#!/bin/sh
#
#   "SystemImager"
#
#   Copyright (C) 1999-2004 Brian Elliott Finley
#
#   $Id$
#

##VERSION_INFO##

# Load functions and other variables
. /etc/init.d/functions

get_arch

##NO_LISTING##
if [ -z $NO_LISTING ]; then
    VERBOSE_OPT="v"
else
    VERBOSE_OPT=""
fi

# Pull in variables left behind by the linuxrc script.
# This information is passed from the linuxrc script on the autoinstall media 
# via /tmp/variables.txt.  Apparently the shell we use in BOEL is not 
# intelligent enough to take a "set -a" parameter.
#
. /tmp/variables.txt || shellout

##SET_IMAGENAME##
##SET_OVERRIDES##

# Get initial information to send to the monitor server.
if [ ! -z $MONITOR_SERVER ]; then
    if [ -z $MONITOR_PORT ]; then
	    MONITOR_PORT=8181
    fi
    mac=`ifconfig $DEVICE | sed -ne "s/.*HWaddr //p" | sed "s/ //g" | sed s/:/./g`
    cpu=`cat /proc/cpuinfo | grep "model name" | sed "s/.*: //" | tr "\n" '|' | sed "s/|$//"`
    mem=`cat /proc/meminfo | sed -ne "s/MemTotal: *//p" | sed "s/ kB//"`
    tmpfs=`df | grep tmpfs | sed "s/.* \([0-9]*%\) .*/\1/"` 
    time=`expr $(cat /proc/uptime | sed "s/\..*//") / 60`
    msg=`echo mac=$mac:ip=$IPADDR:host=$HOSTNAME:cpu=$cpu:mem=$mem:tmpfs=$tmpfs:time=$time:status=$1`
    echo $msg | nc $MONITOR_SERVER $MONITOR_PORT
fi

### BEGIN Check to be sure this not run from a working machine ###
# Test for mounted SCSI or IDE disks
mount | grep [hs]d[a-z][1-9] > /dev/null 2>&1
[ $? -eq 0 ] &&  logmsg Sorry.  Must not run on a working machine... && shellout

# Test for mounted software RAID devices
mount | grep md[0-9] > /dev/null 2>&1
[ $? -eq 0 ] &&  logmsg Sorry.  Must not run on a working machine... && shellout

# Test for mounted hardware RAID disks
mount | grep c[0-9]+d[0-9]+p > /dev/null 2>&1
[ $? -eq 0 ] &&  logmsg Sorry.  Must not run on a working machine... && shellout
### END Check to be sure this not run from a working machine ###


################################################################################
#
#   Stop RAID devices before partitioning begins
#
# Q1) Why did they get started in the first place?  
# A1) So we can pull a local.cfg file off a root mounted software RAID system.
#     They may not be started on your system -- they would only be started if
#     you did the stuff in Q3 below.
#
# Q2) Why didn't my local.cfg on my root mounted software RAID work for me 
#     with the standard kernel flavour?
# A2) The standard kernel flavour uses modules for the software RAID drivers --
#     therefore, software RAID is not available at the point in the boot process
#     where BOEL needs to read the local.cfg file.  They are only pulled over 
#     when this script is run, which is, of course, only runnable if it was
#     pulled over the network using the settings that you would have wanted it
#     to get from the local.cfg file, which it couldn't.  Right?
#
# Q3) Whatever.  So how do I make it work with a local.cfg file on my root
#     mounted software RAID?  
# A3) Compile an autoinstall kernel with software RAID, and any other drivers 
#     you might need built in (filesystem, SCSI drivers, etc.).
#
if [ -f /proc/mdstat ]; then
  RAID_DEVICES=` cat /proc/mdstat | grep ^md | sed 's/ .*$//g' `

  # raidstop will not run unless a raidtab file exists
  echo "" >> /etc/raidtab || shellout

  # turn dem pesky raid devices off!
  for RAID_DEVICE in ${RAID_DEVICES}
  do
    DEV="/dev/${RAID_DEVICE}"
    # we don't do a shellout here because, well I forgot why, but we don't.
    logmsg "raidstop ${DEV}" && raidstop ${DEV}
  done
fi
#
################################################################################

##PARTITION_DISKS##

logmsg "Load additional filesystem drivers."
modprobe reiserfs
modprobe ext2
modprobe ext3
modprobe jfs
modprobe xfs

logmsg "Load device mapper driver (for LVM)."
modprobe dm-mod

### BEGIN LVM initialization commands -AR- ###
##INITIALIZE_LVM_PARTITIONS##
### END LVM initialization commands ###

### BEGIN LVM groups creation commands -AR- ###
##CREATE_LVM_GROUPS##
### END LVM groups creation commands ###

### BEGIN LVM volumes creation commands -AR- ###
##CREATE_LVM_VOLUMES##
### END LVM volumes creation commands ###

### BEGIN swap and filesystem creation commands ###
##CREATE_FILESYSTEMS##
### END swap and filesystem creation commands ###

### BEGIN mount proc in image for tools like System Configurator ###
logmsg "mkdir -p /a/proc || shellout"
mkdir -p /a/proc || shellout
logmsg "mount proc /a/proc -t proc -o defaults || shellout"
mount proc /a/proc -t proc -o defaults || shellout
### END mount proc in image for tools like System Configurator ###

### BEGIN mount sysfs in image for tools that might be run during chroot ###
logmsg "mkdir -p /a/sys || shellout"
mkdir -p /a/sys || shellout
logmsg "mount sysfs /a/sys -t sysfs -o defaults || shellout"
mount sysfs /a/sys -t sysfs -o defaults || shellout
### END mount sysfs in image for tools that might be run during chroot ###

################################################################################
#
#   Lay the image down on the freshly formatted disk(s)
#
if [ ! -z $FLAMETHROWER_DIRECTORY_PORTBASE ]; then 

    # Use multicast 
    MODULE_NAME="${IMAGENAME}"
    DIR=/a
    RETRY=7
    FLAMETHROWER_TARPIPE=y
    flamethrower_client
else 
    # Use rsync 
    if [ $NO_LISTING ]; then
        logmsg "Quietly installing image... "
        start_spinner
    fi
    if [ ! -z $MONITOR_SERVER ]; then
        start_report_task
    fi
    if [ "${TMPFS_STAGING}" = "yes" ]; then 

        # Deposit image into tmpfs
        DIR=/tmp/tmpfs_staging
        logmsg
        logmsg "TMPFS_STAGING=${TMPFS_STAGING} -- Staging in ${DIR}"
        mkdir -p ${DIR}

        logmsg "rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ ${DIR}/" 
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ ${DIR}/ || shellout 

        # Move from staging in tmpfs to disk
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${DIR}/ /a/
    else
        logmsg "rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ /a/" 
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ /a/ || shellout 
    fi
fi 

beep

#
################################################################################


if [ $NO_LISTING ]; then
    stop_spinner
fi

# Leave notice of which image is installed on the client
echo $IMAGENAME > /a/etc/systemimager/IMAGE_LAST_SYNCED_TO || shellout

if [ ! -z $MONITOR_SERVER ]; then
    stop_report_task 100
fi

### BEGIN generate new fstab file from autoinstallscript.conf ###
##GENERATE_FSTAB##
### END generate new fstab file from autoinstallscript.conf ###

################################################################################
#
#   Process override directories
#
for OVERRIDE in $OVERRIDES
do
    if [ ! -z $FLAMETHROWER_DIRECTORY_PORTBASE ]; then
        # Use multicast
        MODULE_NAME="override_${OVERRIDE}"
        DIR=/a
        RETRY=7
	FLAMETHROWER_TARPIPE=y
        flamethrower_client
    else
        # Use rsync
        logmsg "rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /a/"
        rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /a/ || logmsg "Override directory $OVERRIDE doesn't seem to exist, but that may be OK."
    fi
done

beep

#
################################################################################


##################################################################
#
# Uncomment the line below to leave your hostname blank.
# Certain distributions use this as an indication to take on the
# hostname provided by a DHCP server.  The default is to have
# SystemConfigurator assign your clients the hostname that
# corresponds to the IP address the use during the install.
# (If you used to use the static_dhcp option, this is your man.)
#
#HOSTNAME=""


################################################################################
#
# mount /dev /a/dev -o bind if needed
#
##BOEL_DEVSTYLE##
#
################################################################################


################################################################################
#
#   System Configurator
#
# Configure the client's hardware, network interface, and boot loader.
#
##SYSTEMCONFIGURATOR##
#
################################################################################


################################################################################
#
#   Post Install Scripts
#
run_post_install_scripts
#
################################################################################


################################################################################
#
#   Unmount filesystems
#
##UMOUNT_FILESYSTEMS##
#
################################################################################


################################################################################
#
#   Tell the image server we're done
#   
rsync $IMAGESERVER::scripts/imaging_complete > /dev/null 2>&1
#
################################################################################

# Take network interface down
[ -z $DEVICE ] && DEVICE=eth0
ifconfig $DEVICE down || shellout

# Announce completion (even for non beep-incessantly --post-install options)
beep 3

##POSTINSTALL##
