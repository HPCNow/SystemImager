#!/bin/sh

#
# "VA SystemImager" - Copyright (C) 1999-2001 Brian Elliott Finley <brian@valinux.com>
#   Others who have contributed to this code (in alphabetical order):
#     dann frazier <dannf@ldl.fc.hp.com>
#     James Oakley <joakley@solutioninc.com>
#
#
# This file is: installclient
#   This script is a wrapper around the install_client_all rule in the
#   Makefile.  This takes care of upgrade issues and interacting with users.
#


# do we want a quiet install?
QUIET="false"
for cl_option ; do
  case $cl_option in
    -q|-quiet|--quiet ) QUIET="true" ;;
  esac
done

# set some variables
PATH=/usr/local/bin:/usr/local/sbin:/bin:/usr/bin:/sbin:/usr/sbin
COMMAND_PATH=`dirname $0`
test "x$COMMAND_PATH" != "x" && cd $COMMAND_PATH
DESTDIR=`pwd`
VERSION=`cat $DESTDIR/VERSION`

# if not run as root, install will surely fail
[ `whoami` != "root" ] && echo "Must be run as root!" && exit 1

##############################################################################################
### BEGIN functions
##############################################################################################
#!/bin/sh
#
# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#
# Version:	@(#) /etc/init.d/functions 1.01 26-Oct-1993
#
# Author:	Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Hacked by:    Greg Galloway and Marc Ewing
#
# Mercilessly hacked by: "Brian Finley" <brian@valinux.com> 1999.09.18
#                 for: VA SystemImager
#

# First set up a default search path.
export PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"

# Get a sane screen width
[ -z "$COLUMNS" ] && COLUMNS=80

# Read in our configuration
if [ -z "$BOOTUP" ]; then
  if [ -f /etc/sysconfig/init ]; then
      . /etc/sysconfig/init
  else
    # This all seem confusing? Look in /etc/sysconfig/init,
    # or in /usr/doc/initscripts-*/sysconfig.txt
    BOOTUP=color
    RES_COL=60
    MOVE_TO_COL="echo -en \\033[300C\\033[$[${COLUMNS}-${RES_COL}]D"
    SETCOLOR_SUCCESS="echo -en \\033[1;32m"
    SETCOLOR_FAILURE="echo -en \\033[1;31m"
    SETCOLOR_WARNING="echo -en \\033[1;33m"
    SETCOLOR_NORMAL="echo -en \\033[0;39m"
    LOGLEVEL=1
  fi
fi

if [ "$BOOTUP" != "verbose" ]; then
   INITLOG_ARGS="-q"
else
   INITLOG_ARGS=
fi

# A function to start a program.
daemon() {
	# Test syntax.
	gotbase=
	case $1 in
	    '')    echo '$0: Usage: daemon [+/-nicelevel] {program}'
	           return 1;;
	    --check)
	           shift
		   base=$1
		   gotbase="yes"
		   shift
		   nicelevel=0
		   ;;
	          
	    -*|+*) nicelevel=$1
	           shift;;
	     *)    nicelevel=0;;
	esac

        # Save basename.
        [ -z $gotbase ] && base=`basename $1`

        # See if it's already running.
	pid=`pidofproc $base`
	[ -n "$pid" ] && ps h $pid >/dev/null 2>&1 && return

	# make sure it doesn't core dump anywhere; while this could mask
	# problems with the daemon, it also closes some security problems
	ulimit -c 0
	
	# Echo daemon
        [ "$BOOTUP" = "verbose" ] && echo -n " $base"

	# And start it up.
	nice -n $nicelevel initlog $INITLOG_ARGS -c "$*" && success "$base startup" || failure "$base startup"
}

# A function to stop a program.
killproc() {
	# Test syntax.
	if [ $# = 0 ]; then
		echo "Usage: killproc {program} [signal]"
		return 1
	fi

	notset=0
	# check for second arg to be kill level
	if [ "$2" != "" ] ; then
		killlevel=$2
	else
		notset=1
		killlevel="-9"
	fi

        # Save basename.
        base=`basename $1`

        # Find pid.
        pid=`pidofproc $base`

        # Kill it.
        if [ "$pid" != "" ] ; then
                [ $BOOTUP = "verbose" ] && echo -n "$base "
		if [ "$notset" = "1" ] ; then
		       if ps h $pid>/dev/null 2>&1; then
			   # TERM first, then KILL if not dead
			   kill -TERM $pid
			   usleep 100000
			   if ps h $pid >/dev/null 2>&1 ; then
				sleep 1
				if ps h $pid >/dev/null 2>&1 ; then
				        sleep 3
					if ps h $pid >/dev/null 2>&1 ; then
					   kill -KILL $pid
					fi
				fi
			   fi
		        fi
			ps h $pid >/dev/null 2>&1 && failure "$base shutdown" || success "$base shutdown"
		# use specified level only
		else
		        if ps h $pid >/dev/null 2>&1; then
	                	kill $killlevel $pid && success "$base $killlevel" || failure "$base $killlevel"
			fi
		fi
	else
	    failure "$base shutdown"
	fi

        # Remove pid file if any.
	if [ "$notset" = "1" ]; then
            rm -f /var/run/$base.pid
	fi
}

# A function to find the pid of a program.
pidofproc() {
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: pidofproc {program}"
		return 1
	fi

	# First try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo $pid
	                return 0
	        fi
	fi

	# Next try "pidof"
	pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo $pid
	        return 0
	fi

	# Finally try to extract it from ps
	ps ax | awk 'BEGIN { prog=ARGV[1]; ARGC=1 } 
			   { if ((prog == $5) || (("(" prog ")") == $5) ||
			     (("[" prog "]") == $5) ||
			   ((prog ":") == $5)) { print $1 ; exit 0 } }' $1
}

status() {
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: status {program}"
		return 1
	fi

	# First try "pidof"
	pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo "$1 (pid $pid) is running..."
	        return 0
        else
                pid=`ps ax | awk 'BEGIN { prog=ARGV[1]; ARGC=1 } 
			   { if ((prog == $5) || (("(" prog ")") == $5) ||
			     (("[" prog "]") == $5) ||
			   ((prog ":") == $5)) { print $1 ; exit 0 } }' $1`
                if [ "$pid" != "" ] ; then
                        echo "$1 (pid $pid) is running..."
                        return 0
                fi
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo "$1 dead but pid file exists"
	                return 1
	        fi
	fi
	# See if /var/lock/subsys/$1 exists
	if [ -f /var/lock/subsys/$1 ]; then
		echo "$1 dead but subsys locked"
		return 2
	fi
	echo "$1 is stopped"
	return 3
}

echo_success() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "[  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  echo -n "OK"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "  ]"
  return 0
}

echo_failure() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo -n "FAILED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  return 1
}

echo_passed() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo -n "PASSED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  return 1
}

# Log that something succeeded
success() {
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 1
  else
     echo "-n $0 -s \"$1\" -e 1" >&21
  fi
  #[ "$BOOTUP" != "verbose" ] && echo_success
  [ "$BOOTUP" != "verbose" ] && [ $QUIET != "true" ] && echo_success
  return 0
}

# Log that something failed
failure() {
  rc=$?
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 2
  else
     echo "-n $0 -s \"$1\" -e 2" >&21
  fi
  [ "$BOOTUP" != "verbose" ] && echo_failure
  return $rc
}

# Log that something passed, but may have had errors. Useful for fsck
passed() {
  rc=$?
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 1
  else
     echo "-n $0 -s \"$1\" -e 1" >&21
  fi
  [ "$BOOTUP" != "verbose" ] && echo_passed
  return $rc
}  

# Run some action. Log its output.
action() {
  STRING=$1
  echo -n "$STRING "
  shift
  initlog $INITLOG_ARGS -c "$*" && success "$STRING" || failure "$STRING"
  rc=$?
  echo
  return $rc
}

# Confirm whether we really want to run this service
confirm() {
  echo -n "Start service $1 (Y)es/(N)o/(C)ontinue? [Y] "
  read answer
  case $answer in
    y|Y|"")
      return 0
    ;;
    c|C)
      return 2
    ;;
    n|N)
      return 1
    ;;
    *)
      confirm $1
      return $?
    ;;
    esac
}



# VA SystemImager specific functions
create_rsyncd_conf() {
  echo '#'                                                      > /etc/rsyncd.conf
  echo '# "VA SystemImager" - Copyright (C) 1999-2000 Brian Elliott Finley <brian@valinux.com>'    >> /etc/rsyncd.conf
  echo '#'                                                      >> /etc/rsyncd.conf
  echo ''                                                       >> /etc/rsyncd.conf
  echo 'list = yes'                                             >> /etc/rsyncd.conf
  echo 'timeout = 600'                                          >> /etc/rsyncd.conf
  echo 'dont compress = *.gz *.tgz *.zip *.Z *.ZIP *.bz2 *.deb *.rpm *.dbf'  >> /etc/rsyncd.conf
  echo 'uid = root'                                             >> /etc/rsyncd.conf
  echo 'gid = root'                                             >> /etc/rsyncd.conf
  echo 'use chroot = no'                                        >> /etc/rsyncd.conf
  echo 'log file = /var/log/systemimager'                       >> /etc/rsyncd.conf
  echo ''                                                       >> /etc/rsyncd.conf
  echo '# only image entries below this line'                   >> /etc/rsyncd.conf
  echo ''                                                       >> /etc/rsyncd.conf
}
##############################################################################################
### END functions
##############################################################################################



### BEGIN introduction ###
if [ $QUIET = "false" ]; then
  # you sure you want to install?
  echo -n "Install SystemImager client? (y/[n]) "
  read REPLY
  case $REPLY in
    y|Y|Yes|yes|YES ) clear; echo Ok.  Installing SystemImager client... ;;
                  * ) echo Install cancelled.  No files installed. && exit 1 ;;
  esac

  echo
  sleep 2
fi
### END introduction ###

### BEGIN clean up old files ###
echo "Checking for old utilities..."

for file in /usr/sbin/prepareclient /usr/sbin/updateclient /usr/sbin/lsimage; do
    if [ -f "$file" ]; then
	echo "Warning:  $file was found on this system."
	echo "Starting with SystemImager 1.6.0, binaries have moved to /usr/local by default."
	echo "You should probably remove this older version, to make sure it is not executed"
	echo "by mistake."
	echo -n "Shall I remove $file for you? ([y]/n) "
	read REPLY
	case $REPLY in
	    n|N|No|no|NO ) echo "Not removing $file, as requested." ;;
		       * ) rm $file ;;
        esac
    fi
done

echo "Checking for old config files..."
CONFIG_FILES="/etc/systemimager/updateclient.local.exclude:./tftpstuff/systemimager/updateclient.local.exclude"

for file in $CONFIG_FILES; do
    old=`echo $file | cut -d ":" -f 1`
    new=`echo $file | cut -d ":" -f 2`
    if [ -f "$old" ]; then
	diff $old $new > /dev/null
	if [ $? -ne 0 ]; then
	    echo "Warning: $old already exists, but it differs from the one I am going to install."
	    echo "I'm going to move this file to $old.beforesystemimager$VERSION."
	    echo "Press enter to continue."
	    read
	    mv $old $old.beforesystemimager$VERSION
	fi
    fi
done    

### BEGIN make install_client_all
echo "Running 'make install_client_all'..."
make install_client_all DESTDIR=/tmp/foo
if [ $? -ne 0 ]; then
    echo "Install failed - hopefully the messages above will help you debug the problem."
    exit 1
fi
### END make install_client_all
    
if [ $QUIET = "false" ]; then 
   echo "You must run \"prepareclient\" before you can retrieve this clients image."
   echo -n "Do you want to run \"prepareclient\" now? ([y]/n) "
   read REPLY
   case $REPLY in
           n|N|No|no|NO ) echo \"prepareclient\" not run.
                          echo Be sure to run \"prepareclient\" before you run \"getimage\" on the imageserver.
                          exit 0
                          ;;
                      * ) prepareclient ;;
   esac
fi

exit 0
