package SystemImager::Server;

# put copyright here

=head1 NAME

SystemImager::Server - Server specific module.

=head1 SYNOPSIS

#  my $bootloader = new SystemConfig::Boot::Grub(%bootvars);
#
#  if($bootloader->footprint()) {
#      $bootloader->setup();
#  }
#
#  my @fileschanged = $bootloader->files();

=cut

use strict;

$version_number="1.5.0";
$VERSION = $version_number;

push @SystemConfig::Boot::boottypes, qw(SystemConfig::Boot::Grub);

sub new {
    my $class = shift;
    my %this = (
                root => "",
                filesmod => [],
		grub_path => "",       ### Path to Grub executable.
		device_map_file => "", ### Device map file
		boot_inst_dev => "",   ### Device to which to install boot image.
		default_root => "",    ### The default root device. 
                @_,
               );
    bless \%this, $class;
}

=head1 METHODS

The following methods exist in this module:

=over 4

=item files()

The files() method is merely an accessor method for the all files
touched by the instance during its run.

=cut

sub files {
    my $this = shift;
    return @{$this->{filesmod}};
}

=item footprint()

This method returns 1 if executable Grub bootloader is installed. 

=cut

sub footprint {
    my $this = shift;
    my $exitval;

    ### Let's see if Grub is installed in the system. 
    $this->{grub_path} = which("grub");

    chomp($this->{grub_path});

    return $this->{grub_path};
}

=item dev2bios()

This method is used as an "internal" method.
It takes a path to the device as the argument and returns device syntax ( 
matching an entry in the device map file) used by Grub 

=cut

sub dev2bios {
# Searches for and converts "/dev/ ..."  to device syntax used by Grub from the device map file.
# Arg: path to the device.

    my ($devpath, $device, $devpart, $mapfile);
    my $this = shift;
    my $biosdev = "";

    $devpath = shift;

    $devpath =~ /^(\/dev\/.+?)(\d*?)$/; # extract partition number and device name
    $device = $1;                     # from the device path.  
    $devpart = $2;

    if ($device) { ### Empty string could have been passed as the input param
      $mapfile = $this->{device_map_file};
      open(MAPFH,"<$mapfile") 
	or croak("Couldn't open $this->{device_map_file} for reading");
      
      while(<MAPFH>) {
	if (/(\(.+)\)\s+$device/) {
	  if ($devpart) {
	    $devpart--; # Partition number starts from 0
	    $biosdev = "$1,$devpart)";
	  }
	  else {
	    $biosdev = "$1)";
	  }
	  last;
	}
      }
      close(MAPFH);
    }
    $biosdev;
}

=item make_autoinstall_script()

This method creates an autoinstall script for an image.

=cut

# put code here

=item setup()

This method read the System Configurator's config file and translates it
into the bootloader's "native" config file. 

=cut

sub setup {
    my $this = shift;
    my ($timeout, $defaultbootnum, $output, $exitval);
    my $counter = 0;
    
    ### First, check to see if the device map file exists, if it doesn't
    ### let's create one. It will make our job much easier.
    $this->{device_map_file} = $this->{root} . "/boot/grub/device.map";
    my $command = "" . <<"EOL";
$this->{grub_path} --device-map=$this->{device_map_file} 2>&1 << ETO 
ETO
EOL
    unless (-e "$this->{device_map_file}") { 
	$output = qx/$command/;
	$exitval = $? >> 8;
	if ($exitval) {
	    croak("Error: cannot create the device map file!\n$output\n");
	}
    }

    ### Identify path to the default root device
    $this->{default_root} = $this->dev2bios($this->{boot_rootdev});

    ### Set up the boot device, if we can. 
    $this->{boot_inst_dev} = $this->dev2bios($this->{boot_bootdev});
    unless ($this->{boot_inst_dev}) {
	$this->{boot_inst_dev} = $this->{default_root};
    }

    ### Open the native bootloader config file for write.
    my $file = $this->{root} . "/boot/grub/menu.lst";

    open(OUT,">$file") or croak("Couldn't open $file for writing");
    print OUT "##################################################\n";
    print OUT "# This file is generated by System Configurator. #\n";
    print OUT "##################################################\n";
    print OUT "\n";

    print OUT "#----- Global Options -----#\n";

    ### Timeout
    if ($this->{boot_timeout}) {
	$timeout = $this->{boot_timeout} / 10; # User specifies timeout in deciseconds
	print OUT "# The number of seconds to wait before booting. \n";
	print OUT "timeout " . $timeout . "\n";
    }
   
    ### default kernel image to boot with
    print OUT "# The default kernel image to boot. \n";
    undef $defaultbootnum;

    DBOUT: foreach my $key (sort keys %$this) {
        if ($key =~ /^(kernel\d+)_label/) {
	    if ($this->{$key} eq $this->{boot_defaultboot}) {
		### Order of default kernel image. 
		$defaultbootnum = $counter;
		### If boot device is not specified, set it up with the default root device. 
		### I know this is sort of off the track, but since we know the default root device
		### why not set up the boot device now? This is more efficient. 
		unless ($this->{boot_inst_dev}) {
		    if ($this->{$1 . "_rootdev"}) {
			$this->{boot_inst_dev} = $this->dev2bios($this->{$1 . "_rootdev"});
		    }
		    else {
			croak("Error: Boot device can not be derived. \n");
		    }
		}
		### If the user has specified ROOTDEV for this kernel image, then override value previously
		### put into $this->{default_root}. 
		if ($this->{$1 . "_rootdev"}) {
		    $this->{default_root} = $this->dev2bios($this->{$1 . "_rootdev"})
		    }
		last DBOUT;
	    }
	    $counter++;
	}
    }
    unless (defined $defaultbootnum) {
	croak("Error: default kernel image cannot be identified. \n"); 
    }
    print OUT "default " . $defaultbootnum . "\n";
    print OUT "\n";

    foreach my $key (sort keys %$this) {
        if ($key =~ /^(kernel\d+)_path/) {
            $this->setup_kernel($1,\*OUT);
        }
    }

    close(OUT);
    
    ### "TESTRUN" option will only create the config file.
    ### If ON, the boot image will not be installed.
    unless($this->{boot_testrun}) {
        $this->commit();
    }
    
    ### To be part of the exclusion files
    push @{$this->{filesmod}}, "$file";

    ### Indicate that Grub has been successfully installed.
    1;
}

=item setup_kernel()

An "internal" method.
This method sets up a kernel image as specified in the config file.

=cut

sub setup_kernel {
    my ($this, $image, $outfh) = @_;
    my ($append, $deviceline);
    my ($rootpath, $kernelcom);

    print $outfh "#----- Options for \U$image -----#\n";

    ### label
    print $outfh "### Label for $image. \n";
    print $outfh "title " . $this->{$image . "_label"} . "\n";    

    ### Specify device to be mounted as the root
    undef $rootpath;
    if ($this->{$image. "_rootdev"}) { 
	$rootpath = $this->{$image. "_rootdev"}; #rootdev option specified for the image
    }
    elsif ($this->{boot_rootdev}) {
	$rootpath = $this->{boot_rootdev}; #rootdev global option
    }
    if (defined $rootpath) {
	# At this point ".../boot/grub/device.map" should exist since we issued commnad to creat it
	# if it didn't exist before.
	print $outfh "### Device to be mounted as the root. \n";
	print $outfh "root " . 
	    $this->dev2bios($rootpath) . " \n";
    }
    
    ### Check for command line kernel options. 
    $kernelcom = "kernel " . $this->{$image . "_path"} . " root=" . $rootpath . " ro";
    if ($this->{$image. "_append"})
    {
	$kernelcom = $kernelcom . " " . $this->{$image . "_append"} . "\n";
    }
    elsif ($this->{boot_append}) {
	$kernelcom = $kernelcom . " " . $this->{boot_append} . " \n";
    }
    else {
	$kernelcom = $kernelcom . "\n";
    }
    print $outfh "### Kernel command. \n";
    print $outfh $kernelcom;

    ### Initrd image
    if ($this->{$image. "_initrd"})
    {
	print $outfh "### initrd \n";
	print $outfh "initrd " . $this->{$image . "_initrd"} . "\n";
    }        
    print $outfh "\n";
}

=back

=head1 AUTHOR

  Brian Finley <brian@thefinleys.com>

=head1 SEE ALSO

L<SystemImager::Client>, L<SystemImager::Common>, L<perl>

=cut

1;




















