*******************************************************************************
* this patch is a superset of patches, combined to eliminate the possibility  *
* of conflicts.  patches in this version include:                             *
* - all patches included in the kernel-image-2.4.9-ia64-010820.4 package      *
* - a patch for building with newer binutils                                  *
* - a patch to tell gcc to optimize for size                                  *
*******************************************************************************

diff -urN linux.orig/Documentation/Configure.help linux/Documentation/Configure.help
--- linux.orig/Documentation/Configure.help	Sun Aug 12 11:51:41 2001
+++ linux/Documentation/Configure.help	Mon Dec 17 20:27:40 2001
@@ -2423,6 +2423,14 @@
   say N here to save some memory. You can also say Y if you have an
   "intelligent" multiport card such as Cyclades, Digiboards, etc.
 
+Support for serial ports defined by ACPI tables
+CONFIG_SERIAL_ACPI
+  Legacy free machines may not have serial ports at the legacy COM1, 
+  COM2 etc addresses. Serial ports on such machines are described by
+  the ACPI tables SPCR (Serial Port Console Redirection) table and 
+  DBGP (Debug Port) table. Say Y here if you want to include support
+  for these serial ports.
+
 Support for sharing serial interrupts
 CONFIG_SERIAL_SHARE_IRQ
   Some serial boards have hardware support which allows multiple dumb
@@ -2533,6 +2541,16 @@
   the GLX component for XFree86 3.3.6, which can be downloaded from
   http://utah-glx.sourceforge.net/ .
 
+Intel 460GX support
+CONFIG_AGP_I460
+  This option gives you AGP support for the Intel 460GX chipset.  This
+  chipset, the first to support Intel Itanium processors, is new and
+  this option is correspondingly a little experimental.
+
+  If you don't have a 460GX based machine (such as BigSur) with an AGP 
+  slot then this option isn't going to do you much good.  If you're
+  dying to do Direct Rendering on IA-64, this is what you're looking for.
+
 Intel I810/I810 DC100/I810e support
 CONFIG_AGP_I810
   This option gives you AGP support for the Xserver on the Intel 810
@@ -8877,6 +8895,16 @@
   say M here and read Documentation/modules.txt. This is recommended.
   The module will be called sk98lin.o.
 
+Broadcom NetXtreme BCM5700 Gigabit Ethernet support
+CONFIG_NET_BROADCOM
+  Say Y here if you have a Broadcom BCM5700/BCM5701, or 3Com
+  3C996/3C997/3C1000/3C940 PCI/PCIX Gigabit Ethernet adapter.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called bcm5700.o.
+
 MyriCOM Gigabit Ethernet support
 CONFIG_MYRI_SBUS
   This driver supports MyriCOM Sbus gigabit ethernet cards.
@@ -12559,6 +12587,18 @@
   Say Y here if you would like to be able to read the hard disk
   partition table format used by SGI machines.
 
+Intel EFI GUID partition support
+CONFIG_EFI_PARTITION
+  Say Y here if you would like to use hard disks under Linux which
+  were partitioned using EFI GPT.  Presently only useful on the
+  IA-64 platform.
+
+/dev/guid support (EXPERIMENTAL)
+CONFIG_DEVFS_GUID
+  Say Y here if you would like to access disks and partitions by
+  their Globally Unique Identifiers (GUIDs) which will appear as
+  symbolic links in /dev/guid.
+
 Ultrix partition support
 CONFIG_ULTRIX_PARTITION
   Say Y here if you would like to be able to read the hard disk
@@ -18395,56 +18435,13 @@
 
   If you don't know what to do, choose 8KB.
 
-Enable Itanium A-step specific code
-CONFIG_ITANIUM_ASTEP_SPECIFIC
-  Select this option to build a kernel for an Itanium prototype system
-  with an A-step CPU.  You have an A-step CPU if the "revision" field in
-  /proc/cpuinfo is 0.
-
 Enable Itanium B-step specific code
 CONFIG_ITANIUM_BSTEP_SPECIFIC
   Select this option to build a kernel for an Itanium prototype system
-  with a B-step CPU.  You have a B-step CPU if the "revision" field in
-  /proc/cpuinfo has a value in the range from 1 to 4.
-
-Enable Itanium B0-step specific code
-CONFIG_ITANIUM_B0_SPECIFIC
-  Select this option to bild a kernel for an Itanium prototype system
-  with a B0-step CPU.  You have a B0-step CPU if the "revision" field in
-  /proc/cpuinfo is 1.
-
-Force interrupt redirection
-CONFIG_IA64_HAVE_IRQREDIR
-  Select this option if you know that your system has the ability to
-  redirect interrupts to different CPUs.  Select N here if you're
-  unsure.
-
-Enable use of global TLB purge instruction (ptc.g)
-CONFIG_ITANIUM_PTCG
-  Say Y here if you want the kernel to use the IA-64 "ptc.g"
-  instruction to flush the TLB on all CPUs.  Select N here if
-  you're unsure.
-
-Enable SoftSDV hacks
-CONFIG_IA64_SOFTSDV_HACKS
-  Say Y here to enable hacks to make the kernel work on the Intel
-  SoftSDV simulator.  Select N here if you're unsure.
-
-Enable AzusA hacks
-CONFIG_IA64_AZUSA_HACKS
-  Say Y here to enable hacks to make the kernel work on the NEC
-  AzusA platform.  Select N here if you're unsure.
-
-Force socket buffers below 4GB?
-CONFIG_SKB_BELOW_4GB
-  Most of today's network interface cards (NICs) support DMA to
-  the low 32 bits of the address space only.  On machines with
-  more then 4GB of memory, this can cause the system to slow
-  down if there is no I/O TLB hardware.  Turning this option on
-  avoids the slow-down by forcing socket buffers to be allocated
-  from memory below 4GB.  The downside is that your system could
-  run out of memory below 4GB before all memory has been used up.
-  If you're unsure how to answer this question, answer Y.
+  with a B-step CPU.  Only B3 step CPUs are supported.  You have a B3-step
+  CPU if the "revision" field in /proc/cpuinfo is equal to 4.  If the
+  "revision" field shows a number bigger than 4, you do not have to turn
+  on this option.
 
 Enable IA-64 Machine Check Abort
 CONFIG_IA64_MCA
@@ -18464,6 +18461,15 @@
   Layer) information in /proc/pal.  This contains useful information
   about the processors in your systems, such as cache and TLB sizes
   and the PAL firmware version in use.
+
+  To use this option, you have to check that the "/proc file system
+  support" (CONFIG_PROC_FS) is enabled, too.
+
+/proc/efi/vars support
+CONFIG_EFI_VARS
+  If you say Y here, you are able to get EFI (Extensible Firmware
+  Interface) variable information in /proc/efi/vars.  You may read,
+  write, create, and destroy EFI variables through this interface.
 
   To use this option, you have to check that the "/proc file system
   support" (CONFIG_PROC_FS) is enabled, too.
diff -urN linux.orig/Makefile linux/Makefile
--- linux.orig/Makefile	Thu Aug 16 12:12:49 2001
+++ linux/Makefile	Mon Dec 17 20:27:40 2001
@@ -87,7 +87,7 @@
 
 CPPFLAGS := -D__KERNEL__ -I$(HPATH)
 
-CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -O2 \
+CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
 	  -fomit-frame-pointer -fno-strict-aliasing -fno-common
 AFLAGS := -D__ASSEMBLY__ $(CPPFLAGS)
 
@@ -136,7 +136,8 @@
 	drivers/net/net.o \
 	drivers/media/media.o
 DRIVERS-$(CONFIG_AGP) += drivers/char/agp/agp.o
-DRIVERS-$(CONFIG_DRM) += drivers/char/drm/drm.o
+DRIVERS-$(CONFIG_DRM_NEW) += drivers/char/drm/drm.o
+DRIVERS-$(CONFIG_DRM_OLD) += drivers/char/drm-4.0/drm.o
 DRIVERS-$(CONFIG_NUBUS) += drivers/nubus/nubus.a
 DRIVERS-$(CONFIG_ISDN) += drivers/isdn/isdn.a
 DRIVERS-$(CONFIG_NET_FC) += drivers/net/fc/fc.o
@@ -232,14 +233,14 @@
 
 include arch/$(ARCH)/Makefile
 
-export	CPPFLAGS CFLAGS AFLAGS
+export	CPPFLAGS CFLAGS CFLAGS_KERNEL AFLAGS AFLAGS_KERNEL
 
 export	NETWORKS DRIVERS LIBS HEAD LDFLAGS LINKFLAGS MAKEBOOT ASFLAGS
 
 .S.s:
-	$(CPP) $(AFLAGS) -traditional -o $*.s $<
+	$(CPP) $(AFLAGS) $(AFLAGS_KERNEL) -traditional -o $*.s $<
 .S.o:
-	$(CC) $(AFLAGS) -traditional -c -o $*.o $<
+	$(CC) $(AFLAGS) $(AFLAGS_KERNEL) -traditional -c -o $*.o $<
 
 Version: dummy
 	@rm -f include/linux/compile.h
diff -urN linux.orig/arch/i386/lib/usercopy.c linux/arch/i386/lib/usercopy.c
--- linux.orig/arch/i386/lib/usercopy.c	Fri Apr 13 21:26:07 2001
+++ linux/arch/i386/lib/usercopy.c	Mon Dec 17 20:27:40 2001
@@ -44,6 +44,7 @@
 unsigned long
 __generic_copy_to_user(void *to, const void *from, unsigned long n)
 {
+	prefetch(from);
 	if (access_ok(VERIFY_WRITE, to, n))
 		__copy_user(to,from,n);
 	return n;
@@ -52,6 +53,7 @@
 unsigned long
 __generic_copy_from_user(void *to, const void *from, unsigned long n)
 {
+	prefetchw(to);
 	if (access_ok(VERIFY_READ, from, n))
 		__copy_user_zeroing(to,from,n);
 	else
diff -urN linux.orig/arch/ia64/Makefile linux/arch/ia64/Makefile
--- linux.orig/arch/ia64/Makefile	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/Makefile	Mon Dec 17 20:27:40 2001
@@ -105,7 +105,7 @@
 
 compressed: vmlinux
 	$(OBJCOPY) --strip-all vmlinux vmlinux-tmp
-	gzip -9 vmlinux-tmp
+	gzip vmlinux-tmp
 	mv vmlinux-tmp.gz vmlinux.gz
 
 rawboot:
diff -urN linux.orig/arch/ia64/config.in linux/arch/ia64/config.in
--- linux.orig/arch/ia64/config.in	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/config.in	Mon Dec 17 20:27:40 2001
@@ -51,25 +51,6 @@
 if [ "$CONFIG_ITANIUM" = "y" ]; then
 	define_bool CONFIG_IA64_BRL_EMU y
 	bool '  Enable Itanium B-step specific code' CONFIG_ITANIUM_BSTEP_SPECIFIC
-	if [ "$CONFIG_ITANIUM_BSTEP_SPECIFIC" = "y" ]; then
-	  bool '   Enable Itanium B0-step specific code' CONFIG_ITANIUM_B0_SPECIFIC
-        fi
-	if [ "$CONFIG_ITANIUM_BSTEP_SPECIFIC" = "y" ]; then
-	  bool '   Enable Itanium B1-step specific code' CONFIG_ITANIUM_B1_SPECIFIC
-	fi
-	if [ "$CONFIG_ITANIUM_BSTEP_SPECIFIC" = "y" ]; then
-	  bool '   Enable Itanium B2-step specific code' CONFIG_ITANIUM_B2_SPECIFIC
-	fi
-	bool '  Enable Itanium C-step specific code' CONFIG_ITANIUM_CSTEP_SPECIFIC
-	if [ "$CONFIG_ITANIUM_CSTEP_SPECIFIC" = "y" ]; then
-	  bool '   Enable Itanium C0-step specific code' CONFIG_ITANIUM_C0_SPECIFIC
-	fi
-	if [ "$CONFIG_ITANIUM_B0_SPECIFIC" = "y" \
-	     -o "$CONFIG_ITANIUM_B1_SPECIFIC" = "y" -o "$CONFIG_ITANIUM_B2_SPECIFIC" = "y" ]; then
-	  define_bool CONFIG_ITANIUM_PTCG n
-	else
-	  define_bool CONFIG_ITANIUM_PTCG y
-	fi
 	if [ "$CONFIG_IA64_SGI_SN1" = "y" ]; then
 	  define_int CONFIG_IA64_L1_CACHE_SHIFT 7 # align cache-sensitive data to 128 bytes
 	else
@@ -78,16 +59,15 @@
 fi
 
 if [ "$CONFIG_MCKINLEY" = "y" ]; then
-	define_bool CONFIG_ITANIUM_PTCG y
 	define_int CONFIG_IA64_L1_CACHE_SHIFT 7
 	bool '  Enable McKinley A-step specific code' CONFIG_MCKINLEY_ASTEP_SPECIFIC
 	if [ "$CONFIG_MCKINLEY_ASTEP_SPECIFIC" = "y" ]; then
 	  bool '   Enable McKinley A0/A1-step specific code' CONFIG_MCKINLEY_A0_SPECIFIC
 	fi
+	bool '  Enable Hewlett-Packard prototype suport' CONFIG_IA64_HP_PROTO
 fi
 
 if [ "$CONFIG_IA64_DIG" = "y" ]; then
-	bool '  Force interrupt redirection' CONFIG_IA64_HAVE_IRQREDIR
 	bool '  Enable IA-64 Machine Check Abort' CONFIG_IA64_MCA
 	define_bool CONFIG_PM y
 fi
@@ -109,6 +89,7 @@
 define_bool CONFIG_KCORE_ELF y	# On IA-64, we always want an ELF /proc/kcore.
 
 bool 'SMP support' CONFIG_SMP
+tristate 'Support running of Linux/x86 binaries' CONFIG_IA32_SUPPORT
 bool 'Performance monitor support' CONFIG_PERFMON
 tristate '/proc/pal support' CONFIG_IA64_PALINFO
 tristate '/proc/efi/vars support' CONFIG_EFI_VARS
@@ -271,12 +252,6 @@
 comment 'Kernel hacking'
 
 #bool 'Debug kmalloc/kfree' CONFIG_DEBUG_MALLOC
-if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
-  tristate 'Kernel support for IA-32 emulation' CONFIG_IA32_SUPPORT
-  tristate 'Kernel FP software completion' CONFIG_MATHEMU
-else
-  define_bool CONFIG_MATHEMU y
-fi
 
 bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
 bool 'Early printk support (requires VGA!)' CONFIG_IA64_EARLY_PRINTK
diff -urN linux.orig/arch/ia64/defconfig linux/arch/ia64/defconfig
--- linux.orig/arch/ia64/defconfig	Thu Jun 22 08:09:44 2000
+++ linux/arch/ia64/defconfig	Mon Dec 17 20:27:40 2001
@@ -3,53 +3,128 @@
 #
 
 #
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+# CONFIG_KMOD is not set
+
+#
 # General setup
 #
 CONFIG_IA64=y
 # CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_MCA is not set
 # CONFIG_SBUS is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_INTERPRETER=y
+CONFIG_ACPI_KERNEL_CONFIG=y
+CONFIG_ITANIUM=y
+# CONFIG_MCKINLEY is not set
 # CONFIG_IA64_GENERIC is not set
-CONFIG_IA64_HP_SIM=y
-# CONFIG_IA64_SGI_SN1_SIM is not set
-# CONFIG_IA64_DIG is not set
+CONFIG_IA64_DIG=y
+# CONFIG_IA64_HP_SIM is not set
+# CONFIG_IA64_SGI_SN1 is not set
 # CONFIG_IA64_PAGE_SIZE_4KB is not set
 # CONFIG_IA64_PAGE_SIZE_8KB is not set
 CONFIG_IA64_PAGE_SIZE_16KB=y
 # CONFIG_IA64_PAGE_SIZE_64KB is not set
+CONFIG_IA64_BRL_EMU=y
+CONFIG_ITANIUM_BSTEP_SPECIFIC=y
+CONFIG_IA64_L1_CACHE_SHIFT=6
+CONFIG_IA64_MCA=y
+CONFIG_PM=y
 CONFIG_KCORE_ELF=y
-# CONFIG_SMP is not set
-# CONFIG_PERFMON is not set
-# CONFIG_NET is not set
-# CONFIG_SYSVIPC is not set
+CONFIG_SMP=y
+CONFIG_PERFMON=y
+CONFIG_IA64_PALINFO=y
+CONFIG_EFI_VARS=y
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-# CONFIG_BINFMT_ELF is not set
+CONFIG_SYSCTL=y
+CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
+# CONFIG_ACPI_DEBUG is not set
+# CONFIG_ACPI_BUSMGR is not set
+# CONFIG_ACPI_SYS is not set
+# CONFIG_ACPI_CPU is not set
+# CONFIG_ACPI_BUTTON is not set
+# CONFIG_ACPI_AC is not set
+# CONFIG_ACPI_EC is not set
+# CONFIG_ACPI_CMBATT is not set
+# CONFIG_ACPI_THERMAL is not set
 CONFIG_PCI=y
 CONFIG_PCI_NAMES=y
 # CONFIG_HOTPLUG is not set
 # CONFIG_PCMCIA is not set
 
 #
-# Code maturity level options
+# Parallel port support
 #
-CONFIG_EXPERIMENTAL=y
+# CONFIG_PARPORT is not set
 
 #
-# Loadable module support
+# Networking options
 #
-# CONFIG_MODULES is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+# CONFIG_NETLINK is not set
+# CONFIG_NETFILTER is not set
+CONFIG_FILTER=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
 
 #
-# Parallel port support
+# QoS and/or fair queueing
 #
-# CONFIG_PARPORT is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
 
 #
 # Plug and Play configuration
 #
 # CONFIG_PNP is not set
 # CONFIG_ISAPNP is not set
+# CONFIG_PNPBIOS is not set
 
 #
 # Block devices
@@ -58,14 +133,12 @@
 # CONFIG_BLK_DEV_XD is not set
 # CONFIG_PARIDE is not set
 # CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
-
-#
-# Additional Block Devices
-#
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
 
 #
 # I2O device support
@@ -73,10 +146,22 @@
 # CONFIG_I2O is not set
 # CONFIG_I2O_PCI is not set
 # CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
 # CONFIG_I2O_SCSI is not set
 # CONFIG_I2O_PROC is not set
 
 #
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
 # ATA/IDE/MFM/RLL support
 #
 CONFIG_IDE=y
@@ -92,12 +177,21 @@
 # CONFIG_BLK_DEV_HD_IDE is not set
 # CONFIG_BLK_DEV_HD is not set
 CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_IDEDISK_MULTI_MODE=y
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
 # CONFIG_BLK_DEV_IDECS is not set
 CONFIG_BLK_DEV_IDECD=y
 # CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
+CONFIG_BLK_DEV_IDEFLOPPY=y
+CONFIG_BLK_DEV_IDESCSI=y
 
 #
 # IDE chipset support/bugfixes
@@ -110,44 +204,203 @@
 CONFIG_IDEPCI_SHARE_IRQ=y
 CONFIG_BLK_DEV_IDEDMA_PCI=y
 # CONFIG_BLK_DEV_OFFBOARD is not set
-CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_PCI_AUTO is not set
 CONFIG_BLK_DEV_IDEDMA=y
-CONFIG_IDEDMA_PCI_EXPERIMENTAL=y
 # CONFIG_IDEDMA_PCI_WIP is not set
 # CONFIG_IDEDMA_NEW_DRIVE_LISTINGS is not set
-# CONFIG_BLK_DEV_AEC6210 is not set
-# CONFIG_AEC6210_TUNING is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_AEC62XX_TUNING is not set
 # CONFIG_BLK_DEV_ALI15X3 is not set
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD7409 is not set
 # CONFIG_AMD7409_OVERRIDE is not set
 # CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_CMD64X_RAID is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
 # CONFIG_BLK_DEV_CS5530 is not set
 # CONFIG_BLK_DEV_HPT34X is not set
 # CONFIG_HPT34X_AUTODMA is not set
 # CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_HPT366_FIP is not set
-# CONFIG_HPT366_MODE3 is not set
 CONFIG_BLK_DEV_PIIX=y
-CONFIG_PIIX_TUNING=y
+# CONFIG_PIIX_TUNING is not set
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_OPTI621 is not set
 # CONFIG_BLK_DEV_PDC202XX is not set
 # CONFIG_PDC202XX_BURST is not set
-# CONFIG_PDC202XX_MASTER is not set
+# CONFIG_BLK_DEV_OSB4 is not set
 # CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
 # CONFIG_BLK_DEV_TRM290 is not set
 # CONFIG_BLK_DEV_VIA82CXXX is not set
 # CONFIG_IDE_CHIPSETS is not set
-CONFIG_IDEDMA_AUTO=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_DMA_NONPCI is not set
 CONFIG_BLK_DEV_IDE_MODES=y
 
 #
 # SCSI support
 #
-# CONFIG_SCSI is not set
+CONFIG_SCSI=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_SD_EXTRA_DEVS=40
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_DEBUG_QUEUES=y
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_NCR53C8XX is not set
+# CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+CONFIG_SCSI_QLOGIC_1280=y
+# CONFIG_SCSI_QLOGIC_QLA2100 is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_APRICOT is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_TULIP is not set
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_DGRS is not set
+# CONFIG_DM9102 is not set
+CONFIG_EEPRO100=y
+# CONFIG_LNE390 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139TOO is not set
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+# CONFIG_DL2K is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
 
 #
 # Amateur Radio support
@@ -165,13 +418,27 @@
 # CONFIG_CD_NO_IDESCSI is not set
 
 #
+# Input core support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_KEYBDEV=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+
+#
 # Character devices
 #
-# CONFIG_VT is not set
-# CONFIG_SERIAL is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_SERIAL=y
+CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_UNIX98_PTYS is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
 
 #
 # I2C support
@@ -182,97 +449,337 @@
 # Mice
 #
 # CONFIG_BUSMOUSE is not set
-# CONFIG_MOUSE is not set
+CONFIG_MOUSE=y
+CONFIG_PSMOUSE=y
+# CONFIG_82C710_MOUSE is not set
+# CONFIG_PC110_PAD is not set
 
 #
 # Joysticks
 #
 # CONFIG_JOYSTICK is not set
+
+#
+# Input core support is needed for joysticks
+#
 # CONFIG_QIC02_TAPE is not set
 
 #
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
+# CONFIG_INTEL_RNG is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
 CONFIG_EFI_RTC=y
-
-#
-# Video For Linux
-#
-# CONFIG_VIDEO_DEV is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
 
 #
 # Ftape, the floppy tape device driver
 #
 # CONFIG_FTAPE is not set
-# CONFIG_DRM is not set
-# CONFIG_DRM_TDFX is not set
-# CONFIG_AGP is not set
+CONFIG_AGP=y
+# CONFIG_AGP_INTEL is not set
+CONFIG_AGP_I460=y
+# CONFIG_AGP_I460_FULLRQ is not set
+# CONFIG_AGP_I810 is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_AGP_AMD is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_SWORKS is not set
+CONFIG_AGP_PTE_FIXUPS=y
+CONFIG_DRM=y
+CONFIG_DRM_TDFX=y
+# CONFIG_DRM_GAMMA is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_MGA is not set
 
 #
-# USB support
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+CONFIG_VIDEO_PROC_FS=y
+# CONFIG_I2C_PARPORT is not set
+
 #
-# CONFIG_USB is not set
+# Video Adapters
+#
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_ZR36120 is not set
+# CONFIG_VIDEO_MEYE is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_GEMTEK_PCI is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_MIROPCM20 is not set
+# CONFIG_RADIO_MIROPCM20_RDS is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
 
 #
 # File systems
 #
 # CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
 # CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
 # CONFIG_BFS_FS is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_MSDOS_FS is not set
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
 # CONFIG_UMSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
+CONFIG_VFAT_FS=y
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
 # CONFIG_CRAMFS is not set
-# CONFIG_ISO9660_FS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_RAMFS is not set
+CONFIG_ISO9660_FS=y
 # CONFIG_JOLIET is not set
 # CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
 # CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
 # CONFIG_HPFS_FS is not set
-# CONFIG_PROC_FS is not set
+CONFIG_PROC_FS=y
 # CONFIG_DEVFS_FS is not set
 # CONFIG_DEVFS_MOUNT is not set
 # CONFIG_DEVFS_DEBUG is not set
-# CONFIG_DEVPTS_FS is not set
+CONFIG_DEVPTS_FS=y
 # CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
 # CONFIG_ROMFS_FS is not set
-# CONFIG_EXT2_FS is not set
+CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
 # CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
 # CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_ROOT_NFS is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
 
 #
 # Partition Types
 #
 # CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
-# CONFIG_NLS is not set
-# CONFIG_NLS is not set
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Console drivers
+#
+CONFIG_VGA_CONSOLE=y
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
 
 #
 # Sound
 #
-# CONFIG_SOUND is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+CONFIG_SOUND_CS4281=y
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Controllers
+#
+CONFIG_USB_UHCI_ALT=y
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+# CONFIG_USB_HID is not set
+CONFIG_USB_KBD=y
+CONFIG_USB_MOUSE=y
+# CONFIG_USB_WACOM is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+CONFIG_USB_IBMCAM=y
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_DABUSB is not set
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_PLUSB is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_NET1080 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB misc drivers
+#
+# CONFIG_USB_RIO500 is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
 
 #
 # Kernel hacking
 #
-# CONFIG_IA32_SUPPORT is not set
-# CONFIG_MATHEMU is not set
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_IA64_EARLY_PRINTK is not set
+CONFIG_IA32_SUPPORT=y
+CONFIG_MATHEMU=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_IA64_EARLY_PRINTK=y
 # CONFIG_IA64_DEBUG_CMPXCHG is not set
 # CONFIG_IA64_DEBUG_IRQ is not set
-# CONFIG_IA64_PRINT_HAZARDS is not set
-# CONFIG_KDB is not set
+CONFIG_IA64_PRINT_HAZARDS=y
+# CONFIG_DISABLE_VHPT is not set
diff -urN linux.orig/arch/ia64/ia32/binfmt_elf32.c linux/arch/ia64/ia32/binfmt_elf32.c
--- linux.orig/arch/ia64/ia32/binfmt_elf32.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/ia32/binfmt_elf32.c	Mon Dec 17 20:27:40 2001
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1999 Arun Sharma <arun.sharma@intel.com>
  * Copyright (C) 2001 Hewlett-Packard Co
- * Copyright (C) 2001 David Mosberger-Tang <davidm@hpl.hp.com>
+ *	David Mosberger-Tang <davidm@hpl.hp.com>
  *
  * 06/16/00	A. Mallick	initialize csd/ssd/tssd/cflg for ia32_load_state
  * 04/13/01	D. Mosberger	dropped saving tssd in ar.k1---it's not needed
@@ -51,16 +51,13 @@
 /* Global descriptor table */
 unsigned long *ia32_gdt_table, *ia32_tss;
 
-struct page *
+static struct page *
 put_shared_page (struct task_struct * tsk, struct page *page, unsigned long address)
 {
 	pgd_t * pgd;
 	pmd_t * pmd;
 	pte_t * pte;
 
-	if (page_count(page) != 1)
-		printk("mem_map disagrees with %p at %08lx\n", (void *) page, address);
-
 	pgd = pgd_offset(tsk->mm, address);
 
 	spin_lock(&tsk->mm->page_table_lock);
@@ -96,6 +93,9 @@
 	 * Map GDT and TSS below 4GB, where the processor can find them.  We need to map
 	 * it with privilege level 3 because the IVE uses non-privileged accesses to these
 	 * tables.  IA-32 segmentation is used to protect against IA-32 accesses to them.
+	 *
+	 * Note: Since we don't have a vmarea for the GDT and TSS pages, we don't need
+	 *	 to worry about an exit()ing IA-32 task freeing these pages.
 	 */
 	put_shared_page(current, virt_to_page(ia32_gdt_table), IA32_GDT_OFFSET);
 	if (PAGE_SHIFT <= IA32_PAGE_SHIFT)
@@ -213,6 +213,7 @@
 	return 0;
 }
 
+#if 0
 static unsigned long
 ia32_mm_addr (unsigned long addr)
 {
@@ -224,34 +225,38 @@
 		return ELF_PAGESTART(addr);
 	return ELF_PAGEALIGN(addr);
 }
+#endif
 
 /*
- *  Normally we would do an `mmap' to map in the process's text section.
- *  This doesn't work with IA32 processes as the ELF file might specify
- *  a non page size aligned address.  Instead we will just allocate
- *  memory and read the data in from the file.  Slightly less efficient
- *  but it works.
+ * Normally we would do an `mmap' to map in the process's text section.  This doesn't work
+ * with IA32 processes as the ELF file might specify a non page size aligned address.
+ * Instead we will just allocate memory and read the data in from the file.  Slightly less
+ * efficient but it works.
  */
-extern long ia32_do_mmap (struct file *filep, unsigned int len, unsigned int prot,
-			  unsigned int flags, unsigned int fd, unsigned int offset);
-
 static unsigned long
 elf_map32 (struct file *filep, unsigned long addr, struct elf_phdr *eppnt, int prot, int type)
 {
 	unsigned long retval;
 
-	if (eppnt->p_memsz >= (1UL<<32) || addr > (1UL<<32) - eppnt->p_memsz)
-		return -EINVAL;
-
 	/*
-	 *  Make sure the elf interpreter doesn't get loaded at location 0
-	 *    so that NULL pointers correctly cause segfaults.
+	 * Make sure the elf interpreter doesn't get loaded at location 0 so that NULL
+	 * pointers correctly cause segfaults.
 	 */
 	if (addr == 0)
 		addr += PAGE_SIZE;
+
+#if 0
+	if (eppnt->p_memsz >= (1UL<<32) || addr > (1UL<<32) - eppnt->p_memsz)
+		return -EINVAL;
+
 	set_brk(ia32_mm_addr(addr), addr + eppnt->p_memsz);
 	memset((char *) addr + eppnt->p_filesz, 0, eppnt->p_memsz - eppnt->p_filesz);
 	kernel_read(filep, eppnt->p_offset, (char *) addr, eppnt->p_filesz);
 	retval = (unsigned long) addr;
+#else
+	retval = ia32_do_mmap(filep, (addr & IA32_PAGE_MASK),
+			      eppnt->p_filesz + (eppnt->p_vaddr & ~IA32_PAGE_MASK), prot, type,
+			      eppnt->p_offset - (eppnt->p_vaddr & ~IA32_PAGE_MASK));
+#endif
 	return retval;
 }
diff -urN linux.orig/arch/ia64/ia32/ia32_entry.S linux/arch/ia64/ia32/ia32_entry.S
--- linux.orig/arch/ia64/ia32/ia32_entry.S	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/ia32/ia32_entry.S	Mon Dec 17 20:27:40 2001
@@ -85,7 +85,7 @@
 	st8.spill [r2]=r8			// store return value in slot for r8
 	br.call.sptk.few rp=invoke_syscall_trace // give parent a chance to catch return value
 .ret2:	alloc r2=ar.pfs,0,0,0,0			// drop the syscall argument frame
-	br.cond.sptk.many ia64_leave_kernel	// rp MUST be != ia64_leave_kernel!
+	br.cond.sptk.many ia64_leave_kernel
 END(ia32_trace_syscall)
 
 GLOBAL_ENTRY(sys32_vfork)
diff -urN linux.orig/arch/ia64/ia32/ia32_ioctl.c linux/arch/ia64/ia32/ia32_ioctl.c
--- linux.orig/arch/ia64/ia32/ia32_ioctl.c	Thu Jan  4 13:50:17 2001
+++ linux/arch/ia64/ia32/ia32_ioctl.c	Mon Dec 17 20:27:40 2001
@@ -137,10 +137,6 @@
 	case IOCTL_NR(DRM_IOCTL_I810_GETBUF):
 	case IOCTL_NR(DRM_IOCTL_I810_COPY):
 
-	/* Rage 128 specific ioctls */
-
-	case IOCTL_NR(DRM_IOCTL_R128_PACKET):
-
 	case IOCTL_NR(VFAT_IOCTL_READDIR_BOTH):
 	case IOCTL_NR(VFAT_IOCTL_READDIR_SHORT):
 	case IOCTL_NR(MTIOCGET):
diff -urN linux.orig/arch/ia64/ia32/ia32_signal.c linux/arch/ia64/ia32/ia32_signal.c
--- linux.orig/arch/ia64/ia32/ia32_signal.c	Mon Oct  9 18:54:53 2000
+++ linux/arch/ia64/ia32/ia32_signal.c	Mon Dec 17 20:27:40 2001
@@ -279,7 +279,7 @@
        err |= setup_sigcontext_ia32(&frame->sc, &frame->fpstate, regs, set->sig[0]);
 
        if (_IA32_NSIG_WORDS > 1) {
-               err |= __copy_to_user(frame->extramask, &set->sig[1],
+               err |= __copy_to_user(frame->extramask, (char *) &set->sig[1] + 4,
                                      sizeof(frame->extramask));
        }
 
@@ -424,10 +424,8 @@
                goto badframe;
 
        if (__get_user(set.sig[0], &frame->sc.oldmask)
-           || (_IA32_NSIG_WORDS > 1
-               && __copy_from_user((((char *) &set.sig) + 4),
-                                   &frame->extramask,
-                                   sizeof(frame->extramask))))
+           || (_IA32_NSIG_WORDS > 1 && __copy_from_user((char *) &set.sig + 4, &frame->extramask,
+							sizeof(frame->extramask))))
                goto badframe;
 
        sigdelsetmask(&set, ~_BLOCKABLE);
diff -urN linux.orig/arch/ia64/ia32/sys_ia32.c linux/arch/ia64/ia32/sys_ia32.c
--- linux.orig/arch/ia64/ia32/sys_ia32.c	Sun Aug 12 16:07:42 2001
+++ linux/arch/ia64/ia32/sys_ia32.c	Mon Dec 17 20:27:40 2001
@@ -7,8 +7,8 @@
  * Copyright (C) 1999		Arun Sharma <arun.sharma@intel.com>
  * Copyright (C) 1997,1998	Jakub Jelinek (jj@sunsite.mff.cuni.cz)
  * Copyright (C) 1997		David S. Miller (davem@caip.rutgers.edu)
- * Copyright (C) 2000		Hewlett-Packard Co.
- * Copyright (C) 2000		David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 2000-2001 Hewlett-Packard Co
+ *	David Mosberger-Tang <davidm@hpl.hp.com>
  *
  * These routines maintain argument size conversion between 32bit and 64bit
  * environment.
@@ -66,6 +66,10 @@
 
 extern asmlinkage long sys_execve (char *, char **, char **, struct pt_regs *);
 extern asmlinkage long sys_mprotect (unsigned long, size_t, unsigned long);
+extern asmlinkage long sys_munmap (unsigned long, size_t);
+
+/* forward declaration: */
+asmlinkage long sys32_mprotect (unsigned int, unsigned int, int);
 
 static int
 nargs (unsigned int arg, char **ap)
@@ -124,14 +128,16 @@
 	old_map_base  = current->thread.map_base;
 	old_task_size = current->thread.task_size;
 
-	/* we may be exec'ing a 64-bit process: reset map base & task-size: */
+	/* we may be exec'ing a 64-bit process: reset map base, task-size, and io-base: */
 	current->thread.map_base  = DEFAULT_MAP_BASE;
 	current->thread.task_size = DEFAULT_TASK_SIZE;
+	ia64_set_kr(IA64_KR_IO_BASE, current->thread.old_iob);
 
 	set_fs(KERNEL_DS);
 	r = sys_execve(filename, av, ae, regs);
 	if (r < 0) {
-		/* oops, execve failed, switch back to old map base & task-size: */
+		/* oops, execve failed, switch back to old values... */
+		ia64_set_kr(IA64_KR_IO_BASE, IA32_IOBASE);
 		current->thread.map_base  = old_map_base;
 		current->thread.task_size = old_task_size;
 		set_fs(USER_DS);	/* establish new task-size as the address-limit */
@@ -215,96 +221,137 @@
 
 #define OFFSET4K(a)	((a) & 0xfff)
 
-unsigned long
-do_mmap_fake(struct file *file, unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags, loff_t off)
+#if PAGE_SHIFT > IA32_PAGE_SHIFT
+
+static unsigned long
+do_mmap_fake (struct file *file, unsigned long addr, unsigned long len, int prot, int flags,
+	      loff_t off)
 {
+	unsigned long faddr = (addr & PAGE_MASK), end, front_len, back_len, retval;
+	void *front = 0, *back = 0;
 	struct inode *inode;
-	void *front, *back;
-	unsigned long baddr;
-	int r;
 	char c;
 
-	if (OFFSET4K(addr) || OFFSET4K(off))
-		return -EINVAL;
+	/*
+	 * Allow any kind of access: this lets us avoid having to figure out what the
+	 * protection of the partial front and back pages is...
+	 */
 	prot |= PROT_WRITE;
-	front = NULL;
-	back = NULL;
-	if ((baddr = (addr & PAGE_MASK)) != addr && get_user(c, (char *)baddr) == 0) {
-		front = kmalloc(addr - baddr, GFP_KERNEL);
+
+	if (OFFSET4K(addr))
+		return -EINVAL;
+
+	end = addr + len;
+	front_len = addr - faddr;
+	back_len = (end & ~PAGE_MASK);
+
+	if (front_len && get_user(c, (char *)faddr) == 0) {
+		front = kmalloc(front_len, GFP_KERNEL);
 		if (!front)
 			return -ENOMEM;
-		__copy_user(front, (void *)baddr, addr - baddr);
+		__copy_user(front, (void *)faddr, front_len);
 	}
-	if (addr && ((addr + len) & ~PAGE_MASK) && get_user(c, (char *)(addr + len)) == 0) {
-		back = kmalloc(PAGE_SIZE - ((addr + len) & ~PAGE_MASK), GFP_KERNEL);
+
+	if (addr && back_len && get_user(c, (char *)end) == 0) {
+		back = kmalloc(PAGE_SIZE - back_len, GFP_KERNEL);
 		if (!back) {
-			if (front)
-				kfree(front);
-			return -ENOMEM;
+			addr = -ENOMEM;
+			goto fail;
 		}
-		__copy_user(back, (char *)addr + len, PAGE_SIZE - ((addr + len) & ~PAGE_MASK));
+		__copy_user(back, (char *)end, PAGE_SIZE - back_len);
 	}
+
 	down_write(&current->mm->mmap_sem);
-	r = do_mmap(0, baddr, len + (addr - baddr), prot, flags | MAP_ANONYMOUS, 0);
+	{
+		retval = do_mmap(0, faddr, len + front_len, prot, flags | MAP_ANONYMOUS, 0);
+	}
 	up_write(&current->mm->mmap_sem);
-	if (r < 0)
-		return(r);
-	if (addr == 0)
-		addr = r;
+
+	if (IS_ERR((void *) retval)) {
+		addr = retval;
+		goto fail;
+	}
+
+	if (!addr)
+		addr = retval;
+
+	end = addr + len;
+
 	if (back) {
-		__copy_user((char *)addr + len, back, PAGE_SIZE - ((addr + len) & ~PAGE_MASK));
+		__copy_user((char *) end, back, PAGE_SIZE - back_len);
 		kfree(back);
 	}
 	if (front) {
-		__copy_user((void *)baddr, front, addr - baddr);
+		__copy_user((void *) faddr, front, front_len);
 		kfree(front);
 	}
-	if (flags & MAP_ANONYMOUS) {
-		clear_user((char *)addr, len);
-		return(addr);
+
+	if (!(flags & MAP_ANONYMOUS)) {
+		inode = file->f_dentry->d_inode;
+		if (!inode->i_fop
+		    || !file->f_op->read
+		    || (*file->f_op->read)(file, (char *)addr, len, &off) < 0)
+		{
+			sys_munmap(addr, len + front_len);
+			return -EINVAL;
+		}
 	}
-	if (!file)
-		return -EINVAL;
-	inode = file->f_dentry->d_inode;
-	if (!inode->i_fop)
-		return -EINVAL;
-	if (!file->f_op->read)
-		return -EINVAL;
-	r = file->f_op->read(file, (char *)addr, len, &off);
-	return (r < 0) ? -EINVAL : addr;
+	return addr;
+
+  fail:
+	if (front)
+		kfree(front);
+	if (back)
+		kfree(back);
+	return addr;
 }
 
-long
-ia32_do_mmap (struct file *file, unsigned int addr, unsigned int len, unsigned int prot,
-	      unsigned int flags, unsigned int fd, unsigned int offset)
+#endif /* PAGE_SHIFT > IA32_PAGE_SHIFT */
+
+unsigned long
+ia32_do_mmap (struct file *file, unsigned long addr, unsigned long len, int prot, int flags,
+	      loff_t offset)
 {
-	long error = -EFAULT;
-	unsigned int poff;
+	if (file && (!file->f_op || !file->f_op->mmap))
+		return -ENODEV;
 
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	prot |= PROT_EXEC;
+	len = IA32_PAGE_ALIGN(len);
+	if (len == 0)
+		return addr;
+
+	if (len > IA32_PAGE_OFFSET || addr > IA32_PAGE_OFFSET - len)
+		return -EINVAL;
+
+	if (OFFSET4K(offset))
+		return -EINVAL;
 
+	if (prot & (PROT_READ | PROT_WRITE))
+		prot |= PROT_EXEC;	/* x86 has no "execute" permission bit... */
+
+#if PAGE_SHIFT > IA32_PAGE_SHIFT
 	if ((flags & MAP_FIXED) && ((addr & ~PAGE_MASK) || (offset & ~PAGE_MASK)))
-		error = do_mmap_fake(file, addr, len, prot, flags, (loff_t)offset);
-	else {
-		poff = offset & PAGE_MASK;
-		len += offset - poff;
+		addr = do_mmap_fake(file, addr, len, prot, flags, offset);
+	else
+#endif
+	{
+		loff_t pgoff = offset & PAGE_MASK;
+		len += offset - pgoff;
 
 		down_write(&current->mm->mmap_sem);
-		error = do_mmap_pgoff(file, addr, len, prot, flags, poff >> PAGE_SHIFT);
+		{
+			addr = do_mmap(file, addr, len, prot, flags, pgoff);
+		}
 		up_write(&current->mm->mmap_sem);
 
-		if (!IS_ERR((void *) error))
-			error += offset - poff;
+		if (!IS_ERR((void *) addr))
+			addr += offset - pgoff;
 	}
-	return error;
+	return addr;
 }
 
 /*
- * Linux/i386 didn't use to be able to handle more than
- * 4 system call parameters, so these system calls used a memory
- * block for parameter passing..
+ * Linux/i386 didn't use to be able to handle more than 4 system call parameters, so these
+ * system calls used a memory block for parameter passing..
  */
 
 struct mmap_arg_struct {
@@ -317,56 +364,114 @@
 };
 
 asmlinkage long
-sys32_mmap(struct mmap_arg_struct *arg)
+sys32_mmap (struct mmap_arg_struct *arg)
 {
 	struct mmap_arg_struct a;
 	struct file *file = NULL;
-	long retval;
+	unsigned long addr;
+	int flags;
 
 	if (copy_from_user(&a, arg, sizeof(a)))
 		return -EFAULT;
 
-	if (PAGE_ALIGN(a.len) == 0)
-		return a.addr;
+	if (OFFSET4K(a.offset))
+		return -EINVAL;
+
+	flags = a.flags;
 
-	if (!(a.flags & MAP_ANONYMOUS)) {
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(a.fd);
 		if (!file)
 			return -EBADF;
 	}
-#ifdef	CONFIG_IA64_PAGE_SIZE_4KB
-	if ((a.offset & ~PAGE_MASK) != 0)
-		return -EINVAL;
 
-	down_write(&current->mm->mmap_sem);
-	retval = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags, a.offset >> PAGE_SHIFT);
-	up_write(&current->mm->mmap_sem);
-#else
-	retval = ia32_do_mmap(file, a.addr, a.len, a.prot, a.flags, a.fd, a.offset);
-#endif
+	addr = ia32_do_mmap(file, a.addr, a.len, a.prot, flags, a.offset);
+
 	if (file)
 		fput(file);
-	return retval;
+	return addr;
 }
 
+#if PAGE_SHIFT > IA32_PAGE_SHIFT
+
+/*
+ * When mprotect()ing a partial page, we set the permission to the union of the old
+ * settings and the new settings.  In other words, it's only possible to make access to a
+ * partial page less restrictive.
+ */
+static long
+mprotect_partial_page (unsigned long address, int new_prot)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	int old_prot = 0;
+
+	if (new_prot == PROT_NONE)
+		return 0;		/* optimize case where nothing changes... */
+
+	address &= ~PAGE_MASK;
+
+	down_read(&mm->mmap_sem);
+	{
+		vma = find_vma(mm, address);
+		if (vma && vma->vm_start <= address)
+			old_prot = (vma->vm_flags & 0xf);
+	}
+	up_read(&mm->mmap_sem);
+
+	return sys_mprotect(address, PAGE_SIZE, new_prot | old_prot);
+}
+
+#endif /* PAGE_SHIFT > IA32_PAGE_SHIFT */
+
 asmlinkage long
-sys32_mprotect(unsigned long start, size_t len, unsigned long prot)
+sys32_mprotect (unsigned int start, unsigned int len, int prot)
 {
+#if PAGE_SHIFT > IA32_PAGE_SHIFT
+	unsigned long end;
+	long retval;
+#endif
 
-#ifdef	CONFIG_IA64_PAGE_SIZE_4KB
-	return(sys_mprotect(start, len, prot));
-#else	// CONFIG_IA64_PAGE_SIZE_4KB
-	if (prot == 0)
-		return(0);
-	len += start & ~PAGE_MASK;
-	if ((start & ~PAGE_MASK) && (prot & PROT_WRITE))
+	if (prot & (PROT_READ | PROT_WRITE))
+		/* on x86, PROT_WRITE implies PROT_READ and PROT_READ implies PROT_EXEC... */
 		prot |= PROT_EXEC;
-	return(sys_mprotect(start & PAGE_MASK, len & PAGE_MASK, prot));
-#endif	// CONFIG_IA64_PAGE_SIZE_4KB
+
+#if PAGE_SHIFT > IA32_PAGE_SHIFT
+	if (OFFSET4K(start))
+		return -EINVAL;
+
+	len = IA32_PAGE_ALIGN(len);
+	end = start + len;
+	if (end < start)
+		return -EINVAL;
+
+	if (start & ~PAGE_MASK) {
+		/* start address is 4KB aligned but not page aligned. */
+		retval = mprotect_partial_page(start, prot);
+		if (retval < 0)
+			return retval;
+
+		len -= (start & ~PAGE_MASK);
+		start = PAGE_ALIGN(start);
+
+		if (start >= end)
+			return 0;
+	}
+
+	if (end & ~PAGE_MASK) {
+		/* end address is 4KB aligned but not page aligned. */
+		retval = mprotect_partial_page(end, prot);
+		if (retval < 0)
+			return retval;
+		len -= (len & ~PAGE_MASK);
+	}
+#endif
+	return sys_mprotect(start, len, prot);
 }
 
 asmlinkage long
-sys32_pipe(int *fd)
+sys32_pipe (int *fd)
 {
 	int retval;
 	int fds[2];
@@ -395,8 +500,8 @@
 }
 
 asmlinkage long
-sys32_rt_sigaction(int sig, struct sigaction32 *act,
-		   struct sigaction32 *oact,  unsigned int sigsetsize)
+sys32_rt_sigaction (int sig, struct sigaction32 *act,
+		    struct sigaction32 *oact,  unsigned int sigsetsize)
 {
 	struct k_sigaction new_ka, old_ka;
 	int ret;
@@ -2612,7 +2717,6 @@
 	up_write(&current->mm->mmap_sem);
 
 	if (addr >= 0) {
-		ia64_set_kr(IA64_KR_IO_BASE, addr);
 		old = (old & ~0x3000) | (level << 12);
 		__asm__ __volatile__("mov ar.eflag=%0 ;;" :: "r"(old));
 	}
diff -urN linux.orig/arch/ia64/kernel/acpi.c linux/arch/ia64/kernel/acpi.c
--- linux.orig/arch/ia64/kernel/acpi.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/acpi.c	Mon Dec 17 20:27:40 2001
@@ -9,7 +9,7 @@
  * Copyright (C) 2000 Hewlett-Packard Co.
  * Copyright (C) 2000 David Mosberger-Tang <davidm@hpl.hp.com>
  * Copyright (C) 2000 Intel Corp.
- * Copyright (C) 2000 J.I. Lee <jung-ik.lee@intel.com>
+ * Copyright (C) 2000,2001 J.I. Lee <jung-ik.lee@intel.com>
  *      ACPI based kernel configuration manager.
  *      ACPI 2.0 & IA64 ext 0.71
  */
@@ -23,6 +23,9 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/irq.h>
+#ifdef CONFIG_SERIAL_ACPI
+#include <linux/acpi_serial.h>
+#endif
 
 #include <asm/acpi-ext.h>
 #include <asm/acpikcfg.h>
@@ -34,6 +37,9 @@
 
 #undef ACPI_DEBUG		/* Guess what this does? */
 
+/* global array to record platform interrupt vectors for generic int routing */
+int platform_irq_list[ACPI_MAX_PLATFORM_IRQS];
+
 /* These are ugly but will be reclaimed by the kernel */
 int __initdata available_cpus;
 int __initdata total_cpus;
@@ -41,8 +47,11 @@
 void (*pm_idle) (void);
 void (*pm_power_off) (void);
 
+asm (".weak iosapic_register_irq");
 asm (".weak iosapic_register_legacy_irq");
+asm (".weak iosapic_register_platform_irq");
 asm (".weak iosapic_init");
+asm (".weak iosapic_version");
 
 const char *
 acpi_get_sysname (void)
@@ -65,6 +74,25 @@
 }
 
 /*
+ * Interrupt routing API for device drivers.
+ * Provides the interrupt vector for a generic platform event
+ * (currently only CPEI implemented)
+ */
+int
+acpi_request_vector(u32 int_type)
+{
+	int vector = -1;
+
+	if (int_type < ACPI_MAX_PLATFORM_IRQS) {
+		/* correctable platform error interrupt */
+		vector = platform_irq_list[int_type];
+	} else
+		printk("acpi_request_vector(): invalid interrupt type\n");
+
+	return vector;
+}
+
+/*
  * Configure legacy IRQ information.
  */
 static void __init
@@ -139,15 +167,93 @@
 }
 
 /*
- * Info on platform interrupt sources: NMI. PMI, INIT, etc.
+ * Extract iosapic info from madt (again) to determine which iosapic
+ * this platform interrupt resides in
+ */
+static int __init
+acpi20_which_iosapic (int global_vector, acpi_madt_t *madt, u32 *irq_base, char **iosapic_address)
+{
+	acpi_entry_iosapic_t *iosapic;
+	char *p, *end;
+	int ver, max_pin;
+
+	p = (char *) (madt + 1);
+	end = p + (madt->header.length - sizeof(acpi_madt_t));
+
+	while (p < end) {
+		switch (*p) {
+		      case ACPI20_ENTRY_IO_SAPIC:
+			/* collect IOSAPIC info for platform int use later */
+			iosapic = (acpi_entry_iosapic_t *)p;
+			*irq_base = iosapic->irq_base;
+			*iosapic_address = ioremap(iosapic->address, 0);
+			/* is this the iosapic we're looking for? */
+			ver = iosapic_version(*iosapic_address);
+			max_pin = (ver >> 16) & 0xff;
+			if ((global_vector - *irq_base) <= max_pin)
+				return 0;		/* found it! */
+			break;
+		      default:
+			break;
+		}
+		p += p[1];
+	}
+	return 1;
+}
+
+/*
+ * Info on platform interrupt sources: NMI, PMI, INIT, etc.
  */
 static void __init
-acpi20_platform (char *p)
+acpi20_platform (char *p, acpi_madt_t *madt)
 {
+	int vector;
+	u32 irq_base;
+	char *iosapic_address;
+	unsigned long polarity = 0, trigger = 0;
 	acpi20_entry_platform_src_t *plat = (acpi20_entry_platform_src_t *) p;
 
 	printk("PLATFORM: IOSAPIC %x -> Vector %x on CPU %.04u:%.04u\n",
 	       plat->iosapic_vector, plat->global_vector, plat->eid, plat->id);
+
+	/* record platform interrupt vectors for generic int routing code */
+
+	if (!iosapic_register_platform_irq) {
+		printk("acpi20_platform(): no ACPI platform IRQ support\n");
+		return;
+	}
+
+	/* extract polarity and trigger info from flags */
+	switch (plat->flags) {
+	      case 0x5: polarity = 1; trigger = 1; break;
+	      case 0x7: polarity = 0; trigger = 1; break;
+	      case 0xd: polarity = 1; trigger = 0; break;
+	      case 0xf: polarity = 0; trigger = 0; break;
+	      default:
+		printk("acpi20_platform(): unknown flags 0x%x\n", plat->flags);
+		break;
+	}
+
+	/* which iosapic does this IRQ belong to? */
+	if (acpi20_which_iosapic(plat->global_vector, madt, &irq_base, &iosapic_address)) {
+		printk("acpi20_platform(): I/O SAPIC not found!\n");
+		return;
+	}
+
+	/*
+	 * get vector assignment for this IRQ, set attributes, and program the IOSAPIC
+	 * routing table
+	 */
+	vector = iosapic_register_platform_irq(plat->int_type,
+					       plat->global_vector,
+					       plat->iosapic_vector,
+					       plat->eid,
+					       plat->id,
+					       polarity,
+					       trigger,
+					       irq_base,
+					       iosapic_address);
+	platform_irq_list[plat->int_type] = vector;
 }
 
 /*
@@ -173,8 +279,10 @@
 static void __init
 acpi20_parse_madt (acpi_madt_t *madt)
 {
-	acpi_entry_iosapic_t *iosapic;
+	acpi_entry_iosapic_t *iosapic = NULL;
+	acpi20_entry_lsapic_t *lsapic = NULL;
 	char *p, *end;
+	int i;
 
 	/* Base address of IPI Message Block */
 	if (madt->lapic_address) {
@@ -186,23 +294,27 @@
 	p = (char *) (madt + 1);
 	end = p + (madt->header.length - sizeof(acpi_madt_t));
 
+	/* Initialize platform interrupt vector array */
+	for (i = 0; i < ACPI_MAX_PLATFORM_IRQS; i++)
+		platform_irq_list[i] = -1;
+
 	/*
-	 * Splitted entry parsing to ensure ordering.
+	 * Split-up entry parsing to ensure ordering.
 	 */
-
 	while (p < end) {
 		switch (*p) {
-		case ACPI20_ENTRY_LOCAL_APIC_ADDR_OVERRIDE:
+		      case ACPI20_ENTRY_LOCAL_APIC_ADDR_OVERRIDE:
 			printk("ACPI 2.0 MADT: LOCAL APIC Override\n");
 			acpi20_lapic_addr_override(p);
 			break;
 
-		case ACPI20_ENTRY_LOCAL_SAPIC:
+		      case ACPI20_ENTRY_LOCAL_SAPIC:
 			printk("ACPI 2.0 MADT: LOCAL SAPIC\n");
+			lsapic = (acpi20_entry_lsapic_t *) p;
 			acpi20_lsapic(p);
 			break;
 
-		case ACPI20_ENTRY_IO_SAPIC:
+		      case ACPI20_ENTRY_IO_SAPIC:
 			iosapic = (acpi_entry_iosapic_t *) p;
 			if (iosapic_init)
 				/*
@@ -218,26 +330,25 @@
 					);
 			break;
 
-		case ACPI20_ENTRY_PLATFORM_INT_SOURCE:
+		      case ACPI20_ENTRY_PLATFORM_INT_SOURCE:
 			printk("ACPI 2.0 MADT: PLATFORM INT SOURCE\n");
-			acpi20_platform(p);
+			acpi20_platform(p, madt);
 			break;
 
-		case ACPI20_ENTRY_LOCAL_APIC:
+		      case ACPI20_ENTRY_LOCAL_APIC:
 			printk("ACPI 2.0 MADT: LOCAL APIC entry\n"); break;
-		case ACPI20_ENTRY_IO_APIC:
+		      case ACPI20_ENTRY_IO_APIC:
 			printk("ACPI 2.0 MADT: IO APIC entry\n"); break;
-		case ACPI20_ENTRY_NMI_SOURCE:
+		      case ACPI20_ENTRY_NMI_SOURCE:
 			printk("ACPI 2.0 MADT: NMI SOURCE entry\n"); break;
-		case ACPI20_ENTRY_LOCAL_APIC_NMI:
+		      case ACPI20_ENTRY_LOCAL_APIC_NMI:
 			printk("ACPI 2.0 MADT: LOCAL APIC NMI entry\n"); break;
-		case ACPI20_ENTRY_INT_SRC_OVERRIDE:
+		      case ACPI20_ENTRY_INT_SRC_OVERRIDE:
 			break;
-		default:
+		      default:
 			printk("ACPI 2.0 MADT: unknown entry skip\n"); break;
 			break;
 		}
-
 		p += p[1];
 	}
 
@@ -245,16 +356,35 @@
 	end = p + (madt->header.length - sizeof(acpi_madt_t));
 
 	while (p < end) {
+		switch (*p) {
+		      case ACPI20_ENTRY_LOCAL_APIC:
+			if (lsapic) break;
+			printk("ACPI 2.0 MADT: LOCAL APIC entry\n");
+			/* parse local apic if there's no local Sapic */
+			break;
+		      case ACPI20_ENTRY_IO_APIC:
+			if (iosapic) break;
+			printk("ACPI 2.0 MADT: IO APIC entry\n");
+			/* parse ioapic if there's no ioSapic */
+			break;
+		      default:
+			break;
+		}
+		p += p[1];
+	}
+
+	p = (char *) (madt + 1);
+	end = p + (madt->header.length - sizeof(acpi_madt_t));
 
+	while (p < end) {
 		switch (*p) {
-		case ACPI20_ENTRY_INT_SRC_OVERRIDE:
+		      case ACPI20_ENTRY_INT_SRC_OVERRIDE:
 			printk("ACPI 2.0 MADT: INT SOURCE Override\n");
 			acpi_legacy_irq(p);
 			break;
-		default:
+		      default:
 			break;
 		}
-
 		p += p[1];
 	}
 
@@ -269,6 +399,7 @@
 # ifdef CONFIG_ACPI
 	acpi_xsdt_t *xsdt;
 	acpi_desc_table_hdr_t *hdrp;
+	acpi_madt_t *madt;
 	int tables, i;
 
 	if (strncmp(rsdp20->signature, ACPI_RSDP_SIG, ACPI_RSDP_SIG_LEN)) {
@@ -310,8 +441,76 @@
 			ACPI_MADT_SIG, ACPI_MADT_SIG_LEN) != 0)
 			continue;
 
-		acpi20_parse_madt((acpi_madt_t *) hdrp);
+		madt = (acpi_madt_t *)hdrp;
+		acpi20_parse_madt(madt);
 	}
+
+#ifdef CONFIG_SERIAL_ACPI
+
+	/*
+	 * Now we're interested in other tables, but we want the iosapics
+	 * already initialized, so we do it in a separate loop.
+	 */
+
+	for (i = 0; i < tables; i++) {
+		hdrp = (acpi_desc_table_hdr_t *) __va(readl_unaligned(&xsdt->entry_ptrs[i]));
+		/*
+		 * search for SPCR and DBGP table entries so we can enable
+		 * non-pci interrupts to IO-SAPICs.
+		 */
+		if (!strncmp(hdrp->signature, ACPI_SPCRT_SIG, ACPI_SPCRT_SIG_LEN) || 
+		    !strncmp(hdrp->signature, ACPI_DBGPT_SIG, ACPI_DBGPT_SIG_LEN)) {
+
+			acpi_ser_t *spcr = (void *)hdrp;
+			unsigned long global_int;
+
+			setup_serial_acpi(hdrp);
+
+			/*
+			 * ACPI is able to describe serial ports that live at non-standard
+			 * memory space addresses and use SAPIC interrupts.  If not also
+			 * PCI devices, there would be no interrupt vector information
+			 * for them.  This checks for and fixes that situation.
+			 */
+			if (spcr->length < sizeof(acpi_ser_t))
+				/* table is not long enough for full info, thus no int */
+				break;
+
+			/*
+			 * If the device is not in PCI space, but uses a SAPIC interrupt,
+			 * we need to program the SAPIC so that serial can autoprobe for
+			 * the IA64 interrupt vector later on.  If the device is on the
+			 * PCI space, it should already be setup via the PCI vectors
+			 */
+			if (spcr->base_addr.space_id != ACPI_SERIAL_PCICONF_SPACE &&
+				spcr->int_type == ACPI_SERIAL_INT_SAPIC) {
+
+				u32 irq_base;
+				char *iosapic_address;
+				int vector;
+
+				/* We have a UART in memory space with a SAPIC interrupt */
+				global_int = (spcr->global_int[3] << 24) |
+				             (spcr->global_int[2] << 16) |
+				             (spcr->global_int[1] << 8) |
+				              spcr->global_int[0];
+
+				if (!iosapic_register_irq)
+					continue;
+
+				/* which iosapic does this IRQ belong to? */
+				if (acpi20_which_iosapic(global_int, madt, &irq_base,
+				    &iosapic_address) == 0) {
+					vector = iosapic_register_irq(global_int, 
+					                              1, /* active high polarity */
+												  1, /* edge triggered */
+												  irq_base,
+												  iosapic_address);
+				}
+			}
+		}
+	}
+#endif
 
 	acpi_cf_terminate();
 
diff -urN linux.orig/arch/ia64/kernel/efi.c linux/arch/ia64/kernel/efi.c
--- linux.orig/arch/ia64/kernel/efi.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/efi.c	Mon Dec 17 20:27:40 2001
@@ -289,6 +289,37 @@
 			if (end != cp)
 				break;
 			cp = end;
+#ifdef CONFIG_IA64_HP_PROTO
+		} else if (memcmp(cp, "baud=", 4) == 0) {
+			extern int acpi_base_baud;
+
+			cp +=5;
+
+			acpi_base_baud = simple_strtoul(cp, NULL, 10);
+			printk("Using manual ACPI UART baud rate (%dMHz)\n",acpi_base_baud);
+			acpi_base_baud *= 1000000;
+			acpi_base_baud /= 16;
+		} else if (memcmp(cp, "noautoconf", 10) == 0) {
+			extern int acpi_autoconf_flag;
+
+			cp +=10;
+			printk("Autoconfig disabled for ACPI UARTs\n");
+			acpi_autoconf_flag = 0x0;
+
+		} else if (memcmp(cp, "crs", 3) == 0) {
+			extern int hp_proto_check_crs;
+
+			cp +=3;
+			printk("Skipping ACPI _CRS method check\n");
+			hp_proto_check_crs = 1;
+		} else if (memcmp(cp, "freq=", 5) == 0) {
+			extern unsigned long hp_proto_platform_base_freq;
+
+			cp +=5;
+			printk("Registered overriding platform base frequency\n");
+			hp_proto_platform_base_freq = simple_strtoul(cp, NULL, 10);
+			hp_proto_platform_base_freq *= 1000000;
+#endif
 		} else {
 			while (*cp != ' ' && *cp)
 				++cp;
@@ -479,8 +510,49 @@
 	return 0;
 }
 
+int
+efi_page_is_ram (u64 phys_addr)
+{
+	void *efi_map_start, *efi_map_end, *p;
+	efi_memory_desc_t *md;
+	u64 efi_desc_size;
+
+	efi_map_start = __va(ia64_boot_param->efi_memmap);
+	efi_map_end   = efi_map_start + ia64_boot_param->efi_memmap_size;
+	efi_desc_size = ia64_boot_param->efi_memdesc_size;
+
+	for (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {
+		md = p;
+
+		if ((md->phys_addr <= phys_addr) && (phys_addr <=
+		    (md->phys_addr + (md->num_pages << 12) - 1))) {
+
+			switch (md->type) {
+				case EFI_LOADER_CODE:
+				case EFI_LOADER_DATA:
+				case EFI_BOOT_SERVICES_CODE:
+				case EFI_BOOT_SERVICES_DATA:
+				case EFI_RUNTIME_SERVICES_CODE:
+				case EFI_RUNTIME_SERVICES_DATA:
+				case EFI_CONVENTIONAL_MEMORY:
+				case EFI_ACPI_RECLAIM_MEMORY:
+				case EFI_ACPI_MEMORY_NVS:
+					return 1;
+				case EFI_MEMORY_MAPPED_IO:
+				case EFI_MEMORY_MAPPED_IO_PORT_SPACE:
+					return 0;
+				default:
+					return -1;
+			}
+		}
+	}
+	return -1;
+}
+
 static void __exit
 efivars_exit(void)
 {
+#ifdef CONFIG_PROC_FS
  	remove_proc_entry(efi_dir->name, NULL);
+#endif
 }
diff -urN linux.orig/arch/ia64/kernel/entry.S linux/arch/ia64/kernel/entry.S
--- linux.orig/arch/ia64/kernel/entry.S	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/entry.S	Mon Dec 17 20:27:40 2001
@@ -143,7 +143,7 @@
 	shr.u r26=r20,KERNEL_PG_SHIFT
 	mov r16=KERNEL_PG_NUM
 	;;
-	cmp.ne p6,p7=r26,r16		// check >= 64M && < 128M
+	cmp.ne p6,p7=r26,r16		// check whether r26 != KERNEL_PG_NUM
 	adds r21=IA64_TASK_THREAD_KSP_OFFSET,in0
 	;;
 	/*
@@ -153,10 +153,11 @@
 (p6)	cmp.eq p7,p6=r26,r27
 (p6)	br.cond.dpnt.few .map
 	;;
-.done:	ld8 sp=[r21]			// load kernel stack pointer of new task
+.done:
 (p6)	ssm psr.ic			// if we we had to map, renable the psr.ic bit FIRST!!!
 	;;
 (p6)	srlz.d
+	ld8 sp=[r21]			// load kernel stack pointer of new task
 	mov IA64_KR(CURRENT)=r20	// update "current" application register
 	mov r8=r13			// return pointer to previously running task
 	mov r13=in0			// set "current" pointer
@@ -212,24 +213,18 @@
 	.save @priunat,r17
 	mov r17=ar.unat		// preserve caller's
 	.body
-#if !(defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC))
 	adds r3=80,sp
 	;;
 	lfetch.fault.excl.nt1 [r3],128
-#endif
 	mov ar.rsc=0		// put RSE in mode: enforced lazy, little endian, pl 0
-#if !(defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC))
 	adds r2=16+128,sp
 	;;
 	lfetch.fault.excl.nt1 [r2],128
 	lfetch.fault.excl.nt1 [r3],128
-#endif
 	adds r14=SW(R4)+16,sp
-#if !(defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC))
 	;;
 	lfetch.fault.excl [r2]
 	lfetch.fault.excl [r3]
-#endif
 	adds r15=SW(R5)+16,sp
 	;;
 	mov r18=ar.fpsr		// preserve fpsr
@@ -321,11 +316,9 @@
 ENTRY(load_switch_stack)
 	.prologue
 	.altrp b7
-	.body
-#if !(defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC))
 
+	.body
 	lfetch.fault.nt1 [sp]
-#endif
 	adds r2=SW(AR_BSPSTORE)+16,sp
 	adds r3=SW(AR_UNAT)+16,sp
 	mov ar.rsc=0						// put RSE into enforced lazy mode
@@ -527,7 +520,7 @@
 	lfetch.fault [sp]
 	movl r14=.restart
 	;;
-	MOVBR(.ret.sptk,rp,r14,.restart)
+	mov.ret.sptk rp=r14,.restart
 .restart:
 	adds r17=IA64_TASK_NEED_RESCHED_OFFSET,r13
 	adds r18=IA64_TASK_SIGPENDING_OFFSET,r13
@@ -536,13 +529,13 @@
 #endif
 	;;
 #ifdef CONFIG_PERFMON
-	ld8 r19=[r19]				// load current->task.pfm_notify
+(pUser)	ld8 r19=[r19]				// load current->task.pfm_notify
 #endif
-	ld8 r17=[r17]				// load current->need_resched
-	ld4 r18=[r18]				// load current->sigpending
+(pUser)	ld8 r17=[r17]				// load current->need_resched
+(pUser)	ld4 r18=[r18]				// load current->sigpending
 	;;
 #ifdef CONFIG_PERFMON
-	cmp.ne p9,p0=r19,r0			// current->task.pfm_notify != 0?
+(pUser)	cmp.ne.unc p9,p0=r19,r0			// current->task.pfm_notify != 0?
 #endif
 (pUser)	cmp.ne.unc p7,p0=r17,r0			// current->need_resched != 0?
 (pUser)	cmp.ne.unc p8,p0=r18,r0			// current->sigpending != 0?
@@ -687,7 +680,7 @@
 	shladd in0=loc1,3,r17
 	mov in1=0
 	;;
-	.align 32
+//	.align 32	// gas-2.11.90 is unable to generate a stop bit after .align
 rse_clear_invalid:
 	// cycle 0
  { .mii
@@ -876,7 +869,7 @@
 	adds sp=16,sp
 	;;
 	ld8 r9=[sp]				// load new ar.unat
-	MOVBR(.sptk,b7,r8,ia64_leave_kernel)
+	mov.sptk b7=r8,ia64_leave_kernel
 	;;
 	mov ar.unat=r9
 	br b7
diff -urN linux.orig/arch/ia64/kernel/entry.h linux/arch/ia64/kernel/entry.h
--- linux.orig/arch/ia64/kernel/entry.h	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/entry.h	Mon Dec 17 20:27:40 2001
@@ -1,12 +1,5 @@
 #include <linux/config.h>
 
-/* XXX fixme */
-#if defined(CONFIG_ITANIUM_B1_SPECIFIC)
-# define MOVBR(type,br,gr,lbl)	mov br=gr
-#else
-# define MOVBR(type,br,gr,lbl)	mov##type br=gr,lbl
-#endif
-
 /*
  * Preserved registers that are shared between code in ivt.S and entry.S.  Be
  * careful not to step on these!
@@ -62,7 +55,7 @@
 	;;					\
 	.fframe IA64_SWITCH_STACK_SIZE;		\
 	adds sp=-IA64_SWITCH_STACK_SIZE,sp;	\
-	MOVBR(.ret.sptk,b7,r28,1f);		\
+	mov.ret.sptk b7=r28,1f;			\
 	SWITCH_STACK_SAVES(0);			\
 	br.cond.sptk.many save_switch_stack;	\
 1:
@@ -71,7 +64,7 @@
 	movl r28=1f;				\
 	;;					\
 	invala;					\
-	MOVBR(.ret.sptk,b7,r28,1f);		\
+	mov.ret.sptk b7=r28,1f;			\
 	br.cond.sptk.many load_switch_stack;	\
 1:	.restore sp;				\
 	adds sp=IA64_SWITCH_STACK_SIZE,sp
diff -urN linux.orig/arch/ia64/kernel/head.S linux/arch/ia64/kernel/head.S
--- linux.orig/arch/ia64/kernel/head.S	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/head.S	Mon Dec 17 20:27:40 2001
@@ -218,7 +218,7 @@
 	add r19=IA64_NUM_DBG_REGS*8,in0
 	;;
 1:	mov r16=dbr[r18]
-#if defined(CONFIG_ITANIUM_C0_SPECIFIC)
+#ifdef CONFIG_ITANIUM
 	;;
 	srlz.d
 #endif
@@ -235,9 +235,7 @@
 
 GLOBAL_ENTRY(ia64_load_debug_regs)
 	alloc r16=ar.pfs,1,0,0,0
-#if !(defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC))
 	lfetch.nta [in0]
-#endif
 	mov r20=ar.lc			// preserve ar.lc
 	add r19=IA64_NUM_DBG_REGS*8,in0
 	mov ar.lc=IA64_NUM_DBG_REGS-1
@@ -248,9 +246,9 @@
 	add r18=1,r18
 	;;
 	mov dbr[r18]=r16
-#if defined(CONFIG_ITANIUM_BSTEP_SPECIFIC) || defined(CONFIG_ITANIUM_C0_SPECIFIC)
+#ifdef CONFIG_ITANIUM
 	;;
-	srlz.d
+	srlz.d				// Errata 132 (NoFix status)
 #endif
 	mov ibr[r18]=r17
 	br.cloop.sptk.few 1b
@@ -821,7 +819,6 @@
 	// try acquiring lock (we know ar.ccv is still zero!):
 	mov tmp=1
 	;;
-	IA64_SEMFIX_INSN
 	cmpxchg4.acq tmp=[r31],tmp,ar.ccv
 	;;
 	cmp.eq p15,p0=tmp,r0
diff -urN linux.orig/arch/ia64/kernel/iosapic.c linux/arch/ia64/kernel/iosapic.c
--- linux.orig/arch/ia64/kernel/iosapic.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/iosapic.c	Mon Dec 17 20:27:40 2001
@@ -53,6 +53,7 @@
 #include <asm/acpi-ext.h>
 #include <asm/acpikcfg.h>
 #include <asm/delay.h>
+#include <asm/hw_irq.h>
 #include <asm/io.h>
 #include <asm/iosapic.h>
 #include <asm/machvec.h>
@@ -325,7 +326,7 @@
 	set_affinity:	iosapic_set_affinity
 };
 
-static unsigned int
+unsigned int
 iosapic_version (char *addr)
 {
 	/*
@@ -342,6 +343,113 @@
 }
 
 /*
+ * ACPI can describe IOSAPIC interrupts via static tables and namespace
+ * methods.  This provides an interface to register those interrupts and
+ * program the IOSAPIC RTE.
+ */
+int
+iosapic_register_irq (u32 global_vector, unsigned long polarity, unsigned long
+                      edge_triggered, u32 base_irq, char *iosapic_address)
+{
+	irq_desc_t *idesc;
+	struct hw_interrupt_type *irq_type;
+	int vector;
+
+	vector = iosapic_irq_to_vector(global_vector);
+	if (vector < 0)
+		vector = ia64_alloc_irq();
+
+	/* fill in information from this vector's IOSAPIC */
+	iosapic_irq[vector].addr = iosapic_address;
+	iosapic_irq[vector].base_irq = base_irq;
+	iosapic_irq[vector].pin	= global_vector - iosapic_irq[vector].base_irq;
+	iosapic_irq[vector].polarity = polarity ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW;
+	iosapic_irq[vector].dmode    = IOSAPIC_LOWEST_PRIORITY;
+
+	if (edge_triggered) {
+		iosapic_irq[vector].trigger = IOSAPIC_EDGE;
+		irq_type = &irq_type_iosapic_edge;
+	} else {
+		iosapic_irq[vector].trigger = IOSAPIC_LEVEL;
+		irq_type = &irq_type_iosapic_level;
+	}
+
+	idesc = irq_desc(vector);
+	if (idesc->handler != irq_type) {
+		if (idesc->handler != &no_irq_type)
+			printk("iosapic_register_irq(): changing vector 0x%02x from"
+			       "%s to %s\n", vector, idesc->handler->typename, irq_type->typename);
+		idesc->handler = irq_type;
+	}
+
+	printk("IOSAPIC %x(%s,%s) -> Vector %x\n", global_vector,
+	       (polarity ? "high" : "low"), (edge_triggered ? "edge" : "level"), vector);
+
+	/* program the IOSAPIC routing table */
+	set_rte(vector, (ia64_get_lid() >> 16) & 0xffff);
+	return vector;
+}
+
+/*
+ * ACPI calls this when it finds an entry for a platform interrupt.
+ * Note that the irq_base and IOSAPIC address must be set in iosapic_init().
+ */
+int
+iosapic_register_platform_irq (u32 int_type, u32 global_vector, u32 iosapic_vector,
+			       u16 eid, u16 id, unsigned long polarity,
+			       unsigned long edge_triggered, u32 base_irq, char *iosapic_address)
+{
+	struct hw_interrupt_type *irq_type;
+	irq_desc_t *idesc;
+	int vector;
+
+	switch (int_type) {
+	      case ACPI20_ENTRY_PIS_CPEI:
+		vector = IA64_PCE_VECTOR;
+		iosapic_irq[vector].dmode = IOSAPIC_LOWEST_PRIORITY;
+		break;
+	      case ACPI20_ENTRY_PIS_INIT:
+		vector = ia64_alloc_irq();
+		iosapic_irq[vector].dmode = IOSAPIC_INIT;
+		break;
+	      default:
+		printk("iosapic_register_platform_irq(): invalid int type\n");
+		return -1;
+	}
+
+	/* fill in information from this vector's IOSAPIC */
+	iosapic_irq[vector].addr = iosapic_address;
+	iosapic_irq[vector].base_irq = base_irq;
+	iosapic_irq[vector].pin	= global_vector - iosapic_irq[vector].base_irq;
+	iosapic_irq[vector].polarity = polarity ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW;
+
+	if (edge_triggered) {
+		iosapic_irq[vector].trigger = IOSAPIC_EDGE;
+		irq_type = &irq_type_iosapic_edge;
+	} else {
+		iosapic_irq[vector].trigger = IOSAPIC_LEVEL;
+		irq_type = &irq_type_iosapic_level;
+	}
+
+	idesc = irq_desc(vector);
+	if (idesc->handler != irq_type) {
+		if (idesc->handler != &no_irq_type)
+			printk("iosapic_register_platform_irq(): changing vector 0x%02x from"
+			       "%s to %s\n", vector, idesc->handler->typename, irq_type->typename);
+		idesc->handler = irq_type;
+	}
+
+	printk("PLATFORM int %x: IOSAPIC %x(%s,%s) -> Vector %x CPU %.02u:%.02u\n",
+	       int_type, global_vector, (polarity ? "high" : "low"),
+	       (edge_triggered ? "edge" : "level"), vector, eid, id);
+
+	/* program the IOSAPIC routing table */
+	set_rte(vector, ((id << 8) | eid) & 0xffff);
+	return vector;
+}
+
+
+/*
  * ACPI calls this when it finds an entry for a legacy ISA interrupt.  Note that the
  * irq_base and IOSAPIC address must be set in iosapic_init().
  */
@@ -436,7 +544,7 @@
 			/* the interrupt route is for another controller... */
 			continue;
 
-		if (irq < 16)
+		if (pcat_compat && (irq < 16))
 			vector = isa_irq_to_vector(irq);
 		else {
 			vector = iosapic_irq_to_vector(irq);
@@ -457,17 +565,7 @@
 		       pci_irq.route[i].bus, pci_irq.route[i].pci_id>>16, pci_irq.route[i].pin,
 		       iosapic_irq[vector].base_irq + iosapic_irq[vector].pin, vector);
 # endif
-		irq_type = &irq_type_iosapic_level;
-		idesc = irq_desc(vector);
-		if (idesc->handler != irq_type){
-			if (idesc->handler != &no_irq_type)
-				printk("iosapic_init: changing vector 0x%02x from %s to %s\n",
-				       vector, idesc->handler->typename, irq_type->typename);
-			idesc->handler = irq_type;
-		}
 
-		/* program the IOSAPIC routing table: */
-		set_rte(vector, (ia64_get_lid() >> 16) & 0xffff);
 	}
 }
 
@@ -477,6 +575,8 @@
 	struct	pci_dev	*dev;
 	unsigned char pin;
 	int vector;
+	struct hw_interrupt_type *irq_type;
+	irq_desc_t *idesc;
 
 	if (phase != 1)
 		return;
@@ -515,6 +615,37 @@
 				printk("PCI->APIC IRQ transform: (B%d,I%d,P%d) -> 0x%02x\n",
 				       dev->bus->number, PCI_SLOT(dev->devfn), pin, vector);
 				dev->irq = vector;
+
+				irq_type = &irq_type_iosapic_level;
+				idesc = irq_desc(vector);
+				if (idesc->handler != irq_type){
+					if (idesc->handler != &no_irq_type)
+						printk("iosapic_init: changing vector 0x%02x from %s to %s\n",
+				       		vector, idesc->handler->typename, irq_type->typename);
+					idesc->handler = irq_type;
+				}
+#ifdef CONFIG_SMP
+				/*
+				 * For platforms that do not support interrupt redirect
+				 * via the XTP interface, we can round-robin the PCI
+				 * device interrupts to the processors
+				 */
+				if (!(smp_int_redirect & SMP_IRQ_REDIRECTION)) {
+					static int cpu_index = 0;
+
+					set_rte(vector, cpu_physical_id(cpu_index) & 0xffff);
+
+					cpu_index++;
+					if (cpu_index == smp_num_cpus)
+						cpu_index = 0;
+						
+				} else {
+					set_rte(vector, (ia64_get_lid() >> 16) & 0xffff);
+				}
+#else
+				/* program the IOSAPIC routing table: */
+				set_rte(vector, (ia64_get_lid() >> 16) & 0xffff);
+#endif
 			}
 		}
 		/*
diff -urN linux.orig/arch/ia64/kernel/ivt.S linux/arch/ia64/kernel/ivt.S
--- linux.orig/arch/ia64/kernel/ivt.S	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/ivt.S	Mon Dec 17 20:27:40 2001
@@ -534,15 +534,6 @@
 	;;
 1:	ld8 r18=[r17]
 	;;
-# if defined(CONFIG_IA32_SUPPORT) && defined(CONFIG_ITANIUM_B0_SPECIFIC)
-	/*
-	 * Erratum 85 (Access bit fault could be reported before page not present fault)
-	 *   If the PTE is indicates the page is not present, then just turn this into a
-	 *   page fault.
-	 */
-	tbit.z p6,p0=r18,_PAGE_P_BIT		// page present bit cleared?
-(p6)	br.sptk page_fault			// page wasn't present
-# endif
 	mov ar.ccv=r18				// set compare value for cmpxchg
 	or r25=_PAGE_A,r18			// set the accessed bit
 	;;
@@ -564,15 +555,6 @@
 	;;
 1:	ld8 r18=[r17]
 	;;
-# if defined(CONFIG_IA32_SUPPORT) && defined(CONFIG_ITANIUM_B0_SPECIFIC)
-	/*
-	 * Erratum 85 (Access bit fault could be reported before page not present fault)
-	 *   If the PTE is indicates the page is not present, then just turn this into a
-	 *   page fault.
-	 */
-	tbit.z p6,p0=r18,_PAGE_P_BIT		// page present bit cleared?
-(p6)	br.sptk page_fault			// page wasn't present
-# endif
 	or r18=_PAGE_A,r18			// set the accessed bit
 	mov b0=r29				// restore b0
 	;;
diff -urN linux.orig/arch/ia64/kernel/mca.c linux/arch/ia64/kernel/mca.c
--- linux.orig/arch/ia64/kernel/mca.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/mca.c	Mon Dec 17 20:27:40 2001
@@ -3,12 +3,20 @@
  * Purpose:	Generic MCA handling layer
  *
  * Updated for latest kernel
+ * Copyright (C) 2001 Intel
+ * Copyright (C) Fred Lewis (frederick.v.lewis@intel.com)
+ *
  * Copyright (C) 2000 Intel
  * Copyright (C) Chuck Fleckenstein (cfleck@co.intel.com)
  *
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) Vijay Chander(vijay@engr.sgi.com)
  *
+ * 01/01/03 F. Lewis    Added setup of CMCI and CPEI IRQs, logging of corrected
+ *                      platform errors, completed code for logging of
+ *                      corrected & uncorrected machine check errors, and
+ *                      updated for conformance with Nov. 2000 revision of the
+ *                      SAL 3.0 spec.
  * 00/03/29 C. Fleckenstein  Fixed PAL/SAL update issues, began MCA bug fixes, logging issues,
  *                           added min save state dump, added INIT handler.
  */
@@ -16,6 +24,7 @@
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/smp_lock.h>
 
@@ -27,8 +36,10 @@
 #include <asm/mca.h>
 
 #include <asm/irq.h>
-#include <asm/machvec.h>
+#include <asm/hw_irq.h>
+#include <asm/acpi-ext.h>
 
+#define MCA_PRT_XTRA_DATA  // Uncomment to printer headers and dumps
 
 typedef struct ia64_fptr {
 	unsigned long fp;
@@ -38,22 +49,67 @@
 ia64_mc_info_t			ia64_mc_info;
 ia64_mca_sal_to_os_state_t	ia64_sal_to_os_handoff_state;
 ia64_mca_os_to_sal_state_t	ia64_os_to_sal_handoff_state;
-u64				ia64_mca_proc_state_dump[256];
+u64				ia64_mca_proc_state_dump[512];
 u64				ia64_mca_stack[1024];
 u64				ia64_mca_stackframe[32];
 u64				ia64_mca_bspstore[1024];
 u64				ia64_init_stack[INIT_TASK_SIZE] __attribute__((aligned(16)));
 
-static void			ia64_mca_cmc_vector_setup(int		enable,
-							  int_vector_t	cmc_vector);
 static void			ia64_mca_wakeup_ipi_wait(void);
 static void			ia64_mca_wakeup(int cpu);
 static void			ia64_mca_wakeup_all(void);
-static void			ia64_log_init(int,int);
-static void			ia64_log_get(int,int, prfunc_t);
-static void			ia64_log_clear(int,int,int, prfunc_t);
+static void			ia64_log_init(int);
 extern void		        ia64_monarch_init_handler (void);
 extern void		        ia64_slave_init_handler (void);
+extern struct hw_interrupt_type irq_type_iosapic_level;
+
+static struct irqaction cmci_irqaction = {
+	handler:    ia64_mca_cmc_int_handler,
+	flags:      SA_INTERRUPT,
+	name:       "cmc_hndlr"
+};
+
+static struct irqaction mca_rdzv_irqaction = {
+	handler:    ia64_mca_rendez_int_handler,
+	flags:      SA_INTERRUPT,
+	name:       "mca_rdzv"
+};
+
+static struct irqaction mca_wkup_irqaction = {
+	handler:    ia64_mca_wakeup_int_handler,
+	flags:      SA_INTERRUPT,
+	name:       "mca_wkup"
+};
+
+static struct irqaction mca_cpe_irqaction = {
+	handler:    ia64_mca_cpe_int_handler,
+	flags:      SA_INTERRUPT,
+	name:       "cpe_hndlr"
+};
+
+/*
+ *  ia64_mca_log_sal_error_record
+ *
+ *  This function retrieves a specified error record type from SAL, sends it to
+ *  the system log, and notifies SALs to clear the record from its non-volatile
+ *  memory.
+ *
+ *  Inputs  :   sal_info_type   (Type of error record MCA/CMC/CPE/INIT)
+ *  Outputs :   None
+ */
+void
+ia64_mca_log_sal_error_record(int sal_info_type)
+{
+	/* Get the MCA error record */
+	if (!ia64_log_get(sal_info_type, (prfunc_t)printk))
+		return;                 // no record retrieved
+
+	/* Log the error record */
+	ia64_log_print(sal_info_type, (prfunc_t)printk);
+
+	/* Clear the CMC SAL logs now that they have been logged */
+	ia64_sal_clear_state_info(sal_info_type);
+}
 
 /*
  * hack for now, add platform dependent handlers
@@ -67,10 +123,14 @@
 }
 
 void
-cmci_handler_platform (int cmc_irq, void *arg, struct pt_regs *ptregs)
+ia64_mca_cpe_int_handler (int cpe_irq, void *arg, struct pt_regs *ptregs)
 {
+	IA64_MCA_DEBUG("ia64_mca_cpe_int_handler : received interrupt. vector = %#x\n", cpe_irq);
 
+	/* Get the CMC error record and log it */
+	ia64_mca_log_sal_error_record(SAL_INFO_TYPE_CPE);
 }
+
 /*
  * This routine will be used to deal with platform specific handling
  * of the init, i.e. drop into the kernel debugger on server machine,
@@ -81,17 +141,72 @@
 init_handler_platform (struct pt_regs *regs)
 {
 	/* if a kernel debugger is available call it here else just dump the registers */
+
 	show_regs(regs);		/* dump the state info */
+	while (1);			/* hang city if no debugger */
 }
 
+/*
+ * ia64_mca_init_platform
+ *
+ *  External entry for platform specific MCA initialization.
+ *
+ *  Inputs
+ *      None
+ *
+ *  Outputs
+ *      None
+ */
 void
-log_print_platform ( void *cur_buff_ptr, prfunc_t prfunc)
+ia64_mca_init_platform (void)
 {
+
 }
 
+/*
+ *  ia64_mca_check_errors
+ *
+ *  External entry to check for error records which may have been posted by SAL
+ *  for a prior failure which resulted in a machine shutdown before an the
+ *  error could be logged.  This function must be called after the filesystem
+ *  is initialized.
+ *
+ *  Inputs  :   None
+ *
+ *  Outputs :   None
+ */
 void
-ia64_mca_init_platform (void)
+ia64_mca_check_errors (void)
 {
+	/*
+	 *  If there is an MCA error record pending, get it and log it.
+	 */
+	ia64_mca_log_sal_error_record(SAL_INFO_TYPE_MCA);
+}
+
+/*
+ * ia64_mca_register_cpev
+ *
+ *  Register the corrected platform error vector with SAL.
+ *
+ *  Inputs
+ *      cpev        Corrected Platform Error Vector number
+ *
+ *  Outputs
+ *      None
+ */
+static void
+ia64_mca_register_cpev (int cpev)
+{
+	/* Register the CPE interrupt vector with SAL */
+	if (ia64_sal_mc_set_params(SAL_MC_PARAM_CPE_INT, SAL_MC_PARAM_MECHANISM_INT, cpev, 0, 0)) {
+		printk("ia64_mca_platform_init : failed to register Corrected "
+		       "Platform Error interrupt vector with SAL.\n");
+		return;
+	}
+
+	IA64_MCA_DEBUG("ia64_mca_platform_init : corrected platform error "
+		       "vector %#x setup and enabled\n", cpev);
 }
 
 #endif /* PLATFORM_MCA_HANDLERS */
@@ -140,30 +255,36 @@
 				     && !ia64_pmss_dump_bank0))
 			printk("\n");
 	}
-	/* hang city for now, until we include debugger or copy to ptregs to show: */
-	while (1);
 }
 
 /*
  * ia64_mca_cmc_vector_setup
- *	Setup the correctable machine check vector register in the processor
+ *
+ *  Setup the corrected machine check vector register in the processor and
+ *  unmask interrupt.  This function is invoked on a per-processor basis.
+ *
  * Inputs
- *	Enable (1 - enable cmc interrupt , 0 - disable)
- *	CMC handler entry point (if enabled)
+ *      None
  *
  * Outputs
  *	None
  */
-static void
-ia64_mca_cmc_vector_setup(int		enable,
-			  int_vector_t	cmc_vector)
+void
+ia64_mca_cmc_vector_setup (void)
 {
 	cmcv_reg_t	cmcv;
 
 	cmcv.cmcv_regval	= 0;
-	cmcv.cmcv_mask	= enable;
-	cmcv.cmcv_vector	= cmc_vector;
+	cmcv.cmcv_mask      = 0;        /* Unmask/enable interrupt */
+	cmcv.cmcv_vector    = IA64_CMC_VECTOR;
 	ia64_set_cmcv(cmcv.cmcv_regval);
+
+	IA64_MCA_DEBUG("ia64_mca_platform_init : CPU %d corrected "
+		       "machine check vector %#x setup and enabled.\n",
+		       smp_processor_id(), IA64_CMC_VECTOR);
+
+	IA64_MCA_DEBUG("ia64_mca_platform_init : CPU %d CMCV = %#016lx\n",
+		       smp_processor_id(), ia64_get_cmcv());
 }
 
 
@@ -174,26 +295,58 @@
 void
 mca_test(void)
 {
-	slpi_buf.slpi_valid.slpi_psi = 1;
-	slpi_buf.slpi_valid.slpi_cache_check = 1;
-	slpi_buf.slpi_valid.slpi_tlb_check = 1;
-	slpi_buf.slpi_valid.slpi_bus_check = 1;
-	slpi_buf.slpi_valid.slpi_minstate = 1;
-	slpi_buf.slpi_valid.slpi_bank1_gr = 1;
-	slpi_buf.slpi_valid.slpi_br = 1;
-	slpi_buf.slpi_valid.slpi_cr = 1;
-	slpi_buf.slpi_valid.slpi_ar = 1;
-	slpi_buf.slpi_valid.slpi_rr = 1;
-	slpi_buf.slpi_valid.slpi_fr = 1;
+	slpi_buf.valid.psi_static_struct = 1;
+	slpi_buf.valid.num_cache_check = 1;
+	slpi_buf.valid.num_tlb_check = 1;
+	slpi_buf.valid.num_bus_check = 1;
+	slpi_buf.valid.processor_static_info.minstate = 1;
+	slpi_buf.valid.processor_static_info.br = 1;
+	slpi_buf.valid.processor_static_info.cr = 1;
+	slpi_buf.valid.processor_static_info.ar = 1;
+	slpi_buf.valid.processor_static_info.rr = 1;
+	slpi_buf.valid.processor_static_info.fr = 1;
 
 	ia64_os_mca_dispatch();
 }
 
 #endif /* #if defined(MCA_TEST) */
 
+
+/*
+ *  verify_guid
+ *
+ *  Compares a test guid to a target guid and returns result.
+ *
+ *  Inputs
+ *      test_guid *     (ptr to guid to be verified)
+ *      target_guid *   (ptr to standard guid to be verified against)
+ *
+ *  Outputs
+ *      0               (test verifies against target)
+ *      non-zero        (test guid does not verify)
+ */
+static int
+verify_guid (efi_guid_t *test, efi_guid_t *target)
+{
+	int     rc;
+
+	if ((rc = memcmp((void *)test, (void *)target, sizeof(efi_guid_t)))) {
+		IA64_MCA_DEBUG("ia64_mca_print : invalid guid = "
+			       "{ %08x, %04x, %04x, { %#02x, %#02x, %#02x, %#02x, "
+			       "%#02x, %#02x, %#02x, %#02x, } } \n ",
+			       test->data1, test->data2, test->data3, test->data4[0],
+			       test->data4[1], test->data4[2], test->data4[3],
+			       test->data4[4], test->data4[5], test->data4[6],
+			       test->data4[7]);
+	}
+
+	return rc;
+}
+
 /*
  * ia64_mca_init
- *	Do all the mca specific initialization on a per-processor basis.
+ *
+ *  Do all the system level mca specific initialization.
  *
  *	1. Register spinloop and wakeup request interrupt vectors
  *
@@ -201,22 +354,23 @@
  *
  *	3. Register OS_INIT handler entry point
  *
- *	4. Initialize CMCV register to enable/disable CMC interrupt on the
- *	   processor and hook a handler in the platform-specific ia64_mca_init.
+ *  4. Initialize MCA/CMC/INIT related log buffers maintained by the OS.
  *
- *	5. Initialize MCA/CMC/INIT related log buffers maintained by the OS.
+ *  Note that this initialization is done very early before some kernel
+ *  services are available.
  *
- * Inputs
- *	None
- * Outputs
- *	None
+ *  Inputs  :   None
+ *
+ *  Outputs :   None
  */
 void __init
 ia64_mca_init(void)
 {
 	ia64_fptr_t *mon_init_ptr = (ia64_fptr_t *)ia64_monarch_init_handler;
 	ia64_fptr_t *slave_init_ptr = (ia64_fptr_t *)ia64_slave_init_handler;
+	ia64_fptr_t *mca_hldlr_ptr = (ia64_fptr_t *)ia64_os_mca_dispatch;
 	int i;
+	s64 rc;
 
 	IA64_MCA_DEBUG("ia64_mca_init : begin\n");
 
@@ -224,54 +378,56 @@
 	for(i = 0 ; i < IA64_MAXCPUS; i++)
 		ia64_mc_info.imi_rendez_checkin[i] = IA64_MCA_RENDEZ_CHECKIN_NOTDONE;
 
-	/* NOTE : The actual irqs for the rendez, wakeup and
-	 * cmc interrupts are requested in the platform-specific
-	 * mca initialization code.
-	 */
 	/*
 	 * Register the rendezvous spinloop and wakeup mechanism with SAL
 	 */
 
 	/* Register the rendezvous interrupt vector with SAL */
-	if (ia64_sal_mc_set_params(SAL_MC_PARAM_RENDEZ_INT,
-				   SAL_MC_PARAM_MECHANISM_INT,
-				   IA64_MCA_RENDEZ_VECTOR,
-				   IA64_MCA_RENDEZ_TIMEOUT,
-				   0))
+	if ((rc = ia64_sal_mc_set_params(SAL_MC_PARAM_RENDEZ_INT,
+					 SAL_MC_PARAM_MECHANISM_INT,
+					 IA64_MCA_RENDEZ_VECTOR,
+					 IA64_MCA_RENDEZ_TIMEOUT,
+					 0)))
+	{
+		printk("ia64_mca_init : Failed to register rendezvous interrupt "
+		       "with SAL.  rc = %ld\n", rc);
 		return;
+	}
 
 	/* Register the wakeup interrupt vector with SAL */
-	if (ia64_sal_mc_set_params(SAL_MC_PARAM_RENDEZ_WAKEUP,
-				   SAL_MC_PARAM_MECHANISM_INT,
-				   IA64_MCA_WAKEUP_VECTOR,
-				   0,
-				   0))
+	if ((rc = ia64_sal_mc_set_params(SAL_MC_PARAM_RENDEZ_WAKEUP,
+					 SAL_MC_PARAM_MECHANISM_INT,
+					 IA64_MCA_WAKEUP_VECTOR,
+					 0, 0)))
+	{
+		printk("ia64_mca_init : Failed to register wakeup interrupt with SAL.  rc = %ld\n",
+		       rc);
 		return;
+	}
 
 	IA64_MCA_DEBUG("ia64_mca_init : registered mca rendezvous spinloop and wakeup mech.\n");
-	/*
-	 * Setup the correctable machine check vector
-	 */
-	ia64_mca_cmc_vector_setup(IA64_CMC_INT_ENABLE, IA64_CMC_VECTOR);
-
-	IA64_MCA_DEBUG("ia64_mca_init : correctable mca vector setup done\n");
 
-	ia64_mc_info.imi_mca_handler		= __pa(ia64_os_mca_dispatch);
+	ia64_mc_info.imi_mca_handler        = __pa(mca_hldlr_ptr->fp);
 	/*
 	 * XXX - disable SAL checksum by setting size to 0; should be
 	 *	__pa(ia64_os_mca_dispatch_end) - __pa(ia64_os_mca_dispatch);
 	 */
 	ia64_mc_info.imi_mca_handler_size	= 0;
-	/* Register the os mca handler with SAL */
-	if (ia64_sal_set_vectors(SAL_VECTOR_OS_MCA,
-				 ia64_mc_info.imi_mca_handler,
-				 __pa(ia64_get_gp()),
-				 ia64_mc_info.imi_mca_handler_size,
-				 0,0,0))
 
+	/* Register the os mca handler with SAL */
+	if ((rc = ia64_sal_set_vectors(SAL_VECTOR_OS_MCA,
+				       ia64_mc_info.imi_mca_handler,
+				       mca_hldlr_ptr->gp,
+				       ia64_mc_info.imi_mca_handler_size,
+				       0, 0, 0)))
+	{
+		printk("ia64_mca_init : Failed to register os mca handler with SAL.  rc = %ld\n",
+		       rc);
 		return;
+	}
 
-	IA64_MCA_DEBUG("ia64_mca_init : registered os mca handler with SAL\n");
+	IA64_MCA_DEBUG("ia64_mca_init : registered os mca handler with SAL at 0x%lx, gp = 0x%lx\n",
+		       ia64_mc_info.imi_mca_handler, mca_hldlr_ptr->gp);
 
 	/*
 	 * XXX - disable SAL checksum by setting size to 0, should be
@@ -282,53 +438,87 @@
 	ia64_mc_info.imi_slave_init_handler		= __pa(slave_init_ptr->fp);
 	ia64_mc_info.imi_slave_init_handler_size	= 0;
 
-	IA64_MCA_DEBUG("ia64_mca_init : os init handler at %lx\n",ia64_mc_info.imi_monarch_init_handler);
+	IA64_MCA_DEBUG("ia64_mca_init : os init handler at %lx\n",
+		       ia64_mc_info.imi_monarch_init_handler);
 
 	/* Register the os init handler with SAL */
-	if (ia64_sal_set_vectors(SAL_VECTOR_OS_INIT,
-				 ia64_mc_info.imi_monarch_init_handler,
-				 __pa(ia64_get_gp()),
-				 ia64_mc_info.imi_monarch_init_handler_size,
-				 ia64_mc_info.imi_slave_init_handler,
-				 __pa(ia64_get_gp()),
-				 ia64_mc_info.imi_slave_init_handler_size))
-
-
+	if ((rc = ia64_sal_set_vectors(SAL_VECTOR_OS_INIT,
+				       ia64_mc_info.imi_monarch_init_handler,
+				       __pa(ia64_get_gp()),
+				       ia64_mc_info.imi_monarch_init_handler_size,
+				       ia64_mc_info.imi_slave_init_handler,
+				       __pa(ia64_get_gp()),
+				       ia64_mc_info.imi_slave_init_handler_size)))
+	{
+		printk("ia64_mca_init : Failed to register m/s init handlers with SAL. rc = %ld\n",
+		       rc);
 		return;
+	}
 
 	IA64_MCA_DEBUG("ia64_mca_init : registered os init handler with SAL\n");
 
+	/*
+	 *  Configure the CMCI vector and handler. Interrupts for CMC are
+	 *  per-processor, so AP CMC interrupts are setup in smp_callin() (smp.c).
+	 */
+	register_percpu_irq(IA64_CMC_VECTOR, &cmci_irqaction);
+	ia64_mca_cmc_vector_setup();       /* Setup vector on BSP & enable */
+
+	/* Setup the MCA rendezvous interrupt vector */
+	register_percpu_irq(IA64_MCA_RENDEZ_VECTOR, &mca_rdzv_irqaction);
+
+	/* Setup the MCA wakeup interrupt vector */
+	register_percpu_irq(IA64_MCA_WAKEUP_VECTOR, &mca_wkup_irqaction);
+
+	/* Setup the CPE interrupt vector */
+	{
+		irq_desc_t *desc;
+		unsigned int irq;
+		int cpev = acpi_request_vector(ACPI20_ENTRY_PIS_CPEI);
+
+		if (cpev >= 0) {
+			for (irq = 0; irq < NR_IRQS; ++irq)
+				if (irq_to_vector(irq) == cpev) {
+					desc = irq_desc(irq);
+					desc->status |= IRQ_PER_CPU;
+					desc->handler = &irq_type_iosapic_level;
+					setup_irq(irq, &mca_cpe_irqaction);
+				}
+			ia64_mca_register_cpev(cpev);
+		} else
+			printk("ia64_mca_init : Failed to get routed CPEI vector from ACPI.\n");
+	}
+
 	/* Initialize the areas set aside by the OS to buffer the
 	 * platform/processor error states for MCA/INIT/CMC
 	 * handling.
 	 */
-	ia64_log_init(SAL_INFO_TYPE_MCA, SAL_SUB_INFO_TYPE_PROCESSOR);
-	ia64_log_init(SAL_INFO_TYPE_MCA, SAL_SUB_INFO_TYPE_PLATFORM);
-	ia64_log_init(SAL_INFO_TYPE_INIT, SAL_SUB_INFO_TYPE_PROCESSOR);
-	ia64_log_init(SAL_INFO_TYPE_INIT, SAL_SUB_INFO_TYPE_PLATFORM);
-	ia64_log_init(SAL_INFO_TYPE_CMC, SAL_SUB_INFO_TYPE_PROCESSOR);
-	ia64_log_init(SAL_INFO_TYPE_CMC, SAL_SUB_INFO_TYPE_PLATFORM);
-
-	ia64_mca_init_platform();
-
-	IA64_MCA_DEBUG("ia64_mca_init : platform-specific mca handling setup done\n");
+	ia64_log_init(SAL_INFO_TYPE_MCA);
+	ia64_log_init(SAL_INFO_TYPE_INIT);
+	ia64_log_init(SAL_INFO_TYPE_CMC);
+	ia64_log_init(SAL_INFO_TYPE_CPE);
 
 #if defined(MCA_TEST)
 	mca_test();
 #endif /* #if defined(MCA_TEST) */
 
 	printk("Mca related initialization done\n");
+
+#if 0   // Too early in initialization -- error log is lost
+	/* Do post-failure MCA error logging */
+	ia64_mca_check_errors();
+#endif  // Too early in initialization -- error log is lost
 }
 
 /*
  * ia64_mca_wakeup_ipi_wait
+ *
  *	Wait for the inter-cpu interrupt to be sent by the
  *	monarch processor once it is done with handling the
  *	MCA.
- * Inputs
- *	None
- * Outputs
- *	None
+ *
+ *  Inputs  :   None
+ *  Outputs :   None
  */
 void
 ia64_mca_wakeup_ipi_wait(void)
@@ -339,16 +529,16 @@
 
 	do {
 		switch(irr_num) {
-		case 0:
+		      case 0:
 			irr = ia64_get_irr0();
 			break;
-		case 1:
+		      case 1:
 			irr = ia64_get_irr1();
 			break;
-		case 2:
+		      case 2:
 			irr = ia64_get_irr2();
 			break;
-		case 3:
+		      case 3:
 			irr = ia64_get_irr3();
 			break;
 		}
@@ -357,26 +547,28 @@
 
 /*
  * ia64_mca_wakeup
+ *
  *	Send an inter-cpu interrupt to wake-up a particular cpu
  *	and mark that cpu to be out of rendez.
- * Inputs
- *	cpuid
- * Outputs
- *	None
+ *
+ *  Inputs  :   cpuid
+ *  Outputs :   None
  */
 void
 ia64_mca_wakeup(int cpu)
 {
 	platform_send_ipi(cpu, IA64_MCA_WAKEUP_VECTOR, IA64_IPI_DM_INT, 0);
 	ia64_mc_info.imi_rendez_checkin[cpu] = IA64_MCA_RENDEZ_CHECKIN_NOTDONE;
+
 }
+
 /*
  * ia64_mca_wakeup_all
+ *
  *	Wakeup all the cpus which have rendez'ed previously.
- * Inputs
- *	None
- * Outputs
- *	None
+ *
+ *  Inputs  :   None
+ *  Outputs :   None
  */
 void
 ia64_mca_wakeup_all(void)
@@ -389,15 +581,16 @@
 			ia64_mca_wakeup(cpu);
 
 }
+
 /*
  * ia64_mca_rendez_interrupt_handler
+ *
  *	This is handler used to put slave processors into spinloop
  *	while the monarch processor does the mca handling and later
  *	wake each slave up once the monarch is done.
- * Inputs
- *	None
- * Outputs
- *	None
+ *
+ *  Inputs  :   None
+ *  Outputs :   None
  */
 void
 ia64_mca_rendez_int_handler(int rendez_irq, void *arg, struct pt_regs *ptregs)
@@ -423,23 +616,22 @@
 
 	/* Enable all interrupts */
 	restore_flags(flags);
-
-
 }
 
 
 /*
  * ia64_mca_wakeup_int_handler
+ *
  *	The interrupt handler for processing the inter-cpu interrupt to the
  *	slave cpu which was spinning in the rendez loop.
  *	Since this spinning is done by turning off the interrupts and
  *	polling on the wakeup-interrupt bit in the IRR, there is
  *	nothing useful to be done in the handler.
- *  Inputs
- *	wakeup_irq	(Wakeup-interrupt bit)
+ *
+ *  Inputs  :   wakeup_irq  (Wakeup-interrupt bit)
  *	arg		(Interrupt handler specific argument)
  *	ptregs		(Exception frame at the time of the interrupt)
- *  Outputs
+ *  Outputs :   None
  *
  */
 void
@@ -450,16 +642,16 @@
 
 /*
  * ia64_return_to_sal_check
+ *
  *	This is function called before going back from the OS_MCA handler
  *	to the OS_MCA dispatch code which finally takes the control back
  *	to the SAL.
  *	The main purpose of this routine is to setup the OS_MCA to SAL
  *	return state which can be used by the OS_MCA dispatch code
  *	just before going back to SAL.
- * Inputs
- *	None
- * Outputs
- *	None
+ *
+ *  Inputs  :   None
+ *  Outputs :   None
  */
 
 void
@@ -474,11 +666,13 @@
 	ia64_os_to_sal_handoff_state.imots_sal_check_ra =
 		ia64_sal_to_os_handoff_state.imsto_sal_check_ra;
 
-	/* For now ignore the MCA */
-	ia64_os_to_sal_handoff_state.imots_os_status = IA64_MCA_CORRECTED;
+	/* Cold Boot for uncorrectable MCA */
+	ia64_os_to_sal_handoff_state.imots_os_status = IA64_MCA_COLD_BOOT;
 }
+
 /*
  * ia64_mca_ucmc_handler
+ *
  *	This is uncorrectable machine check handler called from OS_MCA
  *	dispatch code which is in turn called from SAL_CHECK().
  *	This is the place where the core of OS MCA handling is done.
@@ -487,93 +681,92 @@
  *	monarch processor. Once the  monarch is done with MCA handling
  *	further MCA logging is enabled by clearing logs.
  *	Monarch also has the duty of sending wakeup-IPIs to pull the
- *	slave processors out of rendez. spinloop.
- * Inputs
- *	None
- * Outputs
- *	None
+ *  slave processors out of rendezvous spinloop.
+ *
+ *  Inputs  :   None
+ *  Outputs :   None
  */
 void
 ia64_mca_ucmc_handler(void)
 {
+#if 0   /* stubbed out @FVL */
+	/*
+	 *  Attempting to log a DBE error Causes "reserved register/field panic"
+	 *  in printk.
+	 */
 
-	/* Get the MCA processor log */
-	ia64_log_get(SAL_INFO_TYPE_MCA, SAL_SUB_INFO_TYPE_PROCESSOR, (prfunc_t)printk);
-	/* Get the MCA platform log */
-	ia64_log_get(SAL_INFO_TYPE_MCA, SAL_SUB_INFO_TYPE_PLATFORM, (prfunc_t)printk);
-
-	ia64_log_print(SAL_INFO_TYPE_MCA, SAL_SUB_INFO_TYPE_PROCESSOR, (prfunc_t)printk);
+	/* Get the MCA error record and log it */
+	ia64_mca_log_sal_error_record(SAL_INFO_TYPE_MCA);
+#endif  /* stubbed out @FVL */
 
 	/*
-	 * Do some error handling - Platform-specific mca handler is called at this point
+	 *  Do Platform-specific mca error handling if required.
 	 */
-
 	mca_handler_platform() ;
 
-	/* Clear the SAL MCA logs */
-	ia64_log_clear(SAL_INFO_TYPE_MCA, SAL_SUB_INFO_TYPE_PROCESSOR, 1, printk);
-	ia64_log_clear(SAL_INFO_TYPE_MCA, SAL_SUB_INFO_TYPE_PLATFORM, 1, printk);
-
-	/* Wakeup all the processors which are spinning in the rendezvous
-	 * loop.
+	/*
+	 *  Wakeup all the processors which are spinning in the rendezvous
+	 *  loop.
 	 */
 	ia64_mca_wakeup_all();
+
+	/* Return to SAL */
 	ia64_return_to_sal_check();
 }
 
 /*
  * ia64_mca_cmc_int_handler
- *	This is correctable machine check interrupt handler.
+ *
+ *  This is corrected machine check interrupt handler.
  *	Right now the logs are extracted and displayed in a well-defined
  *	format.
+ *
  * Inputs
- *	None
+ *      interrupt number
+ *      client data arg ptr
+ *      saved registers ptr
+ *
  * Outputs
  *	None
  */
 void
 ia64_mca_cmc_int_handler(int cmc_irq, void *arg, struct pt_regs *ptregs)
 {
-	/* Get the CMC processor log */
-	ia64_log_get(SAL_INFO_TYPE_CMC, SAL_SUB_INFO_TYPE_PROCESSOR, (prfunc_t)printk);
-	/* Get the CMC platform log */
-	ia64_log_get(SAL_INFO_TYPE_CMC, SAL_SUB_INFO_TYPE_PLATFORM, (prfunc_t)printk);
-
+	IA64_MCA_DEBUG("ia64_mca_cmc_int_handler : received interrupt vector = %#x on CPU %d\n",
+		       cmc_irq, smp_processor_id());
 
-	ia64_log_print(SAL_INFO_TYPE_CMC, SAL_SUB_INFO_TYPE_PROCESSOR, (prfunc_t)printk);
-	cmci_handler_platform(cmc_irq, arg, ptregs);
-
-	/* Clear the CMC SAL logs now that they have been saved in the OS buffer */
-	ia64_sal_clear_state_info(SAL_INFO_TYPE_CMC);
+	/* Get the CMC error record and log it */
+	ia64_mca_log_sal_error_record(SAL_INFO_TYPE_CMC);
 }
 
 /*
  * IA64_MCA log support
  */
 #define IA64_MAX_LOGS		2	/* Double-buffering for nested MCAs */
-#define IA64_MAX_LOG_TYPES	3	/* MCA, CMC, INIT */
-#define IA64_MAX_LOG_SUBTYPES	2	/* Processor, Platform */
+#define IA64_MAX_LOG_TYPES      4   /* MCA, INIT, CMC, CPE */
 
-typedef struct ia64_state_log_s {
+typedef struct ia64_state_log_s
+{
 	spinlock_t	isl_lock;
 	int		isl_index;
-	ia64_psilog_t	isl_log[IA64_MAX_LOGS];	/* need space to store header + error log */
+	ia64_err_rec_t  isl_log[IA64_MAX_LOGS]; /* need space to store header + error log */
 } ia64_state_log_t;
 
-static ia64_state_log_t	ia64_state_log[IA64_MAX_LOG_TYPES][IA64_MAX_LOG_SUBTYPES];
+static ia64_state_log_t ia64_state_log[IA64_MAX_LOG_TYPES];
 
-#define IA64_LOG_LOCK_INIT(it, sit)	spin_lock_init(&ia64_state_log[it][sit].isl_lock)
-#define IA64_LOG_LOCK(it, sit)		spin_lock_irqsave(&ia64_state_log[it][sit].isl_lock, s)
-#define IA64_LOG_UNLOCK(it, sit)	spin_unlock_irqrestore(&ia64_state_log[it][sit].isl_lock,\
-							       s)
-#define IA64_LOG_NEXT_INDEX(it, sit)	ia64_state_log[it][sit].isl_index
-#define IA64_LOG_CURR_INDEX(it, sit)	1 - ia64_state_log[it][sit].isl_index
-#define IA64_LOG_INDEX_INC(it, sit)	\
-	ia64_state_log[it][sit].isl_index = 1 - ia64_state_log[it][sit].isl_index
-#define IA64_LOG_INDEX_DEC(it, sit)	\
-	ia64_state_log[it][sit].isl_index = 1 - ia64_state_log[it][sit].isl_index
-#define IA64_LOG_NEXT_BUFFER(it, sit)	(void *)(&(ia64_state_log[it][sit].isl_log[IA64_LOG_NEXT_INDEX(it,sit)]))
-#define IA64_LOG_CURR_BUFFER(it, sit)	(void *)(&(ia64_state_log[it][sit].isl_log[IA64_LOG_CURR_INDEX(it,sit)]))
+/* Note:  Some of these macros assume IA64_MAX_LOGS is always 2.  Should be */
+/* fixed. @FVL                                                              */
+#define IA64_LOG_LOCK_INIT(it) spin_lock_init(&ia64_state_log[it].isl_lock)
+#define IA64_LOG_LOCK(it)      spin_lock_irqsave(&ia64_state_log[it].isl_lock, s)
+#define IA64_LOG_UNLOCK(it)    spin_unlock_irqrestore(&ia64_state_log[it].isl_lock,s)
+#define IA64_LOG_NEXT_INDEX(it)    ia64_state_log[it].isl_index
+#define IA64_LOG_CURR_INDEX(it)    1 - ia64_state_log[it].isl_index
+#define IA64_LOG_INDEX_INC(it) \
+    ia64_state_log[it].isl_index = 1 - ia64_state_log[it].isl_index
+#define IA64_LOG_INDEX_DEC(it) \
+    ia64_state_log[it].isl_index = 1 - ia64_state_log[it].isl_index
+#define IA64_LOG_NEXT_BUFFER(it)   (void *)(&(ia64_state_log[it].isl_log[IA64_LOG_NEXT_INDEX(it)]))
+#define IA64_LOG_CURR_BUFFER(it)   (void *)(&(ia64_state_log[it].isl_log[IA64_LOG_CURR_INDEX(it)]))
 
 /*
  * C portion of the OS INIT handler
@@ -584,123 +777,216 @@
  *
  * Returns:
  *   0 if SAL must warm boot the System
- *   1 if SAL must retrun to interrupted context using PAL_MC_RESUME
+ *   1 if SAL must return to interrupted context using PAL_MC_RESUME
  *
  */
-
 void
 ia64_init_handler (struct pt_regs *regs)
 {
 	sal_log_processor_info_t *proc_ptr;
-	ia64_psilog_t *plog_ptr;
+	ia64_err_rec_t *plog_ptr;
 
 	printk("Entered OS INIT handler\n");
 
 	/* Get the INIT processor log */
-	ia64_log_get(SAL_INFO_TYPE_INIT, SAL_SUB_INFO_TYPE_PROCESSOR, (prfunc_t)printk);
-	/* Get the INIT platform log */
-	ia64_log_get(SAL_INFO_TYPE_INIT, SAL_SUB_INFO_TYPE_PLATFORM, (prfunc_t)printk);
+	if (!ia64_log_get(SAL_INFO_TYPE_INIT, (prfunc_t)printk))
+		return;                 // no record retrieved
 
 #ifdef IA64_DUMP_ALL_PROC_INFO
-	ia64_log_print(SAL_INFO_TYPE_INIT, SAL_SUB_INFO_TYPE_PROCESSOR, (prfunc_t)printk);
+	ia64_log_print(SAL_INFO_TYPE_INIT, (prfunc_t)printk);
 #endif
 
 	/*
 	 * get pointer to min state save area
 	 *
 	 */
-	plog_ptr=(ia64_psilog_t *)IA64_LOG_CURR_BUFFER(SAL_INFO_TYPE_INIT,
-						       SAL_SUB_INFO_TYPE_PROCESSOR);
-	proc_ptr = &plog_ptr->devlog.proclog;
+	plog_ptr=(ia64_err_rec_t *)IA64_LOG_CURR_BUFFER(SAL_INFO_TYPE_INIT);
+	proc_ptr = &plog_ptr->proc_err;
 
-	ia64_process_min_state_save(&proc_ptr->slpi_min_state_area,regs);
-
-	init_handler_platform(regs);              /* call platform specific routines */
+	ia64_process_min_state_save(&proc_ptr->processor_static_info.min_state_area,
+				    regs);
 
 	/* Clear the INIT SAL logs now that they have been saved in the OS buffer */
 	ia64_sal_clear_state_info(SAL_INFO_TYPE_INIT);
+
+	init_handler_platform(regs);              /* call platform specific routines */
 }
 
 /*
+ *  ia64_log_prt_guid
+ *
+ *  Print a formatted GUID.
+ *
+ * Inputs   :   p_guid      (ptr to the GUID)
+ *              prfunc      (print function)
+ * Outputs  :   None
+ *
+ */
+void
+ia64_log_prt_guid (efi_guid_t *p_guid, prfunc_t prfunc)
+{
+	printk("GUID = { %08x, %04x, %04x, { %#02x, %#02x, %#02x, %#02x, "
+	       "%#02x, %#02x, %#02x, %#02x, } } \n ", p_guid->data1,
+	       p_guid->data2, p_guid->data3, p_guid->data4[0], p_guid->data4[1],
+	       p_guid->data4[2], p_guid->data4[3], p_guid->data4[4],
+	       p_guid->data4[5], p_guid->data4[6], p_guid->data4[7]);
+}
+
+#ifdef MCA_PRT_XTRA_DATA    // for test only @FVL
+static void
+ia64_log_hexdump(unsigned char *p, unsigned long n_ch, prfunc_t prfunc)
+{
+	int i, j;
+
+	if (!p)
+		return;
+
+	for (i = 0; i < n_ch;) {
+		prfunc("%p ", (void *)p);
+		for (j = 0; (j < 16) && (i < n_ch); i++, j++, p++) {
+			prfunc("%02x ", *p);
+		}
+		prfunc("\n");
+	}
+}
+
+static void
+ia64_log_prt_record_header (sal_log_record_header_t *rh, prfunc_t prfunc)
+{
+	prfunc("SAL RECORD HEADER:  Record buffer = %p,  header size = %ld\n",
+	       (void *)rh, sizeof(sal_log_record_header_t));
+	ia64_log_hexdump((unsigned char *)rh, sizeof(sal_log_record_header_t),
+			 (prfunc_t)prfunc);
+	prfunc("Total record length = %d\n", rh->len);
+	ia64_log_prt_guid(&rh->platform_guid, prfunc);
+	prfunc("End of SAL RECORD HEADER\n");
+}
+
+static void
+ia64_log_prt_section_header (sal_log_section_hdr_t *sh, prfunc_t prfunc)
+{
+	prfunc("SAL SECTION HEADER:  Record buffer = %p,  header size = %ld\n",
+	       (void *)sh, sizeof(sal_log_section_hdr_t));
+	ia64_log_hexdump((unsigned char *)sh, sizeof(sal_log_section_hdr_t),
+			 (prfunc_t)prfunc);
+	prfunc("Length of section & header = %d\n", sh->len);
+	ia64_log_prt_guid(&sh->guid, prfunc);
+	prfunc("End of SAL SECTION HEADER\n");
+}
+#endif  // MCA_PRT_XTRA_DATA for test only @FVL
+
+/*
  * ia64_log_init
  *	Reset the OS ia64 log buffer
- * Inputs	:	info_type	(SAL_INFO_TYPE_{MCA,INIT,CMC})
- *			sub_info_type	(SAL_SUB_INFO_TYPE_{PROCESSOR,PLATFORM})
+ * Inputs   :   info_type   (SAL_INFO_TYPE_{MCA,INIT,CMC,CPE})
  * Outputs	:	None
  */
 void
-ia64_log_init(int sal_info_type, int sal_sub_info_type)
+ia64_log_init(int sal_info_type)
 {
-	IA64_LOG_LOCK_INIT(sal_info_type, sal_sub_info_type);
-	IA64_LOG_NEXT_INDEX(sal_info_type, sal_sub_info_type) = 0;
-	memset(IA64_LOG_NEXT_BUFFER(sal_info_type, sal_sub_info_type), 0,
-	       sizeof(ia64_psilog_t) * IA64_MAX_LOGS);
+	IA64_LOG_LOCK_INIT(sal_info_type);
+	IA64_LOG_NEXT_INDEX(sal_info_type) = 0;
+	memset(IA64_LOG_NEXT_BUFFER(sal_info_type), 0,
+	       sizeof(ia64_err_rec_t) * IA64_MAX_LOGS);
 }
 
 /*
  * ia64_log_get
+ *
  *	Get the current MCA log from SAL and copy it into the OS log buffer.
- * Inputs	:	info_type	(SAL_INFO_TYPE_{MCA,INIT,CMC})
- *			sub_info_type	(SAL_SUB_INFO_TYPE_{PROCESSOR,PLATFORM})
- * Outputs	:	None
+ *
+ *  Inputs  :   info_type   (SAL_INFO_TYPE_{MCA,INIT,CMC,CPE})
+ *              prfunc      (fn ptr of log output function)
+ *  Outputs :   size        (total record length)
  *
  */
-void
-ia64_log_get(int sal_info_type, int sal_sub_info_type, prfunc_t prfunc)
+u64
+ia64_log_get(int sal_info_type, prfunc_t prfunc)
 {
-	sal_log_header_t	*log_buffer;
-	int			s,total_len=0;
-
-	IA64_LOG_LOCK(sal_info_type, sal_sub_info_type);
+	sal_log_record_header_t     *log_buffer;
+	u64                         total_len = 0;
+	int                         s;
 
+	IA64_LOG_LOCK(sal_info_type);
 
 	/* Get the process state information */
-	log_buffer = IA64_LOG_NEXT_BUFFER(sal_info_type, sal_sub_info_type);
-
-	if (!(total_len=ia64_sal_get_state_info(sal_info_type,(u64 *)log_buffer)))
-		prfunc("ia64_mca_log_get : Getting processor log failed\n");
-
-	IA64_MCA_DEBUG("ia64_log_get: retrieved %d bytes of error information\n",total_len);
+	log_buffer = IA64_LOG_NEXT_BUFFER(sal_info_type);
 
-	IA64_LOG_INDEX_INC(sal_info_type, sal_sub_info_type);
-
-	IA64_LOG_UNLOCK(sal_info_type, sal_sub_info_type);
+	total_len = ia64_sal_get_state_info(sal_info_type, (u64 *)log_buffer);
 
+	if (total_len) {
+		IA64_LOG_INDEX_INC(sal_info_type);
+		IA64_LOG_UNLOCK(sal_info_type);
+		IA64_MCA_DEBUG("ia64_log_get: SAL error record type %d retrieved. "
+			       "Record length = %ld\n", sal_info_type, total_len);
+		return total_len;
+	} else {
+		IA64_LOG_UNLOCK(sal_info_type);
+		prfunc("ia64_log_get : Failed to retrieve SAL error record type %d\n",
+		       sal_info_type);
+		return 0;
+	}
 }
 
 /*
- * ia64_log_clear
- *	Clear the current MCA log from SAL and dpending on the clear_os_buffer flags
- *	clear the OS log buffer also
- * Inputs	:	info_type	(SAL_INFO_TYPE_{MCA,INIT,CMC})
- *			sub_info_type	(SAL_SUB_INFO_TYPE_{PROCESSOR,PLATFORM})
- *			clear_os_buffer
+ *  ia64_log_prt_oem_data
+ *
+ *  Print OEM specific data if included.
+ *
+ * Inputs   :   header_len  (length passed in section header)
+ *              sect_len    (default length of section type)
+ *              p_data      (ptr to data)
  *			prfunc		(print function)
  * Outputs	:	None
  *
  */
 void
-ia64_log_clear(int sal_info_type, int sal_sub_info_type, int clear_os_buffer, prfunc_t prfunc)
+ia64_log_prt_oem_data (int header_len, int sect_len, u8 *p_data, prfunc_t prfunc)
 {
-	if (ia64_sal_clear_state_info(sal_info_type))
-		prfunc("ia64_mca_log_get : Clearing processor log failed\n");
-
-	if (clear_os_buffer) {
-		sal_log_header_t	*log_buffer;
-		int			s;
-
-		IA64_LOG_LOCK(sal_info_type, sal_sub_info_type);
+	int oem_data_len, i;
 
-		/* Get the process state information */
-		log_buffer = IA64_LOG_CURR_BUFFER(sal_info_type, sal_sub_info_type);
-
-		memset(log_buffer, 0, sizeof(ia64_psilog_t));
-
-		IA64_LOG_INDEX_DEC(sal_info_type, sal_sub_info_type);
-
-		IA64_LOG_UNLOCK(sal_info_type, sal_sub_info_type);
+	if ((oem_data_len = header_len - sect_len) > 0) {
+		prfunc(" OEM Specific Data:");
+		for (i = 0; i < oem_data_len; i++, p_data++)
+			prfunc(" %02x", *p_data);
 	}
+	prfunc("\n");
+}
 
+/*
+ *  ia64_log_rec_header_print
+ *
+ *  Log info from the SAL error record header.
+ *
+ *  Inputs  :   lh *    (ptr to SAL log error record header)
+ *              prfunc  (fn ptr of log output function to use)
+ *  Outputs :   None
+ */
+void
+ia64_log_rec_header_print (sal_log_record_header_t *lh, prfunc_t prfunc)
+{
+	char str_buf[32];
+
+	sprintf(str_buf, "%2d.%02d",
+		(lh->revision.major >> 4) * 10 + (lh->revision.major & 0xf),
+		(lh->revision.minor >> 4) * 10 + (lh->revision.minor & 0xf));
+	prfunc("+Err Record ID: %d    SAL Rev: %s\n", lh->id, str_buf);
+	sprintf(str_buf, "%02d/%02d/%04d/ %02d:%02d:%02d",
+		(lh->timestamp.slh_month >> 4) * 10 +
+		(lh->timestamp.slh_month & 0xf),
+		(lh->timestamp.slh_day >> 4) * 10 +
+		(lh->timestamp.slh_day & 0xf),
+		(lh->timestamp.slh_century >> 4) * 1000 +
+		(lh->timestamp.slh_century & 0xf) * 100 +
+		(lh->timestamp.slh_year >> 4) * 10 +
+		(lh->timestamp.slh_year & 0xf),
+		(lh->timestamp.slh_hour >> 4) * 10 +
+		(lh->timestamp.slh_hour & 0xf),
+		(lh->timestamp.slh_minute >> 4) * 10 +
+		(lh->timestamp.slh_minute & 0xf),
+		(lh->timestamp.slh_second >> 4) * 10 +
+		(lh->timestamp.slh_second & 0xf));
+	prfunc("+Time: %s    Severity %d\n", str_buf, lh->severity);
 }
 
 /*
@@ -729,6 +1015,33 @@
 		prfunc("+ %s[%d] 0x%lx\n", reg_prefix, i, regs[i]);
 }
 
+/*
+ * ia64_log_processor_fp_regs_print
+ *  Print the contents of the saved floating page register(s) in the format
+ *      <reg_prefix>[<index>] <value>
+ *
+ * Inputs:  ia64_fpreg  (Register save buffer)
+ *          reg_num     (# of registers)
+ *          reg_class   (application/banked/control/bank1_general)
+ *          reg_prefix  (ar/br/cr/b1_gr)
+ * Outputs: None
+ *
+ */
+void
+ia64_log_processor_fp_regs_print (struct ia64_fpreg *regs,
+                                  int               reg_num,
+                                  char              *reg_class,
+                                  char              *reg_prefix,
+                                  prfunc_t          prfunc)
+{
+	int i;
+
+	prfunc("+%s Registers\n", reg_class);
+	for (i = 0; i < reg_num; i++)
+		prfunc("+ %s[%d] 0x%lx%016lx\n", reg_prefix, i, regs[i].u.bits[1],
+		       regs[i].u.bits[0]);
+}
+
 static char *pal_mesi_state[] = {
 	"Invalid",
 	"Shared",
@@ -754,69 +1067,91 @@
 /*
  * ia64_log_cache_check_info_print
  *	Display the machine check information related to cache error(s).
- * Inputs	:	i		(Multiple errors are logged, i - index of logged error)
- *			info		(Machine check info logged by the PAL and later
+ * Inputs:  i           (Multiple errors are logged, i - index of logged error)
+ *          cc_info *   (Ptr to cache check info logged by the PAL and later
  *					 captured by the SAL)
- *			target_addr	(Address which caused the cache error)
- * Outputs	:	None
+ *          prfunc      (fn ptr of print function to be used for output)
+ * Outputs: None
  */
 void
-ia64_log_cache_check_info_print(int			i,
-				pal_cache_check_info_t	info,
-				u64			target_addr,
-				prfunc_t		prfunc)
+ia64_log_cache_check_info_print (int                      i,
+                                 sal_log_mod_error_info_t *cache_check_info,
+				 prfunc_t		prfunc)
 {
+	pal_cache_check_info_t  *info;
+	u64                     target_addr;
+
+	if (!cache_check_info->valid.check_info) {
+		IA64_MCA_DEBUG("ia64_mca_log_print : invalid cache_check_info[%d]\n",i);
+		return;                 /* If check info data not valid, skip it */
+	}
+
+	info        = (pal_cache_check_info_t *)&cache_check_info->check_info;
+	target_addr = cache_check_info->target_identifier;
+
 	prfunc("+ Cache check info[%d]\n+", i);
-	prfunc("  Level: L%d",info.level);
-	if (info.mv)
-		prfunc(" ,Mesi: %s",pal_mesi_state[info.mesi]);
-	prfunc(" ,Index: %d,", info.index);
-	if (info.ic)
-		prfunc(" ,Cache: Instruction");
-	if (info.dc)
-		prfunc(" ,Cache: Data");
-	if (info.tl)
-		prfunc(" ,Line: Tag");
-	if (info.dl)
-		prfunc(" ,Line: Data");
-	prfunc(" ,Operation: %s,", pal_cache_op[info.op]);
-	if (info.wv)
-		prfunc(" ,Way: %d,", info.way);
-	if (info.tv)
-		prfunc(" ,Target Addr: 0x%lx", target_addr);
-	if (info.mc)
-		prfunc(" ,MC: Corrected");
+	prfunc("  Level: L%d,",info->level);
+	if (info->mv)
+		prfunc(" Mesi: %s,",pal_mesi_state[info->mesi]);
+	prfunc(" Index: %d,", info->index);
+	if (info->ic)
+		prfunc(" Cache: Instruction,");
+	if (info->dc)
+		prfunc(" Cache: Data,");
+	if (info->tl)
+		prfunc(" Line: Tag,");
+	if (info->dl)
+		prfunc(" Line: Data,");
+	prfunc(" Operation: %s,", pal_cache_op[info->op]);
+	if (info->wv)
+		prfunc(" Way: %d,", info->way);
+	if (cache_check_info->valid.target_identifier)
+		/* Hope target address is saved in target_identifier */
+		if (info->tv)
+			prfunc(" Target Addr: 0x%lx,", target_addr);
+	if (info->mc)
+		prfunc(" MC: Corrected");
 	prfunc("\n");
 }
 
 /*
  * ia64_log_tlb_check_info_print
  *	Display the machine check information related to tlb error(s).
- * Inputs	:	i		(Multiple errors are logged, i - index of logged error)
- *			info		(Machine check info logged by the PAL and later
+ * Inputs:  i           (Multiple errors are logged, i - index of logged error)
+ *          tlb_info *  (Ptr to machine check info logged by the PAL and later
  *					 captured by the SAL)
- * Outputs	:	None
+ *          prfunc      (fn ptr of print function to be used for output)
+ * Outputs: None
  */
-
 void
-ia64_log_tlb_check_info_print(int			i,
-			      pal_tlb_check_info_t	info,
-			      prfunc_t			prfunc)
+ia64_log_tlb_check_info_print (int                      i,
+                               sal_log_mod_error_info_t *tlb_check_info,
+                               prfunc_t                 prfunc)
+
 {
+	pal_tlb_check_info_t    *info;
+
+	if (!tlb_check_info->valid.check_info) {
+		IA64_MCA_DEBUG("ia64_mca_log_print : invalid tlb_check_info[%d]\n", i);
+		return;                 /* If check info data not valid, skip it */
+	}
+
+	info = (pal_tlb_check_info_t *)&tlb_check_info->check_info;
+
 	prfunc("+ TLB Check Info [%d]\n+", i);
-	if (info.itc)
+	if (info->itc)
 		prfunc("  Failure: Instruction Translation Cache");
-	if (info.dtc)
+	if (info->dtc)
 		prfunc("  Failure: Data Translation Cache");
-	if (info.itr) {
+	if (info->itr) {
 		prfunc("  Failure: Instruction Translation Register");
-		prfunc(" ,Slot: %d", info.tr_slot);
+		prfunc(" ,Slot: %d", info->tr_slot);
 	}
-	if (info.dtr) {
+	if (info->dtr) {
 		prfunc("  Failure: Data Translation Register");
-		prfunc(" ,Slot: %d", info.tr_slot);
+		prfunc(" ,Slot: %d", info->tr_slot);
 	}
-	if (info.mc)
+	if (info->mc)
 		prfunc(" ,MC: Corrected");
 	prfunc("\n");
 }
@@ -824,159 +1159,719 @@
 /*
  * ia64_log_bus_check_info_print
  *	Display the machine check information related to bus error(s).
- * Inputs	:	i		(Multiple errors are logged, i - index of logged error)
- *			info		(Machine check info logged by the PAL and later
+ * Inputs:  i           (Multiple errors are logged, i - index of logged error)
+ *          bus_info *  (Ptr to machine check info logged by the PAL and later
  *					 captured by the SAL)
- *			req_addr	(Address of the requestor of the transaction)
- *			resp_addr	(Address of the responder of the transaction)
- *			target_addr	(Address where the data was to be delivered to  or
- *					 obtained from)
- * Outputs	:	None
+ *          prfunc      (fn ptr of print function to be used for output)
+ * Outputs: None
  */
 void
-ia64_log_bus_check_info_print(int			i,
-			      pal_bus_check_info_t	info,
-			      u64			req_addr,
-			      u64			resp_addr,
-			      u64			targ_addr,
-			      prfunc_t			prfunc)
-{
+ia64_log_bus_check_info_print (int                      i,
+                               sal_log_mod_error_info_t *bus_check_info,
+                               prfunc_t                 prfunc)
+{
+	pal_bus_check_info_t *info;
+	u64         req_addr;   /* Address of the requestor of the transaction */
+	u64         resp_addr;  /* Address of the responder of the transaction */
+	u64         targ_addr;  /* Address where the data was to be delivered to */
+	/* or obtained from */
+
+	if (!bus_check_info->valid.check_info) {
+		IA64_MCA_DEBUG("ia64_mca_log_print : invalid bus_check_info[%d]\n", i);
+		return;                 /* If check info data not valid, skip it */
+	}
+
+	info      = (pal_bus_check_info_t *)&bus_check_info->check_info;
+	req_addr  = bus_check_info->requestor_identifier;
+	resp_addr = bus_check_info->responder_identifier;
+	targ_addr = bus_check_info->target_identifier;
+
 	prfunc("+ BUS Check Info [%d]\n+", i);
-	prfunc(" Status Info: %d", info.bsi);
-	prfunc(" ,Severity: %d", info.sev);
-	prfunc(" ,Transaction Type: %d", info.type);
-	prfunc(" ,Transaction Size: %d", info.size);
-	if (info.cc)
+	prfunc(" Status Info: %d", info->bsi);
+	prfunc(" ,Severity: %d", info->sev);
+	prfunc(" ,Transaction Type: %d", info->type);
+	prfunc(" ,Transaction Size: %d", info->size);
+	if (info->cc)
 		prfunc(" ,Cache-cache-transfer");
-	if (info.ib)
+	if (info->ib)
 		prfunc(" ,Error: Internal");
-	if (info.eb)
+	if (info->eb)
 		prfunc(" ,Error: External");
-	if (info.mc)
+	if (info->mc)
 		prfunc(" ,MC: Corrected");
-	if (info.tv)
+	if (info->tv)
 		prfunc(" ,Target Address: 0x%lx", targ_addr);
-	if (info.rq)
+	if (info->rq)
 		prfunc(" ,Requestor Address: 0x%lx", req_addr);
-	if (info.tv)
+	if (info->tv)
 		prfunc(" ,Responder Address: 0x%lx", resp_addr);
 	prfunc("\n");
 }
 
 /*
+ *  ia64_log_mem_dev_err_info_print
+ *
+ *  Format and log the platform memory device error record section data.
+ *
+ *  Inputs:  mem_dev_err_info * (Ptr to memory device error record section
+ *                               returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_mem_dev_err_info_print (sal_log_mem_dev_err_info_t *mdei,
+                                 prfunc_t                   prfunc)
+{
+	prfunc("+ Mem Error Detail: ");
+
+	if (mdei->valid.error_status)
+		prfunc(" Error Status: %#lx,", mdei->error_status);
+	if (mdei->valid.physical_addr)
+		prfunc(" Physical Address: %#lx,", mdei->physical_addr);
+	if (mdei->valid.addr_mask)
+		prfunc(" Address Mask: %#lx,", mdei->addr_mask);
+	if (mdei->valid.node)
+		prfunc(" Node: %d,", mdei->node);
+	if (mdei->valid.card)
+		prfunc(" Card: %d,", mdei->card);
+	if (mdei->valid.module)
+		prfunc(" Module: %d,", mdei->module);
+	if (mdei->valid.bank)
+		prfunc(" Bank: %d,", mdei->bank);
+	if (mdei->valid.device)
+		prfunc(" Device: %d,", mdei->device);
+	if (mdei->valid.row)
+		prfunc(" Row: %d,", mdei->row);
+	if (mdei->valid.column)
+		prfunc(" Column: %d,", mdei->column);
+	if (mdei->valid.bit_position)
+		prfunc(" Bit Position: %d,", mdei->bit_position);
+	if (mdei->valid.target_id)
+		prfunc(" ,Target Address: %#lx,", mdei->target_id);
+	if (mdei->valid.requestor_id)
+		prfunc(" ,Requestor Address: %#lx,", mdei->requestor_id);
+	if (mdei->valid.responder_id)
+		prfunc(" ,Responder Address: %#lx,", mdei->responder_id);
+	if (mdei->valid.bus_spec_data)
+		prfunc(" Bus Specific Data: %#lx,", mdei->bus_spec_data);
+	prfunc("\n");
+
+	if (mdei->valid.oem_id) {
+		u8  *p_data = &(mdei->oem_id[0]);
+		int i;
+
+		prfunc(" OEM Memory Controller ID:");
+		for (i = 0; i < 16; i++, p_data++)
+			prfunc(" %02x", *p_data);
+		prfunc("\n");
+	}
+
+	if (mdei->valid.oem_data) {
+		ia64_log_prt_oem_data((int)mdei->header.len,
+				      (int)sizeof(sal_log_mem_dev_err_info_t) - 1,
+				      &(mdei->oem_data[0]), prfunc);
+	}
+}
+
+/*
+ *  ia64_log_sel_dev_err_info_print
+ *
+ *  Format and log the platform SEL device error record section data.
+ *
+ *  Inputs:  sel_dev_err_info * (Ptr to the SEL device error record section
+ *                               returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_sel_dev_err_info_print (sal_log_sel_dev_err_info_t *sdei,
+                                 prfunc_t                   prfunc)
+{
+	int     i;
+
+	prfunc("+ SEL Device Error Detail: ");
+
+	if (sdei->valid.record_id)
+		prfunc(" Record ID: %#x", sdei->record_id);
+	if (sdei->valid.record_type)
+		prfunc(" Record Type: %#x", sdei->record_type);
+	prfunc(" Time Stamp: ");
+	for (i = 0; i < 4; i++)
+		prfunc("%1d", sdei->timestamp[i]);
+	if (sdei->valid.generator_id)
+		prfunc(" Generator ID: %#x", sdei->generator_id);
+	if (sdei->valid.evm_rev)
+		prfunc(" Message Format Version: %#x", sdei->evm_rev);
+	if (sdei->valid.sensor_type)
+		prfunc(" Sensor Type: %#x", sdei->sensor_type);
+	if (sdei->valid.sensor_num)
+		prfunc(" Sensor Number: %#x", sdei->sensor_num);
+	if (sdei->valid.event_dir)
+		prfunc(" Event Direction Type: %#x", sdei->event_dir);
+	if (sdei->valid.event_data1)
+		prfunc(" Data1: %#x", sdei->event_data1);
+	if (sdei->valid.event_data2)
+		prfunc(" Data2: %#x", sdei->event_data2);
+	if (sdei->valid.event_data3)
+		prfunc(" Data3: %#x", sdei->event_data3);
+	prfunc("\n");
+
+}
+
+/*
+ *  ia64_log_pci_bus_err_info_print
+ *
+ *  Format and log the platform PCI bus error record section data.
+ *
+ *  Inputs:  pci_bus_err_info * (Ptr to the PCI bus error record section
+ *                               returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_pci_bus_err_info_print (sal_log_pci_bus_err_info_t *pbei,
+                                 prfunc_t                   prfunc)
+{
+	prfunc("+ PCI Bus Error Detail: ");
+
+	if (pbei->valid.err_status)
+		prfunc(" Error Status: %#lx", pbei->err_status);
+	if (pbei->valid.err_type)
+		prfunc(" Error Type: %#x", pbei->err_type);
+	if (pbei->valid.bus_id)
+		prfunc(" Bus ID: %#x", pbei->bus_id);
+	if (pbei->valid.bus_address)
+		prfunc(" Bus Address: %#lx", pbei->bus_address);
+	if (pbei->valid.bus_data)
+		prfunc(" Bus Data: %#lx", pbei->bus_data);
+	if (pbei->valid.bus_cmd)
+		prfunc(" Bus Command: %#lx", pbei->bus_cmd);
+	if (pbei->valid.requestor_id)
+		prfunc(" Requestor ID: %#lx", pbei->requestor_id);
+	if (pbei->valid.responder_id)
+		prfunc(" Responder ID: %#lx", pbei->responder_id);
+	if (pbei->valid.target_id)
+		prfunc(" Target ID: %#lx", pbei->target_id);
+	if (pbei->valid.oem_data)
+		prfunc("\n");
+
+	if (pbei->valid.oem_data) {
+		ia64_log_prt_oem_data((int)pbei->header.len,
+				      (int)sizeof(sal_log_pci_bus_err_info_t) - 1,
+				      &(pbei->oem_data[0]), prfunc);
+	}
+}
+
+/*
+ *  ia64_log_smbios_dev_err_info_print
+ *
+ *  Format and log the platform SMBIOS device error record section data.
+ *
+ *  Inputs:  smbios_dev_err_info * (Ptr to the SMBIOS device error record
+ *                                  section returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_smbios_dev_err_info_print (sal_log_smbios_dev_err_info_t *sdei,
+                                    prfunc_t                      prfunc)
+{
+	u8      i;
+
+	prfunc("+ SMBIOS Device Error Detail: ");
+
+	if (sdei->valid.event_type)
+		prfunc(" Event Type: %#x", sdei->event_type);
+	if (sdei->valid.time_stamp) {
+		prfunc(" Time Stamp: ");
+		for (i = 0; i < 6; i++)
+			prfunc("%d", sdei->time_stamp[i]);
+	}
+	if ((sdei->valid.data) && (sdei->valid.length)) {
+		prfunc(" Data: ");
+		for (i = 0; i < sdei->length; i++)
+			prfunc(" %02x", sdei->data[i]);
+	}
+	prfunc("\n");
+}
+
+/*
+ *  ia64_log_pci_comp_err_info_print
+ *
+ *  Format and log the platform PCI component error record section data.
+ *
+ *  Inputs:  pci_comp_err_info * (Ptr to the PCI component error record section
+ *                                returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_pci_comp_err_info_print(sal_log_pci_comp_err_info_t *pcei,
+				 prfunc_t                     prfunc)
+{
+	u32     n_mem_regs, n_io_regs;
+	u64     i, n_pci_data;
+	u64     *p_reg_data;
+	u8      *p_oem_data;
+
+	prfunc("+ PCI Component Error Detail: ");
+
+	if (pcei->valid.err_status)
+		prfunc(" Error Status: %#lx\n", pcei->err_status);
+	if (pcei->valid.comp_info)
+		prfunc(" Component Info: Vendor Id = %#x, Device Id = %#x,"
+		       " Class Code = %#x, Seg/Bus/Dev/Func = %d/%d/%d/%d\n",
+		       pcei->comp_info.vendor_id, pcei->comp_info.device_id,
+		       pcei->comp_info.class_code, pcei->comp_info.seg_num,
+		       pcei->comp_info.bus_num, pcei->comp_info.dev_num,
+		       pcei->comp_info.func_num);
+
+	n_mem_regs = (pcei->valid.num_mem_regs) ? pcei->num_mem_regs : 0;
+	n_io_regs =  (pcei->valid.num_io_regs)  ? pcei->num_io_regs  : 0;
+	p_reg_data = &(pcei->reg_data_pairs[0]);
+	p_oem_data = (u8 *)p_reg_data +
+		(n_mem_regs + n_io_regs) * 2 * sizeof(u64);
+	n_pci_data = p_oem_data - (u8 *)pcei;
+
+	if (n_pci_data > pcei->header.len) {
+		prfunc(" Invalid PCI Component Error Record format: length = %ld, "
+		       " Size PCI Data = %d, Num Mem-Map/IO-Map Regs = %ld/%ld\n",
+		       pcei->header.len, n_pci_data, n_mem_regs, n_io_regs);
+		return;
+	}
+
+	if (n_mem_regs) {
+		prfunc(" Memory Mapped Registers\n Address \tValue\n");
+		for (i = 0; i < pcei->num_mem_regs; i++) {
+			prfunc(" %#lx %#lx\n", p_reg_data[0], p_reg_data[1]);
+			p_reg_data += 2;
+		}
+	}
+	if (n_io_regs) {
+		prfunc(" I/O Mapped Registers\n Address \tValue\n");
+		for (i = 0; i < pcei->num_io_regs; i++) {
+			prfunc(" %#lx %#lx\n", p_reg_data[0], p_reg_data[1]);
+			p_reg_data += 2;
+		}
+	}
+	if (pcei->valid.oem_data) {
+		ia64_log_prt_oem_data((int)pcei->header.len, n_pci_data,
+				      p_oem_data, prfunc);
+		prfunc("\n");
+	}
+}
+
+/*
+ *  ia64_log_plat_specific_err_info_print
+ *
+ *  Format and log the platform specifie error record section data.
+ *
+ *  Inputs:  sel_dev_err_info * (Ptr to the platform specific error record
+ *                               section returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_plat_specific_err_info_print (sal_log_plat_specific_err_info_t *psei,
+                                       prfunc_t                         prfunc)
+{
+	prfunc("+ Platform Specific Error Detail: ");
+
+	if (psei->valid.err_status)
+		prfunc(" Error Status: %#lx", psei->err_status);
+	if (psei->valid.guid) {
+		prfunc(" GUID: ");
+		ia64_log_prt_guid(&psei->guid, prfunc);
+	}
+	if (psei->valid.oem_data) {
+		ia64_log_prt_oem_data((int)psei->header.len,
+				      (int)sizeof(sal_log_plat_specific_err_info_t) - 1,
+				      &(psei->oem_data[0]), prfunc);
+	}
+	prfunc("\n");
+}
+
+/*
+ *  ia64_log_host_ctlr_err_info_print
+ *
+ *  Format and log the platform host controller error record section data.
+ *
+ *  Inputs:  host_ctlr_err_info * (Ptr to the host controller error record
+ *                                 section returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_host_ctlr_err_info_print (sal_log_host_ctlr_err_info_t *hcei,
+                                   prfunc_t                     prfunc)
+{
+	prfunc("+ Host Controller Error Detail: ");
+
+	if (hcei->valid.err_status)
+		prfunc(" Error Status: %#lx", hcei->err_status);
+	if (hcei->valid.requestor_id)
+		prfunc(" Requestor ID: %#lx", hcei->requestor_id);
+	if (hcei->valid.responder_id)
+		prfunc(" Responder ID: %#lx", hcei->responder_id);
+	if (hcei->valid.target_id)
+		prfunc(" Target ID: %#lx", hcei->target_id);
+	if (hcei->valid.bus_spec_data)
+		prfunc(" Bus Specific Data: %#lx", hcei->bus_spec_data);
+	if (hcei->valid.oem_data) {
+		ia64_log_prt_oem_data((int)hcei->header.len,
+				      (int)sizeof(sal_log_host_ctlr_err_info_t) - 1,
+				      &(hcei->oem_data[0]), prfunc);
+	}
+	prfunc("\n");
+}
+
+/*
+ *  ia64_log_plat_bus_err_info_print
+ *
+ *  Format and log the platform bus error record section data.
+ *
+ *  Inputs:  plat_bus_err_info * (Ptr to the platform bus error record section
+ *                                returned by SAL)
+ *           prfunc             (fn ptr of print function to be used for output)
+ *  Outputs: None
+ */
+void
+ia64_log_plat_bus_err_info_print (sal_log_plat_bus_err_info_t *pbei,
+                                  prfunc_t                    prfunc)
+{
+	prfunc("+ Platform Bus Error Detail: ");
+
+	if (pbei->valid.err_status)
+		prfunc(" Error Status: %#lx", pbei->err_status);
+	if (pbei->valid.requestor_id)
+		prfunc(" Requestor ID: %#lx", pbei->requestor_id);
+	if (pbei->valid.responder_id)
+		prfunc(" Responder ID: %#lx", pbei->responder_id);
+	if (pbei->valid.target_id)
+		prfunc(" Target ID: %#lx", pbei->target_id);
+	if (pbei->valid.bus_spec_data)
+		prfunc(" Bus Specific Data: %#lx", pbei->bus_spec_data);
+	if (pbei->valid.oem_data) {
+		ia64_log_prt_oem_data((int)pbei->header.len,
+				      (int)sizeof(sal_log_plat_bus_err_info_t) - 1,
+				      &(pbei->oem_data[0]), prfunc);
+	}
+	prfunc("\n");
+}
+
+/*
+ *  ia64_log_proc_dev_err_info_print
+ *
+ *  Display the processor device error record.
+ *
+ *  Inputs:  sal_log_processor_info_t * (Ptr to processor device error record
+ *                                       section body).
+ *           prfunc                     (fn ptr of print function to be used
+ *                                       for output).
+ *  Outputs: None
+ */
+void
+ia64_log_proc_dev_err_info_print (sal_log_processor_info_t  *slpi,
+                                  prfunc_t                  prfunc)
+{
+	size_t  d_len = slpi->header.len - sizeof(sal_log_section_hdr_t);
+	sal_processor_static_info_t *spsi;
+	int                         i;
+	sal_log_mod_error_info_t    *p_data;
+
+	prfunc("+Processor Device Error Info Section\n");
+
+#ifdef MCA_PRT_XTRA_DATA    // for test only @FVL
+	{
+		char    *p_data = (char *)&slpi->valid;
+
+		prfunc("SAL_PROC_DEV_ERR SECTION DATA:  Data buffer = %p, "
+		       "Data size = %ld\n", (void *)p_data, d_len);
+		ia64_log_hexdump(p_data, d_len, prfunc);
+		prfunc("End of SAL_PROC_DEV_ERR SECTION DATA\n");
+	}
+#endif  // MCA_PRT_XTRA_DATA for test only @FVL
+
+	if (slpi->valid.proc_error_map)
+		prfunc(" Processor Error Map: %#lx\n", slpi->proc_error_map);
+
+	if (slpi->valid.proc_state_param)
+		prfunc(" Processor State Param: %#lx\n", slpi->proc_state_parameter);
+
+	if (slpi->valid.proc_cr_lid)
+		prfunc(" Processor LID: %#lx\n", slpi->proc_cr_lid);
+
+	/*
+	 *  Note: March 2001 SAL spec states that if the number of elements in any
+	 *  of  the MOD_ERROR_INFO_STRUCT arrays is zero, the entire array is
+	 *  absent. Also, current implementations only allocate space for number of
+	 *  elements used.  So we walk the data pointer from here on.
+	 */
+	p_data = &slpi->cache_check_info[0];
+
+	/* Print the cache check information if any*/
+	for (i = 0 ; i < slpi->valid.num_cache_check; i++, p_data++)
+		ia64_log_cache_check_info_print(i, p_data, prfunc);
+
+	/* Print the tlb check information if any*/
+	for (i = 0 ; i < slpi->valid.num_tlb_check; i++, p_data++)
+		ia64_log_tlb_check_info_print(i, p_data, prfunc);
+
+	/* Print the bus check information if any*/
+	for (i = 0 ; i < slpi->valid.num_bus_check; i++, p_data++)
+		ia64_log_bus_check_info_print(i, p_data, prfunc);
+
+	/* Print the reg file check information if any*/
+	for (i = 0 ; i < slpi->valid.num_reg_file_check; i++, p_data++)
+		ia64_log_hexdump((u8 *)p_data, sizeof(sal_log_mod_error_info_t),
+				 prfunc);    /* Just hex dump for now */
+
+	/* Print the ms check information if any*/
+	for (i = 0 ; i < slpi->valid.num_ms_check; i++, p_data++)
+		ia64_log_hexdump((u8 *)p_data, sizeof(sal_log_mod_error_info_t),
+				 prfunc);    /* Just hex dump for now */
+
+	/* Print CPUID registers if any*/
+	if (slpi->valid.cpuid_info) {
+		u64     *p = (u64 *)p_data;
+
+		prfunc(" CPUID Regs: %#lx %#lx %#lx %#lx\n", p[0], p[1], p[2], p[3]);
+		p_data++;
+	}
+
+	/* Print processor static info if any */
+	if (slpi->valid.psi_static_struct) {
+		spsi = (sal_processor_static_info_t *)p_data;
+
+		/* Print branch register contents if valid */
+		if (spsi->valid.br)
+			ia64_log_processor_regs_print(spsi->br, 8, "Branch", "br",
+						      prfunc);
+
+		/* Print control register contents if valid */
+		if (spsi->valid.cr)
+			ia64_log_processor_regs_print(spsi->cr, 128, "Control", "cr",
+						      prfunc);
+
+		/* Print application register contents if valid */
+		if (spsi->valid.ar)
+			ia64_log_processor_regs_print(spsi->ar, 128, "Application",
+						      "ar", prfunc);
+
+		/* Print region register contents if valid */
+		if (spsi->valid.rr)
+			ia64_log_processor_regs_print(spsi->rr, 8, "Region", "rr",
+						      prfunc);
+
+		/* Print floating-point register contents if valid */
+		if (spsi->valid.fr)
+			ia64_log_processor_fp_regs_print(spsi->fr, 128, "Floating-point", "fr",
+							 prfunc);
+	}
+}
+
+/*
  * ia64_log_processor_info_print
+ *
  *	Display the processor-specific information logged by PAL as a part
  *	of MCA or INIT or CMC.
- * Inputs	:	lh	(Pointer of the sal log header which specifies the format
- *				 of SAL state info as specified by the SAL spec).
+ *
+ *  Inputs   :  lh      (Pointer of the sal log header which specifies the
+ *                       format of SAL state info as specified by the SAL spec).
+ *              prfunc  (fn ptr of print function to be used for output).
  * Outputs	:	None
  */
 void
-ia64_log_processor_info_print(sal_log_header_t *lh, prfunc_t prfunc)
+ia64_log_processor_info_print(sal_log_record_header_t *lh, prfunc_t prfunc)
 {
-	sal_log_processor_info_t	*slpi;
-	int				i;
+	sal_log_section_hdr_t       *slsh;
+	int                         n_sects;
+	int                         ercd_pos;
 
 	if (!lh)
 		return;
 
-	if (lh->slh_log_type != SAL_SUB_INFO_TYPE_PROCESSOR)
+#ifdef MCA_PRT_XTRA_DATA    // for test only @FVL
+	ia64_log_prt_record_header(lh, prfunc);
+#endif  // MCA_PRT_XTRA_DATA for test only @FVL
+
+	if ((ercd_pos = sizeof(sal_log_record_header_t)) >= lh->len) {
+		IA64_MCA_DEBUG("ia64_mca_log_print : "
+			       "truncated SAL CMC error record. len = %d\n",
+			       lh->len);
 		return;
+	}
 
-	slpi = (sal_log_processor_info_t *)((char *)lh+sizeof(sal_log_header_t));  /* point to proc info */
+	/* Print record header info */
+	ia64_log_rec_header_print(lh, prfunc);
 
-	if (!slpi) {
-		prfunc("No Processor Error Log found\n");
-		return;
+	for (n_sects = 0; (ercd_pos < lh->len); n_sects++, ercd_pos += slsh->len) {
+		/* point to next section header */
+		slsh = (sal_log_section_hdr_t *)((char *)lh + ercd_pos);
+
+#ifdef MCA_PRT_XTRA_DATA    // for test only @FVL
+		ia64_log_prt_section_header(slsh, prfunc);
+#endif  // MCA_PRT_XTRA_DATA for test only @FVL
+
+		if (verify_guid((void *)&slsh->guid, (void *)&(SAL_PROC_DEV_ERR_SECT_GUID))) {
+			IA64_MCA_DEBUG("ia64_mca_log_print : unsupported record section\n");
+			continue;
+		}
+
+		/*
+		 *  Now process processor device error record section
+		 */
+		ia64_log_proc_dev_err_info_print((sal_log_processor_info_t *)slsh,
+						 printk);
 	}
 
-	/* Print branch register contents if valid */
-	if (slpi->slpi_valid.slpi_br)
-		ia64_log_processor_regs_print(slpi->slpi_br, 8, "Branch", "br", prfunc);
+	IA64_MCA_DEBUG("ia64_mca_log_print : "
+		       "found %d sections in SAL CMC error record. len = %d\n",
+		       n_sects, lh->len);
+	if (!n_sects) {
+		prfunc("No Processor Device Error Info Section found\n");
+		return;
+	}
+}
 
-	/* Print control register contents if valid */
-	if (slpi->slpi_valid.slpi_cr)
-		ia64_log_processor_regs_print(slpi->slpi_cr, 128, "Control", "cr", prfunc);
+/*
+ *  ia64_log_platform_info_print
+ *
+ *  Format and Log the SAL Platform Error Record.
+ *
+ *  Inputs  :   lh      (Pointer to the sal error record header with format
+ *                       specified by the SAL spec).
+ *              prfunc  (fn ptr of log output function to use)
+ *  Outputs :   None
+ */
+void
+ia64_log_platform_info_print (sal_log_record_header_t *lh, prfunc_t prfunc)
+{
+	sal_log_section_hdr_t       *slsh;
+	int                         n_sects;
+	int                         ercd_pos;
 
-	/* Print application register contents if valid */
-	if (slpi->slpi_valid.slpi_ar)
-		ia64_log_processor_regs_print(slpi->slpi_br, 128, "Application", "ar", prfunc);
+	if (!lh)
+		return;
 
-	/* Print region register contents if valid */
-	if (slpi->slpi_valid.slpi_rr)
-		ia64_log_processor_regs_print(slpi->slpi_rr, 8, "Region", "rr", prfunc);
+#ifdef MCA_PRT_XTRA_DATA    // for test only @FVL
+	ia64_log_prt_record_header(lh, prfunc);
+#endif  // MCA_PRT_XTRA_DATA for test only @FVL
+
+	if ((ercd_pos = sizeof(sal_log_record_header_t)) >= lh->len) {
+		IA64_MCA_DEBUG("ia64_mca_log_print : "
+			       "truncated SAL error record. len = %d\n",
+			       lh->len);
+		return;
+	}
 
-	/* Print floating-point register contents if valid */
-	if (slpi->slpi_valid.slpi_fr)
-		ia64_log_processor_regs_print(slpi->slpi_fr, 128, "Floating-point", "fr",
-					      prfunc);
+	/* Print record header info */
+	ia64_log_rec_header_print(lh, prfunc);
 
-	/* Print the cache check information if any*/
-	for (i = 0 ; i < MAX_CACHE_ERRORS; i++)
-		ia64_log_cache_check_info_print(i,
-					slpi->slpi_cache_check_info[i].slpi_cache_check,
-					slpi->slpi_cache_check_info[i].slpi_target_address,
-						prfunc);
-	/* Print the tlb check information if any*/
-	for (i = 0 ; i < MAX_TLB_ERRORS; i++)
-		ia64_log_tlb_check_info_print(i,slpi->slpi_tlb_check_info[i], prfunc);
+	for (n_sects = 0; (ercd_pos < lh->len); n_sects++, ercd_pos += slsh->len) {
+		/* point to next section header */
+		slsh = (sal_log_section_hdr_t *)((char *)lh + ercd_pos);
+
+#ifdef MCA_PRT_XTRA_DATA    // for test only @FVL
+		ia64_log_prt_section_header(slsh, prfunc);
+
+		if (efi_guidcmp(slsh->guid, SAL_PROC_DEV_ERR_SECT_GUID) != 0) {
+			size_t  d_len = slsh->len - sizeof(sal_log_section_hdr_t);
+			char    *p_data = (char *)&((sal_log_mem_dev_err_info_t *)slsh)->valid;
+
+			prfunc("Start of Platform Err Data Section:  Data buffer = %p, "
+			       "Data size = %ld\n", (void *)p_data, d_len);
+			ia64_log_hexdump(p_data, d_len, prfunc);
+			prfunc("End of Platform Err Data Section\n");
+		}
+#endif  // MCA_PRT_XTRA_DATA for test only @FVL
 
-	/* Print the bus check information if any*/
-	for (i = 0 ; i < MAX_BUS_ERRORS; i++)
-		ia64_log_bus_check_info_print(i,
-					slpi->slpi_bus_check_info[i].slpi_bus_check,
-					slpi->slpi_bus_check_info[i].slpi_requestor_addr,
-					slpi->slpi_bus_check_info[i].slpi_responder_addr,
-					slpi->slpi_bus_check_info[i].slpi_target_addr,
-					      prfunc);
+		/*
+		 *  Now process CPE error record section
+		 */
+		if (efi_guidcmp(slsh->guid, SAL_PROC_DEV_ERR_SECT_GUID) == 0) {
+			ia64_log_proc_dev_err_info_print((sal_log_processor_info_t *)slsh,
+							 prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_MEM_DEV_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform Memory Device Error Info Section\n");
+			ia64_log_mem_dev_err_info_print((sal_log_mem_dev_err_info_t *)slsh,
+							prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_SEL_DEV_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform SEL Device Error Info Section\n");
+			ia64_log_sel_dev_err_info_print((sal_log_sel_dev_err_info_t *)slsh,
+							prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_PCI_BUS_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform PCI Bus Error Info Section\n");
+			ia64_log_pci_bus_err_info_print((sal_log_pci_bus_err_info_t *)slsh,
+							prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_SMBIOS_DEV_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform SMBIOS Device Error Info Section\n");
+			ia64_log_smbios_dev_err_info_print((sal_log_smbios_dev_err_info_t *)slsh,
+							   prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_PCI_COMP_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform PCI Component Error Info Section\n");
+			ia64_log_pci_comp_err_info_print((sal_log_pci_comp_err_info_t *)slsh,
+							 prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_SPECIFIC_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform Specific Error Info Section\n");
+			ia64_log_plat_specific_err_info_print((sal_log_plat_specific_err_info_t *)
+							      slsh,
+							      prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_HOST_CTLR_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform Host Controller Error Info Section\n");
+			ia64_log_host_ctlr_err_info_print((sal_log_host_ctlr_err_info_t *)slsh,
+							  prfunc);
+		} else if (efi_guidcmp(slsh->guid, SAL_PLAT_BUS_ERR_SECT_GUID) == 0) {
+			prfunc("+Platform Bus Error Info Section\n");
+			ia64_log_plat_bus_err_info_print((sal_log_plat_bus_err_info_t *)slsh,
+							 prfunc);
+		} else {
+			IA64_MCA_DEBUG("ia64_mca_log_print : unsupported record section\n");
+			continue;
+		}
+	}
 
+	IA64_MCA_DEBUG("ia64_mca_log_print : found %d sections in SAL error record. len = %d\n",
+		       n_sects, lh->len);
+	if (!n_sects) {
+		prfunc("No Platform Error Info Sections found\n");
+		return;
+	}
 }
 
 /*
  * ia64_log_print
- *	Display the contents of the OS error log information
- * Inputs	:	info_type	(SAL_INFO_TYPE_{MCA,INIT,CMC})
- *			sub_info_type	(SAL_SUB_INFO_TYPE_{PROCESSOR,PLATFORM})
+ *
+ *  Displays the contents of the OS error log information
+ *
+ *  Inputs   :  info_type   (SAL_INFO_TYPE_{MCA,INIT,CMC,CPE})
+ *              prfunc      (fn ptr of log output function to use)
  * Outputs	:	None
  */
 void
-ia64_log_print(int sal_info_type, int sal_sub_info_type, prfunc_t prfunc)
+ia64_log_print(int sal_info_type, prfunc_t prfunc)
 {
-	char	*info_type, *sub_info_type;
-
 	switch(sal_info_type) {
-	case SAL_INFO_TYPE_MCA:
-		info_type = "MCA";
+	      case SAL_INFO_TYPE_MCA:
+		prfunc("+BEGIN HARDWARE ERROR STATE AT MCA\n");
+		ia64_log_platform_info_print(IA64_LOG_CURR_BUFFER(sal_info_type), prfunc);
+		prfunc("+END HARDWARE ERROR STATE AT MCA\n");
 		break;
-	case SAL_INFO_TYPE_INIT:
-		info_type = "INIT";
+	      case SAL_INFO_TYPE_INIT:
+		prfunc("+MCA INIT ERROR LOG (UNIMPLEMENTED)\n");
 		break;
-	case SAL_INFO_TYPE_CMC:
-		info_type = "CMC";
+	      case SAL_INFO_TYPE_CMC:
+		prfunc("+BEGIN HARDWARE ERROR STATE AT CMC\n");
+		ia64_log_processor_info_print(IA64_LOG_CURR_BUFFER(sal_info_type), prfunc);
+		prfunc("+END HARDWARE ERROR STATE AT CMC\n");
 		break;
-	default:
-		info_type = "UNKNOWN";
+	      case SAL_INFO_TYPE_CPE:
+		prfunc("+BEGIN HARDWARE ERROR STATE AT CPE\n");
+		ia64_log_platform_info_print(IA64_LOG_CURR_BUFFER(sal_info_type), prfunc);
+		prfunc("+END HARDWARE ERROR STATE AT CPE\n");
 		break;
-	}
-
-	switch(sal_sub_info_type) {
-	case SAL_SUB_INFO_TYPE_PROCESSOR:
-		sub_info_type = "PROCESSOR";
-		break;
-	case SAL_SUB_INFO_TYPE_PLATFORM:
-		sub_info_type = "PLATFORM";
-		break;
-	default:
-		sub_info_type = "UNKNOWN";
+	      default:
+		prfunc("+MCA UNKNOWN ERROR LOG (UNIMPLEMENTED)\n");
 		break;
 	}
-
-	prfunc("+BEGIN HARDWARE ERROR STATE [%s %s]\n", info_type, sub_info_type);
-	if (sal_sub_info_type == SAL_SUB_INFO_TYPE_PROCESSOR)
-		ia64_log_processor_info_print(
-				      IA64_LOG_CURR_BUFFER(sal_info_type, sal_sub_info_type),
-				      prfunc);
-	else
-		log_print_platform(IA64_LOG_CURR_BUFFER(sal_info_type, sal_sub_info_type),prfunc);
-	prfunc("+END HARDWARE ERROR STATE [%s %s]\n", info_type, sub_info_type);
 }
diff -urN linux.orig/arch/ia64/kernel/mca_asm.S linux/arch/ia64/kernel/mca_asm.S
--- linux.orig/arch/ia64/kernel/mca_asm.S	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/mca_asm.S	Mon Dec 17 20:27:40 2001
@@ -9,6 +9,7 @@
 //
 #include <linux/config.h>
 
+#include <asm/asmmacro.h>
 #include <asm/pgtable.h>
 #include <asm/processor.h>
 #include <asm/mca_asm.h>
@@ -23,7 +24,7 @@
 #include "minstate.h"
 
 /*
- *	SAL_TO_OS_MCA_HANDOFF_STATE
+ *  SAL_TO_OS_MCA_HANDOFF_STATE (SAL 3.0 spec)
  *		1. GR1 = OS GP
  *		2. GR8 = PAL_PROC physical address
  *		3. GR9 = SAL_PROC physical address
@@ -33,6 +34,7 @@
  */
 #define SAL_TO_OS_MCA_HANDOFF_STATE_SAVE(_tmp)		\
 	movl	_tmp=ia64_sal_to_os_handoff_state;;	\
+	DATA_VA_TO_PA(_tmp);;				\
 	st8	[_tmp]=r1,0x08;;			\
 	st8	[_tmp]=r8,0x08;;			\
 	st8	[_tmp]=r9,0x08;;			\
@@ -41,47 +43,29 @@
 	st8	[_tmp]=r12,0x08;;
 
 /*
- *	OS_MCA_TO_SAL_HANDOFF_STATE
- *		1. GR8 = OS_MCA status
- *		2. GR9 = SAL GP (physical)
- *		3. GR22 = New min state save area pointer
+ *  OS_MCA_TO_SAL_HANDOFF_STATE (SAL 3.0 spec)
+ *      1. GR8 = OS_MCA return status
+ *	2. GR9 = SAL GP (physical)
+ *      3. GR10 = 0/1 returning same/new context
+ *      4. GR22 = New min state save area pointer
+ *      returns ptr to SAL rtn save loc in _tmp
  */
-#define OS_MCA_TO_SAL_HANDOFF_STATE_RESTORE(_tmp)	\
-	movl	_tmp=ia64_os_to_sal_handoff_state;;	\
-	DATA_VA_TO_PA(_tmp);;				\
-	ld8	r8=[_tmp],0x08;;			\
-	ld8	r9=[_tmp],0x08;;			\
-	ld8	r22=[_tmp],0x08;;
-
-/*
- *	BRANCH
- *		Jump to the instruction referenced by
- *	"to_label".
- *		Branch is taken only if the predicate
- *	register "p" is true.
- *		"ip" is the address of the instruction
- *	located at "from_label".
- *		"temp" is a scratch register like r2
- *		"adjust" needed for HP compiler.
- *	A screwup somewhere with constant arithmetic.
- */
-#define BRANCH(to_label, temp, p, adjust)		\
-100:	(p)	mov		temp=ip;		\
-		;;					\
-	(p)	adds		temp=to_label-100b,temp;\
-		;;					\
-	(p)	adds		temp=adjust,temp;	\
-		;;					\
-	(p)	mov		b1=temp	;		\
-	(p)	br		b1
+#define OS_MCA_TO_SAL_HANDOFF_STATE_RESTORE(_tmp)				\
+	movl	_tmp=ia64_os_to_sal_handoff_state;;				\
+	DATA_VA_TO_PA(_tmp);;							\
+	ld8	r8=[_tmp],0x08;;						\
+	ld8	r9=[_tmp],0x08;;						\
+	ld8     r10=[_tmp],0x08;;						\
+	ld8     r22=[_tmp],0x08;;						\
+	movl    _tmp=ia64_sal_to_os_handoff_state;;				\
+	DATA_VA_TO_PA(_tmp);;							\
+	add     _tmp=0x28,_tmp;;            // point to SAL rtn save location
 
 	.global ia64_os_mca_dispatch
 	.global ia64_os_mca_dispatch_end
 	.global ia64_sal_to_os_handoff_state
 	.global	ia64_os_to_sal_handoff_state
-	.global	ia64_os_mca_ucmc_handler
 	.global	ia64_mca_proc_state_dump
-	.global ia64_mca_proc_state_restore
 	.global	ia64_mca_stack
 	.global	ia64_mca_stackframe
 	.global	ia64_mca_bspstore
@@ -100,7 +84,7 @@
 #endif	/* #if defined(MCA_TEST) */
 
 	// Save the SAL to OS MCA handoff state as defined
-	// by SAL SPEC 2.5
+	// by SAL SPEC 3.0
 	// NOTE : The order in which the state gets saved
 	//	  is dependent on the way the C-structure
 	//	  for ia64_mca_sal_to_os_state_t has been
@@ -110,15 +94,20 @@
 	// LOG PROCESSOR STATE INFO FROM HERE ON..
 	;;
 begin_os_mca_dump:
-	BRANCH(ia64_os_mca_proc_state_dump, r2, p0, 0x0)
-	;;
+	br	ia64_os_mca_proc_state_dump;;
+
 ia64_os_mca_done_dump:
 
 	// Setup new stack frame for OS_MCA handling
-	movl        r2=ia64_mca_bspstore		// local bspstore area location in r2
-	movl        r3=ia64_mca_stackframe		// save stack frame to memory in r3
+	movl    r2=ia64_mca_bspstore;;      // local bspstore area location in r2
+	DATA_VA_TO_PA(r2);;
+	movl    r3=ia64_mca_stackframe;;    // save stack frame to memory in r3
+	DATA_VA_TO_PA(r3);;
 	rse_switch_context(r6,r3,r2);;                  // RSC management in this new context
 	movl        r12=ia64_mca_stack;;
+	mov     r2=8*1024;;                 // stack size must be same as c array
+	add     r12=r2,r12;;                // stack base @ bottom of array
+	DATA_VA_TO_PA(r12);;
 
 	// Enter virtual mode from physical mode
 	VIRTUAL_MODE_ENTER(r2, r3, ia64_os_mca_virtual_begin, r4)
@@ -127,7 +116,7 @@
 	// call our handler
 	movl		r2=ia64_mca_ucmc_handler;;
 	mov		b6=r2;;
-	br.call.sptk.few	b0=b6
+	br.call.sptk.few    b0=b6;;
 .ret0:
 	// Revert back to physical mode before going back to SAL
 	PHYSICAL_MODE_ENTER(r2, r3, ia64_os_mca_virtual_end, r4)
@@ -135,9 +124,9 @@
 
 #if defined(MCA_TEST)
 	// Pretend that we are in interrupt context
-	mov		r2=psr
-	dep		r2=0, r2, PSR_IC, 2;
-	mov		psr.l = r2
+	mov	r2=psr;;
+	dep	r2=0, r2, PSR_IC, 2;;
+	mov	psr.l = r2;;
 #endif	/* #if defined(MCA_TEST) */
 
 	// restore the original stack frame here
@@ -152,15 +141,14 @@
 	mov		r8=gp
 	;;
 begin_os_mca_restore:
-	BRANCH(ia64_os_mca_proc_state_restore, r2, p0, 0x0)
-	;;
+	br	ia64_os_mca_proc_state_restore;;
 
 ia64_os_mca_done_restore:
 	;;
 	// branch back to SALE_CHECK
 	OS_MCA_TO_SAL_HANDOFF_STATE_RESTORE(r2)
 	ld8		r3=[r2];;
-	mov		b0=r3                       // SAL_CHECK return address
+	mov		b0=r3;;			      // SAL_CHECK return address
 	br		b0
 	;;
 ia64_os_mca_dispatch_end:
@@ -178,8 +166,10 @@
 //--
 
 ia64_os_mca_proc_state_dump:
-// Get and save GR0-31 from Proc. Min. State Save Area to SAL PSI
+// Save bank 1 GRs 16-31 which will be used by c-language code when we switch
+//  to virtual addressing mode.
 	movl		r2=ia64_mca_proc_state_dump;;           // Os state dump area
+        DATA_VA_TO_PA(r2)                   // convert to to physical address
 
 // save ar.NaT
 	mov		r5=ar.unat                  // ar.unat
@@ -250,16 +240,16 @@
 // if PSR.ic=0, reading interruption registers causes an illegal operation fault
 	mov		r3=psr;;
 	tbit.nz.unc	p6,p0=r3,PSR_IC;;           // PSI Valid Log bit pos. test
-(p6)    st8		[r2]=r0,9*8+160             // increment by 168 byte inc.
+(p6)    st8     [r2]=r0,9*8+160             // increment by 232 byte inc.
 begin_skip_intr_regs:
-	BRANCH(SkipIntrRegs,  r9, p6, 0x0)
-	;;
+(p6)	br		SkipIntrRegs;;
+
 	add		r4=8,r2                  // duplicate r2 in r4
 	add		r6=2*8,r2                // duplicate r2 in r6
 
 	mov		r3=cr16                     // cr.ipsr
 	mov		r5=cr17                     // cr.isr
-	mov		r7=r0;;                     // cr.ida => cr18
+        mov     r7=r0;;                     // cr.ida => cr18 (reserved)
 	st8		[r2]=r3,3*8
 	st8		[r4]=r5,3*8
 	st8		[r6]=r7,3*8;;
@@ -394,8 +384,7 @@
 	br.cloop.sptk.few	cStRR
 	;;
 end_os_mca_dump:
-	BRANCH(ia64_os_mca_done_dump, r2, p0, -0x10)
-	;;
+	br	ia64_os_mca_done_dump;;
 
 //EndStub//////////////////////////////////////////////////////////////////////
 
@@ -484,11 +473,10 @@
 // if PSR.ic=1, reading interruption registers causes an illegal operation fault
 	mov		r3=psr;;
 	tbit.nz.unc	p6,p0=r3,PSR_IC;;           // PSI Valid Log bit pos. test
-(p6)    st8		[r2]=r0,9*8+160             // increment by 160 byte inc.
+(p6)    st8     [r2]=r0,9*8+160             // increment by 232 byte inc.
 
 begin_rskip_intr_regs:
-	BRANCH(rSkipIntrRegs, r9, p6, 0x0)
-	;;
+(p6)	br		rSkipIntrRegs;;
 
 	add		r4=8,r2                  // duplicate r2 in r4
 	add		r6=2*8,r2;;              // duplicate r2 in r4
@@ -498,7 +486,7 @@
 	ld8		r7=[r6],3*8;;
 	mov		cr16=r3                     // cr.ipsr
 	mov		cr17=r5                     // cr.isr is read only
-//      mov		cr18=r7;;                   // cr.ida
+//      mov     cr18=r7;;                   // cr.ida (reserved - don't restore)
 
 	ld8		r3=[r2],3*8
 	ld8		r5=[r4],3*8
@@ -629,8 +617,8 @@
 	mov		ar.lc=r5
 	;;
 end_os_mca_restore:
-	BRANCH(ia64_os_mca_done_restore, r2, p0, -0x20)
-	;;
+	br	ia64_os_mca_done_restore;;
+
 //EndStub//////////////////////////////////////////////////////////////////////
 
 // ok, the issue here is that we need to save state information so
@@ -660,12 +648,7 @@
 //		6. GR12 = Return address to location within SAL_INIT procedure
 
 
-	.text
-	.align 16
-.global ia64_monarch_init_handler
-.proc ia64_monarch_init_handler
-ia64_monarch_init_handler:
-
+GLOBAL_ENTRY(ia64_monarch_init_handler)
 #if defined(CONFIG_SMP) && defined(SAL_MPINIT_WORKAROUND)
 	//
 	// work around SAL bug that sends all processors to monarch entry
@@ -746,8 +729,7 @@
 
 return_from_init:
 	br.sptk return_from_init
-
-	.endp
+END(ia64_monarch_init_handler)
 
 //
 // SAL to OS entry point for INIT on the slave processor
@@ -755,14 +737,6 @@
 // as a part of ia64_mca_init.
 //
 
-	.text
-	.align 16
-.global ia64_slave_init_handler
-.proc ia64_slave_init_handler
-ia64_slave_init_handler:
-
-
-slave_init_spin_me:
-	br.sptk slave_init_spin_me
-	;;
-	.endp
+GLOBAL_ENTRY(ia64_slave_init_handler)
+1:	br.sptk 1b
+END(ia64_slave_init_handler)
diff -urN linux.orig/arch/ia64/kernel/pci.c linux/arch/ia64/kernel/pci.c
--- linux.orig/arch/ia64/kernel/pci.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/pci.c	Mon Dec 17 20:27:40 2001
@@ -38,6 +38,10 @@
 #define DBG(x...)
 #endif
 
+#ifdef CONFIG_IA64_MCA
+extern void ia64_mca_check_errors( void );
+#endif
+
 /*
  * This interrupt-safe spinlock protects all accesses to PCI
  * configuration space.
@@ -122,6 +126,10 @@
 #	define PCI_BUSES_TO_SCAN 255
 	int i;
 
+#ifdef CONFIG_IA64_MCA
+	ia64_mca_check_errors();    /* For post-failure MCA error logging */
+#endif
+
 	platform_pci_fixup(0);	/* phase 0 initialization (before PCI bus has been scanned) */
 
 	printk("PCI: Probing PCI hardware\n");
@@ -194,4 +202,40 @@
 pcibios_setup (char *str)
 {
 	return NULL;
+}
+
+int
+pci_mmap_page_range (struct pci_dev *dev, struct vm_area_struct *vma,
+		     enum pci_mmap_state mmap_state, int write_combine)
+{
+	/*
+	 * I/O space cannot be accessed via normal processor loads and stores on this
+	 * platform.
+	 */
+	if (mmap_state == pci_mmap_io)
+		/*
+		 * XXX we could relax this for I/O spaces for which ACPI indicates that
+		 * the space is 1-to-1 mapped.  But at the moment, we don't support
+		 * multiple PCI address spaces and the legacy I/O space is not 1-to-1
+		 * mapped, so this is moot.
+		 */
+		return -EINVAL;
+
+	/*
+	 * Leave vm_pgoff as-is, the PCI space address is the physical address on this
+	 * platform.
+	 */
+	vma->vm_flags |= (VM_SHM | VM_LOCKED | VM_IO);
+
+	if (write_combine)
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	else
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (remap_page_range(vma->vm_start, vma->vm_pgoff << PAGE_SHIFT,
+			     vma->vm_end - vma->vm_start,
+			     vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
 }
diff -urN linux.orig/arch/ia64/kernel/perfmon.c linux/arch/ia64/kernel/perfmon.c
--- linux.orig/arch/ia64/kernel/perfmon.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/perfmon.c	Mon Dec 17 20:27:40 2001
@@ -33,6 +33,7 @@
 #include <asm/signal.h>
 #include <asm/system.h>
 #include <asm/system.h>
+#include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/delay.h> /* for ia64_get_itc() */
 
@@ -656,6 +657,16 @@
 
 			/* upper part is ignored on rval */
 			ia64_set_pmd(cnum, ctx->ctx_pmds[i].smpl_rval);
+
+			/* 
+			 * we must reset BTB index (clears pmd16.full to make
+			 * sure we do not report the same branches twice.
+			 * The non-blocking case in handled in update_counters().
+			 */
+			if (cnum == ctx->ctx_btb_counter) {
+				DBprintk(("reseting PMD16\n"));
+				ia64_set_pmd(16, 0);
+			}
 		}
 	}
 }
@@ -783,6 +794,8 @@
 	/* XXX: ctx locking may be required here */
 
 	for (i = 0; i < count; i++, req++) {
+		unsigned long reg_val = ~0, ctx_val = ~0;
+
 		if (copy_from_user(&tmp, req, sizeof(tmp))) return -EFAULT;
 
 		if (!PMD_IS_IMPL(tmp.pfr_reg.reg_num)) return -EINVAL;
@@ -791,23 +804,24 @@
 			if (ta == current){
 				val = ia64_get_pmd(tmp.pfr_reg.reg_num);
 			} else {
-				val = th->pmd[tmp.pfr_reg.reg_num];
+				val = reg_val = th->pmd[tmp.pfr_reg.reg_num];
 			}
 			val &= pmu_conf.perf_ovfl_val;
 			/*
 			 * lower part of .val may not be zero, so we must be an addition because of
 			 * residual count (see update_counters).
 			 */
-			val += ctx->ctx_pmds[tmp.pfr_reg.reg_num - PMU_FIRST_COUNTER].val;
+			val += ctx_val = ctx->ctx_pmds[tmp.pfr_reg.reg_num - PMU_FIRST_COUNTER].val;
 		} else {
 			/* for now */
 			if (ta != current) return -EINVAL;
 
+			ia64_srlz_d();
 			val = ia64_get_pmd(tmp.pfr_reg.reg_num);
 		}
 		tmp.pfr_reg.reg_value = val;
 
-		DBprintk((" reading PMD[%ld]=0x%lx\n", tmp.pfr_reg.reg_num, val));
+		DBprintk((" reading PMD[%ld]=0x%lx reg=0x%lx ctx_val=0x%lx pmc=0x%lx\n", tmp.pfr_reg.reg_num, val, reg_val, ctx_val, ia64_get_pmc(tmp.pfr_reg.reg_num)));
 
 		if (copy_to_user(req, &tmp, sizeof(tmp))) return -EFAULT;
 	}
@@ -1153,7 +1167,7 @@
 	 * XXX: pend_notify and ovfl_regs could be merged maybe !
 	 */
 	if (ctx->ctx_ovfl_regs == 0) {
-		printk("perfmon: spurious overflow notification from pid %d\n", current->pid);
+		DBprintk(("perfmon: spurious overflow notification from pid %d\n", current->pid));
 		return;
 	}
 	read_lock(&tasklist_lock);
@@ -1343,11 +1357,13 @@
 	 * Don't think this could happen given upfront tests
 	 */
 	if ((th->flags & IA64_THREAD_PM_VALID) == 0) {
-		printk("perfmon: Spurious overflow interrupt: process %d not using perfmon\n", ta->pid);
+		DBprintk(("perfmon: Spurious overflow interrupt: process %d not using perfmon\n",
+			  ta->pid));
 		return 0x1;
 	}
 	if (!ctx) {
-		printk("perfmon: Spurious overflow interrupt: process %d has no PFM context\n", ta->pid);
+		DBprintk(("perfmon: Spurious overflow interrupt: process %d has no PFM context\n",
+			  ta->pid));
 		return 0;
 	}
 
@@ -1583,7 +1599,8 @@
 		ia64_set_pmc(0, pmc0);
 		ia64_srlz_d();
 	} else {
-		printk("perfmon: Spurious PMU overflow interrupt: pmc0=0x%lx owner=%p\n", pmc0, (void *)PMU_OWNER());
+		DBprintk(("perfmon: Spurious PMU overflow interrupt: pmc0=0x%lx owner=%p\n",
+			  pmc0, (void *)PMU_OWNER()));
 	}
 }
 
@@ -1648,8 +1665,8 @@
 	}
 	pmu_conf.perf_ovfl_val = (1L << pm_info.pal_perf_mon_info_s.width) - 1;
 	pmu_conf.max_counters  = pm_info.pal_perf_mon_info_s.generic;
-	pmu_conf.num_pmds      = find_num_pm_regs(pmu_conf.impl_regs);
-	pmu_conf.num_pmcs      = find_num_pm_regs(&pmu_conf.impl_regs[4]);
+	pmu_conf.num_pmcs      = find_num_pm_regs(pmu_conf.impl_regs);
+	pmu_conf.num_pmds      = find_num_pm_regs(&pmu_conf.impl_regs[4]);
 
 	printk("perfmon: %d bits counters (max value 0x%lx)\n", pm_info.pal_perf_mon_info_s.width, pmu_conf.perf_ovfl_val);
 	printk("perfmon: %ld PMC/PMD pairs, %ld PMCs, %ld PMDs\n", pmu_conf.max_counters, pmu_conf.num_pmcs, pmu_conf.num_pmds);
@@ -1756,7 +1773,7 @@
 	 */
 	if (pmc0 & ~0x1) {
 		if (owner != ta) printk(__FUNCTION__" owner=%p task=%p\n", (void *)owner, (void *)ta);
-		printk(__FUNCTION__" Warning: pmc[0]=0x%lx explicit call\n", pmc0);
+		DBprintk((__FUNCTION__" Warning: pmc[0]=0x%lx explicit call\n", pmc0));
 
 		pmc0 = update_counters(owner, pmc0, NULL);
 		/* we will save the updated version of pmc0 */
@@ -1842,7 +1859,7 @@
 
 /*
  * This function is called when a thread exits (from exit_thread()).
- * This is a simplified pfm_save_regs() that simply flushes hthe current
+ * This is a simplified pfm_save_regs() that simply flushes the current
  * register state into the save area taking into account any pending
  * overflow. This time no notification is sent because the taks is dying
  * anyway. The inline processing of overflows avoids loosing some counts.
@@ -1933,12 +1950,20 @@
 		/* collect latest results */
 		ctx->ctx_pmds[i].val += ia64_get_pmd(j) & pmu_conf.perf_ovfl_val;
 
+		/*
+		 * now everything is in ctx_pmds[] and we need
+		 * to clear the saved context from save_regs() such that
+		 * pfm_read_pmds() gets the correct value
+		 */
+		ta->thread.pmd[j] = 0;
+
 		/* take care of overflow inline */
 		if (mask & 0x1) {
 			ctx->ctx_pmds[i].val += 1 + pmu_conf.perf_ovfl_val;
 			DBprintk((" PMD[%d] overflowed pmd=0x%lx pmds.val=0x%lx\n",
 			j, ia64_get_pmd(j), ctx->ctx_pmds[i].val));
 		}
+		mask >>=1;
 	}
 }
 
diff -urN linux.orig/arch/ia64/kernel/process.c linux/arch/ia64/kernel/process.c
--- linux.orig/arch/ia64/kernel/process.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/process.c	Mon Dec 17 20:27:40 2001
@@ -518,7 +518,11 @@
 void
 machine_restart (char *restart_cmd)
 {
+#ifdef CONFIG_IA64_HP_PROTO
+	(*efi.reset_system)(EFI_RESET_COLD, 0, 0, 0);
+#else
 	(*efi.reset_system)(EFI_RESET_WARM, 0, 0, 0);
+#endif
 }
 
 void
diff -urN linux.orig/arch/ia64/kernel/sal.c linux/arch/ia64/kernel/sal.c
--- linux.orig/arch/ia64/kernel/sal.c	Thu Jan  4 13:50:17 2001
+++ linux/arch/ia64/kernel/sal.c	Mon Dec 17 20:27:40 2001
@@ -1,8 +1,8 @@
 /*
  * System Abstraction Layer (SAL) interface routines.
  *
- * Copyright (C) 1998, 1999 Hewlett-Packard Co
- * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1998, 1999, 2001 Hewlett-Packard Co
+ * Copyright (C) 1998, 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
  * Copyright (C) 1999 VA Linux Systems
  * Copyright (C) 1999 Walt Drummond <drummond@valinux.com>
  */
@@ -162,14 +162,6 @@
 		      {
 			      struct ia64_sal_desc_platform_feature *pf = (void *) p;
 			      printk("SAL: Platform features ");
-
-#ifdef CONFIG_IA64_HAVE_IRQREDIR
-			      /*
-			       * Early versions of SAL say we don't have
-			       * IRQ redirection, even though we do...
-			       */
-			      pf->feature_mask |= (1 << 1);
-#endif
 
 			      if (pf->feature_mask & (1 << 0))
 				      printk("BusLock ");
diff -urN linux.orig/arch/ia64/kernel/setup.c linux/arch/ia64/kernel/setup.c
--- linux.orig/arch/ia64/kernel/setup.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/setup.c	Mon Dec 17 20:27:40 2001
@@ -344,7 +344,12 @@
 
 #ifdef CONFIG_VT
 # if defined(CONFIG_VGA_CONSOLE)
-	conswitchp = &vga_con;
+	if (!(efi_page_is_ram(0xa0000) == 1))
+		conswitchp = &vga_con;
+#  if defined(CONFIG_DUMMY_CONSOLE)
+	else
+		conswitchp = &dummy_con;
+#  endif
 # elif defined(CONFIG_DUMMY_CONSOLE)
 	conswitchp = &dummy_con;
 # endif
diff -urN linux.orig/arch/ia64/kernel/signal.c linux/arch/ia64/kernel/signal.c
--- linux.orig/arch/ia64/kernel/signal.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/signal.c	Mon Dec 17 20:27:40 2001
@@ -139,10 +139,9 @@
 		struct ia64_psr *psr = ia64_psr(&scr->pt);
 
 		__copy_from_user(current->thread.fph, &sc->sc_fr[32], 96*16);
-		if (!psr->dfh) {
-			psr->mfh = 0;
+		psr->mfh = 0;   /* drop signal handler's fph contents... */
+		if (!psr->dfh)
 			__ia64_load_fpu(current->thread.fph);
-		}
 	}
 	return err;
 }
diff -urN linux.orig/arch/ia64/kernel/smp.c linux/arch/ia64/kernel/smp.c
--- linux.orig/arch/ia64/kernel/smp.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/smp.c	Mon Dec 17 20:27:40 2001
@@ -48,6 +48,7 @@
 #include <asm/sal.h>
 #include <asm/system.h>
 #include <asm/unistd.h>
+#include <asm/mca.h>
 
 /* The 'big kernel lock' */
 spinlock_t kernel_flag = SPIN_LOCK_UNLOCKED;
@@ -70,9 +71,6 @@
 
 #define IPI_CALL_FUNC		0
 #define IPI_CPU_STOP		1
-#ifndef CONFIG_ITANIUM_PTCG
-# define IPI_FLUSH_TLB		2
-#endif  /*!CONFIG_ITANIUM_PTCG */
 
 static void
 stop_this_cpu (void)
@@ -136,49 +134,6 @@
 			stop_this_cpu();
 			break;
 
-#ifndef CONFIG_ITANIUM_PTCG
-		case IPI_FLUSH_TLB:
-		{
-			extern unsigned long flush_start, flush_end, flush_nbits, flush_rid;
-			extern atomic_t flush_cpu_count;
-			unsigned long saved_rid = ia64_get_rr(flush_start);
-			unsigned long end = flush_end;
-			unsigned long start = flush_start;
-			unsigned long nbits = flush_nbits;
-
-			/*
-			 * Current CPU may be running with different RID so we need to
-			 * reload the RID of flushed address.  Purging the translation
-			 * also needs ALAT invalidation; we do not need "invala" here
-			 * since it is done in ia64_leave_kernel.
-			 */
-			ia64_srlz_d();
-			if (saved_rid != flush_rid) {
-				ia64_set_rr(flush_start, flush_rid);
-				ia64_srlz_d();
-			}
-
-			do {
-				/*
-				 * Purge local TLB entries.
-				 */
-				__asm__ __volatile__ ("ptc.l %0,%1" ::
-						      "r"(start), "r"(nbits<<2) : "memory");
-				start += (1UL << nbits);
-			} while (start < end);
-
-			ia64_insn_group_barrier();
-			ia64_srlz_i();			/* srlz.i implies srlz.d */
-
-			if (saved_rid != flush_rid) {
-				ia64_set_rr(flush_start, saved_rid);
-				ia64_srlz_d();
-			}
-			atomic_dec(&flush_cpu_count);
-			break;
-		}
-#endif	/* !CONFIG_ITANIUM_PTCG */
-
 		default:
 			printk(KERN_CRIT "Unknown IPI on CPU %d: %lu\n", this_cpu, which);
 			break;
@@ -228,30 +183,6 @@
 	platform_send_ipi(cpu, IA64_IPI_RESCHEDULE, IA64_IPI_DM_INT, 0);
 }
 
-#ifndef CONFIG_ITANIUM_PTCG
-
-void
-smp_send_flush_tlb (void)
-{
-	send_IPI_allbutself(IPI_FLUSH_TLB);
-}
-
-void
-smp_resend_flush_tlb (void)
-{
-	int i;
-
-	/*
-	 * Really need a null IPI but since this rarely should happen & since this code
-	 * will go away, lets not add one.
-	 */
-	for (i = 0; i < smp_num_cpus; ++i)
-		if (i != smp_processor_id())
-			smp_send_reschedule(i);
-}
-
-#endif  /* !CONFIG_ITANIUM_PTCG */
-
 void
 smp_flush_tlb_all (void)
 {
@@ -277,10 +208,6 @@
 {
 	struct call_data_struct data;
 	int cpus = 1;
-#if (defined(CONFIG_ITANIUM_B0_SPECIFIC) \
-     || defined(CONFIG_ITANIUM_B1_SPECIFIC) || defined(CONFIG_ITANIUM_B2_SPECIFIC))
-	unsigned long timeout;
-#endif
 
 	if (cpuid == smp_processor_id()) {
 		printk(__FUNCTION__" trying to call self\n");
@@ -297,24 +224,12 @@
 	spin_lock_bh(&call_lock);
 	call_data = &data;
 
-#if (defined(CONFIG_ITANIUM_B0_SPECIFIC) \
-     || defined(CONFIG_ITANIUM_B1_SPECIFIC) || defined(CONFIG_ITANIUM_B2_SPECIFIC))
-  resend:
-  	send_IPI_single(cpuid, IPI_CALL_FUNC);
-
-	/*  Wait for response */
-	timeout = jiffies + HZ;
-	while ((atomic_read(&data.started) != cpus) && time_before(jiffies, timeout))
-		barrier();
-	if (atomic_read(&data.started) != cpus)
-		goto resend;
-#else
   	send_IPI_single(cpuid, IPI_CALL_FUNC);
 
 	/* Wait for response */
 	while (atomic_read(&data.started) != cpus)
 		barrier();
-#endif
+
 	if (wait)
 		while (atomic_read(&data.finished) != cpus)
 			barrier();
@@ -348,10 +263,6 @@
 {
 	struct call_data_struct data;
 	int cpus = smp_num_cpus-1;
-#if (defined(CONFIG_ITANIUM_B0_SPECIFIC) \
-     || defined(CONFIG_ITANIUM_B1_SPECIFIC) || defined(CONFIG_ITANIUM_B2_SPECIFIC))
-	unsigned long timeout;
-#endif
 
 	if (!cpus)
 		return 0;
@@ -366,25 +277,11 @@
 	spin_lock_bh(&call_lock);
 	call_data = &data;
 
-#if (defined(CONFIG_ITANIUM_B0_SPECIFIC) \
-     || defined(CONFIG_ITANIUM_B1_SPECIFIC) || defined(CONFIG_ITANIUM_B2_SPECIFIC))
-  resend:
-	/*  Send a message to all other CPUs and wait for them to respond */
-	send_IPI_allbutself(IPI_CALL_FUNC);
-
-	/* Wait for response */
-	timeout = jiffies + HZ;
-	while ((atomic_read(&data.started) != cpus) && time_before(jiffies, timeout))
-		barrier();
-	if (atomic_read(&data.started) != cpus)
-		goto resend;
-#else
 	send_IPI_allbutself(IPI_CALL_FUNC);
 
 	/* Wait for response */
 	while (atomic_read(&data.started) != cpus)
 		barrier();
-#endif
 
 	if (wait)
 		while (atomic_read(&data.finished) != cpus)
diff -urN linux.orig/arch/ia64/kernel/smpboot.c linux/arch/ia64/kernel/smpboot.c
--- linux.orig/arch/ia64/kernel/smpboot.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/smpboot.c	Mon Dec 17 20:27:40 2001
@@ -324,8 +324,7 @@
 	phys_id = hard_smp_processor_id();
 
 	if (test_and_set_bit(cpuid, &cpu_online_map)) {
-		printk("huh, phys CPU#0x%x, CPU#0x%x already present??\n", 
-					phys_id, cpuid);
+		printk("huh, phys CPU#0x%x, CPU#0x%x already present??\n", phys_id, cpuid);
 		BUG();
 	}
 
@@ -341,6 +340,12 @@
 	 * Get our bogomips.
 	 */
 	ia64_init_itm();
+
+#ifdef CONFIG_IA64_MCA
+	ia64_mca_cmc_vector_setup();	/* Setup vector on AP & enable */
+	ia64_mca_check_errors();	/* For post-failure MCA error logging */
+#endif
+
 #ifdef CONFIG_PERFMON
 	perfmon_init_percpu();
 #endif
diff -urN linux.orig/arch/ia64/kernel/sys_ia64.c linux/arch/ia64/kernel/sys_ia64.c
--- linux.orig/arch/ia64/kernel/sys_ia64.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/sys_ia64.c	Mon Dec 17 20:27:40 2001
@@ -194,7 +194,7 @@
 	 */
 	len = PAGE_ALIGN(len);
 	if (len == 0)
-		return addr;
+		goto out;
 
 	/* don't permit mappings into unmapped space or the virtual page table of a region: */
 	roff = rgn_offset(addr);
@@ -208,7 +208,7 @@
 	down_write(&current->mm->mmap_sem);
 	addr = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
 	up_write(&current->mm->mmap_sem);
-
+out:
 	if (file)
 		fput(file);
 	return addr;
diff -urN linux.orig/arch/ia64/kernel/time.c linux/arch/ia64/kernel/time.c
--- linux.orig/arch/ia64/kernel/time.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/time.c	Mon Dec 17 20:27:40 2001
@@ -33,6 +33,10 @@
 
 #endif
 
+#ifdef CONFIG_IA64_HP_PROTO
+unsigned long hp_proto_platform_base_freq = 0;
+#endif
+
 static void
 do_profile (unsigned long ip)
 {
@@ -145,6 +149,9 @@
 	tv->tv_usec = usec;
 }
 
+/* XXX there should be a cleaner way for declaring an alias... */
+asm (".global get_fast_time; get_fast_time = do_gettimeofday");
+
 static void
 timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
@@ -260,6 +267,12 @@
 		       platform_base_freq);
 		platform_base_freq = 75000000;
 	}
+#ifdef CONFIG_IA64_HP_PROTO
+	if (hp_proto_platform_base_freq) {
+		printk("Overriding base frequency to %dMHz\n",hp_proto_platform_base_freq/1000000);
+		platform_base_freq = hp_proto_platform_base_freq;
+	}
+#endif
 	if (!proc_ratio.den)
 		proc_ratio.den = 1;	/* avoid division by zero */
 	if (!itc_ratio.den)
diff -urN linux.orig/arch/ia64/kernel/traps.c linux/arch/ia64/kernel/traps.c
--- linux.orig/arch/ia64/kernel/traps.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/traps.c	Mon Dec 17 20:27:40 2001
@@ -1,20 +1,19 @@
 /*
  * Architecture-specific trap handling.
  *
- * Copyright (C) 1998-2000 Hewlett-Packard Co
- * Copyright (C) 1998-2000 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1998-2001 Hewlett-Packard Co
+ * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
  *
  * 05/12/00 grao <goutham.rao@intel.com> : added isr in siginfo for SIGFPE
  */
 
 /*
- * The fpu_fault() handler needs to be able to access and update all
- * floating point registers.  Those saved in pt_regs can be accessed
- * through that structure, but those not saved, will be accessed
- * directly.  To make this work, we need to ensure that the compiler
- * does not end up using a preserved floating point register on its
- * own.  The following achieves this by declaring preserved registers
- * that are not marked as "fixed" as global register variables.
+ * fp_emulate() needs to be able to access and update all floating point registers.  Those
+ * saved in pt_regs can be accessed through that structure, but those not saved, will be
+ * accessed directly.  To make this work, we need to ensure that the compiler does not end
+ * up using a preserved floating point register on its own.  The following achieves this
+ * by declaring preserved registers that are not marked as "fixed" as global register
+ * variables.
  */
 register double f2 asm ("f2"); register double f3 asm ("f3");
 register double f4 asm ("f4"); register double f5 asm ("f5");
diff -urN linux.orig/arch/ia64/kernel/unaligned.c linux/arch/ia64/kernel/unaligned.c
--- linux.orig/arch/ia64/kernel/unaligned.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/kernel/unaligned.c	Mon Dec 17 20:27:40 2001
@@ -5,6 +5,7 @@
  * Copyright (C) 1999-2000 Stephane Eranian <eranian@hpl.hp.com>
  * Copyright (C) 2001 David Mosberger-Tang <davidm@hpl.hp.com>
  *
+ * 2001/08/13	Correct size of extended floats (float_fsz) from 16 to 10 bytes.
  * 2001/01/17	Add support emulation of unaligned kernel accesses.
  */
 #include <linux/kernel.h>
@@ -908,7 +909,7 @@
  * floating point operations sizes in bytes
  */
 static const unsigned char float_fsz[4]={
-	16, /* extended precision (e) */
+	10, /* extended precision (e) */
 	8,  /* integer (8)            */
 	4,  /* single precision (s)   */
 	8   /* double precision (d)   */
@@ -978,11 +979,11 @@
 	unsigned long len = float_fsz[ld.x6_sz];
 
 	/*
-	 * fr0 & fr1 don't need to be checked because Illegal Instruction
-	 * faults have higher priority than unaligned faults.
+	 * fr0 & fr1 don't need to be checked because Illegal Instruction faults have
+	 * higher priority than unaligned faults.
 	 *
-	 * r0 cannot be found as the base as it would never generate an
-	 * unaligned reference.
+	 * r0 cannot be found as the base as it would never generate an unaligned
+	 * reference.
 	 */
 
 	/*
@@ -996,8 +997,10 @@
 	 * invalidate the ALAT entry and execute updates, if any.
 	 */
 	if (ld.x6_op != 0x2) {
-		/* this assumes little-endian byte-order: */
-
+		/*
+		 * This assumes little-endian byte-order.  Note that there is no "ldfpe"
+		 * instruction:
+		 */
 		if (copy_from_user(&fpr_init[0], (void *) ifa, len)
 		    || copy_from_user(&fpr_init[1], (void *) (ifa + len), len))
 			return -1;
@@ -1337,7 +1340,7 @@
 
 	/*
 	 * IMPORTANT:
-	 * Notice that the swictch statement DOES not cover all possible instructions
+	 * Notice that the switch statement DOES not cover all possible instructions
 	 * that DO generate unaligned references. This is made on purpose because for some
 	 * instructions it DOES NOT make sense to try and emulate the access. Sometimes it
 	 * is WRONG to try and emulate. Here is a list of instruction we don't emulate i.e.,
diff -urN linux.orig/arch/ia64/lib/do_csum.S linux/arch/ia64/lib/do_csum.S
--- linux.orig/arch/ia64/lib/do_csum.S	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/lib/do_csum.S	Mon Dec 17 20:27:40 2001
@@ -16,7 +16,6 @@
  *		back-to-back 8-byte words per loop. Clean up the initialization
  *		for the loop. Support the cases where load latency = 1 or 2.
  *		Set CONFIG_IA64_LOAD_LATENCY to 1 or 2 (default).
- *
  */
 
 #include <asm/asmmacro.h>
diff -urN linux.orig/arch/ia64/lib/memcpy.S linux/arch/ia64/lib/memcpy.S
--- linux.orig/arch/ia64/lib/memcpy.S	Thu Apr  5 13:51:47 2001
+++ linux/arch/ia64/lib/memcpy.S	Mon Dec 17 20:27:40 2001
@@ -9,20 +9,14 @@
  * Output:
  * 	no return value
  *
- * Copyright (C) 2000 Hewlett-Packard Co
+ * Copyright (C) 2001 Hewlett-Packard Co
  * Copyright (C) 2000 Stephane Eranian <eranian@hpl.hp.com>
- * Copyright (C) 2000 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 2001 David Mosberger-Tang <davidm@hpl.hp.com>
  */
 #include <linux/config.h>
 
 #include <asm/asmmacro.h>
 
-#if defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC)
-# define BRP(args...)	nop.b 0
-#else
-# define BRP(args...)	brp.loop.imp args
-#endif
-
 GLOBAL_ENTRY(bcopy)
 	.regstk 3,0,0,0
 	mov r8=in0
@@ -119,7 +113,7 @@
 1: { .mib
 (p[0])	ld8 val[0]=[src],8
 	nop.i 0
-	BRP(1b, 2f)
+	brp.loop.imp 1b, 2f
 }
 2: { .mfb
 (p[N-1])st8 [dst]=val[N-1],8
@@ -142,11 +136,11 @@
 memcpy_short:
 	adds cnt=-1,in2		// br.ctop is repeat/until
 	mov ar.ec=MEM_LAT
-	BRP(1f, 2f)
+	brp.loop.imp 1f, 2f
 	;;
 	mov ar.lc=cnt
 	;;
-	nop.m	0			
+	nop.m	0
 	;;
 	nop.m	0
 	nop.i	0
@@ -163,7 +157,7 @@
 1: { .mib
 (p[0])	ld1 val[0]=[src],1
 	nop.i 0
-	BRP(1b, 2f)
+	brp.loop.imp 1b, 2f
 } ;;
 2: { .mfb
 (p[MEM_LAT-1])st1 [dst]=val[MEM_LAT-1],1
@@ -300,7 +294,7 @@
  1: { .mib											\
 	(p[0])		ld8 val[0]=[src2],8;							\
 	(p[MEM_LAT+3])	shrp w[0]=val[MEM_LAT+3],val[MEM_LAT+4-index],shift;			\
-			BRP(1b, 2f)								\
+			brp.loop.imp 1b, 2f							\
     };												\
  2: { .mfb											\
 	(p[MEM_LAT+4])	st8 [dst]=w[1],8;							\
diff -urN linux.orig/arch/ia64/mm/tlb.c linux/arch/ia64/mm/tlb.c
--- linux.orig/arch/ia64/mm/tlb.c	Tue Jul 31 11:30:08 2001
+++ linux/arch/ia64/mm/tlb.c	Mon Dec 17 20:27:40 2001
@@ -45,84 +45,6 @@
  */
 spinlock_t ptcg_lock = SPIN_LOCK_UNLOCKED; /* see <asm/pgtable.h> */
 
-#if defined(CONFIG_SMP) && !defined(CONFIG_ITANIUM_PTCG)
-
-#include <linux/irq.h>
-
-unsigned long	flush_end, flush_start, flush_nbits, flush_rid;
-atomic_t flush_cpu_count;
-
-/*
- * flush_tlb_no_ptcg is called with ptcg_lock locked
- */
-static inline void
-flush_tlb_no_ptcg (unsigned long start, unsigned long end, unsigned long nbits)
-{
-	extern void smp_send_flush_tlb (void);
-	unsigned long saved_tpr = 0;
-	unsigned long flags;
-
-	/*
-	 * Some times this is called with interrupts disabled and causes
-	 * dead-lock; to avoid this we enable interrupt and raise the TPR
-	 * to enable ONLY IPI.
-	 */
-	__save_flags(flags);
-	if (!(flags & IA64_PSR_I)) {
-		saved_tpr = ia64_get_tpr();
-		ia64_srlz_d();
-		ia64_set_tpr(IA64_IPI_VECTOR - 16);
-		ia64_srlz_d();
-		local_irq_enable();
-	}
-
-	spin_lock(&ptcg_lock);
-	flush_rid = ia64_get_rr(start);
-	ia64_srlz_d();
-	flush_start = start;
-	flush_end = end;
-	flush_nbits = nbits;
-	atomic_set(&flush_cpu_count, smp_num_cpus - 1);
-	smp_send_flush_tlb();
-	/*
-	 * Purge local TLB entries. ALAT invalidation is done in ia64_leave_kernel.
-	 */
-	do {
-		asm volatile ("ptc.l %0,%1" :: "r"(start), "r"(nbits<<2) : "memory");
-		start += (1UL << nbits);
-	} while (start < end);
-
-	ia64_srlz_i();			/* srlz.i implies srlz.d */
-
-	/*
-	 * Wait for other CPUs to finish purging entries.
-	 */
-#if defined(CONFIG_ITANIUM_BSTEP_SPECIFIC)
-	{
-		extern void smp_resend_flush_tlb (void);
-		unsigned long start = ia64_get_itc();
-
-		while (atomic_read(&flush_cpu_count) > 0) {
-			if ((ia64_get_itc() - start) > 400000UL) {
-				smp_resend_flush_tlb();
-				start = ia64_get_itc();
-			}
-		}
-	}
-#else
-	while (atomic_read(&flush_cpu_count)) {
-		/* Nothing */
-	}
-#endif
-	if (!(flags & IA64_PSR_I)) {
-		local_irq_disable();
-		ia64_set_tpr(saved_tpr);
-		ia64_srlz_d();
-	}
-}
-
-#endif /* CONFIG_SMP && !CONFIG_ITANIUM_PTCG */
-
 /*
  * Acquire the ia64_ctx.lock before calling this function!
  */
@@ -222,9 +144,6 @@
 	}
 	start &= ~((1UL << nbits) - 1);
 
-#if defined(CONFIG_SMP) && !defined(CONFIG_ITANIUM_PTCG)
-	flush_tlb_no_ptcg(start, end, nbits);
-#else
 	spin_lock(&ptcg_lock);
 	do {
 # ifdef CONFIG_SMP
@@ -237,7 +156,6 @@
 # endif
 		start += (1UL << nbits);
 	} while (start < end);
-#endif /* CONFIG_SMP && !defined(CONFIG_ITANIUM_PTCG) */
 	spin_unlock(&ptcg_lock);
 	ia64_insn_group_barrier();
 	ia64_srlz_i();			/* srlz.i implies srlz.d */
diff -urN linux.orig/arch/ia64/sn/sn1/llsc4.c linux/arch/ia64/sn/sn1/llsc4.c
--- linux.orig/arch/ia64/sn/sn1/llsc4.c	Thu Apr  5 13:51:47 2001
+++ linux/arch/ia64/sn/sn1/llsc4.c	Mon Dec 17 20:27:40 2001
@@ -35,16 +35,6 @@
 static int	inttest=0;
 #endif
 
-#ifdef IA64_SEMFIX_INSN
-#undef IA64_SEMFIX_INSN
-#endif
-#ifdef IA64_SEMFIX
-#undef IA64_SEMFIX
-#endif
-# define IA64_SEMFIX_INSN
-# define IA64_SEMFIX    ""
-
-
 /*
  * Test parameter table for AUTOTEST
  */
@@ -192,7 +182,6 @@
 	printk ("     llscfail    \t%s\tForce a failure to test the trigger & error messages\n", fail_enabled ? "on" : "off");
 	printk ("     llscselt    \t%s\tSelective triger on failures\n", selective_trigger ? "on" : "off");
 	printk ("     llscblkadr  \t%s\tDump data block addresses\n", dump_block_addrs_opt ? "on" : "off");
-	printk ("  SEMFIX: %s\n", IA64_SEMFIX);
 	printk ("\n");
 }
 __setup("autotest", autotest_enable);
diff -urN linux.orig/arch/ia64/tools/offsets.h linux/arch/ia64/tools/offsets.h
--- linux.orig/arch/ia64/tools/offsets.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/tools/offsets.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,142 @@
+#ifndef _ASM_IA64_OFFSETS_H
+#define _ASM_IA64_OFFSETS_H
+
+/*
+ * DO NOT MODIFY
+ *
+ * This file was generated by arch/ia64/tools/print_offsets.
+ *
+ */
+
+#define PT_PTRACED_BIT			0
+#define PT_TRACESYS_BIT			1
+
+#define IA64_TASK_SIZE			2800	/* 0xaf0 */
+#define IA64_PT_REGS_SIZE		400	/* 0x190 */
+#define IA64_SWITCH_STACK_SIZE		560	/* 0x230 */
+#define IA64_SIGINFO_SIZE		128	/* 0x80 */
+#define IA64_CPU_SIZE			16384	/* 0x4000 */
+#define SIGFRAME_SIZE			2832	/* 0xb10 */
+#define UNW_FRAME_INFO_SIZE		448	/* 0x1c0 */
+
+#define IA64_TASK_PTRACE_OFFSET		48	/* 0x30 */
+#define IA64_TASK_SIGPENDING_OFFSET	16	/* 0x10 */
+#define IA64_TASK_NEED_RESCHED_OFFSET	40	/* 0x28 */
+#define IA64_TASK_PROCESSOR_OFFSET	100	/* 0x64 */
+#define IA64_TASK_THREAD_OFFSET		960	/* 0x3c0 */
+#define IA64_TASK_THREAD_KSP_OFFSET	960	/* 0x3c0 */
+#define IA64_TASK_PID_OFFSET		196	/* 0xc4 */
+#define IA64_TASK_MM_OFFSET		88	/* 0x58 */
+#define IA64_PT_REGS_CR_IPSR_OFFSET	0	/* 0x0 */
+#define IA64_PT_REGS_CR_IIP_OFFSET	8	/* 0x8 */
+#define IA64_PT_REGS_CR_IFS_OFFSET	16	/* 0x10 */
+#define IA64_PT_REGS_AR_UNAT_OFFSET	24	/* 0x18 */
+#define IA64_PT_REGS_AR_PFS_OFFSET	32	/* 0x20 */
+#define IA64_PT_REGS_AR_RSC_OFFSET	40	/* 0x28 */
+#define IA64_PT_REGS_AR_RNAT_OFFSET	48	/* 0x30 */
+#define IA64_PT_REGS_AR_BSPSTORE_OFFSET	56	/* 0x38 */
+#define IA64_PT_REGS_PR_OFFSET		64	/* 0x40 */
+#define IA64_PT_REGS_B6_OFFSET		72	/* 0x48 */
+#define IA64_PT_REGS_LOADRS_OFFSET	80	/* 0x50 */
+#define IA64_PT_REGS_R1_OFFSET		88	/* 0x58 */
+#define IA64_PT_REGS_R2_OFFSET		96	/* 0x60 */
+#define IA64_PT_REGS_R3_OFFSET		104	/* 0x68 */
+#define IA64_PT_REGS_R12_OFFSET		112	/* 0x70 */
+#define IA64_PT_REGS_R13_OFFSET		120	/* 0x78 */
+#define IA64_PT_REGS_R14_OFFSET		128	/* 0x80 */
+#define IA64_PT_REGS_R15_OFFSET		136	/* 0x88 */
+#define IA64_PT_REGS_R8_OFFSET		144	/* 0x90 */
+#define IA64_PT_REGS_R9_OFFSET		152	/* 0x98 */
+#define IA64_PT_REGS_R10_OFFSET		160	/* 0xa0 */
+#define IA64_PT_REGS_R11_OFFSET		168	/* 0xa8 */
+#define IA64_PT_REGS_R16_OFFSET		176	/* 0xb0 */
+#define IA64_PT_REGS_R17_OFFSET		184	/* 0xb8 */
+#define IA64_PT_REGS_R18_OFFSET		192	/* 0xc0 */
+#define IA64_PT_REGS_R19_OFFSET		200	/* 0xc8 */
+#define IA64_PT_REGS_R20_OFFSET		208	/* 0xd0 */
+#define IA64_PT_REGS_R21_OFFSET		216	/* 0xd8 */
+#define IA64_PT_REGS_R22_OFFSET		224	/* 0xe0 */
+#define IA64_PT_REGS_R23_OFFSET		232	/* 0xe8 */
+#define IA64_PT_REGS_R24_OFFSET		240	/* 0xf0 */
+#define IA64_PT_REGS_R25_OFFSET		248	/* 0xf8 */
+#define IA64_PT_REGS_R26_OFFSET		256	/* 0x100 */
+#define IA64_PT_REGS_R27_OFFSET		264	/* 0x108 */
+#define IA64_PT_REGS_R28_OFFSET		272	/* 0x110 */
+#define IA64_PT_REGS_R29_OFFSET		280	/* 0x118 */
+#define IA64_PT_REGS_R30_OFFSET		288	/* 0x120 */
+#define IA64_PT_REGS_R31_OFFSET		296	/* 0x128 */
+#define IA64_PT_REGS_AR_CCV_OFFSET	304	/* 0x130 */
+#define IA64_PT_REGS_AR_FPSR_OFFSET	312	/* 0x138 */
+#define IA64_PT_REGS_B0_OFFSET		320	/* 0x140 */
+#define IA64_PT_REGS_B7_OFFSET		328	/* 0x148 */
+#define IA64_PT_REGS_F6_OFFSET		336	/* 0x150 */
+#define IA64_PT_REGS_F7_OFFSET		352	/* 0x160 */
+#define IA64_PT_REGS_F8_OFFSET		368	/* 0x170 */
+#define IA64_PT_REGS_F9_OFFSET		384	/* 0x180 */
+#define IA64_SWITCH_STACK_CALLER_UNAT_OFFSET 0	/* 0x0 */
+#define IA64_SWITCH_STACK_AR_FPSR_OFFSET	8	/* 0x8 */
+#define IA64_SWITCH_STACK_F2_OFFSET	16	/* 0x10 */
+#define IA64_SWITCH_STACK_F3_OFFSET	32	/* 0x20 */
+#define IA64_SWITCH_STACK_F4_OFFSET	48	/* 0x30 */
+#define IA64_SWITCH_STACK_F5_OFFSET	64	/* 0x40 */
+#define IA64_SWITCH_STACK_F10_OFFSET	80	/* 0x50 */
+#define IA64_SWITCH_STACK_F11_OFFSET	96	/* 0x60 */
+#define IA64_SWITCH_STACK_F12_OFFSET	112	/* 0x70 */
+#define IA64_SWITCH_STACK_F13_OFFSET	128	/* 0x80 */
+#define IA64_SWITCH_STACK_F14_OFFSET	144	/* 0x90 */
+#define IA64_SWITCH_STACK_F15_OFFSET	160	/* 0xa0 */
+#define IA64_SWITCH_STACK_F16_OFFSET	176	/* 0xb0 */
+#define IA64_SWITCH_STACK_F17_OFFSET	192	/* 0xc0 */
+#define IA64_SWITCH_STACK_F18_OFFSET	208	/* 0xd0 */
+#define IA64_SWITCH_STACK_F19_OFFSET	224	/* 0xe0 */
+#define IA64_SWITCH_STACK_F20_OFFSET	240	/* 0xf0 */
+#define IA64_SWITCH_STACK_F21_OFFSET	256	/* 0x100 */
+#define IA64_SWITCH_STACK_F22_OFFSET	272	/* 0x110 */
+#define IA64_SWITCH_STACK_F23_OFFSET	288	/* 0x120 */
+#define IA64_SWITCH_STACK_F24_OFFSET	304	/* 0x130 */
+#define IA64_SWITCH_STACK_F25_OFFSET	320	/* 0x140 */
+#define IA64_SWITCH_STACK_F26_OFFSET	336	/* 0x150 */
+#define IA64_SWITCH_STACK_F27_OFFSET	352	/* 0x160 */
+#define IA64_SWITCH_STACK_F28_OFFSET	368	/* 0x170 */
+#define IA64_SWITCH_STACK_F29_OFFSET	384	/* 0x180 */
+#define IA64_SWITCH_STACK_F30_OFFSET	400	/* 0x190 */
+#define IA64_SWITCH_STACK_F31_OFFSET	416	/* 0x1a0 */
+#define IA64_SWITCH_STACK_R4_OFFSET	432	/* 0x1b0 */
+#define IA64_SWITCH_STACK_R5_OFFSET	440	/* 0x1b8 */
+#define IA64_SWITCH_STACK_R6_OFFSET	448	/* 0x1c0 */
+#define IA64_SWITCH_STACK_R7_OFFSET	456	/* 0x1c8 */
+#define IA64_SWITCH_STACK_B0_OFFSET	464	/* 0x1d0 */
+#define IA64_SWITCH_STACK_B1_OFFSET	472	/* 0x1d8 */
+#define IA64_SWITCH_STACK_B2_OFFSET	480	/* 0x1e0 */
+#define IA64_SWITCH_STACK_B3_OFFSET	488	/* 0x1e8 */
+#define IA64_SWITCH_STACK_B4_OFFSET	496	/* 0x1f0 */
+#define IA64_SWITCH_STACK_B5_OFFSET	504	/* 0x1f8 */
+#define IA64_SWITCH_STACK_AR_PFS_OFFSET	512	/* 0x200 */
+#define IA64_SWITCH_STACK_AR_LC_OFFSET	520	/* 0x208 */
+#define IA64_SWITCH_STACK_AR_UNAT_OFFSET	528	/* 0x210 */
+#define IA64_SWITCH_STACK_AR_RNAT_OFFSET	536	/* 0x218 */
+#define IA64_SWITCH_STACK_AR_BSPSTORE_OFFSET 544	/* 0x220 */
+#define IA64_SWITCH_STACK_PR_OFFSET	552	/* 0x228 */
+#define IA64_SIGCONTEXT_AR_BSP_OFFSET	72	/* 0x48 */
+#define IA64_SIGCONTEXT_AR_FPSR_OFFSET	104	/* 0x68 */
+#define IA64_SIGCONTEXT_AR_RNAT_OFFSET	80	/* 0x50 */
+#define IA64_SIGCONTEXT_AR_UNAT_OFFSET	96	/* 0x60 */
+#define IA64_SIGCONTEXT_B0_OFFSET	136	/* 0x88 */
+#define IA64_SIGCONTEXT_CFM_OFFSET	48	/* 0x30 */
+#define IA64_SIGCONTEXT_FLAGS_OFFSET	0	/* 0x0 */
+#define IA64_SIGCONTEXT_FR6_OFFSET	560	/* 0x230 */
+#define IA64_SIGCONTEXT_PR_OFFSET	128	/* 0x80 */
+#define IA64_SIGCONTEXT_R12_OFFSET	296	/* 0x128 */
+#define IA64_SIGFRAME_ARG0_OFFSET	0	/* 0x0 */
+#define IA64_SIGFRAME_ARG1_OFFSET	8	/* 0x8 */
+#define IA64_SIGFRAME_ARG2_OFFSET	16	/* 0x10 */
+#define IA64_SIGFRAME_RBS_BASE_OFFSET	24	/* 0x18 */
+#define IA64_SIGFRAME_HANDLER_OFFSET	32	/* 0x20 */
+#define IA64_SIGFRAME_SIGCONTEXT_OFFSET	176	/* 0xb0 */
+#define IA64_CLONE_VFORK			16384	/* 0x4000 */
+#define IA64_CLONE_VM			256	/* 0x100 */
+#define IA64_CPU_IRQ_COUNT_OFFSET	0	/* 0x0 */
+#define IA64_CPU_BH_COUNT_OFFSET		4	/* 0x4 */
+#define IA64_CPU_PHYS_STACKED_SIZE_P8_OFFSET 12	/* 0xc */
+
+#endif /* _ASM_IA64_OFFSETS_H */
diff -urN linux.orig/arch/ia64/vmlinux.lds.S linux/arch/ia64/vmlinux.lds.S
--- linux.orig/arch/ia64/vmlinux.lds.S	Tue Jul 31 11:30:09 2001
+++ linux/arch/ia64/vmlinux.lds.S	Mon Dec 17 20:27:40 2001
@@ -9,12 +9,13 @@
 SECTIONS
 {
   /* Sections to be discarded */
-  /DISCARD/ : {
+/***********************************
+	 /DISCARD/ : {
 	*(.text.exit)
 	*(.data.exit)
 	*(.exitcall.exit)
 	}
-
+************************************/
   v = PAGE_OFFSET;	/* this symbol is here to make debugging easier... */
   phys_start = _start - PAGE_OFFSET;
 
diff -urN linux.orig/arch/ia64/vmlinux.lds.S~ linux/arch/ia64/vmlinux.lds.S~
--- linux.orig/arch/ia64/vmlinux.lds.S~	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/vmlinux.lds.S~	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,186 @@
+#include <linux/config.h>
+
+#include <asm/page.h>
+#include <asm/system.h>
+
+OUTPUT_FORMAT("elf64-ia64-little")
+OUTPUT_ARCH(ia64)
+ENTRY(phys_start)
+SECTIONS
+{
+  /* Sections to be discarded */
+  /DISCARD/ : {
+	*(.text.exit)
+	*(.data.exit)
+	*(.exitcall.exit)
+	}
+
+  v = PAGE_OFFSET;	/* this symbol is here to make debugging easier... */
+  phys_start = _start - PAGE_OFFSET;
+
+  . = KERNEL_START;
+
+  _text = .;
+  _stext = .;
+  .text : AT(ADDR(.text) - PAGE_OFFSET)
+    {
+	*(.text.ivt)
+	/* these are not really text pages, but they need to be page aligned: */
+	*(__special_page_section)
+	__start_gate_section = .;
+	*(.text.gate)
+	__stop_gate_section = .;
+	*(.text)
+    }
+  .text2 : AT(ADDR(.text2) - PAGE_OFFSET)
+	{ *(.text2) }
+#ifdef CONFIG_SMP
+  .text.lock : AT(ADDR(.text.lock) - PAGE_OFFSET)
+	{ *(.text.lock) }
+#endif
+  _etext = .;
+
+  /* Read-only data */
+
+  __gp = ALIGN(16) + 0x200000;	/* gp must be 16-byte aligned for exc. table */
+
+  /* Global data */
+  _data = .;
+
+  /* Exception table */
+  . = ALIGN(16);
+  __start___ex_table = .;
+  __ex_table : AT(ADDR(__ex_table) - PAGE_OFFSET)
+	{ *(__ex_table) }
+  __stop___ex_table = .;
+
+#if defined(CONFIG_IA64_GENERIC)
+  /* Machine Vector */
+  . = ALIGN(16);
+  machvec_start = .;
+  .machvec : AT(ADDR(.machvec) - PAGE_OFFSET)
+	{ *(.machvec) }
+  machvec_end = .;
+#endif
+
+  __start___ksymtab = .;	/* Kernel symbol table */
+  __ksymtab : AT(ADDR(__ksymtab) - PAGE_OFFSET)
+	{ *(__ksymtab) }
+  __stop___ksymtab = .;
+
+  __start___kallsyms = .;	/* All kernel symbols for debugging */
+  __kallsyms : AT(ADDR(__kallsyms) - PAGE_OFFSET)
+	{ *(__kallsyms) }
+  __stop___kallsyms = .;
+
+  /* Unwind info & table: */
+  . = ALIGN(8);
+  .IA_64.unwind_info : AT(ADDR(.IA_64.unwind_info) - PAGE_OFFSET)
+	{ *(.IA_64.unwind_info*) }
+  ia64_unw_start = .;
+  .IA_64.unwind : AT(ADDR(.IA_64.unwind) - PAGE_OFFSET)
+	{ *(.IA_64.unwind*) }
+  ia64_unw_end = .;
+
+  .rodata : AT(ADDR(.rodata) - PAGE_OFFSET)
+	{ *(.rodata) *(.rodata.*) }
+  .kstrtab : AT(ADDR(.kstrtab) - PAGE_OFFSET)
+	{ *(.kstrtab) }
+  .opd : AT(ADDR(.opd) - PAGE_OFFSET)
+	{ *(.opd) }
+
+  /* Initialization code and data: */
+
+  . = ALIGN(PAGE_SIZE);
+  __init_begin = .;
+  .text.init : AT(ADDR(.text.init) - PAGE_OFFSET)
+	{ *(.text.init) }
+
+  .data.init : AT(ADDR(.data.init) - PAGE_OFFSET)
+	{ *(.data.init) }
+   . = ALIGN(16);
+  __setup_start = .;
+  .setup.init : AT(ADDR(.setup.init) - PAGE_OFFSET)
+        { *(.setup.init) }
+  __setup_end = .;
+  __initcall_start = .;
+  .initcall.init : AT(ADDR(.initcall.init) - PAGE_OFFSET)
+        { *(.initcall.init) }
+  __initcall_end = .;
+  . = ALIGN(PAGE_SIZE);
+  __init_end = .;
+
+  /* The initial task and kernel stack */
+  init_task : AT(ADDR(init_task) - PAGE_OFFSET)
+	{ *(init_task) }
+
+  .data.page_aligned : AT(ADDR(.data.page_aligned) - PAGE_OFFSET)
+        { *(.data.idt) }
+
+  . = ALIGN(64);
+  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - PAGE_OFFSET)
+        { *(.data.cacheline_aligned) }
+
+  /* Kernel symbol names for modules: */
+  .kstrtab : AT(ADDR(.kstrtab) - PAGE_OFFSET)
+	{ *(.kstrtab) }
+
+  .data : AT(ADDR(.data) - PAGE_OFFSET)
+	{ *(.data) *(.gnu.linkonce.d*) CONSTRUCTORS }
+
+  .got : AT(ADDR(.got) - PAGE_OFFSET)
+	{ *(.got.plt) *(.got) }
+  /* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata : AT(ADDR(.sdata) - PAGE_OFFSET)
+	{ *(.sdata) }
+  _edata  =  .;
+  _bss = .;
+  .sbss : AT(ADDR(.sbss) - PAGE_OFFSET)
+	{ *(.sbss) *(.scommon) }
+  .bss : AT(ADDR(.bss) - PAGE_OFFSET)
+	{ *(.bss) *(COMMON) }
+  . = ALIGN(64 / 8);
+  _end = .;
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+  /* These must appear regardless of  .  */
+  /* Discard them for now since Intel SoftSDV cannot handle them.
+  .comment 0 : { *(.comment) }
+  .note 0 : { *(.note) }
+  */
+  /DISCARD/ : { *(.comment) }
+  /DISCARD/ : { *(.note) }
+}
diff -urN linux.orig/drivers/acpi/Makefile linux/drivers/acpi/Makefile
--- linux.orig/drivers/acpi/Makefile	Wed Jun 20 18:47:39 2001
+++ linux/drivers/acpi/Makefile	Mon Dec 17 20:27:40 2001
@@ -37,7 +37,7 @@
 obj-$(CONFIG_ACPI)	+= os.o acpi_ksyms.o
 obj-$(CONFIG_ACPI)	+= $(foreach dir,$(acpi-subdirs),$(dir)/$(dir).o) 
 ifdef CONFIG_ACPI_KERNEL_CONFIG
-   obj-$(CONFIG_ACPI) 	+= acpiconf.o osconf.o
+   obj-$(CONFIG_ACPI) 	+= acpiconf.o osconf.o driver.o
 else
    obj-$(CONFIG_ACPI)	+= driver.o
 endif
diff -urN linux.orig/drivers/acpi/acpiconf.c linux/drivers/acpi/acpiconf.c
--- linux.orig/drivers/acpi/acpiconf.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/acpiconf.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,705 @@
+/*
+ *  acpiconf.c - ACPI based kernel configuration
+ *
+ *  Copyright (C) 2000-2001 Intel Corp.
+ *  Copyright (C) 2000-2001 J.I. Lee <Jung-Ik.Lee@intel.com>
+ *
+ *  Revision History:
+ *	 9/15/2000 J.I.
+ *		Major revision:	for new ACPI initialization requirements
+ *	11/15/2000 J.I.
+ *		Major revision:	ACPI 2.0 tables support
+ *	04/23/2001 J.I.
+ *		Rewrote functions to support multiple _PRTs of child P2Ps
+ *		under root pci bus
+ */
+
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <asm/system.h>
+#include <asm/iosapic.h>
+#include <asm/efi.h>
+#include <asm/acpikcfg.h>
+#include "acpi.h"
+#include "osconf.h"
+#include "acpiconf.h"
+
+
+static	int	acpi_cf_initialized __initdata = 0;
+
+ACPI_STATUS	__init
+acpi_cf_init (
+	void * rsdp
+	)
+{
+	ACPI_STATUS	status;
+
+	acpi_os_bind_osd(ACPI_CF_PHASE_BOOTTIME);
+
+	status = acpi_initialize_subsystem ();
+	if (ACPI_FAILURE(status)) {
+		printk ("Acpi cfg:initialize_subsystem error=0x%x\n", status);
+		return status;
+	}
+	dprintk(("Acpi cfg:initializ_subsysteme pass\n"));
+
+	status = acpi_load_tables ((u64)virt_to_phys(rsdp));
+	if (ACPI_FAILURE(status)) {
+		printk ("Acpi cfg:load firmware tables error=0x%x\n", status);
+		acpi_terminate();
+		return status;
+	}
+	dprintk(("Acpi cfg:load firmware tables pass\n"));
+
+	status = acpi_enable_subsystem (ACPI_FULL_INITIALIZATION);
+	if (ACPI_FAILURE(status)) {
+		printk ("Acpi cfg:enable_subsystem error=0x%x\n", status);
+		acpi_terminate();
+		return status;
+	}
+	dprintk(("Acpi cfg:enable_subsystem pass\n"));
+
+	acpi_cf_initialized++;
+
+	return AE_OK;
+}
+
+
+ACPI_STATUS	__init
+acpi_cf_terminate ( void )
+{
+	ACPI_STATUS	status;
+
+	if (! ACPI_CF_INITIALIZED())
+		return AE_ERROR;
+
+	status = acpi_disable ();
+	if (ACPI_FAILURE(status)) {
+		printk ("Acpi cfg:disable fail=0x%x\n", status);
+		/* fall thru...*/
+	}
+
+	status = acpi_terminate ();
+	if (ACPI_FAILURE(status)) {
+		printk ("Acpi cfg:acpi terminate error=0x%x\n", status);
+		/* fall thru...*/
+	}
+
+	acpi_cf_cleanup();
+	acpi_os_bind_osd(ACPI_CF_PHASE_RUNTIME);
+
+	acpi_cf_initialized--;
+
+	return status;
+}
+
+#ifdef CONFIG_IA64_HP_PROTO
+
+static ACPI_STATUS acpi_cf_evaluate_method (ACPI_HANDLE handle,
+                                            UINT8 *method_name,
+                                            NATIVE_UINT *nuint);
+
+
+int hp_proto_check_crs = 0;
+
+static ACPI_STATUS      __init
+acpi_cf_get_hp_proto_crs_callback (
+	ACPI_HANDLE handle,
+	UINT32      level,
+	void        *context,
+	void        **retval
+)
+{
+	ACPI_STATUS status, name_status;
+	ACPI_BUFFER acpi_buffer, name_buf;
+	UINT8 buf[PATHNAME_MAX];
+	NATIVE_UINT     temp = 0x0F;
+
+	acpi_buffer.length = 0;
+	acpi_buffer.pointer = NULL;
+
+	name_buf.length  = PATHNAME_MAX;
+	name_buf.pointer = (void *) buf;
+
+	name_status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buf);
+	if (ACPI_SUCCESS(name_status)) {
+		printk("Acpi CRS:path=[%s]\n", (char *)name_buf.pointer);
+	} else {
+		printk("Error getting pathname\n");
+		return AE_OK;
+	}
+
+	status = acpi_cf_evaluate_method(handle, METHOD_NAME__STA, &temp);
+
+	if (status != AE_NOT_FOUND) {
+		if (ACPI_FAILURE(status)) {
+			printk("_STA Method failed (0x%x)\n",status);
+			return AE_OK;
+		} else if (!(temp & ACPI_STA_DEVICE_PRESENT)) {
+			printk("_STA Method reports device not present\n");
+			return AE_OK;
+		}
+	}
+
+	status = acpi_get_current_resources(handle, &acpi_buffer);
+
+	switch (status) {
+		case AE_BUFFER_OVERFLOW:
+			break;          /* found */
+		case AE_NOT_FOUND:
+			return AE_OK;   /* let acpi_walk_namespace continue. */
+		default:
+			printk("Acpi cfg:get current resource settings fail=0x%x\n", status);
+			return AE_OK;
+	}
+
+	acpi_buffer.pointer = acpi_os_callocate (acpi_buffer.length);
+	if (acpi_buffer.pointer == NULL) {
+		printk("Acpi cfg:callocate %d bytes Fail\n", acpi_buffer.length);
+		return AE_OK;
+	}
+
+	status = acpi_get_current_resources (handle, &acpi_buffer);
+	if (ACPI_FAILURE(status)) {
+		printk("Acpi cfg:get current resource settings Fail=0x%x\n", status);
+		acpi_os_free(acpi_buffer.pointer);
+		return AE_OK;
+	}
+
+	/*
+	acpi_rs_dump_resource_list ((ACPI_RESOURCE *) acpi_buffer.pointer);
+	*/
+	acpi_os_free(acpi_buffer.pointer);
+
+	return AE_OK;
+}
+
+ACPI_STATUS     __init
+acpi_cf_get_hp_proto_crs ( void )
+{
+	ACPI_STATUS status;
+
+	if (! ACPI_CF_INITIALIZED()) {
+		if (efi.acpi20)
+			status = acpi_cf_init((void *)efi.acpi20);
+		else
+			status = acpi_cf_init((void *)efi.acpi);
+		if (ACPI_FAILURE (status))
+			return status;
+	}
+
+	status = acpi_walk_namespace ( ACPI_TYPE_DEVICE,
+	                               ACPI_ROOT_OBJECT,
+	                               ACPI_UINT32_MAX,
+	                               acpi_cf_get_hp_proto_crs_callback,
+	                               NULL,
+	                               NULL);
+
+	if (ACPI_FAILURE (status)) {
+		printk("Acpi Cfg: get crs fail\n");
+		return status;
+	}
+
+	printk("Acpi Cfg: get CRS %s\n", (ACPI_SUCCESS(status))?"pass":"fail");
+
+	return status;
+}
+#endif /* CONFIG_IA64_HP_PROTO */
+
+
+ACPI_STATUS	__init
+acpi_cf_get_pci_vectors (
+	struct pci_vector_struct	**vectors,
+	int				*num_pci_vectors
+	)
+{
+	ACPI_STATUS	status;
+	void		*prts;
+
+	if (! ACPI_CF_INITIALIZED()) {
+		status = acpi_cf_init((void *)efi.acpi);
+		if (ACPI_FAILURE (status))
+			return status;
+	}
+
+	*vectors = NULL;
+	*num_pci_vectors = 0;
+
+	status = acpi_cf_get_prt (&prts);
+	if (ACPI_FAILURE (status)) {
+		printk("Acpi cfg: get prt fail\n");
+		return status;
+	}
+
+	status = acpi_cf_convert_prt_to_vectors (prts, vectors, num_pci_vectors);
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_DEBUG
+	if (ACPI_SUCCESS(status)) {
+		acpi_cf_print_pci_vectors (*vectors, *num_pci_vectors);
+	}
+#endif
+	printk("Acpi cfg: get PCI interrupt vectors %s\n",
+		(ACPI_SUCCESS(status))?"pass":"fail");
+
+#ifdef CONFIG_IA64_HP_PROTO
+	if (hp_proto_check_crs)
+		acpi_cf_get_hp_proto_crs();
+#endif
+	return status;
+}
+
+
+static	PCI_ROUTING_TABLE	*pci_routing_tables[PCI_MAX_BUS] __initdata = {NULL};
+
+
+typedef struct _acpi_rpb {
+	NATIVE_UINT	rpb_busnum;
+	NATIVE_UINT	lastbusnum;
+	ACPI_HANDLE	rpb_handle;
+} acpi_rpb_t;
+
+
+static ACPI_STATUS	__init
+acpi_cf_evaluate_method (
+	ACPI_HANDLE	handle,
+	UINT8		*method_name,
+	NATIVE_UINT	*nuint
+	)
+{
+	UINT32			tnuint = 0;
+	ACPI_STATUS		status;
+
+	ACPI_BUFFER		ret_buf;
+	ACPI_OBJECT		*ext_obj;
+	UINT8			buf[PATHNAME_MAX];
+
+
+	ret_buf.length  = PATHNAME_MAX;
+	ret_buf.pointer = (void *) buf;
+
+	status = acpi_evaluate_object(handle, method_name, NULL, &ret_buf);
+	if (ACPI_FAILURE(status)) {
+		if (status == AE_NOT_FOUND) {
+			printk("Acpi cfg: no %s found\n", method_name);
+		} else {
+			printk("Acpi cfg: %s fail=0x%x\n", method_name, status);
+		}
+	} else {
+		ext_obj = (ACPI_OBJECT *) ret_buf.pointer;
+
+		switch (ext_obj->type) {
+		case ACPI_TYPE_INTEGER:
+			tnuint = (NATIVE_UINT) ext_obj->integer.value;
+			break;
+		default:
+			printk("Acpi cfg: %s obj type incorrect\n", method_name);
+			status = AE_TYPE;
+			break;
+		}
+	}
+
+	*nuint = tnuint;
+	return (status);
+}
+
+
+static ACPI_STATUS	__init
+acpi_cf_evaluate_PRT (
+	ACPI_HANDLE		handle,
+	PCI_ROUTING_TABLE	**prt
+	)
+{
+	ACPI_BUFFER		acpi_buffer;
+	ACPI_STATUS		status;
+
+	acpi_buffer.length  = 0;
+	acpi_buffer.pointer = NULL;
+
+	status = acpi_get_irq_routing_table (handle, &acpi_buffer);
+
+	switch (status) {
+	case AE_BUFFER_OVERFLOW:
+		dprintk(("Acpi cfg: _PRT found. need %d bytes\n",
+			acpi_buffer.length));
+		break;		/* found */
+	default:
+		printk("Acpi cfg: _PRT fail=0x%x\n", status);
+	case AE_NOT_FOUND:
+		return status;
+	}
+
+	*prt = (PCI_ROUTING_TABLE *) acpi_os_callocate (acpi_buffer.length);
+	if (!*prt) {
+		printk("Acpi cfg: callocate %d bytes for _PRT fail\n",
+			acpi_buffer.length);
+		return AE_NO_MEMORY;
+	}
+	acpi_buffer.pointer = (void *) *prt;
+
+	status = acpi_get_irq_routing_table (handle, &acpi_buffer);
+	if (ACPI_FAILURE(status)) {
+		printk("Acpi cfg: _PRT fail=0x%x.\n", status);
+		acpi_os_free(prt);
+	}
+
+	return status;
+}
+
+static ACPI_STATUS	__init
+acpi_cf_get_root_pci_callback (
+	ACPI_HANDLE		handle,
+	UINT32			Level,
+	void			*context,
+	void			**retval
+	)
+{
+	NATIVE_UINT		busnum = 0;
+	ACPI_STATUS		status;
+	acpi_rpb_t		rpb;
+	PCI_ROUTING_TABLE	*prt;
+
+	UINT8			path_name[PATHNAME_MAX];
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_DEBUG
+	ACPI_BUFFER		ret_buf;
+
+	ret_buf.length  = PATHNAME_MAX;
+	ret_buf.pointer = (void *) path_name;
+
+	status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &ret_buf);
+#else
+	memset(path_name, 0, sizeof (path_name));
+#endif
+
+	/*
+	 * get bus number of this pci root bridge
+	 */
+	status = acpi_cf_evaluate_method(handle, METHOD_NAME__BBN, &busnum);
+	if (ACPI_FAILURE(status)) {
+		printk("Acpi cfg:%s evaluate _BBN fail=0x%x\n",
+			path_name, status);
+		return (status);
+	}
+	printk("Acpi cfg:%s ROOT PCI bus %ld\n", path_name, busnum);
+
+	/*
+	 * evaluate root pci bridge's _CRS for Bus number range for child P2P
+	 * (bus min/max/len) - not yet.
+	 */
+
+	/*
+	 * get immediate _PRT of this root pci bridge if any
+	 */
+	status = acpi_cf_evaluate_PRT (handle, &prt);
+	switch(status) {
+	case AE_NOT_FOUND:
+		break;
+	default:
+		if (ACPI_FAILURE(status)) {
+			printk("Acpi cfg:%s _PRT fail=0x%x\n",
+				path_name, status);
+			return status;
+		}
+		dprintk(("Acpi cfg:%s bus %ld got _PRT\n", path_name, busnum));
+		acpi_cf_add_to_pci_routing_tables (busnum, prt);
+		break;
+	}
+
+
+	/*
+	 * walk down this root pci bridge to get _PRTs if any
+	 */
+	rpb.rpb_busnum = rpb.lastbusnum = busnum;
+	rpb.rpb_handle = handle;
+	status = acpi_walk_namespace ( ACPI_TYPE_DEVICE,
+					handle,
+					ACPI_UINT32_MAX,
+					acpi_cf_get_prt_callback,
+					&rpb,
+					NULL );
+	if (ACPI_FAILURE(status))
+		printk("Acpi cfg:%s walk namespace for _PRT error=0x%x\n",
+			path_name, status);
+
+	return (status);
+}
+
+
+/*
+ * handle _PRTs of immediate P2Ps of root pci. 
+ */
+static ACPI_STATUS	__init
+acpi_cf_associate_prt_to_bus (
+	ACPI_HANDLE		handle,
+	acpi_rpb_t		*rpb,
+	NATIVE_UINT		*retbusnum,
+	NATIVE_UINT		depth
+	)
+{
+	ACPI_STATUS		status;
+	UINT32			segbus;
+	NATIVE_UINT		devfn;
+	UINT8			bn;
+
+	UINT8			path_name[PATHNAME_MAX];
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_DEBUG
+	ACPI_BUFFER		ret_buf;
+
+	ret_buf.length  = PATHNAME_MAX;
+	ret_buf.pointer = (void *) path_name;
+
+	status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &ret_buf);
+#else
+	memset(path_name, 0, sizeof (path_name));
+#endif
+
+	/*
+	 * get devfn from _ADR
+	 */
+	status = acpi_cf_evaluate_method(handle, METHOD_NAME__ADR, &devfn);
+	if (ACPI_FAILURE(status)) {
+		*retbusnum = rpb->rpb_busnum + 1;
+		printk("Acpi cfg:%s _ADR fail=0x%x. Set busnum to %ld\n",
+			path_name, status, *retbusnum);
+		return AE_OK;
+	}
+	dprintk(("Acpi cfg:%s _ADR =0x%x\n", path_name, (UINT32)devfn));
+
+
+	/*
+	 * access pci config space for bus number
+	 *	segbus = from rpb, devfn = from _ADR
+	 */
+	segbus = (UINT32)(rpb->rpb_busnum & 0xFFFFFFFF);
+
+	status = acpi_os_read_pci_cfg_byte(segbus,
+				(UINT32)devfn, PCI_PRIMARY_BUS, &bn);
+	if (ACPI_FAILURE(status)) {
+		*retbusnum = rpb->rpb_busnum + 1;
+		printk("Acpi cfg:%s pci read fail=0x%x. b:df:a=%x:%x:%x\n",
+			path_name, status, segbus, (UINT32)devfn,
+			PCI_PRIMARY_BUS);
+		printk("Acpi cfg:%s Set busnum to %ld\n",
+			path_name, *retbusnum);
+		return AE_OK;
+	}
+	dprintk(("Acpi cfg:%s pribus %d\n", path_name, bn));
+
+
+	status = acpi_os_read_pci_cfg_byte(segbus,
+				(UINT32)devfn, PCI_SECONDARY_BUS, &bn);
+	if (ACPI_FAILURE(status)) {
+		*retbusnum = rpb->rpb_busnum + 1;
+		printk("Acpi cfg:%s pci read fail=0x%x. b:df:a=%x:%x:%x\n",
+			path_name, status, segbus, (UINT32)devfn,
+			PCI_SECONDARY_BUS);
+		printk("Acpi cfg:%s Set busnum to %ld\n",
+			path_name, *retbusnum);
+		return AE_OK;
+	}
+	dprintk(("Acpi cfg:%s busnum %d\n", path_name, bn));
+
+	*retbusnum = (NATIVE_UINT)bn;
+	return AE_OK;
+}
+
+
+static ACPI_STATUS	__init
+acpi_cf_get_prt (
+	void		**prts
+	)
+{
+	ACPI_STATUS	status;
+
+	status = acpi_get_devices ( PCI_ROOT_HID_STRING,
+				acpi_cf_get_root_pci_callback,
+				NULL,
+				NULL );
+
+	if (ACPI_FAILURE(status)) {
+		printk("Acpi cfg:get_device PCI ROOT HID error=0x%x\n", status);
+	}
+
+	*prts = (void *)pci_routing_tables;
+
+	return status;
+}
+
+static ACPI_STATUS	__init
+acpi_cf_get_prt_callback (
+	ACPI_HANDLE		handle,
+	UINT32			Level,
+	void			*context,
+	void			**retval
+	)
+{
+	PCI_ROUTING_TABLE	*prt;
+	NATIVE_UINT		busnum = 0;
+	NATIVE_UINT		temp = 0x0F;
+	ACPI_STATUS		status;
+
+	UINT8			path_name[PATHNAME_MAX];
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_DEBUG
+	ACPI_BUFFER		ret_buf;
+
+	ret_buf.length  = PATHNAME_MAX;
+	ret_buf.pointer = (void *) path_name;
+
+	status = acpi_get_name(handle, ACPI_FULL_PATHNAME, &ret_buf);
+#else
+	memset(path_name, 0, sizeof (path_name));
+#endif
+
+	status = acpi_cf_evaluate_PRT (handle, &prt);
+	switch(status) {
+	case AE_NOT_FOUND:
+		return AE_OK;
+	default:
+		if (ACPI_FAILURE(status)) {
+			printk("Acpi cfg:%s _PRT fail=0x%x\n",
+				path_name, status);
+			return status;
+		}
+	}
+
+	/*
+	 * evaluate _STA in case this device does not exist
+	 */
+	status = acpi_cf_evaluate_method(handle, METHOD_NAME__STA, &temp);
+	switch(status) {
+	case AE_NOT_FOUND:
+		break;
+	default:
+		if (ACPI_FAILURE(status)) {
+			printk("Acpi cfg:%s _STA fail=0x%x\n",
+				path_name, status);
+			return status;
+		}
+		if (!(temp & ACPI_STA_DEVICE_PRESENT)) {
+			dprintk(("Acpi cfg:%s not exist. _PRT discarded\n",
+				path_name));
+			acpi_os_free(prt);
+			return AE_OK;
+		}
+		break;
+	}
+
+	/*
+	 * associate a bus number to this _PRT since 
+	 * this _PRT is not on root pci bridge 
+	 */
+	acpi_cf_associate_prt_to_bus(handle, context, &busnum, 0);
+
+	printk("Acpi cfg:%s busnum %ld got _PRT\n", path_name, busnum);
+	acpi_cf_add_to_pci_routing_tables (busnum, prt);
+
+	return AE_OK;
+}
+
+
+static void	__init
+acpi_cf_add_to_pci_routing_tables (
+	NATIVE_UINT		busnum,
+	PCI_ROUTING_TABLE	*prt
+	)
+{
+	if ( busnum >= PCI_MAX_BUS ) {
+		printk("Acpi cfg:invalid pci bus number %ld\n", busnum);
+		acpi_os_free(prt);
+		return;
+	}
+
+	if (pci_routing_tables[busnum]) {
+		printk("Acpi cfg:duplicate PRT for pci bus %ld. overiding...\n", busnum);
+		acpi_os_free(pci_routing_tables[busnum]);
+	}
+
+	pci_routing_tables[busnum] = prt;
+}
+
+
+#define	DUMPVECTOR(pv)	printk("PCI bus=0x%x id=0x%x pin=0x%x irq=0x%x\n", pv->bus, pv->pci_id, pv->pin, pv->irq);
+
+static ACPI_STATUS	__init
+acpi_cf_convert_prt_to_vectors (
+	void				*prts,
+	struct pci_vector_struct	**vectors,
+	int				*num_pci_vectors
+	)
+{
+	struct pci_vector_struct	*pvec;
+	PCI_ROUTING_TABLE		**pprts, *prt, *prtf;
+	int				nvec = 0;
+	int				i;
+
+
+	pprts = (PCI_ROUTING_TABLE **)prts;
+
+	for ( i = 0; i < PCI_MAX_BUS; i++) {
+		prt = *pprts++;
+		if (prt) {
+			for ( ; prt->length > 0; nvec++) {
+				prt = (PCI_ROUTING_TABLE *) ((NATIVE_UINT)prt + (NATIVE_UINT)prt->length);
+			}
+		}
+	}
+
+	*num_pci_vectors = nvec;
+	*vectors = acpi_os_callocate (sizeof(struct pci_vector_struct) * nvec);
+	if (!*vectors) {
+		printk("Acpi cfg: callocate for pci_vector error\n");
+		return AE_NO_MEMORY;
+	}
+
+	pvec = *vectors;
+	pprts = (PCI_ROUTING_TABLE **)prts;
+
+	for ( i = 0; i < PCI_MAX_BUS; i++) {
+		prt = prtf = *pprts++;
+		if (prt) {
+			for ( ; prt->length > 0; pvec++) {
+				pvec->bus	= (UINT16)i;
+				pvec->pci_id	= prt->address;
+				pvec->pin	= (UINT8)prt->pin;
+				pvec->irq	= (UINT8)prt->source_index;
+
+				prt = (PCI_ROUTING_TABLE *) ((NATIVE_UINT)prt + (NATIVE_UINT)prt->length);
+			}
+			acpi_os_free((void *)prtf);
+		}
+	}
+
+	return AE_OK;
+}
+
+
+void	__init
+acpi_cf_cleanup ( void )
+{
+	/* nothing to free, pci_vectors are used by the kernel */
+}
+
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_DEBUG
+void	__init
+acpi_cf_print_pci_vectors (
+	struct pci_vector_struct	*vectors,
+	int				num_pci_vectors
+	)
+{
+	struct pci_vector_struct	*pvec;
+	int				i;
+
+	printk("number of PCI interrupt vectors = %d\n", num_pci_vectors);
+
+	pvec = vectors;
+	for (i = 0; i < num_pci_vectors; i++) {
+		DUMPVECTOR(pvec);
+		pvec++;
+	}
+}
+#endif
diff -urN linux.orig/drivers/acpi/acpiconf.h linux/drivers/acpi/acpiconf.h
--- linux.orig/drivers/acpi/acpiconf.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/acpiconf.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,63 @@
+/*
+ *  acpiconf.h - ACPI based kernel configuration 
+ *
+ *  Copyright (C) 2000 Intel Corp.
+ *  Copyright (C) 2000 J.I. Lee <Jung-Ik.Lee@intel.com>
+ */
+
+#include <linux/init.h>
+
+#define	PCI_MAX_BUS		0x100
+#define	ACPI_STA_DEVICE_PRESENT	0x01
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_DEBUG
+#define	ACPI_CF_INITIALIZED()	(acpi_cf_initialized > 0)
+#undef	dprintk
+#define	dprintk(a)	printk a
+#else
+#define	ACPI_CF_INITIALIZED()	1
+#undef	dprintk
+#define	dprintk(a)
+#endif
+
+
+extern
+void	__init
+acpi_os_bind_osd(int acpi_phase);
+
+
+static
+ACPI_STATUS	__init
+acpi_cf_get_prt (void **prts);
+
+
+static
+ACPI_STATUS	__init
+acpi_cf_get_prt_callback (
+	ACPI_HANDLE		handle,
+	UINT32			level,
+	void			*context,
+	void			**retval
+	);
+
+
+static
+void	__init
+acpi_cf_add_to_pci_routing_tables (
+	NATIVE_UINT		busnum,
+	PCI_ROUTING_TABLE	*prt
+	);
+
+
+static
+ACPI_STATUS	__init
+acpi_cf_convert_prt_to_vectors (
+	void				*prts,
+	struct pci_vector_struct	**vectors,
+	int				*num_pci_vectors
+	);
+
+
+void	__init
+acpi_cf_cleanup ( void );
+
diff -urN linux.orig/drivers/acpi/driver.c linux/drivers/acpi/driver.c
--- linux.orig/drivers/acpi/driver.c	Wed Jun 20 18:47:39 2001
+++ linux/drivers/acpi/driver.c	Mon Dec 17 20:27:40 2001
@@ -39,6 +39,7 @@
 #include <linux/pm.h>
 #include <linux/acpi.h>
 #include <asm/uaccess.h>
+#include <asm/io.h>
 #include "acpi.h"
 #include "driver.h"
 
@@ -87,7 +88,10 @@
 		return -ENODEV;
 	}
 #else
-	rsdp_phys = efi.acpi;
+	if (efi.acpi20)
+		rsdp_phys = virt_to_phys(efi.acpi20);
+	else
+		rsdp_phys = virt_to_phys(efi.acpi);
 #endif
 
 	/* from this point on, on error we must call acpi_terminate() */
@@ -128,7 +132,9 @@
 
 	printk(KERN_INFO "ACPI: Subsystem enabled\n");
 
+#ifdef CONFIG_PM
 	pm_active = 1;
+#endif
 
 	return 0;
 }
@@ -141,7 +147,9 @@
 {
 	acpi_terminate();
 
+#ifdef CONFIG_PM
 	pm_active = 0;
+#endif
 
 	printk(KERN_ERR "ACPI: Subsystem disabled\n");
 }
diff -urN linux.orig/drivers/acpi/events/evrgnini.c linux/drivers/acpi/events/evrgnini.c
--- linux.orig/drivers/acpi/events/evrgnini.c	Wed Jun 20 18:47:40 2001
+++ linux/drivers/acpi/events/evrgnini.c	Mon Dec 17 20:27:40 2001
@@ -214,15 +214,13 @@
 		 * Node is currently the parent object
 		 */
 		while (node != acpi_gbl_root_node) {
-			status = acpi_ut_execute_HID (node, &object_hID);
-			if (ACPI_SUCCESS (status)) {
-				if (!(STRNCMP (object_hID.buffer, PCI_ROOT_HID_STRING,
-						   sizeof (PCI_ROOT_HID_STRING)))) {
-					acpi_install_address_space_handler (node,
-							   ACPI_ADR_SPACE_PCI_CONFIG,
-							   ACPI_DEFAULT_HANDLER, NULL, NULL);
-					break;
-				}
+			STRNCPY(object_hID.buffer, PCI_ROOT_HID_STRING, sizeof(ACPI_DEVICE_ID));
+			status = acpi_ut_match_PNP_ID (node, &object_hID);
+			if (status == AE_OK) {
+				acpi_install_address_space_handler (node,
+						   ACPI_ADR_SPACE_PCI_CONFIG,
+						   ACPI_DEFAULT_HANDLER, NULL, NULL);
+				break;
 			}
 
 			node = acpi_ns_get_parent_object (node);
diff -urN linux.orig/drivers/acpi/events/evxfevnt.c linux/drivers/acpi/events/evxfevnt.c
--- linux.orig/drivers/acpi/events/evxfevnt.c	Wed Jun 20 18:47:40 2001
+++ linux/drivers/acpi/events/evxfevnt.c	Mon Dec 17 20:27:40 2001
@@ -69,7 +69,12 @@
 
 	status = acpi_hw_set_mode (SYS_MODE_ACPI);
 	if (ACPI_FAILURE (status)) {
+#ifdef CONFIG_IA64_HP_PROTO
+		printk("acpi_hw_set_mode(SYS_MODE_ACPI) failed, ignored\n");
+		status = AE_OK;
+#else
 		return (status);
+#endif
 	}
 
 	return (status);
diff -urN linux.orig/drivers/acpi/include/actypes.h linux/drivers/acpi/include/actypes.h
--- linux.orig/drivers/acpi/include/actypes.h	Wed Jun 20 18:47:40 2001
+++ linux/drivers/acpi/include/actypes.h	Mon Dec 17 20:27:40 2001
@@ -60,6 +60,7 @@
 typedef int                             INT32;
 typedef unsigned int                    UINT32;
 typedef COMPILER_DEPENDENT_UINT64       UINT64;
+typedef long				INT64;
 
 typedef UINT64                          NATIVE_UINT;
 typedef INT64                           NATIVE_INT;
diff -urN linux.orig/drivers/acpi/include/acutils.h linux/drivers/acpi/include/acutils.h
--- linux.orig/drivers/acpi/include/acutils.h	Wed Jun 20 18:47:40 2001
+++ linux/drivers/acpi/include/acutils.h	Mon Dec 17 20:27:40 2001
@@ -402,6 +402,7 @@
 /* Method name strings */
 
 #define METHOD_NAME__HID        "_HID"
+#define METHOD_NAME__CID        "_CID"
 #define METHOD_NAME__UID        "_UID"
 #define METHOD_NAME__ADR        "_ADR"
 #define METHOD_NAME__STA        "_STA"
@@ -420,6 +421,11 @@
 acpi_ut_execute_HID (
 	ACPI_NAMESPACE_NODE     *device_node,
 	ACPI_DEVICE_ID          *hid);
+
+ACPI_STATUS
+acpi_ut_match_PNP_ID (
+	ACPI_NAMESPACE_NODE     *device_node,
+	ACPI_DEVICE_ID          *pnpid);
 
 ACPI_STATUS
 acpi_ut_execute_STA (
diff -urN linux.orig/drivers/acpi/namespace/nsxfobj.c linux/drivers/acpi/namespace/nsxfobj.c
--- linux.orig/drivers/acpi/namespace/nsxfobj.c	Wed Jun 20 18:47:40 2001
+++ linux/drivers/acpi/namespace/nsxfobj.c	Mon Dec 17 20:27:40 2001
@@ -629,10 +629,13 @@
 	}
 
 	/*
-	 * Filter based on device HID
+	 * Filter based on device HID/CID
 	 */
 	if (info->hid != NULL) {
-		status = acpi_ut_execute_HID (node, &device_id);
+
+		STRNCPY(device_id.buffer, info->hid, sizeof(ACPI_DEVICE_ID));
+
+		status = acpi_ut_match_PNP_ID (node, &device_id);
 		if (status == AE_NOT_FOUND) {
 			return (AE_OK);
 		}
@@ -641,12 +644,9 @@
 			return (AE_CTRL_DEPTH);
 		}
 
-		if (STRNCMP (device_id.buffer, info->hid, sizeof (device_id.buffer)) != 0) {
-			return (AE_OK);
-		}
+		info->user_function (obj_handle, nesting_level, info->context, return_value);
 	}
 
-	info->user_function (obj_handle, nesting_level, info->context, return_value);
 	return (AE_OK);
 }
 
diff -urN linux.orig/drivers/acpi/os.c linux/drivers/acpi/os.c
--- linux.orig/drivers/acpi/os.c	Sun Jun 24 21:53:07 2001
+++ linux/drivers/acpi/os.c	Mon Dec 17 20:27:40 2001
@@ -1,15 +1,9 @@
-/******************************************************************************
- * 
- * Module Name: os.c - Linux OSL functions
- *		$Revision: 28 $
- *
- *****************************************************************************/
-
 /*
  *  os.c - OS-dependent functions
  *
  *  Copyright (C) 2000 Andrew Henroid
- *  Copyright (C) 2001 Andrew Grover
+ *  Copyright (C) 2000 Intel Corp.
+ *  Copyright (C) 2000 J.I. Lee <jung-ik.lee@intel.com>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -31,16 +25,21 @@
  * - Fixed improper kernel_thread parameters 
  */
 
+#include <linux/config.h>
+
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/kmod.h>
+#include <linux/irq.h>
 #include <linux/delay.h>
 #include <asm/io.h>
 #include <acpi.h>
+#ifndef	CONFIG_ACPI_KERNEL_CONFIG_ONLY
 #include "driver.h"
+#endif
 
 #define _COMPONENT	ACPI_OS_SERVICES
 	MODULE_NAME	("os")
@@ -56,6 +55,35 @@
  *			       Debugger Stuff
  *****************************************************************************/
 
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG
+#include "osconf.h"
+
+struct acpi_osd acpi_osd_rt = {
+	/* these are runtime osd entries that differ from boottime entries */
+	acpi_os_allocate_rt,
+	acpi_os_callocate_rt,
+	acpi_os_free_rt,
+	acpi_os_queue_for_execution_rt,
+	acpi_os_read_pci_cfg_byte_rt,
+	acpi_os_read_pci_cfg_word_rt,
+	acpi_os_read_pci_cfg_dword_rt,
+	acpi_os_write_pci_cfg_byte_rt,
+	acpi_os_write_pci_cfg_word_rt,
+	acpi_os_write_pci_cfg_dword_rt
+};
+#else
+#define	acpi_os_allocate_rt		acpi_os_allocate
+#define	acpi_os_callocate_rt		acpi_os_callocate
+#define	acpi_os_free_rt			acpi_os_free
+#define acpi_os_queue_for_execution_rt	acpi_os_queue_for_execution
+#define acpi_os_read_pci_cfg_byte_rt	acpi_os_read_pci_cfg_byte
+#define acpi_os_read_pci_cfg_word_rt	acpi_os_read_pci_cfg_word
+#define acpi_os_read_pci_cfg_dword_rt	acpi_os_read_pci_cfg_dword
+#define acpi_os_write_pci_cfg_byte_rt	acpi_os_write_pci_cfg_byte
+#define acpi_os_write_pci_cfg_word_rt	acpi_os_write_pci_cfg_word
+#define acpi_os_write_pci_cfg_dword_rt	acpi_os_write_pci_cfg_dword
+#endif
+
 #ifdef ENABLE_DEBUGGER
 
 #include <linux/kdb.h>
@@ -127,13 +155,13 @@
 }
 
 void *
-acpi_os_allocate(u32 size)
+acpi_os_allocate_rt(u32 size)
 {
 	return kmalloc(size, GFP_KERNEL);
 }
 
 void *
-acpi_os_callocate(u32 size)
+acpi_os_callocate_rt(u32 size)
 {
 	void *ptr = acpi_os_allocate(size);
 	if (ptr)
@@ -142,14 +170,37 @@
 }
 
 void
-acpi_os_free(void *ptr)
+acpi_os_free_rt(void *ptr)
 {
 	kfree(ptr);
 }
 
+#ifdef CONFIG_ACPI_KERNEL_CONFIG
+#include <asm/efi.h>
+#define ACPI_USE_EFI
+#endif
+
 ACPI_STATUS
 acpi_os_map_memory(ACPI_PHYSICAL_ADDRESS phys, u32 size, void **virt)
 {
+#ifdef ACPI_USE_EFI
+	int ram_page;
+
+	ram_page = efi_page_is_ram((unsigned long) phys);
+
+	if (ram_page == 1) {
+		*virt = phys_to_virt((unsigned long) phys);
+		/* printk("acpi_os_map_memory(0x%lx) = 0x%lx\n",phys, *virt); */
+		return AE_OK;
+	} else if (ram_page == 0) {
+		*virt = ioremap((unsigned long) phys, size);
+		/* printk("acpi_os_map_memory(0x%lx) = 0x%lx\n",phys, *virt); */
+		return AE_OK;
+	} else {
+		/* printk("acpi_os_map_memory(0x%lx) = ????\n",phys); */
+		return AE_ERROR;
+	}
+#else
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR "ACPI: Cannot map memory that high\n");
 		return AE_ERROR;
@@ -165,6 +216,7 @@
 		return AE_ERROR;
 
 	return AE_OK;
+#endif
 }
 
 void
@@ -191,6 +243,101 @@
 	(*acpi_irq_handler)(acpi_irq_context);
 }
 
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG
+struct irqaction	acpiirqaction;
+/*
+ * codes from request_irq and free_irq.
+ */
+ACPI_STATUS
+acpi_os_install_interrupt_handler(u32 irq, OSD_HANDLER handler, void *context)
+{
+	struct irqaction	*act;
+	int	retval;
+
+	if (irq >= NR_IRQS) {
+		printk("ACPI: install SCI handler fail: invalid irq%d\n", irq);
+		return AE_ERROR;
+	}
+
+	if (!handler) {
+		printk("ACPI: install SCI handler fail: invalid handler\n");
+		return AE_ERROR;
+	}
+
+	act = & acpiirqaction;
+
+	acpi_irq_irq = irq;
+	acpi_irq_handler = handler;
+	acpi_irq_context = context;
+
+	act->handler = acpi_irq;
+	act->flags = SA_INTERRUPT | SA_SHIRQ;
+	act->mask = 0;
+	act->name = "acpi";
+	act->next = NULL;
+	act->dev_id = acpi_irq;
+
+	retval = setup_irq(irq, act);
+	if (retval) {
+		printk("ACPI: install SCI handler fail: setup_irq\n");
+		acpi_irq_handler = NULL;
+		return AE_ERROR;
+	}
+	printk("ACPI: install SCI %d handler pass\n", irq);
+
+	return AE_OK;
+}
+
+ACPI_STATUS
+acpi_os_remove_interrupt_handler(u32 irq, OSD_HANDLER handler)
+{
+	irq_desc_t *desc;
+	struct irqaction **p;
+	unsigned long flags;
+
+	if (!acpi_irq_handler)
+		return AE_OK;
+
+	if (irq != acpi_irq_irq) return AE_ERROR;
+
+	acpi_irq_handler = NULL;
+
+	desc = irq_desc(irq);
+	spin_lock_irqsave(&desc->lock,flags);
+	p = &desc->action;
+	for (;;) {
+		struct irqaction * action = *p;
+		if (action) {
+			struct irqaction **pp = p;
+			p = &action->next;
+			if (action->dev_id != acpi_irq)
+				continue;
+
+			/* Found it - now remove it from the list of entries */
+			*pp = action->next;
+			if (!desc->action) {
+				desc->status |= IRQ_DISABLED;
+				desc->handler->shutdown(irq);
+			}
+			spin_unlock_irqrestore(&desc->lock,flags);
+
+#ifdef CONFIG_SMP
+			/* Wait to make sure it's not being used on another CPU */
+			while (desc->status & IRQ_INPROGRESS)
+				barrier();
+#endif
+			return AE_OK;
+		}
+		printk("ACPI: Trying to free free IRQ%d\n",irq);
+		spin_unlock_irqrestore(&desc->lock,flags);
+		return AE_OK;
+	}
+
+	return AE_OK;
+}
+
+#else
 ACPI_STATUS
 acpi_os_install_interrupt_handler(u32 irq, OSD_HANDLER handler, void *context)
 {
@@ -218,6 +365,7 @@
 
 	return AE_OK;
 }
+#endif
 
 /*
  * Running in interpreter thread context, safe to sleep
@@ -275,41 +423,47 @@
 UINT8
 acpi_os_mem_in8 (ACPI_PHYSICAL_ADDRESS phys_addr)
 {
-	return (*(u8*) (u32) phys_addr);
+	u8* virt_addr = ioremap(phys_addr,0);
+	return (*(u8*) virt_addr);
 }
 
 UINT16
 acpi_os_mem_in16 (ACPI_PHYSICAL_ADDRESS phys_addr)
 {
-	return (*(u16*) (u32) phys_addr);
+	u16* virt_addr = ioremap(phys_addr,0);
+	return (*(u16*) virt_addr);
 }
 
 UINT32
 acpi_os_mem_in32 (ACPI_PHYSICAL_ADDRESS phys_addr)
 {
-	return (*(u32*) (u32) phys_addr);
+	u32* virt_addr = ioremap(phys_addr,0);
+	return (*(u32*) virt_addr);
 }
 
 void
 acpi_os_mem_out8 (ACPI_PHYSICAL_ADDRESS phys_addr, UINT8 value)
 {
-	*(u8*) phys_to_virt(phys_addr) = value;
+	u8* virt_addr = ioremap(phys_addr,0);
+	*(u8*) virt_addr = value;
 }
 
 void
 acpi_os_mem_out16 (ACPI_PHYSICAL_ADDRESS phys_addr, UINT16 value)
 {
-	*(u16*) phys_to_virt(phys_addr) = value;
+	u16* virt_addr = ioremap(phys_addr,0);
+	*(u16*) virt_addr = value;
 }
 
 void
 acpi_os_mem_out32 (ACPI_PHYSICAL_ADDRESS phys_addr, UINT32 value)
 {
-	*(u32*) phys_to_virt(phys_addr) = value;
+	u32* virt_addr = ioremap(phys_addr,0);
+	*(u32*) virt_addr = value;
 }
 
 ACPI_STATUS
-acpi_os_read_pci_cfg_byte(
+acpi_os_read_pci_cfg_byte_rt(
 	u32 bus,
 	u32 func,
 	u32 addr,
@@ -323,7 +477,7 @@
 }
 
 ACPI_STATUS
-acpi_os_read_pci_cfg_word(
+acpi_os_read_pci_cfg_word_rt(
 	u32 bus,
 	u32 func,
 	u32 addr,
@@ -337,7 +491,7 @@
 }
 
 ACPI_STATUS
-acpi_os_read_pci_cfg_dword(
+acpi_os_read_pci_cfg_dword_rt(
 	u32 bus,
 	u32 func,
 	u32 addr,
@@ -351,7 +505,7 @@
 }
 
 ACPI_STATUS
-acpi_os_write_pci_cfg_byte(
+acpi_os_write_pci_cfg_byte_rt(
 	u32 bus,
 	u32 func,
 	u32 addr,
@@ -365,7 +519,7 @@
 }
 
 ACPI_STATUS
-acpi_os_write_pci_cfg_word(
+acpi_os_write_pci_cfg_word_rt(
 	u32 bus,
 	u32 func,
 	u32 addr,
@@ -379,7 +533,7 @@
 }
 
 ACPI_STATUS
-acpi_os_write_pci_cfg_dword(
+acpi_os_write_pci_cfg_dword_rt(
 	u32 bus,
 	u32 func,
 	u32 addr,
@@ -391,6 +545,27 @@
 		return AE_ERROR;
 	return AE_OK;
 }
+
+#ifdef CONFIG_ACPI_KERNEL_CONFIG
+/*
+ * Queue for interpreter thread
+ */
+
+ACPI_STATUS
+acpi_os_queue_for_execution_rt(
+			    u32 priority,
+			    OSD_EXECUTION_CALLBACK callback,
+			    void *context)
+{
+# ifndef CONFIG_ACPI_KERNEL_CONFIG_ONLY
+	if (acpi_run(callback, context))
+		return AE_ERROR;
+# else
+	(*callback)(context);
+# endif
+	return AE_OK;
+}
+#endif
 
 ACPI_STATUS
 acpi_os_load_module (
diff -urN linux.orig/drivers/acpi/osconf.c linux/drivers/acpi/osconf.c
--- linux.orig/drivers/acpi/osconf.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/osconf.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,321 @@
+/*
+ *  osconf.c - ACPI OS-dependent functions for Kernel Boot/Configuration time
+ *
+ *  Copyright (C) 2000 Intel Corp.
+ *  Copyright (C) 2000 J.I. Lee <Jung-Ik.Lee@intel.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/pci.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/sal.h>
+
+#include "acpi.h"
+#include "osconf.h"
+
+
+static void * __init acpi_os_allocate_bt(u32 size);
+static void * __init acpi_os_callocate_bt(u32 size);
+static void __init acpi_os_free_bt(void *ptr);
+
+static ACPI_STATUS __init
+acpi_os_queue_for_execution_bt(
+	u32			priority,
+	OSD_EXECUTION_CALLBACK	callback,
+	void			*context
+	);
+
+static ACPI_STATUS __init
+acpi_os_read_pci_cfg_byte_bt( u32 segbus, u32 func, u32 addr, u8 * val);
+
+static ACPI_STATUS __init
+acpi_os_read_pci_cfg_word_bt( u32 segbus, u32 func, u32 addr, u16 * val);
+
+static ACPI_STATUS __init
+acpi_os_read_pci_cfg_dword_bt( u32 segbus, u32 func, u32 addr, u32 * val);
+
+static ACPI_STATUS __init
+acpi_os_write_pci_cfg_byte_bt( u32 segbus, u32 func, u32 addr, u8 val);
+
+static ACPI_STATUS __init
+acpi_os_write_pci_cfg_word_bt( u32 segbus, u32 func, u32 addr, u16 val);
+
+static ACPI_STATUS __init
+acpi_os_write_pci_cfg_dword_bt( u32 segbus, u32 func, u32 addr, u32 val);
+
+
+static struct acpi_osd *acpi_osd;
+extern struct acpi_osd acpi_osd_rt;
+static struct acpi_osd acpi_osd_bt __initdata = {
+	/* these are boottime osd entries that differ from runtime entries */
+	acpi_os_allocate_bt,
+	acpi_os_callocate_bt,
+	acpi_os_free_bt,
+	acpi_os_queue_for_execution_bt,
+	acpi_os_read_pci_cfg_byte_bt,
+	acpi_os_read_pci_cfg_word_bt,
+	acpi_os_read_pci_cfg_dword_bt,
+	acpi_os_write_pci_cfg_byte_bt,
+	acpi_os_write_pci_cfg_word_bt,
+	acpi_os_write_pci_cfg_dword_bt
+};
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_BM_PROFILE
+static void	__init
+acpi_cf_bm_statistics( void );
+#endif
+
+void __init
+acpi_os_bind_osd(int	acpi_phase)
+{
+	switch (acpi_phase) {
+	case	ACPI_CF_PHASE_BOOTTIME:
+		acpi_osd = &acpi_osd_bt;
+		printk("Acpi cfg:bind to Boot time Acpi OSD\n");
+		break;
+	case	ACPI_CF_PHASE_RUNTIME:
+	default:
+		acpi_osd = &acpi_osd_rt;
+		printk("Acpi cfg:bind to Run time Acpi OSD\n");
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_BM_PROFILE
+		acpi_cf_bm_statistics();
+#endif
+		break;
+	}
+}
+
+void *
+acpi_os_allocate(u32 size)
+{
+	return acpi_osd->allocate(size);
+}
+
+void *
+acpi_os_callocate(u32 size)
+{
+	return acpi_osd->callocate(size);
+}
+
+void
+acpi_os_free(void *ptr)
+{
+	acpi_osd->free(ptr);
+	return;
+}
+
+
+ACPI_STATUS
+acpi_os_read_pci_cfg_byte( u32 segbus, u32 func, u32 addr, u8 * val)
+{
+	return acpi_osd->read_pci_cfg_byte(segbus, func, addr, val);
+}
+
+
+ACPI_STATUS
+acpi_os_read_pci_cfg_word( u32 segbus, u32 func, u32 addr, u16 * val)
+{
+	return acpi_osd->read_pci_cfg_word(segbus, func, addr, val);
+}
+
+
+ACPI_STATUS
+acpi_os_read_pci_cfg_dword( u32 segbus, u32 func, u32 addr, u32 * val)
+{
+	return acpi_osd->read_pci_cfg_dword(segbus, func, addr, val);
+}
+
+
+ACPI_STATUS
+acpi_os_write_pci_cfg_byte( u32 segbus, u32 func, u32 addr, u8 val)
+{
+	return acpi_osd->write_pci_cfg_byte(segbus, func, addr, val);
+}
+
+
+ACPI_STATUS
+acpi_os_write_pci_cfg_word( u32 segbus, u32 func, u32 addr, u16 val)
+{
+	return acpi_osd->write_pci_cfg_word(segbus, func, addr, val);
+}
+
+
+ACPI_STATUS
+acpi_os_write_pci_cfg_dword( u32 segbus, u32 func, u32 addr, u32 val)
+{
+	return acpi_osd->write_pci_cfg_dword(segbus, func, addr, val);
+}
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_BM_PROFILE
+/*
+ * Let's profile bootmem usage to see how much we consume. J.I.
+ */
+static	unsigned long	bm_alloc_size __initdata = 0;
+static	unsigned long	bm_alloc_size_max __initdata = 0;
+static	unsigned long	bm_alloc_count_max __initdata = 0;
+static	unsigned long	bm_free_count_max __initdata = 0;
+
+static void	__init
+acpi_cf_bm_checkin(void *ptr, u32 size)
+{
+	bm_alloc_count_max++;
+	bm_alloc_size += size;
+	if (bm_alloc_size > bm_alloc_size_max)
+		bm_alloc_size_max = bm_alloc_size;
+};
+
+static void	__init
+acpi_cf_bm_checkout(void *ptr, u32 size)
+{
+	bm_free_count_max++;
+	bm_alloc_size -= size;
+};
+
+static void	__init
+acpi_cf_bm_statistics( void )
+{
+	printk("Acpi cfg:bm_alloc_size_max =%ld bytes\n", bm_alloc_size_max);
+	printk("Acpi cfg:bm_alloc_count_max=%ld\n", bm_alloc_count_max);
+	printk("Acpi cfg:bm_free_count_max =%ld\n", bm_free_count_max);
+}
+#endif
+
+
+static void * __init
+acpi_os_allocate_bt(u32 size)
+{
+	void *ptr;
+
+	size += sizeof(unsigned long);
+	ptr = alloc_bootmem(size);
+
+	if (ptr) {
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_BM_PROFILE
+		acpi_cf_bm_checkin(ptr, size);
+#endif
+		*((unsigned long *)ptr) = (unsigned long)size;
+		ptr += sizeof(unsigned long);
+	}
+
+	return ptr;
+}
+
+static void * __init
+acpi_os_callocate_bt(u32 size)
+{
+	void *ptr = acpi_os_allocate_bt(size);
+
+	return ptr;
+}
+
+static void __init
+acpi_os_free_bt(void *ptr)
+{
+	unsigned long	size;
+
+	ptr -= sizeof(size);
+	size = *((unsigned long *)ptr);
+
+#ifdef	CONFIG_ACPI_KERNEL_CONFIG_BM_PROFILE
+	acpi_cf_bm_checkout(ptr, (unsigned long)size);
+#endif
+	//if (size)
+		free_bootmem (__pa((unsigned long)ptr), (u32)size);
+}
+
+
+static ACPI_STATUS __init
+acpi_os_queue_for_execution_bt(
+	u32			priority,
+	OSD_EXECUTION_CALLBACK	callback,
+	void			*context)
+{
+	/*
+	 * run callback immediately
+	 */
+	(*callback)(context);
+	return AE_OK;
+}
+
+
+static ACPI_STATUS __init
+acpi_os_read_pci_cfg_byte_bt( u32 segbus, u32 func, u32 addr, u8 * val)
+{
+	unsigned int	devfn;
+	s64		status;
+	u64		lval;
+
+	devfn = PCI_DEVFN((func >> 16) & 0xffff, func & 0xffff);
+	status = ia64_sal_pci_config_read(PCI_CONFIG_ADDRESS((segbus & 0xffff), devfn, addr), 1, &lval);
+	*val = lval;
+
+	return status;
+}
+
+
+static ACPI_STATUS __init
+acpi_os_read_pci_cfg_word_bt( u32 segbus, u32 func, u32 addr, u16 * val)
+{
+	unsigned int	devfn;
+	s64		status;
+	u64		lval;
+
+	devfn = PCI_DEVFN((func >> 16) & 0xffff, func & 0xffff);
+	status = ia64_sal_pci_config_read(PCI_CONFIG_ADDRESS((segbus & 0xffff), devfn, addr), 2, &lval);
+	*val = lval;
+
+	return status;
+}
+
+
+static ACPI_STATUS __init
+acpi_os_read_pci_cfg_dword_bt( u32 segbus, u32 func, u32 addr, u32 * val)
+{
+	unsigned int	devfn;
+	s64		status;
+	u64		lval;
+
+	devfn = PCI_DEVFN((func >> 16) & 0xffff, func & 0xffff);
+	status = ia64_sal_pci_config_read(PCI_CONFIG_ADDRESS((segbus & 0xffff), devfn, addr), 4, &lval);
+	*val = lval;
+
+	return status;
+}
+
+
+static ACPI_STATUS __init
+acpi_os_write_pci_cfg_byte_bt( u32 segbus, u32 func, u32 addr, u8 val)
+{
+	unsigned int	devfn;
+
+	devfn = PCI_DEVFN((func >> 16) & 0xffff, func & 0xffff);
+	return ia64_sal_pci_config_write(PCI_CONFIG_ADDRESS((segbus & 0xffff), devfn, addr), 1, val);
+}
+
+
+static ACPI_STATUS __init
+acpi_os_write_pci_cfg_word_bt( u32 segbus, u32 func, u32 addr, u16 val)
+{
+	unsigned int	devfn;
+
+	devfn = PCI_DEVFN((func >> 16) & 0xffff, func & 0xffff);
+	return ia64_sal_pci_config_write(PCI_CONFIG_ADDRESS((segbus & 0xffff), devfn, addr), 2, val);
+}
+
+
+static ACPI_STATUS __init
+acpi_os_write_pci_cfg_dword_bt( u32 segbus, u32 func, u32 addr, u32 val)
+{
+	unsigned int	devfn;
+
+	devfn = PCI_DEVFN((func >> 16) & 0xffff, func & 0xffff);
+	return ia64_sal_pci_config_write(PCI_CONFIG_ADDRESS((segbus & 0xffff), devfn, addr), 4, val);
+}
+
+
diff -urN linux.orig/drivers/acpi/osconf.h linux/drivers/acpi/osconf.h
--- linux.orig/drivers/acpi/osconf.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/osconf.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,84 @@
+/*
+ *  osconf.h - ACPI OS-dependent headers for Kernel Boot/Configuration time
+ *
+ *  Copyright (C) 2000 Intel Corp.
+ *  Copyright (C) 2000 J.I. Lee <Jung-Ik.Lee@intel.com>
+ */
+
+
+struct acpi_osd {
+	void * (*allocate)(u32 size);
+	void * (*callocate)(u32 size);
+	void  (*free)(void *ptr);
+	ACPI_STATUS (*queue_for_exec)(u32 pri, OSD_EXECUTION_CALLBACK cb, void *context);
+	ACPI_STATUS (*read_pci_cfg_byte)(u32 bus, u32 func, u32 addr, u8 *val);
+	ACPI_STATUS (*read_pci_cfg_word)(u32 bus, u32 func, u32 addr, u16 *val);
+	ACPI_STATUS (*read_pci_cfg_dword)(u32 bus, u32 func, u32 addr, u32 *val);
+	ACPI_STATUS (*write_pci_cfg_byte)(u32 bus, u32 func, u32 addr, u8 val);
+	ACPI_STATUS (*write_pci_cfg_word)(u32 bus, u32 func, u32 addr, u16 val);
+	ACPI_STATUS (*write_pci_cfg_dword)(u32 bus, u32 func, u32 addr, u32 val);
+};
+
+
+#define	PCI_CONFIG_ADDRESS(bus, devfn, where) \
+	(((u64) bus << 16) | ((u64) (devfn & 0xff) << 8) | (where & 0xff))
+
+#define	ACPI_CF_PHASE_BOOTTIME	0x00
+#define	ACPI_CF_PHASE_RUNTIME	0x01
+
+
+/* acpi_osd functions */
+void * acpi_os_allocate(u32 size);
+void * acpi_os_callocate(u32 size);
+void acpi_os_free(void *ptr);
+
+
+ACPI_STATUS
+acpi_os_read_pci_cfg_byte( u32 segbus, u32 func, u32 addr, u8 * val);
+
+ACPI_STATUS
+acpi_os_read_pci_cfg_word( u32 segbus, u32 func, u32 addr, u16 * val);
+
+ACPI_STATUS
+acpi_os_read_pci_cfg_dword( u32 segbus, u32 func, u32 addr, u32 * val);
+
+ACPI_STATUS
+acpi_os_write_pci_cfg_byte( u32 segbus, u32 func, u32 addr, u8 val);
+
+ACPI_STATUS
+acpi_os_write_pci_cfg_word( u32 segbus, u32 func, u32 addr, u16 val);
+
+ACPI_STATUS
+acpi_os_write_pci_cfg_dword( u32 segbus, u32 func, u32 addr, u32 val);
+
+
+/* acpi_osd_rt functions */
+extern void * acpi_os_allocate_rt(u32 size);
+extern void * acpi_os_callocate_rt(u32 size);
+extern void acpi_os_free_rt(void *ptr);
+
+extern ACPI_STATUS
+acpi_os_queue_for_execution_rt(
+	u32			priority,
+	OSD_EXECUTION_CALLBACK	callback,
+	void			*context
+	);
+
+extern ACPI_STATUS
+acpi_os_read_pci_cfg_byte_rt( u32 segbus, u32 func, u32 addr, u8 * val);
+
+extern ACPI_STATUS
+acpi_os_read_pci_cfg_word_rt( u32 segbus, u32 func, u32 addr, u16 * val);
+
+extern ACPI_STATUS
+acpi_os_read_pci_cfg_dword_rt( u32 segbus, u32 func, u32 addr, u32 * val);
+
+extern ACPI_STATUS
+acpi_os_write_pci_cfg_byte_rt( u32 segbus, u32 func, u32 addr, u8 val);
+
+extern ACPI_STATUS
+acpi_os_write_pci_cfg_word_rt( u32 segbus, u32 func, u32 addr, u16 val);
+
+extern ACPI_STATUS
+acpi_os_write_pci_cfg_dword_rt( u32 segbus, u32 func, u32 addr, u32 val);
+
diff -urN linux.orig/drivers/acpi/resources/rsirq.c linux/drivers/acpi/resources/rsirq.c
--- linux.orig/drivers/acpi/resources/rsirq.c	Wed Jun 20 18:47:40 2001
+++ linux/drivers/acpi/resources/rsirq.c	Mon Dec 17 20:27:40 2001
@@ -307,28 +307,16 @@
 	output_struct->data.extended_irq.producer_consumer = temp8 & 0x01;
 
 	/*
-	 * Check for HE, LL or HL
+	 * Check interrupt mode
+	 *  - Edge/Level are defined opposite in the table vs the headers
 	 */
-	if(temp8 & 0x02) {
-		output_struct->data.extended_irq.edge_level = EDGE_SENSITIVE;
-		output_struct->data.extended_irq.active_high_low = ACTIVE_HIGH;
-	}
+	output_struct->data.extended_irq.edge_level =
+	                          (temp8 & 0x2) ? EDGE_SENSITIVE : LEVEL_SENSITIVE;
 
-	else {
-		if(temp8 & 0x4) {
-			output_struct->data.extended_irq.edge_level = LEVEL_SENSITIVE;
-			output_struct->data.extended_irq.active_high_low = ACTIVE_LOW;
-		}
-
-		else {
-			/*
-			 * Only _LL and _HE polarity/trigger interrupts
-			 * are allowed (ACPI spec v1.0b ection 6.4.2.1),
-			 * so an error will occur if we reach this point
-			 */
-			return (AE_BAD_DATA);
-		}
-	}
+	/*
+	 * Check interrupt polarity
+	 */
+	output_struct->data.extended_irq.active_high_low = (temp8 >> 2) & 0x1;
 
 	/*
 	 * Check for sharable
diff -urN linux.orig/drivers/acpi/utilities/uteval.c linux/drivers/acpi/utilities/uteval.c
--- linux.orig/drivers/acpi/utilities/uteval.c	Wed Jun 20 18:47:40 2001
+++ linux/drivers/acpi/utilities/uteval.c	Mon Dec 17 20:27:40 2001
@@ -244,6 +244,90 @@
 	return (status);
 }
 
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_ut_match_PNP_ID
+ *
+ * PARAMETERS:  Device_node         - Node for the device
+ *              *PNPID              - Device ID to match
+ *
+ * RETURN:      AE_OK = node matches id
+ *
+ * DESCRIPTION: Matches PNP ID to node based on _HID and _CID method data
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+ACPI_STATUS
+acpi_ut_match_PNP_ID (
+	ACPI_NAMESPACE_NODE     *device_node,
+	ACPI_DEVICE_ID			*pnpid)
+{
+	ACPI_DEVICE_ID			device_id;
+	ACPI_STATUS				status;
+	ACPI_OPERAND_OBJECT     *obj_desc, *obj_ptr;
+	u32						i;
+	
+	FUNCTION_TRACE ("Ut_match_PNP_ID");
+
+	status = acpi_ut_execute_HID(device_node, &device_id);
+
+	if (ACPI_SUCCESS(status)) {
+		if (!STRNCMP(device_id.buffer, pnpid->buffer, sizeof(ACPI_DEVICE_ID)))
+			return AE_OK;
+	}
+
+	status = acpi_ns_evaluate_relative (device_node, METHOD_NAME__CID, NULL, &obj_desc);
+
+	if (ACPI_FAILURE (status) || (obj_desc == NULL)) {
+		return AE_NOT_FOUND;
+	}
+			
+	status = AE_NOT_FOUND;
+
+	switch (obj_desc->common.type) {
+		
+		case ACPI_TYPE_INTEGER:
+			acpi_ex_eisa_id_to_string ((u32) obj_desc->integer.value, device_id.buffer);
+			if (!STRNCMP(device_id.buffer, pnpid->buffer, sizeof(ACPI_DEVICE_ID)))
+				status = AE_OK;
+			break;
+		
+		case ACPI_TYPE_STRING:
+			if (!STRNCMP(obj_desc->string.pointer, pnpid->buffer, sizeof(ACPI_DEVICE_ID)))
+				status = AE_OK;
+			break;
+		
+		case ACPI_TYPE_PACKAGE:
+			for (i = 0 ; i < obj_desc->package.count ; i++) {
+				obj_ptr = obj_desc->package.elements[i];
+				
+				switch (obj_ptr->common.type) {
+					case ACPI_TYPE_INTEGER:
+						acpi_ex_eisa_id_to_string ((u32) obj_ptr->integer.value, device_id.buffer);
+						if (!STRNCMP(device_id.buffer, pnpid->buffer, sizeof(ACPI_DEVICE_ID)))
+							status = AE_OK;
+						break;
+		
+					case ACPI_TYPE_STRING:
+						if (!STRNCMP(obj_ptr->string.pointer, pnpid->buffer, sizeof(ACPI_DEVICE_ID)))
+							status = AE_OK;
+						break;
+						
+					default:
+						break;
+				}
+			}
+		
+		default:
+			break;
+	}
+
+	acpi_ut_remove_reference (obj_desc);	
+	return (status);
+		
+}
+
 
 /*******************************************************************************
  *
diff -urN linux.orig/drivers/block/loop.c linux/drivers/block/loop.c
--- linux.orig/drivers/block/loop.c	Fri Jun 29 17:16:56 2001
+++ linux/drivers/block/loop.c	Mon Dec 17 20:27:40 2001
@@ -36,6 +36,10 @@
  * Al Viro too.
  * Jens Axboe <axboe@suse.de>, Nov 2000
  *
+ * Changing of backing file/device during operation for read-only loopback.
+ * Jakub Jelinek <jakub@redhat.com>, Mar 31, 2000
+ * AV: ported the above to Jens' variant, Jan 2001
+ *
  * Still To Fix:
  * - Advisory locking is ignored here. 
  * - Should use an own CAP_* category instead of CAP_SYS_ADMIN 
@@ -74,6 +78,8 @@
 
 #define MAJOR_NR LOOP_MAJOR
 
+#define LOOP_BH_Set 7			/* it's ugly, but... */
+
 static int max_loop = 8;
 static struct loop_device *loop_dev;
 static int *loop_sizes;
@@ -251,12 +257,23 @@
 	return size;
 }
 
+static inline void lo_drop(struct loop_device *lo, int set)
+{
+      spin_lock_irq(&lo->lo_lock);
+      if (!--lo->lo_pending_reads[set] && set !=lo->lo_current &&
+          lo->lo_change)
+              up(lo->lo_change);
+      spin_unlock_irq(&lo->lo_lock);
+}
+
+
 static int lo_receive(struct loop_device *lo, struct buffer_head *bh, int bsize,
 		      loff_t pos)
 {
 	struct lo_read_data cookie;
 	read_descriptor_t desc;
 	struct file *file;
+	int lo_current;
 
 	cookie.lo = lo;
 	cookie.data = bh->b_data;
@@ -266,9 +283,12 @@
 	desc.buf = (char*)&cookie;
 	desc.error = 0;
 	spin_lock_irq(&lo->lo_lock);
+ 	lo_current = lo->lo_current;
+ 	lo->lo_pending_reads[lo_current]++;
 	file = lo->lo_backing_file;
 	spin_unlock_irq(&lo->lo_lock);
 	do_generic_file_read(file, &pos, &desc, lo_read_actor);
+ 	lo_drop(lo, lo_current);
 	return desc.error;
 }
 
@@ -381,9 +401,11 @@
 }
 
 static struct buffer_head *loop_get_buffer(struct loop_device *lo,
-					   struct buffer_head *rbh)
+					   struct buffer_head *rbh,
+					   int rw)
 {
 	struct buffer_head *bh;
+	int lo_current;
 
 	do {
 		bh = kmem_cache_alloc(bh_cachep, SLAB_NOIO);
@@ -398,9 +420,13 @@
 	bh->b_size = rbh->b_size;
 	bh->b_dev = rbh->b_rdev;
 	spin_lock_irq(&lo->lo_lock);
+	lo_current = lo->lo_current;
+	if (rw != WRITE)
+		lo->lo_pending_reads[lo_current]++;
 	bh->b_rdev = lo->lo_device;
 	spin_unlock_irq(&lo->lo_lock);
 	bh->b_state = (1 << BH_Req) | (1 << BH_Mapped) | (1 << BH_Lock);
+	bh->b_state |= (lo_current << LOOP_BH_Set);
 
 	/*
 	 * easy way out, although it does waste some memory for < PAGE_SIZE
@@ -474,7 +500,7 @@
 	/*
 	 * piggy old buffer on original, and submit for I/O
 	 */
-	bh = loop_get_buffer(lo, rbh);
+	bh = loop_get_buffer(lo, rbh, rw);
 	bh->b_private = rbh;
 	IV = loop_get_iv(lo, bh->b_rsector);
 	if (rw == WRITE) {
@@ -519,6 +545,7 @@
 				     bh->b_size, IV);
 
 		rbh->b_end_io(rbh, !ret);
+		lo_drop(lo, (bh->b_state >> LOOP_BH_Set) & 1);
 		loop_put_buffer(bh);
 	}
 }
@@ -585,8 +612,7 @@
 	return 0;
 }
 
-static int loop_set_fd(struct loop_device *lo, struct file *lo_file, kdev_t dev,
-		       unsigned int arg)
+static int loop_change_fd(struct loop_device *lo, struct file *lo_file, kdev_t dev, unsigned int arg, int set)
 {
 	struct file	*file;
 	struct inode	*inode;
@@ -595,11 +621,18 @@
 	int		error;
 	int		bs;
 
-	MOD_INC_USE_COUNT;
+	if (set) {
+		MOD_INC_USE_COUNT;
 
-	error = -EBUSY;
-	if (lo->lo_state != Lo_unbound)
-		goto out;
+		error = -EBUSY;
+		if (lo->lo_state != Lo_unbound)
+			goto out;
+	} else {
+		/* Changing backing file is only allowed for read-only devices now.  */
+		error = -EINVAL;
+		if (lo->lo_state != Lo_bound || !(lo->lo_flags & LO_FLAGS_READ_ONLY))
+			goto out;
+	}
 	 
 	error = -EBADF;
 	file = fget(arg);
@@ -635,43 +668,85 @@
 
 	get_file(file);
 
-	if (IS_RDONLY (inode) || is_read_only(lo_device)
-	    || !(lo_file->f_mode & FMODE_WRITE))
-		lo_flags |= LO_FLAGS_READ_ONLY;
-
-	set_device_ro(dev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);
-
-	lo->lo_device = lo_device;
-	lo->lo_flags = lo_flags;
-	lo->lo_backing_file = file;
-	lo->transfer = NULL;
-	lo->ioctl = NULL;
-	figure_loop_size(lo);
-	lo->old_gfp_mask = inode->i_mapping->gfp_mask;
-	inode->i_mapping->gfp_mask = GFP_NOIO;
-
-	bs = 0;
-	if (blksize_size[MAJOR(lo_device)])
-		bs = blksize_size[MAJOR(lo_device)][MINOR(lo_device)];
-	if (!bs)
-		bs = BLOCK_SIZE;
-
-	set_blocksize(dev, bs);
-
-	lo->lo_bh = lo->lo_bhtail = NULL;
-	kernel_thread(loop_thread, lo, CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
-	down(&lo->lo_sem);
-
+	if (set) {
+		if (IS_RDONLY (inode) || is_read_only(lo_device)
+                   || !(lo_file->f_mode & FMODE_WRITE))
+                       lo_flags |= LO_FLAGS_READ_ONLY;
+
+               set_device_ro(dev, (lo_flags & LO_FLAGS_READ_ONLY)!=0);
+
+               lo->lo_current = 0;
+               lo->lo_pending_reads [0] = 0;
+               lo->lo_pending_reads [1] = 0;
+               lo->lo_device = lo_device;
+               lo->lo_flags = lo_flags;
+               lo->lo_backing_file = file;
+               lo->lo_change = NULL;
+               lo->transfer = NULL;
+               lo->ioctl = NULL;
+               figure_loop_size(lo);
+               lo->old_gfp_mask = inode->i_mapping->gfp_mask;
+               inode->i_mapping->gfp_mask = GFP_NOIO;
+
+               bs = 0;
+               if (blksize_size[MAJOR(lo_device)])
+                       bs = blksize_size[MAJOR(lo_device)][MINOR(lo_device)];
+               if (!bs)
+                       bs = BLOCK_SIZE;
+
+               lo->lo_blksize = bs;
+               set_blocksize(dev, bs);
+
+               lo->lo_bh = lo->lo_bhtail = NULL;
+               kernel_thread(loop_thread, lo, CLONE_FS | CLONE_FILES | CLONE_SIGHAND);
+               down(&lo->lo_sem);
+       } else {
+               int size = compute_loop_size(lo, file->f_dentry, lo_device);
+               struct semaphore sem;
+               kdev_t old_device;   
+               struct file *old_backing_file;
+ 
+               error = -EINVAL;
+               if (size != loop_sizes[lo->lo_number])
+                       /* Loop size has changed. Don't allow it. */
+                       goto out_put_all;
+ 
+               init_MUTEX(&sem);
+ 
+               spin_lock_irq(&lo->lo_lock);
+               if (lo->lo_pending_reads [lo->lo_current]) {
+                       lo->lo_current ^= 1;
+                       lo->lo_change = &sem;
+                       down(&sem);
+               }
+               old_device = lo->lo_device;
+               old_backing_file = lo->lo_backing_file;
+               lo->lo_device = lo_device;
+               lo->lo_backing_file = file;
+               lo->lo_flags = lo_flags | LO_FLAGS_READ_ONLY;
+               spin_unlock_irq(&lo->lo_lock);
+ 
+               /* Wait until there are no more outstanding requests to the
+                  old backing file/device */
+               down(&sem);
+               lo->lo_change = NULL;
+               fput(old_backing_file);
+               error = 0;
+       }
+  
+out_put_all:
 	fput(file);
-	return 0;
-
- out_putf:
+	return 0;  
+                      
+out_putf:
 	fput(file);
- out:
-	MOD_DEC_USE_COUNT;
+        	
+out:
+	if (set)
+		MOD_DEC_USE_COUNT;
 	return error;
 }
-
+                                              
 static int loop_release_xfer(struct loop_device *lo)
 {
 	int err = 0; 
@@ -832,7 +907,10 @@
 	down(&lo->lo_ctl_mutex);
 	switch (cmd) {
 	case LOOP_SET_FD:
-		err = loop_set_fd(lo, file, inode->i_rdev, arg);
+		err = loop_change_fd(lo, file, inode->i_rdev, arg, 1);
+		break;
+	case LOOP_CHANGE_FD:
+		err = loop_change_fd(lo, file, inode->i_rdev, arg, 0);
 		break;
 	case LOOP_CLR_FD:
 		err = loop_clr_fd(lo, inode->i_rdev);
diff -urN linux.orig/drivers/char/Config.in linux/drivers/char/Config.in
--- linux.orig/drivers/char/Config.in	Sun Aug 12 11:38:48 2001
+++ linux/drivers/char/Config.in	Mon Dec 17 20:27:40 2001
@@ -16,6 +16,9 @@
       tristate '   Dual serial port support' CONFIG_DUALSP_SERIAL
    fi
 fi
+if [ "$CONFIG_ACPI" = "y" ]; then
+   bool '  Support for serial ports defined by ACPI tables' CONFIG_SERIAL_ACPI
+fi
 dep_mbool 'Extended dumb serial driver options' CONFIG_SERIAL_EXTENDED $CONFIG_SERIAL
 if [ "$CONFIG_SERIAL_EXTENDED" = "y" ]; then
    bool '  Support more than 4 serial ports' CONFIG_SERIAL_MANY_PORTS
@@ -188,6 +191,9 @@
 dep_tristate '/dev/agpgart (AGP Support)' CONFIG_AGP $CONFIG_DRM_AGP
 if [ "$CONFIG_AGP" != "n" ]; then
    bool '  Intel 440LX/BX/GX and I815/I840/I850 support' CONFIG_AGP_INTEL
+   if [ "$CONFIG_IA64" != "n" ]; then
+   	bool '  Intel 460GX support' CONFIG_AGP_I460
+   fi
    bool '  Intel I810/I815 (on-board) support' CONFIG_AGP_I810
    bool '  VIA chipset support' CONFIG_AGP_VIA
    bool '  AMD Irongate support' CONFIG_AGP_AMD
@@ -196,7 +202,17 @@
    bool '  Serverworks LE/HE support' CONFIG_AGP_SWORKS
 fi
 
-source drivers/char/drm/Config.in
+bool 'Direct Rendering Manager (XFree86 DRI support)' CONFIG_DRM
+
+if [ "$CONFIG_DRM" = "y" ]; then
+   bool '  Build drivers for new (XFree 4.1) DRM' CONFIG_DRM_NEW
+   if [ "$CONFIG_DRM_NEW" = "y" ]; then
+      source drivers/char/drm/Config.in
+   else
+      define_bool CONFIG_DRM_OLD y
+      source drivers/char/drm-4.0/Config.in
+   fi
+fi
 
 if [ "$CONFIG_HOTPLUG" = "y" -a "$CONFIG_PCMCIA" != "n" ]; then
    source drivers/char/pcmcia/Config.in
diff -urN linux.orig/drivers/char/Makefile linux/drivers/char/Makefile
--- linux.orig/drivers/char/Makefile	Wed Jul  4 15:41:33 2001
+++ linux/drivers/char/Makefile	Mon Dec 17 20:27:40 2001
@@ -25,7 +25,7 @@
 			misc.o pty.o random.o selection.o serial.o \
 			sonypi.o tty_io.o tty_ioctl.o
 
-mod-subdirs	:=	joystick ftape drm pcmcia
+mod-subdirs	:=	joystick ftape drm pcmcia drm-4.0
 
 list-multi	:=	
 
@@ -125,6 +125,7 @@
 
 obj-$(CONFIG_VT) += vt.o vc_screen.o consolemap.o consolemap_deftbl.o $(CONSOLE) selection.o
 obj-$(CONFIG_SERIAL) += $(SERIAL)
+obj-$(CONFIG_SERIAL_ACPI) += acpi_serial.o
 obj-$(CONFIG_SERIAL_21285) += serial_21285.o
 obj-$(CONFIG_SERIAL_SA1100) += serial_sa1100.o
 obj-$(CONFIG_SERIAL_AMBA) += serial_amba.o
@@ -137,6 +138,7 @@
 
 obj-$(CONFIG_MAGIC_SYSRQ) += sysrq.o
 obj-$(CONFIG_ATARI_DSP56K) += dsp56k.o
+obj-$(CONFIG_SIM_SERIAL) += simserial.o
 obj-$(CONFIG_ROCKETPORT) += rocket.o
 obj-$(CONFIG_MOXA_SMARTIO) += mxser.o
 obj-$(CONFIG_MOXA_INTELLIO) += moxa.o
@@ -196,7 +198,8 @@
 obj-$(CONFIG_QIC02_TAPE) += tpqic02.o
 
 subdir-$(CONFIG_FTAPE) += ftape
-subdir-$(CONFIG_DRM) += drm
+subdir-$(CONFIG_DRM_NEW) += drm
+subdir-$(CONFIG_DRM_OLD) += drm-4.0
 subdir-$(CONFIG_PCMCIA) += pcmcia
 subdir-$(CONFIG_AGP) += agp
 
@@ -242,4 +245,4 @@
 consolemap_deftbl.o: consolemap_deftbl.c $(TOPDIR)/include/linux/types.h
 
 defkeymap.c: defkeymap.map
-	loadkeys --mktable defkeymap.map > defkeymap.c
+	loadkeys --mktable defkeymap.map | sed -e 's/^static *//' > defkeymap.c
diff -urN linux.orig/drivers/char/acpi_serial.c linux/drivers/char/acpi_serial.c
--- linux.orig/drivers/char/acpi_serial.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/acpi_serial.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,215 @@
+/*
+ *  linux/drivers/acpi_serial.c
+ *
+ *  Copyright (C) 2000  Hewlett-Packard Co.
+ *  Copyright (C) 2000  Khalid Aziz <khalid_aziz@hp.com>
+ *
+ *  Detect and initialize the headless console serial port defined in 
+ *  SPCR table and debug serial port defined in DBGP table
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/acpi.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <asm/serial.h>
+#include <asm/io.h>
+#include <linux/acpi_serial.h>
+/*#include <asm/acpi-ext.h>*/
+
+#undef SERIAL_DEBUG_ACPI
+#ifdef CONFIG_IA64_HP_PROTO
+int acpi_base_baud = 0;
+int acpi_autoconf_flag = ASYNC_BOOT_AUTOCONF;
+#endif
+
+/*
+ * Query ACPI tables for a debug and a headless console serial
+ * port. If found, add them to rs_table[]. A pointer to either SPCR
+ * or DBGP table is passed as parameter. This function should be called 
+ * before serial_console_init() is called to make sure the SPCR serial 
+ * console will be available for use. IA-64 kernel calls this function
+ * from within acpi.c when it encounters SPCR or DBGP tables as it parses 
+ * the ACPI 2.0 tables during bootup.
+ *
+ */
+void __init setup_serial_acpi(void *tablep) 
+{
+	acpi_ser_t *acpi_ser_p;
+	struct serial_struct serial_req;
+	unsigned long iobase;
+	int global_sys_irq;
+
+#ifdef SERIAL_DEBUG_ACPI
+	printk("Entering setup_serial_acpi()\n");
+#endif
+
+	/* Now get the table */
+	if (tablep == NULL) {
+		return;
+	}
+
+	acpi_ser_p = (acpi_ser_t *)tablep;
+
+	/*
+	 * Perform a sanity check on the table. Table should have a 
+	 * signature of "SPCR" or "DBGP" and it should be atleast 52 bytes
+	 * long.
+	 */
+	if ((strncmp(acpi_ser_p->signature, ACPI_SPCRT_SIGNATURE, 
+					ACPI_SIG_LEN) != 0) && 
+		(strncmp(acpi_ser_p->signature, ACPI_DBGPT_SIGNATURE, 
+					ACPI_SIG_LEN) != 0)) {
+		return;
+	}
+	if (acpi_ser_p->length < 52) {
+		return;
+	}
+
+	iobase = (((u64) acpi_ser_p->base_addr.addrh) << 32) | acpi_ser_p->base_addr.addrl;
+	global_sys_irq = (acpi_ser_p->global_int[3] << 24) | 
+			(acpi_ser_p->global_int[2] << 16) |
+			(acpi_ser_p->global_int[1] << 8) |
+			acpi_ser_p->global_int[0];
+
+#ifdef SERIAL_DEBUG_ACPI
+	printk("setup_serial_acpi(): table pointer = 0x%p\n", acpi_ser_p);
+	printk("                     sig = '%c%c%c%c'\n",
+			acpi_ser_p->signature[0],
+			acpi_ser_p->signature[1],
+			acpi_ser_p->signature[2],
+			acpi_ser_p->signature[3]);
+	printk("                     length = %d\n", acpi_ser_p->length);
+	printk("                     Rev = %d\n", acpi_ser_p->rev);
+	printk("                     Interface type = %d\n", acpi_ser_p->intfc_type);
+	printk("                     Base address = 0x%lX\n", iobase);
+	printk("                     IRQ = %d\n", acpi_ser_p->irq);
+	printk("                     Global System Int = %d\n", global_sys_irq);
+	printk("                     Baud rate = ");
+	switch (acpi_ser_p->baud) {
+		case ACPI_SERIAL_BAUD_9600:
+			printk("9600\n");
+			break;
+
+		case ACPI_SERIAL_BAUD_19200:
+			printk("19200\n");
+			break;
+
+		case ACPI_SERIAL_BAUD_57600:
+			printk("57600\n");
+			break;
+
+		case ACPI_SERIAL_BAUD_115200:
+			printk("115200\n");
+			break;
+
+		default:
+			printk("Huh (%d)\n", acpi_ser_p->baud);
+			break;
+
+	}
+	if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_PCICONF_SPACE) {
+		printk("                     PCI serial port:\n");
+		printk("                         Bus %d, Device %d, Vendor ID 0x%x, Dev ID 0x%x\n",
+		acpi_ser_p->pci_bus, acpi_ser_p->pci_dev,
+		acpi_ser_p->pci_vendor_id, acpi_ser_p->pci_dev_id);
+	}
+#endif
+
+	/* 
+	 * Now build a serial_req structure to update the entry in
+	 * rs_table for the headless console port.
+	 */
+	switch (acpi_ser_p->intfc_type) {
+ 		case ACPI_SERIAL_INTFC_16550:
+			serial_req.type = PORT_16550;
+			serial_req.baud_base = BASE_BAUD;
+#ifdef CONFIG_IA64_HP_PROTO
+			if (acpi_base_baud)
+				serial_req.baud_base = acpi_base_baud;
+#endif
+			break;
+
+ 		case ACPI_SERIAL_INTFC_16450:
+			serial_req.type = PORT_16450;
+			serial_req.baud_base = BASE_BAUD;
+#ifdef CONFIG_IA64_HP_PROTO
+			if (acpi_base_baud)
+				serial_req.baud_base = acpi_base_baud;
+#endif
+			break;
+
+		default:
+			serial_req.type = PORT_UNKNOWN;
+			break;
+	}
+	if (strncmp(acpi_ser_p->signature, ACPI_SPCRT_SIGNATURE,
+					ACPI_SIG_LEN) == 0) {
+		serial_req.line = ACPI_SERIAL_CONSOLE_PORT;
+	}
+	else if (strncmp(acpi_ser_p->signature, ACPI_DBGPT_SIGNATURE, 
+					ACPI_SIG_LEN) == 0) {
+		serial_req.line = ACPI_SERIAL_DEBUG_PORT;
+	}
+	/*
+	 * Check if this is an I/O mapped address or a memory mapped address
+	 */
+	if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_MEM_SPACE) {
+		serial_req.port = 0;
+		serial_req.port_high = 0;
+		serial_req.iomem_base = (void *)ioremap(iobase, 64);
+		serial_req.io_type = SERIAL_IO_MEM;
+	}
+	else if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_IO_SPACE) {
+		serial_req.port = (unsigned long) iobase & 0xffffffff;
+		serial_req.port_high = (unsigned long)(((u64)iobase) >> 32);
+		serial_req.iomem_base = NULL;
+		serial_req.io_type = SERIAL_IO_PORT;
+	}
+	else if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_PCICONF_SPACE) {
+		printk("WARNING: No support for PCI serial console\n");
+		return;
+	}
+
+#ifdef CONFIG_IA64_HP_PROTO
+	serial_req.flags = ASYNC_SKIP_TEST | acpi_autoconf_flag | ASYNC_AUTO_IRQ;
+#else
+	serial_req.flags = ASYNC_SKIP_TEST | ASYNC_BOOT_AUTOCONF | ASYNC_AUTO_IRQ;
+#endif
+
+	/*
+	 * If the table does not have IRQ information, use 0 for IRQ. 
+	 * This will force rs_init() to probe for IRQ. 
+	 */
+	if (acpi_ser_p->length < 53) {
+		serial_req.irq = 0;
+	}
+	else {
+		if (acpi_ser_p->int_type & 
+			(ACPI_SERIAL_INT_APIC | ACPI_SERIAL_INT_SAPIC)) {
+			serial_req.irq = global_sys_irq;
+		}
+		else if (acpi_ser_p->int_type & ACPI_SERIAL_INT_PCAT) {
+			serial_req.irq = acpi_ser_p->irq;
+		}
+		else {
+			serial_req.irq = 0;
+			serial_req.flags &= ~ASYNC_AUTO_IRQ;
+		}
+	}
+
+	serial_req.xmit_fifo_size = serial_req.custom_divisor = 0;
+	serial_req.close_delay = serial_req.hub6 = serial_req.closing_wait = 0;
+	serial_req.iomem_reg_shift = 0;
+	if (early_serial_setup(&serial_req) < 0) {
+		printk("early_serial_setup() for ACPI serial console port failed\n");
+		return;
+	}
+
+#ifdef SERIAL_DEBUG_ACPI
+	printk("Leaving setup_serial_acpi()\n");
+#endif
+}
diff -urN linux.orig/drivers/char/agp/agp.h linux/drivers/char/agp/agp.h
--- linux.orig/drivers/char/agp/agp.h	Wed Aug 15 02:22:15 2001
+++ linux/drivers/char/agp/agp.h	Mon Dec 17 20:27:40 2001
@@ -84,8 +84,8 @@
 	void *dev_private_data;
 	struct pci_dev *dev;
 	gatt_mask *masks;
-	unsigned long *gatt_table;
-	unsigned long *gatt_table_real;
+	u32 *gatt_table;
+	u32 *gatt_table_real;
 	unsigned long scratch_page;
 	unsigned long gart_bus_addr;
 	unsigned long gatt_bus_addr;
@@ -101,6 +101,7 @@
 	int num_aperture_sizes;
 	int num_of_masks;
 	int capndx;
+	int cant_use_aperture;
 
 	/* Links to driver specific functions */
 
@@ -110,6 +111,7 @@
 	void (*cleanup) (void);
 	void (*tlb_flush) (agp_memory *);
 	unsigned long (*mask_memory) (unsigned long, int);
+	unsigned long (*unmask_memory) (unsigned long);
 	void (*cache_flush) (void);
 	int (*create_gatt_table) (void);
 	int (*free_gatt_table) (void);
@@ -142,6 +144,10 @@
 #define A_IDXFIX()	(A_SIZE_FIX(agp_bridge.aperture_sizes) + i)
 #define MAXKEY		(4096 * 32)
 
+#ifndef max
+#define max(a,b)	(((a)>(b))?(a):(b))
+#endif
+
 #define AGPGART_MODULE_NAME	"agpgart"
 #define PFX			AGPGART_MODULE_NAME ": "
 
@@ -192,6 +198,9 @@
 #ifndef PCI_DEVICE_ID_INTEL_82443GX_1
 #define PCI_DEVICE_ID_INTEL_82443GX_1   0x71a1
 #endif
+#ifndef PCI_DEVICE_ID_INTEL_460GX
+#define PCI_DEVICE_ID_INTEL_460GX	 0x84ea
+#endif
 #ifndef PCI_DEVICE_ID_AMD_IRONGATE_0
 #define PCI_DEVICE_ID_AMD_IRONGATE_0    0x7006
 #endif
@@ -227,6 +236,15 @@
 #define INTEL_AGPCTRL   0xb0
 #define INTEL_NBXCFG    0x50
 #define INTEL_ERRSTS    0x91
+
+/* Intel 460GX Registers */
+#define INTEL_I460_APBASE		0x10
+#define INTEL_I460_BAPBASE		0x98
+#define INTEL_I460_GXBCTL		0xa0
+#define INTEL_I460_AGPSIZ		0xa2
+#define INTEL_I460_ATTBASE		0xfe200000
+#define INTEL_I460_GATT_VALID		(1UL << 24)
+#define INTEL_I460_GATT_COHERENT	(1UL << 25)
 
 /* intel i840 registers */
 #define INTEL_I840_MCHCFG   0x50
diff -urN linux.orig/drivers/char/agp/agpgart_be.c linux/drivers/char/agp/agpgart_be.c
--- linux.orig/drivers/char/agp/agpgart_be.c	Wed Aug 15 02:22:15 2001
+++ linux/drivers/char/agp/agpgart_be.c	Mon Dec 17 20:27:40 2001
@@ -22,6 +22,7 @@
  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
+ * 460GX support by Chris Ahna <christopher.j.ahna@intel.com>
  */
 #include <linux/config.h>
 #include <linux/version.h>
@@ -42,6 +43,9 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
+#include <asm/pgalloc.h>
+#include <asm/pgtable.h>
+#include <asm/smplock.h>
 
 #include <linux/agp_backend.h>
 #include "agp.h"
@@ -58,7 +62,7 @@
 EXPORT_SYMBOL(agp_backend_release);
 
 static void flush_cache(void);
-
+ 
 static struct agp_bridge_data agp_bridge;
 static int agp_try_unsupported __initdata = 0;
 
@@ -203,19 +207,56 @@
 		agp_bridge.free_by_type(curr);
 		return;
 	}
-	if (curr->page_count != 0) {
-		for (i = 0; i < curr->page_count; i++) {
-			curr->memory[i] &= ~(0x00000fff);
-			agp_bridge.agp_destroy_page((unsigned long)
-					 phys_to_virt(curr->memory[i]));
+	if(agp_bridge.cant_use_aperture == 0) {
+		if (curr->page_count != 0) {
+			for (i = 0; i < curr->page_count; i++) {
+				curr->memory[i] = agp_bridge.unmask_memory(
+					                     curr->memory[i]);
+				agp_bridge.agp_destroy_page((unsigned long)
+						 phys_to_virt(curr->memory[i]));
+			}
 		}
+	} else {
+		vfree(curr->vmptr);
 	}
+
 	agp_free_key(curr->key);
 	vfree(curr->memory);
 	kfree(curr);
 	MOD_DEC_USE_COUNT;
 }
 
+#define IN_VMALLOC(_x)	  (((_x) >= VMALLOC_START) && ((_x) < VMALLOC_END))
+
+/*
+ * Look up and return the pte corresponding to addr.  We only do this for
+ * agp_ioremap'ed addresses. 
+ */
+static pte_t * agp_lookup_pte(unsigned long addr) { 
+
+	pgd_t			*dir;
+	pmd_t			*pmd;
+	pte_t			*pte;
+
+	if(!IN_VMALLOC(addr))
+		return NULL;
+
+	dir = pgd_offset_k(addr);
+	pmd = pmd_offset(dir, addr);
+
+	if(pmd) {
+		pte = pte_offset(pmd, addr);
+
+		if(pte) {
+			return pte;
+		} else {
+			return NULL;
+		}
+	} else {
+		return NULL;
+	}
+}
+
 #define ENTRIES_PER_PAGE		(PAGE_SIZE / sizeof(unsigned long))
 
 agp_memory *agp_allocate_memory(size_t page_count, u32 type)
@@ -245,24 +286,60 @@
 	scratch_pages = (page_count + ENTRIES_PER_PAGE - 1) / ENTRIES_PER_PAGE;
 
 	new = agp_create_memory(scratch_pages);
-
 	if (new == NULL) {
 	      	MOD_DEC_USE_COUNT;
 		return NULL;
 	}
-	for (i = 0; i < page_count; i++) {
-		new->memory[i] = agp_bridge.agp_alloc_page();
 
-		if (new->memory[i] == 0) {
-			/* Free this structure */
-			agp_free_memory(new);
+	if(agp_bridge.cant_use_aperture == 0) {
+		for (i = 0; i < page_count; i++) {
+			new->memory[i] = agp_bridge.agp_alloc_page();
+
+			if (new->memory[i] == 0) {
+				/* Free this structure */
+				agp_free_memory(new);
+				return NULL;
+			}
+			new->memory[i] =
+			    agp_bridge.mask_memory(
+					  virt_to_phys((void *) new->memory[i]),
+							  type);
+			new->page_count++;
+		}
+	} else {
+		void *vmblock;
+		unsigned long vaddr, paddr;
+		pte_t *pte;
+
+		vmblock = __vmalloc(page_count << PAGE_SHIFT, GFP_KERNEL,
+#ifdef __ia64__
+					pgprot_writecombine(PAGE_KERNEL));
+#else
+					PAGE_KERNEL);
+#endif
+		if(vmblock == NULL) {
+			MOD_DEC_USE_COUNT;
 			return NULL;
 		}
-		new->memory[i] =
-		    agp_bridge.mask_memory(
-				   virt_to_phys((void *) new->memory[i]),
-						  type);
-		new->page_count++;
+
+		new->vmptr = vmblock;
+		vaddr = (unsigned long) vmblock;
+
+		for(i = 0; i < page_count; i++, vaddr += PAGE_SIZE) {
+			pte = agp_lookup_pte(vaddr);
+			if(pte == NULL) {
+				MOD_DEC_USE_COUNT;
+				return NULL;
+			}
+#ifdef __ia64__
+			paddr = pte_val(*pte) & _PFN_MASK;
+#else
+			paddr = pte_val(*pte) & PAGE_MASK;
+#endif
+			new->memory[i] = agp_bridge.mask_memory(paddr, type);
+		}
+
+		new->page_count = page_count;
 	}
 
 	return new;
@@ -305,6 +382,9 @@
 
 void agp_copy_info(agp_kern_info * info)
 {
+	unsigned long page_mask = 0;
+	int i;
+
 	memset(info, 0, sizeof(agp_kern_info));
 	if (agp_bridge.type == NOT_SUPPORTED) {
 		info->chipset = agp_bridge.type;
@@ -319,6 +399,12 @@
 	info->aper_size = agp_return_size();
 	info->max_memory = agp_bridge.max_memory_agp;
 	info->current_memory = atomic_read(&agp_bridge.current_memory_agp);
+	info->cant_use_aperture = agp_bridge.cant_use_aperture;
+
+	for(i = 0; i < agp_bridge.num_of_masks; i++)
+		page_mask |= agp_bridge.mask_memory(page_mask, i);
+
+	info->page_mask = ~page_mask;
 }
 
 /* End - Routine to copy over information structure */
@@ -342,12 +428,13 @@
 		curr->is_flushed = TRUE;
 	}
 	ret_val = agp_bridge.insert_memory(curr, pg_start, curr->type);
-
+		
 	if (ret_val != 0) {
 		return ret_val;
 	}
 	curr->is_bound = TRUE;
 	curr->pg_start = pg_start;
+
 	return 0;
 }
 
@@ -366,6 +453,7 @@
 	if (ret_val != 0) {
 		return ret_val;
 	}
+
 	curr->is_bound = FALSE;
 	curr->pg_start = 0;
 	return 0;
@@ -376,7 +464,7 @@
 /* 
  * Driver routines - start
  * Currently this module supports the following chipsets:
- * i810, 440lx, 440bx, 440gx, i840, i850, via vp3, via mvp3, via kx133, 
+ * i810, 440lx, 440bx, 440gx, 460gx, i840, i850, via vp3, via mvp3, via kx133, 
  * via kt133, amd irongate, ALi M1541, and generic support for the SiS 
  * chipsets.
  */
@@ -603,7 +691,7 @@
 	for (page = virt_to_page(table); page <= virt_to_page(table_end); page++)
 		set_bit(PG_reserved, &page->flags);
 
-	agp_bridge.gatt_table_real = (unsigned long *) table;
+	agp_bridge.gatt_table_real = (u32 *) table;
 	CACHE_FLUSH();
 	agp_bridge.gatt_table = ioremap_nocache(virt_to_phys(table),
 					(PAGE_SIZE * (1 << page_order)));
@@ -809,6 +897,11 @@
 	agp_bridge.agp_enable(mode);
 }
 
+static unsigned long agp_generic_unmask_memory(unsigned long addr)
+{
+	return addr & ~(0x00000fff);
+}
+
 /* End - Generic Agp routines */
 
 #ifdef CONFIG_AGP_I810
@@ -1073,6 +1166,7 @@
 	agp_bridge.cleanup = intel_i810_cleanup;
 	agp_bridge.tlb_flush = intel_i810_tlbflush;
 	agp_bridge.mask_memory = intel_i810_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = intel_i810_agp_enable;
 	agp_bridge.cache_flush = global_cache_flush;
 	agp_bridge.create_gatt_table = agp_generic_create_gatt_table;
@@ -1083,12 +1177,673 @@
 	agp_bridge.free_by_type = intel_i810_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 }
 
 #endif /* CONFIG_AGP_I810 */
 
+#ifdef CONFIG_AGP_I460
+
+/* BIOS configures the chipset so that one of two apbase registers are used */
+static u8 intel_i460_dynamic_apbase = 0x10;
+
+/* 460 supports multiple GART page sizes, so GART pageshift is dynamic */ 
+static u8 intel_i460_pageshift = 12;
+
+/* To speed mmap fixups, track the last entry used in the GATT. */
+static u32 intel_i460_tog = 0;
+
+/* Keep track of which is larger, chipset or kernel page size. */
+static u32 intel_i460_cpk = 1;
+
+/* Structure for tracking partial use of 4MB GART pages */
+static u32 **i460_pg_detail = NULL;
+static u32 *i460_pg_count = NULL;
+
+#define I460_CPAGES_PER_KPAGE (PAGE_SIZE >> intel_i460_pageshift)
+#define I460_KPAGES_PER_CPAGE ((1 << intel_i460_pageshift) >> PAGE_SHIFT)
+
+#define I460_SRAM_IO_DISABLE		(1 << 4)
+#define I460_BAPBASE_ENABLE		(1 << 3)
+#define I460_AGPSIZ_MASK		0x7
+#define I460_4M_PS			(1 << 1)
+
+#define log2(x)				ffz(~(x))
+
+static int intel_i460_fetch_size(void)
+{
+	int i;
+	u8 temp;
+	aper_size_info_8 *values;
+
+	/* Determine the GART page size */
+	pci_read_config_byte(agp_bridge.dev, INTEL_I460_GXBCTL, &temp);
+	intel_i460_pageshift = (temp & I460_4M_PS) ? 22 : 12;
+
+	values = A_SIZE_8(agp_bridge.aperture_sizes);
+
+	pci_read_config_byte(agp_bridge.dev, INTEL_I460_AGPSIZ, &temp);
+
+	/* Exit now if the IO drivers for the GART SRAMS are turned off */
+	if(temp & I460_SRAM_IO_DISABLE) {
+		printk("[agpgart] GART SRAMS disabled on 460GX chipset\n");
+		printk("[agpgart] AGPGART operation not possible\n");
+		return 0;
+	}
+
+	/* Make sure we don't try to create an 2 ^ 23 entry GATT */
+	if((intel_i460_pageshift == 0) && ((temp & I460_AGPSIZ_MASK) == 4)) {
+		printk("[agpgart] We can't have a 32GB aperture with 4KB"
+			" GART pages\n");
+		return 0;
+	}
+
+	/* Determine the proper APBASE register */
+	if(temp & I460_BAPBASE_ENABLE)
+		intel_i460_dynamic_apbase = INTEL_I460_BAPBASE;
+	else intel_i460_dynamic_apbase = INTEL_I460_APBASE;
+
+	for (i = 0; i < agp_bridge.num_aperture_sizes; i++) {
+
+		/*
+		 * Dynamically calculate the proper num_entries and page_order 
+		 * values for the define aperture sizes. Take care not to
+		 * shift off the end of values[i].size.
+		 */	
+		values[i].num_entries = (values[i].size << 8) >>
+						(intel_i460_pageshift - 12);
+		values[i].page_order = log2((sizeof(u32)*values[i].num_entries)
+						>> PAGE_SHIFT);
+	}
+
+	for (i = 0; i < agp_bridge.num_aperture_sizes; i++) {
+		/* Neglect control bits when matching up size_value */
+		if ((temp & I460_AGPSIZ_MASK) == values[i].size_value) {
+			agp_bridge.previous_size =
+			    agp_bridge.current_size = (void *) (values + i);
+			agp_bridge.aperture_size_idx = i;
+			return values[i].size;
+		}
+	}
+
+	return 0;
+}
+
+/* There isn't anything to do here since 460 has no GART TLB. */ 
+static void intel_i460_tlb_flush(agp_memory * mem)
+{
+	return;
+}
+
+/*
+ * This utility function is needed to prevent corruption of the control bits
+ * which are stored along with the aperture size in 460's AGPSIZ register
+ */
+static void intel_i460_write_agpsiz(u8 size_value)
+{
+	u8 temp;
+
+	pci_read_config_byte(agp_bridge.dev, INTEL_I460_AGPSIZ, &temp);
+	pci_write_config_byte(agp_bridge.dev, INTEL_I460_AGPSIZ,
+		((temp & ~I460_AGPSIZ_MASK) | size_value));
+}
+
+static void intel_i460_cleanup(void)
+{
+	aper_size_info_8 *previous_size;
+
+	previous_size = A_SIZE_8(agp_bridge.previous_size);
+	intel_i460_write_agpsiz(previous_size->size_value);
+
+	if(intel_i460_cpk == 0)
+	{
+		vfree(i460_pg_detail);
+		vfree(i460_pg_count);
+	}
+}
+
+
+/* Control bits for Out-Of-GART coherency and Burst Write Combining */
+#define I460_GXBCTL_OOG		(1UL << 0)
+#define I460_GXBCTL_BWC		(1UL << 2)
+
+static int intel_i460_configure(void)
+{
+	union {
+		u32 small[2];
+		u64 large;
+	} temp;
+	u8 scratch;
+	int i;
+
+	aper_size_info_8 *current_size;
+
+	temp.large = 0;
+
+	current_size = A_SIZE_8(agp_bridge.current_size);
+	intel_i460_write_agpsiz(current_size->size_value);	
+
+	/*
+	 * Do the necessary rigmarole to read all eight bytes of APBASE.
+	 * This has to be done since the AGP aperture can be above 4GB on
+	 * 460 based systems.
+	 */
+	pci_read_config_dword(agp_bridge.dev, intel_i460_dynamic_apbase, 
+		&(temp.small[0]));
+	pci_read_config_dword(agp_bridge.dev, intel_i460_dynamic_apbase + 4,
+		&(temp.small[1]));
+
+	/* Clear BAR control bits */
+	agp_bridge.gart_bus_addr = temp.large & ~((1UL << 3) - 1); 
+
+	pci_read_config_byte(agp_bridge.dev, INTEL_I460_GXBCTL, &scratch);
+	pci_write_config_byte(agp_bridge.dev, INTEL_I460_GXBCTL,
+			  (scratch & 0x02) | I460_GXBCTL_OOG | I460_GXBCTL_BWC);
+
+	/* 
+	 * Initialize partial allocation trackers if a GART page is bigger than
+	 * a kernel page.
+	 */
+	if(I460_CPAGES_PER_KPAGE >= 1) {
+		intel_i460_cpk = 1;
+	} else {
+		intel_i460_cpk = 0;
+
+		i460_pg_detail = (void *) vmalloc(sizeof(*i460_pg_detail) *
+					current_size->num_entries);
+		i460_pg_count = (void *) vmalloc(sizeof(*i460_pg_count) *
+					current_size->num_entries);
+	
+		for (i = 0; i < current_size->num_entries; i++) {
+			i460_pg_count[i] = 0;
+			i460_pg_detail[i] = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int intel_i460_create_gatt_table(void) {
+
+	char *table;
+	int i;
+	int page_order;
+	int num_entries;
+	void *temp;
+	unsigned int read_back;
+
+	/*
+	 * Load up the fixed address of the GART SRAMS which hold our
+	 * GATT table.
+	 */
+	table = (char *) __va(INTEL_I460_ATTBASE);
+
+	temp = agp_bridge.current_size;
+	page_order = A_SIZE_8(temp)->page_order;
+	num_entries = A_SIZE_8(temp)->num_entries;
+
+	agp_bridge.gatt_table_real = (u32 *) table;
+	agp_bridge.gatt_table = ioremap_nocache(virt_to_phys(table),
+		 			     (PAGE_SIZE * (1 << page_order)));
+	agp_bridge.gatt_bus_addr = virt_to_phys(agp_bridge.gatt_table_real);
+
+	for (i = 0; i < num_entries; i++) {
+		agp_bridge.gatt_table[i] = 0;
+	}
+
+	/* 
+	 * The 460 spec says we have to read the last location written to 
+	 * make sure that all writes have taken effect
+	 */
+	read_back = agp_bridge.gatt_table[i - 1];
+
+	/* Set the Top-Of-GATT to 0 */
+	intel_i460_tog = 0;
+
+	return 0;
+}
+
+static int intel_i460_free_gatt_table(void)
+{
+	int num_entries;
+	int i;
+	void *temp;
+	unsigned int read_back;
+
+	temp = agp_bridge.current_size;
+
+	num_entries = A_SIZE_8(temp)->num_entries;
+
+	for (i = 0; i < num_entries; i++) {
+		agp_bridge.gatt_table[i] = 0;
+	}
+	
+	/* 
+	 * The 460 spec says we have to read the last location written to 
+	 * make sure that all writes have taken effect
+	 */
+	read_back = agp_bridge.gatt_table[i - 1];
+
+	iounmap(agp_bridge.gatt_table);
+	intel_i460_tog = 0;
+
+	return 0;
+}
+
+/*
+ * When the Top-Of-GATT is cleared, this routine is called to roll tog back
+ * to point to the last valid GATT entry. This code is needed to traverse
+ * unused portions of the GATT, since we don't know about such gaps in
+ * intel_i460_remove_memory. 
+ */
+static void intel_i460_rollback_tog(void) {
+
+	while(intel_i460_tog > 0) {
+		
+		if(agp_bridge.gatt_table[intel_i460_tog - 1] &
+		      		INTEL_I460_GATT_VALID)
+			return;
+
+		intel_i460_tog--;
+	}
+}
+
+/* These functions are called when PAGE_SIZE exceeds the GART page size */	
+
+static int intel_i460_insert_memory_cpk(agp_memory * mem,
+				     off_t pg_start, int type)
+{
+	int i, j, k, num_entries;
+	void *temp;
+	unsigned int hold;
+	unsigned int read_back;
+
+	/* 
+	 * The rest of the kernel will compute page offsets in terms of
+	 * PAGE_SIZE.
+	 */
+	pg_start = I460_CPAGES_PER_KPAGE * pg_start;
+
+	temp = agp_bridge.current_size;
+	num_entries = A_SIZE_8(temp)->num_entries;
+
+	if((pg_start + I460_CPAGES_PER_KPAGE * mem->page_count) > num_entries) {
+		printk("[agpgart] Looks like we're out of AGP memory\n");
+		return -EINVAL;
+	}
+
+	j = pg_start;
+	while (j < (pg_start + I460_CPAGES_PER_KPAGE * mem->page_count)) {
+		if (!PGE_EMPTY(agp_bridge.gatt_table[j])) {
+			return -EBUSY;
+		}
+		j++;
+	}
+
+	if (mem->is_flushed == FALSE) {
+		CACHE_FLUSH();
+		mem->is_flushed = TRUE;
+	}
+
+	for (i = 0, j = pg_start; i < mem->page_count; i++) {
+
+		hold = (unsigned int) (mem->memory[i]);
+
+		for (k = 0; k < I460_CPAGES_PER_KPAGE; k++, j++, hold++)
+			agp_bridge.gatt_table[j] = hold;
+	}
+
+	/* 
+	 * The 460 spec says we have to read the last location written to 
+	 * make sure that all writes have taken effect
+	 */
+	read_back = agp_bridge.gatt_table[j - 1];
+
+	if(j > intel_i460_tog)
+		intel_i460_tog = j;
+
+	return 0;
+}
+
+static int intel_i460_remove_memory_cpk(agp_memory * mem, off_t pg_start,
+				     int type)
+{
+	int i;
+	unsigned int read_back;
+
+	pg_start = I460_CPAGES_PER_KPAGE * pg_start;
+
+	for (i = pg_start; i < (pg_start + I460_CPAGES_PER_KPAGE * 
+							mem->page_count); i++) 
+		agp_bridge.gatt_table[i] = 0;
+
+	/* 
+	 * The 460 spec says we have to read the last location written to 
+	 * make sure that all writes have taken effect
+	 */
+	read_back = agp_bridge.gatt_table[i - 1];
+
+	if(i == intel_i460_tog)
+		intel_i460_rollback_tog();
+
+	return 0;
+}
+
+/*
+ * These functions are called when the GART page size exceeds PAGE_SIZE.
+ *
+ * This situation is interesting since AGP memory allocations that are
+ * smaller than a single GART page are possible.  The structures i460_pg_count
+ * and i460_pg_detail track partial allocation of the large GART pages to
+ * work around this issue.
+ *
+ * i460_pg_count[pg_num] tracks the number of kernel pages in use within
+ * GART page pg_num.  i460_pg_detail[pg_num] is an array containing a
+ * psuedo-GART entry for each of the aforementioned kernel pages.  The whole
+ * of i460_pg_detail is equivalent to a giant GATT with page size equal to
+ * that of the kernel.
+ */	
+
+static void *intel_i460_alloc_large_page(int pg_num)
+{
+	int i;
+	void *bp, *bp_end;
+	struct page *page;
+
+	i460_pg_detail[pg_num] = (void *) vmalloc(sizeof(u32) * 
+							I460_KPAGES_PER_CPAGE);
+	if(i460_pg_detail[pg_num] == NULL) {
+		printk("[agpgart] Out of memory, we're in trouble...\n");
+		return NULL;
+	}
+
+	for(i = 0; i < I460_KPAGES_PER_CPAGE; i++)
+		i460_pg_detail[pg_num][i] = 0;
+
+	bp = (void *) __get_free_pages(GFP_KERNEL, 
+					intel_i460_pageshift - PAGE_SHIFT);
+	if(bp == NULL) {
+		printk("[agpgart] Couldn't alloc 4M GART page...\n");
+		return NULL;
+	}
+
+	bp_end = bp + ((PAGE_SIZE * 
+			    (1 << (intel_i460_pageshift - PAGE_SHIFT))) - 1);
+
+	for (page = virt_to_page(bp); page <= virt_to_page(bp_end); page++)
+	{
+		atomic_inc(&page->count);
+		set_bit(PG_locked, &page->flags);
+		atomic_inc(&agp_bridge.current_memory_agp);
+	}
+
+	return bp;		
+}
+
+static void intel_i460_free_large_page(int pg_num, unsigned long addr)
+{
+	struct page *page;
+	void *bp, *bp_end;
+
+	bp = (void *) __va(addr);
+	bp_end = bp + (PAGE_SIZE * 
+			(1 << (intel_i460_pageshift - PAGE_SHIFT)));
+
+	vfree(i460_pg_detail[pg_num]);
+	i460_pg_detail[pg_num] = NULL;
+
+	for (page = virt_to_page(bp); page < virt_to_page(bp_end); page++)
+	{
+		atomic_dec(&page->count);
+		clear_bit(PG_locked, &page->flags);
+		wake_up(&page->wait);
+		atomic_dec(&agp_bridge.current_memory_agp);
+	}
+
+	free_pages((unsigned long) bp, intel_i460_pageshift - PAGE_SHIFT);
+}
+	
+static int intel_i460_insert_memory_kpc(agp_memory * mem,
+				     off_t pg_start, int type)
+{
+	int i, pg, start_pg, end_pg, start_offset, end_offset, idx;
+	int num_entries;	
+	void *temp;
+	unsigned int read_back;
+
+	temp = agp_bridge.current_size;
+	num_entries = A_SIZE_8(temp)->num_entries;
+
+	/* Figure out what pg_start means in terms of our large GART pages */
+	start_pg 	= pg_start / I460_KPAGES_PER_CPAGE;
+	start_offset 	= pg_start % I460_KPAGES_PER_CPAGE;
+	end_pg 		= (pg_start + mem->page_count - 1) / 
+							I460_KPAGES_PER_CPAGE;
+	end_offset 	= (pg_start + mem->page_count - 1) % 
+							I460_KPAGES_PER_CPAGE;
+
+	if(end_pg > num_entries)
+	{
+		printk("[agpgart] Looks like we're out of AGP memory\n");
+		return -EINVAL;
+	}
+
+	/* Check if the requested region of the aperture is free */
+	for(pg = start_pg; pg <= end_pg; pg++)
+	{
+		/* Allocate new GART pages if necessary */
+		if(i460_pg_detail[pg] == NULL) {
+			temp = intel_i460_alloc_large_page(pg);
+			if(temp == NULL)
+				return -ENOMEM;
+			agp_bridge.gatt_table[pg] = agp_bridge.mask_memory(
+			    			       (unsigned long) temp, 0);
+			read_back = agp_bridge.gatt_table[pg];
+		}
+
+		for(idx = ((pg == start_pg) ? start_offset : 0);
+		    idx < ((pg == end_pg) ? (end_offset + 1) 
+				       : I460_KPAGES_PER_CPAGE);
+		    idx++) 
+		{
+			if(i460_pg_detail[pg][idx] != 0)
+				return -EBUSY;
+		}
+	}
+		
+	if (mem->is_flushed == FALSE) {
+		CACHE_FLUSH();
+		mem->is_flushed = TRUE;
+	}
+
+	for(pg = start_pg, i = 0; pg <= end_pg; pg++)
+	{
+		for(idx = ((pg == start_pg) ? start_offset : 0);
+		    idx < ((pg == end_pg) ? (end_offset + 1)
+				       : I460_KPAGES_PER_CPAGE);
+		    idx++, i++)
+		{
+			i460_pg_detail[pg][idx] = agp_bridge.gatt_table[pg] + 
+						      ((idx * PAGE_SIZE) >> 12);
+			i460_pg_count[pg]++;
+
+			/* Finally we fill in mem->memory... */
+			mem->memory[i] = ((unsigned long) (0xffffff & 
+						i460_pg_detail[pg][idx])) << 12;
+		}
+	}
+
+	if(end_pg > intel_i460_tog)
+		intel_i460_tog = end_pg + 1;
+
+	return 0;
+}
+	
+static int intel_i460_remove_memory_kpc(agp_memory * mem,
+				     off_t pg_start, int type)
+{
+	int i, pg, start_pg, end_pg, start_offset, end_offset, idx;
+	int num_entries;
+	void *temp;
+	unsigned int read_back;
+	unsigned long addr;
+
+	temp = agp_bridge.current_size;
+	num_entries = A_SIZE_8(temp)->num_entries;
+
+	/* Figure out what pg_start means in terms of our large GART pages */
+	start_pg 	= pg_start / I460_KPAGES_PER_CPAGE;
+	start_offset 	= pg_start % I460_KPAGES_PER_CPAGE;
+	end_pg 		= (pg_start + mem->page_count - 1) / 
+						I460_KPAGES_PER_CPAGE;
+	end_offset 	= (pg_start + mem->page_count - 1) % 
+						I460_KPAGES_PER_CPAGE;
+
+	for(i = 0, pg = start_pg; pg <= end_pg; pg++)
+	{
+		for(idx = ((pg == start_pg) ? start_offset : 0);
+		    idx < ((pg == end_pg) ? (end_offset + 1)
+				       : I460_KPAGES_PER_CPAGE);
+		    idx++, i++) 
+		{
+			mem->memory[i] = 0;
+			i460_pg_detail[pg][idx] = 0;
+			i460_pg_count[pg]--;
+		}
+
+		/* Free GART pages if they are unused */
+		if(i460_pg_count[pg] == 0) {
+			addr = (0xffffffUL & (unsigned long) 
+					     (agp_bridge.gatt_table[pg])) << 12;
+
+			agp_bridge.gatt_table[pg] = 0;
+			read_back = agp_bridge.gatt_table[pg];
+
+			intel_i460_free_large_page(pg, addr);
+		}
+	}
+		
+	if(end_pg == intel_i460_tog - 1)
+		intel_i460_rollback_tog();
+
+	return 0;
+}
+
+/* Dummy routines to call the approriate {cpk,kpc} function */
+
+static int intel_i460_insert_memory(agp_memory * mem,
+				     off_t pg_start, int type)
+{
+	if(intel_i460_cpk)
+		return intel_i460_insert_memory_cpk(mem, pg_start, type);
+	else
+		return intel_i460_insert_memory_kpc(mem, pg_start, type);
+}
+
+static int intel_i460_remove_memory(agp_memory * mem,
+				     off_t pg_start, int type)
+{
+	if(intel_i460_cpk)
+		return intel_i460_remove_memory_cpk(mem, pg_start, type);
+	else
+		return intel_i460_remove_memory_kpc(mem, pg_start, type);
+}
+
+/*
+ * If the kernel page size is smaller that the chipset page size, we don't
+ * want to allocate memory until we know where it is to be bound in the
+ * aperture (a multi-kernel-page alloc might fit inside of an already
+ * allocated GART page).  Consequently, don't allocate or free anything
+ * if i460_cpk (meaning chipset pages per kernel page) isn't set.
+ *
+ * Let's just hope nobody counts on the allocated AGP memory being there
+ * before bind time (I don't think current drivers do)...
+ */ 
+static unsigned long intel_i460_alloc_page(void)
+{
+	if(intel_i460_cpk)
+		return agp_generic_alloc_page();
+
+	/* Returning NULL would cause problems */
+	return ((unsigned long) ~0UL);
+}
+
+static void intel_i460_destroy_page(unsigned long page)
+{
+	if(intel_i460_cpk)
+		agp_generic_destroy_page(page);
+}
+
+static gatt_mask intel_i460_masks[] =
+{
+	{ 
+	  INTEL_I460_GATT_VALID, 
+	  0
+	}
+};
+
+static unsigned long intel_i460_mask_memory(unsigned long addr, int type) 
+{
+	/* Make sure the returned address is a valid GATT entry */
+	return (agp_bridge.masks[0].mask | (((addr & 
+		     ~((1 << intel_i460_pageshift) - 1)) & 0xffffff000) >> 12));
+}
+
+static unsigned long intel_i460_unmask_memory(unsigned long addr)
+{
+	/* Turn a GATT entry into a physical address */
+	return ((addr & 0xffffff) << 12);
+}
+
+static aper_size_info_8 intel_i460_sizes[3] =
+{
+	/* 
+	 * The 32GB aperture is only available with a 4M GART page size.
+	 * Due to the dynamic GART page size, we can't figure out page_order
+	 * or num_entries until runtime.
+	 */
+	{32768, 0, 0, 4},
+	{1024, 0, 0, 2},
+	{256, 0, 0, 1}
+};
+
+static int __init intel_i460_setup (struct pci_dev *pdev)
+{
+
+        agp_bridge.masks = intel_i460_masks;
+        agp_bridge.num_of_masks = 1;
+        agp_bridge.aperture_sizes = (void *) intel_i460_sizes;
+        agp_bridge.size_type = U8_APER_SIZE;
+        agp_bridge.num_aperture_sizes = 3;
+        agp_bridge.dev_private_data = NULL;
+        agp_bridge.needs_scratch_page = FALSE;
+        agp_bridge.configure = intel_i460_configure;
+        agp_bridge.fetch_size = intel_i460_fetch_size;
+        agp_bridge.cleanup = intel_i460_cleanup;
+        agp_bridge.tlb_flush = intel_i460_tlb_flush;
+        agp_bridge.mask_memory = intel_i460_mask_memory;
+        agp_bridge.unmask_memory = intel_i460_unmask_memory;
+        agp_bridge.agp_enable = agp_generic_agp_enable;
+        agp_bridge.cache_flush = global_cache_flush;
+        agp_bridge.create_gatt_table = intel_i460_create_gatt_table;
+        agp_bridge.free_gatt_table = intel_i460_free_gatt_table;
+        agp_bridge.insert_memory = intel_i460_insert_memory;
+        agp_bridge.remove_memory = intel_i460_remove_memory;
+        agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
+        agp_bridge.free_by_type = agp_generic_free_by_type;
+        agp_bridge.agp_alloc_page = intel_i460_alloc_page;
+        agp_bridge.agp_destroy_page = intel_i460_destroy_page;
+	agp_bridge.cant_use_aperture = 1;
+
+        return 0;
+
+        (void) pdev; /* unused */
+}
+
+#endif		/* CONFIG_AGP_I460 */
+
 #ifdef CONFIG_AGP_INTEL
 
 static int intel_fetch_size(void)
@@ -1265,6 +2020,7 @@
 	agp_bridge.cleanup = intel_cleanup;
 	agp_bridge.tlb_flush = intel_tlbflush;
 	agp_bridge.mask_memory = intel_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = agp_generic_agp_enable;
 	agp_bridge.cache_flush = global_cache_flush;
 	agp_bridge.create_gatt_table = agp_generic_create_gatt_table;
@@ -1275,6 +2031,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 	
@@ -1295,6 +2052,7 @@
 	agp_bridge.cleanup = intel_cleanup;
 	agp_bridge.tlb_flush = intel_tlbflush;
 	agp_bridge.mask_memory = intel_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = agp_generic_agp_enable;
 	agp_bridge.cache_flush = global_cache_flush;
 	agp_bridge.create_gatt_table = agp_generic_create_gatt_table;
@@ -1305,6 +2063,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 	
@@ -1325,6 +2084,7 @@
 	agp_bridge.cleanup = intel_cleanup;
 	agp_bridge.tlb_flush = intel_tlbflush;
 	agp_bridge.mask_memory = intel_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = agp_generic_agp_enable;
 	agp_bridge.cache_flush = global_cache_flush;
 	agp_bridge.create_gatt_table = agp_generic_create_gatt_table;
@@ -1335,6 +2095,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 	
@@ -1442,6 +2203,7 @@
 	agp_bridge.cleanup = via_cleanup;
 	agp_bridge.tlb_flush = via_tlbflush;
 	agp_bridge.mask_memory = via_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = agp_generic_agp_enable;
 	agp_bridge.cache_flush = global_cache_flush;
 	agp_bridge.create_gatt_table = agp_generic_create_gatt_table;
@@ -1452,6 +2214,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 	
@@ -1553,6 +2316,7 @@
 	agp_bridge.cleanup = sis_cleanup;
 	agp_bridge.tlb_flush = sis_tlbflush;
 	agp_bridge.mask_memory = sis_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = agp_generic_agp_enable;
 	agp_bridge.cache_flush = global_cache_flush;
 	agp_bridge.create_gatt_table = agp_generic_create_gatt_table;
@@ -1563,6 +2327,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 }
@@ -1572,8 +2337,8 @@
 #ifdef CONFIG_AGP_AMD
 
 typedef struct _amd_page_map {
-	unsigned long *real;
-	unsigned long *remapped;
+	u32 *real;
+	u32 *remapped;
 } amd_page_map;
 
 static struct _amd_irongate_private {
@@ -1586,7 +2351,7 @@
 {
 	int i;
 
-	page_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);
+	page_map->real = (u32 *) __get_free_page(GFP_KERNEL);
 	if (page_map->real == NULL) {
 		return -ENOMEM;
 	}
@@ -1841,7 +2606,7 @@
 			     off_t pg_start, int type)
 {
 	int i, j, num_entries;
-	unsigned long *cur_gatt;
+	u32 *cur_gatt;
 	unsigned long addr;
 
 	num_entries = A_SIZE_LVL2(agp_bridge.current_size)->num_entries;
@@ -1881,7 +2646,7 @@
 			     int type)
 {
 	int i;
-	unsigned long *cur_gatt;
+	u32 *cur_gatt;
 	unsigned long addr;
 
 	if (type != 0 || mem->type != 0) {
@@ -1928,6 +2693,7 @@
 	agp_bridge.cleanup = amd_irongate_cleanup;
 	agp_bridge.tlb_flush = amd_irongate_tlbflush;
 	agp_bridge.mask_memory = amd_irongate_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = agp_generic_agp_enable;
 	agp_bridge.cache_flush = global_cache_flush;
 	agp_bridge.create_gatt_table = amd_create_gatt_table;
@@ -1938,6 +2704,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 	
@@ -2171,6 +2938,7 @@
 	agp_bridge.cleanup = ali_cleanup;
 	agp_bridge.tlb_flush = ali_tlbflush;
 	agp_bridge.mask_memory = ali_mask_memory;
+	agp_bridge.unmask_memory = agp_generic_unmask_memory;
 	agp_bridge.agp_enable = agp_generic_agp_enable;
 	agp_bridge.cache_flush = ali_cache_flush;
 	agp_bridge.create_gatt_table = agp_generic_create_gatt_table;
@@ -2181,6 +2949,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = ali_alloc_page;
 	agp_bridge.agp_destroy_page = ali_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	return 0;
 	
@@ -2766,6 +3535,7 @@
 	agp_bridge.free_by_type = agp_generic_free_by_type;
 	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
 	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 0;
 
 	pci_read_config_dword(agp_bridge.dev,
 			      SVWRKS_APSIZE,
@@ -2931,6 +3701,15 @@
 		intel_generic_setup },
 #endif /* CONFIG_AGP_INTEL */
 
+#ifdef CONFIG_AGP_I460
+	{ PCI_DEVICE_ID_INTEL_460GX,
+		PCI_VENDOR_ID_INTEL,
+		INTEL_460GX,
+		"Intel",
+		"460GX",
+		intel_i460_setup },
+#endif
+
 #ifdef CONFIG_AGP_SIS
 	{ PCI_DEVICE_ID_SI_630,
 		PCI_VENDOR_ID_SI,
@@ -3111,6 +3890,18 @@
 	return -ENODEV;
 }
 
+static int agp_check_supported_device(struct pci_dev *dev) {
+
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE (agp_bridge_info); i++) {
+		if(dev->vendor == agp_bridge_info[i].vendor_id &&
+		   dev->device == agp_bridge_info[i].device_id)
+			return 1;
+	}
+
+	return 0;
+}
 
 /* Supported Device Scanning routine */
 
@@ -3120,8 +3911,14 @@
 	u8 cap_ptr = 0x00;
 	u32 cap_id, scratch;
 
-	if ((dev = pci_find_class(PCI_CLASS_BRIDGE_HOST << 8, NULL)) == NULL)
-		return -ENODEV;
+	/* 
+	 * Some systems have multiple host bridges (i.e. BigSur), so
+	 * we can't just use the first one we find.
+	 */
+	do {
+		if ((dev = pci_find_class(PCI_CLASS_BRIDGE_HOST << 8, dev)) == NULL)
+			return -ENODEV;
+	} while(!agp_check_supported_device(dev));
 
 	agp_bridge.dev = dev;
 
@@ -3349,7 +4146,7 @@
 	size_value = agp_bridge.fetch_size();
 
 	if (size_value == 0) {
-		printk(KERN_ERR PFX "unable to detrimine aperture size.\n");
+		printk(KERN_ERR PFX "unable to determine aperture size.\n");
 		rc = -EINVAL;
 		goto err_out;
 	}
diff -urN linux.orig/drivers/char/drm/Config.in linux/drivers/char/drm/Config.in
--- linux.orig/drivers/char/drm/Config.in	Wed Aug  8 10:42:10 2001
+++ linux/drivers/char/drm/Config.in	Mon Dec 17 20:27:40 2001
@@ -5,12 +5,9 @@
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
 #
 
-bool 'Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)' CONFIG_DRM
-if [ "$CONFIG_DRM" != "n" ]; then
-    tristate '  3dfx Banshee/Voodoo3+' CONFIG_DRM_TDFX
-    tristate '  3dlabs GMX 2000' CONFIG_DRM_GAMMA
-    tristate '  ATI Rage 128' CONFIG_DRM_R128
-    dep_tristate '  ATI Radeon' CONFIG_DRM_RADEON $CONFIG_AGP
-    dep_tristate '  Intel I810' CONFIG_DRM_I810 $CONFIG_AGP
-    dep_tristate '  Matrox g200/g400' CONFIG_DRM_MGA $CONFIG_AGP
-fi
+tristate '  3dfx Banshee/Voodoo3+' CONFIG_DRM_TDFX
+tristate '  3dlabs GMX 2000' CONFIG_DRM_GAMMA
+tristate '  ATI Rage 128' CONFIG_DRM_R128
+dep_tristate '  ATI Radeon' CONFIG_DRM_RADEON $CONFIG_AGP
+dep_tristate '  Intel I810' CONFIG_DRM_I810 $CONFIG_AGP
+dep_tristate '  Matrox g200/g400' CONFIG_DRM_MGA $CONFIG_AGP
diff -urN linux.orig/drivers/char/drm/ati_pcigart.h linux/drivers/char/drm/ati_pcigart.h
--- linux.orig/drivers/char/drm/ati_pcigart.h	Wed Aug 15 15:21:50 2001
+++ linux/drivers/char/drm/ati_pcigart.h	Mon Dec 17 20:27:40 2001
@@ -30,7 +30,10 @@
 #define __NO_VERSION__
 #include "drmP.h"
 
-#if PAGE_SIZE == 8192
+#if PAGE_SIZE == 16384
+# define ATI_PCIGART_TABLE_ORDER 	1
+# define ATI_PCIGART_TABLE_PAGES 	(1 << 1)
+#elif PAGE_SIZE == 8192
 # define ATI_PCIGART_TABLE_ORDER 	2
 # define ATI_PCIGART_TABLE_PAGES 	(1 << 2)
 #elif PAGE_SIZE == 4096
@@ -72,8 +75,6 @@
 	int i;
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
-	if ( !address ) return;
-
 	page = virt_to_page( address );
 
 	for ( i = 0 ; i <= ATI_PCIGART_TABLE_PAGES ; i++, page++ ) {
@@ -84,25 +85,46 @@
 	free_pages( address, ATI_PCIGART_TABLE_ORDER );
 }
 
-unsigned long DRM(ati_pcigart_init)( drm_device_t *dev )
+int DRM(ati_pcigart_init)( drm_device_t *dev,
+			   unsigned long *addr,
+			   dma_addr_t *bus_addr)
 {
 	drm_sg_mem_t *entry = dev->sg;
-	unsigned long address;
+	unsigned long address = 0;
 	unsigned long pages;
-	u32 *pci_gart, page_base;
-	int i, j;
+	u32 *pci_gart, page_base, bus_address = 0;
+	int i, j, ret = 0;
 
 	if ( !entry ) {
 		DRM_ERROR( "no scatter/gather memory!\n" );
-		return 0;
+		goto done;
 	}
 
 	address = DRM(ati_alloc_pcigart_table)();
 	if ( !address ) {
 		DRM_ERROR( "cannot allocate PCI GART page!\n" );
-		return 0;
+		goto done;
 	}
 
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+	if ( !dev->pdev ) {
+		DRM_ERROR( "PCI device unknown!\n" );
+		goto done;
+	}
+
+	bus_address = pci_map_single(dev->pdev, (void *)address,
+				  ATI_PCIGART_TABLE_PAGES * PAGE_SIZE,
+				  PCI_DMA_TODEVICE);
+	if (bus_address == 0) {
+		DRM_ERROR( "unable to map PCIGART pages!\n" );
+		DRM(ati_free_pcigart_table)( address );
+		address = 0;
+		goto done;
+	}
+#else
+	bus_address = virt_to_bus( (void *)address );
+#endif
+
 	pci_gart = (u32 *)address;
 
 	pages = ( entry->pages <= ATI_MAX_PCIGART_PAGES )
@@ -111,28 +133,78 @@
 	memset( pci_gart, 0, ATI_MAX_PCIGART_PAGES * sizeof(u32) );
 
 	for ( i = 0 ; i < pages ; i++ ) {
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+		/* we need to support large memory configurations */
+		entry->busaddr[i] = pci_map_single(dev->pdev,
+					   page_address( entry->pagelist[i] ),
+					   PAGE_SIZE,
+					   PCI_DMA_TODEVICE);
+		if (entry->busaddr[i] == 0) {
+			DRM_ERROR( "unable to map PCIGART pages!\n" );
+			DRM(ati_pcigart_cleanup)( dev, address, bus_address );
+			address = 0;
+			bus_address = 0;
+			goto done;
+		}
+		page_base = (u32) entry->busaddr[i];
+#else
 		page_base = page_to_bus( entry->pagelist[i] );
+#endif
 		for (j = 0; j < (PAGE_SIZE / ATI_PCIGART_PAGE_SIZE); j++) {
 			*pci_gart++ = cpu_to_le32( page_base );
 			page_base += ATI_PCIGART_PAGE_SIZE;
 		}
 	}
 
+	ret = 1;
+
 #if __i386__
 	asm volatile ( "wbinvd" ::: "memory" );
 #else
 	mb();
 #endif
 
-	return address;
+done:
+	*addr = address;
+	*bus_addr = bus_address;
+	return ret;
 }
 
-int DRM(ati_pcigart_cleanup)( unsigned long address )
+int DRM(ati_pcigart_cleanup)( drm_device_t *dev,
+			      unsigned long addr,
+			      dma_addr_t bus_addr)
 {
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+	drm_sg_mem_t *entry = dev->sg;
+	unsigned long pages;
+	int i;
 
-	if ( address ) {
-		DRM(ati_free_pcigart_table)( address );
+	/* we need to support large memory configurations */
+	if ( !entry ) {
+		DRM_ERROR( "no scatter/gather memory!\n" );
+		return 0;
+	}
+
+	if ( bus_addr ) {
+		pci_unmap_single(dev->pdev, bus_addr,
+				 ATI_PCIGART_TABLE_PAGES * PAGE_SIZE,
+				 PCI_DMA_TODEVICE);
+
+		pages = ( entry->pages <= ATI_MAX_PCIGART_PAGES )
+		        ? entry->pages : ATI_MAX_PCIGART_PAGES;
+
+		for ( i = 0 ; i < pages ; i++ ) {
+			if ( !entry->busaddr[i] ) break;
+			pci_unmap_single(dev->pdev, entry->busaddr[i],
+					 PAGE_SIZE, PCI_DMA_TODEVICE);
+		}
+	}
+
+#endif
+
+	if ( addr ) {
+		DRM(ati_free_pcigart_table)( addr );
 	}
 
-	return 0;
+	return 1;
 }
diff -urN linux.orig/drivers/char/drm/drmP.h linux/drivers/char/drm/drmP.h
--- linux.orig/drivers/char/drm/drmP.h	Wed Aug 15 15:21:47 2001
+++ linux/drivers/char/drm/drmP.h	Mon Dec 17 20:27:40 2001
@@ -76,6 +76,17 @@
 #include <asm/pgalloc.h>
 #include "drm.h"
 
+/* page_to_bus for earlier kernels, not optimal in all cases */
+#ifndef page_to_bus
+#define page_to_bus(page)	((unsigned int)(virt_to_bus(page_address(page))))
+#endif
+
+/* We just use virt_to_bus for pci_map_single on older kernels */
+#if LINUX_VERSION_CODE < 0x020400
+#define pci_map_single(hwdev, ptr, size, direction)	virt_to_bus(ptr)
+#define pci_unmap_single(hwdev, dma_addr, size, direction)
+#endif
+
 /* DRM template customization defaults
  */
 #ifndef __HAVE_AGP
@@ -355,13 +366,14 @@
    if (len > DRM_PROC_LIMIT) { ret; *eof = 1; return len - offset; }
 
 				/* Mapping helper macros */
-#define DRM_IOREMAP(map)						\
-	(map)->handle = DRM(ioremap)( (map)->offset, (map)->size )
+#define DRM_IOREMAP(map, dev)						\
+	(map)->handle = DRM(ioremap)( (map)->offset, (map)->size, (dev) )
 
-#define DRM_IOREMAPFREE(map)						\
+#define DRM_IOREMAPFREE(map, dev)					\
 	do {								\
 		if ( (map)->handle && (map)->size )			\
-			DRM(ioremapfree)( (map)->handle, (map)->size );	\
+			DRM(ioremapfree)( (map)->handle,		\
+						 (map)->size, (dev) );	\
 	} while (0)
 
 #define DRM_FIND_MAP(_map, _o)						\
@@ -616,6 +628,8 @@
 	int                acquired;
 	unsigned long      base;
    	int 		   agp_mtrr;
+	int		   cant_use_aperture;
+	unsigned long	   page_mask;
 } drm_agp_head_t;
 #endif
 
@@ -624,6 +638,7 @@
 	void            *virtual;
 	int             pages;
 	struct page     **pagelist;
+	dma_addr_t	*busaddr;
 } drm_sg_mem_t;
 
 typedef struct drm_sigdata {
@@ -714,6 +729,7 @@
 #if __REALLY_HAVE_AGP
 	drm_agp_head_t    *agp;
 #endif
+	struct pci_dev *pdev;
 #ifdef __alpha__
 #if LINUX_VERSION_CODE < 0x020403
 	struct pci_controler *hose;
@@ -811,8 +827,10 @@
 extern unsigned long DRM(alloc_pages)(int order, int area);
 extern void	     DRM(free_pages)(unsigned long address, int order,
 				     int area);
-extern void	     *DRM(ioremap)(unsigned long offset, unsigned long size);
-extern void	     DRM(ioremapfree)(void *pt, unsigned long size);
+extern void	     *DRM(ioremap)(unsigned long offset,
+					unsigned long size, drm_device_t *dev);
+extern void	     DRM(ioremapfree)(void *pt,
+					unsigned long size, drm_device_t *dev);
 
 #if __REALLY_HAVE_AGP
 extern agp_memory    *DRM(alloc_agp)(int pages, u32 type);
@@ -1018,8 +1036,12 @@
 #endif
 
                                /* ATI PCIGART support (ati_pcigart.h) */
-extern unsigned long  DRM(ati_pcigart_init)(drm_device_t *dev);
-extern int            DRM(ati_pcigart_cleanup)(unsigned long address);
+extern int            DRM(ati_pcigart_init)(drm_device_t *dev,
+					    unsigned long *addr,
+					    dma_addr_t *bus_addr);
+extern int            DRM(ati_pcigart_cleanup)(drm_device_t *dev,
+					       unsigned long addr,
+					       dma_addr_t bus_addr);
 
 #endif /* __KERNEL__ */
 #endif
diff -urN linux.orig/drivers/char/drm/drm_agpsupport.h linux/drivers/char/drm/drm_agpsupport.h
--- linux.orig/drivers/char/drm/drm_agpsupport.h	Wed Aug 15 15:21:50 2001
+++ linux/drivers/char/drm/drm_agpsupport.h	Mon Dec 17 20:27:40 2001
@@ -275,6 +275,7 @@
 		case INTEL_I815:	head->chipset = "Intel i815";	 break;
 		case INTEL_I840:	head->chipset = "Intel i840";    break;
 		case INTEL_I850:	head->chipset = "Intel i850";	 break;
+		case INTEL_460GX:	head->chipset = "Intel 460GX";	 break;
 #endif
 
 		case VIA_GENERIC:	head->chipset = "VIA";           break;
@@ -316,6 +317,14 @@
 
 		default:		head->chipset = "Unknown";       break;
 		}
+#if LINUX_VERSION_CODE <= 0x020408
+		head->cant_use_aperture = 0;
+		head->page_mask = ~(0xfff);
+#else
+		head->cant_use_aperture = head->agp_info.cant_use_aperture;
+		head->page_mask = head->agp_info.page_mask;
+#endif
+
 		DRM_INFO("AGP %d.%d on %s @ 0x%08lx %ZuMB\n",
 			 head->agp_info.version.major,
 			 head->agp_info.version.minor,
diff -urN linux.orig/drivers/char/drm/drm_bufs.h linux/drivers/char/drm/drm_bufs.h
--- linux.orig/drivers/char/drm/drm_bufs.h	Wed Aug 15 15:21:47 2001
+++ linux/drivers/char/drm/drm_bufs.h	Mon Dec 17 20:27:40 2001
@@ -107,7 +107,7 @@
 	switch ( map->type ) {
 	case _DRM_REGISTERS:
 	case _DRM_FRAME_BUFFER:
-#if !defined(__sparc__) && !defined(__alpha__)
+#if !defined(__sparc__) && !defined(__alpha__) && !defined(__ia64__)
 		if ( map->offset + map->size < map->offset ||
 		     map->offset < virt_to_phys(high_memory) ) {
 			DRM(free)( map, sizeof(*map), DRM_MEM_MAPS );
@@ -124,7 +124,7 @@
 					      MTRR_TYPE_WRCOMB, 1 );
 		}
 #endif
-		map->handle = DRM(ioremap)( map->offset, map->size );
+		map->handle = DRM(ioremap)( map->offset, map->size, dev );
 		break;
 
 	case _DRM_SHM:
@@ -249,7 +249,7 @@
 				DRM_DEBUG("mtrr_del = %d\n", retcode);
 			}
 #endif
-			DRM(ioremapfree)(map->handle, map->size);
+			DRM(ioremapfree)(map->handle, map->size, dev);
 			break;
 		case _DRM_SHM:
 			vfree(map->handle);
diff -urN linux.orig/drivers/char/drm/drm_context.h linux/drivers/char/drm/drm_context.h
--- linux.orig/drivers/char/drm/drm_context.h	Wed Aug 15 15:21:47 2001
+++ linux/drivers/char/drm/drm_context.h	Mon Dec 17 20:27:40 2001
@@ -181,7 +181,7 @@
 	drm_device_t	*dev	= priv->dev;
 	drm_ctx_priv_map_t request;
 	drm_map_t *map = NULL;
-	drm_map_list_t *r_list;
+	drm_map_list_t *r_list = NULL;
 	struct list_head *list;
 
 	if (copy_from_user(&request,
diff -urN linux.orig/drivers/char/drm/drm_drv.h linux/drivers/char/drm/drm_drv.h
--- linux.orig/drivers/char/drm/drm_drv.h	Wed Aug  8 10:42:14 2001
+++ linux/drivers/char/drm/drm_drv.h	Mon Dec 17 20:27:40 2001
@@ -438,7 +438,7 @@
 					DRM_DEBUG( "mtrr_del=%d\n", retcode );
 				}
 #endif
-				DRM(ioremapfree)( map->handle, map->size );
+				DRM(ioremapfree)( map->handle, map->size, dev );
 				break;
 			case _DRM_SHM:
 				vfree(map->handle);
diff -urN linux.orig/drivers/char/drm/drm_ioctl.h linux/drivers/char/drm/drm_ioctl.h
--- linux.orig/drivers/char/drm/drm_ioctl.h	Wed Aug 15 15:21:47 2001
+++ linux/drivers/char/drm/drm_ioctl.h	Mon Dec 17 20:27:40 2001
@@ -98,7 +98,6 @@
 	}
 	sprintf(dev->devname, "%s@%s", dev->name, dev->unique);
 
-#ifdef __alpha__
 	do {
 		struct pci_dev *pci_dev;
                 int b, d, f;
@@ -114,10 +113,13 @@
                 if (*p) break;
  
                 pci_dev = pci_find_slot(b, PCI_DEVFN(d,f));
-                if (pci_dev)
-                        dev->hose = pci_dev->sysdata;
-        } while(0);
+                if (pci_dev) {
+			dev->pdev = pci_dev;
+#ifdef __alpha__
+			dev->hose = pci_dev->sysdata;
 #endif
+		}
+        } while(0);
 
 	return 0;
 }
diff -urN linux.orig/drivers/char/drm/drm_memory.h linux/drivers/char/drm/drm_memory.h
--- linux.orig/drivers/char/drm/drm_memory.h	Wed Aug 15 15:21:47 2001
+++ linux/drivers/char/drm/drm_memory.h	Mon Dec 17 20:27:40 2001
@@ -306,7 +306,7 @@
 	}
 }
 
-void *DRM(ioremap)(unsigned long offset, unsigned long size)
+void *DRM(ioremap)(unsigned long offset, unsigned long size, drm_device_t *dev)
 {
 	void *pt;
 
@@ -316,12 +316,52 @@
 		return NULL;
 	}
 
+	if(dev->agp->cant_use_aperture == 0) {
+		goto standard_ioremap;
+	} else {
+		drm_map_t *map    = NULL;
+		drm_map_list_t  *r_list;
+		struct list_head *list, *head;
+
+		list_for_each(list, &dev->maplist->head) {
+			r_list = (drm_map_list_t *)list;
+			map = r_list->map;
+			if (!map) continue;
+			if (map->offset <= offset &&
+				(map->offset + map->size) >= (offset + size))
+				break;
+		}
+		
+		if(map && map->type == _DRM_AGP) {
+			struct drm_agp_mem *agpmem;
+
+			for(agpmem = dev->agp->memory; agpmem;
+						agpmem = agpmem->next) {
+				if(agpmem->bound <= offset &&
+				   (agpmem->bound + (agpmem->pages
+					<< PAGE_SHIFT)) >= (offset + size))
+					break;
+			}
+
+			if(agpmem == NULL)
+				goto standard_ioremap;
+
+			pt = agpmem->memory->vmptr + (offset - agpmem->bound);
+			goto ioremap_success;
+		} else {
+			goto standard_ioremap;
+		}
+	}
+
+standard_ioremap:
 	if (!(pt = ioremap(offset, size))) {
 		spin_lock(&DRM(mem_lock));
 		++DRM(mem_stats)[DRM_MEM_MAPPINGS].fail_count;
 		spin_unlock(&DRM(mem_lock));
 		return NULL;
 	}
+
+ioremap_success:
 	spin_lock(&DRM(mem_lock));
 	++DRM(mem_stats)[DRM_MEM_MAPPINGS].succeed_count;
 	DRM(mem_stats)[DRM_MEM_MAPPINGS].bytes_allocated += size;
@@ -329,7 +369,7 @@
 	return pt;
 }
 
-void DRM(ioremapfree)(void *pt, unsigned long size)
+void DRM(ioremapfree)(void *pt, unsigned long size, drm_device_t *dev)
 {
 	int alloc_count;
 	int free_count;
@@ -337,7 +377,7 @@
 	if (!pt)
 		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
 			      "Attempt to free NULL pointer\n");
-	else
+	else if(dev->agp->cant_use_aperture == 0)
 		iounmap(pt);
 
 	spin_lock(&DRM(mem_lock));
diff -urN linux.orig/drivers/char/drm/drm_scatter.h linux/drivers/char/drm/drm_scatter.h
--- linux.orig/drivers/char/drm/drm_scatter.h	Wed Aug 15 15:21:50 2001
+++ linux/drivers/char/drm/drm_scatter.h	Mon Dec 17 20:27:40 2001
@@ -47,12 +47,17 @@
 
 	vfree( entry->virtual );
 
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+	DRM(free)( entry->busaddr,
+		   entry->pages * sizeof(*entry->busaddr),
+		   DRM_MEM_PAGES );
+#endif
 	DRM(free)( entry->pagelist,
-		  entry->pages * sizeof(*entry->pagelist),
-		  DRM_MEM_PAGES );
+		   entry->pages * sizeof(*entry->pagelist),
+		   DRM_MEM_PAGES );
 	DRM(free)( entry,
-		  sizeof(*entry),
-		  DRM_MEM_SGLISTS );
+		   sizeof(*entry),
+		   DRM_MEM_SGLISTS );
 }
 
 int DRM(sg_alloc)( struct inode *inode, struct file *filp,
@@ -93,16 +98,35 @@
 		DRM(free)( entry, sizeof(*entry), DRM_MEM_SGLISTS );
 		return -ENOMEM;
 	}
-	memset(entry->pagelist, 0, pages * sizeof(*entry->pagelist));
+
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+	entry->busaddr = DRM(alloc)( pages * sizeof(*entry->busaddr),
+				     DRM_MEM_PAGES );
+	if ( !entry->busaddr ) {
+		DRM(free)( entry->pagelist,
+			   entry->pages * sizeof(*entry->pagelist),
+			   DRM_MEM_PAGES );
+		DRM(free)( entry,
+			   sizeof(*entry),
+			   DRM_MEM_SGLISTS );
+		return -ENOMEM;
+	}
+	memset( (void *)entry->busaddr, 0, pages * sizeof(*entry->busaddr) );
+#endif
 
 	entry->virtual = vmalloc_32( pages << PAGE_SHIFT );
 	if ( !entry->virtual ) {
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+		DRM(free)( entry->busaddr,
+			   entry->pages * sizeof(*entry->busaddr),
+			   DRM_MEM_PAGES );
+#endif
 		DRM(free)( entry->pagelist,
-			  entry->pages * sizeof(*entry->pagelist),
-			  DRM_MEM_PAGES );
+			   entry->pages * sizeof(*entry->pagelist),
+			   DRM_MEM_PAGES );
 		DRM(free)( entry,
-			  sizeof(*entry),
-			  DRM_MEM_SGLISTS );
+			   sizeof(*entry),
+			   DRM_MEM_SGLISTS );
 		return -ENOMEM;
 	}
 
diff -urN linux.orig/drivers/char/drm/drm_vm.h linux/drivers/char/drm/drm_vm.h
--- linux.orig/drivers/char/drm/drm_vm.h	Wed Aug 15 15:21:47 2001
+++ linux/drivers/char/drm/drm_vm.h	Mon Dec 17 20:27:40 2001
@@ -67,6 +67,82 @@
 			    int write_access)
 #endif
 {
+#if (defined(__alpha__) || defined(__ia64__)) && __REALLY_HAVE_AGP
+	drm_file_t *priv  = vma->vm_file->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_map_t *map    = NULL;
+	drm_map_list_t  *r_list;
+	struct list_head *list;
+
+	/*
+         * Find the right map
+         */
+
+	if(!dev->agp->cant_use_aperture) goto vm_nopage_error;
+
+	list_for_each(list, &dev->maplist->head) {
+		r_list = (drm_map_list_t *)list;
+		map = r_list->map;
+		if (!map) continue;
+		if (map->offset == VM_OFFSET(vma)) break;
+	}
+
+	if (map && map->type == _DRM_AGP) {
+		unsigned long offset = address - vma->vm_start;
+		unsigned long baddr = VM_OFFSET(vma) + offset, paddr;
+		struct drm_agp_mem *agpmem;
+		struct page *page;
+
+#if __alpha__
+		/*
+                 * Adjust to a bus-relative address
+                 */
+		baddr -= dev->hose->mem_space->start;
+#endif
+
+		/*
+                 * It's AGP memory - find the real physical page to map
+                 */
+		for(agpmem = dev->agp->memory; agpmem; agpmem = agpmem->next) {
+			if (agpmem->bound <= baddr &&
+			    agpmem->bound + agpmem->pages * PAGE_SIZE > baddr) 
+				break;
+		}
+
+		if (!agpmem) goto vm_nopage_error;
+
+		/*
+                 * Get the page, inc the use count, and return it
+                 */
+		offset = (baddr - agpmem->bound) >> PAGE_SHIFT;
+
+		/*
+		 * This is bad.  What we really want to do here is unmask
+		 * the GART table entry held in the agp_memory structure.
+		 * There isn't a convenient way to call agp_bridge.unmask_
+		 * memory from here, so hard code it for now.
+		 */
+#if defined(__alpha__)
+		paddr = agpmem->memory->memory[offset] & ~1UL;
+#elif defined(__ia64__)
+		paddr = (agpmem->memory->memory[offset] & 0xffffff) << 12;
+#endif
+
+		page = virt_to_page(__va(paddr));
+		get_page(page);
+
+		DRM_DEBUG("baddr = 0x%lx page = 0x%p, offset = 0x%lx\n",
+			  baddr, __va(agpmem->memory->memory[offset]), offset);
+
+#if LINUX_VERSION_CODE < 0x020317
+		return page_address(page);
+#else
+		return page;
+#endif
+        }
+vm_nopage_error:
+#endif /* __REALLY_HAVE_AGP */
+
 	return NOPAGE_SIGBUS;		/* Disallow mremap */
 }
 
@@ -191,7 +267,7 @@
 					DRM_DEBUG("mtrr_del = %d\n", retcode);
 				}
 #endif
-				DRM(ioremapfree)(map->handle, map->size);
+				DRM(ioremapfree)(map->handle, map->size, dev);
 				break;
 			case _DRM_SHM:
 				vfree(map->handle);
@@ -220,24 +296,27 @@
 	drm_file_t	 *priv	 = vma->vm_file->private_data;
 	drm_device_t	 *dev	 = priv->dev;
 	drm_device_dma_t *dma	 = dev->dma;
-	unsigned long	 physical;
 	unsigned long	 offset;
-	unsigned long	 page;
+	unsigned long	 page_nr;
+	struct page	 *page;
 
 	if (!dma)		   return NOPAGE_SIGBUS; /* Error */
 	if (address > vma->vm_end) return NOPAGE_SIGBUS; /* Disallow mremap */
 	if (!dma->pagelist)	   return NOPAGE_OOM ; /* Nothing allocated */
 
 	offset	 = address - vma->vm_start; /* vm_[pg]off[set] should be 0 */
-	page	 = offset >> PAGE_SHIFT;
-	physical = dma->pagelist[page] + (offset & (~PAGE_MASK));
-	atomic_inc(&virt_to_page(physical)->count); /* Dec. by kernel */
+	page_nr  = offset >> PAGE_SHIFT;
+	page = virt_to_page((dma->pagelist[page_nr] + 
+			     (offset & (~PAGE_MASK))));
 
-	DRM_DEBUG("0x%08lx (page %lu) => 0x%08lx\n", address, page, physical);
+	get_page(page);
+
+	DRM_DEBUG("0x%08lx (page %lu) => 0x%08x\n", address, page_nr, 
+		  page_to_bus(page));
 #if LINUX_VERSION_CODE < 0x020317
-	return physical;
+	return page_address(page);
 #else
-	return virt_to_page(physical);
+	return page;
 #endif
 }
 
@@ -274,10 +353,10 @@
 	map_offset = map->offset - dev->sg->handle;
 	page_offset = (offset >> PAGE_SHIFT) + (map_offset >> PAGE_SHIFT);
 	page = entry->pagelist[page_offset];
-	atomic_inc(&page->count);                       /* Dec. by kernel */
+	get_page(page);
 
 #if LINUX_VERSION_CODE < 0x020317
-	return (unsigned long)virt_to_phys(page->virtual);
+	return page_address(page);
 #else
 	return page;
 #endif
@@ -435,9 +514,25 @@
 	}
 
 	switch (map->type) {
+        case _DRM_AGP:
+#if defined(__alpha__) || defined(__ia64__)
+                /*
+                 * On Alpha and ia64 we can't talk to bus dma address from
+                 * the CPU, so for memory of type DRM_AGP, we'll deal with
+                 * sorting out the real physical pages and mappings
+                 * in nopage()
+                 */
+                vma->vm_ops = &DRM(vm_ops);
+
+#if defined(__ia64__)
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+#endif	
+
+                break;
+#endif
+                /* fall through to _DRM_FRAME_BUFFER... */        
 	case _DRM_FRAME_BUFFER:
 	case _DRM_REGISTERS:
-	case _DRM_AGP:
 		if (VM_OFFSET(vma) >= __pa(high_memory)) {
 #if defined(__i386__)
 			if (boot_cpu_data.x86 > 3 && map->type != _DRM_AGP) {
@@ -445,8 +540,7 @@
 				pgprot_val(vma->vm_page_prot) &= ~_PAGE_PWT;
 			}
 #elif defined(__ia64__)
-			if (map->type != _DRM_AGP)
-				vma->vm_page_prot =
+			vma->vm_page_prot =
 					pgprot_writecombine(vma->vm_page_prot);
 #elif defined(__powerpc__)
 			pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE | _PAGE_GUARDED;
diff -urN linux.orig/drivers/char/drm/i810_dma.c linux/drivers/char/drm/i810_dma.c
--- linux.orig/drivers/char/drm/i810_dma.c	Wed Aug  8 10:42:15 2001
+++ linux/drivers/char/drm/i810_dma.c	Mon Dec 17 20:27:40 2001
@@ -315,7 +315,7 @@
 
 	   	if(dev_priv->ring.virtual_start) {
 		   	DRM(ioremapfree)((void *) dev_priv->ring.virtual_start,
-					 dev_priv->ring.Size);
+					 dev_priv->ring.Size, dev);
 		}
 	   	if(dev_priv->hw_status_page != 0UL) {
 		   	i810_free_page(dev, dev_priv->hw_status_page);
@@ -329,7 +329,8 @@
 		for (i = 0; i < dma->buf_count; i++) {
 			drm_buf_t *buf = dma->buflist[ i ];
 			drm_i810_buf_priv_t *buf_priv = buf->dev_private;
-			DRM(ioremapfree)(buf_priv->kernel_virtual, buf->total);
+			DRM(ioremapfree)(buf_priv->kernel_virtual,
+							buf->total, dev);
 		}
 	}
    	return 0;
@@ -402,7 +403,7 @@
 	   	*buf_priv->in_use = I810_BUF_FREE;
 
 		buf_priv->kernel_virtual = DRM(ioremap)(buf->bus_address,
-							buf->total);
+							buf->total, dev);
 	}
 	return 0;
 }
@@ -458,7 +459,7 @@
 
    	dev_priv->ring.virtual_start = DRM(ioremap)(dev->agp->base +
 						    init->ring_start,
-						    init->ring_size);
+						    init->ring_size, dev);
 
    	if (dev_priv->ring.virtual_start == NULL) {
 		dev->dev_private = (void *) dev_priv;
diff -urN linux.orig/drivers/char/drm/mga_dma.c linux/drivers/char/drm/mga_dma.c
--- linux.orig/drivers/char/drm/mga_dma.c	Wed Aug  8 10:42:15 2001
+++ linux/drivers/char/drm/mga_dma.c	Mon Dec 17 20:27:40 2001
@@ -557,9 +557,9 @@
 		(drm_mga_sarea_t *)((u8 *)dev_priv->sarea->handle +
 				    init->sarea_priv_offset);
 
-	DRM_IOREMAP( dev_priv->warp );
-	DRM_IOREMAP( dev_priv->primary );
-	DRM_IOREMAP( dev_priv->buffers );
+	DRM_IOREMAP( dev_priv->warp, dev );
+	DRM_IOREMAP( dev_priv->primary, dev );
+	DRM_IOREMAP( dev_priv->buffers, dev );
 
 	if(!dev_priv->warp->handle ||
 	   !dev_priv->primary->handle ||
@@ -647,9 +647,9 @@
 	if ( dev->dev_private ) {
 		drm_mga_private_t *dev_priv = dev->dev_private;
 
-		DRM_IOREMAPFREE( dev_priv->warp );
-		DRM_IOREMAPFREE( dev_priv->primary );
-		DRM_IOREMAPFREE( dev_priv->buffers );
+		DRM_IOREMAPFREE( dev_priv->warp, dev );
+		DRM_IOREMAPFREE( dev_priv->primary, dev );
+		DRM_IOREMAPFREE( dev_priv->buffers, dev );
 
 		if ( dev_priv->head != NULL ) {
 			mga_freelist_cleanup( dev );
diff -urN linux.orig/drivers/char/drm/mga_drv.h linux/drivers/char/drm/mga_drv.h
--- linux.orig/drivers/char/drm/mga_drv.h	Wed Aug  8 10:42:15 2001
+++ linux/drivers/char/drm/mga_drv.h	Mon Dec 17 20:27:40 2001
@@ -145,14 +145,28 @@
 #define mga_flush_write_combine()	mb()
 
 
-#define MGA_BASE( reg )		((u32)(dev_priv->mmio->handle))
+#define MGA_BASE( reg )		((unsigned long)(dev_priv->mmio->handle))
 #define MGA_ADDR( reg )		(MGA_BASE(reg) + reg)
 
 #define MGA_DEREF( reg )	*(volatile u32 *)MGA_ADDR( reg )
+#define MGA_DEREF8( reg )	*(volatile u8 *)MGA_ADDR( reg )
+
+#ifdef __alpha__
+#define MGA_READ( reg )		(_MGA_READ((u32 *)MGA_ADDR(reg)))
+#define MGA_WRITE( reg, val )	do { wmb(); MGA_DEREF( reg ) = val; } while (0)
+#define MGA_WRITE8( reg, val )  do { wmb(); MGA_DEREF8( reg ) = val; } while (0)
+
+static inline u32 _MGA_READ(u32 *addr)
+{
+	mb();
+	return *(volatile u32 *)addr;
+}
+
+#else
 #define MGA_READ( reg )		MGA_DEREF( reg )
 #define MGA_WRITE( reg, val )	do { MGA_DEREF( reg ) = val; } while (0)
-#define MGA_DEREF8( reg )	*(volatile u8 *)MGA_ADDR( reg )
 #define MGA_WRITE8( reg, val )  do { MGA_DEREF8( reg ) = val; } while (0)
+#endif
 
 #define DWGREG0 	0x1c00
 #define DWGREG0_END 	0x1dff
diff -urN linux.orig/drivers/char/drm/r128_cce.c linux/drivers/char/drm/r128_cce.c
--- linux.orig/drivers/char/drm/r128_cce.c	Sun Aug 12 12:55:12 2001
+++ linux/drivers/char/drm/r128_cce.c	Mon Dec 17 20:27:40 2001
@@ -216,7 +216,22 @@
 	int i;
 
 	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+#ifndef CONFIG_AGP_I460
 		if ( GET_RING_HEAD( &dev_priv->ring ) == dev_priv->ring.tail ) {
+#else
+		/*
+		 * XXX - this is (I think) a 460GX specific hack
+		 *
+		 * When doing texturing, ring.tail sometimes gets ahead of
+		 * PM4_BUFFER_DL_WPTR by 2; consequently, the card processes
+		 * its whole quota of instructions and *ring.head is still 2
+		 * short of ring.tail.  Work around this for now in lieu of
+		 * a better solution.
+		 */
+ 		if ( GET_RING_HEAD( &dev_priv->ring ) == dev_priv->ring.tail ||
+			( dev_priv->ring.tail -
+				GET_RING_HEAD( &dev_priv->ring ) ) == 2 ) {
+#endif
 			int pm4stat = R128_READ( R128_PM4_STAT );
 			if ( ( (pm4stat & R128_PM4_FIFOCNT_MASK) >=
 			       dev_priv->cce_fifo_size ) &&
@@ -341,8 +356,27 @@
 	SET_RING_HEAD( &dev_priv->ring, 0 );
 
 	if ( !dev_priv->is_pci ) {
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+		/*
+		 * XXX - This is a 460GX specific hack
+		 *
+		 * We have to hack this right now.  460GX isn't claiming PCI
+		 * writes from the card into the AGP aperture.  Because of this,
+		 * we have to get space outside of the aperture for RPTR_ADDR.
+		 */
+		if( dev->agp->agp_info.chipset == INTEL_460GX ) {
+			unsigned long alt_rh_off;
+
+			alt_rh_off = __get_free_page(GFP_KERNEL | GFP_DMA);
+			atomic_inc(&virt_to_page(alt_rh_off)->count);
+			set_bit(PG_locked, &virt_to_page(alt_rh_off)->flags);
+
+			dev_priv->ring.head = (__volatile__ u32 *) alt_rh_off;
+			SET_RING_HEAD( &dev_priv->ring, 0 );
+		}
+#endif
 		R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
-			    dev_priv->ring_rptr->offset );
+				    	__pa( dev_priv->ring.head ) );
 	} else {
 		drm_sg_mem_t *entry = dev->sg;
 		unsigned long tmp_ofs, page_ofs;
@@ -350,12 +384,20 @@
 		tmp_ofs = dev_priv->ring_rptr->offset - dev->sg->handle;
 		page_ofs = tmp_ofs >> PAGE_SHIFT;
 
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+		R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
+     			    entry->busaddr[page_ofs]);
+		DRM_DEBUG( "ring rptr: offset=0x%08x handle=0x%08lx\n",
+			   entry->busaddr[page_ofs],
+     			   entry->handle + tmp_ofs );
+#else
 		R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
 			    page_to_bus(entry->pagelist[page_ofs]));
 
 		DRM_DEBUG( "ring rptr: offset=0x%08lx handle=0x%08lx\n",
 			   page_to_bus(entry->pagelist[page_ofs]),
 			   entry->handle + tmp_ofs );
+#endif
 	}
 
 	/* Set watermark control */
@@ -551,9 +593,9 @@
 				     init->sarea_priv_offset);
 
 	if ( !dev_priv->is_pci ) {
-		DRM_IOREMAP( dev_priv->cce_ring );
-		DRM_IOREMAP( dev_priv->ring_rptr );
-		DRM_IOREMAP( dev_priv->buffers );
+		DRM_IOREMAP( dev_priv->cce_ring, dev );
+		DRM_IOREMAP( dev_priv->ring_rptr, dev );
+		DRM_IOREMAP( dev_priv->buffers, dev );
 		if(!dev_priv->cce_ring->handle ||
 		   !dev_priv->ring_rptr->handle ||
 		   !dev_priv->buffers->handle) {
@@ -599,15 +641,14 @@
 		    dev_priv->sarea_priv->last_dispatch );
 
 	if ( dev_priv->is_pci ) {
-		dev_priv->phys_pci_gart = DRM(ati_pcigart_init)( dev );
-		if ( !dev_priv->phys_pci_gart ) {
+		if (!DRM(ati_pcigart_init)( dev, &dev_priv->phys_pci_gart,
+     					    &dev_priv->bus_pci_gart) ) {
 			DRM_ERROR( "failed to init PCI GART!\n" );
 			dev->dev_private = (void *)dev_priv;
 			r128_do_cleanup_cce( dev );
 			return -ENOMEM;
 		}
-		R128_WRITE( R128_PCI_GART_PAGE,
-			    virt_to_bus( (void *)dev_priv->phys_pci_gart ) );
+		R128_WRITE( R128_PCI_GART_PAGE, dev_priv->bus_pci_gart );
 	}
 
 	r128_cce_init_ring_buffer( dev, dev_priv );
@@ -626,11 +667,31 @@
 		drm_r128_private_t *dev_priv = dev->dev_private;
 
 		if ( !dev_priv->is_pci ) {
-			DRM_IOREMAPFREE( dev_priv->cce_ring );
-			DRM_IOREMAPFREE( dev_priv->ring_rptr );
-			DRM_IOREMAPFREE( dev_priv->buffers );
+			DRM_IOREMAPFREE( dev_priv->cce_ring, dev );
+			DRM_IOREMAPFREE( dev_priv->ring_rptr, dev );
+			DRM_IOREMAPFREE( dev_priv->buffers, dev );
+		} else {
+			if (!DRM(ati_pcigart_cleanup)( dev,
+						dev_priv->phys_pci_gart,
+						dev_priv->bus_pci_gart ))
+				DRM_ERROR( "failed to cleanup PCI GART!\n" );
 		}
 
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+		/*
+		 * Free the page we grabbed for RPTR_ADDR
+		 */
+		if( dev->agp->agp_info.chipset == INTEL_460GX ) {
+			unsigned long alt_rh_off =
+				(unsigned long) dev_priv->ring.head;
+
+			atomic_dec(&virt_to_page(alt_rh_off)->count);
+			clear_bit(PG_locked, &virt_to_page(alt_rh_off)->flags);
+			wake_up(&virt_to_page(alt_rh_off)->wait);
+			free_page(alt_rh_off);
+		}
+#endif
+	
 		DRM(free)( dev->dev_private, sizeof(drm_r128_private_t),
 			   DRM_MEM_DRIVER );
 		dev->dev_private = NULL;
diff -urN linux.orig/drivers/char/drm/r128_drv.h linux/drivers/char/drm/r128_drv.h
--- linux.orig/drivers/char/drm/r128_drv.h	Wed Aug  8 10:42:15 2001
+++ linux/drivers/char/drm/r128_drv.h	Mon Dec 17 20:27:40 2001
@@ -72,6 +72,7 @@
 	int usec_timeout;
 	int is_pci;
 	unsigned long phys_pci_gart;
+	dma_addr_t bus_pci_gart;
 	unsigned long cce_buffers_offset;
 
 	atomic_t idle_count;
diff -urN linux.orig/drivers/char/drm/radeon_cp.c linux/drivers/char/drm/radeon_cp.c
--- linux.orig/drivers/char/drm/radeon_cp.c	Sun Aug 12 14:29:02 2001
+++ linux/drivers/char/drm/radeon_cp.c	Mon Dec 17 20:27:40 2001
@@ -614,8 +614,27 @@
 	dev_priv->ring.tail = cur_read_ptr;
 
 	if ( !dev_priv->is_pci ) {
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+		/*
+		 * XXX - This is a 460GX specific hack
+		 *
+		 * We have to hack this right now.  460GX isn't claiming PCI
+		 * writes from the card into the AGP aperture.  Because of this,
+		 * we have to get space outside of the aperture for RPTR_ADDR.
+		 */
+		if( dev->agp->agp_info.chipset == INTEL_460GX ) {
+			unsigned long alt_rh_off;
+
+			alt_rh_off = __get_free_page(GFP_KERNEL | GFP_DMA);
+			atomic_inc(&virt_to_page(alt_rh_off)->count);
+			set_bit(PG_locked, &virt_to_page(alt_rh_off)->flags);
+
+			dev_priv->ring.head = (__volatile__ u32 *) alt_rh_off;
+			*dev_priv->ring.head = cur_read_ptr;
+		}
+#endif
 		RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR,
-			      dev_priv->ring_rptr->offset );
+			      		__pa( dev_priv->ring.head ) );
 	} else {
 		drm_sg_mem_t *entry = dev->sg;
 		unsigned long tmp_ofs, page_ofs;
@@ -623,12 +642,20 @@
 		tmp_ofs = dev_priv->ring_rptr->offset - dev->sg->handle;
 		page_ofs = tmp_ofs >> PAGE_SHIFT;
 
+#if defined(__alpha__) && (LINUX_VERSION_CODE >= 0x020400)
+		RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR,
+			     entry->busaddr[page_ofs]);
+		DRM_DEBUG( "ring rptr: offset=0x%08x handle=0x%08lx\n",
+			   entry->busaddr[page_ofs],
+			   entry->handle + tmp_ofs );
+#else
 		RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR,
 			      page_to_bus(entry->pagelist[page_ofs]));
 
 		DRM_DEBUG( "ring rptr: offset=0x%08x handle=0x%08lx\n",
 			   page_to_bus(entry->pagelist[page_ofs]),
 			   entry->handle + tmp_ofs );
+#endif
 	}
 
 	/* Set ring buffer size */
@@ -839,9 +866,9 @@
 				       init->sarea_priv_offset);
 
 	if ( !dev_priv->is_pci ) {
-		DRM_IOREMAP( dev_priv->cp_ring );
-		DRM_IOREMAP( dev_priv->ring_rptr );
-		DRM_IOREMAP( dev_priv->buffers );
+		DRM_IOREMAP( dev_priv->cp_ring, dev );
+		DRM_IOREMAP( dev_priv->ring_rptr, dev );
+		DRM_IOREMAP( dev_priv->buffers, dev );
 		if(!dev_priv->cp_ring->handle ||
 		   !dev_priv->ring_rptr->handle ||
 		   !dev_priv->buffers->handle) {
@@ -929,8 +956,8 @@
 		      dev_priv->sarea_priv->last_clear );
 
 	if ( dev_priv->is_pci ) {
-		dev_priv->phys_pci_gart = DRM(ati_pcigart_init)( dev );
-		if ( !dev_priv->phys_pci_gart ) {
+		if (!DRM(ati_pcigart_init)( dev, &dev_priv->phys_pci_gart,
+					    &dev_priv->bus_pci_gart)) {
 			DRM_ERROR( "failed to init PCI GART!\n" );
 			dev->dev_private = (void *)dev_priv;
 			radeon_do_cleanup_cp(dev);
@@ -944,8 +971,7 @@
 
 		/* set PCI GART page-table base address
 		 */
-		RADEON_WRITE( RADEON_AIC_PT_BASE,
-			      virt_to_bus( (void *)dev_priv->phys_pci_gart ) );
+		RADEON_WRITE( RADEON_AIC_PT_BASE, dev_priv->bus_pci_gart );
 
 		/* set address range for PCI address translate
 		 */
@@ -987,11 +1013,31 @@
 		drm_radeon_private_t *dev_priv = dev->dev_private;
 
 		if ( !dev_priv->is_pci ) {
-			DRM_IOREMAPFREE( dev_priv->cp_ring );
-			DRM_IOREMAPFREE( dev_priv->ring_rptr );
-			DRM_IOREMAPFREE( dev_priv->buffers );
+			DRM_IOREMAPFREE( dev_priv->cp_ring, dev );
+			DRM_IOREMAPFREE( dev_priv->ring_rptr, dev );
+			DRM_IOREMAPFREE( dev_priv->buffers, dev );
+		} else {
+			if (!DRM(ati_pcigart_cleanup)( dev,
+						dev_priv->phys_pci_gart,
+						dev_priv->bus_pci_gart ))
+				DRM_ERROR( "failed to cleanup PCI GART!\n" );
 		}
 
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+		/*
+		 * Free the page we grabbed for RPTR_ADDR
+		 */
+		if( dev->agp->agp_info.chipset == INTEL_460GX ) {
+			unsigned long alt_rh_off =
+				(unsigned long) dev_priv->ring.head;
+
+			atomic_dec(&virt_to_page(alt_rh_off)->count);
+			clear_bit(PG_locked, &virt_to_page(alt_rh_off)->flags);
+			wake_up(&virt_to_page(alt_rh_off)->wait);
+			free_page(alt_rh_off);
+		}
+#endif
+	
 		DRM(free)( dev->dev_private, sizeof(drm_radeon_private_t),
 			   DRM_MEM_DRIVER );
 		dev->dev_private = NULL;
diff -urN linux.orig/drivers/char/drm/radeon_drv.h linux/drivers/char/drm/radeon_drv.h
--- linux.orig/drivers/char/drm/radeon_drv.h	Wed Aug  8 10:42:15 2001
+++ linux/drivers/char/drm/radeon_drv.h	Mon Dec 17 20:27:40 2001
@@ -84,6 +84,7 @@
 	int usec_timeout;
 	int is_pci;
 	unsigned long phys_pci_gart;
+	dma_addr_t bus_pci_gart;
 
 	atomic_t idle_count;
 
diff -urN linux.orig/drivers/char/drm/tdfx_drv.c linux/drivers/char/drm/tdfx_drv.c
--- linux.orig/drivers/char/drm/tdfx_drv.c	Wed Aug  8 10:42:15 2001
+++ linux/drivers/char/drm/tdfx_drv.c	Mon Dec 17 20:27:40 2001
@@ -44,13 +44,30 @@
 #define DRIVER_MINOR		0
 #define DRIVER_PATCHLEVEL	0
 
+#ifndef PCI_VENDOR_ID_3DFX
+#define PCI_VENDOR_ID_3DFX 0x121A
+#endif
 #ifndef PCI_DEVICE_ID_3DFX_VOODOO5
 #define PCI_DEVICE_ID_3DFX_VOODOO5 0x0009
 #endif
+#ifndef PCI_DEVICE_ID_3DFX_VOODOO4
+#define PCI_DEVICE_ID_3DFX_VOODOO4 0x0007
+#endif
+#ifndef PCI_DEVICE_ID_3DFX_VOODOO3_3000 /* Voodoo3 3000 */
+#define PCI_DEVICE_ID_3DFX_VOODOO3_3000 0x0005
+#endif
+#ifndef PCI_DEVICE_ID_3DFX_VOODOO3_2000 /* Voodoo3 3000 */
+#define PCI_DEVICE_ID_3DFX_VOODOO3_2000 0x0004
+#endif
+#ifndef PCI_DEVICE_ID_3DFX_BANSHEE
+#define PCI_DEVICE_ID_3DFX_BANSHEE 0x0003
+#endif
 
 static drm_pci_list_t DRM(idlist)[] = {
 	{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_BANSHEE },
-	{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO3 },
+	{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO3_2000 },
+	{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO3_3000 },
+	{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO4 },
 	{ PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_VOODOO5 },
 	{ 0, 0 }
 };
diff -urN linux.orig/drivers/char/drm-4.0/Config.in linux/drivers/char/drm-4.0/Config.in
--- linux.orig/drivers/char/drm-4.0/Config.in	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/Config.in	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,13 @@
+#
+# drm device configuration
+#
+# This driver provides support for the
+# Direct Rendering Infrastructure (DRI) in XFree86 4.x.
+#
+
+tristate '  3dfx Banshee/Voodoo3+' CONFIG_DRM40_TDFX
+tristate '  3dlabs GMX 2000' CONFIG_DRM40_GAMMA
+dep_tristate '  ATI Rage 128' CONFIG_DRM40_R128 $CONFIG_AGP
+dep_tristate '  ATI Radeon' CONFIG_DRM40_RADEON $CONFIG_AGP
+dep_tristate '  Intel I810' CONFIG_DRM40_I810 $CONFIG_AGP
+dep_tristate '  Matrox g200/g400' CONFIG_DRM40_MGA $CONFIG_AGP
diff -urN linux.orig/drivers/char/drm-4.0/Makefile linux/drivers/char/drm-4.0/Makefile
--- linux.orig/drivers/char/drm-4.0/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/Makefile	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,104 @@
+#
+# Makefile for the drm device driver.  This driver provides support for
+# the Direct Rendering Infrastructure (DRI) in XFree86 4.x.
+#
+
+O_TARGET	:= drm.o
+
+export-objs     := gamma_drv.o tdfx_drv.o r128_drv.o ffb_drv.o mga_drv.o \
+		   i810_drv.o
+
+# lib-objs are included in every module so that radical changes to the
+# architecture of the DRM support library can be made at a later time.
+#
+# The downside is that each module is larger, and a system that uses
+# more than one module (i.e., a dual-head system) will use more memory
+# (but a system that uses exactly one module will use the same amount of
+# memory).
+#
+# The upside is that if the DRM support library ever becomes insufficient
+# for new families of cards, a new library can be implemented for those new
+# cards without impacting the drivers for the old cards.  This is significant,
+# because testing architectural changes to old cards may be impossible, and
+# may delay the implementation of a better architecture.  We've traded slight
+# memory waste (in the dual-head case) for greatly improved long-term
+# maintainability.
+#
+# NOTE: lib-objs will be eliminated in future versions, thereby
+# eliminating the need to compile the .o files into every module, but
+# for now we still need them.
+#
+
+lib-objs   := init.o memory.o proc.o auth.o context.o drawable.o bufs.o
+lib-objs   += lists.o lock.o ioctl.o fops.o vm.o dma.o ctxbitmap.o
+
+ifeq ($(CONFIG_AGP),y)
+ lib-objs  += agpsupport.o
+else
+ ifeq ($(CONFIG_AGP),m)
+  lib-objs  += agpsupport.o
+ endif
+endif
+
+list-multi  := gamma.o tdfx.o r128.o ffb.o mga.o i810.o
+gamma-objs  := gamma_drv.o  gamma_dma.o
+tdfx-objs   := tdfx_drv.o                 tdfx_context.o
+r128-objs   := r128_drv.o   r128_cce.o    r128_context.o r128_bufs.o r128_state.o
+ffb-objs    := ffb_drv.o                  ffb_context.o
+mga-objs    := mga_drv.o    mga_dma.o     mga_context.o  mga_bufs.o  mga_state.o
+i810-objs   := i810_drv.o   i810_dma.o    i810_context.o i810_bufs.o
+radeon-objs := radeon_drv.o radeon_cp.o   radeon_context.o radeon_bufs.o radeon_state.o
+
+obj-$(CONFIG_DRM40_GAMMA) += gamma.o
+obj-$(CONFIG_DRM40_TDFX)  += tdfx.o
+obj-$(CONFIG_DRM40_R128)  += r128.o
+obj-$(CONFIG_DRM40_RADEON)+= radeon.o
+obj-$(CONFIG_DRM40_FFB)   += ffb.o
+obj-$(CONFIG_DRM40_MGA)   += mga.o
+obj-$(CONFIG_DRM40_I810)  += i810.o
+
+
+# When linking into the kernel, link the library just once. 
+# If making modules, we include the library into each module
+
+lib-objs-mod := $(patsubst %.o,%-mod.o,$(lib-objs))
+
+ifdef MAKING_MODULES
+  lib = drmlib-mod.a
+else
+  obj-y += drmlib.a
+endif
+
+include $(TOPDIR)/Rules.make
+
+$(patsubst %.o,%.c,$(lib-objs-mod)): 
+	@ln -sf $(subst -mod,,$@) $@
+
+drmlib-mod.a: $(lib-objs-mod)
+	rm -f $@
+	$(AR) $(EXTRA_ARFLAGS) rcs $@ $(lib-objs-mod)
+
+drmlib.a: $(lib-objs)
+	rm -f $@
+	$(AR) $(EXTRA_ARFLAGS) rcs $@ $(lib-objs)
+
+gamma.o: $(gamma-objs) $(lib)
+	$(LD) -r -o $@ $(gamma-objs) $(lib)
+
+tdfx.o: $(tdfx-objs) $(lib)
+	$(LD) -r -o $@ $(tdfx-objs) $(lib)
+
+mga.o: $(mga-objs) $(lib)
+	$(LD) -r -o $@ $(mga-objs) $(lib)
+
+i810.o: $(i810-objs) $(lib)
+	$(LD) -r -o $@ $(i810-objs) $(lib)
+
+r128.o: $(r128-objs) $(lib)
+	$(LD) -r -o $@ $(r128-objs) $(lib)
+
+radeon.o: $(radeon-objs) $(lib)
+	$(LD) -r -o $@ $(radeon-objs) $(lib)
+
+ffb.o: $(ffb-objs) $(lib)
+	$(LD) -r -o $@ $(ffb-objs) $(lib)
diff -urN linux.orig/drivers/char/drm-4.0/README.drm linux/drivers/char/drm-4.0/README.drm
--- linux.orig/drivers/char/drm-4.0/README.drm	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/README.drm	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,46 @@
+************************************************************
+* For the very latest on DRI development, please see:      *
+*     http://dri.sourceforge.net/                          *
+************************************************************
+
+The Direct Rendering Manager (drm) is a device-independent kernel-level
+device driver that provides support for the XFree86 Direct Rendering
+Infrastructure (DRI).
+
+The DRM supports the Direct Rendering Infrastructure (DRI) in four major
+ways:
+
+    1. The DRM provides synchronized access to the graphics hardware via
+       the use of an optimized two-tiered lock.
+
+    2. The DRM enforces the DRI security policy for access to the graphics
+       hardware by only allowing authenticated X11 clients access to
+       restricted regions of memory.
+
+    3. The DRM provides a generic DMA engine, complete with multiple
+       queues and the ability to detect the need for an OpenGL context
+       switch.
+
+    4. The DRM is extensible via the use of small device-specific modules
+       that rely extensively on the API exported by the DRM module.
+
+
+Documentation on the DRI is available from:
+    http://precisioninsight.com/piinsights.html
+
+For specific information about kernel-level support, see:
+
+    The Direct Rendering Manager, Kernel Support for the Direct Rendering
+    Infrastructure
+    http://precisioninsight.com/dr/drm.html
+
+    Hardware Locking for the Direct Rendering Infrastructure
+    http://precisioninsight.com/dr/locking.html
+
+    A Security Analysis of the Direct Rendering Infrastructure
+    http://precisioninsight.com/dr/security.html
+
+************************************************************
+* For the very latest on DRI development, please see:      *
+*     http://dri.sourceforge.net/                          *
+************************************************************
diff -urN linux.orig/drivers/char/drm-4.0/agpsupport.c linux/drivers/char/drm-4.0/agpsupport.c
--- linux.orig/drivers/char/drm-4.0/agpsupport.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/agpsupport.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,349 @@
+/* agpsupport.c -- DRM support for AGP/GART backend -*- linux-c -*-
+ * Created: Mon Dec 13 09:56:45 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Author: Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include <linux/config.h>
+#include <linux/module.h>
+#if LINUX_VERSION_CODE < 0x020400
+#include "agpsupport-pre24.h"
+#else
+#define DRM_AGP_GET (drm_agp_t *)inter_module_get("drm_agp")
+#define DRM_AGP_PUT inter_module_put("drm_agp")
+#endif
+
+static const drm_agp_t *drm_agp = NULL;
+
+int drm_agp_info(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	agp_kern_info    *kern;
+	drm_agp_info_t   info;
+
+	if (!dev->agp->acquired || !drm_agp->copy_info) return -EINVAL;
+
+	kern                   = &dev->agp->agp_info;
+	info.agp_version_major = kern->version.major;
+	info.agp_version_minor = kern->version.minor;
+	info.mode              = kern->mode;
+	info.aperture_base     = kern->aper_base;
+	info.aperture_size     = kern->aper_size * 1024 * 1024;
+	info.memory_allowed    = kern->max_memory << PAGE_SHIFT;
+	info.memory_used       = kern->current_memory << PAGE_SHIFT;
+	info.id_vendor         = kern->device->vendor;
+	info.id_device         = kern->device->device;
+
+	if (copy_to_user((drm_agp_info_t *)arg, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+int drm_agp_acquire(struct inode *inode, struct file *filp, unsigned int cmd,
+		    unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	int              retcode;
+
+	if (dev->agp->acquired || !drm_agp->acquire) return -EINVAL;
+	if ((retcode = drm_agp->acquire())) return retcode;
+	dev->agp->acquired = 1;
+	return 0;
+}
+
+int drm_agp_release(struct inode *inode, struct file *filp, unsigned int cmd,
+		    unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+
+	if (!dev->agp->acquired || !drm_agp->release) return -EINVAL;
+	drm_agp->release();
+	dev->agp->acquired = 0;
+	return 0;
+	
+}
+
+void _drm_agp_release(void)
+{
+	if (drm_agp->release) drm_agp->release();
+}
+
+int drm_agp_enable(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_agp_mode_t   mode;
+
+	if (!dev->agp->acquired || !drm_agp->enable) return -EINVAL;
+
+	if (copy_from_user(&mode, (drm_agp_mode_t *)arg, sizeof(mode)))
+		return -EFAULT;
+	
+	dev->agp->mode    = mode.mode;
+	drm_agp->enable(mode.mode);
+	dev->agp->base    = dev->agp->agp_info.aper_base;
+	dev->agp->enabled = 1;
+	return 0;
+}
+
+int drm_agp_alloc(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_agp_buffer_t request;
+	drm_agp_mem_t    *entry;
+	agp_memory       *memory;
+	unsigned long    pages;
+	u32 		 type;
+	if (!dev->agp->acquired) return -EINVAL;
+	if (copy_from_user(&request, (drm_agp_buffer_t *)arg, sizeof(request)))
+		return -EFAULT;
+	if (!(entry = drm_alloc(sizeof(*entry), DRM_MEM_AGPLISTS)))
+		return -ENOMEM;
+   
+   	memset(entry, 0, sizeof(*entry));
+
+	pages = (request.size + PAGE_SIZE - 1) / PAGE_SIZE;
+	type = (u32) request.type;
+
+	if (!(memory = drm_alloc_agp(pages, type))) {
+		drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+		return -ENOMEM;
+	}
+	
+	entry->handle    = (unsigned long)memory->memory;
+	entry->memory    = memory;
+	entry->bound     = 0;
+	entry->pages     = pages;
+	entry->prev      = NULL;
+	entry->next      = dev->agp->memory;
+	if (dev->agp->memory) dev->agp->memory->prev = entry;
+	dev->agp->memory = entry;
+
+	request.handle   = entry->handle;
+        request.physical = memory->physical;
+
+	if (copy_to_user((drm_agp_buffer_t *)arg, &request, sizeof(request))) {
+		dev->agp->memory       = entry->next;
+		dev->agp->memory->prev = NULL;
+		drm_free_agp(memory, pages);
+		drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static drm_agp_mem_t *drm_agp_lookup_entry(drm_device_t *dev,
+					   unsigned long handle)
+{
+	drm_agp_mem_t *entry;
+
+	for (entry = dev->agp->memory; entry; entry = entry->next) {
+		if (entry->handle == handle) return entry;
+	}
+	return NULL;
+}
+
+int drm_agp_unbind(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t	  *priv	 = filp->private_data;
+	drm_device_t	  *dev	 = priv->dev;
+	drm_agp_binding_t request;
+	drm_agp_mem_t     *entry;
+
+	if (!dev->agp->acquired) return -EINVAL;
+	if (copy_from_user(&request, (drm_agp_binding_t *)arg, sizeof(request)))
+		return -EFAULT;
+	if (!(entry = drm_agp_lookup_entry(dev, request.handle)))
+		return -EINVAL;
+	if (!entry->bound) return -EINVAL;
+	return drm_unbind_agp(entry->memory);
+}
+
+int drm_agp_bind(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	  *priv	 = filp->private_data;
+	drm_device_t	  *dev	 = priv->dev;
+	drm_agp_binding_t request;
+	drm_agp_mem_t     *entry;
+	int               retcode;
+	int               page;
+	
+	if (!dev->agp->acquired || !drm_agp->bind_memory) return -EINVAL;
+	if (copy_from_user(&request, (drm_agp_binding_t *)arg, sizeof(request)))
+		return -EFAULT;
+	if (!(entry = drm_agp_lookup_entry(dev, request.handle)))
+		return -EINVAL;
+	if (entry->bound) return -EINVAL;
+	page = (request.offset + PAGE_SIZE - 1) / PAGE_SIZE;
+	if ((retcode = drm_bind_agp(entry->memory, page))) return retcode;
+	entry->bound = dev->agp->base + (page << PAGE_SHIFT);
+	DRM_DEBUG("base = 0x%lx entry->bound = 0x%lx\n", 
+		  dev->agp->base, entry->bound);
+	return 0;
+}
+
+int drm_agp_free(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_agp_buffer_t request;
+	drm_agp_mem_t    *entry;
+	
+	if (!dev->agp->acquired) return -EINVAL;
+	if (copy_from_user(&request, (drm_agp_buffer_t *)arg, sizeof(request)))
+		return -EFAULT;
+	if (!(entry = drm_agp_lookup_entry(dev, request.handle)))
+		return -EINVAL;
+	if (entry->bound) drm_unbind_agp(entry->memory);
+   
+	if (entry->prev) entry->prev->next = entry->next;
+	else             dev->agp->memory  = entry->next;
+	if (entry->next) entry->next->prev = entry->prev;
+	drm_free_agp(entry->memory, entry->pages);
+	drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+	return 0;
+}
+
+drm_agp_head_t *drm_agp_init(void)
+{
+	drm_agp_head_t *head         = NULL;
+
+	drm_agp = DRM_AGP_GET;
+	if (drm_agp) {
+		if (!(head = drm_alloc(sizeof(*head), DRM_MEM_AGPLISTS)))
+			return NULL;
+		memset((void *)head, 0, sizeof(*head));
+		drm_agp->copy_info(&head->agp_info);
+		if (head->agp_info.chipset == NOT_SUPPORTED) {
+			drm_free(head, sizeof(*head), DRM_MEM_AGPLISTS);
+			return NULL;
+		}
+		head->memory = NULL;
+		switch (head->agp_info.chipset) {
+		case INTEL_GENERIC:	head->chipset = "Intel";         break;
+		case INTEL_LX:		head->chipset = "Intel 440LX";   break;
+		case INTEL_BX:		head->chipset = "Intel 440BX";   break;
+		case INTEL_GX:		head->chipset = "Intel 440GX";   break;
+		case INTEL_I810:	head->chipset = "Intel i810";    break;
+
+#if LINUX_VERSION_CODE >= 0x020400
+		case INTEL_I840:	head->chipset = "Intel i840";    break;
+#endif
+		case INTEL_460GX:	head->chipset = "Intel 460GX";	 break;
+
+		case VIA_GENERIC:	head->chipset = "VIA";           break;
+		case VIA_VP3:		head->chipset = "VIA VP3";       break;
+		case VIA_MVP3:		head->chipset = "VIA MVP3";      break;
+
+#if LINUX_VERSION_CODE >= 0x020400
+		case VIA_MVP4:		head->chipset = "VIA MVP4";      break;
+		case VIA_APOLLO_KX133:	head->chipset = "VIA Apollo KX133"; 
+			break;
+		case VIA_APOLLO_KT133:	head->chipset = "VIA Apollo KT133"; 
+			break;
+#endif
+
+		case VIA_APOLLO_PRO: 	head->chipset = "VIA Apollo Pro";
+			break;
+		case SIS_GENERIC:	head->chipset = "SiS";           break;
+		case AMD_GENERIC:	head->chipset = "AMD";           break;
+		case AMD_IRONGATE:	head->chipset = "AMD Irongate";  break;
+		case ALI_GENERIC:	head->chipset = "ALi";           break;
+		case ALI_M1541: 	head->chipset = "ALi M1541";     break;
+		case ALI_M1621: 	head->chipset = "ALi M1621";	 break;
+		case ALI_M1631: 	head->chipset = "ALi M1631";	 break;
+		case ALI_M1632: 	head->chipset = "ALi M1632";	 break;
+		case ALI_M1641: 	head->chipset = "ALi M1641";	 break;
+		case ALI_M1647: 	head->chipset = "ALi M1647";	 break;
+		case ALI_M1651: 	head->chipset = "ALi M1651";	 break;
+		case SVWRKS_GENERIC:	head->chipset = "Serverworks Generic";
+			break;
+		case SVWRKS_HE: 	head->chipset = "Serverworks HE"; break;
+		case SVWRKS_LE: 	head->chipset = "Serverworks LE"; break;
+
+		default:		head->chipset = "Unknown";       break;
+		}
+#if LINUX_VERSION_CODE <= 0x020408
+		head->cant_use_aperture = 0;
+		head->page_mask = ~(0xfff);
+#else
+		head->cant_use_aperture = head->agp_info.cant_use_aperture;
+		head->page_mask = head->agp_info.page_mask;
+#endif
+
+		DRM_INFO("AGP %d.%d on %s @ 0x%08lx %ZuMB\n",
+			 head->agp_info.version.major,
+			 head->agp_info.version.minor,
+			 head->chipset,
+			 head->agp_info.aper_base,
+			 head->agp_info.aper_size);
+	}
+	return head;
+}
+
+void drm_agp_uninit(void)
+{
+	DRM_AGP_PUT;
+	drm_agp = NULL;
+}
+
+agp_memory *drm_agp_allocate_memory(size_t pages, u32 type)
+{
+	if (!drm_agp->allocate_memory) return NULL;
+	return drm_agp->allocate_memory(pages, type);
+}
+
+int drm_agp_free_memory(agp_memory *handle)
+{
+	if (!handle || !drm_agp->free_memory) return 0;
+	drm_agp->free_memory(handle);
+	return 1;
+}
+
+int drm_agp_bind_memory(agp_memory *handle, off_t start)
+{
+	if (!handle || !drm_agp->bind_memory) return -EINVAL;
+	return drm_agp->bind_memory(handle, start);
+}
+
+int drm_agp_unbind_memory(agp_memory *handle)
+{
+	if (!handle || !drm_agp->unbind_memory) return -EINVAL;
+	return drm_agp->unbind_memory(handle);
+}
diff -urN linux.orig/drivers/char/drm-4.0/auth.c linux/drivers/char/drm-4.0/auth.c
--- linux.orig/drivers/char/drm-4.0/auth.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/auth.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,162 @@
+/* auth.c -- IOCTLs for authentication -*- linux-c -*-
+ * Created: Tue Feb  2 08:37:54 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+static int drm_hash_magic(drm_magic_t magic)
+{
+	return magic & (DRM_HASH_SIZE-1);
+}
+
+static drm_file_t *drm_find_file(drm_device_t *dev, drm_magic_t magic)
+{
+	drm_file_t	  *retval = NULL;
+	drm_magic_entry_t *pt;
+	int		  hash	  = drm_hash_magic(magic);
+
+	down(&dev->struct_sem);
+	for (pt = dev->magiclist[hash].head; pt; pt = pt->next) {
+		if (pt->magic == magic) {
+			retval = pt->priv;
+			break;
+		}
+	}
+	up(&dev->struct_sem);
+	return retval;
+}
+
+int drm_add_magic(drm_device_t *dev, drm_file_t *priv, drm_magic_t magic)
+{
+	int		  hash;
+	drm_magic_entry_t *entry;
+	
+	DRM_DEBUG("%d\n", magic);
+	
+	hash	     = drm_hash_magic(magic);
+	entry	     = drm_alloc(sizeof(*entry), DRM_MEM_MAGIC);
+	if (!entry) return -ENOMEM;
+	entry->magic = magic;
+	entry->priv  = priv;
+	entry->next  = NULL;
+
+	down(&dev->struct_sem);
+	if (dev->magiclist[hash].tail) {
+		dev->magiclist[hash].tail->next = entry;
+		dev->magiclist[hash].tail	= entry;
+	} else {
+		dev->magiclist[hash].head	= entry;
+		dev->magiclist[hash].tail	= entry;
+	}
+	up(&dev->struct_sem);
+	
+	return 0;
+}
+
+int drm_remove_magic(drm_device_t *dev, drm_magic_t magic)
+{
+	drm_magic_entry_t *prev = NULL;
+	drm_magic_entry_t *pt;
+	int		  hash;
+	
+	DRM_DEBUG("%d\n", magic);
+	hash = drm_hash_magic(magic);
+	
+	down(&dev->struct_sem);
+	for (pt = dev->magiclist[hash].head; pt; prev = pt, pt = pt->next) {
+		if (pt->magic == magic) {
+			if (dev->magiclist[hash].head == pt) {
+				dev->magiclist[hash].head = pt->next;
+			}
+			if (dev->magiclist[hash].tail == pt) {
+				dev->magiclist[hash].tail = prev;
+			}
+			if (prev) {
+				prev->next = pt->next;
+			}
+			up(&dev->struct_sem);
+			return 0;
+		}
+	}
+	up(&dev->struct_sem);
+
+	drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+	
+	return -EINVAL;
+}
+
+int drm_getmagic(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	static drm_magic_t sequence = 0;
+	static spinlock_t  lock	    = SPIN_LOCK_UNLOCKED;
+	drm_file_t	   *priv    = filp->private_data;
+	drm_device_t	   *dev	    = priv->dev;
+	drm_auth_t	   auth;
+
+				/* Find unique magic */
+	if (priv->magic) {
+		auth.magic = priv->magic;
+	} else {
+		do {
+			spin_lock(&lock);
+			if (!sequence) ++sequence; /* reserve 0 */
+			auth.magic = sequence++;
+			spin_unlock(&lock);
+		} while (drm_find_file(dev, auth.magic));
+		priv->magic = auth.magic;
+		drm_add_magic(dev, priv, auth.magic);
+	}
+	
+	DRM_DEBUG("%u\n", auth.magic);
+	if (copy_to_user((drm_auth_t *)arg, &auth, sizeof(auth)))
+		return -EFAULT;
+	return 0;
+}
+
+int drm_authmagic(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	   *priv    = filp->private_data;
+	drm_device_t	   *dev	    = priv->dev;
+	drm_auth_t	   auth;
+	drm_file_t	   *file;
+
+	if (copy_from_user(&auth, (drm_auth_t *)arg, sizeof(auth)))
+		return -EFAULT;
+	DRM_DEBUG("%u\n", auth.magic);
+	if ((file = drm_find_file(dev, auth.magic))) {
+		file->authenticated = 1;
+		drm_remove_magic(dev, auth.magic);
+		return 0;
+	}
+	return -EINVAL;
+}
diff -urN linux.orig/drivers/char/drm-4.0/bufs.c linux/drivers/char/drm-4.0/bufs.c
--- linux.orig/drivers/char/drm-4.0/bufs.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/bufs.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,543 @@
+/* bufs.c -- IOCTLs to manage buffers -*- linux-c -*-
+ * Created: Tue Feb  2 08:37:54 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include <linux/config.h>
+#include "drmP.h"
+#include "linux/un.h"
+
+				/* Compute order.  Can be made faster. */
+int drm_order(unsigned long size)
+{
+	int	      order;
+	unsigned long tmp;
+
+	for (order = 0, tmp = size; tmp >>= 1; ++order);
+	if (size & ~(1 << order)) ++order;
+	return order;
+}
+
+int drm_addmap(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_map_t	*map;
+	
+	if (!(filp->f_mode & 3)) return -EACCES; /* Require read/write */
+
+	map	     = drm_alloc(sizeof(*map), DRM_MEM_MAPS);
+	if (!map) return -ENOMEM;
+	if (copy_from_user(map, (drm_map_t *)arg, sizeof(*map))) {
+		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		return -EFAULT;
+	}
+
+	DRM_DEBUG("offset = 0x%08lx, size = 0x%08lx, type = %d\n",
+		  map->offset, map->size, map->type);
+	if ((map->offset & (~PAGE_MASK)) || (map->size & (~PAGE_MASK))) {
+		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		return -EINVAL;
+	}
+	map->mtrr   = -1;
+	map->handle = 0;
+
+	switch (map->type) {
+	case _DRM_REGISTERS:
+	case _DRM_FRAME_BUFFER:
+#if !defined(__sparc__) && !defined(__ia64__)
+		if (map->offset + map->size < map->offset
+		    || map->offset < virt_to_phys(high_memory)) {
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			return -EINVAL;
+		}
+#endif
+#ifdef CONFIG_MTRR
+		if (map->type == _DRM_FRAME_BUFFER
+		    || (map->flags & _DRM_WRITE_COMBINING)) {
+			map->mtrr = mtrr_add(map->offset, map->size,
+					     MTRR_TYPE_WRCOMB, 1);
+		}
+#endif
+		map->handle = drm_ioremap(map->offset, map->size, dev);
+		break;
+			
+
+	case _DRM_SHM:
+		map->handle = (void *)drm_alloc_pages(drm_order(map->size)
+						      - PAGE_SHIFT,
+						      DRM_MEM_SAREA);
+		DRM_DEBUG("%ld %d %p\n", map->size, drm_order(map->size),
+			  map->handle);
+		if (!map->handle) {
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			return -ENOMEM;
+		}
+		map->offset = (unsigned long)map->handle;
+		if (map->flags & _DRM_CONTAINS_LOCK) {
+			dev->lock.hw_lock = map->handle; /* Pointer to lock */
+		}
+		break;
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	case _DRM_AGP:
+		map->offset = map->offset + dev->agp->base;
+		break;
+#endif
+	default:
+		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		return -EINVAL;
+	}
+
+	down(&dev->struct_sem);
+	if (dev->maplist) {
+		++dev->map_count;
+		dev->maplist = drm_realloc(dev->maplist,
+					   (dev->map_count-1)
+					   * sizeof(*dev->maplist),
+					   dev->map_count
+					   * sizeof(*dev->maplist),
+					   DRM_MEM_MAPS);
+	} else {
+		dev->map_count = 1;
+		dev->maplist = drm_alloc(dev->map_count*sizeof(*dev->maplist),
+					 DRM_MEM_MAPS);
+	}
+	dev->maplist[dev->map_count-1] = map;
+	up(&dev->struct_sem);
+
+	if (copy_to_user((drm_map_t *)arg, map, sizeof(*map)))
+		return -EFAULT;
+	if (map->type != _DRM_SHM) {
+		if (copy_to_user(&((drm_map_t *)arg)->handle,
+				 &map->offset,
+				 sizeof(map->offset)))
+			return -EFAULT;
+	}		
+	return 0;
+}
+
+int drm_addbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_desc_t	 request;
+	int		 count;
+	int		 order;
+	int		 size;
+	int		 total;
+	int		 page_order;
+	drm_buf_entry_t	 *entry;
+	unsigned long	 page;
+	drm_buf_t	 *buf;
+	int		 alignment;
+	unsigned long	 offset;
+	int		 i;
+	int		 byte_count;
+	int		 page_count;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	count	   = request.count;
+	order	   = drm_order(request.size);
+	size	   = 1 << order;
+	
+	DRM_DEBUG("count = %d, size = %d (%d), order = %d, queue_count = %d\n",
+		  request.count, request.size, size, order, dev->queue_count);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	if (dev->queue_count) return -EBUSY; /* Not while in use */
+
+	alignment  = (request.flags & _DRM_PAGE_ALIGN) ? PAGE_ALIGN(size):size;
+	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
+	total	   = PAGE_SIZE << page_order;
+
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
+	
+	down(&dev->struct_sem);
+	entry = &dma->bufs[order];
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;	/* May only call once for each order */
+	}
+	
+	if(count < 0 || count > 4096)
+	{
+		up(&dev->struct_sem);
+		return -EINVAL;
+	}
+	
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
+
+	entry->seglist = drm_alloc(count * sizeof(*entry->seglist),
+				   DRM_MEM_SEGS);
+	if (!entry->seglist) {
+		drm_free(entry->buflist,
+			 count * sizeof(*entry->buflist),
+			 DRM_MEM_BUFS);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->seglist, 0, count * sizeof(*entry->seglist));
+
+	dma->pagelist = drm_realloc(dma->pagelist,
+				    dma->page_count * sizeof(*dma->pagelist),
+				    (dma->page_count + (count << page_order))
+				    * sizeof(*dma->pagelist),
+				    DRM_MEM_PAGES);
+	DRM_DEBUG("pagelist: %d entries\n",
+		  dma->page_count + (count << page_order));
+
+
+	entry->buf_size	  = size;
+	entry->page_order = page_order;
+	byte_count	  = 0;
+	page_count	  = 0;
+	while (entry->buf_count < count) {
+		if (!(page = drm_alloc_pages(page_order, DRM_MEM_DMA))) break;
+		entry->seglist[entry->seg_count++] = page;
+		for (i = 0; i < (1 << page_order); i++) {
+			DRM_DEBUG("page %d @ 0x%08lx\n",
+				  dma->page_count + page_count,
+				  page + PAGE_SIZE * i);
+			dma->pagelist[dma->page_count + page_count++]
+				= page + PAGE_SIZE * i;
+		}
+		for (offset = 0;
+		     offset + size <= total && entry->buf_count < count;
+		     offset += alignment, ++entry->buf_count) {
+			buf	     = &entry->buflist[entry->buf_count];
+			buf->idx     = dma->buf_count + entry->buf_count;
+			buf->total   = alignment;
+			buf->order   = order;
+			buf->used    = 0;
+			buf->offset  = (dma->byte_count + byte_count + offset);
+			buf->address = (void *)(page + offset);
+			buf->next    = NULL;
+			buf->waiting = 0;
+			buf->pending = 0;
+			init_waitqueue_head(&buf->dma_wait);
+			buf->pid     = 0;
+#if DRM_DMA_HISTOGRAM
+			buf->time_queued     = 0;
+			buf->time_dispatched = 0;
+			buf->time_completed  = 0;
+			buf->time_freed	     = 0;
+#endif
+			DRM_DEBUG("buffer %d @ %p\n",
+				  entry->buf_count, buf->address);
+		}
+		byte_count += PAGE_SIZE << page_order;
+	}
+
+	dma->buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist),
+				   DRM_MEM_BUFS);
+	for (i = dma->buf_count; i < dma->buf_count + entry->buf_count; i++)
+		dma->buflist[i] = &entry->buflist[i - dma->buf_count];
+
+	dma->buf_count	+= entry->buf_count;
+	dma->seg_count	+= entry->seg_count;
+	dma->page_count += entry->seg_count << page_order;
+	dma->byte_count += PAGE_SIZE * (entry->seg_count << page_order);
+	
+	drm_freelist_create(&entry->freelist, entry->buf_count);
+	for (i = 0; i < entry->buf_count; i++) {
+		drm_freelist_put(dev, &entry->freelist, &entry->buflist[i]);
+	}
+	
+	up(&dev->struct_sem);
+
+	request.count = entry->buf_count;
+	request.size  = size;
+
+	if (copy_to_user((drm_buf_desc_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+	
+	atomic_dec(&dev->buf_alloc);
+	return 0;
+}
+
+int drm_infobufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_info_t	 request;
+	int		 i;
+	int		 count;
+
+	if (!dma) return -EINVAL;
+
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	++dev->buf_use;		/* Can't allocate more after this call */
+	spin_unlock(&dev->count_lock);
+
+	if (copy_from_user(&request,
+			   (drm_buf_info_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	for (i = 0, count = 0; i < DRM_MAX_ORDER+1; i++) {
+		if (dma->bufs[i].buf_count) ++count;
+	}
+	
+	DRM_DEBUG("count = %d\n", count);
+	
+	if (request.count >= count) {
+		for (i = 0, count = 0; i < DRM_MAX_ORDER+1; i++) {
+			if (dma->bufs[i].buf_count) {
+				if (copy_to_user(&request.list[count].count,
+						 &dma->bufs[i].buf_count,
+						 sizeof(dma->bufs[0]
+							.buf_count)) ||
+				    copy_to_user(&request.list[count].size,
+						 &dma->bufs[i].buf_size,
+						 sizeof(dma->bufs[0].buf_size)) ||
+				    copy_to_user(&request.list[count].low_mark,
+						 &dma->bufs[i]
+						 .freelist.low_mark,
+						 sizeof(dma->bufs[0]
+							.freelist.low_mark)) ||
+				    copy_to_user(&request.list[count]
+						 .high_mark,
+						 &dma->bufs[i]
+						 .freelist.high_mark,
+						 sizeof(dma->bufs[0]
+							.freelist.high_mark)))
+					return -EFAULT;
+
+				DRM_DEBUG("%d %d %d %d %d\n",
+					  i,
+					  dma->bufs[i].buf_count,
+					  dma->bufs[i].buf_size,
+					  dma->bufs[i].freelist.low_mark,
+					  dma->bufs[i].freelist.high_mark);
+				++count;
+			}
+		}
+	}
+	request.count = count;
+
+	if (copy_to_user((drm_buf_info_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+	
+	return 0;
+}
+
+int drm_markbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_desc_t	 request;
+	int		 order;
+	drm_buf_entry_t	 *entry;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	DRM_DEBUG("%d, %d, %d\n",
+		  request.size, request.low_mark, request.high_mark);
+	order = drm_order(request.size);
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	entry = &dma->bufs[order];
+
+	if (request.low_mark < 0 || request.low_mark > entry->buf_count)
+		return -EINVAL;
+	if (request.high_mark < 0 || request.high_mark > entry->buf_count)
+		return -EINVAL;
+
+	entry->freelist.low_mark  = request.low_mark;
+	entry->freelist.high_mark = request.high_mark;
+	
+	return 0;
+}
+
+int drm_freebufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_free_t	 request;
+	int		 i;
+	int		 idx;
+	drm_buf_t	 *buf;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_free_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	DRM_DEBUG("%d\n", request.count);
+	for (i = 0; i < request.count; i++) {
+		if (copy_from_user(&idx,
+				   &request.list[i],
+				   sizeof(idx)))
+			return -EFAULT;
+		if (idx < 0 || idx >= dma->buf_count) {
+			DRM_ERROR("Index %d (of %d max)\n",
+				  idx, dma->buf_count - 1);
+			return -EINVAL;
+		}
+		buf = dma->buflist[idx];
+		if (buf->pid != current->pid) {
+			DRM_ERROR("Process %d freeing buffer owned by %d\n",
+				  current->pid, buf->pid);
+			return -EINVAL;
+		}
+		drm_free_buffer(dev, buf);
+	}
+	
+	return 0;
+}
+
+int drm_mapbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	int		 retcode = 0;
+	const int	 zero	 = 0;
+	unsigned long	 virtual;
+	unsigned long	 address;
+	drm_buf_map_t	 request;
+	int		 i;
+
+	if (!dma) return -EINVAL;
+	
+	DRM_DEBUG("\n");
+
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	++dev->buf_use;		/* Can't allocate more after this call */
+	spin_unlock(&dev->count_lock);
+
+	if (copy_from_user(&request,
+			   (drm_buf_map_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	if (request.count >= dma->buf_count) {
+		down_write(&current->mm->mmap_sem);
+		virtual = do_mmap(filp, 0, dma->byte_count,
+				  PROT_READ|PROT_WRITE, MAP_SHARED, 0);
+		up_write(&current->mm->mmap_sem);
+		if (virtual > -1024UL) {
+				/* Real error */
+			retcode = (signed long)virtual;
+			goto done;
+		}
+		request.virtual = (void *)virtual;
+
+		for (i = 0; i < dma->buf_count; i++) {
+			if (copy_to_user(&request.list[i].idx,
+					 &dma->buflist[i]->idx,
+					 sizeof(request.list[0].idx))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].total,
+					 &dma->buflist[i]->total,
+					 sizeof(request.list[0].total))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].used,
+					 &zero,
+					 sizeof(zero))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			address = virtual + dma->buflist[i]->offset;
+			if (copy_to_user(&request.list[i].address,
+					 &address,
+					 sizeof(address))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+		}
+	}
+done:
+	request.count = dma->buf_count;
+	DRM_DEBUG("%d buffers, retcode = %d\n", request.count, retcode);
+
+	if (copy_to_user((drm_buf_map_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+
+	return retcode;
+}
diff -urN linux.orig/drivers/char/drm-4.0/context.c linux/drivers/char/drm-4.0/context.c
--- linux.orig/drivers/char/drm-4.0/context.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/context.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,321 @@
+/* context.c -- IOCTLs for contexts and DMA queues -*- linux-c -*-
+ * Created: Tue Feb  2 08:37:54 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+static int drm_init_queue(drm_device_t *dev, drm_queue_t *q, drm_ctx_t *ctx)
+{
+	DRM_DEBUG("\n");
+	
+	if (atomic_read(&q->use_count) != 1
+	    || atomic_read(&q->finalization)
+	    || atomic_read(&q->block_count)) {
+		DRM_ERROR("New queue is already in use: u%d f%d b%d\n",
+			  atomic_read(&q->use_count),
+			  atomic_read(&q->finalization),
+			  atomic_read(&q->block_count));
+	}
+		  
+	atomic_set(&q->finalization,  0);
+	atomic_set(&q->block_count,   0);
+	atomic_set(&q->block_read,    0);
+	atomic_set(&q->block_write,   0);
+	atomic_set(&q->total_queued,  0);
+	atomic_set(&q->total_flushed, 0);
+	atomic_set(&q->total_locks,   0);
+
+	init_waitqueue_head(&q->write_queue);
+	init_waitqueue_head(&q->read_queue);
+	init_waitqueue_head(&q->flush_queue);
+
+	q->flags = ctx->flags;
+
+	drm_waitlist_create(&q->waitlist, dev->dma->buf_count);
+
+	return 0;
+}
+
+
+/* drm_alloc_queue:
+PRE: 1) dev->queuelist[0..dev->queue_count] is allocated and will not
+	disappear (so all deallocation must be done after IOCTLs are off)
+     2) dev->queue_count < dev->queue_slots
+     3) dev->queuelist[i].use_count == 0 and
+	dev->queuelist[i].finalization == 0 if i not in use 
+POST: 1) dev->queuelist[i].use_count == 1
+      2) dev->queue_count < dev->queue_slots */
+		
+static int drm_alloc_queue(drm_device_t *dev)
+{
+	int	    i;
+	drm_queue_t *queue;
+	int	    oldslots;
+	int	    newslots;
+				/* Check for a free queue */
+	for (i = 0; i < dev->queue_count; i++) {
+		atomic_inc(&dev->queuelist[i]->use_count);
+		if (atomic_read(&dev->queuelist[i]->use_count) == 1
+		    && !atomic_read(&dev->queuelist[i]->finalization)) {
+			DRM_DEBUG("%d (free)\n", i);
+			return i;
+		}
+		atomic_dec(&dev->queuelist[i]->use_count);
+	}
+				/* Allocate a new queue */
+	
+	queue = drm_alloc(sizeof(*queue), DRM_MEM_QUEUES);
+	if(queue == NULL)
+		return -ENOMEM;	
+
+	memset(queue, 0, sizeof(*queue));
+	down(&dev->struct_sem);
+	atomic_set(&queue->use_count, 1);
+	
+	++dev->queue_count;
+	if (dev->queue_count >= dev->queue_slots) {
+		oldslots = dev->queue_slots * sizeof(*dev->queuelist);
+		if (!dev->queue_slots) dev->queue_slots = 1;
+		dev->queue_slots *= 2;
+		newslots = dev->queue_slots * sizeof(*dev->queuelist);
+
+		dev->queuelist = drm_realloc(dev->queuelist,
+					     oldslots,
+					     newslots,
+					     DRM_MEM_QUEUES);
+		if (!dev->queuelist) {
+			up(&dev->struct_sem);
+			DRM_DEBUG("out of memory\n");
+			return -ENOMEM;
+		}
+	}
+	dev->queuelist[dev->queue_count-1] = queue;
+	
+	up(&dev->struct_sem);
+	DRM_DEBUG("%d (new)\n", dev->queue_count - 1);
+	return dev->queue_count - 1;
+}
+
+int drm_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_res_t	res;
+	drm_ctx_t	ctx;
+	int		i;
+
+	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
+	if (copy_from_user(&res, (drm_ctx_res_t *)arg, sizeof(res)))
+		return -EFAULT;
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+			ctx.handle = i;
+			if (copy_to_user(&res.contexts[i],
+					 &i,
+					 sizeof(i)))
+				return -EFAULT;
+		}
+	}
+	res.count = DRM_RESERVED_CONTEXTS;
+	if (copy_to_user((drm_ctx_res_t *)arg, &res, sizeof(res)))
+		return -EFAULT;
+	return 0;
+}
+
+
+int drm_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	if ((ctx.handle = drm_alloc_queue(dev)) == DRM_KERNEL_CONTEXT) {
+				/* Init kernel's context and get a new one. */
+		drm_init_queue(dev, dev->queuelist[ctx.handle], &ctx);
+		ctx.handle = drm_alloc_queue(dev);
+	}
+	drm_init_queue(dev, dev->queuelist[ctx.handle], &ctx);
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int drm_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+	drm_queue_t	*q;
+		
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	
+	DRM_DEBUG("%d\n", ctx.handle);
+	
+	if (ctx.handle < 0 || ctx.handle >= dev->queue_count) return -EINVAL;
+	q = dev->queuelist[ctx.handle];
+	
+	atomic_inc(&q->use_count);
+	if (atomic_read(&q->use_count) == 1) {
+				/* No longer in use */
+		atomic_dec(&q->use_count);
+		return -EINVAL;
+	}
+
+	if (DRM_BUFCOUNT(&q->waitlist)) {
+		atomic_dec(&q->use_count);
+		return -EBUSY;
+	}
+	
+	q->flags = ctx.flags;
+	
+	atomic_dec(&q->use_count);
+	return 0;
+}
+
+int drm_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+	drm_queue_t	*q;
+		
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	
+	DRM_DEBUG("%d\n", ctx.handle);
+	
+	if (ctx.handle >= dev->queue_count) return -EINVAL;
+	q = dev->queuelist[ctx.handle];
+	
+	atomic_inc(&q->use_count);
+	if (atomic_read(&q->use_count) == 1) {
+				/* No longer in use */
+		atomic_dec(&q->use_count);
+		return -EINVAL;
+	}
+	
+	ctx.flags = q->flags;
+	atomic_dec(&q->use_count);
+	
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	
+	return 0;
+}
+
+int drm_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	return drm_context_switch(dev, dev->last_context, ctx.handle);
+}
+
+int drm_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	drm_context_switch_complete(dev, ctx.handle);
+
+	return 0;
+}
+
+int drm_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	      unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+	drm_queue_t	*q;
+	drm_buf_t	*buf;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	
+	if (ctx.handle >= dev->queue_count) return -EINVAL;
+	q = dev->queuelist[ctx.handle];
+	
+	atomic_inc(&q->use_count);
+	if (atomic_read(&q->use_count) == 1) {
+				/* No longer in use */
+		atomic_dec(&q->use_count);
+		return -EINVAL;
+	}
+	
+	atomic_inc(&q->finalization); /* Mark queue in finalization state */
+	atomic_sub(2, &q->use_count); /* Mark queue as unused (pending
+					 finalization) */
+
+	while (test_and_set_bit(0, &dev->interrupt_flag)) {
+		schedule();
+		if (signal_pending(current)) {
+			clear_bit(0, &dev->interrupt_flag);
+			return -EINTR;
+		}
+	}
+				/* Remove queued buffers */
+	while ((buf = drm_waitlist_get(&q->waitlist))) {
+		drm_free_buffer(dev, buf);
+	}
+	clear_bit(0, &dev->interrupt_flag);
+	
+				/* Wakeup blocked processes */
+	wake_up_interruptible(&q->read_queue);
+	wake_up_interruptible(&q->write_queue);
+	wake_up_interruptible(&q->flush_queue);
+	
+				/* Finalization over.  Queue is made
+				   available when both use_count and
+				   finalization become 0, which won't
+				   happen until all the waiting processes
+				   stop waiting. */
+	atomic_dec(&q->finalization);
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/ctxbitmap.c linux/drivers/char/drm-4.0/ctxbitmap.c
--- linux.orig/drivers/char/drm-4.0/ctxbitmap.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/ctxbitmap.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,85 @@
+/* ctxbitmap.c -- Context bitmap management -*- linux-c -*-
+ * Created: Thu Jan 6 03:56:42 2000 by jhartmann@precisioninsight.com
+ * 
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+void drm_ctxbitmap_free(drm_device_t *dev, int ctx_handle)
+{
+	if (ctx_handle < 0) goto failed;
+
+	if (ctx_handle < DRM_MAX_CTXBITMAP) {
+		clear_bit(ctx_handle, dev->ctx_bitmap);
+		return;
+	}
+failed:
+       	DRM_ERROR("Attempt to free invalid context handle: %d\n",
+		  ctx_handle);
+       	return;
+}
+
+int drm_ctxbitmap_next(drm_device_t *dev)
+{
+	int bit;
+
+	bit = find_first_zero_bit(dev->ctx_bitmap, DRM_MAX_CTXBITMAP);
+	if (bit < DRM_MAX_CTXBITMAP) {
+		set_bit(bit, dev->ctx_bitmap);
+	   	DRM_DEBUG("drm_ctxbitmap_next bit : %d\n", bit);
+		return bit;
+	}
+	return -1;
+}
+
+int drm_ctxbitmap_init(drm_device_t *dev)
+{
+	int i;
+   	int temp;
+
+	dev->ctx_bitmap = (unsigned long *) drm_alloc(PAGE_SIZE, 
+						      DRM_MEM_CTXBITMAP);
+	if(dev->ctx_bitmap == NULL) {
+		return -ENOMEM;
+	}
+	memset((void *) dev->ctx_bitmap, 0, PAGE_SIZE);
+	for(i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+		temp = drm_ctxbitmap_next(dev);
+	   	DRM_DEBUG("drm_ctxbitmap_init : %d\n", temp);
+	}
+
+	return 0;
+}
+
+void drm_ctxbitmap_cleanup(drm_device_t *dev)
+{
+	drm_free((void *)dev->ctx_bitmap, PAGE_SIZE,
+		 DRM_MEM_CTXBITMAP);
+}
+
diff -urN linux.orig/drivers/char/drm-4.0/dma.c linux/drivers/char/drm-4.0/dma.c
--- linux.orig/drivers/char/drm-4.0/dma.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/dma.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,546 @@
+/* dma.c -- DMA IOCTL and function support -*- linux-c -*-
+ * Created: Fri Mar 19 14:30:16 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinuxa.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+#include <linux/interrupt.h>	/* For task queue support */
+
+void drm_dma_setup(drm_device_t *dev)
+{
+	int i;
+	
+	if (!(dev->dma = drm_alloc(sizeof(*dev->dma), DRM_MEM_DRIVER))) {
+                printk(KERN_ERR "drm_dma_setup: can't drm_alloc dev->dma");
+                return;
+        }       
+	memset(dev->dma, 0, sizeof(*dev->dma));
+	for (i = 0; i <= DRM_MAX_ORDER; i++)
+		memset(&dev->dma->bufs[i], 0, sizeof(dev->dma->bufs[0]));
+}
+
+void drm_dma_takedown(drm_device_t *dev)
+{
+	drm_device_dma_t  *dma = dev->dma;
+	int		  i, j;
+
+	if (!dma) return;
+	
+				/* Clear dma buffers */
+	for (i = 0; i <= DRM_MAX_ORDER; i++) {
+		if (dma->bufs[i].seg_count) {
+			DRM_DEBUG("order %d: buf_count = %d,"
+				  " seg_count = %d\n",
+				  i,
+				  dma->bufs[i].buf_count,
+				  dma->bufs[i].seg_count);
+			for (j = 0; j < dma->bufs[i].seg_count; j++) {
+				drm_free_pages(dma->bufs[i].seglist[j],
+					       dma->bufs[i].page_order,
+					       DRM_MEM_DMA);
+			}
+			drm_free(dma->bufs[i].seglist,
+				 dma->bufs[i].seg_count
+				 * sizeof(*dma->bufs[0].seglist),
+				 DRM_MEM_SEGS);
+		}
+	   	if(dma->bufs[i].buf_count) {
+		   	for(j = 0; j < dma->bufs[i].buf_count; j++) {
+			   if(dma->bufs[i].buflist[j].dev_private) {
+			      drm_free(dma->bufs[i].buflist[j].dev_private,
+				       dma->bufs[i].buflist[j].dev_priv_size,
+				       DRM_MEM_BUFS);
+			   }
+			}
+		   	drm_free(dma->bufs[i].buflist,
+				 dma->bufs[i].buf_count *
+				 sizeof(*dma->bufs[0].buflist),
+				 DRM_MEM_BUFS);
+		   	drm_freelist_destroy(&dma->bufs[i].freelist);
+		}
+	}
+	
+	if (dma->buflist) {
+		drm_free(dma->buflist,
+			 dma->buf_count * sizeof(*dma->buflist),
+			 DRM_MEM_BUFS);
+	}
+
+	if (dma->pagelist) {
+		drm_free(dma->pagelist,
+			 dma->page_count * sizeof(*dma->pagelist),
+			 DRM_MEM_PAGES);
+	}
+	drm_free(dev->dma, sizeof(*dev->dma), DRM_MEM_DRIVER);
+	dev->dma = NULL;
+}
+
+#if DRM_DMA_HISTOGRAM
+/* This is slow, but is useful for debugging. */
+int drm_histogram_slot(unsigned long count)
+{
+	int value = DRM_DMA_HISTOGRAM_INITIAL;
+	int slot;
+
+	for (slot = 0;
+	     slot < DRM_DMA_HISTOGRAM_SLOTS;
+	     ++slot, value = DRM_DMA_HISTOGRAM_NEXT(value)) {
+		if (count < value) return slot;
+	}
+	return DRM_DMA_HISTOGRAM_SLOTS - 1;
+}
+
+void drm_histogram_compute(drm_device_t *dev, drm_buf_t *buf)
+{
+	cycles_t queued_to_dispatched;
+	cycles_t dispatched_to_completed;
+	cycles_t completed_to_freed;
+	int	 q2d, d2c, c2f, q2c, q2f;
+	
+	if (buf->time_queued) {
+		queued_to_dispatched	= (buf->time_dispatched
+					   - buf->time_queued);
+		dispatched_to_completed = (buf->time_completed
+					   - buf->time_dispatched);
+		completed_to_freed	= (buf->time_freed
+					   - buf->time_completed);
+
+		q2d = drm_histogram_slot(queued_to_dispatched);
+		d2c = drm_histogram_slot(dispatched_to_completed);
+		c2f = drm_histogram_slot(completed_to_freed);
+
+		q2c = drm_histogram_slot(queued_to_dispatched
+					 + dispatched_to_completed);
+		q2f = drm_histogram_slot(queued_to_dispatched
+					 + dispatched_to_completed
+					 + completed_to_freed);
+		
+		atomic_inc(&dev->histo.total);
+		atomic_inc(&dev->histo.queued_to_dispatched[q2d]);
+		atomic_inc(&dev->histo.dispatched_to_completed[d2c]);
+		atomic_inc(&dev->histo.completed_to_freed[c2f]);
+		
+		atomic_inc(&dev->histo.queued_to_completed[q2c]);
+		atomic_inc(&dev->histo.queued_to_freed[q2f]);
+
+	}
+	buf->time_queued     = 0;
+	buf->time_dispatched = 0;
+	buf->time_completed  = 0;
+	buf->time_freed	     = 0;
+}
+#endif
+
+void drm_free_buffer(drm_device_t *dev, drm_buf_t *buf)
+{
+	drm_device_dma_t *dma = dev->dma;
+
+	if (!buf) return;
+	
+	buf->waiting  = 0;
+	buf->pending  = 0;
+	buf->pid      = 0;
+	buf->used     = 0;
+#if DRM_DMA_HISTOGRAM
+	buf->time_completed = get_cycles();
+#endif
+	if (waitqueue_active(&buf->dma_wait)) {
+		wake_up_interruptible(&buf->dma_wait);
+	} else {
+				/* If processes are waiting, the last one
+				   to wake will put the buffer on the free
+				   list.  If no processes are waiting, we
+				   put the buffer on the freelist here. */
+		drm_freelist_put(dev, &dma->bufs[buf->order].freelist, buf);
+	}
+}
+
+void drm_reclaim_buffers(drm_device_t *dev, pid_t pid)
+{
+	drm_device_dma_t *dma = dev->dma;
+	int		 i;
+
+	if (!dma) return;
+	for (i = 0; i < dma->buf_count; i++) {
+		if (dma->buflist[i]->pid == pid) {
+			switch (dma->buflist[i]->list) {
+			case DRM_LIST_NONE:
+				drm_free_buffer(dev, dma->buflist[i]);
+				break;
+			case DRM_LIST_WAIT:
+				dma->buflist[i]->list = DRM_LIST_RECLAIM;
+				break;
+			default:
+				/* Buffer already on hardware. */
+				break;
+			}
+		}
+	}
+}
+
+int drm_context_switch(drm_device_t *dev, int old, int new)
+{
+	char	    buf[64];
+	drm_queue_t *q;
+
+	atomic_inc(&dev->total_ctx);
+
+	if (test_and_set_bit(0, &dev->context_flag)) {
+		DRM_ERROR("Reentering -- FIXME\n");
+		return -EBUSY;
+	}
+
+#if DRM_DMA_HISTOGRAM
+	dev->ctx_start = get_cycles();
+#endif
+	
+	DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+	if (new >= dev->queue_count) {
+		clear_bit(0, &dev->context_flag);
+		return -EINVAL;
+	}
+
+	if (new == dev->last_context) {
+		clear_bit(0, &dev->context_flag);
+		return 0;
+	}
+	
+	q = dev->queuelist[new];
+	atomic_inc(&q->use_count);
+	if (atomic_read(&q->use_count) == 1) {
+		atomic_dec(&q->use_count);
+		clear_bit(0, &dev->context_flag);
+		return -EINVAL;
+	}
+
+	if (drm_flags & DRM_FLAG_NOCTX) {
+		drm_context_switch_complete(dev, new);
+	} else {
+		sprintf(buf, "C %d %d\n", old, new);
+		drm_write_string(dev, buf);
+	}
+	
+	atomic_dec(&q->use_count);
+	
+	return 0;
+}
+
+int drm_context_switch_complete(drm_device_t *dev, int new)
+{
+	drm_device_dma_t *dma = dev->dma;
+	
+	dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
+	dev->last_switch  = jiffies;
+	
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("Lock isn't held after context switch\n");
+	}
+
+	if (!dma || !(dma->next_buffer && dma->next_buffer->while_locked)) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("Cannot free lock\n");
+		}
+	}
+	
+#if DRM_DMA_HISTOGRAM
+	atomic_inc(&dev->histo.ctx[drm_histogram_slot(get_cycles()
+						      - dev->ctx_start)]);
+		   
+#endif
+	clear_bit(0, &dev->context_flag);
+	wake_up_interruptible(&dev->context_wait);
+	
+	return 0;
+}
+
+void drm_clear_next_buffer(drm_device_t *dev)
+{
+	drm_device_dma_t *dma = dev->dma;
+	
+	dma->next_buffer = NULL;
+	if (dma->next_queue && !DRM_BUFCOUNT(&dma->next_queue->waitlist)) {
+		wake_up_interruptible(&dma->next_queue->flush_queue);
+	}
+	dma->next_queue	 = NULL;
+}
+
+
+int drm_select_queue(drm_device_t *dev, void (*wrapper)(unsigned long))
+{
+	int	   i;
+	int	   candidate = -1;
+	int	   j	     = jiffies;
+
+	if (!dev) {
+		DRM_ERROR("No device\n");
+		return -1;
+	}
+	if (!dev->queuelist || !dev->queuelist[DRM_KERNEL_CONTEXT]) {
+				/* This only happens between the time the
+				   interrupt is initialized and the time
+				   the queues are initialized. */
+		return -1;
+	}
+
+				/* Doing "while locked" DMA? */
+	if (DRM_WAITCOUNT(dev, DRM_KERNEL_CONTEXT)) {
+		return DRM_KERNEL_CONTEXT;
+	}
+
+				/* If there are buffers on the last_context
+				   queue, and we have not been executing
+				   this context very long, continue to
+				   execute this context. */
+	if (dev->last_switch <= j
+	    && dev->last_switch + DRM_TIME_SLICE > j
+	    && DRM_WAITCOUNT(dev, dev->last_context)) {
+		return dev->last_context;
+	}
+
+				/* Otherwise, find a candidate */
+	for (i = dev->last_checked + 1; i < dev->queue_count; i++) {
+		if (DRM_WAITCOUNT(dev, i)) {
+			candidate = dev->last_checked = i;
+			break;
+		}
+	}
+
+	if (candidate < 0) {
+		for (i = 0; i < dev->queue_count; i++) {
+			if (DRM_WAITCOUNT(dev, i)) {
+				candidate = dev->last_checked = i;
+				break;
+			}
+		}
+	}
+
+	if (wrapper
+	    && candidate >= 0
+	    && candidate != dev->last_context
+	    && dev->last_switch <= j
+	    && dev->last_switch + DRM_TIME_SLICE > j) {
+		if (dev->timer.expires != dev->last_switch + DRM_TIME_SLICE) {
+			del_timer(&dev->timer);
+			dev->timer.function = wrapper;
+			dev->timer.data	    = (unsigned long)dev;
+			dev->timer.expires  = dev->last_switch+DRM_TIME_SLICE;
+			add_timer(&dev->timer);
+		}
+		return -1;
+	}
+
+	return candidate;
+}
+
+
+int drm_dma_enqueue(drm_device_t *dev, drm_dma_t *d)
+{
+	int		  i;
+	drm_queue_t	  *q;
+	drm_buf_t	  *buf;
+	int		  idx;
+	int		  while_locked = 0;
+	drm_device_dma_t  *dma = dev->dma;
+	DECLARE_WAITQUEUE(entry, current);
+
+	DRM_DEBUG("%d\n", d->send_count);
+
+	if (d->flags & _DRM_DMA_WHILE_LOCKED) {
+		int context = dev->lock.hw_lock->lock;
+		
+		if (!_DRM_LOCK_IS_HELD(context)) {
+			DRM_ERROR("No lock held during \"while locked\""
+				  " request\n");
+			return -EINVAL;
+		}
+		if (d->context != _DRM_LOCKING_CONTEXT(context)
+		    && _DRM_LOCKING_CONTEXT(context) != DRM_KERNEL_CONTEXT) {
+			DRM_ERROR("Lock held by %d while %d makes"
+				  " \"while locked\" request\n",
+				  _DRM_LOCKING_CONTEXT(context),
+				  d->context);
+			return -EINVAL;
+		}
+		q = dev->queuelist[DRM_KERNEL_CONTEXT];
+		while_locked = 1;
+	} else {
+		q = dev->queuelist[d->context];
+	}
+
+
+	atomic_inc(&q->use_count);
+	if (atomic_read(&q->block_write)) {
+		add_wait_queue(&q->write_queue, &entry);
+		atomic_inc(&q->block_count);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!atomic_read(&q->block_write)) break;
+			schedule();
+			if (signal_pending(current)) {
+				atomic_dec(&q->use_count);
+				remove_wait_queue(&q->write_queue, &entry);
+				return -EINTR;
+			}
+		}
+		atomic_dec(&q->block_count);
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&q->write_queue, &entry);
+	}
+	
+	for (i = 0; i < d->send_count; i++) {
+		idx = d->send_indices[i];
+		if (idx < 0 || idx >= dma->buf_count) {
+			atomic_dec(&q->use_count);
+			DRM_ERROR("Index %d (of %d max)\n",
+				  d->send_indices[i], dma->buf_count - 1);
+			return -EINVAL;
+		}
+		buf = dma->buflist[ idx ];
+		if (buf->pid != current->pid) {
+			atomic_dec(&q->use_count);
+			DRM_ERROR("Process %d using buffer owned by %d\n",
+				  current->pid, buf->pid);
+			return -EINVAL;
+		}
+		if (buf->list != DRM_LIST_NONE) {
+			atomic_dec(&q->use_count);
+			DRM_ERROR("Process %d using buffer %d on list %d\n",
+				  current->pid, buf->idx, buf->list);
+		}
+		buf->used	  = d->send_sizes[i];
+		buf->while_locked = while_locked;
+		buf->context	  = d->context;
+		if (!buf->used) {
+			DRM_ERROR("Queueing 0 length buffer\n");
+		}
+		if (buf->pending) {
+			atomic_dec(&q->use_count);
+			DRM_ERROR("Queueing pending buffer:"
+				  " buffer %d, offset %d\n",
+				  d->send_indices[i], i);
+			return -EINVAL;
+		}
+		if (buf->waiting) {
+			atomic_dec(&q->use_count);
+			DRM_ERROR("Queueing waiting buffer:"
+				  " buffer %d, offset %d\n",
+				  d->send_indices[i], i);
+			return -EINVAL;
+		}
+		buf->waiting = 1;
+		if (atomic_read(&q->use_count) == 1
+		    || atomic_read(&q->finalization)) {
+			drm_free_buffer(dev, buf);
+		} else {
+			drm_waitlist_put(&q->waitlist, buf);
+			atomic_inc(&q->total_queued);
+		}
+	}
+	atomic_dec(&q->use_count);
+	
+	return 0;
+}
+
+static int drm_dma_get_buffers_of_order(drm_device_t *dev, drm_dma_t *d,
+					int order)
+{
+	int		  i;
+	drm_buf_t	  *buf;
+	drm_device_dma_t  *dma = dev->dma;
+	
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = drm_freelist_get(&dma->bufs[order].freelist,
+				       d->flags & _DRM_DMA_WAIT);
+		if (!buf) break;
+		if (buf->pending || buf->waiting) {
+			DRM_ERROR("Free buffer %d in use by %d (w%d, p%d)\n",
+				  buf->idx,
+				  buf->pid,
+				  buf->waiting,
+				  buf->pending);
+		}
+		buf->pid     = current->pid;
+		if (copy_to_user(&d->request_indices[i],
+				 &buf->idx,
+				 sizeof(buf->idx)))
+			return -EFAULT;
+
+		if (copy_to_user(&d->request_sizes[i],
+				 &buf->total,
+				 sizeof(buf->total)))
+			return -EFAULT;
+
+		++d->granted_count;
+	}
+	return 0;
+}
+
+
+int drm_dma_get_buffers(drm_device_t *dev, drm_dma_t *dma)
+{
+	int		  order;
+	int		  retcode = 0;
+	int		  tmp_order;
+	
+	order = drm_order(dma->request_size);
+
+	dma->granted_count = 0;
+	retcode		   = drm_dma_get_buffers_of_order(dev, dma, order);
+
+	if (dma->granted_count < dma->request_count
+	    && (dma->flags & _DRM_DMA_SMALLER_OK)) {
+		for (tmp_order = order - 1;
+		     !retcode
+			     && dma->granted_count < dma->request_count
+			     && tmp_order >= DRM_MIN_ORDER;
+		     --tmp_order) {
+			
+			retcode = drm_dma_get_buffers_of_order(dev, dma,
+							       tmp_order);
+		}
+	}
+
+	if (dma->granted_count < dma->request_count
+	    && (dma->flags & _DRM_DMA_LARGER_OK)) {
+		for (tmp_order = order + 1;
+		     !retcode
+			     && dma->granted_count < dma->request_count
+			     && tmp_order <= DRM_MAX_ORDER;
+		     ++tmp_order) {
+			
+			retcode = drm_dma_get_buffers_of_order(dev, dma,
+							       tmp_order);
+		}
+	}
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/drawable.c linux/drivers/char/drm-4.0/drawable.c
--- linux.orig/drivers/char/drm-4.0/drawable.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/drawable.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,51 @@
+/* drawable.c -- IOCTLs for drawables -*- linux-c -*-
+ * Created: Tue Feb  2 08:37:54 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+int drm_adddraw(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_draw_t draw;
+
+	draw.handle = 0;	/* NOOP */
+	DRM_DEBUG("%d\n", draw.handle);
+	if (copy_to_user((drm_draw_t *)arg, &draw, sizeof(draw)))
+		return -EFAULT;
+	return 0;
+}
+
+int drm_rmdraw(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	return 0;		/* NOOP */
+}
diff -urN linux.orig/drivers/char/drm-4.0/drm.h linux/drivers/char/drm-4.0/drm.h
--- linux.orig/drivers/char/drm-4.0/drm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/drm.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,414 @@
+/* drm.h -- Header for Direct Rendering Manager -*- linux-c -*-
+ * Created: Mon Jan  4 10:05:05 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ * Acknowledgements:
+ * Dec 1999, Richard Henderson <rth@twiddle.net>, move to generic cmpxchg.
+ *
+ */
+
+#ifndef _DRM_H_
+#define _DRM_H_
+
+#include <linux/config.h>
+#if defined(__linux__)
+#include <asm/ioctl.h>		/* For _IO* macros */
+#define DRM_IOCTL_NR(n)	     _IOC_NR(n)
+#elif defined(__FreeBSD__)
+#include <sys/ioccom.h>
+#define DRM_IOCTL_NR(n)	     ((n) & 0xff)
+#endif
+
+#define DRM_PROC_DEVICES "/proc/devices"
+#define DRM_PROC_MISC	 "/proc/misc"
+#define DRM_PROC_DRM	 "/proc/drm"
+#define DRM_DEV_DRM	 "/dev/drm"
+#define DRM_DEV_MODE	 (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP)
+#define DRM_DEV_UID	 0
+#define DRM_DEV_GID	 0
+
+
+#define DRM_NAME	"drm"	  /* Name in kernel, /dev, and /proc	    */
+#define DRM_MIN_ORDER	5	  /* At least 2^5 bytes = 32 bytes	    */
+#define DRM_MAX_ORDER	22	  /* Up to 2^22 bytes = 4MB		    */
+#define DRM_RAM_PERCENT 10	  /* How much system ram can we lock?	    */
+
+#define _DRM_LOCK_HELD	0x80000000 /* Hardware lock is held		    */
+#define _DRM_LOCK_CONT	0x40000000 /* Hardware lock is contended	    */
+#define _DRM_LOCK_IS_HELD(lock)	   ((lock) & _DRM_LOCK_HELD)
+#define _DRM_LOCK_IS_CONT(lock)	   ((lock) & _DRM_LOCK_CONT)
+#define _DRM_LOCKING_CONTEXT(lock) ((lock) & ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))
+
+typedef unsigned long drm_handle_t;
+typedef unsigned int  drm_context_t;
+typedef unsigned int  drm_drawable_t;
+typedef unsigned int  drm_magic_t;
+
+/* Warning: If you change this structure, make sure you change
+ * XF86DRIClipRectRec in the server as well */
+
+typedef struct drm_clip_rect {
+           unsigned short x1;
+           unsigned short y1;
+           unsigned short x2;
+           unsigned short y2;
+} drm_clip_rect_t;
+
+/* Seperate include files for the i810/mga/r128 specific structures */
+#include "mga_drm.h"
+#include "i810_drm.h"
+#include "r128_drm.h"
+#include "radeon_drm.h"
+#ifdef CONFIG_DRM40_SIS
+#include "sis_drm.h"
+#endif
+
+typedef struct drm_version {
+	int    version_major;	  /* Major version			    */
+	int    version_minor;	  /* Minor version			    */
+	int    version_patchlevel;/* Patch level			    */
+	size_t name_len;	  /* Length of name buffer		    */
+	char   *name;		  /* Name of driver			    */
+	size_t date_len;	  /* Length of date buffer		    */
+	char   *date;		  /* User-space buffer to hold date	    */
+	size_t desc_len;	  /* Length of desc buffer		    */
+	char   *desc;		  /* User-space buffer to hold desc	    */
+} drm_version_t;
+
+typedef struct drm_unique {
+	size_t unique_len;	  /* Length of unique			    */
+	char   *unique;		  /* Unique name for driver instantiation   */
+} drm_unique_t;
+
+typedef struct drm_list {
+	int		 count;	  /* Length of user-space structures	    */
+	drm_version_t	 *version;
+} drm_list_t;
+
+typedef struct drm_block {
+	int		 unused;
+} drm_block_t;
+
+typedef struct drm_control {
+	enum {
+		DRM_ADD_COMMAND,
+		DRM_RM_COMMAND,
+		DRM_INST_HANDLER,
+		DRM_UNINST_HANDLER
+	}		 func;
+	int		 irq;
+} drm_control_t;
+
+typedef enum drm_map_type {
+	_DRM_FRAME_BUFFER = 0,	  /* WC (no caching), no core dump	    */
+	_DRM_REGISTERS	  = 1,	  /* no caching, no core dump		    */
+	_DRM_SHM	  = 2,	  /* shared, cached			    */
+	_DRM_AGP          = 3	  /* AGP/GART                               */
+} drm_map_type_t;
+
+typedef enum drm_map_flags {
+	_DRM_RESTRICTED	     = 0x01, /* Cannot be mapped to user-virtual    */
+	_DRM_READ_ONLY	     = 0x02,
+	_DRM_LOCKED	     = 0x04, /* shared, cached, locked		    */
+	_DRM_KERNEL	     = 0x08, /* kernel requires access		    */
+	_DRM_WRITE_COMBINING = 0x10, /* use write-combining if available    */
+	_DRM_CONTAINS_LOCK   = 0x20  /* SHM page that contains lock	    */
+} drm_map_flags_t;
+
+typedef struct drm_map {
+	unsigned long	offset;	 /* Requested physical address (0 for SAREA)*/
+	unsigned long	size;	 /* Requested physical size (bytes)	    */
+	drm_map_type_t	type;	 /* Type of memory to map		    */
+	drm_map_flags_t flags;	 /* Flags				    */
+	void		*handle; /* User-space: "Handle" to pass to mmap    */
+				 /* Kernel-space: kernel-virtual address    */
+	int		mtrr;	 /* MTRR slot used			    */
+				 /* Private data			    */
+} drm_map_t;
+
+typedef enum drm_lock_flags {
+	_DRM_LOCK_READY	     = 0x01, /* Wait until hardware is ready for DMA */
+	_DRM_LOCK_QUIESCENT  = 0x02, /* Wait until hardware quiescent	     */
+	_DRM_LOCK_FLUSH	     = 0x04, /* Flush this context's DMA queue first */
+	_DRM_LOCK_FLUSH_ALL  = 0x08, /* Flush all DMA queues first	     */
+				/* These *HALT* flags aren't supported yet
+				   -- they will be used to support the
+				   full-screen DGA-like mode. */
+	_DRM_HALT_ALL_QUEUES = 0x10, /* Halt all current and future queues   */
+	_DRM_HALT_CUR_QUEUES = 0x20  /* Halt all current queues		     */
+} drm_lock_flags_t;
+
+typedef struct drm_lock {
+	int		 context;
+	drm_lock_flags_t flags;
+} drm_lock_t;
+
+typedef enum drm_dma_flags {	      /* These values *MUST* match xf86drm.h */
+				      /* Flags for DMA buffer dispatch	     */
+	_DRM_DMA_BLOCK	      = 0x01, /* Block until buffer dispatched.
+					 Note, the buffer may not yet have
+					 been processed by the hardware --
+					 getting a hardware lock with the
+					 hardware quiescent will ensure
+					 that the buffer has been
+					 processed.			     */
+	_DRM_DMA_WHILE_LOCKED = 0x02, /* Dispatch while lock held	     */
+	_DRM_DMA_PRIORITY     = 0x04, /* High priority dispatch		     */
+
+				      /* Flags for DMA buffer request	     */
+	_DRM_DMA_WAIT	      = 0x10, /* Wait for free buffers		     */
+	_DRM_DMA_SMALLER_OK   = 0x20, /* Smaller-than-requested buffers ok   */
+	_DRM_DMA_LARGER_OK    = 0x40  /* Larger-than-requested buffers ok    */
+} drm_dma_flags_t;
+
+typedef struct drm_buf_desc {
+	int	      count;	 /* Number of buffers of this size	     */
+	int	      size;	 /* Size in bytes			     */
+	int	      low_mark;	 /* Low water mark			     */
+	int	      high_mark; /* High water mark			     */
+	enum {
+		_DRM_PAGE_ALIGN = 0x01, /* Align on page boundaries for DMA  */
+		_DRM_AGP_BUFFER = 0x02  /* Buffer is in agp space            */
+	}	      flags;
+	unsigned long agp_start; /* Start address of where the agp buffers
+				  * are in the agp aperture */
+} drm_buf_desc_t;
+
+typedef struct drm_buf_info {
+	int	       count;	/* Entries in list			     */
+	drm_buf_desc_t *list;
+} drm_buf_info_t;
+
+typedef struct drm_buf_free {
+	int	       count;
+	int	       *list;
+} drm_buf_free_t;
+
+typedef struct drm_buf_pub {
+	int		  idx;	       /* Index into master buflist	     */
+	int		  total;       /* Buffer size			     */
+	int		  used;	       /* Amount of buffer in use (for DMA)  */
+	void		  *address;    /* Address of buffer		     */
+} drm_buf_pub_t;
+
+typedef struct drm_buf_map {
+	int	      count;	/* Length of buflist			    */
+	void	      *virtual;	/* Mmaped area in user-virtual		    */
+	drm_buf_pub_t *list;	/* Buffer information			    */
+} drm_buf_map_t;
+
+typedef struct drm_dma {
+				/* Indices here refer to the offset into
+				   buflist in drm_buf_get_t.  */
+	int		context;	  /* Context handle		    */
+	int		send_count;	  /* Number of buffers to send	    */
+	int		*send_indices;	  /* List of handles to buffers	    */
+	int		*send_sizes;	  /* Lengths of data to send	    */
+	drm_dma_flags_t flags;		  /* Flags			    */
+	int		request_count;	  /* Number of buffers requested    */
+	int		request_size;	  /* Desired size for buffers	    */
+	int		*request_indices; /* Buffer information		    */
+	int		*request_sizes;
+	int		granted_count;	  /* Number of buffers granted	    */
+} drm_dma_t;
+
+typedef enum {
+	_DRM_CONTEXT_PRESERVED = 0x01,
+	_DRM_CONTEXT_2DONLY    = 0x02
+} drm_ctx_flags_t;
+
+typedef struct drm_ctx {
+	drm_context_t	handle;
+	drm_ctx_flags_t flags;
+} drm_ctx_t;
+
+typedef struct drm_ctx_res {
+	int		count;
+	drm_ctx_t	*contexts;
+} drm_ctx_res_t;
+
+typedef struct drm_draw {
+	drm_drawable_t	handle;
+} drm_draw_t;
+
+typedef struct drm_auth {
+	drm_magic_t	magic;
+} drm_auth_t;
+
+typedef struct drm_irq_busid {
+	int irq;
+	int busnum;
+	int devnum;
+	int funcnum;
+} drm_irq_busid_t;
+
+typedef struct drm_agp_mode {
+	unsigned long mode;
+} drm_agp_mode_t;
+
+				/* For drm_agp_alloc -- allocated a buffer */
+typedef struct drm_agp_buffer {
+	unsigned long size;	/* In bytes -- will round to page boundary */
+	unsigned long handle;	/* Used for BIND/UNBIND ioctls */
+	unsigned long type;     /* Type of memory to allocate  */
+        unsigned long physical; /* Physical used by i810       */
+} drm_agp_buffer_t;
+
+				/* For drm_agp_bind */
+typedef struct drm_agp_binding {
+	unsigned long handle;   /* From drm_agp_buffer */
+	unsigned long offset;	/* In bytes -- will round to page boundary */
+} drm_agp_binding_t;
+
+typedef struct drm_agp_info {
+	int            agp_version_major;
+	int            agp_version_minor;
+	unsigned long  mode;
+	unsigned long  aperture_base;  /* physical address */
+	unsigned long  aperture_size;  /* bytes */
+	unsigned long  memory_allowed; /* bytes */
+	unsigned long  memory_used;
+
+				/* PCI information */
+	unsigned short id_vendor;
+	unsigned short id_device;
+} drm_agp_info_t;
+
+#define DRM_IOCTL_BASE			'd'
+#define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)
+#define DRM_IOR(nr,size)		_IOR(DRM_IOCTL_BASE,nr,size)
+#define DRM_IOW(nr,size)		_IOW(DRM_IOCTL_BASE,nr,size)
+#define DRM_IOWR(nr,size)		_IOWR(DRM_IOCTL_BASE,nr,size)
+
+
+#define DRM_IOCTL_VERSION		DRM_IOWR(0x00, drm_version_t)
+#define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, drm_unique_t)
+#define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, drm_auth_t)
+#define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, drm_irq_busid_t)
+
+#define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, drm_unique_t)
+#define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, drm_auth_t)
+#define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, drm_block_t)
+#define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, drm_block_t)
+#define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, drm_control_t)
+#define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, drm_map_t)
+#define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, drm_buf_desc_t)
+#define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, drm_buf_desc_t)
+#define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, drm_buf_info_t)
+#define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, drm_buf_map_t)
+#define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, drm_buf_free_t)
+
+#define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, drm_ctx_t)
+#define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, drm_ctx_t)
+#define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, drm_ctx_t)
+#define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, drm_ctx_t)
+#define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, drm_ctx_t)
+#define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, drm_ctx_t)
+#define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, drm_ctx_res_t)
+#define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, drm_draw_t)
+#define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, drm_draw_t)
+#define DRM_IOCTL_DMA			DRM_IOWR(0x29, drm_dma_t)
+#define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, drm_lock_t)
+#define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, drm_lock_t)
+#define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, drm_lock_t)
+
+#define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)
+#define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)
+#define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, drm_agp_mode_t)
+#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, drm_agp_info_t)
+#define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, drm_agp_buffer_t)
+#define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, drm_agp_buffer_t)
+#define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, drm_agp_binding_t)
+#define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, drm_agp_binding_t)
+
+/* Mga specific ioctls */
+#define DRM_IOCTL_MGA_INIT		DRM_IOW( 0x40, drm_mga_init_t)
+#define DRM_IOCTL_MGA_SWAP		DRM_IOW( 0x41, drm_mga_swap_t)
+#define DRM_IOCTL_MGA_CLEAR		DRM_IOW( 0x42, drm_mga_clear_t)
+#define DRM_IOCTL_MGA_ILOAD		DRM_IOW( 0x43, drm_mga_iload_t)
+#define DRM_IOCTL_MGA_VERTEX		DRM_IOW( 0x44, drm_mga_vertex_t)
+#define DRM_IOCTL_MGA_FLUSH		DRM_IOW( 0x45, drm_lock_t )
+#define DRM_IOCTL_MGA_INDICES		DRM_IOW( 0x46, drm_mga_indices_t)
+#define DRM_IOCTL_MGA_BLIT		DRM_IOW( 0x47, drm_mga_blit_t)
+
+/* I810 specific ioctls */
+#define DRM_IOCTL_I810_INIT		DRM_IOW( 0x40, drm_i810_init_t)
+#define DRM_IOCTL_I810_VERTEX		DRM_IOW( 0x41, drm_i810_vertex_t)
+#define DRM_IOCTL_I810_CLEAR		DRM_IOW( 0x42, drm_i810_clear_t)
+#define DRM_IOCTL_I810_FLUSH		DRM_IO(  0x43)
+#define DRM_IOCTL_I810_GETAGE		DRM_IO(  0x44)
+#define DRM_IOCTL_I810_GETBUF		DRM_IOWR(0x45, drm_i810_dma_t)
+#define DRM_IOCTL_I810_SWAP		DRM_IO(  0x46)
+#define DRM_IOCTL_I810_COPY		DRM_IOW( 0x47, drm_i810_copy_t)
+#define DRM_IOCTL_I810_DOCOPY		DRM_IO(  0x48)
+
+/* Rage 128 specific ioctls */
+#define DRM_IOCTL_R128_INIT		DRM_IOW( 0x40, drm_r128_init_t)
+#define DRM_IOCTL_R128_CCE_START	DRM_IO(  0x41)
+#define DRM_IOCTL_R128_CCE_STOP		DRM_IOW( 0x42, drm_r128_cce_stop_t)
+#define DRM_IOCTL_R128_CCE_RESET	DRM_IO(  0x43)
+#define DRM_IOCTL_R128_CCE_IDLE		DRM_IO(  0x44)
+#define DRM_IOCTL_R128_RESET		DRM_IO(  0x46)
+#define DRM_IOCTL_R128_SWAP		DRM_IO(  0x47)
+#define DRM_IOCTL_R128_CLEAR		DRM_IOW( 0x48, drm_r128_clear_t)
+#define DRM_IOCTL_R128_VERTEX		DRM_IOW( 0x49, drm_r128_vertex_t)
+#define DRM_IOCTL_R128_INDICES		DRM_IOW( 0x4a, drm_r128_indices_t)
+#define DRM_IOCTL_R128_BLIT		DRM_IOW( 0x4b, drm_r128_blit_t)
+#define DRM_IOCTL_R128_DEPTH		DRM_IOW( 0x4c, drm_r128_depth_t)
+#define DRM_IOCTL_R128_STIPPLE		DRM_IOW( 0x4d, drm_r128_stipple_t)
+#define DRM_IOCTL_R128_PACKET		DRM_IOWR(0x4e, drm_r128_packet_t)
+
+/* Radeon specific ioctls */
+#define DRM_IOCTL_RADEON_CP_INIT	DRM_IOW( 0x40, drm_radeon_init_t)
+#define DRM_IOCTL_RADEON_CP_START	DRM_IO(  0x41)
+#define DRM_IOCTL_RADEON_CP_STOP	DRM_IOW( 0x42, drm_radeon_cp_stop_t)
+#define DRM_IOCTL_RADEON_CP_RESET	DRM_IO(  0x43)
+#define DRM_IOCTL_RADEON_CP_IDLE	DRM_IO(  0x44)
+#define DRM_IOCTL_RADEON_RESET		DRM_IO(  0x45)
+#define DRM_IOCTL_RADEON_FULLSCREEN	DRM_IOW( 0x46, drm_radeon_fullscreen_t)
+#define DRM_IOCTL_RADEON_SWAP		DRM_IO(  0x47)
+#define DRM_IOCTL_RADEON_CLEAR		DRM_IOW( 0x48, drm_radeon_clear_t)
+#define DRM_IOCTL_RADEON_VERTEX		DRM_IOW( 0x49, drm_radeon_vertex_t)
+#define DRM_IOCTL_RADEON_INDICES	DRM_IOW( 0x4a, drm_radeon_indices_t)
+#define DRM_IOCTL_RADEON_BLIT		DRM_IOW( 0x4b, drm_radeon_blit_t)
+#define DRM_IOCTL_RADEON_STIPPLE	DRM_IOW( 0x4c, drm_radeon_stipple_t)
+#define DRM_IOCTL_RADEON_INDIRECT	DRM_IOWR(0x4d, drm_radeon_indirect_t)
+
+#ifdef CONFIG_DRM40_SIS
+/* SiS specific ioctls */
+#define SIS_IOCTL_FB_ALLOC		DRM_IOWR(0x44, drm_sis_mem_t)
+#define SIS_IOCTL_FB_FREE		DRM_IOW( 0x45, drm_sis_mem_t)
+#define SIS_IOCTL_AGP_INIT		DRM_IOWR(0x53, drm_sis_agp_t)
+#define SIS_IOCTL_AGP_ALLOC		DRM_IOWR(0x54, drm_sis_mem_t)
+#define SIS_IOCTL_AGP_FREE		DRM_IOW( 0x55, drm_sis_mem_t)
+#define SIS_IOCTL_FLIP			DRM_IOW( 0x48, drm_sis_flip_t)
+#define SIS_IOCTL_FLIP_INIT		DRM_IO(  0x49)
+#define SIS_IOCTL_FLIP_FINAL		DRM_IO(  0x50)
+#endif
+
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/drmP.h linux/drivers/char/drm-4.0/drmP.h
--- linux.orig/drivers/char/drm-4.0/drmP.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/drmP.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,839 @@
+/* drmP.h -- Private header for Direct Rendering Manager -*- linux-c -*-
+ * Created: Mon Jan  4 10:05:05 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#ifndef _DRM_P_H_
+#define _DRM_P_H_
+
+#ifdef __KERNEL__
+#ifdef __alpha__
+/* add include of current.h so that "current" is defined
+ * before static inline funcs in wait.h. Doing this so we
+ * can build the DRM (part of PI DRI). 4/21/2000 S + B */
+#include <asm/current.h>
+#endif /* __alpha__ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/file.h>
+#include <linux/pci.h>
+#include <linux/wrapper.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>	/* For (un)lock_kernel */
+#include <linux/mm.h>
+#ifdef __alpha__
+#include <asm/pgtable.h> /* For pte_wrprotect */
+#endif
+#include <asm/io.h>
+#include <asm/mman.h>
+#include <asm/uaccess.h>
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+#include <linux/types.h>
+#include <linux/agp_backend.h>
+#endif
+#if LINUX_VERSION_CODE >= 0x020100 /* KERNEL_VERSION(2,1,0) */
+#include <linux/tqueue.h>
+#include <linux/poll.h>
+#endif
+#if LINUX_VERSION_CODE < 0x020400
+#include "compat-pre24.h"
+#endif
+#include "drm.h"
+
+#define DRM_DEBUG_CODE 2	  /* Include debugging code (if > 1, then
+				     also include looping detection. */
+#define DRM_DMA_HISTOGRAM 1	  /* Make histogram of DMA latency. */
+
+#define DRM_HASH_SIZE	      16 /* Size of key hash table		  */
+#define DRM_KERNEL_CONTEXT    0	 /* Change drm_resctx if changed	  */
+#define DRM_RESERVED_CONTEXTS 1	 /* Change drm_resctx if changed	  */
+#define DRM_LOOPING_LIMIT     5000000
+#define DRM_BSZ		      1024 /* Buffer size for /dev/drm? output	  */
+#define DRM_TIME_SLICE	      (HZ/20)  /* Time slice for GLXContexts	  */
+#define DRM_LOCK_SLICE	      1	/* Time slice for lock, in jiffies	  */
+
+#define DRM_FLAG_DEBUG	  0x01
+#define DRM_FLAG_NOCTX	  0x02
+
+#define DRM_MEM_DMA	   0
+#define DRM_MEM_SAREA	   1
+#define DRM_MEM_DRIVER	   2
+#define DRM_MEM_MAGIC	   3
+#define DRM_MEM_IOCTLS	   4
+#define DRM_MEM_MAPS	   5
+#define DRM_MEM_VMAS	   6
+#define DRM_MEM_BUFS	   7
+#define DRM_MEM_SEGS	   8
+#define DRM_MEM_PAGES	   9
+#define DRM_MEM_FILES	  10
+#define DRM_MEM_QUEUES	  11
+#define DRM_MEM_CMDS	  12
+#define DRM_MEM_MAPPINGS  13
+#define DRM_MEM_BUFLISTS  14
+#define DRM_MEM_AGPLISTS  15
+#define DRM_MEM_TOTALAGP  16
+#define DRM_MEM_BOUNDAGP  17
+#define DRM_MEM_CTXBITMAP 18
+
+#define DRM_MAX_CTXBITMAP (PAGE_SIZE * 8)
+
+				/* Backward compatibility section */
+				/* _PAGE_WT changed to _PAGE_PWT in 2.2.6 */
+#ifndef _PAGE_PWT
+#define _PAGE_PWT _PAGE_WT
+#endif
+				/* Wait queue declarations changed in 2.3.1 */
+#ifndef DECLARE_WAITQUEUE
+#define DECLARE_WAITQUEUE(w,c) struct wait_queue w = { c, NULL }
+typedef struct wait_queue *wait_queue_head_t;
+#define init_waitqueue_head(q) *q = NULL;
+#endif
+
+				/* _PAGE_4M changed to _PAGE_PSE in 2.3.23 */
+#ifndef _PAGE_PSE
+#define _PAGE_PSE _PAGE_4M
+#endif
+
+				/* vm_offset changed to vm_pgoff in 2.3.25 */
+#if LINUX_VERSION_CODE < 0x020319
+#define VM_OFFSET(vma) ((vma)->vm_offset)
+#else
+#define VM_OFFSET(vma) ((vma)->vm_pgoff << PAGE_SHIFT)
+#endif
+
+				/* *_nopage return values defined in 2.3.26 */
+#ifndef NOPAGE_SIGBUS
+#define NOPAGE_SIGBUS 0
+#endif
+#ifndef NOPAGE_OOM
+#define NOPAGE_OOM 0
+#endif
+
+				/* module_init/module_exit added in 2.3.13 */
+#ifndef module_init
+#define module_init(x)  int init_module(void) { return x(); }
+#endif
+#ifndef module_exit
+#define module_exit(x)  void cleanup_module(void) { x(); }
+#endif
+
+				/* Generic cmpxchg added in 2.3.x */
+#ifndef __HAVE_ARCH_CMPXCHG
+				/* Include this here so that driver can be
+                                   used with older kernels. */
+#if defined(__alpha__)
+static __inline__ unsigned long
+__cmpxchg_u32(volatile int *m, int old, int new)
+{
+	unsigned long prev, cmp;
+
+	__asm__ __volatile__(
+	"1:	ldl_l %0,%2\n"
+	"	cmpeq %0,%3,%1\n"
+	"	beq %1,2f\n"
+	"	mov %4,%1\n"
+	"	stl_c %1,%2\n"
+	"	beq %1,3f\n"
+	"2:	mb\n"
+	".subsection 2\n"
+	"3:	br 1b\n"
+	".previous"
+	: "=&r"(prev), "=&r"(cmp), "=m"(*m)
+	: "r"((long) old), "r"(new), "m"(*m));
+
+	return prev;
+}
+
+static __inline__ unsigned long
+__cmpxchg_u64(volatile long *m, unsigned long old, unsigned long new)
+{
+	unsigned long prev, cmp;
+
+	__asm__ __volatile__(
+	"1:	ldq_l %0,%2\n"
+	"	cmpeq %0,%3,%1\n"
+	"	beq %1,2f\n"
+	"	mov %4,%1\n"
+	"	stq_c %1,%2\n"
+	"	beq %1,3f\n"
+	"2:	mb\n"
+	".subsection 2\n"
+	"3:	br 1b\n"
+	".previous"
+	: "=&r"(prev), "=&r"(cmp), "=m"(*m)
+	: "r"((long) old), "r"(new), "m"(*m));
+
+	return prev;
+}
+
+static __inline__ unsigned long
+__cmpxchg(volatile void *ptr, unsigned long old, unsigned long new, int size)
+{
+	switch (size) {
+		case 4:
+			return __cmpxchg_u32(ptr, old, new);
+		case 8:
+			return __cmpxchg_u64(ptr, old, new);
+	}
+	return old;
+}
+#define cmpxchg(ptr,o,n)						 \
+  ({									 \
+     __typeof__(*(ptr)) _o_ = (o);					 \
+     __typeof__(*(ptr)) _n_ = (n);					 \
+     (__typeof__(*(ptr))) __cmpxchg((ptr), (unsigned long)_o_,		 \
+				    (unsigned long)_n_, sizeof(*(ptr))); \
+  })
+
+#elif __i386__
+static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
+				      unsigned long new, int size)
+{
+	unsigned long prev;
+	switch (size) {
+	case 1:
+		__asm__ __volatile__(LOCK_PREFIX "cmpxchgb %b1,%2"
+				     : "=a"(prev)
+				     : "q"(new), "m"(*__xg(ptr)), "0"(old)
+				     : "memory");
+		return prev;
+	case 2:
+		__asm__ __volatile__(LOCK_PREFIX "cmpxchgw %w1,%2"
+				     : "=a"(prev)
+				     : "q"(new), "m"(*__xg(ptr)), "0"(old)
+				     : "memory");
+		return prev;
+	case 4:
+		__asm__ __volatile__(LOCK_PREFIX "cmpxchgl %1,%2"
+				     : "=a"(prev)
+				     : "q"(new), "m"(*__xg(ptr)), "0"(old)
+				     : "memory");
+		return prev;
+	}
+	return old;
+}
+
+#define cmpxchg(ptr,o,n)						\
+  ((__typeof__(*(ptr)))__cmpxchg((ptr),(unsigned long)(o),		\
+				 (unsigned long)(n),sizeof(*(ptr))))
+#endif /* i386 & alpha */
+#endif
+
+				/* Macros to make printk easier */
+#define DRM_ERROR(fmt, arg...) \
+	printk(KERN_ERR "[" DRM_NAME ":" __FUNCTION__ "] *ERROR* " fmt , ##arg)
+#define DRM_MEM_ERROR(area, fmt, arg...) \
+	printk(KERN_ERR "[" DRM_NAME ":" __FUNCTION__ ":%s] *ERROR* " fmt , \
+	       drm_mem_stats[area].name , ##arg)
+#define DRM_INFO(fmt, arg...)  printk(KERN_INFO "[" DRM_NAME "] " fmt , ##arg)
+
+#if DRM_DEBUG_CODE
+#define DRM_DEBUG(fmt, arg...)						  \
+	do {								  \
+		if (drm_flags&DRM_FLAG_DEBUG)				  \
+			printk(KERN_DEBUG				  \
+			       "[" DRM_NAME ":" __FUNCTION__ "] " fmt ,	  \
+			       ##arg);					  \
+	} while (0)
+#else
+#define DRM_DEBUG(fmt, arg...)		 do { } while (0)
+#endif
+
+#define DRM_PROC_LIMIT (PAGE_SIZE-80)
+
+#define DRM_PROC_PRINT(fmt, arg...)	   \
+   len += sprintf(&buf[len], fmt , ##arg); \
+   if (len > DRM_PROC_LIMIT) return len;
+
+#define DRM_PROC_PRINT_RET(ret, fmt, arg...)	    \
+   len += sprintf(&buf[len], fmt , ##arg);	    \
+   if (len > DRM_PROC_LIMIT) { ret; return len; }
+
+				/* Internal types and structures */
+#define DRM_ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
+#define DRM_MIN(a,b) ((a)<(b)?(a):(b))
+#define DRM_MAX(a,b) ((a)>(b)?(a):(b))
+
+#define DRM_LEFTCOUNT(x) (((x)->rp + (x)->count - (x)->wp) % ((x)->count + 1))
+#define DRM_BUFCOUNT(x) ((x)->count - DRM_LEFTCOUNT(x))
+#define DRM_WAITCOUNT(dev,idx) DRM_BUFCOUNT(&dev->queuelist[idx]->waitlist)
+
+typedef int drm_ioctl_t(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+
+typedef struct drm_ioctl_desc {
+	drm_ioctl_t	     *func;
+	int		     auth_needed;
+	int		     root_only;
+} drm_ioctl_desc_t;
+
+typedef struct drm_devstate {
+	pid_t		  owner;	/* X server pid holding x_lock */
+	
+} drm_devstate_t;
+
+typedef struct drm_magic_entry {
+	drm_magic_t	       magic;
+	struct drm_file	       *priv;
+	struct drm_magic_entry *next;
+} drm_magic_entry_t;
+
+typedef struct drm_magic_head {
+	struct drm_magic_entry *head;
+	struct drm_magic_entry *tail;
+} drm_magic_head_t;
+
+typedef struct drm_vma_entry {
+	struct vm_area_struct *vma;
+	struct drm_vma_entry  *next;
+	pid_t		      pid;
+} drm_vma_entry_t;
+
+typedef struct drm_buf {
+	int		  idx;	       /* Index into master buflist	     */
+	int		  total;       /* Buffer size			     */
+	int		  order;       /* log-base-2(total)		     */
+	int		  used;	       /* Amount of buffer in use (for DMA)  */
+	unsigned long	  offset;      /* Byte offset (used internally)	     */
+	void		  *address;    /* Address of buffer		     */
+	unsigned long	  bus_address; /* Bus address of buffer		     */
+	struct drm_buf	  *next;       /* Kernel-only: used for free list    */
+	__volatile__ int  waiting;     /* On kernel DMA queue		     */
+	__volatile__ int  pending;     /* On hardware DMA queue		     */
+	wait_queue_head_t dma_wait;    /* Processes waiting		     */
+	pid_t		  pid;	       /* PID of holding process	     */
+	int		  context;     /* Kernel queue for this buffer	     */
+	int		  while_locked;/* Dispatch this buffer while locked  */
+	enum {
+		DRM_LIST_NONE	 = 0,
+		DRM_LIST_FREE	 = 1,
+		DRM_LIST_WAIT	 = 2,
+		DRM_LIST_PEND	 = 3,
+		DRM_LIST_PRIO	 = 4,
+		DRM_LIST_RECLAIM = 5
+	}		  list;	       /* Which list we're on		     */
+
+#if DRM_DMA_HISTOGRAM
+	cycles_t	  time_queued;	   /* Queued to kernel DMA queue     */
+	cycles_t	  time_dispatched; /* Dispatched to hardware	     */
+	cycles_t	  time_completed;  /* Completed by hardware	     */
+	cycles_t	  time_freed;	   /* Back on freelist		     */
+#endif
+
+	int		  dev_priv_size; /* Size of buffer private stoarge   */
+	void		  *dev_private;  /* Per-buffer private storage       */
+} drm_buf_t;
+
+#if DRM_DMA_HISTOGRAM
+#define DRM_DMA_HISTOGRAM_SLOTS		  9
+#define DRM_DMA_HISTOGRAM_INITIAL	 10
+#define DRM_DMA_HISTOGRAM_NEXT(current)	 ((current)*10)
+typedef struct drm_histogram {
+	atomic_t	  total;
+
+	atomic_t	  queued_to_dispatched[DRM_DMA_HISTOGRAM_SLOTS];
+	atomic_t	  dispatched_to_completed[DRM_DMA_HISTOGRAM_SLOTS];
+	atomic_t	  completed_to_freed[DRM_DMA_HISTOGRAM_SLOTS];
+
+	atomic_t	  queued_to_completed[DRM_DMA_HISTOGRAM_SLOTS];
+	atomic_t	  queued_to_freed[DRM_DMA_HISTOGRAM_SLOTS];
+
+	atomic_t	  dma[DRM_DMA_HISTOGRAM_SLOTS];
+	atomic_t	  schedule[DRM_DMA_HISTOGRAM_SLOTS];
+	atomic_t	  ctx[DRM_DMA_HISTOGRAM_SLOTS];
+	atomic_t	  lacq[DRM_DMA_HISTOGRAM_SLOTS];
+	atomic_t	  lhld[DRM_DMA_HISTOGRAM_SLOTS];
+} drm_histogram_t;
+#endif
+
+				/* bufs is one longer than it has to be */
+typedef struct drm_waitlist {
+	int		  count;	/* Number of possible buffers	   */
+	drm_buf_t	  **bufs;	/* List of pointers to buffers	   */
+	drm_buf_t	  **rp;		/* Read pointer			   */
+	drm_buf_t	  **wp;		/* Write pointer		   */
+	drm_buf_t	  **end;	/* End pointer			   */
+	spinlock_t	  read_lock;
+	spinlock_t	  write_lock;
+} drm_waitlist_t;
+
+typedef struct drm_freelist {
+	int		  initialized; /* Freelist in use		   */
+	atomic_t	  count;       /* Number of free buffers	   */
+	drm_buf_t	  *next;       /* End pointer			   */
+
+	wait_queue_head_t waiting;     /* Processes waiting on free bufs   */
+	int		  low_mark;    /* Low water mark		   */
+	int		  high_mark;   /* High water mark		   */
+	atomic_t	  wfh;	       /* If waiting for high mark	   */
+	spinlock_t        lock;
+} drm_freelist_t;
+
+typedef struct drm_buf_entry {
+	int		  buf_size;
+	int		  buf_count;
+	drm_buf_t	  *buflist;
+	int		  seg_count;
+	int		  page_order;
+	unsigned long	  *seglist;
+
+	drm_freelist_t	  freelist;
+} drm_buf_entry_t;
+
+typedef struct drm_hw_lock {
+	__volatile__ unsigned int lock;
+	char			  padding[60]; /* Pad to cache line */
+} drm_hw_lock_t;
+
+typedef struct drm_file {
+	int		  authenticated;
+	int		  minor;
+	pid_t		  pid;
+	uid_t		  uid;
+	drm_magic_t	  magic;
+	unsigned long	  ioctl_count;
+	struct drm_file	  *next;
+	struct drm_file	  *prev;
+	struct drm_device *dev;
+	int 		  remove_auth_on_close;
+} drm_file_t;
+
+
+typedef struct drm_queue {
+	atomic_t	  use_count;	/* Outstanding uses (+1)	    */
+	atomic_t	  finalization;	/* Finalization in progress	    */
+	atomic_t	  block_count;	/* Count of processes waiting	    */
+	atomic_t	  block_read;	/* Queue blocked for reads	    */
+	wait_queue_head_t read_queue;	/* Processes waiting on block_read  */
+	atomic_t	  block_write;	/* Queue blocked for writes	    */
+	wait_queue_head_t write_queue;	/* Processes waiting on block_write */
+	atomic_t	  total_queued;	/* Total queued statistic	    */
+	atomic_t	  total_flushed;/* Total flushes statistic	    */
+	atomic_t	  total_locks;	/* Total locks statistics	    */
+	drm_ctx_flags_t	  flags;	/* Context preserving and 2D-only   */
+	drm_waitlist_t	  waitlist;	/* Pending buffers		    */
+	wait_queue_head_t flush_queue;	/* Processes waiting until flush    */
+} drm_queue_t;
+
+typedef struct drm_lock_data {
+	drm_hw_lock_t	  *hw_lock;	/* Hardware lock		   */
+	pid_t		  pid;		/* PID of lock holder (0=kernel)   */
+	wait_queue_head_t lock_queue;	/* Queue of blocked processes	   */
+	unsigned long	  lock_time;	/* Time of last lock in jiffies	   */
+} drm_lock_data_t;
+
+typedef struct drm_device_dma {
+				/* Performance Counters */
+	atomic_t	  total_prio;	/* Total DRM_DMA_PRIORITY	   */
+	atomic_t	  total_bytes;	/* Total bytes DMA'd		   */
+	atomic_t	  total_dmas;	/* Total DMA buffers dispatched	   */
+
+	atomic_t	  total_missed_dma;  /* Missed drm_do_dma	    */
+	atomic_t	  total_missed_lock; /* Missed lock in drm_do_dma   */
+	atomic_t	  total_missed_free; /* Missed drm_free_this_buffer */
+	atomic_t	  total_missed_sched;/* Missed drm_dma_schedule	    */
+
+	atomic_t	  total_tried;	/* Tried next_buffer		    */
+	atomic_t	  total_hit;	/* Sent next_buffer		    */
+	atomic_t	  total_lost;	/* Lost interrupt		    */
+
+	drm_buf_entry_t	  bufs[DRM_MAX_ORDER+1];
+	int		  buf_count;
+	drm_buf_t	  **buflist;	/* Vector of pointers info bufs	   */
+	int		  seg_count;
+	int		  page_count;
+	unsigned long	  *pagelist;
+	unsigned long	  byte_count;
+	enum {
+	   _DRM_DMA_USE_AGP = 0x01
+	} flags;
+
+				/* DMA support */
+	drm_buf_t	  *this_buffer;	/* Buffer being sent		   */
+	drm_buf_t	  *next_buffer; /* Selected buffer to send	   */
+	drm_queue_t	  *next_queue;	/* Queue from which buffer selected*/
+	wait_queue_head_t waiting;	/* Processes waiting on free bufs  */
+} drm_device_dma_t;
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+typedef struct drm_agp_mem {
+	unsigned long      handle;
+	agp_memory         *memory;
+	unsigned long      bound; /* address */
+	int                pages;
+	struct drm_agp_mem *prev;
+	struct drm_agp_mem *next;
+} drm_agp_mem_t;
+
+typedef struct drm_agp_head {
+	agp_kern_info      agp_info;
+	const char         *chipset;
+	drm_agp_mem_t      *memory;
+	unsigned long      mode;
+	int                enabled;
+	int                acquired;
+	unsigned long      base;
+   	int 		   agp_mtrr;
+	int		   cant_use_aperture;
+	unsigned long	   page_mask;
+} drm_agp_head_t;
+#endif
+
+typedef struct drm_sigdata {
+	int           context;
+	drm_hw_lock_t *lock;
+} drm_sigdata_t;
+
+typedef struct drm_device {
+	const char	  *name;	/* Simple driver name		   */
+	char		  *unique;	/* Unique identifier: e.g., busid  */
+	int		  unique_len;	/* Length of unique field	   */
+	dev_t		  device;	/* Device number for mknod	   */
+	char		  *devname;	/* For /proc/interrupts		   */
+
+	int		  blocked;	/* Blocked due to VC switch?	   */
+	struct proc_dir_entry *root;	/* Root for this device's entries  */
+
+				/* Locks */
+	spinlock_t	  count_lock;	/* For inuse, open_count, buf_use  */
+	struct semaphore  struct_sem;	/* For others			   */
+
+				/* Usage Counters */
+	int		  open_count;	/* Outstanding files open	   */
+	atomic_t	  ioctl_count;	/* Outstanding IOCTLs pending	   */
+	atomic_t	  vma_count;	/* Outstanding vma areas open	   */
+	int		  buf_use;	/* Buffers in use -- cannot alloc  */
+	atomic_t	  buf_alloc;	/* Buffer allocation in progress   */
+
+				/* Performance Counters */
+	atomic_t	  total_open;
+	atomic_t	  total_close;
+	atomic_t	  total_ioctl;
+	atomic_t	  total_irq;	/* Total interruptions		   */
+	atomic_t	  total_ctx;	/* Total context switches	   */
+
+	atomic_t	  total_locks;
+	atomic_t	  total_unlocks;
+	atomic_t	  total_contends;
+	atomic_t	  total_sleeps;
+
+				/* Authentication */
+	drm_file_t	  *file_first;
+	drm_file_t	  *file_last;
+	drm_magic_head_t  magiclist[DRM_HASH_SIZE];
+
+				/* Memory management */
+	drm_map_t	  **maplist;	/* Vector of pointers to regions   */
+	int		  map_count;	/* Number of mappable regions	   */
+
+	drm_vma_entry_t	  *vmalist;	/* List of vmas (for debugging)	   */
+	drm_lock_data_t	  lock;		/* Information on hardware lock	   */
+
+				/* DMA queues (contexts) */
+	int		  queue_count;	/* Number of active DMA queues	   */
+	int		  queue_reserved; /* Number of reserved DMA queues */
+	int		  queue_slots;	/* Actual length of queuelist	   */
+	drm_queue_t	  **queuelist;	/* Vector of pointers to DMA queues */
+	drm_device_dma_t  *dma;		/* Optional pointer for DMA support */
+
+				/* Context support */
+	int		  irq;		/* Interrupt used by board	   */
+	__volatile__ long context_flag;	/* Context swapping flag	   */
+	__volatile__ long interrupt_flag; /* Interruption handler flag	   */
+	__volatile__ long dma_flag;	/* DMA dispatch flag		   */
+	struct timer_list timer;	/* Timer for delaying ctx switch   */
+	wait_queue_head_t context_wait; /* Processes waiting on ctx switch */
+	int		  last_checked;	/* Last context checked for DMA	   */
+	int		  last_context;	/* Last current context		   */
+	unsigned long	  last_switch;	/* jiffies at last context switch  */
+	struct tq_struct  tq;
+	cycles_t	  ctx_start;
+	cycles_t	  lck_start;
+#if DRM_DMA_HISTOGRAM
+	drm_histogram_t	  histo;
+#endif
+
+				/* Callback to X server for context switch
+				   and for heavy-handed reset. */
+	char		  buf[DRM_BSZ]; /* Output buffer		   */
+	char		  *buf_rp;	/* Read pointer			   */
+	char		  *buf_wp;	/* Write pointer		   */
+	char		  *buf_end;	/* End pointer			   */
+	struct fasync_struct *buf_async;/* Processes waiting for SIGIO	   */
+	wait_queue_head_t buf_readers;	/* Processes waiting to read	   */
+	wait_queue_head_t buf_writers;	/* Processes waiting to ctx switch */
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	drm_agp_head_t    *agp;
+#endif
+	unsigned long     *ctx_bitmap;
+	void		  *dev_private;
+	drm_sigdata_t     sigdata; /* For block_all_signals */
+	sigset_t          sigmask;
+} drm_device_t;
+
+				/* Internal function definitions */
+
+				/* Misc. support (init.c) */
+extern int	     drm_flags;
+extern void	     drm_parse_options(char *s);
+extern int           drm_cpu_valid(void);
+
+
+				/* Device support (fops.c) */
+extern int	     drm_open_helper(struct inode *inode, struct file *filp,
+				     drm_device_t *dev);
+extern int	     drm_flush(struct file *filp);
+extern int	     drm_release(struct inode *inode, struct file *filp);
+extern int	     drm_fasync(int fd, struct file *filp, int on);
+extern ssize_t	     drm_read(struct file *filp, char *buf, size_t count,
+			      loff_t *off);
+extern int	     drm_write_string(drm_device_t *dev, const char *s);
+extern unsigned int  drm_poll(struct file *filp, struct poll_table_struct *wait);
+
+				/* Mapping support (vm.c) */
+#if LINUX_VERSION_CODE < 0x020317
+extern unsigned long drm_vm_nopage(struct vm_area_struct *vma,
+				   unsigned long address,
+				   int write_access);
+extern unsigned long drm_vm_shm_nopage(struct vm_area_struct *vma,
+				       unsigned long address,
+				       int write_access);
+extern unsigned long drm_vm_shm_nopage_lock(struct vm_area_struct *vma,
+					    unsigned long address,
+					    int write_access);
+extern unsigned long drm_vm_dma_nopage(struct vm_area_struct *vma,
+				       unsigned long address,
+				       int write_access);
+#else
+				/* Return type changed in 2.3.23 */
+extern struct page *drm_vm_nopage(struct vm_area_struct *vma,
+				  unsigned long address,
+				  int write_access);
+extern struct page *drm_vm_shm_nopage(struct vm_area_struct *vma,
+				      unsigned long address,
+				      int write_access);
+extern struct page *drm_vm_shm_nopage_lock(struct vm_area_struct *vma,
+					   unsigned long address,
+					   int write_access);
+extern struct page *drm_vm_dma_nopage(struct vm_area_struct *vma,
+				      unsigned long address,
+				      int write_access);
+#endif
+extern void	     drm_vm_open(struct vm_area_struct *vma);
+extern void	     drm_vm_close(struct vm_area_struct *vma);
+extern int	     drm_mmap_dma(struct file *filp,
+				  struct vm_area_struct *vma);
+extern int	     drm_mmap(struct file *filp, struct vm_area_struct *vma);
+
+
+				/* Proc support (proc.c) */
+extern int	     drm_proc_init(drm_device_t *dev);
+extern int	     drm_proc_cleanup(void);
+
+				/* Memory management support (memory.c) */
+extern void	     drm_mem_init(void);
+extern int	     drm_mem_info(char *buf, char **start, off_t offset,
+				  int len, int *eof, void *data);
+extern void	     *drm_alloc(size_t size, int area);
+extern void	     *drm_realloc(void *oldpt, size_t oldsize, size_t size,
+				  int area);
+extern char	     *drm_strdup(const char *s, int area);
+extern void	     drm_strfree(const char *s, int area);
+extern void	     drm_free(void *pt, size_t size, int area);
+extern unsigned long drm_alloc_pages(int order, int area);
+extern void	     drm_free_pages(unsigned long address, int order,
+				    int area);
+extern void	     *drm_ioremap(unsigned long offset, unsigned long size,
+							drm_device_t *dev);
+extern void	     drm_ioremapfree(void *pt, unsigned long size,
+							drm_device_t *dev);
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+extern agp_memory    *drm_alloc_agp(int pages, u32 type);
+extern int           drm_free_agp(agp_memory *handle, int pages);
+extern int           drm_bind_agp(agp_memory *handle, unsigned int start);
+extern int           drm_unbind_agp(agp_memory *handle);
+#endif
+
+
+				/* Buffer management support (bufs.c) */
+extern int	     drm_order(unsigned long size);
+extern int	     drm_addmap(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+extern int	     drm_addbufs(struct inode *inode, struct file *filp,
+				 unsigned int cmd, unsigned long arg);
+extern int	     drm_infobufs(struct inode *inode, struct file *filp,
+				  unsigned int cmd, unsigned long arg);
+extern int	     drm_markbufs(struct inode *inode, struct file *filp,
+				  unsigned int cmd, unsigned long arg);
+extern int	     drm_freebufs(struct inode *inode, struct file *filp,
+				  unsigned int cmd, unsigned long arg);
+extern int	     drm_mapbufs(struct inode *inode, struct file *filp,
+				 unsigned int cmd, unsigned long arg);
+
+
+				/* Buffer list management support (lists.c) */
+extern int	     drm_waitlist_create(drm_waitlist_t *bl, int count);
+extern int	     drm_waitlist_destroy(drm_waitlist_t *bl);
+extern int	     drm_waitlist_put(drm_waitlist_t *bl, drm_buf_t *buf);
+extern drm_buf_t     *drm_waitlist_get(drm_waitlist_t *bl);
+
+extern int	     drm_freelist_create(drm_freelist_t *bl, int count);
+extern int	     drm_freelist_destroy(drm_freelist_t *bl);
+extern int	     drm_freelist_put(drm_device_t *dev, drm_freelist_t *bl,
+				      drm_buf_t *buf);
+extern drm_buf_t     *drm_freelist_get(drm_freelist_t *bl, int block);
+
+				/* DMA support (gen_dma.c) */
+extern void	     drm_dma_setup(drm_device_t *dev);
+extern void	     drm_dma_takedown(drm_device_t *dev);
+extern void	     drm_free_buffer(drm_device_t *dev, drm_buf_t *buf);
+extern void	     drm_reclaim_buffers(drm_device_t *dev, pid_t pid);
+extern int	     drm_context_switch(drm_device_t *dev, int old, int new);
+extern int	     drm_context_switch_complete(drm_device_t *dev, int new);
+extern void	     drm_clear_next_buffer(drm_device_t *dev);
+extern int	     drm_select_queue(drm_device_t *dev,
+				      void (*wrapper)(unsigned long));
+extern int	     drm_dma_enqueue(drm_device_t *dev, drm_dma_t *dma);
+extern int	     drm_dma_get_buffers(drm_device_t *dev, drm_dma_t *dma);
+#if DRM_DMA_HISTOGRAM
+extern int	     drm_histogram_slot(unsigned long count);
+extern void	     drm_histogram_compute(drm_device_t *dev, drm_buf_t *buf);
+#endif
+
+
+				/* Misc. IOCTL support (ioctl.c) */
+extern int	     drm_irq_busid(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+extern int	     drm_getunique(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+extern int	     drm_setunique(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+
+
+				/* Context IOCTL support (context.c) */
+extern int	     drm_resctx(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+extern int	     drm_addctx(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+extern int	     drm_modctx(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+extern int	     drm_getctx(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+extern int	     drm_switchctx(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+extern int	     drm_newctx(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+extern int	     drm_rmctx(struct inode *inode, struct file *filp,
+			       unsigned int cmd, unsigned long arg);
+
+
+				/* Drawable IOCTL support (drawable.c) */
+extern int	     drm_adddraw(struct inode *inode, struct file *filp,
+				 unsigned int cmd, unsigned long arg);
+extern int	     drm_rmdraw(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+
+
+				/* Authentication IOCTL support (auth.c) */
+extern int	     drm_add_magic(drm_device_t *dev, drm_file_t *priv,
+				   drm_magic_t magic);
+extern int	     drm_remove_magic(drm_device_t *dev, drm_magic_t magic);
+extern int	     drm_getmagic(struct inode *inode, struct file *filp,
+				  unsigned int cmd, unsigned long arg);
+extern int	     drm_authmagic(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+
+
+				/* Locking IOCTL support (lock.c) */
+extern int	     drm_block(struct inode *inode, struct file *filp,
+			       unsigned int cmd, unsigned long arg);
+extern int	     drm_unblock(struct inode *inode, struct file *filp,
+				 unsigned int cmd, unsigned long arg);
+extern int	     drm_lock_take(__volatile__ unsigned int *lock,
+				   unsigned int context);
+extern int	     drm_lock_transfer(drm_device_t *dev,
+				       __volatile__ unsigned int *lock,
+				       unsigned int context);
+extern int	     drm_lock_free(drm_device_t *dev,
+				   __volatile__ unsigned int *lock,
+				   unsigned int context);
+extern int	     drm_finish(struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg);
+extern int	     drm_flush_unblock(drm_device_t *dev, int context,
+				       drm_lock_flags_t flags);
+extern int	     drm_flush_block_and_flush(drm_device_t *dev, int context,
+					       drm_lock_flags_t flags);
+extern int           drm_notifier(void *priv);
+
+				/* Context Bitmap support (ctxbitmap.c) */
+extern int	     drm_ctxbitmap_init(drm_device_t *dev);
+extern void	     drm_ctxbitmap_cleanup(drm_device_t *dev);
+extern int	     drm_ctxbitmap_next(drm_device_t *dev);
+extern void	     drm_ctxbitmap_free(drm_device_t *dev, int ctx_handle);
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+				/* AGP/GART support (agpsupport.c) */
+extern drm_agp_head_t *drm_agp_init(void);
+extern void           drm_agp_uninit(void);
+extern int            drm_agp_acquire(struct inode *inode, struct file *filp,
+				      unsigned int cmd, unsigned long arg);
+extern void           _drm_agp_release(void);
+extern int            drm_agp_release(struct inode *inode, struct file *filp,
+				      unsigned int cmd, unsigned long arg);
+extern int            drm_agp_enable(struct inode *inode, struct file *filp,
+				     unsigned int cmd, unsigned long arg);
+extern int            drm_agp_info(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+extern int            drm_agp_alloc(struct inode *inode, struct file *filp,
+				    unsigned int cmd, unsigned long arg);
+extern int            drm_agp_free(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+extern int            drm_agp_unbind(struct inode *inode, struct file *filp,
+				     unsigned int cmd, unsigned long arg);
+extern int            drm_agp_bind(struct inode *inode, struct file *filp,
+				   unsigned int cmd, unsigned long arg);
+extern agp_memory     *drm_agp_allocate_memory(size_t pages, u32 type);
+extern int            drm_agp_free_memory(agp_memory *handle);
+extern int            drm_agp_bind_memory(agp_memory *handle, off_t start);
+extern int            drm_agp_unbind_memory(agp_memory *handle);
+#endif
+#endif
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/ffb_context.c linux/drivers/char/drm-4.0/ffb_context.c
--- linux.orig/drivers/char/drm-4.0/ffb_context.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/ffb_context.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,540 @@
+/* $Id: ffb_context.c,v 1.4 2000/08/29 07:01:55 davem Exp $
+ * ffb_context.c: Creator/Creator3D DRI/DRM context switching.
+ *
+ * Copyright (C) 2000 David S. Miller (davem@redhat.com)
+ *
+ * Almost entirely stolen from tdfx_context.c, see there
+ * for authors.
+ */
+
+#include <linux/sched.h>
+#include <asm/upa.h>
+
+#include "drmP.h"
+
+#include "ffb_drv.h"
+
+static int ffb_alloc_queue(drm_device_t *dev, int is_2d_only)
+{
+	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) (dev + 1);
+	int i;
+
+	for (i = 0; i < FFB_MAX_CTXS; i++) {
+		if (fpriv->hw_state[i] == NULL)
+			break;
+	}
+	if (i == FFB_MAX_CTXS)
+		return -1;
+
+	fpriv->hw_state[i] = kmalloc(sizeof(struct ffb_hw_context), GFP_KERNEL);
+	if (fpriv->hw_state[i] == NULL)
+		return -1;
+
+	fpriv->hw_state[i]->is_2d_only = is_2d_only;
+
+	/* Plus one because 0 is the special DRM_KERNEL_CONTEXT. */
+	return i + 1;
+}
+
+static void ffb_save_context(ffb_dev_priv_t *fpriv, int idx)
+{
+	ffb_fbcPtr ffb = fpriv->regs;
+	struct ffb_hw_context *ctx;
+	int i;
+
+	ctx = fpriv->hw_state[idx - 1];
+	if (idx == 0 || ctx == NULL)
+		return;
+
+	if (ctx->is_2d_only) {
+		/* 2D applications only care about certain pieces
+		 * of state.
+		 */
+		ctx->drawop = upa_readl(&ffb->drawop);
+		ctx->ppc = upa_readl(&ffb->ppc);
+		ctx->wid = upa_readl(&ffb->wid);
+		ctx->fg = upa_readl(&ffb->fg);
+		ctx->bg = upa_readl(&ffb->bg);
+		ctx->xclip = upa_readl(&ffb->xclip);
+		ctx->fbc = upa_readl(&ffb->fbc);
+		ctx->rop = upa_readl(&ffb->rop);
+		ctx->cmp = upa_readl(&ffb->cmp);
+		ctx->matchab = upa_readl(&ffb->matchab);
+		ctx->magnab = upa_readl(&ffb->magnab);
+		ctx->pmask = upa_readl(&ffb->pmask);
+		ctx->xpmask = upa_readl(&ffb->xpmask);
+		ctx->lpat = upa_readl(&ffb->lpat);
+		ctx->fontxy = upa_readl(&ffb->fontxy);
+		ctx->fontw = upa_readl(&ffb->fontw);
+		ctx->fontinc = upa_readl(&ffb->fontinc);
+
+		/* stencil/stencilctl only exists on FFB2+ and later
+		 * due to the introduction of 3DRAM-III.
+		 */
+		if (fpriv->ffb_type == ffb2_vertical_plus ||
+		    fpriv->ffb_type == ffb2_horizontal_plus) {
+			ctx->stencil = upa_readl(&ffb->stencil);
+			ctx->stencilctl = upa_readl(&ffb->stencilctl);
+		}
+
+		for (i = 0; i < 32; i++)
+			ctx->area_pattern[i] = upa_readl(&ffb->pattern[i]);
+		ctx->ucsr = upa_readl(&ffb->ucsr);
+		return;
+	}
+
+	/* Fetch drawop. */
+	ctx->drawop = upa_readl(&ffb->drawop);
+
+	/* If we were saving the vertex registers, this is where
+	 * we would do it.  We would save 32 32-bit words starting
+	 * at ffb->suvtx.
+	 */
+
+	/* Capture rendering attributes. */
+
+	ctx->ppc = upa_readl(&ffb->ppc);		/* Pixel Processor Control */
+	ctx->wid = upa_readl(&ffb->wid);		/* Current WID */
+	ctx->fg = upa_readl(&ffb->fg);			/* Constant FG color */
+	ctx->bg = upa_readl(&ffb->bg);			/* Constant BG color */
+	ctx->consty = upa_readl(&ffb->consty);		/* Constant Y */
+	ctx->constz = upa_readl(&ffb->constz);		/* Constant Z */
+	ctx->xclip = upa_readl(&ffb->xclip);		/* X plane clip */
+	ctx->dcss = upa_readl(&ffb->dcss);		/* Depth Cue Scale Slope */
+	ctx->vclipmin = upa_readl(&ffb->vclipmin);	/* Primary XY clip, minimum */
+	ctx->vclipmax = upa_readl(&ffb->vclipmax);	/* Primary XY clip, maximum */
+	ctx->vclipzmin = upa_readl(&ffb->vclipzmin);	/* Primary Z clip, minimum */
+	ctx->vclipzmax = upa_readl(&ffb->vclipzmax);	/* Primary Z clip, maximum */
+	ctx->dcsf = upa_readl(&ffb->dcsf);		/* Depth Cue Scale Front Bound */
+	ctx->dcsb = upa_readl(&ffb->dcsb);		/* Depth Cue Scale Back Bound */
+	ctx->dczf = upa_readl(&ffb->dczf);		/* Depth Cue Scale Z Front */
+	ctx->dczb = upa_readl(&ffb->dczb);		/* Depth Cue Scale Z Back */
+	ctx->blendc = upa_readl(&ffb->blendc);		/* Alpha Blend Control */
+	ctx->blendc1 = upa_readl(&ffb->blendc1);	/* Alpha Blend Color 1 */
+	ctx->blendc2 = upa_readl(&ffb->blendc2);	/* Alpha Blend Color 2 */
+	ctx->fbc = upa_readl(&ffb->fbc);		/* Frame Buffer Control */
+	ctx->rop = upa_readl(&ffb->rop);		/* Raster Operation */
+	ctx->cmp = upa_readl(&ffb->cmp);		/* Compare Controls */
+	ctx->matchab = upa_readl(&ffb->matchab);	/* Buffer A/B Match Ops */
+	ctx->matchc = upa_readl(&ffb->matchc);		/* Buffer C Match Ops */
+	ctx->magnab = upa_readl(&ffb->magnab);		/* Buffer A/B Magnitude Ops */
+	ctx->magnc = upa_readl(&ffb->magnc);		/* Buffer C Magnitude Ops */
+	ctx->pmask = upa_readl(&ffb->pmask);		/* RGB Plane Mask */
+	ctx->xpmask = upa_readl(&ffb->xpmask);		/* X Plane Mask */
+	ctx->ypmask = upa_readl(&ffb->ypmask);		/* Y Plane Mask */
+	ctx->zpmask = upa_readl(&ffb->zpmask);		/* Z Plane Mask */
+
+	/* Auxiliary Clips. */
+	ctx->auxclip0min = upa_readl(&ffb->auxclip[0].min);
+	ctx->auxclip0max = upa_readl(&ffb->auxclip[0].max);
+	ctx->auxclip1min = upa_readl(&ffb->auxclip[1].min);
+	ctx->auxclip1max = upa_readl(&ffb->auxclip[1].max);
+	ctx->auxclip2min = upa_readl(&ffb->auxclip[2].min);
+	ctx->auxclip2max = upa_readl(&ffb->auxclip[2].max);
+	ctx->auxclip3min = upa_readl(&ffb->auxclip[3].min);
+	ctx->auxclip3max = upa_readl(&ffb->auxclip[3].max);
+
+	ctx->lpat = upa_readl(&ffb->lpat);		/* Line Pattern */
+	ctx->fontxy = upa_readl(&ffb->fontxy);		/* XY Font Coordinate */
+	ctx->fontw = upa_readl(&ffb->fontw);		/* Font Width */
+	ctx->fontinc = upa_readl(&ffb->fontinc);	/* Font X/Y Increment */
+
+	/* These registers/features only exist on FFB2 and later chips. */
+	if (fpriv->ffb_type >= ffb2_prototype) {
+		ctx->dcss1 = upa_readl(&ffb->dcss1);	/* Depth Cue Scale Slope 1 */
+		ctx->dcss2 = upa_readl(&ffb->dcss2);	/* Depth Cue Scale Slope 2 */
+		ctx->dcss2 = upa_readl(&ffb->dcss3);	/* Depth Cue Scale Slope 3 */
+		ctx->dcs2  = upa_readl(&ffb->dcs2);	/* Depth Cue Scale 2 */
+		ctx->dcs3  = upa_readl(&ffb->dcs3);	/* Depth Cue Scale 3 */
+		ctx->dcs4  = upa_readl(&ffb->dcs4);	/* Depth Cue Scale 4 */
+		ctx->dcd2  = upa_readl(&ffb->dcd2);	/* Depth Cue Depth 2 */
+		ctx->dcd3  = upa_readl(&ffb->dcd3);	/* Depth Cue Depth 3 */
+		ctx->dcd4  = upa_readl(&ffb->dcd4);	/* Depth Cue Depth 4 */
+
+		/* And stencil/stencilctl only exists on FFB2+ and later
+		 * due to the introduction of 3DRAM-III.
+		 */
+		if (fpriv->ffb_type == ffb2_vertical_plus ||
+		    fpriv->ffb_type == ffb2_horizontal_plus) {
+			ctx->stencil = upa_readl(&ffb->stencil);
+			ctx->stencilctl = upa_readl(&ffb->stencilctl);
+		}
+	}
+
+	/* Save the 32x32 area pattern. */
+	for (i = 0; i < 32; i++)
+		ctx->area_pattern[i] = upa_readl(&ffb->pattern[i]);
+
+	/* Finally, stash away the User Constol/Status Register. */
+	ctx->ucsr = upa_readl(&ffb->ucsr);
+}
+
+static void ffb_restore_context(ffb_dev_priv_t *fpriv, int old, int idx)
+{
+	ffb_fbcPtr ffb = fpriv->regs;
+	struct ffb_hw_context *ctx;
+	int i;
+
+	ctx = fpriv->hw_state[idx - 1];
+	if (idx == 0 || ctx == NULL)
+		return;
+
+	if (ctx->is_2d_only) {
+		/* 2D applications only care about certain pieces
+		 * of state.
+		 */
+		upa_writel(ctx->drawop, &ffb->drawop);
+
+		/* If we were restoring the vertex registers, this is where
+		 * we would do it.  We would restore 32 32-bit words starting
+		 * at ffb->suvtx.
+		 */
+
+		upa_writel(ctx->ppc, &ffb->ppc);
+		upa_writel(ctx->wid, &ffb->wid);
+		upa_writel(ctx->fg,  &ffb->fg);
+		upa_writel(ctx->bg, &ffb->bg);
+		upa_writel(ctx->xclip, &ffb->xclip);
+		upa_writel(ctx->fbc, &ffb->fbc);
+		upa_writel(ctx->rop, &ffb->rop);
+		upa_writel(ctx->cmp, &ffb->cmp);
+		upa_writel(ctx->matchab, &ffb->matchab);
+		upa_writel(ctx->magnab, &ffb->magnab);
+		upa_writel(ctx->pmask, &ffb->pmask);
+		upa_writel(ctx->xpmask, &ffb->xpmask);
+		upa_writel(ctx->lpat, &ffb->lpat);
+		upa_writel(ctx->fontxy, &ffb->fontxy);
+		upa_writel(ctx->fontw, &ffb->fontw);
+		upa_writel(ctx->fontinc, &ffb->fontinc);
+
+		/* stencil/stencilctl only exists on FFB2+ and later
+		 * due to the introduction of 3DRAM-III.
+		 */
+		if (fpriv->ffb_type == ffb2_vertical_plus ||
+		    fpriv->ffb_type == ffb2_horizontal_plus) {
+			upa_writel(ctx->stencil, &ffb->stencil);
+			upa_writel(ctx->stencilctl, &ffb->stencilctl);
+			upa_writel(0x80000000, &ffb->fbc);
+			upa_writel((ctx->stencilctl | 0x80000),
+				   &ffb->rawstencilctl);
+			upa_writel(ctx->fbc, &ffb->fbc);
+		}
+
+		for (i = 0; i < 32; i++)
+			upa_writel(ctx->area_pattern[i], &ffb->pattern[i]);
+		upa_writel((ctx->ucsr & 0xf0000), &ffb->ucsr);
+		return;
+	}
+
+	/* Restore drawop. */
+	upa_writel(ctx->drawop, &ffb->drawop);
+
+	/* If we were restoring the vertex registers, this is where
+	 * we would do it.  We would restore 32 32-bit words starting
+	 * at ffb->suvtx.
+	 */
+
+	/* Restore rendering attributes. */
+
+	upa_writel(ctx->ppc, &ffb->ppc);		/* Pixel Processor Control */
+	upa_writel(ctx->wid, &ffb->wid);		/* Current WID */
+	upa_writel(ctx->fg, &ffb->fg);			/* Constant FG color */
+	upa_writel(ctx->bg, &ffb->bg);			/* Constant BG color */
+	upa_writel(ctx->consty, &ffb->consty);		/* Constant Y */
+	upa_writel(ctx->constz, &ffb->constz);		/* Constant Z */
+	upa_writel(ctx->xclip, &ffb->xclip);		/* X plane clip */
+	upa_writel(ctx->dcss, &ffb->dcss);		/* Depth Cue Scale Slope */
+	upa_writel(ctx->vclipmin, &ffb->vclipmin);	/* Primary XY clip, minimum */
+	upa_writel(ctx->vclipmax, &ffb->vclipmax);	/* Primary XY clip, maximum */
+	upa_writel(ctx->vclipzmin, &ffb->vclipzmin);	/* Primary Z clip, minimum */
+	upa_writel(ctx->vclipzmax, &ffb->vclipzmax);	/* Primary Z clip, maximum */
+	upa_writel(ctx->dcsf, &ffb->dcsf);		/* Depth Cue Scale Front Bound */
+	upa_writel(ctx->dcsb, &ffb->dcsb);		/* Depth Cue Scale Back Bound */
+	upa_writel(ctx->dczf, &ffb->dczf);		/* Depth Cue Scale Z Front */
+	upa_writel(ctx->dczb, &ffb->dczb);		/* Depth Cue Scale Z Back */
+	upa_writel(ctx->blendc, &ffb->blendc);		/* Alpha Blend Control */
+	upa_writel(ctx->blendc1, &ffb->blendc1);	/* Alpha Blend Color 1 */
+	upa_writel(ctx->blendc2, &ffb->blendc2);	/* Alpha Blend Color 2 */
+	upa_writel(ctx->fbc, &ffb->fbc);		/* Frame Buffer Control */
+	upa_writel(ctx->rop, &ffb->rop);		/* Raster Operation */
+	upa_writel(ctx->cmp, &ffb->cmp);		/* Compare Controls */
+	upa_writel(ctx->matchab, &ffb->matchab);	/* Buffer A/B Match Ops */
+	upa_writel(ctx->matchc, &ffb->matchc);		/* Buffer C Match Ops */
+	upa_writel(ctx->magnab, &ffb->magnab);		/* Buffer A/B Magnitude Ops */
+	upa_writel(ctx->magnc, &ffb->magnc);		/* Buffer C Magnitude Ops */
+	upa_writel(ctx->pmask, &ffb->pmask);		/* RGB Plane Mask */
+	upa_writel(ctx->xpmask, &ffb->xpmask);		/* X Plane Mask */
+	upa_writel(ctx->ypmask, &ffb->ypmask);		/* Y Plane Mask */
+	upa_writel(ctx->zpmask, &ffb->zpmask);		/* Z Plane Mask */
+
+	/* Auxiliary Clips. */
+	upa_writel(ctx->auxclip0min, &ffb->auxclip[0].min);
+	upa_writel(ctx->auxclip0max, &ffb->auxclip[0].max);
+	upa_writel(ctx->auxclip1min, &ffb->auxclip[1].min);
+	upa_writel(ctx->auxclip1max, &ffb->auxclip[1].max);
+	upa_writel(ctx->auxclip2min, &ffb->auxclip[2].min);
+	upa_writel(ctx->auxclip2max, &ffb->auxclip[2].max);
+	upa_writel(ctx->auxclip3min, &ffb->auxclip[3].min);
+	upa_writel(ctx->auxclip3max, &ffb->auxclip[3].max);
+
+	upa_writel(ctx->lpat, &ffb->lpat);		/* Line Pattern */
+	upa_writel(ctx->fontxy, &ffb->fontxy);		/* XY Font Coordinate */
+	upa_writel(ctx->fontw, &ffb->fontw);		/* Font Width */
+	upa_writel(ctx->fontinc, &ffb->fontinc);	/* Font X/Y Increment */
+
+	/* These registers/features only exist on FFB2 and later chips. */
+	if (fpriv->ffb_type >= ffb2_prototype) {
+		upa_writel(ctx->dcss1, &ffb->dcss1);	/* Depth Cue Scale Slope 1 */
+		upa_writel(ctx->dcss2, &ffb->dcss2);	/* Depth Cue Scale Slope 2 */
+		upa_writel(ctx->dcss3, &ffb->dcss2);	/* Depth Cue Scale Slope 3 */
+		upa_writel(ctx->dcs2, &ffb->dcs2);	/* Depth Cue Scale 2 */
+		upa_writel(ctx->dcs3, &ffb->dcs3);	/* Depth Cue Scale 3 */
+		upa_writel(ctx->dcs4, &ffb->dcs4);	/* Depth Cue Scale 4 */
+		upa_writel(ctx->dcd2, &ffb->dcd2);	/* Depth Cue Depth 2 */
+		upa_writel(ctx->dcd3, &ffb->dcd3);	/* Depth Cue Depth 3 */
+		upa_writel(ctx->dcd4, &ffb->dcd4);	/* Depth Cue Depth 4 */
+
+		/* And stencil/stencilctl only exists on FFB2+ and later
+		 * due to the introduction of 3DRAM-III.
+		 */
+		if (fpriv->ffb_type == ffb2_vertical_plus ||
+		    fpriv->ffb_type == ffb2_horizontal_plus) {
+			/* Unfortunately, there is a hardware bug on
+			 * the FFB2+ chips which prevents a normal write
+			 * to the stencil control register from working
+			 * as it should.
+			 *
+			 * The state controlled by the FFB stencilctl register
+			 * really gets transferred to the per-buffer instances
+			 * of the stencilctl register in the 3DRAM chips.
+			 *
+			 * The bug is that FFB does not update buffer C correctly,
+			 * so we have to do it by hand for them.
+			 */
+
+			/* This will update buffers A and B. */
+			upa_writel(ctx->stencil, &ffb->stencil);
+			upa_writel(ctx->stencilctl, &ffb->stencilctl);
+
+			/* Force FFB to use buffer C 3dram regs. */
+			upa_writel(0x80000000, &ffb->fbc);
+			upa_writel((ctx->stencilctl | 0x80000),
+				   &ffb->rawstencilctl);
+
+			/* Now restore the correct FBC controls. */
+			upa_writel(ctx->fbc, &ffb->fbc);
+		}
+	}
+
+	/* Restore the 32x32 area pattern. */
+	for (i = 0; i < 32; i++)
+		upa_writel(ctx->area_pattern[i], &ffb->pattern[i]);
+
+	/* Finally, stash away the User Constol/Status Register.
+	 * The only state we really preserve here is the picking
+	 * control.
+	 */
+	upa_writel((ctx->ucsr & 0xf0000), &ffb->ucsr);
+}
+
+#define FFB_UCSR_FB_BUSY       0x01000000
+#define FFB_UCSR_RP_BUSY       0x02000000
+#define FFB_UCSR_ALL_BUSY      (FFB_UCSR_RP_BUSY|FFB_UCSR_FB_BUSY)
+
+static void FFBWait(ffb_fbcPtr ffb)
+{
+	int limit = 100000;
+
+	do {
+		u32 regval = upa_readl(&ffb->ucsr);
+
+		if ((regval & FFB_UCSR_ALL_BUSY) == 0)
+			break;
+	} while (--limit);
+}
+
+int ffb_context_switch(drm_device_t *dev, int old, int new)
+{
+	ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) (dev + 1);
+
+        atomic_inc(&dev->total_ctx);
+
+#if DRM_DMA_HISTOGRAM
+        dev->ctx_start = get_cycles();
+#endif
+        
+        DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+        if (new == dev->last_context ||
+	    dev->last_context == 0) {
+		dev->last_context = new;
+                return 0;
+	}
+        
+	FFBWait(fpriv->regs);
+	ffb_save_context(fpriv, old);
+	ffb_restore_context(fpriv, old, new);
+	FFBWait(fpriv->regs);
+        
+	dev->last_context = new;
+
+        return 0;
+}
+
+int ffb_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_res_t	res;
+	drm_ctx_t	ctx;
+	int		i;
+
+	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
+	if (copy_from_user(&res, (drm_ctx_res_t *)arg, sizeof(res)))
+		return -EFAULT;
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+			ctx.handle = i;
+			if (copy_to_user(&res.contexts[i],
+					 &i,
+					 sizeof(i)))
+				return -EFAULT;
+		}
+	}
+	res.count = DRM_RESERVED_CONTEXTS;
+	if (copy_to_user((drm_ctx_res_t *)arg, &res, sizeof(res)))
+		return -EFAULT;
+	return 0;
+}
+
+
+int ffb_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+	int idx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	idx = ffb_alloc_queue(dev, (ctx.flags & _DRM_CONTEXT_2DONLY));
+	if (idx < 0)
+		return -ENFILE;
+
+	DRM_DEBUG("%d\n", ctx.handle);
+	ctx.handle = idx;
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int ffb_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	ffb_dev_priv_t	*fpriv	= (ffb_dev_priv_t *) (dev + 1);
+	struct ffb_hw_context *hwctx;
+	drm_ctx_t ctx;
+	int idx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+
+	idx = ctx.handle;
+	if (idx <= 0 || idx >= FFB_MAX_CTXS)
+		return -EINVAL;
+
+	hwctx = fpriv->hw_state[idx - 1];
+	if (hwctx == NULL)
+		return -EINVAL;
+
+	if ((ctx.flags & _DRM_CONTEXT_2DONLY) == 0)
+		hwctx->is_2d_only = 0;
+	else
+		hwctx->is_2d_only = 1;
+
+	return 0;
+}
+
+int ffb_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	ffb_dev_priv_t	*fpriv	= (ffb_dev_priv_t *) (dev + 1);
+	struct ffb_hw_context *hwctx;
+	drm_ctx_t ctx;
+	int idx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+
+	idx = ctx.handle;
+	if (idx <= 0 || idx >= FFB_MAX_CTXS)
+		return -EINVAL;
+
+	hwctx = fpriv->hw_state[idx - 1];
+	if (hwctx == NULL)
+		return -EINVAL;
+
+	if (hwctx->is_2d_only != 0)
+		ctx.flags = _DRM_CONTEXT_2DONLY;
+	else
+		ctx.flags = 0;
+
+	if (copy_to_user((drm_ctx_t*)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+
+	return 0;
+}
+
+int ffb_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	return ffb_context_switch(dev, dev->last_context, ctx.handle);
+}
+
+int ffb_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+
+	return 0;
+}
+
+int ffb_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_t	ctx;
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	ffb_dev_priv_t	*fpriv	= (ffb_dev_priv_t *) (dev + 1);
+	int idx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+
+	idx = ctx.handle - 1;
+	if (idx < 0 || idx >= FFB_MAX_CTXS)
+		return -EINVAL;
+
+	if (fpriv->hw_state[idx] != NULL) {
+		kfree(fpriv->hw_state[idx]);
+		fpriv->hw_state[idx] = NULL;
+	}
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/ffb_drv.c linux/drivers/char/drm-4.0/ffb_drv.c
--- linux.orig/drivers/char/drm-4.0/ffb_drv.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/ffb_drv.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,951 @@
+/* $Id: ffb_drv.c,v 1.14 2001/05/24 12:01:47 davem Exp $
+ * ffb_drv.c: Creator/Creator3D direct rendering driver.
+ *
+ * Copyright (C) 2000 David S. Miller (davem@redhat.com)
+ */
+
+#include "drmP.h"
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <asm/shmparam.h>
+#include <asm/oplib.h>
+#include <asm/upa.h>
+
+#include "ffb_drv.h"
+
+#define FFB_NAME	"ffb"
+#define FFB_DESC	"Creator/Creator3D"
+#define FFB_DATE	"20000517"
+#define FFB_MAJOR	0
+#define FFB_MINOR	0
+#define FFB_PATCHLEVEL	1
+
+/* Forward declarations. */
+int  ffb_init(void);
+void ffb_cleanup(void);
+static int  ffb_version(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+static int  ffb_open(struct inode *inode, struct file *filp);
+static int  ffb_release(struct inode *inode, struct file *filp);
+static int  ffb_ioctl(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+static int  ffb_lock(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg);
+static int  ffb_unlock(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+static int ffb_mmap(struct file *filp, struct vm_area_struct *vma);
+static unsigned long ffb_get_unmapped_area(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
+
+/* From ffb_context.c */
+extern int ffb_resctx(struct inode *, struct file *, unsigned int, unsigned long);
+extern int ffb_addctx(struct inode *, struct file *, unsigned int, unsigned long);
+extern int ffb_modctx(struct inode *, struct file *, unsigned int, unsigned long);
+extern int ffb_getctx(struct inode *, struct file *, unsigned int, unsigned long);
+extern int ffb_switchctx(struct inode *, struct file *, unsigned int, unsigned long);
+extern int ffb_newctx(struct inode *, struct file *, unsigned int, unsigned long);
+extern int ffb_rmctx(struct inode *, struct file *, unsigned int, unsigned long);
+extern int ffb_context_switch(drm_device_t *, int, int);
+
+static struct file_operations ffb_fops = {
+	owner:			THIS_MODULE,
+	open:			ffb_open,
+	flush:			drm_flush,
+	release:		ffb_release,
+	ioctl:			ffb_ioctl,
+	mmap:			ffb_mmap,
+	read:			drm_read,
+	fasync:			drm_fasync,
+	poll:			drm_poll,
+	get_unmapped_area:	ffb_get_unmapped_area,
+};
+
+/* This is just a template, we make a new copy for each FFB
+ * we discover at init time so that each one gets a unique
+ * misc device minor number.
+ */
+static struct miscdevice ffb_misc = {
+	minor:	MISC_DYNAMIC_MINOR,
+	name:	FFB_NAME,
+	fops:	&ffb_fops,
+};
+
+static drm_ioctl_desc_t ffb_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]    = { ffb_version,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)] = { drm_getunique,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]  = { drm_getmagic,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]  = { drm_irq_busid,	  0, 1 }, /* XXX */
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)] = { drm_setunique,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]	     = { drm_block,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]    = { drm_unblock,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)] = { drm_authmagic,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]    = { drm_addmap,	  1, 1 },
+	
+	/* The implementation is currently a nop just like on tdfx.
+	 * Later we can do something more clever. -DaveM
+	 */
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]    = { ffb_addctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]     = { ffb_rmctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]    = { ffb_modctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]    = { ffb_getctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)] = { ffb_switchctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]    = { ffb_newctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]    = { ffb_resctx,	  1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]   = { drm_adddraw,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]    = { drm_rmdraw,	  1, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	     = { ffb_lock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]     = { ffb_unlock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]     = { drm_finish,	  1, 0 },
+};
+#define FFB_IOCTL_COUNT DRM_ARRAY_SIZE(ffb_ioctls)
+
+#ifdef MODULE
+static char *ffb = NULL;
+#endif
+
+MODULE_AUTHOR("David S. Miller (davem@redhat.com)");
+MODULE_DESCRIPTION("Sun Creator/Creator3D DRI");
+
+static int ffb_takedown(drm_device_t *dev)
+{
+	int		  i;
+	drm_magic_entry_t *pt, *next;
+	drm_map_t	  *map;
+	drm_vma_entry_t	  *vma, *vma_next;
+
+	DRM_DEBUG("\n");
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
+	
+	if (dev->devname) {
+		drm_free(dev->devname, strlen(dev->devname)+1, DRM_MEM_DRIVER);
+		dev->devname = NULL;
+	}
+	
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique)+1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
+
+	/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
+			next = pt->next;
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+		}
+		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
+	}
+	
+	/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
+			vma_next = vma->next;
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		}
+		dev->vmalist = NULL;
+	}
+	
+	/* Clear map area information */
+	if (dev->maplist) {
+		for (i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			switch (map->type) {
+			case _DRM_REGISTERS:
+			case _DRM_FRAME_BUFFER:
+				drm_ioremapfree(map->handle, map->size, dev);
+				break;
+
+			case _DRM_SHM:
+				drm_free_pages((unsigned long)map->handle,
+					       drm_order(map->size)
+					       - PAGE_SHIFT,
+					       DRM_MEM_SAREA);
+				break;
+
+			default:
+				break;
+			};
+
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		}
+
+		drm_free(dev->maplist,
+			 dev->map_count * sizeof(*dev->maplist),
+			 DRM_MEM_MAPS);
+		dev->maplist   = NULL;
+		dev->map_count = 0;
+	}
+	
+	if (dev->lock.hw_lock) {
+		dev->lock.hw_lock    = NULL; /* SHM removed */
+		dev->lock.pid	     = 0;
+		wake_up_interruptible(&dev->lock.lock_queue);
+	}
+	up(&dev->struct_sem);
+	
+	return 0;
+}
+
+drm_device_t **ffb_dev_table;
+static int ffb_dev_table_size;
+
+static void get_ffb_type(ffb_dev_priv_t *ffb_priv, int instance)
+{
+	volatile unsigned char *strap_bits;
+	unsigned char val;
+
+	strap_bits = (volatile unsigned char *)
+		(ffb_priv->card_phys_base + 0x00200000UL);
+
+	/* Don't ask, you have to read the value twice for whatever
+	 * reason to get correct contents.
+	 */
+	val = upa_readb(strap_bits);
+	val = upa_readb(strap_bits);
+	switch (val & 0x78) {
+	case (0x0 << 5) | (0x0 << 3):
+		ffb_priv->ffb_type = ffb1_prototype;
+		printk("ffb%d: Detected FFB1 pre-FCS prototype\n", instance);
+		break;
+	case (0x0 << 5) | (0x1 << 3):
+		ffb_priv->ffb_type = ffb1_standard;
+		printk("ffb%d: Detected FFB1\n", instance);
+		break;
+	case (0x0 << 5) | (0x3 << 3):
+		ffb_priv->ffb_type = ffb1_speedsort;
+		printk("ffb%d: Detected FFB1-SpeedSort\n", instance);
+		break;
+	case (0x1 << 5) | (0x0 << 3):
+		ffb_priv->ffb_type = ffb2_prototype;
+		printk("ffb%d: Detected FFB2/vertical pre-FCS prototype\n", instance);
+		break;
+	case (0x1 << 5) | (0x1 << 3):
+		ffb_priv->ffb_type = ffb2_vertical;
+		printk("ffb%d: Detected FFB2/vertical\n", instance);
+		break;
+	case (0x1 << 5) | (0x2 << 3):
+		ffb_priv->ffb_type = ffb2_vertical_plus;
+		printk("ffb%d: Detected FFB2+/vertical\n", instance);
+		break;
+	case (0x2 << 5) | (0x0 << 3):
+		ffb_priv->ffb_type = ffb2_horizontal;
+		printk("ffb%d: Detected FFB2/horizontal\n", instance);
+		break;
+	case (0x2 << 5) | (0x2 << 3):
+		ffb_priv->ffb_type = ffb2_horizontal;
+		printk("ffb%d: Detected FFB2+/horizontal\n", instance);
+		break;
+	default:
+		ffb_priv->ffb_type = ffb2_vertical;
+		printk("ffb%d: Unknown boardID[%08x], assuming FFB2\n", instance, val);
+		break;
+	};
+}
+
+static void __init ffb_apply_upa_parent_ranges(int parent, struct linux_prom64_registers *regs)
+{
+	struct linux_prom64_ranges ranges[PROMREG_MAX];
+	char name[128];
+	int len, i;
+
+	prom_getproperty(parent, "name", name, sizeof(name));
+	if (strcmp(name, "upa") != 0)
+		return;
+
+	len = prom_getproperty(parent, "ranges", (void *) ranges, sizeof(ranges));
+	if (len <= 0)
+		return;
+
+	len /= sizeof(struct linux_prom64_ranges);
+	for (i = 0; i < len; i++) {
+		struct linux_prom64_ranges *rng = &ranges[i];
+		u64 phys_addr = regs->phys_addr;
+
+		if (phys_addr >= rng->ot_child_base &&
+		    phys_addr < (rng->ot_child_base + rng->or_size)) {
+			regs->phys_addr -= rng->ot_child_base;
+			regs->phys_addr += rng->ot_parent_base;
+			return;
+		}
+	}
+
+	return;
+}
+
+static int __init ffb_init_one(int prom_node, int parent_node, int instance)
+{
+	struct linux_prom64_registers regs[2*PROMREG_MAX];
+	drm_device_t *dev;
+	ffb_dev_priv_t *ffb_priv;
+	int ret, i;
+
+	dev = kmalloc(sizeof(drm_device_t) + sizeof(ffb_dev_priv_t), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	memset(dev, 0, sizeof(*dev));
+	spin_lock_init(&dev->count_lock);
+	sema_init(&dev->struct_sem, 1);
+
+	ffb_priv = (ffb_dev_priv_t *) (dev + 1);
+	ffb_priv->prom_node = prom_node;
+	if (prom_getproperty(ffb_priv->prom_node, "reg",
+			     (void *)regs, sizeof(regs)) <= 0) {
+		kfree(dev);
+		return -EINVAL;
+	}
+	ffb_apply_upa_parent_ranges(parent_node, &regs[0]);
+	ffb_priv->card_phys_base = regs[0].phys_addr;
+	ffb_priv->regs = (ffb_fbcPtr)
+		(regs[0].phys_addr + 0x00600000UL);
+	get_ffb_type(ffb_priv, instance);
+	for (i = 0; i < FFB_MAX_CTXS; i++)
+		ffb_priv->hw_state[i] = NULL;
+
+	ffb_dev_table[instance] = dev;
+
+#ifdef MODULE
+	drm_parse_options(ffb);
+#endif
+
+	memcpy(&ffb_priv->miscdev, &ffb_misc, sizeof(ffb_misc));
+	ret = misc_register(&ffb_priv->miscdev);
+	if (ret) {
+		ffb_dev_table[instance] = NULL;
+		kfree(dev);
+		return ret;
+	}
+
+	dev->device = MKDEV(MISC_MAJOR, ffb_priv->miscdev.minor);
+	dev->name = FFB_NAME;
+
+	drm_mem_init();
+	drm_proc_init(dev);
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d at %016lx\n",
+		 FFB_NAME,
+		 FFB_MAJOR,
+		 FFB_MINOR,
+		 FFB_PATCHLEVEL,
+		 FFB_DATE,
+		 ffb_priv->miscdev.minor,
+		 ffb_priv->card_phys_base);
+	
+	return 0;
+}
+
+static int __init ffb_count_siblings(int root)
+{
+	int node, child, count = 0;
+
+	child = prom_getchild(root);
+	for (node = prom_searchsiblings(child, "SUNW,ffb"); node;
+	     node = prom_searchsiblings(prom_getsibling(node), "SUNW,ffb"))
+		count++;
+
+	return count;
+}
+
+static int __init ffb_init_dev_table(void)
+{
+	int root, total;
+
+	total = ffb_count_siblings(prom_root_node);
+	root = prom_getchild(prom_root_node);
+	for (root = prom_searchsiblings(root, "upa"); root;
+	     root = prom_searchsiblings(prom_getsibling(root), "upa"))
+		total += ffb_count_siblings(root);
+
+	if (!total)
+		return -ENODEV;
+
+	ffb_dev_table = kmalloc(sizeof(drm_device_t *) * total, GFP_KERNEL);
+	if (!ffb_dev_table)
+		return -ENOMEM;
+
+	ffb_dev_table_size = total;
+
+	return 0;
+}
+
+static int __init ffb_scan_siblings(int root, int instance)
+{
+	int node, child;
+
+	child = prom_getchild(root);
+	for (node = prom_searchsiblings(child, "SUNW,ffb"); node;
+	     node = prom_searchsiblings(prom_getsibling(node), "SUNW,ffb")) {
+		ffb_init_one(node, root, instance);
+		instance++;
+	}
+
+	return instance;
+}
+
+int __init ffb_init(void)
+{
+	int root, instance, ret;
+
+	ret = ffb_init_dev_table();
+	if (ret)
+		return ret;
+
+	instance = ffb_scan_siblings(prom_root_node, 0);
+
+	root = prom_getchild(prom_root_node);
+	for (root = prom_searchsiblings(root, "upa"); root;
+	     root = prom_searchsiblings(prom_getsibling(root), "upa"))
+		instance = ffb_scan_siblings(root, instance);
+
+	return 0;
+}
+
+void __exit ffb_cleanup(void)
+{
+	int instance;
+
+	DRM_DEBUG("\n");
+	
+	drm_proc_cleanup();
+	for (instance = 0; instance < ffb_dev_table_size; instance++) {
+		drm_device_t *dev = ffb_dev_table[instance];
+		ffb_dev_priv_t *ffb_priv;
+
+		if (!dev)
+			continue;
+
+		ffb_priv = (ffb_dev_priv_t *) (dev + 1);
+		if (misc_deregister(&ffb_priv->miscdev)) {
+			DRM_ERROR("Cannot unload module\n");
+		} else {
+			DRM_INFO("Module unloaded\n");
+		}
+		ffb_takedown(dev);
+		kfree(dev);
+		ffb_dev_table[instance] = NULL;
+	}
+	kfree(ffb_dev_table);
+	ffb_dev_table = NULL;
+	ffb_dev_table_size = 0;
+}
+
+static int ffb_version(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	drm_version_t version;
+	int len, ret;
+
+	ret = copy_from_user(&version, (drm_version_t *)arg, sizeof(version));
+	if (ret)
+		return -EFAULT;
+
+	version.version_major		= FFB_MAJOR;
+	version.version_minor		= FFB_MINOR;
+	version.version_patchlevel	= FFB_PATCHLEVEL;
+
+	len = strlen(FFB_NAME);
+	if (len > version.name_len)
+		len = version.name_len;
+	version.name_len = len;
+	if (len && version.name) {
+		ret = copy_to_user(version.name, FFB_NAME, len);
+		if (ret)
+			return -EFAULT;
+	}
+
+	len = strlen(FFB_DATE);
+	if (len > version.date_len)
+		len = version.date_len;
+	version.date_len = len;
+	if (len && version.date) {
+		ret = copy_to_user(version.date, FFB_DATE, len);
+		if (ret)
+			return -EFAULT;
+	}
+
+	len = strlen(FFB_DESC);
+	if (len > version.desc_len)
+		len = version.desc_len;
+	version.desc_len = len;
+	if (len && version.desc) {
+		ret = copy_to_user(version.desc, FFB_DESC, len);
+		if (ret)
+			return -EFAULT;
+	}
+
+	ret = copy_to_user((drm_version_t *) arg, &version, sizeof(version));
+	if (ret)
+		ret = -EFAULT;
+
+	return ret;
+}
+
+static int ffb_setup(drm_device_t *dev)
+{
+	int i;
+
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
+	dev->buf_use = 0;
+	atomic_set(&dev->buf_alloc, 0);
+
+	atomic_set(&dev->total_open, 0);
+	atomic_set(&dev->total_close, 0);
+	atomic_set(&dev->total_ioctl, 0);
+	atomic_set(&dev->total_irq, 0);
+	atomic_set(&dev->total_ctx, 0);
+	atomic_set(&dev->total_locks, 0);
+	atomic_set(&dev->total_unlocks, 0);
+	atomic_set(&dev->total_contends, 0);
+	atomic_set(&dev->total_sleeps, 0);
+
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		dev->magiclist[i].head = NULL;
+		dev->magiclist[i].tail = NULL;
+	}
+
+	dev->maplist	    = NULL;
+	dev->map_count	    = 0;
+	dev->vmalist	    = NULL;
+	dev->lock.hw_lock   = NULL;
+	init_waitqueue_head(&dev->lock.lock_queue);
+	dev->queue_count    = 0;
+	dev->queue_reserved = 0;
+	dev->queue_slots    = 0;
+	dev->queuelist	    = NULL;
+	dev->irq	    = 0;
+	dev->context_flag   = 0;
+	dev->interrupt_flag = 0;
+	dev->dma            = 0;
+	dev->dma_flag	    = 0;
+	dev->last_context   = 0;
+	dev->last_switch    = 0;
+	dev->last_checked   = 0;
+	init_timer(&dev->timer);
+	init_waitqueue_head(&dev->context_wait);
+
+	dev->ctx_start	    = 0;
+	dev->lck_start	    = 0;
+	
+	dev->buf_rp	  = dev->buf;
+	dev->buf_wp	  = dev->buf;
+	dev->buf_end	  = dev->buf + DRM_BSZ;
+	dev->buf_async	  = NULL;
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
+
+	return 0;
+}
+
+static int ffb_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t *dev;
+	int minor, i;
+	int ret = 0;
+
+	minor = MINOR(inode->i_rdev);
+	for (i = 0; i < ffb_dev_table_size; i++) {
+		ffb_dev_priv_t *ffb_priv;
+
+		ffb_priv = (ffb_dev_priv_t *) (ffb_dev_table[i] + 1);
+
+		if (ffb_priv->miscdev.minor == minor)
+			break;
+	}
+
+	if (i >= ffb_dev_table_size)
+		return -EINVAL;
+
+	dev = ffb_dev_table[i];
+	if (!dev)
+		return -EINVAL;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	ret = drm_open_helper(inode, filp, dev);
+	if (!ret) {
+		atomic_inc(&dev->total_open);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return ffb_setup(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+
+	return ret;
+}
+
+static int ffb_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev;
+	int ret = 0;
+
+	lock_kernel();
+	dev = priv->dev;
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (dev->lock.hw_lock != NULL
+	    && _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)
+	    && dev->lock.pid == current->pid) {
+		ffb_dev_priv_t *fpriv = (ffb_dev_priv_t *) (dev + 1);
+		int context = _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock);
+		int idx;
+
+		/* We have to free up the rogue hw context state
+		 * holding error or else we will leak it.
+		 */
+		idx = context - 1;
+		if (fpriv->hw_state[idx] != NULL) {
+			kfree(fpriv->hw_state[idx]);
+			fpriv->hw_state[idx] = NULL;
+		}
+	}
+
+	ret = drm_release(inode, filp);
+
+	if (!ret) {
+		atomic_inc(&dev->total_close);
+		spin_lock(&dev->count_lock);
+		if (!--dev->open_count) {
+			if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+				DRM_ERROR("Device busy: %d %d\n",
+					  atomic_read(&dev->ioctl_count),
+					  dev->blocked);
+				spin_unlock(&dev->count_lock);
+				unlock_kernel();
+				return -EBUSY;
+			}
+			spin_unlock(&dev->count_lock);
+			ret = ffb_takedown(dev);
+			unlock_kernel();
+			return ret;
+		}
+		spin_unlock(&dev->count_lock);
+	}
+
+	unlock_kernel();
+	return ret;
+}
+
+static int ffb_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int		 nr	 = DRM_IOCTL_NR(cmd);
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_ioctl_desc_t *ioctl;
+	drm_ioctl_t	 *func;
+	int		 ret;
+
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->total_ioctl);
+	++priv->ioctl_count;
+	
+	DRM_DEBUG("pid = %d, cmd = 0x%02x, nr = 0x%02x, dev 0x%x, auth = %d\n",
+		  current->pid, cmd, nr, dev->device, priv->authenticated);
+
+	if (nr >= FFB_IOCTL_COUNT) {
+		ret = -EINVAL;
+	} else {
+		ioctl	  = &ffb_ioctls[nr];
+		func	  = ioctl->func;
+
+		if (!func) {
+			DRM_DEBUG("no function\n");
+			ret = -EINVAL;
+		} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN))
+			    || (ioctl->auth_needed && !priv->authenticated)) {
+			ret = -EACCES;
+		} else {
+			ret = (func)(inode, filp, cmd, arg);
+		}
+	}
+	
+	atomic_dec(&dev->ioctl_count);
+
+	return ret;
+}
+
+static int ffb_lock(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+        drm_file_t        *priv	= filp->private_data;
+        drm_device_t      *dev	= priv->dev;
+        DECLARE_WAITQUEUE(entry, current);
+        int               ret	= 0;
+        drm_lock_t        lock;
+
+	ret = copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock));
+	if (ret)
+		return -EFAULT;
+
+        if (lock.context == DRM_KERNEL_CONTEXT) {
+                DRM_ERROR("Process %d using kernel context %d\n",
+                          current->pid, lock.context);
+                return -EINVAL;
+        }
+
+        DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+                  lock.context, current->pid, dev->lock.hw_lock->lock,
+                  lock.flags);
+
+	add_wait_queue(&dev->lock.lock_queue, &entry);
+	for (;;) {
+		if (!dev->lock.hw_lock) {
+			/* Device has been unregistered */
+			ret = -EINTR;
+			break;
+		}
+		if (drm_lock_take(&dev->lock.hw_lock->lock,
+				  lock.context)) {
+			dev->lock.pid       = current->pid;
+			dev->lock.lock_time = jiffies;
+			atomic_inc(&dev->total_locks);
+			break;  /* Got lock */
+		}
+                        
+		/* Contention */
+		atomic_inc(&dev->total_sleeps);
+		current->state = TASK_INTERRUPTIBLE;
+		current->policy |= SCHED_YIELD;
+		schedule();
+		if (signal_pending(current)) {
+			ret = -ERESTARTSYS;
+			break;
+		}
+	}
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&dev->lock.lock_queue, &entry);
+
+        if (!ret) {
+		sigemptyset(&dev->sigmask);
+		sigaddset(&dev->sigmask, SIGSTOP);
+		sigaddset(&dev->sigmask, SIGTSTP);
+		sigaddset(&dev->sigmask, SIGTTIN);
+		sigaddset(&dev->sigmask, SIGTTOU);
+		dev->sigdata.context = lock.context;
+		dev->sigdata.lock = dev->lock.hw_lock;
+		block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+
+		if (dev->last_context != lock.context)
+			ffb_context_switch(dev, dev->last_context, lock.context);
+	}
+
+        DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
+
+        return ret;
+}
+
+int ffb_unlock(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+	unsigned int old, new, prev, ctx;
+	int ret;
+
+	ret = copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock));
+	if (ret)
+		return -EFAULT;
+	
+	if ((ctx = lock.context) == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d frees lock (%d holds)\n",
+		  lock.context,
+		  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	atomic_inc(&dev->total_unlocks);
+	if (_DRM_LOCK_IS_CONT(dev->lock.hw_lock->lock))
+		atomic_inc(&dev->total_contends);
+
+	/* We no longer really hold it, but if we are the next
+	 * agent to request it then we should just be able to
+	 * take it immediately and not eat the ioctl.
+	 */
+	dev->lock.pid = 0;
+	{
+		__volatile__ unsigned int *plock = &dev->lock.hw_lock->lock;
+
+		do {
+			old  = *plock;
+			new  = ctx;
+			prev = cmpxchg(plock, old, new);
+		} while (prev != old);
+	}
+
+	wake_up_interruptible(&dev->lock.lock_queue);
+	
+	unblock_all_signals();
+	return 0;
+}
+
+extern struct vm_operations_struct drm_vm_ops;
+extern struct vm_operations_struct drm_vm_shm_ops;
+extern struct vm_operations_struct drm_vm_shm_lock_ops;
+
+static int ffb_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_map_t	*map	= NULL;
+	ffb_dev_priv_t	*ffb_priv;
+	int		i, minor;
+	
+	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
+		  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
+
+	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
+	ffb_priv = NULL;
+	for (i = 0; i < ffb_dev_table_size; i++) {
+		ffb_priv = (ffb_dev_priv_t *) (ffb_dev_table[i] + 1);
+		if (ffb_priv->miscdev.minor == minor)
+			break;
+	}
+	if (i >= ffb_dev_table_size)
+		return -EINVAL;
+
+	/* We don't support/need dma mappings, so... */
+	if (!VM_OFFSET(vma))
+		return -EINVAL;
+
+	for (i = 0; i < dev->map_count; i++) {
+		unsigned long off;
+
+		map = dev->maplist[i];
+
+		/* Ok, a little hack to make 32-bit apps work. */
+		off = (map->offset & 0xffffffff);
+		if (off == VM_OFFSET(vma))
+			break;
+	}
+
+	if (i >= dev->map_count)
+		return -EINVAL;
+
+	if (!map ||
+	    ((map->flags & _DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))
+		return -EPERM;
+
+	if (map->size != (vma->vm_end - vma->vm_start))
+		return -EINVAL;
+
+	/* Set read-only attribute before mappings are created
+	 * so it works for fb/reg maps too.
+	 */
+	if (map->flags & _DRM_READ_ONLY)
+		vma->vm_page_prot = __pgprot(pte_val(pte_wrprotect(
+			__pte(pgprot_val(vma->vm_page_prot)))));
+
+	switch (map->type) {
+	case _DRM_FRAME_BUFFER:
+		/* FALLTHROUGH */
+
+	case _DRM_REGISTERS:
+		/* In order to handle 32-bit drm apps/xserver we
+		 * play a trick.  The mappings only really specify
+		 * the 32-bit offset from the cards 64-bit base
+		 * address, and we just add in the base here.
+		 */
+		vma->vm_flags |= VM_IO;
+		if (io_remap_page_range(vma->vm_start,
+					ffb_priv->card_phys_base + VM_OFFSET(vma),
+					vma->vm_end - vma->vm_start,
+					vma->vm_page_prot, 0))
+			return -EAGAIN;
+
+		vma->vm_ops = &drm_vm_ops;
+		break;
+	case _DRM_SHM:
+		if (map->flags & _DRM_CONTAINS_LOCK)
+			vma->vm_ops = &drm_vm_shm_lock_ops;
+		else {
+			vma->vm_ops = &drm_vm_shm_ops;
+			vma->vm_private_data = (void *) map;
+		}
+
+		/* Don't let this area swap.  Change when
+		 * DRM_KERNEL advisory is supported.
+		 */
+		vma->vm_flags |= VM_LOCKED;
+		break;
+	default:
+		return -EINVAL;	/* This should never happen. */
+	};
+
+	vma->vm_flags |= VM_LOCKED | VM_SHM; /* Don't swap */
+
+	vma->vm_file = filp; /* Needed for drm_vm_open() */
+	drm_vm_open(vma);
+	return 0;
+}
+
+static drm_map_t *ffb_find_map(struct file *filp, unsigned long off)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev;
+	drm_map_t	*map;
+	int		i;
+
+	if (!priv || (dev = priv->dev) == NULL)
+		return NULL;
+
+	for (i = 0; i < dev->map_count; i++) {
+		unsigned long uoff;
+
+		map = dev->maplist[i];
+
+		/* Ok, a little hack to make 32-bit apps work. */
+		uoff = (map->offset & 0xffffffff);
+		if (uoff == off)
+			return map;
+	}
+	return NULL;
+}
+
+static unsigned long ffb_get_unmapped_area(struct file *filp, unsigned long hint, unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+	drm_map_t *map = ffb_find_map(filp, pgoff << PAGE_SHIFT);
+	unsigned long addr = -ENOMEM;
+
+	if (!map)
+		return get_unmapped_area(NULL, hint, len, pgoff, flags);
+
+	if (map->type == _DRM_FRAME_BUFFER ||
+	    map->type == _DRM_REGISTERS) {
+#ifdef HAVE_ARCH_FB_UNMAPPED_AREA
+		addr = get_fb_unmapped_area(filp, hint, len, pgoff, flags);
+#else
+		addr = get_unmapped_area(NULL, hint, len, pgoff, flags);
+#endif
+	} else if (map->type == _DRM_SHM && SHMLBA > PAGE_SIZE) {
+		unsigned long slack = SHMLBA - PAGE_SIZE;
+
+		addr = get_unmapped_area(NULL, hint, len + slack, pgoff, flags);
+		if (!(addr & ~PAGE_MASK)) {
+			unsigned long kvirt = (unsigned long) map->handle;
+
+			if ((kvirt & (SHMLBA - 1)) != (addr & (SHMLBA - 1))) {
+				unsigned long koff, aoff;
+
+				koff = kvirt & (SHMLBA - 1);
+				aoff = addr & (SHMLBA - 1);
+				if (koff < aoff)
+					koff += SHMLBA;
+
+				addr += (koff - aoff);
+			}
+		}
+	} else {
+		addr = get_unmapped_area(NULL, hint, len, pgoff, flags);
+	}
+
+	return addr;
+}
+
+module_init(ffb_init);
+module_exit(ffb_cleanup);
diff -urN linux.orig/drivers/char/drm-4.0/ffb_drv.h linux/drivers/char/drm-4.0/ffb_drv.h
--- linux.orig/drivers/char/drm-4.0/ffb_drv.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/ffb_drv.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,276 @@
+/* $Id: ffb_drv.h,v 1.1 2000/06/01 04:24:39 davem Exp $
+ * ffb_drv.h: Creator/Creator3D direct rendering driver.
+ *
+ * Copyright (C) 2000 David S. Miller (davem@redhat.com)
+ */
+
+/* Auxilliary clips. */
+typedef struct  {
+	volatile unsigned int min;
+	volatile unsigned int max;
+} ffb_auxclip, *ffb_auxclipPtr;
+
+/* FFB register set. */
+typedef struct _ffb_fbc {
+	/* Next vertex registers, on the right we list which drawops
+	 * use said register and the logical name the register has in
+	 * that context.
+	 */					/* DESCRIPTION		DRAWOP(NAME)	*/
+/*0x00*/unsigned int		pad1[3];	/* Reserved				*/
+/*0x0c*/volatile unsigned int	alpha;		/* ALPHA Transparency			*/
+/*0x10*/volatile unsigned int	red;		/* RED					*/
+/*0x14*/volatile unsigned int	green;		/* GREEN				*/
+/*0x18*/volatile unsigned int	blue;		/* BLUE					*/
+/*0x1c*/volatile unsigned int	z;		/* DEPTH				*/
+/*0x20*/volatile unsigned int	y;		/* Y			triangle(DOYF)	*/
+						/*                      aadot(DYF)	*/
+						/*                      ddline(DYF)	*/
+						/*                      aaline(DYF)	*/
+/*0x24*/volatile unsigned int	x;		/* X			triangle(DOXF)	*/
+						/*                      aadot(DXF)	*/
+						/*                      ddline(DXF)	*/
+						/*                      aaline(DXF)	*/
+/*0x28*/unsigned int		pad2[2];	/* Reserved				*/
+/*0x30*/volatile unsigned int	ryf;		/* Y (alias to DOYF)	ddline(RYF)	*/
+						/*			aaline(RYF)	*/
+						/*			triangle(RYF)	*/
+/*0x34*/volatile unsigned int	rxf;		/* X			ddline(RXF)	*/
+						/*			aaline(RXF)	*/
+						/*			triangle(RXF)	*/
+/*0x38*/unsigned int		pad3[2];	/* Reserved				*/
+/*0x40*/volatile unsigned int	dmyf;		/* Y (alias to DOYF)	triangle(DMYF)	*/
+/*0x44*/volatile unsigned int	dmxf;		/* X			triangle(DMXF)	*/
+/*0x48*/unsigned int		pad4[2];	/* Reserved				*/
+/*0x50*/volatile unsigned int	ebyi;		/* Y (alias to RYI)	polygon(EBYI)	*/
+/*0x54*/volatile unsigned int	ebxi;		/* X			polygon(EBXI)	*/
+/*0x58*/unsigned int		pad5[2];	/* Reserved				*/
+/*0x60*/volatile unsigned int	by;		/* Y			brline(RYI)	*/
+						/*			fastfill(OP)	*/
+						/*			polygon(YI)	*/
+						/*			rectangle(YI)	*/
+						/*			bcopy(SRCY)	*/
+						/*			vscroll(SRCY)	*/
+/*0x64*/volatile unsigned int	bx;		/* X			brline(RXI)	*/
+						/*			polygon(XI)	*/
+						/*			rectangle(XI)	*/
+						/*			bcopy(SRCX)	*/
+						/*			vscroll(SRCX)	*/
+						/*			fastfill(GO)	*/
+/*0x68*/volatile unsigned int	dy;		/* destination Y	fastfill(DSTY)	*/
+						/*			bcopy(DSRY)	*/
+						/*			vscroll(DSRY)	*/
+/*0x6c*/volatile unsigned int	dx;		/* destination X	fastfill(DSTX)	*/
+						/*			bcopy(DSTX)	*/
+						/*			vscroll(DSTX)	*/
+/*0x70*/volatile unsigned int	bh;		/* Y (alias to RYI)	brline(DYI)	*/
+						/*			dot(DYI)	*/
+						/*			polygon(ETYI)	*/
+						/* Height		fastfill(H)	*/
+						/*			bcopy(H)	*/
+						/*			vscroll(H)	*/
+						/* Y count		fastfill(NY)	*/
+/*0x74*/volatile unsigned int	bw;		/* X			dot(DXI)	*/
+						/*			brline(DXI)	*/
+						/*			polygon(ETXI)	*/
+						/*			fastfill(W)	*/
+						/*			bcopy(W)	*/
+						/*			vscroll(W)	*/
+						/*			fastfill(NX)	*/
+/*0x78*/unsigned int		pad6[2];	/* Reserved				*/
+/*0x80*/unsigned int		pad7[32];	/* Reserved				*/
+	
+	/* Setup Unit's vertex state register */
+/*100*/	volatile unsigned int	suvtx;
+/*104*/	unsigned int		pad8[63];	/* Reserved				*/
+	
+	/* Frame Buffer Control Registers */
+/*200*/	volatile unsigned int	ppc;		/* Pixel Processor Control		*/
+/*204*/	volatile unsigned int	wid;		/* Current WID				*/
+/*208*/	volatile unsigned int	fg;		/* FG data				*/
+/*20c*/	volatile unsigned int	bg;		/* BG data				*/
+/*210*/	volatile unsigned int	consty;		/* Constant Y				*/
+/*214*/	volatile unsigned int	constz;		/* Constant Z				*/
+/*218*/	volatile unsigned int	xclip;		/* X Clip				*/
+/*21c*/	volatile unsigned int	dcss;		/* Depth Cue Scale Slope		*/
+/*220*/	volatile unsigned int	vclipmin;	/* Viewclip XY Min Bounds		*/
+/*224*/	volatile unsigned int	vclipmax;	/* Viewclip XY Max Bounds		*/
+/*228*/	volatile unsigned int	vclipzmin;	/* Viewclip Z Min Bounds		*/
+/*22c*/	volatile unsigned int	vclipzmax;	/* Viewclip Z Max Bounds		*/
+/*230*/	volatile unsigned int	dcsf;		/* Depth Cue Scale Front Bound		*/
+/*234*/	volatile unsigned int	dcsb;		/* Depth Cue Scale Back Bound		*/
+/*238*/	volatile unsigned int	dczf;		/* Depth Cue Z Front			*/
+/*23c*/	volatile unsigned int	dczb;		/* Depth Cue Z Back			*/
+/*240*/	unsigned int		pad9;		/* Reserved				*/
+/*244*/	volatile unsigned int	blendc;		/* Alpha Blend Control			*/
+/*248*/	volatile unsigned int	blendc1;	/* Alpha Blend Color 1			*/
+/*24c*/	volatile unsigned int	blendc2;	/* Alpha Blend Color 2			*/
+/*250*/	volatile unsigned int	fbramitc;	/* FB RAM Interleave Test Control	*/
+/*254*/	volatile unsigned int	fbc;		/* Frame Buffer Control			*/
+/*258*/	volatile unsigned int	rop;		/* Raster OPeration			*/
+/*25c*/	volatile unsigned int	cmp;		/* Frame Buffer Compare			*/
+/*260*/	volatile unsigned int	matchab;	/* Buffer AB Match Mask			*/
+/*264*/	volatile unsigned int	matchc;		/* Buffer C(YZ) Match Mask		*/
+/*268*/	volatile unsigned int	magnab;		/* Buffer AB Magnitude Mask		*/
+/*26c*/	volatile unsigned int	magnc;		/* Buffer C(YZ) Magnitude Mask		*/
+/*270*/	volatile unsigned int	fbcfg0;		/* Frame Buffer Config 0		*/
+/*274*/	volatile unsigned int	fbcfg1;		/* Frame Buffer Config 1		*/
+/*278*/	volatile unsigned int	fbcfg2;		/* Frame Buffer Config 2		*/
+/*27c*/	volatile unsigned int	fbcfg3;		/* Frame Buffer Config 3		*/
+/*280*/	volatile unsigned int	ppcfg;		/* Pixel Processor Config		*/
+/*284*/	volatile unsigned int	pick;		/* Picking Control			*/
+/*288*/	volatile unsigned int	fillmode;	/* FillMode				*/
+/*28c*/	volatile unsigned int	fbramwac;	/* FB RAM Write Address Control		*/
+/*290*/	volatile unsigned int	pmask;		/* RGB PlaneMask			*/
+/*294*/	volatile unsigned int	xpmask;		/* X PlaneMask				*/
+/*298*/	volatile unsigned int	ypmask;		/* Y PlaneMask				*/
+/*29c*/	volatile unsigned int	zpmask;		/* Z PlaneMask				*/
+/*2a0*/	ffb_auxclip		auxclip[4]; 	/* Auxilliary Viewport Clip		*/
+	
+	/* New 3dRAM III support regs */
+/*2c0*/	volatile unsigned int	rawblend2;
+/*2c4*/	volatile unsigned int	rawpreblend;
+/*2c8*/	volatile unsigned int	rawstencil;
+/*2cc*/	volatile unsigned int	rawstencilctl;
+/*2d0*/	volatile unsigned int	threedram1;
+/*2d4*/	volatile unsigned int	threedram2;
+/*2d8*/	volatile unsigned int	passin;
+/*2dc*/	volatile unsigned int	rawclrdepth;
+/*2e0*/	volatile unsigned int	rawpmask;
+/*2e4*/	volatile unsigned int	rawcsrc;
+/*2e8*/	volatile unsigned int	rawmatch;
+/*2ec*/	volatile unsigned int	rawmagn;
+/*2f0*/	volatile unsigned int	rawropblend;
+/*2f4*/	volatile unsigned int	rawcmp;
+/*2f8*/	volatile unsigned int	rawwac;
+/*2fc*/	volatile unsigned int	fbramid;
+	
+/*300*/	volatile unsigned int	drawop;		/* Draw OPeration			*/
+/*304*/	unsigned int		pad10[2];	/* Reserved				*/
+/*30c*/	volatile unsigned int	lpat;		/* Line Pattern control			*/
+/*310*/	unsigned int		pad11;		/* Reserved				*/
+/*314*/	volatile unsigned int	fontxy;		/* XY Font coordinate			*/
+/*318*/	volatile unsigned int	fontw;		/* Font Width				*/
+/*31c*/	volatile unsigned int	fontinc;	/* Font Increment			*/
+/*320*/	volatile unsigned int	font;		/* Font bits				*/
+/*324*/	unsigned int		pad12[3];	/* Reserved				*/
+/*330*/	volatile unsigned int	blend2;
+/*334*/	volatile unsigned int	preblend;
+/*338*/	volatile unsigned int	stencil;
+/*33c*/	volatile unsigned int	stencilctl;
+
+/*340*/	unsigned int		pad13[4];	/* Reserved				*/
+/*350*/	volatile unsigned int	dcss1;		/* Depth Cue Scale Slope 1		*/
+/*354*/	volatile unsigned int	dcss2;		/* Depth Cue Scale Slope 2		*/
+/*358*/	volatile unsigned int	dcss3;		/* Depth Cue Scale Slope 3		*/
+/*35c*/	volatile unsigned int	widpmask;
+/*360*/	volatile unsigned int	dcs2;
+/*364*/	volatile unsigned int	dcs3;
+/*368*/	volatile unsigned int	dcs4;
+/*36c*/	unsigned int		pad14;		/* Reserved				*/
+/*370*/	volatile unsigned int	dcd2;
+/*374*/	volatile unsigned int	dcd3;
+/*378*/	volatile unsigned int	dcd4;
+/*37c*/	unsigned int		pad15;		/* Reserved				*/
+/*380*/	volatile unsigned int	pattern[32];	/* area Pattern				*/
+/*400*/	unsigned int		pad16[8];	/* Reserved				*/
+/*420*/	volatile unsigned int	reset;		/* chip RESET				*/
+/*424*/	unsigned int		pad17[247];	/* Reserved				*/
+/*800*/	volatile unsigned int	devid;		/* Device ID				*/
+/*804*/	unsigned int		pad18[63];	/* Reserved				*/
+/*900*/	volatile unsigned int	ucsr;		/* User Control & Status Register	*/
+/*904*/	unsigned int		pad19[31];	/* Reserved				*/
+/*980*/	volatile unsigned int	mer;		/* Mode Enable Register			*/
+/*984*/	unsigned int		pad20[1439];	/* Reserved				*/
+} ffb_fbc, *ffb_fbcPtr;
+
+struct ffb_hw_context {
+	int is_2d_only;
+
+	unsigned int ppc;
+	unsigned int wid;
+	unsigned int fg;
+	unsigned int bg;
+	unsigned int consty;
+	unsigned int constz;
+	unsigned int xclip;
+	unsigned int dcss;
+	unsigned int vclipmin;
+	unsigned int vclipmax;
+	unsigned int vclipzmin;
+	unsigned int vclipzmax;
+	unsigned int dcsf;
+	unsigned int dcsb;
+	unsigned int dczf;
+	unsigned int dczb;
+	unsigned int blendc;
+	unsigned int blendc1;
+	unsigned int blendc2;
+	unsigned int fbc;
+	unsigned int rop;
+	unsigned int cmp;
+	unsigned int matchab;
+	unsigned int matchc;
+	unsigned int magnab;
+	unsigned int magnc;
+	unsigned int pmask;
+	unsigned int xpmask;
+	unsigned int ypmask;
+	unsigned int zpmask;
+	unsigned int auxclip0min;
+	unsigned int auxclip0max;
+	unsigned int auxclip1min;
+	unsigned int auxclip1max;
+	unsigned int auxclip2min;
+	unsigned int auxclip2max;
+	unsigned int auxclip3min;
+	unsigned int auxclip3max;
+	unsigned int drawop;
+	unsigned int lpat;
+	unsigned int fontxy;
+	unsigned int fontw;
+	unsigned int fontinc;
+	unsigned int area_pattern[32];
+	unsigned int ucsr;
+	unsigned int stencil;
+	unsigned int stencilctl;
+	unsigned int dcss1;
+	unsigned int dcss2;
+	unsigned int dcss3;
+	unsigned int dcs2;
+	unsigned int dcs3;
+	unsigned int dcs4;
+	unsigned int dcd2;
+	unsigned int dcd3;
+	unsigned int dcd4;
+	unsigned int mer;
+};
+
+#define FFB_MAX_CTXS	32
+
+enum ffb_chip_type {
+	ffb1_prototype = 0,	/* Early pre-FCS FFB */
+	ffb1_standard,		/* First FCS FFB, 100Mhz UPA, 66MHz gclk */
+	ffb1_speedsort,		/* Second FCS FFB, 100Mhz UPA, 75MHz gclk */
+	ffb2_prototype,		/* Early pre-FCS vertical FFB2 */
+	ffb2_vertical,		/* First FCS FFB2/vertical, 100Mhz UPA, 100MHZ gclk,
+				   75(SingleBuffer)/83(DoubleBuffer) MHz fclk */
+	ffb2_vertical_plus,	/* Second FCS FFB2/vertical, same timings */
+	ffb2_horizontal,	/* First FCS FFB2/horizontal, same timings as FFB2/vert */
+	ffb2_horizontal_plus,	/* Second FCS FFB2/horizontal, same timings */
+	afb_m3,			/* FCS Elite3D, 3 float chips */
+	afb_m6			/* FCS Elite3D, 6 float chips */
+};
+
+typedef struct ffb_dev_priv {
+	/* Misc software state. */
+	int			prom_node;
+	enum ffb_chip_type	ffb_type;
+	u64			card_phys_base;
+	struct miscdevice 	miscdev;
+
+	/* Controller registers. */
+	ffb_fbcPtr		regs;
+
+	/* Context table. */
+	struct ffb_hw_context	*hw_state[FFB_MAX_CTXS];
+} ffb_dev_priv_t;
diff -urN linux.orig/drivers/char/drm-4.0/fops.c linux/drivers/char/drm-4.0/fops.c
--- linux.orig/drivers/char/drm-4.0/fops.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/fops.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,253 @@
+/* fops.c -- File operations for DRM -*- linux-c -*-
+ * Created: Mon Jan  4 08:58:31 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *    Daryll Strauss <daryll@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include <linux/poll.h>
+
+/* drm_open is called whenever a process opens /dev/drm. */
+
+int drm_open_helper(struct inode *inode, struct file *filp, drm_device_t *dev)
+{
+	kdev_t	     minor = MINOR(inode->i_rdev);
+	drm_file_t   *priv;
+
+	if (filp->f_flags & O_EXCL)   return -EBUSY; /* No exclusive opens */
+	if (!drm_cpu_valid())         return -EINVAL;
+
+	DRM_DEBUG("pid = %d, minor = %d\n", current->pid, minor);
+
+	priv		    = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
+	if(priv == NULL)
+		return -ENOMEM;
+	memset(priv, 0, sizeof(*priv));
+
+	filp->private_data  = priv;
+	priv->uid	    = current->euid;
+	priv->pid	    = current->pid;
+	priv->minor	    = minor;
+	priv->dev	    = dev;
+	priv->ioctl_count   = 0;
+	priv->authenticated = capable(CAP_SYS_ADMIN);
+
+	down(&dev->struct_sem);
+	if (!dev->file_last) {
+		priv->next	= NULL;
+		priv->prev	= NULL;
+		dev->file_first = priv;
+		dev->file_last	= priv;
+	} else {
+		priv->next	     = NULL;
+		priv->prev	     = dev->file_last;
+		dev->file_last->next = priv;
+		dev->file_last	     = priv;
+	}
+	up(&dev->struct_sem);
+	
+	return 0;
+}
+
+int drm_flush(struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev    = priv->dev;
+
+	DRM_DEBUG("pid = %d, device = 0x%x, open_count = %d\n",
+		  current->pid, dev->device, dev->open_count);
+	return 0;
+}
+
+/* drm_release is called whenever a process closes /dev/drm*.  Linux calls
+   this only if any mappings have been closed. */
+
+int drm_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev    = priv->dev;
+
+	DRM_DEBUG("pid = %d, device = 0x%x, open_count = %d\n",
+		  current->pid, dev->device, dev->open_count);
+
+	if (dev->lock.hw_lock
+	    && _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)
+	    && dev->lock.pid == current->pid) {
+		DRM_ERROR("Process %d dead, freeing lock for context %d\n",
+			  current->pid,
+			  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+		drm_lock_free(dev,
+			      &dev->lock.hw_lock->lock,
+			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+		
+				/* FIXME: may require heavy-handed reset of
+                                   hardware at this point, possibly
+                                   processed via a callback to the X
+                                   server. */
+	}
+	drm_reclaim_buffers(dev, priv->pid);
+
+	drm_fasync(-1, filp, 0);
+
+	down(&dev->struct_sem);
+	if (priv->prev) priv->prev->next = priv->next;
+	else		dev->file_first	 = priv->next;
+	if (priv->next) priv->next->prev = priv->prev;
+	else		dev->file_last	 = priv->prev;
+	up(&dev->struct_sem);
+	
+	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
+	
+	return 0;
+}
+
+int drm_fasync(int fd, struct file *filp, int on)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev    = priv->dev;
+	int	      retcode;
+	
+	DRM_DEBUG("fd = %d, device = 0x%x\n", fd, dev->device);
+	retcode = fasync_helper(fd, filp, on, &dev->buf_async);
+	if (retcode < 0) return retcode;
+	return 0;
+}
+
+
+/* The drm_read and drm_write_string code (especially that which manages
+   the circular buffer), is based on Alessandro Rubini's LINUX DEVICE
+   DRIVERS (Cambridge: O'Reilly, 1998), pages 111-113. */
+
+ssize_t drm_read(struct file *filp, char *buf, size_t count, loff_t *off)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev    = priv->dev;
+	int	      left;
+	int	      avail;
+	int	      send;
+	int	      cur;
+
+	DRM_DEBUG("%p, %p\n", dev->buf_rp, dev->buf_wp);
+	
+	while (dev->buf_rp == dev->buf_wp) {
+		DRM_DEBUG("  sleeping\n");
+		if (filp->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		interruptible_sleep_on(&dev->buf_readers);
+		if (signal_pending(current)) {
+			DRM_DEBUG("  interrupted\n");
+			return -ERESTARTSYS;
+		}
+		DRM_DEBUG("  awake\n");
+	}
+
+	left  = (dev->buf_rp + DRM_BSZ - dev->buf_wp) % DRM_BSZ;
+	avail = DRM_BSZ - left;
+	send  = DRM_MIN(avail, count);
+
+	while (send) {
+		if (dev->buf_wp > dev->buf_rp) {
+			cur = DRM_MIN(send, dev->buf_wp - dev->buf_rp);
+		} else {
+			cur = DRM_MIN(send, dev->buf_end - dev->buf_rp);
+		}
+		if (copy_to_user(buf, dev->buf_rp, cur))
+			return -EFAULT;
+		dev->buf_rp += cur;
+		if (dev->buf_rp == dev->buf_end) dev->buf_rp = dev->buf;
+		send -= cur;
+	}
+	
+	wake_up_interruptible(&dev->buf_writers);
+	return DRM_MIN(avail, count);;
+}
+
+int drm_write_string(drm_device_t *dev, const char *s)
+{
+	int left   = (dev->buf_rp + DRM_BSZ - dev->buf_wp) % DRM_BSZ;
+	int send   = strlen(s);
+	int count;
+
+	DRM_DEBUG("%d left, %d to send (%p, %p)\n",
+		  left, send, dev->buf_rp, dev->buf_wp);
+	
+	if (left == 1 || dev->buf_wp != dev->buf_rp) {
+		DRM_ERROR("Buffer not empty (%d left, wp = %p, rp = %p)\n",
+			  left,
+			  dev->buf_wp,
+			  dev->buf_rp);
+	}
+
+	while (send) {
+		if (dev->buf_wp >= dev->buf_rp) {
+			count = DRM_MIN(send, dev->buf_end - dev->buf_wp);
+			if (count == left) --count; /* Leave a hole */
+		} else {
+			count = DRM_MIN(send, dev->buf_rp - dev->buf_wp - 1);
+		}
+		strncpy(dev->buf_wp, s, count);
+		dev->buf_wp += count;
+		if (dev->buf_wp == dev->buf_end) dev->buf_wp = dev->buf;
+		send -= count;
+	}
+
+#if LINUX_VERSION_CODE < 0x020315 && !defined(KILLFASYNCHASTHREEPARAMETERS)
+	/* The extra parameter to kill_fasync was added in 2.3.21, and is
+           _not_ present in _stock_ 2.2.14 and 2.2.15.  However, some
+           distributions patch 2.2.x kernels to add this parameter.  The
+           Makefile.linux attempts to detect this addition and defines
+           KILLFASYNCHASTHREEPARAMETERS if three parameters are found. */
+	if (dev->buf_async) kill_fasync(dev->buf_async, SIGIO);
+#else
+
+				/* Parameter added in 2.3.21. */
+#if LINUX_VERSION_CODE < 0x020400
+	if (dev->buf_async) kill_fasync(dev->buf_async, SIGIO, POLL_IN);
+#else
+				/* Type of first parameter changed in
+                                   Linux 2.4.0-test2... */
+	if (dev->buf_async) kill_fasync(&dev->buf_async, SIGIO, POLL_IN);
+#endif
+#endif
+	DRM_DEBUG("waking\n");
+	wake_up_interruptible(&dev->buf_readers);
+	return 0;
+}
+
+unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	drm_file_t   *priv = filp->private_data;
+	drm_device_t *dev  = priv->dev;
+
+	poll_wait(filp, &dev->buf_readers, wait);
+	if (dev->buf_wp != dev->buf_rp) return POLLIN | POLLRDNORM;
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/gamma_dma.c linux/drivers/char/drm-4.0/gamma_dma.c
--- linux.orig/drivers/char/drm-4.0/gamma_dma.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/gamma_dma.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,836 @@
+/* gamma_dma.c -- DMA support for GMX 2000 -*- linux-c -*-
+ * Created: Fri Mar 19 14:30:16 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "gamma_drv.h"
+
+#include <linux/interrupt.h>	/* For task queue support */
+
+
+/* WARNING!!! MAGIC NUMBER!!!  The number of regions already added to the
+   kernel must be specified here.  Currently, the number is 2.	This must
+   match the order the X server uses for instantiating register regions ,
+   or must be passed in a new ioctl. */
+#define GAMMA_REG(reg)						   \
+	(2							   \
+	 + ((reg < 0x1000)					   \
+	    ? 0							   \
+	    : ((reg < 0x10000) ? 1 : ((reg < 0x11000) ? 2 : 3))))
+
+#define GAMMA_OFF(reg)						   \
+	((reg < 0x1000)						   \
+	 ? reg							   \
+	 : ((reg < 0x10000)					   \
+	    ? (reg - 0x1000)					   \
+	    : ((reg < 0x11000)					   \
+	       ? (reg - 0x10000)				   \
+	       : (reg - 0x11000))))
+
+#define GAMMA_BASE(reg)	 ((unsigned long)dev->maplist[GAMMA_REG(reg)]->handle)
+#define GAMMA_ADDR(reg)	 (GAMMA_BASE(reg) + GAMMA_OFF(reg))
+#define GAMMA_DEREF(reg) *(__volatile__ int *)GAMMA_ADDR(reg)
+#define GAMMA_READ(reg)	 GAMMA_DEREF(reg)
+#define GAMMA_WRITE(reg,val) do { GAMMA_DEREF(reg) = val; } while (0)
+
+#define GAMMA_BROADCASTMASK    0x9378
+#define GAMMA_COMMANDINTENABLE 0x0c48
+#define GAMMA_DMAADDRESS       0x0028
+#define GAMMA_DMACOUNT	       0x0030
+#define GAMMA_FILTERMODE       0x8c00
+#define GAMMA_GCOMMANDINTFLAGS 0x0c50
+#define GAMMA_GCOMMANDMODE     0x0c40
+#define GAMMA_GCOMMANDSTATUS   0x0c60
+#define GAMMA_GDELAYTIMER      0x0c38
+#define GAMMA_GDMACONTROL      0x0060
+#define GAMMA_GINTENABLE       0x0808
+#define GAMMA_GINTFLAGS	       0x0810
+#define GAMMA_INFIFOSPACE      0x0018
+#define GAMMA_OUTFIFOWORDS     0x0020
+#define GAMMA_OUTPUTFIFO       0x2000
+#define GAMMA_SYNC	       0x8c40
+#define GAMMA_SYNC_TAG	       0x0188
+
+static inline void gamma_dma_dispatch(drm_device_t *dev, unsigned long address,
+				      unsigned long length)
+{
+	GAMMA_WRITE(GAMMA_DMAADDRESS, virt_to_phys((void *)address));
+	while (GAMMA_READ(GAMMA_GCOMMANDSTATUS) != 4)
+		;
+	GAMMA_WRITE(GAMMA_DMACOUNT, length / 4);
+}
+
+static inline void gamma_dma_quiescent_single(drm_device_t *dev)
+{
+	while (GAMMA_READ(GAMMA_DMACOUNT))
+		;
+	while (GAMMA_READ(GAMMA_INFIFOSPACE) < 3)
+		;
+
+	GAMMA_WRITE(GAMMA_FILTERMODE, 1 << 10);
+	GAMMA_WRITE(GAMMA_SYNC, 0);
+	
+	do {
+		while (!GAMMA_READ(GAMMA_OUTFIFOWORDS))
+			;
+	} while (GAMMA_READ(GAMMA_OUTPUTFIFO) != GAMMA_SYNC_TAG);
+}
+
+static inline void gamma_dma_quiescent_dual(drm_device_t *dev)
+{
+	while (GAMMA_READ(GAMMA_DMACOUNT))
+		;
+	while (GAMMA_READ(GAMMA_INFIFOSPACE) < 3)
+		;
+
+	GAMMA_WRITE(GAMMA_BROADCASTMASK, 3);
+
+	GAMMA_WRITE(GAMMA_FILTERMODE, 1 << 10);
+	GAMMA_WRITE(GAMMA_SYNC, 0);
+	
+				/* Read from first MX */
+	do {
+		while (!GAMMA_READ(GAMMA_OUTFIFOWORDS))
+			;
+	} while (GAMMA_READ(GAMMA_OUTPUTFIFO) != GAMMA_SYNC_TAG);
+	
+				/* Read from second MX */
+	do {
+		while (!GAMMA_READ(GAMMA_OUTFIFOWORDS + 0x10000))
+			;
+	} while (GAMMA_READ(GAMMA_OUTPUTFIFO + 0x10000) != GAMMA_SYNC_TAG);
+}
+
+static inline void gamma_dma_ready(drm_device_t *dev)
+{
+	while (GAMMA_READ(GAMMA_DMACOUNT))
+		;
+}
+
+static inline int gamma_dma_is_ready(drm_device_t *dev)
+{
+	return !GAMMA_READ(GAMMA_DMACOUNT);
+}
+
+static void gamma_dma_service(int irq, void *device, struct pt_regs *regs)
+{
+	drm_device_t	 *dev = (drm_device_t *)device;
+	drm_device_dma_t *dma = dev->dma;
+	
+	atomic_inc(&dev->total_irq);
+	GAMMA_WRITE(GAMMA_GDELAYTIMER, 0xc350/2); /* 0x05S */
+	GAMMA_WRITE(GAMMA_GCOMMANDINTFLAGS, 8);
+	GAMMA_WRITE(GAMMA_GINTFLAGS, 0x2001);
+	if (gamma_dma_is_ready(dev)) {
+				/* Free previous buffer */
+		if (test_and_set_bit(0, &dev->dma_flag)) {
+			atomic_inc(&dma->total_missed_free);
+			return;
+		}
+		if (dma->this_buffer) {
+			drm_free_buffer(dev, dma->this_buffer);
+			dma->this_buffer = NULL;
+		}
+		clear_bit(0, &dev->dma_flag);
+
+				/* Dispatch new buffer */
+		queue_task(&dev->tq, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
+	}
+}
+
+/* Only called by gamma_dma_schedule. */
+static int gamma_do_dma(drm_device_t *dev, int locked)
+{
+	unsigned long	 address;
+	unsigned long	 length;
+	drm_buf_t	 *buf;
+	int		 retcode = 0;
+	drm_device_dma_t *dma = dev->dma;
+#if DRM_DMA_HISTOGRAM
+	cycles_t	 dma_start, dma_stop;
+#endif
+
+	if (test_and_set_bit(0, &dev->dma_flag)) {
+		atomic_inc(&dma->total_missed_dma);
+		return -EBUSY;
+	}
+	
+#if DRM_DMA_HISTOGRAM
+	dma_start = get_cycles();
+#endif
+
+	if (!dma->next_buffer) {
+		DRM_ERROR("No next_buffer\n");
+		clear_bit(0, &dev->dma_flag);
+		return -EINVAL;
+	}
+
+	buf	= dma->next_buffer;
+	address = (unsigned long)buf->address;
+	length	= buf->used;
+
+	DRM_DEBUG("context %d, buffer %d (%ld bytes)\n",
+		  buf->context, buf->idx, length);
+
+	if (buf->list == DRM_LIST_RECLAIM) {
+		drm_clear_next_buffer(dev);
+		drm_free_buffer(dev, buf);
+		clear_bit(0, &dev->dma_flag);
+		return -EINVAL;
+	}
+
+	if (!length) {
+		DRM_ERROR("0 length buffer\n");
+		drm_clear_next_buffer(dev);
+		drm_free_buffer(dev, buf);
+		clear_bit(0, &dev->dma_flag);
+		return 0;
+	}
+	
+	if (!gamma_dma_is_ready(dev)) {
+		clear_bit(0, &dev->dma_flag);
+		return -EBUSY;
+	}
+
+	if (buf->while_locked) {
+		if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+			DRM_ERROR("Dispatching buffer %d from pid %d"
+				  " \"while locked\", but no lock held\n",
+				  buf->idx, buf->pid);
+		}
+	} else {
+		if (!locked && !drm_lock_take(&dev->lock.hw_lock->lock,
+					      DRM_KERNEL_CONTEXT)) {
+			atomic_inc(&dma->total_missed_lock);
+			clear_bit(0, &dev->dma_flag);
+			return -EBUSY;
+		}
+	}
+
+	if (dev->last_context != buf->context
+	    && !(dev->queuelist[buf->context]->flags
+		 & _DRM_CONTEXT_PRESERVED)) {
+				/* PRE: dev->last_context != buf->context */
+		if (drm_context_switch(dev, dev->last_context, buf->context)) {
+			drm_clear_next_buffer(dev);
+			drm_free_buffer(dev, buf);
+		}
+		retcode = -EBUSY;
+		goto cleanup;
+			
+				/* POST: we will wait for the context
+				   switch and will dispatch on a later call
+				   when dev->last_context == buf->context.
+				   NOTE WE HOLD THE LOCK THROUGHOUT THIS
+				   TIME! */
+	}
+
+	drm_clear_next_buffer(dev);
+	buf->pending	 = 1;
+	buf->waiting	 = 0;
+	buf->list	 = DRM_LIST_PEND;
+#if DRM_DMA_HISTOGRAM
+	buf->time_dispatched = get_cycles();
+#endif
+
+	gamma_dma_dispatch(dev, address, length);
+	drm_free_buffer(dev, dma->this_buffer);
+	dma->this_buffer = buf;
+
+	atomic_add(length, &dma->total_bytes);
+	atomic_inc(&dma->total_dmas);
+
+	if (!buf->while_locked && !dev->context_flag && !locked) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+cleanup:
+
+	clear_bit(0, &dev->dma_flag);
+
+#if DRM_DMA_HISTOGRAM
+	dma_stop = get_cycles();
+	atomic_inc(&dev->histo.dma[drm_histogram_slot(dma_stop - dma_start)]);
+#endif
+
+	return retcode;
+}
+
+static void gamma_dma_schedule_timer_wrapper(unsigned long dev)
+{
+	gamma_dma_schedule((drm_device_t *)dev, 0);
+}
+
+static void gamma_dma_schedule_tq_wrapper(void *dev)
+{
+	gamma_dma_schedule(dev, 0);
+}
+
+int gamma_dma_schedule(drm_device_t *dev, int locked)
+{
+	int		 next;
+	drm_queue_t	 *q;
+	drm_buf_t	 *buf;
+	int		 retcode   = 0;
+	int		 processed = 0;
+	int		 missed;
+	int		 expire	   = 20;
+	drm_device_dma_t *dma	   = dev->dma;
+#if DRM_DMA_HISTOGRAM
+	cycles_t	 schedule_start;
+#endif
+
+	if (test_and_set_bit(0, &dev->interrupt_flag)) {
+				/* Not reentrant */
+		atomic_inc(&dma->total_missed_sched);
+		return -EBUSY;
+	}
+	missed = atomic_read(&dma->total_missed_sched);
+
+#if DRM_DMA_HISTOGRAM
+	schedule_start = get_cycles();
+#endif
+
+again:
+	if (dev->context_flag) {
+		clear_bit(0, &dev->interrupt_flag);
+		return -EBUSY;
+	}
+	if (dma->next_buffer) {
+				/* Unsent buffer that was previously
+				   selected, but that couldn't be sent
+				   because the lock could not be obtained
+				   or the DMA engine wasn't ready.  Try
+				   again. */
+		atomic_inc(&dma->total_tried);
+		if (!(retcode = gamma_do_dma(dev, locked))) {
+			atomic_inc(&dma->total_hit);
+			++processed;
+		}
+	} else {
+		do {
+			next = drm_select_queue(dev,
+					     gamma_dma_schedule_timer_wrapper);
+			if (next >= 0) {
+				q   = dev->queuelist[next];
+				buf = drm_waitlist_get(&q->waitlist);
+				dma->next_buffer = buf;
+				dma->next_queue	 = q;
+				if (buf && buf->list == DRM_LIST_RECLAIM) {
+					drm_clear_next_buffer(dev);
+					drm_free_buffer(dev, buf);
+				}
+			}
+		} while (next >= 0 && !dma->next_buffer);
+		if (dma->next_buffer) {
+			if (!(retcode = gamma_do_dma(dev, locked))) {
+				++processed;
+			}
+		}
+	}
+
+	if (--expire) {
+		if (missed != atomic_read(&dma->total_missed_sched)) {
+			atomic_inc(&dma->total_lost);
+			if (gamma_dma_is_ready(dev)) goto again;
+		}
+		if (processed && gamma_dma_is_ready(dev)) {
+			atomic_inc(&dma->total_lost);
+			processed = 0;
+			goto again;
+		}
+	}
+	
+	clear_bit(0, &dev->interrupt_flag);
+	
+#if DRM_DMA_HISTOGRAM
+	atomic_inc(&dev->histo.schedule[drm_histogram_slot(get_cycles()
+							   - schedule_start)]);
+#endif
+	return retcode;
+}
+
+static int gamma_dma_priority(drm_device_t *dev, drm_dma_t *d)
+{
+	unsigned long	  address;
+	unsigned long	  length;
+	int		  must_free = 0;
+	int		  retcode   = 0;
+	int		  i;
+	int		  idx;
+	drm_buf_t	  *buf;
+	drm_buf_t	  *last_buf = NULL;
+	drm_device_dma_t  *dma	    = dev->dma;
+	DECLARE_WAITQUEUE(entry, current);
+
+				/* Turn off interrupt handling */
+	while (test_and_set_bit(0, &dev->interrupt_flag)) {
+		schedule();
+		if (signal_pending(current)) return -EINTR;
+	}
+	if (!(d->flags & _DRM_DMA_WHILE_LOCKED)) {
+		while (!drm_lock_take(&dev->lock.hw_lock->lock,
+				      DRM_KERNEL_CONTEXT)) {
+			schedule();
+			if (signal_pending(current)) {
+				clear_bit(0, &dev->interrupt_flag);
+				return -EINTR;
+			}
+		}
+		++must_free;
+	}
+	atomic_inc(&dma->total_prio);
+
+	for (i = 0; i < d->send_count; i++) {
+		idx = d->send_indices[i];
+		if (idx < 0 || idx >= dma->buf_count) {
+			DRM_ERROR("Index %d (of %d max)\n",
+				  d->send_indices[i], dma->buf_count - 1);
+			continue;
+		}
+		buf = dma->buflist[ idx ];
+		if (buf->pid != current->pid) {
+			DRM_ERROR("Process %d using buffer owned by %d\n",
+				  current->pid, buf->pid);
+			retcode = -EINVAL;
+			goto cleanup;
+		}
+		if (buf->list != DRM_LIST_NONE) {
+			DRM_ERROR("Process %d using %d's buffer on list %d\n",
+				  current->pid, buf->pid, buf->list);
+			retcode = -EINVAL;
+			goto cleanup;
+		}
+				/* This isn't a race condition on
+				   buf->list, since our concern is the
+				   buffer reclaim during the time the
+				   process closes the /dev/drm? handle, so
+				   it can't also be doing DMA. */
+		buf->list	  = DRM_LIST_PRIO;
+		buf->used	  = d->send_sizes[i];
+		buf->context	  = d->context;
+		buf->while_locked = d->flags & _DRM_DMA_WHILE_LOCKED;
+		address		  = (unsigned long)buf->address;
+		length		  = buf->used;
+		if (!length) {
+			DRM_ERROR("0 length buffer\n");
+		}
+		if (buf->pending) {
+			DRM_ERROR("Sending pending buffer:"
+				  " buffer %d, offset %d\n",
+				  d->send_indices[i], i);
+			retcode = -EINVAL;
+			goto cleanup;
+		}
+		if (buf->waiting) {
+			DRM_ERROR("Sending waiting buffer:"
+				  " buffer %d, offset %d\n",
+				  d->send_indices[i], i);
+			retcode = -EINVAL;
+			goto cleanup;
+		}
+		buf->pending = 1;
+		
+		if (dev->last_context != buf->context
+		    && !(dev->queuelist[buf->context]->flags
+			 & _DRM_CONTEXT_PRESERVED)) {
+			add_wait_queue(&dev->context_wait, &entry);
+			current->state = TASK_INTERRUPTIBLE;
+				/* PRE: dev->last_context != buf->context */
+			drm_context_switch(dev, dev->last_context,
+					   buf->context);
+				/* POST: we will wait for the context
+				   switch and will dispatch on a later call
+				   when dev->last_context == buf->context.
+				   NOTE WE HOLD THE LOCK THROUGHOUT THIS
+				   TIME! */
+			schedule();
+			current->state = TASK_RUNNING;
+			remove_wait_queue(&dev->context_wait, &entry);
+			if (signal_pending(current)) {
+				retcode = -EINTR;
+				goto cleanup;
+			}
+			if (dev->last_context != buf->context) {
+				DRM_ERROR("Context mismatch: %d %d\n",
+					  dev->last_context,
+					  buf->context);
+			}
+		}
+
+#if DRM_DMA_HISTOGRAM
+		buf->time_queued     = get_cycles();
+		buf->time_dispatched = buf->time_queued;
+#endif
+		gamma_dma_dispatch(dev, address, length);
+		atomic_add(length, &dma->total_bytes);
+		atomic_inc(&dma->total_dmas);
+		
+		if (last_buf) {
+			drm_free_buffer(dev, last_buf);
+		}
+		last_buf = buf;
+	}
+
+
+cleanup:
+	if (last_buf) {
+		gamma_dma_ready(dev);
+		drm_free_buffer(dev, last_buf);
+	}
+	
+	if (must_free && !dev->context_flag) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+	clear_bit(0, &dev->interrupt_flag);
+	return retcode;
+}
+
+static int gamma_dma_send_buffers(drm_device_t *dev, drm_dma_t *d)
+{
+	DECLARE_WAITQUEUE(entry, current);
+	drm_buf_t	  *last_buf = NULL;
+	int		  retcode   = 0;
+	drm_device_dma_t  *dma	    = dev->dma;
+
+	if (d->flags & _DRM_DMA_BLOCK) {
+		last_buf = dma->buflist[d->send_indices[d->send_count-1]];
+		add_wait_queue(&last_buf->dma_wait, &entry);
+	}
+	
+	if ((retcode = drm_dma_enqueue(dev, d))) {
+		if (d->flags & _DRM_DMA_BLOCK)
+			remove_wait_queue(&last_buf->dma_wait, &entry);
+		return retcode;
+	}
+	
+	gamma_dma_schedule(dev, 0);
+	
+	if (d->flags & _DRM_DMA_BLOCK) {
+		DRM_DEBUG("%d waiting\n", current->pid);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!last_buf->waiting && !last_buf->pending)
+				break; /* finished */
+			schedule();
+			if (signal_pending(current)) {
+				retcode = -EINTR; /* Can't restart */
+				break;
+			}
+		}
+		current->state = TASK_RUNNING;
+		DRM_DEBUG("%d running\n", current->pid);
+		remove_wait_queue(&last_buf->dma_wait, &entry);
+		if (!retcode
+		    || (last_buf->list==DRM_LIST_PEND && !last_buf->pending)) {
+			if (!waitqueue_active(&last_buf->dma_wait)) {
+				drm_free_buffer(dev, last_buf);
+			}
+		}
+		if (retcode) {
+			DRM_ERROR("ctx%d w%d p%d c%d i%d l%d %d/%d\n",
+				  d->context,
+				  last_buf->waiting,
+				  last_buf->pending,
+				  DRM_WAITCOUNT(dev, d->context),
+				  last_buf->idx,
+				  last_buf->list,
+				  last_buf->pid,
+				  current->pid);
+		}
+	}
+	return retcode;
+}
+
+int gamma_dma(struct inode *inode, struct file *filp, unsigned int cmd,
+	      unsigned long arg)
+{
+	drm_file_t	  *priv	    = filp->private_data;
+	drm_device_t	  *dev	    = priv->dev;
+	drm_device_dma_t  *dma	    = dev->dma;
+	int		  retcode   = 0;
+	drm_dma_t	  d;
+
+	if (copy_from_user(&d, (drm_dma_t *)arg, sizeof(d)))
+		return -EFAULT;
+	DRM_DEBUG("%d %d: %d send, %d req\n",
+		  current->pid, d.context, d.send_count, d.request_count);
+
+	if (d.context == DRM_KERNEL_CONTEXT || d.context >= dev->queue_slots) {
+		DRM_ERROR("Process %d using context %d\n",
+			  current->pid, d.context);
+		return -EINVAL;
+	}
+	if (d.send_count < 0 || d.send_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to send %d buffers (of %d max)\n",
+			  current->pid, d.send_count, dma->buf_count);
+		return -EINVAL;
+	}
+	if (d.request_count < 0 || d.request_count > dma->buf_count) {
+		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
+			  current->pid, d.request_count, dma->buf_count);
+		return -EINVAL;
+	}
+
+	if (d.send_count) {
+		if (d.flags & _DRM_DMA_PRIORITY)
+			retcode = gamma_dma_priority(dev, &d);
+		else 
+			retcode = gamma_dma_send_buffers(dev, &d);
+	}
+
+	d.granted_count = 0;
+
+	if (!retcode && d.request_count) {
+		retcode = drm_dma_get_buffers(dev, &d);
+	}
+
+	DRM_DEBUG("%d returning, granted = %d\n",
+		  current->pid, d.granted_count);
+	if (copy_to_user((drm_dma_t *)arg, &d, sizeof(d)))
+		return -EFAULT;
+
+	return retcode;
+}
+
+int gamma_irq_install(drm_device_t *dev, int irq)
+{
+	int retcode;
+
+	if (!irq)     return -EINVAL;
+	
+	down(&dev->struct_sem);
+	if (dev->irq) {
+		up(&dev->struct_sem);
+		return -EBUSY;
+	}
+	dev->irq = irq;
+	up(&dev->struct_sem);
+	
+	DRM_DEBUG("%d\n", irq);
+
+	dev->context_flag     = 0;
+	dev->interrupt_flag   = 0;
+	dev->dma_flag	      = 0;
+	
+	dev->dma->next_buffer = NULL;
+	dev->dma->next_queue  = NULL;
+	dev->dma->this_buffer = NULL;
+
+	INIT_LIST_HEAD(&dev->tq.list);
+	dev->tq.sync	      = 0;
+	dev->tq.routine	      = gamma_dma_schedule_tq_wrapper;
+	dev->tq.data	      = dev;
+
+
+				/* Before installing handler */
+	GAMMA_WRITE(GAMMA_GCOMMANDMODE, 0);
+	GAMMA_WRITE(GAMMA_GDMACONTROL, 0);
+	
+				/* Install handler */
+	if ((retcode = request_irq(dev->irq,
+				   gamma_dma_service,
+				   0,
+				   dev->devname,
+				   dev))) {
+		down(&dev->struct_sem);
+		dev->irq = 0;
+		up(&dev->struct_sem);
+		return retcode;
+	}
+
+				/* After installing handler */
+	GAMMA_WRITE(GAMMA_GINTENABLE,	    0x2001);
+	GAMMA_WRITE(GAMMA_COMMANDINTENABLE, 0x0008);
+	GAMMA_WRITE(GAMMA_GDELAYTIMER,	   0x39090);
+	
+	return 0;
+}
+
+int gamma_irq_uninstall(drm_device_t *dev)
+{
+	int irq;
+
+	down(&dev->struct_sem);
+	irq	 = dev->irq;
+	dev->irq = 0;
+	up(&dev->struct_sem);
+	
+	if (!irq) return -EINVAL;
+	
+	DRM_DEBUG("%d\n", irq);
+	
+	GAMMA_WRITE(GAMMA_GDELAYTIMER,	    0);
+	GAMMA_WRITE(GAMMA_COMMANDINTENABLE, 0);
+	GAMMA_WRITE(GAMMA_GINTENABLE,	    0);
+	free_irq(irq, dev);
+
+	return 0;
+}
+
+
+int gamma_control(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_control_t	ctl;
+	int		retcode;
+	
+	if (copy_from_user(&ctl, (drm_control_t *)arg, sizeof(ctl)))
+		return -EFAULT;
+	
+	switch (ctl.func) {
+	case DRM_INST_HANDLER:
+		if ((retcode = gamma_irq_install(dev, ctl.irq)))
+			return retcode;
+		break;
+	case DRM_UNINST_HANDLER:
+		if ((retcode = gamma_irq_uninstall(dev)))
+			return retcode;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int gamma_lock(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	DECLARE_WAITQUEUE(entry, current);
+	int		  ret	= 0;
+	drm_lock_t	  lock;
+	drm_queue_t	  *q;
+#if DRM_DMA_HISTOGRAM
+	cycles_t	  start;
+
+	dev->lck_start = start = get_cycles();
+#endif
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+		  lock.context, current->pid, dev->lock.hw_lock->lock,
+		  lock.flags);
+
+	if (lock.context < 0 || lock.context >= dev->queue_count)
+		return -EINVAL;
+	q = dev->queuelist[lock.context];
+	
+	ret = drm_flush_block_and_flush(dev, lock.context, lock.flags);
+
+	if (!ret) {
+		if (_DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock)
+		    != lock.context) {
+			long j = jiffies - dev->lock.lock_time;
+
+			if (j > 0 && j <= DRM_LOCK_SLICE) {
+				/* Can't take lock if we just had it and
+				   there is contention. */
+				current->state = TASK_INTERRUPTIBLE;
+				schedule_timeout(j);
+			}
+		}
+		add_wait_queue(&dev->lock.lock_queue, &entry);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!dev->lock.hw_lock) {
+				/* Device has been unregistered */
+				ret = -EINTR;
+				break;
+			}
+			if (drm_lock_take(&dev->lock.hw_lock->lock,
+					  lock.context)) {
+				dev->lock.pid	    = current->pid;
+				dev->lock.lock_time = jiffies;
+				atomic_inc(&dev->total_locks);
+				atomic_inc(&q->total_locks);
+				break;	/* Got lock */
+			}
+			
+				/* Contention */
+			atomic_inc(&dev->total_sleeps);
+			schedule();
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&dev->lock.lock_queue, &entry);
+	}
+
+	drm_flush_unblock(dev, lock.context, lock.flags); /* cleanup phase */
+	
+	if (!ret) {
+		sigemptyset(&dev->sigmask);
+		sigaddset(&dev->sigmask, SIGSTOP);
+		sigaddset(&dev->sigmask, SIGTSTP);
+		sigaddset(&dev->sigmask, SIGTTIN);
+		sigaddset(&dev->sigmask, SIGTTOU);
+		dev->sigdata.context = lock.context;
+		dev->sigdata.lock    = dev->lock.hw_lock;
+		block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+
+		if (lock.flags & _DRM_LOCK_READY)
+			gamma_dma_ready(dev);
+		if (lock.flags & _DRM_LOCK_QUIESCENT) {
+			if (gamma_found() == 1) {
+				gamma_dma_quiescent_single(dev);
+			} else {
+				gamma_dma_quiescent_dual(dev);
+			}
+		}
+	}
+	DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
+
+#if DRM_DMA_HISTOGRAM
+	atomic_inc(&dev->histo.lacq[drm_histogram_slot(get_cycles() - start)]);
+#endif
+	
+	return ret;
+}
diff -urN linux.orig/drivers/char/drm-4.0/gamma_drv.c linux/drivers/char/drm-4.0/gamma_drv.c
--- linux.orig/drivers/char/drm-4.0/gamma_drv.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/gamma_drv.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,571 @@
+/* gamma.c -- 3dlabs GMX 2000 driver -*- linux-c -*-
+ * Created: Mon Jan  4 08:58:31 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "gamma_drv.h"
+
+#ifndef PCI_DEVICE_ID_3DLABS_GAMMA
+#define PCI_DEVICE_ID_3DLABS_GAMMA 0x0008
+#endif
+#ifndef PCI_DEVICE_ID_3DLABS_MX
+#define PCI_DEVICE_ID_3DLABS_MX 0x0006
+#endif
+
+#define GAMMA_NAME	 "gamma"
+#define GAMMA_DESC	 "3dlabs GMX 2000"
+#define GAMMA_DATE	 "20000910"
+#define GAMMA_MAJOR	 1
+#define GAMMA_MINOR	 0
+#define GAMMA_PATCHLEVEL 0
+
+static drm_device_t	      gamma_device;
+
+static struct file_operations gamma_fops = {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* This started being used during 2.4.0-test */
+	owner:   THIS_MODULE,
+#endif
+	open:	 gamma_open,
+	flush:	 drm_flush,
+	release: gamma_release,
+	ioctl:	 gamma_ioctl,
+	mmap:	 drm_mmap,
+	read:	 drm_read,
+	fasync:	 drm_fasync,
+	poll:	 drm_poll,
+};
+
+static struct miscdevice      gamma_misc = {
+	minor: MISC_DYNAMIC_MINOR,
+	name:  GAMMA_NAME,
+	fops:  &gamma_fops,
+};
+
+static drm_ioctl_desc_t	      gamma_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]    = { gamma_version,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)] = { drm_getunique,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]  = { drm_getmagic,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]  = { drm_irq_busid,	  0, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)] = { drm_setunique,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]	     = { drm_block,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]    = { drm_unblock,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_CONTROL)]    = { gamma_control,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)] = { drm_authmagic,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]    = { drm_addmap,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)]   = { drm_addbufs,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)]  = { drm_markbufs,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)]  = { drm_infobufs,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MAP_BUFS)]   = { drm_mapbufs,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)]  = { drm_freebufs,	  1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]    = { drm_addctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]     = { drm_rmctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]    = { drm_modctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]    = { drm_getctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)] = { drm_switchctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]    = { drm_newctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]    = { drm_resctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]   = { drm_adddraw,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]    = { drm_rmdraw,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_DMA)]	     = { gamma_dma,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	     = { gamma_lock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]     = { gamma_unlock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]     = { drm_finish,	  1, 0 },
+};
+#define GAMMA_IOCTL_COUNT DRM_ARRAY_SIZE(gamma_ioctls)
+
+#ifdef MODULE
+static char		      *gamma = NULL;
+#endif
+static int 		      devices = 0;
+
+MODULE_AUTHOR("VA Linux Systems, Inc.");
+MODULE_DESCRIPTION("3dlabs GMX 2000");
+MODULE_PARM(gamma, "s");
+MODULE_PARM(devices, "i");
+MODULE_PARM_DESC(devices,
+		 "devices=x, where x is the number of MX chips on card\n");
+#ifndef MODULE
+/* gamma_options is called by the kernel to parse command-line options
+ * passed via the boot-loader (e.g., LILO).  It calls the insmod option
+ * routine, drm_parse_options.
+ */
+
+
+static int __init gamma_options(char *str)
+{
+	drm_parse_options(str);
+	return 1;
+}
+
+__setup("gamma=", gamma_options);
+#endif
+
+static int gamma_setup(drm_device_t *dev)
+{
+	int i;
+
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
+	dev->buf_use	  = 0;
+	atomic_set(&dev->buf_alloc, 0);
+
+	drm_dma_setup(dev);
+
+	atomic_set(&dev->total_open, 0);
+	atomic_set(&dev->total_close, 0);
+	atomic_set(&dev->total_ioctl, 0);
+	atomic_set(&dev->total_irq, 0);
+	atomic_set(&dev->total_ctx, 0);
+	atomic_set(&dev->total_locks, 0);
+	atomic_set(&dev->total_unlocks, 0);
+	atomic_set(&dev->total_contends, 0);
+	atomic_set(&dev->total_sleeps, 0);
+
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		dev->magiclist[i].head = NULL;
+		dev->magiclist[i].tail = NULL;
+	}
+	dev->maplist	    = NULL;
+	dev->map_count	    = 0;
+	dev->vmalist	    = NULL;
+	dev->lock.hw_lock   = NULL;
+	init_waitqueue_head(&dev->lock.lock_queue);
+	dev->queue_count    = 0;
+	dev->queue_reserved = 0;
+	dev->queue_slots    = 0;
+	dev->queuelist	    = NULL;
+	dev->irq	    = 0;
+	dev->context_flag   = 0;
+	dev->interrupt_flag = 0;
+	dev->dma_flag	    = 0;
+	dev->last_context   = 0;
+	dev->last_switch    = 0;
+	dev->last_checked   = 0;
+	init_timer(&dev->timer);
+	init_waitqueue_head(&dev->context_wait);
+#if DRM_DMA_HISTO
+	memset(&dev->histo, 0, sizeof(dev->histo));
+#endif
+	dev->ctx_start	    = 0;
+	dev->lck_start	    = 0;
+
+	dev->buf_rp	  = dev->buf;
+	dev->buf_wp	  = dev->buf;
+	dev->buf_end	  = dev->buf + DRM_BSZ;
+	dev->buf_async	  = NULL;
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
+
+	DRM_DEBUG("\n");
+
+	/* The kernel's context could be created here, but is now created
+	   in drm_dma_enqueue.	This is more resource-efficient for
+	   hardware that does not do DMA, but may mean that
+	   drm_select_queue fails between the time the interrupt is
+	   initialized and the time the queues are initialized. */
+
+	return 0;
+}
+
+
+static int gamma_takedown(drm_device_t *dev)
+{
+	int		  i;
+	drm_magic_entry_t *pt, *next;
+	drm_map_t	  *map;
+	drm_vma_entry_t	  *vma, *vma_next;
+
+	DRM_DEBUG("\n");
+
+	if (dev->irq) gamma_irq_uninstall(dev);
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
+
+	if (dev->devname) {
+		drm_free(dev->devname, strlen(dev->devname)+1, DRM_MEM_DRIVER);
+		dev->devname = NULL;
+	}
+
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique)+1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
+				/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
+			next = pt->next;
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+		}
+		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
+	}
+
+				/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
+			vma_next = vma->next;
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		}
+		dev->vmalist = NULL;
+	}
+
+				/* Clear map area and mtrr information */
+	if (dev->maplist) {
+		for (i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			switch (map->type) {
+			case _DRM_REGISTERS:
+			case _DRM_FRAME_BUFFER:
+#ifdef CONFIG_MTRR
+				if (map->mtrr >= 0) {
+					int retcode;
+					retcode = mtrr_del(map->mtrr,
+							   map->offset,
+							   map->size);
+					DRM_DEBUG("mtrr_del = %d\n", retcode);
+				}
+#endif
+				drm_ioremapfree(map->handle, map->size, dev);
+				break;
+			case _DRM_SHM:
+				drm_free_pages((unsigned long)map->handle,
+					       drm_order(map->size)
+					       - PAGE_SHIFT,
+					       DRM_MEM_SAREA);
+				break;
+			case _DRM_AGP:
+				/* Do nothing here, because this is all
+                                   handled in the AGP/GART driver. */
+				break;
+			}
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		}
+		drm_free(dev->maplist,
+			 dev->map_count * sizeof(*dev->maplist),
+			 DRM_MEM_MAPS);
+		dev->maplist   = NULL;
+		dev->map_count = 0;
+	}
+
+	if (dev->queuelist) {
+		for (i = 0; i < dev->queue_count; i++) {
+			drm_waitlist_destroy(&dev->queuelist[i]->waitlist);
+			if (dev->queuelist[i]) {
+				drm_free(dev->queuelist[i],
+					 sizeof(*dev->queuelist[0]),
+					 DRM_MEM_QUEUES);
+				dev->queuelist[i] = NULL;
+			}
+		}
+		drm_free(dev->queuelist,
+			 dev->queue_slots * sizeof(*dev->queuelist),
+			 DRM_MEM_QUEUES);
+		dev->queuelist	 = NULL;
+	}
+
+	drm_dma_takedown(dev);
+
+	dev->queue_count     = 0;
+	if (dev->lock.hw_lock) {
+		dev->lock.hw_lock    = NULL; /* SHM removed */
+		dev->lock.pid	     = 0;
+		wake_up_interruptible(&dev->lock.lock_queue);
+	}
+	up(&dev->struct_sem);
+
+	return 0;
+}
+
+int gamma_found(void)
+{
+	return devices;
+}
+
+int gamma_find_devices(void)
+{
+	struct pci_dev *d = NULL, *one = NULL, *two = NULL;
+
+	d = pci_find_device(PCI_VENDOR_ID_3DLABS,PCI_DEVICE_ID_3DLABS_GAMMA,d);
+	if (!d) return 0;
+
+	one = pci_find_device(PCI_VENDOR_ID_3DLABS,PCI_DEVICE_ID_3DLABS_MX,d);
+	if (!one) return 0;
+
+	/* Make sure it's on the same card, if not - no MX's found */
+	if (PCI_SLOT(d->devfn) != PCI_SLOT(one->devfn)) return 0;
+
+	two = pci_find_device(PCI_VENDOR_ID_3DLABS,PCI_DEVICE_ID_3DLABS_MX,one);
+	if (!two) return 1;
+
+	/* Make sure it's on the same card, if not - only 1 MX found */
+	if (PCI_SLOT(d->devfn) != PCI_SLOT(two->devfn)) return 1;
+
+	/* Two MX's found - we don't currently support more than 2 */
+	return 2;
+}
+
+/* gamma_init is called via init_module at module load time, or via
+ * linux/init/main.c (this is not currently supported). */
+
+static int __init gamma_init(void)
+{
+	int		      retcode;
+	drm_device_t	      *dev = &gamma_device;
+
+	DRM_DEBUG("\n");
+
+	memset((void *)dev, 0, sizeof(*dev));
+	dev->count_lock	  = SPIN_LOCK_UNLOCKED;
+	sema_init(&dev->struct_sem, 1);
+
+#ifdef MODULE
+	drm_parse_options(gamma);
+#endif
+	devices = gamma_find_devices();
+	if (devices == 0) return -1;
+
+	if ((retcode = misc_register(&gamma_misc))) {
+		DRM_ERROR("Cannot register \"%s\"\n", GAMMA_NAME);
+		return retcode;
+	}
+	dev->device = MKDEV(MISC_MAJOR, gamma_misc.minor);
+	dev->name   = GAMMA_NAME;
+
+	drm_mem_init();
+	drm_proc_init(dev);
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d with %d MX devices\n",
+		 GAMMA_NAME,
+		 GAMMA_MAJOR,
+		 GAMMA_MINOR,
+		 GAMMA_PATCHLEVEL,
+		 GAMMA_DATE,
+		 gamma_misc.minor,
+		 devices);
+
+	return 0;
+}
+
+/* gamma_cleanup is called via cleanup_module at module unload time. */
+
+static void __exit gamma_cleanup(void)
+{
+	drm_device_t	      *dev = &gamma_device;
+
+	DRM_DEBUG("\n");
+
+	drm_proc_cleanup();
+	if (misc_deregister(&gamma_misc)) {
+		DRM_ERROR("Cannot unload module\n");
+	} else {
+		DRM_INFO("Module unloaded\n");
+	}
+	gamma_takedown(dev);
+}
+
+module_init(gamma_init);
+module_exit(gamma_cleanup);
+
+
+int gamma_version(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_version_t version;
+	int	      len;
+
+	if (copy_from_user(&version,
+			   (drm_version_t *)arg,
+			   sizeof(version)))
+		return -EFAULT;
+
+#define DRM_COPY(name,value)				     \
+	len = strlen(value);				     \
+	if (len > name##_len) len = name##_len;		     \
+	name##_len = strlen(value);			     \
+	if (len && name) {				     \
+		if (copy_to_user(name, value, len))	     \
+			return -EFAULT;			     \
+	}
+
+	version.version_major	   = GAMMA_MAJOR;
+	version.version_minor	   = GAMMA_MINOR;
+	version.version_patchlevel = GAMMA_PATCHLEVEL;
+
+	DRM_COPY(version.name, GAMMA_NAME);
+	DRM_COPY(version.date, GAMMA_DATE);
+	DRM_COPY(version.desc, GAMMA_DESC);
+
+	if (copy_to_user((drm_version_t *)arg,
+			 &version,
+			 sizeof(version)))
+		return -EFAULT;
+	return 0;
+}
+
+int gamma_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t  *dev    = &gamma_device;
+	int	      retcode = 0;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_open_helper(inode, filp, dev))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_INC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_open);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return gamma_setup(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+	return retcode;
+}
+
+int gamma_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev;
+	int	      retcode = 0;
+
+	lock_kernel();
+	dev = priv->dev;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_release(inode, filp))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_DEC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_close);
+		spin_lock(&dev->count_lock);
+		if (!--dev->open_count) {
+			if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+				DRM_ERROR("Device busy: %d %d\n",
+					  atomic_read(&dev->ioctl_count),
+					  dev->blocked);
+				spin_unlock(&dev->count_lock);
+				unlock_kernel();
+				return -EBUSY;
+			}
+			spin_unlock(&dev->count_lock);
+			unlock_kernel();
+			return gamma_takedown(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+	unlock_kernel();
+	return retcode;
+}
+
+/* drm_ioctl is called whenever a process performs an ioctl on /dev/drm. */
+
+int gamma_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	int		 nr	 = DRM_IOCTL_NR(cmd);
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	int		 retcode = 0;
+	drm_ioctl_desc_t *ioctl;
+	drm_ioctl_t	 *func;
+
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->total_ioctl);
+	++priv->ioctl_count;
+
+	DRM_DEBUG("pid = %d, cmd = 0x%02x, nr = 0x%02x, dev 0x%x, auth = %d\n",
+		  current->pid, cmd, nr, dev->device, priv->authenticated);
+
+	if (nr >= GAMMA_IOCTL_COUNT) {
+		retcode = -EINVAL;
+	} else {
+		ioctl	  = &gamma_ioctls[nr];
+		func	  = ioctl->func;
+
+		if (!func) {
+			DRM_DEBUG("no function\n");
+			retcode = -EINVAL;
+		} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN))
+			    || (ioctl->auth_needed && !priv->authenticated)) {
+			retcode = -EACCES;
+		} else {
+			retcode = (func)(inode, filp, cmd, arg);
+		}
+	}
+
+	atomic_dec(&dev->ioctl_count);
+	return retcode;
+}
+
+
+int gamma_unlock(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d frees lock (%d holds)\n",
+		  lock.context,
+		  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	atomic_inc(&dev->total_unlocks);
+	if (_DRM_LOCK_IS_CONT(dev->lock.hw_lock->lock))
+		atomic_inc(&dev->total_contends);
+	drm_lock_transfer(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
+	gamma_dma_schedule(dev, 1);
+	if (!dev->context_flag) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+#if DRM_DMA_HISTOGRAM
+	atomic_inc(&dev->histo.lhld[drm_histogram_slot(get_cycles()
+						       - dev->lck_start)]);
+#endif
+
+	unblock_all_signals();
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/gamma_drv.h linux/drivers/char/drm-4.0/gamma_drv.h
--- linux.orig/drivers/char/drm-4.0/gamma_drv.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/gamma_drv.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,58 @@
+/* gamma_drv.h -- Private header for 3dlabs GMX 2000 driver -*- linux-c -*-
+ * Created: Mon Jan  4 10:05:05 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ * 
+ */
+
+#ifndef _GAMMA_DRV_H_
+#define _GAMMA_DRV_H_
+
+				/* gamma_drv.c */
+extern int  gamma_version(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  gamma_open(struct inode *inode, struct file *filp);
+extern int  gamma_release(struct inode *inode, struct file *filp);
+extern int  gamma_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  gamma_lock(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  gamma_unlock(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+
+				/* gamma_dma.c */
+extern int  gamma_dma_schedule(drm_device_t *dev, int locked);
+extern int  gamma_dma(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int  gamma_irq_install(drm_device_t *dev, int irq);
+extern int  gamma_irq_uninstall(drm_device_t *dev);
+extern int  gamma_control(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  gamma_find_devices(void);
+extern int  gamma_found(void);
+
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/i810_bufs.c linux/drivers/char/drm-4.0/i810_bufs.c
--- linux.orig/drivers/char/drm-4.0/i810_bufs.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/i810_bufs.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,339 @@
+/* i810_bufs.c -- IOCTLs to manage buffers -*- linux-c -*-
+ * Created: Thu Jan 6 01:47:26 2000 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ * 
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "i810_drv.h"
+#include "linux/un.h"
+
+int i810_addbufs_agp(struct inode *inode, struct file *filp, unsigned int cmd,
+		    unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_desc_t request;
+	drm_buf_entry_t *entry;
+	drm_buf_t *buf;
+	unsigned long offset;
+	unsigned long agp_offset;
+	int count;
+	int order;
+	int size;
+	int alignment;
+	int page_order;
+	int total;
+	int byte_count;
+	int i;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	count = request.count;
+	order = drm_order(request.size);
+	size	= 1 << order;
+	agp_offset = request.agp_start;
+	alignment  = (request.flags & _DRM_PAGE_ALIGN) ? PAGE_ALIGN(size) :size;
+	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
+	total = PAGE_SIZE << page_order;
+	byte_count = 0;
+   
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	if (dev->queue_count) return -EBUSY; /* Not while in use */
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
+   
+	down(&dev->struct_sem);
+	entry = &dma->bufs[order];
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM; /* May only call once for each order */
+	}
+
+	if(count < 0 || count > 4096)
+	{
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -EINVAL;
+	}
+	   
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
+   
+	entry->buf_size   = size;
+	entry->page_order = page_order;
+	offset = 0;
+   
+	while(entry->buf_count < count) {
+		buf = &entry->buflist[entry->buf_count];
+		buf->idx = dma->buf_count + entry->buf_count;
+		buf->total = alignment;
+		buf->order = order;
+		buf->used = 0;
+		buf->offset = offset;
+		buf->bus_address = dev->agp->base + agp_offset + offset;
+		buf->address = (void *)(agp_offset + offset + dev->agp->base);
+		buf->next = NULL;
+		buf->waiting = 0;
+		buf->pending = 0;
+		init_waitqueue_head(&buf->dma_wait);
+		buf->pid = 0;
+
+		buf->dev_private = drm_alloc(sizeof(drm_i810_buf_priv_t), 
+					     DRM_MEM_BUFS);
+		buf->dev_priv_size = sizeof(drm_i810_buf_priv_t);
+	   	memset(buf->dev_private, 0, sizeof(drm_i810_buf_priv_t));
+
+#if DRM_DMA_HISTOGRAM
+		buf->time_queued = 0;
+		buf->time_dispatched = 0;
+		buf->time_completed = 0;
+		buf->time_freed = 0;
+#endif
+		offset = offset + alignment;
+		entry->buf_count++;
+		byte_count += PAGE_SIZE << page_order;
+      
+		DRM_DEBUG("buffer %d @ %p\n",
+			  entry->buf_count, buf->address);
+	}
+   
+	dma->buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist),
+				   DRM_MEM_BUFS);
+	for (i = dma->buf_count; i < dma->buf_count + entry->buf_count; i++)
+		dma->buflist[i] = &entry->buflist[i - dma->buf_count];
+   
+	dma->buf_count  += entry->buf_count;
+	dma->byte_count += byte_count;
+	drm_freelist_create(&entry->freelist, entry->buf_count);
+	for (i = 0; i < entry->buf_count; i++) {
+		drm_freelist_put(dev, &entry->freelist, &entry->buflist[i]);
+	}
+   
+	up(&dev->struct_sem);
+   
+	request.count = entry->buf_count;
+	request.size  = size;
+   
+	if (copy_to_user((drm_buf_desc_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+   
+	atomic_dec(&dev->buf_alloc);
+	dma->flags = _DRM_DMA_USE_AGP;
+	return 0;
+}
+
+int i810_addbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_buf_desc_t	 request;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	if(request.flags & _DRM_AGP_BUFFER)
+		return i810_addbufs_agp(inode, filp, cmd, arg);
+	else
+		return -EINVAL;
+}
+
+int i810_infobufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_info_t	 request;
+	int		 i;
+	int		 count;
+
+	if (!dma) return -EINVAL;
+
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	++dev->buf_use;		/* Can't allocate more after this call */
+	spin_unlock(&dev->count_lock);
+
+	if (copy_from_user(&request,
+			   (drm_buf_info_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	for (i = 0, count = 0; i < DRM_MAX_ORDER+1; i++) {
+		if (dma->bufs[i].buf_count) ++count;
+	}
+	
+	DRM_DEBUG("count = %d\n", count);
+	
+	if (request.count >= count) {
+		for (i = 0, count = 0; i < DRM_MAX_ORDER+1; i++) {
+			if (dma->bufs[i].buf_count) {
+				if (copy_to_user(&request.list[count].count,
+						 &dma->bufs[i].buf_count,
+						 sizeof(dma->bufs[0]
+							.buf_count)) ||
+				    copy_to_user(&request.list[count].size,
+						 &dma->bufs[i].buf_size,
+						 sizeof(dma->bufs[0].buf_size)) ||
+				    copy_to_user(&request.list[count].low_mark,
+						 &dma->bufs[i]
+						 .freelist.low_mark,
+						 sizeof(dma->bufs[0]
+							.freelist.low_mark)) ||
+				    copy_to_user(&request.list[count]
+						 .high_mark,
+						 &dma->bufs[i]
+						 .freelist.high_mark,
+						 sizeof(dma->bufs[0]
+							.freelist.high_mark)))
+					return -EFAULT;
+
+				DRM_DEBUG("%d %d %d %d %d\n",
+					  i,
+					  dma->bufs[i].buf_count,
+					  dma->bufs[i].buf_size,
+					  dma->bufs[i].freelist.low_mark,
+					  dma->bufs[i].freelist.high_mark);
+				++count;
+			}
+		}
+	}
+	request.count = count;
+
+	if (copy_to_user((drm_buf_info_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+	
+	return 0;
+}
+
+int i810_markbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_desc_t	 request;
+	int		 order;
+	drm_buf_entry_t	 *entry;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	DRM_DEBUG("%d, %d, %d\n",
+		  request.size, request.low_mark, request.high_mark);
+	order = drm_order(request.size);
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	entry = &dma->bufs[order];
+
+	if (request.low_mark < 0 || request.low_mark > entry->buf_count)
+		return -EINVAL;
+	if (request.high_mark < 0 || request.high_mark > entry->buf_count)
+		return -EINVAL;
+
+	entry->freelist.low_mark  = request.low_mark;
+	entry->freelist.high_mark = request.high_mark;
+	
+	return 0;
+}
+
+int i810_freebufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_free_t	 request;
+	int		 i;
+	int		 idx;
+	drm_buf_t	 *buf;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_free_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	DRM_DEBUG("%d\n", request.count);
+	for (i = 0; i < request.count; i++) {
+		if (copy_from_user(&idx,
+				   &request.list[i],
+				   sizeof(idx)))
+			return -EFAULT;
+		if (idx < 0 || idx >= dma->buf_count) {
+			DRM_ERROR("Index %d (of %d max)\n",
+				  idx, dma->buf_count - 1);
+			return -EINVAL;
+		}
+		buf = dma->buflist[idx];
+		if (buf->pid != current->pid) {
+			DRM_ERROR("Process %d freeing buffer owned by %d\n",
+				  current->pid, buf->pid);
+			return -EINVAL;
+		}
+		drm_free_buffer(dev, buf);
+	}
+	
+	return 0;
+}
+
diff -urN linux.orig/drivers/char/drm-4.0/i810_context.c linux/drivers/char/drm-4.0/i810_context.c
--- linux.orig/drivers/char/drm-4.0/i810_context.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/i810_context.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,212 @@
+/* i810_context.c -- IOCTLs for i810 contexts -*- linux-c -*-
+ * Created: Mon Dec 13 09:51:35 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "i810_drv.h"
+
+static int i810_alloc_queue(drm_device_t *dev)
+{
+   	int temp = drm_ctxbitmap_next(dev);
+   	DRM_DEBUG("i810_alloc_queue: %d\n", temp);
+	return temp;
+}
+
+int i810_context_switch(drm_device_t *dev, int old, int new)
+{
+        char        buf[64];
+
+        atomic_inc(&dev->total_ctx);
+
+        if (test_and_set_bit(0, &dev->context_flag)) {
+                DRM_ERROR("Reentering -- FIXME\n");
+                return -EBUSY;
+        }
+
+#if DRM_DMA_HISTOGRAM
+        dev->ctx_start = get_cycles();
+#endif
+        
+        DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+        if (new == dev->last_context) {
+                clear_bit(0, &dev->context_flag);
+                return 0;
+        }
+        
+        if (drm_flags & DRM_FLAG_NOCTX) {
+                i810_context_switch_complete(dev, new);
+        } else {
+                sprintf(buf, "C %d %d\n", old, new);
+                drm_write_string(dev, buf);
+        }
+        
+        return 0;
+}
+
+int i810_context_switch_complete(drm_device_t *dev, int new)
+{
+        dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
+        dev->last_switch  = jiffies;
+        
+        if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+                DRM_ERROR("Lock isn't held after context switch\n");
+        }
+
+				/* If a context switch is ever initiated
+                                   when the kernel holds the lock, release
+                                   that lock here. */
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.ctx[drm_histogram_slot(get_cycles()
+                                                      - dev->ctx_start)]);
+                   
+#endif
+        clear_bit(0, &dev->context_flag);
+        wake_up(&dev->context_wait);
+        
+        return 0;
+}
+
+int i810_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_res_t	res;
+	drm_ctx_t	ctx;
+	int		i;
+
+	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
+	if (copy_from_user(&res, (drm_ctx_res_t *)arg, sizeof(res)))
+		return -EFAULT;
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+			ctx.handle = i;
+			if (copy_to_user(&res.contexts[i],
+					 &i,
+					 sizeof(i)))
+				return -EFAULT;
+		}
+	}
+	res.count = DRM_RESERVED_CONTEXTS;
+	if (copy_to_user((drm_ctx_res_t *)arg, &res, sizeof(res)))
+		return -EFAULT;
+	return 0;
+}
+
+int i810_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	if ((ctx.handle = i810_alloc_queue(dev)) == DRM_KERNEL_CONTEXT) {
+				/* Skip kernel's context and get a new one. */
+		ctx.handle = i810_alloc_queue(dev);
+	}
+        if (ctx.handle == -1) {
+		DRM_DEBUG("Not enough free contexts.\n");
+				/* Should this return -EBUSY instead? */
+		return -ENOMEM;
+	}
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int i810_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+   	/* This does nothing for the i810 */
+	return 0;
+}
+
+int i810_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	/* This is 0, because we don't hanlde any context flags */
+	ctx.flags = 0;
+	if (copy_to_user((drm_ctx_t*)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int i810_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	return i810_context_switch(dev, dev->last_context, ctx.handle);
+}
+
+int i810_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	i810_context_switch_complete(dev, ctx.handle);
+
+	return 0;
+}
+
+int i810_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	      unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+   	if(ctx.handle != DRM_KERNEL_CONTEXT) {
+	   	drm_ctxbitmap_free(dev, ctx.handle);
+	}
+	
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/i810_dma.c linux/drivers/char/drm-4.0/i810_dma.c
--- linux.orig/drivers/char/drm-4.0/i810_dma.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/i810_dma.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1438 @@
+/* i810_dma.c -- DMA support for the i810 -*- linux-c -*-
+ * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *          Keith Whitwell <keithw@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "i810_drv.h"
+#include <linux/interrupt.h>	/* For task queue support */
+
+/* in case we don't have a 2.3.99-pre6 kernel or later: */
+#ifndef VM_DONTCOPY
+#define VM_DONTCOPY 0
+#endif
+
+#define I810_BUF_FREE		2
+#define I810_BUF_CLIENT		1
+#define I810_BUF_HARDWARE      	0
+
+#define I810_BUF_UNMAPPED 0
+#define I810_BUF_MAPPED   1
+
+#define I810_REG(reg)		2
+#define I810_BASE(reg)		((unsigned long) \
+				dev->maplist[I810_REG(reg)]->handle)
+#define I810_ADDR(reg)		(I810_BASE(reg) + reg)
+#define I810_DEREF(reg)		*(__volatile__ int *)I810_ADDR(reg)
+#define I810_READ(reg)		I810_DEREF(reg)
+#define I810_WRITE(reg,val) 	do { I810_DEREF(reg) = val; } while (0)
+#define I810_DEREF16(reg)	*(__volatile__ u16 *)I810_ADDR(reg)
+#define I810_READ16(reg)	I810_DEREF16(reg)
+#define I810_WRITE16(reg,val)	do { I810_DEREF16(reg) = val; } while (0)
+
+#define RING_LOCALS	unsigned int outring, ringmask; volatile char *virt;
+
+#define BEGIN_LP_RING(n) do {				\
+	if (I810_VERBOSE)				\
+		DRM_DEBUG("BEGIN_LP_RING(%d) in %s\n",	\
+			  n, __FUNCTION__);		\
+	if (dev_priv->ring.space < n*4) 		\
+		i810_wait_ring(dev, n*4);		\
+	dev_priv->ring.space -= n*4;			\
+	outring = dev_priv->ring.tail;			\
+	ringmask = dev_priv->ring.tail_mask;		\
+	virt = dev_priv->ring.virtual_start;		\
+} while (0)
+
+#define ADVANCE_LP_RING() do {					\
+	if (I810_VERBOSE) DRM_DEBUG("ADVANCE_LP_RING\n");	\
+	dev_priv->ring.tail = outring;				\
+	I810_WRITE(LP_RING + RING_TAIL, outring);		\
+} while(0)
+
+#define OUT_RING(n) do {						\
+	if (I810_VERBOSE) DRM_DEBUG("   OUT_RING %x\n", (int)(n));	\
+	*(volatile unsigned int *)(virt + outring) = n;			\
+	outring += 4;							\
+	outring &= ringmask;						\
+} while (0);
+
+static inline void i810_print_status_page(drm_device_t *dev)
+{
+   	drm_device_dma_t *dma = dev->dma;
+      	drm_i810_private_t *dev_priv = dev->dev_private;
+	u32 *temp = (u32 *)dev_priv->hw_status_page;
+   	int i;
+
+   	DRM_DEBUG(  "hw_status: Interrupt Status : %x\n", temp[0]);
+   	DRM_DEBUG(  "hw_status: LpRing Head ptr : %x\n", temp[1]);
+   	DRM_DEBUG(  "hw_status: IRing Head ptr : %x\n", temp[2]);
+      	DRM_DEBUG(  "hw_status: Reserved : %x\n", temp[3]);
+   	DRM_DEBUG(  "hw_status: Driver Counter : %d\n", temp[5]);
+   	for(i = 6; i < dma->buf_count + 6; i++) {
+	   	DRM_DEBUG( "buffer status idx : %d used: %d\n", i - 6, temp[i]);
+	}
+}
+
+static drm_buf_t *i810_freelist_get(drm_device_t *dev)
+{
+   	drm_device_dma_t *dma = dev->dma;
+	int		 i;
+   	int 		 used;
+   
+	/* Linear search might not be the best solution */
+
+   	for (i = 0; i < dma->buf_count; i++) {
+	   	drm_buf_t *buf = dma->buflist[ i ];
+	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+		/* In use is already a pointer */
+	   	used = cmpxchg(buf_priv->in_use, I810_BUF_FREE, 
+			       I810_BUF_CLIENT);
+	   	if(used == I810_BUF_FREE) {
+			return buf;
+		}
+	}
+   	return NULL;
+}
+
+/* This should only be called if the buffer is not sent to the hardware
+ * yet, the hardware updates in use for us once its on the ring buffer.
+ */
+
+static int i810_freelist_put(drm_device_t *dev, drm_buf_t *buf)
+{
+   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+   	int used;
+   
+   	/* In use is already a pointer */
+   	used = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, I810_BUF_FREE);
+   	if(used != I810_BUF_CLIENT) {
+	   	DRM_ERROR("Freeing buffer thats not in use : %d\n", buf->idx);
+	   	return -EINVAL;
+	}
+   
+   	return 0;
+}
+
+static struct file_operations i810_buffer_fops = {
+	open:	 i810_open,
+	flush:	 drm_flush,
+	release: i810_release,
+	ioctl:	 i810_ioctl,
+	mmap:	 i810_mmap_buffers,
+	read:	 drm_read,
+	fasync:	 drm_fasync,
+      	poll:	 drm_poll,
+};
+
+int i810_mmap_buffers(struct file *filp, struct vm_area_struct *vma)
+{
+	drm_file_t	    *priv	  = filp->private_data;
+	drm_device_t	    *dev;
+	drm_i810_private_t  *dev_priv;
+	drm_buf_t           *buf;
+	drm_i810_buf_priv_t *buf_priv;
+
+	lock_kernel();
+	dev	 = priv->dev;
+	dev_priv = dev->dev_private;
+	buf      = dev_priv->mmap_buffer;
+	buf_priv = buf->dev_private;
+   
+	vma->vm_flags |= (VM_IO | VM_DONTCOPY);
+	vma->vm_file = filp;
+   
+   	buf_priv->currently_mapped = I810_BUF_MAPPED;
+	unlock_kernel();
+
+	if (remap_page_range(vma->vm_start,
+			     VM_OFFSET(vma),
+			     vma->vm_end - vma->vm_start,
+			     vma->vm_page_prot)) return -EAGAIN;
+	return 0;
+}
+
+static int i810_map_buffer(drm_buf_t *buf, struct file *filp)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+      	drm_i810_private_t *dev_priv = dev->dev_private;
+   	struct file_operations *old_fops;
+	int retcode = 0;
+
+	if(buf_priv->currently_mapped == I810_BUF_MAPPED) return -EINVAL;
+
+	if(VM_DONTCOPY != 0) {
+		down_write(&current->mm->mmap_sem);
+		old_fops = filp->f_op;
+		filp->f_op = &i810_buffer_fops;
+		dev_priv->mmap_buffer = buf;
+		buf_priv->virtual = (void *)do_mmap(filp, 0, buf->total, 
+						    PROT_READ|PROT_WRITE,
+						    MAP_SHARED, 
+						    buf->bus_address);
+		dev_priv->mmap_buffer = NULL;
+   		filp->f_op = old_fops;
+		if ((unsigned long)buf_priv->virtual > -1024UL) {
+			/* Real error */
+			DRM_DEBUG("mmap error\n");
+			retcode = (signed int)buf_priv->virtual;
+			buf_priv->virtual = 0;
+		}
+   		up_write(&current->mm->mmap_sem);
+	} else {
+		buf_priv->virtual = buf_priv->kernel_virtual;
+   		buf_priv->currently_mapped = I810_BUF_MAPPED;
+	}
+	return retcode;
+}
+
+static int i810_unmap_buffer(drm_buf_t *buf)
+{
+	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	int retcode = 0;
+
+	if(VM_DONTCOPY != 0) {
+		if(buf_priv->currently_mapped != I810_BUF_MAPPED) 
+			return -EINVAL;
+		down_write(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE < 0x020399
+        	retcode = do_munmap((unsigned long)buf_priv->virtual, 
+				    (size_t) buf->total);
+#else
+        	retcode = do_munmap(current->mm, 
+				    (unsigned long)buf_priv->virtual, 
+				    (size_t) buf->total);
+#endif
+   		up_write(&current->mm->mmap_sem);
+	}
+   	buf_priv->currently_mapped = I810_BUF_UNMAPPED;
+   	buf_priv->virtual = 0;
+
+	return retcode;
+}
+
+static int i810_dma_get_buffer(drm_device_t *dev, drm_i810_dma_t *d, 
+			       struct file *filp)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_buf_t	  *buf;
+	drm_i810_buf_priv_t *buf_priv;
+	int retcode = 0;
+
+	buf = i810_freelist_get(dev);
+	if (!buf) {
+		retcode = -ENOMEM;
+	   	DRM_DEBUG("retcode=%d\n", retcode);
+		return retcode;
+	}
+   
+	retcode = i810_map_buffer(buf, filp);
+	if(retcode) {
+		i810_freelist_put(dev, buf);
+	   	DRM_DEBUG("mapbuf failed, retcode %d\n", retcode);
+		return retcode;
+	}
+	buf->pid     = priv->pid;
+	buf_priv = buf->dev_private;	
+	d->granted = 1;
+   	d->request_idx = buf->idx;
+   	d->request_size = buf->total;
+   	d->virtual = buf_priv->virtual;
+
+	return retcode;
+}
+
+static unsigned long i810_alloc_page(drm_device_t *dev)
+{
+	unsigned long address;
+   
+	address = __get_free_page(GFP_KERNEL);
+	if(address == 0UL) 
+		return 0;
+	
+	atomic_inc(&virt_to_page(address)->count);
+	set_bit(PG_locked, &virt_to_page(address)->flags);
+   
+	return address;
+}
+
+static void i810_free_page(drm_device_t *dev, unsigned long page)
+{
+	if(page == 0UL) 
+		return;
+	
+	atomic_dec(&virt_to_page(page)->count);
+	clear_bit(PG_locked, &virt_to_page(page)->flags);
+	wake_up(&virt_to_page(page)->wait);
+	free_page(page);
+	return;
+}
+
+static int i810_dma_cleanup(drm_device_t *dev)
+{
+	drm_device_dma_t *dma = dev->dma;
+
+	if(dev->dev_private) {
+		int i;
+	   	drm_i810_private_t *dev_priv = 
+	     		(drm_i810_private_t *) dev->dev_private;
+	   
+	   	if(dev_priv->ring.virtual_start) {
+		   	drm_ioremapfree((void *) dev_priv->ring.virtual_start,
+					dev_priv->ring.Size, dev);
+		}
+	   	if(dev_priv->hw_status_page != 0UL) {
+		   	i810_free_page(dev, dev_priv->hw_status_page);
+		   	/* Need to rewrite hardware status page */
+		   	I810_WRITE(0x02080, 0x1ffff000);
+		}
+	   	drm_free(dev->dev_private, sizeof(drm_i810_private_t), 
+			 DRM_MEM_DRIVER);
+	   	dev->dev_private = NULL;
+
+		for (i = 0; i < dma->buf_count; i++) {
+			drm_buf_t *buf = dma->buflist[ i ];
+			drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+			drm_ioremapfree(buf_priv->kernel_virtual,
+							buf->total, dev);
+		}
+	}
+   	return 0;
+}
+
+static int i810_wait_ring(drm_device_t *dev, int n)
+{
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+   	drm_i810_ring_buffer_t *ring = &(dev_priv->ring);
+   	int iters = 0;
+   	unsigned long end;
+	unsigned int last_head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+
+	end = jiffies + (HZ*3);
+   	while (ring->space < n) {
+	   	int i;
+	
+	   	ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+	   	ring->space = ring->head - (ring->tail+8);
+		if (ring->space < 0) ring->space += ring->Size;
+	   
+		if (ring->head != last_head)
+		   end = jiffies + (HZ*3);
+	  
+	   	iters++;
+		if((signed)(end - jiffies) <= 0) {
+		   	DRM_ERROR("space: %d wanted %d\n", ring->space, n);
+		   	DRM_ERROR("lockup\n");
+		   	goto out_wait_ring;
+		}
+
+	   	for (i = 0 ; i < 2000 ; i++) ;
+	}
+
+out_wait_ring:   
+   	return iters;
+}
+
+static void i810_kernel_lost_context(drm_device_t *dev)
+{
+      	drm_i810_private_t *dev_priv = dev->dev_private;
+   	drm_i810_ring_buffer_t *ring = &(dev_priv->ring);
+      
+   	ring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;
+     	ring->tail = I810_READ(LP_RING + RING_TAIL);
+     	ring->space = ring->head - (ring->tail+8);
+     	if (ring->space < 0) ring->space += ring->Size;
+}
+
+static int i810_freelist_init(drm_device_t *dev)
+{
+      	drm_device_dma_t *dma = dev->dma;
+   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+   	int my_idx = 24;
+   	u32 *hw_status = (u32 *)(dev_priv->hw_status_page + my_idx);
+   	int i;
+   
+   	if(dma->buf_count > 1019) {
+	   	/* Not enough space in the status page for the freelist */
+	   	return -EINVAL;
+	}
+
+   	for (i = 0; i < dma->buf_count; i++) {
+	   	drm_buf_t *buf = dma->buflist[ i ];
+	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	   
+	   	buf_priv->in_use = hw_status++;
+	   	buf_priv->my_use_idx = my_idx;
+	   	my_idx += 4;
+
+	   	*buf_priv->in_use = I810_BUF_FREE;
+
+		buf_priv->kernel_virtual = drm_ioremap(buf->bus_address, 
+						       buf->total, dev);
+	}
+	return 0;
+}
+
+static int i810_dma_initialize(drm_device_t *dev, 
+			       drm_i810_private_t *dev_priv,
+			       drm_i810_init_t *init)
+{
+	drm_map_t *sarea_map;
+
+   	dev->dev_private = (void *) dev_priv;
+   	memset(dev_priv, 0, sizeof(drm_i810_private_t));
+
+   	if (init->ring_map_idx >= dev->map_count ||
+	    init->buffer_map_idx >= dev->map_count) {
+	   	i810_dma_cleanup(dev);
+	   	DRM_ERROR("ring_map or buffer_map are invalid\n");
+	   	return -EINVAL;
+	}
+   
+   	dev_priv->ring_map_idx = init->ring_map_idx;
+   	dev_priv->buffer_map_idx = init->buffer_map_idx;
+	sarea_map = dev->maplist[0];
+	dev_priv->sarea_priv = (drm_i810_sarea_t *) 
+		((u8 *)sarea_map->handle + 
+		 init->sarea_priv_offset);
+
+   	atomic_set(&dev_priv->flush_done, 0);
+	init_waitqueue_head(&dev_priv->flush_queue);
+   	
+   	dev_priv->ring.Start = init->ring_start;
+   	dev_priv->ring.End = init->ring_end;
+   	dev_priv->ring.Size = init->ring_size;
+
+   	dev_priv->ring.virtual_start = drm_ioremap(dev->agp->base + 
+						   init->ring_start, 
+						   init->ring_size, dev);
+
+   	dev_priv->ring.tail_mask = dev_priv->ring.Size - 1;
+   
+   	if (dev_priv->ring.virtual_start == NULL) {
+	   	i810_dma_cleanup(dev);
+	   	DRM_ERROR("can not ioremap virtual address for"
+			  " ring buffer\n");
+	   	return -ENOMEM;
+	}
+
+	dev_priv->w = init->w;
+	dev_priv->h = init->h;
+	dev_priv->pitch = init->pitch;
+	dev_priv->back_offset = init->back_offset;
+	dev_priv->depth_offset = init->depth_offset;
+
+	dev_priv->front_di1 = init->front_offset | init->pitch_bits;
+	dev_priv->back_di1 = init->back_offset | init->pitch_bits;
+	dev_priv->zi1 = init->depth_offset | init->pitch_bits;
+	
+   
+   	/* Program Hardware Status Page */
+   	dev_priv->hw_status_page = i810_alloc_page(dev);
+   	memset((void *) dev_priv->hw_status_page, 0, PAGE_SIZE);
+   	if(dev_priv->hw_status_page == 0UL) {
+		i810_dma_cleanup(dev);
+		DRM_ERROR("Can not allocate hardware status page\n");
+		return -ENOMEM;
+	}
+   	DRM_DEBUG("hw status page @ %lx\n", dev_priv->hw_status_page);
+   
+   	I810_WRITE(0x02080, virt_to_bus((void *)dev_priv->hw_status_page));
+   	DRM_DEBUG("Enabled hardware status page\n");
+   
+   	/* Now we need to init our freelist */
+   	if(i810_freelist_init(dev) != 0) {
+	   	i810_dma_cleanup(dev);
+	   	DRM_ERROR("Not enough space in the status page for"
+			  " the freelist\n");
+	   	return -ENOMEM;
+	}
+   	return 0;
+}
+
+int i810_dma_init(struct inode *inode, struct file *filp,
+		  unsigned int cmd, unsigned long arg)
+{
+   	drm_file_t *priv = filp->private_data;
+   	drm_device_t *dev = priv->dev;
+   	drm_i810_private_t *dev_priv;
+   	drm_i810_init_t init;
+   	int retcode = 0;
+	
+  	if (copy_from_user(&init, (drm_i810_init_t *)arg, sizeof(init)))
+		return -EFAULT;
+	
+   	switch(init.func) {
+	 	case I810_INIT_DMA:
+	   		dev_priv = drm_alloc(sizeof(drm_i810_private_t), 
+					     DRM_MEM_DRIVER);
+	   		if(dev_priv == NULL) return -ENOMEM;
+	   		retcode = i810_dma_initialize(dev, dev_priv, &init);
+	   	break;
+	 	case I810_CLEANUP_DMA:
+	   		retcode = i810_dma_cleanup(dev);
+	   	break;
+	 	default:
+	   		retcode = -EINVAL;
+	   	break;
+	}
+   
+   	return retcode;
+}
+
+
+
+/* Most efficient way to verify state for the i810 is as it is
+ * emitted.  Non-conformant state is silently dropped.
+ *
+ * Use 'volatile' & local var tmp to force the emitted values to be
+ * identical to the verified ones.
+ */
+static void i810EmitContextVerified( drm_device_t *dev, 
+				     volatile unsigned int *code ) 
+{	
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+	int i, j = 0;
+	unsigned int tmp;
+	RING_LOCALS;
+
+	BEGIN_LP_RING( I810_CTX_SETUP_SIZE );
+
+	OUT_RING( GFX_OP_COLOR_FACTOR );
+	OUT_RING( code[I810_CTXREG_CF1] );
+
+	OUT_RING( GFX_OP_STIPPLE );
+	OUT_RING( code[I810_CTXREG_ST1] );
+
+	for ( i = 4 ; i < I810_CTX_SETUP_SIZE ; i++ ) {
+		tmp = code[i];
+
+		if ((tmp & (7<<29)) == (3<<29) &&
+		    (tmp & (0x1f<<24)) < (0x1d<<24)) 
+		{
+			OUT_RING( tmp ); 
+			j++;
+		} 
+	}
+
+	if (j & 1) 
+		OUT_RING( 0 ); 
+
+	ADVANCE_LP_RING();
+}
+
+static void i810EmitTexVerified( drm_device_t *dev, 
+				 volatile unsigned int *code ) 
+{	
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+	int i, j = 0;
+	unsigned int tmp;
+	RING_LOCALS;
+
+	BEGIN_LP_RING( I810_TEX_SETUP_SIZE );
+
+	OUT_RING( GFX_OP_MAP_INFO );
+	OUT_RING( code[I810_TEXREG_MI1] );
+	OUT_RING( code[I810_TEXREG_MI2] );
+	OUT_RING( code[I810_TEXREG_MI3] );
+
+	for ( i = 4 ; i < I810_TEX_SETUP_SIZE ; i++ ) {
+		tmp = code[i];
+
+		if ((tmp & (7<<29)) == (3<<29) &&
+		    (tmp & (0x1f<<24)) < (0x1d<<24)) 
+		{
+			OUT_RING( tmp ); 
+			j++;
+		}
+	} 
+		
+	if (j & 1) 
+		OUT_RING( 0 ); 
+
+	ADVANCE_LP_RING();
+}
+
+
+/* Need to do some additional checking when setting the dest buffer.
+ */
+static void i810EmitDestVerified( drm_device_t *dev, 
+				  volatile unsigned int *code ) 
+{	
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+	unsigned int tmp;
+	RING_LOCALS;
+
+	BEGIN_LP_RING( I810_DEST_SETUP_SIZE + 2 );
+
+	tmp = code[I810_DESTREG_DI1];
+	if (tmp == dev_priv->front_di1 || tmp == dev_priv->back_di1) {
+		OUT_RING( CMD_OP_DESTBUFFER_INFO );
+		OUT_RING( tmp );
+	} else
+	   DRM_DEBUG("bad di1 %x (allow %x or %x)\n",
+		     tmp, dev_priv->front_di1, dev_priv->back_di1);
+
+	/* invarient:
+	 */
+	OUT_RING( CMD_OP_Z_BUFFER_INFO );
+	OUT_RING( dev_priv->zi1 );
+
+	OUT_RING( GFX_OP_DESTBUFFER_VARS );
+	OUT_RING( code[I810_DESTREG_DV1] );
+
+	OUT_RING( GFX_OP_DRAWRECT_INFO );
+	OUT_RING( code[I810_DESTREG_DR1] );
+	OUT_RING( code[I810_DESTREG_DR2] );
+	OUT_RING( code[I810_DESTREG_DR3] );
+	OUT_RING( code[I810_DESTREG_DR4] );
+	OUT_RING( 0 );
+
+	ADVANCE_LP_RING();
+}
+
+
+
+static void i810EmitState( drm_device_t *dev )
+{
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+      	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+
+	if (dirty & I810_UPLOAD_BUFFERS) {
+		i810EmitDestVerified( dev, sarea_priv->BufferState );
+		sarea_priv->dirty &= ~I810_UPLOAD_BUFFERS;
+	}
+
+	if (dirty & I810_UPLOAD_CTX) {
+		i810EmitContextVerified( dev, sarea_priv->ContextState );
+		sarea_priv->dirty &= ~I810_UPLOAD_CTX;
+	}
+
+	if (dirty & I810_UPLOAD_TEX0) {
+		i810EmitTexVerified( dev, sarea_priv->TexState[0] );
+		sarea_priv->dirty &= ~I810_UPLOAD_TEX0;
+	}
+
+	if (dirty & I810_UPLOAD_TEX1) {
+		i810EmitTexVerified( dev, sarea_priv->TexState[1] );
+		sarea_priv->dirty &= ~I810_UPLOAD_TEX1;
+	}
+}
+
+
+
+/* need to verify 
+ */
+static void i810_dma_dispatch_clear( drm_device_t *dev, int flags, 
+				     unsigned int clear_color,
+				     unsigned int clear_zval )
+{
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+      	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	int pitch = dev_priv->pitch;
+	int cpp = 2;
+	int i;
+	RING_LOCALS;
+
+  	i810_kernel_lost_context(dev);
+
+      	if (nbox > I810_NR_SAREA_CLIPRECTS)
+     		nbox = I810_NR_SAREA_CLIPRECTS;
+
+	for (i = 0 ; i < nbox ; i++, pbox++) {
+		unsigned int x = pbox->x1;
+		unsigned int y = pbox->y1;
+		unsigned int width = (pbox->x2 - x) * cpp;
+		unsigned int height = pbox->y2 - y;
+		unsigned int start = y * pitch + x * cpp;
+
+		if (pbox->x1 > pbox->x2 ||
+		    pbox->y1 > pbox->y2 ||
+		    pbox->x2 > dev_priv->w ||
+		    pbox->y2 > dev_priv->h)
+			continue;
+
+	   	if ( flags & I810_FRONT ) {	    
+		   	DRM_DEBUG("clear front\n");
+			BEGIN_LP_RING( 6 );	    
+			OUT_RING( BR00_BITBLT_CLIENT | 
+				  BR00_OP_COLOR_BLT | 0x3 );
+			OUT_RING( BR13_SOLID_PATTERN | (0xF0 << 16) | pitch );
+			OUT_RING( (height << 16) | width );
+			OUT_RING( start );
+			OUT_RING( clear_color );
+			OUT_RING( 0 );
+			ADVANCE_LP_RING();
+		}
+
+		if ( flags & I810_BACK ) {
+			DRM_DEBUG("clear back\n");
+			BEGIN_LP_RING( 6 );	    
+			OUT_RING( BR00_BITBLT_CLIENT | 
+				  BR00_OP_COLOR_BLT | 0x3 );
+			OUT_RING( BR13_SOLID_PATTERN | (0xF0 << 16) | pitch );
+			OUT_RING( (height << 16) | width );
+			OUT_RING( dev_priv->back_offset + start );
+			OUT_RING( clear_color );
+			OUT_RING( 0 );
+			ADVANCE_LP_RING();
+		}
+
+		if ( flags & I810_DEPTH ) {
+			DRM_DEBUG("clear depth\n");
+			BEGIN_LP_RING( 6 );	    
+			OUT_RING( BR00_BITBLT_CLIENT | 
+				  BR00_OP_COLOR_BLT | 0x3 );
+			OUT_RING( BR13_SOLID_PATTERN | (0xF0 << 16) | pitch );
+			OUT_RING( (height << 16) | width );
+			OUT_RING( dev_priv->depth_offset + start );
+			OUT_RING( clear_zval );
+			OUT_RING( 0 );
+			ADVANCE_LP_RING();
+		}
+	}
+}
+
+static void i810_dma_dispatch_swap( drm_device_t *dev )
+{
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+      	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	int pitch = dev_priv->pitch;
+	int cpp = 2;
+	int ofs = dev_priv->back_offset;
+	int i;
+	RING_LOCALS;
+
+	DRM_DEBUG("swapbuffers\n");
+
+  	i810_kernel_lost_context(dev);
+
+      	if (nbox > I810_NR_SAREA_CLIPRECTS)
+     		nbox = I810_NR_SAREA_CLIPRECTS;
+
+	for (i = 0 ; i < nbox; i++, pbox++) 
+	{
+		unsigned int w = pbox->x2 - pbox->x1;
+		unsigned int h = pbox->y2 - pbox->y1;
+		unsigned int dst = pbox->x1*cpp + pbox->y1*pitch;
+		unsigned int start = ofs + dst;
+
+		if (pbox->x1 > pbox->x2 ||
+		    pbox->y1 > pbox->y2 ||
+		    pbox->x2 > dev_priv->w ||
+		    pbox->y2 > dev_priv->h)
+			continue;
+ 
+	   	DRM_DEBUG("dispatch swap %d,%d-%d,%d!\n",
+			  pbox[i].x1, pbox[i].y1,
+			  pbox[i].x2, pbox[i].y2);
+
+		BEGIN_LP_RING( 6 );
+		OUT_RING( BR00_BITBLT_CLIENT | BR00_OP_SRC_COPY_BLT | 0x4 );
+		OUT_RING( pitch | (0xCC << 16));
+		OUT_RING( (h << 16) | (w * cpp));
+		OUT_RING( dst );
+		OUT_RING( pitch );	
+		OUT_RING( start );
+		ADVANCE_LP_RING();
+	}
+}
+
+
+static void i810_dma_dispatch_vertex(drm_device_t *dev, 
+				     drm_buf_t *buf,
+				     int discard,
+				     int used)
+{
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+   	drm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;
+   	drm_clip_rect_t *box = sarea_priv->boxes;
+   	int nbox = sarea_priv->nbox;
+	unsigned long address = (unsigned long)buf->bus_address;
+	unsigned long start = address - dev->agp->base;     
+	int i = 0, u;
+   	RING_LOCALS;
+
+   	i810_kernel_lost_context(dev);
+
+   	if (nbox > I810_NR_SAREA_CLIPRECTS) 
+		nbox = I810_NR_SAREA_CLIPRECTS;
+
+	if (discard) {
+		u = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, 
+			    I810_BUF_HARDWARE);
+		if(u != I810_BUF_CLIENT) {
+			DRM_DEBUG("xxxx 2\n");
+		}
+	}
+
+	if (used > 4*1024) 
+		used = 0;
+
+	if (sarea_priv->dirty)
+	   i810EmitState( dev );
+
+  	DRM_DEBUG("dispatch vertex addr 0x%lx, used 0x%x nbox %d\n", 
+		  address, used, nbox);
+
+   	dev_priv->counter++;
+   	DRM_DEBUG(  "dispatch counter : %ld\n", dev_priv->counter);
+   	DRM_DEBUG(  "i810_dma_dispatch\n");
+   	DRM_DEBUG(  "start : %lx\n", start);
+	DRM_DEBUG(  "used : %d\n", used);
+   	DRM_DEBUG(  "start + used - 4 : %ld\n", start + used - 4);
+
+	if (buf_priv->currently_mapped == I810_BUF_MAPPED) {
+		*(u32 *)buf_priv->virtual = (GFX_OP_PRIMITIVE |
+					     sarea_priv->vertex_prim |
+					     ((used/4)-2));
+		
+		if (used & 4) {
+			*(u32 *)((u32)buf_priv->virtual + used) = 0;
+			used += 4;
+		}
+
+		i810_unmap_buffer(buf);
+	}
+		   
+	if (used) {
+		do {
+			if (i < nbox) {
+				BEGIN_LP_RING(4);
+				OUT_RING( GFX_OP_SCISSOR | SC_UPDATE_SCISSOR | 
+					  SC_ENABLE );
+				OUT_RING( GFX_OP_SCISSOR_INFO );
+				OUT_RING( box[i].x1 | (box[i].y1<<16) );
+				OUT_RING( (box[i].x2-1) | ((box[i].y2-1)<<16) );
+				ADVANCE_LP_RING();
+			}
+			
+			BEGIN_LP_RING(4);
+			OUT_RING( CMD_OP_BATCH_BUFFER );
+			OUT_RING( start | BB1_PROTECTED );
+			OUT_RING( start + used - 4 );
+			OUT_RING( 0 );
+			ADVANCE_LP_RING();
+			
+		} while (++i < nbox);
+	}
+
+	BEGIN_LP_RING(10);
+	OUT_RING( CMD_STORE_DWORD_IDX );
+	OUT_RING( 20 );
+	OUT_RING( dev_priv->counter );
+	OUT_RING( 0 );
+
+	if (discard) {
+		OUT_RING( CMD_STORE_DWORD_IDX );
+		OUT_RING( buf_priv->my_use_idx );
+		OUT_RING( I810_BUF_FREE );
+		OUT_RING( 0 );
+	}
+
+      	OUT_RING( CMD_REPORT_HEAD );
+	OUT_RING( 0 );
+   	ADVANCE_LP_RING();
+}
+
+
+/* Interrupts are only for flushing */
+static void i810_dma_service(int irq, void *device, struct pt_regs *regs)
+{
+	drm_device_t	 *dev = (drm_device_t *)device;
+   	u16 temp;
+   
+	atomic_inc(&dev->total_irq);
+      	temp = I810_READ16(I810REG_INT_IDENTITY_R);
+   	temp = temp & ~(0x6000);
+   	if(temp != 0) I810_WRITE16(I810REG_INT_IDENTITY_R, 
+				   temp); /* Clear all interrupts */
+	else
+	   return;
+ 
+   	queue_task(&dev->tq, &tq_immediate);
+   	mark_bh(IMMEDIATE_BH);
+}
+
+static void i810_dma_task_queue(void *device)
+{
+	drm_device_t *dev = (drm_device_t *) device;
+      	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+
+   	atomic_set(&dev_priv->flush_done, 1);
+   	wake_up_interruptible(&dev_priv->flush_queue);
+}
+
+int i810_irq_install(drm_device_t *dev, int irq)
+{
+	int retcode;
+	u16 temp;
+   
+	if (!irq)     return -EINVAL;
+	
+	down(&dev->struct_sem);
+	if (dev->irq) {
+		up(&dev->struct_sem);
+		return -EBUSY;
+	}
+	dev->irq = irq;
+	up(&dev->struct_sem);
+	
+   	DRM_DEBUG(  "Interrupt Install : %d\n", irq);
+	DRM_DEBUG("%d\n", irq);
+
+	dev->context_flag     = 0;
+	dev->interrupt_flag   = 0;
+	dev->dma_flag	      = 0;
+	
+	dev->dma->next_buffer = NULL;
+	dev->dma->next_queue  = NULL;
+	dev->dma->this_buffer = NULL;
+
+	INIT_LIST_HEAD(&dev->tq.list);
+	dev->tq.sync	      = 0;
+	dev->tq.routine	      = i810_dma_task_queue;
+	dev->tq.data	      = dev;
+
+				/* Before installing handler */
+   	temp = I810_READ16(I810REG_HWSTAM);
+   	temp = temp & 0x6000;
+   	I810_WRITE16(I810REG_HWSTAM, temp);
+   	
+      	temp = I810_READ16(I810REG_INT_MASK_R);
+   	temp = temp & 0x6000;
+   	I810_WRITE16(I810REG_INT_MASK_R, temp); /* Unmask interrupts */
+   	temp = I810_READ16(I810REG_INT_ENABLE_R);
+   	temp = temp & 0x6000;
+      	I810_WRITE16(I810REG_INT_ENABLE_R, temp); /* Disable all interrupts */
+
+				/* Install handler */
+	if ((retcode = request_irq(dev->irq,
+				   i810_dma_service,
+				   SA_SHIRQ,
+				   dev->devname,
+				   dev))) {
+		down(&dev->struct_sem);
+		dev->irq = 0;
+		up(&dev->struct_sem);
+		return retcode;
+	}
+   	temp = I810_READ16(I810REG_INT_ENABLE_R);
+   	temp = temp & 0x6000;
+   	temp = temp | 0x0003;
+   	I810_WRITE16(I810REG_INT_ENABLE_R, 
+		     temp); /* Enable bp & user interrupts */
+	return 0;
+}
+
+int i810_irq_uninstall(drm_device_t *dev)
+{
+	int irq;
+   	u16 temp;
+
+
+/*  	return 0; */
+
+	down(&dev->struct_sem);
+	irq	 = dev->irq;
+	dev->irq = 0;
+	up(&dev->struct_sem);
+	
+	if (!irq) return -EINVAL;
+
+   	DRM_DEBUG(  "Interrupt UnInstall: %d\n", irq);	
+	DRM_DEBUG("%d\n", irq);
+   
+   	temp = I810_READ16(I810REG_INT_IDENTITY_R);
+   	temp = temp & ~(0x6000);
+   	if(temp != 0) I810_WRITE16(I810REG_INT_IDENTITY_R, 
+				   temp); /* Clear all interrupts */
+   
+   	temp = I810_READ16(I810REG_INT_ENABLE_R);
+   	temp = temp & 0x6000;
+   	I810_WRITE16(I810REG_INT_ENABLE_R, 
+		     temp);                     /* Disable all interrupts */
+
+   	free_irq(irq, dev);
+
+	return 0;
+}
+
+int i810_control(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_control_t	ctl;
+	int		retcode;
+   
+   	DRM_DEBUG(  "i810_control\n");
+
+	if (copy_from_user(&ctl, (drm_control_t *)arg, sizeof(ctl)))
+		return -EFAULT;
+	
+	switch (ctl.func) {
+	case DRM_INST_HANDLER:
+		if ((retcode = i810_irq_install(dev, ctl.irq)))
+			return retcode;
+		break;
+	case DRM_UNINST_HANDLER:
+		if ((retcode = i810_irq_uninstall(dev)))
+			return retcode;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static inline void i810_dma_emit_flush(drm_device_t *dev)
+{
+   	drm_i810_private_t *dev_priv = dev->dev_private;
+   	RING_LOCALS;
+
+   	i810_kernel_lost_context(dev);
+
+   	BEGIN_LP_RING(2);
+      	OUT_RING( CMD_REPORT_HEAD );
+      	OUT_RING( GFX_OP_USER_INTERRUPT );
+      	ADVANCE_LP_RING();
+
+/*  	i810_wait_ring( dev, dev_priv->ring.Size - 8 ); */
+/*     	atomic_set(&dev_priv->flush_done, 1); */
+/*     	wake_up_interruptible(&dev_priv->flush_queue); */
+}
+
+static inline void i810_dma_quiescent_emit(drm_device_t *dev)
+{
+      	drm_i810_private_t *dev_priv = dev->dev_private;
+   	RING_LOCALS;
+
+  	i810_kernel_lost_context(dev);
+
+   	BEGIN_LP_RING(4);
+   	OUT_RING( INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE );
+   	OUT_RING( CMD_REPORT_HEAD );
+      	OUT_RING( 0 );
+      	OUT_RING( GFX_OP_USER_INTERRUPT );
+   	ADVANCE_LP_RING();
+
+/*  	i810_wait_ring( dev, dev_priv->ring.Size - 8 ); */
+/*     	atomic_set(&dev_priv->flush_done, 1); */
+/*     	wake_up_interruptible(&dev_priv->flush_queue); */
+}
+
+static void i810_dma_quiescent(drm_device_t *dev)
+{
+      	DECLARE_WAITQUEUE(entry, current);
+  	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+	unsigned long end;      
+
+   	if(dev_priv == NULL) {
+	   	return;
+	}
+      	atomic_set(&dev_priv->flush_done, 0);
+   	add_wait_queue(&dev_priv->flush_queue, &entry);
+   	end = jiffies + (HZ*3);
+   
+   	for (;;) {
+		current->state = TASK_INTERRUPTIBLE;
+	      	i810_dma_quiescent_emit(dev);
+	   	if (atomic_read(&dev_priv->flush_done) == 1) break;
+		if((signed)(end - jiffies) <= 0) {
+		   	DRM_ERROR("lockup\n");
+		   	break;
+		}	   
+	      	schedule_timeout(HZ*3);
+	      	if (signal_pending(current)) {
+		   	break;
+		}
+	}
+   
+   	current->state = TASK_RUNNING;
+   	remove_wait_queue(&dev_priv->flush_queue, &entry);
+   
+   	return;
+}
+
+static int i810_flush_queue(drm_device_t *dev)
+{
+   	DECLARE_WAITQUEUE(entry, current);
+  	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	unsigned long end;
+   	int i, ret = 0;      
+
+   	if(dev_priv == NULL) {
+	   	return 0;
+	}
+      	atomic_set(&dev_priv->flush_done, 0);
+   	add_wait_queue(&dev_priv->flush_queue, &entry);
+   	end = jiffies + (HZ*3);
+   	for (;;) {
+		current->state = TASK_INTERRUPTIBLE;
+	      	i810_dma_emit_flush(dev);
+	   	if (atomic_read(&dev_priv->flush_done) == 1) break;
+		if((signed)(end - jiffies) <= 0) {
+		   	DRM_ERROR("lockup\n");
+		   	break;
+		}	   
+	      	schedule_timeout(HZ*3);
+	      	if (signal_pending(current)) {
+		   	ret = -EINTR; /* Can't restart */
+		   	break;
+		}
+	}
+   
+   	current->state = TASK_RUNNING;
+   	remove_wait_queue(&dev_priv->flush_queue, &entry);
+
+
+   	for (i = 0; i < dma->buf_count; i++) {
+	   	drm_buf_t *buf = dma->buflist[ i ];
+	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	   
+		int used = cmpxchg(buf_priv->in_use, I810_BUF_HARDWARE, 
+				   I810_BUF_FREE);
+
+		if (used == I810_BUF_HARDWARE)
+			DRM_DEBUG("reclaimed from HARDWARE\n");
+		if (used == I810_BUF_CLIENT)
+			DRM_DEBUG("still on client HARDWARE\n");
+	}
+
+   	return ret;
+}
+
+/* Must be called with the lock held */
+void i810_reclaim_buffers(drm_device_t *dev, pid_t pid)
+{
+	drm_device_dma_t *dma = dev->dma;
+	int		 i;
+
+	if (!dma) return;
+      	if (!dev->dev_private) return;
+	if (!dma->buflist) return;
+
+        i810_flush_queue(dev);
+
+	for (i = 0; i < dma->buf_count; i++) {
+	   	drm_buf_t *buf = dma->buflist[ i ];
+	   	drm_i810_buf_priv_t *buf_priv = buf->dev_private;
+	   
+		if (buf->pid == pid && buf_priv) {
+			int used = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, 
+					   I810_BUF_FREE);
+
+			if (used == I810_BUF_CLIENT)
+				DRM_DEBUG("reclaimed from client\n");
+		   	if(buf_priv->currently_mapped == I810_BUF_MAPPED)
+		     		buf_priv->currently_mapped = I810_BUF_UNMAPPED;
+		}
+	}
+}
+
+int i810_lock(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+
+	DECLARE_WAITQUEUE(entry, current);
+	int		  ret	= 0;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+   
+   	DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+		  lock.context, current->pid, dev->lock.hw_lock->lock,
+		  lock.flags);
+
+	if (lock.context < 0) {
+		return -EINVAL;
+	}
+	/* Only one queue:
+	 */
+
+	if (!ret) {
+		add_wait_queue(&dev->lock.lock_queue, &entry);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!dev->lock.hw_lock) {
+				/* Device has been unregistered */
+				ret = -EINTR;
+				break;
+			}
+			if (drm_lock_take(&dev->lock.hw_lock->lock,
+					  lock.context)) {
+				dev->lock.pid	    = current->pid;
+				dev->lock.lock_time = jiffies;
+				atomic_inc(&dev->total_locks);
+				break;	/* Got lock */
+			}
+			
+				/* Contention */
+			atomic_inc(&dev->total_sleeps);
+		   	DRM_DEBUG("Calling lock schedule\n");
+			schedule();
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&dev->lock.lock_queue, &entry);
+	}
+	
+	if (!ret) {
+		sigemptyset(&dev->sigmask);
+		sigaddset(&dev->sigmask, SIGSTOP);
+		sigaddset(&dev->sigmask, SIGTSTP);
+		sigaddset(&dev->sigmask, SIGTTIN);
+		sigaddset(&dev->sigmask, SIGTTOU);
+		dev->sigdata.context = lock.context;
+		dev->sigdata.lock    = dev->lock.hw_lock;
+		block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+
+		if (lock.flags & _DRM_LOCK_QUIESCENT) {
+		   DRM_DEBUG("_DRM_LOCK_QUIESCENT\n");
+		   DRM_DEBUG("fred\n");
+		   i810_dma_quiescent(dev);
+		}
+	}
+	DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
+	return ret;
+}
+
+int i810_flush_ioctl(struct inode *inode, struct file *filp, 
+		     unsigned int cmd, unsigned long arg)
+{
+   	drm_file_t	  *priv	  = filp->private_data;
+   	drm_device_t	  *dev	  = priv->dev;
+   
+   	DRM_DEBUG("i810_flush_ioctl\n");
+   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("i810_flush_ioctl called without lock held\n");
+		return -EINVAL;
+	}
+
+   	i810_flush_queue(dev);
+   	return 0;
+}
+
+
+int i810_dma_vertex(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+      	u32 *hw_status = (u32 *)dev_priv->hw_status_page;
+   	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *) 
+     					dev_priv->sarea_priv; 
+	drm_i810_vertex_t vertex;
+
+	if (copy_from_user(&vertex, (drm_i810_vertex_t *)arg, sizeof(vertex)))
+		return -EFAULT;
+
+   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("i810_dma_vertex called without lock held\n");
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("i810 dma vertex, idx %d used %d discard %d\n",
+		  vertex.idx, vertex.used, vertex.discard);
+
+	if(vertex.idx < 0 || vertex.idx > dma->buf_count) return -EINVAL;
+
+	i810_dma_dispatch_vertex( dev, 
+				  dma->buflist[ vertex.idx ], 
+				  vertex.discard, vertex.used );
+
+   	atomic_add(vertex.used, &dma->total_bytes);
+	atomic_inc(&dma->total_dmas);
+	sarea_priv->last_enqueue = dev_priv->counter-1;
+   	sarea_priv->last_dispatch = (int) hw_status[5];
+   
+	return 0;
+}
+
+
+
+int i810_clear_bufs(struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_i810_clear_t clear;
+
+   	if (copy_from_user(&clear, (drm_i810_clear_t *)arg, sizeof(clear)))
+		return -EFAULT;
+   
+   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("i810_clear_bufs called without lock held\n");
+		return -EINVAL;
+	}
+
+	i810_dma_dispatch_clear( dev, clear.flags, 
+				 clear.clear_color, 
+				 clear.clear_depth );
+   	return 0;
+}
+
+int i810_swap_bufs(struct inode *inode, struct file *filp,
+		  unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+   
+	DRM_DEBUG("i810_swap_bufs\n");
+
+   	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("i810_swap_buf called without lock held\n");
+		return -EINVAL;
+	}
+
+	i810_dma_dispatch_swap( dev );
+   	return 0;
+}
+
+int i810_getage(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+   	drm_file_t	  *priv	    = filp->private_data;
+	drm_device_t	  *dev	    = priv->dev;
+   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+      	u32 *hw_status = (u32 *)dev_priv->hw_status_page;
+   	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *) 
+     					dev_priv->sarea_priv; 
+
+      	sarea_priv->last_dispatch = (int) hw_status[5];
+	return 0;
+}
+
+int i810_getbuf(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	  *priv	    = filp->private_data;
+	drm_device_t	  *dev	    = priv->dev;
+	int		  retcode   = 0;
+	drm_i810_dma_t	  d;
+   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+   	u32 *hw_status = (u32 *)dev_priv->hw_status_page;
+   	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *) 
+     					dev_priv->sarea_priv; 
+
+	DRM_DEBUG("getbuf\n");
+   	if (copy_from_user(&d, (drm_i810_dma_t *)arg, sizeof(d)))
+		return -EFAULT;
+   
+	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("i810_dma called without lock held\n");
+		return -EINVAL;
+	}
+	
+	d.granted = 0;
+
+	retcode = i810_dma_get_buffer(dev, &d, filp);
+
+	DRM_DEBUG("i810_dma: %d returning %d, granted = %d\n",
+		  current->pid, retcode, d.granted);
+
+	if (copy_to_user((drm_dma_t *)arg, &d, sizeof(d)))
+		return -EFAULT;
+   	sarea_priv->last_dispatch = (int) hw_status[5];
+
+	return retcode;
+}
+
+int i810_copybuf(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	  *priv	    = filp->private_data;
+	drm_device_t	  *dev	    = priv->dev;
+	drm_i810_copy_t	  d;
+   	drm_i810_private_t *dev_priv = (drm_i810_private_t *)dev->dev_private;
+   	u32 *hw_status = (u32 *)dev_priv->hw_status_page;
+   	drm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *) 
+     					dev_priv->sarea_priv; 
+	drm_buf_t *buf;
+	drm_i810_buf_priv_t *buf_priv;
+	drm_device_dma_t *dma = dev->dma;
+
+	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("i810_dma called without lock held\n");
+		return -EINVAL;
+	}
+   
+   	if (copy_from_user(&d, (drm_i810_copy_t *)arg, sizeof(d)))
+		return -EFAULT;
+
+	if(d.idx < 0 || d.idx > dma->buf_count) return -EINVAL;
+	buf = dma->buflist[ d.idx ];
+   	buf_priv = buf->dev_private;
+	if (buf_priv->currently_mapped != I810_BUF_MAPPED) return -EPERM;
+
+	/* Stopping end users copying their data to the entire kernel
+	   is good.. */
+	if (d.used < 0 || d.used > buf->total)
+		return -EINVAL;
+		
+   	if (copy_from_user(buf_priv->virtual, d.address, d.used))
+		return -EFAULT;
+
+   	sarea_priv->last_dispatch = (int) hw_status[5];
+
+	return 0;
+}
+
+int i810_docopy(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	if(VM_DONTCOPY == 0) return 1;
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/i810_drm.h linux/drivers/char/drm-4.0/i810_drm.h
--- linux.orig/drivers/char/drm-4.0/i810_drm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/i810_drm.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,194 @@
+#ifndef _I810_DRM_H_
+#define _I810_DRM_H_
+
+/* WARNING: These defines must be the same as what the Xserver uses.
+ * if you change them, you must change the defines in the Xserver.
+ */
+
+#ifndef _I810_DEFINES_
+#define _I810_DEFINES_
+
+#define I810_DMA_BUF_ORDER		12
+#define I810_DMA_BUF_SZ 		(1<<I810_DMA_BUF_ORDER)
+#define I810_DMA_BUF_NR 		256
+#define I810_NR_SAREA_CLIPRECTS 	8
+
+/* Each region is a minimum of 64k, and there are at most 64 of them.
+ */
+#define I810_NR_TEX_REGIONS 64
+#define I810_LOG_MIN_TEX_REGION_SIZE 16
+#endif
+
+#define I810_UPLOAD_TEX0IMAGE  0x1 /* handled clientside */
+#define I810_UPLOAD_TEX1IMAGE  0x2 /* handled clientside */
+#define I810_UPLOAD_CTX        0x4
+#define I810_UPLOAD_BUFFERS    0x8
+#define I810_UPLOAD_TEX0       0x10
+#define I810_UPLOAD_TEX1       0x20
+#define I810_UPLOAD_CLIPRECTS  0x40
+
+
+/* Indices into buf.Setup where various bits of state are mirrored per
+ * context and per buffer.  These can be fired at the card as a unit,
+ * or in a piecewise fashion as required.
+ */
+
+/* Destbuffer state 
+ *    - backbuffer linear offset and pitch -- invarient in the current dri
+ *    - zbuffer linear offset and pitch -- also invarient
+ *    - drawing origin in back and depth buffers.
+ *
+ * Keep the depth/back buffer state here to acommodate private buffers
+ * in the future.
+ */
+#define I810_DESTREG_DI0  0	/* CMD_OP_DESTBUFFER_INFO (2 dwords) */
+#define I810_DESTREG_DI1  1
+#define I810_DESTREG_DV0  2	/* GFX_OP_DESTBUFFER_VARS (2 dwords) */
+#define I810_DESTREG_DV1  3
+#define I810_DESTREG_DR0  4	/* GFX_OP_DRAWRECT_INFO (4 dwords) */
+#define I810_DESTREG_DR1  5
+#define I810_DESTREG_DR2  6
+#define I810_DESTREG_DR3  7
+#define I810_DESTREG_DR4  8
+#define I810_DEST_SETUP_SIZE 10
+
+/* Context state
+ */
+#define I810_CTXREG_CF0   0	/* GFX_OP_COLOR_FACTOR */
+#define I810_CTXREG_CF1   1	
+#define I810_CTXREG_ST0   2     /* GFX_OP_STIPPLE */
+#define I810_CTXREG_ST1   3
+#define I810_CTXREG_VF    4	/* GFX_OP_VERTEX_FMT */
+#define I810_CTXREG_MT    5	/* GFX_OP_MAP_TEXELS */
+#define I810_CTXREG_MC0   6	/* GFX_OP_MAP_COLOR_STAGES - stage 0 */
+#define I810_CTXREG_MC1   7     /* GFX_OP_MAP_COLOR_STAGES - stage 1 */
+#define I810_CTXREG_MC2   8	/* GFX_OP_MAP_COLOR_STAGES - stage 2 */
+#define I810_CTXREG_MA0   9	/* GFX_OP_MAP_ALPHA_STAGES - stage 0 */
+#define I810_CTXREG_MA1   10	/* GFX_OP_MAP_ALPHA_STAGES - stage 1 */
+#define I810_CTXREG_MA2   11	/* GFX_OP_MAP_ALPHA_STAGES - stage 2 */
+#define I810_CTXREG_SDM   12	/* GFX_OP_SRC_DEST_MONO */
+#define I810_CTXREG_FOG   13	/* GFX_OP_FOG_COLOR */
+#define I810_CTXREG_B1    14	/* GFX_OP_BOOL_1 */
+#define I810_CTXREG_B2    15	/* GFX_OP_BOOL_2 */
+#define I810_CTXREG_LCS   16	/* GFX_OP_LINEWIDTH_CULL_SHADE_MODE */
+#define I810_CTXREG_PV    17	/* GFX_OP_PV_RULE -- Invarient! */
+#define I810_CTXREG_ZA    18	/* GFX_OP_ZBIAS_ALPHAFUNC */
+#define I810_CTXREG_AA    19	/* GFX_OP_ANTIALIAS */
+#define I810_CTX_SETUP_SIZE 20 
+
+/* Texture state (per tex unit)
+ */
+#define I810_TEXREG_MI0  0	/* GFX_OP_MAP_INFO (4 dwords) */
+#define I810_TEXREG_MI1  1	
+#define I810_TEXREG_MI2  2	
+#define I810_TEXREG_MI3  3	
+#define I810_TEXREG_MF   4	/* GFX_OP_MAP_FILTER */
+#define I810_TEXREG_MLC  5	/* GFX_OP_MAP_LOD_CTL */
+#define I810_TEXREG_MLL  6	/* GFX_OP_MAP_LOD_LIMITS */
+#define I810_TEXREG_MCS  7	/* GFX_OP_MAP_COORD_SETS ??? */
+#define I810_TEX_SETUP_SIZE 8
+
+#define I810_FRONT   0x1
+#define I810_BACK    0x2
+#define I810_DEPTH   0x4
+
+
+typedef struct _drm_i810_init {
+	enum {
+		I810_INIT_DMA = 0x01,
+		I810_CLEANUP_DMA = 0x02
+	} func;
+	int ring_map_idx;
+	int buffer_map_idx;
+	int sarea_priv_offset;
+	unsigned int ring_start;
+	unsigned int ring_end;
+	unsigned int ring_size;
+	unsigned int front_offset;
+	unsigned int back_offset;
+	unsigned int depth_offset;
+	unsigned int w;
+	unsigned int h;
+	unsigned int pitch;
+	unsigned int pitch_bits; 
+} drm_i810_init_t;
+
+/* Warning: If you change the SAREA structure you must change the Xserver
+ * structure as well */
+
+typedef struct _drm_i810_tex_region {
+	unsigned char next, prev; /* indices to form a circular LRU  */
+	unsigned char in_use;	/* owned by a client, or free? */
+	int age;		/* tracked by clients to update local LRU's */
+} drm_i810_tex_region_t;
+
+typedef struct _drm_i810_sarea {
+   	unsigned int ContextState[I810_CTX_SETUP_SIZE];
+   	unsigned int BufferState[I810_DEST_SETUP_SIZE];
+   	unsigned int TexState[2][I810_TEX_SETUP_SIZE];
+   	unsigned int dirty;
+
+	unsigned int nbox;
+	drm_clip_rect_t boxes[I810_NR_SAREA_CLIPRECTS];
+
+	/* Maintain an LRU of contiguous regions of texture space.  If
+	 * you think you own a region of texture memory, and it has an
+	 * age different to the one you set, then you are mistaken and
+	 * it has been stolen by another client.  If global texAge
+	 * hasn't changed, there is no need to walk the list.
+	 *
+	 * These regions can be used as a proxy for the fine-grained
+	 * texture information of other clients - by maintaining them
+	 * in the same lru which is used to age their own textures,
+	 * clients have an approximate lru for the whole of global
+	 * texture space, and can make informed decisions as to which
+	 * areas to kick out.  There is no need to choose whether to
+	 * kick out your own texture or someone else's - simply eject
+	 * them all in LRU order.  
+	 */
+   
+	drm_i810_tex_region_t texList[I810_NR_TEX_REGIONS+1]; 
+				/* Last elt is sentinal */
+        int texAge;		/* last time texture was uploaded */
+        int last_enqueue;	/* last time a buffer was enqueued */
+	int last_dispatch;	/* age of the most recently dispatched buffer */
+	int last_quiescent;     /*  */
+	int ctxOwner;		/* last context to upload state */
+
+	int vertex_prim;
+
+} drm_i810_sarea_t;
+
+typedef struct _drm_i810_clear {
+	int clear_color;
+	int clear_depth;
+	int flags;
+} drm_i810_clear_t;
+
+
+
+/* These may be placeholders if we have more cliprects than
+ * I810_NR_SAREA_CLIPRECTS.  In that case, the client sets discard to
+ * false, indicating that the buffer will be dispatched again with a
+ * new set of cliprects.
+ */
+typedef struct _drm_i810_vertex {
+   	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	int discard;		/* client is finished with the buffer? */
+} drm_i810_vertex_t;
+
+typedef struct _drm_i810_copy_t {
+   	int idx;		/* buffer index */
+	int used;		/* nr bytes in use */
+	void *address;		/* Address to copy from */
+} drm_i810_copy_t;
+
+typedef struct drm_i810_dma {
+	void *virtual;
+	int request_idx;
+	int request_size;
+	int granted;
+} drm_i810_dma_t;
+
+#endif /* _I810_DRM_H_ */
diff -urN linux.orig/drivers/char/drm-4.0/i810_drv.c linux/drivers/char/drm-4.0/i810_drv.c
--- linux.orig/drivers/char/drm-4.0/i810_drv.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/i810_drv.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,648 @@
+/* i810_drv.c -- I810 driver -*- linux-c -*-
+ * Created: Mon Dec 13 01:56:22 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "i810_drv.h"
+
+#define I810_NAME	 "i810"
+#define I810_DESC	 "Intel I810"
+#define I810_DATE	 "20000928"
+#define I810_MAJOR	 1
+#define I810_MINOR	 1
+#define I810_PATCHLEVEL	 0
+
+static drm_device_t	      i810_device;
+drm_ctx_t		      i810_res_ctx;
+
+static struct file_operations i810_fops = {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* This started being used during 2.4.0-test */
+	owner:   THIS_MODULE,
+#endif
+	open:	 i810_open,
+	flush:	 drm_flush,
+	release: i810_release,
+	ioctl:	 i810_ioctl,
+	mmap:	 drm_mmap,
+	read:	 drm_read,
+	fasync:	 drm_fasync,
+      	poll:	 drm_poll,
+};
+
+static struct miscdevice      i810_misc = {
+	minor: MISC_DYNAMIC_MINOR,
+	name:  I810_NAME,
+	fops:  &i810_fops,
+};
+
+static drm_ioctl_desc_t	      i810_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]     = { i810_version,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)]  = { drm_getunique,  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]   = { drm_getmagic,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]   = { drm_irq_busid,  0, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)]  = { drm_setunique,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]	      = { drm_block,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]     = { drm_unblock,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_CONTROL)]     = { i810_control,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)]  = { drm_authmagic,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]     = { drm_addmap,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)]    = { i810_addbufs,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)]   = { i810_markbufs,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)]   = { i810_infobufs,  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)]   = { i810_freebufs,  1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]     = { i810_addctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]      = { i810_rmctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]     = { i810_modctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]     = { i810_getctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)]  = { i810_switchctx,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]     = { i810_newctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]     = { i810_resctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]    = { drm_adddraw,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]     = { drm_rmdraw,	  1, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	      = { i810_lock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]      = { i810_unlock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]      = { drm_finish,	  1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)] = { drm_agp_acquire, 1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)] = { drm_agp_release, 1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)]  = { drm_agp_enable,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)]    = { drm_agp_info,    1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)]   = { drm_agp_alloc,   1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)]    = { drm_agp_free,    1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)]    = { drm_agp_bind,    1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)]  = { drm_agp_unbind,  1, 1 },
+
+   	[DRM_IOCTL_NR(DRM_IOCTL_I810_INIT)]   = { i810_dma_init,   1, 1 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_I810_VERTEX)] = { i810_dma_vertex, 1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_I810_CLEAR)]  = { i810_clear_bufs, 1, 0 },
+      	[DRM_IOCTL_NR(DRM_IOCTL_I810_FLUSH)]  = { i810_flush_ioctl,1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_I810_GETAGE)] = { i810_getage,     1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_I810_GETBUF)] = { i810_getbuf,     1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_I810_SWAP)]   = { i810_swap_bufs,  1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_I810_COPY)]   = { i810_copybuf,    1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_I810_DOCOPY)] = { i810_docopy,     1, 0 },
+};
+
+#define I810_IOCTL_COUNT DRM_ARRAY_SIZE(i810_ioctls)
+
+#ifdef MODULE
+static char		      *i810 = NULL;
+#endif
+
+MODULE_AUTHOR("VA Linux Systems, Inc.");
+MODULE_DESCRIPTION("Intel I810");
+MODULE_PARM(i810, "s");
+
+#ifndef MODULE
+/* i810_options is called by the kernel to parse command-line options
+ * passed via the boot-loader (e.g., LILO).  It calls the insmod option
+ * routine, drm_parse_drm.
+ */
+
+static int __init i810_options(char *str)
+{
+	drm_parse_options(str);
+	return 1;
+}
+
+__setup("i810=", i810_options);
+#endif
+
+static int i810_setup(drm_device_t *dev)
+{
+	int i;
+
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
+	dev->buf_use	  = 0;
+	atomic_set(&dev->buf_alloc, 0);
+
+	drm_dma_setup(dev);
+
+	atomic_set(&dev->total_open, 0);
+	atomic_set(&dev->total_close, 0);
+	atomic_set(&dev->total_ioctl, 0);
+	atomic_set(&dev->total_irq, 0);
+	atomic_set(&dev->total_ctx, 0);
+	atomic_set(&dev->total_locks, 0);
+	atomic_set(&dev->total_unlocks, 0);
+	atomic_set(&dev->total_contends, 0);
+	atomic_set(&dev->total_sleeps, 0);
+
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		dev->magiclist[i].head = NULL;
+		dev->magiclist[i].tail = NULL;
+	}
+	dev->maplist	    = NULL;
+	dev->map_count	    = 0;
+	dev->vmalist	    = NULL;
+	dev->lock.hw_lock   = NULL;
+	init_waitqueue_head(&dev->lock.lock_queue);
+	dev->queue_count    = 0;
+	dev->queue_reserved = 0;
+	dev->queue_slots    = 0;
+	dev->queuelist	    = NULL;
+	dev->irq	    = 0;
+	dev->context_flag   = 0;
+	dev->interrupt_flag = 0;
+	dev->dma_flag	    = 0;
+	dev->last_context   = 0;
+	dev->last_switch    = 0;
+	dev->last_checked   = 0;
+	init_timer(&dev->timer);
+	init_waitqueue_head(&dev->context_wait);
+#if DRM_DMA_HISTO
+	memset(&dev->histo, 0, sizeof(dev->histo));
+#endif
+	dev->ctx_start	    = 0;
+	dev->lck_start	    = 0;
+
+	dev->buf_rp	  = dev->buf;
+	dev->buf_wp	  = dev->buf;
+	dev->buf_end	  = dev->buf + DRM_BSZ;
+	dev->buf_async	  = NULL;
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
+
+	DRM_DEBUG("\n");
+
+	/* The kernel's context could be created here, but is now created
+	   in drm_dma_enqueue.	This is more resource-efficient for
+	   hardware that does not do DMA, but may mean that
+	   drm_select_queue fails between the time the interrupt is
+	   initialized and the time the queues are initialized. */
+
+	return 0;
+}
+
+
+static int i810_takedown(drm_device_t *dev)
+{
+	int		  i;
+	drm_magic_entry_t *pt, *next;
+	drm_map_t	  *map;
+	drm_vma_entry_t	  *vma, *vma_next;
+
+	DRM_DEBUG("\n");
+
+	if (dev->irq) i810_irq_uninstall(dev);
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
+
+	if (dev->devname) {
+		drm_free(dev->devname, strlen(dev->devname)+1, DRM_MEM_DRIVER);
+		dev->devname = NULL;
+	}
+
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique)+1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
+				/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
+			next = pt->next;
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+		}
+		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
+	}
+   				/* Clear AGP information */
+	if (dev->agp) {
+		drm_agp_mem_t *entry;
+		drm_agp_mem_t *nexte;
+
+				/* Remove AGP resources, but leave dev->agp
+                                   intact until r128_cleanup is called. */
+		for (entry = dev->agp->memory; entry; entry = nexte) {
+			nexte = entry->next;
+			if (entry->bound) drm_unbind_agp(entry->memory);
+			drm_free_agp(entry->memory, entry->pages);
+			drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+		}
+		dev->agp->memory = NULL;
+
+		if (dev->agp->acquired) _drm_agp_release();
+
+		dev->agp->acquired = 0;
+		dev->agp->enabled  = 0;
+	}
+				/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
+			vma_next = vma->next;
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		}
+		dev->vmalist = NULL;
+	}
+
+				/* Clear map area and mtrr information */
+	if (dev->maplist) {
+		for (i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			switch (map->type) {
+			case _DRM_REGISTERS:
+			case _DRM_FRAME_BUFFER:
+#ifdef CONFIG_MTRR
+				if (map->mtrr >= 0) {
+					int retcode;
+					retcode = mtrr_del(map->mtrr,
+							   map->offset,
+							   map->size);
+					DRM_DEBUG("mtrr_del = %d\n", retcode);
+				}
+#endif
+				drm_ioremapfree(map->handle, map->size, dev);
+				break;
+			case _DRM_SHM:
+				drm_free_pages((unsigned long)map->handle,
+					       drm_order(map->size)
+					       - PAGE_SHIFT,
+					       DRM_MEM_SAREA);
+				break;
+			case _DRM_AGP:
+				break;
+			}
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		}
+		drm_free(dev->maplist,
+			 dev->map_count * sizeof(*dev->maplist),
+			 DRM_MEM_MAPS);
+		dev->maplist   = NULL;
+		dev->map_count = 0;
+	}
+
+	if (dev->queuelist) {
+		for (i = 0; i < dev->queue_count; i++) {
+			drm_waitlist_destroy(&dev->queuelist[i]->waitlist);
+			if (dev->queuelist[i]) {
+				drm_free(dev->queuelist[i],
+					 sizeof(*dev->queuelist[0]),
+					 DRM_MEM_QUEUES);
+				dev->queuelist[i] = NULL;
+			}
+		}
+		drm_free(dev->queuelist,
+			 dev->queue_slots * sizeof(*dev->queuelist),
+			 DRM_MEM_QUEUES);
+		dev->queuelist	 = NULL;
+	}
+
+	drm_dma_takedown(dev);
+
+	dev->queue_count     = 0;
+	if (dev->lock.hw_lock) {
+		dev->lock.hw_lock    = NULL; /* SHM removed */
+		dev->lock.pid	     = 0;
+		wake_up_interruptible(&dev->lock.lock_queue);
+	}
+	up(&dev->struct_sem);
+
+	return 0;
+}
+
+/* i810_init is called via init_module at module load time, or via
+ * linux/init/main.c (this is not currently supported). */
+
+static int __init i810_init(void)
+{
+	int		      retcode;
+	drm_device_t	      *dev = &i810_device;
+
+	DRM_DEBUG("\n");
+
+	memset((void *)dev, 0, sizeof(*dev));
+	dev->count_lock	  = SPIN_LOCK_UNLOCKED;
+	sema_init(&dev->struct_sem, 1);
+
+#ifdef MODULE
+	drm_parse_options(i810);
+#endif
+	DRM_DEBUG("doing misc_register\n");
+	if ((retcode = misc_register(&i810_misc))) {
+		DRM_ERROR("Cannot register \"%s\"\n", I810_NAME);
+		return retcode;
+	}
+	dev->device = MKDEV(MISC_MAJOR, i810_misc.minor);
+	dev->name   = I810_NAME;
+
+   	DRM_DEBUG("doing mem init\n");
+	drm_mem_init();
+	DRM_DEBUG("doing proc init\n");
+	drm_proc_init(dev);
+	DRM_DEBUG("doing agp init\n");
+	dev->agp    = drm_agp_init();
+   	if(dev->agp == NULL) {
+	   	DRM_INFO("The i810 drm module requires the agpgart module"
+			 " to function correctly\nPlease load the agpgart"
+			 " module before you load the i810 module\n");
+	   	drm_proc_cleanup();
+	   	misc_deregister(&i810_misc);
+	   	i810_takedown(dev);
+	   	return -ENOMEM;
+	}
+	DRM_DEBUG("doing ctxbitmap init\n");
+	if((retcode = drm_ctxbitmap_init(dev))) {
+		DRM_ERROR("Cannot allocate memory for context bitmap.\n");
+		drm_proc_cleanup();
+		misc_deregister(&i810_misc);
+		i810_takedown(dev);
+		return retcode;
+	}
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d\n",
+		 I810_NAME,
+		 I810_MAJOR,
+		 I810_MINOR,
+		 I810_PATCHLEVEL,
+		 I810_DATE,
+		 i810_misc.minor);
+
+	return 0;
+}
+
+/* i810_cleanup is called via cleanup_module at module unload time. */
+
+static void __exit i810_cleanup(void)
+{
+	drm_device_t	      *dev = &i810_device;
+
+	DRM_DEBUG("\n");
+
+	drm_proc_cleanup();
+	if (misc_deregister(&i810_misc)) {
+		DRM_ERROR("Cannot unload module\n");
+	} else {
+		DRM_INFO("Module unloaded\n");
+	}
+	drm_ctxbitmap_cleanup(dev);
+	i810_takedown(dev);
+	if (dev->agp) {
+		drm_agp_uninit();
+		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
+		dev->agp = NULL;
+	}
+}
+
+module_init(i810_init);
+module_exit(i810_cleanup);
+
+
+int i810_version(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_version_t version;
+	int	      len;
+
+	if (copy_from_user(&version,
+			   (drm_version_t *)arg,
+			   sizeof(version)))
+		return -EFAULT;
+
+#define DRM_COPY(name,value)				     \
+	len = strlen(value);				     \
+	if (len > name##_len) len = name##_len;		     \
+	name##_len = strlen(value);			     \
+	if (len && name) {				     \
+		if (copy_to_user(name, value, len))          \
+			return -EFAULT;			     \
+	}
+
+	version.version_major	   = I810_MAJOR;
+	version.version_minor	   = I810_MINOR;
+	version.version_patchlevel = I810_PATCHLEVEL;
+
+	DRM_COPY(version.name, I810_NAME);
+	DRM_COPY(version.date, I810_DATE);
+	DRM_COPY(version.desc, I810_DESC);
+
+	if (copy_to_user((drm_version_t *)arg,
+			 &version,
+			 sizeof(version)))
+		return -EFAULT;
+	return 0;
+}
+
+int i810_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t  *dev    = &i810_device;
+	int	      retcode = 0;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_open_helper(inode, filp, dev))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_INC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_open);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return i810_setup(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+	return retcode;
+}
+
+int i810_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev;
+	int	      retcode = 0;
+
+	lock_kernel();
+	dev    = priv->dev;
+	DRM_DEBUG("pid = %d, device = 0x%x, open_count = %d\n",
+		  current->pid, dev->device, dev->open_count);
+
+	if (dev->lock.hw_lock && _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)
+	    && dev->lock.pid == current->pid) {
+	      	i810_reclaim_buffers(dev, priv->pid);
+		DRM_ERROR("Process %d dead, freeing lock for context %d\n",
+			  current->pid,
+			  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+		drm_lock_free(dev,
+			      &dev->lock.hw_lock->lock,
+			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+
+				/* FIXME: may require heavy-handed reset of
+                                   hardware at this point, possibly
+                                   processed via a callback to the X
+                                   server. */
+	} else if (dev->lock.hw_lock) {
+	   	/* The lock is required to reclaim buffers */
+	   	DECLARE_WAITQUEUE(entry, current);
+	   	add_wait_queue(&dev->lock.lock_queue, &entry);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!dev->lock.hw_lock) {
+				/* Device has been unregistered */
+				retcode = -EINTR;
+				break;
+			}
+			if (drm_lock_take(&dev->lock.hw_lock->lock,
+					  DRM_KERNEL_CONTEXT)) {
+				dev->lock.pid	    = priv->pid;
+				dev->lock.lock_time = jiffies;
+				atomic_inc(&dev->total_locks);
+				break;	/* Got lock */
+			}
+				/* Contention */
+			atomic_inc(&dev->total_sleeps);
+			schedule();
+			if (signal_pending(current)) {
+				retcode = -ERESTARTSYS;
+				break;
+			}
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&dev->lock.lock_queue, &entry);
+	   	if(!retcode) {
+		   	i810_reclaim_buffers(dev, priv->pid);
+		   	drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				      DRM_KERNEL_CONTEXT);
+		}
+	}
+	drm_fasync(-1, filp, 0);
+
+	down(&dev->struct_sem);
+	if (priv->prev) priv->prev->next = priv->next;
+	else		dev->file_first	 = priv->next;
+	if (priv->next) priv->next->prev = priv->prev;
+	else		dev->file_last	 = priv->prev;
+	up(&dev->struct_sem);
+
+	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
+#if LINUX_VERSION_CODE < 0x020333
+	MOD_DEC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+   	atomic_inc(&dev->total_close);
+   	spin_lock(&dev->count_lock);
+   	if (!--dev->open_count) {
+	   	if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+		   	DRM_ERROR("Device busy: %d %d\n",
+				  atomic_read(&dev->ioctl_count),
+				  dev->blocked);
+		   	spin_unlock(&dev->count_lock);
+			unlock_kernel();
+		   	return -EBUSY;
+		}
+	   	spin_unlock(&dev->count_lock);
+		unlock_kernel();
+		return i810_takedown(dev);
+	}
+	spin_unlock(&dev->count_lock);
+	unlock_kernel();
+	return retcode;
+}
+
+/* drm_ioctl is called whenever a process performs an ioctl on /dev/drm. */
+
+int i810_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	int		 nr	 = DRM_IOCTL_NR(cmd);
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	int		 retcode = 0;
+	drm_ioctl_desc_t *ioctl;
+	drm_ioctl_t	 *func;
+
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->total_ioctl);
+	++priv->ioctl_count;
+
+	DRM_DEBUG("pid = %d, cmd = 0x%02x, nr = 0x%02x, dev 0x%x, auth = %d\n",
+		  current->pid, cmd, nr, dev->device, priv->authenticated);
+
+	if (nr >= I810_IOCTL_COUNT) {
+		retcode = -EINVAL;
+	} else {
+		ioctl	  = &i810_ioctls[nr];
+		func	  = ioctl->func;
+
+		if (!func) {
+			DRM_DEBUG("no function\n");
+			retcode = -EINVAL;
+		} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN))
+			    || (ioctl->auth_needed && !priv->authenticated)) {
+			retcode = -EACCES;
+		} else {
+			retcode = (func)(inode, filp, cmd, arg);
+		}
+	}
+
+	atomic_dec(&dev->ioctl_count);
+	return retcode;
+}
+
+int i810_unlock(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d frees lock (%d holds)\n",
+		  lock.context,
+		  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	atomic_inc(&dev->total_unlocks);
+	if (_DRM_LOCK_IS_CONT(dev->lock.hw_lock->lock))
+		atomic_inc(&dev->total_contends);
+   	drm_lock_transfer(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
+	if (!dev->context_flag) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+#if DRM_DMA_HISTOGRAM
+	atomic_inc(&dev->histo.lhld[drm_histogram_slot(get_cycles()
+						       - dev->lck_start)]);
+#endif
+
+	unblock_all_signals();
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/i810_drv.h linux/drivers/char/drm-4.0/i810_drv.h
--- linux.orig/drivers/char/drm-4.0/i810_drv.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/i810_drv.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,225 @@
+/* i810_drv.h -- Private header for the Matrox g200/g400 driver -*- linux-c -*-
+ * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ * 	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#ifndef _I810_DRV_H_
+#define _I810_DRV_H_
+
+typedef struct drm_i810_buf_priv {
+   	u32 *in_use;
+   	int my_use_idx;
+	int currently_mapped;
+	void *virtual;
+	void *kernel_virtual;
+	int map_count;
+   	struct vm_area_struct *vma;
+} drm_i810_buf_priv_t;
+
+typedef struct _drm_i810_ring_buffer{
+	int tail_mask;
+	unsigned long Start;
+	unsigned long End;
+	unsigned long Size;
+	u8 *virtual_start;
+	int head;
+	int tail;
+	int space;
+} drm_i810_ring_buffer_t;
+
+typedef struct drm_i810_private {
+   	int ring_map_idx;
+   	int buffer_map_idx;
+
+   	drm_i810_ring_buffer_t ring;
+	drm_i810_sarea_t *sarea_priv;
+
+      	unsigned long hw_status_page;
+   	unsigned long counter;
+
+   	atomic_t flush_done;
+   	wait_queue_head_t flush_queue;	/* Processes waiting until flush    */
+	drm_buf_t *mmap_buffer;
+
+	
+	u32 front_di1, back_di1, zi1;
+	
+	int back_offset;
+	int depth_offset;
+	int w, h;
+	int pitch;
+} drm_i810_private_t;
+
+				/* i810_drv.c */
+extern int  i810_version(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  i810_open(struct inode *inode, struct file *filp);
+extern int  i810_release(struct inode *inode, struct file *filp);
+extern int  i810_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  i810_unlock(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+
+				/* i810_dma.c */
+extern int  i810_dma_schedule(drm_device_t *dev, int locked);
+extern int  i810_getbuf(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  i810_irq_install(drm_device_t *dev, int irq);
+extern int  i810_irq_uninstall(drm_device_t *dev);
+extern int  i810_control(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  i810_lock(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  i810_dma_init(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  i810_flush_ioctl(struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg);
+extern void i810_reclaim_buffers(drm_device_t *dev, pid_t pid);
+extern int  i810_getage(struct inode *inode, struct file *filp, unsigned int cmd,
+			unsigned long arg);
+extern int i810_mmap_buffers(struct file *filp, struct vm_area_struct *vma);
+extern int i810_copybuf(struct inode *inode, struct file *filp, 
+			unsigned int cmd, unsigned long arg);
+extern int i810_docopy(struct inode *inode, struct file *filp, 
+		       unsigned int cmd, unsigned long arg);
+
+				/* i810_bufs.c */
+extern int  i810_addbufs(struct inode *inode, struct file *filp, 
+			unsigned int cmd, unsigned long arg);
+extern int  i810_infobufs(struct inode *inode, struct file *filp, 
+			 unsigned int cmd, unsigned long arg);
+extern int  i810_markbufs(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int  i810_freebufs(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int  i810_addmap(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+
+				/* i810_context.c */
+extern int  i810_resctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  i810_addctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  i810_modctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  i810_getctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  i810_switchctx(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  i810_newctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  i810_rmctx(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+
+extern int  i810_context_switch(drm_device_t *dev, int old, int new);
+extern int  i810_context_switch_complete(drm_device_t *dev, int new);
+
+#define I810_VERBOSE 0
+
+
+int i810_dma_vertex(struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg);
+
+int i810_swap_bufs(struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg);
+
+int i810_clear_bufs(struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg);
+
+#define GFX_OP_USER_INTERRUPT 		((0<<29)|(2<<23))
+#define GFX_OP_BREAKPOINT_INTERRUPT	((0<<29)|(1<<23))
+#define CMD_REPORT_HEAD			(7<<23)
+#define CMD_STORE_DWORD_IDX		((0x21<<23) | 0x1)
+#define CMD_OP_BATCH_BUFFER  ((0x0<<29)|(0x30<<23)|0x1)
+
+#define INST_PARSER_CLIENT   0x00000000
+#define INST_OP_FLUSH        0x02000000
+#define INST_FLUSH_MAP_CACHE 0x00000001
+
+
+#define BB1_START_ADDR_MASK   (~0x7)
+#define BB1_PROTECTED         (1<<0)
+#define BB1_UNPROTECTED       (0<<0)
+#define BB2_END_ADDR_MASK     (~0x7)
+
+#define I810REG_HWSTAM		0x02098
+#define I810REG_INT_IDENTITY_R	0x020a4
+#define I810REG_INT_MASK_R 	0x020a8
+#define I810REG_INT_ENABLE_R	0x020a0
+
+#define LP_RING     		0x2030
+#define HP_RING     		0x2040
+#define RING_TAIL      		0x00
+#define TAIL_ADDR		0x000FFFF8
+#define RING_HEAD      		0x04
+#define HEAD_WRAP_COUNT     	0xFFE00000
+#define HEAD_WRAP_ONE       	0x00200000
+#define HEAD_ADDR           	0x001FFFFC
+#define RING_START     		0x08
+#define START_ADDR          	0x00FFFFF8
+#define RING_LEN       		0x0C
+#define RING_NR_PAGES       	0x000FF000 
+#define RING_REPORT_MASK    	0x00000006
+#define RING_REPORT_64K     	0x00000002
+#define RING_REPORT_128K    	0x00000004
+#define RING_NO_REPORT      	0x00000000
+#define RING_VALID_MASK     	0x00000001
+#define RING_VALID          	0x00000001
+#define RING_INVALID        	0x00000000
+
+#define GFX_OP_SCISSOR         ((0x3<<29)|(0x1c<<24)|(0x10<<19))
+#define SC_UPDATE_SCISSOR       (0x1<<1)
+#define SC_ENABLE_MASK          (0x1<<0)
+#define SC_ENABLE               (0x1<<0)
+
+#define GFX_OP_SCISSOR_INFO    ((0x3<<29)|(0x1d<<24)|(0x81<<16)|(0x1))
+#define SCI_YMIN_MASK      (0xffff<<16)
+#define SCI_XMIN_MASK      (0xffff<<0)
+#define SCI_YMAX_MASK      (0xffff<<16)
+#define SCI_XMAX_MASK      (0xffff<<0)
+
+#define GFX_OP_COLOR_FACTOR      ((0x3<<29)|(0x1d<<24)|(0x1<<16)|0x0)
+#define GFX_OP_STIPPLE           ((0x3<<29)|(0x1d<<24)|(0x83<<16))
+#define GFX_OP_MAP_INFO          ((0x3<<29)|(0x1d<<24)|0x2)
+#define GFX_OP_DESTBUFFER_VARS   ((0x3<<29)|(0x1d<<24)|(0x85<<16)|0x0)
+#define GFX_OP_DRAWRECT_INFO     ((0x3<<29)|(0x1d<<24)|(0x80<<16)|(0x3))
+#define GFX_OP_PRIMITIVE         ((0x3<<29)|(0x1f<<24))
+
+#define CMD_OP_Z_BUFFER_INFO     ((0x0<<29)|(0x16<<23))
+#define CMD_OP_DESTBUFFER_INFO   ((0x0<<29)|(0x15<<23))
+
+#define BR00_BITBLT_CLIENT   0x40000000
+#define BR00_OP_COLOR_BLT    0x10000000
+#define BR00_OP_SRC_COPY_BLT 0x10C00000
+#define BR13_SOLID_PATTERN   0x80000000
+
+
+
+#endif
+
diff -urN linux.orig/drivers/char/drm-4.0/init.c linux/drivers/char/drm-4.0/init.c
--- linux.orig/drivers/char/drm-4.0/init.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/init.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,113 @@
+/* init.c -- Setup/Cleanup for DRM -*- linux-c -*-
+ * Created: Mon Jan  4 08:58:31 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+int			      drm_flags		= 0;
+
+/* drm_parse_option parses a single option.  See description for
+   drm_parse_options for details. */
+
+static void drm_parse_option(char *s)
+{
+	char *c, *r;
+	
+	DRM_DEBUG("\"%s\"\n", s);
+	if (!s || !*s) return;
+	for (c = s; *c && *c != ':'; c++); /* find : or \0 */
+	if (*c) r = c + 1; else r = NULL;  /* remember remainder */
+	*c = '\0';			   /* terminate */
+	if (!strcmp(s, "noctx")) {
+		drm_flags |= DRM_FLAG_NOCTX;
+		DRM_INFO("Server-mediated context switching OFF\n");
+		return;
+	}
+	if (!strcmp(s, "debug")) {
+		drm_flags |= DRM_FLAG_DEBUG;
+		DRM_INFO("Debug messages ON\n");
+		return;
+	}
+	DRM_ERROR("\"%s\" is not a valid option\n", s);
+	return;
+}
+
+/* drm_parse_options parse the insmod "drm=" options, or the command-line
+ * options passed to the kernel via LILO.  The grammar of the format is as
+ * follows:
+ *
+ * drm		::= 'drm=' option_list
+ * option_list	::= option [ ';' option_list ]
+ * option	::= 'device:' major
+ *		|   'debug' 
+ *		|   'noctx'
+ * major	::= INTEGER
+ *
+ * Note that 's' contains option_list without the 'drm=' part.
+ *
+ * device=major,minor specifies the device number used for /dev/drm
+ *	  if major == 0 then the misc device is used
+ *	  if major == 0 and minor == 0 then dynamic misc allocation is used
+ * debug=on specifies that debugging messages will be printk'd
+ * debug=trace specifies that each function call will be logged via printk
+ * debug=off turns off all debugging options
+ *
+ */
+
+void drm_parse_options(char *s)
+{
+	char *h, *t, *n;
+	
+	DRM_DEBUG("\"%s\"\n", s ?: "");
+	if (!s || !*s) return;
+
+	for (h = t = n = s; h && *h; h = n) {
+		for (; *t && *t != ';'; t++);	       /* find ; or \0 */
+		if (*t) n = t + 1; else n = NULL;      /* remember next */
+		*t = '\0';			       /* terminate */
+		drm_parse_option(h);		       /* parse */
+	}
+}
+
+/* drm_cpu_valid returns non-zero if the DRI will run on this CPU, and 0
+ * otherwise. */
+
+int drm_cpu_valid(void)
+{
+#if defined(__i386__)
+	if (boot_cpu_data.x86 == 3) return 0; /* No cmpxchg on a 386 */
+#endif
+#if defined(__sparc__) && !defined(__sparc_v9__)
+	if (1)
+		return 0; /* No cmpxchg before v9 sparc. */
+#endif
+	return 1;
+}
diff -urN linux.orig/drivers/char/drm-4.0/ioctl.c linux/drivers/char/drm-4.0/ioctl.c
--- linux.orig/drivers/char/drm-4.0/ioctl.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/ioctl.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,99 @@
+/* ioctl.c -- IOCTL processing for DRM -*- linux-c -*-
+ * Created: Fri Jan  8 09:01:26 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+int drm_irq_busid(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_irq_busid_t p;
+	struct pci_dev	*dev;
+
+	if (copy_from_user(&p, (drm_irq_busid_t *)arg, sizeof(p)))
+		return -EFAULT;
+	dev = pci_find_slot(p.busnum, PCI_DEVFN(p.devnum, p.funcnum));
+	if (dev) p.irq = dev->irq;
+	else	 p.irq = 0;
+	DRM_DEBUG("%d:%d:%d => IRQ %d\n",
+		  p.busnum, p.devnum, p.funcnum, p.irq);
+	if (copy_to_user((drm_irq_busid_t *)arg, &p, sizeof(p)))
+		return -EFAULT;
+	return 0;
+}
+
+int drm_getunique(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_unique_t	 u;
+
+	if (copy_from_user(&u, (drm_unique_t *)arg, sizeof(u)))
+		return -EFAULT;
+	if (u.unique_len >= dev->unique_len) {
+		if (copy_to_user(u.unique, dev->unique, dev->unique_len))
+			return -EFAULT;
+	}
+	u.unique_len = dev->unique_len;
+	if (copy_to_user((drm_unique_t *)arg, &u, sizeof(u)))
+		return -EFAULT;
+	return 0;
+}
+
+int drm_setunique(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_unique_t	 u;
+
+	if (dev->unique_len || dev->unique)
+		return -EBUSY;
+
+	if (copy_from_user(&u, (drm_unique_t *)arg, sizeof(u)))
+		return -EFAULT;
+
+	if (!u.unique_len || u.unique_len > 1024)
+		return -EINVAL;
+	
+	dev->unique_len = u.unique_len;
+	dev->unique	= drm_alloc(u.unique_len + 1, DRM_MEM_DRIVER);
+	if (copy_from_user(dev->unique, u.unique, dev->unique_len))
+		return -EFAULT;
+	dev->unique[dev->unique_len] = '\0';
+
+	dev->devname = drm_alloc(strlen(dev->name) + strlen(dev->unique) + 2,
+				 DRM_MEM_DRIVER);
+	sprintf(dev->devname, "%s@%s", dev->name, dev->unique);
+
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/lists.c linux/drivers/char/drm-4.0/lists.c
--- linux.orig/drivers/char/drm-4.0/lists.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/lists.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,218 @@
+/* lists.c -- Buffer list handling routines -*- linux-c -*-
+ * Created: Mon Apr 19 20:54:22 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+int drm_waitlist_create(drm_waitlist_t *bl, int count)
+{
+	if (bl->count) return -EINVAL;
+	
+	bl->count      = count;
+	bl->bufs       = drm_alloc((bl->count + 2) * sizeof(*bl->bufs),
+				   DRM_MEM_BUFLISTS);
+	bl->rp	       = bl->bufs;
+	bl->wp	       = bl->bufs;
+	bl->end	       = &bl->bufs[bl->count+1];
+	bl->write_lock = SPIN_LOCK_UNLOCKED;
+	bl->read_lock  = SPIN_LOCK_UNLOCKED;
+	return 0;
+}
+
+int drm_waitlist_destroy(drm_waitlist_t *bl)
+{
+	if (bl->rp != bl->wp) return -EINVAL;
+	if (bl->bufs) drm_free(bl->bufs,
+			       (bl->count + 2) * sizeof(*bl->bufs),
+			       DRM_MEM_BUFLISTS);
+	bl->count = 0;
+	bl->bufs  = NULL;
+	bl->rp	  = NULL;
+	bl->wp	  = NULL;
+	bl->end	  = NULL;
+	return 0;
+}
+
+int drm_waitlist_put(drm_waitlist_t *bl, drm_buf_t *buf)
+{							
+	int	      left;
+	unsigned long flags;
+
+	left = DRM_LEFTCOUNT(bl);
+	if (!left) {
+		DRM_ERROR("Overflow while adding buffer %d from pid %d\n",
+			  buf->idx, buf->pid);
+		return -EINVAL;
+	}
+#if DRM_DMA_HISTOGRAM
+	buf->time_queued = get_cycles();
+#endif
+	buf->list	 = DRM_LIST_WAIT;
+	
+	spin_lock_irqsave(&bl->write_lock, flags);
+	*bl->wp = buf;
+	if (++bl->wp >= bl->end) bl->wp = bl->bufs;
+	spin_unlock_irqrestore(&bl->write_lock, flags);
+	
+	return 0;
+}
+
+drm_buf_t *drm_waitlist_get(drm_waitlist_t *bl)
+{
+	drm_buf_t     *buf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&bl->read_lock, flags);
+	buf = *bl->rp;
+	if (bl->rp == bl->wp) {
+		spin_unlock_irqrestore(&bl->read_lock, flags);
+		return NULL;
+	}				     
+	if (++bl->rp >= bl->end) bl->rp = bl->bufs;
+	spin_unlock_irqrestore(&bl->read_lock, flags);
+	
+	return buf;
+}
+
+int drm_freelist_create(drm_freelist_t *bl, int count)
+{
+	atomic_set(&bl->count, 0);
+	bl->next      = NULL;
+	init_waitqueue_head(&bl->waiting);
+	bl->low_mark  = 0;
+	bl->high_mark = 0;
+	atomic_set(&bl->wfh,   0);
+	bl->lock      = SPIN_LOCK_UNLOCKED;
+	++bl->initialized;
+	return 0;
+}
+
+int drm_freelist_destroy(drm_freelist_t *bl)
+{
+	atomic_set(&bl->count, 0);
+	bl->next = NULL;
+	return 0;
+}
+
+int drm_freelist_put(drm_device_t *dev, drm_freelist_t *bl, drm_buf_t *buf)
+{
+	drm_device_dma_t *dma  = dev->dma;
+
+	if (!dma) {
+		DRM_ERROR("No DMA support\n");
+		return 1;
+	}
+
+	if (buf->waiting || buf->pending || buf->list == DRM_LIST_FREE) {
+		DRM_ERROR("Freed buffer %d: w%d, p%d, l%d\n",
+			  buf->idx, buf->waiting, buf->pending, buf->list);
+	}
+	if (!bl) return 1;
+#if DRM_DMA_HISTOGRAM
+	buf->time_freed = get_cycles();
+	drm_histogram_compute(dev, buf);
+#endif
+	buf->list	= DRM_LIST_FREE;
+	
+	spin_lock(&bl->lock);
+	buf->next	= bl->next;
+	bl->next	= buf;
+	spin_unlock(&bl->lock);
+	
+	atomic_inc(&bl->count);
+	if (atomic_read(&bl->count) > dma->buf_count) {
+		DRM_ERROR("%d of %d buffers free after addition of %d\n",
+			  atomic_read(&bl->count), dma->buf_count, buf->idx);
+		return 1;
+	}
+				/* Check for high water mark */
+	if (atomic_read(&bl->wfh) && atomic_read(&bl->count)>=bl->high_mark) {
+		atomic_set(&bl->wfh, 0);
+		wake_up_interruptible(&bl->waiting);
+	}
+	return 0;
+}
+
+static drm_buf_t *drm_freelist_try(drm_freelist_t *bl)
+{
+	drm_buf_t	  *buf;
+
+	if (!bl) return NULL;
+	
+				/* Get buffer */
+	spin_lock(&bl->lock);
+	if (!bl->next) {
+		spin_unlock(&bl->lock);
+		return NULL;
+	}
+	buf	  = bl->next;
+	bl->next  = bl->next->next;
+	spin_unlock(&bl->lock);
+	
+	atomic_dec(&bl->count);
+	buf->next = NULL;
+	buf->list = DRM_LIST_NONE;
+	if (buf->waiting || buf->pending) {
+		DRM_ERROR("Free buffer %d: w%d, p%d, l%d\n",
+			  buf->idx, buf->waiting, buf->pending, buf->list);
+	}
+	
+	return buf;
+}
+
+drm_buf_t *drm_freelist_get(drm_freelist_t *bl, int block)
+{
+	drm_buf_t	  *buf	= NULL;
+	DECLARE_WAITQUEUE(entry, current);
+
+	if (!bl || !bl->initialized) return NULL;
+	
+				/* Check for low water mark */
+	if (atomic_read(&bl->count) <= bl->low_mark) /* Became low */
+		atomic_set(&bl->wfh, 1);
+	if (atomic_read(&bl->wfh)) {
+		if (block) {
+			add_wait_queue(&bl->waiting, &entry);
+			for (;;) {
+				current->state = TASK_INTERRUPTIBLE;
+				if (!atomic_read(&bl->wfh)
+				    && (buf = drm_freelist_try(bl))) break;
+				schedule();
+				if (signal_pending(current)) break;
+			}
+			current->state = TASK_RUNNING;
+			remove_wait_queue(&bl->waiting, &entry);
+		}
+		return buf;
+	}
+		
+	return drm_freelist_try(bl);
+}
diff -urN linux.orig/drivers/char/drm-4.0/lock.c linux/drivers/char/drm-4.0/lock.c
--- linux.orig/drivers/char/drm-4.0/lock.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/lock.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,252 @@
+/* lock.c -- IOCTLs for locking -*- linux-c -*-
+ * Created: Tue Feb  2 08:37:54 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+int drm_block(struct inode *inode, struct file *filp, unsigned int cmd,
+	      unsigned long arg)
+{
+	DRM_DEBUG("\n");
+	return 0;
+}
+
+int drm_unblock(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	DRM_DEBUG("\n");
+	return 0;
+}
+
+int drm_lock_take(__volatile__ unsigned int *lock, unsigned int context)
+{
+	unsigned int old, new, prev;
+
+	do {
+		old = *lock;
+		if (old & _DRM_LOCK_HELD) new = old | _DRM_LOCK_CONT;
+		else			  new = context | _DRM_LOCK_HELD;
+		prev = cmpxchg(lock, old, new);
+	} while (prev != old);
+	if (_DRM_LOCKING_CONTEXT(old) == context) {
+		if (old & _DRM_LOCK_HELD) {
+			if (context != DRM_KERNEL_CONTEXT) {
+				DRM_ERROR("%d holds heavyweight lock\n",
+					  context);
+			}
+			return 0;
+		}
+	}
+	if (new == (context | _DRM_LOCK_HELD)) {
+				/* Have lock */
+		return 1;
+	}
+	return 0;
+}
+
+/* This takes a lock forcibly and hands it to context.	Should ONLY be used
+   inside *_unlock to give lock to kernel before calling *_dma_schedule. */
+int drm_lock_transfer(drm_device_t *dev,
+		      __volatile__ unsigned int *lock, unsigned int context)
+{
+	unsigned int old, new, prev;
+
+	dev->lock.pid = 0;
+	do {
+		old  = *lock;
+		new  = context | _DRM_LOCK_HELD;
+		prev = cmpxchg(lock, old, new);
+	} while (prev != old);
+	return 1;
+}
+
+int drm_lock_free(drm_device_t *dev,
+		  __volatile__ unsigned int *lock, unsigned int context)
+{
+	unsigned int old, new, prev;
+	pid_t        pid = dev->lock.pid;
+
+	dev->lock.pid = 0;
+	do {
+		old  = *lock;
+		new  = 0;
+		prev = cmpxchg(lock, old, new);
+	} while (prev != old);
+	if (_DRM_LOCK_IS_HELD(old) && _DRM_LOCKING_CONTEXT(old) != context) {
+		DRM_ERROR("%d freed heavyweight lock held by %d (pid %d)\n",
+			  context,
+			  _DRM_LOCKING_CONTEXT(old),
+			  pid);
+		return 1;
+	}
+	wake_up_interruptible(&dev->lock.lock_queue);
+	return 0;
+}
+
+static int drm_flush_queue(drm_device_t *dev, int context)
+{
+	DECLARE_WAITQUEUE(entry, current);
+	int		  ret	= 0;
+	drm_queue_t	  *q	= dev->queuelist[context];
+	
+	DRM_DEBUG("\n");
+	
+	atomic_inc(&q->use_count);
+	if (atomic_read(&q->use_count) > 1) {
+		atomic_inc(&q->block_write);
+		add_wait_queue(&q->flush_queue, &entry);
+		atomic_inc(&q->block_count);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!DRM_BUFCOUNT(&q->waitlist)) break;
+			schedule();
+			if (signal_pending(current)) {
+				ret = -EINTR; /* Can't restart */
+				break;
+			}
+		}
+		atomic_dec(&q->block_count);
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&q->flush_queue, &entry);
+	}
+	atomic_dec(&q->use_count);
+	atomic_inc(&q->total_flushed);
+		
+				/* NOTE: block_write is still incremented!
+				   Use drm_flush_unlock_queue to decrement. */
+	return ret;
+}
+
+static int drm_flush_unblock_queue(drm_device_t *dev, int context)
+{
+	drm_queue_t	  *q	= dev->queuelist[context];
+	
+	DRM_DEBUG("\n");
+	
+	atomic_inc(&q->use_count);
+	if (atomic_read(&q->use_count) > 1) {
+		if (atomic_read(&q->block_write)) {
+			atomic_dec(&q->block_write);
+			wake_up_interruptible(&q->write_queue);
+		}
+	}
+	atomic_dec(&q->use_count);
+	return 0;
+}
+
+int drm_flush_block_and_flush(drm_device_t *dev, int context,
+			      drm_lock_flags_t flags)
+{
+	int ret = 0;
+	int i;
+	
+	DRM_DEBUG("\n");
+	
+	if (flags & _DRM_LOCK_FLUSH) {
+		ret = drm_flush_queue(dev, DRM_KERNEL_CONTEXT);
+		if (!ret) ret = drm_flush_queue(dev, context);
+	}
+	if (flags & _DRM_LOCK_FLUSH_ALL) {
+		for (i = 0; !ret && i < dev->queue_count; i++) {
+			ret = drm_flush_queue(dev, i);
+		}
+	}
+	return ret;
+}
+
+int drm_flush_unblock(drm_device_t *dev, int context, drm_lock_flags_t flags)
+{
+	int ret = 0;
+	int i;
+	
+	DRM_DEBUG("\n");
+	
+	if (flags & _DRM_LOCK_FLUSH) {
+		ret = drm_flush_unblock_queue(dev, DRM_KERNEL_CONTEXT);
+		if (!ret) ret = drm_flush_unblock_queue(dev, context);
+	}
+	if (flags & _DRM_LOCK_FLUSH_ALL) {
+		for (i = 0; !ret && i < dev->queue_count; i++) {
+			ret = drm_flush_unblock_queue(dev, i);
+		}
+	}
+		
+	return ret;
+}
+
+int drm_finish(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	int		  ret	  = 0;
+	drm_lock_t	  lock;
+
+	DRM_DEBUG("\n");
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+	ret = drm_flush_block_and_flush(dev, lock.context, lock.flags);
+	drm_flush_unblock(dev, lock.context, lock.flags);
+	return ret;
+}
+
+/* If we get here, it means that the process has called DRM_IOCTL_LOCK
+   without calling DRM_IOCTL_UNLOCK.
+   
+   If the lock is not held, then let the signal proceed as usual.
+   
+   If the lock is held, then set the contended flag and keep the signal
+   blocked.
+   
+
+   Return 1 if the signal should be delivered normally.
+   Return 0 if the signal should be blocked.  */
+
+int drm_notifier(void *priv)
+{
+	drm_sigdata_t *s = (drm_sigdata_t *)priv;
+	unsigned int  old, new, prev;
+
+
+				/* Allow signal delivery if lock isn't held */
+	if (!_DRM_LOCK_IS_HELD(s->lock->lock)
+	    || _DRM_LOCKING_CONTEXT(s->lock->lock) != s->context) return 1;
+	
+				/* Otherwise, set flag to force call to
+                                   drmUnlock */
+	do {
+		old  = s->lock->lock;
+		new  = old | _DRM_LOCK_CONT;
+		prev = cmpxchg(&s->lock->lock, old, new);
+	} while (prev != old);
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/memory.c linux/drivers/char/drm-4.0/memory.c
--- linux.orig/drivers/char/drm-4.0/memory.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/memory.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,486 @@
+/* memory.c -- Memory management wrappers for DRM -*- linux-c -*-
+ * Created: Thu Feb  4 14:00:34 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include <linux/config.h>
+#include "drmP.h"
+#include <linux/wrapper.h>
+
+typedef struct drm_mem_stats {
+	const char	  *name;
+	int		  succeed_count;
+	int		  free_count;
+	int		  fail_count;
+	unsigned long	  bytes_allocated;
+	unsigned long	  bytes_freed;
+} drm_mem_stats_t;
+
+static spinlock_t	  drm_mem_lock	    = SPIN_LOCK_UNLOCKED;
+static unsigned long	  drm_ram_available = 0; /* In pages */
+static unsigned long	  drm_ram_used	    = 0;
+static drm_mem_stats_t	  drm_mem_stats[]   = {
+	[DRM_MEM_DMA]	    = { "dmabufs"  },
+	[DRM_MEM_SAREA]	    = { "sareas"   },
+	[DRM_MEM_DRIVER]    = { "driver"   },
+	[DRM_MEM_MAGIC]	    = { "magic"	   },
+	[DRM_MEM_IOCTLS]    = { "ioctltab" },
+	[DRM_MEM_MAPS]	    = { "maplist"  },
+	[DRM_MEM_VMAS]	    = { "vmalist"  },
+	[DRM_MEM_BUFS]	    = { "buflist"  },
+	[DRM_MEM_SEGS]	    = { "seglist"  },
+	[DRM_MEM_PAGES]	    = { "pagelist" },
+	[DRM_MEM_FILES]	    = { "files"	   },
+	[DRM_MEM_QUEUES]    = { "queues"   },
+	[DRM_MEM_CMDS]	    = { "commands" },
+	[DRM_MEM_MAPPINGS]  = { "mappings" },
+	[DRM_MEM_BUFLISTS]  = { "buflists" },
+	[DRM_MEM_AGPLISTS]  = { "agplist"  },
+	[DRM_MEM_TOTALAGP]  = { "totalagp" },
+	[DRM_MEM_BOUNDAGP]  = { "boundagp" },
+	[DRM_MEM_CTXBITMAP] = { "ctxbitmap"},
+	{ NULL, 0, }		/* Last entry must be null */
+};
+
+void drm_mem_init(void)
+{
+	drm_mem_stats_t *mem;
+	struct sysinfo	si;
+	
+	for (mem = drm_mem_stats; mem->name; ++mem) {
+		mem->succeed_count   = 0;
+		mem->free_count	     = 0;
+		mem->fail_count	     = 0;
+		mem->bytes_allocated = 0;
+		mem->bytes_freed     = 0;
+	}
+	
+	si_meminfo(&si);
+#if LINUX_VERSION_CODE < 0x020317
+				/* Changed to page count in 2.3.23 */
+	drm_ram_available = si.totalram >> PAGE_SHIFT;
+#else
+	drm_ram_available = si.totalram;
+#endif
+	drm_ram_used	  = 0;
+}
+
+/* drm_mem_info is called whenever a process reads /dev/drm/mem. */
+
+static int _drm_mem_info(char *buf, char **start, off_t offset, int len,
+			 int *eof, void *data)
+{
+	drm_mem_stats_t *pt;
+
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+	DRM_PROC_PRINT("		  total counts			"
+		       " |    outstanding  \n");
+	DRM_PROC_PRINT("type	   alloc freed fail	bytes	   freed"
+		       " | allocs      bytes\n\n");
+	DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu kB         |\n",
+		       "system", 0, 0, 0,
+		       drm_ram_available << (PAGE_SHIFT - 10));
+	DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu kB         |\n",
+		       "locked", 0, 0, 0, drm_ram_used >> 10);
+	DRM_PROC_PRINT("\n");
+	for (pt = drm_mem_stats; pt->name; pt++) {
+		DRM_PROC_PRINT("%-9.9s %5d %5d %4d %10lu %10lu | %6d %10ld\n",
+			       pt->name,
+			       pt->succeed_count,
+			       pt->free_count,
+			       pt->fail_count,
+			       pt->bytes_allocated,
+			       pt->bytes_freed,
+			       pt->succeed_count - pt->free_count,
+			       (long)pt->bytes_allocated
+			       - (long)pt->bytes_freed);
+	}
+	
+	return len;
+}
+
+int drm_mem_info(char *buf, char **start, off_t offset, int len,
+		 int *eof, void *data)
+{
+	int ret;
+	
+	spin_lock(&drm_mem_lock);
+	ret = _drm_mem_info(buf, start, offset, len, eof, data);
+	spin_unlock(&drm_mem_lock);
+	return ret;
+}
+
+void *drm_alloc(size_t size, int area)
+{
+	void *pt;
+	
+	if (!size) {
+		DRM_MEM_ERROR(area, "Allocating 0 bytes\n");
+		return NULL;
+	}
+	
+	if (!(pt = kmalloc(size, GFP_KERNEL))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[area].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return NULL;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
+	return pt;
+}
+
+void *drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
+{
+	void *pt;
+	
+	if (!(pt = drm_alloc(size, area))) return NULL;
+	if (oldpt && oldsize) {
+		memcpy(pt, oldpt, oldsize);
+		drm_free(oldpt, oldsize, area);
+	}
+	return pt;
+}
+
+char *drm_strdup(const char *s, int area)
+{
+	char *pt;
+	int	 length = s ? strlen(s) : 0;
+	
+	if (!(pt = drm_alloc(length+1, area))) return NULL;
+	strcpy(pt, s);
+	return pt;
+}
+
+void drm_strfree(const char *s, int area)
+{
+	unsigned int size;
+	
+	if (!s) return;
+	
+	size = 1 + (s ? strlen(s) : 0);
+	drm_free((void *)s, size, area);
+}
+
+void drm_free(void *pt, size_t size, int area)
+{
+	int alloc_count;
+	int free_count;
+	
+	if (!pt) DRM_MEM_ERROR(area, "Attempt to free NULL pointer\n");
+	else	 kfree(pt);
+	spin_lock(&drm_mem_lock);
+	drm_mem_stats[area].bytes_freed += size;
+	free_count  = ++drm_mem_stats[area].free_count;
+	alloc_count =	drm_mem_stats[area].succeed_count;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(area, "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+}
+
+unsigned long drm_alloc_pages(int order, int area)
+{
+	unsigned long address;
+	unsigned long bytes	  = PAGE_SIZE << order;
+	unsigned long addr;
+	unsigned int  sz;
+	
+	spin_lock(&drm_mem_lock);
+	if ((drm_ram_used >> PAGE_SHIFT)
+	    > (DRM_RAM_PERCENT * drm_ram_available) / 100) {
+		spin_unlock(&drm_mem_lock);
+		return 0;
+	}
+	spin_unlock(&drm_mem_lock);
+	
+	address = __get_free_pages(GFP_KERNEL, order);
+	if (!address) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[area].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return 0;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_allocated += bytes;
+	drm_ram_used		            += bytes;
+	spin_unlock(&drm_mem_lock);
+	
+	
+				/* Zero outside the lock */
+	memset((void *)address, 0, bytes);
+	
+				/* Reserve */
+	for (addr = address, sz = bytes;
+	     sz > 0;
+	     addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* Argument type changed in 2.4.0-test6/pre8 */
+		mem_map_reserve(virt_to_page(addr));
+#else
+		mem_map_reserve(MAP_NR(addr));
+#endif
+	}
+	
+	return address;
+}
+
+void drm_free_pages(unsigned long address, int order, int area)
+{
+	unsigned long bytes = PAGE_SIZE << order;
+	int		  alloc_count;
+	int		  free_count;
+	unsigned long addr;
+	unsigned int  sz;
+	
+	if (!address) {
+		DRM_MEM_ERROR(area, "Attempt to free address 0\n");
+	} else {
+				/* Unreserve */
+		for (addr = address, sz = bytes;
+		     sz > 0;
+		     addr += PAGE_SIZE, sz -= PAGE_SIZE) {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* Argument type changed in 2.4.0-test6/pre8 */
+			mem_map_unreserve(virt_to_page(addr));
+#else
+			mem_map_unreserve(MAP_NR(addr));
+#endif
+		}
+		free_pages(address, order);
+	}
+	
+	spin_lock(&drm_mem_lock);
+	free_count  = ++drm_mem_stats[area].free_count;
+	alloc_count =	drm_mem_stats[area].succeed_count;
+	drm_mem_stats[area].bytes_freed += bytes;
+	drm_ram_used			-= bytes;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(area,
+			      "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+}
+
+void *drm_ioremap(unsigned long offset, unsigned long size, drm_device_t *dev)
+{
+	void *pt;
+	
+	if (!size) {
+		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
+			      "Mapping 0 bytes at 0x%08lx\n", offset);
+		return NULL;
+	}
+	
+	if(dev->agp->cant_use_aperture == 0) {
+		goto standard_ioremap;
+	} else {
+		drm_map_t *map    = NULL;
+		int i;
+
+		for(i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			if (!map) continue;
+			if (map->offset <= offset &&
+				(map->offset + map->size) >= (offset + size))
+				break;
+		}
+		
+		if(map && map->type == _DRM_AGP) {
+			struct drm_agp_mem *agpmem;
+
+			for(agpmem = dev->agp->memory; agpmem;
+						agpmem = agpmem->next) {
+				if(agpmem->bound <= offset &&
+				   (agpmem->bound + (agpmem->pages
+					<< PAGE_SHIFT)) >= (offset + size))
+					break;
+			}
+
+			if(agpmem == NULL)
+				goto standard_ioremap;
+
+			pt = agpmem->memory->vmptr + (offset - agpmem->bound);
+			goto ioremap_success;
+		} else {
+			goto standard_ioremap;
+		}
+	}
+
+standard_ioremap:
+	if (!(pt = ioremap(offset, size))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_MAPPINGS].fail_count;
+		spin_unlock(&drm_mem_lock);
+		return NULL;
+	}
+
+ioremap_success:
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_allocated += size;
+	spin_unlock(&drm_mem_lock);
+	return pt;
+}
+
+void drm_ioremapfree(void *pt, unsigned long size, drm_device_t *dev)
+{
+	int alloc_count;
+	int free_count;
+	
+	if (!pt)
+		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
+			      "Attempt to free NULL pointer\n");
+	else if(dev->agp->cant_use_aperture == 0)
+		iounmap(pt);
+	
+	spin_lock(&drm_mem_lock);
+	drm_mem_stats[DRM_MEM_MAPPINGS].bytes_freed += size;
+	free_count  = ++drm_mem_stats[DRM_MEM_MAPPINGS].free_count;
+	alloc_count =	drm_mem_stats[DRM_MEM_MAPPINGS].succeed_count;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
+			      "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+}
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+agp_memory *drm_alloc_agp(int pages, u32 type)
+{
+	agp_memory *handle;
+
+	if (!pages) {
+		DRM_MEM_ERROR(DRM_MEM_TOTALAGP, "Allocating 0 pages\n");
+		return NULL;
+	}
+	
+	if ((handle = drm_agp_allocate_memory(pages, type))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_TOTALAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_TOTALAGP].bytes_allocated
+			+= pages << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
+		return handle;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_TOTALAGP].fail_count;
+	spin_unlock(&drm_mem_lock);
+	return NULL;
+}
+
+int drm_free_agp(agp_memory *handle, int pages)
+{
+	int           alloc_count;
+	int           free_count;
+	int           retval = -EINVAL;
+
+	if (!handle) {
+		DRM_MEM_ERROR(DRM_MEM_TOTALAGP,
+			      "Attempt to free NULL AGP handle\n");
+		return retval;;
+	}
+	
+	if (drm_agp_free_memory(handle)) {
+		spin_lock(&drm_mem_lock);
+		free_count  = ++drm_mem_stats[DRM_MEM_TOTALAGP].free_count;
+		alloc_count =   drm_mem_stats[DRM_MEM_TOTALAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_TOTALAGP].bytes_freed
+			+= pages << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
+		if (free_count > alloc_count) {
+			DRM_MEM_ERROR(DRM_MEM_TOTALAGP,
+				      "Excess frees: %d frees, %d allocs\n",
+				      free_count, alloc_count);
+		}
+		return 0;
+	}
+	return retval;
+}
+
+int drm_bind_agp(agp_memory *handle, unsigned int start)
+{
+	int retcode = -EINVAL;
+
+	if (!handle) {
+		DRM_MEM_ERROR(DRM_MEM_BOUNDAGP,
+			      "Attempt to bind NULL AGP handle\n");
+		return retcode;
+	}
+
+	if (!(retcode = drm_agp_bind_memory(handle, start))) {
+		spin_lock(&drm_mem_lock);
+		++drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
+		drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_allocated
+			+= handle->page_count << PAGE_SHIFT;
+		spin_unlock(&drm_mem_lock);
+		return retcode;
+	}
+	spin_lock(&drm_mem_lock);
+	++drm_mem_stats[DRM_MEM_BOUNDAGP].fail_count;
+	spin_unlock(&drm_mem_lock);
+	return retcode;
+}
+
+int drm_unbind_agp(agp_memory *handle)
+{
+	int alloc_count;
+	int free_count;
+	int retcode = -EINVAL;
+	
+	if (!handle) {
+		DRM_MEM_ERROR(DRM_MEM_BOUNDAGP,
+			      "Attempt to unbind NULL AGP handle\n");
+		return retcode;
+	}
+
+	if ((retcode = drm_agp_unbind_memory(handle))) return retcode;
+	spin_lock(&drm_mem_lock);
+	free_count  = ++drm_mem_stats[DRM_MEM_BOUNDAGP].free_count;
+	alloc_count = drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
+	drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_freed
+		+= handle->page_count << PAGE_SHIFT;
+	spin_unlock(&drm_mem_lock);
+	if (free_count > alloc_count) {
+		DRM_MEM_ERROR(DRM_MEM_BOUNDAGP,
+			      "Excess frees: %d frees, %d allocs\n",
+			      free_count, alloc_count);
+	}
+	return retcode;
+}
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/mga_bufs.c linux/drivers/char/drm-4.0/mga_bufs.c
--- linux.orig/drivers/char/drm-4.0/mga_bufs.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/mga_bufs.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,629 @@
+/* mga_bufs.c -- IOCTLs to manage buffers -*- linux-c -*-
+ * Created: Thu Jan 6 01:47:26 2000 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "mga_drv.h"
+#include "linux/un.h"
+
+
+int mga_addbufs_agp(struct inode *inode, struct file *filp, unsigned int cmd,
+		    unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_desc_t request;
+	drm_buf_entry_t *entry;
+	drm_buf_t *buf;
+	unsigned long offset;
+	unsigned long agp_offset;
+	int count;
+	int order;
+	int size;
+	int alignment;
+	int page_order;
+	int total;
+	int byte_count;
+	int i;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	count = request.count;
+	order = drm_order(request.size);
+	size	= 1 << order;
+	agp_offset = request.agp_start;
+	alignment  = (request.flags & _DRM_PAGE_ALIGN) ? PAGE_ALIGN(size):size;
+	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
+	total = PAGE_SIZE << page_order;
+	byte_count = 0;
+
+	DRM_DEBUG("count: %d\n", count);
+	DRM_DEBUG("order: %d\n", order);
+	DRM_DEBUG("size: %d\n", size);
+	DRM_DEBUG("agp_offset: %ld\n", agp_offset);
+	DRM_DEBUG("alignment: %d\n", alignment);
+	DRM_DEBUG("page_order: %d\n", page_order);
+	DRM_DEBUG("total: %d\n", total);
+	DRM_DEBUG("byte_count: %d\n", byte_count);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	if (dev->queue_count) return -EBUSY; /* Not while in use */
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
+   
+	down(&dev->struct_sem);
+	entry = &dma->bufs[order];
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM; /* May only call once for each order */
+	}
+
+	/* This isnt neccessarily a good limit, but we have to stop a dumb
+	   32 bit overflow problem below */
+	   
+	if ( count < 0 || count > 4096)
+	{
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -EINVAL;
+	}
+		   
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
+   
+	entry->buf_size   = size;
+	entry->page_order = page_order;
+	offset = 0;
+
+   
+	while(entry->buf_count < count) {
+		buf = &entry->buflist[entry->buf_count];
+		buf->idx = dma->buf_count + entry->buf_count;
+		buf->total = alignment;
+		buf->order = order;
+		buf->used = 0;
+
+		buf->offset = offset; /* Hrm */
+		buf->bus_address = dev->agp->base + agp_offset + offset;
+		buf->address = (void *)(agp_offset + offset + dev->agp->base);
+		buf->next = NULL;
+		buf->waiting = 0;
+		buf->pending = 0;
+		init_waitqueue_head(&buf->dma_wait);
+		buf->pid = 0;
+
+		buf->dev_private = drm_alloc(sizeof(drm_mga_buf_priv_t),
+					     DRM_MEM_BUFS);
+		buf->dev_priv_size = sizeof(drm_mga_buf_priv_t);
+
+#if DRM_DMA_HISTOGRAM
+		buf->time_queued = 0;
+		buf->time_dispatched = 0;
+		buf->time_completed = 0;
+		buf->time_freed = 0;
+#endif
+		offset = offset + alignment;
+		entry->buf_count++;
+		byte_count += PAGE_SIZE << page_order;
+	}
+   
+	dma->buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist),
+				   DRM_MEM_BUFS);
+	for (i = dma->buf_count; i < dma->buf_count + entry->buf_count; i++)
+		dma->buflist[i] = &entry->buflist[i - dma->buf_count];
+   
+	dma->buf_count  += entry->buf_count;
+
+	DRM_DEBUG("dma->buf_count : %d\n", dma->buf_count);
+
+	dma->byte_count += byte_count;
+
+	DRM_DEBUG("entry->buf_count : %d\n", entry->buf_count);
+
+	drm_freelist_create(&entry->freelist, entry->buf_count);
+	for (i = 0; i < entry->buf_count; i++) {
+		drm_freelist_put(dev, &entry->freelist, &entry->buflist[i]);
+	}
+   
+	up(&dev->struct_sem);
+   
+	request.count = entry->buf_count;
+	request.size  = size;
+   
+	if (copy_to_user((drm_buf_desc_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+   
+	atomic_dec(&dev->buf_alloc);
+
+	DRM_DEBUG("count: %d\n", count);
+	DRM_DEBUG("order: %d\n", order);
+	DRM_DEBUG("size: %d\n", size);
+	DRM_DEBUG("agp_offset: %ld\n", agp_offset);
+	DRM_DEBUG("alignment: %d\n", alignment);
+	DRM_DEBUG("page_order: %d\n", page_order);
+	DRM_DEBUG("total: %d\n", total);
+	DRM_DEBUG("byte_count: %d\n", byte_count);
+
+	dma->flags = _DRM_DMA_USE_AGP;
+
+	DRM_DEBUG("dma->flags : %x\n", dma->flags);
+
+	return 0;
+}
+
+int mga_addbufs_pci(struct inode *inode, struct file *filp, unsigned int cmd,
+		    unsigned long arg)
+{
+   	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_desc_t	 request;
+	int		 count;
+	int		 order;
+	int		 size;
+	int		 total;
+	int		 page_order;
+	drm_buf_entry_t	 *entry;
+	unsigned long	 page;
+	drm_buf_t	 *buf;
+	int		 alignment;
+	unsigned long	 offset;
+	int		 i;
+	int		 byte_count;
+	int		 page_count;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	count	   = request.count;
+	order	   = drm_order(request.size);
+	size	   = 1 << order;
+	
+	DRM_DEBUG("count = %d, size = %d (%d), order = %d, queue_count = %d\n",
+		  request.count, request.size, size, order, dev->queue_count);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	if (dev->queue_count) return -EBUSY; /* Not while in use */
+
+	alignment  = (request.flags & _DRM_PAGE_ALIGN) ? PAGE_ALIGN(size):size;
+	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
+	total	   = PAGE_SIZE << page_order;
+
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
+	
+	down(&dev->struct_sem);
+	entry = &dma->bufs[order];
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;	/* May only call once for each order */
+	}
+	
+	if(count < 0 || count > 4096)
+	{
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -EINVAL;
+	}
+	
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
+
+	entry->seglist = drm_alloc(count * sizeof(*entry->seglist),
+				   DRM_MEM_SEGS);
+	if (!entry->seglist) {
+		drm_free(entry->buflist,
+			 count * sizeof(*entry->buflist),
+			 DRM_MEM_BUFS);
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->seglist, 0, count * sizeof(*entry->seglist));
+
+	dma->pagelist = drm_realloc(dma->pagelist,
+				    dma->page_count * sizeof(*dma->pagelist),
+				    (dma->page_count + (count << page_order))
+				    * sizeof(*dma->pagelist),
+				    DRM_MEM_PAGES);
+	DRM_DEBUG("pagelist: %d entries\n",
+		  dma->page_count + (count << page_order));
+
+
+	entry->buf_size	  = size;
+	entry->page_order = page_order;
+	byte_count	  = 0;
+	page_count	  = 0;
+	while (entry->buf_count < count) {
+		if (!(page = drm_alloc_pages(page_order, DRM_MEM_DMA))) break;
+		entry->seglist[entry->seg_count++] = page;
+		for (i = 0; i < (1 << page_order); i++) {
+			DRM_DEBUG("page %d @ 0x%08lx\n",
+				  dma->page_count + page_count,
+				  page + PAGE_SIZE * i);
+			dma->pagelist[dma->page_count + page_count++]
+				= page + PAGE_SIZE * i;
+		}
+		for (offset = 0;
+		     offset + size <= total && entry->buf_count < count;
+		     offset += alignment, ++entry->buf_count) {
+			buf	     = &entry->buflist[entry->buf_count];
+			buf->idx     = dma->buf_count + entry->buf_count;
+			buf->total   = alignment;
+			buf->order   = order;
+			buf->used    = 0;
+			buf->offset  = (dma->byte_count + byte_count + offset);
+			buf->address = (void *)(page + offset);
+			buf->next    = NULL;
+			buf->waiting = 0;
+			buf->pending = 0;
+			init_waitqueue_head(&buf->dma_wait);
+			buf->pid     = 0;
+#if DRM_DMA_HISTOGRAM
+			buf->time_queued     = 0;
+			buf->time_dispatched = 0;
+			buf->time_completed  = 0;
+			buf->time_freed	     = 0;
+#endif
+			DRM_DEBUG("buffer %d @ %p\n",
+				  entry->buf_count, buf->address);
+		}
+		byte_count += PAGE_SIZE << page_order;
+	}
+
+	dma->buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist),
+				   DRM_MEM_BUFS);
+	for (i = dma->buf_count; i < dma->buf_count + entry->buf_count; i++)
+		dma->buflist[i] = &entry->buflist[i - dma->buf_count];
+
+	dma->buf_count	+= entry->buf_count;
+	dma->seg_count	+= entry->seg_count;
+	dma->page_count += entry->seg_count << page_order;
+	dma->byte_count += PAGE_SIZE * (entry->seg_count << page_order);
+	
+	drm_freelist_create(&entry->freelist, entry->buf_count);
+	for (i = 0; i < entry->buf_count; i++) {
+		drm_freelist_put(dev, &entry->freelist, &entry->buflist[i]);
+	}
+	
+	up(&dev->struct_sem);
+
+	request.count = entry->buf_count;
+	request.size  = size;
+
+	if (copy_to_user((drm_buf_desc_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+	
+	atomic_dec(&dev->buf_alloc);
+	return 0;
+}
+
+int mga_addbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_buf_desc_t	 request;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	if(request.flags & _DRM_AGP_BUFFER)
+		return mga_addbufs_agp(inode, filp, cmd, arg);
+	else
+		return mga_addbufs_pci(inode, filp, cmd, arg);
+}
+
+int mga_infobufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_info_t	 request;
+	int		 i;
+	int		 count;
+
+	if (!dma) return -EINVAL;
+
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	++dev->buf_use;		/* Can't allocate more after this call */
+	spin_unlock(&dev->count_lock);
+
+	if (copy_from_user(&request,
+			   (drm_buf_info_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	for (i = 0, count = 0; i < DRM_MAX_ORDER+1; i++) {
+		if (dma->bufs[i].buf_count) ++count;
+	}
+	
+	if (request.count >= count) {
+		for (i = 0, count = 0; i < DRM_MAX_ORDER+1; i++) {
+			if (dma->bufs[i].buf_count) {
+				if (copy_to_user(&request.list[count].count,
+						 &dma->bufs[i].buf_count,
+						 sizeof(dma->bufs[0]
+							.buf_count)) ||
+				    copy_to_user(&request.list[count].size,
+						 &dma->bufs[i].buf_size,
+						 sizeof(dma->bufs[0].buf_size)) ||
+				    copy_to_user(&request.list[count].low_mark,
+						 &dma->bufs[i]
+						 .freelist.low_mark,
+						 sizeof(dma->bufs[0]
+							.freelist.low_mark)) ||
+				    copy_to_user(&request.list[count]
+						 .high_mark,
+						 &dma->bufs[i]
+						 .freelist.high_mark,
+						 sizeof(dma->bufs[0]
+							.freelist.high_mark)))
+					return -EFAULT;
+				++count;
+			}
+		}
+	}
+	request.count = count;
+
+	if (copy_to_user((drm_buf_info_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+	
+	return 0;
+}
+
+int mga_markbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_desc_t	 request;
+	int		 order;
+	drm_buf_entry_t	 *entry;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request, (drm_buf_desc_t *)arg, sizeof(request)))
+		return -EFAULT;
+
+	order = drm_order(request.size);
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	entry = &dma->bufs[order];
+
+	if (request.low_mark < 0 || request.low_mark > entry->buf_count)
+		return -EINVAL;
+	if (request.high_mark < 0 || request.high_mark > entry->buf_count)
+		return -EINVAL;
+
+	entry->freelist.low_mark  = request.low_mark;
+	entry->freelist.high_mark = request.high_mark;
+	
+	return 0;
+}
+
+int mga_freebufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	drm_buf_free_t	 request;
+	int		 i;
+	int		 idx;
+	drm_buf_t	 *buf;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_free_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	for (i = 0; i < request.count; i++) {
+		if (copy_from_user(&idx,
+				   &request.list[i],
+				   sizeof(idx)))
+			return -EFAULT;
+		if (idx < 0 || idx >= dma->buf_count) {
+			DRM_ERROR("Index %d (of %d max)\n",
+				  idx, dma->buf_count - 1);
+			return -EINVAL;
+		}
+		buf = dma->buflist[idx];
+		if (buf->pid != current->pid) {
+			DRM_ERROR("Process %d freeing buffer owned by %d\n",
+				  current->pid, buf->pid);
+			return -EINVAL;
+		}
+		drm_free_buffer(dev, buf);
+	}
+	
+	return 0;
+}
+
+int mga_mapbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	int		 retcode = 0;
+	const int	 zero	 = 0;
+	unsigned long	 virtual;
+	unsigned long	 address;
+	drm_buf_map_t	 request;
+	int		 i;
+
+	if (!dma) return -EINVAL;
+	
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	++dev->buf_use;		/* Can't allocate more after this call */
+	spin_unlock(&dev->count_lock);
+
+	if (copy_from_user(&request,
+			   (drm_buf_map_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	if (request.count >= dma->buf_count) {
+		if(dma->flags & _DRM_DMA_USE_AGP) {
+			drm_mga_private_t *dev_priv = dev->dev_private;
+			drm_map_t *map = NULL;
+	 
+			map = dev->maplist[dev_priv->buffer_map_idx];
+			if (!map) {
+				retcode = -EINVAL;
+				goto done;
+			}
+
+			DRM_DEBUG("map->offset : %lx\n", map->offset);
+			DRM_DEBUG("map->size : %lx\n", map->size);
+			DRM_DEBUG("map->type : %d\n", map->type);
+			DRM_DEBUG("map->flags : %x\n", map->flags);
+			DRM_DEBUG("map->handle : %p\n", map->handle);
+			DRM_DEBUG("map->mtrr : %d\n", map->mtrr);
+			down_write(&current->mm->mmap_sem);
+			virtual = do_mmap(filp, 0, map->size, 
+					  PROT_READ|PROT_WRITE,
+					  MAP_SHARED, 
+					  (unsigned long)map->offset);
+			up_write(&current->mm->mmap_sem);
+		} else {
+			down_write(&current->mm->mmap_sem);
+			virtual = do_mmap(filp, 0, dma->byte_count,
+					  PROT_READ|PROT_WRITE, MAP_SHARED, 0);
+			up_write(&current->mm->mmap_sem);
+		}
+		if (virtual > -1024UL) {
+			/* Real error */
+			DRM_DEBUG("mmap error\n");
+			retcode = (signed long)virtual;
+			goto done;
+		}
+		request.virtual = (void *)virtual;
+      
+		for (i = 0; i < dma->buf_count; i++) {
+			if (copy_to_user(&request.list[i].idx,
+					 &dma->buflist[i]->idx,
+					 sizeof(request.list[0].idx))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].total,
+					 &dma->buflist[i]->total,
+					 sizeof(request.list[0].total))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].used,
+					 &zero,
+					 sizeof(zero))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			address = virtual + dma->buflist[i]->offset;
+			if (copy_to_user(&request.list[i].address,
+					 &address,
+					 sizeof(address))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+		}
+	}
+ done:
+	request.count = dma->buf_count;
+	DRM_DEBUG("%d buffers, retcode = %d\n", request.count, retcode);
+   
+	if (copy_to_user((drm_buf_map_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+
+	DRM_DEBUG("retcode : %d\n", retcode);
+
+	return retcode;
+}
diff -urN linux.orig/drivers/char/drm-4.0/mga_context.c linux/drivers/char/drm-4.0/mga_context.c
--- linux.orig/drivers/char/drm-4.0/mga_context.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/mga_context.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,209 @@
+/* mga_context.c -- IOCTLs for mga contexts -*- linux-c -*-
+ * Created: Mon Dec 13 09:51:35 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Author: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	   Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "mga_drv.h"
+
+static int mga_alloc_queue(drm_device_t *dev)
+{
+   	return drm_ctxbitmap_next(dev);
+}
+
+int mga_context_switch(drm_device_t *dev, int old, int new)
+{
+        char        buf[64];
+
+        atomic_inc(&dev->total_ctx);
+
+        if (test_and_set_bit(0, &dev->context_flag)) {
+                DRM_ERROR("Reentering -- FIXME\n");
+                return -EBUSY;
+        }
+
+#if DRM_DMA_HISTOGRAM
+        dev->ctx_start = get_cycles();
+#endif
+        
+        DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+        if (new == dev->last_context) {
+                clear_bit(0, &dev->context_flag);
+                return 0;
+        }
+        
+        if (drm_flags & DRM_FLAG_NOCTX) {
+                mga_context_switch_complete(dev, new);
+        } else {
+                sprintf(buf, "C %d %d\n", old, new);
+                drm_write_string(dev, buf);
+        }
+        
+        return 0;
+}
+
+int mga_context_switch_complete(drm_device_t *dev, int new)
+{
+        dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
+        dev->last_switch  = jiffies;
+        
+        if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+                DRM_ERROR("Lock isn't held after context switch\n");
+        }
+
+				/* If a context switch is ever initiated
+                                   when the kernel holds the lock, release
+                                   that lock here. */
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.ctx[drm_histogram_slot(get_cycles()
+                                                      - dev->ctx_start)]);
+                   
+#endif
+        clear_bit(0, &dev->context_flag);
+        wake_up(&dev->context_wait);
+        
+        return 0;
+}
+
+int mga_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_res_t	res;
+	drm_ctx_t	ctx;
+	int		i;
+
+	if (copy_from_user(&res, (drm_ctx_res_t *)arg, sizeof(res)))
+		return -EFAULT;
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+			ctx.handle = i;
+			if (copy_to_user(&res.contexts[i],
+					 &i,
+					 sizeof(i)))
+				return -EFAULT;
+		}
+	}
+	res.count = DRM_RESERVED_CONTEXTS;
+	if (copy_to_user((drm_ctx_res_t *)arg, &res, sizeof(res)))
+		return -EFAULT;
+	return 0;
+}
+
+int mga_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	if ((ctx.handle = mga_alloc_queue(dev)) == DRM_KERNEL_CONTEXT) {
+				/* Skip kernel's context and get a new one. */
+		ctx.handle = mga_alloc_queue(dev);
+	}
+        if (ctx.handle == -1) {
+		return -ENOMEM;
+	}
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int mga_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+   	/* This does nothing for the mga */
+	return 0;
+}
+
+int mga_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	/* This is 0, because we don't hanlde any context flags */
+	ctx.flags = 0;
+	if (copy_to_user((drm_ctx_t*)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int mga_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	return mga_context_switch(dev, dev->last_context, ctx.handle);
+}
+
+int mga_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	mga_context_switch_complete(dev, ctx.handle);
+
+	return 0;
+}
+
+int mga_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	      unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	if(ctx.handle == DRM_KERNEL_CONTEXT+1) priv->remove_auth_on_close = 1;
+
+      	if(ctx.handle != DRM_KERNEL_CONTEXT) {
+	   	drm_ctxbitmap_free(dev, ctx.handle);
+	}
+	
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/mga_dma.c linux/drivers/char/drm-4.0/mga_dma.c
--- linux.orig/drivers/char/drm-4.0/mga_dma.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/mga_dma.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1059 @@
+/* mga_dma.c -- DMA support for mga g200/g400 -*- linux-c -*-
+ * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *	    Keith Whitwell <keithw@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "mga_drv.h"
+
+#include <linux/interrupt.h>	/* For task queue support */
+
+#define MGA_REG(reg)		2
+#define MGA_BASE(reg)		((unsigned long) \
+				((drm_device_t *)dev)->maplist[MGA_REG(reg)]->handle)
+#define MGA_ADDR(reg)		(MGA_BASE(reg) + reg)
+#define MGA_DEREF(reg)		*(__volatile__ int *)MGA_ADDR(reg)
+#define MGA_READ(reg)		MGA_DEREF(reg)
+#define MGA_WRITE(reg,val) 	do { MGA_DEREF(reg) = val; } while (0)
+
+#define PDEA_pagpxfer_enable 	     0x2
+
+static int mga_flush_queue(drm_device_t *dev);
+
+static unsigned long mga_alloc_page(drm_device_t *dev)
+{
+	unsigned long address;
+
+	address = __get_free_page(GFP_KERNEL);
+	if(address == 0UL) {
+		return 0;
+	}
+	atomic_inc(&virt_to_page(address)->count);
+	set_bit(PG_reserved, &virt_to_page(address)->flags);
+
+	return address;
+}
+
+static void mga_free_page(drm_device_t *dev, unsigned long page)
+{
+	if(!page) return;
+	atomic_dec(&virt_to_page(page)->count);
+	clear_bit(PG_reserved, &virt_to_page(page)->flags);
+	free_page(page);
+	return;
+}
+
+static void mga_delay(void)
+{
+	return;
+}
+
+/* These are two age tags that will never be sent to
+ * the hardware */
+#define MGA_BUF_USED 	0xffffffff
+#define MGA_BUF_FREE	0
+
+static int mga_freelist_init(drm_device_t *dev)
+{
+      	drm_device_dma_t *dma = dev->dma;
+   	drm_buf_t *buf;
+   	drm_mga_buf_priv_t *buf_priv;
+      	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+   	drm_mga_freelist_t *item;
+   	int i;
+
+   	dev_priv->head = drm_alloc(sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
+	if(dev_priv->head == NULL) return -ENOMEM;
+   	memset(dev_priv->head, 0, sizeof(drm_mga_freelist_t));
+   	dev_priv->head->age = MGA_BUF_USED;
+
+   	for (i = 0; i < dma->buf_count; i++) {
+	   	buf = dma->buflist[ i ];
+	        buf_priv = buf->dev_private;
+		item = drm_alloc(sizeof(drm_mga_freelist_t),
+				 DRM_MEM_DRIVER);
+	   	if(item == NULL) return -ENOMEM;
+	   	memset(item, 0, sizeof(drm_mga_freelist_t));
+	  	item->age = MGA_BUF_FREE;
+	   	item->prev = dev_priv->head;
+	   	item->next = dev_priv->head->next;
+	   	if(dev_priv->head->next != NULL)
+			dev_priv->head->next->prev = item;
+	   	if(item->next == NULL) dev_priv->tail = item;
+	   	item->buf = buf;
+	   	buf_priv->my_freelist = item;
+		buf_priv->discard = 0;
+		buf_priv->dispatched = 0;
+	   	dev_priv->head->next = item;
+	}
+
+   	return 0;
+}
+
+static void mga_freelist_cleanup(drm_device_t *dev)
+{
+      	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+   	drm_mga_freelist_t *item;
+   	drm_mga_freelist_t *prev;
+
+   	item = dev_priv->head;
+   	while(item) {
+	   	prev = item;
+	   	item = item->next;
+	   	drm_free(prev, sizeof(drm_mga_freelist_t), DRM_MEM_DRIVER);
+	}
+
+   	dev_priv->head = dev_priv->tail = NULL;
+}
+
+/* Frees dispatch lock */
+static inline void mga_dma_quiescent(drm_device_t *dev)
+{
+	drm_device_dma_t  *dma      = dev->dma;
+	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+   	unsigned long end;
+	int i;
+
+	DRM_DEBUG("dispatch_status = 0x%02lx\n", dev_priv->dispatch_status);
+	end = jiffies + (HZ*3);
+    	while(1) {
+		if(!test_and_set_bit(MGA_IN_DISPATCH,
+				     &dev_priv->dispatch_status)) {
+			break;
+		}
+	   	if((signed)(end - jiffies) <= 0) {
+			DRM_ERROR("irqs: %d wanted %d\n",
+				  atomic_read(&dev->total_irq),
+				  atomic_read(&dma->total_lost));
+			DRM_ERROR("lockup: dispatch_status = 0x%02lx,"
+				  " jiffies = %lu, end = %lu\n",
+				  dev_priv->dispatch_status, jiffies, end);
+			return;
+		}
+		for (i = 0 ; i < 2000 ; i++) mga_delay();
+	}
+	end = jiffies + (HZ*3);
+    	DRM_DEBUG("quiescent status : %x\n", MGA_READ(MGAREG_STATUS));
+    	while((MGA_READ(MGAREG_STATUS) & 0x00030001) != 0x00020000) {
+		if((signed)(end - jiffies) <= 0) {
+			DRM_ERROR("irqs: %d wanted %d\n",
+				  atomic_read(&dev->total_irq),
+				  atomic_read(&dma->total_lost));
+			DRM_ERROR("lockup\n");
+			clear_bit(MGA_IN_DISPATCH, &dev_priv->dispatch_status);
+			return;
+		}
+		for (i = 0 ; i < 2000 ; i++) mga_delay();
+	}
+    	sarea_priv->dirty |= MGA_DMA_FLUSH;
+
+    	clear_bit(MGA_IN_DISPATCH, &dev_priv->dispatch_status);
+	DRM_DEBUG("exit, dispatch_status = 0x%02lx\n",
+		  dev_priv->dispatch_status);
+}
+
+static void mga_reset_freelist(drm_device_t *dev)
+{
+   	drm_device_dma_t  *dma      = dev->dma;
+   	drm_buf_t *buf;
+   	drm_mga_buf_priv_t *buf_priv;
+	int i;
+
+   	for (i = 0; i < dma->buf_count; i++) {
+	   	buf = dma->buflist[ i ];
+	        buf_priv = buf->dev_private;
+		buf_priv->my_freelist->age = MGA_BUF_FREE;
+	}
+}
+
+/* Least recently used :
+ * These operations are not atomic b/c they are protected by the
+ * hardware lock */
+
+drm_buf_t *mga_freelist_get(drm_device_t *dev)
+{
+   	DECLARE_WAITQUEUE(entry, current);
+   	drm_mga_private_t *dev_priv =
+     		(drm_mga_private_t *) dev->dev_private;
+	drm_mga_freelist_t *prev;
+   	drm_mga_freelist_t *next;
+	static int failed = 0;
+	int return_null = 0;
+
+	if(failed >= 1000 && dev_priv->tail->age >= dev_priv->last_prim_age) {
+		DRM_DEBUG("Waiting on freelist,"
+			  " tail->age = %d, last_prim_age= %d\n",
+			  dev_priv->tail->age,
+			  dev_priv->last_prim_age);
+	   	add_wait_queue(&dev_priv->buf_queue, &entry);
+		set_bit(MGA_IN_GETBUF, &dev_priv->dispatch_status);
+	   	for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+		   	mga_dma_schedule(dev, 0);
+			if(dev_priv->tail->age < dev_priv->last_prim_age)
+				break;
+		   	atomic_inc(&dev->total_sleeps);
+		   	schedule();
+		   	if (signal_pending(current)) {
+				++return_null;
+				break;
+			}
+		}
+		clear_bit(MGA_IN_GETBUF, &dev_priv->dispatch_status);
+		current->state = TASK_RUNNING;
+	   	remove_wait_queue(&dev_priv->buf_queue, &entry);
+		if (return_null) return NULL;
+	}
+
+   	if(dev_priv->tail->age < dev_priv->last_prim_age) {
+		prev = dev_priv->tail->prev;
+	   	next = dev_priv->tail;
+	   	prev->next = NULL;
+	   	next->prev = next->next = NULL;
+	   	dev_priv->tail = prev;
+	   	next->age = MGA_BUF_USED;
+		failed = 0;
+	   	return next->buf;
+	}
+
+	failed++;
+   	return NULL;
+}
+
+int mga_freelist_put(drm_device_t *dev, drm_buf_t *buf)
+{
+      	drm_mga_private_t *dev_priv =
+     		(drm_mga_private_t *) dev->dev_private;
+   	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+	drm_mga_freelist_t *prev;
+   	drm_mga_freelist_t *head;
+   	drm_mga_freelist_t *next;
+
+   	if(buf_priv->my_freelist->age == MGA_BUF_USED) {
+		/* Discarded buffer, put it on the tail */
+		next = buf_priv->my_freelist;
+		next->age = MGA_BUF_FREE;
+		prev = dev_priv->tail;
+		prev->next = next;
+		next->prev = prev;
+		next->next = NULL;
+		dev_priv->tail = next;
+	} else {
+		/* Normally aged buffer, put it on the head + 1,
+		 * as the real head is a sentinal element
+		 */
+		next = buf_priv->my_freelist;
+		head = dev_priv->head;
+		prev = head->next;
+		head->next = next;
+		prev->prev = next;
+		next->prev = head;
+		next->next = prev;
+	}
+
+   	return 0;
+}
+
+static int mga_init_primary_bufs(drm_device_t *dev, drm_mga_init_t *init)
+{
+   	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_prim_buf_t *prim_buffer;
+   	int i, temp, size_of_buf;
+   	int offset = init->reserved_map_agpstart;
+
+   	dev_priv->primary_size = ((init->primary_size + PAGE_SIZE - 1) /
+				  PAGE_SIZE) * PAGE_SIZE;
+   	size_of_buf = dev_priv->primary_size / MGA_NUM_PRIM_BUFS;
+	dev_priv->warp_ucode_size = init->warp_ucode_size;
+   	dev_priv->prim_bufs = drm_alloc(sizeof(drm_mga_prim_buf_t *) *
+					(MGA_NUM_PRIM_BUFS + 1),
+					DRM_MEM_DRIVER);
+   	if(dev_priv->prim_bufs == NULL) {
+		DRM_ERROR("Unable to allocate memory for prim_buf\n");
+		return -ENOMEM;
+	}
+   	memset(dev_priv->prim_bufs,
+	       0, sizeof(drm_mga_prim_buf_t *) * (MGA_NUM_PRIM_BUFS + 1));
+
+   	temp = init->warp_ucode_size + dev_priv->primary_size;
+	temp = ((temp + PAGE_SIZE - 1) / PAGE_SIZE) * PAGE_SIZE;
+
+	dev_priv->ioremap = drm_ioremap(dev->agp->base + offset,
+					temp, dev);
+	if(dev_priv->ioremap == NULL) {
+		DRM_ERROR("Ioremap failed\n");
+		return -ENOMEM;
+	}
+   	init_waitqueue_head(&dev_priv->wait_queue);
+
+   	for(i = 0; i < MGA_NUM_PRIM_BUFS; i++) {
+	   	prim_buffer = drm_alloc(sizeof(drm_mga_prim_buf_t),
+					DRM_MEM_DRIVER);
+	   	if(prim_buffer == NULL) return -ENOMEM;
+	   	memset(prim_buffer, 0, sizeof(drm_mga_prim_buf_t));
+	   	prim_buffer->phys_head = offset + dev->agp->base;
+	   	prim_buffer->current_dma_ptr =
+			prim_buffer->head =
+			(u32 *) (dev_priv->ioremap +
+				 offset -
+				 init->reserved_map_agpstart);
+	   	prim_buffer->num_dwords = 0;
+	   	prim_buffer->max_dwords = size_of_buf / sizeof(u32);
+	   	prim_buffer->max_dwords -= 5; /* Leave room for the softrap */
+	   	prim_buffer->sec_used = 0;
+	   	prim_buffer->idx = i;
+		prim_buffer->prim_age = i + 1;
+	   	offset = offset + size_of_buf;
+	   	dev_priv->prim_bufs[i] = prim_buffer;
+	}
+	dev_priv->current_prim_idx = 0;
+        dev_priv->next_prim =
+		dev_priv->last_prim =
+		dev_priv->current_prim =
+        	dev_priv->prim_bufs[0];
+	dev_priv->next_prim_age = 2;
+	dev_priv->last_prim_age = 1;
+   	set_bit(MGA_BUF_IN_USE, &dev_priv->current_prim->buffer_status);
+   	return 0;
+}
+
+void mga_fire_primary(drm_device_t *dev, drm_mga_prim_buf_t *prim)
+{
+       	drm_mga_private_t *dev_priv = dev->dev_private;
+      	drm_device_dma_t  *dma	    = dev->dma;
+       	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+ 	int use_agp = PDEA_pagpxfer_enable;
+	unsigned long end;
+   	int i;
+   	int next_idx;
+       	PRIMLOCALS;
+
+   	dev_priv->last_prim = prim;
+
+ 	/* We never check for overflow, b/c there is always room */
+    	PRIMPTR(prim);
+   	if(num_dwords <= 0) {
+		DRM_ERROR("num_dwords == 0 when dispatched\n");
+		goto out_prim_wait;
+	}
+ 	PRIMOUTREG( MGAREG_DMAPAD, 0);
+ 	PRIMOUTREG( MGAREG_DMAPAD, 0);
+       	PRIMOUTREG( MGAREG_DMAPAD, 0);
+   	PRIMOUTREG( MGAREG_SOFTRAP, 0);
+    	PRIMFINISH(prim);
+
+	end = jiffies + (HZ*3);
+    	if(sarea_priv->dirty & MGA_DMA_FLUSH) {
+		while((MGA_READ(MGAREG_STATUS) & 0x00030001) != 0x00020000) {
+			if((signed)(end - jiffies) <= 0) {
+				DRM_ERROR("irqs: %d wanted %d\n",
+					  atomic_read(&dev->total_irq),
+					  atomic_read(&dma->total_lost));
+				DRM_ERROR("lockup (flush)\n");
+				goto out_prim_wait;
+			}
+
+			for (i = 0 ; i < 4096 ; i++) mga_delay();
+		}
+		sarea_priv->dirty &= ~(MGA_DMA_FLUSH);
+	} else {
+		while((MGA_READ(MGAREG_STATUS) & 0x00020001) != 0x00020000) {
+			if((signed)(end - jiffies) <= 0) {
+				DRM_ERROR("irqs: %d wanted %d\n",
+					  atomic_read(&dev->total_irq),
+					  atomic_read(&dma->total_lost));
+				DRM_ERROR("lockup (wait)\n");
+				goto out_prim_wait;
+			}
+
+			for (i = 0 ; i < 4096 ; i++) mga_delay();
+		}
+	}
+
+   	mga_flush_write_combine();
+    	atomic_inc(&dev_priv->pending_bufs);
+       	MGA_WRITE(MGAREG_PRIMADDRESS, phys_head | TT_GENERAL);
+ 	MGA_WRITE(MGAREG_PRIMEND, (phys_head + num_dwords * 4) | use_agp);
+   	prim->num_dwords = 0;
+	sarea_priv->last_enqueue = prim->prim_age;
+
+   	next_idx = prim->idx + 1;
+    	if(next_idx >= MGA_NUM_PRIM_BUFS)
+		next_idx = 0;
+
+    	dev_priv->next_prim = dev_priv->prim_bufs[next_idx];
+	return;
+
+ out_prim_wait:
+	prim->num_dwords = 0;
+	prim->sec_used = 0;
+	clear_bit(MGA_BUF_IN_USE, &prim->buffer_status);
+   	wake_up_interruptible(&dev_priv->wait_queue);
+	clear_bit(MGA_BUF_SWAP_PENDING, &prim->buffer_status);
+	clear_bit(MGA_IN_DISPATCH, &dev_priv->dispatch_status);
+}
+
+int mga_advance_primary(drm_device_t *dev)
+{
+   	DECLARE_WAITQUEUE(entry, current);
+   	drm_mga_private_t *dev_priv = dev->dev_private;
+   	drm_mga_prim_buf_t *prim_buffer;
+   	drm_device_dma_t  *dma      = dev->dma;
+   	int next_prim_idx;
+   	int ret = 0;
+
+   	/* This needs to reset the primary buffer if available,
+	 * we should collect stats on how many times it bites
+	 * it's tail */
+
+   	next_prim_idx = dev_priv->current_prim_idx + 1;
+   	if(next_prim_idx >= MGA_NUM_PRIM_BUFS)
+     		next_prim_idx = 0;
+   	prim_buffer = dev_priv->prim_bufs[next_prim_idx];
+	set_bit(MGA_IN_WAIT, &dev_priv->dispatch_status);
+
+      	/* In use is cleared in interrupt handler */
+
+   	if(test_and_set_bit(MGA_BUF_IN_USE, &prim_buffer->buffer_status)) {
+	   	add_wait_queue(&dev_priv->wait_queue, &entry);
+	   	for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+		   	mga_dma_schedule(dev, 0);
+		   	if(!test_and_set_bit(MGA_BUF_IN_USE,
+					     &prim_buffer->buffer_status))
+				break;
+		   	atomic_inc(&dev->total_sleeps);
+		   	atomic_inc(&dma->total_missed_sched);
+		   	schedule();
+		   	if (signal_pending(current)) {
+			   	ret = -ERESTARTSYS;
+			   	break;
+			}
+		}
+		current->state = TASK_RUNNING;
+	   	remove_wait_queue(&dev_priv->wait_queue, &entry);
+	   	if(ret) return ret;
+	}
+	clear_bit(MGA_IN_WAIT, &dev_priv->dispatch_status);
+
+   	/* This primary buffer is now free to use */
+   	prim_buffer->current_dma_ptr = prim_buffer->head;
+   	prim_buffer->num_dwords = 0;
+   	prim_buffer->sec_used = 0;
+	prim_buffer->prim_age = dev_priv->next_prim_age++;
+	if(prim_buffer->prim_age == 0 || prim_buffer->prim_age == 0xffffffff) {
+		mga_flush_queue(dev);
+		mga_dma_quiescent(dev);
+		mga_reset_freelist(dev);
+		prim_buffer->prim_age = (dev_priv->next_prim_age += 2);
+	}
+
+	/* Reset all buffer status stuff */
+	clear_bit(MGA_BUF_NEEDS_OVERFLOW, &prim_buffer->buffer_status);
+	clear_bit(MGA_BUF_FORCE_FIRE, &prim_buffer->buffer_status);
+	clear_bit(MGA_BUF_SWAP_PENDING, &prim_buffer->buffer_status);
+
+   	dev_priv->current_prim = prim_buffer;
+   	dev_priv->current_prim_idx = next_prim_idx;
+   	return 0;
+}
+
+/* More dynamic performance decisions */
+static inline int mga_decide_to_fire(drm_device_t *dev)
+{
+   	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+
+   	if(test_bit(MGA_BUF_FORCE_FIRE, &dev_priv->next_prim->buffer_status)) {
+	   	return 1;
+	}
+
+	if (test_bit(MGA_IN_GETBUF, &dev_priv->dispatch_status) &&
+	    dev_priv->next_prim->num_dwords) {
+	   	return 1;
+	}
+
+	if (test_bit(MGA_IN_FLUSH, &dev_priv->dispatch_status) &&
+	    dev_priv->next_prim->num_dwords) {
+	   	return 1;
+	}
+
+   	if(atomic_read(&dev_priv->pending_bufs) <= MGA_NUM_PRIM_BUFS - 1) {
+		if(test_bit(MGA_BUF_SWAP_PENDING,
+			    &dev_priv->next_prim->buffer_status)) {
+			return 1;
+		}
+	}
+
+   	if(atomic_read(&dev_priv->pending_bufs) <= MGA_NUM_PRIM_BUFS / 2) {
+		if(dev_priv->next_prim->sec_used >= MGA_DMA_BUF_NR / 8) {
+			return 1;
+		}
+	}
+
+   	if(atomic_read(&dev_priv->pending_bufs) >= MGA_NUM_PRIM_BUFS / 2) {
+		if(dev_priv->next_prim->sec_used >= MGA_DMA_BUF_NR / 4) {
+			return 1;
+		}
+	}
+
+   	return 0;
+}
+
+int mga_dma_schedule(drm_device_t *dev, int locked)
+{
+      	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+	int               retval    = 0;
+
+   	if (!dev_priv) return -EBUSY;
+	
+	if (test_and_set_bit(0, &dev->dma_flag)) {
+		retval = -EBUSY;
+		goto sch_out_wakeup;
+	}
+
+   	if(test_bit(MGA_IN_FLUSH, &dev_priv->dispatch_status) ||
+	   test_bit(MGA_IN_WAIT, &dev_priv->dispatch_status) ||
+	   test_bit(MGA_IN_GETBUF, &dev_priv->dispatch_status)) {
+		locked = 1;
+	}
+
+   	if (!locked &&
+	    !drm_lock_take(&dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT)) {
+	   	clear_bit(0, &dev->dma_flag);
+		retval = -EBUSY;
+		goto sch_out_wakeup;
+	}
+
+   	if(!test_and_set_bit(MGA_IN_DISPATCH, &dev_priv->dispatch_status)) {
+	   	/* Fire dma buffer */
+	   	if(mga_decide_to_fire(dev)) {
+			clear_bit(MGA_BUF_FORCE_FIRE,
+				  &dev_priv->next_prim->buffer_status);
+		   	if(dev_priv->current_prim == dev_priv->next_prim) {
+				/* Schedule overflow for a later time */
+				set_bit(MGA_BUF_NEEDS_OVERFLOW,
+					&dev_priv->next_prim->buffer_status);
+			}
+		   	mga_fire_primary(dev, dev_priv->next_prim);
+		} else {
+			clear_bit(MGA_IN_DISPATCH, &dev_priv->dispatch_status);
+		}
+	}
+
+	if (!locked) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+
+	clear_bit(0, &dev->dma_flag);
+
+sch_out_wakeup:
+      	if(test_bit(MGA_IN_FLUSH, &dev_priv->dispatch_status) &&
+	   atomic_read(&dev_priv->pending_bufs) == 0) {
+		/* Everything has been processed by the hardware */
+		clear_bit(MGA_IN_FLUSH, &dev_priv->dispatch_status);
+		wake_up_interruptible(&dev_priv->flush_queue);
+	}
+
+	if(test_bit(MGA_IN_GETBUF, &dev_priv->dispatch_status)
+	   && dev_priv->tail->age < dev_priv->last_prim_age)
+		wake_up_interruptible(&dev_priv->buf_queue);
+
+	return retval;
+}
+
+static void mga_dma_service(int irq, void *device, struct pt_regs *regs)
+{
+    	drm_device_t	 *dev = (drm_device_t *)device;
+    	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+    	drm_mga_prim_buf_t *last_prim_buffer;
+
+    	atomic_inc(&dev->total_irq);
+	if((MGA_READ(MGAREG_STATUS) & 0x00000001) != 0x00000001) return;
+      	MGA_WRITE(MGAREG_ICLEAR, 0x00000001);
+   	last_prim_buffer = dev_priv->last_prim;
+    	last_prim_buffer->num_dwords = 0;
+    	last_prim_buffer->sec_used = 0;
+	dev_priv->sarea_priv->last_dispatch =
+		dev_priv->last_prim_age = last_prim_buffer->prim_age;
+      	clear_bit(MGA_BUF_IN_USE, &last_prim_buffer->buffer_status);
+      	clear_bit(MGA_BUF_SWAP_PENDING, &last_prim_buffer->buffer_status);
+      	clear_bit(MGA_IN_DISPATCH, &dev_priv->dispatch_status);
+      	atomic_dec(&dev_priv->pending_bufs);
+   	queue_task(&dev->tq, &tq_immediate);
+   	mark_bh(IMMEDIATE_BH);
+   	wake_up_interruptible(&dev_priv->wait_queue);
+}
+
+static void mga_dma_task_queue(void *device)
+{
+	mga_dma_schedule((drm_device_t *)device, 0);
+}
+
+int mga_dma_cleanup(drm_device_t *dev)
+{
+	if(dev->dev_private) {
+		drm_mga_private_t *dev_priv =
+			(drm_mga_private_t *) dev->dev_private;
+
+		if (dev->irq) mga_flush_queue(dev);
+		mga_dma_quiescent(dev);
+
+		if(dev_priv->ioremap) {
+			int temp = (dev_priv->warp_ucode_size +
+				    dev_priv->primary_size +
+				    PAGE_SIZE - 1) / PAGE_SIZE * PAGE_SIZE;
+
+			drm_ioremapfree((void *) dev_priv->ioremap, temp, dev);
+		}
+	   	if(dev_priv->status_page != NULL) {
+		   	iounmap(dev_priv->status_page);
+		}
+	   	if(dev_priv->real_status_page != 0UL) {
+		   	mga_free_page(dev, dev_priv->real_status_page);
+		}
+	   	if(dev_priv->prim_bufs != NULL) {
+		   	int i;
+		   	for(i = 0; i < MGA_NUM_PRIM_BUFS; i++) {
+			   	if(dev_priv->prim_bufs[i] != NULL) {
+			     		drm_free(dev_priv->prim_bufs[i],
+						 sizeof(drm_mga_prim_buf_t),
+						 DRM_MEM_DRIVER);
+				}
+			}
+		   	drm_free(dev_priv->prim_bufs, sizeof(void *) *
+				 (MGA_NUM_PRIM_BUFS + 1),
+				 DRM_MEM_DRIVER);
+		}
+		if(dev_priv->head != NULL) {
+		   	mga_freelist_cleanup(dev);
+		}
+
+
+		drm_free(dev->dev_private, sizeof(drm_mga_private_t),
+			 DRM_MEM_DRIVER);
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+static int mga_dma_initialize(drm_device_t *dev, drm_mga_init_t *init) {
+	drm_mga_private_t *dev_priv;
+	drm_map_t *sarea_map = NULL;
+
+	dev_priv = drm_alloc(sizeof(drm_mga_private_t), DRM_MEM_DRIVER);
+	if(dev_priv == NULL) return -ENOMEM;
+	dev->dev_private = (void *) dev_priv;
+
+	memset(dev_priv, 0, sizeof(drm_mga_private_t));
+
+	if((init->reserved_map_idx >= dev->map_count) ||
+	   (init->buffer_map_idx >= dev->map_count)) {
+		mga_dma_cleanup(dev);
+		return -EINVAL;
+	}
+
+	dev_priv->reserved_map_idx = init->reserved_map_idx;
+	dev_priv->buffer_map_idx = init->buffer_map_idx;
+	sarea_map = dev->maplist[0];
+	dev_priv->sarea_priv = (drm_mga_sarea_t *)
+		((u8 *)sarea_map->handle +
+		 init->sarea_priv_offset);
+
+	/* Scale primary size to the next page */
+	dev_priv->chipset = init->chipset;
+	dev_priv->frontOffset = init->frontOffset;
+	dev_priv->backOffset = init->backOffset;
+	dev_priv->depthOffset = init->depthOffset;
+	dev_priv->textureOffset = init->textureOffset;
+	dev_priv->textureSize = init->textureSize;
+	dev_priv->cpp = init->cpp;
+	dev_priv->sgram = init->sgram;
+	dev_priv->stride = init->stride;
+
+	dev_priv->mAccess = init->mAccess;
+   	init_waitqueue_head(&dev_priv->flush_queue);
+	init_waitqueue_head(&dev_priv->buf_queue);
+	dev_priv->WarpPipe = 0xff000000;
+	dev_priv->vertexsize = 0;
+
+   	DRM_DEBUG("chipset=%d ucode_size=%d backOffset=%x depthOffset=%x\n",
+		  dev_priv->chipset, dev_priv->warp_ucode_size,
+		  dev_priv->backOffset, dev_priv->depthOffset);
+   	DRM_DEBUG("cpp: %d sgram: %d stride: %d maccess: %x\n",
+		  dev_priv->cpp, dev_priv->sgram, dev_priv->stride,
+		  dev_priv->mAccess);
+
+	memcpy(&dev_priv->WarpIndex, &init->WarpIndex,
+	       sizeof(drm_mga_warp_index_t) * MGA_MAX_WARP_PIPES);
+
+   	if(mga_init_primary_bufs(dev, init) != 0) {
+		DRM_ERROR("Can not initialize primary buffers\n");
+		mga_dma_cleanup(dev);
+		return -ENOMEM;
+	}
+   	dev_priv->real_status_page = mga_alloc_page(dev);
+      	if(dev_priv->real_status_page == 0UL) {
+		mga_dma_cleanup(dev);
+		DRM_ERROR("Can not allocate status page\n");
+		return -ENOMEM;
+	}
+
+   	dev_priv->status_page =
+		ioremap_nocache(virt_to_bus((void *)dev_priv->real_status_page),
+				PAGE_SIZE);
+
+   	if(dev_priv->status_page == NULL) {
+		mga_dma_cleanup(dev);
+		DRM_ERROR("Can not remap status page\n");
+		return -ENOMEM;
+	}
+
+   	/* Write status page when secend or softrap occurs
+	 *
+	 * Disable this on ia64 on the off chance that real status page will be
+	 * above 4GB.
+	 */
+#if defined(__ia64__)
+   	MGA_WRITE(MGAREG_PRIMPTR,
+		  virt_to_bus((void *)dev_priv->real_status_page));
+#else
+   	MGA_WRITE(MGAREG_PRIMPTR,
+		  virt_to_bus((void *)dev_priv->real_status_page) | 0x00000003);
+#endif
+
+	/* Private is now filled in, initialize the hardware */
+	{
+		PRIMLOCALS;
+		PRIMGETPTR( dev_priv );
+
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DWGSYNC, 0x0100);
+		PRIMOUTREG(MGAREG_SOFTRAP, 0);
+		/* Poll for the first buffer to insure that
+		 * the status register will be correct
+		 */
+
+		mga_flush_write_combine();
+	   	MGA_WRITE(MGAREG_PRIMADDRESS, phys_head | TT_GENERAL);
+
+		MGA_WRITE(MGAREG_PRIMEND, ((phys_head + num_dwords * 4) |
+					   PDEA_pagpxfer_enable));
+
+	   	while(MGA_READ(MGAREG_DWGSYNC) != 0x0100) ;
+	}
+
+	if(mga_freelist_init(dev) != 0) {
+	   	DRM_ERROR("Could not initialize freelist\n");
+	   	mga_dma_cleanup(dev);
+	   	return -ENOMEM;
+	}
+	return 0;
+}
+
+int mga_dma_init(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_mga_init_t init;
+
+	if (copy_from_user(&init, (drm_mga_init_t *)arg, sizeof(init)))
+		return -EFAULT;
+
+	switch(init.func) {
+	case MGA_INIT_DMA:
+		return mga_dma_initialize(dev, &init);
+	case MGA_CLEANUP_DMA:
+		return mga_dma_cleanup(dev);
+	}
+
+	return -EINVAL;
+}
+
+int mga_irq_install(drm_device_t *dev, int irq)
+{
+	int retcode;
+
+	if (!irq)     return -EINVAL;
+
+	down(&dev->struct_sem);
+	if (dev->irq) {
+		up(&dev->struct_sem);
+		return -EBUSY;
+	}
+	dev->irq = irq;
+	up(&dev->struct_sem);
+
+	DRM_DEBUG("install irq handler %d\n", irq);
+
+	dev->context_flag     = 0;
+	dev->interrupt_flag   = 0;
+	dev->dma_flag	      = 0;
+	dev->dma->next_buffer = NULL;
+	dev->dma->next_queue  = NULL;
+	dev->dma->this_buffer = NULL;
+	INIT_LIST_HEAD(&dev->tq.list);
+	dev->tq.sync	      = 0;
+	dev->tq.routine	      = mga_dma_task_queue;
+	dev->tq.data	      = dev;
+
+				/* Before installing handler */
+	MGA_WRITE(MGAREG_IEN, 0);
+   				/* Install handler */
+	if ((retcode = request_irq(dev->irq,
+				   mga_dma_service,
+				   SA_SHIRQ,
+				   dev->devname,
+				   dev))) {
+		down(&dev->struct_sem);
+		dev->irq = 0;
+		up(&dev->struct_sem);
+		return retcode;
+	}
+				/* After installing handler */
+   	MGA_WRITE(MGAREG_ICLEAR, 0x00000001);
+	MGA_WRITE(MGAREG_IEN, 0x00000001);
+	return 0;
+}
+
+int mga_irq_uninstall(drm_device_t *dev)
+{
+	int irq;
+
+	down(&dev->struct_sem);
+	irq	 = dev->irq;
+	dev->irq = 0;
+	up(&dev->struct_sem);
+
+	if (!irq) return -EINVAL;
+   	DRM_DEBUG("remove irq handler %d\n", irq);
+      	MGA_WRITE(MGAREG_ICLEAR, 0x00000001);
+	MGA_WRITE(MGAREG_IEN, 0);
+	free_irq(irq, dev);
+	return 0;
+}
+
+int mga_control(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_control_t	ctl;
+
+	if (copy_from_user(&ctl, (drm_control_t *)arg, sizeof(ctl)))
+		return -EFAULT;
+
+	switch (ctl.func) {
+	case DRM_INST_HANDLER:
+		return mga_irq_install(dev, ctl.irq);
+	case DRM_UNINST_HANDLER:
+		return mga_irq_uninstall(dev);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int mga_flush_queue(drm_device_t *dev)
+{
+   	DECLARE_WAITQUEUE(entry, current);
+  	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+   	int ret = 0;
+
+   	if(!dev_priv) return 0;
+
+   	if(dev_priv->next_prim->num_dwords != 0) {
+   		add_wait_queue(&dev_priv->flush_queue, &entry);
+		if (test_bit(MGA_IN_FLUSH, &dev_priv->dispatch_status)) 
+			DRM_ERROR("Incorrect mga_flush_queue logic\n");
+		set_bit(MGA_IN_FLUSH, &dev_priv->dispatch_status);
+		mga_dma_schedule(dev, 0);
+   		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+	   		if (!test_bit(MGA_IN_FLUSH,
+				      &dev_priv->dispatch_status))
+				break;
+		   	atomic_inc(&dev->total_sleeps);
+	      		schedule();
+	      		if (signal_pending(current)) {
+		   		ret = -EINTR; /* Can't restart */
+				clear_bit(MGA_IN_FLUSH,
+					  &dev_priv->dispatch_status);
+		   		break;
+			}
+		}
+		current->state = TASK_RUNNING;
+   		remove_wait_queue(&dev_priv->flush_queue, &entry);
+	}
+   	return ret;
+}
+
+/* Must be called with the lock held */
+void mga_reclaim_buffers(drm_device_t *dev, pid_t pid)
+{
+	drm_device_dma_t *dma = dev->dma;
+	int		 i;
+
+	if (!dma) return;
+      	if(dev->dev_private == NULL) return;
+	if(dma->buflist == NULL) return;
+
+	DRM_DEBUG("buf_count=%d\n", dma->buf_count);
+	
+        mga_flush_queue(dev);
+
+	for (i = 0; i < dma->buf_count; i++) {
+	   	drm_buf_t *buf = dma->buflist[ i ];
+	   	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+
+		/* Only buffers that need to get reclaimed ever
+		 * get set to free
+		 */
+		if (buf->pid == pid  && buf_priv) {
+			if(buf_priv->my_freelist->age == MGA_BUF_USED)
+		     		buf_priv->my_freelist->age = MGA_BUF_FREE;
+		}
+	}
+}
+
+int mga_lock(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	DECLARE_WAITQUEUE(entry, current);
+	int		  ret	= 0;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	if (lock.context < 0) return -EINVAL;
+
+	/* Only one queue:
+	 */
+
+	if (!ret) {
+		add_wait_queue(&dev->lock.lock_queue, &entry);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!dev->lock.hw_lock) {
+				/* Device has been unregistered */
+				ret = -EINTR;
+				break;
+			}
+			if (drm_lock_take(&dev->lock.hw_lock->lock,
+					  lock.context)) {
+				dev->lock.pid	    = current->pid;
+				dev->lock.lock_time = jiffies;
+				atomic_inc(&dev->total_locks);
+				break;	/* Got lock */
+			}
+
+				/* Contention */
+			atomic_inc(&dev->total_sleeps);
+			schedule();
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+				break;
+			}
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&dev->lock.lock_queue, &entry);
+	}
+
+	if (!ret) {
+		sigemptyset(&dev->sigmask);
+		sigaddset(&dev->sigmask, SIGSTOP);
+		sigaddset(&dev->sigmask, SIGTSTP);
+		sigaddset(&dev->sigmask, SIGTTIN);
+		sigaddset(&dev->sigmask, SIGTTOU);
+		dev->sigdata.context = lock.context;
+		dev->sigdata.lock    = dev->lock.hw_lock;
+		block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+
+		if (lock.flags & _DRM_LOCK_QUIESCENT) {
+		   DRM_DEBUG("_DRM_LOCK_QUIESCENT\n");
+		   mga_flush_queue(dev);
+		   mga_dma_quiescent(dev);
+		}
+	}
+
+	if (ret) DRM_DEBUG("%d %s\n", lock.context,
+			   ret ? "interrupted" : "has lock");
+	return ret;
+}
+
+int mga_flush_ioctl(struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg)
+{
+       	drm_file_t	  *priv	  = filp->private_data;
+    	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+      	drm_mga_private_t *dev_priv = (drm_mga_private_t *)dev->dev_private;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if(!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("lock not held\n");
+		return -EINVAL;
+	}
+
+   	if(lock.flags & _DRM_LOCK_FLUSH || lock.flags & _DRM_LOCK_FLUSH_ALL) {
+		drm_mga_prim_buf_t *temp_buf;
+
+		temp_buf = dev_priv->current_prim;
+
+		if(temp_buf && temp_buf->num_dwords) {
+			set_bit(MGA_BUF_FORCE_FIRE, &temp_buf->buffer_status);
+			mga_advance_primary(dev);
+ 		}
+		mga_dma_schedule(dev, 1);
+	}
+   	if(lock.flags & _DRM_LOCK_QUIESCENT) {
+		mga_flush_queue(dev);
+		mga_dma_quiescent(dev);
+	}
+
+    	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/mga_drm.h linux/drivers/char/drm-4.0/mga_drm.h
--- linux.orig/drivers/char/drm-4.0/mga_drm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/mga_drm.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,274 @@
+/* mga_drm.h -- Public header for the Matrox g200/g400 driver -*- linux-c -*-
+ * Created: Tue Jan 25 01:50:01 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Jeff Hartmann <jhartmann@valinux.com>
+ *          Keith Whitwell <keithw@valinux.com>
+ *
+ */
+
+#ifndef _MGA_DRM_H_
+#define _MGA_DRM_H_
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (xf86drmMga.h)
+ */
+#ifndef _MGA_DEFINES_
+#define _MGA_DEFINES_
+
+#define MGA_F  0x1		/* fog */
+#define MGA_A  0x2		/* alpha */
+#define MGA_S  0x4		/* specular */
+#define MGA_T2 0x8		/* multitexture */
+
+#define MGA_WARP_TGZ            0
+#define MGA_WARP_TGZF           (MGA_F)
+#define MGA_WARP_TGZA           (MGA_A)
+#define MGA_WARP_TGZAF          (MGA_F|MGA_A)
+#define MGA_WARP_TGZS           (MGA_S)
+#define MGA_WARP_TGZSF          (MGA_S|MGA_F)
+#define MGA_WARP_TGZSA          (MGA_S|MGA_A)
+#define MGA_WARP_TGZSAF         (MGA_S|MGA_F|MGA_A)
+#define MGA_WARP_T2GZ           (MGA_T2)
+#define MGA_WARP_T2GZF          (MGA_T2|MGA_F)
+#define MGA_WARP_T2GZA          (MGA_T2|MGA_A)
+#define MGA_WARP_T2GZAF         (MGA_T2|MGA_A|MGA_F)
+#define MGA_WARP_T2GZS          (MGA_T2|MGA_S)
+#define MGA_WARP_T2GZSF         (MGA_T2|MGA_S|MGA_F)
+#define MGA_WARP_T2GZSA         (MGA_T2|MGA_S|MGA_A)
+#define MGA_WARP_T2GZSAF        (MGA_T2|MGA_S|MGA_F|MGA_A)
+
+#define MGA_MAX_G400_PIPES 16
+#define MGA_MAX_G200_PIPES  8	/* no multitex */
+#define MGA_MAX_WARP_PIPES MGA_MAX_G400_PIPES
+
+#define MGA_CARD_TYPE_G200 1
+#define MGA_CARD_TYPE_G400 2
+
+#define MGA_FRONT   0x1
+#define MGA_BACK    0x2
+#define MGA_DEPTH   0x4
+
+/* 3d state excluding texture units:
+ */
+#define MGA_CTXREG_DSTORG     0	/* validated */
+#define MGA_CTXREG_MACCESS    1	
+#define MGA_CTXREG_PLNWT      2 	
+#define MGA_CTXREG_DWGCTL     3	
+#define MGA_CTXREG_ALPHACTRL  4
+#define MGA_CTXREG_FOGCOLOR   5
+#define MGA_CTXREG_WFLAG      6
+#define MGA_CTXREG_TDUAL0     7
+#define MGA_CTXREG_TDUAL1     8
+#define MGA_CTXREG_FCOL       9
+#define MGA_CTXREG_STENCIL    10
+#define MGA_CTXREG_STENCILCTL 11
+#define MGA_CTX_SETUP_SIZE    12
+
+/* 2d state
+ */
+#define MGA_2DREG_PITCH 	0
+#define MGA_2D_SETUP_SIZE 	1
+
+/* Each texture unit has a state:
+ */
+#define MGA_TEXREG_CTL        0
+#define MGA_TEXREG_CTL2       1
+#define MGA_TEXREG_FILTER     2
+#define MGA_TEXREG_BORDERCOL  3
+#define MGA_TEXREG_ORG        4 /* validated */
+#define MGA_TEXREG_ORG1       5
+#define MGA_TEXREG_ORG2       6
+#define MGA_TEXREG_ORG3       7
+#define MGA_TEXREG_ORG4       8
+#define MGA_TEXREG_WIDTH      9
+#define MGA_TEXREG_HEIGHT     10
+#define MGA_TEX_SETUP_SIZE    11
+
+/* What needs to be changed for the current vertex dma buffer?
+ */
+#define MGA_UPLOAD_CTX        0x1
+#define MGA_UPLOAD_TEX0       0x2
+#define MGA_UPLOAD_TEX1       0x4
+#define MGA_UPLOAD_PIPE       0x8
+#define MGA_UPLOAD_TEX0IMAGE  0x10 /* handled client-side */
+#define MGA_UPLOAD_TEX1IMAGE  0x20 /* handled client-side */
+#define MGA_UPLOAD_2D 	      0x40
+#define MGA_WAIT_AGE          0x80 /* handled client-side */
+#define MGA_UPLOAD_CLIPRECTS  0x100 /* handled client-side */
+#define MGA_DMA_FLUSH	      0x200 /* set when someone gets the lock
+                                       quiescent */
+
+/* 32 buffers of 64k each, total 2 meg.
+ */
+#define MGA_DMA_BUF_ORDER     16
+#define MGA_DMA_BUF_SZ        (1<<MGA_DMA_BUF_ORDER)
+#define MGA_DMA_BUF_NR        31
+
+/* Keep these small for testing.
+ */
+#define MGA_NR_SAREA_CLIPRECTS 8
+
+/* 2 heaps (1 for card, 1 for agp), each divided into upto 128
+ * regions, subject to a minimum region size of (1<<16) == 64k. 
+ *
+ * Clients may subdivide regions internally, but when sharing between
+ * clients, the region size is the minimum granularity. 
+ */
+
+#define MGA_CARD_HEAP 0
+#define MGA_AGP_HEAP  1
+#define MGA_NR_TEX_HEAPS 2
+#define MGA_NR_TEX_REGIONS 16
+#define MGA_LOG_MIN_TEX_REGION_SIZE 16
+#endif
+
+typedef struct _drm_mga_warp_index {
+   	int installed;
+   	unsigned long phys_addr;
+   	int size;
+} drm_mga_warp_index_t;
+
+typedef struct drm_mga_init {
+   	enum { 
+	   	MGA_INIT_DMA = 0x01,
+	       	MGA_CLEANUP_DMA = 0x02
+	} func;
+   	int reserved_map_agpstart;
+   	int reserved_map_idx;
+   	int buffer_map_idx;
+   	int sarea_priv_offset;
+   	int primary_size;
+   	int warp_ucode_size;
+   	unsigned int frontOffset;
+   	unsigned int backOffset;
+   	unsigned int depthOffset;
+   	unsigned int textureOffset;
+   	unsigned int textureSize;
+        unsigned int agpTextureOffset;
+        unsigned int agpTextureSize;
+   	unsigned int cpp;
+   	unsigned int stride;
+   	int sgram;
+	int chipset;
+   	drm_mga_warp_index_t WarpIndex[MGA_MAX_WARP_PIPES];
+	unsigned int mAccess;
+} drm_mga_init_t;
+
+/* Warning: if you change the sarea structure, you must change the Xserver
+ * structures as well */
+
+typedef struct _drm_mga_tex_region {
+	unsigned char next, prev;	
+	unsigned char in_use;	
+	unsigned int age;			
+} drm_mga_tex_region_t;
+
+typedef struct _drm_mga_sarea {
+	/* The channel for communication of state information to the kernel
+	 * on firing a vertex dma buffer.
+	 */
+   	unsigned int ContextState[MGA_CTX_SETUP_SIZE];
+   	unsigned int ServerState[MGA_2D_SETUP_SIZE];
+   	unsigned int TexState[2][MGA_TEX_SETUP_SIZE];
+   	unsigned int WarpPipe;
+   	unsigned int dirty;
+
+   	unsigned int nbox;
+   	drm_clip_rect_t boxes[MGA_NR_SAREA_CLIPRECTS];
+
+
+	/* Information about the most recently used 3d drawable.  The
+	 * client fills in the req_* fields, the server fills in the 
+	 * exported_ fields and puts the cliprects into boxes, above.
+	 *
+	 * The client clears the exported_drawable field before
+	 * clobbering the boxes data.
+	 */
+        unsigned int req_drawable;	 /* the X drawable id */
+	unsigned int req_draw_buffer;	 /* MGA_FRONT or MGA_BACK */
+
+        unsigned int exported_drawable;	 
+	unsigned int exported_index; 
+        unsigned int exported_stamp;	
+        unsigned int exported_buffers;	 
+        unsigned int exported_nfront;
+        unsigned int exported_nback;
+	int exported_back_x, exported_front_x, exported_w;	
+	int exported_back_y, exported_front_y, exported_h;
+   	drm_clip_rect_t exported_boxes[MGA_NR_SAREA_CLIPRECTS];
+   
+	/* Counters for aging textures and for client-side throttling.
+	 */
+        unsigned int last_enqueue;	/* last time a buffer was enqueued */
+	unsigned int last_dispatch;	/* age of the most recently dispatched buffer */
+	unsigned int last_quiescent;     /*  */
+
+
+	/* LRU lists for texture memory in agp space and on the card
+	 */
+	drm_mga_tex_region_t texList[MGA_NR_TEX_HEAPS][MGA_NR_TEX_REGIONS+1];
+	unsigned int texAge[MGA_NR_TEX_HEAPS];
+	
+	/* Mechanism to validate card state.
+	 */
+   	int ctxOwner;
+   	int vertexsize;
+} drm_mga_sarea_t;	
+
+/* Device specific ioctls:
+ */
+typedef struct _drm_mga_clear {
+	unsigned int clear_color;
+	unsigned int clear_depth;
+	unsigned int flags;
+	unsigned int clear_depth_mask;
+	unsigned int clear_color_mask;
+} drm_mga_clear_t;
+
+typedef struct _drm_mga_swap {
+   	int dummy;
+} drm_mga_swap_t;
+
+typedef struct _drm_mga_iload {
+	int idx;
+	int length;
+	unsigned int destOrg;
+} drm_mga_iload_t;
+
+typedef struct _drm_mga_vertex {
+   	int idx;		/* buffer to queue */
+	int used;		/* bytes in use */
+	int discard;		/* client finished with buffer?  */
+} drm_mga_vertex_t;
+
+typedef struct _drm_mga_indices {
+   	int idx;		/* buffer to queue */
+	unsigned int start;		
+	unsigned int end;		
+	int discard;		/* client finished with buffer?  */
+} drm_mga_indices_t;
+
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/mga_drv.c linux/drivers/char/drm-4.0/mga_drv.c
--- linux.orig/drivers/char/drm-4.0/mga_drv.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/mga_drv.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,665 @@
+/* mga_drv.c -- Matrox g200/g400 driver -*- linux-c -*-
+ * Created: Mon Dec 13 01:56:22 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ *
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "mga_drv.h"
+
+#define MGA_NAME	 "mga"
+#define MGA_DESC	 "Matrox G200/G400"
+#define MGA_DATE	 "20000928"
+#define MGA_MAJOR	 2
+#define MGA_MINOR	 0
+#define MGA_PATCHLEVEL	 1
+
+static drm_device_t	      mga_device;
+drm_ctx_t		      mga_res_ctx;
+
+static struct file_operations mga_fops = {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* This started being used during 2.4.0-test */
+	owner:   THIS_MODULE,
+#endif
+	open:	 mga_open,
+	flush:	 drm_flush,
+	release: mga_release,
+	ioctl:	 mga_ioctl,
+	mmap:	 drm_mmap,
+	read:	 drm_read,
+	fasync:	 drm_fasync,
+   	poll:	 drm_poll,
+};
+
+static struct miscdevice      mga_misc = {
+	minor: MISC_DYNAMIC_MINOR,
+	name:  MGA_NAME,
+	fops:  &mga_fops,
+};
+
+static drm_ioctl_desc_t	      mga_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]     = { mga_version,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)]  = { drm_getunique,  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]   = { drm_getmagic,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]   = { drm_irq_busid,  0, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)]  = { drm_setunique,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]	      = { drm_block,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]     = { drm_unblock,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_CONTROL)]     = { mga_control,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)]  = { drm_authmagic,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]     = { drm_addmap,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)]    = { mga_addbufs,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)]   = { mga_markbufs,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)]   = { mga_infobufs,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MAP_BUFS)]    = { mga_mapbufs,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)]   = { mga_freebufs,	  1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]     = { mga_addctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]      = { mga_rmctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]     = { mga_modctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]     = { mga_getctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)]  = { mga_switchctx,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]     = { mga_newctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]     = { mga_resctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]    = { drm_adddraw,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]     = { drm_rmdraw,	  1, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_DMA)]	      = { mga_dma,	  1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	      = { mga_lock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]      = { mga_unlock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]      = { drm_finish,	  1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)] = { drm_agp_acquire, 1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)] = { drm_agp_release, 1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)]  = { drm_agp_enable,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)]    = { drm_agp_info,    1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)]   = { drm_agp_alloc,   1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)]    = { drm_agp_free,    1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)]    = { drm_agp_bind,    1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)]  = { drm_agp_unbind,  1, 1 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_MGA_INIT)]    = { mga_dma_init,    1, 1 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_MGA_SWAP)]    = { mga_swap_bufs,   1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_MGA_CLEAR)]   = { mga_clear_bufs,  1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_MGA_ILOAD)]   = { mga_iload,       1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_MGA_VERTEX)]  = { mga_vertex,      1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_MGA_FLUSH)]   = { mga_flush_ioctl, 1, 0 },
+   	[DRM_IOCTL_NR(DRM_IOCTL_MGA_INDICES)] = { mga_indices,     1, 0 },
+};
+
+#define MGA_IOCTL_COUNT DRM_ARRAY_SIZE(mga_ioctls)
+
+#ifdef MODULE
+static char		      *mga = NULL;
+#endif
+
+MODULE_AUTHOR("VA Linux Systems, Inc.");
+MODULE_DESCRIPTION("Matrox G200/G400");
+MODULE_PARM(mga, "s");
+
+#ifndef MODULE
+/* mga_options is called by the kernel to parse command-line options passed
+ * via the boot-loader (e.g., LILO).  It calls the insmod option routine,
+ * drm_parse_drm.
+ */
+
+static int __init mga_options(char *str)
+{
+	drm_parse_options(str);
+	return 1;
+}
+
+__setup("mga=", mga_options);
+#endif
+
+static int mga_setup(drm_device_t *dev)
+{
+	int i;
+
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
+	dev->buf_use	  = 0;
+	atomic_set(&dev->buf_alloc, 0);
+
+	drm_dma_setup(dev);
+
+	atomic_set(&dev->total_open, 0);
+	atomic_set(&dev->total_close, 0);
+	atomic_set(&dev->total_ioctl, 0);
+	atomic_set(&dev->total_irq, 0);
+	atomic_set(&dev->total_ctx, 0);
+	atomic_set(&dev->total_locks, 0);
+	atomic_set(&dev->total_unlocks, 0);
+	atomic_set(&dev->total_contends, 0);
+	atomic_set(&dev->total_sleeps, 0);
+
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		dev->magiclist[i].head = NULL;
+		dev->magiclist[i].tail = NULL;
+	}
+	dev->maplist	    = NULL;
+	dev->map_count	    = 0;
+	dev->vmalist	    = NULL;
+	dev->lock.hw_lock   = NULL;
+	init_waitqueue_head(&dev->lock.lock_queue);
+	dev->queue_count    = 0;
+	dev->queue_reserved = 0;
+	dev->queue_slots    = 0;
+	dev->queuelist	    = NULL;
+	dev->irq	    = 0;
+	dev->context_flag   = 0;
+	dev->interrupt_flag = 0;
+	dev->dma_flag	    = 0;
+	dev->last_context   = 0;
+	dev->last_switch    = 0;
+	dev->last_checked   = 0;
+	init_timer(&dev->timer);
+	init_waitqueue_head(&dev->context_wait);
+
+	dev->ctx_start	    = 0;
+	dev->lck_start	    = 0;
+
+	dev->buf_rp	  = dev->buf;
+	dev->buf_wp	  = dev->buf;
+	dev->buf_end	  = dev->buf + DRM_BSZ;
+	dev->buf_async	  = NULL;
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
+
+	DRM_DEBUG("\n");
+
+	/* The kernel's context could be created here, but is now created
+	   in drm_dma_enqueue.	This is more resource-efficient for
+	   hardware that does not do DMA, but may mean that
+	   drm_select_queue fails between the time the interrupt is
+	   initialized and the time the queues are initialized. */
+
+	return 0;
+}
+
+
+static int mga_takedown(drm_device_t *dev)
+{
+	int		  i;
+	drm_magic_entry_t *pt, *next;
+	drm_map_t	  *map;
+	drm_vma_entry_t	  *vma, *vma_next;
+
+	DRM_DEBUG("\n");
+
+	if (dev->dev_private) mga_dma_cleanup(dev);
+	if (dev->irq) mga_irq_uninstall(dev);
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
+
+	if (dev->devname) {
+		drm_free(dev->devname, strlen(dev->devname)+1, DRM_MEM_DRIVER);
+		dev->devname = NULL;
+	}
+
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique)+1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
+				/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
+			next = pt->next;
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+		}
+		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
+	}
+   				/* Clear AGP information */
+	if (dev->agp) {
+		drm_agp_mem_t *entry;
+		drm_agp_mem_t *nexte;
+
+				/* Remove AGP resources, but leave dev->agp
+                                   intact until cleanup is called. */
+		for (entry = dev->agp->memory; entry; entry = nexte) {
+			nexte = entry->next;
+			if (entry->bound) drm_unbind_agp(entry->memory);
+			drm_free_agp(entry->memory, entry->pages);
+			drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+		}
+		dev->agp->memory = NULL;
+
+		if (dev->agp->acquired)	_drm_agp_release();
+
+		dev->agp->acquired = 0;
+		dev->agp->enabled  = 0;
+	}
+				/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
+			vma_next = vma->next;
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		}
+		dev->vmalist = NULL;
+	}
+
+				/* Clear map area and mtrr information */
+	if (dev->maplist) {
+		for (i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			switch (map->type) {
+			case _DRM_REGISTERS:
+			case _DRM_FRAME_BUFFER:
+#ifdef CONFIG_MTRR
+				if (map->mtrr >= 0) {
+					int retcode;
+					retcode = mtrr_del(map->mtrr,
+							   map->offset,
+							   map->size);
+					DRM_DEBUG("mtrr_del = %d\n", retcode);
+				}
+#endif
+				drm_ioremapfree(map->handle, map->size, dev);
+				break;
+			case _DRM_SHM:
+				drm_free_pages((unsigned long)map->handle,
+					       drm_order(map->size)
+					       - PAGE_SHIFT,
+					       DRM_MEM_SAREA);
+				break;
+			case _DRM_AGP:
+				break;
+			}
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		}
+		drm_free(dev->maplist,
+			 dev->map_count * sizeof(*dev->maplist),
+			 DRM_MEM_MAPS);
+		dev->maplist   = NULL;
+		dev->map_count = 0;
+	}
+
+	if (dev->queuelist) {
+		for (i = 0; i < dev->queue_count; i++) {
+			drm_waitlist_destroy(&dev->queuelist[i]->waitlist);
+			if (dev->queuelist[i]) {
+				drm_free(dev->queuelist[i],
+					 sizeof(*dev->queuelist[0]),
+					 DRM_MEM_QUEUES);
+				dev->queuelist[i] = NULL;
+			}
+		}
+		drm_free(dev->queuelist,
+			 dev->queue_slots * sizeof(*dev->queuelist),
+			 DRM_MEM_QUEUES);
+		dev->queuelist	 = NULL;
+	}
+
+	drm_dma_takedown(dev);
+
+	dev->queue_count     = 0;
+	if (dev->lock.hw_lock) {
+		dev->lock.hw_lock    = NULL; /* SHM removed */
+		dev->lock.pid	     = 0;
+		wake_up_interruptible(&dev->lock.lock_queue);
+	}
+	up(&dev->struct_sem);
+
+	return 0;
+}
+
+/* mga_init is called via init_module at module load time, or via
+ * linux/init/main.c (this is not currently supported). */
+
+static int __init mga_init(void)
+{
+	int		      retcode;
+	drm_device_t	      *dev = &mga_device;
+
+	DRM_DEBUG("\n");
+
+	memset((void *)dev, 0, sizeof(*dev));
+	dev->count_lock	  = SPIN_LOCK_UNLOCKED;
+	sema_init(&dev->struct_sem, 1);
+
+#ifdef MODULE
+	drm_parse_options(mga);
+#endif
+	if ((retcode = misc_register(&mga_misc))) {
+		DRM_ERROR("Cannot register \"%s\"\n", MGA_NAME);
+		return retcode;
+	}
+	dev->device = MKDEV(MISC_MAJOR, mga_misc.minor);
+	dev->name   = MGA_NAME;
+
+	drm_mem_init();
+	drm_proc_init(dev);
+	dev->agp    = drm_agp_init();
+      	if(dev->agp == NULL) {
+	   	DRM_INFO("The mga drm module requires the agpgart module"
+		         " to function correctly\nPlease load the agpgart"
+		         " module before you load the mga module\n");
+	   	drm_proc_cleanup();
+	   	misc_deregister(&mga_misc);
+	   	mga_takedown(dev);
+	   	return -ENOMEM;
+	}
+#ifdef CONFIG_MTRR
+   	dev->agp->agp_mtrr = mtrr_add(dev->agp->agp_info.aper_base,
+				      dev->agp->agp_info.aper_size * 1024 * 1024,
+				      MTRR_TYPE_WRCOMB,
+				      1);
+#endif
+	if((retcode = drm_ctxbitmap_init(dev))) {
+		DRM_ERROR("Cannot allocate memory for context bitmap.\n");
+		drm_proc_cleanup();
+		misc_deregister(&mga_misc);
+		mga_takedown(dev);
+		return retcode;
+	}
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d\n",
+		 MGA_NAME,
+		 MGA_MAJOR,
+		 MGA_MINOR,
+		 MGA_PATCHLEVEL,
+		 MGA_DATE,
+		 mga_misc.minor);
+
+	return 0;
+}
+
+/* mga_cleanup is called via cleanup_module at module unload time. */
+
+static void __exit mga_cleanup(void)
+{
+	drm_device_t	      *dev = &mga_device;
+
+	DRM_DEBUG("\n");
+
+	drm_proc_cleanup();
+	if (misc_deregister(&mga_misc)) {
+		DRM_ERROR("Cannot unload module\n");
+	} else {
+		DRM_INFO("Module unloaded\n");
+	}
+	drm_ctxbitmap_cleanup(dev);
+#ifdef CONFIG_MTRR
+   	if(dev->agp && dev->agp->agp_mtrr) {
+	   	int retval;
+	   	retval = mtrr_del(dev->agp->agp_mtrr,
+				  dev->agp->agp_info.aper_base,
+				  dev->agp->agp_info.aper_size * 1024*1024);
+	   	DRM_DEBUG("mtrr_del = %d\n", retval);
+	}
+#endif
+
+	mga_takedown(dev);
+	if (dev->agp) {
+		drm_agp_uninit();
+		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
+		dev->agp = NULL;
+	}
+}
+
+module_init(mga_init);
+module_exit(mga_cleanup);
+
+
+int mga_version(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_version_t version;
+	int	      len;
+
+	if (copy_from_user(&version,
+			   (drm_version_t *)arg,
+			   sizeof(version)))
+		return -EFAULT;
+
+#define DRM_COPY(name,value)				     \
+	len = strlen(value);				     \
+	if (len > name##_len) len = name##_len;		     \
+	name##_len = strlen(value);			     \
+	if (len && name) {				     \
+		if (copy_to_user(name, value, len))	     \
+			return -EFAULT;			     \
+	}
+
+	version.version_major	   = MGA_MAJOR;
+	version.version_minor	   = MGA_MINOR;
+	version.version_patchlevel = MGA_PATCHLEVEL;
+
+	DRM_COPY(version.name, MGA_NAME);
+	DRM_COPY(version.date, MGA_DATE);
+	DRM_COPY(version.desc, MGA_DESC);
+
+	if (copy_to_user((drm_version_t *)arg,
+			 &version,
+			 sizeof(version)))
+		return -EFAULT;
+	return 0;
+}
+
+int mga_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t  *dev    = &mga_device;
+	int	      retcode = 0;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_open_helper(inode, filp, dev))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_INC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_open);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return mga_setup(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+	return retcode;
+}
+
+int mga_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev;
+	int	      retcode = 0;
+
+	lock_kernel();
+	dev    = priv->dev;
+	DRM_DEBUG("pid = %d, device = 0x%x, open_count = %d\n",
+		  current->pid, dev->device, dev->open_count);
+
+	if (dev->lock.hw_lock && _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)
+	    && dev->lock.pid == current->pid) {
+	      	mga_reclaim_buffers(dev, priv->pid);
+		DRM_INFO("Process %d dead (ctx %d, d_s = 0x%02lx)\n",
+			 current->pid,
+			 _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock),
+			 dev->dev_private ?
+			 ((drm_mga_private_t *)dev->dev_private)
+			 ->dispatch_status
+			 : 0);
+
+		if (dev->dev_private)
+			((drm_mga_private_t *)dev->dev_private)
+				->dispatch_status &= MGA_IN_DISPATCH;
+		
+		drm_lock_free(dev,
+			      &dev->lock.hw_lock->lock,
+			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	} else if (dev->lock.hw_lock) {
+	   	/* The lock is required to reclaim buffers */
+	   	DECLARE_WAITQUEUE(entry, current);
+	   	add_wait_queue(&dev->lock.lock_queue, &entry);
+		for (;;) {
+			current->state = TASK_INTERRUPTIBLE;
+			if (!dev->lock.hw_lock) {
+				/* Device has been unregistered */
+				retcode = -EINTR;
+				break;
+			}
+			if (drm_lock_take(&dev->lock.hw_lock->lock,
+					  DRM_KERNEL_CONTEXT)) {
+				dev->lock.pid	    = priv->pid;
+				dev->lock.lock_time = jiffies;
+				atomic_inc(&dev->total_locks);
+				break;	/* Got lock */
+			}
+				/* Contention */
+			atomic_inc(&dev->total_sleeps);
+			schedule();
+			if (signal_pending(current)) {
+				retcode = -ERESTARTSYS;
+				break;
+			}
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&dev->lock.lock_queue, &entry);
+	   	if(!retcode) {
+		   	mga_reclaim_buffers(dev, priv->pid);
+			if (dev->dev_private)
+				((drm_mga_private_t *)dev->dev_private)
+					->dispatch_status &= MGA_IN_DISPATCH;
+		   	drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				      DRM_KERNEL_CONTEXT);
+		}
+	}
+	drm_fasync(-1, filp, 0);
+
+	down(&dev->struct_sem);
+	if (priv->remove_auth_on_close == 1) {
+		drm_file_t *temp = dev->file_first;
+		while(temp) {
+			temp->authenticated = 0;
+			temp = temp->next;
+		}
+	}
+	if (priv->prev) priv->prev->next = priv->next;
+	else		dev->file_first	 = priv->next;
+	if (priv->next) priv->next->prev = priv->prev;
+	else		dev->file_last	 = priv->prev;
+	up(&dev->struct_sem);
+
+	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
+#if LINUX_VERSION_CODE < 0x020333
+	MOD_DEC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+   	atomic_inc(&dev->total_close);
+   	spin_lock(&dev->count_lock);
+   	if (!--dev->open_count) {
+	   	if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+		   	DRM_ERROR("Device busy: %d %d\n",
+				  atomic_read(&dev->ioctl_count),
+				  dev->blocked);
+		   	spin_unlock(&dev->count_lock);
+			unlock_kernel();
+		   	return -EBUSY;
+		}
+	   	spin_unlock(&dev->count_lock);
+		unlock_kernel();
+	   	return mga_takedown(dev);
+	}
+	spin_unlock(&dev->count_lock);
+	unlock_kernel();
+	return retcode;
+}
+
+
+/* drm_ioctl is called whenever a process performs an ioctl on /dev/drm. */
+
+int mga_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	int		 nr	 = DRM_IOCTL_NR(cmd);
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	int		 retcode = 0;
+	drm_ioctl_desc_t *ioctl;
+	drm_ioctl_t	 *func;
+
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->total_ioctl);
+	++priv->ioctl_count;
+
+	if (nr >= MGA_IOCTL_COUNT) {
+		retcode = -EINVAL;
+	} else {
+		ioctl	  = &mga_ioctls[nr];
+		func	  = ioctl->func;
+
+		if (!func) {
+			DRM_DEBUG("no function: pid = %d, cmd = 0x%02x,"
+				  " nr = 0x%02x, dev 0x%x, auth = %d\n",
+				  current->pid, cmd, nr, dev->device,
+				  priv->authenticated);
+			retcode = -EINVAL;
+		} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN))
+			    || (ioctl->auth_needed && !priv->authenticated)) {
+			retcode = -EACCES;
+		} else {
+			retcode = (func)(inode, filp, cmd, arg);
+		}
+	}
+
+	atomic_dec(&dev->ioctl_count);
+	return retcode;
+}
+
+int mga_unlock(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	atomic_inc(&dev->total_unlocks);
+	if (_DRM_LOCK_IS_CONT(dev->lock.hw_lock->lock))
+		atomic_inc(&dev->total_contends);
+	drm_lock_transfer(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
+	mga_dma_schedule(dev, 1);
+
+	if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+			  DRM_KERNEL_CONTEXT)) DRM_ERROR("\n");
+
+	unblock_all_signals();
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/mga_drv.h linux/drivers/char/drm-4.0/mga_drv.h
--- linux.orig/drivers/char/drm-4.0/mga_drv.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/mga_drv.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,520 @@
+/* mga_drv.h -- Private header for the Matrox g200/g400 driver -*- linux-c -*-
+ * Created: Mon Dec 13 01:50:01 1999 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Rickard E. (Rik) Faith <faith@valinux.com>
+ * 	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#ifndef _MGA_DRV_H_
+#define _MGA_DRV_H_
+
+#define MGA_BUF_IN_USE         0
+#define MGA_BUF_SWAP_PENDING   1
+#define MGA_BUF_FORCE_FIRE     2
+#define MGA_BUF_NEEDS_OVERFLOW 3
+
+typedef struct {
+	long buffer_status; /* long req'd for set_bit() --RR */
+   	int num_dwords;
+   	int max_dwords;
+   	u32 *current_dma_ptr;
+   	u32 *head;
+   	u32 phys_head;
+	unsigned int prim_age;
+   	int sec_used;
+   	int idx;
+} drm_mga_prim_buf_t;
+
+typedef struct _drm_mga_freelist {
+   	__volatile__ unsigned int age;
+   	drm_buf_t *buf;
+   	struct _drm_mga_freelist *next;
+   	struct _drm_mga_freelist *prev;
+} drm_mga_freelist_t;
+
+#define MGA_IN_DISPATCH   0
+#define MGA_IN_FLUSH      1
+#define MGA_IN_WAIT       2
+#define MGA_IN_GETBUF	  3
+
+typedef struct _drm_mga_private {
+   	long dispatch_status;  /* long req'd for set_bit() --RR */
+	unsigned int next_prim_age;
+	__volatile__ unsigned int last_prim_age;
+   	int reserved_map_idx;
+   	int buffer_map_idx;
+   	drm_mga_sarea_t *sarea_priv;
+   	int primary_size;
+   	int warp_ucode_size;
+   	int chipset;
+   	unsigned int frontOffset;
+   	unsigned int backOffset;
+   	unsigned int depthOffset;
+   	unsigned int textureOffset;
+   	unsigned int textureSize;
+   	int cpp;
+   	unsigned int stride;
+   	int sgram;
+	int use_agp;
+   	drm_mga_warp_index_t WarpIndex[MGA_MAX_G400_PIPES];
+	unsigned int WarpPipe;
+	unsigned int vertexsize;
+   	atomic_t pending_bufs;
+   	void *status_page;
+   	unsigned long real_status_page;
+   	u8 *ioremap;
+   	drm_mga_prim_buf_t **prim_bufs;
+   	drm_mga_prim_buf_t *next_prim;
+   	drm_mga_prim_buf_t *last_prim;
+   	drm_mga_prim_buf_t *current_prim;
+   	int current_prim_idx;
+   	drm_mga_freelist_t *head;
+   	drm_mga_freelist_t *tail;
+   	wait_queue_head_t flush_queue;	/* Processes waiting until flush    */
+      	wait_queue_head_t wait_queue;	/* Processes waiting until interrupt */
+	wait_queue_head_t buf_queue;    /* Processes waiting for a free buf */
+	/* Some validated register values:
+	 */
+	u32 mAccess;
+} drm_mga_private_t;
+
+				/* mga_drv.c */
+extern int  mga_version(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  mga_open(struct inode *inode, struct file *filp);
+extern int  mga_release(struct inode *inode, struct file *filp);
+extern int  mga_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  mga_unlock(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+
+				/* mga_dma.c */
+extern int  mga_dma_schedule(drm_device_t *dev, int locked);
+extern int  mga_dma(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int  mga_irq_install(drm_device_t *dev, int irq);
+extern int  mga_irq_uninstall(drm_device_t *dev);
+extern int  mga_control(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  mga_lock(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+
+/* mga_dma_init does init and release */
+extern int mga_dma_init(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int mga_dma_cleanup(drm_device_t *dev);
+extern int mga_flush_ioctl(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern unsigned int mga_create_sync_tag(drm_device_t *dev);
+extern drm_buf_t *mga_freelist_get(drm_device_t *dev);
+extern int mga_freelist_put(drm_device_t *dev, drm_buf_t *buf);
+extern int mga_advance_primary(drm_device_t *dev);
+extern void mga_reclaim_buffers(drm_device_t *dev, pid_t pid);
+
+
+				/* mga_bufs.c */
+extern int  mga_addbufs(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  mga_infobufs(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int  mga_markbufs(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int  mga_freebufs(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+extern int  mga_mapbufs(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  mga_addmap(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+				/* mga_state.c */
+extern int  mga_clear_bufs(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int  mga_swap_bufs(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  mga_iload(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int  mga_vertex(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+extern int  mga_indices(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+				/* mga_context.c */
+extern int  mga_resctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  mga_addctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  mga_modctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  mga_getctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  mga_switchctx(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  mga_newctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  mga_rmctx(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg);
+
+extern int  mga_context_switch(drm_device_t *dev, int old, int new);
+extern int  mga_context_switch_complete(drm_device_t *dev, int new);
+
+#define mga_flush_write_combine()	mb()
+
+typedef enum {
+	TT_GENERAL,
+	TT_BLIT,
+	TT_VECTOR,
+	TT_VERTEX
+} transferType_t;
+
+typedef struct {
+   	drm_mga_freelist_t *my_freelist;
+	int discard;
+	int dispatched;
+} drm_mga_buf_priv_t;
+
+#define DWGREG0 	0x1c00
+#define DWGREG0_END 	0x1dff
+#define DWGREG1		0x2c00
+#define DWGREG1_END	0x2dff
+
+#define ISREG0(r)	(r >= DWGREG0 && r <= DWGREG0_END)
+#define ADRINDEX0(r)	(u8)((r - DWGREG0) >> 2)
+#define ADRINDEX1(r)	(u8)(((r - DWGREG1) >> 2) | 0x80)
+#define ADRINDEX(r)	(ISREG0(r) ? ADRINDEX0(r) : ADRINDEX1(r))
+
+#define MGA_VERBOSE 0
+#define MGA_NUM_PRIM_BUFS 	8
+
+#define PRIMLOCALS	u8 tempIndex[4]; u32 *dma_ptr; u32 phys_head; \
+			int outcount, num_dwords
+
+#define PRIM_OVERFLOW(dev, dev_priv, length) do {			   \
+	drm_mga_prim_buf_t *tmp_buf =					   \
+ 		dev_priv->prim_bufs[dev_priv->current_prim_idx];	   \
+	if( test_bit(MGA_BUF_NEEDS_OVERFLOW, &tmp_buf->buffer_status)) {   \
+ 		mga_advance_primary(dev);				   \
+ 		mga_dma_schedule(dev, 1);				   \
+		tmp_buf = dev_priv->prim_bufs[dev_priv->current_prim_idx]; \
+ 	} else if( tmp_buf->max_dwords - tmp_buf->num_dwords < length ||   \
+ 	           tmp_buf->sec_used > MGA_DMA_BUF_NR/2) {		   \
+		set_bit(MGA_BUF_FORCE_FIRE, &tmp_buf->buffer_status);	   \
+ 		mga_advance_primary(dev);				   \
+ 		mga_dma_schedule(dev, 1);				   \
+		tmp_buf = dev_priv->prim_bufs[dev_priv->current_prim_idx]; \
+	}								   \
+	if(MGA_VERBOSE)							   \
+		DRM_DEBUG("PRIMGETPTR in %s\n", __FUNCTION__);		   \
+	dma_ptr = tmp_buf->current_dma_ptr;				   \
+	num_dwords = tmp_buf->num_dwords;				   \
+	phys_head = tmp_buf->phys_head;					   \
+	outcount = 0;							   \
+} while(0)
+
+#define PRIMGETPTR(dev_priv) do {					\
+	drm_mga_prim_buf_t *tmp_buf =					\
+		dev_priv->prim_bufs[dev_priv->current_prim_idx];	\
+	if(MGA_VERBOSE)							\
+		DRM_DEBUG("PRIMGETPTR in %s\n", __FUNCTION__);		\
+	dma_ptr = tmp_buf->current_dma_ptr;				\
+	num_dwords = tmp_buf->num_dwords;				\
+	phys_head = tmp_buf->phys_head;					\
+	outcount = 0;							\
+} while(0)
+
+#define PRIMPTR(prim_buf) do {					\
+	if(MGA_VERBOSE)						\
+		DRM_DEBUG("PRIMPTR in %s\n", __FUNCTION__);	\
+	dma_ptr = prim_buf->current_dma_ptr;			\
+	num_dwords = prim_buf->num_dwords;			\
+	phys_head = prim_buf->phys_head;			\
+	outcount = 0;						\
+} while(0)
+
+#define PRIMFINISH(prim_buf) do {				\
+	if (MGA_VERBOSE) {					\
+		DRM_DEBUG( "PRIMFINISH in %s\n", __FUNCTION__);	\
+                if (outcount & 3)				\
+                      DRM_DEBUG(" --- truncation\n");	        \
+        }							\
+	prim_buf->num_dwords = num_dwords;			\
+	prim_buf->current_dma_ptr = dma_ptr;			\
+} while(0)
+
+#define PRIMADVANCE(dev_priv)	do {				\
+drm_mga_prim_buf_t *tmp_buf = 					\
+	dev_priv->prim_bufs[dev_priv->current_prim_idx];	\
+	if (MGA_VERBOSE) {					\
+		DRM_DEBUG("PRIMADVANCE in %s\n", __FUNCTION__);	\
+                if (outcount & 3)				\
+                      DRM_DEBUG(" --- truncation\n");	\
+        }							\
+	tmp_buf->num_dwords = num_dwords;      			\
+	tmp_buf->current_dma_ptr = dma_ptr;    			\
+} while (0)
+
+#define PRIMUPDATE(dev_priv)	do {					\
+	drm_mga_prim_buf_t *tmp_buf =					\
+		dev_priv->prim_bufs[dev_priv->current_prim_idx];	\
+	tmp_buf->sec_used++;						\
+} while (0)
+
+#define AGEBUF(dev_priv, buf_priv)	do {				\
+	drm_mga_prim_buf_t *tmp_buf =					\
+		dev_priv->prim_bufs[dev_priv->current_prim_idx];	\
+	buf_priv->my_freelist->age = tmp_buf->prim_age;			\
+} while (0)
+
+
+#define PRIMOUTREG(reg, val) do {					\
+	tempIndex[outcount]=ADRINDEX(reg);				\
+	dma_ptr[1+outcount] = val;					\
+	if (MGA_VERBOSE)						\
+		DRM_DEBUG("   PRIMOUT %d: 0x%x -- 0x%x\n",		\
+		       num_dwords + 1 + outcount, ADRINDEX(reg), val);	\
+	if( ++outcount == 4) {						\
+		outcount = 0;						\
+		dma_ptr[0] = *(u32 *)tempIndex;				\
+		dma_ptr+=5;						\
+		num_dwords += 5;					\
+	}								\
+}while (0)
+
+/* A reduced set of the mga registers.
+ */
+
+#define MGAREG_MGA_EXEC 			0x0100
+#define MGAREG_ALPHACTRL 			0x2c7c
+#define MGAREG_AR0 				0x1c60
+#define MGAREG_AR1 				0x1c64
+#define MGAREG_AR2 				0x1c68
+#define MGAREG_AR3 				0x1c6c
+#define MGAREG_AR4 				0x1c70
+#define MGAREG_AR5 				0x1c74
+#define MGAREG_AR6 				0x1c78
+#define MGAREG_CXBNDRY				0x1c80
+#define MGAREG_CXLEFT 				0x1ca0
+#define MGAREG_CXRIGHT				0x1ca4
+#define MGAREG_DMAPAD 				0x1c54
+#define MGAREG_DSTORG 				0x2cb8
+#define MGAREG_DWGCTL 				0x1c00
+#define MGAREG_DWGSYNC				0x2c4c
+#define MGAREG_FCOL 				0x1c24
+#define MGAREG_FIFOSTATUS 			0x1e10
+#define MGAREG_FOGCOL 				0x1cf4
+#define MGAREG_FXBNDRY				0x1c84
+#define MGAREG_FXLEFT 				0x1ca8
+#define MGAREG_FXRIGHT				0x1cac
+#define MGAREG_ICLEAR 				0x1e18
+#define MGAREG_IEN 				0x1e1c
+#define MGAREG_LEN 				0x1c5c
+#define MGAREG_MACCESS				0x1c04
+#define MGAREG_PITCH 				0x1c8c
+#define MGAREG_PLNWT 				0x1c1c
+#define MGAREG_PRIMADDRESS 			0x1e58
+#define MGAREG_PRIMEND				0x1e5c
+#define MGAREG_PRIMPTR				0x1e50
+#define MGAREG_SECADDRESS 			0x2c40
+#define MGAREG_SECEND 				0x2c44
+#define MGAREG_SETUPADDRESS 			0x2cd0
+#define MGAREG_SETUPEND 			0x2cd4
+#define MGAREG_SOFTRAP				0x2c48
+#define MGAREG_SRCORG 				0x2cb4
+#define MGAREG_STATUS 				0x1e14
+#define MGAREG_STENCIL				0x2cc8
+#define MGAREG_STENCILCTL 			0x2ccc
+#define MGAREG_TDUALSTAGE0 			0x2cf8
+#define MGAREG_TDUALSTAGE1 			0x2cfc
+#define MGAREG_TEXBORDERCOL 			0x2c5c
+#define MGAREG_TEXCTL 				0x2c30
+#define MGAREG_TEXCTL2				0x2c3c
+#define MGAREG_TEXFILTER 			0x2c58
+#define MGAREG_TEXHEIGHT 			0x2c2c
+#define MGAREG_TEXORG 				0x2c24
+#define MGAREG_TEXORG1				0x2ca4
+#define MGAREG_TEXORG2				0x2ca8
+#define MGAREG_TEXORG3				0x2cac
+#define MGAREG_TEXORG4				0x2cb0
+#define MGAREG_TEXTRANS 			0x2c34
+#define MGAREG_TEXTRANSHIGH 			0x2c38
+#define MGAREG_TEXWIDTH 			0x2c28
+#define MGAREG_WACCEPTSEQ 			0x1dd4
+#define MGAREG_WCODEADDR 			0x1e6c
+#define MGAREG_WFLAG 				0x1dc4
+#define MGAREG_WFLAG1 				0x1de0
+#define MGAREG_WFLAGNB				0x1e64
+#define MGAREG_WFLAGNB1 			0x1e08
+#define MGAREG_WGETMSB				0x1dc8
+#define MGAREG_WIADDR 				0x1dc0
+#define MGAREG_WIADDR2				0x1dd8
+#define MGAREG_WMISC 				0x1e70
+#define MGAREG_WVRTXSZ				0x1dcc
+#define MGAREG_YBOT 				0x1c9c
+#define MGAREG_YDST 				0x1c90
+#define MGAREG_YDSTLEN				0x1c88
+#define MGAREG_YDSTORG				0x1c94
+#define MGAREG_YTOP 				0x1c98
+#define MGAREG_ZORG 				0x1c0c
+
+/* Warp registers */
+#define MGAREG_WR0                              0x2d00
+#define MGAREG_WR1                              0x2d04
+#define MGAREG_WR2                              0x2d08
+#define MGAREG_WR3                              0x2d0c
+#define MGAREG_WR4                              0x2d10
+#define MGAREG_WR5                              0x2d14
+#define MGAREG_WR6                              0x2d18
+#define MGAREG_WR7                              0x2d1c
+#define MGAREG_WR8                              0x2d20
+#define MGAREG_WR9                              0x2d24
+#define MGAREG_WR10                             0x2d28
+#define MGAREG_WR11                             0x2d2c
+#define MGAREG_WR12                             0x2d30
+#define MGAREG_WR13                             0x2d34
+#define MGAREG_WR14                             0x2d38
+#define MGAREG_WR15                             0x2d3c
+#define MGAREG_WR16                             0x2d40
+#define MGAREG_WR17                             0x2d44
+#define MGAREG_WR18                             0x2d48
+#define MGAREG_WR19                             0x2d4c
+#define MGAREG_WR20                             0x2d50
+#define MGAREG_WR21                             0x2d54
+#define MGAREG_WR22                             0x2d58
+#define MGAREG_WR23                             0x2d5c
+#define MGAREG_WR24                             0x2d60
+#define MGAREG_WR25                             0x2d64
+#define MGAREG_WR26                             0x2d68
+#define MGAREG_WR27                             0x2d6c
+#define MGAREG_WR28                             0x2d70
+#define MGAREG_WR29                             0x2d74
+#define MGAREG_WR30                             0x2d78
+#define MGAREG_WR31                             0x2d7c
+#define MGAREG_WR32                             0x2d80
+#define MGAREG_WR33                             0x2d84
+#define MGAREG_WR34                             0x2d88
+#define MGAREG_WR35                             0x2d8c
+#define MGAREG_WR36                             0x2d90
+#define MGAREG_WR37                             0x2d94
+#define MGAREG_WR38                             0x2d98
+#define MGAREG_WR39                             0x2d9c
+#define MGAREG_WR40                             0x2da0
+#define MGAREG_WR41                             0x2da4
+#define MGAREG_WR42                             0x2da8
+#define MGAREG_WR43                             0x2dac
+#define MGAREG_WR44                             0x2db0
+#define MGAREG_WR45                             0x2db4
+#define MGAREG_WR46                             0x2db8
+#define MGAREG_WR47                             0x2dbc
+#define MGAREG_WR48                             0x2dc0
+#define MGAREG_WR49                             0x2dc4
+#define MGAREG_WR50                             0x2dc8
+#define MGAREG_WR51                             0x2dcc
+#define MGAREG_WR52                             0x2dd0
+#define MGAREG_WR53                             0x2dd4
+#define MGAREG_WR54                             0x2dd8
+#define MGAREG_WR55                             0x2ddc
+#define MGAREG_WR56                             0x2de0
+#define MGAREG_WR57                             0x2de4
+#define MGAREG_WR58                             0x2de8
+#define MGAREG_WR59                             0x2dec
+#define MGAREG_WR60                             0x2df0
+#define MGAREG_WR61                             0x2df4
+#define MGAREG_WR62                             0x2df8
+#define MGAREG_WR63                             0x2dfc
+
+#define PDEA_pagpxfer_enable			0x2
+
+#define WIA_wmode_suspend			0x0
+#define WIA_wmode_start 			0x3
+#define WIA_wagp_agp				0x4
+
+#define DC_opcod_line_open 			0x0
+#define DC_opcod_autoline_open 			0x1
+#define DC_opcod_line_close 			0x2
+#define DC_opcod_autoline_close 		0x3
+#define DC_opcod_trap 				0x4
+#define DC_opcod_texture_trap 			0x6
+#define DC_opcod_bitblt 			0x8
+#define DC_opcod_iload 				0x9
+#define DC_atype_rpl 				0x0
+#define DC_atype_rstr 				0x10
+#define DC_atype_zi 				0x30
+#define DC_atype_blk 				0x40
+#define DC_atype_i 				0x70
+#define DC_linear_xy 				0x0
+#define DC_linear_linear 			0x80
+#define DC_zmode_nozcmp 			0x0
+#define DC_zmode_ze 				0x200
+#define DC_zmode_zne 				0x300
+#define DC_zmode_zlt 				0x400
+#define DC_zmode_zlte 				0x500
+#define DC_zmode_zgt 				0x600
+#define DC_zmode_zgte 				0x700
+#define DC_solid_disable 			0x0
+#define DC_solid_enable 			0x800
+#define DC_arzero_disable 			0x0
+#define DC_arzero_enable 			0x1000
+#define DC_sgnzero_disable 			0x0
+#define DC_sgnzero_enable 			0x2000
+#define DC_shftzero_disable 			0x0
+#define DC_shftzero_enable 			0x4000
+#define DC_bop_SHIFT 				16
+#define DC_trans_SHIFT 				20
+#define DC_bltmod_bmonolef 			0x0
+#define DC_bltmod_bmonowf 			0x8000000
+#define DC_bltmod_bplan 			0x2000000
+#define DC_bltmod_bfcol 			0x4000000
+#define DC_bltmod_bu32bgr 			0x6000000
+#define DC_bltmod_bu32rgb 			0xe000000
+#define DC_bltmod_bu24bgr 			0x16000000
+#define DC_bltmod_bu24rgb 			0x1e000000
+#define DC_pattern_disable 			0x0
+#define DC_pattern_enable 			0x20000000
+#define DC_transc_disable 			0x0
+#define DC_transc_enable 			0x40000000
+#define DC_clipdis_disable 			0x0
+#define DC_clipdis_enable 			0x80000000
+
+
+#define SETADD_mode_vertlist                   	0x0
+
+
+#define MGA_CLEAR_CMD (DC_opcod_trap | DC_arzero_enable | 		\
+		       DC_sgnzero_enable | DC_shftzero_enable | 	\
+		       (0xC << DC_bop_SHIFT) | DC_clipdis_enable | 	\
+		       DC_solid_enable | DC_transc_enable)
+
+
+#define MGA_COPY_CMD (DC_opcod_bitblt | DC_atype_rpl | DC_linear_xy |	\
+		      DC_solid_disable | DC_arzero_disable | 		\
+		      DC_sgnzero_enable | DC_shftzero_enable | 		\
+		      (0xC << DC_bop_SHIFT) | DC_bltmod_bfcol | 	\
+		      DC_pattern_disable | DC_transc_disable | 		\
+		      DC_clipdis_enable)				\
+
+#define MGA_FLUSH_CMD (DC_opcod_texture_trap | (0xF << DC_trans_SHIFT) |\
+		       DC_arzero_enable | DC_sgnzero_enable |		\
+		       DC_atype_i)
+
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/mga_state.c linux/drivers/char/drm-4.0/mga_state.c
--- linux.orig/drivers/char/drm-4.0/mga_state.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/mga_state.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1017 @@
+/* mga_state.c -- State support for mga g200/g400 -*- linux-c -*-
+ * Created: Thu Jan 27 02:53:43 2000 by jhartmann@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Jeff Hartmann <jhartmann@valinux.com>
+ * 	    Keith Whitwell <keithw@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "mga_drv.h"
+#include "drm.h"
+
+/* If you change the functions to set state, PLEASE
+ * change these values
+ */
+
+#define MGAEMITCLIP_SIZE	10
+#define MGAEMITCTX_SIZE		20
+#define MGAG200EMITTEX_SIZE 	20
+#define MGAG400EMITTEX0_SIZE	30
+#define MGAG400EMITTEX1_SIZE	25
+#define MGAG400EMITPIPE_SIZE	50
+#define MGAG200EMITPIPE_SIZE	15
+
+#define MAX_STATE_SIZE ((MGAEMITCLIP_SIZE * MGA_NR_SAREA_CLIPRECTS) + \
+			MGAEMITCTX_SIZE + MGAG400EMITTEX0_SIZE + \
+			MGAG400EMITTEX1_SIZE + MGAG400EMITPIPE_SIZE)
+
+static void mgaEmitClipRect(drm_mga_private_t * dev_priv,
+			    drm_clip_rect_t * box)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->ContextState;
+	PRIMLOCALS;
+
+	/* This takes 10 dwords */
+	PRIMGETPTR(dev_priv);
+
+	/* Force reset of dwgctl on G400 (eliminates clip disable bit) */
+	if (dev_priv->chipset == MGA_CARD_TYPE_G400) {
+#if 0
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DWGSYNC, 0);
+		PRIMOUTREG(MGAREG_DWGSYNC, 0);
+		PRIMOUTREG(MGAREG_DWGCTL, regs[MGA_CTXREG_DWGCTL]);
+#else
+		PRIMOUTREG(MGAREG_DWGCTL, regs[MGA_CTXREG_DWGCTL]);
+		PRIMOUTREG(MGAREG_LEN + MGAREG_MGA_EXEC, 0x80000000);
+		PRIMOUTREG(MGAREG_DWGCTL, regs[MGA_CTXREG_DWGCTL]);
+		PRIMOUTREG(MGAREG_LEN + MGAREG_MGA_EXEC, 0x80000000);
+#endif
+	}
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_CXBNDRY, ((box->x2) << 16) | (box->x1));
+	PRIMOUTREG(MGAREG_YTOP, box->y1 * dev_priv->stride / dev_priv->cpp);
+	PRIMOUTREG(MGAREG_YBOT, box->y2 * dev_priv->stride / dev_priv->cpp);
+
+	PRIMADVANCE(dev_priv);
+}
+
+static void mgaEmitContext(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->ContextState;
+	PRIMLOCALS;
+
+	/* This takes a max of 20 dwords */
+	PRIMGETPTR(dev_priv);
+
+	PRIMOUTREG(MGAREG_DSTORG, regs[MGA_CTXREG_DSTORG]);
+	PRIMOUTREG(MGAREG_MACCESS, regs[MGA_CTXREG_MACCESS]);
+	PRIMOUTREG(MGAREG_PLNWT, regs[MGA_CTXREG_PLNWT]);
+	PRIMOUTREG(MGAREG_DWGCTL, regs[MGA_CTXREG_DWGCTL]);
+
+	PRIMOUTREG(MGAREG_ALPHACTRL, regs[MGA_CTXREG_ALPHACTRL]);
+	PRIMOUTREG(MGAREG_FOGCOL, regs[MGA_CTXREG_FOGCOLOR]);
+	PRIMOUTREG(MGAREG_WFLAG, regs[MGA_CTXREG_WFLAG]);
+	PRIMOUTREG(MGAREG_ZORG, dev_priv->depthOffset);	/* invarient */
+
+	if (dev_priv->chipset == MGA_CARD_TYPE_G400) {
+		PRIMOUTREG(MGAREG_WFLAG1, regs[MGA_CTXREG_WFLAG]);
+		PRIMOUTREG(MGAREG_TDUALSTAGE0, regs[MGA_CTXREG_TDUAL0]);
+		PRIMOUTREG(MGAREG_TDUALSTAGE1, regs[MGA_CTXREG_TDUAL1]);
+		PRIMOUTREG(MGAREG_FCOL, regs[MGA_CTXREG_FCOL]);
+
+		PRIMOUTREG(MGAREG_STENCIL, regs[MGA_CTXREG_STENCIL]);
+		PRIMOUTREG(MGAREG_STENCILCTL, regs[MGA_CTXREG_STENCILCTL]);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+	} else {
+		PRIMOUTREG(MGAREG_FCOL, regs[MGA_CTXREG_FCOL]);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+	}
+
+	PRIMADVANCE(dev_priv);
+}
+
+static void mgaG200EmitTex(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->TexState[0];
+	PRIMLOCALS;
+
+	PRIMGETPTR(dev_priv);
+
+	/* This takes 20 dwords */
+
+	PRIMOUTREG(MGAREG_TEXCTL2, regs[MGA_TEXREG_CTL2]);
+	PRIMOUTREG(MGAREG_TEXCTL, regs[MGA_TEXREG_CTL]);
+	PRIMOUTREG(MGAREG_TEXFILTER, regs[MGA_TEXREG_FILTER]);
+	PRIMOUTREG(MGAREG_TEXBORDERCOL, regs[MGA_TEXREG_BORDERCOL]);
+
+	PRIMOUTREG(MGAREG_TEXORG, regs[MGA_TEXREG_ORG]);
+	PRIMOUTREG(MGAREG_TEXORG1, regs[MGA_TEXREG_ORG1]);
+	PRIMOUTREG(MGAREG_TEXORG2, regs[MGA_TEXREG_ORG2]);
+	PRIMOUTREG(MGAREG_TEXORG3, regs[MGA_TEXREG_ORG3]);
+
+	PRIMOUTREG(MGAREG_TEXORG4, regs[MGA_TEXREG_ORG4]);
+	PRIMOUTREG(MGAREG_TEXWIDTH, regs[MGA_TEXREG_WIDTH]);
+	PRIMOUTREG(MGAREG_TEXHEIGHT, regs[MGA_TEXREG_HEIGHT]);
+	PRIMOUTREG(MGAREG_WR24, regs[MGA_TEXREG_WIDTH]);
+
+	PRIMOUTREG(MGAREG_WR34, regs[MGA_TEXREG_HEIGHT]);
+	PRIMOUTREG(MGAREG_TEXTRANS, 0xffff);
+	PRIMOUTREG(MGAREG_TEXTRANSHIGH, 0xffff);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+
+	PRIMADVANCE(dev_priv);
+}
+
+#define TMC_dualtex_enable 		0x80
+
+static void mgaG400EmitTex0(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->TexState[0];
+	PRIMLOCALS;
+
+	PRIMGETPTR(dev_priv);
+
+	/* This takes 30 dwords */
+
+	PRIMOUTREG(MGAREG_TEXCTL2, regs[MGA_TEXREG_CTL2] | 0x00008000);
+	PRIMOUTREG(MGAREG_TEXCTL, regs[MGA_TEXREG_CTL]);
+	PRIMOUTREG(MGAREG_TEXFILTER, regs[MGA_TEXREG_FILTER]);
+	PRIMOUTREG(MGAREG_TEXBORDERCOL, regs[MGA_TEXREG_BORDERCOL]);
+
+	PRIMOUTREG(MGAREG_TEXORG, regs[MGA_TEXREG_ORG]);
+	PRIMOUTREG(MGAREG_TEXORG1, regs[MGA_TEXREG_ORG1]);
+	PRIMOUTREG(MGAREG_TEXORG2, regs[MGA_TEXREG_ORG2]);
+	PRIMOUTREG(MGAREG_TEXORG3, regs[MGA_TEXREG_ORG3]);
+
+	PRIMOUTREG(MGAREG_TEXORG4, regs[MGA_TEXREG_ORG4]);
+	PRIMOUTREG(MGAREG_TEXWIDTH, regs[MGA_TEXREG_WIDTH]);
+	PRIMOUTREG(MGAREG_TEXHEIGHT, regs[MGA_TEXREG_HEIGHT]);
+	PRIMOUTREG(MGAREG_WR49, 0);
+
+	PRIMOUTREG(MGAREG_WR57, 0);
+	PRIMOUTREG(MGAREG_WR53, 0);
+	PRIMOUTREG(MGAREG_WR61, 0);
+	PRIMOUTREG(MGAREG_WR52, 0x40);
+
+	PRIMOUTREG(MGAREG_WR60, 0x40);
+	PRIMOUTREG(MGAREG_WR54, regs[MGA_TEXREG_WIDTH] | 0x40);
+	PRIMOUTREG(MGAREG_WR62, regs[MGA_TEXREG_HEIGHT] | 0x40);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_TEXTRANS, 0xffff);
+	PRIMOUTREG(MGAREG_TEXTRANSHIGH, 0xffff);
+
+	PRIMADVANCE(dev_priv);
+}
+
+#define TMC_map1_enable 		0x80000000
+
+static void mgaG400EmitTex1(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->TexState[1];
+	PRIMLOCALS;
+
+	PRIMGETPTR(dev_priv);
+
+	/* This takes 25 dwords */
+
+	PRIMOUTREG(MGAREG_TEXCTL2,
+		   regs[MGA_TEXREG_CTL2] | TMC_map1_enable | 0x00008000);
+	PRIMOUTREG(MGAREG_TEXCTL, regs[MGA_TEXREG_CTL]);
+	PRIMOUTREG(MGAREG_TEXFILTER, regs[MGA_TEXREG_FILTER]);
+	PRIMOUTREG(MGAREG_TEXBORDERCOL, regs[MGA_TEXREG_BORDERCOL]);
+
+	PRIMOUTREG(MGAREG_TEXORG, regs[MGA_TEXREG_ORG]);
+	PRIMOUTREG(MGAREG_TEXORG1, regs[MGA_TEXREG_ORG1]);
+	PRIMOUTREG(MGAREG_TEXORG2, regs[MGA_TEXREG_ORG2]);
+	PRIMOUTREG(MGAREG_TEXORG3, regs[MGA_TEXREG_ORG3]);
+
+	PRIMOUTREG(MGAREG_TEXORG4, regs[MGA_TEXREG_ORG4]);
+	PRIMOUTREG(MGAREG_TEXWIDTH, regs[MGA_TEXREG_WIDTH]);
+	PRIMOUTREG(MGAREG_TEXHEIGHT, regs[MGA_TEXREG_HEIGHT]);
+	PRIMOUTREG(MGAREG_WR49, 0);
+
+	PRIMOUTREG(MGAREG_WR57, 0);
+	PRIMOUTREG(MGAREG_WR53, 0);
+	PRIMOUTREG(MGAREG_WR61, 0);
+	PRIMOUTREG(MGAREG_WR52, regs[MGA_TEXREG_WIDTH] | 0x40);
+
+	PRIMOUTREG(MGAREG_WR60, regs[MGA_TEXREG_HEIGHT] | 0x40);
+	PRIMOUTREG(MGAREG_TEXTRANS, 0xffff);
+	PRIMOUTREG(MGAREG_TEXTRANSHIGH, 0xffff);
+	PRIMOUTREG(MGAREG_TEXCTL2, regs[MGA_TEXREG_CTL2] | 0x00008000);
+
+	PRIMADVANCE(dev_priv);
+}
+
+#define MAGIC_FPARAM_HEX_VALUE 0x46480000
+/* This is the hex value of 12800.0f which is a magic value we must
+ * set in wr56.
+ */
+
+static void mgaG400EmitPipe(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int pipe = sarea_priv->WarpPipe;
+	PRIMLOCALS;
+
+	PRIMGETPTR(dev_priv);
+
+	/* This takes 50 dwords */
+
+	/* Establish vertex size.  
+	 */
+	PRIMOUTREG(MGAREG_WIADDR2, WIA_wmode_suspend);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+
+	if (pipe & MGA_T2) {
+		PRIMOUTREG(MGAREG_WVRTXSZ, 0x00001e09);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0);
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0);
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0);
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0x1e000000);
+	} else {
+		if (dev_priv->WarpPipe & MGA_T2) {
+			/* Flush the WARP pipe */
+			PRIMOUTREG(MGAREG_YDST, 0);
+			PRIMOUTREG(MGAREG_FXLEFT, 0);
+			PRIMOUTREG(MGAREG_FXRIGHT, 1);
+			PRIMOUTREG(MGAREG_DWGCTL, MGA_FLUSH_CMD);
+
+			PRIMOUTREG(MGAREG_LEN + MGAREG_MGA_EXEC, 1);
+			PRIMOUTREG(MGAREG_DWGSYNC, 0x7000);
+			PRIMOUTREG(MGAREG_TEXCTL2, 0x00008000);
+			PRIMOUTREG(MGAREG_LEN + MGAREG_MGA_EXEC, 0);
+
+			PRIMOUTREG(MGAREG_TEXCTL2, 0x80 | 0x00008000);
+			PRIMOUTREG(MGAREG_LEN + MGAREG_MGA_EXEC, 0);
+			PRIMOUTREG(MGAREG_TEXCTL2, 0x00008000);
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+		}
+
+		PRIMOUTREG(MGAREG_WVRTXSZ, 0x00001807);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+		PRIMOUTREG(MGAREG_DMAPAD, 0);
+
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0);
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0);
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0);
+		PRIMOUTREG(MGAREG_WACCEPTSEQ, 0x18000000);
+	}
+
+	PRIMOUTREG(MGAREG_WFLAG, 0);
+	PRIMOUTREG(MGAREG_WFLAG1, 0);
+	PRIMOUTREG(MGAREG_WR56, MAGIC_FPARAM_HEX_VALUE);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+
+	PRIMOUTREG(MGAREG_WR49, 0);	/* Tex stage 0 */
+	PRIMOUTREG(MGAREG_WR57, 0);	/* Tex stage 0 */
+	PRIMOUTREG(MGAREG_WR53, 0);	/* Tex stage 1 */
+	PRIMOUTREG(MGAREG_WR61, 0);	/* Tex stage 1 */
+
+	PRIMOUTREG(MGAREG_WR54, 0x40);	/* Tex stage 0 : w */
+	PRIMOUTREG(MGAREG_WR62, 0x40);	/* Tex stage 0 : h */
+	PRIMOUTREG(MGAREG_WR52, 0x40);	/* Tex stage 1 : w */
+	PRIMOUTREG(MGAREG_WR60, 0x40);	/* Tex stage 1 : h */
+
+	/* Dma pading required due to hw bug */
+	PRIMOUTREG(MGAREG_DMAPAD, 0xffffffff);
+	PRIMOUTREG(MGAREG_DMAPAD, 0xffffffff);
+	PRIMOUTREG(MGAREG_DMAPAD, 0xffffffff);
+	PRIMOUTREG(MGAREG_WIADDR2,
+		   (u32) (dev_priv->WarpIndex[pipe].
+			  phys_addr | WIA_wmode_start | WIA_wagp_agp));
+	PRIMADVANCE(dev_priv);
+}
+
+static void mgaG200EmitPipe(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int pipe = sarea_priv->WarpPipe;
+	PRIMLOCALS;
+
+	PRIMGETPTR(dev_priv);
+
+	/* This takes 15 dwords */
+
+	PRIMOUTREG(MGAREG_WIADDR, WIA_wmode_suspend);
+	PRIMOUTREG(MGAREG_WVRTXSZ, 7);
+	PRIMOUTREG(MGAREG_WFLAG, 0);
+	PRIMOUTREG(MGAREG_WR24, 0);	/* tex w/h */
+
+	PRIMOUTREG(MGAREG_WR25, 0x100);
+	PRIMOUTREG(MGAREG_WR34, 0);	/* tex w/h */
+	PRIMOUTREG(MGAREG_WR42, 0xFFFF);
+	PRIMOUTREG(MGAREG_WR60, 0xFFFF);
+
+	/* Dma pading required due to hw bug */
+	PRIMOUTREG(MGAREG_DMAPAD, 0xffffffff);
+	PRIMOUTREG(MGAREG_DMAPAD, 0xffffffff);
+	PRIMOUTREG(MGAREG_DMAPAD, 0xffffffff);
+	PRIMOUTREG(MGAREG_WIADDR,
+		   (u32) (dev_priv->WarpIndex[pipe].
+			  phys_addr | WIA_wmode_start | WIA_wagp_agp));
+
+	PRIMADVANCE( dev_priv );
+}
+
+static void mgaEmitState(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+
+	if (dev_priv->chipset == MGA_CARD_TYPE_G400) {
+		int multitex = sarea_priv->WarpPipe & MGA_T2;
+
+		if (sarea_priv->WarpPipe != dev_priv->WarpPipe) {
+			mgaG400EmitPipe(dev_priv);
+			dev_priv->WarpPipe = sarea_priv->WarpPipe;
+		}
+
+		if (dirty & MGA_UPLOAD_CTX) {
+			mgaEmitContext(dev_priv);
+			sarea_priv->dirty &= ~MGA_UPLOAD_CTX;
+		}
+
+		if (dirty & MGA_UPLOAD_TEX0) {
+			mgaG400EmitTex0(dev_priv);
+			sarea_priv->dirty &= ~MGA_UPLOAD_TEX0;
+		}
+
+		if ((dirty & MGA_UPLOAD_TEX1) && multitex) {
+			mgaG400EmitTex1(dev_priv);
+			sarea_priv->dirty &= ~MGA_UPLOAD_TEX1;
+		}
+	} else {
+		if (sarea_priv->WarpPipe != dev_priv->WarpPipe) {
+			mgaG200EmitPipe(dev_priv);
+			dev_priv->WarpPipe = sarea_priv->WarpPipe;
+		}
+
+		if (dirty & MGA_UPLOAD_CTX) {
+			mgaEmitContext(dev_priv);
+			sarea_priv->dirty &= ~MGA_UPLOAD_CTX;
+		}
+
+		if (dirty & MGA_UPLOAD_TEX0) {
+			mgaG200EmitTex(dev_priv);
+			sarea_priv->dirty &= ~MGA_UPLOAD_TEX0;
+		}
+	}
+}
+
+/* Disallow all write destinations except the front and backbuffer.
+ */
+static int mgaVerifyContext(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->ContextState;
+
+	if (regs[MGA_CTXREG_DSTORG] != dev_priv->frontOffset &&
+	    regs[MGA_CTXREG_DSTORG] != dev_priv->backOffset) {
+		DRM_DEBUG("BAD DSTORG: %x (front %x, back %x)\n\n",
+			  regs[MGA_CTXREG_DSTORG], dev_priv->frontOffset,
+			  dev_priv->backOffset);
+		regs[MGA_CTXREG_DSTORG] = 0;
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Disallow texture reads from PCI space.
+ */
+static int mgaVerifyTex(drm_mga_private_t * dev_priv, int unit)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+
+	if ((sarea_priv->TexState[unit][MGA_TEXREG_ORG] & 0x3) == 0x1) {
+		DRM_DEBUG("BAD TEXREG_ORG: %x, unit %d\n",
+			  sarea_priv->TexState[unit][MGA_TEXREG_ORG],
+			  unit);
+		sarea_priv->TexState[unit][MGA_TEXREG_ORG] = 0;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int mgaVerifyState(drm_mga_private_t * dev_priv)
+{
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+	int rv = 0;
+
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
+
+	if (dirty & MGA_UPLOAD_CTX)
+		rv |= mgaVerifyContext(dev_priv);
+
+	if (dirty & MGA_UPLOAD_TEX0)
+		rv |= mgaVerifyTex(dev_priv, 0);
+
+	if (dev_priv->chipset == MGA_CARD_TYPE_G400) {
+		if (dirty & MGA_UPLOAD_TEX1)
+			rv |= mgaVerifyTex(dev_priv, 1);
+
+		if (dirty & MGA_UPLOAD_PIPE)
+			rv |= (sarea_priv->WarpPipe > MGA_MAX_G400_PIPES);
+	} else {
+		if (dirty & MGA_UPLOAD_PIPE)
+			rv |= (sarea_priv->WarpPipe > MGA_MAX_G200_PIPES);
+	}
+
+	return rv == 0;
+}
+
+static int mgaVerifyIload(drm_mga_private_t * dev_priv,
+			  unsigned long bus_address,
+			  unsigned int dstOrg, int length)
+{
+	if (dstOrg < dev_priv->textureOffset ||
+	    dstOrg + length >
+	    (dev_priv->textureOffset + dev_priv->textureSize)) {
+		return -EINVAL;
+	}
+	if (length % 64) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This copies a 64 byte aligned agp region to the frambuffer
+ * with a standard blit, the ioctl needs to do checking */
+
+static void mga_dma_dispatch_tex_blit(drm_device_t * dev,
+				      unsigned long bus_address,
+				      int length, unsigned int destOrg)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	int use_agp = PDEA_pagpxfer_enable | 0x00000001;
+	u16 y2;
+	PRIMLOCALS;
+
+	y2 = length / 64;
+
+	PRIM_OVERFLOW(dev, dev_priv, 30);
+
+	PRIMOUTREG(MGAREG_DSTORG, destOrg);
+	PRIMOUTREG(MGAREG_MACCESS, 0x00000000);
+	PRIMOUTREG(MGAREG_SRCORG, (u32) bus_address | use_agp);
+	PRIMOUTREG(MGAREG_AR5, 64);
+
+	PRIMOUTREG(MGAREG_PITCH, 64);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DWGCTL, MGA_COPY_CMD);
+
+	PRIMOUTREG(MGAREG_AR0, 63);
+	PRIMOUTREG(MGAREG_AR3, 0);
+	PRIMOUTREG(MGAREG_FXBNDRY, (63 << 16));
+	PRIMOUTREG(MGAREG_YDSTLEN + MGAREG_MGA_EXEC, y2);
+
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_SRCORG, 0);
+	PRIMOUTREG(MGAREG_PITCH, dev_priv->stride / dev_priv->cpp);
+	PRIMOUTREG(MGAREG_DWGSYNC, 0x7000);
+	PRIMADVANCE(dev_priv);
+}
+
+static void mga_dma_dispatch_vertex(drm_device_t * dev, drm_buf_t * buf)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned long address = (unsigned long) buf->bus_address;
+	int length = buf->used;
+	int use_agp = PDEA_pagpxfer_enable;
+	int i = 0;
+	PRIMLOCALS;
+
+	if (buf->used) {
+		/* WARNING: if you change any of the state functions verify
+		 * these numbers (Overestimating this doesn't hurt).
+		 */
+		buf_priv->dispatched = 1;
+		PRIM_OVERFLOW(dev, dev_priv,
+			      (MAX_STATE_SIZE + (5 * MGA_NR_SAREA_CLIPRECTS)));
+		mgaEmitState(dev_priv);
+
+#if 0
+		length = dev_priv->vertexsize * 3 * 4;
+#endif
+
+		do {
+			if (i < sarea_priv->nbox) {
+				mgaEmitClipRect(dev_priv,
+						&sarea_priv->boxes[i]);
+			}
+
+			PRIMGETPTR(dev_priv);
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_SECADDRESS,
+				   ((u32) address) | TT_VERTEX);
+			PRIMOUTREG(MGAREG_SECEND,
+				   (((u32) (address + length)) | use_agp));
+			PRIMADVANCE(dev_priv);
+		} while (++i < sarea_priv->nbox);
+	}
+	if (buf_priv->discard) {
+		if (buf_priv->dispatched == 1)
+			AGEBUF(dev_priv, buf_priv);
+		buf_priv->dispatched = 0;
+		mga_freelist_put(dev, buf);
+	}
+
+
+}
+
+
+static void mga_dma_dispatch_indices(drm_device_t * dev,
+				     drm_buf_t * buf,
+				     unsigned int start, unsigned int end)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_buf_priv_t *buf_priv = buf->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int address = (unsigned int) buf->bus_address;
+	int use_agp = PDEA_pagpxfer_enable;
+	int i = 0;
+	PRIMLOCALS;
+
+	if (start != end) {
+		/* WARNING: if you change any of the state functions verify
+		 * these numbers (Overestimating this doesn't hurt).
+		 */
+		buf_priv->dispatched = 1;
+		PRIM_OVERFLOW(dev, dev_priv,
+			      (MAX_STATE_SIZE + (5 * MGA_NR_SAREA_CLIPRECTS)));
+		mgaEmitState(dev_priv);
+
+		do {
+			if (i < sarea_priv->nbox) {
+				mgaEmitClipRect(dev_priv,
+						&sarea_priv->boxes[i]);
+			}
+
+			PRIMGETPTR(dev_priv);
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_SETUPADDRESS,
+				   ((address + start) |
+				    SETADD_mode_vertlist));
+			PRIMOUTREG(MGAREG_SETUPEND,
+				   ((address + end) | use_agp));
+/*  				   ((address + start + 12) | use_agp)); */
+			PRIMADVANCE(dev_priv);
+		} while (++i < sarea_priv->nbox);
+	}
+	if (buf_priv->discard) {
+		if (buf_priv->dispatched == 1)
+			AGEBUF(dev_priv, buf_priv);
+		buf_priv->dispatched = 0;
+		mga_freelist_put(dev, buf);
+	}
+}
+
+
+static void mga_dma_dispatch_clear(drm_device_t * dev, int flags,
+				   unsigned int clear_color,
+				   unsigned int clear_zval,
+				   unsigned int clear_colormask,
+				   unsigned int clear_depthmask)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->ContextState;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	unsigned int cmd;
+	int i;
+	PRIMLOCALS;
+
+	if (dev_priv->sgram)
+		cmd = MGA_CLEAR_CMD | DC_atype_blk;
+	else
+		cmd = MGA_CLEAR_CMD | DC_atype_rstr;
+
+	PRIM_OVERFLOW(dev, dev_priv, 35 * MGA_NR_SAREA_CLIPRECTS);
+
+	for (i = 0; i < nbox; i++) {
+		unsigned int height = pbox[i].y2 - pbox[i].y1;
+
+		if (flags & MGA_FRONT) {
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_PLNWT, clear_colormask);
+			PRIMOUTREG(MGAREG_YDSTLEN,
+				   (pbox[i].y1 << 16) | height);
+			PRIMOUTREG(MGAREG_FXBNDRY,
+				   (pbox[i].x2 << 16) | pbox[i].x1);
+
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_FCOL, clear_color);
+			PRIMOUTREG(MGAREG_DSTORG, dev_priv->frontOffset);
+			PRIMOUTREG(MGAREG_DWGCTL + MGAREG_MGA_EXEC, cmd);
+		}
+
+		if (flags & MGA_BACK) {
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_PLNWT, clear_colormask);
+			PRIMOUTREG(MGAREG_YDSTLEN,
+				   (pbox[i].y1 << 16) | height);
+			PRIMOUTREG(MGAREG_FXBNDRY,
+				   (pbox[i].x2 << 16) | pbox[i].x1);
+
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_FCOL, clear_color);
+			PRIMOUTREG(MGAREG_DSTORG, dev_priv->backOffset);
+			PRIMOUTREG(MGAREG_DWGCTL + MGAREG_MGA_EXEC, cmd);
+		}
+
+		if (flags & MGA_DEPTH) {
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_PLNWT, clear_depthmask);
+			PRIMOUTREG(MGAREG_YDSTLEN,
+				   (pbox[i].y1 << 16) | height);
+			PRIMOUTREG(MGAREG_FXBNDRY,
+				   (pbox[i].x2 << 16) | pbox[i].x1);
+
+			PRIMOUTREG(MGAREG_DMAPAD, 0);
+			PRIMOUTREG(MGAREG_FCOL, clear_zval);
+			PRIMOUTREG(MGAREG_DSTORG, dev_priv->depthOffset);
+			PRIMOUTREG(MGAREG_DWGCTL + MGAREG_MGA_EXEC, cmd);
+		}
+	}
+
+	/* Force reset of DWGCTL */
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DWGCTL, regs[MGA_CTXREG_DWGCTL]);
+	PRIMADVANCE(dev_priv);
+}
+
+static void mga_dma_dispatch_swap(drm_device_t * dev)
+{
+	drm_mga_private_t *dev_priv = dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int *regs = sarea_priv->ContextState;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	int i;
+	int pixel_stride = dev_priv->stride / dev_priv->cpp;
+
+	PRIMLOCALS;
+
+	PRIM_OVERFLOW(dev, dev_priv, (MGA_NR_SAREA_CLIPRECTS * 5) + 20);
+
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DWGSYNC, 0x7100);
+	PRIMOUTREG(MGAREG_DWGSYNC, 0x7000);
+
+	PRIMOUTREG(MGAREG_DSTORG, dev_priv->frontOffset);
+	PRIMOUTREG(MGAREG_MACCESS, dev_priv->mAccess);
+	PRIMOUTREG(MGAREG_SRCORG, dev_priv->backOffset);
+	PRIMOUTREG(MGAREG_AR5, pixel_stride);
+
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DWGCTL, MGA_COPY_CMD);
+
+	for (i = 0; i < nbox; i++) {
+		unsigned int h = pbox[i].y2 - pbox[i].y1;
+		unsigned int start = pbox[i].y1 * pixel_stride;
+
+		PRIMOUTREG(MGAREG_AR0, start + pbox[i].x2 - 1);
+		PRIMOUTREG(MGAREG_AR3, start + pbox[i].x1);
+		PRIMOUTREG(MGAREG_FXBNDRY,
+			   pbox[i].x1 | ((pbox[i].x2 - 1) << 16));
+		PRIMOUTREG(MGAREG_YDSTLEN + MGAREG_MGA_EXEC,
+			   (pbox[i].y1 << 16) | h);
+	}
+
+	/* Force reset of DWGCTL */
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_DMAPAD, 0);
+	PRIMOUTREG(MGAREG_SRCORG, 0);
+	PRIMOUTREG(MGAREG_DWGCTL, regs[MGA_CTXREG_DWGCTL]);
+
+	PRIMADVANCE(dev_priv);
+}
+
+int mga_clear_bufs(struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_mga_private_t *dev_priv =
+	    (drm_mga_private_t *) dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_mga_clear_t clear;
+
+	if (copy_from_user(&clear, (drm_mga_clear_t *) arg, sizeof(clear)))
+		return -EFAULT;
+
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("mga_clear_bufs called without lock held\n");
+		return -EINVAL;
+	}
+
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= MGA_UPLOAD_CTX;
+	mga_dma_dispatch_clear(dev, clear.flags,
+			       clear.clear_color,
+			       clear.clear_depth,
+			       clear.clear_color_mask,
+			       clear.clear_depth_mask);
+	PRIMUPDATE(dev_priv);
+	mga_flush_write_combine();
+	mga_dma_schedule(dev, 1);
+	return 0;
+}
+
+int mga_swap_bufs(struct inode *inode, struct file *filp,
+		  unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_mga_private_t *dev_priv =
+	    (drm_mga_private_t *) dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("mga_swap_bufs called without lock held\n");
+		return -EINVAL;
+	}
+
+	if (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)
+		sarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= MGA_UPLOAD_CTX;
+	mga_dma_dispatch_swap(dev);
+	PRIMUPDATE(dev_priv);
+	set_bit(MGA_BUF_SWAP_PENDING,
+		&dev_priv->current_prim->buffer_status);
+	mga_flush_write_combine();
+	mga_dma_schedule(dev, 1);
+	return 0;
+}
+
+int mga_iload(struct inode *inode, struct file *filp,
+	      unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+	drm_mga_private_t *dev_priv =
+	    (drm_mga_private_t *) dev->dev_private;
+	drm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_buf_t *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	drm_mga_iload_t iload;
+	unsigned long bus_address;
+
+	if (copy_from_user(&iload, (drm_mga_iload_t *) arg, sizeof(iload)))
+		return -EFAULT;
+
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("mga_iload called without lock held\n");
+		return -EINVAL;
+	}
+
+	if(iload.idx < 0 || iload.idx > dma->buf_count) return -EINVAL;
+	buf = dma->buflist[iload.idx];
+	buf_priv = buf->dev_private;
+	bus_address = buf->bus_address;
+
+	if (mgaVerifyIload(dev_priv,
+			   bus_address, iload.destOrg, iload.length)) {
+		mga_freelist_put(dev, buf);
+		return -EINVAL;
+	}
+
+	sarea_priv->dirty |= MGA_UPLOAD_CTX;
+
+	mga_dma_dispatch_tex_blit(dev, bus_address, iload.length,
+				  iload.destOrg);
+	AGEBUF(dev_priv, buf_priv);
+	buf_priv->discard = 1;
+	mga_freelist_put(dev, buf);
+	mga_flush_write_combine();
+	mga_dma_schedule(dev, 1);
+	return 0;
+}
+
+int mga_vertex(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_mga_private_t *dev_priv =
+	    (drm_mga_private_t *) dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	drm_mga_vertex_t vertex;
+
+	if (copy_from_user(&vertex, (drm_mga_vertex_t *) arg, sizeof(vertex)))
+		return -EFAULT;
+
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("mga_vertex called without lock held\n");
+		return -EINVAL;
+	}
+
+	if(vertex.idx < 0 || vertex.idx > dma->buf_count) return -EINVAL;
+
+	buf = dma->buflist[vertex.idx];
+	buf_priv = buf->dev_private;
+
+	buf->used = vertex.used;
+	buf_priv->discard = vertex.discard;
+
+	if (!mgaVerifyState(dev_priv)) {
+		if (vertex.discard) {
+			if (buf_priv->dispatched == 1)
+				AGEBUF(dev_priv, buf_priv);
+			buf_priv->dispatched = 0;
+			mga_freelist_put(dev, buf);
+		}
+		return -EINVAL;
+	}
+
+	mga_dma_dispatch_vertex(dev, buf);
+
+	PRIMUPDATE(dev_priv);
+	mga_flush_write_combine();
+	mga_dma_schedule(dev, 1);
+	return 0;
+}
+
+
+int mga_indices(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_mga_private_t *dev_priv =
+	    (drm_mga_private_t *) dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_mga_buf_priv_t *buf_priv;
+	drm_mga_indices_t indices;
+
+	if (copy_from_user(&indices,
+			   (drm_mga_indices_t *)arg, sizeof(indices)))
+		return -EFAULT;
+
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("mga_indices called without lock held\n");
+		return -EINVAL;
+	}
+
+	if(indices.idx < 0 || indices.idx > dma->buf_count) return -EINVAL;
+	buf = dma->buflist[indices.idx];
+	buf_priv = buf->dev_private;
+
+	buf_priv->discard = indices.discard;
+
+	if (!mgaVerifyState(dev_priv)) {
+		if (indices.discard) {
+			if (buf_priv->dispatched == 1)
+				AGEBUF(dev_priv, buf_priv);
+			buf_priv->dispatched = 0;
+			mga_freelist_put(dev, buf);
+		}
+		return -EINVAL;
+	}
+
+	mga_dma_dispatch_indices(dev, buf, indices.start, indices.end);
+
+	PRIMUPDATE(dev_priv);
+	mga_flush_write_combine();
+	mga_dma_schedule(dev, 1);
+	return 0;
+}
+
+
+
+static int mga_dma_get_buffers(drm_device_t * dev, drm_dma_t * d)
+{
+	int i;
+	drm_buf_t *buf;
+
+	for (i = d->granted_count; i < d->request_count; i++) {
+		buf = mga_freelist_get(dev);
+		if (!buf)
+			break;
+		buf->pid = current->pid;
+		if (copy_to_user(&d->request_indices[i],
+				 &buf->idx, sizeof(buf->idx)))
+			return -EFAULT;
+		if (copy_to_user(&d->request_sizes[i],
+				 &buf->total, sizeof(buf->total)))
+			return -EFAULT;
+		++d->granted_count;
+	}
+	return 0;
+}
+
+int mga_dma(struct inode *inode, struct file *filp, unsigned int cmd,
+	    unsigned long arg)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+	int retcode = 0;
+	drm_dma_t d;
+
+	if (copy_from_user(&d, (drm_dma_t *) arg, sizeof(d)))
+		return -EFAULT;
+
+	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+		DRM_ERROR("mga_dma called without lock held\n");
+		return -EINVAL;
+	}
+
+	/* Please don't send us buffers.
+	 */
+	if (d.send_count != 0) {
+		DRM_ERROR
+		    ("Process %d trying to send %d buffers via drmDMA\n",
+		     current->pid, d.send_count);
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if (d.request_count < 0 || d.request_count > dma->buf_count) {
+		DRM_ERROR
+		    ("Process %d trying to get %d buffers (of %d max)\n",
+		     current->pid, d.request_count, dma->buf_count);
+		return -EINVAL;
+	}
+
+	d.granted_count = 0;
+
+	if (d.request_count) {
+		retcode = mga_dma_get_buffers(dev, &d);
+	}
+
+	if (copy_to_user((drm_dma_t *) arg, &d, sizeof(d)))
+		return -EFAULT;
+	return retcode;
+}
diff -urN linux.orig/drivers/char/drm-4.0/proc.c linux/drivers/char/drm-4.0/proc.c
--- linux.orig/drivers/char/drm-4.0/proc.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/proc.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,578 @@
+/* proc.c -- /proc support for DRM -*- linux-c -*-
+ * Created: Mon Jan 11 09:48:47 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+
+static struct proc_dir_entry *drm_root	   = NULL;
+static struct proc_dir_entry *drm_dev_root = NULL;
+static char		     drm_slot_name[64];
+
+static int	   drm_name_info(char *buf, char **start, off_t offset,
+				 int len, int *eof, void *data);
+static int	   drm_vm_info(char *buf, char **start, off_t offset,
+			       int len, int *eof, void *data);
+static int	   drm_clients_info(char *buf, char **start, off_t offset,
+				    int len, int *eof, void *data);
+static int	   drm_queues_info(char *buf, char **start, off_t offset,
+				   int len, int *eof, void *data);
+static int	   drm_bufs_info(char *buf, char **start, off_t offset,
+				 int len, int *eof, void *data);
+#if DRM_DEBUG_CODE
+static int	   drm_vma_info(char *buf, char **start, off_t offset,
+				int len, int *eof, void *data);
+#endif
+#if DRM_DMA_HISTOGRAM
+static int	   drm_histo_info(char *buf, char **start, off_t offset,
+				  int len, int *eof, void *data);
+#endif
+
+struct drm_proc_list {
+	const char *name;
+	int	   (*f)(char *, char **, off_t, int, int *, void *);
+} drm_proc_list[] = {
+	{ "name",    drm_name_info    },
+	{ "mem",     drm_mem_info     },
+	{ "vm",	     drm_vm_info      },
+	{ "clients", drm_clients_info },
+	{ "queues",  drm_queues_info  },
+	{ "bufs",    drm_bufs_info    },
+#if DRM_DEBUG_CODE
+	{ "vma",     drm_vma_info     },
+#endif
+#if DRM_DMA_HISTOGRAM
+	{ "histo",   drm_histo_info   },
+#endif
+};
+#define DRM_PROC_ENTRIES (sizeof(drm_proc_list)/sizeof(drm_proc_list[0]))
+
+int drm_proc_init(drm_device_t *dev)
+{
+	struct proc_dir_entry *ent;
+	int		      i, j;
+
+	drm_root = create_proc_entry("dri", S_IFDIR, NULL);
+	if (!drm_root) {
+		DRM_ERROR("Cannot create /proc/dri\n");
+		return -1;
+	}
+
+				/* Instead of doing this search, we should
+				   add some global support for /proc/dri. */
+	for (i = 0; i < 8; i++) {
+		sprintf(drm_slot_name, "dri/%d", i);
+		drm_dev_root = create_proc_entry(drm_slot_name, S_IFDIR, NULL);
+		if (!drm_dev_root) {
+			DRM_ERROR("Cannot create /proc/%s\n", drm_slot_name);
+			remove_proc_entry("dri", NULL);
+			break;
+		}
+		if (drm_dev_root->nlink == 2) break;
+		drm_dev_root = NULL;
+	}
+	if (!drm_dev_root) {
+		DRM_ERROR("Cannot find slot in /proc/dri\n");
+		return -1;
+	}
+
+	for (i = 0; i < DRM_PROC_ENTRIES; i++) {
+		ent = create_proc_entry(drm_proc_list[i].name,
+					S_IFREG|S_IRUGO, drm_dev_root);
+		if (!ent) {
+			DRM_ERROR("Cannot create /proc/%s/%s\n",
+				  drm_slot_name, drm_proc_list[i].name);
+			for (j = 0; j < i; j++)
+				remove_proc_entry(drm_proc_list[i].name,
+						  drm_dev_root);
+			remove_proc_entry(drm_slot_name, NULL);
+			remove_proc_entry("dri", NULL);
+			return -1;
+		}
+		ent->read_proc = drm_proc_list[i].f;
+		ent->data      = dev;
+	}
+
+	return 0;
+}
+
+
+int drm_proc_cleanup(void)
+{
+	int i;
+	
+	if (drm_root) {
+		if (drm_dev_root) {
+			for (i = 0; i < DRM_PROC_ENTRIES; i++) {
+				remove_proc_entry(drm_proc_list[i].name,
+						  drm_dev_root);
+			}
+			remove_proc_entry(drm_slot_name, NULL);
+		}
+		remove_proc_entry("dri", NULL);
+		remove_proc_entry(DRM_NAME, NULL);
+	}
+	drm_root = drm_dev_root = NULL;
+	return 0;
+}
+
+static int drm_name_info(char *buf, char **start, off_t offset, int len,
+			 int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+
+	if (dev->unique) {
+		DRM_PROC_PRINT("%s 0x%x %s\n",
+			       dev->name, dev->device, dev->unique);
+	} else {
+		DRM_PROC_PRINT("%s 0x%x\n", dev->name, dev->device);
+	}
+	return len;
+}
+
+static int _drm_vm_info(char *buf, char **start, off_t offset, int len,
+			int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	drm_map_t    *map;
+				/* Hardcoded from _DRM_FRAME_BUFFER,
+                                   _DRM_REGISTERS, _DRM_SHM, and
+                                   _DRM_AGP. */
+	const char   *types[] = { "FB", "REG", "SHM", "AGP" };
+	const char   *type;
+	int	     i;
+
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+	DRM_PROC_PRINT("slot	 offset	      size type flags	 "
+		       "address mtrr\n\n");
+	for (i = 0; i < dev->map_count; i++) {
+		map = dev->maplist[i];
+		if (map->type < 0 || map->type > 3) type = "??";
+		else				    type = types[map->type];
+		DRM_PROC_PRINT("%4d 0x%08lx 0x%08lx %4.4s  0x%02x 0x%08lx ",
+			       i,
+			       map->offset,
+			       map->size,
+			       type,
+			       map->flags,
+			       (unsigned long)map->handle);
+		if (map->mtrr < 0) {
+			DRM_PROC_PRINT("none\n");
+		} else {
+			DRM_PROC_PRINT("%4d\n", map->mtrr);
+		}
+	}
+
+	return len;
+}
+
+static int drm_vm_info(char *buf, char **start, off_t offset, int len,
+		       int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	int	     ret;
+
+	down(&dev->struct_sem);
+	ret = _drm_vm_info(buf, start, offset, len, eof, data);
+	up(&dev->struct_sem);
+	return ret;
+}
+
+
+static int _drm_queues_info(char *buf, char **start, off_t offset, int len,
+			    int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	int	     i;
+	drm_queue_t  *q;
+
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+	DRM_PROC_PRINT("  ctx/flags   use   fin"
+		       "   blk/rw/rwf  wait    flushed	   queued"
+		       "      locks\n\n");
+	for (i = 0; i < dev->queue_count; i++) {
+		q = dev->queuelist[i];
+		atomic_inc(&q->use_count);
+		DRM_PROC_PRINT_RET(atomic_dec(&q->use_count),
+				   "%5d/0x%03x %5d %5d"
+				   " %5d/%c%c/%c%c%c %5Zd %10d %10d %10d\n",
+				   i,
+				   q->flags,
+				   atomic_read(&q->use_count),
+				   atomic_read(&q->finalization),
+				   atomic_read(&q->block_count),
+				   atomic_read(&q->block_read) ? 'r' : '-',
+				   atomic_read(&q->block_write) ? 'w' : '-',
+				   waitqueue_active(&q->read_queue) ? 'r':'-',
+				   waitqueue_active(&q->write_queue) ? 'w':'-',
+				   waitqueue_active(&q->flush_queue) ? 'f':'-',
+				   DRM_BUFCOUNT(&q->waitlist),
+				   atomic_read(&q->total_flushed),
+				   atomic_read(&q->total_queued),
+				   atomic_read(&q->total_locks));
+		atomic_dec(&q->use_count);
+	}
+	
+	return len;
+}
+
+static int drm_queues_info(char *buf, char **start, off_t offset, int len,
+			   int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	int	     ret;
+
+	down(&dev->struct_sem);
+	ret = _drm_queues_info(buf, start, offset, len, eof, data);
+	up(&dev->struct_sem);
+	return ret;
+}
+
+/* drm_bufs_info is called whenever a process reads
+   /dev/drm/<dev>/bufs. */
+
+static int _drm_bufs_info(char *buf, char **start, off_t offset, int len,
+			  int *eof, void *data)
+{
+	drm_device_t	 *dev = (drm_device_t *)data;
+	drm_device_dma_t *dma = dev->dma;
+	int		 i;
+
+	if (!dma)	return 0;
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+	DRM_PROC_PRINT(" o     size count  free	 segs pages    kB\n\n");
+	for (i = 0; i <= DRM_MAX_ORDER; i++) {
+		if (dma->bufs[i].buf_count)
+			DRM_PROC_PRINT("%2d %8d %5d %5d %5d %5d %5ld\n",
+				       i,
+				       dma->bufs[i].buf_size,
+				       dma->bufs[i].buf_count,
+				       atomic_read(&dma->bufs[i]
+						   .freelist.count),
+				       dma->bufs[i].seg_count,
+				       dma->bufs[i].seg_count
+				       *(1 << dma->bufs[i].page_order),
+				       (dma->bufs[i].seg_count
+					* (1 << dma->bufs[i].page_order))
+				       * PAGE_SIZE / 1024);
+	}
+	DRM_PROC_PRINT("\n");
+	for (i = 0; i < dma->buf_count; i++) {
+		if (i && !(i%32)) DRM_PROC_PRINT("\n");
+		DRM_PROC_PRINT(" %d", dma->buflist[i]->list);
+	}
+	DRM_PROC_PRINT("\n");
+
+	return len;
+}
+
+static int drm_bufs_info(char *buf, char **start, off_t offset, int len,
+			 int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	int	     ret;
+
+	down(&dev->struct_sem);
+	ret = _drm_bufs_info(buf, start, offset, len, eof, data);
+	up(&dev->struct_sem);
+	return ret;
+}
+
+
+static int _drm_clients_info(char *buf, char **start, off_t offset, int len,
+			     int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	drm_file_t   *priv;
+
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+	DRM_PROC_PRINT("a dev	pid    uid	magic	  ioctls\n\n");
+	for (priv = dev->file_first; priv; priv = priv->next) {
+		DRM_PROC_PRINT("%c %3d %5d %5d %10u %10lu\n",
+			       priv->authenticated ? 'y' : 'n',
+			       priv->minor,
+			       priv->pid,
+			       priv->uid,
+			       priv->magic,
+			       priv->ioctl_count);
+	}
+
+	return len;
+}
+
+static int drm_clients_info(char *buf, char **start, off_t offset, int len,
+			    int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	int	     ret;
+
+	down(&dev->struct_sem);
+	ret = _drm_clients_info(buf, start, offset, len, eof, data);
+	up(&dev->struct_sem);
+	return ret;
+}
+
+#if DRM_DEBUG_CODE
+
+#define DRM_VMA_VERBOSE 0
+
+static int _drm_vma_info(char *buf, char **start, off_t offset, int len,
+			 int *eof, void *data)
+{
+	drm_device_t	      *dev = (drm_device_t *)data;
+	drm_vma_entry_t	      *pt;
+	struct vm_area_struct *vma;
+#if DRM_VMA_VERBOSE
+	unsigned long	      i;
+	unsigned long	      address;
+	pgd_t		      *pgd;
+	pmd_t		      *pmd;
+	pte_t		      *pte;
+#endif
+#if defined(__i386__)
+	unsigned int	      pgprot;
+#endif
+
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+	DRM_PROC_PRINT("vma use count: %d, high_memory = %p, 0x%08lx\n",
+		       atomic_read(&dev->vma_count),
+		       high_memory, virt_to_phys(high_memory));
+	for (pt = dev->vmalist; pt; pt = pt->next) {
+		if (!(vma = pt->vma)) continue;
+		DRM_PROC_PRINT("\n%5d 0x%08lx-0x%08lx %c%c%c%c%c%c 0x%08lx",
+			       pt->pid,
+			       vma->vm_start,
+			       vma->vm_end,
+			       vma->vm_flags & VM_READ	   ? 'r' : '-',
+			       vma->vm_flags & VM_WRITE	   ? 'w' : '-',
+			       vma->vm_flags & VM_EXEC	   ? 'x' : '-',
+			       vma->vm_flags & VM_MAYSHARE ? 's' : 'p',
+			       vma->vm_flags & VM_LOCKED   ? 'l' : '-',
+			       vma->vm_flags & VM_IO	   ? 'i' : '-',
+			       VM_OFFSET(vma));
+		
+#if defined(__i386__)
+		pgprot = pgprot_val(vma->vm_page_prot);
+		DRM_PROC_PRINT(" %c%c%c%c%c%c%c%c%c",
+			       pgprot & _PAGE_PRESENT  ? 'p' : '-',
+			       pgprot & _PAGE_RW       ? 'w' : 'r',
+			       pgprot & _PAGE_USER     ? 'u' : 's',
+			       pgprot & _PAGE_PWT      ? 't' : 'b',
+			       pgprot & _PAGE_PCD      ? 'u' : 'c',
+			       pgprot & _PAGE_ACCESSED ? 'a' : '-',
+			       pgprot & _PAGE_DIRTY    ? 'd' : '-',
+			       pgprot & _PAGE_PSE      ? 'm' : 'k',
+			       pgprot & _PAGE_GLOBAL   ? 'g' : 'l' );
+#endif		
+		DRM_PROC_PRINT("\n");
+#if 0
+		for (i = vma->vm_start; i < vma->vm_end; i += PAGE_SIZE) {
+			pgd = pgd_offset(vma->vm_mm, i);
+			pmd = pmd_offset(pgd, i);
+			pte = pte_offset(pmd, i);
+			if (pte_present(*pte)) {
+				address = __pa(pte_page(*pte))
+					+ (i & (PAGE_SIZE-1));
+				DRM_PROC_PRINT("      0x%08lx -> 0x%08lx"
+					       " %c%c%c%c%c\n",
+					       i,
+					       address,
+					       pte_read(*pte)  ? 'r' : '-',
+					       pte_write(*pte) ? 'w' : '-',
+					       pte_exec(*pte)  ? 'x' : '-',
+					       pte_dirty(*pte) ? 'd' : '-',
+					       pte_young(*pte) ? 'a' : '-' );
+			} else {
+				DRM_PROC_PRINT("      0x%08lx\n", i);
+			}
+		}
+#endif
+	}
+	
+	return len;
+}
+
+static int drm_vma_info(char *buf, char **start, off_t offset, int len,
+			int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	int	     ret;
+
+	down(&dev->struct_sem);
+	ret = _drm_vma_info(buf, start, offset, len, eof, data);
+	up(&dev->struct_sem);
+	return ret;
+}
+#endif
+
+
+#if DRM_DMA_HISTOGRAM
+static int _drm_histo_info(char *buf, char **start, off_t offset, int len,
+			   int *eof, void *data)
+{
+	drm_device_t	 *dev = (drm_device_t *)data;
+	drm_device_dma_t *dma = dev->dma;
+	int		 i;
+	unsigned long	 slot_value = DRM_DMA_HISTOGRAM_INITIAL;
+	unsigned long	 prev_value = 0;
+	drm_buf_t	 *buffer;
+
+	if (offset > 0) return 0; /* no partial requests */
+	len  = 0;
+	*eof = 1;
+
+	DRM_PROC_PRINT("general statistics:\n");
+	DRM_PROC_PRINT("total	 %10u\n", atomic_read(&dev->histo.total));
+	DRM_PROC_PRINT("open	 %10u\n", atomic_read(&dev->total_open));
+	DRM_PROC_PRINT("close	 %10u\n", atomic_read(&dev->total_close));
+	DRM_PROC_PRINT("ioctl	 %10u\n", atomic_read(&dev->total_ioctl));
+	DRM_PROC_PRINT("irq	 %10u\n", atomic_read(&dev->total_irq));
+	DRM_PROC_PRINT("ctx	 %10u\n", atomic_read(&dev->total_ctx));
+	
+	DRM_PROC_PRINT("\nlock statistics:\n");
+	DRM_PROC_PRINT("locks	 %10u\n", atomic_read(&dev->total_locks));
+	DRM_PROC_PRINT("unlocks	 %10u\n", atomic_read(&dev->total_unlocks));
+	DRM_PROC_PRINT("contends %10u\n", atomic_read(&dev->total_contends));
+	DRM_PROC_PRINT("sleeps	 %10u\n", atomic_read(&dev->total_sleeps));
+
+
+	if (dma) {
+		DRM_PROC_PRINT("\ndma statistics:\n");
+		DRM_PROC_PRINT("prio	 %10u\n",
+			       atomic_read(&dma->total_prio));
+		DRM_PROC_PRINT("bytes	 %10u\n",
+			       atomic_read(&dma->total_bytes));
+		DRM_PROC_PRINT("dmas	 %10u\n",
+			       atomic_read(&dma->total_dmas));
+		DRM_PROC_PRINT("missed:\n");
+		DRM_PROC_PRINT("  dma	 %10u\n",
+			       atomic_read(&dma->total_missed_dma));
+		DRM_PROC_PRINT("  lock	 %10u\n",
+			       atomic_read(&dma->total_missed_lock));
+		DRM_PROC_PRINT("  free	 %10u\n",
+			       atomic_read(&dma->total_missed_free));
+		DRM_PROC_PRINT("  sched	 %10u\n",
+			       atomic_read(&dma->total_missed_sched));
+		DRM_PROC_PRINT("tried	 %10u\n",
+			       atomic_read(&dma->total_tried));
+		DRM_PROC_PRINT("hit	 %10u\n",
+			       atomic_read(&dma->total_hit));
+		DRM_PROC_PRINT("lost	 %10u\n",
+			       atomic_read(&dma->total_lost));
+		
+		buffer = dma->next_buffer;
+		if (buffer) {
+			DRM_PROC_PRINT("next_buffer %7d\n", buffer->idx);
+		} else {
+			DRM_PROC_PRINT("next_buffer    none\n");
+		}
+		buffer = dma->this_buffer;
+		if (buffer) {
+			DRM_PROC_PRINT("this_buffer %7d\n", buffer->idx);
+		} else {
+			DRM_PROC_PRINT("this_buffer    none\n");
+		}
+	}
+	
+
+	DRM_PROC_PRINT("\nvalues:\n");
+	if (dev->lock.hw_lock) {
+		DRM_PROC_PRINT("lock	       0x%08x\n",
+			       dev->lock.hw_lock->lock);
+	} else {
+		DRM_PROC_PRINT("lock		     none\n");
+	}
+	DRM_PROC_PRINT("context_flag   0x%08lx\n", dev->context_flag);
+	DRM_PROC_PRINT("interrupt_flag 0x%08lx\n", dev->interrupt_flag);
+	DRM_PROC_PRINT("dma_flag       0x%08lx\n", dev->dma_flag);
+
+	DRM_PROC_PRINT("queue_count    %10d\n",	 dev->queue_count);
+	DRM_PROC_PRINT("last_context   %10d\n",	 dev->last_context);
+	DRM_PROC_PRINT("last_switch    %10lu\n", dev->last_switch);
+	DRM_PROC_PRINT("last_checked   %10d\n",	 dev->last_checked);
+		
+	
+	DRM_PROC_PRINT("\n		       q2d	  d2c	     c2f"
+		       "	q2c	   q2f	      dma	 sch"
+		       "	ctx	  lacq	     lhld\n\n");
+	for (i = 0; i < DRM_DMA_HISTOGRAM_SLOTS; i++) {
+		DRM_PROC_PRINT("%s %10lu %10u %10u %10u %10u %10u"
+			       " %10u %10u %10u %10u %10u\n",
+			       i == DRM_DMA_HISTOGRAM_SLOTS - 1 ? ">=" : "< ",
+			       i == DRM_DMA_HISTOGRAM_SLOTS - 1
+			       ? prev_value : slot_value ,
+			       
+			       atomic_read(&dev->histo
+					   .queued_to_dispatched[i]),
+			       atomic_read(&dev->histo
+					   .dispatched_to_completed[i]),
+			       atomic_read(&dev->histo
+					   .completed_to_freed[i]),
+			       
+			       atomic_read(&dev->histo
+					   .queued_to_completed[i]),
+			       atomic_read(&dev->histo
+					   .queued_to_freed[i]),
+			       atomic_read(&dev->histo.dma[i]),
+			       atomic_read(&dev->histo.schedule[i]),
+			       atomic_read(&dev->histo.ctx[i]),
+			       atomic_read(&dev->histo.lacq[i]),
+			       atomic_read(&dev->histo.lhld[i]));
+		prev_value = slot_value;
+		slot_value = DRM_DMA_HISTOGRAM_NEXT(slot_value);
+	}
+	return len;
+}
+
+static int drm_histo_info(char *buf, char **start, off_t offset, int len,
+			  int *eof, void *data)
+{
+	drm_device_t *dev = (drm_device_t *)data;
+	int	     ret;
+
+	down(&dev->struct_sem);
+	ret = _drm_histo_info(buf, start, offset, len, eof, data);
+	up(&dev->struct_sem);
+	return ret;
+}
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/r128_bufs.c linux/drivers/char/drm-4.0/r128_bufs.c
--- linux.orig/drivers/char/drm-4.0/r128_bufs.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/r128_bufs.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,319 @@
+/* r128_bufs.c -- IOCTLs to manage buffers -*- linux-c -*-
+ * Created: Wed Apr 12 16:19:08 2000 by kevin@precisioninsight.com
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Kevin E. Martin <martin@valinux.com>
+ *          Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include <linux/config.h>
+#include "drmP.h"
+#include "r128_drv.h"
+#include "linux/un.h"
+
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+int r128_addbufs_agp(struct inode *inode, struct file *filp, unsigned int cmd,
+		     unsigned long arg)
+{
+	drm_file_t       *priv = filp->private_data;
+	drm_device_t     *dev  = priv->dev;
+	drm_device_dma_t *dma  = dev->dma;
+	drm_buf_desc_t    request;
+	drm_buf_entry_t  *entry;
+	drm_buf_t        *buf;
+	unsigned long     offset;
+	unsigned long     agp_offset;
+	int               count;
+	int               order;
+	int               size;
+	int               alignment;
+	int               page_order;
+	int               total;
+	int               byte_count;
+	int               i;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	count      = request.count;
+	order      = drm_order(request.size);
+	size       = 1 << order;
+
+	alignment  = (request.flags & _DRM_PAGE_ALIGN) ? PAGE_ALIGN(size):size;
+	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
+	total      = PAGE_SIZE << page_order;
+
+	byte_count = 0;
+	agp_offset = dev->agp->base + request.agp_start;
+
+	DRM_DEBUG("count:      %d\n",  count);
+	DRM_DEBUG("order:      %d\n",  order);
+	DRM_DEBUG("size:       %d\n",  size);
+	DRM_DEBUG("agp_offset: %ld\n", agp_offset);
+	DRM_DEBUG("alignment:  %d\n",  alignment);
+	DRM_DEBUG("page_order: %d\n",  page_order);
+	DRM_DEBUG("total:      %d\n",  total);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	if (dev->queue_count) return -EBUSY; /* Not while in use */
+
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
+
+	down(&dev->struct_sem);
+	entry = &dma->bufs[order];
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM; /* May only call once for each order */
+	}
+
+	/* Might be a poor limit, but take that up with XFree86 
+	   if its a problem */
+	   
+	if(count < 0 || count > 4096)
+	{
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -EINVAL;
+	}
+		
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
+
+	entry->buf_size   = size;
+	entry->page_order = page_order;
+	offset            = 0;
+
+	for (offset = 0;
+	     entry->buf_count < count;
+	     offset += alignment, ++entry->buf_count) {
+		buf          = &entry->buflist[entry->buf_count];
+		buf->idx     = dma->buf_count + entry->buf_count;
+		buf->total   = alignment;
+		buf->order   = order;
+		buf->used    = 0;
+		buf->offset  = (dma->byte_count + offset);
+		buf->address = (void *)(agp_offset + offset);
+		buf->next    = NULL;
+		buf->waiting = 0;
+		buf->pending = 0;
+		init_waitqueue_head(&buf->dma_wait);
+		buf->pid     = 0;
+
+		buf->dev_priv_size = sizeof(drm_r128_buf_priv_t);
+		buf->dev_private   = drm_alloc(sizeof(drm_r128_buf_priv_t),
+					       DRM_MEM_BUFS);
+		memset(buf->dev_private, 0, buf->dev_priv_size);
+
+#if DRM_DMA_HISTOGRAM
+		buf->time_queued     = 0;
+		buf->time_dispatched = 0;
+		buf->time_completed  = 0;
+		buf->time_freed      = 0;
+#endif
+
+		byte_count += PAGE_SIZE << page_order;
+
+		DRM_DEBUG("buffer %d @ %p\n",
+			  entry->buf_count, buf->address);
+	}
+
+	DRM_DEBUG("byte_count: %d\n", byte_count);
+
+	dma->buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist),
+				   DRM_MEM_BUFS);
+	for (i = dma->buf_count; i < dma->buf_count + entry->buf_count; i++)
+		dma->buflist[i] = &entry->buflist[i - dma->buf_count];
+
+	dma->buf_count  += entry->buf_count;
+	dma->byte_count += byte_count;
+
+	drm_freelist_create(&entry->freelist, entry->buf_count);
+	for (i = 0; i < entry->buf_count; i++) {
+		drm_freelist_put(dev, &entry->freelist, &entry->buflist[i]);
+	}
+
+	up(&dev->struct_sem);
+
+	request.count = entry->buf_count;
+	request.size  = size;
+
+	if (copy_to_user((drm_buf_desc_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+
+	dma->flags = _DRM_DMA_USE_AGP;
+
+	atomic_dec(&dev->buf_alloc);
+	return 0;
+}
+#endif
+
+int r128_addbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t		*priv		= filp->private_data;
+	drm_device_t		*dev		= priv->dev;
+	drm_r128_private_t	*dev_priv	= dev->dev_private;
+	drm_buf_desc_t		request;
+
+	if (!dev_priv || dev_priv->is_pci) return -EINVAL;
+
+	if (copy_from_user(&request,
+			   (drm_buf_desc_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	if (request.flags & _DRM_AGP_BUFFER)
+		return r128_addbufs_agp(inode, filp, cmd, arg);
+	else
+#endif
+		return -EINVAL;
+}
+
+int r128_mapbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t		*priv		= filp->private_data;
+	drm_device_t		*dev		= priv->dev;
+	drm_r128_private_t	*dev_priv	= dev->dev_private;
+	drm_device_dma_t	*dma		= dev->dma;
+	int			 retcode	= 0;
+	const int		 zero		= 0;
+	unsigned long		 virtual;
+	unsigned long		 address;
+	drm_buf_map_t		 request;
+	int			 i;
+
+	if (!dma || !dev_priv || dev_priv->is_pci) return -EINVAL;
+
+	DRM_DEBUG("\n");
+
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	++dev->buf_use;		/* Can't allocate more after this call */
+	spin_unlock(&dev->count_lock);
+
+	if (copy_from_user(&request,
+			   (drm_buf_map_t *)arg,
+			   sizeof(request)))
+		return -EFAULT;
+
+	if (request.count >= dma->buf_count) {
+		if (dma->flags & _DRM_DMA_USE_AGP) {
+			drm_map_t *map;
+
+			map = dev_priv->buffers;
+			if (!map) {
+				retcode = -EINVAL;
+				goto done;
+			}
+
+			down_write(&current->mm->mmap_sem);
+			virtual = do_mmap(filp, 0, map->size,
+					  PROT_READ|PROT_WRITE,
+					  MAP_SHARED,
+					  (unsigned long)map->offset);
+			up_write(&current->mm->mmap_sem);
+		} else {
+			down_write(&current->mm->mmap_sem);
+			virtual = do_mmap(filp, 0, dma->byte_count,
+					  PROT_READ|PROT_WRITE, MAP_SHARED, 0);
+			up_write(&current->mm->mmap_sem);
+		}
+		if (virtual > -1024UL) {
+			/* Real error */
+			retcode = (signed long)virtual;
+			goto done;
+		}
+		request.virtual = (void *)virtual;
+
+		for (i = 0; i < dma->buf_count; i++) {
+			if (copy_to_user(&request.list[i].idx,
+					 &dma->buflist[i]->idx,
+					 sizeof(request.list[0].idx))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].total,
+					 &dma->buflist[i]->total,
+					 sizeof(request.list[0].total))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].used,
+					 &zero,
+					 sizeof(zero))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			address = virtual + dma->buflist[i]->offset;
+			if (copy_to_user(&request.list[i].address,
+					 &address,
+					 sizeof(address))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+		}
+	}
+ done:
+	request.count = dma->buf_count;
+	DRM_DEBUG("%d buffers, retcode = %d\n", request.count, retcode);
+
+	if (copy_to_user((drm_buf_map_t *)arg,
+			 &request,
+			 sizeof(request)))
+		return -EFAULT;
+
+	return retcode;
+}
diff -urN linux.orig/drivers/char/drm-4.0/r128_cce.c linux/drivers/char/drm-4.0/r128_cce.c
--- linux.orig/drivers/char/drm-4.0/r128_cce.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/r128_cce.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1305 @@
+/* r128_cce.c -- ATI Rage 128 driver -*- linux-c -*-
+ * Created: Wed Apr  5 19:24:19 2000 by kevin@precisioninsight.com
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *   Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "r128_drv.h"
+
+#include <linux/interrupt.h>	/* For task queue support */
+#include <linux/delay.h>
+
+
+/* FIXME: Temporary CCE packet buffer */
+u32 r128_cce_buffer[(1 << 14)] __attribute__ ((aligned (32)));
+
+/* CCE microcode (from ATI) */
+static u32 r128_cce_microcode[] = {
+	0, 276838400, 0, 268449792, 2, 142, 2, 145, 0, 1076765731, 0,
+	1617039951, 0, 774592877, 0, 1987540286, 0, 2307490946U, 0,
+	599558925, 0, 589505315, 0, 596487092, 0, 589505315, 1,
+	11544576, 1, 206848, 1, 311296, 1, 198656, 2, 912273422, 11,
+	262144, 0, 0, 1, 33559837, 1, 7438, 1, 14809, 1, 6615, 12, 28,
+	1, 6614, 12, 28, 2, 23, 11, 18874368, 0, 16790922, 1, 409600, 9,
+	30, 1, 147854772, 16, 420483072, 3, 8192, 0, 10240, 1, 198656,
+	1, 15630, 1, 51200, 10, 34858, 9, 42, 1, 33559823, 2, 10276, 1,
+	15717, 1, 15718, 2, 43, 1, 15936948, 1, 570480831, 1, 14715071,
+	12, 322123831, 1, 33953125, 12, 55, 1, 33559908, 1, 15718, 2,
+	46, 4, 2099258, 1, 526336, 1, 442623, 4, 4194365, 1, 509952, 1,
+	459007, 3, 0, 12, 92, 2, 46, 12, 176, 1, 15734, 1, 206848, 1,
+	18432, 1, 133120, 1, 100670734, 1, 149504, 1, 165888, 1,
+	15975928, 1, 1048576, 6, 3145806, 1, 15715, 16, 2150645232U, 2,
+	268449859, 2, 10307, 12, 176, 1, 15734, 1, 15735, 1, 15630, 1,
+	15631, 1, 5253120, 6, 3145810, 16, 2150645232U, 1, 15864, 2, 82,
+	1, 343310, 1, 1064207, 2, 3145813, 1, 15728, 1, 7817, 1, 15729,
+	3, 15730, 12, 92, 2, 98, 1, 16168, 1, 16167, 1, 16002, 1, 16008,
+	1, 15974, 1, 15975, 1, 15990, 1, 15976, 1, 15977, 1, 15980, 0,
+	15981, 1, 10240, 1, 5253120, 1, 15720, 1, 198656, 6, 110, 1,
+	180224, 1, 103824738, 2, 112, 2, 3145839, 0, 536885440, 1,
+	114880, 14, 125, 12, 206975, 1, 33559995, 12, 198784, 0,
+	33570236, 1, 15803, 0, 15804, 3, 294912, 1, 294912, 3, 442370,
+	1, 11544576, 0, 811612160, 1, 12593152, 1, 11536384, 1,
+	14024704, 7, 310382726, 0, 10240, 1, 14796, 1, 14797, 1, 14793,
+	1, 14794, 0, 14795, 1, 268679168, 1, 9437184, 1, 268449792, 1,
+	198656, 1, 9452827, 1, 1075854602, 1, 1075854603, 1, 557056, 1,
+	114880, 14, 159, 12, 198784, 1, 1109409213, 12, 198783, 1,
+	1107312059, 12, 198784, 1, 1109409212, 2, 162, 1, 1075854781, 1,
+	1073757627, 1, 1075854780, 1, 540672, 1, 10485760, 6, 3145894,
+	16, 274741248, 9, 168, 3, 4194304, 3, 4209949, 0, 0, 0, 256, 14,
+	174, 1, 114857, 1, 33560007, 12, 176, 0, 10240, 1, 114858, 1,
+	33560018, 1, 114857, 3, 33560007, 1, 16008, 1, 114874, 1,
+	33560360, 1, 114875, 1, 33560154, 0, 15963, 0, 256, 0, 4096, 1,
+	409611, 9, 188, 0, 10240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+
+#define DO_REMAP(_m, _d) (_m)->handle = drm_ioremap((_m)->offset,           \
+							 (_m)->size, (_d))
+
+#define DO_REMAPFREE(_m, _d)                                                \
+	do {                                                                \
+		if ((_m)->handle && (_m)->size)                             \
+			drm_ioremapfree((_m)->handle, (_m)->size, (_d));    \
+	} while (0)
+
+#define DO_FIND_MAP(_m, _o)                                                 \
+	do {                                                                \
+		int _i;                                                     \
+		for (_i = 0; _i < dev->map_count; _i++) {                   \
+			if (dev->maplist[_i]->offset == _o) {               \
+				_m = dev->maplist[_i];                      \
+				break;                                      \
+			}                                                   \
+		}                                                           \
+	} while (0)
+
+
+int R128_READ_PLL(drm_device_t *dev, int addr)
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+
+	R128_WRITE8(R128_CLOCK_CNTL_INDEX, addr & 0x1f);
+	return R128_READ(R128_CLOCK_CNTL_DATA);
+}
+
+#if 0
+static void r128_status( drm_r128_private_t *dev_priv )
+{
+	printk( "GUI_STAT           = 0x%08x\n",
+		(unsigned int)R128_READ( R128_GUI_STAT ) );
+	printk( "PM4_STAT           = 0x%08x\n",
+		(unsigned int)R128_READ( R128_PM4_STAT ) );
+	printk( "PM4_BUFFER_DL_WPTR = 0x%08x\n",
+		(unsigned int)R128_READ( R128_PM4_BUFFER_DL_WPTR ) );
+	printk( "PM4_BUFFER_DL_RPTR = 0x%08x\n",
+		(unsigned int)R128_READ( R128_PM4_BUFFER_DL_RPTR ) );
+	printk( "PM4_MICRO_CNTL     = 0x%08x\n",
+		(unsigned int)R128_READ( R128_PM4_MICRO_CNTL ) );
+	printk( "PM4_BUFFER_CNTL    = 0x%08x\n",
+		(unsigned int)R128_READ( R128_PM4_BUFFER_CNTL ) );
+}
+#endif
+
+
+/* ================================================================
+ * Engine, FIFO control
+ */
+
+static int r128_do_pixcache_flush( drm_r128_private_t *dev_priv )
+{
+	u32 tmp;
+	int i;
+
+	tmp = R128_READ( R128_PC_NGUI_CTLSTAT ) | R128_PC_FLUSH_ALL;
+	R128_WRITE( R128_PC_NGUI_CTLSTAT, tmp );
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		if ( !(R128_READ( R128_PC_NGUI_CTLSTAT ) & R128_PC_BUSY) ) {
+			return 0;
+		}
+		udelay( 1 );
+	}
+
+	DRM_ERROR( "%s failed!\n", __FUNCTION__ );
+	return -EBUSY;
+}
+
+static int r128_do_wait_for_fifo( drm_r128_private_t *dev_priv, int entries )
+{
+	int i;
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		int slots = R128_READ( R128_GUI_STAT ) & R128_GUI_FIFOCNT_MASK;
+		if ( slots >= entries ) return 0;
+		udelay( 1 );
+	}
+
+	DRM_ERROR( "%s failed!\n", __FUNCTION__ );
+	return -EBUSY;
+}
+
+static int r128_do_wait_for_idle( drm_r128_private_t *dev_priv )
+{
+	int i, ret;
+
+	ret = r128_do_wait_for_fifo( dev_priv, 64 );
+	if ( !ret ) return ret;
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		if ( !(R128_READ( R128_GUI_STAT ) & R128_GUI_ACTIVE) ) {
+			r128_do_pixcache_flush( dev_priv );
+			return 0;
+		}
+		udelay( 1 );
+	}
+
+	DRM_ERROR( "%s failed!\n", __FUNCTION__ );
+	return -EBUSY;
+}
+
+
+/* ================================================================
+ * CCE control, initialization
+ */
+
+/* Load the microcode for the CCE */
+static void r128_cce_load_microcode( drm_r128_private_t *dev_priv )
+{
+	int i;
+
+	r128_do_wait_for_idle( dev_priv );
+
+	R128_WRITE( R128_PM4_MICROCODE_ADDR, 0 );
+	for ( i = 0 ; i < 256 ; i++ ) {
+		R128_WRITE( R128_PM4_MICROCODE_DATAH,
+			    r128_cce_microcode[i * 2] );
+		R128_WRITE( R128_PM4_MICROCODE_DATAL,
+			    r128_cce_microcode[i * 2 + 1] );
+	}
+}
+
+/* Flush any pending commands to the CCE.  This should only be used just
+ * prior to a wait for idle, as it informs the engine that the command
+ * stream is ending.
+ */
+static void r128_do_cce_flush( drm_r128_private_t *dev_priv )
+{
+	u32 tmp;
+
+	tmp = R128_READ( R128_PM4_BUFFER_DL_WPTR ) | R128_PM4_BUFFER_DL_DONE;
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, tmp );
+}
+
+/* Wait for the CCE to go idle.
+ */
+static int r128_do_cce_idle( drm_r128_private_t *dev_priv )
+{
+	int i;
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+#ifndef CONFIG_AGP_I460
+		if ( *dev_priv->ring.head == dev_priv->ring.tail ) {
+#else
+		/*
+		 * XXX - this is (I think) a 460GX specific hack
+		 *
+		 * When doing texturing, ring.tail sometimes gets ahead of
+		 * PM4_BUFFER_DL_WPTR by 2; consequently, the card processes
+		 * its whole quota of instructions and *ring.head is still 2
+		 * short of ring.tail.  Work around this for now in lieu of
+		 * a better solution.
+		 */
+		if ( (*dev_priv->ring.head == dev_priv->ring.tail) ||
+			((dev_priv->ring.tail - *dev_priv->ring.head) == 2) ) {
+#endif
+			int pm4stat = R128_READ( R128_PM4_STAT );
+			if ( ( (pm4stat & R128_PM4_FIFOCNT_MASK) >=
+			       dev_priv->cce_fifo_size ) &&
+			     !(pm4stat & (R128_PM4_BUSY |
+					  R128_PM4_GUI_ACTIVE)) ) {
+				return r128_do_pixcache_flush( dev_priv );
+			}
+		}
+		udelay( 1 );
+	}
+
+#if 0
+	DRM_ERROR( "failed!\n" );
+	r128_status( dev_priv );
+#endif
+	return -EBUSY;
+}
+
+/* Start the Concurrent Command Engine.
+ */
+static void r128_do_cce_start( drm_r128_private_t *dev_priv )
+{
+	r128_do_wait_for_idle( dev_priv );
+
+	R128_WRITE( R128_PM4_BUFFER_CNTL,
+		    dev_priv->cce_mode | dev_priv->ring.size_l2qw );
+	R128_READ( R128_PM4_BUFFER_ADDR ); /* as per the sample code */
+	R128_WRITE( R128_PM4_MICRO_CNTL, R128_PM4_MICRO_FREERUN );
+
+	dev_priv->cce_running = 1;
+}
+
+/* Reset the Concurrent Command Engine.  This will not flush any pending
+ * commangs, so you must wait for the CCE command stream to complete
+ * before calling this routine.
+ */
+static void r128_do_cce_reset( drm_r128_private_t *dev_priv )
+{
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
+	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
+	*dev_priv->ring.head = 0;
+	dev_priv->ring.tail = 0;
+}
+
+/* Stop the Concurrent Command Engine.  This will not flush any pending
+ * commangs, so you must flush the command stream and wait for the CCE
+ * to go idle before calling this routine.
+ */
+static void r128_do_cce_stop( drm_r128_private_t *dev_priv )
+{
+	R128_WRITE( R128_PM4_MICRO_CNTL, 0 );
+	R128_WRITE( R128_PM4_BUFFER_CNTL, R128_PM4_NONPM4 );
+
+	dev_priv->cce_running = 0;
+}
+
+/* Reset the engine.  This will stop the CCE if it is running.
+ */
+static int r128_do_engine_reset( drm_device_t *dev )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	u32 clock_cntl_index, mclk_cntl, gen_reset_cntl;
+
+	r128_do_pixcache_flush( dev_priv );
+
+	clock_cntl_index = R128_READ( R128_CLOCK_CNTL_INDEX );
+	mclk_cntl = R128_READ_PLL( dev, R128_MCLK_CNTL );
+
+	R128_WRITE_PLL( R128_MCLK_CNTL,
+			mclk_cntl | R128_FORCE_GCP | R128_FORCE_PIPE3D_CP );
+
+	gen_reset_cntl = R128_READ( R128_GEN_RESET_CNTL );
+
+	/* Taken from the sample code - do not change */
+	R128_WRITE( R128_GEN_RESET_CNTL,
+		    gen_reset_cntl | R128_SOFT_RESET_GUI );
+	R128_READ( R128_GEN_RESET_CNTL );
+	R128_WRITE( R128_GEN_RESET_CNTL,
+		    gen_reset_cntl & ~R128_SOFT_RESET_GUI );
+	R128_READ( R128_GEN_RESET_CNTL );
+
+	R128_WRITE_PLL( R128_MCLK_CNTL, mclk_cntl );
+	R128_WRITE( R128_CLOCK_CNTL_INDEX, clock_cntl_index );
+	R128_WRITE( R128_GEN_RESET_CNTL, gen_reset_cntl );
+
+	/* Reset the CCE ring */
+	r128_do_cce_reset( dev_priv );
+
+	/* The CCE is no longer running after an engine reset */
+	dev_priv->cce_running = 0;
+
+	/* Reset any pending vertex, indirect buffers */
+	r128_freelist_reset( dev );
+
+	return 0;
+}
+
+static void r128_cce_init_ring_buffer( drm_device_t *dev )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	u32 ring_start;
+	u32 tmp;
+
+	/* The manual (p. 2) says this address is in "VM space".  This
+	 * means it's an offset from the start of AGP space.
+	 */
+	ring_start = dev_priv->cce_ring->offset - dev->agp->base;
+	R128_WRITE( R128_PM4_BUFFER_OFFSET, ring_start | R128_AGP_OFFSET );
+
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
+	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
+
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+	/*
+	 * XXX - This is a 460GX specific hack
+	 *
+	 * We have to hack this right now.  460GX isn't claiming PCI writes
+	 * from the card into the AGP aperture.  Because of this, we have
+	 * to get space outside of the aperture for RPTR_ADDR.
+	 */
+	if(dev->agp->agp_info.chipset == INTEL_460GX) {
+		dev_priv->ring.head = (void *) 
+					__get_free_page(GFP_KERNEL | GFP_DMA);
+		atomic_inc(&virt_to_page(dev_priv->ring.head)->count);
+		set_bit(PG_locked, &virt_to_page(dev_priv->ring.head)->flags);
+		dev_priv->ring.head = __va(dev_priv->ring.head);
+
+		*dev_priv->ring.head = 0;
+		R128_WRITE(R128_PM4_BUFFER_DL_RPTR_ADDR, 
+					__pa(dev_priv->ring.head));
+	} else {
+#else
+	/* DL_RPTR_ADDR is a physical address in AGP space. */
+	*dev_priv->ring.head = 0;
+	R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
+		    dev_priv->ring_rptr->offset );
+#endif
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+	}
+#endif
+
+	/* Set watermark control */
+	R128_WRITE( R128_PM4_BUFFER_WM_CNTL,
+		    ((R128_WATERMARK_L/4) << R128_WMA_SHIFT)
+		    | ((R128_WATERMARK_M/4) << R128_WMB_SHIFT)
+		    | ((R128_WATERMARK_N/4) << R128_WMC_SHIFT)
+		    | ((R128_WATERMARK_K/64) << R128_WB_WM_SHIFT) );
+
+	/* Force read.  Why?  Because it's in the examples... */
+	R128_READ( R128_PM4_BUFFER_ADDR );
+
+	/* Turn on bus mastering */
+	tmp = R128_READ( R128_BUS_CNTL ) & ~R128_BUS_MASTER_DIS;
+	R128_WRITE( R128_BUS_CNTL, tmp );
+}
+
+static int r128_do_init_cce( drm_device_t *dev, drm_r128_init_t *init )
+{
+	drm_r128_private_t *dev_priv;
+        int i;
+
+	dev_priv = drm_alloc( sizeof(drm_r128_private_t), DRM_MEM_DRIVER );
+	if ( dev_priv == NULL )
+		return -ENOMEM;
+	dev->dev_private = (void *)dev_priv;
+
+	memset( dev_priv, 0, sizeof(drm_r128_private_t) );
+
+	dev_priv->is_pci = init->is_pci;
+
+	/* GH: We don't support PCI cards until PCI GART is implemented.
+	 * Fail here so we can remove all checks for PCI cards around
+	 * the CCE ring code.
+	 */
+	if ( dev_priv->is_pci ) {
+		drm_free( dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+		return -EINVAL;
+	}
+
+	dev_priv->usec_timeout = init->usec_timeout;
+	if ( dev_priv->usec_timeout < 1 ||
+	     dev_priv->usec_timeout > R128_MAX_USEC_TIMEOUT ) {
+		drm_free( dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+		return -EINVAL;
+	}
+
+	dev_priv->cce_mode = init->cce_mode;
+	dev_priv->cce_secure = init->cce_secure;
+
+	/* GH: Simple idle check.
+	 */
+	atomic_set( &dev_priv->idle_count, 0 );
+
+	/* We don't support anything other than bus-mastering ring mode,
+	 * but the ring can be in either AGP or PCI space for the ring
+	 * read pointer.
+	 */
+	if ( ( init->cce_mode != R128_PM4_192BM ) &&
+	     ( init->cce_mode != R128_PM4_128BM_64INDBM ) &&
+	     ( init->cce_mode != R128_PM4_64BM_128INDBM ) &&
+	     ( init->cce_mode != R128_PM4_64BM_64VCBM_64INDBM ) ) {
+		drm_free( dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+		return -EINVAL;
+	}
+
+	switch ( init->cce_mode ) {
+	case R128_PM4_NONPM4:
+		dev_priv->cce_fifo_size = 0;
+		break;
+	case R128_PM4_192PIO:
+	case R128_PM4_192BM:
+		dev_priv->cce_fifo_size = 192;
+		break;
+	case R128_PM4_128PIO_64INDBM:
+	case R128_PM4_128BM_64INDBM:
+		dev_priv->cce_fifo_size = 128;
+		break;
+	case R128_PM4_64PIO_128INDBM:
+	case R128_PM4_64BM_128INDBM:
+	case R128_PM4_64PIO_64VCBM_64INDBM:
+	case R128_PM4_64BM_64VCBM_64INDBM:
+	case R128_PM4_64PIO_64VCPIO_64INDPIO:
+		dev_priv->cce_fifo_size = 64;
+		break;
+	}
+
+	dev_priv->fb_bpp	= init->fb_bpp;
+	dev_priv->front_offset	= init->front_offset;
+	dev_priv->front_pitch	= init->front_pitch;
+	dev_priv->back_offset	= init->back_offset;
+	dev_priv->back_pitch	= init->back_pitch;
+
+	dev_priv->depth_bpp	= init->depth_bpp;
+	dev_priv->depth_offset	= init->depth_offset;
+	dev_priv->depth_pitch	= init->depth_pitch;
+	dev_priv->span_offset	= init->span_offset;
+
+	dev_priv->front_pitch_offset_c = (((dev_priv->front_pitch/8) << 21) |
+					  (dev_priv->front_offset >> 5));
+	dev_priv->back_pitch_offset_c = (((dev_priv->back_pitch/8) << 21) |
+					 (dev_priv->back_offset >> 5));
+	dev_priv->depth_pitch_offset_c = (((dev_priv->depth_pitch/8) << 21) |
+					  (dev_priv->depth_offset >> 5) |
+					  R128_DST_TILE);
+	dev_priv->span_pitch_offset_c = (((dev_priv->depth_pitch/8) << 21) |
+					 (dev_priv->span_offset >> 5));
+
+	/* FIXME: We want multiple shared areas, including one shared
+	 * only by the X Server and kernel module.
+	 */
+	for ( i = 0 ; i < dev->map_count ; i++ ) {
+		if ( dev->maplist[i]->type == _DRM_SHM ) {
+			dev_priv->sarea = dev->maplist[i];
+			break;
+		}
+	}
+
+	DO_FIND_MAP( dev_priv->fb, init->fb_offset );
+	DO_FIND_MAP( dev_priv->mmio, init->mmio_offset );
+	DO_FIND_MAP( dev_priv->cce_ring, init->ring_offset );
+	DO_FIND_MAP( dev_priv->ring_rptr, init->ring_rptr_offset );
+	DO_FIND_MAP( dev_priv->buffers, init->buffers_offset );
+
+	if ( !dev_priv->is_pci ) {
+		DO_FIND_MAP( dev_priv->agp_textures,
+			     init->agp_textures_offset );
+	}
+
+	dev_priv->sarea_priv =
+		(drm_r128_sarea_t *)((u8 *)dev_priv->sarea->handle +
+				     init->sarea_priv_offset);
+
+	DO_REMAP( dev_priv->cce_ring, dev );
+	DO_REMAP( dev_priv->ring_rptr, dev );
+	DO_REMAP( dev_priv->buffers, dev );
+#if 0
+	if ( !dev_priv->is_pci ) {
+		DO_REMAP( dev_priv->agp_textures, dev );
+	}
+#endif
+
+	dev_priv->ring.head = ((__volatile__ u32 *)
+			       dev_priv->ring_rptr->handle);
+
+	dev_priv->ring.start = (u32 *)dev_priv->cce_ring->handle;
+	dev_priv->ring.end = ((u32 *)dev_priv->cce_ring->handle
+			      + init->ring_size / sizeof(u32));
+	dev_priv->ring.size = init->ring_size;
+	dev_priv->ring.size_l2qw = drm_order( init->ring_size / 8 );
+
+	dev_priv->ring.tail_mask =
+		(dev_priv->ring.size / sizeof(u32)) - 1;
+
+	dev_priv->sarea_priv->last_frame = 0;
+	R128_WRITE( R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame );
+
+	dev_priv->sarea_priv->last_dispatch = 0;
+	R128_WRITE( R128_LAST_DISPATCH_REG,
+		    dev_priv->sarea_priv->last_dispatch );
+
+	r128_cce_init_ring_buffer( dev );
+	r128_cce_load_microcode( dev_priv );
+	r128_do_engine_reset( dev );
+
+	return 0;
+}
+
+static int r128_do_cleanup_cce( drm_device_t *dev )
+{
+	if ( dev->dev_private ) {
+		drm_r128_private_t *dev_priv = dev->dev_private;
+
+		DO_REMAPFREE( dev_priv->cce_ring, dev );
+		DO_REMAPFREE( dev_priv->ring_rptr, dev );
+		DO_REMAPFREE( dev_priv->buffers, dev );
+#if 0
+		if ( !dev_priv->is_pci ) {
+			DO_REMAPFREE( dev_priv->agp_textures, dev );
+		}
+#endif
+
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+		/*
+		 * Free the page we grabbed for RPTR_ADDR
+		 */
+		if(dev->agp->agp_info.chipset == INTEL_460GX) {
+			atomic_dec(&virt_to_page(dev_priv->ring.head)->count);
+			clear_bit(PG_locked, 
+				     &virt_to_page(dev_priv->ring.head)->flags);
+			wake_up(&virt_to_page(dev_priv->ring.head)->wait);
+			free_page((unsigned long) dev_priv->ring.head);
+		}
+#endif
+	
+		drm_free( dev->dev_private, sizeof(drm_r128_private_t),
+			  DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+int r128_cce_init( struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_r128_init_t init;
+
+	if ( copy_from_user( &init, (drm_r128_init_t *)arg, sizeof(init) ) )
+		return -EFAULT;
+
+	switch ( init.func ) {
+	case R128_INIT_CCE:
+		return r128_do_init_cce( dev, &init );
+	case R128_CLEANUP_CCE:
+		return r128_do_cleanup_cce( dev );
+	}
+
+	return -EINVAL;
+}
+
+int r128_cce_start( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4 ) {
+		DRM_DEBUG( "%s while CCE running\n", __FUNCTION__ );
+		return 0;
+	}
+
+	r128_do_cce_start( dev_priv );
+
+	return 0;
+}
+
+/* Stop the CCE.  The engine must have been idled before calling this
+ * routine.
+ */
+int r128_cce_stop( struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_cce_stop_t stop;
+	int ret;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &stop, (drm_r128_init_t *)arg, sizeof(stop) ) )
+		return -EFAULT;
+
+	/* Flush any pending CCE commands.  This ensures any outstanding
+	 * commands are exectuted by the engine before we turn it off.
+	 */
+	if ( stop.flush ) {
+		r128_do_cce_flush( dev_priv );
+	}
+
+	/* If we fail to make the engine go idle, we return an error
+	 * code so that the DRM ioctl wrapper can try again.
+	 */
+	if ( stop.idle ) {
+		ret = r128_do_cce_idle( dev_priv );
+		if ( ret < 0 ) return ret;
+	}
+
+	/* Finally, we can turn off the CCE.  If the engine isn't idle,
+	 * we will get some dropped triangles as they won't be fully
+	 * rendered before the CCE is shut down.
+	 */
+	r128_do_cce_stop( dev_priv );
+
+	/* Reset the engine */
+	r128_do_engine_reset( dev );
+
+	return 0;
+}
+
+/* Just reset the CCE ring.  Called as part of an X Server engine reset.
+ */
+int r128_cce_reset( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( !dev_priv ) {
+		DRM_DEBUG( "%s called before init done\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	r128_do_cce_reset( dev_priv );
+
+	/* The CCE is no longer running after an engine reset */
+	dev_priv->cce_running = 0;
+
+	return 0;
+}
+
+int r128_cce_idle( struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( dev_priv->cce_running ) {
+		r128_do_cce_flush( dev_priv );
+	}
+
+	return r128_do_cce_idle( dev_priv );
+}
+
+int r128_engine_reset( struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	return r128_do_engine_reset( dev );
+}
+
+
+/* ================================================================
+ * Freelist management
+ */
+#define R128_BUFFER_USED	0xffffffff
+#define R128_BUFFER_FREE	0
+
+#if 0
+static int r128_freelist_init( drm_device_t *dev )
+{
+	drm_device_dma_t *dma = dev->dma;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_buf_t *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_r128_freelist_t *entry;
+	int i;
+
+	dev_priv->head = drm_alloc( sizeof(drm_r128_freelist_t),
+				    DRM_MEM_DRIVER );
+	if ( dev_priv->head == NULL )
+		return -ENOMEM;
+
+	memset( dev_priv->head, 0, sizeof(drm_r128_freelist_t) );
+	dev_priv->head->age = R128_BUFFER_USED;
+
+	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+
+		entry = drm_alloc( sizeof(drm_r128_freelist_t),
+				   DRM_MEM_DRIVER );
+		if ( !entry ) return -ENOMEM;
+
+		entry->age = R128_BUFFER_FREE;
+		entry->buf = buf;
+		entry->prev = dev_priv->head;
+		entry->next = dev_priv->head->next;
+		if ( !entry->next )
+			dev_priv->tail = entry;
+
+		buf_priv->discard = 0;
+		buf_priv->dispatched = 0;
+		buf_priv->list_entry = entry;
+
+		dev_priv->head->next = entry;
+
+		if ( dev_priv->head->next )
+			dev_priv->head->next->prev = entry;
+	}
+
+	return 0;
+
+}
+#endif
+
+drm_buf_t *r128_freelist_get( drm_device_t *dev )
+{
+	drm_device_dma_t *dma = dev->dma;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_buf_t *buf;
+	int i, t;
+
+	/* FIXME: Optimize -- use freelist code */
+
+	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+		if ( buf->pid == 0 )
+			return buf;
+	}
+
+	for ( t = 0 ; t < dev_priv->usec_timeout ; t++ ) {
+		u32 done_age = R128_READ( R128_LAST_DISPATCH_REG );
+
+		for ( i = 0 ; i < dma->buf_count ; i++ ) {
+			buf = dma->buflist[i];
+			buf_priv = buf->dev_private;
+			if ( buf->pending && buf_priv->age <= done_age ) {
+				/* The buffer has been processed, so it
+				 * can now be used.
+				 */
+				buf->pending = 0;
+				return buf;
+			}
+		}
+		udelay( 1 );
+	}
+
+	DRM_ERROR( "returning NULL!\n" );
+	return NULL;
+}
+
+void r128_freelist_reset( drm_device_t *dev )
+{
+	drm_device_dma_t *dma = dev->dma;
+	int i;
+
+	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+		buf_priv->age = 0;
+	}
+}
+
+
+/* ================================================================
+ * CCE packet submission
+ */
+
+int r128_wait_ring( drm_r128_private_t *dev_priv, int n )
+{
+	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
+	int i;
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		ring->space = *ring->head - ring->tail;
+		if ( ring->space <= 0 )
+			ring->space += ring->size;
+
+		if ( ring->space >= n )
+			return 0;
+
+		udelay( 1 );
+	}
+
+	return -EBUSY;
+}
+
+void r128_update_ring_snapshot( drm_r128_private_t *dev_priv )
+{
+	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
+
+	ring->space = *ring->head - ring->tail;
+#if R128_PERFORMANCE_BOXES
+	if ( ring->space == 0 )
+		atomic_inc( &dev_priv->idle_count );
+#endif
+	if ( ring->space <= 0 )
+		ring->space += ring->size;
+}
+
+#if 0
+static int r128_verify_command( drm_r128_private_t *dev_priv,
+				u32 cmd, int *size )
+{
+	int writing = 1;
+
+	*size = 0;
+
+	switch ( cmd & R128_CCE_PACKET_MASK ) {
+	case R128_CCE_PACKET0:
+		if ( (cmd & R128_CCE_PACKET0_REG_MASK) <= (0x1004 >> 2) &&
+		     (cmd & R128_CCE_PACKET0_REG_MASK) !=
+		     (R128_PM4_VC_FPU_SETUP >> 2) ) {
+			writing = 0;
+		}
+		*size = ((cmd & R128_CCE_PACKET_COUNT_MASK) >> 16) + 2;
+		break;
+
+	case R128_CCE_PACKET1:
+		if ( (cmd & R128_CCE_PACKET1_REG0_MASK) <= (0x1004 >> 2) &&
+		     (cmd & R128_CCE_PACKET1_REG0_MASK) !=
+		     (R128_PM4_VC_FPU_SETUP >> 2) ) {
+			writing = 0;
+		}
+		if ( (cmd & R128_CCE_PACKET1_REG1_MASK) <= (0x1004 << 9) &&
+		     (cmd & R128_CCE_PACKET1_REG1_MASK) !=
+		     (R128_PM4_VC_FPU_SETUP << 9) ) {
+			writing = 0;
+		}
+		*size = 3;
+		break;
+
+	case R128_CCE_PACKET2:
+		break;
+
+	case R128_CCE_PACKET3:
+		*size = ((cmd & R128_CCE_PACKET_COUNT_MASK) >> 16) + 2;
+		break;
+
+	}
+
+	return writing;
+}
+
+static int r128_submit_packet_ring_secure( drm_r128_private_t *dev_priv,
+					   u32 *commands, int *count )
+{
+#if 0
+	int write = dev_priv->sarea_priv->ring_write;
+	int *write_ptr = dev_priv->ring_start + write;
+	int c = *count;
+	u32 tmp = 0;
+	int psize = 0;
+	int writing = 1;
+	int timeout;
+
+	while ( c > 0 ) {
+		tmp = *commands++;
+		if ( !psize ) {
+			writing = r128_verify_command( dev_priv, tmp, &psize );
+		}
+		psize--;
+
+		if ( writing ) {
+			write++;
+			*write_ptr++ = tmp;
+		}
+		if ( write >= dev_priv->ring_entries ) {
+			write = 0;
+			write_ptr = dev_priv->ring_start;
+		}
+		timeout = 0;
+		while ( write == *dev_priv->ring_read_ptr ) {
+			R128_READ( R128_PM4_BUFFER_DL_RPTR );
+			if ( timeout++ >= dev_priv->usec_timeout )
+				return -EBUSY;
+			udelay( 1 );
+		}
+		c--;
+	}
+
+	if ( write < 32 ) {
+		memcpy( dev_priv->ring_end,
+			dev_priv->ring_start,
+			write * sizeof(u32) );
+	}
+
+	/* Make sure WC cache has been flushed */
+	r128_flush_write_combine();
+
+	dev_priv->sarea_priv->ring_write = write;
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, write );
+
+	*count = 0;
+#endif
+	return 0;
+}
+
+static int r128_submit_packet_ring_insecure( drm_r128_private_t *dev_priv,
+					     u32 *commands, int *count )
+{
+#if 0
+	int write = dev_priv->sarea_priv->ring_write;
+	int *write_ptr = dev_priv->ring_start + write;
+	int c = *count;
+	int timeout;
+
+	while ( c > 0 ) {
+		write++;
+		*write_ptr++ = *commands++;
+		if ( write >= dev_priv->ring_entries ) {
+			write = 0;
+			write_ptr = dev_priv->ring_start;
+		}
+
+		timeout = 0;
+		while ( write == *dev_priv->ring_read_ptr ) {
+			R128_READ( R128_PM4_BUFFER_DL_RPTR );
+			if ( timeout++ >= dev_priv->usec_timeout )
+				return -EBUSY;
+			udelay( 1 );
+		}
+		c--;
+	}
+
+	if ( write < 32 ) {
+		memcpy( dev_priv->ring_end,
+			dev_priv->ring_start,
+			write * sizeof(u32) );
+	}
+
+	/* Make sure WC cache has been flushed */
+	r128_flush_write_combine();
+
+	dev_priv->sarea_priv->ring_write = write;
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, write );
+
+	*count = 0;
+#endif
+	return 0;
+}
+#endif
+
+/* Internal packet submission routine.  This uses the insecure versions
+ * of the packet submission functions, and thus should only be used for
+ * packets generated inside the kernel module.
+ */
+int r128_do_submit_packet( drm_r128_private_t *dev_priv,
+			   u32 *buffer, int count )
+{
+	int c = count;
+	int ret = 0;
+
+#if 0
+	int left = 0;
+
+	if ( c >= dev_priv->ring_entries ) {
+		c = dev_priv->ring_entries - 1;
+		left = count - c;
+	}
+
+	/* Since this is only used by the kernel we can use the
+	 * insecure ring buffer submit packet routine.
+	 */
+	ret = r128_submit_packet_ring_insecure( dev_priv, buffer, &c );
+	c += left;
+#endif
+
+	return ( ret < 0 ) ? ret : c;
+}
+
+/* External packet submission routine.  This uses the secure versions
+ * by default, and can thus submit packets received from user space.
+ */
+int r128_cce_packet( struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_packet_t packet;
+	u32 *buffer;
+	int c;
+	int size;
+	int ret = 0;
+
+#if 0
+	/* GH: Disable packet submission for now.
+	 */
+	return -EINVAL;
+#endif
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "r128_submit_packet called without lock held\n" );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &packet, (drm_r128_packet_t *)arg,
+			     sizeof(packet) ) )
+		return -EFAULT;
+
+#if 0
+	c = packet.count;
+	size = c * sizeof(*buffer);
+
+	{
+		int left = 0;
+
+		if ( c >= dev_priv->ring_entries ) {
+			c = dev_priv->ring_entries - 1;
+			size = c * sizeof(*buffer);
+			left = packet.count - c;
+		}
+
+		buffer = kmalloc( size, 0 );
+		if ( buffer == NULL)
+			return -ENOMEM;
+		if ( copy_from_user( buffer, packet.buffer, size ) )
+			return -EFAULT;
+
+		if ( dev_priv->cce_secure ) {
+			ret = r128_submit_packet_ring_secure( dev_priv,
+							      buffer, &c );
+		} else {
+			ret = r128_submit_packet_ring_insecure( dev_priv,
+								buffer, &c );
+		}
+		c += left;
+	}
+
+	kfree( buffer );
+#else
+	c = 0;
+#endif
+
+	packet.count = c;
+	if ( copy_to_user( (drm_r128_packet_t *)arg, &packet,
+			   sizeof(packet) ) )
+		return -EFAULT;
+
+	if ( ret ) {
+		return ret;
+	} else if ( c > 0 ) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+#if 0
+static int r128_send_vertbufs( drm_device_t *dev, drm_r128_vertex_t *v )
+{
+	drm_device_dma_t    *dma      = dev->dma;
+	drm_r128_private_t  *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_buf_t           *buf;
+	int                  i, ret;
+	RING_LOCALS;
+
+	/* Make sure we have valid data */
+	for (i = 0; i < v->send_count; i++) {
+		int idx = v->send_indices[i];
+
+		if (idx < 0 || idx >= dma->buf_count) {
+			DRM_ERROR("Index %d (of %d max)\n",
+				  idx, dma->buf_count - 1);
+			return -EINVAL;
+		}
+		buf = dma->buflist[idx];
+		if (buf->pid != current->pid) {
+			DRM_ERROR("Process %d using buffer owned by %d\n",
+				  current->pid, buf->pid);
+			return -EINVAL;
+		}
+		if (buf->pending) {
+			DRM_ERROR("Sending pending buffer:"
+				  " buffer %d, offset %d\n",
+				  v->send_indices[i], i);
+			return -EINVAL;
+		}
+	}
+
+	/* Wait for idle, if we've wrapped to make sure that all pending
+           buffers have been processed */
+	if (dev_priv->submit_age == R128_MAX_VBUF_AGE) {
+		if ((ret = r128_do_cce_idle(dev)) < 0) return ret;
+		dev_priv->submit_age = 0;
+		r128_freelist_reset(dev);
+	}
+
+	/* Make sure WC cache has been flushed (if in PIO mode) */
+	if (!dev_priv->cce_is_bm_mode) r128_flush_write_combine();
+
+	/* FIXME: Add support for sending vertex buffer to the CCE here
+	   instead of in client code.  The v->prim holds the primitive
+	   type that should be drawn.  Loop over the list buffers in
+	   send_indices[] and submit a packet for each VB.
+
+	   This will require us to loop over the clip rects here as
+	   well, which implies that we extend the kernel driver to allow
+	   cliprects to be stored here.  Note that the cliprects could
+	   possibly come from the X server instead of the client, but
+	   this will require additional changes to the DRI to allow for
+	   this optimization. */
+
+	/* Submit a CCE packet that writes submit_age to R128_VB_AGE_REG */
+#if 0
+	cce_buffer[0] = R128CCE0(R128_CCE_PACKET0, R128_VB_AGE_REG, 0);
+	cce_buffer[1] = dev_priv->submit_age;
+
+	if ((ret = r128_do_submit_packet(dev, cce_buffer, 2)) < 0) {
+		/* Until we add support for sending VBs to the CCE in
+		   this routine, we can recover from this error.  After
+		   we add that support, we won't be able to easily
+		   recover, so we will probably have to implement
+		   another mechanism for handling timeouts from packets
+		   submitted directly by the kernel. */
+		return ret;
+	}
+#else
+	BEGIN_RING( 2 );
+
+	OUT_RING( CCE_PACKET0( R128_VB_AGE_REG, 0 ) );
+	OUT_RING( dev_priv->submit_age );
+
+	ADVANCE_RING();
+#endif
+	/* Now that the submit packet request has succeeded, we can mark
+           the buffers as pending */
+	for (i = 0; i < v->send_count; i++) {
+		buf = dma->buflist[v->send_indices[i]];
+		buf->pending = 1;
+
+		buf_priv      = buf->dev_private;
+		buf_priv->age = dev_priv->submit_age;
+	}
+
+	dev_priv->submit_age++;
+
+	return 0;
+}
+#endif
+
+
+
+
+static int r128_cce_get_buffers( drm_device_t *dev, drm_dma_t *d )
+{
+	int i;
+	drm_buf_t *buf;
+
+	for ( i = d->granted_count ; i < d->request_count ; i++ ) {
+		buf = r128_freelist_get( dev );
+		if ( !buf ) return -EAGAIN;
+
+		buf->pid = current->pid;
+
+		if ( copy_to_user( &d->request_indices[i], &buf->idx,
+				   sizeof(buf->idx) ) )
+			return -EFAULT;
+		if ( copy_to_user( &d->request_sizes[i], &buf->total,
+				   sizeof(buf->total) ) )
+			return -EFAULT;
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int r128_cce_buffers( struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+	int ret = 0;
+	drm_dma_t d;
+
+	if ( copy_from_user( &d, (drm_dma_t *) arg, sizeof(d) ) )
+		return -EFAULT;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	/* Please don't send us buffers.
+	 */
+	if ( d.send_count != 0 ) {
+		DRM_ERROR( "Process %d trying to send %d buffers via drmDMA\n",
+			   current->pid, d.send_count );
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if ( d.request_count < 0 || d.request_count > dma->buf_count ) {
+		DRM_ERROR( "Process %d trying to get %d buffers (of %d max)\n",
+			   current->pid, d.request_count, dma->buf_count );
+		return -EINVAL;
+	}
+
+	d.granted_count = 0;
+
+	if ( d.request_count ) {
+		ret = r128_cce_get_buffers( dev, &d );
+	}
+
+	if ( copy_to_user( (drm_dma_t *) arg, &d, sizeof(d) ) )
+		return -EFAULT;
+
+	return ret;
+}
diff -urN linux.orig/drivers/char/drm-4.0/r128_context.c linux/drivers/char/drm-4.0/r128_context.c
--- linux.orig/drivers/char/drm-4.0/r128_context.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/r128_context.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,217 @@
+/* r128_context.c -- IOCTLs for r128 contexts -*- linux-c -*-
+ * Created: Mon Dec 13 09:51:35 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "r128_drv.h"
+
+extern drm_ctx_t r128_res_ctx;
+
+static int r128_alloc_queue(drm_device_t *dev)
+{
+	return drm_ctxbitmap_next(dev);
+}
+
+int r128_context_switch(drm_device_t *dev, int old, int new)
+{
+        char        buf[64];
+
+        atomic_inc(&dev->total_ctx);
+
+        if (test_and_set_bit(0, &dev->context_flag)) {
+                DRM_ERROR("Reentering -- FIXME\n");
+                return -EBUSY;
+        }
+
+#if DRM_DMA_HISTOGRAM
+        dev->ctx_start = get_cycles();
+#endif
+
+        DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+        if (new == dev->last_context) {
+                clear_bit(0, &dev->context_flag);
+                return 0;
+        }
+
+        if (drm_flags & DRM_FLAG_NOCTX) {
+                r128_context_switch_complete(dev, new);
+        } else {
+                sprintf(buf, "C %d %d\n", old, new);
+                drm_write_string(dev, buf);
+        }
+
+        return 0;
+}
+
+int r128_context_switch_complete(drm_device_t *dev, int new)
+{
+        dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
+        dev->last_switch  = jiffies;
+
+        if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+                DRM_ERROR("Lock isn't held after context switch\n");
+        }
+
+				/* If a context switch is ever initiated
+                                   when the kernel holds the lock, release
+                                   that lock here. */
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.ctx[drm_histogram_slot(get_cycles()
+                                                      - dev->ctx_start)]);
+
+#endif
+        clear_bit(0, &dev->context_flag);
+        wake_up(&dev->context_wait);
+
+        return 0;
+}
+
+
+int r128_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_res_t	res;
+	drm_ctx_t	ctx;
+	int		i;
+
+	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
+	if (copy_from_user(&res, (drm_ctx_res_t *)arg, sizeof(res)))
+		return -EFAULT;
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+			ctx.handle = i;
+			if (copy_to_user(&res.contexts[i],
+					 &i,
+					 sizeof(i)))
+				return -EFAULT;
+		}
+	}
+	res.count = DRM_RESERVED_CONTEXTS;
+	if (copy_to_user((drm_ctx_res_t *)arg, &res, sizeof(res)))
+		return -EFAULT;
+	return 0;
+}
+
+
+int r128_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	if ((ctx.handle = r128_alloc_queue(dev)) == DRM_KERNEL_CONTEXT) {
+				/* Skip kernel's context and get a new one. */
+		ctx.handle = r128_alloc_queue(dev);
+	}
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (ctx.handle == -1) {
+		DRM_DEBUG("Not enough free contexts.\n");
+				/* Should this return -EBUSY instead? */
+		return -ENOMEM;
+	}
+
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int r128_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	if (ctx.flags==_DRM_CONTEXT_PRESERVED)
+		r128_res_ctx.handle=ctx.handle;
+	return 0;
+}
+
+int r128_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	/* This is 0, because we don't hanlde any context flags */
+	ctx.flags = 0;
+	if (copy_to_user((drm_ctx_t*)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int r128_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	return r128_context_switch(dev, dev->last_context, ctx.handle);
+}
+
+int r128_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	r128_context_switch_complete(dev, ctx.handle);
+
+	return 0;
+}
+
+int r128_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	drm_ctxbitmap_free(dev, ctx.handle);
+
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/r128_drm.h linux/drivers/char/drm-4.0/r128_drm.h
--- linux.orig/drivers/char/drm-4.0/r128_drm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/r128_drm.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,272 @@
+/* r128_drm.h -- Public header for the r128 driver -*- linux-c -*-
+ * Created: Wed Apr  5 19:24:19 2000 by kevin@precisioninsight.com
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#ifndef _R128_DRM_H_
+#define _R128_DRM_H_
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the X server file (r128_sarea.h)
+ */
+#ifndef __R128_SAREA_DEFINES__
+#define __R128_SAREA_DEFINES__
+
+/* What needs to be changed for the current vertex buffer?
+ */
+#define R128_UPLOAD_CONTEXT		0x001
+#define R128_UPLOAD_SETUP		0x002
+#define R128_UPLOAD_TEX0		0x004
+#define R128_UPLOAD_TEX1		0x008
+#define R128_UPLOAD_TEX0IMAGES		0x010
+#define R128_UPLOAD_TEX1IMAGES		0x020
+#define R128_UPLOAD_CORE		0x040
+#define R128_UPLOAD_MASKS		0x080
+#define R128_UPLOAD_WINDOW		0x100
+#define R128_UPLOAD_CLIPRECTS		0x200	/* handled client-side */
+#define R128_REQUIRE_QUIESCENCE		0x400
+#define R128_UPLOAD_ALL			0x7ff
+
+#define R128_FRONT			0x1
+#define R128_BACK			0x2
+#define R128_DEPTH			0x4
+
+/* Primitive types
+ */
+#define R128_POINTS			0x1
+#define R128_LINES			0x2
+#define R128_LINE_STRIP			0x3
+#define R128_TRIANGLES			0x4
+#define R128_TRIANGLE_FAN		0x5
+#define R128_TRIANGLE_STRIP		0x6
+
+/* Vertex/indirect buffer size
+ */
+#if 1
+#define R128_BUFFER_SIZE		16384
+#else
+#define R128_BUFFER_SIZE		(128 * 1024)
+#endif
+
+/* Byte offsets for indirect buffer data
+ */
+#define R128_INDEX_PRIM_OFFSET		20
+#define R128_HOSTDATA_BLIT_OFFSET	32
+
+/* 2048x2048 @ 32bpp texture requires this many indirect buffers
+ */
+#define R128_MAX_BLIT_BUFFERS		((2048 * 2048 * 4) / R128_BUFFER_SIZE)
+
+/* Keep these small for testing.
+ */
+#define R128_NR_SAREA_CLIPRECTS		12
+
+/* There are 2 heaps (local/AGP).  Each region within a heap is a
+ *  minimum of 64k, and there are at most 64 of them per heap.
+ */
+#define R128_LOCAL_TEX_HEAP		0
+#define R128_AGP_TEX_HEAP		1
+#define R128_NR_TEX_HEAPS		2
+#define R128_NR_TEX_REGIONS		64
+#define R128_LOG_TEX_GRANULARITY	16
+
+#define R128_NR_CONTEXT_REGS		12
+#define R128_TEX_MAXLEVELS		11
+
+#endif /* __R128_SAREA_DEFINES__ */
+
+typedef struct {
+	/* Context state - can be written in one large chunk */
+	unsigned int dst_pitch_offset_c;
+	unsigned int dp_gui_master_cntl_c;
+	unsigned int sc_top_left_c;
+	unsigned int sc_bottom_right_c;
+	unsigned int z_offset_c;
+	unsigned int z_pitch_c;
+	unsigned int z_sten_cntl_c;
+	unsigned int tex_cntl_c;
+	unsigned int misc_3d_state_cntl_reg;
+	unsigned int texture_clr_cmp_clr_c;
+	unsigned int texture_clr_cmp_msk_c;
+	unsigned int fog_color_c;
+
+	/* Texture state */
+	unsigned int tex_size_pitch_c;
+	unsigned int constant_color_c;
+
+	/* Setup state */
+	unsigned int pm4_vc_fpu_setup;
+	unsigned int setup_cntl;
+
+	/* Mask state */
+	unsigned int dp_write_mask;
+	unsigned int sten_ref_mask_c;
+	unsigned int plane_3d_mask_c;
+
+	/* Window state */
+	unsigned int window_xy_offset;
+
+	/* Core state */
+	unsigned int scale_3d_cntl;
+} drm_r128_context_regs_t;
+
+/* Setup registers for each texture unit */
+typedef struct {
+	unsigned int tex_cntl;
+	unsigned int tex_combine_cntl;
+	unsigned int tex_size_pitch;
+	unsigned int tex_offset[R128_TEX_MAXLEVELS];
+	unsigned int tex_border_color;
+} drm_r128_texture_regs_t;
+
+
+typedef struct drm_tex_region {
+	unsigned char next, prev;
+	unsigned char in_use;
+	int age;
+} drm_tex_region_t;
+
+typedef struct drm_r128_sarea {
+	/* The channel for communication of state information to the kernel
+	 * on firing a vertex buffer.
+	 */
+	drm_r128_context_regs_t context_state;
+	drm_r128_texture_regs_t tex_state[R128_NR_TEX_HEAPS];
+	unsigned int dirty;
+	unsigned int vertsize;
+	unsigned int vc_format;
+
+	/* The current cliprects, or a subset thereof.
+	 */
+	drm_clip_rect_t boxes[R128_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
+
+	/* Counters for client-side throttling of rendering clients.
+	 */
+	unsigned int last_frame;
+	unsigned int last_dispatch;
+
+	drm_tex_region_t tex_list[R128_NR_TEX_HEAPS][R128_NR_TEX_REGIONS+1];
+	int tex_age[R128_NR_TEX_HEAPS];
+	int ctx_owner;
+} drm_r128_sarea_t;
+
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (xf86drmR128.h)
+ */
+typedef struct drm_r128_init {
+	enum {
+		R128_INIT_CCE    = 0x01,
+		R128_CLEANUP_CCE = 0x02
+	} func;
+	int sarea_priv_offset;
+	int is_pci;
+	int cce_mode;
+	int cce_secure;
+	int ring_size;
+	int usec_timeout;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+	unsigned int span_offset;
+
+	unsigned int fb_offset;
+	unsigned int mmio_offset;
+	unsigned int ring_offset;
+	unsigned int ring_rptr_offset;
+	unsigned int buffers_offset;
+	unsigned int agp_textures_offset;
+} drm_r128_init_t;
+
+typedef struct drm_r128_cce_stop {
+	int flush;
+	int idle;
+} drm_r128_cce_stop_t;
+
+typedef struct drm_r128_clear {
+	unsigned int flags;
+	int x, y, w, h;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+} drm_r128_clear_t;
+
+typedef struct drm_r128_vertex {
+	int prim;
+	int idx;			/* Index of vertex buffer */
+	int count;			/* Number of vertices in buffer */
+	int discard;			/* Client finished with buffer? */
+} drm_r128_vertex_t;
+
+typedef struct drm_r128_indices {
+	int prim;
+	int idx;
+	int start;
+	int end;
+	int discard;			/* Client finished with buffer? */
+} drm_r128_indices_t;
+
+typedef struct drm_r128_blit {
+	int idx;
+	int pitch;
+	int offset;
+	int format;
+	unsigned short x, y;
+	unsigned short width, height;
+} drm_r128_blit_t;
+
+typedef struct drm_r128_depth {
+	enum {
+		R128_WRITE_SPAN		= 0x01,
+		R128_WRITE_PIXELS	= 0x02,
+		R128_READ_SPAN		= 0x03,
+		R128_READ_PIXELS	= 0x04
+	} func;
+	int n;
+	int *x;
+	int *y;
+	unsigned int *buffer;
+	unsigned char *mask;
+} drm_r128_depth_t;
+
+typedef struct drm_r128_stipple {
+	unsigned int *mask;
+} drm_r128_stipple_t;
+
+typedef struct drm_r128_packet {
+	unsigned int *buffer;
+	int count;
+	int flags;
+} drm_r128_packet_t;
+
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/r128_drv.c linux/drivers/char/drm-4.0/r128_drv.c
--- linux.orig/drivers/char/drm-4.0/r128_drv.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/r128_drv.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,699 @@
+/* r128_drv.c -- ATI Rage 128 driver -*- linux-c -*-
+ * Created: Mon Dec 13 09:47:27 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "r128_drv.h"
+
+#define R128_NAME		"r128"
+#define R128_DESC		"ATI Rage 128"
+#define R128_DATE		"20001215"
+#define R128_MAJOR		2
+#define R128_MINOR		1
+#define R128_PATCHLEVEL		2
+
+static drm_device_t	r128_device;
+drm_ctx_t		r128_res_ctx;
+
+static struct file_operations r128_fops = {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* This started being used during 2.4.0-test */
+	owner:   THIS_MODULE,
+#endif
+	open:	 r128_open,
+	flush:	 drm_flush,
+	release: r128_release,
+	ioctl:	 r128_ioctl,
+	mmap:	 drm_mmap,
+	read:	 drm_read,
+	fasync:	 drm_fasync,
+	poll:	 drm_poll,
+};
+
+static struct miscdevice      r128_misc = {
+	minor: MISC_DYNAMIC_MINOR,
+	name:  R128_NAME,
+	fops:  &r128_fops,
+};
+
+static drm_ioctl_desc_t	      r128_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]      = { r128_version,      0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)]   = { drm_getunique,     0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]    = { drm_getmagic,      0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]    = { drm_irq_busid,     0, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)]   = { drm_setunique,     1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]	       = { drm_block,         1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]      = { drm_unblock,       1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)]   = { drm_authmagic,     1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]      = { drm_addmap,        1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)]     = { r128_addbufs,      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)]    = { drm_markbufs,      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)]    = { drm_infobufs,      1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MAP_BUFS)]     = { r128_mapbufs,      1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)]    = { drm_freebufs,      1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]      = { r128_addctx,	      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]       = { r128_rmctx,	      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]      = { r128_modctx,	      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]      = { r128_getctx,	      1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)]   = { r128_switchctx,    1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]      = { r128_newctx,	      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]      = { r128_resctx,	      1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]     = { drm_adddraw,	      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]      = { drm_rmdraw,	      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_DMA)]	       = { r128_cce_buffers,  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	       = { r128_lock,	      1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]       = { r128_unlock,	      1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]       = { drm_finish,	      1, 0 },
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)]  = { drm_agp_acquire,   1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)]  = { drm_agp_release,   1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)]   = { drm_agp_enable,    1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)]     = { drm_agp_info,      1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)]    = { drm_agp_alloc,     1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)]     = { drm_agp_free,      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)]     = { drm_agp_bind,      1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)]   = { drm_agp_unbind,    1, 1 },
+#endif
+
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_INIT)]    = { r128_cce_init,     1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_START)] = { r128_cce_start,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_STOP)]  = { r128_cce_stop,   1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_RESET)] = { r128_cce_reset,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_CCE_IDLE)]  = { r128_cce_idle,   1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_RESET)]   = { r128_engine_reset, 1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_SWAP)]    = { r128_cce_swap,     1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_CLEAR)]   = { r128_cce_clear,    1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_VERTEX)]  = { r128_cce_vertex,   1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_INDICES)] = { r128_cce_indices,  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_BLIT)]    = { r128_cce_blit,     1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_DEPTH)]   = { r128_cce_depth,    1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_STIPPLE)] = { r128_cce_stipple,  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_R128_PACKET)]  = { r128_cce_packet,   1, 0 },
+};
+#define R128_IOCTL_COUNT DRM_ARRAY_SIZE(r128_ioctls)
+
+#ifdef MODULE
+static char		      *r128 = NULL;
+#endif
+
+MODULE_AUTHOR("VA Linux Systems, Inc.");
+MODULE_DESCRIPTION("r128");
+MODULE_PARM(r128, "s");
+
+#ifndef MODULE
+/* r128_options is called by the kernel to parse command-line options
+ * passed via the boot-loader (e.g., LILO).  It calls the insmod option
+ * routine, drm_parse_drm.
+ */
+
+static int __init r128_options(char *str)
+{
+	drm_parse_options(str);
+	return 1;
+}
+
+__setup("r128=", r128_options);
+#endif
+
+static int r128_setup(drm_device_t *dev)
+{
+	int i;
+
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
+	dev->buf_use	  = 0;
+	atomic_set(&dev->buf_alloc, 0);
+
+	drm_dma_setup(dev);
+
+	atomic_set(&dev->total_open, 0);
+	atomic_set(&dev->total_close, 0);
+	atomic_set(&dev->total_ioctl, 0);
+	atomic_set(&dev->total_irq, 0);
+	atomic_set(&dev->total_ctx, 0);
+	atomic_set(&dev->total_locks, 0);
+	atomic_set(&dev->total_unlocks, 0);
+	atomic_set(&dev->total_contends, 0);
+	atomic_set(&dev->total_sleeps, 0);
+
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		dev->magiclist[i].head = NULL;
+		dev->magiclist[i].tail = NULL;
+	}
+	dev->maplist	    = NULL;
+	dev->map_count	    = 0;
+	dev->vmalist	    = NULL;
+	dev->lock.hw_lock   = NULL;
+	init_waitqueue_head(&dev->lock.lock_queue);
+	dev->queue_count    = 0;
+	dev->queue_reserved = 0;
+	dev->queue_slots    = 0;
+	dev->queuelist	    = NULL;
+	dev->irq	    = 0;
+	dev->context_flag   = 0;
+	dev->interrupt_flag = 0;
+	dev->dma_flag	    = 0;
+	dev->last_context   = 0;
+	dev->last_switch    = 0;
+	dev->last_checked   = 0;
+	init_timer(&dev->timer);
+	init_waitqueue_head(&dev->context_wait);
+
+	dev->ctx_start	    = 0;
+	dev->lck_start	    = 0;
+
+	dev->buf_rp	  = dev->buf;
+	dev->buf_wp	  = dev->buf;
+	dev->buf_end	  = dev->buf + DRM_BSZ;
+	dev->buf_async	  = NULL;
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
+
+	r128_res_ctx.handle=-1;
+
+	DRM_DEBUG("\n");
+
+	/* The kernel's context could be created here, but is now created
+	   in drm_dma_enqueue.	This is more resource-efficient for
+	   hardware that does not do DMA, but may mean that
+	   drm_select_queue fails between the time the interrupt is
+	   initialized and the time the queues are initialized. */
+
+	return 0;
+}
+
+
+static int r128_takedown(drm_device_t *dev)
+{
+	int		  i;
+	drm_magic_entry_t *pt, *next;
+	drm_map_t	  *map;
+	drm_vma_entry_t	  *vma, *vma_next;
+
+	DRM_DEBUG("\n");
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
+
+	if (dev->devname) {
+		drm_free(dev->devname, strlen(dev->devname)+1, DRM_MEM_DRIVER);
+		dev->devname = NULL;
+	}
+
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique)+1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
+				/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
+			next = pt->next;
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+		}
+		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
+	}
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+				/* Clear AGP information */
+	if (dev->agp) {
+		drm_agp_mem_t *entry;
+		drm_agp_mem_t *nexte;
+
+				/* Remove AGP resources, but leave dev->agp
+                                   intact until r128_cleanup is called. */
+		for (entry = dev->agp->memory; entry; entry = nexte) {
+			nexte = entry->next;
+			if (entry->bound) drm_unbind_agp(entry->memory);
+			drm_free_agp(entry->memory, entry->pages);
+			drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+		}
+		dev->agp->memory = NULL;
+
+		if (dev->agp->acquired)	_drm_agp_release();
+
+		dev->agp->acquired = 0;
+		dev->agp->enabled  = 0;
+	}
+#endif
+
+				/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
+			vma_next = vma->next;
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		}
+		dev->vmalist = NULL;
+	}
+
+				/* Clear map area and mtrr information */
+	if (dev->maplist) {
+		for (i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			switch (map->type) {
+			case _DRM_REGISTERS:
+			case _DRM_FRAME_BUFFER:
+#ifdef CONFIG_MTRR
+				if (map->mtrr >= 0) {
+					int retcode;
+					retcode = mtrr_del(map->mtrr,
+							   map->offset,
+							   map->size);
+					DRM_DEBUG("mtrr_del = %d\n", retcode);
+				}
+#endif
+				drm_ioremapfree(map->handle, map->size, dev);
+				break;
+			case _DRM_SHM:
+				drm_free_pages((unsigned long)map->handle,
+					       drm_order(map->size)
+					       - PAGE_SHIFT,
+					       DRM_MEM_SAREA);
+				break;
+			case _DRM_AGP:
+				/* Do nothing here, because this is all
+                                   handled in the AGP/GART driver. */
+				break;
+			}
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		}
+		drm_free(dev->maplist,
+			 dev->map_count * sizeof(*dev->maplist),
+			 DRM_MEM_MAPS);
+		dev->maplist   = NULL;
+		dev->map_count = 0;
+	}
+
+	drm_dma_takedown(dev);
+
+	dev->queue_count     = 0;
+	if (dev->lock.hw_lock) {
+		dev->lock.hw_lock    = NULL; /* SHM removed */
+		dev->lock.pid	     = 0;
+		wake_up_interruptible(&dev->lock.lock_queue);
+	}
+	up(&dev->struct_sem);
+
+	return 0;
+}
+
+/* r128_init is called via init_module at module load time, or via
+ * linux/init/main.c (this is not currently supported). */
+
+static int __init r128_init(void)
+{
+	int		      retcode;
+	drm_device_t	      *dev = &r128_device;
+
+	DRM_DEBUG("\n");
+
+	memset((void *)dev, 0, sizeof(*dev));
+	dev->count_lock	  = SPIN_LOCK_UNLOCKED;
+	sema_init(&dev->struct_sem, 1);
+
+#ifdef MODULE
+	drm_parse_options(r128);
+#endif
+
+	if ((retcode = misc_register(&r128_misc))) {
+		DRM_ERROR("Cannot register \"%s\"\n", R128_NAME);
+		return retcode;
+	}
+	dev->device = MKDEV(MISC_MAJOR, r128_misc.minor);
+	dev->name   = R128_NAME;
+
+	drm_mem_init();
+	drm_proc_init(dev);
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	dev->agp    = drm_agp_init();
+	if (dev->agp == NULL) {
+		DRM_ERROR("Cannot initialize agpgart module.\n");
+		drm_proc_cleanup();
+		misc_deregister(&r128_misc);
+		r128_takedown(dev);
+		return -ENOMEM;
+	}
+
+#ifdef CONFIG_MTRR
+	dev->agp->agp_mtrr = mtrr_add(dev->agp->agp_info.aper_base,
+				      dev->agp->agp_info.aper_size*1024*1024,
+				      MTRR_TYPE_WRCOMB,
+				      1);
+#endif
+#endif
+
+	if((retcode = drm_ctxbitmap_init(dev))) {
+		DRM_ERROR("Cannot allocate memory for context bitmap.\n");
+		drm_proc_cleanup();
+		misc_deregister(&r128_misc);
+		r128_takedown(dev);
+		return retcode;
+	}
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d\n",
+		 R128_NAME,
+		 R128_MAJOR,
+		 R128_MINOR,
+		 R128_PATCHLEVEL,
+		 R128_DATE,
+		 r128_misc.minor);
+
+	return 0;
+}
+
+/* r128_cleanup is called via cleanup_module at module unload time. */
+
+static void __exit r128_cleanup(void)
+{
+	drm_device_t	      *dev = &r128_device;
+
+	DRM_DEBUG("\n");
+
+	drm_proc_cleanup();
+	if (misc_deregister(&r128_misc)) {
+		DRM_ERROR("Cannot unload module\n");
+	} else {
+		DRM_INFO("Module unloaded\n");
+	}
+	drm_ctxbitmap_cleanup(dev);
+	r128_takedown(dev);
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	if (dev->agp) {
+		drm_agp_uninit();
+		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
+		dev->agp = NULL;
+	}
+#endif
+}
+
+module_init(r128_init);
+module_exit(r128_cleanup);
+
+
+int r128_version(struct inode *inode, struct file *filp,
+		 unsigned int cmd, unsigned long arg)
+{
+	drm_version_t version;
+	int	      len;
+
+	if (copy_from_user(&version,
+			   (drm_version_t *)arg,
+			   sizeof(version)))
+		return -EFAULT;
+
+#define DRM_COPY(name,value)					\
+	len = strlen(value);					\
+	if (len > name##_len) len = name##_len;			\
+	name##_len = strlen(value);				\
+	if (len && name) {					\
+		if (copy_to_user(name, value, len))		\
+			return -EFAULT;				\
+	}
+
+	version.version_major	   = R128_MAJOR;
+	version.version_minor	   = R128_MINOR;
+	version.version_patchlevel = R128_PATCHLEVEL;
+
+	DRM_COPY(version.name, R128_NAME);
+	DRM_COPY(version.date, R128_DATE);
+	DRM_COPY(version.desc, R128_DESC);
+
+	if (copy_to_user((drm_version_t *)arg,
+			 &version,
+			 sizeof(version)))
+		return -EFAULT;
+	return 0;
+}
+
+int r128_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t  *dev    = &r128_device;
+	int	      retcode = 0;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_open_helper(inode, filp, dev))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_INC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_open);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return r128_setup(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+
+	return retcode;
+}
+
+int r128_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev;
+	int	      retcode = 0;
+
+	lock_kernel();
+	dev = priv->dev;
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_release(inode, filp))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_DEC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_close);
+		spin_lock(&dev->count_lock);
+		if (!--dev->open_count) {
+			if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+				DRM_ERROR("Device busy: %d %d\n",
+					  atomic_read(&dev->ioctl_count),
+					  dev->blocked);
+				spin_unlock(&dev->count_lock);
+				unlock_kernel();
+				return -EBUSY;
+			}
+			spin_unlock(&dev->count_lock);
+			unlock_kernel();
+			return r128_takedown(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+
+	unlock_kernel();
+	return retcode;
+}
+
+/* r128_ioctl is called whenever a process performs an ioctl on /dev/drm. */
+int r128_ioctl(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
+{
+	int		 nr	 = DRM_IOCTL_NR(cmd);
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	int		 retcode = 0;
+	drm_ioctl_desc_t *ioctl;
+	drm_ioctl_t	 *func;
+
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->total_ioctl);
+	++priv->ioctl_count;
+
+	DRM_DEBUG("pid = %d, cmd = 0x%02x, nr = 0x%02x, dev 0x%x, auth = %d\n",
+		  current->pid, cmd, nr, dev->device, priv->authenticated);
+
+	if (nr >= R128_IOCTL_COUNT) {
+		retcode = -EINVAL;
+	} else {
+		ioctl	  = &r128_ioctls[nr];
+		func	  = ioctl->func;
+
+		if (!func) {
+			DRM_DEBUG("no function\n");
+			retcode = -EINVAL;
+		} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN))
+			   || (ioctl->auth_needed && !priv->authenticated)) {
+			retcode = -EACCES;
+		} else {
+			retcode = (func)(inode, filp, cmd, arg);
+		}
+	}
+
+#if 0
+	if ( retcode ) {
+		DRM_INFO( "%s 0x%x ret = %d\n", __FUNCTION__, nr, retcode );
+	}
+#endif
+
+	atomic_dec(&dev->ioctl_count);
+	return retcode;
+}
+
+int r128_lock(struct inode *inode, struct file *filp,
+	      unsigned int cmd, unsigned long arg)
+{
+        drm_file_t        *priv   = filp->private_data;
+        drm_device_t      *dev    = priv->dev;
+        DECLARE_WAITQUEUE(entry, current);
+        int               ret   = 0;
+        drm_lock_t        lock;
+#if DRM_DMA_HISTOGRAM
+        cycles_t          start;
+
+        dev->lck_start = start = get_cycles();
+#endif
+
+        if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+        if (lock.context == DRM_KERNEL_CONTEXT) {
+                DRM_ERROR("Process %d using kernel context %d\n",
+                          current->pid, lock.context);
+                return -EINVAL;
+        }
+
+        DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+                  lock.context, current->pid, dev->lock.hw_lock->lock,
+                  lock.flags);
+
+        if (lock.context < 0)
+                return -EINVAL;
+
+        if (!ret) {
+                add_wait_queue(&dev->lock.lock_queue, &entry);
+                for (;;) {
+                        current->state = TASK_INTERRUPTIBLE;
+                        if (!dev->lock.hw_lock) {
+                                /* Device has been unregistered */
+                                ret = -EINTR;
+                                break;
+                        }
+                        if (drm_lock_take(&dev->lock.hw_lock->lock,
+                                          lock.context)) {
+                                dev->lock.pid       = current->pid;
+                                dev->lock.lock_time = jiffies;
+                                atomic_inc(&dev->total_locks);
+                                break;  /* Got lock */
+                        }
+
+                                /* Contention */
+                        atomic_inc(&dev->total_sleeps);
+                        schedule();
+                        if (signal_pending(current)) {
+                                ret = -ERESTARTSYS;
+                                break;
+                        }
+                }
+                current->state = TASK_RUNNING;
+                remove_wait_queue(&dev->lock.lock_queue, &entry);
+        }
+
+        if (!ret) {
+		sigemptyset(&dev->sigmask);
+		sigaddset(&dev->sigmask, SIGSTOP);
+		sigaddset(&dev->sigmask, SIGTSTP);
+		sigaddset(&dev->sigmask, SIGTTIN);
+		sigaddset(&dev->sigmask, SIGTTOU);
+		dev->sigdata.context = lock.context;
+		dev->sigdata.lock    = dev->lock.hw_lock;
+		block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+                if (lock.flags & _DRM_LOCK_READY) {
+				/* Wait for space in DMA/FIFO */
+		}
+                if (lock.flags & _DRM_LOCK_QUIESCENT) {
+				/* Make hardware quiescent */
+			DRM_DEBUG( "not quiescent!\n" );
+#if 0
+                        r128_quiescent(dev);
+#endif
+		}
+        }
+
+#if LINUX_VERSION_CODE < 0x020400
+	if (lock.context != r128_res_ctx.handle) {
+		current->counter = 5;
+		current->priority = DEF_PRIORITY/4;
+	}
+#endif
+        DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
+
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.lacq[drm_histogram_slot(get_cycles() - start)]);
+#endif
+
+        return ret;
+}
+
+
+int r128_unlock(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d frees lock (%d holds)\n",
+		  lock.context,
+		  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	atomic_inc(&dev->total_unlocks);
+	if (_DRM_LOCK_IS_CONT(dev->lock.hw_lock->lock))
+		atomic_inc(&dev->total_contends);
+	drm_lock_transfer(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
+				/* FIXME: Try to send data to card here */
+	if (!dev->context_flag) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+
+#if LINUX_VERSION_CODE < 0x020400
+	if (lock.context != r128_res_ctx.handle) {
+		current->counter = 5;
+		current->priority = DEF_PRIORITY;
+	}
+#endif
+	unblock_all_signals();
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/r128_drv.h linux/drivers/char/drm-4.0/r128_drv.h
--- linux.orig/drivers/char/drm-4.0/r128_drv.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/r128_drv.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,469 @@
+/* r128_drv.h -- Private header for r128 driver -*- linux-c -*-
+ * Created: Mon Dec 13 09:51:11 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@valinux.com>
+ *   Kevin E. Martin <martin@valinux.com>
+ *   Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#ifndef __R128_DRV_H__
+#define __R128_DRV_H__
+
+typedef struct drm_r128_freelist {
+   	unsigned int age;
+   	drm_buf_t *buf;
+   	struct drm_r128_freelist *next;
+   	struct drm_r128_freelist *prev;
+} drm_r128_freelist_t;
+
+typedef struct drm_r128_ring_buffer {
+	u32 *start;
+	u32 *end;
+	int size;
+	int size_l2qw;
+
+	volatile u32 *head;
+	u32 tail;
+	u32 tail_mask;
+	int space;
+} drm_r128_ring_buffer_t;
+
+typedef struct drm_r128_private {
+	drm_r128_ring_buffer_t ring;
+	drm_r128_sarea_t *sarea_priv;
+
+	int cce_mode;
+	int cce_fifo_size;
+	int cce_secure;
+	int cce_running;
+
+   	drm_r128_freelist_t *head;
+   	drm_r128_freelist_t *tail;
+
+	int usec_timeout;
+	int is_pci;
+
+	atomic_t idle_count;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset;
+	unsigned int front_pitch;
+	unsigned int back_offset;
+	unsigned int back_pitch;
+
+	unsigned int depth_bpp;
+	unsigned int depth_offset;
+	unsigned int depth_pitch;
+	unsigned int span_offset;
+
+	u32 front_pitch_offset_c;
+	u32 back_pitch_offset_c;
+	u32 depth_pitch_offset_c;
+	u32 span_pitch_offset_c;
+
+	drm_map_t *sarea;
+	drm_map_t *fb;
+	drm_map_t *mmio;
+	drm_map_t *cce_ring;
+	drm_map_t *ring_rptr;
+	drm_map_t *buffers;
+	drm_map_t *agp_textures;
+} drm_r128_private_t;
+
+typedef struct drm_r128_buf_priv {
+	u32 age;
+	int prim;
+	int discard;
+	int dispatched;
+   	drm_r128_freelist_t *list_entry;
+} drm_r128_buf_priv_t;
+
+				/* r128_drv.c */
+extern int  r128_version( struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg );
+extern int  r128_open( struct inode *inode, struct file *filp );
+extern int  r128_release( struct inode *inode, struct file *filp );
+extern int  r128_ioctl( struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg );
+extern int  r128_lock( struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg );
+extern int  r128_unlock( struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg );
+
+				/* r128_cce.c */
+extern int r128_cce_init( struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg );
+extern int r128_cce_start( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int r128_cce_stop( struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg );
+extern int r128_cce_reset( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int r128_cce_idle( struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg );
+extern int r128_engine_reset( struct inode *inode, struct file *filp,
+			      unsigned int cmd, unsigned long arg );
+extern int r128_cce_packet( struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg );
+extern int r128_cce_buffers( struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg );
+
+extern void r128_freelist_reset( drm_device_t *dev );
+extern drm_buf_t *r128_freelist_get( drm_device_t *dev );
+
+extern int r128_wait_ring( drm_r128_private_t *dev_priv, int n );
+extern void r128_update_ring_snapshot( drm_r128_private_t *dev_priv );
+
+				/* r128_state.c */
+extern int r128_cce_clear( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int r128_cce_swap( struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg );
+extern int r128_cce_vertex( struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg );
+extern int r128_cce_indices( struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg );
+extern int r128_cce_blit( struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg );
+extern int r128_cce_depth( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int r128_cce_stipple( struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg );
+
+				/* r128_bufs.c */
+extern int r128_addbufs(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int r128_mapbufs(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+
+				/* r128_context.c */
+extern int  r128_resctx(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  r128_addctx(struct inode *inode, struct file *filp,
+		        unsigned int cmd, unsigned long arg);
+extern int  r128_modctx(struct inode *inode, struct file *filp,
+		        unsigned int cmd, unsigned long arg);
+extern int  r128_getctx(struct inode *inode, struct file *filp,
+		        unsigned int cmd, unsigned long arg);
+extern int  r128_switchctx(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int  r128_newctx(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  r128_rmctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+
+extern int  r128_context_switch(drm_device_t *dev, int old, int new);
+extern int  r128_context_switch_complete(drm_device_t *dev, int new);
+
+
+/* Register definitions, register access macros and drmAddMap constants
+ * for Rage 128 kernel driver.
+ */
+
+#define R128_AUX_SC_CNTL		0x1660
+#	define R128_AUX1_SC_EN			(1 << 0)
+#	define R128_AUX1_SC_MODE_OR		(0 << 1)
+#	define R128_AUX1_SC_MODE_NAND		(1 << 1)
+#	define R128_AUX2_SC_EN			(1 << 2)
+#	define R128_AUX2_SC_MODE_OR		(0 << 3)
+#	define R128_AUX2_SC_MODE_NAND		(1 << 3)
+#	define R128_AUX3_SC_EN			(1 << 4)
+#	define R128_AUX3_SC_MODE_OR		(0 << 5)
+#	define R128_AUX3_SC_MODE_NAND		(1 << 5)
+#define R128_AUX1_SC_LEFT		0x1664
+#define R128_AUX1_SC_RIGHT		0x1668
+#define R128_AUX1_SC_TOP		0x166c
+#define R128_AUX1_SC_BOTTOM		0x1670
+#define R128_AUX2_SC_LEFT		0x1674
+#define R128_AUX2_SC_RIGHT		0x1678
+#define R128_AUX2_SC_TOP		0x167c
+#define R128_AUX2_SC_BOTTOM		0x1680
+#define R128_AUX3_SC_LEFT		0x1684
+#define R128_AUX3_SC_RIGHT		0x1688
+#define R128_AUX3_SC_TOP		0x168c
+#define R128_AUX3_SC_BOTTOM		0x1690
+
+#define R128_BRUSH_DATA0		0x1480
+#define R128_BUS_CNTL			0x0030
+#	define R128_BUS_MASTER_DIS		(1 << 6)
+
+#define R128_CLOCK_CNTL_INDEX		0x0008
+#define R128_CLOCK_CNTL_DATA		0x000c
+#	define R128_PLL_WR_EN			(1 << 7)
+
+#define R128_CONSTANT_COLOR_C		0x1d34
+
+#define R128_DP_GUI_MASTER_CNTL		0x146c
+#       define R128_GMC_SRC_PITCH_OFFSET_CNTL	(1    <<  0)
+#       define R128_GMC_DST_PITCH_OFFSET_CNTL	(1    <<  1)
+#	define R128_GMC_BRUSH_SOLID_COLOR	(13   <<  4)
+#	define R128_GMC_BRUSH_NONE		(15   <<  4)
+#	define R128_GMC_DST_16BPP		(4    <<  8)
+#	define R128_GMC_DST_24BPP		(5    <<  8)
+#	define R128_GMC_DST_32BPP		(6    <<  8)
+#       define R128_GMC_DST_DATATYPE_SHIFT	8
+#	define R128_GMC_SRC_DATATYPE_COLOR	(3    << 12)
+#	define R128_DP_SRC_SOURCE_MEMORY	(2    << 24)
+#	define R128_DP_SRC_SOURCE_HOST_DATA	(3    << 24)
+#	define R128_GMC_CLR_CMP_CNTL_DIS	(1    << 28)
+#	define R128_GMC_AUX_CLIP_DIS		(1    << 29)
+#	define R128_GMC_WR_MSK_DIS		(1    << 30)
+#	define R128_ROP3_S			0x00cc0000
+#	define R128_ROP3_P			0x00f00000
+#define R128_DP_WRITE_MASK		0x16cc
+#define R128_DST_PITCH_OFFSET_C		0x1c80
+#	define R128_DST_TILE			(1 << 31)
+
+#define R128_GEN_RESET_CNTL		0x00f0
+#	define R128_SOFT_RESET_GUI		(1 <<  0)
+
+#define R128_GUI_SCRATCH_REG0		0x15e0
+#define R128_GUI_SCRATCH_REG1		0x15e4
+#define R128_GUI_SCRATCH_REG2		0x15e8
+#define R128_GUI_SCRATCH_REG3		0x15ec
+#define R128_GUI_SCRATCH_REG4		0x15f0
+#define R128_GUI_SCRATCH_REG5		0x15f4
+
+#define R128_GUI_STAT			0x1740
+#	define R128_GUI_FIFOCNT_MASK		0x0fff
+#	define R128_GUI_ACTIVE			(1 << 31)
+
+#define R128_MCLK_CNTL			0x000f
+#	define R128_FORCE_GCP			(1 << 16)
+#	define R128_FORCE_PIPE3D_CP		(1 << 17)
+#	define R128_FORCE_RCP			(1 << 18)
+
+#define R128_PC_GUI_CTLSTAT		0x1748
+#define R128_PC_NGUI_CTLSTAT		0x0184
+#	define R128_PC_FLUSH_GUI		(3 << 0)
+#	define R128_PC_RI_GUI			(1 << 2)
+#	define R128_PC_FLUSH_ALL		0x00ff
+#	define R128_PC_BUSY			(1 << 31)
+
+#define R128_PRIM_TEX_CNTL_C		0x1cb0
+
+#define R128_SCALE_3D_CNTL		0x1a00
+#define R128_SEC_TEX_CNTL_C		0x1d00
+#define R128_SEC_TEXTURE_BORDER_COLOR_C	0x1d3c
+#define R128_SETUP_CNTL			0x1bc4
+#define R128_STEN_REF_MASK_C		0x1d40
+
+#define R128_TEX_CNTL_C			0x1c9c
+#	define R128_TEX_CACHE_FLUSH		(1 << 23)
+
+#define R128_WINDOW_XY_OFFSET		0x1bcc
+
+
+/* CCE registers
+ */
+#define R128_PM4_BUFFER_OFFSET		0x0700
+#define R128_PM4_BUFFER_CNTL		0x0704
+#	define R128_PM4_MASK			(15 << 28)
+#	define R128_PM4_NONPM4			(0  << 28)
+#	define R128_PM4_192PIO			(1  << 28)
+#	define R128_PM4_192BM			(2  << 28)
+#	define R128_PM4_128PIO_64INDBM		(3  << 28)
+#	define R128_PM4_128BM_64INDBM		(4  << 28)
+#	define R128_PM4_64PIO_128INDBM		(5  << 28)
+#	define R128_PM4_64BM_128INDBM		(6  << 28)
+#	define R128_PM4_64PIO_64VCBM_64INDBM	(7  << 28)
+#	define R128_PM4_64BM_64VCBM_64INDBM	(8  << 28)
+#	define R128_PM4_64PIO_64VCPIO_64INDPIO	(15 << 28)
+
+#define R128_PM4_BUFFER_WM_CNTL		0x0708
+#	define R128_WMA_SHIFT			0
+#	define R128_WMB_SHIFT			8
+#	define R128_WMC_SHIFT			16
+#	define R128_WB_WM_SHIFT			24
+
+#define R128_PM4_BUFFER_DL_RPTR_ADDR	0x070c
+#define R128_PM4_BUFFER_DL_RPTR		0x0710
+#define R128_PM4_BUFFER_DL_WPTR		0x0714
+#	define R128_PM4_BUFFER_DL_DONE		(1 << 31)
+
+#define R128_PM4_VC_FPU_SETUP		0x071c
+
+#define R128_PM4_IW_INDOFF		0x0738
+#define R128_PM4_IW_INDSIZE		0x073c
+
+#define R128_PM4_STAT			0x07b8
+#	define R128_PM4_FIFOCNT_MASK		0x0fff
+#	define R128_PM4_BUSY			(1 << 16)
+#	define R128_PM4_GUI_ACTIVE		(1 << 31)
+
+#define R128_PM4_MICROCODE_ADDR		0x07d4
+#define R128_PM4_MICROCODE_RADDR	0x07d8
+#define R128_PM4_MICROCODE_DATAH	0x07dc
+#define R128_PM4_MICROCODE_DATAL	0x07e0
+
+#define R128_PM4_BUFFER_ADDR		0x07f0
+#define R128_PM4_MICRO_CNTL		0x07fc
+#	define R128_PM4_MICRO_FREERUN		(1 << 30)
+
+#define R128_PM4_FIFO_DATA_EVEN		0x1000
+#define R128_PM4_FIFO_DATA_ODD		0x1004
+
+
+/* CCE command packets
+ */
+#define R128_CCE_PACKET0		0x00000000
+#define R128_CCE_PACKET1		0x40000000
+#define R128_CCE_PACKET2		0x80000000
+#define R128_CCE_PACKET3		0xC0000000
+#	define R128_CNTL_HOSTDATA_BLT		0x00009400
+#	define R128_CNTL_PAINT_MULTI		0x00009A00
+#	define R128_CNTL_BITBLT_MULTI		0x00009B00
+#	define R128_3D_RNDR_GEN_INDX_PRIM	0x00002300
+
+#define R128_CCE_PACKET_MASK		0xC0000000
+#define R128_CCE_PACKET_COUNT_MASK	0x3fff0000
+#define R128_CCE_PACKET0_REG_MASK	0x000007ff
+#define R128_CCE_PACKET1_REG0_MASK	0x000007ff
+#define R128_CCE_PACKET1_REG1_MASK	0x003ff800
+
+#define R128_CCE_VC_CNTL_PRIM_TYPE_NONE		0x00000000
+#define R128_CCE_VC_CNTL_PRIM_TYPE_POINT	0x00000001
+#define R128_CCE_VC_CNTL_PRIM_TYPE_LINE		0x00000002
+#define R128_CCE_VC_CNTL_PRIM_TYPE_POLY_LINE	0x00000003
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_LIST	0x00000004
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_FAN	0x00000005
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_STRIP	0x00000006
+#define R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2	0x00000007
+#define R128_CCE_VC_CNTL_PRIM_WALK_IND		0x00000010
+#define R128_CCE_VC_CNTL_PRIM_WALK_LIST		0x00000020
+#define R128_CCE_VC_CNTL_PRIM_WALK_RING		0x00000030
+#define R128_CCE_VC_CNTL_NUM_SHIFT		16
+
+#define R128_DATATYPE_CI8		2
+#define R128_DATATYPE_ARGB1555		3
+#define R128_DATATYPE_RGB565		4
+#define R128_DATATYPE_RGB888		5
+#define R128_DATATYPE_ARGB8888		6
+#define R128_DATATYPE_RGB332		7
+#define R128_DATATYPE_RGB8		9
+#define R128_DATATYPE_ARGB4444		15
+
+/* Constants */
+#define R128_AGP_OFFSET			0x02000000
+
+#define R128_WATERMARK_L		16
+#define R128_WATERMARK_M		8
+#define R128_WATERMARK_N		8
+#define R128_WATERMARK_K		128
+
+#define R128_MAX_USEC_TIMEOUT	100000	/* 100 ms */
+
+#define R128_LAST_FRAME_REG		R128_GUI_SCRATCH_REG0
+#define R128_LAST_DISPATCH_REG		R128_GUI_SCRATCH_REG1
+#define R128_MAX_VB_AGE			0xffffffff
+
+#define R128_MAX_VB_VERTS		(0xffff)
+
+
+#define R128_BASE(reg)		((unsigned long)(dev_priv->mmio->handle))
+#define R128_ADDR(reg)		(R128_BASE(reg) + reg)
+
+#define R128_READ(reg)		readl(R128_ADDR(reg))
+#define R128_WRITE(reg,val)	writel(val,R128_ADDR(reg))
+
+#define R128_READ8(reg)		readb(R128_ADDR(reg))
+#define R128_WRITE8(reg,val)	writeb(val,R128_ADDR(reg))
+
+#define R128_WRITE_PLL(addr,val)                                              \
+do {                                                                          \
+	R128_WRITE8(R128_CLOCK_CNTL_INDEX, ((addr) & 0x1f) | R128_PLL_WR_EN); \
+	R128_WRITE(R128_CLOCK_CNTL_DATA, (val));                              \
+} while (0)
+
+extern int R128_READ_PLL(drm_device_t *dev, int addr);
+
+#define R128CCE0(p,r,n)   ((p) | ((n) << 16) | ((r) >> 2))
+#define R128CCE1(p,r1,r2) ((p) | (((r2) >> 2) << 11) | ((r1) >> 2))
+#define R128CCE2(p)       ((p))
+#define R128CCE3(p,n)     ((p) | ((n) << 16))
+
+
+
+
+#define CCE_PACKET0( reg, n )		(R128_CCE_PACKET0 |		\
+					 ((n) << 16) | ((reg) >> 2))
+#define CCE_PACKET1( reg0, reg1 )	(R128_CCE_PACKET1 |		\
+					 (((reg1) >> 2) << 11) | ((reg0) >> 2))
+#define CCE_PACKET2()			(R128_CCE_PACKET2)
+#define CCE_PACKET3( pkt, n )		(R128_CCE_PACKET3 |		\
+					 (pkt) | ((n) << 16))
+
+
+#define r128_flush_write_combine()		mb()
+
+
+#define R128_VERBOSE	0
+
+#define RING_LOCALS	int write; unsigned int tail_mask; volatile u32 *ring;
+
+#define BEGIN_RING( n ) do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "BEGIN_RING( %d ) in %s\n",			\
+			   n, __FUNCTION__ );				\
+	}								\
+	if ( dev_priv->ring.space < n * sizeof(u32) ) {			\
+		r128_wait_ring( dev_priv, n * sizeof(u32) );		\
+	}								\
+	dev_priv->ring.space -= n * sizeof(u32);			\
+	ring = dev_priv->ring.start;					\
+	write = dev_priv->ring.tail;					\
+	tail_mask = dev_priv->ring.tail_mask;				\
+} while (0)
+
+#define ADVANCE_RING() do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "ADVANCE_RING() tail=0x%06x wr=0x%06x\n",	\
+			  write, dev_priv->ring.tail );			\
+	}								\
+	if ( write < 32 ) {						\
+		memcpy( dev_priv->ring.end,				\
+			dev_priv->ring.start,				\
+			write * sizeof(u32) );				\
+	}								\
+	r128_flush_write_combine();					\
+	dev_priv->ring.tail = write;					\
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, write );			\
+} while (0)
+
+#define OUT_RING( x ) do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "   OUT_RING( 0x%08x ) at 0x%x\n",		\
+			   (unsigned int)(x), write );			\
+	}								\
+	ring[write++] = x;						\
+	write &= tail_mask;						\
+} while (0)
+
+#define R128_PERFORMANCE_BOXES	0
+
+#endif /* __R128_DRV_H__ */
diff -urN linux.orig/drivers/char/drm-4.0/r128_state.c linux/drivers/char/drm-4.0/r128_state.c
--- linux.orig/drivers/char/drm-4.0/r128_state.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/r128_state.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1605 @@
+/* r128_state.c -- State support for r128 -*- linux-c -*-
+ * Created: Thu Jan 27 02:53:43 2000 by gareth@valinux.com
+ *
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "r128_drv.h"
+#include "drm.h"
+
+
+/* ================================================================
+ * CCE hardware state programming functions
+ */
+
+static void r128_emit_clip_rects( drm_r128_private_t *dev_priv,
+				  drm_clip_rect_t *boxes, int count )
+{
+	u32 aux_sc_cntl = 0x00000000;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 17 );
+
+	if ( count >= 1 ) {
+		OUT_RING( CCE_PACKET0( R128_AUX1_SC_LEFT, 3 ) );
+		OUT_RING( boxes[0].x1 );
+		OUT_RING( boxes[0].x2 - 1 );
+		OUT_RING( boxes[0].y1 );
+		OUT_RING( boxes[0].y2 - 1 );
+
+		aux_sc_cntl |= (R128_AUX1_SC_EN | R128_AUX1_SC_MODE_OR);
+	}
+	if ( count >= 2 ) {
+		OUT_RING( CCE_PACKET0( R128_AUX2_SC_LEFT, 3 ) );
+		OUT_RING( boxes[1].x1 );
+		OUT_RING( boxes[1].x2 - 1 );
+		OUT_RING( boxes[1].y1 );
+		OUT_RING( boxes[1].y2 - 1 );
+
+		aux_sc_cntl |= (R128_AUX2_SC_EN | R128_AUX2_SC_MODE_OR);
+	}
+	if ( count >= 3 ) {
+		OUT_RING( CCE_PACKET0( R128_AUX3_SC_LEFT, 3 ) );
+		OUT_RING( boxes[2].x1 );
+		OUT_RING( boxes[2].x2 - 1 );
+		OUT_RING( boxes[2].y1 );
+		OUT_RING( boxes[2].y2 - 1 );
+
+		aux_sc_cntl |= (R128_AUX3_SC_EN | R128_AUX3_SC_MODE_OR);
+	}
+
+	OUT_RING( CCE_PACKET0( R128_AUX_SC_CNTL, 0 ) );
+	OUT_RING( aux_sc_cntl );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_core( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 2 );
+
+	OUT_RING( CCE_PACKET0( R128_SCALE_3D_CNTL, 0 ) );
+	OUT_RING( ctx->scale_3d_cntl );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_context( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 13 );
+
+	OUT_RING( CCE_PACKET0( R128_DST_PITCH_OFFSET_C, 11 ) );
+	OUT_RING( ctx->dst_pitch_offset_c );
+	OUT_RING( ctx->dp_gui_master_cntl_c );
+	OUT_RING( ctx->sc_top_left_c );
+	OUT_RING( ctx->sc_bottom_right_c );
+	OUT_RING( ctx->z_offset_c );
+	OUT_RING( ctx->z_pitch_c );
+	OUT_RING( ctx->z_sten_cntl_c );
+	OUT_RING( ctx->tex_cntl_c );
+	OUT_RING( ctx->misc_3d_state_cntl_reg );
+	OUT_RING( ctx->texture_clr_cmp_clr_c );
+	OUT_RING( ctx->texture_clr_cmp_msk_c );
+	OUT_RING( ctx->fog_color_c );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_setup( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 3 );
+
+	OUT_RING( CCE_PACKET1( R128_SETUP_CNTL, R128_PM4_VC_FPU_SETUP ) );
+	OUT_RING( ctx->setup_cntl );
+	OUT_RING( ctx->pm4_vc_fpu_setup );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_masks( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 5 );
+
+	OUT_RING( CCE_PACKET0( R128_DP_WRITE_MASK, 0 ) );
+	OUT_RING( ctx->dp_write_mask );
+
+	OUT_RING( CCE_PACKET0( R128_STEN_REF_MASK_C, 1 ) );
+	OUT_RING( ctx->sten_ref_mask_c );
+	OUT_RING( ctx->plane_3d_mask_c );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_window( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 2 );
+
+	OUT_RING( CCE_PACKET0( R128_WINDOW_XY_OFFSET, 0 ) );
+	OUT_RING( ctx->window_xy_offset );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_tex0( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_context_regs_t *ctx = &sarea_priv->context_state;
+	drm_r128_texture_regs_t *tex = &sarea_priv->tex_state[0];
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 7 + R128_TEX_MAXLEVELS );
+
+	OUT_RING( CCE_PACKET0( R128_PRIM_TEX_CNTL_C,
+			       2 + R128_TEX_MAXLEVELS ) );
+	OUT_RING( tex->tex_cntl );
+	OUT_RING( tex->tex_combine_cntl );
+	OUT_RING( ctx->tex_size_pitch_c );
+	for ( i = 0 ; i < R128_TEX_MAXLEVELS ; i++ ) {
+		OUT_RING( tex->tex_offset[i] );
+	}
+
+	OUT_RING( CCE_PACKET0( R128_CONSTANT_COLOR_C, 1 ) );
+	OUT_RING( ctx->constant_color_c );
+	OUT_RING( tex->tex_border_color );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_tex1( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_texture_regs_t *tex = &sarea_priv->tex_state[1];
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 5 + R128_TEX_MAXLEVELS );
+
+	OUT_RING( CCE_PACKET0( R128_SEC_TEX_CNTL_C,
+			       1 + R128_TEX_MAXLEVELS ) );
+	OUT_RING( tex->tex_cntl );
+	OUT_RING( tex->tex_combine_cntl );
+	for ( i = 0 ; i < R128_TEX_MAXLEVELS ; i++ ) {
+		OUT_RING( tex->tex_offset[i] );
+	}
+
+	OUT_RING( CCE_PACKET0( R128_SEC_TEXTURE_BORDER_COLOR_C, 0 ) );
+	OUT_RING( tex->tex_border_color );
+
+	ADVANCE_RING();
+}
+
+static inline void r128_emit_state( drm_r128_private_t *dev_priv )
+{
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+
+	DRM_DEBUG( "%s: dirty=0x%08x\n", __FUNCTION__, dirty );
+
+	if ( dirty & R128_UPLOAD_CORE ) {
+		r128_emit_core( dev_priv );
+		sarea_priv->dirty &= ~R128_UPLOAD_CORE;
+	}
+
+	if ( dirty & R128_UPLOAD_CONTEXT ) {
+		r128_emit_context( dev_priv );
+		sarea_priv->dirty &= ~R128_UPLOAD_CONTEXT;
+	}
+
+	if ( dirty & R128_UPLOAD_SETUP ) {
+		r128_emit_setup( dev_priv );
+		sarea_priv->dirty &= ~R128_UPLOAD_SETUP;
+	}
+
+	if ( dirty & R128_UPLOAD_MASKS ) {
+		r128_emit_masks( dev_priv );
+		sarea_priv->dirty &= ~R128_UPLOAD_MASKS;
+	}
+
+	if ( dirty & R128_UPLOAD_WINDOW ) {
+		r128_emit_window( dev_priv );
+		sarea_priv->dirty &= ~R128_UPLOAD_WINDOW;
+	}
+
+	if ( dirty & R128_UPLOAD_TEX0 ) {
+		r128_emit_tex0( dev_priv );
+		sarea_priv->dirty &= ~R128_UPLOAD_TEX0;
+	}
+
+	if ( dirty & R128_UPLOAD_TEX1 ) {
+		r128_emit_tex1( dev_priv );
+		sarea_priv->dirty &= ~R128_UPLOAD_TEX1;
+	}
+
+	/* Turn off the texture cache flushing */
+	sarea_priv->context_state.tex_cntl_c &= ~R128_TEX_CACHE_FLUSH;
+
+	sarea_priv->dirty &= ~R128_REQUIRE_QUIESCENCE;
+}
+
+
+#if R128_PERFORMANCE_BOXES
+/* ================================================================
+ * Performance monitoring functions
+ */
+
+static void r128_clear_box( drm_r128_private_t *dev_priv,
+			    int x, int y, int w, int h,
+			    int r, int g, int b )
+{
+	u32 pitch, offset;
+	u32 fb_bpp, color;
+	RING_LOCALS;
+
+	switch ( dev_priv->fb_bpp ) {
+	case 16:
+		fb_bpp = R128_GMC_DST_16BPP;
+		color = (((r & 0xf8) << 8) |
+			 ((g & 0xfc) << 3) |
+			 ((b & 0xf8) >> 3));
+		break;
+	case 24:
+		fb_bpp = R128_GMC_DST_24BPP;
+		color = ((r << 16) | (g << 8) | b);
+		break;
+	case 32:
+		fb_bpp = R128_GMC_DST_32BPP;
+		color = (((0xff) << 24) | (r << 16) | (g <<  8) | b);
+		break;
+	default:
+		return;
+	}
+
+	offset = dev_priv->back_offset;
+	pitch = dev_priv->back_pitch >> 3;
+
+	BEGIN_RING( 6 );
+
+	OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
+	OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+		  | R128_GMC_BRUSH_SOLID_COLOR
+		  | fb_bpp
+		  | R128_GMC_SRC_DATATYPE_COLOR
+		  | R128_ROP3_P
+		  | R128_GMC_CLR_CMP_CNTL_DIS
+		  | R128_GMC_AUX_CLIP_DIS );
+
+	OUT_RING( (pitch << 21) | (offset >> 5) );
+	OUT_RING( color );
+
+	OUT_RING( (x << 16) | y );
+	OUT_RING( (w << 16) | h );
+
+	ADVANCE_RING();
+}
+
+static void r128_cce_performance_boxes( drm_r128_private_t *dev_priv )
+{
+	if ( atomic_read( &dev_priv->idle_count ) == 0 ) {
+		r128_clear_box( dev_priv, 64, 4, 8, 8, 0, 255, 0 );
+	} else {
+		atomic_set( &dev_priv->idle_count, 0 );
+	}
+}
+
+#endif
+
+
+/* ================================================================
+ * CCE command dispatch functions
+ */
+
+static void r128_print_dirty( const char *msg, unsigned int flags )
+{
+	DRM_INFO( "%s: (0x%x) %s%s%s%s%s%s%s%s%s\n",
+		  msg,
+		  flags,
+		  (flags & R128_UPLOAD_CORE)        ? "core, " : "",
+		  (flags & R128_UPLOAD_CONTEXT)     ? "context, " : "",
+		  (flags & R128_UPLOAD_SETUP)       ? "setup, " : "",
+		  (flags & R128_UPLOAD_TEX0)        ? "tex0, " : "",
+		  (flags & R128_UPLOAD_TEX1)        ? "tex1, " : "",
+		  (flags & R128_UPLOAD_MASKS)       ? "masks, " : "",
+		  (flags & R128_UPLOAD_WINDOW)      ? "window, " : "",
+		  (flags & R128_UPLOAD_CLIPRECTS)   ? "cliprects, " : "",
+		  (flags & R128_REQUIRE_QUIESCENCE) ? "quiescence, " : "" );
+}
+
+static void r128_cce_dispatch_clear( drm_device_t *dev,
+				     unsigned int flags,
+				     int cx, int cy, int cw, int ch,
+				     unsigned int clear_color,
+				     unsigned int clear_depth )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	u32 fb_bpp, depth_bpp;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	switch ( dev_priv->fb_bpp ) {
+	case 16:
+		fb_bpp = R128_GMC_DST_16BPP;
+		break;
+	case 32:
+		fb_bpp = R128_GMC_DST_32BPP;
+		break;
+	default:
+		return;
+	}
+	switch ( dev_priv->depth_bpp ) {
+	case 16:
+		depth_bpp = R128_GMC_DST_16BPP;
+		break;
+	case 24:
+	case 32:
+		depth_bpp = R128_GMC_DST_32BPP;
+		break;
+	default:
+		return;
+	}
+
+	for ( i = 0 ; i < nbox ; i++ ) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG( "dispatch clear %d,%d-%d,%d flags 0x%x\n",
+			   pbox[i].x1, pbox[i].y1, pbox[i].x2,
+			   pbox[i].y2, flags );
+
+		if ( flags & (R128_FRONT | R128_BACK) ) {
+			BEGIN_RING( 2 );
+
+			OUT_RING( CCE_PACKET0( R128_DP_WRITE_MASK, 0 ) );
+			OUT_RING( sarea_priv->context_state.plane_3d_mask_c );
+
+			ADVANCE_RING();
+		}
+
+		if ( flags & R128_FRONT ) {
+			BEGIN_RING( 6 );
+
+			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
+			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+				  | R128_GMC_BRUSH_SOLID_COLOR
+				  | fb_bpp
+				  | R128_GMC_SRC_DATATYPE_COLOR
+				  | R128_ROP3_P
+				  | R128_GMC_CLR_CMP_CNTL_DIS
+				  | R128_GMC_AUX_CLIP_DIS );
+
+			OUT_RING( dev_priv->front_pitch_offset_c );
+			OUT_RING( clear_color );
+
+			OUT_RING( (x << 16) | y );
+			OUT_RING( (w << 16) | h );
+
+			ADVANCE_RING();
+		}
+
+		if ( flags & R128_BACK ) {
+			BEGIN_RING( 6 );
+
+			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
+			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+				  | R128_GMC_BRUSH_SOLID_COLOR
+				  | fb_bpp
+				  | R128_GMC_SRC_DATATYPE_COLOR
+				  | R128_ROP3_P
+				  | R128_GMC_CLR_CMP_CNTL_DIS
+				  | R128_GMC_AUX_CLIP_DIS );
+
+			OUT_RING( dev_priv->back_pitch_offset_c );
+			OUT_RING( clear_color );
+
+			OUT_RING( (x << 16) | y );
+			OUT_RING( (w << 16) | h );
+
+			ADVANCE_RING();
+		}
+
+		if ( flags & R128_DEPTH ) {
+			BEGIN_RING( 6 );
+
+			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
+			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+				  | R128_GMC_BRUSH_SOLID_COLOR
+				  | depth_bpp
+				  | R128_GMC_SRC_DATATYPE_COLOR
+				  | R128_ROP3_P
+				  | R128_GMC_CLR_CMP_CNTL_DIS
+				  | R128_GMC_AUX_CLIP_DIS
+				  | R128_GMC_WR_MSK_DIS );
+
+			OUT_RING( dev_priv->depth_pitch_offset_c );
+			OUT_RING( clear_depth );
+
+			OUT_RING( (x << 16) | y );
+			OUT_RING( (w << 16) | h );
+
+			ADVANCE_RING();
+		}
+	}
+}
+
+static void r128_cce_dispatch_swap( drm_device_t *dev )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	u32 fb_bpp;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+#if R128_PERFORMANCE_BOXES
+	/* Do some trivial performance monitoring...
+	 */
+	r128_cce_performance_boxes( dev_priv );
+#endif
+
+	switch ( dev_priv->fb_bpp ) {
+	case 16:
+		fb_bpp = R128_GMC_DST_16BPP;
+		break;
+	case 32:
+	default:
+		fb_bpp = R128_GMC_DST_32BPP;
+		break;
+	}
+
+	for ( i = 0 ; i < nbox ; i++ ) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		BEGIN_RING( 7 );
+
+		OUT_RING( CCE_PACKET3( R128_CNTL_BITBLT_MULTI, 5 ) );
+		OUT_RING( R128_GMC_SRC_PITCH_OFFSET_CNTL
+			  | R128_GMC_DST_PITCH_OFFSET_CNTL
+			  | R128_GMC_BRUSH_NONE
+			  | fb_bpp
+			  | R128_GMC_SRC_DATATYPE_COLOR
+			  | R128_ROP3_S
+			  | R128_DP_SRC_SOURCE_MEMORY
+			  | R128_GMC_CLR_CMP_CNTL_DIS
+			  | R128_GMC_AUX_CLIP_DIS
+			  | R128_GMC_WR_MSK_DIS );
+
+		OUT_RING( dev_priv->back_pitch_offset_c );
+		OUT_RING( dev_priv->front_pitch_offset_c );
+
+		OUT_RING( (x << 16) | y );
+		OUT_RING( (x << 16) | y );
+		OUT_RING( (w << 16) | h );
+
+		ADVANCE_RING();
+	}
+
+	/* Increment the frame counter.  The client-side 3D driver must
+	 * throttle the framerate by waiting for this value before
+	 * performing the swapbuffer ioctl.
+	 */
+	dev_priv->sarea_priv->last_frame++;
+
+	BEGIN_RING( 2 );
+
+	OUT_RING( CCE_PACKET0( R128_LAST_FRAME_REG, 0 ) );
+	OUT_RING( dev_priv->sarea_priv->last_frame );
+
+	ADVANCE_RING();
+}
+
+static void r128_cce_dispatch_vertex( drm_device_t *dev,
+				      drm_buf_t *buf )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int format = sarea_priv->vc_format;
+	int offset = dev_priv->buffers->offset + buf->offset - dev->agp->base;
+	int size = buf->used;
+	int prim = buf_priv->prim;
+	int i = 0;
+	RING_LOCALS;
+	DRM_DEBUG( "%s: buf=%d nbox=%d\n",
+		   __FUNCTION__, buf->idx, sarea_priv->nbox );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	if ( 0 )
+		r128_print_dirty( "dispatch_vertex", sarea_priv->dirty );
+
+	if ( buf->used ) {
+		buf_priv->dispatched = 1;
+
+		if ( sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS ) {
+			r128_emit_state( dev_priv );
+		}
+
+		do {
+			/* Emit the next set of up to three cliprects */
+			if ( i < sarea_priv->nbox ) {
+				r128_emit_clip_rects( dev_priv,
+						      &sarea_priv->boxes[i],
+						      sarea_priv->nbox - i );
+			}
+
+			/* Emit the vertex buffer rendering commands */
+			BEGIN_RING( 5 );
+
+			OUT_RING( CCE_PACKET3( R128_3D_RNDR_GEN_INDX_PRIM, 3 ) );
+			OUT_RING( offset );
+			OUT_RING( size );
+			OUT_RING( format );
+			OUT_RING( prim | R128_CCE_VC_CNTL_PRIM_WALK_LIST |
+				  (size << R128_CCE_VC_CNTL_NUM_SHIFT) );
+
+			ADVANCE_RING();
+
+			i += 3;
+		} while ( i < sarea_priv->nbox );
+	}
+
+	if ( buf_priv->discard ) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the vertex buffer age */
+		BEGIN_RING( 2 );
+
+		OUT_RING( CCE_PACKET0( R128_LAST_DISPATCH_REG, 0 ) );
+		OUT_RING( buf_priv->age );
+
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		buf->used = 0;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+
+#if 0
+	if ( dev_priv->submit_age == R128_MAX_VB_AGE ) {
+		ret = r128_do_cce_idle( dev_priv );
+		if ( ret < 0 ) return ret;
+		dev_priv->submit_age = 0;
+		r128_freelist_reset( dev );
+	}
+#endif
+
+	sarea_priv->dirty &= ~R128_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+}
+
+
+
+
+static void r128_cce_dispatch_indirect( drm_device_t *dev,
+					drm_buf_t *buf,
+					int start, int end )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+	RING_LOCALS;
+	DRM_DEBUG( "indirect: buf=%d s=0x%x e=0x%x\n",
+		   buf->idx, start, end );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	if ( start != end ) {
+		int offset = (dev_priv->buffers->offset - dev->agp->base
+			      + buf->offset + start);
+		int dwords = (end - start + 3) / sizeof(u32);
+
+		/* Indirect buffer data must be an even number of
+		 * dwords, so if we've been given an odd number we must
+		 * pad the data with a Type-2 CCE packet.
+		 */
+		if ( dwords & 1 ) {
+			u32 *data = (u32 *)
+				((char *)dev_priv->buffers->handle
+				 + buf->offset + start);
+			data[dwords++] = R128_CCE_PACKET2;
+		}
+
+		buf_priv->dispatched = 1;
+
+		/* Fire off the indirect buffer */
+		BEGIN_RING( 3 );
+
+		OUT_RING( CCE_PACKET0( R128_PM4_IW_INDOFF, 1 ) );
+		OUT_RING( offset );
+		OUT_RING( dwords );
+
+		ADVANCE_RING();
+	}
+
+	if ( buf_priv->discard ) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the indirect buffer age */
+		BEGIN_RING( 2 );
+
+		OUT_RING( CCE_PACKET0( R128_LAST_DISPATCH_REG, 0 ) );
+		OUT_RING( buf_priv->age );
+
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		buf->used = 0;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+
+#if 0
+	if ( dev_priv->submit_age == R128_MAX_VB_AGE ) {
+		ret = r128_do_cce_idle( dev_priv );
+		if ( ret < 0 ) return ret;
+		dev_priv->submit_age = 0;
+		r128_freelist_reset( dev );
+	}
+#endif
+}
+
+static void r128_cce_dispatch_indices( drm_device_t *dev,
+				       drm_buf_t *buf,
+				       int start, int end,
+				       int count )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_buf_priv_t *buf_priv = buf->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int format = sarea_priv->vc_format;
+	int offset = dev_priv->buffers->offset - dev->agp->base;
+	int prim = buf_priv->prim;
+	u32 *data;
+	int dwords;
+	int i = 0;
+	RING_LOCALS;
+	DRM_DEBUG( "indices: s=%d e=%d c=%d\n", start, end, count );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	if ( 0 )
+		r128_print_dirty( "dispatch_indices", sarea_priv->dirty );
+
+	if ( start != end ) {
+		buf_priv->dispatched = 1;
+
+		if ( sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS ) {
+			r128_emit_state( dev_priv );
+		}
+
+		dwords = (end - start + 3) / sizeof(u32);
+
+		data = (u32 *)((char *)dev_priv->buffers->handle
+			       + buf->offset + start);
+
+		data[0] = CCE_PACKET3( R128_3D_RNDR_GEN_INDX_PRIM, dwords-2 );
+
+		data[1] = offset;
+		data[2] = R128_MAX_VB_VERTS;
+		data[3] = format;
+		data[4] = (prim | R128_CCE_VC_CNTL_PRIM_WALK_IND |
+			   (count << 16));
+
+		if ( count & 0x1 ) {
+			data[dwords-1] &= 0x0000ffff;
+		}
+
+		do {
+			/* Emit the next set of up to three cliprects */
+			if ( i < sarea_priv->nbox ) {
+				r128_emit_clip_rects( dev_priv,
+						      &sarea_priv->boxes[i],
+						      sarea_priv->nbox - i );
+			}
+
+			r128_cce_dispatch_indirect( dev, buf, start, end );
+
+			i += 3;
+		} while ( i < sarea_priv->nbox );
+	}
+
+	if ( buf_priv->discard ) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the vertex buffer age */
+		BEGIN_RING( 2 );
+
+		OUT_RING( CCE_PACKET0( R128_LAST_DISPATCH_REG, 0 ) );
+		OUT_RING( buf_priv->age );
+
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+
+#if 0
+	if ( dev_priv->submit_age == R128_MAX_VB_AGE ) {
+		ret = r128_do_cce_idle( dev_priv );
+		if ( ret < 0 ) return ret;
+		dev_priv->submit_age = 0;
+		r128_freelist_reset( dev );
+	}
+#endif
+
+	sarea_priv->dirty &= ~R128_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+}
+
+static int r128_cce_dispatch_blit( drm_device_t *dev,
+				   drm_r128_blit_t *blit )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	u32 *data;
+	int dword_shift, dwords;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	/* The compiler won't optimize away a division by a variable,
+	 * even if the only legal values are powers of two.  Thus, we'll
+	 * use a shift instead.
+	 */
+	switch ( blit->format ) {
+	case R128_DATATYPE_ARGB1555:
+	case R128_DATATYPE_RGB565:
+	case R128_DATATYPE_ARGB4444:
+		dword_shift = 1;
+		break;
+	case R128_DATATYPE_ARGB8888:
+		dword_shift = 0;
+		break;
+	default:
+		DRM_ERROR( "invalid blit format %d\n", blit->format );
+		return -EINVAL;
+	}
+
+	/* Flush the pixel cache, and mark the contents as Read Invalid.
+	 * This ensures no pixel data gets mixed up with the texture
+	 * data from the host data blit, otherwise part of the texture
+	 * image may be corrupted.
+	 */
+	BEGIN_RING( 2 );
+
+	OUT_RING( CCE_PACKET0( R128_PC_GUI_CTLSTAT, 0 ) );
+	OUT_RING( R128_PC_RI_GUI | R128_PC_FLUSH_GUI );
+
+	ADVANCE_RING();
+
+	/* Dispatch the indirect buffer.
+	 */
+	buf = dma->buflist[blit->idx];
+	buf_priv = buf->dev_private;
+
+	if ( buf->pid != current->pid ) {
+		DRM_ERROR( "process %d using buffer owned by %d\n",
+			   current->pid, buf->pid );
+		return -EINVAL;
+	}
+	if ( buf->pending ) {
+		DRM_ERROR( "sending pending buffer %d\n", blit->idx );
+		return -EINVAL;
+	}
+
+	buf_priv->discard = 1;
+
+	dwords = (blit->width * blit->height) >> dword_shift;
+
+	data = (u32 *)((char *)dev_priv->buffers->handle + buf->offset);
+
+	data[0] = CCE_PACKET3( R128_CNTL_HOSTDATA_BLT, dwords + 6 );
+	data[1] = ( R128_GMC_DST_PITCH_OFFSET_CNTL
+		    | R128_GMC_BRUSH_NONE
+		    | (blit->format << 8)
+		    | R128_GMC_SRC_DATATYPE_COLOR
+		    | R128_ROP3_S
+		    | R128_DP_SRC_SOURCE_HOST_DATA
+		    | R128_GMC_CLR_CMP_CNTL_DIS
+		    | R128_GMC_AUX_CLIP_DIS
+		    | R128_GMC_WR_MSK_DIS );
+
+	data[2] = (blit->pitch << 21) | (blit->offset >> 5);
+	data[3] = 0xffffffff;
+	data[4] = 0xffffffff;
+	data[5] = (blit->y << 16) | blit->x;
+	data[6] = (blit->height << 16) | blit->width;
+	data[7] = dwords;
+
+	buf->used = (dwords + 8) * sizeof(u32);
+
+	r128_cce_dispatch_indirect( dev, buf, 0, buf->used );
+
+	/* Flush the pixel cache after the blit completes.  This ensures
+	 * the texture data is written out to memory before rendering
+	 * continues.
+	 */
+	BEGIN_RING( 2 );
+
+	OUT_RING( CCE_PACKET0( R128_PC_GUI_CTLSTAT, 0 ) );
+	OUT_RING( R128_PC_FLUSH_GUI );
+
+	ADVANCE_RING();
+
+	return 0;
+}
+
+
+/* ================================================================
+ * Tiled depth buffer management
+ *
+ * FIXME: These should all set the destination write mask for when we
+ * have hardware stencil support.
+ */
+
+static int r128_cce_dispatch_write_span( drm_device_t *dev,
+					 drm_r128_depth_t *depth )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, x, y;
+	u32 *buffer;
+	u8 *mask;
+	u32 depth_bpp;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	switch ( dev_priv->depth_bpp ) {
+	case 16:
+		depth_bpp = R128_GMC_DST_16BPP;
+		break;
+	case 24:
+	case 32:
+		depth_bpp = R128_GMC_DST_32BPP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	count = depth->n;
+	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
+		return -EFAULT;
+	}
+	if ( copy_from_user( &y, depth->y, sizeof(y) ) ) {
+		return -EFAULT;
+	}
+
+	buffer = kmalloc( depth->n * sizeof(u32), 0 );
+	if ( buffer == NULL )
+		return -ENOMEM;
+	if ( copy_from_user( buffer, depth->buffer,
+			     depth->n * sizeof(u32) ) ) {
+		kfree( buffer );
+		return -EFAULT;
+	}
+
+	if ( depth->mask ) {
+		mask = kmalloc( depth->n * sizeof(u8), 0 );
+		if ( mask == NULL ) {
+			kfree( buffer );
+			return -ENOMEM;
+		}
+		if ( copy_from_user( mask, depth->mask,
+				     depth->n * sizeof(u8) ) ) {
+			kfree( buffer );
+			kfree( mask );
+			return -EFAULT;
+		}
+
+		for ( i = 0 ; i < count ; i++, x++ ) {
+			if ( mask[i] ) {
+				BEGIN_RING( 6 );
+
+				OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI,
+						       4 ) );
+				OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+					  | R128_GMC_BRUSH_SOLID_COLOR
+					  | depth_bpp
+					  | R128_GMC_SRC_DATATYPE_COLOR
+					  | R128_ROP3_P
+					  | R128_GMC_CLR_CMP_CNTL_DIS
+					  | R128_GMC_WR_MSK_DIS );
+
+				OUT_RING( dev_priv->depth_pitch_offset_c );
+				OUT_RING( buffer[i] );
+
+				OUT_RING( (x << 16) | y );
+				OUT_RING( (1 << 16) | 1 );
+
+				ADVANCE_RING();
+			}
+		}
+
+		kfree( mask );
+	} else {
+		for ( i = 0 ; i < count ; i++, x++ ) {
+			BEGIN_RING( 6 );
+
+			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
+			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+				  | R128_GMC_BRUSH_SOLID_COLOR
+				  | depth_bpp
+				  | R128_GMC_SRC_DATATYPE_COLOR
+				  | R128_ROP3_P
+				  | R128_GMC_CLR_CMP_CNTL_DIS
+				  | R128_GMC_WR_MSK_DIS );
+
+			OUT_RING( dev_priv->depth_pitch_offset_c );
+			OUT_RING( buffer[i] );
+
+			OUT_RING( (x << 16) | y );
+			OUT_RING( (1 << 16) | 1 );
+
+			ADVANCE_RING();
+		}
+	}
+
+	kfree( buffer );
+
+	return 0;
+}
+
+static int r128_cce_dispatch_write_pixels( drm_device_t *dev,
+					   drm_r128_depth_t *depth )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, *x, *y;
+	u32 *buffer;
+	u8 *mask;
+	u32 depth_bpp;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	switch ( dev_priv->depth_bpp ) {
+	case 16:
+		depth_bpp = R128_GMC_DST_16BPP;
+		break;
+	case 24:
+	case 32:
+		depth_bpp = R128_GMC_DST_32BPP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	count = depth->n;
+
+	x = kmalloc( count * sizeof(*x), 0 );
+	if ( x == NULL ) {
+		return -ENOMEM;
+	}
+	y = kmalloc( count * sizeof(*y), 0 );
+	if ( y == NULL ) {
+		kfree( x );
+		return -ENOMEM;
+	}
+	if ( copy_from_user( x, depth->x, count * sizeof(int) ) ) {
+		kfree( x );
+		kfree( y );
+		return -EFAULT;
+	}
+	if ( copy_from_user( y, depth->y, count * sizeof(int) ) ) {
+		kfree( x );
+		kfree( y );
+		return -EFAULT;
+	}
+
+	buffer = kmalloc( depth->n * sizeof(u32), 0 );
+	if ( buffer == NULL ) {
+		kfree( x );
+		kfree( y );
+		return -ENOMEM;
+	}
+	if ( copy_from_user( buffer, depth->buffer,
+			     depth->n * sizeof(u32) ) ) {
+		kfree( x );
+		kfree( y );
+		kfree( buffer );
+		return -EFAULT;
+	}
+
+	if ( depth->mask ) {
+		mask = kmalloc( depth->n * sizeof(u8), 0 );
+		if ( mask == NULL ) {
+			kfree( x );
+			kfree( y );
+			kfree( buffer );
+			return -ENOMEM;
+		}
+		if ( copy_from_user( mask, depth->mask,
+				     depth->n * sizeof(u8) ) ) {
+			kfree( x );
+			kfree( y );
+			kfree( buffer );
+			kfree( mask );
+			return -EFAULT;
+		}
+
+		for ( i = 0 ; i < count ; i++ ) {
+			if ( mask[i] ) {
+				BEGIN_RING( 6 );
+
+				OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI,
+						       4 ) );
+				OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+					  | R128_GMC_BRUSH_SOLID_COLOR
+					  | depth_bpp
+					  | R128_GMC_SRC_DATATYPE_COLOR
+					  | R128_ROP3_P
+					  | R128_GMC_CLR_CMP_CNTL_DIS
+					  | R128_GMC_WR_MSK_DIS );
+
+				OUT_RING( dev_priv->depth_pitch_offset_c );
+				OUT_RING( buffer[i] );
+
+				OUT_RING( (x[i] << 16) | y[i] );
+				OUT_RING( (1 << 16) | 1 );
+
+				ADVANCE_RING();
+			}
+		}
+
+		kfree( mask );
+	} else {
+		for ( i = 0 ; i < count ; i++ ) {
+			BEGIN_RING( 6 );
+
+			OUT_RING( CCE_PACKET3( R128_CNTL_PAINT_MULTI, 4 ) );
+			OUT_RING( R128_GMC_DST_PITCH_OFFSET_CNTL
+				  | R128_GMC_BRUSH_SOLID_COLOR
+				  | depth_bpp
+				  | R128_GMC_SRC_DATATYPE_COLOR
+				  | R128_ROP3_P
+				  | R128_GMC_CLR_CMP_CNTL_DIS
+				  | R128_GMC_WR_MSK_DIS );
+
+			OUT_RING( dev_priv->depth_pitch_offset_c );
+			OUT_RING( buffer[i] );
+
+			OUT_RING( (x[i] << 16) | y[i] );
+			OUT_RING( (1 << 16) | 1 );
+
+			ADVANCE_RING();
+		}
+	}
+
+	kfree( x );
+	kfree( y );
+	kfree( buffer );
+
+	return 0;
+}
+
+static int r128_cce_dispatch_read_span( drm_device_t *dev,
+					drm_r128_depth_t *depth )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, x, y;
+	u32 depth_bpp;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	switch ( dev_priv->depth_bpp ) {
+	case 16:
+		depth_bpp = R128_GMC_DST_16BPP;
+		break;
+	case 24:
+	case 32:
+		depth_bpp = R128_GMC_DST_32BPP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	count = depth->n;
+	if ( copy_from_user( &x, depth->x, sizeof(x) ) ) {
+		return -EFAULT;
+	}
+	if ( copy_from_user( &y, depth->y, sizeof(y) ) ) {
+		return -EFAULT;
+	}
+
+	BEGIN_RING( 7 );
+
+	OUT_RING( CCE_PACKET3( R128_CNTL_BITBLT_MULTI, 5 ) );
+	OUT_RING( R128_GMC_SRC_PITCH_OFFSET_CNTL
+		  | R128_GMC_DST_PITCH_OFFSET_CNTL
+		  | R128_GMC_BRUSH_NONE
+		  | depth_bpp
+		  | R128_GMC_SRC_DATATYPE_COLOR
+		  | R128_ROP3_S
+		  | R128_DP_SRC_SOURCE_MEMORY
+		  | R128_GMC_CLR_CMP_CNTL_DIS
+		  | R128_GMC_WR_MSK_DIS );
+
+	OUT_RING( dev_priv->depth_pitch_offset_c );
+	OUT_RING( dev_priv->span_pitch_offset_c );
+
+	OUT_RING( (x << 16) | y );
+	OUT_RING( (0 << 16) | 0 );
+	OUT_RING( (count << 16) | 1 );
+
+	ADVANCE_RING();
+
+	return 0;
+}
+
+static int r128_cce_dispatch_read_pixels( drm_device_t *dev,
+					  drm_r128_depth_t *depth )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int count, *x, *y;
+	u32 depth_bpp;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	switch ( dev_priv->depth_bpp ) {
+	case 16:
+		depth_bpp = R128_GMC_DST_16BPP;
+		break;
+	case 24:
+	case 32:
+		depth_bpp = R128_GMC_DST_32BPP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	count = depth->n;
+	if ( count > dev_priv->depth_pitch ) {
+		count = dev_priv->depth_pitch;
+	}
+
+	x = kmalloc( count * sizeof(*x), 0 );
+	if ( x == NULL ) {
+		return -ENOMEM;
+	}
+	y = kmalloc( count * sizeof(*y), 0 );
+	if ( y == NULL ) {
+		kfree( x );
+		return -ENOMEM;
+	}
+	if ( copy_from_user( x, depth->x, count * sizeof(int) ) ) {
+		kfree( x );
+		kfree( y );
+		return -EFAULT;
+	}
+	if ( copy_from_user( y, depth->y, count * sizeof(int) ) ) {
+		kfree( x );
+		kfree( y );
+		return -EFAULT;
+	}
+
+	for ( i = 0 ; i < count ; i++ ) {
+		BEGIN_RING( 7 );
+
+		OUT_RING( CCE_PACKET3( R128_CNTL_BITBLT_MULTI, 5 ) );
+		OUT_RING( R128_GMC_SRC_PITCH_OFFSET_CNTL
+			  | R128_GMC_DST_PITCH_OFFSET_CNTL
+			  | R128_GMC_BRUSH_NONE
+			  | depth_bpp
+			  | R128_GMC_SRC_DATATYPE_COLOR
+			  | R128_ROP3_S
+			  | R128_DP_SRC_SOURCE_MEMORY
+			  | R128_GMC_CLR_CMP_CNTL_DIS
+			  | R128_GMC_WR_MSK_DIS );
+
+		OUT_RING( dev_priv->depth_pitch_offset_c );
+		OUT_RING( dev_priv->span_pitch_offset_c );
+
+		OUT_RING( (x[i] << 16) | y[i] );
+		OUT_RING( (i << 16) | 0 );
+		OUT_RING( (1 << 16) | 1 );
+
+		ADVANCE_RING();
+	}
+
+	kfree( x );
+	kfree( y );
+
+	return 0;
+}
+
+
+/* ================================================================
+ * Polygon stipple
+ */
+
+static void r128_cce_dispatch_stipple( drm_device_t *dev, u32 *stipple )
+{
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	r128_update_ring_snapshot( dev_priv );
+
+	BEGIN_RING( 33 );
+
+	OUT_RING(  CCE_PACKET0( R128_BRUSH_DATA0, 31 ) );
+	for ( i = 0 ; i < 32 ; i++ ) {
+		OUT_RING( stipple[i] );
+	}
+
+	ADVANCE_RING();
+}
+
+
+/* ================================================================
+ * IOCTL functions
+ */
+
+int r128_cce_clear( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_clear_t clear;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "r128_cce_clear called without lock held\n" );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &clear, (drm_r128_clear_t *) arg,
+			     sizeof(clear) ) )
+		return -EFAULT;
+
+	if ( sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS )
+		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
+
+	r128_cce_dispatch_clear( dev, clear.flags,
+				 clear.x, clear.y, clear.w, clear.h,
+				 clear.clear_color, clear.clear_depth );
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;
+
+	return 0;
+}
+
+int r128_cce_swap( struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "r128_cce_swap called without lock held\n" );
+		return -EINVAL;
+	}
+
+	if ( sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS )
+		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
+
+	r128_cce_dispatch_swap( dev );
+
+	/* Make sure we restore the 3D state next time.
+	 */
+	dev_priv->sarea_priv->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;
+
+	return 0;
+}
+
+int r128_cce_vertex( struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_r128_vertex_t vertex;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( !dev_priv || dev_priv->is_pci ) {
+		DRM_ERROR( "%s called with a PCI card\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &vertex, (drm_r128_vertex_t *)arg,
+			     sizeof(vertex) ) )
+		return -EFAULT;
+
+	DRM_DEBUG( "%s: pid=%d index=%d count=%d discard=%d\n",
+		   __FUNCTION__, current->pid,
+		   vertex.idx, vertex.count, vertex.discard );
+
+	if ( vertex.idx < 0 || vertex.idx >= dma->buf_count ) {
+		DRM_ERROR( "buffer index %d (of %d max)\n",
+			   vertex.idx, dma->buf_count - 1 );
+		return -EINVAL;
+	}
+	if ( vertex.prim < 0 ||
+	     vertex.prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2 ) {
+		DRM_ERROR( "buffer prim %d\n", vertex.prim );
+		return -EINVAL;
+	}
+
+	buf = dma->buflist[vertex.idx];
+	buf_priv = buf->dev_private;
+
+	if ( buf->pid != current->pid ) {
+		DRM_ERROR( "process %d using buffer owned by %d\n",
+			   current->pid, buf->pid );
+		return -EINVAL;
+	}
+	if ( buf->pending ) {
+		DRM_ERROR( "sending pending buffer %d\n", vertex.idx );
+		return -EINVAL;
+	}
+
+	buf->used = vertex.count;
+	buf_priv->prim = vertex.prim;
+	buf_priv->discard = vertex.discard;
+
+	r128_cce_dispatch_vertex( dev, buf );
+
+	return 0;
+}
+
+int r128_cce_indices( struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_r128_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_r128_buf_priv_t *buf_priv;
+	drm_r128_indices_t elts;
+	int count;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( !dev_priv || dev_priv->is_pci ) {
+		DRM_ERROR( "%s called with a PCI card\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &elts, (drm_r128_indices_t *)arg,
+			     sizeof(elts) ) )
+		return -EFAULT;
+
+	DRM_DEBUG( "%s: pid=%d buf=%d s=%d e=%d d=%d\n",
+		   __FUNCTION__, current->pid,
+		   elts.idx, elts.start, elts.end, elts.discard );
+
+	if ( elts.idx < 0 || elts.idx >= dma->buf_count ) {
+		DRM_ERROR( "buffer index %d (of %d max)\n",
+			   elts.idx, dma->buf_count - 1 );
+		return -EINVAL;
+	}
+	if ( elts.prim < 0 ||
+	     elts.prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2 ) {
+		DRM_ERROR( "buffer prim %d\n", elts.prim );
+		return -EINVAL;
+	}
+
+	buf = dma->buflist[elts.idx];
+	buf_priv = buf->dev_private;
+
+	if ( buf->pid != current->pid ) {
+		DRM_ERROR( "process %d using buffer owned by %d\n",
+			   current->pid, buf->pid );
+		return -EINVAL;
+	}
+	if ( buf->pending ) {
+		DRM_ERROR( "sending pending buffer %d\n", elts.idx );
+		return -EINVAL;
+	}
+
+	count = (elts.end - elts.start) / sizeof(u16);
+	elts.start -= R128_INDEX_PRIM_OFFSET;
+
+	if ( elts.start & 0x7 ) {
+		DRM_ERROR( "misaligned buffer 0x%x\n", elts.start );
+		return -EINVAL;
+	}
+	if ( elts.start < buf->used ) {
+		DRM_ERROR( "no header 0x%x - 0x%x\n", elts.start, buf->used );
+		return -EINVAL;
+	}
+
+	buf->used = elts.end;
+	buf_priv->prim = elts.prim;
+	buf_priv->discard = elts.discard;
+
+	r128_cce_dispatch_indices( dev, buf, elts.start, elts.end, count );
+
+	return 0;
+}
+
+int r128_cce_blit( struct inode *inode, struct file *filp,
+		   unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+	drm_r128_blit_t blit;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &blit, (drm_r128_blit_t *)arg,
+			     sizeof(blit) ) )
+		return -EFAULT;
+
+	DRM_DEBUG( "%s: pid=%d index=%d\n",
+		   __FUNCTION__, current->pid, blit.idx );
+
+	if ( blit.idx < 0 || blit.idx >= dma->buf_count ) {
+		DRM_ERROR( "buffer index %d (of %d max)\n",
+			   blit.idx, dma->buf_count - 1 );
+		return -EINVAL;
+	}
+
+	return r128_cce_dispatch_blit( dev, &blit );
+}
+
+int r128_cce_depth( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_r128_depth_t depth;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &depth, (drm_r128_depth_t *)arg,
+			     sizeof(depth) ) )
+		return -EFAULT;
+
+	switch ( depth.func ) {
+	case R128_WRITE_SPAN:
+		return r128_cce_dispatch_write_span( dev, &depth );
+	case R128_WRITE_PIXELS:
+		return r128_cce_dispatch_write_pixels( dev, &depth );
+	case R128_READ_SPAN:
+		return r128_cce_dispatch_read_span( dev, &depth );
+	case R128_READ_PIXELS:
+		return r128_cce_dispatch_read_pixels( dev, &depth );
+	}
+
+	return -EINVAL;
+}
+
+int r128_cce_stipple( struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_r128_stipple_t stipple;
+	u32 mask[32];
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &stipple, (drm_r128_stipple_t *)arg,
+			     sizeof(stipple) ) )
+		return -EFAULT;
+
+	if ( copy_from_user( &mask, stipple.mask,
+			     32 * sizeof(u32) ) )
+		return -EFAULT;
+
+	r128_cce_dispatch_stipple( dev, mask );
+
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/radeon_bufs.c linux/drivers/char/drm-4.0/radeon_bufs.c
--- linux.orig/drivers/char/drm-4.0/radeon_bufs.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/radeon_bufs.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,312 @@
+/* radeon_bufs.c -- IOCTLs to manage buffers -*- linux-c -*-
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Kevin E. Martin <martin@valinux.com>
+ *          Rickard E. (Rik) Faith <faith@valinux.com>
+ *	    Jeff Hartmann <jhartmann@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include <linux/config.h>
+#include "drmP.h"
+#include "radeon_drv.h"
+#include "linux/un.h"
+
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+int radeon_addbufs_agp(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg)
+{
+	drm_file_t       *priv = filp->private_data;
+	drm_device_t     *dev  = priv->dev;
+	drm_device_dma_t *dma  = dev->dma;
+	drm_buf_desc_t    request;
+	drm_buf_entry_t  *entry;
+	drm_buf_t        *buf;
+	unsigned long     offset;
+	unsigned long     agp_offset;
+	int               count;
+	int               order;
+	int               size;
+	int               alignment;
+	int               page_order;
+	int               total;
+	int               byte_count;
+	int               i;
+
+	if (!dma) return -EINVAL;
+
+	if (copy_from_user(&request, (drm_buf_desc_t *)arg, sizeof(request)))
+		return -EFAULT;
+
+	count      = request.count;
+	order      = drm_order(request.size);
+	size       = 1 << order;
+
+	alignment  = (request.flags & _DRM_PAGE_ALIGN) ? PAGE_ALIGN(size):size;
+	page_order = order - PAGE_SHIFT > 0 ? order - PAGE_SHIFT : 0;
+	total      = PAGE_SIZE << page_order;
+
+	byte_count = 0;
+	agp_offset = dev->agp->base + request.agp_start;
+
+	DRM_DEBUG("count:      %d\n",  count);
+	DRM_DEBUG("order:      %d\n",  order);
+	DRM_DEBUG("size:       %d\n",  size);
+	DRM_DEBUG("agp_offset: %ld\n", agp_offset);
+	DRM_DEBUG("alignment:  %d\n",  alignment);
+	DRM_DEBUG("page_order: %d\n",  page_order);
+	DRM_DEBUG("total:      %d\n",  total);
+
+	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER) return -EINVAL;
+	if (dev->queue_count) return -EBUSY; /* Not while in use */
+
+	spin_lock(&dev->count_lock);
+	if (dev->buf_use) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	atomic_inc(&dev->buf_alloc);
+	spin_unlock(&dev->count_lock);
+
+	down(&dev->struct_sem);
+	entry = &dma->bufs[order];
+	if (entry->buf_count) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM; /* May only call once for each order */
+	}
+
+	/* Might be too low a limit. XFree folks need to fix this properly */
+	
+	if(count < 0 || count > 4096)
+	{
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -EINVAL;
+	}
+		
+	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+				   DRM_MEM_BUFS);
+	if (!entry->buflist) {
+		up(&dev->struct_sem);
+		atomic_dec(&dev->buf_alloc);
+		return -ENOMEM;
+	}
+	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
+
+	entry->buf_size   = size;
+	entry->page_order = page_order;
+	offset            = 0;
+
+	for (offset = 0;
+	     entry->buf_count < count;
+	     offset += alignment, ++entry->buf_count) {
+		buf          = &entry->buflist[entry->buf_count];
+		buf->idx     = dma->buf_count + entry->buf_count;
+		buf->total   = alignment;
+		buf->order   = order;
+		buf->used    = 0;
+		buf->offset  = (dma->byte_count + offset);
+		buf->address = (void *)(agp_offset + offset);
+		buf->next    = NULL;
+		buf->waiting = 0;
+		buf->pending = 0;
+		init_waitqueue_head(&buf->dma_wait);
+		buf->pid     = 0;
+
+		buf->dev_priv_size = sizeof(drm_radeon_buf_priv_t);
+		buf->dev_private   = drm_alloc(sizeof(drm_radeon_buf_priv_t),
+					       DRM_MEM_BUFS);
+                if (!buf->dev_private) {
+                        up(&dev->struct_sem);
+                        atomic_dec(&dev->buf_alloc);
+                        return -ENOMEM;
+                }
+		memset(buf->dev_private, 0, buf->dev_priv_size);
+
+#if DRM_DMA_HISTOGRAM
+		buf->time_queued     = 0;
+		buf->time_dispatched = 0;
+		buf->time_completed  = 0;
+		buf->time_freed      = 0;
+#endif
+
+		byte_count += PAGE_SIZE << page_order;
+
+		DRM_DEBUG("buffer %d @ %p\n",
+			  entry->buf_count, buf->address);
+	}
+
+	DRM_DEBUG("byte_count: %d\n", byte_count);
+
+	dma->buflist = drm_realloc(dma->buflist,
+				   dma->buf_count * sizeof(*dma->buflist),
+				   (dma->buf_count + entry->buf_count)
+				   * sizeof(*dma->buflist),
+				   DRM_MEM_BUFS);
+	for (i = dma->buf_count; i < dma->buf_count + entry->buf_count; i++)
+		dma->buflist[i] = &entry->buflist[i - dma->buf_count];
+
+	dma->buf_count  += entry->buf_count;
+	dma->byte_count += byte_count;
+
+	drm_freelist_create(&entry->freelist, entry->buf_count);
+	for (i = 0; i < entry->buf_count; i++) {
+		drm_freelist_put(dev, &entry->freelist, &entry->buflist[i]);
+	}
+
+	up(&dev->struct_sem);
+
+	request.count = entry->buf_count;
+	request.size  = size;
+
+	if (copy_to_user((drm_buf_desc_t *)arg, &request, sizeof(request)))
+		return -EFAULT;
+
+	dma->flags = _DRM_DMA_USE_AGP;
+
+	atomic_dec(&dev->buf_alloc);
+	return 0;
+}
+#endif
+
+int radeon_addbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t		*priv		= filp->private_data;
+	drm_device_t		*dev		= priv->dev;
+	drm_radeon_private_t	*dev_priv	= dev->dev_private;
+	drm_buf_desc_t		request;
+
+	if (!dev_priv || dev_priv->is_pci) return -EINVAL;
+
+	if (copy_from_user(&request, (drm_buf_desc_t *)arg, sizeof(request)))
+		return -EFAULT;
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	if (request.flags & _DRM_AGP_BUFFER)
+		return radeon_addbufs_agp(inode, filp, cmd, arg);
+	else
+#endif
+		return -EINVAL;
+}
+
+int radeon_mapbufs(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t		*priv		= filp->private_data;
+	drm_device_t		*dev		= priv->dev;
+	drm_radeon_private_t	*dev_priv	= dev->dev_private;
+	drm_device_dma_t	*dma		= dev->dma;
+	int			 retcode	= 0;
+	const int		 zero		= 0;
+	unsigned long		 virtual;
+	unsigned long		 address;
+	drm_buf_map_t		 request;
+	int			 i;
+
+	if (!dma || !dev_priv || dev_priv->is_pci) return -EINVAL;
+
+	DRM_DEBUG("\n");
+
+	spin_lock(&dev->count_lock);
+	if (atomic_read(&dev->buf_alloc)) {
+		spin_unlock(&dev->count_lock);
+		return -EBUSY;
+	}
+	++dev->buf_use;		/* Can't allocate more after this call */
+	spin_unlock(&dev->count_lock);
+
+	if (copy_from_user(&request, (drm_buf_map_t *)arg, sizeof(request)))
+		return -EFAULT;
+
+	if (request.count >= dma->buf_count) {
+		if (dma->flags & _DRM_DMA_USE_AGP) {
+			drm_map_t *map;
+
+			map = dev_priv->buffers;
+			if (!map) {
+				retcode = -EINVAL;
+				goto done;
+			}
+
+			down_write(&current->mm->mmap_sem);
+			virtual = do_mmap(filp, 0, map->size,
+					  PROT_READ|PROT_WRITE,
+					  MAP_SHARED,
+					  (unsigned long)map->offset);
+			up_write(&current->mm->mmap_sem);
+		} else {
+			down_write(&current->mm->mmap_sem);
+			virtual = do_mmap(filp, 0, dma->byte_count,
+					  PROT_READ|PROT_WRITE, MAP_SHARED, 0);
+			up_write(&current->mm->mmap_sem);
+		}
+		if (virtual > -1024UL) {
+			/* Real error */
+			retcode = (signed long)virtual;
+			goto done;
+		}
+		request.virtual = (void *)virtual;
+
+		for (i = 0; i < dma->buf_count; i++) {
+			if (copy_to_user(&request.list[i].idx,
+					 &dma->buflist[i]->idx,
+					 sizeof(request.list[0].idx))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].total,
+					 &dma->buflist[i]->total,
+					 sizeof(request.list[0].total))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			if (copy_to_user(&request.list[i].used,
+					 &zero,
+					 sizeof(zero))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+			address = virtual + dma->buflist[i]->offset;
+			if (copy_to_user(&request.list[i].address,
+					 &address,
+					 sizeof(address))) {
+				retcode = -EFAULT;
+				goto done;
+			}
+		}
+	}
+ done:
+	request.count = dma->buf_count;
+	DRM_DEBUG("%d buffers, retcode = %d\n", request.count, retcode);
+
+	if (copy_to_user((drm_buf_map_t *)arg, &request, sizeof(request)))
+		return -EFAULT;
+
+	return retcode;
+}
diff -urN linux.orig/drivers/char/drm-4.0/radeon_context.c linux/drivers/char/drm-4.0/radeon_context.c
--- linux.orig/drivers/char/drm-4.0/radeon_context.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/radeon_context.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,215 @@
+/* radeon_context.c -- IOCTLs for Radeon contexts -*- linux-c -*-
+ *
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Kevin E. Martin <martin@valinux.com>
+ *         Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "radeon_drv.h"
+
+extern drm_ctx_t radeon_res_ctx;
+
+static int radeon_alloc_queue(drm_device_t *dev)
+{
+	return drm_ctxbitmap_next(dev);
+}
+
+int radeon_context_switch(drm_device_t *dev, int old, int new)
+{
+        char        buf[64];
+
+        atomic_inc(&dev->total_ctx);
+
+        if (test_and_set_bit(0, &dev->context_flag)) {
+                DRM_ERROR("Reentering -- FIXME\n");
+                return -EBUSY;
+        }
+
+#if DRM_DMA_HISTOGRAM
+        dev->ctx_start = get_cycles();
+#endif
+
+        DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+        if (new == dev->last_context) {
+                clear_bit(0, &dev->context_flag);
+                return 0;
+        }
+
+        if (drm_flags & DRM_FLAG_NOCTX) {
+                radeon_context_switch_complete(dev, new);
+        } else {
+                sprintf(buf, "C %d %d\n", old, new);
+                drm_write_string(dev, buf);
+        }
+
+        return 0;
+}
+
+int radeon_context_switch_complete(drm_device_t *dev, int new)
+{
+        dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
+        dev->last_switch  = jiffies;
+
+        if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+                DRM_ERROR("Lock isn't held after context switch\n");
+        }
+
+				/* If a context switch is ever initiated
+                                   when the kernel holds the lock, release
+                                   that lock here. */
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.ctx[drm_histogram_slot(get_cycles()
+                                                      - dev->ctx_start)]);
+
+#endif
+        clear_bit(0, &dev->context_flag);
+        wake_up(&dev->context_wait);
+
+        return 0;
+}
+
+
+int radeon_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_ctx_res_t	res;
+	drm_ctx_t	ctx;
+	int		i;
+
+	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
+	if (copy_from_user(&res, (drm_ctx_res_t *)arg, sizeof(res)))
+		return -EFAULT;
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+			ctx.handle = i;
+			if (copy_to_user(&res.contexts[i], &i, sizeof(i)))
+				return -EFAULT;
+		}
+	}
+	res.count = DRM_RESERVED_CONTEXTS;
+	if (copy_to_user((drm_ctx_res_t *)arg, &res, sizeof(res)))
+		return -EFAULT;
+	return 0;
+}
+
+
+int radeon_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	if ((ctx.handle = radeon_alloc_queue(dev)) == DRM_KERNEL_CONTEXT) {
+				/* Skip kernel's context and get a new one. */
+		ctx.handle = radeon_alloc_queue(dev);
+	}
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (ctx.handle == -1) {
+		DRM_DEBUG("Not enough free contexts.\n");
+				/* Should this return -EBUSY instead? */
+		return -ENOMEM;
+	}
+
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int radeon_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	if (ctx.flags==_DRM_CONTEXT_PRESERVED)
+		radeon_res_ctx.handle=ctx.handle;
+	return 0;
+}
+
+int radeon_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	/* This is 0, because we don't hanlde any context flags */
+	ctx.flags = 0;
+	if (copy_to_user((drm_ctx_t*)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int radeon_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		     unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	return radeon_context_switch(dev, dev->last_context, ctx.handle);
+}
+
+int radeon_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	radeon_context_switch_complete(dev, ctx.handle);
+
+	return 0;
+}
+
+int radeon_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	drm_ctxbitmap_free(dev, ctx.handle);
+
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/radeon_cp.c linux/drivers/char/drm-4.0/radeon_cp.c
--- linux.orig/drivers/char/drm-4.0/radeon_cp.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/radeon_cp.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1353 @@
+/* radeon_cp.c -- CP support for Radeon -*- linux-c -*-
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *   Kevin E. Martin <martin@valinux.com>
+ *   Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "radeon_drv.h"
+
+#include <linux/interrupt.h>	/* For task queue support */
+#include <linux/delay.h>
+
+#define RADEON_FIFO_DEBUG	0
+
+
+/* CP microcode (from ATI) */
+static u32 radeon_cp_microcode[][2] = {
+	{ 0x21007000, 0000000000 },
+	{ 0x20007000, 0000000000 },
+	{ 0x000000b4, 0x00000004 },
+	{ 0x000000b8, 0x00000004 },
+	{ 0x6f5b4d4c, 0000000000 },
+	{ 0x4c4c427f, 0000000000 },
+	{ 0x5b568a92, 0000000000 },
+	{ 0x4ca09c6d, 0000000000 },
+	{ 0xad4c4c4c, 0000000000 },
+	{ 0x4ce1af3d, 0000000000 },
+	{ 0xd8afafaf, 0000000000 },
+	{ 0xd64c4cdc, 0000000000 },
+	{ 0x4cd10d10, 0000000000 },
+	{ 0x000f0000, 0x00000016 },
+	{ 0x362f242d, 0000000000 },
+	{ 0x00000012, 0x00000004 },
+	{ 0x000f0000, 0x00000016 },
+	{ 0x362f282d, 0000000000 },
+	{ 0x000380e7, 0x00000002 },
+	{ 0x04002c97, 0x00000002 },
+	{ 0x000f0001, 0x00000016 },
+	{ 0x333a3730, 0000000000 },
+	{ 0x000077ef, 0x00000002 },
+	{ 0x00061000, 0x00000002 },
+	{ 0x00000021, 0x0000001a },
+	{ 0x00004000, 0x0000001e },
+	{ 0x00061000, 0x00000002 },
+	{ 0x00000021, 0x0000001a },
+	{ 0x00004000, 0x0000001e },
+	{ 0x00061000, 0x00000002 },
+	{ 0x00000021, 0x0000001a },
+	{ 0x00004000, 0x0000001e },
+	{ 0x00000017, 0x00000004 },
+	{ 0x0003802b, 0x00000002 },
+	{ 0x040067e0, 0x00000002 },
+	{ 0x00000017, 0x00000004 },
+	{ 0x000077e0, 0x00000002 },
+	{ 0x00065000, 0x00000002 },
+	{ 0x000037e1, 0x00000002 },
+	{ 0x040067e1, 0x00000006 },
+	{ 0x000077e0, 0x00000002 },
+	{ 0x000077e1, 0x00000002 },
+	{ 0x000077e1, 0x00000006 },
+	{ 0xffffffff, 0000000000 },
+	{ 0x10000000, 0000000000 },
+	{ 0x0003802b, 0x00000002 },
+	{ 0x040067e0, 0x00000006 },
+	{ 0x00007675, 0x00000002 },
+	{ 0x00007676, 0x00000002 },
+	{ 0x00007677, 0x00000002 },
+	{ 0x00007678, 0x00000006 },
+	{ 0x0003802c, 0x00000002 },
+	{ 0x04002676, 0x00000002 },
+	{ 0x00007677, 0x00000002 },
+	{ 0x00007678, 0x00000006 },
+	{ 0x0000002f, 0x00000018 },
+	{ 0x0000002f, 0x00000018 },
+	{ 0000000000, 0x00000006 },
+	{ 0x00000030, 0x00000018 },
+	{ 0x00000030, 0x00000018 },
+	{ 0000000000, 0x00000006 },
+	{ 0x01605000, 0x00000002 },
+	{ 0x00065000, 0x00000002 },
+	{ 0x00098000, 0x00000002 },
+	{ 0x00061000, 0x00000002 },
+	{ 0x64c0603e, 0x00000004 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x00080000, 0x00000016 },
+	{ 0000000000, 0000000000 },
+	{ 0x0400251d, 0x00000002 },
+	{ 0x00007580, 0x00000002 },
+	{ 0x00067581, 0x00000002 },
+	{ 0x04002580, 0x00000002 },
+	{ 0x00067581, 0x00000002 },
+	{ 0x00000049, 0x00000004 },
+	{ 0x00005000, 0000000000 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x00061000, 0x00000002 },
+	{ 0x0000750e, 0x00000002 },
+	{ 0x00019000, 0x00000002 },
+	{ 0x00011055, 0x00000014 },
+	{ 0x00000055, 0x00000012 },
+	{ 0x0400250f, 0x00000002 },
+	{ 0x0000504f, 0x00000004 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x00007565, 0x00000002 },
+	{ 0x00007566, 0x00000002 },
+	{ 0x00000058, 0x00000004 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x01e655b4, 0x00000002 },
+	{ 0x4401b0e4, 0x00000002 },
+	{ 0x01c110e4, 0x00000002 },
+	{ 0x26667066, 0x00000018 },
+	{ 0x040c2565, 0x00000002 },
+	{ 0x00000066, 0x00000018 },
+	{ 0x04002564, 0x00000002 },
+	{ 0x00007566, 0x00000002 },
+	{ 0x0000005d, 0x00000004 },
+	{ 0x00401069, 0x00000008 },
+	{ 0x00101000, 0x00000002 },
+	{ 0x000d80ff, 0x00000002 },
+	{ 0x0080006c, 0x00000008 },
+	{ 0x000f9000, 0x00000002 },
+	{ 0x000e00ff, 0x00000002 },
+	{ 0000000000, 0x00000006 },
+	{ 0x0000008f, 0x00000018 },
+	{ 0x0000005b, 0x00000004 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x00007576, 0x00000002 },
+	{ 0x00065000, 0x00000002 },
+	{ 0x00009000, 0x00000002 },
+	{ 0x00041000, 0x00000002 },
+	{ 0x0c00350e, 0x00000002 },
+	{ 0x00049000, 0x00000002 },
+	{ 0x00051000, 0x00000002 },
+	{ 0x01e785f8, 0x00000002 },
+	{ 0x00200000, 0x00000002 },
+	{ 0x0060007e, 0x0000000c },
+	{ 0x00007563, 0x00000002 },
+	{ 0x006075f0, 0x00000021 },
+	{ 0x20007073, 0x00000004 },
+	{ 0x00005073, 0x00000004 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x00007576, 0x00000002 },
+	{ 0x00007577, 0x00000002 },
+	{ 0x0000750e, 0x00000002 },
+	{ 0x0000750f, 0x00000002 },
+	{ 0x00a05000, 0x00000002 },
+	{ 0x00600083, 0x0000000c },
+	{ 0x006075f0, 0x00000021 },
+	{ 0x000075f8, 0x00000002 },
+	{ 0x00000083, 0x00000004 },
+	{ 0x000a750e, 0x00000002 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x0020750f, 0x00000002 },
+	{ 0x00600086, 0x00000004 },
+	{ 0x00007570, 0x00000002 },
+	{ 0x00007571, 0x00000002 },
+	{ 0x00007572, 0x00000006 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x00005000, 0x00000002 },
+	{ 0x00a05000, 0x00000002 },
+	{ 0x00007568, 0x00000002 },
+	{ 0x00061000, 0x00000002 },
+	{ 0x00000095, 0x0000000c },
+	{ 0x00058000, 0x00000002 },
+	{ 0x0c607562, 0x00000002 },
+	{ 0x00000097, 0x00000004 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x00600096, 0x00000004 },
+	{ 0x400070e5, 0000000000 },
+	{ 0x000380e6, 0x00000002 },
+	{ 0x040025c5, 0x00000002 },
+	{ 0x000380e5, 0x00000002 },
+	{ 0x000000a8, 0x0000001c },
+	{ 0x000650aa, 0x00000018 },
+	{ 0x040025bb, 0x00000002 },
+	{ 0x000610ab, 0x00000018 },
+	{ 0x040075bc, 0000000000 },
+	{ 0x000075bb, 0x00000002 },
+	{ 0x000075bc, 0000000000 },
+	{ 0x00090000, 0x00000006 },
+	{ 0x00090000, 0x00000002 },
+	{ 0x000d8002, 0x00000006 },
+	{ 0x00007832, 0x00000002 },
+	{ 0x00005000, 0x00000002 },
+	{ 0x000380e7, 0x00000002 },
+	{ 0x04002c97, 0x00000002 },
+	{ 0x00007820, 0x00000002 },
+	{ 0x00007821, 0x00000002 },
+	{ 0x00007800, 0000000000 },
+	{ 0x01200000, 0x00000002 },
+	{ 0x20077000, 0x00000002 },
+	{ 0x01200000, 0x00000002 },
+	{ 0x20007000, 0x00000002 },
+	{ 0x00061000, 0x00000002 },
+	{ 0x0120751b, 0x00000002 },
+	{ 0x8040750a, 0x00000002 },
+	{ 0x8040750b, 0x00000002 },
+	{ 0x00110000, 0x00000002 },
+	{ 0x000380e5, 0x00000002 },
+	{ 0x000000c6, 0x0000001c },
+	{ 0x000610ab, 0x00000018 },
+	{ 0x844075bd, 0x00000002 },
+	{ 0x000610aa, 0x00000018 },
+	{ 0x840075bb, 0x00000002 },
+	{ 0x000610ab, 0x00000018 },
+	{ 0x844075bc, 0x00000002 },
+	{ 0x000000c9, 0x00000004 },
+	{ 0x804075bd, 0x00000002 },
+	{ 0x800075bb, 0x00000002 },
+	{ 0x804075bc, 0x00000002 },
+	{ 0x00108000, 0x00000002 },
+	{ 0x01400000, 0x00000002 },
+	{ 0x006000cd, 0x0000000c },
+	{ 0x20c07000, 0x00000020 },
+	{ 0x000000cf, 0x00000012 },
+	{ 0x00800000, 0x00000006 },
+	{ 0x0080751d, 0x00000006 },
+	{ 0000000000, 0000000000 },
+	{ 0x0000775c, 0x00000002 },
+	{ 0x00a05000, 0x00000002 },
+	{ 0x00661000, 0x00000002 },
+	{ 0x0460275d, 0x00000020 },
+	{ 0x00004000, 0000000000 },
+	{ 0x01e00830, 0x00000002 },
+	{ 0x21007000, 0000000000 },
+	{ 0x6464614d, 0000000000 },
+	{ 0x69687420, 0000000000 },
+	{ 0x00000073, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0x00005000, 0x00000002 },
+	{ 0x000380d0, 0x00000002 },
+	{ 0x040025e0, 0x00000002 },
+	{ 0x000075e1, 0000000000 },
+	{ 0x00000001, 0000000000 },
+	{ 0x000380e0, 0x00000002 },
+	{ 0x04002394, 0x00000002 },
+	{ 0x00005000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0x00000008, 0000000000 },
+	{ 0x00000004, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+	{ 0000000000, 0000000000 },
+};
+
+
+#define DO_IOREMAP(_m, _d) (_m)->handle = drm_ioremap((_m)->offset,	\
+						 	(_m)->size, (_d))
+
+#define DO_IOREMAPFREE(_m, _d)						\
+	do {								\
+		if ((_m)->handle && (_m)->size)				\
+			drm_ioremapfree((_m)->handle, (_m)->size, (_d));\
+	} while (0)
+
+#define DO_FIND_MAP(_m, _o)						\
+	do {								\
+		int _i;							\
+		for (_i = 0; _i < dev->map_count; _i++) {		\
+			if (dev->maplist[_i]->offset == _o) {		\
+				_m = dev->maplist[_i];			\
+				break;					\
+			}						\
+		}							\
+	} while (0)
+
+
+int RADEON_READ_PLL(drm_device_t *dev, int addr)
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+
+	RADEON_WRITE8(RADEON_CLOCK_CNTL_INDEX, addr & 0x1f);
+	return RADEON_READ(RADEON_CLOCK_CNTL_DATA);
+}
+
+#if RADEON_FIFO_DEBUG
+static void radeon_status( drm_radeon_private_t *dev_priv )
+{
+	printk( "%s:\n", __FUNCTION__ );
+	printk( "RBBM_STATUS = 0x%08x\n",
+		(unsigned int)RADEON_READ( RADEON_RBBM_STATUS ) );
+	printk( "CP_RB_RTPR = 0x%08x\n",
+		(unsigned int)RADEON_READ( RADEON_CP_RB_RPTR ) );
+	printk( "CP_RB_WTPR = 0x%08x\n",
+		(unsigned int)RADEON_READ( RADEON_CP_RB_WPTR ) );
+}
+#endif
+
+
+/* ================================================================
+ * Engine, FIFO control
+ */
+
+static int radeon_do_pixcache_flush( drm_radeon_private_t *dev_priv )
+{
+	u32 tmp;
+	int i;
+
+	tmp  = RADEON_READ( RADEON_RB2D_DSTCACHE_CTLSTAT );
+	tmp |= RADEON_RB2D_DC_FLUSH_ALL;
+	RADEON_WRITE( RADEON_RB2D_DSTCACHE_CTLSTAT, tmp );
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		if ( !(RADEON_READ( RADEON_RB2D_DSTCACHE_CTLSTAT )
+		       & RADEON_RB2D_DC_BUSY) ) {
+			return 0;
+		}
+		udelay( 1 );
+	}
+
+#if RADEON_FIFO_DEBUG
+	DRM_ERROR( "failed!\n" );
+	radeon_status( dev_priv );
+#endif
+	return -EBUSY;
+}
+
+static int radeon_do_wait_for_fifo( drm_radeon_private_t *dev_priv,
+				    int entries )
+{
+	int i;
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		int slots = ( RADEON_READ( RADEON_RBBM_STATUS )
+			      & RADEON_RBBM_FIFOCNT_MASK );
+		if ( slots >= entries ) return 0;
+		udelay( 1 );
+	}
+
+#if RADEON_FIFO_DEBUG
+	DRM_ERROR( "failed!\n" );
+	radeon_status( dev_priv );
+#endif
+	return -EBUSY;
+}
+
+static int radeon_do_wait_for_idle( drm_radeon_private_t *dev_priv )
+{
+	int i, ret;
+
+	ret = radeon_do_wait_for_fifo( dev_priv, 64 );
+	if ( ret < 0 ) return ret;
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		if ( !(RADEON_READ( RADEON_RBBM_STATUS )
+		       & RADEON_RBBM_ACTIVE) ) {
+			radeon_do_pixcache_flush( dev_priv );
+			return 0;
+		}
+		udelay( 1 );
+	}
+
+#if RADEON_FIFO_DEBUG
+	DRM_ERROR( "failed!\n" );
+	radeon_status( dev_priv );
+#endif
+	return -EBUSY;
+}
+
+
+/* ================================================================
+ * CP control, initialization
+ */
+
+/* Load the microcode for the CP */
+static void radeon_cp_load_microcode( drm_radeon_private_t *dev_priv )
+{
+	int i;
+
+	radeon_do_wait_for_idle( dev_priv );
+
+	RADEON_WRITE( RADEON_CP_ME_RAM_ADDR, 0 );
+	for ( i = 0 ; i < 256 ; i++ ) {
+		RADEON_WRITE( RADEON_CP_ME_RAM_DATAH,
+			      radeon_cp_microcode[i][1] );
+		RADEON_WRITE( RADEON_CP_ME_RAM_DATAL,
+			      radeon_cp_microcode[i][0] );
+	}
+}
+
+/* Flush any pending commands to the CP.  This should only be used just
+ * prior to a wait for idle, as it informs the engine that the command
+ * stream is ending.
+ */
+static void radeon_do_cp_flush( drm_radeon_private_t *dev_priv )
+{
+#if 0
+	u32 tmp;
+
+	tmp = RADEON_READ( RADEON_CP_RB_WPTR ) | (1 << 31);
+	RADEON_WRITE( RADEON_CP_RB_WPTR, tmp );
+#endif
+}
+
+/* Wait for the CP to go idle.
+ */
+int radeon_do_cp_idle( drm_radeon_private_t *dev_priv )
+{
+	RING_LOCALS;
+
+	BEGIN_RING( 6 );
+
+	RADEON_PURGE_CACHE();
+	RADEON_PURGE_ZCACHE();
+	RADEON_WAIT_UNTIL_IDLE();
+
+	ADVANCE_RING();
+
+	return radeon_do_wait_for_idle( dev_priv );
+}
+
+/* Start the Command Processor.
+ */
+static void radeon_do_cp_start( drm_radeon_private_t *dev_priv )
+{
+	RING_LOCALS;
+
+	radeon_do_wait_for_idle( dev_priv );
+
+	RADEON_WRITE( RADEON_CP_CSQ_CNTL, dev_priv->cp_mode );
+
+	dev_priv->cp_running = 1;
+
+	BEGIN_RING( 6 );
+
+	RADEON_PURGE_CACHE();
+	RADEON_PURGE_ZCACHE();
+	RADEON_WAIT_UNTIL_IDLE();
+
+	ADVANCE_RING();
+}
+
+/* Reset the Command Processor.  This will not flush any pending
+ * commands, so you must wait for the CP command stream to complete
+ * before calling this routine.
+ */
+static void radeon_do_cp_reset( drm_radeon_private_t *dev_priv )
+{
+	u32 cur_read_ptr;
+
+	cur_read_ptr = RADEON_READ( RADEON_CP_RB_RPTR );
+	RADEON_WRITE( RADEON_CP_RB_WPTR, cur_read_ptr );
+	*dev_priv->ring.head = cur_read_ptr;
+	dev_priv->ring.tail = cur_read_ptr;
+}
+
+/* Stop the Command Processor.  This will not flush any pending
+ * commands, so you must flush the command stream and wait for the CP
+ * to go idle before calling this routine.
+ */
+static void radeon_do_cp_stop( drm_radeon_private_t *dev_priv )
+{
+	RADEON_WRITE( RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIDIS_INDDIS );
+
+	dev_priv->cp_running = 0;
+}
+
+/* Reset the engine.  This will stop the CP if it is running.
+ */
+static int radeon_do_engine_reset( drm_device_t *dev )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	u32 clock_cntl_index, mclk_cntl, rbbm_soft_reset;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	radeon_do_pixcache_flush( dev_priv );
+
+	clock_cntl_index = RADEON_READ( RADEON_CLOCK_CNTL_INDEX );
+	mclk_cntl = RADEON_READ_PLL( dev, RADEON_MCLK_CNTL );
+
+	/* FIXME: remove magic number here and in radeon ddx driver!!! */
+	RADEON_WRITE_PLL( RADEON_MCLK_CNTL, mclk_cntl | 0x003f00000 );
+
+	rbbm_soft_reset = RADEON_READ( RADEON_RBBM_SOFT_RESET );
+
+	RADEON_WRITE( RADEON_RBBM_SOFT_RESET, ( rbbm_soft_reset |
+						RADEON_SOFT_RESET_CP |
+						RADEON_SOFT_RESET_HI |
+						RADEON_SOFT_RESET_SE |
+						RADEON_SOFT_RESET_RE |
+						RADEON_SOFT_RESET_PP |
+						RADEON_SOFT_RESET_E2 |
+						RADEON_SOFT_RESET_RB |
+						RADEON_SOFT_RESET_HDP ) );
+	RADEON_READ( RADEON_RBBM_SOFT_RESET );
+	RADEON_WRITE( RADEON_RBBM_SOFT_RESET, ( rbbm_soft_reset &
+						~( RADEON_SOFT_RESET_CP |
+						   RADEON_SOFT_RESET_HI |
+						   RADEON_SOFT_RESET_SE |
+						   RADEON_SOFT_RESET_RE |
+						   RADEON_SOFT_RESET_PP |
+						   RADEON_SOFT_RESET_E2 |
+						   RADEON_SOFT_RESET_RB |
+						   RADEON_SOFT_RESET_HDP ) ) );
+	RADEON_READ( RADEON_RBBM_SOFT_RESET );
+
+
+	RADEON_WRITE_PLL( RADEON_MCLK_CNTL, mclk_cntl );
+	RADEON_WRITE( RADEON_CLOCK_CNTL_INDEX, clock_cntl_index );
+	RADEON_WRITE( RADEON_RBBM_SOFT_RESET,  rbbm_soft_reset );
+
+	/* Reset the CP ring */
+	radeon_do_cp_reset( dev_priv );
+
+	/* The CP is no longer running after an engine reset */
+	dev_priv->cp_running = 0;
+
+	/* Reset any pending vertex, indirect buffers */
+	radeon_freelist_reset( dev );
+
+	return 0;
+}
+
+static void radeon_cp_init_ring_buffer( drm_device_t *dev )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	u32 ring_start, cur_read_ptr;
+	u32 tmp;
+
+	/* Initialize the memory controller */
+	RADEON_WRITE( RADEON_MC_FB_LOCATION,
+		      (dev_priv->agp_vm_start - 1) & 0xffff0000 );
+	RADEON_WRITE( RADEON_MC_AGP_LOCATION,
+		      (((dev_priv->agp_vm_start - 1 +
+			 dev_priv->agp_size) & 0xffff0000) |
+		       (dev_priv->agp_vm_start >> 16)) );
+
+	ring_start = (dev_priv->cp_ring->offset
+		      - dev->agp->base
+		      + dev_priv->agp_vm_start);
+
+	RADEON_WRITE( RADEON_CP_RB_BASE, ring_start );
+
+	/* Set the write pointer delay */
+	RADEON_WRITE( RADEON_CP_RB_WPTR_DELAY, 0 );
+
+	/* Initialize the ring buffer's read and write pointers */
+	cur_read_ptr = RADEON_READ( RADEON_CP_RB_RPTR );
+	RADEON_WRITE( RADEON_CP_RB_WPTR, cur_read_ptr );
+
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+	/*
+	 * XXX - This is a 460GX specific hack
+	 *
+	 * We have to hack this right now.  The GXB isn't claiming PCI writes
+	 * from the card into the AGP aperture.  Because of this, we have
+	 * to get space outside of the aperture for RPTR_ADDR.
+	 */
+	if(dev->agp->agp_info.chipset == INTEL_460GX) {
+		dev_priv->ring.head = (void *) 
+					__get_free_page(GFP_KERNEL | GFP_DMA);
+		atomic_inc(&virt_to_page(dev_priv->ring.head)->count);
+		set_bit(PG_locked, &virt_to_page(dev_priv->ring.head)->flags);
+		dev_priv->ring.head = __va(dev_priv->ring.head);
+
+		*dev_priv->ring.head = cur_read_ptr;
+		dev_priv->ring.tail = cur_read_ptr;
+
+		RADEON_WRITE(RADEON_CP_RB_RPTR_ADDR, __pa(dev_priv->ring.head));
+	} else {
+#else
+	*dev_priv->ring.head = cur_read_ptr;
+	dev_priv->ring.tail = cur_read_ptr;
+
+	RADEON_WRITE( RADEON_CP_RB_RPTR_ADDR, dev_priv->ring_rptr->offset );
+#endif
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+	}
+#endif
+	/* Set ring buffer size */
+	RADEON_WRITE( RADEON_CP_RB_CNTL, dev_priv->ring.size_l2qw );
+
+	radeon_do_wait_for_idle( dev_priv );
+
+	/* Turn off PCI GART */
+	tmp = RADEON_READ( RADEON_AIC_CNTL ) & ~RADEON_PCIGART_TRANSLATE_EN;
+	RADEON_WRITE( RADEON_AIC_CNTL, tmp );
+
+	/* Turn on bus mastering */
+	tmp = RADEON_READ( RADEON_BUS_CNTL ) & ~RADEON_BUS_MASTER_DIS;
+	RADEON_WRITE( RADEON_BUS_CNTL, tmp );
+
+	/* Sync everything up */
+	RADEON_WRITE( RADEON_ISYNC_CNTL,
+		      (RADEON_ISYNC_ANY2D_IDLE3D |
+		       RADEON_ISYNC_ANY3D_IDLE2D |
+		       RADEON_ISYNC_WAIT_IDLEGUI |
+		       RADEON_ISYNC_CPSCRATCH_IDLEGUI) );
+}
+
+static int radeon_do_init_cp( drm_device_t *dev, drm_radeon_init_t *init )
+{
+	drm_radeon_private_t *dev_priv;
+        int i;
+
+	dev_priv = drm_alloc( sizeof(drm_radeon_private_t), DRM_MEM_DRIVER );
+	if ( dev_priv == NULL )
+		return -ENOMEM;
+	dev->dev_private = (void *)dev_priv;
+
+	memset( dev_priv, 0, sizeof(drm_radeon_private_t) );
+
+	dev_priv->is_pci = init->is_pci;
+
+	/* We don't support PCI cards until PCI GART is implemented.
+	 * Fail here so we can remove all checks for PCI cards around
+	 * the CP ring code.
+	 */
+	if ( dev_priv->is_pci ) {
+		drm_free( dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+		return -EINVAL;
+	}
+
+	dev_priv->usec_timeout = init->usec_timeout;
+	if ( dev_priv->usec_timeout < 1 ||
+	     dev_priv->usec_timeout > RADEON_MAX_USEC_TIMEOUT ) {
+		drm_free( dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+		return -EINVAL;
+	}
+
+	dev_priv->cp_mode = init->cp_mode;
+
+	/* Simple idle check.
+	 */
+	atomic_set( &dev_priv->idle_count, 0 );
+
+	/* We don't support anything other than bus-mastering ring mode,
+	 * but the ring can be in either AGP or PCI space for the ring
+	 * read pointer.
+	 */
+	if ( ( init->cp_mode != RADEON_CSQ_PRIBM_INDDIS ) &&
+	     ( init->cp_mode != RADEON_CSQ_PRIBM_INDBM ) ) {
+		drm_free( dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+		return -EINVAL;
+	}
+
+	switch ( init->fb_bpp ) {
+	case 16:
+		dev_priv->color_fmt = RADEON_COLOR_FORMAT_RGB565;
+		break;
+	case 32:
+	default:
+		dev_priv->color_fmt = RADEON_COLOR_FORMAT_ARGB8888;
+		break;
+	}
+	dev_priv->front_offset	= init->front_offset;
+	dev_priv->front_pitch	= init->front_pitch;
+	dev_priv->back_offset	= init->back_offset;
+	dev_priv->back_pitch	= init->back_pitch;
+
+	switch ( init->depth_bpp ) {
+	case 16:
+		dev_priv->depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z;
+		break;
+	case 32:
+	default:
+		dev_priv->depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z;
+		break;
+	}
+	dev_priv->depth_offset	= init->depth_offset;
+	dev_priv->depth_pitch	= init->depth_pitch;
+
+	dev_priv->front_pitch_offset = (((dev_priv->front_pitch/64) << 22) |
+					(dev_priv->front_offset >> 10));
+	dev_priv->back_pitch_offset = (((dev_priv->back_pitch/64) << 22) |
+				       (dev_priv->back_offset >> 10));
+	dev_priv->depth_pitch_offset = (((dev_priv->depth_pitch/64) << 22) |
+					(dev_priv->depth_offset >> 10));
+
+	/* Hardware state for depth clears.  Remove this if/when we no
+	 * longer clear the depth buffer with a 3D rectangle.  Hard-code
+	 * all values to prevent unwanted 3D state from slipping through
+	 * and screwing with the clear operation.
+	 */
+	dev_priv->depth_clear.rb3d_cntl = (RADEON_PLANE_MASK_ENABLE |
+					   RADEON_Z_ENABLE |
+					   (dev_priv->color_fmt << 10) |
+					   RADEON_ZBLOCK16);
+
+	dev_priv->depth_clear.rb3d_zstencilcntl = (dev_priv->depth_fmt |
+						   RADEON_Z_TEST_ALWAYS |
+						   RADEON_STENCIL_TEST_ALWAYS |
+						   RADEON_STENCIL_S_FAIL_KEEP |
+						   RADEON_STENCIL_ZPASS_KEEP |
+						   RADEON_STENCIL_ZFAIL_KEEP |
+						   RADEON_Z_WRITE_ENABLE);
+
+	dev_priv->depth_clear.se_cntl = (RADEON_FFACE_CULL_CW |
+					 RADEON_BFACE_SOLID |
+					 RADEON_FFACE_SOLID |
+					 RADEON_FLAT_SHADE_VTX_LAST |
+
+					 RADEON_DIFFUSE_SHADE_FLAT |
+					 RADEON_ALPHA_SHADE_FLAT |
+					 RADEON_SPECULAR_SHADE_FLAT |
+					 RADEON_FOG_SHADE_FLAT |
+
+					 RADEON_VTX_PIX_CENTER_OGL |
+					 RADEON_ROUND_MODE_TRUNC |
+					 RADEON_ROUND_PREC_8TH_PIX);
+
+	/* FIXME: We want multiple shared areas, including one shared
+	 * only by the X Server and kernel module.
+	 */
+	for ( i = 0 ; i < dev->map_count ; i++ ) {
+		if ( dev->maplist[i]->type == _DRM_SHM ) {
+			dev_priv->sarea = dev->maplist[i];
+			break;
+		}
+	}
+
+	DO_FIND_MAP( dev_priv->fb, init->fb_offset );
+	DO_FIND_MAP( dev_priv->mmio, init->mmio_offset );
+	DO_FIND_MAP( dev_priv->cp_ring, init->ring_offset );
+	DO_FIND_MAP( dev_priv->ring_rptr, init->ring_rptr_offset );
+	DO_FIND_MAP( dev_priv->buffers, init->buffers_offset );
+
+	if ( !dev_priv->is_pci ) {
+		DO_FIND_MAP( dev_priv->agp_textures,
+			     init->agp_textures_offset );
+	}
+
+	dev_priv->sarea_priv =
+		(drm_radeon_sarea_t *)((u8 *)dev_priv->sarea->handle +
+				       init->sarea_priv_offset);
+
+	DO_IOREMAP( dev_priv->cp_ring, dev );
+	DO_IOREMAP( dev_priv->ring_rptr, dev );
+	DO_IOREMAP( dev_priv->buffers, dev );
+#if 0
+	if ( !dev_priv->is_pci ) {
+		DO_IOREMAP( dev_priv->agp_textures, dev );
+	}
+#endif
+
+	dev_priv->agp_size = init->agp_size;
+	dev_priv->agp_vm_start = RADEON_READ( RADEON_CONFIG_APER_SIZE );
+	dev_priv->agp_buffers_offset = (dev_priv->buffers->offset
+					- dev->agp->base
+					+ dev_priv->agp_vm_start);
+
+	dev_priv->ring.head = ((__volatile__ u32 *)
+			       dev_priv->ring_rptr->handle);
+
+	dev_priv->ring.start = (u32 *)dev_priv->cp_ring->handle;
+	dev_priv->ring.end = ((u32 *)dev_priv->cp_ring->handle
+			      + init->ring_size / sizeof(u32));
+	dev_priv->ring.size = init->ring_size;
+	dev_priv->ring.size_l2qw = drm_order( init->ring_size / 8 );
+
+	dev_priv->ring.tail_mask =
+		(dev_priv->ring.size / sizeof(u32)) - 1;
+
+#if 0
+	/* Initialize the scratch register pointer.  This will cause
+	 * the scratch register values to be written out to memory
+	 * whenever they are updated.
+	 * FIXME: This doesn't quite work yet, so we're disabling it
+	 * for the release.
+	 */
+	RADEON_WRITE( RADEON_SCRATCH_ADDR, (dev_priv->ring_rptr->offset +
+					    RADEON_SCRATCH_REG_OFFSET) );
+	RADEON_WRITE( RADEON_SCRATCH_UMSK, 0x7 );
+#endif
+
+	dev_priv->scratch = ((__volatile__ u32 *)
+			     dev_priv->ring_rptr->handle +
+			     (RADEON_SCRATCH_REG_OFFSET / sizeof(u32)));
+
+	dev_priv->sarea_priv->last_frame = 0;
+	RADEON_WRITE( RADEON_LAST_FRAME_REG,
+		      dev_priv->sarea_priv->last_frame );
+
+	dev_priv->sarea_priv->last_dispatch = 0;
+	RADEON_WRITE( RADEON_LAST_DISPATCH_REG,
+		      dev_priv->sarea_priv->last_dispatch );
+
+	dev_priv->sarea_priv->last_clear = 0;
+	RADEON_WRITE( RADEON_LAST_CLEAR_REG,
+		      dev_priv->sarea_priv->last_clear );
+
+	radeon_cp_load_microcode( dev_priv );
+	radeon_cp_init_ring_buffer( dev );
+	radeon_do_engine_reset( dev );
+
+#if ROTATE_BUFS
+	dev_priv->last_buf = 0;
+#endif
+
+	return 0;
+}
+
+static int radeon_do_cleanup_cp( drm_device_t *dev )
+{
+	if ( dev->dev_private ) {
+		drm_radeon_private_t *dev_priv = dev->dev_private;
+
+		DO_IOREMAPFREE( dev_priv->cp_ring, dev );
+		DO_IOREMAPFREE( dev_priv->ring_rptr, dev );
+		DO_IOREMAPFREE( dev_priv->buffers, dev );
+#if 0
+		if ( !dev_priv->is_pci ) {
+			DO_IOREMAPFREE( dev_priv->agp_textures, dev );
+		}
+#endif
+
+#if defined(CONFIG_AGP_I460) && defined(__ia64__)
+		/*
+		 * Free the page we grabbed for RPTR_ADDR.
+		 */
+		if(dev->agp->agp_info.chipset == INTEL_460GX) {
+			atomic_dec(&virt_to_page(dev_priv->ring.head)->count);
+			clear_bit(PG_locked, 
+				     &virt_to_page(dev_priv->ring.head)->flags);
+			wake_up(&virt_to_page(dev_priv->ring.head)->wait);
+			free_page((unsigned long) dev_priv->ring.head);
+		}
+#endif
+		
+		drm_free( dev->dev_private, sizeof(drm_radeon_private_t),
+			  DRM_MEM_DRIVER );
+		dev->dev_private = NULL;
+	}
+
+	return 0;
+}
+
+int radeon_cp_init( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_radeon_init_t init;
+
+	if ( copy_from_user( &init, (drm_radeon_init_t *)arg, sizeof(init) ) )
+		return -EFAULT;
+
+	switch ( init.func ) {
+	case RADEON_INIT_CP:
+		return radeon_do_init_cp( dev, &init );
+	case RADEON_CLEANUP_CP:
+		return radeon_do_cleanup_cp( dev );
+	}
+
+	return -EINVAL;
+}
+
+int radeon_cp_start( struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( dev_priv->cp_running ) {
+		DRM_DEBUG( "%s while CP running\n", __FUNCTION__ );
+		return 0;
+	}
+	if ( dev_priv->cp_mode == RADEON_CSQ_PRIDIS_INDDIS ) {
+		DRM_DEBUG( "%s called with bogus CP mode (%d)\n",
+			   __FUNCTION__, dev_priv->cp_mode );
+		return 0;
+	}
+
+	radeon_do_cp_start( dev_priv );
+
+	return 0;
+}
+
+/* Stop the CP.  The engine must have been idled before calling this
+ * routine.
+ */
+int radeon_cp_stop( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_cp_stop_t stop;
+	int ret;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &stop, (drm_radeon_init_t *)arg, sizeof(stop) ) )
+		return -EFAULT;
+
+	/* Flush any pending CP commands.  This ensures any outstanding
+	 * commands are exectuted by the engine before we turn it off.
+	 */
+	if ( stop.flush ) {
+		radeon_do_cp_flush( dev_priv );
+	}
+
+	/* If we fail to make the engine go idle, we return an error
+	 * code so that the DRM ioctl wrapper can try again.
+	 */
+	if ( stop.idle ) {
+		ret = radeon_do_cp_idle( dev_priv );
+		if ( ret < 0 ) return ret;
+	}
+
+	/* Finally, we can turn off the CP.  If the engine isn't idle,
+	 * we will get some dropped triangles as they won't be fully
+	 * rendered before the CP is shut down.
+	 */
+	radeon_do_cp_stop( dev_priv );
+
+	/* Reset the engine */
+	radeon_do_engine_reset( dev );
+
+	return 0;
+}
+
+/* Just reset the CP ring.  Called as part of an X Server engine reset.
+ */
+int radeon_cp_reset( struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( !dev_priv ) {
+		DRM_DEBUG( "%s called before init done\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	radeon_do_cp_reset( dev_priv );
+
+	/* The CP is no longer running after an engine reset */
+	dev_priv->cp_running = 0;
+
+	return 0;
+}
+
+int radeon_cp_idle( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	return radeon_do_cp_idle( dev_priv );
+}
+
+int radeon_engine_reset( struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	return radeon_do_engine_reset( dev );
+}
+
+
+/* ================================================================
+ * Fullscreen mode
+ */
+
+static int radeon_do_init_pageflip( drm_device_t *dev )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	dev_priv->crtc_offset =      RADEON_READ( RADEON_CRTC_OFFSET );
+	dev_priv->crtc_offset_cntl = RADEON_READ( RADEON_CRTC_OFFSET_CNTL );
+
+	RADEON_WRITE( RADEON_CRTC_OFFSET, dev_priv->front_offset );
+	RADEON_WRITE( RADEON_CRTC_OFFSET_CNTL,
+		      dev_priv->crtc_offset_cntl |
+		      RADEON_CRTC_OFFSET_FLIP_CNTL );
+
+	dev_priv->page_flipping = 1;
+	dev_priv->current_page = 0;
+
+	return 0;
+}
+
+int radeon_do_cleanup_pageflip( drm_device_t *dev )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	RADEON_WRITE( RADEON_CRTC_OFFSET,      dev_priv->crtc_offset );
+	RADEON_WRITE( RADEON_CRTC_OFFSET_CNTL, dev_priv->crtc_offset_cntl );
+
+	dev_priv->page_flipping = 0;
+	dev_priv->current_page = 0;
+
+	return 0;
+}
+
+int radeon_fullscreen( struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg )
+{
+        drm_file_t *priv = filp->private_data;
+        drm_device_t *dev = priv->dev;
+	drm_radeon_fullscreen_t fs;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &fs, (drm_radeon_fullscreen_t *)arg,
+			     sizeof(fs) ) )
+		return -EFAULT;
+
+	switch ( fs.func ) {
+	case RADEON_INIT_FULLSCREEN:
+		return radeon_do_init_pageflip( dev );
+	case RADEON_CLEANUP_FULLSCREEN:
+		return radeon_do_cleanup_pageflip( dev );
+	}
+
+	return -EINVAL;
+}
+
+
+/* ================================================================
+ * Freelist management
+ */
+#define RADEON_BUFFER_USED	0xffffffff
+#define RADEON_BUFFER_FREE	0
+
+#if 0
+static int radeon_freelist_init( drm_device_t *dev )
+{
+	drm_device_dma_t *dma = dev->dma;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_buf_t *buf;
+	drm_radeon_buf_priv_t *buf_priv;
+	drm_radeon_freelist_t *entry;
+	int i;
+
+	dev_priv->head = drm_alloc( sizeof(drm_radeon_freelist_t),
+				    DRM_MEM_DRIVER );
+	if ( dev_priv->head == NULL )
+		return -ENOMEM;
+
+	memset( dev_priv->head, 0, sizeof(drm_radeon_freelist_t) );
+	dev_priv->head->age = RADEON_BUFFER_USED;
+
+	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+
+		entry = drm_alloc( sizeof(drm_radeon_freelist_t),
+				   DRM_MEM_DRIVER );
+		if ( !entry ) return -ENOMEM;
+
+		entry->age = RADEON_BUFFER_FREE;
+		entry->buf = buf;
+		entry->prev = dev_priv->head;
+		entry->next = dev_priv->head->next;
+		if ( !entry->next )
+			dev_priv->tail = entry;
+
+		buf_priv->discard = 0;
+		buf_priv->dispatched = 0;
+		buf_priv->list_entry = entry;
+
+		dev_priv->head->next = entry;
+
+		if ( dev_priv->head->next )
+			dev_priv->head->next->prev = entry;
+	}
+
+	return 0;
+
+}
+#endif
+
+drm_buf_t *radeon_freelist_get( drm_device_t *dev )
+{
+	drm_device_dma_t *dma = dev->dma;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv;
+	drm_buf_t *buf;
+	int i, t;
+#if ROTATE_BUFS
+	int start;
+#endif
+
+	/* FIXME: Optimize -- use freelist code */
+
+	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+		buf = dma->buflist[i];
+		buf_priv = buf->dev_private;
+		if ( buf->pid == 0 ) {
+			DRM_DEBUG( "  ret buf=%d last=%d pid=0\n",
+				   buf->idx, dev_priv->last_buf );
+			return buf;
+		}
+		DRM_DEBUG( "    skipping buf=%d pid=%d\n",
+			   buf->idx, buf->pid );
+	}
+
+#if ROTATE_BUFS
+	if ( ++dev_priv->last_buf >= dma->buf_count )
+		dev_priv->last_buf = 0;
+	start = dev_priv->last_buf;
+#endif
+	for ( t = 0 ; t < dev_priv->usec_timeout ; t++ ) {
+#if 0
+		/* FIXME: Disable this for now */
+		u32 done_age = dev_priv->scratch[RADEON_LAST_DISPATCH];
+#else
+		u32 done_age = RADEON_READ( RADEON_LAST_DISPATCH_REG );
+#endif
+#if ROTATE_BUFS
+		for ( i = start ; i < dma->buf_count ; i++ ) {
+#else
+		for ( i = 0 ; i < dma->buf_count ; i++ ) {
+#endif
+			buf = dma->buflist[i];
+			buf_priv = buf->dev_private;
+			if ( buf->pending && buf_priv->age <= done_age ) {
+				/* The buffer has been processed, so it
+				 * can now be used.
+				 */
+				buf->pending = 0;
+				DRM_DEBUG( "  ret buf=%d last=%d age=%d done=%d\n", buf->idx, dev_priv->last_buf, buf_priv->age, done_age );
+				return buf;
+			}
+			DRM_DEBUG( "    skipping buf=%d age=%d done=%d\n",
+				   buf->idx, buf_priv->age,
+				   done_age );
+#if ROTATE_BUFS
+			start = 0;
+#endif
+		}
+		udelay( 1 );
+	}
+
+	DRM_ERROR( "returning NULL!\n" );
+	return NULL;
+}
+
+void radeon_freelist_reset( drm_device_t *dev )
+{
+	drm_device_dma_t *dma = dev->dma;
+#if ROTATE_BUFS
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+#endif
+	int i;
+
+#if ROTATE_BUFS
+	dev_priv->last_buf = 0;
+#endif
+	for ( i = 0 ; i < dma->buf_count ; i++ ) {
+		drm_buf_t *buf = dma->buflist[i];
+		drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
+		buf_priv->age = 0;
+	}
+}
+
+
+/* ================================================================
+ * CP command submission
+ */
+
+int radeon_wait_ring( drm_radeon_private_t *dev_priv, int n )
+{
+	drm_radeon_ring_buffer_t *ring = &dev_priv->ring;
+	int i;
+
+	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
+		ring->space = *ring->head - ring->tail;
+		if ( ring->space <= 0 )
+			ring->space += ring->size;
+
+		if ( ring->space >= n )
+			return 0;
+
+		udelay( 1 );
+	}
+
+	/* FIXME: This return value is ignored in the BEGIN_RING macro! */
+	DRM_ERROR( "failed!\n" );
+	return -EBUSY;
+}
+
+void radeon_update_ring_snapshot( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_ring_buffer_t *ring = &dev_priv->ring;
+
+	ring->space = *ring->head - ring->tail;
+	if ( ring->space == 0 )
+		atomic_inc( &dev_priv->idle_count );
+	if ( ring->space <= 0 )
+		ring->space += ring->size;
+}
+
+static int radeon_cp_get_buffers( drm_device_t *dev, drm_dma_t *d )
+{
+	int i;
+	drm_buf_t *buf;
+
+	for ( i = d->granted_count ; i < d->request_count ; i++ ) {
+		buf = radeon_freelist_get( dev );
+		if ( !buf ) return -EAGAIN;
+
+		buf->pid = current->pid;
+
+		if ( copy_to_user( &d->request_indices[i], &buf->idx,
+				   sizeof(buf->idx) ) )
+			return -EFAULT;
+		if ( copy_to_user( &d->request_sizes[i], &buf->total,
+				   sizeof(buf->total) ) )
+			return -EFAULT;
+
+		d->granted_count++;
+	}
+	return 0;
+}
+
+int radeon_cp_buffers( struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_device_dma_t *dma = dev->dma;
+	int ret = 0;
+	drm_dma_t d;
+
+	if ( copy_from_user( &d, (drm_dma_t *) arg, sizeof(d) ) )
+		return -EFAULT;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	/* Please don't send us buffers.
+	 */
+	if ( d.send_count != 0 ) {
+		DRM_ERROR( "Process %d trying to send %d buffers via drmDMA\n",
+			   current->pid, d.send_count );
+		return -EINVAL;
+	}
+
+	/* We'll send you buffers.
+	 */
+	if ( d.request_count < 0 || d.request_count > dma->buf_count ) {
+		DRM_ERROR( "Process %d trying to get %d buffers (of %d max)\n",
+			   current->pid, d.request_count, dma->buf_count );
+		return -EINVAL;
+	}
+
+	d.granted_count = 0;
+
+	if ( d.request_count ) {
+		ret = radeon_cp_get_buffers( dev, &d );
+	}
+
+	if ( copy_to_user( (drm_dma_t *) arg, &d, sizeof(d) ) )
+		return -EFAULT;
+
+	return ret;
+}
diff -urN linux.orig/drivers/char/drm-4.0/radeon_drm.h linux/drivers/char/drm-4.0/radeon_drm.h
--- linux.orig/drivers/char/drm-4.0/radeon_drm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/radeon_drm.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,325 @@
+/* radeon_drm.h -- Public header for the radeon driver -*- linux-c -*-
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#ifndef __RADEON_DRM_H__
+#define __RADEON_DRM_H__
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the X server file (radeon_sarea.h)
+ */
+#ifndef __RADEON_SAREA_DEFINES__
+#define __RADEON_SAREA_DEFINES__
+
+/* What needs to be changed for the current vertex buffer?
+ */
+#define RADEON_UPLOAD_CONTEXT		0x00000001
+#define RADEON_UPLOAD_VERTFMT		0x00000002
+#define RADEON_UPLOAD_LINE		0x00000004
+#define RADEON_UPLOAD_BUMPMAP		0x00000008
+#define RADEON_UPLOAD_MASKS		0x00000010
+#define RADEON_UPLOAD_VIEWPORT		0x00000020
+#define RADEON_UPLOAD_SETUP		0x00000040
+#define RADEON_UPLOAD_TCL		0x00000080
+#define RADEON_UPLOAD_MISC		0x00000100
+#define RADEON_UPLOAD_TEX0		0x00000200
+#define RADEON_UPLOAD_TEX1		0x00000400
+#define RADEON_UPLOAD_TEX2		0x00000800
+#define RADEON_UPLOAD_TEX0IMAGES	0x00001000
+#define RADEON_UPLOAD_TEX1IMAGES	0x00002000
+#define RADEON_UPLOAD_TEX2IMAGES	0x00004000
+#define RADEON_UPLOAD_CLIPRECTS		0x00008000 /* handled client-side */
+#define RADEON_REQUIRE_QUIESCENCE	0x00010000
+#define RADEON_UPLOAD_ALL		0x0001ffff
+
+#define RADEON_FRONT			0x1
+#define RADEON_BACK			0x2
+#define RADEON_DEPTH			0x4
+
+/* Primitive types
+ */
+#define RADEON_POINTS			0x1
+#define RADEON_LINES			0x2
+#define RADEON_LINE_STRIP		0x3
+#define RADEON_TRIANGLES		0x4
+#define RADEON_TRIANGLE_FAN		0x5
+#define RADEON_TRIANGLE_STRIP		0x6
+
+/* Vertex/indirect buffer size
+ */
+#define RADEON_BUFFER_SIZE		16384
+
+/* Byte offsets for indirect buffer data
+ */
+#define RADEON_INDEX_PRIM_OFFSET	20
+#define RADEON_HOSTDATA_BLIT_OFFSET	32
+
+#define RADEON_SCRATCH_REG_OFFSET	32
+
+/* Keep these small for testing
+ */
+#define RADEON_NR_SAREA_CLIPRECTS	12
+
+/* There are 2 heaps (local/AGP).  Each region within a heap is a
+ * minimum of 64k, and there are at most 64 of them per heap.
+ */
+#define RADEON_LOCAL_TEX_HEAP		0
+#define RADEON_AGP_TEX_HEAP		1
+#define RADEON_NR_TEX_HEAPS		2
+#define RADEON_NR_TEX_REGIONS		64
+#define RADEON_LOG_TEX_GRANULARITY	16
+
+#define RADEON_MAX_TEXTURE_LEVELS	11
+#define RADEON_MAX_TEXTURE_UNITS	3
+
+#endif /* __RADEON_SAREA_DEFINES__ */
+
+typedef struct {
+	unsigned int red;
+	unsigned int green;
+	unsigned int blue;
+	unsigned int alpha;
+} radeon_color_regs_t;
+
+typedef struct {
+	/* Context state */
+	unsigned int pp_misc;				/* 0x1c14 */
+	unsigned int pp_fog_color;
+	unsigned int re_solid_color;
+	unsigned int rb3d_blendcntl;
+	unsigned int rb3d_depthoffset;
+	unsigned int rb3d_depthpitch;
+	unsigned int rb3d_zstencilcntl;
+
+	unsigned int pp_cntl;				/* 0x1c38 */
+	unsigned int rb3d_cntl;
+	unsigned int rb3d_coloroffset;
+	unsigned int re_width_height;
+	unsigned int rb3d_colorpitch;
+	unsigned int se_cntl;
+
+	/* Vertex format state */
+	unsigned int se_coord_fmt;			/* 0x1c50 */
+
+	/* Line state */
+	unsigned int re_line_pattern;			/* 0x1cd0 */
+	unsigned int re_line_state;
+
+	unsigned int se_line_width;			/* 0x1db8 */
+
+	/* Bumpmap state */
+	unsigned int pp_lum_matrix;			/* 0x1d00 */
+
+	unsigned int pp_rot_matrix_0;			/* 0x1d58 */
+	unsigned int pp_rot_matrix_1;
+
+	/* Mask state */
+	unsigned int rb3d_stencilrefmask;		/* 0x1d7c */
+	unsigned int rb3d_ropcntl;
+	unsigned int rb3d_planemask;
+
+	/* Viewport state */
+	unsigned int se_vport_xscale;			/* 0x1d98 */
+	unsigned int se_vport_xoffset;
+	unsigned int se_vport_yscale;
+	unsigned int se_vport_yoffset;
+	unsigned int se_vport_zscale;
+	unsigned int se_vport_zoffset;
+
+	/* Setup state */
+	unsigned int se_cntl_status;			/* 0x2140 */
+
+#ifdef TCL_ENABLE
+	/* TCL state */
+	radeon_color_regs_t se_tcl_material_emmissive;	/* 0x2210 */
+	radeon_color_regs_t se_tcl_material_ambient;
+	radeon_color_regs_t se_tcl_material_diffuse;
+	radeon_color_regs_t se_tcl_material_specular;
+	unsigned int se_tcl_shininess;
+	unsigned int se_tcl_output_vtx_fmt;
+	unsigned int se_tcl_output_vtx_sel;
+	unsigned int se_tcl_matrix_select_0;
+	unsigned int se_tcl_matrix_select_1;
+	unsigned int se_tcl_ucp_vert_blend_ctl;
+	unsigned int se_tcl_texture_proc_ctl;
+	unsigned int se_tcl_light_model_ctl;
+	unsigned int se_tcl_per_light_ctl[4];
+#endif
+
+	/* Misc state */
+	unsigned int re_top_left;			/* 0x26c0 */
+	unsigned int re_misc;
+} drm_radeon_context_regs_t;
+
+/* Setup registers for each texture unit
+ */
+typedef struct {
+	unsigned int pp_txfilter;
+	unsigned int pp_txformat;
+	unsigned int pp_txoffset;
+	unsigned int pp_txcblend;
+	unsigned int pp_txablend;
+	unsigned int pp_tfactor;
+
+	unsigned int pp_border_color;
+
+#ifdef CUBIC_ENABLE
+	unsigned int pp_cubic_faces;
+	unsigned int pp_cubic_offset[5];
+#endif
+} drm_radeon_texture_regs_t;
+
+typedef struct {
+	unsigned char next, prev;
+	unsigned char in_use;
+	int age;
+} drm_radeon_tex_region_t;
+
+typedef struct {
+	/* The channel for communication of state information to the kernel
+	 * on firing a vertex buffer.
+	 */
+	drm_radeon_context_regs_t context_state;
+	drm_radeon_texture_regs_t tex_state[RADEON_MAX_TEXTURE_UNITS];
+	unsigned int dirty;
+	unsigned int vertsize;
+	unsigned int vc_format;
+
+	/* The current cliprects, or a subset thereof.
+	 */
+	drm_clip_rect_t boxes[RADEON_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
+
+	/* Counters for client-side throttling of rendering clients.
+	 */
+	unsigned int last_frame;
+	unsigned int last_dispatch;
+	unsigned int last_clear;
+
+	drm_radeon_tex_region_t tex_list[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS+1];
+	int tex_age[RADEON_NR_TEX_HEAPS];
+	int ctx_owner;
+} drm_radeon_sarea_t;
+
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (xf86drmRadeon.h)
+ */
+typedef struct drm_radeon_init {
+	enum {
+		RADEON_INIT_CP    = 0x01,
+		RADEON_CLEANUP_CP = 0x02
+	} func;
+	int sarea_priv_offset;
+	int is_pci;
+	int cp_mode;
+	int agp_size;
+	int ring_size;
+	int usec_timeout;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	unsigned int fb_offset;
+	unsigned int mmio_offset;
+	unsigned int ring_offset;
+	unsigned int ring_rptr_offset;
+	unsigned int buffers_offset;
+	unsigned int agp_textures_offset;
+} drm_radeon_init_t;
+
+typedef struct drm_radeon_cp_stop {
+	int flush;
+	int idle;
+} drm_radeon_cp_stop_t;
+
+typedef struct drm_radeon_fullscreen {
+	enum {
+		RADEON_INIT_FULLSCREEN    = 0x01,
+		RADEON_CLEANUP_FULLSCREEN = 0x02
+	} func;
+} drm_radeon_fullscreen_t;
+
+#define CLEAR_X1	0
+#define CLEAR_Y1	1
+#define CLEAR_X2	2
+#define CLEAR_Y2	3
+#define CLEAR_DEPTH	4
+
+typedef struct drm_radeon_clear {
+	unsigned int flags;
+	int x, y, w, h;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+	union {
+		float f[5];
+		unsigned int ui[5];
+	} rect;
+} drm_radeon_clear_t;
+
+typedef struct drm_radeon_vertex {
+	int prim;
+	int idx;			/* Index of vertex buffer */
+	int count;			/* Number of vertices in buffer */
+	int discard;			/* Client finished with buffer? */
+} drm_radeon_vertex_t;
+
+typedef struct drm_radeon_indices {
+	int prim;
+	int idx;
+	int start;
+	int end;
+	int discard;			/* Client finished with buffer? */
+} drm_radeon_indices_t;
+
+typedef struct drm_radeon_blit {
+	int idx;
+	int pitch;
+	int offset;
+	int format;
+	unsigned short x, y;
+	unsigned short width, height;
+} drm_radeon_blit_t;
+
+typedef struct drm_radeon_stipple {
+	unsigned int *mask;
+} drm_radeon_stipple_t;
+
+typedef struct drm_radeon_indirect {
+	int idx;
+	int start;
+	int end;
+	int discard;
+} drm_radeon_indirect_t;
+
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/radeon_drv.c linux/drivers/char/drm-4.0/radeon_drv.c
--- linux.orig/drivers/char/drm-4.0/radeon_drv.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/radeon_drv.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,702 @@
+/* radeon_drv.c -- ATI Radeon driver -*- linux-c -*-
+ *
+ * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Kevin E. Martin <martin@valinux.com>
+ *          Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "radeon_drv.h"
+
+#define RADEON_NAME		"radeon"
+#define RADEON_DESC		"ATI Radeon"
+#define RADEON_DATE		"20010105"
+#define RADEON_MAJOR		1
+#define RADEON_MINOR		0
+#define RADEON_PATCHLEVEL	0
+
+static drm_device_t	      radeon_device;
+drm_ctx_t	              radeon_res_ctx;
+
+static struct file_operations radeon_fops = {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* This started being used during 2.4.0-test */
+	owner:   THIS_MODULE,
+#endif
+	open:	 radeon_open,
+	flush:	 drm_flush,
+	release: radeon_release,
+	ioctl:	 radeon_ioctl,
+	mmap:	 drm_mmap,
+	read:	 drm_read,
+	fasync:	 drm_fasync,
+	poll:	 drm_poll,
+};
+
+static struct miscdevice      radeon_misc = {
+	minor: MISC_DYNAMIC_MINOR,
+	name:  RADEON_NAME,
+	fops:  &radeon_fops,
+};
+
+static drm_ioctl_desc_t	      radeon_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]       = { radeon_version,	0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)]    = { drm_getunique,	0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]     = { drm_getmagic,	0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]     = { drm_irq_busid,	0, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)]    = { drm_setunique,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]	        = { drm_block,		1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]       = { drm_unblock,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)]    = { drm_authmagic,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]       = { drm_addmap,		1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)]      = { radeon_addbufs,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)]     = { drm_markbufs,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)]     = { drm_infobufs,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MAP_BUFS)]      = { radeon_mapbufs,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)]     = { drm_freebufs,	1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]       = { radeon_addctx,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]        = { radeon_rmctx,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]       = { radeon_modctx,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]       = { radeon_getctx,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)]    = { radeon_switchctx,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]       = { radeon_newctx,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]       = { radeon_resctx,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]      = { drm_adddraw,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]       = { drm_rmdraw,		1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_DMA)]	        = { radeon_cp_buffers,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	        = { radeon_lock,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]        = { radeon_unlock,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]        = { drm_finish,		1, 0 },
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)]   = { drm_agp_acquire,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)]   = { drm_agp_release,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)]    = { drm_agp_enable,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)]      = { drm_agp_info,	1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)]     = { drm_agp_alloc,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)]      = { drm_agp_free,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)]      = { drm_agp_bind,	1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)]    = { drm_agp_unbind,	1, 1 },
+#endif
+
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_INIT)]  = { radeon_cp_init,   1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_START)] = { radeon_cp_start,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_STOP)]  = { radeon_cp_stop,   1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_RESET)] = { radeon_cp_reset,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_CP_IDLE)]  = { radeon_cp_idle,   1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_RESET)] = { radeon_engine_reset, 1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_FULLSCREEN)] = { radeon_fullscreen, 1, 0 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_SWAP)]    = { radeon_cp_swap,    1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_CLEAR)]   = { radeon_cp_clear,   1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_VERTEX)]  = { radeon_cp_vertex,  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_INDICES)] = { radeon_cp_indices, 1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_BLIT)]    = { radeon_cp_blit,    1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_STIPPLE)] = { radeon_cp_stipple, 1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RADEON_INDIRECT)]= { radeon_cp_indirect,1, 1 },
+};
+#define RADEON_IOCTL_COUNT DRM_ARRAY_SIZE(radeon_ioctls)
+
+#ifdef MODULE
+static char		      *radeon = NULL;
+#endif
+
+MODULE_AUTHOR("VA Linux Systems, Inc.");
+MODULE_DESCRIPTION("radeon");
+MODULE_PARM(radeon, "s");
+
+#ifndef MODULE
+/* radeon_options is called by the kernel to parse command-line options
+ * passed via the boot-loader (e.g., LILO).  It calls the insmod option
+ * routine, drm_parse_drm.
+ */
+
+static int __init radeon_options(char *str)
+{
+	drm_parse_options(str);
+	return 1;
+}
+
+__setup("radeon=", radeon_options);
+#endif
+
+static int radeon_setup(drm_device_t *dev)
+{
+	int i;
+
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
+	dev->buf_use	  = 0;
+	atomic_set(&dev->buf_alloc, 0);
+
+	drm_dma_setup(dev);
+
+	atomic_set(&dev->total_open, 0);
+	atomic_set(&dev->total_close, 0);
+	atomic_set(&dev->total_ioctl, 0);
+	atomic_set(&dev->total_irq, 0);
+	atomic_set(&dev->total_ctx, 0);
+	atomic_set(&dev->total_locks, 0);
+	atomic_set(&dev->total_unlocks, 0);
+	atomic_set(&dev->total_contends, 0);
+	atomic_set(&dev->total_sleeps, 0);
+
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		dev->magiclist[i].head = NULL;
+		dev->magiclist[i].tail = NULL;
+	}
+	dev->maplist	    = NULL;
+	dev->map_count	    = 0;
+	dev->vmalist	    = NULL;
+	dev->lock.hw_lock   = NULL;
+	init_waitqueue_head(&dev->lock.lock_queue);
+	dev->queue_count    = 0;
+	dev->queue_reserved = 0;
+	dev->queue_slots    = 0;
+	dev->queuelist	    = NULL;
+	dev->irq	    = 0;
+	dev->context_flag   = 0;
+	dev->interrupt_flag = 0;
+	dev->dma_flag	    = 0;
+	dev->last_context   = 0;
+	dev->last_switch    = 0;
+	dev->last_checked   = 0;
+	init_timer(&dev->timer);
+	init_waitqueue_head(&dev->context_wait);
+
+	dev->ctx_start	    = 0;
+	dev->lck_start	    = 0;
+
+	dev->buf_rp	    = dev->buf;
+	dev->buf_wp	    = dev->buf;
+	dev->buf_end	    = dev->buf + DRM_BSZ;
+	dev->buf_async	    = NULL;
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
+
+	radeon_res_ctx.handle = -1;
+
+	DRM_DEBUG("\n");
+
+	/* The kernel's context could be created here, but is now created
+	   in drm_dma_enqueue.	This is more resource-efficient for
+	   hardware that does not do DMA, but may mean that
+	   drm_select_queue fails between the time the interrupt is
+	   initialized and the time the queues are initialized. */
+
+	return 0;
+}
+
+
+static int radeon_takedown(drm_device_t *dev)
+{
+	int		  i;
+	drm_magic_entry_t *pt, *next;
+	drm_map_t	  *map;
+	drm_vma_entry_t	  *vma, *vma_next;
+
+	DRM_DEBUG("\n");
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
+
+	if (dev->devname) {
+		drm_free(dev->devname, strlen(dev->devname)+1, DRM_MEM_DRIVER);
+		dev->devname = NULL;
+	}
+
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique)+1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
+				/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
+			next = pt->next;
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+		}
+		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
+	}
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+				/* Clear AGP information */
+	if (dev->agp) {
+		drm_agp_mem_t *entry;
+		drm_agp_mem_t *nexte;
+
+				/* Remove AGP resources, but leave dev->agp
+                                   intact until radeon_cleanup is called. */
+		for (entry = dev->agp->memory; entry; entry = nexte) {
+			nexte = entry->next;
+			if (entry->bound) drm_unbind_agp(entry->memory);
+			drm_free_agp(entry->memory, entry->pages);
+			drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+		}
+		dev->agp->memory = NULL;
+
+		if (dev->agp->acquired)	_drm_agp_release();
+
+		dev->agp->acquired = 0;
+		dev->agp->enabled  = 0;
+	}
+#endif
+
+				/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
+			vma_next = vma->next;
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		}
+		dev->vmalist = NULL;
+	}
+
+				/* Clear map area and mtrr information */
+	if (dev->maplist) {
+		for (i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			switch (map->type) {
+			case _DRM_REGISTERS:
+			case _DRM_FRAME_BUFFER:
+#ifdef CONFIG_MTRR
+				if (map->mtrr >= 0) {
+					int retcode;
+					retcode = mtrr_del(map->mtrr,
+							   map->offset,
+							   map->size);
+					DRM_DEBUG("mtrr_del = %d\n", retcode);
+				}
+#endif
+				drm_ioremapfree(map->handle, map->size, dev);
+				break;
+			case _DRM_SHM:
+				drm_free_pages((unsigned long)map->handle,
+					       drm_order(map->size)
+					       - PAGE_SHIFT,
+					       DRM_MEM_SAREA);
+				break;
+			case _DRM_AGP:
+				/* Do nothing here, because this is all
+                                   handled in the AGP/GART driver. */
+				break;
+			}
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		}
+		drm_free(dev->maplist,
+			 dev->map_count * sizeof(*dev->maplist),
+			 DRM_MEM_MAPS);
+		dev->maplist   = NULL;
+		dev->map_count = 0;
+	}
+
+	drm_dma_takedown(dev);
+
+	dev->queue_count     = 0;
+	if (dev->lock.hw_lock) {
+		dev->lock.hw_lock    = NULL; /* SHM removed */
+		dev->lock.pid	     = 0;
+		wake_up_interruptible(&dev->lock.lock_queue);
+	}
+	up(&dev->struct_sem);
+
+	return 0;
+}
+
+/* radeon_init is called via init_module at module load time, or via
+ * linux/init/main.c (this is not currently supported). */
+
+static int __init radeon_init(void)
+{
+	int		      retcode;
+	drm_device_t	      *dev = &radeon_device;
+
+	DRM_DEBUG("\n");
+
+	memset((void *)dev, 0, sizeof(*dev));
+	dev->count_lock	  = SPIN_LOCK_UNLOCKED;
+	sema_init(&dev->struct_sem, 1);
+
+#ifdef MODULE
+	drm_parse_options(radeon);
+#endif
+
+	if ((retcode = misc_register(&radeon_misc))) {
+		DRM_ERROR("Cannot register \"%s\"\n", RADEON_NAME);
+		return retcode;
+	}
+	dev->device = MKDEV(MISC_MAJOR, radeon_misc.minor);
+	dev->name   = RADEON_NAME;
+
+	drm_mem_init();
+	drm_proc_init(dev);
+
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	dev->agp    = drm_agp_init();
+      	if (dev->agp == NULL) {
+	   	DRM_ERROR("Cannot initialize agpgart module.\n");
+	   	drm_proc_cleanup();
+	   	misc_deregister(&radeon_misc);
+	   	radeon_takedown(dev);
+	   	return -ENOMEM;
+	}
+
+#ifdef CONFIG_MTRR
+	dev->agp->agp_mtrr = mtrr_add(dev->agp->agp_info.aper_base,
+				      dev->agp->agp_info.aper_size*1024*1024,
+				      MTRR_TYPE_WRCOMB,
+				      1);
+#endif
+#endif
+
+	if((retcode = drm_ctxbitmap_init(dev))) {
+		DRM_ERROR("Cannot allocate memory for context bitmap.\n");
+		drm_proc_cleanup();
+		misc_deregister(&radeon_misc);
+		radeon_takedown(dev);
+		return retcode;
+	}
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d\n",
+		 RADEON_NAME,
+		 RADEON_MAJOR,
+		 RADEON_MINOR,
+		 RADEON_PATCHLEVEL,
+		 RADEON_DATE,
+		 radeon_misc.minor);
+
+	return 0;
+}
+
+/* radeon_cleanup is called via cleanup_module at module unload time. */
+
+static void __exit radeon_cleanup(void)
+{
+	drm_device_t	      *dev = &radeon_device;
+
+	DRM_DEBUG("\n");
+
+	drm_proc_cleanup();
+	if (misc_deregister(&radeon_misc)) {
+		DRM_ERROR("Cannot unload module\n");
+	} else {
+		DRM_INFO("Module unloaded\n");
+	}
+	drm_ctxbitmap_cleanup(dev);
+	radeon_takedown(dev);
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	if (dev->agp) {
+		drm_agp_uninit();
+		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
+		dev->agp = NULL;
+	}
+#endif
+}
+
+module_init(radeon_init);
+module_exit(radeon_cleanup);
+
+
+int radeon_version(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_version_t version;
+	int	      len;
+
+	if (copy_from_user(&version,
+			   (drm_version_t *)arg,
+			   sizeof(version)))
+		return -EFAULT;
+
+#define DRM_COPY(name,value)				     \
+	len = strlen(value);				     \
+	if (len > name##_len) len = name##_len;		     \
+	name##_len = strlen(value);			     \
+	if (len && name) {				     \
+		if (copy_to_user(name, value, len))	     \
+			return -EFAULT;			     \
+	}
+
+	version.version_major	   = RADEON_MAJOR;
+	version.version_minor	   = RADEON_MINOR;
+	version.version_patchlevel = RADEON_PATCHLEVEL;
+
+	DRM_COPY(version.name, RADEON_NAME);
+	DRM_COPY(version.date, RADEON_DATE);
+	DRM_COPY(version.desc, RADEON_DESC);
+
+	if (copy_to_user((drm_version_t *)arg,
+			 &version,
+			 sizeof(version)))
+		return -EFAULT;
+	return 0;
+}
+
+int radeon_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t  *dev    = &radeon_device;
+	int	      retcode = 0;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_open_helper(inode, filp, dev))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_INC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_open);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return radeon_setup(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+
+	return retcode;
+}
+
+int radeon_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev;
+	int	      retcode = 0;
+
+	lock_kernel();
+	dev = priv->dev;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+
+	/* Force the cleanup of page flipping when required */
+	if ( dev->dev_private ) {
+		drm_radeon_private_t *dev_priv = dev->dev_private;
+		if ( dev_priv->page_flipping ) {
+			radeon_do_cleanup_pageflip( dev );
+		}
+	}
+
+	if (!(retcode = drm_release(inode, filp))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_DEC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_close);
+		spin_lock(&dev->count_lock);
+		if (!--dev->open_count) {
+			if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+				DRM_ERROR("Device busy: %d %d\n",
+					  atomic_read(&dev->ioctl_count),
+					  dev->blocked);
+				spin_unlock(&dev->count_lock);
+				unlock_kernel();
+				return -EBUSY;
+			}
+			spin_unlock(&dev->count_lock);
+			unlock_kernel();
+			return radeon_takedown(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+
+	unlock_kernel();
+	return retcode;
+}
+
+/* radeon_ioctl is called whenever a process performs an ioctl on /dev/drm. */
+
+int radeon_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	int		 nr	 = DRM_IOCTL_NR(cmd);
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	int		 retcode = 0;
+	drm_ioctl_desc_t *ioctl;
+	drm_ioctl_t	 *func;
+
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->total_ioctl);
+	++priv->ioctl_count;
+
+	DRM_DEBUG("pid = %d, cmd = 0x%02x, nr = 0x%02x, dev 0x%x, auth = %d\n",
+		  current->pid, cmd, nr, dev->device, priv->authenticated);
+
+	if (nr >= RADEON_IOCTL_COUNT) {
+		retcode = -EINVAL;
+	} else {
+		ioctl	  = &radeon_ioctls[nr];
+		func	  = ioctl->func;
+
+		if (!func) {
+			DRM_DEBUG("no function\n");
+			retcode = -EINVAL;
+		} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN))
+			    || (ioctl->auth_needed && !priv->authenticated)) {
+			retcode = -EACCES;
+		} else {
+			retcode = (func)(inode, filp, cmd, arg);
+		}
+	}
+
+	atomic_dec(&dev->ioctl_count);
+	return retcode;
+}
+
+int radeon_lock(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+        drm_file_t        *priv   = filp->private_data;
+        drm_device_t      *dev    = priv->dev;
+        DECLARE_WAITQUEUE(entry, current);
+        int               ret   = 0;
+        drm_lock_t        lock;
+#if DRM_DMA_HISTOGRAM
+        cycles_t          start;
+
+        dev->lck_start = start = get_cycles();
+#endif
+
+        if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+        if (lock.context == DRM_KERNEL_CONTEXT) {
+                DRM_ERROR("Process %d using kernel context %d\n",
+                          current->pid, lock.context);
+                return -EINVAL;
+        }
+
+        DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+                  lock.context, current->pid, dev->lock.hw_lock->lock,
+                  lock.flags);
+
+        if (lock.context < 0 /* || lock.context >= dev->queue_count */)
+                return -EINVAL;
+
+        if (!ret) {
+                add_wait_queue(&dev->lock.lock_queue, &entry);
+                for (;;) {
+                        current->state = TASK_INTERRUPTIBLE;
+                        if (!dev->lock.hw_lock) {
+                                /* Device has been unregistered */
+                                ret = -EINTR;
+                                break;
+                        }
+                        if (drm_lock_take(&dev->lock.hw_lock->lock,
+                                          lock.context)) {
+                                dev->lock.pid       = current->pid;
+                                dev->lock.lock_time = jiffies;
+                                atomic_inc(&dev->total_locks);
+                                break;  /* Got lock */
+                        }
+
+                                /* Contention */
+                        atomic_inc(&dev->total_sleeps);
+                        schedule();
+                        if (signal_pending(current)) {
+                                ret = -ERESTARTSYS;
+                                break;
+                        }
+                }
+                current->state = TASK_RUNNING;
+                remove_wait_queue(&dev->lock.lock_queue, &entry);
+        }
+
+        if (!ret) {
+		sigemptyset(&dev->sigmask);
+		sigaddset(&dev->sigmask, SIGSTOP);
+		sigaddset(&dev->sigmask, SIGTSTP);
+		sigaddset(&dev->sigmask, SIGTTIN);
+		sigaddset(&dev->sigmask, SIGTTOU);
+		dev->sigdata.context = lock.context;
+		dev->sigdata.lock    = dev->lock.hw_lock;
+		block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+                if (lock.flags & _DRM_LOCK_READY) {
+				/* Wait for space in DMA/FIFO */
+		}
+                if (lock.flags & _DRM_LOCK_QUIESCENT) {
+				/* Make hardware quiescent */
+			DRM_DEBUG("not quiescent!\n");
+#if 0
+                        radeon_quiescent(dev);
+#endif
+		}
+        }
+
+#if LINUX_VERSION_CODE < 0x020400
+	if (lock.context != radeon_res_ctx.handle) {
+		current->counter = 5;
+		current->priority = DEF_PRIORITY/4;
+	}
+#endif
+        DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
+
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.lacq[drm_histogram_slot(get_cycles() - start)]);
+#endif
+
+        return ret;
+}
+
+
+int radeon_unlock(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d frees lock (%d holds)\n",
+		  lock.context,
+		  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	atomic_inc(&dev->total_unlocks);
+	if (_DRM_LOCK_IS_CONT(dev->lock.hw_lock->lock))
+		atomic_inc(&dev->total_contends);
+	drm_lock_transfer(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
+				/* FIXME: Try to send data to card here */
+	if (!dev->context_flag) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+
+#if LINUX_VERSION_CODE < 0x020400
+	if (lock.context != radeon_res_ctx.handle) {
+		current->counter = 5;
+		current->priority = DEF_PRIORITY;
+	}
+#endif
+	unblock_all_signals();
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/radeon_drv.h linux/drivers/char/drm-4.0/radeon_drv.h
--- linux.orig/drivers/char/drm-4.0/radeon_drv.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/radeon_drv.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,709 @@
+/* radeon_drv.h -- Private header for radeon driver -*- linux-c -*-
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@valinux.com>
+ *   Kevin E. Martin <martin@valinux.com>
+ *   Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#ifndef __RADEON_DRV_H__
+#define __RADEON_DRV_H__
+
+typedef struct drm_radeon_freelist {
+   	unsigned int age;
+   	drm_buf_t *buf;
+   	struct drm_radeon_freelist *next;
+   	struct drm_radeon_freelist *prev;
+} drm_radeon_freelist_t;
+
+typedef struct drm_radeon_ring_buffer {
+	u32 *start;
+	u32 *end;
+	int size;
+	int size_l2qw;
+
+	volatile u32 *head;
+	u32 tail;
+	u32 tail_mask;
+	int space;
+} drm_radeon_ring_buffer_t;
+
+typedef struct drm_radeon_depth_clear_t {
+	u32 rb3d_cntl;
+	u32 rb3d_zstencilcntl;
+	u32 se_cntl;
+} drm_radeon_depth_clear_t;
+
+typedef struct drm_radeon_private {
+	drm_radeon_ring_buffer_t ring;
+	drm_radeon_sarea_t *sarea_priv;
+
+	int agp_size;
+	u32 agp_vm_start;
+	u32 agp_buffers_offset;
+
+	int cp_mode;
+	int cp_running;
+
+   	drm_radeon_freelist_t *head;
+   	drm_radeon_freelist_t *tail;
+/* FIXME: ROTATE_BUFS is a hask to cycle through bufs until freelist
+   code is used.  Note this hides a problem with the scratch register
+   (used to keep track of last buffer completed) being written to before
+   the last buffer has actually completed rendering. */
+#define ROTATE_BUFS 1
+#if ROTATE_BUFS
+	int last_buf;
+#endif
+	volatile u32 *scratch;
+
+	int usec_timeout;
+	int is_pci;
+
+	atomic_t idle_count;
+
+	int page_flipping;
+	int current_page;
+	u32 crtc_offset;
+	u32 crtc_offset_cntl;
+
+	unsigned int color_fmt;
+	unsigned int front_offset;
+	unsigned int front_pitch;
+	unsigned int back_offset;
+	unsigned int back_pitch;
+
+	unsigned int depth_fmt;
+	unsigned int depth_offset;
+	unsigned int depth_pitch;
+
+	u32 front_pitch_offset;
+	u32 back_pitch_offset;
+	u32 depth_pitch_offset;
+
+	drm_radeon_depth_clear_t depth_clear;
+
+	drm_map_t *sarea;
+	drm_map_t *fb;
+	drm_map_t *mmio;
+	drm_map_t *cp_ring;
+	drm_map_t *ring_rptr;
+	drm_map_t *buffers;
+	drm_map_t *agp_textures;
+} drm_radeon_private_t;
+
+typedef struct drm_radeon_buf_priv {
+	u32 age;
+	int prim;
+	int discard;
+	int dispatched;
+   	drm_radeon_freelist_t *list_entry;
+} drm_radeon_buf_priv_t;
+
+				/* radeon_drv.c */
+extern int  radeon_version( struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg );
+extern int  radeon_open( struct inode *inode, struct file *filp );
+extern int  radeon_release( struct inode *inode, struct file *filp );
+extern int  radeon_ioctl( struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg );
+extern int  radeon_lock( struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg );
+extern int  radeon_unlock( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+
+				/* radeon_cp.c */
+extern int radeon_cp_init( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int radeon_cp_start( struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg );
+extern int radeon_cp_stop( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int radeon_cp_reset( struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg );
+extern int radeon_cp_idle( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int radeon_engine_reset( struct inode *inode, struct file *filp,
+				unsigned int cmd, unsigned long arg );
+extern int radeon_fullscreen( struct inode *inode, struct file *filp,
+			      unsigned int cmd, unsigned long arg );
+extern int radeon_cp_buffers( struct inode *inode, struct file *filp,
+			      unsigned int cmd, unsigned long arg );
+
+extern void radeon_freelist_reset( drm_device_t *dev );
+extern drm_buf_t *radeon_freelist_get( drm_device_t *dev );
+
+extern int radeon_wait_ring( drm_radeon_private_t *dev_priv, int n );
+extern void radeon_update_ring_snapshot( drm_radeon_private_t *dev_priv );
+
+extern int radeon_do_cp_idle( drm_radeon_private_t *dev_priv );
+extern int radeon_do_cleanup_pageflip( drm_device_t *dev );
+
+				/* radeon_state.c */
+extern int radeon_cp_clear( struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg );
+extern int radeon_cp_swap( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int radeon_cp_vertex( struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg );
+extern int radeon_cp_indices( struct inode *inode, struct file *filp,
+			      unsigned int cmd, unsigned long arg );
+extern int radeon_cp_blit( struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg );
+extern int radeon_cp_stipple( struct inode *inode, struct file *filp,
+			      unsigned int cmd, unsigned long arg );
+extern int radeon_cp_indirect( struct inode *inode, struct file *filp,
+			       unsigned int cmd, unsigned long arg );
+
+				/* radeon_bufs.c */
+extern int radeon_addbufs(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int radeon_mapbufs(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+
+				/* radeon_context.c */
+extern int  radeon_resctx(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  radeon_addctx(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  radeon_modctx(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  radeon_getctx(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  radeon_switchctx(struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg);
+extern int  radeon_newctx(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  radeon_rmctx(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+
+extern int  radeon_context_switch(drm_device_t *dev, int old, int new);
+extern int  radeon_context_switch_complete(drm_device_t *dev, int new);
+
+
+/* Register definitions, register access macros and drmAddMap constants
+ * for Radeon kernel driver.
+ */
+
+#define RADEON_AUX_SCISSOR_CNTL		0x26f0
+#	define RADEON_EXCLUSIVE_SCISSOR_0	(1 << 24)
+#	define RADEON_EXCLUSIVE_SCISSOR_1	(1 << 25)
+#	define RADEON_EXCLUSIVE_SCISSOR_2	(1 << 26)
+#	define RADEON_SCISSOR_0_ENABLE		(1 << 28)
+#	define RADEON_SCISSOR_1_ENABLE		(1 << 29)
+#	define RADEON_SCISSOR_2_ENABLE		(1 << 30)
+
+#define RADEON_BUS_CNTL			0x0030
+#	define RADEON_BUS_MASTER_DIS		(1 << 6)
+
+#define RADEON_CLOCK_CNTL_DATA		0x000c
+#	define RADEON_PLL_WR_EN			(1 << 7)
+#define RADEON_CLOCK_CNTL_INDEX		0x0008
+#define RADEON_CONFIG_APER_SIZE		0x0108
+#define RADEON_CRTC_OFFSET		0x0224
+#define RADEON_CRTC_OFFSET_CNTL		0x0228
+#	define RADEON_CRTC_TILE_EN		(1 << 15)
+#	define RADEON_CRTC_OFFSET_FLIP_CNTL	(1 << 16)
+
+#define RADEON_RB3D_COLORPITCH		0x1c48
+#define RADEON_RB3D_DEPTHCLEARVALUE	0x1c30
+#define RADEON_RB3D_DEPTHXY_OFFSET	0x1c60
+
+#define RADEON_DP_GUI_MASTER_CNTL	0x146c
+#	define RADEON_GMC_SRC_PITCH_OFFSET_CNTL	(1 << 0)
+#	define RADEON_GMC_DST_PITCH_OFFSET_CNTL	(1 << 1)
+#	define RADEON_GMC_BRUSH_SOLID_COLOR	(13 << 4)
+#	define RADEON_GMC_BRUSH_NONE		(15 << 4)
+#	define RADEON_GMC_DST_16BPP		(4 << 8)
+#	define RADEON_GMC_DST_24BPP		(5 << 8)
+#	define RADEON_GMC_DST_32BPP		(6 << 8)
+#	define RADEON_GMC_DST_DATATYPE_SHIFT	8
+#	define RADEON_GMC_SRC_DATATYPE_COLOR	(3 << 12)
+#	define RADEON_DP_SRC_SOURCE_MEMORY	(2 << 24)
+#	define RADEON_DP_SRC_SOURCE_HOST_DATA	(3 << 24)
+#	define RADEON_GMC_CLR_CMP_CNTL_DIS	(1 << 28)
+#	define RADEON_GMC_WR_MSK_DIS		(1 << 30)
+#	define RADEON_ROP3_S			0x00cc0000
+#	define RADEON_ROP3_P			0x00f00000
+#define RADEON_DP_WRITE_MASK		0x16cc
+#define RADEON_DST_PITCH_OFFSET		0x142c
+#define RADEON_DST_PITCH_OFFSET_C	0x1c80
+#	define RADEON_DST_TILE_LINEAR		(0 << 30)
+#	define RADEON_DST_TILE_MACRO		(1 << 30)
+#	define RADEON_DST_TILE_MICRO		(2 << 30)
+#	define RADEON_DST_TILE_BOTH		(3 << 30)
+
+#define RADEON_SCRATCH_REG0		0x15e0
+#define RADEON_SCRATCH_REG1		0x15e4
+#define RADEON_SCRATCH_REG2		0x15e8
+#define RADEON_SCRATCH_REG3		0x15ec
+#define RADEON_SCRATCH_REG4		0x15f0
+#define RADEON_SCRATCH_REG5		0x15f4
+#define RADEON_SCRATCH_UMSK		0x0770
+#define RADEON_SCRATCH_ADDR		0x0774
+
+#define RADEON_HOST_PATH_CNTL		0x0130
+#	define RADEON_HDP_SOFT_RESET		(1 << 26)
+#	define RADEON_HDP_WC_TIMEOUT_MASK	(7 << 28)
+#	define RADEON_HDP_WC_TIMEOUT_28BCLK	(7 << 28)
+
+#define RADEON_ISYNC_CNTL		0x1724
+#	define RADEON_ISYNC_ANY2D_IDLE3D	(1 << 0)
+#	define RADEON_ISYNC_ANY3D_IDLE2D	(1 << 1)
+#	define RADEON_ISYNC_TRIG2D_IDLE3D	(1 << 2)
+#	define RADEON_ISYNC_TRIG3D_IDLE2D	(1 << 3)
+#	define RADEON_ISYNC_WAIT_IDLEGUI	(1 << 4)
+#	define RADEON_ISYNC_CPSCRATCH_IDLEGUI	(1 << 5)
+
+#define RADEON_MC_AGP_LOCATION		0x014c
+#define RADEON_MC_FB_LOCATION		0x0148
+#define RADEON_MCLK_CNTL		0x0012
+
+#define RADEON_PP_BORDER_COLOR_0	0x1d40
+#define RADEON_PP_BORDER_COLOR_1	0x1d44
+#define RADEON_PP_BORDER_COLOR_2	0x1d48
+#define RADEON_PP_CNTL			0x1c38
+#	define RADEON_SCISSOR_ENABLE		(1 <<  1)
+#define RADEON_PP_LUM_MATRIX		0x1d00
+#define RADEON_PP_MISC			0x1c14
+#define RADEON_PP_ROT_MATRIX_0		0x1d58
+#define RADEON_PP_TXFILTER_0		0x1c54
+#define RADEON_PP_TXFILTER_1		0x1c6c
+#define RADEON_PP_TXFILTER_2		0x1c84
+
+#define RADEON_RB2D_DSTCACHE_CTLSTAT	0x342c
+#	define RADEON_RB2D_DC_FLUSH		(3 << 0)
+#	define RADEON_RB2D_DC_FREE		(3 << 2)
+#	define RADEON_RB2D_DC_FLUSH_ALL		0xf
+#	define RADEON_RB2D_DC_BUSY		(1 << 31)
+#define RADEON_RB3D_CNTL		0x1c3c
+#	define RADEON_ALPHA_BLEND_ENABLE	(1 << 0)
+#	define RADEON_PLANE_MASK_ENABLE		(1 << 1)
+#	define RADEON_DITHER_ENABLE		(1 << 2)
+#	define RADEON_ROUND_ENABLE		(1 << 3)
+#	define RADEON_SCALE_DITHER_ENABLE	(1 << 4)
+#	define RADEON_DITHER_INIT		(1 << 5)
+#	define RADEON_ROP_ENABLE		(1 << 6)
+#	define RADEON_STENCIL_ENABLE		(1 << 7)
+#	define RADEON_Z_ENABLE			(1 << 8)
+#	define RADEON_DEPTH_XZ_OFFEST_ENABLE	(1 << 9)
+#	define RADEON_ZBLOCK8			(0 << 15)
+#	define RADEON_ZBLOCK16			(1 << 15)
+#define RADEON_RB3D_DEPTHOFFSET		0x1c24
+#define RADEON_RB3D_PLANEMASK		0x1d84
+#define RADEON_RB3D_STENCILREFMASK	0x1d7c
+#define RADEON_RB3D_ZCACHE_MODE		0x3250
+#define RADEON_RB3D_ZCACHE_CTLSTAT	0x3254
+#	define RADEON_RB3D_ZC_FLUSH		(1 << 0)
+#	define RADEON_RB3D_ZC_FREE		(1 << 2)
+#	define RADEON_RB3D_ZC_FLUSH_ALL		0x5
+#	define RADEON_RB3D_ZC_BUSY		(1 << 31)
+#define RADEON_RB3D_ZSTENCILCNTL	0x1c2c
+#	define RADEON_Z_TEST_MASK		(7 << 4)
+#	define RADEON_Z_TEST_ALWAYS		(7 << 4)
+#	define RADEON_STENCIL_TEST_ALWAYS	(7 << 12)
+#	define RADEON_STENCIL_S_FAIL_KEEP	(0 << 16)
+#	define RADEON_STENCIL_ZPASS_KEEP	(0 << 20)
+#	define RADEON_STENCIL_ZFAIL_KEEP	(0 << 20)
+#	define RADEON_Z_WRITE_ENABLE		(1 << 30)
+#define RADEON_RBBM_SOFT_RESET		0x00f0
+#	define RADEON_SOFT_RESET_CP		(1 <<  0)
+#	define RADEON_SOFT_RESET_HI		(1 <<  1)
+#	define RADEON_SOFT_RESET_SE		(1 <<  2)
+#	define RADEON_SOFT_RESET_RE		(1 <<  3)
+#	define RADEON_SOFT_RESET_PP		(1 <<  4)
+#	define RADEON_SOFT_RESET_E2		(1 <<  5)
+#	define RADEON_SOFT_RESET_RB		(1 <<  6)
+#	define RADEON_SOFT_RESET_HDP		(1 <<  7)
+#define RADEON_RBBM_STATUS		0x0e40
+#	define RADEON_RBBM_FIFOCNT_MASK		0x007f
+#	define RADEON_RBBM_ACTIVE		(1 << 31)
+#define RADEON_RE_LINE_PATTERN		0x1cd0
+#define RADEON_RE_MISC			0x26c4
+#define RADEON_RE_TOP_LEFT		0x26c0
+#define RADEON_RE_WIDTH_HEIGHT		0x1c44
+#define RADEON_RE_STIPPLE_ADDR		0x1cc8
+#define RADEON_RE_STIPPLE_DATA		0x1ccc
+
+#define RADEON_SCISSOR_TL_0		0x1cd8
+#define RADEON_SCISSOR_BR_0		0x1cdc
+#define RADEON_SCISSOR_TL_1		0x1ce0
+#define RADEON_SCISSOR_BR_1		0x1ce4
+#define RADEON_SCISSOR_TL_2		0x1ce8
+#define RADEON_SCISSOR_BR_2		0x1cec
+#define RADEON_SE_COORD_FMT		0x1c50
+#define RADEON_SE_CNTL			0x1c4c
+#	define RADEON_FFACE_CULL_CW		(0 << 0)
+#	define RADEON_BFACE_SOLID		(3 << 1)
+#	define RADEON_FFACE_SOLID		(3 << 3)
+#	define RADEON_FLAT_SHADE_VTX_LAST	(3 << 6)
+#	define RADEON_DIFFUSE_SHADE_FLAT	(1 << 8)
+#	define RADEON_DIFFUSE_SHADE_GOURAUD	(2 << 8)
+#	define RADEON_ALPHA_SHADE_FLAT		(1 << 10)
+#	define RADEON_ALPHA_SHADE_GOURAUD	(2 << 10)
+#	define RADEON_SPECULAR_SHADE_FLAT	(1 << 12)
+#	define RADEON_SPECULAR_SHADE_GOURAUD	(2 << 12)
+#	define RADEON_FOG_SHADE_FLAT		(1 << 14)
+#	define RADEON_FOG_SHADE_GOURAUD		(2 << 14)
+#	define RADEON_VPORT_XY_XFORM_ENABLE	(1 << 24)
+#	define RADEON_VPORT_Z_XFORM_ENABLE	(1 << 25)
+#	define RADEON_VTX_PIX_CENTER_OGL	(1 << 27)
+#	define RADEON_ROUND_MODE_TRUNC		(0 << 28)
+#	define RADEON_ROUND_PREC_8TH_PIX	(1 << 30)
+#define RADEON_SE_CNTL_STATUS		0x2140
+#define RADEON_SE_LINE_WIDTH		0x1db8
+#define RADEON_SE_VPORT_XSCALE		0x1d98
+#define RADEON_SURFACE_ACCESS_FLAGS	0x0bf8
+#define RADEON_SURFACE_ACCESS_CLR	0x0bfc
+#define RADEON_SURFACE_CNTL		0x0b00
+#	define RADEON_SURF_TRANSLATION_DIS	(1 << 8)
+#	define RADEON_NONSURF_AP0_SWP_MASK	(3 << 20)
+#	define RADEON_NONSURF_AP0_SWP_LITTLE	(0 << 20)
+#	define RADEON_NONSURF_AP0_SWP_BIG16	(1 << 20)
+#	define RADEON_NONSURF_AP0_SWP_BIG32	(2 << 20)
+#	define RADEON_NONSURF_AP1_SWP_MASK	(3 << 22)
+#	define RADEON_NONSURF_AP1_SWP_LITTLE	(0 << 22)
+#	define RADEON_NONSURF_AP1_SWP_BIG16	(1 << 22)
+#	define RADEON_NONSURF_AP1_SWP_BIG32	(2 << 22)
+#define RADEON_SURFACE0_INFO		0x0b0c
+#	define RADEON_SURF_PITCHSEL_MASK	(0x1ff << 0)
+#	define RADEON_SURF_TILE_MODE_MASK	(3 << 16)
+#	define RADEON_SURF_TILE_MODE_MACRO	(0 << 16)
+#	define RADEON_SURF_TILE_MODE_MICRO	(1 << 16)
+#	define RADEON_SURF_TILE_MODE_32BIT_Z	(2 << 16)
+#	define RADEON_SURF_TILE_MODE_16BIT_Z	(3 << 16)
+#define RADEON_SURFACE0_LOWER_BOUND	0x0b04
+#define RADEON_SURFACE0_UPPER_BOUND	0x0b08
+#define RADEON_SURFACE1_INFO		0x0b1c
+#define RADEON_SURFACE1_LOWER_BOUND	0x0b14
+#define RADEON_SURFACE1_UPPER_BOUND	0x0b18
+#define RADEON_SURFACE2_INFO		0x0b2c
+#define RADEON_SURFACE2_LOWER_BOUND	0x0b24
+#define RADEON_SURFACE2_UPPER_BOUND	0x0b28
+#define RADEON_SURFACE3_INFO		0x0b3c
+#define RADEON_SURFACE3_LOWER_BOUND	0x0b34
+#define RADEON_SURFACE3_UPPER_BOUND	0x0b38
+#define RADEON_SURFACE4_INFO		0x0b4c
+#define RADEON_SURFACE4_LOWER_BOUND	0x0b44
+#define RADEON_SURFACE4_UPPER_BOUND	0x0b48
+#define RADEON_SURFACE5_INFO		0x0b5c
+#define RADEON_SURFACE5_LOWER_BOUND	0x0b54
+#define RADEON_SURFACE5_UPPER_BOUND	0x0b58
+#define RADEON_SURFACE6_INFO		0x0b6c
+#define RADEON_SURFACE6_LOWER_BOUND	0x0b64
+#define RADEON_SURFACE6_UPPER_BOUND	0x0b68
+#define RADEON_SURFACE7_INFO		0x0b7c
+#define RADEON_SURFACE7_LOWER_BOUND	0x0b74
+#define RADEON_SURFACE7_UPPER_BOUND	0x0b78
+#define RADEON_SW_SEMAPHORE		0x013c
+
+#define RADEON_WAIT_UNTIL		0x1720
+#	define RADEON_WAIT_CRTC_PFLIP		(1 << 0)
+#	define RADEON_WAIT_2D_IDLECLEAN		(1 << 16)
+#	define RADEON_WAIT_3D_IDLECLEAN		(1 << 17)
+#	define RADEON_WAIT_HOST_IDLECLEAN	(1 << 18)
+
+#define RADEON_RB3D_ZMASKOFFSET		0x1c34
+#define RADEON_RB3D_ZSTENCILCNTL	0x1c2c
+#	define RADEON_DEPTH_FORMAT_16BIT_INT_Z	(0 << 0)
+#	define RADEON_DEPTH_FORMAT_24BIT_INT_Z	(2 << 0)
+
+
+/* CP registers */
+#define RADEON_CP_ME_RAM_ADDR		0x07d4
+#define RADEON_CP_ME_RAM_RADDR		0x07d8
+#define RADEON_CP_ME_RAM_DATAH		0x07dc
+#define RADEON_CP_ME_RAM_DATAL		0x07e0
+
+#define RADEON_CP_RB_BASE		0x0700
+#define RADEON_CP_RB_CNTL		0x0704
+#define RADEON_CP_RB_RPTR_ADDR		0x070c
+#define RADEON_CP_RB_RPTR		0x0710
+#define RADEON_CP_RB_WPTR		0x0714
+
+#define RADEON_CP_RB_WPTR_DELAY		0x0718
+#	define RADEON_PRE_WRITE_TIMER_SHIFT	0
+#	define RADEON_PRE_WRITE_LIMIT_SHIFT	23
+
+#define RADEON_CP_IB_BASE		0x0738
+
+#define RADEON_CP_CSQ_CNTL		0x0740
+#	define RADEON_CSQ_CNT_PRIMARY_MASK	(0xff << 0)
+#	define RADEON_CSQ_PRIDIS_INDDIS		(0 << 28)
+#	define RADEON_CSQ_PRIPIO_INDDIS		(1 << 28)
+#	define RADEON_CSQ_PRIBM_INDDIS		(2 << 28)
+#	define RADEON_CSQ_PRIPIO_INDBM		(3 << 28)
+#	define RADEON_CSQ_PRIBM_INDBM		(4 << 28)
+#	define RADEON_CSQ_PRIPIO_INDPIO		(15 << 28)
+
+#define RADEON_AIC_CNTL			0x01d0
+#	define RADEON_PCIGART_TRANSLATE_EN	(1 << 0)
+
+/* CP command packets */
+#define RADEON_CP_PACKET0		0x00000000
+#	define RADEON_ONE_REG_WR		(1 << 15)
+#define RADEON_CP_PACKET1		0x40000000
+#define RADEON_CP_PACKET2		0x80000000
+#define RADEON_CP_PACKET3		0xC0000000
+#	define RADEON_3D_RNDR_GEN_INDX_PRIM	0x00002300
+#	define RADEON_WAIT_FOR_IDLE		0x00002600
+#	define RADEON_3D_DRAW_IMMD		0x00002900
+#	define RADEON_3D_CLEAR_ZMASK		0x00003200
+#	define RADEON_CNTL_HOSTDATA_BLT		0x00009400
+#	define RADEON_CNTL_PAINT_MULTI		0x00009A00
+#	define RADEON_CNTL_BITBLT_MULTI		0x00009B00
+
+#define RADEON_CP_PACKET_MASK		0xC0000000
+#define RADEON_CP_PACKET_COUNT_MASK	0x3fff0000
+#define RADEON_CP_PACKET0_REG_MASK	0x000007ff
+#define RADEON_CP_PACKET1_REG0_MASK	0x000007ff
+#define RADEON_CP_PACKET1_REG1_MASK	0x003ff800
+
+#define RADEON_VTX_Z_PRESENT			(1 << 31)
+
+#define RADEON_PRIM_TYPE_NONE			(0 << 0)
+#define RADEON_PRIM_TYPE_POINT			(1 << 0)
+#define RADEON_PRIM_TYPE_LINE			(2 << 0)
+#define RADEON_PRIM_TYPE_LINE_STRIP		(3 << 0)
+#define RADEON_PRIM_TYPE_TRI_LIST		(4 << 0)
+#define RADEON_PRIM_TYPE_TRI_FAN		(5 << 0)
+#define RADEON_PRIM_TYPE_TRI_STRIP		(6 << 0)
+#define RADEON_PRIM_TYPE_TRI_TYPE2		(7 << 0)
+#define RADEON_PRIM_TYPE_RECT_LIST		(8 << 0)
+#define RADEON_PRIM_TYPE_3VRT_POINT_LIST	(9 << 0)
+#define RADEON_PRIM_TYPE_3VRT_LINE_LIST		(10 << 0)
+#define RADEON_PRIM_WALK_IND			(1 << 4)
+#define RADEON_PRIM_WALK_LIST			(2 << 4)
+#define RADEON_PRIM_WALK_RING			(3 << 4)
+#define RADEON_COLOR_ORDER_BGRA			(0 << 6)
+#define RADEON_COLOR_ORDER_RGBA			(1 << 6)
+#define RADEON_MAOS_ENABLE			(1 << 7)
+#define RADEON_VTX_FMT_R128_MODE		(0 << 8)
+#define RADEON_VTX_FMT_RADEON_MODE		(1 << 8)
+#define RADEON_NUM_VERTICES_SHIFT		16
+
+#define RADEON_COLOR_FORMAT_CI8		2
+#define RADEON_COLOR_FORMAT_ARGB1555	3
+#define RADEON_COLOR_FORMAT_RGB565	4
+#define RADEON_COLOR_FORMAT_ARGB8888	6
+#define RADEON_COLOR_FORMAT_RGB332	7
+#define RADEON_COLOR_FORMAT_RGB8	9
+#define RADEON_COLOR_FORMAT_ARGB4444	15
+
+#define RADEON_TXF_8BPP_I		0
+#define RADEON_TXF_16BPP_AI88		1
+#define RADEON_TXF_8BPP_RGB332		2
+#define RADEON_TXF_16BPP_ARGB1555	3
+#define RADEON_TXF_16BPP_RGB565		4
+#define RADEON_TXF_16BPP_ARGB4444	5
+#define RADEON_TXF_32BPP_ARGB8888	6
+#define RADEON_TXF_32BPP_RGBA8888	7
+
+/* Constants */
+#define RADEON_MAX_USEC_TIMEOUT		100000	/* 100 ms */
+
+#define RADEON_LAST_FRAME_REG		RADEON_SCRATCH_REG0
+#define RADEON_LAST_DISPATCH_REG	RADEON_SCRATCH_REG1
+#define RADEON_LAST_CLEAR_REG		RADEON_SCRATCH_REG2
+#define RADEON_LAST_DISPATCH		1
+
+#define RADEON_MAX_VB_AGE		0x7fffffff
+#define RADEON_MAX_VB_VERTS		(0xffff)
+
+
+#define RADEON_BASE(reg)	((unsigned long)(dev_priv->mmio->handle))
+#define RADEON_ADDR(reg)	(RADEON_BASE(reg) + reg)
+
+#define RADEON_DEREF(reg)	*(__volatile__ u32 *)RADEON_ADDR(reg)
+#define RADEON_READ(reg)	RADEON_DEREF(reg)
+#define RADEON_WRITE(reg,val)	do { RADEON_DEREF(reg) = val; } while (0)
+
+#define RADEON_DEREF8(reg)	*(__volatile__ u8 *)RADEON_ADDR(reg)
+#define RADEON_READ8(reg)	RADEON_DEREF8(reg)
+#define RADEON_WRITE8(reg,val)	do { RADEON_DEREF8(reg) = val; } while (0)
+
+#define RADEON_WRITE_PLL(addr,val)                                            \
+do {                                                                          \
+	RADEON_WRITE8(RADEON_CLOCK_CNTL_INDEX,                                \
+		      ((addr) & 0x1f) | RADEON_PLL_WR_EN);                    \
+	RADEON_WRITE(RADEON_CLOCK_CNTL_DATA, (val));                          \
+} while (0)
+
+extern int RADEON_READ_PLL(drm_device_t *dev, int addr);
+
+
+
+#define CP_PACKET0( reg, n )						\
+	(RADEON_CP_PACKET0 | ((n) << 16) | ((reg) >> 2))
+#define CP_PACKET0_TABLE( reg, n )					\
+	(RADEON_CP_PACKET0 | RADEON_ONE_REG_WR | ((n) << 16) | ((reg) >> 2))
+#define CP_PACKET1( reg0, reg1 )					\
+	(RADEON_CP_PACKET1 | (((reg1) >> 2) << 15) | ((reg0) >> 2))
+#define CP_PACKET2()							\
+	(RADEON_CP_PACKET2)
+#define CP_PACKET3( pkt, n )						\
+	(RADEON_CP_PACKET3 | (pkt) | ((n) << 16))
+
+
+/* ================================================================
+ * Engine control helper macros
+ */
+
+#define RADEON_WAIT_UNTIL_2D_IDLE()					\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( (RADEON_WAIT_2D_IDLECLEAN |				\
+		   RADEON_WAIT_HOST_IDLECLEAN) );			\
+} while (0)
+
+#define RADEON_WAIT_UNTIL_3D_IDLE()					\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( (RADEON_WAIT_3D_IDLECLEAN |				\
+		   RADEON_WAIT_HOST_IDLECLEAN) );			\
+} while (0)
+
+#define RADEON_WAIT_UNTIL_IDLE()					\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( (RADEON_WAIT_2D_IDLECLEAN |				\
+		   RADEON_WAIT_3D_IDLECLEAN |				\
+		   RADEON_WAIT_HOST_IDLECLEAN) );			\
+} while (0)
+
+#define RADEON_WAIT_UNTIL_PAGE_FLIPPED()				\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
+	OUT_RING( RADEON_WAIT_CRTC_PFLIP );				\
+} while (0)
+
+#define RADEON_FLUSH_CACHE()						\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_RB2D_DSTCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB2D_DC_FLUSH );				\
+} while (0)
+
+#define RADEON_PURGE_CACHE()						\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_RB2D_DSTCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB2D_DC_FLUSH_ALL );				\
+} while (0)
+
+#define RADEON_FLUSH_ZCACHE()						\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_RB3D_ZCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB3D_ZC_FLUSH );				\
+} while (0)
+
+#define RADEON_PURGE_ZCACHE()						\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_RB3D_ZCACHE_CTLSTAT, 0 ) );	\
+	OUT_RING( RADEON_RB3D_ZC_FLUSH_ALL );				\
+} while (0)
+
+
+/* ================================================================
+ * Misc helper macros
+ */
+
+#define VB_AGE_CHECK_WITH_RET( dev_priv )				\
+do {									\
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;		\
+	if ( sarea_priv->last_dispatch >= RADEON_MAX_VB_AGE ) {		\
+		int __ret = radeon_do_cp_idle( dev_priv );		\
+		if ( __ret < 0 ) return __ret;				\
+		sarea_priv->last_dispatch = 0;				\
+		radeon_freelist_reset( dev );				\
+	}								\
+} while (0)
+
+#define RADEON_DISPATCH_AGE( age )					\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_LAST_DISPATCH_REG, 0 ) );		\
+	OUT_RING( age );						\
+} while (0)
+
+#define RADEON_FRAME_AGE( age )						\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_LAST_FRAME_REG, 0 ) );		\
+	OUT_RING( age );						\
+} while (0)
+
+#define RADEON_CLEAR_AGE( age )						\
+do {									\
+	OUT_RING( CP_PACKET0( RADEON_LAST_CLEAR_REG, 0 ) );		\
+	OUT_RING( age );						\
+} while (0)
+
+
+/* ================================================================
+ * Ring control
+ */
+
+#define radeon_flush_write_combine()	mb()
+
+
+#define RADEON_VERBOSE	0
+
+#define RING_LOCALS	int write; unsigned int mask; volatile u32 *ring;
+
+#define BEGIN_RING( n ) do {						\
+	if ( RADEON_VERBOSE ) {						\
+		DRM_INFO( "BEGIN_RING( %d ) in %s\n",			\
+			   n, __FUNCTION__ );				\
+	}								\
+	if ( dev_priv->ring.space < (n) * sizeof(u32) ) {		\
+		radeon_wait_ring( dev_priv, (n) * sizeof(u32) );	\
+	}								\
+	dev_priv->ring.space -= (n) * sizeof(u32);			\
+	ring = dev_priv->ring.start;					\
+	write = dev_priv->ring.tail;					\
+	mask = dev_priv->ring.tail_mask;				\
+} while (0)
+
+#define ADVANCE_RING() do {						\
+	if ( RADEON_VERBOSE ) {						\
+		DRM_INFO( "ADVANCE_RING() tail=0x%06x wr=0x%06x\n",	\
+			  write, dev_priv->ring.tail );			\
+	}								\
+	radeon_flush_write_combine();					\
+	dev_priv->ring.tail = write;					\
+	RADEON_WRITE( RADEON_CP_RB_WPTR, write );			\
+} while (0)
+
+#define OUT_RING( x ) do {						\
+	if ( RADEON_VERBOSE ) {						\
+		DRM_INFO( "   OUT_RING( 0x%08x ) at 0x%x\n",		\
+			   (unsigned int)(x), write );			\
+	}								\
+	ring[write++] = (x);						\
+	write &= mask;							\
+} while (0)
+
+#define RADEON_PERFORMANCE_BOXES	0
+
+#endif /* __RADEON_DRV_H__ */
diff -urN linux.orig/drivers/char/drm-4.0/radeon_state.c linux/drivers/char/drm-4.0/radeon_state.c
--- linux.orig/drivers/char/drm-4.0/radeon_state.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/radeon_state.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1447 @@
+/* radeon_state.c -- State support for Radeon -*- linux-c -*-
+ *
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "radeon_drv.h"
+#include "drm.h"
+#include <linux/delay.h>
+
+
+/* ================================================================
+ * CP hardware state programming functions
+ */
+
+static inline void radeon_emit_clip_rect( drm_radeon_private_t *dev_priv,
+					  drm_clip_rect_t *box )
+{
+	RING_LOCALS;
+
+	DRM_DEBUG( "   box:  x1=%d y1=%d  x2=%d y2=%d\n",
+		   box->x1, box->y1, box->x2, box->y2 );
+
+	BEGIN_RING( 4 );
+
+	OUT_RING( CP_PACKET0( RADEON_RE_TOP_LEFT, 0 ) );
+	OUT_RING( (box->y1 << 16) | box->x1 );
+
+	OUT_RING( CP_PACKET0( RADEON_RE_WIDTH_HEIGHT, 0 ) );
+	OUT_RING( ((box->y2 - 1) << 16) | (box->x2 - 1) );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_context( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 14 );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_MISC, 6 ) );
+	OUT_RING( ctx->pp_misc );
+	OUT_RING( ctx->pp_fog_color );
+	OUT_RING( ctx->re_solid_color );
+	OUT_RING( ctx->rb3d_blendcntl );
+	OUT_RING( ctx->rb3d_depthoffset );
+	OUT_RING( ctx->rb3d_depthpitch );
+	OUT_RING( ctx->rb3d_zstencilcntl );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_CNTL, 2 ) );
+	OUT_RING( ctx->pp_cntl );
+	OUT_RING( ctx->rb3d_cntl );
+	OUT_RING( ctx->rb3d_coloroffset );
+
+	OUT_RING( CP_PACKET0( RADEON_RB3D_COLORPITCH, 0 ) );
+	OUT_RING( ctx->rb3d_colorpitch );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_vertfmt( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 2 );
+
+	OUT_RING( CP_PACKET0( RADEON_SE_COORD_FMT, 0 ) );
+	OUT_RING( ctx->se_coord_fmt );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_line( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 5 );
+
+	OUT_RING( CP_PACKET0( RADEON_RE_LINE_PATTERN, 1 ) );
+	OUT_RING( ctx->re_line_pattern );
+	OUT_RING( ctx->re_line_state );
+
+	OUT_RING( CP_PACKET0( RADEON_SE_LINE_WIDTH, 0 ) );
+	OUT_RING( ctx->se_line_width );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_bumpmap( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 5 );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_LUM_MATRIX, 0 ) );
+	OUT_RING( ctx->pp_lum_matrix );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_ROT_MATRIX_0, 1 ) );
+	OUT_RING( ctx->pp_rot_matrix_0 );
+	OUT_RING( ctx->pp_rot_matrix_1 );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_masks( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 4 );
+
+	OUT_RING( CP_PACKET0( RADEON_RB3D_STENCILREFMASK, 2 ) );
+	OUT_RING( ctx->rb3d_stencilrefmask );
+	OUT_RING( ctx->rb3d_ropcntl );
+	OUT_RING( ctx->rb3d_planemask );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_viewport( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 7 );
+
+	OUT_RING( CP_PACKET0( RADEON_SE_VPORT_XSCALE, 5 ) );
+	OUT_RING( ctx->se_vport_xscale );
+	OUT_RING( ctx->se_vport_xoffset );
+	OUT_RING( ctx->se_vport_yscale );
+	OUT_RING( ctx->se_vport_yoffset );
+	OUT_RING( ctx->se_vport_zscale );
+	OUT_RING( ctx->se_vport_zoffset );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_setup( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 4 );
+
+	OUT_RING( CP_PACKET0( RADEON_SE_CNTL, 0 ) );
+	OUT_RING( ctx->se_cntl );
+	OUT_RING( CP_PACKET0( RADEON_SE_CNTL_STATUS, 0 ) );
+	OUT_RING( ctx->se_cntl_status );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_tcl( drm_radeon_private_t *dev_priv )
+{
+#ifdef TCL_ENABLE
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 29 );
+
+	OUT_RING( CP_PACKET0( RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED, 27 ) );
+	OUT_RING( ctx->se_tcl_material_emmissive.red );
+	OUT_RING( ctx->se_tcl_material_emmissive.green );
+	OUT_RING( ctx->se_tcl_material_emmissive.blue );
+	OUT_RING( ctx->se_tcl_material_emmissive.alpha );
+	OUT_RING( ctx->se_tcl_material_ambient.red );
+	OUT_RING( ctx->se_tcl_material_ambient.green );
+	OUT_RING( ctx->se_tcl_material_ambient.blue );
+	OUT_RING( ctx->se_tcl_material_ambient.alpha );
+	OUT_RING( ctx->se_tcl_material_diffuse.red );
+	OUT_RING( ctx->se_tcl_material_diffuse.green );
+	OUT_RING( ctx->se_tcl_material_diffuse.blue );
+	OUT_RING( ctx->se_tcl_material_diffuse.alpha );
+	OUT_RING( ctx->se_tcl_material_specular.red );
+	OUT_RING( ctx->se_tcl_material_specular.green );
+	OUT_RING( ctx->se_tcl_material_specular.blue );
+	OUT_RING( ctx->se_tcl_material_specular.alpha );
+	OUT_RING( ctx->se_tcl_shininess );
+	OUT_RING( ctx->se_tcl_output_vtx_fmt );
+	OUT_RING( ctx->se_tcl_output_vtx_sel );
+	OUT_RING( ctx->se_tcl_matrix_select_0 );
+	OUT_RING( ctx->se_tcl_matrix_select_1 );
+	OUT_RING( ctx->se_tcl_ucp_vert_blend_ctl );
+	OUT_RING( ctx->se_tcl_texture_proc_ctl );
+	OUT_RING( ctx->se_tcl_light_model_ctl );
+	for ( i = 0 ; i < 4 ; i++ ) {
+		OUT_RING( ctx->se_tcl_per_light_ctl[i] );
+	}
+
+	ADVANCE_RING();
+#else
+	DRM_ERROR( "TCL not enabled!\n" );
+#endif
+}
+
+static inline void radeon_emit_misc( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_context_regs_t *ctx = &sarea_priv->context_state;
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 2 );
+
+	OUT_RING( CP_PACKET0( RADEON_RE_MISC, 0 ) );
+	OUT_RING( ctx->re_misc );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_tex0( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_texture_regs_t *tex = &sarea_priv->tex_state[0];
+	RING_LOCALS;
+	DRM_DEBUG( "    %s: offset=0x%x\n", __FUNCTION__, tex->pp_txoffset );
+
+	BEGIN_RING( 9 );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_0, 5 ) );
+	OUT_RING( tex->pp_txfilter );
+	OUT_RING( tex->pp_txformat );
+	OUT_RING( tex->pp_txoffset );
+	OUT_RING( tex->pp_txcblend );
+	OUT_RING( tex->pp_txablend );
+	OUT_RING( tex->pp_tfactor );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_0, 0 ) );
+	OUT_RING( tex->pp_border_color );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_tex1( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_texture_regs_t *tex = &sarea_priv->tex_state[1];
+	RING_LOCALS;
+	DRM_DEBUG( "    %s: offset=0x%x\n", __FUNCTION__, tex->pp_txoffset );
+
+	BEGIN_RING( 9 );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_1, 5 ) );
+	OUT_RING( tex->pp_txfilter );
+	OUT_RING( tex->pp_txformat );
+	OUT_RING( tex->pp_txoffset );
+	OUT_RING( tex->pp_txcblend );
+	OUT_RING( tex->pp_txablend );
+	OUT_RING( tex->pp_tfactor );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_1, 0 ) );
+	OUT_RING( tex->pp_border_color );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_tex2( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_texture_regs_t *tex = &sarea_priv->tex_state[2];
+	RING_LOCALS;
+	DRM_DEBUG( "    %s\n", __FUNCTION__ );
+
+	BEGIN_RING( 9 );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_2, 5 ) );
+	OUT_RING( tex->pp_txfilter );
+	OUT_RING( tex->pp_txformat );
+	OUT_RING( tex->pp_txoffset );
+	OUT_RING( tex->pp_txcblend );
+	OUT_RING( tex->pp_txablend );
+	OUT_RING( tex->pp_tfactor );
+
+	OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_2, 0 ) );
+	OUT_RING( tex->pp_border_color );
+
+	ADVANCE_RING();
+}
+
+static inline void radeon_emit_state( drm_radeon_private_t *dev_priv )
+{
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	unsigned int dirty = sarea_priv->dirty;
+
+	DRM_DEBUG( "%s: dirty=0x%08x\n", __FUNCTION__, dirty );
+
+	if ( dirty & RADEON_UPLOAD_CONTEXT ) {
+		radeon_emit_context( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_CONTEXT;
+	}
+
+	if ( dirty & RADEON_UPLOAD_VERTFMT ) {
+		radeon_emit_vertfmt( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_VERTFMT;
+	}
+
+	if ( dirty & RADEON_UPLOAD_LINE ) {
+		radeon_emit_line( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_LINE;
+	}
+
+	if ( dirty & RADEON_UPLOAD_BUMPMAP ) {
+		radeon_emit_bumpmap( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_BUMPMAP;
+	}
+
+	if ( dirty & RADEON_UPLOAD_MASKS ) {
+		radeon_emit_masks( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_MASKS;
+	}
+
+	if ( dirty & RADEON_UPLOAD_VIEWPORT ) {
+		radeon_emit_viewport( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_VIEWPORT;
+	}
+
+	if ( dirty & RADEON_UPLOAD_SETUP ) {
+		radeon_emit_setup( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_SETUP;
+	}
+
+	if ( dirty & RADEON_UPLOAD_TCL ) {
+#ifdef TCL_ENABLE
+		radeon_emit_tcl( dev_priv );
+#endif
+		sarea_priv->dirty &= ~RADEON_UPLOAD_TCL;
+	}
+
+	if ( dirty & RADEON_UPLOAD_MISC ) {
+		radeon_emit_misc( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_MISC;
+	}
+
+	if ( dirty & RADEON_UPLOAD_TEX0 ) {
+		radeon_emit_tex0( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_TEX0;
+	}
+
+	if ( dirty & RADEON_UPLOAD_TEX1 ) {
+		radeon_emit_tex1( dev_priv );
+		sarea_priv->dirty &= ~RADEON_UPLOAD_TEX1;
+	}
+
+	if ( dirty & RADEON_UPLOAD_TEX2 ) {
+#if 0
+		radeon_emit_tex2( dev_priv );
+#endif
+		sarea_priv->dirty &= ~RADEON_UPLOAD_TEX2;
+	}
+
+	sarea_priv->dirty &= ~(RADEON_UPLOAD_TEX0IMAGES |
+			       RADEON_UPLOAD_TEX1IMAGES |
+			       RADEON_UPLOAD_TEX2IMAGES |
+			       RADEON_REQUIRE_QUIESCENCE);
+}
+
+
+#if RADEON_PERFORMANCE_BOXES
+/* ================================================================
+ * Performance monitoring functions
+ */
+
+static void radeon_clear_box( drm_radeon_private_t *dev_priv,
+			      int x, int y, int w, int h,
+			      int r, int g, int b )
+{
+	u32 pitch, offset;
+	u32 color;
+	RING_LOCALS;
+
+	switch ( dev_priv->color_fmt ) {
+	case RADEON_COLOR_FORMAT_RGB565:
+		color = (((r & 0xf8) << 8) |
+			 ((g & 0xfc) << 3) |
+			 ((b & 0xf8) >> 3));
+		break;
+	case RADEON_COLOR_FORMAT_ARGB8888:
+	default:
+		color = (((0xff) << 24) | (r << 16) | (g <<  8) | b);
+		break;
+	}
+
+	offset = dev_priv->back_offset;
+	pitch = dev_priv->back_pitch >> 3;
+
+	BEGIN_RING( 6 );
+
+	OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
+	OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+		  RADEON_GMC_BRUSH_SOLID_COLOR |
+		  (dev_priv->color_fmt << 8) |
+		  RADEON_GMC_SRC_DATATYPE_COLOR |
+		  RADEON_ROP3_P |
+		  RADEON_GMC_CLR_CMP_CNTL_DIS );
+
+	OUT_RING( (pitch << 22) | (offset >> 5) );
+	OUT_RING( color );
+
+	OUT_RING( (x << 16) | y );
+	OUT_RING( (w << 16) | h );
+
+	ADVANCE_RING();
+}
+
+static void radeon_cp_performance_boxes( drm_radeon_private_t *dev_priv )
+{
+	if ( atomic_read( &dev_priv->idle_count ) == 0 ) {
+		radeon_clear_box( dev_priv, 64, 4, 8, 8, 0, 255, 0 );
+	} else {
+		atomic_set( &dev_priv->idle_count, 0 );
+	}
+}
+
+#endif
+
+
+/* ================================================================
+ * CP command dispatch functions
+ */
+
+static void radeon_print_dirty( const char *msg, unsigned int flags )
+{
+	DRM_DEBUG( "%s: (0x%x) %s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
+		   msg,
+		   flags,
+		   (flags & RADEON_UPLOAD_CONTEXT)     ? "context, " : "",
+		   (flags & RADEON_UPLOAD_VERTFMT)     ? "vertfmt, " : "",
+		   (flags & RADEON_UPLOAD_LINE)        ? "line, " : "",
+		   (flags & RADEON_UPLOAD_BUMPMAP)     ? "bumpmap, " : "",
+		   (flags & RADEON_UPLOAD_MASKS)       ? "masks, " : "",
+		   (flags & RADEON_UPLOAD_VIEWPORT)    ? "viewport, " : "",
+		   (flags & RADEON_UPLOAD_SETUP)       ? "setup, " : "",
+		   (flags & RADEON_UPLOAD_TCL)         ? "tcl, " : "",
+		   (flags & RADEON_UPLOAD_MISC)        ? "misc, " : "",
+		   (flags & RADEON_UPLOAD_TEX0)        ? "tex0, " : "",
+		   (flags & RADEON_UPLOAD_TEX1)        ? "tex1, " : "",
+		   (flags & RADEON_UPLOAD_TEX2)        ? "tex2, " : "",
+		   (flags & RADEON_UPLOAD_CLIPRECTS)   ? "cliprects, " : "",
+		   (flags & RADEON_REQUIRE_QUIESCENCE) ? "quiescence, " : "" );
+}
+
+static void radeon_cp_dispatch_clear( drm_device_t *dev,
+				      drm_radeon_clear_t *clear )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	unsigned int flags = clear->flags;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+	if ( dev_priv->page_flipping && dev_priv->current_page == 1 ) {
+		unsigned int tmp = flags;
+
+		flags &= ~(RADEON_FRONT | RADEON_BACK);
+		if ( tmp & RADEON_FRONT ) flags |= RADEON_BACK;
+		if ( tmp & RADEON_BACK )  flags |= RADEON_FRONT;
+	}
+
+	for ( i = 0 ; i < nbox ; i++ ) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG( "dispatch clear %d,%d-%d,%d flags 0x%x\n",
+			   x, y, w, h, flags );
+
+		if ( flags & (RADEON_FRONT | RADEON_BACK) ) {
+			BEGIN_RING( 4 );
+
+			/* Ensure the 3D stream is idle before doing a
+			 * 2D fill to clear the front or back buffer.
+			 */
+			RADEON_WAIT_UNTIL_3D_IDLE();
+
+			OUT_RING( CP_PACKET0( RADEON_DP_WRITE_MASK, 0 ) );
+			OUT_RING( sarea_priv->context_state.rb3d_planemask );
+
+			ADVANCE_RING();
+
+			/* Make sure we restore the 3D state next time.
+			 */
+			dev_priv->sarea_priv->dirty |= (RADEON_UPLOAD_CONTEXT |
+							RADEON_UPLOAD_MASKS);
+		}
+
+		if ( flags & RADEON_FRONT ) {
+			BEGIN_RING( 6 );
+
+			OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
+			OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+				  RADEON_GMC_BRUSH_SOLID_COLOR |
+				  (dev_priv->color_fmt << 8) |
+				  RADEON_GMC_SRC_DATATYPE_COLOR |
+				  RADEON_ROP3_P |
+				  RADEON_GMC_CLR_CMP_CNTL_DIS );
+
+			OUT_RING( dev_priv->front_pitch_offset );
+			OUT_RING( clear->clear_color );
+
+			OUT_RING( (x << 16) | y );
+			OUT_RING( (w << 16) | h );
+
+			ADVANCE_RING();
+		}
+
+		if ( flags & RADEON_BACK ) {
+			BEGIN_RING( 6 );
+
+			OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
+			OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+				  RADEON_GMC_BRUSH_SOLID_COLOR |
+				  (dev_priv->color_fmt << 8) |
+				  RADEON_GMC_SRC_DATATYPE_COLOR |
+				  RADEON_ROP3_P |
+				  RADEON_GMC_CLR_CMP_CNTL_DIS );
+
+			OUT_RING( dev_priv->back_pitch_offset );
+			OUT_RING( clear->clear_color );
+
+			OUT_RING( (x << 16) | y );
+			OUT_RING( (w << 16) | h );
+
+			ADVANCE_RING();
+
+		}
+
+		if ( flags & RADEON_DEPTH ) {
+			drm_radeon_depth_clear_t *depth_clear =
+			   &dev_priv->depth_clear;
+
+			if ( sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS ) {
+				radeon_emit_state( dev_priv );
+			}
+
+			/* FIXME: Render a rectangle to clear the depth
+			 * buffer.  So much for those "fast Z clears"...
+			 */
+			BEGIN_RING( 23 );
+
+			RADEON_WAIT_UNTIL_2D_IDLE();
+
+			OUT_RING( CP_PACKET0( RADEON_PP_CNTL, 1 ) );
+			OUT_RING( 0x00000000 );
+			OUT_RING( depth_clear->rb3d_cntl );
+			OUT_RING( CP_PACKET0( RADEON_RB3D_ZSTENCILCNTL, 0 ) );
+			OUT_RING( depth_clear->rb3d_zstencilcntl );
+			OUT_RING( CP_PACKET0( RADEON_RB3D_PLANEMASK, 0 ) );
+			OUT_RING( 0x00000000 );
+			OUT_RING( CP_PACKET0( RADEON_SE_CNTL, 0 ) );
+			OUT_RING( depth_clear->se_cntl );
+
+			OUT_RING( CP_PACKET3( RADEON_3D_DRAW_IMMD, 10 ) );
+			OUT_RING( RADEON_VTX_Z_PRESENT );
+			OUT_RING( (RADEON_PRIM_TYPE_RECT_LIST |
+				   RADEON_PRIM_WALK_RING |
+				   RADEON_MAOS_ENABLE |
+				   RADEON_VTX_FMT_RADEON_MODE |
+				   (3 << RADEON_NUM_VERTICES_SHIFT)) );
+
+			OUT_RING( clear->rect.ui[CLEAR_X1] );
+			OUT_RING( clear->rect.ui[CLEAR_Y1] );
+			OUT_RING( clear->rect.ui[CLEAR_DEPTH] );
+
+			OUT_RING( clear->rect.ui[CLEAR_X1] );
+			OUT_RING( clear->rect.ui[CLEAR_Y2] );
+			OUT_RING( clear->rect.ui[CLEAR_DEPTH] );
+
+			OUT_RING( clear->rect.ui[CLEAR_X2] );
+			OUT_RING( clear->rect.ui[CLEAR_Y2] );
+			OUT_RING( clear->rect.ui[CLEAR_DEPTH] );
+
+			ADVANCE_RING();
+
+			/* Make sure we restore the 3D state next time.
+			 */
+			dev_priv->sarea_priv->dirty |= (RADEON_UPLOAD_CONTEXT |
+							RADEON_UPLOAD_SETUP |
+							RADEON_UPLOAD_MASKS);
+		}
+	}
+
+	/* Increment the clear counter.  The client-side 3D driver must
+	 * wait on this value before performing the clear ioctl.  We
+	 * need this because the card's so damned fast...
+	 */
+	dev_priv->sarea_priv->last_clear++;
+
+	BEGIN_RING( 4 );
+
+	RADEON_CLEAR_AGE( dev_priv->sarea_priv->last_clear );
+	RADEON_WAIT_UNTIL_IDLE();
+
+	ADVANCE_RING();
+}
+
+static void radeon_cp_dispatch_swap( drm_device_t *dev )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int nbox = sarea_priv->nbox;
+	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+#if RADEON_PERFORMANCE_BOXES
+	/* Do some trivial performance monitoring...
+	 */
+	radeon_cp_performance_boxes( dev_priv );
+#endif
+
+	/* Wait for the 3D stream to idle before dispatching the bitblt.
+	 * This will prevent data corruption between the two streams.
+	 */
+	BEGIN_RING( 2 );
+
+	RADEON_WAIT_UNTIL_3D_IDLE();
+
+	ADVANCE_RING();
+
+	for ( i = 0 ; i < nbox ; i++ ) {
+		int x = pbox[i].x1;
+		int y = pbox[i].y1;
+		int w = pbox[i].x2 - x;
+		int h = pbox[i].y2 - y;
+
+		DRM_DEBUG( "dispatch swap %d,%d-%d,%d\n",
+			   x, y, w, h );
+
+		BEGIN_RING( 7 );
+
+		OUT_RING( CP_PACKET3( RADEON_CNTL_BITBLT_MULTI, 5 ) );
+		OUT_RING( RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
+			  RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+			  RADEON_GMC_BRUSH_NONE |
+			  (dev_priv->color_fmt << 8) |
+			  RADEON_GMC_SRC_DATATYPE_COLOR |
+			  RADEON_ROP3_S |
+			  RADEON_DP_SRC_SOURCE_MEMORY |
+			  RADEON_GMC_CLR_CMP_CNTL_DIS |
+			  RADEON_GMC_WR_MSK_DIS );
+
+		OUT_RING( dev_priv->back_pitch_offset );
+		OUT_RING( dev_priv->front_pitch_offset );
+
+		OUT_RING( (x << 16) | y );
+		OUT_RING( (x << 16) | y );
+		OUT_RING( (w << 16) | h );
+
+		ADVANCE_RING();
+	}
+
+	/* Increment the frame counter.  The client-side 3D driver must
+	 * throttle the framerate by waiting for this value before
+	 * performing the swapbuffer ioctl.
+	 */
+	dev_priv->sarea_priv->last_frame++;
+
+	BEGIN_RING( 4 );
+
+	RADEON_FRAME_AGE( dev_priv->sarea_priv->last_frame );
+	RADEON_WAIT_UNTIL_2D_IDLE();
+
+	ADVANCE_RING();
+}
+
+static void radeon_cp_dispatch_flip( drm_device_t *dev )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	RING_LOCALS;
+	DRM_DEBUG( "%s: page=%d\n", __FUNCTION__, dev_priv->current_page );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+#if RADEON_PERFORMANCE_BOXES
+	/* Do some trivial performance monitoring...
+	 */
+	radeon_cp_performance_boxes( dev_priv );
+#endif
+
+	BEGIN_RING( 6 );
+
+	RADEON_WAIT_UNTIL_3D_IDLE();
+	RADEON_WAIT_UNTIL_PAGE_FLIPPED();
+
+	OUT_RING( CP_PACKET0( RADEON_CRTC_OFFSET, 0 ) );
+
+	if ( dev_priv->current_page == 0 ) {
+		OUT_RING( dev_priv->back_offset );
+		dev_priv->current_page = 1;
+	} else {
+		OUT_RING( dev_priv->front_offset );
+		dev_priv->current_page = 0;
+	}
+
+	ADVANCE_RING();
+
+	/* Increment the frame counter.  The client-side 3D driver must
+	 * throttle the framerate by waiting for this value before
+	 * performing the swapbuffer ioctl.
+	 */
+	dev_priv->sarea_priv->last_frame++;
+
+	BEGIN_RING( 2 );
+
+	RADEON_FRAME_AGE( dev_priv->sarea_priv->last_frame );
+
+	ADVANCE_RING();
+}
+
+static void radeon_cp_dispatch_vertex( drm_device_t *dev,
+				       drm_buf_t *buf )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int format = sarea_priv->vc_format;
+	int offset = dev_priv->agp_buffers_offset + buf->offset;
+	int size = buf->used;
+	int prim = buf_priv->prim;
+	int i = 0;
+	RING_LOCALS;
+	DRM_DEBUG( "%s: nbox=%d\n", __FUNCTION__, sarea_priv->nbox );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+	if ( 0 )
+		radeon_print_dirty( "dispatch_vertex", sarea_priv->dirty );
+
+	if ( buf->used ) {
+		buf_priv->dispatched = 1;
+
+		if ( sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS ) {
+			radeon_emit_state( dev_priv );
+		}
+
+		do {
+			/* Emit the next set of up to three cliprects */
+			if ( i < sarea_priv->nbox ) {
+				radeon_emit_clip_rect( dev_priv,
+						       &sarea_priv->boxes[i] );
+			}
+
+			/* Emit the vertex buffer rendering commands */
+			BEGIN_RING( 5 );
+
+			OUT_RING( CP_PACKET3( RADEON_3D_RNDR_GEN_INDX_PRIM, 3 ) );
+			OUT_RING( offset );
+			OUT_RING( size );
+			OUT_RING( format );
+			OUT_RING( prim | RADEON_PRIM_WALK_LIST |
+				  RADEON_COLOR_ORDER_RGBA |
+				  RADEON_VTX_FMT_RADEON_MODE |
+				  (size << RADEON_NUM_VERTICES_SHIFT) );
+
+			ADVANCE_RING();
+
+			i++;
+		} while ( i < sarea_priv->nbox );
+	}
+
+	if ( buf_priv->discard ) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the vertex buffer age */
+		BEGIN_RING( 2 );
+		RADEON_DISPATCH_AGE( buf_priv->age );
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		buf->used = 0;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+
+	sarea_priv->dirty &= ~RADEON_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+}
+
+
+static void radeon_cp_dispatch_indirect( drm_device_t *dev,
+					 drm_buf_t *buf,
+					 int start, int end )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
+	RING_LOCALS;
+	DRM_DEBUG( "indirect: buf=%d s=0x%x e=0x%x\n",
+		   buf->idx, start, end );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+	if ( start != end ) {
+		int offset = (dev_priv->agp_buffers_offset
+			      + buf->offset + start);
+		int dwords = (end - start + 3) / sizeof(u32);
+
+		/* Indirect buffer data must be an even number of
+		 * dwords, so if we've been given an odd number we must
+		 * pad the data with a Type-2 CP packet.
+		 */
+		if ( dwords & 1 ) {
+			u32 *data = (u32 *)
+				((char *)dev_priv->buffers->handle
+				 + buf->offset + start);
+			data[dwords++] = RADEON_CP_PACKET2;
+		}
+
+		buf_priv->dispatched = 1;
+
+		/* Fire off the indirect buffer */
+		BEGIN_RING( 3 );
+
+		OUT_RING( CP_PACKET0( RADEON_CP_IB_BASE, 1 ) );
+		OUT_RING( offset );
+		OUT_RING( dwords );
+
+		ADVANCE_RING();
+	}
+
+	if ( buf_priv->discard ) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the indirect buffer age */
+		BEGIN_RING( 2 );
+		RADEON_DISPATCH_AGE( buf_priv->age );
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		buf->used = 0;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+}
+
+static void radeon_cp_dispatch_indices( drm_device_t *dev,
+					drm_buf_t *buf,
+					int start, int end,
+					int count )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_buf_priv_t *buf_priv = buf->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	int format = sarea_priv->vc_format;
+	int offset = dev_priv->agp_buffers_offset;
+	int prim = buf_priv->prim;
+	u32 *data;
+	int dwords;
+	int i = 0;
+	RING_LOCALS;
+	DRM_DEBUG( "indices: s=%d e=%d c=%d\n", start, end, count );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+	if ( 0 )
+		radeon_print_dirty( "dispatch_indices", sarea_priv->dirty );
+
+	if ( start != end ) {
+		buf_priv->dispatched = 1;
+
+		if ( sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS ) {
+			radeon_emit_state( dev_priv );
+		}
+
+		dwords = (end - start + 3) / sizeof(u32);
+
+		data = (u32 *)((char *)dev_priv->buffers->handle
+			       + buf->offset + start);
+
+		data[0] = CP_PACKET3( RADEON_3D_RNDR_GEN_INDX_PRIM, dwords-2 );
+
+		data[1] = offset;
+		data[2] = RADEON_MAX_VB_VERTS;
+		data[3] = format;
+		data[4] = (prim | RADEON_PRIM_WALK_IND |
+			   RADEON_COLOR_ORDER_RGBA |
+			   RADEON_VTX_FMT_RADEON_MODE |
+			   (count << RADEON_NUM_VERTICES_SHIFT) );
+
+		if ( count & 0x1 ) {
+			data[dwords-1] &= 0x0000ffff;
+		}
+
+		do {
+			/* Emit the next set of up to three cliprects */
+			if ( i < sarea_priv->nbox ) {
+				radeon_emit_clip_rect( dev_priv,
+						       &sarea_priv->boxes[i] );
+			}
+
+			radeon_cp_dispatch_indirect( dev, buf, start, end );
+
+			i++;
+		} while ( i < sarea_priv->nbox );
+	}
+
+	if ( buf_priv->discard ) {
+		buf_priv->age = dev_priv->sarea_priv->last_dispatch;
+
+		/* Emit the vertex buffer age */
+		BEGIN_RING( 2 );
+		RADEON_DISPATCH_AGE( buf_priv->age );
+		ADVANCE_RING();
+
+		buf->pending = 1;
+		/* FIXME: Check dispatched field */
+		buf_priv->dispatched = 0;
+	}
+
+	dev_priv->sarea_priv->last_dispatch++;
+
+	sarea_priv->dirty &= ~RADEON_UPLOAD_CLIPRECTS;
+	sarea_priv->nbox = 0;
+}
+
+static int radeon_cp_dispatch_blit( drm_device_t *dev,
+				    drm_radeon_blit_t *blit )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_radeon_buf_priv_t *buf_priv;
+	u32 format;
+	u32 *data;
+	int dword_shift, dwords;
+	RING_LOCALS;
+	DRM_DEBUG( "blit: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n",
+		   blit->offset >> 10, blit->pitch, blit->format,
+		   blit->x, blit->y, blit->width, blit->height );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+	/* The compiler won't optimize away a division by a variable,
+	 * even if the only legal values are powers of two.  Thus, we'll
+	 * use a shift instead.
+	 */
+	switch ( blit->format ) {
+	case RADEON_TXF_32BPP_ARGB8888:
+	case RADEON_TXF_32BPP_RGBA8888:
+		format = RADEON_COLOR_FORMAT_ARGB8888;
+		dword_shift = 0;
+		break;
+	case RADEON_TXF_16BPP_AI88:
+	case RADEON_TXF_16BPP_ARGB1555:
+	case RADEON_TXF_16BPP_RGB565:
+	case RADEON_TXF_16BPP_ARGB4444:
+		format = RADEON_COLOR_FORMAT_RGB565;
+		dword_shift = 1;
+		break;
+	case RADEON_TXF_8BPP_I:
+	case RADEON_TXF_8BPP_RGB332:
+		format = RADEON_COLOR_FORMAT_CI8;
+		dword_shift = 2;
+		break;
+	default:
+		DRM_ERROR( "invalid blit format %d\n", blit->format );
+		return -EINVAL;
+	}
+
+	/* Flush the pixel cache.  This ensures no pixel data gets mixed
+	 * up with the texture data from the host data blit, otherwise
+	 * part of the texture image may be corrupted.
+	 */
+	BEGIN_RING( 4 );
+
+	RADEON_FLUSH_CACHE();
+	RADEON_WAIT_UNTIL_IDLE();
+
+	ADVANCE_RING();
+
+	/* Dispatch the indirect buffer.
+	 */
+	buf = dma->buflist[blit->idx];
+	buf_priv = buf->dev_private;
+
+	if ( buf->pid != current->pid ) {
+		DRM_ERROR( "process %d using buffer owned by %d\n",
+			   current->pid, buf->pid );
+		return -EINVAL;
+	}
+	if ( buf->pending ) {
+		DRM_ERROR( "sending pending buffer %d\n", blit->idx );
+		return -EINVAL;
+	}
+
+	buf_priv->discard = 1;
+
+	dwords = (blit->width * blit->height) >> dword_shift;
+	if ( !dwords ) dwords = 1;
+
+	data = (u32 *)((char *)dev_priv->buffers->handle + buf->offset);
+
+	data[0] = CP_PACKET3( RADEON_CNTL_HOSTDATA_BLT, dwords + 6 );
+	data[1] = (RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+		   RADEON_GMC_BRUSH_NONE |
+		   (format << 8) |
+		   RADEON_GMC_SRC_DATATYPE_COLOR |
+		   RADEON_ROP3_S |
+		   RADEON_DP_SRC_SOURCE_HOST_DATA |
+		   RADEON_GMC_CLR_CMP_CNTL_DIS |
+		   RADEON_GMC_WR_MSK_DIS);
+
+	data[2] = (blit->pitch << 22) | (blit->offset >> 10);
+	data[3] = 0xffffffff;
+	data[4] = 0xffffffff;
+	data[5] = (blit->y << 16) | blit->x;
+	data[6] = (blit->height << 16) | blit->width;
+	data[7] = dwords;
+
+	buf->used = (dwords + 8) * sizeof(u32);
+
+	radeon_cp_dispatch_indirect( dev, buf, 0, buf->used );
+
+	/* Flush the pixel cache after the blit completes.  This ensures
+	 * the texture data is written out to memory before rendering
+	 * continues.
+	 */
+	BEGIN_RING( 4 );
+
+	RADEON_FLUSH_CACHE();
+	RADEON_WAIT_UNTIL_2D_IDLE();
+
+	ADVANCE_RING();
+
+	return 0;
+}
+
+static void radeon_cp_dispatch_stipple( drm_device_t *dev, u32 *stipple )
+{
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	int i;
+	RING_LOCALS;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	radeon_update_ring_snapshot( dev_priv );
+
+	BEGIN_RING( 35 );
+
+	OUT_RING( CP_PACKET0( RADEON_RE_STIPPLE_ADDR, 0 ) );
+	OUT_RING( 0x00000000 );
+
+	OUT_RING( CP_PACKET0_TABLE( RADEON_RE_STIPPLE_DATA, 31 ) );
+	for ( i = 0 ; i < 32 ; i++ ) {
+		OUT_RING( stipple[i] );
+	}
+
+	ADVANCE_RING();
+}
+
+
+/* ================================================================
+ * IOCTL functions
+ */
+
+int radeon_cp_clear( struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_radeon_clear_t clear;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &clear, (drm_radeon_clear_t *) arg,
+			     sizeof(clear) ) )
+		return -EFAULT;
+
+	if ( sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS )
+		sarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;
+
+	radeon_cp_dispatch_clear( dev, &clear );
+
+	return 0;
+}
+
+int radeon_cp_swap( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_radeon_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	DRM_DEBUG( "%s\n", __FUNCTION__ );
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS )
+		sarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;
+
+	if ( !dev_priv->page_flipping ) {
+		radeon_cp_dispatch_swap( dev );
+		dev_priv->sarea_priv->dirty |= (RADEON_UPLOAD_CONTEXT |
+						RADEON_UPLOAD_MASKS);
+	} else {
+		radeon_cp_dispatch_flip( dev );
+	}
+
+	return 0;
+}
+
+int radeon_cp_vertex( struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_radeon_buf_priv_t *buf_priv;
+	drm_radeon_vertex_t vertex;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( !dev_priv || dev_priv->is_pci ) {
+		DRM_ERROR( "%s called with a PCI card\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &vertex, (drm_radeon_vertex_t *)arg,
+			     sizeof(vertex) ) )
+		return -EFAULT;
+
+	DRM_DEBUG( "%s: pid=%d index=%d count=%d discard=%d\n",
+		   __FUNCTION__, current->pid,
+		   vertex.idx, vertex.count, vertex.discard );
+
+	if ( vertex.idx < 0 || vertex.idx >= dma->buf_count ) {
+		DRM_ERROR( "buffer index %d (of %d max)\n",
+			   vertex.idx, dma->buf_count - 1 );
+		return -EINVAL;
+	}
+	if ( vertex.prim < 0 ||
+	     vertex.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST ) {
+		DRM_ERROR( "buffer prim %d\n", vertex.prim );
+		return -EINVAL;
+	}
+
+	VB_AGE_CHECK_WITH_RET( dev_priv );
+
+	buf = dma->buflist[vertex.idx];
+	buf_priv = buf->dev_private;
+
+	if ( buf->pid != current->pid ) {
+		DRM_ERROR( "process %d using buffer owned by %d\n",
+			   current->pid, buf->pid );
+		return -EINVAL;
+	}
+	if ( buf->pending ) {
+		DRM_ERROR( "sending pending buffer %d\n", vertex.idx );
+		return -EINVAL;
+	}
+
+	buf->used = vertex.count;
+	buf_priv->prim = vertex.prim;
+	buf_priv->discard = vertex.discard;
+
+	radeon_cp_dispatch_vertex( dev, buf );
+
+	return 0;
+}
+
+int radeon_cp_indices( struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_radeon_buf_priv_t *buf_priv;
+	drm_radeon_indices_t elts;
+	int count;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( !dev_priv || dev_priv->is_pci ) {
+		DRM_ERROR( "%s called with a PCI card\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &elts, (drm_radeon_indices_t *)arg,
+			     sizeof(elts) ) )
+		return -EFAULT;
+
+	DRM_DEBUG( "%s: pid=%d index=%d start=%d end=%d discard=%d\n",
+		   __FUNCTION__, current->pid,
+		   elts.idx, elts.start, elts.end, elts.discard );
+
+	if ( elts.idx < 0 || elts.idx >= dma->buf_count ) {
+		DRM_ERROR( "buffer index %d (of %d max)\n",
+			   elts.idx, dma->buf_count - 1 );
+		return -EINVAL;
+	}
+	if ( elts.prim < 0 ||
+	     elts.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST ) {
+		DRM_ERROR( "buffer prim %d\n", elts.prim );
+		return -EINVAL;
+	}
+
+	VB_AGE_CHECK_WITH_RET( dev_priv );
+
+	buf = dma->buflist[elts.idx];
+	buf_priv = buf->dev_private;
+
+	if ( buf->pid != current->pid ) {
+		DRM_ERROR( "process %d using buffer owned by %d\n",
+			   current->pid, buf->pid );
+		return -EINVAL;
+	}
+	if ( buf->pending ) {
+		DRM_ERROR( "sending pending buffer %d\n", elts.idx );
+		return -EINVAL;
+	}
+
+	count = (elts.end - elts.start) / sizeof(u16);
+	elts.start -= RADEON_INDEX_PRIM_OFFSET;
+
+	if ( elts.start & 0x7 ) {
+		DRM_ERROR( "misaligned buffer 0x%x\n", elts.start );
+		return -EINVAL;
+	}
+	if ( elts.start < buf->used ) {
+		DRM_ERROR( "no header 0x%x - 0x%x\n", elts.start, buf->used );
+		return -EINVAL;
+	}
+
+	buf->used = elts.end;
+	buf_priv->prim = elts.prim;
+	buf_priv->discard = elts.discard;
+
+	radeon_cp_dispatch_indices( dev, buf, elts.start, elts.end, count );
+
+	return 0;
+}
+
+int radeon_cp_blit( struct inode *inode, struct file *filp,
+		    unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_radeon_blit_t blit;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &blit, (drm_radeon_blit_t *)arg,
+			     sizeof(blit) ) )
+		return -EFAULT;
+
+	DRM_DEBUG( "%s: pid=%d index=%d\n",
+		   __FUNCTION__, current->pid, blit.idx );
+
+	if ( blit.idx < 0 || blit.idx > dma->buf_count ) {
+		DRM_ERROR( "sending %d buffers (of %d max)\n",
+			   blit.idx, dma->buf_count );
+		return -EINVAL;
+	}
+
+	VB_AGE_CHECK_WITH_RET( dev_priv );
+
+	return radeon_cp_dispatch_blit( dev, &blit );
+}
+
+int radeon_cp_stipple( struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_radeon_stipple_t stipple;
+	u32 mask[32];
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &stipple, (drm_radeon_stipple_t *)arg,
+			     sizeof(stipple) ) )
+		return -EFAULT;
+
+	if ( copy_from_user( &mask, stipple.mask,
+			     32 * sizeof(u32) ) )
+		return -EFAULT;
+
+	radeon_cp_dispatch_stipple( dev, mask );
+
+	return 0;
+}
+
+int radeon_cp_indirect( struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg )
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->dev;
+	drm_radeon_private_t *dev_priv = dev->dev_private;
+	drm_device_dma_t *dma = dev->dma;
+	drm_buf_t *buf;
+	drm_radeon_buf_priv_t *buf_priv;
+	drm_radeon_indirect_t indirect;
+	RING_LOCALS;
+
+	if ( !_DRM_LOCK_IS_HELD( dev->lock.hw_lock->lock ) ||
+	     dev->lock.pid != current->pid ) {
+		DRM_ERROR( "%s called without lock held\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+	if ( !dev_priv || dev_priv->is_pci ) {
+		DRM_ERROR( "%s called with a PCI card\n", __FUNCTION__ );
+		return -EINVAL;
+	}
+
+	if ( copy_from_user( &indirect, (drm_radeon_indirect_t *)arg,
+			     sizeof(indirect) ) )
+		return -EFAULT;
+
+	DRM_DEBUG( "indirect: idx=%d s=%d e=%d d=%d\n",
+		   indirect.idx, indirect.start,
+		   indirect.end, indirect.discard );
+
+	if ( indirect.idx < 0 || indirect.idx >= dma->buf_count ) {
+		DRM_ERROR( "buffer index %d (of %d max)\n",
+			   indirect.idx, dma->buf_count - 1 );
+		return -EINVAL;
+	}
+
+	buf = dma->buflist[indirect.idx];
+	buf_priv = buf->dev_private;
+
+	if ( buf->pid != current->pid ) {
+		DRM_ERROR( "process %d using buffer owned by %d\n",
+			   current->pid, buf->pid );
+		return -EINVAL;
+	}
+	if ( buf->pending ) {
+		DRM_ERROR( "sending pending buffer %d\n", indirect.idx );
+		return -EINVAL;
+	}
+
+	if ( indirect.start < buf->used ) {
+		DRM_ERROR( "reusing indirect: start=0x%x actual=0x%x\n",
+			   indirect.start, buf->used );
+		return -EINVAL;
+	}
+
+	VB_AGE_CHECK_WITH_RET( dev_priv );
+
+	buf->used = indirect.end;
+	buf_priv->discard = indirect.discard;
+
+	/* Wait for the 3D stream to idle before the indirect buffer
+	 * containing 2D acceleration commands is processed.
+	 */
+	BEGIN_RING( 2 );
+
+	RADEON_WAIT_UNTIL_3D_IDLE();
+
+	ADVANCE_RING();
+
+	/* Dispatch the indirect buffer full of commands from the
+	 * X server.  This is insecure and is thus only available to
+	 * privileged clients.
+	 */
+	radeon_cp_dispatch_indirect( dev, buf, indirect.start, indirect.end );
+
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/tdfx_context.c linux/drivers/char/drm-4.0/tdfx_context.c
--- linux.orig/drivers/char/drm-4.0/tdfx_context.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/tdfx_context.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,219 @@
+/* tdfx_context.c -- IOCTLs for tdfx contexts -*- linux-c -*-
+ * Created: Thu Oct  7 10:50:22 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *    Daryll Strauss <daryll@valinux.com>
+ * 
+ */
+
+#define __NO_VERSION__
+#include "drmP.h"
+#include "tdfx_drv.h"
+
+extern drm_ctx_t tdfx_res_ctx;
+
+static int tdfx_alloc_queue(drm_device_t *dev)
+{
+	return drm_ctxbitmap_next(dev);
+}
+
+int tdfx_context_switch(drm_device_t *dev, int old, int new)
+{
+        char        buf[64];
+
+        atomic_inc(&dev->total_ctx);
+
+        if (test_and_set_bit(0, &dev->context_flag)) {
+                DRM_ERROR("Reentering -- FIXME\n");
+                return -EBUSY;
+        }
+
+#if DRM_DMA_HISTOGRAM
+        dev->ctx_start = get_cycles();
+#endif
+        
+        DRM_DEBUG("Context switch from %d to %d\n", old, new);
+
+        if (new == dev->last_context) {
+                clear_bit(0, &dev->context_flag);
+                return 0;
+        }
+        
+        if (drm_flags & DRM_FLAG_NOCTX) {
+                tdfx_context_switch_complete(dev, new);
+        } else {
+                sprintf(buf, "C %d %d\n", old, new);
+                drm_write_string(dev, buf);
+        }
+        
+        return 0;
+}
+
+int tdfx_context_switch_complete(drm_device_t *dev, int new)
+{
+        dev->last_context = new;  /* PRE/POST: This is the _only_ writer. */
+        dev->last_switch  = jiffies;
+        
+        if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)) {
+                DRM_ERROR("Lock isn't held after context switch\n");
+        }
+
+				/* If a context switch is ever initiated
+                                   when the kernel holds the lock, release
+                                   that lock here. */
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.ctx[drm_histogram_slot(get_cycles()
+                                                      - dev->ctx_start)]);
+                   
+#endif
+        clear_bit(0, &dev->context_flag);
+        wake_up(&dev->context_wait);
+        
+        return 0;
+}
+
+
+int tdfx_resctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_ctx_res_t	res;
+	drm_ctx_t	ctx;
+	int		i;
+
+	DRM_DEBUG("%d\n", DRM_RESERVED_CONTEXTS);
+	if (copy_from_user(&res, (drm_ctx_res_t *)arg, sizeof(res)))
+		return -EFAULT;
+	if (res.count >= DRM_RESERVED_CONTEXTS) {
+		memset(&ctx, 0, sizeof(ctx));
+		for (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {
+			ctx.handle = i;
+			if (copy_to_user(&res.contexts[i],
+					 &i,
+					 sizeof(i)))
+				return -EFAULT;
+		}
+	}
+	res.count = DRM_RESERVED_CONTEXTS;
+	if (copy_to_user((drm_ctx_res_t *)arg, &res, sizeof(res)))
+		return -EFAULT;
+	return 0;
+}
+
+
+int tdfx_addctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	if ((ctx.handle = tdfx_alloc_queue(dev)) == DRM_KERNEL_CONTEXT) {
+				/* Skip kernel's context and get a new one. */
+		ctx.handle = tdfx_alloc_queue(dev);
+	}
+	DRM_DEBUG("%d\n", ctx.handle);
+	if (ctx.handle == -1) {
+		DRM_DEBUG("Not enough free contexts.\n");
+				/* Should this return -EBUSY instead? */
+		return -ENOMEM;
+	}
+   
+	if (copy_to_user((drm_ctx_t *)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int tdfx_modctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	if (ctx.flags==_DRM_CONTEXT_PRESERVED)
+		tdfx_res_ctx.handle=ctx.handle;
+	return 0;
+}
+
+int tdfx_getctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	drm_ctx_t ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t*)arg, sizeof(ctx)))
+		return -EFAULT;
+	/* This is 0, because we don't handle any context flags */
+	ctx.flags = 0;
+	if (copy_to_user((drm_ctx_t*)arg, &ctx, sizeof(ctx)))
+		return -EFAULT;
+	return 0;
+}
+
+int tdfx_switchctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	return tdfx_context_switch(dev, dev->last_context, ctx.handle);
+}
+
+int tdfx_newctx(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	tdfx_context_switch_complete(dev, ctx.handle);
+
+	return 0;
+}
+
+int tdfx_rmctx(struct inode *inode, struct file *filp, unsigned int cmd,
+	       unsigned long arg)
+{
+	drm_file_t      *priv   = filp->private_data;
+	drm_device_t    *dev    = priv->dev;
+	drm_ctx_t	ctx;
+
+	if (copy_from_user(&ctx, (drm_ctx_t *)arg, sizeof(ctx)))
+		return -EFAULT;
+	DRM_DEBUG("%d\n", ctx.handle);
+	drm_ctxbitmap_free(dev, ctx.handle);
+
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/tdfx_drv.c linux/drivers/char/drm-4.0/tdfx_drv.c
--- linux.orig/drivers/char/drm-4.0/tdfx_drv.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/tdfx_drv.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,696 @@
+/* tdfx_drv.c -- tdfx driver -*- linux-c -*-
+ * Created: Thu Oct  7 10:38:32 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *    Daryll Strauss <daryll@valinux.com>
+ *
+ */
+
+#include <linux/config.h>
+#include "drmP.h"
+#include "tdfx_drv.h"
+
+#define TDFX_NAME	 "tdfx"
+#define TDFX_DESC	 "3dfx Banshee/Voodoo3+"
+#define TDFX_DATE	 "20000928"
+#define TDFX_MAJOR	 1
+#define TDFX_MINOR	 0
+#define TDFX_PATCHLEVEL  0
+
+static drm_device_t	      tdfx_device;
+drm_ctx_t	              tdfx_res_ctx;
+
+static struct file_operations tdfx_fops = {
+#if LINUX_VERSION_CODE >= 0x020400
+				/* This started being used during 2.4.0-test */
+	owner:   THIS_MODULE,
+#endif
+	open:	 tdfx_open,
+	flush:	 drm_flush,
+	release: tdfx_release,
+	ioctl:	 tdfx_ioctl,
+	mmap:	 drm_mmap,
+	read:	 drm_read,
+	fasync:	 drm_fasync,
+	poll:	 drm_poll,
+};
+
+static struct miscdevice      tdfx_misc = {
+	minor: MISC_DYNAMIC_MINOR,
+	name:  TDFX_NAME,
+	fops:  &tdfx_fops,
+};
+
+static drm_ioctl_desc_t	      tdfx_ioctls[] = {
+	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]    = { tdfx_version,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)] = { drm_getunique,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]  = { drm_getmagic,	  0, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]  = { drm_irq_busid,	  0, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)] = { drm_setunique,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]	     = { drm_block,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]    = { drm_unblock,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)] = { drm_authmagic,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]    = { drm_addmap,	  1, 1 },
+
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]    = { tdfx_addctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]     = { tdfx_rmctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]    = { tdfx_modctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]    = { tdfx_getctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)] = { tdfx_switchctx,  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]    = { tdfx_newctx,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]    = { tdfx_resctx,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]   = { drm_adddraw,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]    = { drm_rmdraw,	  1, 1 },
+	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	     = { tdfx_lock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]     = { tdfx_unlock,	  1, 0 },
+	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]     = { drm_finish,	  1, 0 },
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)]   = {drm_agp_acquire, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)]   = {drm_agp_release, 1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)]    = {drm_agp_enable,  1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)]      = {drm_agp_info,    1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)]     = {drm_agp_alloc,   1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)]      = {drm_agp_free,    1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)]      = {drm_agp_unbind,  1, 1},
+	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)]    = {drm_agp_bind,    1, 1},
+#endif
+};
+#define TDFX_IOCTL_COUNT DRM_ARRAY_SIZE(tdfx_ioctls)
+
+#ifdef MODULE
+static char		      *tdfx = NULL;
+#endif
+
+MODULE_AUTHOR("VA Linux Systems, Inc.");
+MODULE_DESCRIPTION("tdfx");
+MODULE_PARM(tdfx, "s");
+
+#ifndef MODULE
+/* tdfx_options is called by the kernel to parse command-line options
+ * passed via the boot-loader (e.g., LILO).  It calls the insmod option
+ * routine, drm_parse_drm.
+ */
+
+static int __init tdfx_options(char *str)
+{
+	drm_parse_options(str);
+	return 1;
+}
+
+__setup("tdfx=", tdfx_options);
+#endif
+
+static int tdfx_setup(drm_device_t *dev)
+{
+	int i;
+
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
+	dev->buf_use	  = 0;
+	atomic_set(&dev->buf_alloc, 0);
+
+	atomic_set(&dev->total_open, 0);
+	atomic_set(&dev->total_close, 0);
+	atomic_set(&dev->total_ioctl, 0);
+	atomic_set(&dev->total_irq, 0);
+	atomic_set(&dev->total_ctx, 0);
+	atomic_set(&dev->total_locks, 0);
+	atomic_set(&dev->total_unlocks, 0);
+	atomic_set(&dev->total_contends, 0);
+	atomic_set(&dev->total_sleeps, 0);
+
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		dev->magiclist[i].head = NULL;
+		dev->magiclist[i].tail = NULL;
+	}
+	dev->maplist	    = NULL;
+	dev->map_count	    = 0;
+	dev->vmalist	    = NULL;
+	dev->lock.hw_lock   = NULL;
+	init_waitqueue_head(&dev->lock.lock_queue);
+	dev->queue_count    = 0;
+	dev->queue_reserved = 0;
+	dev->queue_slots    = 0;
+	dev->queuelist	    = NULL;
+	dev->irq	    = 0;
+	dev->context_flag   = 0;
+	dev->interrupt_flag = 0;
+	dev->dma            = 0;
+	dev->dma_flag	    = 0;
+	dev->last_context   = 0;
+	dev->last_switch    = 0;
+	dev->last_checked   = 0;
+	init_timer(&dev->timer);
+	init_waitqueue_head(&dev->context_wait);
+
+	dev->ctx_start	    = 0;
+	dev->lck_start	    = 0;
+
+	dev->buf_rp	  = dev->buf;
+	dev->buf_wp	  = dev->buf;
+	dev->buf_end	  = dev->buf + DRM_BSZ;
+	dev->buf_async	  = NULL;
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
+
+	tdfx_res_ctx.handle=-1;
+
+	DRM_DEBUG("\n");
+
+	/* The kernel's context could be created here, but is now created
+	   in drm_dma_enqueue.	This is more resource-efficient for
+	   hardware that does not do DMA, but may mean that
+	   drm_select_queue fails between the time the interrupt is
+	   initialized and the time the queues are initialized. */
+
+	return 0;
+}
+
+
+static int tdfx_takedown(drm_device_t *dev)
+{
+	int		  i;
+	drm_magic_entry_t *pt, *next;
+	drm_map_t	  *map;
+	drm_vma_entry_t	  *vma, *vma_next;
+
+	DRM_DEBUG("\n");
+
+	down(&dev->struct_sem);
+	del_timer(&dev->timer);
+
+	if (dev->devname) {
+		drm_free(dev->devname, strlen(dev->devname)+1, DRM_MEM_DRIVER);
+		dev->devname = NULL;
+	}
+
+	if (dev->unique) {
+		drm_free(dev->unique, strlen(dev->unique)+1, DRM_MEM_DRIVER);
+		dev->unique = NULL;
+		dev->unique_len = 0;
+	}
+				/* Clear pid list */
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
+		for (pt = dev->magiclist[i].head; pt; pt = next) {
+			next = pt->next;
+			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+		}
+		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
+	}
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+				/* Clear AGP information */
+	if (dev->agp) {
+		drm_agp_mem_t *temp;
+		drm_agp_mem_t *temp_next;
+
+		temp = dev->agp->memory;
+		while(temp != NULL) {
+			temp_next = temp->next;
+			drm_free_agp(temp->memory, temp->pages);
+			drm_free(temp, sizeof(*temp), DRM_MEM_AGPLISTS);
+			temp = temp_next;
+		}
+		if (dev->agp->acquired) _drm_agp_release();
+	}
+#endif
+				/* Clear vma list (only built for debugging) */
+	if (dev->vmalist) {
+		for (vma = dev->vmalist; vma; vma = vma_next) {
+			vma_next = vma->next;
+			drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		}
+		dev->vmalist = NULL;
+	}
+
+				/* Clear map area and mtrr information */
+	if (dev->maplist) {
+		for (i = 0; i < dev->map_count; i++) {
+			map = dev->maplist[i];
+			switch (map->type) {
+			case _DRM_REGISTERS:
+			case _DRM_FRAME_BUFFER:
+#ifdef CONFIG_MTRR
+				if (map->mtrr >= 0) {
+					int retcode;
+					retcode = mtrr_del(map->mtrr,
+							   map->offset,
+							   map->size);
+					DRM_DEBUG("mtrr_del = %d\n", retcode);
+				}
+#endif
+				drm_ioremapfree(map->handle, map->size, dev);
+				break;
+			case _DRM_SHM:
+				drm_free_pages((unsigned long)map->handle,
+					       drm_order(map->size)
+					       - PAGE_SHIFT,
+					       DRM_MEM_SAREA);
+				break;
+			case _DRM_AGP:
+				/* Do nothing here, because this is all
+                                   handled in the AGP/GART driver. */
+				break;
+			}
+			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		}
+		drm_free(dev->maplist,
+			 dev->map_count * sizeof(*dev->maplist),
+			 DRM_MEM_MAPS);
+		dev->maplist   = NULL;
+		dev->map_count = 0;
+	}
+
+	if (dev->lock.hw_lock) {
+		dev->lock.hw_lock    = NULL; /* SHM removed */
+		dev->lock.pid	     = 0;
+		wake_up_interruptible(&dev->lock.lock_queue);
+	}
+	up(&dev->struct_sem);
+
+	return 0;
+}
+
+/* tdfx_init is called via init_module at module load time, or via
+ * linux/init/main.c (this is not currently supported). */
+
+static int __init tdfx_init(void)
+{
+	int		      retcode;
+	drm_device_t	      *dev = &tdfx_device;
+
+	DRM_DEBUG("\n");
+
+	memset((void *)dev, 0, sizeof(*dev));
+	dev->count_lock	  = SPIN_LOCK_UNLOCKED;
+	sema_init(&dev->struct_sem, 1);
+
+#ifdef MODULE
+	drm_parse_options(tdfx);
+#endif
+
+	if ((retcode = misc_register(&tdfx_misc))) {
+		DRM_ERROR("Cannot register \"%s\"\n", TDFX_NAME);
+		return retcode;
+	}
+	dev->device = MKDEV(MISC_MAJOR, tdfx_misc.minor);
+	dev->name   = TDFX_NAME;
+
+	drm_mem_init();
+	drm_proc_init(dev);
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	dev->agp    = drm_agp_init();
+#endif
+	if((retcode = drm_ctxbitmap_init(dev))) {
+		DRM_ERROR("Cannot allocate memory for context bitmap.\n");
+		drm_proc_cleanup();
+		misc_deregister(&tdfx_misc);
+		tdfx_takedown(dev);
+		return retcode;
+	}
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d\n",
+		 TDFX_NAME,
+		 TDFX_MAJOR,
+		 TDFX_MINOR,
+		 TDFX_PATCHLEVEL,
+		 TDFX_DATE,
+		 tdfx_misc.minor);
+
+	return 0;
+}
+
+/* tdfx_cleanup is called via cleanup_module at module unload time. */
+
+static void __exit tdfx_cleanup(void)
+{
+	drm_device_t	      *dev = &tdfx_device;
+
+	DRM_DEBUG("\n");
+
+	drm_proc_cleanup();
+	if (misc_deregister(&tdfx_misc)) {
+		DRM_ERROR("Cannot unload module\n");
+	} else {
+		DRM_INFO("Module unloaded\n");
+	}
+	drm_ctxbitmap_cleanup(dev);
+	tdfx_takedown(dev);
+#if defined(CONFIG_AGP) || defined(CONFIG_AGP_MODULE)
+	if (dev->agp) {
+		drm_agp_uninit();
+		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
+		dev->agp = NULL;
+	}
+#endif
+}
+
+module_init(tdfx_init);
+module_exit(tdfx_cleanup);
+
+
+int tdfx_version(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	drm_version_t version;
+	int	      len;
+
+	if (copy_from_user(&version,
+			   (drm_version_t *)arg,
+			   sizeof(version)))
+		return -EFAULT;
+
+#define DRM_COPY(name,value)				     \
+	len = strlen(value);				     \
+	if (len > name##_len) len = name##_len;		     \
+	name##_len = strlen(value);			     \
+	if (len && name) {				     \
+		if (copy_to_user(name, value, len))	     \
+			return -EFAULT;			     \
+	}
+
+	version.version_major	   = TDFX_MAJOR;
+	version.version_minor	   = TDFX_MINOR;
+	version.version_patchlevel = TDFX_PATCHLEVEL;
+
+	DRM_COPY(version.name, TDFX_NAME);
+	DRM_COPY(version.date, TDFX_DATE);
+	DRM_COPY(version.desc, TDFX_DESC);
+
+	if (copy_to_user((drm_version_t *)arg,
+			 &version,
+			 sizeof(version)))
+		return -EFAULT;
+	return 0;
+}
+
+int tdfx_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t  *dev    = &tdfx_device;
+	int	      retcode = 0;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_open_helper(inode, filp, dev))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_INC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_open);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return tdfx_setup(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+	return retcode;
+}
+
+int tdfx_release(struct inode *inode, struct file *filp)
+{
+	drm_file_t    *priv   = filp->private_data;
+	drm_device_t  *dev;
+	int	      retcode = 0;
+
+	lock_kernel();
+	dev = priv->dev;
+
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
+	if (!(retcode = drm_release(inode, filp))) {
+#if LINUX_VERSION_CODE < 0x020333
+		MOD_DEC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+		atomic_inc(&dev->total_close);
+		spin_lock(&dev->count_lock);
+		if (!--dev->open_count) {
+			if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+				DRM_ERROR("Device busy: %d %d\n",
+					  atomic_read(&dev->ioctl_count),
+					  dev->blocked);
+				spin_unlock(&dev->count_lock);
+				unlock_kernel();
+				return -EBUSY;
+			}
+			spin_unlock(&dev->count_lock);
+			unlock_kernel();
+			return tdfx_takedown(dev);
+		}
+		spin_unlock(&dev->count_lock);
+	}
+
+	unlock_kernel();
+	return retcode;
+}
+
+/* tdfx_ioctl is called whenever a process performs an ioctl on /dev/drm. */
+
+int tdfx_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		unsigned long arg)
+{
+	int		 nr	 = DRM_IOCTL_NR(cmd);
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	int		 retcode = 0;
+	drm_ioctl_desc_t *ioctl;
+	drm_ioctl_t	 *func;
+
+	atomic_inc(&dev->ioctl_count);
+	atomic_inc(&dev->total_ioctl);
+	++priv->ioctl_count;
+
+	DRM_DEBUG("pid = %d, cmd = 0x%02x, nr = 0x%02x, dev 0x%x, auth = %d\n",
+		  current->pid, cmd, nr, dev->device, priv->authenticated);
+
+	if (nr >= TDFX_IOCTL_COUNT) {
+		retcode = -EINVAL;
+	} else {
+		ioctl	  = &tdfx_ioctls[nr];
+		func	  = ioctl->func;
+
+		if (!func) {
+			DRM_DEBUG("no function\n");
+			retcode = -EINVAL;
+		} else if ((ioctl->root_only && !capable(CAP_SYS_ADMIN))
+			    || (ioctl->auth_needed && !priv->authenticated)) {
+			retcode = -EACCES;
+		} else {
+			retcode = (func)(inode, filp, cmd, arg);
+		}
+	}
+
+	atomic_dec(&dev->ioctl_count);
+	return retcode;
+}
+
+int tdfx_lock(struct inode *inode, struct file *filp, unsigned int cmd,
+	      unsigned long arg)
+{
+        drm_file_t        *priv   = filp->private_data;
+        drm_device_t      *dev    = priv->dev;
+        DECLARE_WAITQUEUE(entry, current);
+        int               ret   = 0;
+        drm_lock_t        lock;
+#if DRM_DMA_HISTOGRAM
+        cycles_t          start;
+
+        dev->lck_start = start = get_cycles();
+#endif
+
+        if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+        if (lock.context == DRM_KERNEL_CONTEXT) {
+                DRM_ERROR("Process %d using kernel context %d\n",
+                          current->pid, lock.context);
+                return -EINVAL;
+        }
+
+        DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+                  lock.context, current->pid, dev->lock.hw_lock->lock,
+                  lock.flags);
+
+#if 0
+				/* dev->queue_count == 0 right now for
+                                   tdfx.  FIXME? */
+        if (lock.context < 0 || lock.context >= dev->queue_count)
+                return -EINVAL;
+#endif
+
+        if (!ret) {
+#if 0
+                if (_DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock)
+                    != lock.context) {
+                        long j = jiffies - dev->lock.lock_time;
+
+                        if (lock.context == tdfx_res_ctx.handle &&
+				j >= 0 && j < DRM_LOCK_SLICE) {
+                                /* Can't take lock if we just had it and
+                                   there is contention. */
+                                DRM_DEBUG("%d (pid %d) delayed j=%d dev=%d jiffies=%d\n",
+					lock.context, current->pid, j,
+					dev->lock.lock_time, jiffies);
+                                current->state = TASK_INTERRUPTIBLE;
+				current->policy |= SCHED_YIELD;
+                                schedule_timeout(DRM_LOCK_SLICE-j);
+				DRM_DEBUG("jiffies=%d\n", jiffies);
+                        }
+                }
+#endif
+                add_wait_queue(&dev->lock.lock_queue, &entry);
+                for (;;) {
+                        current->state = TASK_INTERRUPTIBLE;
+                        if (!dev->lock.hw_lock) {
+                                /* Device has been unregistered */
+                                ret = -EINTR;
+                                break;
+                        }
+                        if (drm_lock_take(&dev->lock.hw_lock->lock,
+                                          lock.context)) {
+                                dev->lock.pid       = current->pid;
+                                dev->lock.lock_time = jiffies;
+                                atomic_inc(&dev->total_locks);
+                                break;  /* Got lock */
+                        }
+
+                                /* Contention */
+                        atomic_inc(&dev->total_sleeps);
+#if 1
+			current->policy |= SCHED_YIELD;
+#endif
+                        schedule();
+                        if (signal_pending(current)) {
+                                ret = -ERESTARTSYS;
+                                break;
+                        }
+                }
+                current->state = TASK_RUNNING;
+                remove_wait_queue(&dev->lock.lock_queue, &entry);
+        }
+
+#if 0
+	if (!ret && dev->last_context != lock.context &&
+		lock.context != tdfx_res_ctx.handle &&
+		dev->last_context != tdfx_res_ctx.handle) {
+		add_wait_queue(&dev->context_wait, &entry);
+	        current->state = TASK_INTERRUPTIBLE;
+                /* PRE: dev->last_context != lock.context */
+	        tdfx_context_switch(dev, dev->last_context, lock.context);
+		/* POST: we will wait for the context
+                   switch and will dispatch on a later call
+                   when dev->last_context == lock.context
+                   NOTE WE HOLD THE LOCK THROUGHOUT THIS
+                   TIME! */
+		current->policy |= SCHED_YIELD;
+	        schedule();
+	        current->state = TASK_RUNNING;
+	        remove_wait_queue(&dev->context_wait, &entry);
+	        if (signal_pending(current)) {
+	                ret = -EINTR;
+	        } else if (dev->last_context != lock.context) {
+			DRM_ERROR("Context mismatch: %d %d\n",
+                        	dev->last_context, lock.context);
+	        }
+	}
+#endif
+
+        if (!ret) {
+		sigemptyset(&dev->sigmask);
+		sigaddset(&dev->sigmask, SIGSTOP);
+		sigaddset(&dev->sigmask, SIGTSTP);
+		sigaddset(&dev->sigmask, SIGTTIN);
+		sigaddset(&dev->sigmask, SIGTTOU);
+		dev->sigdata.context = lock.context;
+		dev->sigdata.lock    = dev->lock.hw_lock;
+		block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+
+                if (lock.flags & _DRM_LOCK_READY) {
+				/* Wait for space in DMA/FIFO */
+		}
+                if (lock.flags & _DRM_LOCK_QUIESCENT) {
+				/* Make hardware quiescent */
+#if 0
+                        tdfx_quiescent(dev);
+#endif
+		}
+        }
+
+#if LINUX_VERSION_CODE < 0x020400
+	if (lock.context != tdfx_res_ctx.handle) {
+		current->counter = 5;
+		current->priority = DEF_PRIORITY/4;
+	}
+#endif
+        DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
+
+#if DRM_DMA_HISTOGRAM
+        atomic_inc(&dev->histo.lacq[drm_histogram_slot(get_cycles() - start)]);
+#endif
+
+        return ret;
+}
+
+
+int tdfx_unlock(struct inode *inode, struct file *filp, unsigned int cmd,
+		 unsigned long arg)
+{
+	drm_file_t	  *priv	  = filp->private_data;
+	drm_device_t	  *dev	  = priv->dev;
+	drm_lock_t	  lock;
+
+	if (copy_from_user(&lock, (drm_lock_t *)arg, sizeof(lock)))
+		return -EFAULT;
+
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d frees lock (%d holds)\n",
+		  lock.context,
+		  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	atomic_inc(&dev->total_unlocks);
+	if (_DRM_LOCK_IS_CONT(dev->lock.hw_lock->lock))
+		atomic_inc(&dev->total_contends);
+	drm_lock_transfer(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
+				/* FIXME: Try to send data to card here */
+	if (!dev->context_flag) {
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
+		}
+	}
+
+#if LINUX_VERSION_CODE < 0x020400
+	if (lock.context != tdfx_res_ctx.handle) {
+		current->counter = 5;
+		current->priority = DEF_PRIORITY;
+	}
+#endif
+
+	unblock_all_signals();
+	return 0;
+}
diff -urN linux.orig/drivers/char/drm-4.0/tdfx_drv.h linux/drivers/char/drm-4.0/tdfx_drv.h
--- linux.orig/drivers/char/drm-4.0/tdfx_drv.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/tdfx_drv.h	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,67 @@
+/* tdfx_drv.h -- Private header for tdfx driver -*- linux-c -*-
+ * Created: Thu Oct  7 10:40:04 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *    Daryll Strauss <daryll@valinux.com>
+ * 
+ */
+
+#ifndef _TDFX_DRV_H_
+#define _TDFX_DRV_H_
+
+				/* tdfx_drv.c */
+extern int  tdfx_version(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg);
+extern int  tdfx_open(struct inode *inode, struct file *filp);
+extern int  tdfx_release(struct inode *inode, struct file *filp);
+extern int  tdfx_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  tdfx_lock(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+extern int  tdfx_unlock(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg);
+
+				/* tdfx_context.c */
+
+extern int  tdfx_resctx(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  tdfx_addctx(struct inode *inode, struct file *filp,
+		        unsigned int cmd, unsigned long arg);
+extern int  tdfx_modctx(struct inode *inode, struct file *filp,
+		        unsigned int cmd, unsigned long arg);
+extern int  tdfx_getctx(struct inode *inode, struct file *filp,
+		        unsigned int cmd, unsigned long arg);
+extern int  tdfx_switchctx(struct inode *inode, struct file *filp,
+			   unsigned int cmd, unsigned long arg);
+extern int  tdfx_newctx(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg);
+extern int  tdfx_rmctx(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg);
+
+extern int  tdfx_context_switch(drm_device_t *dev, int old, int new);
+extern int  tdfx_context_switch_complete(drm_device_t *dev, int new);
+#endif
diff -urN linux.orig/drivers/char/drm-4.0/vm.c linux/drivers/char/drm-4.0/vm.c
--- linux.orig/drivers/char/drm-4.0/vm.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/drm-4.0/vm.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,451 @@
+/* vm.c -- Memory mapping for DRM -*- linux-c -*-
+ * Created: Mon Jan  4 08:58:31 1999 by faith@precisioninsight.com
+ *
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * 
+ * Authors:
+ *    Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ */
+
+#define __NO_VERSION__
+#include <linux/config.h>
+#include "drmP.h"
+
+struct vm_operations_struct   drm_vm_ops = {
+	nopage:	 drm_vm_nopage,
+	open:	 drm_vm_open,
+	close:	 drm_vm_close,
+};
+
+struct vm_operations_struct   drm_vm_shm_ops = {
+	nopage:	 drm_vm_shm_nopage,
+	open:	 drm_vm_open,
+	close:	 drm_vm_close,
+};
+
+struct vm_operations_struct   drm_vm_shm_lock_ops = {
+	nopage:	 drm_vm_shm_nopage_lock,
+	open:	 drm_vm_open,
+	close:	 drm_vm_close,
+};
+
+struct vm_operations_struct   drm_vm_dma_ops = {
+	nopage:	 drm_vm_dma_nopage,
+	open:	 drm_vm_open,
+	close:	 drm_vm_close,
+};
+
+#if LINUX_VERSION_CODE < 0x020317
+unsigned long drm_vm_nopage(struct vm_area_struct *vma,
+			    unsigned long address,
+			    int write_access)
+#else
+				/* Return type changed in 2.3.23 */
+struct page *drm_vm_nopage(struct vm_area_struct *vma,
+			   unsigned long address,
+			   int write_access)
+#endif
+{
+#if defined(__ia64__)
+        drm_file_t *priv  = vma->vm_file->private_data;
+        drm_device_t *dev = priv->dev;
+        drm_map_t *map    = NULL;
+	int i;
+
+        /*
+         * Find the right map
+         */
+
+	if(!dev->agp->cant_use_aperture) goto vm_nopage_error;
+
+	for (i = 0; i < dev->map_count; i++) {
+                map = dev->maplist[i];
+                if (!map) continue;
+                if (map->offset == VM_OFFSET(vma)) break;
+        }
+
+        if (map && map->type == _DRM_AGP) {
+                unsigned long offset = address - vma->vm_start;
+                unsigned long baddr = VM_OFFSET(vma) + offset, paddr;
+                struct drm_agp_mem *agpmem;
+                struct page *page;
+
+                /*
+                 * It's AGP memory - find the real physical page to map
+                 */
+                for(agpmem = dev->agp->memory; agpmem; agpmem = agpmem->next) {
+                        if (agpmem->bound <= baddr &&
+                            agpmem->bound + agpmem->pages * PAGE_SIZE > baddr) 
+                                break;
+                }
+
+                if (!agpmem) goto vm_nopage_error;
+
+                /*
+                 * Get the page, inc the use count, and return it
+                 */
+                offset = (baddr - agpmem->bound) >> PAGE_SHIFT;
+
+		/*
+		 * This is bad.  What we really want to do here is unmask
+		 * the GART table entry held in the agp_memory structure.
+		 * There isn't a convenient way to call agp_bridge.unmask_
+		 * memory from here, so hard code it for now.
+		 */
+		paddr = (agpmem->memory->memory[offset] & 0xffffff) << 12;
+
+                page = virt_to_page(__va(paddr));
+                get_page(page);
+
+#if LINUX_VERSION_CODE < 0x020317
+		return page_address(page);
+#else
+		return page;
+#endif
+        }
+vm_nopage_error:
+#endif
+	return NOPAGE_SIGBUS;		/* Disallow mremap */
+}
+
+#if LINUX_VERSION_CODE < 0x020317
+unsigned long drm_vm_shm_nopage(struct vm_area_struct *vma,
+				unsigned long address,
+				int write_access)
+#else
+				/* Return type changed in 2.3.23 */
+struct page *drm_vm_shm_nopage(struct vm_area_struct *vma,
+			       unsigned long address,
+			       int write_access)
+#endif
+{
+#if LINUX_VERSION_CODE >= 0x020300
+	drm_map_t	 *map	 = (drm_map_t *)vma->vm_private_data;
+#else
+	drm_map_t	 *map	 = (drm_map_t *)vma->vm_pte;
+#endif
+	unsigned long	 physical;
+	unsigned long	 offset;
+
+	if (address > vma->vm_end) return NOPAGE_SIGBUS; /* Disallow mremap */
+	if (!map)    		   return NOPAGE_OOM;  /* Nothing allocated */
+
+	offset	 = address - vma->vm_start;
+	physical = (unsigned long)map->handle + offset;
+	atomic_inc(&virt_to_page(physical)->count); /* Dec. by kernel */
+
+	DRM_DEBUG("0x%08lx => 0x%08lx\n", address, physical);
+#if LINUX_VERSION_CODE < 0x020317
+	return physical;
+#else
+	return virt_to_page(physical);
+#endif
+}
+
+#if LINUX_VERSION_CODE < 0x020317
+unsigned long drm_vm_shm_nopage_lock(struct vm_area_struct *vma,
+				     unsigned long address,
+				     int write_access)
+#else
+				/* Return type changed in 2.3.23 */
+struct page *drm_vm_shm_nopage_lock(struct vm_area_struct *vma,
+				    unsigned long address,
+				    int write_access)
+#endif
+{
+	drm_file_t	 *priv	 = vma->vm_file->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	unsigned long	 physical;
+	unsigned long	 offset;
+	unsigned long	 page;
+
+	if (address > vma->vm_end) return NOPAGE_SIGBUS; /* Disallow mremap */
+	if (!dev->lock.hw_lock)    return NOPAGE_OOM;  /* Nothing allocated */
+
+	offset	 = address - vma->vm_start;
+	page	 = offset >> PAGE_SHIFT;
+	physical = (unsigned long)dev->lock.hw_lock + offset;
+	atomic_inc(&virt_to_page(physical)->count); /* Dec. by kernel */
+
+	DRM_DEBUG("0x%08lx (page %lu) => 0x%08lx\n", address, page, physical);
+#if LINUX_VERSION_CODE < 0x020317
+	return physical;
+#else
+	return virt_to_page(physical);
+#endif
+}
+
+#if LINUX_VERSION_CODE < 0x020317
+unsigned long drm_vm_dma_nopage(struct vm_area_struct *vma,
+				unsigned long address,
+				int write_access)
+#else
+				/* Return type changed in 2.3.23 */
+struct page *drm_vm_dma_nopage(struct vm_area_struct *vma,
+			       unsigned long address,
+			       int write_access)
+#endif
+{
+	drm_file_t	 *priv	 = vma->vm_file->private_data;
+	drm_device_t	 *dev	 = priv->dev;
+	drm_device_dma_t *dma	 = dev->dma;
+	unsigned long	 physical;
+	unsigned long	 offset;
+	unsigned long	 page;
+
+	if (!dma)		   return NOPAGE_SIGBUS; /* Error */
+	if (address > vma->vm_end) return NOPAGE_SIGBUS; /* Disallow mremap */
+	if (!dma->pagelist)	   return NOPAGE_OOM ; /* Nothing allocated */
+
+	offset	 = address - vma->vm_start; /* vm_[pg]off[set] should be 0 */
+	page	 = offset >> PAGE_SHIFT;
+	physical = dma->pagelist[page] + (offset & (~PAGE_MASK));
+	atomic_inc(&virt_to_page(physical)->count); /* Dec. by kernel */
+
+	DRM_DEBUG("0x%08lx (page %lu) => 0x%08lx\n", address, page, physical);
+#if LINUX_VERSION_CODE < 0x020317
+	return physical;
+#else
+	return virt_to_page(physical);
+#endif
+}
+
+void drm_vm_open(struct vm_area_struct *vma)
+{
+	drm_file_t	*priv	= vma->vm_file->private_data;
+	drm_device_t	*dev	= priv->dev;
+#if DRM_DEBUG_CODE
+	drm_vma_entry_t *vma_entry;
+#endif
+
+	DRM_DEBUG("0x%08lx,0x%08lx\n",
+		  vma->vm_start, vma->vm_end - vma->vm_start);
+	atomic_inc(&dev->vma_count);
+#if LINUX_VERSION_CODE < 0x020333
+				/* The map can exist after the fd is closed. */
+	MOD_INC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+
+
+#if DRM_DEBUG_CODE
+	vma_entry = drm_alloc(sizeof(*vma_entry), DRM_MEM_VMAS);
+	if (vma_entry) {
+		down(&dev->struct_sem);
+		vma_entry->vma	= vma;
+		vma_entry->next = dev->vmalist;
+		vma_entry->pid	= current->pid;
+		dev->vmalist	= vma_entry;
+		up(&dev->struct_sem);
+	}
+#endif
+}
+
+void drm_vm_close(struct vm_area_struct *vma)
+{
+	drm_file_t	*priv	= vma->vm_file->private_data;
+	drm_device_t	*dev	= priv->dev;
+#if DRM_DEBUG_CODE
+	drm_vma_entry_t *pt, *prev;
+#endif
+
+	DRM_DEBUG("0x%08lx,0x%08lx\n",
+		  vma->vm_start, vma->vm_end - vma->vm_start);
+#if LINUX_VERSION_CODE < 0x020333
+	MOD_DEC_USE_COUNT; /* Needed before Linux 2.3.51 */
+#endif
+	atomic_dec(&dev->vma_count);
+
+#if DRM_DEBUG_CODE
+	down(&dev->struct_sem);
+	for (pt = dev->vmalist, prev = NULL; pt; prev = pt, pt = pt->next) {
+		if (pt->vma == vma) {
+			if (prev) {
+				prev->next = pt->next;
+			} else {
+				dev->vmalist = pt->next;
+			}
+			drm_free(pt, sizeof(*pt), DRM_MEM_VMAS);
+			break;
+		}
+	}
+	up(&dev->struct_sem);
+#endif
+}
+
+int drm_mmap_dma(struct file *filp, struct vm_area_struct *vma)
+{
+	drm_file_t	 *priv	 = filp->private_data;
+	drm_device_t	 *dev;
+	drm_device_dma_t *dma;
+	unsigned long	 length	 = vma->vm_end - vma->vm_start;
+	
+	lock_kernel();
+	dev	 = priv->dev;
+	dma	 = dev->dma;
+	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
+		  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
+
+				/* Length must match exact page count */
+	if (!dma || (length >> PAGE_SHIFT) != dma->page_count) {
+		unlock_kernel();
+		return -EINVAL;
+	}
+	unlock_kernel();
+
+	vma->vm_ops   = &drm_vm_dma_ops;
+	vma->vm_flags |= VM_LOCKED | VM_SHM; /* Don't swap */
+	
+#if LINUX_VERSION_CODE < 0x020203 /* KERNEL_VERSION(2,2,3) */
+				/* In Linux 2.2.3 and above, this is
+				   handled in do_mmap() in mm/mmap.c. */
+	++filp->f_count;
+#endif
+	vma->vm_file  =	 filp;	/* Needed for drm_vm_open() */
+	drm_vm_open(vma);
+	return 0;
+}
+
+int drm_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	drm_file_t	*priv	= filp->private_data;
+	drm_device_t	*dev	= priv->dev;
+	drm_map_t	*map	= NULL;
+	unsigned long	off;
+	int		i;
+	
+	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
+		  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
+
+	if (!VM_OFFSET(vma)) return drm_mmap_dma(filp, vma);
+
+				/* A sequential search of a linked list is
+				   fine here because: 1) there will only be
+				   about 5-10 entries in the list and, 2) a
+				   DRI client only has to do this mapping
+				   once, so it doesn't have to be optimized
+				   for performance, even if the list was a
+				   bit longer. */
+	for (i = 0; i < dev->map_count; i++) {
+		map = dev->maplist[i];
+		off = map->offset ^ VM_OFFSET(vma);
+#ifdef	__ia64__
+		/*
+		 * Ignore region bits, makes IA32 processes happier
+		 * XXX This is a hack...
+		 */
+		off &= ~0xe000000000000000;
+#endif	// __ia64__
+		if (off == 0)
+			break;
+	}
+	
+	if (i >= dev->map_count) return -EINVAL;
+	if (!map || ((map->flags&_DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))
+		return -EPERM;
+
+				/* Check for valid size. */
+	if (map->size != vma->vm_end - vma->vm_start) return -EINVAL;
+	
+	if (!capable(CAP_SYS_ADMIN) && (map->flags & _DRM_READ_ONLY)) {
+		vma->vm_flags &= VM_MAYWRITE;
+#if defined(__i386__)
+		pgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;
+#else
+				/* Ye gads this is ugly.  With more thought
+                                   we could move this up higher and use
+                                   `protection_map' instead.  */
+		vma->vm_page_prot = __pgprot(pte_val(pte_wrprotect(
+			__pte(pgprot_val(vma->vm_page_prot)))));
+#endif
+	}
+
+	switch (map->type) {
+	case _DRM_AGP:
+#if defined(__ia64__)
+                /*
+                 * On ia64 we can't talk to bus dma address from
+                 * the CPU, so for memory of type DRM_AGP, we'll deal with
+                 * sorting out the real physical pages and mappings in
+                 * in nopage()
+                 */
+                vma->vm_ops = &drm_vm_ops;
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+                break;
+#endif
+	case _DRM_FRAME_BUFFER:
+	case _DRM_REGISTERS:
+		if (VM_OFFSET(vma) >= __pa(high_memory)) {
+#if defined(__i386__)
+			if (boot_cpu_data.x86 > 3 && map->type != _DRM_AGP) {
+				pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
+				pgprot_val(vma->vm_page_prot) &= ~_PAGE_PWT;
+			}
+#elif defined(__ia64__)
+			if (map->type != _DRM_AGP)
+				vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+#endif
+			vma->vm_flags |= VM_IO;	/* not in core dump */
+		}
+		if (remap_page_range(vma->vm_start,
+				     VM_OFFSET(vma),
+				     vma->vm_end - vma->vm_start,
+				     vma->vm_page_prot))
+				return -EAGAIN;
+		DRM_DEBUG("   Type = %d; start = 0x%lx, end = 0x%lx,"
+			  " offset = 0x%lx\n",
+			  map->type,
+			  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
+		vma->vm_ops = &drm_vm_ops;
+		break;
+	case _DRM_SHM:
+		if (map->flags & _DRM_CONTAINS_LOCK)
+			vma->vm_ops = &drm_vm_shm_lock_ops;
+		else {
+			vma->vm_ops = &drm_vm_shm_ops;
+#if LINUX_VERSION_CODE >= 0x020300
+			vma->vm_private_data = (void *)map;
+#else
+			vma->vm_pte = (unsigned long)map;
+#endif
+		}
+
+				/* Don't let this area swap.  Change when
+				   DRM_KERNEL advisory is supported. */
+		vma->vm_flags |= VM_LOCKED;
+		break;
+	default:
+		return -EINVAL;	/* This should never happen. */
+	}
+	vma->vm_flags |= VM_LOCKED | VM_SHM; /* Don't swap */
+
+#if LINUX_VERSION_CODE < 0x020203 /* KERNEL_VERSION(2,2,3) */
+				/* In Linux 2.2.3 and above, this is
+				   handled in do_mmap() in mm/mmap.c. */
+	++filp->f_count;
+#endif
+	vma->vm_file  =	 filp;	/* Needed for drm_vm_open() */
+	drm_vm_open(vma);
+	return 0;
+}
diff -urN linux.orig/drivers/char/efirtc.c linux/drivers/char/efirtc.c
--- linux.orig/drivers/char/efirtc.c	Mon Sep 18 15:57:01 2000
+++ linux/drivers/char/efirtc.c	Mon Dec 17 20:27:40 2001
@@ -40,7 +40,7 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
-#define EFI_RTC_VERSION		"0.2"
+#define EFI_RTC_VERSION		"0.3"
 
 #define EFI_ISDST (EFI_TIME_ADJUST_DAYLIGHT|EFI_TIME_IN_DAYLIGHT)
 /*
@@ -315,56 +315,45 @@
 	spin_unlock_irqrestore(&efi_rtc_lock,flags);
 
 	p += sprintf(p,
-		     "Time      :\n"
-		     "Year      : %u\n"
-		     "Month     : %u\n"
-		     "Day       : %u\n"
-		     "Hour      : %u\n"
-		     "Minute    : %u\n"
-		     "Second    : %u\n"
-		     "Nanosecond: %u\n"
-		     "Daylight  : %u\n",
-		     eft.year, eft.month, eft.day, eft.hour, eft.minute,
-		     eft.second, eft.nanosecond, eft.daylight);
+		     "Time          : %u:%u:%u.%09u\n"
+		     "Date          : %u-%u-%u\n"
+		     "Daylight      : %u\n",
+		     eft.hour, eft.minute, eft.second, eft.nanosecond, 
+		     eft.year, eft.month, eft.day,
+		     eft.daylight);
 
 	if ( eft.timezone == EFI_UNSPECIFIED_TIMEZONE)
-		p += sprintf(p, "Timezone  : unspecified\n");
+		p += sprintf(p, "Timezone       : unspecified\n");
 	else
 		/* XXX fixme: convert to string? */
-		p += sprintf(p, "Timezone  : %u\n", eft.timezone);
+		p += sprintf(p, "Timezone       : %u\n", eft.timezone);
 		
 
 	p += sprintf(p,
-		     "\nWakeup Alm:\n"
-		     "Enabled   : %s\n"
-		     "Pending   : %s\n"
-		     "Year      : %u\n"
-		     "Month     : %u\n"
-		     "Day       : %u\n"
-		     "Hour      : %u\n"
-		     "Minute    : %u\n"
-		     "Second    : %u\n"
-		     "Nanosecond: %u\n"
-		     "Daylight  : %u\n",
-		     enabled == 1 ? "Yes" : "No",
-		     pending == 1 ? "Yes" : "No",
-		     alm.year, alm.month, alm.day, alm.hour, alm.minute,
-		     alm.second, alm.nanosecond, alm.daylight);
+		     "Alarm Time     : %u:%u:%u.%09u\n"
+		     "Alarm Date     : %u-%u-%u\n"
+		     "Alarm Daylight : %u\n"
+		     "Enabled        : %s\n"
+		     "Pending        : %s\n",
+		     alm.hour, alm.minute, alm.second, alm.nanosecond, 
+		     alm.year, alm.month, alm.day, 
+		     alm.daylight,
+		     enabled == 1 ? "yes" : "no",
+		     pending == 1 ? "yes" : "no");
 
 	if ( eft.timezone == EFI_UNSPECIFIED_TIMEZONE)
-		p += sprintf(p, "Timezone  : unspecified\n");
+		p += sprintf(p, "Timezone       : unspecified\n");
 	else
 		/* XXX fixme: convert to string? */
-		p += sprintf(p, "Timezone  : %u\n", eft.timezone);
+		p += sprintf(p, "Timezone       : %u\n", alm.timezone);
 
 	/*
 	 * now prints the capabilities
 	 */
 	p += sprintf(p,
-		     "\nClock Cap :\n"
-		     "Resolution: %u\n"
-		     "Accuracy  : %u\n"
-		     "SetstoZero: %u\n",
+		     "Resolution     : %u\n"
+		     "Accuracy       : %u\n"
+		     "SetstoZero     : %u\n",
 		      cap.resolution, cap.accuracy, cap.sets_to_zero);
 
 	return  p - buf;
@@ -390,7 +379,7 @@
 
 	misc_register(&efi_rtc_dev);
 
-	create_proc_read_entry ("efirtc", 0, NULL, efi_rtc_read_proc, NULL);
+	create_proc_read_entry ("driver/efirtc", 0, NULL, efi_rtc_read_proc, NULL);
 
 	return 0;
 }
diff -urN linux.orig/drivers/char/mem.c linux/drivers/char/mem.c
--- linux.orig/drivers/char/mem.c	Sat Jul 28 13:37:23 2001
+++ linux/drivers/char/mem.c	Mon Dec 17 20:27:40 2001
@@ -196,9 +196,13 @@
 	 * through a file pointer that was marked O_SYNC will be
 	 * done non-cached.
 	 */
-	if (noncached_address(offset) || (file->f_flags & O_SYNC))
+	if (noncached_address(offset) || (file->f_flags & O_SYNC)
+	    || (vma->vm_flags & VM_NONCACHED))
 		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
+	if (vma->vm_flags & VM_WRITECOMBINED)
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
 	/* Don't try to swap out physical pages.. */
 	vma->vm_flags |= VM_RESERVED;
 
@@ -475,13 +479,15 @@
 	switch (orig) {
 		case 0:
 			file->f_pos = offset;
-			return file->f_pos;
+			break;
 		case 1:
 			file->f_pos += offset;
-			return file->f_pos;
+			break;
 		default:
 			return -EINVAL;
 	}
+	force_successful_syscall_return();
+	return file->f_pos;
 }
 
 static int open_port(struct inode * inode, struct file * filp)
diff -urN linux.orig/drivers/char/pc_keyb.c linux/drivers/char/pc_keyb.c
--- linux.orig/drivers/char/pc_keyb.c	Tue Aug 14 16:49:50 2001
+++ linux/drivers/char/pc_keyb.c	Mon Dec 17 20:27:40 2001
@@ -723,6 +723,13 @@
 {
 	int status;
 
+#ifdef __ia64__
+	if (kbd_read_status() == 0xff && kbd_read_input() == 0xff) {
+		kbd_exists = 0;
+		return "No keyboard controller preset";
+	}
+#endif
+
 	/*
 	 * Test the keyboard interface.
 	 * This seems to be the only way to get it going.
@@ -829,6 +836,10 @@
 		char *msg = initialize_kbd();
 		if (msg)
 			printk(KERN_WARNING "initialize_kbd: %s\n", msg);
+#ifdef __ia64__
+		if (!kbd_exists)
+			return;
+#endif
 	}
 
 #if defined CONFIG_PSMOUSE
diff -urN linux.orig/drivers/char/serial.c linux/drivers/char/serial.c
--- linux.orig/drivers/char/serial.c	Mon Aug 13 17:37:33 2001
+++ linux/drivers/char/serial.c	Mon Dec 17 20:27:40 2001
@@ -85,6 +85,11 @@
  * SERIAL_PARANOIA_CHECK
  * 		Check the magic number for the async_structure where
  * 		ever possible.
+ *
+ * CONFIG_SERIAL_ACPI
+ *		Enable support for serial console port and serial 
+ *		debug port as defined by the SPCR and DBGP tables in 
+ *		ACPI 2.0.
  */
 
 #include <linux/config.h>
@@ -113,6 +118,10 @@
 #endif
 #endif
 
+#ifdef CONFIG_SERIAL_ACPI
+#define ENABLE_SERIAL_ACPI
+#endif
+
 #if defined(CONFIG_ISAPNP)|| (defined(CONFIG_ISAPNP_MODULE) && defined(MODULE))
 #ifndef ENABLE_SERIAL_PNP
 #define ENABLE_SERIAL_PNP
@@ -2353,7 +2362,7 @@
 
 	autoconfig(info->state);
 	if ((info->state->flags & ASYNC_AUTO_IRQ) &&
-	    (info->state->port != 0) &&
+	    (info->state->port != 0  || info->state->iomem_base != 0) &&
 	    (info->state->type != PORT_UNKNOWN)) {
 		irq = detect_uart_irq(info->state);
 		if (irq > 0)
@@ -3382,6 +3391,10 @@
        " ISAPNP"
 #define SERIAL_OPT
 #endif
+#ifdef ENABLE_SERIAL_ACPI
+       " SERIAL_ACPI"
+#define SERIAL_OPT
+#endif
 #ifdef SERIAL_OPT
        " enabled\n";
 #else
@@ -5445,7 +5458,17 @@
 	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
 		state->magic = SSTATE_MAGIC;
 		state->line = i;
+#ifdef CONFIG_IA64_HP_PROTO
+		{
+			extern int acpi_autoconf_flag;
+			if (acpi_autoconf_flag)
+				state->type = PORT_UNKNOWN;
+			else
+				state->irq = 0;
+		}
+#else
 		state->type = PORT_UNKNOWN;
+#endif
 		state->custom_divisor = 0;
 		state->close_delay = 5*HZ/10;
 		state->closing_wait = 30*HZ;
@@ -5473,13 +5496,22 @@
 			continue;
 		if (   (state->flags & ASYNC_BOOT_AUTOCONF)
 		    && (state->flags & ASYNC_AUTO_IRQ)
-		    && (state->port != 0))
+		    && (state->port != 0 || state->iomem_base != 0))
 			state->irq = detect_uart_irq(state);
-		printk(KERN_INFO "ttyS%02d%s at 0x%04lx (irq = %d) is a %s\n",
-		       state->line + SERIAL_DEV_OFFSET,
-		       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
-		       state->port, state->irq,
-		       uart_config[state->type].name);
+		if (state->io_type == SERIAL_IO_MEM) {
+			printk(KERN_INFO"ttyS%02d%s at 0x%px (irq = %d) is a %s\n",
+	 		       state->line + SERIAL_DEV_OFFSET,
+			       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
+			       state->iomem_base, state->irq,
+			       uart_config[state->type].name);
+		}
+		else {
+			printk(KERN_INFO "ttyS%02d%s at 0x%04lx (irq = %d) is a %s\n",
+	 		       state->line + SERIAL_DEV_OFFSET,
+			       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
+			       state->port, state->irq,
+			       uart_config[state->type].name);
+		}
 		tty_register_devfs(&serial_driver, 0,
 				   serial_driver.minor_start + state->line);
 		tty_register_devfs(&callout_driver, 0,
diff -urN linux.orig/drivers/char/simserial.c linux/drivers/char/simserial.c
--- linux.orig/drivers/char/simserial.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/simserial.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1,1104 @@
+/*
+ * Simulated Serial Driver (fake serial)
+ *
+ * This driver is mostly used for bringup purposes and will go away.
+ * It has a strong dependency on the system console. All outputs
+ * are rerouted to the same facility as the one used by printk which, in our
+ * case means sys_sim.c console (goes via the simulator). The code hereafter
+ * is completely leveraged from the serial.c driver.
+ *
+ * Copyright (C) 1999-2000 Hewlett-Packard Co
+ * Copyright (C) 1999 Stephane Eranian <eranian@hpl.hp.com>
+ * Copyright (C) 2000 David Mosberger-Tang <davidm@hpl.hp.com>
+ *
+ * 02/04/00 D. Mosberger	Merged in serial.c bug fixes in rs_close().
+ * 02/25/00 D. Mosberger	Synced up with 2.3.99pre-5 version of serial.c.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/malloc.h>
+#include <linux/console.h>
+#include <linux/module.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_KDB
+# include <linux/kdb.h>
+#endif
+
+#undef SIMSERIAL_DEBUG	/* define this to get some debug information */
+
+#define KEYBOARD_INTR	3	/* must match with simulator! */
+
+#define NR_PORTS	1	/* only one port for now */
+#define SERIAL_INLINE	1
+
+#ifdef SERIAL_INLINE
+#define _INLINE_ inline
+#endif
+
+#ifndef MIN
+#define MIN(a,b)	((a) < (b) ? (a) : (b))
+#endif
+
+#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? SA_SHIRQ : SA_INTERRUPT)
+
+#define SSC_GETCHAR	21
+
+extern long ia64_ssc (long, long, long, long, int);
+extern void ia64_ssc_connect_irq (long intr, long irq);
+
+static char *serial_name = "SimSerial driver";
+static char *serial_version = "0.6";
+
+/*
+ * This has been extracted from asm/serial.h. We need one eventually but
+ * I don't know exactly what we're going to put in it so just fake one
+ * for now.
+ */
+#define BASE_BAUD ( 1843200 / 16 )
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+
+/*
+ * Most of the values here are meaningless to this particular driver.
+ * However some values must be preserved for the code (leveraged from serial.c
+ * to work correctly).
+ * port must not be 0
+ * type must not be UNKNOWN
+ * So I picked arbitrary (guess from where?) values instead
+ */
+static struct serial_state rs_table[NR_PORTS]={
+  /* UART CLK   PORT IRQ     FLAGS        */
+  { 0, BASE_BAUD, 0x3F8, 0, STD_COM_FLAGS,0,PORT_16550 }  /* ttyS0 */
+};
+
+/*
+ * Just for the fun of it !
+ */
+static struct serial_uart_config uart_config[] = {
+	{ "unknown", 1, 0 },
+	{ "8250", 1, 0 },
+	{ "16450", 1, 0 },
+	{ "16550", 1, 0 },
+	{ "16550A", 16, UART_CLEAR_FIFO | UART_USE_FIFO },
+	{ "cirrus", 1, 0 },
+	{ "ST16650", 1, UART_CLEAR_FIFO | UART_STARTECH },
+	{ "ST16650V2", 32, UART_CLEAR_FIFO | UART_USE_FIFO |
+		  UART_STARTECH },
+	{ "TI16750", 64, UART_CLEAR_FIFO | UART_USE_FIFO},
+	{ 0, 0}
+};
+
+static struct tty_driver serial_driver, callout_driver;
+static int serial_refcount;
+
+static struct async_struct *IRQ_ports[NR_IRQS];
+static struct tty_struct *serial_table[NR_PORTS];
+static struct termios *serial_termios[NR_PORTS];
+static struct termios *serial_termios_locked[NR_PORTS];
+
+static struct console *console;
+
+static unsigned char *tmp_buf;
+static DECLARE_MUTEX(tmp_buf_sem);
+
+extern struct console *console_drivers; /* from kernel/printk.c */
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop() and rs_start()
+ *
+ * This routines are called before setting or resetting tty->stopped.
+ * They enable or disable transmitter interrupts, as necessary.
+ * ------------------------------------------------------------
+ */
+static void rs_stop(struct tty_struct *tty)
+{
+#ifdef SIMSERIAL_DEBUG
+	printk("rs_stop: tty->stopped=%d tty->hw_stopped=%d tty->flow_stopped=%d\n",
+		tty->stopped, tty->hw_stopped, tty->flow_stopped);
+#endif
+
+}
+
+static void rs_start(struct tty_struct *tty)
+{
+#if SIMSERIAL_DEBUG
+	printk("rs_start: tty->stopped=%d tty->hw_stopped=%d tty->flow_stopped=%d\n",
+		tty->stopped, tty->hw_stopped, tty->flow_stopped);
+#endif
+}
+
+static  void receive_chars(struct tty_struct *tty, struct pt_regs *regs)
+{
+	unsigned char ch;
+	static unsigned char seen_esc = 0;
+
+	while ( (ch = ia64_ssc(0, 0, 0, 0, SSC_GETCHAR)) ) {
+		if ( ch == 27 && seen_esc == 0 ) {
+			seen_esc = 1;
+			continue;
+		} else {
+			if ( seen_esc==1 && ch == 'O' ) {
+				seen_esc = 2;
+				continue;
+			} else if ( seen_esc == 2 ) {
+				if ( ch == 'P' ) show_state();		/* F1 key */
+				if ( ch == 'Q' ) show_buffers();	/* F2 key */
+#ifdef CONFIG_KDB
+				if ( ch == 'S' )
+					kdb(KDB_REASON_KEYBOARD, 0, (kdb_eframe_t) regs);
+#endif
+
+				seen_esc = 0;
+				continue;
+			}
+		}
+		seen_esc = 0;
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) break;
+
+		*tty->flip.char_buf_ptr = ch;
+
+		*tty->flip.flag_buf_ptr = 0;
+
+		tty->flip.flag_buf_ptr++;
+		tty->flip.char_buf_ptr++;
+		tty->flip.count++;
+	}
+	tty_flip_buffer_push(tty);
+}
+
+/*
+ * This is the serial driver's interrupt routine for a single port
+ */
+static void rs_interrupt_single(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct async_struct * info;
+
+	/*
+	 * I don't know exactly why they don't use the dev_id opaque data
+	 * pointer instead of this extra lookup table
+	 */
+	info = IRQ_ports[irq];
+	if (!info || !info->tty) {
+		printk("simrs_interrupt_single: info|tty=0 info=%p problem\n", info);
+		return;
+	}
+	/*
+	 * pretty simple in our case, because we only get interrupts
+	 * on inbound traffic
+	 */
+	receive_chars(info->tty, regs);
+}
+
+/*
+ * -------------------------------------------------------------------
+ * Here ends the serial interrupt routines.
+ * -------------------------------------------------------------------
+ */
+
+#if 0
+/*
+ * not really used in our situation so keep them commented out for now
+ */
+static DECLARE_TASK_QUEUE(tq_serial); /* used to be at the top of the file */
+static void do_serial_bh(void)
+{
+	run_task_queue(&tq_serial);
+	printk("do_serial_bh: called\n");
+}
+#endif
+
+static void do_softint(void *private_)
+{
+	printk("simserial: do_softint called\n");
+}
+
+static void rs_put_char(struct tty_struct *tty, unsigned char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (!tty || !info->xmit.buf) return;
+
+	save_flags(flags); cli();
+	if (CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE) == 0) {
+		restore_flags(flags);
+		return;
+	}
+	info->xmit.buf[info->xmit.head] = ch;
+	info->xmit.head = (info->xmit.head + 1) & (SERIAL_XMIT_SIZE-1);
+	restore_flags(flags);
+}
+
+static _INLINE_ void transmit_chars(struct async_struct *info, int *intr_done)
+{
+	int count;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+
+	if (info->x_char) {
+		char c = info->x_char;
+
+		console->write(console, &c, 1);
+
+		info->state->icount.tx++;
+		info->x_char = 0;
+
+		goto out;
+	}
+
+	if (info->xmit.head == info->xmit.tail || info->tty->stopped || info->tty->hw_stopped) {
+#ifdef SIMSERIAL_DEBUG
+		printk("transmit_chars: head=%d, tail=%d, stopped=%d\n",
+		       info->xmit.head, info->xmit.tail, info->tty->stopped);
+#endif
+		goto out;
+	}
+	/*
+	 * We removed the loop and try to do it in to chunks. We need
+	 * 2 operations maximum because it's a ring buffer.
+	 *
+	 * First from current to tail if possible.
+	 * Then from the beginning of the buffer until necessary
+	 */
+
+	count = MIN(CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE),
+		    SERIAL_XMIT_SIZE - info->xmit.tail);
+	console->write(console, info->xmit.buf+info->xmit.tail, count);
+
+	info->xmit.tail = (info->xmit.tail+count) & (SERIAL_XMIT_SIZE-1);
+
+	/*
+	 * We have more at the beginning of the buffer
+	 */
+	count = CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+	if (count) {
+		console->write(console, info->xmit.buf, count);
+		info->xmit.tail += count;
+	}
+out:
+	restore_flags(flags);
+}
+
+static void rs_flush_chars(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	if (info->xmit.head == info->xmit.tail || tty->stopped || tty->hw_stopped ||
+	    !info->xmit.buf)
+		return;
+
+	transmit_chars(info, NULL);
+}
+
+
+static int rs_write(struct tty_struct * tty, int from_user,
+		    const unsigned char *buf, int count)
+{
+	int	c, ret = 0;
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (!tty || !info->xmit.buf || !tmp_buf) return 0;
+
+	save_flags(flags);
+	if (from_user) {
+		down(&tmp_buf_sem);
+		while (1) {
+			int c1;
+			c = CIRC_SPACE_TO_END(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0)
+				break;
+
+			c -= copy_from_user(tmp_buf, buf, c);
+			if (!c) {
+				if (!ret)
+					ret = -EFAULT;
+				break;
+			}
+			cli();
+			c1 = CIRC_SPACE_TO_END(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+			if (c1 < c)
+				c = c1;
+			memcpy(info->xmit.buf + info->xmit.head, tmp_buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+					   (SERIAL_XMIT_SIZE-1));
+			restore_flags(flags);
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		up(&tmp_buf_sem);
+	} else {
+		cli();
+		while (1) {
+			c = CIRC_SPACE_TO_END(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0) {
+				break;
+			}
+			memcpy(info->xmit.buf + info->xmit.head, buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+					   (SERIAL_XMIT_SIZE-1));
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		restore_flags(flags);
+	}
+	/*
+	 * Hey, we transmit directly from here in our case
+	 */
+	if (CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE)
+	    && !tty->stopped && !tty->hw_stopped) {
+		transmit_chars(info, NULL);
+	}
+	return ret;
+}
+
+static int rs_write_room(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	return CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+static int rs_chars_in_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	return CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+static void rs_flush_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	info->xmit.head = info->xmit.tail = 0;
+	restore_flags(flags);
+
+	wake_up_interruptible(&tty->write_wait);
+
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup)
+		(tty->ldisc.write_wakeup)(tty);
+}
+
+/*
+ * This function is used to send a high-priority XON/XOFF character to
+ * the device
+ */
+static void rs_send_xchar(struct tty_struct *tty, char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	info->x_char = ch;
+	if (ch) {
+		/*
+		 * I guess we could call console->write() directly but
+		 * let's do that for now.
+		 */
+		transmit_chars(info, NULL);
+	}
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_throttle()
+ *
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled.
+ * ------------------------------------------------------------
+ */
+static void rs_throttle(struct tty_struct * tty)
+{
+	if (I_IXOFF(tty)) rs_send_xchar(tty, STOP_CHAR(tty));
+
+	printk("simrs_throttle called\n");
+}
+
+static void rs_unthrottle(struct tty_struct * tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	if (I_IXOFF(tty)) {
+		if (info->x_char)
+			info->x_char = 0;
+		else
+			rs_send_xchar(tty, START_CHAR(tty));
+	}
+	printk("simrs_unthrottle called\n");
+}
+
+/*
+ * rs_break() --- routine which turns the break handling on or off
+ */
+static void rs_break(struct tty_struct *tty, int break_state)
+{
+}
+
+static int rs_ioctl(struct tty_struct *tty, struct file * file,
+		    unsigned int cmd, unsigned long arg)
+{
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&
+	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+		    return -EIO;
+	}
+
+	switch (cmd) {
+		case TIOCMGET:
+			printk("rs_ioctl: TIOCMGET called\n");
+			return -EINVAL;
+		case TIOCMBIS:
+		case TIOCMBIC:
+		case TIOCMSET:
+			printk("rs_ioctl: TIOCMBIS/BIC/SET called\n");
+			return -EINVAL;
+		case TIOCGSERIAL:
+			printk("simrs_ioctl TIOCGSERIAL called\n");
+			return 0;
+		case TIOCSSERIAL:
+			printk("simrs_ioctl TIOCSSERIAL called\n");
+			return 0;
+		case TIOCSERCONFIG:
+			printk("rs_ioctl: TIOCSERCONFIG called\n");
+			return -EINVAL;
+
+		case TIOCSERGETLSR: /* Get line status register */
+			printk("rs_ioctl: TIOCSERGETLSR called\n");
+			return  -EINVAL;
+
+		case TIOCSERGSTRUCT:
+			printk("rs_ioctl: TIOCSERGSTRUCT called\n");
+#if 0
+			if (copy_to_user((struct async_struct *) arg,
+					 info, sizeof(struct async_struct)))
+				return -EFAULT;
+#endif
+			return 0;
+
+		/*
+		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+		 * - mask passed in arg for lines of interest
+		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+		 * Caller should use TIOCGICOUNT to see which one it was
+		 */
+		case TIOCMIWAIT:
+			printk("rs_ioctl: TIOCMIWAIT: called\n");
+			return 0;
+		/*
+		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+		 * Return: write counters to the user passed counter struct
+		 * NB: both 1->0 and 0->1 transitions are counted except for
+		 *     RI where only 0->1 is counted.
+		 */
+		case TIOCGICOUNT:
+			printk("rs_ioctl: TIOCGICOUNT called\n");
+			return 0;
+
+		case TIOCSERGWILD:
+		case TIOCSERSWILD:
+			/* "setserial -W" is called in Debian boot */
+			printk ("TIOCSER?WILD ioctl obsolete, ignored.\n");
+			return 0;
+
+		default:
+			return -ENOIOCTLCMD;
+		}
+	return 0;
+}
+
+#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
+
+static void rs_set_termios(struct tty_struct *tty, struct termios *old_termios)
+{
+	unsigned int cflag = tty->termios->c_cflag;
+
+	if (   (cflag == old_termios->c_cflag)
+	    && (   RELEVANT_IFLAG(tty->termios->c_iflag)
+		== RELEVANT_IFLAG(old_termios->c_iflag)))
+	  return;
+
+
+	/* Handle turning off CRTSCTS */
+	if ((old_termios->c_cflag & CRTSCTS) &&
+	    !(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		rs_start(tty);
+	}
+}
+/*
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ */
+static void shutdown(struct async_struct * info)
+{
+	unsigned long	flags;
+	struct serial_state *state;
+	int		retval;
+
+	if (!(info->flags & ASYNC_INITIALIZED)) return;
+
+	state = info->state;
+
+#ifdef SIMSERIAL_DEBUG
+	printk("Shutting down serial port %d (irq %d)....", info->line,
+	       state->irq);
+#endif
+
+	save_flags(flags); cli(); /* Disable interrupts */
+
+	/*
+	 * First unlink the serial port from the IRQ chain...
+	 */
+	if (info->next_port)
+		info->next_port->prev_port = info->prev_port;
+	if (info->prev_port)
+		info->prev_port->next_port = info->next_port;
+	else
+		IRQ_ports[state->irq] = info->next_port;
+
+	/*
+	 * Free the IRQ, if necessary
+	 */
+	if (state->irq && (!IRQ_ports[state->irq] ||
+			  !IRQ_ports[state->irq]->next_port)) {
+		if (IRQ_ports[state->irq]) {
+			free_irq(state->irq, NULL);
+			retval = request_irq(state->irq, rs_interrupt_single,
+					     IRQ_T(info), "serial", NULL);
+
+			if (retval)
+				printk("serial shutdown: request_irq: error %d"
+				       "  Couldn't reacquire IRQ.\n", retval);
+		} else
+			free_irq(state->irq, NULL);
+	}
+
+	if (info->xmit.buf) {
+		free_page((unsigned long) info->xmit.buf);
+		info->xmit.buf = 0;
+	}
+
+	if (info->tty) set_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->flags &= ~ASYNC_INITIALIZED;
+	restore_flags(flags);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_close()
+ *
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we unlink its
+ * async structure from the interrupt chain if necessary, and we free
+ * that IRQ if nothing is left in the chain.
+ * ------------------------------------------------------------
+ */
+static void rs_close(struct tty_struct *tty, struct file * filp)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state;
+	unsigned long flags;
+
+	if (!info ) return;
+
+	state = info->state;
+
+	save_flags(flags); cli();
+
+	if (tty_hung_up_p(filp)) {
+#ifdef SIMSERIAL_DEBUG
+		printk("rs_close: hung_up\n");
+#endif
+		MOD_DEC_USE_COUNT;
+		restore_flags(flags);
+		return;
+	}
+#ifdef SIMSERIAL_DEBUG
+	printk("rs_close ttys%d, count = %d\n", info->line, state->count);
+#endif
+	if ((tty->count == 1) && (state->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  state->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("rs_close: bad serial port count; tty->count is 1, "
+		       "state->count is %d\n", state->count);
+		state->count = 1;
+	}
+	if (--state->count < 0) {
+		printk("rs_close: bad serial port count for ttys%d: %d\n",
+		       info->line, state->count);
+		state->count = 0;
+	}
+	if (state->count) {
+		MOD_DEC_USE_COUNT;
+		restore_flags(flags);
+		return;
+	}
+	info->flags |= ASYNC_CLOSING;
+	restore_flags(flags);
+
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	shutdown(info);
+	if (tty->driver.flush_buffer) tty->driver.flush_buffer(tty);
+	if (tty->ldisc.flush_buffer) tty->ldisc.flush_buffer(tty);
+	info->event = 0;
+	info->tty = 0;
+	if (info->blocked_open) {
+		if (info->close_delay) {
+			current->state = TASK_INTERRUPTIBLE;
+			schedule_timeout(info->close_delay);
+		}
+		wake_up_interruptible(&info->open_wait);
+	}
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE|ASYNC_CLOSING);
+	wake_up_interruptible(&info->close_wait);
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * rs_wait_until_sent() --- wait until the transmitter is empty
+ */
+static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+}
+
+
+/*
+ * rs_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void rs_hangup(struct tty_struct *tty)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state = info->state;
+
+#ifdef SIMSERIAL_DEBUG
+	printk("rs_hangup: called\n");
+#endif
+
+	state = info->state;
+
+	rs_flush_buffer(tty);
+	if (info->flags & ASYNC_CLOSING)
+		return;
+	shutdown(info);
+
+	info->event = 0;
+	state->count = 0;
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE);
+	info->tty = 0;
+	wake_up_interruptible(&info->open_wait);
+}
+
+
+static int get_async_struct(int line, struct async_struct **ret_info)
+{
+	struct async_struct *info;
+	struct serial_state *sstate;
+
+	sstate = rs_table + line;
+	sstate->count++;
+	if (sstate->info) {
+		*ret_info = sstate->info;
+		return 0;
+	}
+	info = kmalloc(sizeof(struct async_struct), GFP_KERNEL);
+	if (!info) {
+		sstate->count--;
+		return -ENOMEM;
+	}
+	memset(info, 0, sizeof(struct async_struct));
+	init_waitqueue_head(&info->open_wait);
+	init_waitqueue_head(&info->close_wait);
+	init_waitqueue_head(&info->delta_msr_wait);
+	info->magic = SERIAL_MAGIC;
+	info->port = sstate->port;
+	info->flags = sstate->flags;
+	info->xmit_fifo_size = sstate->xmit_fifo_size;
+	info->line = line;
+	info->tqueue.routine = do_softint;
+	info->tqueue.data = info;
+	info->state = sstate;
+	if (sstate->info) {
+		kfree(info);
+		*ret_info = sstate->info;
+		return 0;
+	}
+	*ret_info = sstate->info = info;
+	return 0;
+}
+
+static int
+startup(struct async_struct *info)
+{
+	unsigned long flags;
+	int	retval=0;
+	void (*handler)(int, void *, struct pt_regs *);
+	struct serial_state *state= info->state;
+	unsigned long page;
+
+	page = get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	save_flags(flags); cli();
+
+	if (info->flags & ASYNC_INITIALIZED) {
+		free_page(page);
+		goto errout;
+	}
+
+	if (!state->port || !state->type) {
+		if (info->tty) set_bit(TTY_IO_ERROR, &info->tty->flags);
+		free_page(page);
+		goto errout;
+	}
+	if (info->xmit.buf)
+		free_page(page);
+	else
+		info->xmit.buf = (unsigned char *) page;
+
+#ifdef SIMSERIAL_DEBUG
+	printk("startup: ttys%d (irq %d)...", info->line, state->irq);
+#endif
+
+	/*
+	 * Allocate the IRQ if necessary
+	 */
+	if (state->irq && (!IRQ_ports[state->irq] ||
+			  !IRQ_ports[state->irq]->next_port)) {
+		if (IRQ_ports[state->irq]) {
+			retval = -EBUSY;
+			goto errout;
+		} else
+			handler = rs_interrupt_single;
+
+		retval = request_irq(state->irq, handler, IRQ_T(info),
+				     "simserial", NULL);
+		if (retval) {
+			if (capable(CAP_SYS_ADMIN)) {
+				if (info->tty)
+					set_bit(TTY_IO_ERROR,
+						&info->tty->flags);
+				retval = 0;
+			}
+			goto errout;
+		}
+	}
+
+	/*
+	 * Insert serial port into IRQ chain.
+	 */
+	info->prev_port = 0;
+	info->next_port = IRQ_ports[state->irq];
+	if (info->next_port)
+		info->next_port->prev_port = info;
+	IRQ_ports[state->irq] = info;
+
+	if (info->tty) clear_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->xmit.head = info->xmit.tail = 0;
+
+#if 0
+	/*
+	 * Set up serial timers...
+	 */
+	timer_table[RS_TIMER].expires = jiffies + 2*HZ/100;
+	timer_active |= 1 << RS_TIMER;
+#endif
+
+	/*
+	 * Set up the tty->alt_speed kludge
+	 */
+	if (info->tty) {
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			info->tty->alt_speed = 57600;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			info->tty->alt_speed = 115200;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			info->tty->alt_speed = 230400;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			info->tty->alt_speed = 460800;
+	}
+
+	info->flags |= ASYNC_INITIALIZED;
+	restore_flags(flags);
+	return 0;
+
+errout:
+	restore_flags(flags);
+	return retval;
+}
+
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port, linking in its async structure into
+ * the IRQ chain.   It also performs the serial-specific
+ * initialization for the tty structure.
+ */
+static int rs_open(struct tty_struct *tty, struct file * filp)
+{
+	struct async_struct	*info;
+	int			retval, line;
+	unsigned long		page;
+
+	MOD_INC_USE_COUNT;
+	line = MINOR(tty->device) - tty->driver.minor_start;
+	if ((line < 0) || (line >= NR_PORTS)) {
+		MOD_DEC_USE_COUNT;
+		return -ENODEV;
+	}
+	retval = get_async_struct(line, &info);
+	if (retval) {
+		MOD_DEC_USE_COUNT;
+		return retval;
+	}
+	tty->driver_data = info;
+	info->tty = tty;
+
+#ifdef SIMSERIAL_DEBUG
+	printk("rs_open %s%d, count = %d\n", tty->driver.name, info->line,
+	       info->state->count);
+#endif
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+
+	if (!tmp_buf) {
+		page = get_free_page(GFP_KERNEL);
+		if (!page) {
+			/* MOD_DEC_USE_COUNT; "info->tty" will cause this? */
+			return -ENOMEM;
+		}
+		if (tmp_buf)
+			free_page(page);
+		else
+			tmp_buf = (unsigned char *) page;
+	}
+
+	/*
+	 * If the port is the middle of closing, bail out now
+	 */
+	if (tty_hung_up_p(filp) ||
+	    (info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+		/* MOD_DEC_USE_COUNT; "info->tty" will cause this? */
+#ifdef SERIAL_DO_RESTART
+		return ((info->flags & ASYNC_HUP_NOTIFY) ?
+			-EAGAIN : -ERESTARTSYS);
+#else
+		return -EAGAIN;
+#endif
+	}
+
+	/*
+	 * Start up serial port
+	 */
+	retval = startup(info);
+	if (retval) {
+		/* MOD_DEC_USE_COUNT; "info->tty" will cause this? */
+		return retval;
+	}
+
+	if ((info->state->count == 1) &&
+	    (info->flags & ASYNC_SPLIT_TERMIOS)) {
+		if (tty->driver.subtype == SERIAL_TYPE_NORMAL)
+			*tty->termios = info->state->normal_termios;
+		else
+			*tty->termios = info->state->callout_termios;
+	}
+
+	/*
+	 * figure out which console to use (should be one already)
+	 */
+	console = console_drivers;
+	while (console) {
+		if ((console->flags & CON_ENABLED) && console->write) break;
+		console = console->next;
+	}
+
+	info->session = current->session;
+	info->pgrp = current->pgrp;
+
+#ifdef SIMSERIAL_DEBUG
+	printk("rs_open ttys%d successful\n", info->line);
+#endif
+	return 0;
+}
+
+/*
+ * /proc fs routines....
+ */
+
+static inline int line_info(char *buf, struct serial_state *state)
+{
+	return sprintf(buf, "%d: uart:%s port:%lX irq:%d\n",
+		       state->line, uart_config[state->type].name,
+		       state->port, state->irq);
+}
+
+int rs_read_proc(char *page, char **start, off_t off, int count,
+		 int *eof, void *data)
+{
+	int i, len = 0, l;
+	off_t	begin = 0;
+
+	len += sprintf(page, "simserinfo:1.0 driver:%s\n", serial_version);
+	for (i = 0; i < NR_PORTS && len < 4000; i++) {
+		l = line_info(page + len, &rs_table[i]);
+		len += l;
+		if (len+begin > off+count)
+			goto done;
+		if (len+begin < off) {
+			begin += len;
+			len = 0;
+		}
+	}
+	*eof = 1;
+done:
+	if (off >= len+begin)
+		return 0;
+	*start = page + (begin-off);
+	return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+/*
+ * ---------------------------------------------------------------------
+ * rs_init() and friends
+ *
+ * rs_init() is called at boot-time to initialize the serial driver.
+ * ---------------------------------------------------------------------
+ */
+
+/*
+ * This routine prints out the appropriate serial driver version
+ * number, and identifies which options were configured into this
+ * driver.
+ */
+static inline void show_serial_version(void)
+{
+	printk(KERN_INFO "%s version %s with", serial_name, serial_version);
+	printk(" no serial options enabled\n");
+}
+
+/*
+ * The serial driver boot-time initialization code!
+ */
+static int __init
+simrs_init (void)
+{
+	int			i;
+	struct serial_state	*state;
+
+	show_serial_version();
+
+	/* Initialize the tty_driver structure */
+
+	memset(&serial_driver, 0, sizeof(struct tty_driver));
+	serial_driver.magic = TTY_DRIVER_MAGIC;
+	serial_driver.driver_name = "simserial";
+	serial_driver.name = "ttyS";
+	serial_driver.major = TTY_MAJOR;
+	serial_driver.minor_start = 64;
+	serial_driver.num = 1;
+	serial_driver.type = TTY_DRIVER_TYPE_SERIAL;
+	serial_driver.subtype = SERIAL_TYPE_NORMAL;
+	serial_driver.init_termios = tty_std_termios;
+	serial_driver.init_termios.c_cflag =
+		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	serial_driver.flags = TTY_DRIVER_REAL_RAW;
+	serial_driver.refcount = &serial_refcount;
+	serial_driver.table = serial_table;
+	serial_driver.termios = serial_termios;
+	serial_driver.termios_locked = serial_termios_locked;
+
+	serial_driver.open = rs_open;
+	serial_driver.close = rs_close;
+	serial_driver.write = rs_write;
+	serial_driver.put_char = rs_put_char;
+	serial_driver.flush_chars = rs_flush_chars;
+	serial_driver.write_room = rs_write_room;
+	serial_driver.chars_in_buffer = rs_chars_in_buffer;
+	serial_driver.flush_buffer = rs_flush_buffer;
+	serial_driver.ioctl = rs_ioctl;
+	serial_driver.throttle = rs_throttle;
+	serial_driver.unthrottle = rs_unthrottle;
+	serial_driver.send_xchar = rs_send_xchar;
+	serial_driver.set_termios = rs_set_termios;
+	serial_driver.stop = rs_stop;
+	serial_driver.start = rs_start;
+	serial_driver.hangup = rs_hangup;
+	serial_driver.break_ctl = rs_break;
+	serial_driver.wait_until_sent = rs_wait_until_sent;
+	serial_driver.read_proc = rs_read_proc;
+
+	/*
+	 * Let's have a little bit of fun !
+	 */
+	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
+
+		if (state->type == PORT_UNKNOWN) continue;
+
+		if (!state->irq) {
+			state->irq = ia64_alloc_irq();
+			ia64_ssc_connect_irq(KEYBOARD_INTR, state->irq);
+		}
+
+		printk(KERN_INFO "ttyS%02d at 0x%04lx (irq = %d) is a %s\n",
+		       state->line,
+		       state->port, state->irq,
+		       uart_config[state->type].name);
+	}
+	/*
+	 * The callout device is just like normal device except for
+	 * major number and the subtype code.
+	 */
+	callout_driver = serial_driver;
+	callout_driver.name = "cua";
+	callout_driver.major = TTYAUX_MAJOR;
+	callout_driver.subtype = SERIAL_TYPE_CALLOUT;
+	callout_driver.read_proc = 0;
+	callout_driver.proc_entry = 0;
+
+	if (tty_register_driver(&serial_driver))
+		panic("Couldn't register simserial driver\n");
+
+	if (tty_register_driver(&callout_driver))
+		panic("Couldn't register callout driver\n");
+
+	return 0;
+}
+
+#ifndef MODULE
+__initcall(simrs_init);
+#endif
diff -urN linux.orig/drivers/ide/ide-geometry.c linux/drivers/ide/ide-geometry.c
--- linux.orig/drivers/ide/ide-geometry.c	Thu Jan  4 13:50:17 2001
+++ linux/drivers/ide/ide-geometry.c	Mon Dec 17 20:27:40 2001
@@ -3,8 +3,11 @@
  */
 #include <linux/config.h>
 #include <linux/ide.h>
-#include <linux/mc146818rtc.h>
 #include <asm/io.h>
+
+#ifdef __i386__
+# include <linux/mc146818rtc.h>
+#endif
 
 /*
  * We query CMOS about hard disks : it could be that we have a SCSI/ESDI/etc
diff -urN linux.orig/drivers/input/joydev.c linux/drivers/input/joydev.c
--- linux.orig/drivers/input/joydev.c	Wed Apr 11 20:02:30 2001
+++ linux/drivers/input/joydev.c	Mon Dec 17 20:27:40 2001
@@ -86,6 +86,12 @@
 MODULE_DESCRIPTION("Joystick device driver");
 MODULE_SUPPORTED_DEVICE("input/js");
 
+static inline unsigned long
+jiffies_to_msec (unsigned long t)
+{
+	return 1000*(t / HZ) + 1000*(t % HZ)/HZ;
+}
+
 static int joydev_correct(int value, struct js_corr *corr)
 {
 	switch (corr->type) {
@@ -133,7 +139,7 @@
 			return;
 	}  
 
-	event.time = jiffies * (1000 / HZ);
+	event.time = jiffies_to_msec(jiffies);
 
 	while (list) {
 
@@ -278,7 +284,7 @@
 
 		struct js_event event;
 
-		event.time = jiffies * (1000/HZ);
+		event.time = jiffies_to_msec(jiffies);
 
 		if (list->startup < joydev->nkey) {
 			event.type = JS_EVENT_BUTTON | JS_EVENT_INIT;
diff -urN linux.orig/drivers/media/radio/Makefile linux/drivers/media/radio/Makefile
--- linux.orig/drivers/media/radio/Makefile	Sun Aug  5 14:15:05 2001
+++ linux/drivers/media/radio/Makefile	Mon Dec 17 20:27:40 2001
@@ -11,7 +11,7 @@
 
 # Object file lists.
 
-obj-y		:=
+obj-y		:= dummy.o
 obj-m		:=
 obj-n		:=
 obj-		:=
diff -urN linux.orig/drivers/media/radio/dummy.c linux/drivers/media/radio/dummy.c
--- linux.orig/drivers/media/radio/dummy.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/media/radio/dummy.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -urN linux.orig/drivers/media/video/Makefile linux/drivers/media/video/Makefile
--- linux.orig/drivers/media/video/Makefile	Wed Jul  4 15:41:33 2001
+++ linux/drivers/media/video/Makefile	Mon Dec 17 20:27:40 2001
@@ -11,7 +11,7 @@
 
 # Object file lists.
 
-obj-y		:=
+obj-y		:= dummy.o
 obj-m		:=
 obj-n		:=
 obj-		:=
diff -urN linux.orig/drivers/media/video/dummy.c linux/drivers/media/video/dummy.c
--- linux.orig/drivers/media/video/dummy.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/media/video/dummy.c	Mon Dec 17 20:27:40 2001
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -urN linux.orig/drivers/net/Config.in linux/drivers/net/Config.in
--- linux.orig/drivers/net/Config.in	Sun Aug 12 11:51:42 2001
+++ linux/drivers/net/Config.in	Mon Dec 17 20:27:41 2001
@@ -207,6 +207,7 @@
 
 dep_tristate 'Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support' CONFIG_ACENIC $CONFIG_PCI
 dep_mbool '  Omit support for old Tigon I based AceNICs' CONFIG_ACENIC_OMIT_TIGON_I $CONFIG_ACENIC
+dep_tristate 'Broadcom BCM5700 support' CONFIG_NET_BROADCOM $CONFIG_PCI
 dep_tristate 'D-Link DL2000-based Gigabit Ethernet support' CONFIG_DL2K $CONFIG_PCI
 dep_tristate 'MyriCOM Gigabit Ethernet support' CONFIG_MYRI_SBUS $CONFIG_SBUS
 dep_tristate 'Packet Engines Hamachi GNIC-II support' CONFIG_HAMACHI $CONFIG_PCI
diff -urN linux.orig/drivers/net/Makefile linux/drivers/net/Makefile
--- linux.orig/drivers/net/Makefile	Fri Jul  6 17:48:50 2001
+++ linux/drivers/net/Makefile	Mon Dec 17 20:27:41 2001
@@ -29,6 +29,10 @@
   obj-$(CONFIG_ISDN) += slhc.o
 endif
 
+ifeq ($(CONFIG_NET_BROADCOM),y)
+  obj-y += bcm/bcm5700.o
+endif
+
 subdir-$(CONFIG_NET_PCMCIA) += pcmcia
 subdir-$(CONFIG_NET_WIRELESS) += wireless
 subdir-$(CONFIG_TULIP) += tulip
@@ -40,6 +44,7 @@
 subdir-$(CONFIG_APPLETALK) += appletalk
 subdir-$(CONFIG_SK98LIN) += sk98lin
 subdir-$(CONFIG_SKFP) += skfp
+subdir-$(CONFIG_NET_BROADCOM) += bcm
 
 #
 # link order important here
@@ -128,6 +133,7 @@
 obj-$(CONFIG_ES3210) += es3210.o 8390.o
 obj-$(CONFIG_LNE390) += lne390.o 8390.o
 obj-$(CONFIG_NE3210) += ne3210.o 8390.o
+obj-$(CONFIG_SIMETH) += simeth.o
 
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
diff -urN linux.orig/drivers/net/bcm/5701rls.c linux/drivers/net/bcm/5701rls.c
--- linux.orig/drivers/net/bcm/5701rls.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/5701rls.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,161 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+#if INCLUDE_5701_AX_FIX
+
+#include "mm.h"
+#include "5701rls.h"
+
+#define  T3_RX_CPU_ID    0
+#define T3_TX_CPU_ID    1
+#define T3_RX_CPU_SPAD_ADDR  0x30000
+#define T3_RX_CPU_SPAD_SIZE  0x4000
+#define T3_TX_CPU_SPAD_ADDR  0x34000
+#define T3_TX_CPU_SPAD_SIZE  0x4000
+
+/* Function protocol types */
+STATIC LM_STATUS LM_ResetCpu(PLM_DEVICE_BLOCK pDevice,LM_UINT32 cpu_number);
+
+LM_STATUS LM_LoadRlsFirmware(PLM_DEVICE_BLOCK pDevice)
+{
+  int i;
+  LM_UINT32 address;
+
+  if (LM_ResetCpu(pDevice,T3_RX_CPU_ID) != LM_STATUS_SUCCESS)
+    {
+      DbgMessage(FATAL, ("Failed Resetting Rx CPU.\n"));
+      DbgBreak();
+      return LM_STATUS_FAILURE;
+    }
+
+  /* First of all clear scrach pad memory */
+  for (i= 0; i < T3_RX_CPU_SPAD_SIZE; i+=4)
+    {
+      LM_RegWrInd(pDevice,T3_RX_CPU_SPAD_ADDR+i,0);
+    }
+
+  /* Rx-Cpu */
+  REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+  REG_WR(pDevice,rxCpu.reg.mode, REG_RD(pDevice,rxCpu.reg.mode)| CPU_MODE_HALT);
+  /* Copy code first */
+  address = T3_RX_CPU_SPAD_ADDR + (t3FwTextAddr & 0xffff);
+  for (i= 0; i <= t3FwTextLen; i+=4)
+    {
+      LM_RegWrInd(pDevice,address+i,t3FwText[i/4]);
+    }
+
+  address = T3_RX_CPU_SPAD_ADDR + (t3FwRodataAddr & 0xffff);
+  for (i= 0; i <= t3FwRodataLen; i+=4)
+    {
+      LM_RegWrInd(pDevice,address+i,t3FwRodata[i/4]);
+    }
+
+  address = T3_RX_CPU_SPAD_ADDR + (t3FwDataAddr & 0xffff);
+  for (i= 0; i <= t3FwDataLen; i+=4)
+    {
+      LM_RegWrInd(pDevice,address+i,t3FwData[i/4]);
+    }
+
+  /* Tx-Cpu */
+  if (LM_ResetCpu(pDevice,T3_TX_CPU_ID) != LM_STATUS_SUCCESS)
+    {
+      DbgMessage(FATAL, ("Failed Resetting Tx CPU.\n"));
+      DbgBreak();
+      return LM_STATUS_FAILURE;
+    }
+
+  /* First of all clear scrach pad memory */
+  for (i= 0; i < T3_TX_CPU_SPAD_SIZE; i+=4)
+    {
+      LM_RegWrInd(pDevice,T3_TX_CPU_SPAD_ADDR+i,0);
+    }
+
+  REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+  REG_WR(pDevice,txCpu.reg.mode,REG_RD(pDevice,txCpu.reg.mode) | 
+	 CPU_MODE_HALT);
+  address = T3_TX_CPU_SPAD_ADDR + (t3FwTextAddr & 0xffff);
+  for (i= 0; i <= t3FwTextLen; i+=4)
+    {
+      LM_RegWrInd(pDevice,address+i,t3FwText[i/4]);
+    }
+
+  address = T3_TX_CPU_SPAD_ADDR + (t3FwRodataAddr & 0xffff);
+  for (i= 0; i <= t3FwRodataLen; i+=4)
+    {
+      LM_RegWrInd(pDevice,address+i,t3FwRodata[i/4]);
+    }
+
+  address = T3_TX_CPU_SPAD_ADDR + (t3FwDataAddr & 0xffff);
+  for (i= 0; i <= t3FwDataLen; i+=4)
+    {
+      LM_RegWrInd(pDevice,address+i,t3FwData[i/4]);
+    }
+
+  /* Start Rx CPU */
+  REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+  REG_WR(pDevice,rxCpu.reg.PC,t3FwTextAddr);
+  for (i = 0 ; i < 5; i++)
+    {
+      if (t3FwTextAddr == REG_RD(pDevice,rxCpu.reg.PC))
+	break;
+
+      REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+      REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_HALT);
+      REG_WR(pDevice,rxCpu.reg.PC,t3FwTextAddr);
+      MM_Wait(1000);
+    }
+
+  REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+  REG_WR(pDevice,rxCpu.reg.mode, 0);
+
+  return LM_STATUS_SUCCESS;
+}
+
+STATIC LM_STATUS LM_ResetCpu(PLM_DEVICE_BLOCK pDevice,LM_UINT32 cpu_number)
+{
+  LM_UINT32 i;
+
+  if (cpu_number == T3_RX_CPU_ID)
+    {
+      REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+      REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_RESET);
+
+      for (i = 0 ; i < 10000; i++)
+        {
+          if (!(REG_RD(pDevice,rxCpu.reg.mode) & CPU_MODE_RESET))
+            break;
+        }
+
+      REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+      REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_RESET);
+      MM_Wait(10);
+    }
+  else
+    {
+      REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+      REG_WR(pDevice,txCpu.reg.mode,CPU_MODE_RESET);
+      for (i = 0 ; i < 10000; i++)
+        {
+          if (!(REG_RD(pDevice,txCpu.reg.mode) & CPU_MODE_RESET))
+            break;
+
+	  REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+          REG_WR(pDevice,txCpu.reg.mode,CPU_MODE_RESET);
+	  MM_Wait(10);
+        }
+    }
+
+  return (( i == 10000) ? LM_STATUS_FAILURE : LM_STATUS_SUCCESS);
+}
+
+#endif /* INCLUDE_5701_AX_FIX */
diff -urN linux.orig/drivers/net/bcm/5701rls.h linux/drivers/net/bcm/5701rls.h
--- linux.orig/drivers/net/bcm/5701rls.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/5701rls.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,198 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+typedef unsigned long U32;
+int t3FwReleaseMajor = 0x0;
+int t3FwReleaseMinor = 0x0;
+int t3FwReleaseFix = 0x0;
+U32 t3FwStartAddr = 0x08000000;
+U32 t3FwTextAddr = 0x08000000;
+int t3FwTextLen = 0x9c0;
+U32 t3FwRodataAddr = 0x080009c0;
+int t3FwRodataLen = 0x60;
+U32 t3FwDataAddr = 0x08000a40;
+int t3FwDataLen = 0x20;
+U32 t3FwSbssAddr = 0x08000a60;
+int t3FwSbssLen = 0xc;
+U32 t3FwBssAddr = 0x08000a70;
+int t3FwBssLen = 0x10;
+U32 t3FwText[(0x9c0/4) + 1] = {
+0x0, 
+0x10000003, 0x0, 0xd, 0xd, 
+0x3c1d0800, 0x37bd3ffc, 0x3a0f021, 0x3c100800, 
+0x26100000, 0xe000018, 0x0, 0xd, 
+0x3c1d0800, 0x37bd3ffc, 0x3a0f021, 0x3c100800, 
+0x26100034, 0xe00021c, 0x0, 0xd, 
+0x0, 0x0, 0x0, 0x27bdffe0, 
+0x3c1cc000, 0xafbf0018, 0xaf80680c, 0xe00004c, 
+0x241b2105, 0x97850000, 0x97870002, 0x9782002c, 
+0x9783002e, 0x3c040800, 0x248409c0, 0xafa00014, 
+0x21400, 0x621825, 0x52c00, 0xafa30010, 
+0x8f860010, 0xe52825, 0xe000060, 0x24070102, 
+0x3c02ac00, 0x34420100, 0x3c03ac01, 0x34630100, 
+0xaf820490, 0x3c02ffff, 0xaf820494, 0xaf830498, 
+0xaf82049c, 0x24020001, 0xaf825ce0, 0xe00003f, 
+0xaf825d00, 0xe000140, 0x0, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x2402ffff, 0xaf825404, 
+0x8f835400, 0x34630400, 0xaf835400, 0xaf825404, 
+0x3c020800, 0x24420034, 0xaf82541c, 0x3e00008, 
+0xaf805400, 0x0, 0x0, 0x3c020800, 
+0x34423000, 0x3c030800, 0x34633000, 0x3c040800, 
+0x348437ff, 0x3c010800, 0xac220a64, 0x24020040, 
+0x3c010800, 0xac220a68, 0x3c010800, 0xac200a60, 
+0xac600000, 0x24630004, 0x83102b, 0x5040fffd, 
+0xac600000, 0x3e00008, 0x0, 0x804821, 
+0x8faa0010, 0x3c020800, 0x8c420a60, 0x3c040800, 
+0x8c840a68, 0x8fab0014, 0x24430001, 0x44102b, 
+0x3c010800, 0xac230a60, 0x14400003, 0x4021, 
+0x3c010800, 0xac200a60, 0x3c020800, 0x8c420a60, 
+0x3c030800, 0x8c630a64, 0x91240000, 0x21140, 
+0x431021, 0x481021, 0x25080001, 0xa0440000, 
+0x29020008, 0x1440fff4, 0x25290001, 0x3c020800, 
+0x8c420a60, 0x3c030800, 0x8c630a64, 0x8f84680c, 
+0x21140, 0x431021, 0xac440008, 0xac45000c, 
+0xac460010, 0xac470014, 0xac4a0018, 0x3e00008, 
+0xac4b001c, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x2000008, 
+0x0, 0xa0001e3, 0x3c0a0001, 0xa0001e3, 
+0x3c0a0002, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x3c0a0007, 0xa0001e3, 0x3c0a0008, 0xa0001e3, 
+0x3c0a0009, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x3c0a000b, 0xa0001e3, 
+0x3c0a000c, 0xa0001e3, 0x3c0a000d, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x3c0a000e, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x3c0a0013, 0xa0001e3, 
+0x3c0a0014, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x27bdffe0, 
+0x1821, 0x1021, 0xafbf0018, 0xafb10014, 
+0xafb00010, 0x3c010800, 0x220821, 0xac200a70, 
+0x3c010800, 0x220821, 0xac200a74, 0x3c010800, 
+0x220821, 0xac200a78, 0x24630001, 0x1860fff5, 
+0x2442000c, 0x24110001, 0x8f906810, 0x32020004, 
+0x14400005, 0x24040001, 0x3c020800, 0x8c420a78, 
+0x18400003, 0x2021, 0xe000182, 0x0, 
+0x32020001, 0x10400003, 0x0, 0xe000169, 
+0x0, 0xa000153, 0xaf915028, 0x8fbf0018, 
+0x8fb10014, 0x8fb00010, 0x3e00008, 0x27bd0020, 
+0x3c050800, 0x8ca50a70, 0x3c060800, 0x8cc60a80, 
+0x3c070800, 0x8ce70a78, 0x27bdffe0, 0x3c040800, 
+0x248409d0, 0xafbf0018, 0xafa00010, 0xe000060, 
+0xafa00014, 0xe00017b, 0x2021, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x24020001, 0x8f836810, 
+0x821004, 0x21027, 0x621824, 0x3e00008, 
+0xaf836810, 0x27bdffd8, 0xafbf0024, 0x1080002e, 
+0xafb00020, 0x8f825cec, 0xafa20018, 0x8f825cec, 
+0x3c100800, 0x26100a78, 0xafa2001c, 0x34028000, 
+0xaf825cec, 0x8e020000, 0x18400016, 0x0, 
+0x3c020800, 0x94420a74, 0x8fa3001c, 0x221c0, 
+0xac830004, 0x8fa2001c, 0x3c010800, 0xe000201, 
+0xac220a74, 0x10400005, 0x0, 0x8e020000, 
+0x24420001, 0xa0001df, 0xae020000, 0x3c020800, 
+0x8c420a70, 0x21c02, 0x321c0, 0xa0001c5, 
+0xafa2001c, 0xe000201, 0x0, 0x1040001f, 
+0x0, 0x8e020000, 0x8fa3001c, 0x24420001, 
+0x3c010800, 0xac230a70, 0x3c010800, 0xac230a74, 
+0xa0001df, 0xae020000, 0x3c100800, 0x26100a78, 
+0x8e020000, 0x18400028, 0x0, 0xe000201, 
+0x0, 0x14400024, 0x0, 0x8e020000, 
+0x3c030800, 0x8c630a70, 0x2442ffff, 0xafa3001c, 
+0x18400006, 0xae020000, 0x31402, 0x221c0, 
+0x8c820004, 0x3c010800, 0xac220a70, 0x97a2001e, 
+0x2442ff00, 0x2c420300, 0x1440000b, 0x24024000, 
+0x3c040800, 0x248409dc, 0xafa00010, 0xafa00014, 
+0x8fa6001c, 0x24050008, 0xe000060, 0x3821, 
+0xa0001df, 0x0, 0xaf825cf8, 0x3c020800, 
+0x8c420a40, 0x8fa3001c, 0x24420001, 0xaf835cf8, 
+0x3c010800, 0xac220a40, 0x8fbf0024, 0x8fb00020, 
+0x3e00008, 0x27bd0028, 0x27bdffe0, 0x3c040800, 
+0x248409e8, 0x2821, 0x3021, 0x3821, 
+0xafbf0018, 0xafa00010, 0xe000060, 0xafa00014, 
+0x8fbf0018, 0x3e00008, 0x27bd0020, 0x8f82680c, 
+0x8f85680c, 0x21827, 0x3182b, 0x31823, 
+0x431024, 0x441021, 0xa2282b, 0x10a00006, 
+0x0, 0x401821, 0x8f82680c, 0x43102b, 
+0x1440fffd, 0x0, 0x3e00008, 0x0, 
+0x3c040800, 0x8c840000, 0x3c030800, 0x8c630a40, 
+0x64102b, 0x54400002, 0x831023, 0x641023, 
+0x2c420008, 0x3e00008, 0x38420001, 0x27bdffe0, 
+0x802821, 0x3c040800, 0x24840a00, 0x3021, 
+0x3821, 0xafbf0018, 0xafa00010, 0xe000060, 
+0xafa00014, 0xa000216, 0x0, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x0, 0x27bdffe0, 
+0x3c1cc000, 0xafbf0018, 0xe00004c, 0xaf80680c, 
+0x3c040800, 0x24840a10, 0x3802821, 0x3021, 
+0x3821, 0xafa00010, 0xe000060, 0xafa00014, 
+0x2402ffff, 0xaf825404, 0x3c0200aa, 0xe000234, 
+0xaf825434, 0x8fbf0018, 0x3e00008, 0x27bd0020, 
+0x0, 0x0, 0x0, 0x27bdffe8, 
+0xafb00010, 0x24100001, 0xafbf0014, 0x3c01c003, 
+0xac200000, 0x8f826810, 0x30422000, 0x10400003, 
+0x0, 0xe000246, 0x0, 0xa00023a, 
+0xaf905428, 0x8fbf0014, 0x8fb00010, 0x3e00008, 
+0x27bd0018, 0x27bdfff8, 0x8f845d0c, 0x3c0200ff, 
+0x3c030800, 0x8c630a50, 0x3442fff8, 0x821024, 
+0x1043001e, 0x3c0500ff, 0x34a5fff8, 0x3c06c003, 
+0x3c074000, 0x851824, 0x8c620010, 0x3c010800, 
+0xac230a50, 0x30420008, 0x10400005, 0x871025, 
+0x8cc20000, 0x24420001, 0xacc20000, 0x871025, 
+0xaf825d0c, 0x8fa20000, 0x24420001, 0xafa20000, 
+0x8fa20000, 0x8fa20000, 0x24420001, 0xafa20000, 
+0x8fa20000, 0x8f845d0c, 0x3c030800, 0x8c630a50, 
+0x851024, 0x1443ffe8, 0x851824, 0x27bd0008, 
+0x3e00008, 0x0, 0x0, 0x0 };
+U32 t3FwRodata[(0x60/4) + 1] = {
+0x35373031, 0x726c7341, 0x0, 
+0x0, 0x53774576, 0x656e7430, 0x0, 
+0x726c7045, 0x76656e74, 0x31000000, 0x556e6b6e, 
+0x45766e74, 0x0, 0x0, 0x0, 
+0x0, 0x66617461, 0x6c457272, 0x0, 
+0x0, 0x4d61696e, 0x43707542, 0x0, 
+0x0, 0x0 };
+U32 t3FwData[(0x20/4) + 1] = {
+0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0 };
diff -urN linux.orig/drivers/net/bcm/Makefile linux/drivers/net/bcm/Makefile
--- linux.orig/drivers/net/bcm/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/Makefile	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,13 @@
+
+#
+# Makefile for linux/drivers/net/bcm
+#
+
+O_TARGET := bcm5700.o
+obj-y    := b57um.o b57proc.o tigon3.o autoneg.o 5701rls.o
+obj-m    := $(O_TARGET)
+
+EXTRA_CFLAGS = -DDBG=0 -DT3_JUMBO_RCV_RCB_ENTRY_COUNT=256 -DNICE_SUPPORT -DPCIX_TARGET_WORKAROUND=1 -DINCLUDE_TBI_SUPPORT -DINCLUDE_5701_AX_FIX=1
+
+include $(TOPDIR)/Rules.make
+
diff -urN linux.orig/drivers/net/bcm/autoneg.c linux/drivers/net/bcm/autoneg.c
--- linux.orig/drivers/net/bcm/autoneg.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/autoneg.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,535 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+#if INCLUDE_TBI_SUPPORT
+#include "autoneg.h"
+#include "mm.h"
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+MM_AnTxConfig(
+    PAN_STATE_INFO pAnInfo)
+{
+    PLM_DEVICE_BLOCK pDevice;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    REG_WR(pDevice, MacCtrl.TxAutoNeg, (LM_UINT32) pAnInfo->TxConfig.AsUSHORT);
+
+    pDevice->MacMode |= MAC_MODE_SEND_CONFIGS;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+MM_AnTxIdle(
+    PAN_STATE_INFO pAnInfo)
+{
+    PLM_DEVICE_BLOCK pDevice;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    pDevice->MacMode &= ~MAC_MODE_SEND_CONFIGS;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+char
+MM_AnRxConfig(
+    PAN_STATE_INFO pAnInfo,
+    unsigned short *pRxConfig)
+{
+    PLM_DEVICE_BLOCK pDevice;
+    LM_UINT32 Value32;
+    char Retcode;
+
+    Retcode = AN_FALSE;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if(Value32 & MAC_STATUS_RECEIVING_CFG)
+    {
+        Value32 = REG_RD(pDevice, MacCtrl.RxAutoNeg);
+        *pRxConfig = (unsigned short) Value32;
+
+        Retcode = AN_TRUE;
+    }
+
+    return Retcode;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+AutonegInit(
+    PAN_STATE_INFO pAnInfo)
+{
+    unsigned long j;
+
+    for(j = 0; j < sizeof(AN_STATE_INFO); j++)
+    {
+        ((unsigned char *) pAnInfo)[j] = 0;
+    }
+
+    /* Initialize the default advertisement register. */
+    pAnInfo->mr_adv_full_duplex = 1;
+    pAnInfo->mr_adv_sym_pause = 1;
+    pAnInfo->mr_adv_asym_pause = 1;
+    pAnInfo->mr_an_enable = 1;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+AUTONEG_STATUS
+Autoneg8023z(
+    PAN_STATE_INFO pAnInfo)
+{
+    unsigned short RxConfig;
+    unsigned long Delta_us;
+    AUTONEG_STATUS AnRet;
+
+    /* Get the current time. */
+    if(pAnInfo->State == AN_STATE_UNKNOWN)
+    {
+        pAnInfo->RxConfig.AsUSHORT = 0;
+        pAnInfo->CurrentTime_us = 0;
+        pAnInfo->LinkTime_us = 0;
+        pAnInfo->AbilityMatchCfg = 0;
+        pAnInfo->AbilityMatchCnt = 0;
+        pAnInfo->AbilityMatch = AN_FALSE;
+        pAnInfo->IdleMatch = AN_FALSE;
+        pAnInfo->AckMatch = AN_FALSE;
+    }
+
+    /* Increment the timer tick.  This function is called every microsecon. */
+    pAnInfo->CurrentTime_us++;
+
+    /* Set the AbilityMatch, IdleMatch, and AckMatch flags if their */
+    /* corresponding conditions are satisfied. */
+    if(MM_AnRxConfig(pAnInfo, &RxConfig))
+    {
+        if(RxConfig != pAnInfo->AbilityMatchCfg)
+        {
+            pAnInfo->AbilityMatchCfg = RxConfig;
+            pAnInfo->AbilityMatch = AN_FALSE;
+            pAnInfo->AbilityMatchCnt = 0;
+        }
+        else
+        {
+            pAnInfo->AbilityMatchCnt++;
+            if(pAnInfo->AbilityMatchCnt > 1)
+            {
+                pAnInfo->AbilityMatch = AN_TRUE;
+                pAnInfo->AbilityMatchCfg = RxConfig;
+            }
+        }
+
+        if(RxConfig & AN_CONFIG_ACK)
+        {
+            pAnInfo->AckMatch = AN_TRUE;
+        }
+        else
+        {
+            pAnInfo->AckMatch = AN_FALSE;
+        }
+
+        pAnInfo->IdleMatch = AN_FALSE;
+    }
+    else
+    {
+        pAnInfo->IdleMatch = AN_TRUE;
+
+        pAnInfo->AbilityMatchCfg = 0;
+        pAnInfo->AbilityMatchCnt = 0;
+        pAnInfo->AbilityMatch = AN_FALSE;
+        pAnInfo->AckMatch = AN_FALSE;
+
+        RxConfig = 0;
+    }
+
+    /* Save the last Config. */
+    pAnInfo->RxConfig.AsUSHORT = RxConfig;
+
+    /* Default return code. */
+    AnRet = AUTONEG_STATUS_OK;
+
+    /* Autoneg state machine as defined in 802.3z section 37.3.1.5. */
+    switch(pAnInfo->State)
+    {
+        case AN_STATE_UNKNOWN:
+            if(pAnInfo->mr_an_enable || pAnInfo->mr_restart_an)
+            {
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+            }
+
+            /* Fall through.*/
+
+        case AN_STATE_AN_ENABLE:
+            pAnInfo->mr_an_complete = AN_FALSE;
+            pAnInfo->mr_page_rx = AN_FALSE;
+
+            if(pAnInfo->mr_an_enable)
+            {
+                pAnInfo->CurrentTime_us = 0;
+                pAnInfo->LinkTime_us = 0;
+                pAnInfo->AbilityMatchCfg = 0;
+                pAnInfo->AbilityMatchCnt = 0;
+                pAnInfo->AbilityMatch = AN_FALSE;
+                pAnInfo->IdleMatch = AN_FALSE;
+                pAnInfo->AckMatch = AN_FALSE;
+
+                pAnInfo->State = AN_STATE_AN_RESTART_INIT;
+            }
+            else
+            {
+                pAnInfo->State = AN_STATE_DISABLE_LINK_OK;
+            }
+            break;
+
+        case AN_STATE_AN_RESTART_INIT:
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+            pAnInfo->mr_np_loaded = AN_FALSE;
+
+            pAnInfo->TxConfig.AsUSHORT = 0;
+            MM_AnTxConfig(pAnInfo);
+
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            pAnInfo->State = AN_STATE_AN_RESTART;
+
+            /* Fall through.*/
+
+        case AN_STATE_AN_RESTART:
+            /* Get the current time and compute the delta with the saved */
+            /* link timer. */
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+                pAnInfo->State = AN_STATE_ABILITY_DETECT_INIT;
+            }
+            else
+            {
+                AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+            }
+            break;
+
+        case AN_STATE_DISABLE_LINK_OK:
+            AnRet = AUTONEG_STATUS_DONE;
+            break;
+
+        case AN_STATE_ABILITY_DETECT_INIT:
+            /* Note: in the state diagram, this variable is set to */
+            /* mr_adv_ability<12>.  Is this right?. */
+            pAnInfo->mr_toggle_tx = AN_FALSE;
+
+#if DBG
+            DbgMessage(INFORM, ("TxConfig: "));
+
+            if(pAnInfo->mr_adv_full_duplex)
+            {
+                DbgMessage(INFORM, ("FD "));
+            }
+
+            if(pAnInfo->mr_adv_half_duplex)
+            {
+                DbgMessage(INFORM, ("HD "));
+            }
+
+            if(pAnInfo->mr_adv_sym_pause)
+            {
+                DbgMessage(INFORM, ("PS1 "));
+            }
+
+            if(pAnInfo->mr_adv_asym_pause)
+            {
+                DbgMessage(INFORM, ("PS2 "));
+            }
+
+            if(pAnInfo->mr_adv_remote_fault1)
+            {
+                DbgMessage(INFORM, ("RF1 "));
+            }
+
+            if(pAnInfo->mr_adv_remote_fault2)
+            {
+                DbgMessage(INFORM, ("RF2 "));
+            }
+
+            if(pAnInfo->mr_adv_next_page)
+            {
+                DbgMessage(INFORM, ("NP "));
+            }
+
+            DbgMessage(INFORM, ("\n"));
+#endif
+
+            /* Send the config as advertised in the advertisement register. */
+            pAnInfo->TxConfig.AsUSHORT = 0;
+            pAnInfo->TxConfig.D5_FD = pAnInfo->mr_adv_full_duplex;
+            pAnInfo->TxConfig.D6_HD = pAnInfo->mr_adv_half_duplex;
+            pAnInfo->TxConfig.D7_PS1 = pAnInfo->mr_adv_sym_pause;
+            pAnInfo->TxConfig.D8_PS2 = pAnInfo->mr_adv_asym_pause;
+            pAnInfo->TxConfig.D12_RF1 = pAnInfo->mr_adv_remote_fault1;
+            pAnInfo->TxConfig.D13_RF2 = pAnInfo->mr_adv_remote_fault2;
+            pAnInfo->TxConfig.D15_NP = pAnInfo->mr_adv_next_page;
+
+            MM_AnTxConfig(pAnInfo);
+
+            pAnInfo->State = AN_STATE_ABILITY_DETECT;
+
+            break;
+
+        case AN_STATE_ABILITY_DETECT:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT != 0)
+            {
+                pAnInfo->State = AN_STATE_ACK_DETECT_INIT;
+            }
+
+            break;
+
+        case AN_STATE_ACK_DETECT_INIT:
+            pAnInfo->TxConfig.D14_ACK = 1;
+            MM_AnTxConfig(pAnInfo);
+
+            pAnInfo->State = AN_STATE_ACK_DETECT;
+
+            /* Fall through. */
+
+        case AN_STATE_ACK_DETECT:
+            if(pAnInfo->AckMatch == AN_TRUE)
+            {
+                if((pAnInfo->RxConfig.AsUSHORT & ~AN_CONFIG_ACK) ==
+                    (pAnInfo->AbilityMatchCfg & ~AN_CONFIG_ACK))
+                {
+                    pAnInfo->State = AN_STATE_COMPLETE_ACK_INIT;
+                }
+                else
+                {
+                    DbgMessage(FATAL, ("1 ACK_DETECT ===> AN_ENABLE.\n"));
+                    pAnInfo->State = AN_STATE_AN_ENABLE;
+                }
+            }
+            else if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("2 ACK_DETECT ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+            }
+
+            break;
+
+        case AN_STATE_COMPLETE_ACK_INIT:
+            /* Make sure invalid bits are not set. */
+            if(pAnInfo->RxConfig.bits.D0 || pAnInfo->RxConfig.bits.D1 ||
+                pAnInfo->RxConfig.bits.D2 || pAnInfo->RxConfig.bits.D3 ||
+                pAnInfo->RxConfig.bits.D4 || pAnInfo->RxConfig.bits.D9 ||
+                pAnInfo->RxConfig.bits.D10 || pAnInfo->RxConfig.bits.D11)
+            {
+                DbgMessage(FATAL, ("Received an invalid Config.\n"));
+                DbgBreak();
+                AnRet = AUTONEG_STATUS_FAILED;
+                break;
+            }
+
+            /* Set up the link partner advertisement register. */
+            pAnInfo->mr_lp_adv_full_duplex = pAnInfo->RxConfig.D5_FD;
+            pAnInfo->mr_lp_adv_half_duplex = pAnInfo->RxConfig.D6_HD;
+            pAnInfo->mr_lp_adv_sym_pause = pAnInfo->RxConfig.D7_PS1;
+            pAnInfo->mr_lp_adv_asym_pause = pAnInfo->RxConfig.D8_PS2;
+            pAnInfo->mr_lp_adv_remote_fault1 = pAnInfo->RxConfig.D12_RF1;
+            pAnInfo->mr_lp_adv_remote_fault2 = pAnInfo->RxConfig.D13_RF2;
+            pAnInfo->mr_lp_adv_next_page = pAnInfo->RxConfig.D15_NP;
+#if DBG
+            DbgMessage(INFORM, ("RxConfig: "));
+
+            if(pAnInfo->mr_lp_adv_full_duplex)
+            {
+                DbgMessage(INFORM, ("FD "));
+            }
+
+            if(pAnInfo->mr_lp_adv_half_duplex)
+            {
+                DbgMessage(INFORM, ("HD "));
+            }
+
+            if(pAnInfo->mr_lp_adv_sym_pause)
+            {
+                DbgMessage(INFORM, ("PS1 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_asym_pause)
+            {
+                DbgMessage(INFORM, ("PS2 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_remote_fault1)
+            {
+                DbgMessage(INFORM, ("RF1 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_remote_fault2)
+            {
+                DbgMessage(INFORM, ("RF2 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_next_page)
+            {
+                DbgMessage(INFORM, ("NP "));
+            }
+
+            DbgMessage(INFORM, ("\n"));
+#endif
+
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+
+            pAnInfo->mr_toggle_tx = !pAnInfo->mr_toggle_tx;
+            pAnInfo->mr_toggle_rx = pAnInfo->RxConfig.bits.D11;
+            pAnInfo->mr_np_rx = pAnInfo->RxConfig.D15_NP;
+            pAnInfo->mr_page_rx = AN_TRUE;
+
+            pAnInfo->State = AN_STATE_COMPLETE_ACK;
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            break;
+
+        case AN_STATE_COMPLETE_ACK:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("COMPLETE_ACK ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+                break;
+            }
+
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+                if(pAnInfo->mr_adv_next_page == 0 ||
+                    pAnInfo->mr_lp_adv_next_page == 0)
+                {
+                    pAnInfo->State = AN_STATE_IDLE_DETECT_INIT;
+                }
+                else
+                {
+                    if(pAnInfo->TxConfig.bits.D15 == 0 &&
+                        pAnInfo->mr_np_rx == 0)
+                    {
+                        pAnInfo->State = AN_STATE_IDLE_DETECT_INIT;
+                    }
+                    else
+                    {
+                        DbgMessage(FATAL, ("Next page not implemented.\n"));
+                        DbgBreak();
+                        AnRet = AUTONEG_STATUS_FAILED;
+                    }
+                }
+            }
+
+            break;
+
+        case AN_STATE_IDLE_DETECT_INIT:
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+
+            MM_AnTxIdle(pAnInfo);
+
+            pAnInfo->State = AN_STATE_IDLE_DETECT;
+
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            break;
+
+        case AN_STATE_IDLE_DETECT:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("IDLE_DETECT ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+                break;
+            }
+
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+//                if(pAnInfo->IdleMatch == AN_TRUE)
+//                {
+                    pAnInfo->State = AN_STATE_LINK_OK;
+//                }
+//                else
+//                {
+//                    DbgMessage(FATAL, ("Autoneg failed in IDLE_DETECT.\n"));
+//                    AnRet = AUTONEG_STATUS_FAILED;
+//                    break;
+//                }
+            }
+
+            break;
+
+        case AN_STATE_LINK_OK:
+            pAnInfo->mr_an_complete = AN_TRUE;
+            pAnInfo->mr_link_ok = AN_TRUE;
+            AnRet = AUTONEG_STATUS_DONE;
+
+            break;
+
+        case AN_STATE_NEXT_PAGE_WAIT_INIT:
+            DbgMessage(FATAL, ("Not implemented.\n"));
+            DbgBreak();
+            break;
+
+        case AN_STATE_NEXT_PAGE_WAIT:
+            DbgMessage(FATAL, ("Not implemented.\n"));
+            DbgBreak();
+            break;
+
+        default:
+            DbgMessage(FATAL, ("Invalid AN state.\n"));
+            DbgBreak();
+            AnRet = AUTONEG_STATUS_FAILED;
+            break;
+    }
+
+    return AnRet;
+}
+#endif /* INCLUDE_TBI_SUPPORT */
+
diff -urN linux.orig/drivers/net/bcm/autoneg.h linux/drivers/net/bcm/autoneg.h
--- linux.orig/drivers/net/bcm/autoneg.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/autoneg.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,416 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+
+#ifndef AUTONEG_H
+#define AUTONEG_H
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+#define AN_LINK_TIMER_INTERVAL_US           10000       /* 10ms */
+
+/* TRUE, FALSE */
+#define AN_TRUE                             1
+#define AN_FALSE                            0
+
+
+
+/******************************************************************************/
+/* Main data structure for keeping track of 802.3z auto-negotation state */
+/* variables as shown in Figure 37-6 of the IEEE 802.3z specification. */
+/******************************************************************************/
+
+typedef struct
+{
+    /* Current auto-negotiation state. */
+    unsigned long State;
+    #define AN_STATE_UNKNOWN                        0
+    #define AN_STATE_AN_ENABLE                      1
+    #define AN_STATE_AN_RESTART_INIT                2
+    #define AN_STATE_AN_RESTART                     3
+    #define AN_STATE_DISABLE_LINK_OK                4
+    #define AN_STATE_ABILITY_DETECT_INIT            5
+    #define AN_STATE_ABILITY_DETECT                 6
+    #define AN_STATE_ACK_DETECT_INIT                7
+    #define AN_STATE_ACK_DETECT                     8
+    #define AN_STATE_COMPLETE_ACK_INIT              9
+    #define AN_STATE_COMPLETE_ACK                   10
+    #define AN_STATE_IDLE_DETECT_INIT               11
+    #define AN_STATE_IDLE_DETECT                    12
+    #define AN_STATE_LINK_OK                        13
+    #define AN_STATE_NEXT_PAGE_WAIT_INIT            14
+    #define AN_STATE_NEXT_PAGE_WAIT                 16
+
+    /* Link timer. */
+    unsigned long LinkTime_us;
+
+    /* Current time. */
+    unsigned long CurrentTime_us;
+
+    /* Need these values for consistency check. */
+    unsigned short AbilityMatchCfg;
+
+    /* Ability, idle, and ack match functions. */
+    unsigned long AbilityMatchCnt;
+    char AbilityMatch;
+    char IdleMatch;
+    char AckMatch;
+
+    /* Tx config data */
+    union
+    {
+        /* The TxConfig register is arranged as follows:                      */
+        /*                                                                    */
+        /* MSB                                                           LSB  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        /* | D7| D6| D5| D4| D3| D2| D1| D0|D15|D14|D13|D12|D11|D10| D9| D8|  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        struct
+        {
+#ifdef BIG_ENDIAN_HOST
+            unsigned short D7:1;        /* PS1 */
+            unsigned short D6:1;        /* HD */
+            unsigned short D5:1;        /* FD */
+            unsigned short D4:1;
+            unsigned short D3:1;
+            unsigned short D2:1;
+            unsigned short D1:1;
+            unsigned short D0:1;
+            unsigned short D15:1;       /* NP */
+            unsigned short D14:1;       /* ACK */
+            unsigned short D13:1;       /* RF2 */
+            unsigned short D12:1;       /* RF1 */
+            unsigned short D11:1;
+            unsigned short D10:1;
+            unsigned short D9:1;
+            unsigned short D8:1;        /* PS2 */
+#else /* BIG_ENDIAN_HOST */
+            unsigned int D8:1;        /* PS2 */
+            unsigned int D9:1;
+            unsigned int D10:1;
+            unsigned int D11:1;
+            unsigned int D12:1;       /* RF1 */
+            unsigned int D13:1;       /* RF2 */
+            unsigned int D14:1;       /* ACK */
+            unsigned int D15:1;       /* NP */
+            unsigned int D0:1;
+            unsigned int D1:1;
+            unsigned int D2:1;
+            unsigned int D3:1;
+            unsigned int D4:1;
+            unsigned int D5:1;        /* FD */
+            unsigned int D6:1;        /* HD */
+            unsigned int D7:1;        /* PS1 */
+#endif
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define D8_PS2                      bits.D8
+        #define D12_RF1                     bits.D12
+        #define D13_RF2                     bits.D13
+        #define D14_ACK                     bits.D14
+        #define D15_NP                      bits.D15
+        #define D5_FD                       bits.D5
+        #define D6_HD                       bits.D6
+        #define D7_PS1                      bits.D7
+    } TxConfig;
+
+    /* Rx config data */
+    union
+    {
+        /* The RxConfig register is arranged as follows:                      */
+        /*                                                                    */
+        /* MSB                                                           LSB  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        /* | D7| D6| D5| D4| D3| D2| D1| D0|D15|D14|D13|D12|D11|D10| D9| D8|  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        struct
+        {
+#ifdef BIG_ENDIAN_HOST
+	    unsigned short D7:1;        /* PS1 */
+            unsigned short D6:1;        /* HD */
+	    unsigned short D5:1;        /* FD */
+            unsigned short D4:1;
+            unsigned short D3:1;
+            unsigned short D2:1;
+            unsigned short D1:1;
+            unsigned short D0:1;
+  	    unsigned short D15:1;       /* NP */
+            unsigned short D14:1;       /* ACK */
+            unsigned short D13:1;       /* RF2 */    
+            unsigned short D12:1;       /* RF1 */
+            unsigned short D11:1;
+            unsigned short D10:1;
+            unsigned short D9:1;
+            unsigned short D8:1;        /* PS2 */
+#else /* BIG_ENDIAN_HOST */
+            unsigned int D8:1;        /* PS2 */
+            unsigned int D9:1;
+            unsigned int D10:1;
+            unsigned int D11:1;
+            unsigned int D12:1;       /* RF1 */
+            unsigned int D13:1;       /* RF2 */
+            unsigned int D14:1;       /* ACK */
+            unsigned int D15:1;       /* NP */
+            unsigned int D0:1;
+            unsigned int D1:1;
+            unsigned int D2:1;
+            unsigned int D3:1;
+            unsigned int D4:1;
+            unsigned int D5:1;        /* FD */
+            unsigned int D6:1;        /* HD */
+            unsigned int D7:1;        /* PS1 */
+#endif
+        } bits;
+
+        unsigned short AsUSHORT;
+    } RxConfig;
+
+    #define AN_CONFIG_NP                            0x0080
+    #define AN_CONFIG_ACK                           0x0040
+    #define AN_CONFIG_RF2                           0x0020
+    #define AN_CONFIG_RF1                           0x0010
+    #define AN_CONFIG_PS2                           0x0001
+    #define AN_CONFIG_PS1                           0x8000
+    #define AN_CONFIG_HD                            0x4000
+    #define AN_CONFIG_FD                            0x2000
+
+
+    /* Management registers. */
+
+    /* Control register. */
+    union
+    {
+        struct
+        {
+            unsigned int an_enable:1;
+            unsigned int loopback:1;
+            unsigned int reset:1;
+            unsigned int restart_an:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_an_enable                Mr0.bits.an_enable
+        #define mr_loopback                 Mr0.bits.loopback
+        #define mr_main_reset               Mr0.bits.reset
+        #define mr_restart_an               Mr0.bits.restart_an
+    } Mr0;
+
+    /* Status register. */
+    union
+    {
+        struct
+        {
+            unsigned int an_complete:1;
+            unsigned int link_ok:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_an_complete              Mr1.bits.an_complete
+        #define mr_link_ok                  Mr1.bits.link_ok
+    } Mr1;
+
+    /* Advertisement register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_4:5;
+            unsigned int full_duplex:1;
+            unsigned int half_duplex:1;
+            unsigned int sym_pause:1;
+            unsigned int asym_pause:1;
+            unsigned int reserved_11:3;
+            unsigned int remote_fault1:1;
+            unsigned int remote_fault2:1;
+            unsigned int reserved_14:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_adv_full_duplex          Mr4.bits.full_duplex
+        #define mr_adv_half_duplex          Mr4.bits.half_duplex
+        #define mr_adv_sym_pause            Mr4.bits.sym_pause
+        #define mr_adv_asym_pause           Mr4.bits.asym_pause
+        #define mr_adv_remote_fault1        Mr4.bits.remote_fault1
+        #define mr_adv_remote_fault2        Mr4.bits.remote_fault2
+        #define mr_adv_next_page            Mr4.bits.next_page
+    } Mr4;
+
+    /* Link partner advertisement register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_4:5;
+            unsigned int lp_full_duplex:1;
+            unsigned int lp_half_duplex:1;
+            unsigned int lp_sym_pause:1;
+            unsigned int lp_asym_pause:1;
+            unsigned int reserved_11:3;
+            unsigned int lp_remote_fault1:1;
+            unsigned int lp_remote_fault2:1;
+            unsigned int lp_ack:1;
+            unsigned int lp_next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_lp_adv_full_duplex       Mr5.bits.lp_full_duplex
+        #define mr_lp_adv_half_duplex       Mr5.bits.lp_half_duplex
+        #define mr_lp_adv_sym_pause         Mr5.bits.lp_sym_pause
+        #define mr_lp_adv_asym_pause        Mr5.bits.lp_asym_pause
+        #define mr_lp_adv_remote_fault1     Mr5.bits.lp_remote_fault1
+        #define mr_lp_adv_remote_fault2     Mr5.bits.lp_remote_fault2
+        #define mr_lp_adv_next_page         Mr5.bits.lp_next_page
+    } Mr5;
+
+    /* Auto-negotiation expansion register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_0:1;
+            unsigned int page_received:1;
+            unsigned int next_pageable:1;
+            unsigned int reserved_15:13;
+        } bits;
+
+        unsigned short AsUSHORT;
+    } Mr6;
+
+    /* Auto-negotiation next page transmit register. */
+    union
+    {
+        struct
+        {
+            unsigned int code_field:11;
+            unsigned int toggle:1;
+            unsigned int ack2:1;
+            unsigned int message_page:1;
+            unsigned int reserved_14:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_np_tx                    Mr7.AsUSHORT
+    } Mr7;
+
+    /* Auto-negotiation link partner ability register. */
+    union
+    {
+        struct
+        {
+            unsigned int code_field:11;
+            unsigned int toggle:1;
+            unsigned int ack2:1;
+            unsigned int message_page:1;
+            unsigned int ack:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+        
+        #define mr_lp_np_rx                 Mr8.AsUSHORT
+    } Mr8;
+
+    /* Extended status register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_11:12;
+            unsigned int base1000_t_hd:1;
+            unsigned int base1000_t_fd:1;
+            unsigned int base1000_x_hd:1;
+            unsigned int base1000_x_fd:1;
+        } bits;      
+
+        unsigned short AsUSHORT;
+    } Mr15;
+
+    /* Miscellaneous state variables. */
+    union
+    {
+        struct
+        {
+            unsigned int toggle_tx:1;
+            unsigned int toggle_rx:1;
+            unsigned int np_rx:1;
+            unsigned int page_rx:1;
+            unsigned int np_loaded:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_toggle_tx                MrMisc.bits.toggle_tx
+        #define mr_toggle_rx                MrMisc.bits.toggle_rx
+        #define mr_np_rx                    MrMisc.bits.np_rx
+        #define mr_page_rx                  MrMisc.bits.page_rx
+        #define mr_np_loaded                MrMisc.bits.np_loaded
+    } MrMisc;
+
+
+    /* Implement specifics */
+
+    /* Pointer to the operating system specific data structure. */
+    void *pContext;
+} AN_STATE_INFO, *PAN_STATE_INFO;
+
+
+
+/******************************************************************************/
+/* Return code of Autoneg8023z. */
+/******************************************************************************/
+
+typedef enum
+{
+    AUTONEG_STATUS_OK               = 0,
+    AUTONEG_STATUS_DONE             = 1,
+    AUTONEG_STATUS_TIMER_ENABLED    = 2,
+//    AUTONEG_STATUS_FAILED           = 0xffffffff,
+    AUTONEG_STATUS_FAILED           = 0xfffffff
+} AUTONEG_STATUS, *PAUTONEG_STATUS;
+
+
+
+/******************************************************************************/
+/* Function prototypes. */
+/******************************************************************************/
+
+AUTONEG_STATUS Autoneg8023z(PAN_STATE_INFO pAnInfo);
+void AutonegInit(PAN_STATE_INFO pAnInfo);
+
+
+
+/******************************************************************************/
+/* The following functions are defined in the os-dependent module. */
+/******************************************************************************/
+
+void MM_AnTxConfig(PAN_STATE_INFO pAnInfo);
+void MM_AnTxIdle(PAN_STATE_INFO pAnInfo);
+char MM_AnRxConfig(PAN_STATE_INFO pAnInfo, unsigned short *pRxConfig);
+
+
+
+#endif /* AUTONEG_H */
+
diff -urN linux.orig/drivers/net/bcm/b57proc.c linux/drivers/net/bcm/b57proc.c
--- linux.orig/drivers/net/bcm/b57proc.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/b57proc.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,335 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* /proc file system handling code.                                           */
+/*                                                                            */
+/******************************************************************************/
+
+#include "mm.h"
+#ifdef CONFIG_PROC_FS
+
+#define NICINFO_PROC_DIR "nicinfo"
+
+static struct proc_dir_entry *bcm5700_procfs_dir;
+
+extern char bcm5700_driver[], bcm5700_version[];
+
+extern LM_UINT32 bcm5700_crc_count(PUM_DEVICE_BLOCK pUmDevice);
+
+static struct proc_dir_entry *
+proc_getdir(char *name, struct proc_dir_entry *proc_dir)
+{
+	struct proc_dir_entry *pde = proc_dir;
+
+	lock_kernel();
+	for (pde=pde->subdir; pde; pde = pde->next) {
+		if (pde->namelen && (strcmp(name, pde->name) == 0)) {
+			/* directory exists */
+			break;
+		}
+	}
+	if (pde == (struct proc_dir_entry *) 0)
+	{
+		/* create the directory */
+#if (LINUX_VERSION_CODE > 0x20300)
+		pde = proc_mkdir(name, proc_dir);
+#else
+		pde = create_proc_entry(name, S_IFDIR, proc_dir);
+#endif
+		if (pde == (struct proc_dir_entry *) 0) {
+			unlock_kernel();
+			return (pde);
+		}
+	}
+	unlock_kernel();
+	return (pde);
+}
+
+int
+bcm5700_proc_create(void)
+{
+	bcm5700_procfs_dir = proc_getdir(NICINFO_PROC_DIR, proc_net);
+
+	if (bcm5700_procfs_dir == (struct proc_dir_entry *) 0) {
+		printk(KERN_DEBUG "Could not create procfs nicinfo directory %s\n", NICINFO_PROC_DIR);
+		return -1;
+	}
+	return 0;
+}
+
+int
+bcm5700_read_pfs(char *page, char **start, off_t off, int count,
+	int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	int len = 0;
+	LM_UINT32 value32, rx_mac_errors, rx_crc_errors, rx_align_errors;
+	LM_UINT32 rx_runt_errors, rx_frag_errors, rx_long_errors;
+	LM_UINT32 rx_overrun_errors, rx_jabber_errors;
+
+	len += sprintf(page+len, "Description\t\t\t%s\n", pUmDevice->name);
+	len += sprintf(page+len, "Driver_Name\t\t\t%s\n", bcm5700_driver);
+	len += sprintf(page+len, "Driver_Version\t\t\t%s\n", bcm5700_version);
+	len += sprintf(page+len, "PCI_Vendor\t\t\t0x%04x\n", pDevice->PciVendorId);
+	len += sprintf(page+len, "PCI_Device_ID\t\t\t0x%04x\n",
+		pDevice->PciDeviceId);
+	len += sprintf(page+len, "PCI_Subsystem_Vendor\t\t0x%04x\n",
+		pDevice->SubsystemVendorId);
+	len += sprintf(page+len, "PCI_Subsystem_ID\t\t0x%04x\n",
+		pDevice->SubsystemId);
+	len += sprintf(page+len, "PCI_Revision_ID\t\t\t0x%02x\n",
+		pDevice->PciRevId);
+	len += sprintf(page+len, "PCI_Slot\t\t\t%d\n",
+		PCI_SLOT(pUmDevice->pdev->devfn));
+	len += sprintf(page+len, "PCI_Bus\t\t\t\t%d\n",
+		pUmDevice->pdev->bus->number);
+
+	value32 = pDevice->PciState & (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED);
+	len += sprintf(page+len, "PCI_Bus_Speed\t\t\t%s\n",
+		(value32 == (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS)) ? "32-bit PCI 33MHz" : 
+		((value32 == (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED)) ? "32-bit PCI 66MHz" : 
+		((value32 == T3_PCI_STATE_NOT_PCI_X_BUS) ? "64-bit PCI 33MHz" : 
+		((value32 == (T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED)) ? "64-bit PCI 66MHz" : 
+		((value32 == 0) ? "64-bit PCIX 66MHz" : 
+		(value32 == T3_PCI_STATE_HIGH_BUS_SPEED) ? "64-bit PCIX 133MHz":
+			"N/A")))));
+	len += sprintf(page+len, "Memory\t\t\t\t0x%lx\n", pUmDevice->dev->base_addr);
+	len += sprintf(page+len, "IRQ\t\t\t\t%d\n", dev->irq);
+	len += sprintf(page+len, "System_Device_Name\t\t%s\n", dev->name);
+	len += sprintf(page+len, "Current_HWaddr\t\t\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+	len += sprintf(page+len,
+		"Permanent_HWaddr\t\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+		pDevice->NodeAddress[0], pDevice->NodeAddress[1],
+		pDevice->NodeAddress[2], pDevice->NodeAddress[3],
+		pDevice->NodeAddress[4], pDevice->NodeAddress[5]);
+	len += sprintf(page+len, "Part_Number\t\t\t%s\n\n", pDevice->PartNo);
+
+	len += sprintf(page+len, "Link\t\t\t\t%s\n", 
+		(pUmDevice->opened == 0) ? "unknown" :
+    		((pDevice->LinkStatus == LM_STATUS_LINK_ACTIVE) ? "up" :
+		"down"));
+	len += sprintf(page+len, "Speed\t\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+    		((pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) ? "1000" :
+    		((pDevice->LineSpeed == LM_LINE_SPEED_100MBPS) ? "100" :
+    		(pDevice->LineSpeed == LM_LINE_SPEED_10MBPS) ? "10" : "N/A")));
+	len += sprintf(page+len, "Duplex\t\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+		((pDevice->DuplexMode == LM_DUPLEX_MODE_FULL) ? "full" :
+			"half"));
+	len += sprintf(page+len, "Flow_Control\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+		((pDevice->FlowControl == LM_FLOW_CONTROL_NONE) ? "off" :
+		(((pDevice->FlowControl & LM_FLOW_CONTROL_RX_TX_PAUSE) ==
+			LM_FLOW_CONTROL_RX_TX_PAUSE) ? "receive/transmit" :
+		(pDevice->FlowControl & LM_FLOW_CONTROL_RECEIVE_PAUSE) ?
+			"receive" : "transmit")));
+	len += sprintf(page+len, "State\t\t\t\t%s\n", 
+    		(dev->flags & IFF_UP) ? "up" : "down");
+	len += sprintf(page+len, "MTU_Size\t\t\t%d\n\n", dev->mtu);
+	len += sprintf(page+len, "Rx_Packets\t\t\t%u\n", 
+			((pStats == 0) ? 0 :
+			pStats->ifHCInUcastPkts.Low +
+			pStats->ifHCInMulticastPkts.Low +
+			pStats->ifHCInBroadcastPkts.Low));
+	if (dev->mtu > 1500) {
+		len += sprintf(page+len, "Rx_Jumbo_Packets\t\t%u\n", 
+			((pStats == 0) ? 0 :
+			pStats->etherStatsPkts1523Octetsto2047Octets.Low +
+			pStats->etherStatsPkts2048Octetsto4095Octets.Low +
+			pStats->etherStatsPkts4096Octetsto8191Octets.Low +
+			pStats->etherStatsPkts8192Octetsto9022Octets.Low));
+	}
+	len += sprintf(page+len, "Tx_Packets\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->COSIfHCOutPkts[0].Low));
+	len += sprintf(page+len, "Rx_Bytes\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifHCInOctets.Low));
+	len += sprintf(page+len, "Tx_Bytes\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifHCOutOctets.Low));
+	if (pStats == 0) {
+		rx_crc_errors = 0;
+		rx_align_errors = 0;
+		rx_runt_errors = 0;
+		rx_frag_errors = 0;
+		rx_long_errors = 0;
+		rx_overrun_errors = 0;
+		rx_jabber_errors = 0;
+	}
+	else {
+		rx_crc_errors = bcm5700_crc_count(pUmDevice);
+		rx_align_errors = pStats->dot3StatsAlignmentErrors.Low;
+		rx_runt_errors = pStats->etherStatsUndersizePkts.Low;
+		rx_frag_errors = pStats->etherStatsFragments.Low;
+		rx_long_errors = pStats->dot3StatsFramesTooLong.Low;
+		rx_overrun_errors = pStats->nicNoMoreRxBDs.Low;
+		rx_jabber_errors = pStats->etherStatsJabbers.Low;
+	}
+	rx_mac_errors = rx_crc_errors + rx_align_errors + rx_runt_errors +
+		rx_frag_errors + rx_long_errors + rx_jabber_errors;
+	len += sprintf(page+len, "Rx_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		rx_mac_errors + rx_overrun_errors + pUmDevice->rx_misc_errors));
+	len += sprintf(page+len, "Tx_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifOutErrors.Low));
+	len += sprintf(page+len, "\nTx_Carrier_Errors\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->dot3StatsCarrierSenseErrors.Low));
+	len += sprintf(page+len, "Tx_Abort_Excess_Coll\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsExcessiveCollisions.Low));
+	len += sprintf(page+len, "Tx_Abort_Late_Coll\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsLateCollisions.Low));
+	len += sprintf(page+len, "Tx_Deferred_Ok\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsDeferredTransmissions.Low));
+	len += sprintf(page+len, "Tx_Single_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsSingleCollisionFrames.Low));
+	len += sprintf(page+len, "Tx_Multi_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsMultipleCollisionFrames.Low));
+	len += sprintf(page+len, "Tx_Total_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->etherStatsCollisions.Low));
+	len += sprintf(page+len, "\nRx_CRC_Errors\t\t\t%u\n", rx_crc_errors);
+	len += sprintf(page+len, "Rx_Short_Fragment_Errors\t%u\n",
+		rx_frag_errors);
+	len += sprintf(page+len, "Rx_Short_Length_Errors\t\t%u\n",
+		rx_runt_errors);
+	len += sprintf(page+len, "Rx_Long_Length_Errors\t\t%u\n",
+		rx_long_errors);
+	len += sprintf(page+len, "Rx_Align_Errors\t\t\t%u\n",
+		rx_align_errors);
+	len += sprintf(page+len, "Rx_Overrun_Errors\t\t%u\n",
+		rx_overrun_errors);
+	len += sprintf(page+len, "\nTx_MAC_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->dot3StatsInternalMacTransmitErrors.Low));
+	len += sprintf(page+len, "Rx_MAC_Errors\t\t\t%u\n\n",
+		rx_mac_errors);
+
+	len += sprintf(page+len, "Tx_Checksum\t\t\t%s\n",
+		((pDevice->TaskToOffload & LM_TASK_OFFLOAD_TX_TCP_CHECKSUM) ?
+		"ON" : "OFF"));
+	len += sprintf(page+len, "Rx_Checksum\t\t\t%s\n",
+		((pDevice->TaskToOffload & LM_TASK_OFFLOAD_RX_TCP_CHECKSUM) ?
+		"ON" : "OFF"));
+	len += sprintf(page+len, "Scatter_Gather\t\t\t%s\n",
+#if (LINUX_VERSION_CODE >= 0x20400)
+		((dev->features & NETIF_F_SG) ? "ON" : "OFF"));
+#else
+		"OFF");
+#endif
+	len += sprintf(page+len, "Tx_Desc_Count\t\t\t%u\n",
+		pDevice->TxPacketDescCnt);
+	len += sprintf(page+len, "Rx_Desc_Count\t\t\t%u\n",
+		pDevice->RxStdDescCnt);
+	len += sprintf(page+len, "Rx_Jumbo_Desc_Count\t\t%u\n",
+		pDevice->RxJumboDescCnt);
+	len += sprintf(page+len, "Rx_Adaptive_Coalescing\t\t%s\n",
+		(pUmDevice->rx_adaptive_coalesce ? "ON" : "OFF"));
+	len += sprintf(page+len, "Rx_Coalescing_Ticks\t\t%u\n",
+		pUmDevice->rx_curr_coalesce_ticks);
+	len += sprintf(page+len, "Rx_Coalesced_Frames\t\t%u\n",
+		pUmDevice->rx_curr_coalesce_frames);
+	len += sprintf(page+len, "Tx_Coalescing_Ticks\t\t%u\n",
+		pDevice->TxCoalescingTicks);
+	len += sprintf(page+len, "Tx_Coalesced_Frames\t\t%u\n",
+		pDevice->TxMaxCoalescedFrames);
+	len += sprintf(page+len, "Stats_Coalescing_Ticks\t\t%u\n",
+		pDevice->StatsCoalescingTicks);
+	len += sprintf(page+len, "Wake_On_LAN\t\t\t%s\n",
+        	((pDevice->WakeUpMode & LM_WAKE_UP_MODE_MAGIC_PACKET) ?
+		"ON" : "OFF"));
+#if TIGON3_DEBUG
+	len += sprintf(page+len, "\nTx_Zero_Copy_Packets\t\t%u\n",
+		pUmDevice->tx_zc_count);
+	len += sprintf(page+len, "Tx_Chksum_Packets\t\t%u\n",
+		pUmDevice->tx_chksum_count);
+	len += sprintf(page+len, "Tx_Highmem_Fragments\t\t%u\n",
+		pUmDevice->tx_himem_count);
+	len += sprintf(page+len, "Rx_Good_Chksum_Packets\t\t%u\n",
+		pUmDevice->rx_good_chksum_count);
+	len += sprintf(page+len, "Rx_Bad_Chksum_Packets\t\t%u\n",
+		pUmDevice->rx_bad_chksum_count);
+	if (!pDevice->EnableTbi) {
+        	LM_ReadPhy(pDevice, 0, &value32);
+		len += sprintf(page+len, "\nPhy_Register_0x00\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 1, &value32);
+		len += sprintf(page+len, "Phy_Register_0x01\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 2, &value32);
+		len += sprintf(page+len, "Phy_Register_0x02\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 3, &value32);
+		len += sprintf(page+len, "Phy_Register_0x03\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 4, &value32);
+		len += sprintf(page+len, "Phy_Register_0x04\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 5, &value32);
+		len += sprintf(page+len, "Phy_Register_0x05\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 9, &value32);
+		len += sprintf(page+len, "Phy_Register_0x09\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 0xa, &value32);
+		len += sprintf(page+len, "Phy_Register_0x0A\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 0xf, &value32);
+		len += sprintf(page+len, "Phy_Register_0x0F\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 0x10, &value32);
+		len += sprintf(page+len, "Phy_Register_0x10\t\t0x%lx\n", value32);
+        	LM_ReadPhy(pDevice, 0x19, &value32);
+		len += sprintf(page+len, "Phy_Register_0x19\t\t0x%lx\n", value32);
+	}
+#endif
+
+	*eof = 1;
+	return len;
+}
+
+int
+bcm5700_proc_create_dev(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	if (!bcm5700_procfs_dir)
+		return -1;
+
+	sprintf(pUmDevice->pfs_name, "%s.info", dev->name);
+	pUmDevice->pfs_entry = create_proc_entry(pUmDevice->pfs_name,
+		S_IFREG, bcm5700_procfs_dir);
+	if (pUmDevice->pfs_entry == 0)
+		return -1;
+	pUmDevice->pfs_entry->read_proc = bcm5700_read_pfs;
+	pUmDevice->pfs_entry->data = dev;
+	return 0;
+}
+int
+bcm5700_proc_remove_dev(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	remove_proc_entry(pUmDevice->pfs_name, bcm5700_procfs_dir);
+	return 0;
+}
+
+#endif
diff -urN linux.orig/drivers/net/bcm/b57um.c linux/drivers/net/bcm/b57um.c
--- linux.orig/drivers/net/bcm/b57um.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/b57um.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,2468 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/******************************************************************************/
+
+
+char bcm5700_driver[] = "bcm5700";
+char bcm5700_version[] = "2.0.25";
+char bcm5700_date[] = "(10/22/01)";
+
+#define B57UM
+#include "mm.h"
+
+#define TASKLET
+
+/* A few user-configurable values. */
+
+#define MAX_UNITS 16
+/* Used to pass the full-duplex flag, etc. */
+static int line_speed[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int auto_speed[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int full_duplex[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int rx_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int tx_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int auto_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int mtu[MAX_UNITS] = {1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500};	/* Jumbo MTU for interfaces. */
+static int tx_checksum[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int rx_checksum[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int scatter_gather[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+
+#define TX_DESC_CNT DEFAULT_TX_PACKET_DESC_COUNT
+static unsigned int tx_pkt_desc_cnt[MAX_UNITS] =
+	{TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT};
+
+#define RX_DESC_CNT DEFAULT_STD_RCV_DESC_COUNT
+static unsigned int rx_std_desc_cnt[MAX_UNITS] =
+	{RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT };
+
+#define JBO_DESC_CNT DEFAULT_JUMBO_RCV_DESC_COUNT
+static unsigned int rx_jumbo_desc_cnt[MAX_UNITS] =
+	{JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT };
+
+static unsigned int rx_adaptive_coalesce[MAX_UNITS] =
+	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+
+#define RX_COAL_TK DEFAULT_RX_COALESCING_TICKS
+static unsigned int rx_coalesce_ticks[MAX_UNITS] =
+	{RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK, RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK,RX_COAL_TK, RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK};
+
+#define RX_COAL_FM DEFAULT_RX_MAX_COALESCED_FRAMES
+static unsigned int rx_max_coalesce_frames[MAX_UNITS] =
+	{RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM};
+
+#define TX_COAL_TK DEFAULT_TX_COALESCING_TICKS
+static unsigned int tx_coalesce_ticks[MAX_UNITS] =
+	{TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK, TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK,TX_COAL_TK, TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK};
+
+#define TX_COAL_FM DEFAULT_TX_MAX_COALESCED_FRAMES
+static unsigned int tx_max_coalesce_frames[MAX_UNITS] =
+	{TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM};
+
+#define ST_COAL_TK DEFAULT_STATS_COALESCING_TICKS
+static unsigned int stats_coalesce_ticks[MAX_UNITS] =
+	{ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,};
+
+static int enable_wol[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+/* Operational parameters that usually are not changed. */
+/* Time in jiffies before concluding the transmitter is hung. */
+#define TX_TIMEOUT  (2*HZ)
+
+#if (LINUX_VERSION_CODE < 0x02030d)
+#define pci_resource_start(dev, bar)	(dev->base_address[bar] & PCI_BASE_ADDRESS_MEM_MASK)
+#elif (LINUX_VERSION_CODE < 0x02032b)
+#define pci_resource_start(dev, bar)	(dev->resource[bar] & PCI_BASE_ADDRESS_MEM_MASK)
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+#define dev_kfree_skb_irq(skb)  dev_kfree_skb(skb)
+#define netif_wake_queue(dev)	clear_bit(0, &dev->tbusy); mark_bh(NET_BH)
+#define netif_stop_queue(dev)	set_bit(0, &dev->tbusy)
+
+static inline void netif_start_queue(struct net_device *dev)
+{
+	dev->tbusy = 0;
+	dev->interrupt = 0;
+	dev->start = 1;
+}
+
+#define netif_queue_stopped(dev)	dev->tbusy
+#define netif_running(dev)		dev->start
+
+static inline void tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	queue_task(tasklet, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static inline void tasklet_init(struct tasklet_struct *tasklet,
+				void (*func)(unsigned long),
+				unsigned long data)
+{
+        tasklet->next = NULL;
+        tasklet->sync = 0;
+        tasklet->routine = (void (*)(void *))func;
+        tasklet->data = (void *)data;
+}
+
+#define tasklet_kill(tasklet)
+
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020300)
+struct pci_device_id {
+	unsigned int vendor, device;		/* Vendor and device ID or PCI_ANY_ID */
+	unsigned int subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
+	unsigned int class, class_mask;		/* (class,subclass,prog-if) triplet */
+	unsigned long driver_data;		/* Data private to the driver */
+};
+
+#define PCI_ANY_ID		0
+
+#define pci_set_drvdata(pdev, dev)
+#define pci_get_drvdata(pdev) 0
+
+#define pci_enable_device(pdev) 0
+
+#define __devinit		__init
+#define __devinitdata		__initdata
+#define __devexit
+
+#define SET_MODULE_OWNER(dev)
+#define MODULE_DEVICE_TABLE(pci, pci_tbl)
+
+#endif
+
+
+#if (LINUX_VERSION_CODE < 0x02032a)
+static inline void *pci_alloc_consistent(struct pci_dev *pdev, size_t size,
+					 dma_addr_t *dma_handle)
+{
+	void *virt_ptr;
+
+	/* Maximum in slab.c */
+	if (size > 131072)
+		return 0;
+
+	virt_ptr = kmalloc(size, GFP_KERNEL);
+	*dma_handle = virt_to_bus(virt_ptr);
+	return virt_ptr;
+}
+#define pci_free_consistent(cookie, size, ptr, dma_ptr)	kfree(ptr)
+#define pci_map_single(cookie, address, size, dir)	virt_to_bus(address)
+#define pci_unmap_single(cookie, address, size, dir)
+
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020329)
+#define pci_set_dma_mask(pdev, mask) (0)
+#else
+#if (LINUX_VERSION_CODE < 0x020403)
+int
+pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask)
+{
+    if(! pci_dma_supported(dev, mask))
+        return -EIO;
+
+    dev->dma_mask = mask;
+
+    return 0;
+}
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020402)
+#define pci_request_regions(pdev, name) (0)
+#define pci_release_regions(pdev)
+#endif
+
+/*
+ * bcm_pci_map_single_high() is based on code in acenic.c
+ */
+#if MAX_SKB_FRAGS
+#if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)
+
+typedef unsigned long long dmaaddr_high_t;
+
+static inline dmaaddr_high_t
+bcm_pci_map_single_high(struct pci_dev *hwdev, struct page *page,
+		    int offset, size_t size, int dir)
+{
+	dmaaddr_high_t phys;
+
+	phys = (page-mem_map) *	(dmaaddr_high_t) PAGE_SIZE + offset;
+
+	return phys;
+}
+
+#define bcm_pci_unmap_single_high(hwdev, map, size, dir)
+
+#else
+
+typedef dma_addr_t dmaaddr_high_t;
+
+static inline dmaaddr_high_t
+bcm_pci_map_single_high(struct pci_dev *hwdev, struct page *page,
+		    int offset, size_t size, int dir)
+{
+	return pci_map_single(hwdev, page_address(page) + offset, size, dir);
+}
+
+#define bcm_pci_unmap_single_high pci_unmap_single
+
+#endif
+#endif
+
+#define set_64bit_addr(paddr, low, high) \
+	(paddr)->Low = low;		\
+	(paddr)->High = high;
+
+static inline void bcm_set_addr(LM_PHYSICAL_ADDRESS *paddr, dma_addr_t addr)
+{
+	unsigned long baddr = (unsigned long) addr;
+#if (BITS_PER_LONG == 64)
+	set_64bit_addr(paddr, baddr & 0xffffffff, baddr >> 32);
+#else
+	set_64bit_addr(paddr, baddr, 0);
+#endif
+}
+
+#if MAX_SKB_FRAGS
+static inline void bcm_set_addr_high(LM_PHYSICAL_ADDRESS *paddr, dmaaddr_high_t addr)
+{
+#if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)
+	set_64bit_addr(paddr, (unsigned long) (addr & 0xffffffff),
+		(unsigned long) (addr >> 32));
+#else
+	bcm_set_addr(paddr, (dma_addr_t) addr);
+#endif
+}
+#endif
+
+#if ! defined(spin_is_locked)
+#define spin_is_locked(lock)    (test_bit(0,(lock)))
+#endif
+
+inline long
+bcm5700_lock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	long flags;
+	
+	if (pUmDevice->do_global_lock) {
+		spin_lock_irqsave(&pUmDevice->global_lock, flags);
+		return flags;
+	}
+	return 0;
+}
+
+inline void
+bcm5700_unlock(PUM_DEVICE_BLOCK pUmDevice, long flags)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_unlock_irqrestore(&pUmDevice->global_lock, flags);
+	}
+}
+
+inline int
+bcm5700_trylock(PUM_DEVICE_BLOCK pUmDevice, long *flags)
+{
+	if (pUmDevice->do_global_lock) {
+		if (spin_is_locked(&pUmDevice->global_lock))
+			return 0;
+		spin_lock_irqsave(&pUmDevice->global_lock, *flags);
+		return 1;
+	}
+	return 1;
+}
+
+inline void
+bcm5700_intr_lock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_lock(&pUmDevice->global_lock);
+	}
+}
+
+inline void
+bcm5700_intr_unlock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_unlock(&pUmDevice->global_lock);
+	}
+}
+
+/*
+ * Broadcom NIC Extension support
+ * -ffan
+ */
+#ifdef NICE_SUPPORT
+#include "nicext.h"
+
+typedef struct {
+	ushort  tag;
+	ushort  signature;
+} vlan_tag_t;
+
+#endif /* NICE_SUPPORT */
+
+typedef union {
+	dma_addr_t dma_map;
+#if MAX_SKB_FRAGS
+	dmaaddr_high_t dma_map_high;
+#endif
+} dma_map_t;
+
+typedef struct _UM_PACKET {
+	LM_PACKET lm_packet;
+	struct sk_buff *skbuff;
+#if MAX_SKB_FRAGS
+	dma_map_t map[MAX_SKB_FRAGS + 1];
+	size_t map_len[MAX_SKB_FRAGS + 1];
+#else
+	dma_map_t map[1];
+	size_t map_len[1];
+#endif
+	LM_FRAG_LIST frag_list;
+#if MAX_SKB_FRAGS
+        LM_FRAG frag_list_bufs[MAX_SKB_FRAGS];
+#endif
+} UM_PACKET, *PUM_PACKET;
+
+int MM_Packet_Desc_Size = sizeof(UM_PACKET);
+
+#if defined(MODULE)
+MODULE_AUTHOR("Michael Chan <mchan@broadcom.com>");
+MODULE_DESCRIPTION("BCM5700 Driver");
+MODULE_PARM(debug, "i");
+MODULE_PARM(line_speed, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(auto_speed, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(full_duplex, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(auto_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(mtu, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_checksum, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_checksum, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(scatter_gather, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_pkt_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_std_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_jumbo_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_adaptive_coalesce, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_max_coalesce_frames, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_max_coalesce_frames, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(stats_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(enable_wol, "1-" __MODULE_STRING(MAX_UNITS) "i");
+#endif
+
+#define RUN_AT(x) (jiffies + (x))
+
+char kernel_version[] = UTS_RELEASE;
+
+#define PCI_SUPPORT_VER2
+
+#if ! defined(CAP_NET_ADMIN)
+#define capable(CAP_XXX) (suser())
+#endif
+
+#define tigon3_debug debug
+#if TIGON3_DEBUG
+static int tigon3_debug = TIGON3_DEBUG;
+#else
+static int tigon3_debug = 0;
+#endif
+
+
+#if DBG
+#define STATIC
+#else
+#define STATIC static
+#endif
+
+STATIC int bcm5700_open(struct net_device *dev);
+STATIC void bcm5700_timer(unsigned long data);
+STATIC void bcm5700_tx_timeout(struct net_device *dev);
+STATIC int bcm5700_start_xmit(struct sk_buff *skb, struct net_device *dev);
+STATIC void bcm5700_interrupt(int irq, void *dev_instance, struct pt_regs *regs);
+STATIC void bcm5700_tasklet(unsigned long data);
+STATIC int bcm5700_close(struct net_device *dev);
+STATIC struct net_device_stats *bcm5700_get_stats(struct net_device *dev);
+STATIC int bcm5700_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+STATIC void bcm5700_set_rx_mode(struct net_device *dev);
+STATIC int bcm5700_set_mac_addr(struct net_device *dev, void *p);
+STATIC int replenish_rx_buffers(PUM_DEVICE_BLOCK pUmDevice);
+STATIC int check_4G_boundary(PUM_DEVICE_BLOCK pUmDevice, PUM_PACKET pUmPacket);
+STATIC int bcm5700_freemem(struct net_device *dev);
+STATIC int bcm5700_adapt_rx_coalesce(PUM_DEVICE_BLOCK pUmDevice);
+
+
+/* A list of all installed bcm5700 devices. */
+static struct net_device *root_tigon3_dev = NULL;
+
+typedef enum {
+	BCM5700A6 = 0,
+	BCM5700T6,
+	BCM5700A9,
+	BCM5700T9,
+	BCM5700,
+	BCM5701A5,
+	BCM5701T1,
+	BCM5701T8,
+	BCM5701A7,
+	BCM5701A10,
+	BCM5701A12,
+	BCM5701,
+	BCM5703,
+	TC996T,
+	TC996ST,
+	TC996SSX,
+	TC996SX,
+	TC996BT,
+	TC997T,
+	TC997SX,
+	TC1000T,
+	TC940BR01,
+	TC942BR01,
+	NC6770,
+	NC7770,
+	NC7780,
+} board_t;
+
+
+/* indexed by board_t, above */
+static struct {
+	char *name;
+} board_info[] __devinitdata = {
+	{ "Broadcom BCM5700 1000Base-T" },
+	{ "Broadcom BCM5700 1000Base-SX" },
+	{ "Broadcom BCM5700 1000Base-SX" },
+	{ "Broadcom BCM5700 1000Base-T" },
+	{ "Broadcom BCM5700" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-SX" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701" },
+	{ "Broadcom BCM5703" },
+	{ "3Com 3C996 10/100/1000 Server NIC" },
+	{ "3Com 3C996 10/100/1000 Server NIC" },
+	{ "3Com 3C996 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C996 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C996B Gigabit Server NIC" },
+	{ "3Com 3C997 Gigabit Server NIC" },
+	{ "3Com 3C997 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C1000 Gigabit NIC" },
+	{ "3Com 3C940 Gigabit LOM (21X21)" },
+	{ "3Com 3C942 Gigabit LOM (31X31)" },
+	{ "Compaq NC6770 Gigabit Server Adapter" },
+	{ "Compaq NC7770 Gigabit Server Adapter" },
+	{ "Compaq NC7780 Gigabit Server Adapter" },
+	{ 0 },
+	};
+
+static struct pci_device_id bcm5700_pci_tbl[] __devinitdata = {
+	{0x14e4, 0x1644, 0x14e4, 0x1644, 0, 0, BCM5700A6 },
+	{0x14e4, 0x1644, 0x14e4, 0x2, 0, 0, BCM5700T6 },
+	{0x14e4, 0x1644, 0x14e4, 0x3, 0, 0, BCM5700A9 },
+	{0x14e4, 0x1644, 0x14e4, 0x4, 0, 0, BCM5700T9 },
+	{0x14e4, 0x1644, 0x1028, 0xd1, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x0106, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x0109, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x010a, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x10b7, 0x1000, 0, 0, TC996T },
+	{0x14e4, 0x1644, 0x10b7, 0x1001, 0, 0, TC996ST },
+	{0x14e4, 0x1644, 0x10b7, 0x1002, 0, 0, TC996SSX },
+	{0x14e4, 0x1644, 0x10b7, 0x1003, 0, 0, TC997T },
+	{0x14e4, 0x1644, 0x10b7, 0x1005, 0, 0, TC997SX },
+	{0x14e4, 0x1644, 0x10b7, 0x1008, 0, 0, TC942BR01 },
+	{0x14e4, 0x1644, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5700 },
+	{0x14e4, 0x1645, 0x14e4, 1, 0, 0, BCM5701A5 },
+	{0x14e4, 0x1645, 0x14e4, 5, 0, 0, BCM5701T1 },
+	{0x14e4, 0x1645, 0x14e4, 6, 0, 0, BCM5701T8 },
+	{0x14e4, 0x1645, 0x14e4, 7, 0, 0, BCM5701A7 },
+	{0x14e4, 0x1645, 0x14e4, 8, 0, 0, BCM5701A10 },
+	{0x14e4, 0x1645, 0x14e4, 0x8008, 0, 0, BCM5701A12 },
+	{0x14e4, 0x1645, 0x0e11, 0x7d, 0, 0, NC6770 },
+	{0x14e4, 0x1645, 0x0e11, 0x7c, 0, 0, NC7770 },
+	{0x14e4, 0x1645, 0x0e11, 0x85, 0, 0, NC7780 },
+	{0x14e4, 0x1645, 0x10b7, 0x1004, 0, 0, TC996SX },
+	{0x14e4, 0x1645, 0x10b7, 0x1006, 0, 0, TC996BT },
+	{0x14e4, 0x1645, 0x10b7, 0x1007, 0, 0, TC1000T },
+	{0x14e4, 0x1645, 0x10b7, 0x1008, 0, 0, TC940BR01 },
+	{0x14e4, 0x1645, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5701 },
+	{0x14e4, 0x1647, 0x14e4, 0x0009, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, 0x14e4, 0x8009, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, 0x0e11, 0x9a, 0, 0, NC7770 },
+	{0x14e4, 0x1647, 0x0e11, 0x99, 0, 0, NC7780 },
+	{0x14e4, 0x1647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5703 },
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, bcm5700_pci_tbl);
+
+#ifdef CONFIG_PROC_FS
+extern int bcm5700_proc_create(void);
+extern int bcm5700_proc_create_dev(struct net_device *dev);
+extern int bcm5700_proc_remove_dev(struct net_device *dev);
+#endif
+
+static int __devinit bcm5700_init_board(struct pci_dev *pdev,
+					struct net_device **dev_out,
+					int board_idx)
+{
+	struct net_device *dev;
+	PUM_DEVICE_BLOCK pUmDevice;
+	PLM_DEVICE_BLOCK pDevice;
+	int rc;
+
+	*dev_out = NULL;
+
+	/* dev zeroed in init_etherdev */
+	dev = init_etherdev(NULL, sizeof(*pUmDevice));
+	if (dev == NULL) {
+		printk (KERN_ERR "%s: unable to alloc new ethernet\n",
+			bcm5700_driver);
+		return -ENOMEM;
+	}
+	SET_MODULE_OWNER(dev);
+	pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	/* enable device (incl. PCI PM wakeup), and bus-mastering */
+	rc = pci_enable_device (pdev);
+	if (rc)
+		goto err_out;
+
+	rc = pci_request_regions(pdev, bcm5700_driver);
+	if (rc)
+		goto err_out;
+
+	pci_set_master(pdev);
+
+	if (pci_set_dma_mask(pdev, ~(0UL)) != 0) {
+		printk(KERN_ERR "System does not support DMA\n");
+		pci_release_regions(pdev);
+		goto err_out;
+	}
+
+	pUmDevice->dev = dev;
+	pUmDevice->pdev = pdev;
+	pUmDevice->mem_list_num = 0;
+	pUmDevice->next_module = root_tigon3_dev;
+	pUmDevice->index = board_idx;
+	root_tigon3_dev = dev;
+
+	spin_lock_init(&pUmDevice->global_lock);
+
+	spin_lock_init(&pUmDevice->undi_lock);
+
+
+	pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	if (mtu[board_idx] > 1500) {
+		if (mtu[board_idx] > 9000) {
+			dev->mtu = 9000;
+			printk(KERN_WARNING "%s: Invalid mtu parameter (%d), using 9000\n", dev->name, mtu[board_idx]);
+		}
+		else
+			dev->mtu = mtu[board_idx];
+	}
+	else if (mtu[board_idx] < 1500) {
+		printk(KERN_WARNING "%s: Invalid mtu parameter (%d), using 1500\n", dev->name, mtu[board_idx]);
+	}
+
+	if (LM_GetAdapterInfo(pDevice) != LM_STATUS_SUCCESS) {
+		printk(KERN_ERR "Get Adapter info failed\n");
+		rc = -ENODEV;
+		goto err_out_unmap;
+	}
+
+	pUmDevice->do_global_lock = 0;
+	if (T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5700) {
+		/* The 5700 chip works best without interleaved register */
+		/* accesses on certain machines. */
+		pUmDevice->do_global_lock = 1;
+	}
+	dev->base_addr = pci_resource_start(pdev, 0);
+	dev->irq = pDevice->Irq = pdev->irq;
+
+	*dev_out = dev;
+	return 0;
+
+err_out_unmap:
+	pci_release_regions(pdev);
+	bcm5700_freemem(dev);
+
+err_out:
+	unregister_netdev(dev);
+	kfree (dev);
+	return rc;
+}
+
+static int __devinit
+bcm5700_print_ver(void)
+{
+	printk(KERN_INFO "Broadcom Gigabit Ethernet Driver %s ",
+		bcm5700_driver);
+#ifdef NICE_SUPPORT
+	printk("with Broadcom NIC Extension (NICE) ");
+#endif
+	printk("ver. %s %s\n", bcm5700_version, bcm5700_date);
+	return 0;
+}
+
+static int __devinit
+bcm5700_init_one(struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	struct net_device *dev = NULL;
+	PUM_DEVICE_BLOCK pUmDevice;
+	PLM_DEVICE_BLOCK pDevice;
+	int i;
+	static int board_idx = -1;
+	static int printed_version = 0;
+	struct pci_dev *amd_dev;
+
+	board_idx++;
+
+	if (!printed_version) {
+		bcm5700_print_ver();
+#ifdef CONFIG_PROC_FS
+		bcm5700_proc_create();
+#endif
+		printed_version = 1;
+	}
+
+	i = bcm5700_init_board(pdev, &dev, board_idx);
+	if (i < 0) {
+		return i;
+	}
+
+	if (dev == NULL)
+		return -ENOMEM;
+
+	dev->open = bcm5700_open;
+	dev->hard_start_xmit = bcm5700_start_xmit;
+	dev->stop = bcm5700_close;
+	dev->get_stats = bcm5700_get_stats;
+	dev->set_multicast_list = bcm5700_set_rx_mode;
+	dev->do_ioctl = bcm5700_ioctl;
+	dev->set_mac_address = &bcm5700_set_mac_addr;
+#if (LINUX_VERSION_CODE >= 0x20400)
+	dev->tx_timeout = bcm5700_tx_timeout;
+	dev->watchdog_timeo = TX_TIMEOUT;
+#endif
+
+	pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	dev->base_addr = pci_resource_start(pdev, 0);
+	dev->irq = pdev->irq;
+
+	pci_set_drvdata(pdev, dev);
+
+	memcpy(dev->dev_addr, pDevice->NodeAddress, 6);
+	pUmDevice->name = board_info[ent->driver_data].name,
+	printk(KERN_INFO "%s: %s found at mem %lx, IRQ %d, ",
+		dev->name, pUmDevice->name, dev->base_addr,
+		dev->irq);
+	printk("node addr ");
+	for (i = 0; i < 6; i++) {
+		printk("%2.2x", dev->dev_addr[i]);
+	}
+	printk("\n");
+
+	printk(KERN_INFO "%s: ", dev->name);
+	if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5400_PHY_ID)
+		printk("Broadcom BCM5400 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+		printk("Broadcom BCM5401 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5411_PHY_ID)
+		printk("Broadcom BCM5411 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5701_PHY_ID)
+		printk("Broadcom BCM5701 Integrated Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM8002_PHY_ID)
+		printk("Broadcom BCM8002 SerDes ");
+	else if (pDevice->EnableTbi)
+		printk("Agilent HDMP-1636 SerDes ");
+	else
+		printk("Unknown ");
+	printk("transceiver found\n");
+
+	printk(KERN_INFO "%s: ", dev->name);
+#if (LINUX_VERSION_CODE >= 0x20400)
+	if (scatter_gather[board_idx]) {
+		dev->features |= NETIF_F_SG | NETIF_F_HIGHDMA;
+	}
+	if ((pDevice->ChipRevId != T3_CHIP_ID_5700_B0) &&
+		tx_checksum[board_idx]) {
+		dev->features |= NETIF_F_IP_CSUM;
+	}
+
+	printk("Scatter-gather %s, 64-bit DMA %s, Tx Checksum %s, ",
+		(char *) ((dev->features & NETIF_F_SG) ? "ON" : "OFF"),
+		(char *) ((dev->features & NETIF_F_HIGHDMA) ? "ON" : "OFF"),
+		(char *) ((dev->features & NETIF_F_IP_CSUM) ? "ON" : "OFF"));
+#endif
+	if ((pDevice->ChipRevId != T3_CHIP_ID_5700_B0) &&
+		rx_checksum[board_idx])
+		printk("Rx Checksum ON\n");
+	else
+		printk("Rx Checksum OFF\n");
+
+#ifdef CONFIG_PROC_FS
+	bcm5700_proc_create_dev(dev);
+#endif
+#ifdef TASKLET
+	tasklet_init(&pUmDevice->tasklet, bcm5700_tasklet,
+		(unsigned long) pUmDevice);
+#endif
+	if ((amd_dev = pci_find_device(0x1022, 0x700c, NULL))) {
+		u32 val;
+
+		/* Found AMD 762 North bridge */
+		pci_read_config_dword(amd_dev, 0x4c, &val);
+		if ((val & 0x02) == 0) {
+			pci_write_config_dword(amd_dev, 0x4c, val | 0x02);
+			printk(KERN_INFO "%s: Setting AMD762 Northbridge to enable PCI ordering compliance\n", bcm5700_driver);
+		}
+	}
+	return 0;
+
+}
+
+
+static void __devexit
+bcm5700_remove_one (struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata (pdev);
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+
+#ifdef CONFIG_PROC_FS
+	bcm5700_proc_remove_dev(dev); 
+#endif
+	unregister_netdev(dev);
+
+	if (pUmDevice->lm_dev.pMappedMemBase)
+		iounmap(pUmDevice->lm_dev.pMappedMemBase);
+
+	pci_release_regions(pdev);
+
+	kfree(dev);
+
+	pci_set_drvdata(pdev, NULL);
+
+/*	pci_power_off(pdev, -1);*/
+
+}
+
+int __devinit
+bcm5700_probe(struct net_device *dev)
+{
+	int cards_found = 0;
+	struct pci_dev *pdev = NULL;
+	struct pci_device_id *pci_tbl;
+	u16 ssvid, ssid;
+
+	if ( ! pci_present())
+		return -ENODEV;
+
+	pci_tbl = bcm5700_pci_tbl;
+	while ((pdev = pci_find_class(PCI_CLASS_NETWORK_ETHERNET << 8, pdev))) {
+		int idx;
+
+		pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &ssvid);
+		pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &ssid);
+		for (idx = 0; pci_tbl[idx].vendor; idx++) {
+			if ((pci_tbl[idx].vendor == PCI_ANY_ID ||
+				pci_tbl[idx].vendor == pdev->vendor) &&
+				(pci_tbl[idx].device == PCI_ANY_ID ||
+				pci_tbl[idx].device == pdev->device) &&
+				(pci_tbl[idx].subvendor == PCI_ANY_ID ||
+				pci_tbl[idx].subvendor == ssvid) &&
+				(pci_tbl[idx].subdevice == PCI_ANY_ID ||
+				pci_tbl[idx].subdevice == ssid))
+			{
+
+				break;
+			}
+		}
+		if (pci_tbl[idx].vendor == 0)
+			continue;
+
+
+		if (bcm5700_init_one(pdev, &pci_tbl[idx]) == 0)
+			cards_found++;
+	}
+
+	return cards_found ? 0 : -ENODEV;
+}
+
+
+
+STATIC int
+bcm5700_open(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	int index;
+
+	index = pUmDevice->index;
+	if (pDevice->ChipRevId == T3_CHIP_ID_5700_B0) {
+		pDevice->TaskToOffload = LM_TASK_OFFLOAD_NONE; 
+	}
+	else {
+		if (rx_checksum[index]) {
+			pDevice->TaskToOffload |=
+				LM_TASK_OFFLOAD_RX_TCP_CHECKSUM |
+				LM_TASK_OFFLOAD_RX_UDP_CHECKSUM;
+		}
+		if (tx_checksum[index]) {
+			pDevice->TaskToOffload |=
+				LM_TASK_OFFLOAD_TX_TCP_CHECKSUM |
+				LM_TASK_OFFLOAD_TX_UDP_CHECKSUM;
+			pDevice->NoTxPseudoHdrChksum = TRUE;
+		}
+	}
+	/* delay for 4 seconds */
+	pUmDevice->delayed_link_ind = (4 * HZ) / pUmDevice->timer_interval;
+
+	pUmDevice->adaptive_expiry = HZ / pUmDevice->timer_interval;
+
+	/* Sometimes we get spurious ints. after reset when link is down. */
+	/* This field tells the isr to service the int. even if there is */
+	/* no status block update. */
+	pUmDevice->adapter_just_inited = (3 * HZ) / pUmDevice->timer_interval;
+
+	if (request_irq(dev->irq, &bcm5700_interrupt, SA_SHIRQ, dev->name, dev)) {
+		return -EAGAIN;
+	}
+
+	pUmDevice->opened = 1;
+#if TIGON3_DEBUG
+	pUmDevice->tx_zc_count = 0;
+	pUmDevice->tx_chksum_count = 0;
+	pUmDevice->tx_himem_count = 0;
+	pUmDevice->rx_good_chksum_count = 0;
+	pUmDevice->rx_bad_chksum_count = 0;
+#endif
+	if (LM_InitializeAdapter(pDevice) != LM_STATUS_SUCCESS) {
+		free_irq(dev->irq, dev);
+		bcm5700_freemem(dev);
+		return -EAGAIN;
+	}
+
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+
+	if (tigon3_debug > 1)
+		printk(KERN_DEBUG "%s: tigon3_open() irq %d.\n", dev->name, dev->irq);
+
+	QQ_InitQueue(&pUmDevice->rx_out_of_buf_q.Container,
+        MAX_RX_PACKET_DESC_COUNT);
+	netif_start_queue(dev);
+
+#if (LINUX_VERSION_CODE < 0x020300)
+	MOD_INC_USE_COUNT;
+#endif
+
+	init_timer(&pUmDevice->timer);
+	pUmDevice->timer.expires = RUN_AT(pUmDevice->timer_interval);
+	pUmDevice->timer.data = (unsigned long)dev;
+	pUmDevice->timer.function = &bcm5700_timer;
+	add_timer(&pUmDevice->timer);
+
+	LM_EnableInterrupt(pDevice);
+
+	return 0;
+}
+
+STATIC void
+bcm5700_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	long flags;
+
+	if (!pUmDevice->opened)
+		return;
+
+	if (pUmDevice->delayed_link_ind > 0) {
+		if (pUmDevice->delayed_link_ind == 1)
+			MM_IndicateStatus(pDevice, pDevice->LinkStatus);
+		else
+			pUmDevice->delayed_link_ind--;
+	}
+	if (pUmDevice->adapter_just_inited > 0) {
+		pUmDevice->adapter_just_inited--;
+	}
+
+	if (!pUmDevice->interrupt) {
+		if (!pDevice->UseTaggedStatus) {
+			flags = bcm5700_lock(pUmDevice);
+			if (pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) {
+				/* This will generate an interrupt */
+				REG_WR(pDevice, Grc.LocalCtrl,
+					pDevice->GrcLocalCtrl |
+					GRC_MISC_LOCAL_CTRL_SET_INT);
+			}
+			else {
+				REG_WR(pDevice, HostCoalesce.Mode,
+					HOST_COALESCE_ENABLE |
+					HOST_COALESCE_NOW);
+			}
+			if (!(REG_RD(pDevice, DmaWrite.Mode) &
+				DMA_WRITE_MODE_ENABLE)) {
+				bcm5700_tx_timeout(dev);
+			}
+			bcm5700_unlock(pUmDevice, flags);
+			if (pUmDevice->tx_queued) {
+				pUmDevice->tx_queued = 0;
+				netif_wake_queue(dev);
+			}
+		}
+#if (LINUX_VERSION_CODE < 0x02032b)
+		if ((QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) !=
+			pDevice->TxPacketDescCnt) &&
+			((jiffies - dev->trans_start) > TX_TIMEOUT)) {
+
+			printk(KERN_WARNING "%s: Tx hung\n", dev->name);
+			bcm5700_tx_timeout(dev);
+		}
+#endif
+	}
+	if (pUmDevice->rx_adaptive_coalesce) {
+		pUmDevice->adaptive_expiry--;
+		if (pUmDevice->adaptive_expiry == 0) {	
+			pUmDevice->adaptive_expiry = HZ /
+				pUmDevice->timer_interval;
+			bcm5700_adapt_rx_coalesce(pUmDevice);
+		}
+	}
+	if (QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container) >=
+		pUmDevice->rx_buf_repl_panic_thresh) {
+		/* Generate interrupt and let isr allocate buffers */
+		REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+			GRC_MISC_LOCAL_CTRL_SET_INT);
+	}
+
+	pUmDevice->timer.expires = RUN_AT(pUmDevice->timer_interval);
+	add_timer(&pUmDevice->timer);
+}
+
+STATIC int
+bcm5700_adapt_rx_coalesce(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	uint rx_curr_cnt, tx_curr_cnt, rx_delta, tx_delta, total_delta;
+	long flags;
+
+	rx_curr_cnt = pDevice->pStatsBlkVirt->ifHCInUcastPkts.Low;
+	tx_curr_cnt = pDevice->pStatsBlkVirt->COSIfHCOutPkts[0].Low;
+	if ((rx_curr_cnt <= pUmDevice->rx_last_cnt) ||
+		(tx_curr_cnt <= pUmDevice->tx_last_cnt)) {
+
+		/* skip if there is counter rollover */
+		pUmDevice->rx_last_cnt = rx_curr_cnt;
+		pUmDevice->tx_last_cnt = tx_curr_cnt;
+		return 0;
+	}
+
+	rx_delta = rx_curr_cnt - pUmDevice->rx_last_cnt;
+	tx_delta = tx_curr_cnt - pUmDevice->tx_last_cnt;
+	total_delta = rx_delta + tx_delta;
+
+	pUmDevice->rx_last_cnt = rx_curr_cnt;
+	pUmDevice->tx_last_cnt = tx_curr_cnt;
+
+	if (total_delta < rx_delta)
+		return 0;
+
+	if (total_delta < ADAPTIVE_LO_PKT_THRESH) {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+			pUmDevice->rx_curr_coalesce_frames =
+				ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				ADAPTIVE_LO_RX_COALESCING_TICKS;
+
+    			REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+				ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES);
+
+			REG_WR(pDevice, HostCoalesce.RxCoalescingTicks,
+				ADAPTIVE_LO_RX_COALESCING_TICKS);
+			bcm5700_unlock(pUmDevice, flags);
+		}
+	}
+	else if (total_delta < ADAPTIVE_HI_PKT_THRESH) {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			DEFAULT_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+			pUmDevice->rx_curr_coalesce_frames = 
+				DEFAULT_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				DEFAULT_RX_COALESCING_TICKS;
+
+    			REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+				DEFAULT_RX_MAX_COALESCED_FRAMES);
+
+			REG_WR(pDevice, HostCoalesce.RxCoalescingTicks,
+				DEFAULT_RX_COALESCING_TICKS);
+			bcm5700_unlock(pUmDevice, flags);
+		}
+	}
+	else {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+			pUmDevice->rx_curr_coalesce_frames = 
+				ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				ADAPTIVE_HI_RX_COALESCING_TICKS;
+
+    			REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+				ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES);
+
+			REG_WR(pDevice, HostCoalesce.RxCoalescingTicks,
+				ADAPTIVE_HI_RX_COALESCING_TICKS);
+			bcm5700_unlock(pUmDevice, flags);
+		}
+	}
+	return 0;
+}
+
+STATIC void
+bcm5700_tx_timeout(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	netif_stop_queue(dev);
+	LM_DisableInterrupt(pDevice);
+	LM_ResetAdapter(pDevice);	
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+	LM_EnableInterrupt(pDevice);
+	netif_wake_queue(dev);
+}
+
+
+STATIC int
+bcm5700_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	PLM_FRAG_LIST pfrag_list;
+	long flags;
+	unsigned int len;
+#if MAX_SKB_FRAGS
+	skb_frag_t *frag;
+	int i;
+	int frag_no;
+#endif
+#ifdef NICE_SUPPORT
+	vlan_tag_t *vlan_tag;
+#endif
+
+	if ((pDevice->LinkStatus == LM_STATUS_LINK_DOWN) || !pDevice->InitDone)
+	{
+		dev_kfree_skb(skb);
+		return 0;
+	}
+	
+#if (LINUX_VERSION_CODE < 0x02032b)
+	if (test_and_set_bit(0, &dev->tbusy)) {
+		return 1;
+	}
+#endif
+
+	if (pUmDevice->do_global_lock && pUmDevice->interrupt) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_queued = 1;
+		if (!pUmDevice->interrupt) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_queued = 0;
+		}
+		return 1;
+	}
+
+	pPacket = (PLM_PACKET)
+		QQ_PopHead(&pDevice->TxPacketFreeQ.Container);
+	if (pPacket == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+	pUmPacket = (PUM_PACKET) pPacket;
+	pUmPacket->skbuff = skb;
+	pfrag_list = &pUmPacket->frag_list;
+	pPacket->u.Tx.pFraglist = pfrag_list;
+	if (skb->ip_summed == CHECKSUM_HW) {
+		pPacket->Flags = SND_BD_FLAG_TCP_UDP_CKSUM;
+#if TIGON3_DEBUG
+		pUmDevice->tx_chksum_count++;
+#endif
+	}
+	else {
+		pPacket->Flags = 0;
+	}
+#if MAX_SKB_FRAGS
+	if ((frag_no = skb_shinfo(skb)->nr_frags))
+		len = skb->len - skb->data_len;
+	else
+		len = skb->len;
+	if (atomic_read(&pDevice->SendBdLeft) < (frag_no + 1)) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+		if (atomic_read(&pDevice->SendBdLeft) >= (frag_no + 1)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+#else
+	len = skb->len;
+	if (atomic_read(&pDevice->SendBdLeft) == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+		if (atomic_read(&pDevice->SendBdLeft)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+#endif
+
+	pfrag_list->Fragments[0].FragSize = len;
+	pUmPacket->map[0].dma_map = pci_map_single(pUmDevice->pdev,
+		skb->data, len, PCI_DMA_TODEVICE);
+	pUmPacket->map_len[0] = len;
+	bcm_set_addr(&pfrag_list->Fragments[0].FragBuf,
+		pUmPacket->map[0].dma_map);
+
+#if MAX_SKB_FRAGS
+	pPacket->u.Tx.FragCount = frag_no + 1;
+#if TIGON3_DEBUG
+	if (pPacket->u.Tx.FragCount > 1)
+		pUmDevice->tx_zc_count++;
+#endif
+	for (i = 1; i < pPacket->u.Tx.FragCount; i++) {
+		frag = &skb_shinfo(skb)->frags[i - 1];
+			
+		pUmPacket->map[i].dma_map_high =
+			bcm_pci_map_single_high(pUmDevice->pdev,
+				frag->page,
+				frag->page_offset,
+				frag->size, PCI_DMA_TODEVICE);
+		pUmPacket->map_len[i] = frag->size;
+		bcm_set_addr_high(&pfrag_list->Fragments[i].FragBuf,
+			pUmPacket->map[i].dma_map_high);
+#if TIGON3_DEBUG
+		if (pfrag_list->Fragments[i].FragBuf.High)
+			pUmDevice->tx_himem_count++;
+#endif
+		pfrag_list->Fragments[i].FragSize = frag->size;
+	}
+#else
+	pPacket->u.Tx.FragCount = 1;
+#endif
+
+	/* Work around 4GB dma problem */
+	if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700) {
+		if (check_4G_boundary(pUmDevice, pUmPacket) == 0) {
+			QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+#if (LINUX_VERSION_CODE < 0x02032b)
+			netif_wake_queue(dev);
+#endif
+			return 0;
+		}
+		skb = pUmPacket->skbuff;
+	}
+
+#ifdef NICE_SUPPORT
+	vlan_tag = (vlan_tag_t *) &skb->cb[0];
+	if (vlan_tag->signature == 0x5555) {
+		pPacket->VlanTag = vlan_tag->tag;
+		pPacket->Flags |= SND_BD_FLAG_VLAN_TAG;
+		vlan_tag->signature = 0;
+	}
+#endif
+	flags = bcm5700_lock(pUmDevice);
+	LM_SendPacket(pDevice, pPacket);
+	bcm5700_unlock(pUmDevice, flags);
+	if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) != 0) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+	}
+#if (LINUX_VERSION_CODE < 0x02032b)
+	else {
+		netif_wake_queue(dev);
+	}
+#endif
+	dev->trans_start = jiffies;
+	return 0;
+}
+
+STATIC
+int
+check_4G_boundary(PUM_DEVICE_BLOCK pUmDevice, PUM_PACKET pUmPacket)
+{
+	u32 base;
+	int i;
+	PLM_FRAG_LIST pfrag_list = &pUmPacket->frag_list;
+	PLM_FRAG pfrag;
+	struct sk_buff *skb, *nskb;
+#if MAX_SKB_FRAGS
+	skb_frag_t *frag;
+	unsigned char *ptr;
+#endif
+	int do_copy = 0;
+
+	/* Work around 4GB dma problem */
+	for (i = 0; i < pUmPacket->lm_packet.u.Tx.FragCount; i++) {
+		pfrag = &pfrag_list->Fragments[i];
+
+		if (((base = pfrag->FragBuf.Low) > 0xffffdcc0) &&
+			(pfrag->FragBuf.High == 0) &&
+			((base + 8 + pfrag->FragSize) < base)) {
+
+			do_copy = 1;
+			break;
+		}
+	}
+	if (do_copy) {
+		skb = pUmPacket->skbuff;
+		if ((nskb = dev_alloc_skb(skb->len))) {
+			memcpy(nskb->data, skb->data, pUmPacket->map_len[0]);
+			pci_unmap_single(pUmDevice->pdev,
+				pUmPacket->map[0].dma_map,
+				pUmPacket->map_len[0], PCI_DMA_TODEVICE);
+#if MAX_SKB_FRAGS
+			skb_shinfo(nskb)->nr_frags = 0;
+			ptr = nskb->data + pUmPacket->map_len[0];
+			for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+				frag = &skb_shinfo(skb)->frags[i];
+				memcpy(ptr,
+					(void *) page_address(frag->page) +
+					frag->page_offset, frag->size);
+				bcm_pci_unmap_single_high(pUmDevice->pdev,
+					pUmPacket->map[i+1].dma_map_high,
+					pUmPacket->map_len[i+1],
+					PCI_DMA_TODEVICE);
+				ptr += frag->size;
+			}
+#endif
+			nskb->len = skb->len;
+			memcpy(&nskb->cb[0], &skb->cb[0], sizeof(vlan_tag_t));
+			pUmPacket->map[0].dma_map =
+				pci_map_single(pUmDevice->pdev,
+					nskb->data,
+					nskb->len, PCI_DMA_TODEVICE);
+			bcm_set_addr(&pfrag_list->Fragments[0].FragBuf,
+				pUmPacket->map[0].dma_map);
+			pUmPacket->lm_packet.u.Tx.FragCount = 1;
+		}
+		dev_kfree_skb(skb);
+		pUmPacket->skbuff = nskb;
+		if (nskb == 0) {
+			return 0;
+		}
+	}
+	return 1;
+}
+
+
+STATIC void
+bcm5700_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *)dev_instance;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	LM_UINT32 oldtag, newtag;
+	int repl_buf_count;
+
+	if (!pDevice->InitDone)
+		return;
+
+	bcm5700_intr_lock(pUmDevice);
+	if (test_and_set_bit(0, (void*)&pUmDevice->interrupt)) {
+		printk(KERN_ERR "%s: Duplicate entry of the interrupt handler by "
+			   "processor %d.\n",
+			   dev->name, hard_smp_processor_id());
+		bcm5700_intr_unlock(pUmDevice);
+		return;
+	}
+
+	if (pDevice->UseTaggedStatus) {
+		if ((pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) ||
+			pUmDevice->adapter_just_inited) {
+			REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+			oldtag = pDevice->pStatusBlkVirt->StatusTag;
+
+			while (1) {
+   				pDevice->pStatusBlkVirt->Status &=
+					~STATUS_BLOCK_UPDATED;
+
+				LM_ServiceInterrupts(pDevice);
+				newtag = pDevice->pStatusBlkVirt->StatusTag;
+				if (newtag == oldtag) {
+					REG_WR(pDevice,
+						Mailbox.Interrupt[0].Low,
+						newtag << 24);
+					break;
+				}
+				oldtag = newtag;
+			}
+		}
+	}
+	else if ((pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) ||
+			pUmDevice->adapter_just_inited) {
+		do {
+			uint dummy;
+
+			pDevice->pMemView->Mailbox.Interrupt[0].Low = 1;
+   			pDevice->pStatusBlkVirt->Status &= ~STATUS_BLOCK_UPDATED;
+			LM_ServiceInterrupts(pDevice);
+			pDevice->pMemView->Mailbox.Interrupt[0].Low = 0;
+			dummy = pDevice->pMemView->Mailbox.Interrupt[0].Low;
+		}
+		while (pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED);
+	}
+#ifdef TASKLET
+	repl_buf_count = QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container);
+	if (repl_buf_count >= pUmDevice->rx_buf_repl_thresh) {
+		if ((repl_buf_count >= pUmDevice->rx_buf_repl_panic_thresh) &&
+			(!test_and_set_bit(0, &pUmDevice->tasklet_busy))) {
+			replenish_rx_buffers(pUmDevice);
+			clear_bit(0, (void*)&pUmDevice->tasklet_busy);
+		}
+		else if (!pUmDevice->tasklet_pending) {
+			pUmDevice->tasklet_pending = 1;
+			tasklet_schedule(&pUmDevice->tasklet);
+		}
+	}
+#else
+	if (QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container)) {
+		replenish_rx_buffers(pUmDevice);
+	}
+
+	if (QQ_GetEntryCnt(&pDevice->RxPacketFreeQ.Container)) {
+		LM_QueueRxPackets(pDevice);
+	}
+#endif
+
+	clear_bit(0, (void*)&pUmDevice->interrupt);
+	bcm5700_intr_unlock(pUmDevice);
+	if (pUmDevice->tx_queued) {
+		pUmDevice->tx_queued = 0;
+		netif_wake_queue(dev);
+	}
+	return;
+}
+
+
+STATIC void
+bcm5700_tasklet(unsigned long data)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)data;
+
+	/* RH 7.2 Beta 3 tasklets are reentrant */
+	if (test_and_set_bit(0, &pUmDevice->tasklet_busy)) {
+		pUmDevice->tasklet_pending = 0;
+		return;
+	}
+
+	pUmDevice->tasklet_pending = 0;
+	replenish_rx_buffers(pUmDevice);
+	clear_bit(0, &pUmDevice->tasklet_busy);
+}
+
+STATIC int
+bcm5700_close(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+	dev->start = 0;
+#endif
+	netif_stop_queue(dev);
+	pUmDevice->opened = 0;
+
+	if (tigon3_debug > 1)
+		printk(KERN_DEBUG "%s: Shutting down Tigon3\n",
+			   dev->name);
+
+	LM_DisableInterrupt(pDevice);
+#ifdef TASKLET
+//	tasklet_disable(&pUmDevice->tasklet);
+	tasklet_kill(&pUmDevice->tasklet);
+#endif
+	LM_Halt(pDevice);
+	pDevice->InitDone = 0;
+	del_timer(&pUmDevice->timer);
+
+	free_irq(dev->irq, dev);
+#if (LINUX_VERSION_CODE < 0x020300)
+	MOD_DEC_USE_COUNT;
+#endif
+	LM_SetPowerState(pDevice, LM_POWER_STATE_D3);
+	bcm5700_freemem(dev);
+
+	return 0;
+}
+
+STATIC int
+bcm5700_freemem(struct net_device *dev)
+{
+	int i;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+
+	for (i = 0; i < pUmDevice->mem_list_num; i++) {
+		if (pUmDevice->dma_list[i] == 0) {
+			kfree(pUmDevice->mem_list[i]);
+		}
+		else {
+			pci_free_consistent(pUmDevice->pdev,
+				(size_t) pUmDevice->mem_size_list[i],
+				pUmDevice->mem_list[i],
+				pUmDevice->dma_list[i]);
+		}
+	}
+	pUmDevice->mem_list_num = 0;
+	return 0;
+}
+
+LM_UINT32
+bcm5700_crc_count(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	LM_UINT32 Value32;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	unsigned long flags;
+
+#if INCLUDE_TBI_SUPPORT
+	if(pDevice->EnableTbi)
+		return (pStats->dot3StatsFCSErrors.Low);
+#endif
+	if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+		T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701) {
+
+		if (pUmDevice->adapter_just_inited)
+			return 0;
+		flags = bcm5700_lock(pUmDevice);
+		LM_ReadPhy(pDevice, 0x1e, &Value32);
+		LM_WritePhy(pDevice, 0x1e, Value32 | 0x8000);
+		LM_ReadPhy(pDevice, 0x14, &Value32);
+		bcm5700_unlock(pUmDevice, flags);
+		pDevice->PhyCrcCount += Value32;
+		return pDevice->PhyCrcCount;
+	}
+	else if (pStats == 0) {
+		return 0;
+	}
+	else {
+		return (pStats->dot3StatsFCSErrors.Low);
+	}
+}
+
+STATIC struct net_device_stats *
+bcm5700_get_stats(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	struct net_device_stats *p_netstats = &pUmDevice->stats;
+
+	if (pStats == 0)
+		return p_netstats;
+
+	/* Get stats from LM */
+	p_netstats->rx_packets = pStats->ifHCInUcastPkts.Low +
+			pStats->ifHCInMulticastPkts.Low +
+			pStats->ifHCInBroadcastPkts.Low;
+	p_netstats->tx_packets = pStats->COSIfHCOutPkts[0].Low;
+	p_netstats->rx_bytes = pStats->ifHCInOctets.Low;
+	p_netstats->tx_bytes = pStats->ifHCOutOctets.Low;
+	p_netstats->tx_errors = pStats->dot3StatsInternalMacTransmitErrors.Low +
+			pStats->dot3StatsCarrierSenseErrors.Low +
+			pStats->ifOutDiscards.Low +
+			pStats->ifOutErrors.Low;
+	p_netstats->multicast = pStats->ifHCInMulticastPkts.Low;
+	p_netstats->collisions = pStats->etherStatsCollisions.Low;
+	p_netstats->rx_length_errors = pStats->dot3StatsFramesTooLong.Low +
+			pStats->etherStatsUndersizePkts.Low;
+	p_netstats->rx_over_errors = pStats->nicNoMoreRxBDs.Low;
+	p_netstats->rx_frame_errors = pStats->dot3StatsAlignmentErrors.Low;
+	p_netstats->rx_crc_errors = bcm5700_crc_count(pUmDevice);
+	p_netstats->rx_errors = p_netstats->rx_length_errors +
+				p_netstats->rx_over_errors +
+				p_netstats->rx_frame_errors +
+				p_netstats->rx_crc_errors +
+				pStats->etherStatsFragments.Low +
+				pStats->etherStatsJabbers.Low;
+	
+	p_netstats->tx_aborted_errors = pStats->ifOutDiscards.Low;
+	p_netstats->tx_carrier_errors = pStats->dot3StatsCarrierSenseErrors.Low;
+
+	return p_netstats;
+}
+
+#if (LINUX_VERSION_CODE >= 0x020400)
+static int netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	u32 ethcmd;
+		
+	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
+		return -EFAULT;
+
+        switch (ethcmd) {
+#ifdef ETHTOOL_GDRVINFO
+        case ETHTOOL_GDRVINFO: {
+		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
+		PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+		extern int t3FwReleaseMajor;
+		extern int t3FwReleaseMinor;
+		extern int t3FwReleaseFix;
+
+		strcpy(info.driver,  bcm5700_driver);
+		sprintf(info.fw_version, "%i.%i.%i",
+			t3FwReleaseMajor, t3FwReleaseMinor, 
+			t3FwReleaseFix);
+		strcpy(info.version, bcm5700_version);
+		strcpy(info.bus_info, pUmDevice->pdev->slot_name);
+		if (copy_to_user(useraddr, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+#endif
+
+        }
+	
+	return -EOPNOTSUPP;
+}
+#endif
+
+/* Provide ioctl() calls to examine the MII xcvr state. */
+STATIC int bcm5700_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	u16 *data = (u16 *)&rq->ifr_data;
+	u32 value;
+	unsigned long flags;
+
+	switch(cmd) {
+	case SIOCDEVPRIVATE:		/* Get the address of the PHY in use. */
+		data[0] = pDevice->PhyAddr;
+	case SIOCDEVPRIVATE+1:		/* Read the specified MII register. */
+		flags = bcm5700_lock(pUmDevice);
+		LM_ReadPhy(pDevice, data[1] & 0x1f, (LM_UINT32 *) &value);
+		bcm5700_unlock(pUmDevice, flags);
+		data[3] = value & 0xffff;
+		return 0;
+	case SIOCDEVPRIVATE+2:		/* Write the specified MII register */
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		flags = bcm5700_lock(pUmDevice);
+		LM_WritePhy(pDevice, data[1] & 0x1f, data[2]);
+		bcm5700_unlock(pUmDevice, flags);
+		return 0;
+#ifdef NICE_SUPPORT
+	case SIOCNICE:
+		{
+			struct nice_req* nrq;
+
+			if (!capable(CAP_NET_ADMIN))
+				return -EPERM;
+
+			nrq = (struct nice_req*)&rq->ifr_ifru;
+			if( nrq->cmd == NICE_CMD_QUERY_SUPPORT ) {
+				nrq->nrq_magic = NICE_DEVICE_MAGIC;
+				nrq->nrq_support_rx = 1;
+				nrq->nrq_support_get_speed = 1;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_SET_RX ) {
+				pUmDevice->nice_rx = nrq->nrq_rx;
+				pUmDevice->nice_ctx = nrq->nrq_ctx;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_GET_RX ) {
+				nrq->nrq_rx = pUmDevice->nice_rx;
+				nrq->nrq_ctx = pUmDevice->nice_ctx;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_GET_SPEED ) {
+				nrq->nrq_speed = pUmDevice->line_speed;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_BLINK_LED ) {
+				return LM_BlinkLED(pDevice, nrq->nrq_blink_time);
+			}
+			break;
+		}
+#endif /* NICE_SUPPORT */
+#if (LINUX_VERSION_CODE >= 0x020400)
+	case SIOCETHTOOL:
+		return netdev_ethtool_ioctl(dev, (void *) rq->ifr_data);
+#endif
+	default:
+		return -EOPNOTSUPP;
+	}
+	return -EOPNOTSUPP;
+}
+
+STATIC void bcm5700_set_rx_mode(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	int i;
+	struct dev_mc_list *mclist;
+
+	LM_MulticastClear(pDevice);
+	for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+			 i++, mclist = mclist->next) {
+		LM_MulticastAdd(pDevice, (PLM_UINT8) &mclist->dmi_addr);
+	}
+	if ((dev->flags & IFF_ALLMULTI) &&
+		!(pDevice->ReceiveMask & LM_ACCEPT_ALL_MULTICAST)) {
+
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask | LM_ACCEPT_ALL_MULTICAST);
+	}
+	else if (pDevice->ReceiveMask & LM_ACCEPT_ALL_MULTICAST) {
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask & ~LM_ACCEPT_ALL_MULTICAST);
+	}
+	if ((dev->flags & IFF_PROMISC) &&
+		!(pDevice->RxMode & RX_MODE_PROMISCUOUS_MODE)) {
+
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask | LM_PROMISCUOUS_MODE);
+	}
+	else if (pDevice->RxMode & RX_MODE_PROMISCUOUS_MODE) {
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask & ~LM_PROMISCUOUS_MODE);
+	}
+}
+
+/*
+ * Set the hardware MAC address.
+ */
+STATIC int bcm5700_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr=p;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) dev->priv;
+
+	if (netif_running(dev))
+		return -EBUSY;
+	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
+	LM_SetMacAddress(pDevice, dev->dev_addr);
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE < 0x020300)
+#ifdef MODULE
+int init_module(void)
+{
+	return bcm5700_probe(NULL);
+}
+
+void cleanup_module(void)
+{
+	struct net_device *next_dev;
+	PUM_DEVICE_BLOCK pUmDevice;
+
+	/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
+	while (root_tigon3_dev) {
+		pUmDevice = (PUM_DEVICE_BLOCK)root_tigon3_dev->priv;
+#ifdef CONFIG_PROC_FS
+		bcm5700_proc_remove_dev(root_tigon3_dev); 
+#endif
+		next_dev = pUmDevice->next_module;
+		unregister_netdev(root_tigon3_dev);
+		if (pUmDevice->lm_dev.pMappedMemBase)
+			iounmap(pUmDevice->lm_dev.pMappedMemBase);
+		kfree(root_tigon3_dev);
+		root_tigon3_dev = next_dev;
+	}
+}
+
+#endif  /* MODULE */
+#else	/* LINUX_VERSION_CODE < 0x020300 */
+
+#if (LINUX_VERSION_CODE >= 0x020406)
+static int bcm5700_suspend (struct pci_dev *pdev, u32 state)
+#else
+static void bcm5700_suspend (struct pci_dev *pdev)
+#endif
+{
+	struct net_device *dev = (struct net_device *) pci_get_drvdata(pdev);
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	if (!netif_running(dev))
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#else
+		return;
+#endif
+
+	LM_DisableInterrupt(pDevice);
+	netif_device_detach (dev);
+
+	/* Disable interrupts, stop Tx and Rx. */
+	LM_Halt(pDevice);
+	LM_SetPowerState(pDevice, LM_POWER_STATE_D3);
+
+/*	pci_power_off(pdev, -1);*/
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE >= 0x020406)
+static int bcm5700_resume(struct pci_dev *pdev)
+#else
+static void bcm5700_resume(struct pci_dev *pdev)
+#endif
+{
+	struct net_device *dev = (struct net_device *) pci_get_drvdata(pdev);
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) dev->priv;
+
+	if (!netif_running(dev))
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#else
+		return;
+#endif
+/*	pci_power_on(pdev);*/
+	netif_device_attach(dev);
+	LM_InitializeAdapter(pDevice);
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+	LM_EnableInterrupt(pDevice);
+#if (LINUX_VERSION_CODE >= 0x020406)
+	return 0;
+#endif
+}
+
+
+static struct pci_driver bcm5700_pci_driver = {
+	name:		bcm5700_driver,
+	id_table:	bcm5700_pci_tbl,
+	probe:		bcm5700_init_one,
+	remove:		bcm5700_remove_one,
+	suspend:	bcm5700_suspend,
+	resume:		bcm5700_resume,
+};
+
+
+static int __init bcm5700_init_module (void)
+{
+	return pci_module_init(&bcm5700_pci_driver);
+}
+
+
+static void __exit bcm5700_cleanup_module (void)
+{
+	pci_unregister_driver(&bcm5700_pci_driver);
+}
+
+
+module_init(bcm5700_init_module);
+module_exit(bcm5700_cleanup_module);
+#endif
+
+/*
+ * Middle Module
+ *
+ */
+
+
+#define STD_BUF_SZ	1536
+#define MIN_BUF_SZ	128
+
+LM_STATUS
+MM_ReadConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT16 *pValue16)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_read_config_word(pUmDevice->pdev, Offset, (u16 *) pValue16);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_ReadConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT32 *pValue32)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_read_config_dword(pUmDevice->pdev, Offset, (u32 *) pValue32);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_WriteConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT16 Value16)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_write_config_word(pUmDevice->pdev, Offset, Value16);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_WriteConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT32 Value32)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_write_config_dword(pUmDevice->pdev, Offset, Value32);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_AllocateSharedMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+	PLM_VOID *pMemoryBlockVirt, PLM_PHYSICAL_ADDRESS pMemoryBlockPhy,
+	LM_BOOL Cached)
+{
+	PLM_VOID pvirt;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	dma_addr_t mapping;
+
+	pvirt = pci_alloc_consistent(pUmDevice->pdev, BlockSize,
+					       &mapping);
+	if (!pvirt) {
+		return LM_STATUS_FAILURE;
+	}
+	pUmDevice->mem_list[pUmDevice->mem_list_num] = pvirt;
+	pUmDevice->dma_list[pUmDevice->mem_list_num] = mapping;
+	pUmDevice->mem_size_list[pUmDevice->mem_list_num++] = BlockSize;
+	memset(pvirt, 0, BlockSize);
+	*pMemoryBlockVirt = (PLM_VOID) pvirt;
+	bcm_set_addr(pMemoryBlockPhy, mapping);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_AllocateMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+	PLM_VOID *pMemoryBlockVirt)
+{
+	PLM_VOID pvirt;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+
+
+	/* Maximum in slab.c */
+	if (BlockSize > 131072) {
+		goto MM_Alloc_error;
+	}
+
+	pvirt = kmalloc(BlockSize, GFP_KERNEL);
+	if (!pvirt) {
+		goto MM_Alloc_error;
+	}
+	pUmDevice->mem_list[pUmDevice->mem_list_num] = pvirt;
+	pUmDevice->dma_list[pUmDevice->mem_list_num] = 0;
+	pUmDevice->mem_size_list[pUmDevice->mem_list_num++] = BlockSize;
+	memset(pvirt, 0, BlockSize);
+	*pMemoryBlockVirt = pvirt;
+	return LM_STATUS_SUCCESS;
+
+MM_Alloc_error:
+	printk(KERN_WARNING "%s: Memory allocation failed - buffer parameters may be set too high\n", pUmDevice->dev->name);
+	return LM_STATUS_FAILURE;
+}
+
+LM_STATUS
+MM_MapMemBase(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+
+	pDevice->pMappedMemBase = ioremap_nocache(
+		pci_resource_start(pUmDevice->pdev, 0), pDevice->MemBaseSize);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_InitializeUmPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	int i;
+	struct sk_buff *skb;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PUM_PACKET pUmPacket;
+	PLM_PACKET pPacket;
+
+	for (i = 0; i < pDevice->RxPacketDescCnt; i++) {
+		pPacket = QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+		pUmPacket = (PUM_PACKET) pPacket;
+		if (pPacket == 0) {
+			printk(KERN_DEBUG "Bad RxPacketFreeQ\n");
+		}
+		skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2);
+		if (skb == 0) {
+			pUmPacket->skbuff = 0;
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+			continue;
+		}
+		pUmPacket->skbuff = skb;
+		skb->dev = pUmDevice->dev;
+		skb_reserve(skb, 2);
+		pUmPacket->map[0].dma_map = pci_map_single(pUmDevice->pdev,
+					skb->tail,
+					pPacket->u.Rx.RxBufferSize,
+					PCI_DMA_FROMDEVICE);
+		pPacket->u.Rx.pRxBufferVirt = skb->tail;
+		bcm_set_addr(&pPacket->u.Rx.RxBufferPhy,
+			pUmPacket->map[0].dma_map);
+		QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+	}
+	pUmDevice->rx_buf_repl_thresh = pDevice->RxPacketDescCnt / 8;
+	pUmDevice->rx_buf_repl_panic_thresh = pDevice->RxPacketDescCnt / 2;
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_GetConfig(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	int index = pUmDevice->index;
+
+	if (auto_speed[index] == 0)
+		pDevice->DisableAutoNeg = TRUE;
+	else
+		pDevice->DisableAutoNeg = FALSE;
+
+	if (line_speed[index] == 0) {
+		pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_AUTO;
+		pDevice->DisableAutoNeg = FALSE;
+	}
+	else {
+		if (line_speed[index] == 1000) {
+			if (pDevice->EnableTbi) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX;
+			}
+			else if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS;
+			}
+			if (!pDevice->EnableTbi)
+				pDevice->DisableAutoNeg = FALSE;
+		}
+		else if (line_speed[index] == 100) {
+			if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS;
+			}
+		}
+		else if (line_speed[index] == 10) {
+			if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+			}
+		}
+		else {
+			pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_AUTO;
+			pDevice->DisableAutoNeg = FALSE;
+			printk(KERN_WARNING "%s: Invalid line_speed parameter (%d), using 0\n", pUmDevice->dev->name, line_speed[index]);
+		}
+
+	}
+	pDevice->FlowControlCap = 0;
+	if (rx_flow_control[index] != 0) {
+		pDevice->FlowControlCap |= LM_FLOW_CONTROL_RECEIVE_PAUSE;
+	}
+	if (tx_flow_control[index] != 0) {
+		pDevice->FlowControlCap |= LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+	}
+	if (auto_flow_control[index] != 0) {
+		if (pDevice->DisableAutoNeg == FALSE) {
+
+			pDevice->FlowControlCap |= LM_FLOW_CONTROL_AUTO_PAUSE;
+			if ((tx_flow_control[index] == 0) &&
+				(rx_flow_control[index] == 0)) {
+
+				pDevice->FlowControlCap |=
+					LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+					LM_FLOW_CONTROL_RECEIVE_PAUSE;
+			}
+		}
+		else {
+			printk(KERN_WARNING "%s: Conflicting auto_flow_control parameter (%d), using 0\n", pUmDevice->dev->name, auto_flow_control[index]);
+		}
+
+	}
+
+	if (pUmDevice->dev->mtu > 1500) {
+		pDevice->RxMtu = pUmDevice->dev->mtu + 14;
+		pDevice->RxJumboDescCnt = DEFAULT_JUMBO_RCV_DESC_COUNT;
+	}
+	else {
+		pDevice->RxJumboDescCnt = 0;
+	}
+
+	if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701) {
+		pDevice->UseTaggedStatus = TRUE;
+		pUmDevice->timer_interval = HZ;
+	}
+	else {
+		pUmDevice->timer_interval = HZ/10;
+	}
+
+	if ((tx_pkt_desc_cnt[index] == 0) ||
+		(tx_pkt_desc_cnt[index] > MAX_TX_PACKET_DESC_COUNT)) {
+		printk(KERN_WARNING "%s: Invalid tx_pkt_desc_cnt parameter (%d), using %d\n", pUmDevice->dev->name, tx_pkt_desc_cnt[index], DEFAULT_TX_PACKET_DESC_COUNT);
+		tx_pkt_desc_cnt[index] = DEFAULT_TX_PACKET_DESC_COUNT;
+	}
+	pDevice->TxPacketDescCnt = tx_pkt_desc_cnt[index];
+	if ((rx_std_desc_cnt[index] == 0) ||
+		(rx_std_desc_cnt[index] > MAX_RX_PACKET_DESC_COUNT)) {
+		printk(KERN_WARNING "%s: Invalid rx_std_desc_cnt parameter (%d), using %d\n", pUmDevice->dev->name, rx_std_desc_cnt[index], DEFAULT_RX_PACKET_DESC_COUNT);
+		rx_std_desc_cnt[index] = DEFAULT_RX_PACKET_DESC_COUNT;
+	}
+	pDevice->RxStdDescCnt = rx_std_desc_cnt[index];
+	if ((mtu[index] > 1514) && ((rx_jumbo_desc_cnt[index] == 0) ||
+		(rx_jumbo_desc_cnt[index] >= T3_JUMBO_RCV_RCB_ENTRY_COUNT))) {
+		printk(KERN_WARNING "%s: Invalid rx_jumbo_desc_cnt parameter (%d), using %d\n", pUmDevice->dev->name, rx_jumbo_desc_cnt[index], DEFAULT_JUMBO_RCV_DESC_COUNT);
+		rx_jumbo_desc_cnt[index] = DEFAULT_JUMBO_RCV_DESC_COUNT;
+	}
+	pDevice->RxJumboDescCnt = rx_jumbo_desc_cnt[index];
+	pUmDevice->rx_adaptive_coalesce = rx_adaptive_coalesce[index];
+	if (!pUmDevice->rx_adaptive_coalesce) {
+		if (rx_coalesce_ticks[index] > MAX_RX_COALESCING_TICKS) {
+			printk(KERN_WARNING "%s: Invalid rx_coalesce_ticks parameter (%d), using %d\n", pUmDevice->dev->name, rx_coalesce_ticks[index], MAX_RX_COALESCING_TICKS);
+			rx_coalesce_ticks[index] = MAX_RX_COALESCING_TICKS;
+		}
+		else if ((rx_coalesce_ticks[index] == 0) &&
+			(rx_max_coalesce_frames[index] == 0)) {
+
+			printk(KERN_WARNING "%s: Conflicting rx_coalesce_ticks (0) and rx_max_coalesce_frames (0) parameters, using %d and %d respectively\n", pUmDevice->dev->name, DEFAULT_RX_COALESCING_TICKS, DEFAULT_RX_MAX_COALESCED_FRAMES);
+			rx_coalesce_ticks[index] = DEFAULT_RX_COALESCING_TICKS;
+			rx_max_coalesce_frames[index] =
+				DEFAULT_RX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->RxCoalescingTicks = rx_coalesce_ticks[index];
+		pUmDevice->rx_curr_coalesce_ticks = pDevice->RxCoalescingTicks;
+
+		if (rx_max_coalesce_frames[index] > MAX_RX_MAX_COALESCED_FRAMES)
+		{
+			printk(KERN_WARNING "%s: Invalid rx_max_coalesce_frames parameter (%d), using %d\n", pUmDevice->dev->name, rx_max_coalesce_frames[index], MAX_RX_MAX_COALESCED_FRAMES);
+			rx_max_coalesce_frames[index] =
+				MAX_RX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->RxMaxCoalescedFrames = rx_max_coalesce_frames[index];
+		pUmDevice->rx_curr_coalesce_frames =
+			pDevice->RxMaxCoalescedFrames;
+		if (stats_coalesce_ticks[index] > MAX_STATS_COALESCING_TICKS) {
+			printk(KERN_WARNING "%s: Invalid stats_coalesce_ticks parameter (%d), using %d\n", pUmDevice->dev->name, stats_coalesce_ticks[index], MAX_STATS_COALESCING_TICKS);
+			stats_coalesce_ticks[index] =
+				MAX_STATS_COALESCING_TICKS;
+		}
+		pDevice->StatsCoalescingTicks = stats_coalesce_ticks[index];
+	}
+	else {
+		pUmDevice->rx_curr_coalesce_frames =
+			DEFAULT_RX_MAX_COALESCED_FRAMES;
+		pUmDevice->rx_curr_coalesce_ticks =
+			DEFAULT_RX_COALESCING_TICKS;
+	}
+	if (tx_coalesce_ticks[index] > MAX_TX_COALESCING_TICKS) {
+		printk(KERN_WARNING "%s: Invalid tx_coalesce_ticks parameter (%d), using %d\n", pUmDevice->dev->name, tx_coalesce_ticks[index], MAX_TX_COALESCING_TICKS);
+		tx_coalesce_ticks[index] = MAX_TX_COALESCING_TICKS;
+	}
+	else if ((tx_coalesce_ticks[index] == 0) &&
+		(tx_max_coalesce_frames[index] == 0)) {
+
+		printk(KERN_WARNING "%s: Conflicting tx_coalesce_ticks (0) and tx_max_coalesce_frames (0) parameters, using %d and %d respectively\n", pUmDevice->dev->name, DEFAULT_TX_COALESCING_TICKS, DEFAULT_TX_MAX_COALESCED_FRAMES);
+		tx_coalesce_ticks[index] = DEFAULT_TX_COALESCING_TICKS;
+		tx_max_coalesce_frames[index] = DEFAULT_TX_MAX_COALESCED_FRAMES;
+	}
+	pDevice->TxCoalescingTicks = tx_coalesce_ticks[index];
+	if (tx_max_coalesce_frames[index] > MAX_TX_MAX_COALESCED_FRAMES) {
+		printk(KERN_WARNING "%s: Invalid tx_max_coalesce_frames parameter (%d), using %d\n", pUmDevice->dev->name, tx_max_coalesce_frames[index], MAX_TX_MAX_COALESCED_FRAMES);
+		tx_max_coalesce_frames[index] = MAX_TX_MAX_COALESCED_FRAMES;
+	}
+	pDevice->TxMaxCoalescedFrames = tx_max_coalesce_frames[index];
+
+	if (enable_wol[index]) {
+		pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_MAGIC_PACKET;
+		pDevice->WakeUpMode = LM_WAKE_UP_MODE_MAGIC_PACKET;
+	}
+	if (pDevice->EnablePciXFix)
+		pDevice->NicSendBd = FALSE;
+	else
+		pDevice->NicSendBd = TRUE;
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_StartTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_CompleteTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_IndicateRxPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+	int size;
+
+	while (1) {
+		pPacket = (PLM_PACKET)
+			QQ_PopHead(&pDevice->RxPacketReceivedQ.Container);
+		if (pPacket == 0)
+			break;
+		pUmPacket = (PUM_PACKET) pPacket;
+		pci_unmap_single(pUmDevice->pdev,
+				pUmPacket->map[0].dma_map,
+				pPacket->u.Rx.RxBufferSize,
+				PCI_DMA_FROMDEVICE);
+		if ((pPacket->PacketStatus != LM_STATUS_SUCCESS) ||
+			((size = pPacket->PacketSize) > pDevice->RxMtu)) {
+
+			/* reuse skb */
+#ifdef TASKLET
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+#else
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+#endif
+			pUmDevice->rx_misc_errors++;
+			continue;
+		}
+		skb = pUmPacket->skbuff;
+		skb_put(skb, size);
+		skb->pkt_type = 0;
+		skb->protocol = eth_type_trans(skb, skb->dev);
+		if ((pPacket->Flags & RCV_BD_FLAG_TCP_UDP_CHKSUM_FIELD) &&
+			(pDevice->TaskToOffload &
+				LM_TASK_OFFLOAD_RX_TCP_CHECKSUM)) {
+			if (pPacket->u.Rx.TcpUdpChecksum == 0xffff) {
+
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+#if TIGON3_DEBUG
+				pUmDevice->rx_good_chksum_count++;
+#endif
+			}
+			else {
+				skb->ip_summed = CHECKSUM_NONE;
+				pUmDevice->rx_bad_chksum_count++;
+			}
+		}
+		else {
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+#ifdef NICE_SUPPORT
+		if( pUmDevice->nice_rx ) {
+			vlan_tag_t *vlan_tag;
+
+			vlan_tag = (vlan_tag_t *) &skb->cb[0];
+			if (pPacket->Flags & RCV_BD_FLAG_VLAN_TAG) {
+				vlan_tag->signature = 0x7777;
+				vlan_tag->tag = pPacket->VlanTag;
+			}
+			else {
+				vlan_tag->signature = 0;
+			}
+			pUmDevice->nice_rx(skb, pUmDevice->nice_ctx);
+		}
+		else {
+			netif_rx(skb);
+		}
+#else
+		netif_rx(skb);
+#endif
+
+#ifdef TASKLET
+		pUmPacket->skbuff = 0;
+		QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+#else
+		skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2);
+		if (skb == 0) {
+			pUmPacket->skbuff = 0;
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+		}
+		else {
+			pUmPacket->skbuff = skb;
+			skb->dev = pUmDevice->dev;
+			skb_reserve(skb, 2);
+			pUmPacket->map[0].dma_map = pci_map_single(
+						pUmDevice->pdev,
+						skb->tail,
+						pPacket->u.Rx.RxBufferSize,
+						PCI_DMA_FROMDEVICE);
+			pPacket->u.Rx.pRxBufferVirt = skb->tail;
+			bcm_set_addr(&pPacket->u.Rx.RxBufferPhy,
+				pUmPacket->map[0].dma_map);
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+		}
+#endif
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+/* Returns 1 if not all buffers are allocated */
+STATIC int
+replenish_rx_buffers(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	struct sk_buff *skb;
+	int queue_rx = 0;
+	int ret = 0;
+
+	while ((pUmPacket = (PUM_PACKET)
+		QQ_PopHead(&pUmDevice->rx_out_of_buf_q.Container)) != 0) {
+		pPacket = (PLM_PACKET) pUmPacket;
+		if (pUmPacket->skbuff) {
+			/* reuse an old skb */
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+			queue_rx = 1;
+			continue;
+		}
+		if ((skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2)) == 0) {
+			QQ_PushHead(&pUmDevice->rx_out_of_buf_q.Container,
+				pPacket);
+			ret = 1;
+			break;
+		}
+		pUmPacket->skbuff = skb;
+		skb->dev = pUmDevice->dev;
+		skb_reserve(skb, 2);
+		pPacket->u.Rx.pRxBufferVirt = skb->tail;
+		pUmPacket->map[0].dma_map = pci_map_single(pUmDevice->pdev,
+					skb->tail,
+					pPacket->u.Rx.RxBufferSize,
+					PCI_DMA_FROMDEVICE);
+		bcm_set_addr(&pPacket->u.Rx.RxBufferPhy,
+			pUmPacket->map[0].dma_map);
+		QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+		queue_rx = 1;
+	}
+	if (queue_rx) {
+		LM_QueueRxPackets(pDevice);
+	}
+	return ret;
+}
+
+LM_STATUS
+MM_IndicateTxPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+#if MAX_SKB_FRAGS
+	int i;
+#endif
+
+	while (1) {
+		pPacket = (PLM_PACKET)
+			QQ_PopHead(&pDevice->TxPacketXmittedQ.Container);
+		if (pPacket == 0)
+			break;
+		pUmPacket = (PUM_PACKET) pPacket;
+		skb = pUmPacket->skbuff;
+		pci_unmap_single(pUmDevice->pdev, pUmPacket->map[0].dma_map,
+				pUmPacket->map_len[0], PCI_DMA_TODEVICE);
+#if MAX_SKB_FRAGS
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			bcm_pci_unmap_single_high(pUmDevice->pdev,
+				pUmPacket->map[i+1].dma_map_high,
+				pUmPacket->map_len[i+1], PCI_DMA_TODEVICE);
+		}
+#endif
+		dev_kfree_skb_irq(skb);
+		pUmPacket->skbuff = 0;
+		QQ_PushTail(&pDevice->TxPacketFreeQ.Container, pPacket);
+	}
+	if (pUmDevice->tx_full) {
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) >=
+			(pDevice->TxPacketDescCnt >> 1)) {
+
+			pUmDevice->tx_full = 0;
+			netif_wake_queue(pUmDevice->dev);
+		}
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_IndicateStatus(PLM_DEVICE_BLOCK pDevice, LM_STATUS Status)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	struct net_device *dev = pUmDevice->dev;
+	LM_FLOW_CONTROL flow_control;
+
+	if (!pUmDevice->opened)
+		return LM_STATUS_SUCCESS;
+
+	if (pUmDevice->delayed_link_ind > 0) {
+		pUmDevice->delayed_link_ind = 0;
+		printk(KERN_INFO "%s: %s ", bcm5700_driver, dev->name);
+		if (Status == LM_STATUS_LINK_DOWN) {
+			printk("NIC Link is DOWN\n");
+		}
+		else if (Status == LM_STATUS_LINK_ACTIVE) {
+			printk("NIC Link is UP, ");
+		}
+	}
+	else {
+		printk(KERN_ALERT "%s: %s ", bcm5700_driver, dev->name);
+		if (Status == LM_STATUS_LINK_DOWN) {
+			pUmDevice->line_speed = 0;
+			printk("NIC Link is Down\n");
+		}
+		else if (Status == LM_STATUS_LINK_ACTIVE) {
+			printk("NIC Link is Up, ");
+		}
+	}
+
+	if (Status == LM_STATUS_LINK_ACTIVE) {
+		if (pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS)
+			pUmDevice->line_speed = 1000;
+		else if (pDevice->LineSpeed == LM_LINE_SPEED_100MBPS)
+			pUmDevice->line_speed = 100;
+		else if (pDevice->LineSpeed == LM_LINE_SPEED_10MBPS)
+			pUmDevice->line_speed = 10;
+
+		printk("%d Mbps ", pUmDevice->line_speed);
+
+		if (pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+			printk("full duplex");
+		else
+			printk("half duplex");
+
+		flow_control = pDevice->FlowControl &
+			(LM_FLOW_CONTROL_RECEIVE_PAUSE |
+			LM_FLOW_CONTROL_TRANSMIT_PAUSE);
+		if (flow_control) {
+			if (flow_control & LM_FLOW_CONTROL_RECEIVE_PAUSE) {
+				printk(", receive ");
+				if (flow_control & LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+					printk("& transmit ");
+			}
+			else {
+				printk(", transmit ");
+			}
+			printk("flow control ON");
+		}
+		printk("\n");
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_FreeRxBuffer(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+
+	if (pPacket == 0)
+		return LM_STATUS_SUCCESS;
+	pUmPacket = (PUM_PACKET) pPacket;
+	if ((skb = pUmPacket->skbuff))
+		dev_kfree_skb(skb);
+	pUmPacket->skbuff = 0;
+	return LM_STATUS_SUCCESS;
+}
+unsigned long
+MM_AnGetCurrentTime_us(PAN_STATE_INFO pAnInfo)
+{
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	return ((tv.tv_sec * 1000000) + tv.tv_usec);
+}
+
+
+/*MODULE_LICENSE("GPL");*/
diff -urN linux.orig/drivers/net/bcm/bits.h linux/drivers/net/bcm/bits.h
--- linux.orig/drivers/net/bcm/bits.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/bits.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,62 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef BITS_H
+#define BITS_H
+
+
+
+/******************************************************************************/
+/* Bit Mask definitions */
+/******************************************************************************/
+
+#define BIT_NONE            0x00
+#define BIT_0               0x01
+#define BIT_1               0x02
+#define BIT_2               0x04
+#define BIT_3               0x08
+#define BIT_4               0x10
+#define BIT_5               0x20
+#define BIT_6               0x40
+#define BIT_7               0x80
+#define BIT_8               0x0100
+#define BIT_9               0x0200
+#define BIT_10              0x0400
+#define BIT_11              0x0800
+#define BIT_12              0x1000
+#define BIT_13              0x2000
+#define BIT_14              0x4000
+#define BIT_15              0x8000
+#define BIT_16              0x010000
+#define BIT_17              0x020000
+#define BIT_18              0x040000
+#define BIT_19              0x080000
+#define BIT_20              0x100000
+#define BIT_21              0x200000
+#define BIT_22              0x400000
+#define BIT_23              0x800000
+#define BIT_24              0x01000000
+#define BIT_25              0x02000000
+#define BIT_26              0x04000000
+#define BIT_27              0x08000000
+#define BIT_28              0x10000000
+#define BIT_29              0x20000000
+#define BIT_30              0x40000000
+#define BIT_31              0x80000000
+
+
+
+#endif /* BITS_H */
+
diff -urN linux.orig/drivers/net/bcm/debug.h linux/drivers/net/bcm/debug.h
--- linux.orig/drivers/net/bcm/debug.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/debug.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,108 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef DEBUG_H 
+#define DEBUG_H 
+
+
+
+/******************************************************************************/
+/* Debug macros                                                               */
+/******************************************************************************/
+
+/* Code path for controlling output debug messages. */
+/* Define your code path here. */
+#define CP_INIT                     0x010000
+#define CP_SEND                     0x020000
+#define CP_RCV                      0x040000
+#define CP_INT                      0x080000
+#define CP_UINIT                    0x100000
+#define CP_RESET                    0x200000
+
+#define CP_ALL                      (CP_INIT | CP_SEND | CP_RCV | CP_INT | \
+                                    CP_RESET | CP_UINIT)
+
+#define CP_MASK                     0xffff0000
+
+
+/* Debug message levels. */
+#define LV_VERBOSE                  0x03
+#define LV_INFORM                   0x02
+#define LV_WARN                     0x01
+#define LV_FATAL                    0x00
+
+#define LV_MASK                     0xffff
+
+
+/* Code path and messsage level combined.  These are the first argument of */
+/* the DbgMessage macro. */
+#define INIT_V                      (CP_INIT | LV_VERBOSE)
+#define INIT_I                      (CP_INIT | LV_INFORM)
+#define INIT_W                      (CP_INIT | LV_WARN)
+#define SEND_V                      (CP_SEND | LV_VERBOSE)
+#define SEND_I                      (CP_SEND | LV_INFORM)
+#define SEND_W                      (CP_SEND | LV_WARN)
+#define RCV_V                       (CP_RCV | LV_VERBOSE)
+#define RCV_I                       (CP_RCV | LV_INFORM)
+#define RCV_W                       (CP_RCV | LV_WARN)
+#define INT_V                       (CP_INT | LV_VERBOSE)
+#define INT_I                       (CP_INT | LV_INFORM)
+#define INT_W                       (CP_INT | LV_WARN)
+#define UINIT_V                     (CP_UINIT | LV_VERBOSE)
+#define UINIT_I                     (CP_UINIT | LV_INFORM)
+#define UINIT_W                     (CP_UINIT | LV_WARN)
+#define RESET_V                     (CP_RESET | LV_VERBOSE)
+#define RESET_I                     (CP_RESET | LV_INFORM)
+#define RESET_W                     (CP_RESET | LV_WARN)
+#define CPALL_V                     (CP_ALL | LV_VERBOSE)
+#define CPALL_I                     (CP_ALL | LV_INFORM)
+#define CPALL_W                     (CP_ALL | LV_WARN)
+
+
+/* All code path message levels. */
+#define FATAL                       (CP_ALL | LV_FATAL)
+#define WARN                        (CP_ALL | LV_WARN)
+#define INFORM                      (CP_ALL | LV_INFORM)
+#define VERBOSE                     (CP_ALL | LV_VERBOSE)
+
+
+/* These constants control the message output. */
+/* Set your debug message output level and code path here. */
+#ifndef DBG_MSG_CP
+#define DBG_MSG_CP                  CP_ALL      /* Where to output messages. */
+#endif
+
+#ifndef DBG_MSG_LV
+#define DBG_MSG_LV                  LV_VERBOSE  /* Level of message output. */
+#endif
+
+
+/* DbgMessage macro. */
+#if DBG
+#define DbgMessage(CNTRL, MESSAGE)  \
+    if((CNTRL & DBG_MSG_CP) && ((CNTRL & LV_MASK) <= DBG_MSG_LV)) \
+        DbgPrint MESSAGE
+#define DbgBreak()                 DbgBreakPoint() 
+#define STATIC
+#else
+#define DbgMessage(CNTRL, MESSAGE)
+#define DbgBreak()
+#define STATIC static
+#endif /* DBG */
+
+
+
+#endif /* DEBUG_H */
+
diff -urN linux.orig/drivers/net/bcm/lm.h linux/drivers/net/bcm/lm.h
--- linux.orig/drivers/net/bcm/lm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/lm.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,476 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef LM_H
+#define LM_H
+
+#include "debug.h"
+//#include "list.h"
+#include "queue.h"
+#include "bits.h"
+#include "lmcfg.h"
+
+
+
+/******************************************************************************/
+/* Basic types. */
+/******************************************************************************/
+
+typedef char           LM_CHAR,    *PLM_CHAR;
+typedef unsigned int   LM_UINT,    *PLM_UINT;
+typedef unsigned char  LM_UINT8,   *PLM_UINT8;
+typedef unsigned short LM_UINT16,  *PLM_UINT16;
+typedef unsigned int   LM_UINT32,  *PLM_UINT32;
+typedef unsigned int   LM_COUNTER, *PLM_COUNTER;
+typedef void           LM_VOID,    *PLM_VOID;
+typedef char           LM_BOOL,    *PLM_BOOL;
+
+/* 64bit value. */
+typedef struct {
+#ifdef BIG_ENDIAN_HOST
+    LM_UINT32 High;
+    LM_UINT32 Low;
+#else /* BIG_ENDIAN_HOST */
+    LM_UINT32 Low;
+    LM_UINT32 High;
+#endif /* !BIG_ENDIAN_HOST */
+} LM_UINT64, *PLM_UINT64;
+
+typedef LM_UINT64 LM_PHYSICAL_ADDRESS, *PLM_PHYSICAL_ADDRESS;
+
+/* void LM_INC_PHYSICAL_ADDRESS(PLM_PHYSICAL_ADDRESS pAddr,LM_UINT32 IncSize) */
+#define LM_INC_PHYSICAL_ADDRESS(pAddr, IncSize)             \
+    {                                                       \
+        LM_UINT32 OrgLow;                                   \
+                                                            \
+        OrgLow = (pAddr)->Low;                              \
+        (pAddr)->Low += IncSize;                            \
+        if((pAddr)->Low < OrgLow) {                         \
+            (pAddr)->High++; /* Wrap around. */             \
+        }                                                   \
+    }
+    
+
+#ifndef TRUE
+#define TRUE           1
+#endif /* TRUE */
+
+#ifndef FALSE
+#define FALSE          0
+#endif /* FALSE */
+
+#ifndef NULL
+#define NULL                ((void *) 0)
+#endif /* NULL */
+
+#ifndef OFFSETOF
+#define OFFSETOF(_s, _m)    (MM_UINT_PTR(&(((_s *) 0)->_m)))
+#endif /* OFFSETOF */
+
+
+
+/******************************************************************************/
+/* Simple macros. */
+/******************************************************************************/
+
+#define IS_ETH_BROADCAST(_pEthAddr)                                         \
+    (((unsigned char *) (_pEthAddr))[0] == ((unsigned char) 0xff))
+
+#define IS_ETH_MULTICAST(_pEthAddr)                                         \
+    (((unsigned char *) (_pEthAddr))[0] & ((unsigned char) 0x01))
+
+#define IS_ETH_ADDRESS_EQUAL(_pEtherAddr1, _pEtherAddr2)                    \
+    ((((unsigned char *) (_pEtherAddr1))[0] ==                              \
+    ((unsigned char *) (_pEtherAddr2))[0]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[1] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[1]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[2] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[2]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[3] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[3]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[4] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[4]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[5] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[5]))
+
+#define COPY_ETH_ADDRESS(_Src, _Dst)                                        \
+    ((unsigned char *) (_Dst))[0] = ((unsigned char *) (_Src))[0];          \
+    ((unsigned char *) (_Dst))[1] = ((unsigned char *) (_Src))[1];          \
+    ((unsigned char *) (_Dst))[2] = ((unsigned char *) (_Src))[2];          \
+    ((unsigned char *) (_Dst))[3] = ((unsigned char *) (_Src))[3];          \
+    ((unsigned char *) (_Dst))[4] = ((unsigned char *) (_Src))[4];          \
+    ((unsigned char *) (_Dst))[5] = ((unsigned char *) (_Src))[5];
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+#define ETHERNET_ADDRESS_SIZE           6
+#define ETHERNET_PACKET_HEADER_SIZE     14
+#define MIN_ETHERNET_PACKET_SIZE        64      /* with 4 byte crc. */
+#define MAX_ETHERNET_PACKET_SIZE        1518    /* with 4 byte crc. */
+#define MIN_ETHERNET_PACKET_SIZE_NO_CRC 60
+#define MAX_ETHERNET_PACKET_SIZE_NO_CRC 1514
+#define MAX_ETHERNET_PACKET_BUFFER_SIZE 1536    /* A nice even number. */
+
+#ifndef LM_MAX_MC_TABLE_SIZE
+#define LM_MAX_MC_TABLE_SIZE            32
+#endif /* LM_MAX_MC_TABLE_SIZE */
+#define LM_MC_ENTRY_SIZE                (ETHERNET_ADDRESS_SIZE+1)
+#define LM_MC_INSTANCE_COUNT_INDEX      (LM_MC_ENTRY_SIZE-1)
+
+
+/* Receive filter masks. */
+#define LM_ACCEPT_UNICAST               0x0001
+#define LM_ACCEPT_MULTICAST             0x0002
+#define LM_ACCEPT_ALL_MULTICAST         0x0004
+#define LM_ACCEPT_BROADCAST             0x0008
+#define LM_ACCEPT_ERROR_PACKET          0x0010
+
+#define LM_PROMISCUOUS_MODE             0x10000
+
+
+
+/******************************************************************************/
+/* PCI registers. */
+/******************************************************************************/
+
+#define PCI_VENDOR_ID_REG               0x00
+#define PCI_DEVICE_ID_REG               0x02
+
+#define PCI_COMMAND_REG                 0x04
+#define PCI_IO_SPACE_ENABLE             0x0001
+#define PCI_MEM_SPACE_ENABLE            0x0002
+#define PCI_BUSMASTER_ENABLE            0x0004
+#define PCI_MEMORY_WRITE_INVALIDATE     0x0010
+#define PCI_PARITY_ERROR_ENABLE         0x0040
+#define PCI_SYSTEM_ERROR_ENABLE         0x0100
+#define PCI_FAST_BACK_TO_BACK_ENABLE    0x0200
+
+#define PCI_STATUS_REG                  0x06
+#define PCI_REV_ID_REG                  0x08
+
+#define PCI_CACHE_LINE_SIZE_REG         0x0c
+
+#define PCI_IO_BASE_ADDR_REG            0x10
+#define PCI_IO_BASE_ADDR_MASK           0xfffffff0
+
+#define PCI_MEM_BASE_ADDR_LOW           0x10
+#define PCI_MEM_BASE_ADDR_HIGH          0x14
+
+#define PCI_SUBSYSTEM_VENDOR_ID_REG     0x2c
+#define PCI_SUBSYSTEM_ID_REG            0x2e
+#define PCI_INT_LINE_REG                0x3c
+
+#define PCIX_CAP_REG                    0x40
+#define PCIX_ENABLE_RELAXED_ORDERING    BIT_17
+
+/******************************************************************************/
+/* Fragment structure. */
+/******************************************************************************/
+
+typedef struct {
+    LM_UINT32 FragSize;
+    LM_PHYSICAL_ADDRESS FragBuf;
+} LM_FRAG, *PLM_FRAG;
+
+typedef struct {
+    /* FragCount is initialized for the caller to the maximum array size, on */
+    /* return FragCount is the number of the actual fragments in the array. */
+    LM_UINT32 FragCount;
+
+    /* Total buffer size. */
+    LM_UINT32 TotalSize;
+
+    /* Fragment array buffer. */
+    LM_FRAG Fragments[1];
+} LM_FRAG_LIST, *PLM_FRAG_LIST;
+
+#define DECLARE_FRAG_LIST_BUFFER_TYPE(_FRAG_LIST_TYPE_NAME, _MAX_FRAG_COUNT) \
+    typedef struct {                                                         \
+        LM_FRAG_LIST FragList;                                               \
+        LM_FRAG FragListBuffer[_MAX_FRAG_COUNT-1];                           \
+    } _FRAG_LIST_TYPE_NAME, *P##_FRAG_LIST_TYPE_NAME
+
+
+
+/******************************************************************************/
+/* Status codes. */
+/******************************************************************************/
+
+#define LM_STATUS_SUCCESS                                       0
+#define LM_STATUS_FAILURE                                       1
+
+#define LM_STATUS_INTERRUPT_ACTIVE                              2
+#define LM_STATUS_INTERRUPT_NOT_ACTIVE                          3
+
+#define LM_STATUS_LINK_ACTIVE                                   4
+#define LM_STATUS_LINK_DOWN                                     5
+#define LM_STATUS_LINK_SETTING_MISMATCH                         6
+
+#define LM_STATUS_TOO_MANY_FRAGMENTS                            7
+#define LM_STATUS_TRANSMIT_ABORTED                              8
+#define LM_STATUS_TRANSMIT_ERROR                                9
+#define LM_STATUS_RECEIVE_ABORTED                               10
+#define LM_STATUS_RECEIVE_ERROR                                 11
+#define LM_STATUS_INVALID_PACKET_SIZE                           12
+#define LM_STATUS_OUT_OF_MAP_REGISTERS                          13
+#define LM_STATUS_UNKNOWN_ADAPTER                               14
+
+typedef LM_UINT LM_STATUS, *PLM_STATUS;
+
+
+
+/******************************************************************************/
+/* Requested media type. */
+/******************************************************************************/
+
+#define LM_REQUESTED_MEDIA_TYPE_AUTO                            0
+#define LM_REQUESTED_MEDIA_TYPE_BNC                             1
+#define LM_REQUESTED_MEDIA_TYPE_UTP_AUTO                        2
+#define LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS                      3
+#define LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX          4
+#define LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS                     5
+#define LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX         6
+#define LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS                    7
+#define LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX        8
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS                   9
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS_FULL_DUPLEX       10
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS                  11
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX      12
+#define LM_REQUESTED_MEDIA_TYPE_MAC_LOOPBACK                    0xfffe
+#define LM_REQUESTED_MEDIA_TYPE_PHY_LOOPBACK                    0xffff
+
+typedef LM_UINT32 LM_REQUESTED_MEDIA_TYPE, *PLM_REQUESTED_MEDIA_TYPE;
+
+
+
+/******************************************************************************/
+/* Media type. */
+/******************************************************************************/
+
+#define LM_MEDIA_TYPE_UNKNOWN                                   -1
+#define LM_MEDIA_TYPE_AUTO                                      0
+#define LM_MEDIA_TYPE_UTP                                       1
+#define LM_MEDIA_TYPE_BNC                                       2
+#define LM_MEDIA_TYPE_AUI                                       3
+#define LM_MEDIA_TYPE_FIBER                                     4
+
+typedef LM_UINT32 LM_MEDIA_TYPE, *PLM_MEDIA_TYPE;
+
+
+
+/******************************************************************************/
+/* Line speed. */
+/******************************************************************************/
+
+#define LM_LINE_SPEED_UNKNOWN                                   0
+#define LM_LINE_SPEED_10MBPS                                    1
+#define LM_LINE_SPEED_100MBPS                                   2
+#define LM_LINE_SPEED_1000MBPS                                  3
+
+typedef LM_UINT32 LM_LINE_SPEED, *PLM_LINE_SPEED;
+
+
+
+/******************************************************************************/
+/* Duplex mode. */
+/******************************************************************************/
+
+#define LM_DUPLEX_MODE_UNKNOWN                                  0
+#define LM_DUPLEX_MODE_HALF                                     1
+#define LM_DUPLEX_MODE_FULL                                     2
+
+typedef LM_UINT32 LM_DUPLEX_MODE, *PLM_DUPLEX_MODE;
+
+
+
+/******************************************************************************/
+/* Power state. */
+/******************************************************************************/
+
+#define LM_POWER_STATE_D0       0
+#define LM_POWER_STATE_D1       1
+#define LM_POWER_STATE_D2       2
+#define LM_POWER_STATE_D3       3
+
+typedef LM_UINT32 LM_POWER_STATE, *PLM_POWER_STATE;
+
+
+
+/******************************************************************************/
+/* Task offloading. */
+/******************************************************************************/
+
+#define LM_TASK_OFFLOAD_NONE                    0x0000
+#define LM_TASK_OFFLOAD_TX_IP_CHECKSUM          0x0001
+#define LM_TASK_OFFLOAD_RX_IP_CHECKSUM          0x0002
+#define LM_TASK_OFFLOAD_TX_TCP_CHECKSUM         0x0004
+#define LM_TASK_OFFLOAD_RX_TCP_CHECKSUM         0x0008
+#define LM_TASK_OFFLOAD_TX_UDP_CHECKSUM         0x0010
+#define LM_TASK_OFFLOAD_RX_UDP_CHECKSUM         0x0020
+#define LM_TASK_OFFLOAD_TCP_SEGMENTATION        0x0040
+
+typedef LM_UINT32 LM_TASK_OFFLOAD, *PLM_TASK_OFFLOAD;
+
+
+
+/******************************************************************************/
+/* Flow control. */
+/******************************************************************************/
+
+#define LM_FLOW_CONTROL_NONE                    0x00
+#define LM_FLOW_CONTROL_RECEIVE_PAUSE           0x01
+#define LM_FLOW_CONTROL_TRANSMIT_PAUSE          0x02
+#define LM_FLOW_CONTROL_RX_TX_PAUSE (LM_FLOW_CONTROL_RECEIVE_PAUSE | \
+    LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+
+/* This value can be or-ed with RECEIVE_PAUSE and TRANSMIT_PAUSE.  If the */
+/* auto-negotiation is disabled and the RECEIVE_PAUSE and TRANSMIT_PAUSE */
+/* bits are set, then flow control is enabled regardless of link partner's */
+/* flow control capability. */
+#define LM_FLOW_CONTROL_AUTO_PAUSE              0x80000000
+
+typedef LM_UINT32 LM_FLOW_CONTROL, *PLM_FLOW_CONTROL;
+
+
+
+/******************************************************************************/
+/* Wake up mode. */
+/******************************************************************************/
+
+#define LM_WAKE_UP_MODE_NONE                    0
+#define LM_WAKE_UP_MODE_MAGIC_PACKET            1
+#define LM_WAKE_UP_MODE_NWUF                    2
+#define LM_WAKE_UP_MODE_LINK_CHANGE             4
+
+typedef LM_UINT32 LM_WAKE_UP_MODE, *PLM_WAKE_UP_MODE;
+
+
+
+/******************************************************************************/
+/* Counters. */
+/******************************************************************************/
+
+#define LM_COUNTER_FRAMES_XMITTED_OK                            0
+#define LM_COUNTER_FRAMES_RECEIVED_OK                           1
+#define LM_COUNTER_ERRORED_TRANSMIT_COUNT                       2
+#define LM_COUNTER_ERRORED_RECEIVE_COUNT                        3
+#define LM_COUNTER_RCV_CRC_ERROR                                4
+#define LM_COUNTER_ALIGNMENT_ERROR                              5
+#define LM_COUNTER_SINGLE_COLLISION_FRAMES                      6
+#define LM_COUNTER_MULTIPLE_COLLISION_FRAMES                    7
+#define LM_COUNTER_FRAMES_DEFERRED                              8
+#define LM_COUNTER_MAX_COLLISIONS                               9
+#define LM_COUNTER_RCV_OVERRUN                                  10
+#define LM_COUNTER_XMIT_UNDERRUN                                11
+#define LM_COUNTER_UNICAST_FRAMES_XMIT                          12
+#define LM_COUNTER_MULTICAST_FRAMES_XMIT                        13
+#define LM_COUNTER_BROADCAST_FRAMES_XMIT                        14
+#define LM_COUNTER_UNICAST_FRAMES_RCV                           15
+#define LM_COUNTER_MULTICAST_FRAMES_RCV                         16
+#define LM_COUNTER_BROADCAST_FRAMES_RCV                         17
+
+typedef LM_UINT32 LM_COUNTER_TYPE, *PLM_COUNTER_TYPE;
+
+
+
+/******************************************************************************/
+/* Forward definition. */
+/******************************************************************************/
+
+typedef struct _LM_DEVICE_BLOCK *PLM_DEVICE_BLOCK;
+typedef struct _LM_PACKET *PLM_PACKET;
+
+
+
+/******************************************************************************/
+/* Function prototypes. */
+/******************************************************************************/
+
+LM_STATUS LM_GetAdapterInfo(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_InitializeAdapter(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_ResetAdapter(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_DisableInterrupt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_EnableInterrupt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SendPacket(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS LM_ServiceInterrupts(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_QueueRxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetReceiveMask(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Mask);
+LM_STATUS LM_Halt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_Abort(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_MulticastAdd(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMcAddress);
+LM_STATUS LM_MulticastDel(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMcAddress);
+LM_STATUS LM_MulticastClear(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetMacAddress(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMacAddress);
+LM_STATUS LM_LoopbackAddress(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pAddress);
+
+LM_UINT32 LM_GetCrcCounter(PLM_DEVICE_BLOCK pDevice);
+
+LM_WAKE_UP_MODE LM_PMCapabilities(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_NwufAdd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 ByteMaskSize,
+    LM_UINT8 *pByteMask, LM_UINT8 *pPattern);
+LM_STATUS LM_NwufRemove(PLM_DEVICE_BLOCK pDevice, LM_UINT32 ByteMaskSize,
+    LM_UINT8 *pByteMask, LM_UINT8 *pPattern);
+LM_STATUS LM_SetPowerState(PLM_DEVICE_BLOCK pDevice, LM_POWER_STATE PowerLevel);
+
+LM_VOID LM_ReadPhy(PLM_DEVICE_BLOCK pDevice, LM_UINT32 PhyReg,
+    PLM_UINT32 pData32);
+LM_VOID LM_WritePhy(PLM_DEVICE_BLOCK pDevice, LM_UINT32 PhyReg,
+    LM_UINT32 Data32);
+
+LM_STATUS LM_ControlLoopBack(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Control);
+LM_STATUS LM_SetupPhy(PLM_DEVICE_BLOCK pDevice);
+int LM_BlinkLED(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlinkDuration);
+
+
+
+/******************************************************************************/
+/* These are the OS specific functions called by LMAC. */
+/******************************************************************************/
+
+LM_STATUS MM_ReadConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT16 *pValue16);
+LM_STATUS MM_WriteConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT16 Value16);
+LM_STATUS MM_ReadConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT32 *pValue32);
+LM_STATUS MM_WriteConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT32 Value32);
+LM_STATUS MM_MapMemBase(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_MapIoBase(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateRxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateTxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_StartTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS MM_CompleteTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS MM_AllocateMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize, 
+    PLM_VOID *pMemoryBlockVirt);
+LM_STATUS MM_AllocateSharedMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+    PLM_VOID *pMemoryBlockVirt, PLM_PHYSICAL_ADDRESS pMemoryBlockPhy,
+    LM_BOOL Cached);
+LM_STATUS MM_GetConfig(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateStatus(PLM_DEVICE_BLOCK pDevice, LM_STATUS Status);
+LM_STATUS MM_InitializeUmPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_FreeRxBuffer(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS LM_MbufWorkAround(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetLinkSpeed(PLM_DEVICE_BLOCK pDevice,
+			  LM_REQUESTED_MEDIA_TYPE RequestedMediaType);
+
+
+
+#endif /* LM_H */
+
diff -urN linux.orig/drivers/net/bcm/lmcfg.h linux/drivers/net/bcm/lmcfg.h
--- linux.orig/drivers/net/bcm/lmcfg.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/lmcfg.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,39 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef LMCFG_H
+#define LMCFG_H
+
+
+
+/******************************************************************************/
+/* Configurable constants */
+/******************************************************************************/
+
+#define LM_MAJOR_VER                1
+#define LM_MINOR_VER                0
+
+#define LM_SHORT_COMPANY_NAME_STR   "Broadcom"
+#define LM_LONG_COMPANY_NAME_STR    "Broadcom Corporation"
+
+#define LM_LONG_COPYRIGHT_STR    "Copyright \251 2000 Broadcom Corporation.  All rights reserved."
+#define LM_SHORT_COPYRIGHT_STR   "Copyright \251 2000 Broadcom Corporation."
+
+#define LM_DRV_PRODUCT_NAME_STR  "Gigabit Ethernet Driver"
+
+
+
+#endif /* LMCFG_H */
+
diff -urN linux.orig/drivers/net/bcm/mm.h linux/drivers/net/bcm/mm.h
--- linux.orig/drivers/net/bcm/mm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/mm.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,177 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/******************************************************************************/
+
+#ifndef MM_H
+#define MM_H
+
+#include <linux/config.h>
+#if defined(CONFIG_SMP) && ! defined(__SMP__)
+#define __SMP__
+#endif
+#if defined(CONFIG_MODVERSIONS) && defined(MODULE) && ! defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+
+#ifndef B57UM
+#define __NO_VERSION__
+#endif
+#include <linux/version.h>
+#ifdef MODULE
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/module.h>
+#else
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#define SET_MODULE_OWNER(dev)
+#define MODULE_DEVICE_TABLE(pci, pci_tbl)
+#endif
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <asm/processor.h>		/* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/unaligned.h>
+#include <asm/delay.h>
+#include <linux/time.h>
+#if (LINUX_VERSION_CODE >= 0x020400)
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#endif
+#ifdef CONFIG_PROC_FS
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+#endif
+
+#include "lm.h"
+#include "queue.h"
+#include "tigon3.h"
+
+extern int MM_Packet_Desc_Size;
+
+#define MM_PACKET_DESC_SIZE MM_Packet_Desc_Size
+
+DECLARE_QUEUE_TYPE(UM_RX_PACKET_Q, MAX_RX_PACKET_DESC_COUNT+1);
+
+#define MAX_MEM 16
+
+#if (LINUX_VERSION_CODE < 0x020211)
+typedef u32 dma_addr_t;
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02030e)
+#define net_device device
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+#define tasklet_struct			tq_struct
+#endif
+
+typedef struct _UM_DEVICE_BLOCK {
+	LM_DEVICE_BLOCK lm_dev;
+	struct net_device *dev;
+	struct pci_dev *pdev;
+	struct net_device *next_module;
+	char *name;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *pfs_entry;
+	char pfs_name[32];
+#endif
+	void *mem_list[MAX_MEM];
+	dma_addr_t dma_list[MAX_MEM];
+	int mem_size_list[MAX_MEM];
+	int mem_list_num;
+	int index;
+	int opened;
+	int delayed_link_ind; /* Delay link status during initial load */
+	int adapter_just_inited; /* the first few seconds after init. */
+	int timer_interval;
+	int adaptive_expiry;
+	int tx_full;
+	int tx_queued;
+	int line_speed;		/* in Mbps, 0 if link is down */
+	UM_RX_PACKET_Q rx_out_of_buf_q;
+	int rx_out_of_buf;
+	int rx_buf_repl_thresh;
+	int rx_buf_repl_panic_thresh;
+	struct timer_list timer;
+	int do_global_lock;
+	spinlock_t global_lock;
+	spinlock_t undi_lock;
+	long undi_flags;
+	volatile int interrupt;
+	int tasklet_pending;
+	int tasklet_busy;
+	struct tasklet_struct tasklet;
+	struct net_device_stats stats;
+#ifdef NICE_SUPPORT
+	void (*nice_rx)( struct sk_buff*, void* );
+	void* nice_ctx;
+#endif /* NICE_SUPPORT */
+	int rx_adaptive_coalesce;
+	uint rx_last_cnt;
+	uint tx_last_cnt;
+	uint rx_curr_coalesce_frames;
+	uint rx_curr_coalesce_ticks;
+#if TIGON3_DEBUG
+	uint tx_zc_count;
+	uint tx_chksum_count;
+	uint tx_himem_count;
+	uint rx_good_chksum_count;
+#endif
+	uint rx_bad_chksum_count;
+	uint rx_misc_errors;
+} UM_DEVICE_BLOCK, *PUM_DEVICE_BLOCK;
+
+#define MM_ACQUIRE_UNDI_LOCK(_pDevice) \
+	if (!(((PUM_DEVICE_BLOCK)(_pDevice))->do_global_lock)) {	\
+		long flags;						\
+		spin_lock_irqsave(&((PUM_DEVICE_BLOCK)(_pDevice))->undi_lock, flags);	\
+		((PUM_DEVICE_BLOCK)(_pDevice))->undi_flags = flags; \
+	}
+
+#define MM_RELEASE_UNDI_LOCK(_pDevice) \
+	if (!(((PUM_DEVICE_BLOCK)(_pDevice))->do_global_lock)) {	\
+		long flags = ((PUM_DEVICE_BLOCK) (_pDevice))->undi_flags; \
+		spin_unlock_irqrestore(&((PUM_DEVICE_BLOCK)(_pDevice))->undi_lock, flags); \
+	}
+
+#define MM_ACQUIRE_INT_LOCK(_pDevice) \
+	while (((PUM_DEVICE_BLOCK) _pDevice)->interrupt)
+
+#define MM_RELEASE_INT_LOCK(_pDevice)
+
+#define MM_UINT_PTR(_ptr)   ((unsigned long) (_ptr))
+
+#define DbgPrint(fmt, arg...) printk(KERN_WARNING fmt, ##arg)
+#if defined(CONFIG_X86)
+#define DbgBreakPoint() __asm__("int $129")
+#else
+#define DbgBreakPoint()
+#endif
+#define MM_Wait(time) udelay(time)
+
+#endif
diff -urN linux.orig/drivers/net/bcm/nicext.h linux/drivers/net/bcm/nicext.h
--- linux.orig/drivers/net/bcm/nicext.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/nicext.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,110 @@
+/****************************************************************************
+ * Copyright(c) 2000-2001 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.          
+ *
+ * Name:        nicext.h
+ *
+ * Description: Broadcom Network Interface Card Extension (NICE) is an 
+ *              extension to Linux NET device kernel mode drivers. 
+ *              NICE is designed to provide additional functionalities, 
+ *              such as receive packet intercept. To support Broadcom NICE, 
+ *              the network device driver can be modified by adding an 
+ *              device ioctl handler and by indicating receiving packets 
+ *              to the NICE receive handler. Broadcom NICE will only be 
+ *              enabled by a NICE-aware intermediate driver, such as 
+ *              Broadcom Advanced Server Program Driver (BASP). When NICE 
+ *              is not enabled, the modified network device drivers 
+ *              functions exactly as other non-NICE aware drivers.
+ *
+ * Author:      Frankie Fan
+ *
+ * Created:     September 17, 2000
+ *
+ ****************************************************************************/
+#ifndef _nicext_h_
+#define _nicext_h_
+
+/*
+ * ioctl for NICE
+ */
+#define SIOCNICE                   	SIOCDEVPRIVATE+7
+
+/*
+ * SIOCNICE: 
+ *
+ * The following structure needs to be less than IFNAMSIZ (16 bytes) because
+ * we're overloading ifreq.ifr_ifru.
+ *
+ * If 16 bytes is not enough, we should consider relaxing this because
+ * this is no field after ifr_ifru in the ifreq structure. But we may
+ * run into future compatiability problem in case of changing struct ifreq.
+ */
+struct nice_req
+{
+    __u32 cmd;
+    
+    union
+    {
+#ifdef __KERNEL__
+        /* cmd = NICE_CMD_SET_RX or NICE_CMD_GET_RX */
+        struct
+        {
+            void (*nrqus1_rx)( struct sk_buff*, void* );
+            void* nrqus1_ctx;
+        } nrqu_nrqus1;
+
+        /* cmd = NICE_CMD_QUERY_SUPPORT */
+        struct
+        {
+            __u32 nrqus2_magic;
+            __u32 nrqus2_support_rx:1;
+            __u32 nrqus2_support_vlan:1;
+            __u32 nrqus2_support_get_speed:1;
+        } nrqu_nrqus2;
+#endif
+
+        /* cmd = NICE_CMD_GET_SPEED */
+        struct
+        {
+            unsigned int nrqus3_speed; /* 0 if link is down, */
+                                       /* otherwise speed in Mbps */
+        } nrqu_nrqus3;
+
+        /* cmd = NICE_CMD_BLINK_LED */
+        struct
+        {
+            unsigned int nrqus4_blink_time; /* blink duration in seconds */
+        } nrqu_nrqus4;
+
+    } nrq_nrqu;
+};
+
+#define nrq_rx           nrq_nrqu.nrqu_nrqus1.nrqus1_rx
+#define nrq_ctx          nrq_nrqu.nrqu_nrqus1.nrqus1_ctx
+#define nrq_support_rx   nrq_nrqu.nrqu_nrqus2.nrqus2_support_rx
+#define nrq_magic        nrq_nrqu.nrqu_nrqus2.nrqus2_magic
+#define nrq_support_vlan nrq_nrqu.nrqu_nrqus2.nrqus2_support_vlan
+#define nrq_support_get_speed nrq_nrqu.nrqu_nrqus2.nrqus2_support_get_speed
+#define nrq_speed        nrq_nrqu.nrqu_nrqus3.nrqus3_speed
+#define nrq_blink_time   nrq_nrqu.nrqu_nrqus4.nrqus4_blink_time
+
+/*
+ * magic constants
+ */
+#define NICE_REQUESTOR_MAGIC            0x4543494E // NICE in ascii
+#define NICE_DEVICE_MAGIC               0x4E494345 // ECIN in ascii
+
+/*
+ * command field
+ */
+#define NICE_CMD_QUERY_SUPPORT          0x00000001
+#define NICE_CMD_SET_RX                 0x00000002
+#define NICE_CMD_GET_RX                 0x00000003
+#define NICE_CMD_GET_SPEED              0x00000004
+#define NICE_CMD_BLINK_LED              0x00000005
+
+#endif  // _nicext_h_ 
+
diff -urN linux.orig/drivers/net/bcm/queue.h linux/drivers/net/bcm/queue.h
--- linux.orig/drivers/net/bcm/queue.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/queue.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,338 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* Queue functions.                                                           */
+/*    void          QQ_InitQueue(PQQ_CONTAINER pQueue)                        */
+/*    char          QQ_Full(PQQ_CONTAINER pQueue)                             */
+/*    char          QQ_Empty(PQQ_CONTAINER pQueue)                            */
+/*    unsigned int QQ_GetSize(PQQ_CONTAINER pQueue)                          */
+/*    unsigned int QQ_GetEntryCnt(PQQ_CONTAINER pQueue)                      */
+/*    char          QQ_PushHead(PQQ_CONTAINER pQueue, PQQ_ENTRY pEntry)       */
+/*    char          QQ_PushTail(PQQ_CONTAINER pQueue, PQQ_ENTRY pEntry)       */
+/*    PQQ_ENTRY     QQ_PopHead(PQQ_CONTAINER pQueue)                          */
+/*    PQQ_ENTRY     QQ_PopTail(PQQ_CONTAINER pQueue)                          */
+/*    PQQ_ENTRY     QQ_GetHead(PQQ_CONTAINER pQueue, unsigned int Idx)       */
+/*    PQQ_ENTRY     QQ_GetTail(PQQ_CONTAINER pQueue, unsigned int Idx)       */
+/*                                                                            */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef BCM_QUEUE_H
+#define BCM_QUEUE_H
+
+
+
+/******************************************************************************/
+/* Queue definitions. */
+/******************************************************************************/
+
+/* Entry for queueing. */
+typedef void *PQQ_ENTRY;
+
+
+/* Queue header -- base type. */
+typedef struct {
+    unsigned int Head;
+    unsigned int Tail;
+    unsigned int Size;
+    atomic_t EntryCnt;
+    PQQ_ENTRY Array[1];
+} QQ_CONTAINER, *PQQ_CONTAINER;
+
+
+/* Declare queue type macro. */
+#define DECLARE_QUEUE_TYPE(_QUEUE_TYPE, _QUEUE_SIZE)            \
+                                                                \
+    typedef struct {                                            \
+        QQ_CONTAINER Container;                                 \
+        PQQ_ENTRY EntryBuffer[_QUEUE_SIZE];                     \
+    } _QUEUE_TYPE, *P##_QUEUE_TYPE
+
+
+
+/******************************************************************************/
+/* Compilation switches. */
+/******************************************************************************/
+
+#if DBG
+#undef QQ_NO_OVERFLOW_CHECK
+#undef QQ_NO_UNDERFLOW_CHECK
+#endif /* DBG */
+
+#ifdef QQ_USE_MACROS
+/* notdone */
+#else
+
+#ifdef QQ_NO_INLINE
+#define __inline
+#endif /* QQ_NO_INLINE */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void 
+QQ_InitQueue(
+PQQ_CONTAINER pQueue,
+unsigned int QueueSize) {
+    pQueue->Head = 0;
+    pQueue->Tail = 0;
+    pQueue->Size = QueueSize+1;
+    atomic_set(&pQueue->EntryCnt, 0);
+} /* QQ_InitQueue */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_Full(
+PQQ_CONTAINER pQueue) {
+    unsigned int NewHead;
+
+    NewHead = (pQueue->Head + 1) % pQueue->Size;
+
+    return(NewHead == pQueue->Tail);
+} /* QQ_Full */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_Empty(
+PQQ_CONTAINER pQueue) {
+    return(pQueue->Head == pQueue->Tail);
+} /* QQ_Empty */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned int 
+QQ_GetSize(
+PQQ_CONTAINER pQueue) {
+    return pQueue->Size;
+} /* QQ_GetSize */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned int 
+QQ_GetEntryCnt(
+PQQ_CONTAINER pQueue) {
+    return atomic_read(&pQueue->EntryCnt);
+} /* QQ_GetEntryCnt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    TRUE entry was added successfully.                                      */
+/*    FALSE queue is full.                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_PushHead(
+PQQ_CONTAINER pQueue, 
+PQQ_ENTRY pEntry) {
+    unsigned int Head;
+
+    Head = (pQueue->Head + 1) % pQueue->Size;
+
+#if !defined(QQ_NO_OVERFLOW_CHECK)
+    if(Head == pQueue->Tail) {
+        return 0;
+    } /* if */
+#endif /* QQ_NO_OVERFLOW_CHECK */
+
+    pQueue->Array[pQueue->Head] = pEntry;
+    pQueue->Head = Head;
+    atomic_inc(&pQueue->EntryCnt);
+
+    return -1;
+} /* QQ_PushHead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    TRUE entry was added successfully.                                      */
+/*    FALSE queue is full.                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_PushTail(
+PQQ_CONTAINER pQueue,
+PQQ_ENTRY pEntry) {
+    unsigned int Tail;
+
+    Tail = pQueue->Tail;
+    if(Tail == 0) {
+        Tail = pQueue->Size;
+    } /* if */
+    Tail--;
+
+#if !defined(QQ_NO_OVERFLOW_CHECK)
+    if(Tail == pQueue->Head) {
+        return 0;
+    } /* if */
+#endif /* QQ_NO_OVERFLOW_CHECK */
+
+    pQueue->Array[Tail] = pEntry;
+    pQueue->Tail = Tail;
+    atomic_inc(&pQueue->EntryCnt);
+
+    return -1;
+} /* QQ_PushTail */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_PopHead(
+PQQ_CONTAINER pQueue) {
+    unsigned int Head;
+    PQQ_ENTRY Entry;
+
+    Head = pQueue->Head;
+
+#if !defined(QQ_NO_UNDERFLOW_CHECK)
+    if(Head == pQueue->Tail) {
+        return (PQQ_ENTRY) 0;
+    } /* if */
+#endif /* QQ_NO_UNDERFLOW_CHECK */
+
+    if(Head == 0) {
+        Head = pQueue->Size;
+    } /* if */
+    Head--;
+
+    Entry = pQueue->Array[Head];
+    pQueue->Head = Head;
+    atomic_dec(&pQueue->EntryCnt);
+
+    return Entry;
+} /* QQ_PopHead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_PopTail(
+PQQ_CONTAINER pQueue) {
+    unsigned int Tail;
+    PQQ_ENTRY Entry;
+
+    Tail = pQueue->Tail;
+
+#if !defined(QQ_NO_UNDERFLOW_CHECK)
+    if(Tail == pQueue->Head) {
+        return (PQQ_ENTRY) 0;
+    } /* if */
+#endif /* QQ_NO_UNDERFLOW_CHECK */
+
+    Entry = pQueue->Array[Tail];
+    pQueue->Tail = (Tail + 1) % pQueue->Size;
+    atomic_dec(&pQueue->EntryCnt);
+
+    return Entry;
+} /* QQ_PopTail */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_GetHead(
+    PQQ_CONTAINER pQueue,
+    unsigned int Idx)
+{
+    if(Idx >= atomic_read(&pQueue->EntryCnt))
+    {
+        return (PQQ_ENTRY) 0;
+    }
+
+    if(pQueue->Head > Idx)
+    {
+        Idx = pQueue->Head - Idx;
+    }
+    else
+    {
+        Idx = pQueue->Size - (Idx - pQueue->Head);
+    }
+    Idx--;
+
+    return pQueue->Array[Idx];
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_GetTail(
+    PQQ_CONTAINER pQueue,
+    unsigned int Idx)
+{
+    if(Idx >= atomic_read(&pQueue->EntryCnt))
+    {
+        return (PQQ_ENTRY) 0;
+    }
+
+    Idx += pQueue->Tail;
+    if(Idx >= pQueue->Size)
+    {
+        Idx = Idx - pQueue->Size;
+    }
+
+    return pQueue->Array[Idx];
+}
+
+#endif /* QQ_USE_MACROS */
+
+
+
+#endif /* QUEUE_H */
diff -urN linux.orig/drivers/net/bcm/tigon3.c linux/drivers/net/bcm/tigon3.c
--- linux.orig/drivers/net/bcm/tigon3.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/tigon3.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,5416 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+#include "mm.h"
+
+
+
+/******************************************************************************/
+/* Local functions. */
+/******************************************************************************/
+
+LM_STATUS LM_Abort(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_QueueRxPackets(PLM_DEVICE_BLOCK pDevice);
+
+static LM_STATUS LM_TranslateRequestedMediaType(
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+    PLM_MEDIA_TYPE pMediaType, PLM_LINE_SPEED pLineSpeed,
+    PLM_DUPLEX_MODE pDuplexMode);
+
+static LM_STATUS LM_InitBcm540xPhy(PLM_DEVICE_BLOCK pDevice);
+
+__inline static LM_VOID LM_ServiceRxInterrupt(PLM_DEVICE_BLOCK pDevice);
+__inline static LM_VOID LM_ServiceTxInterrupt(PLM_DEVICE_BLOCK pDevice);
+
+static LM_STATUS LM_ForceAutoNegBcm540xPhy(PLM_DEVICE_BLOCK pDevice, 
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType, LM_BOOL WaitForLink);
+static LM_STATUS LM_ForceAutoNeg(PLM_DEVICE_BLOCK pDevice, 
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType, LM_BOOL WaitForLink);
+static LM_UINT32 GetPhyAdFlowCntrlSettings(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_SetFlowControl(PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 LocalPhyAd, LM_UINT32 RemotePhyAd);
+STATIC LM_STATUS LM_SetupFiberPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_SetupCopperPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_InitBcm800xPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC PLM_ADAPTER_INFO LM_GetAdapterInfoBySsid(LM_UINT16 Svid, LM_UINT16 Ssid);
+STATIC LM_STATUS LM_DmaTest(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pBufferVirt,
+           LM_PHYSICAL_ADDRESS BufferPhy, LM_UINT32 BufferSize);
+
+
+/******************************************************************************/
+/* External functions. */
+/******************************************************************************/
+
+LM_STATUS LM_LoadRlsFirmware(PLM_DEVICE_BLOCK pDevice);
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_UINT32
+LM_RegRdInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Register) {
+    LM_UINT32 Value32;
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#endif
+    MM_WriteConfig32(pDevice, T3_PCI_REG_ADDR_REG, Register);
+    MM_ReadConfig32(pDevice, T3_PCI_REG_DATA_REG, &Value32);
+#if PCIX_TARGET_WORKAROUND
+    MM_RELEASE_UNDI_LOCK(pDevice);
+#endif
+
+    return Value32;
+} /* LM_RegRdInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_RegWrInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Register,
+LM_UINT32 Value32) {
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#endif
+    MM_WriteConfig32(pDevice, T3_PCI_REG_ADDR_REG, Register);
+    MM_WriteConfig32(pDevice, T3_PCI_REG_DATA_REG, Value32);
+#if PCIX_TARGET_WORKAROUND
+    MM_RELEASE_UNDI_LOCK(pDevice);
+#endif
+} /* LM_RegWrInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_UINT32
+LM_MemRdInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 MemAddr) {
+    LM_UINT32 Value32;
+
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#ifdef BIG_ENDIAN_HOST
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    Value32 = REG_RD(pDevice, PciCfg.MemWindowData);
+    /*    Value32 = REG_RD(pDevice,uIntMem.Mbuf[(MemAddr & 0x7fff)/4]); */
+#else
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    MM_ReadConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, &Value32);
+#endif
+    MM_RELEASE_UNDI_LOCK(pDevice);
+
+    return Value32;
+} /* LM_MemRdInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_MemWrInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 MemAddr,
+LM_UINT32 Value32) {
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#ifdef BIG_ENDIAN_HOST
+    REG_WR(pDevice,PciCfg.MemWindowBaseAddr,MemAddr);
+    REG_WR(pDevice,uIntMem.Mbuf[(MemAddr & 0x7fff)/4],Value32);
+#else
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, Value32);
+#endif
+    MM_RELEASE_UNDI_LOCK(pDevice);
+} /* LM_MemWrInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_QueueRxPackets(
+PLM_DEVICE_BLOCK pDevice) {
+    LM_STATUS Lmstatus;
+    PLM_PACKET pPacket;
+    PT3_RCV_BD pRcvBd;
+    LM_UINT32 StdBdAdded = 0;
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    LM_UINT32 JumboBdAdded = 0;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    Lmstatus = LM_STATUS_SUCCESS;
+
+    pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+    while(pPacket) {
+        switch(pPacket->u.Rx.RcvProdRing) {
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+            case T3_JUMBO_RCV_PROD_RING:        /* Jumbo Receive Ring. */
+                /* Initialize the buffer descriptor. */
+                pRcvBd = 
+                    &pDevice->pRxJumboBdVirt[pDevice->RxJumboProdIdx];
+                pRcvBd->Flags = RCV_BD_FLAG_END | RCV_BD_FLAG_JUMBO_RING;
+                pRcvBd->Len = (LM_UINT16) pDevice->RxJumboBufferSize;
+
+                /* Initialize the receive buffer pointer */
+                pRcvBd->HostAddr.Low = pPacket->u.Rx.RxBufferPhy.Low;
+                pRcvBd->HostAddr.High = pPacket->u.Rx.RxBufferPhy.High;
+
+                /* The opaque field may point to an offset from a fix addr. */
+                pRcvBd->Opaque = (LM_UINT32) (MM_UINT_PTR(pPacket) - 
+                    MM_UINT_PTR(pDevice->pPacketDescBase));
+
+                /* Update the producer index. */
+                pDevice->RxJumboProdIdx = (pDevice->RxJumboProdIdx + 1) & 
+                    T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK;
+
+                JumboBdAdded++;
+                break;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+            case T3_STD_RCV_PROD_RING:      /* Standard Receive Ring. */
+                /* Initialize the buffer descriptor. */
+                pRcvBd = &pDevice->pRxStdBdVirt[pDevice->RxStdProdIdx];
+                pRcvBd->Flags = RCV_BD_FLAG_END;
+                pRcvBd->Len = MAX_STD_RCV_BUFFER_SIZE;
+
+                /* Initialize the receive buffer pointer */
+                pRcvBd->HostAddr.Low = pPacket->u.Rx.RxBufferPhy.Low;
+                pRcvBd->HostAddr.High = pPacket->u.Rx.RxBufferPhy.High;
+
+                /* The opaque field may point to an offset from a fix addr. */
+                pRcvBd->Opaque = (LM_UINT32) (MM_UINT_PTR(pPacket) - 
+                    MM_UINT_PTR(pDevice->pPacketDescBase));
+
+                /* Update the producer index. */
+                pDevice->RxStdProdIdx = (pDevice->RxStdProdIdx + 1) & 
+                    T3_STD_RCV_RCB_ENTRY_COUNT_MASK;
+
+                StdBdAdded++;
+                break;
+
+            case T3_UNKNOWN_RCV_PROD_RING:
+            default:
+                Lmstatus = LM_STATUS_FAILURE;
+                break;
+        } /* switch */
+
+        /* Bail out if there is any error. */
+        if(Lmstatus != LM_STATUS_SUCCESS)
+        {
+            break;
+        }
+
+        pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+    } /* while */
+
+    /* Update the procedure index. */
+    if(StdBdAdded)
+    {
+        REG_WR(pDevice, Mailbox.RcvStdProdIdx.Low, pDevice->RxStdProdIdx);
+//        pDevice->RxStdQueuedCnt += StdBdAdded;
+    }
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    if(JumboBdAdded)
+    {
+        REG_WR(pDevice, Mailbox.RcvJumboProdIdx.Low, pDevice->RxJumboProdIdx);
+//        pDevice->RxJumboQueuedCnt += JumboBdAdded;
+    }
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    return Lmstatus;
+} /* LM_QueueRxPackets */
+
+
+STATIC void
+LM_ReadVPD(PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT8 Vpd[256];
+    LM_UINT32 *Vpd_dptr = (LM_UINT32 *) Vpd;
+    LM_UINT16 j, Value16;
+
+    REG_WR(pDevice, Grc.LocalCtrl, REG_RD(pDevice, Grc.LocalCtrl) |
+        GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM);
+
+    MM_Wait(100);
+    /* Read PN from VPD */
+    for (j = 0; j < 256; j += 4, Vpd_dptr++ )
+    {
+        MM_WriteConfig16(pDevice, 0x52, (LM_UINT16) j);
+        while (1) {
+            MM_ReadConfig16(pDevice, 0x52, &Value16);
+            if (Value16 & 0x8000)
+                break;
+            MM_Wait(40);
+        }
+        MM_ReadConfig32(pDevice, 0x54, Vpd_dptr);
+    }
+    for (j = 0; j < 256; )
+    {
+        unsigned int Vpd_r_len;
+        unsigned int Vpd_r_end;
+
+        if ((Vpd[j] == 0x82) || (Vpd[j] == 0x91))
+        {
+            j = j + 3 + Vpd[j + 1] + (Vpd[j + 2] << 8);
+        }
+        else if (Vpd[j] == 0x90)
+        {
+            Vpd_r_len =  Vpd[j + 1] + (Vpd[j + 2] << 8);
+            j += 3;
+            Vpd_r_end = Vpd_r_len + j;
+            while (j < Vpd_r_end)
+            {
+                if ((Vpd[j] == 'P') && (Vpd[j + 1] == 'N'))
+                {
+                    int len = Vpd[j + 2];
+
+                    memcpy(pDevice->PartNo, &Vpd[j + 3], len);
+                    break;
+                }
+                else
+                {
+                    j = j + Vpd[j + 2];
+                }
+            }
+            break;
+        }
+        else {
+            break;
+        }
+    }
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine initializes default parameters and reads the PCI           */
+/*    configurations.                                                         */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_GetAdapterInfo(
+PLM_DEVICE_BLOCK pDevice)
+{
+    PLM_ADAPTER_INFO pAdapterInfo;
+    LM_UINT32 Value32;
+    LM_STATUS Status;
+    LM_UINT32 j;
+    LM_UINT32 EeSigFound;
+    LM_UINT32 EePhyTypeSerdes = 0;
+    LM_UINT32 EePhyLedMode = 0;
+    LM_UINT32 EePhyId = 0;
+
+    /* Get Device Id and Vendor Id */
+    Status = MM_ReadConfig32(pDevice, PCI_VENDOR_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->PciVendorId = (LM_UINT16) Value32;
+    pDevice->PciDeviceId = (LM_UINT16) (Value32 >> 16);
+
+    /* If we are not getting the write adapter, exit. */
+    if((Value32 != T3_PCI_ID_BCM5700) && 
+       (Value32 != T3_PCI_ID_BCM5701) &&
+       (Value32 != T3_PCI_ID_BCM5703))
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    Status = MM_ReadConfig32(pDevice, PCI_REV_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->PciRevId = (LM_UINT8) Value32;
+
+    /* Get IRQ. */
+    Status = MM_ReadConfig32(pDevice, PCI_INT_LINE_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->Irq = (LM_UINT8) Value32;
+
+    /* Get interrupt pin. */
+    pDevice->IntPin = (LM_UINT8) (Value32 >> 8);
+
+    /* Get chip revision id. */
+    Status = MM_ReadConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, &Value32);
+    pDevice->ChipRevId = Value32 >> 16;
+
+    /* Get subsystem vendor. */
+    Status = MM_ReadConfig32(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->SubsystemVendorId = (LM_UINT16) Value32;
+
+    /* Get PCI subsystem id. */
+    pDevice->SubsystemId = (LM_UINT16) (Value32 >> 16);
+
+    /* Get the cache line size. */
+    MM_ReadConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG, &Value32);
+    pDevice->CacheLineSize = (LM_UINT8) Value32;
+    pDevice->SavedCacheLineReg = Value32;
+
+    /* Get PCI memory base. */
+    MM_ReadConfig32(pDevice, PCI_MEM_BASE_ADDR_HIGH, &Value32);
+    pDevice->MemBaseHigh = Value32;
+
+    MM_ReadConfig32(pDevice, PCI_MEM_BASE_ADDR_LOW, &Value32);
+    Value32 &= 0xfffffff0;
+    pDevice->MemBaseLow = Value32;
+
+    /* Initialize require MemBase Size */
+    pDevice->MemBaseSize = sizeof(T3_STD_MEM_MAP); 
+
+    /* Map the memory base to system address space. */
+    Status = MM_MapMemBase(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Initialize the memory view pointer. */
+    pDevice->pMemView = (PT3_STD_MEM_MAP) pDevice->pMappedMemBase;
+
+#if PCIX_TARGET_WORKAROUND
+    /* store whether we are in PCI are PCI-X mode */
+    pDevice->EnablePciXFix = FALSE;
+
+    MM_ReadConfig32(pDevice, T3_PCI_STATE_REG, &Value32);
+    if((Value32 & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) == 0)
+    {
+        /* Enable PCI-X workaround only if we are running on 5700 BX. */
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            pDevice->EnablePciXFix = TRUE;
+        }
+    }
+#endif
+    /* Bx bug: due to the "byte_enable bug" in PCI-X mode, the power */
+    /* management register may be clobbered which may cause the */
+    /* BCM5700 to go into D3 state.  While in this state, we will */
+    /* not have memory mapped register access.  As a workaround, we */
+    /* need to restore the device to D0 state. */
+    MM_ReadConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, &Value32);
+    Value32 |= T3_PM_PME_ASSERTED;
+    Value32 &= ~T3_PM_POWER_STATE_MASK;
+    Value32 |= T3_PM_POWER_STATE_D0;
+    MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, Value32);
+
+    /* read the current PCI command word */
+    MM_ReadConfig32(pDevice, PCI_COMMAND_REG, &Value32);
+
+    /* Make sure bus-mastering is enabled. */
+    Value32 |= PCI_BUSMASTER_ENABLE;
+
+#if PCIX_TARGET_WORKAROUND
+	/* if we are in PCI-X mode, also make sure mem-mapping and SERR#/PERR#
+	   are enabled */
+        if (pDevice->EnablePciXFix == TRUE) {
+            Value32 |= (PCI_MEM_SPACE_ENABLE | PCI_SYSTEM_ERROR_ENABLE | 
+                        PCI_PARITY_ERROR_ENABLE);
+        }
+#endif
+
+    if(pDevice->EnableNWI)
+    {
+        Value32 |= PCI_MEMORY_WRITE_INVALIDATE;
+    }
+    else {
+        Value32 &= (~PCI_MEMORY_WRITE_INVALIDATE);
+    }
+
+    /* Error out if mem-mapping is NOT enabled for PCI systems */
+    if (!(Value32 | PCI_MEM_SPACE_ENABLE))
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* save the value we are going to write into the PCI command word */	
+    pDevice->PciCommandStatusWords = Value32;	
+
+    Status = MM_WriteConfig32(pDevice, PCI_COMMAND_REG, Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Set power state to D0. */
+    LM_SetPowerState(pDevice, LM_POWER_STATE_D0);
+
+    /* Setup the mode registers. */
+    pDevice->MiscHostCtrl = 
+        MISC_HOST_CTRL_MASK_PCI_INT | 
+        MISC_HOST_CTRL_ENABLE_ENDIAN_WORD_SWAP | 
+#ifdef BIG_ENDIAN_HOST
+        MISC_HOST_CTRL_ENABLE_ENDIAN_BYTE_SWAP |  
+#endif /* BIG_ENDIAN_HOST */
+        MISC_HOST_CTRL_ENABLE_INDIRECT_ACCESS |
+        MISC_HOST_CTRL_ENABLE_PCI_STATE_REG_RW;
+	/* write to PCI misc host ctr first in order to enable indirect accesses */
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, pDevice->MiscHostCtrl);
+
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl);
+
+#ifdef BIG_ENDIAN_HOST
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+              GRC_MODE_WORD_SWAP_NON_FRAME_DATA;
+#else
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | GRC_MODE_BYTE_SWAP_DATA;
+#endif
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    REG_WR(pDevice, PciCfg.ClockCtrl, 0);
+    REG_WR(pDevice, PciCfg.MemWindowBaseAddr, 0);
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ReadConfig32(pDevice, T3_PCI_STATE_REG, &Value32);
+    if ((pDevice->EnablePciXFix == FALSE) &&
+        ((Value32 & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) == 0))
+    {
+        if (pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B2 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B5)
+        {
+            pDevice->pMemView->uIntMem.MemBlock32K[0x300] = 0;
+            pDevice->pMemView->uIntMem.MemBlock32K[0x301] = 0;
+            pDevice->pMemView->uIntMem.MemBlock32K[0x301] = 0xffffffff;
+            if (pDevice->pMemView->uIntMem.MemBlock32K[0x300])
+            {
+                pDevice->EnablePciXFix = TRUE;
+            }
+        }
+    }
+#endif
+    /* Get the node address. */
+    Value32 = REG_RD(pDevice, MacCtrl.MacAddr[0].High);
+    pDevice->NodeAddress[0] = (LM_UINT8) (Value32 >> 8);
+    pDevice->NodeAddress[1] = (LM_UINT8) Value32;
+
+    Value32 = REG_RD(pDevice, MacCtrl.MacAddr[0].Low);
+    pDevice->NodeAddress[2] = (LM_UINT8) (Value32 >> 24);
+    pDevice->NodeAddress[3] = (LM_UINT8) (Value32 >> 16);
+    pDevice->NodeAddress[4] = (LM_UINT8) (Value32 >> 8);
+    pDevice->NodeAddress[5] = (LM_UINT8) Value32;
+
+    pDevice->PermanentNodeAddress[0] = pDevice->NodeAddress[0];
+    pDevice->PermanentNodeAddress[1] = pDevice->NodeAddress[1];
+    pDevice->PermanentNodeAddress[2] = pDevice->NodeAddress[2];
+    pDevice->PermanentNodeAddress[3] = pDevice->NodeAddress[3];
+    pDevice->PermanentNodeAddress[4] = pDevice->NodeAddress[4];
+    pDevice->PermanentNodeAddress[5] = pDevice->NodeAddress[5];
+
+    /* Initialize the default values. */
+    pDevice->NoTxPseudoHdrChksum = FALSE;
+    pDevice->NoRxPseudoHdrChksum = FALSE;
+    pDevice->NicSendBd = FALSE;
+    pDevice->TxPacketDescCnt = DEFAULT_TX_PACKET_DESC_COUNT;
+    pDevice->RxStdDescCnt = DEFAULT_STD_RCV_DESC_COUNT;
+    pDevice->RxCoalescingTicks = DEFAULT_RX_COALESCING_TICKS;
+    pDevice->TxCoalescingTicks = DEFAULT_TX_COALESCING_TICKS;
+    pDevice->RxMaxCoalescedFrames = DEFAULT_RX_MAX_COALESCED_FRAMES;
+    pDevice->TxMaxCoalescedFrames = DEFAULT_TX_MAX_COALESCED_FRAMES;
+    pDevice->RxCoalescingTicksDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->TxCoalescingTicksDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->RxMaxCoalescedFramesDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->TxMaxCoalescedFramesDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->StatsCoalescingTicks = DEFAULT_STATS_COALESCING_TICKS;
+    pDevice->TxCopyBufferSize = DEFAULT_TX_COPY_BUFFER_SIZE;
+    pDevice->EnableNWI = FALSE;
+    pDevice->TxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    pDevice->DisableAutoNeg = FALSE;
+    pDevice->PhyIntMode = T3_PHY_INT_MODE_AUTO;
+    pDevice->LinkChngMode = T3_LINK_CHNG_MODE_AUTO;
+    pDevice->Bcm540xMode = BCM540X_MODE_AUTO;
+    pDevice->ResetPhyOnInit = TRUE;
+    pDevice->DelayPciGrant = TRUE;
+    pDevice->UseTaggedStatus = FALSE;
+
+    pDevice->DmaMbufLowMark = T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO;
+    pDevice->RxMacMbufLowMark = T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO;
+    pDevice->MbufHighMark = T3_DEF_MBUF_HIGH_WMARK_JUMBO;
+
+    pDevice->RequestedMediaType = LM_REQUESTED_MEDIA_TYPE_AUTO;
+    pDevice->TaskOffloadCap = LM_TASK_OFFLOAD_NONE;
+    pDevice->FlowControlCap = LM_FLOW_CONTROL_AUTO_PAUSE;
+    pDevice->EnableTbi = FALSE;
+
+    pDevice->MbufBase = T3_NIC_MBUF_POOL_ADDR;
+    pDevice->MbufSize = T3_NIC_MBUF_POOL_SIZE;
+
+    pDevice->LinkStatus = LM_STATUS_LINK_DOWN;
+    pDevice->QueueRxPackets = TRUE;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    pDevice->RxJumboDescCnt = DEFAULT_JUMBO_RCV_DESC_COUNT;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Change driver parameters. */
+    Status = MM_GetConfig(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Make this is a known adapter. */
+    pAdapterInfo = LM_GetAdapterInfoBySsid(pDevice->SubsystemVendorId,
+        pDevice->SubsystemId);
+
+    Value32 = REG_RD(pDevice, Grc.MiscCfg) & GRC_MISC_BD_ID_MASK;
+    if (Value32 != GRC_MISC_BD_ID_5700 &&
+        Value32 != GRC_MISC_BD_ID_5701 &&
+        Value32 != GRC_MISC_BD_ID_5703)
+    {
+        return LM_STATUS_UNKNOWN_ADAPTER;
+    }
+
+    /* Get Eeprom info. */
+    Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_SIG_ADDR);
+    if (Value32 == T3_NIC_DATA_SIG)
+    {
+        EeSigFound = TRUE;
+        Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_NIC_CFG_ADDR);
+
+        /* Determine PHY type. */
+        switch (Value32 & T3_NIC_CFG_PHY_TYPE_MASK)
+        {
+            case T3_NIC_CFG_PHY_TYPE_COPPER:
+                EePhyTypeSerdes = FALSE;
+                break;
+
+            case T3_NIC_CFG_PHY_TYPE_FIBER:
+                EePhyTypeSerdes = TRUE;
+                break;
+
+            default:
+                EePhyTypeSerdes = FALSE;
+                break;
+        }
+
+        /* Determine PHY type. */
+        switch (Value32 & T3_NIC_CFG_LED_MODE_MASK)
+        {
+            case T3_NIC_CFG_LED_MODE_TRIPLE_SPEED:
+                EePhyLedMode = BCM540X_MODE_THREE_LINK;
+                break;
+
+            case T3_NIC_CFG_LED_MODE_LINK_SPEED:
+                EePhyLedMode = BCM540X_MODE_LINK10;
+                break;
+
+            default:
+                EePhyLedMode = BCM540X_MODE_AUTO;
+                break;
+        }
+
+        /* Get the PHY Id. */
+        Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_PHY_ID_ADDR);
+        if (Value32)
+        {
+            EePhyId = (((Value32 & T3_NIC_PHY_ID1_MASK) >> 16) &
+                PHY_ID1_OUI_MASK) << 10;
+
+            Value32 = Value32 & T3_NIC_PHY_ID2_MASK;
+
+            EePhyId |= ((Value32 & PHY_ID2_OUI_MASK) << 16) |
+              (Value32 & PHY_ID2_MODEL_MASK) | (Value32 & PHY_ID2_REV_MASK);
+        }
+        else
+        {
+            EePhyId = 0;
+        }
+    }
+    else
+    {
+        EeSigFound = FALSE;
+    }
+
+    /* Set the PHY address. */
+    pDevice->PhyAddr = PHY_DEVICE_ID;
+
+    /* Disable auto polling. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    MM_Wait(40);
+
+    /* Get the PHY id. */
+    LM_ReadPhy(pDevice, PHY_ID1_REG, &Value32);
+    pDevice->PhyId = (Value32 & PHY_ID1_OUI_MASK) << 10;
+
+    LM_ReadPhy(pDevice, PHY_ID2_REG, &Value32);
+    pDevice->PhyId |= ((Value32 & PHY_ID2_OUI_MASK) << 16) |
+      (Value32 & PHY_ID2_MODEL_MASK) | (Value32 & PHY_ID2_REV_MASK);
+
+    /* Set the EnableTbi flag to false if we have a copper PHY. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+            DbgMessage(INFORM, ("PHY_BCM5401_PHY_ID\n"));
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5401_PHY_ID:
+            DbgMessage(INFORM, ("PHY_BCM5401_PHY_ID\n"));
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5411_PHY_ID:
+            DbgMessage(INFORM, ("PHY_BCM5411_PHY_ID\n"));
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5701_PHY_ID:
+            DbgMessage(INFORM, ("PHY_BCM5701_PHY_ID\n"));
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM8002_PHY_ID:
+            DbgMessage(INFORM, ("PHY_BCM8002_PHY_ID\n"));
+            pDevice->EnableTbi = TRUE;
+            break;
+
+        default:
+
+            if (pAdapterInfo)
+            {
+                pDevice->PhyId = pAdapterInfo->PhyId;
+                pDevice->EnableTbi = pAdapterInfo->Serdes;
+            }
+            else if (EeSigFound)
+            {
+                pDevice->PhyId = EePhyId;
+                pDevice->EnableTbi = EePhyTypeSerdes;
+            }
+            break;
+    }
+
+    /* Bail out if we don't know the copper PHY id. */
+    if(UNKNOWN_PHY_ID(pDevice->PhyId) && !pDevice->EnableTbi)
+    {
+        DbgMessage(FATAL, ("Don't know the copper PHY id.\n"));
+        DbgBreak();
+        return LM_STATUS_FAILURE;
+    }
+
+#if INCLUDE_5701_AX_FIX
+    if (pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+    {
+        pDevice->ResetPhyOnInit = TRUE;
+    }
+#endif
+
+    /* Save the current phy link status. */
+    if(!pDevice->EnableTbi)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        /* If we don't have link reset the PHY. */
+        if(!(Value32 & PHY_STATUS_LINK_PASS) || pDevice->ResetPhyOnInit)
+        {
+
+            LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_PHY_RESET);
+
+            for(j = 0; j < 5000; j++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+                if(Value32 && !(Value32 & PHY_CTRL_PHY_RESET))
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+
+#if INCLUDE_5701_AX_FIX
+            /* 5701_AX_BX bug:  only advertises 10mb speed. */
+            if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+                pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+            {
+
+                Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD |
+                    PHY_AN_AD_10BASET_HALF | PHY_AN_AD_10BASET_FULL |
+                    PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+                Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+                LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+
+                Value32 = BCM540X_AN_AD_1000BASET_HALF | 
+                    BCM540X_AN_AD_1000BASET_FULL | BCM540X_CONFIG_AS_MASTER |
+                    BCM540X_ENABLE_CONFIG_AS_MASTER;
+                LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+
+                LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_AUTO_NEG_ENABLE |
+                    PHY_CTRL_RESTART_AUTO_NEG);
+            }
+#endif
+            /* Bail out if we don't know the copper PHY id. */
+            if(UNKNOWN_PHY_ID(pDevice->PhyId) && !pDevice->EnableTbi)
+            {
+                return LM_STATUS_FAILURE;
+            }
+        }
+    }
+
+    /* Turn off tap power management. */
+    if((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+    {
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x0c20);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+
+        MM_Wait(40);
+    }
+
+#if INCLUDE_TBI_SUPPORT
+    if(pDevice->EnableTbi)
+    {
+        pDevice->PhyIntMode = T3_PHY_INT_MODE_LINK_READY;
+    }
+#endif /* INCLUDE_TBI_SUPPORT */
+
+    /* UseTaggedStatus is only valid for 5701 and later. */
+    if(pDevice->UseTaggedStatus && (pDevice->ChipRevId == T3_CHIP_ID_5700_C0 ||
+        T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_AX ||
+        T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX))
+    {
+        pDevice->UseTaggedStatus = FALSE;
+
+        pDevice->CoalesceMode = 0;
+    }
+    else
+    {
+        pDevice->CoalesceMode = HOST_COALESCE_CLEAR_TICKS_ON_RX_BD_EVENT |
+            HOST_COALESCE_CLEAR_TICKS_ON_TX_BD_EVENT;
+    }
+
+    /* Set the status block size. */
+    if(T3_CHIP_REV(pDevice->ChipRevId) != T3_CHIP_REV_5700_AX &&
+        T3_CHIP_REV(pDevice->ChipRevId) != T3_CHIP_REV_5700_BX)
+    {
+        pDevice->CoalesceMode |= HOST_COALESCE_32_BYTE_STATUS_MODE;
+    }
+
+    /* Check the DURING_INT coalescing ticks parameters. */
+    if(pDevice->UseTaggedStatus)
+    {
+        if(pDevice->RxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxCoalescingTicksDuringInt =
+                DEFAULT_RX_COALESCING_TICKS_DURING_INT;
+        }
+
+        if(pDevice->TxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxCoalescingTicksDuringInt =
+                DEFAULT_TX_COALESCING_TICKS_DURING_INT;
+        }
+
+        if(pDevice->RxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxMaxCoalescedFramesDuringInt =
+                DEFAULT_RX_MAX_COALESCED_FRAMES_DURING_INT;
+        }
+
+        if(pDevice->TxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxMaxCoalescedFramesDuringInt =
+                DEFAULT_TX_MAX_COALESCED_FRAMES_DURING_INT;
+        }
+    }
+    else
+    {
+        if(pDevice->RxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxCoalescingTicksDuringInt = 0;
+        }
+
+        if(pDevice->TxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxCoalescingTicksDuringInt = 0;
+        }
+
+        if(pDevice->RxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxMaxCoalescedFramesDuringInt = 0;
+        }
+
+        if(pDevice->TxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxMaxCoalescedFramesDuringInt = 0;
+        }
+    }
+
+    /* Check for invalid parameters. */
+    if(pDevice->TxPacketDescCnt > MAX_TX_PACKET_DESC_COUNT ||
+        pDevice->TxPacketDescCnt == 0)
+    {
+
+        DbgMessage(INIT_W, ("TxPacketDescCnt too big.\n"));
+        pDevice->TxPacketDescCnt = DEFAULT_TX_PACKET_DESC_COUNT;
+    }
+
+
+    /* Check for invalid parameters. */
+    if(pDevice->TxPacketDescCnt > MAX_TX_PACKET_DESC_COUNT ||
+        pDevice->TxPacketDescCnt == 0)
+    {
+        pDevice->TxPacketDescCnt = DEFAULT_TX_PACKET_DESC_COUNT;
+    }
+
+    if(pDevice->RxStdDescCnt == 0)
+    {
+        pDevice->RxStdDescCnt = DEFAULT_STD_RCV_DESC_COUNT;
+    }
+
+#if T3_JUMBO_RCB_ENTRY_COUNT
+    if(pDevice->RxStdDescCnt >= T3_STD_RCV_RCB_ENTRY_COUNT)
+    {
+        pDevice->RxStdDescCnt = DEFAULT_STD_RCV_DESC_COUNT;
+    }
+#else
+    if(pDevice->RxStdDescCnt > MAX_RX_PACKET_DESC_COUNT)
+    {
+        pDevice->RxStdDescCnt = DEFAULT_RX_PACKET_DESC_COUNT;
+    }
+#endif 
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    if(pDevice->RxMtu <= (MAX_STD_RCV_BUFFER_SIZE - 8 /* CRC */))
+    {
+        pDevice->RxJumboDescCnt = 0;
+        if(pDevice->RxMtu <= MAX_ETHERNET_PACKET_SIZE_NO_CRC)
+        {
+            pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+        }
+#if 0
+        else
+        {
+            /* We do this so we don't have to use the jumbo ring for */
+            /* receiving packets smaller than 1536. */
+            pDevice->RxMtu = MAX_STD_RCV_BUFFER_SIZE - 8; /* CRC */
+        }
+#endif
+    }
+    else
+    {
+        pDevice->RxJumboBufferSize = (pDevice->RxMtu + 8 /* CRC + VLAN */ +
+            COMMON_CACHE_LINE_SIZE-1) & ~COMMON_CACHE_LINE_MASK;
+
+        if(pDevice->RxJumboBufferSize > MAX_JUMBO_RCV_BUFFER_SIZE)
+        {
+            pDevice->RxJumboBufferSize = DEFAULT_JUMBO_RCV_BUFFER_SIZE;
+            pDevice->RxMtu = pDevice->RxJumboBufferSize - 8 /* CRC + VLAN */;
+        }
+        pDevice->TxMtu = pDevice->RxMtu;
+
+        if(pDevice->RxJumboDescCnt == 0 || 
+            pDevice->RxJumboDescCnt >= T3_JUMBO_RCV_RCB_ENTRY_COUNT)
+        {
+            pDevice->RxJumboDescCnt = DEFAULT_JUMBO_RCV_DESC_COUNT;
+        }
+    }
+#else
+    pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    pDevice->RxPacketDescCnt = 
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+        pDevice->RxJumboDescCnt +
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+        pDevice->RxStdDescCnt;
+
+    if(pDevice->TxMtu < MAX_ETHERNET_PACKET_SIZE_NO_CRC)
+    {
+        pDevice->TxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    }
+
+    if(pDevice->TxMtu > MAX_JUMBO_TX_BUFFER_SIZE)
+    {
+        pDevice->TxMtu = MAX_JUMBO_TX_BUFFER_SIZE;
+    }
+
+    if(pDevice->TxCopyBufferSize)
+    {
+        if(pDevice->TxCopyBufferSize & COMMON_CACHE_LINE_MASK)
+        {
+            pDevice->TxCopyBufferSize &= ~COMMON_CACHE_LINE_MASK;
+        }
+
+        if(pDevice->TxCopyBufferSize < MIN_TX_COPY_BUFFER_SIZE)
+        {
+            pDevice->TxCopyBufferSize = MIN_TX_COPY_BUFFER_SIZE;
+        }
+
+        if(pDevice->TxCopyBufferSize > MAX_TX_COPY_BUFFER_SIZE)
+        {
+            pDevice->TxCopyBufferSize = MAX_TX_COPY_BUFFER_SIZE;
+        }
+    }
+    else
+    {
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            pDevice->TxCopyBufferSize = MIN_TX_COPY_BUFFER_SIZE;
+        }
+    }
+
+    /* Configure the proper ways to get link change interrupt. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO)
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+        }
+        else
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_LINK_READY;
+        }
+    }
+    else if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        /* Auto-polling does not work on 5700_AX and 5700_BX. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+        }
+    }
+
+    /* Determine the method to get link change status. */
+    if(pDevice->LinkChngMode == T3_LINK_CHNG_MODE_AUTO)
+    {
+        /* The link status bit in the status block does not work on 5700_AX */
+        /* and 5700_BX chips. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+        }
+        else
+        {
+            pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_BLOCK;
+        }
+    }
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT ||
+        T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+    }
+
+    /* Configure PHY led mode. */
+    if(pDevice->Bcm540xMode == BCM540X_MODE_AUTO)
+    {
+        if(pDevice->SubsystemVendorId == T3_SVID_DELL)
+        {
+            pDevice->Bcm540xMode = BCM540X_MODE_LINK10;
+        }
+        else
+        {
+            pDevice->Bcm540xMode = BCM540X_MODE_THREE_LINK;
+
+            if (EeSigFound && EePhyLedMode != BCM540X_MODE_AUTO)
+            {
+                pDevice->Bcm540xMode = EePhyLedMode;
+            }
+        }
+    }
+    if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B2)
+    {
+        pDevice->WolSpeed = WOL_SPEED_10MB;
+    }
+    else
+    {
+        pDevice->WolSpeed = WOL_SPEED_100MB;
+    }
+
+    /* Offloadings. */
+    pDevice->TaskToOffload = LM_TASK_OFFLOAD_NONE;
+
+    /* Turn off task offloading on Ax. */
+    if(pDevice->ChipRevId == T3_CHIP_ID_5700_B0)
+    {
+        pDevice->TaskOffloadCap &= ~(LM_TASK_OFFLOAD_TX_TCP_CHECKSUM |
+            LM_TASK_OFFLOAD_TX_UDP_CHECKSUM);
+    }
+    pDevice->PciState = REG_RD(pDevice, PciCfg.PciState);
+    LM_ReadVPD(pDevice);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_GetAdapterInfo */
+
+STATIC PLM_ADAPTER_INFO
+LM_GetAdapterInfoBySsid(
+    LM_UINT16 Svid,
+    LM_UINT16 Ssid)
+{
+    static LM_ADAPTER_INFO AdapterArr[] =
+    {
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700A6, PHY_BCM5401_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A5, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700T6, PHY_BCM8002_PHY_ID, 1},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700A9, 0, 1 },
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701T1, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701T8, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A7, 0, 1},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A10, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A12, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95703Ax1, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95703Ax2, PHY_BCM5701_PHY_ID, 0},
+
+        { T3_SVID_3COM, T3_SSID_3COM_3C996T, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C996BT, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C996SX, 0, 1 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C1000T, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C940BR01, PHY_BCM5701_PHY_ID, 0 },
+
+        { T3_SVID_DELL, T3_SSID_DELL_VIPER, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_JAGUAR, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_MERLOT, PHY_BCM5411_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_SLIM_MERLOT, PHY_BCM5411_PHY_ID, 0 },
+
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_BANSHEE, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_BANSHEE_2, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_CHANGELING, 0, 1 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_NC7780, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_NC7780_2, PHY_BCM5701_PHY_ID, 0 },
+
+    };
+    LM_UINT32 j;
+
+    for(j = 0; j < sizeof(AdapterArr)/sizeof(LM_ADAPTER_INFO); j++)
+    {
+        if(AdapterArr[j].Svid == Svid && AdapterArr[j].Ssid == Ssid)
+        {
+            return &AdapterArr[j];
+        }
+    }
+
+    return NULL;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine sets up receive/transmit buffer descriptions queues.       */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_InitializeAdapter(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_PHYSICAL_ADDRESS MemPhy;
+    PLM_UINT8 pMemVirt;
+    PLM_PACKET pPacket;
+    LM_STATUS Status;
+    LM_UINT32 Size;
+    LM_UINT32 j;
+
+    /* Set power state to D0. */
+    LM_SetPowerState(pDevice, LM_POWER_STATE_D0);
+
+    /* Intialize the queues. */
+    QQ_InitQueue(&pDevice->RxPacketReceivedQ.Container, 
+        MAX_RX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->RxPacketFreeQ.Container,
+        MAX_RX_PACKET_DESC_COUNT);
+
+    QQ_InitQueue(&pDevice->TxPacketFreeQ.Container,MAX_TX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->TxPacketActiveQ.Container,MAX_TX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->TxPacketXmittedQ.Container,MAX_TX_PACKET_DESC_COUNT);
+
+    /* Allocate shared memory for: status block, the buffers for receive */
+    /* rings -- standard, mini, jumbo, and return rings. */
+    Size = T3_STATUS_BLOCK_SIZE + sizeof(T3_STATS_BLOCK) +
+        T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD) +
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+        T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD) +
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+        T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+
+    /* Memory for host based Send BD. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        Size += sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT;
+    }
+
+    /* Allocate the memory block. */
+    Status = MM_AllocateSharedMemory(pDevice, Size, (PLM_VOID) &pMemVirt, &MemPhy, FALSE);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    if (LM_DmaTest(pDevice, pMemVirt, MemPhy, 0x400) != LM_STATUS_SUCCESS)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Status block. */
+    pDevice->pStatusBlkVirt = (PT3_STATUS_BLOCK) pMemVirt;
+    pDevice->StatusBlkPhy = MemPhy;
+    pMemVirt += T3_STATUS_BLOCK_SIZE;
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, T3_STATUS_BLOCK_SIZE);
+
+    /* Statistics block. */
+    pDevice->pStatsBlkVirt = (PT3_STATS_BLOCK) pMemVirt;
+    pDevice->StatsBlkPhy = MemPhy;
+    pMemVirt += sizeof(T3_STATS_BLOCK);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, sizeof(T3_STATS_BLOCK));
+
+    /* Receive standard BD buffer. */
+    pDevice->pRxStdBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RxStdBdPhy = MemPhy;
+
+    pMemVirt += T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Receive jumbo BD buffer. */
+    pDevice->pRxJumboBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RxJumboBdPhy = MemPhy;
+
+    pMemVirt += T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Receive return BD buffer. */
+    pDevice->pRcvRetBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RcvRetBdPhy = MemPhy;
+
+    pMemVirt += T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+
+    /* Set up Send BD. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        pDevice->pSendBdVirt = (PT3_SND_BD) pMemVirt;
+        pDevice->SendBdPhy = MemPhy;
+
+        pMemVirt += sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT;
+        LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+            sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT);
+    }
+    else
+    {
+        pDevice->pSendBdVirt = (PT3_SND_BD)
+            pDevice->pMemView->uIntMem.First32k.BufferDesc;
+        pDevice->SendBdPhy.High = 0;
+        pDevice->SendBdPhy.Low = T3_NIC_SND_BUFFER_DESC_ADDR;
+    }
+
+    if(pDevice->TxCopyBufferSize)
+    {
+        /* Figure out the memory needed for coalescing transmit buffer. */
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            Size = (pDevice->TxCopyBufferSize + BCM5700_BX_TX_COPY_BUF_SIZE +
+                COMMON_CACHE_LINE_SIZE) * pDevice->TxPacketDescCnt;
+        }
+        else
+        {
+            Size = pDevice->TxCopyBufferSize * pDevice->TxPacketDescCnt;
+        }
+
+        /* Allocate double copy buffers for copying small transmit packets. */
+        Status = MM_AllocateSharedMemory(pDevice, Size, (PLM_VOID) &pMemVirt, &MemPhy,
+            TRUE);
+        if(Status != LM_STATUS_SUCCESS)
+        {
+            return Status;
+        }
+    }
+
+    /* Allocate memory for packet descriptors. */
+    Size = (pDevice->RxPacketDescCnt + 
+        pDevice->TxPacketDescCnt) * MM_PACKET_DESC_SIZE;
+    Status = MM_AllocateMemory(pDevice, Size, (PLM_VOID *) &pPacket);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->pPacketDescBase = (PLM_VOID) pPacket;
+
+    /* Create transmit packet descriptors from the memory block and add them */
+    /* to the TxPacketFreeQ for each send ring. */
+    for(j = 0; j < pDevice->TxPacketDescCnt; j++)
+    {
+        /* Ring index. */
+        pPacket->Flags = 0;
+
+        if(pDevice->TxCopyBufferSize)
+        {
+            /* Initialize pointers to the transmit buffer. */
+            pPacket->u.Tx.pTxCopyBufferVirt = (PLM_UINT8) pMemVirt;
+            pPacket->u.Tx.TxCopyBufferPhy = MemPhy;
+
+            /* Next buffer. */
+            if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+            {
+                pMemVirt += pDevice->TxCopyBufferSize +
+                    BCM5700_BX_TX_COPY_BUF_SIZE;
+                LM_INC_PHYSICAL_ADDRESS(&MemPhy, pDevice->TxCopyBufferSize +
+                    BCM5700_BX_TX_COPY_BUF_SIZE);
+            }
+            else
+            {
+                pMemVirt += pDevice->TxCopyBufferSize;
+                LM_INC_PHYSICAL_ADDRESS(&MemPhy, pDevice->TxCopyBufferSize);
+            }
+        }
+
+        /* Queue the descriptor in the TxPacketFreeQ of the 'k' ring. */
+        QQ_PushTail(&pDevice->TxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for(j.. */
+
+    /* Create receive packet descriptors from the memory block and add them */
+    /* to the RxPacketFreeQ.  Create the Standard packet descriptors. */
+    for(j = 0; j < pDevice->RxStdDescCnt; j++)
+    {
+        /* Receive producer ring. */
+        pPacket->u.Rx.RcvProdRing = T3_STD_RCV_PROD_RING;
+
+        /* Receive buffer size. */
+        pPacket->u.Rx.RxBufferSize = MAX_STD_RCV_BUFFER_SIZE;
+
+        /* Add the descriptor to RxPacketFreeQ. */
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for */
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Create the Mini packet descriptors. */
+    for(j = 0; j < pDevice->RxJumboDescCnt; j++)
+    {
+        /* Receive producer ring. */
+        pPacket->u.Rx.RcvProdRing = T3_JUMBO_RCV_PROD_RING;
+
+        /* Receive buffer size. */
+        pPacket->u.Rx.RxBufferSize = pDevice->RxJumboBufferSize;
+
+        /* Add the descriptor to RxPacketFreeQ. */
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for */
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Initialize the rest of the packet descriptors. */
+    Status = MM_InitializeUmPackets(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    } /* if */
+
+    /* Default receive mask. */
+    pDevice->ReceiveMask = LM_ACCEPT_MULTICAST | LM_ACCEPT_BROADCAST |
+        LM_ACCEPT_UNICAST;
+
+    /* Make sure we are in the first 32k memory window or NicSendBd. */
+    REG_WR(pDevice, PciCfg.MemWindowBaseAddr, 0);
+
+    /* Initialize the hardware. */
+    Status = LM_ResetAdapter(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* We are done with initialization. */
+    pDevice->InitDone = TRUE;
+
+    return LM_STATUS_SUCCESS;
+} /* LM_InitializeAdapter */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This function Enables/Disables MAC loopback.                            */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_ControlLoopBack(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 Control)
+{
+    switch(Control)
+    {
+        case LM_ENABLE:
+            pDevice->MacMode &= ~MAC_MODE_PORT_MODE_MASK;
+            pDevice->MacMode |= MAC_MODE_PORT_INTERNAL_LOOPBACK |
+                MAC_MODE_LINK_POLARITY | MAC_MODE_PORT_MODE_GMII;
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+            break;
+
+        case LM_DISABLE:
+            pDevice->MacMode &= ~(MAC_MODE_PORT_INTERNAL_LOOPBACK |
+                MAC_MODE_LINK_POLARITY | MAC_MODE_PORT_MODE_MASK);
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+            break;
+
+        default:
+            return LM_STATUS_FAILURE;
+            break;
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This function Enables/Disables a given block.                          */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_CntrlBlock(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 mask,LM_UINT32 cntrl)
+{
+    LM_UINT32 j,i,data;
+    LM_UINT32 MaxWaitCnt;
+
+    MaxWaitCnt = 20;
+    j = 0;
+
+    for(i = 0 ; i < 32; i++) 
+    {
+        if(!(mask & (1 << i)))
+            continue;     
+ 
+        switch (1 << i) 
+        {
+            case T3_BLOCK_DMA_RD:
+                data = REG_RD(pDevice, DmaRead.Mode);
+                if (cntrl == LM_DISABLE) 
+                {
+                    data &= ~DMA_READ_MODE_ENABLE;
+                    REG_WR(pDevice, DmaRead.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaRead.Mode) & DMA_READ_MODE_ENABLE))
+                            break;
+                        MM_Wait(200);
+                    }
+                }
+                else 
+                    REG_WR(pDevice, DmaRead.Mode, data | DMA_READ_MODE_ENABLE);
+                break;
+  
+            case T3_BLOCK_DMA_COMP:
+                data = REG_RD(pDevice,DmaComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~DMA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, DmaComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaComp.Mode) & DMA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, DmaComp.Mode, data | DMA_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_BD_INITIATOR:
+                data = REG_RD(pDevice, RcvBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, RcvBdIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvBdIn.Mode) & RCV_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }              
+                }
+                else
+                    REG_WR(pDevice, RcvBdIn.Mode,data | RCV_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_BD_COMP:
+                data = REG_RD(pDevice, RcvBdComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_BD_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, RcvBdComp.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvBdComp.Mode) & RCV_BD_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, RcvBdComp.Mode,data | RCV_BD_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_DMA_WR:
+                data = REG_RD(pDevice, DmaWrite.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~DMA_WRITE_MODE_ENABLE;
+                    REG_WR(pDevice, DmaWrite.Mode,data);
+
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaWrite.Mode) & DMA_WRITE_MODE_ENABLE))
+                            break;
+                        MM_Wait(200);
+                    }
+                }
+                else
+                    REG_WR(pDevice, DmaWrite.Mode,data | DMA_WRITE_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MSI_HANDLER:
+                data = REG_RD(pDevice, Msi.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~MSI_MODE_ENABLE;
+                    REG_WR(pDevice, Msi.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, Msi.Mode) & MSI_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, Msi.Mode, data |MSI_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_LIST_PLMT:
+                data = REG_RD(pDevice, RcvListPlmt.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_LIST_PLMT_MODE_ENABLE;
+                    REG_WR(pDevice, RcvListPlmt.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvListPlmt.Mode) & RCV_LIST_PLMT_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, RcvListPlmt.Mode,data | RCV_LIST_PLMT_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_LIST_SELECTOR:
+                data = REG_RD(pDevice, RcvListSel.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_LIST_SEL_MODE_ENABLE;
+                    REG_WR(pDevice, RcvListSel.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvListSel.Mode) & RCV_LIST_SEL_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, RcvListSel.Mode,data |RCV_LIST_SEL_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_DATA_INITIATOR:
+                data = REG_RD(pDevice, RcvDataBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_DATA_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, RcvDataBdIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvDataBdIn.Mode) & RCV_DATA_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }      
+                }
+                else
+                    REG_WR(pDevice, RcvDataBdIn.Mode, data | RCV_DATA_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_DATA_COMP:
+                data = REG_RD(pDevice, RcvDataComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_DATA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, RcvDataComp.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvDataBdIn.Mode) & RCV_DATA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }        
+                }
+                else
+                    REG_WR(pDevice, RcvDataComp.Mode,data | RCV_DATA_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_HOST_COALESING:
+                data = REG_RD(pDevice, HostCoalesce.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~HOST_COALESCE_ENABLE;
+                    REG_WR(pDevice, HostCoalesce.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdIn.Mode) & HOST_COALESCE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, HostCoalesce.Mode, data | HOST_COALESCE_ENABLE);
+                break;
+
+            case T3_BLOCK_MAC_RX_ENGINE:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->RxMode &= ~RX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        MM_Wait(100);
+                        if(!(REG_RD(pDevice, MacCtrl.RxMode) & RX_MODE_ENABLE))
+                        {
+                            break;
+                        }
+                    }
+                }
+                else
+                {
+                    pDevice->RxMode |= RX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+                }
+                break;
+
+            case T3_BLOCK_MBUF_CLUSTER_FREE:
+                data = REG_RD(pDevice, MbufClusterFree.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~MBUF_CLUSTER_FREE_MODE_ENABLE;
+                    REG_WR(pDevice, MbufClusterFree.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MbufClusterFree.Mode) & MBUF_CLUSTER_FREE_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, MbufClusterFree.Mode, data | MBUF_CLUSTER_FREE_MODE_ENABLE);         
+                break;
+
+            case T3_BLOCK_SEND_BD_INITIATOR:
+                data = REG_RD(pDevice, SndBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdIn.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdIn.Mode) & SND_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdIn.Mode, data  | SND_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_BD_COMP:
+                data = REG_RD(pDevice, SndBdComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdComp.Mode) & SND_BD_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdComp.Mode, data | SND_BD_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_BD_SELECTOR:
+                data = REG_RD(pDevice, SndBdSel.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_SEL_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdSel.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdSel.Mode) & SND_BD_SEL_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdSel.Mode, data | SND_BD_SEL_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_DATA_INITIATOR:
+                data = REG_RD(pDevice, SndDataIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~T3_SND_DATA_IN_MODE_ENABLE;
+                    REG_WR(pDevice, SndDataIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndDataIn.Mode) & T3_SND_DATA_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndDataIn.Mode,data | T3_SND_DATA_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_DATA_COMP:
+                data = REG_RD(pDevice, SndDataComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_DATA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, SndDataComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndDataComp.Mode) & SND_DATA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndDataComp.Mode,data | SND_DATA_COMP_MODE_ENABLE);
+                break;
+               
+            case T3_BLOCK_MAC_TX_ENGINE:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->TxMode &= ~TX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        MM_Wait(100);
+                        if(!(REG_RD(pDevice, MacCtrl.TxMode) & TX_MODE_ENABLE))
+                            break;
+                    }
+                }
+                else  
+                {
+                    pDevice->TxMode |= TX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+                }
+                break;
+
+            case T3_BLOCK_MEM_ARBITOR:
+                data = REG_RD(pDevice, MemArbiter.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~T3_MEM_ARBITER_MODE_ENABLE;
+                    REG_WR(pDevice, MemArbiter.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MemArbiter.Mode) & T3_MEM_ARBITER_MODE_ENABLE)) 
+                            break;
+                        MM_Wait(100);
+                    }       
+                }
+                else
+                    REG_WR(pDevice, MemArbiter.Mode,data|T3_MEM_ARBITER_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MBUF_MANAGER:
+                data = REG_RD(pDevice, BufMgr.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~BUFMGR_MODE_ENABLE;
+                    REG_WR(pDevice, BufMgr.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, BufMgr.Mode) & BUFMGR_MODE_ENABLE))
+                            break;
+                        MM_Wait(100);
+                    }
+                }
+                else
+                    REG_WR(pDevice, BufMgr.Mode,data |  BUFMGR_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MAC_GLOBAL:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->MacMode &= ~(MAC_MODE_ENABLE_TDE |
+                        MAC_MODE_ENABLE_RDE |
+                        MAC_MODE_ENABLE_FHDE);
+                }
+                else
+                {
+                    pDevice->MacMode |= (MAC_MODE_ENABLE_TDE |
+                        MAC_MODE_ENABLE_RDE |
+                        MAC_MODE_ENABLE_FHDE);
+                }
+                REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+                break;
+
+            default:
+                return LM_STATUS_FAILURE;
+        } /* switch */
+
+        if(j >= MaxWaitCnt) 
+        {
+            return LM_STATUS_FAILURE;
+        }
+    } 
+
+    return LM_STATUS_SUCCESS;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This function reinitializes the adapter.                                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_ResetAdapter(
+PLM_DEVICE_BLOCK pDevice) {
+    LM_UINT32 Value32;
+    LM_UINT32 j, k;
+
+    /* Disable interrupt. */
+    LM_DisableInterrupt(pDevice);
+
+    /* May get a spurious interrupt */
+    pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED;
+
+    /* Disable transmit and receive DMA engines.  Abort all pending requests. */
+    if(pDevice->InitDone)
+    {
+        LM_Abort(pDevice);
+    }
+
+    pDevice->ShuttingDown = FALSE;
+
+    {
+        /* Global reset. */
+        REG_WR(pDevice, Grc.MiscCfg, GRC_MISC_CFG_CORE_CLOCK_RESET);
+        MM_Wait(40);
+
+        MM_WriteConfig32(pDevice, PCI_COMMAND_REG,
+            pDevice->PciCommandStatusWords);
+
+        /* Disable PCI-X relaxed ordering bit. */
+        MM_ReadConfig32(pDevice, PCIX_CAP_REG, &Value32);
+        Value32 &= ~PCIX_ENABLE_RELAXED_ORDERING;
+        MM_WriteConfig32(pDevice, PCIX_CAP_REG, Value32);
+
+
+        /* make sure we re-enable indirect accesses */
+        MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG,
+            pDevice->MiscHostCtrl);
+
+        /* Enable memory arbiter. */
+        REG_WR(pDevice, MemArbiter.Mode, T3_MEM_ARBITER_MODE_ENABLE);
+
+        /* Reconfigure the miscellaneous host control register after reset. */
+        REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl);
+
+#ifdef BIG_ENDIAN_HOST
+        /* Reconfigure the mode register. */
+        Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+                  GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+                  GRC_MODE_BYTE_SWAP_DATA |
+                  GRC_MODE_WORD_SWAP_DATA;
+#else
+        /* Reconfigure the mode register. */
+        Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | GRC_MODE_BYTE_SWAP_DATA;
+#endif
+        REG_WR(pDevice, Grc.Mode, Value32);
+
+        /* Prevent PXE from restarting. */
+        MEM_WR_OFFSET(pDevice, 0x0b50, T3_MAGIC_NUM);
+
+    }
+
+    /* Bug:  After a GRC the EMAC register shoulde be cleared but it is not. */
+
+    if(pDevice->EnableTbi) {
+        pDevice->MacMode = MAC_MODE_PORT_MODE_TBI;
+        REG_WR(pDevice, MacCtrl.Mode, MAC_MODE_PORT_MODE_TBI);
+    }
+    else
+        REG_WR(pDevice, MacCtrl.Mode, 0);
+
+    /* Wait for the firmware to finish initialization. */
+    for(j = 0; j < 50000; j++)
+    {
+        Value32 = MEM_RD_OFFSET(pDevice, 0x0b50);
+        if(Value32 == ~T3_MAGIC_NUM)
+        {
+            break;
+        }
+
+        MM_Wait(10);
+    }
+
+    /* Bug: Athlon fix for B3 silicon only.  This bit does not do anything */
+    /* in other chip revisions. */
+    if(pDevice->DelayPciGrant)
+    {
+        Value32 = REG_RD(pDevice, PciCfg.ClockCtrl);
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32 | BIT_31);
+    }
+
+    /* Enable TaggedStatus mode. */
+    if(pDevice->UseTaggedStatus)
+    {
+        pDevice->MiscHostCtrl |= MISC_HOST_CTRL_ENABLE_TAGGED_STATUS_MODE;
+    }
+
+    /* Restore PCI configuration registers. */
+    MM_WriteConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG,
+        pDevice->SavedCacheLineReg);
+//    LM_RegWrInd(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+//        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+    MM_WriteConfig32(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+
+    /* Clear the statistics block. */
+    for(j = 0x0300; j < 0x0b00; j++)
+    {
+        MEM_WR_OFFSET(pDevice, j, 0);
+    }
+
+    /* Initialize the statistis Block */
+    pDevice->pStatusBlkVirt->Status = 0;
+    pDevice->pStatusBlkVirt->RcvStdConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvJumboConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvMiniConIdx = 0;
+
+    for(j = 0; j < 16; j++)
+    {
+       pDevice->pStatusBlkVirt->Idx[j].RcvProdIdx = 0;
+       pDevice->pStatusBlkVirt->Idx[j].SendConIdx = 0;
+    }
+
+    for(k = 0; k < T3_STD_RCV_RCB_ENTRY_COUNT ;k++)
+    {
+       pDevice->pRxStdBdVirt[k].HostAddr.High = 0;
+       pDevice->pRxStdBdVirt[k].HostAddr.Low = 0;
+    }
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Receive jumbo BD buffer. */
+    for(k = 0; k < T3_JUMBO_RCV_RCB_ENTRY_COUNT; k++)
+    {
+        pDevice->pRxJumboBdVirt[k].HostAddr.High = 0;
+        pDevice->pRxJumboBdVirt[k].HostAddr.Low = 0;
+    }
+#endif
+
+    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl, pDevice->DmaReadWriteCtrl);    
+
+    /* GRC mode control register. */
+    Value32 = 
+#ifdef BIG_ENDIAN_HOST
+        GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+        GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+        GRC_MODE_BYTE_SWAP_DATA |
+        GRC_MODE_WORD_SWAP_DATA |
+#else
+        GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+        GRC_MODE_BYTE_SWAP_DATA |
+        GRC_MODE_WORD_SWAP_DATA |
+#endif
+        GRC_MODE_INT_ON_MAC_ATTN |
+        GRC_MODE_HOST_STACK_UP;
+
+    /* Configure send BD mode. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        Value32 |= GRC_MODE_HOST_SEND_BDS;
+    }
+    else
+    {
+        Value32 |= GRC_MODE_4X_NIC_BASED_SEND_RINGS;
+    }
+
+    /* Configure pseudo checksum mode. */
+    if(pDevice->NoTxPseudoHdrChksum)
+    {
+        Value32 |= GRC_MODE_TX_NO_PSEUDO_HEADER_CHKSUM;
+    }
+
+    if(pDevice->NoRxPseudoHdrChksum)
+    {
+        Value32 |= GRC_MODE_RX_NO_PSEUDO_HEADER_CHKSUM;
+    }
+
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    /* Setup the timer prescalar register. */
+    REG_WR(pDevice, Grc.MiscCfg, 65 << 1);      /* Clock is alwasy 66Mhz. */
+
+    /* Set up the MBUF pool base address and size. */
+    REG_WR(pDevice, BufMgr.MbufPoolAddr, pDevice->MbufBase);
+    REG_WR(pDevice, BufMgr.MbufPoolSize, pDevice->MbufSize);
+
+    /* Set up the DMA descriptor pool base address and size. */
+    REG_WR(pDevice, BufMgr.DmaDescPoolAddr, T3_NIC_DMA_DESC_POOL_ADDR);
+    REG_WR(pDevice, BufMgr.DmaDescPoolSize, T3_NIC_DMA_DESC_POOL_SIZE);
+    
+    /* Configure MBUF and Threshold watermarks */
+    /* Configure the DMA read MBUF low water mark. */
+    if(pDevice->DmaMbufLowMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark, 
+            pDevice->DmaMbufLowMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark,
+                T3_DEF_DMA_MBUF_LOW_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark,
+                T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO);
+        }
+    }
+
+    /* Configure the MAC Rx MBUF low water mark. */
+    if(pDevice->RxMacMbufLowMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+            pDevice->RxMacMbufLowMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+                T3_DEF_RX_MAC_MBUF_LOW_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+                T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO);
+        }
+    }
+
+    /* Configure the MBUF high water mark. */
+    if(pDevice->MbufHighMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufHighWaterMark, pDevice->MbufHighMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufHighWaterMark,
+                T3_DEF_MBUF_HIGH_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufHighWaterMark,
+                T3_DEF_MBUF_HIGH_WMARK_JUMBO);
+        }
+    }
+
+    REG_WR(pDevice, BufMgr.DmaLowWaterMark, T3_DEF_DMA_DESC_LOW_WMARK);
+    REG_WR(pDevice, BufMgr.DmaHighWaterMark, T3_DEF_DMA_DESC_HIGH_WMARK);
+
+    /* Enable buffer manager. */
+    REG_WR(pDevice, BufMgr.Mode, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE);
+
+    for(j = 0 ;j < 2000; j++)
+    {
+        if(REG_RD(pDevice, BufMgr.Mode) & BUFMGR_MODE_ENABLE)
+            break;
+        MM_Wait(10);
+    }
+
+    if(j >= 2000)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Enable the FTQs. */
+    REG_WR(pDevice, Ftq.Reset, 0xffffffff);
+    REG_WR(pDevice, Ftq.Reset, 0);
+
+    /* Wait until FTQ is ready */
+    for(j = 0; j < 2000; j++)
+    {
+        if(REG_RD(pDevice, Ftq.Reset) == 0)
+            break;
+        MM_Wait(10);
+    }
+
+    if(j >= 2000)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Initialize the Standard Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.HostRingAddr.High, 
+        pDevice->RxStdBdPhy.High);
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.HostRingAddr.Low, 
+        pDevice->RxStdBdPhy.Low);
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.u.MaxLen_Flags,
+        MAX_STD_RCV_BUFFER_SIZE << 16);
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.NicRingAddr,
+        (LM_UINT32) T3_NIC_STD_RCV_BUFFER_DESC_ADDR);
+
+    /* Initialize the Jumbo Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.u.MaxLen_Flags,
+        T3_RCB_FLAG_RING_DISABLED);
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.HostRingAddr.High, 
+        pDevice->RxJumboBdPhy.High);
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.HostRingAddr.Low, 
+        pDevice->RxJumboBdPhy.Low);
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.NicRingAddr,
+        (LM_UINT32) T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR);
+
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.u.MaxLen_Flags, 0);
+
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Initialize the Mini Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.MiniRcvRcb.u.MaxLen_Flags,
+        T3_RCB_FLAG_RING_DISABLED);
+
+    /* Receive BD Ring replenish threshold. */
+    REG_WR(pDevice, RcvBdIn.StdRcvThreshold, pDevice->RxStdDescCnt/8);
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    REG_WR(pDevice, RcvBdIn.JumboRcvThreshold, pDevice->RxJumboDescCnt/8);
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Disable all the unused rings. */
+    for(j = 0; j < T3_MAX_SEND_RCB_COUNT; j++) {
+        MEM_WR(pDevice, SendRcb[j].u.MaxLen_Flags, T3_RCB_FLAG_RING_DISABLED);
+    } /* for */
+
+    /* Initialize the indices. */
+    pDevice->SendProdIdx = 0;
+    pDevice->SendConIdx = 0;
+
+    REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, 0); 
+    REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, 0);
+
+    /* Set up host or NIC based send RCB. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.High, 
+            pDevice->SendBdPhy.High);
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.Low, 
+            pDevice->SendBdPhy.Low);
+
+        /* Set up the NIC ring address in the RCB. */
+        MEM_WR(pDevice, SendRcb[0].NicRingAddr,T3_NIC_SND_BUFFER_DESC_ADDR);
+
+        /* Setup the RCB. */
+        MEM_WR(pDevice, SendRcb[0].u.MaxLen_Flags,
+            T3_SEND_RCB_ENTRY_COUNT << 16);
+
+    }
+    else
+    {
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.High, 0);
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.Low, 0);
+        MEM_WR(pDevice, SendRcb[0].NicRingAddr,
+            pDevice->SendBdPhy.Low);
+    }
+    atomic_set(&pDevice->SendBdLeft, T3_SEND_RCB_ENTRY_COUNT-1);
+
+    for(k = 0; k < T3_SEND_RCB_ENTRY_COUNT; k++)
+    {
+        pDevice->pSendBdVirt[k].HostAddr.High = 0;
+        pDevice->pSendBdVirt[k].HostAddr.Low = 0;
+        pDevice->pSendBdVirt[k].u1.Len_Flags = 0;
+        pDevice->ShadowSendBd[k].HostAddr.High = 0;
+        pDevice->ShadowSendBd[k].u1.Len_Flags = 0;
+    }
+
+    /* Configure the receive return rings. */
+    for(j = 0; j < T3_MAX_RCV_RETURN_RCB_COUNT; j++)
+    {
+        MEM_WR(pDevice, RcvRetRcb[j].u.MaxLen_Flags, T3_RCB_FLAG_RING_DISABLED);
+    }
+
+    pDevice->RcvRetConIdx = 0;
+
+    MEM_WR(pDevice, RcvRetRcb[0].HostRingAddr.High, 
+        pDevice->RcvRetBdPhy.High);
+    MEM_WR(pDevice, RcvRetRcb[0].HostRingAddr.Low,
+        pDevice->RcvRetBdPhy.Low);
+
+    /* Set up the NIC ring address in the RCB. */
+    /* Not very clear from the spec.  I am guessing that for Receive */
+    /* Return Ring, NicRingAddr is not used. */
+    MEM_WR(pDevice, RcvRetRcb[0].NicRingAddr, 0);
+
+    /* Setup the RCB. */
+    MEM_WR(pDevice, RcvRetRcb[0].u.MaxLen_Flags,
+        T3_RCV_RETURN_RCB_ENTRY_COUNT << 16);
+
+    /* Reinitialize RX ring producer index */
+    REG_WR(pDevice, Mailbox.RcvStdProdIdx.Low, 0);
+    REG_WR(pDevice, Mailbox.RcvJumboProdIdx.Low, 0);
+    REG_WR(pDevice, Mailbox.RcvMiniProdIdx.Low, 0);
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    pDevice->RxJumboProdIdx = 0;
+    pDevice->RxJumboQueuedCnt = 0;
+#endif
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxStdProdIdx = 0;
+    pDevice->RxStdQueuedCnt = 0;
+
+#if T3_JUMBO_RCV_ENTRY_COUNT
+    pDevice->RxJumboProdIdx = 0;
+#endif /* T3_JUMBO_RCV_ENTRY_COUNT */
+
+    /* Configure the MAC address. */
+    LM_SetMacAddress(pDevice, pDevice->NodeAddress);
+
+    /* Initialize the transmit random backoff seed. */
+    Value32 = (pDevice->NodeAddress[0] + pDevice->NodeAddress[1] + 
+        pDevice->NodeAddress[2] + pDevice->NodeAddress[3] + 
+        pDevice->NodeAddress[4] + pDevice->NodeAddress[5]) & 
+        MAC_TX_BACKOFF_SEED_MASK;
+    REG_WR(pDevice, MacCtrl.TxBackoffSeed, Value32);
+
+    /* Receive MTU.  Frames larger than the MTU is marked as oversized. */
+    REG_WR(pDevice, MacCtrl.MtuSize, pDevice->RxMtu + 8);   /* CRC + VLAN. */
+
+    /* Configure Time slot/IPG per 802.3 */
+    REG_WR(pDevice, MacCtrl.TxLengths, 0x2620);
+
+    /*
+     * Configure Receive Rules so that packets don't match 
+     * Programmble rule will be queued to Return Ring 1 
+     */
+    REG_WR(pDevice, MacCtrl.RcvRuleCfg, RX_RULE_DEFAULT_CLASS);
+
+    /* 
+     * Configure to have 16 Classes of Services (COS) and one
+     * queue per class.  Bad frames are queued to RRR#1.
+     * And frames don't match rules are also queued to COS#1.
+     */
+    REG_WR(pDevice, RcvListPlmt.Config, 0x181);
+    
+    /* Enable Receive Placement Statistics */
+    REG_WR(pDevice, RcvListPlmt.StatsEnableMask,0xffffff);
+    REG_WR(pDevice, RcvListPlmt.StatsCtrl, RCV_LIST_STATS_ENABLE);
+
+    /* Enable Send Data Initator Statistics */
+    REG_WR(pDevice, SndDataIn.StatsEnableMask,0xffffff);
+    REG_WR(pDevice, SndDataIn.StatsCtrl,
+        T3_SND_DATA_IN_STATS_CTRL_ENABLE | \
+        T3_SND_DATA_IN_STATS_CTRL_FASTER_UPDATE);
+
+    /* Disable the host coalescing state machine before configuring it's */
+    /* parameters. */
+    REG_WR(pDevice, HostCoalesce.Mode, 0); 
+    for(j = 0; j < 2000; j++)
+    {
+        Value32 = REG_RD(pDevice, HostCoalesce.Mode);
+        if(!(Value32 & HOST_COALESCE_ENABLE))
+        {
+            break;
+        }
+        MM_Wait(10);
+    }
+
+    /* Host coalescing configurations. */
+    REG_WR(pDevice, HostCoalesce.RxCoalescingTicks, pDevice->RxCoalescingTicks);
+    REG_WR(pDevice, HostCoalesce.TxCoalescingTicks, pDevice->TxCoalescingTicks);
+    REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+        pDevice->RxMaxCoalescedFrames);
+    REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFrames,
+        pDevice->TxMaxCoalescedFrames);
+    REG_WR(pDevice, HostCoalesce.RxCoalescedTickDuringInt,
+        pDevice->RxCoalescingTicksDuringInt);
+    REG_WR(pDevice, HostCoalesce.TxCoalescedTickDuringInt,
+        pDevice->TxCoalescingTicksDuringInt);
+    REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFramesDuringInt,
+        pDevice->RxMaxCoalescedFramesDuringInt);
+    REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFramesDuringInt,
+        pDevice->TxMaxCoalescedFramesDuringInt);
+
+    /* Initialize the address of the status block.  The NIC will DMA */
+    /* the status block to this memory which resides on the host. */
+    REG_WR(pDevice, HostCoalesce.StatusBlkHostAddr.High, 
+        pDevice->StatusBlkPhy.High);
+    REG_WR(pDevice, HostCoalesce.StatusBlkHostAddr.Low,
+        pDevice->StatusBlkPhy.Low);
+
+    /* Initialize the address of the statistics block.  The NIC will DMA */
+    /* the statistics to this block of memory. */
+    REG_WR(pDevice, HostCoalesce.StatsBlkHostAddr.High, 
+        pDevice->StatsBlkPhy.High);
+    REG_WR(pDevice, HostCoalesce.StatsBlkHostAddr.Low,
+        pDevice->StatsBlkPhy.Low);
+
+    REG_WR(pDevice, HostCoalesce.StatsCoalescingTicks,
+        pDevice->StatsCoalescingTicks);
+
+    REG_WR(pDevice, HostCoalesce.StatsBlkNicAddr, 0x300);
+    REG_WR(pDevice, HostCoalesce.StatusBlkNicAddr,0xb00);
+
+    /* Enable Host Coalesing state machine */
+    REG_WR(pDevice, HostCoalesce.Mode, HOST_COALESCE_ENABLE |
+        pDevice->CoalesceMode);
+
+    /* Enable the Receive BD Completion state machine. */
+    REG_WR(pDevice, RcvBdComp.Mode, RCV_BD_COMP_MODE_ENABLE |
+        RCV_BD_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Receive List Placement state machine. */
+    REG_WR(pDevice, RcvListPlmt.Mode, RCV_LIST_PLMT_MODE_ENABLE);
+
+    /* Enable the Receive List Selector state machine. */
+    REG_WR(pDevice, RcvListSel.Mode, RCV_LIST_SEL_MODE_ENABLE |
+        RCV_LIST_SEL_MODE_ATTN_ENABLE);
+
+    /* Enable transmit DMA, clear statistics. */
+    pDevice->MacMode =  MAC_MODE_ENABLE_TX_STATISTICS |
+        MAC_MODE_ENABLE_RX_STATISTICS | MAC_MODE_ENABLE_TDE |
+        MAC_MODE_ENABLE_RDE | MAC_MODE_ENABLE_FHDE;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+        MAC_MODE_CLEAR_RX_STATISTICS | MAC_MODE_CLEAR_TX_STATISTICS);
+
+    /* GRC miscellaneous local control register. */
+    pDevice->GrcLocalCtrl = GRC_MISC_LOCAL_CTRL_INT_ON_ATTN |
+        GRC_MISC_LOCAL_CTRL_GPIO_OE1 | GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1;
+    REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl);
+
+    /* Reset RX counters. */
+    for(j = 0; j < sizeof(LM_RX_COUNTERS); j++)
+    {
+        ((PLM_UINT8) &pDevice->RxCounters)[j] = 0;
+    }
+
+    /* Reset TX counters. */
+    for(j = 0; j < sizeof(LM_TX_COUNTERS); j++)
+    {
+        ((PLM_UINT8) &pDevice->TxCounters)[j] = 0;
+    }
+
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+
+    /* Enable the DMA Completion state machine. */
+    REG_WR(pDevice, DmaComp.Mode, DMA_COMP_MODE_ENABLE);
+
+    /* Enable the DMA Write state machine. */
+    Value32 = DMA_WRITE_MODE_ENABLE |
+        DMA_WRITE_MODE_TARGET_ABORT_ATTN_ENABLE |
+        DMA_WRITE_MODE_MASTER_ABORT_ATTN_ENABLE |
+        DMA_WRITE_MODE_PARITY_ERROR_ATTN_ENABLE |
+        DMA_WRITE_MODE_ADDR_OVERFLOW_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_OVERRUN_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_UNDERRUN_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_OVERREAD_ATTN_ENABLE |
+        DMA_WRITE_MODE_LONG_READ_ATTN_ENABLE;
+    REG_WR(pDevice, DmaWrite.Mode, Value32);
+
+    /* Enable the Read DMA state machine. */
+    Value32 = DMA_READ_MODE_ENABLE |
+        DMA_READ_MODE_TARGET_ABORT_ATTN_ENABLE |
+        DMA_READ_MODE_MASTER_ABORT_ATTN_ENABLE |
+        DMA_READ_MODE_PARITY_ERROR_ATTN_ENABLE |
+        DMA_READ_MODE_ADDR_OVERFLOW_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_OVERRUN_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_UNDERRUN_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_OVERREAD_ATTN_ENABLE |
+        DMA_READ_MODE_LONG_READ_ATTN_ENABLE;
+    REG_WR(pDevice, DmaRead.Mode, Value32);
+
+    /* Enable the Receive Data Completion state machine. */
+    REG_WR(pDevice, RcvDataComp.Mode, RCV_DATA_COMP_MODE_ENABLE |
+        RCV_DATA_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Mbuf Cluster Free state machine. */
+    REG_WR(pDevice, MbufClusterFree.Mode, MBUF_CLUSTER_FREE_MODE_ENABLE);
+
+    /* Enable the Send Data Completion state machine. */
+    REG_WR(pDevice, SndDataComp.Mode, SND_DATA_COMP_MODE_ENABLE);
+
+    /* Enable the Send BD Completion state machine. */
+    REG_WR(pDevice, SndBdComp.Mode, SND_BD_COMP_MODE_ENABLE |
+        SND_BD_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Receive BD Initiator state machine. */
+    REG_WR(pDevice, RcvBdIn.Mode, RCV_BD_IN_MODE_ENABLE |
+        RCV_BD_IN_MODE_BD_IN_DIABLED_RCB_ATTN_ENABLE);
+
+    /* Enable the Receive Data and Receive BD Initiator state machine. */
+    REG_WR(pDevice, RcvDataBdIn.Mode, RCV_DATA_BD_IN_MODE_ENABLE |
+        RCV_DATA_BD_IN_MODE_INVALID_RING_SIZE);
+
+    /* Enable the Send Data Initiator state machine. */
+    REG_WR(pDevice, SndDataIn.Mode, T3_SND_DATA_IN_MODE_ENABLE);
+
+    /* Enable the Send BD Initiator state machine. */
+    REG_WR(pDevice, SndBdIn.Mode, SND_BD_IN_MODE_ENABLE |
+        SND_BD_IN_MODE_ATTN_ENABLE);
+
+    /* Enable the Send BD Selector state machine. */
+    REG_WR(pDevice, SndBdSel.Mode, SND_BD_SEL_MODE_ENABLE |
+        SND_BD_SEL_MODE_ATTN_ENABLE);
+
+#if INCLUDE_5701_AX_FIX
+    /* Load the firmware for the 5701_A0 workaround. */
+    if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0)
+    {
+        LM_LoadRlsFirmware(pDevice);
+    }
+#endif
+
+    /* Enable the transmitter. */
+    pDevice->TxMode = TX_MODE_ENABLE;
+    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+    
+    /* Enable the receiver. */
+    pDevice->RxMode = RX_MODE_ENABLE;
+    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+
+    if (pDevice->RestoreOnWakeUp)
+    {
+        pDevice->RestoreOnWakeUp = FALSE;
+        pDevice->DisableAutoNeg = pDevice->WakeUpDisableAutoNeg;
+        pDevice->RequestedMediaType = pDevice->WakeUpRequestedMediaType;
+    }
+
+    /* Prevent 5700 b0 from violating PCI spec. */
+    if(pDevice->EnableNWI)
+    {
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            Value32 = REG_RD(pDevice, PciCfg.DmaReadWriteCtrl);
+            Value32 &= ~DMA_CTRL_WRITE_BOUNDARY_MASK;
+
+            switch(pDevice->CacheLineSize)
+            {
+                case 16:
+                    Value32 |= DMA_CTRL_WRITE_BOUNDARY_16;
+                    break;
+
+                case 32:
+                    Value32 |= DMA_CTRL_WRITE_BOUNDARY_32;
+                    break;
+
+                case 64:
+                    Value32 |= DMA_CTRL_WRITE_BOUNDARY_64;
+                    break;
+
+                case 128:
+                    Value32 |= DMA_CTRL_WRITE_BOUNDARY_128;
+                    break;
+
+                case 256:
+                    Value32 |= DMA_CTRL_WRITE_BOUNDARY_256;
+                    break;
+
+                case 512:
+                    Value32 |= DMA_CTRL_WRITE_BOUNDARY_512;
+                    break;
+
+                case 1024:
+                    Value32 |= DMA_CTRL_WRITE_BOUNDARY_1024;
+                    break;
+            }
+            REG_WR(pDevice, PciCfg.DmaReadWriteCtrl, Value32);
+        }
+    }
+
+    /* Disable auto polling. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+
+    /* Program so that hardware control all LEDs and use default blink period */
+    REG_WR(pDevice, MacCtrl.LedCtrl, 0);
+    
+    /* Activate Link to enable MAC state machine */
+    REG_WR(pDevice, MacCtrl.MiStatus, MI_STATUS_ENABLE_LINK_STATUS_ATTN);
+
+    REG_WR(pDevice, MacCtrl.RxMode, RX_MODE_RESET);
+    MM_Wait(10);
+    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+    /* Setup the phy chip. */
+    LM_SetupPhy(pDevice);
+
+    if (!pDevice->EnableTbi) {
+        /* Clear CRC stats */
+        LM_ReadPhy(pDevice, 0x1e, &Value32);
+        LM_WritePhy(pDevice, 0x1e, Value32 | 0x8000);
+        LM_ReadPhy(pDevice, 0x14, &Value32);
+    }
+
+    /* Set up the receive mask. */
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask);
+
+    /* Queue Rx packet buffers. */
+    if(pDevice->QueueRxPackets)
+    {
+        LM_QueueRxPackets(pDevice);
+    }
+
+    /* Enable interrupt to the host. */
+    if(pDevice->InitDone)
+    {
+        LM_EnableInterrupt(pDevice);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_ResetAdapter */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine disables the adapter from generating interrupts.           */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_DisableInterrupt(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl | 
+        MISC_HOST_CTRL_MASK_PCI_INT);
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine enables the adapter to generate interrupts.                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_EnableInterrupt(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl &
+        ~MISC_HOST_CTRL_MASK_PCI_INT);
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+
+    if(pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED)
+    {
+        REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+            GRC_MISC_LOCAL_CTRL_SET_INT);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine puts a packet on the wire if there is a transmit DMA       */
+/*    descriptor available; otherwise the packet is queued for later          */
+/*    transmission.  If the second argue is NULL, this routine will put       */
+/*    the queued packet on the wire if possible.                              */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_SendPacket(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+    LM_UINT32 FragCount;
+    PT3_SND_BD pSendBd;
+    PT3_SND_BD pShadowSendBd;
+    LM_UINT32 Value32;
+    LM_UINT32 Idx;
+
+    /* Update the SendBdLeft count. */
+    atomic_sub(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+    /* Initalize the send buffer descriptors. */
+    Idx = pDevice->SendProdIdx;
+
+    pSendBd = &pDevice->pSendBdVirt[Idx];
+
+    /* Next producer index. */
+    if (pDevice->NicSendBd == TRUE)
+    {
+        pShadowSendBd = &pDevice->ShadowSendBd[Idx];
+        for(FragCount = 0; ; )
+        {
+            /* Initialize the pointer to the send buffer fragment. */
+            Value32 =
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.High;
+            if (Value32 != pShadowSendBd->HostAddr.High)
+            {
+                pSendBd->HostAddr.High = Value32;
+                pShadowSendBd->HostAddr.High = Value32;
+            }
+            pSendBd->HostAddr.Low = 
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.Low;
+
+            /* Setup the control flags and send buffer size. */
+            Value32 = (pPacket->u.Tx.pFraglist->Fragments[FragCount].
+                FragSize << 16) | pPacket->Flags;
+
+            Idx = (Idx + 1) & T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+            FragCount++;
+            if (FragCount >= pPacket->u.Tx.FragCount)
+            {
+                Value32 |= SND_BD_FLAG_END;
+                if (Value32 != pShadowSendBd->u1.Len_Flags)
+                {
+                    pSendBd->u1.Len_Flags = Value32;
+                    pShadowSendBd->u1.Len_Flags = Value32;
+                }
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+                break;
+            }
+            else
+            {
+                if (Value32 != pShadowSendBd->u1.Len_Flags)
+                {
+                    pSendBd->u1.Len_Flags = Value32;
+                    pShadowSendBd->u1.Len_Flags = Value32;
+                }
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+            }
+
+            pSendBd++;
+            pShadowSendBd++;
+            if (Idx == 0)
+            {
+                pSendBd = &pDevice->pSendBdVirt[0];
+                pShadowSendBd = &pDevice->ShadowSendBd[0];
+            }
+        } /* for */
+    }
+    else
+    {
+        for(FragCount = 0; ; )
+        {
+            /* Initialize the pointer to the send buffer fragment. */
+            pSendBd->HostAddr.High = 
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.High;
+            pSendBd->HostAddr.Low = 
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.Low;
+
+            /* Setup the control flags and send buffer size. */
+            Value32 = (pPacket->u.Tx.pFraglist->Fragments[FragCount].
+                FragSize << 16) | pPacket->Flags;
+
+            Idx = (Idx + 1) & T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+            FragCount++;
+            if (FragCount >= pPacket->u.Tx.FragCount)
+            {
+                pSendBd->u1.Len_Flags = Value32 | SND_BD_FLAG_END;
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+                break;
+            }
+            else
+            {
+                pSendBd->u1.Len_Flags = Value32;
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+            }
+            pSendBd++;
+            if (Idx == 0)
+            {
+                pSendBd = &pDevice->pSendBdVirt[0];
+            }
+        } /* for */
+    }
+
+    /* Put the packet descriptor in the ActiveQ. */
+    QQ_PushTail(&pDevice->TxPacketActiveQ.Container, pPacket);
+
+    if(pDevice->NicSendBd == FALSE)
+    {
+        REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, Idx);
+
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, Idx);
+        }
+    }
+    else {
+        REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, Idx);
+
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, Idx);
+        }
+    }
+    /* Update the producer index. */
+    pDevice->SendProdIdx = Idx;
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned long
+ComputeCrc32(
+unsigned char *pBuffer,
+unsigned long BufferSize) {
+    unsigned long Reg;
+    unsigned long Tmp;
+    unsigned long j, k;
+
+    Reg = 0xffffffff;
+
+    for(j = 0; j < BufferSize; j++)
+    {
+        Reg ^= pBuffer[j];
+
+        for(k = 0; k < 8; k++)
+        {
+            Tmp = Reg & 0x01;
+
+            Reg >>= 1;
+
+            if(Tmp)
+            {
+                Reg ^= 0xedb88320;
+            }
+        }
+    }
+
+    return ~Reg;
+} /* ComputeCrc32 */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine sets the receive control register according to ReceiveMask */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_SetReceiveMask(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Mask) {
+    LM_UINT32 ReceiveMask;
+    LM_UINT32 RxMode;
+    LM_UINT32 j, k;
+
+    ReceiveMask = Mask;
+
+    RxMode = pDevice->RxMode;
+
+    if(Mask & LM_ACCEPT_UNICAST)
+    {
+        Mask &= ~LM_ACCEPT_UNICAST;
+    }
+
+    if(Mask & LM_ACCEPT_MULTICAST)
+    {
+        Mask &= ~LM_ACCEPT_MULTICAST;
+    }
+
+    if(Mask & LM_ACCEPT_ALL_MULTICAST)
+    {
+        Mask &= ~LM_ACCEPT_ALL_MULTICAST;
+    }
+
+    if(Mask & LM_ACCEPT_BROADCAST)
+    {
+        Mask &= ~LM_ACCEPT_BROADCAST;
+    }
+
+    RxMode &= ~RX_MODE_PROMISCUOUS_MODE;
+    if(Mask & LM_PROMISCUOUS_MODE)
+    {
+        RxMode |= RX_MODE_PROMISCUOUS_MODE;
+        Mask &= ~LM_PROMISCUOUS_MODE;
+    }
+
+    RxMode &= ~(RX_MODE_ACCEPT_RUNTS | RX_MODE_ACCEPT_OVERSIZED);
+    if(Mask & LM_ACCEPT_ERROR_PACKET)
+    {
+        RxMode |= RX_MODE_ACCEPT_RUNTS | RX_MODE_ACCEPT_OVERSIZED;
+        Mask &= ~LM_ACCEPT_ERROR_PACKET;
+    }
+
+    /* Make sure all the bits are valid before committing changes. */
+    if(Mask)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Commit the new filter. */
+    pDevice->RxMode = RxMode;
+    REG_WR(pDevice, MacCtrl.RxMode, RxMode);
+
+    pDevice->ReceiveMask = ReceiveMask;
+
+    /* Set up the MC hash table. */
+    if(ReceiveMask & LM_ACCEPT_ALL_MULTICAST)
+    {
+        for(k = 0; k < 4; k++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[k], 0xffffffff);
+        }
+    }
+    else if(ReceiveMask & LM_ACCEPT_MULTICAST)
+    {
+        LM_UINT32 HashReg[4];
+
+        HashReg[0] = 0; HashReg[1] = 0; HashReg[2] = 0; HashReg[3] = 0;
+        for(j = 0; j < pDevice->McEntryCount; j++)
+        {
+            LM_UINT32 RegIndex;
+            LM_UINT32 Bitpos;
+            LM_UINT32 Crc32;
+
+            Crc32 = ComputeCrc32(pDevice->McTable[j], ETHERNET_ADDRESS_SIZE);
+
+            /* The most significant 7 bits of the CRC32 (no inversion), */
+            /* are used to index into one of the possible 128 bit positions. */
+            Bitpos = ~Crc32 & 0x7f;
+
+            /* Hash register index. */
+            RegIndex = (Bitpos & 0x60) >> 5;
+
+            /* Bit to turn on within a hash register. */
+            Bitpos &= 0x1f;
+
+            /* Enable the multicast bit. */
+            HashReg[RegIndex] |= (1 << Bitpos);
+        }
+
+        /* REV_AX has problem with multicast filtering where it uses both */
+        /* DA and SA to perform hashing. */
+        for(k = 0; k < 4; k++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[k], HashReg[k]);
+        }
+    }
+    else
+    {
+        /* Reject all multicast frames. */
+        for(j = 0; j < 4; j++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[j], 0);
+        }
+    }
+
+    /* By default, Tigon3 will accept broadcast frames.  We need to setup */
+    if(ReceiveMask & LM_ACCEPT_BROADCAST)
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Rule,
+            REJECT_BROADCAST_RULE1_RULE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Value,
+            REJECT_BROADCAST_RULE1_VALUE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Rule,
+            REJECT_BROADCAST_RULE1_RULE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Value,
+            REJECT_BROADCAST_RULE1_VALUE & RCV_DISABLE_RULE_MASK);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Rule, 
+            REJECT_BROADCAST_RULE1_RULE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Value, 
+            REJECT_BROADCAST_RULE1_VALUE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Rule, 
+            REJECT_BROADCAST_RULE2_RULE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Value, 
+            REJECT_BROADCAST_RULE2_VALUE);
+    }
+
+    /* disable the rest of the rules. */
+    for(j = RCV_LAST_RULE_IDX; j < 16; j++)
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[j].Rule, 0);
+        REG_WR(pDevice, MacCtrl.RcvRules[j].Value, 0);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetReceiveMask */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Disable the interrupt and put the transmitter and receiver engines in   */
+/*    an idle state.  Also aborts all pending send requests and receive       */
+/*    buffers.                                                                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_Abort(
+PLM_DEVICE_BLOCK pDevice)
+{
+    PLM_PACKET pPacket;
+    LM_UINT Idx;
+
+    LM_DisableInterrupt(pDevice);
+
+    /* Disable all the state machines. */
+    LM_CntrlBlock(pDevice,T3_BLOCK_MAC_RX_ENGINE,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_BD_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_LIST_PLMT,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_LIST_SELECTOR,LM_DISABLE);  
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_DATA_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_DATA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_BD_COMP,LM_DISABLE);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_SELECTOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_DATA_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_RD,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_DATA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_COMP,LM_DISABLE);
+
+    /* Clear TDE bit */
+    pDevice->MacMode &= ~MAC_MODE_ENABLE_TDE;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_MAC_TX_ENGINE,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_HOST_COALESING,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_WR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_MBUF_CLUSTER_FREE,LM_DISABLE);
+
+    /* Reset all FTQs */
+    REG_WR(pDevice, Ftq.Reset, 0xffffffff);
+    REG_WR(pDevice, Ftq.Reset, 0x0);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_MBUF_MANAGER,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_MEM_ARBITOR,LM_DISABLE);
+
+    MM_ACQUIRE_INT_LOCK(pDevice);
+
+    /* Abort packets that have already queued to go out. */
+    pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->TxPacketActiveQ.Container);
+    while(pPacket)
+    {
+//        MM_CompleteTxDma(pDevice, pPacket);
+
+        pPacket->PacketStatus = LM_STATUS_TRANSMIT_ABORTED;
+        pDevice->TxCounters.TxPacketAbortedCnt++;
+
+        atomic_add(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+        QQ_PushTail(&pDevice->TxPacketXmittedQ.Container, pPacket);
+
+        pPacket = (PLM_PACKET) 
+            QQ_PopHead(&pDevice->TxPacketActiveQ.Container);
+    }
+
+    /* Cleanup the receive return rings. */
+    LM_ServiceRxInterrupt(pDevice);
+
+    /* Don't want to indicate rx packets in Ndis miniport shutdown context. */
+    /* Doing so may cause system crash. */
+    if(!pDevice->ShuttingDown)
+    {
+        /* Indicate packets to the protocol. */
+        MM_IndicateTxPackets(pDevice);
+
+        /* Indicate received packets to the protocols. */
+        MM_IndicateRxPackets(pDevice);
+    }
+    else
+    {
+        /* Move the receive packet descriptors in the ReceivedQ to the */
+        /* free queue. */
+        for(; ;)
+        {
+            pPacket = (PLM_PACKET) QQ_PopHead(
+                &pDevice->RxPacketReceivedQ.Container);
+            if(pPacket == NULL)
+            {
+                break;
+            }
+            QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+        }
+    }
+
+    /* Clean up the Std Receive Producer ring. */
+    Idx = pDevice->pStatusBlkVirt->RcvStdConIdx;
+
+    while(Idx != pDevice->RxStdProdIdx) {
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pDevice->pRxStdBdVirt[Idx].Opaque));
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        Idx = (Idx + 1) & T3_STD_RCV_RCB_ENTRY_COUNT_MASK;
+    } /* while */
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxStdProdIdx = 0;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Clean up the Jumbo Receive Producer ring. */
+    Idx = pDevice->pStatusBlkVirt->RcvJumboConIdx;
+
+    while(Idx != pDevice->RxJumboProdIdx) {
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pDevice->pRxJumboBdVirt[Idx].Opaque));
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        Idx = (Idx + 1) & T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK;
+    } /* while */
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxJumboProdIdx = 0;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    MM_RELEASE_INT_LOCK(pDevice);
+
+    /* Initialize the statistis Block */
+    pDevice->pStatusBlkVirt->Status = 0;
+    pDevice->pStatusBlkVirt->RcvStdConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvJumboConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvMiniConIdx = 0;
+
+    return LM_STATUS_SUCCESS;
+} /* LM_Abort */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Disable the interrupt and put the transmitter and receiver engines in   */
+/*    an idle state.  Aborts all pending send requests and receive buffers.   */
+/*    Also free all the receive buffers.                                      */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_Halt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    LM_UINT32 EntryCnt;
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    LM_Abort(pDevice);
+
+    /* Get the number of entries in the queue. */
+    EntryCnt = QQ_GetEntryCnt(&pDevice->RxPacketFreeQ.Container);
+
+    /* Make sure all the packets have been accounted for. */
+    for(EntryCnt = 0; EntryCnt < pDevice->RxPacketDescCnt; EntryCnt++)
+    {
+        pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+        if (pPacket == 0)
+            break;
+
+        MM_FreeRxBuffer(pDevice, pPacket);
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+    }
+
+    /* Reset the chip. */
+    {
+        /* Global reset. */
+        REG_WR(pDevice, Grc.MiscCfg, GRC_MISC_CFG_CORE_CLOCK_RESET);
+        for(j = 0; j < 100; j++)
+        {
+            MM_Wait(10);
+        }
+
+        /* re-enable PCI command word. */
+        MM_WriteConfig32(pDevice, PCI_COMMAND_REG,
+            pDevice->PciCommandStatusWords);
+
+        /* Disable PCI-X relaxed ordering bit. */
+        MM_ReadConfig32(pDevice, PCIX_CAP_REG, &Value32);
+        Value32 &= ~PCIX_ENABLE_RELAXED_ORDERING;
+        MM_WriteConfig32(pDevice, PCIX_CAP_REG, Value32);
+
+        /* make sure we re-enable indirect accesses */
+        MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG,
+            pDevice->MiscHostCtrl);
+
+        /* Enable memory arbiter. */
+        REG_WR(pDevice, MemArbiter.Mode, T3_MEM_ARBITER_MODE_ENABLE);
+
+        /* Reconfigure the miscellaneous host control register after reset. */
+        REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl);
+    }
+
+    /* Prevent PXE from restarting. */
+    MEM_WR_OFFSET(pDevice, 0x0b50, T3_MAGIC_NUM);
+
+    /* Wait for the firmware to finish initialization. */
+    for(j = 0; j < 50000; j++)
+    {
+        MM_Wait(10);
+
+        Value32 = MEM_RD_OFFSET(pDevice, 0x0b50);
+        if(Value32 == ~T3_MAGIC_NUM)
+        {
+            break;
+        }
+    }
+
+    /* Restore PCI configuration registers. */
+    MM_WriteConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG,
+        pDevice->SavedCacheLineReg);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_Halt */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void
+LM_ServiceTxInterrupt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    LM_UINT32 HwConIdx;
+    LM_UINT32 SwConIdx;
+
+    HwConIdx = pDevice->pStatusBlkVirt->Idx[0].SendConIdx;
+
+    /* Get our copy of the consumer index.  The buffer descriptors */
+    /* that are in between the consumer indices are freed. */
+    SwConIdx = pDevice->SendConIdx;
+
+    /* Move the packets from the TxPacketActiveQ that are sent out to */
+    /* the TxPacketXmittedQ.  Packets that are sent use the */
+    /* descriptors that are between SwConIdx and HwConIdx. */
+    while(SwConIdx != HwConIdx)
+    {
+        /* Get the packet that was sent from the TxPacketActiveQ. */
+        pPacket = (PLM_PACKET) QQ_PopHead(
+            &pDevice->TxPacketActiveQ.Container);
+
+        /* Set the return status. */
+        pPacket->PacketStatus = LM_STATUS_SUCCESS;
+
+        /* Complete the transmit with a call to MM_CompleteTxDma. */
+//        MM_CompleteTxDma(pDevice, pPacket);
+
+        /* Put the packet in the TxPacketXmittedQ for indication later. */
+        QQ_PushTail(&pDevice->TxPacketXmittedQ.Container, pPacket);
+
+        /* Move to the next packet's BD. */
+        SwConIdx = (SwConIdx + pPacket->u.Tx.FragCount) & 
+            T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+        /* Update the number of unused BDs. */
+        atomic_add(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+        /* Get the new updated HwConIdx. */
+        HwConIdx = pDevice->pStatusBlkVirt->Idx[0].SendConIdx;
+    } /* while */
+
+    /* Save the new SwConIdx. */
+    pDevice->SendConIdx = SwConIdx;
+
+} /* LM_ServiceTxInterrupt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void
+LM_ServiceRxInterrupt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    PT3_RCV_BD pRcvBd;
+    LM_UINT32 HwRcvRetProdIdx;
+    LM_UINT32 SwRcvRetConIdx;
+
+    /* Loop thru the receive return rings for received packets. */
+    HwRcvRetProdIdx = pDevice->pStatusBlkVirt->Idx[0].RcvProdIdx;
+
+    SwRcvRetConIdx = pDevice->RcvRetConIdx;
+    while(SwRcvRetConIdx != HwRcvRetProdIdx)
+    {
+        pRcvBd = &pDevice->pRcvRetBdVirt[SwRcvRetConIdx];
+
+        /* Get the received packet descriptor. */
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pRcvBd->Opaque));
+
+        /* Check the error flag. */
+        if(pRcvBd->ErrorFlag &&
+            pRcvBd->ErrorFlag != RCV_BD_ERR_ODD_NIBBLED_RCVD_MII)
+        {
+            pPacket->PacketStatus = LM_STATUS_FAILURE;
+
+            pDevice->RxCounters.RxPacketErrCnt++;
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_BAD_CRC)
+            {
+                pDevice->RxCounters.RxErrCrcCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_COLL_DETECT)
+            {
+                pDevice->RxCounters.RxErrCollCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_LINK_LOST_DURING_PKT)
+            {
+                pDevice->RxCounters.RxErrLinkLostCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_PHY_DECODE_ERR)
+            {
+                pDevice->RxCounters.RxErrPhyDecodeCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_ODD_NIBBLED_RCVD_MII)
+            {
+                pDevice->RxCounters.RxErrOddNibbleCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_MAC_ABORT)
+            {
+                pDevice->RxCounters.RxErrMacAbortCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_LEN_LT_64)
+            {
+                pDevice->RxCounters.RxErrShortPacketCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_TRUNC_NO_RESOURCES)
+            {
+                pDevice->RxCounters.RxErrNoResourceCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_GIANT_FRAME_RCVD)
+            {
+                pDevice->RxCounters.RxErrLargePacketCnt++;
+            }
+        }
+        else
+        {
+            pPacket->PacketStatus = LM_STATUS_SUCCESS;
+            pPacket->PacketSize = pRcvBd->Len - 4;
+
+            pPacket->Flags = pRcvBd->Flags;
+            if(pRcvBd->Flags & RCV_BD_FLAG_VLAN_TAG)
+            {
+                pPacket->VlanTag = pRcvBd->VlanTag;
+            }
+
+            pPacket->u.Rx.TcpUdpChecksum = pRcvBd->TcpUdpCksum;
+        }
+
+#if 0
+        /* Decrement the number of receive buffers queued. */
+        switch(pPacket->u.Rx.RcvProdRing)
+        {
+            case T3_STD_RCV_PROD_RING:      /* Standard Receive Ring. */
+                pDevice->RxStdQueuedCnt--;
+                break;
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+            case T3_JUMBO_RCV_PROD_RING:    /* Jumbo Receive Ring. */
+                pDevice->RxJumboQueuedCnt--;
+                break;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+            case T3_UNKNOWN_RCV_PROD_RING:
+               break;
+        }
+#endif
+
+        /* Put the packet descriptor containing the received packet */
+        /* buffer in the RxPacketReceivedQ for indication later. */
+        QQ_PushTail(&pDevice->RxPacketReceivedQ.Container, pPacket);
+
+        /* Go to the next buffer descriptor. */
+        SwRcvRetConIdx = (SwRcvRetConIdx + 1) &
+            T3_RCV_RETURN_RCB_ENTRY_COUNT_MASK;
+
+        /* Get the updated HwRcvRetProdIdx. */
+        HwRcvRetProdIdx = pDevice->pStatusBlkVirt->Idx[0].RcvProdIdx;
+    } /* while */
+
+    pDevice->RcvRetConIdx = SwRcvRetConIdx;
+
+    /* Update the receive return ring consumer index. */
+    REG_WR(pDevice, Mailbox.RcvRetConIdx[0].Low, SwRcvRetConIdx);
+} /* LM_ServiceRxInterrupt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This is the interrupt event handler routine. It acknowledges all        */
+/*    pending interrupts and process all pending events.                      */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_ServiceInterrupts(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+
+    /* Setup the phy chip whenever the link status changes. */
+    if(pDevice->LinkChngMode == T3_LINK_CHNG_MODE_USE_STATUS_REG)
+    {
+        Value32 = REG_RD(pDevice, MacCtrl.Status);
+        if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT &&
+            (Value32 & MAC_STATUS_MI_INTERRUPT))
+        {
+            DbgMessage(INFORM, ("MI_INTERRUPT.\n"));
+            LM_SetupPhy(pDevice);
+        }
+        else if(Value32 & MAC_STATUS_LINK_STATE_CHANGED)
+        {
+            DbgMessage(INFORM, ("MAC_STATUS_LINK_CHANGED.\n"));
+            LM_SetupPhy(pDevice);
+        }
+    }
+    else
+    {
+        if(pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_LINK_CHANGED_STATUS)
+        {
+            DbgMessage(INFORM, ("STATUS_BLOCK_LINK_CHANGED.\n"));
+            pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED |
+                (pDevice->pStatusBlkVirt->Status & ~STATUS_BLOCK_LINK_CHANGED_STATUS);
+            LM_SetupPhy(pDevice);
+        }
+    }
+
+    /* Service receive and transmit interrupts. */
+    LM_ServiceRxInterrupt(pDevice);
+    LM_ServiceTxInterrupt(pDevice);
+        
+    /* No spinlock for this queue since this routine is serialized. */
+    if(!QQ_Empty(&pDevice->RxPacketReceivedQ.Container))
+    {
+        /* Indicate receive packets. */
+        MM_IndicateRxPackets(pDevice);
+//        LM_QueueRxPackets(pDevice);
+    }
+
+    /* No spinlock for this queue since this routine is serialized. */
+    if(!QQ_Empty(&pDevice->TxPacketXmittedQ.Container))
+    {
+        MM_IndicateTxPackets(pDevice);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_ServiceInterrupts */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastAdd(
+PLM_DEVICE_BLOCK pDevice,
+PLM_UINT8 pMcAddress) {
+    PLM_UINT8 pEntry;
+    LM_UINT32 j;
+
+    pEntry = pDevice->McTable[0];
+    for(j = 0; j < pDevice->McEntryCount; j++)
+    {
+        if(IS_ETH_ADDRESS_EQUAL(pEntry, pMcAddress))
+        {
+            /* Found a match, increment the instance count. */
+            pEntry[LM_MC_INSTANCE_COUNT_INDEX] += 1;
+
+            return LM_STATUS_SUCCESS;
+        }
+
+        pEntry += LM_MC_ENTRY_SIZE;
+    }
+    
+    if(pDevice->McEntryCount >= LM_MAX_MC_TABLE_SIZE)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    pEntry = pDevice->McTable[pDevice->McEntryCount];
+
+    COPY_ETH_ADDRESS(pMcAddress, pEntry);
+    pEntry[LM_MC_INSTANCE_COUNT_INDEX] = 1;
+
+    pDevice->McEntryCount++;
+
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask | LM_ACCEPT_MULTICAST);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_MulticastAdd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastDel(
+PLM_DEVICE_BLOCK pDevice,
+PLM_UINT8 pMcAddress) {
+    PLM_UINT8 pEntry;
+    LM_UINT32 j;
+
+    pEntry = pDevice->McTable[0];
+    for(j = 0; j < pDevice->McEntryCount; j++)
+    {
+        if(IS_ETH_ADDRESS_EQUAL(pEntry, pMcAddress))
+        {
+            /* Found a match, decrement the instance count. */
+            pEntry[LM_MC_INSTANCE_COUNT_INDEX] -= 1;
+
+            /* No more instance left, remove the address from the table. */
+            /* Move the last entry in the table to the delete slot. */
+            if(pEntry[LM_MC_INSTANCE_COUNT_INDEX] == 0 &&
+                pDevice->McEntryCount > 1)
+            {
+
+                COPY_ETH_ADDRESS(
+                    pDevice->McTable[pDevice->McEntryCount-1], pEntry);
+                pEntry[LM_MC_INSTANCE_COUNT_INDEX] =
+                    pDevice->McTable[pDevice->McEntryCount-1]
+                    [LM_MC_INSTANCE_COUNT_INDEX];
+            }
+            pDevice->McEntryCount--;
+
+            /* Update the receive mask if the table is empty. */
+            if(pDevice->McEntryCount == 0)
+            {
+                LM_SetReceiveMask(pDevice, 
+                    pDevice->ReceiveMask & ~LM_ACCEPT_MULTICAST);
+            }
+
+            return LM_STATUS_SUCCESS;
+        }
+
+        pEntry += LM_MC_ENTRY_SIZE;
+    }
+
+    return LM_STATUS_FAILURE;
+} /* LM_MulticastDel */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastClear(
+PLM_DEVICE_BLOCK pDevice) {
+    pDevice->McEntryCount = 0;
+
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask & ~LM_ACCEPT_MULTICAST);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_MulticastClear */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetMacAddress(
+    PLM_DEVICE_BLOCK pDevice,
+    PLM_UINT8 pMacAddress)
+{
+    LM_UINT32 j;
+
+    for(j = 0; j < 4; j++)
+    {
+        REG_WR(pDevice, MacCtrl.MacAddr[j].High,
+            (pMacAddress[0] << 8) | pMacAddress[1]);
+        REG_WR(pDevice, MacCtrl.MacAddr[j].Low,
+            (pMacAddress[2] << 24) | (pMacAddress[3] << 16) |
+            (pMacAddress[4] << 8) | pMacAddress[5]);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_LoopbackAddress(
+PLM_DEVICE_BLOCK pDevice,
+PLM_UINT8 pAddress) {
+    LM_UINT32 Index;
+
+    if(IS_ETH_MULTICAST(pAddress))
+    {
+        if(IS_ETH_BROADCAST(pAddress))
+        {
+            if(pDevice->ReceiveMask & LM_ACCEPT_BROADCAST)
+            {
+                return LM_STATUS_SUCCESS;
+            }
+
+            return LM_STATUS_FAILURE;
+        }
+
+        for(Index = 0; Index < pDevice->McEntryCount; Index++)
+        {
+            if(IS_ETH_ADDRESS_EQUAL(pAddress, pDevice->McTable[Index]))
+            {
+                return LM_STATUS_SUCCESS;
+            }
+        }
+
+        return LM_STATUS_FAILURE;
+    }
+
+    if(IS_ETH_ADDRESS_EQUAL(pAddress, pDevice->NodeAddress))
+    {
+        return LM_STATUS_SUCCESS;
+    }
+
+    return LM_STATUS_FAILURE;
+} /* LM_LoopbackAddress */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Sets up the default line speed, and duplex modes based on the requested */
+/*    media type.                                                             */
+/*                                                                            */
+/* Return:                                                                    */
+/*    None.                                                                   */
+/******************************************************************************/
+static LM_STATUS
+LM_TranslateRequestedMediaType(
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+PLM_MEDIA_TYPE pMediaType,
+PLM_LINE_SPEED pLineSpeed,
+PLM_DUPLEX_MODE pDuplexMode) {
+    *pMediaType = LM_MEDIA_TYPE_AUTO;
+    *pLineSpeed = LM_LINE_SPEED_UNKNOWN;
+    *pDuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+
+    /* determine media type */
+    switch(RequestedMediaType) {
+        case LM_REQUESTED_MEDIA_TYPE_BNC:
+            *pMediaType = LM_MEDIA_TYPE_BNC;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_AUTO:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        default:
+            break;
+    } /* switch */
+
+    return LM_STATUS_SUCCESS;
+} /* LM_TranslateRequestedMediaType */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_LINK_ACTIVE                                                   */
+/*    LM_STATUS_LINK_DOWN                                                     */
+/******************************************************************************/
+static LM_STATUS
+LM_InitBcm540xPhy(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_LINE_SPEED CurrentLineSpeed;
+    LM_DUPLEX_MODE CurrentDuplexMode;
+    LM_STATUS CurrentLinkStatus;
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        if(!pDevice->InitDone)
+        {
+            Value32 = 0;
+        }
+
+        if(!(Value32 & PHY_STATUS_LINK_PASS))
+        {
+            LM_WritePhy(pDevice, BCM5401_AUX_CTRL,  0x0c20);
+
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+            for(j = 0; j < 1000; j++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+                if(Value32 & PHY_STATUS_LINK_PASS)
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+            if((pDevice->PhyId & PHY_ID_REV_MASK) == PHY_BCM5401_B0_REV)
+            {
+                if(!(Value32 & PHY_STATUS_LINK_PASS) &&
+                    (pDevice->OldLineSpeed == LM_LINE_SPEED_1000MBPS))
+                {
+                    LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_PHY_RESET);
+                    for(j = 0; j < 5000; j++)
+                    {
+                        MM_Wait(10);
+
+                        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+                        if(!(Value32 & PHY_CTRL_PHY_RESET))
+                        {
+                            MM_Wait(40);
+                            break;
+                        }
+                    }
+
+                    LM_WritePhy(pDevice, BCM5401_AUX_CTRL,  0x0c20);
+
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+                }
+            }
+        }
+    }
+    else if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+    {
+        /* Bug: 5701 A0, B0 TX CRC workaround. */
+        LM_WritePhy(pDevice, 0x15, 0x0a75);
+        LM_WritePhy(pDevice, 0x1c, 0x8c68);
+        LM_WritePhy(pDevice, 0x1c, 0x8d68);
+        LM_WritePhy(pDevice, 0x1c, 0x8c68);
+    }
+
+    /* Acknowledge interrupts. */
+    LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+    LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+
+    /* Configure the interrupt mask. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+    {
+        LM_WritePhy(pDevice, BCM540X_INT_MASK_REG, ~BCM540X_INT_LINK_CHANGE);
+    }
+
+    /* Use GMII interface. */
+    if(pDevice->Bcm540xMode == BCM540X_MODE_THREE_LINK)
+    {
+        LM_WritePhy(pDevice, BCM540X_EXT_CTRL_REG, 
+            BCM540X_EXT_CTRL_LINK3_LED_MODE);
+    }
+    else
+    {
+        LM_WritePhy(pDevice, BCM540X_EXT_CTRL_REG, 0);
+    }
+
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Get current link and duplex mode. */
+    LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+    LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+    if(Value32 & PHY_STATUS_LINK_PASS)
+    {
+
+        /* Determine the current line and duplex settings. */
+        LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+        for(j = 0; j < 2000; j++)
+        {
+            MM_Wait(10);
+
+            LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+            if(Value32)
+            {
+                break;
+            }
+        }
+
+        switch(Value32 & BCM540X_AUX_SPEED_MASK)
+        {
+            case BCM540X_AUX_10BASET_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_10MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_10BASET_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_10MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            case BCM540X_AUX_100BASETX_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_100MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_100BASETX_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_100MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            case BCM540X_AUX_100BASET_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_1000MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_100BASET_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_1000MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            default:
+
+                CurrentLineSpeed = LM_LINE_SPEED_UNKNOWN;
+                CurrentDuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+                break;
+        }
+
+        /* Make sure we are in auto-neg mode. */
+        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+
+        /* Bug?  First read may not return the right value. */
+        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+
+        /* Use the current line settings for "auto" mode. */
+        if(pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+            pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+        {
+            if(Value32 & PHY_CTRL_AUTO_NEG_ENABLE)
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+
+                /* We may be exiting low power mode and the link is in */
+                /* 10mb.  In this case, we need to restart autoneg. */
+                LM_ReadPhy(pDevice, BCM540X_1000BASET_CTRL_REG, &Value32);
+                if(!(Value32 & (BCM540X_AN_AD_1000BASET_HALF |
+                    BCM540X_AN_AD_1000BASET_FULL)))
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+                }
+            }
+            else
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+            }
+        }
+        else
+        {
+            /* Force line settings. */
+            /* Use the current setting if it matches the user's requested */
+            /* setting. */
+            LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+            if((pDevice->LineSpeed == CurrentLineSpeed) &&
+                (pDevice->DuplexMode == CurrentDuplexMode))
+            {
+                if ((pDevice->DisableAutoNeg &&
+                    !(Value32 & PHY_CTRL_AUTO_NEG_ENABLE)) ||
+                    (!pDevice->DisableAutoNeg &&
+                    (Value32 & PHY_CTRL_AUTO_NEG_ENABLE)))
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+                }
+                else
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+                } 
+            }
+            else
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+            } 
+        }
+
+        /* Save line settings. */
+        pDevice->LineSpeed = CurrentLineSpeed;
+        pDevice->DuplexMode = CurrentDuplexMode;
+        pDevice->MediaType = LM_MEDIA_TYPE_UTP;
+    }
+
+    return CurrentLinkStatus;
+} /* LM_InitBcm540xPhy */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetFlowControl(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 LocalPhyAd,
+    LM_UINT32 RemotePhyAd)
+{
+    LM_FLOW_CONTROL FlowCap;
+
+    DbgMessage(INFORM, ("### LM_SetFlowControl\n"));
+
+    /* Resolve flow control. */
+    FlowCap = LM_FLOW_CONTROL_NONE;
+
+    /* See Table 28B-3 of 802.3ab-1999 spec. */
+    if(pDevice->FlowControlCap & LM_FLOW_CONTROL_AUTO_PAUSE)
+    {
+        if(LocalPhyAd & PHY_AN_AD_PAUSE_CAPABLE)
+        {
+            if(LocalPhyAd & PHY_AN_AD_ASYM_PAUSE)
+            {
+                if(RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE)
+                {
+                    DbgMessage(INFORM, ("FlowCap: tx/rx\n"));
+                    FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+                        LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+                else if(RemotePhyAd & PHY_LINK_PARTNER_ASYM_PAUSE)
+                {
+                    DbgMessage(INFORM, ("FlowCap: rx PAUSE\n"));
+                    FlowCap = LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+            }
+            else
+            {
+                if(RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE)
+                {
+                    DbgMessage(INFORM, ("FlowCap: tx/rx\n"));
+                    FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+                        LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+            }
+        }
+        else if(LocalPhyAd & PHY_AN_AD_ASYM_PAUSE)
+        {
+            if((RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE) &&
+                (RemotePhyAd & PHY_LINK_PARTNER_ASYM_PAUSE))
+            {
+                DbgMessage(INFORM, ("FlowCap: tx PAUSE\n"));
+                FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+            }
+        }
+    }
+    else
+    {
+        FlowCap = pDevice->FlowControlCap;
+    }
+
+    /* Enable/disable rx PAUSE. */
+    pDevice->RxMode &= ~RX_MODE_ENABLE_FLOW_CONTROL;
+    if(FlowCap & LM_FLOW_CONTROL_RECEIVE_PAUSE &&
+        (pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE ||
+        pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE))
+    {
+        pDevice->FlowControl |= LM_FLOW_CONTROL_RECEIVE_PAUSE;
+        pDevice->RxMode |= RX_MODE_ENABLE_FLOW_CONTROL;
+
+        DbgMessage(INFORM, ("Enable rx PAUSE.\n"));
+    }
+    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+
+    /* Enable/disable tx PAUSE. */
+    pDevice->TxMode &= ~TX_MODE_ENABLE_FLOW_CONTROL;
+    if(FlowCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE &&
+        (pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE ||
+        pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE))
+    {
+        pDevice->FlowControl |= LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+        pDevice->TxMode |= TX_MODE_ENABLE_FLOW_CONTROL;
+
+        DbgMessage(INFORM, ("Enable tx PAUSE.\n"));
+    }
+    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+#if INCLUDE_TBI_SUPPORT
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_InitBcm800xPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    DbgMessage(INFORM, ("### LM_InitBcm800xPhy\n"));
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+
+    /* Reset the SERDES during init and when we have link. */
+    if(!pDevice->InitDone || Value32 & MAC_STATUS_PCS_SYNCED)
+    {
+        /* Set PLL lock range. */
+        LM_WritePhy(pDevice, 0x16, 0x8007);
+
+        /* Software reset. */
+        LM_WritePhy(pDevice, 0x00, 0x8000);
+
+        /* Wait for reset to complete. */
+        for(j = 0; j < 500; j++)
+        {
+            MM_Wait(10);
+        }
+
+#if DBG
+        /* Verify lock (if cable attached).  Should be 0x8001. */
+        LM_ReadPhy(pDevice, 0x10, &Value32);
+        DbgMessage(INFORM, ("FiberPhy 0x10 = 0x%x\n", Value32));
+#endif
+
+        /* Config mode; seletct PMA/Ch 1 regs. */
+        LM_WritePhy(pDevice, 0x10, 0x8411);
+
+        /* Enable auto-lock and comdet, select txclk for tx. */
+        LM_WritePhy(pDevice, 0x11, 0x0a10);
+
+        LM_WritePhy(pDevice, 0x18, 0x00a0);
+        LM_WritePhy(pDevice, 0x16, 0x41ff);
+
+        /* Assert and deassert POR. */
+        LM_WritePhy(pDevice, 0x13, 0x0400);
+        MM_Wait(40);
+        LM_WritePhy(pDevice, 0x13, 0x0000);
+
+        LM_WritePhy(pDevice, 0x11, 0x0a50);
+        MM_Wait(40);
+        LM_WritePhy(pDevice, 0x11, 0x0a10);
+
+        /* Delay for signal to stabilize. */
+        for(j = 0; j < 15000; j++)
+        {
+            MM_Wait(10);
+        }
+
+        /* Deselect the channel register so we can read the PHY id later. */
+        LM_WritePhy(pDevice, 0x10, 0x8011);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_SetupFiberPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS CurrentLinkStatus;
+    AUTONEG_STATUS AnStatus = 0;
+    LM_UINT32 Value32;
+    LM_UINT32 Cnt;
+    LM_UINT32 j;
+
+    DbgMessage(INFORM, ("### LM_SetupFiberPhy\n"));
+
+    /* Enable TBI and full duplex mode. */
+    pDevice->MacMode |= MAC_MODE_PORT_MODE_TBI;
+    pDevice->MacMode &= ~MAC_MODE_HALF_DUPLEX;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+//    MM_Wait(40);
+
+    /* Initialize the BCM8002 SERDES PHY. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM8002_PHY_ID:
+            LM_InitBcm800xPhy(pDevice);
+            break;
+
+        default:
+            break;
+    }
+
+    /* Enable link change interrupt. */
+    REG_WR(pDevice, MacCtrl.MacEvent, MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN);
+
+    /* Default to link down. */
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Get the link status. */
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if(Value32 & MAC_STATUS_PCS_SYNCED)
+    {
+        if(pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO)
+        {
+            /* auto-negotiation mode. */
+            DbgMessage(INFORM, ("Autoneg mode.\n"));
+
+            /* Initialize the autoneg default capaiblities. */
+            AutonegInit(&pDevice->AnInfo);
+
+            /* Set the context pointer to point to the main device structure. */
+            pDevice->AnInfo.pContext = pDevice;
+
+            /* Setup flow control advertisement register. */
+            Value32 = GetPhyAdFlowCntrlSettings(pDevice);
+            if(Value32 & PHY_AN_AD_PAUSE_CAPABLE)
+            {
+                pDevice->AnInfo.mr_adv_sym_pause = 1;
+            }
+            else
+            {
+                pDevice->AnInfo.mr_adv_sym_pause = 0;
+            }
+
+            if(Value32 & PHY_AN_AD_ASYM_PAUSE)
+            {
+                pDevice->AnInfo.mr_adv_asym_pause = 1;
+            }
+            else
+            {
+                pDevice->AnInfo.mr_adv_asym_pause = 0;
+            }
+
+            /* Try to autoneg up to six times. */
+            Cnt = 0;
+            while (Cnt < 6)
+            {
+                Cnt++;
+                REG_WR(pDevice, MacCtrl.TxAutoNeg, 0);
+
+                Value32 = pDevice->MacMode & ~MAC_MODE_PORT_MODE_MASK;
+                Value32 |= MAC_MODE_PORT_MODE_GMII;
+                REG_WR(pDevice, MacCtrl.Mode, Value32);
+                MM_Wait(20);
+
+                REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+                    MAC_MODE_SEND_CONFIGS);
+
+                pDevice->AnInfo.State = AN_STATE_UNKNOWN;
+                pDevice->AnInfo.CurrentTime_us = 0;
+
+                for(j = 0; pDevice->AnInfo.CurrentTime_us < 95000; j++)
+                {
+                    AnStatus = Autoneg8023z(&pDevice->AnInfo);
+
+                    if((AnStatus == AUTONEG_STATUS_DONE) || 
+                        (AnStatus == AUTONEG_STATUS_FAILED))
+                    {
+                        break;
+                    }
+                
+                    MM_Wait(1);
+                }
+                if((AnStatus == AUTONEG_STATUS_DONE) || 
+                    (AnStatus == AUTONEG_STATUS_FAILED))
+                {
+                    break;
+                }
+            }
+
+            /* Stop sending configs. */
+            MM_AnTxIdle(&pDevice->AnInfo);
+
+            /* Resolve flow control settings. */
+            if((AnStatus == AUTONEG_STATUS_DONE) &&
+                pDevice->AnInfo.mr_an_complete && pDevice->AnInfo.mr_link_ok &&
+                pDevice->AnInfo.mr_lp_adv_full_duplex)
+                {
+                LM_UINT32 RemotePhyAd;
+                LM_UINT32 LocalPhyAd;
+
+                DbgMessage(INFORM, ("Autoneg successful.\n"));
+
+                LocalPhyAd = 0;
+                if(pDevice->AnInfo.mr_adv_sym_pause)
+                {
+                    LocalPhyAd |= PHY_AN_AD_PAUSE_CAPABLE;
+                }
+
+                if(pDevice->AnInfo.mr_adv_asym_pause)
+                {
+                    LocalPhyAd |= PHY_AN_AD_ASYM_PAUSE;
+                }
+
+                RemotePhyAd = 0;
+                if(pDevice->AnInfo.mr_lp_adv_sym_pause)
+                {
+                    RemotePhyAd |= PHY_LINK_PARTNER_PAUSE_CAPABLE;
+                }
+
+                if(pDevice->AnInfo.mr_lp_adv_asym_pause)
+                {
+                    RemotePhyAd |= PHY_LINK_PARTNER_ASYM_PAUSE;
+                }
+
+                LM_SetFlowControl(pDevice, LocalPhyAd, RemotePhyAd);
+
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+            }
+            for (j = 0; j < 60; j++)
+            {
+                MM_Wait(20);
+                REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+                    MAC_STATUS_CFG_CHANGED);
+                MM_Wait(20);
+                if ((REG_RD(pDevice, MacCtrl.Status) &
+                    (MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED)) == 0)
+                    break;
+            }
+        }
+        else
+        {
+            /* We are forcing line speed. */
+            DbgMessage(INFORM, ("Forcing fiber 1000FD.\n"));
+
+            CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+        }
+    }
+    /* Set the link polarity bit. */
+    pDevice->MacMode &= ~MAC_MODE_LINK_POLARITY;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED |
+        (pDevice->pStatusBlkVirt->Status & ~STATUS_BLOCK_LINK_CHANGED_STATUS);
+
+    for (j = 0; j < 100; j++)
+    {
+        REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+            MAC_STATUS_CFG_CHANGED);
+        MM_Wait(5);
+        if ((REG_RD(pDevice, MacCtrl.Status) &
+            (MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED)) == 0)
+            break;
+    }
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if((Value32 & MAC_STATUS_PCS_SYNCED) == 0)
+        CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Initialize the current link status. */
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        DbgMessage(INFORM, ("link on fiber.\n"));
+        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+    }
+    else
+    {
+        DbgMessage(INFORM, ("No link on fiber.\n"));
+        pDevice->LineSpeed = LM_LINE_SPEED_UNKNOWN;
+        pDevice->DuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+    }
+
+    /* Indicate link status. */
+    if (pDevice->LinkStatus != CurrentLinkStatus) {
+        pDevice->LinkStatus = CurrentLinkStatus;
+        MM_IndicateStatus(pDevice, CurrentLinkStatus);
+    }
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if((Value32 & MAC_STATUS_PCS_SYNCED) == 0)
+    {
+        REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+            MAC_MODE_LINK_POLARITY);
+        if (pDevice->InitDone == TRUE)
+        {
+            MM_Wait(1);
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+        }
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+#endif /* INCLUDE_TBI_SUPPORT */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetupCopperPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS CurrentLinkStatus;
+    LM_UINT32 Value32;
+
+    /* Assume there is not link first. */
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Disable phy link change attention. */
+    REG_WR(pDevice, MacCtrl.MacEvent, 0);
+
+    /* Clear link change attention. */
+    REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+        MAC_STATUS_CFG_CHANGED);
+
+    /* Disable auto-polling for the moment. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    MM_Wait(40);
+
+    /* Determine the requested line speed and duplex. */
+    pDevice->OldLineSpeed = pDevice->LineSpeed;
+    LM_TranslateRequestedMediaType(pDevice->RequestedMediaType,
+        &pDevice->MediaType, &pDevice->LineSpeed, &pDevice->DuplexMode);
+
+    /* Set the phy to loopback mode. */
+    if(pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_PHY_LOOPBACK ||
+        pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_MAC_LOOPBACK)
+    {
+        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+        if(!(Value32 & PHY_CTRL_LOOPBACK_MODE) &&
+            pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_PHY_LOOPBACK)
+        {
+            /* Disable link change and PHY interrupts. */
+            REG_WR(pDevice, MacCtrl.MacEvent, 0);
+
+            /* Clear link change attention. */
+            REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+                MAC_STATUS_CFG_CHANGED);
+
+            LM_WritePhy(pDevice, PHY_CTRL_REG, 0x4140);
+            MM_Wait(40);
+
+            pDevice->MacMode &= ~MAC_MODE_LINK_POLARITY;
+            if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701 ||
+                T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5703)
+            {
+                pDevice->MacMode |= MAC_MODE_LINK_POLARITY;
+            }
+
+            /* GMII interface. */
+            pDevice->MacMode &= ~MAC_MODE_PORT_MODE_MASK;
+            pDevice->MacMode |= MAC_MODE_PORT_MODE_GMII;
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+            MM_Wait(40);
+
+            LM_WritePhy(pDevice, BCM540X_EXT_CTRL_REG, 
+                BCM540X_EXT_CTRL_LINK3_LED_MODE);
+            MM_Wait(40);
+        }
+
+        /* W2k will not transmit any packet when it thinks the link is down. */
+        pDevice->LinkStatus = LM_STATUS_LINK_ACTIVE;
+        MM_IndicateStatus(pDevice, LM_STATUS_LINK_ACTIVE);
+
+        return LM_STATUS_SUCCESS;
+    }
+
+    /* Did we just exit from loopback mode? */
+    LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+    LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+
+    if(Value32 & PHY_CTRL_LOOPBACK_MODE)
+    {
+        CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+        /* Re-enable link change interrupt.  This was disabled when we */
+        /* enter loopback mode. */
+        if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+        {
+            REG_WR(pDevice, MacCtrl.MacEvent, MAC_EVENT_ENABLE_MI_INTERRUPT);
+        }
+        else
+        {
+            REG_WR(pDevice, MacCtrl.MacEvent, 
+                MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN);
+        }
+    }
+    else
+    {
+        /* Initialize the phy chip. */
+        switch(pDevice->PhyId & PHY_ID_MASK)
+        {
+            case PHY_BCM5400_PHY_ID:
+            case PHY_BCM5401_PHY_ID:
+            case PHY_BCM5411_PHY_ID:
+            case PHY_BCM5701_PHY_ID:
+                CurrentLinkStatus = LM_InitBcm540xPhy(pDevice);
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    if(CurrentLinkStatus == LM_STATUS_LINK_SETTING_MISMATCH)
+    {
+        CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+    }
+    
+    /* Setup flow control. */
+    pDevice->FlowControl = LM_FLOW_CONTROL_NONE;
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        LM_FLOW_CONTROL FlowCap;     /* Flow control capability. */
+
+        FlowCap = LM_FLOW_CONTROL_NONE;
+
+        if(pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+        {
+            if(pDevice->DisableAutoNeg == FALSE ||
+                pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+                pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+            {
+                LM_UINT32 ExpectedPhyAd;
+                LM_UINT32 LocalPhyAd;
+                LM_UINT32 RemotePhyAd;
+
+                LM_ReadPhy(pDevice, PHY_AN_AD_REG, &LocalPhyAd);
+                LocalPhyAd &= (PHY_AN_AD_ASYM_PAUSE | PHY_AN_AD_PAUSE_CAPABLE);
+
+                ExpectedPhyAd = GetPhyAdFlowCntrlSettings(pDevice);
+
+                if(ExpectedPhyAd && LocalPhyAd != ExpectedPhyAd)
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+                }
+                else
+                {
+                    LM_ReadPhy(pDevice, PHY_LINK_PARTNER_ABILITY_REG,
+                        &RemotePhyAd);
+
+                    LM_SetFlowControl(pDevice, LocalPhyAd, RemotePhyAd);
+                }
+            }
+        }
+    }
+
+    if(CurrentLinkStatus == LM_STATUS_LINK_DOWN)
+    {
+        LM_ForceAutoNeg(pDevice, pDevice->RequestedMediaType, FALSE);
+
+        /* If we force line speed, we make get link right away. */
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        if(Value32 & PHY_STATUS_LINK_PASS)
+        {
+            CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+        }
+    }
+
+    /* GMII interface. */
+    pDevice->MacMode &= ~MAC_MODE_PORT_MODE_MASK;
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        if(pDevice->LineSpeed == LM_LINE_SPEED_100MBPS ||
+            pDevice->LineSpeed == LM_LINE_SPEED_10MBPS)
+        {
+            pDevice->MacMode |= MAC_MODE_PORT_MODE_MII;
+        }
+        else
+        {
+            pDevice->MacMode |= MAC_MODE_PORT_MODE_GMII;
+        }
+    }
+    else {
+        pDevice->MacMode |= MAC_MODE_PORT_MODE_GMII;
+    }
+
+    /* Set the MAC to operate in the appropriate duplex mode. */
+    pDevice->MacMode &= ~MAC_MODE_HALF_DUPLEX;
+    if(pDevice->DuplexMode == LM_DUPLEX_MODE_HALF)
+    {
+        pDevice->MacMode |= MAC_MODE_HALF_DUPLEX;
+    }
+
+    /* Set the link polarity bit. */
+    pDevice->MacMode &= ~MAC_MODE_LINK_POLARITY;
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+    {
+        if (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+        {
+            pDevice->MacMode |= MAC_MODE_LINK_POLARITY;
+        }
+
+        /* Set LED mode. */
+        REG_WR(pDevice, MacCtrl.LedCtrl, LED_CTRL_PHY_MODE_1);
+    }
+    else
+    {
+        if((pDevice->Bcm540xMode == BCM540X_MODE_LINK10) ||
+             (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE &&
+             pDevice->LineSpeed == LM_LINE_SPEED_10MBPS))
+        {
+            pDevice->MacMode |= MAC_MODE_LINK_POLARITY;
+        }
+    }
+
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    /* Enable auto polling. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        pDevice->MiMode |= MI_MODE_AUTO_POLLING_ENABLE;
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    }
+
+    /* Enable phy link change attention. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+    {
+        REG_WR(pDevice, MacCtrl.MacEvent, MAC_EVENT_ENABLE_MI_INTERRUPT);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.MacEvent, 
+            MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN);
+    }
+    if ((T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700) &&
+        (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE) &&
+        (pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) &&
+        (((pDevice->PciState & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) &&
+          (pDevice->PciState & T3_PCI_STATE_BUS_SPEED_HIGH)) ||
+         !(pDevice->PciState & T3_PCI_STATE_CONVENTIONAL_PCI_MODE)))
+    {
+        MM_Wait(120);
+        REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+            MAC_STATUS_CFG_CHANGED);
+        MEM_WR_OFFSET(pDevice, T3_FIRMWARE_MAILBOX,
+            T3_MAGIC_NUM_DISABLE_DMAW_ON_LINK_CHANGE);
+    }
+
+    /* Indicate link status. */
+    if (pDevice->LinkStatus != CurrentLinkStatus) {
+        pDevice->LinkStatus = CurrentLinkStatus;
+        MM_IndicateStatus(pDevice, CurrentLinkStatus);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetupCopperPhy */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetupPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS LmStatus;
+
+    DbgMessage(INFORM, ("### LM_SetupPhy\n"));
+
+#if INCLUDE_TBI_SUPPORT
+    if(pDevice->EnableTbi)
+    {
+        LmStatus = LM_SetupFiberPhy(pDevice);
+    }
+    else
+#endif /* INCLUDE_TBI_SUPPORT */
+    {
+        LmStatus = LM_SetupCopperPhy(pDevice);
+    }
+    if ((pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) &&
+        (pDevice->DuplexMode == LM_DUPLEX_MODE_HALF))
+    {
+        REG_WR(pDevice, MacCtrl.TxLengths, 0x26ff);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.TxLengths, 0x2620);
+    }
+
+    return LmStatus;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_ReadPhy(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 PhyReg,
+PLM_UINT32 pData32) {
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode &
+            ~MI_MODE_AUTO_POLLING_ENABLE);
+        MM_Wait(40);
+    }
+
+    Value32 = (pDevice->PhyAddr << MI_COM_FIRST_PHY_ADDR_BIT) |
+        ((PhyReg & MI_COM_PHY_REG_ADDR_MASK) << MI_COM_FIRST_PHY_REG_ADDR_BIT) |
+        MI_COM_CMD_READ | MI_COM_START;
+
+    REG_WR(pDevice, MacCtrl.MiCom, Value32);
+    
+    for(j = 0; j < 5000; j++)
+    {
+        MM_Wait(10);
+
+        Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+
+        if(!(Value32 & MI_COM_BUSY))
+        {
+            Value32 &= MI_COM_PHY_DATA_MASK;
+            break;
+        }
+    }
+
+    if(Value32 & MI_COM_BUSY)
+    {
+        Value32 = 0;
+    }
+
+    *pData32 = Value32;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+        MM_Wait(40);
+    }
+} /* LM_ReadPhy */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_WritePhy(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 PhyReg,
+LM_UINT32 Data32) {
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode &
+            ~MI_MODE_AUTO_POLLING_ENABLE);
+        MM_Wait(40);
+    }
+
+    Value32 = (pDevice->PhyAddr << MI_COM_FIRST_PHY_ADDR_BIT) |
+        ((PhyReg & MI_COM_PHY_REG_ADDR_MASK) << MI_COM_FIRST_PHY_REG_ADDR_BIT) |
+        (Data32 & MI_COM_PHY_DATA_MASK) | MI_COM_CMD_WRITE | MI_COM_START;
+
+    REG_WR(pDevice, MacCtrl.MiCom, Value32);
+    
+    for(j = 0; j < 5000; j++)
+    {
+        MM_Wait(10);
+
+        Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+
+        if(!(Value32 & MI_COM_BUSY))
+        {
+            break;
+        }
+    }
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+        MM_Wait(40);
+    }
+} /* LM_WritePhy */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetPowerState(
+PLM_DEVICE_BLOCK pDevice,
+LM_POWER_STATE PowerLevel) {
+    LM_UINT32 PmeSupport;
+    LM_UINT32 Value32;
+    LM_UINT32 PmCtrl;
+
+    DbgMessage(INFORM, ("### LM_SetPowerState\n"));
+
+    /* make sureindirect accesses are enabled*/
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, pDevice->MiscHostCtrl);
+
+    /* Clear the PME_ASSERT bit and the power state bits.  Also enable */
+    /* the PME bit. */
+    MM_ReadConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, &PmCtrl);
+    DbgMessage(INFORM, ("PmCtrl = 0x%x\n", PmCtrl));
+
+    PmCtrl |= T3_PM_PME_ASSERTED;
+    PmCtrl &= ~T3_PM_POWER_STATE_MASK;
+
+    /* Set the appropriate power state. */
+    if(PowerLevel == LM_POWER_STATE_D0)
+    {
+        DbgMessage(INFORM, ("We're in D0 state.\n"));
+
+        /* Bring the card out of low power mode. */
+        PmCtrl |= T3_PM_POWER_STATE_D0;
+        MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, PmCtrl);
+
+        REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl);
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x02);
+
+        return LM_STATUS_SUCCESS;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D1)
+    {
+        DbgMessage(INFORM, ("We're in D1 state.\n"));
+        PmCtrl |= T3_PM_POWER_STATE_D1;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D2)
+    {
+        DbgMessage(INFORM, ("We're in D2 state.\n"));
+        PmCtrl |= T3_PM_POWER_STATE_D2;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D3)
+    {
+        DbgMessage(INFORM, ("We're in D3 state.\n"));
+        PmCtrl |= T3_PM_POWER_STATE_D3;
+    }
+    else
+    {
+        DbgMessage(FATAL, ("Unknown power level.\n"));
+
+        return LM_STATUS_FAILURE;
+    }
+    PmCtrl |= T3_PM_PME_ENABLE;
+
+#if 0
+    /* No WOL. */
+    if(pDevice->WakeUpModeCap == LM_WAKE_UP_MODE_NONE)
+    {
+        DbgMessage(INFORM, ("No power capabilities.\n"));
+        return LM_STATUS_FAILURE;
+    }
+#endif
+
+    /* Mask out all interrupts so LM_SetupPhy won't be called while we are */
+    /* setting new line speed. */
+    Value32 = REG_RD(pDevice, PciCfg.MiscHostCtrl);
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, Value32 | MISC_HOST_CTRL_MASK_PCI_INT);
+
+    if(!pDevice->RestoreOnWakeUp)
+    {
+        pDevice->RestoreOnWakeUp = TRUE;
+        pDevice->WakeUpDisableAutoNeg = pDevice->DisableAutoNeg;
+        pDevice->WakeUpRequestedMediaType = pDevice->RequestedMediaType;
+    }
+
+    /* Force auto-negotiation to 10 line speed. */
+    pDevice->DisableAutoNeg = FALSE;
+    pDevice->RequestedMediaType = LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+    LM_SetupPhy(pDevice);
+
+    /* Put the driver in the initial state, and go through the power down */
+    /* sequence. */
+    LM_Halt(pDevice);
+
+    MM_ReadConfig32(pDevice, T3_PCI_PM_CAP_REG, &PmeSupport);
+
+    if (pDevice->WakeUpModeCap != LM_WAKE_UP_MODE_NONE)
+    {
+
+        /* Enable WOL. */
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x5a);
+        MM_Wait(40);
+
+        Value32 = MAC_MODE_PORT_MODE_MII | MAC_MODE_LINK_POLARITY;
+
+        /* Always enable magic packet wake-up if we have vaux. */
+        if((PmeSupport & T3_PCI_PM_CAP_PME_D3COLD) && 
+            (pDevice->WakeUpModeCap & LM_WAKE_UP_MODE_MAGIC_PACKET))
+        {
+            Value32 |= MAC_MODE_DETECT_MAGIC_PACKET_ENABLE;
+        }
+
+        /* Enable magic packet wake-up. */
+        if(pDevice->WakeUpMode & LM_WAKE_UP_MODE_MAGIC_PACKET)
+        {
+            Value32 |= MAC_MODE_DETECT_MAGIC_PACKET_ENABLE;
+        }
+
+        REG_WR(pDevice, MacCtrl.Mode, Value32);
+
+        /* Enable the receiver. */
+        REG_WR(pDevice, MacCtrl.RxMode, RX_MODE_ENABLE);
+    }
+
+    /* Disable tx/rx clocks, and seletect an alternate clock. */
+    if(pDevice->WolSpeed == WOL_SPEED_100MB)
+    {
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_DISABLE_RX_CLOCK |
+            T3_PCI_DISABLE_TX_CLOCK | T3_PCI_SELECT_ALTERNATE_CLOCK);
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_DISABLE_RX_CLOCK |
+            T3_PCI_DISABLE_TX_CLOCK | T3_PCI_44MHZ_CORE_CLOCK);
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_DISABLE_RX_CLOCK |
+            T3_PCI_DISABLE_TX_CLOCK | T3_PCI_SELECT_ALTERNATE_CLOCK |
+            T3_PCI_44MHZ_CORE_CLOCK);
+    }
+    else
+    {
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_DISABLE_RX_CLOCK |
+            T3_PCI_DISABLE_TX_CLOCK | T3_PCI_SELECT_ALTERNATE_CLOCK |
+            T3_PCI_POWER_DOWN_PCI_PLL133);
+    }
+
+    MM_Wait(40);
+
+    /* Switch adapter to auxilliary power on if we have vaux. */
+    if((PmeSupport & T3_PCI_PM_CAP_PME_D3COLD) &&
+        (pDevice->WakeUpMode != LM_WAKE_UP_MODE_NONE))
+    {
+        REG_WR(pDevice, Grc.LocalCtrl, GRC_MISC_LOCAL_CTRL_GPIO_OE0 |
+            GRC_MISC_LOCAL_CTRL_GPIO_OE1 | GRC_MISC_LOCAL_CTRL_GPIO_OE2 |
+            GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0 |
+            GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1);
+    }
+
+    /* Set the phy to low power mode. */
+    /* Put the the hardware in low power mode. */
+    MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, PmCtrl);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetPowerState */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+static LM_UINT32
+GetPhyAdFlowCntrlSettings(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+
+    Value32 = 0;
+
+    /* Auto negotiation flow control only when autonegotiation is enabled. */
+    if(pDevice->DisableAutoNeg == FALSE ||
+        pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+        pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+    {
+        /* Please refer to Table 28B-3 of the 802.3ab-1999 spec. */
+        if((pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE) ||
+            ((pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE) &&
+            (pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE)))
+        {
+            Value32 |= PHY_AN_AD_PAUSE_CAPABLE;
+        }
+        else if(pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+        {
+            Value32 |= PHY_AN_AD_ASYM_PAUSE;
+        }
+        else if(pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE)
+        {
+            Value32 |= PHY_AN_AD_PAUSE_CAPABLE | PHY_AN_AD_ASYM_PAUSE;
+        }
+    }
+
+    return Value32;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_FAILURE                                                       */
+/*    LM_STATUS_SUCCESS                                                       */
+/*                                                                            */
+/*    If WaitForLink is TRUE, the return code is one of the following.        */
+/*       LM_STATUS_LINK_DOWN                                                  */
+/*       LM_STATUS_LINK_ACTIVE                                                */
+/******************************************************************************/
+static LM_STATUS
+LM_ForceAutoNegBcm540xPhy(
+PLM_DEVICE_BLOCK pDevice, 
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+LM_BOOL WaitForLink)
+{
+    LM_MEDIA_TYPE MediaType;
+    LM_LINE_SPEED LineSpeed;
+    LM_DUPLEX_MODE DuplexMode;
+    LM_UINT32 NewPhyCtrl;
+    LM_STATUS LmStatus;
+    LM_UINT32 Value32;
+    LM_UINT32 Cnt;
+
+    /* Get the interface type, line speed, and duplex mode. */
+    LM_TranslateRequestedMediaType(RequestedMediaType, &MediaType, &LineSpeed,
+        &DuplexMode);
+
+    if (pDevice->RestoreOnWakeUp)
+    {
+        LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+        Value32 = PHY_AN_AD_10BASET_FULL | PHY_AN_AD_10BASET_HALF;
+        if (pDevice->WolSpeed == WOL_SPEED_100MB)
+        {
+            Value32 |= PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+        }
+        Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+        Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+        LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+    }
+    /* Setup the auto-negotiation advertisement register. */
+    else if(LineSpeed == LM_LINE_SPEED_UNKNOWN)
+    {
+        /* Setup the 10/100 Mbps auto-negotiation advertisement register. */
+        Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD |
+            PHY_AN_AD_10BASET_HALF | PHY_AN_AD_10BASET_FULL |
+            PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+        Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+        LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+
+        /* Advertise 1000Mbps */
+        Value32 = BCM540X_AN_AD_1000BASET_HALF | BCM540X_AN_AD_1000BASET_FULL;
+
+#if INCLUDE_5701_AX_FIX
+        /* Bug: workaround for CRC error in gigabit mode when we are in */
+        /* slave mode.  This will force the PHY to operate in */
+        /* master mode. */
+        if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+        {
+            Value32 |= BCM540X_CONFIG_AS_MASTER |
+                BCM540X_ENABLE_CONFIG_AS_MASTER;
+        }
+#endif
+
+        LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+    }
+    else
+    {
+        if(LineSpeed == LM_LINE_SPEED_1000MBPS)
+        {
+            Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = BCM540X_AN_AD_1000BASET_HALF;
+            }
+            else
+            {
+                Value32 = BCM540X_AN_AD_1000BASET_FULL;
+            }
+
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+        }
+        else if(LineSpeed == LM_LINE_SPEED_100MBPS)
+        {
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = PHY_AN_AD_100BASETX_HALF;
+            }
+            else
+            {
+                Value32 = PHY_AN_AD_100BASETX_FULL;
+            }
+
+            Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+        }
+        else if(LineSpeed == LM_LINE_SPEED_10MBPS)
+        {
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = PHY_AN_AD_10BASET_HALF;
+            }
+            else
+            {
+                Value32 = PHY_AN_AD_10BASET_FULL;
+            }
+
+            Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+        }
+    }
+
+    /* Force line speed if auto-negotiation is disabled. */
+    if(pDevice->DisableAutoNeg && LineSpeed != LM_LINE_SPEED_UNKNOWN)
+    {
+        /* This code path is executed only when there is link. */
+        pDevice->MediaType = MediaType;
+        pDevice->LineSpeed = LineSpeed;
+        pDevice->DuplexMode = DuplexMode;
+
+        /* Force line seepd. */
+        NewPhyCtrl = 0;
+        switch(LineSpeed)
+        {
+            case LM_LINE_SPEED_10MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_10MBPS;
+                break;
+            case LM_LINE_SPEED_100MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_100MBPS;
+                break;
+            case LM_LINE_SPEED_1000MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_1000MBPS;
+                break;
+            default:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_1000MBPS;
+                break;
+        }
+
+        if(DuplexMode == LM_DUPLEX_MODE_FULL)
+        {
+            NewPhyCtrl |= PHY_CTRL_FULL_DUPLEX_MODE;
+        }
+
+        /* Don't do anything if the PHY_CTRL is already what we wanted. */
+        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+        if(Value32 != NewPhyCtrl)
+        {
+            /* Temporary bring the link down before forcing line speed. */
+            LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_LOOPBACK_MODE);
+            
+            /* Wait for link to go down. */
+            for(Cnt = 0; Cnt < 15000; Cnt++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+                if(!(Value32 & PHY_STATUS_LINK_PASS))
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+            LM_WritePhy(pDevice, PHY_CTRL_REG, NewPhyCtrl);
+            MM_Wait(40);
+        }
+    }
+    else
+    {
+        LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_AUTO_NEG_ENABLE |
+            PHY_CTRL_RESTART_AUTO_NEG);
+    }
+
+    /* Wait for link. */
+    LmStatus = LM_STATUS_SUCCESS;
+    if(WaitForLink)
+    {
+        LmStatus = LM_STATUS_LINK_DOWN;
+
+        /* Wait for link up to 3 seconds. */
+        for(Cnt = 0; Cnt < 300000; Cnt++)
+        {
+            MM_Wait(10);
+
+            /* Get the current PHY status. */
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+            /* Link ok? */
+            if(Value32 & PHY_STATUS_LINK_PASS)
+            {
+                LmStatus = LM_STATUS_LINK_ACTIVE;
+                pDevice->MediaType = LM_MEDIA_TYPE_UTP;
+
+                /* Determine the current line and duplex settings. */
+                LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+                LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+
+                switch(Value32 & BCM540X_AUX_SPEED_MASK)
+                {
+                    case BCM540X_AUX_10BASET_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_10MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_10BASET_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_10MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    case BCM540X_AUX_100BASETX_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_100MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_100BASETX_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_100MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    case BCM540X_AUX_100BASET_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_100BASET_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    default:
+                        LmStatus = LM_STATUS_LINK_DOWN;
+                        break;
+                }
+
+                break;
+            }
+        }
+
+        /* Acknowledge interrupts. */
+        LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+    }
+
+    return LmStatus;
+} /* LM_ForceAutoNegBcm540xPhy */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+static LM_STATUS
+LM_ForceAutoNeg(
+PLM_DEVICE_BLOCK pDevice, 
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+LM_BOOL WaitForLink) {
+    LM_STATUS LmStatus;
+
+    /* Initialize the phy chip. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+        case PHY_BCM5401_PHY_ID:
+        case PHY_BCM5411_PHY_ID:
+        case PHY_BCM5701_PHY_ID:
+            LmStatus = LM_ForceAutoNegBcm540xPhy(pDevice, RequestedMediaType, 
+                WaitForLink);
+            break;
+
+        default:
+            LmStatus = LM_STATUS_FAILURE;
+            break;
+    }
+
+    return LmStatus;
+} /* LM_ForceAutoNeg */
+
+
+int
+LM_BlinkLED(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlinkDurationSec)
+{
+	LM_UINT32 Oldcfg;
+	int j;
+	int ret = 0;
+
+	if(BlinkDurationSec == 0)
+	{
+		return 0;
+        }
+	if(BlinkDurationSec > 120)
+        {
+	        BlinkDurationSec = 120;
+	}
+
+	Oldcfg = REG_RD(pDevice, MacCtrl.LedCtrl);
+	for(j = 0; j < BlinkDurationSec * 2; j++)
+	{
+		if(j % 2)
+		{
+			// Turn on the LEDs.
+			REG_WR(pDevice, MacCtrl.LedCtrl,
+				LED_CTRL_OVERRIDE_LINK_LED |
+				LED_CTRL_1000MBPS_LED_ON |
+				LED_CTRL_100MBPS_LED_ON |
+				LED_CTRL_10MBPS_LED_ON |
+				LED_CTRL_OVERRIDE_TRAFFIC_LED |
+				LED_CTRL_BLINK_TRAFFIC_LED |
+				LED_CTRL_TRAFFIC_LED);
+		}
+		else
+		{
+			// Turn off the LEDs.
+			REG_WR(pDevice, MacCtrl.LedCtrl,
+				LED_CTRL_OVERRIDE_LINK_LED |
+				LED_CTRL_OVERRIDE_TRAFFIC_LED);
+		}
+		current->state = TASK_INTERRUPTIBLE;
+		if (schedule_timeout(HZ/2) != 0) {
+			ret = -EINTR;
+			break;
+		}
+	}
+	REG_WR(pDevice, MacCtrl.LedCtrl, Oldcfg);
+	return ret;
+}
+
+int t3_do_dma(PLM_DEVICE_BLOCK pDevice, 
+                   LM_PHYSICAL_ADDRESS host_addr_phy, int length,
+                   int dma_read)
+{
+    T3_DMA_DESC dma_desc;
+    int i;
+    LM_UINT32 dma_desc_addr;
+    LM_UINT32 value32;
+
+    REG_WR(pDevice, BufMgr.Mode, 0);
+    REG_WR(pDevice, Ftq.Reset, 0);
+
+    dma_desc.host_addr.High = host_addr_phy.High;
+    dma_desc.host_addr.Low = host_addr_phy.Low;
+    dma_desc.nic_mbuf = 0x2100;
+    dma_desc.len = length;
+    dma_desc.flags = 0x00000004; /* Generate Rx-CPU event */
+
+    if (dma_read)
+    {
+        dma_desc.cqid_sqid = (T3_QID_RX_BD_COMP << 8) |
+            T3_QID_DMA_HIGH_PRI_READ;
+        REG_WR(pDevice, DmaRead.Mode, DMA_READ_MODE_ENABLE);
+    }
+    else
+    {
+        dma_desc.cqid_sqid = (T3_QID_RX_DATA_COMP << 8) |
+            T3_QID_DMA_HIGH_PRI_WRITE;
+        REG_WR(pDevice, DmaWrite.Mode, DMA_WRITE_MODE_ENABLE);
+    }
+
+    dma_desc_addr = T3_NIC_DMA_DESC_POOL_ADDR;
+
+    /* Writing this DMA descriptor to DMA memory */
+    for (i = 0; i < sizeof(T3_DMA_DESC); i += 4)
+    {
+        value32 = *((PLM_UINT32) (((PLM_UINT8) &dma_desc) + i));
+        MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, dma_desc_addr+i);
+        MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, value32);
+    }
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, 0);
+
+    if (dma_read)
+        REG_WR(pDevice, Ftq.DmaHighReadFtqFifoEnqueueDequeue, dma_desc_addr);
+    else
+        REG_WR(pDevice, Ftq.DmaHighWriteFtqFifoEnqueueDequeue, dma_desc_addr);
+
+    for (i = 0; i < 20; i++)
+    {
+        if (dma_read)
+            value32 = REG_RD(pDevice, Ftq.RcvBdCompFtqFifoEnqueueDequeue);
+        else
+            value32 = REG_RD(pDevice, Ftq.RcvDataCompFtqFifoEnqueueDequeue);
+        if ((value32 & 0xffff) == dma_desc_addr)
+            break;
+
+        MM_Wait(1);
+    }
+
+    return ((i == 20) ? LM_STATUS_FAILURE : LM_STATUS_SUCCESS);
+}
+
+STATIC LM_STATUS
+LM_DmaTest(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pBufferVirt,
+           LM_PHYSICAL_ADDRESS BufferPhy, LM_UINT32 BufferSize)
+{
+    int j;
+    LM_UINT32 *ptr;
+    int dma_success = 0;
+
+    REG_WR(pDevice, PciCfg.ClockCtrl, 0);
+    /* Program DMA Read/Write */
+    if (pDevice->PciState & T3_PCI_STATE_NOT_PCI_X_BUS)
+    {
+        pDevice->DmaReadWriteCtrl = 0x763f000f;    
+    }
+    else
+    {
+        pDevice->DmaReadWriteCtrl = 0x761b000f;    
+    }
+    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl, pDevice->DmaReadWriteCtrl);
+
+    while (!dma_success)
+    {
+        /* Fill data with incremental patterns */
+        ptr = (LM_UINT32 *)pBufferVirt;
+        for (j = 0; j < BufferSize/4; j++)
+            *ptr++ = j;
+
+        if (t3_do_dma(pDevice,BufferPhy,BufferSize, 1) == LM_STATUS_FAILURE)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        MM_Wait(40);
+        ptr = (LM_UINT32 *)pBufferVirt;
+        /* Fill data with zero */
+        for (j = 0; j < BufferSize/4; j++)
+            *ptr++ = 0;
+
+        if (t3_do_dma(pDevice,BufferPhy,BufferSize, 0) == LM_STATUS_FAILURE)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        MM_Wait(40);
+        /* Check for data */
+        ptr = (LM_UINT32 *)pBufferVirt;
+        for (j = 0; j < BufferSize/4; j++)
+        {
+            if (*ptr++ != j)
+            {
+                if ((pDevice->DmaReadWriteCtrl & DMA_CTRL_WRITE_BOUNDARY_MASK)
+                    == DMA_CTRL_WRITE_BOUNDARY_DISABLE)
+                {
+                    pDevice->DmaReadWriteCtrl = (pDevice->DmaReadWriteCtrl &
+                         ~DMA_CTRL_WRITE_BOUNDARY_MASK) |
+                          DMA_CTRL_WRITE_BOUNDARY_16;
+                    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl,
+                           pDevice->DmaReadWriteCtrl);
+                    break;
+                 }
+                 else
+                 {
+                     return LM_STATUS_FAILURE;
+                 }
+            }
+        }
+        if (j == (BufferSize/4))
+            dma_success = 1;
+    }
+    return LM_STATUS_SUCCESS;
+}
diff -urN linux.orig/drivers/net/bcm/tigon3.h linux/drivers/net/bcm/tigon3.h
--- linux.orig/drivers/net/bcm/tigon3.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/tigon3.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,3169 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*                                                                            */
+/******************************************************************************/
+
+#ifndef TIGON3_H
+#define TIGON3_H
+
+#include "lm.h"
+#if INCLUDE_TBI_SUPPORT
+#include "autoneg.h"
+#endif
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+/* Maxim number of packet descriptors used for sending packets. */
+#define MAX_TX_PACKET_DESC_COUNT            600
+#define DEFAULT_TX_PACKET_DESC_COUNT        100
+
+/* Maximum number of packet descriptors used for receiving packets. */
+#if T3_JUMBO_RCB_ENTRY_COUNT
+#define MAX_RX_PACKET_DESC_COUNT                                            \
+    (T3_STD_RCV_RCB_ENTRY_COUNT + T3_JUMBO_RCV_RCB_ENTRY_COUNT)
+#else
+#define MAX_RX_PACKET_DESC_COUNT            800
+#endif
+#define DEFAULT_RX_PACKET_DESC_COUNT        200
+
+/* Threshhold for double copying small tx packets.  0 will disable double */
+/* copying of small Tx packets. */
+#define DEFAULT_TX_COPY_BUFFER_SIZE         0
+#define MIN_TX_COPY_BUFFER_SIZE             64 
+#define MAX_TX_COPY_BUFFER_SIZE             512
+
+/* Cache line. */
+#define COMMON_CACHE_LINE_SIZE              0x20
+#define COMMON_CACHE_LINE_MASK              (COMMON_CACHE_LINE_SIZE-1)
+
+/* Maximum number of fragment we can handle. */
+#ifndef MAX_FRAGMENT_COUNT
+#define MAX_FRAGMENT_COUNT                  32
+#endif
+
+/* B0 bug. */
+#define BCM5700_BX_MIN_FRAG_SIZE            10
+#define BCM5700_BX_MIN_FRAG_BUF_SIZE        16  /* nice aligned size. */
+#define BCM5700_BX_MIN_FRAG_BUF_SIZE_MASK   (BCM5700_BX_MIN_FRAG_BUF_SIZE-1)
+#define BCM5700_BX_TX_COPY_BUF_SIZE         (BCM5700_BX_MIN_FRAG_BUF_SIZE * \
+                                            MAX_FRAGMENT_COUNT)
+
+/* MAGIC number. */
+//#define T3_MAGIC_NUM                        'KevT'
+#define T3_FIRMWARE_MAILBOX                0x0b50
+#define T3_MAGIC_NUM                       0x4B657654 
+#define T3_MAGIC_NUM_DISABLE_DMAW_ON_LINK_CHANGE 0x4861764b
+
+#define T3_NIC_DATA_SIG_ADDR               0x0b54
+#define T3_NIC_DATA_SIG                    0x4b657654
+
+#define T3_NIC_DATA_NIC_CFG_ADDR           0x0b58
+#define T3_NIC_CFG_PHY_TYPE_MASK           0x0000000c
+#define T3_NIC_CFG_PHY_TYPE_UNKNOWN        0x00000000
+#define T3_NIC_CFG_PHY_TYPE_COPPER         0x00000004
+#define T3_NIC_CFG_PHY_TYPE_FIBER          0x00000008
+#define T3_NIC_CFG_LED_MODE_MASK           0x00000030
+#define T3_NIC_CFG_LED_MODE_UNKNOWN        0x00000000
+#define T3_NIC_CFG_LED_MODE_TRIPLE_SPEED   0x00000010
+#define T3_NIC_CFG_LED_MODE_LINK_SPEED     0x00000020
+
+#define T3_NIC_DATA_PHY_ID_ADDR            0x0b74
+#define T3_NIC_PHY_ID1_MASK                0xffff0000
+#define T3_NIC_PHY_ID2_MASK                0x0000ffff
+
+
+/******************************************************************************/
+/* Hardware constants. */
+/******************************************************************************/
+
+/* Number of entries in the send ring:  must be 512. */
+#define T3_SEND_RCB_ENTRY_COUNT             512     
+#define T3_SEND_RCB_ENTRY_COUNT_MASK        (T3_SEND_RCB_ENTRY_COUNT-1)
+
+/* Number of send RCBs.  May be 1-16 but for now, only support one. */
+#define T3_MAX_SEND_RCB_COUNT               16
+
+/* Number of entries in the Standard Receive RCB.  Must be 512 entries. */
+#define T3_STD_RCV_RCB_ENTRY_COUNT          512
+#define T3_STD_RCV_RCB_ENTRY_COUNT_MASK     (T3_STD_RCV_RCB_ENTRY_COUNT-1)
+#define DEFAULT_STD_RCV_DESC_COUNT          200    /* Must be < 512. */
+#define MAX_STD_RCV_BUFFER_SIZE             0x600
+
+/* Number of entries in the Jumbo Receive RCB.  This value must 256 or 0. */
+/* Currently, Jumbo Receive RCB is disabled. */
+#ifndef T3_JUMBO_RCV_RCB_ENTRY_COUNT
+#define T3_JUMBO_RCV_RCB_ENTRY_COUNT        0
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+#define T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK   (T3_JUMBO_RCV_RCB_ENTRY_COUNT-1)
+
+#define MAX_JUMBO_RCV_BUFFER_SIZE           (10 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_RCV_BUFFER_SIZE       (4 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_RCV_DESC_COUNT        128     /* Must be < 256. */
+
+#define MAX_JUMBO_TX_BUFFER_SIZE            (8 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_TX_BUFFER_SIZE        (4 * 1024) /* > 1514 */
+
+/* Number of receive return RCBs.  Maybe 1-16 but for now, only support one. */
+#define T3_MAX_RCV_RETURN_RCB_COUNT         16
+
+/* Number of entries in a Receive Return ring.  This value is either 1024 */
+/* or 2048. */
+#ifndef T3_RCV_RETURN_RCB_ENTRY_COUNT 
+#define T3_RCV_RETURN_RCB_ENTRY_COUNT       1024
+#endif /* T3_RCV_RETURN_RCB_ENTRY_COUNT */
+#define T3_RCV_RETURN_RCB_ENTRY_COUNT_MASK  (T3_RCV_RETURN_RCB_ENTRY_COUNT-1)
+
+
+/* Default coalescing parameters. */
+#define DEFAULT_RX_COALESCING_TICKS         100
+#define MAX_RX_COALESCING_TICKS             500
+#define DEFAULT_TX_COALESCING_TICKS         500
+#define MAX_TX_COALESCING_TICKS             500
+#define DEFAULT_RX_MAX_COALESCED_FRAMES     10
+#define MAX_RX_MAX_COALESCED_FRAMES         100
+#define ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES    5
+#define ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES    40
+#define ADAPTIVE_LO_RX_COALESCING_TICKS         50
+#define ADAPTIVE_HI_RX_COALESCING_TICKS         300
+#define ADAPTIVE_LO_PKT_THRESH              30000
+#define ADAPTIVE_HI_PKT_THRESH              74000
+#define DEFAULT_TX_MAX_COALESCED_FRAMES     75
+#define MAX_TX_MAX_COALESCED_FRAMES         100
+
+#define DEFAULT_RX_COALESCING_TICKS_DURING_INT          25
+#define DEFAULT_TX_COALESCING_TICKS_DURING_INT          25
+#define DEFAULT_RX_MAX_COALESCED_FRAMES_DURING_INT      5
+#define DEFAULT_TX_MAX_COALESCED_FRAMES_DURING_INT      5
+
+#define BAD_DEFAULT_VALUE                               0xffffffff
+
+#define DEFAULT_STATS_COALESCING_TICKS      1000000
+#define MAX_STATS_COALESCING_TICKS          3600000000U
+
+
+/* Receive BD Replenish thresholds. */
+#define DEFAULT_RCV_STD_BD_REPLENISH_THRESHOLD      4
+#define DEFAULT_RCV_JUMBO_BD_REPLENISH_THRESHOLD    4
+
+
+/* Maximum physical fragment size. */
+#define MAX_FRAGMENT_SIZE                   (64 * 1024)
+
+
+/* Standard view. */
+#define T3_STD_VIEW_SIZE                    (64 * 1024)
+#define T3_FLAT_VIEW_SIZE                   (32 * 1024 * 1024)
+
+
+/* Buffer descriptor base address on the NIC's memory. */
+
+#define T3_NIC_SND_BUFFER_DESC_ADDR         0x4000
+#define T3_NIC_STD_RCV_BUFFER_DESC_ADDR     0x6000
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR   0x7000
+
+#define T3_NIC_SND_BUFFER_DESC_SIZE         (T3_SEND_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_SND_BD) / 4)
+
+#define T3_NIC_STD_RCV_BUFFER_DESC_SIZE     (T3_STD_RCV_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_RCV_BD) / 4)
+
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_SIZE   (T3_JUMBO_RCV_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_EXT_RCV_BD) / 4)
+
+
+/* MBUF pool. */
+#define T3_NIC_MBUF_POOL_ADDR               0x8000
+#define T3_NIC_MBUF_POOL_SIZE               0x18000
+
+/* DMA descriptor pool */
+#define T3_NIC_DMA_DESC_POOL_ADDR           0x2000
+#define T3_NIC_DMA_DESC_POOL_SIZE           0x2000      /* 8KB. */
+
+#define T3_DEF_DMA_MBUF_LOW_WMARK           0x40
+#define T3_DEF_RX_MAC_MBUF_LOW_WMARK        0x20
+#define T3_DEF_MBUF_HIGH_WMARK              0x60
+
+#define T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO     304
+#define T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO  152
+#define T3_DEF_MBUF_HIGH_WMARK_JUMBO        380
+
+#define T3_DEF_DMA_DESC_LOW_WMARK           5
+#define T3_DEF_DMA_DESC_HIGH_WMARK          10
+
+
+
+/******************************************************************************/
+/* Tigon3 PCI Registers. */
+/******************************************************************************/
+#define T3_PCI_ID_BCM5700                   0x164414e4
+#define T3_PCI_ID_BCM5701                   0x164514e4
+#define T3_PCI_ID_BCM5703                   0x164714e4
+
+#define T3_PCI_VENDOR_ID                    (T3_PCI_ID & 0xffff)
+#define T3_PCI_DEVICE_ID                    (T3_PCI_ID >> 16)
+
+#define T3_PCI_MISC_HOST_CTRL_REG           0x68
+
+/* The most significant 16bit of register 0x68. */
+/* ChipId:4, ChipRev:4, MetalRev:8 */
+#define T3_CHIP_ID_5700_A0                  0x7000
+#define T3_CHIP_ID_5700_A1                  0x7001
+#define T3_CHIP_ID_5700_B0                  0x7100
+#define T3_CHIP_ID_5700_B1                  0x7101
+#define T3_CHIP_ID_5700_C0                  0x7200
+
+#define T3_CHIP_ID_5701_A0                  0x0000
+#define T3_CHIP_ID_5701_B0                  0x0100
+#define T3_CHIP_ID_5701_B2                  0x0102
+#define T3_CHIP_ID_5701_B5                  0x0105
+
+/* Chip Id. */
+#define T3_ASIC_REV(_ChipRevId)             ((_ChipRevId) >> 12)
+#define T3_ASIC_REV_5700                    0x07
+#define T3_ASIC_REV_5701                    0x00
+#define T3_ASIC_REV_5703                    0x01
+
+/* Chip id and revision. */
+#define T3_CHIP_REV(_ChipRevId)             ((_ChipRevId) >> 8)
+#define T3_CHIP_REV_5700_AX                 0x70
+#define T3_CHIP_REV_5700_BX                 0x71
+#define T3_CHIP_REV_5700_CX                 0x72
+#define T3_CHIP_REV_5701_AX                 0x00
+
+/* Metal revision. */
+#define T3_METAL_REV(_ChipRevId)            ((_ChipRevId) & 0xff)
+#define T3_METAL_REV_A0                     0x00
+#define T3_METAL_REV_A1                     0x01
+#define T3_METAL_REV_B0                     0x00
+#define T3_METAL_REV_B1                     0x01
+#define T3_METAL_REV_B2                     0x02
+
+#define T3_PCI_REG_CLOCK_CTRL               0x74
+
+#define T3_PCI_DISABLE_RX_CLOCK             BIT_10
+#define T3_PCI_DISABLE_TX_CLOCK             BIT_11
+#define T3_PCI_SELECT_ALTERNATE_CLOCK       BIT_12
+#define T3_PCI_POWER_DOWN_PCI_PLL133        BIT_15
+#define T3_PCI_44MHZ_CORE_CLOCK             BIT_18
+
+
+#define T3_PCI_REG_ADDR_REG                 0x78
+#define T3_PCI_REG_DATA_REG                 0x80
+
+#define T3_PCI_MEM_WIN_ADDR_REG             0x7c
+#define T3_PCI_MEM_WIN_DATA_REG             0x84
+
+#define T3_PCI_PM_CAP_REG                   0x48
+
+#define T3_PCI_PM_CAP_PME_D3COLD            BIT_31
+#define T3_PCI_PM_CAP_PME_D3HOT             BIT_30
+
+#define T3_PCI_PM_STATUS_CTRL_REG           0x4c
+
+#define T3_PM_POWER_STATE_MASK              (BIT_0 | BIT_1)
+#define T3_PM_POWER_STATE_D0                BIT_NONE
+#define T3_PM_POWER_STATE_D1                BIT_0
+#define T3_PM_POWER_STATE_D2                BIT_1
+#define T3_PM_POWER_STATE_D3                (BIT_0 | BIT_1)
+
+#define T3_PM_PME_ENABLE                    BIT_8
+#define T3_PM_PME_ASSERTED                  BIT_15
+
+
+/* PCI state register. */
+#define T3_PCI_STATE_REG                    0x70
+
+#define T3_PCI_STATE_FORCE_RESET            BIT_0
+#define T3_PCI_STATE_INT_NOT_ACTIVE         BIT_1
+#define T3_PCI_STATE_CONVENTIONAL_PCI_MODE  BIT_2
+#define T3_PCI_STATE_BUS_SPEED_HIGH         BIT_3
+#define T3_PCI_STATE_32BIT_PCI_BUS          BIT_4
+
+
+/* Broadcom subsystem/subvendor IDs. */
+#define T3_SVID_BROADCOM                            0x14e4
+
+#define T3_SSID_BROADCOM_BCM95700A6                 0x1644
+#define T3_SSID_BROADCOM_BCM95701A5                 0x0001
+#define T3_SSID_BROADCOM_BCM95700T6                 0x0002  /* BCM8002 */
+#define T3_SSID_BROADCOM_BCM95700A9                 0x0003  /* Agilent */
+#define T3_SSID_BROADCOM_BCM95701T1                 0x0005
+#define T3_SSID_BROADCOM_BCM95701T8                 0x0006
+#define T3_SSID_BROADCOM_BCM95701A7                 0x0007  /* Agilent */
+#define T3_SSID_BROADCOM_BCM95701A10                0x0008
+#define T3_SSID_BROADCOM_BCM95701A12                0x8008
+#define T3_SSID_BROADCOM_BCM95703Ax1                0x0009
+#define T3_SSID_BROADCOM_BCM95703Ax2                0x8009
+
+/* 3COM subsystem/subvendor IDs. */
+#define T3_SVID_3COM                                0x10b7
+
+#define T3_SSID_3COM_3C996T                         0x1000
+#define T3_SSID_3COM_3C996BT                        0x1006
+#define T3_SSID_3COM_3C996CT                        0x1002
+#define T3_SSID_3COM_3C997T                         0x1003
+#define T3_SSID_3COM_3C1000T                        0x1007
+#define T3_SSID_3COM_3C940BR01                      0x1008
+
+/* Fiber boards. */
+#define T3_SSID_3COM_3C996SX                        0x1004
+#define T3_SSID_3COM_3C997SX                        0x1005
+
+
+/* Dell subsystem/subvendor IDs. */
+
+#define T3_SVID_DELL                                0x1028
+
+#define T3_SSID_DELL_VIPER                          0x00d1
+#define T3_SSID_DELL_JAGUAR                         0x0106
+#define T3_SSID_DELL_MERLOT                         0x0109
+#define T3_SSID_DELL_SLIM_MERLOT                    0x010a
+
+/* Compaq subsystem/subvendor IDs */
+
+#define T3_SVID_COMPAQ                              0x0e11
+
+#define T3_SSID_COMPAQ_BANSHEE                      0x007c
+#define T3_SSID_COMPAQ_BANSHEE_2                    0x009a
+#define T3_SSID_COMPAQ_CHANGELING                   0x007d
+#define T3_SSID_COMPAQ_NC7780                       0x0085
+#define T3_SSID_COMPAQ_NC7780_2                     0x0099
+
+
+/******************************************************************************/
+/* MII registers. */
+/******************************************************************************/
+
+/* Control register. */
+#define PHY_CTRL_REG                                0x00
+
+#define PHY_CTRL_SPEED_MASK                         (BIT_6 | BIT_13)
+#define PHY_CTRL_SPEED_SELECT_10MBPS                BIT_NONE
+#define PHY_CTRL_SPEED_SELECT_100MBPS               BIT_13
+#define PHY_CTRL_SPEED_SELECT_1000MBPS              BIT_6
+#define PHY_CTRL_COLLISION_TEST_ENABLE              BIT_7
+#define PHY_CTRL_FULL_DUPLEX_MODE                   BIT_8
+#define PHY_CTRL_RESTART_AUTO_NEG                   BIT_9
+#define PHY_CTRL_ISOLATE_PHY                        BIT_10
+#define PHY_CTRL_LOWER_POWER_MODE                   BIT_11
+#define PHY_CTRL_AUTO_NEG_ENABLE                    BIT_12
+#define PHY_CTRL_LOOPBACK_MODE                      BIT_14
+#define PHY_CTRL_PHY_RESET                          BIT_15
+
+
+/* Status register. */
+#define PHY_STATUS_REG                              0x01
+
+#define PHY_STATUS_LINK_PASS                        BIT_2
+#define PHY_STATUS_AUTO_NEG_COMPLETE                BIT_5
+
+
+/* Phy Id registers. */
+#define PHY_ID1_REG                                 0x02
+#define PHY_ID1_OUI_MASK                            0xffff
+
+#define PHY_ID2_REG                                 0x03
+#define PHY_ID2_REV_MASK                            0x000f
+#define PHY_ID2_MODEL_MASK                          0x03f0
+#define PHY_ID2_OUI_MASK                            0xfc00
+
+
+/* Auto-negotiation advertisement register. */
+#define PHY_AN_AD_REG                               0x04
+
+#define PHY_AN_AD_ASYM_PAUSE                        BIT_11
+#define PHY_AN_AD_PAUSE_CAPABLE                     BIT_10
+#define PHY_AN_AD_10BASET_HALF                      BIT_5
+#define PHY_AN_AD_10BASET_FULL                      BIT_6
+#define PHY_AN_AD_100BASETX_HALF                    BIT_7
+#define PHY_AN_AD_100BASETX_FULL                    BIT_8
+#define PHY_AN_AD_PROTOCOL_802_3_CSMA_CD            0x01
+
+
+/* Auto-negotiation Link Partner Ability register. */
+#define PHY_LINK_PARTNER_ABILITY_REG                0x05
+
+#define PHY_LINK_PARTNER_ASYM_PAUSE                 BIT_11
+#define PHY_LINK_PARTNER_PAUSE_CAPABLE              BIT_10
+
+
+/* Auto-negotiation expansion register. */
+#define PHY_AN_EXPANSION_REG                        0x06
+
+
+
+/******************************************************************************/
+/* BCM5400 and BCM5401 phy info. */
+/******************************************************************************/
+
+#define PHY_DEVICE_ID           1
+
+/* OUI: bit 31-10;   Model#: bit 9-4;   Rev# bit 3-0. */
+#define PHY_UNKNOWN_PHY                             0x00000000
+#define PHY_BCM5400_PHY_ID                          0x60008040
+#define PHY_BCM5401_PHY_ID                          0x60008050
+#define PHY_BCM5411_PHY_ID                          0x60008070
+#define PHY_BCM5701_PHY_ID                          0x60008110
+#define PHY_BCM8002_PHY_ID                          0x60010140
+
+#define PHY_BCM5401_B0_REV                          0x1
+#define PHY_BCM5401_B2_REV                          0x3
+#define PHY_BCM5401_C0_REV                          0x6
+
+#define PHY_ID_OUI_MASK                             0xfffffc00
+#define PHY_ID_MODEL_MASK                           0x000003f0
+#define PHY_ID_REV_MASK                             0x0000000f
+#define PHY_ID_MASK                                 (PHY_ID_OUI_MASK |      \
+                                                    PHY_ID_MODEL_MASK)
+
+
+#define UNKNOWN_PHY_ID(x)   ((((x) & PHY_ID_MASK) != PHY_BCM5400_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5401_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5411_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5701_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM8002_PHY_ID))
+
+
+
+/* 1000Base-T control register. */
+#define BCM540X_1000BASET_CTRL_REG                  0x09
+
+#define BCM540X_AN_AD_1000BASET_HALF                BIT_8
+#define BCM540X_AN_AD_1000BASET_FULL                BIT_9
+#define BCM540X_CONFIG_AS_MASTER                    BIT_11
+#define BCM540X_ENABLE_CONFIG_AS_MASTER             BIT_12
+
+
+/* Extended control register. */
+#define BCM540X_EXT_CTRL_REG                        0x10
+
+#define BCM540X_EXT_CTRL_LINK3_LED_MODE             BIT_1
+#define BCM540X_EXT_CTRL_TBI                        BIT_15
+
+
+/* DSP Coefficient Read/Write Port. */
+#define BCM540X_DSP_RW_PORT                         0x15
+
+
+/* DSP Coeficient Address Register. */
+#define BCM540X_DSP_ADDRESS_REG                     0x17
+
+#define BCM540X_DSP_TAP_NUMBER_MASK                 0x00
+#define BCM540X_DSP_AGC_A                           0x00
+#define BCM540X_DSP_AGC_B                           0x01
+#define BCM540X_DSP_MSE_PAIR_STATUS                 0x02
+#define BCM540X_DSP_SOFT_DECISION                   0x03
+#define BCM540X_DSP_PHASE_REG                       0x04
+#define BCM540X_DSP_SKEW                            0x05
+#define BCM540X_DSP_POWER_SAVER_UPPER_BOUND         0x06
+#define BCM540X_DSP_POWER_SAVER_LOWER_BOUND         0x07
+#define BCM540X_DSP_LAST_ECHO                       0x08
+#define BCM540X_DSP_FREQUENCY                       0x09
+#define BCM540X_DSP_PLL_BANDWIDTH                   0x0a
+#define BCM540X_DSP_PLL_PHASE_OFFSET                0x0b
+
+#define BCM540X_DSP_FILTER_DCOFFSET                 (BIT_10 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT3                    (BIT_8 | BIT_9 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT2                    (BIT_9 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT1                    (BIT_8 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT0                    BIT_11
+#define BCM540X_DSP_FILTER_NEXT3                    (BIT_8 | BIT_9 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT2                    (BIT_9 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT1                    (BIT_8 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT0                    BIT_10
+#define BCM540X_DSP_FILTER_ECHO                     (BIT_8 | BIT_9)
+#define BCM540X_DSP_FILTER_DFE                      BIT_9
+#define BCM540X_DSP_FILTER_FFE                      BIT_8
+
+#define BCM540X_DSP_CONTROL_ALL_FILTERS             BIT_12
+
+#define BCM540X_DSP_SEL_CH_0                        BIT_NONE
+#define BCM540X_DSP_SEL_CH_1                        BIT_13
+#define BCM540X_DSP_SEL_CH_2                        BIT_14
+#define BCM540X_DSP_SEL_CH_3                        (BIT_13 | BIT_14)
+
+#define BCM540X_CONTROL_ALL_CHANNELS                BIT_15
+
+
+/* Auxilliary Control Register (Shadow Register) */
+#define BCM5401_AUX_CTRL                            0x18
+
+#define BCM5401_SHADOW_SEL_MASK                     0x7
+#define BCM5401_SHADOW_SEL_NORMAL                   0x00
+#define BCM5401_SHADOW_SEL_10BASET                  0x01
+#define BCM5401_SHADOW_SEL_POWER_CONTROL            0x02
+#define BCM5401_SHADOW_SEL_IP_PHONE                 0x03
+#define BCM5401_SHADOW_SEL_MISC_TEST1               0x04
+#define BCM5401_SHADOW_SEL_MISC_TEST2               0x05
+#define BCM5401_SHADOW_SEL_IP_PHONE_SEED            0x06
+
+
+/* Shadow register selector == '000' */
+#define BCM5401_SHDW_NORMAL_DIAG_MODE               BIT_3
+#define BCM5401_SHDW_NORMAL_DISABLE_MBP             BIT_4
+#define BCM5401_SHDW_NORMAL_DISABLE_LOW_PWR         BIT_5
+#define BCM5401_SHDW_NORMAL_DISABLE_INV_PRF         BIT_6
+#define BCM5401_SHDW_NORMAL_DISABLE_PRF             BIT_7
+#define BCM5401_SHDW_NORMAL_RX_SLICING_NORMAL       BIT_NONE
+#define BCM5401_SHDW_NORMAL_RX_SLICING_4D           BIT_8
+#define BCM5401_SHDW_NORMAL_RX_SLICING_3LVL_1D      BIT_9
+#define BCM5401_SHDW_NORMAL_RX_SLICING_5LVL_1D      (BIT_8 | BIT_9)
+#define BCM5401_SHDW_NORMAL_TX_6DB_CODING           BIT_10
+#define BCM5401_SHDW_NORMAL_ENABLE_SM_DSP_CLOCK     BIT_11
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_4NS       BIT_NONE
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_5NS       BIT_12
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_3NS       BIT_13
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_0NS       (BIT_12 | BIT_13)
+#define BCM5401_SHDW_NORMAL_EXT_PACKET_LENGTH       BIT_14
+#define BCM5401_SHDW_NORMAL_EXTERNAL_LOOPBACK       BIT_15
+
+
+/* Auxilliary status summary. */
+#define BCM540X_AUX_STATUS_REG                      0x19
+
+#define BCM540X_AUX_LINK_PASS                       BIT_2
+#define BCM540X_AUX_SPEED_MASK                      (BIT_8 | BIT_9 | BIT_10)
+#define BCM540X_AUX_10BASET_HD                      BIT_8
+#define BCM540X_AUX_10BASET_FD                      BIT_9
+#define BCM540X_AUX_100BASETX_HD                    (BIT_8 | BIT_9)
+#define BCM540X_AUX_100BASET4                       BIT_10
+#define BCM540X_AUX_100BASETX_FD                    (BIT_8 | BIT_10)
+#define BCM540X_AUX_100BASET_HD                     (BIT_9 | BIT_10)
+#define BCM540X_AUX_100BASET_FD                     (BIT_8 | BIT_9 | BIT_10)
+
+
+/* Interrupt status. */
+#define BCM540X_INT_STATUS_REG                      0x1a
+
+#define BCM540X_INT_LINK_CHANGE                     BIT_1
+#define BCM540X_INT_SPEED_CHANGE                    BIT_2
+#define BCM540X_INT_DUPLEX_CHANGE                   BIT_3
+#define BCM540X_INT_AUTO_NEG_PAGE_RX                BIT_10
+
+
+/* Interrupt mask register. */
+#define BCM540X_INT_MASK_REG                        0x1b
+
+
+
+/******************************************************************************/
+/* Register definitions. */
+/******************************************************************************/
+
+typedef volatile LM_UINT8 T3_8BIT_REGISTER, *PT3_8BIT_REGISTER;
+typedef volatile LM_UINT16 T3_16BIT_REGISTER, *PT3_16BIT_REGISTER;
+typedef volatile LM_UINT32 T3_32BIT_REGISTER, *PT3_32BIT_REGISTER;
+
+typedef struct {
+    /* Big endian format. */
+    T3_32BIT_REGISTER High;
+    T3_32BIT_REGISTER Low;
+} T3_64BIT_REGISTER, *PT3_64BIT_REGISTER;
+
+typedef T3_64BIT_REGISTER T3_64BIT_HOST_ADDR, *PT3_64BIT_HOST_ADDR;
+
+#define T3_NUM_OF_DMA_DESC    256
+#define T3_NUM_OF_MBUF        768
+
+typedef struct 
+{
+  T3_64BIT_REGISTER host_addr;
+  T3_32BIT_REGISTER nic_mbuf;
+  T3_16BIT_REGISTER len;
+  T3_16BIT_REGISTER cqid_sqid;
+  T3_32BIT_REGISTER flags;
+  T3_32BIT_REGISTER opaque1;
+  T3_32BIT_REGISTER opaque2;
+  T3_32BIT_REGISTER opaque3;
+}T3_DMA_DESC, *PT3_DMA_DESC;
+
+
+
+/******************************************************************************/
+/* Ring control block. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_REGISTER HostRingAddr;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            T3_16BIT_REGISTER MaxLen;
+            T3_16BIT_REGISTER Flags;
+#else /* BIG_ENDIAN_HOST */
+            T3_16BIT_REGISTER Flags;
+            T3_16BIT_REGISTER MaxLen;
+#endif
+        } s;
+
+        T3_32BIT_REGISTER MaxLen_Flags;
+    } u;
+
+    T3_32BIT_REGISTER NicRingAddr;
+} T3_RCB, *PT3_RCB;
+
+#define T3_RCB_FLAG_USE_EXT_RECV_BD                     BIT_0
+#define T3_RCB_FLAG_RING_DISABLED                       BIT_1
+
+
+
+/******************************************************************************/
+/* Status block. */
+/******************************************************************************/
+
+/* 
+ * Size of status block is actually 0x50 bytes.  Use 0x80 bytes for
+ * cache line alignment. 
+ */
+#define T3_STATUS_BLOCK_SIZE                                    0x80
+
+typedef struct {
+    volatile LM_UINT32 Status;
+    #define STATUS_BLOCK_UPDATED                                BIT_0
+    #define STATUS_BLOCK_LINK_CHANGED_STATUS                    BIT_1
+    #define STATUS_BLOCK_ERROR                                  BIT_2
+
+    volatile LM_UINT32 StatusTag;
+
+#ifdef BIG_ENDIAN_HOST
+    volatile LM_UINT16 RcvStdConIdx;
+    volatile LM_UINT16 RcvJumboConIdx;
+
+    volatile LM_UINT16 Reserved2;
+    volatile LM_UINT16 RcvMiniConIdx;
+
+    struct {
+        volatile LM_UINT16 SendConIdx;   /* Send consumer index. */
+        volatile LM_UINT16 RcvProdIdx;   /* Receive producer index. */
+    } Idx[16];
+#else /* BIG_ENDIAN_HOST */
+    volatile LM_UINT16 RcvJumboConIdx;
+    volatile LM_UINT16 RcvStdConIdx;
+
+    volatile LM_UINT16 RcvMiniConIdx;
+    volatile LM_UINT16 Reserved2;
+
+    struct {
+        volatile LM_UINT16 RcvProdIdx;   /* Receive producer index. */
+        volatile LM_UINT16 SendConIdx;   /* Send consumer index. */
+    } Idx[16];
+#endif
+} T3_STATUS_BLOCK, *PT3_STATUS_BLOCK;
+
+
+
+/******************************************************************************/
+/* Receive buffer descriptors. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr;
+
+#ifdef BIG_ENDIAN_HOST
+    volatile LM_UINT16 Index;
+    volatile LM_UINT16 Len;
+
+    volatile LM_UINT16 Type;
+    volatile LM_UINT16 Flags;
+
+    volatile LM_UINT16 IpCksum;
+    volatile LM_UINT16 TcpUdpCksum;
+
+    volatile LM_UINT16 ErrorFlag;
+    volatile LM_UINT16 VlanTag;
+#else /* BIG_ENDIAN_HOST */
+    volatile LM_UINT16 Len;
+    volatile LM_UINT16 Index;
+
+    volatile LM_UINT16 Flags;
+    volatile LM_UINT16 Type;
+
+    volatile LM_UINT16 TcpUdpCksum;
+    volatile LM_UINT16 IpCksum;
+
+    volatile LM_UINT16 VlanTag;
+    volatile LM_UINT16 ErrorFlag;
+#endif
+
+    volatile LM_UINT32 Reserved;
+    volatile LM_UINT32 Opaque;
+} T3_RCV_BD, *PT3_RCV_BD;
+
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr[3];
+
+#ifdef BIG_ENDIAN_HOST
+    LM_UINT16 Len1;
+    LM_UINT16 Len2;
+
+    LM_UINT16 Len3;
+    LM_UINT16 Reserved1;
+#else /* BIG_ENDIAN_HOST */
+    LM_UINT16 Len2;
+    LM_UINT16 Len1;
+
+    LM_UINT16 Reserved1;
+    LM_UINT16 Len3;
+#endif
+
+    T3_RCV_BD StdRcvBd;
+} T3_EXT_RCV_BD, *PT3_EXT_RCV_BD;
+
+
+/* Error flags. */
+#define RCV_BD_ERR_BAD_CRC                          0x0001
+#define RCV_BD_ERR_COLL_DETECT                      0x0002
+#define RCV_BD_ERR_LINK_LOST_DURING_PKT             0x0004
+#define RCV_BD_ERR_PHY_DECODE_ERR                   0x0008
+#define RCV_BD_ERR_ODD_NIBBLED_RCVD_MII             0x0010
+#define RCV_BD_ERR_MAC_ABORT                        0x0020
+#define RCV_BD_ERR_LEN_LT_64                        0x0040
+#define RCV_BD_ERR_TRUNC_NO_RESOURCES               0x0080
+#define RCV_BD_ERR_GIANT_FRAME_RCVD                 0x0100
+
+
+/* Buffer descriptor flags. */
+#define RCV_BD_FLAG_END                             0x0004
+#define RCV_BD_FLAG_JUMBO_RING                      0x0020
+#define RCV_BD_FLAG_VLAN_TAG                        0x0040
+#define RCV_BD_FLAG_FRAME_HAS_ERROR                 0x0400
+#define RCV_BD_FLAG_IP_CHKSUM_FIELD                 0x1000
+#define RCV_BD_FLAG_TCP_UDP_CHKSUM_FIELD            0x2000
+#define RCV_BD_FLAG_TCP_PACKET                      0x4000
+
+
+
+/******************************************************************************/
+/* Send buffer descriptor. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            LM_UINT16 Len;
+            LM_UINT16 Flags;
+#else /* BIG_ENDIAN_HOST */
+            LM_UINT16 Flags;
+            LM_UINT16 Len;
+#endif
+        } s1;
+
+        LM_UINT32 Len_Flags;
+    } u1;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            LM_UINT16 Reserved;
+            LM_UINT16 VlanTag;
+#else /* BIG_ENDIAN_HOST */
+            LM_UINT16 VlanTag;
+            LM_UINT16 Reserved;
+#endif
+        } s2;
+
+        LM_UINT32 VlanTag;
+    } u2;
+} T3_SND_BD, *PT3_SND_BD;
+
+
+/* Send buffer descriptor flags. */
+#define SND_BD_FLAG_TCP_UDP_CKSUM                   0x0001
+#define SND_BD_FLAG_IP_CKSUM                        0x0002
+#define SND_BD_FLAG_END                             0x0004
+#define SND_BD_FLAG_IP_FRAG                         0x0008
+#define SND_BD_FLAG_IP_FRAG_END                     0x0010
+#define SND_BD_FLAG_VLAN_TAG                        0x0040
+#define SND_BD_FLAG_COAL_NOW                        0x0080
+#define SND_BD_FLAG_CPU_PRE_DMA                     0x0100
+#define SND_BD_FLAG_CPU_POST_DMA                    0x0200
+#define SND_BD_FLAG_INSERT_SRC_ADDR                 0x1000
+#define SND_BD_FLAG_CHOOSE_SRC_ADDR                 0x6000
+#define SND_BD_FLAG_DONT_GEN_CRC                    0x8000
+
+/* MBUFs */
+typedef struct T3_MBUF_FRAME_DESC {
+#ifdef BIG_ENDIAN_HOST
+  LM_UINT32 status_control;
+  union {
+    struct {
+      LM_UINT8 cqid;
+      LM_UINT8 reserved1;
+      LM_UINT16 length;
+    }s1;
+    LM_UINT32 word;
+  }u1;
+  union {
+    struct 
+    {
+      LM_UINT16 ip_hdr_start;
+      LM_UINT16 tcp_udp_hdr_start;
+    }s2;
+
+    LM_UINT32 word;
+  }u2;
+
+  union {
+    struct {
+      LM_UINT16 data_start;
+      LM_UINT16 vlan_id;
+    }s3;
+    
+    LM_UINT32 word;
+  }u3;
+
+  union {
+    struct {
+      LM_UINT16 ip_checksum;
+      LM_UINT16 tcp_udp_checksum;
+    }s4;
+
+    LM_UINT32 word;
+  }u4;
+
+  union {
+    struct {
+      LM_UINT16 pseudo_checksum;
+      LM_UINT16 checksum_status;
+    }s5;
+
+    LM_UINT32 word;
+  }u5;
+  
+  union {
+    struct {
+      LM_UINT16 rule_match;
+      LM_UINT8 class;
+      LM_UINT8 rupt;
+    }s6;
+
+    LM_UINT32 word;
+  }u6;
+
+  union {
+    struct {
+      LM_UINT16 reserved2;
+      LM_UINT16 mbuf_num;
+    }s7;
+
+    LM_UINT32 word;
+  }u7;
+
+  LM_UINT32 reserved3;
+  LM_UINT32 reserved4;
+#else
+  LM_UINT32 status_control;
+  union {
+    struct {
+      LM_UINT16 length;
+      LM_UINT8  reserved1;
+      LM_UINT8  cqid;
+    }s1;
+    LM_UINT32 word;
+  }u1;
+  union {
+    struct 
+    {
+      LM_UINT16 tcp_udp_hdr_start;
+      LM_UINT16 ip_hdr_start;
+    }s2;
+
+    LM_UINT32 word;
+  }u2;
+
+  union {
+    struct {
+      LM_UINT16 vlan_id;
+      LM_UINT16 data_start;
+    }s3;
+    
+    LM_UINT32 word;
+  }u3;
+
+  union {
+    struct {
+      LM_UINT16 tcp_udp_checksum;
+      LM_UINT16 ip_checksum;
+    }s4;
+
+    LM_UINT32 word;
+  }u4;
+
+  union {
+    struct {
+      LM_UINT16 checksum_status;
+      LM_UINT16 pseudo_checksum;
+    }s5;
+
+    LM_UINT32 word;
+  }u5;
+  
+  union {
+    struct {
+      LM_UINT8 rupt;
+      LM_UINT8 class;
+      LM_UINT16 rule_match;
+    }s6;
+
+    LM_UINT32 word;
+  }u6;
+
+  union {
+    struct {
+      LM_UINT16 mbuf_num;
+      LM_UINT16 reserved2;
+    }s7;
+
+    LM_UINT32 word;
+  }u7;
+
+  LM_UINT32 reserved3;
+  LM_UINT32 reserved4;
+#endif
+}T3_MBUF_FRAME_DESC,*PT3_MBUF_FRAME_DESC;
+
+typedef struct T3_MBUF_HDR {
+  union {
+    struct {
+      unsigned int C:1;
+      unsigned int F:1;
+      unsigned int reserved1:7;
+      unsigned int next_mbuf:16;
+      unsigned int length:7;
+    }s1;
+    
+    LM_UINT32 word;
+  }u1;
+  
+  LM_UINT32 next_frame_ptr;
+}T3_MBUF_HDR, *PT3_MBUF_HDR;
+
+typedef struct T3_MBUF
+{
+  T3_MBUF_HDR hdr;
+  union
+  {
+    struct {
+      T3_MBUF_FRAME_DESC frame_hdr;
+      LM_UINT32 data[20];
+    }s1;
+
+    struct {
+      LM_UINT32 data[30];
+    }s2;
+  }body;
+}T3_MBUF, *PT3_MBUF;
+
+#define T3_MBUF_BASE   (T3_NIC_MBUF_POOL_ADDR >> 7)
+#define T3_MBUF_END    ((T3_NIC_MBUF_POOL_ADDR + T3_NIC_MBUF_POOL_SIZE) >> 7)
+
+
+
+/******************************************************************************/
+/* Statistics block. */
+/******************************************************************************/
+
+typedef struct {
+    LM_UINT8 Reserved0[0x400-0x300];
+
+    /* Statistics maintained by Receive MAC. */
+    T3_64BIT_REGISTER ifHCInOctets;
+    T3_64BIT_REGISTER Reserved1;
+    T3_64BIT_REGISTER etherStatsFragments;
+    T3_64BIT_REGISTER ifHCInUcastPkts;
+    T3_64BIT_REGISTER ifHCInMulticastPkts;
+    T3_64BIT_REGISTER ifHCInBroadcastPkts;
+    T3_64BIT_REGISTER dot3StatsFCSErrors;
+    T3_64BIT_REGISTER dot3StatsAlignmentErrors;
+    T3_64BIT_REGISTER xonPauseFramesReceived;
+    T3_64BIT_REGISTER xoffPauseFramesReceived;
+    T3_64BIT_REGISTER macControlFramesReceived;
+    T3_64BIT_REGISTER xoffStateEntered;
+    T3_64BIT_REGISTER dot3StatsFramesTooLong;
+    T3_64BIT_REGISTER etherStatsJabbers;
+    T3_64BIT_REGISTER etherStatsUndersizePkts;
+    T3_64BIT_REGISTER inRangeLengthError;
+    T3_64BIT_REGISTER outRangeLengthError;
+    T3_64BIT_REGISTER etherStatsPkts64Octets;
+    T3_64BIT_REGISTER etherStatsPkts65Octetsto127Octets;
+    T3_64BIT_REGISTER etherStatsPkts128Octetsto255Octets;
+    T3_64BIT_REGISTER etherStatsPkts256Octetsto511Octets;
+    T3_64BIT_REGISTER etherStatsPkts512Octetsto1023Octets;
+    T3_64BIT_REGISTER etherStatsPkts1024Octetsto1522Octets;
+    T3_64BIT_REGISTER etherStatsPkts1523Octetsto2047Octets;
+    T3_64BIT_REGISTER etherStatsPkts2048Octetsto4095Octets;
+    T3_64BIT_REGISTER etherStatsPkts4096Octetsto8191Octets;
+    T3_64BIT_REGISTER etherStatsPkts8192Octetsto9022Octets;
+
+    T3_64BIT_REGISTER Unused1[37];
+
+    /* Statistics maintained by Transmit MAC. */
+    T3_64BIT_REGISTER ifHCOutOctets;
+    T3_64BIT_REGISTER Reserved2;
+    T3_64BIT_REGISTER etherStatsCollisions;
+    T3_64BIT_REGISTER outXonSent;
+    T3_64BIT_REGISTER outXoffSent;
+    T3_64BIT_REGISTER flowControlDone;
+    T3_64BIT_REGISTER dot3StatsInternalMacTransmitErrors;
+    T3_64BIT_REGISTER dot3StatsSingleCollisionFrames;
+    T3_64BIT_REGISTER dot3StatsMultipleCollisionFrames;
+    T3_64BIT_REGISTER dot3StatsDeferredTransmissions;
+    T3_64BIT_REGISTER Reserved3;
+    T3_64BIT_REGISTER dot3StatsExcessiveCollisions;
+    T3_64BIT_REGISTER dot3StatsLateCollisions;
+    T3_64BIT_REGISTER dot3Collided2Times;
+    T3_64BIT_REGISTER dot3Collided3Times;
+    T3_64BIT_REGISTER dot3Collided4Times;
+    T3_64BIT_REGISTER dot3Collided5Times;
+    T3_64BIT_REGISTER dot3Collided6Times;
+    T3_64BIT_REGISTER dot3Collided7Times;
+    T3_64BIT_REGISTER dot3Collided8Times;
+    T3_64BIT_REGISTER dot3Collided9Times;
+    T3_64BIT_REGISTER dot3Collided10Times;
+    T3_64BIT_REGISTER dot3Collided11Times;
+    T3_64BIT_REGISTER dot3Collided12Times;
+    T3_64BIT_REGISTER dot3Collided13Times;
+    T3_64BIT_REGISTER dot3Collided14Times;
+    T3_64BIT_REGISTER dot3Collided15Times;
+    T3_64BIT_REGISTER ifHCOutUcastPkts;
+    T3_64BIT_REGISTER ifHCOutMulticastPkts;
+    T3_64BIT_REGISTER ifHCOutBroadcastPkts;
+    T3_64BIT_REGISTER dot3StatsCarrierSenseErrors;
+    T3_64BIT_REGISTER ifOutDiscards;
+    T3_64BIT_REGISTER ifOutErrors;
+
+    T3_64BIT_REGISTER Unused2[31];
+
+    /* Statistics maintained by Receive List Placement. */
+    T3_64BIT_REGISTER COSIfHCInPkts[16];
+    T3_64BIT_REGISTER COSFramesDroppedDueToFilters;
+    T3_64BIT_REGISTER nicDmaWriteQueueFull;
+    T3_64BIT_REGISTER nicDmaWriteHighPriQueueFull;
+    T3_64BIT_REGISTER nicNoMoreRxBDs;
+    T3_64BIT_REGISTER ifInDiscards;
+    T3_64BIT_REGISTER ifInErrors;
+    T3_64BIT_REGISTER nicRecvThresholdHit;
+
+    T3_64BIT_REGISTER Unused3[9];
+
+    /* Statistics maintained by Send Data Initiator. */
+    T3_64BIT_REGISTER COSIfHCOutPkts[16];
+    T3_64BIT_REGISTER nicDmaReadQueueFull;
+    T3_64BIT_REGISTER nicDmaReadHighPriQueueFull;
+    T3_64BIT_REGISTER nicSendDataCompQueueFull;
+
+    /* Statistics maintained by Host Coalescing. */
+    T3_64BIT_REGISTER nicRingSetSendProdIndex;
+    T3_64BIT_REGISTER nicRingStatusUpdate;
+    T3_64BIT_REGISTER nicInterrupts;
+    T3_64BIT_REGISTER nicAvoidedInterrupts;
+    T3_64BIT_REGISTER nicSendThresholdHit;
+
+    LM_UINT8 Reserved4[0xb00-0x9c0];
+} T3_STATS_BLOCK, *PT3_STATS_BLOCK;
+
+
+
+/******************************************************************************/
+/* PCI configuration registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_16BIT_REGISTER VendorId;
+    T3_16BIT_REGISTER DeviceId;
+
+    T3_16BIT_REGISTER Command;
+    T3_16BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER ClassCodeRevId;
+
+    T3_8BIT_REGISTER CacheLineSize;
+    T3_8BIT_REGISTER LatencyTimer;
+    T3_8BIT_REGISTER HeaderType;
+    T3_8BIT_REGISTER Bist;
+
+    T3_32BIT_REGISTER MemBaseAddrLow;
+    T3_32BIT_REGISTER MemBaseAddrHigh;
+
+    LM_UINT8 Unused1[20];
+
+    T3_16BIT_REGISTER SubsystemVendorId;
+    T3_16BIT_REGISTER SubsystemId;
+
+    T3_32BIT_REGISTER RomBaseAddr;
+
+    T3_8BIT_REGISTER PciXCapiblityPtr;
+    LM_UINT8 Unused2[7];
+
+    T3_8BIT_REGISTER IntLine;
+    T3_8BIT_REGISTER IntPin;
+    T3_8BIT_REGISTER MinGnt;
+    T3_8BIT_REGISTER MaxLat;
+
+    T3_8BIT_REGISTER PciXCapabilities;
+    T3_8BIT_REGISTER PmCapabilityPtr;
+    T3_16BIT_REGISTER PciXCommand;
+
+    T3_32BIT_REGISTER PciXStatus;
+
+    T3_8BIT_REGISTER PmCapabilityId;
+    T3_8BIT_REGISTER VpdCapabilityPtr;
+    T3_16BIT_REGISTER PmCapabilities;
+
+    T3_16BIT_REGISTER PmCtrlStatus;
+    #define PM_CTRL_PME_STATUS            BIT_15
+    #define PM_CTRL_PME_ENABLE            BIT_8
+    #define PM_CTRL_PME_POWER_STATE_D0    0
+    #define PM_CTRL_PME_POWER_STATE_D1    1
+    #define PM_CTRL_PME_POWER_STATE_D2    2
+    #define PM_CTRL_PME_POWER_STATE_D3H   3
+
+    T3_8BIT_REGISTER BridgeSupportExt;
+    T3_8BIT_REGISTER PmData;
+
+    T3_8BIT_REGISTER VpdCapabilityId;
+    T3_8BIT_REGISTER MsiCapabilityPtr;
+    T3_16BIT_REGISTER VpdAddrFlag;
+    #define VPD_FLAG_WRITE      (1 << 15)
+    #define VPD_FLAG_RW_MASK    (1 << 15)
+    #define VPD_FLAG_READ       0
+
+
+    T3_32BIT_REGISTER VpdData;
+
+    T3_8BIT_REGISTER MsiCapabilityId;
+    T3_8BIT_REGISTER NextCapabilityPtr;
+    T3_16BIT_REGISTER MsiCtrl;
+    #define MSI_CTRL_64BIT_CAP     (1 << 7)
+    #define MSI_CTRL_MSG_ENABLE(x) (x << 4)
+    #define MSI_CTRL_MSG_CAP(x)    (x << 1)
+    #define MSI_CTRL_ENABLE        (1 << 0)
+  
+
+    T3_32BIT_REGISTER MsiAddrLow;
+    T3_32BIT_REGISTER MsiAddrHigh;
+
+    T3_16BIT_REGISTER MsiData;
+    T3_16BIT_REGISTER Unused3;
+
+    T3_32BIT_REGISTER MiscHostCtrl;
+    #define MISC_HOST_CTRL_CLEAR_INT                        BIT_0
+    #define MISC_HOST_CTRL_MASK_PCI_INT                     BIT_1
+    #define MISC_HOST_CTRL_ENABLE_ENDIAN_BYTE_SWAP          BIT_2
+    #define MISC_HOST_CTRL_ENABLE_ENDIAN_WORD_SWAP          BIT_3
+    #define MISC_HOST_CTRL_ENABLE_PCI_STATE_REG_RW          BIT_4
+    #define MISC_HOST_CTRL_ENABLE_CLK_REG_RW                BIT_5
+    #define MISC_HOST_CTRL_ENABLE_REG_WORD_SWAP             BIT_6
+    #define MISC_HOST_CTRL_ENABLE_INDIRECT_ACCESS           BIT_7
+    #define MISC_HOST_CTRL_ENABLE_INT_MASK_MODE             BIT_8
+    #define MISC_HOST_CTRL_ENABLE_TAGGED_STATUS_MODE        BIT_9
+
+    T3_32BIT_REGISTER DmaReadWriteCtrl;
+    #define DMA_CTRL_WRITE_BOUNDARY_MASK            (BIT_11 | BIT_12 | BIT_13)
+    #define DMA_CTRL_WRITE_BOUNDARY_DISABLE         0
+    #define DMA_CTRL_WRITE_BOUNDARY_16              BIT_11
+    #define DMA_CTRL_WRITE_BOUNDARY_32              BIT_12
+    #define DMA_CTRL_WRITE_BOUNDARY_64              (BIT_12 | BIT_11)
+    #define DMA_CTRL_WRITE_BOUNDARY_128             BIT_13
+    #define DMA_CTRL_WRITE_BOUNDARY_256             (BIT_13 | BIT_11)
+    #define DMA_CTRL_WRITE_BOUNDARY_512             (BIT_13 | BIT_12)
+    #define DMA_CTRL_WRITE_BOUNDARY_1024            (BIT_13 | BIT_12 | BIT_11)
+
+
+    T3_32BIT_REGISTER PciState;
+    #define T3_PCI_STATE_FORCE_PCI_RESET                    BIT_0
+    #define T3_PCI_STATE_INTERRUPT_NOT_ACTIVE               BIT_1
+    #define T3_PCI_STATE_NOT_PCI_X_BUS                      BIT_2
+    #define T3_PCI_STATE_HIGH_BUS_SPEED                     BIT_3
+    #define T3_PCI_STATE_32BIT_PCI_BUS                      BIT_4
+    #define T3_PCI_STATE_PCI_ROM_ENABLE                     BIT_5
+    #define T3_PCI_STATE_PCI_ROM_RETRY_ENABLE               BIT_6
+    #define T3_PCI_STATE_FLAT_VIEW                          BIT_8
+
+    T3_32BIT_REGISTER ClockCtrl;
+    #define T3_PCI_CLKCTRL_TXCPU_CLK_DISABLE                BIT_11
+    #define T3_PCI_CLKCTRL_RXCPU_CLK_DISABLE                BIT_10
+    #define T3_PCI_CLKCTRL_CORE_CLK_DISABLE                 BIT_9
+
+    T3_32BIT_REGISTER RegBaseAddr;
+
+    T3_32BIT_REGISTER MemWindowBaseAddr;
+    
+#ifdef NIC_CPU_VIEW
+  /* These registers are ONLY visible to NIC CPU */
+    T3_32BIT_REGISTER PowerConsumed;
+    T3_32BIT_REGISTER PowerDissipated;
+#else /* NIC_CPU_VIEW */
+    T3_32BIT_REGISTER RegData;
+    T3_32BIT_REGISTER MemWindowData;
+#endif /* !NIC_CPU_VIEW */
+
+    T3_32BIT_REGISTER ModeCtrl;
+
+    T3_32BIT_REGISTER MiscCfg;
+
+    T3_32BIT_REGISTER MiscLocalCtrl;
+
+    T3_32BIT_REGISTER Unused4;
+
+    /* NOTE: Big/Little-endian clarification needed.  Are these register */
+    /* in big or little endian formate. */
+    T3_64BIT_REGISTER StdRingProdIdx;
+    T3_64BIT_REGISTER RcvRetRingConIdx;
+    T3_64BIT_REGISTER SndProdIdx;
+
+    LM_UINT8 Unused5[80];
+} T3_PCI_CONFIGURATION, *PT3_PCI_CONFIGURATION;
+
+
+
+/******************************************************************************/
+/* Mac control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* MAC mode control. */
+    T3_32BIT_REGISTER Mode;
+    #define MAC_MODE_GLOBAL_RESET                       BIT_0
+    #define MAC_MODE_HALF_DUPLEX                        BIT_1
+    #define MAC_MODE_PORT_MODE_MASK                     (BIT_2 | BIT_3)
+    #define MAC_MODE_PORT_MODE_TBI                      (BIT_2 | BIT_3)
+    #define MAC_MODE_PORT_MODE_GMII                     BIT_3
+    #define MAC_MODE_PORT_MODE_MII                      BIT_2
+    #define MAC_MODE_PORT_MODE_NONE                     BIT_NONE
+    #define MAC_MODE_PORT_INTERNAL_LOOPBACK             BIT_4
+    #define MAC_MODE_TAGGED_MAC_CONTROL                 BIT_7
+    #define MAC_MODE_TX_BURSTING                        BIT_8
+    #define MAC_MODE_MAX_DEFER                          BIT_9
+    #define MAC_MODE_LINK_POLARITY                      BIT_10
+    #define MAC_MODE_ENABLE_RX_STATISTICS               BIT_11
+    #define MAC_MODE_CLEAR_RX_STATISTICS                BIT_12
+    #define MAC_MODE_FLUSH_RX_STATISTICS                BIT_13
+    #define MAC_MODE_ENABLE_TX_STATISTICS               BIT_14
+    #define MAC_MODE_CLEAR_TX_STATISTICS                BIT_15
+    #define MAC_MODE_FLUSH_TX_STATISTICS                BIT_16
+    #define MAC_MODE_SEND_CONFIGS                       BIT_17
+    #define MAC_MODE_DETECT_MAGIC_PACKET_ENABLE         BIT_18
+    #define MAC_MODE_ACPI_POWER_ON_ENABLE               BIT_19
+    #define MAC_MODE_ENABLE_MIP                         BIT_20
+    #define MAC_MODE_ENABLE_TDE                         BIT_21
+    #define MAC_MODE_ENABLE_RDE                         BIT_22
+    #define MAC_MODE_ENABLE_FHDE                        BIT_23
+
+    /* MAC status */
+    T3_32BIT_REGISTER Status;
+    #define MAC_STATUS_PCS_SYNCED                       BIT_0
+    #define MAC_STATUS_SIGNAL_DETECTED                  BIT_1
+    #define MAC_STATUS_RECEIVING_CFG                    BIT_2
+    #define MAC_STATUS_CFG_CHANGED                      BIT_3
+    #define MAC_STATUS_SYNC_CHANGED                     BIT_4
+    #define MAC_STATUS_PORT_DECODE_ERROR                BIT_10
+    #define MAC_STATUS_LINK_STATE_CHANGED               BIT_12
+    #define MAC_STATUS_MI_COMPLETION                    BIT_22
+    #define MAC_STATUS_MI_INTERRUPT                     BIT_23
+    #define MAC_STATUS_AP_ERROR                         BIT_24
+    #define MAC_STATUS_ODI_ERROR                        BIT_25
+    #define MAC_STATUS_RX_STATS_OVERRUN                 BIT_26
+    #define MAC_STATUS_TX_STATS_OVERRUN                 BIT_27
+
+    /* Event Enable */
+    T3_32BIT_REGISTER MacEvent;
+    #define MAC_EVENT_ENABLE_PORT_DECODE_ERR            BIT_10
+    #define MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN    BIT_12
+    #define MAC_EVENT_ENABLE_MI_COMPLETION              BIT_22
+    #define MAC_EVENT_ENABLE_MI_INTERRUPT               BIT_23
+    #define MAC_EVENT_ENABLE_AP_ERROR                   BIT_24
+    #define MAC_EVENT_ENABLE_ODI_ERROR                  BIT_25
+    #define MAC_EVENT_ENABLE_RX_STATS_OVERRUN           BIT_26
+    #define MAC_EVENT_ENABLE_TX_STATS_OVERRUN           BIT_27
+
+    /* Led control. */
+    T3_32BIT_REGISTER LedCtrl;
+    #define LED_CTRL_OVERRIDE_LINK_LED                  BIT_0
+    #define LED_CTRL_1000MBPS_LED_ON                    BIT_1
+    #define LED_CTRL_100MBPS_LED_ON                     BIT_2
+    #define LED_CTRL_10MBPS_LED_ON                      BIT_3
+    #define LED_CTRL_OVERRIDE_TRAFFIC_LED               BIT_4
+    #define LED_CTRL_BLINK_TRAFFIC_LED                  BIT_5
+    #define LED_CTRL_TRAFFIC_LED                        BIT_6
+    #define LED_CTRL_1000MBPS_LED_STATUS                BIT_7
+    #define LED_CTRL_100MBPS_LED_STATUS                 BIT_8
+    #define LED_CTRL_10MBPS_LED_STATUS                  BIT_9
+    #define LED_CTRL_TRAFFIC_LED_STATUS                 BIT_10
+    #define LED_CTRL_MAC_MODE                           BIT_NONE
+    #define LED_CTRL_PHY_MODE_1                         BIT_11
+    #define LED_CTRL_PHY_MODE_2                         BIT_12
+    #define LED_CTRL_BLINK_RATE_MASK                    0x7ff80000
+    #define LED_CTRL_OVERRIDE_BLINK_PERIOD              BIT_19
+    #define LED_CTRL_OVERRIDE_BLINK_RATE                BIT_31
+
+    /* MAC addresses. */
+    struct {
+        T3_32BIT_REGISTER High;             /* Upper 2 bytes. */
+        T3_32BIT_REGISTER Low;              /* Lower 4 bytes. */
+    } MacAddr[4];
+
+    /* ACPI Mbuf pointer. */
+    T3_32BIT_REGISTER AcpiMbufPtr;
+
+    /* ACPI Length and Offset. */
+    T3_32BIT_REGISTER AcpiLengthOffset;
+    #define ACPI_LENGTH_MASK                            0xffff
+    #define ACPI_OFFSET_MASK                            0x0fff0000
+    #define ACPI_LENGTH(x)                              x
+    #define ACPI_OFFSET(x)                              ((x) << 16)
+
+    /* Transmit random backoff. */
+    T3_32BIT_REGISTER TxBackoffSeed;
+    #define MAC_TX_BACKOFF_SEED_MASK                    0x3ff
+
+    /* Receive MTU */
+    T3_32BIT_REGISTER MtuSize;
+    #define MAC_RX_MTU_MASK                             0xffff
+
+    /* Gigabit PCS Test. */
+    T3_32BIT_REGISTER PcsTest;
+    #define MAC_PCS_TEST_DATA_PATTERN_MASK              0x0fffff
+    #define MAC_PCS_TEST_ENABLE                         BIT_20
+
+    /* Transmit Gigabit Auto-Negotiation. */
+    T3_32BIT_REGISTER TxAutoNeg;
+    #define MAC_AN_TX_AN_DATA_MASK                      0xffff
+
+    /* Receive Gigabit Auto-Negotiation. */
+    T3_32BIT_REGISTER RxAutoNeg;
+    #define MAC_AN_RX_AN_DATA_MASK                      0xffff
+
+    /* MI Communication. */
+    T3_32BIT_REGISTER MiCom;
+    #define MI_COM_CMD_MASK                             (BIT_26 | BIT_27)
+    #define MI_COM_CMD_WRITE                            BIT_26
+    #define MI_COM_CMD_READ                             BIT_27
+    #define MI_COM_READ_FAILED                          BIT_28
+    #define MI_COM_START                                BIT_29
+    #define MI_COM_BUSY                                 BIT_29
+
+    #define MI_COM_PHY_ADDR_MASK                        0x1f
+    #define MI_COM_FIRST_PHY_ADDR_BIT                   21
+
+    #define MI_COM_PHY_REG_ADDR_MASK                    0x1f
+    #define MI_COM_FIRST_PHY_REG_ADDR_BIT               16
+
+    #define MI_COM_PHY_DATA_MASK                        0xffff
+
+    /* MI Status. */
+    T3_32BIT_REGISTER MiStatus;
+    #define MI_STATUS_ENABLE_LINK_STATUS_ATTN           BIT_0
+
+    /* MI Mode. */
+    T3_32BIT_REGISTER MiMode;
+    #define MI_MODE_CLOCK_SPEED_10MHZ                   BIT_0
+    #define MI_MODE_USE_SHORT_PREAMBLE                  BIT_1
+    #define MI_MODE_AUTO_POLLING_ENABLE                 BIT_4
+    #define MI_MODE_CORE_CLOCK_SPEED_62MHZ              BIT_15
+
+    /* Auto-polling status. */
+    T3_32BIT_REGISTER AutoPollStatus;
+    #define AUTO_POLL_ERROR                             BIT_0
+
+    /* Transmit MAC mode. */
+    T3_32BIT_REGISTER TxMode;
+    #define TX_MODE_RESET                               BIT_0
+    #define TX_MODE_ENABLE                              BIT_1
+    #define TX_MODE_ENABLE_FLOW_CONTROL                 BIT_4
+    #define TX_MODE_ENABLE_BIG_BACKOFF                  BIT_5
+    #define TX_MODE_ENABLE_LONG_PAUSE                   BIT_6
+
+    /* Transmit MAC status. */
+    T3_32BIT_REGISTER TxStatus;
+    #define TX_STATUS_RX_CURRENTLY_XOFFED               BIT_0
+    #define TX_STATUS_SENT_XOFF                         BIT_1
+    #define TX_STATUS_SENT_XON                          BIT_2
+    #define TX_STATUS_LINK_UP                           BIT_3
+    #define TX_STATUS_ODI_UNDERRUN                      BIT_4
+    #define TX_STATUS_ODI_OVERRUN                       BIT_5
+
+    /* Transmit MAC length. */
+    T3_32BIT_REGISTER TxLengths;
+    #define TX_LEN_SLOT_TIME_MASK                       0xff
+    #define TX_LEN_IPG_MASK                             0x0f00
+    #define TX_LEN_IPG_CRS_MASK                         (BIT_12 | BIT_13)
+
+    /* Receive MAC mode. */
+    T3_32BIT_REGISTER RxMode;
+    #define RX_MODE_RESET                               BIT_0
+    #define RX_MODE_ENABLE                              BIT_1
+    #define RX_MODE_ENABLE_FLOW_CONTROL                 BIT_2
+    #define RX_MODE_KEEP_MAC_CONTROL                    BIT_3
+    #define RX_MODE_KEEP_PAUSE                          BIT_4
+    #define RX_MODE_ACCEPT_OVERSIZED                    BIT_5
+    #define RX_MODE_ACCEPT_RUNTS                        BIT_6
+    #define RX_MODE_LENGTH_CHECK                        BIT_7
+    #define RX_MODE_PROMISCUOUS_MODE                    BIT_8
+    #define RX_MODE_NO_CRC_CHECK                        BIT_9
+    #define RX_MODE_KEEP_VLAN_TAG                       BIT_10
+
+    /* Receive MAC status. */
+    T3_32BIT_REGISTER RxStatus;
+    #define RX_STATUS_REMOTE_TRANSMITTER_XOFFED         BIT_0
+    #define RX_STATUS_XOFF_RECEIVED                     BIT_1
+    #define RX_STATUS_XON_RECEIVED                      BIT_2
+
+    /* Hash registers. */
+    T3_32BIT_REGISTER HashReg[4];
+
+    /* Receive placement rules registers. */
+    struct {
+        T3_32BIT_REGISTER Rule;
+        T3_32BIT_REGISTER Value;
+    } RcvRules[16];
+
+    #define RCV_DISABLE_RULE_MASK                       0x7fffffff
+
+    #define RCV_RULE1_REJECT_BROADCAST_IDX              0x00
+    #define REJECT_BROADCAST_RULE1_RULE                 0xc2000000
+    #define REJECT_BROADCAST_RULE1_VALUE                0xffffffff
+
+    #define RCV_RULE2_REJECT_BROADCAST_IDX              0x01
+    #define REJECT_BROADCAST_RULE2_RULE                 0x86000004
+    #define REJECT_BROADCAST_RULE2_VALUE                0xffffffff
+
+#if INCLUDE_5701_AX_FIX
+    #define RCV_LAST_RULE_IDX                           0x04
+#else
+    #define RCV_LAST_RULE_IDX                           0x02
+#endif
+
+    T3_32BIT_REGISTER RcvRuleCfg;
+    #define RX_RULE_DEFAULT_CLASS                       (1 << 3)
+
+    LM_UINT8 Reserved1[252];
+
+    volatile LM_UINT8 TxMacState[16];
+    volatile LM_UINT8 RxMacState[20];
+
+    LM_UINT8 Reserved2[476];
+
+    T3_32BIT_REGISTER RxStats[26];
+
+    LM_UINT8 Reserved3[24];
+
+    T3_32BIT_REGISTER TxStats[28];
+
+    LM_UINT8 Reserved4[784];
+} T3_MAC_CONTROL, *PT3_MAC_CONTROL;
+
+
+
+/******************************************************************************/
+/* Send data initiator control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define T3_SND_DATA_IN_MODE_RESET                       BIT_0
+    #define T3_SND_DATA_IN_MODE_ENABLE                      BIT_1
+    #define T3_SND_DATA_IN_MODE_STATS_OFLW_ATTN_ENABLE      BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define T3_SND_DATA_IN_STATUS_STATS_OFLW_ATTN           BIT_2
+
+    T3_32BIT_REGISTER StatsCtrl;
+    #define T3_SND_DATA_IN_STATS_CTRL_ENABLE                BIT_0
+    #define T3_SND_DATA_IN_STATS_CTRL_FASTER_UPDATE         BIT_1
+    #define T3_SND_DATA_IN_STATS_CTRL_CLEAR                 BIT_2
+    #define T3_SND_DATA_IN_STATS_CTRL_FLUSH                 BIT_3
+    #define T3_SND_DATA_IN_STATS_CTRL_FORCE_ZERO            BIT_4
+
+    T3_32BIT_REGISTER StatsEnableMask;
+    T3_32BIT_REGISTER StatsIncMask;
+
+    LM_UINT8 Reserved[108];
+
+    T3_32BIT_REGISTER ClassOfServCnt[16];
+    T3_32BIT_REGISTER DmaReadQFullCnt;
+    T3_32BIT_REGISTER DmaPriorityReadQFullCnt;
+    T3_32BIT_REGISTER SdcQFullCnt;
+
+    T3_32BIT_REGISTER NicRingSetSendProdIdxCnt;
+    T3_32BIT_REGISTER StatusUpdatedCnt;
+    T3_32BIT_REGISTER InterruptsCnt;
+    T3_32BIT_REGISTER AvoidInterruptsCnt;
+    T3_32BIT_REGISTER SendThresholdHitCnt;
+
+    /* Unused space. */
+    LM_UINT8 Unused[800];
+} T3_SEND_DATA_INITIATOR, *PT3_SEND_DATA_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Send data completion control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_DATA_COMP_MODE_RESET                        BIT_0
+    #define SND_DATA_COMP_MODE_ENABLE                       BIT_1
+
+    /* Unused space. */
+    LM_UINT8 Unused[1020];
+} T3_SEND_DATA_COMPLETION, *PT3_SEND_DATA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Send BD Ring Selector Control Registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_SEL_MODE_RESET                           BIT_0
+    #define SND_BD_SEL_MODE_ENABLE                          BIT_1
+    #define SND_BD_SEL_MODE_ATTN_ENABLE                     BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define SND_BD_SEL_STATUS_ERROR_ATTN                    BIT_2
+
+    T3_32BIT_REGISTER HwDiag;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[52];
+
+    /* Send BD Ring Selector Local NIC Send BD Consumer Index. */
+    T3_32BIT_REGISTER NicSendBdSelConIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused2[896];
+} T3_SEND_BD_SELECTOR, *PT3_SEND_BD_SELECTOR;
+
+
+
+/******************************************************************************/
+/* Send BD initiator control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_IN_MODE_RESET                            BIT_0
+    #define SND_BD_IN_MODE_ENABLE                           BIT_1
+    #define SND_BD_IN_MODE_ATTN_ENABLE                      BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define SND_BD_IN_STATUS_ERROR_ATTN                     BIT_2
+
+    /* Send BD initiator local NIC send BD producer index. */
+    T3_32BIT_REGISTER NicSendBdInProdIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused2[952];
+} T3_SEND_BD_INITIATOR, *PT3_SEND_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Send BD Completion Control. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_COMP_MODE_RESET                          BIT_0
+    #define SND_BD_COMP_MODE_ENABLE                         BIT_1
+    #define SND_BD_COMP_MODE_ATTN_ENABLE                    BIT_2
+
+    /* Unused space. */
+    LM_UINT8 Unused2[1020];
+} T3_SEND_BD_COMPLETION, *PT3_SEND_BD_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive list placement control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define RCV_LIST_PLMT_MODE_RESET                        BIT_0
+    #define RCV_LIST_PLMT_MODE_ENABLE                       BIT_1
+    #define RCV_LIST_PLMT_MODE_CLASS0_ATTN_ENABLE           BIT_2
+    #define RCV_LIST_PLMT_MODE_MAPPING_OOR_ATTN_ENABLE      BIT_3
+    #define RCV_LIST_PLMT_MODE_STATS_OFLOW_ATTN_ENABLE      BIT_4
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define RCV_LIST_PLMT_STATUS_CLASS0_ATTN                BIT_2
+    #define RCV_LIST_PLMT_STATUS_MAPPING_ATTN               BIT_3
+    #define RCV_LIST_PLMT_STATUS_STATS_OFLOW_ATTN           BIT_4
+
+    /* Receive selector list lock register. */
+    T3_32BIT_REGISTER Lock;
+    #define RCV_LIST_SEL_LOCK_REQUEST_MASK                  0xffff
+    #define RCV_LIST_SEL_LOCK_GRANT_MASK                    0xffff0000
+
+    /* Selector non-empty bits. */
+    T3_32BIT_REGISTER NonEmptyBits;
+    #define RCV_LIST_SEL_NON_EMPTY_MASK                     0xffff
+
+    /* Receive list placement configuration register. */
+    T3_32BIT_REGISTER Config;
+
+    /* Receive List Placement statistics Control. */
+    T3_32BIT_REGISTER StatsCtrl;
+#define RCV_LIST_STATS_ENABLE                               BIT_0
+#define RCV_LIST_STATS_FAST_UPDATE                          BIT_1
+
+    /* Receive List Placement statistics Enable Mask. */
+    T3_32BIT_REGISTER StatsEnableMask;
+
+    /* Receive List Placement statistics Increment Mask. */
+    T3_32BIT_REGISTER StatsIncMask;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[224];
+
+    struct {
+        T3_32BIT_REGISTER Head;
+        T3_32BIT_REGISTER Tail;
+        T3_32BIT_REGISTER Count;
+
+        /* Unused space. */
+        LM_UINT8 Unused[4];
+    } RcvSelectorList[16];
+
+    /* Local statistics counter. */
+    T3_32BIT_REGISTER ClassOfServCnt[16];
+
+    T3_32BIT_REGISTER DropDueToFilterCnt;
+    T3_32BIT_REGISTER DmaWriteQFullCnt;
+    T3_32BIT_REGISTER DmaHighPriorityWriteQFullCnt;
+    T3_32BIT_REGISTER NoMoreReceiveBdCnt;
+    T3_32BIT_REGISTER IfInDiscardsCnt;
+    T3_32BIT_REGISTER IfInErrorsCnt;
+    T3_32BIT_REGISTER RcvThresholdHitCnt;
+
+    /* Another unused space. */
+    LM_UINT8 Unused2[420];
+} T3_RCV_LIST_PLACEMENT, *PT3_RCV_LIST_PLACEMENT;
+
+
+
+/******************************************************************************/
+/* Receive Data and Receive BD Initiator Control. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define RCV_DATA_BD_IN_MODE_RESET                   BIT_0
+    #define RCV_DATA_BD_IN_MODE_ENABLE                  BIT_1
+    #define RCV_DATA_BD_IN_MODE_JUMBO_BD_NEEDED         BIT_2
+    #define RCV_DATA_BD_IN_MODE_FRAME_TOO_BIG           BIT_3
+    #define RCV_DATA_BD_IN_MODE_INVALID_RING_SIZE       BIT_4
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define RCV_DATA_BD_IN_STATUS_JUMBO_BD_NEEDED       BIT_2
+    #define RCV_DATA_BD_IN_STATUS_FRAME_TOO_BIG         BIT_3
+    #define RCV_DATA_BD_IN_STATUS_INVALID_RING_SIZE     BIT_4
+
+    /* Split frame minium size. */
+    T3_32BIT_REGISTER SplitFrameMinSize;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[0x2440-0x240c];
+
+    /* Receive RCBs. */
+    T3_RCB JumboRcvRcb;
+    T3_RCB StdRcvRcb;
+    T3_RCB MiniRcvRcb;
+
+    /* Receive Data and Receive BD Ring Initiator Local NIC Receive */
+    /* BD Consumber Index. */
+    T3_32BIT_REGISTER NicJumboConIdx;
+    T3_32BIT_REGISTER NicStdConIdx;
+    T3_32BIT_REGISTER NicMiniConIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[4];
+
+    /* Receive Data and Receive BD Initiator Local Receive Return ProdIdx. */
+    T3_32BIT_REGISTER RcvDataBdProdIdx[16];
+
+    /* Receive Data and Receive BD Initiator Hardware Diagnostic. */
+    T3_32BIT_REGISTER HwDiag;
+
+    /* Unused space. */
+    LM_UINT8 Unused3[828];
+} T3_RCV_DATA_BD_INITIATOR, *PT3_RCV_DATA_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Receive Data Completion Control Registes. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_DATA_COMP_MODE_RESET                        BIT_0
+    #define RCV_DATA_COMP_MODE_ENABLE                       BIT_1
+    #define RCV_DATA_COMP_MODE_ATTN_ENABLE                  BIT_2
+
+    /* Unused spaced. */
+    LM_UINT8 Unused[1020];
+} T3_RCV_DATA_COMPLETION, *PT3_RCV_DATA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive BD Initiator Control. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_BD_IN_MODE_RESET                            BIT_0
+    #define RCV_BD_IN_MODE_ENABLE                           BIT_1
+    #define RCV_BD_IN_MODE_BD_IN_DIABLED_RCB_ATTN_ENABLE    BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_BD_IN_STATUS_BD_IN_DIABLED_RCB_ATTN         BIT_2
+
+    T3_32BIT_REGISTER NicJumboRcvProdIdx;
+    T3_32BIT_REGISTER NicStdRcvProdIdx;
+    T3_32BIT_REGISTER NicMiniRcvProdIdx;
+
+    T3_32BIT_REGISTER MiniRcvThreshold;
+    T3_32BIT_REGISTER StdRcvThreshold;
+    T3_32BIT_REGISTER JumboRcvThreshold;
+
+    /* Unused space. */
+    LM_UINT8 Unused[992];
+} T3_RCV_BD_INITIATOR, *PT3_RCV_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Receive BD Completion Control Registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_BD_COMP_MODE_RESET                          BIT_0
+    #define RCV_BD_COMP_MODE_ENABLE                         BIT_1
+    #define RCV_BD_COMP_MODE_ATTN_ENABLE                    BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_BD_COMP_STATUS_ERROR_ATTN                   BIT_2
+
+    T3_32BIT_REGISTER  NicJumboRcvBdProdIdx;
+    T3_32BIT_REGISTER  NicStdRcvBdProdIdx;
+    T3_32BIT_REGISTER  NicMiniRcvBdProdIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1004];
+} T3_RCV_BD_COMPLETION, *PT3_RCV_BD_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive list selector control register. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_LIST_SEL_MODE_RESET                         BIT_0
+    #define RCV_LIST_SEL_MODE_ENABLE                        BIT_1
+    #define RCV_LIST_SEL_MODE_ATTN_ENABLE                   BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_LIST_SEL_STATUS_ERROR_ATTN                  BIT_2
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_RCV_LIST_SELECTOR, *PT3_RCV_LIST_SELECTOR;
+
+
+
+/******************************************************************************/
+/* Mbuf cluster free registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define MBUF_CLUSTER_FREE_MODE_RESET    BIT_0
+#define MBUF_CLUSTER_FREE_MODE_ENABLE   BIT_1
+
+    T3_32BIT_REGISTER Status;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_MBUF_CLUSTER_FREE, *PT3_MBUF_CLUSTER_FREE;
+
+
+
+/******************************************************************************/
+/* Host coalescing control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define HOST_COALESCE_RESET                         BIT_0
+    #define HOST_COALESCE_ENABLE                        BIT_1
+    #define HOST_COALESCE_ATTN                          BIT_2
+    #define HOST_COALESCE_NOW                           BIT_3
+    #define HOST_COALESCE_FULL_STATUS_MODE              BIT_NONE
+    #define HOST_COALESCE_64_BYTE_STATUS_MODE           BIT_7
+    #define HOST_COALESCE_32_BYTE_STATUS_MODE           BIT_8
+    #define HOST_COALESCE_CLEAR_TICKS_ON_RX_BD_EVENT    BIT_9
+    #define HOST_COALESCE_CLEAR_TICKS_ON_TX_BD_EVENT    BIT_10
+    #define HOST_COALESCE_NO_INT_ON_COALESCE_NOW_MODE   BIT_11
+    #define HOST_COALESCE_NO_INT_ON_FORCE_DMAD_MODE     BIT_12
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define HOST_COALESCE_ERROR_ATTN                    BIT_2
+
+    /* Receive coalescing ticks. */
+    T3_32BIT_REGISTER RxCoalescingTicks;
+
+    /* Send coalescing ticks. */
+    T3_32BIT_REGISTER TxCoalescingTicks;
+
+    /* Receive max coalesced frames. */
+    T3_32BIT_REGISTER RxMaxCoalescedFrames;
+
+    /* Send max coalesced frames. */
+    T3_32BIT_REGISTER TxMaxCoalescedFrames;
+
+    /* Receive coalescing ticks during interrupt. */
+    T3_32BIT_REGISTER RxCoalescedTickDuringInt;
+
+    /* Send coalescing ticks during interrupt. */
+    T3_32BIT_REGISTER TxCoalescedTickDuringInt;
+
+    /* Receive max coalesced frames during interrupt. */
+    T3_32BIT_REGISTER RxMaxCoalescedFramesDuringInt;
+
+    /* Send max coalesced frames during interrupt. */
+    T3_32BIT_REGISTER TxMaxCoalescedFramesDuringInt;
+
+    /* Statistics tick. */
+    T3_32BIT_REGISTER StatsCoalescingTicks;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[4];
+
+    /* Statistics host address. */
+    T3_64BIT_REGISTER StatsBlkHostAddr;
+
+    /* Status block host address.*/
+    T3_64BIT_REGISTER StatusBlkHostAddr;
+
+    /* Statistics NIC address. */
+    T3_32BIT_REGISTER StatsBlkNicAddr;
+
+    /* Statust block NIC address. */
+    T3_32BIT_REGISTER StatusBlkNicAddr;
+
+    /* Flow attention registers. */
+    T3_32BIT_REGISTER FlowAttn;
+
+    /* Unused space. */
+    LM_UINT8 Unused3[4];
+
+    T3_32BIT_REGISTER NicJumboRcvBdConIdx;
+    T3_32BIT_REGISTER NicStdRcvBdConIdx;
+    T3_32BIT_REGISTER NicMiniRcvBdConIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused4[36];
+
+    T3_32BIT_REGISTER NicRetProdIdx[16];
+    T3_32BIT_REGISTER NicSndBdConIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused5[768];
+} T3_HOST_COALESCING, *PT3_HOST_COALESCING;
+
+
+
+/******************************************************************************/
+/* Memory arbiter registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define T3_MEM_ARBITER_MODE_RESET       BIT_0
+#define T3_MEM_ARBITER_MODE_ENABLE      BIT_1
+
+    T3_32BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER ArbTrapAddrLow;
+    T3_32BIT_REGISTER ArbTrapAddrHigh;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1008];
+} T3_MEM_ARBITER, *PT3_MEM_ARBITER;
+
+
+
+/******************************************************************************/
+/* Buffer manager control register. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define BUFMGR_MODE_RESET                           BIT_0
+    #define BUFMGR_MODE_ENABLE                          BIT_1
+    #define BUFMGR_MODE_ATTN_ENABLE                     BIT_2
+    #define BUFMGR_MODE_BM_TEST                         BIT_3
+    #define BUFMGR_MODE_MBUF_LOW_ATTN_ENABLE            BIT_4
+
+    T3_32BIT_REGISTER Status;
+    #define BUFMGR_STATUS_ERROR                         BIT_2
+    #define BUFMGR_STATUS_MBUF_LOW                      BIT_4
+
+    T3_32BIT_REGISTER MbufPoolAddr;
+    T3_32BIT_REGISTER MbufPoolSize;
+    T3_32BIT_REGISTER MbufReadDmaLowWaterMark;
+    T3_32BIT_REGISTER MbufMacRxLowWaterMark;
+    T3_32BIT_REGISTER MbufHighWaterMark;
+
+    T3_32BIT_REGISTER RxCpuMbufAllocReq;
+    #define BUFMGR_MBUF_ALLOC_BIT                     BIT_31
+    T3_32BIT_REGISTER RxCpuMbufAllocResp;
+    T3_32BIT_REGISTER TxCpuMbufAllocReq;
+    T3_32BIT_REGISTER TxCpuMbufAllocResp;
+
+    T3_32BIT_REGISTER DmaDescPoolAddr;
+    T3_32BIT_REGISTER DmaDescPoolSize;
+    T3_32BIT_REGISTER DmaLowWaterMark;
+    T3_32BIT_REGISTER DmaHighWaterMark;
+
+    T3_32BIT_REGISTER RxCpuDmaAllocReq;
+    T3_32BIT_REGISTER RxCpuDmaAllocResp;
+    T3_32BIT_REGISTER TxCpuDmaAllocReq;
+    T3_32BIT_REGISTER TxCpuDmaAllocResp;
+
+    T3_32BIT_REGISTER Hwdiag[3];
+
+    /* Unused space. */
+    LM_UINT8 Unused[936];
+} T3_BUFFER_MANAGER, *PT3_BUFFER_MANAGER;
+
+
+
+/******************************************************************************/
+/* Read DMA control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_READ_MODE_RESET                         BIT_0
+    #define DMA_READ_MODE_ENABLE                        BIT_1
+    #define DMA_READ_MODE_TARGET_ABORT_ATTN_ENABLE      BIT_2
+    #define DMA_READ_MODE_MASTER_ABORT_ATTN_ENABLE      BIT_3
+    #define DMA_READ_MODE_PARITY_ERROR_ATTN_ENABLE      BIT_4
+    #define DMA_READ_MODE_ADDR_OVERFLOW_ATTN_ENABLE     BIT_5
+    #define DMA_READ_MODE_FIFO_OVERRUN_ATTN_ENABLE      BIT_6
+    #define DMA_READ_MODE_FIFO_UNDERRUN_ATTN_ENABLE     BIT_7
+    #define DMA_READ_MODE_FIFO_OVERREAD_ATTN_ENABLE     BIT_8
+    #define DMA_READ_MODE_LONG_READ_ATTN_ENABLE         BIT_9
+
+    T3_32BIT_REGISTER Status;
+    #define DMA_READ_STATUS_TARGET_ABORT_ATTN           BIT_2
+    #define DMA_READ_STATUS_MASTER_ABORT_ATTN           BIT_3
+    #define DMA_READ_STATUS_PARITY_ERROR_ATTN           BIT_4
+    #define DMA_READ_STATUS_ADDR_OVERFLOW_ATTN          BIT_5
+    #define DMA_READ_STATUS_FIFO_OVERRUN_ATTN           BIT_6
+    #define DMA_READ_STATUS_FIFO_UNDERRUN_ATTN          BIT_7
+    #define DMA_READ_STATUS_FIFO_OVERREAD_ATTN          BIT_8
+    #define DMA_READ_STATUS_LONG_READ_ATTN              BIT_9
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_DMA_READ, *PT3_DMA_READ;
+
+typedef union T3_CPU 
+{
+  struct
+  {
+    T3_32BIT_REGISTER mode;
+    #define CPU_MODE_HALT   BIT_10
+    #define CPU_MODE_RESET  BIT_0 
+    T3_32BIT_REGISTER state;
+    T3_32BIT_REGISTER EventMask;
+    T3_32BIT_REGISTER reserved1[4];
+    T3_32BIT_REGISTER PC;
+    T3_32BIT_REGISTER Instruction;
+    T3_32BIT_REGISTER SpadUnderflow;
+    T3_32BIT_REGISTER WatchdogClear;
+    T3_32BIT_REGISTER WatchdogVector;
+    T3_32BIT_REGISTER WatchdogSavedPC;
+    T3_32BIT_REGISTER HardwareBp;
+    T3_32BIT_REGISTER reserved2[3];
+    T3_32BIT_REGISTER WatchdogSavedState;    
+    T3_32BIT_REGISTER LastBrchAddr;    
+    T3_32BIT_REGISTER SpadUnderflowSet;    
+    T3_32BIT_REGISTER reserved3[(0x200-0x50)/4];
+    T3_32BIT_REGISTER Regs[32];
+    T3_32BIT_REGISTER reserved4[(0x400-0x280)/4];
+  }reg;
+}T3_CPU, *PT3_CPU;
+
+/******************************************************************************/
+/* Write DMA control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_WRITE_MODE_RESET                        BIT_0
+    #define DMA_WRITE_MODE_ENABLE                       BIT_1
+    #define DMA_WRITE_MODE_TARGET_ABORT_ATTN_ENABLE     BIT_2
+    #define DMA_WRITE_MODE_MASTER_ABORT_ATTN_ENABLE     BIT_3
+    #define DMA_WRITE_MODE_PARITY_ERROR_ATTN_ENABLE     BIT_4
+    #define DMA_WRITE_MODE_ADDR_OVERFLOW_ATTN_ENABLE    BIT_5
+    #define DMA_WRITE_MODE_FIFO_OVERRUN_ATTN_ENABLE     BIT_6
+    #define DMA_WRITE_MODE_FIFO_UNDERRUN_ATTN_ENABLE    BIT_7
+    #define DMA_WRITE_MODE_FIFO_OVERREAD_ATTN_ENABLE    BIT_8
+    #define DMA_WRITE_MODE_LONG_READ_ATTN_ENABLE        BIT_9
+
+    T3_32BIT_REGISTER Status;
+    #define DMA_WRITE_STATUS_TARGET_ABORT_ATTN          BIT_2
+    #define DMA_WRITE_STATUS_MASTER_ABORT_ATTN          BIT_3
+    #define DMA_WRITE_STATUS_PARITY_ERROR_ATTN          BIT_4
+    #define DMA_WRITE_STATUS_ADDR_OVERFLOW_ATTN         BIT_5
+    #define DMA_WRITE_STATUS_FIFO_OVERRUN_ATTN          BIT_6
+    #define DMA_WRITE_STATUS_FIFO_UNDERRUN_ATTN         BIT_7
+    #define DMA_WRITE_STATUS_FIFO_OVERREAD_ATTN         BIT_8
+    #define DMA_WRITE_STATUS_LONG_READ_ATTN             BIT_9
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_DMA_WRITE, *PT3_DMA_WRITE;
+
+
+
+/******************************************************************************/
+/* Mailbox registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Interrupt mailbox registers. */
+    T3_64BIT_REGISTER Interrupt[4];
+
+    /* General mailbox registers. */
+    T3_64BIT_REGISTER General[8];
+
+    /* Reload statistics mailbox. */
+    T3_64BIT_REGISTER ReloadStat;
+
+    /* Receive BD ring producer index registers. */
+    T3_64BIT_REGISTER RcvStdProdIdx;
+    T3_64BIT_REGISTER RcvJumboProdIdx;
+    T3_64BIT_REGISTER RcvMiniProdIdx;
+
+    /* Receive return ring consumer index registers. */
+    T3_64BIT_REGISTER RcvRetConIdx[16];
+
+    /* Send BD ring host producer index registers. */
+    T3_64BIT_REGISTER SendHostProdIdx[16];
+
+    /* Send BD ring nic producer index registers. */
+    T3_64BIT_REGISTER SendNicProdIdx[16];
+}T3_MAILBOX, *PT3_MAILBOX;
+
+typedef struct {
+    T3_MAILBOX Mailbox;
+
+    /* Priority mailbox registers. */
+    T3_32BIT_REGISTER HighPriorityEventVector;
+    T3_32BIT_REGISTER HighPriorityEventMask;
+    T3_32BIT_REGISTER LowPriorityEventVector;
+    T3_32BIT_REGISTER LowPriorityEventMask;
+
+    /* Unused space. */
+    LM_UINT8 Unused[496];
+} T3_GRC_MAILBOX, *PT3_GRC_MAILBOX;
+
+
+/******************************************************************************/
+/* Flow through queues. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Reset;
+    
+    LM_UINT8 Unused[12];
+
+    T3_32BIT_REGISTER DmaNormalReadFtqCtrl;
+    T3_32BIT_REGISTER DmaNormalReadFtqFullCnt;
+    T3_32BIT_REGISTER DmaNormalReadFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaNormalReadFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaHighReadFtqCtrl;
+    T3_32BIT_REGISTER DmaHighReadFtqFullCnt;
+    T3_32BIT_REGISTER DmaHighReadFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaHighReadFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaCompDiscardFtqCtrl;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFullCnt;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendBdCompFtqCtrl;
+    T3_32BIT_REGISTER SendBdCompFtqFullCnt;
+    T3_32BIT_REGISTER SendBdCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendBdCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendDataInitiatorFtqCtrl;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFullCnt;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaNormalWriteFtqCtrl;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFullCnt;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaHighWriteFtqCtrl;
+    T3_32BIT_REGISTER DmaHighWriteFtqFullCnt;
+    T3_32BIT_REGISTER DmaHighWriteFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaHighWriteFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SwType1FtqCtrl;
+    T3_32BIT_REGISTER SwType1FtqFullCnt;
+    T3_32BIT_REGISTER SwType1FtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SwType1FtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendDataCompFtqCtrl;
+    T3_32BIT_REGISTER SendDataCompFtqFullCnt;
+    T3_32BIT_REGISTER SendDataCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendDataCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER HostCoalesceFtqCtrl;
+    T3_32BIT_REGISTER HostCoalesceFtqFullCnt;
+    T3_32BIT_REGISTER HostCoalesceFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER HostCoalesceFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER MacTxFtqCtrl;
+    T3_32BIT_REGISTER MacTxFtqFullCnt;
+    T3_32BIT_REGISTER MacTxFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER MacTxFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER MbufClustFreeFtqCtrl;
+    T3_32BIT_REGISTER MbufClustFreeFtqFullCnt;
+    T3_32BIT_REGISTER MbufClustFreeFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER MbufClustFreeFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvBdCompFtqCtrl;
+    T3_32BIT_REGISTER RcvBdCompFtqFullCnt;
+    T3_32BIT_REGISTER RcvBdCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvBdCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvListPlmtFtqCtrl;
+    T3_32BIT_REGISTER RcvListPlmtFtqFullCnt;
+    T3_32BIT_REGISTER RcvListPlmtFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvListPlmtFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqCtrl;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFullCnt;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvDataCompFtqCtrl;
+    T3_32BIT_REGISTER RcvDataCompFtqFullCnt;
+    T3_32BIT_REGISTER RcvDataCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvDataCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SwType2FtqCtrl;
+    T3_32BIT_REGISTER SwType2FtqFullCnt;
+    T3_32BIT_REGISTER SwType2FtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SwType2FtqFifoWritePeek;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[736];
+} T3_FTQ, *PT3_FTQ;
+
+
+
+/******************************************************************************/
+/* Message signaled interrupt registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define MSI_MODE_RESET       BIT_0
+#define MSI_MODE_ENABLE      BIT_1
+    T3_32BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER MsiFifoAccess;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1012];
+} T3_MSG_SIGNALED_INT, *PT3_MSG_SIGNALED_INT;
+
+
+
+/******************************************************************************/
+/* DMA Completion registes. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_COMP_MODE_RESET                         BIT_0
+    #define DMA_COMP_MODE_ENABLE                        BIT_1
+
+    /* Unused space. */
+    LM_UINT8 Unused[1020];
+} T3_DMA_COMPLETION, *PT3_DMA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* GRC registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode control register. */
+    T3_32BIT_REGISTER Mode;
+    #define GRC_MODE_UPDATE_ON_COALESCING               BIT_0
+    #define GRC_MODE_BYTE_SWAP_NON_FRAME_DATA           BIT_1
+    #define GRC_MODE_WORD_SWAP_NON_FRAME_DATA           BIT_2
+    #define GRC_MODE_BYTE_SWAP_DATA                     BIT_4
+    #define GRC_MODE_WORD_SWAP_DATA                     BIT_5
+    #define GRC_MODE_SPLIT_HEADER_MODE                  BIT_8
+    #define GRC_MODE_NO_FRAME_CRACKING                  BIT_9
+    #define GRC_MODE_INCLUDE_CRC                        BIT_10
+    #define GRC_MODE_ALLOW_BAD_FRAMES                   BIT_11
+    #define GRC_MODE_NO_INTERRUPT_ON_SENDS              BIT_13
+    #define GRC_MODE_NO_INTERRUPT_ON_RECEIVE            BIT_14
+    #define GRC_MODE_FORCE_32BIT_PCI_BUS_MODE           BIT_15
+    #define GRC_MODE_HOST_STACK_UP                      BIT_16
+    #define GRC_MODE_HOST_SEND_BDS                      BIT_17
+    #define GRC_MODE_TX_NO_PSEUDO_HEADER_CHKSUM         BIT_20
+    #define GRC_MODE_RX_NO_PSEUDO_HEADER_CHKSUM         BIT_23
+    #define GRC_MODE_INT_ON_TX_CPU_ATTN                 BIT_24
+    #define GRC_MODE_INT_ON_RX_CPU_ATTN                 BIT_25
+    #define GRC_MODE_INT_ON_MAC_ATTN                    BIT_26
+    #define GRC_MODE_INT_ON_DMA_ATTN                    BIT_27
+    #define GRC_MODE_INT_ON_FLOW_ATTN                   BIT_28
+    #define GRC_MODE_4X_NIC_BASED_SEND_RINGS            BIT_29
+    #define GRC_MODE_MULTICAST_FRAME_ENABLE             BIT_30
+
+    /* Misc configuration register. */
+    T3_32BIT_REGISTER MiscCfg;
+    #define GRC_MISC_CFG_CORE_CLOCK_RESET               BIT_0
+    #define GRC_MISC_PRESCALAR_TIMER_MASK               0xfe
+    #define GRC_MISC_BD_ID_MASK                         0x0001e000
+    #define GRC_MISC_BD_ID_5700                         0x0001e000
+    #define GRC_MISC_BD_ID_5701                         0x00000000
+    #define GRC_MISC_BD_ID_5703                         0x00000000
+
+    /* Miscellaneous local control register. */
+    T3_32BIT_REGISTER LocalCtrl;
+    #define GRC_MISC_LOCAL_CTRL_INT_ACTIVE              BIT_0
+    #define GRC_MISC_LOCAL_CTRL_CLEAR_INT               BIT_1
+    #define GRC_MISC_LOCAL_CTRL_SET_INT                 BIT_2
+    #define GRC_MISC_LOCAL_CTRL_INT_ON_ATTN             BIT_3
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT0             BIT_8
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT1             BIT_9
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT2             BIT_10
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE0                BIT_11
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE1                BIT_12
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE2                BIT_13
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0            BIT_14
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1            BIT_15
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT2            BIT_16
+    #define GRC_MISC_LOCAL_CTRL_ENABLE_EXT_MEMORY       BIT_17
+    #define GRC_MISC_LOCAL_CTRL_BANK_SELECT             BIT_21
+    #define GRC_MISC_LOCAL_CTRL_SSRAM_TYPE              BIT_22
+
+    #define GRC_MISC_MEMSIZE_256K     0
+    #define GRC_MISC_MEMSIZE_512K     (1 << 18)
+    #define GRC_MISC_MEMSIZE_1024K    (2 << 18)
+    #define GRC_MISC_MEMSIZE_2048K    (3 << 18)
+    #define GRC_MISC_MEMSIZE_4096K    (4 << 18)
+    #define GRC_MISC_MEMSIZE_8192K    (5 << 18)
+    #define GRC_MISC_MEMSIZE_16M      (6 << 18)
+    #define GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM            BIT_24
+
+
+    T3_32BIT_REGISTER Timer;
+
+    T3_32BIT_REGISTER RxCpuEvent;
+    T3_32BIT_REGISTER RxTimerRef;
+    T3_32BIT_REGISTER RxCpuSemaphore;
+    T3_32BIT_REGISTER RemoteRxCpuAttn;
+
+    T3_32BIT_REGISTER TxCpuEvent;
+    T3_32BIT_REGISTER TxTimerRef;
+    T3_32BIT_REGISTER TxCpuSemaphore;
+    T3_32BIT_REGISTER RemoteTxCpuAttn;
+
+    T3_64BIT_REGISTER MemoryPowerUp;
+
+    T3_32BIT_REGISTER EepromAddr;
+    #define SEEPROM_ADDR_WRITE       0
+    #define SEEPROM_ADDR_READ        (1 << 31)
+    #define SEEPROM_ADDR_RW_MASK     0x80000000
+    #define SEEPROM_ADDR_COMPLETE    (1 << 30)
+    #define SEEPROM_ADDR_FSM_RESET   (1 << 29)
+    #define SEEPROM_ADDR_DEV_ID(x)   (x << 26)
+    #define SEEPROM_ADDR_DEV_ID_MASK 0x1c000000
+    #define SEEPROM_ADDR_START       (1 << 25)
+    #define SEEPROM_ADDR_CLK_PERD(x) (x << 16)
+    #define SEEPROM_ADDR_ADDRESS(x)  (x & 0xfffc)
+    #define SEEPROM_ADDR_ADDRESS_MASK 0x0000ffff
+    T3_32BIT_REGISTER EepromData;
+    T3_32BIT_REGISTER EepromCtrl;
+
+    T3_32BIT_REGISTER MdiCtrl;
+    T3_32BIT_REGISTER SepromDelay;
+
+    /* Unused space. */
+    LM_UINT8 Unused[948];
+} T3_GRC, *PT3_GRC;
+
+
+
+/******************************************************************************/
+/* NIC's internal memory. */
+/******************************************************************************/
+
+typedef struct {
+    /* Page zero for the internal CPUs. */
+    LM_UINT8 PageZero[0x100];               /* 0x0000 */
+
+    /* Send RCBs. */
+    T3_RCB SendRcb[16];                     /* 0x0100 */
+
+    /* Receive Return RCBs. */
+    T3_RCB RcvRetRcb[16];                   /* 0x0200 */
+
+    /* Statistics block. */
+    T3_STATS_BLOCK StatsBlk;                /* 0x0300 */
+
+    /* Status block. */
+    T3_STATUS_BLOCK StatusBlk;              /* 0x0b00 */
+
+    /* Reserved for software. */
+    LM_UINT8 Reserved[1200];                /* 0x0b50 */
+
+    /* Unmapped region. */
+    LM_UINT8 Unmapped[4096];                /* 0x1000 */
+
+    /* DMA descriptors. */
+    LM_UINT8 DmaDesc[8192];                 /* 0x2000 */
+
+    /* Buffer descriptors. */
+    LM_UINT8 BufferDesc[16384];             /* 0x4000 */
+} T3_FIRST_32K_SRAM, *PT3_FIRST_32K_SRAM;
+
+
+
+/******************************************************************************/
+/* Memory layout. */
+/******************************************************************************/
+
+typedef struct {
+    /* PCI configuration registers. */
+    T3_PCI_CONFIGURATION PciCfg;
+
+    /* Unused. */
+    LM_UINT8 Unused1[0x100];                            /* 0x0100 */
+
+    /* Mailbox . */
+    T3_MAILBOX Mailbox;                                 /* 0x0200 */
+
+    /* MAC control registers. */
+    T3_MAC_CONTROL MacCtrl;                             /* 0x0400 */
+
+    /* Send data initiator control registers. */
+    T3_SEND_DATA_INITIATOR SndDataIn;                   /* 0x0c00 */
+
+    /* Send data completion Control registers. */
+    T3_SEND_DATA_COMPLETION SndDataComp;                /* 0x1000 */
+
+    /* Send BD ring selector. */
+    T3_SEND_BD_SELECTOR SndBdSel;                       /* 0x1400 */
+
+    /* Send BD initiator control registers. */
+    T3_SEND_BD_INITIATOR SndBdIn;                       /* 0x1800 */
+
+    /* Send BD completion control registers. */
+    T3_SEND_BD_COMPLETION SndBdComp;                    /* 0x1c00 */
+
+    /* Receive list placement control registers. */
+    T3_RCV_LIST_PLACEMENT RcvListPlmt;                  /* 0x2000 */
+
+    /* Receive Data and Receive BD Initiator Control. */
+    T3_RCV_DATA_BD_INITIATOR RcvDataBdIn;               /* 0x2400 */
+
+    /* Receive Data Completion Control */
+    T3_RCV_DATA_COMPLETION RcvDataComp;                 /* 0x2800 */
+
+    /* Receive BD Initiator Control Registers. */
+    T3_RCV_BD_INITIATOR RcvBdIn;                        /* 0x2c00 */
+
+    /* Receive BD Completion Control Registers. */
+    T3_RCV_BD_COMPLETION RcvBdComp;                     /* 0x3000 */
+
+    /* Receive list selector control registers. */
+    T3_RCV_LIST_SELECTOR RcvListSel;                    /* 0x3400 */
+
+    /* Mbuf cluster free registers. */
+    T3_MBUF_CLUSTER_FREE MbufClusterFree;               /* 0x3800 */
+
+    /* Host coalescing control registers. */
+    T3_HOST_COALESCING HostCoalesce;                    /* 0x3c00 */
+
+    /* Memory arbiter control registers. */
+    T3_MEM_ARBITER MemArbiter;                          /* 0x4000 */
+    
+    /* Buffer manger control registers. */
+    T3_BUFFER_MANAGER BufMgr;                           /* 0x4400 */
+
+    /* Read DMA control registers. */
+    T3_DMA_READ DmaRead;                                /* 0x4800 */
+
+    /* Write DMA control registers. */
+    T3_DMA_WRITE DmaWrite;                              /* 0x4c00 */
+
+    T3_CPU rxCpu;                                       /* 0x5000 */
+    T3_CPU txCpu;                                       /* 0x5400 */
+
+    /* Mailboxes. */
+    T3_GRC_MAILBOX GrcMailbox;                          /* 0x5800 */
+
+    /* Flow Through queues. */
+    T3_FTQ Ftq;                                         /* 0x5c00 */
+
+    /* Message signaled interrupt registes. */
+    T3_MSG_SIGNALED_INT Msi;                            /* 0x6000 */
+
+    /* DMA completion registers. */
+    T3_DMA_COMPLETION DmaComp;                          /* 0x6400 */
+
+    /* GRC registers. */
+    T3_GRC Grc;                                         /* 0x6800 */
+
+    /* Unused space. */
+    LM_UINT8 Unused[5120];                              /* 0x6c00 */
+
+    /* The 32k memory window into the NIC's */
+    /* internal memory.  The memory window is */
+    /* controlled by the Memory Window Base */
+    /* Address register.  This register is located */
+    /* in the PCI configuration space. */
+    union {                                             /* 0x8000 */
+        T3_FIRST_32K_SRAM First32k;
+
+        /* Use the memory window base address register to determine the */
+        /* MBUF segment. */
+        LM_UINT32 Mbuf[32768/4];
+        LM_UINT32 MemBlock32K[32768/4];
+    } uIntMem;
+} T3_STD_MEM_MAP, *PT3_STD_MEM_MAP;
+
+
+/******************************************************************************/
+/* Adapter info. */
+/******************************************************************************/
+
+typedef struct
+{
+    LM_UINT16 Svid;
+    LM_UINT16 Ssid;
+    LM_UINT32 PhyId;
+    LM_UINT32 Serdes;   /* 0 = copper PHY, 1 = Serdes */
+} LM_ADAPTER_INFO, *PLM_ADAPTER_INFO;
+
+
+/******************************************************************************/
+/* Packet queues. */
+/******************************************************************************/
+
+DECLARE_QUEUE_TYPE(LM_RX_PACKET_Q, MAX_RX_PACKET_DESC_COUNT);
+DECLARE_QUEUE_TYPE(LM_TX_PACKET_Q, MAX_TX_PACKET_DESC_COUNT);
+
+
+
+/******************************************************************************/
+/* Tx counters. */
+/******************************************************************************/
+
+typedef struct {
+    LM_COUNTER TxPacketGoodCnt;
+    LM_COUNTER TxBytesGoodCnt;
+    LM_COUNTER TxPacketAbortedCnt;
+    LM_COUNTER NoSendBdLeftCnt;
+    LM_COUNTER NoMapRegisterLeftCnt;
+    LM_COUNTER TooManyFragmentsCnt;
+    LM_COUNTER NoTxPacketDescCnt;
+} LM_TX_COUNTERS, *PLM_TX_COUNTERS;
+
+
+
+/******************************************************************************/
+/* Rx counters. */
+/******************************************************************************/
+
+typedef struct {
+    LM_COUNTER RxPacketGoodCnt;
+    LM_COUNTER RxBytesGoodCnt;
+    LM_COUNTER RxPacketErrCnt;
+    LM_COUNTER RxErrCrcCnt;
+    LM_COUNTER RxErrCollCnt;
+    LM_COUNTER RxErrLinkLostCnt;
+    LM_COUNTER RxErrPhyDecodeCnt;
+    LM_COUNTER RxErrOddNibbleCnt;
+    LM_COUNTER RxErrMacAbortCnt;
+    LM_COUNTER RxErrShortPacketCnt;
+    LM_COUNTER RxErrNoResourceCnt;
+    LM_COUNTER RxErrLargePacketCnt;
+} LM_RX_COUNTERS, *PLM_RX_COUNTERS;
+
+
+
+/******************************************************************************/
+/* Receive producer rings. */
+/******************************************************************************/
+
+typedef enum {
+    T3_UNKNOWN_RCV_PROD_RING    = 0,
+    T3_STD_RCV_PROD_RING        = 1,
+    T3_JUMBO_RCV_PROD_RING      = 3
+} T3_RCV_PROD_RING, *PT3_RCV_PROD_RING;
+
+
+
+/******************************************************************************/
+/* Packet descriptor. */
+/******************************************************************************/
+
+#define LM_PACKET_SIGNATURE_TX              0x6861766b
+#define LM_PACKET_SIGNATURE_RX              0x6b766168
+
+typedef struct _LM_PACKET {
+    /* Set in LM. */
+    LM_STATUS PacketStatus;
+
+    /* Set in LM for Rx, in UM for Tx. */
+    LM_UINT32 PacketSize;
+
+    LM_UINT16 Flags;
+
+#define LM_VALID_VLAN_TAG                   (1 << 0)
+#define LM_VALID_IP_CHKSUM_FIELD            (1 << 1)
+#define LM_VALID_TCP_UDP_CHKSUM_FIELD       (1 << 2)
+#define LM_TCP_PACKET                       (1 << 3)
+#define LM_DONT_GEN_CRC                     (1 << 4)
+#define LM_TCP_SEGMENTATION                 (1 << 5)
+
+    LM_UINT16 VlanTag;
+
+    union {
+        /* Send info. */
+        struct {
+            /* Set up by UM. */
+            LM_UINT32 FragCount;
+
+            /* Checksum offload info. */
+            LM_TASK_OFFLOAD TaskOffload;
+
+            /* Double copy buffer for coalescing transmit buffer fragments. */
+            PLM_UINT8 pTxCopyBufferVirt;
+            LM_PHYSICAL_ADDRESS TxCopyBufferPhy;
+
+            /* Fragment buffer for MM_StartTxDma to fill in. */
+            PLM_FRAG_LIST pFraglist;
+        } Tx;
+
+        /* Receive info. */
+        struct {
+            /* This descriptor belongs to either Std, Mini, or Jumbo ring. */
+            T3_RCV_PROD_RING RcvProdRing;
+
+            /* Receive buffer size */
+            LM_UINT32 RxBufferSize;
+
+            /* Virtual and physical address of the receive buffer. */
+            PLM_UINT8 pRxBufferVirt;
+            LM_PHYSICAL_ADDRESS RxBufferPhy;
+            
+            /* Checksum information. */
+            LM_UINT16 IpChecksum;
+            LM_UINT16 TcpUdpChecksum;
+        } Rx;
+    } u;
+} LM_PACKET;
+
+
+
+/******************************************************************************/
+/* Tigon3 device block. */
+/******************************************************************************/
+
+typedef struct _LM_DEVICE_BLOCK {
+    /* Memory view. */
+    PT3_STD_MEM_MAP pMemView;
+
+    /* Base address of the block of memory in which the LM_PACKET descriptors */
+    /* are allocated from. */
+    PLM_VOID pPacketDescBase;
+
+    LM_UINT32 MiscHostCtrl;
+    LM_UINT32 GrcLocalCtrl;
+    LM_UINT32 DmaReadWriteCtrl;
+    LM_UINT32 PciState;
+
+    /* Rx info */
+    LM_UINT32 RxStdDescCnt;
+    LM_UINT32 RxStdQueuedCnt;
+    LM_UINT32 RxStdProdIdx;
+
+    PT3_RCV_BD pRxStdBdVirt;
+    LM_PHYSICAL_ADDRESS RxStdBdPhy;
+
+    LM_UINT32 RxPacketDescCnt;
+    LM_RX_PACKET_Q RxPacketFreeQ;
+    LM_RX_PACKET_Q RxPacketReceivedQ;
+
+    /* Receive info. */
+    PT3_RCV_BD pRcvRetBdVirt;
+    LM_PHYSICAL_ADDRESS RcvRetBdPhy;
+    LM_UINT32 RcvRetConIdx;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    LM_UINT32 RxJumboDescCnt;
+    LM_UINT32 RxJumboBufferSize;
+    LM_UINT32 RxJumboQueuedCnt;
+
+    LM_UINT32 RxJumboProdIdx;
+
+    PT3_RCV_BD pRxJumboBdVirt;
+    LM_PHYSICAL_ADDRESS RxJumboBdPhy;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* These values are used by the upper module to inform the protocol */
+    /* of the maximum transmit/receive packet size. */
+    LM_UINT32 TxMtu;    /* Does not include CRC. */
+    LM_UINT32 RxMtu;    /* Does not include CRC. */
+
+    /* We need to shadow the EMAC, Rx, Tx mode registers.  With B0 silicon, */
+    /* we may have problems reading any MAC registers in 10mb mode. */
+    LM_UINT32 MacMode;
+    LM_UINT32 RxMode;
+    LM_UINT32 TxMode;
+
+    /* MiMode register. */
+    LM_UINT32 MiMode;
+
+    /* Host coalesce mode register. */
+    LM_UINT32 CoalesceMode;
+
+    /* Send info. */
+    LM_UINT32 TxPacketDescCnt;
+
+    /* Tx info. */
+    LM_TX_PACKET_Q TxPacketFreeQ;
+    LM_TX_PACKET_Q TxPacketActiveQ;
+    LM_TX_PACKET_Q TxPacketXmittedQ;
+
+    /* Pointers to SendBd. */
+    PT3_SND_BD pSendBdVirt;
+    LM_PHYSICAL_ADDRESS SendBdPhy;  /* Only valid for Host based Send BD. */
+
+    /* Send producer and consumer indices. */
+    LM_UINT32 SendProdIdx;
+    LM_UINT32 SendConIdx;
+
+    /* Number of BD left. */
+    atomic_t SendBdLeft;
+
+    T3_SND_BD ShadowSendBd[T3_SEND_RCB_ENTRY_COUNT];
+
+    /* The size of pre-allocated transmit buffers used for coalescing */
+    /* physical buffer fragments. */
+    LM_UINT32 TxCopyBufferSize;
+
+    /* Counters. */
+    LM_RX_COUNTERS RxCounters;
+    LM_TX_COUNTERS TxCounters;
+
+    /* Host coalescing parameters. */
+    LM_UINT32 RxCoalescingTicks;
+    LM_UINT32 TxCoalescingTicks;
+    LM_UINT32 RxMaxCoalescedFrames;
+    LM_UINT32 TxMaxCoalescedFrames;
+    LM_UINT32 StatsCoalescingTicks;
+    LM_UINT32 RxCoalescingTicksDuringInt;
+    LM_UINT32 TxCoalescingTicksDuringInt;
+    LM_UINT32 RxMaxCoalescedFramesDuringInt;
+    LM_UINT32 TxMaxCoalescedFramesDuringInt;
+
+    /* DMA water marks. */
+    LM_UINT32 DmaMbufLowMark;
+    LM_UINT32 RxMacMbufLowMark;
+    LM_UINT32 MbufHighMark;
+
+    /* Status block. */
+    PT3_STATUS_BLOCK pStatusBlkVirt;
+    LM_PHYSICAL_ADDRESS StatusBlkPhy;
+
+    /* Statistics block. */
+    PT3_STATS_BLOCK pStatsBlkVirt;
+    LM_PHYSICAL_ADDRESS StatsBlkPhy;
+
+    /* Current receive mask. */
+    LM_UINT32 ReceiveMask;
+
+    /* Task offload capabilities. */
+    LM_TASK_OFFLOAD TaskOffloadCap;
+
+    /* Task offload selected. */
+    LM_TASK_OFFLOAD TaskToOffload;
+
+    /* Wake up capability. */
+    LM_WAKE_UP_MODE WakeUpModeCap;
+
+    /* Wake up capability. */
+    LM_WAKE_UP_MODE WakeUpMode;
+
+    /* Flow control. */
+    LM_FLOW_CONTROL FlowControlCap;
+    LM_FLOW_CONTROL FlowControl;
+
+    /* Enable or disable PCI NWI. */
+    LM_UINT32 EnableNWI;
+
+    /* Enable 5701 tagged status mode. */
+    LM_UINT32 UseTaggedStatus;
+
+    /* NIC will not compute the pseudo header checksum.  The driver or OS */
+    /* must seed the checksum field with the pseudo checksum. */
+    LM_UINT32 NoTxPseudoHdrChksum;
+
+    /* The receive checksum in the BD does not include the pseudo checksum. */
+    /* The OS or the driver must calculate the pseudo checksum and add it to */
+    /* the checksum in the BD. */
+    LM_UINT32 NoRxPseudoHdrChksum;
+
+    /* Current node address. */
+    LM_UINT8 NodeAddress[8];
+
+    /* The adapter's node address. */
+    LM_UINT8 PermanentNodeAddress[8];
+
+    /* Adapter info. */
+    LM_UINT16 BusNum;               // Init by the upper module.
+    LM_UINT8 DevNum;                // Init by the upper module.
+    LM_UINT8 FunctNum;              // Init by the upper module.
+    LM_UINT16 PciVendorId;
+    LM_UINT16 PciDeviceId;
+    LM_UINT8 Irq;
+    LM_UINT8 IntPin;
+    LM_UINT8 CacheLineSize;
+    LM_UINT8 PciRevId;
+#if PCIX_TARGET_WORKAROUND
+	LM_UINT32 EnablePciXFix;
+#endif
+	LM_UINT32 PciCommandStatusWords;
+    LM_UINT32 ChipRevId;
+    LM_UINT16 SubsystemVendorId;
+    LM_UINT16 SubsystemId;
+    LM_UINT32 MemBaseLow;
+    LM_UINT32 MemBaseHigh;
+    LM_UINT32 MemBaseSize;
+    PLM_UINT8 pMappedMemBase;
+
+    /* Saved PCI configuration registers for restoring after a reset. */
+    LM_UINT32 SavedCacheLineReg;
+
+    /* Phy info. */
+    LM_UINT32 PhyAddr;
+    LM_UINT32 PhyId;
+
+    /* Requested phy settings. */
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType;
+
+    /* Disable auto-negotiation. */
+    LM_UINT32 DisableAutoNeg;
+
+    /* Ways for the MAC to get link change interrupt. */
+    LM_UINT32 PhyIntMode;
+    #define T3_PHY_INT_MODE_AUTO                        0
+    #define T3_PHY_INT_MODE_MI_INTERRUPT                1
+    #define T3_PHY_INT_MODE_LINK_READY                  2
+    #define T3_PHY_INT_MODE_AUTO_POLLING                3
+
+    /* Ways to determine link change status. */
+    LM_UINT32 LinkChngMode;
+    #define T3_LINK_CHNG_MODE_AUTO                      0
+    #define T3_LINK_CHNG_MODE_USE_STATUS_REG            1
+    #define T3_LINK_CHNG_MODE_USE_STATUS_BLOCK          2
+
+    LM_UINT32 Bcm540xMode;
+    #define BCM540X_MODE_AUTO                           0
+    #define BCM540X_MODE_THREE_LINK                     1
+    #define BCM540X_MODE_LINK10                         2
+
+    /* WOL Speed */
+    LM_UINT32 WolSpeed;
+    #define WOL_SPEED_10MB                              1
+    #define WOL_SPEED_100MB                             2
+
+    /* Reset the PHY on initialization. */
+    LM_UINT32 ResetPhyOnInit;
+
+    LM_UINT32 RestoreOnWakeUp;
+    LM_REQUESTED_MEDIA_TYPE WakeUpRequestedMediaType;
+    LM_UINT32 WakeUpDisableAutoNeg;
+
+    /* Current phy settings. */
+    LM_MEDIA_TYPE MediaType;
+    LM_LINE_SPEED LineSpeed;
+    LM_LINE_SPEED OldLineSpeed;
+    LM_DUPLEX_MODE DuplexMode;
+    LM_STATUS LinkStatus;
+
+    /* Multicast address list. */
+    LM_UINT32 McEntryCount;
+    LM_UINT8 McTable[LM_MAX_MC_TABLE_SIZE][LM_MC_ENTRY_SIZE];
+
+    /* Use NIC or Host based send BD. */
+    LM_UINT32 NicSendBd;
+
+    /* Athlon fix. */
+    LM_UINT32 DelayPciGrant;
+
+    /* Init flag. */
+    LM_BOOL InitDone;
+
+    /* Shutdown flag.  Set by the upper module. */
+    LM_BOOL ShuttingDown;
+
+    /* Flag to determine whether to call LM_QueueRxPackets or not in */
+    /* LM_ResetAdapter routine. */
+    LM_BOOL QueueRxPackets;
+
+    LM_UINT32 MbufBase;
+    LM_UINT32 MbufSize;
+
+    /* TRUE if we have a SERDES PHY. */
+    LM_UINT32 EnableTbi;
+
+#if INCLUDE_TBI_SUPPORT
+    /* Autoneg state info. */
+    AN_STATE_INFO AnInfo;
+#endif
+    char PartNo[24];
+    LM_UINT32 PhyCrcCount;
+} LM_DEVICE_BLOCK;
+
+
+#define T3_REG_CPU_VIEW               0xc0000000
+
+#define T3_BLOCK_DMA_RD               (1 << 0)
+#define T3_BLOCK_DMA_COMP             (1 << 1)
+#define T3_BLOCK_RX_BD_INITIATOR      (1 << 2)
+#define T3_BLOCK_RX_BD_COMP           (1 << 3)
+#define T3_BLOCK_DMA_WR               (1 << 4)
+#define T3_BLOCK_MSI_HANDLER          (1 << 5)
+#define T3_BLOCK_RX_LIST_PLMT         (1 << 6)
+#define T3_BLOCK_RX_LIST_SELECTOR     (1 << 7)
+#define T3_BLOCK_RX_DATA_INITIATOR    (1 << 8)
+#define T3_BLOCK_RX_DATA_COMP         (1 << 9)
+#define T3_BLOCK_HOST_COALESING       (1 << 10)
+#define T3_BLOCK_MAC_RX_ENGINE        (1 << 11)
+#define T3_BLOCK_MBUF_CLUSTER_FREE    (1 << 12)
+#define T3_BLOCK_SEND_BD_INITIATOR    (1 << 13)
+#define T3_BLOCK_SEND_BD_COMP         (1 << 14)
+#define T3_BLOCK_SEND_BD_SELECTOR     (1 << 15)
+#define T3_BLOCK_SEND_DATA_INITIATOR  (1 << 16)
+#define T3_BLOCK_SEND_DATA_COMP       (1 << 17)
+#define T3_BLOCK_MAC_TX_ENGINE        (1 << 18)
+#define T3_BLOCK_MEM_ARBITOR          (1 << 19)
+#define T3_BLOCK_MBUF_MANAGER         (1 << 20)
+#define T3_BLOCK_MAC_GLOBAL           (1 << 21)
+
+#define LM_ENABLE               1
+#define LM_DISABLE              2
+
+#define RX_CPU_EVT_SW0              0
+#define RX_CPU_EVT_SW1              1
+#define RX_CPU_EVT_RLP              2
+#define RX_CPU_EVT_SW3              3
+#define RX_CPU_EVT_RLS              4
+#define RX_CPU_EVT_SW4              5
+#define RX_CPU_EVT_RX_BD_COMP       6
+#define RX_CPU_EVT_SW5              7
+#define RX_CPU_EVT_RDI              8
+#define RX_CPU_EVT_DMA_WR           9
+#define RX_CPU_EVT_DMA_RD           10
+#define RX_CPU_EVT_SWQ              11
+#define RX_CPU_EVT_SW6              12
+#define RX_CPU_EVT_RDC              13
+#define RX_CPU_EVT_SW7              14
+#define RX_CPU_EVT_HOST_COALES      15
+#define RX_CPU_EVT_SW8              16
+#define RX_CPU_EVT_HIGH_DMA_WR      17
+#define RX_CPU_EVT_HIGH_DMA_RD      18
+#define RX_CPU_EVT_SW9              19
+#define RX_CPU_EVT_DMA_ATTN         20
+#define RX_CPU_EVT_LOW_P_MBOX       21
+#define RX_CPU_EVT_HIGH_P_MBOX      22
+#define RX_CPU_EVT_SW10             23
+#define RX_CPU_EVT_TX_CPU_ATTN      24
+#define RX_CPU_EVT_MAC_ATTN         25
+#define RX_CPU_EVT_RX_CPU_ATTN      26
+#define RX_CPU_EVT_FLOW_ATTN        27
+#define RX_CPU_EVT_SW11             28
+#define RX_CPU_EVT_TIMER            29
+#define RX_CPU_EVT_SW12             30
+#define RX_CPU_EVT_SW13             31
+
+/* RX-CPU event */
+#define RX_CPU_EVENT_SW_EVENT0      (1 << RX_CPU_EVT_SW0)
+#define RX_CPU_EVENT_SW_EVENT1      (1 << RX_CPU_EVT_SW1)
+#define RX_CPU_EVENT_RLP            (1 << RX_CPU_EVT_RLP)
+#define RX_CPU_EVENT_SW_EVENT3      (1 << RX_CPU_EVT_SW3)
+#define RX_CPU_EVENT_RLS            (1 << RX_CPU_EVT_RLS)
+#define RX_CPU_EVENT_SW_EVENT4      (1 << RX_CPU_EVT_SW4)
+#define RX_CPU_EVENT_RX_BD_COMP     (1 << RX_CPU_EVT_RX_BD_COMP)
+#define RX_CPU_EVENT_SW_EVENT5      (1 << RX_CPU_EVT_SW5)
+#define RX_CPU_EVENT_RDI            (1 << RX_CPU_EVT_RDI)
+#define RX_CPU_EVENT_DMA_WR         (1 << RX_CPU_EVT_DMA_WR)
+#define RX_CPU_EVENT_DMA_RD         (1 << RX_CPU_EVT_DMA_RD)
+#define RX_CPU_EVENT_SWQ            (1 << RX_CPU_EVT_SWQ)
+#define RX_CPU_EVENT_SW_EVENT6      (1 << RX_CPU_EVT_SW6)
+#define RX_CPU_EVENT_RDC            (1 << RX_CPU_EVT_RDC)
+#define RX_CPU_EVENT_SW_EVENT7      (1 << RX_CPU_EVT_SW7)
+#define RX_CPU_EVENT_HOST_COALES    (1 << RX_CPU_EVT_HOST_COALES)
+#define RX_CPU_EVENT_SW_EVENT8      (1 << RX_CPU_EVT_SW8)
+#define RX_CPU_EVENT_HIGH_DMA_WR    (1 << RX_CPU_EVT_HIGH_DMA_WR)
+#define RX_CPU_EVENT_HIGH_DMA_RD    (1 << RX_CPU_EVT_HIGH_DMA_RD)
+#define RX_CPU_EVENT_SW_EVENT9      (1 << RX_CPU_EVT_SW9)
+#define RX_CPU_EVENT_DMA_ATTN       (1 << RX_CPU_EVT_DMA_ATTN)
+#define RX_CPU_EVENT_LOW_P_MBOX     (1 << RX_CPU_EVT_LOW_P_MBOX)
+#define RX_CPU_EVENT_HIGH_P_MBOX    (1 << RX_CPU_EVT_HIGH_P_MBOX)
+#define RX_CPU_EVENT_SW_EVENT10     (1 << RX_CPU_EVT_SW10)
+#define RX_CPU_EVENT_TX_CPU_ATTN    (1 << RX_CPU_EVT_TX_CPU_ATTN)
+#define RX_CPU_EVENT_MAC_ATTN       (1 << RX_CPU_EVT_MAC_ATTN)
+#define RX_CPU_EVENT_RX_CPU_ATTN    (1 << RX_CPU_EVT_RX_CPU_ATTN)
+#define RX_CPU_EVENT_FLOW_ATTN      (1 << RX_CPU_EVT_FLOW_ATTN)
+#define RX_CPU_EVENT_SW_EVENT11     (1 << RX_CPU_EVT_SW11)
+#define RX_CPU_EVENT_TIMER          (1 << RX_CPU_EVT_TIMER)
+#define RX_CPU_EVENT_SW_EVENT12     (1 << RX_CPU_EVT_SW12)
+#define RX_CPU_EVENT_SW_EVENT13     (1 << RX_CPU_EVT_SW13)
+
+#define RX_CPU_MASK (RX_CPU_EVENT_SW_EVENT0 | \
+		     RX_CPU_EVENT_RLP | \
+		     RX_CPU_EVENT_RDI | \
+		     RX_CPU_EVENT_RDC)
+
+#define TX_CPU_EVT_SW0              0
+#define TX_CPU_EVT_SW1              1
+#define TX_CPU_EVT_SW2              2
+#define TX_CPU_EVT_SW3              3
+#define TX_CPU_EVT_TX_MAC           4
+#define TX_CPU_EVT_SW4              5
+#define TX_CPU_EVT_SBDC             6
+#define TX_CPU_EVT_SW5              7
+#define TX_CPU_EVT_SDI              8
+#define TX_CPU_EVT_DMA_WR           9
+#define TX_CPU_EVT_DMA_RD           10
+#define TX_CPU_EVT_SWQ              11
+#define TX_CPU_EVT_SW6              12
+#define TX_CPU_EVT_SDC              13
+#define TX_CPU_EVT_SW7              14
+#define TX_CPU_EVT_HOST_COALES      15
+#define TX_CPU_EVT_SW8              16
+#define TX_CPU_EVT_HIGH_DMA_WR      17
+#define TX_CPU_EVT_HIGH_DMA_RD      18
+#define TX_CPU_EVT_SW9              19
+#define TX_CPU_EVT_DMA_ATTN         20
+#define TX_CPU_EVT_LOW_P_MBOX       21
+#define TX_CPU_EVT_HIGH_P_MBOX      22
+#define TX_CPU_EVT_SW10             23
+#define TX_CPU_EVT_RX_CPU_ATTN      24
+#define TX_CPU_EVT_MAC_ATTN         25
+#define TX_CPU_EVT_TX_CPU_ATTN      26
+#define TX_CPU_EVT_FLOW_ATTN        27
+#define TX_CPU_EVT_SW11             28
+#define TX_CPU_EVT_TIMER            29
+#define TX_CPU_EVT_SW12             30
+#define TX_CPU_EVT_SW13             31
+
+
+/* TX-CPU event */
+#define TX_CPU_EVENT_SW_EVENT0      (1 << TX_CPU_EVT_SW0)
+#define TX_CPU_EVENT_SW_EVENT1      (1 << TX_CPU_EVT_SW1)
+#define TX_CPU_EVENT_SW_EVENT2      (1 << TX_CPU_EVT_SW2)
+#define TX_CPU_EVENT_SW_EVENT3      (1 << TX_CPU_EVT_SW3)
+#define TX_CPU_EVENT_TX_MAC         (1 << TX_CPU_EVT_TX_MAC)
+#define TX_CPU_EVENT_SW_EVENT4      (1 << TX_CPU_EVT_SW4)
+#define TX_CPU_EVENT_SBDC           (1 << TX_CPU_EVT_SBDC)
+#define TX_CPU_EVENT_SW_EVENT5      (1 << TX_CPU_EVT_SW5)
+#define TX_CPU_EVENT_SDI            (1 << TX_CPU_EVT_SDI)
+#define TX_CPU_EVENT_DMA_WR         (1 << TX_CPU_EVT_DMA_WR)
+#define TX_CPU_EVENT_DMA_RD         (1 << TX_CPU_EVT_DMA_RD)
+#define TX_CPU_EVENT_SWQ            (1 << TX_CPU_EVT_SWQ)
+#define TX_CPU_EVENT_SW_EVENT6      (1 << TX_CPU_EVT_SW6)
+#define TX_CPU_EVENT_SDC            (1 << TX_CPU_EVT_SDC)
+#define TX_CPU_EVENT_SW_EVENT7      (1 << TX_CPU_EVT_SW7)
+#define TX_CPU_EVENT_HOST_COALES    (1 << TX_CPU_EVT_HOST_COALES)
+#define TX_CPU_EVENT_SW_EVENT8      (1 << TX_CPU_EVT_SW8)
+#define TX_CPU_EVENT_HIGH_DMA_WR    (1 << TX_CPU_EVT_HIGH_DMA_WR)
+#define TX_CPU_EVENT_HIGH_DMA_RD    (1 << TX_CPU_EVT_HIGH_DMA_RD)
+#define TX_CPU_EVENT_SW_EVENT9      (1 << TX_CPU_EVT_SW9)
+#define TX_CPU_EVENT_DMA_ATTN       (1 << TX_CPU_EVT_DMA_ATTN)
+#define TX_CPU_EVENT_LOW_P_MBOX     (1 << TX_CPU_EVT_LOW_P_MBOX)
+#define TX_CPU_EVENT_HIGH_P_MBOX    (1 << TX_CPU_EVT_HIGH_P_MBOX)
+#define TX_CPU_EVENT_SW_EVENT10     (1 << TX_CPU_EVT_SW10)
+#define TX_CPU_EVENT_RX_CPU_ATTN    (1 << TX_CPU_EVT_RX_CPU_ATTN)
+#define TX_CPU_EVENT_MAC_ATTN       (1 << TX_CPU_EVT_MAC_ATTN)
+#define TX_CPU_EVENT_TX_CPU_ATTN    (1 << TX_CPU_EVT_TX_CPU_ATTN)
+#define TX_CPU_EVENT_FLOW_ATTN      (1 << TX_CPU_EVT_FLOW_ATTN)
+#define TX_CPU_EVENT_SW_EVENT11     (1 << TX_CPU_EVT_SW11)
+#define TX_CPU_EVENT_TIMER          (1 << TX_CPU_EVT_TIMER)
+#define TX_CPU_EVENT_SW_EVENT12     (1 << TX_CPU_EVT_SW12)
+#define TX_CPU_EVENT_SW_EVENT13     (1 << TX_CPU_EVT_SW13)
+
+
+#define TX_CPU_MASK (TX_CPU_EVENT_SW_EVENT0 | \
+		     TX_CPU_EVENT_SDI  | \
+		     TX_CPU_EVENT_SDC)
+
+
+#define T3_FTQ_TYPE1_UNDERFLOW_BIT   (1 << 29)
+#define T3_FTQ_TYPE1_PASS_BIT        (1 << 30)
+#define T3_FTQ_TYPE1_SKIP_BIT        (1 << 31)
+
+#define T3_FTQ_TYPE2_UNDERFLOW_BIT   (1 << 13)
+#define T3_FTQ_TYPE2_PASS_BIT        (1 << 14)
+#define T3_FTQ_TYPE2_SKIP_BIT        (1 << 15)
+
+#define T3_QID_DMA_READ               1
+#define T3_QID_DMA_HIGH_PRI_READ      2
+#define T3_QID_DMA_COMP_DX            3
+#define T3_QID_SEND_BD_COMP           4
+#define T3_QID_SEND_DATA_INITIATOR    5
+#define T3_QID_DMA_WRITE              6
+#define T3_QID_DMA_HIGH_PRI_WRITE     7
+#define T3_QID_SW_TYPE_1              8
+#define T3_QID_SEND_DATA_COMP         9
+#define T3_QID_HOST_COALESCING        10
+#define T3_QID_MAC_TX                 11
+#define T3_QID_MBUF_CLUSTER_FREE      12
+#define T3_QID_RX_BD_COMP             13
+#define T3_QID_RX_LIST_PLM            14
+#define T3_QID_RX_DATA_BD_INITIATOR   15
+#define T3_QID_RX_DATA_COMP           16
+#define T3_QID_SW_TYPE2               17
+
+
+/******************************************************************************/
+/* NIC register read/write macros. */
+/******************************************************************************/
+
+/* MAC register access. */
+LM_UINT32 LM_RegRdInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Register);
+LM_VOID LM_RegWrInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Register,
+    LM_UINT32 Value32);
+
+/* MAC memory access. */
+LM_UINT32 LM_MemRdInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 MemAddr);
+LM_VOID LM_MemWrInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 MemAddr,
+    LM_UINT32 Value32);
+
+#if PCIX_TARGET_WORKAROUND
+
+/* use memor-mapped accesses for mailboxes and reads, UNDI accesses
+   for writes to all other registers */
+#define REG_RD(pDevice, OffsetName)                                         \
+    (pDevice)->pMemView->OffsetName
+
+#define REG_WR(pDevice, OffsetName, Value32)                                \
+	(((OFFSETOF(T3_STD_MEM_MAP, OffsetName) >=0x200 ) &&					\
+	  (OFFSETOF(T3_STD_MEM_MAP, OffsetName) <0x400)) ||						\
+	 ((pDevice)->EnablePciXFix == FALSE)) ?	   								\
+    (void) ((pDevice)->pMemView->OffsetName = Value32) :							\
+    LM_RegWrInd(pDevice, OFFSETOF(T3_STD_MEM_MAP, OffsetName), Value32)
+
+#define MB_REG_RD(pDevice, OffsetName)                                      \
+    (pDevice)->pMemView->OffsetName
+
+#define MB_REG_WR(pDevice, OffsetName, Value32)                             \
+    (pDevice)->pMemView->OffsetName = Value32
+
+#define REG_RD_OFFSET(pDevice, Offset)                                      \
+    *((LM_UINT32 *) (pDevice)->pMemView + Offset/sizeof(LM_UINT32))
+
+#define REG_WR_OFFSET(pDevice, Offset, Value32)                             \
+	(((Offset >=0x200 ) && (Offset < 0x400)) ||								\
+	 ((pDevice)->EnablePciXFix == FALSE)) ?	   								\
+    (void) (*((LM_UINT32 *) (pDevice)->pMemView + Offset/sizeof(LM_UINT32)) = Value32) : \
+    LM_RegWrInd(pDevice, Offset, Value32)
+
+#define MEM_RD(pDevice, AddrName)                                           \
+    LM_MemRdInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName))
+#define MEM_WR(pDevice, AddrName, Value32)                                  \
+    LM_MemWrInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName), Value32)
+
+#define MEM_RD_OFFSET(pDevice, Offset)                                      \
+    LM_MemRdInd(pDevice, Offset)
+#define MEM_WR_OFFSET(pDevice, Offset, Value32)                             \
+    LM_MemWrInd(pDevice, Offset, Value32)
+				
+#else /* normal target access path below */
+
+/* Register access. */
+#define REG_RD(pDevice, OffsetName)                                         \
+    (pDevice)->pMemView->OffsetName
+#define REG_WR(pDevice, OffsetName, Value32)                                \
+    (pDevice)->pMemView->OffsetName = Value32
+
+#define REG_RD_OFFSET(pDevice, Offset)                                      \
+    *((LM_UINT32 *) (pDevice)->pMemView + Offset/sizeof(LM_UINT32))
+#define REG_WR_OFFSET(pDevice, Offset, Value32)                             \
+    (*((LM_UINT32 *) (pDevice)->pMemView + Offset/sizeof(LM_UINT32)) = Value32)
+
+
+/* There could be problem access the memory window directly.  For now, */
+/* we have to go through the PCI configuration register. */
+#define MEM_RD(pDevice, AddrName)                                           \
+    LM_MemRdInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName))
+#define MEM_WR(pDevice, AddrName, Value32)                                  \
+    LM_MemWrInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName), Value32)
+
+#define MEM_RD_OFFSET(pDevice, Offset)                                      \
+    LM_MemRdInd(pDevice, Offset)
+#define MEM_WR_OFFSET(pDevice, Offset, Value32)                             \
+    LM_MemWrInd(pDevice, Offset, Value32)
+
+#endif  /* PCIX_TARGET_WORKAROUND */
+
+#endif /* TIGON3_H */
+
diff -urN linux.orig/drivers/net/eepro100.c linux/drivers/net/eepro100.c
--- linux.orig/drivers/net/eepro100.c	Mon Jul  2 15:03:04 2001
+++ linux/drivers/net/eepro100.c	Mon Dec 17 20:27:41 2001
@@ -25,6 +25,8 @@
 		Disabled FC and ER, to avoid lockups when when we get FCP interrupts.
 	2000 Jul 17 Goutham Rao <goutham.rao@intel.com>
 		PCI DMA API fixes, adding pci_dma_sync_single calls where neccesary
+    2000 Aug 31 David Mosberger <davidm@hpl.hp.com>
+	    RX_ALIGN support: enables rx DMA without causing unaligned accesses.
 */
 
 static const char *version =
@@ -41,13 +43,17 @@
 static int txdmacount = 128;
 static int rxdmacount /* = 0 */;
 
+#if defined(__ia64__) || defined(__alpha__) || defined(__sparc__) || defined(__arm__)
+  /* align rx buffers to 2 bytes so that IP header is aligned */
+# define RX_ALIGN
+# define RxFD_ALIGNMENT		__attribute__ ((aligned (2), packed))
+#else
+# define RxFD_ALIGNMENT
+#endif
+
 /* Set the copy breakpoint for the copy-only-tiny-buffer Rx method.
    Lower values use more memory, but are faster. */
-#if defined(__alpha__) || defined(__sparc__) || defined(__arm__)
-static int rx_copybreak = 1518;
-#else
 static int rx_copybreak = 200;
-#endif
 
 /* Maximum events (Rx packets, etc.) to handle at each interrupt. */
 static int max_interrupt_work = 20;
@@ -377,18 +383,18 @@
 
 /* The Speedo3 Rx and Tx frame/buffer descriptors. */
 struct descriptor {			    /* A generic descriptor. */
-	s32 cmd_status;				/* All command and status fields. */
+	volatile s32 cmd_status;	/* All command and status fields. */
 	u32 link;				    /* struct descriptor *  */
 	unsigned char params[0];
 };
 
 /* The Speedo3 Rx and Tx buffer descriptors. */
 struct RxFD {					/* Receive frame descriptor. */
-	s32 status;
+	volatile s32 status;
 	u32 link;					/* struct RxFD * */
 	u32 rx_buf_addr;			/* void * */
 	u32 count;
-};
+} RxFD_ALIGNMENT;
 
 /* Selected elements of the Tx/RxFD.status word. */
 enum RxFD_bits {
@@ -1174,6 +1180,9 @@
 	for (i = 0; i < RX_RING_SIZE; i++) {
 		struct sk_buff *skb;
 		skb = dev_alloc_skb(PKT_BUF_SZ + sizeof(struct RxFD));
+#ifdef RX_ALIGN
+		skb_reserve(skb, 2);	/* Align IP on 16 byte boundary */
+#endif
 		sp->rx_skbuff[i] = skb;
 		if (skb == NULL)
 			break;			/* OK.  Just initially short of Rx bufs. */
@@ -1599,6 +1608,9 @@
 	struct sk_buff *skb;
 	/* Get a fresh skbuff to replace the consumed one. */
 	skb = dev_alloc_skb(PKT_BUF_SZ + sizeof(struct RxFD));
+#ifdef RX_ALIGN
+	skb_reserve(skb, 2);	/* Align IP on 16 byte boundary */
+#endif
 	sp->rx_skbuff[entry] = skb;
 	if (skb == NULL) {
 		sp->rx_ringp[entry] = NULL;
diff -urN linux.orig/drivers/net/simeth.c linux/drivers/net/simeth.c
--- linux.orig/drivers/net/simeth.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/simeth.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,596 @@
+/*
+ * Simulated Ethernet Driver
+ *
+ * Copyright (C) 1999-2000 Hewlett-Packard Co
+ * Copyright (C) 1999-2000 Stephane Eranain <eranian@hpl.hp.com>
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/in.h>
+#include <linux/malloc.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/if_ether.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/notifier.h>
+#include <asm/bitops.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+
+
+#define SIMETH_RECV_MAX	10
+
+/*
+ * Maximum possible received frame for Ethernet.
+ * We preallocate an sk_buff of that size to avoid costly 
+ * memcpy for temporary buffer into sk_buff. We do basically
+ * what's done in other drivers, like eepro with a ring.
+ * The difference is, of course, that we don't have real DMA !!!
+ */
+#define SIMETH_FRAME_SIZE	ETH_FRAME_LEN	
+
+
+#define SSC_NETDEV_PROBE		100
+#define SSC_NETDEV_SEND			101
+#define SSC_NETDEV_RECV			102
+#define SSC_NETDEV_ATTACH		103
+#define SSC_NETDEV_DETACH		104
+
+#define NETWORK_INTR			8
+
+/*
+ * This structure is need for the module version
+ * It hasn't been tested yet
+ */
+struct simeth_local {
+	struct net_device	*next_module;
+	struct net_device_stats stats;
+	int 			simfd;	 /* descriptor in the simulator */
+};
+
+static int simeth_probe1(void);
+static int simeth_open(struct net_device *dev);
+static int simeth_close(struct net_device *dev);
+static int simeth_tx(struct sk_buff *skb, struct net_device *dev);
+static int simeth_rx(struct net_device *dev);
+static struct net_device_stats *simeth_get_stats(struct net_device *dev);
+static void simeth_interrupt(int irq, void *dev_id, struct pt_regs * regs);
+static void set_multicast_list(struct net_device *dev);
+static int simeth_device_event(struct notifier_block *this,unsigned long event, void *ptr);
+
+static char *simeth_version="v0.2";
+
+/*
+ * This variable is used to establish a mapping between the Linux/ia64 kernel
+ * and the host linux kernel.
+ *
+ * As of today, we support only one card, even though most of the code
+ * is ready for many more. The mapping is then:
+ *	linux/ia64 -> linux/x86
+ * 	   eth0    -> eth1
+ *
+ * In the future, we some string operations, we could easily support up
+ * to 10 cards (0-9).
+ *
+ * The default mapping can be changed on the kernel command line by
+ * specifying simeth=ethX (or whatever string you want).
+ */
+static char *simeth_device="eth0";	 /* default host interface to use */
+
+
+
+static volatile unsigned int card_count; /* how many cards "found" so far */
+static int simeth_debug=0;		/* set to 1 to get debug information */
+
+/*
+ * Used to catch IFF_UP & IFF_DOWN events
+ */
+static struct notifier_block simeth_dev_notifier = {
+	simeth_device_event,
+	0
+};
+
+
+/*
+ * Function used when using a kernel command line option.
+ *
+ * Format: simeth=interface_name (like eth0)
+ */
+static int __init
+simeth_setup(char *str)
+{
+	simeth_device = str;
+	return 1;
+}
+
+__setup("simeth=", simeth_setup);
+
+/*
+ * Function used to probe for simeth devices when not installed
+ * as a loadable module
+ */
+
+int __init
+simeth_probe (void)
+{
+	return simeth_probe1();
+}
+
+extern long ia64_ssc (long, long, long, long, int);
+extern void ia64_ssc_connect_irq (long intr, long irq);
+
+static inline int
+netdev_probe(char *name, unsigned char *ether)
+{
+	return ia64_ssc(__pa(name), __pa(ether), 0,0, SSC_NETDEV_PROBE);
+}
+
+
+static inline int
+netdev_connect(int irq)
+{
+	/* XXX Fix me
+	 * this does not support multiple cards
+	 * also no return value
+	 */
+	ia64_ssc_connect_irq(NETWORK_INTR, irq);
+	return 0;
+}
+
+static inline int
+netdev_attach(int fd, int irq, unsigned int ipaddr)
+{
+	/* this puts the host interface in the right mode (start interupting) */
+	return ia64_ssc(fd, ipaddr, 0,0, SSC_NETDEV_ATTACH);
+}
+
+
+static inline int
+netdev_detach(int fd)
+{
+	/*
+	 * inactivate the host interface (don't interrupt anymore) */
+	return ia64_ssc(fd, 0,0,0, SSC_NETDEV_DETACH);
+}
+
+static inline int
+netdev_send(int fd, unsigned char *buf, unsigned int len)
+{
+	return ia64_ssc(fd, __pa(buf), len, 0, SSC_NETDEV_SEND);
+}
+
+static inline int
+netdev_read(int fd, unsigned char *buf, unsigned int len)
+{
+	return ia64_ssc(fd, __pa(buf), len, 0, SSC_NETDEV_RECV);
+}
+
+/*
+ * Function shared with module code, so cannot be in init section
+ *
+ * So far this function "detects" only one card (test_&_set) but could 
+ * be extended easily.
+ *
+ * Return:
+ * 	- -ENODEV is no device found
+ *	- -ENOMEM is no more memory
+ *	- 0 otherwise
+ */
+static int
+simeth_probe1(void)
+{
+	unsigned char mac_addr[ETH_ALEN];
+	struct simeth_local *local;
+	struct net_device *dev;
+	int fd, i;
+
+	/*
+	 * XXX Fix me 
+	 * let's support just one card for now
+	 */
+	if (test_and_set_bit(0, &card_count))
+		return -ENODEV;
+
+	/*
+	 * check with the simulator for the device
+	 */
+	fd = netdev_probe(simeth_device, mac_addr);
+	if (fd == -1)
+		return -ENODEV;
+
+	dev = init_etherdev(NULL, sizeof(struct simeth_local));
+	if (!dev)
+		return -ENOMEM;
+
+	memcpy(dev->dev_addr, mac_addr, sizeof(mac_addr));
+
+	dev->irq = ia64_alloc_irq();
+
+	/*
+	 * attach the interrupt in the simulator, this does enable interrupts
+	 * until a netdev_attach() is called
+	 */
+	netdev_connect(dev->irq);
+
+	memset(dev->priv, 0, sizeof(struct simeth_local));
+
+	local = dev->priv;
+	local->simfd = fd; /* keep track of underlying file descriptor */
+	local->next_module = NULL;
+
+	dev->open		= simeth_open;
+	dev->stop		= simeth_close;
+	dev->hard_start_xmit	= simeth_tx;
+	dev->get_stats		= simeth_get_stats;
+	dev->set_multicast_list = set_multicast_list; /* no yet used */
+
+	/* Fill in the fields of the device structure with ethernet-generic values. */
+	ether_setup(dev);
+
+	printk("simeth:  %s alpha\n", simeth_version);
+	printk("%s: hosteth=%s simfd=%d, HwAddr", dev->name, simeth_device, local->simfd);
+	for(i = 0; i < ETH_ALEN; i++) {
+		printk(" %2.2x", dev->dev_addr[i]);
+	}
+	printk(", IRQ %d\n", dev->irq);
+
+#ifdef MODULE
+	local->next_module = simeth_dev;
+	simeth_dev  = dev;
+#endif
+	/*
+	 * XXX Fix me
+	 * would not work with more than one device !
+	 */
+	register_netdevice_notifier(&simeth_dev_notifier);
+
+	return 0;
+}
+
+/*
+ * actually binds the device to an interrupt vector
+ */
+static int
+simeth_open(struct net_device *dev)
+{
+	if (request_irq(dev->irq, simeth_interrupt, 0, "simeth", dev)) {
+		printk ("simeth: unable to get IRQ %d.\n", dev->irq);
+		return -EAGAIN;
+	}
+
+	netif_start_queue(dev);
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+/* copied from lapbether.c */
+static __inline__ int dev_is_ethdev(struct net_device *dev)
+{
+       return ( dev->type == ARPHRD_ETHER && strncmp(dev->name, "dummy", 5));
+}
+
+
+/*
+ * Handler for IFF_UP or IFF_DOWN
+ *
+ * The reason for that is that we don't want to be interrupted when the
+ * interface is down. There is no way to unconnect in the simualtor. Instead
+ * we use this function to shutdown packet processing in the frame filter 
+ * in the simulator. Thus no interrupts are generated
+ *
+ *
+ * That's also the place where we pass the IP address of this device to the
+ * simulator so that that we can start filtering packets for it
+ *
+ * There may be a better way of doing this, but I don't know which yet.
+ */
+static int
+simeth_device_event(struct notifier_block *this,unsigned long event, void *ptr)
+{
+	struct net_device *dev = (struct net_device *)ptr;
+	struct simeth_local *local;
+	struct in_device *in_dev;
+	struct in_ifaddr **ifap = NULL;
+	struct in_ifaddr *ifa = NULL;
+	int r;
+
+
+	if ( ! dev ) {
+		printk(KERN_WARNING "simeth_device_event dev=0\n");
+		return NOTIFY_DONE;
+	}
+
+	if ( event != NETDEV_UP && event != NETDEV_DOWN ) return NOTIFY_DONE;
+
+	/*
+	 * Check whether or not it's for an ethernet device
+	 *
+	 * XXX Fixme: This works only as long as we support one
+	 * type of ethernet device.
+	 */
+	if ( !dev_is_ethdev(dev) ) return NOTIFY_DONE;
+
+	if ((in_dev=dev->ip_ptr) != NULL) {
+		for (ifap=&in_dev->ifa_list; (ifa=*ifap) != NULL; ifap=&ifa->ifa_next)
+			if (strcmp(dev->name, ifa->ifa_label) == 0) break;
+	}
+	if ( ifa == NULL ) {
+		printk("simeth_open: can't find device %s's ifa\n", dev->name);
+		return NOTIFY_DONE;
+	}
+
+	printk("simeth_device_event: %s ipaddr=0x%x\n", dev->name, htonl(ifa->ifa_local));
+
+	/*
+	 * XXX Fix me
+	 * if the device was up, and we're simply reconfiguring it, not sure
+	 * we get DOWN then UP.
+	 */
+
+	local = dev->priv;
+	/* now do it for real */
+	r = event == NETDEV_UP ? 
+		netdev_attach(local->simfd, dev->irq, htonl(ifa->ifa_local)):
+		netdev_detach(local->simfd);
+
+	printk("simeth: netdev_attach/detach: event=%s ->%d\n", event == NETDEV_UP ? "attach":"detach", r);
+
+	return NOTIFY_DONE;
+}
+
+static int
+simeth_close(struct net_device *dev)
+{
+	netif_stop_queue(dev);
+
+	free_irq(dev->irq, dev);
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+/*
+ * Only used for debug
+ */
+static void
+frame_print(unsigned char *from, unsigned char *frame, int len)
+{
+	int i;
+
+	printk("%s: (%d) %02x", from, len, frame[0] & 0xff);
+	for(i=1; i < 6; i++ ) {
+		printk(":%02x", frame[i] &0xff);
+	}
+	printk(" %2x", frame[6] &0xff);
+	for(i=7; i < 12; i++ ) {
+		printk(":%02x", frame[i] &0xff);
+	}
+	printk(" [%02x%02x]\n", frame[12], frame[13]);
+
+	for(i=14; i < len; i++ ) {
+		printk("%02x ", frame[i] &0xff);
+		if ( (i%10)==0) printk("\n");
+	}
+	printk("\n");
+}
+
+
+/*
+ * Function used to transmit of frame, very last one on the path before
+ * going to the simulator.
+ */
+static int
+simeth_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct simeth_local *local = (struct simeth_local *)dev->priv;
+
+#if 0
+	/* ensure we have at least ETH_ZLEN bytes (min frame size) */
+	unsigned int length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
+	/* Where do the extra padding bytes comes from inthe skbuff ? */
+#else
+	/* the real driver in the host system is going to take care of that
+	 * or maybe it's the NIC itself.
+	 */
+	unsigned int length = skb->len;
+#endif
+
+	local->stats.tx_bytes += skb->len;
+	local->stats.tx_packets++;
+
+
+	if (simeth_debug > 5) frame_print("simeth_tx", skb->data, length);
+
+	netdev_send(local->simfd, skb->data, length);
+
+	/*
+	 * we are synchronous on write, so we don't simulate a
+	 * trasnmit complete interrupt, thus we don't need to arm a tx
+	 */
+
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+static inline struct sk_buff * 
+make_new_skb(struct net_device *dev)
+{
+	struct sk_buff *nskb;
+
+	/*
+	 * The +2 is used to make sure that the IP header is nicely
+	 * aligned (on 4byte boundary I assume 14+2=16)
+	 */
+	nskb = dev_alloc_skb(SIMETH_FRAME_SIZE + 2);
+	if ( nskb == NULL ) {
+		printk(KERN_NOTICE "%s: memory squeeze. dropping packet.\n", dev->name);
+		return NULL;
+	}
+	nskb->dev = dev;
+
+	skb_reserve(nskb, 2);	/* Align IP on 16 byte boundaries */
+
+	skb_put(nskb,SIMETH_FRAME_SIZE);
+
+	return nskb;
+}
+
+/*
+ * called from interrupt handler to process a received frame
+ */
+static int
+simeth_rx(struct net_device *dev)
+{
+	struct simeth_local	*local;
+	struct sk_buff		*skb;
+	int			len;
+	int			rcv_count = SIMETH_RECV_MAX;
+
+	local = (struct simeth_local *)dev->priv;
+	/*
+	 * the loop concept has been borrowed from other drivers
+	 * looks to me like it's a throttling thing to avoid pushing to many
+	 * packets at one time into the stack. Making sure we can process them
+	 * upstream and make forward progress overall
+	 */
+	do { 
+		if ( (skb=make_new_skb(dev)) == NULL ) {
+			printk(KERN_NOTICE "%s: memory squeeze. dropping packet.\n", dev->name);
+			local->stats.rx_dropped++;
+			return 0;
+		}
+		/*
+		 * Read only one frame at a time
+		 */
+		len = netdev_read(local->simfd, skb->data, SIMETH_FRAME_SIZE);
+		if ( len == 0 ) {
+			if ( simeth_debug > 0 ) printk(KERN_WARNING "%s: count=%d netdev_read=0\n", dev->name, SIMETH_RECV_MAX-rcv_count);
+			break;
+		}
+#if 0
+		/*
+		 * XXX Fix me
+		 * Should really do a csum+copy here
+		 */
+		memcpy(skb->data, frame, len);
+#endif
+		skb->protocol = eth_type_trans(skb, dev);
+
+		if ( simeth_debug > 6 ) frame_print("simeth_rx", skb->data, len);
+
+		/*
+		 * push the packet up & trigger software interrupt
+		 */
+		netif_rx(skb);
+
+		local->stats.rx_packets++;
+		local->stats.rx_bytes += len;
+
+	} while ( --rcv_count );
+
+	return len; /* 0 = nothing left to read, otherwise, we can try again */
+}
+
+/*
+ * Interrupt handler (Yes, we can do it too !!!)
+ */
+static void
+simeth_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct net_device *dev = dev_id;
+
+	if ( dev == NULL ) {
+		printk(KERN_WARNING "simeth: irq %d for unknown device\n", irq);
+		return;
+	}
+
+	/*
+	 * very simple loop because we get interrupts only when receving
+	 */
+	while (simeth_rx(dev));
+}
+
+static struct net_device_stats *
+simeth_get_stats(struct net_device *dev)
+{
+	struct simeth_local  *local = (struct simeth_local *) dev->priv;
+
+	return &local->stats;
+}
+
+/* fake multicast ability */
+static void
+set_multicast_list(struct net_device *dev)
+{
+	printk(KERN_WARNING "%s: set_multicast_list called\n", dev->name);
+}
+
+#ifdef CONFIG_NET_FASTROUTE
+static int
+simeth_accept_fastpath(struct net_device *dev, struct dst_entry *dst)
+{
+	printk(KERN_WARNING "%s: simeth_accept_fastpath called\n", dev->name);
+	return -1;
+}
+#endif
+
+
+#ifdef MODULE
+static int
+simeth_init(void)
+{
+	unsigned int cards_found = 0;
+
+	/* iterate over probe */
+
+	while ( simeth_probe1() == 0 ) cards_found++;
+
+	return cards_found ? 0 : -ENODEV;
+}
+
+
+int
+init_module(void)
+{
+	simeth_dev = NULL;
+
+	/* the register_netdev is done "indirectly by ether_initdev() */
+
+	return simeth_init();
+}
+
+void
+cleanup_module(void)
+{
+	struct net_device *next;
+
+	while ( simeth_dev ) {
+
+		next = ((struct simeth_private *)simeth_dev->priv)->next_module;
+
+		unregister_netdev(simeth_dev);
+
+		kfree(simeth_dev);
+
+		simeth_dev = next;
+	}
+	/*
+	 * XXX fix me
+	 * not clean wihen multiple devices
+	 */
+	unregister_netdevice_notifier(&simeth_dev_notifier);
+}
+#else /* !MODULE */
+__initcall(simeth_probe);
+#endif /* !MODULE */
diff -urN linux.orig/drivers/pci/pci.c linux/drivers/pci/pci.c
--- linux.orig/drivers/pci/pci.c	Mon Aug 13 15:49:21 2001
+++ linux/drivers/pci/pci.c	Mon Dec 17 20:27:41 2001
@@ -1540,10 +1540,10 @@
 
 	switch (rqst) {
 	case PM_SAVE_STATE:
-		error = pci_pm_save_state((u32)data);
+		error = pci_pm_save_state((unsigned long)data);
 		break;
 	case PM_SUSPEND:
-		error = pci_pm_suspend((u32)data);
+		error = pci_pm_suspend((unsigned long)data);
 		break;
 	case PM_RESUME:
 		error = pci_pm_resume();
@@ -1860,9 +1860,9 @@
 	int			map, block;
 
 	if ((page = pool_find_page (pool, dma)) == 0) {
-		printk (KERN_ERR "pci_pool_free %s/%s, %p/%x (bad dma)\n",
+		printk (KERN_ERR "pci_pool_free %s/%s, %p/%lx (bad dma)\n",
 			pool->dev ? pool->dev->slot_name : NULL,
-			pool->name, vaddr, dma);
+			pool->name, vaddr, (unsigned long) dma);
 		return;
 	}
 #ifdef	CONFIG_PCIPOOL_DEBUG
diff -urN linux.orig/drivers/scsi/Config.in linux/drivers/scsi/Config.in
--- linux.orig/drivers/scsi/Config.in	Thu Jul  5 12:28:16 2001
+++ linux/drivers/scsi/Config.in	Mon Dec 17 20:27:41 2001
@@ -152,6 +152,7 @@
    dep_tristate 'Qlogic ISP SCSI support' CONFIG_SCSI_QLOGIC_ISP $CONFIG_SCSI
    dep_tristate 'Qlogic ISP FC SCSI support' CONFIG_SCSI_QLOGIC_FC $CONFIG_SCSI
    dep_tristate 'Qlogic QLA 1280 SCSI support' CONFIG_SCSI_QLOGIC_1280 $CONFIG_SCSI
+   dep_tristate 'Qlogic QLA 2100 driver support' CONFIG_SCSI_QLOGIC_QLA2100 $CONFIG_SCSI
 fi
 if [ "$CONFIG_X86" = "y" ]; then
    dep_tristate 'Seagate ST-02 and Future Domain TMC-8xx SCSI support' CONFIG_SCSI_SEAGATE $CONFIG_SCSI
diff -urN linux.orig/drivers/scsi/Makefile linux/drivers/scsi/Makefile
--- linux.orig/drivers/scsi/Makefile	Fri May  4 16:16:28 2001
+++ linux/drivers/scsi/Makefile	Mon Dec 17 20:27:41 2001
@@ -59,6 +59,7 @@
 obj-$(CONFIG_SUN3_SCSI)		+= sun3_scsi.o
 obj-$(CONFIG_MVME16x_SCSI)	+= mvme16x.o	53c7xx.o
 obj-$(CONFIG_BVME6000_SCSI)	+= bvme6000.o	53c7xx.o
+obj-$(CONFIG_SCSI_SIM)		+= simscsi.o
 obj-$(CONFIG_SCSI_SIM710)	+= sim710.o
 obj-$(CONFIG_SCSI_ADVANSYS)	+= advansys.o
 obj-$(CONFIG_SCSI_PCI2000)	+= pci2000.o
@@ -85,6 +86,7 @@
 obj-$(CONFIG_SCSI_QLOGIC_ISP)	+= qlogicisp.o 
 obj-$(CONFIG_SCSI_QLOGIC_FC)	+= qlogicfc.o 
 obj-$(CONFIG_SCSI_QLOGIC_1280)	+= qla1280.o 
+obj-$(CONFIG_SCSI_QLOGIC_QLA2100) += qla2x00.o
 obj-$(CONFIG_SCSI_PAS16)	+= pas16.o
 obj-$(CONFIG_SCSI_SEAGATE)	+= seagate.o
 obj-$(CONFIG_SCSI_FD_8xx)	+= seagate.o
diff -urN linux.orig/drivers/scsi/ql12160_fw.h linux/drivers/scsi/ql12160_fw.h
--- linux.orig/drivers/scsi/ql12160_fw.h	Mon Feb  7 20:45:28 2000
+++ linux/drivers/scsi/ql12160_fw.h	Mon Dec 17 20:27:41 2001
@@ -1,56 +1,93 @@
 /*
+
  ************************************************************************
+
  *									*
+
  * 	           --- ISP12160 Initiator Firmware ---               	*
+
  *			      32 LUN Support				*
+
  *									*
+
  ************************************************************************
+
  *									*
+
  * Copyright (C) 1999,2000 Qlogic, Corporation
+
  * All rights reserved.
+
  *
+
  * Redistribution and use in source and binary forms are permitted provided
+
  * that the following conditions are met:
+
  * 1. Redistribution of source code must retain the above copyright
+
  *    notice, this list of conditions and the following disclaimer.
- * 2. The name of the author may not be used to endorse or promote products
+
+ * 2. Redistribution in binary form must reproduce the above copyright
+
+ *    notice, this list of conditions and the following disclaimer in the
+
+ *    documentation and/or other materials provided with the distribution.
+
+ * 3. The name of the author may not be used to endorse or promote products
+
  *    derived from this software without specific prior written permission
+
  *
+
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+
  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+
  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+
  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+
  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
  *									*
+
  ************************************************************************
+
  */
 
 
+
 /*
- *	Firmware Version 10.01.19 (12:38 Oct 12, 1999)
+ *	Firmware Version 10.04.08 (11:30 May 31, 2000)
  */
 
 #ifdef UNIQUE_FW_NAME
-unsigned short fw12160i_version = 10*1024+1;
+unsigned short fw12160i_version = 10*1024+4;
 #else
-unsigned short risc_code_version = 10*1024+1;
+unsigned short risc_code_version = 10*1024+4;
 #endif
 
 #ifdef UNIQUE_FW_NAME
-unsigned char fw12160i_version_str[] = {10,1,19};
+unsigned char fw12160i_version_str[] = {10,4,8};
 #else
-unsigned char firmware_version[] = {10,1,19};
+unsigned char firmware_version[] = {10,4,8};
 #endif
 
 #ifdef UNIQUE_FW_NAME
-#define fw12160i_VERSION_STRING "10.1.19"
+#define fw12160i_VERSION_STRING "10.04.08"
 #else
-#define FW_VERSION_STRING "10.1.19"
+#define FW_VERSION_STRING "10.04.08"
 #endif
 
 #ifdef UNIQUE_FW_NAME
@@ -64,1326 +101,1383 @@
 #else
 unsigned short risc_code01[] = { 
 #endif
-	0x0804, 0x1041, 0x0000, 0x32f8, 0x0000, 0x2043, 0x4f50, 0x5952,
+	0x0804, 0x1041, 0x0000, 0x34e5, 0x0000, 0x2043, 0x4f50, 0x5952,
 	0x4947, 0x4854, 0x2031, 0x3939, 0x312c, 0x3139, 0x3932, 0x2c31,
 	0x3939, 0x332c, 0x3139, 0x3934, 0x2051, 0x4c4f, 0x4749, 0x4320,
 	0x434f, 0x5250, 0x4f52, 0x4154, 0x494f, 0x4e00, 0x2049, 0x5350,
 	0x3132, 0x3136, 0x2046, 0x6972, 0x6d77, 0x6172, 0x6520, 0x2056,
-	0x6572, 0x7369, 0x6f6e, 0x2031, 0x302e, 0x3031, 0x2020, 0x2043,
+	0x6572, 0x7369, 0x6f6e, 0x2031, 0x302e, 0x3034, 0x2020, 0x2043,
 	0x7573, 0x746f, 0x6d65, 0x7220, 0x4e6f, 0x2e20, 0x3030, 0x2050,
 	0x726f, 0x6475, 0x6374, 0x204e, 0x6f2e, 0x2020, 0x3030, 0x2020,
-	0x2400, 0x20c9, 0x8cff, 0x2071, 0x0200, 0x70a0, 0x70a2, 0x2001,
+	0x2400, 0x20c9, 0x8eff, 0x2071, 0x0200, 0x70a0, 0x70a2, 0x2001,
 	0x01ff, 0x2004, 0xd0fc, 0x1120, 0x2071, 0x0100, 0x70a0, 0x70a2,
-	0x20c1, 0x0020, 0x2089, 0x1223, 0x2071, 0x0010, 0x70c3, 0x0004,
+	0x20c1, 0x0020, 0x2089, 0x1221, 0x2071, 0x0010, 0x70c3, 0x0004,
 	0x70c7, 0x4953, 0x70cb, 0x5020, 0x70cf, 0x2020, 0x70d3, 0x000a,
 	0x2001, 0x04fd, 0x2004, 0x70d6, 0x2009, 0xfeff, 0x2130, 0x2128,
-	0xa1a2, 0x4300, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424,
-	0xa192, 0x8d00, 0x2009, 0x0000, 0x2001, 0x0032, 0x080c, 0x1d83,
-	0x2218, 0x2079, 0x4300, 0x2fa0, 0x2408, 0x2011, 0x0000, 0x20a9,
+	0xa1a2, 0x4500, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424,
+	0xa192, 0x8f00, 0x2009, 0x0000, 0x2001, 0x0032, 0x080c, 0x1dcf,
+	0x2218, 0x2079, 0x4500, 0x2fa0, 0x2408, 0x2011, 0x0000, 0x20a9,
 	0x0040, 0x42a4, 0x8109, 0x1dd8, 0x2009, 0xff00, 0x3400, 0xa102,
 	0x0218, 0x0110, 0x20a8, 0x42a4, 0x781b, 0x0064, 0x7814, 0xc0cd,
-	0xc0d5, 0x7816, 0x2071, 0x0200, 0x00d6, 0x2069, 0x4340, 0x080c,
-	0x42d8, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1130, 0x2069, 0x4380,
-	0x2071, 0x0100, 0x080c, 0x42d8, 0x7814, 0xc0d4, 0x7816, 0x00de,
+	0xc0d5, 0x7816, 0x2071, 0x0200, 0x00d6, 0x2069, 0x4540, 0x080c,
+	0x44bd, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1130, 0x2069, 0x4580,
+	0x2071, 0x0100, 0x080c, 0x44bd, 0x7814, 0xc0d4, 0x7816, 0x00de,
 	0x7eca, 0x7cc2, 0x7bc6, 0x7867, 0x0000, 0x7800, 0xc08d, 0x7802,
 	0x2031, 0x0030, 0x78af, 0x0101, 0x7823, 0x0002, 0x7827, 0x0002,
-	0x2009, 0x0002, 0x2069, 0x4340, 0x681b, 0x0003, 0x6823, 0x0007,
-	0x6827, 0x00fa, 0x682b, 0x0008, 0x682f, 0x0028, 0x6837, 0x0000,
-	0x683b, 0x0006, 0x6833, 0x0008, 0x683f, 0x0000, 0x8109, 0x0500,
-	0x68d3, 0x000a, 0x68c3, 0x43c0, 0x2079, 0x4300, 0x68d7, 0x762d,
-	0x68c7, 0x48c0, 0x68cb, 0x47c0, 0x68cf, 0x88c0, 0x68ab, 0x8b44,
-	0x68af, 0x8b49, 0x68b3, 0x8b44, 0x68b7, 0x8b44, 0x68a7, 0x0001,
-	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x11c8, 0x2069, 0x4380, 0x0860,
-	0x68d3, 0x000a, 0x68c3, 0x45c0, 0x68d7, 0x7839, 0x68c7, 0x68c0,
-	0x68cb, 0x4840, 0x68cf, 0x89d0, 0x68ab, 0x8b49, 0x68af, 0x8b4e,
-	0x68b3, 0x8b49, 0x68b7, 0x8b49, 0x68a7, 0x0001, 0x00e6, 0x2069,
-	0x47c0, 0x2071, 0x0200, 0x70ec, 0xd0e4, 0x2019, 0x1c09, 0x2021,
-	0x0009, 0x1120, 0x2019, 0x1c0c, 0x2021, 0x000c, 0x080c, 0x1cf3,
-	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1188, 0x2069, 0x4840, 0x2071,
-	0x0100, 0x70ec, 0xd0e4, 0x2019, 0x1c09, 0x2021, 0x0009, 0x1120,
-	0x2019, 0x1c0c, 0x2021, 0x000c, 0x080c, 0x1cf3, 0x00ee, 0x2011,
-	0x0002, 0x2069, 0x48c0, 0x2009, 0x0002, 0x20a9, 0x0100, 0x6837,
-	0x0000, 0x680b, 0x0040, 0x7bc8, 0xa386, 0xfeff, 0x1128, 0x6817,
-	0x0100, 0x681f, 0x0064, 0x0020, 0x6817, 0x0064, 0x681f, 0x0002,
-	0xade8, 0x0010, 0x1f04, 0x1137, 0x8109, 0x1d38, 0x2001, 0x01ff,
-	0x2004, 0xd0fc, 0x1128, 0x8211, 0x0118, 0x2069, 0x68c0, 0x08d8,
-	0x080c, 0x2254, 0x080c, 0x3e39, 0x080c, 0x1b0f, 0x080c, 0x42a0,
-	0x2091, 0x2200, 0x2079, 0x4300, 0x2071, 0x0050, 0x2091, 0x2400,
-	0x2079, 0x4300, 0x2071, 0x0020, 0x2091, 0x2600, 0x2079, 0x0200,
-	0x2071, 0x4340, 0x2091, 0x2800, 0x2079, 0x0100, 0x2071, 0x4380,
-	0x2091, 0x2000, 0x2079, 0x4300, 0x2071, 0x0010, 0x3200, 0xa085,
-	0x303d, 0x2090, 0x2071, 0x0010, 0x70c3, 0x0000, 0x1004, 0x118e,
-	0x70c0, 0xa086, 0x0002, 0x1110, 0x080c, 0x13a3, 0x2039, 0x0000,
-	0x080c, 0x129c, 0x78ac, 0xa005, 0x1180, 0x0e04, 0x119c, 0x786c,
-	0xa065, 0x0110, 0x080c, 0x1ffe, 0x080c, 0x1da4, 0x0e04, 0x11b1,
-	0x786c, 0xa065, 0x0110, 0x080c, 0x1ffe, 0x0e04, 0x11b1, 0x2009,
-	0x4347, 0x2011, 0x4387, 0x2104, 0x220c, 0xa105, 0x0110, 0x080c,
-	0x1c21, 0x2071, 0x4340, 0x70a4, 0xa005, 0x01e8, 0x7450, 0xa485,
-	0x0000, 0x01c8, 0x2079, 0x0200, 0x2091, 0x8000, 0x72d4, 0xa28c,
-	0x303d, 0x2190, 0x080c, 0x260d, 0x2091, 0x8000, 0x2091, 0x303d,
-	0x0e04, 0x11d3, 0x2079, 0x4300, 0x786c, 0xa065, 0x0120, 0x2071,
-	0x0010, 0x080c, 0x1ffe, 0x1d04, 0x11db, 0x2079, 0x4300, 0x2071,
-	0x0010, 0x080c, 0x40ed, 0x2071, 0x4380, 0x70a4, 0xa005, 0x0188,
-	0x7050, 0xa025, 0x0170, 0x2079, 0x0100, 0x2091, 0x8000, 0x72d4,
-	0xa28c, 0x303d, 0x2190, 0x080c, 0x260d, 0x2091, 0x8000, 0x2091,
-	0x303d, 0x2079, 0x4300, 0x2071, 0x0010, 0x0e04, 0x11fc, 0x786c,
-	0xa065, 0x0110, 0x080c, 0x1ffe, 0x1d04, 0x1190, 0x080c, 0x40ed,
-	0x0804, 0x1190, 0x3c00, 0xa084, 0x0007, 0x0002, 0x120e, 0x120e,
-	0x1210, 0x1210, 0x1215, 0x1215, 0x121a, 0x121a, 0x080c, 0x243b,
-	0x2091, 0x2400, 0x080c, 0x3e9c, 0x0005, 0x2091, 0x2200, 0x080c,
-	0x3e9c, 0x0005, 0x2091, 0x2200, 0x080c, 0x3e9c, 0x2091, 0x2400,
-	0x080c, 0x3e9c, 0x0005, 0x1243, 0x1243, 0x1244, 0x1244, 0x124f,
-	0x124f, 0x124f, 0x124f, 0x1258, 0x1258, 0x1263, 0x1263, 0x124f,
-	0x124f, 0x124f, 0x124f, 0x1272, 0x1272, 0x1272, 0x1272, 0x1272,
-	0x1272, 0x1272, 0x1272, 0x1272, 0x1272, 0x1272, 0x1272, 0x1272,
-	0x1272, 0x1272, 0x1272, 0x0cf8, 0x0006, 0x0106, 0x0126, 0x2091,
-	0x2800, 0x080c, 0x2458, 0x012e, 0x010e, 0x000e, 0x000d, 0x0006,
-	0x0106, 0x0126, 0x080c, 0x1202, 0x012e, 0x010e, 0x000e, 0x000d,
-	0x0006, 0x0106, 0x0126, 0x2091, 0x2600, 0x080c, 0x2458, 0x012e,
-	0x010e, 0x000e, 0x000d, 0x0006, 0x0106, 0x0126, 0x2091, 0x2600,
-	0x080c, 0x2458, 0x2091, 0x2800, 0x080c, 0x2458, 0x012e, 0x010e,
-	0x000e, 0x000d, 0x0006, 0x0106, 0x0126, 0x00e6, 0x00f6, 0x2079,
-	0x4300, 0x2071, 0x0200, 0x2069, 0x4340, 0x3d00, 0xd08c, 0x1120,
-	0x2069, 0x4380, 0x2071, 0x0100, 0x080c, 0x42d8, 0x00fe, 0x00ee,
-	0x012e, 0x010e, 0x000e, 0x000d, 0x7008, 0x800b, 0x1240, 0x7007,
-	0x0002, 0xa08c, 0x01e0, 0x1120, 0xd09c, 0x0108, 0x0887, 0x0897,
-	0x70c3, 0x4002, 0x0804, 0x13a6, 0x0e04, 0x1308, 0x2061, 0x0000,
-	0x6018, 0xd084, 0x1904, 0x1308, 0x7828, 0xa005, 0x1120, 0x0004,
-	0x1309, 0x0804, 0x1308, 0xd0fc, 0x0148, 0x0006, 0x080c, 0x1aa9,
-	0x000e, 0x0168, 0x2001, 0x4007, 0x0804, 0x13a5, 0x0006, 0x080c,
-	0x1a9b, 0x000e, 0x0120, 0x2001, 0x4007, 0x0804, 0x13a5, 0x7910,
-	0xd0fc, 0x1128, 0x2061, 0x4340, 0xc19c, 0xc7fc, 0x0020, 0x2061,
-	0x4380, 0xc19d, 0xc7fd, 0x6064, 0xa005, 0x15d0, 0x7912, 0x6083,
-	0x0000, 0x7828, 0xc0fc, 0xa086, 0x0018, 0x1120, 0x00c6, 0x080c,
-	0x18c9, 0x00ce, 0x782b, 0x0000, 0x607c, 0xa065, 0x0190, 0x00c6,
-	0x609c, 0x080c, 0x1b76, 0x00ce, 0x609f, 0x0000, 0x080c, 0x19db,
-	0x2009, 0x0018, 0x6087, 0x0103, 0x080c, 0x1ab7, 0x1198, 0x080c,
-	0x1b02, 0x7810, 0xd09c, 0x1118, 0x2061, 0x4340, 0x0020, 0x2061,
-	0x4380, 0xc09c, 0x7812, 0x607f, 0x0000, 0x60d4, 0xd0c4, 0x0130,
-	0xc0c4, 0x60d6, 0x2001, 0x4005, 0x0804, 0x13a5, 0x0804, 0x13a3,
-	0x0005, 0xa006, 0x70c2, 0x70c6, 0x70ca, 0x70ce, 0x70da, 0x70c0,
-	0xa08a, 0x0040, 0x1a04, 0x1355, 0x0002, 0x13a3, 0x13f1, 0x13bf,
-	0x1425, 0x1459, 0x1459, 0x13b7, 0x19f3, 0x1463, 0x13b1, 0x13c3,
-	0x13c4, 0x13c5, 0x13c6, 0x19f7, 0x13b1, 0x1470, 0x14c5, 0x18e4,
-	0x19ed, 0x13c7, 0x1795, 0x17cb, 0x17fa, 0x183d, 0x1752, 0x175f,
-	0x1772, 0x1784, 0x159a, 0x13b1, 0x14f7, 0x1502, 0x1510, 0x151e,
-	0x1535, 0x1543, 0x1546, 0x1554, 0x1562, 0x156c, 0x1580, 0x158c,
-	0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x15a7, 0x15b8, 0x15d2, 0x1606,
-	0x162f, 0x1641, 0x1644, 0x1677, 0x16aa, 0x16bc, 0x1720, 0x1730,
-	0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x1742, 0x2100, 0xa08a, 0x0040,
-	0x1a04, 0x13b1, 0x0002, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1,
-	0x1a19, 0x1a1f, 0x13b1, 0x13b1, 0x13b1, 0x1a23, 0x1a63, 0x13b1,
-	0x13b1, 0x13b1, 0x13b1, 0x13ec, 0x1454, 0x146b, 0x14c0, 0x18df,
-	0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x1a67, 0x1a0b, 0x1a15, 0x13b1,
-	0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1,
-	0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1,
-	0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1,
-	0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1, 0x13b1,
-	0x13b1, 0x13b1, 0x13b1, 0x72ca, 0x71c6, 0x2001, 0x4006, 0x0028,
-	0x73ce, 0x72ca, 0x71c6, 0x2001, 0x4000, 0x70c2, 0x0e04, 0x13a6,
+	0x2009, 0x0002, 0x2069, 0x4540, 0x681b, 0x0003, 0x6823, 0x0007,
+	0x6827, 0x00fa, 0x682b, 0x0008, 0x682f, 0x0028, 0x6837, 0x0006,
+	0x6833, 0x0008, 0x683b, 0x0000, 0x8109, 0x0500, 0x68cf, 0x000a,
+	0x68bf, 0x45c0, 0x2079, 0x4500, 0x68d3, 0x762d, 0x68c3, 0x4ac0,
+	0x68c7, 0x49c0, 0x68cb, 0x8ac0, 0x68a7, 0x8d44, 0x68ab, 0x8d49,
+	0x68af, 0x8d44, 0x68b3, 0x8d44, 0x68a3, 0x0001, 0x2001, 0x01ff,
+	0x2004, 0xd0fc, 0x11c8, 0x2069, 0x4580, 0x0870, 0x68cf, 0x000a,
+	0x68bf, 0x47c0, 0x68d3, 0x7839, 0x68c3, 0x6ac0, 0x68c7, 0x4a40,
+	0x68cb, 0x8bd0, 0x68a7, 0x8d49, 0x68ab, 0x8d4e, 0x68af, 0x8d49,
+	0x68b3, 0x8d49, 0x68a3, 0x0001, 0x00e6, 0x2069, 0x49c0, 0x2071,
+	0x0200, 0x70ec, 0xd0e4, 0x2019, 0x1c09, 0x2021, 0x0009, 0x1120,
+	0x2019, 0x1c0c, 0x2021, 0x000c, 0x080c, 0x1d3f, 0x2001, 0x01ff,
+	0x2004, 0xd0fc, 0x1188, 0x2069, 0x4a40, 0x2071, 0x0100, 0x70ec,
+	0xd0e4, 0x2019, 0x1c09, 0x2021, 0x0009, 0x1120, 0x2019, 0x1c0c,
+	0x2021, 0x000c, 0x080c, 0x1d3f, 0x00ee, 0x2011, 0x0002, 0x2069,
+	0x4ac0, 0x2009, 0x0002, 0x20a9, 0x0100, 0x6837, 0x0000, 0x680b,
+	0x0040, 0x7bc8, 0xa386, 0xfeff, 0x1128, 0x6817, 0x0100, 0x681f,
+	0x0064, 0x0020, 0x6817, 0x0064, 0x681f, 0x0002, 0xade8, 0x0010,
+	0x1f04, 0x1135, 0x8109, 0x1d38, 0x2001, 0x01ff, 0x2004, 0xd0fc,
+	0x1128, 0x8211, 0x0118, 0x2069, 0x6ac0, 0x08d8, 0x080c, 0x22b7,
+	0x080c, 0x3fba, 0x080c, 0x1b51, 0x080c, 0x4489, 0x2091, 0x2200,
+	0x2079, 0x4500, 0x2071, 0x0050, 0x2091, 0x2400, 0x2079, 0x4500,
+	0x2071, 0x0020, 0x2091, 0x2600, 0x2079, 0x0200, 0x2071, 0x4540,
+	0x2091, 0x2800, 0x2079, 0x0100, 0x2071, 0x4580, 0x2091, 0x2000,
+	0x2079, 0x4500, 0x2071, 0x0010, 0x3200, 0xa085, 0x303d, 0x2090,
+	0x2071, 0x0010, 0x70c3, 0x0000, 0x1004, 0x118c, 0x70c0, 0xa086,
+	0x0002, 0x1110, 0x080c, 0x13b3, 0x2039, 0x0000, 0x080c, 0x12ab,
+	0x78ac, 0xa005, 0x1180, 0x0e04, 0x119a, 0x786c, 0xa065, 0x0110,
+	0x080c, 0x2061, 0x080c, 0x1df0, 0x0e04, 0x11af, 0x786c, 0xa065,
+	0x0110, 0x080c, 0x2061, 0x0e04, 0x11af, 0x2009, 0x4547, 0x2011,
+	0x4587, 0x2104, 0x220c, 0xa105, 0x0110, 0x080c, 0x1c63, 0x2071,
+	0x4540, 0x70a0, 0xa005, 0x01e8, 0x744c, 0xa485, 0x0000, 0x01c8,
+	0x2079, 0x0200, 0x2091, 0x8000, 0x72d0, 0xa28c, 0x303d, 0x2190,
+	0x080c, 0x26ff, 0x2091, 0x8000, 0x2091, 0x303d, 0x0e04, 0x11d1,
+	0x2079, 0x4500, 0x786c, 0xa065, 0x0120, 0x2071, 0x0010, 0x080c,
+	0x2061, 0x1d04, 0x11d9, 0x2079, 0x4500, 0x2071, 0x0010, 0x080c,
+	0x42c7, 0x2071, 0x4580, 0x70a0, 0xa005, 0x0188, 0x704c, 0xa025,
+	0x0170, 0x2079, 0x0100, 0x2091, 0x8000, 0x72d0, 0xa28c, 0x303d,
+	0x2190, 0x080c, 0x26ff, 0x2091, 0x8000, 0x2091, 0x303d, 0x2079,
+	0x4500, 0x2071, 0x0010, 0x0e04, 0x11fa, 0x786c, 0xa065, 0x0110,
+	0x080c, 0x2061, 0x1d04, 0x118e, 0x080c, 0x42c7, 0x0804, 0x118e,
+	0x3c00, 0xa084, 0x0007, 0x0002, 0x120c, 0x120c, 0x120e, 0x120e,
+	0x1213, 0x1213, 0x1218, 0x1218, 0x080c, 0x252b, 0x2091, 0x2400,
+	0x080c, 0x4052, 0x0005, 0x2091, 0x2200, 0x080c, 0x4052, 0x0005,
+	0x2091, 0x2200, 0x080c, 0x4052, 0x2091, 0x2400, 0x080c, 0x4052,
+	0x0005, 0x1241, 0x1241, 0x1242, 0x1242, 0x124d, 0x124d, 0x124d,
+	0x124d, 0x1256, 0x1256, 0x1261, 0x1261, 0x124d, 0x124d, 0x124d,
+	0x124d, 0x1270, 0x1270, 0x1270, 0x1270, 0x1270, 0x1270, 0x1270,
+	0x1270, 0x1270, 0x1270, 0x1270, 0x1270, 0x1270, 0x1270, 0x1270,
+	0x1270, 0x0cf8, 0x0006, 0x0106, 0x0126, 0x2091, 0x2800, 0x080c,
+	0x2548, 0x012e, 0x010e, 0x000e, 0x000d, 0x0006, 0x0106, 0x0126,
+	0x080c, 0x1200, 0x012e, 0x010e, 0x000e, 0x000d, 0x0006, 0x0106,
+	0x0126, 0x2091, 0x2600, 0x080c, 0x2548, 0x012e, 0x010e, 0x000e,
+	0x000d, 0x0006, 0x0106, 0x0126, 0x2091, 0x2600, 0x080c, 0x2548,
+	0x2091, 0x2800, 0x080c, 0x2548, 0x012e, 0x010e, 0x000e, 0x000d,
+	0x0006, 0x0106, 0x0126, 0x00d6, 0x00e6, 0x00f6, 0x2079, 0x4500,
+	0x2071, 0x0200, 0x2069, 0x4540, 0x3d00, 0xd08c, 0x0130, 0x70ec,
+	0xa084, 0x1c00, 0x78e2, 0x080c, 0x44bd, 0x3d00, 0xd084, 0x0150,
+	0x2069, 0x4580, 0x2071, 0x0100, 0x70ec, 0xa084, 0x1c00, 0x78e6,
+	0x080c, 0x44bd, 0x080c, 0x24dc, 0x00fe, 0x00ee, 0x00de, 0x012e,
+	0x010e, 0x000e, 0x000d, 0x7008, 0x800b, 0x1240, 0x7007, 0x0002,
+	0xa08c, 0x01e0, 0x1120, 0xd09c, 0x0108, 0x0887, 0x0897, 0x70c3,
+	0x4002, 0x0804, 0x13b6, 0x0e04, 0x1317, 0x2061, 0x0000, 0x6018,
+	0xd084, 0x1904, 0x1317, 0x7828, 0xa005, 0x1120, 0x0004, 0x1318,
+	0x0804, 0x1317, 0xd0fc, 0x0148, 0x0006, 0x080c, 0x1aeb, 0x000e,
+	0x0168, 0x2001, 0x4007, 0x0804, 0x13b5, 0x0006, 0x080c, 0x1add,
+	0x000e, 0x0120, 0x2001, 0x4007, 0x0804, 0x13b5, 0x7910, 0xd0fc,
+	0x1128, 0x2061, 0x4540, 0xc19c, 0xc7fc, 0x0020, 0x2061, 0x4580,
+	0xc19d, 0xc7fd, 0x6060, 0xa005, 0x15d0, 0x7912, 0x607f, 0x0000,
+	0x7828, 0xc0fc, 0xa086, 0x0018, 0x1120, 0x00c6, 0x080c, 0x190a,
+	0x00ce, 0x782b, 0x0000, 0x6078, 0xa065, 0x0190, 0x00c6, 0x609c,
+	0x080c, 0x1bb8, 0x00ce, 0x609f, 0x0000, 0x080c, 0x1a1b, 0x2009,
+	0x0018, 0x6087, 0x0103, 0x080c, 0x1af9, 0x1198, 0x080c, 0x1b44,
+	0x7810, 0xd09c, 0x1118, 0x2061, 0x4540, 0x0020, 0x2061, 0x4580,
+	0xc09c, 0x7812, 0x607b, 0x0000, 0x60d0, 0xd0c4, 0x0130, 0xc0c4,
+	0x60d2, 0x2001, 0x4005, 0x0804, 0x13b5, 0x0804, 0x13b3, 0x0005,
+	0xa006, 0x70c2, 0x70c6, 0x70ca, 0x70ce, 0x70da, 0x70c0, 0xa03d,
+	0xa08a, 0x0040, 0x1a04, 0x1365, 0x0002, 0x13b3, 0x1401, 0x13cf,
+	0x1435, 0x1469, 0x1469, 0x13c7, 0x1a33, 0x1473, 0x13c1, 0x13d3,
+	0x13d4, 0x13d5, 0x13d6, 0x1a37, 0x13c1, 0x1480, 0x14d5, 0x1925,
+	0x1a2d, 0x13d7, 0x17b4, 0x17ea, 0x1819, 0x185c, 0x1771, 0x177e,
+	0x1791, 0x17a3, 0x15aa, 0x13c1, 0x1507, 0x1512, 0x1520, 0x152e,
+	0x1545, 0x1553, 0x1556, 0x1564, 0x1572, 0x157c, 0x1590, 0x159c,
+	0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x15b7, 0x15c8, 0x15e2, 0x1616,
+	0x163f, 0x1651, 0x1654, 0x167f, 0x16b8, 0x16ca, 0x173f, 0x174f,
+	0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x1761, 0x2100, 0xa08a, 0x0040,
+	0x1a04, 0x13c1, 0x0002, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1,
+	0x1a59, 0x1a5f, 0x13c1, 0x13c1, 0x13c1, 0x1a63, 0x1aa3, 0x13c1,
+	0x13c1, 0x13c1, 0x13c1, 0x13fc, 0x1464, 0x147b, 0x14d0, 0x1920,
+	0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x1aa7, 0x1a4b, 0x1a55, 0x18ef,
+	0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1,
+	0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1,
+	0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1,
+	0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1, 0x13c1,
+	0x13c1, 0x13c1, 0x13c1, 0x72ca, 0x71c6, 0x2001, 0x4006, 0x0028,
+	0x73ce, 0x72ca, 0x71c6, 0x2001, 0x4000, 0x70c2, 0x0e04, 0x13b6,
 	0x2061, 0x0000, 0x601b, 0x0001, 0x2091, 0x5000, 0x2091, 0x4080,
 	0x0005, 0x70c3, 0x4001, 0x0c90, 0x70c3, 0x4006, 0x0c78, 0x2099,
 	0x0041, 0x20a1, 0x0041, 0x20a9, 0x0005, 0x53a3, 0x0c20, 0x70c4,
 	0x70c3, 0x0004, 0x0807, 0x08f8, 0x08f0, 0x08e8, 0x08e0, 0x2091,
 	0x8000, 0x70c3, 0x0004, 0x70c7, 0x4953, 0x70cb, 0x5020, 0x70cf,
-	0x2020, 0x70d3, 0x000a, 0x2001, 0x0001, 0x70d6, 0x2079, 0x0000,
+	0x2020, 0x70d3, 0x000a, 0x2001, 0x0004, 0x70d6, 0x2079, 0x0000,
 	0x781b, 0x0001, 0x2031, 0x0030, 0x2059, 0x1000, 0x2029, 0x041a,
 	0x2051, 0x0445, 0x2061, 0x0447, 0x20c1, 0x0020, 0x2091, 0x5000,
 	0x2091, 0x4080, 0x0804, 0x0418, 0x75d8, 0x74dc, 0x75da, 0x74de,
 	0x0018, 0x2029, 0x0000, 0x2520, 0x71d0, 0x72c8, 0x73cc, 0x70c4,
 	0x20a0, 0x2099, 0x0030, 0x7003, 0x0001, 0x7007, 0x0006, 0x731a,
-	0x721e, 0x7422, 0x7526, 0x2021, 0x0040, 0x81ff, 0x0904, 0x13a3,
+	0x721e, 0x7422, 0x7526, 0x2021, 0x0040, 0x81ff, 0x0904, 0x13b3,
 	0xa182, 0x0040, 0x1210, 0x2120, 0xa006, 0x2008, 0x8403, 0x7012,
 	0x7007, 0x0004, 0x7007, 0x0001, 0x7008, 0xd0fc, 0x0de8, 0x7007,
-	0x0002, 0xa084, 0x01e0, 0x0120, 0x70c3, 0x4002, 0x0804, 0x13a6,
-	0x24a8, 0x53a5, 0x0c10, 0x0804, 0x13a3, 0x2029, 0x0000, 0x2520,
+	0x0002, 0xa084, 0x01e0, 0x0120, 0x70c3, 0x4002, 0x0804, 0x13b6,
+	0x24a8, 0x53a5, 0x0c10, 0x0804, 0x13b3, 0x2029, 0x0000, 0x2520,
 	0x71d0, 0x72c8, 0x73cc, 0x70c4, 0x2098, 0x20a1, 0x0030, 0x7003,
 	0x0000, 0x7007, 0x0006, 0x731a, 0x721e, 0x7422, 0x7526, 0x2021,
-	0x0040, 0x7007, 0x0006, 0x81ff, 0x0904, 0x13a3, 0xa182, 0x0040,
+	0x0040, 0x7007, 0x0006, 0x81ff, 0x0904, 0x13b3, 0xa182, 0x0040,
 	0x1210, 0x2120, 0xa006, 0x2008, 0x8403, 0x7012, 0x24a8, 0x53a6,
 	0x7007, 0x0001, 0x7008, 0xd0fc, 0x0de8, 0xa084, 0x01e0, 0x0d48,
-	0x70c3, 0x4002, 0x0804, 0x13a6, 0x75d8, 0x74dc, 0x75da, 0x74de,
+	0x70c3, 0x4002, 0x0804, 0x13b6, 0x75d8, 0x74dc, 0x75da, 0x74de,
 	0x0878, 0x71c4, 0x70c8, 0x2114, 0xa79e, 0x0004, 0x1108, 0x200a,
-	0x72ca, 0x0804, 0x13a2, 0x70c7, 0x000a, 0x70cb, 0x0001, 0x70cf,
-	0x0013, 0x0804, 0x13a3, 0x75d8, 0x76dc, 0x75da, 0x76de, 0x0018,
+	0x72ca, 0x0804, 0x13b2, 0x70c7, 0x000a, 0x70cb, 0x0004, 0x70cf,
+	0x0008, 0x0804, 0x13b3, 0x75d8, 0x76dc, 0x75da, 0x76de, 0x0018,
 	0x2029, 0x0000, 0x2530, 0x70c4, 0x72c8, 0x73cc, 0x74d0, 0x70c6,
 	0x72ca, 0x73ce, 0x74d2, 0xa005, 0x05f0, 0xa40a, 0x0110, 0x1a04,
-	0x13a5, 0x8001, 0x7872, 0xa084, 0xfc00, 0x0138, 0x78ac, 0xc085,
-	0x78ae, 0x2001, 0x4005, 0x0804, 0x13a5, 0x7b7e, 0x7a7a, 0x7e86,
+	0x13b5, 0x8001, 0x7872, 0xa084, 0xfc00, 0x0138, 0x78ac, 0xc085,
+	0x78ae, 0x2001, 0x4005, 0x0804, 0x13b5, 0x7b7e, 0x7a7a, 0x7e86,
 	0x7d82, 0x7c76, 0xa48c, 0xff00, 0x0170, 0x8407, 0x8004, 0x8004,
 	0x810c, 0x810c, 0x810f, 0xa118, 0xa291, 0x0000, 0xa6b1, 0x0000,
 	0xa581, 0x0000, 0x0050, 0x8407, 0x8004, 0x8004, 0xa318, 0xa291,
 	0x0000, 0xa6b1, 0x0000, 0xa581, 0x0000, 0x731a, 0x721e, 0x7622,
 	0x7026, 0xa605, 0x0118, 0x7a10, 0xc2c5, 0x7a12, 0x78ac, 0xa084,
-	0xfffc, 0x78ae, 0x0018, 0x78ac, 0xc085, 0x78ae, 0x0804, 0x13a3,
+	0xfffc, 0x78ae, 0x0018, 0x78ac, 0xc085, 0x78ae, 0x0804, 0x13b3,
 	0x75d8, 0x76dc, 0x75da, 0x76de, 0x0018, 0x2029, 0x0000, 0x2530,
 	0x70c4, 0x72c8, 0x73cc, 0x74d4, 0x70c6, 0x72ca, 0x73ce, 0x74d6,
-	0xa005, 0x0500, 0xa40a, 0x0110, 0x1a04, 0x13a5, 0x8001, 0x7892,
+	0xa005, 0x0500, 0xa40a, 0x0110, 0x1a04, 0x13b5, 0x8001, 0x7892,
 	0xa084, 0xfc00, 0x0138, 0x78ac, 0xc0c5, 0x78ae, 0x2001, 0x4005,
-	0x0804, 0x13a5, 0x7a9a, 0x7b9e, 0x7da2, 0x7ea6, 0x2600, 0xa505,
+	0x0804, 0x13b5, 0x7a9a, 0x7b9e, 0x7da2, 0x7ea6, 0x2600, 0xa505,
 	0x0118, 0x7a10, 0xc2c5, 0x7a12, 0x7c96, 0x78ac, 0xa084, 0xfcff,
-	0x78ae, 0x0018, 0x78ac, 0xc0c5, 0x78ae, 0x0804, 0x13a3, 0x2009,
+	0x78ae, 0x0018, 0x78ac, 0xc0c5, 0x78ae, 0x0804, 0x13b3, 0x2009,
 	0x0000, 0x786c, 0xa065, 0x0118, 0x8108, 0x6000, 0x0cd8, 0x7ac4,
-	0x0804, 0x13a1, 0x2009, 0x4348, 0x210c, 0x2001, 0x01ff, 0x2004,
-	0xd0fc, 0x1904, 0x13a2, 0x2011, 0x4388, 0x2214, 0x0804, 0x13a1,
-	0x2009, 0x4349, 0x210c, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904,
-	0x13a2, 0x2011, 0x4389, 0x2214, 0x0804, 0x13a1, 0x2061, 0x4340,
+	0x0804, 0x13b1, 0x2009, 0x4548, 0x210c, 0x2001, 0x01ff, 0x2004,
+	0xd0fc, 0x1904, 0x13b2, 0x2011, 0x4588, 0x2214, 0x0804, 0x13b1,
+	0x2009, 0x4549, 0x210c, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904,
+	0x13b2, 0x2011, 0x4589, 0x2214, 0x0804, 0x13b1, 0x2061, 0x4540,
 	0x6128, 0x622c, 0x8214, 0x8214, 0x8214, 0x2001, 0x01ff, 0x2004,
-	0xd0fc, 0x1148, 0x2061, 0x4380, 0x6328, 0x73da, 0x632c, 0x831c,
-	0x831c, 0x831c, 0x73de, 0x0804, 0x13a1, 0x2009, 0x434c, 0x210c,
-	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13a2, 0x2011, 0x438c,
-	0x2214, 0x0804, 0x13a1, 0x7918, 0x0804, 0x13a2, 0x2009, 0x434d,
-	0x210c, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13a2, 0x2011,
-	0x438d, 0x2214, 0x0804, 0x13a1, 0x2009, 0x434e, 0x210c, 0x2001,
-	0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13a2, 0x2011, 0x438e, 0x2214,
-	0x0804, 0x13a1, 0x7920, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904,
-	0x13a2, 0x7a24, 0x0804, 0x13a1, 0x2011, 0x4840, 0x71c4, 0xd1fc,
-	0x1110, 0x2011, 0x47c0, 0x8107, 0xa084, 0x000f, 0x8003, 0x8003,
-	0x8003, 0xa268, 0x6a00, 0x6b08, 0x6c1c, 0x74da, 0x0804, 0x13a0,
-	0x77c4, 0x080c, 0x1b1d, 0x2091, 0x8000, 0x6b1c, 0x6a14, 0x2091,
-	0x8001, 0x2708, 0x0804, 0x13a0, 0x2061, 0x4340, 0x6118, 0x2001,
-	0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13a2, 0x2061, 0x4380, 0x6218,
-	0x0804, 0x13a1, 0x77c4, 0x080c, 0x1b1d, 0x2091, 0x8000, 0x6908,
-	0x6a18, 0x6b10, 0x77da, 0x2091, 0x8001, 0x0804, 0x13a0, 0x71c4,
-	0x2110, 0xa294, 0x000f, 0xa282, 0x0010, 0x1a04, 0x139c, 0x080c,
-	0x230e, 0xa384, 0x4000, 0x0110, 0xa295, 0x0020, 0x0804, 0x13a0,
-	0x71c4, 0x2100, 0xc0bc, 0xa082, 0x0010, 0x1a04, 0x139c, 0xd1bc,
-	0x1120, 0x2011, 0x4348, 0x2204, 0x0020, 0x2011, 0x4388, 0x2204,
-	0xc0bd, 0x0006, 0x2100, 0xc0bc, 0x2012, 0x080c, 0x22b4, 0x001e,
-	0x0804, 0x13a2, 0x71c4, 0x2021, 0x4349, 0x2404, 0x70c6, 0x2019,
-	0x0000, 0x0030, 0x71c8, 0x2021, 0x4389, 0x2404, 0x70ca, 0xc3fd,
-	0x2011, 0x15fe, 0x20a9, 0x0008, 0x2204, 0xa106, 0x0138, 0x8210,
-	0x1f04, 0x15e4, 0x71c4, 0x72c8, 0x0804, 0x139b, 0xa292, 0x15fe,
-	0x0026, 0x2122, 0x001e, 0x080c, 0x22c6, 0x2001, 0x01ff, 0x2004,
-	0xd0fc, 0x1110, 0xd3fc, 0x09f0, 0x0804, 0x13a3, 0x03e8, 0x00fa,
-	0x01f4, 0x02ee, 0x0064, 0x0019, 0x0032, 0x004b, 0x2061, 0x4340,
+	0xd0fc, 0x1148, 0x2061, 0x4580, 0x6328, 0x73da, 0x632c, 0x831c,
+	0x831c, 0x831c, 0x73de, 0x0804, 0x13b1, 0x2009, 0x454c, 0x210c,
+	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13b2, 0x2011, 0x458c,
+	0x2214, 0x0804, 0x13b1, 0x7918, 0x0804, 0x13b2, 0x2009, 0x0202,
+	0x210c, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13b2, 0x2011,
+	0x0102, 0x2214, 0x0804, 0x13b1, 0x2009, 0x454d, 0x210c, 0x2001,
+	0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13b2, 0x2011, 0x458d, 0x2214,
+	0x0804, 0x13b1, 0x7920, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904,
+	0x13b2, 0x7a24, 0x0804, 0x13b1, 0x2011, 0x4a40, 0x71c4, 0xd1fc,
+	0x1110, 0x2011, 0x49c0, 0x8107, 0xa084, 0x000f, 0x8003, 0x8003,
+	0x8003, 0xa268, 0x6a00, 0x6b08, 0x6c1c, 0x74da, 0x0804, 0x13b0,
+	0x77c4, 0x080c, 0x1b5f, 0x2091, 0x8000, 0x6b1c, 0x6a14, 0x2091,
+	0x8001, 0x2708, 0x0804, 0x13b0, 0x2061, 0x4540, 0x6118, 0x2001,
+	0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13b2, 0x2061, 0x4580, 0x6218,
+	0x0804, 0x13b1, 0x77c4, 0x080c, 0x1b5f, 0x2091, 0x8000, 0x6908,
+	0x6a18, 0x6b10, 0x77da, 0x2091, 0x8001, 0x0804, 0x13b0, 0x71c4,
+	0x2110, 0xa294, 0x000f, 0xa282, 0x0010, 0x1a04, 0x13ac, 0x080c,
+	0x2373, 0xa384, 0x4000, 0x0110, 0xa295, 0x0020, 0x0804, 0x13b0,
+	0x71c4, 0x2100, 0xc0bc, 0xa082, 0x0010, 0x1a04, 0x13ac, 0xd1bc,
+	0x1120, 0x2011, 0x4548, 0x2204, 0x0020, 0x2011, 0x4588, 0x2204,
+	0xc0bd, 0x0006, 0x2100, 0xc0bc, 0x2012, 0x080c, 0x2319, 0x001e,
+	0x0804, 0x13b2, 0x71c4, 0x2021, 0x4549, 0x2404, 0x70c6, 0x2019,
+	0x0000, 0x0030, 0x71c8, 0x2021, 0x4589, 0x2404, 0x70ca, 0xc3fd,
+	0x2011, 0x160e, 0x20a9, 0x0008, 0x2204, 0xa106, 0x0138, 0x8210,
+	0x1f04, 0x15f4, 0x71c4, 0x72c8, 0x0804, 0x13ab, 0xa292, 0x160e,
+	0x0026, 0x2122, 0x001e, 0x080c, 0x232b, 0x2001, 0x01ff, 0x2004,
+	0xd0fc, 0x1110, 0xd3fc, 0x09f0, 0x0804, 0x13b3, 0x03e8, 0x00fa,
+	0x01f4, 0x02ee, 0x0064, 0x0019, 0x0032, 0x004b, 0x2061, 0x4540,
 	0x6128, 0x622c, 0x8214, 0x8214, 0x8214, 0x70c4, 0x602a, 0x70c8,
 	0x8003, 0x8003, 0x8003, 0x602e, 0x2001, 0x01ff, 0x2004, 0xd0fc,
-	0x11a0, 0x0026, 0x0016, 0x2061, 0x4380, 0x6128, 0x622c, 0x8214,
+	0x11a0, 0x0026, 0x0016, 0x2061, 0x4580, 0x6128, 0x622c, 0x8214,
 	0x8214, 0x8214, 0x70d8, 0x602a, 0x70dc, 0x8003, 0x8003, 0x8003,
-	0x602e, 0x71da, 0x72de, 0x001e, 0x002e, 0x0804, 0x13a1, 0x2061,
-	0x4340, 0x6130, 0x70c4, 0x6032, 0x2001, 0x01ff, 0x2004, 0xd0fc,
-	0x1904, 0x13a2, 0x2061, 0x4380, 0x6230, 0x70c8, 0x6032, 0x0804,
-	0x13a1, 0x7918, 0x0804, 0x13a2, 0x71c4, 0xa184, 0xffcf, 0x0148,
-	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904, 0x139c, 0x72c8, 0x0804,
-	0x139b, 0x2011, 0x434d, 0x2204, 0x2112, 0x0006, 0x2019, 0x0000,
-	0x080c, 0x2302, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x0118, 0x001e,
-	0x0804, 0x13a2, 0x71c8, 0xa184, 0xffcf, 0x0128, 0x0006, 0x2110,
-	0x71c4, 0x0804, 0x139b, 0x2011, 0x438d, 0x2204, 0x2112, 0x0006,
-	0xc3fd, 0x080c, 0x2302, 0x002e, 0x001e, 0x0804, 0x13a1, 0x71c4,
+	0x602e, 0x71da, 0x72de, 0x001e, 0x002e, 0x0804, 0x13b1, 0x2061,
+	0x4540, 0x6130, 0x70c4, 0x6032, 0x2001, 0x01ff, 0x2004, 0xd0fc,
+	0x1904, 0x13b2, 0x2061, 0x4580, 0x6230, 0x70c8, 0x6032, 0x0804,
+	0x13b1, 0x7918, 0x0804, 0x13b2, 0x71c4, 0xa184, 0xf0cf, 0x0148,
+	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904, 0x13ac, 0x72c8, 0x0804,
+	0x13ab, 0x0006, 0x2019, 0x0000, 0x080c, 0x2367, 0x2001, 0x01ff,
+	0x2004, 0xd0fc, 0x0118, 0x001e, 0x0804, 0x13b2, 0x71c8, 0xa184,
+	0xf0cf, 0x0128, 0x0006, 0x2110, 0x71c4, 0x0804, 0x13ab, 0x0006,
+	0xc3fd, 0x080c, 0x2367, 0x002e, 0x001e, 0x0804, 0x13b1, 0x71c4,
 	0xa182, 0x0010, 0x0248, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904,
-	0x139c, 0x72c8, 0x0804, 0x139b, 0x2011, 0x434e, 0x2204, 0x0006,
-	0x2112, 0x2019, 0x0000, 0x080c, 0x22ef, 0x2001, 0x01ff, 0x2004,
-	0xd0fc, 0x0118, 0x001e, 0x0804, 0x13a2, 0x71c8, 0xa182, 0x0010,
-	0x0228, 0x0006, 0x2110, 0x71c4, 0x0804, 0x139b, 0x2011, 0x438e,
-	0x2204, 0x0006, 0x2112, 0xc3fd, 0x080c, 0x22ef, 0x002e, 0x001e,
-	0x0804, 0x13a1, 0x71c4, 0x72c8, 0xa184, 0xfffd, 0x1904, 0x139b,
-	0xa284, 0xfffd, 0x1904, 0x139b, 0x2100, 0x7920, 0x7822, 0x2200,
-	0x7a24, 0x7826, 0x0804, 0x13a1, 0x2011, 0x4840, 0x71c4, 0xd1fc,
-	0x1110, 0x2011, 0x47c0, 0x8107, 0xa084, 0x000f, 0x8003, 0x8003,
-	0x8003, 0xa268, 0x72c8, 0x73cc, 0x74d8, 0x71c6, 0x6800, 0x70ca,
-	0x73ce, 0x74da, 0x2091, 0x8000, 0x6a02, 0xd2ac, 0x1118, 0x2021,
-	0x0000, 0x0078, 0xa484, 0x00ff, 0xa082, 0x0002, 0x16e8, 0x843f,
-	0xa7bc, 0x00ff, 0x0130, 0xa786, 0x0002, 0x15b0, 0xa484, 0x00ff,
-	0x0598, 0x2061, 0x0200, 0xd1fc, 0x0110, 0x2061, 0x0100, 0x2029,
-	0x0009, 0x2031, 0x0062, 0x843f, 0xa7bc, 0x00ff, 0x0130, 0x8307,
-	0xa084, 0x00ff, 0x1110, 0xa73d, 0x11f8, 0x2041, 0x001d, 0x8307,
-	0xa084, 0x00ff, 0x0150, 0xa842, 0x02b8, 0xa3bc, 0x00ff, 0x2500,
-	0xa702, 0x0290, 0x2600, 0xa702, 0x1278, 0x2039, 0x003a, 0x6804,
-	0xa705, 0x6806, 0x6b0a, 0x6b0c, 0x73ce, 0x681c, 0x70da, 0x6c1e,
-	0x2091, 0x8001, 0x0804, 0x13a3, 0x2091, 0x8001, 0x0804, 0x139d,
-	0x77c4, 0x080c, 0x1b1d, 0x2091, 0x8000, 0x6a14, 0x6b1c, 0x2091,
-	0x8001, 0x70c8, 0x6816, 0x70cc, 0x681e, 0x2708, 0x0804, 0x13a0,
-	0x70c4, 0x2061, 0x4340, 0x6118, 0x601a, 0x2001, 0x01ff, 0x2004,
-	0xd0fc, 0x1904, 0x13a2, 0x70c8, 0x2061, 0x4380, 0x6218, 0x601a,
-	0x0804, 0x13a1, 0x71c4, 0x72c8, 0x73cc, 0xa182, 0x0010, 0x1a04,
-	0x139c, 0x080c, 0x2332, 0xa384, 0x4000, 0x0110, 0xa295, 0x0020,
-	0x0804, 0x13a0, 0x77c4, 0x080c, 0x1b1d, 0x2091, 0x8000, 0x6a08,
-	0xc28d, 0x6a0a, 0x2091, 0x8001, 0x2708, 0x0804, 0x13a1, 0x77c4,
-	0x080c, 0x1b1d, 0x2091, 0x8000, 0x6a08, 0xa294, 0xfff9, 0x6a0a,
-	0x6804, 0xa005, 0x0110, 0x080c, 0x2233, 0x2091, 0x8001, 0x2708,
-	0x0804, 0x13a1, 0x77c4, 0x080c, 0x1b1d, 0x2091, 0x8000, 0x6a08,
-	0xc295, 0x6a0a, 0x6804, 0xa005, 0x0110, 0x080c, 0x2233, 0x2091,
-	0x8001, 0x2708, 0x0804, 0x13a1, 0x77c4, 0x2041, 0x0001, 0x2049,
-	0x0005, 0x2051, 0x0020, 0x2091, 0x8000, 0x080c, 0x1b35, 0x2091,
-	0x8001, 0x2708, 0x6a08, 0x0804, 0x13a1, 0x77c4, 0xd7fc, 0x0128,
-	0x080c, 0x1aa9, 0x0138, 0x0804, 0x13a5, 0x080c, 0x1a9b, 0x0110,
-	0x0804, 0x13a5, 0x73c8, 0x72cc, 0x77c6, 0x73ca, 0x72ce, 0x080c,
-	0x1bad, 0x11e8, 0x6818, 0xa005, 0x01a0, 0x2708, 0x0076, 0x080c,
-	0x2351, 0x007e, 0x1170, 0x2001, 0x0015, 0xd7fc, 0x1118, 0x2061,
-	0x4340, 0x0018, 0xc0fd, 0x2061, 0x4380, 0x782a, 0x2091, 0x8001,
-	0x0005, 0x2091, 0x8001, 0x2001, 0x4005, 0x0804, 0x13a5, 0x2091,
-	0x8001, 0x0804, 0x13a3, 0x77c4, 0xd7fc, 0x0128, 0x080c, 0x1aa9,
-	0x0138, 0x0804, 0x13a5, 0x080c, 0x1a9b, 0x0110, 0x0804, 0x13a5,
-	0x77c6, 0x2041, 0x0021, 0x2049, 0x0005, 0x2051, 0x0020, 0x2091,
-	0x8000, 0x080c, 0x1b35, 0x2009, 0x0016, 0xd7fc, 0x1118, 0x2061,
-	0x4340, 0x0018, 0x2061, 0x4380, 0xc1fd, 0x6067, 0x0003, 0x607f,
-	0x0000, 0x6776, 0x6083, 0x000f, 0x792a, 0x080c, 0x2233, 0x2091,
-	0x8001, 0x0005, 0x77c8, 0x77ca, 0x77c4, 0x77c6, 0xd7fc, 0x0128,
-	0x080c, 0x1aa9, 0x0138, 0x0804, 0x13a5, 0x080c, 0x1a9b, 0x0110,
-	0x0804, 0x13a5, 0xa7bc, 0xff00, 0x2091, 0x8000, 0x2009, 0x0017,
-	0xd7fc, 0x1118, 0x2061, 0x4340, 0x0018, 0x2061, 0x4380, 0xc1fd,
-	0x607f, 0x0000, 0x6067, 0x0002, 0x6776, 0x6083, 0x000f, 0x792a,
-	0x080c, 0x2233, 0x2091, 0x8001, 0x2041, 0x0021, 0x2049, 0x0005,
-	0x2051, 0x0010, 0x2091, 0x8000, 0x70c8, 0xa005, 0x0118, 0x60d4,
-	0xc0fd, 0x60d6, 0x080c, 0x1b35, 0x70c8, 0x6836, 0x8738, 0xa784,
-	0x001f, 0x1dc0, 0x2091, 0x8001, 0x0005, 0x72c8, 0xd284, 0x0128,
-	0x080c, 0x1aa9, 0x0138, 0x0804, 0x13a5, 0x080c, 0x1a9b, 0x0110,
-	0x0804, 0x13a5, 0x72c8, 0x72ca, 0x78ac, 0xa084, 0x0003, 0x1508,
-	0x2039, 0x0000, 0xd284, 0x0108, 0xc7fd, 0x2041, 0x0021, 0x2049,
-	0x0004, 0x2051, 0x0008, 0x080c, 0x1b1d, 0x2091, 0x8000, 0x6808,
-	0xc0d4, 0xa80d, 0x690a, 0x2091, 0x8001, 0x8738, 0xa784, 0x001f,
-	0x1d90, 0xa7bc, 0xff00, 0x873f, 0x8738, 0x873f, 0xa784, 0x0f00,
-	0x1d50, 0x2091, 0x8000, 0x72c8, 0x2069, 0x0100, 0xd284, 0x1110,
-	0x2069, 0x0200, 0x6808, 0xa084, 0xfffd, 0x680a, 0x6830, 0xd0b4,
-	0x01b0, 0x684b, 0x0004, 0x20a9, 0x0014, 0x6848, 0xd094, 0x0110,
-	0x1f04, 0x1885, 0x684b, 0x0009, 0x20a9, 0x0014, 0x6848, 0xd084,
-	0x0110, 0x1f04, 0x188e, 0x20a9, 0x00fa, 0x1f04, 0x1895, 0x2079,
-	0x4300, 0x2009, 0x0018, 0x72c8, 0xd284, 0x1118, 0x2061, 0x4340,
-	0x0018, 0x2061, 0x4380, 0xc1fd, 0x792a, 0x6067, 0x0001, 0x6083,
-	0x000f, 0x60a7, 0x0000, 0x60a8, 0x60b2, 0x60b6, 0x60d4, 0xd0b4,
-	0x0160, 0xc0b4, 0x60d6, 0x00c6, 0x60b8, 0xa065, 0x6008, 0xc0d4,
-	0x600a, 0x6018, 0x8001, 0x601a, 0x00ce, 0x60d4, 0xa084, 0x7eff,
-	0x60d6, 0x78ac, 0xc08d, 0x78ae, 0x681b, 0x0054, 0x2091, 0x8001,
-	0x0005, 0xd7fc, 0x1118, 0x2069, 0x4340, 0x0010, 0x2069, 0x4380,
-	0x71c4, 0x71c6, 0x6916, 0x81ff, 0x1110, 0x68a7, 0x0001, 0x78ac,
-	0xc08c, 0x78ae, 0xd084, 0x1110, 0x080c, 0x1c00, 0x0005, 0x75d8,
-	0x74dc, 0x75da, 0x74de, 0x0018, 0x2029, 0x0000, 0x2520, 0x71c4,
-	0x73c8, 0x72cc, 0x71c6, 0x73ca, 0x72ce, 0x2079, 0x4300, 0x7dde,
-	0x7cda, 0x7bd6, 0x7ad2, 0x080c, 0x1afa, 0x0904, 0x19d7, 0x20a9,
-	0x0005, 0x20a1, 0x4314, 0x2091, 0x8000, 0x41a1, 0x2091, 0x8001,
-	0x2009, 0x0040, 0x080c, 0x1cbf, 0x0120, 0x080c, 0x1b02, 0x0804,
-	0x19d7, 0x6004, 0xa08c, 0x00ff, 0xa18e, 0x0009, 0x1120, 0x0006,
-	0x080c, 0x1fe3, 0x000e, 0xa084, 0xff00, 0x8007, 0x8009, 0x0904,
-	0x1981, 0x00c6, 0x2c68, 0x080c, 0x1afa, 0x05a8, 0x2c00, 0x689e,
-	0x8109, 0x1dc0, 0x609f, 0x0000, 0x00ce, 0x00c6, 0x7ddc, 0x7cd8,
-	0x7bd4, 0x7ad0, 0xa290, 0x0040, 0xa399, 0x0000, 0xa4a1, 0x0000,
-	0xa5a9, 0x0000, 0x7dde, 0x7cda, 0x7bd6, 0x7ad2, 0x2c68, 0x689c,
-	0xa065, 0x0904, 0x1980, 0x2009, 0x0040, 0x080c, 0x1cbf, 0x1550,
-	0x6004, 0xa084, 0x00ff, 0xa086, 0x0002, 0x1168, 0x6004, 0xa084,
-	0x00ff, 0xa086, 0x000a, 0x1120, 0x0016, 0x080c, 0x1fe0, 0x001e,
-	0x2d00, 0x6002, 0x0898, 0x00ce, 0x00c6, 0x609c, 0x080c, 0x1b76,
-	0x00ce, 0x609f, 0x0000, 0x080c, 0x19db, 0x2009, 0x0018, 0x6008,
-	0xc0cd, 0x600a, 0x6004, 0x6086, 0x080c, 0x1ab7, 0x080c, 0x1b02,
-	0x0804, 0x19d7, 0x00ce, 0x00c6, 0x609c, 0x080c, 0x1b76, 0x00ce,
-	0x609f, 0x0000, 0x080c, 0x19db, 0x2009, 0x0018, 0x6087, 0x0103,
-	0x601b, 0x0003, 0x080c, 0x1ab7, 0x080c, 0x1b02, 0x0804, 0x19d7,
-	0x00ce, 0x6114, 0xd1fc, 0x0120, 0x080c, 0x1aa9, 0x01b8, 0x0018,
-	0x080c, 0x1a9b, 0x0198, 0x2029, 0x0000, 0x2520, 0x2009, 0x0018,
-	0x73c8, 0x72cc, 0x6087, 0x0103, 0x601b, 0x0021, 0x080c, 0x1ab7,
-	0x080c, 0x1b02, 0x2001, 0x4007, 0x0804, 0x13a5, 0x74c4, 0x73c8,
-	0x72cc, 0x6014, 0x2091, 0x8000, 0x00e6, 0x2009, 0x0012, 0xd0fc,
-	0x1118, 0x2071, 0x4340, 0x0018, 0x2071, 0x4380, 0xc1fd, 0x792a,
-	0x7067, 0x0005, 0x71d4, 0xa18c, 0xfe7f, 0x71d6, 0x736a, 0x726e,
-	0x7472, 0x7076, 0x707b, 0x0000, 0x2c00, 0x707e, 0xa02e, 0x2530,
-	0x611c, 0xa184, 0x0060, 0x0110, 0x080c, 0x3de5, 0x00ee, 0x6596,
+	0x13ac, 0x72c8, 0x0804, 0x13ab, 0x2011, 0x454d, 0x2204, 0x0006,
+	0x8104, 0x1208, 0x8108, 0x2112, 0x2019, 0x0000, 0x080c, 0x2354,
+	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x0118, 0x001e, 0x0804, 0x13b2,
+	0x71c8, 0xa182, 0x0010, 0x0228, 0x0006, 0x2110, 0x71c4, 0x0804,
+	0x13ab, 0x2011, 0x458d, 0x2204, 0x0006, 0x8104, 0x1208, 0x8108,
+	0x2112, 0xc3fd, 0x080c, 0x2354, 0x002e, 0x001e, 0x0804, 0x13b1,
+	0x71c4, 0x72c8, 0xa184, 0xfffd, 0x1904, 0x13ab, 0xa284, 0xfffd,
+	0x1904, 0x13ab, 0x2100, 0x7920, 0x7822, 0x2200, 0x7a24, 0x7826,
+	0x0804, 0x13b1, 0x2011, 0x4a40, 0x71c4, 0xd1fc, 0x1110, 0x2011,
+	0x49c0, 0x8107, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0xa268,
+	0x72c8, 0x73cc, 0x74d8, 0x71c6, 0x6800, 0x70ca, 0x73ce, 0x74da,
+	0x2091, 0x8000, 0x6a02, 0xd2ac, 0x1118, 0x2021, 0x0000, 0x0090,
+	0xa484, 0x00ff, 0xa082, 0x0002, 0x1a04, 0x173b, 0x843f, 0xa7bc,
+	0x00ff, 0x0140, 0xa786, 0x0002, 0x1904, 0x173b, 0xa484, 0x00ff,
+	0x0904, 0x173b, 0x2061, 0x0200, 0xd1fc, 0x0110, 0x2061, 0x0100,
+	0x2029, 0x0009, 0x2031, 0x0062, 0x843f, 0xa7bc, 0x00ff, 0x0130,
+	0x8307, 0xa084, 0x00ff, 0x1110, 0xa73d, 0x1138, 0x2041, 0x001d,
+	0xa384, 0x00ff, 0xa082, 0x001a, 0x0210, 0xa4a4, 0x00ff, 0x8307,
+	0xa084, 0x00ff, 0x0188, 0xa842, 0x02f0, 0xa086, 0x0010, 0x1120,
+	0xa39c, 0x00ff, 0xa39d, 0x0f00, 0xa3bc, 0x00ff, 0x2500, 0xa702,
+	0x0290, 0x2600, 0xa702, 0x1278, 0x2039, 0x003a, 0x6804, 0xa705,
+	0x6806, 0x6b0a, 0x6b0c, 0x73ce, 0x681c, 0x70da, 0x6c1e, 0x2091,
+	0x8001, 0x0804, 0x13b3, 0x2091, 0x8001, 0x0804, 0x13ad, 0x77c4,
+	0x080c, 0x1b5f, 0x2091, 0x8000, 0x6a14, 0x6b1c, 0x2091, 0x8001,
+	0x70c8, 0x6816, 0x70cc, 0x681e, 0x2708, 0x0804, 0x13b0, 0x70c4,
+	0x2061, 0x4540, 0x6118, 0x601a, 0x2001, 0x01ff, 0x2004, 0xd0fc,
+	0x1904, 0x13b2, 0x70c8, 0x2061, 0x4580, 0x6218, 0x601a, 0x0804,
+	0x13b1, 0x71c4, 0x72c8, 0x73cc, 0xa182, 0x0010, 0x1a04, 0x13ac,
+	0x080c, 0x2397, 0xa384, 0x4000, 0x0110, 0xa295, 0x0020, 0x0804,
+	0x13b0, 0x77c4, 0x080c, 0x1b5f, 0x2091, 0x8000, 0x6a08, 0xc28d,
+	0x6a0a, 0x2091, 0x8001, 0x2708, 0x0804, 0x13b1, 0x77c4, 0x080c,
+	0x1b5f, 0x2091, 0x8000, 0x6a08, 0xa294, 0xfff9, 0x6a0a, 0x6804,
+	0xa005, 0x0110, 0x080c, 0x2296, 0x2091, 0x8001, 0x2708, 0x0804,
+	0x13b1, 0x77c4, 0x080c, 0x1b5f, 0x2091, 0x8000, 0x6a08, 0xc295,
+	0x6a0a, 0x6804, 0xa005, 0x0110, 0x080c, 0x2296, 0x2091, 0x8001,
+	0x2708, 0x0804, 0x13b1, 0x77c4, 0x2041, 0x0001, 0x2049, 0x0005,
+	0x2051, 0x0020, 0x2091, 0x8000, 0x080c, 0x1b77, 0x2091, 0x8001,
+	0x2708, 0x6a08, 0x0804, 0x13b1, 0x77c4, 0xd7fc, 0x0128, 0x080c,
+	0x1aeb, 0x0138, 0x0804, 0x13b5, 0x080c, 0x1add, 0x0110, 0x0804,
+	0x13b5, 0x73c8, 0x72cc, 0x77c6, 0x73ca, 0x72ce, 0x080c, 0x1bef,
+	0x11e8, 0x6818, 0xa005, 0x01a0, 0x2708, 0x0076, 0x080c, 0x23b6,
+	0x007e, 0x1170, 0x2001, 0x0015, 0xd7fc, 0x1118, 0x2061, 0x4540,
+	0x0018, 0xc0fd, 0x2061, 0x4580, 0x782a, 0x2091, 0x8001, 0x0005,
+	0x2091, 0x8001, 0x2001, 0x4005, 0x0804, 0x13b5, 0x2091, 0x8001,
+	0x0804, 0x13b3, 0x77c4, 0xd7fc, 0x0128, 0x080c, 0x1aeb, 0x0138,
+	0x0804, 0x13b5, 0x080c, 0x1add, 0x0110, 0x0804, 0x13b5, 0x77c6,
+	0x2041, 0x0021, 0x2049, 0x0005, 0x2051, 0x0020, 0x2091, 0x8000,
+	0x080c, 0x1b77, 0x2009, 0x0016, 0xd7fc, 0x1118, 0x2061, 0x4540,
+	0x0018, 0x2061, 0x4580, 0xc1fd, 0x6063, 0x0003, 0x607b, 0x0000,
+	0x6772, 0x607f, 0x000f, 0x792a, 0x080c, 0x2296, 0x2091, 0x8001,
+	0x0005, 0x77c8, 0x77ca, 0x77c4, 0x77c6, 0xd7fc, 0x0128, 0x080c,
+	0x1aeb, 0x0138, 0x0804, 0x13b5, 0x080c, 0x1add, 0x0110, 0x0804,
+	0x13b5, 0xa7bc, 0xff00, 0x2091, 0x8000, 0x2009, 0x0017, 0xd7fc,
+	0x1118, 0x2061, 0x4540, 0x0018, 0x2061, 0x4580, 0xc1fd, 0x607b,
+	0x0000, 0x6063, 0x0002, 0x6772, 0x607f, 0x000f, 0x792a, 0x080c,
+	0x2296, 0x2091, 0x8001, 0x2041, 0x0021, 0x2049, 0x0005, 0x2051,
+	0x0010, 0x2091, 0x8000, 0x70c8, 0xa005, 0x0118, 0x60d0, 0xc0fd,
+	0x60d2, 0x080c, 0x1b77, 0x70c8, 0x6836, 0x8738, 0xa784, 0x001f,
+	0x1dc0, 0x2091, 0x8001, 0x0005, 0x2019, 0x0000, 0x72c8, 0xd284,
+	0x0128, 0x080c, 0x1aeb, 0x0138, 0x0804, 0x13b5, 0x080c, 0x1add,
+	0x0110, 0x0804, 0x13b5, 0x72c8, 0x72ca, 0x78ac, 0xa084, 0x0003,
+	0x1508, 0x2039, 0x0000, 0xd284, 0x0108, 0xc7fd, 0x2041, 0x0021,
+	0x2049, 0x0004, 0x2051, 0x0008, 0x080c, 0x1b5f, 0x2091, 0x8000,
+	0x6808, 0xc0d4, 0xa80d, 0x690a, 0x2091, 0x8001, 0x8738, 0xa784,
+	0x001f, 0x1d90, 0xa7bc, 0xff00, 0x873f, 0x8738, 0x873f, 0xa784,
+	0x0f00, 0x1d50, 0x2091, 0x8000, 0x72c8, 0x2069, 0x0100, 0xd284,
+	0x1110, 0x2069, 0x0200, 0x6808, 0xa084, 0xfffd, 0x680a, 0x6830,
+	0xd0b4, 0x01b0, 0x684b, 0x0004, 0x20a9, 0x0014, 0x6848, 0xd094,
+	0x0110, 0x1f04, 0x18a6, 0x684b, 0x0009, 0x20a9, 0x0014, 0x6848,
+	0xd084, 0x0110, 0x1f04, 0x18af, 0x20a9, 0x00fa, 0x1f04, 0x18b6,
+	0x2079, 0x4500, 0x2009, 0x0018, 0x72c8, 0xd284, 0x1118, 0x2061,
+	0x4540, 0x0018, 0x2061, 0x4580, 0xc1fd, 0x607b, 0x0000, 0x792a,
+	0x6063, 0x0001, 0x607f, 0x000f, 0x60a3, 0x0000, 0x60a4, 0x60ae,
+	0x60b2, 0x60d0, 0xd0b4, 0x0160, 0xc0b4, 0x60d2, 0x00c6, 0x60b4,
+	0xa065, 0x6008, 0xc0d4, 0x600a, 0x6018, 0x8001, 0x601a, 0x00ce,
+	0x60d0, 0xa084, 0x7eff, 0x60d2, 0x78ac, 0xc08d, 0x78ae, 0x83ff,
+	0x0108, 0x0005, 0x681b, 0x0054, 0x2091, 0x8001, 0x0005, 0x73cc,
+	0x080c, 0x185e, 0x69ec, 0x6a48, 0xa185, 0x1800, 0x684a, 0xa185,
+	0x0040, 0x68ee, 0x73cc, 0x2021, 0x0004, 0x20a9, 0x09ff, 0x1f04,
+	0x18ff, 0x8421, 0x1dd0, 0x8319, 0x1db0, 0x69ee, 0x6a4a, 0x2091,
+	0x8001, 0x0005, 0xd7fc, 0x1118, 0x2069, 0x4540, 0x0010, 0x2069,
+	0x4580, 0x71c4, 0x71c6, 0x6916, 0x81ff, 0x1110, 0x68a3, 0x0001,
+	0x78ac, 0xc08c, 0x78ae, 0xd084, 0x1110, 0x080c, 0x1c42, 0x0005,
+	0x75d8, 0x74dc, 0x75da, 0x74de, 0x0018, 0x2029, 0x0000, 0x2520,
+	0x71c4, 0x73c8, 0x72cc, 0x71c6, 0x73ca, 0x72ce, 0x2079, 0x4500,
+	0x7dde, 0x7cda, 0x7bd6, 0x7ad2, 0x080c, 0x1b3c, 0x0904, 0x1a17,
+	0x20a9, 0x0005, 0x20a1, 0x4514, 0x2091, 0x8000, 0x41a1, 0x2091,
+	0x8001, 0x2009, 0x0040, 0x080c, 0x1d0b, 0x0120, 0x080c, 0x1b44,
+	0x0804, 0x1a17, 0x6004, 0xa08c, 0x00ff, 0xa18e, 0x0009, 0x1120,
+	0x0006, 0x080c, 0x2046, 0x000e, 0xa084, 0xff00, 0x8007, 0x8009,
+	0x0904, 0x19c2, 0x00c6, 0x2c68, 0x080c, 0x1b3c, 0x05a8, 0x2c00,
+	0x689e, 0x8109, 0x1dc0, 0x609f, 0x0000, 0x00ce, 0x00c6, 0x7ddc,
+	0x7cd8, 0x7bd4, 0x7ad0, 0xa290, 0x0040, 0xa399, 0x0000, 0xa4a1,
+	0x0000, 0xa5a9, 0x0000, 0x7dde, 0x7cda, 0x7bd6, 0x7ad2, 0x2c68,
+	0x689c, 0xa065, 0x0904, 0x19c1, 0x2009, 0x0040, 0x080c, 0x1d0b,
+	0x1550, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0002, 0x1168, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x000a, 0x1120, 0x0016, 0x080c, 0x2043,
+	0x001e, 0x2d00, 0x6002, 0x0898, 0x00ce, 0x00c6, 0x609c, 0x080c,
+	0x1bb8, 0x00ce, 0x609f, 0x0000, 0x080c, 0x1a1b, 0x2009, 0x0018,
+	0x6008, 0xc0cd, 0x600a, 0x6004, 0x6086, 0x080c, 0x1af9, 0x080c,
+	0x1b44, 0x0804, 0x1a17, 0x00ce, 0x00c6, 0x609c, 0x080c, 0x1bb8,
+	0x00ce, 0x609f, 0x0000, 0x080c, 0x1a1b, 0x2009, 0x0018, 0x6087,
+	0x0103, 0x601b, 0x0003, 0x080c, 0x1af9, 0x080c, 0x1b44, 0x0804,
+	0x1a17, 0x00ce, 0x6114, 0xd1fc, 0x0120, 0x080c, 0x1aeb, 0x01b8,
+	0x0018, 0x080c, 0x1add, 0x0198, 0x2029, 0x0000, 0x2520, 0x2009,
+	0x0018, 0x73c8, 0x72cc, 0x6087, 0x0103, 0x601b, 0x0021, 0x080c,
+	0x1af9, 0x080c, 0x1b44, 0x2001, 0x4007, 0x0804, 0x13b5, 0x74c4,
+	0x73c8, 0x72cc, 0x6014, 0x2091, 0x8000, 0x00e6, 0x2009, 0x0012,
+	0xd0fc, 0x1118, 0x2071, 0x4540, 0x0018, 0x2071, 0x4580, 0xc1fd,
+	0x792a, 0x7063, 0x0005, 0x71d0, 0xc1c4, 0x71d2, 0x7366, 0x726a,
+	0x746e, 0x7072, 0x7077, 0x0000, 0x2c00, 0x707a, 0xa02e, 0x2530,
+	0x611c, 0xa184, 0x0060, 0x0110, 0x080c, 0x3f66, 0x00ee, 0x6596,
 	0x65a6, 0x669a, 0x66aa, 0x60af, 0x0000, 0x60b3, 0x0000, 0x6714,
-	0x6023, 0x0000, 0x080c, 0x2233, 0x2091, 0x8001, 0x0005, 0x70c3,
-	0x4005, 0x0804, 0x13a6, 0x20a9, 0x0005, 0x2099, 0x4314, 0x2091,
+	0x6023, 0x0000, 0x080c, 0x2296, 0x2091, 0x8001, 0x0005, 0x70c3,
+	0x4005, 0x0804, 0x13b6, 0x20a9, 0x0005, 0x2099, 0x4514, 0x2091,
 	0x8000, 0x530a, 0x2091, 0x8001, 0x2100, 0xa210, 0xa399, 0x0000,
 	0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x0005, 0x71c4, 0x70c7, 0x0000,
-	0x791e, 0x0804, 0x13a3, 0x71c4, 0x71c6, 0x2168, 0x0010, 0x2069,
+	0x791e, 0x0804, 0x13b3, 0x71c4, 0x71c6, 0x2168, 0x0010, 0x2069,
 	0x1000, 0x690c, 0xa016, 0x2d04, 0xa210, 0x8d68, 0x8109, 0x1dd8,
 	0xa285, 0x0000, 0x1118, 0x70c3, 0x4000, 0x0010, 0x70c3, 0x4003,
-	0x70ca, 0x0804, 0x13a6, 0x7964, 0x71c6, 0x71c4, 0xa182, 0x0003,
-	0x1a04, 0x139c, 0x7966, 0x0804, 0x13a3, 0x7964, 0x71c6, 0x0804,
-	0x13a3, 0x7900, 0x71c6, 0x71c4, 0x7902, 0x0804, 0x13a3, 0x7900,
-	0x71c6, 0x0804, 0x13a3, 0x70c4, 0x2011, 0x0000, 0xa08c, 0x000d,
+	0x70ca, 0x0804, 0x13b6, 0x7964, 0x71c6, 0x71c4, 0xa182, 0x0003,
+	0x1a04, 0x13ac, 0x7966, 0x0804, 0x13b3, 0x7964, 0x71c6, 0x0804,
+	0x13b3, 0x7900, 0x71c6, 0x71c4, 0x7902, 0x0804, 0x13b3, 0x7900,
+	0x71c6, 0x0804, 0x13b3, 0x70c4, 0x2011, 0x0000, 0xa08c, 0x000d,
 	0x0160, 0x810c, 0x0230, 0x8210, 0x810c, 0x810c, 0x0210, 0x8210,
-	0x810c, 0x81ff, 0x1904, 0x139d, 0x8210, 0x7a0e, 0xd28c, 0x0538,
+	0x810c, 0x81ff, 0x1904, 0x13ad, 0x8210, 0x7a0e, 0xd28c, 0x0538,
 	0x7910, 0xc1cd, 0x7912, 0x2009, 0x0021, 0x2019, 0x0003, 0xd284,
-	0x01c0, 0x8108, 0x2019, 0x0041, 0x2011, 0x8b4e, 0x2312, 0x2019,
+	0x01c0, 0x8108, 0x2019, 0x0041, 0x2011, 0x8d4e, 0x2312, 0x2019,
 	0x0042, 0x8210, 0x2312, 0x2019, 0x0043, 0x8210, 0x2312, 0x2019,
 	0x0046, 0x8210, 0x2312, 0x2019, 0x0047, 0x8210, 0x2312, 0x2019,
-	0x0006, 0x2011, 0x8b53, 0x2112, 0x2011, 0x8b73, 0x2312, 0x7904,
-	0x7806, 0x0804, 0x13a2, 0x7804, 0x70c6, 0x0804, 0x13a3, 0x71c4,
-	0xd1fc, 0x1118, 0x2011, 0x47c0, 0x0010, 0x2011, 0x4840, 0x8107,
+	0x0006, 0x2011, 0x8d53, 0x2112, 0x2011, 0x8d73, 0x2312, 0x7904,
+	0x7806, 0x0804, 0x13b2, 0x7804, 0x70c6, 0x0804, 0x13b3, 0x71c4,
+	0xd1fc, 0x1118, 0x2011, 0x49c0, 0x0010, 0x2011, 0x4a40, 0x8107,
 	0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0xa268, 0x2011, 0x0000,
 	0x6814, 0xd0fc, 0x0110, 0xa295, 0x0200, 0xd0b4, 0x0110, 0xa295,
-	0x0001, 0x6b0c, 0x0804, 0x13a0, 0x0016, 0x7814, 0xd0f4, 0x0138,
-	0x2001, 0x4007, 0x70db, 0x0000, 0xa18d, 0x0001, 0x0050, 0xd0fc,
-	0x0138, 0x2001, 0x4007, 0x70db, 0x0001, 0xa18d, 0x0001, 0x0008,
-	0xa006, 0x001e, 0x0005, 0x0016, 0x7814, 0xd0f4, 0x0138, 0x2001,
-	0x4007, 0x70db, 0x0000, 0xa18d, 0x0001, 0x0008, 0xa006, 0x001e,
-	0x0005, 0x0016, 0x7814, 0xd0fc, 0x0138, 0x2001, 0x4007, 0x70db,
-	0x0001, 0xa18d, 0x0001, 0x0008, 0xa006, 0x001e, 0x0005, 0x7112,
-	0x721a, 0x731e, 0x7810, 0xd0c4, 0x0110, 0x7422, 0x7526, 0xac80,
-	0x0001, 0x8108, 0x810c, 0x81a9, 0x8098, 0x20a1, 0x0030, 0x7003,
-	0x0000, 0x6084, 0x20a2, 0x53a6, 0x7007, 0x0001, 0x7974, 0xa184,
-	0xff00, 0x0140, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004, 0x8007,
-	0xa100, 0x0018, 0x8107, 0x8004, 0x8004, 0x797c, 0xa108, 0x7a78,
-	0xa006, 0xa211, 0x7d10, 0xd5c4, 0x0120, 0x7b84, 0xa319, 0x7c80,
-	0xa421, 0x7008, 0xd0fc, 0x0de8, 0x7003, 0x0001, 0x7007, 0x0006,
-	0x711a, 0x721e, 0x7d10, 0xd5c4, 0x0110, 0x7322, 0x7426, 0xa084,
-	0x01e0, 0x0005, 0x7848, 0xa065, 0x0120, 0x2c04, 0x784a, 0x2063,
-	0x0000, 0x0005, 0x00f6, 0x2079, 0x4300, 0x7848, 0x2062, 0x2c00,
-	0xa005, 0x1110, 0x080c, 0x243b, 0x784a, 0x00fe, 0x0005, 0x2011,
-	0x8d00, 0x7a4a, 0x7bc4, 0x8319, 0x0128, 0xa280, 0x0032, 0x2012,
-	0x2010, 0x0cc8, 0x2013, 0x0000, 0x0005, 0x0016, 0x0026, 0xd7fc,
-	0x1118, 0x2011, 0x48c0, 0x0010, 0x2011, 0x68c0, 0xa784, 0x0f00,
-	0x800b, 0xa784, 0x001f, 0x0120, 0x8003, 0x8003, 0x8003, 0x8003,
-	0xa105, 0xa268, 0x002e, 0x001e, 0x0005, 0x0c39, 0x2900, 0x682a,
-	0x2a00, 0x682e, 0x6808, 0xa084, 0xf9ef, 0xa80d, 0x690a, 0x00e6,
-	0xd7fc, 0x1128, 0x2009, 0x4353, 0x2071, 0x4340, 0x0020, 0x2009,
-	0x4393, 0x2071, 0x4380, 0x210c, 0x6804, 0xa005, 0x0148, 0xa116,
-	0x1138, 0x2060, 0x6000, 0x6806, 0x0016, 0x200b, 0x0000, 0x0018,
-	0x2009, 0x0000, 0x0016, 0x6804, 0xa065, 0x0178, 0x6000, 0x6806,
-	0x0421, 0x080c, 0x1d30, 0x6810, 0x7908, 0x8109, 0x790a, 0x8001,
-	0x6812, 0x1d88, 0x7910, 0xc1a5, 0x7912, 0x001e, 0x6902, 0x6906,
-	0x2d00, 0x2060, 0x080c, 0x2580, 0x00ee, 0x0005, 0xa065, 0x0160,
-	0x2008, 0x609c, 0xa005, 0x0128, 0x2062, 0x609f, 0x0000, 0xa065,
-	0x0cc0, 0x7848, 0x794a, 0x2062, 0x0005, 0x6007, 0x0103, 0x608f,
-	0x0000, 0x20a9, 0x001c, 0xac80, 0x0005, 0x20a0, 0x2001, 0x0000,
-	0x40a4, 0x6828, 0x601a, 0x682c, 0x6022, 0x0005, 0x00e6, 0xd7fc,
-	0x1128, 0x2071, 0x4340, 0x2031, 0x43c0, 0x0020, 0x2071, 0x4380,
-	0x2031, 0x45c0, 0x7050, 0xa08c, 0x0200, 0x1128, 0xa608, 0x2d0a,
-	0x8000, 0x7052, 0xa006, 0x00ee, 0x0005, 0x00f6, 0xd7fc, 0x1118,
-	0x2079, 0x4340, 0x0010, 0x2079, 0x4380, 0x080c, 0x1b1d, 0x2091,
-	0x8000, 0x6804, 0x780a, 0xa065, 0x0904, 0x1bfe, 0x0030, 0x2c00,
-	0x780a, 0x2060, 0x6000, 0xa065, 0x05c8, 0x6010, 0xa306, 0x1db8,
-	0x600c, 0xa206, 0x1da0, 0x2c28, 0x784c, 0xac06, 0x1108, 0x0458,
-	0x6804, 0xac06, 0x1140, 0x6000, 0x2060, 0x6806, 0xa005, 0x1118,
-	0x6803, 0x0000, 0x0048, 0x6400, 0x7808, 0x2060, 0x6402, 0xa486,
-	0x0000, 0x1110, 0x2c00, 0x6802, 0x2560, 0x00fe, 0x080c, 0x1b85,
-	0x00f6, 0x601b, 0x0005, 0x6023, 0x0020, 0x00fe, 0x080c, 0x1d30,
-	0x00f6, 0x7908, 0x8109, 0x790a, 0x6810, 0x8001, 0x6812, 0x1118,
-	0x7810, 0xc0a5, 0x7812, 0x2001, 0xffff, 0xa005, 0x00fe, 0x0005,
-	0x0076, 0x2700, 0x2039, 0x0000, 0xd0fc, 0x0108, 0xc7fd, 0x2041,
-	0x0021, 0x2049, 0x0004, 0x2051, 0x0008, 0x2091, 0x8000, 0x080c,
-	0x1b35, 0x8738, 0xa784, 0x001f, 0x1dd0, 0xa7bc, 0xff00, 0x873f,
-	0x8738, 0x873f, 0xa784, 0x0f00, 0x1d90, 0x2091, 0x8001, 0x007e,
-	0x0005, 0x786c, 0x2009, 0x8b74, 0x210c, 0xa10d, 0x0118, 0xa065,
-	0x0804, 0x1ffe, 0x2061, 0x0000, 0x6018, 0xd084, 0x11b8, 0x7810,
-	0xd08c, 0x0130, 0xc08c, 0x7812, 0xc7fc, 0x2069, 0x4340, 0x0028,
-	0xc08d, 0x7812, 0x2069, 0x4380, 0xc7fd, 0x2091, 0x8000, 0x681c,
-	0x681f, 0x0000, 0x2091, 0x8001, 0xa005, 0x1108, 0x0005, 0xa08c,
-	0xfff0, 0x0110, 0x080c, 0x243b, 0x0002, 0x1c5d, 0x1c60, 0x1c66,
-	0x1c6a, 0x1c5e, 0x1c6e, 0x1c5e, 0x1c5e, 0x1c5e, 0x1c73, 0x1c9f,
-	0x1ca2, 0x1ca7, 0x1c5e, 0x1c5e, 0x1c5e, 0x0005, 0x080c, 0x243b,
-	0x080c, 0x1c00, 0x2001, 0x8001, 0x0804, 0x1cb0, 0x2001, 0x8003,
-	0x0804, 0x1cb0, 0x2001, 0x8004, 0x0804, 0x1cb0, 0x080c, 0x1c00,
-	0x2001, 0x8006, 0x04e8, 0x2091, 0x8000, 0x0076, 0xd7fc, 0x1128,
-	0x2069, 0x4340, 0x2039, 0x0009, 0x0020, 0x2069, 0x4380, 0x2039,
-	0x0009, 0x6800, 0xa086, 0x0000, 0x0128, 0x000e, 0x6f1e, 0x2091,
-	0x8001, 0x0005, 0x6874, 0x007e, 0xa0bc, 0xff00, 0x2041, 0x0021,
-	0x2049, 0x0004, 0x2051, 0x0010, 0x080c, 0x1b35, 0x8738, 0xa784,
-	0x001f, 0x1dd0, 0x2091, 0x8001, 0x2001, 0x800a, 0x0088, 0x2001,
-	0x800c, 0x0070, 0x080c, 0x1c00, 0x2001, 0x800d, 0x0048, 0xd7fc,
-	0x0110, 0x78ec, 0x0008, 0x78e4, 0x70c6, 0x2001, 0x800e, 0x0000,
-	0x70c2, 0xd7fc, 0x1118, 0x70db, 0x0000, 0x0010, 0x70db, 0x0001,
-	0x2061, 0x0000, 0x601b, 0x0001, 0x2091, 0x4080, 0x0005, 0xac80,
-	0x0001, 0x81ff, 0x0518, 0x2099, 0x0030, 0x20a0, 0x700c, 0xa084,
-	0x07ff, 0x0100, 0x7018, 0x0006, 0x701c, 0x0006, 0x7020, 0x0006,
-	0x7024, 0x0006, 0x7112, 0x81ac, 0x721a, 0x731e, 0x7422, 0x7526,
-	0x7003, 0x0001, 0x7007, 0x0001, 0x7008, 0x800b, 0x1ee8, 0x7007,
-	0x0002, 0xa08c, 0x01e0, 0x1110, 0x53a5, 0xa006, 0x7003, 0x0000,
-	0x7007, 0x0004, 0x000e, 0x7026, 0x000e, 0x7022, 0x000e, 0x701e,
-	0x000e, 0x701a, 0x0005, 0x2011, 0x0020, 0x2009, 0x0010, 0x6b0a,
-	0x6c0e, 0x681f, 0x0201, 0x6803, 0xfd20, 0x6807, 0x0038, 0x6a1a,
-	0x2d00, 0xa0e8, 0x0008, 0xa290, 0x0004, 0x8109, 0x1d80, 0x0005,
-	0x70ec, 0xd0dc, 0x1520, 0x2029, 0x0001, 0x7814, 0xd0cc, 0x1160,
-	0x70ec, 0xd0e4, 0x2019, 0x0c0a, 0x2021, 0x000a, 0x1120, 0x2019,
-	0x0c0c, 0x2021, 0x000c, 0x0070, 0x70ec, 0xd0e4, 0x1128, 0x2019,
-	0x1c0c, 0x2021, 0x000c, 0x0030, 0x2019, 0x1c09, 0x2021, 0x0009,
-	0xa5ad, 0x0200, 0x6b0a, 0x6c0e, 0x6d1e, 0x6807, 0x0038, 0x0005,
-	0x6004, 0x6086, 0x2c08, 0x2063, 0x0000, 0x7868, 0xa005, 0x796a,
-	0x0110, 0x2c02, 0x0008, 0x796e, 0x0005, 0x00c6, 0x2061, 0x4300,
-	0x6887, 0x0103, 0x2d08, 0x206b, 0x0000, 0x6068, 0xa005, 0x616a,
-	0x0110, 0x2d02, 0x0008, 0x616e, 0x00ce, 0x0005, 0x2091, 0x8000,
-	0x2c04, 0x786e, 0xa005, 0x1108, 0x786a, 0x2091, 0x8001, 0x609c,
-	0xa005, 0x0188, 0x00c6, 0x2060, 0x2008, 0x609c, 0xa005, 0x0138,
-	0x2062, 0x609f, 0x0000, 0xa065, 0x609c, 0xa005, 0x1dc8, 0x7848,
-	0x794a, 0x2062, 0x00ce, 0x7848, 0x2062, 0x609f, 0x0000, 0xac85,
-	0x0000, 0x1110, 0x080c, 0x243b, 0x784a, 0x0005, 0x20a9, 0x0010,
-	0xa006, 0x8004, 0x8086, 0x818e, 0x1208, 0xa200, 0x1f04, 0x1d7a,
-	0x8086, 0x818e, 0x0005, 0x0156, 0x20a9, 0x0010, 0xa005, 0x01b8,
-	0xa11a, 0x12a8, 0x8213, 0x818d, 0x0228, 0xa11a, 0x1220, 0x1f04,
-	0x1d8a, 0x0028, 0xa11a, 0x2308, 0x8210, 0x1f04, 0x1d8a, 0x0006,
-	0x3200, 0xa084, 0xefff, 0x2080, 0x000e, 0x015e, 0x0005, 0x0006,
-	0x3200, 0xa085, 0x1000, 0x0cb8, 0x7d74, 0x70d0, 0xa506, 0x0904,
-	0x1e5b, 0x7810, 0x2050, 0x7800, 0xd08c, 0x0100, 0x080c, 0x1afa,
-	0x0904, 0x1e5b, 0xa046, 0x7970, 0x2500, 0x8000, 0xa112, 0x2009,
-	0x0040, 0x1208, 0x0030, 0x72d0, 0xa206, 0x0118, 0x8840, 0x2009,
-	0x0080, 0x00c6, 0x7112, 0x7007, 0x0001, 0x2099, 0x0030, 0x20a9,
-	0x0020, 0xac80, 0x0001, 0x20a0, 0x2061, 0x0000, 0x88ff, 0x0110,
-	0x080c, 0x1afa, 0x7008, 0xd0fc, 0x0de8, 0x7007, 0x0002, 0x2091,
-	0x8001, 0xa08c, 0x01e0, 0x1538, 0x53a5, 0x8cff, 0x1120, 0x88ff,
-	0x0904, 0x1e48, 0x0050, 0x2c00, 0x788e, 0x20a9, 0x0020, 0xac80,
-	0x0001, 0x20a0, 0x53a5, 0x0804, 0x1e48, 0xa046, 0x7218, 0x731c,
-	0xdac4, 0x0110, 0x7420, 0x7524, 0xa292, 0x0040, 0xa39b, 0x0000,
-	0xa4a3, 0x0000, 0xa5ab, 0x0000, 0x721a, 0x731e, 0xdac4, 0x0118,
-	0x7422, 0x7526, 0xa006, 0x7007, 0x0004, 0x0904, 0x1e48, 0x8cff,
-	0x0110, 0x080c, 0x1b02, 0x00ce, 0x080c, 0x1b02, 0xa046, 0x7888,
-	0x8000, 0x788a, 0xa086, 0x0002, 0x01c0, 0x7a7c, 0x7b78, 0xdac4,
-	0x0110, 0x7c84, 0x7d80, 0x7974, 0x8107, 0x8004, 0x8004, 0xa210,
-	0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x721a, 0x731e,
-	0xdac4, 0x0588, 0x7422, 0x7526, 0x0470, 0x6014, 0xd0fc, 0x1118,
-	0x2069, 0x4340, 0x0010, 0x2069, 0x4380, 0x2091, 0x8000, 0x681f,
-	0x0002, 0x88ff, 0x0120, 0xa046, 0x788c, 0x2060, 0x0c70, 0x788b,
-	0x0000, 0x78ac, 0xa085, 0x0003, 0x78ae, 0x2091, 0x8001, 0x0098,
-	0x00ce, 0x788b, 0x0000, 0x080c, 0x1fb9, 0x6004, 0xa084, 0x000f,
-	0x0059, 0x88ff, 0x0130, 0x788c, 0x2060, 0x6004, 0xa084, 0x000f,
-	0x0019, 0x0804, 0x1da4, 0x0005, 0x0002, 0x1e6d, 0x1e88, 0x1ea1,
-	0x1e6d, 0x1eae, 0x1e7e, 0x1e6d, 0x1e6d, 0x1e6d, 0x1e86, 0x1e9f,
-	0x1e6d, 0x1e6d, 0x1e6d, 0x1e6d, 0x1e6d, 0x2039, 0x0400, 0x78bc,
-	0xa705, 0x78be, 0x6008, 0xa705, 0x600a, 0x080c, 0x1eea, 0x609c,
-	0x78ba, 0x609f, 0x0000, 0x080c, 0x1fa5, 0x0005, 0x78bc, 0xd0c4,
-	0x0108, 0x0c58, 0x601c, 0xc0bd, 0x601e, 0x0030, 0x080c, 0x1fe3,
-	0x78bc, 0xd0c4, 0x0108, 0x0c08, 0x78bf, 0x0000, 0x6004, 0x8007,
-	0xa084, 0x00ff, 0x78b2, 0x8001, 0x0138, 0x080c, 0x1eea, 0x0120,
-	0x78bc, 0xc0c5, 0x78be, 0x0010, 0x0804, 0x1f05, 0x0005, 0x080c,
-	0x1fe0, 0x78bc, 0xa08c, 0x0e00, 0x1110, 0xd0c4, 0x1108, 0x0828,
-	0x080c, 0x1eea, 0x1110, 0x0804, 0x1f05, 0x0005, 0x78bc, 0xd0c4,
-	0x0110, 0x0804, 0x1e6d, 0x78bf, 0x0000, 0x6714, 0x2011, 0x0001,
-	0x22a8, 0x6018, 0xa084, 0x00ff, 0xa005, 0x0188, 0xa7bc, 0xff00,
-	0x20a9, 0x0020, 0xa08e, 0x0001, 0x0150, 0xa7bc, 0x8000, 0x2011,
-	0x0002, 0x20a9, 0x0100, 0xa08e, 0x0002, 0x0108, 0x00c0, 0x080c,
-	0x1b1d, 0x2d00, 0x2091, 0x8000, 0x682b, 0x0000, 0x682f, 0x0000,
-	0x6808, 0xa084, 0xffde, 0x680a, 0xade8, 0x0010, 0x2091, 0x8001,
-	0x1f04, 0x1ed2, 0x8211, 0x0118, 0x20a9, 0x0100, 0x0c58, 0x080c,
-	0x1b02, 0x0005, 0x609f, 0x0000, 0x78b4, 0xa06d, 0x2c00, 0x78b6,
-	0x1110, 0x78ba, 0x0038, 0x689e, 0x2d00, 0x6002, 0x78b8, 0xad06,
-	0x1108, 0x6002, 0x78b0, 0x8001, 0x78b2, 0x1130, 0x78bc, 0xc0c4,
-	0x78be, 0x78b8, 0x2060, 0xa006, 0x0005, 0x00e6, 0xa02e, 0x2530,
-	0x7dba, 0x7db6, 0x65ae, 0x65b2, 0x601c, 0x60a2, 0x2048, 0xa984,
-	0xe1ff, 0x601e, 0xa984, 0x0060, 0x0110, 0x080c, 0x3de5, 0x6596,
-	0x65a6, 0x669a, 0x66aa, 0x6714, 0x2071, 0x4380, 0xd7fc, 0x1110,
-	0x2071, 0x4340, 0xa784, 0x0f00, 0x800b, 0xa784, 0x001f, 0x0120,
-	0x8003, 0x8003, 0x8003, 0x8003, 0xa105, 0x71c4, 0xa168, 0x2700,
-	0x8007, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0x71c8, 0xa100,
-	0x60c2, 0x2091, 0x8000, 0x6e08, 0xd684, 0x0170, 0xd9fc, 0x1160,
-	0x2091, 0x8001, 0x080c, 0x1b85, 0x2091, 0x8000, 0x080c, 0x1d30,
-	0x2091, 0x8001, 0x0804, 0x1fa3, 0x6024, 0xa096, 0x0001, 0x1110,
-	0x8000, 0x6026, 0x6a10, 0x6814, 0xa202, 0x0268, 0x0160, 0x2091,
-	0x8001, 0x2039, 0x0200, 0x609c, 0x78ba, 0x609f, 0x0000, 0x080c,
-	0x1fa5, 0x0804, 0x1fa3, 0x2c08, 0xd9fc, 0x01f0, 0x6800, 0xa065,
-	0x01d8, 0x6a04, 0x7000, 0xa084, 0x0002, 0x0168, 0x704c, 0xa206,
-	0x1150, 0x6b04, 0x2160, 0x2304, 0x6002, 0xa005, 0x1108, 0x6902,
-	0x2260, 0x6102, 0x0098, 0x2d00, 0x2060, 0x080c, 0x2580, 0x6e08,
-	0x2160, 0x6202, 0x6906, 0x0050, 0x6800, 0x6902, 0xa065, 0x0110,
-	0x6102, 0x0008, 0x6906, 0x2160, 0x6003, 0x0000, 0x2160, 0xd9fc,
-	0x0118, 0xa6b4, 0xfffc, 0x6e0a, 0x6810, 0x7d08, 0x8528, 0x7d0a,
-	0x8000, 0x6812, 0x2091, 0x8001, 0xd6b4, 0x0128, 0xa6b6, 0x0040,
-	0x6e0a, 0x080c, 0x1b96, 0x00ee, 0x0005, 0x6008, 0xa705, 0x600a,
-	0x2091, 0x8000, 0x080c, 0x1d30, 0x2091, 0x8001, 0x78b8, 0xa065,
-	0x0128, 0x609c, 0x78ba, 0x609f, 0x0000, 0x0c78, 0x78b6, 0x78ba,
-	0x0005, 0x7970, 0x7874, 0x2818, 0xd384, 0x0118, 0x8000, 0xa112,
-	0x0220, 0x8000, 0xa112, 0x1278, 0xc384, 0x7a7c, 0x721a, 0x7a78,
-	0x721e, 0xdac4, 0x0120, 0x7a84, 0x7222, 0x7a80, 0x7226, 0xa006,
-	0xd384, 0x0108, 0x8000, 0x7876, 0x70d2, 0x781c, 0xa005, 0x0138,
-	0x8001, 0x781e, 0x1120, 0x0e04, 0x1fdf, 0x2091, 0x4080, 0x0005,
-	0x2039, 0x1ff5, 0x0010, 0x2039, 0x1ffb, 0x2704, 0xa005, 0x0160,
-	0xac00, 0x2068, 0x6908, 0x6810, 0x6912, 0x680a, 0x690c, 0x6814,
-	0x6916, 0x680e, 0x8738, 0x0c88, 0x0005, 0x0003, 0x0009, 0x000f,
-	0x0015, 0x001b, 0x0000, 0x0015, 0x001b, 0x0000, 0x2041, 0x0000,
-	0x780c, 0x0002, 0x21a7, 0x2182, 0x2006, 0x2076, 0x2039, 0x8b74,
-	0x2734, 0x7d10, 0x00c0, 0x6084, 0xa086, 0x0103, 0x1904, 0x2060,
-	0x6114, 0x6018, 0xa105, 0x0120, 0x86ff, 0x11d8, 0x0804, 0x2060,
-	0x8603, 0xa080, 0x8b55, 0x620c, 0x2202, 0x8000, 0x6210, 0x2202,
-	0x080c, 0x1d4e, 0x8630, 0xa68e, 0x000f, 0x0904, 0x20e1, 0x786c,
-	0xa065, 0x1d08, 0x7808, 0xa602, 0x1220, 0xd5ac, 0x1110, 0x263a,
-	0x0005, 0xa682, 0x0003, 0x1a04, 0x20e1, 0x2091, 0x8000, 0x2069,
-	0x0000, 0x6818, 0xd084, 0x11f8, 0x2011, 0x8b55, 0x2204, 0x70c6,
-	0x8210, 0x2204, 0x70ca, 0xd684, 0x1130, 0x8210, 0x2204, 0x70da,
-	0x8210, 0x2204, 0x70de, 0xa685, 0x8020, 0x70c2, 0x681b, 0x0001,
-	0x2091, 0x4080, 0x7810, 0xa084, 0xffcf, 0x7812, 0x2091, 0x8001,
-	0x203b, 0x0000, 0x0005, 0x7810, 0xc0ad, 0x7812, 0x0804, 0x20e1,
-	0x263a, 0x080c, 0x21ad, 0x1904, 0x21c9, 0x786c, 0xa065, 0x1904,
-	0x200b, 0x2091, 0x8000, 0x7810, 0xa084, 0xffcf, 0x86ff, 0x0108,
-	0xc0ad, 0x7812, 0x2091, 0x8001, 0x0804, 0x21c9, 0x2039, 0x8b74,
-	0x2734, 0x7d10, 0x00a0, 0x6084, 0xa086, 0x0103, 0x1904, 0x20cb,
-	0x6114, 0x6018, 0xa105, 0x0120, 0x86ff, 0x11b8, 0x0804, 0x20cb,
-	0xa680, 0x8b55, 0x620c, 0x2202, 0x080c, 0x1d4e, 0x8630, 0xa68e,
-	0x001e, 0x0904, 0x20e1, 0x786c, 0xa065, 0x1d28, 0x7808, 0xa602,
-	0x1220, 0xd5ac, 0x1110, 0x263a, 0x0005, 0xa682, 0x0006, 0x1a04,
-	0x20e1, 0x2091, 0x8000, 0x2069, 0x0000, 0x6818, 0xd084, 0x11f8,
-	0x2011, 0x8b55, 0x2009, 0x8b4e, 0x26a8, 0x211c, 0x2204, 0x201a,
-	0x8108, 0x8210, 0x1f04, 0x20ad, 0xa685, 0x8030, 0x70c2, 0x681b,
-	0x0001, 0x2091, 0x4080, 0x7810, 0xa084, 0xffcf, 0x7812, 0x2091,
-	0x8001, 0xa006, 0x2009, 0x8b75, 0x200a, 0x203a, 0x0005, 0x7810,
-	0xc0ad, 0x7812, 0x00b0, 0x263a, 0x080c, 0x21ad, 0x1904, 0x21c9,
-	0x786c, 0xa065, 0x1904, 0x207b, 0x2091, 0x8000, 0x7810, 0xa084,
-	0xffcf, 0x86ff, 0x0108, 0xc0ad, 0x7812, 0x2091, 0x8001, 0x0804,
-	0x21c9, 0x2091, 0x8000, 0x7007, 0x0004, 0x7994, 0x70d4, 0xa102,
-	0x0228, 0x0168, 0x7b90, 0xa302, 0x1150, 0x0010, 0x8002, 0x1138,
-	0x263a, 0x7810, 0xc0ad, 0x7812, 0x2091, 0x8001, 0x0005, 0xa184,
-	0xff00, 0x0140, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004, 0x8007,
-	0xa100, 0x0018, 0x8107, 0x8004, 0x8004, 0x7a9c, 0xa210, 0x721a,
-	0x7a98, 0xa006, 0xa211, 0x721e, 0xd4c4, 0x0130, 0x7aa4, 0xa211,
-	0x7222, 0x7aa0, 0xa211, 0x7226, 0x20a1, 0x0030, 0x7003, 0x0000,
-	0x2009, 0x8b54, 0x260a, 0x8109, 0x2198, 0x2104, 0xd084, 0x0108,
-	0x8633, 0xa6b0, 0x0002, 0x26a8, 0x53a6, 0x8603, 0x7012, 0x7007,
-	0x0001, 0x7990, 0x7894, 0x8000, 0xa10a, 0x1208, 0xa006, 0x2028,
+	0x0001, 0x6b0c, 0x6800, 0x70da, 0x0804, 0x13b0, 0x0016, 0x7814,
+	0xd0f4, 0x0138, 0x2001, 0x4007, 0x70db, 0x0000, 0xa18d, 0x0001,
+	0x0050, 0xd0fc, 0x0138, 0x2001, 0x4007, 0x70db, 0x0001, 0xa18d,
+	0x0001, 0x0008, 0xa006, 0x001e, 0x0005, 0x0016, 0x7814, 0xd0f4,
+	0x0138, 0x2001, 0x4007, 0x70db, 0x0000, 0xa18d, 0x0001, 0x0008,
+	0xa006, 0x001e, 0x0005, 0x0016, 0x7814, 0xd0fc, 0x0138, 0x2001,
+	0x4007, 0x70db, 0x0001, 0xa18d, 0x0001, 0x0008, 0xa006, 0x001e,
+	0x0005, 0x7112, 0x721a, 0x731e, 0x7810, 0xd0c4, 0x0110, 0x7422,
+	0x7526, 0xac80, 0x0001, 0x8108, 0x810c, 0x81a9, 0x8098, 0x20a1,
+	0x0030, 0x7003, 0x0000, 0x6084, 0x20a2, 0x53a6, 0x7007, 0x0001,
 	0x7974, 0xa184, 0xff00, 0x0140, 0x810f, 0x810c, 0x810c, 0x8004,
 	0x8004, 0x8007, 0xa100, 0x0018, 0x8107, 0x8004, 0x8004, 0x797c,
-	0xa108, 0x7a78, 0xa006, 0xa211, 0xd4c4, 0x0120, 0x7b84, 0xa319,
-	0x7c80, 0xa421, 0x7008, 0xd0fc, 0x0de8, 0xa084, 0x01e0, 0x01d0,
-	0x7d10, 0x2031, 0x8b54, 0x2634, 0x78a8, 0x8000, 0x78aa, 0xd08c,
-	0x1138, 0x7007, 0x0006, 0x7004, 0xd094, 0x1de8, 0x0804, 0x20e3,
-	0x2069, 0x4347, 0x206b, 0x0003, 0x78ac, 0xa085, 0x0300, 0x78ae,
-	0xa006, 0x0048, 0x2030, 0x75d6, 0x2091, 0x4080, 0x7d96, 0x7d10,
-	0xa5ac, 0xffcf, 0x7d12, 0x2091, 0x8001, 0x78aa, 0x7007, 0x0006,
-	0x263a, 0x7003, 0x0001, 0x711a, 0x721e, 0xd5c4, 0x0110, 0x7322,
-	0x7426, 0x0005, 0x6084, 0xa086, 0x0103, 0x11d8, 0x6114, 0x6018,
-	0xa105, 0x11b8, 0x2069, 0x0000, 0x6818, 0xd084, 0x1190, 0x600c,
-	0x70c6, 0x6010, 0x70ca, 0x70c3, 0x8020, 0x681b, 0x0001, 0x2091,
-	0x4080, 0x080c, 0x1d4e, 0x0e04, 0x21a0, 0x786c, 0xa065, 0x1d10,
-	0x0005, 0x0059, 0x1530, 0x786c, 0xa065, 0x19e0, 0x0410, 0x0029,
-	0x1500, 0x786c, 0xa065, 0x1dd8, 0x00e0, 0x6084, 0xa086, 0x0103,
-	0x1168, 0x6018, 0xc0fc, 0x601a, 0xa086, 0x0004, 0x1138, 0x7804,
-	0xd0a4, 0x0120, 0x080c, 0x1d4e, 0xa006, 0x0005, 0x0079, 0x1118,
-	0xa085, 0x0001, 0x0005, 0x00b9, 0x1110, 0x2041, 0x0001, 0x7d10,
-	0x0005, 0x88ff, 0x0110, 0x2091, 0x4080, 0x0005, 0x7b90, 0x7994,
-	0x70d4, 0xa102, 0x1118, 0xa385, 0x0000, 0x0005, 0x0210, 0xa302,
-	0x0005, 0x8002, 0x0005, 0xa184, 0xff00, 0x0140, 0x810f, 0x810c,
-	0x810c, 0x8004, 0x8004, 0x8007, 0xa100, 0x0018, 0x8107, 0x8004,
-	0x8004, 0x7a9c, 0x7b98, 0x7ca4, 0x7da0, 0xa210, 0xa006, 0xa319,
-	0xa421, 0xa529, 0x2009, 0x0018, 0x6028, 0xa005, 0x0110, 0x2009,
-	0x0040, 0x080c, 0x1ab7, 0x01d0, 0x78a8, 0x8000, 0x78aa, 0xd08c,
-	0x1510, 0x6014, 0xd0fc, 0x1118, 0x2069, 0x4340, 0x0010, 0x2069,
-	0x4380, 0x2091, 0x8000, 0x681f, 0x0003, 0x78ab, 0x0000, 0x78ac,
-	0xa085, 0x0300, 0x78ae, 0x2091, 0x8001, 0x0068, 0x78ab, 0x0000,
-	0x080c, 0x1d4e, 0x7990, 0x7894, 0x8000, 0xa10a, 0x1208, 0xa006,
-	0x7896, 0x70d6, 0xa006, 0x2071, 0x0010, 0x2091, 0x8001, 0x0005,
-	0x2138, 0xd7fc, 0x1118, 0x2009, 0x4359, 0x0010, 0x2009, 0x4399,
-	0x2091, 0x8000, 0x200a, 0x00f6, 0x2009, 0x4380, 0x2079, 0x0100,
-	0xd7fc, 0x1120, 0x2009, 0x4340, 0x2079, 0x0200, 0x2104, 0xa086,
-	0x0000, 0x1180, 0xd7fc, 0x1118, 0x2009, 0x4345, 0x0010, 0x2009,
-	0x4385, 0x2104, 0xa005, 0x1130, 0x7830, 0xa084, 0x00c0, 0x1110,
-	0x781b, 0x0052, 0x00fe, 0x0005, 0x2009, 0x0002, 0x2069, 0x4300,
-	0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904, 0x22a9, 0x2071, 0x4380,
-	0x2079, 0x0100, 0x2021, 0x45bf, 0x784b, 0x000f, 0x2001, 0x01ff,
-	0x2004, 0xd0fc, 0x0118, 0x2019, 0x3c3b, 0x0030, 0x20a1, 0x012b,
-	0x2019, 0x3c3b, 0xd184, 0x0110, 0x20a1, 0x022b, 0x2304, 0xa005,
-	0x0140, 0x789a, 0x8318, 0x23ac, 0x8318, 0x2398, 0x53a6, 0x3318,
-	0x0ca8, 0x789b, 0x0000, 0x789b, 0x0020, 0x20a9, 0x0010, 0x78af,
-	0x0000, 0x78af, 0x2020, 0x1f04, 0x2287, 0x7003, 0x0000, 0x0016,
-	0xd18c, 0x2009, 0x0000, 0x0108, 0xc1bd, 0x080c, 0x23bd, 0x001e,
-	0x7020, 0xa084, 0x000f, 0xa085, 0x6300, 0x7806, 0x780f, 0x9000,
-	0x7843, 0x00d8, 0x7853, 0x0090, 0x780b, 0x0308, 0x7456, 0x7053,
-	0x0000, 0x8109, 0x0140, 0x2071, 0x4340, 0x2079, 0x0200, 0x2021,
-	0x43bf, 0x0804, 0x2264, 0x0005, 0x0016, 0x2011, 0x0101, 0xd1bc,
-	0x1110, 0x2011, 0x0201, 0xa18c, 0x000f, 0x2204, 0xa084, 0xfff0,
-	0xa105, 0x2012, 0x001e, 0x080c, 0x23bd, 0x0005, 0x2011, 0x0101,
-	0xd3fc, 0x1110, 0x2011, 0x0201, 0x20a9, 0x0009, 0x810b, 0x1f04,
-	0x22ce, 0xa18c, 0x0e00, 0x2204, 0xa084, 0xf1ff, 0xa105, 0x2012,
-	0x0005, 0x2019, 0x0002, 0x2009, 0x0101, 0x20a9, 0x0005, 0x8213,
-	0x1f04, 0x22df, 0xa294, 0x00e0, 0x2104, 0xa084, 0xff1f, 0xa205,
-	0x200a, 0x8319, 0x0118, 0x2009, 0x0201, 0x0c78, 0x0005, 0x2011,
-	0x0101, 0xd3fc, 0x1110, 0x2011, 0x0201, 0x20a9, 0x000c, 0x810b,
-	0x1f04, 0x22f7, 0xa18c, 0xf000, 0x2204, 0xa084, 0x0fff, 0xa105,
-	0x2012, 0x0005, 0x2011, 0x0102, 0xd3fc, 0x1110, 0x2011, 0x0202,
-	0x2204, 0xa084, 0xffcf, 0xa105, 0x2012, 0x0005, 0x00c6, 0x2061,
-	0x0100, 0xd1bc, 0x1110, 0x2061, 0x0200, 0xc1bc, 0x8103, 0x8003,
-	0xa080, 0x0020, 0x609a, 0x62ac, 0x63ac, 0x00ce, 0x0005, 0x00c6,
+	0xa108, 0x7a78, 0xa006, 0xa211, 0x7d10, 0xd5c4, 0x0120, 0x7b84,
+	0xa319, 0x7c80, 0xa421, 0x7008, 0xd0fc, 0x0de8, 0x7003, 0x0001,
+	0x7007, 0x0006, 0x711a, 0x721e, 0x7d10, 0xd5c4, 0x0110, 0x7322,
+	0x7426, 0xa084, 0x01e0, 0x0005, 0x7848, 0xa065, 0x0120, 0x2c04,
+	0x784a, 0x2063, 0x0000, 0x0005, 0x00f6, 0x2079, 0x4500, 0x7848,
+	0x2062, 0x2c00, 0xa005, 0x1110, 0x080c, 0x252b, 0x784a, 0x00fe,
+	0x0005, 0x2011, 0x8f00, 0x7a4a, 0x7bc4, 0x8319, 0x0128, 0xa280,
+	0x0032, 0x2012, 0x2010, 0x0cc8, 0x2013, 0x0000, 0x0005, 0x0016,
+	0x0026, 0xd7fc, 0x1118, 0x2011, 0x4ac0, 0x0010, 0x2011, 0x6ac0,
+	0xa784, 0x0f00, 0x800b, 0xa784, 0x001f, 0x0120, 0x8003, 0x8003,
+	0x8003, 0x8003, 0xa105, 0xa268, 0x002e, 0x001e, 0x0005, 0x0c39,
+	0x2900, 0x682a, 0x2a00, 0x682e, 0x6808, 0xa084, 0xf9ef, 0xa80d,
+	0x690a, 0x00e6, 0xd7fc, 0x1128, 0x2009, 0x4552, 0x2071, 0x4540,
+	0x0020, 0x2009, 0x4592, 0x2071, 0x4580, 0x210c, 0x6804, 0xa005,
+	0x0148, 0xa116, 0x1138, 0x2060, 0x6000, 0x6806, 0x0016, 0x200b,
+	0x0000, 0x0018, 0x2009, 0x0000, 0x0016, 0x6804, 0xa065, 0x0178,
+	0x6000, 0x6806, 0x0421, 0x080c, 0x1d7c, 0x6810, 0x7908, 0x8109,
+	0x790a, 0x8001, 0x6812, 0x1d88, 0x7910, 0xc1a5, 0x7912, 0x001e,
+	0x6902, 0x6906, 0x2d00, 0x2060, 0x080c, 0x2672, 0x00ee, 0x0005,
+	0xa065, 0x0160, 0x2008, 0x609c, 0xa005, 0x0128, 0x2062, 0x609f,
+	0x0000, 0xa065, 0x0cc0, 0x7848, 0x794a, 0x2062, 0x0005, 0x6007,
+	0x0103, 0x608f, 0x0000, 0x20a9, 0x001c, 0xac80, 0x0005, 0x20a0,
+	0x2001, 0x0000, 0x40a4, 0x6828, 0x601a, 0x682c, 0x6022, 0x0005,
+	0x00e6, 0xd7fc, 0x1128, 0x2071, 0x4540, 0x2031, 0x45c0, 0x0020,
+	0x2071, 0x4580, 0x2031, 0x47c0, 0x704c, 0xa08c, 0x0200, 0x1128,
+	0xa608, 0x2d0a, 0x8000, 0x704e, 0xa006, 0x00ee, 0x0005, 0x00f6,
+	0xd7fc, 0x1118, 0x2079, 0x4540, 0x0010, 0x2079, 0x4580, 0x080c,
+	0x1b5f, 0x2091, 0x8000, 0x6804, 0x780a, 0xa065, 0x0904, 0x1c40,
+	0x0030, 0x2c00, 0x780a, 0x2060, 0x6000, 0xa065, 0x05c8, 0x6010,
+	0xa306, 0x1db8, 0x600c, 0xa206, 0x1da0, 0x2c28, 0x7848, 0xac06,
+	0x1108, 0x0458, 0x6804, 0xac06, 0x1140, 0x6000, 0x2060, 0x6806,
+	0xa005, 0x1118, 0x6803, 0x0000, 0x0048, 0x6400, 0x7808, 0x2060,
+	0x6402, 0xa486, 0x0000, 0x1110, 0x2c00, 0x6802, 0x2560, 0x00fe,
+	0x080c, 0x1bc7, 0x00f6, 0x601b, 0x0005, 0x6023, 0x0020, 0x00fe,
+	0x080c, 0x1d7c, 0x00f6, 0x7908, 0x8109, 0x790a, 0x6810, 0x8001,
+	0x6812, 0x1118, 0x7810, 0xc0a5, 0x7812, 0x2001, 0xffff, 0xa005,
+	0x00fe, 0x0005, 0x0076, 0x2700, 0x2039, 0x0000, 0xd0fc, 0x0108,
+	0xc7fd, 0x2041, 0x0021, 0x2049, 0x0004, 0x2051, 0x0008, 0x2091,
+	0x8000, 0x080c, 0x1b77, 0x8738, 0xa784, 0x001f, 0x1dd0, 0xa7bc,
+	0xff00, 0x873f, 0x8738, 0x873f, 0xa784, 0x0f00, 0x1d90, 0x2091,
+	0x8001, 0x007e, 0x0005, 0x786c, 0x2009, 0x8d74, 0x210c, 0xa10d,
+	0x0118, 0xa065, 0x0804, 0x2061, 0x2061, 0x0000, 0x6018, 0xd084,
+	0x11b8, 0x7810, 0xd08c, 0x0130, 0xc08c, 0x7812, 0xc7fc, 0x2069,
+	0x4540, 0x0028, 0xc08d, 0x7812, 0x2069, 0x4580, 0xc7fd, 0x2091,
+	0x8000, 0x681c, 0x681f, 0x0000, 0x2091, 0x8001, 0xa005, 0x1108,
+	0x0005, 0xa08c, 0xfff0, 0x0110, 0x080c, 0x252b, 0x0002, 0x1c9f,
+	0x1ca2, 0x1ca8, 0x1cac, 0x1ca0, 0x1cb0, 0x1ca0, 0x1ca0, 0x1ca0,
+	0x1cb6, 0x1ce2, 0x1ce5, 0x1cea, 0x1cf3, 0x1ca0, 0x1ca0, 0x0005,
+	0x080c, 0x252b, 0x080c, 0x1c42, 0x2001, 0x8001, 0x0804, 0x1cfc,
+	0x2001, 0x8003, 0x0804, 0x1cfc, 0x2001, 0x8004, 0x0804, 0x1cfc,
+	0x080c, 0x1c42, 0x2001, 0x8006, 0x0804, 0x1cfc, 0x2091, 0x8000,
+	0x0076, 0xd7fc, 0x1128, 0x2069, 0x4540, 0x2039, 0x0009, 0x0020,
+	0x2069, 0x4580, 0x2039, 0x0009, 0x6800, 0xa086, 0x0000, 0x0128,
+	0x000e, 0x6f1e, 0x2091, 0x8001, 0x0005, 0x6870, 0x007e, 0xa0bc,
+	0xff00, 0x2041, 0x0021, 0x2049, 0x0004, 0x2051, 0x0010, 0x080c,
+	0x1b77, 0x8738, 0xa784, 0x001f, 0x1dd0, 0x2091, 0x8001, 0x2001,
+	0x800a, 0x00d0, 0x2001, 0x800c, 0x00b8, 0x080c, 0x1c42, 0x2001,
+	0x800d, 0x0090, 0xd7fc, 0x0110, 0x78e4, 0x0008, 0x78e0, 0x70c6,
+	0x2001, 0x800e, 0x0048, 0xd7fc, 0x0110, 0x78ec, 0x0008, 0x78e8,
+	0x70c6, 0x2001, 0x000d, 0x0000, 0x70c2, 0xd7fc, 0x1118, 0x70db,
+	0x0000, 0x0010, 0x70db, 0x0001, 0x2061, 0x0000, 0x601b, 0x0001,
+	0x2091, 0x4080, 0x0005, 0xac80, 0x0001, 0x81ff, 0x0518, 0x2099,
+	0x0030, 0x20a0, 0x700c, 0xa084, 0x07ff, 0x0100, 0x7018, 0x0006,
+	0x701c, 0x0006, 0x7020, 0x0006, 0x7024, 0x0006, 0x7112, 0x81ac,
+	0x721a, 0x731e, 0x7422, 0x7526, 0x7003, 0x0001, 0x7007, 0x0001,
+	0x7008, 0x800b, 0x1ee8, 0x7007, 0x0002, 0xa08c, 0x01e0, 0x1110,
+	0x53a5, 0xa006, 0x7003, 0x0000, 0x7007, 0x0004, 0x000e, 0x7026,
+	0x000e, 0x7022, 0x000e, 0x701e, 0x000e, 0x701a, 0x0005, 0x2011,
+	0x0020, 0x2009, 0x0010, 0x6b0a, 0x6c0e, 0x681f, 0x0201, 0x6803,
+	0xfd20, 0x6807, 0x0038, 0x6a1a, 0x2d00, 0xa0e8, 0x0008, 0xa290,
+	0x0004, 0x8109, 0x1d80, 0x0005, 0x70ec, 0xd0dc, 0x1520, 0x2029,
+	0x0001, 0x7814, 0xd0cc, 0x1160, 0x70ec, 0xd0e4, 0x2019, 0x0c0a,
+	0x2021, 0x000a, 0x1120, 0x2019, 0x0c0c, 0x2021, 0x000c, 0x0070,
+	0x70ec, 0xd0e4, 0x1128, 0x2019, 0x1c0c, 0x2021, 0x000c, 0x0030,
+	0x2019, 0x1c09, 0x2021, 0x0009, 0xa5ad, 0x0200, 0x6b0a, 0x6c0e,
+	0x6d1e, 0x6807, 0x0038, 0x0005, 0x6004, 0x6086, 0x2c08, 0x2063,
+	0x0000, 0x7868, 0xa005, 0x796a, 0x0110, 0x2c02, 0x0008, 0x796e,
+	0x0005, 0x00c6, 0x2061, 0x4500, 0x6887, 0x0103, 0x2d08, 0x206b,
+	0x0000, 0x6068, 0xa005, 0x616a, 0x0110, 0x2d02, 0x0008, 0x616e,
+	0x00ce, 0x0005, 0x2091, 0x8000, 0x2c04, 0x786e, 0xa005, 0x1108,
+	0x786a, 0x2091, 0x8001, 0x609c, 0xa005, 0x0188, 0x00c6, 0x2060,
+	0x2008, 0x609c, 0xa005, 0x0138, 0x2062, 0x609f, 0x0000, 0xa065,
+	0x609c, 0xa005, 0x1dc8, 0x7848, 0x794a, 0x2062, 0x00ce, 0x7848,
+	0x2062, 0x609f, 0x0000, 0xac85, 0x0000, 0x1110, 0x080c, 0x252b,
+	0x784a, 0x0005, 0x20a9, 0x0010, 0xa006, 0x8004, 0x8086, 0x818e,
+	0x1208, 0xa200, 0x1f04, 0x1dc6, 0x8086, 0x818e, 0x0005, 0x0156,
+	0x20a9, 0x0010, 0xa005, 0x01b8, 0xa11a, 0x12a8, 0x8213, 0x818d,
+	0x0228, 0xa11a, 0x1220, 0x1f04, 0x1dd6, 0x0028, 0xa11a, 0x2308,
+	0x8210, 0x1f04, 0x1dd6, 0x0006, 0x3200, 0xa084, 0xefff, 0x2080,
+	0x000e, 0x015e, 0x0005, 0x0006, 0x3200, 0xa085, 0x1000, 0x0cb8,
+	0x7d74, 0x70d0, 0xa506, 0x0904, 0x1ea4, 0x7810, 0x2050, 0x080c,
+	0x1b3c, 0x0904, 0x1ea4, 0xa046, 0x7970, 0x2500, 0x8000, 0xa112,
+	0x2009, 0x0040, 0x1208, 0x0030, 0x72d0, 0xa206, 0x0118, 0x8840,
+	0x2009, 0x0080, 0x00c6, 0x7112, 0x7007, 0x0001, 0x2099, 0x0030,
+	0x20a9, 0x0020, 0xac80, 0x0001, 0x20a0, 0x2061, 0x0000, 0x88ff,
+	0x0110, 0x080c, 0x1b3c, 0x7008, 0xd0fc, 0x0de8, 0x7007, 0x0002,
+	0x2091, 0x8001, 0xa08c, 0x01e0, 0x1538, 0x53a5, 0x8cff, 0x1120,
+	0x88ff, 0x0904, 0x1e91, 0x0050, 0x2c00, 0x788e, 0x20a9, 0x0020,
+	0xac80, 0x0001, 0x20a0, 0x53a5, 0x0804, 0x1e91, 0xa046, 0x7218,
+	0x731c, 0xdac4, 0x0110, 0x7420, 0x7524, 0xa292, 0x0040, 0xa39b,
+	0x0000, 0xa4a3, 0x0000, 0xa5ab, 0x0000, 0x721a, 0x731e, 0xdac4,
+	0x0118, 0x7422, 0x7526, 0xa006, 0x7007, 0x0004, 0x0904, 0x1e91,
+	0x8cff, 0x0110, 0x080c, 0x1b44, 0x00ce, 0x080c, 0x1b44, 0xa046,
+	0x7888, 0x8000, 0x788a, 0xa086, 0x0002, 0x01c0, 0x7a7c, 0x7b78,
+	0xdac4, 0x0110, 0x7c84, 0x7d80, 0x7974, 0x8107, 0x8004, 0x8004,
+	0xa210, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x721a,
+	0x731e, 0xdac4, 0x0588, 0x7422, 0x7526, 0x0470, 0x6014, 0xd0fc,
+	0x1118, 0x2069, 0x4540, 0x0010, 0x2069, 0x4580, 0x2091, 0x8000,
+	0x681f, 0x0002, 0x88ff, 0x0120, 0xa046, 0x788c, 0x2060, 0x0c70,
+	0x788b, 0x0000, 0x78ac, 0xa085, 0x0003, 0x78ae, 0x2091, 0x8001,
+	0x0098, 0x00ce, 0x788b, 0x0000, 0x080c, 0x201c, 0x6004, 0xa084,
+	0x000f, 0x0059, 0x88ff, 0x0130, 0x788c, 0x2060, 0x6004, 0xa084,
+	0x000f, 0x0019, 0x0804, 0x1df0, 0x0005, 0x0002, 0x1eb6, 0x1ed1,
+	0x1eea, 0x1eb6, 0x1ef7, 0x1ec7, 0x1eb6, 0x1eb6, 0x1eb6, 0x1ecf,
+	0x1ee8, 0x1eb6, 0x1eb6, 0x1eb6, 0x1eb6, 0x1eb6, 0x2039, 0x0400,
+	0x78bc, 0xa705, 0x78be, 0x6008, 0xa705, 0x600a, 0x080c, 0x1f33,
+	0x609c, 0x78ba, 0x609f, 0x0000, 0x080c, 0x2008, 0x0005, 0x78bc,
+	0xd0c4, 0x0108, 0x0c58, 0x601c, 0xc0bd, 0x601e, 0x0030, 0x080c,
+	0x2046, 0x78bc, 0xd0c4, 0x0108, 0x0c08, 0x78bf, 0x0000, 0x6004,
+	0x8007, 0xa084, 0x00ff, 0x78b2, 0x8001, 0x0138, 0x080c, 0x1f33,
+	0x0120, 0x78bc, 0xc0c5, 0x78be, 0x0010, 0x0804, 0x1f4e, 0x0005,
+	0x080c, 0x2043, 0x78bc, 0xa08c, 0x0e00, 0x1110, 0xd0c4, 0x1108,
+	0x0828, 0x080c, 0x1f33, 0x1110, 0x0804, 0x1f4e, 0x0005, 0x78bc,
+	0xd0c4, 0x0110, 0x0804, 0x1eb6, 0x78bf, 0x0000, 0x6714, 0x2011,
+	0x0001, 0x22a8, 0x6018, 0xa084, 0x00ff, 0xa005, 0x0188, 0xa7bc,
+	0xff00, 0x20a9, 0x0020, 0xa08e, 0x0001, 0x0150, 0xa7bc, 0x8000,
+	0x2011, 0x0002, 0x20a9, 0x0100, 0xa08e, 0x0002, 0x0108, 0x00c0,
+	0x080c, 0x1b5f, 0x2d00, 0x2091, 0x8000, 0x682b, 0x0000, 0x682f,
+	0x0000, 0x6808, 0xa084, 0xffde, 0x680a, 0xade8, 0x0010, 0x2091,
+	0x8001, 0x1f04, 0x1f1b, 0x8211, 0x0118, 0x20a9, 0x0100, 0x0c58,
+	0x080c, 0x1b44, 0x0005, 0x609f, 0x0000, 0x78b4, 0xa06d, 0x2c00,
+	0x78b6, 0x1110, 0x78ba, 0x0038, 0x689e, 0x2d00, 0x6002, 0x78b8,
+	0xad06, 0x1108, 0x6002, 0x78b0, 0x8001, 0x78b2, 0x1130, 0x78bc,
+	0xc0c4, 0x78be, 0x78b8, 0x2060, 0xa006, 0x0005, 0x00e6, 0xa02e,
+	0x2530, 0x7dba, 0x7db6, 0x65ae, 0x65b2, 0x601c, 0x60a2, 0x2048,
+	0xa984, 0xe1ff, 0x601e, 0xa984, 0x0060, 0x0110, 0x080c, 0x3f66,
+	0x6596, 0x65a6, 0x669a, 0x66aa, 0x6714, 0x2071, 0x4580, 0xd7fc,
+	0x1110, 0x2071, 0x4540, 0xa784, 0x0f00, 0x800b, 0xa784, 0x001f,
+	0x0120, 0x8003, 0x8003, 0x8003, 0x8003, 0xa105, 0x71c0, 0xa168,
+	0x2700, 0x8007, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0x71c4,
+	0xa100, 0x60c2, 0x2091, 0x8000, 0x7814, 0xd0c4, 0x0138, 0xd7fc,
+	0x1118, 0xd0f4, 0x1140, 0x0010, 0xd0fc, 0x1128, 0x6e08, 0xd684,
+	0x01f0, 0xd9fc, 0x11e0, 0x2091, 0x8001, 0x080c, 0x1bc7, 0x2091,
+	0x8000, 0x080c, 0x1d7c, 0x2091, 0x8001, 0x7814, 0xd0c4, 0x0904,
+	0x2006, 0xd7fc, 0x1120, 0xd0f4, 0x1130, 0x0804, 0x2006, 0xd0fc,
+	0x1110, 0x0804, 0x2006, 0x601b, 0x0021, 0x0804, 0x2006, 0x6024,
+	0xa096, 0x0001, 0x1110, 0x8000, 0x6026, 0x6a10, 0x6814, 0xa202,
+	0x0268, 0x0160, 0x2091, 0x8001, 0x2039, 0x0200, 0x609c, 0x78ba,
+	0x609f, 0x0000, 0x080c, 0x2008, 0x0804, 0x2006, 0x2c08, 0xd9fc,
+	0x01f0, 0x6800, 0xa065, 0x01d8, 0x6a04, 0x7000, 0xa084, 0x0002,
+	0x0168, 0x7048, 0xa206, 0x1150, 0x6b04, 0x2160, 0x2304, 0x6002,
+	0xa005, 0x1108, 0x6902, 0x2260, 0x6102, 0x0098, 0x2d00, 0x2060,
+	0x080c, 0x2672, 0x6e08, 0x2160, 0x6202, 0x6906, 0x0050, 0x6800,
+	0x6902, 0xa065, 0x0110, 0x6102, 0x0008, 0x6906, 0x2160, 0x6003,
+	0x0000, 0x2160, 0xd9fc, 0x0118, 0xa6b4, 0xfffc, 0x6e0a, 0x6810,
+	0x7d08, 0x8528, 0x7d0a, 0x8000, 0x6812, 0x2091, 0x8001, 0xd6b4,
+	0x0128, 0xa6b6, 0x0040, 0x6e0a, 0x080c, 0x1bd8, 0x00ee, 0x0005,
+	0x6008, 0xa705, 0x600a, 0x2091, 0x8000, 0x080c, 0x1d7c, 0x2091,
+	0x8001, 0x78b8, 0xa065, 0x0128, 0x609c, 0x78ba, 0x609f, 0x0000,
+	0x0c78, 0x78b6, 0x78ba, 0x0005, 0x7970, 0x7874, 0x2818, 0xd384,
+	0x0118, 0x8000, 0xa112, 0x0220, 0x8000, 0xa112, 0x1278, 0xc384,
+	0x7a7c, 0x721a, 0x7a78, 0x721e, 0xdac4, 0x0120, 0x7a84, 0x7222,
+	0x7a80, 0x7226, 0xa006, 0xd384, 0x0108, 0x8000, 0x7876, 0x70d2,
+	0x781c, 0xa005, 0x0138, 0x8001, 0x781e, 0x1120, 0x0e04, 0x2042,
+	0x2091, 0x4080, 0x0005, 0x2039, 0x2058, 0x0010, 0x2039, 0x205e,
+	0x2704, 0xa005, 0x0160, 0xac00, 0x2068, 0x6908, 0x6810, 0x6912,
+	0x680a, 0x690c, 0x6814, 0x6916, 0x680e, 0x8738, 0x0c88, 0x0005,
+	0x0003, 0x0009, 0x000f, 0x0015, 0x001b, 0x0000, 0x0015, 0x001b,
+	0x0000, 0x2041, 0x0000, 0x780c, 0x0002, 0x220a, 0x21e5, 0x2069,
+	0x20d9, 0x2039, 0x8d74, 0x2734, 0x7d10, 0x00c0, 0x6084, 0xa086,
+	0x0103, 0x1904, 0x20c3, 0x6114, 0x6018, 0xa105, 0x0120, 0x86ff,
+	0x11d8, 0x0804, 0x20c3, 0x8603, 0xa080, 0x8d55, 0x620c, 0x2202,
+	0x8000, 0x6210, 0x2202, 0x080c, 0x1d9a, 0x8630, 0xa68e, 0x000f,
+	0x0904, 0x2144, 0x786c, 0xa065, 0x1d08, 0x7808, 0xa602, 0x1220,
+	0xd5ac, 0x1110, 0x263a, 0x0005, 0xa682, 0x0003, 0x1a04, 0x2144,
+	0x2091, 0x8000, 0x2069, 0x0000, 0x6818, 0xd084, 0x11f8, 0x2011,
+	0x8d55, 0x2204, 0x70c6, 0x8210, 0x2204, 0x70ca, 0xd684, 0x1130,
+	0x8210, 0x2204, 0x70da, 0x8210, 0x2204, 0x70de, 0xa685, 0x8020,
+	0x70c2, 0x681b, 0x0001, 0x2091, 0x4080, 0x7810, 0xa084, 0xffcf,
+	0x7812, 0x2091, 0x8001, 0x203b, 0x0000, 0x0005, 0x7810, 0xc0ad,
+	0x7812, 0x0804, 0x2144, 0x263a, 0x080c, 0x2210, 0x1904, 0x222c,
+	0x786c, 0xa065, 0x1904, 0x206e, 0x2091, 0x8000, 0x7810, 0xa084,
+	0xffcf, 0x86ff, 0x0108, 0xc0ad, 0x7812, 0x2091, 0x8001, 0x0804,
+	0x222c, 0x2039, 0x8d74, 0x2734, 0x7d10, 0x00a0, 0x6084, 0xa086,
+	0x0103, 0x1904, 0x212e, 0x6114, 0x6018, 0xa105, 0x0120, 0x86ff,
+	0x11b8, 0x0804, 0x212e, 0xa680, 0x8d55, 0x620c, 0x2202, 0x080c,
+	0x1d9a, 0x8630, 0xa68e, 0x001e, 0x0904, 0x2144, 0x786c, 0xa065,
+	0x1d28, 0x7808, 0xa602, 0x1220, 0xd5ac, 0x1110, 0x263a, 0x0005,
+	0xa682, 0x0006, 0x1a04, 0x2144, 0x2091, 0x8000, 0x2069, 0x0000,
+	0x6818, 0xd084, 0x11f8, 0x2011, 0x8d55, 0x2009, 0x8d4e, 0x26a8,
+	0x211c, 0x2204, 0x201a, 0x8108, 0x8210, 0x1f04, 0x2110, 0xa685,
+	0x8030, 0x70c2, 0x681b, 0x0001, 0x2091, 0x4080, 0x7810, 0xa084,
+	0xffcf, 0x7812, 0x2091, 0x8001, 0xa006, 0x2009, 0x8d75, 0x200a,
+	0x203a, 0x0005, 0x7810, 0xc0ad, 0x7812, 0x00b0, 0x263a, 0x080c,
+	0x2210, 0x1904, 0x222c, 0x786c, 0xa065, 0x1904, 0x20de, 0x2091,
+	0x8000, 0x7810, 0xa084, 0xffcf, 0x86ff, 0x0108, 0xc0ad, 0x7812,
+	0x2091, 0x8001, 0x0804, 0x222c, 0x2091, 0x8000, 0x7007, 0x0004,
+	0x7994, 0x70d4, 0xa102, 0x0228, 0x0168, 0x7b90, 0xa302, 0x1150,
+	0x0010, 0x8002, 0x1138, 0x263a, 0x7810, 0xc0ad, 0x7812, 0x2091,
+	0x8001, 0x0005, 0xa184, 0xff00, 0x0140, 0x810f, 0x810c, 0x810c,
+	0x8004, 0x8004, 0x8007, 0xa100, 0x0018, 0x8107, 0x8004, 0x8004,
+	0x7a9c, 0xa210, 0x721a, 0x7a98, 0xa006, 0xa211, 0x721e, 0xd4c4,
+	0x0130, 0x7aa4, 0xa211, 0x7222, 0x7aa0, 0xa211, 0x7226, 0x20a1,
+	0x0030, 0x7003, 0x0000, 0x2009, 0x8d54, 0x260a, 0x8109, 0x2198,
+	0x2104, 0xd084, 0x0108, 0x8633, 0xa6b0, 0x0002, 0x26a8, 0x53a6,
+	0x8603, 0x7012, 0x7007, 0x0001, 0x7990, 0x7894, 0x8000, 0xa10a,
+	0x1208, 0xa006, 0x2028, 0x7974, 0xa184, 0xff00, 0x0140, 0x810f,
+	0x810c, 0x810c, 0x8004, 0x8004, 0x8007, 0xa100, 0x0018, 0x8107,
+	0x8004, 0x8004, 0x797c, 0xa108, 0x7a78, 0xa006, 0xa211, 0xd4c4,
+	0x0120, 0x7b84, 0xa319, 0x7c80, 0xa421, 0x7008, 0xd0fc, 0x0de8,
+	0xa084, 0x01e0, 0x01d0, 0x7d10, 0x2031, 0x8d54, 0x2634, 0x78a8,
+	0x8000, 0x78aa, 0xd08c, 0x1138, 0x7007, 0x0006, 0x7004, 0xd094,
+	0x1de8, 0x0804, 0x2146, 0x2069, 0x4547, 0x206b, 0x0003, 0x78ac,
+	0xa085, 0x0300, 0x78ae, 0xa006, 0x0048, 0x2030, 0x75d6, 0x2091,
+	0x4080, 0x7d96, 0x7d10, 0xa5ac, 0xffcf, 0x7d12, 0x2091, 0x8001,
+	0x78aa, 0x7007, 0x0006, 0x263a, 0x7003, 0x0001, 0x711a, 0x721e,
+	0xd5c4, 0x0110, 0x7322, 0x7426, 0x0005, 0x6084, 0xa086, 0x0103,
+	0x11d8, 0x6114, 0x6018, 0xa105, 0x11b8, 0x2069, 0x0000, 0x6818,
+	0xd084, 0x1190, 0x600c, 0x70c6, 0x6010, 0x70ca, 0x70c3, 0x8020,
+	0x681b, 0x0001, 0x2091, 0x4080, 0x080c, 0x1d9a, 0x0e04, 0x2203,
+	0x786c, 0xa065, 0x1d10, 0x0005, 0x0059, 0x1530, 0x786c, 0xa065,
+	0x19e0, 0x0410, 0x0029, 0x1500, 0x786c, 0xa065, 0x1dd8, 0x00e0,
+	0x6084, 0xa086, 0x0103, 0x1168, 0x6018, 0xc0fc, 0x601a, 0xa086,
+	0x0004, 0x1138, 0x7804, 0xd0a4, 0x0120, 0x080c, 0x1d9a, 0xa006,
+	0x0005, 0x0079, 0x1118, 0xa085, 0x0001, 0x0005, 0x00b9, 0x1110,
+	0x2041, 0x0001, 0x7d10, 0x0005, 0x88ff, 0x0110, 0x2091, 0x4080,
+	0x0005, 0x7b90, 0x7994, 0x70d4, 0xa102, 0x1118, 0xa385, 0x0000,
+	0x0005, 0x0210, 0xa302, 0x0005, 0x8002, 0x0005, 0xa184, 0xff00,
+	0x0140, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004, 0x8007, 0xa100,
+	0x0018, 0x8107, 0x8004, 0x8004, 0x7a9c, 0x7b98, 0x7ca4, 0x7da0,
+	0xa210, 0xa006, 0xa319, 0xa421, 0xa529, 0x2009, 0x0018, 0x6028,
+	0xa005, 0x0110, 0x2009, 0x0040, 0x080c, 0x1af9, 0x01d0, 0x78a8,
+	0x8000, 0x78aa, 0xd08c, 0x1510, 0x6014, 0xd0fc, 0x1118, 0x2069,
+	0x4540, 0x0010, 0x2069, 0x4580, 0x2091, 0x8000, 0x681f, 0x0003,
+	0x78ab, 0x0000, 0x78ac, 0xa085, 0x0300, 0x78ae, 0x2091, 0x8001,
+	0x0068, 0x78ab, 0x0000, 0x080c, 0x1d9a, 0x7990, 0x7894, 0x8000,
+	0xa10a, 0x1208, 0xa006, 0x7896, 0x70d6, 0xa006, 0x2071, 0x0010,
+	0x2091, 0x8001, 0x0005, 0x2138, 0xd7fc, 0x1118, 0x2009, 0x4558,
+	0x0010, 0x2009, 0x4598, 0x2091, 0x8000, 0x200a, 0x00f6, 0x2009,
+	0x4580, 0x2079, 0x0100, 0xd7fc, 0x1120, 0x2009, 0x4540, 0x2079,
+	0x0200, 0x2104, 0xa086, 0x0000, 0x1180, 0xd7fc, 0x1118, 0x2009,
+	0x4545, 0x0010, 0x2009, 0x4585, 0x2104, 0xa005, 0x1130, 0x7830,
+	0xa084, 0x00c0, 0x1110, 0x781b, 0x0052, 0x00fe, 0x0005, 0x2009,
+	0x0002, 0x2069, 0x4500, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x1904,
+	0x230c, 0x2071, 0x4580, 0x2079, 0x0100, 0x2021, 0x47bf, 0x784b,
+	0x000f, 0x2001, 0x01ff, 0x2004, 0xd0fc, 0x0118, 0x2019, 0x3dc2,
+	0x0030, 0x20a1, 0x012b, 0x2019, 0x3dc2, 0xd184, 0x0110, 0x20a1,
+	0x022b, 0x2304, 0xa005, 0x0140, 0x789a, 0x8318, 0x23ac, 0x8318,
+	0x2398, 0x53a6, 0x3318, 0x0ca8, 0x789b, 0x0000, 0x789b, 0x0020,
+	0x20a9, 0x0010, 0x78af, 0x0000, 0x78af, 0x2020, 0x1f04, 0x22ea,
+	0x7003, 0x0000, 0x0016, 0xd18c, 0x2009, 0x0000, 0x0108, 0xc1bd,
+	0x080c, 0x2422, 0x001e, 0x7020, 0xa084, 0x000f, 0xa085, 0x6300,
+	0x7806, 0x780f, 0x9000, 0x7843, 0x00d8, 0x7853, 0x0090, 0x780b,
+	0x2f08, 0x7452, 0x704f, 0x0000, 0x8109, 0x0140, 0x2071, 0x4540,
+	0x2079, 0x0200, 0x2021, 0x45bf, 0x0804, 0x22c7, 0x080c, 0x24dc,
+	0x0005, 0x0016, 0x2011, 0x0101, 0xd1bc, 0x1110, 0x2011, 0x0201,
+	0xa18c, 0x000f, 0x2204, 0xa084, 0xfff0, 0xa105, 0x2012, 0x001e,
+	0x080c, 0x2422, 0x0005, 0x2011, 0x0101, 0xd3fc, 0x1110, 0x2011,
+	0x0201, 0x20a9, 0x0009, 0x810b, 0x1f04, 0x2333, 0xa18c, 0x0e00,
+	0x2204, 0xa084, 0xf1ff, 0xa105, 0x2012, 0x0005, 0x2019, 0x0002,
+	0x2009, 0x0101, 0x20a9, 0x0005, 0x8213, 0x1f04, 0x2344, 0xa294,
+	0x00e0, 0x2104, 0xa084, 0xff1f, 0xa205, 0x200a, 0x8319, 0x0118,
+	0x2009, 0x0201, 0x0c78, 0x0005, 0x2011, 0x0101, 0xd3fc, 0x1110,
+	0x2011, 0x0201, 0x20a9, 0x000c, 0x810b, 0x1f04, 0x235c, 0xa18c,
+	0xf000, 0x2204, 0xa084, 0x0fff, 0xa105, 0x2012, 0x0005, 0x2011,
+	0x0102, 0xd3fc, 0x1110, 0x2011, 0x0202, 0x2204, 0xa084, 0xf0cf,
+	0xa105, 0x2012, 0x0005, 0x00c6, 0x2061, 0x0100, 0xd1bc, 0x1110,
+	0x2061, 0x0200, 0xc1bc, 0x8103, 0x8003, 0xa080, 0x0020, 0x609a,
+	0x62ac, 0x63ac, 0x00ce, 0x0005, 0x00c6, 0x2061, 0x0100, 0xd1bc,
+	0x1110, 0x2061, 0x0200, 0xc1bc, 0x8103, 0x8003, 0xa080, 0x0022,
+	0x609a, 0x60a4, 0xa084, 0xffdf, 0x60ae, 0x00ce, 0x0005, 0x00c6,
 	0x2061, 0x0100, 0xd1bc, 0x1110, 0x2061, 0x0200, 0xc1bc, 0x8103,
-	0x8003, 0xa080, 0x0022, 0x609a, 0x60a4, 0xa084, 0xffdf, 0x60ae,
-	0x00ce, 0x0005, 0x00c6, 0x2061, 0x0100, 0xd1bc, 0x1110, 0x2061,
-	0x0200, 0xc1bc, 0x8103, 0x8003, 0xa080, 0x0020, 0x609a, 0x60a4,
-	0xa28c, 0x0020, 0x0118, 0xc2ac, 0xa39d, 0x4000, 0xc3ec, 0xd3b4,
-	0x1108, 0xc3ed, 0x62ae, 0x2010, 0x60a4, 0x63ae, 0x2018, 0x00ce,
-	0x0005, 0x2091, 0x8000, 0x00c6, 0x00e6, 0x6818, 0xa005, 0x0904,
-	0x23a1, 0xd1fc, 0x0118, 0x2061, 0x8ad0, 0x0010, 0x2061, 0x89c0,
-	0x080c, 0x23a9, 0x0538, 0x20a9, 0x0101, 0xd1fc, 0x0118, 0x2061,
-	0x89d0, 0x0010, 0x2061, 0x88c0, 0x00c6, 0x04d9, 0x0128, 0x00ce,
-	0x8c60, 0x1f04, 0x236c, 0x0468, 0x000e, 0xd1fc, 0x0128, 0xa082,
-	0x89d0, 0x2071, 0x4380, 0x0020, 0xa082, 0x88c0, 0x2071, 0x4340,
-	0x707a, 0x7176, 0x2001, 0x0004, 0x7066, 0x7083, 0x000f, 0x080c,
-	0x2228, 0x00a0, 0xd1fc, 0x1118, 0x2071, 0x4340, 0x0010, 0x2071,
-	0x4380, 0x6020, 0xc0dd, 0x6022, 0x7176, 0x2c00, 0x707e, 0x2001,
-	0x0006, 0x7066, 0x7083, 0x000f, 0x080c, 0x2228, 0x2001, 0x0000,
-	0x0010, 0x2001, 0x0001, 0x2091, 0x8001, 0xa005, 0x00ee, 0x00ce,
-	0x0005, 0x2c04, 0xa005, 0x0170, 0x2060, 0x6010, 0xa306, 0x1140,
-	0x600c, 0xa206, 0x1128, 0x6014, 0xa106, 0x1110, 0xa006, 0x0020,
-	0x6000, 0x0c80, 0xa085, 0x0001, 0x0005, 0x00f6, 0x00e6, 0x0016,
-	0x2079, 0x4380, 0x2071, 0x0100, 0xd1bc, 0x1120, 0x2079, 0x4340,
-	0x2071, 0x0200, 0x7920, 0xa18c, 0x000f, 0x70ec, 0xd0c4, 0x1110,
-	0x001e, 0x0060, 0x810b, 0x810b, 0x810b, 0x810b, 0x000e, 0xa18d,
-	0x0800, 0xd0bc, 0x1110, 0xa18d, 0x0f00, 0x2104, 0x00ee, 0x00fe,
-	0x0005, 0x00e6, 0x2001, 0x4301, 0x2004, 0xd0ac, 0x1904, 0x2439,
-	0x68e4, 0xd0ac, 0x0904, 0x2439, 0xa084, 0x0006, 0x1904, 0x2439,
-	0x6014, 0xd0fc, 0x1118, 0x2071, 0x47c0, 0x0010, 0x2071, 0x4840,
-	0x8007, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0xae70, 0x7004,
-	0xa084, 0x000a, 0x15b0, 0x7108, 0xa194, 0xff00, 0x0590, 0xa18c,
-	0x00ff, 0x2001, 0x000a, 0xa106, 0x01a8, 0x2001, 0x000c, 0xa106,
-	0x01a0, 0x2001, 0x0012, 0xa106, 0x0198, 0x2001, 0x0014, 0xa106,
-	0x0190, 0x2001, 0x0019, 0xa106, 0x0188, 0x2001, 0x0032, 0xa106,
-	0x0180, 0x0090, 0x2009, 0x000c, 0x0088, 0x2009, 0x0012, 0x0070,
-	0x2009, 0x0014, 0x0058, 0x2009, 0x0019, 0x0040, 0x2009, 0x0020,
-	0x0028, 0x2009, 0x003f, 0x0010, 0x2011, 0x0000, 0x2100, 0xa205,
-	0x700a, 0x00ee, 0x0005, 0x0e04, 0x243b, 0x2091, 0x8000, 0x2071,
+	0x8003, 0xa080, 0x0020, 0x609a, 0x60a4, 0xa28c, 0x0020, 0x0118,
+	0xc2ac, 0xa39d, 0x4000, 0xc3ec, 0xd3b4, 0x1108, 0xc3ed, 0x62ae,
+	0x2010, 0x60a4, 0x63ae, 0x2018, 0x00ce, 0x0005, 0x2091, 0x8000,
+	0x00c6, 0x00e6, 0x6818, 0xa005, 0x0904, 0x2406, 0xd1fc, 0x0118,
+	0x2061, 0x8cd0, 0x0010, 0x2061, 0x8bc0, 0x080c, 0x240e, 0x0538,
+	0x20a9, 0x0101, 0xd1fc, 0x0118, 0x2061, 0x8bd0, 0x0010, 0x2061,
+	0x8ac0, 0x00c6, 0x04d9, 0x0128, 0x00ce, 0x8c60, 0x1f04, 0x23d1,
+	0x0468, 0x000e, 0xd1fc, 0x0128, 0xa082, 0x8bd0, 0x2071, 0x4580,
+	0x0020, 0xa082, 0x8ac0, 0x2071, 0x4540, 0x7076, 0x7172, 0x2001,
+	0x0004, 0x7062, 0x707f, 0x000f, 0x080c, 0x228b, 0x00a0, 0xd1fc,
+	0x1118, 0x2071, 0x4540, 0x0010, 0x2071, 0x4580, 0x6020, 0xc0dd,
+	0x6022, 0x7172, 0x2c00, 0x707a, 0x2001, 0x0006, 0x7062, 0x707f,
+	0x000f, 0x080c, 0x228b, 0x2001, 0x0000, 0x0010, 0x2001, 0x0001,
+	0x2091, 0x8001, 0xa005, 0x00ee, 0x00ce, 0x0005, 0x2c04, 0xa005,
+	0x0170, 0x2060, 0x6010, 0xa306, 0x1140, 0x600c, 0xa206, 0x1128,
+	0x6014, 0xa106, 0x1110, 0xa006, 0x0020, 0x6000, 0x0c80, 0xa085,
+	0x0001, 0x0005, 0x00f6, 0x00e6, 0x0016, 0x2079, 0x4580, 0x2071,
+	0x0100, 0xd1bc, 0x1120, 0x2079, 0x4540, 0x2071, 0x0200, 0x7920,
+	0xa18c, 0x000f, 0x70ec, 0xd0c4, 0x1110, 0x001e, 0x0060, 0x810b,
+	0x810b, 0x810b, 0x810b, 0x000e, 0xa18d, 0x0800, 0xd0bc, 0x1110,
+	0xa18d, 0x0f00, 0x2104, 0x00ee, 0x00fe, 0x0005, 0x2001, 0x4501,
+	0x2004, 0xd0ac, 0x1138, 0x68e4, 0xd0ac, 0x0120, 0xa084, 0x0006,
+	0x1108, 0x0009, 0x0005, 0x6014, 0x00e6, 0x0036, 0x2018, 0x2071,
+	0x4a40, 0xd0fc, 0x1110, 0x2071, 0x49c0, 0x8007, 0xa084, 0x000f,
+	0x8003, 0x8003, 0x8003, 0xae70, 0x7004, 0xa084, 0x000a, 0x1904,
+	0x24d9, 0x7108, 0xa194, 0xff00, 0x0904, 0x24d9, 0xa18c, 0x00ff,
+	0x701c, 0xa084, 0xff00, 0x01c0, 0x7004, 0xa085, 0x003a, 0x7006,
+	0x2001, 0x0009, 0xa102, 0x16d8, 0x2001, 0x000a, 0xa102, 0x16d0,
+	0x2001, 0x000c, 0xa102, 0x16c8, 0x701c, 0xa084, 0x00ff, 0x701e,
+	0x7004, 0xa084, 0xffdf, 0x7006, 0x2001, 0x000a, 0xa106, 0x01a8,
+	0x2001, 0x000c, 0xa106, 0x01a0, 0x2001, 0x0012, 0xa106, 0x0198,
+	0x2001, 0x0014, 0xa106, 0x0190, 0x2001, 0x0019, 0xa106, 0x0188,
+	0x2001, 0x0032, 0xa106, 0x0180, 0x00d8, 0x2009, 0x000c, 0x00d0,
+	0x2009, 0x0012, 0x00b8, 0x2009, 0x0014, 0x00a0, 0x2009, 0x0019,
+	0x0088, 0x2009, 0x0020, 0x0070, 0x2009, 0x003f, 0x0058, 0x2009,
+	0x000a, 0x0040, 0x2009, 0x000c, 0x0028, 0x2009, 0x0019, 0x0010,
+	0x2011, 0x0000, 0x2100, 0xa205, 0x700a, 0x7004, 0xa085, 0x000a,
+	0x7006, 0x2071, 0x4500, 0x7004, 0xd0bc, 0x0158, 0xd3fc, 0x1120,
+	0x73ea, 0x2071, 0x4540, 0x0018, 0x73ee, 0x2071, 0x4580, 0x701f,
+	0x800f, 0x003e, 0x00ee, 0x0005, 0x2001, 0x01ff, 0x2004, 0xd0fc,
+	0x11d0, 0x2001, 0x04fd, 0x2004, 0xa082, 0x0005, 0x12a0, 0x2071,
+	0x0200, 0x71ec, 0xa18c, 0x1c00, 0x810f, 0x810c, 0x810c, 0x2079,
+	0x0100, 0x78ec, 0xa084, 0x1c00, 0x8007, 0x8004, 0x8004, 0xa105,
+	0xa08a, 0x0007, 0x0208, 0x0005, 0x0002, 0x252a, 0x2511, 0x252a,
+	0x2511, 0x2504, 0x251e, 0x2504, 0x7008, 0xa084, 0xc3ff, 0xa085,
+	0x3000, 0x700a, 0x7808, 0xa084, 0xc3ff, 0xa085, 0x3000, 0x780a,
+	0x0005, 0x7008, 0xa084, 0xc3ff, 0xa085, 0x2000, 0x700a, 0x7808,
+	0xa084, 0xc3ff, 0xa085, 0x2000, 0x780a, 0x0005, 0x7008, 0xa084,
+	0xc3ff, 0xa085, 0x0c00, 0x700a, 0x7808, 0xa084, 0xc3ff, 0xa085,
+	0x0c00, 0x780a, 0x0005, 0x0e04, 0x252b, 0x2091, 0x8000, 0x2071,
 	0x0000, 0x0006, 0x7018, 0xd084, 0x1de8, 0x000e, 0x2071, 0x0010,
-	0x70ca, 0x000e, 0x70c6, 0x70c3, 0x8002, 0x70db, 0x0a01, 0x70df,
-	0x0013, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0cf8,
-	0x7f3c, 0x7e58, 0x7c30, 0x7d38, 0x78a0, 0x708e, 0x7592, 0x7496,
-	0x769a, 0x779e, 0xa594, 0x003f, 0xd4f4, 0x0138, 0xd7bc, 0x1128,
-	0xa784, 0x007d, 0x1904, 0x3ace, 0x0871, 0xa49c, 0x000f, 0xa382,
+	0x70ca, 0x000e, 0x70c6, 0x70c3, 0x8002, 0x70db, 0x0a04, 0x70df,
+	0x0008, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0cf8,
+	0x7f3c, 0x7e58, 0x7c30, 0x7d38, 0x78a0, 0x708a, 0x758e, 0x7492,
+	0x7696, 0x779a, 0xa594, 0x003f, 0xd4f4, 0x0138, 0xd7bc, 0x1128,
+	0xa784, 0x007d, 0x1904, 0x3c3a, 0x0871, 0xa49c, 0x000f, 0xa382,
 	0x0004, 0x0320, 0xa3a6, 0x0007, 0x1930, 0x2418, 0x8507, 0xa084,
-	0x000f, 0x0002, 0x2a4f, 0x2b10, 0x2b38, 0x2d71, 0x30cc, 0x3112,
-	0x31a7, 0x3220, 0x32db, 0x33a6, 0x248d, 0x248a, 0x285b, 0x295c,
-	0x30a0, 0x248a, 0x080c, 0x243b, 0x0005, 0xa006, 0x0038, 0x7808,
-	0xc08d, 0x780a, 0xa006, 0x7002, 0x704e, 0x7046, 0x70d2, 0x7060,
-	0xa005, 0x1904, 0x25d9, 0x7064, 0xa084, 0x0007, 0x0002, 0x24a7,
-	0x2513, 0x251b, 0x2524, 0x252d, 0x25bf, 0x2536, 0x2513, 0x7830,
-	0xd0bc, 0x1d10, 0x71d4, 0xd1b4, 0x1904, 0x24f0, 0x70a4, 0xa086,
-	0x0001, 0x09d0, 0x70b4, 0xa06d, 0x6800, 0xa065, 0xa055, 0x789b,
-	0x0080, 0x6b0c, 0x7baa, 0x6808, 0xa045, 0x6d10, 0x6804, 0xa06d,
-	0xa05d, 0xa886, 0x0001, 0x0118, 0x69bc, 0x7daa, 0x79aa, 0x68c0,
-	0xa04d, 0x6e1c, 0x2001, 0x0010, 0x0804, 0x270a, 0x7060, 0xa005,
-	0x1904, 0x248c, 0x00c6, 0x00d6, 0x70b4, 0xa06d, 0x6800, 0xa065,
+	0x000f, 0x0002, 0x2b40, 0x2c01, 0x2c29, 0x2e64, 0x31f1, 0x3243,
+	0x32e8, 0x3361, 0x341f, 0x34f6, 0x257d, 0x257a, 0x294d, 0x2a4d,
+	0x31c5, 0x257a, 0x080c, 0x252b, 0x0005, 0xa006, 0x0038, 0x7808,
+	0xc08d, 0x780a, 0xa006, 0x7002, 0x704a, 0x7042, 0x70ce, 0x705c,
+	0xa005, 0x1904, 0x26cb, 0x7060, 0xa084, 0x0007, 0x0002, 0x2597,
+	0x2605, 0x260d, 0x2616, 0x261f, 0x26b1, 0x2628, 0x2605, 0x7830,
+	0xd0bc, 0x1d10, 0x71d0, 0xd1bc, 0x19f8, 0xd1b4, 0x1904, 0x25e2,
+	0x70a0, 0xa086, 0x0001, 0x09c0, 0x70b0, 0xa06d, 0x6800, 0xa065,
 	0xa055, 0x789b, 0x0080, 0x6b0c, 0x7baa, 0x6808, 0xa045, 0x6d10,
 	0x6804, 0xa06d, 0xa05d, 0xa886, 0x0001, 0x0118, 0x69bc, 0x7daa,
-	0x79aa, 0x68c0, 0xa04d, 0x6e1c, 0x2001, 0x0020, 0x0804, 0x270a,
-	0x080c, 0x3a8d, 0x1904, 0x248c, 0x781b, 0x0068, 0x70bc, 0xa06d,
+	0x79aa, 0x68c0, 0xa04d, 0x6e1c, 0x2001, 0x0010, 0x0804, 0x27fc,
+	0x705c, 0xa005, 0x1904, 0x257c, 0x00c6, 0x00d6, 0x70b0, 0xa06d,
+	0x6800, 0xa065, 0xa055, 0x789b, 0x0080, 0x6b0c, 0x7baa, 0x6808,
+	0xa045, 0x6d10, 0x6804, 0xa06d, 0xa05d, 0xa886, 0x0001, 0x0118,
+	0x69bc, 0x7daa, 0x79aa, 0x68c0, 0xa04d, 0x6e1c, 0x2001, 0x0020,
+	0x0804, 0x27fc, 0x080c, 0x3bf9, 0x1904, 0x257c, 0x781b, 0x0068,
+	0x70b8, 0xa06d, 0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de, 0x6898,
+	0x78d2, 0x78da, 0x7808, 0xc08d, 0x780a, 0x68bc, 0x703e, 0xc1b4,
+	0x71d2, 0x70b4, 0xa065, 0x68c0, 0x7056, 0x7003, 0x0002, 0x2d00,
+	0x704a, 0xad80, 0x0009, 0x7042, 0x0005, 0x080c, 0x3bf9, 0x1120,
+	0x781b, 0x0054, 0x7003, 0x0004, 0x0005, 0x080c, 0x3bf9, 0x1128,
+	0x2011, 0x000c, 0x0419, 0x7003, 0x0004, 0x0005, 0x080c, 0x3bf9,
+	0x1128, 0x2011, 0x0006, 0x00d1, 0x7003, 0x0004, 0x0005, 0x080c,
+	0x3bf9, 0x1128, 0x2011, 0x000d, 0x0089, 0x7003, 0x0004, 0x0005,
+	0x080c, 0x3bf9, 0x1150, 0x2011, 0x0006, 0x0041, 0x7078, 0x707b,
+	0x0000, 0x2068, 0x704a, 0x7003, 0x0001, 0x0005, 0x7170, 0xc1fc,
+	0x8107, 0x7882, 0x789b, 0x0080, 0xa286, 0x000c, 0x1120, 0x7aaa,
+	0x2001, 0x0001, 0x0098, 0xa18c, 0x001f, 0xa18d, 0x00c0, 0x79aa,
+	0xa286, 0x000d, 0x0120, 0x7aaa, 0x2001, 0x0002, 0x0038, 0x78ab,
+	0x0020, 0x7174, 0x79aa, 0x7aaa, 0x2001, 0x0004, 0x789b, 0x0060,
+	0x78aa, 0x785b, 0x0004, 0x781b, 0x0113, 0x080c, 0x3c0c, 0x707f,
+	0x000f, 0x70d0, 0xd0b4, 0x0168, 0xc0b4, 0x70d2, 0x00c6, 0x70b4,
+	0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a,
+	0x00ce, 0x0005, 0x7014, 0xa005, 0x1138, 0x70d0, 0xd0b4, 0x0128,
+	0x70b4, 0xac06, 0x1110, 0x0c29, 0x0005, 0x0016, 0x71a0, 0xa186,
+	0x0001, 0x0528, 0x00d6, 0x0026, 0x2100, 0x2011, 0x0001, 0xa212,
+	0x70b0, 0x2068, 0x6800, 0xac06, 0x0120, 0x8211, 0x01b0, 0x00c9,
+	0x0cc8, 0x00c6, 0x2100, 0x2011, 0x0001, 0xa212, 0x70b0, 0x2068,
+	0x6800, 0x2060, 0x6008, 0xa084, 0xfbef, 0x600a, 0x8211, 0x0110,
+	0x0041, 0x0cb0, 0x70a3, 0x0001, 0x00ce, 0x002e, 0x00de, 0x001e,
+	0x0005, 0xade8, 0x0005, 0x70a8, 0xad06, 0x1110, 0x70a4, 0x2068,
+	0x0005, 0x080c, 0x3bf9, 0x1904, 0x257c, 0x7078, 0x2068, 0x7770,
+	0x080c, 0x3b35, 0x2c50, 0x080c, 0x3c94, 0x789b, 0x0080, 0x6814,
+	0xa084, 0x001f, 0xc0bd, 0x78aa, 0x6e1c, 0x2041, 0x0001, 0x2001,
+	0x0004, 0x0804, 0x2801, 0x080c, 0x3bf9, 0x1904, 0x257c, 0x789b,
+	0x0080, 0x705c, 0x2068, 0x6f14, 0x70d0, 0xd0b4, 0x0168, 0xc0b4,
+	0x70d2, 0x00c6, 0x70b4, 0xa065, 0x6008, 0xa084, 0xfbef, 0x600a,
+	0x6018, 0x8001, 0x601a, 0x00ce, 0x080c, 0x3b35, 0x2c50, 0x080c,
+	0x3c94, 0x6824, 0xa005, 0x0130, 0xa082, 0x0006, 0x0208, 0x0010,
+	0x6827, 0x0005, 0x6814, 0xa084, 0x001f, 0xc0bd, 0x78aa, 0x2031,
+	0x0020, 0x2041, 0x0001, 0x2001, 0x0003, 0x0804, 0x2801, 0xc28d,
+	0x72d2, 0x72bc, 0xa200, 0xa015, 0x7150, 0x8108, 0xa12a, 0x0208,
+	0x71bc, 0x2164, 0x6504, 0x85ff, 0x1170, 0x7152, 0x8421, 0x1da8,
+	0x70d0, 0xd08c, 0x0128, 0x70cc, 0xa005, 0x1110, 0x70cf, 0x000a,
+	0x0005, 0x2200, 0x0c90, 0x70d0, 0xc08c, 0x70d2, 0x70cf, 0x0000,
+	0x6034, 0xa005, 0x1db0, 0x6708, 0xa784, 0x073f, 0x01d0, 0xd7d4,
+	0x1d80, 0xa784, 0x0021, 0x1d68, 0xa784, 0x0002, 0x0130, 0xa784,
+	0x0004, 0x0d38, 0xa7bc, 0xfffb, 0x670a, 0xa784, 0x0218, 0x1d08,
+	0xa784, 0x0100, 0x0130, 0x6018, 0xa005, 0x19d8, 0xa7bc, 0xfeff,
+	0x670a, 0x2568, 0x6823, 0x0000, 0x6e1c, 0xa684, 0x000e, 0x6318,
+	0x0128, 0x601c, 0xa302, 0x0220, 0x0118, 0x0858, 0x83ff, 0x1948,
+	0x2d58, 0x2c50, 0x7152, 0xd7bc, 0x1110, 0x7028, 0x6022, 0xc7bc,
+	0x670a, 0x68c0, 0xa065, 0xa04d, 0x6100, 0x2a60, 0x2041, 0x0001,
+	0x6b14, 0xa39c, 0x001f, 0xa39d, 0x00c0, 0xd1fc, 0x0110, 0xd684,
+	0x0110, 0xa39c, 0xffbf, 0xd6a4, 0x0110, 0xa39d, 0x0020, 0xa684,
+	0x000e, 0x1904, 0x27b3, 0xc7a5, 0x670a, 0x2c00, 0x68c6, 0x77a0,
+	0xa786, 0x0001, 0x1178, 0x70d0, 0xd0b4, 0x1160, 0x7000, 0xa082,
+	0x0002, 0x1240, 0x7830, 0xd0bc, 0x1128, 0x789b, 0x0080, 0x7baa,
+	0x0804, 0x27fa, 0x8739, 0x77a2, 0x2750, 0x77ac, 0xa7b0, 0x0005,
+	0x70a8, 0xa606, 0x1108, 0x76a4, 0x76ae, 0x2c3a, 0x8738, 0x2d3a,
+	0x8738, 0x283a, 0x8738, 0x233a, 0x8738, 0x253a, 0x7830, 0xd0bc,
+	0x0150, 0x2091, 0x8000, 0x2091, 0x303d, 0x70d0, 0xa084, 0x303d,
+	0x2091, 0x8000, 0x2090, 0xaad5, 0x0000, 0x0120, 0x8421, 0x2200,
+	0x1904, 0x2704, 0x0005, 0xd1dc, 0x0904, 0x3796, 0x2029, 0x0020,
+	0xd69c, 0x1120, 0x8528, 0xd68c, 0x1108, 0x8528, 0x8840, 0x6f14,
+	0x610c, 0x8108, 0xa18c, 0x00ff, 0x70c8, 0xa160, 0x2c64, 0x8cff,
+	0x0188, 0x6014, 0xa706, 0x1dd0, 0x60b8, 0x8001, 0x60ba, 0x1d88,
+	0x2a60, 0x6008, 0xa085, 0x0100, 0x600a, 0x2200, 0x8421, 0x1904,
+	0x2704, 0x0005, 0x2a60, 0x610e, 0x69be, 0x2c00, 0x68c6, 0x8840,
+	0x6008, 0xc0d5, 0x600a, 0x77a0, 0xa786, 0x0001, 0x1904, 0x278a,
+	0x70d0, 0xd0b4, 0x1904, 0x278a, 0x7000, 0xa082, 0x0002, 0x1a04,
+	0x278a, 0x7830, 0xd0bc, 0x1904, 0x278a, 0x789b, 0x0080, 0x7baa,
+	0x7daa, 0x79aa, 0x2001, 0x0002, 0x0006, 0x6018, 0x8000, 0x601a,
+	0x0008, 0x0006, 0x2960, 0x6104, 0x2a60, 0x080c, 0x3ca7, 0x1590,
+	0xa184, 0x0018, 0x0180, 0xa184, 0x0010, 0x0118, 0x080c, 0x393d,
+	0x1548, 0xa184, 0x0008, 0x0138, 0x69a0, 0xa184, 0x0600, 0x1118,
+	0x080c, 0x385d, 0x00f8, 0x69a0, 0xa184, 0x1e00, 0x0528, 0xa184,
+	0x0800, 0x0178, 0x00c6, 0x2960, 0x6000, 0xa085, 0x2000, 0x6002,
+	0x6104, 0xa18d, 0x0010, 0x6106, 0x00ce, 0x080c, 0x393d, 0x1150,
+	0x69a0, 0xa184, 0x0200, 0x0118, 0x080c, 0x38a0, 0x0018, 0xa184,
+	0x0400, 0x19f0, 0x69a0, 0xa184, 0x1000, 0x0130, 0x6914, 0xa18c,
+	0xff00, 0x810f, 0x080c, 0x2384, 0x002e, 0xa68c, 0x00e0, 0xa684,
+	0x0060, 0x0128, 0xa086, 0x0060, 0x1110, 0xa18d, 0x4000, 0xa18d,
+	0x0104, 0x69b6, 0x789b, 0x0060, 0x2800, 0x78aa, 0x6818, 0xc0fd,
+	0x681a, 0xd6bc, 0x0168, 0xc0fc, 0x7083, 0x0000, 0xa08a, 0x000d,
+	0x0328, 0xa08a, 0x000c, 0x7182, 0x2001, 0x000c, 0x800c, 0x7186,
+	0x78aa, 0x3518, 0x3340, 0x3428, 0x8000, 0x80ac, 0xaf80, 0x002b,
+	0x20a0, 0x789b, 0x0000, 0xad80, 0x000b, 0x2098, 0x53a6, 0x23a8,
+	0x2898, 0x25a0, 0xa286, 0x0020, 0x1508, 0x70d0, 0xc0b5, 0x70d2,
+	0x2c00, 0x70b6, 0x2d00, 0x70ba, 0x6814, 0xc0fc, 0x8007, 0x7882,
+	0xa286, 0x0002, 0x0904, 0x28d2, 0x70a0, 0x8000, 0x70a2, 0x74b0,
+	0xa498, 0x0005, 0x70a8, 0xa306, 0x1108, 0x73a4, 0x73b2, 0xa286,
+	0x0010, 0x0904, 0x257c, 0x00de, 0x00ce, 0x0005, 0x7000, 0xa005,
+	0x19e0, 0xa286, 0x0002, 0x1904, 0x28e9, 0x080c, 0x3bf9, 0x19a8,
+	0x6814, 0xc0fc, 0x8007, 0x7882, 0x2091, 0x8000, 0x781b, 0x0068,
 	0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da,
-	0x7808, 0xc08d, 0x780a, 0x68bc, 0x7042, 0xc1b4, 0x71d6, 0x70b8,
-	0xa065, 0x68c0, 0x705a, 0x7003, 0x0002, 0x2d00, 0x704e, 0xad80,
-	0x0009, 0x7046, 0x0005, 0x080c, 0x3a8d, 0x1120, 0x781b, 0x0054,
-	0x7003, 0x0004, 0x0005, 0x080c, 0x3a8d, 0x1128, 0x2011, 0x000c,
-	0x0419, 0x7003, 0x0004, 0x0005, 0x080c, 0x3a8d, 0x1128, 0x2011,
-	0x0006, 0x00d1, 0x7003, 0x0004, 0x0005, 0x080c, 0x3a8d, 0x1128,
-	0x2011, 0x000d, 0x0089, 0x7003, 0x0004, 0x0005, 0x080c, 0x3a8d,
-	0x1150, 0x2011, 0x0006, 0x0041, 0x707c, 0x707f, 0x0000, 0x2068,
-	0x704e, 0x7003, 0x0001, 0x0005, 0x7174, 0xc1fc, 0x8107, 0x7882,
-	0x789b, 0x0080, 0xa286, 0x000c, 0x1120, 0x7aaa, 0x2001, 0x0001,
-	0x0098, 0xa18c, 0x001f, 0xa18d, 0x00c0, 0x79aa, 0xa286, 0x000d,
-	0x0120, 0x7aaa, 0x2001, 0x0002, 0x0038, 0x78ab, 0x0020, 0x7178,
-	0x79aa, 0x7aaa, 0x2001, 0x0004, 0x789b, 0x0060, 0x78aa, 0x785b,
-	0x0004, 0x781b, 0x0113, 0x080c, 0x3aa0, 0x7083, 0x000f, 0x70d4,
-	0xd0b4, 0x0168, 0xc0b4, 0x70d6, 0x00c6, 0x70b8, 0xa065, 0x6008,
-	0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a, 0x00ce, 0x0005,
-	0x7014, 0xa005, 0x1138, 0x70d4, 0xd0b4, 0x0128, 0x70b8, 0xac06,
-	0x1110, 0x0c29, 0x0005, 0x0016, 0x71a4, 0xa186, 0x0001, 0x0528,
-	0x00d6, 0x0026, 0x2100, 0x2011, 0x0001, 0xa212, 0x70b4, 0x2068,
-	0x6800, 0xac06, 0x0120, 0x8211, 0x01b0, 0x00c9, 0x0cc8, 0x00c6,
-	0x2100, 0x2011, 0x0001, 0xa212, 0x70b4, 0x2068, 0x6800, 0x2060,
-	0x6008, 0xa084, 0xfbef, 0x600a, 0x8211, 0x0110, 0x0041, 0x0cb0,
-	0x70a7, 0x0001, 0x00ce, 0x002e, 0x00de, 0x001e, 0x0005, 0xade8,
-	0x0005, 0x70ac, 0xad06, 0x1110, 0x70a8, 0x2068, 0x0005, 0x080c,
-	0x3a8d, 0x1904, 0x248c, 0x707c, 0x2068, 0x7774, 0x080c, 0x396d,
-	0x2c50, 0x080c, 0x3b28, 0x789b, 0x0080, 0x6814, 0xa084, 0x001f,
-	0xc0bd, 0x78aa, 0x6e1c, 0x2041, 0x0001, 0x2001, 0x0004, 0x0804,
-	0x270f, 0x080c, 0x3a8d, 0x1904, 0x248c, 0x789b, 0x0080, 0x7060,
-	0x2068, 0x6f14, 0x70d4, 0xd0b4, 0x0168, 0xc0b4, 0x70d6, 0x00c6,
-	0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001,
-	0x601a, 0x00ce, 0x080c, 0x396d, 0x2c50, 0x080c, 0x3b28, 0x6824,
-	0xa005, 0x0130, 0xa082, 0x0006, 0x0208, 0x0010, 0x6827, 0x0005,
-	0x6814, 0xa084, 0x001f, 0xc0bd, 0x78aa, 0x2031, 0x0020, 0x2041,
-	0x0001, 0x2001, 0x0003, 0x0804, 0x270f, 0xc28d, 0x72d6, 0x72c0,
-	0xa200, 0xa015, 0x7154, 0x8108, 0xa12a, 0x0208, 0x71c0, 0x2164,
-	0x6504, 0x85ff, 0x1170, 0x7156, 0x8421, 0x1da8, 0x70d4, 0xd08c,
-	0x0128, 0x70d0, 0xa005, 0x1110, 0x70d3, 0x000a, 0x0005, 0x2200,
-	0x0c90, 0x70d4, 0xc08c, 0x70d6, 0x70d3, 0x0000, 0x6034, 0xa005,
-	0x1db0, 0x6708, 0xa784, 0x073f, 0x01d0, 0xd7d4, 0x1d80, 0xa784,
-	0x0021, 0x1d68, 0xa784, 0x0002, 0x0130, 0xa784, 0x0004, 0x0d38,
-	0xa7bc, 0xfffb, 0x670a, 0xa784, 0x0218, 0x1d08, 0xa784, 0x0100,
-	0x0130, 0x6018, 0xa005, 0x19d8, 0xa7bc, 0xfeff, 0x670a, 0x2568,
-	0x6823, 0x0000, 0x6e1c, 0xa684, 0x000e, 0x6318, 0x0128, 0x601c,
-	0xa302, 0x0220, 0x0118, 0x0858, 0x83ff, 0x1948, 0x2d58, 0x2c50,
-	0x7156, 0xd7bc, 0x1110, 0x7028, 0x6022, 0xc7bc, 0x670a, 0x68c0,
-	0xa065, 0xa04d, 0x6100, 0x2a60, 0x2041, 0x0001, 0x6b14, 0xa39c,
-	0x001f, 0xa39d, 0x00c0, 0xd1fc, 0x0110, 0xd684, 0x0110, 0xa39c,
-	0xffbf, 0xd6a4, 0x0110, 0xa39d, 0x0020, 0xa684, 0x000e, 0x1904,
-	0x26c1, 0xc7a5, 0x670a, 0x2c00, 0x68c6, 0x77a4, 0xa786, 0x0001,
-	0x1178, 0x70d4, 0xd0b4, 0x1160, 0x7000, 0xa082, 0x0002, 0x1240,
-	0x7830, 0xd0bc, 0x1128, 0x789b, 0x0080, 0x7baa, 0x0804, 0x2708,
-	0x8739, 0x77a6, 0x2750, 0x77b0, 0xa7b0, 0x0005, 0x70ac, 0xa606,
-	0x1108, 0x76a8, 0x76b2, 0x2c3a, 0x8738, 0x2d3a, 0x8738, 0x283a,
-	0x8738, 0x233a, 0x8738, 0x253a, 0x7830, 0xd0bc, 0x0150, 0x2091,
-	0x8000, 0x2091, 0x303d, 0x70d4, 0xa084, 0x303d, 0x2091, 0x8000,
-	0x2090, 0xaad5, 0x0000, 0x0120, 0x8421, 0x2200, 0x1904, 0x2612,
-	0x0005, 0xd1dc, 0x0904, 0x35d5, 0x2029, 0x0020, 0xd69c, 0x1120,
-	0x8528, 0xd68c, 0x1108, 0x8528, 0x8840, 0x6f14, 0x610c, 0x8108,
-	0xa18c, 0x00ff, 0x70cc, 0xa160, 0x2c64, 0x8cff, 0x0188, 0x6014,
-	0xa706, 0x1dd0, 0x60b8, 0x8001, 0x60ba, 0x1d88, 0x2a60, 0x6008,
-	0xa085, 0x0100, 0x600a, 0x2200, 0x8421, 0x1904, 0x2612, 0x0005,
-	0x2a60, 0x610e, 0x69be, 0x2c00, 0x68c6, 0x8840, 0x6008, 0xc0d5,
-	0x600a, 0x77a4, 0xa786, 0x0001, 0x1904, 0x2698, 0x70d4, 0xd0b4,
-	0x1904, 0x2698, 0x7000, 0xa082, 0x0002, 0x1a04, 0x2698, 0x7830,
-	0xd0bc, 0x1904, 0x2698, 0x789b, 0x0080, 0x7baa, 0x7daa, 0x79aa,
-	0x2001, 0x0002, 0x0006, 0x6018, 0x8000, 0x601a, 0x0008, 0x0006,
-	0x2960, 0x6104, 0x2a60, 0x080c, 0x3b3b, 0x1590, 0xa184, 0x0018,
-	0x0180, 0xa184, 0x0010, 0x0118, 0x080c, 0x3776, 0x1548, 0xa184,
-	0x0008, 0x0138, 0x69a0, 0xa184, 0x0600, 0x1118, 0x080c, 0x3696,
-	0x00f8, 0x69a0, 0xa184, 0x1e00, 0x0528, 0xa184, 0x0800, 0x0178,
-	0x00c6, 0x2960, 0x6000, 0xa085, 0x2000, 0x6002, 0x6104, 0xa18d,
-	0x0010, 0x6106, 0x00ce, 0x080c, 0x3776, 0x1150, 0x69a0, 0xa184,
-	0x0200, 0x0118, 0x080c, 0x36d9, 0x0018, 0xa184, 0x0400, 0x19f0,
-	0x69a0, 0xa184, 0x1000, 0x0130, 0x6914, 0xa18c, 0xff00, 0x810f,
-	0x080c, 0x231f, 0x002e, 0xa68c, 0x00e0, 0xa684, 0x0060, 0x0128,
-	0xa086, 0x0060, 0x1110, 0xa18d, 0x4000, 0xa18d, 0x0104, 0x69b6,
-	0x789b, 0x0060, 0x2800, 0x78aa, 0x6818, 0xc0fd, 0x681a, 0xd6bc,
-	0x0168, 0xc0fc, 0x7087, 0x0000, 0xa08a, 0x000d, 0x0328, 0xa08a,
-	0x000c, 0x7186, 0x2001, 0x000c, 0x800c, 0x718a, 0x78aa, 0x3518,
-	0x3340, 0x3428, 0x8000, 0x80ac, 0xaf80, 0x002b, 0x20a0, 0x789b,
-	0x0000, 0xad80, 0x000b, 0x2098, 0x53a6, 0x23a8, 0x2898, 0x25a0,
-	0xa286, 0x0020, 0x1508, 0x70d4, 0xc0b5, 0x70d6, 0x2c00, 0x70ba,
-	0x2d00, 0x70be, 0x6814, 0xc0fc, 0x8007, 0x7882, 0xa286, 0x0002,
-	0x0904, 0x27e0, 0x70a4, 0x8000, 0x70a6, 0x74b4, 0xa498, 0x0005,
-	0x70ac, 0xa306, 0x1108, 0x73a8, 0x73b6, 0xa286, 0x0010, 0x0904,
-	0x248c, 0x00de, 0x00ce, 0x0005, 0x7000, 0xa005, 0x19e0, 0xa286,
-	0x0002, 0x1904, 0x27f7, 0x080c, 0x3a8d, 0x19a8, 0x6814, 0xc0fc,
-	0x8007, 0x7882, 0x2091, 0x8000, 0x781b, 0x0068, 0x68b4, 0x785a,
-	0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0x2091, 0x8001,
-	0x7808, 0xc08d, 0x780a, 0x0126, 0x00d6, 0x00c6, 0x70d4, 0xa084,
-	0x2e00, 0x2090, 0x00ce, 0x00de, 0x012e, 0x2900, 0x705a, 0x68bc,
-	0x7042, 0x7003, 0x0002, 0x2d00, 0x704e, 0xad80, 0x0009, 0x7046,
-	0x7830, 0xd0bc, 0x0140, 0x2091, 0x303d, 0x70d4, 0xa084, 0x303d,
-	0x2091, 0x8000, 0x2090, 0x70a4, 0xa005, 0x1108, 0x0005, 0x8421,
-	0x0de8, 0x7250, 0x70c0, 0xa200, 0xa015, 0x0804, 0x2612, 0xa286,
-	0x0010, 0x1560, 0x080c, 0x3a8d, 0x1904, 0x278b, 0x6814, 0xc0fc,
-	0x8007, 0x7882, 0x781b, 0x0068, 0x68b4, 0x785a, 0x6894, 0x78d6,
-	0x78de, 0x6898, 0x78d2, 0x78da, 0x7808, 0xc08d, 0x780a, 0x70a4,
-	0x8000, 0x70a6, 0x74b4, 0xa490, 0x0005, 0x70ac, 0xa206, 0x1108,
-	0x72a8, 0x72b6, 0x2900, 0x705a, 0x68bc, 0x7042, 0x7003, 0x0002,
-	0x2d00, 0x704e, 0xad80, 0x0009, 0x7046, 0x0005, 0x6bb4, 0xa39d,
-	0x2000, 0x7b5a, 0x6814, 0xc0fc, 0x8007, 0x7882, 0x6b94, 0x7bd6,
-	0x7bde, 0x6e98, 0x7ed2, 0x7eda, 0x781b, 0x0068, 0x2900, 0x705a,
-	0x7202, 0x7808, 0xc08d, 0x780a, 0x2300, 0xa605, 0x0170, 0x70d4,
-	0xa084, 0x2e00, 0xa086, 0x2600, 0x1118, 0x2009, 0x0000, 0x0010,
-	0x2009, 0x0001, 0xa284, 0x000f, 0x0023, 0xad80, 0x0009, 0x7046,
-	0x0005, 0x2859, 0x3fb8, 0x3fb8, 0x3fa6, 0x3fb8, 0x2859, 0x2859,
-	0x2859, 0x080c, 0x243b, 0x7808, 0xa084, 0xfffd, 0x780a, 0x00f6,
-	0x2079, 0x4300, 0x78ac, 0x00fe, 0xd084, 0x01c0, 0x7064, 0xa086,
-	0x0001, 0x1118, 0x7066, 0x0804, 0x293a, 0x7064, 0xa086, 0x0005,
-	0x1158, 0x707c, 0x2068, 0x681b, 0x0004, 0x6817, 0x0000, 0x6820,
-	0xa084, 0x00ff, 0xc09d, 0x6822, 0x7067, 0x0000, 0x70a7, 0x0000,
-	0x70a8, 0x70b2, 0x70b6, 0x080c, 0x256f, 0x0156, 0x2011, 0x0004,
-	0x7164, 0xa186, 0x0001, 0x0170, 0xa186, 0x0007, 0x1118, 0x701f,
-	0x0005, 0x0040, 0x701f, 0x0001, 0x7067, 0x0000, 0x70d4, 0xc0c5,
-	0x70d6, 0x0010, 0x7067, 0x0000, 0x2001, 0x430a, 0x2004, 0xa084,
-	0x00ff, 0xa086, 0x0018, 0x0130, 0x7018, 0x7016, 0xa005, 0x1110,
-	0x70a7, 0x0001, 0x0066, 0x080c, 0x3d52, 0x20a9, 0x0010, 0x2039,
-	0x0000, 0x080c, 0x3861, 0xa7b8, 0x0100, 0x1f04, 0x28b1, 0x006e,
-	0x7000, 0x0002, 0x28ee, 0x28cc, 0x28cc, 0x28c4, 0x28ee, 0x28ee,
-	0x28ee, 0x28c2, 0x080c, 0x243b, 0x7060, 0xa005, 0x0538, 0xad06,
-	0x1118, 0x6800, 0x7062, 0x0080, 0x6820, 0xd084, 0x1148, 0x6f14,
-	0x080c, 0x396d, 0x6008, 0xc0d4, 0x600a, 0x080c, 0x35ab, 0x0020,
-	0x705c, 0x2060, 0x6800, 0x6002, 0xa684, 0x5f00, 0x681e, 0x6818,
-	0xd0fc, 0x0108, 0x6a1a, 0x6817, 0x0000, 0x682b, 0x0000, 0x6820,
-	0xa084, 0x00ff, 0xc09d, 0x6822, 0x080c, 0x1d3d, 0xb284, 0x0800,
-	0x0118, 0x2021, 0x8ad0, 0x0010, 0x2021, 0x89c0, 0x080c, 0x293f,
-	0xb284, 0x0800, 0x0118, 0x2021, 0x4398, 0x0010, 0x2021, 0x4358,
-	0x04f1, 0x20a9, 0x0101, 0xb284, 0x0800, 0x0118, 0x2021, 0x89d0,
-	0x0010, 0x2021, 0x88c0, 0x0499, 0x8420, 0x1f04, 0x290b, 0xb284,
-	0x0600, 0x0118, 0x2061, 0x48c0, 0x0010, 0x2061, 0x68c0, 0x2021,
-	0x0002, 0x20a9, 0x0100, 0x6110, 0x81ff, 0x0198, 0x6018, 0x0016,
-	0x0006, 0x2011, 0x4302, 0x220c, 0xa102, 0x2012, 0x000e, 0x001e,
-	0xa102, 0x0338, 0x6012, 0x1128, 0x2011, 0x4304, 0x2204, 0xc0a5,
-	0x2012, 0x601b, 0x0000, 0xace0, 0x0010, 0x1f04, 0x291b, 0x8421,
-	0x1d00, 0x015e, 0x7003, 0x0000, 0x704f, 0x0000, 0x0005, 0x0046,
-	0x2404, 0xa005, 0x01a8, 0x2068, 0x6800, 0x0006, 0x6a1a, 0x6817,
+	0x2091, 0x8001, 0x7808, 0xc08d, 0x780a, 0x0126, 0x00d6, 0x00c6,
+	0x70d0, 0xa084, 0x2e00, 0x2090, 0x00ce, 0x00de, 0x012e, 0x2900,
+	0x7056, 0x68bc, 0x703e, 0x7003, 0x0002, 0x2d00, 0x704a, 0xad80,
+	0x0009, 0x7042, 0x7830, 0xd0bc, 0x0140, 0x2091, 0x303d, 0x70d0,
+	0xa084, 0x303d, 0x2091, 0x8000, 0x2090, 0x70a0, 0xa005, 0x1108,
+	0x0005, 0x8421, 0x0de8, 0x724c, 0x70bc, 0xa200, 0xa015, 0x0804,
+	0x2704, 0xa286, 0x0010, 0x1560, 0x080c, 0x3bf9, 0x1904, 0x287d,
+	0x6814, 0xc0fc, 0x8007, 0x7882, 0x781b, 0x0068, 0x68b4, 0x785a,
+	0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0x7808, 0xc08d,
+	0x780a, 0x70a0, 0x8000, 0x70a2, 0x74b0, 0xa490, 0x0005, 0x70a8,
+	0xa206, 0x1108, 0x72a4, 0x72b2, 0x2900, 0x7056, 0x68bc, 0x703e,
+	0x7003, 0x0002, 0x2d00, 0x704a, 0xad80, 0x0009, 0x7042, 0x0005,
+	0x6bb4, 0xa39d, 0x2000, 0x7b5a, 0x6814, 0xc0fc, 0x8007, 0x7882,
+	0x6b94, 0x7bd6, 0x7bde, 0x6e98, 0x7ed2, 0x7eda, 0x781b, 0x0068,
+	0x2900, 0x7056, 0x7202, 0x7808, 0xc08d, 0x780a, 0x2300, 0xa605,
+	0x0170, 0x70d0, 0xa084, 0x2e00, 0xa086, 0x2600, 0x1118, 0x2009,
+	0x0000, 0x0010, 0x2009, 0x0001, 0xa284, 0x000f, 0x0023, 0xad80,
+	0x0009, 0x7042, 0x0005, 0x294b, 0x4180, 0x4180, 0x416e, 0x4180,
+	0x294b, 0x294b, 0x294b, 0x080c, 0x252b, 0x7808, 0xa084, 0xfffd,
+	0x780a, 0x00f6, 0x2079, 0x4500, 0x78ac, 0x00fe, 0xd084, 0x01b0,
+	0x7060, 0xa086, 0x0001, 0x0904, 0x2a29, 0x7060, 0xa086, 0x0005,
+	0x1158, 0x7078, 0x2068, 0x681b, 0x0004, 0x6817, 0x0000, 0x6820,
+	0xa084, 0x00ff, 0xc09d, 0x6822, 0x7063, 0x0000, 0x70a3, 0x0000,
+	0x70a4, 0x70ae, 0x70b2, 0x080c, 0x2661, 0x0156, 0x2011, 0x0004,
+	0x7160, 0xa186, 0x0001, 0x0160, 0xa186, 0x0007, 0x1118, 0x701f,
+	0x0005, 0x0030, 0x701f, 0x0001, 0x70d0, 0xc0c5, 0x70d2, 0x0000,
+	0x2001, 0x450a, 0x2004, 0xa084, 0x00ff, 0xa086, 0x0018, 0x0130,
+	0x7018, 0x7016, 0xa005, 0x1110, 0x70a3, 0x0001, 0x0066, 0x080c,
+	0x3ed9, 0x20a9, 0x0010, 0x2039, 0x0000, 0x080c, 0x3a29, 0xa7b8,
+	0x0100, 0x1f04, 0x299d, 0x006e, 0x7000, 0x0002, 0x29da, 0x29b8,
+	0x29b8, 0x29b0, 0x29da, 0x29da, 0x29da, 0x29ae, 0x080c, 0x252b,
+	0x705c, 0xa005, 0x0538, 0xad06, 0x1118, 0x6800, 0x705e, 0x0080,
+	0x6820, 0xd084, 0x1148, 0x6f14, 0x080c, 0x3b35, 0x6008, 0xc0d4,
+	0x600a, 0x080c, 0x376c, 0x0020, 0x7058, 0x2060, 0x6800, 0x6002,
+	0xa684, 0x5f00, 0x681e, 0x6818, 0xd0fc, 0x0108, 0x6a1a, 0x6817,
+	0x0000, 0x682b, 0x0000, 0x6820, 0xa084, 0x00ff, 0xc09d, 0x6822,
+	0x080c, 0x1d89, 0x2011, 0x0004, 0xb284, 0x0800, 0x0118, 0x2021,
+	0x8cd0, 0x0010, 0x2021, 0x8bc0, 0x080c, 0x2a30, 0xb284, 0x0800,
+	0x0118, 0x2021, 0x4597, 0x0010, 0x2021, 0x4557, 0x080c, 0x2a30,
+	0x20a9, 0x0101, 0xb284, 0x0800, 0x0118, 0x2021, 0x8bd0, 0x0010,
+	0x2021, 0x8ac0, 0x04a9, 0x8420, 0x1f04, 0x29fa, 0xb284, 0x0600,
+	0x0118, 0x2061, 0x4ac0, 0x0010, 0x2061, 0x6ac0, 0x2021, 0x0002,
+	0x20a9, 0x0100, 0x6110, 0x81ff, 0x0198, 0x6018, 0x0016, 0x0006,
+	0x2011, 0x4502, 0x220c, 0xa102, 0x2012, 0x000e, 0x001e, 0xa102,
+	0x0338, 0x6012, 0x1128, 0x2011, 0x4504, 0x2204, 0xc0a5, 0x2012,
+	0x601b, 0x0000, 0xace0, 0x0010, 0x1f04, 0x2a0a, 0x8421, 0x1d00,
+	0x015e, 0x7063, 0x0000, 0x7003, 0x0000, 0x704b, 0x0000, 0x0005,
+	0x0046, 0x2404, 0xa005, 0x01a8, 0x2068, 0x6800, 0x0006, 0x6a1a,
+	0x6817, 0x0000, 0x682b, 0x0000, 0x68b4, 0xa084, 0x5f00, 0x681e,
+	0x6820, 0xa084, 0x00ff, 0xc09d, 0x6822, 0x080c, 0x1d89, 0x000e,
+	0x0c48, 0x004e, 0x2023, 0x0000, 0x0005, 0xa282, 0x0003, 0x0310,
+	0x080c, 0x252b, 0x2300, 0x0002, 0x2a57, 0x2ad4, 0x2aee, 0xa282,
+	0x0002, 0x0110, 0x080c, 0x252b, 0x7060, 0x7063, 0x0000, 0x707f,
+	0x0000, 0x0022, 0x77d0, 0xc7c5, 0x77d2, 0x0002, 0x2a6e, 0x2a6e,
+	0x2a70, 0x2aa8, 0x37a0, 0x2a6e, 0x2aa8, 0x2a6e, 0x080c, 0x252b,
+	0x7770, 0x080c, 0x3a29, 0x7770, 0xa7bc, 0x8f00, 0x080c, 0x3b35,
+	0x6018, 0xa005, 0x0528, 0xd7fc, 0x1118, 0x2021, 0x8bc0, 0x0010,
+	0x2021, 0x8cd0, 0x2009, 0x0005, 0x2011, 0x0010, 0x080c, 0x2b08,
+	0x01b8, 0x0156, 0x20a9, 0x0101, 0xd7fc, 0x1118, 0x2021, 0x8ac0,
+	0x0010, 0x2021, 0x8bd0, 0x0046, 0x2009, 0x0005, 0x2011, 0x0010,
+	0x080c, 0x2b08, 0x004e, 0x0118, 0x8420, 0x1f04, 0x2a93, 0x015e,
+	0x8738, 0xa784, 0x001f, 0x1990, 0x0804, 0x257f, 0x0804, 0x257f,
+	0x7770, 0x080c, 0x3b35, 0x6018, 0xa005, 0x0520, 0xd7fc, 0x1118,
+	0x2021, 0x8bc0, 0x0010, 0x2021, 0x8cd0, 0x2009, 0x0005, 0x2011,
+	0x0020, 0x080c, 0x2b08, 0x01b0, 0x0156, 0x20a9, 0x0101, 0xd7fc,
+	0x1118, 0x2021, 0x8ac0, 0x0010, 0x2021, 0x8bd0, 0x0046, 0x2009,
+	0x0005, 0x2011, 0x0020, 0x04e1, 0x004e, 0x0118, 0x8420, 0x1f04,
+	0x2ac6, 0x015e, 0x0804, 0x257f, 0x2200, 0x0002, 0x2ad9, 0x2adb,
+	0x2adb, 0x080c, 0x252b, 0x2009, 0x0012, 0x7060, 0xa086, 0x0002,
+	0x0110, 0x2009, 0x000e, 0x6818, 0xd0fc, 0x0108, 0x691a, 0x7063,
+	0x0000, 0x70d0, 0xc0c5, 0x70d2, 0x0804, 0x3bab, 0x2200, 0x0002,
+	0x2af5, 0x2adb, 0x2af3, 0x080c, 0x252b, 0x080c, 0x3ed9, 0x7000,
+	0xa086, 0x0002, 0x1904, 0x3725, 0x080c, 0x3786, 0x6008, 0xa084,
+	0xfbef, 0x600a, 0x080c, 0x3717, 0x0904, 0x3725, 0x0804, 0x257f,
+	0x2404, 0xa005, 0x0590, 0x2068, 0x2d04, 0x0006, 0x6814, 0xa706,
+	0x0118, 0x2d20, 0x000e, 0x0ca8, 0x000e, 0x2022, 0x691a, 0x6817,
 	0x0000, 0x682b, 0x0000, 0x68b4, 0xa084, 0x5f00, 0x681e, 0x6820,
-	0xa084, 0x00ff, 0xc09d, 0x6822, 0x080c, 0x1d3d, 0x000e, 0x0c48,
-	0x004e, 0x2023, 0x0000, 0x0005, 0xa282, 0x0003, 0x0310, 0x080c,
-	0x243b, 0x2300, 0x0002, 0x2966, 0x29e3, 0x29fd, 0xa282, 0x0002,
-	0x0110, 0x080c, 0x243b, 0x7064, 0x7067, 0x0000, 0x7083, 0x0000,
-	0x0022, 0x77d4, 0xc7c5, 0x77d6, 0x0002, 0x297d, 0x297d, 0x297f,
-	0x29b7, 0x35df, 0x297d, 0x29b7, 0x297d, 0x080c, 0x243b, 0x7774,
-	0x080c, 0x3861, 0x7774, 0xa7bc, 0x8f00, 0x080c, 0x396d, 0x6018,
-	0xa005, 0x0528, 0xd7fc, 0x1118, 0x2021, 0x89c0, 0x0010, 0x2021,
-	0x8ad0, 0x2009, 0x0005, 0x2011, 0x0010, 0x080c, 0x2a17, 0x01b8,
-	0x0156, 0x20a9, 0x0101, 0xd7fc, 0x1118, 0x2021, 0x88c0, 0x0010,
-	0x2021, 0x89d0, 0x0046, 0x2009, 0x0005, 0x2011, 0x0010, 0x080c,
-	0x2a17, 0x004e, 0x0118, 0x8420, 0x1f04, 0x29a2, 0x015e, 0x8738,
-	0xa784, 0x001f, 0x1990, 0x0804, 0x248f, 0x0804, 0x248f, 0x7774,
-	0x080c, 0x396d, 0x6018, 0xa005, 0x0520, 0xd7fc, 0x1118, 0x2021,
-	0x89c0, 0x0010, 0x2021, 0x8ad0, 0x2009, 0x0005, 0x2011, 0x0020,
-	0x080c, 0x2a17, 0x01b0, 0x0156, 0x20a9, 0x0101, 0xd7fc, 0x1118,
-	0x2021, 0x88c0, 0x0010, 0x2021, 0x89d0, 0x0046, 0x2009, 0x0005,
-	0x2011, 0x0020, 0x04e1, 0x004e, 0x0118, 0x8420, 0x1f04, 0x29d5,
-	0x015e, 0x0804, 0x248f, 0x2200, 0x0002, 0x29e8, 0x29ea, 0x29ea,
-	0x080c, 0x243b, 0x2009, 0x0012, 0x7064, 0xa086, 0x0002, 0x0110,
-	0x2009, 0x000e, 0x6818, 0xd0fc, 0x0108, 0x691a, 0x7067, 0x0000,
-	0x70d4, 0xc0c5, 0x70d6, 0x0804, 0x3a3f, 0x2200, 0x0002, 0x2a04,
-	0x29ea, 0x2a02, 0x080c, 0x243b, 0x080c, 0x3d52, 0x7000, 0xa086,
-	0x0002, 0x1904, 0x356d, 0x080c, 0x35c5, 0x6008, 0xa084, 0xfbef,
-	0x600a, 0x080c, 0x355f, 0x0904, 0x356d, 0x0804, 0x248f, 0x2404,
-	0xa005, 0x0590, 0x2068, 0x2d04, 0x0006, 0x6814, 0xa706, 0x0118,
-	0x2d20, 0x000e, 0x0ca8, 0x000e, 0x2022, 0x691a, 0x6817, 0x0000,
-	0x682b, 0x0000, 0x68b4, 0xa084, 0x5f00, 0x681e, 0x6820, 0xa084,
-	0x00ff, 0xa205, 0x6822, 0x080c, 0x1d3d, 0x2021, 0x4302, 0x241c,
-	0x8319, 0x2322, 0x6010, 0x8001, 0x6012, 0x1128, 0x2021, 0x4304,
-	0x2404, 0xc0a5, 0x2022, 0x6008, 0xa084, 0xf9ef, 0x600a, 0x080c,
-	0x258b, 0x080c, 0x35c5, 0x0005, 0xa085, 0x0001, 0x0ce0, 0x2300,
-	0x0002, 0x2a56, 0x2a54, 0x2abc, 0x080c, 0x243b, 0x78e4, 0xa005,
-	0x1708, 0x3208, 0xa18c, 0x0800, 0x0118, 0x0104, 0x248c, 0x0010,
-	0x0304, 0x248c, 0x2008, 0xa084, 0x0030, 0x1110, 0x0804, 0x30a0,
-	0x78ec, 0xa084, 0x0003, 0x0dd0, 0x2100, 0xa084, 0x0007, 0x0002,
-	0x2a9f, 0x2aa8, 0x2a95, 0x2a78, 0x3a83, 0x3a83, 0x2a78, 0x2ab2,
-	0x080c, 0x243b, 0x7000, 0xa086, 0x0004, 0x1190, 0x7064, 0xa086,
-	0x0002, 0x1130, 0x2011, 0x0002, 0x2019, 0x0000, 0x0804, 0x295c,
-	0x7064, 0xa086, 0x0006, 0x0db0, 0x7064, 0xa086, 0x0004, 0x0d90,
-	0x79e4, 0x2001, 0x0003, 0x0804, 0x2daa, 0x6818, 0xd0fc, 0x0110,
-	0x681b, 0x001d, 0x080c, 0x3837, 0x781b, 0x006e, 0x0005, 0x6818,
-	0xd0fc, 0x0110, 0x681b, 0x001d, 0x080c, 0x3837, 0x0804, 0x3a61,
-	0x6818, 0xd0fc, 0x0110, 0x681b, 0x001d, 0x080c, 0x3837, 0x781b,
-	0x00fa, 0x0005, 0x6818, 0xd0fc, 0x0110, 0x681b, 0x001d, 0x080c,
-	0x3837, 0x781b, 0x00cb, 0x0005, 0xa584, 0x000f, 0x11c0, 0x7000,
-	0x0002, 0x248f, 0x2ac9, 0x2acb, 0x356d, 0x356d, 0x356d, 0x2ac9,
-	0x2ac9, 0x080c, 0x243b, 0x080c, 0x35c5, 0x6008, 0xa084, 0xfbef,
-	0x600a, 0x080c, 0x355f, 0x0904, 0x356d, 0x0804, 0x248f, 0x78e4,
-	0xa005, 0x1b04, 0x2a7a, 0x3208, 0xa18c, 0x0800, 0x0118, 0x0104,
-	0x2a7a, 0x0010, 0x0304, 0x2a7a, 0x2008, 0xa084, 0x0030, 0x1118,
-	0x781b, 0x0068, 0x0005, 0x78ec, 0xa084, 0x0003, 0x0dc8, 0x2100,
-	0xa184, 0x0007, 0x0002, 0x2b02, 0x2b06, 0x2afd, 0x2afb, 0x3a83,
-	0x3a83, 0x2afb, 0x3a7d, 0x080c, 0x243b, 0x080c, 0x383d, 0x781b,
-	0x006e, 0x0005, 0x080c, 0x383d, 0x0804, 0x3a61, 0x080c, 0x383d,
-	0x781b, 0x00fa, 0x0005, 0x080c, 0x383d, 0x781b, 0x00cb, 0x0005,
-	0x2300, 0x0002, 0x2b17, 0x2b15, 0x2b19, 0x080c, 0x243b, 0x0804,
-	0x3220, 0x681b, 0x0016, 0x78a3, 0x0000, 0x79e4, 0xa184, 0x0030,
-	0x0904, 0x3220, 0x78ec, 0xa084, 0x0003, 0x0904, 0x3220, 0xa184,
-	0x0100, 0x0d98, 0xa184, 0x0007, 0x0002, 0x2b35, 0x2b06, 0x2a95,
-	0x3a3f, 0x3a83, 0x3a83, 0x3a3f, 0x3a7d, 0x080c, 0x3a4b, 0x0005,
-	0xa282, 0x0005, 0x0310, 0x080c, 0x243b, 0x7898, 0x2040, 0x2300,
-	0x0002, 0x2b44, 0x2d41, 0x2d4b, 0x2200, 0x0002, 0x2b60, 0x2b4d,
-	0x2b60, 0x2b4b, 0x2d25, 0x080c, 0x243b, 0x789b, 0x0018, 0x78a8,
-	0x2010, 0xa084, 0x00ff, 0xa082, 0x0020, 0x0a04, 0x3809, 0xa08a,
-	0x0004, 0x1a04, 0x3809, 0x0002, 0x3809, 0x3809, 0x3809, 0x37bf,
-	0x789b, 0x0018, 0x79a8, 0xa184, 0x0080, 0x0148, 0x0804, 0x3809,
-	0x7000, 0xa005, 0x1dd8, 0x2011, 0x0004, 0x0804, 0x33b2, 0xa184,
-	0x00ff, 0xa08a, 0x0010, 0x1a04, 0x3809, 0x0002, 0x2b88, 0x2b86,
-	0x2b9a, 0x2b9e, 0x2c3c, 0x3809, 0x3809, 0x2c3e, 0x3809, 0x3809,
-	0x2d21, 0x2d21, 0x3809, 0x3809, 0x3809, 0x2d23, 0x080c, 0x243b,
-	0xd6e4, 0x0140, 0x2001, 0x0300, 0x8000, 0x8000, 0x783a, 0x781b,
-	0x00c6, 0x0005, 0x6818, 0xd0fc, 0x0118, 0x681b, 0x001d, 0x0c90,
-	0x0804, 0x3a3f, 0x681b, 0x001d, 0x0804, 0x3831, 0x6920, 0x6922,
-	0xa684, 0x1800, 0x15e0, 0x6820, 0xd084, 0x1904, 0x2be7, 0x6818,
-	0xa086, 0x0008, 0x1110, 0x681b, 0x0000, 0xd6d4, 0x0568, 0xd6bc,
-	0x0558, 0x7087, 0x0000, 0x6818, 0xa084, 0x003f, 0xa08a, 0x000d,
-	0x0718, 0xa08a, 0x000c, 0x7186, 0x2001, 0x000c, 0x800c, 0x718a,
-	0x789b, 0x0061, 0x78aa, 0x0156, 0x0136, 0x0146, 0x0016, 0x3208,
-	0xa18c, 0x0600, 0x0118, 0x20a1, 0x022b, 0x0010, 0x20a1, 0x012b,
-	0x001e, 0x789b, 0x0000, 0x8000, 0x80ac, 0xad80, 0x000b, 0x2098,
-	0x53a6, 0x014e, 0x013e, 0x015e, 0x781b, 0x0071, 0x0005, 0xd6e4,
-	0x0130, 0x781b, 0x0083, 0x0005, 0x781b, 0x0083, 0x0005, 0xa684,
-	0x0060, 0x0dd0, 0xd6dc, 0x0dc0, 0xd6fc, 0x01a0, 0xc6fc, 0x7e5a,
-	0x6eb6, 0x7adc, 0x79d8, 0x78d0, 0x8007, 0xa084, 0x007f, 0xa108,
-	0xa291, 0x0000, 0x6b98, 0x2100, 0xa302, 0x68b2, 0x6b94, 0x2200,
-	0xa303, 0x68ae, 0xd6f4, 0x0118, 0xc6f4, 0x7e5a, 0x6eb6, 0x7000,
-	0xa086, 0x0003, 0x1148, 0x0006, 0x080c, 0x3d52, 0x080c, 0x3fb8,
-	0x000e, 0x781b, 0x0080, 0x0005, 0xa006, 0x080c, 0x4083, 0x6ab0,
-	0x69ac, 0x6c98, 0x6b94, 0x2200, 0xa105, 0x0120, 0x2200, 0xa422,
-	0x2100, 0xa31b, 0x6caa, 0x7cd2, 0x7cda, 0x6ba6, 0x7bd6, 0x7bde,
-	0x2300, 0xa405, 0x1130, 0xc6f5, 0x7e5a, 0x6eb6, 0x781b, 0x0080,
-	0x0005, 0x781b, 0x0080, 0x2200, 0xa115, 0x1118, 0x080c, 0x3fb8,
-	0x0005, 0x080c, 0x3fe5, 0x0005, 0x080c, 0x243b, 0x0804, 0x2cbd,
-	0x00c6, 0x7058, 0x2060, 0x7aa8, 0xa294, 0x00ff, 0xa286, 0x0004,
-	0x11d8, 0x6920, 0xd1e4, 0x1170, 0x2039, 0x0000, 0x2041, 0x0000,
-	0x2031, 0x0000, 0xa006, 0x2010, 0x080c, 0x36f6, 0x080c, 0x379a,
-	0x0804, 0x2cb1, 0xa18c, 0xecff, 0x6922, 0x6104, 0xa18c, 0xffdd,
-	0x6106, 0x6000, 0xc0ac, 0x6002, 0xa286, 0x0003, 0x01d0, 0x6104,
-	0xa18c, 0x0010, 0x0548, 0x080c, 0x3969, 0x080c, 0x3776, 0x88ff,
-	0x0518, 0x00ce, 0x789b, 0x0060, 0x2800, 0x78aa, 0x7e58, 0xc695,
-	0x7e5a, 0xd6d4, 0x1118, 0x781b, 0x006e, 0x0005, 0x781b, 0x0082,
-	0x0005, 0x6920, 0xd1cc, 0x0130, 0xa18c, 0xfdff, 0x6922, 0x6000,
-	0xc0ec, 0x6002, 0x2039, 0x0000, 0x2041, 0x0000, 0x2031, 0x0000,
-	0xa006, 0x2010, 0x080c, 0x379a, 0xa286, 0x0001, 0x0158, 0x6104,
-	0xa18c, 0x0008, 0x01b0, 0x080c, 0x3969, 0x080c, 0x3696, 0x88ff,
-	0x1980, 0x0078, 0x6920, 0xd1c4, 0x0130, 0xa18c, 0xfeff, 0x6922,
-	0x6000, 0xc0e4, 0x6002, 0x2031, 0x0000, 0xa006, 0x2010, 0x080c,
-	0x36f6, 0x00ce, 0x7e58, 0xd6d4, 0x1118, 0x781b, 0x0071, 0x0005,
-	0x781b, 0x0083, 0x0005, 0x0804, 0x382d, 0x2808, 0x789b, 0x0080,
-	0x2019, 0x0080, 0x78a8, 0xa094, 0x00ff, 0xa286, 0x0001, 0x1188,
-	0x7ca8, 0xa4a4, 0x00ff, 0xa480, 0x0002, 0xa300, 0x2018, 0xa102,
-	0x0a04, 0x2c40, 0x0904, 0x2c40, 0x24a8, 0x7aa8, 0x1f04, 0x2cd5,
-	0x0c48, 0xa284, 0x00f0, 0xa082, 0x0020, 0x06b8, 0x2200, 0xa082,
-	0x0021, 0x1698, 0x7aa8, 0x8318, 0x8318, 0x2100, 0xa302, 0x0ad0,
-	0xa286, 0x0023, 0x0980, 0x681c, 0xa084, 0xfff1, 0x681e, 0x7e58,
-	0xa684, 0xfff1, 0xc0a5, 0x2030, 0x7e5a, 0x6008, 0xc0a5, 0x600a,
-	0x78a0, 0x8001, 0x0904, 0x2cb1, 0x20a8, 0x7998, 0x789b, 0x0060,
-	0x78aa, 0x2011, 0x0080, 0x799a, 0x78a8, 0x7998, 0x7a9a, 0x78aa,
-	0x7a98, 0x1f04, 0x2d03, 0xc695, 0x7e5a, 0xd6d4, 0x1118, 0x781b,
-	0x006e, 0x0005, 0x781b, 0x0082, 0x0005, 0x8318, 0x2100, 0xa302,
-	0x0a04, 0x2cc2, 0xa284, 0x0080, 0x1904, 0x3831, 0x78a0, 0xa005,
-	0x08c8, 0x0804, 0x3831, 0x0804, 0x3809, 0x7058, 0xa04d, 0x789b,
-	0x0018, 0x78a8, 0xa084, 0x00ff, 0xa08e, 0x0001, 0x0110, 0x080c,
-	0x243b, 0x7aa8, 0xa294, 0x00ff, 0x78a8, 0xa084, 0x00ff, 0xa08a,
-	0x0005, 0x1a04, 0x3809, 0x0002, 0x3809, 0x3615, 0x3809, 0x3726,
-	0x3b83, 0xa282, 0x0000, 0x1110, 0x080c, 0x243b, 0x080c, 0x3837,
-	0x781b, 0x0082, 0x0005, 0xa282, 0x0003, 0x1110, 0x080c, 0x243b,
-	0xd4fc, 0x11d0, 0x7064, 0xa005, 0x0110, 0x080c, 0x243b, 0x6f14,
-	0x7776, 0xa7bc, 0x8f00, 0x080c, 0x396d, 0x6008, 0xa085, 0x0021,
-	0x600a, 0x8738, 0xa784, 0x001f, 0x1db0, 0x080c, 0x383a, 0x7067,
-	0x0002, 0x701f, 0x0009, 0x0010, 0x080c, 0x3846, 0x781b, 0x0082,
-	0x0005, 0xa282, 0x0004, 0x0310, 0x080c, 0x243b, 0x2300, 0x0002,
-	0x2d7b, 0x2eff, 0x2f3b, 0xa286, 0x0003, 0x0560, 0x7200, 0x7cd8,
-	0x7ddc, 0x7fd0, 0x71d4, 0xd1b4, 0x00f0, 0x7868, 0xa084, 0x00ff,
-	0x11d0, 0xa282, 0x0002, 0x12b8, 0x00d6, 0x783b, 0x8300, 0x781b,
-	0x0059, 0x70bc, 0xa06d, 0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de,
-	0x6898, 0x78d2, 0x78da, 0xc1b4, 0x71d6, 0x7003, 0x0030, 0x00de,
-	0x2001, 0x0000, 0x0058, 0x783b, 0x1300, 0x781b, 0x0057, 0x2001,
-	0x0000, 0x0020, 0x7200, 0x7cd8, 0x7ddc, 0x7fd0, 0x704a, 0x68a0,
-	0xd0ec, 0x0118, 0x6008, 0xc08d, 0x600a, 0xa284, 0x000f, 0x0002,
-	0x2ee0, 0x2dc5, 0x2dc2, 0x3012, 0x3085, 0x248f, 0x2dc0, 0x2dc0,
-	0x080c, 0x243b, 0x6008, 0xc0d4, 0x600a, 0xd6e4, 0x0120, 0x7048,
-	0xa086, 0x0014, 0x11e8, 0x080c, 0x3d52, 0x2009, 0x0000, 0x6818,
-	0xd0fc, 0x0108, 0x7048, 0xa086, 0x0014, 0x0168, 0x6818, 0xa086,
-	0x0008, 0x1904, 0x2ea2, 0x7858, 0xd09c, 0x0904, 0x2ea2, 0x6820,
-	0xd0ac, 0x0904, 0x2ea2, 0x681b, 0x0014, 0x2009, 0x0002, 0x04a8,
-	0x7868, 0xa08c, 0x00ff, 0x0588, 0xa186, 0x0008, 0x1158, 0x6008,
-	0xc0a4, 0x600a, 0x080c, 0x355f, 0x0540, 0x080c, 0x35c5, 0x080c,
-	0x3d52, 0x0060, 0xa186, 0x0028, 0x1500, 0x6018, 0xa005, 0x0d78,
-	0x8001, 0x0d68, 0x8001, 0x0d58, 0x601e, 0x0c48, 0x6820, 0xd084,
-	0x0904, 0x248f, 0xc084, 0x6822, 0x080c, 0x2580, 0x705c, 0x00c6,
-	0x2060, 0x6800, 0x6002, 0x00ce, 0x6004, 0x6802, 0xa005, 0x2d00,
-	0x1108, 0x6002, 0x6006, 0x0804, 0x248f, 0x0016, 0x81ff, 0x15e0,
-	0x7000, 0xa086, 0x0030, 0x05c0, 0x71d4, 0xd1b4, 0x11e8, 0x7060,
-	0xa005, 0x1590, 0x70a4, 0xa086, 0x0001, 0x0570, 0x7003, 0x0000,
-	0x0046, 0x0056, 0x0076, 0x0066, 0x00c6, 0x00d6, 0x080c, 0x24b2,
-	0x00de, 0x00ce, 0x006e, 0x007e, 0x005e, 0x004e, 0x71d4, 0xd1b4,
-	0x11d8, 0x7003, 0x0040, 0x00c0, 0x080c, 0x3a8d, 0x11a8, 0x781b,
-	0x0068, 0x00d6, 0x70bc, 0xa06d, 0x68b4, 0x785a, 0x6894, 0x78d6,
-	0x78de, 0x6898, 0x78d2, 0x78da, 0xc1b4, 0x71d6, 0x7003, 0x0030,
-	0x7808, 0xc08d, 0x780a, 0x00de, 0x080c, 0x2f63, 0x001e, 0x81ff,
-	0x0904, 0x2ea2, 0xa684, 0xdf00, 0x681e, 0x682b, 0x0000, 0x6f14,
-	0xa186, 0x0002, 0x15c0, 0x6818, 0xa086, 0x0014, 0x1130, 0x2008,
-	0xd6e4, 0x0118, 0x7868, 0xa08c, 0x00ff, 0x080c, 0x3850, 0x080c,
-	0x258b, 0x6820, 0xd0dc, 0x1538, 0x8717, 0xa294, 0x000f, 0x8213,
-	0x8213, 0x8213, 0xb284, 0x0600, 0x0118, 0xa290, 0x47c0, 0x0010,
-	0xa290, 0x4840, 0xa290, 0x0000, 0x221c, 0xd3c4, 0x0130, 0x8210,
-	0x2204, 0xa085, 0x0038, 0x2012, 0x8211, 0xd3d4, 0x0138, 0x68a0,
-	0xd0c4, 0x1120, 0x080c, 0x2fcb, 0x0804, 0x248f, 0x6008, 0xc08d,
-	0x600a, 0x0008, 0x692a, 0x6916, 0x6818, 0xd0fc, 0x0110, 0x7048,
-	0x681a, 0xa68c, 0xdf00, 0x691e, 0x6410, 0x84ff, 0x0168, 0x2009,
-	0x4302, 0x2104, 0x8001, 0x200a, 0x8421, 0x6412, 0x1128, 0x2021,
-	0x4304, 0x2404, 0xc0a5, 0x2022, 0x6018, 0xa005, 0x0118, 0x8001,
-	0x601a, 0x1118, 0x6008, 0xc0a4, 0x600a, 0x6820, 0xd084, 0x1130,
-	0x6800, 0xa005, 0x1108, 0x6002, 0x6006, 0x0020, 0x705c, 0x2060,
-	0x6800, 0x6002, 0x2061, 0x4300, 0x6887, 0x0103, 0x2d08, 0x206b,
-	0x0000, 0x6068, 0xa005, 0x616a, 0x0110, 0x2d02, 0x0008, 0x616e,
-	0x7200, 0xa286, 0x0030, 0x0158, 0xa286, 0x0040, 0x1904, 0x248f,
-	0x7003, 0x0002, 0x704c, 0x2068, 0x68c4, 0x2060, 0x0005, 0x7003,
-	0x0002, 0x70bc, 0xa06d, 0x68bc, 0x7042, 0x70b8, 0xa065, 0x68c0,
-	0x705a, 0x2d00, 0x704e, 0xad80, 0x0009, 0x7046, 0x0005, 0xa282,
-	0x0004, 0x0210, 0x080c, 0x243b, 0x2200, 0x0002, 0x2f0a, 0x2f19,
-	0x2f25, 0x2f19, 0xa586, 0x1300, 0x0160, 0xa586, 0x8300, 0x1d90,
-	0x7003, 0x0000, 0x6018, 0x8001, 0x601a, 0x6008, 0xa084, 0xfbef,
-	0x600a, 0x7000, 0xa086, 0x0005, 0x0128, 0x080c, 0x3837, 0x781b,
-	0x0082, 0x0005, 0x781b, 0x0083, 0x0005, 0x7890, 0x8007, 0x8001,
-	0xa084, 0x0007, 0xa080, 0x0018, 0x789a, 0x79a8, 0xa18c, 0x00ff,
-	0xa186, 0x0003, 0x0128, 0xa186, 0x0000, 0x0110, 0x0804, 0x3809,
-	0x781b, 0x0083, 0x0005, 0x6820, 0xc095, 0x6822, 0x82ff, 0x1118,
-	0x080c, 0x3837, 0x0030, 0x8211, 0x0110, 0x080c, 0x243b, 0x080c,
-	0x3846, 0x781b, 0x0082, 0x0005, 0x080c, 0x3aa0, 0x7830, 0xa084,
-	0x00c0, 0x1170, 0x0016, 0x3208, 0xa18c, 0x0800, 0x001e, 0x0118,
-	0x0104, 0x2f60, 0x0010, 0x0304, 0x2f60, 0x791a, 0xa006, 0x0005,
-	0xa085, 0x0001, 0x0005, 0xa684, 0x0060, 0x1130, 0x682f, 0x0000,
-	0x6833, 0x0000, 0x0804, 0x2fca, 0xd6dc, 0x1198, 0x68b4, 0xd0dc,
-	0x1180, 0x6998, 0x6a94, 0x692e, 0x6a32, 0x7048, 0xa005, 0x1130,
-	0x2200, 0xa105, 0x0904, 0x3d52, 0x704b, 0x0015, 0x0804, 0x3d52,
-	0x0005, 0xd6ac, 0x01f0, 0xd6f4, 0x0130, 0x682f, 0x0000, 0x6833,
-	0x0000, 0x0804, 0x3d52, 0x68b4, 0xa084, 0x4000, 0xa635, 0xd6f4,
-	0x1da0, 0x7048, 0xa005, 0x1110, 0x704b, 0x0015, 0xd6dc, 0x1128,
-	0x68b4, 0xd0dc, 0x0110, 0x6ca8, 0x6da4, 0x6c2e, 0x6d32, 0x0804,
-	0x3d52, 0xd6f4, 0x0130, 0x682f, 0x0000, 0x6833, 0x0000, 0x0804,
-	0x3d52, 0x68b4, 0xa084, 0x4800, 0xa635, 0xd6f4, 0x1da0, 0x7048,
-	0xa005, 0x1110, 0x704b, 0x0015, 0x2408, 0x2510, 0x2700, 0x8007,
-	0xa084, 0x007f, 0xa108, 0xa291, 0x0000, 0x692e, 0x6a32, 0x2100,
-	0xa205, 0x1110, 0x0804, 0x3d52, 0x7000, 0xa086, 0x0006, 0x0110,
-	0x0804, 0x3d52, 0x0005, 0x6946, 0x6008, 0xc0cd, 0xd3cc, 0x0108,
-	0xc08d, 0x600a, 0x6818, 0x683a, 0x681b, 0x0006, 0x688f, 0x0000,
-	0x6893, 0x0000, 0x6a30, 0x692c, 0x6a3e, 0x6942, 0x682f, 0x0003,
-	0x6833, 0x0000, 0x6837, 0x0020, 0x6897, 0x0000, 0x689b, 0x0020,
-	0x7000, 0x0002, 0x248f, 0x2ffa, 0x2ff4, 0x2ff2, 0x2ff2, 0x2ff2,
-	0x2ff2, 0x2ff2, 0x080c, 0x243b, 0x6820, 0xd084, 0x1118, 0x080c,
-	0x35ab, 0x0030, 0x705c, 0x2c50, 0x2060, 0x6800, 0x6002, 0x2a60,
-	0x3208, 0xa18c, 0x0600, 0x0118, 0x2021, 0x4358, 0x0010, 0x2021,
-	0x4398, 0x2404, 0xa005, 0x0110, 0x2020, 0x0cd8, 0x2d22, 0x206b,
-	0x0000, 0x0005, 0x080c, 0x35b1, 0x080c, 0x35c5, 0x6008, 0xc0cc,
-	0x600a, 0x682b, 0x0000, 0x789b, 0x000e, 0x6f14, 0x6938, 0x691a,
-	0x6944, 0x6916, 0x3208, 0xa18c, 0x0600, 0x0118, 0x2009, 0x0000,
-	0x0010, 0x2009, 0x0001, 0x080c, 0x40b1, 0xd6dc, 0x0118, 0x691c,
-	0xc1ed, 0x691e, 0x6818, 0xd0fc, 0x0148, 0x7868, 0xa08c, 0x00ff,
-	0x0118, 0x681b, 0x001e, 0x0010, 0x681b, 0x0000, 0xb284, 0x0600,
-	0x1118, 0x2021, 0x4398, 0x0010, 0x2021, 0x4358, 0x6800, 0x2022,
-	0x6a3c, 0x6940, 0x6a32, 0x692e, 0x68c0, 0x2060, 0x6000, 0xd0a4,
-	0x0580, 0x2041, 0x0021, 0x2049, 0x0005, 0x2051, 0x0020, 0x00d6,
-	0x00f6, 0x0156, 0x0146, 0x2079, 0x4300, 0x080c, 0x1b35, 0x014e,
-	0x015e, 0x00fe, 0x70cc, 0x2010, 0x2009, 0x0101, 0x0026, 0x2204,
-	0xa06d, 0x0140, 0x6814, 0xa706, 0x0110, 0x6800, 0x0cc8, 0x6820,
-	0xc0d5, 0x6822, 0x002e, 0x8210, 0x8109, 0x1d80, 0x00de, 0x7067,
-	0x0003, 0x707f, 0x0000, 0x7776, 0x7083, 0x000f, 0x71d4, 0xc1c4,
-	0x71d6, 0x080c, 0x1d3d, 0x0804, 0x248f, 0x7cd8, 0x7ddc, 0x7fd0,
-	0x080c, 0x2f63, 0x682b, 0x0000, 0x789b, 0x000e, 0x6f14, 0x080c,
-	0x3aa4, 0xa08c, 0x00ff, 0x6916, 0x6818, 0xd0fc, 0x0110, 0x7048,
-	0x681a, 0xa68c, 0xdf00, 0x691e, 0x7067, 0x0000, 0x0804, 0x248f,
-	0x7000, 0xa005, 0x1110, 0x0804, 0x248f, 0xa006, 0x080c, 0x3d52,
-	0x6920, 0xd1ac, 0x1110, 0x681b, 0x0014, 0xa68c, 0xdf00, 0x691e,
-	0x682b, 0x0000, 0x6820, 0xa084, 0x00ff, 0x6822, 0x7000, 0x0002,
-	0x248f, 0x30c2, 0x30c2, 0x30c5, 0x30c5, 0x30c5, 0x30c0, 0x30c0,
-	0x080c, 0x243b, 0x6818, 0x0804, 0x2daa, 0x6008, 0xc0a4, 0x600a,
-	0x6817, 0x0000, 0x0804, 0x357a, 0x2300, 0x0002, 0x30d1, 0x30d3,
-	0x3110, 0x080c, 0x243b, 0xd6fc, 0x1904, 0x2bee, 0x7000, 0xa00d,
-	0x0002, 0x248f, 0x30e3, 0x30e3, 0x3104, 0x30e3, 0x310d, 0x30e1,
-	0x30e1, 0x080c, 0x243b, 0xa684, 0x0060, 0xa086, 0x0060, 0x11d0,
-	0xc6ac, 0xc6f4, 0xc6ed, 0x7e5a, 0x681c, 0xc0ac, 0x681e, 0xa186,
-	0x0002, 0x0110, 0x080c, 0x3d52, 0x080c, 0x3fb8, 0x781b, 0x0083,
-	0x71d4, 0xd1b4, 0x1904, 0x248c, 0x70a4, 0xa086, 0x0001, 0x1904,
-	0x24ce, 0x0005, 0xd6ec, 0x0d30, 0x6818, 0xd0fc, 0x0130, 0x681b,
-	0x0015, 0xd6f4, 0x0110, 0x681b, 0x0007, 0x080c, 0x3a4b, 0x0005,
-	0x080c, 0x243b, 0x2300, 0x0002, 0x3119, 0x3134, 0x3182, 0x080c,
-	0x243b, 0x7000, 0x0002, 0x3123, 0x3125, 0x3125, 0x3123, 0x3123,
-	0x3123, 0x3123, 0x3123, 0x080c, 0x243b, 0x080c, 0x3fb8, 0x681c,
-	0xc0b4, 0x681e, 0x70d4, 0xd0b4, 0x1904, 0x248c, 0x70a4, 0xa086,
-	0x0001, 0x1904, 0x24ce, 0x0005, 0xd6fc, 0x15e0, 0x7000, 0xa00d,
-	0x0002, 0x248f, 0x3149, 0x3143, 0x316a, 0x3149, 0x316f, 0x3141,
-	0x3141, 0x080c, 0x243b, 0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2,
-	0x78da, 0xa684, 0x0060, 0xa086, 0x0060, 0x11d0, 0xa6b4, 0xbfbf,
-	0xc6ed, 0x7e5a, 0xa186, 0x0002, 0x0110, 0x080c, 0x3d52, 0x080c,
-	0x3fb8, 0x781b, 0x0083, 0x681c, 0xc0b4, 0x681e, 0x71d4, 0xd1b4,
-	0x1904, 0x248c, 0x70a4, 0xa086, 0x0001, 0x1904, 0x24ce, 0x0005,
-	0xd6ec, 0x0d30, 0x6818, 0xd0fc, 0x0110, 0x681b, 0x0007, 0x781b,
-	0x00fb, 0x0005, 0xc6fc, 0x7e5a, 0x7adc, 0x79d8, 0x6b98, 0x2100,
-	0xa302, 0x68b2, 0x6b94, 0x2200, 0xa303, 0x68ae, 0x79d2, 0x781b,
-	0x0083, 0x0005, 0xd6dc, 0x0130, 0x782b, 0x3009, 0x781b, 0x0083,
-	0x0804, 0x248c, 0x7884, 0xc0ac, 0x7886, 0x78e4, 0xa084, 0x0008,
-	0x1150, 0xa484, 0x0200, 0x0108, 0xc6f5, 0xc6dd, 0x7e5a, 0x781b,
-	0x0083, 0x0804, 0x248c, 0x6820, 0xc095, 0x6822, 0x080c, 0x39ca,
-	0xc6dd, 0x080c, 0x3837, 0x781b, 0x0082, 0x0804, 0x248c, 0x2300,
-	0x0002, 0x31ac, 0x31ae, 0x31b0, 0x080c, 0x243b, 0x0804, 0x3831,
-	0x7d98, 0xd6d4, 0x11f8, 0x79e4, 0xd1ac, 0x0130, 0x78ec, 0xa084,
-	0x0003, 0x0110, 0x782b, 0x3009, 0x789b, 0x0060, 0x78ab, 0x0000,
-	0xa684, 0xfffb, 0x785a, 0x7d9a, 0x79e4, 0xd1ac, 0x0120, 0x78ec,
-	0xa084, 0x0003, 0x1120, 0x2001, 0x0014, 0x0804, 0x2daa, 0xa184,
-	0x0007, 0x04c2, 0x7a90, 0xa294, 0x0007, 0x789b, 0x0060, 0x79a8,
-	0x81ff, 0x0568, 0x789b, 0x0080, 0x7ba8, 0xa384, 0x0001, 0x11d0,
-	0x7ba8, 0x7ba8, 0xa386, 0x0004, 0x1118, 0x2009, 0xffdf, 0x0058,
-	0xa386, 0x0001, 0x1118, 0x2009, 0xfff7, 0x0028, 0xa386, 0x0003,
-	0x1148, 0x2009, 0xffef, 0x00c6, 0x7058, 0x2060, 0x6004, 0xa104,
-	0x6006, 0x00ce, 0x789b, 0x0060, 0x78ab, 0x0000, 0xa684, 0xfffb,
-	0x785a, 0x782b, 0x3009, 0x6920, 0xa18c, 0xecff, 0x6922, 0x7d9a,
-	0x0804, 0x3a3f, 0x2a9f, 0x2aa8, 0x3214, 0x321a, 0x3212, 0x3212,
-	0x3a3f, 0x3a3f, 0x080c, 0x243b, 0x6920, 0xa18c, 0xfcff, 0x6922,
-	0x0804, 0x3a45, 0x6920, 0xa18c, 0xfcff, 0x6922, 0x0804, 0x3a3f,
-	0x79e4, 0xa184, 0x0030, 0x0120, 0x78ec, 0xa084, 0x0003, 0x1558,
-	0x7000, 0xa086, 0x0004, 0x1190, 0x7064, 0xa086, 0x0002, 0x1130,
-	0x2011, 0x0002, 0x2019, 0x0000, 0x0804, 0x295c, 0x7064, 0xa086,
-	0x0006, 0x0db0, 0x7064, 0xa086, 0x0004, 0x0d90, 0x7000, 0xa086,
-	0x0000, 0x0904, 0x248c, 0x6920, 0xa184, 0x0420, 0x0128, 0xc1d4,
-	0x6922, 0x6818, 0x0804, 0x2daa, 0x6818, 0xc0fd, 0x681a, 0x2001,
-	0x0014, 0x0804, 0x2daa, 0xa184, 0x0007, 0x0002, 0x3a3f, 0x3a3f,
-	0x325e, 0x3a3f, 0x3a83, 0x3a83, 0x3a3f, 0x3a3f, 0xd6bc, 0x0570,
-	0x7184, 0x81ff, 0x0558, 0xa182, 0x000d, 0x1318, 0x7087, 0x0000,
-	0x0028, 0xa182, 0x000c, 0x7086, 0x2009, 0x000c, 0x789b, 0x0061,
-	0x79aa, 0x0156, 0x0136, 0x0146, 0x7088, 0x8114, 0xa210, 0x728a,
-	0xa080, 0x000b, 0xad00, 0x2098, 0xb284, 0x0600, 0x0118, 0x20a1,
-	0x022b, 0x0010, 0x20a1, 0x012b, 0x789b, 0x0000, 0x8108, 0x81ac,
-	0x53a6, 0x014e, 0x013e, 0x015e, 0x0804, 0x3a45, 0xd6d4, 0x1904,
-	0x32d1, 0x6820, 0xd084, 0x0904, 0x3a45, 0xa68c, 0x0060, 0xa684,
-	0x0060, 0x0120, 0xa086, 0x0060, 0x1108, 0xc1f5, 0xc194, 0x795a,
-	0x69b6, 0x789b, 0x0060, 0x78ab, 0x0000, 0x789b, 0x0061, 0x6818,
-	0xc0fd, 0x681a, 0x78aa, 0x8008, 0x810c, 0x0904, 0x35da, 0xa18c,
-	0x00f8, 0x1904, 0x35da, 0x0156, 0x0136, 0x0146, 0x0016, 0x20a1,
-	0x012b, 0x3208, 0xa18c, 0x0600, 0x0110, 0x20a1, 0x022b, 0x001e,
-	0x789b, 0x0000, 0x8000, 0x80ac, 0xad80, 0x000b, 0x2098, 0x53a6,
-	0x014e, 0x013e, 0x015e, 0x6814, 0xc0fc, 0x8007, 0x7882, 0x0804,
-	0x3a45, 0x6818, 0xd0fc, 0x0110, 0x681b, 0x0008, 0x080c, 0x3837,
-	0x781b, 0x00ed, 0x0005, 0x2300, 0x0002, 0x32e2, 0x3398, 0x32e0,
-	0x080c, 0x243b, 0x7cd8, 0x7ddc, 0x7fd0, 0x82ff, 0x11f0, 0x7200,
-	0xa286, 0x0003, 0x0904, 0x2d7f, 0x71d4, 0xd1b4, 0x00c0, 0x00d6,
-	0x783b, 0x8800, 0x781b, 0x0059, 0x70bc, 0xa06d, 0x68b4, 0xc0a5,
-	0x785a, 0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0xc1b4,
-	0x71d6, 0x7003, 0x0030, 0x00de, 0x0030, 0x7200, 0x0020, 0x783b,
-	0x1800, 0x781b, 0x0057, 0xa284, 0x000f, 0x0002, 0x3383, 0x3344,
-	0x3318, 0x2da7, 0x3316, 0x3383, 0x3316, 0x3316, 0x080c, 0x243b,
-	0x681c, 0xd0ec, 0x0118, 0x6008, 0xc08d, 0x600a, 0x6920, 0xc185,
-	0x6922, 0x6800, 0x6006, 0xa005, 0x1108, 0x6002, 0x6008, 0xc0d4,
-	0x600a, 0x681c, 0xa084, 0x000e, 0x1148, 0xb284, 0x0600, 0x0118,
-	0x2009, 0x89c0, 0x0040, 0x2009, 0x8ad0, 0x0028, 0x7030, 0x68ba,
-	0x7140, 0x70cc, 0xa108, 0x2104, 0x6802, 0x2d0a, 0x715e, 0xd6dc,
-	0x1118, 0xc6fc, 0x6eb6, 0x04f8, 0x6eb6, 0xa684, 0x0060, 0x05d8,
+	0xa084, 0x00ff, 0xa205, 0x6822, 0x080c, 0x1d89, 0x2021, 0x4502,
+	0x241c, 0x8319, 0x2322, 0x6010, 0x8001, 0x6012, 0x1128, 0x2021,
+	0x4504, 0x2404, 0xc0a5, 0x2022, 0x6008, 0xa084, 0xf9ef, 0x600a,
+	0x080c, 0x267d, 0x080c, 0x3786, 0x0005, 0xa085, 0x0001, 0x0ce0,
+	0x2300, 0x0002, 0x2b47, 0x2b45, 0x2bad, 0x080c, 0x252b, 0x78e4,
+	0xa005, 0x1708, 0x3208, 0xa18c, 0x0800, 0x0118, 0x0104, 0x257c,
+	0x0010, 0x0304, 0x257c, 0x2008, 0xa084, 0x0030, 0x1110, 0x0804,
+	0x31c5, 0x78ec, 0xa084, 0x0003, 0x0dd0, 0x2100, 0xa084, 0x0007,
+	0x0002, 0x2b90, 0x2b99, 0x2b86, 0x2b69, 0x3bef, 0x3bef, 0x2b69,
+	0x2ba3, 0x080c, 0x252b, 0x7000, 0xa086, 0x0004, 0x1190, 0x7060,
+	0xa086, 0x0002, 0x1130, 0x2011, 0x0002, 0x2019, 0x0000, 0x0804,
+	0x2a4d, 0x7060, 0xa086, 0x0006, 0x0db0, 0x7060, 0xa086, 0x0004,
+	0x0d90, 0x79e4, 0x2001, 0x0003, 0x0804, 0x2ea4, 0x6818, 0xd0fc,
+	0x0110, 0x681b, 0x001d, 0x080c, 0x39ff, 0x781b, 0x006e, 0x0005,
+	0x6818, 0xd0fc, 0x0110, 0x681b, 0x001d, 0x080c, 0x39ff, 0x0804,
+	0x3bcd, 0x6818, 0xd0fc, 0x0110, 0x681b, 0x001d, 0x080c, 0x39ff,
+	0x781b, 0x00fa, 0x0005, 0x6818, 0xd0fc, 0x0110, 0x681b, 0x001d,
+	0x080c, 0x39ff, 0x781b, 0x00cb, 0x0005, 0xa584, 0x000f, 0x11c0,
+	0x7000, 0x0002, 0x257f, 0x2bba, 0x2bbc, 0x3725, 0x3725, 0x3725,
+	0x2bba, 0x2bba, 0x080c, 0x252b, 0x080c, 0x3786, 0x6008, 0xa084,
+	0xfbef, 0x600a, 0x080c, 0x3717, 0x0904, 0x3725, 0x0804, 0x257f,
+	0x78e4, 0xa005, 0x1b04, 0x2b6b, 0x3208, 0xa18c, 0x0800, 0x0118,
+	0x0104, 0x2b6b, 0x0010, 0x0304, 0x2b6b, 0x2008, 0xa084, 0x0030,
+	0x1118, 0x781b, 0x0068, 0x0005, 0x78ec, 0xa084, 0x0003, 0x0dc8,
+	0x2100, 0xa184, 0x0007, 0x0002, 0x2bf3, 0x2bf7, 0x2bee, 0x2bec,
+	0x3bef, 0x3bef, 0x2bec, 0x3be9, 0x080c, 0x252b, 0x080c, 0x3a05,
+	0x781b, 0x006e, 0x0005, 0x080c, 0x3a05, 0x0804, 0x3bcd, 0x080c,
+	0x3a05, 0x781b, 0x00fa, 0x0005, 0x080c, 0x3a05, 0x781b, 0x00cb,
+	0x0005, 0x2300, 0x0002, 0x2c08, 0x2c06, 0x2c0a, 0x080c, 0x252b,
+	0x0804, 0x3361, 0x681b, 0x0016, 0x78a3, 0x0000, 0x79e4, 0xa184,
+	0x0030, 0x0904, 0x3361, 0x78ec, 0xa084, 0x0003, 0x0904, 0x3361,
+	0xa184, 0x0100, 0x0d98, 0xa184, 0x0007, 0x0002, 0x2c26, 0x2bf7,
+	0x2b86, 0x3bab, 0x3bef, 0x3bef, 0x3bab, 0x3be9, 0x080c, 0x3bb7,
+	0x0005, 0xa282, 0x0005, 0x0310, 0x080c, 0x252b, 0x7898, 0x2040,
+	0x2300, 0x0002, 0x2c35, 0x2e34, 0x2e3e, 0x2200, 0x0002, 0x2c51,
+	0x2c3e, 0x2c51, 0x2c3c, 0x2e16, 0x080c, 0x252b, 0x789b, 0x0018,
+	0x78a8, 0x2010, 0xa084, 0x00ff, 0xa082, 0x0020, 0x0a04, 0x39d0,
+	0xa08a, 0x0004, 0x1a04, 0x39d0, 0x0002, 0x39d0, 0x39d0, 0x39d0,
+	0x3986, 0x789b, 0x0018, 0x79a8, 0xa184, 0x0080, 0x0148, 0x0804,
+	0x39d0, 0x7000, 0xa005, 0x1dd8, 0x2011, 0x0004, 0x0804, 0x3502,
+	0xa184, 0x00ff, 0xa08a, 0x0010, 0x1a04, 0x39d0, 0x0002, 0x2c79,
+	0x2c77, 0x2c8b, 0x2c8f, 0x2d2d, 0x39d0, 0x39d0, 0x2d2f, 0x39d0,
+	0x39d0, 0x2e12, 0x2e12, 0x39d0, 0x39d0, 0x39d0, 0x2e14, 0x080c,
+	0x252b, 0xd6e4, 0x0140, 0x2001, 0x0300, 0x8000, 0x8000, 0x783a,
+	0x781b, 0x00c7, 0x0005, 0x6818, 0xd0fc, 0x0118, 0x681b, 0x001d,
+	0x0c90, 0x0804, 0x3bab, 0x681b, 0x001d, 0x0804, 0x39f9, 0x6920,
+	0x6922, 0xa684, 0x1800, 0x15e0, 0x6820, 0xd084, 0x1904, 0x2cd8,
+	0x6818, 0xa086, 0x0008, 0x1110, 0x681b, 0x0000, 0xd6d4, 0x0568,
+	0xd6bc, 0x0558, 0x7083, 0x0000, 0x6818, 0xa084, 0x003f, 0xa08a,
+	0x000d, 0x0718, 0xa08a, 0x000c, 0x7182, 0x2001, 0x000c, 0x800c,
+	0x7186, 0x789b, 0x0061, 0x78aa, 0x0156, 0x0136, 0x0146, 0x0016,
+	0x3208, 0xa18c, 0x0600, 0x0118, 0x20a1, 0x022b, 0x0010, 0x20a1,
+	0x012b, 0x001e, 0x789b, 0x0000, 0x8000, 0x80ac, 0xad80, 0x000b,
+	0x2098, 0x53a6, 0x014e, 0x013e, 0x015e, 0x781b, 0x0071, 0x0005,
+	0xd6e4, 0x0130, 0x781b, 0x0083, 0x0005, 0x781b, 0x0083, 0x0005,
+	0xa684, 0x0060, 0x0dd0, 0xd6dc, 0x0dc0, 0xd6fc, 0x01a0, 0xc6fc,
+	0x7e5a, 0x6eb6, 0x7adc, 0x79d8, 0x78d0, 0x8007, 0xa084, 0x007f,
+	0xa108, 0xa291, 0x0000, 0x6b98, 0x2100, 0xa302, 0x68b2, 0x6b94,
+	0x2200, 0xa303, 0x68ae, 0xd6f4, 0x0118, 0xc6f4, 0x7e5a, 0x6eb6,
+	0x7000, 0xa086, 0x0003, 0x1148, 0x0006, 0x080c, 0x3ed9, 0x080c,
+	0x4180, 0x000e, 0x781b, 0x0080, 0x0005, 0xa006, 0x080c, 0x425d,
+	0x6ab0, 0x69ac, 0x6c98, 0x6b94, 0x2200, 0xa105, 0x0120, 0x2200,
+	0xa422, 0x2100, 0xa31b, 0x6caa, 0x7cd2, 0x7cda, 0x6ba6, 0x7bd6,
+	0x7bde, 0x2300, 0xa405, 0x1130, 0xc6f5, 0x7e5a, 0x6eb6, 0x781b,
+	0x0080, 0x0005, 0x781b, 0x0080, 0x2200, 0xa115, 0x1118, 0x080c,
+	0x4180, 0x0005, 0x080c, 0x41ad, 0x0005, 0x080c, 0x252b, 0x0804,
+	0x2dae, 0x00c6, 0x7054, 0x2060, 0x7aa8, 0xa294, 0x00ff, 0xa286,
+	0x0004, 0x11d8, 0x6920, 0xd1e4, 0x1170, 0x2039, 0x0000, 0x2041,
+	0x0000, 0x2031, 0x0000, 0xa006, 0x2010, 0x080c, 0x38bd, 0x080c,
+	0x3961, 0x0804, 0x2da2, 0xa18c, 0xecff, 0x6922, 0x6104, 0xa18c,
+	0xffdd, 0x6106, 0x6000, 0xc0ac, 0x6002, 0xa286, 0x0003, 0x01d0,
+	0x6104, 0xa184, 0x0010, 0x0548, 0x080c, 0x3b31, 0x080c, 0x393d,
+	0x88ff, 0x0518, 0x00ce, 0x789b, 0x0060, 0x2800, 0x78aa, 0x7e58,
+	0xc695, 0x7e5a, 0xd6d4, 0x1118, 0x781b, 0x006e, 0x0005, 0x781b,
+	0x0082, 0x0005, 0x6920, 0xd1cc, 0x0130, 0xa18c, 0xfdff, 0x6922,
+	0x6000, 0xc0ec, 0x6002, 0x2039, 0x0000, 0x2041, 0x0000, 0x2031,
+	0x0000, 0xa006, 0x2010, 0x080c, 0x3961, 0xa286, 0x0001, 0x0158,
+	0x6104, 0xa184, 0x0008, 0x01b0, 0x080c, 0x3b31, 0x080c, 0x385d,
+	0x88ff, 0x1980, 0x0078, 0x6920, 0xd1c4, 0x0130, 0xa18c, 0xfeff,
+	0x6922, 0x6000, 0xc0e4, 0x6002, 0x2031, 0x0000, 0xa006, 0x2010,
+	0x080c, 0x38bd, 0x00ce, 0x7e58, 0xd6d4, 0x1118, 0x781b, 0x0071,
+	0x0005, 0x781b, 0x0083, 0x0005, 0x0804, 0x39f5, 0x2808, 0x789b,
+	0x0080, 0x2019, 0x0080, 0x78a8, 0xa094, 0x00ff, 0xa286, 0x0001,
+	0x1188, 0x7ca8, 0xa4a4, 0x00ff, 0xa480, 0x0002, 0xa300, 0x2018,
+	0xa102, 0x0a04, 0x2d31, 0x0904, 0x2d31, 0x24a8, 0x7aa8, 0x1f04,
+	0x2dc6, 0x0c48, 0xa284, 0x00f0, 0xa082, 0x0020, 0x06b8, 0x2200,
+	0xa082, 0x0021, 0x1698, 0x7aa8, 0x8318, 0x8318, 0x2100, 0xa302,
+	0x0ad0, 0xa286, 0x0023, 0x0980, 0x681c, 0xa084, 0xfff1, 0x681e,
+	0x7e58, 0xa684, 0xfff1, 0xc0a5, 0x2030, 0x7e5a, 0x6008, 0xc0a5,
+	0x600a, 0x78a0, 0x8001, 0x0904, 0x2da2, 0x20a8, 0x7998, 0x789b,
+	0x0060, 0x78aa, 0x2011, 0x0080, 0x799a, 0x78a8, 0x7998, 0x7a9a,
+	0x78aa, 0x7a98, 0x1f04, 0x2df4, 0xc695, 0x7e5a, 0xd6d4, 0x1118,
+	0x781b, 0x006e, 0x0005, 0x781b, 0x0082, 0x0005, 0x8318, 0x2100,
+	0xa302, 0x0a04, 0x2db3, 0xa284, 0x0080, 0x1904, 0x39f9, 0x78a0,
+	0xa005, 0x08c8, 0x0804, 0x39f9, 0x0804, 0x39d0, 0x7054, 0xa04d,
+	0x789b, 0x0018, 0x78a8, 0xa084, 0x00ff, 0xa08e, 0x0001, 0x0110,
+	0x080c, 0x252b, 0x7aa8, 0xa294, 0x00ff, 0x784b, 0x0008, 0x78a8,
+	0xa084, 0x00ff, 0xa08a, 0x0005, 0x1a04, 0x39d0, 0x0002, 0x39d0,
+	0x37d4, 0x39d0, 0x38ed, 0x3cef, 0xa282, 0x0000, 0x1110, 0x080c,
+	0x252b, 0x080c, 0x39ff, 0x781b, 0x0082, 0x0005, 0xa282, 0x0003,
+	0x1110, 0x080c, 0x252b, 0xd4fc, 0x11d0, 0x7060, 0xa005, 0x0110,
+	0x080c, 0x252b, 0x6f14, 0x7772, 0xa7bc, 0x8f00, 0x080c, 0x3b35,
+	0x6008, 0xa085, 0x0021, 0x600a, 0x8738, 0xa784, 0x001f, 0x1db0,
+	0x080c, 0x3a02, 0x7063, 0x0002, 0x701f, 0x0009, 0x0010, 0x080c,
+	0x3a0e, 0x781b, 0x0082, 0x0005, 0xa282, 0x0004, 0x0310, 0x080c,
+	0x252b, 0x2300, 0x0002, 0x2e6e, 0x3004, 0x3040, 0xa286, 0x0003,
+	0x0598, 0x7200, 0x7cd8, 0x7ddc, 0x7fd0, 0x71d0, 0xd1bc, 0x1528,
+	0xd1b4, 0x0518, 0x2001, 0x4501, 0x2004, 0xd0c4, 0x11f0, 0x7868,
+	0xa084, 0x00ff, 0x11d0, 0xa282, 0x0002, 0x12b8, 0x00d6, 0x783b,
+	0x8300, 0x781b, 0x0059, 0x70b8, 0xa06d, 0x68b4, 0x785a, 0x6894,
+	0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0xc1b4, 0x71d2, 0x7003,
+	0x0030, 0x00de, 0x2001, 0x0000, 0x0058, 0x783b, 0x1300, 0x781b,
+	0x0057, 0x2001, 0x0000, 0x0020, 0x7200, 0x7cd8, 0x7ddc, 0x7fd0,
+	0x7046, 0x68a0, 0xd0ec, 0x0118, 0x6008, 0xc08d, 0x600a, 0xa284,
+	0x000f, 0x0002, 0x2fe5, 0x2ebf, 0x2ebc, 0x3117, 0x31aa, 0x257f,
+	0x2eba, 0x2eba, 0x080c, 0x252b, 0x6008, 0xc0d4, 0x600a, 0xd6e4,
+	0x0120, 0x7044, 0xa086, 0x0014, 0x11e8, 0x080c, 0x3ed9, 0x2009,
+	0x0000, 0x6818, 0xd0fc, 0x0108, 0x7044, 0xa086, 0x0014, 0x0168,
+	0x6818, 0xa086, 0x0008, 0x1904, 0x2fa7, 0x7858, 0xd09c, 0x0904,
+	0x2fa7, 0x6820, 0xd0ac, 0x0904, 0x2fa7, 0x681b, 0x0014, 0x2009,
+	0x0002, 0x04a8, 0x7868, 0xa08c, 0x00ff, 0x0588, 0xa186, 0x0008,
+	0x1158, 0x6008, 0xc0a4, 0x600a, 0x080c, 0x3717, 0x0540, 0x080c,
+	0x3786, 0x080c, 0x3ed9, 0x0060, 0xa186, 0x0028, 0x1500, 0x6018,
+	0xa005, 0x0d78, 0x8001, 0x0d68, 0x8001, 0x0d58, 0x601e, 0x0c48,
+	0x6820, 0xd084, 0x0904, 0x257f, 0xc084, 0x6822, 0x080c, 0x2672,
+	0x7058, 0x00c6, 0x2060, 0x6800, 0x6002, 0x00ce, 0x6004, 0x6802,
+	0xa005, 0x2d00, 0x1108, 0x6002, 0x6006, 0x0804, 0x257f, 0x0016,
+	0x81ff, 0x15f0, 0x7000, 0xa086, 0x0030, 0x05d0, 0x71d0, 0xd1bc,
+	0x15b8, 0xd1b4, 0x11e8, 0x705c, 0xa005, 0x1590, 0x70a0, 0xa086,
+	0x0001, 0x0570, 0x7003, 0x0000, 0x0046, 0x0056, 0x0076, 0x0066,
+	0x00c6, 0x00d6, 0x080c, 0x25a4, 0x00de, 0x00ce, 0x006e, 0x007e,
+	0x005e, 0x004e, 0x71d0, 0xd1b4, 0x11d8, 0x7003, 0x0040, 0x00c0,
+	0x080c, 0x3bf9, 0x11a8, 0x781b, 0x0068, 0x00d6, 0x70b8, 0xa06d,
+	0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da,
+	0xc1b4, 0x71d2, 0x7003, 0x0030, 0x7808, 0xc08d, 0x780a, 0x00de,
+	0x080c, 0x3068, 0x001e, 0x81ff, 0x0904, 0x2fa7, 0xa684, 0xdf00,
+	0x681e, 0x682b, 0x0000, 0x6f14, 0xa186, 0x0002, 0x1904, 0x2fa8,
+	0x6818, 0xa086, 0x0014, 0x1130, 0x2008, 0xd6e4, 0x0118, 0x7868,
+	0xa08c, 0x00ff, 0x080c, 0x3a18, 0x080c, 0x267d, 0x6820, 0xd0dc,
+	0x1578, 0x8717, 0xa294, 0x000f, 0x8213, 0x8213, 0x8213, 0xb284,
+	0x0600, 0x0118, 0xa290, 0x49c0, 0x0010, 0xa290, 0x4a40, 0xa290,
+	0x0000, 0x221c, 0xd3c4, 0x0170, 0x6820, 0xd0e4, 0x0128, 0xa084,
+	0xefff, 0x6822, 0xc3ac, 0x2312, 0x8210, 0x2204, 0xa085, 0x0038,
+	0x2012, 0x8211, 0xd3d4, 0x0138, 0x68a0, 0xd0c4, 0x1120, 0x080c,
+	0x30d0, 0x0804, 0x257f, 0x6008, 0xc08d, 0x600a, 0x0008, 0x692a,
+	0x6916, 0x6818, 0xd0fc, 0x0110, 0x7044, 0x681a, 0xa68c, 0xdf00,
+	0x691e, 0x6410, 0x84ff, 0x0168, 0x2009, 0x4502, 0x2104, 0x8001,
+	0x200a, 0x8421, 0x6412, 0x1128, 0x2021, 0x4504, 0x2404, 0xc0a5,
+	0x2022, 0x6018, 0xa005, 0x0118, 0x8001, 0x601a, 0x1118, 0x6008,
+	0xc0a4, 0x600a, 0x6820, 0xd084, 0x1130, 0x6800, 0xa005, 0x1108,
+	0x6002, 0x6006, 0x0020, 0x7058, 0x2060, 0x6800, 0x6002, 0x2061,
+	0x4500, 0x6887, 0x0103, 0x2d08, 0x206b, 0x0000, 0x6068, 0xa005,
+	0x616a, 0x0110, 0x2d02, 0x0008, 0x616e, 0x7200, 0xa286, 0x0030,
+	0x0158, 0xa286, 0x0040, 0x1904, 0x257f, 0x7003, 0x0002, 0x7048,
+	0x2068, 0x68c4, 0x2060, 0x0005, 0x7003, 0x0002, 0x70b8, 0xa06d,
+	0x68bc, 0x703e, 0x70b4, 0xa065, 0x68c0, 0x7056, 0x2d00, 0x704a,
+	0xad80, 0x0009, 0x7042, 0x0005, 0xa282, 0x0004, 0x0210, 0x080c,
+	0x252b, 0x2200, 0x0002, 0x300f, 0x301e, 0x302a, 0x301e, 0xa586,
+	0x1300, 0x0160, 0xa586, 0x8300, 0x1d90, 0x7003, 0x0000, 0x6018,
+	0x8001, 0x601a, 0x6008, 0xa084, 0xfbef, 0x600a, 0x7000, 0xa086,
+	0x0005, 0x0128, 0x080c, 0x39ff, 0x781b, 0x0082, 0x0005, 0x781b,
+	0x0083, 0x0005, 0x7890, 0x8007, 0x8001, 0xa084, 0x0007, 0xa080,
+	0x0018, 0x789a, 0x79a8, 0xa18c, 0x00ff, 0xa186, 0x0003, 0x0128,
+	0xa186, 0x0000, 0x0110, 0x0804, 0x39d0, 0x781b, 0x0083, 0x0005,
+	0x6820, 0xc095, 0x6822, 0x82ff, 0x1118, 0x080c, 0x39ff, 0x0030,
+	0x8211, 0x0110, 0x080c, 0x252b, 0x080c, 0x3a0e, 0x781b, 0x0082,
+	0x0005, 0x080c, 0x3c0c, 0x7830, 0xa084, 0x00c0, 0x1170, 0x0016,
+	0x3208, 0xa18c, 0x0800, 0x001e, 0x0118, 0x0104, 0x3065, 0x0010,
+	0x0304, 0x3065, 0x791a, 0xa006, 0x0005, 0xa085, 0x0001, 0x0005,
+	0xa684, 0x0060, 0x1130, 0x682f, 0x0000, 0x6833, 0x0000, 0x0804,
+	0x30cf, 0xd6dc, 0x1198, 0x68b4, 0xd0dc, 0x1180, 0x6998, 0x6a94,
+	0x692e, 0x6a32, 0x7044, 0xa005, 0x1130, 0x2200, 0xa105, 0x0904,
+	0x3ed9, 0x7047, 0x0015, 0x0804, 0x3ed9, 0x0005, 0xd6ac, 0x01f0,
+	0xd6f4, 0x0130, 0x682f, 0x0000, 0x6833, 0x0000, 0x0804, 0x3ed9,
+	0x68b4, 0xa084, 0x4000, 0xa635, 0xd6f4, 0x1da0, 0x7044, 0xa005,
+	0x1110, 0x7047, 0x0015, 0xd6dc, 0x1128, 0x68b4, 0xd0dc, 0x0110,
+	0x6ca8, 0x6da4, 0x6c2e, 0x6d32, 0x0804, 0x3ed9, 0xd6f4, 0x0130,
+	0x682f, 0x0000, 0x6833, 0x0000, 0x0804, 0x3ed9, 0x68b4, 0xa084,
+	0x4800, 0xa635, 0xd6f4, 0x1da0, 0x7044, 0xa005, 0x1110, 0x7047,
+	0x0015, 0x2408, 0x2510, 0x2700, 0x8007, 0xa084, 0x007f, 0xa108,
+	0xa291, 0x0000, 0x692e, 0x6a32, 0x2100, 0xa205, 0x1110, 0x0804,
+	0x3ed9, 0x7000, 0xa086, 0x0006, 0x0110, 0x0804, 0x3ed9, 0x0005,
+	0x6946, 0x6008, 0xc0cd, 0xd3cc, 0x0108, 0xc08d, 0x600a, 0x6818,
+	0x683a, 0x681b, 0x0006, 0x688f, 0x0000, 0x6893, 0x0000, 0x6a30,
+	0x692c, 0x6a3e, 0x6942, 0x682f, 0x0003, 0x6833, 0x0000, 0x6837,
+	0x0020, 0x6897, 0x0000, 0x689b, 0x0020, 0x7000, 0x0002, 0x257f,
+	0x30ff, 0x30f9, 0x30f7, 0x30f7, 0x30f7, 0x30f7, 0x30f7, 0x080c,
+	0x252b, 0x6820, 0xd084, 0x1118, 0x080c, 0x376c, 0x0030, 0x7058,
+	0x2c50, 0x2060, 0x6800, 0x6002, 0x2a60, 0x3208, 0xa18c, 0x0600,
+	0x0118, 0x2021, 0x4557, 0x0010, 0x2021, 0x4597, 0x2404, 0xa005,
+	0x0110, 0x2020, 0x0cd8, 0x2d22, 0x206b, 0x0000, 0x0005, 0x080c,
+	0x3772, 0x080c, 0x3786, 0x6008, 0xc0cc, 0x600a, 0x682b, 0x0000,
+	0x789b, 0x000e, 0x6f14, 0x6938, 0x691a, 0x6944, 0x6916, 0x3208,
+	0xa18c, 0x0600, 0x0118, 0x2009, 0x0000, 0x0010, 0x2009, 0x0001,
+	0x080c, 0x428b, 0xd6dc, 0x01c8, 0x691c, 0xc1ed, 0x691e, 0x6828,
+	0xa082, 0x000e, 0x0290, 0x6848, 0xa084, 0x000f, 0xa086, 0x000b,
+	0x1160, 0x685c, 0xa086, 0x0047, 0x1140, 0x2001, 0x4501, 0x2004,
+	0xd0ac, 0x1118, 0x2700, 0x080c, 0x2454, 0x6818, 0xd0fc, 0x0140,
+	0x681b, 0x0000, 0x7868, 0xa08c, 0x00ff, 0x0110, 0x681b, 0x001e,
+	0xb284, 0x0600, 0x1118, 0x2021, 0x4597, 0x0010, 0x2021, 0x4557,
+	0x6800, 0x2022, 0x6a3c, 0x6940, 0x6a32, 0x692e, 0x68c0, 0x2060,
+	0x6000, 0xd0a4, 0x0580, 0x2041, 0x0021, 0x2049, 0x0005, 0x2051,
+	0x0020, 0x00d6, 0x00f6, 0x0156, 0x0146, 0x2079, 0x4500, 0x080c,
+	0x1b77, 0x014e, 0x015e, 0x00fe, 0x70c8, 0x2010, 0x2009, 0x0101,
+	0x0026, 0x2204, 0xa06d, 0x0140, 0x6814, 0xa706, 0x0110, 0x6800,
+	0x0cc8, 0x6820, 0xc0d5, 0x6822, 0x002e, 0x8210, 0x8109, 0x1d80,
+	0x00de, 0x7063, 0x0003, 0x707b, 0x0000, 0x7772, 0x707f, 0x000f,
+	0x71d0, 0xc1c4, 0x71d2, 0x6818, 0xa086, 0x0002, 0x1138, 0x6817,
+	0x0000, 0x682b, 0x0000, 0x681c, 0xc0ec, 0x681e, 0x080c, 0x1d89,
+	0x0804, 0x257f, 0x7cd8, 0x7ddc, 0x7fd0, 0x080c, 0x3068, 0x682b,
+	0x0000, 0x789b, 0x000e, 0x6f14, 0x080c, 0x3c10, 0xa08c, 0x00ff,
+	0x6916, 0x6818, 0xd0fc, 0x0110, 0x7044, 0x681a, 0xa68c, 0xdf00,
+	0x691e, 0x7063, 0x0000, 0x0804, 0x257f, 0x7000, 0xa005, 0x1110,
+	0x0804, 0x257f, 0xa006, 0x080c, 0x3ed9, 0x6920, 0xd1ac, 0x1110,
+	0x681b, 0x0014, 0xa68c, 0xdf00, 0x691e, 0x682b, 0x0000, 0x6820,
+	0xa084, 0x00ff, 0x6822, 0x7000, 0x0002, 0x257f, 0x31e7, 0x31e7,
+	0x31ea, 0x31ea, 0x31ea, 0x31e5, 0x31e5, 0x080c, 0x252b, 0x6818,
+	0x0804, 0x2ea4, 0x6008, 0xc0a4, 0x600a, 0x6817, 0x0000, 0x0804,
+	0x373a, 0x2300, 0x0002, 0x31f6, 0x31f8, 0x3241, 0x080c, 0x252b,
+	0xd6fc, 0x1904, 0x2cdf, 0x7000, 0xa00d, 0x0002, 0x257f, 0x3208,
+	0x3208, 0x3231, 0x3208, 0x323e, 0x3206, 0x3206, 0x080c, 0x252b,
+	0xa684, 0x0060, 0x0530, 0xa086, 0x0060, 0x1508, 0xc6ac, 0xc6f4,
+	0xc6ed, 0x7e5a, 0x681c, 0xc0ac, 0x681e, 0xa186, 0x0002, 0x0148,
+	0x080c, 0x3ed9, 0x69ac, 0x68b0, 0xa115, 0x0118, 0x080c, 0x41ad,
+	0x0010, 0x080c, 0x4180, 0x781b, 0x0083, 0x71d0, 0xd1b4, 0x1904,
+	0x257c, 0x70a0, 0xa086, 0x0001, 0x1904, 0x25c0, 0x0005, 0xd6ec,
+	0x09f8, 0x6818, 0xd0fc, 0x0150, 0xd6f4, 0x1130, 0x681b, 0x0015,
+	0x781b, 0x0083, 0x0804, 0x257c, 0x681b, 0x0007, 0x080c, 0x3bb7,
+	0x0005, 0x080c, 0x252b, 0x2300, 0x0002, 0x324a, 0x326c, 0x32c3,
+	0x080c, 0x252b, 0x7000, 0x0002, 0x3254, 0x3256, 0x325d, 0x3254,
+	0x3254, 0x3254, 0x3254, 0x3254, 0x080c, 0x252b, 0x69ac, 0x68b0,
+	0xa115, 0x0118, 0x080c, 0x41ad, 0x0010, 0x080c, 0x4180, 0x681c,
+	0xc0b4, 0x681e, 0x70d0, 0xd0b4, 0x1904, 0x257c, 0x70a0, 0xa086,
+	0x0001, 0x1904, 0x25c0, 0x0005, 0xd6fc, 0x1904, 0x32b3, 0x7000,
+	0xa00d, 0x0002, 0x257f, 0x3282, 0x327c, 0x32ab, 0x3282, 0x32b0,
+	0x327a, 0x327a, 0x080c, 0x252b, 0x6894, 0x78d6, 0x78de, 0x6898,
+	0x78d2, 0x78da, 0xa684, 0x0060, 0x0530, 0xa086, 0x0060, 0x1508,
+	0xa6b4, 0xbfbf, 0xc6ed, 0x7e5a, 0xa186, 0x0002, 0x0148, 0x080c,
+	0x3ed9, 0x69ac, 0x68b0, 0xa115, 0x0118, 0x080c, 0x41ad, 0x0010,
+	0x080c, 0x4180, 0x781b, 0x0083, 0x681c, 0xc0b4, 0x681e, 0x71d0,
+	0xd1b4, 0x1904, 0x257c, 0x70a0, 0xa086, 0x0001, 0x1904, 0x25c0,
+	0x0005, 0xd6ec, 0x09f8, 0x6818, 0xd0fc, 0x0110, 0x681b, 0x0007,
+	0x781b, 0x00fb, 0x0005, 0xc6fc, 0x7e5a, 0x7adc, 0x79d8, 0x6b98,
+	0x2100, 0xa302, 0x68b2, 0x6b94, 0x2200, 0xa303, 0x68ae, 0x79d2,
+	0x781b, 0x0083, 0x0005, 0xd6dc, 0x0130, 0x782b, 0x3009, 0x781b,
+	0x0083, 0x0804, 0x257c, 0x7884, 0xc0ac, 0x7886, 0x78e4, 0xa084,
+	0x0008, 0x1150, 0xa484, 0x0200, 0x0108, 0xc6f5, 0xc6dd, 0x7e5a,
+	0x781b, 0x0083, 0x0804, 0x257c, 0x6820, 0xc095, 0x6822, 0x080c,
+	0x3ba2, 0xc6dd, 0x080c, 0x39ff, 0x781b, 0x0082, 0x0804, 0x257c,
+	0x2300, 0x0002, 0x32ed, 0x32ef, 0x32f1, 0x080c, 0x252b, 0x0804,
+	0x39f9, 0x7d98, 0xd6d4, 0x11f8, 0x79e4, 0xd1ac, 0x0130, 0x78ec,
+	0xa084, 0x0003, 0x0110, 0x782b, 0x3009, 0x789b, 0x0060, 0x78ab,
+	0x0000, 0xa684, 0xfffb, 0x785a, 0x7d9a, 0x79e4, 0xd1ac, 0x0120,
+	0x78ec, 0xa084, 0x0003, 0x1120, 0x2001, 0x0014, 0x0804, 0x2ea4,
+	0xa184, 0x0007, 0x04c2, 0x7a90, 0xa294, 0x0007, 0x789b, 0x0060,
+	0x79a8, 0x81ff, 0x0568, 0x789b, 0x0080, 0x7ba8, 0xa384, 0x0001,
+	0x11d0, 0x7ba8, 0x7ba8, 0xa386, 0x0004, 0x1118, 0x2009, 0xffdf,
+	0x0058, 0xa386, 0x0001, 0x1118, 0x2009, 0xfff7, 0x0028, 0xa386,
+	0x0003, 0x1148, 0x2009, 0xffef, 0x00c6, 0x7054, 0x2060, 0x6004,
+	0xa104, 0x6006, 0x00ce, 0x789b, 0x0060, 0x78ab, 0x0000, 0xa684,
+	0xfffb, 0x785a, 0x782b, 0x3009, 0x6920, 0xa18c, 0xecff, 0x6922,
+	0x7d9a, 0x0804, 0x3bab, 0x2b90, 0x2b99, 0x3355, 0x335b, 0x3353,
+	0x3353, 0x3bab, 0x3bab, 0x080c, 0x252b, 0x6920, 0xa18c, 0xfcff,
+	0x6922, 0x0804, 0x3bb1, 0x6920, 0xa18c, 0xfcff, 0x6922, 0x0804,
+	0x3bab, 0x79e4, 0xa184, 0x0030, 0x0120, 0x78ec, 0xa084, 0x0003,
+	0x1570, 0x7000, 0xa086, 0x0004, 0x1190, 0x7060, 0xa086, 0x0002,
+	0x1130, 0x2011, 0x0002, 0x2019, 0x0000, 0x0804, 0x2a4d, 0x7060,
+	0xa086, 0x0006, 0x0db0, 0x7060, 0xa086, 0x0004, 0x0d90, 0x7000,
+	0xa086, 0x0000, 0x0904, 0x257c, 0x6920, 0xa184, 0x0420, 0x0128,
+	0xc1d4, 0x6922, 0x6818, 0x0804, 0x2ea4, 0x6818, 0xa08e, 0x0002,
+	0x0120, 0xc0fd, 0x681a, 0x2001, 0x0014, 0x0804, 0x2ea4, 0xa184,
+	0x0007, 0x0002, 0x3bab, 0x3bab, 0x33a2, 0x3bab, 0x3bef, 0x3bef,
+	0x3bab, 0x3bab, 0xd6bc, 0x0570, 0x7180, 0x81ff, 0x0558, 0xa182,
+	0x000d, 0x1318, 0x7083, 0x0000, 0x0028, 0xa182, 0x000c, 0x7082,
+	0x2009, 0x000c, 0x789b, 0x0061, 0x79aa, 0x0156, 0x0136, 0x0146,
+	0x7084, 0x8114, 0xa210, 0x7286, 0xa080, 0x000b, 0xad00, 0x2098,
+	0xb284, 0x0600, 0x0118, 0x20a1, 0x022b, 0x0010, 0x20a1, 0x012b,
+	0x789b, 0x0000, 0x8108, 0x81ac, 0x53a6, 0x014e, 0x013e, 0x015e,
+	0x0804, 0x3bb1, 0xd6d4, 0x1904, 0x3415, 0x6820, 0xd084, 0x0904,
+	0x3bb1, 0xa68c, 0x0060, 0xa684, 0x0060, 0x0120, 0xa086, 0x0060,
+	0x1108, 0xc1f5, 0xc194, 0x795a, 0x69b6, 0x789b, 0x0060, 0x78ab,
+	0x0000, 0x789b, 0x0061, 0x6818, 0xc0fd, 0x681a, 0x78aa, 0x8008,
+	0x810c, 0x0904, 0x379b, 0xa18c, 0x00f8, 0x1904, 0x379b, 0x0156,
+	0x0136, 0x0146, 0x0016, 0x20a1, 0x012b, 0x3208, 0xa18c, 0x0600,
+	0x0110, 0x20a1, 0x022b, 0x001e, 0x789b, 0x0000, 0x8000, 0x80ac,
+	0xad80, 0x000b, 0x2098, 0x53a6, 0x014e, 0x013e, 0x015e, 0x6814,
+	0xc0fc, 0x8007, 0x7882, 0x0804, 0x3bb1, 0x6818, 0xd0fc, 0x0110,
+	0x681b, 0x0008, 0x080c, 0x39ff, 0x781b, 0x00ed, 0x0005, 0x2300,
+	0x0002, 0x3426, 0x34e8, 0x3424, 0x080c, 0x252b, 0x7cd8, 0x7ddc,
+	0x7fd0, 0x82ff, 0x1528, 0x7200, 0xa286, 0x0003, 0x0904, 0x2e72,
+	0x71d0, 0xd1bc, 0x11f8, 0xd1b4, 0x01e8, 0x2001, 0x4501, 0x2004,
+	0xd0c4, 0x11c0, 0x00d6, 0x783b, 0x8800, 0x781b, 0x0059, 0x70b8,
+	0xa06d, 0x68b4, 0xc0a5, 0x785a, 0x6894, 0x78d6, 0x78de, 0x6898,
+	0x78d2, 0x78da, 0xc1b4, 0x71d2, 0x7003, 0x0030, 0x00de, 0x0030,
+	0x7200, 0x0020, 0x783b, 0x1800, 0x781b, 0x0057, 0xa284, 0x000f,
+	0x0002, 0x34d3, 0x3490, 0x3463, 0x2ea1, 0x3461, 0x34d3, 0x3461,
+	0x3461, 0x080c, 0x252b, 0x681c, 0xd0ec, 0x0118, 0x6008, 0xc08d,
+	0x600a, 0x6920, 0xc185, 0x6922, 0x6800, 0x6006, 0xa005, 0x1108,
+	0x6002, 0x6008, 0xc0d4, 0x600a, 0x681c, 0xa084, 0x000e, 0x1148,
+	0xb284, 0x0600, 0x0118, 0x2009, 0x8bc0, 0x0040, 0x2009, 0x8cd0,
+	0x0028, 0x7030, 0x68ba, 0x713c, 0x70c8, 0xa108, 0x2104, 0x6802,
+	0x2d0a, 0x715a, 0xd6dc, 0x1120, 0xc6fc, 0x6eb6, 0x0804, 0x34d3,
+	0x6eb6, 0xa684, 0x0060, 0x1120, 0xa684, 0x7fff, 0x68b6, 0x04d8,
 	0xd6dc, 0x1150, 0xa684, 0x7fff, 0x68b6, 0x6894, 0x68a6, 0x6898,
-	0x68aa, 0x080c, 0x3d52, 0x0478, 0xd6ac, 0x0140, 0xa006, 0x080c,
-	0x3d52, 0x2408, 0x2510, 0x69aa, 0x6aa6, 0x0068, 0x2408, 0x2510,
+	0x68aa, 0x080c, 0x3ed9, 0x0478, 0xd6ac, 0x0140, 0xa006, 0x080c,
+	0x3ed9, 0x2408, 0x2510, 0x69aa, 0x6aa6, 0x0068, 0x2408, 0x2510,
 	0x2700, 0x8007, 0xa084, 0x007f, 0xa108, 0xa291, 0x0000, 0x69aa,
-	0x6aa6, 0x080c, 0x3d52, 0xd6fc, 0x01b0, 0xa684, 0x7fff, 0x68b6,
+	0x6aa6, 0x080c, 0x3ed9, 0xd6fc, 0x01b0, 0xa684, 0x7fff, 0x68b6,
 	0x2510, 0x2408, 0xd6ac, 0x1138, 0x2700, 0x8007, 0xa084, 0x007f,
 	0xa108, 0xa291, 0x0000, 0x6b98, 0x2100, 0xa302, 0x68b2, 0x6b94,
-	0x2200, 0xa303, 0x68ae, 0x7000, 0xa086, 0x0030, 0x1904, 0x248f,
-	0x7003, 0x0002, 0x70bc, 0xa06d, 0x68bc, 0x7042, 0x70b8, 0xa065,
-	0x68c0, 0x705a, 0x2d00, 0x704e, 0xad80, 0x0009, 0x7046, 0x0005,
+	0x2200, 0xa303, 0x68ae, 0x7000, 0xa086, 0x0030, 0x1904, 0x257f,
+	0x7003, 0x0002, 0x70b8, 0xa06d, 0x68bc, 0x703e, 0x70b4, 0xa065,
+	0x68c0, 0x7056, 0x2d00, 0x704a, 0xad80, 0x0009, 0x7042, 0x0005,
 	0xa586, 0x8800, 0x1148, 0x7003, 0x0000, 0x6018, 0x8001, 0x601a,
-	0x6008, 0xa084, 0xfbef, 0x600a, 0x0804, 0x3831, 0x7047, 0x0000,
-	0xa282, 0x0006, 0x0310, 0x080c, 0x243b, 0x2300, 0x0002, 0x33b2,
-	0x33e4, 0x340f, 0x2200, 0x0002, 0x33ba, 0x3831, 0x33bc, 0x33ba,
-	0x343f, 0x349d, 0x080c, 0x243b, 0x7003, 0x0005, 0xb284, 0x0600,
-	0x0118, 0x2001, 0x8ae0, 0x0010, 0x2001, 0x8b12, 0x2068, 0x704e,
-	0x0156, 0x20a9, 0x0032, 0x2003, 0x0000, 0x8000, 0x1f04, 0x33cb,
+	0x6008, 0xa084, 0xfbef, 0x600a, 0x0804, 0x39f9, 0x7043, 0x0000,
+	0xa282, 0x0006, 0x0310, 0x080c, 0x252b, 0x2300, 0x0002, 0x3502,
+	0x3534, 0x355f, 0x2200, 0x0002, 0x350a, 0x39f9, 0x350c, 0x350a,
+	0x358f, 0x35f9, 0x080c, 0x252b, 0x7003, 0x0005, 0xb284, 0x0600,
+	0x0118, 0x2001, 0x8ce0, 0x0010, 0x2001, 0x8d12, 0x2068, 0x704a,
+	0x0156, 0x20a9, 0x0032, 0x2003, 0x0000, 0x8000, 0x1f04, 0x351b,
 	0x015e, 0xb284, 0x0600, 0x0118, 0x6817, 0x0000, 0x0010, 0x6817,
-	0x8000, 0xad80, 0x0009, 0x7046, 0x68b7, 0x0700, 0x6823, 0x0800,
-	0x6827, 0x0003, 0x0804, 0x3809, 0x7000, 0xa086, 0x0002, 0x1150,
-	0x080c, 0x35c5, 0x0010, 0x080c, 0x3d52, 0x6008, 0xa084, 0xfbef,
+	0x8000, 0xad80, 0x0009, 0x7042, 0x68b7, 0x0700, 0x6823, 0x0800,
+	0x6827, 0x0003, 0x0804, 0x39d0, 0x7000, 0xa086, 0x0002, 0x1150,
+	0x080c, 0x3786, 0x0010, 0x080c, 0x3ed9, 0x6008, 0xa084, 0xfbef,
 	0x600a, 0x0020, 0x7000, 0xa086, 0x0003, 0x0da8, 0x7003, 0x0005,
-	0xb284, 0x0600, 0x0118, 0x2001, 0x8ae0, 0x0010, 0x2001, 0x8b12,
-	0x2068, 0x704e, 0xad80, 0x0009, 0x7046, 0x2200, 0x0002, 0x3831,
-	0x340d, 0x340d, 0x343f, 0x340d, 0x3831, 0x080c, 0x243b, 0x7000,
-	0xa086, 0x0002, 0x1150, 0x080c, 0x35c5, 0x0010, 0x080c, 0x3d52,
+	0xb284, 0x0600, 0x0118, 0x2001, 0x8ce0, 0x0010, 0x2001, 0x8d12,
+	0x2068, 0x704a, 0xad80, 0x0009, 0x7042, 0x2200, 0x0002, 0x39f9,
+	0x355d, 0x355d, 0x358f, 0x355d, 0x39f9, 0x080c, 0x252b, 0x7000,
+	0xa086, 0x0002, 0x1150, 0x080c, 0x3786, 0x0010, 0x080c, 0x3ed9,
 	0x6008, 0xa084, 0xfbef, 0x600a, 0x0020, 0x7000, 0xa086, 0x0003,
-	0x0da8, 0x7003, 0x0005, 0xb284, 0x0600, 0x0118, 0x2001, 0x8ae0,
-	0x0010, 0x2001, 0x8b12, 0x2068, 0x704e, 0xad80, 0x0009, 0x7046,
-	0x2200, 0x0002, 0x343a, 0x3438, 0x3438, 0x343a, 0x3438, 0x343a,
-	0x080c, 0x243b, 0x080c, 0x3846, 0x781b, 0x0082, 0x0005, 0x7000,
-	0xa086, 0x0002, 0x1158, 0x70d4, 0xc0b5, 0x70d6, 0x2c00, 0x70ba,
-	0x2d00, 0x70be, 0x0038, 0x080c, 0x3d52, 0x0020, 0x7000, 0xa086,
+	0x0da8, 0x7003, 0x0005, 0xb284, 0x0600, 0x0118, 0x2001, 0x8ce0,
+	0x0010, 0x2001, 0x8d12, 0x2068, 0x704a, 0xad80, 0x0009, 0x7042,
+	0x2200, 0x0002, 0x358a, 0x3588, 0x3588, 0x358a, 0x3588, 0x358a,
+	0x080c, 0x252b, 0x080c, 0x3a0e, 0x781b, 0x0082, 0x0005, 0x7000,
+	0xa086, 0x0002, 0x1158, 0x70d0, 0xc0b5, 0x70d2, 0x2c00, 0x70b6,
+	0x2d00, 0x70ba, 0x0038, 0x080c, 0x3ed9, 0x0020, 0x7000, 0xa086,
 	0x0003, 0x0dc8, 0x7003, 0x0001, 0x7a80, 0xa294, 0x0f00, 0x789b,
-	0x0018, 0x7ca8, 0xa484, 0x001f, 0xa215, 0x2069, 0x89c0, 0xb284,
-	0x0600, 0x1118, 0xc2fd, 0x2069, 0x8ad0, 0x2d04, 0x2d08, 0x715e,
+	0x0018, 0x7ca8, 0xa484, 0x001f, 0xa215, 0x2069, 0x8bc0, 0xb284,
+	0x0600, 0x1118, 0xc2fd, 0x2069, 0x8cd0, 0x2d04, 0x2d08, 0x715a,
 	0xa06d, 0x0128, 0x6814, 0xa206, 0x0500, 0x6800, 0x0cb8, 0x7003,
-	0x0005, 0xd2fc, 0x1118, 0x2001, 0x8ae0, 0x0010, 0x2001, 0x8b12,
-	0x2068, 0x704e, 0x0156, 0x20a9, 0x0032, 0x2003, 0x0000, 0x8000,
-	0x1f04, 0x347d, 0x015e, 0xad80, 0x0009, 0x7046, 0x6a16, 0x68b7,
+	0x0005, 0xd2fc, 0x1118, 0x2001, 0x8ce0, 0x0010, 0x2001, 0x8d12,
+	0x2068, 0x704a, 0x0156, 0x20a9, 0x0032, 0x2003, 0x0000, 0x8000,
+	0x1f04, 0x35cd, 0x015e, 0xad80, 0x0009, 0x7042, 0x6a16, 0x68b7,
 	0x0700, 0x6823, 0x0800, 0x6827, 0x0003, 0x6eb4, 0x7e5a, 0x6920,
-	0xa184, 0x0c00, 0x0904, 0x3507, 0x681b, 0x0005, 0xc1ad, 0xc1d4,
-	0x6922, 0x080c, 0x383d, 0x0804, 0x3507, 0x7200, 0xa286, 0x0002,
-	0x1158, 0x70d4, 0xc0b5, 0x70d6, 0x2c00, 0x70ba, 0x2d00, 0x70be,
-	0x0030, 0x080c, 0x3d52, 0x0018, 0xa286, 0x0003, 0x0dd0, 0x7003,
-	0x0001, 0x7a80, 0xa294, 0x0f00, 0x789b, 0x0018, 0x7ca8, 0xa484,
-	0x001f, 0xa215, 0xb284, 0x0600, 0x1108, 0xc2fd, 0x79a8, 0x79a8,
-	0xa18c, 0x00ff, 0x70cc, 0xa168, 0x2d04, 0x2d08, 0x715e, 0xa06d,
-	0x0128, 0x6814, 0xa206, 0x0538, 0x6800, 0x0cb8, 0x7003, 0x0005,
-	0xb284, 0x0600, 0x0118, 0x2001, 0x8ae0, 0x0010, 0x2001, 0x8b12,
-	0x2068, 0x704e, 0x0156, 0x20a9, 0x0032, 0x2003, 0x0000, 0x8000,
-	0x1f04, 0x34dd, 0x015e, 0xb284, 0x0600, 0x0110, 0xc2fc, 0x0008,
-	0xc2fd, 0x6a16, 0xad80, 0x0009, 0x7046, 0x68b7, 0x0700, 0x6823,
-	0x0800, 0x6827, 0x0003, 0x6eb4, 0x6920, 0xa184, 0x0c00, 0x0178,
-	0xd0dc, 0x0118, 0x080c, 0x3843, 0x0050, 0x681b, 0x0005, 0xc1ad,
-	0xc1d4, 0x6922, 0x080c, 0x383d, 0x707f, 0x0000, 0x0000, 0xa6ac,
-	0x0060, 0x05c8, 0x6b98, 0x6c94, 0x69ac, 0x68b0, 0xa105, 0x11c0,
-	0x7bd2, 0x7bda, 0x7cd6, 0x7cde, 0xa6b4, 0xb7ff, 0xa586, 0x0060,
-	0x0550, 0xc6ed, 0x7e5a, 0x2009, 0x0083, 0xd69c, 0x0128, 0x2009,
-	0x0082, 0x2019, 0x0000, 0x2320, 0x791a, 0x080c, 0x3fb8, 0x0418,
-	0x68b0, 0xa31a, 0x2100, 0xa423, 0x2400, 0xa305, 0x01a0, 0x7bd2,
-	0x7bda, 0x7cd6, 0x7cde, 0x68b0, 0xc6f4, 0x7e5a, 0x2011, 0x0083,
-	0xd69c, 0x0128, 0x2011, 0x0082, 0x2019, 0x0000, 0x2320, 0x7a1a,
-	0x080c, 0x3fe5, 0x0040, 0x7e5a, 0x2009, 0x0083, 0xd69c, 0x0110,
-	0x2009, 0x0082, 0x791a, 0x68c0, 0x705a, 0x2d00, 0x704e, 0x68c4,
-	0x2060, 0x71d4, 0xd1b4, 0x1904, 0x248c, 0x2300, 0xa405, 0x0904,
-	0x248c, 0x70a4, 0xa086, 0x0001, 0x1904, 0x24ce, 0x0005, 0x6020,
+	0xa184, 0x0c00, 0x0904, 0x3670, 0x7060, 0xa086, 0x0006, 0x1128,
+	0x7070, 0xa206, 0x1110, 0x7062, 0x707a, 0x681b, 0x0005, 0xc1ad,
+	0x681b, 0x0005, 0xc1ad, 0xc1d4, 0x6922, 0x080c, 0x3a05, 0x0804,
+	0x3670, 0x7200, 0xa286, 0x0002, 0x1158, 0x70d0, 0xc0b5, 0x70d2,
+	0x2c00, 0x70b6, 0x2d00, 0x70ba, 0x0030, 0x080c, 0x3ed9, 0x0018,
+	0xa286, 0x0003, 0x0dd0, 0x7003, 0x0001, 0x7a80, 0xa294, 0x0f00,
+	0x789b, 0x0018, 0x7ca8, 0xa484, 0x001f, 0xa215, 0xb284, 0x0600,
+	0x1108, 0xc2fd, 0x79a8, 0x79a8, 0xa18c, 0x00ff, 0x2118, 0x70c8,
+	0xa168, 0x2d04, 0x2d08, 0x715a, 0xa06d, 0x0128, 0x6814, 0xa206,
+	0x0538, 0x6800, 0x0cb8, 0x7003, 0x0005, 0xb284, 0x0600, 0x0118,
+	0x2001, 0x8ce0, 0x0010, 0x2001, 0x8d12, 0x2068, 0x704a, 0x0156,
+	0x20a9, 0x0032, 0x2003, 0x0000, 0x8000, 0x1f04, 0x363a, 0x015e,
+	0xb284, 0x0600, 0x0110, 0xc2fc, 0x0008, 0xc2fd, 0x6a16, 0xad80,
+	0x0009, 0x7042, 0x68b7, 0x0700, 0x6823, 0x0800, 0x6827, 0x0003,
+	0x6eb4, 0x6920, 0xa184, 0x0c00, 0x01d8, 0xd0dc, 0x0178, 0x7060,
+	0xa086, 0x0004, 0x1140, 0x7070, 0xa206, 0x1128, 0x7074, 0xa306,
+	0x1110, 0x7062, 0x707a, 0x080c, 0x3a0b, 0x0050, 0x681b, 0x0005,
+	0xc1ad, 0xc1d4, 0x6922, 0x080c, 0x3a05, 0x707b, 0x0000, 0x0000,
+	0xc6ec, 0xa6ac, 0x0060, 0x0904, 0x36b7, 0x6b98, 0x6c94, 0x69ac,
+	0x68b0, 0xa105, 0x11e0, 0x7bd2, 0x7bda, 0x7cd6, 0x7cde, 0xa586,
+	0x0060, 0x05c8, 0xd6f4, 0x1108, 0xc6ed, 0xa6b4, 0xb7ff, 0x7e5a,
+	0x2009, 0x0083, 0xd69c, 0x0128, 0x2009, 0x0082, 0x2019, 0x0000,
+	0x2320, 0x791a, 0xd6ec, 0x0588, 0x080c, 0x4180, 0x0470, 0x68b0,
+	0xa31a, 0x2100, 0xa423, 0x2400, 0xa305, 0x01f8, 0x7bd2, 0x7bda,
+	0x7cd6, 0x7cde, 0x68b0, 0xd6f4, 0x1108, 0xc6ed, 0xc6f4, 0x7e5a,
+	0x2011, 0x0083, 0xd69c, 0x0128, 0x2011, 0x0082, 0x2019, 0x0000,
+	0x2320, 0x7a1a, 0xd6ec, 0x0188, 0x080c, 0x41ad, 0x0070, 0x2019,
+	0x0000, 0x2320, 0x0010, 0xa6b4, 0xb7ff, 0x7e5a, 0x2009, 0x0083,
+	0xd69c, 0x0110, 0x2009, 0x0082, 0x791a, 0x68c0, 0x7056, 0x2d00,
+	0x704a, 0x68c4, 0x2060, 0x71d0, 0x2001, 0x4501, 0x2004, 0xd0c4,
+	0x15c8, 0x70d4, 0xa02d, 0x01b8, 0xd1bc, 0x0548, 0x7a80, 0xa294,
+	0x0f00, 0x70d8, 0xa206, 0x0118, 0x78e0, 0xa504, 0x1558, 0x70d6,
+	0xc1bc, 0x71d2, 0x0438, 0x2031, 0x0001, 0x852c, 0x0218, 0x8633,
+	0x8210, 0x0cd8, 0x0005, 0x7de0, 0xa594, 0xff00, 0x0130, 0x2011,
+	0x0008, 0x852f, 0x0c81, 0x8637, 0x0008, 0x0c69, 0x8217, 0x7880,
+	0xa084, 0x0f00, 0xa206, 0x0170, 0x72da, 0x76d6, 0x0058, 0x7a80,
+	0xa294, 0x0f00, 0x70d8, 0xa236, 0x0dc0, 0x78e0, 0xa534, 0x0da8,
+	0xc1bd, 0x71d2, 0xd1b4, 0x1904, 0x257c, 0x2300, 0xa405, 0x0904,
+	0x257c, 0x70a0, 0xa086, 0x0001, 0x1904, 0x25c0, 0x0005, 0x6020,
 	0xa005, 0x0150, 0x8001, 0x6022, 0x6008, 0xa085, 0x0008, 0x600a,
-	0x700f, 0x0100, 0x702c, 0x6026, 0x0005, 0xa006, 0x080c, 0x3d52,
+	0x700f, 0x0100, 0x702c, 0x6026, 0x0005, 0xa006, 0x080c, 0x3ed9,
+	0x7000, 0xa086, 0x0002, 0x0120, 0x7060, 0xa086, 0x0005, 0x1150,
 	0x682b, 0x0000, 0x6817, 0x0000, 0x681b, 0x0001, 0x6823, 0x0040,
-	0x681f, 0x0100, 0x7000, 0xa084, 0x000f, 0x0002, 0x248f, 0x358b,
-	0x3588, 0x35a7, 0x3594, 0x248f, 0x3586, 0x3586, 0x080c, 0x243b,
-	0x0441, 0x0409, 0x0028, 0x0429, 0x705c, 0x2060, 0x6800, 0x6002,
-	0x080c, 0x1d3d, 0x0804, 0x248f, 0x7064, 0x7067, 0x0000, 0x7083,
-	0x0000, 0x0002, 0x35a3, 0x35a3, 0x35a2, 0x35a2, 0x35a2, 0x35a3,
-	0x35a2, 0x35a3, 0x2971, 0x7067, 0x0000, 0x0804, 0x248f, 0x681b,
-	0x0000, 0x0804, 0x3012, 0x6800, 0xa005, 0x1108, 0x6002, 0x6006,
-	0x0005, 0x6410, 0x84ff, 0x0168, 0x2009, 0x4302, 0x2104, 0x8001,
-	0x200a, 0x8421, 0x6412, 0x1128, 0x2021, 0x4304, 0x2404, 0xc0a5,
-	0x2022, 0x6008, 0xc0a4, 0x600a, 0x0005, 0x6018, 0xa005, 0x0110,
-	0x8001, 0x601a, 0x0005, 0x080c, 0x3aa0, 0x681b, 0x0018, 0x04a0,
-	0x080c, 0x3aa0, 0x681b, 0x0019, 0x0478, 0x080c, 0x3aa0, 0x681b,
-	0x001a, 0x0450, 0x080c, 0x3aa0, 0x681b, 0x0003, 0x0428, 0x7774,
-	0x080c, 0x396d, 0x7178, 0xa18c, 0x00ff, 0x3210, 0xa294, 0x0600,
-	0x0118, 0xa1e8, 0x88c0, 0x0010, 0xa1e8, 0x89d0, 0x2d04, 0x2d08,
-	0x2068, 0xa005, 0x1118, 0x707e, 0x0804, 0x248f, 0x6814, 0xc0fc,
-	0x7274, 0xc2fc, 0xa206, 0x0110, 0x6800, 0x0c88, 0x6800, 0x200a,
-	0x681b, 0x0005, 0x707f, 0x0000, 0x080c, 0x35b1, 0x6820, 0xd084,
-	0x1110, 0x080c, 0x35ab, 0x080c, 0x35c5, 0x681f, 0x0000, 0x6823,
-	0x0020, 0x080c, 0x1d3d, 0x0804, 0x248f, 0xa282, 0x0003, 0x1904,
-	0x380d, 0x7da8, 0xa5ac, 0x00ff, 0x7ea8, 0xa6b4, 0x00ff, 0x6920,
-	0xc1bd, 0x6922, 0xd1c4, 0x0590, 0xc1c4, 0x6922, 0xa6b4, 0x00ff,
-	0x0510, 0xa682, 0x001c, 0x0218, 0x0110, 0x2031, 0x001c, 0x852b,
-	0x852b, 0x2041, 0x0000, 0x080c, 0x38c6, 0x0118, 0x080c, 0x36f6,
-	0x00a0, 0x080c, 0x3892, 0x080c, 0x36f3, 0x6920, 0xc1c5, 0x6922,
+	0x681f, 0x0100, 0x7000, 0xa084, 0x000f, 0x0002, 0x257f, 0x374b,
+	0x3748, 0x3768, 0x3754, 0x257f, 0x3746, 0x3746, 0x080c, 0x252b,
+	0x0449, 0x0411, 0x0028, 0x0431, 0x7058, 0x2060, 0x6800, 0x6002,
+	0x080c, 0x1d89, 0x0804, 0x257f, 0x7060, 0x7063, 0x0000, 0x707f,
+	0x0000, 0x0002, 0x3764, 0x3764, 0x3762, 0x3762, 0x3762, 0x3764,
+	0x3762, 0x3764, 0x0804, 0x2a62, 0x7063, 0x0000, 0x0804, 0x257f,
+	0x681b, 0x0000, 0x0804, 0x3117, 0x6800, 0xa005, 0x1108, 0x6002,
+	0x6006, 0x0005, 0x6410, 0x84ff, 0x0168, 0x2009, 0x4502, 0x2104,
+	0x8001, 0x200a, 0x8421, 0x6412, 0x1128, 0x2021, 0x4504, 0x2404,
+	0xc0a5, 0x2022, 0x6008, 0xc0a4, 0x600a, 0x0005, 0x6018, 0xa005,
+	0x0110, 0x8001, 0x601a, 0x0005, 0x080c, 0x3c0c, 0x681b, 0x0018,
+	0x0490, 0x080c, 0x3c0c, 0x681b, 0x0019, 0x0468, 0x080c, 0x3c0c,
+	0x681b, 0x001a, 0x0440, 0x080c, 0x3c0c, 0x681b, 0x0003, 0x0418,
+	0x7770, 0x080c, 0x3b35, 0x7174, 0xa18c, 0x00ff, 0x3210, 0xa294,
+	0x0600, 0x0118, 0xa1e8, 0x8ac0, 0x0010, 0xa1e8, 0x8bd0, 0x2d04,
+	0x2d08, 0x2068, 0xa005, 0x1118, 0x707a, 0x0804, 0x257f, 0x6814,
+	0x7270, 0xa206, 0x0110, 0x6800, 0x0c98, 0x6800, 0x200a, 0x681b,
+	0x0005, 0x707b, 0x0000, 0x080c, 0x3772, 0x6820, 0xd084, 0x1110,
+	0x080c, 0x376c, 0x080c, 0x3786, 0x681f, 0x0000, 0x6823, 0x0020,
+	0x080c, 0x1d89, 0x0804, 0x257f, 0xa282, 0x0003, 0x1904, 0x39d5,
+	0x7da8, 0xa5ac, 0x00ff, 0x7ea8, 0xa6b4, 0x00ff, 0x6920, 0xc1bd,
+	0x6922, 0xd1c4, 0x05b0, 0xc1c4, 0x6922, 0xa6b4, 0x00ff, 0x0530,
+	0xa682, 0x001c, 0x0218, 0x0110, 0x2031, 0x001c, 0xa686, 0x0010,
+	0x1108, 0x8630, 0x852b, 0x852b, 0x2041, 0x0000, 0x080c, 0x3a8e,
+	0x0118, 0x080c, 0x38bd, 0x00a0, 0x080c, 0x3a5a, 0x080c, 0x38ba,
+	0x6920, 0xc1c5, 0x6922, 0x7e58, 0xc695, 0x7e5a, 0xd6d4, 0x1118,
+	0x781b, 0x006e, 0x0005, 0x781b, 0x0082, 0x0005, 0x080c, 0x38ba,
+	0x7e58, 0xd6d4, 0x1118, 0x781b, 0x0071, 0x0005, 0x781b, 0x0083,
+	0x0005, 0x00c6, 0x7054, 0x2060, 0x6100, 0xd1e4, 0x0598, 0x6208,
+	0x8217, 0xa294, 0x00ff, 0xa282, 0x001c, 0x0218, 0x0110, 0x2011,
+	0x001c, 0x2600, 0xa202, 0x1208, 0x2230, 0xa686, 0x0010, 0x1108,
+	0x8630, 0x6208, 0xa294, 0x00ff, 0x78ec, 0xd0e4, 0x0130, 0xa282,
+	0x000a, 0x1240, 0x2011, 0x000a, 0x0028, 0xa282, 0x000c, 0x1210,
+	0x2011, 0x000c, 0x2200, 0xa502, 0x1208, 0x2228, 0x080c, 0x3a5e,
+	0x852b, 0x852b, 0x2041, 0x0000, 0x080c, 0x3a8e, 0x0118, 0x080c,
+	0x38bd, 0x0020, 0x080c, 0x3a5a, 0x080c, 0x38ba, 0x7858, 0xc095,
+	0x785a, 0x00ce, 0x781b, 0x0082, 0x0005, 0x00c6, 0x2960, 0x6000,
+	0xd0e4, 0x1178, 0x6010, 0xa084, 0x000f, 0x1130, 0x6104, 0xa18c,
+	0xfff5, 0x6106, 0x00ce, 0x0005, 0x2011, 0x0032, 0x2019, 0x0000,
+	0x00f0, 0x68a0, 0xd0cc, 0x1dc0, 0x6208, 0xa294, 0x00ff, 0x78ec,
+	0xd0e4, 0x0130, 0xa282, 0x000b, 0x1218, 0x2011, 0x000a, 0x0028,
+	0xa282, 0x000c, 0x1210, 0x2011, 0x000c, 0x6308, 0x831f, 0xa39c,
+	0x00ff, 0xa382, 0x001c, 0x0218, 0x0110, 0x2019, 0x001c, 0x78ab,
+	0x0001, 0x78ab, 0x0003, 0x78ab, 0x0001, 0x7aaa, 0x7baa, 0xa8c0,
+	0x0005, 0x6820, 0xc0c5, 0x6822, 0x080c, 0x3a18, 0x00ce, 0x0005,
+	0x00c6, 0x2960, 0x6104, 0xa18c, 0xfff5, 0x6106, 0x2011, 0x0032,
+	0x2019, 0x0000, 0x0000, 0x78ab, 0x0001, 0x78ab, 0x0003, 0x78ab,
+	0x0001, 0x7aaa, 0x7baa, 0xa8c0, 0x0005, 0x6820, 0xc0c5, 0x6822,
+	0x00ce, 0x0005, 0xa006, 0x2030, 0x2010, 0x00c6, 0x7154, 0x2160,
+	0x2018, 0x2008, 0xa084, 0xffe0, 0xa635, 0x7e86, 0x6018, 0x789a,
+	0x7eae, 0x6612, 0x78a4, 0xa084, 0x7770, 0xa18c, 0x000f, 0xa105,
+	0x2029, 0x4505, 0x252c, 0xd5cc, 0x0140, 0xd3a4, 0x0110, 0xa085,
+	0x0800, 0xd3fc, 0x0110, 0xa085, 0x8080, 0x78a6, 0x6016, 0x788a,
+	0xa6b4, 0x001f, 0x8637, 0x8204, 0x8004, 0xa605, 0x600e, 0x6004,
+	0xa084, 0xffd5, 0x6006, 0x00ce, 0x0005, 0xa282, 0x0002, 0x1904,
+	0x39de, 0x7aa8, 0x6920, 0xc1bd, 0x6922, 0xd1cc, 0x0568, 0xc1cc,
+	0x6922, 0xa294, 0x00ff, 0xa282, 0x0002, 0x1a04, 0x39d0, 0x080c,
+	0x3963, 0x080c, 0x38ba, 0xa980, 0x0001, 0x200c, 0x080c, 0x3b31,
+	0x080c, 0x385d, 0x88ff, 0x0178, 0x789b, 0x0060, 0x2800, 0x78aa,
 	0x7e58, 0xc695, 0x7e5a, 0xd6d4, 0x1118, 0x781b, 0x006e, 0x0005,
-	0x781b, 0x0082, 0x0005, 0x080c, 0x36f3, 0x7e58, 0xd6d4, 0x1118,
-	0x781b, 0x0071, 0x0005, 0x781b, 0x0083, 0x0005, 0x00c6, 0x7058,
-	0x2060, 0x6100, 0xd1e4, 0x0578, 0x6208, 0x8217, 0xa294, 0x00ff,
-	0xa282, 0x001c, 0x0218, 0x0110, 0x2011, 0x001c, 0x2600, 0xa202,
-	0x1208, 0x2230, 0x6208, 0xa294, 0x00ff, 0x78ec, 0xd0e4, 0x0130,
-	0xa282, 0x000a, 0x1240, 0x2011, 0x000a, 0x0028, 0xa282, 0x000c,
-	0x1210, 0x2011, 0x000c, 0x2200, 0xa502, 0x1208, 0x2228, 0x080c,
-	0x3896, 0x852b, 0x852b, 0x2041, 0x0000, 0x080c, 0x38c6, 0x0118,
-	0x080c, 0x36f6, 0x0020, 0x080c, 0x3892, 0x080c, 0x36f3, 0x7858,
-	0xc095, 0x785a, 0x00ce, 0x781b, 0x0082, 0x0005, 0x00c6, 0x2960,
-	0x6000, 0xd0e4, 0x1178, 0x6010, 0xa084, 0x000f, 0x1130, 0x6104,
-	0xa18c, 0xfff5, 0x6106, 0x00ce, 0x0005, 0x2011, 0x0032, 0x2019,
-	0x0000, 0x00f0, 0x68a0, 0xd0cc, 0x1dc0, 0x6208, 0xa294, 0x00ff,
-	0x78ec, 0xd0e4, 0x0130, 0xa282, 0x000b, 0x1218, 0x2011, 0x000a,
-	0x0028, 0xa282, 0x000c, 0x1210, 0x2011, 0x000c, 0x6308, 0x831f,
-	0xa39c, 0x00ff, 0xa382, 0x001c, 0x0218, 0x0110, 0x2019, 0x001c,
-	0x78ab, 0x0001, 0x78ab, 0x0003, 0x78ab, 0x0001, 0x7aaa, 0x7baa,
-	0xa8c0, 0x0005, 0x6820, 0xc0c5, 0x6822, 0x080c, 0x3850, 0x00ce,
-	0x0005, 0x00c6, 0x2960, 0x6104, 0xa18c, 0xfff5, 0x6106, 0x2011,
-	0x0032, 0x2019, 0x0000, 0x0000, 0x78ab, 0x0001, 0x78ab, 0x0003,
-	0x78ab, 0x0001, 0x7aaa, 0x7baa, 0xa8c0, 0x0005, 0x6820, 0xc0c5,
-	0x6822, 0x00ce, 0x0005, 0xa006, 0x2030, 0x2010, 0x00c6, 0x7158,
-	0x2160, 0x2018, 0x2008, 0xa084, 0xffe0, 0xa635, 0x7e86, 0x6018,
-	0x789a, 0x7eae, 0x6612, 0x78a4, 0xa084, 0x7770, 0xa18c, 0x000f,
-	0xa105, 0x2029, 0x4305, 0x252c, 0xd5cc, 0x0140, 0xd3a4, 0x0110,
-	0xa085, 0x0800, 0xd3fc, 0x0110, 0xa085, 0x8080, 0x78a6, 0x6016,
-	0x788a, 0xa6b4, 0x001f, 0x8637, 0x8204, 0x8004, 0xa605, 0x600e,
-	0x6004, 0xa084, 0xffd5, 0x6006, 0x00ce, 0x0005, 0xa282, 0x0002,
-	0x1904, 0x3816, 0x7aa8, 0x6920, 0xc1bd, 0x6922, 0xd1cc, 0x0568,
-	0xc1cc, 0x6922, 0xa294, 0x00ff, 0xa282, 0x0002, 0x1a04, 0x3809,
-	0x080c, 0x379c, 0x080c, 0x36f3, 0xa980, 0x0001, 0x200c, 0x080c,
-	0x3969, 0x080c, 0x3696, 0x88ff, 0x0178, 0x789b, 0x0060, 0x2800,
-	0x78aa, 0x7e58, 0xc695, 0x7e5a, 0xd6d4, 0x1118, 0x781b, 0x006e,
-	0x0005, 0x781b, 0x0082, 0x0005, 0x7e58, 0xd6d4, 0x1118, 0x781b,
-	0x0071, 0x0005, 0x781b, 0x0083, 0x0005, 0xa282, 0x0002, 0x1218,
-	0xa284, 0x0001, 0x0140, 0x7158, 0xa188, 0x0000, 0x210c, 0xd1ec,
-	0x1110, 0x2011, 0x0000, 0x080c, 0x3883, 0x0471, 0x080c, 0x36f3,
-	0x7858, 0xc095, 0x785a, 0x781b, 0x0082, 0x0005, 0x00c6, 0x0026,
-	0x2960, 0x6000, 0x2011, 0x0001, 0xd0ec, 0x1150, 0x6014, 0xa084,
-	0x0040, 0x1120, 0xc1a4, 0x6106, 0xa006, 0x0088, 0x2011, 0x0000,
-	0x78ab, 0x0001, 0x78ab, 0x0002, 0x78ab, 0x0003, 0x7aaa, 0xa8c0,
-	0x0004, 0x080c, 0x3850, 0x6820, 0xa085, 0x0200, 0x6822, 0x002e,
-	0x00ce, 0x0005, 0x8807, 0xa715, 0x00c6, 0x2009, 0x0000, 0x7058,
-	0x2060, 0x82ff, 0x0110, 0x2009, 0x0040, 0x6018, 0xa080, 0x0002,
-	0x789a, 0x78a4, 0xa084, 0xff9f, 0xa105, 0xc0ec, 0xd0b4, 0x1108,
-	0xc0ed, 0x6100, 0xd1f4, 0x0110, 0xa085, 0x0020, 0x78a6, 0x6016,
-	0x788a, 0x6004, 0xa084, 0xffef, 0x6006, 0x00ce, 0x0005, 0x0006,
-	0x7000, 0xa086, 0x0003, 0x0110, 0x000e, 0x0010, 0x000e, 0x0488,
-	0xd6ac, 0x0578, 0x7888, 0xa084, 0x0040, 0x0558, 0x7bb8, 0x8307,
-	0xa084, 0x007f, 0x1508, 0x8207, 0xa084, 0x00ff, 0xa09e, 0x0001,
-	0x1904, 0x382d, 0xd6f4, 0x11d0, 0x79d8, 0x7adc, 0xa108, 0xa291,
-	0x0000, 0x79d2, 0x79da, 0x7ad6, 0x7ade, 0x080c, 0x4083, 0x781b,
-	0x0080, 0xb284, 0x0600, 0x0118, 0x2001, 0x0000, 0x0010, 0x2001,
-	0x0001, 0x080c, 0x3f50, 0x0005, 0x080c, 0x243b, 0x781b, 0x0080,
-	0x0005, 0x781b, 0x0083, 0x0005, 0x2039, 0x0000, 0x2041, 0x0000,
-	0x2031, 0x0000, 0xa006, 0x2010, 0x080c, 0x36f6, 0x080c, 0x379a,
-	0x7e58, 0x04f9, 0x781b, 0x0082, 0x0005, 0x0cd9, 0x6820, 0xc0c4,
-	0x6822, 0x00c6, 0x7058, 0x2060, 0x0804, 0x3720, 0x0c91, 0x6820,
-	0xc0cc, 0x6822, 0x00c6, 0x7058, 0x2060, 0x0804, 0x37b9, 0x0c49,
-	0x6820, 0xa084, 0xecff, 0x6822, 0x00c6, 0x7058, 0x2060, 0x6004,
+	0x781b, 0x0082, 0x0005, 0x7e58, 0xd6d4, 0x1118, 0x781b, 0x0071,
+	0x0005, 0x781b, 0x0083, 0x0005, 0xa282, 0x0002, 0x1218, 0xa284,
+	0x0001, 0x0140, 0x7154, 0xa188, 0x0000, 0x210c, 0xd1ec, 0x1110,
+	0x2011, 0x0000, 0x080c, 0x3a4b, 0x0471, 0x080c, 0x38ba, 0x7858,
+	0xc095, 0x785a, 0x781b, 0x0082, 0x0005, 0x00c6, 0x0026, 0x2960,
+	0x6000, 0x2011, 0x0001, 0xd0ec, 0x1150, 0x6014, 0xa084, 0x0040,
+	0x1120, 0xc1a4, 0x6106, 0xa006, 0x0088, 0x2011, 0x0000, 0x78ab,
+	0x0001, 0x78ab, 0x0002, 0x78ab, 0x0003, 0x7aaa, 0xa8c0, 0x0004,
+	0x080c, 0x3a18, 0x6820, 0xa085, 0x0200, 0x6822, 0x002e, 0x00ce,
+	0x0005, 0x8807, 0xa715, 0x00c6, 0x2009, 0x0000, 0x7054, 0x2060,
+	0x82ff, 0x0110, 0x2009, 0x0040, 0x6018, 0xa080, 0x0002, 0x789a,
+	0x78a4, 0xa084, 0xff9f, 0xa105, 0xc0ec, 0xd0b4, 0x1108, 0xc0ed,
+	0x6100, 0xd1f4, 0x0110, 0xa085, 0x0020, 0x78a6, 0x6016, 0x788a,
+	0x6004, 0xa084, 0xffef, 0x6006, 0x00ce, 0x0005, 0x0006, 0x7000,
+	0xa086, 0x0003, 0x0110, 0x000e, 0x0010, 0x000e, 0x0488, 0xd6ac,
+	0x0578, 0x7888, 0xa084, 0x0040, 0x0558, 0x7bb8, 0x8307, 0xa084,
+	0x007f, 0x1508, 0x8207, 0xa084, 0x00ff, 0xa09e, 0x0001, 0x1904,
+	0x39f5, 0xd6f4, 0x11d0, 0x79d8, 0x7adc, 0xa108, 0xa291, 0x0000,
+	0x79d2, 0x79da, 0x7ad6, 0x7ade, 0x080c, 0x425d, 0x781b, 0x0080,
+	0xb284, 0x0600, 0x0118, 0x2001, 0x0000, 0x0010, 0x2001, 0x0001,
+	0x080c, 0x4118, 0x0005, 0x080c, 0x252b, 0x781b, 0x0080, 0x0005,
+	0x781b, 0x0083, 0x0005, 0x2039, 0x0000, 0x2041, 0x0000, 0x2031,
+	0x0000, 0xa006, 0x2010, 0x080c, 0x38bd, 0x080c, 0x3961, 0x7e58,
+	0x080c, 0x3a11, 0x781b, 0x0082, 0x0005, 0x0cd1, 0x6820, 0xc0c4,
+	0x6822, 0x00c6, 0x7054, 0x2060, 0x0804, 0x38e7, 0x0c89, 0x6820,
+	0xc0cc, 0x6822, 0x00c6, 0x7054, 0x2060, 0x0804, 0x3980, 0x0c41,
+	0x6820, 0xa084, 0xecff, 0x6822, 0x00c6, 0x7054, 0x2060, 0x6004,
 	0xa084, 0xffc5, 0x6006, 0x00ce, 0x0005, 0x0049, 0x781b, 0x0082,
 	0x0005, 0x6827, 0x0002, 0x0049, 0x781b, 0x0082, 0x0005, 0x2001,
 	0x0005, 0x0088, 0x2001, 0x000c, 0x0070, 0x6820, 0xc0d5, 0x6822,
 	0x2001, 0x0006, 0x0040, 0x2001, 0x000d, 0x0028, 0x2001, 0x0009,
 	0x0010, 0x2001, 0x0007, 0x789b, 0x007e, 0x78aa, 0xc69d, 0x7e5a,
-	0x70d4, 0xd0b4, 0x0168, 0xc0b4, 0x70d6, 0x00c6, 0x70b8, 0xa065,
+	0x70d0, 0xd0b4, 0x0168, 0xc0b4, 0x70d2, 0x00c6, 0x70b4, 0xa065,
 	0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a, 0x00ce,
 	0x0005, 0x0076, 0x873f, 0xa7bc, 0x000f, 0x873b, 0x873b, 0x8703,
-	0xb28c, 0x0600, 0x0118, 0xa0e0, 0x47c0, 0x0010, 0xa0e0, 0x4840,
+	0xb28c, 0x0600, 0x0118, 0xa0e0, 0x49c0, 0x0010, 0xa0e0, 0x4a40,
 	0xa7b8, 0x0020, 0x7f9a, 0x79a4, 0xa184, 0x7fe0, 0x78ae, 0x6012,
 	0x79a4, 0xa184, 0x773f, 0x78a6, 0x6016, 0x6004, 0xa085, 0x0038,
 	0x6006, 0x007e, 0x0005, 0x789b, 0x0080, 0x78ab, 0x0001, 0x78ab,
 	0x0002, 0x78ab, 0x0003, 0x7aaa, 0x789b, 0x0060, 0x78ab, 0x0004,
-	0x0804, 0x3850, 0x2031, 0x0000, 0x2029, 0x0032, 0x789b, 0x0080,
+	0x0804, 0x3a18, 0x2031, 0x0000, 0x2029, 0x0032, 0x789b, 0x0080,
 	0x78ab, 0x0001, 0x78ab, 0x0003, 0x78ab, 0x0001, 0x7daa, 0x7eaa,
-	0x789b, 0x0060, 0x78ab, 0x0005, 0x0804, 0x3850, 0x0156, 0x8007,
+	0x789b, 0x0060, 0x78ab, 0x0005, 0x0804, 0x3a18, 0x0156, 0x8007,
 	0xa084, 0x00ff, 0x8003, 0x8003, 0xa080, 0x0020, 0x789a, 0x79a4,
-	0xa18c, 0xffe0, 0x2021, 0x3952, 0x2019, 0x0011, 0x20a9, 0x000e,
+	0xa18c, 0xffe0, 0x2021, 0x3b1a, 0x2019, 0x0011, 0x20a9, 0x000e,
 	0x2011, 0x0032, 0x2404, 0xa084, 0xffe0, 0xa106, 0x0128, 0x8420,
-	0x2300, 0xa210, 0x1f04, 0x38ba, 0x015e, 0x0005, 0x0156, 0x0804,
-	0x3908, 0x2021, 0x3960, 0x20a9, 0x0009, 0x2011, 0x0029, 0xa582,
+	0x2300, 0xa210, 0x1f04, 0x3a82, 0x015e, 0x0005, 0x0156, 0x0804,
+	0x3ad0, 0x2021, 0x3b28, 0x20a9, 0x0009, 0x2011, 0x0029, 0xa582,
 	0x0028, 0x0550, 0x8420, 0x95a9, 0x2011, 0x0033, 0xa582, 0x0033,
 	0x0618, 0x8420, 0x95a9, 0x2019, 0x000a, 0x2011, 0x0065, 0x2200,
-	0xa502, 0x02d0, 0x8420, 0x2300, 0xa210, 0x1f04, 0x38df, 0x015e,
-	0x0088, 0x2021, 0x3952, 0x2019, 0x0011, 0x20a9, 0x000e, 0x2011,
+	0xa502, 0x02d0, 0x8420, 0x2300, 0xa210, 0x1f04, 0x3aa7, 0x015e,
+	0x0088, 0x2021, 0x3b1a, 0x2019, 0x0011, 0x20a9, 0x000e, 0x2011,
 	0x0033, 0x2200, 0xa502, 0x0240, 0x8420, 0x2300, 0xa210, 0x1f04,
-	0x38f1, 0x015e, 0xa006, 0x0005, 0x8211, 0x015e, 0xa582, 0x0064,
+	0x3ab9, 0x015e, 0xa006, 0x0005, 0x8211, 0x015e, 0xa582, 0x0064,
 	0x1220, 0x7808, 0xa085, 0x0070, 0x780a, 0x2404, 0xa005, 0x0005,
-	0xa886, 0x0002, 0x01e8, 0x2021, 0x393e, 0x20a9, 0x000d, 0x2011,
+	0xa886, 0x0002, 0x01e8, 0x2021, 0x3b06, 0x20a9, 0x000d, 0x2011,
 	0x0028, 0xa582, 0x0028, 0x0d48, 0x8420, 0x2019, 0x0019, 0x2011,
 	0x0033, 0x2200, 0xa502, 0x0e00, 0x8420, 0x2300, 0xa210, 0x1f04,
-	0x3919, 0x015e, 0x2011, 0x0184, 0xa582, 0x0185, 0x0ab0, 0x0890,
-	0x2021, 0x394d, 0x20a9, 0x0003, 0x2011, 0x0024, 0xa586, 0x0024,
+	0x3ae1, 0x015e, 0x2011, 0x0184, 0xa582, 0x0185, 0x0ab0, 0x0890,
+	0x2021, 0x3b15, 0x20a9, 0x0003, 0x2011, 0x0024, 0xa586, 0x0024,
 	0x0960, 0x8420, 0x2011, 0x0028, 0xa586, 0x0028, 0x0930, 0x8420,
-	0x2019, 0x0019, 0x2011, 0x0033, 0x0804, 0x38f1, 0x1021, 0x2202,
+	0x2019, 0x0019, 0x2011, 0x0033, 0x0804, 0x3ab9, 0x1021, 0x2202,
 	0x3403, 0x4604, 0x5805, 0x6a06, 0x7c07, 0x4610, 0x4612, 0x5812,
 	0x5a12, 0x6a14, 0x6c14, 0x6e14, 0x7e17, 0x9021, 0xb002, 0xe204,
 	0xe210, 0xe210, 0x1209, 0x3002, 0x3202, 0x4203, 0x4403, 0x5404,
@@ -1391,314 +1485,319 @@
 	0x10e1, 0x330a, 0x5805, 0x5a05, 0x6a06, 0x6c06, 0x7c07, 0x7e07,
 	0x0e00, 0x789b, 0x0080, 0xa046, 0x0005, 0xa784, 0x0f00, 0x800b,
 	0xa784, 0x001f, 0x8003, 0x8003, 0x8003, 0x8003, 0xa105, 0xd7fc,
-	0x0118, 0xa0e0, 0x68c0, 0x0010, 0xa0e0, 0x48c0, 0x0005, 0x00e6,
-	0x00f6, 0xd084, 0x0138, 0x2079, 0x0100, 0x2009, 0x4380, 0x2071,
-	0x4380, 0x0030, 0x2009, 0x4340, 0x2079, 0x0200, 0x2071, 0x4340,
-	0x2091, 0x8000, 0x2104, 0xa084, 0x000f, 0x0002, 0x39c5, 0x39a0,
-	0x39a0, 0x39a0, 0x39a0, 0x39a0, 0x399e, 0x399e, 0x080c, 0x243b,
-	0x784b, 0x0004, 0x7848, 0xa084, 0x0004, 0x1de0, 0x784b, 0x0008,
-	0x7848, 0xa084, 0x0008, 0x1de0, 0x68b4, 0xc0f5, 0x68b6, 0x7858,
-	0xc0f5, 0x785a, 0x7830, 0xd0bc, 0x1180, 0xb284, 0x0800, 0x0118,
-	0x0104, 0x39c5, 0x0010, 0x0304, 0x39c5, 0x681c, 0xd0ac, 0x1118,
-	0x080c, 0x3a4b, 0x0010, 0x781b, 0x00fb, 0x2091, 0x8001, 0x00fe,
-	0x00ee, 0x0005, 0x00c6, 0x2001, 0x4301, 0x2004, 0xd0ac, 0x1904,
-	0x3a3d, 0x6814, 0x8007, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003,
-	0xb28c, 0x0600, 0x0118, 0xa0e0, 0x47c0, 0x0010, 0xa0e0, 0x4840,
-	0x6004, 0xa084, 0x000a, 0x1904, 0x3a3d, 0x6108, 0xa194, 0xff00,
-	0x0904, 0x3a3d, 0xa18c, 0x00ff, 0x601c, 0xa084, 0xff00, 0x0180,
-	0x2001, 0x0009, 0xa102, 0x16b8, 0x2001, 0x000a, 0xa102, 0x16b0,
-	0x2001, 0x000c, 0xa102, 0x16a8, 0x601c, 0xa084, 0x00ff, 0x601e,
-	0x2001, 0x000a, 0xa106, 0x01a8, 0x2001, 0x000c, 0xa106, 0x01a0,
-	0x2001, 0x0012, 0xa106, 0x0198, 0x2001, 0x0014, 0xa106, 0x0190,
-	0x2001, 0x0019, 0xa106, 0x0188, 0x2001, 0x0032, 0xa106, 0x0180,
-	0x00d8, 0x2009, 0x000c, 0x00d0, 0x2009, 0x0012, 0x00b8, 0x2009,
-	0x0014, 0x00a0, 0x2009, 0x0019, 0x0088, 0x2009, 0x0020, 0x0070,
-	0x2009, 0x003f, 0x0058, 0x2009, 0x000a, 0x0040, 0x2009, 0x000c,
-	0x0028, 0x2009, 0x0019, 0x0010, 0x2011, 0x0000, 0x2100, 0xa205,
-	0x600a, 0x6004, 0xa085, 0x0002, 0x6006, 0x00ce, 0x0005, 0x781b,
-	0x0083, 0x0005, 0x781b, 0x0082, 0x0005, 0x781b, 0x0071, 0x0005,
-	0x781b, 0x006e, 0x0005, 0x2009, 0x4319, 0x210c, 0xa186, 0x0000,
-	0x0150, 0xa186, 0x0001, 0x0150, 0x701f, 0x000b, 0x7067, 0x0001,
-	0x781b, 0x0054, 0x0005, 0x781b, 0x00f3, 0x0005, 0x701f, 0x000a,
-	0x0005, 0x2009, 0x4319, 0x210c, 0xa186, 0x0000, 0x0168, 0xa186,
-	0x0001, 0x0138, 0x701f, 0x000b, 0x7067, 0x0001, 0x781b, 0x0054,
-	0x0005, 0x701f, 0x000a, 0x0005, 0x781b, 0x00f2, 0x0005, 0x781b,
-	0x00fb, 0x0005, 0x781b, 0x00fa, 0x0005, 0x781b, 0x00cc, 0x0005,
-	0x781b, 0x00cb, 0x0005, 0x6818, 0xd0fc, 0x0110, 0x681b, 0x001d,
-	0x7067, 0x0001, 0x781b, 0x0054, 0x0005, 0x7830, 0xa084, 0x00c0,
-	0x1170, 0x7808, 0xc08c, 0x780a, 0xe000, 0xe000, 0xe000, 0xe000,
-	0x78ec, 0xa084, 0x0021, 0x0118, 0x7808, 0xc08d, 0x780a, 0x0005,
-	0x7808, 0xc08d, 0x780a, 0x0005, 0x7830, 0xa084, 0x0040, 0x1de0,
-	0xb284, 0x0800, 0x0118, 0x1104, 0x3ab2, 0x0010, 0x1304, 0x3ab2,
-	0x78ac, 0x0005, 0x7808, 0xa084, 0xfffd, 0x780a, 0xe000, 0xe000,
-	0xe000, 0xe000, 0x78ec, 0xa084, 0x0021, 0x0140, 0xb284, 0x0800,
-	0x0118, 0x1104, 0x3ac1, 0x0010, 0x1304, 0x3ac4, 0x78ac, 0x0006,
-	0x7808, 0xa085, 0x0002, 0x780a, 0x000e, 0x0005, 0xa784, 0x0001,
-	0x1904, 0x30a0, 0xa784, 0x0070, 0x0140, 0x00c6, 0x2d60, 0x2f68,
-	0x080c, 0x23e1, 0x2d78, 0x2c68, 0x00ce, 0xa784, 0x0008, 0x0148,
-	0x784b, 0x0008, 0x78ec, 0xa084, 0x0003, 0x0904, 0x248f, 0x0804,
-	0x3a3f, 0xa784, 0x0004, 0x01c8, 0x78b8, 0xa084, 0x8000, 0x01a8,
-	0x784b, 0x0008, 0x78ec, 0xa084, 0x0003, 0x0904, 0x248f, 0x78e4,
-	0xa084, 0x0007, 0xa086, 0x0001, 0x1140, 0x78c0, 0xa685, 0x4800,
-	0x2030, 0x7e5a, 0x781b, 0x00fb, 0x0005, 0xa784, 0x0080, 0x0140,
-	0x7884, 0xd0fc, 0x0128, 0x080c, 0x382d, 0x681b, 0x0022, 0x0005,
-	0x681b, 0x0003, 0x7858, 0xa084, 0x3f00, 0x681e, 0x682f, 0x0000,
-	0x6833, 0x0000, 0x784b, 0x0008, 0x78ec, 0xa084, 0x0003, 0x0904,
-	0x2a7a, 0xb284, 0x0800, 0x0110, 0x0104, 0x248c, 0x0304, 0x248c,
-	0x6b14, 0x8307, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0xd3fc,
-	0x0118, 0xa080, 0x4840, 0x0010, 0xa080, 0x47c0, 0x2060, 0x2048,
-	0x705a, 0x2a60, 0x0005, 0x00c6, 0x2960, 0x6000, 0xd0ac, 0x0904,
-	0x3b81, 0xd1ac, 0x05e0, 0x6108, 0x8117, 0xa18c, 0x00ff, 0x631c,
-	0x832f, 0x68a0, 0xd0cc, 0x11c8, 0xa584, 0x00ff, 0x0138, 0x78ec,
-	0xd0e4, 0x0110, 0x8213, 0x00b8, 0x2029, 0x0000, 0xa182, 0x000c,
-	0x1290, 0x78ec, 0xd0e4, 0x1118, 0x2009, 0x000c, 0x0060, 0xa182,
-	0x000b, 0x1248, 0x2009, 0x000a, 0x0030, 0x2009, 0x0032, 0x2011,
-	0x0000, 0x2029, 0x0000, 0x78ab, 0x0001, 0x78ab, 0x0006, 0x78ab,
-	0x0004, 0x79aa, 0x78ab, 0x0000, 0x7aaa, 0x7baa, 0x7daa, 0xa8c0,
-	0x0008, 0x6820, 0xa085, 0x1000, 0x6822, 0x080c, 0x3850, 0xa085,
-	0x0001, 0x00ce, 0x0005, 0xa282, 0x0006, 0x1904, 0x381f, 0x7da8,
-	0x7eac, 0x8637, 0xa5ac, 0x00ff, 0xa6b4, 0x00ff, 0x7fac, 0x8747,
-	0xa7bc, 0x00ff, 0xa8c4, 0x00ff, 0x6920, 0xc1bd, 0x6922, 0xd1e4,
-	0x05c8, 0xa18c, 0xecff, 0x6922, 0xa782, 0x0002, 0x1a04, 0x37fc,
-	0xa6b4, 0x00ff, 0x0560, 0xa682, 0x0039, 0x1a04, 0x37fc, 0xa582,
-	0x0009, 0x0a04, 0x37fc, 0xa882, 0x0003, 0x1a04, 0x37fc, 0xa886,
-	0x0002, 0x0128, 0xa886, 0x0000, 0x0138, 0x0804, 0x37fc, 0xa786,
-	0x0000, 0x0904, 0x37fc, 0x8634, 0x852b, 0x852b, 0x080c, 0x38c6,
-	0x0904, 0x37fc, 0x080c, 0x36f6, 0x080c, 0x379a, 0x7e58, 0xd6d4,
-	0x1118, 0x781b, 0x0071, 0x0005, 0x781b, 0x0083, 0x0005, 0x080c,
-	0x36f3, 0x0c90, 0xa886, 0x0002, 0x1108, 0x8634, 0x7158, 0xa188,
-	0x0000, 0x210c, 0xd1ac, 0x0904, 0x37fc, 0xd1ec, 0x1120, 0x2039,
-	0x0000, 0x2041, 0x0000, 0xd1e4, 0x1120, 0x2031, 0x0000, 0x2041,
-	0x0000, 0xa782, 0x0002, 0x12c8, 0x621c, 0xa284, 0x00ff, 0xa706,
-	0x0110, 0x2039, 0x0000, 0xa605, 0x0190, 0x6108, 0x811f, 0xa39c,
-	0x00ff, 0x0168, 0xa302, 0x1208, 0x2330, 0x8807, 0xa705, 0xa086,
-	0x0201, 0x0160, 0xa886, 0x0000, 0x0168, 0x2039, 0x0000, 0x2041,
-	0x0000, 0x2031, 0x0000, 0xa006, 0x2010, 0x0070, 0xa284, 0xff00,
-	0x1108, 0x2040, 0xa184, 0x00ff, 0xa502, 0x0108, 0x2128, 0x852b,
-	0x852b, 0x080c, 0x38c6, 0x0d58, 0x080c, 0x36f6, 0x080c, 0x379a,
-	0x789b, 0x0080, 0x78ab, 0x0001, 0x78ab, 0x0006, 0x78ab, 0x0004,
-	0x78ab, 0x0000, 0x7daa, 0x7eaa, 0x7faa, 0x2800, 0x78aa, 0x789b,
-	0x0060, 0x78ab, 0x0005, 0x080c, 0x3850, 0x7858, 0xc095, 0x785a,
-	0x781b, 0x0082, 0x0005, 0x0020, 0x0020, 0x0000, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0062, 0x0009, 0x0014,
-	0x0014, 0x9855, 0x984d, 0x0014, 0x9911, 0x98ff, 0x0014, 0x0014,
-	0x0090, 0x00e7, 0x0100, 0x0402, 0x2008, 0xf880, 0x0018, 0x0017,
-	0x840f, 0xd8c1, 0x0014, 0x0016, 0xa20a, 0x0014, 0x300b, 0xa20c,
-	0x0014, 0x2500, 0x0013, 0x2500, 0x0010, 0x0010, 0x0010, 0x0010,
+	0x0118, 0xa0e0, 0x6ac0, 0x0010, 0xa0e0, 0x4ac0, 0x0005, 0x00e6,
+	0x00f6, 0xd084, 0x0138, 0x2079, 0x0100, 0x2009, 0x4580, 0x2071,
+	0x4580, 0x0030, 0x2009, 0x4540, 0x2079, 0x0200, 0x2071, 0x4540,
+	0x2091, 0x8000, 0x2104, 0xa084, 0x000f, 0x0002, 0x3b68, 0x3b68,
+	0x3b68, 0x3b68, 0x3b68, 0x3b68, 0x3b66, 0x3b66, 0x080c, 0x252b,
+	0x69b4, 0xc1f5, 0xa18c, 0xff9f, 0x69b6, 0xa005, 0x0580, 0x7858,
+	0xa084, 0xff9f, 0xa085, 0x6000, 0x785a, 0x7828, 0xa086, 0x1814,
+	0x1530, 0x784b, 0x0004, 0x7848, 0xa084, 0x0004, 0x1de0, 0x784b,
+	0x0008, 0x7848, 0xa084, 0x0008, 0x1de0, 0x7830, 0xd0bc, 0x11b8,
+	0xb284, 0x0800, 0x0118, 0x0104, 0x3b9f, 0x0010, 0x0304, 0x3b9f,
+	0x79e4, 0xa184, 0x0030, 0x0158, 0x78ec, 0xa084, 0x0003, 0x0138,
+	0x681c, 0xd0ac, 0x1110, 0x00d9, 0x0010, 0x781b, 0x00fb, 0x00fe,
+	0x00ee, 0x0005, 0x2001, 0x4501, 0x2004, 0xd0ac, 0x1118, 0x6814,
+	0x080c, 0x2454, 0x0005, 0x781b, 0x0083, 0x0005, 0x781b, 0x0082,
+	0x0005, 0x781b, 0x0071, 0x0005, 0x781b, 0x006e, 0x0005, 0x2009,
+	0x4519, 0x210c, 0xa186, 0x0000, 0x0150, 0xa186, 0x0001, 0x0150,
+	0x701f, 0x000b, 0x7063, 0x0001, 0x781b, 0x0054, 0x0005, 0x781b,
+	0x00f3, 0x0005, 0x701f, 0x000a, 0x0005, 0x2009, 0x4519, 0x210c,
+	0xa186, 0x0000, 0x0168, 0xa186, 0x0001, 0x0138, 0x701f, 0x000b,
+	0x7063, 0x0001, 0x781b, 0x0054, 0x0005, 0x701f, 0x000a, 0x0005,
+	0x781b, 0x00f2, 0x0005, 0x781b, 0x00fb, 0x0005, 0x781b, 0x00fa,
+	0x0005, 0x781b, 0x00cc, 0x0005, 0x781b, 0x00cb, 0x0005, 0x6818,
+	0xd0fc, 0x0110, 0x681b, 0x001d, 0x7063, 0x0001, 0x781b, 0x0054,
+	0x0005, 0x7830, 0xa084, 0x00c0, 0x1170, 0x7808, 0xc08c, 0x780a,
+	0xe000, 0xe000, 0xe000, 0xe000, 0x78ec, 0xa084, 0x0021, 0x0118,
+	0x7808, 0xc08d, 0x780a, 0x0005, 0x7808, 0xc08d, 0x780a, 0x0005,
+	0x7830, 0xa084, 0x0040, 0x1de0, 0xb284, 0x0800, 0x0118, 0x1104,
+	0x3c1e, 0x0010, 0x1304, 0x3c1e, 0x78ac, 0x0005, 0x7808, 0xa084,
+	0xfffd, 0x780a, 0xe000, 0xe000, 0xe000, 0xe000, 0x78ec, 0xa084,
+	0x0021, 0x0140, 0xb284, 0x0800, 0x0118, 0x1104, 0x3c2d, 0x0010,
+	0x1304, 0x3c30, 0x78ac, 0x0006, 0x7808, 0xa085, 0x0002, 0x780a,
+	0x000e, 0x0005, 0xa784, 0x0001, 0x1904, 0x31c5, 0xa784, 0x0070,
+	0x0140, 0x00c6, 0x2d60, 0x2f68, 0x080c, 0x2446, 0x2d78, 0x2c68,
+	0x00ce, 0xa784, 0x0008, 0x0148, 0x784b, 0x0008, 0x78ec, 0xa084,
+	0x0003, 0x0904, 0x31c5, 0x0804, 0x3bab, 0xa784, 0x0004, 0x01c8,
+	0x78b8, 0xa084, 0x8000, 0x01a8, 0x784b, 0x0008, 0x78ec, 0xa084,
+	0x0003, 0x0904, 0x31c5, 0x78e4, 0xa084, 0x0007, 0xa086, 0x0001,
+	0x1140, 0x78c0, 0xa685, 0x4800, 0x2030, 0x7e5a, 0x781b, 0x00fb,
+	0x0005, 0xa784, 0x0080, 0x0140, 0x7884, 0xd0fc, 0x0128, 0x080c,
+	0x39f5, 0x681b, 0x0022, 0x0005, 0x681b, 0x0003, 0x7858, 0xa084,
+	0x5f00, 0x681e, 0x682f, 0x0000, 0x6833, 0x0000, 0x784b, 0x0008,
+	0x78ec, 0xa084, 0x0003, 0x0904, 0x2b6b, 0xb284, 0x0800, 0x0110,
+	0x0104, 0x257c, 0x0304, 0x257c, 0x6b14, 0x8307, 0xa084, 0x000f,
+	0x8003, 0x8003, 0x8003, 0xd3fc, 0x0118, 0xa080, 0x4a40, 0x0010,
+	0xa080, 0x49c0, 0x2060, 0x2048, 0x7056, 0x2a60, 0x0005, 0x00c6,
+	0x2960, 0x6000, 0xd0ac, 0x0904, 0x3ced, 0xd1ac, 0x05e0, 0x6108,
+	0x8117, 0xa18c, 0x00ff, 0x631c, 0x832f, 0x68a0, 0xd0cc, 0x11c8,
+	0xa584, 0x00ff, 0x0138, 0x78ec, 0xd0e4, 0x0110, 0x8213, 0x00b8,
+	0x2029, 0x0000, 0xa182, 0x000c, 0x1290, 0x78ec, 0xd0e4, 0x1118,
+	0x2009, 0x000c, 0x0060, 0xa182, 0x000b, 0x1248, 0x2009, 0x000a,
+	0x0030, 0x2009, 0x0032, 0x2011, 0x0000, 0x2029, 0x0000, 0x78ab,
+	0x0001, 0x78ab, 0x0006, 0x78ab, 0x0004, 0x79aa, 0x78ab, 0x0000,
+	0x7aaa, 0x7baa, 0x7daa, 0xa8c0, 0x0008, 0x6820, 0xa085, 0x1000,
+	0x6822, 0x080c, 0x3a18, 0xa085, 0x0001, 0x00ce, 0x0005, 0xa282,
+	0x0006, 0x1904, 0x39e7, 0x7da8, 0x7eac, 0x8637, 0xa5ac, 0x00ff,
+	0xa6b4, 0x00ff, 0x7fac, 0x8747, 0xa7bc, 0x00ff, 0xa8c4, 0x00ff,
+	0x6920, 0xc1bd, 0x6922, 0xd1e4, 0x0904, 0x3d59, 0xa18c, 0xecff,
+	0x6922, 0xa782, 0x0002, 0x1a04, 0x39c3, 0xa6b4, 0x00ff, 0x0904,
+	0x3d56, 0xa682, 0x0039, 0x1a04, 0x39c3, 0xa582, 0x0009, 0x0a04,
+	0x39c3, 0xa882, 0x0003, 0x1a04, 0x39c3, 0xa886, 0x0002, 0x01d0,
+	0xa886, 0x0000, 0x1904, 0x39c3, 0x2001, 0x000c, 0x79ec, 0xd1e4,
+	0x0110, 0x2001, 0x000a, 0xa502, 0x1290, 0x080c, 0x39c3, 0x00c6,
+	0x2960, 0x6004, 0xa085, 0x001a, 0x6006, 0x6000, 0xc0ac, 0x6002,
+	0x00ce, 0x0005, 0xa786, 0x0000, 0x0904, 0x39c3, 0x8634, 0xa686,
+	0x0010, 0x1108, 0x8630, 0x852b, 0x852b, 0x080c, 0x3a8e, 0x0904,
+	0x39c3, 0x080c, 0x38bd, 0x080c, 0x3961, 0x7e58, 0xd6d4, 0x1118,
+	0x781b, 0x0071, 0x0005, 0x781b, 0x0083, 0x0005, 0x080c, 0x38ba,
+	0x0c90, 0xa886, 0x0002, 0x1108, 0x8634, 0x7154, 0xa188, 0x0000,
+	0x210c, 0xd1ac, 0x0904, 0x39c3, 0xd1ec, 0x1120, 0x2039, 0x0000,
+	0x2041, 0x0000, 0xd1e4, 0x1120, 0x2031, 0x0000, 0x2041, 0x0000,
+	0xa782, 0x0002, 0x12c8, 0x621c, 0xa284, 0x00ff, 0xa706, 0x0110,
+	0x2039, 0x0000, 0xa605, 0x0190, 0x6108, 0x811f, 0xa39c, 0x00ff,
+	0x0168, 0xa302, 0x1208, 0x2330, 0x8807, 0xa705, 0xa086, 0x0201,
+	0x0160, 0xa886, 0x0000, 0x0168, 0x2039, 0x0000, 0x2041, 0x0000,
+	0x2031, 0x0000, 0xa006, 0x2010, 0x0070, 0xa284, 0xff00, 0x1108,
+	0x2040, 0xa184, 0x00ff, 0xa502, 0x0108, 0x2128, 0x852b, 0x852b,
+	0x080c, 0x3a8e, 0x0d58, 0x080c, 0x38bd, 0x080c, 0x3961, 0x789b,
+	0x0080, 0x78ab, 0x0001, 0x78ab, 0x0006, 0x78ab, 0x0004, 0x78ab,
+	0x0000, 0x7daa, 0x7eaa, 0x7faa, 0x2800, 0x78aa, 0x789b, 0x0060,
+	0x78ab, 0x0005, 0x080c, 0x3a18, 0x7858, 0xc095, 0x785a, 0x781b,
+	0x0082, 0x0005, 0x0020, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0062, 0x0009, 0x0014, 0x0014,
+	0x9855, 0x984d, 0x0014, 0x9911, 0x98ff, 0x0014, 0x0014, 0x0090,
+	0x00e7, 0x0100, 0x0402, 0x2008, 0xf880, 0x0018, 0x0017, 0x840f,
+	0xd8c1, 0x0014, 0x0016, 0xa20a, 0x0014, 0x300b, 0xa20c, 0x0014,
+	0x2500, 0x0013, 0x2500, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
 	0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-	0x0010, 0x0010, 0xa200, 0x3806, 0x8839, 0x20c4, 0x0864, 0xa84f,
-	0x3008, 0x28c1, 0x9d18, 0xa201, 0x300c, 0x2847, 0x8161, 0x846a,
-	0x8000, 0x84a4, 0x1856, 0x883a, 0xa808, 0x28e2, 0x9cce, 0xa8f3,
-	0x0864, 0xa83d, 0x300c, 0xa801, 0x3008, 0x28e1, 0x9cce, 0x2021,
-	0xa818, 0xa205, 0x870c, 0xd8de, 0x64a0, 0x6de0, 0x6fc0, 0x67a4,
-	0x6c80, 0x0212, 0xa205, 0x883d, 0x882b, 0x1814, 0x883b, 0x7027,
-	0x85f2, 0xa737, 0xa532, 0xf003, 0x8576, 0x8677, 0xa814, 0x883e,
-	0xa812, 0x280a, 0xa204, 0x64c0, 0x6de0, 0x67a0, 0x6fc0, 0x1814,
-	0x883b, 0x7027, 0x8576, 0x8677, 0xa806, 0x796d, 0xa8da, 0x796b,
-	0xa8f1, 0x7861, 0x883e, 0x206b, 0x28c1, 0x9d18, 0x2044, 0x2103,
-	0x20b4, 0x2095, 0xa8ca, 0xa207, 0x2901, 0xa80a, 0x0014, 0xa203,
+	0x0010, 0xa200, 0x3806, 0x8839, 0x20c4, 0x0864, 0xa850, 0x3008,
+	0x28c1, 0x9d18, 0xa201, 0x300c, 0x2847, 0x8161, 0x846a, 0x8000,
+	0x84a4, 0x1856, 0x883a, 0xa808, 0x28e2, 0x9cce, 0xa8f3, 0x0864,
+	0xa83e, 0x300c, 0xa801, 0x3008, 0x28e1, 0x9cce, 0x28a1, 0x7162,
+	0x2021, 0xa818, 0xa205, 0x870c, 0xd8de, 0x64a0, 0x6de0, 0x6fc0,
+	0x67a4, 0x6c80, 0x0212, 0xa205, 0x883d, 0x882b, 0x1814, 0x883b,
+	0x7027, 0x85f2, 0xa737, 0xa532, 0xf003, 0x8576, 0x8677, 0xa812,
+	0x883e, 0xa810, 0x2881, 0x7161, 0x280a, 0xa204, 0x64c0, 0x6de0,
+	0x67a0, 0x6fc0, 0x1814, 0x883b, 0x7023, 0x8576, 0x8677, 0xa802,
+	0x7861, 0x883e, 0x206c, 0x28c1, 0x9d18, 0x2044, 0x2103, 0x20a2,
+	0x2081, 0xa8ca, 0x2902, 0xa20e, 0xa80b, 0xa207, 0x0014, 0xa203,
 	0x8000, 0x85a4, 0x1872, 0x879a, 0x883c, 0x1fe2, 0xf601, 0xa208,
-	0x856e, 0x866f, 0x7121, 0x0014, 0x0704, 0x3008, 0x9cce, 0x0014,
-	0xa202, 0x8000, 0x85a4, 0x3009, 0x84a8, 0x19e2, 0xf844, 0x856e,
-	0x883f, 0x08e6, 0xa8f5, 0xf861, 0xa8ea, 0xf801, 0x0014, 0xf881,
-	0x0016, 0x85b2, 0x80f0, 0x9532, 0xfaa2, 0x1de2, 0x0014, 0x8532,
-	0xf221, 0x0014, 0x1de2, 0x84a8, 0xd6e0, 0x1fe6, 0x0014, 0x3008,
-	0x8000, 0x2849, 0x1011, 0xa8fc, 0x3008, 0x8000, 0xa000, 0x2081,
-	0x2802, 0x1011, 0xa8fc, 0xa889, 0x3008, 0x20a1, 0x283c, 0x1011,
-	0xa8fc, 0xa209, 0x0017, 0x300c, 0x8000, 0x85a4, 0x1de2, 0xdac1,
-	0x0014, 0x0210, 0xa801, 0x0014, 0x26e0, 0x873a, 0xfaa3, 0x19f2,
-	0x26e0, 0x18f2, 0x0014, 0xa20b, 0x0014, 0xa20d, 0x3806, 0x0210,
-	0x9d22, 0x0704, 0xa206, 0x6865, 0x817e, 0x842a, 0x1dc1, 0x8823,
-	0x0016, 0x6042, 0x8008, 0xa8fa, 0x8160, 0x842a, 0x8180, 0xf021,
-	0x3008, 0x84a8, 0x11d7, 0x7042, 0x20dd, 0x0011, 0x20d5, 0x8822,
-	0x0016, 0x0000, 0x0126, 0x70d4, 0xa084, 0x4c00, 0x8004, 0x2090,
-	0x7204, 0x7008, 0xc09c, 0xa205, 0x1178, 0x720c, 0x82ff, 0x0128,
-	0x8aff, 0x1150, 0x7200, 0xd284, 0x1138, 0x7007, 0x0004, 0x7003,
-	0x0008, 0x012e, 0x2000, 0x0005, 0x7000, 0xa084, 0x0003, 0x7002,
-	0xc69c, 0xd084, 0x05b8, 0x2001, 0x4301, 0x2004, 0xd0b4, 0x0904,
-	0x3dcf, 0x7108, 0xe000, 0x7008, 0xa106, 0x1dd8, 0xa184, 0x0003,
-	0x0904, 0x3dcf, 0xa184, 0x01e0, 0x1904, 0x3dcf, 0xd1f4, 0x1d88,
-	0xa184, 0x3000, 0xa086, 0x1000, 0x0d60, 0x2011, 0x0180, 0x710c,
-	0x8211, 0x0130, 0x7008, 0xd0f4, 0x1d20, 0x700c, 0xa106, 0x0dc0,
-	0x7007, 0x0012, 0x7108, 0xe000, 0x7008, 0xa106, 0x1dd8, 0xa184,
-	0x0003, 0x0568, 0xd194, 0x0db0, 0xd1f4, 0x0548, 0x7007, 0x0002,
-	0x0880, 0x0428, 0x7108, 0xd1fc, 0x0130, 0x080c, 0x3e9e, 0x8aff,
-	0x0904, 0x3d58, 0x0cb8, 0x700c, 0xa08c, 0x07ff, 0x01e8, 0x7004,
-	0xd084, 0x0178, 0x7014, 0xa005, 0x1148, 0x7010, 0x7310, 0xa306,
-	0x1de0, 0x2300, 0xa005, 0x0128, 0xa102, 0x1e20, 0x7007, 0x0010,
-	0x0030, 0x8aff, 0x0148, 0x080c, 0x4046, 0x1de8, 0x09d8, 0x080c,
-	0x3e58, 0x012e, 0x2000, 0x0005, 0x7204, 0x7108, 0xc19c, 0x8103,
-	0x1218, 0x080c, 0x3e9e, 0x0cc0, 0xa205, 0x1d88, 0x7007, 0x0004,
-	0x7003, 0x0008, 0x012e, 0x2000, 0x0005, 0x6428, 0x84ff, 0x0508,
-	0x2c70, 0x7004, 0xa0bc, 0x000f, 0xa7b8, 0x3e19, 0x273c, 0x87fb,
-	0x1148, 0x0210, 0x080c, 0x243b, 0x609c, 0xa075, 0x0190, 0x0c88,
-	0x2039, 0x3e0e, 0x2704, 0xae68, 0x6808, 0xa630, 0x680c, 0xa529,
-	0x8421, 0x0138, 0x8738, 0x2704, 0xa005, 0x1da8, 0x709c, 0xa075,
-	0x1d00, 0x0005, 0x0000, 0x0005, 0x0009, 0x000d, 0x0011, 0x0015,
-	0x0019, 0x001d, 0x0000, 0x0003, 0x0009, 0x000f, 0x0015, 0x001b,
-	0x0000, 0x0000, 0x3e0e, 0x3e0b, 0x0000, 0x0000, 0x8000, 0x0000,
-	0x3e0e, 0x0000, 0x3e16, 0x3e13, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x3e16, 0x0000, 0x3e11, 0x3e11, 0x0000, 0x0000, 0x8000, 0x0000,
-	0x3e11, 0x0000, 0x3e17, 0x3e17, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x3e17, 0x2079, 0x4300, 0x2071, 0x0010, 0x7007, 0x000a, 0x7007,
-	0x0002, 0x7003, 0x0001, 0x2009, 0x0002, 0x2071, 0x0050, 0x7007,
-	0x000a, 0x7007, 0x0002, 0x7003, 0x0000, 0x2001, 0x01ff, 0x2004,
-	0xd0fc, 0x1128, 0x8109, 0x0118, 0x2071, 0x0020, 0x0c80, 0x0005,
-	0x7004, 0x8004, 0x1690, 0x7007, 0x0012, 0x2019, 0x0000, 0x7108,
-	0x7008, 0xa106, 0x1de0, 0xa184, 0x01e0, 0x0110, 0x080c, 0x243b,
-	0xa19c, 0x300c, 0xa386, 0x2004, 0x0130, 0xa386, 0x0008, 0x0160,
-	0xa386, 0x200c, 0x1d60, 0x7200, 0x8204, 0x0230, 0x730c, 0xa384,
-	0x07ff, 0x0110, 0x080c, 0x243b, 0x7007, 0x0012, 0x7000, 0xd084,
-	0x1160, 0x7008, 0xa084, 0x01e0, 0x1140, 0x7310, 0x7014, 0xa305,
-	0x0120, 0x710c, 0xa184, 0x07ff, 0x1958, 0x7007, 0x0012, 0x7007,
-	0x0008, 0x7004, 0xd09c, 0x1de8, 0x7007, 0x0012, 0x7108, 0x8103,
-	0x0ed8, 0x7003, 0x0008, 0x0005, 0x7108, 0x0000, 0xa184, 0x01e0,
-	0x1550, 0x7108, 0xa184, 0x01e0, 0x1530, 0xa184, 0x0007, 0x0002,
-	0x3eb2, 0x3ec0, 0x3eb0, 0x3ec0, 0x3eb0, 0x3f06, 0x3eb0, 0x3f05,
-	0x080c, 0x243b, 0x7004, 0xa084, 0x0010, 0xc08d, 0x7006, 0x8aff,
-	0x1118, 0x2049, 0x0000, 0x0005, 0x080c, 0x4046, 0x1de8, 0x0005,
-	0x7004, 0xa084, 0x0010, 0xc08d, 0x7006, 0x8aff, 0x0118, 0x080c,
-	0x4046, 0x1de8, 0x0005, 0x7007, 0x0012, 0x7108, 0x1d04, 0x3ece,
-	0x2091, 0x6000, 0x1d04, 0x3ed2, 0x2091, 0x6000, 0x7007, 0x0012,
+	0x856e, 0x7121, 0x0014, 0x0704, 0x3008, 0x9cce, 0x0014, 0xa202,
+	0x8000, 0x85a4, 0x3009, 0x84a8, 0x19e2, 0xf844, 0x856e, 0x883f,
+	0x08e6, 0xa8f5, 0xf861, 0xa8eb, 0xf801, 0x0014, 0xf881, 0x0016,
+	0x85b2, 0x80f0, 0x9532, 0xfaa2, 0x1de2, 0x0014, 0x8532, 0xf221,
+	0x0014, 0x1de2, 0x84a8, 0xd6e0, 0x1fe6, 0x0014, 0x3008, 0x8000,
+	0x2849, 0x1011, 0xa8fc, 0x3008, 0x8000, 0xa000, 0x2081, 0x2802,
+	0x1011, 0xa8fc, 0xa889, 0x3008, 0x20a1, 0x283c, 0x1011, 0xa8fc,
+	0xa209, 0x0017, 0x300c, 0x8000, 0x85a4, 0x1de2, 0xdac1, 0x0014,
+	0x0210, 0xa801, 0x0014, 0x26e0, 0x873a, 0xfaa3, 0x19f2, 0x26e0,
+	0x18f2, 0x0014, 0xa20b, 0x0014, 0xa20d, 0x3806, 0x0210, 0x9d22,
+	0x0704, 0xa206, 0x6865, 0x817e, 0x842a, 0x1dc1, 0x8823, 0x0016,
+	0x6042, 0x8008, 0xa8fa, 0x8160, 0x842a, 0x8180, 0xf021, 0x3008,
+	0x84a8, 0x11d7, 0x7042, 0x20dd, 0x0011, 0x20d5, 0x8822, 0x0016,
+	0x0000, 0x0126, 0x70d0, 0xa084, 0x4c00, 0x8004, 0x2090, 0x7204,
+	0x7008, 0xc09c, 0xa205, 0x1178, 0x720c, 0x82ff, 0x0128, 0x8aff,
+	0x1150, 0x7200, 0xd284, 0x1138, 0x7007, 0x0004, 0x7003, 0x0008,
+	0x012e, 0x2000, 0x0005, 0x7000, 0xa084, 0x0003, 0x7002, 0xc69c,
+	0xd084, 0x0588, 0x7108, 0xe000, 0x7008, 0xa106, 0x1dd8, 0xa184,
+	0x0003, 0x0904, 0x3f50, 0xa184, 0x01e0, 0x1904, 0x3f50, 0xd1f4,
+	0x1d88, 0xa184, 0x3000, 0xa086, 0x1000, 0x0d60, 0x2011, 0x0180,
+	0x710c, 0x8211, 0x0130, 0x7008, 0xd0f4, 0x1d20, 0x700c, 0xa106,
+	0x0dc0, 0x7007, 0x0012, 0x7108, 0xe000, 0x7008, 0xa106, 0x1dd8,
+	0xa184, 0x0003, 0x0568, 0xd194, 0x0db0, 0xd1f4, 0x0548, 0x7007,
+	0x0002, 0x0880, 0x0428, 0x7108, 0xd1fc, 0x0130, 0x080c, 0x4053,
+	0x8aff, 0x0904, 0x3edf, 0x0cb8, 0x700c, 0xa08c, 0x07ff, 0x01e8,
+	0x7004, 0xd084, 0x0178, 0x7014, 0xa005, 0x1148, 0x7010, 0x7310,
+	0xa306, 0x1de0, 0x2300, 0xa005, 0x0128, 0xa102, 0x1e20, 0x7007,
+	0x0010, 0x0030, 0x8aff, 0x0148, 0x080c, 0x4212, 0x1de8, 0x09d8,
+	0x080c, 0x3fd9, 0x012e, 0x2000, 0x0005, 0x7204, 0x7108, 0xc19c,
+	0x8103, 0x1218, 0x7007, 0x0002, 0x0cc0, 0xa205, 0x1d88, 0x7007,
+	0x0004, 0x7003, 0x0008, 0x012e, 0x2000, 0x0005, 0x6428, 0x84ff,
+	0x0508, 0x2c70, 0x7004, 0xa0bc, 0x000f, 0xa7b8, 0x3f9a, 0x273c,
+	0x87fb, 0x1148, 0x0210, 0x080c, 0x252b, 0x609c, 0xa075, 0x0190,
+	0x0c88, 0x2039, 0x3f8f, 0x2704, 0xae68, 0x6808, 0xa630, 0x680c,
+	0xa529, 0x8421, 0x0138, 0x8738, 0x2704, 0xa005, 0x1da8, 0x709c,
+	0xa075, 0x1d00, 0x0005, 0x0000, 0x0005, 0x0009, 0x000d, 0x0011,
+	0x0015, 0x0019, 0x001d, 0x0000, 0x0003, 0x0009, 0x000f, 0x0015,
+	0x001b, 0x0000, 0x0000, 0x3f8f, 0x3f8c, 0x0000, 0x0000, 0x8000,
+	0x0000, 0x3f8f, 0x0000, 0x3f97, 0x3f94, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x3f97, 0x0000, 0x3f92, 0x3f92, 0x0000, 0x0000, 0x8000,
+	0x0000, 0x3f92, 0x0000, 0x3f98, 0x3f98, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x3f98, 0x2079, 0x4500, 0x2071, 0x0010, 0x7007, 0x000a,
+	0x7007, 0x0002, 0x7003, 0x0001, 0x2009, 0x0002, 0x2071, 0x0050,
+	0x7007, 0x000a, 0x7007, 0x0002, 0x7003, 0x0000, 0x2001, 0x01ff,
+	0x2004, 0xd0fc, 0x1128, 0x8109, 0x0118, 0x2071, 0x0020, 0x0c80,
+	0x0005, 0x7004, 0x8004, 0x1a04, 0x402f, 0x7108, 0x7008, 0xa106,
+	0x1de0, 0xa184, 0x01e0, 0x0120, 0x080c, 0x408b, 0x0804, 0x404f,
+	0x7007, 0x0012, 0x2019, 0x0000, 0x7108, 0x7008, 0xa106, 0x1de0,
+	0xa184, 0x01e0, 0x0120, 0x080c, 0x408b, 0x0804, 0x404f, 0xa19c,
+	0x300c, 0xa386, 0x2004, 0x0190, 0xa386, 0x0008, 0x01c0, 0x7004,
+	0xd084, 0x1148, 0x7108, 0x7008, 0xa106, 0x1de0, 0xa184, 0x0003,
+	0x0110, 0x0804, 0x408b, 0xa386, 0x200c, 0x19f0, 0x7200, 0x8204,
+	0x0230, 0x730c, 0xa384, 0x07ff, 0x0110, 0x080c, 0x252b, 0x7108,
+	0x7008, 0xa106, 0x1de0, 0xa184, 0x01e0, 0x0118, 0x080c, 0x408b,
+	0x0470, 0x7007, 0x0012, 0x7000, 0xd084, 0x1148, 0x7310, 0x7014,
+	0xa305, 0x0128, 0x710c, 0xa184, 0x07ff, 0x1904, 0x3fd9, 0x7108,
+	0x7008, 0xa106, 0x1de0, 0xa184, 0x01e0, 0x0118, 0x080c, 0x408b,
+	0x00b0, 0x7007, 0x0012, 0x7007, 0x0008, 0x7004, 0xd09c, 0x1de8,
+	0x7108, 0x7008, 0xa106, 0x1de0, 0xa184, 0x01e0, 0x0118, 0x080c,
+	0x408b, 0x0028, 0x7007, 0x0012, 0x7108, 0x8103, 0x0e88, 0x7003,
+	0x0008, 0x0005, 0x7108, 0xa184, 0x01e0, 0x15a8, 0x7108, 0xa184,
+	0x01e0, 0x1588, 0xa184, 0x0007, 0x0002, 0x4067, 0x4075, 0x4065,
+	0x4075, 0x4065, 0x40c5, 0x4065, 0x40c3, 0x080c, 0x252b, 0x7004,
+	0xa084, 0x0010, 0xc08d, 0x7006, 0x8aff, 0x1118, 0x2049, 0x0000,
+	0x0005, 0x080c, 0x4212, 0x1de8, 0x0005, 0x7004, 0xa084, 0x0010,
+	0xc08d, 0x7006, 0x7004, 0xd084, 0x1140, 0x7108, 0x7008, 0xa106,
+	0x1de0, 0xa184, 0x0003, 0x0108, 0x0030, 0x8aff, 0x0118, 0x080c,
+	0x4212, 0x1de8, 0x0005, 0x7007, 0x0012, 0x7108, 0x1d04, 0x408e,
+	0x2091, 0x6000, 0x1d04, 0x4092, 0x2091, 0x6000, 0x7007, 0x0012,
 	0x7007, 0x0008, 0x7004, 0xd09c, 0x1de8, 0x7007, 0x0012, 0x7108,
 	0xd1fc, 0x1dd8, 0x7003, 0x0000, 0x7000, 0xa005, 0x1130, 0x7004,
 	0xa005, 0x1118, 0x700c, 0xa005, 0x0108, 0x0c40, 0x2049, 0x0000,
 	0xb284, 0x0200, 0x0118, 0x2001, 0x0000, 0x0010, 0x2001, 0x0001,
-	0x080c, 0x397f, 0x6818, 0xa084, 0x8000, 0x0110, 0x681b, 0x0002,
-	0x0005, 0x080c, 0x243b, 0x080c, 0x243b, 0x04b9, 0x7210, 0x7114,
-	0x700c, 0xa09c, 0x07ff, 0x2800, 0xa300, 0xa211, 0xa189, 0x0000,
-	0x0461, 0x2704, 0x2c58, 0xac60, 0x6308, 0x2200, 0xa322, 0x630c,
-	0x2100, 0xa31b, 0x2400, 0xa305, 0x0140, 0x1238, 0x8412, 0x8210,
-	0x830a, 0xa189, 0x0000, 0x2b60, 0x0c58, 0x2b60, 0x8a07, 0x0006,
-	0x6004, 0xa084, 0x0008, 0x0118, 0xa7ba, 0x3e13, 0x0010, 0xa7ba,
-	0x3e0b, 0x000e, 0xa73d, 0x2c00, 0x6886, 0x6f8a, 0x6c92, 0x6b8e,
-	0x7007, 0x0012, 0x080c, 0x3e58, 0x0005, 0x8a50, 0x8739, 0x2704,
+	0x080c, 0x3b47, 0x681b, 0x0002, 0x2051, 0x0000, 0x0005, 0x080c,
+	0x252b, 0x080c, 0x252b, 0x080c, 0x4105, 0x7210, 0x7114, 0x700c,
+	0xa09c, 0x07ff, 0x2800, 0xa300, 0xa211, 0xa189, 0x0000, 0x04a9,
+	0x2704, 0x2c58, 0xac60, 0x6308, 0x2200, 0xa322, 0x630c, 0x2100,
+	0xa31b, 0x2400, 0xa305, 0x0140, 0x1238, 0x8412, 0x8210, 0x830a,
+	0xa189, 0x0000, 0x2b60, 0x0c58, 0x2b60, 0x8a07, 0x0006, 0x6004,
+	0xa084, 0x0008, 0x0118, 0xa7ba, 0x3f94, 0x0010, 0xa7ba, 0x3f8c,
+	0x000e, 0xa73d, 0x2c00, 0x6886, 0x6f8a, 0x6c92, 0x6b8e, 0x7108,
+	0x7008, 0xa106, 0x1de0, 0xa184, 0x01e0, 0x0110, 0x080c, 0x408b,
+	0x7007, 0x0012, 0x080c, 0x3fd9, 0x0005, 0x8a50, 0x8739, 0x2704,
 	0xa004, 0x1168, 0x6000, 0xa064, 0x1108, 0x2d60, 0x6004, 0xa084,
-	0x000f, 0xa080, 0x3e29, 0x203c, 0x87fb, 0x090c, 0x243b, 0x0005,
-	0x0126, 0x00d6, 0x70d4, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de,
+	0x000f, 0xa080, 0x3faa, 0x203c, 0x87fb, 0x090c, 0x252b, 0x0005,
+	0x0126, 0x00d6, 0x70d0, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de,
 	0x6884, 0x2060, 0x6888, 0x6b8c, 0x6c90, 0x8057, 0xaad4, 0x00ff,
 	0xa084, 0x00ff, 0x0006, 0x6804, 0xa084, 0x0008, 0x000e, 0x0118,
-	0xa0b8, 0x3e13, 0x0010, 0xa0b8, 0x3e0b, 0xb284, 0x0200, 0x0110,
+	0xa0b8, 0x3f94, 0x0010, 0xa0b8, 0x3f8c, 0xb284, 0x0200, 0x0110,
 	0x7e20, 0x0008, 0x7e24, 0xa6b5, 0x000c, 0x681c, 0xd0b4, 0x0108,
 	0xc685, 0x2400, 0xa305, 0x0520, 0x2c58, 0x2704, 0x6104, 0xac60,
 	0x6000, 0xa400, 0x701a, 0x6004, 0xa301, 0x701e, 0xa184, 0x0008,
 	0x0140, 0x6010, 0xa081, 0x0000, 0x7022, 0x6014, 0xa081, 0x0000,
 	0x7026, 0x6208, 0x2400, 0xa202, 0x7012, 0x620c, 0x2300, 0xa203,
-	0x7016, 0x7602, 0x7007, 0x0001, 0x2b60, 0x080c, 0x4067, 0x0010,
-	0x080c, 0x4046, 0x1de8, 0x012e, 0x2000, 0x0005, 0x0126, 0x00d6,
-	0x70d4, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de, 0x7007, 0x0004,
+	0x7016, 0x7602, 0x7007, 0x0001, 0x2b60, 0x080c, 0x423a, 0x0010,
+	0x080c, 0x4212, 0x1de8, 0x012e, 0x2000, 0x0005, 0x0126, 0x00d6,
+	0x70d0, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de, 0x7007, 0x0004,
 	0x7004, 0xd094, 0x1de8, 0x7003, 0x0008, 0x012e, 0x2000, 0x0005,
-	0x0126, 0x00d6, 0x70d4, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de,
+	0x0126, 0x00d6, 0x70d0, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de,
 	0x7e20, 0xb284, 0x0200, 0x1108, 0x7e24, 0xa6b5, 0x000c, 0x681c,
 	0xd0ac, 0x1118, 0xc685, 0x7003, 0x0000, 0x6828, 0x2050, 0x2d60,
-	0x6004, 0xa0bc, 0x000f, 0xa7b8, 0x3e19, 0x273c, 0x87fb, 0x1138,
-	0x0210, 0x080c, 0x243b, 0x689c, 0xa065, 0x0120, 0x0c88, 0x080c,
-	0x4046, 0x1de8, 0x012e, 0x2000, 0x0005, 0x0126, 0x0006, 0x0016,
-	0x00d6, 0x70d4, 0xa084, 0x4c00, 0x8004, 0x2090, 0x7e20, 0xb284,
+	0x6004, 0xa0bc, 0x000f, 0xa7b8, 0x3f9a, 0x273c, 0x87fb, 0x1138,
+	0x0210, 0x080c, 0x252b, 0x689c, 0xa065, 0x0120, 0x0c88, 0x080c,
+	0x4212, 0x1de8, 0x012e, 0x2000, 0x0005, 0x0126, 0x0006, 0x0016,
+	0x00d6, 0x70d0, 0xa084, 0x4c00, 0x8004, 0x2090, 0x7e20, 0xb284,
 	0x0200, 0x1108, 0x7e24, 0x00de, 0x003e, 0x004e, 0xa6b5, 0x000c,
 	0x681c, 0xd0b4, 0x0128, 0xc685, 0x7003, 0x0000, 0x7007, 0x0004,
-	0x2049, 0x3fe5, 0x6828, 0xa055, 0x05f0, 0x2d70, 0x2e60, 0x7004,
-	0xa0bc, 0x000f, 0xa7b8, 0x3e19, 0x273c, 0x87fb, 0x1140, 0x0210,
-	0x080c, 0x243b, 0x709c, 0xa075, 0x2060, 0x0568, 0x0c80, 0x2704,
-	0xae68, 0x6808, 0xa422, 0x680c, 0xa31b, 0x0268, 0x8a51, 0x1110,
-	0x080c, 0x243b, 0x8738, 0x2704, 0xa005, 0x1d90, 0x709c, 0xa075,
-	0x2060, 0x01c8, 0x08e0, 0x8422, 0x8420, 0x831a, 0xa399, 0x0000,
-	0x6908, 0x2400, 0xa122, 0x690c, 0x2300, 0xa11b, 0x1210, 0x080c,
-	0x243b, 0xb284, 0x0200, 0x0118, 0x2071, 0x0050, 0x0010, 0x2071,
-	0x0020, 0x0804, 0x3f79, 0x012e, 0x2000, 0x0005, 0x7008, 0xa084,
-	0x0003, 0xa086, 0x0003, 0x1108, 0x0005, 0x2704, 0xac78, 0x7800,
-	0x701a, 0x7804, 0x701e, 0x7808, 0x7012, 0x780c, 0x7016, 0x6004,
-	0xa084, 0x0008, 0x0120, 0x7810, 0x7022, 0x7814, 0x7026, 0x7602,
-	0x7004, 0xa084, 0x0010, 0xc085, 0x7006, 0x2079, 0x4300, 0x8a51,
-	0x01b0, 0x8738, 0x2704, 0xa005, 0x1168, 0x609c, 0xa005, 0x0180,
-	0x2060, 0x6004, 0xa084, 0x000f, 0xa080, 0x3e19, 0x203c, 0x87fb,
-	0x090c, 0x243b, 0x7008, 0xa084, 0x0003, 0xa086, 0x0003, 0x0005,
-	0x2051, 0x0000, 0x0005, 0x0126, 0x0006, 0x00d6, 0x70d4, 0xa084,
-	0x4c00, 0x8004, 0x2090, 0x00de, 0x008e, 0x7108, 0xa184, 0x0003,
-	0x1128, 0x6828, 0xa005, 0x0178, 0x0804, 0x3d6c, 0x7108, 0xd1fc,
-	0x0118, 0x080c, 0x3e9e, 0x0c88, 0x7007, 0x0010, 0x7108, 0xd1fc,
-	0x0de8, 0x080c, 0x3e9e, 0x7008, 0xa086, 0x0008, 0x1d30, 0x7000,
-	0xa005, 0x1d18, 0x7003, 0x0000, 0x2049, 0x0000, 0x012e, 0x2000,
-	0x0005, 0x0126, 0x0146, 0x0136, 0x0156, 0x00c6, 0x00d6, 0x70d4,
-	0xa084, 0x4c00, 0x8004, 0x2090, 0x00de, 0x2049, 0x40b1, 0xad80,
-	0x0011, 0x20a0, 0xb284, 0x0200, 0x0118, 0x2099, 0x0032, 0x0010,
-	0x2099, 0x0031, 0x700c, 0xa084, 0x07ff, 0x682a, 0x7007, 0x0008,
-	0x7007, 0x0002, 0x7003, 0x0001, 0x0118, 0x8000, 0x80ac, 0x53a5,
-	0x700c, 0xa084, 0x07ff, 0x0130, 0x7007, 0x0004, 0x7004, 0xa084,
-	0x0004, 0x1de0, 0x00ce, 0x2049, 0x0000, 0x7003, 0x0000, 0x015e,
-	0x013e, 0x014e, 0x012e, 0x2000, 0x0005, 0x2091, 0x8000, 0x2091,
-	0x6000, 0x78ac, 0xa005, 0x1168, 0x7974, 0x70d0, 0xa106, 0x1148,
-	0x781c, 0xa005, 0x0130, 0x781f, 0x0000, 0x0e04, 0x4101, 0x2091,
-	0x4080, 0x7830, 0x8001, 0x7832, 0x1904, 0x416b, 0x7834, 0x7832,
-	0x2061, 0x68c0, 0x2069, 0x4380, 0xc7fd, 0x68d0, 0xa005, 0x0128,
-	0x8001, 0x68d2, 0x1110, 0x080c, 0x42c4, 0x6800, 0xa084, 0x000f,
-	0x0168, 0xa086, 0x0001, 0x0150, 0x6844, 0xa00d, 0x0138, 0x2104,
-	0xa005, 0x0120, 0x8001, 0x200a, 0x0904, 0x425f, 0x6814, 0xa005,
-	0x01a8, 0x8001, 0x6816, 0x1190, 0x68a7, 0x0001, 0x00f6, 0xd7fc,
-	0x1118, 0x2079, 0x0200, 0x0010, 0x2079, 0x0100, 0x080c, 0x3aa0,
-	0x00fe, 0x6864, 0xa005, 0x0110, 0x080c, 0x2233, 0x6880, 0xa005,
-	0x0140, 0x8001, 0x6882, 0x1128, 0x6867, 0x0000, 0x68d4, 0xc0c5,
-	0x68d6, 0x68d4, 0xd0fc, 0x01b0, 0xc0fc, 0x68d6, 0x20a9, 0x0200,
-	0x6034, 0xa005, 0x0158, 0x8001, 0x6036, 0x68d4, 0xc0fd, 0x68d6,
-	0x1128, 0x6010, 0xa005, 0x0110, 0x080c, 0x2233, 0xace0, 0x0010,
-	0x1f04, 0x4150, 0xd7fc, 0x0138, 0x2061, 0x48c0, 0x2069, 0x4340,
-	0xc7fc, 0x0804, 0x410d, 0x0459, 0x7838, 0x8001, 0x783a, 0x11a0,
-	0x783c, 0x783a, 0x2061, 0x48c0, 0x2069, 0x4340, 0xc7fc, 0x680c,
-	0xa005, 0x0110, 0x080c, 0x41c9, 0xd7fc, 0x1130, 0x2061, 0x68c0,
-	0x2069, 0x4380, 0xc7fd, 0x0c98, 0x7810, 0xd0cc, 0x0168, 0xd0ac,
-	0x1120, 0xd0a4, 0x0148, 0xc0ad, 0x7812, 0x2091, 0x8001, 0x0e04,
-	0x4193, 0x080c, 0x1ffe, 0x0005, 0x2091, 0x8001, 0x0005, 0x7840,
-	0x8001, 0x7842, 0x1568, 0x7844, 0x7842, 0x2091, 0x8000, 0x2061,
-	0x48c0, 0x2069, 0x4340, 0xc7fc, 0x6810, 0xa005, 0x1110, 0x2001,
-	0x0101, 0x8001, 0x6812, 0xd7fc, 0x0118, 0xa080, 0x89d0, 0x0010,
-	0xa080, 0x88c0, 0x2040, 0x2004, 0xa065, 0x0150, 0x6024, 0xa005,
-	0x0120, 0x8001, 0x6026, 0x0904, 0x4207, 0x6000, 0x2c40, 0x0ca0,
-	0xd7fc, 0x1130, 0x2061, 0x68c0, 0x2069, 0x4380, 0xc7fd, 0x08e0,
-	0x0005, 0x2009, 0x0000, 0x20a9, 0x0200, 0x6008, 0xd09c, 0x0540,
-	0x6024, 0xa005, 0x0118, 0x8001, 0x6026, 0x0400, 0x6008, 0xc09c,
-	0xd084, 0x1110, 0xd0ac, 0x01a8, 0x600a, 0x6004, 0xa06d, 0x01c0,
-	0x00c6, 0x0016, 0x6010, 0x8001, 0x6012, 0x080c, 0x35ab, 0x2d00,
-	0x2c68, 0x2060, 0x080c, 0x1b85, 0x080c, 0x1d30, 0x001e, 0x00ce,
-	0x0038, 0xc0bd, 0x600a, 0xa18d, 0x0001, 0x0010, 0xa18d, 0x0100,
-	0xace0, 0x0010, 0x1f04, 0x41cd, 0xa184, 0x0001, 0x0130, 0xa18c,
-	0xfffe, 0x690e, 0x080c, 0x2233, 0x0008, 0x690e, 0x0005, 0x6800,
-	0xa005, 0x0120, 0x684c, 0xac06, 0x0904, 0x425f, 0x6864, 0xa005,
-	0x0120, 0x6027, 0x0001, 0x0804, 0x425c, 0x2c00, 0x687e, 0x6714,
-	0x6f76, 0x6017, 0x0000, 0x602b, 0x0000, 0x601b, 0x0006, 0x60b4,
-	0xa084, 0x3f00, 0x601e, 0x6020, 0xa084, 0x00ff, 0xa085, 0x0060,
-	0x6022, 0x6000, 0x2042, 0x080c, 0x1b1d, 0x6818, 0xa005, 0x0110,
-	0x8001, 0x681a, 0x6808, 0xc0a4, 0x680a, 0x6810, 0x7908, 0x8109,
-	0x790a, 0x8001, 0x1310, 0x080c, 0x243b, 0x6812, 0x1118, 0x7910,
-	0xc1a5, 0x7912, 0x602f, 0x0000, 0x6033, 0x0000, 0x2c68, 0x080c,
-	0x1d3d, 0xd7fc, 0x1118, 0x2069, 0x4340, 0x0010, 0x2069, 0x4380,
-	0x6910, 0xa184, 0x0100, 0x2001, 0x0006, 0x1118, 0x697a, 0x2001,
-	0x0004, 0x2708, 0x080c, 0x2228, 0x2091, 0x8001, 0x0005, 0x00d6,
-	0x694c, 0x2160, 0xd7fc, 0x1118, 0x2069, 0x0200, 0x0010, 0x2069,
-	0x0100, 0x080c, 0x23e1, 0x601b, 0x0006, 0x6858, 0xa084, 0x3f00,
-	0x601e, 0x6020, 0xa084, 0x00ff, 0xa085, 0x0048, 0x6022, 0x602f,
-	0x0000, 0x6033, 0x0000, 0x6830, 0xd0b4, 0x01b0, 0x684b, 0x0004,
-	0x20a9, 0x0014, 0x6848, 0xd094, 0x0110, 0x1f04, 0x4282, 0x684b,
-	0x0009, 0x20a9, 0x0014, 0x6848, 0xd084, 0x0110, 0x1f04, 0x428b,
-	0x20a9, 0x00fa, 0x1f04, 0x4292, 0x6808, 0xa084, 0xfffd, 0x680a,
-	0x681b, 0x0054, 0x00de, 0x6867, 0x0007, 0x2091, 0x8001, 0x0005,
-	0x2079, 0x4300, 0x00e1, 0x0089, 0x00a9, 0x2009, 0x0002, 0x2069,
-	0x4380, 0x680f, 0x0000, 0x6813, 0x0000, 0x6817, 0x0000, 0x8109,
-	0x0118, 0x2069, 0x4340, 0x0ca8, 0x0005, 0x2019, 0x00a3, 0x7b3a,
-	0x7b3e, 0x0005, 0x2019, 0x0033, 0x7b42, 0x7b46, 0x0005, 0x2019,
-	0x32dd, 0x7b32, 0x7b36, 0x0005, 0x6950, 0xa185, 0x0000, 0x0178,
-	0x00c6, 0x6ac0, 0x2264, 0x602b, 0x0000, 0x602f, 0x0000, 0x6008,
-	0xc0b5, 0x600a, 0x8210, 0x8109, 0x1da8, 0x6952, 0x00ce, 0x0005,
-	0x70ec, 0xd0dc, 0x1118, 0xd0d4, 0x0180, 0x0088, 0xae8e, 0x0100,
-	0x0130, 0x7814, 0xc0f5, 0x7816, 0xd0d4, 0x1170, 0x0050, 0x7814,
-	0xc0fd, 0x7816, 0xd0d4, 0x1140, 0x0020, 0xd0e4, 0x0138, 0x70a0,
-	0x70a2, 0x7804, 0xd08c, 0x0110, 0x681f, 0x000c, 0x0005, 0xaf67
+	0x2049, 0x41ad, 0x6828, 0xa055, 0x00d6, 0x0904, 0x420e, 0x2d70,
+	0x2e60, 0x7004, 0xa0bc, 0x000f, 0xa7b8, 0x3f9a, 0x273c, 0x87fb,
+	0x1140, 0x0210, 0x080c, 0x252b, 0x709c, 0xa075, 0x2060, 0x0570,
+	0x0c80, 0x2704, 0xae68, 0x6808, 0xa422, 0x680c, 0xa31b, 0x0268,
+	0x8a51, 0x1110, 0x080c, 0x252b, 0x8738, 0x2704, 0xa005, 0x1d90,
+	0x709c, 0xa075, 0x2060, 0x01d0, 0x08e0, 0x8422, 0x8420, 0x831a,
+	0xa399, 0x0000, 0x6908, 0x2400, 0xa122, 0x690c, 0x2300, 0xa11b,
+	0x1210, 0x080c, 0x252b, 0xb284, 0x0200, 0x0118, 0x2071, 0x0050,
+	0x0010, 0x2071, 0x0020, 0x00de, 0x0804, 0x4141, 0x00de, 0x012e,
+	0x2000, 0x0005, 0x7008, 0x0006, 0xa084, 0x01e0, 0x000e, 0x0110,
+	0xa006, 0x0005, 0xa084, 0x0003, 0xa086, 0x0003, 0x1108, 0x0005,
+	0x2704, 0xac78, 0x7800, 0x701a, 0x7804, 0x701e, 0x7808, 0x7012,
+	0x780c, 0x7016, 0x6004, 0xa084, 0x0008, 0x0120, 0x7810, 0x7022,
+	0x7814, 0x7026, 0x7602, 0x7004, 0xa084, 0x0010, 0xc085, 0x7006,
+	0x2079, 0x4500, 0x8a51, 0x01e8, 0x8738, 0x2704, 0xa005, 0x1168,
+	0x609c, 0xa005, 0x01b8, 0x2060, 0x6004, 0xa084, 0x000f, 0xa080,
+	0x3f9a, 0x203c, 0x87fb, 0x090c, 0x252b, 0x7008, 0x0006, 0xa084,
+	0x01e0, 0x000e, 0x0110, 0xa006, 0x0028, 0xa084, 0x0003, 0xa086,
+	0x0003, 0x0005, 0x2051, 0x0000, 0x0005, 0x0126, 0x0006, 0x00d6,
+	0x70d0, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de, 0x008e, 0x7108,
+	0xa184, 0x0003, 0x1128, 0x6828, 0xa005, 0x0178, 0x0804, 0x3ef3,
+	0x7108, 0xd1fc, 0x0118, 0x080c, 0x4053, 0x0c88, 0x7007, 0x0010,
+	0x7108, 0xd1fc, 0x0de8, 0x080c, 0x4053, 0x7008, 0xa086, 0x0008,
+	0x1d30, 0x7000, 0xa005, 0x1d18, 0x7003, 0x0000, 0x2049, 0x0000,
+	0x012e, 0x2000, 0x0005, 0x0126, 0x0146, 0x0136, 0x0156, 0x00c6,
+	0x00d6, 0x70d0, 0xa084, 0x4c00, 0x8004, 0x2090, 0x00de, 0x2049,
+	0x428b, 0xad80, 0x0011, 0x20a0, 0xb284, 0x0200, 0x0118, 0x2099,
+	0x0032, 0x0010, 0x2099, 0x0031, 0x700c, 0xa084, 0x07ff, 0x682a,
+	0x7007, 0x0008, 0x7007, 0x0002, 0x7003, 0x0001, 0x0118, 0x8000,
+	0x80ac, 0x53a5, 0x700c, 0xa084, 0x07ff, 0x0130, 0x7007, 0x0004,
+	0x7004, 0xa084, 0x0004, 0x1de0, 0x00ce, 0x2049, 0x0000, 0x7003,
+	0x0000, 0x015e, 0x013e, 0x014e, 0x012e, 0x2000, 0x0005, 0x2091,
+	0x8000, 0x2091, 0x6000, 0x78ac, 0xa005, 0x1168, 0x7974, 0x70d0,
+	0xa106, 0x1148, 0x781c, 0xa005, 0x0130, 0x781f, 0x0000, 0x0e04,
+	0x42db, 0x2091, 0x4080, 0x7830, 0x8001, 0x7832, 0x1904, 0x4345,
+	0x7834, 0x7832, 0x2061, 0x6ac0, 0x2069, 0x4580, 0xc7fd, 0x68cc,
+	0xa005, 0x0128, 0x8001, 0x68ce, 0x1110, 0x080c, 0x44ad, 0x6800,
+	0xa084, 0x000f, 0x0168, 0xa086, 0x0001, 0x0150, 0x6840, 0xa00d,
+	0x0138, 0x2104, 0xa005, 0x0120, 0x8001, 0x200a, 0x0904, 0x444a,
+	0x6814, 0xa005, 0x01a8, 0x8001, 0x6816, 0x1190, 0x68a3, 0x0001,
+	0x00f6, 0xd7fc, 0x1118, 0x2079, 0x0200, 0x0010, 0x2079, 0x0100,
+	0x080c, 0x3c0c, 0x00fe, 0x6860, 0xa005, 0x0110, 0x080c, 0x2296,
+	0x687c, 0xa005, 0x0140, 0x8001, 0x687e, 0x1128, 0x6863, 0x0000,
+	0x68d0, 0xc0c5, 0x68d2, 0x68d0, 0xd0fc, 0x01b0, 0xc0fc, 0x68d2,
+	0x20a9, 0x0200, 0x6034, 0xa005, 0x0158, 0x8001, 0x6036, 0x68d0,
+	0xc0fd, 0x68d2, 0x1128, 0x6010, 0xa005, 0x0110, 0x080c, 0x2296,
+	0xace0, 0x0010, 0x1f04, 0x432a, 0xd7fc, 0x0138, 0x2061, 0x4ac0,
+	0x2069, 0x4540, 0xc7fc, 0x0804, 0x42e7, 0x0459, 0x7838, 0x8001,
+	0x783a, 0x11a0, 0x783c, 0x783a, 0x2061, 0x4ac0, 0x2069, 0x4540,
+	0xc7fc, 0x680c, 0xa005, 0x0110, 0x080c, 0x43c1, 0xd7fc, 0x1130,
+	0x2061, 0x6ac0, 0x2069, 0x4580, 0xc7fd, 0x0c98, 0x7810, 0xd0cc,
+	0x0168, 0xd0ac, 0x1120, 0xd0a4, 0x0148, 0xc0ad, 0x7812, 0x2091,
+	0x8001, 0x0e04, 0x436d, 0x080c, 0x2061, 0x0005, 0x2091, 0x8001,
+	0x0005, 0x7840, 0x8001, 0x7842, 0x1904, 0x43c0, 0x7844, 0x7842,
+	0x2069, 0x4540, 0xc7fc, 0x2079, 0x0200, 0x68d4, 0xa005, 0x0138,
+	0x7de0, 0xa504, 0x1120, 0x68d6, 0x68d0, 0xc0bc, 0x68d2, 0x2079,
+	0x4500, 0x6810, 0xa005, 0x1110, 0x2001, 0x0101, 0x8001, 0x6812,
+	0xd7fc, 0x0118, 0xa080, 0x8bd0, 0x0010, 0xa080, 0x8ac0, 0x2040,
+	0x2004, 0xa065, 0x01e0, 0x6024, 0xa005, 0x01b0, 0x8001, 0x6026,
+	0x1198, 0x6800, 0xa005, 0x0130, 0x6848, 0xac06, 0x1118, 0x080c,
+	0x444a, 0x0068, 0x6860, 0xa005, 0x0118, 0x6027, 0x0001, 0x0020,
+	0x080c, 0x4402, 0x2804, 0x0c28, 0x6000, 0x2c40, 0x0c10, 0xd7fc,
+	0x1138, 0x2069, 0x4580, 0xc7fd, 0x2079, 0x0100, 0x0804, 0x437d,
+	0x0005, 0x2009, 0x0000, 0x20a9, 0x0200, 0x6008, 0xd09c, 0x0558,
+	0x6024, 0xa005, 0x0118, 0x8001, 0x6026, 0x0418, 0x6008, 0xc09c,
+	0xd084, 0x1110, 0xd0ac, 0x01c0, 0x600a, 0x6004, 0xa005, 0x01d8,
+	0x00d6, 0x00c6, 0x0016, 0x2068, 0x6010, 0x8001, 0x6012, 0x080c,
+	0x376c, 0x2d00, 0x2c68, 0x2060, 0x080c, 0x1bc7, 0x080c, 0x1d7c,
+	0x001e, 0x00ce, 0x00de, 0x0038, 0xc0bd, 0x600a, 0xa18d, 0x0001,
+	0x0010, 0xa18d, 0x0100, 0xace0, 0x0010, 0x1f04, 0x43c5, 0xa184,
+	0x0001, 0x0130, 0xa18c, 0xfffe, 0x690e, 0x080c, 0x2296, 0x0008,
+	0x690e, 0x0005, 0x2c00, 0x687a, 0x6714, 0x6f72, 0x6017, 0x0000,
+	0x602b, 0x0000, 0x601b, 0x0006, 0x60b4, 0xa084, 0x5f00, 0x601e,
+	0x6020, 0xa084, 0x00ff, 0xa085, 0x0060, 0x6022, 0x6000, 0x2042,
+	0x080c, 0x1b5f, 0x6818, 0xa005, 0x0110, 0x8001, 0x681a, 0x6808,
+	0xc0a4, 0x680a, 0x6810, 0x7908, 0x8109, 0x790a, 0x8001, 0x1310,
+	0x080c, 0x252b, 0x6812, 0x1118, 0x7910, 0xc1a5, 0x7912, 0x602f,
+	0x0000, 0x6033, 0x0000, 0x2c68, 0x080c, 0x1d89, 0xd7fc, 0x1118,
+	0x2069, 0x4540, 0x0010, 0x2069, 0x4580, 0x6910, 0xa184, 0x0100,
+	0x2001, 0x0006, 0x1118, 0x6976, 0x2001, 0x0004, 0x2708, 0x080c,
+	0x228b, 0x0005, 0x00d6, 0x6948, 0x2160, 0xd7fc, 0x1118, 0x2069,
+	0x0200, 0x0010, 0x2069, 0x0100, 0x080c, 0x2446, 0x601b, 0x0006,
+	0x6858, 0xa084, 0x5f00, 0x601e, 0x6020, 0xa084, 0x00ff, 0xa085,
+	0x0048, 0x6022, 0x602f, 0x0000, 0x6033, 0x0000, 0x6808, 0xa084,
+	0xfffd, 0x680a, 0x6830, 0xd0b4, 0x01b0, 0x684b, 0x0004, 0x20a9,
+	0x0014, 0x6848, 0xd094, 0x0110, 0x1f04, 0x4471, 0x684b, 0x0009,
+	0x20a9, 0x0014, 0x6848, 0xd084, 0x0110, 0x1f04, 0x447a, 0x20a9,
+	0x00fa, 0x1f04, 0x4481, 0x681b, 0x0054, 0x00de, 0x6863, 0x0007,
+	0x0005, 0x2079, 0x4500, 0x00e1, 0x0089, 0x00a9, 0x2009, 0x0002,
+	0x2069, 0x4580, 0x680f, 0x0000, 0x6813, 0x0000, 0x6817, 0x0000,
+	0x8109, 0x0118, 0x2069, 0x4540, 0x0ca8, 0x0005, 0x2019, 0x00a3,
+	0x7b3a, 0x7b3e, 0x0005, 0x2019, 0x0033, 0x7b42, 0x7b46, 0x0005,
+	0x2019, 0x32dd, 0x7b32, 0x7b36, 0x0005, 0x694c, 0xa185, 0x0000,
+	0x0158, 0x00c6, 0x6abc, 0x2264, 0x6008, 0xc0b5, 0x600a, 0x8210,
+	0x8109, 0x1dc8, 0x694e, 0x00ce, 0x0005, 0x70ec, 0xd0dc, 0x1118,
+	0xd0d4, 0x0190, 0x0098, 0xae8e, 0x0100, 0x0138, 0x7814, 0xc0f5,
+	0xc0c5, 0x7816, 0xd0d4, 0x11a8, 0x0088, 0x7814, 0xc0fd, 0xc0c5,
+	0x7816, 0xd0d4, 0x1170, 0x0050, 0xd0e4, 0x0168, 0x70e4, 0xa084,
+	0x01ff, 0xa086, 0x01ff, 0x0d38, 0x70a0, 0x70a2, 0x7804, 0xd08c,
+	0x0110, 0x681f, 0x000c, 0x0005, 0x69ca
 };
 #ifdef UNIQUE_FW_NAME
-unsigned short   fw12160i_length01 = 0x32f8;
+unsigned short   fw12160i_length01 = 0x34e5;
 #else
-unsigned short   risc_code_length01 = 0x32f8;
+unsigned short   risc_code_length01 = 0x34e5;
 #endif
 
diff -urN linux.orig/drivers/scsi/ql1280_fw.h linux/drivers/scsi/ql1280_fw.h
--- linux.orig/drivers/scsi/ql1280_fw.h	Mon Feb  7 20:45:28 2000
+++ linux/drivers/scsi/ql1280_fw.h	Mon Dec 17 20:27:41 2001
@@ -1,59 +1,117 @@
 /************************************************************************
+
  *									*
+
  * 	         --- ISP1240/1080/1280 Initiator Firmware ---           *
+
  *			      32 LUN Support				*
+
  *									*
+
  ************************************************************************
- * Copyright (C) 1999,2000 Qlogic, Corporation.
+
+ *									*
+
+ * Copyright (C) 1999,2000 Qlogic, Corporation
+
  * All rights reserved.
+
  *
+
  * Redistribution and use in source and binary forms are permitted provided
+
  * that the following conditions are met:
+
  * 1. Redistribution of source code must retain the above copyright
+
  *    notice, this list of conditions and the following disclaimer.
- * 2. The name of the author may not be used to endorse or promote products
+
+ * 2. Redistribution in binary form must reproduce the above copyright
+
+ *    notice, this list of conditions and the following disclaimer in the
+
+ *    documentation and/or other materials provided with the distribution.
+
+ * 3. The name of the author may not be used to endorse or promote products
+
  *    derived from this software without specific prior written permission
+
  *
+
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+
  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+
  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+
  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+
  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
  *									*
+
  ************************************************************************
+
  */
 
 
 /*
- *	Firmware Version 8.09.00 (18:29 Apr 16, 1999)
+ *	Firmware Version 8.13.08 (10:53 Jan 14, 2000)
  */
 
-unsigned short fw1280ei_version = 8*1024+9;
+#ifdef UNIQUE_FW_NAME
+unsigned short fw1280ei_version = 8*1024+13;
+#else
+unsigned short risc_code_version = 8*1024+13;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned char fw1280ei_version_str[] = {8,13,8};
+#else
+unsigned char firmware_version[] = {8,13,8};
+#endif
 
-unsigned char fw1280ei_version_str[] = {8,9,0};
+#ifdef UNIQUE_FW_NAME
+#define fw1280ei_VERSION_STRING "8.13.8"
+#else
+#define FW_VERSION_STRING "8.13.8"
+#endif
 
+#ifdef UNIQUE_FW_NAME
 unsigned short fw1280ei_addr01 = 0x1000 ;
+#else
+unsigned short risc_code_addr01 = 0x1000 ;
+#endif
 
+#ifdef UNIQUE_FW_NAME
 unsigned short fw1280ei_code01[] = { 
-	0x0078, 0x1041, 0x0000, 0x39e3, 0x0000, 0x2043, 0x4f50, 0x5952,
+#else
+unsigned short risc_code01[] = { 
+#endif
+	0x0078, 0x1041, 0x0000, 0x3c71, 0x0000, 0x2043, 0x4f50, 0x5952,
 	0x4947, 0x4854, 0x2031, 0x3939, 0x312c, 0x3139, 0x3932, 0x2c31,
 	0x3939, 0x332c, 0x3139, 0x3934, 0x2051, 0x4c4f, 0x4749, 0x4320,
 	0x434f, 0x5250, 0x4f52, 0x4154, 0x494f, 0x4e00, 0x2049, 0x5350,
 	0x3132, 0x3430, 0x2046, 0x6972, 0x6d77, 0x6172, 0x6520, 0x2056,
-	0x6572, 0x7369, 0x6f6e, 0x2030, 0x382e, 0x3039, 0x2020, 0x2043,
+	0x6572, 0x7369, 0x6f6e, 0x2030, 0x382e, 0x3133, 0x2020, 0x2043,
 	0x7573, 0x746f, 0x6d65, 0x7220, 0x4e6f, 0x2e20, 0x3030, 0x2050,
 	0x726f, 0x6475, 0x6374, 0x204e, 0x6f2e, 0x2020, 0x3030, 0x2020,
-	0x2400, 0x20c9, 0x93ff, 0x2001, 0x04fc, 0x2004, 0xa086, 0x1080,
+	0x2400, 0x20c9, 0x96ff, 0x2001, 0x04fc, 0x2004, 0xa086, 0x1080,
 	0x00c0, 0x1054, 0x2071, 0x0100, 0x70a0, 0x70a2, 0x20c1, 0x0010,
-	0x2089, 0x136a, 0x0078, 0x106d, 0x2001, 0x04fc, 0x2004, 0xa086,
+	0x2089, 0x1374, 0x0078, 0x106d, 0x2001, 0x04fc, 0x2004, 0xa086,
 	0x1280, 0x00c0, 0x1069, 0x2071, 0x0200, 0x70a0, 0x70a2, 0x2071,
-	0x0100, 0x70a0, 0x70a2, 0x20c1, 0x0010, 0x2089, 0x13ea, 0x0078,
-	0x106d, 0x20c1, 0x0020, 0x2089, 0x1312, 0x2071, 0x0010, 0x70c3,
+	0x0100, 0x70a0, 0x70a2, 0x20c1, 0x0010, 0x2089, 0x13f8, 0x0078,
+	0x106d, 0x20c1, 0x0020, 0x2089, 0x131c, 0x2071, 0x0010, 0x70c3,
 	0x0004, 0x70c7, 0x4953, 0x70cb, 0x5020, 0x70cf, 0x2020, 0x70d3,
 	0x0008, 0x2001, 0x04fe, 0x70d6, 0x20c1, 0x0021, 0x2019, 0x0000,
 	0x2009, 0xfeff, 0x2100, 0x200b, 0xa5a5, 0xa1ec, 0x7fff, 0x2d64,
@@ -61,1838 +119,1924 @@
 	0xa286, 0xa5a5, 0x0040, 0x10a4, 0xa386, 0x000f, 0x0040, 0x10a0,
 	0x2c6a, 0x2a5a, 0x20c1, 0x0020, 0x2019, 0x000f, 0x0078, 0x1080,
 	0x2c6a, 0x2a5a, 0x0078, 0x10a2, 0x2c6a, 0x2a5a, 0x2130, 0x2128,
-	0xa1a2, 0x4a00, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424,
-	0xa192, 0x9400, 0x2009, 0x0000, 0x2001, 0x0032, 0x1078, 0x2078,
-	0x2218, 0x2079, 0x4a00, 0x2fa0, 0x2408, 0x2011, 0x0000, 0x20a9,
-	0x0040, 0x42a4, 0x8109, 0x00c0, 0x10bf, 0x2001, 0x04fc, 0x2004,
-	0xa086, 0x1080, 0x00c0, 0x10db, 0x2071, 0x0100, 0x0d7e, 0x2069,
-	0x4a40, 0x1078, 0x49ae, 0x0d7f, 0x7810, 0xc0ed, 0x7812, 0x781b,
-	0x0064, 0x0078, 0x1100, 0x2001, 0x04fc, 0x2004, 0xa086, 0x1280,
-	0x00c0, 0x10fb, 0x7814, 0xc0ed, 0xc0d5, 0x7816, 0x781b, 0x0064,
-	0x2071, 0x0200, 0x0d7e, 0x2069, 0x4a40, 0x1078, 0x49ae, 0x2069,
-	0x4a80, 0x2071, 0x0100, 0x1078, 0x49ae, 0x7814, 0xc0d4, 0x7816,
-	0x0d7f, 0x0078, 0x1100, 0x7814, 0xc0e5, 0x7816, 0x781b, 0x003c,
-	0x7eca, 0x7cc2, 0x7bc6, 0x7867, 0x0000, 0x7800, 0xc08d, 0x7802,
-	0x2031, 0x0030, 0x78af, 0x0101, 0x7823, 0x0002, 0x7827, 0x0002,
-	0x2009, 0x0002, 0x2069, 0x4a40, 0x681b, 0x0003, 0x6823, 0x0007,
-	0x6827, 0x00fa, 0x682b, 0x0008, 0x682f, 0x0028, 0x6837, 0x0000,
-	0x683b, 0x0006, 0x6833, 0x0008, 0x683f, 0x0000, 0x8109, 0x0040,
-	0x1154, 0x68d3, 0x000a, 0x68c3, 0x4ac0, 0x2079, 0x4a00, 0x7814,
-	0xd0e4, 0x00c0, 0x113a, 0xd0ec, 0x00c0, 0x113e, 0x68d7, 0x7329,
-	0x0078, 0x1140, 0x68d7, 0x730d, 0x0078, 0x1140, 0x68d7, 0x7329,
-	0x68c7, 0x4fc0, 0x68cb, 0x4ec0, 0x68cf, 0x8fc0, 0x68ab, 0x9244,
-	0x68af, 0x9249, 0x68b3, 0x9244, 0x68b7, 0x9244, 0x68a7, 0x0001,
-	0x2069, 0x4a80, 0x0078, 0x1114, 0x68d3, 0x000a, 0x68c3, 0x4cc0,
-	0x7814, 0xd0e4, 0x00c0, 0x1160, 0x68d7, 0x7439, 0x0078, 0x1162,
-	0x68d7, 0x7419, 0x68c7, 0x6fc0, 0x68cb, 0x4f40, 0x68cf, 0x90d0,
-	0x68ab, 0x9249, 0x68af, 0x924e, 0x68b3, 0x9249, 0x68b7, 0x9249,
-	0x68a7, 0x0001, 0x7810, 0xd0ec, 0x00c0, 0x11b8, 0x7814, 0xd0e4,
-	0x00c0, 0x11aa, 0x0e7e, 0x2069, 0x4ec0, 0x2071, 0x0200, 0x70ec,
-	0xd0e4, 0x00c0, 0x118b, 0x2019, 0x0c0c, 0x2021, 0x000c, 0x1078,
-	0x2007, 0x0078, 0x1191, 0x2019, 0x0c0a, 0x2021, 0x000a, 0x1078,
-	0x2007, 0x2069, 0x4f40, 0x2071, 0x0100, 0x70ec, 0xd0e4, 0x00c0,
-	0x11a1, 0x2019, 0x0c0c, 0x2021, 0x000c, 0x1078, 0x2007, 0x0078,
-	0x11a7, 0x2019, 0x0c0a, 0x2021, 0x000a, 0x1078, 0x2007, 0x0e7f,
-	0x0078, 0x11d1, 0x2019, 0x0c0c, 0x2021, 0x000c, 0x2069, 0x4ec0,
-	0x1078, 0x2007, 0x2069, 0x4f40, 0x1078, 0x2007, 0x0078, 0x11d1,
-	0x2069, 0x4ec0, 0x0e7e, 0x2071, 0x0100, 0x70ec, 0xd0e4, 0x00c0,
-	0x11ca, 0x2019, 0x0c0c, 0x2021, 0x000c, 0x1078, 0x2007, 0x0e7f,
-	0x0078, 0x11d1, 0x2019, 0x0c0a, 0x2021, 0x000a, 0x1078, 0x2007,
-	0x0e7f, 0x2011, 0x0002, 0x2069, 0x4fc0, 0x2009, 0x0002, 0x20a9,
-	0x0100, 0x683f, 0x0000, 0x680b, 0x0040, 0x7bc8, 0xa386, 0xfeff,
-	0x00c0, 0x11e8, 0x6817, 0x0100, 0x681f, 0x0064, 0x0078, 0x11ec,
-	0x6817, 0x0064, 0x681f, 0x0002, 0xade8, 0x0010, 0x00f0, 0x11d9,
-	0x8109, 0x00c0, 0x11d7, 0x8211, 0x0040, 0x11fa, 0x2069, 0x6fc0,
-	0x0078, 0x11d5, 0x1078, 0x2611, 0x1078, 0x441d, 0x1078, 0x1df2,
-	0x1078, 0x4957, 0x2091, 0x2100, 0x2079, 0x4a00, 0x7810, 0xd0ec,
-	0x0040, 0x120e, 0x2071, 0x0020, 0x0078, 0x1210, 0x2071, 0x0050,
-	0x2091, 0x2200, 0x2079, 0x4a00, 0x2071, 0x0020, 0x2091, 0x2300,
-	0x2079, 0x4a00, 0x7810, 0xd0ec, 0x0040, 0x1222, 0x2079, 0x0100,
-	0x0078, 0x1224, 0x2079, 0x0200, 0x2071, 0x4a40, 0x2091, 0x2400,
-	0x2079, 0x0100, 0x2071, 0x4a80, 0x2091, 0x2000, 0x2079, 0x4a00,
-	0x2071, 0x0010, 0x3200, 0xa085, 0x303d, 0x2090, 0x2071, 0x0010,
-	0x70c3, 0x0000, 0x0090, 0x1243, 0x70c0, 0xa086, 0x0002, 0x00c0,
-	0x1243, 0x1078, 0x159d, 0x2039, 0x0000, 0x7810, 0xd0ec, 0x00c0,
-	0x12c5, 0x1078, 0x1472, 0x78ac, 0xa005, 0x00c0, 0x1261, 0x0068,
-	0x1257, 0x786c, 0xa065, 0x0040, 0x1257, 0x1078, 0x2368, 0x1078,
-	0x209f, 0x0068, 0x126e, 0x786c, 0xa065, 0x0040, 0x1261, 0x1078,
-	0x2368, 0x0068, 0x126e, 0x2009, 0x4a47, 0x2011, 0x4a87, 0x2104,
-	0x220c, 0xa105, 0x0040, 0x126e, 0x1078, 0x1f1e, 0x2071, 0x4a40,
-	0x70a4, 0xa005, 0x0040, 0x1293, 0x7450, 0xa485, 0x0000, 0x0040,
-	0x1293, 0x2079, 0x0200, 0x2091, 0x8000, 0x72d4, 0xa28c, 0x303d,
-	0x2190, 0x1078, 0x2a9c, 0x2091, 0x8000, 0x2091, 0x303d, 0x0068,
-	0x1293, 0x2079, 0x4a00, 0x786c, 0xa065, 0x0040, 0x1293, 0x2071,
-	0x0010, 0x1078, 0x2368, 0x00e0, 0x129b, 0x2079, 0x4a00, 0x2071,
-	0x0010, 0x1078, 0x4765, 0x2071, 0x4a80, 0x70a4, 0xa005, 0x0040,
-	0x12b3, 0x7050, 0xa025, 0x0040, 0x12b3, 0x2079, 0x0100, 0x2091,
-	0x8000, 0x72d4, 0xa28c, 0x303d, 0x2190, 0x1078, 0x2a9c, 0x2091,
-	0x8000, 0x2091, 0x303d, 0x2079, 0x4a00, 0x2071, 0x0010, 0x0068,
-	0x12bf, 0x786c, 0xa065, 0x0040, 0x12bf, 0x1078, 0x2368, 0x00e0,
-	0x1249, 0x1078, 0x4765, 0x0078, 0x1249, 0x1078, 0x1472, 0x78ac,
-	0xa005, 0x00c0, 0x12dd, 0x0068, 0x12d3, 0x786c, 0xa065, 0x0040,
-	0x12d3, 0x1078, 0x2368, 0x1078, 0x209f, 0x0068, 0x12e7, 0x786c,
-	0xa065, 0x0040, 0x12dd, 0x1078, 0x2368, 0x0068, 0x12e7, 0x2009,
-	0x4a47, 0x2104, 0xa005, 0x0040, 0x12e7, 0x1078, 0x1f1e, 0x2071,
-	0x4a40, 0x70a4, 0xa005, 0x0040, 0x1302, 0x7450, 0xa485, 0x0000,
-	0x0040, 0x1302, 0x2079, 0x0100, 0x2091, 0x8000, 0x72d4, 0xa28c,
-	0x303d, 0x2190, 0x1078, 0x2a9c, 0x2091, 0x8000, 0x2091, 0x303d,
-	0x2079, 0x4a00, 0x2071, 0x0010, 0x0068, 0x130c, 0x786c, 0xa065,
-	0x0040, 0x130c, 0x1078, 0x2368, 0x00e0, 0x12c5, 0x1078, 0x4765,
-	0x0078, 0x12c5, 0x1332, 0x1332, 0x1334, 0x1334, 0x1341, 0x1341,
-	0x1341, 0x1341, 0x134c, 0x134c, 0x1359, 0x1359, 0x1341, 0x1341,
-	0x1341, 0x1341, 0x1332, 0x1332, 0x1334, 0x1334, 0x1341, 0x1341,
-	0x1341, 0x1341, 0x134c, 0x134c, 0x1359, 0x1359, 0x1341, 0x1341,
-	0x1341, 0x1341, 0x0078, 0x1332, 0x007e, 0x107e, 0x127e, 0x2091,
-	0x2400, 0x1078, 0x290b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001,
-	0x007c, 0x007e, 0x107e, 0x127e, 0x1078, 0x13ba, 0x127f, 0x107f,
-	0x007f, 0x2091, 0x8001, 0x007c, 0x007e, 0x107e, 0x127e, 0x2091,
-	0x2300, 0x1078, 0x290b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001,
-	0x007c, 0x007e, 0x107e, 0x127e, 0x2091, 0x2300, 0x1078, 0x290b,
-	0x2091, 0x2400, 0x1078, 0x290b, 0x127f, 0x107f, 0x007f, 0x2091,
-	0x8001, 0x007c, 0x138a, 0x138a, 0x138c, 0x138c, 0x1399, 0x1399,
-	0x1399, 0x1399, 0x13a4, 0x13a4, 0x138c, 0x138c, 0x1399, 0x1399,
-	0x1399, 0x1399, 0x13a5, 0x13a5, 0x13a5, 0x13a5, 0x13a5, 0x13a5,
-	0x13a5, 0x13a5, 0x13a5, 0x13a5, 0x13a5, 0x13a5, 0x13a5, 0x13a5,
-	0x13a5, 0x13a5, 0x0078, 0x138a, 0x007e, 0x107e, 0x127e, 0x2091,
-	0x2300, 0x1078, 0x290b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001,
-	0x007c, 0x007e, 0x107e, 0x127e, 0x1078, 0x13c7, 0x127f, 0x107f,
-	0x007f, 0x2091, 0x8001, 0x007c, 0x007c, 0x107e, 0x127e, 0x0d7e,
-	0x0e7e, 0x0f7e, 0x007e, 0x2071, 0x0100, 0x2069, 0x4a40, 0x2079,
-	0x4a00, 0x1078, 0x49ae, 0x007f, 0x0f7f, 0x0e7f, 0x0d7f, 0x127f,
-	0x107f, 0x007c, 0x3c00, 0xa084, 0x0007, 0x0079, 0x13bf, 0x13d0,
-	0x13d0, 0x13d2, 0x13d2, 0x13d7, 0x13d7, 0x13dc, 0x13dc, 0x3c00,
-	0xa084, 0x0003, 0x0079, 0x13cc, 0x13d0, 0x13d0, 0x13e5, 0x13e5,
-	0x1078, 0x28ec, 0x2091, 0x2200, 0x1078, 0x44b7, 0x007c, 0x2091,
-	0x2100, 0x1078, 0x44b7, 0x007c, 0x2091, 0x2100, 0x1078, 0x44b7,
-	0x2091, 0x2200, 0x1078, 0x44b7, 0x007c, 0x2091, 0x2100, 0x1078,
-	0x44b7, 0x007c, 0x140a, 0x140a, 0x140c, 0x140c, 0x1419, 0x1419,
-	0x1419, 0x1419, 0x1424, 0x1424, 0x1431, 0x1431, 0x1419, 0x1419,
-	0x1419, 0x1419, 0x1442, 0x1442, 0x1442, 0x1442, 0x1442, 0x1442,
-	0x1442, 0x1442, 0x1442, 0x1442, 0x1442, 0x1442, 0x1442, 0x1442,
-	0x1442, 0x1442, 0x0078, 0x140a, 0x007e, 0x107e, 0x127e, 0x2091,
-	0x2400, 0x1078, 0x290b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001,
-	0x007c, 0x007e, 0x107e, 0x127e, 0x1078, 0x13ba, 0x127f, 0x107f,
-	0x007f, 0x2091, 0x8001, 0x007c, 0x007e, 0x107e, 0x127e, 0x2091,
-	0x2300, 0x1078, 0x290b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001,
-	0x007c, 0x007e, 0x107e, 0x127e, 0x2091, 0x2300, 0x1078, 0x290b,
-	0x2091, 0x2400, 0x1078, 0x290b, 0x127f, 0x107f, 0x007f, 0x2091,
-	0x8001, 0x007c, 0x007e, 0x107e, 0x127e, 0x0d7e, 0x0e7e, 0x0f7e,
-	0x2079, 0x4a00, 0x2071, 0x0200, 0x2069, 0x4a40, 0x3d00, 0xd08c,
-	0x00c0, 0x1456, 0x2069, 0x4a80, 0x2071, 0x0100, 0x1078, 0x49ae,
-	0x0f7f, 0x0e7f, 0x0d7f, 0x127f, 0x107f, 0x007f, 0x007c, 0x7008,
-	0x800b, 0x00c8, 0x146d, 0x7007, 0x0002, 0xa08c, 0x01e0, 0x00c0,
-	0x146e, 0xd09c, 0x0040, 0x146d, 0x087a, 0x097a, 0x70c3, 0x4002,
-	0x0078, 0x15a0, 0x0068, 0x14f7, 0x2061, 0x0000, 0x6018, 0xd084,
-	0x00c0, 0x14f7, 0x7828, 0xa005, 0x00c0, 0x1482, 0x0010, 0x14f8,
-	0x0078, 0x14f7, 0x7910, 0xd1f4, 0x0040, 0x148a, 0x2001, 0x4007,
-	0x0078, 0x159f, 0x7914, 0xd1ec, 0x0040, 0x14a5, 0xd0fc, 0x0040,
-	0x149b, 0x007e, 0x1078, 0x1d82, 0x007f, 0x0040, 0x14a5, 0x2001,
-	0x4007, 0x0078, 0x159f, 0x007e, 0x1078, 0x1d72, 0x007f, 0x0040,
-	0x14a5, 0x2001, 0x4007, 0x0078, 0x159f, 0x7910, 0xd0fc, 0x00c0,
-	0x14af, 0x2061, 0x4a40, 0xc19c, 0xc7fc, 0x0078, 0x14b3, 0x2061,
-	0x4a80, 0xc19d, 0xc7fd, 0x6064, 0xa005, 0x00c0, 0x14f7, 0x7912,
-	0x6083, 0x0000, 0x7828, 0xc0fc, 0xa086, 0x0018, 0x00c0, 0x14c4,
-	0x0c7e, 0x1078, 0x1b13, 0x0c7f, 0x782b, 0x0000, 0x607c, 0xa065,
-	0x0040, 0x14dd, 0x0c7e, 0x609c, 0x1078, 0x1e5d, 0x0c7f, 0x609f,
-	0x0000, 0x1078, 0x1c3f, 0x2009, 0x0018, 0x6087, 0x0103, 0x1078,
-	0x1d92, 0x00c0, 0x14f1, 0x1078, 0x1de4, 0x7810, 0xd09c, 0x00c0,
-	0x14e5, 0x2061, 0x4a40, 0x0078, 0x14e9, 0x2061, 0x4a80, 0xc09c,
-	0x7812, 0x607f, 0x0000, 0x60d4, 0xd0dc, 0x0040, 0x14f5, 0xc0dc,
-	0x60d6, 0x2001, 0x4005, 0x0078, 0x159f, 0x0078, 0x159d, 0x007c,
-	0x7810, 0xd0f4, 0x0040, 0x1500, 0x2001, 0x4007, 0x0078, 0x159f,
-	0xa006, 0x70c2, 0x70c6, 0x70ca, 0x70ce, 0x70da, 0x70c0, 0xa08a,
-	0x0040, 0x00c8, 0x150d, 0x0079, 0x1514, 0x2100, 0xa08a, 0x0040,
-	0x00c8, 0x15ab, 0x0079, 0x1554, 0x159d, 0x15f3, 0x15bc, 0x162b,
-	0x1663, 0x1663, 0x15b3, 0x1c57, 0x166e, 0x15ab, 0x15c0, 0x15c2,
-	0x15c4, 0x15c6, 0x1c5c, 0x15ab, 0x167c, 0x16d4, 0x1b35, 0x1c51,
-	0x15c8, 0x19a7, 0x19e9, 0x1a1f, 0x1a6b, 0x1962, 0x196f, 0x1983,
-	0x1996, 0x17a4, 0x1cdc, 0x1706, 0x1713, 0x171f, 0x172b, 0x1741,
-	0x174d, 0x1750, 0x175c, 0x1768, 0x1770, 0x178c, 0x1798, 0x15ab,
-	0x15ab, 0x15ab, 0x15ab, 0x17b1, 0x17c3, 0x17df, 0x1815, 0x183d,
-	0x184d, 0x1850, 0x1881, 0x18b2, 0x18c4, 0x1931, 0x1941, 0x1d32,
-	0x15ab, 0x15ab, 0x15ab, 0x1951, 0x15ab, 0x15ab, 0x15ab, 0x15ab,
-	0x15ab, 0x1c81, 0x1c87, 0x15ab, 0x15ab, 0x15ab, 0x1c8b, 0x1cd8,
-	0x15ab, 0x15ab, 0x1ce8, 0x1cf7, 0x15ed, 0x165d, 0x1676, 0x16ce,
-	0x1b2f, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x1d39, 0x1c73, 0x1c7d,
-	0x15ab, 0x15ab, 0x1d02, 0x1d1b, 0x15ab, 0x15ab, 0x15ab, 0x15ab,
-	0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab,
-	0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab,
-	0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x15ab,
-	0x15ab, 0x15ab, 0x15ab, 0x15ab, 0x72ca, 0x71c6, 0x2001, 0x4006,
-	0x0078, 0x159f, 0x73ce, 0x72ca, 0x71c6, 0x2001, 0x4000, 0x70c2,
-	0x0068, 0x15a0, 0x2061, 0x0000, 0x601b, 0x0001, 0x2091, 0x5000,
-	0x2091, 0x4080, 0x007c, 0x70c3, 0x4001, 0x0078, 0x15a0, 0x70c3,
-	0x4006, 0x0078, 0x15a0, 0x2099, 0x0041, 0x20a1, 0x0041, 0x20a9,
-	0x0005, 0x53a3, 0x0078, 0x159d, 0x70c4, 0x70c3, 0x0004, 0x007a,
-	0x0078, 0x159d, 0x0078, 0x159d, 0x0078, 0x159d, 0x0078, 0x159d,
-	0x2091, 0x8000, 0x70c3, 0x0004, 0x70c7, 0x4953, 0x70cb, 0x5020,
-	0x70cf, 0x2020, 0x70d3, 0x0008, 0x2001, 0x0009, 0x70d6, 0x2079,
-	0x0000, 0x781b, 0x0001, 0x2031, 0x0030, 0x2059, 0x1000, 0x2029,
-	0x041a, 0x2051, 0x0445, 0x2061, 0x0447, 0x20c1, 0x0020, 0x2091,
-	0x5000, 0x2091, 0x4080, 0x0078, 0x0418, 0x75d8, 0x74dc, 0x75da,
-	0x74de, 0x0078, 0x15f6, 0x2029, 0x0000, 0x2520, 0x71d0, 0x72c8,
-	0x73cc, 0x70c4, 0x20a0, 0x2099, 0x0030, 0x7003, 0x0001, 0x7007,
-	0x0006, 0x731a, 0x721e, 0x7422, 0x7526, 0x2021, 0x0040, 0x81ff,
-	0x0040, 0x159d, 0xa182, 0x0040, 0x00c8, 0x1610, 0x2120, 0xa006,
-	0x2008, 0x8403, 0x7012, 0x7007, 0x0004, 0x7007, 0x0001, 0x7008,
-	0xd0fc, 0x0040, 0x1617, 0x7007, 0x0002, 0xa084, 0x01e0, 0x0040,
-	0x1625, 0x70c3, 0x4002, 0x0078, 0x15a0, 0x24a8, 0x53a5, 0x0078,
-	0x1607, 0x0078, 0x159d, 0x2029, 0x0000, 0x2520, 0x71d0, 0x72c8,
-	0x73cc, 0x70c4, 0x2098, 0x20a1, 0x0030, 0x7003, 0x0000, 0x7007,
-	0x0006, 0x731a, 0x721e, 0x7422, 0x7526, 0x2021, 0x0040, 0x7007,
-	0x0006, 0x81ff, 0x0040, 0x159d, 0xa182, 0x0040, 0x00c8, 0x164a,
-	0x2120, 0xa006, 0x2008, 0x8403, 0x7012, 0x24a8, 0x53a6, 0x7007,
-	0x0001, 0x7008, 0xd0fc, 0x0040, 0x1651, 0xa084, 0x01e0, 0x0040,
-	0x163f, 0x70c3, 0x4002, 0x0078, 0x15a0, 0x75d8, 0x74dc, 0x75da,
-	0x74de, 0x0078, 0x162e, 0x71c4, 0x70c8, 0x2114, 0xa79e, 0x0004,
-	0x00c0, 0x166b, 0x200a, 0x72ca, 0x0078, 0x159c, 0x70c7, 0x0008,
-	0x70cb, 0x0009, 0x70cf, 0x0000, 0x0078, 0x159d, 0x75d8, 0x76dc,
-	0x75da, 0x76de, 0x0078, 0x167f, 0x2029, 0x0000, 0x2530, 0x70c4,
-	0x72c8, 0x73cc, 0x74d0, 0x70c6, 0x72ca, 0x73ce, 0x74d2, 0xa005,
-	0x0040, 0x16c9, 0x8001, 0x7872, 0xa084, 0xfc00, 0x0040, 0x1697,
-	0x78ac, 0xc085, 0x78ae, 0x2001, 0x4005, 0x0078, 0x159f, 0x7b7e,
-	0x7a7a, 0x7e86, 0x7d82, 0x7c76, 0xa48c, 0xff00, 0x0040, 0x16af,
-	0x8407, 0x8004, 0x8004, 0x810c, 0x810c, 0x810f, 0xa118, 0xa291,
-	0x0000, 0xa6b1, 0x0000, 0xa581, 0x0000, 0x0078, 0x16b9, 0x8407,
-	0x8004, 0x8004, 0xa318, 0xa291, 0x0000, 0xa6b1, 0x0000, 0xa581,
-	0x0000, 0x731a, 0x721e, 0x7622, 0x7026, 0xa605, 0x0040, 0x16c3,
-	0x7a10, 0xc2c5, 0x7a12, 0x78ac, 0xa084, 0xfffc, 0x78ae, 0x0078,
-	0x16cc, 0x78ac, 0xc085, 0x78ae, 0x0078, 0x159d, 0x75d8, 0x76dc,
-	0x75da, 0x76de, 0x0078, 0x16d7, 0x2029, 0x0000, 0x2530, 0x70c4,
-	0x72c8, 0x73cc, 0x74d4, 0x70c6, 0x72ca, 0x73ce, 0x74d6, 0xa005,
-	0x0040, 0x1701, 0x8001, 0x7892, 0xa084, 0xfc00, 0x0040, 0x16ef,
-	0x78ac, 0xc0c5, 0x78ae, 0x2001, 0x4005, 0x0078, 0x159f, 0x7a9a,
-	0x7b9e, 0x7da2, 0x7ea6, 0x2600, 0xa505, 0x0040, 0x16fa, 0x7a10,
-	0xc2c5, 0x7a12, 0x7c96, 0x78ac, 0xa084, 0xfcff, 0x78ae, 0x0078,
-	0x1704, 0x78ac, 0xc0c5, 0x78ae, 0x0078, 0x159d, 0x2009, 0x0000,
-	0x786c, 0xa065, 0x0040, 0x1710, 0x8108, 0x6000, 0x0078, 0x1709,
-	0x7ac4, 0x0078, 0x159b, 0x2009, 0x4a48, 0x210c, 0x7810, 0xd0ec,
-	0x00c0, 0x159c, 0x2011, 0x4a88, 0x2214, 0x0078, 0x159b, 0x2009,
-	0x4a49, 0x210c, 0x7810, 0xd0ec, 0x00c0, 0x159c, 0x2011, 0x4a89,
-	0x2214, 0x0078, 0x159b, 0x2061, 0x4a40, 0x6128, 0x622c, 0x8214,
-	0x8214, 0x8214, 0x7810, 0xd0ec, 0x00c0, 0x173f, 0x2061, 0x4a80,
-	0x6328, 0x73da, 0x632c, 0x831c, 0x831c, 0x831c, 0x73de, 0x0078,
-	0x159b, 0x2009, 0x4a4c, 0x210c, 0x7810, 0xd0ec, 0x00c0, 0x159c,
-	0x2011, 0x4a8c, 0x2214, 0x0078, 0x159b, 0x7918, 0x0078, 0x159c,
-	0x2009, 0x4a4d, 0x210c, 0x7810, 0xd0ec, 0x00c0, 0x159c, 0x2011,
-	0x4a8d, 0x2214, 0x0078, 0x159b, 0x2009, 0x4a4e, 0x210c, 0x7810,
-	0xd0ec, 0x00c0, 0x159c, 0x2011, 0x4a8e, 0x2214, 0x0078, 0x159b,
-	0x7920, 0x7810, 0xd0ec, 0x00c0, 0x159c, 0x7a24, 0x0078, 0x159b,
-	0x71c4, 0xd1fc, 0x00c0, 0x1778, 0x2011, 0x4ec0, 0x0078, 0x177a,
-	0x2011, 0x4f40, 0x8107, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003,
-	0xa268, 0x6a00, 0x6804, 0xd09c, 0x0040, 0x1789, 0x6b08, 0x0078,
-	0x178a, 0x6b0c, 0x0078, 0x159a, 0x77c4, 0x1078, 0x1e02, 0x2091,
-	0x8000, 0x6b1c, 0x6a14, 0x2091, 0x8001, 0x2708, 0x0078, 0x159a,
-	0x2061, 0x4a40, 0x6118, 0x7810, 0xd0ec, 0x00c0, 0x159c, 0x2061,
-	0x4a80, 0x6218, 0x0078, 0x159b, 0x77c4, 0x1078, 0x1e02, 0x2091,
-	0x8000, 0x6908, 0x6a18, 0x6b10, 0x77da, 0x2091, 0x8001, 0x0078,
-	0x159a, 0x71c4, 0x2110, 0xa294, 0x000f, 0xa282, 0x0010, 0x00c8,
-	0x1595, 0x1078, 0x2729, 0xa384, 0x4000, 0x0040, 0x17c1, 0xa295,
-	0x0020, 0x0078, 0x159a, 0x71c4, 0x2100, 0xc0bc, 0xa082, 0x0010,
-	0x00c8, 0x1595, 0xd1bc, 0x00c0, 0x17d2, 0x2011, 0x4a48, 0x2204,
-	0x0078, 0x17d6, 0x2011, 0x4a88, 0x2204, 0xc0bd, 0x007e, 0x2100,
-	0xc0bc, 0x2012, 0x1078, 0x2686, 0x017f, 0x0078, 0x159c, 0x71c4,
-	0x2021, 0x4a49, 0x2404, 0x70c6, 0x2019, 0x0000, 0x0078, 0x17ee,
-	0x71c8, 0x2021, 0x4a89, 0x2404, 0x70ca, 0xc3fd, 0x2011, 0x180d,
-	0x20a9, 0x0008, 0x2204, 0xa106, 0x0040, 0x17fd, 0x8210, 0x00f0,
-	0x17f2, 0x71c4, 0x72c8, 0x0078, 0x1594, 0xa292, 0x180d, 0x027e,
-	0x2122, 0x017f, 0x1078, 0x26a7, 0x7810, 0xd0ec, 0x00c0, 0x180b,
-	0xd3fc, 0x0040, 0x17e8, 0x0078, 0x159d, 0x03e8, 0x00fa, 0x01f4,
-	0x02ee, 0x0064, 0x0019, 0x0032, 0x004b, 0x2061, 0x4a40, 0x6128,
-	0x622c, 0x8214, 0x8214, 0x8214, 0x70c4, 0x602a, 0x70c8, 0x8003,
-	0x8003, 0x8003, 0x602e, 0x7810, 0xd0ec, 0x00c0, 0x183b, 0x027e,
-	0x017e, 0x2061, 0x4a80, 0x6128, 0x622c, 0x8214, 0x8214, 0x8214,
-	0x70d8, 0x602a, 0x70dc, 0x8003, 0x8003, 0x8003, 0x602e, 0x71da,
-	0x72de, 0x017f, 0x027f, 0x0078, 0x159b, 0x2061, 0x4a40, 0x6130,
-	0x70c4, 0x6032, 0x7810, 0xd0ec, 0x00c0, 0x159c, 0x2061, 0x4a80,
-	0x6230, 0x70c8, 0x6032, 0x0078, 0x159b, 0x7918, 0x0078, 0x159c,
-	0x71c4, 0xa184, 0xffcf, 0x0040, 0x185c, 0x7810, 0xd0ec, 0x00c0,
-	0x1595, 0x72c8, 0x0078, 0x1594, 0x2011, 0x4a4d, 0x2204, 0x2112,
-	0x007e, 0x2019, 0x0000, 0x1078, 0x270e, 0x7810, 0xd0ec, 0x0040,
-	0x186c, 0x017f, 0x0078, 0x159c, 0x71c8, 0xa184, 0xffcf, 0x0040,
-	0x1875, 0x2110, 0x71c4, 0x0078, 0x1594, 0x2011, 0x4a8d, 0x2204,
-	0x2112, 0x007e, 0xc3fd, 0x1078, 0x270e, 0x027f, 0x017f, 0x0078,
-	0x159b, 0x71c4, 0xa182, 0x0010, 0x0048, 0x188d, 0x7810, 0xd0ec,
-	0x00c0, 0x1595, 0x72c8, 0x0078, 0x1594, 0x2011, 0x4a4e, 0x2204,
-	0x007e, 0x2112, 0x2019, 0x0000, 0x1078, 0x26ec, 0x7810, 0xd0ec,
-	0x0040, 0x189d, 0x017f, 0x0078, 0x159c, 0x71c8, 0xa182, 0x0010,
-	0x0048, 0x18a6, 0x2110, 0x71c4, 0x0078, 0x1594, 0x2011, 0x4a8e,
-	0x2204, 0x007e, 0x2112, 0xc3fd, 0x1078, 0x26ec, 0x027f, 0x017f,
-	0x0078, 0x159b, 0x71c4, 0x72c8, 0xa184, 0xfffd, 0x00c0, 0x1594,
-	0xa284, 0xfffd, 0x00c0, 0x1594, 0x2100, 0x7920, 0x7822, 0x2200,
-	0x7a24, 0x7826, 0x0078, 0x159b, 0x71c4, 0xd1fc, 0x00c0, 0x18cc,
-	0x2011, 0x4ec0, 0x0078, 0x18ce, 0x2011, 0x4f40, 0x8107, 0xa084,
-	0x000f, 0x8003, 0x8003, 0x8003, 0xa268, 0x2019, 0x0000, 0x72c8,
-	0xa284, 0x0080, 0x0040, 0x18e2, 0x6c14, 0x84ff, 0x00c0, 0x18e2,
-	0x6817, 0x0040, 0xa284, 0x0040, 0x0040, 0x18ec, 0x6c10, 0x84ff,
-	0x00c0, 0x18ec, 0x6813, 0x0001, 0x6800, 0x007e, 0xa226, 0x0040,
-	0x1909, 0x6a02, 0xd4ec, 0x0040, 0x18f6, 0xc3a5, 0xd4e4, 0x0040,
-	0x18fa, 0xc39d, 0xd4f4, 0x0040, 0x1909, 0x810f, 0xd2f4, 0x0040,
-	0x1905, 0x1078, 0x276b, 0x0078, 0x1909, 0x1078, 0x2749, 0x0078,
-	0x1909, 0x72cc, 0x6808, 0xa206, 0x0040, 0x1929, 0xa2a4, 0x00ff,
-	0x7814, 0xd0e4, 0x00c0, 0x191c, 0xa482, 0x0028, 0x0048, 0x1926,
-	0x0040, 0x1926, 0x0078, 0x1920, 0xa482, 0x0043, 0x0048, 0x1926,
-	0x71c4, 0x71c6, 0x027f, 0x72ca, 0x0078, 0x1596, 0x6a0a, 0xa39d,
-	0x000a, 0x6804, 0xa305, 0x6806, 0x027f, 0x6b0c, 0x71c4, 0x0078,
-	0x159a, 0x77c4, 0x1078, 0x1e02, 0x2091, 0x8000, 0x6a14, 0x6b1c,
-	0x2091, 0x8001, 0x70c8, 0x6816, 0x70cc, 0x681e, 0x2708, 0x0078,
-	0x159a, 0x70c4, 0x2061, 0x4a40, 0x6118, 0x601a, 0x7810, 0xd0ec,
-	0x00c0, 0x159c, 0x70c8, 0x2061, 0x4a80, 0x6218, 0x601a, 0x0078,
-	0x159b, 0x71c4, 0x72c8, 0x73cc, 0xa182, 0x0010, 0x00c8, 0x1595,
-	0x1078, 0x278d, 0xa384, 0x4000, 0x0040, 0x1960, 0xa295, 0x0020,
-	0x0078, 0x159a, 0x77c4, 0x1078, 0x1e02, 0x2091, 0x8000, 0x6a08,
-	0xc28d, 0x6a0a, 0x2091, 0x8001, 0x2708, 0x0078, 0x159b, 0x77c4,
-	0x1078, 0x1e02, 0x2091, 0x8000, 0x6a08, 0xa294, 0xfff9, 0x6a0a,
-	0x6804, 0xa005, 0x0040, 0x197e, 0x1078, 0x25de, 0x2091, 0x8001,
-	0x2708, 0x0078, 0x159b, 0x77c4, 0x1078, 0x1e02, 0x2091, 0x8000,
-	0x6a08, 0xc295, 0x6a0a, 0x6804, 0xa005, 0x0040, 0x1991, 0x1078,
-	0x25de, 0x2091, 0x8001, 0x2708, 0x0078, 0x159b, 0x77c4, 0x2041,
-	0x0001, 0x2049, 0x0005, 0x2051, 0x0020, 0x2091, 0x8000, 0x1078,
-	0x1e1d, 0x2091, 0x8001, 0x2708, 0x6a08, 0x0078, 0x159b, 0x77c4,
-	0x7814, 0xd0e4, 0x00c0, 0x19bb, 0xd7fc, 0x0040, 0x19b5, 0x1078,
-	0x1d82, 0x0040, 0x19bb, 0x0078, 0x159f, 0x1078, 0x1d72, 0x0040,
-	0x19bb, 0x0078, 0x159f, 0x73c8, 0x72cc, 0x77c6, 0x73ca, 0x72ce,
-	0x1078, 0x1e9a, 0x00c0, 0x19e5, 0x6818, 0xa005, 0x0040, 0x19df,
-	0x2708, 0x077e, 0x1078, 0x27bd, 0x077f, 0x00c0, 0x19df, 0x2001,
-	0x0015, 0xd7fc, 0x00c0, 0x19d8, 0x2061, 0x4a40, 0x0078, 0x19db,
-	0xc0fd, 0x2061, 0x4a80, 0x782a, 0x2091, 0x8001, 0x007c, 0x2091,
-	0x8001, 0x2001, 0x4005, 0x0078, 0x159f, 0x2091, 0x8001, 0x0078,
-	0x159d, 0x77c4, 0x7814, 0xd0e4, 0x00c0, 0x19fd, 0xd7fc, 0x0040,
-	0x19f7, 0x1078, 0x1d82, 0x0040, 0x19fd, 0x0078, 0x159f, 0x1078,
-	0x1d72, 0x0040, 0x19fd, 0x0078, 0x159f, 0x77c6, 0x2041, 0x0021,
-	0x2049, 0x0005, 0x2051, 0x0020, 0x2091, 0x8000, 0x1078, 0x1e1d,
-	0x2009, 0x0016, 0xd7fc, 0x00c0, 0x1a11, 0x2061, 0x4a40, 0x0078,
-	0x1a14, 0x2061, 0x4a80, 0xc1fd, 0x6067, 0x0003, 0x6776, 0x6083,
-	0x000f, 0x792a, 0x1078, 0x25de, 0x2091, 0x8001, 0x007c, 0x77c8,
-	0x77ca, 0x77c4, 0x77c6, 0x7814, 0xd0e4, 0x00c0, 0x1a36, 0xd7fc,
-	0x0040, 0x1a30, 0x1078, 0x1d82, 0x0040, 0x1a36, 0x0078, 0x159f,
-	0x1078, 0x1d72, 0x0040, 0x1a36, 0x0078, 0x159f, 0xa7bc, 0xff00,
-	0x2091, 0x8000, 0x2009, 0x0017, 0xd7fc, 0x00c0, 0x1a43, 0x2061,
-	0x4a40, 0x0078, 0x1a46, 0x2061, 0x4a80, 0xc1fd, 0x6067, 0x0002,
-	0x6776, 0x6083, 0x000f, 0x792a, 0x1078, 0x25de, 0x2091, 0x8001,
-	0x2041, 0x0021, 0x2049, 0x0005, 0x2051, 0x0010, 0x2091, 0x8000,
-	0x70c8, 0xa005, 0x0040, 0x1a5f, 0x60d4, 0xc0fd, 0x60d6, 0x1078,
-	0x1e1d, 0x70c8, 0x683e, 0x8738, 0xa784, 0x001f, 0x00c0, 0x1a5f,
-	0x2091, 0x8001, 0x007c, 0x7814, 0xd0e4, 0x00c0, 0x1a7f, 0x72c8,
-	0xd284, 0x0040, 0x1a79, 0x1078, 0x1d82, 0x0040, 0x1a7f, 0x0078,
-	0x159f, 0x1078, 0x1d72, 0x0040, 0x1a7f, 0x0078, 0x159f, 0x72c8,
-	0x72ca, 0x78ac, 0xa084, 0x0003, 0x00c0, 0x1aaa, 0x2039, 0x0000,
-	0xd284, 0x0040, 0x1a8c, 0xc7fd, 0x2041, 0x0021, 0x2049, 0x0004,
-	0x2051, 0x0008, 0x1078, 0x1e02, 0x2091, 0x8000, 0x6808, 0xc0d4,
-	0xa80d, 0x690a, 0x2091, 0x8001, 0x8738, 0xa784, 0x001f, 0x00c0,
-	0x1a92, 0xa7bc, 0xff00, 0x873f, 0x8738, 0x873f, 0xa784, 0x0f00,
-	0x00c0, 0x1a92, 0x2091, 0x8000, 0x72c8, 0xd284, 0x00c0, 0x1abc,
-	0x7810, 0xd0ec, 0x0040, 0x1ab8, 0x2069, 0x0100, 0x0078, 0x1abe,
-	0x2069, 0x0200, 0x0078, 0x1abe, 0x2069, 0x0100, 0x6830, 0xd0b4,
-	0x0040, 0x1ada, 0x684b, 0x0004, 0x20a9, 0x0014, 0x6848, 0xd094,
-	0x0040, 0x1acc, 0x00f0, 0x1ac6, 0x684b, 0x0009, 0x20a9, 0x0014,
-	0x6848, 0xd084, 0x0040, 0x1ad6, 0x00f0, 0x1ad0, 0x20a9, 0x00fa,
-	0x00f0, 0x1ad8, 0x2079, 0x4a00, 0x2009, 0x0018, 0x72c8, 0xd284,
-	0x00c0, 0x1ae6, 0x2061, 0x4a40, 0x0078, 0x1ae9, 0x2061, 0x4a80,
-	0xc1fd, 0x792a, 0x6067, 0x0001, 0x6083, 0x000f, 0x60a7, 0x0000,
-	0x60a8, 0x60b2, 0x60b6, 0x60d4, 0xd0b4, 0x0040, 0x1b03, 0xc0b4,
-	0x60d6, 0x0c7e, 0x60b8, 0xa065, 0x6008, 0xc0d4, 0x600a, 0x6018,
-	0x8001, 0x601a, 0x0c7f, 0x60d4, 0xa084, 0x77ff, 0x60d6, 0x78ac,
-	0xc08d, 0x78ae, 0x6808, 0xa084, 0xfffd, 0x680a, 0x681b, 0x0047,
-	0x2091, 0x8001, 0x007c, 0xd7fc, 0x00c0, 0x1b1a, 0x2069, 0x4a40,
-	0x0078, 0x1b1c, 0x2069, 0x4a80, 0x78ac, 0xc08c, 0x78ae, 0xd084,
-	0x00c0, 0x1b26, 0x0d7e, 0x1078, 0x1efa, 0x0d7f, 0x71c4, 0x71c6,
-	0x6916, 0x81ff, 0x00c0, 0x1b2e, 0x68a7, 0x0001, 0x007c, 0x75d8,
-	0x74dc, 0x75da, 0x74de, 0x0078, 0x1b38, 0x2029, 0x0000, 0x2520,
-	0x71c4, 0x73c8, 0x72cc, 0x71c6, 0x73ca, 0x72ce, 0x2079, 0x4a00,
-	0x7dde, 0x7cda, 0x7bd6, 0x7ad2, 0x1078, 0x1ddb, 0x0040, 0x1c3b,
-	0x20a9, 0x0005, 0x20a1, 0x4a14, 0x2091, 0x8000, 0x41a1, 0x2091,
-	0x8001, 0x2009, 0x0040, 0x1078, 0x1fcf, 0x0040, 0x1b5b, 0x1078,
-	0x1de4, 0x0078, 0x1c3b, 0x6004, 0xa08c, 0x00ff, 0xa18e, 0x0009,
-	0x00c0, 0x1b66, 0x007e, 0x1078, 0x234b, 0x007f, 0xa084, 0xff00,
-	0x8007, 0x8009, 0x0040, 0x1bda, 0x0c7e, 0x2c68, 0x1078, 0x1ddb,
-	0x0040, 0x1bac, 0x2c00, 0x689e, 0x8109, 0x00c0, 0x1b6d, 0x609f,
-	0x0000, 0x0c7f, 0x0c7e, 0x7ddc, 0x7cd8, 0x7bd4, 0x7ad0, 0xa290,
-	0x0040, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x7dde,
-	0x7cda, 0x7bd6, 0x7ad2, 0x2c68, 0x689c, 0xa065, 0x0040, 0x1bd9,
-	0x2009, 0x0040, 0x1078, 0x1fcf, 0x00c0, 0x1bc3, 0x6004, 0xa084,
-	0x00ff, 0xa086, 0x0002, 0x00c0, 0x1bac, 0x6004, 0xa084, 0x00ff,
-	0xa086, 0x000a, 0x00c0, 0x1ba8, 0x017e, 0x1078, 0x2347, 0x017f,
-	0x2d00, 0x6002, 0x0078, 0x1b7b, 0x0c7f, 0x0c7e, 0x609c, 0x1078,
-	0x1e5d, 0x0c7f, 0x609f, 0x0000, 0x1078, 0x1c3f, 0x2009, 0x0018,
-	0x6008, 0xc0cd, 0x600a, 0x6004, 0x6086, 0x1078, 0x1d92, 0x1078,
-	0x1de4, 0x0078, 0x1c3b, 0x0c7f, 0x0c7e, 0x609c, 0x1078, 0x1e5d,
-	0x0c7f, 0x609f, 0x0000, 0x1078, 0x1c3f, 0x2009, 0x0018, 0x6087,
-	0x0103, 0x601b, 0x0003, 0x1078, 0x1d92, 0x1078, 0x1de4, 0x0078,
-	0x1c3b, 0x0c7f, 0x7814, 0xd0e4, 0x00c0, 0x1bff, 0x6114, 0xd1fc,
-	0x0040, 0x1be8, 0x1078, 0x1d82, 0x0040, 0x1bff, 0x0078, 0x1bec,
-	0x1078, 0x1d72, 0x0040, 0x1bff, 0x2029, 0x0000, 0x2520, 0x2009,
-	0x0018, 0x73c8, 0x72cc, 0x6087, 0x0103, 0x601b, 0x0021, 0x1078,
-	0x1d92, 0x1078, 0x1de4, 0x2001, 0x4007, 0x0078, 0x159f, 0x74c4,
-	0x73c8, 0x72cc, 0x6014, 0x2091, 0x8000, 0x0e7e, 0x2009, 0x0012,
-	0xd0fc, 0x00c0, 0x1c0f, 0x2071, 0x4a40, 0x0078, 0x1c12, 0x2071,
-	0x4a80, 0xc1fd, 0x792a, 0x7067, 0x0005, 0x71d4, 0xa18c, 0xf77f,
-	0x71d6, 0x736a, 0x726e, 0x7472, 0x7076, 0x707b, 0x0000, 0x2c00,
-	0x707e, 0xa02e, 0x2530, 0x611c, 0xa184, 0x0060, 0x0040, 0x1c2a,
-	0x1078, 0x43c1, 0x0e7f, 0x6596, 0x65a6, 0x669a, 0x66aa, 0x60af,
-	0x0000, 0x60b3, 0x0000, 0x6714, 0x6023, 0x0000, 0x1078, 0x25de,
-	0x2091, 0x8001, 0x007c, 0x70c3, 0x4005, 0x0078, 0x15a0, 0x20a9,
-	0x0005, 0x2099, 0x4a14, 0x2091, 0x8000, 0x530a, 0x2091, 0x8001,
-	0x2100, 0xa210, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000,
-	0x007c, 0x71c4, 0x70c7, 0x0000, 0x791e, 0x0078, 0x159d, 0x71c4,
-	0x71c6, 0x2168, 0x0078, 0x1c5e, 0x2069, 0x1000, 0x690c, 0xa016,
-	0x2d04, 0xa210, 0x8d68, 0x8109, 0x00c0, 0x1c60, 0xa285, 0x0000,
-	0x00c0, 0x1c6e, 0x70c3, 0x4000, 0x0078, 0x1c70, 0x70c3, 0x4003,
-	0x70ca, 0x0078, 0x15a0, 0x7964, 0x71c6, 0x71c4, 0xa182, 0x0003,
-	0x00c8, 0x1595, 0x7966, 0x0078, 0x159d, 0x7964, 0x71c6, 0x0078,
-	0x159d, 0x7900, 0x71c6, 0x71c4, 0x7902, 0x0078, 0x159d, 0x7900,
-	0x71c6, 0x0078, 0x159d, 0x70c4, 0xd08c, 0x0040, 0x1c94, 0x7a10,
-	0xd2ec, 0x00c0, 0x1c94, 0xc08c, 0x2011, 0x0000, 0xa08c, 0x000d,
-	0x0040, 0x1ca8, 0x810c, 0x0048, 0x1ca4, 0x8210, 0x810c, 0x810c,
-	0x0048, 0x1ca4, 0x8210, 0x810c, 0x81ff, 0x00c0, 0x1596, 0x8210,
-	0x7a0e, 0xd28c, 0x0040, 0x1cd4, 0x7910, 0xc1cd, 0x7912, 0x2009,
-	0x0021, 0x2019, 0x0003, 0xd284, 0x0040, 0x1cce, 0x8108, 0x2019,
-	0x0041, 0x2011, 0x924e, 0x2312, 0x2019, 0x0042, 0x8210, 0x2312,
-	0x2019, 0x0043, 0x8210, 0x2312, 0x2019, 0x0046, 0x8210, 0x2312,
-	0x2019, 0x0047, 0x8210, 0x2312, 0x2019, 0x0006, 0x2011, 0x9253,
-	0x2112, 0x2011, 0x9273, 0x2312, 0x7904, 0x7806, 0x0078, 0x159c,
-	0x7804, 0x70c6, 0x0078, 0x159d, 0x2091, 0x8000, 0x2019, 0x0000,
-	0x2011, 0x0000, 0x2009, 0x0000, 0x2091, 0x8001, 0x0078, 0x159a,
-	0x77c4, 0x1078, 0x1e02, 0x2091, 0x8000, 0x6830, 0xa084, 0xff00,
-	0x8007, 0x2010, 0x2091, 0x8001, 0x2708, 0x0078, 0x159b, 0x77c4,
-	0x1078, 0x1e02, 0x2091, 0x8000, 0x6a34, 0x2091, 0x8001, 0x2708,
-	0x0078, 0x159b, 0x77c4, 0x077e, 0xa7bc, 0xff00, 0x20a9, 0x0008,
-	0x72c8, 0x8217, 0x1078, 0x1e02, 0x2091, 0x8000, 0x6c30, 0x6a32,
-	0x2091, 0x8001, 0x8738, 0x00f0, 0x1d0a, 0x077f, 0x2708, 0x8427,
-	0x2410, 0x0078, 0x159b, 0x77c4, 0x077e, 0xa7bc, 0xff00, 0x20a9,
-	0x0008, 0x72c8, 0x1078, 0x1e02, 0x2091, 0x8000, 0x6c34, 0x6a36,
-	0x2091, 0x8001, 0x8738, 0x00f0, 0x1d22, 0x077f, 0x2708, 0x2410,
-	0x0078, 0x159b, 0x2011, 0x4a3c, 0x220c, 0x70c4, 0x2012, 0x0078,
-	0x159c, 0x71c4, 0xd1fc, 0x00c0, 0x1d41, 0x2011, 0x4ec0, 0x0078,
-	0x1d43, 0x2011, 0x4f40, 0x8107, 0xa084, 0x000f, 0x8003, 0x8003,
-	0x8003, 0xa268, 0x6a14, 0xd2b4, 0x0040, 0x1d52, 0x2011, 0x0001,
-	0x0078, 0x1d54, 0x2011, 0x0000, 0x6b0c, 0x0078, 0x159a, 0x017e,
-	0x7814, 0xd0f4, 0x0040, 0x1d64, 0x2001, 0x4007, 0x70db, 0x0000,
-	0xa18d, 0x0001, 0x0078, 0x1d70, 0xd0fc, 0x0040, 0x1d6f, 0x2001,
-	0x4007, 0x70db, 0x0001, 0xa18d, 0x0001, 0x0078, 0x1d70, 0xa006,
-	0x017f, 0x007c, 0x017e, 0x7814, 0xd0f4, 0x0040, 0x1d7f, 0x2001,
-	0x4007, 0x70db, 0x0000, 0xa18d, 0x0001, 0x0078, 0x1d80, 0xa006,
-	0x017f, 0x007c, 0x017e, 0x7814, 0xd0fc, 0x0040, 0x1d8f, 0x2001,
-	0x4007, 0x70db, 0x0001, 0xa18d, 0x0001, 0x0078, 0x1d90, 0xa006,
-	0x017f, 0x007c, 0x7112, 0x721a, 0x731e, 0x7810, 0xd0c4, 0x0040,
-	0x1d9b, 0x7422, 0x7526, 0xac80, 0x0001, 0x8108, 0x810c, 0x81a9,
-	0x8098, 0x20a1, 0x0030, 0x7003, 0x0000, 0x6084, 0x20a2, 0x53a6,
-	0x7007, 0x0001, 0x7974, 0xa184, 0xff00, 0x0040, 0x1db8, 0x810f,
-	0x810c, 0x810c, 0x8004, 0x8004, 0x8007, 0xa100, 0x0078, 0x1dbb,
-	0x8107, 0x8004, 0x8004, 0x797c, 0xa108, 0x7a78, 0xa006, 0xa211,
-	0x7d10, 0xd5c4, 0x0040, 0x1dc8, 0x7b84, 0xa319, 0x7c80, 0xa421,
-	0x7008, 0xd0fc, 0x0040, 0x1dc8, 0x7003, 0x0001, 0x7007, 0x0006,
-	0x711a, 0x721e, 0x7d10, 0xd5c4, 0x0040, 0x1dd8, 0x7322, 0x7426,
-	0xa084, 0x01e0, 0x007c, 0x7848, 0xa065, 0x0040, 0x1de3, 0x2c04,
-	0x784a, 0x2063, 0x0000, 0x007c, 0x0f7e, 0x2079, 0x4a00, 0x7848,
-	0x2062, 0x2c00, 0xa005, 0x00c0, 0x1def, 0x1078, 0x28ec, 0x784a,
-	0x0f7f, 0x007c, 0x2011, 0x9400, 0x7a4a, 0x7bc4, 0x8319, 0x0040,
-	0x1dff, 0xa280, 0x0032, 0x2012, 0x2010, 0x0078, 0x1df6, 0x2013,
-	0x0000, 0x007c, 0x017e, 0x027e, 0xd7fc, 0x00c0, 0x1e0b, 0x2011,
-	0x4fc0, 0x0078, 0x1e0d, 0x2011, 0x6fc0, 0xa784, 0x0f00, 0x800b,
-	0xa784, 0x001f, 0x0040, 0x1e18, 0x8003, 0x8003, 0x8003, 0x8003,
-	0xa105, 0xa268, 0x027f, 0x017f, 0x007c, 0x1078, 0x1e02, 0x2900,
-	0x682a, 0x2a00, 0x682e, 0x6808, 0xa084, 0xf9ef, 0xa80d, 0x690a,
-	0xd7fc, 0x00c0, 0x1e2f, 0x2009, 0x4a53, 0x0078, 0x1e31, 0x2009,
-	0x4a93, 0x210c, 0x6804, 0xa005, 0x0040, 0x1e41, 0xa116, 0x00c0,
-	0x1e41, 0x2060, 0x6000, 0x6806, 0x017e, 0x200b, 0x0000, 0x0078,
-	0x1e44, 0x2009, 0x0000, 0x017e, 0x6804, 0xa065, 0x0040, 0x1e59,
-	0x6000, 0x6806, 0x1078, 0x1e6f, 0x1078, 0x201b, 0x6810, 0x7908,
-	0x8109, 0x790a, 0x8001, 0x6812, 0x00c0, 0x1e44, 0x7910, 0xc1a5,
-	0x7912, 0x017f, 0x6902, 0x6906, 0x007c, 0xa065, 0x0040, 0x1e6e,
-	0x2008, 0x609c, 0xa005, 0x0040, 0x1e6b, 0x2062, 0x609f, 0x0000,
-	0xa065, 0x0078, 0x1e61, 0x7848, 0x794a, 0x2062, 0x007c, 0x6007,
-	0x0103, 0x608f, 0x0000, 0x20a9, 0x001c, 0xac80, 0x0005, 0x20a0,
-	0x2001, 0x0000, 0x40a4, 0x6828, 0x601a, 0x682c, 0x6022, 0x007c,
-	0x0e7e, 0xd7fc, 0x00c0, 0x1e8a, 0x2071, 0x4a40, 0x2031, 0x4ac0,
-	0x0078, 0x1e8e, 0x2071, 0x4a80, 0x2031, 0x4cc0, 0x7050, 0xa08c,
-	0x0200, 0x00c0, 0x1e98, 0xa608, 0x2d0a, 0x8000, 0x7052, 0xa006,
-	0x0e7f, 0x007c, 0x0f7e, 0xd7fc, 0x00c0, 0x1ea2, 0x2079, 0x4a40,
-	0x0078, 0x1ea4, 0x2079, 0x4a80, 0x1078, 0x1e02, 0x2091, 0x8000,
-	0x6804, 0x780a, 0xa065, 0x0040, 0x1ef8, 0x0078, 0x1eb6, 0x2c00,
-	0x780a, 0x2060, 0x6000, 0xa065, 0x0040, 0x1ef8, 0x6010, 0xa306,
-	0x00c0, 0x1eaf, 0x600c, 0xa206, 0x00c0, 0x1eaf, 0x2c28, 0x784c,
-	0xac06, 0x00c0, 0x1ec5, 0x0078, 0x1ef5, 0x6804, 0xac06, 0x00c0,
-	0x1ed3, 0x6000, 0x2060, 0x6806, 0xa005, 0x00c0, 0x1ed3, 0x6803,
-	0x0000, 0x0078, 0x1edd, 0x6400, 0x7808, 0x2060, 0x6402, 0xa486,
-	0x0000, 0x00c0, 0x1edd, 0x2c00, 0x6802, 0x2560, 0x0f7f, 0x1078,
-	0x1e6f, 0x0f7e, 0x601b, 0x0005, 0x6023, 0x0020, 0x0f7f, 0x1078,
-	0x201b, 0x0f7e, 0x7908, 0x8109, 0x790a, 0x6810, 0x8001, 0x6812,
-	0x00c0, 0x1ef5, 0x7810, 0xc0a5, 0x7812, 0x2001, 0xffff, 0xa005,
-	0x0f7f, 0x007c, 0x077e, 0x2700, 0x2039, 0x0000, 0xd0fc, 0x0040,
-	0x1f02, 0xc7fd, 0x2041, 0x0021, 0x2049, 0x0004, 0x2051, 0x0008,
-	0x2091, 0x8000, 0x1078, 0x1e1d, 0x8738, 0xa784, 0x001f, 0x00c0,
-	0x1f0a, 0xa7bc, 0xff00, 0x873f, 0x8738, 0x873f, 0xa784, 0x0f00,
-	0x00c0, 0x1f0a, 0x2091, 0x8001, 0x077f, 0x007c, 0x2061, 0x0000,
-	0x6018, 0xd084, 0x00c0, 0x1f3e, 0x7810, 0xd08c, 0x0040, 0x1f2f,
-	0xc08c, 0x7812, 0xc7fc, 0x2069, 0x4a40, 0x0078, 0x1f34, 0xc08d,
-	0x7812, 0x2069, 0x4a80, 0xc7fd, 0x2091, 0x8000, 0x681c, 0x681f,
-	0x0000, 0x2091, 0x8001, 0xa005, 0x00c0, 0x1f3f, 0x007c, 0xa08c,
-	0xfff0, 0x0040, 0x1f45, 0x1078, 0x28ec, 0x0079, 0x1f47, 0x1f57,
-	0x1f5a, 0x1f60, 0x1f64, 0x1f58, 0x1f68, 0x1f58, 0x1f58, 0x1f58,
-	0x1f6e, 0x1f9f, 0x1fa3, 0x1fa9, 0x1f58, 0x1f58, 0x1f58, 0x007c,
-	0x1078, 0x28ec, 0x1078, 0x1efa, 0x2001, 0x8001, 0x0078, 0x1fbe,
-	0x2001, 0x8003, 0x0078, 0x1fbe, 0x2001, 0x8004, 0x0078, 0x1fbe,
-	0x1078, 0x1efa, 0x2001, 0x8006, 0x0078, 0x1fbe, 0x2091, 0x8000,
-	0x077e, 0xd7fc, 0x00c0, 0x1f7a, 0x2069, 0x4a40, 0x2039, 0x0009,
-	0x0078, 0x1f7e, 0x2069, 0x4a80, 0x2039, 0x0009, 0x6800, 0xa086,
-	0x0000, 0x0040, 0x1f88, 0x007f, 0x6f1e, 0x2091, 0x8001, 0x007c,
-	0x6874, 0x077f, 0xa0bc, 0xff00, 0x2041, 0x0021, 0x2049, 0x0004,
-	0x2051, 0x0010, 0x1078, 0x1e1d, 0x8738, 0xa784, 0x001f, 0x00c0,
-	0x1f92, 0x2091, 0x8001, 0x2001, 0x800a, 0x0078, 0x1fbe, 0x2001,
-	0x800c, 0x0078, 0x1fbe, 0x1078, 0x1efa, 0x2001, 0x800d, 0x0078,
-	0x1fbe, 0x7814, 0xd0e4, 0x00c0, 0x1fbc, 0xd0ec, 0x0040, 0x1fb6,
-	0xd7fc, 0x0040, 0x1fb6, 0x78ec, 0x0078, 0x1fb7, 0x78e4, 0x70c6,
-	0x2001, 0x800e, 0x0078, 0x1fbe, 0x0078, 0x1f58, 0x70c2, 0xd7fc,
-	0x00c0, 0x1fc6, 0x70db, 0x0000, 0x0078, 0x1fc8, 0x70db, 0x0001,
-	0x2061, 0x0000, 0x601b, 0x0001, 0x2091, 0x4080, 0x007c, 0xac80,
-	0x0001, 0x81ff, 0x0040, 0x1ffa, 0x2099, 0x0030, 0x20a0, 0x700c,
-	0xa084, 0x03ff, 0x0040, 0x1fdc, 0x7018, 0x007e, 0x701c, 0x007e,
-	0x7020, 0x007e, 0x7024, 0x007e, 0x7112, 0x81ac, 0x721a, 0x731e,
-	0x7422, 0x7526, 0x7003, 0x0001, 0x7007, 0x0001, 0x7008, 0x800b,
-	0x00c8, 0x1fee, 0x7007, 0x0002, 0xa08c, 0x01e0, 0x00c0, 0x1ffa,
-	0x53a5, 0xa006, 0x7003, 0x0000, 0x7007, 0x0004, 0x007f, 0x7026,
-	0x007f, 0x7022, 0x007f, 0x701e, 0x007f, 0x701a, 0x007c, 0x2011,
-	0x0020, 0x2009, 0x0010, 0x6b0a, 0x6c0e, 0x6803, 0xfd00, 0x6807,
-	0x0018, 0x6a1a, 0x2d00, 0xa0e8, 0x0008, 0xa290, 0x0004, 0x8109,
-	0x00c0, 0x200b, 0x007c, 0x6004, 0x6086, 0x2c08, 0x2063, 0x0000,
-	0x7868, 0xa005, 0x796a, 0x0040, 0x2028, 0x2c02, 0x0078, 0x2029,
-	0x796e, 0x007c, 0x0c7e, 0x2061, 0x4a00, 0x6887, 0x0103, 0x2d08,
-	0x206b, 0x0000, 0x6068, 0xa005, 0x616a, 0x0040, 0x203a, 0x2d02,
-	0x0078, 0x203b, 0x616e, 0x0c7f, 0x007c, 0x2091, 0x8000, 0x2c04,
-	0x786e, 0xa005, 0x00c0, 0x2045, 0x786a, 0x2091, 0x8001, 0x609c,
-	0xa005, 0x0040, 0x205e, 0x0c7e, 0x2060, 0x2008, 0x609c, 0xa005,
-	0x0040, 0x205a, 0x2062, 0x609f, 0x0000, 0xa065, 0x609c, 0xa005,
-	0x00c0, 0x2052, 0x7848, 0x794a, 0x2062, 0x0c7f, 0x7848, 0x2062,
-	0x609f, 0x0000, 0xac85, 0x0000, 0x00c0, 0x2068, 0x1078, 0x28ec,
-	0x784a, 0x007c, 0x20a9, 0x0010, 0xa006, 0x8004, 0x8086, 0x818e,
-	0x00c8, 0x2073, 0xa200, 0x00f0, 0x206e, 0x8086, 0x818e, 0x007c,
-	0x157e, 0x20a9, 0x0010, 0xa005, 0x0040, 0x2099, 0xa11a, 0x00c8,
-	0x2099, 0x8213, 0x818d, 0x0048, 0x208c, 0xa11a, 0x00c8, 0x208d,
-	0x00f0, 0x2081, 0x0078, 0x2091, 0xa11a, 0x2308, 0x8210, 0x00f0,
-	0x2081, 0x007e, 0x3200, 0xa084, 0xf7ff, 0x2080, 0x007f, 0x157f,
-	0x007c, 0x007e, 0x3200, 0xa085, 0x0800, 0x0078, 0x2095, 0x7d74,
-	0x70d0, 0xa506, 0x0040, 0x2185, 0x7810, 0x2050, 0x7800, 0xd08c,
-	0x0040, 0x20c1, 0xdaec, 0x0040, 0x20c1, 0x0e7e, 0x2091, 0x8000,
-	0x2071, 0x0020, 0x7004, 0xa005, 0x00c0, 0x20be, 0x7008, 0x0e7f,
-	0xa086, 0x0008, 0x0040, 0x20c1, 0x0078, 0x2185, 0x0e7f, 0x0078,
-	0x2185, 0x1078, 0x1ddb, 0x0040, 0x2185, 0xa046, 0x7970, 0x2500,
-	0x8000, 0xa112, 0x2009, 0x0040, 0x00c8, 0x20d0, 0x0078, 0x20d7,
-	0x72d0, 0xa206, 0x0040, 0x20d7, 0x8840, 0x2009, 0x0080, 0x0c7e,
-	0x7112, 0x7007, 0x0001, 0x2099, 0x0030, 0x20a9, 0x0020, 0xac80,
-	0x0001, 0x20a0, 0x2061, 0x0000, 0x88ff, 0x0040, 0x20e9, 0x1078,
-	0x1ddb, 0x7008, 0xd0fc, 0x0040, 0x20e9, 0x7007, 0x0002, 0x2091,
-	0x8001, 0xa08c, 0x01e0, 0x00c0, 0x2120, 0x53a5, 0x8cff, 0x00c0,
-	0x20fe, 0x88ff, 0x0040, 0x216f, 0x0078, 0x2108, 0x2c00, 0x788e,
-	0x20a9, 0x0020, 0xac80, 0x0001, 0x20a0, 0x53a5, 0x0078, 0x216f,
-	0xa046, 0x7218, 0x731c, 0xdac4, 0x0040, 0x2110, 0x7420, 0x7524,
-	0xa292, 0x0040, 0xa39b, 0x0000, 0xa4a3, 0x0000, 0xa5ab, 0x0000,
-	0x721a, 0x731e, 0xdac4, 0x0040, 0x2120, 0x7422, 0x7526, 0xa006,
-	0x7007, 0x0004, 0x0040, 0x216f, 0x8cff, 0x0040, 0x2129, 0x1078,
-	0x1de4, 0x0c7f, 0x1078, 0x1de4, 0xa046, 0x7888, 0x8000, 0x788a,
-	0xa086, 0x0002, 0x0040, 0x214f, 0x7a7c, 0x7b78, 0xdac4, 0x0040,
-	0x213b, 0x7c84, 0x7d80, 0x7974, 0x8107, 0x8004, 0x8004, 0xa210,
-	0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x721a, 0x731e,
-	0xdac4, 0x0040, 0x2185, 0x7422, 0x7526, 0x0078, 0x2185, 0x6014,
-	0xd0fc, 0x00c0, 0x2157, 0x2069, 0x4a40, 0x0078, 0x2159, 0x2069,
-	0x4a80, 0x2091, 0x8000, 0x681f, 0x0002, 0x88ff, 0x0040, 0x2165,
-	0xa046, 0x788c, 0x2060, 0x0078, 0x214f, 0x788b, 0x0000, 0x78ac,
-	0xa085, 0x0003, 0x78ae, 0x2091, 0x8001, 0x0078, 0x2185, 0x0c7f,
-	0x788b, 0x0000, 0x1078, 0x2319, 0x6004, 0xa084, 0x000f, 0x1078,
-	0x2186, 0x88ff, 0x0040, 0x2183, 0x788c, 0x2060, 0x6004, 0xa084,
-	0x000f, 0x1078, 0x2186, 0x0078, 0x209f, 0x007c, 0x0079, 0x2188,
-	0x2198, 0x21b6, 0x21d4, 0x2198, 0x21e5, 0x21a9, 0x2198, 0x2198,
-	0x2198, 0x21b4, 0x21d2, 0x2198, 0x2198, 0x2198, 0x2198, 0x2198,
-	0x2039, 0x0400, 0x78bc, 0xa705, 0x78be, 0x6008, 0xa705, 0x600a,
-	0x1078, 0x2228, 0x609c, 0x78ba, 0x609f, 0x0000, 0x1078, 0x2303,
-	0x007c, 0x78bc, 0xd0c4, 0x0040, 0x21af, 0x0078, 0x2198, 0x601c,
-	0xc0bd, 0x601e, 0x0078, 0x21bc, 0x1078, 0x234b, 0x78bc, 0xd0c4,
-	0x0040, 0x21bc, 0x0078, 0x2198, 0x78bf, 0x0000, 0x6004, 0x8007,
-	0xa084, 0x00ff, 0x78b2, 0x8001, 0x0040, 0x21cf, 0x1078, 0x2228,
-	0x0040, 0x21cf, 0x78bc, 0xc0c5, 0x78be, 0x0078, 0x21d1, 0x0078,
-	0x2247, 0x007c, 0x1078, 0x2347, 0x78bc, 0xa08c, 0x0e00, 0x00c0,
-	0x21dc, 0xd0c4, 0x00c0, 0x21de, 0x0078, 0x2198, 0x1078, 0x2228,
-	0x00c0, 0x21e4, 0x0078, 0x2247, 0x007c, 0x78bc, 0xd0c4, 0x0040,
-	0x21eb, 0x0078, 0x2198, 0x78bf, 0x0000, 0x6714, 0x2011, 0x0001,
-	0x22a8, 0x6018, 0xa084, 0x00ff, 0xa005, 0x0040, 0x220b, 0xa7bc,
-	0xff00, 0x20a9, 0x0020, 0xa08e, 0x0001, 0x0040, 0x220b, 0xa7bc,
-	0x8000, 0x2011, 0x0002, 0x20a9, 0x0100, 0xa08e, 0x0002, 0x0040,
-	0x220b, 0x0078, 0x2225, 0x1078, 0x1e02, 0x2d00, 0x2091, 0x8000,
-	0x682b, 0x0000, 0x682f, 0x0000, 0x6808, 0xa084, 0xffde, 0x680a,
-	0xade8, 0x0010, 0x2091, 0x8001, 0x00f0, 0x220e, 0x8211, 0x0040,
-	0x2225, 0x20a9, 0x0100, 0x0078, 0x220e, 0x1078, 0x1de4, 0x007c,
-	0x609f, 0x0000, 0x78b4, 0xa06d, 0x2c00, 0x78b6, 0x00c0, 0x2233,
-	0x78ba, 0x0078, 0x223b, 0x689e, 0x2d00, 0x6002, 0x78b8, 0xad06,
-	0x00c0, 0x223b, 0x6002, 0x78b0, 0x8001, 0x78b2, 0x00c0, 0x2246,
-	0x78bc, 0xc0c4, 0x78be, 0x78b8, 0x2060, 0xa006, 0x007c, 0x0e7e,
-	0xa02e, 0x2530, 0x7dba, 0x7db6, 0x65ae, 0x65b2, 0x601c, 0x60a2,
-	0x2048, 0xa984, 0xe1ff, 0x601e, 0xa984, 0x0060, 0x0040, 0x225a,
-	0x1078, 0x43c1, 0x6596, 0x65a6, 0x669a, 0x66aa, 0x6714, 0x2071,
-	0x4a80, 0xd7fc, 0x00c0, 0x2266, 0x2071, 0x4a40, 0xa784, 0x0f00,
-	0x800b, 0xa784, 0x001f, 0x0040, 0x2271, 0x8003, 0x8003, 0x8003,
-	0x8003, 0xa105, 0x71c4, 0xa168, 0x2700, 0x8007, 0xa084, 0x000f,
-	0x8003, 0x8003, 0x8003, 0x71c8, 0xa100, 0x60c2, 0x2091, 0x8000,
-	0x7810, 0xd0f4, 0x00c0, 0x228b, 0x6e08, 0xd684, 0x0040, 0x22a1,
-	0xd9fc, 0x00c0, 0x22a1, 0x2091, 0x8001, 0x1078, 0x1e6f, 0x2091,
-	0x8000, 0x1078, 0x201b, 0x2091, 0x8001, 0x7814, 0xd0e4, 0x00c0,
-	0x2301, 0x7810, 0xd0f4, 0x0040, 0x2301, 0x601b, 0x0021, 0x0078,
-	0x2301, 0x6024, 0xa096, 0x0001, 0x00c0, 0x22a8, 0x8000, 0x6026,
-	0x6a10, 0x6814, 0xa202, 0x0048, 0x22bb, 0x0040, 0x22bb, 0x2091,
-	0x8001, 0x2039, 0x0200, 0x609c, 0x78ba, 0x609f, 0x0000, 0x1078,
-	0x2303, 0x0078, 0x2301, 0x2c08, 0xd9fc, 0x0040, 0x22de, 0x6800,
-	0xa065, 0x0040, 0x22de, 0x6a04, 0x7000, 0xa084, 0x0002, 0x0040,
-	0x22d9, 0x704c, 0xa206, 0x00c0, 0x22d9, 0x6b04, 0x2160, 0x2304,
-	0x6002, 0xa005, 0x00c0, 0x22d5, 0x6902, 0x2260, 0x6102, 0x0078,
-	0x22ea, 0x2160, 0x6202, 0x6906, 0x0078, 0x22ea, 0x6800, 0x6902,
-	0xa065, 0x0040, 0x22e6, 0x6102, 0x0078, 0x22e7, 0x6906, 0x2160,
-	0x6003, 0x0000, 0x2160, 0xd9fc, 0x0040, 0x22f1, 0xa6b4, 0xfffc,
-	0x6e0a, 0x6810, 0x7d08, 0x8528, 0x7d0a, 0x8000, 0x6812, 0x2091,
-	0x8001, 0xd6b4, 0x0040, 0x2301, 0xa6b6, 0x0040, 0x6e0a, 0x1078,
-	0x1e80, 0x0e7f, 0x007c, 0x6008, 0xa705, 0x600a, 0x2091, 0x8000,
-	0x1078, 0x201b, 0x2091, 0x8001, 0x78b8, 0xa065, 0x0040, 0x2316,
-	0x609c, 0x78ba, 0x609f, 0x0000, 0x0078, 0x2303, 0x78b6, 0x78ba,
-	0x007c, 0x7970, 0x7874, 0x2818, 0xd384, 0x0040, 0x2323, 0x8000,
-	0xa112, 0x0048, 0x2328, 0x8000, 0xa112, 0x00c8, 0x2338, 0xc384,
-	0x7a7c, 0x721a, 0x7a78, 0x721e, 0xdac4, 0x0040, 0x2333, 0x7a84,
-	0x7222, 0x7a80, 0x7226, 0xa006, 0xd384, 0x0040, 0x2338, 0x8000,
-	0x7876, 0x70d2, 0x781c, 0xa005, 0x0040, 0x2346, 0x8001, 0x781e,
-	0x00c0, 0x2346, 0x0068, 0x2346, 0x2091, 0x4080, 0x007c, 0x2039,
-	0x235f, 0x0078, 0x234d, 0x2039, 0x2365, 0x2704, 0xa005, 0x0040,
-	0x235e, 0xac00, 0x2068, 0x6908, 0x6810, 0x6912, 0x680a, 0x690c,
-	0x6814, 0x6916, 0x680e, 0x8738, 0x0078, 0x234d, 0x007c, 0x0003,
-	0x0009, 0x000f, 0x0015, 0x001b, 0x0000, 0x0015, 0x001b, 0x0000,
-	0x2041, 0x0000, 0x780c, 0x0079, 0x236d, 0x2535, 0x2508, 0x2371,
-	0x23e5, 0x2039, 0x9274, 0x2734, 0x7d10, 0x0078, 0x238c, 0x6084,
-	0xa086, 0x0103, 0x00c0, 0x23ce, 0x6114, 0x6018, 0xa105, 0x00c0,
-	0x23ce, 0x8603, 0xa080, 0x9255, 0x620c, 0x2202, 0x8000, 0x6210,
-	0x2202, 0x1078, 0x203d, 0x8630, 0xa68e, 0x000f, 0x0040, 0x2454,
-	0x786c, 0xa065, 0x00c0, 0x2377, 0x7808, 0xa602, 0x00c8, 0x239d,
-	0xd5ac, 0x00c0, 0x239d, 0x263a, 0x007c, 0xa682, 0x0003, 0x00c8,
-	0x2454, 0x2091, 0x8000, 0x2069, 0x0000, 0x6818, 0xd084, 0x00c0,
-	0x23c9, 0x2011, 0x9255, 0x2204, 0x70c6, 0x8210, 0x2204, 0x70ca,
-	0xd684, 0x00c0, 0x23b9, 0x8210, 0x2204, 0x70da, 0x8210, 0x2204,
-	0x70de, 0xa685, 0x8020, 0x70c2, 0x681b, 0x0001, 0x2091, 0x4080,
-	0x7810, 0xa084, 0xffcf, 0x7812, 0x2091, 0x8001, 0x203b, 0x0000,
-	0x007c, 0x7810, 0xc0ad, 0x7812, 0x0078, 0x2454, 0x263a, 0x1078,
-	0x253f, 0x00c0, 0x254e, 0x786c, 0xa065, 0x00c0, 0x2377, 0x2091,
-	0x8000, 0x7810, 0xa084, 0xffcf, 0x86ff, 0x0040, 0x23e0, 0xc0ad,
-	0x7812, 0x2091, 0x8001, 0x0078, 0x254e, 0x2039, 0x9274, 0x2734,
-	0x7d10, 0x0078, 0x23fc, 0x6084, 0xa086, 0x0103, 0x00c0, 0x243d,
-	0x6114, 0x6018, 0xa105, 0x00c0, 0x243d, 0xa680, 0x9255, 0x620c,
-	0x2202, 0x1078, 0x203d, 0x8630, 0xa68e, 0x001e, 0x0040, 0x2454,
-	0x786c, 0xa065, 0x00c0, 0x23eb, 0x7808, 0xa602, 0x00c8, 0x240d,
-	0xd5ac, 0x00c0, 0x240d, 0x263a, 0x007c, 0xa682, 0x0006, 0x00c8,
-	0x2454, 0x2091, 0x8000, 0x2069, 0x0000, 0x6818, 0xd084, 0x00c0,
-	0x2438, 0x2011, 0x9255, 0x2009, 0x924e, 0x26a8, 0x211c, 0x2204,
-	0x201a, 0x8108, 0x8210, 0x00f0, 0x241e, 0xa685, 0x8030, 0x70c2,
+	0xa1a2, 0x4d00, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424, 0x8424,
+	0xa192, 0x9700, 0x2009, 0x0000, 0x2001, 0x0032, 0x1078, 0x2061,
+	0x2218, 0x2079, 0x4d00, 0x2fa0, 0x2408, 0x2011, 0x0000, 0x20a9,
+	0x0040, 0x42a4, 0x8109, 0x00c0, 0x10bf, 0x2009, 0xff00, 0x3400,
+	0xa102, 0x0048, 0x10cf, 0x0040, 0x10cf, 0x20a8, 0x42a4, 0x2001,
+	0x04fc, 0x2004, 0xa086, 0x1080, 0x00c0, 0x10e5, 0x2071, 0x0100,
+	0x0d7e, 0x2069, 0x4d40, 0x1078, 0x4c38, 0x0d7f, 0x7810, 0xc0ed,
+	0x7812, 0x781b, 0x0064, 0x0078, 0x110a, 0x2001, 0x04fc, 0x2004,
+	0xa086, 0x1280, 0x00c0, 0x1105, 0x7814, 0xc0ed, 0xc0d5, 0x7816,
+	0x781b, 0x0064, 0x2071, 0x0200, 0x0d7e, 0x2069, 0x4d40, 0x1078,
+	0x4c38, 0x2069, 0x4d80, 0x2071, 0x0100, 0x1078, 0x4c38, 0x7814,
+	0xc0d4, 0x7816, 0x0d7f, 0x0078, 0x110a, 0x7814, 0xc0e5, 0x7816,
+	0x781b, 0x003c, 0x7eca, 0x7cc2, 0x7bc6, 0x7867, 0x0000, 0x7800,
+	0xc08d, 0x7802, 0x2031, 0x0030, 0x78af, 0x0101, 0x7823, 0x0002,
+	0x7827, 0x0002, 0x2009, 0x0002, 0x2069, 0x4d40, 0x681b, 0x0003,
+	0x6823, 0x0007, 0x6827, 0x00fa, 0x682b, 0x0008, 0x682f, 0x0028,
+	0x6837, 0x0000, 0x683b, 0x0006, 0x6833, 0x0008, 0x683f, 0x0000,
+	0x8109, 0x0040, 0x115e, 0x68d3, 0x000a, 0x68c3, 0x4dc0, 0x2079,
+	0x4d00, 0x7814, 0xd0e4, 0x00c0, 0x1144, 0xd0ec, 0x00c0, 0x1148,
+	0x68d7, 0x7329, 0x0078, 0x114a, 0x68d7, 0x730d, 0x0078, 0x114a,
+	0x68d7, 0x732d, 0x68c7, 0x52c0, 0x68cb, 0x51c0, 0x68cf, 0x92c0,
+	0x68ab, 0x9544, 0x68af, 0x9549, 0x68b3, 0x9544, 0x68b7, 0x9544,
+	0x68a7, 0x0001, 0x2069, 0x4d80, 0x0078, 0x111e, 0x68d3, 0x000a,
+	0x68c3, 0x4fc0, 0x7814, 0xd0e4, 0x00c0, 0x116a, 0x68d7, 0x7439,
+	0x0078, 0x116c, 0x68d7, 0x7419, 0x68c7, 0x72c0, 0x68cb, 0x5240,
+	0x68cf, 0x93d0, 0x68ab, 0x9549, 0x68af, 0x954e, 0x68b3, 0x9549,
+	0x68b7, 0x9549, 0x68a7, 0x0001, 0x7810, 0xd0ec, 0x00c0, 0x11c2,
+	0x7814, 0xd0e4, 0x00c0, 0x11b4, 0x0e7e, 0x2069, 0x51c0, 0x2071,
+	0x0200, 0x70ec, 0xd0e4, 0x00c0, 0x1195, 0x2019, 0x0c0c, 0x2021,
+	0x000c, 0x1078, 0x1ff0, 0x0078, 0x119b, 0x2019, 0x0c0a, 0x2021,
+	0x000a, 0x1078, 0x1ff0, 0x2069, 0x5240, 0x2071, 0x0100, 0x70ec,
+	0xd0e4, 0x00c0, 0x11ab, 0x2019, 0x0c0c, 0x2021, 0x000c, 0x1078,
+	0x1ff0, 0x0078, 0x11b1, 0x2019, 0x0c0a, 0x2021, 0x000a, 0x1078,
+	0x1ff0, 0x0e7f, 0x0078, 0x11db, 0x2019, 0x0c0c, 0x2021, 0x000c,
+	0x2069, 0x51c0, 0x1078, 0x1ff0, 0x2069, 0x5240, 0x1078, 0x1ff0,
+	0x0078, 0x11db, 0x2069, 0x51c0, 0x0e7e, 0x2071, 0x0100, 0x70ec,
+	0xd0e4, 0x00c0, 0x11d4, 0x2019, 0x0c0c, 0x2021, 0x000c, 0x1078,
+	0x1ff0, 0x0e7f, 0x0078, 0x11db, 0x2019, 0x0c0a, 0x2021, 0x000a,
+	0x1078, 0x1ff0, 0x0e7f, 0x2011, 0x0002, 0x2069, 0x52c0, 0x2009,
+	0x0002, 0x20a9, 0x0100, 0x6837, 0x0000, 0x680b, 0x0040, 0x7bc8,
+	0xa386, 0xfeff, 0x00c0, 0x11f2, 0x6817, 0x0100, 0x681f, 0x0064,
+	0x0078, 0x11f6, 0x6817, 0x0064, 0x681f, 0x0002, 0xade8, 0x0010,
+	0x00f0, 0x11e3, 0x8109, 0x00c0, 0x11e1, 0x8211, 0x0040, 0x1204,
+	0x2069, 0x72c0, 0x0078, 0x11df, 0x1078, 0x261d, 0x1078, 0x4603,
+	0x1078, 0x1dbb, 0x1078, 0x4be1, 0x2091, 0x2100, 0x2079, 0x4d00,
+	0x7810, 0xd0ec, 0x0040, 0x1218, 0x2071, 0x0020, 0x0078, 0x121a,
+	0x2071, 0x0050, 0x2091, 0x2200, 0x2079, 0x4d00, 0x2071, 0x0020,
+	0x2091, 0x2300, 0x2079, 0x4d00, 0x7810, 0xd0ec, 0x0040, 0x122c,
+	0x2079, 0x0100, 0x0078, 0x122e, 0x2079, 0x0200, 0x2071, 0x4d40,
+	0x2091, 0x2400, 0x2079, 0x0100, 0x2071, 0x4d80, 0x2091, 0x2000,
+	0x2079, 0x4d00, 0x2071, 0x0010, 0x3200, 0xa085, 0x303d, 0x2090,
+	0x2071, 0x0010, 0x70c3, 0x0000, 0x0090, 0x124d, 0x70c0, 0xa086,
+	0x0002, 0x00c0, 0x124d, 0x1078, 0x15ba, 0x2039, 0x0000, 0x7810,
+	0xd0ec, 0x00c0, 0x12cf, 0x1078, 0x148e, 0x78ac, 0xa005, 0x00c0,
+	0x126b, 0x0068, 0x1261, 0x786c, 0xa065, 0x0040, 0x1261, 0x1078,
+	0x2356, 0x1078, 0x2088, 0x0068, 0x1278, 0x786c, 0xa065, 0x0040,
+	0x126b, 0x1078, 0x2356, 0x0068, 0x1278, 0x2009, 0x4d47, 0x2011,
+	0x4d87, 0x2104, 0x220c, 0xa105, 0x0040, 0x1278, 0x1078, 0x1ef1,
+	0x2071, 0x4d40, 0x70a4, 0xa005, 0x0040, 0x129d, 0x7450, 0xa485,
+	0x0000, 0x0040, 0x129d, 0x2079, 0x0200, 0x2091, 0x8000, 0x72d4,
+	0xa28c, 0x303d, 0x2190, 0x1078, 0x2b0b, 0x2091, 0x8000, 0x2091,
+	0x303d, 0x0068, 0x129d, 0x2079, 0x4d00, 0x786c, 0xa065, 0x0040,
+	0x129d, 0x2071, 0x0010, 0x1078, 0x2356, 0x00e0, 0x12a5, 0x2079,
+	0x4d00, 0x2071, 0x0010, 0x1078, 0x49ba, 0x2071, 0x4d80, 0x70a4,
+	0xa005, 0x0040, 0x12bd, 0x7050, 0xa025, 0x0040, 0x12bd, 0x2079,
+	0x0100, 0x2091, 0x8000, 0x72d4, 0xa28c, 0x303d, 0x2190, 0x1078,
+	0x2b0b, 0x2091, 0x8000, 0x2091, 0x303d, 0x2079, 0x4d00, 0x2071,
+	0x0010, 0x0068, 0x12c9, 0x786c, 0xa065, 0x0040, 0x12c9, 0x1078,
+	0x2356, 0x00e0, 0x1253, 0x1078, 0x49ba, 0x0078, 0x1253, 0x1078,
+	0x148e, 0x78ac, 0xa005, 0x00c0, 0x12e7, 0x0068, 0x12dd, 0x786c,
+	0xa065, 0x0040, 0x12dd, 0x1078, 0x2356, 0x1078, 0x2088, 0x0068,
+	0x12f1, 0x786c, 0xa065, 0x0040, 0x12e7, 0x1078, 0x2356, 0x0068,
+	0x12f1, 0x2009, 0x4d47, 0x2104, 0xa005, 0x0040, 0x12f1, 0x1078,
+	0x1ef1, 0x2071, 0x4d40, 0x70a4, 0xa005, 0x0040, 0x130c, 0x7450,
+	0xa485, 0x0000, 0x0040, 0x130c, 0x2079, 0x0100, 0x2091, 0x8000,
+	0x72d4, 0xa28c, 0x303d, 0x2190, 0x1078, 0x2b0b, 0x2091, 0x8000,
+	0x2091, 0x303d, 0x2079, 0x4d00, 0x2071, 0x0010, 0x0068, 0x1316,
+	0x786c, 0xa065, 0x0040, 0x1316, 0x1078, 0x2356, 0x00e0, 0x12cf,
+	0x1078, 0x49ba, 0x0078, 0x12cf, 0x133c, 0x133c, 0x133e, 0x133e,
+	0x134b, 0x134b, 0x134b, 0x134b, 0x1356, 0x1356, 0x1363, 0x1363,
+	0x134b, 0x134b, 0x134b, 0x134b, 0x133c, 0x133c, 0x133e, 0x133e,
+	0x134b, 0x134b, 0x134b, 0x134b, 0x1356, 0x1356, 0x1363, 0x1363,
+	0x134b, 0x134b, 0x134b, 0x134b, 0x0078, 0x133c, 0x007e, 0x107e,
+	0x127e, 0x2091, 0x2400, 0x1078, 0x292b, 0x127f, 0x107f, 0x007f,
+	0x2091, 0x8001, 0x007c, 0x007e, 0x107e, 0x127e, 0x1078, 0x13c8,
+	0x127f, 0x107f, 0x007f, 0x2091, 0x8001, 0x007c, 0x007e, 0x107e,
+	0x127e, 0x2091, 0x2300, 0x1078, 0x292b, 0x127f, 0x107f, 0x007f,
+	0x2091, 0x8001, 0x007c, 0x007e, 0x107e, 0x127e, 0x2091, 0x2300,
+	0x1078, 0x292b, 0x2091, 0x2400, 0x1078, 0x292b, 0x127f, 0x107f,
+	0x007f, 0x2091, 0x8001, 0x007c, 0x1394, 0x1394, 0x1396, 0x1396,
+	0x13a3, 0x13a3, 0x13a3, 0x13a3, 0x13ae, 0x13ae, 0x1396, 0x1396,
+	0x13a3, 0x13a3, 0x13a3, 0x13a3, 0x13af, 0x13af, 0x13af, 0x13af,
+	0x13af, 0x13af, 0x13af, 0x13af, 0x13af, 0x13af, 0x13af, 0x13af,
+	0x13af, 0x13af, 0x13af, 0x13af, 0x0078, 0x1394, 0x007e, 0x107e,
+	0x127e, 0x2091, 0x2300, 0x1078, 0x292b, 0x127f, 0x107f, 0x007f,
+	0x2091, 0x8001, 0x007c, 0x007e, 0x107e, 0x127e, 0x1078, 0x13d5,
+	0x127f, 0x107f, 0x007f, 0x2091, 0x8001, 0x007c, 0x007c, 0x107e,
+	0x127e, 0x0d7e, 0x0e7e, 0x0f7e, 0x007e, 0x2071, 0x0100, 0x2069,
+	0x4d40, 0x2079, 0x4d00, 0x70ec, 0xa084, 0x1c00, 0x78e2, 0x1078,
+	0x4c38, 0x007f, 0x0f7f, 0x0e7f, 0x0d7f, 0x127f, 0x107f, 0x007c,
+	0x3c00, 0xa084, 0x0007, 0x0079, 0x13cd, 0x13de, 0x13de, 0x13e0,
+	0x13e0, 0x13e5, 0x13e5, 0x13ea, 0x13ea, 0x3c00, 0xa084, 0x0003,
+	0x0079, 0x13da, 0x13de, 0x13de, 0x13f3, 0x13f3, 0x1078, 0x290c,
+	0x2091, 0x2200, 0x1078, 0x46dd, 0x007c, 0x2091, 0x2100, 0x1078,
+	0x46dd, 0x007c, 0x2091, 0x2100, 0x1078, 0x46dd, 0x2091, 0x2200,
+	0x1078, 0x46dd, 0x007c, 0x2091, 0x2100, 0x1078, 0x46dd, 0x007c,
+	0x1418, 0x1418, 0x141a, 0x141a, 0x1427, 0x1427, 0x1427, 0x1427,
+	0x1432, 0x1432, 0x143f, 0x143f, 0x1427, 0x1427, 0x1427, 0x1427,
+	0x1450, 0x1450, 0x1450, 0x1450, 0x1450, 0x1450, 0x1450, 0x1450,
+	0x1450, 0x1450, 0x1450, 0x1450, 0x1450, 0x1450, 0x1450, 0x1450,
+	0x0078, 0x1418, 0x007e, 0x107e, 0x127e, 0x2091, 0x2400, 0x1078,
+	0x292b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001, 0x007c, 0x007e,
+	0x107e, 0x127e, 0x1078, 0x13c8, 0x127f, 0x107f, 0x007f, 0x2091,
+	0x8001, 0x007c, 0x007e, 0x107e, 0x127e, 0x2091, 0x2300, 0x1078,
+	0x292b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001, 0x007c, 0x007e,
+	0x107e, 0x127e, 0x2091, 0x2300, 0x1078, 0x292b, 0x2091, 0x2400,
+	0x1078, 0x292b, 0x127f, 0x107f, 0x007f, 0x2091, 0x8001, 0x007c,
+	0x007e, 0x107e, 0x127e, 0x0d7e, 0x0e7e, 0x0f7e, 0x2079, 0x4d00,
+	0x2071, 0x0200, 0x2069, 0x4d40, 0x3d00, 0xd08c, 0x0040, 0x1466,
+	0x70ec, 0xa084, 0x1c00, 0x78e2, 0x1078, 0x4c38, 0x3d00, 0xd084,
+	0x0040, 0x1474, 0x2069, 0x4d80, 0x2071, 0x0100, 0x70ec, 0xa084,
+	0x1c00, 0x78e6, 0x1078, 0x4c38, 0x0f7f, 0x0e7f, 0x0d7f, 0x127f,
+	0x107f, 0x007f, 0x007c, 0x7008, 0x800b, 0x00c8, 0x1489, 0x7007,
+	0x0002, 0xa08c, 0x01e0, 0x00c0, 0x148a, 0xd09c, 0x0040, 0x1489,
+	0x087a, 0x097a, 0x70c3, 0x4002, 0x0078, 0x15bd, 0x0068, 0x1513,
+	0x2061, 0x0000, 0x6018, 0xd084, 0x00c0, 0x1513, 0x7828, 0xa005,
+	0x00c0, 0x149e, 0x0010, 0x1514, 0x0078, 0x1513, 0x7910, 0xd1f4,
+	0x0040, 0x14a6, 0x2001, 0x4007, 0x0078, 0x15bc, 0x7914, 0xd1ec,
+	0x0040, 0x14c1, 0xd0fc, 0x0040, 0x14b7, 0x007e, 0x1078, 0x1d4b,
+	0x007f, 0x0040, 0x14c1, 0x2001, 0x4007, 0x0078, 0x15bc, 0x007e,
+	0x1078, 0x1d3b, 0x007f, 0x0040, 0x14c1, 0x2001, 0x4007, 0x0078,
+	0x15bc, 0x7910, 0xd0fc, 0x00c0, 0x14cb, 0x2061, 0x4d40, 0xc19c,
+	0xc7fc, 0x0078, 0x14cf, 0x2061, 0x4d80, 0xc19d, 0xc7fd, 0x6064,
+	0xa005, 0x00c0, 0x1513, 0x7912, 0x6083, 0x0000, 0x7828, 0xc0fc,
+	0xa086, 0x0018, 0x00c0, 0x14e0, 0x0c7e, 0x1078, 0x1b44, 0x0c7f,
+	0x782b, 0x0000, 0x607c, 0xa065, 0x0040, 0x14f9, 0x0c7e, 0x609c,
+	0x1078, 0x1e30, 0x0c7f, 0x609f, 0x0000, 0x1078, 0x1c6d, 0x2009,
+	0x0018, 0x6087, 0x0103, 0x1078, 0x1d5b, 0x00c0, 0x150d, 0x1078,
+	0x1dad, 0x7810, 0xd09c, 0x00c0, 0x1501, 0x2061, 0x4d40, 0x0078,
+	0x1505, 0x2061, 0x4d80, 0xc09c, 0x7812, 0x607f, 0x0000, 0x60d4,
+	0xd0dc, 0x0040, 0x1511, 0xc0dc, 0x60d6, 0x2001, 0x4005, 0x0078,
+	0x15bc, 0x0078, 0x15ba, 0x007c, 0x7810, 0xd0f4, 0x0040, 0x151c,
+	0x2001, 0x4007, 0x0078, 0x15bc, 0xa006, 0x70c2, 0x70c6, 0x70ca,
+	0x70ce, 0x70da, 0x70c0, 0xa03d, 0xa08a, 0x0040, 0x00c8, 0x152a,
+	0x0079, 0x1531, 0x2100, 0xa08a, 0x0040, 0x00c8, 0x15c8, 0x0079,
+	0x1571, 0x15ba, 0x1610, 0x15d9, 0x1648, 0x1680, 0x1680, 0x15d0,
+	0x1c85, 0x168b, 0x15c8, 0x15dd, 0x15df, 0x15e1, 0x15e3, 0x1c8a,
+	0x15c8, 0x1699, 0x16f6, 0x1b64, 0x1c7f, 0x15e5, 0x19d4, 0x1a16,
+	0x1a4e, 0x1a9c, 0x198f, 0x199c, 0x19b0, 0x19c3, 0x17cb, 0x15c8,
+	0x172d, 0x173a, 0x1746, 0x1752, 0x1768, 0x1774, 0x1777, 0x1783,
+	0x178f, 0x1797, 0x17b3, 0x17bf, 0x15c8, 0x15c8, 0x15c8, 0x15c8,
+	0x17d8, 0x17ea, 0x1806, 0x183c, 0x1864, 0x1874, 0x1877, 0x18a8,
+	0x18d9, 0x18eb, 0x195e, 0x196e, 0x15c8, 0x15c8, 0x15c8, 0x15c8,
+	0x197e, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x1caf, 0x1cb5,
+	0x15c8, 0x15c8, 0x15c8, 0x1cb9, 0x1cfe, 0x15c8, 0x15c8, 0x15c8,
+	0x15c8, 0x160a, 0x167a, 0x1693, 0x16f0, 0x1b5e, 0x15c8, 0x15c8,
+	0x15c8, 0x15c8, 0x1d02, 0x1ca1, 0x1cab, 0x15c8, 0x15c8, 0x15c8,
+	0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8,
+	0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8,
+	0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8,
+	0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8, 0x15c8,
+	0x15c8, 0x72ca, 0x71c6, 0x2001, 0x4006, 0x0078, 0x15bc, 0x73ce,
+	0x72ca, 0x71c6, 0x2001, 0x4000, 0x70c2, 0x0068, 0x15bd, 0x2061,
+	0x0000, 0x601b, 0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x007c,
+	0x70c3, 0x4001, 0x0078, 0x15bd, 0x70c3, 0x4006, 0x0078, 0x15bd,
+	0x2099, 0x0041, 0x20a1, 0x0041, 0x20a9, 0x0005, 0x53a3, 0x0078,
+	0x15ba, 0x70c4, 0x70c3, 0x0004, 0x007a, 0x0078, 0x15ba, 0x0078,
+	0x15ba, 0x0078, 0x15ba, 0x0078, 0x15ba, 0x2091, 0x8000, 0x70c3,
+	0x0004, 0x70c7, 0x4953, 0x70cb, 0x5020, 0x70cf, 0x2020, 0x70d3,
+	0x0008, 0x2001, 0x000d, 0x70d6, 0x2079, 0x0000, 0x781b, 0x0001,
+	0x2031, 0x0030, 0x2059, 0x1000, 0x2029, 0x041a, 0x2051, 0x0445,
+	0x2061, 0x0447, 0x20c1, 0x0020, 0x2091, 0x5000, 0x2091, 0x4080,
+	0x0078, 0x0418, 0x75d8, 0x74dc, 0x75da, 0x74de, 0x0078, 0x1613,
+	0x2029, 0x0000, 0x2520, 0x71d0, 0x72c8, 0x73cc, 0x70c4, 0x20a0,
+	0x2099, 0x0030, 0x7003, 0x0001, 0x7007, 0x0006, 0x731a, 0x721e,
+	0x7422, 0x7526, 0x2021, 0x0040, 0x81ff, 0x0040, 0x15ba, 0xa182,
+	0x0040, 0x00c8, 0x162d, 0x2120, 0xa006, 0x2008, 0x8403, 0x7012,
+	0x7007, 0x0004, 0x7007, 0x0001, 0x7008, 0xd0fc, 0x0040, 0x1634,
+	0x7007, 0x0002, 0xa084, 0x01e0, 0x0040, 0x1642, 0x70c3, 0x4002,
+	0x0078, 0x15bd, 0x24a8, 0x53a5, 0x0078, 0x1624, 0x0078, 0x15ba,
+	0x2029, 0x0000, 0x2520, 0x71d0, 0x72c8, 0x73cc, 0x70c4, 0x2098,
+	0x20a1, 0x0030, 0x7003, 0x0000, 0x7007, 0x0006, 0x731a, 0x721e,
+	0x7422, 0x7526, 0x2021, 0x0040, 0x7007, 0x0006, 0x81ff, 0x0040,
+	0x15ba, 0xa182, 0x0040, 0x00c8, 0x1667, 0x2120, 0xa006, 0x2008,
+	0x8403, 0x7012, 0x24a8, 0x53a6, 0x7007, 0x0001, 0x7008, 0xd0fc,
+	0x0040, 0x166e, 0xa084, 0x01e0, 0x0040, 0x165c, 0x70c3, 0x4002,
+	0x0078, 0x15bd, 0x75d8, 0x74dc, 0x75da, 0x74de, 0x0078, 0x164b,
+	0x71c4, 0x70c8, 0x2114, 0xa79e, 0x0004, 0x00c0, 0x1688, 0x200a,
+	0x72ca, 0x0078, 0x15b9, 0x70c7, 0x0008, 0x70cb, 0x000d, 0x70cf,
+	0x0008, 0x0078, 0x15ba, 0x75d8, 0x76dc, 0x75da, 0x76de, 0x0078,
+	0x169c, 0x2029, 0x0000, 0x2530, 0x70c4, 0x72c8, 0x73cc, 0x74d0,
+	0x70c6, 0x72ca, 0x73ce, 0x74d2, 0xa005, 0x0040, 0x16eb, 0xa40a,
+	0x0040, 0x16ac, 0x00c8, 0x15bc, 0x8001, 0x7872, 0xa084, 0xfc00,
+	0x0040, 0x16b9, 0x78ac, 0xc085, 0x78ae, 0x2001, 0x4005, 0x0078,
+	0x15bc, 0x7b7e, 0x7a7a, 0x7e86, 0x7d82, 0x7c76, 0xa48c, 0xff00,
+	0x0040, 0x16d1, 0x8407, 0x8004, 0x8004, 0x810c, 0x810c, 0x810f,
+	0xa118, 0xa291, 0x0000, 0xa6b1, 0x0000, 0xa581, 0x0000, 0x0078,
+	0x16db, 0x8407, 0x8004, 0x8004, 0xa318, 0xa291, 0x0000, 0xa6b1,
+	0x0000, 0xa581, 0x0000, 0x731a, 0x721e, 0x7622, 0x7026, 0xa605,
+	0x0040, 0x16e5, 0x7a10, 0xc2c5, 0x7a12, 0x78ac, 0xa084, 0xfffc,
+	0x78ae, 0x0078, 0x16ee, 0x78ac, 0xc085, 0x78ae, 0x0078, 0x15ba,
+	0x75d8, 0x76dc, 0x75da, 0x76de, 0x0078, 0x16f9, 0x2029, 0x0000,
+	0x2530, 0x70c4, 0x72c8, 0x73cc, 0x74d4, 0x70c6, 0x72ca, 0x73ce,
+	0x74d6, 0xa005, 0x0040, 0x1728, 0xa40a, 0x0040, 0x1709, 0x00c8,
+	0x15bc, 0x8001, 0x7892, 0xa084, 0xfc00, 0x0040, 0x1716, 0x78ac,
+	0xc0c5, 0x78ae, 0x2001, 0x4005, 0x0078, 0x15bc, 0x7a9a, 0x7b9e,
+	0x7da2, 0x7ea6, 0x2600, 0xa505, 0x0040, 0x1721, 0x7a10, 0xc2c5,
+	0x7a12, 0x7c96, 0x78ac, 0xa084, 0xfcff, 0x78ae, 0x0078, 0x172b,
+	0x78ac, 0xc0c5, 0x78ae, 0x0078, 0x15ba, 0x2009, 0x0000, 0x786c,
+	0xa065, 0x0040, 0x1737, 0x8108, 0x6000, 0x0078, 0x1730, 0x7ac4,
+	0x0078, 0x15b8, 0x2009, 0x4d48, 0x210c, 0x7810, 0xd0ec, 0x00c0,
+	0x15b9, 0x2011, 0x4d88, 0x2214, 0x0078, 0x15b8, 0x2009, 0x4d49,
+	0x210c, 0x7810, 0xd0ec, 0x00c0, 0x15b9, 0x2011, 0x4d89, 0x2214,
+	0x0078, 0x15b8, 0x2061, 0x4d40, 0x6128, 0x622c, 0x8214, 0x8214,
+	0x8214, 0x7810, 0xd0ec, 0x00c0, 0x1766, 0x2061, 0x4d80, 0x6328,
+	0x73da, 0x632c, 0x831c, 0x831c, 0x831c, 0x73de, 0x0078, 0x15b8,
+	0x2009, 0x4d4c, 0x210c, 0x7810, 0xd0ec, 0x00c0, 0x15b9, 0x2011,
+	0x4d8c, 0x2214, 0x0078, 0x15b8, 0x7918, 0x0078, 0x15b9, 0x2009,
+	0x4d4d, 0x210c, 0x7810, 0xd0ec, 0x00c0, 0x15b9, 0x2011, 0x4d8d,
+	0x2214, 0x0078, 0x15b8, 0x2009, 0x4d4e, 0x210c, 0x7810, 0xd0ec,
+	0x00c0, 0x15b9, 0x2011, 0x4d8e, 0x2214, 0x0078, 0x15b8, 0x7920,
+	0x7810, 0xd0ec, 0x00c0, 0x15b9, 0x7a24, 0x0078, 0x15b8, 0x71c4,
+	0xd1fc, 0x00c0, 0x179f, 0x2011, 0x51c0, 0x0078, 0x17a1, 0x2011,
+	0x5240, 0x8107, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0xa268,
+	0x6a00, 0x6804, 0xd09c, 0x0040, 0x17b0, 0x6b08, 0x0078, 0x17b1,
+	0x6b0c, 0x0078, 0x15b7, 0x77c4, 0x1078, 0x1dcb, 0x2091, 0x8000,
+	0x6b1c, 0x6a14, 0x2091, 0x8001, 0x2708, 0x0078, 0x15b7, 0x2061,
+	0x4d40, 0x6118, 0x7810, 0xd0ec, 0x00c0, 0x15b9, 0x2061, 0x4d80,
+	0x6218, 0x0078, 0x15b8, 0x77c4, 0x1078, 0x1dcb, 0x2091, 0x8000,
+	0x6908, 0x6a18, 0x6b10, 0x77da, 0x2091, 0x8001, 0x0078, 0x15b7,
+	0x71c4, 0x2110, 0xa294, 0x000f, 0xa282, 0x0010, 0x00c8, 0x15b2,
+	0x1078, 0x2735, 0xa384, 0x4000, 0x0040, 0x17e8, 0xa295, 0x0020,
+	0x0078, 0x15b7, 0x71c4, 0x2100, 0xc0bc, 0xa082, 0x0010, 0x00c8,
+	0x15b2, 0xd1bc, 0x00c0, 0x17f9, 0x2011, 0x4d48, 0x2204, 0x0078,
+	0x17fd, 0x2011, 0x4d88, 0x2204, 0xc0bd, 0x007e, 0x2100, 0xc0bc,
+	0x2012, 0x1078, 0x2692, 0x017f, 0x0078, 0x15b9, 0x71c4, 0x2021,
+	0x4d49, 0x2404, 0x70c6, 0x2019, 0x0000, 0x0078, 0x1815, 0x71c8,
+	0x2021, 0x4d89, 0x2404, 0x70ca, 0xc3fd, 0x2011, 0x1834, 0x20a9,
+	0x0008, 0x2204, 0xa106, 0x0040, 0x1824, 0x8210, 0x00f0, 0x1819,
+	0x71c4, 0x72c8, 0x0078, 0x15b1, 0xa292, 0x1834, 0x027e, 0x2122,
+	0x017f, 0x1078, 0x26b3, 0x7810, 0xd0ec, 0x00c0, 0x1832, 0xd3fc,
+	0x0040, 0x180f, 0x0078, 0x15ba, 0x03e8, 0x00fa, 0x01f4, 0x02ee,
+	0x0064, 0x0019, 0x0032, 0x004b, 0x2061, 0x4d40, 0x6128, 0x622c,
+	0x8214, 0x8214, 0x8214, 0x70c4, 0x602a, 0x70c8, 0x8003, 0x8003,
+	0x8003, 0x602e, 0x7810, 0xd0ec, 0x00c0, 0x1862, 0x027e, 0x017e,
+	0x2061, 0x4d80, 0x6128, 0x622c, 0x8214, 0x8214, 0x8214, 0x70d8,
+	0x602a, 0x70dc, 0x8003, 0x8003, 0x8003, 0x602e, 0x71da, 0x72de,
+	0x017f, 0x027f, 0x0078, 0x15b8, 0x2061, 0x4d40, 0x6130, 0x70c4,
+	0x6032, 0x7810, 0xd0ec, 0x00c0, 0x15b9, 0x2061, 0x4d80, 0x6230,
+	0x70c8, 0x6032, 0x0078, 0x15b8, 0x7918, 0x0078, 0x15b9, 0x71c4,
+	0xa184, 0xffcf, 0x0040, 0x1883, 0x7810, 0xd0ec, 0x00c0, 0x15b2,
+	0x72c8, 0x0078, 0x15b1, 0x2011, 0x4d4d, 0x2204, 0x2112, 0x007e,
+	0x2019, 0x0000, 0x1078, 0x271a, 0x7810, 0xd0ec, 0x0040, 0x1893,
+	0x017f, 0x0078, 0x15b9, 0x71c8, 0xa184, 0xffcf, 0x0040, 0x189c,
+	0x2110, 0x71c4, 0x0078, 0x15b1, 0x2011, 0x4d8d, 0x2204, 0x2112,
+	0x007e, 0xc3fd, 0x1078, 0x271a, 0x027f, 0x017f, 0x0078, 0x15b8,
+	0x71c4, 0xa182, 0x0010, 0x0048, 0x18b4, 0x7810, 0xd0ec, 0x00c0,
+	0x15b2, 0x72c8, 0x0078, 0x15b1, 0x2011, 0x4d4e, 0x2204, 0x007e,
+	0x2112, 0x2019, 0x0000, 0x1078, 0x26f8, 0x7810, 0xd0ec, 0x0040,
+	0x18c4, 0x017f, 0x0078, 0x15b9, 0x71c8, 0xa182, 0x0010, 0x0048,
+	0x18cd, 0x2110, 0x71c4, 0x0078, 0x15b1, 0x2011, 0x4d8e, 0x2204,
+	0x007e, 0x2112, 0xc3fd, 0x1078, 0x26f8, 0x027f, 0x017f, 0x0078,
+	0x15b8, 0x71c4, 0x72c8, 0xa184, 0xfffd, 0x00c0, 0x15b1, 0xa284,
+	0xfffd, 0x00c0, 0x15b1, 0x2100, 0x7920, 0x7822, 0x2200, 0x7a24,
+	0x7826, 0x0078, 0x15b8, 0x71c4, 0xd1fc, 0x00c0, 0x18f3, 0x2011,
+	0x51c0, 0x0078, 0x18f5, 0x2011, 0x5240, 0x8107, 0xa084, 0x000f,
+	0x8003, 0x8003, 0x8003, 0xa268, 0x2019, 0x0000, 0x72c8, 0x2091,
+	0x8000, 0xa284, 0x0080, 0x0040, 0x190b, 0x6c14, 0x84ff, 0x00c0,
+	0x190b, 0x6817, 0x0040, 0xa284, 0x0040, 0x0040, 0x1915, 0x6c10,
+	0x84ff, 0x00c0, 0x1915, 0x6813, 0x0001, 0x6800, 0x007e, 0xa226,
+	0x0040, 0x1932, 0x6a02, 0xd4ec, 0x0040, 0x191f, 0xc3a5, 0xd4e4,
+	0x0040, 0x1923, 0xc39d, 0xd4f4, 0x0040, 0x1932, 0x810f, 0xd2f4,
+	0x0040, 0x192e, 0x1078, 0x2777, 0x0078, 0x1932, 0x1078, 0x2755,
+	0x0078, 0x1932, 0x72cc, 0x6808, 0xa206, 0x0040, 0x1954, 0xa2a4,
+	0x00ff, 0x7814, 0xd0e4, 0x00c0, 0x1945, 0xa482, 0x0028, 0x0048,
+	0x1951, 0x0040, 0x1951, 0x0078, 0x1949, 0xa482, 0x0043, 0x0048,
+	0x1951, 0x71c4, 0x71c6, 0x027f, 0x72ca, 0x2091, 0x8001, 0x0078,
+	0x15b3, 0x6a0a, 0xa39d, 0x000a, 0x6804, 0xa305, 0x6806, 0x027f,
+	0x6b0c, 0x71c4, 0x2091, 0x8001, 0x0078, 0x15b7, 0x77c4, 0x1078,
+	0x1dcb, 0x2091, 0x8000, 0x6a14, 0x6b1c, 0x2091, 0x8001, 0x70c8,
+	0x6816, 0x70cc, 0x681e, 0x2708, 0x0078, 0x15b7, 0x70c4, 0x2061,
+	0x4d40, 0x6118, 0x601a, 0x7810, 0xd0ec, 0x00c0, 0x15b9, 0x70c8,
+	0x2061, 0x4d80, 0x6218, 0x601a, 0x0078, 0x15b8, 0x71c4, 0x72c8,
+	0x73cc, 0xa182, 0x0010, 0x00c8, 0x15b2, 0x1078, 0x2799, 0xa384,
+	0x4000, 0x0040, 0x198d, 0xa295, 0x0020, 0x0078, 0x15b7, 0x77c4,
+	0x1078, 0x1dcb, 0x2091, 0x8000, 0x6a08, 0xc28d, 0x6a0a, 0x2091,
+	0x8001, 0x2708, 0x0078, 0x15b8, 0x77c4, 0x1078, 0x1dcb, 0x2091,
+	0x8000, 0x6a08, 0xa294, 0xfff9, 0x6a0a, 0x6804, 0xa005, 0x0040,
+	0x19ab, 0x1078, 0x25ea, 0x2091, 0x8001, 0x2708, 0x0078, 0x15b8,
+	0x77c4, 0x1078, 0x1dcb, 0x2091, 0x8000, 0x6a08, 0xc295, 0x6a0a,
+	0x6804, 0xa005, 0x0040, 0x19be, 0x1078, 0x25ea, 0x2091, 0x8001,
+	0x2708, 0x0078, 0x15b8, 0x77c4, 0x2041, 0x0001, 0x2049, 0x0005,
+	0x2051, 0x0020, 0x2091, 0x8000, 0x1078, 0x1de6, 0x2091, 0x8001,
+	0x2708, 0x6a08, 0x0078, 0x15b8, 0x77c4, 0x7814, 0xd0e4, 0x00c0,
+	0x19e8, 0xd7fc, 0x0040, 0x19e2, 0x1078, 0x1d4b, 0x0040, 0x19e8,
+	0x0078, 0x15bc, 0x1078, 0x1d3b, 0x0040, 0x19e8, 0x0078, 0x15bc,
+	0x73c8, 0x72cc, 0x77c6, 0x73ca, 0x72ce, 0x1078, 0x1e6d, 0x00c0,
+	0x1a12, 0x6818, 0xa005, 0x0040, 0x1a0c, 0x2708, 0x077e, 0x1078,
+	0x27c9, 0x077f, 0x00c0, 0x1a0c, 0x2001, 0x0015, 0xd7fc, 0x00c0,
+	0x1a05, 0x2061, 0x4d40, 0x0078, 0x1a08, 0xc0fd, 0x2061, 0x4d80,
+	0x782a, 0x2091, 0x8001, 0x007c, 0x2091, 0x8001, 0x2001, 0x4005,
+	0x0078, 0x15bc, 0x2091, 0x8001, 0x0078, 0x15ba, 0x77c4, 0x7814,
+	0xd0e4, 0x00c0, 0x1a2a, 0xd7fc, 0x0040, 0x1a24, 0x1078, 0x1d4b,
+	0x0040, 0x1a2a, 0x0078, 0x15bc, 0x1078, 0x1d3b, 0x0040, 0x1a2a,
+	0x0078, 0x15bc, 0x77c6, 0x2041, 0x0021, 0x2049, 0x0005, 0x2051,
+	0x0020, 0x2091, 0x8000, 0x1078, 0x1de6, 0x2009, 0x0016, 0xd7fc,
+	0x00c0, 0x1a3e, 0x2061, 0x4d40, 0x0078, 0x1a41, 0x2061, 0x4d80,
+	0xc1fd, 0x6067, 0x0003, 0x607f, 0x0000, 0x6776, 0x6083, 0x000f,
+	0x792a, 0x1078, 0x25ea, 0x2091, 0x8001, 0x007c, 0x77c8, 0x77ca,
+	0x77c4, 0x77c6, 0x7814, 0xd0e4, 0x00c0, 0x1a65, 0xd7fc, 0x0040,
+	0x1a5f, 0x1078, 0x1d4b, 0x0040, 0x1a65, 0x0078, 0x15bc, 0x1078,
+	0x1d3b, 0x0040, 0x1a65, 0x0078, 0x15bc, 0xa7bc, 0xff00, 0x2091,
+	0x8000, 0x2009, 0x0017, 0xd7fc, 0x00c0, 0x1a72, 0x2061, 0x4d40,
+	0x0078, 0x1a75, 0x2061, 0x4d80, 0xc1fd, 0x607f, 0x0000, 0x6067,
+	0x0002, 0x6776, 0x6083, 0x000f, 0x792a, 0x1078, 0x25ea, 0x2091,
+	0x8001, 0x2041, 0x0021, 0x2049, 0x0005, 0x2051, 0x0010, 0x2091,
+	0x8000, 0x70c8, 0xa005, 0x0040, 0x1a90, 0x60d4, 0xc0fd, 0x60d6,
+	0x1078, 0x1de6, 0x70c8, 0x6836, 0x8738, 0xa784, 0x001f, 0x00c0,
+	0x1a90, 0x2091, 0x8001, 0x007c, 0x7814, 0xd0e4, 0x00c0, 0x1ab0,
+	0x72c8, 0xd284, 0x0040, 0x1aaa, 0x1078, 0x1d4b, 0x0040, 0x1ab0,
+	0x0078, 0x15bc, 0x1078, 0x1d3b, 0x0040, 0x1ab0, 0x0078, 0x15bc,
+	0x72c8, 0x72ca, 0x78ac, 0xa084, 0x0003, 0x00c0, 0x1adb, 0x2039,
+	0x0000, 0xd284, 0x0040, 0x1abd, 0xc7fd, 0x2041, 0x0021, 0x2049,
+	0x0004, 0x2051, 0x0008, 0x1078, 0x1dcb, 0x2091, 0x8000, 0x6808,
+	0xc0d4, 0xa80d, 0x690a, 0x2091, 0x8001, 0x8738, 0xa784, 0x001f,
+	0x00c0, 0x1ac3, 0xa7bc, 0xff00, 0x873f, 0x8738, 0x873f, 0xa784,
+	0x0f00, 0x00c0, 0x1ac3, 0x2091, 0x8000, 0x72c8, 0xd284, 0x00c0,
+	0x1aed, 0x7810, 0xd0ec, 0x0040, 0x1ae9, 0x2069, 0x0100, 0x0078,
+	0x1aef, 0x2069, 0x0200, 0x0078, 0x1aef, 0x2069, 0x0100, 0x6808,
+	0xa084, 0xfffd, 0x680a, 0x6830, 0xd0b4, 0x0040, 0x1b0f, 0x684b,
+	0x0004, 0x20a9, 0x0014, 0x6848, 0xd094, 0x0040, 0x1b01, 0x00f0,
+	0x1afb, 0x684b, 0x0009, 0x20a9, 0x0014, 0x6848, 0xd084, 0x0040,
+	0x1b0b, 0x00f0, 0x1b05, 0x20a9, 0x00fa, 0x00f0, 0x1b0d, 0x2079,
+	0x4d00, 0x2009, 0x0018, 0x72c8, 0xd284, 0x00c0, 0x1b1b, 0x2061,
+	0x4d40, 0x0078, 0x1b1e, 0x2061, 0x4d80, 0xc1fd, 0x792a, 0x6067,
+	0x0001, 0x6083, 0x000f, 0x60a7, 0x0000, 0x60a8, 0x60b2, 0x60b6,
+	0x60d4, 0xd0b4, 0x0040, 0x1b38, 0xc0b4, 0x60d6, 0x0c7e, 0x60b8,
+	0xa065, 0x6008, 0xc0d4, 0x600a, 0x6018, 0x8001, 0x601a, 0x0c7f,
+	0x60d4, 0xa084, 0x77ff, 0x60d6, 0x78ac, 0xc08d, 0x78ae, 0x681b,
+	0x0047, 0x2091, 0x8001, 0x007c, 0xd7fc, 0x00c0, 0x1b4b, 0x2069,
+	0x4d40, 0x0078, 0x1b4d, 0x2069, 0x4d80, 0x71c4, 0x71c6, 0x6916,
+	0x81ff, 0x00c0, 0x1b55, 0x68a7, 0x0001, 0x78ac, 0xc08c, 0x78ae,
+	0xd084, 0x00c0, 0x1b5d, 0x1078, 0x1ecd, 0x007c, 0x75d8, 0x74dc,
+	0x75da, 0x74de, 0x0078, 0x1b67, 0x2029, 0x0000, 0x2520, 0x71c4,
+	0x73c8, 0x72cc, 0x71c6, 0x73ca, 0x72ce, 0x2079, 0x4d00, 0x7dde,
+	0x7cda, 0x7bd6, 0x7ad2, 0x1078, 0x1da4, 0x0040, 0x1c69, 0x20a9,
+	0x0005, 0x20a1, 0x4d14, 0x2091, 0x8000, 0x41a1, 0x2091, 0x8001,
+	0x2009, 0x0040, 0x1078, 0x1fb8, 0x0040, 0x1b8a, 0x1078, 0x1dad,
+	0x0078, 0x1c69, 0x6004, 0xa08c, 0x00ff, 0xa18e, 0x0009, 0x00c0,
+	0x1b95, 0x007e, 0x1078, 0x2339, 0x007f, 0xa084, 0xff00, 0x8007,
+	0x8009, 0x0040, 0x1c09, 0x0c7e, 0x2c68, 0x1078, 0x1da4, 0x0040,
+	0x1bdb, 0x2c00, 0x689e, 0x8109, 0x00c0, 0x1b9c, 0x609f, 0x0000,
+	0x0c7f, 0x0c7e, 0x7ddc, 0x7cd8, 0x7bd4, 0x7ad0, 0xa290, 0x0040,
+	0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x7dde, 0x7cda,
+	0x7bd6, 0x7ad2, 0x2c68, 0x689c, 0xa065, 0x0040, 0x1c08, 0x2009,
+	0x0040, 0x1078, 0x1fb8, 0x00c0, 0x1bf2, 0x6004, 0xa084, 0x00ff,
+	0xa086, 0x0002, 0x00c0, 0x1bdb, 0x6004, 0xa084, 0x00ff, 0xa086,
+	0x000a, 0x00c0, 0x1bd7, 0x017e, 0x1078, 0x2335, 0x017f, 0x2d00,
+	0x6002, 0x0078, 0x1baa, 0x0c7f, 0x0c7e, 0x609c, 0x1078, 0x1e30,
+	0x0c7f, 0x609f, 0x0000, 0x1078, 0x1c6d, 0x2009, 0x0018, 0x6008,
+	0xc0cd, 0x600a, 0x6004, 0x6086, 0x1078, 0x1d5b, 0x1078, 0x1dad,
+	0x0078, 0x1c69, 0x0c7f, 0x0c7e, 0x609c, 0x1078, 0x1e30, 0x0c7f,
+	0x609f, 0x0000, 0x1078, 0x1c6d, 0x2009, 0x0018, 0x6087, 0x0103,
+	0x601b, 0x0003, 0x1078, 0x1d5b, 0x1078, 0x1dad, 0x0078, 0x1c69,
+	0x0c7f, 0x7814, 0xd0e4, 0x00c0, 0x1c2e, 0x6114, 0xd1fc, 0x0040,
+	0x1c17, 0x1078, 0x1d4b, 0x0040, 0x1c2e, 0x0078, 0x1c1b, 0x1078,
+	0x1d3b, 0x0040, 0x1c2e, 0x2029, 0x0000, 0x2520, 0x2009, 0x0018,
+	0x73c8, 0x72cc, 0x6087, 0x0103, 0x601b, 0x0021, 0x1078, 0x1d5b,
+	0x1078, 0x1dad, 0x2001, 0x4007, 0x0078, 0x15bc, 0x74c4, 0x73c8,
+	0x72cc, 0x6014, 0x2091, 0x8000, 0x0e7e, 0x2009, 0x0012, 0xd0fc,
+	0x00c0, 0x1c3e, 0x2071, 0x4d40, 0x0078, 0x1c41, 0x2071, 0x4d80,
+	0xc1fd, 0x792a, 0x7067, 0x0005, 0x71d4, 0xc1dc, 0x71d6, 0x736a,
+	0x726e, 0x7472, 0x7076, 0x707b, 0x0000, 0x2c00, 0x707e, 0xa02e,
+	0x2530, 0x611c, 0xa184, 0x0060, 0x0040, 0x1c58, 0x1078, 0x45a7,
+	0x0e7f, 0x6596, 0x65a6, 0x669a, 0x66aa, 0x60af, 0x0000, 0x60b3,
+	0x0000, 0x6714, 0x6023, 0x0000, 0x1078, 0x25ea, 0x2091, 0x8001,
+	0x007c, 0x70c3, 0x4005, 0x0078, 0x15bd, 0x20a9, 0x0005, 0x2099,
+	0x4d14, 0x2091, 0x8000, 0x530a, 0x2091, 0x8001, 0x2100, 0xa210,
+	0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x007c, 0x71c4,
+	0x70c7, 0x0000, 0x791e, 0x0078, 0x15ba, 0x71c4, 0x71c6, 0x2168,
+	0x0078, 0x1c8c, 0x2069, 0x1000, 0x690c, 0xa016, 0x2d04, 0xa210,
+	0x8d68, 0x8109, 0x00c0, 0x1c8e, 0xa285, 0x0000, 0x00c0, 0x1c9c,
+	0x70c3, 0x4000, 0x0078, 0x1c9e, 0x70c3, 0x4003, 0x70ca, 0x0078,
+	0x15bd, 0x7964, 0x71c6, 0x71c4, 0xa182, 0x0003, 0x00c8, 0x15b2,
+	0x7966, 0x0078, 0x15ba, 0x7964, 0x71c6, 0x0078, 0x15ba, 0x7900,
+	0x71c6, 0x71c4, 0x7902, 0x0078, 0x15ba, 0x7900, 0x71c6, 0x0078,
+	0x15ba, 0x70c4, 0x2011, 0x0000, 0xa08c, 0x000d, 0x0040, 0x1cce,
+	0x810c, 0x0048, 0x1cca, 0x8210, 0x810c, 0x810c, 0x0048, 0x1cca,
+	0x8210, 0x810c, 0x81ff, 0x00c0, 0x15b3, 0x8210, 0x7a0e, 0xd28c,
+	0x0040, 0x1cfa, 0x7910, 0xc1cd, 0x7912, 0x2009, 0x0021, 0x2019,
+	0x0003, 0xd284, 0x0040, 0x1cf4, 0x8108, 0x2019, 0x0041, 0x2011,
+	0x954e, 0x2312, 0x2019, 0x0042, 0x8210, 0x2312, 0x2019, 0x0043,
+	0x8210, 0x2312, 0x2019, 0x0046, 0x8210, 0x2312, 0x2019, 0x0047,
+	0x8210, 0x2312, 0x2019, 0x0006, 0x2011, 0x9553, 0x2112, 0x2011,
+	0x9573, 0x2312, 0x7904, 0x7806, 0x0078, 0x15b9, 0x7804, 0x70c6,
+	0x0078, 0x15ba, 0x71c4, 0xd1fc, 0x00c0, 0x1d0a, 0x2011, 0x51c0,
+	0x0078, 0x1d0c, 0x2011, 0x5240, 0x8107, 0xa084, 0x000f, 0x8003,
+	0x8003, 0x8003, 0xa268, 0x6a14, 0xd2b4, 0x0040, 0x1d1b, 0x2011,
+	0x0001, 0x0078, 0x1d1d, 0x2011, 0x0000, 0x6b0c, 0x0078, 0x15b7,
+	0x017e, 0x7814, 0xd0f4, 0x0040, 0x1d2d, 0x2001, 0x4007, 0x70db,
+	0x0000, 0xa18d, 0x0001, 0x0078, 0x1d39, 0xd0fc, 0x0040, 0x1d38,
+	0x2001, 0x4007, 0x70db, 0x0001, 0xa18d, 0x0001, 0x0078, 0x1d39,
+	0xa006, 0x017f, 0x007c, 0x017e, 0x7814, 0xd0f4, 0x0040, 0x1d48,
+	0x2001, 0x4007, 0x70db, 0x0000, 0xa18d, 0x0001, 0x0078, 0x1d49,
+	0xa006, 0x017f, 0x007c, 0x017e, 0x7814, 0xd0fc, 0x0040, 0x1d58,
+	0x2001, 0x4007, 0x70db, 0x0001, 0xa18d, 0x0001, 0x0078, 0x1d59,
+	0xa006, 0x017f, 0x007c, 0x7112, 0x721a, 0x731e, 0x7810, 0xd0c4,
+	0x0040, 0x1d64, 0x7422, 0x7526, 0xac80, 0x0001, 0x8108, 0x810c,
+	0x81a9, 0x8098, 0x20a1, 0x0030, 0x7003, 0x0000, 0x6084, 0x20a2,
+	0x53a6, 0x7007, 0x0001, 0x7974, 0xa184, 0xff00, 0x0040, 0x1d81,
+	0x810f, 0x810c, 0x810c, 0x8004, 0x8004, 0x8007, 0xa100, 0x0078,
+	0x1d84, 0x8107, 0x8004, 0x8004, 0x797c, 0xa108, 0x7a78, 0xa006,
+	0xa211, 0x7d10, 0xd5c4, 0x0040, 0x1d91, 0x7b84, 0xa319, 0x7c80,
+	0xa421, 0x7008, 0xd0fc, 0x0040, 0x1d91, 0x7003, 0x0001, 0x7007,
+	0x0006, 0x711a, 0x721e, 0x7d10, 0xd5c4, 0x0040, 0x1da1, 0x7322,
+	0x7426, 0xa084, 0x01e0, 0x007c, 0x7848, 0xa065, 0x0040, 0x1dac,
+	0x2c04, 0x784a, 0x2063, 0x0000, 0x007c, 0x0f7e, 0x2079, 0x4d00,
+	0x7848, 0x2062, 0x2c00, 0xa005, 0x00c0, 0x1db8, 0x1078, 0x290c,
+	0x784a, 0x0f7f, 0x007c, 0x2011, 0x9700, 0x7a4a, 0x7bc4, 0x8319,
+	0x0040, 0x1dc8, 0xa280, 0x0032, 0x2012, 0x2010, 0x0078, 0x1dbf,
+	0x2013, 0x0000, 0x007c, 0x017e, 0x027e, 0xd7fc, 0x00c0, 0x1dd4,
+	0x2011, 0x52c0, 0x0078, 0x1dd6, 0x2011, 0x72c0, 0xa784, 0x0f00,
+	0x800b, 0xa784, 0x001f, 0x0040, 0x1de1, 0x8003, 0x8003, 0x8003,
+	0x8003, 0xa105, 0xa268, 0x027f, 0x017f, 0x007c, 0x1078, 0x1dcb,
+	0x2900, 0x682a, 0x2a00, 0x682e, 0x6808, 0xa084, 0xf9ef, 0xa80d,
+	0x690a, 0x0e7e, 0xd7fc, 0x00c0, 0x1dfb, 0x2009, 0x4d53, 0x2071,
+	0x4d40, 0x0078, 0x1dff, 0x2009, 0x4d93, 0x2071, 0x4d80, 0x210c,
+	0x6804, 0xa005, 0x0040, 0x1e0f, 0xa116, 0x00c0, 0x1e0f, 0x2060,
+	0x6000, 0x6806, 0x017e, 0x200b, 0x0000, 0x0078, 0x1e12, 0x2009,
+	0x0000, 0x017e, 0x6804, 0xa065, 0x0040, 0x1e27, 0x6000, 0x6806,
+	0x1078, 0x1e42, 0x1078, 0x2004, 0x6810, 0x7908, 0x8109, 0x790a,
+	0x8001, 0x6812, 0x00c0, 0x1e12, 0x7910, 0xc1a5, 0x7912, 0x017f,
+	0x6902, 0x6906, 0x2d00, 0x2060, 0x1078, 0x2a6d, 0x0e7f, 0x007c,
+	0xa065, 0x0040, 0x1e41, 0x2008, 0x609c, 0xa005, 0x0040, 0x1e3e,
+	0x2062, 0x609f, 0x0000, 0xa065, 0x0078, 0x1e34, 0x7848, 0x794a,
+	0x2062, 0x007c, 0x6007, 0x0103, 0x608f, 0x0000, 0x20a9, 0x001c,
+	0xac80, 0x0005, 0x20a0, 0x2001, 0x0000, 0x40a4, 0x6828, 0x601a,
+	0x682c, 0x6022, 0x007c, 0x0e7e, 0xd7fc, 0x00c0, 0x1e5d, 0x2071,
+	0x4d40, 0x2031, 0x4dc0, 0x0078, 0x1e61, 0x2071, 0x4d80, 0x2031,
+	0x4fc0, 0x7050, 0xa08c, 0x0200, 0x00c0, 0x1e6b, 0xa608, 0x2d0a,
+	0x8000, 0x7052, 0xa006, 0x0e7f, 0x007c, 0x0f7e, 0xd7fc, 0x00c0,
+	0x1e75, 0x2079, 0x4d40, 0x0078, 0x1e77, 0x2079, 0x4d80, 0x1078,
+	0x1dcb, 0x2091, 0x8000, 0x6804, 0x780a, 0xa065, 0x0040, 0x1ecb,
+	0x0078, 0x1e89, 0x2c00, 0x780a, 0x2060, 0x6000, 0xa065, 0x0040,
+	0x1ecb, 0x6010, 0xa306, 0x00c0, 0x1e82, 0x600c, 0xa206, 0x00c0,
+	0x1e82, 0x2c28, 0x784c, 0xac06, 0x00c0, 0x1e98, 0x0078, 0x1ec8,
+	0x6804, 0xac06, 0x00c0, 0x1ea6, 0x6000, 0x2060, 0x6806, 0xa005,
+	0x00c0, 0x1ea6, 0x6803, 0x0000, 0x0078, 0x1eb0, 0x6400, 0x7808,
+	0x2060, 0x6402, 0xa486, 0x0000, 0x00c0, 0x1eb0, 0x2c00, 0x6802,
+	0x2560, 0x0f7f, 0x1078, 0x1e42, 0x0f7e, 0x601b, 0x0005, 0x6023,
+	0x0020, 0x0f7f, 0x1078, 0x2004, 0x0f7e, 0x7908, 0x8109, 0x790a,
+	0x6810, 0x8001, 0x6812, 0x00c0, 0x1ec8, 0x7810, 0xc0a5, 0x7812,
+	0x2001, 0xffff, 0xa005, 0x0f7f, 0x007c, 0x077e, 0x2700, 0x2039,
+	0x0000, 0xd0fc, 0x0040, 0x1ed5, 0xc7fd, 0x2041, 0x0021, 0x2049,
+	0x0004, 0x2051, 0x0008, 0x2091, 0x8000, 0x1078, 0x1de6, 0x8738,
+	0xa784, 0x001f, 0x00c0, 0x1edd, 0xa7bc, 0xff00, 0x873f, 0x8738,
+	0x873f, 0xa784, 0x0f00, 0x00c0, 0x1edd, 0x2091, 0x8001, 0x077f,
+	0x007c, 0x786c, 0x2009, 0x9574, 0x210c, 0xa10d, 0x0040, 0x1efb,
+	0xa065, 0x0078, 0x2356, 0x2061, 0x0000, 0x6018, 0xd084, 0x00c0,
+	0x1f1b, 0x7810, 0xd08c, 0x0040, 0x1f0c, 0xc08c, 0x7812, 0xc7fc,
+	0x2069, 0x4d40, 0x0078, 0x1f11, 0xc08d, 0x7812, 0x2069, 0x4d80,
+	0xc7fd, 0x2091, 0x8000, 0x681c, 0x681f, 0x0000, 0x2091, 0x8001,
+	0xa005, 0x00c0, 0x1f1c, 0x007c, 0xa08c, 0xfff0, 0x0040, 0x1f22,
+	0x1078, 0x290c, 0x0079, 0x1f24, 0x1f34, 0x1f37, 0x1f3d, 0x1f41,
+	0x1f35, 0x1f45, 0x1f35, 0x1f35, 0x1f35, 0x1f4b, 0x1f7c, 0x1f80,
+	0x1f86, 0x1f9b, 0x1f35, 0x1f35, 0x007c, 0x1078, 0x290c, 0x1078,
+	0x1ecd, 0x2001, 0x8001, 0x0078, 0x1fa7, 0x2001, 0x8003, 0x0078,
+	0x1fa7, 0x2001, 0x8004, 0x0078, 0x1fa7, 0x1078, 0x1ecd, 0x2001,
+	0x8006, 0x0078, 0x1fa7, 0x2091, 0x8000, 0x077e, 0xd7fc, 0x00c0,
+	0x1f57, 0x2069, 0x4d40, 0x2039, 0x0009, 0x0078, 0x1f5b, 0x2069,
+	0x4d80, 0x2039, 0x0009, 0x6800, 0xa086, 0x0000, 0x0040, 0x1f65,
+	0x007f, 0x6f1e, 0x2091, 0x8001, 0x007c, 0x6874, 0x077f, 0xa0bc,
+	0xff00, 0x2041, 0x0021, 0x2049, 0x0004, 0x2051, 0x0010, 0x1078,
+	0x1de6, 0x8738, 0xa784, 0x001f, 0x00c0, 0x1f6f, 0x2091, 0x8001,
+	0x2001, 0x800a, 0x0078, 0x1fa7, 0x2001, 0x800c, 0x0078, 0x1fa7,
+	0x1078, 0x1ecd, 0x2001, 0x800d, 0x0078, 0x1fa7, 0x7814, 0xd0e4,
+	0x00c0, 0x1f99, 0xd0ec, 0x0040, 0x1f93, 0xd7fc, 0x0040, 0x1f93,
+	0x78e4, 0x0078, 0x1f94, 0x78e0, 0x70c6, 0x2001, 0x800e, 0x0078,
+	0x1fa7, 0x0078, 0x1f35, 0xd7fc, 0x0040, 0x1fa1, 0x78ec, 0x0078,
+	0x1fa2, 0x78e8, 0x70c6, 0x2001, 0x000d, 0x0078, 0x1fa7, 0x70c2,
+	0xd7fc, 0x00c0, 0x1faf, 0x70db, 0x0000, 0x0078, 0x1fb1, 0x70db,
+	0x0001, 0x2061, 0x0000, 0x601b, 0x0001, 0x2091, 0x4080, 0x007c,
+	0xac80, 0x0001, 0x81ff, 0x0040, 0x1fe3, 0x2099, 0x0030, 0x20a0,
+	0x700c, 0xa084, 0x03ff, 0x0040, 0x1fc5, 0x7018, 0x007e, 0x701c,
+	0x007e, 0x7020, 0x007e, 0x7024, 0x007e, 0x7112, 0x81ac, 0x721a,
+	0x731e, 0x7422, 0x7526, 0x7003, 0x0001, 0x7007, 0x0001, 0x7008,
+	0x800b, 0x00c8, 0x1fd7, 0x7007, 0x0002, 0xa08c, 0x01e0, 0x00c0,
+	0x1fe3, 0x53a5, 0xa006, 0x7003, 0x0000, 0x7007, 0x0004, 0x007f,
+	0x7026, 0x007f, 0x7022, 0x007f, 0x701e, 0x007f, 0x701a, 0x007c,
+	0x2011, 0x0020, 0x2009, 0x0010, 0x6b0a, 0x6c0e, 0x6803, 0xfd00,
+	0x6807, 0x0018, 0x6a1a, 0x2d00, 0xa0e8, 0x0008, 0xa290, 0x0004,
+	0x8109, 0x00c0, 0x1ff4, 0x007c, 0x6004, 0x6086, 0x2c08, 0x2063,
+	0x0000, 0x7868, 0xa005, 0x796a, 0x0040, 0x2011, 0x2c02, 0x0078,
+	0x2012, 0x796e, 0x007c, 0x0c7e, 0x2061, 0x4d00, 0x6887, 0x0103,
+	0x2d08, 0x206b, 0x0000, 0x6068, 0xa005, 0x616a, 0x0040, 0x2023,
+	0x2d02, 0x0078, 0x2024, 0x616e, 0x0c7f, 0x007c, 0x2091, 0x8000,
+	0x2c04, 0x786e, 0xa005, 0x00c0, 0x202e, 0x786a, 0x2091, 0x8001,
+	0x609c, 0xa005, 0x0040, 0x2047, 0x0c7e, 0x2060, 0x2008, 0x609c,
+	0xa005, 0x0040, 0x2043, 0x2062, 0x609f, 0x0000, 0xa065, 0x609c,
+	0xa005, 0x00c0, 0x203b, 0x7848, 0x794a, 0x2062, 0x0c7f, 0x7848,
+	0x2062, 0x609f, 0x0000, 0xac85, 0x0000, 0x00c0, 0x2051, 0x1078,
+	0x290c, 0x784a, 0x007c, 0x20a9, 0x0010, 0xa006, 0x8004, 0x8086,
+	0x818e, 0x00c8, 0x205c, 0xa200, 0x00f0, 0x2057, 0x8086, 0x818e,
+	0x007c, 0x157e, 0x20a9, 0x0010, 0xa005, 0x0040, 0x2082, 0xa11a,
+	0x00c8, 0x2082, 0x8213, 0x818d, 0x0048, 0x2075, 0xa11a, 0x00c8,
+	0x2076, 0x00f0, 0x206a, 0x0078, 0x207a, 0xa11a, 0x2308, 0x8210,
+	0x00f0, 0x206a, 0x007e, 0x3200, 0xa084, 0xf7ff, 0x2080, 0x007f,
+	0x157f, 0x007c, 0x007e, 0x3200, 0xa085, 0x0800, 0x0078, 0x207e,
+	0x7d74, 0x70d0, 0xa506, 0x0040, 0x216e, 0x7810, 0x2050, 0x7800,
+	0xd08c, 0x0040, 0x20aa, 0xdaec, 0x0040, 0x20aa, 0x0e7e, 0x2091,
+	0x8000, 0x2071, 0x0020, 0x7004, 0xa005, 0x00c0, 0x20a7, 0x7008,
+	0x0e7f, 0xa086, 0x0008, 0x0040, 0x20aa, 0x0078, 0x216e, 0x0e7f,
+	0x0078, 0x216e, 0x1078, 0x1da4, 0x0040, 0x216e, 0xa046, 0x7970,
+	0x2500, 0x8000, 0xa112, 0x2009, 0x0040, 0x00c8, 0x20b9, 0x0078,
+	0x20c0, 0x72d0, 0xa206, 0x0040, 0x20c0, 0x8840, 0x2009, 0x0080,
+	0x0c7e, 0x7112, 0x7007, 0x0001, 0x2099, 0x0030, 0x20a9, 0x0020,
+	0xac80, 0x0001, 0x20a0, 0x2061, 0x0000, 0x88ff, 0x0040, 0x20d2,
+	0x1078, 0x1da4, 0x7008, 0xd0fc, 0x0040, 0x20d2, 0x7007, 0x0002,
+	0x2091, 0x8001, 0xa08c, 0x01e0, 0x00c0, 0x2109, 0x53a5, 0x8cff,
+	0x00c0, 0x20e7, 0x88ff, 0x0040, 0x2158, 0x0078, 0x20f1, 0x2c00,
+	0x788e, 0x20a9, 0x0020, 0xac80, 0x0001, 0x20a0, 0x53a5, 0x0078,
+	0x2158, 0xa046, 0x7218, 0x731c, 0xdac4, 0x0040, 0x20f9, 0x7420,
+	0x7524, 0xa292, 0x0040, 0xa39b, 0x0000, 0xa4a3, 0x0000, 0xa5ab,
+	0x0000, 0x721a, 0x731e, 0xdac4, 0x0040, 0x2109, 0x7422, 0x7526,
+	0xa006, 0x7007, 0x0004, 0x0040, 0x2158, 0x8cff, 0x0040, 0x2112,
+	0x1078, 0x1dad, 0x0c7f, 0x1078, 0x1dad, 0xa046, 0x7888, 0x8000,
+	0x788a, 0xa086, 0x0002, 0x0040, 0x2138, 0x7a7c, 0x7b78, 0xdac4,
+	0x0040, 0x2124, 0x7c84, 0x7d80, 0x7974, 0x8107, 0x8004, 0x8004,
+	0xa210, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x721a,
+	0x731e, 0xdac4, 0x0040, 0x216e, 0x7422, 0x7526, 0x0078, 0x216e,
+	0x6014, 0xd0fc, 0x00c0, 0x2140, 0x2069, 0x4d40, 0x0078, 0x2142,
+	0x2069, 0x4d80, 0x2091, 0x8000, 0x681f, 0x0002, 0x88ff, 0x0040,
+	0x214e, 0xa046, 0x788c, 0x2060, 0x0078, 0x2138, 0x788b, 0x0000,
+	0x78ac, 0xa085, 0x0003, 0x78ae, 0x2091, 0x8001, 0x0078, 0x216e,
+	0x0c7f, 0x788b, 0x0000, 0x1078, 0x2307, 0x6004, 0xa084, 0x000f,
+	0x1078, 0x216f, 0x88ff, 0x0040, 0x216c, 0x788c, 0x2060, 0x6004,
+	0xa084, 0x000f, 0x1078, 0x216f, 0x0078, 0x2088, 0x007c, 0x0079,
+	0x2171, 0x2181, 0x219f, 0x21bd, 0x2181, 0x21ce, 0x2192, 0x2181,
+	0x2181, 0x2181, 0x219d, 0x21bb, 0x2181, 0x2181, 0x2181, 0x2181,
+	0x2181, 0x2039, 0x0400, 0x78bc, 0xa705, 0x78be, 0x6008, 0xa705,
+	0x600a, 0x1078, 0x2211, 0x609c, 0x78ba, 0x609f, 0x0000, 0x1078,
+	0x22f1, 0x007c, 0x78bc, 0xd0c4, 0x0040, 0x2198, 0x0078, 0x2181,
+	0x601c, 0xc0bd, 0x601e, 0x0078, 0x21a5, 0x1078, 0x2339, 0x78bc,
+	0xd0c4, 0x0040, 0x21a5, 0x0078, 0x2181, 0x78bf, 0x0000, 0x6004,
+	0x8007, 0xa084, 0x00ff, 0x78b2, 0x8001, 0x0040, 0x21b8, 0x1078,
+	0x2211, 0x0040, 0x21b8, 0x78bc, 0xc0c5, 0x78be, 0x0078, 0x21ba,
+	0x0078, 0x2230, 0x007c, 0x1078, 0x2335, 0x78bc, 0xa08c, 0x0e00,
+	0x00c0, 0x21c5, 0xd0c4, 0x00c0, 0x21c7, 0x0078, 0x2181, 0x1078,
+	0x2211, 0x00c0, 0x21cd, 0x0078, 0x2230, 0x007c, 0x78bc, 0xd0c4,
+	0x0040, 0x21d4, 0x0078, 0x2181, 0x78bf, 0x0000, 0x6714, 0x2011,
+	0x0001, 0x22a8, 0x6018, 0xa084, 0x00ff, 0xa005, 0x0040, 0x21f4,
+	0xa7bc, 0xff00, 0x20a9, 0x0020, 0xa08e, 0x0001, 0x0040, 0x21f4,
+	0xa7bc, 0x8000, 0x2011, 0x0002, 0x20a9, 0x0100, 0xa08e, 0x0002,
+	0x0040, 0x21f4, 0x0078, 0x220e, 0x1078, 0x1dcb, 0x2d00, 0x2091,
+	0x8000, 0x682b, 0x0000, 0x682f, 0x0000, 0x6808, 0xa084, 0xffde,
+	0x680a, 0xade8, 0x0010, 0x2091, 0x8001, 0x00f0, 0x21f7, 0x8211,
+	0x0040, 0x220e, 0x20a9, 0x0100, 0x0078, 0x21f7, 0x1078, 0x1dad,
+	0x007c, 0x609f, 0x0000, 0x78b4, 0xa06d, 0x2c00, 0x78b6, 0x00c0,
+	0x221c, 0x78ba, 0x0078, 0x2224, 0x689e, 0x2d00, 0x6002, 0x78b8,
+	0xad06, 0x00c0, 0x2224, 0x6002, 0x78b0, 0x8001, 0x78b2, 0x00c0,
+	0x222f, 0x78bc, 0xc0c4, 0x78be, 0x78b8, 0x2060, 0xa006, 0x007c,
+	0x0e7e, 0xa02e, 0x2530, 0x7dba, 0x7db6, 0x65ae, 0x65b2, 0x601c,
+	0x60a2, 0x2048, 0xa984, 0xe1ff, 0x601e, 0xa984, 0x0060, 0x0040,
+	0x2243, 0x1078, 0x45a7, 0x6596, 0x65a6, 0x669a, 0x66aa, 0x6714,
+	0x2071, 0x4d80, 0xd7fc, 0x00c0, 0x224f, 0x2071, 0x4d40, 0xa784,
+	0x0f00, 0x800b, 0xa784, 0x001f, 0x0040, 0x225a, 0x8003, 0x8003,
+	0x8003, 0x8003, 0xa105, 0x71c4, 0xa168, 0x2700, 0x8007, 0xa084,
+	0x000f, 0x8003, 0x8003, 0x8003, 0x71c8, 0xa100, 0x60c2, 0x2091,
+	0x8000, 0x7810, 0xd0f4, 0x00c0, 0x2274, 0x6e08, 0xd684, 0x0040,
+	0x228a, 0xd9fc, 0x00c0, 0x228a, 0x2091, 0x8001, 0x1078, 0x1e42,
+	0x2091, 0x8000, 0x1078, 0x2004, 0x2091, 0x8001, 0x7814, 0xd0e4,
+	0x00c0, 0x22ef, 0x7810, 0xd0f4, 0x0040, 0x22ef, 0x601b, 0x0021,
+	0x0078, 0x22ef, 0x6024, 0xa096, 0x0001, 0x00c0, 0x2291, 0x8000,
+	0x6026, 0x6a10, 0x6814, 0xa202, 0x0048, 0x22a4, 0x0040, 0x22a4,
+	0x2091, 0x8001, 0x2039, 0x0200, 0x609c, 0x78ba, 0x609f, 0x0000,
+	0x1078, 0x22f1, 0x0078, 0x22ef, 0x2c08, 0xd9fc, 0x0040, 0x22cc,
+	0x6800, 0xa065, 0x0040, 0x22cc, 0x6a04, 0x7000, 0xa084, 0x0002,
+	0x0040, 0x22c2, 0x704c, 0xa206, 0x00c0, 0x22c2, 0x6b04, 0x2160,
+	0x2304, 0x6002, 0xa005, 0x00c0, 0x22be, 0x6902, 0x2260, 0x6102,
+	0x0078, 0x22d8, 0x2d00, 0x2060, 0x1078, 0x2a6d, 0x6e08, 0x2160,
+	0x6202, 0x6906, 0x0078, 0x22d8, 0x6800, 0x6902, 0xa065, 0x0040,
+	0x22d4, 0x6102, 0x0078, 0x22d5, 0x6906, 0x2160, 0x6003, 0x0000,
+	0x2160, 0xd9fc, 0x0040, 0x22df, 0xa6b4, 0xfffc, 0x6e0a, 0x6810,
+	0x7d08, 0x8528, 0x7d0a, 0x8000, 0x6812, 0x2091, 0x8001, 0xd6b4,
+	0x0040, 0x22ef, 0xa6b6, 0x0040, 0x6e0a, 0x1078, 0x1e53, 0x0e7f,
+	0x007c, 0x6008, 0xa705, 0x600a, 0x2091, 0x8000, 0x1078, 0x2004,
+	0x2091, 0x8001, 0x78b8, 0xa065, 0x0040, 0x2304, 0x609c, 0x78ba,
+	0x609f, 0x0000, 0x0078, 0x22f1, 0x78b6, 0x78ba, 0x007c, 0x7970,
+	0x7874, 0x2818, 0xd384, 0x0040, 0x2311, 0x8000, 0xa112, 0x0048,
+	0x2316, 0x8000, 0xa112, 0x00c8, 0x2326, 0xc384, 0x7a7c, 0x721a,
+	0x7a78, 0x721e, 0xdac4, 0x0040, 0x2321, 0x7a84, 0x7222, 0x7a80,
+	0x7226, 0xa006, 0xd384, 0x0040, 0x2326, 0x8000, 0x7876, 0x70d2,
+	0x781c, 0xa005, 0x0040, 0x2334, 0x8001, 0x781e, 0x00c0, 0x2334,
+	0x0068, 0x2334, 0x2091, 0x4080, 0x007c, 0x2039, 0x234d, 0x0078,
+	0x233b, 0x2039, 0x2353, 0x2704, 0xa005, 0x0040, 0x234c, 0xac00,
+	0x2068, 0x6908, 0x6810, 0x6912, 0x680a, 0x690c, 0x6814, 0x6916,
+	0x680e, 0x8738, 0x0078, 0x233b, 0x007c, 0x0003, 0x0009, 0x000f,
+	0x0015, 0x001b, 0x0000, 0x0015, 0x001b, 0x0000, 0x2041, 0x0000,
+	0x780c, 0x0079, 0x235b, 0x252d, 0x2500, 0x235f, 0x23d8, 0x2039,
+	0x9574, 0x2734, 0x7d10, 0x0078, 0x237f, 0x6084, 0xa086, 0x0103,
+	0x00c0, 0x23c1, 0x6114, 0x6018, 0xa105, 0x0040, 0x2374, 0x86ff,
+	0x00c0, 0x2390, 0x0078, 0x23c1, 0x8603, 0xa080, 0x9555, 0x620c,
+	0x2202, 0x8000, 0x6210, 0x2202, 0x1078, 0x2026, 0x8630, 0xa68e,
+	0x000f, 0x0040, 0x244c, 0x786c, 0xa065, 0x00c0, 0x2365, 0x7808,
+	0xa602, 0x00c8, 0x2390, 0xd5ac, 0x00c0, 0x2390, 0x263a, 0x007c,
+	0xa682, 0x0003, 0x00c8, 0x244c, 0x2091, 0x8000, 0x2069, 0x0000,
+	0x6818, 0xd084, 0x00c0, 0x23bc, 0x2011, 0x9555, 0x2204, 0x70c6,
+	0x8210, 0x2204, 0x70ca, 0xd684, 0x00c0, 0x23ac, 0x8210, 0x2204,
+	0x70da, 0x8210, 0x2204, 0x70de, 0xa685, 0x8020, 0x70c2, 0x681b,
+	0x0001, 0x2091, 0x4080, 0x7810, 0xa084, 0xffcf, 0x7812, 0x2091,
+	0x8001, 0x203b, 0x0000, 0x007c, 0x7810, 0xc0ad, 0x7812, 0x0078,
+	0x244c, 0x263a, 0x1078, 0x2537, 0x00c0, 0x255a, 0x786c, 0xa065,
+	0x00c0, 0x2365, 0x2091, 0x8000, 0x7810, 0xa084, 0xffcf, 0x86ff,
+	0x0040, 0x23d3, 0xc0ad, 0x7812, 0x2091, 0x8001, 0x0078, 0x255a,
+	0x2039, 0x9574, 0x2734, 0x7d10, 0x0078, 0x23f4, 0x6084, 0xa086,
+	0x0103, 0x00c0, 0x2435, 0x6114, 0x6018, 0xa105, 0x0040, 0x23ed,
+	0x86ff, 0x00c0, 0x2405, 0x0078, 0x2435, 0xa680, 0x9555, 0x620c,
+	0x2202, 0x1078, 0x2026, 0x8630, 0xa68e, 0x001e, 0x0040, 0x244c,
+	0x786c, 0xa065, 0x00c0, 0x23de, 0x7808, 0xa602, 0x00c8, 0x2405,
+	0xd5ac, 0x00c0, 0x2405, 0x263a, 0x007c, 0xa682, 0x0006, 0x00c8,
+	0x244c, 0x2091, 0x8000, 0x2069, 0x0000, 0x6818, 0xd084, 0x00c0,
+	0x2430, 0x2011, 0x9555, 0x2009, 0x954e, 0x26a8, 0x211c, 0x2204,
+	0x201a, 0x8108, 0x8210, 0x00f0, 0x2416, 0xa685, 0x8030, 0x70c2,
 	0x681b, 0x0001, 0x2091, 0x4080, 0x7810, 0xa084, 0xffcf, 0x7812,
-	0x2091, 0x8001, 0xa006, 0x2009, 0x9275, 0x200a, 0x203a, 0x007c,
-	0x7810, 0xc0ad, 0x7812, 0x0078, 0x2454, 0x263a, 0x1078, 0x253f,
-	0x00c0, 0x254e, 0x786c, 0xa065, 0x00c0, 0x23eb, 0x2091, 0x8000,
-	0x7810, 0xa084, 0xffcf, 0x86ff, 0x0040, 0x244f, 0xc0ad, 0x7812,
-	0x2091, 0x8001, 0x0078, 0x254e, 0x2091, 0x8000, 0x7007, 0x0004,
-	0x7994, 0x70d4, 0xa102, 0x0048, 0x2465, 0x0040, 0x246f, 0x7b90,
-	0xa302, 0x00c0, 0x246f, 0x0078, 0x2468, 0x8002, 0x00c0, 0x246f,
+	0x2091, 0x8001, 0xa006, 0x2009, 0x9575, 0x200a, 0x203a, 0x007c,
+	0x7810, 0xc0ad, 0x7812, 0x0078, 0x244c, 0x263a, 0x1078, 0x2537,
+	0x00c0, 0x255a, 0x786c, 0xa065, 0x00c0, 0x23de, 0x2091, 0x8000,
+	0x7810, 0xa084, 0xffcf, 0x86ff, 0x0040, 0x2447, 0xc0ad, 0x7812,
+	0x2091, 0x8001, 0x0078, 0x255a, 0x2091, 0x8000, 0x7007, 0x0004,
+	0x7994, 0x70d4, 0xa102, 0x0048, 0x245d, 0x0040, 0x2467, 0x7b90,
+	0xa302, 0x00c0, 0x2467, 0x0078, 0x2460, 0x8002, 0x00c0, 0x2467,
 	0x263a, 0x7810, 0xc0ad, 0x7812, 0x2091, 0x8001, 0x007c, 0xa184,
-	0xff00, 0x0040, 0x247c, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004,
-	0x8007, 0xa100, 0x0078, 0x247f, 0x8107, 0x8004, 0x8004, 0x7a9c,
+	0xff00, 0x0040, 0x2474, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004,
+	0x8007, 0xa100, 0x0078, 0x2477, 0x8107, 0x8004, 0x8004, 0x7a9c,
 	0xa210, 0x721a, 0x7a98, 0xa006, 0xa211, 0x721e, 0xd4c4, 0x0040,
-	0x248f, 0x7aa4, 0xa211, 0x7222, 0x7aa0, 0xa211, 0x7226, 0x20a1,
-	0x0030, 0x7003, 0x0000, 0x2009, 0x9254, 0x260a, 0x8109, 0x2198,
-	0x2104, 0xd084, 0x0040, 0x249d, 0x8633, 0xa6b0, 0x0002, 0x26a8,
+	0x2487, 0x7aa4, 0xa211, 0x7222, 0x7aa0, 0xa211, 0x7226, 0x20a1,
+	0x0030, 0x7003, 0x0000, 0x2009, 0x9554, 0x260a, 0x8109, 0x2198,
+	0x2104, 0xd084, 0x0040, 0x2495, 0x8633, 0xa6b0, 0x0002, 0x26a8,
 	0x53a6, 0x8603, 0x7012, 0x7007, 0x0001, 0x7990, 0x7894, 0x8000,
-	0xa10a, 0x00c8, 0x24ac, 0xa006, 0x2028, 0x7974, 0xa184, 0xff00,
-	0x0040, 0x24bb, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004, 0x8007,
-	0xa100, 0x0078, 0x24be, 0x8107, 0x8004, 0x8004, 0x797c, 0xa108,
-	0x7a78, 0xa006, 0xa211, 0xd4c4, 0x0040, 0x24ca, 0x7b84, 0xa319,
-	0x7c80, 0xa421, 0x7008, 0xd0fc, 0x0040, 0x24ca, 0xa084, 0x01e0,
-	0x0040, 0x24ef, 0x7d10, 0x2031, 0x9254, 0x2634, 0x78a8, 0x8000,
-	0x78aa, 0xd08c, 0x00c0, 0x24e4, 0x7007, 0x0006, 0x7004, 0xd094,
-	0x00c0, 0x24de, 0x0078, 0x2456, 0x2069, 0x4a47, 0x206b, 0x0003,
-	0x78ac, 0xa085, 0x0300, 0x78ae, 0xa006, 0x0078, 0x24f8, 0x2030,
+	0xa10a, 0x00c8, 0x24a4, 0xa006, 0x2028, 0x7974, 0xa184, 0xff00,
+	0x0040, 0x24b3, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004, 0x8007,
+	0xa100, 0x0078, 0x24b6, 0x8107, 0x8004, 0x8004, 0x797c, 0xa108,
+	0x7a78, 0xa006, 0xa211, 0xd4c4, 0x0040, 0x24c2, 0x7b84, 0xa319,
+	0x7c80, 0xa421, 0x7008, 0xd0fc, 0x0040, 0x24c2, 0xa084, 0x01e0,
+	0x0040, 0x24e7, 0x7d10, 0x2031, 0x9554, 0x2634, 0x78a8, 0x8000,
+	0x78aa, 0xd08c, 0x00c0, 0x24dc, 0x7007, 0x0006, 0x7004, 0xd094,
+	0x00c0, 0x24d6, 0x0078, 0x244e, 0x2069, 0x4d47, 0x206b, 0x0003,
+	0x78ac, 0xa085, 0x0300, 0x78ae, 0xa006, 0x0078, 0x24f0, 0x2030,
 	0x75d6, 0x2091, 0x4080, 0x7d96, 0x7d10, 0xa5ac, 0xffcf, 0x7d12,
 	0x2091, 0x8001, 0x78aa, 0x7007, 0x0006, 0x263a, 0x7003, 0x0001,
-	0x711a, 0x721e, 0xd5c4, 0x0040, 0x2507, 0x7322, 0x7426, 0x007c,
-	0x6084, 0xa086, 0x0103, 0x00c0, 0x252b, 0x6114, 0x6018, 0xa105,
-	0x00c0, 0x252b, 0x2069, 0x0000, 0x6818, 0xd084, 0x00c0, 0x252b,
+	0x711a, 0x721e, 0xd5c4, 0x0040, 0x24ff, 0x7322, 0x7426, 0x007c,
+	0x6084, 0xa086, 0x0103, 0x00c0, 0x2523, 0x6114, 0x6018, 0xa105,
+	0x00c0, 0x2523, 0x2069, 0x0000, 0x6818, 0xd084, 0x00c0, 0x2523,
 	0x600c, 0x70c6, 0x6010, 0x70ca, 0x70c3, 0x8020, 0x681b, 0x0001,
-	0x2091, 0x4080, 0x1078, 0x203d, 0x0068, 0x252a, 0x786c, 0xa065,
-	0x00c0, 0x2508, 0x007c, 0x1078, 0x253f, 0x00c0, 0x254e, 0x786c,
-	0xa065, 0x00c0, 0x2508, 0x0078, 0x254e, 0x1078, 0x253f, 0x00c0,
-	0x254e, 0x786c, 0xa065, 0x00c0, 0x2535, 0x0078, 0x254e, 0x1078,
-	0x2554, 0x00c0, 0x2546, 0xa085, 0x0001, 0x007c, 0x1078, 0x2563,
-	0x00c0, 0x254c, 0x2041, 0x0001, 0x7d10, 0x007c, 0x88ff, 0x0040,
-	0x2553, 0x2091, 0x4080, 0x007c, 0x7b90, 0x7994, 0x70d4, 0xa102,
-	0x00c0, 0x255d, 0xa385, 0x0000, 0x007c, 0x0048, 0x2561, 0xa302,
-	0x007c, 0x8002, 0x007c, 0x7810, 0xd0ec, 0x0040, 0x257b, 0x0e7e,
-	0x2091, 0x8000, 0x2071, 0x0020, 0x7004, 0xa005, 0x00c0, 0x2578,
-	0x7008, 0x0e7f, 0xa086, 0x0008, 0x0040, 0x257b, 0x0078, 0x25cc,
-	0x0e7f, 0x0078, 0x25cc, 0xa184, 0xff00, 0x0040, 0x2588, 0x810f,
-	0x810c, 0x810c, 0x8004, 0x8004, 0x8007, 0xa100, 0x0078, 0x258b,
-	0x8107, 0x8004, 0x8004, 0x7a9c, 0x7b98, 0x7ca4, 0x7da0, 0xa210,
-	0xa006, 0xa319, 0xa421, 0xa529, 0x2009, 0x0018, 0x6028, 0xa005,
-	0x0040, 0x259c, 0x2009, 0x0040, 0x1078, 0x1d92, 0x0040, 0x25be,
-	0x78a8, 0x8000, 0x78aa, 0xd08c, 0x00c0, 0x25cc, 0x6014, 0xd0fc,
-	0x00c0, 0x25ae, 0x2069, 0x4a40, 0x0078, 0x25b0, 0x2069, 0x4a80,
-	0x2091, 0x8000, 0x681f, 0x0003, 0x78ab, 0x0000, 0x78ac, 0xa085,
-	0x0300, 0x78ae, 0x2091, 0x8001, 0x0078, 0x25cc, 0x78ab, 0x0000,
-	0x1078, 0x203d, 0x7990, 0x7894, 0x8000, 0xa10a, 0x00c8, 0x25c9,
-	0xa006, 0x7896, 0x70d6, 0xa006, 0x2071, 0x0010, 0x2091, 0x8001,
-	0x007c, 0x2138, 0xd7fc, 0x00c0, 0x25d9, 0x2009, 0x4a59, 0x0078,
-	0x25db, 0x2009, 0x4a99, 0x2091, 0x8000, 0x200a, 0x0f7e, 0xd7fc,
-	0x00c0, 0x25f2, 0x2009, 0x4a40, 0x2001, 0x4a04, 0x2004, 0xd0ec,
-	0x0040, 0x25ee, 0x2079, 0x0100, 0x0078, 0x25f6, 0x2079, 0x0200,
-	0x0078, 0x25f6, 0x2009, 0x4a80, 0x2079, 0x0100, 0x2104, 0xa086,
-	0x0000, 0x00c0, 0x260f, 0xd7fc, 0x00c0, 0x2602, 0x2009, 0x4a45,
-	0x0078, 0x2604, 0x2009, 0x4a85, 0x2104, 0xa005, 0x00c0, 0x260f,
-	0x7830, 0xa084, 0x00c0, 0x00c0, 0x260f, 0x781b, 0x0045, 0x0f7f,
-	0x007c, 0x2009, 0x0002, 0x2069, 0x4a00, 0x6810, 0xd0ec, 0x00c0,
-	0x2672, 0x2071, 0x4a80, 0x2079, 0x0100, 0x2021, 0x4cbf, 0x784b,
-	0x000f, 0x2019, 0x4205, 0xd184, 0x0040, 0x2632, 0x6810, 0xd0ec,
-	0x0040, 0x262e, 0x20a1, 0x012b, 0x0078, 0x2634, 0x20a1, 0x022b,
-	0x0078, 0x2634, 0x20a1, 0x012b, 0x2304, 0xa005, 0x0040, 0x2641,
-	0x789a, 0x8318, 0x23ac, 0x8318, 0x2398, 0x53a6, 0x3318, 0x0078,
-	0x2634, 0x789b, 0x0020, 0x20a9, 0x0010, 0x78af, 0x0000, 0x78af,
-	0x8020, 0x00f0, 0x2645, 0x7003, 0x0000, 0x017e, 0xd18c, 0x2009,
-	0x0000, 0x0040, 0x2654, 0xc1bd, 0x1078, 0x283d, 0x017f, 0x7020,
-	0xa084, 0x000f, 0x007e, 0x6814, 0xd0e4, 0x007f, 0x00c0, 0x2664,
-	0xa085, 0x6340, 0x0078, 0x2666, 0xa085, 0x62c0, 0x7806, 0x780f,
-	0x9200, 0x7843, 0x00d8, 0x7853, 0x0080, 0x780b, 0x0008, 0x7456,
-	0x7053, 0x0000, 0x8109, 0x0040, 0x2685, 0x2071, 0x4a40, 0x6810,
-	0xd0ec, 0x0040, 0x267f, 0x2079, 0x0100, 0x0078, 0x2681, 0x2079,
-	0x0200, 0x2021, 0x4abf, 0x0078, 0x261f, 0x007c, 0x017e, 0xd1bc,
-	0x00c0, 0x269a, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f,
-	0x0040, 0x2696, 0x2011, 0x0101, 0x0078, 0x269c, 0x2011, 0x0201,
-	0x0078, 0x269c, 0x2011, 0x0101, 0xa18c, 0x000f, 0x2204, 0xa084,
-	0xfff0, 0xa105, 0x2012, 0x017f, 0x1078, 0x283d, 0x007c, 0xd3fc,
-	0x00c0, 0x26ba, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f,
-	0x0040, 0x26b6, 0x2011, 0x0101, 0x0078, 0x26bc, 0x2011, 0x0201,
-	0x0078, 0x26bc, 0x2011, 0x0101, 0x20a9, 0x0009, 0x810b, 0x00f0,
-	0x26be, 0xa18c, 0x0e00, 0x2204, 0xa084, 0xf1ff, 0xa105, 0x2012,
-	0x007c, 0x2019, 0x0002, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x0040,
-	0x26d6, 0x8319, 0x2009, 0x0101, 0x0078, 0x26d8, 0x2009, 0x0101,
-	0x20a9, 0x0005, 0x8213, 0x00f0, 0x26da, 0xa294, 0x00e0, 0x2104,
-	0xa084, 0xff1f, 0xa205, 0x200a, 0x8319, 0x0040, 0x26eb, 0x2009,
-	0x0201, 0x0078, 0x26d8, 0x007c, 0xd3fc, 0x00c0, 0x26ff, 0x007e,
-	0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x26fb, 0x2011,
-	0x0101, 0x0078, 0x2701, 0x2011, 0x0201, 0x0078, 0x2701, 0x2011,
-	0x0101, 0x20a9, 0x000c, 0x810b, 0x00f0, 0x2703, 0xa18c, 0xf000,
-	0x2204, 0xa084, 0x0fff, 0xa105, 0x2012, 0x007c, 0xd3fc, 0x00c0,
-	0x2721, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040,
-	0x271d, 0x2011, 0x0102, 0x0078, 0x2723, 0x2011, 0x0202, 0x0078,
-	0x2723, 0x2011, 0x0102, 0x2204, 0xa084, 0xffcf, 0xa105, 0x2012,
-	0x007c, 0x0c7e, 0xd1bc, 0x00c0, 0x273d, 0x007e, 0x2001, 0x4a04,
-	0x2004, 0xd0ec, 0x007f, 0x0040, 0x2739, 0x2061, 0x0100, 0x0078,
-	0x273f, 0x2061, 0x0200, 0x0078, 0x273f, 0x2061, 0x0100, 0xc1bc,
-	0x8103, 0x8003, 0xa080, 0x0020, 0x609a, 0x62ac, 0x63ac, 0x0c7f,
-	0x007c, 0x0c7e, 0xd1bc, 0x00c0, 0x275d, 0x007e, 0x2001, 0x4a04,
-	0x2004, 0xd0ec, 0x007f, 0x0040, 0x2759, 0x2061, 0x0100, 0x0078,
-	0x275f, 0x2061, 0x0200, 0x0078, 0x275f, 0x2061, 0x0100, 0xc1bc,
-	0x8103, 0x8003, 0xa080, 0x0022, 0x609a, 0x60a4, 0xa084, 0xffdf,
-	0x60ae, 0x0c7f, 0x007c, 0x0c7e, 0xd1bc, 0x00c0, 0x277f, 0x007e,
-	0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x277b, 0x2061,
-	0x0100, 0x0078, 0x2781, 0x2061, 0x0200, 0x0078, 0x2781, 0x2061,
-	0x0100, 0xc1bc, 0x8103, 0x8003, 0xa080, 0x0022, 0x609a, 0x60a4,
-	0xa085, 0x0020, 0x60ae, 0x0c7f, 0x007c, 0x0c7e, 0xd1bc, 0x00c0,
-	0x27a1, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040,
-	0x279d, 0x2061, 0x0100, 0x0078, 0x27a3, 0x2061, 0x0200, 0x0078,
-	0x27a3, 0x2061, 0x0100, 0xc1bc, 0x8103, 0x8003, 0xa080, 0x0020,
-	0x609a, 0x60a4, 0xa28c, 0x0020, 0x0040, 0x27b1, 0xc2ac, 0xa39d,
-	0x4000, 0xc3fc, 0xd3b4, 0x00c0, 0x27b6, 0xc3fd, 0x62ae, 0x2010,
-	0x60a4, 0x63ae, 0x2018, 0x0c7f, 0x007c, 0x2091, 0x8000, 0x0c7e,
-	0x0e7e, 0x6818, 0xa005, 0x0040, 0x281b, 0xd1fc, 0x0040, 0x27cc,
-	0x2061, 0x91d0, 0x0078, 0x27ce, 0x2061, 0x90c0, 0x1078, 0x2823,
-	0x0040, 0x2801, 0x20a9, 0x0101, 0xd1fc, 0x0040, 0x27db, 0x2061,
-	0x90d0, 0x0078, 0x27dd, 0x2061, 0x8fc0, 0x0c7e, 0x1078, 0x2823,
-	0x0040, 0x27e8, 0x0c7f, 0x8c60, 0x00f0, 0x27dd, 0x0078, 0x281b,
-	0x007f, 0xd1fc, 0x0040, 0x27f2, 0xa082, 0x90d0, 0x2071, 0x4a80,
-	0x0078, 0x27f6, 0xa082, 0x8fc0, 0x2071, 0x4a40, 0x707a, 0x7176,
-	0x2001, 0x0004, 0x7066, 0x7083, 0x000f, 0x1078, 0x25d1, 0x0078,
-	0x2817, 0xd1fc, 0x00c0, 0x2808, 0x2071, 0x4a40, 0x0078, 0x280a,
-	0x2071, 0x4a80, 0x6020, 0xc0dd, 0x6022, 0x7176, 0x2c00, 0x707e,
-	0x2001, 0x0006, 0x7066, 0x7083, 0x000f, 0x1078, 0x25d1, 0x2001,
-	0x0000, 0x0078, 0x281d, 0x2001, 0x0001, 0x2091, 0x8001, 0xa005,
-	0x0e7f, 0x0c7f, 0x007c, 0x2c04, 0xa005, 0x0040, 0x283a, 0x2060,
-	0x6010, 0xa306, 0x00c0, 0x2837, 0x600c, 0xa206, 0x00c0, 0x2837,
-	0x6014, 0xa106, 0x00c0, 0x2837, 0xa006, 0x0078, 0x283c, 0x6000,
-	0x0078, 0x2824, 0xa085, 0x0001, 0x007c, 0x0f7e, 0x0e7e, 0x017e,
-	0xd1bc, 0x00c0, 0x2855, 0x2079, 0x4a40, 0x007e, 0x2001, 0x4a04,
-	0x2004, 0xd0ec, 0x007f, 0x0040, 0x2851, 0x2071, 0x0100, 0x0078,
-	0x2859, 0x2071, 0x0200, 0x0078, 0x2859, 0x2079, 0x4a80, 0x2071,
-	0x0100, 0x7920, 0xa18c, 0x000f, 0x70ec, 0xd0c4, 0x00c0, 0x2863,
-	0x017f, 0x0078, 0x287e, 0x810b, 0x810b, 0x810b, 0x810b, 0x007f,
-	0xd0bc, 0x00c0, 0x287b, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec,
-	0x007f, 0x0040, 0x2877, 0xa18d, 0x0f00, 0x0078, 0x287d, 0xa18d,
-	0x0f00, 0x0078, 0x287d, 0xa18d, 0x0800, 0x2104, 0x0e7f, 0x0f7f,
-	0x007c, 0x0e7e, 0x2001, 0x4a01, 0x2004, 0xd0ac, 0x00c0, 0x28ea,
-	0x68e4, 0xd0ac, 0x0040, 0x28ea, 0xa084, 0x0006, 0x00c0, 0x28ea,
-	0x6014, 0xd0fc, 0x00c0, 0x2898, 0x2071, 0x4ec0, 0x0078, 0x289a,
-	0x2071, 0x4f40, 0x8007, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003,
-	0xae70, 0x7004, 0xa084, 0x000a, 0x00c0, 0x28ea, 0x7108, 0xa194,
-	0xff00, 0x0040, 0x28ea, 0xa18c, 0x00ff, 0x2001, 0x000a, 0xa106,
-	0x0040, 0x28cd, 0x2001, 0x000c, 0xa106, 0x0040, 0x28d1, 0x2001,
-	0x0012, 0xa106, 0x0040, 0x28d5, 0x2001, 0x0014, 0xa106, 0x0040,
-	0x28d9, 0x2001, 0x0019, 0xa106, 0x0040, 0x28dd, 0x2001, 0x0032,
-	0xa106, 0x0040, 0x28e1, 0x0078, 0x28e5, 0x2009, 0x000c, 0x0078,
-	0x28e7, 0x2009, 0x0012, 0x0078, 0x28e7, 0x2009, 0x0014, 0x0078,
-	0x28e7, 0x2009, 0x0019, 0x0078, 0x28e7, 0x2009, 0x0020, 0x0078,
-	0x28e7, 0x2009, 0x003f, 0x0078, 0x28e7, 0x2011, 0x0000, 0x2100,
-	0xa205, 0x700a, 0x0e7f, 0x007c, 0x0068, 0x28ec, 0x2091, 0x8000,
-	0x2071, 0x0000, 0x007e, 0x7018, 0xd084, 0x00c0, 0x28f3, 0x007f,
+	0x2091, 0x4080, 0x1078, 0x2026, 0x0068, 0x2522, 0x786c, 0xa065,
+	0x00c0, 0x2500, 0x007c, 0x1078, 0x2537, 0x00c0, 0x255a, 0x786c,
+	0xa065, 0x00c0, 0x2500, 0x0078, 0x255a, 0x1078, 0x2537, 0x00c0,
+	0x255a, 0x786c, 0xa065, 0x00c0, 0x252d, 0x0078, 0x255a, 0x6084,
+	0xa086, 0x0103, 0x00c0, 0x254b, 0x6018, 0xc0fc, 0x601a, 0xa086,
+	0x0004, 0x00c0, 0x254b, 0x7804, 0xd0a4, 0x0040, 0x254b, 0x1078,
+	0x2026, 0xa006, 0x007c, 0x1078, 0x2560, 0x00c0, 0x2552, 0xa085,
+	0x0001, 0x007c, 0x1078, 0x256f, 0x00c0, 0x2558, 0x2041, 0x0001,
+	0x7d10, 0x007c, 0x88ff, 0x0040, 0x255f, 0x2091, 0x4080, 0x007c,
+	0x7b90, 0x7994, 0x70d4, 0xa102, 0x00c0, 0x2569, 0xa385, 0x0000,
+	0x007c, 0x0048, 0x256d, 0xa302, 0x007c, 0x8002, 0x007c, 0x7810,
+	0xd0ec, 0x0040, 0x2587, 0x0e7e, 0x2091, 0x8000, 0x2071, 0x0020,
+	0x7004, 0xa005, 0x00c0, 0x2584, 0x7008, 0x0e7f, 0xa086, 0x0008,
+	0x0040, 0x2587, 0x0078, 0x25d8, 0x0e7f, 0x0078, 0x25d8, 0xa184,
+	0xff00, 0x0040, 0x2594, 0x810f, 0x810c, 0x810c, 0x8004, 0x8004,
+	0x8007, 0xa100, 0x0078, 0x2597, 0x8107, 0x8004, 0x8004, 0x7a9c,
+	0x7b98, 0x7ca4, 0x7da0, 0xa210, 0xa006, 0xa319, 0xa421, 0xa529,
+	0x2009, 0x0018, 0x6028, 0xa005, 0x0040, 0x25a8, 0x2009, 0x0040,
+	0x1078, 0x1d5b, 0x0040, 0x25ca, 0x78a8, 0x8000, 0x78aa, 0xd08c,
+	0x00c0, 0x25d8, 0x6014, 0xd0fc, 0x00c0, 0x25ba, 0x2069, 0x4d40,
+	0x0078, 0x25bc, 0x2069, 0x4d80, 0x2091, 0x8000, 0x681f, 0x0003,
+	0x78ab, 0x0000, 0x78ac, 0xa085, 0x0300, 0x78ae, 0x2091, 0x8001,
+	0x0078, 0x25d8, 0x78ab, 0x0000, 0x1078, 0x2026, 0x7990, 0x7894,
+	0x8000, 0xa10a, 0x00c8, 0x25d5, 0xa006, 0x7896, 0x70d6, 0xa006,
+	0x2071, 0x0010, 0x2091, 0x8001, 0x007c, 0x2138, 0xd7fc, 0x00c0,
+	0x25e5, 0x2009, 0x4d59, 0x0078, 0x25e7, 0x2009, 0x4d99, 0x2091,
+	0x8000, 0x200a, 0x0f7e, 0xd7fc, 0x00c0, 0x25fe, 0x2009, 0x4d40,
+	0x2001, 0x4d04, 0x2004, 0xd0ec, 0x0040, 0x25fa, 0x2079, 0x0100,
+	0x0078, 0x2602, 0x2079, 0x0200, 0x0078, 0x2602, 0x2009, 0x4d80,
+	0x2079, 0x0100, 0x2104, 0xa086, 0x0000, 0x00c0, 0x261b, 0xd7fc,
+	0x00c0, 0x260e, 0x2009, 0x4d45, 0x0078, 0x2610, 0x2009, 0x4d85,
+	0x2104, 0xa005, 0x00c0, 0x261b, 0x7830, 0xa084, 0x00c0, 0x00c0,
+	0x261b, 0x781b, 0x0045, 0x0f7f, 0x007c, 0x2009, 0x0002, 0x2069,
+	0x4d00, 0x6810, 0xd0ec, 0x00c0, 0x267e, 0x2071, 0x4d80, 0x2079,
+	0x0100, 0x2021, 0x4fbf, 0x784b, 0x000f, 0x2019, 0x43d2, 0xd184,
+	0x0040, 0x263e, 0x6810, 0xd0ec, 0x0040, 0x263a, 0x20a1, 0x012b,
+	0x0078, 0x2640, 0x20a1, 0x022b, 0x0078, 0x2640, 0x20a1, 0x012b,
+	0x2304, 0xa005, 0x0040, 0x264d, 0x789a, 0x8318, 0x23ac, 0x8318,
+	0x2398, 0x53a6, 0x3318, 0x0078, 0x2640, 0x789b, 0x0020, 0x20a9,
+	0x0010, 0x78af, 0x0000, 0x78af, 0x8020, 0x00f0, 0x2651, 0x7003,
+	0x0000, 0x017e, 0xd18c, 0x2009, 0x0000, 0x0040, 0x2660, 0xc1bd,
+	0x1078, 0x2849, 0x017f, 0x7020, 0xa084, 0x000f, 0x007e, 0x6814,
+	0xd0e4, 0x007f, 0x00c0, 0x2670, 0xa085, 0x6340, 0x0078, 0x2672,
+	0xa085, 0x62c0, 0x7806, 0x780f, 0x9200, 0x7843, 0x00d8, 0x7853,
+	0x0080, 0x780b, 0x0008, 0x7456, 0x7053, 0x0000, 0x8109, 0x0040,
+	0x2691, 0x2071, 0x4d40, 0x6810, 0xd0ec, 0x0040, 0x268b, 0x2079,
+	0x0100, 0x0078, 0x268d, 0x2079, 0x0200, 0x2021, 0x4dbf, 0x0078,
+	0x262b, 0x007c, 0x017e, 0xd1bc, 0x00c0, 0x26a6, 0x007e, 0x2001,
+	0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x26a2, 0x2011, 0x0101,
+	0x0078, 0x26a8, 0x2011, 0x0201, 0x0078, 0x26a8, 0x2011, 0x0101,
+	0xa18c, 0x000f, 0x2204, 0xa084, 0xfff0, 0xa105, 0x2012, 0x017f,
+	0x1078, 0x2849, 0x007c, 0xd3fc, 0x00c0, 0x26c6, 0x007e, 0x2001,
+	0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x26c2, 0x2011, 0x0101,
+	0x0078, 0x26c8, 0x2011, 0x0201, 0x0078, 0x26c8, 0x2011, 0x0101,
+	0x20a9, 0x0009, 0x810b, 0x00f0, 0x26ca, 0xa18c, 0x0e00, 0x2204,
+	0xa084, 0xf1ff, 0xa105, 0x2012, 0x007c, 0x2019, 0x0002, 0x2001,
+	0x4d04, 0x2004, 0xd0ec, 0x0040, 0x26e2, 0x8319, 0x2009, 0x0101,
+	0x0078, 0x26e4, 0x2009, 0x0101, 0x20a9, 0x0005, 0x8213, 0x00f0,
+	0x26e6, 0xa294, 0x00e0, 0x2104, 0xa084, 0xff1f, 0xa205, 0x200a,
+	0x8319, 0x0040, 0x26f7, 0x2009, 0x0201, 0x0078, 0x26e4, 0x007c,
+	0xd3fc, 0x00c0, 0x270b, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec,
+	0x007f, 0x0040, 0x2707, 0x2011, 0x0101, 0x0078, 0x270d, 0x2011,
+	0x0201, 0x0078, 0x270d, 0x2011, 0x0101, 0x20a9, 0x000c, 0x810b,
+	0x00f0, 0x270f, 0xa18c, 0xf000, 0x2204, 0xa084, 0x0fff, 0xa105,
+	0x2012, 0x007c, 0xd3fc, 0x00c0, 0x272d, 0x007e, 0x2001, 0x4d04,
+	0x2004, 0xd0ec, 0x007f, 0x0040, 0x2729, 0x2011, 0x0102, 0x0078,
+	0x272f, 0x2011, 0x0202, 0x0078, 0x272f, 0x2011, 0x0102, 0x2204,
+	0xa084, 0xffcf, 0xa105, 0x2012, 0x007c, 0x0c7e, 0xd1bc, 0x00c0,
+	0x2749, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040,
+	0x2745, 0x2061, 0x0100, 0x0078, 0x274b, 0x2061, 0x0200, 0x0078,
+	0x274b, 0x2061, 0x0100, 0xc1bc, 0x8103, 0x8003, 0xa080, 0x0020,
+	0x609a, 0x62ac, 0x63ac, 0x0c7f, 0x007c, 0x0c7e, 0xd1bc, 0x00c0,
+	0x2769, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040,
+	0x2765, 0x2061, 0x0100, 0x0078, 0x276b, 0x2061, 0x0200, 0x0078,
+	0x276b, 0x2061, 0x0100, 0xc1bc, 0x8103, 0x8003, 0xa080, 0x0022,
+	0x609a, 0x60a4, 0xa084, 0xffdf, 0x60ae, 0x0c7f, 0x007c, 0x0c7e,
+	0xd1bc, 0x00c0, 0x278b, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec,
+	0x007f, 0x0040, 0x2787, 0x2061, 0x0100, 0x0078, 0x278d, 0x2061,
+	0x0200, 0x0078, 0x278d, 0x2061, 0x0100, 0xc1bc, 0x8103, 0x8003,
+	0xa080, 0x0022, 0x609a, 0x60a4, 0xa085, 0x0020, 0x60ae, 0x0c7f,
+	0x007c, 0x0c7e, 0xd1bc, 0x00c0, 0x27ad, 0x007e, 0x2001, 0x4d04,
+	0x2004, 0xd0ec, 0x007f, 0x0040, 0x27a9, 0x2061, 0x0100, 0x0078,
+	0x27af, 0x2061, 0x0200, 0x0078, 0x27af, 0x2061, 0x0100, 0xc1bc,
+	0x8103, 0x8003, 0xa080, 0x0020, 0x609a, 0x60a4, 0xa28c, 0x0020,
+	0x0040, 0x27bd, 0xc2ac, 0xa39d, 0x4000, 0xc3fc, 0xd3b4, 0x00c0,
+	0x27c2, 0xc3fd, 0x62ae, 0x2010, 0x60a4, 0x63ae, 0x2018, 0x0c7f,
+	0x007c, 0x2091, 0x8000, 0x0c7e, 0x0e7e, 0x6818, 0xa005, 0x0040,
+	0x2827, 0xd1fc, 0x0040, 0x27d8, 0x2061, 0x94d0, 0x0078, 0x27da,
+	0x2061, 0x93c0, 0x1078, 0x282f, 0x0040, 0x280d, 0x20a9, 0x0101,
+	0xd1fc, 0x0040, 0x27e7, 0x2061, 0x93d0, 0x0078, 0x27e9, 0x2061,
+	0x92c0, 0x0c7e, 0x1078, 0x282f, 0x0040, 0x27f4, 0x0c7f, 0x8c60,
+	0x00f0, 0x27e9, 0x0078, 0x2827, 0x007f, 0xd1fc, 0x0040, 0x27fe,
+	0xa082, 0x93d0, 0x2071, 0x4d80, 0x0078, 0x2802, 0xa082, 0x92c0,
+	0x2071, 0x4d40, 0x707a, 0x7176, 0x2001, 0x0004, 0x7066, 0x7083,
+	0x000f, 0x1078, 0x25dd, 0x0078, 0x2823, 0xd1fc, 0x00c0, 0x2814,
+	0x2071, 0x4d40, 0x0078, 0x2816, 0x2071, 0x4d80, 0x6020, 0xc0dd,
+	0x6022, 0x7176, 0x2c00, 0x707e, 0x2001, 0x0006, 0x7066, 0x7083,
+	0x000f, 0x1078, 0x25dd, 0x2001, 0x0000, 0x0078, 0x2829, 0x2001,
+	0x0001, 0x2091, 0x8001, 0xa005, 0x0e7f, 0x0c7f, 0x007c, 0x2c04,
+	0xa005, 0x0040, 0x2846, 0x2060, 0x6010, 0xa306, 0x00c0, 0x2843,
+	0x600c, 0xa206, 0x00c0, 0x2843, 0x6014, 0xa106, 0x00c0, 0x2843,
+	0xa006, 0x0078, 0x2848, 0x6000, 0x0078, 0x2830, 0xa085, 0x0001,
+	0x007c, 0x0f7e, 0x0e7e, 0x017e, 0xd1bc, 0x00c0, 0x2861, 0x2079,
+	0x4d40, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040,
+	0x285d, 0x2071, 0x0100, 0x0078, 0x2865, 0x2071, 0x0200, 0x0078,
+	0x2865, 0x2079, 0x4d80, 0x2071, 0x0100, 0x7920, 0xa18c, 0x000f,
+	0x70ec, 0xd0c4, 0x00c0, 0x286f, 0x017f, 0x0078, 0x288a, 0x810b,
+	0x810b, 0x810b, 0x810b, 0x007f, 0xd0bc, 0x00c0, 0x2887, 0x007e,
+	0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x2883, 0xa18d,
+	0x0f00, 0x0078, 0x2889, 0xa18d, 0x0f00, 0x0078, 0x2889, 0xa18d,
+	0x0800, 0x2104, 0x0e7f, 0x0f7f, 0x007c, 0x0e7e, 0x2001, 0x4d01,
+	0x2004, 0xd0ac, 0x00c0, 0x290a, 0x68e4, 0xd0ac, 0x0040, 0x290a,
+	0xa084, 0x0006, 0x00c0, 0x290a, 0x6014, 0xd0fc, 0x00c0, 0x28a4,
+	0x2071, 0x51c0, 0x0078, 0x28a6, 0x2071, 0x5240, 0x8007, 0xa084,
+	0x000f, 0x8003, 0x8003, 0x8003, 0xae70, 0x7004, 0xa084, 0x000a,
+	0x00c0, 0x290a, 0x7108, 0xa194, 0xff00, 0x0040, 0x290a, 0xa18c,
+	0x00ff, 0x2001, 0x000a, 0xa106, 0x0040, 0x28d9, 0x2001, 0x000c,
+	0xa106, 0x0040, 0x28dd, 0x2001, 0x0012, 0xa106, 0x0040, 0x28e1,
+	0x2001, 0x0014, 0xa106, 0x0040, 0x28e5, 0x2001, 0x0019, 0xa106,
+	0x0040, 0x28e9, 0x2001, 0x0032, 0xa106, 0x0040, 0x28ed, 0x0078,
+	0x28f1, 0x2009, 0x000c, 0x0078, 0x28f3, 0x2009, 0x0012, 0x0078,
+	0x28f3, 0x2009, 0x0014, 0x0078, 0x28f3, 0x2009, 0x0019, 0x0078,
+	0x28f3, 0x2009, 0x0020, 0x0078, 0x28f3, 0x2009, 0x003f, 0x0078,
+	0x28f3, 0x2011, 0x0000, 0x2100, 0xa205, 0x700a, 0x2071, 0x4d00,
+	0x7004, 0xd0bc, 0x0040, 0x290a, 0x6014, 0xd0fc, 0x00c0, 0x2905,
+	0x70ea, 0x2071, 0x4d40, 0x0078, 0x2908, 0x70ee, 0x2071, 0x4d80,
+	0x701f, 0x800f, 0x0e7f, 0x007c, 0x0068, 0x290c, 0x2091, 0x8000,
+	0x2071, 0x0000, 0x007e, 0x7018, 0xd084, 0x00c0, 0x2913, 0x007f,
 	0x2071, 0x0010, 0x70ca, 0x007f, 0x70c6, 0x70c3, 0x8002, 0x70db,
-	0x0809, 0x70df, 0x0000, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091,
-	0x4080, 0x0078, 0x2909, 0x7f3c, 0x7e58, 0x7c30, 0x7d38, 0x78a0,
+	0x080d, 0x70df, 0x0008, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091,
+	0x4080, 0x0078, 0x2929, 0x7f3c, 0x7e58, 0x7c30, 0x7d38, 0x78a0,
 	0x708e, 0x7592, 0x7496, 0x769a, 0x779e, 0xa594, 0x003f, 0xd4f4,
-	0x0040, 0x2920, 0xa784, 0x007d, 0x00c0, 0x417b, 0x1078, 0x28ec,
-	0xa49c, 0x000f, 0xa382, 0x0004, 0x0050, 0x292b, 0xa3a6, 0x0007,
-	0x00c0, 0x28ec, 0x2418, 0x8507, 0xa084, 0x000f, 0x0079, 0x2930,
-	0x2f45, 0x3035, 0x3060, 0x32c1, 0x363b, 0x36a1, 0x3741, 0x37bd,
-	0x38a1, 0x398a, 0x2943, 0x2940, 0x2d2a, 0x2e43, 0x360e, 0x2940,
-	0x1078, 0x28ec, 0x007c, 0xa006, 0x0078, 0x294d, 0x7808, 0xc08d,
+	0x0040, 0x2940, 0xa784, 0x007d, 0x00c0, 0x4348, 0x1078, 0x290c,
+	0xa49c, 0x000f, 0xa382, 0x0004, 0x0050, 0x294b, 0xa3a6, 0x0007,
+	0x00c0, 0x290c, 0x2418, 0x8507, 0xa084, 0x000f, 0x0079, 0x2950,
+	0x2fc6, 0x30b5, 0x30e0, 0x3341, 0x372a, 0x379f, 0x3853, 0x38cf,
+	0x39bd, 0x3aac, 0x2963, 0x2960, 0x2d99, 0x2eba, 0x36fb, 0x2960,
+	0x1078, 0x290c, 0x007c, 0xa006, 0x0078, 0x296d, 0x7808, 0xc08d,
 	0x780a, 0xa006, 0x7002, 0x704e, 0x7046, 0x70d2, 0x7060, 0xa005,
-	0x00c0, 0x2a64, 0x7064, 0xa084, 0x0007, 0x0079, 0x2957, 0x295f,
-	0x29cf, 0x29d8, 0x29e3, 0x29ee, 0x2a4a, 0x29f9, 0x29cf, 0x7830,
-	0xd0bc, 0x00c0, 0x2942, 0x71d4, 0xd1b4, 0x00c0, 0x29ac, 0x70a4,
-	0xa086, 0x0001, 0x0040, 0x2942, 0x70b4, 0xa06d, 0x6800, 0xa065,
-	0xa055, 0x789b, 0x0010, 0x6b0c, 0x7baa, 0x6808, 0xa045, 0x6d10,
-	0x6804, 0xa06d, 0xa05d, 0xa886, 0x0001, 0x0040, 0x2982, 0x69bc,
-	0x7daa, 0x79aa, 0x68c0, 0xa04d, 0x6e1c, 0x2001, 0x0010, 0x0078,
-	0x2bbd, 0x7060, 0xa005, 0x00c0, 0x2942, 0x0c7e, 0x0d7e, 0x70b4,
+	0x00c0, 0x2ad3, 0x7064, 0xa084, 0x0007, 0x0079, 0x2977, 0x297f,
+	0x29f2, 0x29fb, 0x2a06, 0x2a11, 0x2ab9, 0x2a1c, 0x29f2, 0x7830,
+	0xd0bc, 0x00c0, 0x2962, 0x71d4, 0xd1bc, 0x00c0, 0x2962, 0xd1b4,
+	0x00c0, 0x29cf, 0x70a4, 0xa086, 0x0001, 0x0040, 0x2962, 0x70b4,
 	0xa06d, 0x6800, 0xa065, 0xa055, 0x789b, 0x0010, 0x6b0c, 0x7baa,
 	0x6808, 0xa045, 0x6d10, 0x6804, 0xa06d, 0xa05d, 0xa886, 0x0001,
 	0x0040, 0x29a5, 0x69bc, 0x7daa, 0x79aa, 0x68c0, 0xa04d, 0x6e1c,
-	0x2001, 0x0020, 0x0078, 0x2bbd, 0x1078, 0x411c, 0x00c0, 0x2942,
-	0x781b, 0x005b, 0x70bc, 0xa06d, 0x68b4, 0x785a, 0x6894, 0x78d6,
-	0x78de, 0x6898, 0x78d2, 0x78da, 0x7808, 0xc08d, 0x780a, 0x68bc,
-	0x7042, 0xc1b4, 0x71d6, 0x70b8, 0xa065, 0x68c0, 0x705a, 0x7003,
-	0x0002, 0x2d00, 0x704e, 0xad80, 0x0009, 0x7046, 0x007c, 0x1078,
-	0x411c, 0x00c0, 0x29d7, 0x781b, 0x0047, 0x7003, 0x0004, 0x007c,
-	0x1078, 0x411c, 0x00c0, 0x29e2, 0x2011, 0x000c, 0x1078, 0x2a09,
-	0x7003, 0x0004, 0x007c, 0x1078, 0x411c, 0x00c0, 0x29ed, 0x2011,
-	0x0006, 0x1078, 0x2a09, 0x7003, 0x0004, 0x007c, 0x1078, 0x411c,
-	0x00c0, 0x29f8, 0x2011, 0x000d, 0x1078, 0x2a09, 0x7003, 0x0004,
-	0x007c, 0x1078, 0x411c, 0x00c0, 0x2a08, 0x2011, 0x0006, 0x1078,
-	0x2a09, 0x707c, 0x707f, 0x0000, 0x2068, 0x704e, 0x7003, 0x0001,
-	0x007c, 0x7174, 0xc1fc, 0x8107, 0x7882, 0x789b, 0x0010, 0xa286,
-	0x000c, 0x00c0, 0x2a18, 0x7aaa, 0x2001, 0x0001, 0x0078, 0x2a2d,
-	0xa18c, 0x001f, 0xa18d, 0x00c0, 0x79aa, 0xa286, 0x000d, 0x0040,
-	0x2a26, 0x7aaa, 0x2001, 0x0002, 0x0078, 0x2a2d, 0x78ab, 0x0020,
-	0x7178, 0x79aa, 0x7aaa, 0x2001, 0x0004, 0x789b, 0x0060, 0x78aa,
-	0x785b, 0x0004, 0x781b, 0x0108, 0x1078, 0x4131, 0x7083, 0x000f,
-	0x70d4, 0xd0b4, 0x0040, 0x2a49, 0xc0b4, 0x70d6, 0x0c7e, 0x70b8,
-	0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a,
-	0x0c7f, 0x007c, 0x1078, 0x411c, 0x00c0, 0x2942, 0x707c, 0x2068,
-	0x7774, 0x1078, 0x3fe1, 0x2c50, 0x1078, 0x41f0, 0x789b, 0x0010,
-	0x6814, 0xa084, 0x001f, 0xc0bd, 0x78aa, 0x6e1c, 0x2041, 0x0001,
-	0x2001, 0x0004, 0x0078, 0x2bc3, 0x1078, 0x411c, 0x00c0, 0x2942,
-	0x789b, 0x0010, 0x7060, 0x2068, 0x6f14, 0x70d4, 0xd0b4, 0x0040,
-	0x2a7e, 0xc0b4, 0x70d6, 0x0c7e, 0x70b8, 0xa065, 0x6008, 0xa084,
-	0xfbef, 0x600a, 0x6018, 0x8001, 0x601a, 0x0c7f, 0x1078, 0x3fe1,
-	0x2c50, 0x1078, 0x41f0, 0x6824, 0xa005, 0x0040, 0x2a8f, 0xa082,
-	0x0006, 0x0048, 0x2a8d, 0x0078, 0x2a8f, 0x6827, 0x0005, 0x6814,
-	0xa084, 0x001f, 0xc0bd, 0x78aa, 0x2031, 0x0020, 0x2041, 0x0001,
-	0x2001, 0x0003, 0x0078, 0x2bc3, 0xc28d, 0x72d6, 0x72c0, 0xa200,
-	0xa015, 0x7154, 0x8108, 0xa12a, 0x0048, 0x2aa7, 0x71c0, 0x2164,
-	0x6504, 0x85ff, 0x00c0, 0x2abe, 0x7156, 0x8421, 0x00c0, 0x2aa2,
-	0x70d4, 0xd08c, 0x0040, 0x2aba, 0x70d0, 0xa005, 0x00c0, 0x2aba,
-	0x70d3, 0x000a, 0x007c, 0x2200, 0x0078, 0x2aac, 0x70d4, 0xc08c,
-	0x70d6, 0x70d3, 0x0000, 0x603c, 0xa005, 0x00c0, 0x2abb, 0x6708,
-	0xa784, 0x073f, 0x0040, 0x2aed, 0xd7d4, 0x00c0, 0x2abb, 0xa784,
-	0x0021, 0x00c0, 0x2abb, 0xa784, 0x0002, 0x0040, 0x2ade, 0xa784,
-	0x0004, 0x0040, 0x2abb, 0xa7bc, 0xfffb, 0x670a, 0xa784, 0x0218,
-	0x00c0, 0x2abb, 0xa784, 0x0100, 0x0040, 0x2aed, 0x6018, 0xa005,
-	0x00c0, 0x2abb, 0xa7bc, 0xfeff, 0x670a, 0x2568, 0x6823, 0x0000,
-	0x6e1c, 0xa684, 0x000e, 0x6318, 0x0040, 0x2afe, 0x601c, 0xa302,
-	0x0048, 0x2b01, 0x0040, 0x2b01, 0x0078, 0x2abb, 0x83ff, 0x00c0,
-	0x2abb, 0x2d58, 0x2c50, 0x7156, 0xd7bc, 0x00c0, 0x2b09, 0x7028,
-	0x6022, 0xc7bc, 0x670a, 0x68c0, 0xa065, 0xa04d, 0x6100, 0x2a60,
-	0x2041, 0x0001, 0x6b14, 0xa39c, 0x001f, 0xa39d, 0x00c0, 0xd1fc,
-	0x0040, 0x2b1d, 0xd684, 0x0040, 0x2b1f, 0xa39c, 0xffbf, 0xd6a4,
-	0x0040, 0x2b24, 0xa39d, 0x0020, 0xa684, 0x000e, 0x00c0, 0x2b6f,
-	0xc7a5, 0x670a, 0x2c00, 0x68c6, 0x77a4, 0xa786, 0x0001, 0x00c0,
-	0x2b43, 0x70d4, 0xd0b4, 0x00c0, 0x2b43, 0x7000, 0xa082, 0x0002,
-	0x00c8, 0x2b43, 0x7830, 0xd0bc, 0x00c0, 0x2b43, 0x789b, 0x0010,
-	0x7baa, 0x0078, 0x2bbb, 0x8739, 0x77a6, 0x2750, 0x77b0, 0xa7b0,
-	0x0005, 0x70ac, 0xa606, 0x00c0, 0x2b4e, 0x76a8, 0x76b2, 0x2c3a,
-	0x8738, 0x2d3a, 0x8738, 0x283a, 0x8738, 0x233a, 0x8738, 0x253a,
-	0x7830, 0xd0bc, 0x0040, 0x2b66, 0x2091, 0x8000, 0x2091, 0x303d,
-	0x70d4, 0xa084, 0x303d, 0x2091, 0x8000, 0x2090, 0xaad5, 0x0000,
-	0x0040, 0x2b6e, 0x8421, 0x2200, 0x00c0, 0x2aa1, 0x007c, 0xd1dc,
-	0x0040, 0x3be5, 0x2029, 0x0020, 0xd69c, 0x00c0, 0x2b7c, 0x8528,
-	0xd68c, 0x00c0, 0x2b7c, 0x8528, 0x8840, 0x6f14, 0x610c, 0x8108,
-	0xa18c, 0x00ff, 0x70cc, 0xa160, 0x2c64, 0x8cff, 0x0040, 0x2b9b,
-	0x6014, 0xa706, 0x00c0, 0x2b84, 0x60b8, 0x8001, 0x60ba, 0x00c0,
-	0x2b7f, 0x2a60, 0x6008, 0xa085, 0x0100, 0x600a, 0x2200, 0x8421,
-	0x00c0, 0x2aa1, 0x007c, 0x2a60, 0x610e, 0x69be, 0x2c00, 0x68c6,
-	0x8840, 0x6008, 0xc0d5, 0x600a, 0x77a4, 0xa786, 0x0001, 0x00c0,
-	0x2b43, 0x70d4, 0xd0b4, 0x00c0, 0x2b43, 0x7000, 0xa082, 0x0002,
-	0x00c8, 0x2b43, 0x7830, 0xd0bc, 0x00c0, 0x2b43, 0x789b, 0x0010,
-	0x7baa, 0x7daa, 0x79aa, 0x2001, 0x0002, 0x007e, 0x6018, 0x8000,
-	0x601a, 0x0078, 0x2bc4, 0x007e, 0x2960, 0x6104, 0x2a60, 0xa184,
-	0x0018, 0x0040, 0x2be0, 0xa184, 0x0010, 0x0040, 0x2bd3, 0x1078,
-	0x3df6, 0x00c0, 0x2c05, 0xa184, 0x0008, 0x0040, 0x2be0, 0x69a0,
-	0xa184, 0x0600, 0x00c0, 0x2be0, 0x1078, 0x3cda, 0x0078, 0x2c05,
-	0x69a0, 0xa184, 0x1e00, 0x0040, 0x2c10, 0xa184, 0x0800, 0x0040,
-	0x2bf9, 0x0c7e, 0x2960, 0x6000, 0xa085, 0x2000, 0x6002, 0x6104,
-	0xa18d, 0x0010, 0x6106, 0x0c7f, 0x1078, 0x3df6, 0x00c0, 0x2c05,
-	0x69a0, 0xa184, 0x0200, 0x0040, 0x2c01, 0x1078, 0x3d3a, 0x0078,
-	0x2c05, 0xa184, 0x0400, 0x00c0, 0x2bdc, 0x69a0, 0xa184, 0x1000,
-	0x0040, 0x2c10, 0x6914, 0xa18c, 0xff00, 0x810f, 0x1078, 0x2749,
-	0x027f, 0xa68c, 0x00e0, 0xa684, 0x0060, 0x0040, 0x2c1d, 0xa086,
-	0x0060, 0x00c0, 0x2c1d, 0xa18d, 0x4000, 0xa18d, 0x0104, 0x69b6,
-	0x789b, 0x0060, 0x2800, 0x78aa, 0x6818, 0xc0fd, 0x681a, 0xd6bc,
-	0x0040, 0x2c38, 0xc0fc, 0x7087, 0x0000, 0xa08a, 0x000d, 0x0050,
-	0x2c36, 0xa08a, 0x000c, 0x7186, 0x2001, 0x000c, 0x800c, 0x718a,
-	0x78aa, 0x3518, 0x3340, 0x3428, 0x8000, 0x80ac, 0xaf80, 0x002b,
-	0x20a0, 0x789b, 0x0000, 0xad80, 0x000b, 0x2098, 0x53a6, 0x23a8,
-	0x2898, 0x25a0, 0xa286, 0x0020, 0x00c0, 0x2c70, 0x70d4, 0xc0b5,
-	0x70d6, 0x2c00, 0x70ba, 0x2d00, 0x70be, 0x6814, 0xc0fc, 0x8007,
-	0x7882, 0xa286, 0x0002, 0x0040, 0x2ca6, 0x70a4, 0x8000, 0x70a6,
-	0x74b4, 0xa498, 0x0005, 0x70ac, 0xa306, 0x00c0, 0x2c68, 0x73a8,
-	0x73b6, 0xa286, 0x0010, 0x0040, 0x2942, 0x0d7f, 0x0c7f, 0x007c,
-	0x7000, 0xa005, 0x00c0, 0x2c4e, 0xa286, 0x0002, 0x00c0, 0x2cc0,
-	0x1078, 0x411c, 0x00c0, 0x2c4e, 0x6814, 0xc0fc, 0x8007, 0x7882,
-	0x2091, 0x8000, 0x781b, 0x005b, 0x68b4, 0x785a, 0x6894, 0x78d6,
-	0x78de, 0x6898, 0x78d2, 0x78da, 0x2091, 0x8001, 0x7808, 0xc08d,
-	0x780a, 0x127e, 0x0d7e, 0x0c7e, 0x70d4, 0xa084, 0x2700, 0x2090,
-	0x0c7f, 0x0d7f, 0x127f, 0x2900, 0x705a, 0x68bc, 0x7042, 0x7003,
-	0x0002, 0x2d00, 0x704e, 0xad80, 0x0009, 0x7046, 0x7830, 0xd0bc,
-	0x0040, 0x2cb2, 0x2091, 0x303d, 0x70d4, 0xa084, 0x303d, 0x2091,
-	0x8000, 0x2090, 0x70a4, 0xa005, 0x00c0, 0x2cb7, 0x007c, 0x8421,
-	0x0040, 0x2cb6, 0x7250, 0x70c0, 0xa200, 0xa015, 0x0078, 0x2aa1,
-	0xa286, 0x0010, 0x00c0, 0x2cf1, 0x1078, 0x411c, 0x00c0, 0x2c4e,
-	0x6814, 0xc0fc, 0x8007, 0x7882, 0x781b, 0x005b, 0x68b4, 0x785a,
-	0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0x7808, 0xc08d,
-	0x780a, 0x70a4, 0x8000, 0x70a6, 0x74b4, 0xa490, 0x0005, 0x70ac,
-	0xa206, 0x00c0, 0x2ce4, 0x72a8, 0x72b6, 0x2900, 0x705a, 0x68bc,
-	0x7042, 0x7003, 0x0002, 0x2d00, 0x704e, 0xad80, 0x0009, 0x7046,
-	0x007c, 0x6bb4, 0xa39d, 0x2000, 0x7b5a, 0x6814, 0xc0fc, 0x8007,
-	0x7882, 0x6b94, 0x7bd6, 0x7bde, 0x6e98, 0x7ed2, 0x7eda, 0x781b,
-	0x005b, 0x2900, 0x705a, 0x7202, 0x7808, 0xc08d, 0x780a, 0x2300,
-	0xa605, 0x0040, 0x2d1c, 0x70d4, 0xa084, 0x2700, 0xa086, 0x2300,
-	0x00c0, 0x2d16, 0x2009, 0x0000, 0x0078, 0x2d18, 0x2009, 0x0001,
-	0xa284, 0x000f, 0x1079, 0x2d20, 0xad80, 0x0009, 0x7046, 0x007c,
-	0x2d28, 0x45f7, 0x45f7, 0x45e4, 0x45f7, 0x2d28, 0x2d28, 0x2d28,
-	0x1078, 0x28ec, 0x7808, 0xa084, 0xfffd, 0x780a, 0x0f7e, 0x2079,
-	0x4a00, 0x78ac, 0x0f7f, 0xd084, 0x0040, 0x2d4e, 0x7064, 0xa086,
-	0x0001, 0x00c0, 0x2d3e, 0x7066, 0x0078, 0x2e27, 0x7064, 0xa086,
-	0x0005, 0x00c0, 0x2d4c, 0x707c, 0x2068, 0x681b, 0x0004, 0x6817,
-	0x0000, 0x6820, 0xc09d, 0x6822, 0x7067, 0x0000, 0x70a7, 0x0000,
-	0x70a8, 0x70b2, 0x70b6, 0x70d4, 0xd0b4, 0x0040, 0x2d64, 0xc0b4,
+	0x2001, 0x0010, 0x0078, 0x2c2c, 0x7060, 0xa005, 0x00c0, 0x2962,
+	0x0c7e, 0x0d7e, 0x70b4, 0xa06d, 0x6800, 0xa065, 0xa055, 0x789b,
+	0x0010, 0x6b0c, 0x7baa, 0x6808, 0xa045, 0x6d10, 0x6804, 0xa06d,
+	0xa05d, 0xa886, 0x0001, 0x0040, 0x29c8, 0x69bc, 0x7daa, 0x79aa,
+	0x68c0, 0xa04d, 0x6e1c, 0x2001, 0x0020, 0x0078, 0x2c2c, 0x1078,
+	0x42e9, 0x00c0, 0x2962, 0x781b, 0x005b, 0x70bc, 0xa06d, 0x68b4,
+	0x785a, 0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0x7808,
+	0xc08d, 0x780a, 0x68bc, 0x7042, 0xc1b4, 0x71d6, 0x70b8, 0xa065,
+	0x68c0, 0x705a, 0x7003, 0x0002, 0x2d00, 0x704e, 0xad80, 0x0009,
+	0x7046, 0x007c, 0x1078, 0x42e9, 0x00c0, 0x29fa, 0x781b, 0x0047,
+	0x7003, 0x0004, 0x007c, 0x1078, 0x42e9, 0x00c0, 0x2a05, 0x2011,
+	0x000c, 0x1078, 0x2a2c, 0x7003, 0x0004, 0x007c, 0x1078, 0x42e9,
+	0x00c0, 0x2a10, 0x2011, 0x0006, 0x1078, 0x2a2c, 0x7003, 0x0004,
+	0x007c, 0x1078, 0x42e9, 0x00c0, 0x2a1b, 0x2011, 0x000d, 0x1078,
+	0x2a2c, 0x7003, 0x0004, 0x007c, 0x1078, 0x42e9, 0x00c0, 0x2a2b,
+	0x2011, 0x0006, 0x1078, 0x2a2c, 0x707c, 0x707f, 0x0000, 0x2068,
+	0x704e, 0x7003, 0x0001, 0x007c, 0x7174, 0xc1fc, 0x8107, 0x7882,
+	0x789b, 0x0010, 0xa286, 0x000c, 0x00c0, 0x2a3b, 0x7aaa, 0x2001,
+	0x0001, 0x0078, 0x2a50, 0xa18c, 0x001f, 0xa18d, 0x00c0, 0x79aa,
+	0xa286, 0x000d, 0x0040, 0x2a49, 0x7aaa, 0x2001, 0x0002, 0x0078,
+	0x2a50, 0x78ab, 0x0020, 0x7178, 0x79aa, 0x7aaa, 0x2001, 0x0004,
+	0x789b, 0x0060, 0x78aa, 0x785b, 0x0004, 0x781b, 0x0110, 0x1078,
+	0x42fe, 0x7083, 0x000f, 0x70d4, 0xd0b4, 0x0040, 0x2a6c, 0xc0b4,
 	0x70d6, 0x0c7e, 0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef, 0x600a,
-	0x6018, 0x8001, 0x601a, 0x0c7f, 0x157e, 0x2011, 0x0004, 0x7164,
-	0xa186, 0x0001, 0x0040, 0x2d7d, 0xa186, 0x0007, 0x00c0, 0x2d74,
-	0x701f, 0x0005, 0x0078, 0x2d7d, 0x701f, 0x0001, 0x7067, 0x0000,
-	0x70d4, 0xc0dd, 0x70d6, 0x0078, 0x2d7f, 0x7067, 0x0000, 0x2001,
-	0x4a0a, 0x2004, 0xa084, 0x00ff, 0xa086, 0x0018, 0x0040, 0x2d8f,
-	0x7018, 0x7016, 0xa005, 0x00c0, 0x2d8f, 0x70a7, 0x0001, 0x1078,
-	0x4326, 0x20a9, 0x0010, 0x2039, 0x0000, 0x1078, 0x3edb, 0xa7b8,
-	0x0100, 0x00f0, 0x2d95, 0x7000, 0x0079, 0x2d9e, 0x2dcd, 0x2db3,
-	0x2db3, 0x2da8, 0x2dcd, 0x2dcd, 0x2dcd, 0x2da6, 0x1078, 0x28ec,
-	0x7060, 0xa005, 0x0040, 0x2dcd, 0xad06, 0x00c0, 0x2db3, 0x6800,
-	0x7062, 0x0078, 0x2dc5, 0x6820, 0xd084, 0x00c0, 0x2dc1, 0x6f14,
-	0x1078, 0x3fe1, 0x6008, 0xc0d4, 0x600a, 0x1078, 0x3bb5, 0x0078,
-	0x2dc5, 0x705c, 0x2060, 0x6800, 0x6002, 0x6a1a, 0x6817, 0x0000,
-	0x6820, 0xc09d, 0x6822, 0x1078, 0x202a, 0xb284, 0x0400, 0x0040,
-	0x2dd5, 0x2021, 0x91d0, 0x0078, 0x2dd7, 0x2021, 0x90c0, 0x1078,
-	0x2e2c, 0xb284, 0x0400, 0x0040, 0x2de1, 0x2021, 0x4a98, 0x0078,
-	0x2de3, 0x2021, 0x4a58, 0x1078, 0x2e2c, 0x20a9, 0x0101, 0xb284,
-	0x0400, 0x0040, 0x2def, 0x2021, 0x90d0, 0x0078, 0x2df1, 0x2021,
-	0x8fc0, 0x1078, 0x2e2c, 0x8420, 0x00f0, 0x2df1, 0xb284, 0x0300,
-	0x0040, 0x2dfe, 0x2061, 0x4fc0, 0x0078, 0x2e00, 0x2061, 0x6fc0,
-	0x2021, 0x0002, 0x20a9, 0x0100, 0x6110, 0x81ff, 0x0040, 0x2e1d,
-	0x6018, 0x017e, 0x007e, 0x2011, 0x4a02, 0x220c, 0xa102, 0x2012,
-	0x007f, 0x017f, 0xa102, 0x0050, 0x2e1d, 0x6012, 0x00c0, 0x2e1d,
-	0x2011, 0x4a04, 0x2204, 0xc0a5, 0x2012, 0x601b, 0x0000, 0xace0,
-	0x0010, 0x00f0, 0x2e04, 0x8421, 0x00c0, 0x2e02, 0x157f, 0x7003,
-	0x0000, 0x704f, 0x0000, 0x007c, 0x047e, 0x2404, 0xa005, 0x0040,
-	0x2e3f, 0x2068, 0x6800, 0x007e, 0x6a1a, 0x6817, 0x0000, 0x6820,
-	0xc09d, 0x6822, 0x1078, 0x202a, 0x007f, 0x0078, 0x2e2e, 0x047f,
-	0x2023, 0x0000, 0x007c, 0xa282, 0x0003, 0x0050, 0x2e49, 0x1078,
-	0x28ec, 0x2300, 0x0079, 0x2e4c, 0x2e4f, 0x2eda, 0x2ef7, 0xa282,
-	0x0002, 0x0040, 0x2e55, 0x1078, 0x28ec, 0x7064, 0x7067, 0x0000,
-	0x7083, 0x0000, 0x0079, 0x2e5c, 0x2e64, 0x2e64, 0x2e66, 0x2ea6,
-	0x3bf1, 0x2e64, 0x2ea6, 0x2e64, 0x1078, 0x28ec, 0x7774, 0x1078,
-	0x3edb, 0x7774, 0xa7bc, 0x8f00, 0x1078, 0x3fe1, 0x6018, 0xa005,
-	0x0040, 0x2e9d, 0xd7fc, 0x00c0, 0x2e79, 0x2021, 0x90c0, 0x0078,
-	0x2e7b, 0x2021, 0x91d0, 0x2009, 0x0005, 0x2011, 0x0010, 0x1078,
-	0x2f12, 0x0040, 0x2e9d, 0x157e, 0x20a9, 0x0101, 0xd7fc, 0x00c0,
-	0x2e8d, 0x2021, 0x8fc0, 0x0078, 0x2e8f, 0x2021, 0x90d0, 0x047e,
-	0x2009, 0x0005, 0x2011, 0x0010, 0x1078, 0x2f12, 0x047f, 0x0040,
-	0x2e9c, 0x8420, 0x00f0, 0x2e8f, 0x157f, 0x8738, 0xa784, 0x001f,
-	0x00c0, 0x2e6c, 0x0078, 0x2946, 0x0078, 0x2946, 0x7774, 0x1078,
-	0x3fe1, 0x6018, 0xa005, 0x0040, 0x2ed8, 0xd7fc, 0x00c0, 0x2eb4,
-	0x2021, 0x90c0, 0x0078, 0x2eb6, 0x2021, 0x91d0, 0x2009, 0x0005,
-	0x2011, 0x0020, 0x1078, 0x2f12, 0x0040, 0x2ed8, 0x157e, 0x20a9,
-	0x0101, 0xd7fc, 0x00c0, 0x2ec8, 0x2021, 0x8fc0, 0x0078, 0x2eca,
-	0x2021, 0x90d0, 0x047e, 0x2009, 0x0005, 0x2011, 0x0020, 0x1078,
-	0x2f12, 0x047f, 0x0040, 0x2ed7, 0x8420, 0x00f0, 0x2eca, 0x157f,
-	0x0078, 0x2946, 0x2200, 0x0079, 0x2edd, 0x2ee0, 0x2ee2, 0x2ee2,
-	0x1078, 0x28ec, 0x2009, 0x0012, 0x7064, 0xa086, 0x0002, 0x0040,
-	0x2eeb, 0x2009, 0x000e, 0x6818, 0xd0fc, 0x0040, 0x2ef0, 0x691a,
-	0x7067, 0x0000, 0x70d4, 0xc0dd, 0x70d6, 0x0078, 0x40c9, 0x2200,
-	0x0079, 0x2efa, 0x2eff, 0x2ee2, 0x2efd, 0x1078, 0x28ec, 0x1078,
-	0x4326, 0x7000, 0xa086, 0x0002, 0x00c0, 0x3b7a, 0x1078, 0x3bd2,
-	0x6008, 0xa084, 0xfbef, 0x600a, 0x1078, 0x3b6b, 0x0040, 0x3b7a,
-	0x0078, 0x2946, 0x2404, 0xa005, 0x0040, 0x2f41, 0x2068, 0x2d04,
-	0x007e, 0x6814, 0xa706, 0x0040, 0x2f21, 0x2d20, 0x007f, 0x0078,
-	0x2f13, 0x007f, 0x2022, 0x691a, 0x6817, 0x0000, 0x6820, 0xa205,
-	0x6822, 0x1078, 0x202a, 0x2021, 0x4a02, 0x241c, 0x8319, 0x2322,
-	0x6010, 0x8001, 0x6012, 0x00c0, 0x2f3a, 0x2021, 0x4a04, 0x2404,
-	0xc0a5, 0x2022, 0x6008, 0xa084, 0xf9ef, 0x600a, 0x1078, 0x3bd2,
-	0x007c, 0xa085, 0x0001, 0x0078, 0x2f40, 0x2300, 0x0079, 0x2f48,
-	0x2f4d, 0x2f4b, 0x2fce, 0x1078, 0x28ec, 0x78e4, 0xa005, 0x00d0,
-	0x2f84, 0x3208, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f,
-	0x0040, 0x2f5e, 0xa18c, 0x0300, 0x0078, 0x2f60, 0xa18c, 0x0400,
-	0x0040, 0x2f66, 0x0018, 0x2942, 0x0078, 0x2f68, 0x0028, 0x2942,
-	0x2008, 0xa084, 0x0030, 0x00c0, 0x2f70, 0x781b, 0x005b, 0x007c,
-	0x78ec, 0xa084, 0x0003, 0x0040, 0x2f6d, 0x2100, 0xa084, 0x0007,
-	0x0079, 0x2f7a, 0x2fae, 0x2fb8, 0x2fa3, 0x2f82, 0x4111, 0x4111,
-	0x2f82, 0x2fc3, 0x1078, 0x28ec, 0x7000, 0xa086, 0x0004, 0x00c0,
-	0x2f9e, 0x7064, 0xa086, 0x0002, 0x00c0, 0x2f94, 0x2011, 0x0002,
-	0x2019, 0x0000, 0x0078, 0x2e43, 0x7064, 0xa086, 0x0006, 0x0040,
-	0x2f8e, 0x7064, 0xa086, 0x0004, 0x0040, 0x2f8e, 0x79e4, 0x2001,
-	0x0003, 0x0078, 0x3304, 0x6818, 0xd0fc, 0x0040, 0x2fa9, 0x681b,
-	0x001d, 0x1078, 0x3eae, 0x781b, 0x0061, 0x007c, 0x6818, 0xd0fc,
-	0x0040, 0x2fb4, 0x681b, 0x001d, 0x1078, 0x3eae, 0x0078, 0x40ed,
-	0x6818, 0xd0fc, 0x0040, 0x2fbe, 0x681b, 0x001d, 0x1078, 0x3eae,
-	0x781b, 0x00ef, 0x007c, 0x6818, 0xd0fc, 0x0040, 0x2fc9, 0x681b,
-	0x001d, 0x1078, 0x3eae, 0x781b, 0x00bf, 0x007c, 0xa584, 0x000f,
-	0x00c0, 0x2feb, 0x7000, 0x0079, 0x2fd5, 0x2946, 0x2fdd, 0x2fdf,
-	0x3b7a, 0x3b7a, 0x3b7a, 0x2fdd, 0x2fdd, 0x1078, 0x28ec, 0x1078,
-	0x3bd2, 0x6008, 0xa084, 0xfbef, 0x600a, 0x1078, 0x3b6b, 0x0040,
-	0x3b7a, 0x0078, 0x2946, 0x78e4, 0xa005, 0x00d0, 0x2f84, 0x3208,
-	0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x2ffc,
-	0xa18c, 0x0300, 0x0078, 0x2ffe, 0xa18c, 0x0400, 0x0040, 0x3004,
-	0x0018, 0x2f84, 0x0078, 0x3006, 0x0028, 0x2f84, 0x2008, 0xa084,
-	0x0030, 0x00c0, 0x300e, 0x781b, 0x005b, 0x007c, 0x78ec, 0xa084,
-	0x0003, 0x0040, 0x300b, 0x2100, 0xa184, 0x0007, 0x0079, 0x3018,
-	0x3027, 0x302b, 0x3022, 0x3020, 0x4111, 0x4111, 0x3020, 0x410b,
-	0x1078, 0x28ec, 0x1078, 0x3eb6, 0x781b, 0x0061, 0x007c, 0x1078,
-	0x3eb6, 0x0078, 0x40ed, 0x1078, 0x3eb6, 0x781b, 0x00ef, 0x007c,
-	0x1078, 0x3eb6, 0x781b, 0x00bf, 0x007c, 0x2300, 0x0079, 0x3038,
-	0x303d, 0x303b, 0x303f, 0x1078, 0x28ec, 0x0078, 0x37bd, 0x681b,
-	0x0016, 0x78a3, 0x0000, 0x79e4, 0xa184, 0x0030, 0x0040, 0x37bd,
-	0x78ec, 0xa084, 0x0003, 0x0040, 0x37bd, 0xa184, 0x0100, 0x0040,
-	0x3043, 0xa184, 0x0007, 0x0079, 0x3055, 0x305d, 0x302b, 0x2fa3,
-	0x40c9, 0x4111, 0x4111, 0x40c9, 0x410b, 0x1078, 0x40d5, 0x007c,
-	0xa282, 0x0005, 0x0050, 0x3066, 0x1078, 0x28ec, 0x2300, 0x0079,
-	0x3069, 0x306c, 0x328b, 0x3296, 0x2200, 0x0079, 0x306f, 0x3089,
-	0x3076, 0x3089, 0x3074, 0x326e, 0x1078, 0x28ec, 0x789b, 0x0018,
-	0x78a8, 0xa084, 0x00ff, 0xa082, 0x0020, 0x0048, 0x3e9d, 0xa08a,
-	0x0004, 0x00c8, 0x3e9d, 0x0079, 0x3085, 0x3e9d, 0x3e9d, 0x3e9d,
-	0x3e47, 0x789b, 0x0018, 0x79a8, 0xa184, 0x0080, 0x0040, 0x309a,
-	0x0078, 0x3e9d, 0x7000, 0xa005, 0x00c0, 0x3090, 0x2011, 0x0004,
-	0x0078, 0x3998, 0xa184, 0x00ff, 0xa08a, 0x0010, 0x00c8, 0x3e9d,
-	0x0079, 0x30a2, 0x30b4, 0x30b2, 0x30c9, 0x30cd, 0x318f, 0x3e9d,
-	0x3e9d, 0x3191, 0x3e9d, 0x3e9d, 0x326a, 0x326a, 0x3e9d, 0x3e9d,
-	0x3e9d, 0x326c, 0x1078, 0x28ec, 0xd6e4, 0x0040, 0x30bf, 0x2001,
-	0x0300, 0x8000, 0x8000, 0x783a, 0x781b, 0x00ba, 0x007c, 0x6818,
-	0xd0fc, 0x0040, 0x30c7, 0x681b, 0x001d, 0x0078, 0x30b7, 0x0078,
-	0x40c9, 0x681b, 0x001d, 0x0078, 0x3ea7, 0x6920, 0x6922, 0xa684,
-	0x1800, 0x00c0, 0x3121, 0x6820, 0xd084, 0x00c0, 0x3127, 0x6818,
-	0xa086, 0x0008, 0x00c0, 0x30de, 0x681b, 0x0000, 0xd6d4, 0x0040,
-	0x318c, 0xd6bc, 0x0040, 0x311e, 0x7087, 0x0000, 0x6818, 0xa084,
-	0x003f, 0xa08a, 0x000d, 0x0050, 0x311e, 0xa08a, 0x000c, 0x7186,
+	0x6018, 0x8001, 0x601a, 0x0c7f, 0x007c, 0x7014, 0xa005, 0x00c0,
+	0x2a7b, 0x70d4, 0xd0b4, 0x0040, 0x2a7c, 0x70b8, 0xac06, 0x00c0,
+	0x2a7c, 0x1078, 0x2a5b, 0x007c, 0x017e, 0x71a4, 0xa186, 0x0001,
+	0x0040, 0x2aae, 0x0d7e, 0x027e, 0x2100, 0x2011, 0x0001, 0xa212,
+	0x70b4, 0x2068, 0x6800, 0xac06, 0x0040, 0x2a95, 0x8211, 0x0040,
+	0x2aac, 0x1078, 0x2ab0, 0x0078, 0x2a8a, 0x0c7e, 0x2100, 0x2011,
+	0x0001, 0xa212, 0x70b4, 0x2068, 0x6800, 0x2060, 0x6008, 0xa084,
+	0xfbef, 0x600a, 0x8211, 0x0040, 0x2aa9, 0x1078, 0x2ab0, 0x0078,
+	0x2a9c, 0x70a7, 0x0001, 0x0c7f, 0x027f, 0x0d7f, 0x017f, 0x007c,
+	0xade8, 0x0005, 0x70ac, 0xad06, 0x00c0, 0x2ab8, 0x70a8, 0x2068,
+	0x007c, 0x1078, 0x42e9, 0x00c0, 0x2962, 0x707c, 0x2068, 0x7774,
+	0x1078, 0x4187, 0x2c50, 0x1078, 0x43bd, 0x789b, 0x0010, 0x6814,
+	0xa084, 0x001f, 0xc0bd, 0x78aa, 0x6e1c, 0x2041, 0x0001, 0x2001,
+	0x0004, 0x0078, 0x2c32, 0x1078, 0x42e9, 0x00c0, 0x2962, 0x789b,
+	0x0010, 0x7060, 0x2068, 0x6f14, 0x70d4, 0xd0b4, 0x0040, 0x2aed,
+	0xc0b4, 0x70d6, 0x0c7e, 0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef,
+	0x600a, 0x6018, 0x8001, 0x601a, 0x0c7f, 0x1078, 0x4187, 0x2c50,
+	0x1078, 0x43bd, 0x6824, 0xa005, 0x0040, 0x2afe, 0xa082, 0x0006,
+	0x0048, 0x2afc, 0x0078, 0x2afe, 0x6827, 0x0005, 0x6814, 0xa084,
+	0x001f, 0xc0bd, 0x78aa, 0x2031, 0x0020, 0x2041, 0x0001, 0x2001,
+	0x0003, 0x0078, 0x2c32, 0xc28d, 0x72d6, 0x72c0, 0xa200, 0xa015,
+	0x7154, 0x8108, 0xa12a, 0x0048, 0x2b16, 0x71c0, 0x2164, 0x6504,
+	0x85ff, 0x00c0, 0x2b2d, 0x7156, 0x8421, 0x00c0, 0x2b11, 0x70d4,
+	0xd08c, 0x0040, 0x2b29, 0x70d0, 0xa005, 0x00c0, 0x2b29, 0x70d3,
+	0x000a, 0x007c, 0x2200, 0x0078, 0x2b1b, 0x70d4, 0xc08c, 0x70d6,
+	0x70d3, 0x0000, 0x6034, 0xa005, 0x00c0, 0x2b2a, 0x6708, 0xa784,
+	0x073f, 0x0040, 0x2b5c, 0xd7d4, 0x00c0, 0x2b2a, 0xa784, 0x0021,
+	0x00c0, 0x2b2a, 0xa784, 0x0002, 0x0040, 0x2b4d, 0xa784, 0x0004,
+	0x0040, 0x2b2a, 0xa7bc, 0xfffb, 0x670a, 0xa784, 0x0218, 0x00c0,
+	0x2b2a, 0xa784, 0x0100, 0x0040, 0x2b5c, 0x6018, 0xa005, 0x00c0,
+	0x2b2a, 0xa7bc, 0xfeff, 0x670a, 0x2568, 0x6823, 0x0000, 0x6e1c,
+	0xa684, 0x000e, 0x6318, 0x0040, 0x2b6d, 0x601c, 0xa302, 0x0048,
+	0x2b70, 0x0040, 0x2b70, 0x0078, 0x2b2a, 0x83ff, 0x00c0, 0x2b2a,
+	0x2d58, 0x2c50, 0x7156, 0xd7bc, 0x00c0, 0x2b78, 0x7028, 0x6022,
+	0xc7bc, 0x670a, 0x68c0, 0xa065, 0xa04d, 0x6100, 0x2a60, 0x2041,
+	0x0001, 0x6b14, 0xa39c, 0x001f, 0xa39d, 0x00c0, 0xd1fc, 0x0040,
+	0x2b8c, 0xd684, 0x0040, 0x2b8e, 0xa39c, 0xffbf, 0xd6a4, 0x0040,
+	0x2b93, 0xa39d, 0x0020, 0xa684, 0x000e, 0x00c0, 0x2bde, 0xc7a5,
+	0x670a, 0x2c00, 0x68c6, 0x77a4, 0xa786, 0x0001, 0x00c0, 0x2bb2,
+	0x70d4, 0xd0b4, 0x00c0, 0x2bb2, 0x7000, 0xa082, 0x0002, 0x00c8,
+	0x2bb2, 0x7830, 0xd0bc, 0x00c0, 0x2bb2, 0x789b, 0x0010, 0x7baa,
+	0x0078, 0x2c2a, 0x8739, 0x77a6, 0x2750, 0x77b0, 0xa7b0, 0x0005,
+	0x70ac, 0xa606, 0x00c0, 0x2bbd, 0x76a8, 0x76b2, 0x2c3a, 0x8738,
+	0x2d3a, 0x8738, 0x283a, 0x8738, 0x233a, 0x8738, 0x253a, 0x7830,
+	0xd0bc, 0x0040, 0x2bd5, 0x2091, 0x8000, 0x2091, 0x303d, 0x70d4,
+	0xa084, 0x303d, 0x2091, 0x8000, 0x2090, 0xaad5, 0x0000, 0x0040,
+	0x2bdd, 0x8421, 0x2200, 0x00c0, 0x2b10, 0x007c, 0xd1dc, 0x0040,
+	0x3d86, 0x2029, 0x0020, 0xd69c, 0x00c0, 0x2beb, 0x8528, 0xd68c,
+	0x00c0, 0x2beb, 0x8528, 0x8840, 0x6f14, 0x610c, 0x8108, 0xa18c,
+	0x00ff, 0x70cc, 0xa160, 0x2c64, 0x8cff, 0x0040, 0x2c0a, 0x6014,
+	0xa706, 0x00c0, 0x2bf3, 0x60b8, 0x8001, 0x60ba, 0x00c0, 0x2bee,
+	0x2a60, 0x6008, 0xa085, 0x0100, 0x600a, 0x2200, 0x8421, 0x00c0,
+	0x2b10, 0x007c, 0x2a60, 0x610e, 0x69be, 0x2c00, 0x68c6, 0x8840,
+	0x6008, 0xc0d5, 0x600a, 0x77a4, 0xa786, 0x0001, 0x00c0, 0x2bb2,
+	0x70d4, 0xd0b4, 0x00c0, 0x2bb2, 0x7000, 0xa082, 0x0002, 0x00c8,
+	0x2bb2, 0x7830, 0xd0bc, 0x00c0, 0x2bb2, 0x789b, 0x0010, 0x7baa,
+	0x7daa, 0x79aa, 0x2001, 0x0002, 0x007e, 0x6018, 0x8000, 0x601a,
+	0x0078, 0x2c33, 0x007e, 0x2960, 0x6104, 0x2a60, 0xa184, 0x0018,
+	0x0040, 0x2c4f, 0xa184, 0x0010, 0x0040, 0x2c42, 0x1078, 0x3f99,
+	0x00c0, 0x2c74, 0xa184, 0x0008, 0x0040, 0x2c4f, 0x69a0, 0xa184,
+	0x0600, 0x00c0, 0x2c4f, 0x1078, 0x3e7c, 0x0078, 0x2c74, 0x69a0,
+	0xa184, 0x1e00, 0x0040, 0x2c7f, 0xa184, 0x0800, 0x0040, 0x2c68,
+	0x0c7e, 0x2960, 0x6000, 0xa085, 0x2000, 0x6002, 0x6104, 0xa18d,
+	0x0010, 0x6106, 0x0c7f, 0x1078, 0x3f99, 0x00c0, 0x2c74, 0x69a0,
+	0xa184, 0x0200, 0x0040, 0x2c70, 0x1078, 0x3edc, 0x0078, 0x2c74,
+	0xa184, 0x0400, 0x00c0, 0x2c4b, 0x69a0, 0xa184, 0x1000, 0x0040,
+	0x2c7f, 0x6914, 0xa18c, 0xff00, 0x810f, 0x1078, 0x2755, 0x027f,
+	0xa68c, 0x00e0, 0xa684, 0x0060, 0x0040, 0x2c8c, 0xa086, 0x0060,
+	0x00c0, 0x2c8c, 0xa18d, 0x4000, 0xa18d, 0x0104, 0x69b6, 0x789b,
+	0x0060, 0x2800, 0x78aa, 0x6818, 0xc0fd, 0x681a, 0xd6bc, 0x0040,
+	0x2ca7, 0xc0fc, 0x7087, 0x0000, 0xa08a, 0x000d, 0x0050, 0x2ca5,
+	0xa08a, 0x000c, 0x7186, 0x2001, 0x000c, 0x800c, 0x718a, 0x78aa,
+	0x3518, 0x3340, 0x3428, 0x8000, 0x80ac, 0xaf80, 0x002b, 0x20a0,
+	0x789b, 0x0000, 0xad80, 0x000b, 0x2098, 0x53a6, 0x23a8, 0x2898,
+	0x25a0, 0xa286, 0x0020, 0x00c0, 0x2cdf, 0x70d4, 0xc0b5, 0x70d6,
+	0x2c00, 0x70ba, 0x2d00, 0x70be, 0x6814, 0xc0fc, 0x8007, 0x7882,
+	0xa286, 0x0002, 0x0040, 0x2d15, 0x70a4, 0x8000, 0x70a6, 0x74b4,
+	0xa498, 0x0005, 0x70ac, 0xa306, 0x00c0, 0x2cd7, 0x73a8, 0x73b6,
+	0xa286, 0x0010, 0x0040, 0x2962, 0x0d7f, 0x0c7f, 0x007c, 0x7000,
+	0xa005, 0x00c0, 0x2cbd, 0xa286, 0x0002, 0x00c0, 0x2d2f, 0x1078,
+	0x42e9, 0x00c0, 0x2cbd, 0x6814, 0xc0fc, 0x8007, 0x7882, 0x2091,
+	0x8000, 0x781b, 0x005b, 0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de,
+	0x6898, 0x78d2, 0x78da, 0x2091, 0x8001, 0x7808, 0xc08d, 0x780a,
+	0x127e, 0x0d7e, 0x0c7e, 0x70d4, 0xa084, 0x2700, 0x2090, 0x0c7f,
+	0x0d7f, 0x127f, 0x2900, 0x705a, 0x68bc, 0x7042, 0x7003, 0x0002,
+	0x2d00, 0x704e, 0xad80, 0x0009, 0x7046, 0x7830, 0xd0bc, 0x0040,
+	0x2d21, 0x2091, 0x303d, 0x70d4, 0xa084, 0x303d, 0x2091, 0x8000,
+	0x2090, 0x70a4, 0xa005, 0x00c0, 0x2d26, 0x007c, 0x8421, 0x0040,
+	0x2d25, 0x7250, 0x70c0, 0xa200, 0xa015, 0x0078, 0x2b10, 0xa286,
+	0x0010, 0x00c0, 0x2d60, 0x1078, 0x42e9, 0x00c0, 0x2cbd, 0x6814,
+	0xc0fc, 0x8007, 0x7882, 0x781b, 0x005b, 0x68b4, 0x785a, 0x6894,
+	0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0x7808, 0xc08d, 0x780a,
+	0x70a4, 0x8000, 0x70a6, 0x74b4, 0xa490, 0x0005, 0x70ac, 0xa206,
+	0x00c0, 0x2d53, 0x72a8, 0x72b6, 0x2900, 0x705a, 0x68bc, 0x7042,
+	0x7003, 0x0002, 0x2d00, 0x704e, 0xad80, 0x0009, 0x7046, 0x007c,
+	0x6bb4, 0xa39d, 0x2000, 0x7b5a, 0x6814, 0xc0fc, 0x8007, 0x7882,
+	0x6b94, 0x7bd6, 0x7bde, 0x6e98, 0x7ed2, 0x7eda, 0x781b, 0x005b,
+	0x2900, 0x705a, 0x7202, 0x7808, 0xc08d, 0x780a, 0x2300, 0xa605,
+	0x0040, 0x2d8b, 0x70d4, 0xa084, 0x2700, 0xa086, 0x2300, 0x00c0,
+	0x2d85, 0x2009, 0x0000, 0x0078, 0x2d87, 0x2009, 0x0001, 0xa284,
+	0x000f, 0x1079, 0x2d8f, 0xad80, 0x0009, 0x7046, 0x007c, 0x2d97,
+	0x4834, 0x4834, 0x4821, 0x4834, 0x2d97, 0x2d97, 0x2d97, 0x1078,
+	0x290c, 0x7808, 0xa084, 0xfffd, 0x780a, 0x0f7e, 0x2079, 0x4d00,
+	0x78ac, 0x0f7f, 0xd084, 0x0040, 0x2dbf, 0x7064, 0xa086, 0x0001,
+	0x00c0, 0x2dad, 0x7066, 0x0078, 0x2e96, 0x7064, 0xa086, 0x0005,
+	0x00c0, 0x2dbd, 0x707c, 0x2068, 0x681b, 0x0004, 0x6817, 0x0000,
+	0x6820, 0xa084, 0x00ff, 0xc09d, 0x6822, 0x7067, 0x0000, 0x70a7,
+	0x0000, 0x70a8, 0x70b2, 0x70b6, 0x1078, 0x2a5b, 0x157e, 0x2011,
+	0x0004, 0x7164, 0xa186, 0x0001, 0x0040, 0x2ddf, 0xa186, 0x0007,
+	0x00c0, 0x2dd6, 0x701f, 0x0005, 0x0078, 0x2ddf, 0x701f, 0x0001,
+	0x7067, 0x0000, 0x70d4, 0xc0dd, 0x70d6, 0x0078, 0x2de1, 0x7067,
+	0x0000, 0x2001, 0x4d0a, 0x2004, 0xa084, 0x00ff, 0xa086, 0x0018,
+	0x0040, 0x2df1, 0x7018, 0x7016, 0xa005, 0x00c0, 0x2df1, 0x70a7,
+	0x0001, 0x067e, 0x1078, 0x44fb, 0x20a9, 0x0010, 0x2039, 0x0000,
+	0x1078, 0x4081, 0xa7b8, 0x0100, 0x00f0, 0x2df8, 0x067f, 0x7000,
+	0x0079, 0x2e02, 0x2e3c, 0x2e17, 0x2e17, 0x2e0c, 0x2e3c, 0x2e3c,
+	0x2e3c, 0x2e0a, 0x1078, 0x290c, 0x7060, 0xa005, 0x0040, 0x2e3c,
+	0xad06, 0x00c0, 0x2e17, 0x6800, 0x7062, 0x0078, 0x2e29, 0x6820,
+	0xd084, 0x00c0, 0x2e25, 0x6f14, 0x1078, 0x4187, 0x6008, 0xc0d4,
+	0x600a, 0x1078, 0x3d56, 0x0078, 0x2e29, 0x705c, 0x2060, 0x6800,
+	0x6002, 0xa684, 0x5f00, 0x681e, 0x6818, 0xd0fc, 0x0040, 0x2e31,
+	0x6a1a, 0x6817, 0x0000, 0x682b, 0x0000, 0x6820, 0xa084, 0x00ff,
+	0xc09d, 0x6822, 0x1078, 0x2013, 0xb284, 0x0400, 0x0040, 0x2e44,
+	0x2021, 0x94d0, 0x0078, 0x2e46, 0x2021, 0x93c0, 0x1078, 0x2e9b,
+	0xb284, 0x0400, 0x0040, 0x2e50, 0x2021, 0x4d98, 0x0078, 0x2e52,
+	0x2021, 0x4d58, 0x1078, 0x2e9b, 0x20a9, 0x0101, 0xb284, 0x0400,
+	0x0040, 0x2e5e, 0x2021, 0x93d0, 0x0078, 0x2e60, 0x2021, 0x92c0,
+	0x1078, 0x2e9b, 0x8420, 0x00f0, 0x2e60, 0xb284, 0x0300, 0x0040,
+	0x2e6d, 0x2061, 0x52c0, 0x0078, 0x2e6f, 0x2061, 0x72c0, 0x2021,
+	0x0002, 0x20a9, 0x0100, 0x6110, 0x81ff, 0x0040, 0x2e8c, 0x6018,
+	0x017e, 0x007e, 0x2011, 0x4d02, 0x220c, 0xa102, 0x2012, 0x007f,
+	0x017f, 0xa102, 0x0050, 0x2e8c, 0x6012, 0x00c0, 0x2e8c, 0x2011,
+	0x4d04, 0x2204, 0xc0a5, 0x2012, 0x601b, 0x0000, 0xace0, 0x0010,
+	0x00f0, 0x2e73, 0x8421, 0x00c0, 0x2e71, 0x157f, 0x7003, 0x0000,
+	0x704f, 0x0000, 0x007c, 0x047e, 0x2404, 0xa005, 0x0040, 0x2eb6,
+	0x2068, 0x6800, 0x007e, 0x6a1a, 0x6817, 0x0000, 0x682b, 0x0000,
+	0x68b4, 0xa084, 0x5f00, 0x681e, 0x6820, 0xa084, 0x00ff, 0xc09d,
+	0x6822, 0x1078, 0x2013, 0x007f, 0x0078, 0x2e9d, 0x047f, 0x2023,
+	0x0000, 0x007c, 0xa282, 0x0003, 0x0050, 0x2ec0, 0x1078, 0x290c,
+	0x2300, 0x0079, 0x2ec3, 0x2ec6, 0x2f51, 0x2f6e, 0xa282, 0x0002,
+	0x0040, 0x2ecc, 0x1078, 0x290c, 0x7064, 0x7067, 0x0000, 0x7083,
+	0x0000, 0x0079, 0x2ed3, 0x2edb, 0x2edb, 0x2edd, 0x2f1d, 0x3d92,
+	0x2edb, 0x2f1d, 0x2edb, 0x1078, 0x290c, 0x7774, 0x1078, 0x4081,
+	0x7774, 0xa7bc, 0x8f00, 0x1078, 0x4187, 0x6018, 0xa005, 0x0040,
+	0x2f14, 0xd7fc, 0x00c0, 0x2ef0, 0x2021, 0x93c0, 0x0078, 0x2ef2,
+	0x2021, 0x94d0, 0x2009, 0x0005, 0x2011, 0x0010, 0x1078, 0x2f89,
+	0x0040, 0x2f14, 0x157e, 0x20a9, 0x0101, 0xd7fc, 0x00c0, 0x2f04,
+	0x2021, 0x92c0, 0x0078, 0x2f06, 0x2021, 0x93d0, 0x047e, 0x2009,
+	0x0005, 0x2011, 0x0010, 0x1078, 0x2f89, 0x047f, 0x0040, 0x2f13,
+	0x8420, 0x00f0, 0x2f06, 0x157f, 0x8738, 0xa784, 0x001f, 0x00c0,
+	0x2ee3, 0x0078, 0x2966, 0x0078, 0x2966, 0x7774, 0x1078, 0x4187,
+	0x6018, 0xa005, 0x0040, 0x2f4f, 0xd7fc, 0x00c0, 0x2f2b, 0x2021,
+	0x93c0, 0x0078, 0x2f2d, 0x2021, 0x94d0, 0x2009, 0x0005, 0x2011,
+	0x0020, 0x1078, 0x2f89, 0x0040, 0x2f4f, 0x157e, 0x20a9, 0x0101,
+	0xd7fc, 0x00c0, 0x2f3f, 0x2021, 0x92c0, 0x0078, 0x2f41, 0x2021,
+	0x93d0, 0x047e, 0x2009, 0x0005, 0x2011, 0x0020, 0x1078, 0x2f89,
+	0x047f, 0x0040, 0x2f4e, 0x8420, 0x00f0, 0x2f41, 0x157f, 0x0078,
+	0x2966, 0x2200, 0x0079, 0x2f54, 0x2f57, 0x2f59, 0x2f59, 0x1078,
+	0x290c, 0x2009, 0x0012, 0x7064, 0xa086, 0x0002, 0x0040, 0x2f62,
+	0x2009, 0x000e, 0x6818, 0xd0fc, 0x0040, 0x2f67, 0x691a, 0x7067,
+	0x0000, 0x70d4, 0xc0dd, 0x70d6, 0x0078, 0x4296, 0x2200, 0x0079,
+	0x2f71, 0x2f76, 0x2f59, 0x2f74, 0x1078, 0x290c, 0x1078, 0x44fb,
+	0x7000, 0xa086, 0x0002, 0x00c0, 0x3d04, 0x1078, 0x3d73, 0x6008,
+	0xa084, 0xfbef, 0x600a, 0x1078, 0x3cf5, 0x0040, 0x3d04, 0x0078,
+	0x2966, 0x2404, 0xa005, 0x0040, 0x2fc2, 0x2068, 0x2d04, 0x007e,
+	0x6814, 0xa706, 0x0040, 0x2f98, 0x2d20, 0x007f, 0x0078, 0x2f8a,
+	0x007f, 0x2022, 0x691a, 0x6817, 0x0000, 0x682b, 0x0000, 0x68b4,
+	0xa084, 0x5f00, 0x681e, 0x6820, 0xa084, 0x00ff, 0xa205, 0x6822,
+	0x1078, 0x2013, 0x2021, 0x4d02, 0x241c, 0x8319, 0x2322, 0x6010,
+	0x8001, 0x6012, 0x00c0, 0x2fb9, 0x2021, 0x4d04, 0x2404, 0xc0a5,
+	0x2022, 0x6008, 0xa084, 0xf9ef, 0x600a, 0x1078, 0x2a7c, 0x1078,
+	0x3d73, 0x007c, 0xa085, 0x0001, 0x0078, 0x2fc1, 0x2300, 0x0079,
+	0x2fc9, 0x2fce, 0x2fcc, 0x304e, 0x1078, 0x290c, 0x78e4, 0xa005,
+	0x00d0, 0x3004, 0x3208, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec,
+	0x007f, 0x0040, 0x2fdf, 0xa18c, 0x0300, 0x0078, 0x2fe1, 0xa18c,
+	0x0400, 0x0040, 0x2fe7, 0x0018, 0x2962, 0x0078, 0x2fe9, 0x0028,
+	0x2962, 0x2008, 0xa084, 0x0030, 0x00c0, 0x2ff0, 0x0078, 0x36fb,
+	0x78ec, 0xa084, 0x0003, 0x0040, 0x2fee, 0x2100, 0xa084, 0x0007,
+	0x0079, 0x2ffa, 0x302e, 0x3038, 0x3023, 0x3002, 0x42de, 0x42de,
+	0x3002, 0x3043, 0x1078, 0x290c, 0x7000, 0xa086, 0x0004, 0x00c0,
+	0x301e, 0x7064, 0xa086, 0x0002, 0x00c0, 0x3014, 0x2011, 0x0002,
+	0x2019, 0x0000, 0x0078, 0x2eba, 0x7064, 0xa086, 0x0006, 0x0040,
+	0x300e, 0x7064, 0xa086, 0x0004, 0x0040, 0x300e, 0x79e4, 0x2001,
+	0x0003, 0x0078, 0x3385, 0x6818, 0xd0fc, 0x0040, 0x3029, 0x681b,
+	0x001d, 0x1078, 0x4051, 0x781b, 0x0061, 0x007c, 0x6818, 0xd0fc,
+	0x0040, 0x3034, 0x681b, 0x001d, 0x1078, 0x4051, 0x0078, 0x42ba,
+	0x6818, 0xd0fc, 0x0040, 0x303e, 0x681b, 0x001d, 0x1078, 0x4051,
+	0x781b, 0x00f5, 0x007c, 0x6818, 0xd0fc, 0x0040, 0x3049, 0x681b,
+	0x001d, 0x1078, 0x4051, 0x781b, 0x00c5, 0x007c, 0xa584, 0x000f,
+	0x00c0, 0x306b, 0x7000, 0x0079, 0x3055, 0x2966, 0x305d, 0x305f,
+	0x3d04, 0x3d04, 0x3d04, 0x305d, 0x305d, 0x1078, 0x290c, 0x1078,
+	0x3d73, 0x6008, 0xa084, 0xfbef, 0x600a, 0x1078, 0x3cf5, 0x0040,
+	0x3d04, 0x0078, 0x2966, 0x78e4, 0xa005, 0x00d0, 0x3004, 0x3208,
+	0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x307c,
+	0xa18c, 0x0300, 0x0078, 0x307e, 0xa18c, 0x0400, 0x0040, 0x3084,
+	0x0018, 0x3004, 0x0078, 0x3086, 0x0028, 0x3004, 0x2008, 0xa084,
+	0x0030, 0x00c0, 0x308e, 0x781b, 0x005b, 0x007c, 0x78ec, 0xa084,
+	0x0003, 0x0040, 0x308b, 0x2100, 0xa184, 0x0007, 0x0079, 0x3098,
+	0x30a7, 0x30ab, 0x30a2, 0x30a0, 0x42de, 0x42de, 0x30a0, 0x42d8,
+	0x1078, 0x290c, 0x1078, 0x4059, 0x781b, 0x0061, 0x007c, 0x1078,
+	0x4059, 0x0078, 0x42ba, 0x1078, 0x4059, 0x781b, 0x00f5, 0x007c,
+	0x1078, 0x4059, 0x781b, 0x00c5, 0x007c, 0x2300, 0x0079, 0x30b8,
+	0x30bd, 0x30bb, 0x30bf, 0x1078, 0x290c, 0x0078, 0x38cf, 0x681b,
+	0x0016, 0x78a3, 0x0000, 0x79e4, 0xa184, 0x0030, 0x0040, 0x38cf,
+	0x78ec, 0xa084, 0x0003, 0x0040, 0x38cf, 0xa184, 0x0100, 0x0040,
+	0x30c3, 0xa184, 0x0007, 0x0079, 0x30d5, 0x30dd, 0x30ab, 0x3023,
+	0x4296, 0x42de, 0x42de, 0x4296, 0x42d8, 0x1078, 0x42a2, 0x007c,
+	0xa282, 0x0005, 0x0050, 0x30e6, 0x1078, 0x290c, 0x2300, 0x0079,
+	0x30e9, 0x30ec, 0x330b, 0x3316, 0x2200, 0x0079, 0x30ef, 0x3109,
+	0x30f6, 0x3109, 0x30f4, 0x32ee, 0x1078, 0x290c, 0x789b, 0x0018,
+	0x78a8, 0xa084, 0x00ff, 0xa082, 0x0020, 0x0048, 0x4040, 0xa08a,
+	0x0004, 0x00c8, 0x4040, 0x0079, 0x3105, 0x4040, 0x4040, 0x4040,
+	0x3fea, 0x789b, 0x0018, 0x79a8, 0xa184, 0x0080, 0x0040, 0x311a,
+	0x0078, 0x4040, 0x7000, 0xa005, 0x00c0, 0x3110, 0x2011, 0x0004,
+	0x0078, 0x3aba, 0xa184, 0x00ff, 0xa08a, 0x0010, 0x00c8, 0x4040,
+	0x0079, 0x3122, 0x3134, 0x3132, 0x3149, 0x314d, 0x320f, 0x4040,
+	0x4040, 0x3211, 0x4040, 0x4040, 0x32ea, 0x32ea, 0x4040, 0x4040,
+	0x4040, 0x32ec, 0x1078, 0x290c, 0xd6e4, 0x0040, 0x313f, 0x2001,
+	0x0300, 0x8000, 0x8000, 0x783a, 0x781b, 0x00c0, 0x007c, 0x6818,
+	0xd0fc, 0x0040, 0x3147, 0x681b, 0x001d, 0x0078, 0x3137, 0x0078,
+	0x4296, 0x681b, 0x001d, 0x0078, 0x404a, 0x6920, 0x6922, 0xa684,
+	0x1800, 0x00c0, 0x31a1, 0x6820, 0xd084, 0x00c0, 0x31a7, 0x6818,
+	0xa086, 0x0008, 0x00c0, 0x315e, 0x681b, 0x0000, 0xd6d4, 0x0040,
+	0x320c, 0xd6bc, 0x0040, 0x319e, 0x7087, 0x0000, 0x6818, 0xa084,
+	0x003f, 0xa08a, 0x000d, 0x0050, 0x319e, 0xa08a, 0x000c, 0x7186,
 	0x2001, 0x000c, 0x800c, 0x718a, 0x789b, 0x0061, 0x78aa, 0x157e,
-	0x137e, 0x147e, 0x017e, 0x3208, 0xa18c, 0x0300, 0x0040, 0x3110,
-	0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x310c,
-	0x20a1, 0x012b, 0x0078, 0x3112, 0x20a1, 0x022b, 0x0078, 0x3112,
+	0x137e, 0x147e, 0x017e, 0x3208, 0xa18c, 0x0300, 0x0040, 0x3190,
+	0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x318c,
+	0x20a1, 0x012b, 0x0078, 0x3192, 0x20a1, 0x022b, 0x0078, 0x3192,
 	0x20a1, 0x012b, 0x017f, 0x789b, 0x0000, 0x8000, 0x80ac, 0xad80,
 	0x000b, 0x2098, 0x53a6, 0x147f, 0x137f, 0x157f, 0x781b, 0x0064,
-	0x007c, 0xd6e4, 0x0040, 0x3127, 0x781b, 0x0076, 0x007c, 0xa684,
-	0x0060, 0x0040, 0x3189, 0xd6dc, 0x0040, 0x3189, 0xd6fc, 0x00c0,
-	0x3133, 0x0078, 0x314a, 0xc6fc, 0x7e5a, 0x6eb6, 0x7adc, 0x79d8,
-	0x78d0, 0x801b, 0x00c8, 0x313d, 0x8000, 0xa084, 0x003f, 0xa108,
+	0x007c, 0xd6e4, 0x0040, 0x31a7, 0x781b, 0x0076, 0x007c, 0xa684,
+	0x0060, 0x0040, 0x3209, 0xd6dc, 0x0040, 0x3209, 0xd6fc, 0x00c0,
+	0x31b3, 0x0078, 0x31ca, 0xc6fc, 0x7e5a, 0x6eb6, 0x7adc, 0x79d8,
+	0x78d0, 0x801b, 0x00c8, 0x31bd, 0x8000, 0xa084, 0x003f, 0xa108,
 	0xa291, 0x0000, 0x6b98, 0x2100, 0xa302, 0x68b2, 0x6b94, 0x2200,
-	0xa303, 0x68ae, 0xd6f4, 0x0040, 0x3150, 0xc6f4, 0x7e5a, 0x6eb6,
-	0x7000, 0xa086, 0x0003, 0x00c0, 0x315e, 0x007e, 0x1078, 0x4326,
-	0x1078, 0x45f7, 0x007f, 0x781b, 0x0073, 0x007c, 0xa006, 0x1078,
-	0x46e5, 0x6ab0, 0x69ac, 0x6c98, 0x6b94, 0x2200, 0xa105, 0x0040,
-	0x316d, 0x2200, 0xa422, 0x2100, 0xa31b, 0x6caa, 0x7cd2, 0x7cda,
-	0x6ba6, 0x7bd6, 0x7bde, 0x2300, 0xa405, 0x00c0, 0x317d, 0xc6f5,
+	0xa303, 0x68ae, 0xd6f4, 0x0040, 0x31d0, 0xc6f4, 0x7e5a, 0x6eb6,
+	0x7000, 0xa086, 0x0003, 0x00c0, 0x31de, 0x007e, 0x1078, 0x44fb,
+	0x1078, 0x4834, 0x007f, 0x781b, 0x0073, 0x007c, 0xa006, 0x1078,
+	0x493a, 0x6ab0, 0x69ac, 0x6c98, 0x6b94, 0x2200, 0xa105, 0x0040,
+	0x31ed, 0x2200, 0xa422, 0x2100, 0xa31b, 0x6caa, 0x7cd2, 0x7cda,
+	0x6ba6, 0x7bd6, 0x7bde, 0x2300, 0xa405, 0x00c0, 0x31fd, 0xc6f5,
 	0x7e5a, 0x6eb6, 0x781b, 0x0073, 0x007c, 0x781b, 0x0073, 0x2200,
-	0xa115, 0x00c0, 0x3186, 0x1078, 0x45f7, 0x007c, 0x1078, 0x462d,
+	0xa115, 0x00c0, 0x3206, 0x1078, 0x4834, 0x007c, 0x1078, 0x486c,
 	0x007c, 0x781b, 0x0076, 0x007c, 0x781b, 0x0064, 0x007c, 0x1078,
-	0x28ec, 0x0078, 0x31dd, 0x6920, 0xd1c4, 0x0040, 0x31a6, 0xc1c4,
+	0x290c, 0x0078, 0x325d, 0x6920, 0xd1c4, 0x0040, 0x3226, 0xc1c4,
 	0x6922, 0x0c7e, 0x7058, 0x2060, 0x6000, 0xc0e4, 0x6002, 0x6004,
-	0xa084, 0xfff5, 0x6006, 0x0c7f, 0x0078, 0x31d1, 0xd1cc, 0x0040,
-	0x31d1, 0xc1cc, 0x6922, 0x0c7e, 0x7058, 0x2060, 0x6000, 0xc0ec,
+	0xa084, 0xfff5, 0x6006, 0x0c7f, 0x0078, 0x3251, 0xd1cc, 0x0040,
+	0x3251, 0xc1cc, 0x6922, 0x0c7e, 0x7058, 0x2060, 0x6000, 0xc0ec,
 	0x6002, 0x6004, 0xc0a4, 0x6006, 0x2008, 0x2c48, 0x0c7f, 0xd19c,
-	0x0040, 0x31d1, 0x1078, 0x3fdd, 0x1078, 0x3cda, 0x88ff, 0x0040,
-	0x31d1, 0x789b, 0x0060, 0x2800, 0x78aa, 0x7e58, 0xc695, 0x7e5a,
-	0xd6d4, 0x00c0, 0x31ce, 0x781b, 0x0061, 0x007c, 0x781b, 0x0075,
-	0x007c, 0x7e58, 0xd6d4, 0x00c0, 0x31d8, 0x781b, 0x0064, 0x007c,
-	0x781b, 0x0076, 0x007c, 0x0078, 0x3ea2, 0x2019, 0x0000, 0x7990,
-	0xa18c, 0x0007, 0x00c0, 0x31eb, 0x6820, 0xa084, 0x0100, 0x0040,
-	0x31db, 0x2009, 0x0008, 0x789b, 0x0010, 0x78a8, 0xa094, 0x00ff,
-	0xa286, 0x0001, 0x00c0, 0x3207, 0x2300, 0x7ca8, 0xa400, 0x2018,
-	0xa102, 0x0040, 0x31ff, 0x0048, 0x31ff, 0x0078, 0x3201, 0x0078,
-	0x3193, 0x24a8, 0x7aa8, 0x00f0, 0x3201, 0x0078, 0x31ed, 0xa284,
-	0x00f0, 0xa086, 0x0020, 0x00c0, 0x325b, 0x8318, 0x8318, 0x2300,
-	0xa102, 0x0040, 0x3217, 0x0048, 0x3217, 0x0078, 0x3258, 0xa286,
-	0x0023, 0x0040, 0x31db, 0x681c, 0xa084, 0xfff1, 0x681e, 0x7e58,
+	0x0040, 0x3251, 0x1078, 0x4183, 0x1078, 0x3e7c, 0x88ff, 0x0040,
+	0x3251, 0x789b, 0x0060, 0x2800, 0x78aa, 0x7e58, 0xc695, 0x7e5a,
+	0xd6d4, 0x00c0, 0x324e, 0x781b, 0x0061, 0x007c, 0x781b, 0x0075,
+	0x007c, 0x7e58, 0xd6d4, 0x00c0, 0x3258, 0x781b, 0x0064, 0x007c,
+	0x781b, 0x0076, 0x007c, 0x0078, 0x4045, 0x2019, 0x0000, 0x7990,
+	0xa18c, 0x0007, 0x00c0, 0x326b, 0x6820, 0xa084, 0x0100, 0x0040,
+	0x325b, 0x2009, 0x0008, 0x789b, 0x0010, 0x78a8, 0xa094, 0x00ff,
+	0xa286, 0x0001, 0x00c0, 0x3287, 0x2300, 0x7ca8, 0xa400, 0x2018,
+	0xa102, 0x0040, 0x327f, 0x0048, 0x327f, 0x0078, 0x3281, 0x0078,
+	0x3213, 0x24a8, 0x7aa8, 0x00f0, 0x3281, 0x0078, 0x326d, 0xa284,
+	0x00f0, 0xa086, 0x0020, 0x00c0, 0x32db, 0x8318, 0x8318, 0x2300,
+	0xa102, 0x0040, 0x3297, 0x0048, 0x3297, 0x0078, 0x32d8, 0xa286,
+	0x0023, 0x0040, 0x325b, 0x681c, 0xa084, 0xfff1, 0x681e, 0x7e58,
 	0xa684, 0xfff1, 0xc0a5, 0x2030, 0x7e5a, 0x6008, 0xc0a5, 0x600a,
 	0x0c7e, 0x7058, 0x2060, 0x6004, 0x2008, 0x2c48, 0x0c7f, 0xd1a4,
-	0x0040, 0x3238, 0x1078, 0x3fdd, 0x1078, 0x3df6, 0x0078, 0x3246,
+	0x0040, 0x32b8, 0x1078, 0x4183, 0x1078, 0x3f99, 0x0078, 0x32c6,
 	0x0c7e, 0x7058, 0x2060, 0x6004, 0x2008, 0x2c48, 0x0c7f, 0xd19c,
-	0x0040, 0x31d1, 0x1078, 0x3fdd, 0x1078, 0x3cda, 0x88ff, 0x0040,
-	0x31d1, 0x789b, 0x0060, 0x2800, 0x78aa, 0xc695, 0x7e5a, 0xd6d4,
-	0x00c0, 0x3255, 0x781b, 0x0061, 0x007c, 0x781b, 0x0075, 0x007c,
-	0x7aa8, 0x0078, 0x31ed, 0x8318, 0x2300, 0xa102, 0x0040, 0x3264,
-	0x0048, 0x3264, 0x0078, 0x31ed, 0xa284, 0x0080, 0x00c0, 0x3ea7,
-	0x0078, 0x3ea2, 0x0078, 0x3ea7, 0x0078, 0x3e9d, 0x7058, 0xa04d,
+	0x0040, 0x3251, 0x1078, 0x4183, 0x1078, 0x3e7c, 0x88ff, 0x0040,
+	0x3251, 0x789b, 0x0060, 0x2800, 0x78aa, 0xc695, 0x7e5a, 0xd6d4,
+	0x00c0, 0x32d5, 0x781b, 0x0061, 0x007c, 0x781b, 0x0075, 0x007c,
+	0x7aa8, 0x0078, 0x326d, 0x8318, 0x2300, 0xa102, 0x0040, 0x32e4,
+	0x0048, 0x32e4, 0x0078, 0x326d, 0xa284, 0x0080, 0x00c0, 0x404a,
+	0x0078, 0x4045, 0x0078, 0x404a, 0x0078, 0x4040, 0x7058, 0xa04d,
 	0x789b, 0x0018, 0x78a8, 0xa084, 0x00ff, 0xa08e, 0x0001, 0x0040,
-	0x327b, 0x1078, 0x28ec, 0x7aa8, 0xa294, 0x00ff, 0x78a8, 0xa084,
-	0x00ff, 0xa08a, 0x0004, 0x00c8, 0x3e9d, 0x0079, 0x3287, 0x3e9d,
-	0x3c2c, 0x3e9d, 0x3d9e, 0xa282, 0x0000, 0x00c0, 0x3291, 0x1078,
-	0x28ec, 0x1078, 0x3eae, 0x781b, 0x0075, 0x007c, 0xa282, 0x0003,
-	0x00c0, 0x329c, 0x1078, 0x28ec, 0xd4fc, 0x00c0, 0x32bc, 0x7064,
-	0xa005, 0x0040, 0x32a5, 0x1078, 0x28ec, 0x6f14, 0x7776, 0xa7bc,
-	0x8f00, 0x1078, 0x3fe1, 0x6008, 0xa085, 0x0021, 0x600a, 0x8738,
-	0xa784, 0x001f, 0x00c0, 0x32a9, 0x1078, 0x3eb2, 0x7067, 0x0002,
-	0x701f, 0x0009, 0x0078, 0x32be, 0x1078, 0x3ebe, 0x781b, 0x0075,
-	0x007c, 0xa282, 0x0004, 0x0050, 0x32c7, 0x1078, 0x28ec, 0x2300,
-	0x0079, 0x32ca, 0x32cd, 0x346b, 0x34ae, 0xa286, 0x0003, 0x0040,
-	0x3304, 0x7200, 0x7cd8, 0x7ddc, 0x7fd0, 0x71d4, 0xd1b4, 0x0078,
-	0x32fc, 0x0040, 0x32fc, 0x7868, 0xa084, 0x00ff, 0x00c0, 0x32fc,
-	0xa282, 0x0002, 0x00c8, 0x32fc, 0x0d7e, 0x783b, 0x8300, 0x781b,
-	0x004c, 0x70bc, 0xa06d, 0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de,
-	0x6898, 0x78d2, 0x78da, 0xc1b4, 0x71d6, 0x7003, 0x0030, 0x0d7f,
-	0x2001, 0x0000, 0x0078, 0x3308, 0x783b, 0x1300, 0x781b, 0x004a,
-	0x2001, 0x0000, 0x0078, 0x3308, 0x7200, 0x7cd8, 0x7ddc, 0x7fd0,
-	0x704a, 0x68a0, 0xd0ec, 0x0040, 0x3310, 0x6008, 0xc08d, 0x600a,
-	0xa284, 0x000f, 0x0079, 0x3314, 0x344b, 0x3321, 0x331e, 0x35ae,
-	0x35f2, 0x2946, 0x331c, 0x331c, 0x1078, 0x28ec, 0x6008, 0xc0d4,
-	0x600a, 0xd6e4, 0x00c0, 0x3328, 0x1078, 0x4326, 0x0040, 0x3404,
-	0x7868, 0xa08c, 0x00ff, 0x0040, 0x3369, 0xa186, 0x0008, 0x00c0,
-	0x333e, 0x1078, 0x3bd2, 0x6008, 0xc0a4, 0x600a, 0x1078, 0x3b6b,
-	0x0040, 0x3369, 0x1078, 0x4326, 0x0078, 0x3353, 0xa186, 0x0028,
-	0x00c0, 0x3369, 0x1078, 0x4326, 0x6008, 0xc0a4, 0x600a, 0x6018,
-	0xa005, 0x0040, 0x3353, 0x8001, 0x601a, 0x0040, 0x3353, 0x8001,
-	0x0040, 0x3353, 0x601e, 0x6820, 0xd084, 0x0040, 0x2946, 0xc084,
-	0x6822, 0x705c, 0x0c7e, 0x2060, 0x6800, 0x6002, 0x0c7f, 0x6004,
-	0x6802, 0xa005, 0x2d00, 0x00c0, 0x3366, 0x6002, 0x6006, 0x0078,
-	0x2946, 0x017e, 0x81ff, 0x00c0, 0x33b0, 0x7000, 0xa086, 0x0030,
-	0x0040, 0x33b0, 0x71d4, 0xd1b4, 0x00c0, 0x3397, 0x7060, 0xa005,
-	0x00c0, 0x33b0, 0x70a4, 0xa086, 0x0001, 0x0040, 0x33b0, 0x7003,
-	0x0000, 0x047e, 0x057e, 0x077e, 0x067e, 0x0c7e, 0x0d7e, 0x1078,
-	0x296c, 0x0d7f, 0x0c7f, 0x067f, 0x077f, 0x057f, 0x047f, 0x71d4,
-	0xd1b4, 0x00c0, 0x33b0, 0x7003, 0x0040, 0x0078, 0x33b0, 0x1078,
-	0x411c, 0x00c0, 0x33b0, 0x781b, 0x005b, 0x0d7e, 0x70bc, 0xa06d,
-	0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da,
-	0xc1b4, 0x71d6, 0x7003, 0x0030, 0x7808, 0xc08d, 0x780a, 0x0d7f,
-	0x1078, 0x34e8, 0x017f, 0x81ff, 0x0040, 0x3403, 0xa684, 0xdf00,
-	0x681e, 0x682b, 0x0000, 0x6f14, 0xa186, 0x0002, 0x00c0, 0x3404,
-	0x70d4, 0xd0b4, 0x0040, 0x33d1, 0xc0b4, 0x70d6, 0x0c7e, 0x70b8,
-	0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a,
-	0x0c7f, 0x6820, 0xd0dc, 0x00c0, 0x3404, 0x8717, 0xa294, 0x000f,
-	0x8213, 0x8213, 0x8213, 0xb284, 0x0300, 0x0040, 0x33e3, 0xa290,
-	0x4ec0, 0x0078, 0x33e5, 0xa290, 0x4f40, 0xa290, 0x0000, 0x221c,
-	0xd3c4, 0x00c0, 0x33ed, 0x0078, 0x33f3, 0x8210, 0x2204, 0xa085,
-	0x0018, 0x2012, 0x8211, 0xd3d4, 0x0040, 0x33fe, 0x68a0, 0xd0c4,
-	0x00c0, 0x33fe, 0x1078, 0x3562, 0x0078, 0x2946, 0x6008, 0xc08d,
-	0x600a, 0x0078, 0x3404, 0x692a, 0x6916, 0x6818, 0xd0fc, 0x0040,
-	0x340b, 0x7048, 0x681a, 0xa68c, 0xdf00, 0x691e, 0x6410, 0x84ff,
-	0x0040, 0x3420, 0x2009, 0x4a02, 0x2104, 0x8001, 0x200a, 0x8421,
-	0x6412, 0x00c0, 0x3420, 0x2021, 0x4a04, 0x2404, 0xc0a5, 0x2022,
-	0x6018, 0xa005, 0x0040, 0x3428, 0x8001, 0x601a, 0x00c0, 0x342b,
-	0x6008, 0xc0a4, 0x600a, 0x6820, 0xd084, 0x00c0, 0x3437, 0x6800,
-	0xa005, 0x00c0, 0x3434, 0x6002, 0x6006, 0x0078, 0x343b, 0x705c,
-	0x2060, 0x6800, 0x6002, 0x2061, 0x4a00, 0x6887, 0x0103, 0x2d08,
-	0x206b, 0x0000, 0x6068, 0xa005, 0x616a, 0x0040, 0x344a, 0x2d02,
-	0x0078, 0x344b, 0x616e, 0x7200, 0xa286, 0x0030, 0x0040, 0x345b,
-	0xa286, 0x0040, 0x00c0, 0x2946, 0x7003, 0x0002, 0x704c, 0x2068,
-	0x68c4, 0x2060, 0x007c, 0x7003, 0x0002, 0x70bc, 0xa06d, 0x68bc,
-	0x7042, 0x70b8, 0xa065, 0x68c0, 0x705a, 0x2d00, 0x704e, 0xad80,
-	0x0009, 0x7046, 0x007c, 0xa282, 0x0004, 0x0048, 0x3471, 0x1078,
-	0x28ec, 0x2200, 0x0079, 0x3474, 0x3478, 0x3489, 0x3496, 0x3489,
-	0xa586, 0x1300, 0x0040, 0x3489, 0xa586, 0x8300, 0x00c0, 0x346f,
-	0x7003, 0x0000, 0x6018, 0x8001, 0x601a, 0x6008, 0xa084, 0xfbef,
-	0x600a, 0x7000, 0xa086, 0x0005, 0x0040, 0x3493, 0x1078, 0x3eae,
-	0x781b, 0x0075, 0x007c, 0x781b, 0x0076, 0x007c, 0x7890, 0x8007,
-	0x8001, 0xa084, 0x0007, 0xa080, 0x0018, 0x789a, 0x79a8, 0xa18c,
-	0x00ff, 0xa186, 0x0003, 0x0040, 0x34ab, 0xa186, 0x0000, 0x0040,
-	0x34ab, 0x0078, 0x3e9d, 0x781b, 0x0076, 0x007c, 0x6820, 0xc095,
-	0x6822, 0x82ff, 0x00c0, 0x34b8, 0x1078, 0x3eae, 0x0078, 0x34bf,
-	0x8211, 0x0040, 0x34bd, 0x1078, 0x28ec, 0x1078, 0x3ebe, 0x781b,
-	0x0075, 0x007c, 0x1078, 0x4131, 0x7830, 0xa084, 0x00c0, 0x00c0,
-	0x34e5, 0x017e, 0x3208, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec,
-	0x007f, 0x0040, 0x34d7, 0xa18c, 0x0300, 0x0078, 0x34d9, 0xa18c,
-	0x0400, 0x017f, 0x0040, 0x34e0, 0x0018, 0x34e5, 0x0078, 0x34e2,
-	0x0028, 0x34e5, 0x791a, 0xa006, 0x007c, 0xa085, 0x0001, 0x007c,
-	0xa684, 0x0060, 0x00c0, 0x34f2, 0x682f, 0x0000, 0x6833, 0x0000,
-	0x0078, 0x3561, 0xd6dc, 0x00c0, 0x350a, 0x68b4, 0xd0dc, 0x00c0,
-	0x350a, 0x6998, 0x6a94, 0x692e, 0x6a32, 0x7048, 0xa005, 0x00c0,
-	0x3507, 0x2200, 0xa105, 0x0040, 0x4326, 0x704b, 0x0015, 0x0078,
-	0x4326, 0x007c, 0xd6ac, 0x0040, 0x3530, 0xd6f4, 0x0040, 0x3516,
-	0x682f, 0x0000, 0x6833, 0x0000, 0x0078, 0x4326, 0x68b4, 0xa084,
-	0x4000, 0xa635, 0xd6f4, 0x00c0, 0x3510, 0x7048, 0xa005, 0x00c0,
-	0x3523, 0x704b, 0x0015, 0xd6dc, 0x00c0, 0x352c, 0x68b4, 0xd0dc,
-	0x0040, 0x352c, 0x6ca8, 0x6da4, 0x6c2e, 0x6d32, 0x0078, 0x4326,
-	0xd6f4, 0x0040, 0x3539, 0x682f, 0x0000, 0x6833, 0x0000, 0x0078,
-	0x4326, 0x68b4, 0xa084, 0x4800, 0xa635, 0xd6f4, 0x00c0, 0x3533,
-	0x7048, 0xa005, 0x00c0, 0x3546, 0x704b, 0x0015, 0x2408, 0x2510,
-	0x2700, 0x80fb, 0x00c8, 0x354d, 0x8000, 0xa084, 0x003f, 0xa108,
-	0xa291, 0x0000, 0x692e, 0x6a32, 0x2100, 0xa205, 0x00c0, 0x355a,
-	0x0078, 0x4326, 0x7000, 0xa086, 0x0006, 0x0040, 0x3561, 0x0078,
-	0x4326, 0x007c, 0x6008, 0xc0cd, 0xd3cc, 0x0040, 0x3568, 0xc08d,
-	0x600a, 0x681b, 0x0006, 0x688f, 0x0000, 0x6893, 0x0000, 0x6a30,
-	0x692c, 0x6a3e, 0x6942, 0x682f, 0x0003, 0x6833, 0x0000, 0x6837,
-	0x0020, 0x6897, 0x0000, 0x689b, 0x0020, 0x7000, 0x0079, 0x3580,
-	0x2946, 0x3592, 0x358a, 0x3588, 0x3588, 0x3588, 0x3588, 0x3588,
-	0x1078, 0x28ec, 0x6820, 0xd084, 0x00c0, 0x3592, 0x1078, 0x3bb5,
-	0x0078, 0x3598, 0x705c, 0x2c50, 0x2060, 0x6800, 0x6002, 0x2a60,
-	0x3208, 0xa18c, 0x0300, 0x0040, 0x35a1, 0x2021, 0x4a58, 0x0078,
-	0x35a3, 0x2021, 0x4a98, 0x2404, 0xa005, 0x0040, 0x35aa, 0x2020,
-	0x0078, 0x35a3, 0x2d22, 0x206b, 0x0000, 0x007c, 0x1078, 0x3bbc,
-	0x1078, 0x3bd2, 0x6008, 0xc0cc, 0x600a, 0x682b, 0x0000, 0x789b,
-	0x000e, 0x6f14, 0x6817, 0x0002, 0x3208, 0xa18c, 0x0300, 0x0040,
-	0x35c5, 0x2009, 0x0000, 0x0078, 0x35c7, 0x2009, 0x0001, 0x1078,
-	0x471a, 0xd6dc, 0x0040, 0x35cf, 0x691c, 0xc1ed, 0x691e, 0x6818,
-	0xd0fc, 0x0040, 0x35de, 0x7868, 0xa08c, 0x00ff, 0x0040, 0x35dc,
-	0x681b, 0x001e, 0x0078, 0x35de, 0x681b, 0x0000, 0xb284, 0x0300,
-	0x00c0, 0x35e6, 0x2021, 0x4a98, 0x0078, 0x35e8, 0x2021, 0x4a58,
-	0x6800, 0x2022, 0x6a3c, 0x6940, 0x6a32, 0x692e, 0x1078, 0x202a,
-	0x0078, 0x2946, 0x7cd8, 0x7ddc, 0x7fd0, 0x1078, 0x34e8, 0x682b,
-	0x0000, 0x789b, 0x000e, 0x6f14, 0x1078, 0x4135, 0xa08c, 0x00ff,
-	0x6916, 0x6818, 0xd0fc, 0x0040, 0x3607, 0x7048, 0x681a, 0xa68c,
-	0xdf00, 0x691e, 0x7067, 0x0000, 0x0078, 0x2946, 0x7000, 0xa005,
-	0x00c0, 0x3614, 0x0078, 0x2946, 0xa006, 0x1078, 0x4326, 0x6817,
-	0x0000, 0x681b, 0x0014, 0xa68c, 0xdf00, 0x691e, 0x682b, 0x0000,
-	0x6820, 0xa084, 0x00ff, 0x6822, 0x7000, 0x0079, 0x3627, 0x2946,
-	0x3634, 0x3631, 0x3636, 0x3636, 0x3636, 0x362f, 0x362f, 0x1078,
-	0x28ec, 0x6008, 0xc0d4, 0x600a, 0x1078, 0x3bd2, 0x6008, 0xc0a4,
-	0x600a, 0x0078, 0x3b85, 0x2300, 0x0079, 0x363e, 0x3641, 0x3643,
-	0x369f, 0x1078, 0x28ec, 0xd6fc, 0x00c0, 0x3686, 0x7000, 0xa00d,
-	0x0079, 0x364a, 0x2946, 0x3654, 0x3654, 0x3678, 0x3654, 0x3683,
-	0x3652, 0x3652, 0x1078, 0x28ec, 0xa684, 0x0060, 0xa086, 0x0060,
-	0x00c0, 0x3675, 0xc6ac, 0xc6f4, 0xc6ed, 0x7e5a, 0x681c, 0xc0ac,
-	0x681e, 0xa186, 0x0002, 0x0040, 0x3667, 0x1078, 0x4326, 0x1078,
-	0x45f7, 0x781b, 0x0076, 0x71d4, 0xd1b4, 0x00c0, 0x2942, 0x70a4,
-	0xa086, 0x0001, 0x00c0, 0x2989, 0x007c, 0xd6ec, 0x0040, 0x365c,
-	0x6818, 0xd0fc, 0x0040, 0x3683, 0x681b, 0x0015, 0xd6f4, 0x0040,
-	0x3683, 0x681b, 0x0007, 0x1078, 0x40d5, 0x007c, 0xc6fc, 0x7e5a,
-	0x7adc, 0x79d8, 0x78d0, 0x801b, 0x00c8, 0x368f, 0x8000, 0xa084,
-	0x003f, 0xa108, 0xa291, 0x0000, 0x6b98, 0x2100, 0xa302, 0x68b2,
-	0x6b94, 0x2200, 0xa303, 0x68ae, 0x781b, 0x0076, 0x007c, 0x1078,
-	0x28ec, 0x2300, 0x0079, 0x36a4, 0x36a9, 0x36c5, 0x3719, 0x1078,
-	0x28ec, 0x7000, 0x0079, 0x36ac, 0x36b4, 0x36b6, 0x36b6, 0x36b4,
-	0x36b4, 0x36b4, 0x36b4, 0x36b4, 0x1078, 0x28ec, 0x1078, 0x45f7,
-	0x681c, 0xc0b4, 0x681e, 0x70d4, 0xd0b4, 0x00c0, 0x2942, 0x70a4,
-	0xa086, 0x0001, 0x00c0, 0x2989, 0x007c, 0xd6fc, 0x00c0, 0x3709,
-	0x7000, 0xa00d, 0x0079, 0x36cc, 0x2946, 0x36dc, 0x36d6, 0x3700,
-	0x36dc, 0x3706, 0x36d4, 0x36d4, 0x1078, 0x28ec, 0x6894, 0x78d6,
-	0x78de, 0x6898, 0x78d2, 0x78da, 0xa684, 0x0060, 0xa086, 0x0060,
-	0x00c0, 0x36fd, 0xa6b4, 0xbfbf, 0xc6ed, 0x7e5a, 0xa186, 0x0002,
-	0x0040, 0x36ec, 0x1078, 0x4326, 0x1078, 0x45f7, 0x781b, 0x0076,
-	0x681c, 0xc0b4, 0x681e, 0x71d4, 0xd1b4, 0x00c0, 0x2942, 0x70a4,
-	0xa086, 0x0001, 0x00c0, 0x2989, 0x007c, 0xd6ec, 0x0040, 0x36e4,
-	0x6818, 0xd0fc, 0x0040, 0x3706, 0x681b, 0x0007, 0x781b, 0x00f0,
-	0x007c, 0xc6fc, 0x7e5a, 0x7adc, 0x79d8, 0x6b98, 0x2100, 0xa302,
-	0x68b2, 0x6b94, 0x2200, 0xa303, 0x68ae, 0x79d2, 0x781b, 0x0076,
-	0x007c, 0xd6dc, 0x0040, 0x3722, 0x782b, 0x3009, 0x781b, 0x0076,
-	0x0078, 0x2942, 0x7884, 0xc0ac, 0x7886, 0x78e4, 0xa084, 0x0008,
-	0x00c0, 0x3735, 0xa484, 0x0200, 0x0040, 0x372f, 0xc6f5, 0xc6dd,
-	0x7e5a, 0x781b, 0x0076, 0x0078, 0x2942, 0x6820, 0xc095, 0x6822,
-	0x1078, 0x4062, 0xc6dd, 0x1078, 0x3eae, 0x781b, 0x0075, 0x0078,
-	0x2942, 0x2300, 0x0079, 0x3744, 0x3747, 0x3749, 0x374b, 0x1078,
-	0x28ec, 0x0078, 0x3ea7, 0xd6d4, 0x00c0, 0x3771, 0x79e4, 0xd1ac,
-	0x0040, 0x3759, 0x78ec, 0xa084, 0x0003, 0x0040, 0x3759, 0x782b,
-	0x3009, 0x789b, 0x0060, 0x78ab, 0x0000, 0xa684, 0xfffb, 0x785a,
-	0x79e4, 0xd1ac, 0x0040, 0x3769, 0x78ec, 0xa084, 0x0003, 0x00c0,
-	0x376d, 0x2001, 0x0014, 0x0078, 0x3304, 0xa184, 0x0007, 0x0079,
-	0x37a7, 0x7a90, 0xa294, 0x0007, 0x789b, 0x0060, 0x79a8, 0x81ff,
-	0x0040, 0x37a5, 0x789b, 0x0010, 0x7ba8, 0xa384, 0x0001, 0x00c0,
-	0x3798, 0x7ba8, 0x7ba8, 0xa386, 0x0001, 0x00c0, 0x378b, 0x2009,
-	0xfff7, 0x0078, 0x3791, 0xa386, 0x0003, 0x00c0, 0x3798, 0x2009,
-	0xffef, 0x0c7e, 0x7058, 0x2060, 0x6004, 0xa104, 0x6006, 0x0c7f,
-	0x789b, 0x0060, 0x78ab, 0x0000, 0xa684, 0xfffb, 0x785a, 0x782b,
-	0x3009, 0x6920, 0xa18c, 0xfcff, 0x6922, 0x0078, 0x40c9, 0x2fae,
-	0x2fb8, 0x37b1, 0x37b7, 0x37af, 0x37af, 0x40c9, 0x40c9, 0x1078,
-	0x28ec, 0x6920, 0xa18c, 0xfcff, 0x6922, 0x0078, 0x40cf, 0x6920,
-	0xa18c, 0xfcff, 0x6922, 0x0078, 0x40c9, 0x79e4, 0xa184, 0x0030,
-	0x0040, 0x37c7, 0x78ec, 0xa084, 0x0003, 0x00c0, 0x37f1, 0x7000,
-	0xa086, 0x0004, 0x00c0, 0x37e1, 0x7064, 0xa086, 0x0002, 0x00c0,
-	0x37d7, 0x2011, 0x0002, 0x2019, 0x0000, 0x0078, 0x2e43, 0x7064,
-	0xa086, 0x0006, 0x0040, 0x37d1, 0x7064, 0xa086, 0x0004, 0x0040,
-	0x37d1, 0x7000, 0xa086, 0x0000, 0x0040, 0x2942, 0x6820, 0xd0ac,
-	0x00c0, 0x37ed, 0x6818, 0xc0fd, 0x681a, 0x2001, 0x0014, 0x0078,
-	0x3304, 0xa184, 0x0007, 0x0079, 0x37f5, 0x40c9, 0x40c9, 0x37fd,
-	0x40c9, 0x4111, 0x4111, 0x40c9, 0x40c9, 0xd6bc, 0x0040, 0x383f,
-	0x7184, 0x81ff, 0x0040, 0x383f, 0xa182, 0x000d, 0x00d0, 0x380c,
-	0x7087, 0x0000, 0x0078, 0x3811, 0xa182, 0x000c, 0x7086, 0x2009,
-	0x000c, 0x789b, 0x0061, 0x79aa, 0x157e, 0x137e, 0x147e, 0x7088,
-	0x8114, 0xa210, 0x728a, 0xa080, 0x000b, 0xad00, 0x2098, 0xb284,
-	0x0300, 0x0040, 0x3833, 0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec,
-	0x007f, 0x0040, 0x382f, 0x20a1, 0x012b, 0x0078, 0x3835, 0x20a1,
-	0x022b, 0x0078, 0x3835, 0x20a1, 0x012b, 0x789b, 0x0000, 0x8108,
-	0x81ac, 0x53a6, 0x147f, 0x137f, 0x157f, 0x0078, 0x40cf, 0xd6d4,
-	0x00c0, 0x3893, 0x6820, 0xd084, 0x0040, 0x40cf, 0xa68c, 0x0060,
-	0xa684, 0x0060, 0x0040, 0x3851, 0xa086, 0x0060, 0x00c0, 0x3851,
-	0xc1f5, 0xc194, 0x795a, 0x69b6, 0x789b, 0x0060, 0x78ab, 0x0000,
-	0x789b, 0x0061, 0x6818, 0xc0fd, 0x681a, 0x78aa, 0x8008, 0x810c,
-	0x0040, 0x3beb, 0xa18c, 0x00f8, 0x00c0, 0x3beb, 0x157e, 0x137e,
-	0x147e, 0x017e, 0x3208, 0xa18c, 0x0300, 0x0040, 0x387f, 0x007e,
-	0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x387b, 0x20a1,
-	0x012b, 0x0078, 0x3881, 0x20a1, 0x022b, 0x0078, 0x3881, 0x20a1,
-	0x012b, 0x017f, 0x789b, 0x0000, 0x8000, 0x80ac, 0xad80, 0x000b,
-	0x2098, 0x53a6, 0x147f, 0x137f, 0x157f, 0x6814, 0xc0fc, 0x8007,
-	0x7882, 0x0078, 0x40cf, 0x6818, 0xd0fc, 0x0040, 0x3899, 0x681b,
-	0x0008, 0x6820, 0xc0ad, 0x6822, 0x1078, 0x3eb6, 0x781b, 0x00e1,
-	0x007c, 0x2300, 0x0079, 0x38a4, 0x38a9, 0x397b, 0x38a7, 0x1078,
-	0x28ec, 0x7cd8, 0x7ddc, 0x7fd0, 0x82ff, 0x00c0, 0x38d1, 0x7200,
-	0xa286, 0x0003, 0x0040, 0x32d2, 0x71d4, 0xd1b4, 0x0078, 0x38d4,
-	0x0040, 0x38d4, 0x0d7e, 0x783b, 0x8800, 0x781b, 0x004c, 0x70bc,
-	0xa06d, 0x68b4, 0xc0a5, 0x785a, 0x6894, 0x78d6, 0x78de, 0x6898,
-	0x78d2, 0x78da, 0xc1b4, 0x71d6, 0x7003, 0x0030, 0x0d7f, 0x0078,
-	0x38d8, 0x7200, 0x0078, 0x38d8, 0x783b, 0x1800, 0x781b, 0x004a,
-	0xa284, 0x000f, 0x0079, 0x38dc, 0x3966, 0x391a, 0x38e6, 0x3300,
-	0x38e4, 0x3966, 0x38e4, 0x38e4, 0x1078, 0x28ec, 0x681c, 0xd0ec,
-	0x0040, 0x38ed, 0x6008, 0xc08d, 0x600a, 0x6920, 0xc185, 0x6922,
-	0x6800, 0x6006, 0xa005, 0x00c0, 0x38f6, 0x6002, 0x6008, 0xc0d4,
-	0x600a, 0x681c, 0xa084, 0x000e, 0x00c0, 0x390a, 0xb284, 0x0300,
-	0x0040, 0x3906, 0x2009, 0x90c0, 0x0078, 0x390f, 0x2009, 0x91d0,
-	0x0078, 0x390f, 0x7030, 0x68ba, 0x7140, 0x70cc, 0xa108, 0x2104,
-	0x6802, 0x2d0a, 0x715e, 0xd6dc, 0x00c0, 0x391a, 0xc6fc, 0x6eb6,
-	0x0078, 0x3966, 0x6eb6, 0xa684, 0x0060, 0x0040, 0x3966, 0xd6dc,
-	0x00c0, 0x392d, 0xa684, 0x7fff, 0x68b6, 0x6894, 0x68a6, 0x6898,
-	0x68aa, 0x1078, 0x4326, 0x0078, 0x3966, 0xd6ac, 0x0040, 0x3939,
-	0xa006, 0x1078, 0x4326, 0x2408, 0x2510, 0x69aa, 0x6aa6, 0x0078,
-	0x3949, 0x2408, 0x2510, 0x2700, 0x801b, 0x00c8, 0x3940, 0x8000,
-	0xa084, 0x003f, 0xa108, 0xa291, 0x0000, 0x69aa, 0x6aa6, 0x1078,
-	0x4326, 0xd6fc, 0x0040, 0x3966, 0xa684, 0x7fff, 0x68b6, 0x2510,
-	0x2408, 0xd6ac, 0x00c0, 0x395e, 0x2700, 0x801b, 0x00c8, 0x3959,
-	0x8000, 0xa084, 0x003f, 0xa108, 0xa291, 0x0000, 0x6b98, 0x2100,
-	0xa302, 0x68b2, 0x6b94, 0x2200, 0xa303, 0x68ae, 0x7000, 0xa086,
-	0x0030, 0x00c0, 0x2946, 0x7003, 0x0002, 0x70bc, 0xa06d, 0x68bc,
-	0x7042, 0x70b8, 0xa065, 0x68c0, 0x705a, 0x2d00, 0x704e, 0xad80,
-	0x0009, 0x7046, 0x007c, 0xa586, 0x8800, 0x00c0, 0x3988, 0x7003,
-	0x0000, 0x6018, 0x8001, 0x601a, 0x6008, 0xa084, 0xfbef, 0x600a,
-	0x0078, 0x3ea7, 0x7047, 0x0000, 0xa282, 0x0006, 0x0050, 0x3992,
-	0x1078, 0x28ec, 0x2300, 0x0079, 0x3995, 0x3998, 0x39cf, 0x3a01,
-	0x2200, 0x0079, 0x399b, 0x39a1, 0x3ea7, 0x39a3, 0x39a1, 0x3a38,
-	0x3a9b, 0x1078, 0x28ec, 0x7003, 0x0005, 0xb284, 0x0300, 0x0040,
-	0x39ad, 0x2001, 0x91e0, 0x0078, 0x39af, 0x2001, 0x9212, 0x2068,
+	0x32fb, 0x1078, 0x290c, 0x7aa8, 0xa294, 0x00ff, 0x78a8, 0xa084,
+	0x00ff, 0xa08a, 0x0004, 0x00c8, 0x4040, 0x0079, 0x3307, 0x4040,
+	0x3dce, 0x4040, 0x3f41, 0xa282, 0x0000, 0x00c0, 0x3311, 0x1078,
+	0x290c, 0x1078, 0x4051, 0x781b, 0x0075, 0x007c, 0xa282, 0x0003,
+	0x00c0, 0x331c, 0x1078, 0x290c, 0xd4fc, 0x00c0, 0x333c, 0x7064,
+	0xa005, 0x0040, 0x3325, 0x1078, 0x290c, 0x6f14, 0x7776, 0xa7bc,
+	0x8f00, 0x1078, 0x4187, 0x6008, 0xa085, 0x0021, 0x600a, 0x8738,
+	0xa784, 0x001f, 0x00c0, 0x3329, 0x1078, 0x4055, 0x7067, 0x0002,
+	0x701f, 0x0009, 0x0078, 0x333e, 0x1078, 0x4064, 0x781b, 0x0075,
+	0x007c, 0xa282, 0x0004, 0x0050, 0x3347, 0x1078, 0x290c, 0x2300,
+	0x0079, 0x334a, 0x334d, 0x350d, 0x3550, 0xa286, 0x0003, 0x0040,
+	0x3385, 0x7200, 0x7cd8, 0x7ddc, 0x7fd0, 0x71d4, 0xd1bc, 0x00c0,
+	0x337d, 0xd1b4, 0x0040, 0x337d, 0x7868, 0xa084, 0x00ff, 0x00c0,
+	0x337d, 0xa282, 0x0002, 0x00c8, 0x337d, 0x0d7e, 0x783b, 0x8300,
+	0x781b, 0x004c, 0x70bc, 0xa06d, 0x68b4, 0x785a, 0x6894, 0x78d6,
+	0x78de, 0x6898, 0x78d2, 0x78da, 0xc1b4, 0x71d6, 0x7003, 0x0030,
+	0x0d7f, 0x2001, 0x0000, 0x0078, 0x3389, 0x783b, 0x1300, 0x781b,
+	0x004a, 0x2001, 0x0000, 0x0078, 0x3389, 0x7200, 0x7cd8, 0x7ddc,
+	0x7fd0, 0x704a, 0x68a0, 0xd0ec, 0x0040, 0x3391, 0x6008, 0xc08d,
+	0x600a, 0xa284, 0x000f, 0x0079, 0x3395, 0x34ed, 0x33a2, 0x339f,
+	0x3653, 0x36df, 0x2966, 0x339d, 0x339d, 0x1078, 0x290c, 0x6008,
+	0xc0d4, 0x600a, 0xd6e4, 0x0040, 0x33aa, 0x7048, 0xa086, 0x0014,
+	0x00c0, 0x33ca, 0x1078, 0x44fb, 0x2009, 0x0000, 0x6818, 0xd0fc,
+	0x0040, 0x33b3, 0x7048, 0xa086, 0x0014, 0x0040, 0x33c4, 0x6818,
+	0xa086, 0x0008, 0x00c0, 0x34a5, 0x7858, 0xd09c, 0x0040, 0x34a5,
+	0x6820, 0xd0ac, 0x0040, 0x34a5, 0x681b, 0x0014, 0x2009, 0x0002,
+	0x0078, 0x3409, 0x7868, 0xa08c, 0x00ff, 0x0040, 0x3409, 0xa186,
+	0x0008, 0x00c0, 0x33e0, 0x6008, 0xc0a4, 0x600a, 0x1078, 0x3cf5,
+	0x0040, 0x3409, 0x1078, 0x3d73, 0x1078, 0x44fb, 0x0078, 0x33f1,
+	0xa186, 0x0028, 0x00c0, 0x3409, 0x6018, 0xa005, 0x0040, 0x33d3,
+	0x8001, 0x0040, 0x33d3, 0x8001, 0x0040, 0x33d3, 0x601e, 0x0078,
+	0x33d3, 0x6820, 0xd084, 0x0040, 0x2966, 0xc084, 0x6822, 0x1078,
+	0x2a6d, 0x705c, 0x0c7e, 0x2060, 0x6800, 0x6002, 0x0c7f, 0x6004,
+	0x6802, 0xa005, 0x2d00, 0x00c0, 0x3406, 0x6002, 0x6006, 0x0078,
+	0x2966, 0x017e, 0x81ff, 0x00c0, 0x3453, 0x7000, 0xa086, 0x0030,
+	0x0040, 0x3453, 0x71d4, 0xd1bc, 0x00c0, 0x3453, 0xd1b4, 0x00c0,
+	0x343a, 0x7060, 0xa005, 0x00c0, 0x3453, 0x70a4, 0xa086, 0x0001,
+	0x0040, 0x3453, 0x7003, 0x0000, 0x047e, 0x057e, 0x077e, 0x067e,
+	0x0c7e, 0x0d7e, 0x1078, 0x298f, 0x0d7f, 0x0c7f, 0x067f, 0x077f,
+	0x057f, 0x047f, 0x71d4, 0xd1b4, 0x00c0, 0x3453, 0x7003, 0x0040,
+	0x0078, 0x3453, 0x1078, 0x42e9, 0x00c0, 0x3453, 0x781b, 0x005b,
+	0x0d7e, 0x70bc, 0xa06d, 0x68b4, 0x785a, 0x6894, 0x78d6, 0x78de,
+	0x6898, 0x78d2, 0x78da, 0xc1b4, 0x71d6, 0x7003, 0x0030, 0x7808,
+	0xc08d, 0x780a, 0x0d7f, 0x1078, 0x358a, 0x017f, 0x81ff, 0x0040,
+	0x34a5, 0xa684, 0xdf00, 0x681e, 0x682b, 0x0000, 0x6f14, 0xa186,
+	0x0002, 0x00c0, 0x34a6, 0x6818, 0xa086, 0x0014, 0x00c0, 0x346f,
+	0x2008, 0xd6e4, 0x0040, 0x346f, 0x7868, 0xa08c, 0x00ff, 0x1078,
+	0x2a5b, 0x1078, 0x2a7c, 0x6820, 0xd0dc, 0x00c0, 0x34a6, 0x8717,
+	0xa294, 0x000f, 0x8213, 0x8213, 0x8213, 0xb284, 0x0300, 0x0040,
+	0x3485, 0xa290, 0x51c0, 0x0078, 0x3487, 0xa290, 0x5240, 0xa290,
+	0x0000, 0x221c, 0xd3c4, 0x00c0, 0x348f, 0x0078, 0x3495, 0x8210,
+	0x2204, 0xa085, 0x0018, 0x2012, 0x8211, 0xd3d4, 0x0040, 0x34a0,
+	0x68a0, 0xd0c4, 0x00c0, 0x34a0, 0x1078, 0x3604, 0x0078, 0x2966,
+	0x6008, 0xc08d, 0x600a, 0x0078, 0x34a6, 0x692a, 0x6916, 0x6818,
+	0xd0fc, 0x0040, 0x34ad, 0x7048, 0x681a, 0xa68c, 0xdf00, 0x691e,
+	0x6410, 0x84ff, 0x0040, 0x34c2, 0x2009, 0x4d02, 0x2104, 0x8001,
+	0x200a, 0x8421, 0x6412, 0x00c0, 0x34c2, 0x2021, 0x4d04, 0x2404,
+	0xc0a5, 0x2022, 0x6018, 0xa005, 0x0040, 0x34ca, 0x8001, 0x601a,
+	0x00c0, 0x34cd, 0x6008, 0xc0a4, 0x600a, 0x6820, 0xd084, 0x00c0,
+	0x34d9, 0x6800, 0xa005, 0x00c0, 0x34d6, 0x6002, 0x6006, 0x0078,
+	0x34dd, 0x705c, 0x2060, 0x6800, 0x6002, 0x2061, 0x4d00, 0x6887,
+	0x0103, 0x2d08, 0x206b, 0x0000, 0x6068, 0xa005, 0x616a, 0x0040,
+	0x34ec, 0x2d02, 0x0078, 0x34ed, 0x616e, 0x7200, 0xa286, 0x0030,
+	0x0040, 0x34fd, 0xa286, 0x0040, 0x00c0, 0x2966, 0x7003, 0x0002,
+	0x704c, 0x2068, 0x68c4, 0x2060, 0x007c, 0x7003, 0x0002, 0x70bc,
+	0xa06d, 0x68bc, 0x7042, 0x70b8, 0xa065, 0x68c0, 0x705a, 0x2d00,
+	0x704e, 0xad80, 0x0009, 0x7046, 0x007c, 0xa282, 0x0004, 0x0048,
+	0x3513, 0x1078, 0x290c, 0x2200, 0x0079, 0x3516, 0x351a, 0x352b,
+	0x3538, 0x352b, 0xa586, 0x1300, 0x0040, 0x352b, 0xa586, 0x8300,
+	0x00c0, 0x3511, 0x7003, 0x0000, 0x6018, 0x8001, 0x601a, 0x6008,
+	0xa084, 0xfbef, 0x600a, 0x7000, 0xa086, 0x0005, 0x0040, 0x3535,
+	0x1078, 0x4051, 0x781b, 0x0075, 0x007c, 0x781b, 0x0076, 0x007c,
+	0x7890, 0x8007, 0x8001, 0xa084, 0x0007, 0xa080, 0x0018, 0x789a,
+	0x79a8, 0xa18c, 0x00ff, 0xa186, 0x0003, 0x0040, 0x354d, 0xa186,
+	0x0000, 0x0040, 0x354d, 0x0078, 0x4040, 0x781b, 0x0076, 0x007c,
+	0x6820, 0xc095, 0x6822, 0x82ff, 0x00c0, 0x355a, 0x1078, 0x4051,
+	0x0078, 0x3561, 0x8211, 0x0040, 0x355f, 0x1078, 0x290c, 0x1078,
+	0x4064, 0x781b, 0x0075, 0x007c, 0x1078, 0x42fe, 0x7830, 0xa084,
+	0x00c0, 0x00c0, 0x3587, 0x017e, 0x3208, 0x007e, 0x2001, 0x4d04,
+	0x2004, 0xd0ec, 0x007f, 0x0040, 0x3579, 0xa18c, 0x0300, 0x0078,
+	0x357b, 0xa18c, 0x0400, 0x017f, 0x0040, 0x3582, 0x0018, 0x3587,
+	0x0078, 0x3584, 0x0028, 0x3587, 0x791a, 0xa006, 0x007c, 0xa085,
+	0x0001, 0x007c, 0xa684, 0x0060, 0x00c0, 0x3594, 0x682f, 0x0000,
+	0x6833, 0x0000, 0x0078, 0x3603, 0xd6dc, 0x00c0, 0x35ac, 0x68b4,
+	0xd0dc, 0x00c0, 0x35ac, 0x6998, 0x6a94, 0x692e, 0x6a32, 0x7048,
+	0xa005, 0x00c0, 0x35a9, 0x2200, 0xa105, 0x0040, 0x44fb, 0x704b,
+	0x0015, 0x0078, 0x44fb, 0x007c, 0xd6ac, 0x0040, 0x35d2, 0xd6f4,
+	0x0040, 0x35b8, 0x682f, 0x0000, 0x6833, 0x0000, 0x0078, 0x44fb,
+	0x68b4, 0xa084, 0x4000, 0xa635, 0xd6f4, 0x00c0, 0x35b2, 0x7048,
+	0xa005, 0x00c0, 0x35c5, 0x704b, 0x0015, 0xd6dc, 0x00c0, 0x35ce,
+	0x68b4, 0xd0dc, 0x0040, 0x35ce, 0x6ca8, 0x6da4, 0x6c2e, 0x6d32,
+	0x0078, 0x44fb, 0xd6f4, 0x0040, 0x35db, 0x682f, 0x0000, 0x6833,
+	0x0000, 0x0078, 0x44fb, 0x68b4, 0xa084, 0x4800, 0xa635, 0xd6f4,
+	0x00c0, 0x35d5, 0x7048, 0xa005, 0x00c0, 0x35e8, 0x704b, 0x0015,
+	0x2408, 0x2510, 0x2700, 0x80fb, 0x00c8, 0x35ef, 0x8000, 0xa084,
+	0x003f, 0xa108, 0xa291, 0x0000, 0x692e, 0x6a32, 0x2100, 0xa205,
+	0x00c0, 0x35fc, 0x0078, 0x44fb, 0x7000, 0xa086, 0x0006, 0x0040,
+	0x3603, 0x0078, 0x44fb, 0x007c, 0x6946, 0x6008, 0xc0cd, 0xd3cc,
+	0x0040, 0x360b, 0xc08d, 0x600a, 0x6818, 0x683a, 0x681b, 0x0006,
+	0x688f, 0x0000, 0x6893, 0x0000, 0x6a30, 0x692c, 0x6a3e, 0x6942,
+	0x682f, 0x0003, 0x6833, 0x0000, 0x6837, 0x0020, 0x6897, 0x0000,
+	0x689b, 0x0020, 0x7000, 0x0079, 0x3625, 0x2966, 0x3637, 0x362f,
+	0x362d, 0x362d, 0x362d, 0x362d, 0x362d, 0x1078, 0x290c, 0x6820,
+	0xd084, 0x00c0, 0x3637, 0x1078, 0x3d56, 0x0078, 0x363d, 0x705c,
+	0x2c50, 0x2060, 0x6800, 0x6002, 0x2a60, 0x3208, 0xa18c, 0x0300,
+	0x0040, 0x3646, 0x2021, 0x4d58, 0x0078, 0x3648, 0x2021, 0x4d98,
+	0x2404, 0xa005, 0x0040, 0x364f, 0x2020, 0x0078, 0x3648, 0x2d22,
+	0x206b, 0x0000, 0x007c, 0x1078, 0x3d5d, 0x1078, 0x3d73, 0x6008,
+	0xc0cc, 0x600a, 0x682b, 0x0000, 0x789b, 0x000e, 0x6f14, 0x6938,
+	0x691a, 0x6944, 0x6916, 0x3208, 0xa18c, 0x0300, 0x0040, 0x366c,
+	0x2009, 0x0000, 0x0078, 0x366e, 0x2009, 0x0001, 0x1078, 0x496f,
+	0xd6dc, 0x0040, 0x3676, 0x691c, 0xc1ed, 0x691e, 0x6818, 0xd0fc,
+	0x0040, 0x3685, 0x7868, 0xa08c, 0x00ff, 0x0040, 0x3683, 0x681b,
+	0x001e, 0x0078, 0x3685, 0x681b, 0x0000, 0xb284, 0x0300, 0x00c0,
+	0x368d, 0x2021, 0x4d98, 0x0078, 0x368f, 0x2021, 0x4d58, 0x6800,
+	0x2022, 0x6a3c, 0x6940, 0x6a32, 0x692e, 0x68c0, 0x2060, 0x6000,
+	0xd0a4, 0x0040, 0x36cf, 0x2041, 0x0021, 0x2049, 0x0005, 0x2051,
+	0x0020, 0x0d7e, 0x0f7e, 0x157e, 0x147e, 0x2079, 0x4d00, 0x1078,
+	0x1de6, 0x147f, 0x157f, 0x0f7f, 0x70cc, 0x2010, 0x2009, 0x0101,
+	0x027e, 0x2204, 0xa06d, 0x0040, 0x36bf, 0x6814, 0xa706, 0x0040,
+	0x36bc, 0x6800, 0x0078, 0x36b2, 0x6820, 0xc0d5, 0x6822, 0x027f,
+	0x8210, 0x8109, 0x00c0, 0x36b0, 0x0d7f, 0x7067, 0x0003, 0x707f,
+	0x0000, 0x7776, 0x7083, 0x000f, 0x71d4, 0xc1dc, 0x71d6, 0x6818,
+	0xa086, 0x0002, 0x00c0, 0x36db, 0x6817, 0x0000, 0x682b, 0x0000,
+	0x681c, 0xc0ec, 0x681e, 0x1078, 0x2013, 0x0078, 0x2966, 0x7cd8,
+	0x7ddc, 0x7fd0, 0x1078, 0x358a, 0x682b, 0x0000, 0x789b, 0x000e,
+	0x6f14, 0x1078, 0x4302, 0xa08c, 0x00ff, 0x6916, 0x6818, 0xd0fc,
+	0x0040, 0x36f4, 0x7048, 0x681a, 0xa68c, 0xdf00, 0x691e, 0x7067,
+	0x0000, 0x0078, 0x2966, 0x7000, 0xa005, 0x00c0, 0x3701, 0x0078,
+	0x2966, 0xa006, 0x1078, 0x44fb, 0x6920, 0xd1ac, 0x00c0, 0x370a,
+	0x681b, 0x0014, 0xa68c, 0xdf00, 0x691e, 0x682b, 0x0000, 0x6820,
+	0xa084, 0x00ff, 0x6822, 0x7000, 0x0079, 0x3716, 0x2966, 0x3720,
+	0x3720, 0x3723, 0x3723, 0x3723, 0x371e, 0x371e, 0x1078, 0x290c,
+	0x6818, 0x0078, 0x3385, 0x6008, 0xc0a4, 0x600a, 0x6817, 0x0000,
+	0x0078, 0x3d1b, 0x2300, 0x0079, 0x372d, 0x3730, 0x3732, 0x379d,
+	0x1078, 0x290c, 0xd6fc, 0x00c0, 0x3784, 0x7000, 0xa00d, 0x0079,
+	0x3739, 0x2966, 0x3743, 0x3743, 0x3772, 0x3743, 0x3781, 0x3741,
+	0x3741, 0x1078, 0x290c, 0xa684, 0x0060, 0x0040, 0x3772, 0xa086,
+	0x0060, 0x00c0, 0x376f, 0xc6ac, 0xc6f4, 0xc6ed, 0x7e5a, 0x681c,
+	0xc0ac, 0x681e, 0xa186, 0x0002, 0x0040, 0x3761, 0x1078, 0x44fb,
+	0x69ac, 0x68b0, 0xa115, 0x0040, 0x3761, 0x1078, 0x486c, 0x0078,
+	0x3763, 0x1078, 0x4834, 0x781b, 0x0076, 0x71d4, 0xd1b4, 0x00c0,
+	0x2962, 0x70a4, 0xa086, 0x0001, 0x00c0, 0x29ac, 0x007c, 0xd6ec,
+	0x0040, 0x374d, 0x6818, 0xd0fc, 0x0040, 0x3781, 0xd6f4, 0x00c0,
+	0x377f, 0x681b, 0x0015, 0x781b, 0x0076, 0x0078, 0x2962, 0x681b,
+	0x0007, 0x1078, 0x42a2, 0x007c, 0xc6fc, 0x7e5a, 0x7adc, 0x79d8,
+	0x78d0, 0x801b, 0x00c8, 0x378d, 0x8000, 0xa084, 0x003f, 0xa108,
+	0xa291, 0x0000, 0x6b98, 0x2100, 0xa302, 0x68b2, 0x6b94, 0x2200,
+	0xa303, 0x68ae, 0x781b, 0x0076, 0x007c, 0x1078, 0x290c, 0x2300,
+	0x0079, 0x37a2, 0x37a7, 0x37cc, 0x382b, 0x1078, 0x290c, 0x7000,
+	0x0079, 0x37aa, 0x37b2, 0x37b4, 0x37bd, 0x37b2, 0x37b2, 0x37b2,
+	0x37b2, 0x37b2, 0x1078, 0x290c, 0x69ac, 0x68b0, 0xa115, 0x0040,
+	0x37bd, 0x1078, 0x486c, 0x0078, 0x37bf, 0x1078, 0x4834, 0x681c,
+	0xc0b4, 0x681e, 0x70d4, 0xd0b4, 0x00c0, 0x2962, 0x70a4, 0xa086,
+	0x0001, 0x00c0, 0x29ac, 0x007c, 0xd6fc, 0x00c0, 0x381b, 0x7000,
+	0xa00d, 0x0079, 0x37d3, 0x2966, 0x37e3, 0x37dd, 0x3812, 0x37e3,
+	0x3818, 0x37db, 0x37db, 0x1078, 0x290c, 0x6894, 0x78d6, 0x78de,
+	0x6898, 0x78d2, 0x78da, 0xa684, 0x0060, 0x0040, 0x3812, 0xa086,
+	0x0060, 0x00c0, 0x380f, 0xa6b4, 0xbfbf, 0xc6ed, 0x7e5a, 0xa186,
+	0x0002, 0x0040, 0x37fe, 0x1078, 0x44fb, 0x69ac, 0x68b0, 0xa115,
+	0x0040, 0x37fe, 0x1078, 0x486c, 0x0078, 0x3800, 0x1078, 0x4834,
+	0x781b, 0x0076, 0x681c, 0xc0b4, 0x681e, 0x71d4, 0xd1b4, 0x00c0,
+	0x2962, 0x70a4, 0xa086, 0x0001, 0x00c0, 0x29ac, 0x007c, 0xd6ec,
+	0x0040, 0x37ed, 0x6818, 0xd0fc, 0x0040, 0x3818, 0x681b, 0x0007,
+	0x781b, 0x00f6, 0x007c, 0xc6fc, 0x7e5a, 0x7adc, 0x79d8, 0x6b98,
+	0x2100, 0xa302, 0x68b2, 0x6b94, 0x2200, 0xa303, 0x68ae, 0x79d2,
+	0x781b, 0x0076, 0x007c, 0xd6dc, 0x0040, 0x3834, 0x782b, 0x3009,
+	0x781b, 0x0076, 0x0078, 0x2962, 0x7884, 0xc0ac, 0x7886, 0x78e4,
+	0xa084, 0x0008, 0x00c0, 0x3847, 0xa484, 0x0200, 0x0040, 0x3841,
+	0xc6f5, 0xc6dd, 0x7e5a, 0x781b, 0x0076, 0x0078, 0x2962, 0x6820,
+	0xc095, 0x6822, 0x1078, 0x421b, 0xc6dd, 0x1078, 0x4051, 0x781b,
+	0x0075, 0x0078, 0x2962, 0x2300, 0x0079, 0x3856, 0x3859, 0x385b,
+	0x385d, 0x1078, 0x290c, 0x0078, 0x404a, 0xd6d4, 0x00c0, 0x3883,
+	0x79e4, 0xd1ac, 0x0040, 0x386b, 0x78ec, 0xa084, 0x0003, 0x0040,
+	0x386b, 0x782b, 0x3009, 0x789b, 0x0060, 0x78ab, 0x0000, 0xa684,
+	0xfffb, 0x785a, 0x79e4, 0xd1ac, 0x0040, 0x387b, 0x78ec, 0xa084,
+	0x0003, 0x00c0, 0x387f, 0x2001, 0x0014, 0x0078, 0x3385, 0xa184,
+	0x0007, 0x0079, 0x38b9, 0x7a90, 0xa294, 0x0007, 0x789b, 0x0060,
+	0x79a8, 0x81ff, 0x0040, 0x38b7, 0x789b, 0x0010, 0x7ba8, 0xa384,
+	0x0001, 0x00c0, 0x38aa, 0x7ba8, 0x7ba8, 0xa386, 0x0001, 0x00c0,
+	0x389d, 0x2009, 0xfff7, 0x0078, 0x38a3, 0xa386, 0x0003, 0x00c0,
+	0x38aa, 0x2009, 0xffef, 0x0c7e, 0x7058, 0x2060, 0x6004, 0xa104,
+	0x6006, 0x0c7f, 0x789b, 0x0060, 0x78ab, 0x0000, 0xa684, 0xfffb,
+	0x785a, 0x782b, 0x3009, 0x6920, 0xa18c, 0xfcff, 0x6922, 0x0078,
+	0x4296, 0x302e, 0x3038, 0x38c3, 0x38c9, 0x38c1, 0x38c1, 0x4296,
+	0x4296, 0x1078, 0x290c, 0x6920, 0xa18c, 0xfcff, 0x6922, 0x0078,
+	0x429c, 0x6920, 0xa18c, 0xfcff, 0x6922, 0x0078, 0x4296, 0x79e4,
+	0xa184, 0x0030, 0x0040, 0x38d9, 0x78ec, 0xa084, 0x0003, 0x00c0,
+	0x390d, 0x7000, 0xa086, 0x0004, 0x00c0, 0x38f3, 0x7064, 0xa086,
+	0x0002, 0x00c0, 0x38e9, 0x2011, 0x0002, 0x2019, 0x0000, 0x0078,
+	0x2eba, 0x7064, 0xa086, 0x0006, 0x0040, 0x38e3, 0x7064, 0xa086,
+	0x0004, 0x0040, 0x38e3, 0x7000, 0xa086, 0x0000, 0x0040, 0x2962,
+	0x6920, 0xa184, 0x0420, 0x0040, 0x3902, 0xc1d4, 0x6922, 0x6818,
+	0x0078, 0x3385, 0x6818, 0xa08e, 0x0002, 0x0040, 0x390b, 0xc0fd,
+	0x681a, 0x2001, 0x0014, 0x0078, 0x3385, 0xa184, 0x0007, 0x0079,
+	0x3911, 0x4296, 0x4296, 0x3919, 0x4296, 0x42de, 0x42de, 0x4296,
+	0x4296, 0xd6bc, 0x0040, 0x395b, 0x7184, 0x81ff, 0x0040, 0x395b,
+	0xa182, 0x000d, 0x00d0, 0x3928, 0x7087, 0x0000, 0x0078, 0x392d,
+	0xa182, 0x000c, 0x7086, 0x2009, 0x000c, 0x789b, 0x0061, 0x79aa,
+	0x157e, 0x137e, 0x147e, 0x7088, 0x8114, 0xa210, 0x728a, 0xa080,
+	0x000b, 0xad00, 0x2098, 0xb284, 0x0300, 0x0040, 0x394f, 0x007e,
+	0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x394b, 0x20a1,
+	0x012b, 0x0078, 0x3951, 0x20a1, 0x022b, 0x0078, 0x3951, 0x20a1,
+	0x012b, 0x789b, 0x0000, 0x8108, 0x81ac, 0x53a6, 0x147f, 0x137f,
+	0x157f, 0x0078, 0x429c, 0xd6d4, 0x00c0, 0x39af, 0x6820, 0xd084,
+	0x0040, 0x429c, 0xa68c, 0x0060, 0xa684, 0x0060, 0x0040, 0x396d,
+	0xa086, 0x0060, 0x00c0, 0x396d, 0xc1f5, 0xc194, 0x795a, 0x69b6,
+	0x789b, 0x0060, 0x78ab, 0x0000, 0x789b, 0x0061, 0x6818, 0xc0fd,
+	0x681a, 0x78aa, 0x8008, 0x810c, 0x0040, 0x3d8c, 0xa18c, 0x00f8,
+	0x00c0, 0x3d8c, 0x157e, 0x137e, 0x147e, 0x017e, 0x3208, 0xa18c,
+	0x0300, 0x0040, 0x399b, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec,
+	0x007f, 0x0040, 0x3997, 0x20a1, 0x012b, 0x0078, 0x399d, 0x20a1,
+	0x022b, 0x0078, 0x399d, 0x20a1, 0x012b, 0x017f, 0x789b, 0x0000,
+	0x8000, 0x80ac, 0xad80, 0x000b, 0x2098, 0x53a6, 0x147f, 0x137f,
+	0x157f, 0x6814, 0xc0fc, 0x8007, 0x7882, 0x0078, 0x429c, 0x6818,
+	0xd0fc, 0x0040, 0x39b5, 0x681b, 0x0008, 0x6820, 0xc0ad, 0x6822,
+	0x1078, 0x4059, 0x781b, 0x00e7, 0x007c, 0x2300, 0x0079, 0x39c0,
+	0x39c5, 0x3a9d, 0x39c3, 0x1078, 0x290c, 0x7cd8, 0x7ddc, 0x7fd0,
+	0x82ff, 0x00c0, 0x39ee, 0x7200, 0xa286, 0x0003, 0x0040, 0x3352,
+	0x71d4, 0xd1bc, 0x00c0, 0x39f1, 0xd1b4, 0x0040, 0x39f1, 0x0d7e,
+	0x783b, 0x8800, 0x781b, 0x004c, 0x70bc, 0xa06d, 0x68b4, 0xc0a5,
+	0x785a, 0x6894, 0x78d6, 0x78de, 0x6898, 0x78d2, 0x78da, 0xc1b4,
+	0x71d6, 0x7003, 0x0030, 0x0d7f, 0x0078, 0x39f5, 0x7200, 0x0078,
+	0x39f5, 0x783b, 0x1800, 0x781b, 0x004a, 0xa284, 0x000f, 0x0079,
+	0x39f9, 0x3a88, 0x3a37, 0x3a03, 0x3381, 0x3a01, 0x3a88, 0x3a01,
+	0x3a01, 0x1078, 0x290c, 0x681c, 0xd0ec, 0x0040, 0x3a0a, 0x6008,
+	0xc08d, 0x600a, 0x6920, 0xc185, 0x6922, 0x6800, 0x6006, 0xa005,
+	0x00c0, 0x3a13, 0x6002, 0x6008, 0xc0d4, 0x600a, 0x681c, 0xa084,
+	0x000e, 0x00c0, 0x3a27, 0xb284, 0x0300, 0x0040, 0x3a23, 0x2009,
+	0x93c0, 0x0078, 0x3a2c, 0x2009, 0x94d0, 0x0078, 0x3a2c, 0x7030,
+	0x68ba, 0x7140, 0x70cc, 0xa108, 0x2104, 0x6802, 0x2d0a, 0x715e,
+	0xd6dc, 0x00c0, 0x3a37, 0xc6fc, 0x6eb6, 0x0078, 0x3a88, 0x6eb6,
+	0xa684, 0x0060, 0x00c0, 0x3a41, 0xa684, 0x7fff, 0x68b6, 0x0078,
+	0x3a88, 0xd6dc, 0x00c0, 0x3a4f, 0xa684, 0x7fff, 0x68b6, 0x6894,
+	0x68a6, 0x6898, 0x68aa, 0x1078, 0x44fb, 0x0078, 0x3a88, 0xd6ac,
+	0x0040, 0x3a5b, 0xa006, 0x1078, 0x44fb, 0x2408, 0x2510, 0x69aa,
+	0x6aa6, 0x0078, 0x3a6b, 0x2408, 0x2510, 0x2700, 0x801b, 0x00c8,
+	0x3a62, 0x8000, 0xa084, 0x003f, 0xa108, 0xa291, 0x0000, 0x69aa,
+	0x6aa6, 0x1078, 0x44fb, 0xd6fc, 0x0040, 0x3a88, 0xa684, 0x7fff,
+	0x68b6, 0x2510, 0x2408, 0xd6ac, 0x00c0, 0x3a80, 0x2700, 0x801b,
+	0x00c8, 0x3a7b, 0x8000, 0xa084, 0x003f, 0xa108, 0xa291, 0x0000,
+	0x6b98, 0x2100, 0xa302, 0x68b2, 0x6b94, 0x2200, 0xa303, 0x68ae,
+	0x7000, 0xa086, 0x0030, 0x00c0, 0x2966, 0x7003, 0x0002, 0x70bc,
+	0xa06d, 0x68bc, 0x7042, 0x70b8, 0xa065, 0x68c0, 0x705a, 0x2d00,
+	0x704e, 0xad80, 0x0009, 0x7046, 0x007c, 0xa586, 0x8800, 0x00c0,
+	0x3aaa, 0x7003, 0x0000, 0x6018, 0x8001, 0x601a, 0x6008, 0xa084,
+	0xfbef, 0x600a, 0x0078, 0x404a, 0x7047, 0x0000, 0xa282, 0x0006,
+	0x0050, 0x3ab4, 0x1078, 0x290c, 0x2300, 0x0079, 0x3ab7, 0x3aba,
+	0x3af1, 0x3b23, 0x2200, 0x0079, 0x3abd, 0x3ac3, 0x404a, 0x3ac5,
+	0x3ac3, 0x3b5a, 0x3bc2, 0x1078, 0x290c, 0x7003, 0x0005, 0xb284,
+	0x0300, 0x0040, 0x3acf, 0x2001, 0x94e0, 0x0078, 0x3ad1, 0x2001,
+	0x9512, 0x2068, 0x704e, 0x157e, 0x20a9, 0x0032, 0x2003, 0x0000,
+	0x8000, 0x00f0, 0x3ad6, 0x157f, 0xb284, 0x0300, 0x0040, 0x3ae4,
+	0x6817, 0x0000, 0x0078, 0x3ae6, 0x6817, 0x8000, 0xad80, 0x0009,
+	0x7046, 0x68b7, 0x0700, 0x6823, 0x0800, 0x6827, 0x0003, 0x0078,
+	0x4040, 0x7000, 0xa086, 0x0002, 0x00c0, 0x3b02, 0x1078, 0x3d73,
+	0x0078, 0x3afc, 0x1078, 0x44fb, 0x6008, 0xa084, 0xfbef, 0x600a,
+	0x0078, 0x3b07, 0x7000, 0xa086, 0x0003, 0x0040, 0x3afa, 0x7003,
+	0x0005, 0xb284, 0x0300, 0x0040, 0x3b11, 0x2001, 0x94e0, 0x0078,
+	0x3b13, 0x2001, 0x9512, 0x2068, 0x704e, 0xad80, 0x0009, 0x7046,
+	0x2200, 0x0079, 0x3b1b, 0x404a, 0x3b21, 0x3b21, 0x3b5a, 0x3b21,
+	0x404a, 0x1078, 0x290c, 0x7000, 0xa086, 0x0002, 0x00c0, 0x3b34,
+	0x1078, 0x3d73, 0x0078, 0x3b2e, 0x1078, 0x44fb, 0x6008, 0xa084,
+	0xfbef, 0x600a, 0x0078, 0x3b39, 0x7000, 0xa086, 0x0003, 0x0040,
+	0x3b2c, 0x7003, 0x0005, 0xb284, 0x0300, 0x0040, 0x3b43, 0x2001,
+	0x94e0, 0x0078, 0x3b45, 0x2001, 0x9512, 0x2068, 0x704e, 0xad80,
+	0x0009, 0x7046, 0x2200, 0x0079, 0x3b4d, 0x3b55, 0x3b53, 0x3b53,
+	0x3b55, 0x3b53, 0x3b55, 0x1078, 0x290c, 0x1078, 0x4064, 0x781b,
+	0x0075, 0x007c, 0x7000, 0xa086, 0x0002, 0x00c0, 0x3b6c, 0x70d4,
+	0xc0b5, 0x70d6, 0x2c00, 0x70ba, 0x2d00, 0x70be, 0x0078, 0x3b71,
+	0x1078, 0x44fb, 0x0078, 0x3b71, 0x7000, 0xa086, 0x0003, 0x0040,
+	0x3b68, 0x7003, 0x0001, 0x7a80, 0xa294, 0x0f00, 0x789b, 0x0018,
+	0x7ca8, 0xa484, 0x001f, 0xa215, 0x2069, 0x93c0, 0xb284, 0x0300,
+	0x00c0, 0x3b85, 0xc2fd, 0x2069, 0x94d0, 0x2d04, 0x2d08, 0x715e,
+	0xa06d, 0x0040, 0x3b92, 0x6814, 0xa206, 0x0040, 0x3bb2, 0x6800,
+	0x0078, 0x3b86, 0x7003, 0x0005, 0xd2fc, 0x00c0, 0x3b9b, 0x2001,
+	0x94e0, 0x0078, 0x3b9d, 0x2001, 0x9512, 0x2068, 0x704e, 0x157e,
+	0x20a9, 0x0032, 0x2003, 0x0000, 0x8000, 0x00f0, 0x3ba2, 0x157f,
+	0xad80, 0x0009, 0x7046, 0x6a16, 0x68b7, 0x0700, 0x6823, 0x0800,
+	0x6827, 0x0003, 0x6eb4, 0x7e5a, 0x6920, 0xa184, 0x0c00, 0x0040,
+	0x3c3c, 0x681b, 0x0005, 0xc1ad, 0xc1d4, 0x6922, 0x1078, 0x4059,
+	0x0078, 0x3c3c, 0x7200, 0xa286, 0x0002, 0x00c0, 0x3bd4, 0x70d4,
+	0xc0b5, 0x70d6, 0x2c00, 0x70ba, 0x2d00, 0x70be, 0x0078, 0x3bd8,
+	0x1078, 0x44fb, 0x0078, 0x3bd8, 0xa286, 0x0003, 0x0040, 0x3bd0,
+	0x7003, 0x0001, 0x7a80, 0xa294, 0x0f00, 0x789b, 0x0018, 0x7ca8,
+	0xa484, 0x001f, 0xa215, 0xb284, 0x0300, 0x00c0, 0x3be8, 0xc2fd,
+	0x79a8, 0x79a8, 0xa18c, 0x00ff, 0x70cc, 0xa168, 0x2d04, 0x2d08,
+	0x715e, 0xa06d, 0x0040, 0x3bfb, 0x6814, 0xa206, 0x0040, 0x3c24,
+	0x6800, 0x0078, 0x3bef, 0x7003, 0x0005, 0xb284, 0x0300, 0x0040,
+	0x3c05, 0x2001, 0x94e0, 0x0078, 0x3c07, 0x2001, 0x9512, 0x2068,
 	0x704e, 0x157e, 0x20a9, 0x0032, 0x2003, 0x0000, 0x8000, 0x00f0,
-	0x39b4, 0x157f, 0xb284, 0x0300, 0x0040, 0x39c2, 0x6817, 0x0000,
-	0x0078, 0x39c4, 0x6817, 0x8000, 0xad80, 0x0009, 0x7046, 0x68b7,
-	0x0700, 0x6823, 0x0800, 0x6827, 0x0003, 0x0078, 0x3e9d, 0x7000,
-	0xa086, 0x0002, 0x00c0, 0x39e0, 0x1078, 0x3bd2, 0x0078, 0x39da,
-	0x1078, 0x4326, 0x6008, 0xa084, 0xfbef, 0x600a, 0x0078, 0x39e5,
-	0x7000, 0xa086, 0x0003, 0x0040, 0x39d8, 0x7003, 0x0005, 0xb284,
-	0x0300, 0x0040, 0x39ef, 0x2001, 0x91e0, 0x0078, 0x39f1, 0x2001,
-	0x9212, 0x2068, 0x704e, 0xad80, 0x0009, 0x7046, 0x2200, 0x0079,
-	0x39f9, 0x3ea7, 0x39ff, 0x39ff, 0x3a38, 0x39ff, 0x3ea7, 0x1078,
-	0x28ec, 0x7000, 0xa086, 0x0002, 0x00c0, 0x3a12, 0x1078, 0x3bd2,
-	0x0078, 0x3a0c, 0x1078, 0x4326, 0x6008, 0xa084, 0xfbef, 0x600a,
-	0x0078, 0x3a17, 0x7000, 0xa086, 0x0003, 0x0040, 0x3a0a, 0x7003,
-	0x0005, 0xb284, 0x0300, 0x0040, 0x3a21, 0x2001, 0x91e0, 0x0078,
-	0x3a23, 0x2001, 0x9212, 0x2068, 0x704e, 0xad80, 0x0009, 0x7046,
-	0x2200, 0x0079, 0x3a2b, 0x3a33, 0x3a31, 0x3a31, 0x3a33, 0x3a31,
-	0x3a33, 0x1078, 0x28ec, 0x1078, 0x3ebe, 0x781b, 0x0075, 0x007c,
-	0x7000, 0xa086, 0x0002, 0x00c0, 0x3a4a, 0x70d4, 0xc0b5, 0x70d6,
-	0x2c00, 0x70ba, 0x2d00, 0x70be, 0x0078, 0x3a4f, 0x1078, 0x4326,
-	0x0078, 0x3a4f, 0x7000, 0xa086, 0x0003, 0x0040, 0x3a46, 0x7003,
-	0x0001, 0x7a80, 0xa294, 0x0f00, 0x789b, 0x0018, 0x7ca8, 0xa484,
-	0x001f, 0xa215, 0x2069, 0x90c0, 0xb284, 0x0300, 0x00c0, 0x3a63,
-	0xc2fd, 0x2069, 0x91d0, 0x2d04, 0x2d08, 0x715e, 0xa06d, 0x0040,
-	0x3a70, 0x6814, 0xa206, 0x0040, 0x3a90, 0x6800, 0x0078, 0x3a64,
-	0x7003, 0x0005, 0xd2fc, 0x00c0, 0x3a79, 0x2001, 0x91e0, 0x0078,
-	0x3a7b, 0x2001, 0x9212, 0x2068, 0x704e, 0x157e, 0x20a9, 0x0032,
-	0x2003, 0x0000, 0x8000, 0x00f0, 0x3a80, 0x157f, 0xad80, 0x0009,
-	0x7046, 0x6a16, 0x68b7, 0x0700, 0x6823, 0x0800, 0x6827, 0x0003,
-	0x6eb4, 0x7e5a, 0x6820, 0xa084, 0x0c00, 0x0040, 0x3b10, 0x1078,
-	0x3eb6, 0x0078, 0x3b10, 0x7200, 0xa286, 0x0002, 0x00c0, 0x3aad,
-	0x70d4, 0xc0b5, 0x70d6, 0x2c00, 0x70ba, 0x2d00, 0x70be, 0x0078,
-	0x3ab1, 0x1078, 0x4326, 0x0078, 0x3ab1, 0xa286, 0x0003, 0x0040,
-	0x3aa9, 0x7003, 0x0001, 0x7a80, 0xa294, 0x0f00, 0x789b, 0x0018,
-	0x7ca8, 0xa484, 0x001f, 0xa215, 0xb284, 0x0300, 0x00c0, 0x3ac1,
-	0xc2fd, 0x79a8, 0x79a8, 0xa18c, 0x00ff, 0x70cc, 0xa168, 0x2d04,
-	0x2d08, 0x715e, 0xa06d, 0x0040, 0x3ad4, 0x6814, 0xa206, 0x0040,
-	0x3afd, 0x6800, 0x0078, 0x3ac8, 0x7003, 0x0005, 0xb284, 0x0300,
-	0x0040, 0x3ade, 0x2001, 0x91e0, 0x0078, 0x3ae0, 0x2001, 0x9212,
-	0x2068, 0x704e, 0x157e, 0x20a9, 0x0032, 0x2003, 0x0000, 0x8000,
-	0x00f0, 0x3ae5, 0x157f, 0xb284, 0x0300, 0x0040, 0x3af2, 0xc2fc,
-	0x0078, 0x3af3, 0xc2fd, 0x6a16, 0xad80, 0x0009, 0x7046, 0x68b7,
-	0x0700, 0x6823, 0x0800, 0x6827, 0x0003, 0x6eb4, 0x6820, 0xa084,
-	0x0c00, 0x0040, 0x3b10, 0xd0dc, 0x0040, 0x3b0a, 0x1078, 0x3eba,
-	0x0078, 0x3b10, 0x1078, 0x3eb6, 0x707f, 0x0000, 0x0078, 0x3b10,
-	0xa6ac, 0x0060, 0x0040, 0x3b4e, 0x6b98, 0x6c94, 0x69ac, 0x68b0,
-	0xa105, 0x00c0, 0x3b33, 0x7bd2, 0x7bda, 0x7cd6, 0x7cde, 0xa6b4,
-	0xb7ff, 0xa586, 0x0060, 0x0040, 0x3b4e, 0xc6ed, 0x7e5a, 0x2009,
-	0x0076, 0xd69c, 0x0040, 0x3b2e, 0x2009, 0x0075, 0x791a, 0x1078,
-	0x45f7, 0x0078, 0x3b57, 0x68b0, 0xa31a, 0x2100, 0xa423, 0x2400,
-	0xa305, 0x0040, 0x3b4e, 0x7bd2, 0x7bda, 0x7cd6, 0x7cde, 0x68b0,
-	0xc6f4, 0x7e5a, 0x2011, 0x0076, 0xd69c, 0x0040, 0x3b49, 0x2011,
-	0x0075, 0x7a1a, 0x1078, 0x462d, 0x0078, 0x3b57, 0x7e5a, 0x2009,
-	0x0076, 0xd69c, 0x0040, 0x3b56, 0x2009, 0x0075, 0x791a, 0x68c0,
-	0x705a, 0x2d00, 0x704e, 0x68c4, 0x2060, 0x71d4, 0xd1b4, 0x00c0,
-	0x2942, 0x2300, 0xa405, 0x0040, 0x2942, 0x70a4, 0xa086, 0x0001,
-	0x00c0, 0x2989, 0x007c, 0x6020, 0xa005, 0x0040, 0x3b79, 0x8001,
-	0x6022, 0x6008, 0xa085, 0x0008, 0x600a, 0x700f, 0x0100, 0x702c,
-	0x6026, 0x007c, 0xa006, 0x1078, 0x4326, 0x6817, 0x0000, 0x681b,
-	0x0001, 0x6823, 0x0040, 0x681f, 0x0100, 0x7000, 0xa084, 0x000f,
-	0x0079, 0x3b8a, 0x2946, 0x3b94, 0x3b94, 0x3bb1, 0x3b9c, 0x2946,
-	0x3b92, 0x3b92, 0x1078, 0x28ec, 0x1078, 0x3bbc, 0x1078, 0x3bb5,
-	0x1078, 0x202a, 0x0078, 0x2946, 0x7064, 0x7067, 0x0000, 0x7083,
-	0x0000, 0x0079, 0x3ba3, 0x3bad, 0x3bad, 0x3bab, 0x3bab, 0x3bab,
-	0x3bad, 0x3bab, 0x3bad, 0x0079, 0x2e5c, 0x7067, 0x0000, 0x0078,
-	0x2946, 0x681b, 0x0000, 0x0078, 0x35ae, 0x6800, 0xa005, 0x00c0,
-	0x3bba, 0x6002, 0x6006, 0x007c, 0x6410, 0x84ff, 0x0040, 0x3bce,
-	0x2009, 0x4a02, 0x2104, 0x8001, 0x200a, 0x8421, 0x6412, 0x00c0,
-	0x3bce, 0x2021, 0x4a04, 0x2404, 0xc0a5, 0x2022, 0x6008, 0xc0a4,
-	0x600a, 0x007c, 0x6018, 0xa005, 0x0040, 0x3bd8, 0x8001, 0x601a,
-	0x007c, 0x1078, 0x4131, 0x681b, 0x0018, 0x0078, 0x3c1a, 0x1078,
-	0x4131, 0x681b, 0x0019, 0x0078, 0x3c1a, 0x1078, 0x4131, 0x681b,
-	0x001a, 0x0078, 0x3c1a, 0x1078, 0x4131, 0x681b, 0x0003, 0x0078,
-	0x3c1a, 0x7774, 0x1078, 0x3fe1, 0x7178, 0xa18c, 0x00ff, 0x3210,
-	0xa294, 0x0300, 0x0040, 0x3c00, 0xa1e8, 0x8fc0, 0x0078, 0x3c02,
-	0xa1e8, 0x90d0, 0x2d04, 0x2d08, 0x2068, 0xa005, 0x00c0, 0x3c0a,
-	0x0078, 0x2946, 0x6814, 0xc0fc, 0x7274, 0xc2fc, 0xa206, 0x0040,
-	0x3c14, 0x6800, 0x0078, 0x3c03, 0x6800, 0x200a, 0x681b, 0x0005,
-	0x707f, 0x0000, 0x1078, 0x3bbc, 0x6820, 0xd084, 0x00c0, 0x3c22,
-	0x1078, 0x3bb5, 0x1078, 0x3bd2, 0x681f, 0x0000, 0x6823, 0x0020,
-	0x1078, 0x202a, 0x0078, 0x2946, 0xa282, 0x0003, 0x00c0, 0x3e9d,
-	0x7da8, 0xa5ac, 0x00ff, 0x7ea8, 0xa6b4, 0x00ff, 0x6920, 0xc1bd,
-	0x6922, 0xd1c4, 0x0040, 0x3c86, 0xc1c4, 0x6922, 0xa6b4, 0x00ff,
-	0x0040, 0x3c73, 0xa682, 0x000c, 0x0048, 0x3c4a, 0x0040, 0x3c4a,
-	0x2031, 0x000c, 0x2500, 0xa086, 0x000a, 0x0040, 0x3c51, 0x852b,
-	0x852b, 0x1078, 0x3f73, 0x0040, 0x3c59, 0x1078, 0x3d55, 0x0078,
-	0x3c7c, 0x1078, 0x3f2e, 0x0c7e, 0x2960, 0x6004, 0xa084, 0xfff5,
-	0x6006, 0x1078, 0x3d8a, 0x0c7f, 0x6920, 0xc1c5, 0x6922, 0x7e58,
-	0xc695, 0x7e5a, 0xd6d4, 0x00c0, 0x3c70, 0x781b, 0x0061, 0x007c,
-	0x781b, 0x0075, 0x007c, 0x0c7e, 0x2960, 0x6004, 0xa084, 0xfff5,
-	0x6006, 0x1078, 0x3d8a, 0x0c7f, 0x7e58, 0xd6d4, 0x00c0, 0x3c83,
-	0x781b, 0x0064, 0x007c, 0x781b, 0x0076, 0x007c, 0x0c7e, 0x7058,
-	0x2060, 0x6100, 0xd1e4, 0x0040, 0x3ccf, 0x6208, 0x8217, 0xa294,
-	0x00ff, 0xa282, 0x000c, 0x0048, 0x3c99, 0x0040, 0x3c99, 0x2011,
-	0x000c, 0x2600, 0xa202, 0x00c8, 0x3c9e, 0x2230, 0x6208, 0xa294,
-	0x00ff, 0x2001, 0x4a05, 0x2004, 0xd0e4, 0x00c0, 0x3cb3, 0x78ec,
-	0xd0e4, 0x0040, 0x3cb3, 0xa282, 0x000a, 0x00c8, 0x3cb9, 0x2011,
-	0x000a, 0x0078, 0x3cb9, 0xa282, 0x000c, 0x00c8, 0x3cb9, 0x2011,
-	0x000c, 0x2200, 0xa502, 0x00c8, 0x3cbe, 0x2228, 0x1078, 0x3f32,
-	0x2500, 0xa086, 0x000a, 0x0040, 0x3cc7, 0x852b, 0x852b, 0x1078,
-	0x3f73, 0x0040, 0x3ccf, 0x1078, 0x3d55, 0x0078, 0x3cd3, 0x1078,
-	0x3f2e, 0x1078, 0x3d8a, 0x7858, 0xc095, 0x785a, 0x0c7f, 0x781b,
-	0x0075, 0x007c, 0x0c7e, 0x2960, 0x6000, 0xd0e4, 0x00c0, 0x3cf1,
-	0x6010, 0xa084, 0x000f, 0x00c0, 0x3ceb, 0x6104, 0xa18c, 0xfff5,
-	0x6106, 0x0c7f, 0x007c, 0x2011, 0x0032, 0x2019, 0x0000, 0x0078,
-	0x3d1c, 0x68a0, 0xd0cc, 0x00c0, 0x3ceb, 0x6208, 0xa294, 0x00ff,
-	0x2001, 0x4a05, 0x2004, 0xd0e4, 0x00c0, 0x3d0a, 0x78ec, 0xd0e4,
-	0x0040, 0x3d0a, 0xa282, 0x000a, 0x00c0, 0x3d0a, 0x2011, 0x000a,
-	0x0078, 0x3d10, 0xa282, 0x000c, 0x00c8, 0x3d10, 0x2011, 0x000c,
-	0x6308, 0x831f, 0xa39c, 0x00ff, 0xa382, 0x000c, 0x0048, 0x3d1c,
-	0x0040, 0x3d1c, 0x2019, 0x000c, 0x78ab, 0x0001, 0x78ab, 0x0003,
-	0x78ab, 0x0001, 0x7aaa, 0x7baa, 0xa8c0, 0x0005, 0x6820, 0xc0c5,
-	0x6822, 0x70d4, 0xd0b4, 0x0040, 0x3d38, 0xc0b4, 0x70d6, 0x70b8,
-	0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a,
-	0x0c7f, 0x007c, 0x0c7e, 0x2960, 0x6104, 0xa18c, 0xfff5, 0x6106,
-	0x2011, 0x0032, 0x2019, 0x0000, 0x0078, 0x3d46, 0x78ab, 0x0001,
+	0x3c0c, 0x157f, 0xb284, 0x0300, 0x0040, 0x3c19, 0xc2fc, 0x0078,
+	0x3c1a, 0xc2fd, 0x6a16, 0xad80, 0x0009, 0x7046, 0x68b7, 0x0700,
+	0x6823, 0x0800, 0x6827, 0x0003, 0x6eb4, 0x6920, 0xa184, 0x0c00,
+	0x0040, 0x3c3c, 0xd0dc, 0x0040, 0x3c31, 0x1078, 0x4060, 0x0078,
+	0x3c3c, 0x681b, 0x0005, 0xc1ad, 0xc1d4, 0x6922, 0x1078, 0x4059,
+	0x707f, 0x0000, 0x0078, 0x3c3c, 0xc6ec, 0xa6ac, 0x0060, 0x0040,
+	0x3c90, 0x6b98, 0x6c94, 0x69ac, 0x68b0, 0xa105, 0x00c0, 0x3c69,
+	0x7bd2, 0x7bda, 0x7cd6, 0x7cde, 0xa586, 0x0060, 0x0040, 0x3c8e,
+	0xd6f4, 0x00c0, 0x3c54, 0xc6ed, 0xa6b4, 0xb7ff, 0x7e5a, 0x2009,
+	0x0076, 0xd69c, 0x0040, 0x3c61, 0x2009, 0x0075, 0x2019, 0x0000,
+	0x2320, 0x791a, 0xd6ec, 0x0040, 0x3c99, 0x1078, 0x4834, 0x0078,
+	0x3c99, 0x68b0, 0xa31a, 0x2100, 0xa423, 0x2400, 0xa305, 0x0040,
+	0x3c90, 0x7bd2, 0x7bda, 0x7cd6, 0x7cde, 0x68b0, 0xd6f4, 0x00c0,
+	0x3c7a, 0xc6ed, 0xc6f4, 0x7e5a, 0x2011, 0x0076, 0xd69c, 0x0040,
+	0x3c86, 0x2011, 0x0075, 0x2019, 0x0000, 0x2320, 0x7a1a, 0xd6ec,
+	0x0040, 0x3c99, 0x1078, 0x486c, 0x0078, 0x3c99, 0xa6b4, 0xb7ff,
+	0x7e5a, 0x2009, 0x0076, 0xd69c, 0x0040, 0x3c98, 0x2009, 0x0075,
+	0x791a, 0x68c0, 0x705a, 0x2d00, 0x704e, 0x68c4, 0x2060, 0x71d4,
+	0x70d8, 0xa02d, 0x0040, 0x3cc1, 0xd1bc, 0x0040, 0x3cdb, 0x7a80,
+	0xa294, 0x0f00, 0x70dc, 0xa206, 0x0040, 0x3cb2, 0x78e0, 0xa504,
+	0x00c0, 0x3ce8, 0x70da, 0xc1bc, 0x71d6, 0x0078, 0x3ce8, 0x2031,
+	0x0001, 0x852c, 0x0048, 0x3cc0, 0x8633, 0x8210, 0x0078, 0x3cb9,
+	0x007c, 0x7de0, 0xa594, 0xff00, 0x0040, 0x3cce, 0x2011, 0x0008,
+	0x852f, 0x1078, 0x3cb7, 0x8637, 0x0078, 0x3cd0, 0x1078, 0x3cb7,
+	0x8217, 0x7880, 0xa084, 0x0f00, 0xa206, 0x0040, 0x3ce8, 0x72de,
+	0x76da, 0x0078, 0x3ce8, 0x7a80, 0xa294, 0x0f00, 0x70dc, 0xa236,
+	0x0040, 0x3cd8, 0x78e0, 0xa534, 0x0040, 0x3cd8, 0xc1bd, 0x71d6,
+	0xd1b4, 0x00c0, 0x2962, 0x2300, 0xa405, 0x0040, 0x2962, 0x70a4,
+	0xa086, 0x0001, 0x00c0, 0x29ac, 0x007c, 0x6020, 0xa005, 0x0040,
+	0x3d03, 0x8001, 0x6022, 0x6008, 0xa085, 0x0008, 0x600a, 0x700f,
+	0x0100, 0x702c, 0x6026, 0x007c, 0xa006, 0x1078, 0x44fb, 0x7000,
+	0xa086, 0x0002, 0x0040, 0x3d11, 0x7064, 0xa086, 0x0005, 0x00c0,
+	0x3d1b, 0x682b, 0x0000, 0x6817, 0x0000, 0x681b, 0x0001, 0x6823,
+	0x0040, 0x681f, 0x0100, 0x7000, 0xa084, 0x000f, 0x0079, 0x3d20,
+	0x2966, 0x3d30, 0x3d2a, 0x3d52, 0x3d3a, 0x2966, 0x3d28, 0x3d28,
+	0x1078, 0x290c, 0x1078, 0x3d5d, 0x1078, 0x3d56, 0x0078, 0x3d36,
+	0x1078, 0x3d5d, 0x705c, 0x2060, 0x6800, 0x6002, 0x1078, 0x2013,
+	0x0078, 0x2966, 0x7064, 0x7067, 0x0000, 0x7083, 0x0000, 0x0079,
+	0x3d41, 0x3d4e, 0x3d4e, 0x3d49, 0x3d49, 0x3d49, 0x3d4e, 0x3d49,
+	0x3d4e, 0x77d4, 0xc7dd, 0x77d6, 0x0079, 0x2ed3, 0x7067, 0x0000,
+	0x0078, 0x2966, 0x681b, 0x0000, 0x0078, 0x3653, 0x6800, 0xa005,
+	0x00c0, 0x3d5b, 0x6002, 0x6006, 0x007c, 0x6410, 0x84ff, 0x0040,
+	0x3d6f, 0x2009, 0x4d02, 0x2104, 0x8001, 0x200a, 0x8421, 0x6412,
+	0x00c0, 0x3d6f, 0x2021, 0x4d04, 0x2404, 0xc0a5, 0x2022, 0x6008,
+	0xc0a4, 0x600a, 0x007c, 0x6018, 0xa005, 0x0040, 0x3d79, 0x8001,
+	0x601a, 0x007c, 0x1078, 0x42fe, 0x681b, 0x0018, 0x0078, 0x3dbc,
+	0x1078, 0x42fe, 0x681b, 0x0019, 0x0078, 0x3dbc, 0x1078, 0x42fe,
+	0x681b, 0x001a, 0x0078, 0x3dbc, 0x1078, 0x42fe, 0x681b, 0x0003,
+	0x0078, 0x3dbc, 0x7774, 0x1078, 0x4187, 0x7178, 0xa18c, 0x00ff,
+	0x3210, 0xa294, 0x0300, 0x0040, 0x3da1, 0xa1e8, 0x92c0, 0x0078,
+	0x3da3, 0xa1e8, 0x93d0, 0x2d04, 0x2d08, 0x2068, 0xa005, 0x00c0,
+	0x3dac, 0x707e, 0x0078, 0x2966, 0x6814, 0xc0fc, 0x7274, 0xc2fc,
+	0xa206, 0x0040, 0x3db6, 0x6800, 0x0078, 0x3da4, 0x6800, 0x200a,
+	0x681b, 0x0005, 0x707f, 0x0000, 0x1078, 0x3d5d, 0x6820, 0xd084,
+	0x00c0, 0x3dc4, 0x1078, 0x3d56, 0x1078, 0x3d73, 0x681f, 0x0000,
+	0x6823, 0x0020, 0x1078, 0x2013, 0x0078, 0x2966, 0xa282, 0x0003,
+	0x00c0, 0x4040, 0x7da8, 0xa5ac, 0x00ff, 0x7ea8, 0xa6b4, 0x00ff,
+	0x6920, 0xc1bd, 0x6922, 0xd1c4, 0x0040, 0x3e28, 0xc1c4, 0x6922,
+	0xa6b4, 0x00ff, 0x0040, 0x3e15, 0xa682, 0x000c, 0x0048, 0x3dec,
+	0x0040, 0x3dec, 0x2031, 0x000c, 0x2500, 0xa086, 0x000a, 0x0040,
+	0x3df3, 0x852b, 0x852b, 0x1078, 0x4119, 0x0040, 0x3dfb, 0x1078,
+	0x3ef7, 0x0078, 0x3e1e, 0x1078, 0x40d4, 0x0c7e, 0x2960, 0x6004,
+	0xa084, 0xfff5, 0x6006, 0x1078, 0x3f2d, 0x0c7f, 0x6920, 0xc1c5,
+	0x6922, 0x7e58, 0xc695, 0x7e5a, 0xd6d4, 0x00c0, 0x3e12, 0x781b,
+	0x0061, 0x007c, 0x781b, 0x0075, 0x007c, 0x0c7e, 0x2960, 0x6004,
+	0xa084, 0xfff5, 0x6006, 0x1078, 0x3f2d, 0x0c7f, 0x7e58, 0xd6d4,
+	0x00c0, 0x3e25, 0x781b, 0x0064, 0x007c, 0x781b, 0x0076, 0x007c,
+	0x0c7e, 0x7058, 0x2060, 0x6100, 0xd1e4, 0x0040, 0x3e71, 0x6208,
+	0x8217, 0xa294, 0x00ff, 0xa282, 0x000c, 0x0048, 0x3e3b, 0x0040,
+	0x3e3b, 0x2011, 0x000c, 0x2600, 0xa202, 0x00c8, 0x3e40, 0x2230,
+	0x6208, 0xa294, 0x00ff, 0x2001, 0x4d05, 0x2004, 0xd0e4, 0x00c0,
+	0x3e55, 0x78ec, 0xd0e4, 0x0040, 0x3e55, 0xa282, 0x000a, 0x00c8,
+	0x3e5b, 0x2011, 0x000a, 0x0078, 0x3e5b, 0xa282, 0x000c, 0x00c8,
+	0x3e5b, 0x2011, 0x000c, 0x2200, 0xa502, 0x00c8, 0x3e60, 0x2228,
+	0x1078, 0x40d8, 0x2500, 0xa086, 0x000a, 0x0040, 0x3e69, 0x852b,
+	0x852b, 0x1078, 0x4119, 0x0040, 0x3e71, 0x1078, 0x3ef7, 0x0078,
+	0x3e75, 0x1078, 0x40d4, 0x1078, 0x3f2d, 0x7858, 0xc095, 0x785a,
+	0x0c7f, 0x781b, 0x0075, 0x007c, 0x0c7e, 0x2960, 0x6000, 0xd0e4,
+	0x00c0, 0x3e93, 0x6010, 0xa084, 0x000f, 0x00c0, 0x3e8d, 0x6104,
+	0xa18c, 0xfff5, 0x6106, 0x0c7f, 0x007c, 0x2011, 0x0032, 0x2019,
+	0x0000, 0x0078, 0x3ebe, 0x68a0, 0xd0cc, 0x00c0, 0x3e8d, 0x6208,
+	0xa294, 0x00ff, 0x2001, 0x4d05, 0x2004, 0xd0e4, 0x00c0, 0x3eac,
+	0x78ec, 0xd0e4, 0x0040, 0x3eac, 0xa282, 0x000b, 0x00c8, 0x3eac,
+	0x2011, 0x000a, 0x0078, 0x3eb2, 0xa282, 0x000c, 0x00c8, 0x3eb2,
+	0x2011, 0x000c, 0x6308, 0x831f, 0xa39c, 0x00ff, 0xa382, 0x000c,
+	0x0048, 0x3ebe, 0x0040, 0x3ebe, 0x2019, 0x000c, 0x78ab, 0x0001,
 	0x78ab, 0x0003, 0x78ab, 0x0001, 0x7aaa, 0x7baa, 0xa8c0, 0x0005,
-	0x6820, 0xc0c5, 0x6822, 0x0c7f, 0x007c, 0x0c7e, 0x7158, 0x2160,
-	0x2018, 0xa08c, 0x0020, 0x0040, 0x3d5e, 0xc0ac, 0x2008, 0xa084,
-	0xfff0, 0xa635, 0x7e86, 0x6018, 0x789a, 0x7eae, 0x6612, 0x78a4,
-	0xa084, 0xfff0, 0xa18c, 0x000f, 0xa105, 0xa39c, 0x0020, 0x0040,
-	0x3d73, 0xa085, 0x4000, 0xc0fc, 0xd0b4, 0x00c0, 0x3d78, 0xc0fd,
-	0x78a6, 0x6016, 0x788a, 0xa6b4, 0x000f, 0x8637, 0x8204, 0x8004,
-	0xa084, 0x00ff, 0xa605, 0x600e, 0x6004, 0xa084, 0xfff5, 0x6006,
-	0x0c7f, 0x007c, 0x0c7e, 0x7058, 0x2060, 0x6018, 0x789a, 0x78a4,
-	0xa084, 0xfff0, 0x78a6, 0x6012, 0x7884, 0xa084, 0xfff0, 0x7886,
-	0x600c, 0xa084, 0x00ff, 0x600e, 0x0c7f, 0x007c, 0xa282, 0x0002,
-	0x00c0, 0x3e9d, 0x7aa8, 0x6920, 0xc1bd, 0x6922, 0xd1cc, 0x0040,
-	0x3dd9, 0xc1cc, 0x6922, 0xa294, 0x00ff, 0xa282, 0x0002, 0x00c8,
-	0x3e9d, 0x1078, 0x3e2a, 0x1078, 0x3d8a, 0xa980, 0x0001, 0x200c,
-	0x1078, 0x3fdd, 0x1078, 0x3cda, 0x88ff, 0x0040, 0x3dcf, 0x789b,
-	0x0060, 0x2800, 0x78aa, 0x7e58, 0xc695, 0x7e5a, 0xd6d4, 0x00c0,
-	0x3dcc, 0x781b, 0x0061, 0x007c, 0x781b, 0x0075, 0x007c, 0x7e58,
-	0xd6d4, 0x00c0, 0x3dd6, 0x781b, 0x0064, 0x007c, 0x781b, 0x0076,
-	0x007c, 0xa282, 0x0002, 0x00c8, 0x3de1, 0xa284, 0x0001, 0x0040,
-	0x3dea, 0x7158, 0xa188, 0x0000, 0x210c, 0xd1ec, 0x00c0, 0x3dea,
-	0x2011, 0x0000, 0x1078, 0x3f0f, 0x1078, 0x3e2a, 0x1078, 0x3d8a,
-	0x7858, 0xc095, 0x785a, 0x781b, 0x0075, 0x007c, 0x0c7e, 0x027e,
-	0x2960, 0x6000, 0x2011, 0x0001, 0xd0ec, 0x00c0, 0x3e0b, 0x6014,
-	0xa084, 0x0040, 0x00c0, 0x3e09, 0xc1a4, 0x6106, 0xa006, 0x0078,
-	0x3e27, 0x2011, 0x0000, 0x78ab, 0x0001, 0x78ab, 0x0002, 0x78ab,
-	0x0003, 0x7aaa, 0xa8c0, 0x0004, 0x70d4, 0xd0b4, 0x0040, 0x3e23,
-	0xc0b4, 0x70d6, 0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef, 0x600a,
-	0x6018, 0x8001, 0x601a, 0x6820, 0xa085, 0x0200, 0x6822, 0x027f,
-	0x0c7f, 0x007c, 0x0c7e, 0x7058, 0x2060, 0x82ff, 0x0040, 0x3e32,
-	0x2011, 0x0040, 0x6018, 0xa080, 0x0002, 0x789a, 0x78a4, 0xa084,
-	0xffbf, 0xa205, 0xc0fc, 0xd0b4, 0x00c0, 0x3e3f, 0xc0fd, 0x78a6,
-	0x6016, 0x788a, 0x6004, 0xc0a4, 0x6006, 0x0c7f, 0x007c, 0x007e,
-	0x7000, 0xa086, 0x0003, 0x0040, 0x3e50, 0x007f, 0x0078, 0x3e53,
-	0x007f, 0x0078, 0x3e9a, 0xd6ac, 0x0040, 0x3e9a, 0x7888, 0xa084,
-	0x0040, 0x0040, 0x3e9a, 0x7bb8, 0xa384, 0x003f, 0x831b, 0x00c8,
-	0x3e62, 0x8000, 0xa005, 0x0040, 0x3e77, 0x831b, 0x00c8, 0x3e6b,
-	0x8001, 0x0040, 0x3e97, 0xd6f4, 0x0040, 0x3e77, 0x78b8, 0x801b,
-	0x00c8, 0x3e73, 0x8000, 0xa084, 0x003f, 0x00c0, 0x3e97, 0xc6f4,
-	0x7e5a, 0x79d8, 0x7adc, 0x2001, 0x0001, 0xa108, 0x00c8, 0x3e82,
-	0xa291, 0x0000, 0x79d2, 0x79da, 0x7ad6, 0x7ade, 0x1078, 0x46e5,
-	0x781b, 0x0073, 0xb284, 0x0300, 0x0040, 0x3e92, 0x2001, 0x0000,
-	0x0078, 0x3e94, 0x2001, 0x0001, 0x1078, 0x4585, 0x007c, 0x781b,
-	0x0073, 0x007c, 0x781b, 0x0076, 0x007c, 0x1078, 0x3ec2, 0x781b,
-	0x0075, 0x007c, 0x1078, 0x3eae, 0x781b, 0x0075, 0x007c, 0x6827,
-	0x0002, 0x1078, 0x3eb6, 0x781b, 0x0075, 0x007c, 0x2001, 0x0005,
-	0x0078, 0x3ec4, 0x2001, 0x000c, 0x0078, 0x3ec4, 0x2001, 0x0006,
-	0x0078, 0x3ec4, 0x2001, 0x000d, 0x0078, 0x3ec4, 0x2001, 0x0009,
-	0x0078, 0x3ec4, 0x2001, 0x0007, 0x789b, 0x007e, 0x78aa, 0xc69d,
-	0x7e5a, 0x70d4, 0xd0b4, 0x0040, 0x3eda, 0xc0b4, 0x70d6, 0x0c7e,
-	0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001,
-	0x601a, 0x0c7f, 0x007c, 0x077e, 0x873f, 0xa7bc, 0x000f, 0x873b,
-	0x873b, 0x8703, 0x017e, 0xb28c, 0x0300, 0x0040, 0x3eeb, 0xa0e0,
-	0x4ec0, 0x0078, 0x3eed, 0xa0e0, 0x4f40, 0x017f, 0xa7b8, 0x0020,
-	0x7f9a, 0x79a4, 0xa184, 0x000f, 0x0040, 0x3efd, 0xa184, 0xfff0,
-	0x78a6, 0x6012, 0x6004, 0xc09d, 0x6006, 0x8738, 0x8738, 0x7f9a,
-	0x79a4, 0xa184, 0x0040, 0x0040, 0x3f0d, 0xa184, 0xffbf, 0xc0fd,
-	0x78a6, 0x6016, 0x6004, 0xc0a5, 0x6006, 0x077f, 0x007c, 0x789b,
-	0x0010, 0x78ab, 0x0001, 0x78ab, 0x0002, 0x78ab, 0x0003, 0x7aaa,
-	0x789b, 0x0060, 0x78ab, 0x0004, 0x70d4, 0xd0b4, 0x0040, 0x3f2d,
-	0xc0b4, 0x70d6, 0x0c7e, 0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef,
-	0x600a, 0x6018, 0x8001, 0x601a, 0x0c7f, 0x007c, 0x2031, 0x0000,
-	0x2029, 0x0032, 0x789b, 0x0010, 0x78ab, 0x0001, 0x78ab, 0x0003,
-	0x78ab, 0x0001, 0x7daa, 0x7eaa, 0x789b, 0x0060, 0x78ab, 0x0005,
-	0x70d4, 0xd0b4, 0x0040, 0x3f51, 0xc0b4, 0x70d6, 0x0c7e, 0x70b8,
-	0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a,
-	0x0c7f, 0x007c, 0x157e, 0x8007, 0xa084, 0x00ff, 0x8003, 0x8003,
-	0xa080, 0x0020, 0x789a, 0x79a4, 0xa18c, 0xfff0, 0x2021, 0x3fc6,
-	0x2019, 0x0011, 0x20a9, 0x000e, 0x2011, 0x0032, 0x2404, 0xa084,
-	0xfff0, 0xa106, 0x0040, 0x3f71, 0x8420, 0x2300, 0xa210, 0x00f0,
-	0x3f66, 0x157f, 0x007c, 0x157e, 0x2001, 0x4a05, 0x2004, 0xd0e4,
-	0x00c0, 0x3fa4, 0x2021, 0x3fd4, 0x20a9, 0x0009, 0x2011, 0x0028,
-	0xa582, 0x0019, 0x0040, 0x3fba, 0x0048, 0x3fba, 0x8420, 0x95a9,
-	0x2011, 0x0032, 0xa582, 0x0032, 0x0040, 0x3fba, 0x0048, 0x3fba,
-	0x8420, 0x95a9, 0x2019, 0x000a, 0x2011, 0x0064, 0x2200, 0xa502,
-	0x0040, 0x3fba, 0x0048, 0x3fba, 0x8420, 0x2300, 0xa210, 0x00f0,
-	0x3f96, 0x157f, 0x0078, 0x3fb8, 0x2021, 0x3fc6, 0x2019, 0x0011,
-	0x20a9, 0x000e, 0x2011, 0x0032, 0x2200, 0xa502, 0x0040, 0x3fba,
-	0x0048, 0x3fba, 0x8420, 0x2300, 0xa210, 0x00f0, 0x3fac, 0x157f,
-	0xa006, 0x007c, 0x157f, 0xa582, 0x0064, 0x00c8, 0x3fc3, 0x7808,
-	0xa085, 0x0070, 0x780a, 0x2404, 0xa005, 0x007c, 0x1209, 0x3002,
-	0x3202, 0x4203, 0x4403, 0x5404, 0x5604, 0x6605, 0x6805, 0x7806,
-	0x7a06, 0x0c07, 0x0c07, 0x0e07, 0x10e1, 0x330a, 0x5805, 0x5a05,
-	0x6a06, 0x6c06, 0x7c07, 0x7e07, 0x0e00, 0x789b, 0x0010, 0xa046,
-	0x007c, 0xa784, 0x0f00, 0x800b, 0xa784, 0x001f, 0x8003, 0x8003,
-	0x8003, 0x8003, 0xa105, 0xd7fc, 0x0040, 0x3ff2, 0xa0e0, 0x6fc0,
-	0x0078, 0x3ff4, 0xa0e0, 0x4fc0, 0x007c, 0x0e7e, 0x0f7e, 0xd084,
-	0x0040, 0x4002, 0x2079, 0x0100, 0x2009, 0x4a80, 0x2071, 0x4a80,
-	0x0078, 0x4014, 0x2009, 0x4a40, 0x007e, 0x2001, 0x4a04, 0x2004,
-	0xd0ec, 0x007f, 0x0040, 0x4010, 0x2079, 0x0100, 0x0078, 0x4014,
-	0x2079, 0x0200, 0x2071, 0x4a40, 0x2091, 0x8000, 0x2104, 0xa084,
-	0x000f, 0x0079, 0x401b, 0x405d, 0x4025, 0x4025, 0x4025, 0x4025,
-	0x4025, 0x4023, 0x4023, 0x1078, 0x28ec, 0x784b, 0x0004, 0x7848,
-	0xa084, 0x0004, 0x00c0, 0x4027, 0x784b, 0x0008, 0x7848, 0xa084,
-	0x0008, 0x00c0, 0x402e, 0x68b4, 0xc0f5, 0x68b6, 0x7858, 0xc0f5,
-	0x785a, 0x7830, 0xd0bc, 0x00c0, 0x405d, 0x007e, 0x2001, 0x4a04,
-	0x2004, 0xd0ec, 0x007f, 0x0040, 0x4049, 0xb284, 0x0300, 0x0078,
-	0x404b, 0xb284, 0x0400, 0x0040, 0x4051, 0x0018, 0x405d, 0x0078,
-	0x4053, 0x0028, 0x405d, 0x681c, 0xd0ac, 0x00c0, 0x405b, 0x1078,
-	0x40d5, 0x0078, 0x405d, 0x781b, 0x00f0, 0x2091, 0x8001, 0x0f7f,
-	0x0e7f, 0x007c, 0x0c7e, 0x2001, 0x4a01, 0x2004, 0xd0ac, 0x00c0,
-	0x40c7, 0x6814, 0x8007, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003,
-	0xb28c, 0x0300, 0x0040, 0x4078, 0xa0e0, 0x4ec0, 0x0078, 0x407a,
-	0xa0e0, 0x4f40, 0x6004, 0xa084, 0x000a, 0x00c0, 0x40c7, 0x6108,
-	0xa194, 0xff00, 0x0040, 0x40c7, 0xa18c, 0x00ff, 0x2001, 0x000a,
-	0xa106, 0x0040, 0x40a6, 0x2001, 0x000c, 0xa106, 0x0040, 0x40aa,
-	0x2001, 0x0012, 0xa106, 0x0040, 0x40ae, 0x2001, 0x0014, 0xa106,
-	0x0040, 0x40b2, 0x2001, 0x0019, 0xa106, 0x0040, 0x40b6, 0x2001,
-	0x0032, 0xa106, 0x0040, 0x40ba, 0x0078, 0x40be, 0x2009, 0x000c,
-	0x0078, 0x40c0, 0x2009, 0x0012, 0x0078, 0x40c0, 0x2009, 0x0014,
-	0x0078, 0x40c0, 0x2009, 0x0019, 0x0078, 0x40c0, 0x2009, 0x0020,
-	0x0078, 0x40c0, 0x2009, 0x003f, 0x0078, 0x40c0, 0x2011, 0x0000,
-	0x2100, 0xa205, 0x600a, 0x6004, 0xa085, 0x0002, 0x6006, 0x0c7f,
-	0x007c, 0x781b, 0x0076, 0x007c, 0x781b, 0x0075, 0x007c, 0x781b,
-	0x0064, 0x007c, 0x781b, 0x0061, 0x007c, 0x2009, 0x4a19, 0x210c,
-	0xa186, 0x0000, 0x0040, 0x40e7, 0xa186, 0x0001, 0x0040, 0x40ea,
-	0x701f, 0x000b, 0x7067, 0x0001, 0x781b, 0x0047, 0x007c, 0x781b,
-	0x00e7, 0x007c, 0x701f, 0x000a, 0x007c, 0x2009, 0x4a19, 0x210c,
-	0xa186, 0x0000, 0x0040, 0x4102, 0xa186, 0x0001, 0x0040, 0x40ff,
-	0x701f, 0x000b, 0x7067, 0x0001, 0x781b, 0x0047, 0x007c, 0x701f,
-	0x000a, 0x007c, 0x781b, 0x00e6, 0x007c, 0x781b, 0x00f0, 0x007c,
-	0x781b, 0x00ef, 0x007c, 0x781b, 0x00c0, 0x007c, 0x781b, 0x00bf,
-	0x007c, 0x6818, 0xd0fc, 0x0040, 0x4117, 0x681b, 0x001d, 0x7067,
-	0x0001, 0x781b, 0x0047, 0x007c, 0x7830, 0xa084, 0x00c0, 0x00c0,
-	0x4130, 0x7808, 0xc08c, 0x780a, 0x0005, 0x0005, 0x0005, 0x0005,
-	0x78ec, 0xa084, 0x0021, 0x0040, 0x4130, 0x7808, 0xc08d, 0x780a,
-	0x007c, 0x7808, 0xc08d, 0x780a, 0x007c, 0x7830, 0xa084, 0x0040,
-	0x00c0, 0x4135, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x0040, 0x4144,
-	0xb284, 0x0300, 0x0078, 0x4146, 0xb284, 0x0400, 0x0040, 0x414c,
-	0x0098, 0x4150, 0x0078, 0x414e, 0x00a8, 0x4150, 0x78ac, 0x007c,
-	0x7808, 0xa084, 0xfffd, 0x780a, 0x0005, 0x0005, 0x0005, 0x0005,
-	0x78ec, 0xa084, 0x0021, 0x0040, 0x4173, 0x007e, 0x2001, 0x4a04,
-	0x2004, 0xd0ec, 0x007f, 0x0040, 0x4169, 0xb284, 0x0300, 0x0078,
-	0x416b, 0xb284, 0x0400, 0x0040, 0x4171, 0x0098, 0x416d, 0x0078,
-	0x4173, 0x00a8, 0x4171, 0x78ac, 0x007e, 0x7808, 0xa085, 0x0002,
-	0x780a, 0x007f, 0x007c, 0xa784, 0x0001, 0x00c0, 0x360e, 0xa784,
-	0x0070, 0x0040, 0x418b, 0x0c7e, 0x2d60, 0x2f68, 0x1078, 0x2881,
-	0x2d78, 0x2c68, 0x0c7f, 0xa784, 0x0008, 0x0040, 0x4198, 0x784b,
-	0x0008, 0x78ec, 0xa084, 0x0003, 0x0040, 0x2946, 0x0078, 0x40c9,
-	0xa784, 0x0004, 0x0040, 0x41c7, 0x78b8, 0xa084, 0x4001, 0x0040,
-	0x41c7, 0x784b, 0x0008, 0x78ec, 0xa084, 0x0003, 0x0040, 0x2946,
-	0x78e4, 0xa084, 0x0007, 0xa086, 0x0001, 0x00c0, 0x41c7, 0x78c0,
-	0xa685, 0x4800, 0x2030, 0x7e5a, 0x781b, 0x00f0, 0x007c, 0x784b,
-	0x0008, 0x6818, 0xd0fc, 0x0040, 0x41c4, 0x681b, 0x0015, 0xd6f4,
-	0x0040, 0x41c4, 0x681b, 0x0007, 0x1078, 0x40d5, 0x007c, 0x681b,
-	0x0003, 0x7858, 0xa084, 0x3f00, 0x681e, 0x682f, 0x0000, 0x6833,
-	0x0000, 0x784b, 0x0008, 0x78ec, 0xa084, 0x0003, 0x0040, 0x2f84,
-	0x007e, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x41e4,
-	0xb284, 0x0300, 0x0078, 0x41e6, 0xb284, 0x0400, 0x0040, 0x41ec,
-	0x0018, 0x2942, 0x0078, 0x41ee, 0x0028, 0x2942, 0x0078, 0x3ea2,
-	0x6b14, 0x8307, 0xa084, 0x000f, 0x8003, 0x8003, 0x8003, 0xd3fc,
-	0x0040, 0x41fe, 0xa080, 0x4f40, 0x0078, 0x4200, 0xa080, 0x4ec0,
-	0x2060, 0x2048, 0x705a, 0x2a60, 0x007c, 0x0020, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000,
-	0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0062,
-	0x0009, 0x0014, 0x0014, 0x9848, 0x0014, 0x0014, 0x9906, 0x98f4,
-	0x0014, 0x0014, 0x0080, 0x00f1, 0x0100, 0x0402, 0x2008, 0xf880,
-	0x0018, 0xa20a, 0x0014, 0x300b, 0xa20c, 0x0014, 0x2500, 0x0013,
-	0x2500, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
-	0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0xa200,
-	0x3806, 0x8839, 0x20c4, 0x0864, 0xa850, 0x3008, 0x28c1, 0x9d0d,
-	0xa201, 0x300c, 0x2847, 0x8161, 0x846a, 0x8000, 0x84a4, 0x1856,
-	0x883a, 0xa808, 0x28e2, 0x9cc2, 0xa8f3, 0x0864, 0xa83e, 0x300c,
-	0xa801, 0x3008, 0x28e1, 0x9cc2, 0x2021, 0xa81b, 0xa205, 0x870c,
-	0xd8de, 0x64a0, 0x6de0, 0x6fc0, 0x63a4, 0x6c80, 0x0212, 0xa205,
-	0x883d, 0x9d25, 0x882b, 0x1814, 0x883b, 0x9d2b, 0x883b, 0x7027,
-	0x85f2, 0xa737, 0xa532, 0xf003, 0x8576, 0x8677, 0xa812, 0x883e,
-	0xa810, 0x280c, 0xa204, 0x64c0, 0x6de0, 0x67a0, 0x6fc0, 0x9d25,
-	0x1814, 0x9d2b, 0x883b, 0x7023, 0x8576, 0x8677, 0xa802, 0x7861,
-	0x883e, 0x206b, 0x28c1, 0x9d0d, 0x2044, 0x2103, 0x20a2, 0x2081,
-	0xa8c9, 0xa207, 0x2901, 0xa80a, 0x0014, 0xa203, 0x8000, 0x85a4,
-	0x1872, 0x879a, 0x883c, 0x1fe2, 0xf601, 0xa208, 0x856e, 0x866f,
-	0x7161, 0x0014, 0x0704, 0x3008, 0x9cc2, 0x0014, 0xa202, 0x8000,
-	0x85a4, 0x3009, 0x84a8, 0x19e2, 0xf844, 0x856e, 0x883f, 0x08e6,
-	0xa8f5, 0xf861, 0xa8ea, 0xf801, 0x0014, 0xf881, 0x0016, 0x85b2,
-	0x80f0, 0x9532, 0xfaa2, 0x1de2, 0x0014, 0x8532, 0xf221, 0x0014,
-	0x1de2, 0x84a8, 0xd6e0, 0x1fe6, 0x0014, 0x3008, 0x8000, 0x284a,
-	0x1011, 0xa8fc, 0x3008, 0x9d25, 0x8000, 0xa000, 0x2802, 0x1011,
-	0xa8fd, 0x9d2b, 0xa887, 0x3008, 0x9d25, 0x283b, 0x1011, 0xa8fd,
-	0xa209, 0x0017, 0x300c, 0x8000, 0x85a4, 0x1de2, 0xdac1, 0x0014,
-	0x0210, 0xa801, 0x0014, 0x26e0, 0x873a, 0xfaa3, 0x19f2, 0x26e0,
-	0x18f2, 0x0014, 0xa20b, 0x0014, 0xa20d, 0x3806, 0x0210, 0x9d17,
-	0x0704, 0xa206, 0x6865, 0x817e, 0x842a, 0x1dc1, 0x8823, 0x0016,
-	0x6042, 0x8008, 0xa8fa, 0x8000, 0x84a4, 0x8160, 0x842a, 0xf021,
-	0x3008, 0x84a8, 0x11d6, 0x7042, 0x20dd, 0x0011, 0x20d4, 0x8822,
-	0x0016, 0x7944, 0x8421, 0xa020, 0xa532, 0x84a1, 0x0016, 0x7944,
-	0x8421, 0xa0df, 0x9532, 0x84a1, 0x0016, 0x0000, 0x127e, 0x70d4,
-	0xa084, 0x4600, 0x8004, 0x2090, 0x7204, 0x7008, 0xc09c, 0xa205,
-	0x00c0, 0x4342, 0x720c, 0x82ff, 0x0040, 0x433d, 0x8aff, 0x00c0,
-	0x4342, 0x7200, 0xd284, 0x00c0, 0x4342, 0x7003, 0x0008, 0x127f,
-	0x2000, 0x007c, 0x7000, 0xa084, 0x0003, 0x7002, 0xc69c, 0xd084,
-	0x0040, 0x4374, 0x2001, 0x4a05, 0x2004, 0xd0ec, 0x00c0, 0x43a5,
-	0xd0e4, 0x00c0, 0x435a, 0x2001, 0x04fd, 0x2004, 0xa086, 0x0003,
-	0x0040, 0x43a5, 0x0e7e, 0x2071, 0x0010, 0x2009, 0x0007, 0x7008,
-	0xa084, 0x3000, 0x00c0, 0x435d, 0x8109, 0x00c0, 0x435f, 0x0e7f,
-	0x2009, 0x0007, 0x7008, 0xa084, 0x3000, 0x00c0, 0x435a, 0x8109,
-	0x00c0, 0x436a, 0x0078, 0x43a5, 0x7108, 0xd1fc, 0x0040, 0x437f,
-	0x1078, 0x44ba, 0x8aff, 0x0040, 0x432c, 0x0078, 0x4374, 0x700c,
-	0xa08c, 0x03ff, 0x0040, 0x43aa, 0x7004, 0xd084, 0x0040, 0x439c,
-	0x7014, 0xa005, 0x00c0, 0x4398, 0x7010, 0x7310, 0xa306, 0x00c0,
-	0x438c, 0x2300, 0xa005, 0x0040, 0x439c, 0xa102, 0x00c8, 0x4374,
-	0x7007, 0x0010, 0x0078, 0x43a5, 0x8aff, 0x0040, 0x43aa, 0x1078,
-	0x46a3, 0x00c0, 0x439f, 0x0040, 0x4374, 0x1078, 0x4443, 0x127f,
-	0x2000, 0x007c, 0x7204, 0x7108, 0xc19c, 0x8103, 0x00c8, 0x43b9,
-	0x1078, 0x44ba, 0x0078, 0x43aa, 0x7003, 0x0008, 0x127f, 0x2000,
-	0x007c, 0xa205, 0x00c0, 0x43a5, 0x7003, 0x0008, 0x127f, 0x2000,
-	0x007c, 0x6428, 0x84ff, 0x0040, 0x43ed, 0x2c70, 0x7004, 0xa0bc,
-	0x000f, 0xa7b8, 0x43fd, 0x273c, 0x87fb, 0x00c0, 0x43db, 0x0048,
-	0x43d3, 0x1078, 0x28ec, 0x609c, 0xa075, 0x0040, 0x43ed, 0x0078,
-	0x43c6, 0x2039, 0x43f2, 0x2704, 0xae68, 0x6808, 0xa630, 0x680c,
-	0xa529, 0x8421, 0x0040, 0x43ed, 0x8738, 0x2704, 0xa005, 0x00c0,
-	0x43dc, 0x709c, 0xa075, 0x00c0, 0x43c6, 0x007c, 0x0000, 0x0005,
-	0x0009, 0x000d, 0x0011, 0x0015, 0x0019, 0x001d, 0x0000, 0x0003,
-	0x0009, 0x000f, 0x0015, 0x001b, 0x0000, 0x0000, 0x43f2, 0x43ef,
-	0x0000, 0x0000, 0x8000, 0x0000, 0x43f2, 0x0000, 0x43fa, 0x43f7,
-	0x0000, 0x0000, 0x0000, 0x0000, 0x43fa, 0x0000, 0x43f5, 0x43f5,
-	0x0000, 0x0000, 0x8000, 0x0000, 0x43f5, 0x0000, 0x43fb, 0x43fb,
-	0x0000, 0x0000, 0x0000, 0x0000, 0x43fb, 0x2079, 0x4a00, 0x2071,
-	0x0010, 0x7007, 0x000a, 0x7007, 0x0002, 0x7003, 0x0001, 0x7810,
-	0xd0ec, 0x0040, 0x4431, 0x2009, 0x0001, 0x2071, 0x0020, 0x0078,
-	0x4435, 0x2009, 0x0002, 0x2071, 0x0050, 0x7007, 0x000a, 0x7007,
-	0x0002, 0x7003, 0x0000, 0x8109, 0x0040, 0x4442, 0x2071, 0x0020,
-	0x0078, 0x4435, 0x007c, 0x7004, 0x8004, 0x00c8, 0x44a6, 0x7007,
-	0x0012, 0x2019, 0x0000, 0x7108, 0x7008, 0xa106, 0x00c0, 0x444b,
-	0xa184, 0x01e0, 0x0040, 0x4456, 0x1078, 0x28ec, 0x7810, 0xd0ec,
-	0x0040, 0x4470, 0x2001, 0x04fd, 0x2004, 0xa086, 0x0003, 0x00c0,
-	0x4474, 0xa184, 0x4000, 0x0040, 0x4478, 0xa382, 0x0003, 0x00c8,
-	0x4478, 0xa184, 0x0004, 0x0040, 0x444b, 0x8318, 0x0078, 0x444b,
-	0x7814, 0xd0ec, 0x00c0, 0x4478, 0xa184, 0x4000, 0x00c0, 0x444b,
-	0xa19c, 0x300c, 0xa386, 0x2004, 0x0040, 0x4486, 0xa386, 0x0008,
-	0x0040, 0x4491, 0xa386, 0x200c, 0x00c0, 0x444b, 0x7200, 0x8204,
-	0x0048, 0x4491, 0x730c, 0xa384, 0x03ff, 0x0040, 0x4491, 0x1078,
-	0x28ec, 0x7007, 0x0012, 0x7000, 0xd084, 0x00c0, 0x44a6, 0x7008,
-	0xa084, 0x01e0, 0x00c0, 0x44a6, 0x7310, 0x7014, 0xa305, 0x0040,
-	0x44a6, 0x710c, 0xa184, 0x03ff, 0x00c0, 0x4443, 0x7007, 0x0012,
-	0x7007, 0x0008, 0x7004, 0xd09c, 0x00c0, 0x44aa, 0x7007, 0x0012,
-	0x7108, 0x8103, 0x0048, 0x44ae, 0x7003, 0x0008, 0x007c, 0x7108,
-	0x0078, 0x44ba, 0xa184, 0x01e0, 0x00c0, 0x44ee, 0x7108, 0xa184,
-	0x01e0, 0x00c0, 0x44ee, 0xa184, 0x0007, 0x0079, 0x44c7, 0x44d1,
-	0x44e1, 0x44cf, 0x44e1, 0x44cf, 0x4533, 0x44cf, 0x4531, 0x1078,
-	0x28ec, 0x7004, 0xa084, 0x0010, 0xc08d, 0x7006, 0x8aff, 0x00c0,
-	0x44dc, 0x2049, 0x0000, 0x007c, 0x1078, 0x46a3, 0x00c0, 0x44dc,
-	0x007c, 0x7004, 0xa084, 0x0010, 0xc08d, 0x7006, 0x8aff, 0x0040,
-	0x44ed, 0x1078, 0x46a3, 0x00c0, 0x44e9, 0x007c, 0x7007, 0x0012,
-	0x7108, 0x00e0, 0x44f1, 0x2091, 0x6000, 0x00e0, 0x44f5, 0x2091,
-	0x6000, 0x7007, 0x0012, 0x7007, 0x0008, 0x7004, 0xd09c, 0x00c0,
-	0x44fd, 0x7007, 0x0012, 0x7108, 0xd1fc, 0x00c0, 0x4501, 0x7003,
-	0x0000, 0x7000, 0xa005, 0x00c0, 0x4515, 0x7004, 0xa005, 0x00c0,
-	0x4515, 0x700c, 0xa005, 0x0040, 0x4517, 0x0078, 0x44f9, 0x2049,
-	0x0000, 0xb284, 0x0100, 0x0040, 0x4521, 0x2001, 0x0000, 0x0078,
-	0x4523, 0x2001, 0x0001, 0x1078, 0x3ff5, 0x6818, 0xa084, 0x8000,
-	0x0040, 0x452c, 0x681b, 0x0002, 0x007c, 0x1078, 0x28ec, 0x1078,
-	0x28ec, 0x1078, 0x4570, 0x7210, 0x7114, 0x700c, 0xa09c, 0x03ff,
-	0x2800, 0xa300, 0xa211, 0xa189, 0x0000, 0x1078, 0x4570, 0x2704,
-	0x2c58, 0xac60, 0x6308, 0x2200, 0xa322, 0x630c, 0x2100, 0xa31b,
-	0x2400, 0xa305, 0x0040, 0x4556, 0x00c8, 0x4556, 0x8412, 0x8210,
-	0x830a, 0xa189, 0x0000, 0x2b60, 0x0078, 0x453d, 0x2b60, 0x8a07,
-	0x007e, 0x6004, 0xa084, 0x0008, 0x0040, 0x4562, 0xa7ba, 0x43f7,
-	0x0078, 0x4564, 0xa7ba, 0x43ef, 0x007f, 0xa73d, 0x2c00, 0x6886,
-	0x6f8a, 0x6c92, 0x6b8e, 0x7007, 0x0012, 0x1078, 0x4443, 0x007c,
-	0x8a50, 0x8739, 0x2704, 0xa004, 0x00c0, 0x4584, 0x6000, 0xa064,
-	0x00c0, 0x457b, 0x2d60, 0x6004, 0xa084, 0x000f, 0xa080, 0x440d,
-	0x203c, 0x87fb, 0x1040, 0x28ec, 0x007c, 0x127e, 0x0d7e, 0x70d4,
-	0xa084, 0x4600, 0x8004, 0x2090, 0x0d7f, 0x6884, 0x2060, 0x6888,
-	0x6b8c, 0x6c90, 0x8057, 0xaad4, 0x00ff, 0xa084, 0x00ff, 0x007e,
-	0x6804, 0xa084, 0x0008, 0x007f, 0x0040, 0x45a2, 0xa0b8, 0x43f7,
-	0x0078, 0x45a4, 0xa0b8, 0x43ef, 0xb284, 0x0100, 0x0040, 0x45ab,
-	0x7e20, 0x0078, 0x45ac, 0x7e24, 0xa6b5, 0x000c, 0x681c, 0xd0b4,
-	0x0040, 0x45b3, 0xc685, 0x2400, 0xa305, 0x0040, 0x45dd, 0x2c58,
-	0x2704, 0x6104, 0xac60, 0x6000, 0xa400, 0x701a, 0x6004, 0xa301,
-	0x701e, 0xa184, 0x0008, 0x0040, 0x45cd, 0x6010, 0xa081, 0x0000,
-	0x7022, 0x6014, 0xa081, 0x0000, 0x7026, 0x6208, 0x2400, 0xa202,
-	0x7012, 0x620c, 0x2300, 0xa203, 0x7016, 0x7602, 0x7007, 0x0001,
-	0x2b60, 0x1078, 0x46c6, 0x0078, 0x45df, 0x1078, 0x46a3, 0x00c0,
-	0x45dd, 0x127f, 0x2000, 0x007c, 0x127e, 0x0d7e, 0x70d4, 0xa084,
-	0x4600, 0x8004, 0x2090, 0x0d7f, 0x7007, 0x0004, 0x7004, 0xd094,
-	0x00c0, 0x45ee, 0x7003, 0x0008, 0x127f, 0x2000, 0x007c, 0x127e,
-	0x0d7e, 0x70d4, 0xa084, 0x4600, 0x8004, 0x2090, 0x0d7f, 0x7e20,
-	0xb284, 0x0100, 0x00c0, 0x4605, 0x7e24, 0xa6b5, 0x000c, 0x681c,
-	0xd0ac, 0x00c0, 0x4610, 0xc685, 0x7003, 0x0000, 0x7007, 0x0004,
-	0x6828, 0x2050, 0x2d60, 0x6004, 0xa0bc, 0x000f, 0xa7b8, 0x43fd,
-	0x273c, 0x87fb, 0x00c0, 0x4626, 0x0048, 0x4620, 0x1078, 0x28ec,
-	0x689c, 0xa065, 0x0040, 0x462a, 0x0078, 0x4613, 0x1078, 0x46a3,
-	0x00c0, 0x4626, 0x127f, 0x2000, 0x007c, 0x127e, 0x007e, 0x017e,
-	0x0d7e, 0x70d4, 0xa084, 0x4600, 0x8004, 0x2090, 0x7e20, 0xb284,
-	0x0100, 0x00c0, 0x463c, 0x7e24, 0x0d7f, 0x037f, 0x047f, 0xa6b5,
-	0x000c, 0x681c, 0xd0b4, 0x0040, 0x464a, 0xc685, 0x7003, 0x0000,
-	0x7007, 0x0004, 0x2049, 0x462d, 0x6828, 0xa055, 0x0040, 0x46a0,
-	0x2d70, 0x2e60, 0x7004, 0xa0bc, 0x000f, 0xa7b8, 0x43fd, 0x273c,
-	0x87fb, 0x00c0, 0x4666, 0x0048, 0x465f, 0x1078, 0x28ec, 0x709c,
-	0xa075, 0x2060, 0x0040, 0x46a0, 0x0078, 0x4652, 0x2704, 0xae68,
-	0x6808, 0xa422, 0x680c, 0xa31b, 0x0048, 0x467f, 0x8a51, 0x00c0,
-	0x4673, 0x1078, 0x28ec, 0x8738, 0x2704, 0xa005, 0x00c0, 0x4667,
-	0x709c, 0xa075, 0x2060, 0x0040, 0x46a0, 0x0078, 0x4652, 0x8422,
-	0x8420, 0x831a, 0xa399, 0x0000, 0x6908, 0x2400, 0xa122, 0x690c,
-	0x2300, 0xa11b, 0x00c8, 0x468e, 0x1078, 0x28ec, 0xb284, 0x0100,
-	0x0040, 0x469c, 0x2001, 0x4a04, 0x2004, 0xd0ec, 0x00c0, 0x469c,
-	0x2071, 0x0050, 0x0078, 0x469e, 0x2071, 0x0020, 0x0078, 0x45b3,
-	0x127f, 0x2000, 0x007c, 0x7008, 0xa084, 0x0003, 0xa086, 0x0003,
-	0x00c0, 0x46ab, 0x007c, 0x2704, 0xac78, 0x7800, 0x701a, 0x7804,
-	0x701e, 0x7808, 0x7012, 0x780c, 0x7016, 0x6004, 0xa084, 0x0008,
-	0x0040, 0x46be, 0x7810, 0x7022, 0x7814, 0x7026, 0x7602, 0x7004,
-	0xa084, 0x0010, 0xc085, 0x7006, 0x2079, 0x4a00, 0x8a51, 0x0040,
-	0x46e1, 0x8738, 0x2704, 0xa005, 0x00c0, 0x46dc, 0x609c, 0xa005,
-	0x0040, 0x46e2, 0x2060, 0x6004, 0xa084, 0x000f, 0xa080, 0x43fd,
-	0x203c, 0x87fb, 0x1040, 0x28ec, 0x7008, 0xa084, 0x0003, 0xa086,
-	0x0003, 0x007c, 0x2051, 0x0000, 0x007c, 0x127e, 0x007e, 0x0d7e,
-	0x70d4, 0xa084, 0x4600, 0x8004, 0x2090, 0x0d7f, 0x087f, 0x7108,
-	0xa184, 0x0003, 0x00c0, 0x46fa, 0x6828, 0xa005, 0x0040, 0x470a,
-	0x0078, 0x4342, 0x7108, 0xd1fc, 0x0040, 0x4702, 0x1078, 0x44ba,
-	0x0078, 0x46ef, 0x7007, 0x0010, 0x7108, 0xd1fc, 0x0040, 0x4704,
-	0x1078, 0x44ba, 0x7008, 0xa086, 0x0008, 0x00c0, 0x46ef, 0x7000,
-	0xa005, 0x00c0, 0x46ef, 0x7003, 0x0000, 0x2049, 0x0000, 0x127f,
-	0x2000, 0x007c, 0x127e, 0x147e, 0x137e, 0x157e, 0x0c7e, 0x0d7e,
-	0x70d4, 0xa084, 0x4600, 0x8004, 0x2090, 0x0d7f, 0x2049, 0x471a,
-	0xad80, 0x0011, 0x20a0, 0xb284, 0x0100, 0x0040, 0x473d, 0x2001,
-	0x4a04, 0x2004, 0xd0ec, 0x0040, 0x4739, 0x2099, 0x0031, 0x0078,
-	0x473f, 0x2099, 0x0032, 0x0078, 0x473f, 0x2099, 0x0031, 0x700c,
-	0xa084, 0x03ff, 0x682a, 0x7007, 0x0008, 0x7007, 0x0002, 0x7003,
-	0x0001, 0x0040, 0x474e, 0x8000, 0x80ac, 0x53a5, 0x700c, 0xa084,
-	0x03ff, 0x0040, 0x475a, 0x7007, 0x0004, 0x7004, 0xa084, 0x0004,
-	0x00c0, 0x4755, 0x0c7f, 0x2049, 0x0000, 0x7003, 0x0000, 0x157f,
-	0x137f, 0x147f, 0x127f, 0x2000, 0x007c, 0x2091, 0x8000, 0x2091,
-	0x6000, 0x78ac, 0xa005, 0x00c0, 0x477c, 0x7974, 0x70d0, 0xa106,
-	0x00c0, 0x477c, 0x781c, 0xa005, 0x0040, 0x477c, 0x781f, 0x0000,
-	0x0068, 0x477c, 0x2091, 0x4080, 0x7830, 0x8001, 0x7832, 0x00c0,
-	0x4804, 0x7834, 0x7832, 0x7810, 0xd0ec, 0x00c0, 0x47fd, 0x2061,
-	0x6fc0, 0x2069, 0x4a80, 0xc7fd, 0x68d0, 0xa005, 0x0040, 0x4796,
-	0x8001, 0x68d2, 0x00c0, 0x4796, 0x1078, 0x4998, 0x6800, 0xa084,
-	0x000f, 0x0040, 0x47ab, 0xa086, 0x0001, 0x0040, 0x47ab, 0x6844,
-	0xa00d, 0x0040, 0x47ab, 0x2104, 0xa005, 0x0040, 0x47ab, 0x8001,
-	0x200a, 0x0040, 0x4909, 0x6814, 0xa005, 0x0040, 0x47d0, 0x8001,
-	0x6816, 0x00c0, 0x47d0, 0x68a7, 0x0001, 0x0f7e, 0xd7fc, 0x00c0,
-	0x47c5, 0x7810, 0xd0ec, 0x0040, 0x47c1, 0x2079, 0x0100, 0x0078,
-	0x47c7, 0x2079, 0x0200, 0x0078, 0x47c7, 0x2079, 0x0100, 0x1078,
-	0x4131, 0x0f7f, 0x6864, 0xa005, 0x0040, 0x47d0, 0x1078, 0x25de,
-	0x6880, 0xa005, 0x0040, 0x47dd, 0x8001, 0x6882, 0x00c0, 0x47dd,
-	0x6867, 0x0000, 0x68d4, 0xc0dd, 0x68d6, 0x68d4, 0xd0fc, 0x0040,
-	0x47fa, 0xc0fc, 0x68d6, 0x20a9, 0x0200, 0x603c, 0xa005, 0x0040,
-	0x47f6, 0x8001, 0x603e, 0x68d4, 0xc0fd, 0x68d6, 0x00c0, 0x47f6,
-	0x6010, 0xa005, 0x0040, 0x47f6, 0x1078, 0x25de, 0xace0, 0x0010,
-	0x00f0, 0x47e5, 0xd7fc, 0x0040, 0x4804, 0x2061, 0x4fc0, 0x2069,
-	0x4a40, 0xc7fc, 0x0078, 0x478c, 0x1078, 0x4840, 0x7838, 0x8001,
-	0x783a, 0x00c0, 0x4826, 0x783c, 0x783a, 0x2061, 0x4fc0, 0x2069,
-	0x4a40, 0xc7fc, 0x680c, 0xa005, 0x0040, 0x4818, 0x1078, 0x487f,
-	0xd7fc, 0x00c0, 0x4826, 0x7810, 0xd0ec, 0x00c0, 0x4826, 0x2061,
-	0x6fc0, 0x2069, 0x4a80, 0xc7fd, 0x0078, 0x4812, 0x7814, 0xd0e4,
-	0x00c0, 0x482a, 0x7810, 0xd0cc, 0x0040, 0x483d, 0xd0ac, 0x00c0,
-	0x4836, 0xd0a4, 0x0040, 0x483d, 0xc0ad, 0x7812, 0x2091, 0x8001,
-	0x0068, 0x483c, 0x1078, 0x2368, 0x007c, 0x2091, 0x8001, 0x007c,
-	0x7840, 0x8001, 0x7842, 0x00c0, 0x487e, 0x7844, 0x7842, 0x2091,
-	0x8000, 0x2061, 0x4fc0, 0x2069, 0x4a40, 0xc7fc, 0x6810, 0xa005,
-	0x00c0, 0x4854, 0x2001, 0x0101, 0x8001, 0x6812, 0xd7fc, 0x0040,
-	0x485d, 0xa080, 0x90d0, 0x0078, 0x485f, 0xa080, 0x8fc0, 0x2040,
-	0x2004, 0xa065, 0x0040, 0x4870, 0x6024, 0xa005, 0x0040, 0x486c,
-	0x8001, 0x6026, 0x0040, 0x48ad, 0x6000, 0x2c40, 0x0078, 0x4861,
-	0xd7fc, 0x00c0, 0x487e, 0x7810, 0xd0ec, 0x00c0, 0x487e, 0x2061,
-	0x6fc0, 0x2069, 0x4a80, 0xc7fd, 0x0078, 0x484e, 0x007c, 0x2009,
-	0x0000, 0x20a9, 0x0200, 0x6008, 0xd09c, 0x0040, 0x4899, 0x6024,
-	0xa005, 0x0040, 0x488f, 0x8001, 0x6026, 0x0078, 0x4897, 0x6008,
-	0xc09c, 0xc0bd, 0x600a, 0xa18d, 0x0001, 0x0078, 0x4899, 0xa18d,
-	0x0100, 0xace0, 0x0010, 0x00f0, 0x4883, 0xa184, 0x0001, 0x0040,
-	0x48a8, 0xa18c, 0xfffe, 0x690e, 0x1078, 0x25de, 0x0078, 0x48a9,
-	0x690e, 0x007c, 0x00c0, 0x48a9, 0x786c, 0x6800, 0xa005, 0x0040,
-	0x48b5, 0x684c, 0xac06, 0x0040, 0x4909, 0x6864, 0xa005, 0x0040,
-	0x48bd, 0x6027, 0x0001, 0x0078, 0x4906, 0x2c00, 0x687e, 0x601b,
+	0x6820, 0xc0c5, 0x6822, 0x70d4, 0xd0b4, 0x0040, 0x3eda, 0xc0b4,
+	0x70d6, 0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018,
+	0x8001, 0x601a, 0x0c7f, 0x007c, 0x0c7e, 0x2960, 0x6104, 0xa18c,
+	0xfff5, 0x6106, 0x2011, 0x0032, 0x2019, 0x0000, 0x0078, 0x3ee8,
+	0x78ab, 0x0001, 0x78ab, 0x0003, 0x78ab, 0x0001, 0x7aaa, 0x7baa,
+	0xa8c0, 0x0005, 0x6820, 0xc0c5, 0x6822, 0x0c7f, 0x007c, 0x0c7e,
+	0x7158, 0x2160, 0x2018, 0xa08c, 0x0020, 0x0040, 0x3f00, 0xc0ac,
+	0x2008, 0xa084, 0xfff0, 0xa635, 0x7e86, 0x6018, 0x789a, 0x7eae,
+	0x6612, 0x78a4, 0xa084, 0xfff0, 0xa18c, 0x000f, 0xa105, 0xc0f4,
+	0xa39c, 0x0020, 0x0040, 0x3f16, 0xa085, 0x4000, 0xc0fc, 0xd0b4,
+	0x00c0, 0x3f1b, 0xc0fd, 0x78a6, 0x6016, 0x788a, 0xa6b4, 0x000f,
+	0x8637, 0x8204, 0x8004, 0xa084, 0x00ff, 0xa605, 0x600e, 0x6004,
+	0xa084, 0xfff5, 0x6006, 0x0c7f, 0x007c, 0x0c7e, 0x7058, 0x2060,
+	0x6018, 0x789a, 0x78a4, 0xa084, 0xfff0, 0x78a6, 0x6012, 0x7884,
+	0xa084, 0xfff0, 0x7886, 0x600c, 0xa084, 0x00ff, 0x600e, 0x0c7f,
+	0x007c, 0xa282, 0x0002, 0x00c0, 0x4040, 0x7aa8, 0x6920, 0xc1bd,
+	0x6922, 0xd1cc, 0x0040, 0x3f7c, 0xc1cc, 0x6922, 0xa294, 0x00ff,
+	0xa282, 0x0002, 0x00c8, 0x4040, 0x1078, 0x3fcd, 0x1078, 0x3f2d,
+	0xa980, 0x0001, 0x200c, 0x1078, 0x4183, 0x1078, 0x3e7c, 0x88ff,
+	0x0040, 0x3f72, 0x789b, 0x0060, 0x2800, 0x78aa, 0x7e58, 0xc695,
+	0x7e5a, 0xd6d4, 0x00c0, 0x3f6f, 0x781b, 0x0061, 0x007c, 0x781b,
+	0x0075, 0x007c, 0x7e58, 0xd6d4, 0x00c0, 0x3f79, 0x781b, 0x0064,
+	0x007c, 0x781b, 0x0076, 0x007c, 0xa282, 0x0002, 0x00c8, 0x3f84,
+	0xa284, 0x0001, 0x0040, 0x3f8d, 0x7158, 0xa188, 0x0000, 0x210c,
+	0xd1ec, 0x00c0, 0x3f8d, 0x2011, 0x0000, 0x1078, 0x40b5, 0x1078,
+	0x3fcd, 0x1078, 0x3f2d, 0x7858, 0xc095, 0x785a, 0x781b, 0x0075,
+	0x007c, 0x0c7e, 0x027e, 0x2960, 0x6000, 0x2011, 0x0001, 0xd0ec,
+	0x00c0, 0x3fae, 0x6014, 0xa084, 0x0040, 0x00c0, 0x3fac, 0xc1a4,
+	0x6106, 0xa006, 0x0078, 0x3fca, 0x2011, 0x0000, 0x78ab, 0x0001,
+	0x78ab, 0x0002, 0x78ab, 0x0003, 0x7aaa, 0xa8c0, 0x0004, 0x70d4,
+	0xd0b4, 0x0040, 0x3fc6, 0xc0b4, 0x70d6, 0x70b8, 0xa065, 0x6008,
+	0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a, 0x6820, 0xa085,
+	0x0200, 0x6822, 0x027f, 0x0c7f, 0x007c, 0x0c7e, 0x7058, 0x2060,
+	0x82ff, 0x0040, 0x3fd5, 0x2011, 0x0040, 0x6018, 0xa080, 0x0002,
+	0x789a, 0x78a4, 0xa084, 0xffbf, 0xa205, 0xc0fc, 0xd0b4, 0x00c0,
+	0x3fe2, 0xc0fd, 0x78a6, 0x6016, 0x788a, 0x6004, 0xc0a4, 0x6006,
+	0x0c7f, 0x007c, 0x007e, 0x7000, 0xa086, 0x0003, 0x0040, 0x3ff3,
+	0x007f, 0x0078, 0x3ff6, 0x007f, 0x0078, 0x403d, 0xd6ac, 0x0040,
+	0x403d, 0x7888, 0xa084, 0x0040, 0x0040, 0x403d, 0x7bb8, 0xa384,
+	0x003f, 0x831b, 0x00c8, 0x4005, 0x8000, 0xa005, 0x0040, 0x401a,
+	0x831b, 0x00c8, 0x400e, 0x8001, 0x0040, 0x403a, 0xd6f4, 0x0040,
+	0x401a, 0x78b8, 0x801b, 0x00c8, 0x4016, 0x8000, 0xa084, 0x003f,
+	0x00c0, 0x403a, 0xc6f4, 0x7e5a, 0x79d8, 0x7adc, 0x2001, 0x0001,
+	0xa108, 0x00c8, 0x4025, 0xa291, 0x0000, 0x79d2, 0x79da, 0x7ad6,
+	0x7ade, 0x1078, 0x493a, 0x781b, 0x0073, 0xb284, 0x0300, 0x0040,
+	0x4035, 0x2001, 0x0000, 0x0078, 0x4037, 0x2001, 0x0001, 0x1078,
+	0x47c2, 0x007c, 0x781b, 0x0073, 0x007c, 0x781b, 0x0076, 0x007c,
+	0x1078, 0x4068, 0x781b, 0x0075, 0x007c, 0x1078, 0x4051, 0x781b,
+	0x0075, 0x007c, 0x6827, 0x0002, 0x1078, 0x4059, 0x781b, 0x0075,
+	0x007c, 0x2001, 0x0005, 0x0078, 0x406a, 0x2001, 0x000c, 0x0078,
+	0x406a, 0x6820, 0xc0d5, 0x6822, 0x2001, 0x0006, 0x0078, 0x406a,
+	0x2001, 0x000d, 0x0078, 0x406a, 0x2001, 0x0009, 0x0078, 0x406a,
+	0x2001, 0x0007, 0x789b, 0x007e, 0x78aa, 0xc69d, 0x7e5a, 0x70d4,
+	0xd0b4, 0x0040, 0x4080, 0xc0b4, 0x70d6, 0x0c7e, 0x70b8, 0xa065,
+	0x6008, 0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a, 0x0c7f,
+	0x007c, 0x077e, 0x873f, 0xa7bc, 0x000f, 0x873b, 0x873b, 0x8703,
+	0x017e, 0xb28c, 0x0300, 0x0040, 0x4091, 0xa0e0, 0x51c0, 0x0078,
+	0x4093, 0xa0e0, 0x5240, 0x017f, 0xa7b8, 0x0020, 0x7f9a, 0x79a4,
+	0xa184, 0x000f, 0x0040, 0x40a3, 0xa184, 0xfff0, 0x78a6, 0x6012,
+	0x6004, 0xc09d, 0x6006, 0x8738, 0x8738, 0x7f9a, 0x79a4, 0xa184,
+	0x0040, 0x0040, 0x40b3, 0xa184, 0xffbf, 0xc0fd, 0x78a6, 0x6016,
+	0x6004, 0xc0a5, 0x6006, 0x077f, 0x007c, 0x789b, 0x0010, 0x78ab,
+	0x0001, 0x78ab, 0x0002, 0x78ab, 0x0003, 0x7aaa, 0x789b, 0x0060,
+	0x78ab, 0x0004, 0x70d4, 0xd0b4, 0x0040, 0x40d3, 0xc0b4, 0x70d6,
+	0x0c7e, 0x70b8, 0xa065, 0x6008, 0xa084, 0xfbef, 0x600a, 0x6018,
+	0x8001, 0x601a, 0x0c7f, 0x007c, 0x2031, 0x0000, 0x2029, 0x0032,
+	0x789b, 0x0010, 0x78ab, 0x0001, 0x78ab, 0x0003, 0x78ab, 0x0001,
+	0x7daa, 0x7eaa, 0x789b, 0x0060, 0x78ab, 0x0005, 0x70d4, 0xd0b4,
+	0x0040, 0x40f7, 0xc0b4, 0x70d6, 0x0c7e, 0x70b8, 0xa065, 0x6008,
+	0xa084, 0xfbef, 0x600a, 0x6018, 0x8001, 0x601a, 0x0c7f, 0x007c,
+	0x157e, 0x8007, 0xa084, 0x00ff, 0x8003, 0x8003, 0xa080, 0x0020,
+	0x789a, 0x79a4, 0xa18c, 0xfff0, 0x2021, 0x416c, 0x2019, 0x0011,
+	0x20a9, 0x000e, 0x2011, 0x0032, 0x2404, 0xa084, 0xfff0, 0xa106,
+	0x0040, 0x4117, 0x8420, 0x2300, 0xa210, 0x00f0, 0x410c, 0x157f,
+	0x007c, 0x157e, 0x2001, 0x4d05, 0x2004, 0xd0e4, 0x00c0, 0x414a,
+	0x2021, 0x417a, 0x20a9, 0x0009, 0x2011, 0x0028, 0xa582, 0x0019,
+	0x0040, 0x4160, 0x0048, 0x4160, 0x8420, 0x95a9, 0x2011, 0x0032,
+	0xa582, 0x0032, 0x0040, 0x4160, 0x0048, 0x4160, 0x8420, 0x95a9,
+	0x2019, 0x000a, 0x2011, 0x0064, 0x2200, 0xa502, 0x0040, 0x4160,
+	0x0048, 0x4160, 0x8420, 0x2300, 0xa210, 0x00f0, 0x413c, 0x157f,
+	0x0078, 0x415e, 0x2021, 0x416c, 0x2019, 0x0011, 0x20a9, 0x000e,
+	0x2011, 0x0032, 0x2200, 0xa502, 0x0040, 0x4160, 0x0048, 0x4160,
+	0x8420, 0x2300, 0xa210, 0x00f0, 0x4152, 0x157f, 0xa006, 0x007c,
+	0x157f, 0xa582, 0x0064, 0x00c8, 0x4169, 0x7808, 0xa085, 0x0070,
+	0x780a, 0x2404, 0xa005, 0x007c, 0x1209, 0x3002, 0x3202, 0x4203,
+	0x4403, 0x5404, 0x5604, 0x6605, 0x6805, 0x7806, 0x7a06, 0x0c07,
+	0x0c07, 0x0e07, 0x10e1, 0x330a, 0x5805, 0x5a05, 0x6a06, 0x6c06,
+	0x7c07, 0x7e07, 0x0e00, 0x789b, 0x0010, 0xa046, 0x007c, 0xa784,
+	0x0f00, 0x800b, 0xa784, 0x001f, 0x8003, 0x8003, 0x8003, 0x8003,
+	0xa105, 0xd7fc, 0x0040, 0x4198, 0xa0e0, 0x72c0, 0x0078, 0x419a,
+	0xa0e0, 0x52c0, 0x007c, 0x0e7e, 0x0f7e, 0xd084, 0x0040, 0x41a8,
+	0x2079, 0x0100, 0x2009, 0x4d80, 0x2071, 0x4d80, 0x0078, 0x41b8,
+	0x2009, 0x4d40, 0x2071, 0x4d40, 0x2001, 0x4d04, 0x2004, 0xd0ec,
+	0x0040, 0x41b6, 0x2079, 0x0100, 0x0078, 0x41b8, 0x2079, 0x0200,
+	0x2091, 0x8000, 0x2104, 0xa084, 0x000f, 0x0079, 0x41bf, 0x41c9,
+	0x41c9, 0x41c9, 0x41c9, 0x41c9, 0x41c9, 0x41c7, 0x41c7, 0x1078,
+	0x290c, 0x69b4, 0xc1f5, 0xa18c, 0xff9f, 0x69b6, 0xa005, 0x0040,
+	0x4218, 0x7858, 0xa084, 0xff9f, 0xa085, 0x6000, 0x785a, 0x7828,
+	0xa086, 0x1814, 0x00c0, 0x4218, 0x784b, 0x0004, 0x7848, 0xa084,
+	0x0004, 0x00c0, 0x41de, 0x784b, 0x0008, 0x7848, 0xa084, 0x0008,
+	0x00c0, 0x41e5, 0x7830, 0xd0bc, 0x00c0, 0x4218, 0x007e, 0x2001,
+	0x4d04, 0x2004, 0xd0ec, 0x007f, 0x0040, 0x41fa, 0xb284, 0x0300,
+	0x0078, 0x41fc, 0xb284, 0x0400, 0x0040, 0x4202, 0x0018, 0x4218,
+	0x0078, 0x4204, 0x0028, 0x4218, 0x79e4, 0xa184, 0x0030, 0x0040,
+	0x4218, 0x78ec, 0xa084, 0x0003, 0x0040, 0x4218, 0x681c, 0xd0ac,
+	0x00c0, 0x4216, 0x1078, 0x42a2, 0x0078, 0x4218, 0x781b, 0x00f6,
+	0x0f7f, 0x0e7f, 0x007c, 0x0c7e, 0x2001, 0x4d01, 0x2004, 0xd0ac,
+	0x00c0, 0x4294, 0x6814, 0x8007, 0xa084, 0x000f, 0x8003, 0x8003,
+	0x8003, 0xb28c, 0x0300, 0x0040, 0x4231, 0xa0e0, 0x51c0, 0x0078,
+	0x4233, 0xa0e0, 0x5240, 0x6004, 0xa084, 0x000a, 0x00c0, 0x4294,
+	0x6108, 0xa194, 0xff00, 0x0040, 0x4294, 0xa18c, 0x00ff, 0x2001,
+	0x000a, 0xa106, 0x0040, 0x425f, 0x2001, 0x000c, 0xa106, 0x0040,
+	0x4263, 0x2001, 0x0012, 0xa106, 0x0040, 0x4267, 0x2001, 0x0014,
+	0xa106, 0x0040, 0x426b, 0x2001, 0x0019, 0xa106, 0x0040, 0x426f,
+	0x2001, 0x0032, 0xa106, 0x0040, 0x4273, 0x0078, 0x4277, 0x2009,
+	0x000c, 0x0078, 0x4279, 0x2009, 0x0012, 0x0078, 0x4279, 0x2009,
+	0x0014, 0x0078, 0x4279, 0x2009, 0x0019, 0x0078, 0x4279, 0x2009,
+	0x0020, 0x0078, 0x4279, 0x2009, 0x003f, 0x0078, 0x4279, 0x2011,
+	0x0000, 0x2100, 0xa205, 0x600a, 0x6004, 0xa085, 0x0002, 0x6006,
+	0x2061, 0x4d00, 0x6004, 0xd0bc, 0x0040, 0x4294, 0x6814, 0xd0fc,
+	0x00c0, 0x428f, 0x60ea, 0x2061, 0x4d40, 0x0078, 0x4292, 0x60ee,
+	0x2061, 0x4d80, 0x601f, 0x800f, 0x0c7f, 0x007c, 0x781b, 0x0076,
+	0x007c, 0x781b, 0x0075, 0x007c, 0x781b, 0x0064, 0x007c, 0x781b,
+	0x0061, 0x007c, 0x2009, 0x4d19, 0x210c, 0xa186, 0x0000, 0x0040,
+	0x42b4, 0xa186, 0x0001, 0x0040, 0x42b7, 0x701f, 0x000b, 0x7067,
+	0x0001, 0x781b, 0x0047, 0x007c, 0x781b, 0x00ed, 0x007c, 0x701f,
+	0x000a, 0x007c, 0x2009, 0x4d19, 0x210c, 0xa186, 0x0000, 0x0040,
+	0x42cf, 0xa186, 0x0001, 0x0040, 0x42cc, 0x701f, 0x000b, 0x7067,
+	0x0001, 0x781b, 0x0047, 0x007c, 0x701f, 0x000a, 0x007c, 0x781b,
+	0x00ec, 0x007c, 0x781b, 0x00f6, 0x007c, 0x781b, 0x00f5, 0x007c,
+	0x781b, 0x00c6, 0x007c, 0x781b, 0x00c5, 0x007c, 0x6818, 0xd0fc,
+	0x0040, 0x42e4, 0x681b, 0x001d, 0x7067, 0x0001, 0x781b, 0x0047,
+	0x007c, 0x7830, 0xa084, 0x00c0, 0x00c0, 0x42fd, 0x7808, 0xc08c,
+	0x780a, 0x0005, 0x0005, 0x0005, 0x0005, 0x78ec, 0xa084, 0x0021,
+	0x0040, 0x42fd, 0x7808, 0xc08d, 0x780a, 0x007c, 0x7808, 0xc08d,
+	0x780a, 0x007c, 0x7830, 0xa084, 0x0040, 0x00c0, 0x4302, 0x2001,
+	0x4d04, 0x2004, 0xd0ec, 0x0040, 0x4311, 0xb284, 0x0300, 0x0078,
+	0x4313, 0xb284, 0x0400, 0x0040, 0x4319, 0x0098, 0x431d, 0x0078,
+	0x431b, 0x00a8, 0x431d, 0x78ac, 0x007c, 0x7808, 0xa084, 0xfffd,
+	0x780a, 0x0005, 0x0005, 0x0005, 0x0005, 0x78ec, 0xa084, 0x0021,
+	0x0040, 0x4340, 0x007e, 0x2001, 0x4d04, 0x2004, 0xd0ec, 0x007f,
+	0x0040, 0x4336, 0xb284, 0x0300, 0x0078, 0x4338, 0xb284, 0x0400,
+	0x0040, 0x433e, 0x0098, 0x433a, 0x0078, 0x4340, 0x00a8, 0x433e,
+	0x78ac, 0x007e, 0x7808, 0xa085, 0x0002, 0x780a, 0x007f, 0x007c,
+	0xa784, 0x0001, 0x00c0, 0x36fb, 0xa784, 0x0070, 0x0040, 0x4358,
+	0x0c7e, 0x2d60, 0x2f68, 0x1078, 0x288d, 0x2d78, 0x2c68, 0x0c7f,
+	0xa784, 0x0008, 0x0040, 0x4365, 0x784b, 0x0008, 0x78ec, 0xa084,
+	0x0003, 0x0040, 0x2966, 0x0078, 0x4296, 0xa784, 0x0004, 0x0040,
+	0x4394, 0x78b8, 0xa084, 0x4001, 0x0040, 0x4394, 0x784b, 0x0008,
+	0x78ec, 0xa084, 0x0003, 0x0040, 0x2966, 0x78e4, 0xa084, 0x0007,
+	0xa086, 0x0001, 0x00c0, 0x4394, 0x78c0, 0xa685, 0x4800, 0x2030,
+	0x7e5a, 0x781b, 0x00f6, 0x007c, 0x784b, 0x0008, 0x6818, 0xd0fc,
+	0x0040, 0x4391, 0x681b, 0x0015, 0xd6f4, 0x0040, 0x4391, 0x681b,
+	0x0007, 0x1078, 0x42a2, 0x007c, 0x681b, 0x0003, 0x7858, 0xa084,
+	0x3f00, 0x681e, 0x682f, 0x0000, 0x6833, 0x0000, 0x784b, 0x0008,
+	0x78ec, 0xa084, 0x0003, 0x0040, 0x3004, 0x007e, 0x2001, 0x4d04,
+	0x2004, 0xd0ec, 0x007f, 0x0040, 0x43b1, 0xb284, 0x0300, 0x0078,
+	0x43b3, 0xb284, 0x0400, 0x0040, 0x43b9, 0x0018, 0x2962, 0x0078,
+	0x43bb, 0x0028, 0x2962, 0x0078, 0x4045, 0x6b14, 0x8307, 0xa084,
+	0x000f, 0x8003, 0x8003, 0x8003, 0xd3fc, 0x0040, 0x43cb, 0xa080,
+	0x5240, 0x0078, 0x43cd, 0xa080, 0x51c0, 0x2060, 0x2048, 0x705a,
+	0x2a60, 0x007c, 0x0020, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020, 0x0000, 0x0020,
+	0x0000, 0x0020, 0x0000, 0x0020, 0x0062, 0x0009, 0x0014, 0x0014,
+	0x9848, 0x0014, 0x0014, 0x990e, 0x98fa, 0x0014, 0x0014, 0x0080,
+	0x00f9, 0x0100, 0x0402, 0x2008, 0xf880, 0x0018, 0xa20a, 0x0014,
+	0x300b, 0xa20c, 0x0014, 0x2500, 0x0013, 0x2500, 0x0010, 0x0010,
+	0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
+	0x0010, 0x0010, 0x0010, 0x0010, 0xa200, 0x3806, 0x8839, 0x20c4,
+	0x0864, 0xa856, 0x3008, 0x28c1, 0x9d15, 0xa201, 0x300c, 0x2847,
+	0x8161, 0x846a, 0x8000, 0x84a4, 0x1856, 0x883a, 0xa808, 0x28e2,
+	0x9cc8, 0xa8f3, 0x0864, 0xa844, 0x300c, 0xa801, 0x3008, 0x28e1,
+	0x9cc8, 0x2021, 0xa81d, 0xa205, 0x870c, 0xd8de, 0x64a0, 0x6de0,
+	0x6fc0, 0x63a4, 0x6c80, 0x0212, 0xa205, 0x883d, 0x7942, 0x8020,
+	0xa4a1, 0x882b, 0x1814, 0x883b, 0x80df, 0x94a1, 0x7027, 0x85f2,
+	0xa737, 0xa532, 0xf003, 0x8576, 0x8677, 0xa816, 0x883e, 0xa814,
+	0x2001, 0xa812, 0xa204, 0x64c0, 0x6de0, 0x67a0, 0x6fc0, 0x7942,
+	0x8020, 0xa4a1, 0x1814, 0x80df, 0x94a1, 0x883b, 0x7023, 0x8576,
+	0x8677, 0xa802, 0x7861, 0x883e, 0x206b, 0x28c1, 0x9d15, 0x2044,
+	0x2103, 0x20a2, 0x2081, 0xa8c3, 0xa207, 0x2901, 0xa80a, 0x0014,
+	0xa203, 0x8000, 0x85a4, 0x1872, 0x879a, 0x883c, 0x1fe2, 0xf601,
+	0xa208, 0x856e, 0x866f, 0x7161, 0x0014, 0x0704, 0x3008, 0x9cc8,
+	0x0014, 0xa202, 0x8000, 0x85a4, 0x3009, 0x84a8, 0x19e2, 0xf844,
+	0x856e, 0x883f, 0x08e6, 0xa8f5, 0xf861, 0xa8ea, 0xf801, 0x0014,
+	0xf881, 0x0016, 0x85b2, 0x80f0, 0x9532, 0xfaa2, 0x1de2, 0x0014,
+	0x8532, 0xf221, 0x0014, 0x1de2, 0x84a8, 0xd6e0, 0x1fe6, 0x0014,
+	0x3008, 0x8000, 0x284a, 0x1011, 0xa8fc, 0x3008, 0x9d2d, 0x8000,
+	0xa000, 0x2802, 0x1011, 0xa8fd, 0x9d33, 0xa8bd, 0x3008, 0x9d2d,
+	0x283b, 0x1011, 0xa8fd, 0xa209, 0x0017, 0x300c, 0xa209, 0x8000,
+	0x85a4, 0x1de2, 0xa209, 0xdac1, 0x0014, 0x0210, 0xa801, 0x0014,
+	0x26e0, 0x873a, 0xfaa3, 0x19f2, 0x26e0, 0x18f2, 0x0014, 0xa20b,
+	0x0014, 0xa20d, 0x3806, 0x0210, 0x9d1f, 0x0704, 0xa206, 0x6865,
+	0x817e, 0x842a, 0x1dc1, 0x8823, 0x0016, 0x6042, 0x8008, 0xa8fa,
+	0x8000, 0x84a4, 0x8160, 0x842a, 0xf021, 0x3008, 0x84a8, 0x11d6,
+	0x7042, 0x20dd, 0x0011, 0x20d4, 0x8822, 0x0016, 0x7944, 0x8421,
+	0xa020, 0xa532, 0x84a1, 0x0016, 0x7944, 0x8421, 0xa0df, 0x9532,
+	0x84a1, 0x0016, 0x0000, 0x127e, 0x70d4, 0xa084, 0x4600, 0x8004,
+	0x2090, 0x7204, 0x7008, 0xc09c, 0xa205, 0x00c0, 0x4517, 0x720c,
+	0x82ff, 0x0040, 0x4512, 0x8aff, 0x00c0, 0x4517, 0x7200, 0xd284,
+	0x00c0, 0x4517, 0x7003, 0x0008, 0x127f, 0x2000, 0x007c, 0x7000,
+	0xa084, 0x0003, 0x7002, 0xc69c, 0xd084, 0x0040, 0x455a, 0x7108,
+	0x0005, 0x7008, 0xa106, 0x00c0, 0x451f, 0xa184, 0x0003, 0x0040,
+	0x458b, 0xa184, 0x01e0, 0x00c0, 0x458b, 0xd1f4, 0x00c0, 0x451f,
+	0xa184, 0x3000, 0xa086, 0x1000, 0x0040, 0x451f, 0x2011, 0x0180,
+	0x710c, 0x8211, 0x0040, 0x4544, 0x7008, 0xd0f4, 0x00c0, 0x451f,
+	0x700c, 0xa106, 0x0040, 0x4539, 0x7007, 0x0012, 0x7108, 0x0005,
+	0x7008, 0xa106, 0x00c0, 0x4546, 0xa184, 0x0003, 0x0040, 0x458b,
+	0xd194, 0x0040, 0x4546, 0xd1f4, 0x0040, 0x458b, 0x7007, 0x0002,
+	0x0078, 0x451f, 0x7108, 0xd1fc, 0x0040, 0x4565, 0x1078, 0x46e0,
+	0x8aff, 0x0040, 0x4501, 0x0078, 0x455a, 0x700c, 0xa08c, 0x03ff,
+	0x0040, 0x4590, 0x7004, 0xd084, 0x0040, 0x4582, 0x7014, 0xa005,
+	0x00c0, 0x457e, 0x7010, 0x7310, 0xa306, 0x00c0, 0x4572, 0x2300,
+	0xa005, 0x0040, 0x4582, 0xa102, 0x00c8, 0x455a, 0x7007, 0x0010,
+	0x0078, 0x458b, 0x8aff, 0x0040, 0x4590, 0x1078, 0x48e7, 0x00c0,
+	0x4585, 0x0040, 0x455a, 0x1078, 0x4629, 0x127f, 0x2000, 0x007c,
+	0x7204, 0x7108, 0xc19c, 0x8103, 0x00c8, 0x459f, 0x1078, 0x46e0,
+	0x0078, 0x4590, 0x7003, 0x0008, 0x127f, 0x2000, 0x007c, 0xa205,
+	0x00c0, 0x458b, 0x7003, 0x0008, 0x127f, 0x2000, 0x007c, 0x6428,
+	0x84ff, 0x0040, 0x45d3, 0x2c70, 0x7004, 0xa0bc, 0x000f, 0xa7b8,
+	0x45e3, 0x273c, 0x87fb, 0x00c0, 0x45c1, 0x0048, 0x45b9, 0x1078,
+	0x290c, 0x609c, 0xa075, 0x0040, 0x45d3, 0x0078, 0x45ac, 0x2039,
+	0x45d8, 0x2704, 0xae68, 0x6808, 0xa630, 0x680c, 0xa529, 0x8421,
+	0x0040, 0x45d3, 0x8738, 0x2704, 0xa005, 0x00c0, 0x45c2, 0x709c,
+	0xa075, 0x00c0, 0x45ac, 0x007c, 0x0000, 0x0005, 0x0009, 0x000d,
+	0x0011, 0x0015, 0x0019, 0x001d, 0x0000, 0x0003, 0x0009, 0x000f,
+	0x0015, 0x001b, 0x0000, 0x0000, 0x45d8, 0x45d5, 0x0000, 0x0000,
+	0x8000, 0x0000, 0x45d8, 0x0000, 0x45e0, 0x45dd, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x45e0, 0x0000, 0x45db, 0x45db, 0x0000, 0x0000,
+	0x8000, 0x0000, 0x45db, 0x0000, 0x45e1, 0x45e1, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x45e1, 0x2079, 0x4d00, 0x2071, 0x0010, 0x7007,
+	0x000a, 0x7007, 0x0002, 0x7003, 0x0001, 0x7810, 0xd0ec, 0x0040,
+	0x4617, 0x2009, 0x0001, 0x2071, 0x0020, 0x0078, 0x461b, 0x2009,
+	0x0002, 0x2071, 0x0050, 0x7007, 0x000a, 0x7007, 0x0002, 0x7003,
+	0x0000, 0x8109, 0x0040, 0x4628, 0x2071, 0x0020, 0x0078, 0x461b,
+	0x007c, 0x7004, 0x8004, 0x00c8, 0x46b2, 0x7108, 0x7008, 0xa106,
+	0x00c0, 0x462d, 0xa184, 0x01e0, 0x0040, 0x463a, 0x1078, 0x4723,
+	0x0078, 0x46da, 0x7007, 0x0012, 0x2019, 0x0000, 0x7108, 0x7008,
+	0xa106, 0x00c0, 0x463e, 0xa184, 0x01e0, 0x0040, 0x464b, 0x1078,
+	0x4723, 0x0078, 0x46da, 0x7810, 0xd0ec, 0x0040, 0x4665, 0x2001,
+	0x04fd, 0x2004, 0xa086, 0x0003, 0x00c0, 0x4669, 0xa184, 0x4000,
+	0x0040, 0x466d, 0xa382, 0x0003, 0x00c8, 0x466d, 0xa184, 0x0004,
+	0x0040, 0x463e, 0x8318, 0x0078, 0x463e, 0x7814, 0xd0ec, 0x00c0,
+	0x466d, 0xa184, 0x4000, 0x00c0, 0x463e, 0xa19c, 0x300c, 0xa386,
+	0x2004, 0x0040, 0x468a, 0xa386, 0x0008, 0x0040, 0x4695, 0x7004,
+	0xd084, 0x00c0, 0x4686, 0x7108, 0x7008, 0xa106, 0x00c0, 0x467b,
+	0xa184, 0x0003, 0x0040, 0x4686, 0x0078, 0x4723, 0xa386, 0x200c,
+	0x00c0, 0x463e, 0x7200, 0x8204, 0x0048, 0x4695, 0x730c, 0xa384,
+	0x03ff, 0x0040, 0x4695, 0x1078, 0x290c, 0x7108, 0x7008, 0xa106,
+	0x00c0, 0x4695, 0xa184, 0x01e0, 0x0040, 0x46a2, 0x1078, 0x4723,
+	0x0078, 0x46da, 0x7007, 0x0012, 0x7000, 0xd084, 0x00c0, 0x46b2,
+	0x7310, 0x7014, 0xa305, 0x0040, 0x46b2, 0x710c, 0xa184, 0x03ff,
+	0x00c0, 0x4629, 0x7108, 0x7008, 0xa106, 0x00c0, 0x46b2, 0xa184,
+	0x01e0, 0x0040, 0x46bf, 0x1078, 0x4723, 0x0078, 0x46da, 0x7007,
+	0x0012, 0x7007, 0x0008, 0x7004, 0xd09c, 0x00c0, 0x46c3, 0x7108,
+	0x7008, 0xa106, 0x00c0, 0x46c7, 0xa184, 0x01e0, 0x0040, 0x46d4,
+	0x1078, 0x4723, 0x0078, 0x46da, 0x7007, 0x0012, 0x7108, 0x8103,
+	0x0048, 0x46c7, 0x7003, 0x0008, 0x007c, 0x7108, 0x0078, 0x46e0,
+	0xa184, 0x01e0, 0x00c0, 0x4723, 0x7108, 0xa184, 0x01e0, 0x00c0,
+	0x4723, 0xa184, 0x0007, 0x0079, 0x46ed, 0x46f7, 0x4707, 0x46f5,
+	0x4707, 0x46f5, 0x4765, 0x46f5, 0x4763, 0x1078, 0x290c, 0x7004,
+	0xa084, 0x0010, 0xc08d, 0x7006, 0x8aff, 0x00c0, 0x4702, 0x2049,
+	0x0000, 0x007c, 0x1078, 0x48e7, 0x00c0, 0x4702, 0x007c, 0x7004,
+	0xa084, 0x0010, 0xc08d, 0x7006, 0x7004, 0xd084, 0x00c0, 0x471b,
+	0x7108, 0x7008, 0xa106, 0x00c0, 0x4710, 0xa184, 0x0003, 0x0040,
+	0x471b, 0x0078, 0x4723, 0x8aff, 0x0040, 0x4722, 0x1078, 0x48e7,
+	0x00c0, 0x471e, 0x007c, 0x7007, 0x0012, 0x7108, 0x00e0, 0x4726,
+	0x2091, 0x6000, 0x00e0, 0x472a, 0x2091, 0x6000, 0x7007, 0x0012,
+	0x7007, 0x0008, 0x7004, 0xd09c, 0x00c0, 0x4732, 0x7007, 0x0012,
+	0x7108, 0xd1fc, 0x00c0, 0x4736, 0x7003, 0x0000, 0x7000, 0xa005,
+	0x00c0, 0x474a, 0x7004, 0xa005, 0x00c0, 0x474a, 0x700c, 0xa005,
+	0x0040, 0x474c, 0x0078, 0x472e, 0x2049, 0x0000, 0xb284, 0x0100,
+	0x0040, 0x4756, 0x2001, 0x0000, 0x0078, 0x4758, 0x2001, 0x0001,
+	0x1078, 0x419b, 0x681b, 0x0002, 0x2051, 0x0000, 0x007c, 0x1078,
+	0x290c, 0x1078, 0x290c, 0x1078, 0x47ad, 0x7210, 0x7114, 0x700c,
+	0xa09c, 0x03ff, 0x2800, 0xa300, 0xa211, 0xa189, 0x0000, 0x1078,
+	0x47ad, 0x2704, 0x2c58, 0xac60, 0x6308, 0x2200, 0xa322, 0x630c,
+	0x2100, 0xa31b, 0x2400, 0xa305, 0x0040, 0x4788, 0x00c8, 0x4788,
+	0x8412, 0x8210, 0x830a, 0xa189, 0x0000, 0x2b60, 0x0078, 0x476f,
+	0x2b60, 0x8a07, 0x007e, 0x6004, 0xa084, 0x0008, 0x0040, 0x4794,
+	0xa7ba, 0x45dd, 0x0078, 0x4796, 0xa7ba, 0x45d5, 0x007f, 0xa73d,
+	0x2c00, 0x6886, 0x6f8a, 0x6c92, 0x6b8e, 0x7108, 0x7008, 0xa106,
+	0x00c0, 0x479d, 0xa184, 0x01e0, 0x0040, 0x47a8, 0x1078, 0x4723,
+	0x7007, 0x0012, 0x1078, 0x4629, 0x007c, 0x8a50, 0x8739, 0x2704,
+	0xa004, 0x00c0, 0x47c1, 0x6000, 0xa064, 0x00c0, 0x47b8, 0x2d60,
+	0x6004, 0xa084, 0x000f, 0xa080, 0x45f3, 0x203c, 0x87fb, 0x1040,
+	0x290c, 0x007c, 0x127e, 0x0d7e, 0x70d4, 0xa084, 0x4600, 0x8004,
+	0x2090, 0x0d7f, 0x6884, 0x2060, 0x6888, 0x6b8c, 0x6c90, 0x8057,
+	0xaad4, 0x00ff, 0xa084, 0x00ff, 0x007e, 0x6804, 0xa084, 0x0008,
+	0x007f, 0x0040, 0x47df, 0xa0b8, 0x45dd, 0x0078, 0x47e1, 0xa0b8,
+	0x45d5, 0xb284, 0x0100, 0x0040, 0x47e8, 0x7e20, 0x0078, 0x47e9,
+	0x7e24, 0xa6b5, 0x000c, 0x681c, 0xd0b4, 0x0040, 0x47f0, 0xc685,
+	0x2400, 0xa305, 0x0040, 0x481a, 0x2c58, 0x2704, 0x6104, 0xac60,
+	0x6000, 0xa400, 0x701a, 0x6004, 0xa301, 0x701e, 0xa184, 0x0008,
+	0x0040, 0x480a, 0x6010, 0xa081, 0x0000, 0x7022, 0x6014, 0xa081,
+	0x0000, 0x7026, 0x6208, 0x2400, 0xa202, 0x7012, 0x620c, 0x2300,
+	0xa203, 0x7016, 0x7602, 0x7007, 0x0001, 0x2b60, 0x1078, 0x4912,
+	0x0078, 0x481c, 0x1078, 0x48e7, 0x00c0, 0x481a, 0x127f, 0x2000,
+	0x007c, 0x127e, 0x0d7e, 0x70d4, 0xa084, 0x4600, 0x8004, 0x2090,
+	0x0d7f, 0x7007, 0x0004, 0x7004, 0xd094, 0x00c0, 0x482b, 0x7003,
+	0x0008, 0x127f, 0x2000, 0x007c, 0x127e, 0x0d7e, 0x70d4, 0xa084,
+	0x4600, 0x8004, 0x007e, 0x2090, 0x007f, 0x0d7f, 0x7e20, 0xb284,
+	0x0100, 0x00c0, 0x4844, 0x7e24, 0xa6b5, 0x000c, 0x681c, 0xd0ac,
+	0x00c0, 0x484f, 0xc685, 0x7003, 0x0000, 0x7007, 0x0004, 0x6828,
+	0x2050, 0x2d60, 0x6004, 0xa0bc, 0x000f, 0xa7b8, 0x45e3, 0x273c,
+	0x87fb, 0x00c0, 0x4865, 0x0048, 0x485f, 0x1078, 0x290c, 0x689c,
+	0xa065, 0x0040, 0x4869, 0x0078, 0x4852, 0x1078, 0x48e7, 0x00c0,
+	0x4865, 0x127f, 0x2000, 0x007c, 0x127e, 0x007e, 0x017e, 0x0d7e,
+	0x70d4, 0xa084, 0x4600, 0x8004, 0x007e, 0x2090, 0x007f, 0x7e20,
+	0xb284, 0x0100, 0x00c0, 0x487d, 0x7e24, 0x0d7f, 0x037f, 0x047f,
+	0xa6b5, 0x000c, 0x681c, 0xd0b4, 0x0040, 0x488b, 0xc685, 0x7003,
+	0x0000, 0x7007, 0x0004, 0x2049, 0x486c, 0x6828, 0xa055, 0x0d7e,
+	0x0040, 0x48e3, 0x2d70, 0x2e60, 0x7004, 0xa0bc, 0x000f, 0xa7b8,
+	0x45e3, 0x273c, 0x87fb, 0x00c0, 0x48a8, 0x0048, 0x48a1, 0x1078,
+	0x290c, 0x709c, 0xa075, 0x2060, 0x0040, 0x48e3, 0x0078, 0x4894,
+	0x2704, 0xae68, 0x6808, 0xa422, 0x680c, 0xa31b, 0x0048, 0x48c1,
+	0x8a51, 0x00c0, 0x48b5, 0x1078, 0x290c, 0x8738, 0x2704, 0xa005,
+	0x00c0, 0x48a9, 0x709c, 0xa075, 0x2060, 0x0040, 0x48e3, 0x0078,
+	0x4894, 0x8422, 0x8420, 0x831a, 0xa399, 0x0000, 0x6908, 0x2400,
+	0xa122, 0x690c, 0x2300, 0xa11b, 0x00c8, 0x48d0, 0x1078, 0x290c,
+	0xb284, 0x0100, 0x0040, 0x48de, 0x2001, 0x4d04, 0x2004, 0xd0ec,
+	0x00c0, 0x48de, 0x2071, 0x0050, 0x0078, 0x48e0, 0x2071, 0x0020,
+	0x0d7f, 0x0078, 0x47f0, 0x0d7f, 0x127f, 0x2000, 0x007c, 0x7008,
+	0x007e, 0xa084, 0x01e0, 0x007f, 0x0040, 0x48f0, 0xa006, 0x007c,
+	0xa084, 0x0003, 0xa086, 0x0003, 0x00c0, 0x48f7, 0x007c, 0x2704,
+	0xac78, 0x7800, 0x701a, 0x7804, 0x701e, 0x7808, 0x7012, 0x780c,
+	0x7016, 0x6004, 0xa084, 0x0008, 0x0040, 0x490a, 0x7810, 0x7022,
+	0x7814, 0x7026, 0x7602, 0x7004, 0xa084, 0x0010, 0xc085, 0x7006,
+	0x2079, 0x4d00, 0x8a51, 0x0040, 0x4936, 0x8738, 0x2704, 0xa005,
+	0x00c0, 0x4928, 0x609c, 0xa005, 0x0040, 0x4937, 0x2060, 0x6004,
+	0xa084, 0x000f, 0xa080, 0x45e3, 0x203c, 0x87fb, 0x1040, 0x290c,
+	0x7008, 0x007e, 0xa084, 0x01e0, 0x007f, 0x0040, 0x4932, 0xa006,
+	0x0078, 0x4937, 0xa084, 0x0003, 0xa086, 0x0003, 0x007c, 0x2051,
+	0x0000, 0x007c, 0x127e, 0x007e, 0x0d7e, 0x70d4, 0xa084, 0x4600,
+	0x8004, 0x2090, 0x0d7f, 0x087f, 0x7108, 0xa184, 0x0003, 0x00c0,
+	0x494f, 0x6828, 0xa005, 0x0040, 0x495f, 0x0078, 0x4517, 0x7108,
+	0xd1fc, 0x0040, 0x4957, 0x1078, 0x46e0, 0x0078, 0x4944, 0x7007,
+	0x0010, 0x7108, 0xd1fc, 0x0040, 0x4959, 0x1078, 0x46e0, 0x7008,
+	0xa086, 0x0008, 0x00c0, 0x4944, 0x7000, 0xa005, 0x00c0, 0x4944,
+	0x7003, 0x0000, 0x2049, 0x0000, 0x127f, 0x2000, 0x007c, 0x127e,
+	0x147e, 0x137e, 0x157e, 0x0c7e, 0x0d7e, 0x70d4, 0xa084, 0x4600,
+	0x8004, 0x2090, 0x0d7f, 0x2049, 0x496f, 0xad80, 0x0011, 0x20a0,
+	0xb284, 0x0100, 0x0040, 0x4992, 0x2001, 0x4d04, 0x2004, 0xd0ec,
+	0x0040, 0x498e, 0x2099, 0x0031, 0x0078, 0x4994, 0x2099, 0x0032,
+	0x0078, 0x4994, 0x2099, 0x0031, 0x700c, 0xa084, 0x03ff, 0x682a,
+	0x7007, 0x0008, 0x7007, 0x0002, 0x7003, 0x0001, 0x0040, 0x49a3,
+	0x8000, 0x80ac, 0x53a5, 0x700c, 0xa084, 0x03ff, 0x0040, 0x49af,
+	0x7007, 0x0004, 0x7004, 0xa084, 0x0004, 0x00c0, 0x49aa, 0x0c7f,
+	0x2049, 0x0000, 0x7003, 0x0000, 0x157f, 0x137f, 0x147f, 0x127f,
+	0x2000, 0x007c, 0x2091, 0x8000, 0x2091, 0x6000, 0x78ac, 0xa005,
+	0x00c0, 0x49d1, 0x7974, 0x70d0, 0xa106, 0x00c0, 0x49d1, 0x781c,
+	0xa005, 0x0040, 0x49d1, 0x781f, 0x0000, 0x0068, 0x49d1, 0x2091,
+	0x4080, 0x7830, 0x8001, 0x7832, 0x00c0, 0x4a59, 0x7834, 0x7832,
+	0x7810, 0xd0ec, 0x00c0, 0x4a52, 0x2061, 0x72c0, 0x2069, 0x4d80,
+	0xc7fd, 0x68d0, 0xa005, 0x0040, 0x49eb, 0x8001, 0x68d2, 0x00c0,
+	0x49eb, 0x1078, 0x4c22, 0x6800, 0xa084, 0x000f, 0x0040, 0x4a00,
+	0xa086, 0x0001, 0x0040, 0x4a00, 0x6844, 0xa00d, 0x0040, 0x4a00,
+	0x2104, 0xa005, 0x0040, 0x4a00, 0x8001, 0x200a, 0x0040, 0x4b95,
+	0x6814, 0xa005, 0x0040, 0x4a25, 0x8001, 0x6816, 0x00c0, 0x4a25,
+	0x68a7, 0x0001, 0x0f7e, 0xd7fc, 0x00c0, 0x4a1a, 0x7810, 0xd0ec,
+	0x0040, 0x4a16, 0x2079, 0x0100, 0x0078, 0x4a1c, 0x2079, 0x0200,
+	0x0078, 0x4a1c, 0x2079, 0x0100, 0x1078, 0x42fe, 0x0f7f, 0x6864,
+	0xa005, 0x0040, 0x4a25, 0x1078, 0x25ea, 0x6880, 0xa005, 0x0040,
+	0x4a32, 0x8001, 0x6882, 0x00c0, 0x4a32, 0x6867, 0x0000, 0x68d4,
+	0xc0dd, 0x68d6, 0x68d4, 0xd0fc, 0x0040, 0x4a4f, 0xc0fc, 0x68d6,
+	0x20a9, 0x0200, 0x6034, 0xa005, 0x0040, 0x4a4b, 0x8001, 0x6036,
+	0x68d4, 0xc0fd, 0x68d6, 0x00c0, 0x4a4b, 0x6010, 0xa005, 0x0040,
+	0x4a4b, 0x1078, 0x25ea, 0xace0, 0x0010, 0x00f0, 0x4a3a, 0xd7fc,
+	0x0040, 0x4a59, 0x2061, 0x52c0, 0x2069, 0x4d40, 0xc7fc, 0x0078,
+	0x49e1, 0x1078, 0x4a95, 0x7838, 0x8001, 0x783a, 0x00c0, 0x4a7b,
+	0x783c, 0x783a, 0x2061, 0x52c0, 0x2069, 0x4d40, 0xc7fc, 0x680c,
+	0xa005, 0x0040, 0x4a6d, 0x1078, 0x4aec, 0xd7fc, 0x00c0, 0x4a7b,
+	0x7810, 0xd0ec, 0x00c0, 0x4a7b, 0x2061, 0x72c0, 0x2069, 0x4d80,
+	0xc7fd, 0x0078, 0x4a67, 0x7814, 0xd0e4, 0x00c0, 0x4a7f, 0x7810,
+	0xd0cc, 0x0040, 0x4a92, 0xd0ac, 0x00c0, 0x4a8b, 0xd0a4, 0x0040,
+	0x4a92, 0xc0ad, 0x7812, 0x2091, 0x8001, 0x0068, 0x4a91, 0x1078,
+	0x2356, 0x007c, 0x2091, 0x8001, 0x007c, 0x7840, 0x8001, 0x7842,
+	0x00c0, 0x4aeb, 0x7844, 0x7842, 0x2091, 0x8000, 0x2061, 0x52c0,
+	0x2069, 0x4d40, 0xc7fc, 0x7810, 0x2079, 0x0200, 0xd0ec, 0x0040,
+	0x4aab, 0x2079, 0x0100, 0x68d8, 0xa005, 0x0040, 0x4ab7, 0x7de0,
+	0xa504, 0x00c0, 0x4ab7, 0x68da, 0x68d4, 0xc0bc, 0x68d6, 0x2079,
+	0x4d00, 0x6810, 0xa005, 0x00c0, 0x4abf, 0x2001, 0x0101, 0x8001,
+	0x6812, 0xd7fc, 0x0040, 0x4ac8, 0xa080, 0x93d0, 0x0078, 0x4aca,
+	0xa080, 0x92c0, 0x2040, 0x2004, 0xa065, 0x0040, 0x4adb, 0x6024,
+	0xa005, 0x0040, 0x4ad7, 0x8001, 0x6026, 0x0040, 0x4b37, 0x6000,
+	0x2c40, 0x0078, 0x4acc, 0xd7fc, 0x00c0, 0x4aeb, 0x7810, 0xd0ec,
+	0x00c0, 0x4aeb, 0x2061, 0x72c0, 0x2069, 0x4d80, 0xc7fd, 0x2079,
+	0x0200, 0x0078, 0x4aab, 0x007c, 0x2009, 0x0000, 0x20a9, 0x0200,
+	0x6008, 0xd09c, 0x0040, 0x4b23, 0x6024, 0xa005, 0x0040, 0x4afc,
+	0x8001, 0x6026, 0x0078, 0x4b21, 0x6008, 0xc09c, 0xd084, 0x00c0,
+	0x4b04, 0xd0ac, 0x0040, 0x4b1b, 0x600a, 0x6004, 0xa06d, 0x0040,
+	0x4b23, 0x0c7e, 0x017e, 0x6010, 0x8001, 0x6012, 0x1078, 0x3d56,
+	0x2d00, 0x2c68, 0x2060, 0x1078, 0x1e42, 0x1078, 0x2004, 0x017f,
+	0x0c7f, 0x0078, 0x4b23, 0xc0bd, 0x600a, 0xa18d, 0x0001, 0x0078,
+	0x4b23, 0xa18d, 0x0100, 0xace0, 0x0010, 0x00f0, 0x4af0, 0xa184,
+	0x0001, 0x0040, 0x4b32, 0xa18c, 0xfffe, 0x690e, 0x1078, 0x25ea,
+	0x0078, 0x4b33, 0x690e, 0x007c, 0x00c0, 0x4b33, 0x786c, 0x6800,
+	0xa005, 0x0040, 0x4b3f, 0x684c, 0xac06, 0x0040, 0x4b95, 0x6864,
+	0xa005, 0x0040, 0x4b47, 0x6027, 0x0001, 0x0078, 0x4b94, 0x2c00,
+	0x687e, 0x6714, 0x6f76, 0x6017, 0x0000, 0x602b, 0x0000, 0x601b,
 	0x0006, 0x60b4, 0xa084, 0x3f00, 0x601e, 0x6020, 0xa084, 0x00ff,
-	0xa085, 0x0060, 0x6022, 0x6000, 0x2042, 0x6714, 0x6f76, 0x1078,
-	0x1e02, 0x6818, 0xa005, 0x0040, 0x48d7, 0x8001, 0x681a, 0x6808,
-	0xc0a4, 0x680a, 0x6810, 0x7908, 0x8109, 0x790a, 0x8001, 0x00d0,
-	0x48e3, 0x1078, 0x28ec, 0x6812, 0x00c0, 0x48e9, 0x7910, 0xc1a5,
-	0x7912, 0x602f, 0x0000, 0x6033, 0x0000, 0x2c68, 0x1078, 0x202a,
-	0xd7fc, 0x00c0, 0x48f7, 0x2069, 0x4a40, 0x0078, 0x48f9, 0x2069,
-	0x4a80, 0x6910, 0xa184, 0x0100, 0x2001, 0x0006, 0x00c0, 0x4903,
-	0x697a, 0x2001, 0x0004, 0x2708, 0x1078, 0x25d1, 0x2091, 0x8001,
-	0x007c, 0x0d7e, 0x694c, 0x2160, 0xd7fc, 0x00c0, 0x491b, 0x7810,
-	0xd0ec, 0x0040, 0x4917, 0x2069, 0x0100, 0x0078, 0x491d, 0x2069,
-	0x0200, 0x0078, 0x491d, 0x2069, 0x0100, 0x1078, 0x2881, 0x601b,
-	0x0006, 0x6858, 0xa084, 0x3f00, 0x601e, 0x6020, 0xa084, 0x00ff,
-	0xa085, 0x0048, 0x6022, 0x602f, 0x0000, 0x6033, 0x0000, 0x6830,
-	0xd0b4, 0x0040, 0x494b, 0x684b, 0x0004, 0x20a9, 0x0014, 0x6848,
-	0xd094, 0x0040, 0x493d, 0x00f0, 0x4937, 0x684b, 0x0009, 0x20a9,
-	0x0014, 0x6848, 0xd084, 0x0040, 0x4947, 0x00f0, 0x4941, 0x20a9,
-	0x00fa, 0x00f0, 0x4949, 0x6808, 0xa084, 0xfffd, 0x680a, 0x681b,
-	0x0047, 0x0d7f, 0x6867, 0x0007, 0x2091, 0x8001, 0x007c, 0x2079,
-	0x4a00, 0x1078, 0x498b, 0x1078, 0x4971, 0x1078, 0x497e, 0x2009,
-	0x0002, 0x2069, 0x4a80, 0x680f, 0x0000, 0x6813, 0x0000, 0x6817,
-	0x0000, 0x8109, 0x0040, 0x4970, 0x2069, 0x4a40, 0x0078, 0x4963,
-	0x007c, 0x7810, 0xd0ec, 0x0040, 0x4979, 0x2019, 0x00cc, 0x0078,
-	0x497b, 0x2019, 0x007b, 0x7b3a, 0x7b3e, 0x007c, 0x7814, 0xd0e4,
-	0x00c0, 0x4986, 0x2019, 0x0040, 0x0078, 0x4988, 0x2019, 0x0026,
-	0x7b42, 0x7b46, 0x007c, 0x7814, 0xd0e4, 0x00c0, 0x4993, 0x2019,
-	0x3f94, 0x0078, 0x4995, 0x2019, 0x2624, 0x7b32, 0x7b36, 0x007c,
-	0x6950, 0xa185, 0x0000, 0x0040, 0x49ad, 0x0c7e, 0x6ac0, 0x2264,
-	0x602b, 0x0000, 0x602f, 0x0000, 0x6008, 0xc0b5, 0x600a, 0x8210,
-	0x8109, 0x00c0, 0x499f, 0x6952, 0x0c7f, 0x007c, 0x70ec, 0xd0dc,
-	0x00c0, 0x49b7, 0xd0d4, 0x0040, 0x49d6, 0x0078, 0x49d9, 0x7810,
-	0xd0ec, 0x0040, 0x49c2, 0xc0f5, 0x7812, 0xd0ec, 0x0040, 0x49dd,
-	0x0078, 0x49d9, 0xae8e, 0x0100, 0x0040, 0x49ce, 0x7814, 0xc0f5,
-	0x7816, 0xd0d4, 0x00c0, 0x49dd, 0x0078, 0x49d9, 0x7814, 0xc0fd,
-	0x7816, 0xd0d4, 0x00c0, 0x49dd, 0x0078, 0x49d9, 0xd0e4, 0x0040,
-	0x49df, 0x7804, 0xd08c, 0x0040, 0x49df, 0x681f, 0x000c, 0x70a0,
-	0x70a2, 0x007c, 0x699a
+	0xa085, 0x0060, 0x6022, 0x6000, 0x2042, 0x1078, 0x1dcb, 0x6818,
+	0xa005, 0x0040, 0x4b65, 0x8001, 0x681a, 0x6808, 0xc0a4, 0x680a,
+	0x6810, 0x7908, 0x8109, 0x790a, 0x8001, 0x00d0, 0x4b71, 0x1078,
+	0x290c, 0x6812, 0x00c0, 0x4b77, 0x7910, 0xc1a5, 0x7912, 0x602f,
+	0x0000, 0x6033, 0x0000, 0x2c68, 0x1078, 0x2013, 0xd7fc, 0x00c0,
+	0x4b85, 0x2069, 0x4d40, 0x0078, 0x4b87, 0x2069, 0x4d80, 0x6910,
+	0xa184, 0x0100, 0x2001, 0x0006, 0x00c0, 0x4b91, 0x697a, 0x2001,
+	0x0004, 0x2708, 0x1078, 0x25dd, 0x007c, 0x0d7e, 0x694c, 0x2160,
+	0xd7fc, 0x00c0, 0x4ba7, 0x7810, 0xd0ec, 0x0040, 0x4ba3, 0x2069,
+	0x0100, 0x0078, 0x4ba9, 0x2069, 0x0200, 0x0078, 0x4ba9, 0x2069,
+	0x0100, 0x1078, 0x288d, 0x601b, 0x0006, 0x6858, 0xa084, 0x3f00,
+	0x601e, 0x6020, 0xa084, 0x00ff, 0xa085, 0x0048, 0x6022, 0x602f,
+	0x0000, 0x6033, 0x0000, 0x6808, 0xa084, 0xfffd, 0x680a, 0x6830,
+	0xd0b4, 0x0040, 0x4bdb, 0x684b, 0x0004, 0x20a9, 0x0014, 0x6848,
+	0xd094, 0x0040, 0x4bcd, 0x00f0, 0x4bc7, 0x684b, 0x0009, 0x20a9,
+	0x0014, 0x6848, 0xd084, 0x0040, 0x4bd7, 0x00f0, 0x4bd1, 0x20a9,
+	0x00fa, 0x00f0, 0x4bd9, 0x681b, 0x0047, 0x0d7f, 0x6867, 0x0007,
+	0x007c, 0x2079, 0x4d00, 0x1078, 0x4c15, 0x1078, 0x4bfb, 0x1078,
+	0x4c08, 0x2009, 0x0002, 0x2069, 0x4d80, 0x680f, 0x0000, 0x6813,
+	0x0000, 0x6817, 0x0000, 0x8109, 0x0040, 0x4bfa, 0x2069, 0x4d40,
+	0x0078, 0x4bed, 0x007c, 0x7810, 0xd0ec, 0x0040, 0x4c03, 0x2019,
+	0x00cc, 0x0078, 0x4c05, 0x2019, 0x007b, 0x7b3a, 0x7b3e, 0x007c,
+	0x7814, 0xd0e4, 0x00c0, 0x4c10, 0x2019, 0x0040, 0x0078, 0x4c12,
+	0x2019, 0x0026, 0x7b42, 0x7b46, 0x007c, 0x7814, 0xd0e4, 0x00c0,
+	0x4c1d, 0x2019, 0x3f94, 0x0078, 0x4c1f, 0x2019, 0x2624, 0x7b32,
+	0x7b36, 0x007c, 0x6950, 0xa185, 0x0000, 0x0040, 0x4c37, 0x0c7e,
+	0x6ac0, 0x2264, 0x602b, 0x0000, 0x602f, 0x0000, 0x6008, 0xc0b5,
+	0x600a, 0x8210, 0x8109, 0x00c0, 0x4c29, 0x6952, 0x0c7f, 0x007c,
+	0x70ec, 0xd0dc, 0x00c0, 0x4c41, 0xd0d4, 0x0040, 0x4c64, 0x0078,
+	0x4c67, 0x2008, 0x7810, 0xd0ec, 0x0040, 0x4c50, 0xd1c4, 0x00c0,
+	0x4c6f, 0xc0f5, 0x7812, 0xd0ec, 0x0040, 0x4c6b, 0x0078, 0x4c67,
+	0xae8e, 0x0100, 0x0040, 0x4c5c, 0x7814, 0xc0f5, 0x7816, 0xd0d4,
+	0x00c0, 0x4c6b, 0x0078, 0x4c67, 0x7814, 0xc0fd, 0x7816, 0xd0d4,
+	0x00c0, 0x4c6b, 0x0078, 0x4c67, 0xd0e4, 0x0040, 0x4c6d, 0x7804,
+	0xd08c, 0x0040, 0x4c6d, 0x681f, 0x000c, 0x70a0, 0x70a2, 0x007c,
+	0x3782
 };
-unsigned short   fw1280ei_length01 = 0x39e3;
+#ifdef UNIQUE_FW_NAME
+unsigned short   fw1280ei_length01 = 0x3c71;
+#else
+unsigned short   risc_code_length01 = 0x3c71;
+#endif
 
diff -urN linux.orig/drivers/scsi/ql2100_fw.h linux/drivers/scsi/ql2100_fw.h
--- linux.orig/drivers/scsi/ql2100_fw.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/ql2100_fw.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,4740 @@
+/************************************************************************
+ *									*
+ * 	 --- ISP2100 Fabric Initiator/Target Firmware ---               *
+ *                   with expanded LUN addressing                       *
+ *                   and FcTape (FCP-2) support                         *
+ *									*
+ *									*
+ ************************************************************************
+  Copyright (C) 2000 and 2001 Qlogic Corporation 
+  (www.qlogic.com)
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+************************************************************************/
+/*
+ *	Firmware Version 1.19.16 (10:36 Nov 02, 2000)
+ */
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_version = 1*1024+19;
+#else
+unsigned short risc_code_version = 1*1024+19;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned char fw2100tp_version_str[] = {1,19,16};
+#else
+unsigned char firmware_version[] = {1,19,16};
+#endif
+
+#ifdef UNIQUE_FW_NAME
+#define fw2100tp_VERSION_STRING "1.19.16"
+#else
+#define FW_VERSION_STRING "1.19.16"
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_addr01 = 0x1000 ;
+#else
+unsigned short risc_code_addr01 = 0x1000 ;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_code01[] = { 
+#else
+unsigned short risc_code01[] = { 
+#endif
+	0x0078, 0x102d, 0x0000, 0x9260, 0x0000, 0x0001, 0x0013, 0x0010,
+	0x0017, 0x2043, 0x4f50, 0x5952, 0x4947, 0x4854, 0x2031, 0x3939,
+	0x3920, 0x514c, 0x4f47, 0x4943, 0x2043, 0x4f52, 0x504f, 0x5241,
+	0x5449, 0x4f4e, 0x2049, 0x5350, 0x3231, 0x3030, 0x2046, 0x6972,
+	0x6d77, 0x6172, 0x6520, 0x2056, 0x6572, 0x7369, 0x6f6e, 0x2030,
+	0x312e, 0x3139, 0x2020, 0x2020, 0x2400, 0x2091, 0x2000, 0x20c1,
+	0x0021, 0x2039, 0xffff, 0x2019, 0xaaaa, 0x2760, 0x2069, 0x7fff,
+	0x20c1, 0x0020, 0x2c2c, 0x2d34, 0x2762, 0x236a, 0x2c24, 0x2d04,
+	0x266a, 0x2562, 0xa406, 0x00c0, 0x1052, 0x20c1, 0x0021, 0x2c2c,
+	0x2362, 0x2c04, 0x2562, 0xa306, 0x0040, 0x1052, 0x20c1, 0x0020,
+	0x2039, 0x8fff, 0x20a1, 0xaa00, 0x2708, 0x810d, 0x810d, 0x810d,
+	0x810d, 0xa18c, 0x000f, 0x2001, 0x000a, 0xa112, 0xa00e, 0x21a8,
+	0x41a4, 0x3400, 0x8211, 0x00c0, 0x105f, 0x2708, 0x3400, 0xa102,
+	0x0040, 0x106f, 0x0048, 0x106f, 0x20a8, 0xa00e, 0x41a4, 0x20a1,
+	0xa260, 0x2009, 0x0000, 0x20a9, 0x07a0, 0x41a4, 0x3400, 0x20c9,
+	0xa7ff, 0x2059, 0x0000, 0x2b78, 0x7823, 0x0004, 0x2089, 0x255d,
+	0x2051, 0xa300, 0x2a70, 0x775e, 0xa786, 0x8fff, 0x0040, 0x1092,
+	0x705b, 0xca00, 0x7057, 0xc9f1, 0x7063, 0x0200, 0x7067, 0x0200,
+	0x0078, 0x109a, 0x7057, 0xba01, 0x7063, 0x0100, 0x7067, 0x0100,
+	0x705b, 0xba00, 0x1078, 0x12df, 0x1078, 0x13c0, 0x1078, 0x1569,
+	0x1078, 0x1ca4, 0x1078, 0x4229, 0x1078, 0x74cf, 0x1078, 0x134b,
+	0x1078, 0x2a3f, 0x1078, 0x4da2, 0x1078, 0x48b2, 0x1078, 0x57df,
+	0x1078, 0x21f7, 0x1078, 0x5abf, 0x1078, 0x5369, 0x1078, 0x210d,
+	0x1078, 0x21d4, 0x2091, 0x3009, 0x7823, 0x0000, 0x0090, 0x10cf,
+	0x7820, 0xa086, 0x0002, 0x00c0, 0x10cf, 0x7823, 0x4000, 0x0068,
+	0x10c7, 0x781b, 0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x2a70,
+	0x7003, 0x0000, 0x2001, 0x017f, 0x2003, 0x0000, 0x2a70, 0x7000,
+	0xa08e, 0x0003, 0x00c0, 0x10ef, 0x1078, 0x35bc, 0x1078, 0x2a67,
+	0x1078, 0x4df2, 0x1078, 0x4a75, 0x2009, 0x0100, 0x2104, 0xa082,
+	0x0002, 0x0048, 0x10f3, 0x1078, 0x57fb, 0x0078, 0x10d6, 0x1079,
+	0x10f7, 0x0078, 0x10dc, 0x1078, 0x6fa9, 0x0078, 0x10eb, 0x1101,
+	0x1102, 0x11be, 0x10ff, 0x1246, 0x12dc, 0x12dd, 0x12de, 0x1078,
+	0x1328, 0x007c, 0x127e, 0x0f7e, 0x2091, 0x8000, 0x7000, 0xa086,
+	0x0001, 0x00c0, 0x1198, 0x1078, 0x3a43, 0x2079, 0x0100, 0x7844,
+	0xa005, 0x00c0, 0x1198, 0x2011, 0x4129, 0x1078, 0x58d4, 0x1078,
+	0x1ab1, 0x780f, 0x00ff, 0x7840, 0xa084, 0xfffb, 0x7842, 0x2011,
+	0x8010, 0x73c0, 0x1078, 0x3579, 0x2001, 0xffff, 0x1078, 0x5975,
+	0x7238, 0xc284, 0x723a, 0x2001, 0xa30c, 0x2014, 0xc2ac, 0x2202,
+	0x1078, 0x6db5, 0x2011, 0x0004, 0x1078, 0x8a59, 0x1078, 0x47ce,
+	0x1078, 0x4211, 0x0040, 0x1144, 0x7083, 0x0001, 0x70bb, 0x0000,
+	0x1078, 0x3bf5, 0x0078, 0x1198, 0x1078, 0x4897, 0x0040, 0x114d,
+	0x7a0c, 0xc2b4, 0x7a0e, 0x0078, 0x1159, 0x1078, 0x8ddf, 0x70c8,
+	0xd09c, 0x00c0, 0x1159, 0x7094, 0xa005, 0x0040, 0x1159, 0x1078,
+	0x41f5, 0x70d3, 0x0000, 0x70cf, 0x0000, 0x72c8, 0x2079, 0xa351,
+	0x7804, 0xd0ac, 0x0040, 0x1165, 0xc295, 0x72ca, 0xa296, 0x0004,
+	0x0040, 0x1186, 0x2011, 0x0001, 0x1078, 0x8a59, 0x708f, 0x0000,
+	0x7093, 0xffff, 0x7003, 0x0002, 0x0f7f, 0x1078, 0x260d, 0x2011,
+	0x0005, 0x1078, 0x6ef2, 0x1078, 0x6109, 0x0c7e, 0x2061, 0x0100,
+	0x60e3, 0x0008, 0x0c7f, 0x127f, 0x0078, 0x119a, 0x708f, 0x0000,
+	0x7093, 0xffff, 0x7003, 0x0002, 0x2011, 0x0005, 0x1078, 0x6ef2,
+	0x1078, 0x6109, 0x0c7e, 0x2061, 0x0100, 0x60e3, 0x0008, 0x0c7f,
+	0x0f7f, 0x127f, 0x007c, 0x0c7e, 0x20a9, 0x0082, 0x2009, 0x007e,
+	0x017e, 0x027e, 0x037e, 0x2110, 0x027e, 0x2019, 0x0029, 0x1078,
+	0x71e0, 0x027f, 0x1078, 0xa190, 0x037f, 0x027f, 0x017f, 0x1078,
+	0x2921, 0x8108, 0x00f0, 0x11a0, 0x0c7f, 0x706b, 0x0000, 0x706c,
+	0xa084, 0x00ff, 0x706e, 0x7097, 0x0000, 0x007c, 0x127e, 0x2091,
+	0x8000, 0x7000, 0xa086, 0x0002, 0x00c0, 0x1244, 0x7090, 0xa086,
+	0xffff, 0x0040, 0x11d1, 0x1078, 0x260d, 0x1078, 0x6109, 0x0078,
+	0x1244, 0x70c8, 0xd09c, 0x0040, 0x11fd, 0xd084, 0x0040, 0x11fd,
+	0x0f7e, 0x2079, 0x0100, 0x790c, 0xc1b5, 0x790e, 0x0f7f, 0xd08c,
+	0x0040, 0x11fd, 0x70cc, 0xa086, 0xffff, 0x0040, 0x11f9, 0x1078,
+	0x278a, 0x1078, 0x6109, 0x70c8, 0xd094, 0x00c0, 0x1244, 0x2011,
+	0x0001, 0x2019, 0x0000, 0x1078, 0x27c2, 0x1078, 0x6109, 0x0078,
+	0x1244, 0x70d0, 0xa005, 0x00c0, 0x1244, 0x708c, 0xa005, 0x00c0,
+	0x1244, 0x1078, 0x4897, 0x00c0, 0x1244, 0x2001, 0xa352, 0x2004,
+	0xd0ac, 0x0040, 0x1227, 0x157e, 0x0c7e, 0x20a9, 0x007f, 0x2009,
+	0x0000, 0x017e, 0x1078, 0x4501, 0x00c0, 0x121a, 0x6000, 0xd0ec,
+	0x00c0, 0x1222, 0x017f, 0x8108, 0x00f0, 0x1211, 0x0c7f, 0x157f,
+	0x0078, 0x1227, 0x017f, 0x0c7f, 0x157f, 0x0078, 0x1244, 0x7003,
+	0x0003, 0x7093, 0xffff, 0x2001, 0x0000, 0x1078, 0x2480, 0x1078,
+	0x35f7, 0x2001, 0xa5ac, 0x2004, 0xa086, 0x0005, 0x00c0, 0x123c,
+	0x2011, 0x0000, 0x1078, 0x6ef2, 0x2011, 0x0000, 0x1078, 0x6efc,
+	0x1078, 0x6109, 0x1078, 0x61d3, 0x127f, 0x007c, 0x017e, 0x0f7e,
+	0x127e, 0x2091, 0x8000, 0x2079, 0x0100, 0x2009, 0x00f7, 0x1078,
+	0x41de, 0x7940, 0xa18c, 0x0010, 0x7942, 0x7924, 0xd1b4, 0x0040,
+	0x125b, 0x7827, 0x0040, 0xd19c, 0x0040, 0x1260, 0x7827, 0x0008,
+	0x007e, 0x037e, 0x157e, 0xa006, 0x1078, 0x5975, 0x7900, 0xa18a,
+	0x0003, 0x0050, 0x1289, 0x7954, 0xd1ac, 0x00c0, 0x1289, 0x2009,
+	0x00f8, 0x1078, 0x41de, 0x7843, 0x0090, 0x7843, 0x0010, 0x20a9,
+	0x09c4, 0x7820, 0xd09c, 0x00c0, 0x1281, 0x7824, 0xd0ac, 0x00c0,
+	0x12ca, 0x00f0, 0x1279, 0x2001, 0x0001, 0x1078, 0x2480, 0x0078,
+	0x12d5, 0x7853, 0x0000, 0x782f, 0x0020, 0x20a9, 0x0050, 0x00e0,
+	0x128f, 0x2091, 0x6000, 0x00f0, 0x128f, 0x7853, 0x0400, 0x782f,
+	0x0000, 0x2009, 0x00f8, 0x1078, 0x41de, 0x20a9, 0x000e, 0x0005,
+	0x00f0, 0x129f, 0x7853, 0x1400, 0x7843, 0x0090, 0x7843, 0x0010,
+	0x2019, 0x61a8, 0x7854, 0x0005, 0x0005, 0xd08c, 0x0040, 0x12b4,
+	0x7824, 0xd0ac, 0x00c0, 0x12ca, 0x8319, 0x00c0, 0x12aa, 0x2009,
+	0xa331, 0x2104, 0x8000, 0x200a, 0xa084, 0xfff0, 0x0040, 0x12c4,
+	0x200b, 0x0000, 0x1078, 0x251e, 0x2001, 0x0001, 0x1078, 0x2480,
+	0x0078, 0x12d3, 0x2001, 0xa331, 0x2003, 0x0000, 0x7828, 0xc09d,
+	0x782a, 0x7827, 0x0048, 0x7853, 0x0400, 0x157f, 0x037f, 0x007f,
+	0x127f, 0x0f7f, 0x017f, 0x007c, 0x007c, 0x007c, 0x007c, 0x2a70,
+	0x2009, 0x0100, 0x2104, 0xa082, 0x0002, 0x0048, 0x12eb, 0x704f,
+	0xffff, 0x0078, 0x12ed, 0x704f, 0x0000, 0x7053, 0xffff, 0x706b,
+	0x0000, 0x706f, 0x0000, 0x1078, 0x8ddf, 0x2061, 0xa58c, 0x6003,
+	0x0909, 0x6007, 0x0000, 0x600b, 0x8800, 0x600f, 0x0200, 0x6013,
+	0x00ff, 0x6017, 0x0003, 0x601b, 0x0000, 0x601f, 0x07d0, 0x2061,
+	0xa594, 0x6003, 0x8000, 0x6007, 0x0000, 0x600b, 0x0000, 0x600f,
+	0x0200, 0x6013, 0x00ff, 0x6017, 0x0000, 0x601b, 0x0001, 0x601f,
+	0x0000, 0x2061, 0xa5a3, 0x6003, 0x514c, 0x6007, 0x4f47, 0x600b,
+	0x4943, 0x600f, 0x2020, 0x2001, 0xa325, 0x2003, 0x0000, 0x007c,
+	0x2091, 0x8000, 0x0068, 0x132a, 0x007e, 0x017e, 0x2079, 0x0000,
+	0x7818, 0xd084, 0x00c0, 0x1330, 0x017f, 0x792e, 0x007f, 0x782a,
+	0x007f, 0x7826, 0x3900, 0x783a, 0x7823, 0x8002, 0x781b, 0x0001,
+	0x2091, 0x5000, 0x2091, 0x4080, 0x2079, 0xa300, 0x7803, 0x0005,
+	0x0078, 0x1348, 0x007c, 0x2071, 0xa300, 0x7158, 0x712e, 0x2021,
+	0x0001, 0xa190, 0x002d, 0xa298, 0x002d, 0x0048, 0x1361, 0x705c,
+	0xa302, 0x00c8, 0x1361, 0x220a, 0x2208, 0x2310, 0x8420, 0x0078,
+	0x1353, 0x200b, 0x0000, 0x74a6, 0x74aa, 0x007c, 0x0e7e, 0x127e,
+	0x2091, 0x8000, 0x2071, 0xa300, 0x70a8, 0xa0ea, 0x0010, 0x00c8,
+	0x1374, 0xa06e, 0x0078, 0x137e, 0x8001, 0x70aa, 0x702c, 0x2068,
+	0x2d04, 0x702e, 0x206b, 0x0000, 0x6807, 0x0000, 0x127f, 0x0e7f,
+	0x007c, 0x0e7e, 0x2071, 0xa300, 0x127e, 0x2091, 0x8000, 0x70a8,
+	0x8001, 0x00c8, 0x138e, 0xa06e, 0x0078, 0x1397, 0x70aa, 0x702c,
+	0x2068, 0x2d04, 0x702e, 0x206b, 0x0000, 0x6807, 0x0000, 0x127f,
+	0x0e7f, 0x007c, 0x0e7e, 0x127e, 0x2091, 0x8000, 0x2071, 0xa300,
+	0x702c, 0x206a, 0x2d00, 0x702e, 0x70a8, 0x8000, 0x70aa, 0x127f,
+	0x0e7f, 0x007c, 0x8dff, 0x0040, 0x13b6, 0x6804, 0x6807, 0x0000,
+	0x007e, 0x1078, 0x139a, 0x0d7f, 0x0078, 0x13aa, 0x007c, 0x0e7e,
+	0x2071, 0xa300, 0x70a8, 0xa08a, 0x0010, 0xa00d, 0x0e7f, 0x007c,
+	0x0e7e, 0x2071, 0xa5d0, 0x7007, 0x0000, 0x701b, 0x0000, 0x701f,
+	0x0000, 0x2071, 0x0000, 0x7010, 0xa085, 0x8004, 0x7012, 0x0e7f,
+	0x007c, 0x0e7e, 0x2270, 0x700b, 0x0000, 0x2071, 0xa5d0, 0x7018,
+	0xa088, 0xa5d9, 0x220a, 0x8000, 0xa084, 0x0007, 0x701a, 0x7004,
+	0xa005, 0x00c0, 0x13e9, 0x0f7e, 0x2079, 0x0010, 0x1078, 0x13fa,
+	0x0f7f, 0x0e7f, 0x007c, 0x0e7e, 0x2071, 0xa5d0, 0x7004, 0xa005,
+	0x00c0, 0x13f8, 0x0f7e, 0x2079, 0x0010, 0x1078, 0x13fa, 0x0f7f,
+	0x0e7f, 0x007c, 0x7000, 0x0079, 0x13fd, 0x1401, 0x146b, 0x1488,
+	0x1488, 0x7018, 0x711c, 0xa106, 0x00c0, 0x1409, 0x7007, 0x0000,
+	0x007c, 0x0d7e, 0xa180, 0xa5d9, 0x2004, 0x700a, 0x2068, 0x8108,
+	0xa18c, 0x0007, 0x711e, 0x7803, 0x0026, 0x6824, 0x7832, 0x6828,
+	0x7836, 0x682c, 0x783a, 0x6830, 0x783e, 0x6810, 0x700e, 0x680c,
+	0x7016, 0x6804, 0x0d7f, 0xd084, 0x0040, 0x142b, 0x7007, 0x0001,
+	0x1078, 0x1430, 0x007c, 0x7007, 0x0002, 0x1078, 0x1446, 0x007c,
+	0x017e, 0x027e, 0x710c, 0x2011, 0x0040, 0xa182, 0x0040, 0x00c8,
+	0x143b, 0x2110, 0xa006, 0x700e, 0x7212, 0x8203, 0x7822, 0x7803,
+	0x0020, 0x7803, 0x0041, 0x027f, 0x017f, 0x007c, 0x017e, 0x027e,
+	0x137e, 0x147e, 0x157e, 0x7014, 0x2098, 0x20a1, 0x0014, 0x7803,
+	0x0026, 0x710c, 0x2011, 0x0040, 0xa182, 0x0040, 0x00c8, 0x145a,
+	0x2110, 0xa006, 0x700e, 0x22a8, 0x53a6, 0x8203, 0x7822, 0x7803,
+	0x0020, 0x3300, 0x7016, 0x7803, 0x0001, 0x157f, 0x147f, 0x137f,
+	0x027f, 0x017f, 0x007c, 0x137e, 0x147e, 0x157e, 0x2099, 0xa3f9,
+	0x20a1, 0x0018, 0x20a9, 0x0008, 0x53a3, 0x7803, 0x0020, 0x127e,
+	0x2091, 0x8000, 0x7803, 0x0041, 0x7007, 0x0003, 0x7000, 0xc084,
+	0x7002, 0x700b, 0xa3f4, 0x127f, 0x157f, 0x147f, 0x137f, 0x007c,
+	0x137e, 0x147e, 0x157e, 0x2001, 0xa428, 0x209c, 0x20a1, 0x0014,
+	0x7803, 0x0026, 0x2001, 0xa429, 0x20ac, 0x53a6, 0x2099, 0xa42a,
+	0x20a1, 0x0018, 0x20a9, 0x0008, 0x53a3, 0x7803, 0x0020, 0x127e,
+	0x2091, 0x8000, 0x7803, 0x0001, 0x7007, 0x0004, 0x7000, 0xc08c,
+	0x7002, 0x700b, 0xa425, 0x127f, 0x157f, 0x147f, 0x137f, 0x007c,
+	0x017e, 0x0e7e, 0x2071, 0xa5d0, 0x0f7e, 0x2079, 0x0010, 0x7904,
+	0x7803, 0x0002, 0xd1fc, 0x0040, 0x14c2, 0xa18c, 0x0700, 0x7004,
+	0x1079, 0x14c6, 0x0f7f, 0x0e7f, 0x017f, 0x007c, 0x13fa, 0x14ce,
+	0x14fb, 0x1523, 0x1556, 0x14cc, 0x0078, 0x14cc, 0xa18c, 0x0700,
+	0x00c0, 0x14f4, 0x137e, 0x147e, 0x157e, 0x7014, 0x20a0, 0x2099,
+	0x0014, 0x7803, 0x0040, 0x7010, 0x20a8, 0x53a5, 0x3400, 0x7016,
+	0x157f, 0x147f, 0x137f, 0x700c, 0xa005, 0x0040, 0x1510, 0x1078,
+	0x1430, 0x007c, 0x7008, 0xa080, 0x0002, 0x2003, 0x0100, 0x7007,
+	0x0000, 0x1078, 0x13fa, 0x007c, 0x7008, 0xa080, 0x0002, 0x2003,
+	0x0200, 0x0078, 0x14ef, 0xa18c, 0x0700, 0x00c0, 0x1506, 0x700c,
+	0xa005, 0x0040, 0x1510, 0x1078, 0x1446, 0x007c, 0x7008, 0xa080,
+	0x0002, 0x2003, 0x0200, 0x7007, 0x0000, 0x1078, 0x13fa, 0x007c,
+	0x0d7e, 0x7008, 0x2068, 0x7830, 0x6826, 0x7834, 0x682a, 0x7838,
+	0x682e, 0x783c, 0x6832, 0x680b, 0x0100, 0x0d7f, 0x7007, 0x0000,
+	0x1078, 0x13fa, 0x007c, 0xa18c, 0x0700, 0x00c0, 0x1550, 0x137e,
+	0x147e, 0x157e, 0x2001, 0xa3f7, 0x2004, 0xa080, 0x000d, 0x20a0,
+	0x2099, 0x0014, 0x7803, 0x0040, 0x20a9, 0x0020, 0x53a5, 0x2001,
+	0xa3f9, 0x2004, 0xd0bc, 0x0040, 0x1546, 0x2001, 0xa402, 0x2004,
+	0xa080, 0x000d, 0x20a0, 0x20a9, 0x0020, 0x53a5, 0x157f, 0x147f,
+	0x137f, 0x7007, 0x0000, 0x1078, 0x4e9b, 0x1078, 0x13fa, 0x007c,
+	0x2011, 0x8003, 0x1078, 0x3579, 0x0078, 0x1554, 0xa18c, 0x0700,
+	0x00c0, 0x1563, 0x2001, 0xa427, 0x2003, 0x0100, 0x7007, 0x0000,
+	0x1078, 0x13fa, 0x007c, 0x2011, 0x8004, 0x1078, 0x3579, 0x0078,
+	0x1567, 0x127e, 0x2091, 0x2100, 0x2079, 0x0030, 0x2071, 0xa5e1,
+	0x7803, 0x0004, 0x7003, 0x0000, 0x700f, 0xa5e7, 0x7013, 0xa5e7,
+	0x780f, 0x0076, 0x7803, 0x0004, 0x127f, 0x007c, 0x6934, 0xa184,
+	0x0007, 0x0079, 0x1583, 0x158b, 0x15d1, 0x158b, 0x158b, 0x158b,
+	0x15b6, 0x159a, 0x158f, 0xa085, 0x0001, 0x0078, 0x15eb, 0x684c,
+	0xd0bc, 0x0040, 0x158b, 0x6860, 0x682e, 0x685c, 0x682a, 0x6858,
+	0x0078, 0x15d9, 0xa18c, 0x00ff, 0xa186, 0x001e, 0x00c0, 0x158b,
+	0x684c, 0xd0bc, 0x0040, 0x158b, 0x6860, 0x682e, 0x685c, 0x682a,
+	0x6804, 0x681a, 0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080,
+	0x2015, 0x2004, 0x6832, 0x6858, 0x0078, 0x15e1, 0xa18c, 0x00ff,
+	0xa186, 0x0015, 0x00c0, 0x158b, 0x684c, 0xd0ac, 0x0040, 0x158b,
+	0x6804, 0x681a, 0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080,
+	0x2015, 0x2004, 0x6832, 0xa006, 0x682e, 0x682a, 0x6858, 0x0078,
+	0x15e1, 0x684c, 0xd0ac, 0x0040, 0x158b, 0xa006, 0x682e, 0x682a,
+	0x6858, 0xa18c, 0x000f, 0xa188, 0x2015, 0x210c, 0x6932, 0x2d08,
+	0x691a, 0x6826, 0x684c, 0xc0dd, 0x684e, 0xa006, 0x680a, 0x697c,
+	0x6912, 0x6980, 0x6916, 0x007c, 0x20e1, 0x0007, 0x20e1, 0x2000,
+	0x2001, 0x020a, 0x2004, 0x82ff, 0x0040, 0x160e, 0xa280, 0x0004,
+	0x0d7e, 0x206c, 0x684c, 0xd0dc, 0x00c0, 0x160a, 0x1078, 0x157e,
+	0x0040, 0x160a, 0x0d7f, 0xa280, 0x0000, 0x2003, 0x0002, 0xa016,
+	0x0078, 0x160e, 0x6808, 0x8000, 0x680a, 0x0d7f, 0x127e, 0x047e,
+	0x037e, 0x027e, 0x2091, 0x2100, 0x027f, 0x037f, 0x047f, 0x7000,
+	0xa005, 0x00c0, 0x1622, 0x7206, 0x2001, 0x1643, 0x007e, 0x2260,
+	0x0078, 0x17be, 0x710c, 0x220a, 0x8108, 0x230a, 0x8108, 0x240a,
+	0x8108, 0xa182, 0xa602, 0x0048, 0x162f, 0x2009, 0xa5e7, 0x710e,
+	0x7010, 0xa102, 0xa082, 0x0009, 0x0040, 0x163a, 0xa080, 0x001b,
+	0x00c0, 0x163d, 0x2009, 0x0138, 0x200a, 0x7000, 0xa005, 0x00c0,
+	0x1643, 0x1078, 0x179f, 0x127f, 0x007c, 0x127e, 0x027e, 0x037e,
+	0x0c7e, 0x007e, 0x2091, 0x2100, 0x007f, 0x047f, 0x037f, 0x027f,
+	0x0d7e, 0x0c7e, 0x2460, 0x6110, 0x2168, 0x6a62, 0x6b5e, 0xa005,
+	0x0040, 0x16cf, 0x6808, 0xa005, 0x0040, 0x173c, 0x7000, 0xa005,
+	0x00c0, 0x1664, 0x0078, 0x16c4, 0x700c, 0x7110, 0xa106, 0x00c0,
+	0x1745, 0x7004, 0xa406, 0x00c0, 0x16c4, 0x2001, 0x0005, 0x2004,
+	0xd08c, 0x0040, 0x1681, 0x047e, 0x1078, 0x18e2, 0x047f, 0x2460,
+	0x6010, 0xa080, 0x0002, 0x2004, 0xa005, 0x0040, 0x173c, 0x0078,
+	0x165e, 0x2001, 0x0207, 0x2004, 0xd09c, 0x00c0, 0x166d, 0x7804,
+	0xa084, 0x6000, 0x0040, 0x1692, 0xa086, 0x6000, 0x0040, 0x1692,
+	0x0078, 0x166d, 0x7100, 0xa186, 0x0002, 0x00c0, 0x16b2, 0x0e7e,
+	0x2b68, 0x6818, 0x2060, 0x1078, 0x1fea, 0x2804, 0xac70, 0x6034,
+	0xd09c, 0x00c0, 0x16a7, 0x7108, 0x720c, 0x0078, 0x16a9, 0x7110,
+	0x7214, 0x6810, 0xa100, 0x6812, 0x6814, 0xa201, 0x6816, 0x0e7f,
+	0x0078, 0x16b6, 0xa186, 0x0001, 0x00c0, 0x16be, 0x7820, 0x6910,
+	0xa100, 0x6812, 0x7824, 0x6914, 0xa101, 0x6816, 0x7803, 0x0004,
+	0x7003, 0x0000, 0x7004, 0x2060, 0x6100, 0xa18e, 0x0004, 0x00c0,
+	0x1745, 0x2009, 0x0048, 0x1078, 0x756c, 0x0078, 0x1745, 0x6808,
+	0xa005, 0x0040, 0x173c, 0x7000, 0xa005, 0x00c0, 0x16d9, 0x0078,
+	0x173c, 0x700c, 0x7110, 0xa106, 0x00c0, 0x16e2, 0x7004, 0xa406,
+	0x00c0, 0x173c, 0x2001, 0x0005, 0x2004, 0xd08c, 0x0040, 0x16f6,
+	0x047e, 0x1078, 0x18e2, 0x047f, 0x2460, 0x6010, 0xa080, 0x0002,
+	0x2004, 0xa005, 0x0040, 0x173c, 0x0078, 0x16d3, 0x2001, 0x0207,
+	0x2004, 0xd09c, 0x00c0, 0x16e2, 0x2001, 0x0005, 0x2004, 0xd08c,
+	0x00c0, 0x16e8, 0x7804, 0xa084, 0x6000, 0x0040, 0x170d, 0xa086,
+	0x6000, 0x0040, 0x170d, 0x0078, 0x16e2, 0x7007, 0x0000, 0xa016,
+	0x2218, 0x7000, 0xa08e, 0x0001, 0x0040, 0x172e, 0xa08e, 0x0002,
+	0x00c0, 0x173c, 0x0c7e, 0x0e7e, 0x6818, 0x2060, 0x1078, 0x1fea,
+	0x2804, 0xac70, 0x6034, 0xd09c, 0x00c0, 0x172a, 0x7308, 0x720c,
+	0x0078, 0x172c, 0x7310, 0x7214, 0x0e7f, 0x0c7f, 0x7820, 0xa318,
+	0x7824, 0xa211, 0x6810, 0xa300, 0x6812, 0x6814, 0xa201, 0x6816,
+	0x7803, 0x0004, 0x7003, 0x0000, 0x6100, 0xa18e, 0x0004, 0x00c0,
+	0x1745, 0x2009, 0x0048, 0x1078, 0x756c, 0x0c7f, 0x0d7f, 0x127f,
+	0x007c, 0x0f7e, 0x0e7e, 0x027e, 0x037e, 0x047e, 0x1078, 0x1af7,
+	0x027e, 0x2071, 0xa5e1, 0x7000, 0xa086, 0x0000, 0x0040, 0x1790,
+	0x7004, 0xac06, 0x00c0, 0x1781, 0x2079, 0x0030, 0x7000, 0xa086,
+	0x0003, 0x0040, 0x1781, 0x7804, 0xd0fc, 0x00c0, 0x177d, 0x2001,
+	0x0207, 0x2004, 0xd09c, 0x00c0, 0x1763, 0x7803, 0x0004, 0x7804,
+	0xd0ac, 0x00c0, 0x176f, 0x7803, 0x0002, 0x7803, 0x0009, 0x7003,
+	0x0003, 0x7007, 0x0000, 0x0078, 0x1781, 0x1078, 0x18e2, 0x0078,
+	0x1753, 0x157e, 0x20a9, 0x0009, 0x2009, 0xa5e7, 0x2104, 0xac06,
+	0x00c0, 0x178b, 0x200a, 0xa188, 0x0003, 0x00f0, 0x1786, 0x157f,
+	0x027f, 0x2001, 0x015d, 0x201c, 0x831a, 0x2302, 0x2001, 0x0138,
+	0x2202, 0x047f, 0x037f, 0x027f, 0x0e7f, 0x0f7f, 0x007c, 0x700c,
+	0x7110, 0xa106, 0x00c0, 0x17a7, 0x7003, 0x0000, 0x007c, 0x2104,
+	0x7006, 0x2060, 0x8108, 0x211c, 0x8108, 0x2124, 0x8108, 0xa182,
+	0xa602, 0x0048, 0x17b5, 0x2009, 0xa5e7, 0x7112, 0x700c, 0xa106,
+	0x00c0, 0x17be, 0x2001, 0x0138, 0x2003, 0x0008, 0x8cff, 0x00c0,
+	0x17c5, 0x1078, 0x1b22, 0x0078, 0x1823, 0x6010, 0x2068, 0x2d58,
+	0x6828, 0xa406, 0x00c0, 0x17d0, 0x682c, 0xa306, 0x0040, 0x17fe,
+	0x601c, 0xa086, 0x0008, 0x0040, 0x17fe, 0x6024, 0xd0f4, 0x00c0,
+	0x17fa, 0xd0d4, 0x0040, 0x17f6, 0x6038, 0xa402, 0x6034, 0xa303,
+	0x0040, 0x17e4, 0x00c8, 0x17f6, 0x643a, 0x6336, 0x6c2a, 0x6b2e,
+	0x047e, 0x037e, 0x2400, 0x6c7c, 0xa402, 0x6812, 0x2300, 0x6b80,
+	0xa303, 0x6816, 0x037f, 0x047f, 0x0078, 0x17fa, 0x1078, 0x8d8e,
+	0x0040, 0x17c1, 0x1078, 0x2035, 0x00c0, 0x17c1, 0x0c7e, 0x7004,
+	0x2060, 0x6024, 0xc0d4, 0x6026, 0x0c7f, 0x684c, 0xd0f4, 0x0040,
+	0x180f, 0x6817, 0xffff, 0x6813, 0xffff, 0x0078, 0x17c1, 0x6824,
+	0x2050, 0x6818, 0x2060, 0x6830, 0x2040, 0x6034, 0xa0cc, 0x000f,
+	0x2009, 0x0011, 0x1078, 0x1824, 0x0040, 0x1822, 0x2009, 0x0001,
+	0x1078, 0x1824, 0x2d58, 0x007c, 0x8aff, 0x0040, 0x18bb, 0xa03e,
+	0x2730, 0x6850, 0xd0fc, 0x00c0, 0x1846, 0xd0f4, 0x00c0, 0x1856,
+	0x0d7e, 0x2804, 0xac68, 0x2900, 0x0079, 0x1836, 0x189d, 0x185d,
+	0x185d, 0x189d, 0x189d, 0x1895, 0x189d, 0x185d, 0x189d, 0x1863,
+	0x1863, 0x189d, 0x189d, 0x189d, 0x188c, 0x1863, 0xc0fc, 0x6852,
+	0x6b6c, 0x6a70, 0x6d1c, 0x6c20, 0x0d7e, 0xd99c, 0x0040, 0x18a0,
+	0x2804, 0xac68, 0x6f08, 0x6e0c, 0x0078, 0x18a0, 0xc0f4, 0x6852,
+	0x6b6c, 0x6a70, 0x0d7e, 0x0078, 0x18a7, 0x6b08, 0x6a0c, 0x6d00,
+	0x6c04, 0x0078, 0x18a0, 0x7b0c, 0xd3bc, 0x0040, 0x1884, 0x7004,
+	0x0e7e, 0x2070, 0x701c, 0x0e7f, 0xa086, 0x0008, 0x00c0, 0x1884,
+	0x7b08, 0xa39c, 0x0fff, 0x2d20, 0x0d7f, 0x0d7e, 0x6a14, 0x82ff,
+	0x00c0, 0x187f, 0x6810, 0xa302, 0x0048, 0x187f, 0x6b10, 0x2011,
+	0x0000, 0x2468, 0x0078, 0x1886, 0x6b10, 0x6a14, 0x6d00, 0x6c04,
+	0x6f08, 0x6e0c, 0x0078, 0x18a0, 0x0d7f, 0x0d7e, 0x6834, 0xa084,
+	0x00ff, 0xa086, 0x001e, 0x00c0, 0x189d, 0x0d7f, 0x1078, 0x1fd1,
+	0x00c0, 0x1824, 0xa00e, 0x0078, 0x18bb, 0x0d7f, 0x1078, 0x1328,
+	0x7b22, 0x7a26, 0x7d32, 0x7c36, 0x7f3a, 0x7e3e, 0x7902, 0x7000,
+	0x8000, 0x7002, 0x0d7f, 0x6828, 0xa300, 0x682a, 0x682c, 0xa201,
+	0x682e, 0x2300, 0x6b10, 0xa302, 0x6812, 0x2200, 0x6a14, 0xa203,
+	0x6816, 0x1078, 0x1fd1, 0x007c, 0x1078, 0x1328, 0x1078, 0x1c52,
+	0x7004, 0x2060, 0x0d7e, 0x6010, 0x2068, 0x7003, 0x0000, 0x1078,
+	0x1ac6, 0x1078, 0x8a44, 0x0040, 0x18db, 0x6808, 0x8001, 0x680a,
+	0x697c, 0x6912, 0x6980, 0x6916, 0x682b, 0xffff, 0x682f, 0xffff,
+	0x6850, 0xc0bd, 0x6852, 0x0d7f, 0x1078, 0x8758, 0x0078, 0x1aad,
+	0x1078, 0x1328, 0x127e, 0x2091, 0x2100, 0x007e, 0x017e, 0x2b68,
+	0x6818, 0x2060, 0x7904, 0x7803, 0x0002, 0xa184, 0x0700, 0x00c0,
+	0x18be, 0xa184, 0x0003, 0xa086, 0x0003, 0x0040, 0x18e0, 0x7000,
+	0x0079, 0x18fa, 0x1902, 0x1904, 0x1a06, 0x1a84, 0x1a9b, 0x1902,
+	0x1902, 0x1902, 0x1078, 0x1328, 0x8001, 0x7002, 0xa184, 0x0880,
+	0x00c0, 0x1919, 0x8aff, 0x0040, 0x199b, 0x2009, 0x0001, 0x1078,
+	0x1824, 0x0040, 0x1aad, 0x2009, 0x0001, 0x1078, 0x1824, 0x0078,
+	0x1aad, 0x7803, 0x0004, 0x7003, 0x0000, 0xd1bc, 0x00c0, 0x1979,
+	0x027e, 0x037e, 0x7808, 0xd0ec, 0x00c0, 0x1930, 0x7c20, 0x7d24,
+	0x7e30, 0x7f34, 0x7803, 0x0009, 0x7003, 0x0004, 0x0078, 0x1932,
+	0x1078, 0x1b9f, 0x6b28, 0x6a2c, 0x2400, 0x686e, 0xa31a, 0x2500,
+	0x6872, 0xa213, 0x6b2a, 0x6a2e, 0x0c7e, 0x7004, 0x2060, 0x6024,
+	0xd0f4, 0x00c0, 0x1945, 0x633a, 0x6236, 0x0c7f, 0x2400, 0x6910,
+	0xa100, 0x6812, 0x2500, 0x6914, 0xa101, 0x6816, 0x037f, 0x027f,
+	0x2600, 0x681e, 0x2700, 0x6822, 0x1078, 0x1fea, 0x2a00, 0x6826,
+	0x2c00, 0x681a, 0x2800, 0x6832, 0x6850, 0xc0fd, 0x6852, 0x6808,
+	0x8001, 0x680a, 0x00c0, 0x196e, 0x684c, 0xd0e4, 0x0040, 0x196e,
+	0x7004, 0x2060, 0x2009, 0x0048, 0x1078, 0x756c, 0x7000, 0xa086,
+	0x0004, 0x0040, 0x1aad, 0x7003, 0x0000, 0x1078, 0x179f, 0x0078,
+	0x1aad, 0x057e, 0x7d0c, 0xd5bc, 0x00c0, 0x1980, 0x1078, 0xa20c,
+	0x057f, 0x1078, 0x1ac6, 0x0f7e, 0x7004, 0x2078, 0x1078, 0x4893,
+	0x0040, 0x198d, 0x7824, 0xc0f5, 0x7826, 0x0f7f, 0x682b, 0xffff,
+	0x682f, 0xffff, 0x6808, 0x8001, 0x680a, 0x697c, 0x6912, 0x6980,
+	0x6916, 0x0078, 0x1aad, 0x7004, 0x0c7e, 0x2060, 0x6024, 0x0c7f,
+	0xd0f4, 0x0040, 0x19a8, 0x6808, 0x8001, 0x680a, 0x0078, 0x1aad,
+	0x684c, 0xc0f5, 0x684e, 0x7814, 0xa005, 0x00c0, 0x19c0, 0x7003,
+	0x0000, 0x6808, 0x8001, 0x680a, 0x00c0, 0x19bc, 0x7004, 0x2060,
+	0x2009, 0x0048, 0x1078, 0x756c, 0x1078, 0x179f, 0x0078, 0x1aad,
+	0x7814, 0x6910, 0xa102, 0x6812, 0x6914, 0xa183, 0x0000, 0x6816,
+	0x7814, 0x7908, 0xa18c, 0x0fff, 0xa188, 0x0007, 0x8114, 0x8214,
+	0x8214, 0xa10a, 0x8104, 0x8004, 0x8004, 0xa20a, 0x810b, 0x810b,
+	0x810b, 0x1078, 0x1b4d, 0x7803, 0x0004, 0x780f, 0xffff, 0x7803,
+	0x0001, 0x7804, 0xd0fc, 0x0040, 0x19e1, 0x7803, 0x0002, 0x7803,
+	0x0004, 0x780f, 0x0076, 0x7004, 0x7007, 0x0000, 0x2060, 0x2009,
+	0x0048, 0x1078, 0x756c, 0x1078, 0x1b81, 0x0040, 0x19bc, 0x7908,
+	0xd1ec, 0x00c0, 0x19ff, 0x2009, 0x0009, 0x0078, 0x1a01, 0x2009,
+	0x0019, 0x7902, 0x7003, 0x0003, 0x0078, 0x1aad, 0x8001, 0x7002,
+	0xd194, 0x0040, 0x1a18, 0x7804, 0xd0fc, 0x00c0, 0x18ea, 0x8aff,
+	0x0040, 0x1aad, 0x2009, 0x0001, 0x1078, 0x1824, 0x0078, 0x1aad,
+	0xa184, 0x0880, 0x00c0, 0x1a25, 0x8aff, 0x0040, 0x1aad, 0x2009,
+	0x0001, 0x1078, 0x1824, 0x0078, 0x1aad, 0x7803, 0x0004, 0x7003,
+	0x0000, 0xd1bc, 0x00c0, 0x1a65, 0x027e, 0x037e, 0x7808, 0xd0ec,
+	0x00c0, 0x1a38, 0x7803, 0x0009, 0x7003, 0x0004, 0x0078, 0x1a3a,
+	0x1078, 0x1b9f, 0x6b28, 0x6a2c, 0x1078, 0x1fea, 0x0d7e, 0x0f7e,
+	0x2d78, 0x2804, 0xac68, 0x6034, 0xd09c, 0x00c0, 0x1a55, 0x6808,
+	0x2008, 0xa31a, 0x680c, 0xa213, 0x7810, 0xa100, 0x7812, 0x690c,
+	0x7814, 0xa101, 0x7816, 0x0078, 0x1a61, 0x6810, 0x2008, 0xa31a,
+	0x6814, 0xa213, 0x7810, 0xa100, 0x7812, 0x6914, 0x7814, 0xa101,
+	0x7816, 0x0f7f, 0x0d7f, 0x0078, 0x1934, 0x057e, 0x7d0c, 0x1078,
+	0xa20c, 0x057f, 0x1078, 0x1ac6, 0x0f7e, 0x7004, 0x2078, 0x1078,
+	0x4893, 0x0040, 0x1a76, 0x7824, 0xc0f5, 0x7826, 0x0f7f, 0x682b,
+	0xffff, 0x682f, 0xffff, 0x6808, 0x8001, 0x680a, 0x697c, 0x6912,
+	0x6980, 0x6916, 0x0078, 0x1aad, 0x7803, 0x0004, 0x7003, 0x0000,
+	0x7004, 0xa00d, 0x0040, 0x1a97, 0x6808, 0x8001, 0x680a, 0x00c0,
+	0x1a97, 0x7004, 0x2060, 0x2009, 0x0048, 0x1078, 0x756c, 0x1078,
+	0x179f, 0x0078, 0x1aad, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004,
+	0x2060, 0x6010, 0xa005, 0x0040, 0x1a97, 0x2068, 0x6808, 0x8000,
+	0x680a, 0x6c28, 0x6b2c, 0x1078, 0x17be, 0x017f, 0x007f, 0x127f,
+	0x007c, 0x127e, 0x2091, 0x2100, 0x7000, 0xa086, 0x0003, 0x00c0,
+	0x1ac4, 0x700c, 0x7110, 0xa106, 0x0040, 0x1ac4, 0x20e1, 0x9028,
+	0x700f, 0xa5e7, 0x7013, 0xa5e7, 0x127f, 0x007c, 0x0c7e, 0x1078,
+	0x1af7, 0x20e1, 0x9028, 0x700c, 0x7110, 0xa106, 0x0040, 0x1aed,
+	0x2104, 0xa005, 0x0040, 0x1ada, 0x2060, 0x6010, 0x2060, 0x6008,
+	0x8001, 0x600a, 0xa188, 0x0003, 0xa182, 0xa602, 0x0048, 0x1ae2,
+	0x2009, 0xa5e7, 0x7112, 0x700c, 0xa106, 0x00c0, 0x1acb, 0x2001,
+	0x0138, 0x2003, 0x0008, 0x0078, 0x1acb, 0x2001, 0x015d, 0x200c,
+	0x810a, 0x2102, 0x2001, 0x0138, 0x2202, 0x0c7f, 0x007c, 0x2001,
+	0x0138, 0x2014, 0x2003, 0x0000, 0x2021, 0xb015, 0x2001, 0x0141,
+	0x201c, 0xd3dc, 0x00c0, 0x1b14, 0x2001, 0x0109, 0x201c, 0xa39c,
+	0x0048, 0x00c0, 0x1b14, 0x2001, 0x0111, 0x201c, 0x83ff, 0x00c0,
+	0x1b14, 0x8421, 0x00c0, 0x1afe, 0x007c, 0x2011, 0x0201, 0x2009,
+	0x003c, 0x2204, 0xa005, 0x00c0, 0x1b21, 0x8109, 0x00c0, 0x1b19,
+	0x007c, 0x007c, 0x1078, 0x1b15, 0x0040, 0x1b4a, 0x7908, 0xd1ec,
+	0x00c0, 0x1b3a, 0x1078, 0x1b81, 0x0040, 0x1b3a, 0x7803, 0x0009,
+	0x7904, 0xd1fc, 0x0040, 0x1b30, 0x7803, 0x0006, 0x1078, 0x1b15,
+	0x0040, 0x1b4a, 0x780c, 0xd0a4, 0x00c0, 0x1b4a, 0x7007, 0x0000,
+	0x1078, 0x1b81, 0x0040, 0x1b4c, 0x7803, 0x0019, 0x7003, 0x0003,
+	0x0078, 0x1b4c, 0x1078, 0x1ac6, 0x007c, 0x0e7e, 0x2071, 0x0200,
+	0x7808, 0xa084, 0xf000, 0xa10d, 0x1078, 0x1af7, 0x2019, 0x5000,
+	0x8319, 0x0040, 0x1b6b, 0x2001, 0xa602, 0x2004, 0xa086, 0x0000,
+	0x0040, 0x1b6b, 0x2001, 0x0021, 0xd0fc, 0x0040, 0x1b58, 0x1078,
+	0x1e5d, 0x0078, 0x1b56, 0x20e1, 0x7000, 0x7324, 0x7420, 0x7028,
+	0x7028, 0x7426, 0x7037, 0x0001, 0x810f, 0x712e, 0x702f, 0x0100,
+	0x7037, 0x0008, 0x7326, 0x7422, 0x2001, 0x0138, 0x2202, 0x0e7f,
+	0x007c, 0x7908, 0xa18c, 0x0fff, 0xa182, 0x0009, 0x0048, 0x1b8c,
+	0xa085, 0x0001, 0x0078, 0x1b9e, 0x2001, 0x020a, 0x81ff, 0x0040,
+	0x1b97, 0x20e1, 0x6000, 0x200c, 0x200c, 0x200c, 0x200c, 0x20e1,
+	0x7000, 0x200c, 0x200c, 0x7003, 0x0000, 0xa006, 0x007c, 0x7c20,
+	0x7d24, 0x7e30, 0x7f34, 0x700c, 0x7110, 0xa106, 0x0040, 0x1c24,
+	0x7004, 0x017e, 0x210c, 0xa106, 0x017f, 0x0040, 0x1c24, 0x0d7e,
+	0x0c7e, 0x216c, 0x2d00, 0xa005, 0x0040, 0x1c22, 0x6824, 0xd0d4,
+	0x00c0, 0x1c22, 0x6810, 0x2068, 0x6850, 0xd0fc, 0x0040, 0x1bec,
+	0x8108, 0x2104, 0x6b2c, 0xa306, 0x00c0, 0x1c22, 0x8108, 0x2104,
+	0x6a28, 0xa206, 0x00c0, 0x1c22, 0x6850, 0xc0fc, 0xc0f5, 0x6852,
+	0x686c, 0x7822, 0x6870, 0x7826, 0x681c, 0x7832, 0x6820, 0x7836,
+	0x6818, 0x2060, 0x6034, 0xd09c, 0x0040, 0x1be7, 0x6830, 0x2004,
+	0xac68, 0x6808, 0x783a, 0x680c, 0x783e, 0x0078, 0x1c20, 0xa006,
+	0x783a, 0x783e, 0x0078, 0x1c20, 0x8108, 0x2104, 0xa005, 0x00c0,
+	0x1c22, 0x8108, 0x2104, 0xa005, 0x00c0, 0x1c22, 0x6850, 0xc0f5,
+	0x6852, 0x6830, 0x2004, 0x6918, 0xa160, 0xa180, 0x000d, 0x2004,
+	0xd09c, 0x00c0, 0x1c12, 0x6008, 0x7822, 0x686e, 0x600c, 0x7826,
+	0x6872, 0x6000, 0x7832, 0x6004, 0x7836, 0xa006, 0x783a, 0x783e,
+	0x0078, 0x1c20, 0x6010, 0x7822, 0x686e, 0x6014, 0x7826, 0x6872,
+	0x6000, 0x7832, 0x6004, 0x7836, 0x6008, 0x783a, 0x600c, 0x783e,
+	0x7803, 0x0011, 0x0c7f, 0x0d7f, 0x007c, 0x0f7e, 0x0e7e, 0x017e,
+	0x027e, 0x2071, 0xa5e1, 0x2079, 0x0030, 0x2011, 0x0050, 0x7000,
+	0xa086, 0x0000, 0x0040, 0x1c4d, 0x8211, 0x0040, 0x1c4b, 0x2001,
+	0x0005, 0x2004, 0xd08c, 0x0040, 0x1c34, 0x7904, 0xa18c, 0x0780,
+	0x017e, 0x1078, 0x18e2, 0x017f, 0x81ff, 0x00c0, 0x1c4b, 0x2011,
+	0x0050, 0x0078, 0x1c2f, 0xa085, 0x0001, 0x027f, 0x017f, 0x0e7f,
+	0x0f7f, 0x007c, 0x7803, 0x0004, 0x2009, 0x0064, 0x7804, 0xd0ac,
+	0x0040, 0x1ca3, 0x8109, 0x00c0, 0x1c56, 0x2009, 0x0100, 0x210c,
+	0xa18a, 0x0003, 0x1048, 0x1328, 0x1078, 0x1f75, 0x0e7e, 0x0f7e,
+	0x2071, 0xa5d0, 0x2079, 0x0010, 0x7004, 0xa086, 0x0000, 0x0040,
+	0x1c9b, 0x7800, 0x007e, 0x7820, 0x007e, 0x7830, 0x007e, 0x7834,
+	0x007e, 0x7838, 0x007e, 0x783c, 0x007e, 0x7803, 0x0004, 0x7823,
+	0x0000, 0x0005, 0x0005, 0x2079, 0x0030, 0x7804, 0xd0ac, 0x10c0,
+	0x1328, 0x2079, 0x0010, 0x007f, 0x783e, 0x007f, 0x783a, 0x007f,
+	0x7836, 0x007f, 0x7832, 0x007f, 0x7822, 0x007f, 0x7802, 0x0f7f,
+	0x0e7f, 0x0078, 0x1ca1, 0x0f7f, 0x0e7f, 0x7804, 0xd0ac, 0x10c0,
+	0x1328, 0x1078, 0x61d3, 0x007c, 0x0e7e, 0x2071, 0xa602, 0x7003,
+	0x0000, 0x0e7f, 0x007c, 0x0d7e, 0xa280, 0x0004, 0x206c, 0x694c,
+	0xd1dc, 0x00c0, 0x1d26, 0x6934, 0xa184, 0x0007, 0x0079, 0x1cb8,
+	0x1cc0, 0x1d11, 0x1cc0, 0x1cc0, 0x1cc0, 0x1cf6, 0x1cd3, 0x1cc2,
+	0x1078, 0x1328, 0x684c, 0xd0b4, 0x0040, 0x1e34, 0x6860, 0x682e,
+	0x6816, 0x685c, 0x682a, 0x6812, 0x687c, 0x680a, 0x6880, 0x680e,
+	0x6958, 0x0078, 0x1d19, 0x6834, 0xa084, 0x00ff, 0xa086, 0x001e,
+	0x00c0, 0x1cc0, 0x684c, 0xd0b4, 0x0040, 0x1e34, 0x6860, 0x682e,
+	0x6816, 0x685c, 0x682a, 0x6812, 0x687c, 0x680a, 0x6880, 0x680e,
+	0x6804, 0x681a, 0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080,
+	0x2015, 0x2004, 0x6832, 0x6958, 0x0078, 0x1d22, 0xa18c, 0x00ff,
+	0xa186, 0x0015, 0x00c0, 0x1d26, 0x684c, 0xd0b4, 0x0040, 0x1e34,
+	0x6804, 0x681a, 0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080,
+	0x2015, 0x2004, 0x6832, 0x6958, 0xa006, 0x682e, 0x682a, 0x0078,
+	0x1d22, 0x684c, 0xd0b4, 0x0040, 0x18bc, 0x6958, 0xa006, 0x682e,
+	0x682a, 0x2d00, 0x681a, 0x6834, 0xa084, 0x000f, 0xa080, 0x2015,
+	0x2004, 0x6832, 0x6926, 0x684c, 0xc0dd, 0x684e, 0x0d7f, 0x007c,
+	0x0f7e, 0x2079, 0x0020, 0x7804, 0xd0fc, 0x10c0, 0x1e5d, 0x0e7e,
+	0x0d7e, 0x2071, 0xa602, 0x7000, 0xa005, 0x00c0, 0x1dab, 0x0c7e,
+	0x7206, 0xa280, 0x0004, 0x205c, 0x7004, 0x2068, 0x7803, 0x0004,
+	0x6818, 0x0d7e, 0x2068, 0x686c, 0x7812, 0x6890, 0x0f7e, 0x20e1,
+	0x9040, 0x2079, 0x0200, 0x781a, 0x2079, 0x0100, 0x8004, 0x78d6,
+	0x0f7f, 0x0d7f, 0x2b68, 0x6824, 0x2050, 0x6818, 0x2060, 0x6830,
+	0x2040, 0x6034, 0xa0cc, 0x000f, 0x6908, 0x2001, 0x04fd, 0x2004,
+	0xa086, 0x0007, 0x0040, 0x1d6d, 0xa184, 0x0007, 0x0040, 0x1d6d,
+	0x017e, 0x2009, 0x0008, 0xa102, 0x017f, 0xa108, 0x791a, 0x7116,
+	0x701e, 0x680c, 0xa081, 0x0000, 0x781e, 0x701a, 0xa006, 0x700e,
+	0x7012, 0x7004, 0x692c, 0x6814, 0xa106, 0x00c0, 0x1d84, 0x6928,
+	0x6810, 0xa106, 0x0040, 0x1d91, 0x037e, 0x047e, 0x6b14, 0x6c10,
+	0x1078, 0x2035, 0x047f, 0x037f, 0x0040, 0x1d91, 0x0c7f, 0x0078,
+	0x1dab, 0x8aff, 0x00c0, 0x1d99, 0x0c7f, 0xa085, 0x0001, 0x0078,
+	0x1dab, 0x127e, 0x2091, 0x8000, 0x2079, 0x0020, 0x2009, 0x0001,
+	0x1078, 0x1daf, 0x0040, 0x1da8, 0x2009, 0x0001, 0x1078, 0x1daf,
+	0x127f, 0x0c7f, 0xa006, 0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x077e,
+	0x067e, 0x057e, 0x047e, 0x037e, 0x027e, 0x8aff, 0x0040, 0x1e2d,
+	0x700c, 0x7214, 0xa23a, 0x7010, 0x7218, 0xa203, 0x0048, 0x1e2c,
+	0xa705, 0x0040, 0x1e2c, 0xa03e, 0x2730, 0x6850, 0xd0fc, 0x00c0,
+	0x1ddf, 0x0d7e, 0x2804, 0xac68, 0x2900, 0x0079, 0x1dcf, 0x1e0e,
+	0x1def, 0x1def, 0x1e0e, 0x1e0e, 0x1e06, 0x1e0e, 0x1def, 0x1e0e,
+	0x1df5, 0x1df5, 0x1e0e, 0x1e0e, 0x1e0e, 0x1dfd, 0x1df5, 0xc0fc,
+	0x6852, 0x6b6c, 0x6a70, 0x6d1c, 0x6c20, 0xd99c, 0x0040, 0x1e12,
+	0x0d7e, 0x2804, 0xac68, 0x6f08, 0x6e0c, 0x0078, 0x1e11, 0x6b08,
+	0x6a0c, 0x6d00, 0x6c04, 0x0078, 0x1e11, 0x6b10, 0x6a14, 0x6d00,
+	0x6c04, 0x6f08, 0x6e0c, 0x0078, 0x1e11, 0x0d7f, 0x0d7e, 0x6834,
+	0xa084, 0x00ff, 0xa086, 0x001e, 0x00c0, 0x1e0e, 0x0d7f, 0x1078,
+	0x1fd1, 0x00c0, 0x1db5, 0xa00e, 0x0078, 0x1e2d, 0x0d7f, 0x1078,
+	0x1328, 0x0d7f, 0x7b22, 0x7a26, 0x7d32, 0x7c36, 0x7f3a, 0x7e3e,
+	0x7902, 0x7000, 0x8000, 0x7002, 0x6828, 0xa300, 0x682a, 0x682c,
+	0xa201, 0x682e, 0x700c, 0xa300, 0x700e, 0x7010, 0xa201, 0x7012,
+	0x1078, 0x1fd1, 0x0078, 0x1e2d, 0xa006, 0x027f, 0x037f, 0x047f,
+	0x057f, 0x067f, 0x077f, 0x007c, 0x1078, 0x1328, 0x027e, 0x2001,
+	0x0105, 0x2003, 0x0010, 0x20e1, 0x9040, 0x7803, 0x0004, 0x7003,
+	0x0000, 0x7004, 0x2060, 0x0d7e, 0x6010, 0x2068, 0x1078, 0x8a44,
+	0x0040, 0x1e4d, 0x6850, 0xc0bd, 0x6852, 0x0d7f, 0x1078, 0x8758,
+	0x20e1, 0x9040, 0x1078, 0x719a, 0x2011, 0x0000, 0x1078, 0x6efc,
+	0x1078, 0x61d3, 0x027f, 0x0078, 0x1f29, 0x127e, 0x2091, 0x2200,
+	0x007e, 0x017e, 0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x2079, 0x0020,
+	0x2071, 0xa602, 0x2b68, 0x6818, 0x2060, 0x7904, 0x7803, 0x0002,
+	0xa184, 0x0700, 0x00c0, 0x1e36, 0x7000, 0x0079, 0x1e77, 0x1f29,
+	0x1e7b, 0x1ef6, 0x1f27, 0x8001, 0x7002, 0xd19c, 0x00c0, 0x1e8f,
+	0x8aff, 0x0040, 0x1eae, 0x2009, 0x0001, 0x1078, 0x1daf, 0x0040,
+	0x1f29, 0x2009, 0x0001, 0x1078, 0x1daf, 0x0078, 0x1f29, 0x7803,
+	0x0004, 0xd194, 0x0040, 0x1e9f, 0x6850, 0xc0fc, 0x6852, 0x8aff,
+	0x00c0, 0x1ea4, 0x684c, 0xc0f5, 0x684e, 0x0078, 0x1ea4, 0x1078,
+	0x1fea, 0x6850, 0xc0fd, 0x6852, 0x2a00, 0x6826, 0x2c00, 0x681a,
+	0x2800, 0x6832, 0x7003, 0x0000, 0x0078, 0x1f29, 0x711c, 0x81ff,
+	0x0040, 0x1ec4, 0x7918, 0x7922, 0x7827, 0x0000, 0x7803, 0x0001,
+	0x7000, 0x8000, 0x7002, 0x700c, 0xa100, 0x700e, 0x7010, 0xa081,
+	0x0000, 0x7012, 0x0078, 0x1f29, 0x0f7e, 0x027e, 0x781c, 0x007e,
+	0x7818, 0x007e, 0x2079, 0x0100, 0x7a14, 0xa284, 0x0004, 0xa085,
+	0x0012, 0x7816, 0x037e, 0x2019, 0x1000, 0x8319, 0x1040, 0x1328,
+	0x7820, 0xd0bc, 0x00c0, 0x1ed5, 0x037f, 0x79c8, 0x007f, 0xa102,
+	0x017f, 0x007e, 0x017e, 0x79c4, 0x007f, 0xa103, 0x78c6, 0x007f,
+	0x78ca, 0xa284, 0x0004, 0xa085, 0x0012, 0x7816, 0x027f, 0x0f7f,
+	0x7803, 0x0008, 0x7003, 0x0000, 0x0078, 0x1f29, 0x8001, 0x7002,
+	0xd194, 0x0040, 0x1f0b, 0x7804, 0xd0fc, 0x00c0, 0x1e6d, 0xd19c,
+	0x00c0, 0x1f25, 0x8aff, 0x0040, 0x1f29, 0x2009, 0x0001, 0x1078,
+	0x1daf, 0x0078, 0x1f29, 0x027e, 0x037e, 0x6b28, 0x6a2c, 0x1078,
+	0x1fea, 0x0d7e, 0x2804, 0xac68, 0x6034, 0xd09c, 0x00c0, 0x1f1e,
+	0x6808, 0xa31a, 0x680c, 0xa213, 0x0078, 0x1f22, 0x6810, 0xa31a,
+	0x6814, 0xa213, 0x0d7f, 0x0078, 0x1e9f, 0x0078, 0x1e9f, 0x1078,
+	0x1328, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x017f, 0x007f, 0x127f,
+	0x007c, 0x0f7e, 0x0e7e, 0x2071, 0xa602, 0x7000, 0xa086, 0x0000,
+	0x0040, 0x1f72, 0x2079, 0x0020, 0x017e, 0x2009, 0x0207, 0x210c,
+	0xd194, 0x0040, 0x1f4f, 0x2009, 0x020c, 0x210c, 0xa184, 0x0003,
+	0x0040, 0x1f4f, 0x20e1, 0x9040, 0x2001, 0x020c, 0x2102, 0x2009,
+	0x0206, 0x2104, 0x2009, 0x0203, 0x210c, 0xa106, 0x00c0, 0x1f5a,
+	0x20e1, 0x9040, 0x7804, 0xd0fc, 0x0040, 0x1f3d, 0x1078, 0x1e5d,
+	0x7000, 0xa086, 0x0000, 0x00c0, 0x1f3d, 0x017f, 0x7803, 0x0004,
+	0x7804, 0xd0ac, 0x00c0, 0x1f68, 0x20e1, 0x9040, 0x7803, 0x0002,
+	0x7003, 0x0000, 0x0e7f, 0x0f7f, 0x007c, 0x027e, 0x0c7e, 0x0d7e,
+	0x0e7e, 0x0f7e, 0x2071, 0xa602, 0x2079, 0x0020, 0x7000, 0xa086,
+	0x0000, 0x0040, 0x1fae, 0x7004, 0x2060, 0x6010, 0x2068, 0x1078,
+	0x8a44, 0x0040, 0x1f98, 0x6850, 0xc0b5, 0x6852, 0x680c, 0x7a1c,
+	0xa206, 0x00c0, 0x1f98, 0x6808, 0x7a18, 0xa206, 0x0040, 0x1fb4,
+	0x2001, 0x0105, 0x2003, 0x0010, 0x20e1, 0x9040, 0x7803, 0x0004,
+	0x7003, 0x0000, 0x7004, 0x2060, 0x1078, 0x8758, 0x20e1, 0x9040,
+	0x1078, 0x719a, 0x2011, 0x0000, 0x1078, 0x6efc, 0x0f7f, 0x0e7f,
+	0x0d7f, 0x0c7f, 0x027f, 0x007c, 0x6810, 0x6a14, 0xa205, 0x00c0,
+	0x1f98, 0x684c, 0xc0dc, 0x684e, 0x2c10, 0x1078, 0x1cab, 0x2001,
+	0x0105, 0x2003, 0x0010, 0x20e1, 0x9040, 0x7803, 0x0004, 0x7003,
+	0x0000, 0x2069, 0xa5ab, 0x6833, 0x0000, 0x683f, 0x0000, 0x0078,
+	0x1fae, 0x8840, 0x2804, 0xa005, 0x00c0, 0x1fe5, 0x6004, 0xa005,
+	0x0040, 0x1fe7, 0x681a, 0x2060, 0x6034, 0xa084, 0x000f, 0xa080,
+	0x2015, 0x2044, 0x88ff, 0x1040, 0x1328, 0x8a51, 0x007c, 0x2051,
+	0x0000, 0x007c, 0x8a50, 0x8841, 0x2804, 0xa005, 0x00c0, 0x2004,
+	0x2c00, 0xad06, 0x0040, 0x1ff9, 0x6000, 0xa005, 0x00c0, 0x1ff9,
+	0x2d00, 0x2060, 0x681a, 0x6034, 0xa084, 0x000f, 0xa080, 0x2025,
+	0x2044, 0x88ff, 0x1040, 0x1328, 0x007c, 0x0000, 0x0011, 0x0015,
+	0x0019, 0x001d, 0x0021, 0x0025, 0x0029, 0x0000, 0x000f, 0x0015,
+	0x001b, 0x0021, 0x0027, 0x0000, 0x0000, 0x0000, 0x200a, 0x2006,
+	0x0000, 0x0000, 0x2014, 0x0000, 0x200a, 0x0000, 0x2011, 0x200e,
+	0x0000, 0x0000, 0x0000, 0x2014, 0x2011, 0x0000, 0x200c, 0x200c,
+	0x0000, 0x0000, 0x2014, 0x0000, 0x200c, 0x0000, 0x2012, 0x2012,
+	0x0000, 0x0000, 0x0000, 0x2014, 0x2012, 0x0a7e, 0x097e, 0x087e,
+	0x6b2e, 0x6c2a, 0x6858, 0xa055, 0x0040, 0x20d8, 0x2d60, 0x6034,
+	0xa0cc, 0x000f, 0xa9c0, 0x2015, 0xa986, 0x0007, 0x0040, 0x2050,
+	0xa986, 0x000e, 0x0040, 0x2050, 0xa986, 0x000f, 0x00c0, 0x2054,
+	0x605c, 0xa422, 0x6060, 0xa31a, 0x2804, 0xa045, 0x00c0, 0x2062,
+	0x0050, 0x205c, 0x0078, 0x20d8, 0x6004, 0xa065, 0x0040, 0x20d8,
+	0x0078, 0x203f, 0x2804, 0xa005, 0x0040, 0x2080, 0xac68, 0xd99c,
+	0x00c0, 0x2070, 0x6808, 0xa422, 0x680c, 0xa31b, 0x0078, 0x2074,
+	0x6810, 0xa422, 0x6814, 0xa31b, 0x0048, 0x209f, 0x2300, 0xa405,
+	0x0040, 0x2086, 0x8a51, 0x0040, 0x20d8, 0x8840, 0x0078, 0x2062,
+	0x6004, 0xa065, 0x0040, 0x20d8, 0x0078, 0x203f, 0x8a51, 0x0040,
+	0x20d8, 0x8840, 0x2804, 0xa005, 0x00c0, 0x2099, 0x6004, 0xa065,
+	0x0040, 0x20d8, 0x6034, 0xa0cc, 0x000f, 0xa9c0, 0x2015, 0x2804,
+	0x2040, 0x2b68, 0x6850, 0xc0fc, 0x6852, 0x0078, 0x20cc, 0x8422,
+	0x8420, 0x831a, 0xa399, 0x0000, 0x0d7e, 0x2b68, 0x6c6e, 0x6b72,
+	0x0d7f, 0xd99c, 0x00c0, 0x20ba, 0x6908, 0x2400, 0xa122, 0x690c,
+	0x2300, 0xa11b, 0x1048, 0x1328, 0x6800, 0xa420, 0x6804, 0xa319,
+	0x0078, 0x20c6, 0x6910, 0x2400, 0xa122, 0x6914, 0x2300, 0xa11b,
+	0x1048, 0x1328, 0x6800, 0xa420, 0x6804, 0xa319, 0x2b68, 0x6c1e,
+	0x6b22, 0x6850, 0xc0fd, 0x6852, 0x2c00, 0x681a, 0x2800, 0x6832,
+	0x2a00, 0x6826, 0x007f, 0x007f, 0x007f, 0xa006, 0x0078, 0x20dd,
+	0x087f, 0x097f, 0x0a7f, 0xa085, 0x0001, 0x007c, 0x2001, 0x0005,
+	0x2004, 0xa084, 0x0007, 0x0079, 0x20e5, 0x20ed, 0x20ee, 0x20f1,
+	0x20f4, 0x20f9, 0x20fc, 0x2101, 0x2106, 0x007c, 0x1078, 0x1e5d,
+	0x007c, 0x1078, 0x18e2, 0x007c, 0x1078, 0x18e2, 0x1078, 0x1e5d,
+	0x007c, 0x1078, 0x14b0, 0x007c, 0x1078, 0x1e5d, 0x1078, 0x14b0,
+	0x007c, 0x1078, 0x18e2, 0x1078, 0x14b0, 0x007c, 0x1078, 0x18e2,
+	0x1078, 0x1e5d, 0x1078, 0x14b0, 0x007c, 0x127e, 0x2091, 0x2300,
+	0x2079, 0x0200, 0x2071, 0xa880, 0x2069, 0xa300, 0x2009, 0x0004,
+	0x7912, 0x7817, 0x0004, 0x1078, 0x24b5, 0x781b, 0x0002, 0x20e1,
+	0x8700, 0x127f, 0x007c, 0x127e, 0x2091, 0x2300, 0x781c, 0xa084,
+	0x0007, 0x0079, 0x212b, 0x214f, 0x2133, 0x2137, 0x213b, 0x2141,
+	0x2145, 0x2149, 0x214d, 0x1078, 0x5372, 0x0078, 0x214f, 0x1078,
+	0x53b3, 0x0078, 0x214f, 0x1078, 0x5372, 0x1078, 0x53b3, 0x0078,
+	0x214f, 0x1078, 0x2151, 0x0078, 0x214f, 0x1078, 0x2151, 0x0078,
+	0x214f, 0x1078, 0x2151, 0x0078, 0x214f, 0x1078, 0x2151, 0x127f,
+	0x007c, 0x007e, 0x017e, 0x027e, 0x7930, 0xa184, 0x0003, 0x0040,
+	0x215d, 0x20e1, 0x9040, 0x0078, 0x2186, 0xa184, 0x0030, 0x0040,
+	0x216e, 0x6a00, 0xa286, 0x0003, 0x00c0, 0x2168, 0x0078, 0x216a,
+	0x1078, 0x4171, 0x20e1, 0x9010, 0x0078, 0x2186, 0xa184, 0x00c0,
+	0x0040, 0x2180, 0x0e7e, 0x037e, 0x047e, 0x057e, 0x2071, 0xa5e1,
+	0x1078, 0x1ac6, 0x057f, 0x047f, 0x037f, 0x0e7f, 0x0078, 0x2186,
+	0xa184, 0x0300, 0x0040, 0x2186, 0x20e1, 0x9020, 0x7932, 0x027f,
+	0x017f, 0x007f, 0x007c, 0x017e, 0x0e7e, 0x0f7e, 0x2071, 0xa300,
+	0x7128, 0x2001, 0xa58f, 0x2102, 0x2001, 0xa597, 0x2102, 0xa182,
+	0x0211, 0x00c8, 0x219f, 0x2009, 0x0008, 0x0078, 0x21c9, 0xa182,
+	0x0259, 0x00c8, 0x21a7, 0x2009, 0x0007, 0x0078, 0x21c9, 0xa182,
+	0x02c1, 0x00c8, 0x21af, 0x2009, 0x0006, 0x0078, 0x21c9, 0xa182,
+	0x0349, 0x00c8, 0x21b7, 0x2009, 0x0005, 0x0078, 0x21c9, 0xa182,
+	0x0421, 0x00c8, 0x21bf, 0x2009, 0x0004, 0x0078, 0x21c9, 0xa182,
+	0x0581, 0x00c8, 0x21c7, 0x2009, 0x0003, 0x0078, 0x21c9, 0x2009,
+	0x0002, 0x2079, 0x0200, 0x7912, 0x7817, 0x0004, 0x1078, 0x24b5,
+	0x0f7f, 0x0e7f, 0x017f, 0x007c, 0x127e, 0x2091, 0x2200, 0x2061,
+	0x0100, 0x2071, 0xa300, 0x6024, 0x6026, 0x6053, 0x0030, 0x6033,
+	0x00ef, 0x60e7, 0x0000, 0x60eb, 0x00ef, 0x60e3, 0x0008, 0x604b,
+	0xf7f7, 0x6043, 0x0000, 0x602f, 0x0080, 0x602f, 0x0000, 0x6007,
+	0x0eaf, 0x600f, 0x00ff, 0x602b, 0x002f, 0x127f, 0x007c, 0x2001,
+	0xa32f, 0x2003, 0x0000, 0x2001, 0xa32e, 0x2003, 0x0001, 0x007c,
+	0x127e, 0x2091, 0x2200, 0x007e, 0x017e, 0x027e, 0x6124, 0xa184,
+	0x002c, 0x00c0, 0x220f, 0xa184, 0x0007, 0x0079, 0x2215, 0xa195,
+	0x0004, 0xa284, 0x0007, 0x0079, 0x2215, 0x2241, 0x221d, 0x2221,
+	0x2225, 0x222b, 0x222f, 0x2235, 0x223b, 0x1078, 0x5ad2, 0x0078,
+	0x2241, 0x1078, 0x5bc1, 0x0078, 0x2241, 0x1078, 0x5bc1, 0x1078,
+	0x5ad2, 0x0078, 0x2241, 0x1078, 0x2246, 0x0078, 0x2241, 0x1078,
+	0x5ad2, 0x1078, 0x2246, 0x0078, 0x2241, 0x1078, 0x5bc1, 0x1078,
+	0x2246, 0x0078, 0x2241, 0x1078, 0x5bc1, 0x1078, 0x5ad2, 0x1078,
+	0x2246, 0x027f, 0x017f, 0x007f, 0x127f, 0x007c, 0x6124, 0xd1ac,
+	0x0040, 0x2342, 0x017e, 0x047e, 0x0c7e, 0x644c, 0xa486, 0xf0f0,
+	0x00c0, 0x2259, 0x2061, 0x0100, 0x644a, 0x6043, 0x0090, 0x6043,
+	0x0010, 0x74c2, 0xa48c, 0xff00, 0x7034, 0xd084, 0x0040, 0x2271,
+	0xa186, 0xf800, 0x00c0, 0x2271, 0x7038, 0xd084, 0x00c0, 0x2271,
+	0xc085, 0x703a, 0x037e, 0x2418, 0x2011, 0x8016, 0x1078, 0x3579,
+	0x037f, 0xa196, 0xff00, 0x0040, 0x22b3, 0x6030, 0xa084, 0x00ff,
+	0x810f, 0xa116, 0x0040, 0x22b3, 0x7130, 0xd184, 0x00c0, 0x22b3,
+	0x2011, 0xa352, 0x2214, 0xd2ec, 0x0040, 0x228e, 0xc18d, 0x7132,
+	0x2011, 0xa352, 0x2214, 0xd2ac, 0x00c0, 0x22b3, 0x6240, 0xa294,
+	0x0010, 0x0040, 0x229a, 0x6248, 0xa294, 0xff00, 0xa296, 0xff00,
+	0x0040, 0x22b3, 0x7030, 0xd08c, 0x0040, 0x2305, 0x7034, 0xd08c,
+	0x00c0, 0x22aa, 0x2001, 0xa30c, 0x200c, 0xd1ac, 0x00c0, 0x2305,
+	0xc1ad, 0x2102, 0x037e, 0x73c0, 0x2011, 0x8013, 0x1078, 0x3579,
+	0x037f, 0x0078, 0x2305, 0x7034, 0xd08c, 0x00c0, 0x22bf, 0x2001,
+	0xa30c, 0x200c, 0xd1ac, 0x00c0, 0x2305, 0xc1ad, 0x2102, 0x037e,
+	0x73c0, 0x2011, 0x8013, 0x1078, 0x3579, 0x037f, 0x7130, 0xc185,
+	0x7132, 0x2011, 0xa352, 0x220c, 0xd1a4, 0x0040, 0x22e9, 0x017e,
+	0x2009, 0x0001, 0x2011, 0x0100, 0x1078, 0x5a6d, 0x2019, 0x000e,
+	0x1078, 0x9e3b, 0xa484, 0x00ff, 0xa080, 0x293f, 0x200c, 0xa18c,
+	0xff00, 0x810f, 0x8127, 0xa006, 0x2009, 0x000e, 0x1078, 0x9ec0,
+	0x017f, 0xd1ac, 0x00c0, 0x22f6, 0x017e, 0x2009, 0x0000, 0x2019,
+	0x0004, 0x1078, 0x27e2, 0x017f, 0x0078, 0x2305, 0x157e, 0x20a9,
+	0x007f, 0x2009, 0x0000, 0x1078, 0x4501, 0x00c0, 0x2301, 0x1078,
+	0x4235, 0x8108, 0x00f0, 0x22fb, 0x157f, 0x0c7f, 0x047f, 0x0f7e,
+	0x2079, 0xa5be, 0x783c, 0xa086, 0x0000, 0x0040, 0x2317, 0x6027,
+	0x0004, 0x783f, 0x0000, 0x2079, 0x0140, 0x7803, 0x0000, 0x0f7f,
+	0x2011, 0x0003, 0x1078, 0x6ef2, 0x2011, 0x0002, 0x1078, 0x6efc,
+	0x1078, 0x6dda, 0x1078, 0x595a, 0x037e, 0x2019, 0x0000, 0x1078,
+	0x6e6c, 0x037f, 0x60e3, 0x0000, 0x017f, 0x2001, 0xa300, 0x2014,
+	0xa296, 0x0004, 0x00c0, 0x233a, 0xd19c, 0x00c0, 0x233a, 0x6228,
+	0xc29d, 0x622a, 0x2003, 0x0001, 0x2001, 0xa321, 0x2003, 0x0000,
+	0x6027, 0x0020, 0xd194, 0x0040, 0x2426, 0x0f7e, 0x2079, 0xa5be,
+	0x783c, 0xa086, 0x0001, 0x00c0, 0x2366, 0x017e, 0x6027, 0x0004,
+	0x783f, 0x0000, 0x2079, 0x0140, 0x7803, 0x1000, 0x7803, 0x0000,
+	0x2079, 0xa5ab, 0x7807, 0x0000, 0x7833, 0x0000, 0x1078, 0x6109,
+	0x1078, 0x61d3, 0x017f, 0x0f7f, 0x0078, 0x2426, 0x0f7f, 0x017e,
+	0x3900, 0xa082, 0xa6cd, 0x00c8, 0x2371, 0x017e, 0x1078, 0x728a,
+	0x017f, 0x6220, 0xd2b4, 0x0040, 0x23dc, 0x1078, 0x595a, 0x1078,
+	0x6c41, 0x6027, 0x0004, 0x0f7e, 0x2019, 0xa5b4, 0x2304, 0xa07d,
+	0x0040, 0x23b2, 0x7804, 0xa086, 0x0032, 0x00c0, 0x23b2, 0x0d7e,
+	0x0c7e, 0x0e7e, 0x2069, 0x0140, 0x618c, 0x6288, 0x7818, 0x608e,
+	0x7808, 0x608a, 0x6043, 0x0002, 0x2001, 0x0003, 0x8001, 0x00c0,
+	0x2396, 0x6043, 0x0000, 0x6803, 0x1000, 0x6803, 0x0000, 0x618e,
+	0x628a, 0x1078, 0x6010, 0x1078, 0x6109, 0x7810, 0x2070, 0x7037,
+	0x0103, 0x2f60, 0x1078, 0x753d, 0x0e7f, 0x0c7f, 0x0d7f, 0x0f7f,
+	0x017f, 0x007c, 0x0f7f, 0x0d7e, 0x2069, 0x0140, 0x6804, 0xa084,
+	0x4000, 0x0040, 0x23bf, 0x6803, 0x1000, 0x6803, 0x0000, 0x0d7f,
+	0x0c7e, 0x2061, 0xa5ab, 0x6028, 0xa09a, 0x00c8, 0x00c8, 0x23cf,
+	0x8000, 0x602a, 0x0c7f, 0x1078, 0x6c33, 0x0078, 0x2425, 0x2019,
+	0xa5b4, 0x2304, 0xa065, 0x0040, 0x23d9, 0x2009, 0x0027, 0x1078,
+	0x756c, 0x0c7f, 0x0078, 0x2425, 0xd2bc, 0x0040, 0x2425, 0x1078,
+	0x5967, 0x6017, 0x0010, 0x6027, 0x0004, 0x0d7e, 0x2069, 0x0140,
+	0x6804, 0xa084, 0x4000, 0x0040, 0x23f1, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x0d7f, 0x0c7e, 0x2061, 0xa5ab, 0x6044, 0xa09a, 0x00c8,
+	0x00c8, 0x2414, 0x8000, 0x6046, 0x603c, 0x0c7f, 0xa005, 0x0040,
+	0x2425, 0x2009, 0x07d0, 0x1078, 0x595f, 0xa080, 0x0007, 0x2004,
+	0xa086, 0x0006, 0x00c0, 0x2410, 0x6017, 0x0012, 0x0078, 0x2425,
+	0x6017, 0x0016, 0x0078, 0x2425, 0x037e, 0x2019, 0x0001, 0x1078,
+	0x6e6c, 0x037f, 0x2019, 0xa5ba, 0x2304, 0xa065, 0x0040, 0x2424,
+	0x2009, 0x004f, 0x1078, 0x756c, 0x0c7f, 0x017f, 0xd19c, 0x0040,
+	0x247c, 0x7034, 0xd0ac, 0x00c0, 0x2457, 0x017e, 0x157e, 0x6027,
+	0x0008, 0x602f, 0x0020, 0x20a9, 0x000a, 0x00f0, 0x2435, 0x602f,
+	0x0000, 0x6150, 0xa185, 0x1400, 0x6052, 0x20a9, 0x0320, 0x00e0,
+	0x243f, 0x2091, 0x6000, 0x6020, 0xd09c, 0x00c0, 0x244e, 0x157f,
+	0x6152, 0x017f, 0x6027, 0x0008, 0x0078, 0x247c, 0x1078, 0x250d,
+	0x00f0, 0x243f, 0x157f, 0x6152, 0x017f, 0x6027, 0x0008, 0x017e,
+	0x6028, 0xc09c, 0x602a, 0x2011, 0x0003, 0x1078, 0x6ef2, 0x2011,
+	0x0002, 0x1078, 0x6efc, 0x1078, 0x6dda, 0x1078, 0x595a, 0x037e,
+	0x2019, 0x0000, 0x1078, 0x6e6c, 0x037f, 0x60e3, 0x0000, 0x1078,
+	0xa22a, 0x1078, 0xa248, 0x2001, 0xa300, 0x2003, 0x0004, 0x6027,
+	0x0008, 0x1078, 0x1246, 0x017f, 0xa18c, 0xffd0, 0x6126, 0x007c,
+	0x007e, 0x017e, 0x027e, 0x0e7e, 0x0f7e, 0x127e, 0x2091, 0x8000,
+	0x2071, 0xa300, 0x71b8, 0x70ba, 0xa116, 0x0040, 0x24ae, 0x81ff,
+	0x0040, 0x2498, 0x2011, 0x8011, 0x1078, 0x3579, 0x0078, 0x24ae,
+	0x2011, 0x8012, 0x1078, 0x3579, 0x2001, 0xa371, 0x2004, 0xd0fc,
+	0x00c0, 0x24ae, 0x037e, 0x0c7e, 0x2061, 0x0100, 0x2019, 0x0028,
+	0x2009, 0x0000, 0x1078, 0x27e2, 0x0c7f, 0x037f, 0x127f, 0x0f7f,
+	0x0e7f, 0x027f, 0x017f, 0x007f, 0x007c, 0x0c7e, 0x0f7e, 0x007e,
+	0x027e, 0x2061, 0x0100, 0xa190, 0x24d1, 0x2204, 0x60f2, 0x2011,
+	0x24de, 0x6000, 0xa082, 0x0003, 0x00c8, 0x24ca, 0x2001, 0x00ff,
+	0x0078, 0x24cb, 0x2204, 0x60ee, 0x027f, 0x007f, 0x0f7f, 0x0c7f,
+	0x007c, 0x0840, 0x0840, 0x0840, 0x0580, 0x0420, 0x0348, 0x02c0,
+	0x0258, 0x0210, 0x01a8, 0x01a8, 0x01a8, 0x01a8, 0x0140, 0x00f8,
+	0x00d0, 0x00b0, 0x00a0, 0x2028, 0xa18c, 0x00ff, 0x2130, 0xa094,
+	0xff00, 0x00c0, 0x24ee, 0x81ff, 0x0040, 0x24f2, 0x1078, 0x5623,
+	0x0078, 0x24f9, 0xa080, 0x293f, 0x200c, 0xa18c, 0xff00, 0x810f,
+	0xa006, 0x007c, 0xa080, 0x293f, 0x200c, 0xa18c, 0x00ff, 0x007c,
+	0x0c7e, 0x2061, 0xa300, 0x6030, 0x0040, 0x2509, 0xc09d, 0x0078,
+	0x250a, 0xc09c, 0x6032, 0x0c7f, 0x007c, 0x007e, 0x157e, 0x0f7e,
+	0x2079, 0x0100, 0x20a9, 0x000a, 0x7854, 0xd08c, 0x00c0, 0x251a,
+	0x00f0, 0x2514, 0x0f7f, 0x157f, 0x007f, 0x007c, 0x0c7e, 0x007e,
+	0x2061, 0x0100, 0x6030, 0x007e, 0x6048, 0x007e, 0x60e4, 0x007e,
+	0x60e8, 0x007e, 0x6050, 0x007e, 0x60f0, 0x007e, 0x60ec, 0x007e,
+	0x600c, 0x007e, 0x6004, 0x007e, 0x6028, 0x007e, 0x60e0, 0x007e,
+	0x602f, 0x0100, 0x602f, 0x0000, 0x0005, 0x0005, 0x0005, 0x0005,
+	0x602f, 0x0040, 0x602f, 0x0000, 0x007f, 0x60e2, 0x007f, 0x602a,
+	0x007f, 0x6006, 0x007f, 0x600e, 0x007f, 0x60ee, 0x007f, 0x60f2,
+	0x007f, 0x6052, 0x007f, 0x60ea, 0x007f, 0x60e6, 0x007f, 0x604a,
+	0x007f, 0x6032, 0x007f, 0x0c7f, 0x007c, 0x257d, 0x2581, 0x2585,
+	0x258b, 0x2591, 0x2597, 0x259d, 0x25a5, 0x25ad, 0x25b3, 0x25b9,
+	0x25c1, 0x25c9, 0x25d1, 0x25d9, 0x25e3, 0x25ed, 0x25ed, 0x25ed,
+	0x25ed, 0x25ed, 0x25ed, 0x25ed, 0x25ed, 0x25ed, 0x25ed, 0x25ed,
+	0x25ed, 0x25ed, 0x25ed, 0x25ed, 0x25ed, 0x107e, 0x007e, 0x0078,
+	0x2606, 0x107e, 0x007e, 0x0078, 0x2606, 0x107e, 0x007e, 0x1078,
+	0x2200, 0x0078, 0x2606, 0x107e, 0x007e, 0x1078, 0x2200, 0x0078,
+	0x2606, 0x107e, 0x007e, 0x1078, 0x20de, 0x0078, 0x2606, 0x107e,
+	0x007e, 0x1078, 0x20de, 0x0078, 0x2606, 0x107e, 0x007e, 0x1078,
+	0x2200, 0x1078, 0x20de, 0x0078, 0x2606, 0x107e, 0x007e, 0x1078,
+	0x2200, 0x1078, 0x20de, 0x0078, 0x2606, 0x107e, 0x007e, 0x1078,
+	0x2123, 0x0078, 0x2606, 0x107e, 0x007e, 0x1078, 0x2123, 0x0078,
+	0x2606, 0x107e, 0x007e, 0x1078, 0x2200, 0x1078, 0x2123, 0x0078,
+	0x2606, 0x107e, 0x007e, 0x1078, 0x2200, 0x1078, 0x2123, 0x0078,
+	0x2606, 0x107e, 0x007e, 0x1078, 0x20de, 0x1078, 0x2123, 0x0078,
+	0x2606, 0x107e, 0x007e, 0x1078, 0x20de, 0x1078, 0x2123, 0x0078,
+	0x2606, 0x107e, 0x007e, 0x1078, 0x2200, 0x1078, 0x20de, 0x1078,
+	0x2123, 0x0078, 0x2606, 0x107e, 0x007e, 0x1078, 0x2200, 0x1078,
+	0x20de, 0x1078, 0x2123, 0x0078, 0x2606, 0x0005, 0x0078, 0x25ed,
+	0xb084, 0x003c, 0x8004, 0x8004, 0x0079, 0x25f6, 0x2606, 0x2583,
+	0x2587, 0x258d, 0x2593, 0x2599, 0x259f, 0x25a7, 0x25af, 0x25b5,
+	0x25bb, 0x25c3, 0x25cb, 0x25d3, 0x25db, 0x25e5, 0x0008, 0x25f0,
+	0x007f, 0x107f, 0x2091, 0x8001, 0x007c, 0x0c7e, 0x027e, 0x047e,
+	0x2021, 0x0000, 0x1078, 0x4897, 0x00c0, 0x2705, 0x70c8, 0xd09c,
+	0x0040, 0x2624, 0xd084, 0x00c0, 0x2624, 0xd0bc, 0x00c0, 0x2705,
+	0x1078, 0x2709, 0x0078, 0x2705, 0xd094, 0x0040, 0x262b, 0x7093,
+	0xffff, 0x0078, 0x2705, 0x2001, 0x010c, 0x203c, 0x7280, 0xd284,
+	0x0040, 0x2694, 0xd28c, 0x00c0, 0x2694, 0x037e, 0x7390, 0xa38e,
+	0xffff, 0x0040, 0x263e, 0x83ff, 0x00c0, 0x2640, 0x2019, 0x0001,
+	0x8314, 0xa2e0, 0xa9c0, 0x2c04, 0xa38c, 0x0001, 0x0040, 0x264d,
+	0xa084, 0xff00, 0x8007, 0x0078, 0x264f, 0xa084, 0x00ff, 0xa70e,
+	0x0040, 0x2689, 0xa08e, 0x0000, 0x0040, 0x2689, 0xa08e, 0x00ff,
+	0x00c0, 0x2666, 0x7230, 0xd284, 0x00c0, 0x268f, 0x7280, 0xc28d,
+	0x7282, 0x7093, 0xffff, 0x037f, 0x0078, 0x2694, 0x2009, 0x0000,
+	0x1078, 0x24e3, 0x1078, 0x4499, 0x00c0, 0x268c, 0x6004, 0xa084,
+	0x00ff, 0xa086, 0x0006, 0x00c0, 0x2683, 0x7030, 0xd08c, 0x0040,
+	0x267d, 0x6000, 0xd0bc, 0x0040, 0x2683, 0x1078, 0x271f, 0x0040,
+	0x268c, 0x0078, 0x2689, 0x1078, 0x2857, 0x1078, 0x274c, 0x0040,
+	0x268c, 0x8318, 0x0078, 0x2640, 0x7392, 0x0078, 0x2691, 0x7093,
+	0xffff, 0x037f, 0x0078, 0x2705, 0xa780, 0x293f, 0x203c, 0xa7bc,
+	0xff00, 0x873f, 0x2041, 0x007e, 0x7090, 0xa096, 0xffff, 0x00c0,
+	0x26a6, 0x2009, 0x0000, 0x28a8, 0x0078, 0x26b2, 0xa812, 0x0048,
+	0x26ae, 0x2008, 0xa802, 0x20a8, 0x0078, 0x26b2, 0x7093, 0xffff,
+	0x0078, 0x2705, 0x2700, 0x157e, 0x017e, 0xa106, 0x0040, 0x26f9,
+	0xc484, 0x1078, 0x4501, 0x0040, 0x26c3, 0x1078, 0x4499, 0x00c0,
+	0x2702, 0x0078, 0x26c4, 0xc485, 0x6004, 0xa084, 0x00ff, 0xa086,
+	0x0006, 0x00c0, 0x26d3, 0x7030, 0xd08c, 0x0040, 0x26f1, 0x6000,
+	0xd0bc, 0x00c0, 0x26f1, 0x7280, 0xd28c, 0x0040, 0x26e9, 0x6004,
+	0xa084, 0x00ff, 0xa082, 0x0006, 0x0048, 0x26f9, 0xd484, 0x00c0,
+	0x26e5, 0x1078, 0x44bc, 0x0078, 0x26e7, 0x1078, 0x2921, 0x0078,
+	0x26f9, 0x1078, 0x2857, 0x1078, 0x274c, 0x0040, 0x2702, 0x0078,
+	0x26f9, 0x1078, 0x28ec, 0x0040, 0x26f9, 0x1078, 0x271f, 0x0040,
+	0x2702, 0x017f, 0x8108, 0x157f, 0x00f0, 0x26b2, 0x7093, 0xffff,
+	0x0078, 0x2705, 0x017f, 0x157f, 0x7192, 0x047f, 0x027f, 0x0c7f,
+	0x007c, 0x0c7e, 0x017e, 0x7093, 0x0000, 0x2009, 0x007e, 0x1078,
+	0x4499, 0x00c0, 0x271c, 0x1078, 0x2857, 0x1078, 0x274c, 0x0040,
+	0x271c, 0x70c8, 0xc0bd, 0x70ca, 0x017f, 0x0c7f, 0x007c, 0x017e,
+	0x077e, 0x0d7e, 0x0c7e, 0x2c68, 0x2001, 0xa356, 0x2004, 0xa084,
+	0x00ff, 0x6842, 0x1078, 0x74d7, 0x0040, 0x2747, 0x2d00, 0x601a,
+	0x601f, 0x0001, 0x2001, 0x0000, 0x1078, 0x442b, 0x2001, 0x0000,
+	0x1078, 0x443f, 0x127e, 0x2091, 0x8000, 0x708c, 0x8000, 0x708e,
+	0x127f, 0x2009, 0x0004, 0x1078, 0x756c, 0xa085, 0x0001, 0x0c7f,
+	0x0d7f, 0x077f, 0x017f, 0x007c, 0x017e, 0x077e, 0x0d7e, 0x0c7e,
+	0x2c68, 0x2001, 0xa356, 0x2004, 0xa084, 0x00ff, 0x6842, 0x1078,
+	0x74d7, 0x0040, 0x2785, 0x2d00, 0x601a, 0x6800, 0xc0c4, 0x6802,
+	0x68a0, 0xa086, 0x007e, 0x0040, 0x276e, 0x6804, 0xa084, 0x00ff,
+	0xa086, 0x0006, 0x00c0, 0x276e, 0x1078, 0x2813, 0x601f, 0x0001,
+	0x2001, 0x0000, 0x1078, 0x442b, 0x2001, 0x0002, 0x1078, 0x443f,
+	0x127e, 0x2091, 0x8000, 0x708c, 0x8000, 0x708e, 0x127f, 0x2009,
+	0x0002, 0x1078, 0x756c, 0xa085, 0x0001, 0x0c7f, 0x0d7f, 0x077f,
+	0x017f, 0x007c, 0x0c7e, 0x027e, 0x2009, 0x0080, 0x1078, 0x4499,
+	0x00c0, 0x2798, 0x1078, 0x279b, 0x0040, 0x2798, 0x70cf, 0xffff,
+	0x027f, 0x0c7f, 0x007c, 0x017e, 0x077e, 0x0d7e, 0x0c7e, 0x2c68,
+	0x1078, 0x74d7, 0x0040, 0x27bd, 0x2d00, 0x601a, 0x601f, 0x0001,
+	0x2001, 0x0000, 0x1078, 0x442b, 0x2001, 0x0002, 0x1078, 0x443f,
+	0x127e, 0x2091, 0x8000, 0x70d0, 0x8000, 0x70d2, 0x127f, 0x2009,
+	0x0002, 0x1078, 0x756c, 0xa085, 0x0001, 0x0c7f, 0x0d7f, 0x077f,
+	0x017f, 0x007c, 0x0c7e, 0x0d7e, 0x127e, 0x2091, 0x8000, 0x2009,
+	0x007f, 0x1078, 0x4499, 0x00c0, 0x27de, 0x2c68, 0x1078, 0x74d7,
+	0x0040, 0x27de, 0x2d00, 0x601a, 0x6312, 0x601f, 0x0001, 0x620a,
+	0x2009, 0x0022, 0x1078, 0x756c, 0xa085, 0x0001, 0x127f, 0x0d7f,
+	0x0c7f, 0x007c, 0x0e7e, 0x0c7e, 0x067e, 0x037e, 0x027e, 0x1078,
+	0x5d60, 0x1078, 0x5d02, 0x1078, 0x7ddf, 0x2130, 0x81ff, 0x0040,
+	0x27f7, 0x20a9, 0x007e, 0x2009, 0x0000, 0x0078, 0x27fb, 0x20a9,
+	0x007f, 0x2009, 0x0000, 0x017e, 0x1078, 0x4501, 0x00c0, 0x2804,
+	0x1078, 0x471b, 0x1078, 0x4235, 0x017f, 0x8108, 0x00f0, 0x27fb,
+	0x86ff, 0x00c0, 0x280d, 0x1078, 0x119b, 0x027f, 0x037f, 0x067f,
+	0x0c7f, 0x0e7f, 0x007c, 0x0e7e, 0x0c7e, 0x037e, 0x027e, 0x017e,
+	0x6218, 0x2270, 0x72a0, 0x027e, 0x2019, 0x0029, 0x1078, 0x5d53,
+	0x077e, 0x2039, 0x0000, 0x1078, 0x5c78, 0x2c08, 0x1078, 0x9c38,
+	0x077f, 0x017f, 0x2e60, 0x1078, 0x471b, 0x6210, 0x6314, 0x1078,
+	0x4235, 0x6212, 0x6316, 0x017f, 0x027f, 0x037f, 0x0c7f, 0x0e7f,
+	0x007c, 0x0e7e, 0x007e, 0x6018, 0xa080, 0x0028, 0x2004, 0xd0bc,
+	0x00c0, 0x284d, 0x2071, 0xa300, 0x708c, 0xa005, 0x0040, 0x284a,
+	0x8001, 0x708e, 0x007f, 0x0e7f, 0x007c, 0x2071, 0xa300, 0x70d0,
+	0xa005, 0x0040, 0x284a, 0x8001, 0x70d2, 0x0078, 0x284a, 0x6000,
+	0xc08c, 0x6002, 0x007c, 0x0f7e, 0x0e7e, 0x0c7e, 0x037e, 0x027e,
+	0x017e, 0x157e, 0x2178, 0x81ff, 0x00c0, 0x286a, 0x20a9, 0x0001,
+	0x0078, 0x2885, 0x2001, 0xa352, 0x2004, 0xd0c4, 0x0040, 0x2881,
+	0xd0a4, 0x0040, 0x2881, 0x047e, 0x6018, 0xa080, 0x0028, 0x2024,
+	0xa4a4, 0x00ff, 0x8427, 0xa006, 0x2009, 0x002d, 0x1078, 0x9ec0,
+	0x047f, 0x20a9, 0x00ff, 0x2011, 0x0000, 0x027e, 0xa28e, 0x007e,
+	0x0040, 0x28c9, 0xa28e, 0x007f, 0x0040, 0x28c9, 0xa28e, 0x0080,
+	0x0040, 0x28c9, 0xa288, 0xa434, 0x210c, 0x81ff, 0x0040, 0x28c9,
+	0x8fff, 0x1040, 0x28d5, 0x0c7e, 0x2160, 0x2001, 0x0001, 0x1078,
+	0x48a2, 0x0c7f, 0x2019, 0x0029, 0x1078, 0x5d53, 0x077e, 0x2039,
+	0x0000, 0x1078, 0x5c78, 0x0c7e, 0x027e, 0x2160, 0x6204, 0xa294,
+	0x00ff, 0xa286, 0x0006, 0x00c0, 0x28b9, 0x6007, 0x0404, 0x0078,
+	0x28be, 0x2001, 0x0004, 0x8007, 0xa215, 0x6206, 0x027f, 0x0c7f,
+	0x017e, 0x2c08, 0x1078, 0x9c38, 0x017f, 0x077f, 0x2160, 0x1078,
+	0x471b, 0x027f, 0x8210, 0x00f0, 0x2885, 0x157f, 0x017f, 0x027f,
+	0x037f, 0x0c7f, 0x0e7f, 0x0f7f, 0x007c, 0x047e, 0x027e, 0x017e,
+	0x2001, 0xa352, 0x2004, 0xd0c4, 0x0040, 0x28e8, 0xd0a4, 0x0040,
+	0x28e8, 0xa006, 0x2220, 0x8427, 0x2009, 0x0029, 0x1078, 0x9ec0,
+	0x017f, 0x027f, 0x047f, 0x007c, 0x017e, 0x027e, 0x037e, 0x0c7e,
+	0x7280, 0x82ff, 0x0040, 0x291a, 0xa290, 0xa352, 0x2214, 0xd2ac,
+	0x00c0, 0x291a, 0x2100, 0x1078, 0x24fa, 0x81ff, 0x0040, 0x291c,
+	0x2019, 0x0001, 0x8314, 0xa2e0, 0xa9c0, 0x2c04, 0xd384, 0x0040,
+	0x290e, 0xa084, 0xff00, 0x8007, 0x0078, 0x2910, 0xa084, 0x00ff,
+	0xa116, 0x0040, 0x291c, 0xa096, 0x00ff, 0x0040, 0x291a, 0x8318,
+	0x0078, 0x2902, 0xa085, 0x0001, 0x0c7f, 0x037f, 0x027f, 0x017f,
+	0x007c, 0x017e, 0x0c7e, 0x127e, 0x2091, 0x8000, 0xa180, 0xa434,
+	0x2004, 0xa065, 0x0040, 0x293b, 0x017e, 0x0c7e, 0x1078, 0x8ec0,
+	0x017f, 0x1040, 0x1328, 0x611a, 0x1078, 0x2813, 0x1078, 0x753d,
+	0x017f, 0x1078, 0x44bc, 0x127f, 0x0c7f, 0x017f, 0x007c, 0x7eef,
+	0x7de8, 0x7ce4, 0x80e2, 0x7be1, 0x80e0, 0x80dc, 0x80da, 0x7ad9,
+	0x80d6, 0x80d5, 0x80d4, 0x80d3, 0x80d2, 0x80d1, 0x79ce, 0x78cd,
+	0x80cc, 0x80cb, 0x80ca, 0x80c9, 0x80c7, 0x80c6, 0x77c5, 0x76c3,
+	0x80bc, 0x80ba, 0x75b9, 0x80b6, 0x74b5, 0x73b4, 0x72b3, 0x80b2,
+	0x80b1, 0x80ae, 0x71ad, 0x80ac, 0x70ab, 0x6faa, 0x6ea9, 0x80a7,
+	0x6da6, 0x6ca5, 0x6ba3, 0x6a9f, 0x699e, 0x689d, 0x809b, 0x8098,
+	0x6797, 0x6690, 0x658f, 0x6488, 0x6384, 0x6282, 0x8081, 0x8080,
+	0x617c, 0x607a, 0x8079, 0x5f76, 0x8075, 0x8074, 0x8073, 0x8072,
+	0x8071, 0x806e, 0x5e6d, 0x806c, 0x5d6b, 0x5c6a, 0x5b69, 0x8067,
+	0x5a66, 0x5965, 0x5863, 0x575c, 0x565a, 0x5559, 0x8056, 0x8055,
+	0x5454, 0x5353, 0x5252, 0x5151, 0x504e, 0x4f4d, 0x804c, 0x804b,
+	0x4e4a, 0x4d49, 0x8047, 0x4c46, 0x8045, 0x8043, 0x803c, 0x803a,
+	0x8039, 0x8036, 0x4b35, 0x8034, 0x4a33, 0x4932, 0x4831, 0x802e,
+	0x472d, 0x462c, 0x452b, 0x442a, 0x4329, 0x4227, 0x8026, 0x8025,
+	0x4123, 0x401f, 0x3f1e, 0x3e1d, 0x3d1b, 0x3c18, 0x8017, 0x8010,
+	0x3b0f, 0x3a08, 0x8004, 0x3902, 0x8001, 0x8000, 0x8000, 0x3800,
+	0x3700, 0x3600, 0x8000, 0x3500, 0x8000, 0x8000, 0x8000, 0x3400,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x3300, 0x3200,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x3100, 0x3000,
+	0x8000, 0x8000, 0x2f00, 0x8000, 0x2e00, 0x2d00, 0x2c00, 0x8000,
+	0x8000, 0x8000, 0x2b00, 0x8000, 0x2a00, 0x2900, 0x2800, 0x8000,
+	0x2700, 0x2600, 0x2500, 0x2400, 0x2300, 0x2200, 0x8000, 0x8000,
+	0x2100, 0x2000, 0x1f00, 0x1e00, 0x1d00, 0x1c00, 0x8000, 0x8000,
+	0x1b00, 0x1a00, 0x8000, 0x1900, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x1800, 0x8000, 0x1700, 0x1600, 0x1500, 0x8000,
+	0x1400, 0x1300, 0x1200, 0x1100, 0x1000, 0x0f00, 0x8000, 0x8000,
+	0x0e00, 0x0d00, 0x0c00, 0x0b00, 0x0a00, 0x0900, 0x8000, 0x8000,
+	0x0800, 0x0700, 0x8000, 0x0600, 0x8000, 0x8000, 0x8000, 0x0500,
+	0x0400, 0x0300, 0x8000, 0x0200, 0x8000, 0x8000, 0x8000, 0x0100,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x0000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x2071,
+	0xa381, 0x7003, 0x0002, 0xa006, 0x7012, 0x7016, 0x703a, 0x703e,
+	0x7033, 0xa391, 0x7037, 0xa391, 0x7007, 0x0001, 0x2061, 0xa3d1,
+	0x6003, 0x0002, 0x007c, 0x0090, 0x2a66, 0x0068, 0x2a66, 0x2071,
+	0xa381, 0x2b78, 0x7818, 0xd084, 0x00c0, 0x2a66, 0x2a60, 0x7820,
+	0xa08e, 0x0069, 0x00c0, 0x2b56, 0x0079, 0x2aea, 0x007c, 0x2071,
+	0xa381, 0x7004, 0x0079, 0x2a6c, 0x2a70, 0x2a71, 0x2a7b, 0x2a8d,
+	0x007c, 0x0090, 0x2a7a, 0x0068, 0x2a7a, 0x2b78, 0x7818, 0xd084,
+	0x0040, 0x2a99, 0x007c, 0x2b78, 0x2061, 0xa3d1, 0x6008, 0xa08e,
+	0x0100, 0x0040, 0x2a88, 0xa086, 0x0200, 0x0040, 0x2b4e, 0x007c,
+	0x7014, 0x2068, 0x2a60, 0x7018, 0x007a, 0x7010, 0x2068, 0x6834,
+	0xa086, 0x0103, 0x0040, 0x2a95, 0x007c, 0x2a60, 0x2b78, 0x7018,
+	0x007a, 0x2a60, 0x7820, 0xa08a, 0x0040, 0x00c8, 0x2aa2, 0x61b8,
+	0x0079, 0x2aaa, 0x2100, 0xa08a, 0x003f, 0x00c8, 0x2b4a, 0x61b8,
+	0x0079, 0x2aea, 0x2b2c, 0x2b5e, 0x2b66, 0x2b6a, 0x2b72, 0x2b78,
+	0x2b7c, 0x2b88, 0x2b8c, 0x2b96, 0x2b9a, 0x2b4a, 0x2b4a, 0x2b4a,
+	0x2b9e, 0x2b4a, 0x2bae, 0x2bc5, 0x2bdc, 0x2c58, 0x2c5d, 0x2c8a,
+	0x2ce4, 0x2cf5, 0x2d13, 0x2d54, 0x2d5e, 0x2d6b, 0x2d7e, 0x2d9d,
+	0x2da6, 0x2de3, 0x2de9, 0x2b4a, 0x2e05, 0x2b4a, 0x2b4a, 0x2b4a,
+	0x2b4a, 0x2b4a, 0x2e0c, 0x2e16, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a,
+	0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a, 0x2e1e, 0x2b4a, 0x2b4a, 0x2b4a,
+	0x2b4a, 0x2b4a, 0x2e30, 0x2e47, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a,
+	0x2b4a, 0x2b4a, 0x2e59, 0x2eb0, 0x2f0e, 0x2f1f, 0x2b4a, 0x2b4a,
+	0x2b4a, 0x38f1, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a,
+	0x2b4a, 0x2b4a, 0x2b96, 0x2b9a, 0x2f36, 0x2b4a, 0x2f43, 0x397d,
+	0x39da, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a,
+	0x2b4a, 0x2b4a, 0x2f90, 0x30c5, 0x30e1, 0x30ed, 0x3150, 0x31a9,
+	0x31b4, 0x31f3, 0x3202, 0x3211, 0x3214, 0x2f47, 0x3238, 0x3284,
+	0x3291, 0x33a2, 0x34cd, 0x34f7, 0x3604, 0x3614, 0x3621, 0x365b,
+	0x372a, 0x2b4a, 0x2b4a, 0x2b4a, 0x2b4a, 0x3792, 0x37ae, 0x3828,
+	0x38e2, 0x713c, 0x0078, 0x2b2c, 0x2021, 0x4000, 0x1078, 0x3553,
+	0x127e, 0x2091, 0x8000, 0x0068, 0x2b39, 0x7818, 0xd084, 0x0040,
+	0x2b3c, 0x127f, 0x0078, 0x2b30, 0x7c22, 0x7926, 0x7a2a, 0x7b2e,
+	0x781b, 0x0001, 0x2091, 0x4080, 0x7007, 0x0001, 0x2091, 0x5000,
+	0x127f, 0x007c, 0x2021, 0x4001, 0x0078, 0x2b2e, 0x2021, 0x4002,
+	0x0078, 0x2b2e, 0x2021, 0x4003, 0x0078, 0x2b2e, 0x2021, 0x4005,
+	0x0078, 0x2b2e, 0x2021, 0x4006, 0x0078, 0x2b2e, 0xa02e, 0x2520,
+	0x7b28, 0x7a2c, 0x7824, 0x7930, 0x0078, 0x3562, 0x7823, 0x0004,
+	0x7824, 0x007a, 0xa02e, 0x2520, 0x7b28, 0x7a2c, 0x7824, 0x7930,
+	0x0078, 0x3566, 0x7924, 0x7828, 0x2114, 0x200a, 0x0078, 0x2b2c,
+	0x7924, 0x2114, 0x0078, 0x2b2c, 0x2099, 0x0009, 0x20a1, 0x0009,
+	0x20a9, 0x0007, 0x53a3, 0x7924, 0x7a28, 0x7b2c, 0x0078, 0x2b2c,
+	0x7824, 0x2060, 0x0078, 0x2ba0, 0x2009, 0x0001, 0x2011, 0x0013,
+	0x2019, 0x0010, 0x783b, 0x0017, 0x0078, 0x2b2c, 0x7d38, 0x7c3c,
+	0x0078, 0x2b60, 0x7d38, 0x7c3c, 0x0078, 0x2b6c, 0x2061, 0x1000,
+	0x610c, 0xa006, 0x2c14, 0xa200, 0x8c60, 0x8109, 0x00c0, 0x2ba2,
+	0x2010, 0xa005, 0x0040, 0x2b2c, 0x0078, 0x2b52, 0x2069, 0xa351,
+	0x7824, 0x7930, 0xa11a, 0x00c8, 0x2b5a, 0x8019, 0x0040, 0x2b5a,
+	0x684a, 0x6942, 0x782c, 0x6852, 0x7828, 0x6856, 0xa006, 0x685a,
+	0x685e, 0x1078, 0x4dbd, 0x0078, 0x2b2c, 0x2069, 0xa351, 0x7824,
+	0x7934, 0xa11a, 0x00c8, 0x2b5a, 0x8019, 0x0040, 0x2b5a, 0x684e,
+	0x6946, 0x782c, 0x6862, 0x7828, 0x6866, 0xa006, 0x686a, 0x686e,
+	0x1078, 0x494d, 0x0078, 0x2b2c, 0xa02e, 0x2520, 0x81ff, 0x00c0,
+	0x2b56, 0x7924, 0x7b28, 0x7a2c, 0x20a9, 0x0005, 0x20a1, 0xa388,
+	0x41a1, 0x1078, 0x3518, 0x0040, 0x2b56, 0x2009, 0x0020, 0x1078,
+	0x3562, 0x701b, 0x2bf4, 0x007c, 0x6834, 0x2008, 0xa084, 0x00ff,
+	0xa096, 0x0011, 0x0040, 0x2c00, 0xa096, 0x0019, 0x00c0, 0x2b56,
+	0x810f, 0xa18c, 0x00ff, 0x0040, 0x2b56, 0x710e, 0x700c, 0x8001,
+	0x0040, 0x2c31, 0x700e, 0x1078, 0x3518, 0x0040, 0x2b56, 0x2009,
+	0x0020, 0x2061, 0xa3d1, 0x6224, 0x6328, 0x642c, 0x6530, 0xa290,
+	0x0040, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x1078,
+	0x3562, 0x701b, 0x2c24, 0x007c, 0x6834, 0xa084, 0x00ff, 0xa096,
+	0x0002, 0x0040, 0x2c2f, 0xa096, 0x000a, 0x00c0, 0x2b56, 0x0078,
+	0x2c06, 0x7010, 0x2068, 0x6838, 0xc0fd, 0x683a, 0x1078, 0x436e,
+	0x00c0, 0x2c3f, 0x7007, 0x0003, 0x701b, 0x2c41, 0x007c, 0x1078,
+	0x4a60, 0x127e, 0x2091, 0x8000, 0x20a9, 0x0005, 0x2099, 0xa388,
+	0x530a, 0x2100, 0xa210, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9,
+	0x0000, 0xad80, 0x000d, 0x2009, 0x0020, 0x127f, 0x0078, 0x3566,
+	0x61a0, 0x7824, 0x60a2, 0x0078, 0x2b2c, 0x2091, 0x8000, 0x7823,
+	0x4000, 0x7827, 0x4953, 0x782b, 0x5020, 0x782f, 0x2020, 0x2009,
+	0x017f, 0x2104, 0x7832, 0x3f00, 0x7836, 0x2061, 0x0100, 0x6200,
+	0x2061, 0x0200, 0x603c, 0x8007, 0xa205, 0x783a, 0x2009, 0x04fd,
+	0x2104, 0x783e, 0x781b, 0x0001, 0x2091, 0x5000, 0x2091, 0x4080,
+	0x2071, 0x0010, 0x20c1, 0x00f0, 0xa08a, 0x0003, 0x00c8, 0x0427,
+	0x0078, 0x0423, 0x81ff, 0x00c0, 0x2b56, 0x7924, 0x810f, 0xa18c,
+	0x00ff, 0x1078, 0x4501, 0x00c0, 0x2b5a, 0x7e38, 0xa684, 0x3fff,
+	0xa082, 0x4000, 0x0048, 0x2c9e, 0x0078, 0x2b5a, 0x7c28, 0x7d2c,
+	0x1078, 0x46d6, 0xd28c, 0x00c0, 0x2ca9, 0x1078, 0x466a, 0x0078,
+	0x2cab, 0x1078, 0x46a4, 0x00c0, 0x2cd5, 0x2061, 0xaa00, 0x127e,
+	0x2091, 0x8000, 0x6000, 0xa086, 0x0000, 0x0040, 0x2cc3, 0x6010,
+	0xa06d, 0x0040, 0x2cc3, 0x683c, 0xa406, 0x00c0, 0x2cc3, 0x6840,
+	0xa506, 0x0040, 0x2cce, 0x127f, 0xace0, 0x0010, 0x2001, 0xa315,
+	0x2004, 0xac02, 0x00c8, 0x2b56, 0x0078, 0x2caf, 0x1078, 0x8758,
+	0x127f, 0x0040, 0x2b56, 0x0078, 0x2b2c, 0xa00e, 0x2001, 0x0005,
+	0x1078, 0x4a60, 0x127e, 0x2091, 0x8000, 0x1078, 0x8cc0, 0x1078,
+	0x4982, 0x127f, 0x0078, 0x2b2c, 0x81ff, 0x00c0, 0x2b56, 0x1078,
+	0x3530, 0x0040, 0x2b5a, 0x1078, 0x45a7, 0x0040, 0x2b56, 0x1078,
+	0x46e4, 0x0040, 0x2b56, 0x0078, 0x2b2c, 0x81ff, 0x00c0, 0x2b56,
+	0x1078, 0x3542, 0x0040, 0x2b5a, 0x1078, 0x475f, 0x0040, 0x2b56,
+	0x2019, 0x0005, 0x1078, 0x4705, 0x0040, 0x2b56, 0x7828, 0xa08a,
+	0x1000, 0x00c8, 0x2b5a, 0x8003, 0x800b, 0x810b, 0xa108, 0x1078,
+	0x58e1, 0x0078, 0x2b2c, 0x127e, 0x2091, 0x8000, 0x81ff, 0x0040,
+	0x2d1d, 0x2009, 0x0001, 0x0078, 0x2d4e, 0x2029, 0x00ff, 0x644c,
+	0x2400, 0xa506, 0x0040, 0x2d48, 0x2508, 0x1078, 0x4501, 0x00c0,
+	0x2d48, 0x1078, 0x475f, 0x00c0, 0x2d33, 0x2009, 0x0002, 0x62a8,
+	0x2518, 0x0078, 0x2d4e, 0x2019, 0x0004, 0x1078, 0x4705, 0x00c0,
+	0x2d3d, 0x2009, 0x0006, 0x0078, 0x2d4e, 0x7824, 0xa08a, 0x1000,
+	0x00c8, 0x2d51, 0x8003, 0x800b, 0x810b, 0xa108, 0x1078, 0x58e1,
+	0x8529, 0x00c8, 0x2d20, 0x127f, 0x0078, 0x2b2c, 0x127f, 0x0078,
+	0x2b56, 0x127f, 0x0078, 0x2b5a, 0x1078, 0x3530, 0x0040, 0x2b5a,
+	0x1078, 0x461b, 0x1078, 0x46d6, 0x0078, 0x2b2c, 0x81ff, 0x00c0,
+	0x2b56, 0x1078, 0x3530, 0x0040, 0x2b5a, 0x1078, 0x460a, 0x1078,
+	0x46d6, 0x0078, 0x2b2c, 0x81ff, 0x00c0, 0x2b56, 0x1078, 0x3530,
+	0x0040, 0x2b5a, 0x1078, 0x46a7, 0x0040, 0x2b56, 0x1078, 0x43c1,
+	0x1078, 0x4663, 0x1078, 0x46d6, 0x0078, 0x2b2c, 0x1078, 0x3530,
+	0x0040, 0x2b5a, 0x1078, 0x45a7, 0x0040, 0x2b56, 0x62a0, 0x2019,
+	0x0005, 0x0c7e, 0x1078, 0x471b, 0x0c7f, 0x1078, 0x5d53, 0x077e,
+	0x2039, 0x0000, 0x1078, 0x5c78, 0x2009, 0x0000, 0x1078, 0x9c38,
+	0x077f, 0x1078, 0x46d6, 0x0078, 0x2b2c, 0x1078, 0x3530, 0x0040,
+	0x2b5a, 0x1078, 0x46d6, 0x2208, 0x0078, 0x2b2c, 0x157e, 0x0d7e,
+	0x0e7e, 0x2069, 0xa413, 0x6810, 0x6914, 0xa10a, 0x00c8, 0x2db2,
+	0x2009, 0x0000, 0x6816, 0x2011, 0x0000, 0x2019, 0x0000, 0x20a9,
+	0x00ff, 0x2069, 0xa434, 0x2d04, 0xa075, 0x0040, 0x2dc7, 0x704c,
+	0x1078, 0x2dd1, 0xa210, 0x7080, 0x1078, 0x2dd1, 0xa318, 0x8d68,
+	0x00f0, 0x2dbb, 0x2300, 0xa218, 0x0e7f, 0x0d7f, 0x157f, 0x0078,
+	0x2b2c, 0x0f7e, 0x017e, 0xa07d, 0x0040, 0x2de0, 0x2001, 0x0000,
+	0x8000, 0x2f0c, 0x81ff, 0x0040, 0x2de0, 0x2178, 0x0078, 0x2dd8,
+	0x017f, 0x0f7f, 0x007c, 0x2069, 0xa413, 0x6910, 0x62a4, 0x0078,
+	0x2b2c, 0x81ff, 0x00c0, 0x2b56, 0x614c, 0xa190, 0x293f, 0x2214,
+	0xa294, 0x00ff, 0x606c, 0xa084, 0xff00, 0xa215, 0x6368, 0x67c8,
+	0xd79c, 0x0040, 0x2dff, 0x2031, 0x0001, 0x0078, 0x2e01, 0x2031,
+	0x0000, 0x7e3a, 0x7f3e, 0x0078, 0x2b2c, 0x613c, 0x6240, 0x2019,
+	0xa5a0, 0x231c, 0x0078, 0x2b2c, 0x127e, 0x2091, 0x8000, 0x6134,
+	0xa006, 0x2010, 0x2018, 0x127f, 0x0078, 0x2b2c, 0x1078, 0x3542,
+	0x0040, 0x2b5a, 0x6244, 0x6338, 0x0078, 0x2b2c, 0x613c, 0x6240,
+	0x7824, 0x603e, 0x7b28, 0x6342, 0x2069, 0xa351, 0x831f, 0xa305,
+	0x6816, 0x782c, 0x2069, 0xa5a0, 0x2d1c, 0x206a, 0x0078, 0x2b2c,
+	0x017e, 0x127e, 0x2091, 0x8000, 0x7824, 0x6036, 0xd094, 0x0040,
+	0x2e43, 0x7828, 0xa085, 0x0001, 0x2009, 0xa5a9, 0x200a, 0x2001,
+	0xffff, 0x1078, 0x5975, 0x127f, 0x017f, 0x0078, 0x2b2c, 0x1078,
+	0x3542, 0x0040, 0x2b5a, 0x7828, 0xa00d, 0x0040, 0x2b5a, 0x782c,
+	0xa005, 0x0040, 0x2b5a, 0x6244, 0x6146, 0x6338, 0x603a, 0x0078,
+	0x2b2c, 0x2001, 0xa300, 0x2004, 0xa086, 0x0003, 0x00c0, 0x2b56,
+	0x0c7e, 0x2061, 0x0100, 0x7924, 0x810f, 0xa18c, 0x00ff, 0xa196,
+	0x00ff, 0x00c0, 0x2e70, 0x6030, 0xa085, 0xff00, 0x0078, 0x2e7f,
+	0xa182, 0x007f, 0x00c8, 0x2ea9, 0xa188, 0x293f, 0x210c, 0xa18c,
+	0x00ff, 0x6030, 0xa116, 0x0040, 0x2ea9, 0x810f, 0xa105, 0x127e,
+	0x2091, 0x8000, 0x007e, 0x1078, 0x74d7, 0x007f, 0x0040, 0x2ea5,
+	0x601a, 0x600b, 0xbc09, 0x601f, 0x0001, 0x1078, 0x3518, 0x0040,
+	0x2eac, 0x6837, 0x0000, 0x7007, 0x0003, 0x6833, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x701b, 0x2f07, 0x2d00, 0x6012, 0x2009, 0x0032,
+	0x1078, 0x756c, 0x127f, 0x0c7f, 0x007c, 0x127f, 0x0c7f, 0x0078,
+	0x2b56, 0x0c7f, 0x0078, 0x2b5a, 0x1078, 0x753d, 0x0078, 0x2ea5,
+	0x2001, 0xa300, 0x2004, 0xa086, 0x0003, 0x00c0, 0x2b56, 0x0c7e,
+	0x2061, 0x0100, 0x7924, 0x810f, 0xa18c, 0x00ff, 0xa196, 0x00ff,
+	0x00c0, 0x2ec7, 0x6030, 0xa085, 0xff00, 0x0078, 0x2ed6, 0xa182,
+	0x007f, 0x00c8, 0x2f00, 0xa188, 0x293f, 0x210c, 0xa18c, 0x00ff,
+	0x6030, 0xa116, 0x0040, 0x2f00, 0x810f, 0xa105, 0x127e, 0x2091,
+	0x8000, 0x007e, 0x1078, 0x74d7, 0x007f, 0x0040, 0x2efc, 0x601a,
+	0x600b, 0xbc05, 0x601f, 0x0001, 0x1078, 0x3518, 0x0040, 0x2f03,
+	0x6837, 0x0000, 0x7007, 0x0003, 0x6833, 0x0000, 0x6838, 0xc0fd,
+	0x683a, 0x701b, 0x2f07, 0x2d00, 0x6012, 0x2009, 0x0032, 0x1078,
+	0x756c, 0x127f, 0x0c7f, 0x007c, 0x127f, 0x0c7f, 0x0078, 0x2b56,
+	0x0c7f, 0x0078, 0x2b5a, 0x1078, 0x753d, 0x0078, 0x2efc, 0x6830,
+	0xa086, 0x0100, 0x0040, 0x2b56, 0x0078, 0x2b2c, 0x2061, 0xa62d,
+	0x127e, 0x2091, 0x8000, 0x6000, 0xd084, 0x0040, 0x2f1c, 0x6104,
+	0x6208, 0x127f, 0x0078, 0x2b2c, 0x127f, 0x0078, 0x2b5a, 0x81ff,
+	0x00c0, 0x2b56, 0x127e, 0x2091, 0x8000, 0x6244, 0x6060, 0xa202,
+	0x0048, 0x2f33, 0xa085, 0x0001, 0x1078, 0x2500, 0x1078, 0x3bf5,
+	0x127f, 0x0078, 0x2b2c, 0x127f, 0x0078, 0x2b5a, 0x127e, 0x2091,
+	0x8000, 0x20a9, 0x0011, 0x2001, 0xa340, 0x20a0, 0xa006, 0x40a4,
+	0x127f, 0x0078, 0x2b2c, 0x7d38, 0x7c3c, 0x0078, 0x2bde, 0x7824,
+	0xa09c, 0x00ff, 0xa39a, 0x0003, 0x00c8, 0x2b56, 0x624c, 0xa084,
+	0xff00, 0x8007, 0xa206, 0x00c0, 0x2f5f, 0x2001, 0xa340, 0x2009,
+	0x000c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0078, 0x3566, 0x81ff,
+	0x00c0, 0x2b56, 0x1078, 0x3542, 0x0040, 0x2b5a, 0x6004, 0xa084,
+	0x00ff, 0xa086, 0x0006, 0x00c0, 0x2b56, 0x0c7e, 0x1078, 0x3518,
+	0x0c7f, 0x0040, 0x2b56, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a,
+	0x1078, 0x8b85, 0x0040, 0x2b56, 0x7007, 0x0003, 0x701b, 0x2f81,
+	0x007c, 0x6830, 0xa086, 0x0100, 0x0040, 0x2b56, 0xad80, 0x000e,
+	0x2009, 0x000c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0078, 0x3566,
+	0x1078, 0x3518, 0x0040, 0x2b56, 0x1078, 0x421a, 0x2009, 0x001c,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078, 0x3562, 0x701b, 0x2fa1,
+	0x007c, 0xade8, 0x000d, 0x6800, 0xa005, 0x0040, 0x2b5a, 0x6804,
+	0xd0ac, 0x0040, 0x2fae, 0xd0a4, 0x0040, 0x2b5a, 0xd094, 0x0040,
+	0x2fb9, 0x0c7e, 0x2061, 0x0100, 0x6104, 0xa18c, 0xffdf, 0x6106,
+	0x0c7f, 0xd08c, 0x0040, 0x2fc4, 0x0c7e, 0x2061, 0x0100, 0x6104,
+	0xa18d, 0x0010, 0x6106, 0x0c7f, 0x2009, 0x0100, 0x210c, 0xa18a,
+	0x0002, 0x0048, 0x2fd9, 0xd084, 0x0040, 0x2fd9, 0x6a28, 0xa28a,
+	0x007f, 0x00c8, 0x2b5a, 0xa288, 0x293f, 0x210c, 0xa18c, 0x00ff,
+	0x6152, 0xd0dc, 0x0040, 0x2fe2, 0x6828, 0xa08a, 0x007f, 0x00c8,
+	0x2b5a, 0x604e, 0x6808, 0xa08a, 0x0100, 0x0048, 0x2b5a, 0xa08a,
+	0x0841, 0x00c8, 0x2b5a, 0xa084, 0x0007, 0x00c0, 0x2b5a, 0x680c,
+	0xa005, 0x0040, 0x2b5a, 0x6810, 0xa005, 0x0040, 0x2b5a, 0x6848,
+	0x6940, 0xa10a, 0x00c8, 0x2b5a, 0x8001, 0x0040, 0x2b5a, 0x684c,
+	0x6944, 0xa10a, 0x00c8, 0x2b5a, 0x8001, 0x0040, 0x2b5a, 0x6804,
+	0xd0fc, 0x0040, 0x3038, 0x1078, 0x3518, 0x0040, 0x2b56, 0x2009,
+	0x0014, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0xa290, 0x0038, 0xa399,
+	0x0000, 0x1078, 0x3562, 0x701b, 0x301e, 0x007c, 0xade8, 0x000d,
+	0x20a9, 0x0014, 0x2d98, 0x2069, 0xa36d, 0x2da0, 0x53a3, 0x7010,
+	0xa0e8, 0x000d, 0x2001, 0xa371, 0x200c, 0xd1e4, 0x0040, 0x3038,
+	0x0c7e, 0x2061, 0x0100, 0x6004, 0xa085, 0x0b00, 0x6006, 0x0c7f,
+	0x20a9, 0x001c, 0x2d98, 0x2069, 0xa351, 0x2da0, 0x53a3, 0x6814,
+	0xa08c, 0x00ff, 0x613e, 0x8007, 0xa084, 0x00ff, 0x6042, 0x1078,
+	0x4dbd, 0x1078, 0x48dd, 0x1078, 0x494d, 0x6000, 0xa086, 0x0000,
+	0x00c0, 0x30c3, 0x6808, 0x602a, 0x1078, 0x218b, 0x6818, 0x691c,
+	0x6a20, 0x6b24, 0x8007, 0x810f, 0x8217, 0x831f, 0x6016, 0x611a,
+	0x621e, 0x6322, 0x6c04, 0xd4f4, 0x0040, 0x3070, 0x6830, 0x6934,
+	0x6a38, 0x6b3c, 0x8007, 0x810f, 0x8217, 0x831f, 0x0078, 0x3072,
+	0xa084, 0xf0ff, 0x6006, 0x610a, 0x620e, 0x6312, 0x1078, 0x59a8,
+	0x6904, 0xd1fc, 0x0040, 0x30a5, 0x0c7e, 0x2009, 0x0000, 0x20a9,
+	0x0001, 0x6b70, 0xd384, 0x0040, 0x30a2, 0x0078, 0x308c, 0x839d,
+	0x00c8, 0x30a2, 0x3508, 0x8109, 0x1078, 0x5364, 0x6878, 0x6016,
+	0x6874, 0x2008, 0xa084, 0xff00, 0x8007, 0x600a, 0xa184, 0x00ff,
+	0x6006, 0x8108, 0x00c0, 0x30a0, 0x6003, 0x0003, 0x0078, 0x30a2,
+	0x6003, 0x0001, 0x00f0, 0x3087, 0x0c7f, 0x0c7e, 0x2061, 0x0100,
+	0x602f, 0x0040, 0x602f, 0x0000, 0x0c7f, 0x1078, 0x3784, 0x0040,
+	0x30b3, 0x1078, 0x2500, 0x60bc, 0xa005, 0x0040, 0x30bf, 0x6003,
+	0x0001, 0x2091, 0x301d, 0x1078, 0x4171, 0x0078, 0x30c3, 0x6003,
+	0x0004, 0x2091, 0x301d, 0x0078, 0x2b2c, 0x6000, 0xa086, 0x0000,
+	0x0040, 0x2b56, 0x2069, 0xa351, 0x7830, 0x6842, 0x7834, 0x6846,
+	0x6804, 0xd0fc, 0x0040, 0x30d8, 0x2009, 0x0030, 0x0078, 0x30da,
+	0x2009, 0x001c, 0x2d00, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0078,
+	0x3566, 0xa006, 0x1078, 0x2500, 0x81ff, 0x00c0, 0x2b56, 0x1078,
+	0x421a, 0x1078, 0x4171, 0x0078, 0x2b2c, 0x81ff, 0x00c0, 0x2b56,
+	0x6180, 0x81ff, 0x0040, 0x3107, 0x703f, 0x0000, 0x2001, 0xa9c0,
+	0x2009, 0x0040, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x127e, 0x2091,
+	0x8000, 0x1078, 0x3566, 0x701b, 0x2b29, 0x127f, 0x007c, 0x703f,
+	0x0001, 0x0d7e, 0x2069, 0xa9c0, 0x20a9, 0x0040, 0x20a1, 0xa9c0,
+	0x2019, 0xffff, 0x43a4, 0x654c, 0xa588, 0x293f, 0x210c, 0xa18c,
+	0x00ff, 0x216a, 0xa00e, 0x2011, 0x0002, 0x2100, 0xa506, 0x0040,
+	0x3139, 0x1078, 0x4501, 0x00c0, 0x3139, 0x6014, 0x821c, 0x0048,
+	0x3131, 0xa398, 0xa9c0, 0xa085, 0xff00, 0x8007, 0x201a, 0x0078,
+	0x3138, 0xa398, 0xa9c0, 0x2324, 0xa4a4, 0xff00, 0xa405, 0x201a,
+	0x8210, 0x8108, 0xa182, 0x0080, 0x00c8, 0x3140, 0x0078, 0x311d,
+	0x8201, 0x8007, 0x2d0c, 0xa105, 0x206a, 0x0d7f, 0x20a9, 0x0040,
+	0x20a1, 0xa9c0, 0x2099, 0xa9c0, 0x1078, 0x41be, 0x0078, 0x30f6,
+	0x1078, 0x3542, 0x0040, 0x2b5a, 0x0c7e, 0x1078, 0x3518, 0x0c7f,
+	0x00c0, 0x315e, 0x2009, 0x0002, 0x0078, 0x2b56, 0x2001, 0xa352,
+	0x2004, 0xd0b4, 0x0040, 0x3185, 0x6000, 0xd08c, 0x00c0, 0x3185,
+	0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0, 0x3185, 0x6837,
+	0x0000, 0x6838, 0xc0fd, 0x683a, 0x1078, 0x8bd9, 0x00c0, 0x317c,
+	0x2009, 0x0003, 0x0078, 0x2b56, 0x7007, 0x0003, 0x701b, 0x3181,
+	0x007c, 0x1078, 0x3542, 0x0040, 0x2b5a, 0x20a9, 0x002b, 0x2c98,
+	0xade8, 0x0002, 0x2da0, 0x53a3, 0x20a9, 0x0004, 0xac80, 0x0006,
+	0x2098, 0xad80, 0x0006, 0x20a0, 0x1078, 0x41be, 0x20a9, 0x0004,
+	0xac80, 0x000a, 0x2098, 0xad80, 0x000a, 0x20a0, 0x1078, 0x41be,
+	0x2d00, 0x2009, 0x002b, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0078,
+	0x3566, 0x81ff, 0x00c0, 0x2b56, 0x1078, 0x3530, 0x0040, 0x2b5a,
+	0x1078, 0x46ef, 0x0078, 0x2b2c, 0x81ff, 0x00c0, 0x2b56, 0x7828,
+	0xa08a, 0x1000, 0x00c8, 0x2b5a, 0x1078, 0x3542, 0x0040, 0x2b5a,
+	0x1078, 0x475f, 0x0040, 0x2b56, 0x2019, 0x0004, 0x1078, 0x4705,
+	0x7924, 0x810f, 0x7a28, 0x1078, 0x31cf, 0x0078, 0x2b2c, 0xa186,
+	0x00ff, 0x0040, 0x31d7, 0x1078, 0x31e7, 0x0078, 0x31e6, 0x2029,
+	0x007e, 0x2061, 0xa300, 0x644c, 0x2400, 0xa506, 0x0040, 0x31e3,
+	0x2508, 0x1078, 0x31e7, 0x8529, 0x00c8, 0x31dc, 0x007c, 0x1078,
+	0x4501, 0x00c0, 0x31f2, 0x2200, 0x8003, 0x800b, 0x810b, 0xa108,
+	0x1078, 0x58e1, 0x007c, 0x81ff, 0x00c0, 0x2b56, 0x1078, 0x3530,
+	0x0040, 0x2b5a, 0x1078, 0x45a7, 0x0040, 0x2b56, 0x1078, 0x46fa,
+	0x0078, 0x2b2c, 0x81ff, 0x00c0, 0x2b56, 0x1078, 0x3530, 0x0040,
+	0x2b5a, 0x1078, 0x45a7, 0x0040, 0x2b56, 0x1078, 0x46e4, 0x0078,
+	0x2b2c, 0x6100, 0x0078, 0x2b2c, 0x1078, 0x3542, 0x0040, 0x2b5a,
+	0x2001, 0xa300, 0x2004, 0xa086, 0x0003, 0x00c0, 0x2b56, 0x0d7e,
+	0xace8, 0x000a, 0x7924, 0xd184, 0x0040, 0x3228, 0xace8, 0x0006,
+	0x680c, 0x8007, 0x783e, 0x6808, 0x8007, 0x783a, 0x6b04, 0x831f,
+	0x6a00, 0x8217, 0x0d7f, 0x6100, 0xa18c, 0x0200, 0x0078, 0x2b2c,
+	0xa006, 0x1078, 0x2500, 0x7824, 0xa084, 0x00ff, 0xa086, 0x00ff,
+	0x0040, 0x3245, 0x81ff, 0x00c0, 0x2b56, 0x1078, 0x421a, 0x7828,
+	0xa08a, 0x1000, 0x00c8, 0x2b5a, 0x7924, 0xa18c, 0xff00, 0x810f,
+	0xa186, 0x00ff, 0x0040, 0x325b, 0xa182, 0x007f, 0x00c8, 0x2b5a,
+	0x2100, 0x1078, 0x24fa, 0x027e, 0x0c7e, 0x127e, 0x2091, 0x8000,
+	0x2061, 0xa5be, 0x601b, 0x0000, 0x601f, 0x0000, 0x2061, 0x0100,
+	0x6030, 0xa084, 0x00ff, 0x810f, 0xa105, 0x604a, 0x6043, 0x0090,
+	0x6043, 0x0010, 0x2009, 0x002d, 0x2011, 0x4196, 0x1078, 0x596c,
+	0x7924, 0xa18c, 0xff00, 0x810f, 0x7a28, 0x1078, 0x31cf, 0x127f,
+	0x0c7f, 0x027f, 0x0078, 0x2b2c, 0x7924, 0xa18c, 0xff00, 0x810f,
+	0x0c7e, 0x1078, 0x4499, 0x2c08, 0x0c7f, 0x00c0, 0x2b5a, 0x0078,
+	0x2b2c, 0x81ff, 0x0040, 0x3298, 0x2009, 0x0001, 0x0078, 0x2b56,
+	0x60c8, 0xd09c, 0x00c0, 0x32a0, 0x2009, 0x0005, 0x0078, 0x2b56,
+	0x1078, 0x3518, 0x00c0, 0x32a8, 0x2009, 0x0002, 0x0078, 0x2b56,
+	0x7924, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078, 0x3562, 0x701b,
+	0x32b2, 0x007c, 0x2009, 0x0080, 0x1078, 0x4501, 0x00c0, 0x32bf,
+	0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x0040, 0x32c3, 0x2021,
+	0x400a, 0x0078, 0x2b2e, 0x0d7e, 0xade8, 0x000d, 0x6900, 0x6a08,
+	0x6b0c, 0x6c10, 0x6d14, 0x6e18, 0x6820, 0xa0be, 0x0100, 0x0040,
+	0x3336, 0xa0be, 0x0112, 0x0040, 0x3336, 0xa0be, 0x0113, 0x0040,
+	0x3336, 0xa0be, 0x0114, 0x0040, 0x3336, 0xa0be, 0x0117, 0x0040,
+	0x3336, 0xa0be, 0x011a, 0x0040, 0x3336, 0xa0be, 0x0121, 0x0040,
+	0x332c, 0xa0be, 0x0131, 0x0040, 0x332c, 0xa0be, 0x0171, 0x0040,
+	0x3336, 0xa0be, 0x0173, 0x0040, 0x3336, 0xa0be, 0x01a1, 0x00c0,
+	0x32fe, 0x6830, 0x8007, 0x6832, 0x0078, 0x333c, 0xa0be, 0x0212,
+	0x0040, 0x3332, 0xa0be, 0x0213, 0x0040, 0x3332, 0xa0be, 0x0214,
+	0x0040, 0x3324, 0xa0be, 0x0217, 0x0040, 0x331e, 0xa0be, 0x021a,
+	0x00c0, 0x3317, 0x6838, 0x8007, 0x683a, 0x0078, 0x3336, 0xa0be,
+	0x0300, 0x0040, 0x3336, 0x0d7f, 0x0078, 0x2b5a, 0xad80, 0x0010,
+	0x20a9, 0x0007, 0x1078, 0x337e, 0xad80, 0x000e, 0x20a9, 0x0001,
+	0x1078, 0x337e, 0x0078, 0x3336, 0xad80, 0x000c, 0x1078, 0x338c,
+	0x0078, 0x333c, 0xad80, 0x000e, 0x1078, 0x338c, 0xad80, 0x000c,
+	0x20a9, 0x0001, 0x1078, 0x337e, 0x0c7e, 0x1078, 0x3518, 0x0040,
+	0x336f, 0x6838, 0xc0fd, 0x683a, 0x6837, 0x0119, 0x6853, 0x0000,
+	0x684f, 0x0020, 0x685b, 0x0001, 0x810b, 0x697e, 0x6883, 0x0000,
+	0x6a86, 0x6b8a, 0x6c8e, 0x6d92, 0x6996, 0x689b, 0x0000, 0x0c7f,
+	0x0d7f, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x6823, 0x0000,
+	0x6804, 0x2068, 0x1078, 0x8ba1, 0x00c0, 0x336a, 0x2009, 0x0003,
+	0x0078, 0x2b56, 0x7007, 0x0003, 0x701b, 0x3375, 0x007c, 0x0c7f,
+	0x0d7f, 0x2009, 0x0002, 0x0078, 0x2b56, 0x6820, 0xa086, 0x8001,
+	0x00c0, 0x2b2c, 0x2009, 0x0004, 0x0078, 0x2b56, 0x017e, 0x2008,
+	0x2044, 0x8000, 0x204c, 0x8000, 0x290a, 0x8108, 0x280a, 0x8108,
+	0x00f0, 0x3380, 0x017f, 0x007c, 0x017e, 0x0a7e, 0x0b7e, 0x2008,
+	0x2044, 0x8000, 0x204c, 0x8000, 0x2054, 0x8000, 0x205c, 0x2b0a,
+	0x8108, 0x2a0a, 0x8108, 0x290a, 0x8108, 0x280a, 0x0b7f, 0x0a7f,
+	0x017f, 0x007c, 0x81ff, 0x0040, 0x33a9, 0x2009, 0x0001, 0x0078,
+	0x2b56, 0x7924, 0x2140, 0xa18c, 0xff00, 0x810f, 0xa182, 0x0080,
+	0x0048, 0x2b5a, 0xa182, 0x00ff, 0x00c8, 0x2b5a, 0x7a2c, 0x7b28,
+	0x6068, 0xa306, 0x00c0, 0x33c4, 0x606c, 0xa24e, 0x0040, 0x2b5a,
+	0xa9cc, 0xff00, 0x0040, 0x2b5a, 0x0c7e, 0x1078, 0x346d, 0x2c68,
+	0x0c7f, 0x0040, 0x33fc, 0xa0c6, 0x4000, 0x00c0, 0x33e2, 0x0c7e,
+	0x007e, 0x2d60, 0x2009, 0x0000, 0x1078, 0x47cb, 0x00c0, 0x33d9,
+	0xc185, 0x6000, 0xd0bc, 0x0040, 0x33de, 0xc18d, 0x007f, 0x0c7f,
+	0x0078, 0x33f9, 0xa0c6, 0x4007, 0x00c0, 0x33e9, 0x2408, 0x0078,
+	0x33f9, 0xa0c6, 0x4008, 0x00c0, 0x33f1, 0x2708, 0x2610, 0x0078,
+	0x33f9, 0xa0c6, 0x4009, 0x00c0, 0x33f7, 0x0078, 0x33f9, 0x2001,
+	0x4006, 0x2020, 0x0078, 0x2b2e, 0x2d00, 0x7022, 0x017e, 0x0b7e,
+	0x0c7e, 0x0e7e, 0x2c70, 0x1078, 0x74d7, 0x0040, 0x3442, 0x2d00,
+	0x601a, 0x2001, 0xa356, 0x2004, 0xa084, 0x00ff, 0x6842, 0x2e58,
+	0x0e7f, 0x0e7e, 0x0c7e, 0x1078, 0x3518, 0x0c7f, 0x2b70, 0x00c0,
+	0x3423, 0x1078, 0x753d, 0x0e7f, 0x0c7f, 0x0b7f, 0x017f, 0x2009,
+	0x0002, 0x0078, 0x2b56, 0x6837, 0x0000, 0x2d00, 0x6012, 0x6833,
+	0x0000, 0x6838, 0xc0fd, 0x683a, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x2813, 0x127f, 0x601f, 0x0001, 0x2001, 0x0000, 0x1078, 0x442b,
+	0x2001, 0x0002, 0x1078, 0x443f, 0x2009, 0x0002, 0x1078, 0x756c,
+	0xa085, 0x0001, 0x0e7f, 0x0c7f, 0x0b7f, 0x017f, 0x00c0, 0x344c,
+	0x2009, 0x0003, 0x0078, 0x2b56, 0x7007, 0x0003, 0x701b, 0x3451,
+	0x007c, 0x6830, 0xa086, 0x0100, 0x7020, 0x2060, 0x00c0, 0x345f,
+	0x2009, 0x0004, 0x6204, 0xa294, 0x00ff, 0x0078, 0x2b56, 0x2009,
+	0x0000, 0x1078, 0x47cb, 0x00c0, 0x3466, 0xc185, 0x6000, 0xd0bc,
+	0x0040, 0x346b, 0xc18d, 0x0078, 0x2b2c, 0x0e7e, 0x0d7e, 0x2029,
+	0x0000, 0x2021, 0x0080, 0x20a9, 0x007f, 0x2071, 0xa4b4, 0x2e04,
+	0xa005, 0x00c0, 0x3482, 0x2100, 0xa406, 0x00c0, 0x34b3, 0x2428,
+	0x0078, 0x34b3, 0x2068, 0x6f10, 0x2700, 0xa306, 0x00c0, 0x34a4,
+	0x6e14, 0x2600, 0xa206, 0x00c0, 0x34a4, 0x2400, 0xa106, 0x00c0,
+	0x34a0, 0x2d60, 0xd884, 0x0040, 0x34c8, 0x6004, 0xa084, 0x00ff,
+	0xa086, 0x0006, 0x00c0, 0x34c8, 0x2001, 0x4000, 0x0078, 0x34c9,
+	0x2001, 0x4007, 0x0078, 0x34c9, 0x2400, 0xa106, 0x00c0, 0x34b3,
+	0x6e14, 0x87ff, 0x00c0, 0x34af, 0x86ff, 0x0040, 0x347f, 0x2001,
+	0x4008, 0x0078, 0x34c9, 0x8420, 0x8e70, 0x00f0, 0x3477, 0x85ff,
+	0x00c0, 0x34c2, 0x2001, 0x4009, 0x0078, 0x34c9, 0x2001, 0x0001,
+	0x0078, 0x34c9, 0x1078, 0x4499, 0x00c0, 0x34be, 0x6312, 0x6216,
+	0xa006, 0xa005, 0x0d7f, 0x0e7f, 0x007c, 0x81ff, 0x00c0, 0x2b56,
+	0x1078, 0x3518, 0x0040, 0x2b56, 0x6837, 0x0000, 0x6838, 0xc0fd,
+	0x683a, 0x7824, 0xa005, 0x0040, 0x2b5a, 0xa096, 0x00ff, 0x0040,
+	0x34e5, 0xa092, 0x0004, 0x00c8, 0x2b5a, 0x2010, 0x2d18, 0x1078,
+	0x27c2, 0x0040, 0x2b56, 0x7007, 0x0003, 0x701b, 0x34f0, 0x007c,
+	0x6830, 0xa086, 0x0100, 0x0040, 0x2b56, 0x0078, 0x2b2c, 0x7924,
+	0xa18c, 0xff00, 0x810f, 0xa182, 0x0080, 0x0048, 0x2b5a, 0xa182,
+	0x00ff, 0x00c8, 0x2b5a, 0x127e, 0x2091, 0x8000, 0x1078, 0x8a89,
+	0x00c0, 0x3515, 0xa190, 0xa434, 0x2204, 0xa065, 0x0040, 0x3515,
+	0x1078, 0x4235, 0x127f, 0x0078, 0x2b2c, 0x127f, 0x0078, 0x2b56,
+	0x1078, 0x1381, 0x0040, 0x352f, 0xa006, 0x6802, 0x7010, 0xa005,
+	0x00c0, 0x3527, 0x2d00, 0x7012, 0x7016, 0x0078, 0x352d, 0x7014,
+	0x6802, 0x2060, 0x2d00, 0x6006, 0x7016, 0xad80, 0x000d, 0x007c,
+	0x7924, 0x810f, 0xa18c, 0x00ff, 0x1078, 0x4501, 0x00c0, 0x353f,
+	0x7e28, 0xa684, 0x3fff, 0xa082, 0x4000, 0x0048, 0x3540, 0xa066,
+	0x8cff, 0x007c, 0x7e24, 0x860f, 0xa18c, 0x00ff, 0x1078, 0x4501,
+	0x00c0, 0x3550, 0xa6b4, 0x00ff, 0xa682, 0x4000, 0x0048, 0x3551,
+	0xa066, 0x8cff, 0x007c, 0x017e, 0x7110, 0x81ff, 0x0040, 0x355e,
+	0x2168, 0x6904, 0x1078, 0x139a, 0x0078, 0x3555, 0x7112, 0x7116,
+	0x017f, 0x007c, 0x2031, 0x0001, 0x0078, 0x3568, 0x2031, 0x0000,
+	0x2061, 0xa3d1, 0x6606, 0x6112, 0x600e, 0x6226, 0x632a, 0x642e,
+	0x6532, 0x2c10, 0x1078, 0x13d1, 0x7007, 0x0002, 0x701b, 0x2b2c,
+	0x007c, 0x0f7e, 0x127e, 0x2091, 0x8000, 0x2079, 0x0000, 0x2001,
+	0xa38f, 0x2004, 0xa005, 0x00c0, 0x3594, 0x0068, 0x3594, 0x7818,
+	0xd084, 0x00c0, 0x3594, 0x7a22, 0x7b26, 0x7c2a, 0x781b, 0x0001,
+	0x2091, 0x4080, 0x0078, 0x35b9, 0x017e, 0x0c7e, 0x0e7e, 0x2071,
+	0xa381, 0x7138, 0xa182, 0x0008, 0x0048, 0x35a2, 0x7030, 0x2060,
+	0x0078, 0x35b3, 0x7030, 0xa0e0, 0x0008, 0xac82, 0xa3d1, 0x0048,
+	0x35ab, 0x2061, 0xa391, 0x2c00, 0x7032, 0x81ff, 0x00c0, 0x35b1,
+	0x7036, 0x8108, 0x713a, 0x2262, 0x6306, 0x640a, 0x0e7f, 0x0c7f,
+	0x017f, 0x127f, 0x0f7f, 0x007c, 0x0e7e, 0x2071, 0xa381, 0x7038,
+	0xa005, 0x0040, 0x35f5, 0x127e, 0x2091, 0x8000, 0x0068, 0x35f4,
+	0x0f7e, 0x2079, 0x0000, 0x7818, 0xd084, 0x00c0, 0x35f3, 0x0c7e,
+	0x7034, 0x2060, 0x2c04, 0x7822, 0x6004, 0x7826, 0x6008, 0x782a,
+	0x781b, 0x0001, 0x2091, 0x4080, 0x7038, 0x8001, 0x703a, 0xa005,
+	0x00c0, 0x35e9, 0x7033, 0xa391, 0x7037, 0xa391, 0x0c7f, 0x0078,
+	0x35f3, 0xac80, 0x0008, 0xa0fa, 0xa3d1, 0x0048, 0x35f1, 0x2001,
+	0xa391, 0x7036, 0x0c7f, 0x0f7f, 0x127f, 0x0e7f, 0x007c, 0x027e,
+	0x2001, 0xa352, 0x2004, 0xd0c4, 0x0040, 0x3602, 0x2011, 0x8014,
+	0x1078, 0x3579, 0x027f, 0x007c, 0x81ff, 0x00c0, 0x2b56, 0x127e,
+	0x2091, 0x8000, 0x6030, 0xc08d, 0xc085, 0xc0ac, 0x6032, 0x1078,
+	0x4171, 0x127f, 0x0078, 0x2b2c, 0x7824, 0x2008, 0xa18c, 0xfffd,
+	0x00c0, 0x361f, 0x61d4, 0xa10d, 0x61d6, 0x0078, 0x2b2c, 0x0078,
+	0x2b5a, 0x81ff, 0x00c0, 0x2b56, 0x6000, 0xa086, 0x0003, 0x00c0,
+	0x2b56, 0x2001, 0xa352, 0x2004, 0xd0ac, 0x00c0, 0x2b56, 0x1078,
+	0x3542, 0x0040, 0x2b5a, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006,
+	0x00c0, 0x363e, 0x7828, 0xa005, 0x0040, 0x2b2c, 0x0c7e, 0x1078,
+	0x3518, 0x0c7f, 0x0040, 0x2b56, 0x6837, 0x0000, 0x6833, 0x0000,
+	0x6838, 0xc0fd, 0x683a, 0x1078, 0x8c4d, 0x0040, 0x2b56, 0x7007,
+	0x0003, 0x701b, 0x3654, 0x007c, 0x6830, 0xa086, 0x0100, 0x0040,
+	0x2b56, 0x0078, 0x2b2c, 0x2001, 0xa300, 0x2004, 0xa086, 0x0003,
+	0x00c0, 0x2b56, 0x7f24, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078,
+	0x3518, 0x0040, 0x2b56, 0x2009, 0x0000, 0x2031, 0x0000, 0x7023,
+	0x0000, 0x702f, 0x0000, 0xad80, 0x0005, 0x7026, 0x20a0, 0x1078,
+	0x4501, 0x00c0, 0x36d8, 0x6004, 0xa0c4, 0x00ff, 0xa8c6, 0x0006,
+	0x0040, 0x3688, 0xa0c4, 0xff00, 0xa8c6, 0x0600, 0x00c0, 0x36d8,
+	0x2001, 0xa352, 0x2004, 0xd0ac, 0x00c0, 0x3695, 0x1078, 0x47cb,
+	0x00c0, 0x3695, 0xd79c, 0x0040, 0x36d8, 0xd794, 0x00c0, 0x369b,
+	0xd784, 0x0040, 0x36a7, 0xac80, 0x0006, 0x2098, 0x3400, 0x20a9,
+	0x0004, 0x53a3, 0x1078, 0x338c, 0xd794, 0x0040, 0x36b0, 0xac80,
+	0x000a, 0x2098, 0x3400, 0x20a9, 0x0004, 0x53a3, 0x1078, 0x338c,
+	0x21a2, 0xd794, 0x0040, 0x36d0, 0xac80, 0x0000, 0x2098, 0x94a0,
+	0x20a9, 0x0002, 0x53a3, 0xac80, 0x0003, 0x20a6, 0x94a0, 0xac80,
+	0x0004, 0x2098, 0x3400, 0x20a9, 0x0002, 0x53a3, 0x1078, 0x337e,
+	0xac80, 0x0026, 0x2098, 0x20a9, 0x0002, 0x53a3, 0x0078, 0x36d1,
+	0x94a0, 0xd794, 0x0040, 0x36d6, 0xa6b0, 0x000b, 0xa6b0, 0x0005,
+	0x8108, 0xd78c, 0x0040, 0x36e2, 0xa186, 0x0100, 0x0040, 0x36f3,
+	0x0078, 0x36e6, 0xa186, 0x007e, 0x0040, 0x36f3, 0xd794, 0x0040,
+	0x36ed, 0xa686, 0x0020, 0x0078, 0x36ef, 0xa686, 0x0028, 0x0040,
+	0x36fc, 0x0078, 0x3677, 0x86ff, 0x00c0, 0x36fa, 0x7120, 0x810b,
+	0x0078, 0x2b2c, 0x702f, 0x0001, 0x711e, 0x7020, 0xa600, 0x7022,
+	0x772a, 0x2061, 0xa3d1, 0x6007, 0x0000, 0x6612, 0x7024, 0x600e,
+	0x6226, 0x632a, 0x642e, 0x6532, 0x2c10, 0x1078, 0x13d1, 0x7007,
+	0x0002, 0x701b, 0x3714, 0x007c, 0x702c, 0xa005, 0x00c0, 0x3726,
+	0x711c, 0x7024, 0x20a0, 0x7728, 0x2031, 0x0000, 0x2061, 0xa3d1,
+	0x6224, 0x6328, 0x642c, 0x6530, 0x0078, 0x3677, 0x7120, 0x810b,
+	0x0078, 0x2b2c, 0x2029, 0x007e, 0x7924, 0x7a28, 0x7b2c, 0x7c38,
+	0xa184, 0xff00, 0x8007, 0xa0e2, 0x0020, 0x0048, 0x2b5a, 0xa502,
+	0x0048, 0x2b5a, 0xa184, 0x00ff, 0xa0e2, 0x0020, 0x0048, 0x2b5a,
+	0xa502, 0x0048, 0x2b5a, 0xa284, 0xff00, 0x8007, 0xa0e2, 0x0020,
+	0x0048, 0x2b5a, 0xa502, 0x0048, 0x2b5a, 0xa284, 0x00ff, 0xa0e2,
+	0x0020, 0x0048, 0x2b5a, 0xa502, 0x0048, 0x2b5a, 0xa384, 0xff00,
+	0x8007, 0xa0e2, 0x0020, 0x0048, 0x2b5a, 0xa502, 0x0048, 0x2b5a,
+	0xa384, 0x00ff, 0xa0e2, 0x0020, 0x0048, 0x2b5a, 0xa502, 0x0048,
+	0x2b5a, 0xa484, 0xff00, 0x8007, 0xa0e2, 0x0020, 0x0048, 0x2b5a,
+	0xa502, 0x0048, 0x2b5a, 0xa484, 0x00ff, 0xa0e2, 0x0020, 0x0048,
+	0x2b5a, 0xa502, 0x0048, 0x2b5a, 0x2061, 0xa5a3, 0x6102, 0x6206,
+	0x630a, 0x640e, 0x0078, 0x2b2c, 0x007e, 0x2001, 0xa352, 0x2004,
+	0xd0cc, 0x007f, 0x007c, 0x007e, 0x2001, 0xa371, 0x2004, 0xd0bc,
+	0x007f, 0x007c, 0x6160, 0x7a24, 0x6300, 0x82ff, 0x00c0, 0x379b,
+	0x7926, 0x0078, 0x2b2c, 0x83ff, 0x00c0, 0x2b5a, 0x2001, 0xfff0,
+	0xa200, 0x00c8, 0x2b5a, 0x2019, 0xffff, 0x6064, 0xa302, 0xa200,
+	0x0048, 0x2b5a, 0x7926, 0x6262, 0x0078, 0x2b2c, 0x2001, 0xa300,
+	0x2004, 0xa086, 0x0003, 0x00c0, 0x2b56, 0x7c28, 0x7d24, 0x7e38,
+	0x7f2c, 0x1078, 0x3518, 0x0040, 0x2b56, 0x2009, 0x0000, 0x2019,
+	0x0000, 0x7023, 0x0000, 0x702f, 0x0000, 0xad80, 0x0003, 0x7026,
+	0x20a0, 0xa1e0, 0xa434, 0x2c64, 0x8cff, 0x0040, 0x37e8, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x0040, 0x37dd, 0x6004, 0xa084,
+	0xff00, 0xa086, 0x0600, 0x00c0, 0x37e8, 0x6014, 0x20a2, 0x94a0,
+	0x6010, 0x8007, 0xa105, 0x8007, 0x20a2, 0x94a0, 0xa398, 0x0002,
+	0x8108, 0xa182, 0x00ff, 0x0040, 0x37f3, 0xa386, 0x002a, 0x0040,
+	0x37fc, 0x0078, 0x37c9, 0x83ff, 0x00c0, 0x37fa, 0x7120, 0x810c,
+	0x0078, 0x2b2c, 0x702f, 0x0001, 0x711e, 0x7020, 0xa300, 0x7022,
+	0x2061, 0xa3d1, 0x6007, 0x0000, 0x6312, 0x7024, 0x600e, 0x6426,
+	0x652a, 0x662e, 0x6732, 0x2c10, 0x1078, 0x13d1, 0x7007, 0x0002,
+	0x701b, 0x3813, 0x007c, 0x702c, 0xa005, 0x00c0, 0x3824, 0x711c,
+	0x7024, 0x20a0, 0x2019, 0x0000, 0x2061, 0xa3d1, 0x6424, 0x6528,
+	0x662c, 0x6730, 0x0078, 0x37c9, 0x7120, 0x810c, 0x0078, 0x2b2c,
+	0x81ff, 0x00c0, 0x2b56, 0x60c8, 0xd09c, 0x0040, 0x2b56, 0x1078,
+	0x3518, 0x0040, 0x2b56, 0x7924, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38,
+	0x1078, 0x3562, 0x701b, 0x383d, 0x007c, 0x0d7e, 0xade8, 0x000d,
+	0x6828, 0xa0be, 0x7000, 0x0040, 0x3850, 0xa0be, 0x7100, 0x0040,
+	0x3850, 0xa0be, 0x7200, 0x0040, 0x3850, 0x0d7f, 0x0078, 0x2b5a,
+	0x6820, 0x6924, 0x1078, 0x24e3, 0x00c0, 0x387b, 0x1078, 0x4499,
+	0x00c0, 0x387b, 0x7122, 0x6612, 0x6516, 0x6e18, 0x0c7e, 0x1078,
+	0x3518, 0x0040, 0x387b, 0x1078, 0x3518, 0x0040, 0x387b, 0x0c7f,
+	0x0d7f, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x6823, 0x0000,
+	0x6804, 0x2068, 0x1078, 0x8bbd, 0x0040, 0x2b56, 0x7007, 0x0003,
+	0x701b, 0x387e, 0x007c, 0x0d7f, 0x0078, 0x2b56, 0x7120, 0x1078,
+	0x2921, 0x6820, 0xa086, 0x8001, 0x0040, 0x2b56, 0x2d00, 0x701e,
+	0x6804, 0xa080, 0x0002, 0x007e, 0x20a9, 0x002a, 0x2098, 0x20a0,
+	0x1078, 0x41be, 0x007f, 0xade8, 0x000d, 0x6a08, 0x6b0c, 0x6c10,
+	0x6d14, 0x2061, 0xa3d1, 0x6007, 0x0000, 0x6e00, 0x6f28, 0xa7c6,
+	0x7000, 0x00c0, 0x38a5, 0x0078, 0x38a9, 0xa7c6, 0x7100, 0x00c0,
+	0x38b1, 0xa6c2, 0x0004, 0x0048, 0x2b5a, 0x2009, 0x0004, 0x0078,
+	0x3566, 0xa7c6, 0x7200, 0x00c0, 0x2b5a, 0xa6c2, 0x0054, 0x0048,
+	0x2b5a, 0x600e, 0x6013, 0x002a, 0x6226, 0x632a, 0x642e, 0x6532,
+	0x2c10, 0x1078, 0x13d1, 0x7007, 0x0002, 0x701b, 0x38c8, 0x007c,
+	0x701c, 0x2068, 0x6804, 0xa080, 0x0001, 0x2004, 0xa080, 0x0002,
+	0x007e, 0x20a9, 0x002a, 0x2098, 0x20a0, 0x1078, 0x41be, 0x007f,
+	0x2009, 0x002a, 0x2061, 0xa3d1, 0x6224, 0x6328, 0x642c, 0x6530,
+	0x0078, 0x3566, 0x81ff, 0x00c0, 0x2b56, 0x1078, 0x3530, 0x0040,
+	0x2b5a, 0x1078, 0x45a7, 0x0040, 0x2b56, 0x1078, 0x4710, 0x0078,
+	0x2b2c, 0x7824, 0xd084, 0x0040, 0x3150, 0x1078, 0x3542, 0x0040,
+	0x2b5a, 0x0c7e, 0x1078, 0x3518, 0x0c7f, 0x00c0, 0x3903, 0x2009,
+	0x0002, 0x0078, 0x2b56, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006,
+	0x0040, 0x3910, 0xa08e, 0x0004, 0x0040, 0x3910, 0xa08e, 0x0005,
+	0x00c0, 0x3934, 0x2001, 0xa352, 0x2004, 0xd0b4, 0x0040, 0x3185,
+	0x6000, 0xd08c, 0x00c0, 0x3185, 0x6837, 0x0000, 0x6838, 0xc0fd,
+	0x683a, 0x1078, 0x8bd9, 0x00c0, 0x3929, 0x2009, 0x0003, 0x0078,
+	0x2b56, 0x7007, 0x0003, 0x701b, 0x392e, 0x007c, 0x1078, 0x3542,
+	0x0040, 0x2b5a, 0x0078, 0x3185, 0x2009, 0xa32e, 0x210c, 0x81ff,
+	0x0040, 0x393e, 0x2009, 0x0001, 0x0078, 0x2b56, 0x2001, 0xa300,
+	0x2004, 0xa086, 0x0003, 0x0040, 0x3949, 0x2009, 0x0007, 0x0078,
+	0x2b56, 0x2001, 0xa352, 0x2004, 0xd0ac, 0x0040, 0x3953, 0x2009,
+	0x0008, 0x0078, 0x2b56, 0x609c, 0xd0a4, 0x00c0, 0x395a, 0xd0ac,
+	0x00c0, 0x3185, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd,
+	0x683a, 0x1078, 0x8c4d, 0x00c0, 0x3969, 0x2009, 0x0003, 0x0078,
+	0x2b56, 0x7007, 0x0003, 0x701b, 0x396e, 0x007c, 0x6830, 0xa086,
+	0x0100, 0x00c0, 0x3977, 0x2009, 0x0004, 0x0078, 0x2b56, 0x1078,
+	0x3542, 0x0040, 0x2b5a, 0x0078, 0x3912, 0x81ff, 0x2009, 0x0001,
+	0x00c0, 0x2b56, 0x6000, 0xa086, 0x0003, 0x2009, 0x0007, 0x00c0,
+	0x2b56, 0x2001, 0xa352, 0x2004, 0xd0ac, 0x2009, 0x0008, 0x00c0,
+	0x2b56, 0x1078, 0x3542, 0x0040, 0x2b5a, 0x6004, 0xa084, 0x00ff,
+	0xa086, 0x0006, 0x2009, 0x0009, 0x00c0, 0x2b56, 0x0c7e, 0x1078,
+	0x3518, 0x0c7f, 0x2009, 0x0002, 0x0040, 0x2b56, 0x6837, 0x0000,
+	0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x7928, 0xa194, 0xff00,
+	0xa18c, 0x00ff, 0xa006, 0x82ff, 0x00c0, 0x39bc, 0xc0ed, 0x6952,
+	0x792c, 0x6956, 0x0078, 0x39c5, 0xa28e, 0x0100, 0x00c0, 0x2b5a,
+	0xc0e5, 0x6853, 0x0000, 0x6857, 0x0000, 0x683e, 0x1078, 0x8df6,
+	0x2009, 0x0003, 0x0040, 0x2b56, 0x7007, 0x0003, 0x701b, 0x39d1,
+	0x007c, 0x6830, 0xa086, 0x0100, 0x2009, 0x0004, 0x0040, 0x2b56,
+	0x0078, 0x2b2c, 0x81ff, 0x2009, 0x0001, 0x00c0, 0x2b56, 0x6000,
+	0xa086, 0x0003, 0x2009, 0x0007, 0x00c0, 0x2b56, 0x1078, 0x3542,
+	0x0040, 0x2b5a, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x2009,
+	0x0009, 0x00c0, 0x2b56, 0x0c7e, 0x1078, 0x3518, 0x0c7f, 0x2009,
+	0x0002, 0x0040, 0x2b56, 0xad80, 0x000f, 0x2009, 0x0008, 0x7a2c,
+	0x7b28, 0x7c3c, 0x7d38, 0x1078, 0x3562, 0x701b, 0x3a08, 0x007c,
+	0x0d7e, 0xade8, 0x000f, 0x6800, 0xa086, 0x0500, 0x00c0, 0x3a1b,
+	0x6804, 0xa005, 0x00c0, 0x3a1b, 0x6808, 0xa084, 0xff00, 0x00c0,
+	0x3a1b, 0x0078, 0x3a1e, 0x0d7f, 0x00c0, 0x2b5a, 0x0d7f, 0x6837,
+	0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x0c7e, 0x1078,
+	0x3542, 0x00c0, 0x3a2e, 0x0c7f, 0x0078, 0x2b5a, 0x1078, 0x8e52,
+	0x2009, 0x0003, 0x0c7f, 0x0040, 0x2b56, 0x7007, 0x0003, 0x701b,
+	0x3a3a, 0x007c, 0x6830, 0xa086, 0x0100, 0x2009, 0x0004, 0x0040,
+	0x2b56, 0x0078, 0x2b2c, 0x127e, 0x0c7e, 0x0e7e, 0x2061, 0x0100,
+	0x2071, 0xa300, 0x6044, 0xd0a4, 0x00c0, 0x3a6c, 0xd084, 0x0040,
+	0x3a55, 0x1078, 0x3bcc, 0x0078, 0x3a68, 0xd08c, 0x0040, 0x3a5c,
+	0x1078, 0x3ae3, 0x0078, 0x3a68, 0xd094, 0x0040, 0x3a63, 0x1078,
+	0x3ab7, 0x0078, 0x3a68, 0xd09c, 0x0040, 0x3a68, 0x1078, 0x3a76,
+	0x0e7f, 0x0c7f, 0x127f, 0x007c, 0x017e, 0x6128, 0xd19c, 0x00c0,
+	0x3a73, 0xc19d, 0x612a, 0x017f, 0x0078, 0x3a68, 0x624c, 0xa286,
+	0xf0f0, 0x00c0, 0x3a87, 0x6048, 0xa086, 0xf0f0, 0x0040, 0x3a87,
+	0x624a, 0x6043, 0x0090, 0x6043, 0x0010, 0x0078, 0x3ab6, 0xa294,
+	0xff00, 0xa296, 0xf700, 0x0040, 0x3a9c, 0x7134, 0xd1a4, 0x00c0,
+	0x3a9c, 0x6240, 0xa294, 0x0010, 0x0040, 0x3a9c, 0x2009, 0x00f7,
+	0x1078, 0x41de, 0x0078, 0x3ab6, 0x6043, 0x0040, 0x6043, 0x0000,
+	0x7073, 0x0000, 0x708b, 0x0001, 0x70af, 0x0000, 0x70cb, 0x0000,
+	0x2009, 0xa9c0, 0x200b, 0x0000, 0x7083, 0x0000, 0x7077, 0x000f,
+	0x2009, 0x000f, 0x2011, 0x4122, 0x1078, 0x596c, 0x007c, 0x157e,
+	0x7074, 0xa005, 0x00c0, 0x3ae1, 0x2011, 0x4122, 0x1078, 0x58d4,
+	0x6040, 0xa094, 0x0010, 0xa285, 0x0020, 0x6042, 0x20a9, 0x00c8,
+	0x6044, 0xd08c, 0x00c0, 0x3ada, 0x00f0, 0x3ac8, 0x6242, 0x7087,
+	0x0000, 0x6040, 0xa094, 0x0010, 0xa285, 0x0080, 0x6042, 0x6242,
+	0x0078, 0x3ae1, 0x6242, 0x7087, 0x0000, 0x707b, 0x0000, 0x0078,
+	0x3ae1, 0x157f, 0x007c, 0x7078, 0xa08a, 0x0003, 0x00c8, 0x3aec,
+	0x1079, 0x3aef, 0x0078, 0x3aee, 0x1078, 0x1328, 0x007c, 0x3af2,
+	0x3b41, 0x3bcb, 0x0f7e, 0x707b, 0x0001, 0x20e1, 0xa000, 0x20e1,
+	0x8700, 0x1078, 0x218b, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2079,
+	0xa800, 0x207b, 0x2200, 0x7807, 0x00ef, 0x780b, 0x0000, 0x780f,
+	0x00ef, 0x7813, 0x0138, 0x7817, 0x0000, 0x781b, 0x0000, 0x781f,
+	0x0000, 0x7823, 0xffff, 0x7827, 0xffff, 0x782b, 0x0000, 0x782f,
+	0x0000, 0x2079, 0xa80c, 0x207b, 0x1101, 0x7807, 0x0000, 0x2099,
+	0xa305, 0x20a1, 0xa80e, 0x20a9, 0x0004, 0x53a3, 0x2079, 0xa812,
+	0x207b, 0x0000, 0x7807, 0x0000, 0x2099, 0xa800, 0x20a1, 0x020b,
+	0x20a9, 0x0014, 0x53a6, 0x60c3, 0x000c, 0x600f, 0x0000, 0x1078,
+	0x4158, 0x0f7f, 0x707f, 0x0000, 0x6043, 0x0008, 0x6043, 0x0000,
+	0x007c, 0x0d7e, 0x707c, 0x707f, 0x0000, 0xa025, 0x0040, 0x3bb5,
+	0x6020, 0xd0b4, 0x00c0, 0x3bb3, 0x7188, 0x81ff, 0x0040, 0x3ba2,
+	0xa486, 0x000c, 0x00c0, 0x3bad, 0xa480, 0x0018, 0x8004, 0x20a8,
+	0x2011, 0xa880, 0x2019, 0xa800, 0x220c, 0x2304, 0xa106, 0x00c0,
+	0x3b79, 0x8210, 0x8318, 0x00f0, 0x3b5c, 0x6043, 0x0004, 0x608b,
+	0xbc94, 0x608f, 0xf0f0, 0x6043, 0x0006, 0x707b, 0x0002, 0x7087,
+	0x0002, 0x2009, 0x07d0, 0x2011, 0x4129, 0x1078, 0x596c, 0x0078,
+	0x3bb3, 0x2069, 0xa880, 0x6930, 0xa18e, 0x1101, 0x00c0, 0x3bad,
+	0x6834, 0xa005, 0x00c0, 0x3bad, 0x6900, 0xa18c, 0x00ff, 0x00c0,
+	0x3b8d, 0x6804, 0xa005, 0x0040, 0x3ba2, 0x2011, 0xa88e, 0x2019,
+	0xa305, 0x20a9, 0x0004, 0x220c, 0x2304, 0xa102, 0x0048, 0x3ba0,
+	0x00c0, 0x3bad, 0x8210, 0x8318, 0x00f0, 0x3b93, 0x0078, 0x3bad,
+	0x708b, 0x0000, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xa880,
+	0x20a1, 0x020b, 0x20a9, 0x0014, 0x53a6, 0x6043, 0x0008, 0x6043,
+	0x0000, 0x0078, 0x3bb5, 0x0d7f, 0x007c, 0x6020, 0xd0b4, 0x00c0,
+	0x3bb3, 0x60c3, 0x000c, 0x2011, 0xa5b5, 0x2013, 0x0000, 0x707f,
+	0x0000, 0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7, 0x9575, 0x1078,
+	0x6c38, 0x0078, 0x3bb3, 0x007c, 0x7084, 0xa08a, 0x001d, 0x00c8,
+	0x3bd5, 0x1079, 0x3bd8, 0x0078, 0x3bd7, 0x1078, 0x1328, 0x007c,
+	0x3c02, 0x3c11, 0x3c40, 0x3c59, 0x3c85, 0x3cb1, 0x3cdd, 0x3d13,
+	0x3d3f, 0x3d67, 0x3daa, 0x3dd4, 0x3df6, 0x3e0c, 0x3e32, 0x3e45,
+	0x3e4e, 0x3e7e, 0x3eaa, 0x3ed6, 0x3f02, 0x3f38, 0x3f7d, 0x3fac,
+	0x3fce, 0x4010, 0x4036, 0x404f, 0x4050, 0x0c7e, 0x2061, 0xa300,
+	0x6003, 0x0007, 0x2061, 0x0100, 0x6004, 0xa084, 0xfff9, 0x6006,
+	0x0c7f, 0x007c, 0x608b, 0xbc94, 0x608f, 0xf0f0, 0x6043, 0x0002,
+	0x7087, 0x0001, 0x2009, 0x07d0, 0x2011, 0x4129, 0x1078, 0x596c,
+	0x007c, 0x0f7e, 0x707c, 0xa086, 0x0014, 0x00c0, 0x3c3e, 0x6043,
+	0x0000, 0x6020, 0xd0b4, 0x00c0, 0x3c3e, 0x2079, 0xa880, 0x7a30,
+	0xa296, 0x1102, 0x00c0, 0x3c3c, 0x7834, 0xa005, 0x00c0, 0x3c3c,
+	0x7a38, 0xd2fc, 0x0040, 0x3c32, 0x70ac, 0xa005, 0x00c0, 0x3c32,
+	0x70af, 0x0001, 0x2011, 0x4129, 0x1078, 0x58d4, 0x7087, 0x0010,
+	0x1078, 0x3e4e, 0x0078, 0x3c3e, 0x1078, 0x4171, 0x0f7f, 0x007c,
+	0x7087, 0x0003, 0x6043, 0x0004, 0x2011, 0x4129, 0x1078, 0x58d4,
+	0x1078, 0x41c6, 0x20a3, 0x1102, 0x20a3, 0x0000, 0x20a9, 0x000a,
+	0x20a3, 0x0000, 0x00f0, 0x3c50, 0x60c3, 0x0014, 0x1078, 0x4158,
+	0x007c, 0x0f7e, 0x707c, 0xa005, 0x0040, 0x3c83, 0x2011, 0x4129,
+	0x1078, 0x58d4, 0xa086, 0x0014, 0x00c0, 0x3c81, 0x2079, 0xa880,
+	0x7a30, 0xa296, 0x1102, 0x00c0, 0x3c81, 0x7834, 0xa005, 0x00c0,
+	0x3c81, 0x7a38, 0xd2fc, 0x0040, 0x3c7b, 0x70ac, 0xa005, 0x00c0,
+	0x3c7b, 0x70af, 0x0001, 0x7087, 0x0004, 0x1078, 0x3c85, 0x0078,
+	0x3c83, 0x1078, 0x4171, 0x0f7f, 0x007c, 0x7087, 0x0005, 0x1078,
+	0x41c6, 0x20a3, 0x1103, 0x20a3, 0x0000, 0x3430, 0x2011, 0xa88e,
+	0x1078, 0x4211, 0x00c0, 0x3ca3, 0x7070, 0xa005, 0x00c0, 0x3ca3,
+	0x714c, 0xa186, 0xffff, 0x0040, 0x3ca3, 0x1078, 0x40ea, 0x0040,
+	0x3ca3, 0x1078, 0x41f5, 0x20a9, 0x0008, 0x2298, 0x26a0, 0x53a6,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078, 0x4158,
+	0x007c, 0x0f7e, 0x707c, 0xa005, 0x0040, 0x3cdb, 0x2011, 0x4129,
+	0x1078, 0x58d4, 0xa086, 0x0014, 0x00c0, 0x3cd9, 0x2079, 0xa880,
+	0x7a30, 0xa296, 0x1103, 0x00c0, 0x3cd9, 0x7834, 0xa005, 0x00c0,
+	0x3cd9, 0x7a38, 0xd2fc, 0x0040, 0x3cd3, 0x70ac, 0xa005, 0x00c0,
+	0x3cd3, 0x70af, 0x0001, 0x7087, 0x0006, 0x1078, 0x3cdd, 0x0078,
+	0x3cdb, 0x1078, 0x4171, 0x0f7f, 0x007c, 0x7087, 0x0007, 0x1078,
+	0x41c6, 0x20a3, 0x1104, 0x20a3, 0x0000, 0x3430, 0x2011, 0xa88e,
+	0x1078, 0x4211, 0x00c0, 0x3d05, 0x7070, 0xa005, 0x00c0, 0x3d05,
+	0x7150, 0xa186, 0xffff, 0x0040, 0x3d05, 0xa180, 0x293f, 0x200c,
+	0xa18c, 0xff00, 0x810f, 0x1078, 0x40ea, 0x0040, 0x3d05, 0x1078,
+	0x378b, 0x0040, 0x3d05, 0x1078, 0x2500, 0x20a9, 0x0008, 0x2298,
+	0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x1078, 0x4158, 0x007c, 0x0f7e, 0x707c, 0xa005, 0x0040, 0x3d3d,
+	0x2011, 0x4129, 0x1078, 0x58d4, 0xa086, 0x0014, 0x00c0, 0x3d3b,
+	0x2079, 0xa880, 0x7a30, 0xa296, 0x1104, 0x00c0, 0x3d3b, 0x7834,
+	0xa005, 0x00c0, 0x3d3b, 0x7a38, 0xd2fc, 0x0040, 0x3d35, 0x70ac,
+	0xa005, 0x00c0, 0x3d35, 0x70af, 0x0001, 0x7087, 0x0008, 0x1078,
+	0x3d3f, 0x0078, 0x3d3d, 0x1078, 0x4171, 0x0f7f, 0x007c, 0x7087,
+	0x0009, 0x1078, 0x41c6, 0x20a3, 0x1105, 0x20a3, 0x0100, 0x3430,
+	0x1078, 0x4211, 0x00c0, 0x3d58, 0x7070, 0xa005, 0x00c0, 0x3d58,
+	0x1078, 0x4051, 0x00c0, 0x3d62, 0xa085, 0x0001, 0x1078, 0x2500,
+	0x20a9, 0x0008, 0x2099, 0xa88e, 0x26a0, 0x53a6, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078, 0x4158, 0x007c, 0x0f7e,
+	0x707c, 0xa005, 0x0040, 0x3da8, 0x2011, 0x4129, 0x1078, 0x58d4,
+	0xa086, 0x0014, 0x00c0, 0x3da6, 0x2079, 0xa880, 0x7a30, 0xa296,
+	0x1105, 0x00c0, 0x3da6, 0x7834, 0x2011, 0x0100, 0xa21e, 0x00c0,
+	0x3d91, 0x7a38, 0xd2fc, 0x0040, 0x3d8b, 0x70ac, 0xa005, 0x00c0,
+	0x3d8b, 0x70af, 0x0001, 0x7087, 0x000a, 0x1078, 0x3daa, 0x0078,
+	0x3da8, 0xa005, 0x00c0, 0x3da6, 0x7a38, 0xd2fc, 0x0040, 0x3d9e,
+	0x70ac, 0xa005, 0x00c0, 0x3d9e, 0x70af, 0x0001, 0x7083, 0x0000,
+	0x7087, 0x000e, 0x1078, 0x3e32, 0x0078, 0x3da8, 0x1078, 0x4171,
+	0x0f7f, 0x007c, 0x7087, 0x000b, 0x2011, 0xa80e, 0x22a0, 0x20a9,
+	0x0040, 0x2019, 0xffff, 0x43a4, 0x20a9, 0x0002, 0x2009, 0x0000,
+	0x41a4, 0x1078, 0x41c6, 0x20a3, 0x1106, 0x20a3, 0x0000, 0x1078,
+	0x4211, 0x0040, 0x3dc7, 0x2013, 0x0000, 0x0078, 0x3dcb, 0x6030,
+	0xa085, 0x0100, 0x2012, 0x2298, 0x20a9, 0x0042, 0x53a6, 0x60c3,
+	0x0084, 0x1078, 0x4158, 0x007c, 0x0f7e, 0x707c, 0xa005, 0x0040,
+	0x3df4, 0x2011, 0x4129, 0x1078, 0x58d4, 0xa086, 0x0084, 0x00c0,
+	0x3df2, 0x2079, 0xa880, 0x7a30, 0xa296, 0x1106, 0x00c0, 0x3df2,
+	0x7834, 0xa005, 0x00c0, 0x3df2, 0x7087, 0x000c, 0x1078, 0x3df6,
+	0x0078, 0x3df4, 0x1078, 0x4171, 0x0f7f, 0x007c, 0x7087, 0x000d,
+	0x1078, 0x41c6, 0x20a3, 0x1107, 0x20a3, 0x0000, 0x2099, 0xa88e,
+	0x20a9, 0x0040, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0084, 0x1078, 0x4158, 0x007c, 0x0f7e, 0x707c, 0xa005, 0x0040,
+	0x3e30, 0x2011, 0x4129, 0x1078, 0x58d4, 0xa086, 0x0084, 0x00c0,
+	0x3e2e, 0x2079, 0xa880, 0x7a30, 0xa296, 0x1107, 0x00c0, 0x3e2e,
+	0x7834, 0xa005, 0x00c0, 0x3e2e, 0x7083, 0x0001, 0x1078, 0x41b8,
+	0x7087, 0x000e, 0x1078, 0x3e32, 0x0078, 0x3e30, 0x1078, 0x4171,
+	0x0f7f, 0x007c, 0x7087, 0x000f, 0x707f, 0x0000, 0x608b, 0xbc85,
+	0x608f, 0xb5b5, 0x6043, 0x0005, 0x6043, 0x0004, 0x2009, 0x07d0,
+	0x2011, 0x4129, 0x1078, 0x58c7, 0x007c, 0x707c, 0xa005, 0x0040,
+	0x3e4d, 0x2011, 0x4129, 0x1078, 0x58d4, 0x007c, 0x7087, 0x0011,
+	0x1078, 0x4211, 0x00c0, 0x3e67, 0x7168, 0x81ff, 0x0040, 0x3e67,
+	0x2009, 0x0000, 0x706c, 0xa084, 0x00ff, 0x1078, 0x24e3, 0xa186,
+	0x0080, 0x0040, 0x3e67, 0x2011, 0xa88e, 0x1078, 0x40ea, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x2099, 0xa880, 0x20a1, 0x020b, 0x747c,
+	0xa480, 0x0018, 0xa080, 0x0007, 0xa084, 0x03f8, 0x8004, 0x20a8,
+	0x53a6, 0x60c3, 0x0014, 0x1078, 0x4158, 0x007c, 0x0f7e, 0x707c,
+	0xa005, 0x0040, 0x3ea8, 0x2011, 0x4129, 0x1078, 0x58d4, 0xa086,
+	0x0014, 0x00c0, 0x3ea6, 0x2079, 0xa880, 0x7a30, 0xa296, 0x1103,
+	0x00c0, 0x3ea6, 0x7834, 0xa005, 0x00c0, 0x3ea6, 0x7a38, 0xd2fc,
+	0x0040, 0x3ea0, 0x70ac, 0xa005, 0x00c0, 0x3ea0, 0x70af, 0x0001,
+	0x7087, 0x0012, 0x1078, 0x3eaa, 0x0078, 0x3ea8, 0x1078, 0x4171,
+	0x0f7f, 0x007c, 0x7087, 0x0013, 0x1078, 0x41d2, 0x20a3, 0x1103,
+	0x20a3, 0x0000, 0x3430, 0x2011, 0xa88e, 0x1078, 0x4211, 0x00c0,
+	0x3ec8, 0x7070, 0xa005, 0x00c0, 0x3ec8, 0x714c, 0xa186, 0xffff,
+	0x0040, 0x3ec8, 0x1078, 0x40ea, 0x0040, 0x3ec8, 0x1078, 0x41f5,
+	0x20a9, 0x0008, 0x2298, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x60c3, 0x0014, 0x1078, 0x4158, 0x007c, 0x0f7e, 0x707c,
+	0xa005, 0x0040, 0x3f00, 0x2011, 0x4129, 0x1078, 0x58d4, 0xa086,
+	0x0014, 0x00c0, 0x3efe, 0x2079, 0xa880, 0x7a30, 0xa296, 0x1104,
+	0x00c0, 0x3efe, 0x7834, 0xa005, 0x00c0, 0x3efe, 0x7a38, 0xd2fc,
+	0x0040, 0x3ef8, 0x70ac, 0xa005, 0x00c0, 0x3ef8, 0x70af, 0x0001,
+	0x7087, 0x0014, 0x1078, 0x3f02, 0x0078, 0x3f00, 0x1078, 0x4171,
+	0x0f7f, 0x007c, 0x7087, 0x0015, 0x1078, 0x41d2, 0x20a3, 0x1104,
+	0x20a3, 0x0000, 0x3430, 0x2011, 0xa88e, 0x1078, 0x4211, 0x00c0,
+	0x3f2a, 0x7070, 0xa005, 0x00c0, 0x3f2a, 0x7150, 0xa186, 0xffff,
+	0x0040, 0x3f2a, 0xa180, 0x293f, 0x200c, 0xa18c, 0xff00, 0x810f,
+	0x1078, 0x40ea, 0x0040, 0x3f2a, 0x1078, 0x378b, 0x0040, 0x3f2a,
+	0x1078, 0x2500, 0x20a9, 0x0008, 0x2298, 0x26a0, 0x53a6, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078, 0x4158, 0x007c,
+	0x0f7e, 0x707c, 0xa005, 0x0040, 0x3f7b, 0x2011, 0x4129, 0x1078,
+	0x58d4, 0xa086, 0x0014, 0x00c0, 0x3f79, 0x2079, 0xa880, 0x7a30,
+	0xa296, 0x1105, 0x00c0, 0x3f79, 0x7834, 0x2011, 0x0100, 0xa21e,
+	0x00c0, 0x3f5e, 0x7a38, 0xd2fc, 0x0040, 0x3f5c, 0x70ac, 0xa005,
+	0x00c0, 0x3f5c, 0x70af, 0x0001, 0x0078, 0x3f6d, 0xa005, 0x00c0,
+	0x3f79, 0x7a38, 0xd2fc, 0x0040, 0x3f6b, 0x70ac, 0xa005, 0x00c0,
+	0x3f6b, 0x70af, 0x0001, 0x7083, 0x0000, 0x7a38, 0xd2f4, 0x0040,
+	0x3f73, 0x70cb, 0x0008, 0x7087, 0x0016, 0x1078, 0x3f7d, 0x0078,
+	0x3f7b, 0x1078, 0x4171, 0x0f7f, 0x007c, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x2099, 0xa880, 0x20a1, 0x020b, 0x20a9, 0x000e, 0x53a6,
+	0x3430, 0x2011, 0xa88e, 0x7087, 0x0017, 0x1078, 0x4211, 0x00c0,
+	0x3f9d, 0x7070, 0xa005, 0x00c0, 0x3f9d, 0x1078, 0x4051, 0x00c0,
+	0x3fa7, 0xa085, 0x0001, 0x1078, 0x2500, 0x20a9, 0x0008, 0x2099,
+	0xa88e, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0014, 0x1078, 0x4158, 0x007c, 0x0f7e, 0x707c, 0xa005, 0x0040,
+	0x3fcc, 0x2011, 0x4129, 0x1078, 0x58d4, 0xa086, 0x0084, 0x00c0,
+	0x3fca, 0x2079, 0xa880, 0x7a30, 0xa296, 0x1106, 0x00c0, 0x3fca,
+	0x7834, 0xa005, 0x00c0, 0x3fca, 0x7087, 0x0018, 0x1078, 0x3fce,
+	0x0078, 0x3fcc, 0x1078, 0x4171, 0x0f7f, 0x007c, 0x7087, 0x0019,
+	0x1078, 0x41d2, 0x20a3, 0x1106, 0x20a3, 0x0000, 0x3430, 0x2099,
+	0xa88e, 0x2039, 0xa80e, 0x27a0, 0x20a9, 0x0040, 0x53a3, 0x1078,
+	0x4211, 0x00c0, 0x4002, 0x2728, 0x2514, 0x8207, 0xa084, 0x00ff,
+	0x8000, 0x2018, 0xa294, 0x00ff, 0x8007, 0xa205, 0x202a, 0x6030,
+	0x2310, 0x8214, 0xa2a0, 0xa80e, 0x2414, 0xa38c, 0x0001, 0x0040,
+	0x3ffd, 0xa294, 0xff00, 0x0078, 0x4000, 0xa294, 0x00ff, 0x8007,
+	0xa215, 0x2222, 0x2798, 0x26a0, 0x20a9, 0x0040, 0x53a6, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x0084, 0x1078, 0x4158, 0x007c,
+	0x0f7e, 0x707c, 0xa005, 0x0040, 0x4034, 0x2011, 0x4129, 0x1078,
+	0x58d4, 0xa086, 0x0084, 0x00c0, 0x4032, 0x2079, 0xa880, 0x7a30,
+	0xa296, 0x1107, 0x00c0, 0x4032, 0x7834, 0xa005, 0x00c0, 0x4032,
+	0x7083, 0x0001, 0x1078, 0x41b8, 0x7087, 0x001a, 0x1078, 0x4036,
+	0x0078, 0x4034, 0x1078, 0x4171, 0x0f7f, 0x007c, 0x7087, 0x001b,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xa880, 0x20a1, 0x020b,
+	0x747c, 0xa480, 0x0018, 0xa080, 0x0007, 0xa084, 0x03f8, 0x8004,
+	0x20a8, 0x53a6, 0x60c3, 0x0084, 0x1078, 0x4158, 0x007c, 0x007c,
+	0x007c, 0x087e, 0x097e, 0x2029, 0xa352, 0x252c, 0x20a9, 0x0008,
+	0x2041, 0xa80e, 0x28a0, 0x2099, 0xa88e, 0x53a3, 0x20a9, 0x0008,
+	0x2011, 0x0007, 0xd5d4, 0x0040, 0x4067, 0x2011, 0x0000, 0x2800,
+	0xa200, 0x200c, 0xa1a6, 0xffff, 0x00c0, 0x4079, 0xd5d4, 0x0040,
+	0x4074, 0x8210, 0x0078, 0x4075, 0x8211, 0x00f0, 0x4067, 0x0078,
+	0x40e1, 0x82ff, 0x00c0, 0x408b, 0xd5d4, 0x0040, 0x4085, 0xa1a6,
+	0x3fff, 0x0040, 0x4071, 0x0078, 0x4089, 0xa1a6, 0x3fff, 0x0040,
+	0x40e1, 0xa18d, 0xc000, 0x20a9, 0x0010, 0x2019, 0x0001, 0xd5d4,
+	0x0040, 0x4094, 0x2019, 0x0010, 0x2120, 0xd5d4, 0x0040, 0x409b,
+	0x8423, 0x0078, 0x409c, 0x8424, 0x00c8, 0x40a9, 0xd5d4, 0x0040,
+	0x40a4, 0x8319, 0x0078, 0x40a5, 0x8318, 0x00f0, 0x4095, 0x0078,
+	0x40e1, 0x23a8, 0x2021, 0x0001, 0x8426, 0x8425, 0x00f0, 0x40ad,
+	0x2328, 0x8529, 0xa2be, 0x0007, 0x0040, 0x40c1, 0x007e, 0x2039,
+	0x0007, 0x2200, 0xa73a, 0x007f, 0x27a8, 0xa5a8, 0x0010, 0x00f0,
+	0x40bd, 0x754e, 0xa5c8, 0x293f, 0x292c, 0xa5ac, 0x00ff, 0x6532,
+	0x60e7, 0x0000, 0x65ea, 0x706b, 0x0000, 0x756e, 0x2018, 0x2304,
+	0xa405, 0x201a, 0x7073, 0x0001, 0x26a0, 0x2898, 0x20a9, 0x0008,
+	0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0xa085, 0x0001, 0x0078,
+	0x40e7, 0xa006, 0x0078, 0x40e7, 0xa006, 0x1078, 0x1328, 0x097f,
+	0x087f, 0x007c, 0x2118, 0x2021, 0x0000, 0x2001, 0x0007, 0xa39a,
+	0x0010, 0x0048, 0x40f7, 0x8420, 0x8001, 0x0078, 0x40ef, 0x2118,
+	0x84ff, 0x0040, 0x4100, 0xa39a, 0x0010, 0x8421, 0x00c0, 0x40fb,
+	0x2021, 0x0001, 0x83ff, 0x0040, 0x4109, 0x8423, 0x8319, 0x00c0,
+	0x4105, 0xa238, 0x2704, 0xa42c, 0x00c0, 0x4121, 0xa405, 0x203a,
+	0x714e, 0xa1a0, 0x293f, 0x242c, 0xa5ac, 0x00ff, 0x6532, 0x60e7,
+	0x0000, 0x65ea, 0x706b, 0x0000, 0x756e, 0x7073, 0x0001, 0xa084,
+	0x0000, 0x007c, 0x0e7e, 0x2071, 0xa300, 0x7077, 0x0000, 0x0e7f,
+	0x007c, 0x0e7e, 0x0f7e, 0x2001, 0x0002, 0x1078, 0x5975, 0x2079,
+	0x0100, 0x2071, 0x0140, 0x1078, 0x6c41, 0x7004, 0xa084, 0x4000,
+	0x0040, 0x413e, 0x7003, 0x1000, 0x7003, 0x0000, 0x127e, 0x2091,
+	0x8000, 0x2071, 0xa321, 0x2073, 0x0000, 0x7840, 0x027e, 0x017e,
+	0x2009, 0x00f7, 0x1078, 0x41de, 0x017f, 0xa094, 0x0010, 0xa285,
+	0x0080, 0x7842, 0x7a42, 0x027f, 0x127f, 0x0f7f, 0x0e7f, 0x007c,
+	0x127e, 0x2091, 0x8000, 0x2011, 0xa5b5, 0x2013, 0x0000, 0x707f,
+	0x0000, 0x127f, 0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7, 0x9575,
+	0x1078, 0x6c38, 0x2009, 0x07d0, 0x2011, 0x4129, 0x1078, 0x596c,
+	0x007c, 0x017e, 0x027e, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x2009,
+	0x00f7, 0x1078, 0x41de, 0x2061, 0xa5be, 0x601b, 0x0000, 0x601f,
+	0x0000, 0x2061, 0xa300, 0x6003, 0x0001, 0x2061, 0x0100, 0x6043,
+	0x0090, 0x6043, 0x0010, 0x2009, 0x002d, 0x2011, 0x4196, 0x1078,
+	0x58c7, 0x127f, 0x0c7f, 0x027f, 0x017f, 0x007c, 0x0e7e, 0x007e,
+	0x127e, 0x2091, 0x8000, 0x2001, 0x0001, 0x1078, 0x5975, 0x2071,
+	0x0100, 0x1078, 0x6c41, 0x2071, 0x0140, 0x7004, 0xa084, 0x4000,
+	0x0040, 0x41ae, 0x7003, 0x1000, 0x7003, 0x0000, 0x2001, 0x0001,
+	0x1078, 0x2480, 0x1078, 0x4171, 0x127f, 0x007f, 0x0e7f, 0x007c,
+	0x20a9, 0x0040, 0x20a1, 0xa9c0, 0x2099, 0xa88e, 0x3304, 0x8007,
+	0x20a2, 0x9398, 0x94a0, 0x00f0, 0x41be, 0x007c, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x2099, 0xa800, 0x20a1, 0x020b, 0x20a9, 0x000c,
+	0x53a6, 0x007c, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xa880,
+	0x20a1, 0x020b, 0x20a9, 0x000c, 0x53a6, 0x007c, 0x0c7e, 0x007e,
+	0x2061, 0x0100, 0x810f, 0x2001, 0xa32e, 0x2004, 0xa005, 0x00c0,
+	0x41ef, 0x6030, 0xa084, 0x00ff, 0xa105, 0x0078, 0x41f1, 0xa185,
+	0x00f7, 0x604a, 0x007f, 0x0c7f, 0x007c, 0x017e, 0x047e, 0x2001,
+	0xa352, 0x2004, 0xd0a4, 0x0040, 0x4208, 0xa006, 0x2020, 0x2009,
+	0x002a, 0x1078, 0x9ec0, 0x2001, 0xa30c, 0x200c, 0xc195, 0x2102,
+	0x2019, 0x002a, 0x2009, 0x0000, 0x1078, 0x27e2, 0x047f, 0x017f,
+	0x007c, 0x007e, 0x2001, 0xa30c, 0x2004, 0xd09c, 0x0040, 0x4218,
+	0x007f, 0x007c, 0x007e, 0x017e, 0x127e, 0x2091, 0x8000, 0x2001,
+	0x0101, 0x200c, 0xa18d, 0x0006, 0x2102, 0x127f, 0x017f, 0x007f,
+	0x007c, 0x157e, 0x20a9, 0x00ff, 0x2009, 0xa434, 0xa006, 0x200a,
+	0x8108, 0x00f0, 0x422f, 0x157f, 0x007c, 0x0d7e, 0x037e, 0x157e,
+	0x137e, 0x147e, 0x2069, 0xa351, 0xa006, 0x6002, 0x6007, 0x0707,
+	0x600a, 0x600e, 0x6012, 0xa198, 0x293f, 0x231c, 0xa39c, 0x00ff,
+	0x6316, 0x20a9, 0x0004, 0xac98, 0x0006, 0x23a0, 0x40a4, 0x20a9,
+	0x0004, 0xac98, 0x000a, 0x23a0, 0x40a4, 0x603e, 0x6042, 0x604e,
+	0x6052, 0x6056, 0x605a, 0x605e, 0x6062, 0x6066, 0x606a, 0x606e,
+	0x6072, 0x6076, 0x607a, 0x607e, 0x6082, 0x6086, 0x608a, 0x608e,
+	0x6092, 0x6096, 0x609a, 0x609e, 0x60ae, 0x61a2, 0x0d7e, 0x60a4,
+	0xa06d, 0x0040, 0x4275, 0x1078, 0x139a, 0x60a7, 0x0000, 0x60a8,
+	0xa06d, 0x0040, 0x427d, 0x1078, 0x139a, 0x60ab, 0x0000, 0x0d7f,
+	0xa006, 0x604a, 0x6810, 0x603a, 0x680c, 0x6046, 0x6814, 0xa084,
+	0x00ff, 0x6042, 0x147f, 0x137f, 0x157f, 0x037f, 0x0d7f, 0x007c,
+	0x127e, 0x2091, 0x8000, 0x6944, 0x6e48, 0xa684, 0x3fff, 0xa082,
+	0x4000, 0x00c8, 0x4361, 0xa18c, 0xff00, 0x810f, 0xa182, 0x00ff,
+	0x00c8, 0x4367, 0x2001, 0xa30c, 0x2004, 0xa084, 0x0003, 0x0040,
+	0x42c2, 0x2001, 0xa30c, 0x2004, 0xd084, 0x00c0, 0x4342, 0xa188,
+	0xa434, 0x2104, 0xa065, 0x0040, 0x4342, 0x6004, 0xa084, 0x00ff,
+	0xa08e, 0x0006, 0x00c0, 0x4342, 0x6000, 0xd0c4, 0x0040, 0x4342,
+	0x0078, 0x42cf, 0xa188, 0xa434, 0x2104, 0xa065, 0x0040, 0x4326,
+	0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006, 0x00c0, 0x432c, 0x60a4,
+	0xa00d, 0x0040, 0x42d7, 0x1078, 0x4749, 0x0040, 0x4320, 0x60a8,
+	0xa00d, 0x0040, 0x42f1, 0x1078, 0x479a, 0x00c0, 0x42f1, 0x694c,
+	0xd1fc, 0x00c0, 0x42e7, 0x1078, 0x441c, 0x0078, 0x431b, 0x1078,
+	0x43d6, 0x694c, 0xd1ec, 0x00c0, 0x431b, 0x1078, 0x460a, 0x0078,
+	0x431b, 0x694c, 0xa184, 0xa000, 0x0040, 0x430b, 0xd1ec, 0x0040,
+	0x4304, 0xd1fc, 0x0040, 0x4300, 0x1078, 0x461b, 0x0078, 0x4307,
+	0x1078, 0x461b, 0x0078, 0x430b, 0xd1fc, 0x0040, 0x430b, 0x1078,
+	0x43d6, 0x0078, 0x431b, 0x6050, 0xa00d, 0x0040, 0x4316, 0x2d00,
+	0x200a, 0x6803, 0x0000, 0x6052, 0x0078, 0x431b, 0x2d00, 0x6052,
+	0x604e, 0x6803, 0x0000, 0x1078, 0x5c17, 0xa006, 0x127f, 0x007c,
+	0x2001, 0x0005, 0x2009, 0x0000, 0x0078, 0x436b, 0x2001, 0x0028,
+	0x2009, 0x0000, 0x0078, 0x436b, 0xa082, 0x0006, 0x00c8, 0x4342,
+	0x60a0, 0xd0bc, 0x00c0, 0x433e, 0x6100, 0xd1fc, 0x0040, 0x42cf,
+	0x2001, 0x0029, 0x2009, 0x1000, 0x0078, 0x436b, 0x2001, 0x0028,
+	0x0078, 0x435d, 0x2009, 0xa30c, 0x210c, 0xd18c, 0x0040, 0x434c,
+	0x2001, 0x0004, 0x0078, 0x435d, 0xd184, 0x0040, 0x4353, 0x2001,
+	0x0004, 0x0078, 0x435d, 0x2001, 0x0029, 0x6100, 0xd1fc, 0x0040,
+	0x435d, 0x2009, 0x1000, 0x0078, 0x436b, 0x2009, 0x0000, 0x0078,
+	0x436b, 0x2001, 0x0029, 0x2009, 0x0000, 0x0078, 0x436b, 0x2001,
+	0x0029, 0x2009, 0x0000, 0xa005, 0x127f, 0x007c, 0x6944, 0x6e48,
+	0xa684, 0x3fff, 0xa082, 0x4000, 0x00c8, 0x43bb, 0xa18c, 0xff00,
+	0x810f, 0xa182, 0x00ff, 0x00c8, 0x43a1, 0xa188, 0xa434, 0x2104,
+	0xa065, 0x0040, 0x43a1, 0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006,
+	0x00c0, 0x43a7, 0x684c, 0xd0ec, 0x0040, 0x4394, 0x1078, 0x461b,
+	0x1078, 0x43d6, 0x0078, 0x439c, 0x1078, 0x43d6, 0x684c, 0xd0fc,
+	0x0040, 0x439c, 0x1078, 0x460a, 0x1078, 0x4663, 0xa006, 0x0078,
+	0x43bf, 0x2001, 0x0028, 0x2009, 0x0000, 0x0078, 0x43bf, 0xa082,
+	0x0006, 0x00c8, 0x43b5, 0x6100, 0xd1fc, 0x0040, 0x438a, 0x2001,
+	0x0029, 0x2009, 0x1000, 0x0078, 0x43bf, 0x2001, 0x0029, 0x2009,
+	0x0000, 0x0078, 0x43bf, 0x2001, 0x0029, 0x2009, 0x0000, 0xa005,
+	0x007c, 0x127e, 0x2091, 0x8000, 0x6050, 0xa00d, 0x0040, 0x43cf,
+	0x2d00, 0x200a, 0x6803, 0x0000, 0x6052, 0x127f, 0x007c, 0x2d00,
+	0x6052, 0x604e, 0x6803, 0x0000, 0x0078, 0x43cd, 0x127e, 0x2091,
+	0x8000, 0x604c, 0xa005, 0x0040, 0x43ec, 0x0e7e, 0x2071, 0xa5ab,
+	0x7004, 0xa086, 0x0002, 0x0040, 0x43f3, 0x0e7f, 0x604c, 0x6802,
+	0x2d00, 0x604e, 0x127f, 0x007c, 0x2d00, 0x6052, 0x604e, 0x6803,
+	0x0000, 0x0078, 0x43ea, 0x701c, 0xac06, 0x00c0, 0x43e5, 0x604c,
+	0x2070, 0x7000, 0x6802, 0x2d00, 0x7002, 0x0e7f, 0x127f, 0x007c,
+	0x127e, 0x2091, 0x8000, 0x604c, 0xa06d, 0x0040, 0x440e, 0x6800,
+	0xa005, 0x00c0, 0x440c, 0x6052, 0x604e, 0xad05, 0x127f, 0x007c,
+	0x604c, 0xa06d, 0x0040, 0x441b, 0x6800, 0xa005, 0x00c0, 0x4419,
+	0x6052, 0x604e, 0xad05, 0x007c, 0x6803, 0x0000, 0x6084, 0xa00d,
+	0x0040, 0x4426, 0x2d00, 0x200a, 0x6086, 0x007c, 0x2d00, 0x6086,
+	0x6082, 0x0078, 0x4425, 0x127e, 0x0c7e, 0x027e, 0x2091, 0x8000,
+	0x6218, 0x2260, 0x6200, 0xa005, 0x0040, 0x4439, 0xc285, 0x0078,
+	0x443a, 0xc284, 0x6202, 0x027f, 0x0c7f, 0x127f, 0x007c, 0x127e,
+	0x0c7e, 0x2091, 0x8000, 0x6218, 0x2260, 0x6204, 0x007e, 0xa086,
+	0x0006, 0x00c0, 0x445e, 0x609c, 0xd0ac, 0x0040, 0x445e, 0x2001,
+	0xa352, 0x2004, 0xd0a4, 0x0040, 0x445e, 0xa284, 0xff00, 0x8007,
+	0xa086, 0x0007, 0x00c0, 0x445e, 0x2011, 0x0600, 0x007f, 0xa294,
+	0xff00, 0xa215, 0x6206, 0x007e, 0xa086, 0x0006, 0x00c0, 0x446e,
+	0x6290, 0x82ff, 0x00c0, 0x446e, 0x1078, 0x1328, 0x007f, 0x0c7f,
+	0x127f, 0x007c, 0x127e, 0x0c7e, 0x2091, 0x8000, 0x6218, 0x2260,
+	0x6204, 0x007e, 0xa086, 0x0006, 0x00c0, 0x4490, 0x609c, 0xd0a4,
+	0x0040, 0x4490, 0x2001, 0xa352, 0x2004, 0xd0ac, 0x00c0, 0x4490,
+	0xa284, 0x00ff, 0xa086, 0x0007, 0x00c0, 0x4490, 0x2011, 0x0006,
+	0x007f, 0xa294, 0x00ff, 0x8007, 0xa215, 0x6206, 0x0c7f, 0x127f,
+	0x007c, 0x027e, 0xa182, 0x00ff, 0x0048, 0x44a2, 0xa085, 0x0001,
+	0x0078, 0x44ba, 0xa190, 0xa434, 0x2204, 0xa065, 0x00c0, 0x44b9,
+	0x017e, 0x0d7e, 0x1078, 0x1366, 0x2d60, 0x0d7f, 0x017f, 0x0040,
+	0x449e, 0x2c00, 0x2012, 0x60a7, 0x0000, 0x60ab, 0x0000, 0x1078,
+	0x4235, 0xa006, 0x027f, 0x007c, 0x127e, 0x2091, 0x8000, 0x027e,
+	0xa182, 0x00ff, 0x0048, 0x44c8, 0xa085, 0x0001, 0x0078, 0x44fe,
+	0x0d7e, 0xa190, 0xa434, 0x2204, 0xa06d, 0x0040, 0x44fc, 0x2013,
+	0x0000, 0x0d7e, 0x0c7e, 0x2d60, 0x60a4, 0xa06d, 0x0040, 0x44da,
+	0x1078, 0x139a, 0x60a8, 0xa06d, 0x0040, 0x44e0, 0x1078, 0x139a,
+	0x0c7f, 0x0d7f, 0x0d7e, 0x0c7e, 0x68ac, 0x2060, 0x8cff, 0x0040,
+	0x44f8, 0x600c, 0x007e, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040,
+	0x44f3, 0x1078, 0x13aa, 0x1078, 0x753d, 0x0c7f, 0x0078, 0x44e6,
+	0x0c7f, 0x0d7f, 0x1078, 0x139a, 0x0d7f, 0xa006, 0x027f, 0x127f,
+	0x007c, 0x017e, 0xa182, 0x00ff, 0x0048, 0x450a, 0xa085, 0x0001,
+	0x0078, 0x4511, 0xa188, 0xa434, 0x2104, 0xa065, 0x0040, 0x4506,
+	0xa006, 0x017f, 0x007c, 0x0d7e, 0x157e, 0x137e, 0x147e, 0x600b,
+	0x0000, 0x600f, 0x0000, 0x6000, 0xc08c, 0x6002, 0x2069, 0xa88e,
+	0x6808, 0x605e, 0x6810, 0x6062, 0x6138, 0xa10a, 0x0048, 0x4529,
+	0x603a, 0x6814, 0x6066, 0x2099, 0xa896, 0xac88, 0x000a, 0x21a0,
+	0x20a9, 0x0004, 0x53a3, 0x2099, 0xa89a, 0xac88, 0x0006, 0x21a0,
+	0x20a9, 0x0004, 0x53a3, 0x2069, 0xa8ae, 0x6808, 0x606a, 0x690c,
+	0x616e, 0x6810, 0x6072, 0x6818, 0x6076, 0xa182, 0x0211, 0x00c8,
+	0x454d, 0x2009, 0x0008, 0x0078, 0x4577, 0xa182, 0x0259, 0x00c8,
+	0x4555, 0x2009, 0x0007, 0x0078, 0x4577, 0xa182, 0x02c1, 0x00c8,
+	0x455d, 0x2009, 0x0006, 0x0078, 0x4577, 0xa182, 0x0349, 0x00c8,
+	0x4565, 0x2009, 0x0005, 0x0078, 0x4577, 0xa182, 0x0421, 0x00c8,
+	0x456d, 0x2009, 0x0004, 0x0078, 0x4577, 0xa182, 0x0581, 0x00c8,
+	0x4575, 0x2009, 0x0003, 0x0078, 0x4577, 0x2009, 0x0002, 0x6192,
+	0x147f, 0x137f, 0x157f, 0x0d7f, 0x007c, 0x017e, 0x027e, 0x0e7e,
+	0x2071, 0xa88d, 0x2e04, 0x6896, 0x2071, 0xa88e, 0x7004, 0x689a,
+	0x701c, 0x689e, 0x6a00, 0x2009, 0xa371, 0x210c, 0xd0bc, 0x0040,
+	0x4597, 0xd1ec, 0x0040, 0x4597, 0xc2ad, 0x0078, 0x4598, 0xc2ac,
+	0xd0c4, 0x0040, 0x45a1, 0xd1e4, 0x0040, 0x45a1, 0xc2bd, 0x0078,
+	0x45a2, 0xc2bc, 0x6a02, 0x0e7f, 0x027f, 0x017f, 0x007c, 0x0d7e,
+	0x127e, 0x2091, 0x8000, 0x60a4, 0xa06d, 0x0040, 0x45cb, 0x6900,
+	0x81ff, 0x00c0, 0x45df, 0x6a04, 0xa282, 0x0010, 0x00c8, 0x45e4,
+	0xad88, 0x0004, 0x20a9, 0x0010, 0x2104, 0xa086, 0xffff, 0x0040,
+	0x45c6, 0x8108, 0x00f0, 0x45bc, 0x1078, 0x1328, 0x260a, 0x8210,
+	0x6a06, 0x0078, 0x45df, 0x1078, 0x1381, 0x0040, 0x45e4, 0x2d00,
+	0x60a6, 0x6803, 0x0000, 0xad88, 0x0004, 0x20a9, 0x0010, 0x200b,
+	0xffff, 0x8108, 0x00f0, 0x45d7, 0x6807, 0x0001, 0x6e12, 0xa085,
+	0x0001, 0x127f, 0x0d7f, 0x007c, 0xa006, 0x0078, 0x45e1, 0x127e,
+	0x2091, 0x8000, 0x0d7e, 0x60a4, 0xa00d, 0x0040, 0x4607, 0x2168,
+	0x6800, 0xa005, 0x00c0, 0x4603, 0x1078, 0x4749, 0x00c0, 0x4607,
+	0x200b, 0xffff, 0x6804, 0xa08a, 0x0002, 0x0048, 0x4603, 0x8001,
+	0x6806, 0x0078, 0x4607, 0x1078, 0x139a, 0x60a7, 0x0000, 0x0d7f,
+	0x127f, 0x007c, 0x127e, 0x2091, 0x8000, 0x1078, 0x47af, 0x0078,
+	0x4613, 0x1078, 0x43c1, 0x1078, 0x46a7, 0x00c0, 0x4611, 0x1078,
+	0x4663, 0x127f, 0x007c, 0x0d7e, 0x127e, 0x2091, 0x8000, 0x60a8,
+	0xa06d, 0x0040, 0x463f, 0x6950, 0x81ff, 0x00c0, 0x4653, 0x6a54,
+	0xa282, 0x0010, 0x00c8, 0x4660, 0xad88, 0x0018, 0x20a9, 0x0010,
+	0x2104, 0xa086, 0xffff, 0x0040, 0x463a, 0x8108, 0x00f0, 0x4630,
+	0x1078, 0x1328, 0x260a, 0x8210, 0x6a56, 0x0078, 0x4653, 0x1078,
+	0x1381, 0x0040, 0x4660, 0x2d00, 0x60aa, 0x6853, 0x0000, 0xad88,
+	0x0018, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108, 0x00f0, 0x464b,
+	0x6857, 0x0001, 0x6e62, 0x0078, 0x4657, 0x1078, 0x441c, 0x1078,
+	0x466d, 0x00c0, 0x4655, 0xa085, 0x0001, 0x127f, 0x0d7f, 0x007c,
+	0xa006, 0x0078, 0x465d, 0x127e, 0x2091, 0x8000, 0x1078, 0x5c17,
+	0x127f, 0x007c, 0xa01e, 0x0078, 0x466f, 0x2019, 0x0001, 0xa00e,
+	0x127e, 0x2091, 0x8000, 0x604c, 0x2068, 0x6000, 0xd0dc, 0x00c0,
+	0x468d, 0x8dff, 0x0040, 0x46a2, 0x83ff, 0x0040, 0x4685, 0x6848,
+	0xa606, 0x0040, 0x4692, 0x0078, 0x468d, 0x683c, 0xa406, 0x00c0,
+	0x468d, 0x6840, 0xa506, 0x0040, 0x4692, 0x2d08, 0x6800, 0x2068,
+	0x0078, 0x4679, 0x6a00, 0x604c, 0xad06, 0x00c0, 0x469a, 0x624e,
+	0x0078, 0x469d, 0xa180, 0x0000, 0x2202, 0x82ff, 0x00c0, 0x46a2,
+	0x6152, 0x8dff, 0x127f, 0x007c, 0xa01e, 0x0078, 0x46a9, 0x2019,
+	0x0001, 0xa00e, 0x6080, 0x2068, 0x8dff, 0x0040, 0x46d5, 0x83ff,
+	0x0040, 0x46b8, 0x6848, 0xa606, 0x0040, 0x46c5, 0x0078, 0x46c0,
+	0x683c, 0xa406, 0x00c0, 0x46c0, 0x6840, 0xa506, 0x0040, 0x46c5,
+	0x2d08, 0x6800, 0x2068, 0x0078, 0x46ac, 0x6a00, 0x6080, 0xad06,
+	0x00c0, 0x46cd, 0x6282, 0x0078, 0x46d0, 0xa180, 0x0000, 0x2202,
+	0x82ff, 0x00c0, 0x46d5, 0x6186, 0x8dff, 0x007c, 0xa016, 0x1078,
+	0x4742, 0x00c0, 0x46dd, 0x2011, 0x0001, 0x1078, 0x4793, 0x00c0,
+	0x46e3, 0xa295, 0x0002, 0x007c, 0x1078, 0x47cb, 0x0040, 0x46ec,
+	0x1078, 0x8b12, 0x0078, 0x46ee, 0xa085, 0x0001, 0x007c, 0x1078,
+	0x47cb, 0x0040, 0x46f7, 0x1078, 0x8aaa, 0x0078, 0x46f9, 0xa085,
+	0x0001, 0x007c, 0x1078, 0x47cb, 0x0040, 0x4702, 0x1078, 0x8af4,
+	0x0078, 0x4704, 0xa085, 0x0001, 0x007c, 0x1078, 0x47cb, 0x0040,
+	0x470d, 0x1078, 0x8ac6, 0x0078, 0x470f, 0xa085, 0x0001, 0x007c,
+	0x1078, 0x47cb, 0x0040, 0x4718, 0x1078, 0x8b30, 0x0078, 0x471a,
+	0xa085, 0x0001, 0x007c, 0x127e, 0x007e, 0x0d7e, 0x2091, 0x8000,
+	0x6080, 0xa06d, 0x0040, 0x473a, 0x6800, 0x007e, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x1078, 0x8cb8, 0x007e, 0x6000, 0xd0fc,
+	0x0040, 0x4734, 0x1078, 0xa18c, 0x007f, 0x1078, 0x4982, 0x007f,
+	0x0078, 0x4721, 0x6083, 0x0000, 0x6087, 0x0000, 0x0d7f, 0x007f,
+	0x127f, 0x007c, 0x60a4, 0xa00d, 0x00c0, 0x4749, 0xa085, 0x0001,
+	0x007c, 0x0e7e, 0x2170, 0x7000, 0xa005, 0x00c0, 0x475c, 0x20a9,
+	0x0010, 0xae88, 0x0004, 0x2104, 0xa606, 0x0040, 0x475c, 0x8108,
+	0x00f0, 0x4753, 0xa085, 0x0001, 0xa006, 0x0e7f, 0x007c, 0x0d7e,
+	0x127e, 0x2091, 0x8000, 0x60a4, 0xa06d, 0x00c0, 0x476d, 0x1078,
+	0x1381, 0x0040, 0x477f, 0x2d00, 0x60a6, 0x6803, 0x0001, 0x6807,
+	0x0000, 0xad88, 0x0004, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108,
+	0x00f0, 0x4775, 0xa085, 0x0001, 0x127f, 0x0d7f, 0x007c, 0xa006,
+	0x0078, 0x477c, 0x0d7e, 0x127e, 0x2091, 0x8000, 0x60a4, 0xa06d,
+	0x0040, 0x4790, 0x60a7, 0x0000, 0x1078, 0x139a, 0xa085, 0x0001,
+	0x127f, 0x0d7f, 0x007c, 0x60a8, 0xa00d, 0x00c0, 0x479a, 0xa085,
+	0x0001, 0x007c, 0x0e7e, 0x2170, 0x7050, 0xa005, 0x00c0, 0x47ad,
+	0x20a9, 0x0010, 0xae88, 0x0018, 0x2104, 0xa606, 0x0040, 0x47ad,
+	0x8108, 0x00f0, 0x47a4, 0xa085, 0x0001, 0x0e7f, 0x007c, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x4793, 0x00c0, 0x47c9, 0x200b, 0xffff,
+	0x0d7e, 0x60a8, 0x2068, 0x6854, 0xa08a, 0x0002, 0x0048, 0x47c4,
+	0x8001, 0x6856, 0x0078, 0x47c8, 0x1078, 0x139a, 0x60ab, 0x0000,
+	0x0d7f, 0x127f, 0x007c, 0x609c, 0xd0a4, 0x007c, 0x0f7e, 0x71ac,
+	0x81ff, 0x00c0, 0x47e9, 0x71c8, 0xd19c, 0x0040, 0x47e9, 0x2001,
+	0x007e, 0xa080, 0xa434, 0x2004, 0xa07d, 0x0040, 0x47e9, 0x7804,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0, 0x47e9, 0x7800, 0xc0ed,
+	0x7802, 0x2079, 0xa351, 0x7804, 0xd0a4, 0x0040, 0x480f, 0x157e,
+	0x0c7e, 0x20a9, 0x007f, 0x2009, 0x0000, 0x017e, 0x1078, 0x4501,
+	0x00c0, 0x4809, 0x6004, 0xa084, 0xff00, 0x8007, 0xa096, 0x0004,
+	0x0040, 0x4806, 0xa086, 0x0006, 0x00c0, 0x4809, 0x6000, 0xc0ed,
+	0x6002, 0x017f, 0x8108, 0x00f0, 0x47f5, 0x0c7f, 0x157f, 0x1078,
+	0x4897, 0x0040, 0x4818, 0x2001, 0xa59f, 0x200c, 0x0078, 0x4820,
+	0x2079, 0xa351, 0x7804, 0xd0a4, 0x0040, 0x4824, 0x2009, 0x07d0,
+	0x2011, 0x4826, 0x1078, 0x596c, 0x0f7f, 0x007c, 0x2011, 0x4826,
+	0x1078, 0x58d4, 0x1078, 0x4897, 0x0040, 0x484e, 0x2001, 0xa4b2,
+	0x2004, 0xa080, 0x0000, 0x200c, 0xc1ec, 0x2102, 0x2001, 0xa352,
+	0x2004, 0xd0a4, 0x0040, 0x4842, 0x2009, 0x07d0, 0x2011, 0x4826,
+	0x1078, 0x596c, 0x0e7e, 0x2071, 0xa300, 0x706b, 0x0000, 0x706f,
+	0x0000, 0x1078, 0x260d, 0x0e7f, 0x0078, 0x4886, 0x157e, 0x0c7e,
+	0x20a9, 0x007f, 0x2009, 0x0000, 0x017e, 0x1078, 0x4501, 0x00c0,
+	0x4880, 0x6000, 0xd0ec, 0x0040, 0x4880, 0x047e, 0x62a0, 0xa294,
+	0x00ff, 0x8227, 0xa006, 0x2009, 0x0029, 0x1078, 0x9ec0, 0x6000,
+	0xc0e5, 0xc0ec, 0x6002, 0x6004, 0xa084, 0x00ff, 0xa085, 0x0700,
+	0x6006, 0x2019, 0x0029, 0x1078, 0x5d53, 0x077e, 0x2039, 0x0000,
+	0x1078, 0x5c78, 0x2009, 0x0000, 0x1078, 0x9c38, 0x077f, 0x047f,
+	0x017f, 0x8108, 0x00f0, 0x4854, 0x0c7f, 0x157f, 0x007c, 0x0c7e,
+	0x6018, 0x2060, 0x6000, 0xc0ec, 0x6002, 0x0c7f, 0x007c, 0x7818,
+	0x2004, 0xd0ac, 0x007c, 0x7818, 0x2004, 0xd0bc, 0x007c, 0x0f7e,
+	0x2001, 0xa4b2, 0x2004, 0xa07d, 0x0040, 0x48a0, 0x7800, 0xd0ec,
+	0x0f7f, 0x007c, 0x127e, 0x027e, 0x2091, 0x8000, 0x6200, 0xa005,
+	0x0040, 0x48ad, 0xc2fd, 0x0078, 0x48ae, 0xc2fc, 0x6202, 0x027f,
+	0x127f, 0x007c, 0x2071, 0xa413, 0x7003, 0x0001, 0x7007, 0x0000,
+	0x7013, 0x0000, 0x7017, 0x0000, 0x701b, 0x0000, 0x701f, 0x0000,
+	0x700b, 0x0000, 0x704b, 0x0001, 0x704f, 0x0000, 0x705b, 0x0020,
+	0x705f, 0x0040, 0x707f, 0x0000, 0x2071, 0xa57c, 0x7003, 0xa413,
+	0x7007, 0x0000, 0x700b, 0x0000, 0x700f, 0xa55c, 0x7013, 0x0020,
+	0x7017, 0x0040, 0x7037, 0x0000, 0x007c, 0x017e, 0x0e7e, 0x2071,
+	0xa534, 0xa00e, 0x7186, 0x718a, 0x7097, 0x0001, 0x2001, 0xa352,
+	0x2004, 0xd0fc, 0x00c0, 0x48f7, 0x2001, 0xa352, 0x2004, 0xa00e,
+	0xd09c, 0x0040, 0x48f4, 0x8108, 0x7102, 0x0078, 0x494a, 0x2001,
+	0xa371, 0x200c, 0xa184, 0x000f, 0x2009, 0xa372, 0x210c, 0x0079,
+	0x4901, 0x48ec, 0x4922, 0x492a, 0x4935, 0x493b, 0x48ec, 0x48ec,
+	0x48ec, 0x4911, 0x48ec, 0x48ec, 0x48ec, 0x48ec, 0x48ec, 0x48ec,
+	0x48ec, 0x7003, 0x0004, 0x137e, 0x147e, 0x157e, 0x2099, 0xa375,
+	0x20a1, 0xa585, 0x20a9, 0x0004, 0x53a3, 0x157f, 0x147f, 0x137f,
+	0x0078, 0x494a, 0x708f, 0x0005, 0x7007, 0x0122, 0x2001, 0x0002,
+	0x0078, 0x4930, 0x708f, 0x0002, 0x7007, 0x0121, 0x2001, 0x0003,
+	0x7002, 0x7097, 0x0001, 0x0078, 0x4947, 0x7007, 0x0122, 0x2001,
+	0x0002, 0x0078, 0x493f, 0x7007, 0x0121, 0x2001, 0x0003, 0x7002,
+	0xa006, 0x7096, 0x708e, 0xa184, 0xff00, 0x8007, 0x709a, 0xa184,
+	0x00ff, 0x7092, 0x0e7f, 0x017f, 0x007c, 0x0e7e, 0x2071, 0xa413,
+	0x684c, 0xa005, 0x00c0, 0x495b, 0x7028, 0xc085, 0x702a, 0xa085,
+	0x0001, 0x0078, 0x4980, 0x6a60, 0x7236, 0x6b64, 0x733a, 0x6868,
+	0x703e, 0x7076, 0x686c, 0x7042, 0x707a, 0x684c, 0x702e, 0x6844,
+	0x7032, 0x2009, 0x000d, 0x200a, 0x700b, 0x0000, 0x8007, 0x8006,
+	0x8006, 0xa08c, 0x003f, 0xa084, 0xffc0, 0xa210, 0x2100, 0xa319,
+	0x726e, 0x7372, 0x7028, 0xc084, 0x702a, 0x7007, 0x0001, 0xa006,
+	0x0e7f, 0x007c, 0x0e7e, 0x027e, 0x6838, 0xd0fc, 0x00c0, 0x49d8,
+	0x6804, 0xa00d, 0x0040, 0x499e, 0x0d7e, 0x2071, 0xa300, 0xa016,
+	0x702c, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x00c0,
+	0x4991, 0x702e, 0x70a8, 0xa200, 0x70aa, 0x0d7f, 0x2071, 0xa413,
+	0x701c, 0xa005, 0x00c0, 0x49ea, 0x0068, 0x49e8, 0x2071, 0xa534,
+	0x7200, 0x82ff, 0x0040, 0x49e8, 0x6934, 0xa186, 0x0103, 0x00c0,
+	0x49fb, 0x6948, 0x6844, 0xa105, 0x00c0, 0x49db, 0x2009, 0x8020,
+	0x2200, 0x0079, 0x49bb, 0x49e8, 0x49c0, 0x4a18, 0x4a26, 0x49e8,
+	0x2071, 0x0000, 0x7018, 0xd084, 0x00c0, 0x49e8, 0x7122, 0x683c,
+	0x7026, 0x6840, 0x702a, 0x701b, 0x0001, 0x2091, 0x4080, 0x2071,
+	0xa300, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70a8, 0x8000, 0x70aa,
+	0x027f, 0x0e7f, 0x007c, 0x6844, 0xa086, 0x0100, 0x00c0, 0x49e8,
+	0x6868, 0xa005, 0x00c0, 0x49e8, 0x2009, 0x8020, 0x0078, 0x49b8,
+	0x2071, 0xa413, 0x2d08, 0x206b, 0x0000, 0x7010, 0x8000, 0x7012,
+	0x7018, 0xa06d, 0x711a, 0x0040, 0x49f8, 0x6902, 0x0078, 0x49f9,
+	0x711e, 0x0078, 0x49d8, 0xa18c, 0x00ff, 0xa186, 0x0017, 0x0040,
+	0x4a09, 0xa186, 0x001e, 0x0040, 0x4a09, 0xa18e, 0x001f, 0x00c0,
+	0x49e8, 0x684c, 0xd0cc, 0x0040, 0x49e8, 0x6850, 0xa084, 0x00ff,
+	0xa086, 0x0001, 0x00c0, 0x49e8, 0x2009, 0x8021, 0x0078, 0x49b8,
+	0x7084, 0x8008, 0xa092, 0x001e, 0x00c8, 0x49e8, 0x7186, 0xae90,
+	0x0003, 0xa210, 0x683c, 0x2012, 0x0078, 0x4a36, 0x7084, 0x8008,
+	0xa092, 0x000f, 0x00c8, 0x49e8, 0x7186, 0xae90, 0x0003, 0x8003,
+	0xa210, 0x683c, 0x2012, 0x8210, 0x6840, 0x2012, 0x7088, 0xa10a,
+	0x0048, 0x49cf, 0x718c, 0x7084, 0xa10a, 0x0048, 0x49cf, 0x2071,
+	0x0000, 0x7018, 0xd084, 0x00c0, 0x49cf, 0x2071, 0xa534, 0x7000,
+	0xa086, 0x0002, 0x00c0, 0x4a56, 0x1078, 0x4cd2, 0x2071, 0x0000,
+	0x701b, 0x0001, 0x2091, 0x4080, 0x0078, 0x49cf, 0x1078, 0x4cfd,
+	0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0078, 0x49cf,
+	0x007e, 0x684c, 0x007e, 0x6837, 0x0103, 0x20a9, 0x001c, 0xad80,
+	0x0011, 0x20a0, 0x2001, 0x0000, 0x40a4, 0x007f, 0xa084, 0x00ff,
+	0x684e, 0x007f, 0x684a, 0x6952, 0x007c, 0x2071, 0xa413, 0x7004,
+	0x0079, 0x4a7a, 0x4a84, 0x4a95, 0x4ca3, 0x4ca4, 0x4ccb, 0x4cd1,
+	0x4a85, 0x4c91, 0x4c32, 0x4cb4, 0x007c, 0x127e, 0x2091, 0x8000,
+	0x0068, 0x4a94, 0x2009, 0x000d, 0x7030, 0x200a, 0x2091, 0x4080,
+	0x7007, 0x0001, 0x700b, 0x0000, 0x127f, 0x2069, 0xa5be, 0x6844,
+	0xa005, 0x0050, 0x4abd, 0x00c0, 0x4abd, 0x127e, 0x2091, 0x8000,
+	0x2069, 0x0000, 0x6934, 0x2001, 0xa41f, 0x2004, 0xa10a, 0x0040,
+	0x4ab8, 0x0068, 0x4abc, 0x2069, 0x0000, 0x6818, 0xd084, 0x00c0,
+	0x4abc, 0x2009, 0x8040, 0x6922, 0x681b, 0x0001, 0x2091, 0x4080,
+	0x2069, 0xa5be, 0x6847, 0xffff, 0x127f, 0x2069, 0xa300, 0x6844,
+	0x6960, 0xa102, 0x2069, 0xa534, 0x688a, 0x6984, 0x701c, 0xa06d,
+	0x0040, 0x4acf, 0x81ff, 0x0040, 0x4b17, 0x0078, 0x4ae5, 0x81ff,
+	0x0040, 0x4be9, 0x2071, 0xa534, 0x7184, 0x7088, 0xa10a, 0x00c8,
+	0x4ae5, 0x7190, 0x2071, 0xa5be, 0x7040, 0xa005, 0x0040, 0x4ae5,
+	0x00d0, 0x4be9, 0x7142, 0x0078, 0x4be9, 0x2071, 0xa534, 0x718c,
+	0x127e, 0x2091, 0x8000, 0x7084, 0xa10a, 0x0048, 0x4c06, 0x0068,
+	0x4b9b, 0x2071, 0x0000, 0x7018, 0xd084, 0x00c0, 0x4b9b, 0x2001,
+	0xffff, 0x2071, 0xa5be, 0x7042, 0x2071, 0xa534, 0x7000, 0xa086,
+	0x0002, 0x00c0, 0x4b0d, 0x1078, 0x4cd2, 0x2071, 0x0000, 0x701b,
+	0x0001, 0x2091, 0x4080, 0x0078, 0x4b9b, 0x1078, 0x4cfd, 0x2071,
+	0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0078, 0x4b9b, 0x2071,
+	0xa534, 0x7000, 0xa005, 0x0040, 0x4bc8, 0x6934, 0xa186, 0x0103,
+	0x00c0, 0x4b9e, 0x684c, 0xd0bc, 0x00c0, 0x4bc8, 0x6948, 0x6844,
+	0xa105, 0x00c0, 0x4bbb, 0x2009, 0x8020, 0x2071, 0xa534, 0x7000,
+	0x0079, 0x4b32, 0x4bc8, 0x4b80, 0x4b58, 0x4b6a, 0x4b37, 0x137e,
+	0x147e, 0x157e, 0x2099, 0xa375, 0x20a1, 0xa585, 0x20a9, 0x0004,
+	0x53a3, 0x157f, 0x147f, 0x137f, 0x2071, 0xa57c, 0xad80, 0x000f,
+	0x700e, 0x7013, 0x0002, 0x7007, 0x0002, 0x700b, 0x0000, 0x2e10,
+	0x1078, 0x13d1, 0x2071, 0xa413, 0x7007, 0x0009, 0x0078, 0x4be9,
+	0x7084, 0x8008, 0xa092, 0x001e, 0x00c8, 0x4be9, 0xae90, 0x0003,
+	0xa210, 0x683c, 0x2012, 0x7186, 0x2071, 0xa413, 0x1078, 0x4d5b,
+	0x0078, 0x4be9, 0x7084, 0x8008, 0xa092, 0x000f, 0x00c8, 0x4be9,
+	0xae90, 0x0003, 0x8003, 0xa210, 0x683c, 0x2012, 0x8210, 0x6840,
+	0x2012, 0x7186, 0x2071, 0xa413, 0x1078, 0x4d5b, 0x0078, 0x4be9,
+	0x127e, 0x2091, 0x8000, 0x0068, 0x4b9b, 0x2071, 0x0000, 0x7018,
+	0xd084, 0x00c0, 0x4b9b, 0x7122, 0x683c, 0x7026, 0x6840, 0x702a,
+	0x701b, 0x0001, 0x2091, 0x4080, 0x127f, 0x2071, 0xa413, 0x1078,
+	0x4d5b, 0x0078, 0x4be9, 0x127f, 0x0078, 0x4be9, 0xa18c, 0x00ff,
+	0xa186, 0x0017, 0x0040, 0x4bac, 0xa186, 0x001e, 0x0040, 0x4bac,
+	0xa18e, 0x001f, 0x00c0, 0x4bc8, 0x684c, 0xd0cc, 0x0040, 0x4bc8,
+	0x6850, 0xa084, 0x00ff, 0xa086, 0x0001, 0x00c0, 0x4bc8, 0x2009,
+	0x8021, 0x0078, 0x4b2d, 0x6844, 0xa086, 0x0100, 0x00c0, 0x4bc8,
+	0x6868, 0xa005, 0x00c0, 0x4bc8, 0x2009, 0x8020, 0x0078, 0x4b2d,
+	0x2071, 0xa413, 0x1078, 0x4d6f, 0x0040, 0x4be9, 0x2071, 0xa413,
+	0x700f, 0x0001, 0x6934, 0xa184, 0x00ff, 0xa086, 0x0003, 0x00c0,
+	0x4be0, 0x810f, 0xa18c, 0x00ff, 0x8101, 0x0040, 0x4be0, 0x710e,
+	0x7007, 0x0003, 0x1078, 0x4d8f, 0x7050, 0xa086, 0x0100, 0x0040,
+	0x4ca4, 0x127e, 0x2091, 0x8000, 0x2071, 0xa413, 0x7008, 0xa086,
+	0x0001, 0x00c0, 0x4c04, 0x0068, 0x4c04, 0x2009, 0x000d, 0x7030,
+	0x200a, 0x2091, 0x4080, 0x700b, 0x0000, 0x7004, 0xa086, 0x0006,
+	0x00c0, 0x4c04, 0x7007, 0x0001, 0x127f, 0x007c, 0x2071, 0xa413,
+	0x1078, 0x4d6f, 0x0040, 0x4c2f, 0x2071, 0xa534, 0x7084, 0x700a,
+	0x20a9, 0x0020, 0x2099, 0xa535, 0x20a1, 0xa55c, 0x53a3, 0x7087,
+	0x0000, 0x2071, 0xa413, 0x2069, 0xa57c, 0x706c, 0x6826, 0x7070,
+	0x682a, 0x7074, 0x682e, 0x7078, 0x6832, 0x2d10, 0x1078, 0x13d1,
+	0x7007, 0x0008, 0x2001, 0xffff, 0x2071, 0xa5be, 0x7042, 0x127f,
+	0x0078, 0x4be9, 0x2069, 0xa57c, 0x6808, 0xa08e, 0x0000, 0x0040,
+	0x4c90, 0xa08e, 0x0200, 0x0040, 0x4c8e, 0xa08e, 0x0100, 0x00c0,
+	0x4c90, 0x127e, 0x2091, 0x8000, 0x0068, 0x4c8b, 0x2069, 0x0000,
+	0x6818, 0xd084, 0x00c0, 0x4c8b, 0x702c, 0x7130, 0x8108, 0xa102,
+	0x0048, 0x4c59, 0xa00e, 0x7034, 0x706e, 0x7038, 0x7072, 0x0078,
+	0x4c63, 0x706c, 0xa080, 0x0040, 0x706e, 0x00c8, 0x4c63, 0x7070,
+	0xa081, 0x0000, 0x7072, 0x7132, 0x6936, 0x700b, 0x0000, 0x2001,
+	0xa559, 0x2004, 0xa005, 0x00c0, 0x4c82, 0x6934, 0x2069, 0xa534,
+	0x689c, 0x699e, 0x2069, 0xa5be, 0xa102, 0x00c0, 0x4c7b, 0x6844,
+	0xa005, 0x00d0, 0x4c89, 0x2001, 0xa55a, 0x200c, 0x810d, 0x6946,
+	0x0078, 0x4c89, 0x2009, 0x8040, 0x6922, 0x681b, 0x0001, 0x2091,
+	0x4080, 0x7007, 0x0001, 0x127f, 0x0078, 0x4c90, 0x7007, 0x0005,
+	0x007c, 0x701c, 0xa06d, 0x0040, 0x4ca2, 0x1078, 0x4d6f, 0x0040,
+	0x4ca2, 0x7007, 0x0003, 0x1078, 0x4d8f, 0x7050, 0xa086, 0x0100,
+	0x0040, 0x4ca4, 0x007c, 0x007c, 0x7050, 0xa09e, 0x0100, 0x00c0,
+	0x4cad, 0x7007, 0x0004, 0x0078, 0x4ccb, 0xa086, 0x0200, 0x00c0,
+	0x4cb3, 0x7007, 0x0005, 0x007c, 0x2001, 0xa57e, 0x2004, 0xa08e,
+	0x0100, 0x00c0, 0x4cc0, 0x7007, 0x0001, 0x1078, 0x4d5b, 0x007c,
+	0xa08e, 0x0000, 0x0040, 0x4cbf, 0xa08e, 0x0200, 0x00c0, 0x4cbf,
+	0x7007, 0x0005, 0x007c, 0x1078, 0x4d25, 0x7006, 0x1078, 0x4d5b,
+	0x007c, 0x007c, 0x0e7e, 0x157e, 0x2071, 0xa534, 0x7184, 0x81ff,
+	0x0040, 0x4cfa, 0xa006, 0x7086, 0xae80, 0x0003, 0x2071, 0x0000,
+	0x21a8, 0x2014, 0x7226, 0x8000, 0x0070, 0x4cf7, 0x2014, 0x722a,
+	0x8000, 0x0070, 0x4cf7, 0x2014, 0x722e, 0x8000, 0x0070, 0x4cf7,
+	0x2014, 0x723a, 0x8000, 0x0070, 0x4cf7, 0x2014, 0x723e, 0xa180,
+	0x8030, 0x7022, 0x157f, 0x0e7f, 0x007c, 0x0e7e, 0x157e, 0x2071,
+	0xa534, 0x7184, 0x81ff, 0x0040, 0x4d22, 0xa006, 0x7086, 0xae80,
+	0x0003, 0x2071, 0x0000, 0x21a8, 0x2014, 0x7226, 0x8000, 0x2014,
+	0x722a, 0x8000, 0x0070, 0x4d1b, 0x2014, 0x723a, 0x8000, 0x2014,
+	0x723e, 0x0078, 0x4d1f, 0x2001, 0x8020, 0x0078, 0x4d21, 0x2001,
+	0x8042, 0x7022, 0x157f, 0x0e7f, 0x007c, 0x702c, 0x7130, 0x8108,
+	0xa102, 0x0048, 0x4d32, 0xa00e, 0x7034, 0x706e, 0x7038, 0x7072,
+	0x0078, 0x4d3c, 0x706c, 0xa080, 0x0040, 0x706e, 0x00c8, 0x4d3c,
+	0x7070, 0xa081, 0x0000, 0x7072, 0x7132, 0x700c, 0x8001, 0x700e,
+	0x00c0, 0x4d52, 0x127e, 0x2091, 0x8000, 0x0068, 0x4d55, 0x2001,
+	0x000d, 0x2102, 0x2091, 0x4080, 0x2001, 0x0001, 0x700b, 0x0000,
+	0x127f, 0x007c, 0x2001, 0x0007, 0x007c, 0x2001, 0x0006, 0x700b,
+	0x0001, 0x127f, 0x007c, 0x701c, 0xa06d, 0x0040, 0x4d6e, 0x127e,
+	0x2091, 0x8000, 0x7010, 0x8001, 0x7012, 0x2d04, 0x701e, 0xa005,
+	0x00c0, 0x4d6b, 0x701a, 0x127f, 0x1078, 0x139a, 0x007c, 0x2019,
+	0x000d, 0x2304, 0x230c, 0xa10e, 0x0040, 0x4d7e, 0x2304, 0x230c,
+	0xa10e, 0x0040, 0x4d7e, 0xa006, 0x0078, 0x4d8e, 0x732c, 0x8319,
+	0x7130, 0xa102, 0x00c0, 0x4d88, 0x2300, 0xa005, 0x0078, 0x4d8e,
+	0x0048, 0x4d8d, 0xa302, 0x0078, 0x4d8e, 0x8002, 0x007c, 0x2d00,
+	0x7026, 0xa080, 0x000d, 0x7056, 0x7053, 0x0000, 0x127e, 0x2091,
+	0x8000, 0x2009, 0xa5d0, 0x2104, 0xc08d, 0x200a, 0x127f, 0x1078,
+	0x13eb, 0x007c, 0x2071, 0xa3e1, 0x7003, 0x0000, 0x7007, 0x0000,
+	0x700f, 0x0000, 0x702b, 0x0001, 0x704f, 0x0000, 0x7053, 0x0001,
+	0x705f, 0x0020, 0x7063, 0x0040, 0x7083, 0x0000, 0x708b, 0x0000,
+	0x708f, 0x0001, 0x70bf, 0x0000, 0x007c, 0x0e7e, 0x2071, 0xa3e1,
+	0x6848, 0xa005, 0x00c0, 0x4dcb, 0x7028, 0xc085, 0x702a, 0xa085,
+	0x0001, 0x0078, 0x4df0, 0x6a50, 0x7236, 0x6b54, 0x733a, 0x6858,
+	0x703e, 0x707a, 0x685c, 0x7042, 0x707e, 0x6848, 0x702e, 0x6840,
+	0x7032, 0x2009, 0x000c, 0x200a, 0x8007, 0x8006, 0x8006, 0xa08c,
+	0x003f, 0xa084, 0xffc0, 0xa210, 0x2100, 0xa319, 0x7272, 0x7376,
+	0x7028, 0xc084, 0x702a, 0x7007, 0x0001, 0x700f, 0x0000, 0xa006,
+	0x0e7f, 0x007c, 0x2b78, 0x2071, 0xa3e1, 0x7004, 0x1079, 0x4e50,
+	0x700c, 0x0079, 0x4dfb, 0x4e00, 0x4df5, 0x4df5, 0x4df5, 0x4df5,
+	0x007c, 0x700c, 0x0079, 0x4e04, 0x4e09, 0x4e4e, 0x4e4e, 0x4e4f,
+	0x4e4f, 0x7830, 0x7930, 0xa106, 0x0040, 0x4e13, 0x7830, 0x7930,
+	0xa106, 0x00c0, 0x4e39, 0x7030, 0xa10a, 0x0040, 0x4e39, 0x00c8,
+	0x4e1b, 0x712c, 0xa10a, 0xa18a, 0x0002, 0x00c8, 0x4e3a, 0x1078,
+	0x1366, 0x0040, 0x4e39, 0x2d00, 0x705a, 0x7063, 0x0040, 0x2001,
+	0x0003, 0x7057, 0x0000, 0x127e, 0x007e, 0x2091, 0x8000, 0x2009,
+	0xa5d0, 0x2104, 0xc085, 0x200a, 0x007f, 0x700e, 0x127f, 0x1078,
+	0x13eb, 0x007c, 0x1078, 0x1366, 0x0040, 0x4e39, 0x2d00, 0x705a,
+	0x1078, 0x1366, 0x00c0, 0x4e46, 0x0078, 0x4e25, 0x2d00, 0x7086,
+	0x7063, 0x0080, 0x2001, 0x0004, 0x0078, 0x4e29, 0x007c, 0x007c,
+	0x4e61, 0x4e62, 0x4e99, 0x4e9a, 0x4e4e, 0x4ed0, 0x4ed5, 0x4f0c,
+	0x4f0d, 0x4f28, 0x4f29, 0x4f2a, 0x4f2b, 0x4f2c, 0x4f2d, 0x4fad,
+	0x4fd7, 0x007c, 0x700c, 0x0079, 0x4e65, 0x4e6a, 0x4e6d, 0x4e7d,
+	0x4e98, 0x4e98, 0x1078, 0x4e01, 0x007c, 0x127e, 0x8001, 0x700e,
+	0x7058, 0x007e, 0x1078, 0x5348, 0x0040, 0x4e7a, 0x2091, 0x8000,
+	0x1078, 0x4e01, 0x0d7f, 0x0078, 0x4e86, 0x127e, 0x8001, 0x700e,
+	0x1078, 0x5348, 0x7058, 0x2068, 0x7084, 0x705a, 0x6803, 0x0000,
+	0x6807, 0x0000, 0x6834, 0xa084, 0x00ff, 0xa08a, 0x0020, 0x00c8,
+	0x4e95, 0x1079, 0x4eb0, 0x127f, 0x007c, 0x127f, 0x1078, 0x4f2e,
+	0x007c, 0x007c, 0x007c, 0x0e7e, 0x2071, 0xa3e1, 0x700c, 0x0079,
+	0x4ea1, 0x4ea6, 0x4ea6, 0x4ea6, 0x4ea8, 0x4eac, 0x0e7f, 0x007c,
+	0x700f, 0x0001, 0x0078, 0x4eae, 0x700f, 0x0002, 0x0e7f, 0x007c,
+	0x4f2e, 0x4f2e, 0x4f4a, 0x4f2e, 0x5080, 0x4f2e, 0x4f2e, 0x4f2e,
+	0x4f2e, 0x4f2e, 0x4f4a, 0x50ca, 0x5117, 0x5170, 0x5186, 0x4f2e,
+	0x4f2e, 0x4f66, 0x4f4a, 0x4f2e, 0x4f2e, 0x4f87, 0x5245, 0x5263,
+	0x4f2e, 0x4f66, 0x4f2e, 0x4f2e, 0x4f2e, 0x4f2e, 0x4f7c, 0x5263,
+	0x7020, 0x2068, 0x1078, 0x139a, 0x007c, 0x700c, 0x0079, 0x4ed8,
+	0x4edd, 0x4ee0, 0x4ef0, 0x4f0b, 0x4f0b, 0x1078, 0x4e01, 0x007c,
+	0x127e, 0x8001, 0x700e, 0x7058, 0x007e, 0x1078, 0x5348, 0x0040,
+	0x4eed, 0x2091, 0x8000, 0x1078, 0x4e01, 0x0d7f, 0x0078, 0x4ef9,
+	0x127e, 0x8001, 0x700e, 0x1078, 0x5348, 0x7058, 0x2068, 0x7084,
+	0x705a, 0x6803, 0x0000, 0x6807, 0x0000, 0x6834, 0xa084, 0x00ff,
+	0xa08a, 0x001a, 0x00c8, 0x4f08, 0x1079, 0x4f0e, 0x127f, 0x007c,
+	0x127f, 0x1078, 0x4f2e, 0x007c, 0x007c, 0x007c, 0x4f2e, 0x4f4a,
+	0x506a, 0x4f2e, 0x4f4a, 0x4f2e, 0x4f4a, 0x4f4a, 0x4f2e, 0x4f4a,
+	0x506a, 0x4f4a, 0x4f4a, 0x4f4a, 0x4f4a, 0x4f4a, 0x4f2e, 0x4f4a,
+	0x506a, 0x4f2e, 0x4f2e, 0x4f4a, 0x4f2e, 0x4f2e, 0x4f2e, 0x4f4a,
+	0x007c, 0x007c, 0x007c, 0x007c, 0x007c, 0x007c, 0x7007, 0x0001,
+	0x6838, 0xa084, 0x00ff, 0xc0d5, 0x683a, 0x127e, 0x2091, 0x8000,
+	0x1078, 0x4982, 0x127f, 0x007c, 0x7007, 0x0001, 0x6838, 0xa084,
+	0x00ff, 0xc0e5, 0x683a, 0x127e, 0x2091, 0x8000, 0x1078, 0x4982,
+	0x127f, 0x007c, 0x7007, 0x0001, 0x6838, 0xa084, 0x00ff, 0xc0ed,
+	0x683a, 0x127e, 0x2091, 0x8000, 0x1078, 0x4982, 0x127f, 0x007c,
+	0x7007, 0x0001, 0x6838, 0xa084, 0x00ff, 0xc0dd, 0x683a, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x4982, 0x127f, 0x007c, 0x6834, 0x8007,
+	0xa084, 0x00ff, 0x0040, 0x4f3c, 0x8001, 0x00c0, 0x4f73, 0x7007,
+	0x0001, 0x0078, 0x5049, 0x7007, 0x0006, 0x7012, 0x2d00, 0x7016,
+	0x701a, 0x704b, 0x5049, 0x007c, 0x684c, 0xa084, 0x00c0, 0xa086,
+	0x00c0, 0x00c0, 0x4f87, 0x7007, 0x0001, 0x0078, 0x5280, 0x2d00,
+	0x7016, 0x701a, 0x20a9, 0x0004, 0xa080, 0x0024, 0x2098, 0x20a1,
+	0xa40c, 0x53a3, 0x6858, 0x7012, 0xa082, 0x0401, 0x00c8, 0x4f58,
+	0x6884, 0xa08a, 0x0002, 0x00c8, 0x4f58, 0x82ff, 0x00c0, 0x4fa9,
+	0x6888, 0x698c, 0xa105, 0x0040, 0x4fa9, 0x2001, 0x5019, 0x0078,
+	0x4fac, 0xa280, 0x500f, 0x2004, 0x70c6, 0x7010, 0xa015, 0x0040,
+	0x4ff7, 0x1078, 0x1366, 0x00c0, 0x4fb8, 0x7007, 0x000f, 0x007c,
+	0x2d00, 0x7022, 0x70c4, 0x2060, 0x6000, 0x6836, 0x6004, 0xad00,
+	0x7096, 0x6008, 0xa20a, 0x00c8, 0x4fc7, 0xa00e, 0x2200, 0x7112,
+	0x620c, 0x8003, 0x800b, 0xa296, 0x0004, 0x0040, 0x4fd0, 0xa108,
+	0x719a, 0x810b, 0x719e, 0xae90, 0x0022, 0x1078, 0x13d1, 0x7090,
+	0xa08e, 0x0100, 0x0040, 0x4feb, 0xa086, 0x0200, 0x0040, 0x4fe3,
+	0x7007, 0x0010, 0x007c, 0x7020, 0x2068, 0x1078, 0x139a, 0x7014,
+	0x2068, 0x0078, 0x4f58, 0x7020, 0x2068, 0x7018, 0x6802, 0x6807,
+	0x0000, 0x2d08, 0x2068, 0x6906, 0x711a, 0x0078, 0x4fad, 0x7014,
+	0x2068, 0x7007, 0x0001, 0x6884, 0xa005, 0x00c0, 0x5006, 0x6888,
+	0x698c, 0xa105, 0x0040, 0x5006, 0x1078, 0x501d, 0x6834, 0xa084,
+	0x00ff, 0xa086, 0x001e, 0x0040, 0x5280, 0x0078, 0x5049, 0x5011,
+	0x5015, 0x0002, 0x0011, 0x0007, 0x0004, 0x000a, 0x000f, 0x0005,
+	0x0006, 0x000a, 0x0011, 0x0005, 0x0004, 0x0f7e, 0x0e7e, 0x0c7e,
+	0x077e, 0x067e, 0x6f88, 0x6e8c, 0x6804, 0x2060, 0xacf0, 0x0021,
+	0xacf8, 0x0027, 0x2009, 0x0005, 0x700c, 0x7816, 0x7008, 0x7812,
+	0x7004, 0x7806, 0x7000, 0x7802, 0x7e0e, 0x7f0a, 0x8109, 0x0040,
+	0x503f, 0xaef2, 0x0004, 0xaffa, 0x0006, 0x0078, 0x502c, 0x6004,
+	0xa065, 0x00c0, 0x5026, 0x067f, 0x077f, 0x0c7f, 0x0e7f, 0x0f7f,
+	0x007c, 0x2009, 0xa32e, 0x210c, 0x81ff, 0x00c0, 0x5064, 0x6838,
+	0xa084, 0x00ff, 0x683a, 0x1078, 0x4290, 0x00c0, 0x5058, 0x007c,
+	0x1078, 0x4a60, 0x127e, 0x2091, 0x8000, 0x1078, 0x8cb8, 0x1078,
+	0x4982, 0x127f, 0x0078, 0x5057, 0x2001, 0x0028, 0x2009, 0x0000,
+	0x0078, 0x5058, 0x7018, 0x6802, 0x2d08, 0x2068, 0x6906, 0x711a,
+	0x7010, 0x8001, 0x7012, 0x0040, 0x5079, 0x7007, 0x0006, 0x0078,
+	0x507f, 0x7014, 0x2068, 0x7007, 0x0001, 0x7048, 0x107a, 0x007c,
+	0x7007, 0x0001, 0x6944, 0x810f, 0xa18c, 0x00ff, 0x6848, 0xa084,
+	0x00ff, 0x20a9, 0x0001, 0xa096, 0x0001, 0x0040, 0x50a9, 0x2009,
+	0x0000, 0x20a9, 0x00ff, 0xa096, 0x0002, 0x0040, 0x50a9, 0xa005,
+	0x00c0, 0x50bc, 0x6944, 0x810f, 0xa18c, 0x00ff, 0x1078, 0x4501,
+	0x00c0, 0x50bc, 0x067e, 0x6e50, 0x1078, 0x45e7, 0x067f, 0x0078,
+	0x50bc, 0x047e, 0x2011, 0xa30c, 0x2224, 0xc484, 0xc48c, 0x2412,
+	0x047f, 0x0c7e, 0x1078, 0x4501, 0x00c0, 0x50b8, 0x1078, 0x4782,
+	0x8108, 0x00f0, 0x50b2, 0x0c7f, 0x684c, 0xd084, 0x00c0, 0x50c3,
+	0x1078, 0x139a, 0x007c, 0x127e, 0x2091, 0x8000, 0x1078, 0x4982,
+	0x127f, 0x007c, 0x127e, 0x2091, 0x8000, 0x7007, 0x0001, 0x2001,
+	0xa352, 0x2004, 0xd0a4, 0x0040, 0x510e, 0x2061, 0xa62d, 0x6100,
+	0xd184, 0x0040, 0x50ee, 0x6858, 0xa084, 0x00ff, 0x00c0, 0x5111,
+	0x6000, 0xd084, 0x0040, 0x510e, 0x6004, 0xa005, 0x00c0, 0x5114,
+	0x6003, 0x0000, 0x600b, 0x0000, 0x0078, 0x510b, 0x2011, 0x0001,
+	0x6860, 0xa005, 0x00c0, 0x50f6, 0x2001, 0x001e, 0x8000, 0x6016,
+	0x6858, 0xa084, 0x00ff, 0x0040, 0x510e, 0x6006, 0x6858, 0x8007,
+	0xa084, 0x00ff, 0x0040, 0x510e, 0x600a, 0x6858, 0x8000, 0x00c0,
+	0x510a, 0xc28d, 0x6202, 0x127f, 0x0078, 0x5337, 0x127f, 0x0078,
+	0x532f, 0x127f, 0x0078, 0x5327, 0x127f, 0x0078, 0x532b, 0x127e,
+	0x2091, 0x8000, 0x7007, 0x0001, 0x2001, 0xa352, 0x2004, 0xd0a4,
+	0x0040, 0x516d, 0x2061, 0xa62d, 0x6000, 0xd084, 0x0040, 0x516d,
+	0x6204, 0x6308, 0xd08c, 0x00c0, 0x515f, 0x6c48, 0xa484, 0x0003,
+	0x0040, 0x5145, 0x6958, 0xa18c, 0x00ff, 0x8001, 0x00c0, 0x513e,
+	0x2100, 0xa210, 0x0048, 0x516a, 0x0078, 0x5145, 0x8001, 0x00c0,
+	0x516a, 0x2100, 0xa212, 0x0048, 0x516a, 0xa484, 0x000c, 0x0040,
+	0x515f, 0x6958, 0x810f, 0xa18c, 0x00ff, 0xa082, 0x0004, 0x00c0,
+	0x5157, 0x2100, 0xa318, 0x0048, 0x516a, 0x0078, 0x515f, 0xa082,
+	0x0004, 0x00c0, 0x516a, 0x2100, 0xa31a, 0x0048, 0x516a, 0x6860,
+	0xa005, 0x0040, 0x5165, 0x8000, 0x6016, 0x6206, 0x630a, 0x127f,
+	0x0078, 0x5337, 0x127f, 0x0078, 0x5333, 0x127f, 0x0078, 0x532f,
+	0x127e, 0x2091, 0x8000, 0x7007, 0x0001, 0x2061, 0xa62d, 0x6300,
+	0xd38c, 0x00c0, 0x5180, 0x6308, 0x8318, 0x0048, 0x5183, 0x630a,
+	0x127f, 0x0078, 0x5345, 0x127f, 0x0078, 0x5333, 0x127e, 0x0c7e,
+	0x2091, 0x8000, 0x7007, 0x0001, 0x684c, 0xd0ac, 0x0040, 0x519a,
+	0x0c7e, 0x2061, 0xa62d, 0x6000, 0xa084, 0xfcff, 0x6002, 0x0c7f,
+	0x0078, 0x51c9, 0x6858, 0xa005, 0x0040, 0x51e0, 0x685c, 0xa065,
+	0x0040, 0x51dc, 0x2001, 0xa32e, 0x2004, 0xa005, 0x0040, 0x51ac,
+	0x1078, 0x8c01, 0x0078, 0x51ba, 0x6013, 0x0400, 0x6037, 0x0000,
+	0x694c, 0xd1a4, 0x0040, 0x51b6, 0x6950, 0x6136, 0x2009, 0x0041,
+	0x1078, 0x756c, 0x6958, 0xa18c, 0xff00, 0xa186, 0x2000, 0x00c0,
+	0x51c9, 0x027e, 0x2009, 0x0000, 0x2011, 0xfdff, 0x1078, 0x5a6d,
+	0x027f, 0x684c, 0xd0c4, 0x0040, 0x51d8, 0x2061, 0xa62d, 0x6000,
+	0xd08c, 0x00c0, 0x51d8, 0x6008, 0x8000, 0x0048, 0x51dc, 0x600a,
+	0x0c7f, 0x127f, 0x0078, 0x5337, 0x0c7f, 0x127f, 0x0078, 0x532f,
+	0x6954, 0xa186, 0x0045, 0x0040, 0x5213, 0xa186, 0x002a, 0x00c0,
+	0x51f0, 0x2001, 0xa30c, 0x200c, 0xc194, 0x2102, 0x0078, 0x51c9,
+	0xa186, 0x0020, 0x0040, 0x5209, 0xa186, 0x0029, 0x0040, 0x51fc,
+	0xa186, 0x002d, 0x00c0, 0x51dc, 0x6944, 0xa18c, 0xff00, 0x810f,
+	0x1078, 0x4501, 0x00c0, 0x51c9, 0x6000, 0xc0e4, 0x6002, 0x0078,
+	0x51c9, 0x685c, 0xa065, 0x0040, 0x51dc, 0x2001, 0xa5a1, 0x2004,
+	0x6016, 0x0078, 0x51c9, 0x685c, 0xa065, 0x0040, 0x51dc, 0x0e7e,
+	0x6860, 0xa075, 0x2001, 0xa32e, 0x2004, 0xa005, 0x0040, 0x522b,
+	0x1078, 0x8c01, 0x8eff, 0x0040, 0x5228, 0x2e60, 0x1078, 0x8c01,
+	0x0e7f, 0x0078, 0x51c9, 0x6024, 0xc0dc, 0xc0d5, 0x6026, 0x2e60,
+	0x6007, 0x003a, 0x6870, 0xa005, 0x0040, 0x523c, 0x6007, 0x003b,
+	0x6874, 0x602a, 0x6878, 0x6012, 0x6003, 0x0001, 0x1078, 0x5bf8,
+	0x1078, 0x6109, 0x0e7f, 0x0078, 0x51c9, 0x2061, 0xa62d, 0x6000,
+	0xd084, 0x0040, 0x525f, 0xd08c, 0x00c0, 0x5345, 0x2091, 0x8000,
+	0x6204, 0x8210, 0x0048, 0x5259, 0x6206, 0x2091, 0x8001, 0x0078,
+	0x5345, 0x2091, 0x8001, 0x6853, 0x0016, 0x0078, 0x533e, 0x6853,
+	0x0007, 0x0078, 0x533e, 0x6834, 0x8007, 0xa084, 0x00ff, 0x00c0,
+	0x526d, 0x1078, 0x4f3c, 0x0078, 0x527f, 0x2030, 0x8001, 0x00c0,
+	0x5277, 0x7007, 0x0001, 0x1078, 0x5280, 0x0078, 0x527f, 0x7007,
+	0x0006, 0x7012, 0x2d00, 0x7016, 0x701a, 0x704b, 0x5280, 0x007c,
+	0x0e7e, 0x127e, 0x2091, 0x8000, 0x2009, 0xa32e, 0x210c, 0x81ff,
+	0x00c0, 0x530b, 0x2009, 0xa30c, 0x210c, 0xd194, 0x00c0, 0x5315,
+	0x6848, 0x2070, 0xae82, 0xaa00, 0x0048, 0x52fb, 0x2001, 0xa315,
+	0x2004, 0xae02, 0x00c8, 0x52fb, 0x2061, 0xa62d, 0x6100, 0xa184,
+	0x0301, 0xa086, 0x0001, 0x00c0, 0x52de, 0x711c, 0xa186, 0x0006,
+	0x00c0, 0x52e6, 0x7018, 0xa005, 0x0040, 0x530b, 0x2004, 0xd0e4,
+	0x00c0, 0x530f, 0x7024, 0xd0dc, 0x00c0, 0x5319, 0x6853, 0x0000,
+	0x6803, 0x0000, 0x2d08, 0x7010, 0xa005, 0x00c0, 0x52ca, 0x7112,
+	0x684c, 0xd0f4, 0x00c0, 0x531d, 0x2e60, 0x1078, 0x59b6, 0x127f,
+	0x0e7f, 0x007c, 0x2068, 0x6800, 0xa005, 0x00c0, 0x52ca, 0x6902,
+	0x2168, 0x684c, 0xd0f4, 0x00c0, 0x531d, 0x127f, 0x0e7f, 0x007c,
+	0x127f, 0x0e7f, 0x6853, 0x0006, 0x0078, 0x533e, 0xd184, 0x0040,
+	0x52d8, 0xd1c4, 0x00c0, 0x52ff, 0x0078, 0x5303, 0x6944, 0xa18c,
+	0xff00, 0x810f, 0x1078, 0x4501, 0x00c0, 0x530f, 0x6000, 0xd0e4,
+	0x00c0, 0x530f, 0x711c, 0xa186, 0x0007, 0x00c0, 0x52fb, 0x6853,
+	0x0002, 0x0078, 0x5311, 0x6853, 0x0008, 0x0078, 0x5311, 0x6853,
+	0x000e, 0x0078, 0x5311, 0x6853, 0x0017, 0x0078, 0x5311, 0x6853,
+	0x0035, 0x0078, 0x5311, 0x6853, 0x0028, 0x0078, 0x5311, 0x6853,
+	0x0029, 0x127f, 0x0e7f, 0x0078, 0x533e, 0x6853, 0x002a, 0x0078,
+	0x5311, 0x6853, 0x0045, 0x0078, 0x5311, 0x2e60, 0x2019, 0x0002,
+	0x6017, 0x0014, 0x1078, 0x9a6a, 0x127f, 0x0e7f, 0x007c, 0x2009,
+	0x003e, 0x0078, 0x5339, 0x2009, 0x0004, 0x0078, 0x5339, 0x2009,
+	0x0006, 0x0078, 0x5339, 0x2009, 0x0016, 0x0078, 0x5339, 0x2009,
+	0x0001, 0x6854, 0xa084, 0xff00, 0xa105, 0x6856, 0x2091, 0x8000,
+	0x1078, 0x4982, 0x2091, 0x8001, 0x007c, 0x1078, 0x139a, 0x007c,
+	0x702c, 0x7130, 0x8108, 0xa102, 0x0048, 0x5355, 0xa00e, 0x7034,
+	0x7072, 0x7038, 0x7076, 0x0078, 0x5361, 0x7070, 0xa080, 0x0040,
+	0x7072, 0x00c8, 0x5361, 0x7074, 0xa081, 0x0000, 0x7076, 0xa085,
+	0x0001, 0x7932, 0x7132, 0x007c, 0x0d7e, 0x1078, 0x59ad, 0x0d7f,
+	0x007c, 0x0d7e, 0x2011, 0x0004, 0x2204, 0xa085, 0x8002, 0x2012,
+	0x0d7f, 0x007c, 0x20e1, 0x0002, 0x3d08, 0x20e1, 0x2000, 0x3d00,
+	0xa084, 0x7000, 0x0040, 0x5380, 0xa086, 0x1000, 0x00c0, 0x53ac,
+	0x20e1, 0x0000, 0x3d00, 0xa094, 0xff00, 0x8217, 0xa084, 0xf000,
+	0xa086, 0x3000, 0x00c0, 0x5390, 0x1078, 0x5570, 0x0078, 0x53a7,
+	0x20e1, 0x0004, 0x3d60, 0xd1bc, 0x00c0, 0x5397, 0x3e60, 0xac84,
+	0x000f, 0x00c0, 0x53ac, 0xac82, 0xaa00, 0x0048, 0x53ac, 0x6854,
+	0xac02, 0x00c8, 0x53ac, 0x2009, 0x0047, 0x1078, 0x756c, 0x7a1c,
+	0xd284, 0x00c0, 0x5372, 0x007c, 0xa016, 0x1078, 0x15ec, 0x0078,
+	0x53a7, 0x0078, 0x53ac, 0x781c, 0xd08c, 0x0040, 0x53db, 0x157e,
+	0x137e, 0x147e, 0x20e1, 0x3000, 0x3d20, 0x3e28, 0xa584, 0x0076,
+	0x00c0, 0x53f1, 0xa484, 0x7000, 0xa086, 0x1000, 0x00c0, 0x53e0,
+	0x1078, 0x540c, 0x0040, 0x53f1, 0x20e1, 0x3000, 0x7828, 0x7828,
+	0x1078, 0x542a, 0x147f, 0x137f, 0x157f, 0x2009, 0xa5b3, 0x2104,
+	0xa005, 0x00c0, 0x53dc, 0x007c, 0x1078, 0x6109, 0x0078, 0x53db,
+	0xa484, 0x7000, 0x00c0, 0x53f1, 0x1078, 0x540c, 0x0040, 0x5403,
+	0x7000, 0xa084, 0xff00, 0xa086, 0x8100, 0x0040, 0x53cc, 0x0078,
+	0x5403, 0x1078, 0xa1ee, 0xd5a4, 0x0040, 0x53ff, 0x1078, 0x1af7,
+	0x20e1, 0x9010, 0x2001, 0x0138, 0x2202, 0x0078, 0x5407, 0x1078,
+	0x540c, 0x687f, 0x0000, 0x20e1, 0x3000, 0x7828, 0x7828, 0x147f,
+	0x137f, 0x157f, 0x0078, 0x53db, 0xa484, 0x01ff, 0x687e, 0xa005,
+	0x0040, 0x541e, 0xa080, 0x001f, 0xa084, 0x03f8, 0x80ac, 0x20e1,
+	0x1000, 0x2ea0, 0x2099, 0x020a, 0x53a5, 0x007c, 0x20a9, 0x000c,
+	0x20e1, 0x1000, 0x2ea0, 0x2099, 0x020a, 0x53a5, 0xa085, 0x0001,
+	0x0078, 0x541d, 0x7000, 0xa084, 0xff00, 0xa08c, 0xf000, 0x8007,
+	0xa196, 0x0000, 0x00c0, 0x5437, 0x0078, 0x567c, 0x007c, 0xa196,
+	0x2000, 0x00c0, 0x5448, 0x6900, 0xa18e, 0x0001, 0x00c0, 0x5444,
+	0x1078, 0x3a43, 0x0078, 0x5436, 0x1078, 0x5450, 0x0078, 0x5436,
+	0xa196, 0x8000, 0x00c0, 0x5436, 0x1078, 0x570c, 0x0078, 0x5436,
+	0x0c7e, 0x7110, 0xa18c, 0xff00, 0x810f, 0xa196, 0x0001, 0x0040,
+	0x545d, 0xa196, 0x0023, 0x00c0, 0x5568, 0xa08e, 0x0023, 0x00c0,
+	0x5492, 0x1078, 0x57b2, 0x0040, 0x5568, 0x7124, 0x610a, 0x7030,
+	0xa08e, 0x0200, 0x00c0, 0x5476, 0x7034, 0xa005, 0x00c0, 0x5568,
+	0x2009, 0x0015, 0x1078, 0x756c, 0x0078, 0x5568, 0xa08e, 0x0214,
+	0x0040, 0x547e, 0xa08e, 0x0210, 0x00c0, 0x5484, 0x2009, 0x0015,
+	0x1078, 0x756c, 0x0078, 0x5568, 0xa08e, 0x0100, 0x00c0, 0x5568,
+	0x7034, 0xa005, 0x00c0, 0x5568, 0x2009, 0x0016, 0x1078, 0x756c,
+	0x0078, 0x5568, 0xa08e, 0x0022, 0x00c0, 0x5568, 0x7030, 0xa08e,
+	0x0300, 0x00c0, 0x54a3, 0x7034, 0xa005, 0x00c0, 0x5568, 0x2009,
+	0x0017, 0x0078, 0x5534, 0xa08e, 0x0500, 0x00c0, 0x54af, 0x7034,
+	0xa005, 0x00c0, 0x5568, 0x2009, 0x0018, 0x0078, 0x5534, 0xa08e,
+	0x2010, 0x00c0, 0x54b7, 0x2009, 0x0019, 0x0078, 0x5534, 0xa08e,
+	0x2110, 0x00c0, 0x54bf, 0x2009, 0x001a, 0x0078, 0x5534, 0xa08e,
+	0x5200, 0x00c0, 0x54cb, 0x7034, 0xa005, 0x00c0, 0x5568, 0x2009,
+	0x001b, 0x0078, 0x5534, 0xa08e, 0x5000, 0x00c0, 0x54d7, 0x7034,
+	0xa005, 0x00c0, 0x5568, 0x2009, 0x001c, 0x0078, 0x5534, 0xa08e,
+	0x1300, 0x00c0, 0x54df, 0x2009, 0x0034, 0x0078, 0x5534, 0xa08e,
+	0x1200, 0x00c0, 0x54eb, 0x7034, 0xa005, 0x00c0, 0x5568, 0x2009,
+	0x0024, 0x0078, 0x5534, 0xa08c, 0xff00, 0xa18e, 0x2400, 0x00c0,
+	0x54f5, 0x2009, 0x002d, 0x0078, 0x5534, 0xa08c, 0xff00, 0xa18e,
+	0x5300, 0x00c0, 0x54ff, 0x2009, 0x002a, 0x0078, 0x5534, 0xa08e,
+	0x0f00, 0x00c0, 0x5507, 0x2009, 0x0020, 0x0078, 0x5534, 0xa08e,
+	0x5300, 0x00c0, 0x550d, 0x0078, 0x552a, 0xa08e, 0x6104, 0x00c0,
+	0x552a, 0x2011, 0xa88d, 0x8208, 0x2204, 0xa082, 0x0004, 0x20a8,
+	0x95ac, 0x95ac, 0x2011, 0x8015, 0x211c, 0x8108, 0x047e, 0x2124,
+	0x1078, 0x3579, 0x047f, 0x8108, 0x00f0, 0x551a, 0x2009, 0x0023,
+	0x0078, 0x5534, 0xa08e, 0x6000, 0x00c0, 0x5532, 0x2009, 0x003f,
+	0x0078, 0x5534, 0x2009, 0x001d, 0x017e, 0x2011, 0xa883, 0x2204,
+	0x8211, 0x220c, 0x1078, 0x24e3, 0x00c0, 0x556a, 0x1078, 0x4499,
+	0x00c0, 0x556a, 0x6612, 0x6516, 0x86ff, 0x0040, 0x555a, 0x017f,
+	0x017e, 0xa186, 0x0017, 0x00c0, 0x555a, 0x6868, 0xa606, 0x00c0,
+	0x555a, 0x686c, 0xa506, 0xa084, 0xff00, 0x00c0, 0x555a, 0x6000,
+	0xc0f5, 0x6002, 0x0c7e, 0x1078, 0x74d7, 0x0040, 0x556d, 0x017f,
+	0x611a, 0x601f, 0x0004, 0x7120, 0x610a, 0x017f, 0x1078, 0x756c,
+	0x0c7f, 0x007c, 0x017f, 0x0078, 0x5568, 0x0c7f, 0x0078, 0x556a,
+	0x0c7e, 0x1078, 0x55d4, 0x00c0, 0x55d2, 0xa184, 0xff00, 0x8007,
+	0xa086, 0x0008, 0x00c0, 0x55d2, 0xa28e, 0x0033, 0x00c0, 0x55a3,
+	0x1078, 0x57b2, 0x0040, 0x55d2, 0x7124, 0x610a, 0x7030, 0xa08e,
+	0x0200, 0x00c0, 0x5595, 0x7034, 0xa005, 0x00c0, 0x55d2, 0x2009,
+	0x0015, 0x1078, 0x756c, 0x0078, 0x55d2, 0xa08e, 0x0100, 0x00c0,
+	0x55d2, 0x7034, 0xa005, 0x00c0, 0x55d2, 0x2009, 0x0016, 0x1078,
+	0x756c, 0x0078, 0x55d2, 0xa28e, 0x0032, 0x00c0, 0x55d2, 0x7030,
+	0xa08e, 0x1400, 0x00c0, 0x55d2, 0x2009, 0x0038, 0x017e, 0x2011,
+	0xa883, 0x2204, 0x8211, 0x220c, 0x1078, 0x24e3, 0x00c0, 0x55d1,
+	0x1078, 0x4499, 0x00c0, 0x55d1, 0x6612, 0x6516, 0x0c7e, 0x1078,
+	0x74d7, 0x0040, 0x55d0, 0x017f, 0x611a, 0x601f, 0x0004, 0x7120,
+	0x610a, 0x017f, 0x1078, 0x756c, 0x1078, 0x6109, 0x0078, 0x55d2,
+	0x0c7f, 0x017f, 0x0c7f, 0x007c, 0x0f7e, 0x0d7e, 0x027e, 0x017e,
+	0x137e, 0x147e, 0x157e, 0x3c00, 0x007e, 0x2079, 0x0030, 0x2069,
+	0x0200, 0x1078, 0x1c25, 0x00c0, 0x5615, 0x1078, 0x1b15, 0x0040,
+	0x561f, 0x7908, 0xa18c, 0x1fff, 0xa182, 0x0011, 0x00c8, 0x561f,
+	0x20a9, 0x000c, 0x20e1, 0x0000, 0x2ea0, 0x2099, 0x020a, 0x53a5,
+	0x20e1, 0x2000, 0x2001, 0x020a, 0x2004, 0x7a0c, 0x7808, 0xa080,
+	0x0007, 0xa084, 0x1ff8, 0xa08a, 0x0140, 0x10c8, 0x1328, 0x80ac,
+	0x20e1, 0x6000, 0x2099, 0x020a, 0x53a5, 0x20e1, 0x7000, 0x6828,
+	0x6828, 0x7803, 0x0004, 0xa294, 0x0070, 0x007f, 0x20e0, 0x157f,
+	0x147f, 0x137f, 0x017f, 0x027f, 0x0d7f, 0x0f7f, 0x007c, 0xa085,
+	0x0001, 0x0078, 0x5615, 0x047e, 0x0e7e, 0x0d7e, 0x2028, 0x2130,
+	0xa696, 0x00ff, 0x00c0, 0x5644, 0xa596, 0xfffd, 0x00c0, 0x5634,
+	0x2009, 0x007f, 0x0078, 0x5677, 0xa596, 0xfffe, 0x00c0, 0x563c,
+	0x2009, 0x007e, 0x0078, 0x5677, 0xa596, 0xfffc, 0x00c0, 0x5644,
+	0x2009, 0x0080, 0x0078, 0x5677, 0x2011, 0x0000, 0x2021, 0x0081,
+	0x20a9, 0x007e, 0x2071, 0xa4b5, 0x2e1c, 0x83ff, 0x00c0, 0x5656,
+	0x82ff, 0x00c0, 0x566b, 0x2410, 0x0078, 0x566b, 0x2368, 0x6f10,
+	0x007e, 0x2100, 0xa706, 0x007f, 0x6b14, 0x00c0, 0x5665, 0xa346,
+	0x00c0, 0x5665, 0x2408, 0x0078, 0x5677, 0x87ff, 0x00c0, 0x566b,
+	0x83ff, 0x0040, 0x5650, 0x8420, 0x8e70, 0x00f0, 0x564c, 0x82ff,
+	0x00c0, 0x5676, 0xa085, 0x0001, 0x0078, 0x5678, 0x2208, 0xa006,
+	0x0d7f, 0x0e7f, 0x047f, 0x007c, 0xa084, 0x0007, 0x0079, 0x5681,
+	0x007c, 0x5689, 0x5689, 0x5689, 0x57c8, 0x5689, 0x568a, 0x56a3,
+	0x56f3, 0x007c, 0x7110, 0xd1bc, 0x0040, 0x56a2, 0x7120, 0x2160,
+	0xac8c, 0x000f, 0x00c0, 0x56a2, 0xac8a, 0xaa00, 0x0048, 0x56a2,
+	0x6854, 0xac02, 0x00c8, 0x56a2, 0x7124, 0x610a, 0x2009, 0x0046,
+	0x1078, 0x756c, 0x007c, 0x0c7e, 0x7110, 0xd1bc, 0x00c0, 0x56f1,
+	0x2011, 0xa883, 0x2204, 0x8211, 0x220c, 0x1078, 0x24e3, 0x00c0,
+	0x56f1, 0x1078, 0x4499, 0x00c0, 0x56f1, 0x6612, 0x6516, 0x6000,
+	0xd0ec, 0x00c0, 0x56f1, 0x6204, 0xa294, 0xff00, 0x8217, 0xa286,
+	0x0006, 0x00c0, 0x56d6, 0x0c7e, 0x1078, 0x74d7, 0x017f, 0x0040,
+	0x56f1, 0x611a, 0x601f, 0x0006, 0x7120, 0x610a, 0x7130, 0x6122,
+	0x2009, 0x0044, 0x1078, 0x756c, 0x0078, 0x56f1, 0x0c7e, 0x1078,
+	0x74d7, 0x017f, 0x0040, 0x56f1, 0x611a, 0x601f, 0x0004, 0x7120,
+	0x610a, 0xa286, 0x0004, 0x00c0, 0x56e9, 0x6007, 0x0005, 0x0078,
+	0x56eb, 0x6007, 0x0001, 0x6003, 0x0001, 0x1078, 0x5c45, 0x1078,
+	0x6109, 0x0c7f, 0x007c, 0x7110, 0xd1bc, 0x0040, 0x570b, 0x7020,
+	0x2060, 0xac84, 0x000f, 0x00c0, 0x570b, 0xac82, 0xaa00, 0x0048,
+	0x570b, 0x6854, 0xac02, 0x00c8, 0x570b, 0x7124, 0x610a, 0x2009,
+	0x0045, 0x1078, 0x756c, 0x007c, 0x7110, 0xa18c, 0xff00, 0x810f,
+	0xa18e, 0x0000, 0x00c0, 0x571c, 0xa084, 0x000f, 0xa08a, 0x0006,
+	0x00c8, 0x571c, 0x1079, 0x571d, 0x007c, 0x5723, 0x5724, 0x5723,
+	0x5723, 0x5794, 0x57a3, 0x007c, 0x7110, 0xd1bc, 0x0040, 0x572c,
+	0x702c, 0xd084, 0x0040, 0x5793, 0x700c, 0x7108, 0x1078, 0x24e3,
+	0x00c0, 0x5793, 0x1078, 0x4499, 0x00c0, 0x5793, 0x6612, 0x6516,
+	0x6204, 0x7110, 0xd1bc, 0x0040, 0x575e, 0xa28c, 0x00ff, 0xa186,
+	0x0004, 0x0040, 0x5747, 0xa186, 0x0006, 0x00c0, 0x5784, 0x0c7e,
+	0x1078, 0x57b2, 0x0c7f, 0x0040, 0x5793, 0x0c7e, 0x1078, 0x74d7,
+	0x017f, 0x0040, 0x5793, 0x611a, 0x601f, 0x0002, 0x7120, 0x610a,
+	0x2009, 0x0088, 0x1078, 0x756c, 0x0078, 0x5793, 0xa28c, 0x00ff,
+	0xa186, 0x0006, 0x0040, 0x5773, 0xa186, 0x0004, 0x0040, 0x5773,
+	0xa294, 0xff00, 0x8217, 0xa286, 0x0004, 0x0040, 0x5773, 0xa286,
+	0x0006, 0x00c0, 0x5784, 0x0c7e, 0x1078, 0x74d7, 0x017f, 0x0040,
+	0x5793, 0x611a, 0x601f, 0x0005, 0x7120, 0x610a, 0x2009, 0x0088,
+	0x1078, 0x756c, 0x0078, 0x5793, 0x0c7e, 0x1078, 0x74d7, 0x017f,
+	0x0040, 0x5793, 0x611a, 0x601f, 0x0004, 0x7120, 0x610a, 0x2009,
+	0x0001, 0x1078, 0x756c, 0x007c, 0x7110, 0xd1bc, 0x0040, 0x57a2,
+	0x1078, 0x57b2, 0x0040, 0x57a2, 0x7124, 0x610a, 0x2009, 0x0089,
+	0x1078, 0x756c, 0x007c, 0x7110, 0xd1bc, 0x0040, 0x57b1, 0x1078,
+	0x57b2, 0x0040, 0x57b1, 0x7124, 0x610a, 0x2009, 0x008a, 0x1078,
+	0x756c, 0x007c, 0x7020, 0x2060, 0xac84, 0x000f, 0x00c0, 0x57c5,
+	0xac82, 0xaa00, 0x0048, 0x57c5, 0x2001, 0xa315, 0x2004, 0xac02,
+	0x00c8, 0x57c5, 0xa085, 0x0001, 0x007c, 0xa006, 0x0078, 0x57c4,
+	0x7110, 0xd1bc, 0x00c0, 0x57de, 0x7024, 0x2060, 0xac84, 0x000f,
+	0x00c0, 0x57de, 0xac82, 0xaa00, 0x0048, 0x57de, 0x6854, 0xac02,
+	0x00c8, 0x57de, 0x2009, 0x0051, 0x1078, 0x756c, 0x007c, 0x2071,
+	0xa5be, 0x7003, 0x0003, 0x700f, 0x0361, 0xa006, 0x701a, 0x7012,
+	0x7017, 0xaa00, 0x7007, 0x0000, 0x7026, 0x702b, 0x6c4e, 0x7032,
+	0x7037, 0x6ca0, 0x703b, 0x0002, 0x703f, 0x0000, 0x7043, 0xffff,
+	0x7047, 0xffff, 0x007c, 0x2071, 0xa5be, 0x00e0, 0x58c1, 0x2091,
+	0x6000, 0x700c, 0x8001, 0x700e, 0x00c0, 0x5873, 0x700f, 0x0361,
+	0x7007, 0x0001, 0x127e, 0x2091, 0x8000, 0x7138, 0x8109, 0x713a,
+	0x00c0, 0x5871, 0x703b, 0x0002, 0x2009, 0x0100, 0x2104, 0xa082,
+	0x0003, 0x00c8, 0x5871, 0x703c, 0xa086, 0x0001, 0x00c0, 0x584e,
+	0x0d7e, 0x2069, 0x0140, 0x6804, 0xa084, 0x4000, 0x0040, 0x582c,
+	0x6803, 0x1000, 0x0078, 0x5833, 0x6804, 0xa084, 0x1000, 0x0040,
+	0x5833, 0x6803, 0x0100, 0x6803, 0x0000, 0x703f, 0x0000, 0x2069,
+	0xa5ab, 0x6804, 0xa082, 0x0006, 0x00c0, 0x5840, 0x6807, 0x0000,
+	0x6830, 0xa082, 0x0003, 0x00c0, 0x5847, 0x6833, 0x0000, 0x1078,
+	0x6109, 0x1078, 0x61d3, 0x0d7f, 0x0078, 0x5871, 0x0d7e, 0x2069,
+	0xa300, 0x6944, 0x6860, 0xa102, 0x00c8, 0x5870, 0x2069, 0xa5ab,
+	0x6804, 0xa086, 0x0000, 0x00c0, 0x5870, 0x6830, 0xa086, 0x0000,
+	0x00c0, 0x5870, 0x703f, 0x0001, 0x6807, 0x0006, 0x6833, 0x0003,
+	0x2069, 0x0100, 0x6830, 0x689e, 0x2069, 0x0140, 0x6803, 0x0600,
+	0x0d7f, 0x0078, 0x5876, 0x127e, 0x2091, 0x8000, 0x7024, 0xa00d,
+	0x0040, 0x588e, 0x7020, 0x8001, 0x7022, 0x00c0, 0x588e, 0x7023,
+	0x0009, 0x8109, 0x7126, 0xa186, 0x03e8, 0x00c0, 0x5889, 0x7028,
+	0x107a, 0x81ff, 0x00c0, 0x588e, 0x7028, 0x107a, 0x7030, 0xa00d,
+	0x0040, 0x589f, 0x702c, 0x8001, 0x702e, 0x00c0, 0x589f, 0x702f,
+	0x0009, 0x8109, 0x7132, 0x00c0, 0x589f, 0x7034, 0x107a, 0x7040,
+	0xa005, 0x0040, 0x58a7, 0x0050, 0x58a7, 0x8001, 0x7042, 0x7044,
+	0xa005, 0x0040, 0x58af, 0x0050, 0x58af, 0x8001, 0x7046, 0x7018,
+	0xa00d, 0x0040, 0x58c0, 0x7008, 0x8001, 0x700a, 0x00c0, 0x58c0,
+	0x700b, 0x0009, 0x8109, 0x711a, 0x00c0, 0x58c0, 0x701c, 0x107a,
+	0x127f, 0x7004, 0x0079, 0x58c4, 0x58eb, 0x58ec, 0x5908, 0x0e7e,
+	0x2071, 0xa5be, 0x7018, 0xa005, 0x00c0, 0x58d2, 0x711a, 0x721e,
+	0x700b, 0x0009, 0x0e7f, 0x007c, 0x0e7e, 0x007e, 0x2071, 0xa5be,
+	0x701c, 0xa206, 0x00c0, 0x58de, 0x701a, 0x701e, 0x007f, 0x0e7f,
+	0x007c, 0x0e7e, 0x2071, 0xa5be, 0x6088, 0xa102, 0x0048, 0x58e9,
+	0x618a, 0x0e7f, 0x007c, 0x007c, 0x7110, 0x1078, 0x4501, 0x00c0,
+	0x58fe, 0x6088, 0x8001, 0x0048, 0x58fe, 0x608a, 0x00c0, 0x58fe,
+	0x127e, 0x2091, 0x8000, 0x1078, 0x6109, 0x127f, 0x8108, 0xa182,
+	0x00ff, 0x0048, 0x5906, 0xa00e, 0x7007, 0x0002, 0x7112, 0x007c,
+	0x7014, 0x2060, 0x127e, 0x2091, 0x8000, 0x603c, 0xa005, 0x0040,
+	0x5917, 0x8001, 0x603e, 0x00c0, 0x5917, 0x1078, 0x8cd7, 0x6014,
+	0xa005, 0x0040, 0x5941, 0x8001, 0x6016, 0x00c0, 0x5941, 0x611c,
+	0xa186, 0x0003, 0x0040, 0x5928, 0xa186, 0x0006, 0x00c0, 0x593f,
+	0x6010, 0x2068, 0x6854, 0xa08a, 0x199a, 0x0048, 0x593f, 0xa082,
+	0x1999, 0x6856, 0xa08a, 0x199a, 0x0048, 0x5938, 0x2001, 0x1999,
+	0x8003, 0x800b, 0x810b, 0xa108, 0x6116, 0x0078, 0x5941, 0x1078,
+	0x8810, 0x127f, 0xac88, 0x0010, 0x7116, 0x2001, 0xca00, 0xa102,
+	0x0048, 0x594e, 0x7017, 0xaa00, 0x7007, 0x0000, 0x007c, 0x0e7e,
+	0x2071, 0xa5be, 0x7027, 0x07d0, 0x7023, 0x0009, 0x703b, 0x0002,
+	0x0e7f, 0x007c, 0x2001, 0xa5c7, 0x2003, 0x0000, 0x007c, 0x0e7e,
+	0x2071, 0xa5be, 0x7132, 0x702f, 0x0009, 0x0e7f, 0x007c, 0x2011,
+	0xa5ca, 0x2013, 0x0000, 0x007c, 0x0e7e, 0x2071, 0xa5be, 0x711a,
+	0x721e, 0x700b, 0x0009, 0x0e7f, 0x007c, 0x027e, 0x0e7e, 0x0f7e,
+	0x2079, 0xa300, 0x7a34, 0xd294, 0x0040, 0x59a4, 0x2071, 0xa5aa,
+	0x2e14, 0xa0fe, 0x0000, 0x0040, 0x5991, 0xa0fe, 0x0001, 0x0040,
+	0x5995, 0xa0fe, 0x0002, 0x00c0, 0x59a0, 0xa292, 0x0085, 0x0078,
+	0x5997, 0xa292, 0x0005, 0x0078, 0x5997, 0xa292, 0x0002, 0x2272,
+	0x0040, 0x599c, 0x00c8, 0x59a4, 0x2011, 0x8037, 0x1078, 0x3579,
+	0x2011, 0xa5a9, 0x2204, 0x2072, 0x0f7f, 0x0e7f, 0x027f, 0x007c,
+	0x0c7e, 0x2061, 0xa62d, 0x0c7f, 0x007c, 0xa184, 0x000f, 0x8003,
+	0x8003, 0x8003, 0xa080, 0xa62d, 0x2060, 0x007c, 0x6854, 0xa08a,
+	0x199a, 0x0048, 0x59bd, 0x2001, 0x1999, 0xa005, 0x00c0, 0x59cc,
+	0x0c7e, 0x2061, 0xa62d, 0x6014, 0x0c7f, 0xa005, 0x00c0, 0x59d1,
+	0x2001, 0x001e, 0x0078, 0x59d1, 0xa08e, 0xffff, 0x00c0, 0x59d1,
+	0xa006, 0x8003, 0x800b, 0x810b, 0xa108, 0x6116, 0x684c, 0xa08c,
+	0x00c0, 0xa18e, 0x00c0, 0x0040, 0x5a24, 0xd0b4, 0x00c0, 0x59e8,
+	0xd0bc, 0x00c0, 0x5a14, 0x2009, 0x0006, 0x1078, 0x5a43, 0x007c,
+	0xd0fc, 0x0040, 0x59f3, 0xa084, 0x0003, 0x0040, 0x59f3, 0xa086,
+	0x0003, 0x00c0, 0x5a3c, 0x6024, 0xd0d4, 0x0040, 0x59fd, 0xc0d4,
+	0x6026, 0x6860, 0x602a, 0x685c, 0x602e, 0x2009, 0xa373, 0x2104,
+	0xd084, 0x0040, 0x5a0f, 0x6118, 0xa188, 0x0027, 0x2104, 0xd08c,
+	0x00c0, 0x5a0f, 0x2009, 0x0042, 0x1078, 0x756c, 0x007c, 0x2009,
+	0x0043, 0x1078, 0x756c, 0x007c, 0xd0fc, 0x0040, 0x5a1f, 0xa084,
+	0x0003, 0x0040, 0x5a1f, 0xa086, 0x0003, 0x00c0, 0x5a3c, 0x2009,
+	0x0042, 0x1078, 0x756c, 0x007c, 0xd0fc, 0x0040, 0x5a32, 0xa084,
+	0x0003, 0xa08e, 0x0002, 0x0040, 0x5a36, 0x2009, 0x0041, 0x1078,
+	0x756c, 0x007c, 0x1078, 0x5a41, 0x0078, 0x5a31, 0x2009, 0x0043,
+	0x1078, 0x756c, 0x0078, 0x5a31, 0x2009, 0x0004, 0x1078, 0x5a43,
+	0x007c, 0x2009, 0x0001, 0x0d7e, 0x6010, 0xa0ec, 0xf000, 0x0040,
+	0x5a6b, 0x2068, 0x6952, 0x6800, 0x6012, 0xa186, 0x0001, 0x00c0,
+	0x5a65, 0x694c, 0xa18c, 0x8100, 0xa18e, 0x8100, 0x00c0, 0x5a65,
+	0x0c7e, 0x2061, 0xa62d, 0x6200, 0xd28c, 0x00c0, 0x5a64, 0x6204,
+	0x8210, 0x0048, 0x5a64, 0x6206, 0x0c7f, 0x1078, 0x4982, 0x6010,
+	0xa06d, 0x10c0, 0x59b6, 0x0d7f, 0x007c, 0x157e, 0x0c7e, 0x2061,
+	0xa62d, 0x6000, 0x81ff, 0x0040, 0x5a78, 0xa205, 0x0078, 0x5a79,
+	0xa204, 0x6002, 0x0c7f, 0x157f, 0x007c, 0x6800, 0xd08c, 0x00c0,
+	0x5a89, 0x6808, 0xa005, 0x0040, 0x5a89, 0x8001, 0x680a, 0xa085,
+	0x0001, 0x007c, 0x20a9, 0x0010, 0xa006, 0x8004, 0x8086, 0x818e,
+	0x00c8, 0x5a93, 0xa200, 0x00f0, 0x5a8e, 0x8086, 0x818e, 0x007c,
+	0x157e, 0x20a9, 0x0010, 0xa005, 0x0040, 0x5ab9, 0xa11a, 0x00c8,
+	0x5ab9, 0x8213, 0x818d, 0x0048, 0x5aac, 0xa11a, 0x00c8, 0x5aad,
+	0x00f0, 0x5aa1, 0x0078, 0x5ab1, 0xa11a, 0x2308, 0x8210, 0x00f0,
+	0x5aa1, 0x007e, 0x3200, 0xa084, 0xf7ff, 0x2080, 0x007f, 0x157f,
+	0x007c, 0x007e, 0x3200, 0xa085, 0x0800, 0x0078, 0x5ab5, 0x127e,
+	0x2091, 0x2200, 0x2079, 0xa5ab, 0x127f, 0x0d7e, 0x2069, 0xa5ab,
+	0x6803, 0x0005, 0x2069, 0x0004, 0x2d04, 0xa085, 0x8001, 0x206a,
+	0x0d7f, 0x007c, 0x0c7e, 0x6027, 0x0001, 0x7804, 0xa084, 0x0007,
+	0x0079, 0x5ada, 0x5ae4, 0x5b09, 0x5b64, 0x5aea, 0x5b09, 0x5ae4,
+	0x5ae2, 0x5ae2, 0x1078, 0x1328, 0x1078, 0x595a, 0x1078, 0x6109,
+	0x0c7f, 0x007c, 0x62c0, 0x82ff, 0x00c0, 0x5af0, 0x0c7f, 0x007c,
+	0x2011, 0x4129, 0x1078, 0x58d4, 0x7828, 0xa092, 0x00c8, 0x00c8,
+	0x5aff, 0x8000, 0x782a, 0x1078, 0x4168, 0x0078, 0x5aee, 0x1078,
+	0x4129, 0x7807, 0x0003, 0x7827, 0x0000, 0x782b, 0x0000, 0x0078,
+	0x5aee, 0x1078, 0x595a, 0x3c00, 0x007e, 0x2011, 0x0209, 0x20e1,
+	0x4000, 0x2214, 0x007f, 0x20e0, 0x82ff, 0x0040, 0x5b27, 0x62c0,
+	0x82ff, 0x00c0, 0x5b27, 0x782b, 0x0000, 0x7824, 0xa065, 0x1040,
+	0x1328, 0x2009, 0x0013, 0x1078, 0x756c, 0x0c7f, 0x007c, 0x3900,
+	0xa082, 0xa6cd, 0x00c8, 0x5b2e, 0x1078, 0x728a, 0x0c7e, 0x7824,
+	0xa065, 0x1040, 0x1328, 0x7804, 0xa086, 0x0004, 0x0040, 0x5ba9,
+	0x7828, 0xa092, 0x2710, 0x00c8, 0x5b44, 0x8000, 0x782a, 0x0c7f,
+	0x1078, 0x6c33, 0x0078, 0x5b25, 0x6104, 0xa186, 0x0003, 0x00c0,
+	0x5b5b, 0x0e7e, 0x2071, 0xa300, 0x70d4, 0x0e7f, 0xd08c, 0x0040,
+	0x5b5b, 0x0c7e, 0x0e7e, 0x2061, 0x0100, 0x2071, 0xa300, 0x1078,
+	0x4171, 0x0e7f, 0x0c7f, 0x1078, 0xa241, 0x2009, 0x0014, 0x1078,
+	0x756c, 0x0c7f, 0x0078, 0x5b25, 0x2001, 0xa5c7, 0x2003, 0x0000,
+	0x62c0, 0x82ff, 0x00c0, 0x5b78, 0x782b, 0x0000, 0x7824, 0xa065,
+	0x1040, 0x1328, 0x2009, 0x0013, 0x1078, 0x75c3, 0x0c7f, 0x007c,
+	0x0c7e, 0x0d7e, 0x3900, 0xa082, 0xa6cd, 0x00c8, 0x5b81, 0x1078,
+	0x728a, 0x7824, 0xa005, 0x1040, 0x1328, 0x781c, 0xa06d, 0x1040,
+	0x1328, 0x6800, 0xc0dc, 0x6802, 0x7924, 0x2160, 0x1078, 0x753d,
+	0x693c, 0x81ff, 0x1040, 0x1328, 0x8109, 0x693e, 0x6854, 0xa015,
+	0x0040, 0x5b9d, 0x7a1e, 0x0078, 0x5b9f, 0x7918, 0x791e, 0x7807,
+	0x0000, 0x7827, 0x0000, 0x0d7f, 0x0c7f, 0x1078, 0x6109, 0x0078,
+	0x5b76, 0x6104, 0xa186, 0x0002, 0x0040, 0x5bb4, 0xa186, 0x0004,
+	0x0040, 0x5bb4, 0x0078, 0x5b38, 0x7808, 0xac06, 0x0040, 0x5b38,
+	0x1078, 0x6010, 0x1078, 0x5c45, 0x0c7f, 0x1078, 0x6109, 0x0078,
+	0x5b25, 0x0c7e, 0x6027, 0x0002, 0x62c8, 0x82ff, 0x00c0, 0x5bdb,
+	0x62c4, 0x82ff, 0x00c0, 0x5bdb, 0x793c, 0xa1e5, 0x0000, 0x0040,
+	0x5bd5, 0x2009, 0x0049, 0x1078, 0x756c, 0x2011, 0xa5ca, 0x2013,
+	0x0000, 0x0c7f, 0x007c, 0x3908, 0xa192, 0xa6cd, 0x00c8, 0x5be2,
+	0x1078, 0x728a, 0x6017, 0x0010, 0x793c, 0x81ff, 0x0040, 0x5bd5,
+	0x793c, 0xa188, 0x0007, 0x210c, 0xa18e, 0x0006, 0x00c0, 0x5bf4,
+	0x6017, 0x0012, 0x0078, 0x5bd9, 0x6017, 0x0016, 0x0078, 0x5bd9,
+	0x007e, 0x017e, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x600f, 0x0000,
+	0x2c08, 0x2061, 0xa5ab, 0x6020, 0x8000, 0x6022, 0x6010, 0xa005,
+	0x0040, 0x5c13, 0xa080, 0x0003, 0x2102, 0x6112, 0x127f, 0x0c7f,
+	0x017f, 0x007f, 0x007c, 0x6116, 0x6112, 0x0078, 0x5c0e, 0x0d7e,
+	0x2069, 0xa5ab, 0x6000, 0xd0d4, 0x0040, 0x5c2c, 0x6820, 0x8000,
+	0x6822, 0xa086, 0x0001, 0x00c0, 0x5c27, 0x2c00, 0x681e, 0x6804,
+	0xa084, 0x0007, 0x0079, 0x6111, 0xc0d5, 0x6002, 0x6818, 0xa005,
+	0x0040, 0x5c3e, 0x6056, 0x605b, 0x0000, 0x007e, 0x2c00, 0x681a,
+	0x0d7f, 0x685a, 0x2069, 0xa5ab, 0x0078, 0x5c1e, 0x6056, 0x605a,
+	0x2c00, 0x681a, 0x681e, 0x0078, 0x5c1e, 0x007e, 0x017e, 0x0c7e,
+	0x127e, 0x2091, 0x8000, 0x600f, 0x0000, 0x2c08, 0x2061, 0xa5ab,
+	0x6020, 0x8000, 0x6022, 0x6008, 0xa005, 0x0040, 0x5c60, 0xa080,
+	0x0003, 0x2102, 0x610a, 0x127f, 0x0c7f, 0x017f, 0x007f, 0x007c,
+	0x610e, 0x610a, 0x0078, 0x5c5b, 0x0c7e, 0x600f, 0x0000, 0x2c08,
+	0x2061, 0xa5ab, 0x6034, 0xa005, 0x0040, 0x5c74, 0xa080, 0x0003,
+	0x2102, 0x6136, 0x0c7f, 0x007c, 0x613a, 0x6136, 0x0078, 0x5c72,
+	0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x067e, 0x027e, 0x017e, 0x007e,
+	0x127e, 0x2071, 0xa5ab, 0x7638, 0x2660, 0x2678, 0x2091, 0x8000,
+	0x8cff, 0x0040, 0x5ced, 0x6018, 0xa080, 0x0028, 0x2004, 0xa206,
+	0x00c0, 0x5ce8, 0x87ff, 0x0040, 0x5c99, 0x6020, 0xa106, 0x00c0,
+	0x5ce8, 0x703c, 0xac06, 0x00c0, 0x5cab, 0x037e, 0x2019, 0x0001,
+	0x1078, 0x6e6c, 0x7033, 0x0000, 0x703f, 0x0000, 0x7043, 0x0000,
+	0x7047, 0x0000, 0x037f, 0x7038, 0xac36, 0x00c0, 0x5cb1, 0x660c,
+	0x763a, 0x7034, 0xac36, 0x00c0, 0x5cbf, 0x2c00, 0xaf36, 0x0040,
+	0x5cbd, 0x2f00, 0x7036, 0x0078, 0x5cbf, 0x7037, 0x0000, 0x660c,
+	0x067e, 0x2c00, 0xaf06, 0x0040, 0x5cc8, 0x7e0e, 0x0078, 0x5cc9,
+	0x2678, 0x600f, 0x0000, 0x1078, 0x8a44, 0x0040, 0x5ce3, 0x6010,
+	0x2068, 0x601c, 0xa086, 0x0003, 0x00c0, 0x5cf7, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x1078, 0x8cb8, 0x1078, 0xa181, 0x1078,
+	0x4982, 0x1078, 0x8bf4, 0x1078, 0x8c01, 0x0c7f, 0x0078, 0x5c88,
+	0x2c78, 0x600c, 0x2060, 0x0078, 0x5c88, 0x127f, 0x007f, 0x017f,
+	0x027f, 0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x601c,
+	0xa086, 0x0006, 0x00c0, 0x5cd6, 0x1078, 0xa181, 0x1078, 0x9e70,
+	0x0078, 0x5ce3, 0x007e, 0x067e, 0x0c7e, 0x0d7e, 0x0f7e, 0x2031,
+	0x0000, 0x127e, 0x2091, 0x8000, 0x2079, 0xa5ab, 0x7838, 0xa065,
+	0x0040, 0x5d41, 0x600c, 0x007e, 0x600f, 0x0000, 0x783c, 0xac06,
+	0x00c0, 0x5d28, 0x037e, 0x2019, 0x0001, 0x1078, 0x6e6c, 0x7833,
+	0x0000, 0x783f, 0x0000, 0x7843, 0x0000, 0x7847, 0x0000, 0x037f,
+	0x1078, 0x8a44, 0x0040, 0x5d3c, 0x6010, 0x2068, 0x601c, 0xa086,
+	0x0003, 0x00c0, 0x5d4a, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000,
+	0x1078, 0x4982, 0x1078, 0x8bf4, 0x1078, 0x8c01, 0x007f, 0x0078,
+	0x5d0f, 0x7e3a, 0x7e36, 0x127f, 0x0f7f, 0x0d7f, 0x0c7f, 0x067f,
+	0x007f, 0x007c, 0x601c, 0xa086, 0x0006, 0x00c0, 0x5d33, 0x1078,
+	0x9e70, 0x0078, 0x5d3c, 0x017e, 0x027e, 0x087e, 0x2041, 0x0000,
+	0x1078, 0x5d6d, 0x1078, 0x5e21, 0x087f, 0x027f, 0x017f, 0x007c,
+	0x0f7e, 0x127e, 0x2079, 0xa5ab, 0x2091, 0x8000, 0x1078, 0x5ebc,
+	0x1078, 0x5f32, 0x127f, 0x0f7f, 0x007c, 0x0f7e, 0x0e7e, 0x0d7e,
+	0x0c7e, 0x067e, 0x017e, 0x007e, 0x127e, 0x2091, 0x8000, 0x2071,
+	0xa5ab, 0x7614, 0x2660, 0x2678, 0x8cff, 0x0040, 0x5e01, 0x6018,
+	0xa080, 0x0028, 0x2004, 0xa206, 0x00c0, 0x5dfc, 0x88ff, 0x0040,
+	0x5d8d, 0x6020, 0xa106, 0x00c0, 0x5dfc, 0x7024, 0xac06, 0x00c0,
+	0x5dbd, 0x2069, 0x0100, 0x68c0, 0xa005, 0x0040, 0x5db8, 0x1078,
+	0x595a, 0x1078, 0x6c41, 0x68c3, 0x0000, 0x1078, 0x7188, 0x7027,
+	0x0000, 0x037e, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0040,
+	0x5dad, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824,
+	0xd084, 0x0040, 0x5db5, 0x6827, 0x0001, 0x037f, 0x0078, 0x5dbd,
+	0x6003, 0x0009, 0x630a, 0x0078, 0x5dfc, 0x7014, 0xac36, 0x00c0,
+	0x5dc3, 0x660c, 0x7616, 0x7010, 0xac36, 0x00c0, 0x5dd1, 0x2c00,
+	0xaf36, 0x0040, 0x5dcf, 0x2f00, 0x7012, 0x0078, 0x5dd1, 0x7013,
+	0x0000, 0x660c, 0x067e, 0x2c00, 0xaf06, 0x0040, 0x5dda, 0x7e0e,
+	0x0078, 0x5ddb, 0x2678, 0x600f, 0x0000, 0x6010, 0x2068, 0x1078,
+	0x8a44, 0x0040, 0x5df5, 0x601c, 0xa086, 0x0003, 0x00c0, 0x5e0a,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0x8cb8, 0x1078,
+	0xa181, 0x1078, 0x4982, 0x1078, 0x8bf4, 0x1078, 0x8c01, 0x1078,
+	0x7045, 0x0c7f, 0x0078, 0x5d7c, 0x2c78, 0x600c, 0x2060, 0x0078,
+	0x5d7c, 0x127f, 0x007f, 0x017f, 0x067f, 0x0c7f, 0x0d7f, 0x0e7f,
+	0x0f7f, 0x007c, 0x601c, 0xa086, 0x0006, 0x00c0, 0x5e15, 0x1078,
+	0xa181, 0x1078, 0x9e70, 0x0078, 0x5df5, 0x601c, 0xa086, 0x0002,
+	0x00c0, 0x5df5, 0x6004, 0xa086, 0x0085, 0x0040, 0x5de8, 0x0078,
+	0x5df5, 0x0c7e, 0x007e, 0x127e, 0x2091, 0x8000, 0xa280, 0xa434,
+	0x2004, 0xa065, 0x0040, 0x5eb8, 0x0f7e, 0x0e7e, 0x0d7e, 0x067e,
+	0x2071, 0xa5ab, 0x6654, 0x7018, 0xac06, 0x00c0, 0x5e38, 0x761a,
+	0x701c, 0xac06, 0x00c0, 0x5e44, 0x86ff, 0x00c0, 0x5e43, 0x7018,
+	0x701e, 0x0078, 0x5e44, 0x761e, 0x6058, 0xa07d, 0x0040, 0x5e49,
+	0x7e56, 0xa6ed, 0x0000, 0x0040, 0x5e4f, 0x2f00, 0x685a, 0x6057,
+	0x0000, 0x605b, 0x0000, 0x6000, 0xc0d4, 0xc0dc, 0x6002, 0x1078,
+	0x4410, 0x0040, 0x5eb4, 0x7624, 0x86ff, 0x0040, 0x5ea2, 0xa680,
+	0x0004, 0x2004, 0xad06, 0x00c0, 0x5ea2, 0x0d7e, 0x2069, 0x0100,
+	0x68c0, 0xa005, 0x0040, 0x5e99, 0x1078, 0x595a, 0x1078, 0x6c41,
+	0x68c3, 0x0000, 0x1078, 0x7188, 0x7027, 0x0000, 0x037e, 0x2069,
+	0x0140, 0x6b04, 0xa384, 0x1000, 0x0040, 0x5e82, 0x6803, 0x0100,
+	0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0040, 0x5e8a,
+	0x6827, 0x0001, 0x037f, 0x0d7f, 0x0c7e, 0x603c, 0xa005, 0x0040,
+	0x5e93, 0x8001, 0x603e, 0x2660, 0x1078, 0x8c01, 0x0c7f, 0x0078,
+	0x5ea2, 0x0d7f, 0x0c7e, 0x2660, 0x6003, 0x0009, 0x630a, 0x0c7f,
+	0x0078, 0x5e57, 0x8dff, 0x0040, 0x5eb0, 0x6837, 0x0103, 0x6b4a,
+	0x6847, 0x0000, 0x1078, 0x8cb8, 0x1078, 0xa181, 0x1078, 0x4982,
+	0x1078, 0x7045, 0x0078, 0x5e57, 0x067f, 0x0d7f, 0x0e7f, 0x0f7f,
+	0x127f, 0x007f, 0x0c7f, 0x007c, 0x007e, 0x067e, 0x0c7e, 0x0d7e,
+	0x2031, 0x0000, 0x7814, 0xa065, 0x0040, 0x5f16, 0x600c, 0x007e,
+	0x600f, 0x0000, 0x7824, 0xac06, 0x00c0, 0x5efb, 0x2069, 0x0100,
+	0x68c0, 0xa005, 0x0040, 0x5ef5, 0x1078, 0x595a, 0x1078, 0x6c41,
+	0x68c3, 0x0000, 0x1078, 0x7188, 0x7827, 0x0000, 0x037e, 0x2069,
+	0x0140, 0x6b04, 0xa384, 0x1000, 0x0040, 0x5eea, 0x6803, 0x0100,
+	0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0040, 0x5ef2,
+	0x6827, 0x0001, 0x037f, 0x0078, 0x5efb, 0x6003, 0x0009, 0x630a,
+	0x2c30, 0x0078, 0x5f13, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040,
+	0x5f0f, 0x601c, 0xa086, 0x0003, 0x00c0, 0x5f1d, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x1078, 0x4982, 0x1078, 0x8bf4, 0x1078,
+	0x8c01, 0x1078, 0x7045, 0x007f, 0x0078, 0x5ec3, 0x7e16, 0x7e12,
+	0x0d7f, 0x0c7f, 0x067f, 0x007f, 0x007c, 0x601c, 0xa086, 0x0006,
+	0x00c0, 0x5f26, 0x1078, 0x9e70, 0x0078, 0x5f0f, 0x601c, 0xa086,
+	0x0002, 0x00c0, 0x5f0f, 0x6004, 0xa086, 0x0085, 0x0040, 0x5f06,
+	0x0078, 0x5f0f, 0x007e, 0x067e, 0x0c7e, 0x0d7e, 0x7818, 0xa065,
+	0x0040, 0x5fa0, 0x6054, 0x007e, 0x6057, 0x0000, 0x605b, 0x0000,
+	0x6000, 0xc0d4, 0xc0dc, 0x6002, 0x1078, 0x4410, 0x0040, 0x5f9d,
+	0x7e24, 0x86ff, 0x0040, 0x5f8f, 0xa680, 0x0004, 0x2004, 0xad06,
+	0x00c0, 0x5f8f, 0x0d7e, 0x2069, 0x0100, 0x68c0, 0xa005, 0x0040,
+	0x5f86, 0x1078, 0x595a, 0x1078, 0x6c41, 0x68c3, 0x0000, 0x1078,
+	0x7188, 0x7827, 0x0000, 0x037e, 0x2069, 0x0140, 0x6b04, 0xa384,
+	0x1000, 0x0040, 0x5f6f, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069,
+	0x0100, 0x6824, 0xd084, 0x0040, 0x5f77, 0x6827, 0x0001, 0x037f,
+	0x0d7f, 0x0c7e, 0x603c, 0xa005, 0x0040, 0x5f80, 0x8001, 0x603e,
+	0x2660, 0x1078, 0x8c01, 0x0c7f, 0x0078, 0x5f8f, 0x0d7f, 0x0c7e,
+	0x2660, 0x6003, 0x0009, 0x630a, 0x0c7f, 0x0078, 0x5f44, 0x8dff,
+	0x0040, 0x5f99, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078,
+	0x4982, 0x1078, 0x7045, 0x0078, 0x5f44, 0x007f, 0x0078, 0x5f37,
+	0x781e, 0x781a, 0x0d7f, 0x0c7f, 0x067f, 0x007f, 0x007c, 0x0e7e,
+	0x0d7e, 0x067e, 0x6000, 0xd0dc, 0x0040, 0x5fc4, 0x604c, 0xa06d,
+	0x0040, 0x5fc4, 0x6848, 0xa606, 0x00c0, 0x5fc4, 0x2071, 0xa5ab,
+	0x7024, 0xa035, 0x0040, 0x5fc4, 0xa080, 0x0004, 0x2004, 0xad06,
+	0x00c0, 0x5fc4, 0x1078, 0x5fc8, 0x067f, 0x0d7f, 0x0e7f, 0x007c,
+	0x0f7e, 0x2079, 0x0100, 0x78c0, 0xa005, 0x00c0, 0x5fd7, 0x0c7e,
+	0x2660, 0x6003, 0x0009, 0x630a, 0x0c7f, 0x0078, 0x600e, 0x1078,
+	0x6c41, 0x78c3, 0x0000, 0x1078, 0x7188, 0x7027, 0x0000, 0x037e,
+	0x2079, 0x0140, 0x7b04, 0xa384, 0x1000, 0x0040, 0x5feb, 0x7803,
+	0x0100, 0x7803, 0x0000, 0x2079, 0x0100, 0x7824, 0xd084, 0x0040,
+	0x5ff3, 0x7827, 0x0001, 0x1078, 0x7188, 0x037f, 0x1078, 0x4410,
+	0x0c7e, 0x603c, 0xa005, 0x0040, 0x5fff, 0x8001, 0x603e, 0x2660,
+	0x1078, 0x753d, 0x0c7f, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000,
+	0x1078, 0x8cb8, 0x1078, 0x4982, 0x1078, 0x7045, 0x0f7f, 0x007c,
+	0x0e7e, 0x0c7e, 0x2071, 0xa5ab, 0x7004, 0xa084, 0x0007, 0x0079,
+	0x6019, 0x6023, 0x6026, 0x603f, 0x605b, 0x60a0, 0x6023, 0x6023,
+	0x6021, 0x1078, 0x1328, 0x0c7f, 0x0e7f, 0x007c, 0x7024, 0xa065,
+	0x0040, 0x6034, 0x7020, 0x8001, 0x7022, 0x600c, 0xa015, 0x0040,
+	0x603b, 0x7216, 0x600f, 0x0000, 0x7007, 0x0000, 0x7027, 0x0000,
+	0x0c7f, 0x0e7f, 0x007c, 0x7216, 0x7212, 0x0078, 0x6034, 0x6018,
+	0x2060, 0x1078, 0x4410, 0x6000, 0xc0dc, 0x6002, 0x7020, 0x8001,
+	0x7022, 0x0040, 0x6050, 0x6054, 0xa015, 0x0040, 0x6057, 0x721e,
+	0x7007, 0x0000, 0x7027, 0x0000, 0x0c7f, 0x0e7f, 0x007c, 0x7218,
+	0x721e, 0x0078, 0x6050, 0x7024, 0xa065, 0x0040, 0x609d, 0x700c,
+	0xac06, 0x00c0, 0x6072, 0x1078, 0x7045, 0x600c, 0xa015, 0x0040,
+	0x606e, 0x720e, 0x600f, 0x0000, 0x0078, 0x609b, 0x720e, 0x720a,
+	0x0078, 0x609b, 0x7014, 0xac06, 0x00c0, 0x6085, 0x1078, 0x7045,
+	0x600c, 0xa015, 0x0040, 0x6081, 0x7216, 0x600f, 0x0000, 0x0078,
+	0x609b, 0x7216, 0x7212, 0x0078, 0x609b, 0x6018, 0x2060, 0x1078,
+	0x4410, 0x6000, 0xc0dc, 0x6002, 0x1078, 0x7045, 0x701c, 0xa065,
+	0x0040, 0x609b, 0x6054, 0xa015, 0x0040, 0x6099, 0x721e, 0x0078,
+	0x609b, 0x7218, 0x721e, 0x7027, 0x0000, 0x0c7f, 0x0e7f, 0x007c,
+	0x7024, 0xa065, 0x0040, 0x60ad, 0x1078, 0x7045, 0x600c, 0xa015,
+	0x0040, 0x60b4, 0x720e, 0x600f, 0x0000, 0x1078, 0x7188, 0x7027,
+	0x0000, 0x0c7f, 0x0e7f, 0x007c, 0x720e, 0x720a, 0x0078, 0x60ad,
+	0x0d7e, 0x2069, 0xa5ab, 0x6830, 0xa084, 0x0003, 0x0079, 0x60c0,
+	0x60c6, 0x60c8, 0x60ee, 0x60c6, 0x1078, 0x1328, 0x0d7f, 0x007c,
+	0x0c7e, 0x6840, 0xa086, 0x0001, 0x0040, 0x60e4, 0x683c, 0xa065,
+	0x0040, 0x60d9, 0x600c, 0xa015, 0x0040, 0x60e0, 0x6a3a, 0x600f,
+	0x0000, 0x6833, 0x0000, 0x683f, 0x0000, 0x0c7f, 0x0d7f, 0x007c,
+	0x683a, 0x6836, 0x0078, 0x60d9, 0x6843, 0x0000, 0x6838, 0xa065,
+	0x0040, 0x60d9, 0x6003, 0x0003, 0x0078, 0x60d9, 0x0c7e, 0x6843,
+	0x0000, 0x6847, 0x0000, 0x683c, 0xa065, 0x0040, 0x6106, 0x600c,
+	0xa015, 0x0040, 0x6102, 0x6a3a, 0x600f, 0x0000, 0x683f, 0x0000,
+	0x0078, 0x6106, 0x683f, 0x0000, 0x683a, 0x6836, 0x0c7f, 0x0d7f,
+	0x007c, 0x0d7e, 0x2069, 0xa5ab, 0x6804, 0xa084, 0x0007, 0x0079,
+	0x6111, 0x611b, 0x61c2, 0x61c2, 0x61c2, 0x61c2, 0x61c4, 0x61c2,
+	0x6119, 0x1078, 0x1328, 0x6820, 0xa005, 0x00c0, 0x6121, 0x0d7f,
+	0x007c, 0x0c7e, 0x680c, 0xa065, 0x0040, 0x6130, 0x6807, 0x0004,
+	0x6826, 0x682b, 0x0000, 0x1078, 0x620a, 0x0c7f, 0x0d7f, 0x007c,
+	0x6814, 0xa065, 0x0040, 0x613e, 0x6807, 0x0001, 0x6826, 0x682b,
+	0x0000, 0x1078, 0x620a, 0x0c7f, 0x0d7f, 0x007c, 0x0e7e, 0x037e,
+	0x6a1c, 0xa2f5, 0x0000, 0x0040, 0x61bd, 0x704c, 0xa00d, 0x0040,
+	0x614d, 0x7088, 0xa005, 0x0040, 0x6165, 0x7054, 0xa075, 0x0040,
+	0x6156, 0xa20e, 0x0040, 0x61bd, 0x0078, 0x615b, 0x6818, 0xa20e,
+	0x0040, 0x61bd, 0x2070, 0x704c, 0xa00d, 0x0040, 0x614d, 0x7088,
+	0xa005, 0x00c0, 0x614d, 0x2e00, 0x681e, 0x733c, 0x7038, 0xa302,
+	0x00c8, 0x614d, 0x1078, 0x750c, 0x0040, 0x61bd, 0x8318, 0x733e,
+	0x6112, 0x2e10, 0x621a, 0xa180, 0x0014, 0x2004, 0xa084, 0x00ff,
+	0x6032, 0xa180, 0x0014, 0x2003, 0x0000, 0xa180, 0x0015, 0x2004,
+	0xa08a, 0x199a, 0x0048, 0x6186, 0x2001, 0x1999, 0x8003, 0x801b,
+	0x831b, 0xa318, 0x6316, 0x037f, 0x0f7e, 0x2c78, 0x71a0, 0xd1bc,
+	0x0040, 0x619f, 0x7100, 0xd1f4, 0x0040, 0x619b, 0x7114, 0xa18c,
+	0x00ff, 0x0078, 0x61a4, 0x2009, 0x0000, 0x0078, 0x61a4, 0xa1e0,
+	0x293f, 0x2c0c, 0xa18c, 0x00ff, 0x2061, 0x0100, 0x619a, 0x1078,
+	0x679b, 0x7300, 0xc3dd, 0x7302, 0x6807, 0x0002, 0x2f18, 0x6b26,
+	0x682b, 0x0000, 0x781f, 0x0003, 0x7803, 0x0001, 0x7807, 0x0040,
+	0x0f7f, 0x0e7f, 0x0c7f, 0x0d7f, 0x007c, 0x037f, 0x0e7f, 0x0c7f,
+	0x0078, 0x61bb, 0x0d7f, 0x007c, 0x0c7e, 0x680c, 0xa065, 0x0040,
+	0x61d0, 0x6807, 0x0004, 0x6826, 0x682b, 0x0000, 0x1078, 0x620a,
+	0x0c7f, 0x0d7f, 0x007c, 0x0f7e, 0x0d7e, 0x2069, 0xa5ab, 0x6830,
+	0xa086, 0x0000, 0x00c0, 0x61f1, 0x6838, 0xa07d, 0x0040, 0x61f1,
+	0x6833, 0x0001, 0x683e, 0x6847, 0x0000, 0x127e, 0x0f7e, 0x2091,
+	0x2200, 0x027f, 0x1078, 0x1d28, 0x00c0, 0x61f4, 0x127f, 0x1078,
+	0x6ae5, 0x0d7f, 0x0f7f, 0x007c, 0x127f, 0x6843, 0x0000, 0x7803,
+	0x0002, 0x780c, 0xa015, 0x0040, 0x6206, 0x6a3a, 0x780f, 0x0000,
+	0x6833, 0x0000, 0x683f, 0x0000, 0x0078, 0x61f1, 0x683a, 0x6836,
+	0x0078, 0x6200, 0x601c, 0xa084, 0x000f, 0x1079, 0x6210, 0x007c,
+	0x6219, 0x621e, 0x663f, 0x6758, 0x621e, 0x663f, 0x6758, 0x6219,
+	0x621e, 0x1078, 0x6010, 0x1078, 0x6109, 0x007c, 0x157e, 0x137e,
+	0x147e, 0x0c7e, 0x0f7e, 0x6004, 0xa08a, 0x0044, 0x10c8, 0x1328,
+	0x6118, 0x2178, 0x79a0, 0xd1bc, 0x0040, 0x623b, 0x7900, 0xd1f4,
+	0x0040, 0x6237, 0x7914, 0xa18c, 0x00ff, 0x0078, 0x6240, 0x2009,
+	0x0000, 0x0078, 0x6240, 0xa1f8, 0x293f, 0x2f0c, 0xa18c, 0x00ff,
+	0x2c78, 0x2061, 0x0100, 0x619a, 0xa08a, 0x0040, 0x00c8, 0x6292,
+	0x1079, 0x6250, 0x0f7f, 0x0c7f, 0x147f, 0x137f, 0x157f, 0x007c,
+	0x62f8, 0x6340, 0x6368, 0x6403, 0x6433, 0x643b, 0x6462, 0x6473,
+	0x6484, 0x648c, 0x64a4, 0x648c, 0x650f, 0x6473, 0x6530, 0x6538,
+	0x6484, 0x6538, 0x6549, 0x6290, 0x6290, 0x6290, 0x6290, 0x6290,
+	0x6290, 0x6290, 0x6290, 0x6290, 0x6290, 0x6290, 0x6d05, 0x6d2a,
+	0x6d3f, 0x6d62, 0x6d83, 0x6462, 0x6290, 0x6462, 0x648c, 0x6290,
+	0x6368, 0x6403, 0x6290, 0x72ac, 0x648c, 0x6290, 0x72cc, 0x648c,
+	0x6290, 0x6290, 0x62f3, 0x62a1, 0x6290, 0x72f1, 0x7368, 0x7450,
+	0x6290, 0x7461, 0x645c, 0x747d, 0x6290, 0x6d98, 0x6290, 0x6290,
+	0x1078, 0x1328, 0x2100, 0x1079, 0x629b, 0x0f7f, 0x0c7f, 0x147f,
+	0x137f, 0x157f, 0x007c, 0x629f, 0x629f, 0x629f, 0x62d5, 0x1078,
+	0x1328, 0x0d7e, 0x20a1, 0x020b, 0x1078, 0x6567, 0x7810, 0x2068,
+	0x20a3, 0x2414, 0x20a3, 0x0018, 0x20a3, 0x0800, 0x683c, 0x20a2,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x6850, 0x20a2, 0x6854, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0018, 0x1078, 0x6c2d, 0x0d7f, 0x007c, 0x0d7e, 0x7818,
+	0x2068, 0x68a0, 0xa082, 0x007e, 0x0048, 0x62d2, 0xa085, 0x0001,
+	0x0d7f, 0x007c, 0xa006, 0x0078, 0x62d0, 0x0d7e, 0x20a1, 0x020b,
+	0x1078, 0x6567, 0x20a3, 0x0500, 0x20a3, 0x0000, 0x7810, 0xa0e8,
+	0x000f, 0x6808, 0x20a2, 0x680c, 0x20a2, 0x6810, 0x20a2, 0x6814,
+	0x20a2, 0x6818, 0x20a2, 0x681c, 0x20a2, 0x60c3, 0x0010, 0x1078,
+	0x6c2d, 0x0d7f, 0x007c, 0x6030, 0x609a, 0x1078, 0x6c2d, 0x007c,
+	0x20a1, 0x020b, 0x1078, 0x6567, 0x20a3, 0x5200, 0x20a3, 0x0000,
+	0x0d7e, 0x2069, 0xa351, 0x6804, 0xd084, 0x0040, 0x6312, 0x6828,
+	0x20a3, 0x0000, 0x017e, 0x1078, 0x24fa, 0x21a2, 0x017f, 0x0d7f,
+	0x0078, 0x6317, 0x0d7f, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a9,
+	0x0004, 0x2099, 0xa305, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xa301,
+	0x53a6, 0x7818, 0xa080, 0x0028, 0x2004, 0xa082, 0x007f, 0x0048,
+	0x6331, 0x2001, 0xa31a, 0x20a6, 0x2001, 0xa31b, 0x20a6, 0x0078,
+	0x6337, 0x20a3, 0x0000, 0x6030, 0xa084, 0x00ff, 0x20a2, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x001c, 0x1078, 0x6c2d, 0x007c,
+	0x20a1, 0x020b, 0x1078, 0x6567, 0x20a3, 0x0500, 0x20a3, 0x0000,
+	0x7818, 0xa080, 0x0028, 0x2004, 0xa082, 0x007f, 0x0048, 0x6358,
+	0x2001, 0xa31a, 0x20a6, 0x2001, 0xa31b, 0x20a6, 0x0078, 0x635e,
+	0x20a3, 0x0000, 0x6030, 0xa084, 0x00ff, 0x20a2, 0x20a9, 0x0004,
+	0x2099, 0xa305, 0x53a6, 0x60c3, 0x0010, 0x1078, 0x6c2d, 0x007c,
+	0x20a1, 0x020b, 0x1078, 0x6567, 0x0c7e, 0x7818, 0x2060, 0x2001,
+	0x0000, 0x1078, 0x48a2, 0x0c7f, 0x7818, 0xa080, 0x0028, 0x2004,
+	0xa086, 0x007e, 0x00c0, 0x6383, 0x20a3, 0x0400, 0x620c, 0xc2b4,
+	0x620e, 0x0078, 0x6385, 0x20a3, 0x0300, 0x20a3, 0x0000, 0x7818,
+	0xa080, 0x0028, 0x2004, 0xa086, 0x007e, 0x00c0, 0x63d2, 0x2099,
+	0xa58c, 0x33a6, 0x9398, 0x33a6, 0x9398, 0x3304, 0xa084, 0x3fff,
+	0x20a2, 0x9398, 0x33a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a9, 0x0004, 0x2099, 0xa305, 0x53a6,
+	0x20a9, 0x0004, 0x2099, 0xa301, 0x53a6, 0x20a9, 0x0010, 0x20a3,
+	0x0000, 0x00f0, 0x63af, 0x2099, 0xa594, 0x3304, 0xc0dd, 0x20a2,
+	0x2001, 0xa371, 0x2004, 0xd0e4, 0x0040, 0x63ca, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x9398, 0x9398, 0x9398, 0x33a6, 0x20a9, 0x0004,
+	0x0078, 0x63cc, 0x20a9, 0x0007, 0x20a3, 0x0000, 0x00f0, 0x63cc,
+	0x0078, 0x63f2, 0x2099, 0xa58c, 0x20a9, 0x0008, 0x53a6, 0x20a9,
+	0x0004, 0x2099, 0xa305, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xa301,
+	0x53a6, 0x20a9, 0x0008, 0x20a3, 0x0000, 0x00f0, 0x63e3, 0x20a9,
+	0x0008, 0x20a3, 0x0000, 0x00f0, 0x63e9, 0x2099, 0xa594, 0x20a9,
+	0x0008, 0x53a6, 0x20a9, 0x0008, 0x20a3, 0x0000, 0x00f0, 0x63f4,
+	0x20a9, 0x000a, 0x20a3, 0x0000, 0x00f0, 0x63fa, 0x60c3, 0x0074,
+	0x1078, 0x6c2d, 0x007c, 0x20a1, 0x020b, 0x1078, 0x6567, 0x20a3,
+	0x2010, 0x20a3, 0x0014, 0x20a3, 0x0800, 0x20a3, 0x2000, 0xa006,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x0f7e, 0x2079, 0xa351,
+	0x7904, 0x0f7f, 0xd1ac, 0x00c0, 0x641f, 0xa085, 0x0020, 0xd1a4,
+	0x0040, 0x6424, 0xa085, 0x0010, 0xa085, 0x0002, 0x0d7e, 0x0078,
+	0x64ed, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x1078, 0x6c2d, 0x007c, 0x20a1, 0x020b, 0x1078, 0x6567, 0x20a3,
+	0x5000, 0x0078, 0x6385, 0x20a1, 0x020b, 0x1078, 0x6567, 0x20a3,
+	0x2110, 0x20a3, 0x0014, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0014, 0x1078, 0x6c2d, 0x007c, 0x20a1, 0x020b, 0x1078, 0x65ef,
+	0x0078, 0x6466, 0x20a1, 0x020b, 0x1078, 0x65f8, 0x20a3, 0x0200,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0004,
+	0x1078, 0x6c2d, 0x007c, 0x20a1, 0x020b, 0x1078, 0x65f8, 0x20a3,
+	0x0100, 0x20a3, 0x0000, 0x20a3, 0x0003, 0x20a3, 0x2a00, 0x60c3,
+	0x0008, 0x1078, 0x6c2d, 0x007c, 0x20a1, 0x020b, 0x1078, 0x65f8,
+	0x20a3, 0x0200, 0x0078, 0x6385, 0x20a1, 0x020b, 0x1078, 0x65f8,
+	0x20a3, 0x0100, 0x20a3, 0x0000, 0x7828, 0xa005, 0x0040, 0x649b,
+	0x20a2, 0x0078, 0x649d, 0x20a3, 0x0003, 0x7810, 0x20a2, 0x60c3,
+	0x0008, 0x1078, 0x6c2d, 0x007c, 0x0d7e, 0x20a1, 0x020b, 0x1078,
+	0x65f8, 0x20a3, 0x0210, 0x20a3, 0x0014, 0x20a3, 0x0800, 0x7818,
+	0x2068, 0x6894, 0xa086, 0x0014, 0x00c0, 0x64ca, 0x6998, 0xa184,
+	0xc000, 0x00c0, 0x64c6, 0xd1ec, 0x0040, 0x64c2, 0x20a3, 0x2100,
+	0x0078, 0x64cc, 0x20a3, 0x0100, 0x0078, 0x64cc, 0x20a3, 0x0400,
+	0x0078, 0x64cc, 0x20a3, 0x0700, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x20a2, 0x0f7e, 0x2079, 0xa351, 0x7904, 0x0f7f, 0xd1ac,
+	0x00c0, 0x64dc, 0xa085, 0x0020, 0xd1a4, 0x0040, 0x64e1, 0xa085,
+	0x0010, 0x2009, 0xa373, 0x210c, 0xd184, 0x0040, 0x64eb, 0x699c,
+	0xd18c, 0x0040, 0x64ed, 0xa085, 0x0002, 0x027e, 0x2009, 0xa371,
+	0x210c, 0xd1e4, 0x0040, 0x64fb, 0xc0c5, 0xa094, 0x0030, 0xa296,
+	0x0010, 0x0040, 0x6505, 0xd1ec, 0x0040, 0x6505, 0xa094, 0x0030,
+	0xa296, 0x0010, 0x0040, 0x6505, 0xc0bd, 0x027f, 0x20a2, 0x20a2,
+	0x20a2, 0x60c3, 0x0014, 0x1078, 0x6c2d, 0x0d7f, 0x007c, 0x20a1,
+	0x020b, 0x1078, 0x65f8, 0x20a3, 0x0210, 0x20a3, 0x0014, 0x20a3,
+	0x0000, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078, 0x6c2d, 0x007c,
+	0x20a1, 0x020b, 0x1078, 0x65f8, 0x20a3, 0x0200, 0x0078, 0x62fe,
+	0x20a1, 0x020b, 0x1078, 0x65f8, 0x20a3, 0x0100, 0x20a3, 0x0000,
+	0x20a3, 0x0003, 0x20a3, 0x2a00, 0x60c3, 0x0008, 0x1078, 0x6c2d,
+	0x007c, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x20a1, 0x020b, 0x1078,
+	0x65f8, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3, 0x000b, 0x20a3,
+	0x0000, 0x60c3, 0x0008, 0x1078, 0x6c2d, 0x007c, 0x027e, 0x037e,
+	0x047e, 0x2019, 0x3200, 0x2021, 0x0800, 0x0078, 0x656e, 0x027e,
+	0x037e, 0x047e, 0x2019, 0x2200, 0x2021, 0x0100, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2014, 0xa286, 0x007e,
+	0x00c0, 0x6581, 0xa385, 0x00ff, 0x20a2, 0x20a3, 0xfffe, 0x0078,
+	0x65b6, 0xa286, 0x007f, 0x00c0, 0x658d, 0x0d7e, 0xa385, 0x00ff,
+	0x20a2, 0x20a3, 0xfffd, 0x0078, 0x65a4, 0xd2bc, 0x0040, 0x65ac,
+	0xa286, 0x0080, 0x0d7e, 0x00c0, 0x659c, 0xa385, 0x00ff, 0x20a2,
+	0x20a3, 0xfffc, 0x0078, 0x65a4, 0xa2e8, 0xa434, 0x2d6c, 0x6810,
+	0xa305, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa31a, 0x2da6, 0x8d68,
+	0x2da6, 0x0d7f, 0x0078, 0x65ba, 0x0d7e, 0xa2e8, 0xa434, 0x2d6c,
+	0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000,
+	0x6230, 0x22a2, 0xa485, 0x0029, 0x20a2, 0x047f, 0x037f, 0x20a3,
+	0x0000, 0x1078, 0x6c1c, 0x22a2, 0x20a3, 0x0000, 0x2fa2, 0x20a3,
+	0xffff, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f, 0x007c, 0x027e,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x20a3, 0x02ff, 0x2011, 0xfffc,
+	0x22a2, 0x0d7e, 0x2069, 0xa31a, 0x2da6, 0x8d68, 0x2da6, 0x0d7f,
+	0x20a3, 0x2029, 0x20a3, 0x0000, 0x0078, 0x65c1, 0x20a3, 0x0100,
+	0x20a3, 0x0000, 0x20a3, 0xfc02, 0x20a3, 0x0000, 0x007c, 0x027e,
+	0x037e, 0x047e, 0x2019, 0x3300, 0x2021, 0x0800, 0x0078, 0x65ff,
+	0x027e, 0x037e, 0x047e, 0x2019, 0x2300, 0x2021, 0x0100, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0xa092,
+	0x007e, 0x0048, 0x661c, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810,
+	0xa305, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa31a, 0x2da6, 0x8d68,
+	0x2da6, 0x0d7f, 0x0078, 0x662a, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c,
+	0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000,
+	0x6230, 0x22a2, 0xa485, 0x0098, 0x20a2, 0x20a3, 0x0000, 0x047f,
+	0x037f, 0x1078, 0x6c1c, 0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2,
+	0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f, 0x007c, 0x0c7e,
+	0x0f7e, 0x6004, 0xa08a, 0x0085, 0x1048, 0x1328, 0xa08a, 0x008c,
+	0x10c8, 0x1328, 0x6118, 0x2178, 0x79a0, 0xd1bc, 0x0040, 0x665d,
+	0x7900, 0xd1f4, 0x0040, 0x6659, 0x7914, 0xa18c, 0x00ff, 0x0078,
+	0x6662, 0x2009, 0x0000, 0x0078, 0x6662, 0xa1f8, 0x293f, 0x2f0c,
+	0xa18c, 0x00ff, 0x2c78, 0x2061, 0x0100, 0x619a, 0xa082, 0x0085,
+	0x1079, 0x666d, 0x0f7f, 0x0c7f, 0x007c, 0x6676, 0x6681, 0x669c,
+	0x6674, 0x6674, 0x6674, 0x6676, 0x1078, 0x1328, 0x147e, 0x20a1,
+	0x020b, 0x1078, 0x66af, 0x60c3, 0x0000, 0x1078, 0x6c2d, 0x147f,
+	0x007c, 0x147e, 0x20a1, 0x020b, 0x1078, 0x66e3, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x7808, 0x20a2, 0x7810, 0x20a2, 0x20a3, 0x0000,
+	0x20a3, 0xffff, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x000c,
+	0x1078, 0x6c2d, 0x147f, 0x007c, 0x147e, 0x20a1, 0x020b, 0x1078,
+	0x6724, 0x20a3, 0x0003, 0x20a3, 0x0300, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x60c3, 0x0004, 0x1078, 0x6c2d, 0x147f, 0x007c, 0x027e,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004,
+	0xa092, 0x007e, 0x0048, 0x66ce, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c,
+	0x6810, 0xa085, 0x8100, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa31a,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x66dd, 0x0d7e, 0xa0e8,
+	0xa434, 0x2d6c, 0x6810, 0xa085, 0x8100, 0x20a2, 0x6814, 0x20a2,
+	0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x20a3, 0x0009, 0x20a3,
+	0x0000, 0x0078, 0x65c1, 0x027e, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x7818, 0xa080, 0x0028, 0x2004, 0xa092, 0x007e, 0x0048, 0x6702,
+	0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085, 0x8400, 0x20a2,
+	0x6814, 0x20a2, 0x2069, 0xa31a, 0x2da6, 0x8d68, 0x2da6, 0x0d7f,
+	0x0078, 0x6711, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085,
+	0x8400, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000, 0x6230,
+	0x22a2, 0x20a3, 0x0099, 0x20a3, 0x0000, 0x1078, 0x6c1c, 0x22a2,
+	0x20a3, 0x0000, 0x7a08, 0x22a2, 0x7a10, 0x22a2, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x027f, 0x007c, 0x027e, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0xa092, 0x007e, 0x0048,
+	0x6743, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085, 0x8500,
+	0x20a2, 0x6814, 0x20a2, 0x2069, 0xa31a, 0x2da6, 0x8d68, 0x2da6,
+	0x0d7f, 0x0078, 0x6752, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810,
+	0xa085, 0x8500, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000,
+	0x6230, 0x22a2, 0x20a3, 0x0099, 0x20a3, 0x0000, 0x0078, 0x6715,
+	0x0c7e, 0x0f7e, 0x2c78, 0x7804, 0xa08a, 0x0040, 0x1048, 0x1328,
+	0xa08a, 0x0053, 0x10c8, 0x1328, 0x7918, 0x2160, 0x61a0, 0xd1bc,
+	0x0040, 0x6777, 0x6100, 0xd1f4, 0x0040, 0x6773, 0x6114, 0xa18c,
+	0x00ff, 0x0078, 0x677c, 0x2009, 0x0000, 0x0078, 0x677c, 0xa1e0,
+	0x293f, 0x2c0c, 0xa18c, 0x00ff, 0x2061, 0x0100, 0x619a, 0xa082,
+	0x0040, 0x1079, 0x6786, 0x0f7f, 0x0c7f, 0x007c, 0x679b, 0x68a9,
+	0x684a, 0x6a59, 0x6799, 0x6799, 0x6799, 0x6799, 0x6799, 0x6799,
+	0x6799, 0x6f5e, 0x6f6f, 0x6f80, 0x6f91, 0x6799, 0x748e, 0x6799,
+	0x6f4d, 0x1078, 0x1328, 0x0d7e, 0x157e, 0x147e, 0x780b, 0xffff,
+	0x20a1, 0x020b, 0x1078, 0x6806, 0x7910, 0x2168, 0x6948, 0x7922,
+	0x21a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x694c, 0xa184, 0x000f,
+	0x00c0, 0x67b6, 0x2001, 0x0005, 0x0078, 0x67c0, 0xd184, 0x0040,
+	0x67bd, 0x2001, 0x0004, 0x0078, 0x67c0, 0xa084, 0x0006, 0x8004,
+	0x017e, 0x2008, 0x7830, 0xa084, 0x00ff, 0x8007, 0xa105, 0x017f,
+	0x20a2, 0xd1ac, 0x0040, 0x67d0, 0x20a3, 0x0002, 0x0078, 0x67dc,
+	0xd1b4, 0x0040, 0x67d7, 0x20a3, 0x0001, 0x0078, 0x67dc, 0x20a3,
+	0x0000, 0x2230, 0x0078, 0x67de, 0x6a80, 0x6e7c, 0x20a9, 0x0008,
+	0xad80, 0x0017, 0x200c, 0x810f, 0x21a2, 0x8000, 0x00f0, 0x67e2,
+	0x22a2, 0x26a2, 0x60c3, 0x0020, 0x20e1, 0x9080, 0x6014, 0xa084,
+	0x0004, 0xa085, 0x0009, 0x6016, 0x2001, 0xa5c7, 0x2003, 0x07d0,
+	0x2001, 0xa5c6, 0x2003, 0x0009, 0x2001, 0xa5cc, 0x2003, 0x0002,
+	0x1078, 0x157e, 0x147f, 0x157f, 0x0d7f, 0x007c, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7a18, 0xa280, 0x0023, 0x2014, 0x8210, 0xa294,
+	0x00ff, 0x2202, 0x8217, 0x7818, 0xa080, 0x0028, 0x2004, 0xd0bc,
+	0x0040, 0x682c, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085,
+	0x0600, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa31a, 0x2da6, 0x8d68,
+	0x2da6, 0x0d7f, 0x0078, 0x683b, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c,
+	0x6810, 0xa085, 0x0600, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3,
+	0x0000, 0x6130, 0x21a2, 0x20a3, 0x0829, 0x20a3, 0x0000, 0x22a2,
+	0x20a3, 0x0000, 0x2fa2, 0x20a3, 0xffff, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x007c, 0x0d7e, 0x157e, 0x137e, 0x147e, 0x20a1, 0x020b,
+	0x1078, 0x686a, 0x7810, 0x2068, 0x6860, 0x20a2, 0x685c, 0x20a2,
+	0x6880, 0x20a2, 0x687c, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x60c3, 0x000c, 0x1078, 0x6c2d, 0x147f, 0x137f, 0x157f,
+	0x0d7f, 0x007c, 0x027e, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818,
+	0xa080, 0x0028, 0x2004, 0xd0bc, 0x0040, 0x6888, 0x0d7e, 0xa0e8,
+	0xa434, 0x2d6c, 0x6810, 0xa085, 0x0500, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xa31a, 0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x6897,
+	0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085, 0x0500, 0x20a2,
+	0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x20a3,
+	0x0889, 0x20a3, 0x0000, 0x1078, 0x6c1c, 0x22a2, 0x20a3, 0x0000,
+	0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f,
+	0x007c, 0x0d7e, 0x157e, 0x137e, 0x147e, 0x7810, 0xa06d, 0x1078,
+	0x488f, 0x0040, 0x68bd, 0x684c, 0xa084, 0x2020, 0xa086, 0x2020,
+	0x00c0, 0x68bd, 0x7824, 0xc0cd, 0x7826, 0x20a1, 0x020b, 0x1078,
+	0x6a12, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x7810,
+	0xa084, 0xf000, 0x00c0, 0x68d4, 0x7810, 0xa084, 0x0700, 0x8007,
+	0x1079, 0x68dc, 0x0078, 0x68d7, 0xa006, 0x1079, 0x68dc, 0x147f,
+	0x137f, 0x157f, 0x0d7f, 0x007c, 0x68e6, 0x697e, 0x6989, 0x69b3,
+	0x69c7, 0x69e3, 0x69ee, 0x68e4, 0x1078, 0x1328, 0x017e, 0x037e,
+	0x694c, 0xa18c, 0x0003, 0x0040, 0x68f1, 0xa186, 0x0003, 0x00c0,
+	0x6900, 0x6b78, 0x7824, 0xd0cc, 0x0040, 0x68f7, 0xc3e5, 0x23a2,
+	0x6868, 0x20a2, 0x6864, 0x20a2, 0x037f, 0x017f, 0x0078, 0x69be,
+	0xa186, 0x0001, 0x10c0, 0x1328, 0x6b78, 0x7824, 0xd0cc, 0x0040,
+	0x690a, 0xc3e5, 0x23a2, 0x6868, 0x20a2, 0x6864, 0x20a2, 0x22a2,
+	0x6874, 0x20a2, 0x22a2, 0x687c, 0x20a2, 0x2009, 0x0018, 0xa384,
+	0x0300, 0x0040, 0x6978, 0xd3c4, 0x0040, 0x6920, 0x687c, 0xa108,
+	0xd3cc, 0x0040, 0x6925, 0x6874, 0xa108, 0x157e, 0x20a9, 0x000d,
+	0xad80, 0x0020, 0x201c, 0x831f, 0x23a2, 0x8000, 0x00f0, 0x692a,
+	0x157f, 0x22a2, 0x22a2, 0x22a2, 0xa184, 0x0003, 0x0040, 0x6978,
+	0x20a1, 0x020b, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x007e, 0x7818,
+	0xa080, 0x0028, 0x2004, 0xd0bc, 0x0040, 0x6958, 0x0d7e, 0xa0e8,
+	0xa434, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xa31a, 0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x6967,
+	0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2,
+	0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x007f,
+	0x7b24, 0xd3cc, 0x0040, 0x6970, 0x20a3, 0x0889, 0x0078, 0x6972,
+	0x20a3, 0x0898, 0x20a2, 0x1078, 0x6c1c, 0x22a2, 0x20a3, 0x0000,
+	0x61c2, 0x037f, 0x017f, 0x1078, 0x6c2d, 0x007c, 0x2011, 0x0008,
+	0x7824, 0xd0cc, 0x0040, 0x6985, 0xc2e5, 0x22a2, 0xa016, 0x0078,
+	0x69bc, 0x2011, 0x0302, 0x7824, 0xd0cc, 0x0040, 0x6990, 0xc2e5,
+	0x22a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x0012, 0x22a2,
+	0x20a3, 0x0008, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x7000,
+	0x20a3, 0x0500, 0x22a2, 0x20a3, 0x000a, 0x22a2, 0x22a2, 0x20a3,
+	0x2500, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x60c3, 0x0032,
+	0x1078, 0x6c2d, 0x007c, 0x2011, 0x0028, 0x7824, 0xd0cc, 0x0040,
+	0x69ba, 0xc2e5, 0x22a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x22a2,
+	0x22a2, 0x22a2, 0x60c3, 0x0018, 0x1078, 0x6c2d, 0x007c, 0x2011,
+	0x0100, 0x7824, 0xd0cc, 0x0040, 0x69ce, 0xc2e5, 0x22a2, 0xa016,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x0008, 0x22a2,
+	0x7834, 0xa084, 0x00ff, 0x20a2, 0x22a2, 0x22a2, 0x60c3, 0x0020,
+	0x1078, 0x6c2d, 0x007c, 0x2011, 0x0008, 0x7824, 0xd0cc, 0x0040,
+	0x69ea, 0xc2e5, 0x22a2, 0xa016, 0x0078, 0x69bc, 0x037e, 0x7b10,
+	0xa384, 0xff00, 0x7812, 0xa384, 0x00ff, 0x8001, 0x00c0, 0x6a01,
+	0x7824, 0xd0cc, 0x0040, 0x69fd, 0xc2e5, 0x22a2, 0x037f, 0x0078,
+	0x69bc, 0x047e, 0x2021, 0x0800, 0x007e, 0x7824, 0xd0cc, 0x007f,
+	0x0040, 0x6a0b, 0xc4e5, 0x24a2, 0x047f, 0x22a2, 0x20a2, 0x037f,
+	0x0078, 0x69be, 0x027e, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818,
+	0xa080, 0x0028, 0x2004, 0xd0bc, 0x0040, 0x6a30, 0x0d7e, 0xa0e8,
+	0xa434, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xa31a, 0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x6a3f,
+	0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2,
+	0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x7824,
+	0xd0cc, 0x0040, 0x6a47, 0x20a3, 0x0889, 0x0078, 0x6a49, 0x20a3,
+	0x0898, 0x20a3, 0x0000, 0x1078, 0x6c1c, 0x22a2, 0x20a3, 0x0000,
+	0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f,
+	0x007c, 0x0d7e, 0x157e, 0x137e, 0x147e, 0x017e, 0x037e, 0x7810,
+	0xa084, 0x0700, 0x8007, 0x1079, 0x6a6c, 0x037f, 0x017f, 0x147f,
+	0x137f, 0x157f, 0x0d7f, 0x007c, 0x6a74, 0x6a74, 0x6a76, 0x6a74,
+	0x6a74, 0x6a74, 0x6a9b, 0x6a74, 0x1078, 0x1328, 0x7910, 0xa18c,
+	0xf8ff, 0xa18d, 0x0600, 0x7912, 0x20a1, 0x020b, 0x2009, 0x0003,
+	0x1078, 0x6aa5, 0x0d7e, 0x2069, 0xa351, 0x6804, 0xd0bc, 0x0040,
+	0x6a90, 0x682c, 0xa084, 0x00ff, 0x8007, 0x20a2, 0x0078, 0x6a92,
+	0x20a3, 0x3f00, 0x0d7f, 0x22a2, 0x22a2, 0x22a2, 0x60c3, 0x0001,
+	0x1078, 0x6c2d, 0x007c, 0x20a1, 0x020b, 0x2009, 0x0003, 0x1078,
+	0x6aa5, 0x20a3, 0x7f00, 0x0078, 0x6a93, 0x027e, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0xd0bc, 0x0040,
+	0x6ac3, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810, 0xa085, 0x0100,
+	0x20a2, 0x6814, 0x20a2, 0x2069, 0xa31a, 0x2da6, 0x8d68, 0x2da6,
+	0x0d7f, 0x0078, 0x6ad2, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c, 0x6810,
+	0xa085, 0x0100, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000,
+	0x6230, 0x22a2, 0x20a3, 0x0888, 0xa18d, 0x0008, 0x21a2, 0x1078,
+	0x6c1c, 0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x027f, 0x007c, 0x0e7e, 0x0d7e, 0x0c7e,
+	0x057e, 0x047e, 0x037e, 0x2061, 0x0100, 0x2071, 0xa300, 0x6130,
+	0x7818, 0x2068, 0x68a0, 0x2028, 0xd0bc, 0x00c0, 0x6afc, 0x6910,
+	0x6a14, 0x6430, 0x0078, 0x6b00, 0x6910, 0x6a14, 0x7368, 0x746c,
+	0x781c, 0xa086, 0x0006, 0x0040, 0x6b5f, 0xd5bc, 0x0040, 0x6b10,
+	0xa185, 0x0100, 0x6062, 0x6266, 0x636a, 0x646e, 0x0078, 0x6b17,
+	0xa185, 0x0100, 0x6062, 0x6266, 0x606b, 0x0000, 0x646e, 0x6073,
+	0x0809, 0x6077, 0x0008, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e,
+	0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6082, 0x7808, 0x6086,
+	0x7810, 0x2070, 0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6,
+	0x7008, 0x60ca, 0x686c, 0x60ce, 0x60ab, 0x0036, 0x60af, 0x95d5,
+	0x60d7, 0x0000, 0xa582, 0x0080, 0x0048, 0x6b49, 0x6a00, 0xd2f4,
+	0x0040, 0x6b47, 0x6a14, 0xa294, 0x00ff, 0x0078, 0x6b49, 0x2011,
+	0x0000, 0x629e, 0x6017, 0x0016, 0x2009, 0x07d0, 0x60c4, 0xa084,
+	0xfff0, 0xa005, 0x0040, 0x6b56, 0x2009, 0x1b58, 0x1078, 0x595f,
+	0x037f, 0x047f, 0x057f, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0x7810,
+	0x2070, 0x704c, 0xa084, 0x0003, 0xa086, 0x0002, 0x0040, 0x6bb7,
+	0xd5bc, 0x0040, 0x6b73, 0xa185, 0x0100, 0x6062, 0x6266, 0x636a,
+	0x646e, 0x0078, 0x6b7a, 0xa185, 0x0100, 0x6062, 0x6266, 0x606b,
+	0x0000, 0x646e, 0x6073, 0x0880, 0x6077, 0x0008, 0x688c, 0x8000,
+	0xa084, 0x00ff, 0x688e, 0x8007, 0x607a, 0x607f, 0x0000, 0x2f00,
+	0x6086, 0x7808, 0x6082, 0x7060, 0x608a, 0x705c, 0x608e, 0x7080,
+	0x60c6, 0x707c, 0x60ca, 0x707c, 0x792c, 0xa108, 0x792e, 0x7080,
+	0x7928, 0xa109, 0x792a, 0x686c, 0x60ce, 0x60ab, 0x0036, 0x60af,
+	0x95d5, 0x60d7, 0x0000, 0xa582, 0x0080, 0x0048, 0x6bb2, 0x6a00,
+	0xd2f4, 0x0040, 0x6bb0, 0x6a14, 0xa294, 0x00ff, 0x0078, 0x6bb2,
+	0x2011, 0x0000, 0x629e, 0x6017, 0x0012, 0x0078, 0x6b4c, 0xd5bc,
+	0x0040, 0x6bc2, 0xa185, 0x0700, 0x6062, 0x6266, 0x636a, 0x646e,
+	0x0078, 0x6bc9, 0xa185, 0x0700, 0x6062, 0x6266, 0x606b, 0x0000,
+	0x646e, 0x1078, 0x488f, 0x0040, 0x6bdf, 0x0d7e, 0x7810, 0xa06d,
+	0x684c, 0x0d7f, 0xa084, 0x2020, 0xa086, 0x2020, 0x00c0, 0x6bdf,
+	0x7824, 0xc0cd, 0x7826, 0x6073, 0x0889, 0x0078, 0x6be1, 0x6073,
+	0x0898, 0x6077, 0x0000, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e,
+	0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6086, 0x7808, 0x6082,
+	0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6, 0x7008, 0x60ca,
+	0x686c, 0x60ce, 0x60ab, 0x0036, 0x60af, 0x95d5, 0x60d7, 0x0000,
+	0xa582, 0x0080, 0x0048, 0x6c0f, 0x6a00, 0xd2f4, 0x0040, 0x6c0d,
+	0x6a14, 0xa294, 0x00ff, 0x0078, 0x6c0f, 0x2011, 0x0000, 0x629e,
+	0x7824, 0xd0cc, 0x0040, 0x6c18, 0x6017, 0x0016, 0x0078, 0x6b4c,
+	0x6017, 0x0012, 0x0078, 0x6b4c, 0x7a18, 0xa280, 0x0023, 0x2014,
+	0x8210, 0xa294, 0x00ff, 0x2202, 0x8217, 0x007c, 0x0d7e, 0x2069,
+	0xa5ab, 0x6843, 0x0001, 0x0d7f, 0x007c, 0x20e1, 0x9080, 0x60a3,
+	0x0056, 0x60a7, 0x9575, 0x1078, 0x6c38, 0x1078, 0x594f, 0x007c,
+	0x007e, 0x6014, 0xa084, 0x0004, 0xa085, 0x0009, 0x6016, 0x007f,
+	0x007c, 0x007e, 0x0c7e, 0x2061, 0x0100, 0x6014, 0xa084, 0x0004,
+	0xa085, 0x0008, 0x6016, 0x0c7f, 0x007f, 0x007c, 0x0c7e, 0x0d7e,
+	0x017e, 0x027e, 0x2061, 0x0100, 0x2069, 0x0140, 0x6904, 0xa194,
+	0x4000, 0x0040, 0x6c89, 0x1078, 0x6c41, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x0c7e, 0x2061, 0xa5ab, 0x6128, 0xa192, 0x00c8, 0x00c8,
+	0x6c76, 0x8108, 0x612a, 0x6124, 0x0c7f, 0x81ff, 0x0040, 0x6c84,
+	0x1078, 0x594f, 0x1078, 0x6c38, 0x0078, 0x6c84, 0x6124, 0xa1e5,
+	0x0000, 0x0040, 0x6c81, 0x1078, 0xa241, 0x2009, 0x0014, 0x1078,
+	0x756c, 0x0c7f, 0x0078, 0x6c84, 0x027f, 0x017f, 0x0d7f, 0x0c7f,
+	0x007c, 0x2001, 0xa5c7, 0x2004, 0xa005, 0x00c0, 0x6c84, 0x0c7e,
+	0x2061, 0xa5ab, 0x6128, 0xa192, 0x0003, 0x00c8, 0x6c76, 0x8108,
+	0x612a, 0x0c7f, 0x1078, 0x594f, 0x1078, 0x4171, 0x0078, 0x6c84,
+	0x0c7e, 0x0d7e, 0x0e7e, 0x017e, 0x027e, 0x1078, 0x5967, 0x2071,
+	0xa5ab, 0x713c, 0x81ff, 0x0040, 0x6cca, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x6904, 0xa194, 0x4000, 0x0040, 0x6cd0, 0x6803, 0x1000,
+	0x6803, 0x0000, 0x037e, 0x2019, 0x0001, 0x1078, 0x6e6c, 0x037f,
+	0x713c, 0x2160, 0x1078, 0xa241, 0x2009, 0x004a, 0x1078, 0x756c,
+	0x0078, 0x6cca, 0x027f, 0x017f, 0x0e7f, 0x0d7f, 0x0c7f, 0x007c,
+	0x0078, 0x6cba, 0x0e7e, 0x0d7e, 0x0c7e, 0x067e, 0x057e, 0x047e,
+	0x007e, 0x127e, 0x2091, 0x8000, 0x6018, 0x2068, 0x6ca0, 0x2071,
+	0xa5ab, 0x7018, 0x2068, 0x8dff, 0x0040, 0x6cfc, 0x68a0, 0xa406,
+	0x0040, 0x6cee, 0x6854, 0x2068, 0x0078, 0x6ce3, 0x6010, 0x2060,
+	0x643c, 0x6540, 0x6e48, 0x2d60, 0x1078, 0x466a, 0x0040, 0x6cfc,
+	0x1078, 0x7045, 0xa085, 0x0001, 0x127f, 0x007f, 0x047f, 0x057f,
+	0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0x20a1, 0x020b, 0x1078,
+	0x6567, 0x20a3, 0x1200, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x781c,
+	0xa086, 0x0004, 0x00c0, 0x6d17, 0x6098, 0x0078, 0x6d18, 0x6030,
+	0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a9, 0x0010, 0xa006,
+	0x20a2, 0x00f0, 0x6d20, 0x20a2, 0x20a2, 0x60c3, 0x002c, 0x1078,
+	0x6c2d, 0x007c, 0x157e, 0x147e, 0x20a1, 0x020b, 0x1078, 0x6567,
+	0x20a3, 0x0f00, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808, 0x20a2,
+	0x60c3, 0x0008, 0x1078, 0x6c2d, 0x147f, 0x157f, 0x007c, 0x157e,
+	0x147e, 0x20a1, 0x020b, 0x1078, 0x65f8, 0x20a3, 0x0200, 0x20a3,
+	0x0000, 0x20a9, 0x0006, 0x2011, 0xa340, 0x2019, 0xa341, 0x23a6,
+	0x22a6, 0xa398, 0x0002, 0xa290, 0x0002, 0x00f0, 0x6d4f, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x001c, 0x1078, 0x6c2d, 0x147f,
+	0x157f, 0x007c, 0x157e, 0x147e, 0x017e, 0x027e, 0x20a1, 0x020b,
+	0x1078, 0x65cf, 0x1078, 0x65e6, 0x7810, 0xa080, 0x0000, 0x2004,
+	0xa080, 0x0015, 0x2098, 0x7808, 0xa088, 0x0002, 0x21a8, 0x53a6,
+	0xa080, 0x0004, 0x8003, 0x60c2, 0x1078, 0x6c2d, 0x027f, 0x017f,
+	0x147f, 0x157f, 0x007c, 0x157e, 0x147e, 0x20a1, 0x020b, 0x1078,
+	0x6567, 0x20a3, 0x6200, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808,
+	0x20a2, 0x60c3, 0x0008, 0x1078, 0x6c2d, 0x147f, 0x157f, 0x007c,
+	0x157e, 0x147e, 0x017e, 0x027e, 0x20a1, 0x020b, 0x1078, 0x6567,
+	0x7810, 0xa080, 0x0000, 0x2004, 0xa080, 0x0017, 0x2098, 0x7808,
+	0xa088, 0x0002, 0x21a8, 0x53a6, 0x8003, 0x60c2, 0x1078, 0x6c2d,
+	0x027f, 0x017f, 0x147f, 0x157f, 0x007c, 0x0e7e, 0x0c7e, 0x007e,
+	0x127e, 0x2091, 0x8000, 0x2071, 0xa5ab, 0x700c, 0x2060, 0x8cff,
+	0x0040, 0x6dd1, 0x1078, 0x8c3b, 0x00c0, 0x6dc8, 0x1078, 0x7a05,
+	0x600c, 0x007e, 0x1078, 0x753d, 0x1078, 0x7045, 0x0c7f, 0x0078,
+	0x6dbf, 0x700f, 0x0000, 0x700b, 0x0000, 0x127f, 0x007f, 0x0c7f,
+	0x0e7f, 0x007c, 0x127e, 0x157e, 0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e,
+	0x027e, 0x017e, 0x007e, 0x2091, 0x8000, 0x2069, 0x0100, 0x2079,
+	0x0140, 0x2071, 0xa5ab, 0x7024, 0x2060, 0x8cff, 0x0040, 0x6e2a,
+	0x1078, 0x6c41, 0x68c3, 0x0000, 0x1078, 0x595a, 0x2009, 0x0013,
+	0x1078, 0x756c, 0x20a9, 0x01f4, 0x6824, 0xd094, 0x0040, 0x6e0d,
+	0x6827, 0x0004, 0x7804, 0xa084, 0x4000, 0x0040, 0x6e1f, 0x7803,
+	0x1000, 0x7803, 0x0000, 0x0078, 0x6e1f, 0xd084, 0x0040, 0x6e14,
+	0x6827, 0x0001, 0x0078, 0x6e16, 0x00f0, 0x6dfc, 0x7804, 0xa084,
+	0x1000, 0x0040, 0x6e1f, 0x7803, 0x0100, 0x7803, 0x0000, 0x6824,
+	0x007f, 0x017f, 0x027f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x157f,
+	0x127f, 0x007c, 0x2001, 0xa300, 0x2004, 0xa096, 0x0001, 0x0040,
+	0x6e62, 0xa096, 0x0004, 0x0040, 0x6e62, 0x6817, 0x0008, 0x68c3,
+	0x0000, 0x2011, 0x4129, 0x1078, 0x58d4, 0x20a9, 0x01f4, 0x6824,
+	0xd094, 0x0040, 0x6e50, 0x6827, 0x0004, 0x7804, 0xa084, 0x4000,
+	0x0040, 0x6e62, 0x7803, 0x1000, 0x7803, 0x0000, 0x0078, 0x6e62,
+	0xd084, 0x0040, 0x6e57, 0x6827, 0x0001, 0x0078, 0x6e59, 0x00f0,
+	0x6e3f, 0x7804, 0xa084, 0x1000, 0x0040, 0x6e62, 0x7803, 0x0100,
+	0x7803, 0x0000, 0x007f, 0x017f, 0x027f, 0x0c7f, 0x0d7f, 0x0e7f,
+	0x0f7f, 0x157f, 0x127f, 0x007c, 0x127e, 0x157e, 0x0f7e, 0x0e7e,
+	0x0d7e, 0x0c7e, 0x027e, 0x017e, 0x007e, 0x2091, 0x8000, 0x2069,
+	0x0100, 0x2079, 0x0140, 0x2071, 0xa5ab, 0x703c, 0x2060, 0x8cff,
+	0x0040, 0x6ee8, 0x6817, 0x0010, 0x2009, 0x00fa, 0x8109, 0x00c0,
+	0x6e86, 0x68c7, 0x0000, 0x68cb, 0x0008, 0x1078, 0x5967, 0x1078,
+	0x1f31, 0x047e, 0x057e, 0x2009, 0x017f, 0x212c, 0x200b, 0x00a5,
+	0x2021, 0x0169, 0x2404, 0xa084, 0x000f, 0xa086, 0x0004, 0x00c0,
+	0x6eb7, 0x68c7, 0x0000, 0x68cb, 0x0008, 0x0e7e, 0x0f7e, 0x2079,
+	0x0020, 0x2071, 0xa602, 0x6814, 0xa084, 0x0004, 0xa085, 0x0012,
+	0x6816, 0x7803, 0x0008, 0x7003, 0x0000, 0x0f7f, 0x0e7f, 0x250a,
+	0x057f, 0x047f, 0xa39d, 0x0000, 0x00c0, 0x6ec2, 0x2009, 0x0049,
+	0x1078, 0x756c, 0x20a9, 0x03e8, 0x6824, 0xd094, 0x0040, 0x6ed5,
+	0x6827, 0x0004, 0x7804, 0xa084, 0x4000, 0x0040, 0x6ee7, 0x7803,
+	0x1000, 0x7803, 0x0000, 0x0078, 0x6ee7, 0xd08c, 0x0040, 0x6edc,
+	0x6827, 0x0002, 0x0078, 0x6ede, 0x00f0, 0x6ec4, 0x7804, 0xa084,
+	0x1000, 0x0040, 0x6ee7, 0x7803, 0x0100, 0x7803, 0x0000, 0x6824,
+	0x007f, 0x017f, 0x027f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x157f,
+	0x127f, 0x007c, 0x0d7e, 0x127e, 0x2091, 0x8000, 0x2069, 0xa5ab,
+	0x6a06, 0x127f, 0x0d7f, 0x007c, 0x0d7e, 0x127e, 0x2091, 0x8000,
+	0x2069, 0xa5ab, 0x6a32, 0x127f, 0x0d7f, 0x007c, 0x0f7e, 0x0e7e,
+	0x0c7e, 0x067e, 0x007e, 0x127e, 0x2071, 0xa5ab, 0x7614, 0x2660,
+	0x2678, 0x2091, 0x8000, 0x8cff, 0x0040, 0x6f46, 0x601c, 0xa206,
+	0x00c0, 0x6f41, 0x7014, 0xac36, 0x00c0, 0x6f20, 0x660c, 0x7616,
+	0x7010, 0xac36, 0x00c0, 0x6f2e, 0x2c00, 0xaf36, 0x0040, 0x6f2c,
+	0x2f00, 0x7012, 0x0078, 0x6f2e, 0x7013, 0x0000, 0x660c, 0x067e,
+	0x2c00, 0xaf06, 0x0040, 0x6f37, 0x7e0e, 0x0078, 0x6f38, 0x2678,
+	0x600f, 0x0000, 0x1078, 0x8c01, 0x1078, 0x7045, 0x0c7f, 0x0078,
+	0x6f13, 0x2c78, 0x600c, 0x2060, 0x0078, 0x6f13, 0x127f, 0x007f,
+	0x067f, 0x0c7f, 0x0e7f, 0x0f7f, 0x007c, 0x157e, 0x147e, 0x20a1,
+	0x020b, 0x1078, 0x6806, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2,
+	0x20a2, 0x20a2, 0x20a3, 0x1000, 0x0078, 0x6fa0, 0x157e, 0x147e,
+	0x20a1, 0x020b, 0x1078, 0x6806, 0x7810, 0x20a2, 0xa006, 0x20a2,
+	0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x4000, 0x0078, 0x6fa0, 0x157e,
+	0x147e, 0x20a1, 0x020b, 0x1078, 0x6806, 0x7810, 0x20a2, 0xa006,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x2000, 0x0078, 0x6fa0,
+	0x157e, 0x147e, 0x20a1, 0x020b, 0x1078, 0x6806, 0x7810, 0x20a2,
+	0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x0400, 0x0078,
+	0x6fa0, 0x157e, 0x147e, 0x20a1, 0x020b, 0x1078, 0x6806, 0x7810,
+	0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x0200,
+	0x1078, 0x7050, 0x60c3, 0x0020, 0x1078, 0x6c2d, 0x147f, 0x157f,
+	0x007c, 0x127e, 0x0c7e, 0x2091, 0x8000, 0x2061, 0x0100, 0x6120,
+	0xd1b4, 0x00c0, 0x6fb8, 0xd1bc, 0x00c0, 0x7002, 0x0078, 0x7042,
+	0x2009, 0x017f, 0x200b, 0x00a1, 0x157e, 0x007e, 0x0d7e, 0x2069,
+	0x0140, 0x20a9, 0x001e, 0x2009, 0x0169, 0x6804, 0xa084, 0x4000,
+	0x0040, 0x6ff9, 0x6020, 0xd0b4, 0x0040, 0x6ff9, 0x6024, 0xd094,
+	0x00c0, 0x6ff9, 0x2104, 0xa084, 0x000f, 0xa086, 0x0004, 0x00c0,
+	0x6ff9, 0x00f0, 0x6fc5, 0x027e, 0x6198, 0xa18c, 0x00ff, 0x8107,
+	0x6130, 0xa18c, 0x00ff, 0xa10d, 0x6088, 0x628c, 0x618e, 0x608b,
+	0xbc91, 0x6043, 0x0001, 0x6043, 0x0000, 0x608a, 0x628e, 0x6024,
+	0xd094, 0x00c0, 0x6ff8, 0x6a04, 0xa294, 0x4000, 0x00c0, 0x6fef,
+	0x027f, 0x0d7f, 0x007f, 0x157f, 0x2009, 0x017f, 0x200b, 0x0000,
+	0x0078, 0x7042, 0x2009, 0x017f, 0x200b, 0x00a1, 0x157e, 0x007e,
+	0x0d7e, 0x2069, 0x0140, 0x20a9, 0x001e, 0x2009, 0x0169, 0x6804,
+	0xa084, 0x4000, 0x0040, 0x703b, 0x6020, 0xd0bc, 0x0040, 0x703b,
+	0x2104, 0xa084, 0x000f, 0xa086, 0x0004, 0x00c0, 0x703b, 0x00f0,
+	0x700f, 0x027e, 0x6164, 0xa18c, 0x00ff, 0x8107, 0x6130, 0xa18c,
+	0x00ff, 0xa10d, 0x6088, 0x628c, 0x608b, 0xbc91, 0x618e, 0x6043,
+	0x0001, 0x6043, 0x0000, 0x608a, 0x628e, 0x6a04, 0xa294, 0x4000,
+	0x00c0, 0x7035, 0x027f, 0x0d7f, 0x007f, 0x157f, 0x2009, 0x017f,
+	0x200b, 0x0000, 0x0c7f, 0x127f, 0x007c, 0x0e7e, 0x2071, 0xa5ab,
+	0x7020, 0xa005, 0x0040, 0x704e, 0x8001, 0x7022, 0x0e7f, 0x007c,
+	0x20a9, 0x0008, 0x20a2, 0x00f0, 0x7052, 0x20a2, 0x20a2, 0x007c,
+	0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x077e, 0x067e, 0x007e, 0x127e,
+	0x2091, 0x8000, 0x2071, 0xa5ab, 0x7614, 0x2660, 0x2678, 0x2039,
+	0x0001, 0x87ff, 0x0040, 0x70f4, 0x8cff, 0x0040, 0x70f4, 0x601c,
+	0xa086, 0x0006, 0x00c0, 0x70ef, 0x88ff, 0x0040, 0x707f, 0x2800,
+	0xac06, 0x00c0, 0x70ef, 0x2039, 0x0000, 0x0078, 0x708a, 0x6018,
+	0xa206, 0x00c0, 0x70ef, 0x85ff, 0x0040, 0x708a, 0x6020, 0xa106,
+	0x00c0, 0x70ef, 0x7024, 0xac06, 0x00c0, 0x70ba, 0x2069, 0x0100,
+	0x68c0, 0xa005, 0x0040, 0x70b5, 0x1078, 0x595a, 0x6817, 0x0008,
+	0x68c3, 0x0000, 0x1078, 0x7188, 0x7027, 0x0000, 0x037e, 0x2069,
+	0x0140, 0x6b04, 0xa384, 0x1000, 0x0040, 0x70aa, 0x6803, 0x0100,
+	0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0040, 0x70b2,
+	0x6827, 0x0001, 0x037f, 0x0078, 0x70ba, 0x6003, 0x0009, 0x630a,
+	0x0078, 0x70ef, 0x7014, 0xac36, 0x00c0, 0x70c0, 0x660c, 0x7616,
+	0x7010, 0xac36, 0x00c0, 0x70ce, 0x2c00, 0xaf36, 0x0040, 0x70cc,
+	0x2f00, 0x7012, 0x0078, 0x70ce, 0x7013, 0x0000, 0x660c, 0x067e,
+	0x2c00, 0xaf06, 0x0040, 0x70d7, 0x7e0e, 0x0078, 0x70d8, 0x2678,
+	0x89ff, 0x00c0, 0x70e7, 0x600f, 0x0000, 0x6010, 0x2068, 0x1078,
+	0x8a44, 0x0040, 0x70e5, 0x1078, 0x9e70, 0x1078, 0x8c01, 0x1078,
+	0x7045, 0x88ff, 0x00c0, 0x70fe, 0x0c7f, 0x0078, 0x7069, 0x2c78,
+	0x600c, 0x2060, 0x0078, 0x7069, 0xa006, 0x127f, 0x007f, 0x067f,
+	0x077f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x6017, 0x0000,
+	0x0c7f, 0xa8c5, 0x0001, 0x0078, 0x70f5, 0x0f7e, 0x0e7e, 0x0d7e,
+	0x0c7e, 0x067e, 0x027e, 0x007e, 0x127e, 0x2091, 0x8000, 0x2071,
+	0xa5ab, 0x7638, 0x2660, 0x2678, 0x8cff, 0x0040, 0x7177, 0x601c,
+	0xa086, 0x0006, 0x00c0, 0x7172, 0x87ff, 0x0040, 0x7125, 0x2700,
+	0xac06, 0x00c0, 0x7172, 0x0078, 0x7130, 0x6018, 0xa206, 0x00c0,
+	0x7172, 0x85ff, 0x0040, 0x7130, 0x6020, 0xa106, 0x00c0, 0x7172,
+	0x703c, 0xac06, 0x00c0, 0x7142, 0x037e, 0x2019, 0x0001, 0x1078,
+	0x6e6c, 0x7033, 0x0000, 0x703f, 0x0000, 0x7043, 0x0000, 0x7047,
+	0x0000, 0x037f, 0x7038, 0xac36, 0x00c0, 0x7148, 0x660c, 0x763a,
+	0x7034, 0xac36, 0x00c0, 0x7156, 0x2c00, 0xaf36, 0x0040, 0x7154,
+	0x2f00, 0x7036, 0x0078, 0x7156, 0x7037, 0x0000, 0x660c, 0x067e,
+	0x2c00, 0xaf06, 0x0040, 0x715f, 0x7e0e, 0x0078, 0x7160, 0x2678,
+	0x600f, 0x0000, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040, 0x716a,
+	0x1078, 0x9e70, 0x1078, 0x8c01, 0x87ff, 0x00c0, 0x7181, 0x0c7f,
+	0x0078, 0x7114, 0x2c78, 0x600c, 0x2060, 0x0078, 0x7114, 0xa006,
+	0x127f, 0x007f, 0x027f, 0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f,
+	0x007c, 0x6017, 0x0000, 0x0c7f, 0xa7bd, 0x0001, 0x0078, 0x7178,
+	0x0e7e, 0x2071, 0xa5ab, 0x2001, 0xa300, 0x2004, 0xa086, 0x0002,
+	0x00c0, 0x7196, 0x7007, 0x0005, 0x0078, 0x7198, 0x7007, 0x0000,
+	0x0e7f, 0x007c, 0x0f7e, 0x0e7e, 0x0c7e, 0x067e, 0x027e, 0x007e,
+	0x127e, 0x2091, 0x8000, 0x2071, 0xa5ab, 0x2c10, 0x7638, 0x2660,
+	0x2678, 0x8cff, 0x0040, 0x71d8, 0x2200, 0xac06, 0x00c0, 0x71d3,
+	0x7038, 0xac36, 0x00c0, 0x71b6, 0x660c, 0x763a, 0x7034, 0xac36,
+	0x00c0, 0x71c4, 0x2c00, 0xaf36, 0x0040, 0x71c2, 0x2f00, 0x7036,
+	0x0078, 0x71c4, 0x7037, 0x0000, 0x660c, 0x2c00, 0xaf06, 0x0040,
+	0x71cc, 0x7e0e, 0x0078, 0x71cd, 0x2678, 0x600f, 0x0000, 0xa085,
+	0x0001, 0x0078, 0x71d8, 0x2c78, 0x600c, 0x2060, 0x0078, 0x71a9,
+	0x127f, 0x007f, 0x027f, 0x067f, 0x0c7f, 0x0e7f, 0x0f7f, 0x007c,
+	0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x067e, 0x007e, 0x127e, 0x2091,
+	0x8000, 0x2071, 0xa5ab, 0x760c, 0x2660, 0x2678, 0x8cff, 0x0040,
+	0x7279, 0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x00c0, 0x7274,
+	0x7024, 0xac06, 0x00c0, 0x721f, 0x2069, 0x0100, 0x68c0, 0xa005,
+	0x0040, 0x724d, 0x1078, 0x6c41, 0x68c3, 0x0000, 0x1078, 0x7188,
+	0x7027, 0x0000, 0x037e, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000,
+	0x0040, 0x7216, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100,
+	0x6824, 0xd084, 0x0040, 0x721e, 0x6827, 0x0001, 0x037f, 0x700c,
+	0xac36, 0x00c0, 0x7225, 0x660c, 0x760e, 0x7008, 0xac36, 0x00c0,
+	0x7233, 0x2c00, 0xaf36, 0x0040, 0x7231, 0x2f00, 0x700a, 0x0078,
+	0x7233, 0x700b, 0x0000, 0x660c, 0x067e, 0x2c00, 0xaf06, 0x0040,
+	0x723c, 0x7e0e, 0x0078, 0x723d, 0x2678, 0x600f, 0x0000, 0x1078,
+	0x8c27, 0x00c0, 0x7251, 0x1078, 0x2839, 0x1078, 0x8c3b, 0x00c0,
+	0x726d, 0x1078, 0x7a05, 0x0078, 0x726d, 0x1078, 0x7188, 0x0078,
+	0x721f, 0x1078, 0x8c3b, 0x00c0, 0x7259, 0x1078, 0x7a05, 0x0078,
+	0x726d, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040, 0x726d, 0x601c,
+	0xa086, 0x0003, 0x00c0, 0x7281, 0x6837, 0x0103, 0x6b4a, 0x6847,
+	0x0000, 0x1078, 0x4982, 0x1078, 0x8bf4, 0x1078, 0x8c01, 0x1078,
+	0x7045, 0x0c7f, 0x0078, 0x71ee, 0x2c78, 0x600c, 0x2060, 0x0078,
+	0x71ee, 0x127f, 0x007f, 0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f,
+	0x007c, 0x601c, 0xa086, 0x0006, 0x00c0, 0x726d, 0x1078, 0x9e70,
+	0x0078, 0x726d, 0x037e, 0x157e, 0x137e, 0x147e, 0x3908, 0xa006,
+	0xa190, 0x0020, 0x221c, 0xa39e, 0x260c, 0x00c0, 0x729b, 0x8210,
+	0x8000, 0x0078, 0x7292, 0xa005, 0x0040, 0x72a7, 0x20a9, 0x0020,
+	0x2198, 0x8211, 0xa282, 0x0020, 0x20c8, 0x20a0, 0x53a3, 0x147f,
+	0x137f, 0x157f, 0x037f, 0x007c, 0x0d7e, 0x20a1, 0x020b, 0x1078,
+	0x65f8, 0x20a3, 0x0200, 0x20a3, 0x0014, 0x60c3, 0x0014, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x2099, 0xa5a3, 0x20a9, 0x0004, 0x53a6,
+	0x20a3, 0x0004, 0x20a3, 0x7878, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x1078, 0x6c2d, 0x0d7f, 0x007c, 0x20a1, 0x020b, 0x1078, 0x65f8,
+	0x20a3, 0x0214, 0x20a3, 0x0018, 0x20a3, 0x0800, 0x7810, 0xa084,
+	0xff00, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x7810, 0xa084, 0x00ff, 0x20a2, 0x7828, 0x20a2,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0018, 0x1078, 0x6c2d,
+	0x007c, 0x0d7e, 0x017e, 0x2f68, 0x2009, 0x0035, 0x1078, 0x8ef5,
+	0x00c0, 0x7361, 0x20a1, 0x020b, 0x1078, 0x6567, 0x20a3, 0x1300,
+	0x20a3, 0x0000, 0x7828, 0x2068, 0x681c, 0xa086, 0x0003, 0x0040,
+	0x733d, 0x7818, 0xa080, 0x0028, 0x2014, 0xa286, 0x007e, 0x00c0,
+	0x7317, 0x20a3, 0x00ff, 0x20a3, 0xfffe, 0x0078, 0x7352, 0xa286,
+	0x007f, 0x00c0, 0x7321, 0x20a3, 0x00ff, 0x20a3, 0xfffd, 0x0078,
+	0x7352, 0xd2bc, 0x0040, 0x7337, 0xa286, 0x0080, 0x00c0, 0x732e,
+	0x20a3, 0x00ff, 0x20a3, 0xfffc, 0x0078, 0x7352, 0xa2e8, 0xa434,
+	0x2d6c, 0x6810, 0x20a2, 0x6814, 0x20a2, 0x0078, 0x7352, 0x20a3,
+	0x0000, 0x6098, 0x20a2, 0x0078, 0x7352, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa082, 0x007e, 0x0048, 0x734e, 0x0d7e, 0x2069, 0xa31a,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x7352, 0x20a3, 0x0000,
+	0x6030, 0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x000c, 0x1078, 0x6c2d, 0x017f, 0x0d7f,
+	0x007c, 0x7817, 0x0001, 0x7803, 0x0006, 0x017f, 0x0d7f, 0x007c,
+	0x0d7e, 0x027e, 0x7928, 0x2168, 0x691c, 0xa186, 0x0006, 0x0040,
+	0x738a, 0xa186, 0x0003, 0x0040, 0x73e5, 0xa186, 0x0005, 0x0040,
+	0x73c8, 0xa186, 0x0004, 0x0040, 0x73b8, 0xa186, 0x0008, 0x0040,
+	0x73d2, 0x7807, 0x0037, 0x7813, 0x1700, 0x1078, 0x7450, 0x027f,
+	0x0d7f, 0x007c, 0x1078, 0x740d, 0x2009, 0x4000, 0x6800, 0x0079,
+	0x7391, 0x73a4, 0x73b2, 0x73a6, 0x73b2, 0x73ad, 0x73a4, 0x73a4,
+	0x73b2, 0x73b2, 0x73b2, 0x73b2, 0x73a4, 0x73a4, 0x73a4, 0x73a4,
+	0x73a4, 0x73b2, 0x73a4, 0x73b2, 0x1078, 0x1328, 0x6824, 0xd0e4,
+	0x0040, 0x73ad, 0xd0cc, 0x0040, 0x73b0, 0xa00e, 0x0078, 0x73b2,
+	0x2009, 0x2000, 0x6828, 0x20a2, 0x682c, 0x20a2, 0x0078, 0x7403,
+	0x1078, 0x740d, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000,
+	0x6a00, 0xa286, 0x0002, 0x00c0, 0x73c6, 0xa00e, 0x0078, 0x7403,
+	0x1078, 0x740d, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000,
+	0x0078, 0x7403, 0x1078, 0x740d, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x2009, 0x4000, 0xa286, 0x0005, 0x0040, 0x73e2, 0xa286, 0x0002,
+	0x00c0, 0x73e3, 0xa00e, 0x0078, 0x7403, 0x1078, 0x740d, 0x6810,
+	0x2068, 0x697c, 0x6810, 0xa112, 0x6980, 0x6814, 0xa103, 0x20a2,
+	0x22a2, 0x7928, 0xa180, 0x0000, 0x2004, 0xa08e, 0x0002, 0x0040,
+	0x7401, 0xa08e, 0x0004, 0x0040, 0x7401, 0x2009, 0x4000, 0x0078,
+	0x7403, 0x2009, 0x0000, 0x21a2, 0x20a3, 0x0000, 0x60c3, 0x0018,
+	0x1078, 0x6c2d, 0x027f, 0x0d7f, 0x007c, 0x037e, 0x047e, 0x057e,
+	0x067e, 0x20a1, 0x020b, 0x1078, 0x65f8, 0xa006, 0x20a3, 0x0200,
+	0x20a2, 0x7934, 0x21a2, 0x7938, 0x21a2, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa092, 0x007e, 0x0048, 0x7433, 0x0d7e, 0x2069, 0xa31a,
+	0x2d2c, 0x8d68, 0x2d34, 0xa0e8, 0xa434, 0x2d6c, 0x6b10, 0x6c14,
+	0x0d7f, 0x0078, 0x7439, 0x2019, 0x0000, 0x6498, 0x2029, 0x0000,
+	0x6630, 0x7828, 0xa080, 0x0007, 0x2004, 0xa086, 0x0003, 0x00c0,
+	0x7447, 0x25a2, 0x26a2, 0x23a2, 0x24a2, 0x0078, 0x744b, 0x23a2,
+	0x24a2, 0x25a2, 0x26a2, 0x067f, 0x057f, 0x047f, 0x037f, 0x007c,
+	0x20a1, 0x020b, 0x1078, 0x65f8, 0x20a3, 0x0100, 0x20a3, 0x0000,
+	0x20a3, 0x0009, 0x7810, 0x20a2, 0x60c3, 0x0008, 0x1078, 0x6c2d,
+	0x007c, 0x20a1, 0x020b, 0x1078, 0x655e, 0x20a3, 0x1400, 0x20a3,
+	0x0000, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x7828, 0x20a2, 0x782c,
+	0x20a2, 0x7830, 0xa084, 0x00ff, 0x8007, 0x20a2, 0x20a3, 0x0000,
+	0x60c3, 0x0010, 0x1078, 0x6c2d, 0x007c, 0x20a1, 0x020b, 0x1078,
+	0x65ef, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x7828, 0x20a2, 0x7810,
+	0x20a2, 0x60c3, 0x0008, 0x1078, 0x6c2d, 0x007c, 0x147e, 0x20a1,
+	0x020b, 0x1078, 0x7499, 0x60c3, 0x0000, 0x1078, 0x6c2d, 0x147f,
+	0x007c, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xd0bc, 0x0040, 0x74b6, 0x0d7e, 0xa0e8, 0xa434, 0x2d6c,
+	0x6810, 0xa085, 0x0300, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa31a,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x74be, 0x20a3, 0x0300,
+	0x6298, 0x22a2, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x20a3, 0x0819,
+	0x20a3, 0x0000, 0x1078, 0x6c1c, 0x22a2, 0x20a3, 0x0000, 0x2fa2,
+	0x7a08, 0x22a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x007c, 0x2061,
+	0xaa00, 0x2a70, 0x7060, 0x7046, 0x704b, 0xaa00, 0x007c, 0x0e7e,
+	0x127e, 0x2071, 0xa300, 0x2091, 0x8000, 0x7544, 0xa582, 0x0010,
+	0x0048, 0x7509, 0x7048, 0x2060, 0x6000, 0xa086, 0x0000, 0x0040,
+	0x74f5, 0xace0, 0x0010, 0x7054, 0xac02, 0x00c8, 0x74f1, 0x0078,
+	0x74e4, 0x2061, 0xaa00, 0x0078, 0x74e4, 0x6003, 0x0008, 0x8529,
+	0x7546, 0xaca8, 0x0010, 0x7054, 0xa502, 0x00c8, 0x7505, 0x754a,
+	0xa085, 0x0001, 0x127f, 0x0e7f, 0x007c, 0x704b, 0xaa00, 0x0078,
+	0x7500, 0xa006, 0x0078, 0x7502, 0x0e7e, 0x2071, 0xa300, 0x7544,
+	0xa582, 0x0010, 0x0048, 0x753a, 0x7048, 0x2060, 0x6000, 0xa086,
+	0x0000, 0x0040, 0x7527, 0xace0, 0x0010, 0x7054, 0xac02, 0x00c8,
+	0x7523, 0x0078, 0x7516, 0x2061, 0xaa00, 0x0078, 0x7516, 0x6003,
+	0x0008, 0x8529, 0x7546, 0xaca8, 0x0010, 0x7054, 0xa502, 0x00c8,
+	0x7536, 0x754a, 0xa085, 0x0001, 0x0e7f, 0x007c, 0x704b, 0xaa00,
+	0x0078, 0x7532, 0xa006, 0x0078, 0x7534, 0xac82, 0xaa00, 0x1048,
+	0x1328, 0x2001, 0xa315, 0x2004, 0xac02, 0x10c8, 0x1328, 0xa006,
+	0x6006, 0x600a, 0x600e, 0x6012, 0x6016, 0x601a, 0x601f, 0x0000,
+	0x6003, 0x0000, 0x6022, 0x6026, 0x602a, 0x602e, 0x6032, 0x6036,
+	0x603a, 0x603e, 0x2061, 0xa300, 0x6044, 0x8000, 0x6046, 0xa086,
+	0x0001, 0x0040, 0x7564, 0x007c, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x6109, 0x127f, 0x0078, 0x7563, 0x601c, 0xa084, 0x000f, 0x0079,
+	0x7571, 0x757a, 0x758b, 0x75a7, 0x75c3, 0x8f2d, 0x8f49, 0x8f65,
+	0x757a, 0x758b, 0xa186, 0x0013, 0x00c0, 0x7583, 0x1078, 0x6010,
+	0x1078, 0x6109, 0x007c, 0xa18e, 0x0047, 0x00c0, 0x758a, 0xa016,
+	0x1078, 0x15ec, 0x007c, 0x067e, 0x6000, 0xa0b2, 0x0010, 0x10c8,
+	0x1328, 0x1079, 0x7595, 0x067f, 0x007c, 0x75a5, 0x7891, 0x7a34,
+	0x75a5, 0x7ab8, 0x75df, 0x75a5, 0x75a5, 0x7823, 0x7e6d, 0x75a5,
+	0x75a5, 0x75a5, 0x75a5, 0x75a5, 0x75a5, 0x1078, 0x1328, 0x067e,
+	0x6000, 0xa0b2, 0x0010, 0x10c8, 0x1328, 0x1079, 0x75b1, 0x067f,
+	0x007c, 0x75c1, 0x8522, 0x75c1, 0x75c1, 0x75c1, 0x75c1, 0x75c1,
+	0x75c1, 0x84c5, 0x86a8, 0x75c1, 0x8552, 0x85d8, 0x8552, 0x85d8,
+	0x75c1, 0x1078, 0x1328, 0x067e, 0x6000, 0xa0b2, 0x0010, 0x10c8,
+	0x1328, 0x1079, 0x75cd, 0x067f, 0x007c, 0x75dd, 0x7eb4, 0x7f81,
+	0x80c6, 0x8242, 0x75dd, 0x75dd, 0x75dd, 0x7e8d, 0x846d, 0x8471,
+	0x75dd, 0x75dd, 0x75dd, 0x75dd, 0x84a1, 0x1078, 0x1328, 0xa1b6,
+	0x0015, 0x00c0, 0x75e7, 0x1078, 0x753d, 0x0078, 0x75ed, 0xa1b6,
+	0x0016, 0x10c0, 0x1328, 0x1078, 0x753d, 0x007c, 0x20a9, 0x000e,
+	0x2e98, 0x6010, 0x20a0, 0x53a3, 0x20a9, 0x0006, 0x3310, 0x3420,
+	0x9398, 0x94a0, 0x3318, 0x3428, 0x222e, 0x2326, 0xa290, 0x0002,
+	0xa5a8, 0x0002, 0xa398, 0x0002, 0xa4a0, 0x0002, 0x00f0, 0x75fc,
+	0x0e7e, 0x1078, 0x8a44, 0x0040, 0x7613, 0x6010, 0x2070, 0x7007,
+	0x0000, 0x7037, 0x0103, 0x0e7f, 0x1078, 0x753d, 0x007c, 0x0d7e,
+	0x037e, 0x7330, 0xa386, 0x0200, 0x00c0, 0x7624, 0x6018, 0x2068,
+	0x6813, 0x00ff, 0x6817, 0xfffd, 0x6010, 0xa005, 0x0040, 0x762e,
+	0x2068, 0x6807, 0x0000, 0x6837, 0x0103, 0x6b32, 0x1078, 0x753d,
+	0x037f, 0x0d7f, 0x007c, 0x017e, 0x20a9, 0x002a, 0xae80, 0x000c,
+	0x2098, 0x6010, 0xa080, 0x0002, 0x20a0, 0x53a3, 0x20a9, 0x002a,
+	0x6010, 0xa080, 0x0001, 0x2004, 0xa080, 0x0002, 0x20a0, 0x53a3,
+	0x0e7e, 0x6010, 0x2004, 0x2070, 0x7037, 0x0103, 0x0e7f, 0x1078,
+	0x753d, 0x017f, 0x007c, 0x0e7e, 0x0d7e, 0x603f, 0x0000, 0x2c68,
+	0x017e, 0x2009, 0x0035, 0x1078, 0x8ef5, 0x017f, 0x00c0, 0x766f,
+	0x027e, 0x6228, 0x2268, 0x027f, 0x2071, 0xa88c, 0x6b1c, 0xa386,
+	0x0003, 0x0040, 0x7673, 0xa386, 0x0006, 0x0040, 0x7677, 0x1078,
+	0x753d, 0x0078, 0x7679, 0x1078, 0x767c, 0x0078, 0x7679, 0x1078,
+	0x771e, 0x0d7f, 0x0e7f, 0x007c, 0x0f7e, 0x6810, 0x2078, 0xa186,
+	0x0015, 0x0040, 0x7705, 0xa18e, 0x0016, 0x00c0, 0x771c, 0x700c,
+	0xa084, 0xff00, 0xa086, 0x1700, 0x00c0, 0x76e0, 0x8fff, 0x0040,
+	0x771a, 0x6808, 0xa086, 0xffff, 0x00c0, 0x7709, 0x784c, 0xa084,
+	0x0060, 0xa086, 0x0020, 0x00c0, 0x76a7, 0x797c, 0x7810, 0xa106,
+	0x00c0, 0x7709, 0x7980, 0x7814, 0xa106, 0x00c0, 0x7709, 0x1078,
+	0x8bf4, 0x6830, 0x7852, 0x784c, 0xc0dc, 0xc0f4, 0xc0d4, 0x784e,
+	0x027e, 0xa00e, 0x6a14, 0x2001, 0x000a, 0x1078, 0x5a98, 0x7854,
+	0xa20a, 0x0048, 0x76bc, 0x8011, 0x7a56, 0x82ff, 0x027f, 0x00c0,
+	0x76c8, 0x0c7e, 0x2d60, 0x1078, 0x8832, 0x0c7f, 0x0078, 0x771a,
+	0x0c7e, 0x0d7e, 0x2f68, 0x6838, 0xd0fc, 0x00c0, 0x76d3, 0x1078,
+	0x4290, 0x0078, 0x76d5, 0x1078, 0x436e, 0x0d7f, 0x0c7f, 0x00c0,
+	0x7709, 0x0c7e, 0x2d60, 0x1078, 0x753d, 0x0c7f, 0x0078, 0x771a,
+	0x7008, 0xa086, 0x000b, 0x00c0, 0x76fa, 0x6018, 0x200c, 0xc1bc,
+	0x2102, 0x0c7e, 0x2d60, 0x7853, 0x0003, 0x6007, 0x0085, 0x6003,
+	0x000b, 0x601f, 0x0002, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x0c7f,
+	0x0078, 0x771a, 0x700c, 0xa086, 0x2a00, 0x00c0, 0x7709, 0x2001,
+	0xa5a2, 0x2004, 0x683e, 0x0078, 0x771a, 0x1078, 0x7739, 0x0078,
+	0x771c, 0x8fff, 0x1040, 0x1328, 0x0c7e, 0x0d7e, 0x2d60, 0x2f68,
+	0x684b, 0x0003, 0x1078, 0x8726, 0x1078, 0x8bf4, 0x1078, 0x8c01,
+	0x0d7f, 0x0c7f, 0x1078, 0x753d, 0x0f7f, 0x007c, 0xa186, 0x0015,
+	0x00c0, 0x7728, 0x2001, 0xa5a2, 0x2004, 0x683e, 0x0078, 0x7736,
+	0xa18e, 0x0016, 0x00c0, 0x7738, 0x0c7e, 0x2d00, 0x2060, 0x1078,
+	0xa134, 0x1078, 0x5a41, 0x1078, 0x753d, 0x0c7f, 0x1078, 0x753d,
+	0x007c, 0x027e, 0x037e, 0x047e, 0x7228, 0x7c80, 0x7b7c, 0xd2f4,
+	0x0040, 0x7748, 0x2001, 0xa5a2, 0x2004, 0x683e, 0x0078, 0x77ac,
+	0x0c7e, 0x2d60, 0x1078, 0x874a, 0x0c7f, 0x6804, 0xa086, 0x0050,
+	0x00c0, 0x7760, 0x0c7e, 0x2d00, 0x2060, 0x6003, 0x0001, 0x6007,
+	0x0050, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x0c7f, 0x0078, 0x77ac,
+	0x6800, 0xa086, 0x000f, 0x0040, 0x7782, 0x8fff, 0x1040, 0x1328,
+	0x6824, 0xd0dc, 0x00c0, 0x7782, 0x6800, 0xa086, 0x0004, 0x00c0,
+	0x7787, 0x784c, 0xd0ac, 0x0040, 0x7787, 0x784c, 0xc0dc, 0xc0f4,
+	0x784e, 0x7850, 0xc0f4, 0xc0fc, 0x7852, 0x2001, 0x0001, 0x682e,
+	0x0078, 0x77a6, 0x2001, 0x0007, 0x682e, 0x0078, 0x77a6, 0x784c,
+	0xd0b4, 0x00c0, 0x7794, 0xd0ac, 0x0040, 0x7782, 0x784c, 0xd0f4,
+	0x00c0, 0x7782, 0x0078, 0x7775, 0xd2ec, 0x00c0, 0x7782, 0x7024,
+	0xa306, 0x00c0, 0x779f, 0x7020, 0xa406, 0x0040, 0x7782, 0x7020,
+	0x6836, 0x7024, 0x683a, 0x2001, 0x0005, 0x682e, 0x1078, 0x8d2b,
+	0x1078, 0x6109, 0x0078, 0x77ae, 0x1078, 0x753d, 0x047f, 0x037f,
+	0x027f, 0x007c, 0x0e7e, 0x0d7e, 0x027e, 0x6034, 0x2068, 0x6a1c,
+	0xa286, 0x0007, 0x0040, 0x7806, 0xa286, 0x0002, 0x0040, 0x7806,
+	0xa286, 0x0000, 0x0040, 0x7806, 0x6808, 0x6338, 0xa306, 0x00c0,
+	0x7806, 0x2071, 0xa88c, 0xa186, 0x0015, 0x0040, 0x7800, 0xa18e,
+	0x0016, 0x00c0, 0x77e8, 0x6030, 0xa084, 0x00ff, 0xa086, 0x0001,
+	0x00c0, 0x77e8, 0x700c, 0xa086, 0x2a00, 0x00c0, 0x77e8, 0x6034,
+	0xa080, 0x0009, 0x200c, 0xc1dd, 0xc1f5, 0x2102, 0x0078, 0x7800,
+	0x0c7e, 0x6034, 0x2060, 0x6010, 0x2068, 0x1078, 0x8a44, 0x1040,
+	0x1328, 0x6853, 0x0003, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f,
+	0x0002, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x0c7f, 0x0078, 0x7806,
+	0x6034, 0x2068, 0x2001, 0xa5a2, 0x2004, 0x683e, 0x1078, 0x753d,
+	0x027f, 0x0d7f, 0x0e7f, 0x007c, 0x0d7e, 0x20a9, 0x000e, 0x2e98,
+	0x6010, 0x20a0, 0x53a3, 0xa1b6, 0x0015, 0x00c0, 0x7820, 0x6018,
+	0x2068, 0x7038, 0x680a, 0x703c, 0x680e, 0x6800, 0xc08d, 0x6802,
+	0x0d7f, 0x0078, 0x7608, 0x2100, 0xa1b2, 0x0044, 0x10c8, 0x1328,
+	0xa1b2, 0x0040, 0x00c8, 0x7888, 0x0079, 0x782e, 0x787c, 0x7870,
+	0x787c, 0x787c, 0x787c, 0x787c, 0x786e, 0x786e, 0x786e, 0x786e,
+	0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e,
+	0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e,
+	0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x787c, 0x786e, 0x787c,
+	0x787c, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x787c, 0x786e,
+	0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e,
+	0x787c, 0x787c, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e, 0x786e,
+	0x786e, 0x786e, 0x786e, 0x787c, 0x786e, 0x786e, 0x1078, 0x1328,
+	0x6003, 0x0001, 0x6106, 0x1078, 0x5c45, 0x127e, 0x2091, 0x8000,
+	0x1078, 0x6109, 0x127f, 0x007c, 0x6003, 0x0001, 0x6106, 0x1078,
+	0x5c45, 0x127e, 0x2091, 0x8000, 0x1078, 0x6109, 0x127f, 0x007c,
+	0x2600, 0x0079, 0x788b, 0x788f, 0x788f, 0x788f, 0x787c, 0x1078,
+	0x1328, 0x6004, 0xa0b2, 0x0044, 0x10c8, 0x1328, 0xa1b6, 0x0013,
+	0x00c0, 0x78a1, 0xa0b2, 0x0040, 0x00c8, 0x79fb, 0x2008, 0x0079,
+	0x7941, 0xa1b6, 0x0027, 0x00c0, 0x78fe, 0x1078, 0x6010, 0x6004,
+	0x1078, 0x8c27, 0x0040, 0x78be, 0x1078, 0x8c3b, 0x0040, 0x78f6,
+	0xa08e, 0x0021, 0x0040, 0x78fa, 0xa08e, 0x0022, 0x0040, 0x78f6,
+	0xa08e, 0x003d, 0x0040, 0x78fa, 0x0078, 0x78f1, 0x1078, 0x2839,
+	0x2001, 0x0007, 0x1078, 0x443f, 0x6018, 0xa080, 0x0028, 0x200c,
+	0x1078, 0x7a05, 0xa186, 0x007e, 0x00c0, 0x78d3, 0x2001, 0xa332,
+	0x2014, 0xc285, 0x2202, 0x017e, 0x027e, 0x037e, 0x2110, 0x2019,
+	0x0028, 0x1078, 0x5d53, 0x077e, 0x2039, 0x0000, 0x1078, 0x5c78,
+	0x0c7e, 0x6018, 0xa065, 0x0040, 0x78e7, 0x1078, 0x471b, 0x0c7f,
+	0x2c08, 0x1078, 0x9c38, 0x077f, 0x037f, 0x027f, 0x017f, 0x1078,
+	0x44bc, 0x1078, 0x753d, 0x1078, 0x6109, 0x007c, 0x1078, 0x7a05,
+	0x0078, 0x78f1, 0x1078, 0x7a28, 0x0078, 0x78f1, 0xa186, 0x0014,
+	0x00c0, 0x78f5, 0x1078, 0x6010, 0x1078, 0x2813, 0x1078, 0x8c27,
+	0x00c0, 0x791d, 0x1078, 0x2839, 0x6018, 0xa080, 0x0028, 0x200c,
+	0x1078, 0x7a05, 0xa186, 0x007e, 0x00c0, 0x791b, 0x2001, 0xa332,
+	0x200c, 0xc185, 0x2102, 0x0078, 0x78f1, 0x1078, 0x8c3b, 0x00c0,
+	0x7925, 0x1078, 0x7a05, 0x0078, 0x78f1, 0x6004, 0xa08e, 0x0032,
+	0x00c0, 0x7936, 0x0e7e, 0x0f7e, 0x2071, 0xa381, 0x2079, 0x0000,
+	0x1078, 0x2b56, 0x0f7f, 0x0e7f, 0x0078, 0x78f1, 0x6004, 0xa08e,
+	0x0021, 0x0040, 0x7921, 0xa08e, 0x0022, 0x1040, 0x7a05, 0x0078,
+	0x78f1, 0x7983, 0x7985, 0x7989, 0x798d, 0x7991, 0x7995, 0x7981,
+	0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981,
+	0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981,
+	0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981, 0x7999,
+	0x79ab, 0x7981, 0x79ad, 0x79ab, 0x7981, 0x7981, 0x7981, 0x7981,
+	0x7981, 0x79ab, 0x79ab, 0x7981, 0x7981, 0x7981, 0x7981, 0x7981,
+	0x7981, 0x7981, 0x7981, 0x79de, 0x79ab, 0x7981, 0x79a5, 0x7981,
+	0x7981, 0x7981, 0x79a7, 0x7981, 0x7981, 0x7981, 0x79ab, 0x7981,
+	0x7981, 0x1078, 0x1328, 0x0078, 0x79ab, 0x2001, 0x000b, 0x0078,
+	0x79b8, 0x2001, 0x0003, 0x0078, 0x79b8, 0x2001, 0x0005, 0x0078,
+	0x79b8, 0x2001, 0x0001, 0x0078, 0x79b8, 0x2001, 0x0009, 0x0078,
+	0x79b8, 0x1078, 0x6010, 0x6003, 0x0005, 0x2001, 0xa5a2, 0x2004,
+	0x603e, 0x1078, 0x6109, 0x0078, 0x79b7, 0x0078, 0x79ab, 0x0078,
+	0x79ab, 0x1078, 0x443f, 0x0078, 0x79f0, 0x1078, 0x6010, 0x6003,
+	0x0004, 0x2001, 0xa5a0, 0x2004, 0x6016, 0x1078, 0x6109, 0x007c,
+	0x1078, 0x443f, 0x1078, 0x6010, 0x2001, 0xa5a2, 0x2004, 0x603e,
+	0x6003, 0x0002, 0x037e, 0x2019, 0xa35c, 0x2304, 0xa084, 0xff00,
+	0x00c0, 0x79cf, 0x2019, 0xa5a0, 0x231c, 0x0078, 0x79d8, 0x8007,
+	0xa09a, 0x0004, 0x0048, 0x79ca, 0x8003, 0x801b, 0x831b, 0xa318,
+	0x6316, 0x037f, 0x1078, 0x6109, 0x0078, 0x79b7, 0x0e7e, 0x0f7e,
+	0x2071, 0xa381, 0x2079, 0x0000, 0x1078, 0x2b56, 0x0f7f, 0x0e7f,
+	0x1078, 0x6010, 0x1078, 0x753d, 0x1078, 0x6109, 0x0078, 0x79b7,
+	0x1078, 0x6010, 0x6003, 0x0002, 0x2001, 0xa5a0, 0x2004, 0x6016,
+	0x1078, 0x6109, 0x007c, 0x2600, 0x2008, 0x0079, 0x79ff, 0x7a03,
+	0x7a03, 0x7a03, 0x79f0, 0x1078, 0x1328, 0x0e7e, 0x1078, 0x8a44,
+	0x0040, 0x7a21, 0x6010, 0x2070, 0x7038, 0xd0fc, 0x0040, 0x7a21,
+	0x7007, 0x0000, 0x017e, 0x6004, 0xa08e, 0x0021, 0x0040, 0x7a23,
+	0xa08e, 0x003d, 0x0040, 0x7a23, 0x017f, 0x7037, 0x0103, 0x7033,
+	0x0100, 0x0e7f, 0x007c, 0x017f, 0x1078, 0x7a28, 0x0078, 0x7a21,
+	0x0e7e, 0xacf0, 0x0004, 0x2e74, 0x7000, 0x2070, 0x7037, 0x0103,
+	0x7023, 0x8001, 0x0e7f, 0x007c, 0x0d7e, 0x6618, 0x2668, 0x6804,
+	0xa084, 0x00ff, 0x0d7f, 0xa0b2, 0x000c, 0x10c8, 0x1328, 0x6604,
+	0xa6b6, 0x0043, 0x00c0, 0x7a48, 0x1078, 0x8e6d, 0x0078, 0x7aa7,
+	0x6604, 0xa6b6, 0x0033, 0x00c0, 0x7a51, 0x1078, 0x8e11, 0x0078,
+	0x7aa7, 0x6604, 0xa6b6, 0x0028, 0x00c0, 0x7a5a, 0x1078, 0x8c6a,
+	0x0078, 0x7aa7, 0x6604, 0xa6b6, 0x0029, 0x00c0, 0x7a63, 0x1078,
+	0x8c84, 0x0078, 0x7aa7, 0x6604, 0xa6b6, 0x001f, 0x00c0, 0x7a6c,
+	0x1078, 0x75ee, 0x0078, 0x7aa7, 0x6604, 0xa6b6, 0x0000, 0x00c0,
+	0x7a75, 0x1078, 0x780c, 0x0078, 0x7aa7, 0x6604, 0xa6b6, 0x0022,
+	0x00c0, 0x7a7e, 0x1078, 0x7617, 0x0078, 0x7aa7, 0x6604, 0xa6b6,
+	0x0035, 0x00c0, 0x7a87, 0x1078, 0x7653, 0x0078, 0x7aa7, 0x6604,
+	0xa6b6, 0x0039, 0x00c0, 0x7a90, 0x1078, 0x77b2, 0x0078, 0x7aa7,
+	0x6604, 0xa6b6, 0x003d, 0x00c0, 0x7a99, 0x1078, 0x7633, 0x0078,
+	0x7aa7, 0xa1b6, 0x0015, 0x00c0, 0x7aa1, 0x1079, 0x7aac, 0x0078,
+	0x7aa7, 0xa1b6, 0x0016, 0x00c0, 0x7aa8, 0x1079, 0x7bfd, 0x007c,
+	0x1078, 0x7583, 0x0078, 0x7aa7, 0x7ad0, 0x7ad3, 0x7ad0, 0x7b1e,
+	0x7ad0, 0x7b91, 0x7c09, 0x7ad0, 0x7ad0, 0x7bd5, 0x7ad0, 0x7beb,
+	0xa1b6, 0x0048, 0x0040, 0x7ac4, 0x20e1, 0x0005, 0x3d18, 0x3e20,
+	0x2c10, 0x1078, 0x15ec, 0x007c, 0x0e7e, 0xacf0, 0x0004, 0x2e74,
+	0x7000, 0x2070, 0x7037, 0x0103, 0x0e7f, 0x1078, 0x753d, 0x007c,
+	0x0005, 0x0005, 0x007c, 0x0e7e, 0x2071, 0xa300, 0x707c, 0xa086,
+	0x0074, 0x00c0, 0x7b07, 0x1078, 0x9c0c, 0x00c0, 0x7af9, 0x0d7e,
+	0x6018, 0x2068, 0x7030, 0xd08c, 0x0040, 0x7aec, 0x6800, 0xd0bc,
+	0x0040, 0x7aec, 0xc0c5, 0x6802, 0x1078, 0x7b0b, 0x0d7f, 0x2001,
+	0x0006, 0x1078, 0x443f, 0x1078, 0x2839, 0x1078, 0x753d, 0x0078,
+	0x7b09, 0x2001, 0x000a, 0x1078, 0x443f, 0x1078, 0x2839, 0x6003,
+	0x0001, 0x6007, 0x0001, 0x1078, 0x5c45, 0x0078, 0x7b09, 0x1078,
+	0x7b81, 0x0e7f, 0x007c, 0x6800, 0xd084, 0x0040, 0x7b1d, 0x2001,
+	0x0000, 0x1078, 0x442b, 0x2069, 0xa351, 0x6804, 0xd0a4, 0x0040,
+	0x7b1d, 0x2001, 0x0006, 0x1078, 0x4472, 0x007c, 0x0d7e, 0x2011,
+	0xa31f, 0x2204, 0xa086, 0x0074, 0x00c0, 0x7b7d, 0x6018, 0x2068,
+	0x6aa0, 0xa286, 0x007e, 0x00c0, 0x7b31, 0x1078, 0x7d17, 0x0078,
+	0x7b7f, 0x1078, 0x7d0d, 0x6018, 0x2068, 0xa080, 0x0028, 0x2014,
+	0xa286, 0x0080, 0x00c0, 0x7b55, 0x6813, 0x00ff, 0x6817, 0xfffc,
+	0x6010, 0xa005, 0x0040, 0x7b4b, 0x2068, 0x6807, 0x0000, 0x6837,
+	0x0103, 0x6833, 0x0200, 0x2001, 0x0006, 0x1078, 0x443f, 0x1078,
+	0x2839, 0x1078, 0x753d, 0x0078, 0x7b7f, 0x0e7e, 0x2071, 0xa332,
+	0x2e04, 0xd09c, 0x0040, 0x7b70, 0x2071, 0xa880, 0x7108, 0x720c,
+	0xa18c, 0x00ff, 0x00c0, 0x7b68, 0xa284, 0xff00, 0x0040, 0x7b70,
+	0x6018, 0x2070, 0x70a0, 0xd0bc, 0x00c0, 0x7b70, 0x7112, 0x7216,
+	0x0e7f, 0x2001, 0x0004, 0x1078, 0x443f, 0x6003, 0x0001, 0x6007,
+	0x0003, 0x1078, 0x5c45, 0x0078, 0x7b7f, 0x1078, 0x7b81, 0x0d7f,
+	0x007c, 0x2001, 0xa300, 0x2004, 0xa086, 0x0003, 0x0040, 0x7b8c,
+	0x2001, 0x0007, 0x1078, 0x443f, 0x1078, 0x2839, 0x1078, 0x753d,
+	0x007c, 0x0e7e, 0x2071, 0xa300, 0x707c, 0xa086, 0x0014, 0x00c0,
+	0x7bcf, 0x7000, 0xa086, 0x0003, 0x00c0, 0x7ba4, 0x6010, 0xa005,
+	0x00c0, 0x7ba4, 0x1078, 0x35f7, 0x0d7e, 0x6018, 0x2068, 0x1078,
+	0x457d, 0x1078, 0x7b0b, 0x0d7f, 0x1078, 0x7dba, 0x00c0, 0x7bcf,
+	0x0d7e, 0x6018, 0x2068, 0x6890, 0x0d7f, 0xa005, 0x0040, 0x7bcf,
+	0x2001, 0x0006, 0x1078, 0x443f, 0x0e7e, 0x6010, 0xa005, 0x0040,
+	0x7bc8, 0x2070, 0x7007, 0x0000, 0x7037, 0x0103, 0x7033, 0x0200,
+	0x0e7f, 0x1078, 0x2839, 0x1078, 0x753d, 0x0078, 0x7bd3, 0x1078,
+	0x7a05, 0x1078, 0x7b81, 0x0e7f, 0x007c, 0x2011, 0xa31f, 0x2204,
+	0xa086, 0x0014, 0x00c0, 0x7be8, 0x2001, 0x0002, 0x1078, 0x443f,
+	0x6003, 0x0001, 0x6007, 0x0001, 0x1078, 0x5c45, 0x0078, 0x7bea,
+	0x1078, 0x7b81, 0x007c, 0x2011, 0xa31f, 0x2204, 0xa086, 0x0004,
+	0x00c0, 0x7bfa, 0x2001, 0x0007, 0x1078, 0x443f, 0x1078, 0x753d,
+	0x0078, 0x7bfc, 0x1078, 0x7b81, 0x007c, 0x7ad0, 0x7c11, 0x7ad0,
+	0x7c4e, 0x7ad0, 0x7cc0, 0x7c09, 0x7ad0, 0x7ad0, 0x7cd5, 0x7ad0,
+	0x7ce8, 0x6604, 0xa6b6, 0x001e, 0x00c0, 0x7c10, 0x1078, 0x753d,
+	0x007c, 0x0d7e, 0x0c7e, 0x1078, 0x7cfb, 0x00c0, 0x7c27, 0x2001,
+	0x0000, 0x1078, 0x442b, 0x2001, 0x0002, 0x1078, 0x443f, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x1078, 0x5c45, 0x0078, 0x7c4b, 0x2009,
+	0xa88e, 0x2104, 0xa086, 0x0009, 0x00c0, 0x7c3c, 0x6018, 0x2068,
+	0x6840, 0xa084, 0x00ff, 0xa005, 0x0040, 0x7c49, 0x8001, 0x6842,
+	0x6017, 0x000a, 0x0078, 0x7c4b, 0x2009, 0xa88f, 0x2104, 0xa084,
+	0xff00, 0xa086, 0x1900, 0x00c0, 0x7c49, 0x1078, 0x753d, 0x0078,
+	0x7c4b, 0x1078, 0x7b81, 0x0c7f, 0x0d7f, 0x007c, 0x1078, 0x7d0a,
+	0x00c0, 0x7c62, 0x2001, 0x0000, 0x1078, 0x442b, 0x2001, 0x0002,
+	0x1078, 0x443f, 0x6003, 0x0001, 0x6007, 0x0002, 0x1078, 0x5c45,
+	0x0078, 0x7c8e, 0x1078, 0x7a05, 0x2009, 0xa88e, 0x2134, 0xa6b4,
+	0x00ff, 0xa686, 0x0005, 0x0040, 0x7c8f, 0xa686, 0x000b, 0x0040,
+	0x7c8c, 0x2009, 0xa88f, 0x2104, 0xa084, 0xff00, 0x00c0, 0x7c7c,
+	0xa686, 0x0009, 0x0040, 0x7c8f, 0xa086, 0x1900, 0x00c0, 0x7c8c,
+	0xa686, 0x0009, 0x0040, 0x7c8f, 0x2001, 0x0004, 0x1078, 0x443f,
+	0x1078, 0x753d, 0x0078, 0x7c8e, 0x1078, 0x7b81, 0x007c, 0x0d7e,
+	0x6010, 0x2068, 0x1078, 0x8a44, 0x0040, 0x7c9d, 0x6838, 0xd0fc,
+	0x0040, 0x7c9d, 0x0d7f, 0x0078, 0x7c8c, 0x6018, 0x2068, 0x6840,
+	0xa084, 0x00ff, 0xa005, 0x0040, 0x7cae, 0x8001, 0x6842, 0x6017,
+	0x000a, 0x6007, 0x0016, 0x0d7f, 0x0078, 0x7c8e, 0x68a0, 0xa086,
+	0x007e, 0x00c0, 0x7cbb, 0x0e7e, 0x2071, 0xa300, 0x1078, 0x41f5,
+	0x0e7f, 0x0078, 0x7cbd, 0x1078, 0x2813, 0x0d7f, 0x0078, 0x7c8c,
+	0x1078, 0x7d0a, 0x00c0, 0x7cd0, 0x2001, 0x0004, 0x1078, 0x443f,
+	0x6003, 0x0001, 0x6007, 0x0003, 0x1078, 0x5c45, 0x0078, 0x7cd4,
+	0x1078, 0x7a05, 0x1078, 0x7b81, 0x007c, 0x1078, 0x7d0a, 0x00c0,
+	0x7ce5, 0x2001, 0x0008, 0x1078, 0x443f, 0x6003, 0x0001, 0x6007,
+	0x0005, 0x1078, 0x5c45, 0x0078, 0x7ce7, 0x1078, 0x7b81, 0x007c,
+	0x1078, 0x7d0a, 0x00c0, 0x7cf8, 0x2001, 0x000a, 0x1078, 0x443f,
+	0x6003, 0x0001, 0x6007, 0x0001, 0x1078, 0x5c45, 0x0078, 0x7cfa,
+	0x1078, 0x7b81, 0x007c, 0x2009, 0xa88e, 0x2104, 0xa086, 0x0003,
+	0x00c0, 0x7d09, 0x2009, 0xa88f, 0x2104, 0xa084, 0xff00, 0xa086,
+	0x2a00, 0x007c, 0xa085, 0x0001, 0x007c, 0x0c7e, 0x017e, 0xac88,
+	0x0006, 0x2164, 0x1078, 0x4513, 0x017f, 0x0c7f, 0x007c, 0x0f7e,
+	0x0e7e, 0x0d7e, 0x037e, 0x017e, 0x6018, 0x2068, 0x2071, 0xa332,
+	0x2e04, 0xa085, 0x0003, 0x2072, 0x1078, 0x7d8b, 0x0040, 0x7d50,
+	0x2001, 0xa352, 0x2004, 0xd0a4, 0x0040, 0x7d39, 0xa006, 0x2020,
+	0x2009, 0x002a, 0x1078, 0x9ec0, 0x2001, 0xa30c, 0x200c, 0xc195,
+	0x2102, 0x2019, 0x002a, 0x2009, 0x0001, 0x1078, 0x27e2, 0x2071,
+	0xa300, 0x1078, 0x260d, 0x0c7e, 0x157e, 0x20a9, 0x0081, 0x2009,
+	0x007f, 0x1078, 0x2921, 0x8108, 0x00f0, 0x7d49, 0x157f, 0x0c7f,
+	0x1078, 0x7d0d, 0x6813, 0x00ff, 0x6817, 0xfffe, 0x2071, 0xa880,
+	0x2079, 0x0100, 0x2e04, 0xa084, 0x00ff, 0x2069, 0xa31a, 0x206a,
+	0x78e6, 0x007e, 0x8e70, 0x2e04, 0x2069, 0xa31b, 0x206a, 0x78ea,
+	0xa084, 0xff00, 0x017f, 0xa105, 0x2009, 0xa325, 0x200a, 0x2069,
+	0xa88e, 0x2071, 0xa59c, 0x6810, 0x2072, 0x6814, 0x7006, 0x6818,
+	0x700a, 0x681c, 0x700e, 0x1078, 0x8da9, 0x2001, 0x0006, 0x1078,
+	0x443f, 0x1078, 0x2839, 0x1078, 0x753d, 0x017f, 0x037f, 0x0d7f,
+	0x0e7f, 0x0f7f, 0x007c, 0x027e, 0x037e, 0x0e7e, 0x157e, 0x2019,
+	0xa325, 0x231c, 0x83ff, 0x0040, 0x7db5, 0x2071, 0xa880, 0x2e14,
+	0xa294, 0x00ff, 0x7004, 0xa084, 0xff00, 0xa205, 0xa306, 0x00c0,
+	0x7db5, 0x2011, 0xa896, 0xad98, 0x000a, 0x20a9, 0x0004, 0x1078,
+	0x7e55, 0x00c0, 0x7db5, 0x2011, 0xa89a, 0xad98, 0x0006, 0x20a9,
+	0x0004, 0x1078, 0x7e55, 0x00c0, 0x7db5, 0x157f, 0x0e7f, 0x037f,
+	0x027f, 0x007c, 0x0e7e, 0x2071, 0xa88c, 0x7004, 0xa086, 0x0014,
+	0x00c0, 0x7ddd, 0x7008, 0xa086, 0x0800, 0x00c0, 0x7ddd, 0x700c,
+	0xd0ec, 0x0040, 0x7ddb, 0xa084, 0x0f00, 0xa086, 0x0100, 0x00c0,
+	0x7ddb, 0x7024, 0xd0a4, 0x00c0, 0x7dd8, 0xd0ac, 0x0040, 0x7ddb,
+	0xa006, 0x0078, 0x7ddd, 0xa085, 0x0001, 0x0e7f, 0x007c, 0x0e7e,
+	0x0d7e, 0x0c7e, 0x077e, 0x057e, 0x047e, 0x027e, 0x007e, 0x127e,
+	0x2091, 0x8000, 0x2029, 0xa5b4, 0x252c, 0x2021, 0xa5ba, 0x2424,
+	0x2061, 0xaa00, 0x2071, 0xa300, 0x7244, 0x7060, 0xa202, 0x00c8,
+	0x7e43, 0x1078, 0x9ee5, 0x0040, 0x7e3b, 0x671c, 0xa786, 0x0001,
+	0x0040, 0x7e3b, 0xa786, 0x0007, 0x0040, 0x7e3b, 0x2500, 0xac06,
+	0x0040, 0x7e3b, 0x2400, 0xac06, 0x0040, 0x7e3b, 0x0c7e, 0x6000,
+	0xa086, 0x0004, 0x00c0, 0x7e16, 0x1078, 0x1749, 0xa786, 0x0008,
+	0x00c0, 0x7e25, 0x1078, 0x8c3b, 0x00c0, 0x7e25, 0x0c7f, 0x1078,
+	0x7a05, 0x1078, 0x8c01, 0x0078, 0x7e3b, 0x6010, 0x2068, 0x1078,
+	0x8a44, 0x0040, 0x7e38, 0xa786, 0x0003, 0x00c0, 0x7e4d, 0x6837,
+	0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0x4982, 0x1078, 0x8bf4,
+	0x1078, 0x8c01, 0x0c7f, 0xace0, 0x0010, 0x7054, 0xac02, 0x00c8,
+	0x7e43, 0x0078, 0x7df4, 0x127f, 0x007f, 0x027f, 0x047f, 0x057f,
+	0x077f, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0xa786, 0x0006, 0x00c0,
+	0x7e2f, 0x1078, 0x9e70, 0x0078, 0x7e38, 0x220c, 0x2304, 0xa106,
+	0x00c0, 0x7e60, 0x8210, 0x8318, 0x00f0, 0x7e55, 0xa006, 0x007c,
+	0x2304, 0xa102, 0x0048, 0x7e68, 0x2001, 0x0001, 0x0078, 0x7e6a,
+	0x2001, 0x0000, 0xa18d, 0x0001, 0x007c, 0x6004, 0xa08a, 0x0044,
+	0x10c8, 0x1328, 0x1078, 0x8c27, 0x0040, 0x7e7c, 0x1078, 0x8c3b,
+	0x0040, 0x7e89, 0x0078, 0x7e82, 0x1078, 0x2839, 0x1078, 0x8c3b,
+	0x0040, 0x7e89, 0x1078, 0x6010, 0x1078, 0x753d, 0x1078, 0x6109,
+	0x007c, 0x1078, 0x7a05, 0x0078, 0x7e82, 0xa182, 0x0040, 0x0079,
+	0x7e91, 0x7ea4, 0x7ea4, 0x7ea4, 0x7ea4, 0x7ea4, 0x7ea4, 0x7ea4,
+	0x7ea4, 0x7ea4, 0x7ea4, 0x7ea4, 0x7ea6, 0x7ea6, 0x7ea6, 0x7ea6,
+	0x7ea4, 0x7ea4, 0x7ea4, 0x7ea6, 0x1078, 0x1328, 0x600b, 0xffff,
+	0x6003, 0x0001, 0x6106, 0x1078, 0x5bf8, 0x127e, 0x2091, 0x8000,
+	0x1078, 0x6109, 0x127f, 0x007c, 0xa186, 0x0013, 0x00c0, 0x7ebd,
+	0x6004, 0xa082, 0x0040, 0x0079, 0x7f48, 0xa186, 0x0027, 0x00c0,
+	0x7edf, 0x1078, 0x6010, 0x1078, 0x2813, 0x0d7e, 0x6110, 0x2168,
+	0x1078, 0x8a44, 0x0040, 0x7ed9, 0x6837, 0x0103, 0x684b, 0x0029,
+	0x6847, 0x0000, 0x694c, 0xc1c5, 0x694e, 0x1078, 0x4982, 0x1078,
+	0x8bf4, 0x0d7f, 0x1078, 0x753d, 0x1078, 0x6109, 0x007c, 0xa186,
+	0x0014, 0x00c0, 0x7ee8, 0x6004, 0xa082, 0x0040, 0x0079, 0x7f10,
+	0xa186, 0x0046, 0x0040, 0x7ef4, 0xa186, 0x0045, 0x0040, 0x7ef4,
+	0xa186, 0x0047, 0x10c0, 0x1328, 0x2001, 0x0109, 0x2004, 0xd084,
+	0x0040, 0x7f0d, 0x127e, 0x2091, 0x2200, 0x007e, 0x017e, 0x027e,
+	0x1078, 0x5ad2, 0x027f, 0x017f, 0x007f, 0x127f, 0x6000, 0xa086,
+	0x0002, 0x00c0, 0x7f0d, 0x0078, 0x7f81, 0x1078, 0x7583, 0x007c,
+	0x7f25, 0x7f23, 0x7f23, 0x7f23, 0x7f23, 0x7f23, 0x7f23, 0x7f23,
+	0x7f23, 0x7f23, 0x7f23, 0x7f41, 0x7f41, 0x7f41, 0x7f41, 0x7f23,
+	0x7f41, 0x7f23, 0x7f41, 0x1078, 0x1328, 0x1078, 0x6010, 0x0d7e,
+	0x6110, 0x2168, 0x1078, 0x8a44, 0x0040, 0x7f3b, 0x6837, 0x0103,
+	0x684b, 0x0006, 0x6847, 0x0000, 0x6850, 0xc0ec, 0x6852, 0x1078,
+	0x4982, 0x1078, 0x8bf4, 0x0d7f, 0x1078, 0x753d, 0x1078, 0x6109,
+	0x007c, 0x1078, 0x6010, 0x1078, 0x753d, 0x1078, 0x6109, 0x007c,
+	0x7f5d, 0x7f5b, 0x7f5b, 0x7f5b, 0x7f5b, 0x7f5b, 0x7f5b, 0x7f5b,
+	0x7f5b, 0x7f5b, 0x7f5b, 0x7f6f, 0x7f6f, 0x7f6f, 0x7f6f, 0x7f5b,
+	0x7f7a, 0x7f5b, 0x7f6f, 0x1078, 0x1328, 0x1078, 0x6010, 0x2001,
+	0xa5a2, 0x2004, 0x603e, 0x6003, 0x0002, 0x1078, 0x6109, 0x6010,
+	0xa088, 0x0013, 0x2104, 0xa085, 0x0400, 0x200a, 0x007c, 0x1078,
+	0x6010, 0x2001, 0xa5a2, 0x2004, 0x603e, 0x6003, 0x000f, 0x1078,
+	0x6109, 0x007c, 0x1078, 0x6010, 0x1078, 0x753d, 0x1078, 0x6109,
+	0x007c, 0xa182, 0x0040, 0x0079, 0x7f85, 0x7f98, 0x7f98, 0x7f98,
+	0x7f98, 0x7f98, 0x7f9a, 0x8095, 0x80b7, 0x7f98, 0x7f98, 0x7f98,
+	0x7f98, 0x7f98, 0x7f98, 0x7f98, 0x7f98, 0x7f98, 0x7f98, 0x7f98,
+	0x1078, 0x1328, 0x0e7e, 0x0d7e, 0x603f, 0x0000, 0x2071, 0xa880,
+	0x7124, 0x610a, 0x2071, 0xa88c, 0x6110, 0x2168, 0x7614, 0xa6b4,
+	0x0fff, 0x86ff, 0x0040, 0x8058, 0xa68c, 0x0c00, 0x0040, 0x7fd1,
+	0x0f7e, 0x2c78, 0x1078, 0x4893, 0x0f7f, 0x0040, 0x7fcd, 0x684c,
+	0xd0ac, 0x0040, 0x7fcd, 0x6024, 0xd0dc, 0x00c0, 0x7fcd, 0x6850,
+	0xd0bc, 0x00c0, 0x7fcd, 0x7318, 0x6814, 0xa306, 0x00c0, 0x806f,
+	0x731c, 0x6810, 0xa306, 0x00c0, 0x806f, 0x7318, 0x6b62, 0x731c,
+	0x6b5e, 0xa68c, 0x00ff, 0xa186, 0x0002, 0x0040, 0x8004, 0xa186,
+	0x0028, 0x00c0, 0x7fe1, 0x1078, 0x8c15, 0x684b, 0x001c, 0x0078,
+	0x8006, 0xd6dc, 0x0040, 0x7ffd, 0x684b, 0x0015, 0x684c, 0xd0ac,
+	0x0040, 0x7ffb, 0x6914, 0x6a10, 0x2100, 0xa205, 0x0040, 0x7ffb,
+	0x7018, 0xa106, 0x00c0, 0x7ff8, 0x701c, 0xa206, 0x0040, 0x7ffb,
+	0x6962, 0x6a5e, 0xc6dc, 0x0078, 0x8006, 0xd6d4, 0x0040, 0x8004,
+	0x684b, 0x0007, 0x0078, 0x8006, 0x684b, 0x0000, 0x6837, 0x0103,
+	0x6e46, 0xa01e, 0xd6c4, 0x0040, 0x802f, 0xa686, 0x0100, 0x00c0,
+	0x801a, 0x2001, 0xa899, 0x2004, 0xa005, 0x00c0, 0x801a, 0xc6c4,
+	0x0078, 0x7fa9, 0x7328, 0x732c, 0x6b56, 0x83ff, 0x0040, 0x802f,
+	0xa38a, 0x0009, 0x0048, 0x8026, 0x2019, 0x0008, 0x037e, 0x2308,
+	0x2019, 0xa898, 0xad90, 0x0019, 0x1078, 0x8739, 0x037f, 0xd6cc,
+	0x0040, 0x8085, 0x7124, 0x695a, 0x81ff, 0x0040, 0x8085, 0xa192,
+	0x0021, 0x00c8, 0x8046, 0x2071, 0xa898, 0x831c, 0x2300, 0xae18,
+	0xad90, 0x001d, 0x1078, 0x8739, 0x0078, 0x8085, 0x6838, 0xd0fc,
+	0x0040, 0x804f, 0x2009, 0x0020, 0x695a, 0x0078, 0x803b, 0x0f7e,
+	0x2d78, 0x1078, 0x86d1, 0x0f7f, 0x1078, 0x8726, 0x0078, 0x8087,
+	0x0f7e, 0x2c78, 0x1078, 0x4893, 0x0f7f, 0x0040, 0x8075, 0x684c,
+	0xd0ac, 0x0040, 0x8075, 0x6024, 0xd0dc, 0x00c0, 0x8075, 0x6850,
+	0xd0bc, 0x00c0, 0x8075, 0x684c, 0xd0f4, 0x00c0, 0x8075, 0x1078,
+	0x8cfa, 0x0d7f, 0x0e7f, 0x0078, 0x8094, 0x684b, 0x0000, 0x6837,
+	0x0103, 0x6e46, 0x684c, 0xd0ac, 0x0040, 0x8085, 0x6810, 0x6914,
+	0xa115, 0x0040, 0x8085, 0x1078, 0x8233, 0x1078, 0x4982, 0x6218,
+	0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x1078, 0x8cc4, 0x0d7f, 0x0e7f,
+	0x00c0, 0x8094, 0x1078, 0x753d, 0x007c, 0x0f7e, 0x6003, 0x0003,
+	0x2079, 0xa88c, 0x7c04, 0x7b00, 0x7e0c, 0x7d08, 0x6010, 0x2078,
+	0x784c, 0xd0ac, 0x0040, 0x80a8, 0x6003, 0x0002, 0x0f7f, 0x007c,
+	0x7c12, 0x7b16, 0x7e0a, 0x7d0e, 0x0f7f, 0x603f, 0x0000, 0x2c10,
+	0x1078, 0x1cab, 0x1078, 0x5c64, 0x1078, 0x61d3, 0x007c, 0x2001,
+	0xa5a2, 0x2004, 0x603e, 0x6003, 0x0004, 0x6110, 0x20e1, 0x0005,
+	0x3d18, 0x3e20, 0x2c10, 0x1078, 0x15ec, 0x007c, 0xa182, 0x0040,
+	0x0079, 0x80ca, 0x80dd, 0x80dd, 0x80dd, 0x80dd, 0x80dd, 0x80df,
+	0x8182, 0x80dd, 0x80dd, 0x8198, 0x8209, 0x80dd, 0x80dd, 0x80dd,
+	0x80dd, 0x8218, 0x80dd, 0x80dd, 0x80dd, 0x1078, 0x1328, 0x077e,
+	0x0f7e, 0x0e7e, 0x0d7e, 0x2071, 0xa88c, 0x6110, 0x2178, 0x7614,
+	0xa6b4, 0x0fff, 0x7e46, 0x7f4c, 0xc7e5, 0x7f4e, 0x6218, 0x2268,
+	0x6a3c, 0x8211, 0x6a3e, 0x86ff, 0x0040, 0x817d, 0xa694, 0xff00,
+	0xa284, 0x0c00, 0x0040, 0x8100, 0x7018, 0x7862, 0x701c, 0x785e,
+	0xa284, 0x0300, 0x0040, 0x817d, 0x1078, 0x1381, 0x1040, 0x1328,
+	0x2d00, 0x784a, 0x7f4c, 0xc7cd, 0x7f4e, 0x6837, 0x0103, 0x7838,
+	0x683a, 0x783c, 0x683e, 0x7840, 0x6842, 0x6e46, 0xa68c, 0x0c00,
+	0x0040, 0x811e, 0x7318, 0x6b62, 0x731c, 0x6b5e, 0xa68c, 0x00ff,
+	0xa186, 0x0002, 0x0040, 0x813a, 0xa186, 0x0028, 0x00c0, 0x812c,
+	0x684b, 0x001c, 0x0078, 0x813c, 0xd6dc, 0x0040, 0x8133, 0x684b,
+	0x0015, 0x0078, 0x813c, 0xd6d4, 0x0040, 0x813a, 0x684b, 0x0007,
+	0x0078, 0x813c, 0x684b, 0x0000, 0x6f4e, 0x7850, 0x6852, 0x7854,
+	0x6856, 0xa01e, 0xd6c4, 0x0040, 0x815a, 0x7328, 0x732c, 0x6b56,
+	0x83ff, 0x0040, 0x815a, 0xa38a, 0x0009, 0x0048, 0x8151, 0x2019,
+	0x0008, 0x037e, 0x2308, 0x2019, 0xa898, 0xad90, 0x0019, 0x1078,
+	0x8739, 0x037f, 0xd6cc, 0x0040, 0x817d, 0x7124, 0x695a, 0x81ff,
+	0x0040, 0x817d, 0xa192, 0x0021, 0x00c8, 0x8171, 0x2071, 0xa898,
+	0x831c, 0x2300, 0xae18, 0xad90, 0x001d, 0x1078, 0x8739, 0x0078,
+	0x817d, 0x7838, 0xd0fc, 0x0040, 0x817a, 0x2009, 0x0020, 0x695a,
+	0x0078, 0x8166, 0x2d78, 0x1078, 0x86d1, 0x0d7f, 0x0e7f, 0x0f7f,
+	0x077f, 0x007c, 0x0f7e, 0x6003, 0x0003, 0x2079, 0xa88c, 0x7c04,
+	0x7b00, 0x7e0c, 0x7d08, 0x6010, 0x2078, 0x7c12, 0x7b16, 0x7e0a,
+	0x7d0e, 0x0f7f, 0x2c10, 0x1078, 0x1cab, 0x1078, 0x6c26, 0x007c,
+	0x0d7e, 0x0f7e, 0x2c78, 0x1078, 0x4893, 0x0f7f, 0x0040, 0x81a4,
+	0x2001, 0xa5a2, 0x2004, 0x603e, 0x6003, 0x0002, 0x1078, 0x60b8,
+	0x1078, 0x61d3, 0x6110, 0x2168, 0x694c, 0xd1e4, 0x0040, 0x8207,
+	0xd1cc, 0x0040, 0x81de, 0x6948, 0x6838, 0xd0fc, 0x0040, 0x81d6,
+	0x017e, 0x684c, 0x007e, 0x6850, 0x007e, 0xad90, 0x000d, 0xa198,
+	0x000d, 0x2009, 0x0020, 0x157e, 0x21a8, 0x2304, 0x2012, 0x8318,
+	0x8210, 0x00f0, 0x81c5, 0x157f, 0x007f, 0x6852, 0x007f, 0x684e,
+	0x017f, 0x2168, 0x1078, 0x13aa, 0x0078, 0x8201, 0x017e, 0x1078,
+	0x13aa, 0x0d7f, 0x1078, 0x8726, 0x0078, 0x8201, 0x6837, 0x0103,
+	0x6944, 0xa184, 0x00ff, 0xa0b6, 0x0002, 0x0040, 0x81fd, 0xa086,
+	0x0028, 0x00c0, 0x81ef, 0x684b, 0x001c, 0x0078, 0x81ff, 0xd1dc,
+	0x0040, 0x81f6, 0x684b, 0x0015, 0x0078, 0x81ff, 0xd1d4, 0x0040,
+	0x81fd, 0x684b, 0x0007, 0x0078, 0x81ff, 0x684b, 0x0000, 0x1078,
+	0x4982, 0x1078, 0x8cc4, 0x00c0, 0x8207, 0x1078, 0x753d, 0x0d7f,
+	0x007c, 0x2019, 0x0001, 0x1078, 0x6e6c, 0x6003, 0x0002, 0x2001,
+	0xa5a2, 0x2004, 0x603e, 0x1078, 0x60b8, 0x1078, 0x61d3, 0x007c,
+	0x1078, 0x60b8, 0x1078, 0x2813, 0x0d7e, 0x6110, 0x2168, 0x1078,
+	0x8a44, 0x0040, 0x822d, 0x6837, 0x0103, 0x684b, 0x0029, 0x6847,
+	0x0000, 0x1078, 0x4982, 0x1078, 0x8bf4, 0x0d7f, 0x1078, 0x753d,
+	0x1078, 0x61d3, 0x007c, 0x684b, 0x0015, 0xd1fc, 0x0040, 0x823f,
+	0x684b, 0x0007, 0x8002, 0x8000, 0x810a, 0xa189, 0x0000, 0x6962,
+	0x685e, 0x007c, 0xa182, 0x0040, 0x0079, 0x8246, 0x8259, 0x8259,
+	0x8259, 0x8259, 0x8259, 0x825b, 0x8259, 0x8333, 0x833f, 0x8259,
+	0x8259, 0x8259, 0x8259, 0x8259, 0x8259, 0x8259, 0x8259, 0x8259,
+	0x8259, 0x1078, 0x1328, 0x077e, 0x0f7e, 0x0e7e, 0x0d7e, 0x2071,
+	0xa88c, 0x6110, 0x2178, 0x7614, 0xa6b4, 0x0fff, 0x0f7e, 0x2c78,
+	0x1078, 0x4893, 0x0f7f, 0x0040, 0x827e, 0xa684, 0x00ff, 0x00c0,
+	0x827e, 0x6024, 0xd0f4, 0x00c0, 0x827a, 0x7808, 0xa086, 0x0000,
+	0x00c0, 0x827e, 0x1078, 0x8cfa, 0x0078, 0x832e, 0x7e46, 0x7f4c,
+	0xc7e5, 0x7f4e, 0x6218, 0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x86ff,
+	0x0040, 0x8323, 0xa694, 0xff00, 0xa284, 0x0c00, 0x0040, 0x8294,
+	0x7018, 0x7862, 0x701c, 0x785e, 0xa284, 0x0300, 0x0040, 0x8320,
+	0xa686, 0x0100, 0x00c0, 0x82a6, 0x2001, 0xa899, 0x2004, 0xa005,
+	0x00c0, 0x82a6, 0xc6c4, 0x7e46, 0x0078, 0x8287, 0x1078, 0x1381,
+	0x1040, 0x1328, 0x2d00, 0x784a, 0x7f4c, 0xa7bd, 0x0200, 0x7f4e,
+	0x6837, 0x0103, 0x7838, 0x683a, 0x783c, 0x683e, 0x7840, 0x6842,
+	0x6e46, 0xa68c, 0x0c00, 0x0040, 0x82c1, 0x7318, 0x6b62, 0x731c,
+	0x6b5e, 0xa68c, 0x00ff, 0xa186, 0x0002, 0x0040, 0x82dd, 0xa186,
+	0x0028, 0x00c0, 0x82cf, 0x684b, 0x001c, 0x0078, 0x82df, 0xd6dc,
+	0x0040, 0x82d6, 0x684b, 0x0015, 0x0078, 0x82df, 0xd6d4, 0x0040,
+	0x82dd, 0x684b, 0x0007, 0x0078, 0x82df, 0x684b, 0x0000, 0x6f4e,
+	0x7850, 0x6852, 0x7854, 0x6856, 0xa01e, 0xd6c4, 0x0040, 0x82fd,
+	0x7328, 0x732c, 0x6b56, 0x83ff, 0x0040, 0x82fd, 0xa38a, 0x0009,
+	0x0048, 0x82f4, 0x2019, 0x0008, 0x037e, 0x2308, 0x2019, 0xa898,
+	0xad90, 0x0019, 0x1078, 0x8739, 0x037f, 0xd6cc, 0x0040, 0x8320,
+	0x7124, 0x695a, 0x81ff, 0x0040, 0x8320, 0xa192, 0x0021, 0x00c8,
+	0x8314, 0x2071, 0xa898, 0x831c, 0x2300, 0xae18, 0xad90, 0x001d,
+	0x1078, 0x8739, 0x0078, 0x8320, 0x7838, 0xd0fc, 0x0040, 0x831d,
+	0x2009, 0x0020, 0x695a, 0x0078, 0x8309, 0x2d78, 0x1078, 0x86d1,
+	0xd6dc, 0x00c0, 0x8326, 0xa006, 0x0078, 0x832c, 0x2001, 0x0001,
+	0x2071, 0xa88c, 0x7218, 0x731c, 0x1078, 0x1645, 0x0d7f, 0x0e7f,
+	0x0f7f, 0x077f, 0x007c, 0x2001, 0xa5a2, 0x2004, 0x603e, 0x20e1,
+	0x0005, 0x3d18, 0x3e20, 0x2c10, 0x1078, 0x15ec, 0x007c, 0x2001,
+	0xa5a2, 0x2004, 0x603e, 0x0d7e, 0x6003, 0x0002, 0x6110, 0x2168,
+	0x694c, 0xd1e4, 0x0040, 0x846b, 0x603f, 0x0000, 0x0f7e, 0x2c78,
+	0x1078, 0x4893, 0x0f7f, 0x0040, 0x8385, 0x6814, 0x6910, 0xa115,
+	0x0040, 0x8385, 0x6a60, 0xa206, 0x00c0, 0x8362, 0x685c, 0xa106,
+	0x0040, 0x8385, 0x684c, 0xc0e4, 0x684e, 0x6847, 0x0000, 0x6863,
+	0x0000, 0x685f, 0x0000, 0x6024, 0xd0f4, 0x00c0, 0x837a, 0x697c,
+	0x6810, 0xa102, 0x603a, 0x6980, 0x6814, 0xa103, 0x6036, 0x6024,
+	0xc0f5, 0x6026, 0x0d7e, 0x6018, 0x2068, 0x683c, 0x8000, 0x683e,
+	0x0d7f, 0x1078, 0x8cfa, 0x0078, 0x846b, 0x694c, 0xd1cc, 0x0040,
+	0x8430, 0x6948, 0x6838, 0xd0fc, 0x0040, 0x83ea, 0x017e, 0x684c,
+	0x007e, 0x6850, 0x007e, 0x0f7e, 0x2178, 0x7944, 0xa184, 0x00ff,
+	0xa0b6, 0x0002, 0x0040, 0x83bf, 0xa086, 0x0028, 0x00c0, 0x83a6,
+	0x684b, 0x001c, 0x784b, 0x001c, 0x0078, 0x83ca, 0xd1dc, 0x0040,
+	0x83b6, 0x684b, 0x0015, 0x784b, 0x0015, 0x1078, 0x8ea5, 0x0040,
+	0x83b4, 0x7944, 0xc1dc, 0x7946, 0x0078, 0x83ca, 0xd1d4, 0x0040,
+	0x83bf, 0x684b, 0x0007, 0x784b, 0x0007, 0x0078, 0x83ca, 0x684c,
+	0xd0ac, 0x0040, 0x83ca, 0x6810, 0x6914, 0xa115, 0x0040, 0x83ca,
+	0x1078, 0x8233, 0x6848, 0x784a, 0x6860, 0x7862, 0x685c, 0x785e,
+	0xad90, 0x000d, 0xaf98, 0x000d, 0x2009, 0x0020, 0x157e, 0x21a8,
+	0x2304, 0x2012, 0x8318, 0x8210, 0x00f0, 0x83d8, 0x157f, 0x0f7f,
+	0x007f, 0x6852, 0x007f, 0x684e, 0x017f, 0x2168, 0x1078, 0x13aa,
+	0x0078, 0x8465, 0x017e, 0x0f7e, 0x2178, 0x7944, 0xa184, 0x00ff,
+	0xa0b6, 0x0002, 0x0040, 0x8417, 0xa086, 0x0028, 0x00c0, 0x83fe,
+	0x684b, 0x001c, 0x784b, 0x001c, 0x0078, 0x8422, 0xd1dc, 0x0040,
+	0x840e, 0x684b, 0x0015, 0x784b, 0x0015, 0x1078, 0x8ea5, 0x0040,
+	0x840c, 0x7944, 0xc1dc, 0x7946, 0x0078, 0x8422, 0xd1d4, 0x0040,
+	0x8417, 0x684b, 0x0007, 0x784b, 0x0007, 0x0078, 0x8422, 0x684c,
+	0xd0ac, 0x0040, 0x8422, 0x6810, 0x6914, 0xa115, 0x0040, 0x8422,
+	0x1078, 0x8233, 0x6860, 0x7862, 0x685c, 0x785e, 0x684c, 0x784e,
+	0x0f7f, 0x1078, 0x13aa, 0x0d7f, 0x1078, 0x8726, 0x0078, 0x8465,
+	0x6837, 0x0103, 0x6944, 0xa184, 0x00ff, 0xa0b6, 0x0002, 0x0040,
+	0x8456, 0xa086, 0x0028, 0x00c0, 0x8441, 0x684b, 0x001c, 0x0078,
+	0x8463, 0xd1dc, 0x0040, 0x844f, 0x684b, 0x0015, 0x1078, 0x8ea5,
+	0x0040, 0x844d, 0x6944, 0xc1dc, 0x6946, 0x0078, 0x8463, 0xd1d4,
+	0x0040, 0x8456, 0x684b, 0x0007, 0x0078, 0x8463, 0x684b, 0x0000,
+	0x684c, 0xd0ac, 0x0040, 0x8463, 0x6810, 0x6914, 0xa115, 0x0040,
+	0x8463, 0x1078, 0x8233, 0x1078, 0x4982, 0x1078, 0x8cc4, 0x00c0,
+	0x846b, 0x1078, 0x753d, 0x0d7f, 0x007c, 0x1078, 0x6010, 0x0078,
+	0x8473, 0x1078, 0x60b8, 0x1078, 0x8a44, 0x0040, 0x8492, 0x0d7e,
+	0x6110, 0x2168, 0x6837, 0x0103, 0x2009, 0xa30c, 0x210c, 0xd18c,
+	0x00c0, 0x849d, 0xd184, 0x00c0, 0x8499, 0x6108, 0x694a, 0xa18e,
+	0x0029, 0x00c0, 0x848d, 0x1078, 0xa181, 0x6847, 0x0000, 0x1078,
+	0x4982, 0x0d7f, 0x1078, 0x753d, 0x1078, 0x6109, 0x1078, 0x61d3,
+	0x007c, 0x684b, 0x0004, 0x0078, 0x848d, 0x684b, 0x0004, 0x0078,
+	0x848d, 0xa182, 0x0040, 0x0079, 0x84a5, 0x84b8, 0x84b8, 0x84b8,
+	0x84b8, 0x84b8, 0x84ba, 0x84b8, 0x84bd, 0x84b8, 0x84b8, 0x84b8,
+	0x84b8, 0x84b8, 0x84b8, 0x84b8, 0x84b8, 0x84b8, 0x84b8, 0x84b8,
+	0x1078, 0x1328, 0x1078, 0x753d, 0x007c, 0x007e, 0x027e, 0xa016,
+	0x1078, 0x15ec, 0x027f, 0x007f, 0x007c, 0xa182, 0x0085, 0x0079,
+	0x84c9, 0x84d2, 0x84d0, 0x84d0, 0x84de, 0x84d0, 0x84d0, 0x84d0,
+	0x1078, 0x1328, 0x6003, 0x0001, 0x6106, 0x1078, 0x5bf8, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x6109, 0x127f, 0x007c, 0x027e, 0x057e,
+	0x0d7e, 0x0e7e, 0x2071, 0xa880, 0x7224, 0x6212, 0x7220, 0x1078,
+	0x8a30, 0x0040, 0x8503, 0x2268, 0x6800, 0xa086, 0x0000, 0x0040,
+	0x8503, 0x6018, 0x6d18, 0xa52e, 0x00c0, 0x8503, 0x0c7e, 0x2d60,
+	0x1078, 0x874a, 0x0c7f, 0x0040, 0x8503, 0x6803, 0x0002, 0x6007,
+	0x0086, 0x0078, 0x8505, 0x6007, 0x0087, 0x6003, 0x0001, 0x1078,
+	0x5bf8, 0x1078, 0x6109, 0x0f7e, 0x2278, 0x1078, 0x4893, 0x0f7f,
+	0x0040, 0x851d, 0x6824, 0xd0ec, 0x0040, 0x851d, 0x0c7e, 0x2260,
+	0x603f, 0x0000, 0x1078, 0x8cfa, 0x0c7f, 0x0e7f, 0x0d7f, 0x057f,
+	0x027f, 0x007c, 0xa186, 0x0013, 0x00c0, 0x8533, 0x6004, 0xa08a,
+	0x0085, 0x1048, 0x1328, 0xa08a, 0x008c, 0x10c8, 0x1328, 0xa082,
+	0x0085, 0x0079, 0x8542, 0xa186, 0x0027, 0x0040, 0x853b, 0xa186,
+	0x0014, 0x10c0, 0x1328, 0x1078, 0x6010, 0x1078, 0x8c01, 0x1078,
+	0x6109, 0x007c, 0x8549, 0x854b, 0x854b, 0x8549, 0x8549, 0x8549,
+	0x8549, 0x1078, 0x1328, 0x1078, 0x6010, 0x1078, 0x8c01, 0x1078,
+	0x6109, 0x007c, 0xa186, 0x0013, 0x00c0, 0x855c, 0x6004, 0xa082,
+	0x0085, 0x2008, 0x0078, 0x8597, 0xa186, 0x0027, 0x00c0, 0x857f,
+	0x1078, 0x6010, 0x1078, 0x2813, 0x0d7e, 0x6010, 0x2068, 0x1078,
+	0x8a44, 0x0040, 0x8575, 0x6837, 0x0103, 0x6847, 0x0000, 0x684b,
+	0x0029, 0x1078, 0x4982, 0x1078, 0x8bf4, 0x0d7f, 0x1078, 0x753d,
+	0x1078, 0x6109, 0x007c, 0x1078, 0x7583, 0x0078, 0x857a, 0xa186,
+	0x0014, 0x00c0, 0x857b, 0x1078, 0x6010, 0x0d7e, 0x6010, 0x2068,
+	0x1078, 0x8a44, 0x0040, 0x8575, 0x6837, 0x0103, 0x6847, 0x0000,
+	0x684b, 0x0006, 0x6850, 0xc0ec, 0x6852, 0x0078, 0x8571, 0x0079,
+	0x8599, 0x85a2, 0x85a0, 0x85a0, 0x85a0, 0x85a0, 0x85a0, 0x85bd,
+	0x1078, 0x1328, 0x1078, 0x6010, 0x6030, 0xa08c, 0xff00, 0x810f,
+	0xa186, 0x0039, 0x0040, 0x85b0, 0xa186, 0x0035, 0x00c0, 0x85b4,
+	0x2001, 0xa5a0, 0x0078, 0x85b6, 0x2001, 0xa5a1, 0x2004, 0x6016,
+	0x6003, 0x000c, 0x1078, 0x6109, 0x007c, 0x1078, 0x6010, 0x6030,
+	0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0040, 0x85cb, 0xa186,
+	0x0035, 0x00c0, 0x85cf, 0x2001, 0xa5a0, 0x0078, 0x85d1, 0x2001,
+	0xa5a1, 0x2004, 0x6016, 0x6003, 0x000e, 0x1078, 0x6109, 0x007c,
+	0xa182, 0x008c, 0x00c8, 0x85e2, 0xa182, 0x0085, 0x0048, 0x85e2,
+	0x0079, 0x85e5, 0x1078, 0x7583, 0x007c, 0x85ec, 0x85ec, 0x85ec,
+	0x85ec, 0x85ee, 0x8643, 0x85ec, 0x1078, 0x1328, 0x0f7e, 0x2c78,
+	0x1078, 0x4893, 0x0f7f, 0x0040, 0x8601, 0x6030, 0xa08c, 0xff00,
+	0x810f, 0xa186, 0x0039, 0x0040, 0x865a, 0xa186, 0x0035, 0x0040,
+	0x865a, 0x0d7e, 0x1078, 0x8bf4, 0x1078, 0x8a44, 0x0040, 0x8625,
+	0x6010, 0x2068, 0x6837, 0x0103, 0x6850, 0xd0b4, 0x0040, 0x8616,
+	0x684b, 0x0006, 0xc0ec, 0x6852, 0x0078, 0x8621, 0xd0bc, 0x0040,
+	0x861d, 0x684b, 0x0002, 0x0078, 0x8621, 0x684b, 0x0005, 0x1078,
+	0x8cc0, 0x6847, 0x0000, 0x1078, 0x4982, 0x2c68, 0x1078, 0x74d7,
+	0x0040, 0x863e, 0x6003, 0x0001, 0x6007, 0x001e, 0x2009, 0xa88e,
+	0x210c, 0x6136, 0x2009, 0xa88f, 0x210c, 0x613a, 0x6918, 0x611a,
+	0x6920, 0x6122, 0x601f, 0x0001, 0x1078, 0x5bf8, 0x2d60, 0x1078,
+	0x753d, 0x0d7f, 0x007c, 0x0f7e, 0x2c78, 0x1078, 0x4893, 0x0f7f,
+	0x0040, 0x8680, 0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0035,
+	0x0040, 0x865a, 0xa186, 0x001e, 0x0040, 0x865a, 0xa186, 0x0039,
+	0x00c0, 0x8680, 0x0d7e, 0x2c68, 0x1078, 0x8ef5, 0x00c0, 0x86a4,
+	0x1078, 0x74d7, 0x0040, 0x867d, 0x6106, 0x6003, 0x0001, 0x601f,
+	0x0001, 0x6918, 0x611a, 0x6928, 0x612a, 0x692c, 0x612e, 0x6930,
+	0xa18c, 0x00ff, 0x6132, 0x6934, 0x6136, 0x6938, 0x613a, 0x6920,
+	0x6122, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x2d60, 0x0078, 0x86a4,
+	0x0d7e, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040, 0x86a4, 0x6837,
+	0x0103, 0x6850, 0xd0b4, 0x0040, 0x8693, 0xc0ec, 0x6852, 0x684b,
+	0x0006, 0x0078, 0x869e, 0xd0bc, 0x0040, 0x869a, 0x684b, 0x0002,
+	0x0078, 0x869e, 0x684b, 0x0005, 0x1078, 0x8cc0, 0x6847, 0x0000,
+	0x1078, 0x4982, 0x1078, 0x8bf4, 0x0d7f, 0x1078, 0x753d, 0x007c,
+	0x017e, 0x0d7e, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040, 0x86b8,
+	0x6837, 0x0103, 0x684b, 0x0028, 0x6847, 0x0000, 0x1078, 0x4982,
+	0x0d7f, 0x017f, 0xa186, 0x0013, 0x0040, 0x86ca, 0xa186, 0x0014,
+	0x0040, 0x86ca, 0xa186, 0x0027, 0x0040, 0x86ca, 0x1078, 0x7583,
+	0x0078, 0x86d0, 0x1078, 0x6010, 0x1078, 0x8c01, 0x1078, 0x6109,
+	0x007c, 0x057e, 0x067e, 0x0d7e, 0x0f7e, 0x2029, 0x0001, 0xa182,
+	0x0101, 0x00c8, 0x86dd, 0x0078, 0x86df, 0x2009, 0x0100, 0x2130,
+	0x2069, 0xa898, 0x831c, 0x2300, 0xad18, 0x2009, 0x0020, 0xaf90,
+	0x001d, 0x1078, 0x8739, 0xa6b2, 0x0020, 0x7804, 0xa06d, 0x0040,
+	0x86f3, 0x1078, 0x13aa, 0x1078, 0x1381, 0x0040, 0x871d, 0x8528,
+	0x6837, 0x0110, 0x683b, 0x0000, 0x2d20, 0x7c06, 0xa68a, 0x003d,
+	0x00c8, 0x8709, 0x2608, 0xad90, 0x000f, 0x1078, 0x8739, 0x0078,
+	0x871d, 0xa6b2, 0x003c, 0x2009, 0x003c, 0x2d78, 0xad90, 0x000f,
+	0x1078, 0x8739, 0x0078, 0x86f3, 0x0f7f, 0x852f, 0xa5ad, 0x0003,
+	0x7d36, 0xa5ac, 0x0000, 0x0078, 0x8722, 0x0f7f, 0x852f, 0xa5ad,
+	0x0003, 0x7d36, 0x0d7f, 0x067f, 0x057f, 0x007c, 0x0f7e, 0x8dff,
+	0x0040, 0x8737, 0x6804, 0xa07d, 0x0040, 0x8735, 0x6807, 0x0000,
+	0x1078, 0x4982, 0x2f68, 0x0078, 0x872a, 0x1078, 0x4982, 0x0f7f,
+	0x007c, 0x157e, 0xa184, 0x0001, 0x0040, 0x873f, 0x8108, 0x810c,
+	0x21a8, 0x2304, 0x8007, 0x2012, 0x8318, 0x8210, 0x00f0, 0x8741,
+	0x157f, 0x007c, 0x067e, 0x127e, 0x2091, 0x8000, 0x2031, 0x0001,
+	0x601c, 0xa084, 0x000f, 0x1079, 0x8766, 0x127f, 0x067f, 0x007c,
+	0x127e, 0x2091, 0x8000, 0x067e, 0x2031, 0x0000, 0x601c, 0xa084,
+	0x000f, 0x1079, 0x8766, 0x067f, 0x127f, 0x007c, 0x8780, 0x876e,
+	0x877b, 0x879c, 0x876e, 0x877b, 0x879c, 0x877b, 0x1078, 0x1328,
+	0x037e, 0x2019, 0x0010, 0x1078, 0x9a6a, 0x601f, 0x0006, 0x6003,
+	0x0007, 0x037f, 0x007c, 0xa006, 0x007c, 0xa085, 0x0001, 0x007c,
+	0x0d7e, 0x86ff, 0x00c0, 0x8797, 0x6010, 0x2068, 0x1078, 0x8a44,
+	0x0040, 0x8799, 0xa00e, 0x2001, 0x0005, 0x1078, 0x4a60, 0x1078,
+	0x8cc0, 0x1078, 0x4982, 0x1078, 0x753d, 0xa085, 0x0001, 0x0d7f,
+	0x007c, 0xa006, 0x0078, 0x8797, 0x6000, 0xa08a, 0x0010, 0x10c8,
+	0x1328, 0x1079, 0x87a4, 0x007c, 0x87b4, 0x87d4, 0x87b6, 0x87f7,
+	0x87d0, 0x87b4, 0x877b, 0x8780, 0x8780, 0x877b, 0x877b, 0x877b,
+	0x877b, 0x877b, 0x877b, 0x877b, 0x1078, 0x1328, 0x86ff, 0x00c0,
+	0x87cd, 0x0d7e, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040, 0x87c2,
+	0x1078, 0x8cc0, 0x0d7f, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f,
+	0x0002, 0x1078, 0x5bf8, 0x1078, 0x6109, 0xa085, 0x0001, 0x007c,
+	0x1078, 0x1749, 0x0078, 0x87b6, 0x0e7e, 0x2071, 0xa5ab, 0x7024,
+	0xac06, 0x00c0, 0x87dd, 0x1078, 0x6dda, 0x601c, 0xa084, 0x000f,
+	0xa086, 0x0006, 0x00c0, 0x87ef, 0x087e, 0x097e, 0x2049, 0x0001,
+	0x2c40, 0x1078, 0x7058, 0x097f, 0x087f, 0x0078, 0x87f1, 0x1078,
+	0x6cd2, 0x0e7f, 0x00c0, 0x87b6, 0x1078, 0x877b, 0x007c, 0x037e,
+	0x0e7e, 0x2071, 0xa5ab, 0x703c, 0xac06, 0x00c0, 0x8807, 0x2019,
+	0x0000, 0x1078, 0x6e6c, 0x0e7f, 0x037f, 0x0078, 0x87b6, 0x1078,
+	0x719a, 0x0e7f, 0x037f, 0x00c0, 0x87b6, 0x1078, 0x877b, 0x007c,
+	0x0c7e, 0x601c, 0xa084, 0x000f, 0x1079, 0x8818, 0x0c7f, 0x007c,
+	0x8827, 0x8895, 0x89cd, 0x8832, 0x8c01, 0x8827, 0x9a5b, 0x753d,
+	0x8895, 0x1078, 0x8c3b, 0x00c0, 0x8827, 0x1078, 0x7a05, 0x007c,
+	0x1078, 0x6010, 0x1078, 0x6109, 0x1078, 0x753d, 0x007c, 0x6017,
+	0x0001, 0x007c, 0x6010, 0xa080, 0x0019, 0x2c02, 0x6000, 0xa08a,
+	0x0010, 0x10c8, 0x1328, 0x1079, 0x883e, 0x007c, 0x884e, 0x8850,
+	0x8872, 0x8884, 0x8891, 0x884e, 0x8827, 0x8827, 0x8827, 0x8884,
+	0x8884, 0x884e, 0x884e, 0x884e, 0x884e, 0x888e, 0x1078, 0x1328,
+	0x0e7e, 0x6010, 0x2070, 0x7050, 0xc0b5, 0x7052, 0x2071, 0xa5ab,
+	0x7024, 0xac06, 0x0040, 0x886e, 0x1078, 0x6cd2, 0x6007, 0x0085,
+	0x6003, 0x000b, 0x601f, 0x0002, 0x2001, 0xa5a1, 0x2004, 0x6016,
+	0x1078, 0x5bf8, 0x1078, 0x6109, 0x0e7f, 0x007c, 0x6017, 0x0001,
+	0x0078, 0x886c, 0x0d7e, 0x6010, 0x2068, 0x6850, 0xc0b5, 0x6852,
+	0x0d7f, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x1078,
+	0x5bf8, 0x1078, 0x6109, 0x007c, 0x0d7e, 0x6017, 0x0001, 0x6010,
+	0x2068, 0x6850, 0xc0b5, 0x6852, 0x0d7f, 0x007c, 0x1078, 0x753d,
+	0x007c, 0x1078, 0x1749, 0x0078, 0x8872, 0x6000, 0xa08a, 0x0010,
+	0x10c8, 0x1328, 0x1079, 0x889d, 0x007c, 0x88ad, 0x882f, 0x88af,
+	0x88ad, 0x88af, 0x88af, 0x8828, 0x88ad, 0x8821, 0x8821, 0x88ad,
+	0x88ad, 0x88ad, 0x88ad, 0x88ad, 0x88ad, 0x1078, 0x1328, 0x0d7e,
+	0x6018, 0x2068, 0x6804, 0xa084, 0x00ff, 0x0d7f, 0xa08a, 0x000c,
+	0x10c8, 0x1328, 0x1079, 0x88bd, 0x007c, 0x88c9, 0x8971, 0x88cb,
+	0x890b, 0x88cb, 0x890b, 0x88cb, 0x88d8, 0x88c9, 0x890b, 0x88c9,
+	0x88f5, 0x1078, 0x1328, 0x6004, 0xa08e, 0x0016, 0x0040, 0x8906,
+	0xa08e, 0x0004, 0x0040, 0x8906, 0xa08e, 0x0002, 0x0040, 0x8906,
+	0x6004, 0x1078, 0x8c3b, 0x0040, 0x898c, 0xa08e, 0x0021, 0x0040,
+	0x8990, 0xa08e, 0x0022, 0x0040, 0x898c, 0xa08e, 0x003d, 0x0040,
+	0x8990, 0xa08e, 0x0039, 0x0040, 0x8994, 0xa08e, 0x0035, 0x0040,
+	0x8994, 0xa08e, 0x001e, 0x0040, 0x8908, 0xa08e, 0x0001, 0x00c0,
+	0x8904, 0x0d7e, 0x6018, 0x2068, 0x6804, 0xa084, 0x00ff, 0x0d7f,
+	0xa086, 0x0006, 0x0040, 0x8906, 0x1078, 0x2813, 0x1078, 0x7a05,
+	0x1078, 0x8c01, 0x007c, 0x0c7e, 0x0d7e, 0x6104, 0xa186, 0x0016,
+	0x0040, 0x8961, 0xa186, 0x0002, 0x00c0, 0x8934, 0x6018, 0x2068,
+	0x68a0, 0xd0bc, 0x00c0, 0x89b8, 0x6840, 0xa084, 0x00ff, 0xa005,
+	0x0040, 0x8934, 0x8001, 0x6842, 0x6013, 0x0000, 0x601f, 0x0007,
+	0x6017, 0x0398, 0x1078, 0x74d7, 0x0040, 0x8934, 0x2d00, 0x601a,
+	0x601f, 0x0001, 0x0078, 0x8961, 0x0d7f, 0x0c7f, 0x6004, 0xa08e,
+	0x0002, 0x00c0, 0x8952, 0x6018, 0xa080, 0x0028, 0x2004, 0xa086,
+	0x007e, 0x00c0, 0x8952, 0x2009, 0xa332, 0x2104, 0xc085, 0x200a,
+	0x0e7e, 0x2071, 0xa300, 0x1078, 0x41f5, 0x0e7f, 0x1078, 0x7a05,
+	0x0078, 0x8956, 0x1078, 0x7a05, 0x1078, 0x2813, 0x0e7e, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x2839, 0x127f, 0x0e7f, 0x1078, 0x8c01,
+	0x007c, 0x2001, 0x0002, 0x1078, 0x443f, 0x6003, 0x0001, 0x6007,
+	0x0002, 0x1078, 0x5c45, 0x1078, 0x6109, 0x0d7f, 0x0c7f, 0x0078,
+	0x8960, 0x0c7e, 0x0d7e, 0x6104, 0xa186, 0x0016, 0x0040, 0x8961,
+	0x6018, 0x2068, 0x6840, 0xa084, 0x00ff, 0xa005, 0x0040, 0x8934,
+	0x8001, 0x6842, 0x6003, 0x0001, 0x1078, 0x5c45, 0x1078, 0x6109,
+	0x0d7f, 0x0c7f, 0x0078, 0x8960, 0x1078, 0x7a05, 0x0078, 0x8908,
+	0x1078, 0x7a28, 0x0078, 0x8908, 0x0d7e, 0x2c68, 0x6104, 0x1078,
+	0x8ef5, 0x0d7f, 0x0040, 0x89a0, 0x1078, 0x753d, 0x0078, 0x89b7,
+	0x6004, 0x8007, 0x6130, 0xa18c, 0x00ff, 0xa105, 0x6032, 0x6007,
+	0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x6038, 0x600a, 0x2001,
+	0xa5a1, 0x2004, 0x6016, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x007c,
+	0x0d7f, 0x0c7f, 0x1078, 0x7a05, 0x1078, 0x2813, 0x0e7e, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x2839, 0x6013, 0x0000, 0x601f, 0x0007,
+	0x6017, 0x0398, 0x127f, 0x0e7f, 0x007c, 0x6000, 0xa08a, 0x0010,
+	0x10c8, 0x1328, 0x1079, 0x89d5, 0x007c, 0x89e5, 0x89e5, 0x89e5,
+	0x89e5, 0x89e5, 0x89e5, 0x89e5, 0x89e5, 0x89e5, 0x8827, 0x89e5,
+	0x882f, 0x89e7, 0x882f, 0x89f5, 0x89e5, 0x1078, 0x1328, 0x6004,
+	0xa086, 0x008b, 0x0040, 0x89f5, 0x6007, 0x008b, 0x6003, 0x000d,
+	0x1078, 0x5bf8, 0x1078, 0x6109, 0x007c, 0x1078, 0x8bf4, 0x1078,
+	0x8a44, 0x0040, 0x8a2d, 0x1078, 0x2813, 0x0d7e, 0x1078, 0x8a44,
+	0x0040, 0x8a0f, 0x6010, 0x2068, 0x6837, 0x0103, 0x684b, 0x0006,
+	0x6847, 0x0000, 0x6850, 0xc0ed, 0x6852, 0x1078, 0x4982, 0x2c68,
+	0x1078, 0x74d7, 0x0040, 0x8a1d, 0x6818, 0x601a, 0x0c7e, 0x2d60,
+	0x1078, 0x8c01, 0x0c7f, 0x0078, 0x8a1e, 0x2d60, 0x0d7f, 0x6013,
+	0x0000, 0x601f, 0x0001, 0x6007, 0x0001, 0x6003, 0x0001, 0x1078,
+	0x5c45, 0x1078, 0x6109, 0x0078, 0x8a2f, 0x1078, 0x8c01, 0x007c,
+	0xa284, 0x000f, 0x00c0, 0x8a41, 0xa282, 0xaa00, 0x0048, 0x8a41,
+	0x2001, 0xa315, 0x2004, 0xa202, 0x00c8, 0x8a41, 0xa085, 0x0001,
+	0x007c, 0xa006, 0x0078, 0x8a40, 0x027e, 0x0e7e, 0x2071, 0xa300,
+	0x6210, 0x7058, 0xa202, 0x0048, 0x8a56, 0x705c, 0xa202, 0x00c8,
+	0x8a56, 0xa085, 0x0001, 0x0e7f, 0x027f, 0x007c, 0xa006, 0x0078,
+	0x8a53, 0x0e7e, 0x0c7e, 0x037e, 0x007e, 0x127e, 0x2091, 0x8000,
+	0x2061, 0xaa00, 0x2071, 0xa300, 0x7344, 0x7060, 0xa302, 0x00c8,
+	0x8a83, 0x601c, 0xa206, 0x00c0, 0x8a7b, 0x1078, 0x8d66, 0x0040,
+	0x8a7b, 0x1078, 0x8c3b, 0x00c0, 0x8a77, 0x1078, 0x7a05, 0x0c7e,
+	0x1078, 0x753d, 0x0c7f, 0xace0, 0x0010, 0x7054, 0xac02, 0x00c8,
+	0x8a83, 0x0078, 0x8a64, 0x127f, 0x007f, 0x037f, 0x0c7f, 0x0e7f,
+	0x007c, 0x0e7e, 0x0c7e, 0x017e, 0xa188, 0xa434, 0x210c, 0x81ff,
+	0x0040, 0x8aa1, 0x2061, 0xaa00, 0x2071, 0xa300, 0x017e, 0x1078,
+	0x74d7, 0x017f, 0x0040, 0x8aa4, 0x611a, 0x1078, 0x2813, 0x1078,
+	0x753d, 0xa006, 0x0078, 0x8aa6, 0xa085, 0x0001, 0x017f, 0x0c7f,
+	0x0e7f, 0x007c, 0x0c7e, 0x057e, 0x127e, 0x2091, 0x8000, 0x0c7e,
+	0x1078, 0x74d7, 0x057f, 0x0040, 0x8ac3, 0x6612, 0x651a, 0x601f,
+	0x0003, 0x2009, 0x004b, 0x1078, 0x756c, 0xa085, 0x0001, 0x127f,
+	0x057f, 0x0c7f, 0x007c, 0xa006, 0x0078, 0x8abf, 0x0c7e, 0x057e,
+	0x127e, 0x2091, 0x8000, 0x62a0, 0x0c7e, 0x1078, 0x74d7, 0x057f,
+	0x0040, 0x8af1, 0x6013, 0x0000, 0x651a, 0x601f, 0x0003, 0x0c7e,
+	0x2560, 0x1078, 0x471b, 0x0c7f, 0x1078, 0x5d53, 0x077e, 0x2039,
+	0x0000, 0x1078, 0x5c78, 0x2c08, 0x1078, 0x9c38, 0x077f, 0x2009,
+	0x004c, 0x1078, 0x756c, 0xa085, 0x0001, 0x127f, 0x057f, 0x0c7f,
+	0x007c, 0xa006, 0x0078, 0x8aed, 0x0f7e, 0x0c7e, 0x047e, 0x0c7e,
+	0x1078, 0x74d7, 0x2c78, 0x0c7f, 0x0040, 0x8b0e, 0x7e12, 0x2c00,
+	0x781a, 0x781f, 0x0003, 0x2021, 0x0005, 0x1078, 0x8b4e, 0x2f60,
+	0x2009, 0x004d, 0x1078, 0x756c, 0xa085, 0x0001, 0x047f, 0x0c7f,
+	0x0f7f, 0x007c, 0x0f7e, 0x0c7e, 0x047e, 0x0c7e, 0x1078, 0x74d7,
+	0x2c78, 0x0c7f, 0x0040, 0x8b2c, 0x7e12, 0x2c00, 0x781a, 0x781f,
+	0x0003, 0x2021, 0x0005, 0x1078, 0x8b4e, 0x2f60, 0x2009, 0x004e,
+	0x1078, 0x756c, 0xa085, 0x0001, 0x047f, 0x0c7f, 0x0f7f, 0x007c,
+	0x0f7e, 0x0c7e, 0x047e, 0x0c7e, 0x1078, 0x74d7, 0x2c78, 0x0c7f,
+	0x0040, 0x8b4a, 0x7e12, 0x2c00, 0x781a, 0x781f, 0x0003, 0x2021,
+	0x0004, 0x1078, 0x8b4e, 0x2f60, 0x2009, 0x0052, 0x1078, 0x756c,
+	0xa085, 0x0001, 0x047f, 0x0c7f, 0x0f7f, 0x007c, 0x097e, 0x077e,
+	0x127e, 0x2091, 0x8000, 0x1078, 0x46a7, 0x0040, 0x8b5b, 0x2001,
+	0x8b53, 0x0078, 0x8b61, 0x1078, 0x466d, 0x0040, 0x8b6a, 0x2001,
+	0x8b5b, 0x007e, 0xa00e, 0x2400, 0x1078, 0x4a60, 0x1078, 0x4982,
+	0x007f, 0x007a, 0x2418, 0x1078, 0x5fa7, 0x62a0, 0x087e, 0x2041,
+	0x0001, 0x2039, 0x0001, 0x2608, 0x1078, 0x5d6d, 0x087f, 0x1078,
+	0x5c78, 0x2f08, 0x2648, 0x1078, 0x9c38, 0x613c, 0x81ff, 0x1040,
+	0x5e21, 0x127f, 0x077f, 0x097f, 0x007c, 0x0c7e, 0x127e, 0x2091,
+	0x8000, 0x0c7e, 0x1078, 0x74d7, 0x017f, 0x0040, 0x8b9e, 0x660a,
+	0x611a, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x001f, 0x1078,
+	0x756c, 0xa085, 0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078,
+	0x8b9b, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x0c7e, 0x1078, 0x74d7,
+	0x017f, 0x0040, 0x8bba, 0x660a, 0x611a, 0x601f, 0x0008, 0x2d00,
+	0x6012, 0x2009, 0x0021, 0x1078, 0x756c, 0xa085, 0x0001, 0x127f,
+	0x0c7f, 0x007c, 0xa006, 0x0078, 0x8bb7, 0x0c7e, 0x127e, 0x2091,
+	0x8000, 0x0c7e, 0x1078, 0x74d7, 0x017f, 0x0040, 0x8bd6, 0x660a,
+	0x611a, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x003d, 0x1078,
+	0x756c, 0xa085, 0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078,
+	0x8bd3, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x0c7e, 0x1078, 0x74d7,
+	0x017f, 0x0040, 0x8bf1, 0x611a, 0x601f, 0x0001, 0x2d00, 0x6012,
+	0x2009, 0x0000, 0x1078, 0x756c, 0xa085, 0x0001, 0x127f, 0x0c7f,
+	0x007c, 0xa006, 0x0078, 0x8bee, 0x027e, 0x0d7e, 0x6218, 0x2268,
+	0x6a3c, 0x82ff, 0x0040, 0x8bfe, 0x8211, 0x6a3e, 0x0d7f, 0x027f,
+	0x007c, 0x007e, 0x6000, 0xa086, 0x0000, 0x0040, 0x8c13, 0x6013,
+	0x0000, 0x601f, 0x0007, 0x2001, 0xa5a1, 0x2004, 0x6016, 0x1078,
+	0xa134, 0x603f, 0x0000, 0x007f, 0x007c, 0x067e, 0x0c7e, 0x0d7e,
+	0x2031, 0xa352, 0x2634, 0xd6e4, 0x0040, 0x8c23, 0x6618, 0x2660,
+	0x6e48, 0x1078, 0x461b, 0x0d7f, 0x0c7f, 0x067f, 0x007c, 0x007e,
+	0x017e, 0x6004, 0xa08e, 0x0002, 0x0040, 0x8c38, 0xa08e, 0x0003,
+	0x0040, 0x8c38, 0xa08e, 0x0004, 0x0040, 0x8c38, 0xa085, 0x0001,
+	0x017f, 0x007f, 0x007c, 0x007e, 0x0d7e, 0x6010, 0xa06d, 0x0040,
+	0x8c48, 0x6838, 0xd0fc, 0x0040, 0x8c48, 0xa006, 0x0078, 0x8c4a,
+	0xa085, 0x0001, 0x0d7f, 0x007f, 0x007c, 0x0c7e, 0x127e, 0x2091,
+	0x8000, 0x0c7e, 0x1078, 0x74d7, 0x017f, 0x0040, 0x8c67, 0x611a,
+	0x601f, 0x0001, 0x2d00, 0x6012, 0x1078, 0x2813, 0x2009, 0x0028,
+	0x1078, 0x756c, 0xa085, 0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006,
+	0x0078, 0x8c64, 0xa186, 0x0015, 0x00c0, 0x8c7f, 0x2011, 0xa31f,
+	0x2204, 0xa086, 0x0074, 0x00c0, 0x8c7f, 0x1078, 0x7d0d, 0x6003,
+	0x0001, 0x6007, 0x0029, 0x1078, 0x5c45, 0x0078, 0x8c83, 0x1078,
+	0x7a05, 0x1078, 0x753d, 0x007c, 0xa186, 0x0016, 0x00c0, 0x8c8e,
+	0x2001, 0x0004, 0x1078, 0x443f, 0x0078, 0x8caf, 0xa186, 0x0015,
+	0x00c0, 0x8cb3, 0x2011, 0xa31f, 0x2204, 0xa086, 0x0014, 0x00c0,
+	0x8cb3, 0x0d7e, 0x6018, 0x2068, 0x1078, 0x457d, 0x0d7f, 0x1078,
+	0x7dba, 0x00c0, 0x8cb3, 0x0d7e, 0x6018, 0x2068, 0x6890, 0x0d7f,
+	0xa005, 0x0040, 0x8cb3, 0x2001, 0x0006, 0x1078, 0x443f, 0x1078,
+	0x7608, 0x0078, 0x8cb7, 0x1078, 0x7a05, 0x1078, 0x753d, 0x007c,
+	0x6848, 0xa086, 0x0005, 0x00c0, 0x8cbf, 0x1078, 0x8cc0, 0x007c,
+	0x6850, 0xc0ad, 0x6852, 0x007c, 0x0e7e, 0x2071, 0xa88c, 0x7014,
+	0xd0e4, 0x0040, 0x8cd5, 0x6013, 0x0000, 0x6003, 0x0001, 0x6007,
+	0x0050, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x0e7f, 0x007c, 0x0c7e,
+	0x0f7e, 0x2c78, 0x1078, 0x4893, 0x0f7f, 0x0040, 0x8ce4, 0x601c,
+	0xa084, 0x000f, 0x1079, 0x8ce6, 0x0c7f, 0x007c, 0x8827, 0x8cf1,
+	0x8cf4, 0x8cf7, 0x9f00, 0x9f1c, 0x9f1f, 0x8827, 0x8827, 0x1078,
+	0x1328, 0x0005, 0x0005, 0x007c, 0x0005, 0x0005, 0x007c, 0x1078,
+	0x8cfa, 0x007c, 0x0f7e, 0x2c78, 0x1078, 0x4893, 0x0040, 0x8d29,
+	0x1078, 0x74d7, 0x00c0, 0x8d0a, 0x2001, 0xa5a2, 0x2004, 0x783e,
+	0x0078, 0x8d29, 0x7818, 0x601a, 0x781c, 0xa086, 0x0003, 0x0040,
+	0x8d17, 0x7808, 0x6036, 0x2f00, 0x603a, 0x0078, 0x8d1b, 0x7808,
+	0x603a, 0x2f00, 0x6036, 0x602a, 0x601f, 0x0001, 0x6007, 0x0035,
+	0x6003, 0x0001, 0x7920, 0x6122, 0x1078, 0x5bf8, 0x1078, 0x6109,
+	0x2f60, 0x0f7f, 0x007c, 0x017e, 0x0f7e, 0x682c, 0x6032, 0xa08e,
+	0x0001, 0x0040, 0x8d3c, 0xa086, 0x0005, 0x0040, 0x8d40, 0xa006,
+	0x602a, 0x602e, 0x0078, 0x8d51, 0x6824, 0xc0f4, 0xc0d5, 0x6826,
+	0x6810, 0x2078, 0x787c, 0x6938, 0xa102, 0x7880, 0x6934, 0xa103,
+	0x00c8, 0x8d37, 0x6834, 0x602a, 0x6838, 0xa084, 0xfffc, 0x683a,
+	0x602e, 0x2d00, 0x6036, 0x6808, 0x603a, 0x6918, 0x611a, 0x6920,
+	0x6122, 0x601f, 0x0001, 0x6007, 0x0039, 0x6003, 0x0001, 0x1078,
+	0x5bf8, 0x6803, 0x0002, 0x0f7f, 0x017f, 0x007c, 0x007e, 0x017e,
+	0x6004, 0xa08e, 0x0034, 0x0040, 0x8d8b, 0xa08e, 0x0035, 0x0040,
+	0x8d8b, 0xa08e, 0x0036, 0x0040, 0x8d8b, 0xa08e, 0x0037, 0x0040,
+	0x8d8b, 0xa08e, 0x0038, 0x0040, 0x8d8b, 0xa08e, 0x0039, 0x0040,
+	0x8d8b, 0xa08e, 0x003a, 0x0040, 0x8d8b, 0xa08e, 0x003b, 0x0040,
+	0x8d8b, 0xa085, 0x0001, 0x017f, 0x007f, 0x007c, 0x0f7e, 0x2c78,
+	0x1078, 0x4893, 0x00c0, 0x8d98, 0xa085, 0x0001, 0x0078, 0x8da7,
+	0x6024, 0xd0f4, 0x00c0, 0x8da6, 0xc0f5, 0x6026, 0x6010, 0x2078,
+	0x7828, 0x603a, 0x782c, 0x6036, 0x1078, 0x1749, 0xa006, 0x0f7f,
+	0x007c, 0x007e, 0x017e, 0x027e, 0x037e, 0x0e7e, 0x2001, 0xa59c,
+	0x200c, 0x8000, 0x2014, 0x2001, 0x0032, 0x1078, 0x5a98, 0x2001,
+	0xa5a0, 0x82ff, 0x00c0, 0x8dbe, 0x2011, 0x0002, 0x2202, 0x2001,
+	0xa59e, 0x200c, 0x8000, 0x2014, 0x2071, 0xa58c, 0x711a, 0x721e,
+	0x2001, 0x0064, 0x1078, 0x5a98, 0x2001, 0xa5a1, 0x82ff, 0x00c0,
+	0x8dd3, 0x2011, 0x0002, 0x2202, 0x2009, 0xa5a2, 0xa280, 0x000a,
+	0x200a, 0x0e7f, 0x037f, 0x027f, 0x017f, 0x007f, 0x007c, 0x007e,
+	0x0e7e, 0x2001, 0xa5a0, 0x2003, 0x0028, 0x2001, 0xa5a1, 0x2003,
+	0x0014, 0x2071, 0xa58c, 0x701b, 0x0000, 0x701f, 0x07d0, 0x2001,
+	0xa5a2, 0x2003, 0x001e, 0x0e7f, 0x007f, 0x007c, 0x0c7e, 0x127e,
+	0x2091, 0x8000, 0x0c7e, 0x1078, 0x74d7, 0x017f, 0x0040, 0x8e0e,
+	0x611a, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x0033, 0x1078,
+	0x756c, 0xa085, 0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078,
+	0x8e0b, 0x0d7e, 0x0e7e, 0x0f7e, 0x2071, 0xa300, 0xa186, 0x0015,
+	0x00c0, 0x8e40, 0x707c, 0xa086, 0x0018, 0x00c0, 0x8e40, 0x6010,
+	0x2068, 0x6a3c, 0xd2e4, 0x00c0, 0x8e34, 0x2c78, 0x1078, 0x62c6,
+	0x0040, 0x8e48, 0x7068, 0x6a50, 0xa206, 0x00c0, 0x8e3c, 0x706c,
+	0x6a54, 0xa206, 0x00c0, 0x8e3c, 0x6218, 0xa290, 0x0028, 0x2214,
+	0x2009, 0x0000, 0x1078, 0x285b, 0x1078, 0x7608, 0x0078, 0x8e44,
+	0x1078, 0x7a05, 0x1078, 0x753d, 0x0f7f, 0x0e7f, 0x0d7f, 0x007c,
+	0x704c, 0xa080, 0x293f, 0x2004, 0x6a54, 0xa206, 0x0040, 0x8e34,
+	0x0078, 0x8e3c, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x0c7e, 0x1078,
+	0x74d7, 0x017f, 0x0040, 0x8e6a, 0x611a, 0x601f, 0x0001, 0x2d00,
+	0x6012, 0x2009, 0x0043, 0x1078, 0x756c, 0xa085, 0x0001, 0x127f,
+	0x0c7f, 0x007c, 0xa006, 0x0078, 0x8e67, 0x0d7e, 0x0e7e, 0x0f7e,
+	0x2071, 0xa300, 0xa186, 0x0015, 0x00c0, 0x8e93, 0x707c, 0xa086,
+	0x0004, 0x00c0, 0x8e93, 0x6010, 0xa0e8, 0x000f, 0x2c78, 0x1078,
+	0x62c6, 0x0040, 0x8e9b, 0x7068, 0x6a08, 0xa206, 0x00c0, 0x8e8f,
+	0x706c, 0x6a0c, 0xa206, 0x00c0, 0x8e8f, 0x1078, 0x2813, 0x1078,
+	0x7608, 0x0078, 0x8e97, 0x1078, 0x7a05, 0x1078, 0x753d, 0x0f7f,
+	0x0e7f, 0x0d7f, 0x007c, 0x704c, 0xa080, 0x293f, 0x2004, 0x6a0c,
+	0xa206, 0x0040, 0x8e8d, 0x0078, 0x8e8f, 0x017e, 0x027e, 0x684c,
+	0xd0ac, 0x0040, 0x8ebd, 0x6914, 0x6a10, 0x2100, 0xa205, 0x0040,
+	0x8ebd, 0x6860, 0xa106, 0x00c0, 0x8eb9, 0x685c, 0xa206, 0x0040,
+	0x8ebd, 0x6962, 0x6a5e, 0xa085, 0x0001, 0x027f, 0x017f, 0x007c,
+	0x0e7e, 0x127e, 0x2071, 0xa300, 0x2091, 0x8000, 0x7544, 0xa582,
+	0x0001, 0x0048, 0x8ef2, 0x7048, 0x2060, 0x6000, 0xa086, 0x0000,
+	0x0040, 0x8ede, 0xace0, 0x0010, 0x7054, 0xac02, 0x00c8, 0x8eda,
+	0x0078, 0x8ecd, 0x2061, 0xaa00, 0x0078, 0x8ecd, 0x6003, 0x0008,
+	0x8529, 0x7546, 0xaca8, 0x0010, 0x7054, 0xa502, 0x00c8, 0x8eee,
+	0x754a, 0xa085, 0x0001, 0x127f, 0x0e7f, 0x007c, 0x704b, 0xaa00,
+	0x0078, 0x8ee9, 0xa006, 0x0078, 0x8eeb, 0x0c7e, 0x027e, 0x017e,
+	0xa186, 0x0035, 0x0040, 0x8eff, 0x6a34, 0x0078, 0x8f00, 0x6a28,
+	0x1078, 0x8a30, 0x0040, 0x8f29, 0x2260, 0x611c, 0xa186, 0x0003,
+	0x0040, 0x8f0e, 0xa186, 0x0006, 0x00c0, 0x8f25, 0x6834, 0xa206,
+	0x0040, 0x8f1d, 0x6838, 0xa206, 0x00c0, 0x8f25, 0x6108, 0x6834,
+	0xa106, 0x00c0, 0x8f25, 0x0078, 0x8f22, 0x6008, 0x6938, 0xa106,
+	0x00c0, 0x8f25, 0x6018, 0x6918, 0xa106, 0x017f, 0x027f, 0x0c7f,
+	0x007c, 0xa085, 0x0001, 0x0078, 0x8f25, 0x067e, 0x6000, 0xa0b2,
+	0x0010, 0x10c8, 0x1328, 0x1079, 0x8f37, 0x067f, 0x007c, 0x8f47,
+	0x93bb, 0x94d3, 0x8f47, 0x8f47, 0x8f47, 0x8f47, 0x8f47, 0x8f81,
+	0x955e, 0x8f47, 0x8f47, 0x8f47, 0x8f47, 0x8f47, 0x8f47, 0x1078,
+	0x1328, 0x067e, 0x6000, 0xa0b2, 0x0010, 0x10c8, 0x1328, 0x1079,
+	0x8f53, 0x067f, 0x007c, 0x8f63, 0x99f6, 0x8f63, 0x8f63, 0x8f63,
+	0x8f63, 0x8f63, 0x8f63, 0x99b4, 0x9a44, 0x8f63, 0xa053, 0xa087,
+	0xa053, 0xa087, 0x8f63, 0x1078, 0x1328, 0x067e, 0x6000, 0xa0b2,
+	0x0010, 0x10c8, 0x1328, 0x1079, 0x8f6f, 0x067f, 0x007c, 0x8f7f,
+	0x969f, 0x976a, 0x9798, 0x9813, 0x8f7f, 0x9919, 0x98c1, 0x956a,
+	0x9988, 0x999e, 0x8f7f, 0x8f7f, 0x8f7f, 0x8f7f, 0x8f7f, 0x1078,
+	0x1328, 0xa1b2, 0x0044, 0x10c8, 0x1328, 0x2100, 0x0079, 0x8f88,
+	0x8fc8, 0x919a, 0x8fc8, 0x8fc8, 0x8fc8, 0x91a2, 0x8fc8, 0x8fc8,
+	0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8,
+	0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fca,
+	0x902d, 0x9038, 0x9081, 0x909c, 0x911b, 0x918b, 0x8fc8, 0x8fc8,
+	0x91a6, 0x8fc8, 0x8fc8, 0x91b5, 0x91bc, 0x8fc8, 0x8fc8, 0x8fc8,
+	0x8fc8, 0x8fc8, 0x91ea, 0x8fc8, 0x8fc8, 0x91f5, 0x8fc8, 0x8fc8,
+	0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x920a, 0x8fc8, 0x8fc8, 0x8fc8,
+	0x9291, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x8fc8, 0x9305,
+	0x1078, 0x1328, 0x1078, 0x4897, 0x00c0, 0x8fd7, 0x2001, 0xa332,
+	0x2004, 0xa084, 0x0009, 0xa086, 0x0008, 0x00c0, 0x8fdf, 0x6007,
+	0x0009, 0x602b, 0x0009, 0x6013, 0x0000, 0x0078, 0x9195, 0x1078,
+	0x4887, 0x0e7e, 0x0c7e, 0x037e, 0x027e, 0x017e, 0x6218, 0x2270,
+	0x72a0, 0x027e, 0x2019, 0x0029, 0x1078, 0x5d53, 0x077e, 0x2039,
+	0x0000, 0x1078, 0x5c78, 0x2c08, 0x1078, 0x9c38, 0x077f, 0x017f,
+	0x2e60, 0x1078, 0x471b, 0x017f, 0x027f, 0x037f, 0x0c7f, 0x0e7f,
+	0x6618, 0x0c7e, 0x2660, 0x1078, 0x4513, 0x0c7f, 0xa6b0, 0x0001,
+	0x2634, 0xa684, 0x00ff, 0xa082, 0x0006, 0x0048, 0x901f, 0x1078,
+	0x9b6c, 0x00c0, 0x907b, 0x1078, 0x9afd, 0x00c0, 0x901b, 0x6007,
+	0x0008, 0x0078, 0x9195, 0x6007, 0x0009, 0x0078, 0x9195, 0x1078,
+	0x9d45, 0x0040, 0x9029, 0x1078, 0x9b6c, 0x0040, 0x9013, 0x0078,
+	0x907b, 0x6013, 0x1900, 0x0078, 0x901b, 0x6106, 0x1078, 0x9aa8,
+	0x6007, 0x0006, 0x0078, 0x9195, 0x6007, 0x0007, 0x0078, 0x9195,
+	0x1078, 0xa0bf, 0x00c0, 0x9340, 0x0d7e, 0x6618, 0x2668, 0x6e04,
+	0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0040, 0x905d, 0xa686,
+	0x0004, 0x0040, 0x905d, 0x6e04, 0xa6b4, 0x00ff, 0xa686, 0x0006,
+	0x0040, 0x905d, 0xa686, 0x0004, 0x0040, 0x905d, 0xa686, 0x0005,
+	0x0040, 0x905d, 0x0d7f, 0x0078, 0x907b, 0x1078, 0x9bd2, 0x00c0,
+	0x9076, 0xa686, 0x0006, 0x00c0, 0x906f, 0x027e, 0x6218, 0xa290,
+	0x0028, 0x2214, 0x2009, 0x0000, 0x1078, 0x285b, 0x027f, 0x1078,
+	0x457d, 0x6007, 0x000a, 0x0d7f, 0x0078, 0x9195, 0x6007, 0x000b,
+	0x0d7f, 0x0078, 0x9195, 0x1078, 0x2813, 0x6007, 0x0001, 0x0078,
+	0x9195, 0x1078, 0xa0bf, 0x00c0, 0x9340, 0x6618, 0x0d7e, 0x2668,
+	0x6e04, 0x0d7f, 0xa686, 0x0707, 0x0040, 0x907b, 0x027e, 0x6218,
+	0xa290, 0x0028, 0x2214, 0x2009, 0x0000, 0x1078, 0x285b, 0x027f,
+	0x6007, 0x000c, 0x0078, 0x9195, 0x1078, 0x4897, 0x00c0, 0x90a9,
+	0x2001, 0xa332, 0x2004, 0xa084, 0x0009, 0xa086, 0x0008, 0x00c0,
+	0x90b1, 0x6007, 0x0009, 0x602b, 0x0009, 0x6013, 0x0000, 0x0078,
+	0x9195, 0x1078, 0x4887, 0x6618, 0xa6b0, 0x0001, 0x2634, 0xa684,
+	0x00ff, 0xa082, 0x0006, 0x0048, 0x90f5, 0xa6b4, 0xff00, 0x8637,
+	0xa686, 0x0004, 0x0040, 0x90c8, 0xa686, 0x0006, 0x00c0, 0x907b,
+	0x1078, 0x9be1, 0x00c0, 0x90d0, 0x6007, 0x000e, 0x0078, 0x9195,
+	0x047e, 0x6418, 0xa4a0, 0x0028, 0x2424, 0xa4a4, 0x00ff, 0x8427,
+	0x047e, 0x1078, 0x2813, 0x047f, 0x017e, 0xa006, 0x2009, 0xa352,
+	0x210c, 0xd1a4, 0x0040, 0x90ef, 0x2009, 0x0029, 0x1078, 0x9ec0,
+	0x6018, 0x0d7e, 0x2068, 0x6800, 0xc0e5, 0x6802, 0x0d7f, 0x017f,
+	0x047f, 0x6007, 0x0001, 0x0078, 0x9195, 0x2001, 0x0001, 0x1078,
+	0x442b, 0x157e, 0x017e, 0x027e, 0x037e, 0x20a9, 0x0004, 0x2019,
+	0xa305, 0x2011, 0xa890, 0x1078, 0x7e55, 0x037f, 0x027f, 0x017f,
+	0x157f, 0xa005, 0x0040, 0x9115, 0xa6b4, 0xff00, 0x8637, 0xa686,
+	0x0006, 0x0040, 0x90c8, 0x0078, 0x907b, 0x6013, 0x1900, 0x6007,
+	0x0009, 0x0078, 0x9195, 0x1078, 0x4897, 0x00c0, 0x9128, 0x2001,
+	0xa332, 0x2004, 0xa084, 0x0009, 0xa086, 0x0008, 0x00c0, 0x9130,
+	0x6007, 0x0009, 0x602b, 0x0009, 0x6013, 0x0000, 0x0078, 0x9195,
+	0x1078, 0x4887, 0x6618, 0xa6b0, 0x0001, 0x2634, 0xa684, 0x00ff,
+	0xa082, 0x0006, 0x0048, 0x9178, 0xa6b4, 0xff00, 0x8637, 0xa686,
+	0x0004, 0x0040, 0x9147, 0xa686, 0x0006, 0x00c0, 0x907b, 0x1078,
+	0x9c0c, 0x00c0, 0x9153, 0x1078, 0x9afd, 0x00c0, 0x9153, 0x6007,
+	0x0010, 0x0078, 0x9195, 0x047e, 0x6418, 0xa4a0, 0x0028, 0x2424,
+	0xa4a4, 0x00ff, 0x8427, 0x047e, 0x1078, 0x2813, 0x047f, 0x017e,
+	0xa006, 0x2009, 0xa352, 0x210c, 0xd1a4, 0x0040, 0x9172, 0x2009,
+	0x0029, 0x1078, 0x9ec0, 0x6018, 0x0d7e, 0x2068, 0x6800, 0xc0e5,
+	0x6802, 0x0d7f, 0x017f, 0x047f, 0x6007, 0x0001, 0x0078, 0x9195,
+	0x1078, 0x9d45, 0x0040, 0x9185, 0xa6b4, 0xff00, 0x8637, 0xa686,
+	0x0006, 0x0040, 0x9147, 0x0078, 0x907b, 0x6013, 0x1900, 0x6007,
+	0x0009, 0x0078, 0x9195, 0x1078, 0xa0bf, 0x00c0, 0x9340, 0x1078,
+	0x9343, 0x00c0, 0x907b, 0x6007, 0x0012, 0x6003, 0x0001, 0x1078,
+	0x5c45, 0x007c, 0x6007, 0x0001, 0x6003, 0x0001, 0x1078, 0x5c45,
+	0x0078, 0x9199, 0x6007, 0x0005, 0x0078, 0x919c, 0x1078, 0xa0bf,
+	0x00c0, 0x9340, 0x1078, 0x9343, 0x00c0, 0x907b, 0x6007, 0x0020,
+	0x6003, 0x0001, 0x1078, 0x5c45, 0x007c, 0x6007, 0x0023, 0x6003,
+	0x0001, 0x1078, 0x5c45, 0x007c, 0x1078, 0xa0bf, 0x00c0, 0x9340,
+	0x1078, 0x9343, 0x00c0, 0x907b, 0x017e, 0x027e, 0x2011, 0xa890,
+	0x2214, 0x2c08, 0x1078, 0x9e8c, 0x00c0, 0x91de, 0x2160, 0x6007,
+	0x0026, 0x6013, 0x1700, 0x2011, 0xa889, 0x2214, 0xa296, 0xffff,
+	0x00c0, 0x91e3, 0x6007, 0x0025, 0x0078, 0x91e3, 0x1078, 0x753d,
+	0x2160, 0x6007, 0x0025, 0x6003, 0x0001, 0x1078, 0x5c45, 0x027f,
+	0x017f, 0x007c, 0x6106, 0x1078, 0x9363, 0x6007, 0x002b, 0x0078,
+	0x9195, 0x6007, 0x002c, 0x0078, 0x9195, 0x1078, 0xa0bf, 0x00c0,
+	0x9340, 0x1078, 0x9343, 0x00c0, 0x907b, 0x6106, 0x1078, 0x9368,
+	0x00c0, 0x9206, 0x6007, 0x002e, 0x0078, 0x9195, 0x6007, 0x002f,
+	0x0078, 0x9195, 0x0e7e, 0x0d7e, 0x0c7e, 0x6018, 0xa080, 0x0001,
+	0x200c, 0xa184, 0x00ff, 0xa086, 0x0006, 0x0040, 0x9223, 0xa184,
+	0xff00, 0x8007, 0xa086, 0x0006, 0x0040, 0x9223, 0x0c7f, 0x0d7f,
+	0x0e7f, 0x0078, 0x919a, 0x2001, 0xa371, 0x2004, 0xd0e4, 0x0040,
+	0x928d, 0x2071, 0xa88c, 0x7010, 0x6036, 0x7014, 0x603a, 0x7108,
+	0x720c, 0x2001, 0xa352, 0x2004, 0xd0a4, 0x0040, 0x9241, 0x6018,
+	0x2068, 0x6810, 0xa106, 0x00c0, 0x9241, 0x6814, 0xa206, 0x0040,
+	0x9265, 0x2001, 0xa352, 0x2004, 0xd0ac, 0x00c0, 0x9281, 0x2069,
+	0xa300, 0x686c, 0xa206, 0x00c0, 0x9281, 0x6868, 0xa106, 0x00c0,
+	0x9281, 0x7210, 0x1078, 0x8a30, 0x0040, 0x9287, 0x1078, 0x9f31,
+	0x0040, 0x9287, 0x622a, 0x6007, 0x0036, 0x6003, 0x0001, 0x1078,
+	0x5bf8, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0x7214, 0xa286, 0xffff,
+	0x0040, 0x9277, 0x1078, 0x8a30, 0x0040, 0x9287, 0xa280, 0x0002,
+	0x2004, 0x7110, 0xa106, 0x00c0, 0x9287, 0x0078, 0x9252, 0x7210,
+	0x2c08, 0x1078, 0x9e8c, 0x2c10, 0x2160, 0x0040, 0x9287, 0x0078,
+	0x9252, 0x6007, 0x0037, 0x6013, 0x1500, 0x0078, 0x925d, 0x6007,
+	0x0037, 0x6013, 0x1700, 0x0078, 0x925d, 0x6007, 0x0012, 0x0078,
+	0x925d, 0x6018, 0xa080, 0x0001, 0x2004, 0xa084, 0xff00, 0x8007,
+	0xa086, 0x0006, 0x00c0, 0x919a, 0x0e7e, 0x0d7e, 0x0c7e, 0x2001,
+	0xa371, 0x2004, 0xd0e4, 0x0040, 0x92fd, 0x2069, 0xa300, 0x2071,
+	0xa88c, 0x7008, 0x6036, 0x720c, 0x623a, 0xa286, 0xffff, 0x00c0,
+	0x92ba, 0x7208, 0x0c7e, 0x2c08, 0x1078, 0x9e8c, 0x2c10, 0x0c7f,
+	0x0040, 0x92f1, 0x1078, 0x8a30, 0x0040, 0x92f1, 0x0c7e, 0x027e,
+	0x2260, 0x1078, 0x874a, 0x027f, 0x0c7f, 0x7118, 0xa18c, 0xff00,
+	0x810f, 0xa186, 0x0001, 0x0040, 0x92db, 0xa186, 0x0005, 0x0040,
+	0x92d5, 0xa186, 0x0007, 0x00c0, 0x92e5, 0xa280, 0x0004, 0x2004,
+	0xa005, 0x0040, 0x92e5, 0x057e, 0x7510, 0x7614, 0x1078, 0x9f46,
+	0x057f, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0x6007, 0x003b, 0x602b,
+	0x0009, 0x6013, 0x2a00, 0x6003, 0x0001, 0x1078, 0x5bf8, 0x0078,
+	0x92e1, 0x6007, 0x003b, 0x602b, 0x0009, 0x6013, 0x1700, 0x6003,
+	0x0001, 0x1078, 0x5bf8, 0x0078, 0x92e1, 0x6007, 0x003b, 0x602b,
+	0x000b, 0x6013, 0x0000, 0x0078, 0x925d, 0x0e7e, 0x027e, 0x1078,
+	0x4897, 0x0040, 0x933a, 0x1078, 0x4887, 0x1078, 0xa148, 0x00c0,
+	0x9338, 0x2071, 0xa300, 0x70c8, 0xc085, 0x70ca, 0x0f7e, 0x2079,
+	0x0100, 0x7294, 0xa284, 0x00ff, 0x706a, 0x78e6, 0xa284, 0xff00,
+	0x726c, 0xa205, 0x706e, 0x78ea, 0x0f7f, 0x70d3, 0x0000, 0x2001,
+	0xa352, 0x2004, 0xd0a4, 0x0040, 0x9331, 0x2011, 0xa5c4, 0x2013,
+	0x07d0, 0xd0ac, 0x00c0, 0x933a, 0x1078, 0x260d, 0x0078, 0x933a,
+	0x1078, 0xa178, 0x027f, 0x0e7f, 0x1078, 0x753d, 0x0078, 0x9199,
+	0x1078, 0x753d, 0x007c, 0x0d7e, 0x067e, 0x6618, 0x2668, 0x6e04,
+	0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0040, 0x9360, 0xa686,
+	0x0004, 0x0040, 0x9360, 0x6e04, 0xa6b4, 0x00ff, 0xa686, 0x0006,
+	0x0040, 0x9360, 0xa686, 0x0004, 0x0040, 0x9360, 0xa085, 0x0001,
+	0x067f, 0x0d7f, 0x007c, 0x0d7e, 0x1078, 0x9397, 0x0d7f, 0x007c,
+	0x0d7e, 0x1078, 0x93a6, 0x00c0, 0x9390, 0x680c, 0xa08c, 0xff00,
+	0x6820, 0xa084, 0x00ff, 0xa115, 0x6212, 0x6824, 0x602a, 0xd1e4,
+	0x0040, 0x937e, 0x2009, 0x0001, 0x0078, 0x938c, 0xd1ec, 0x0040,
+	0x9390, 0x6920, 0xa18c, 0x00ff, 0x6824, 0x1078, 0x24e3, 0x00c0,
+	0x9390, 0x2110, 0x2009, 0x0000, 0x1078, 0x285b, 0x0078, 0x9394,
+	0xa085, 0x0001, 0x0078, 0x9395, 0xa006, 0x0d7f, 0x007c, 0x2069,
+	0xa88d, 0x6800, 0xa082, 0x0010, 0x00c8, 0x93a4, 0x6013, 0x0000,
+	0xa085, 0x0001, 0x0078, 0x93a5, 0xa006, 0x007c, 0x6013, 0x0000,
+	0x2069, 0xa88c, 0x6808, 0xa084, 0xff00, 0xa086, 0x0800, 0x00c0,
+	0x93ba, 0x6800, 0xa084, 0x00ff, 0xa08e, 0x0014, 0x0040, 0x93ba,
+	0xa08e, 0x0010, 0x007c, 0x6004, 0xa0b2, 0x0044, 0x10c8, 0x1328,
+	0xa1b6, 0x0013, 0x00c0, 0x93c7, 0x2008, 0x0079, 0x93da, 0xa1b6,
+	0x0027, 0x0040, 0x93cf, 0xa1b6, 0x0014, 0x10c0, 0x1328, 0x2001,
+	0x0007, 0x1078, 0x4472, 0x1078, 0x6010, 0x1078, 0x8c01, 0x1078,
+	0x6109, 0x007c, 0x941a, 0x941c, 0x941a, 0x941a, 0x941a, 0x941c,
+	0x9424, 0x94ae, 0x9471, 0x94ae, 0x9485, 0x94ae, 0x9424, 0x94ae,
+	0x94a6, 0x94ae, 0x94a6, 0x94ae, 0x94ae, 0x941a, 0x941a, 0x941a,
+	0x941a, 0x941a, 0x941a, 0x941a, 0x941a, 0x941a, 0x941a, 0x941a,
+	0x941c, 0x941a, 0x94ae, 0x941a, 0x941a, 0x94ae, 0x941a, 0x94ae,
+	0x94ae, 0x941a, 0x941a, 0x941a, 0x941a, 0x94ae, 0x94ae, 0x941a,
+	0x94ae, 0x94ae, 0x941a, 0x941a, 0x941a, 0x941a, 0x941a, 0x941c,
+	0x94ae, 0x94ae, 0x941a, 0x941a, 0x94ae, 0x94ae, 0x941a, 0x941a,
+	0x941a, 0x941a, 0x1078, 0x1328, 0x1078, 0x6010, 0x6003, 0x0002,
+	0x1078, 0x6109, 0x0078, 0x94b4, 0x0f7e, 0x2079, 0xa351, 0x7804,
+	0x0f7f, 0xd0ac, 0x00c0, 0x94ae, 0x2001, 0x0000, 0x1078, 0x442b,
+	0x6018, 0xa080, 0x0004, 0x2004, 0xa086, 0x00ff, 0x0040, 0x94ae,
+	0x0c7e, 0x6018, 0x2060, 0x6000, 0xd0f4, 0x00c0, 0x9448, 0x6010,
+	0xa005, 0x0040, 0x9448, 0x0c7f, 0x1078, 0x35f7, 0x0078, 0x94ae,
+	0x0c7f, 0x2001, 0xa300, 0x2004, 0xa086, 0x0002, 0x00c0, 0x9457,
+	0x0f7e, 0x2079, 0xa300, 0x788c, 0x8000, 0x788e, 0x0f7f, 0x2001,
+	0x0002, 0x1078, 0x443f, 0x1078, 0x6010, 0x601f, 0x0001, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x1078, 0x5c45, 0x1078, 0x6109, 0x0c7e,
+	0x6118, 0x2160, 0x2009, 0x0001, 0x1078, 0x58e1, 0x0c7f, 0x0078,
+	0x94b4, 0x6618, 0x0d7e, 0x2668, 0x6e04, 0x0d7f, 0xa6b4, 0xff00,
+	0x8637, 0xa686, 0x0006, 0x0040, 0x94ae, 0xa686, 0x0004, 0x0040,
+	0x94ae, 0x2001, 0x0004, 0x0078, 0x94ac, 0x2001, 0xa300, 0x2004,
+	0xa086, 0x0003, 0x00c0, 0x948e, 0x1078, 0x35f7, 0x2001, 0x0006,
+	0x1078, 0x94b5, 0x6618, 0x0d7e, 0x2668, 0x6e04, 0x0d7f, 0xa6b4,
+	0xff00, 0x8637, 0xa686, 0x0006, 0x0040, 0x94ae, 0x2001, 0x0006,
+	0x0078, 0x94ac, 0x2001, 0x0004, 0x0078, 0x94ac, 0x2001, 0x0006,
+	0x1078, 0x94b5, 0x0078, 0x94ae, 0x1078, 0x4472, 0x1078, 0x6010,
+	0x1078, 0x753d, 0x1078, 0x6109, 0x007c, 0x017e, 0x0d7e, 0x6118,
+	0x2168, 0x6900, 0xd184, 0x0040, 0x94d0, 0x6104, 0xa18e, 0x000a,
+	0x00c0, 0x94c8, 0x699c, 0xd1a4, 0x00c0, 0x94c8, 0x2001, 0x0007,
+	0x1078, 0x443f, 0x2001, 0x0000, 0x1078, 0x442b, 0x1078, 0x2839,
+	0x0d7f, 0x017f, 0x007c, 0x0d7e, 0x6618, 0x2668, 0x6804, 0xa084,
+	0xff00, 0x8007, 0x0d7f, 0xa0b2, 0x000c, 0x10c8, 0x1328, 0xa1b6,
+	0x0015, 0x00c0, 0x94e7, 0x1079, 0x94ee, 0x0078, 0x94ed, 0xa1b6,
+	0x0016, 0x10c0, 0x1328, 0x1079, 0x94fa, 0x007c, 0x7ad0, 0x7ad0,
+	0x7ad0, 0x7ad0, 0x7ad0, 0x7ad0, 0x9547, 0x9506, 0x7ad0, 0x7ad0,
+	0x7ad0, 0x7ad0, 0x7ad0, 0x7ad0, 0x7ad0, 0x7ad0, 0x7ad0, 0x7ad0,
+	0x9547, 0x954f, 0x7ad0, 0x7ad0, 0x7ad0, 0x7ad0, 0x0f7e, 0x2079,
+	0xa351, 0x7804, 0xd0ac, 0x00c0, 0x952d, 0x6018, 0xa07d, 0x0040,
+	0x952d, 0x7800, 0xd0f4, 0x00c0, 0x9519, 0x7810, 0xa005, 0x00c0,
+	0x952d, 0x2001, 0x0000, 0x1078, 0x442b, 0x2001, 0x0002, 0x1078,
+	0x443f, 0x601f, 0x0001, 0x6003, 0x0001, 0x6007, 0x0002, 0x1078,
+	0x5c45, 0x1078, 0x6109, 0x0078, 0x9545, 0x2011, 0xa883, 0x2204,
+	0x8211, 0x220c, 0x1078, 0x24e3, 0x00c0, 0x9545, 0x0c7e, 0x1078,
+	0x4501, 0x0040, 0x9540, 0x0c7f, 0x1078, 0x753d, 0x0078, 0x9545,
+	0x1078, 0x4235, 0x0c7f, 0x1078, 0x753d, 0x0f7f, 0x007c, 0x6604,
+	0xa6b6, 0x001e, 0x00c0, 0x954e, 0x1078, 0x753d, 0x007c, 0x1078,
+	0x7d0a, 0x00c0, 0x955b, 0x6003, 0x0001, 0x6007, 0x0001, 0x1078,
+	0x5c45, 0x0078, 0x955d, 0x1078, 0x753d, 0x007c, 0x6004, 0xa08a,
+	0x0044, 0x10c8, 0x1328, 0x1078, 0x6010, 0x1078, 0x8c01, 0x1078,
+	0x6109, 0x007c, 0xa182, 0x0040, 0x0079, 0x956e, 0x9581, 0x9581,
+	0x9581, 0x9581, 0x9583, 0x9581, 0x9581, 0x9581, 0x9581, 0x9581,
+	0x9581, 0x9581, 0x9581, 0x9581, 0x9581, 0x9581, 0x9581, 0x9581,
+	0x9581, 0x1078, 0x1328, 0x0d7e, 0x0e7e, 0x0f7e, 0x157e, 0x047e,
+	0x027e, 0x6218, 0xa280, 0x002b, 0x2004, 0xa005, 0x0040, 0x9594,
+	0x2021, 0x0000, 0x1078, 0xa111, 0x6106, 0x2071, 0xa880, 0x7444,
+	0xa4a4, 0xff00, 0x0040, 0x95eb, 0xa486, 0x2000, 0x00c0, 0x95a6,
+	0x2009, 0x0001, 0x2011, 0x0200, 0x1078, 0x5a6d, 0x1078, 0x1381,
+	0x1040, 0x1328, 0x6003, 0x0007, 0x2d00, 0x6837, 0x010d, 0x6803,
+	0x0000, 0x683b, 0x0000, 0x6c5a, 0x2c00, 0x685e, 0x6008, 0x68b2,
+	0x6018, 0x2078, 0x78a0, 0x8007, 0x7130, 0x694a, 0x017e, 0xa084,
+	0xff00, 0x6846, 0x684f, 0x0000, 0x6857, 0x0036, 0x1078, 0x4982,
+	0x017f, 0xa486, 0x2000, 0x00c0, 0x95d3, 0x2019, 0x0017, 0x1078,
+	0x9e3b, 0x0078, 0x9645, 0xa486, 0x0400, 0x00c0, 0x95dd, 0x2019,
+	0x0002, 0x1078, 0x9dec, 0x0078, 0x9645, 0xa486, 0x0200, 0x00c0,
+	0x95e3, 0x1078, 0x9dd1, 0xa486, 0x1000, 0x00c0, 0x95e9, 0x1078,
+	0x9e20, 0x0078, 0x9645, 0x2069, 0xa62d, 0x6a00, 0xd284, 0x0040,
+	0x969b, 0xa284, 0x0300, 0x00c0, 0x9693, 0x6804, 0xa005, 0x0040,
+	0x9683, 0x2d78, 0x6003, 0x0007, 0x1078, 0x1366, 0x0040, 0x964c,
+	0x7800, 0xd08c, 0x00c0, 0x9607, 0x7804, 0x8001, 0x7806, 0x6013,
+	0x0000, 0x6803, 0x0000, 0x6837, 0x0116, 0x683b, 0x0000, 0x6008,
+	0x68b2, 0x2c00, 0x684a, 0x6018, 0x2078, 0x78a0, 0x8007, 0x7130,
+	0x6986, 0x6846, 0x6853, 0x003d, 0x7244, 0xa294, 0x0003, 0xa286,
+	0x0002, 0x00c0, 0x9627, 0x684f, 0x0040, 0x0078, 0x9631, 0xa286,
+	0x0001, 0x00c0, 0x962f, 0x684f, 0x0080, 0x0078, 0x9631, 0x684f,
+	0x0000, 0x20a9, 0x000a, 0x2001, 0xa890, 0xad90, 0x0015, 0x200c,
+	0x810f, 0x2112, 0x8000, 0x8210, 0x00f0, 0x9637, 0x200c, 0x6982,
+	0x8000, 0x200c, 0x697e, 0x1078, 0x4982, 0x027f, 0x047f, 0x157f,
+	0x0f7f, 0x0e7f, 0x0d7f, 0x007c, 0x6013, 0x0100, 0x6003, 0x0001,
+	0x6007, 0x0041, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x0078, 0x9645,
+	0x2069, 0xa892, 0x2d04, 0xa084, 0xff00, 0xa086, 0x1200, 0x00c0,
+	0x9677, 0x2069, 0xa880, 0x686c, 0xa084, 0x00ff, 0x017e, 0x6110,
+	0xa18c, 0x0700, 0xa10d, 0x6112, 0x017f, 0x6003, 0x0001, 0x6007,
+	0x0043, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x0078, 0x9645, 0x6013,
+	0x0200, 0x6003, 0x0001, 0x6007, 0x0041, 0x1078, 0x5bf8, 0x1078,
+	0x6109, 0x0078, 0x9645, 0x6013, 0x0300, 0x0078, 0x9689, 0x6013,
+	0x0100, 0x6003, 0x0001, 0x6007, 0x0041, 0x1078, 0x5bf8, 0x1078,
+	0x6109, 0x0078, 0x9645, 0x6013, 0x0500, 0x0078, 0x9689, 0x6013,
+	0x0600, 0x0078, 0x9658, 0x6013, 0x0200, 0x0078, 0x9658, 0xa186,
+	0x0013, 0x00c0, 0x96b1, 0x6004, 0xa08a, 0x0040, 0x1048, 0x1328,
+	0xa08a, 0x0053, 0x10c8, 0x1328, 0xa082, 0x0040, 0x2008, 0x0079,
+	0x9725, 0xa186, 0x0051, 0x0040, 0x96be, 0xa186, 0x0047, 0x00c0,
+	0x96d7, 0x6004, 0xa086, 0x0041, 0x0040, 0x96e5, 0x2001, 0x0109,
+	0x2004, 0xd084, 0x0040, 0x96e5, 0x127e, 0x2091, 0x2200, 0x007e,
+	0x017e, 0x027e, 0x1078, 0x5ad2, 0x027f, 0x017f, 0x007f, 0x127f,
+	0x6000, 0xa086, 0x0002, 0x00c0, 0x96e5, 0x0078, 0x976a, 0xa186,
+	0x0027, 0x0040, 0x96df, 0xa186, 0x0014, 0x10c0, 0x1328, 0x6004,
+	0xa082, 0x0040, 0x2008, 0x0079, 0x96e8, 0x1078, 0x7583, 0x007c,
+	0x96fb, 0x96fd, 0x96fd, 0x96fb, 0x96fb, 0x96fb, 0x96fb, 0x96fb,
+	0x96fb, 0x96fb, 0x96fb, 0x96fb, 0x96fb, 0x96fb, 0x96fb, 0x96fb,
+	0x96fb, 0x96fb, 0x96fb, 0x1078, 0x1328, 0x1078, 0x6010, 0x1078,
+	0x6109, 0x037e, 0x0d7e, 0x6010, 0xa06d, 0x0040, 0x9722, 0xad84,
+	0xf000, 0x0040, 0x9722, 0x6003, 0x0002, 0x6018, 0x2004, 0xd0bc,
+	0x00c0, 0x9722, 0x2019, 0x0004, 0x1078, 0x9e70, 0x6013, 0x0000,
+	0x6014, 0xa005, 0x00c0, 0x9720, 0x2001, 0xa5a1, 0x2004, 0x6016,
+	0x6003, 0x0007, 0x0d7f, 0x037f, 0x007c, 0x9738, 0x9757, 0x9741,
+	0x9764, 0x9738, 0x9738, 0x9738, 0x9738, 0x9738, 0x9738, 0x9738,
+	0x9738, 0x9738, 0x9738, 0x9738, 0x9738, 0x9738, 0x9738, 0x9738,
+	0x1078, 0x1328, 0x6010, 0xa088, 0x0013, 0x2104, 0xa085, 0x0400,
+	0x200a, 0x1078, 0x6010, 0x6010, 0xa080, 0x0013, 0x2004, 0xd0b4,
+	0x0040, 0x9752, 0x6003, 0x0007, 0x2009, 0x0043, 0x1078, 0x756c,
+	0x0078, 0x9754, 0x6003, 0x0002, 0x1078, 0x6109, 0x007c, 0x1078,
+	0x6010, 0x1078, 0xa0c6, 0x00c0, 0x9761, 0x1078, 0x5a41, 0x1078,
+	0x753d, 0x1078, 0x6109, 0x007c, 0x1078, 0x6010, 0x2009, 0x0041,
+	0x0078, 0x98c1, 0xa182, 0x0040, 0x0079, 0x976e, 0x9781, 0x9783,
+	0x9781, 0x9781, 0x9781, 0x9781, 0x9781, 0x9784, 0x9781, 0x9781,
+	0x9781, 0x9781, 0x9781, 0x9781, 0x9781, 0x9781, 0x9781, 0x978f,
+	0x9781, 0x1078, 0x1328, 0x007c, 0x6003, 0x0004, 0x6110, 0x20e1,
+	0x0005, 0x3d18, 0x3e20, 0x2c10, 0x1078, 0x15ec, 0x007c, 0x0d7e,
+	0x1078, 0x5a41, 0x0d7f, 0x1078, 0xa134, 0x1078, 0x753d, 0x007c,
+	0xa182, 0x0040, 0x0079, 0x979c, 0x97af, 0x97af, 0x97af, 0x97af,
+	0x97af, 0x97af, 0x97af, 0x97b1, 0x97af, 0x97b4, 0x97df, 0x97af,
+	0x97af, 0x97af, 0x97af, 0x97df, 0x97af, 0x97af, 0x97af, 0x1078,
+	0x1328, 0x1078, 0x7583, 0x007c, 0x1078, 0x60b8, 0x1078, 0x61d3,
+	0x6010, 0x0d7e, 0x2068, 0x684c, 0xd0fc, 0x0040, 0x97ca, 0xa08c,
+	0x0003, 0xa18e, 0x0002, 0x0040, 0x97d2, 0x2009, 0x0041, 0x0d7f,
+	0x0078, 0x98c1, 0x6003, 0x0007, 0x6017, 0x0000, 0x1078, 0x5a41,
+	0x0d7f, 0x007c, 0x1078, 0xa0c6, 0x0040, 0x97d8, 0x0d7f, 0x007c,
+	0x1078, 0x5a41, 0x1078, 0x753d, 0x0d7f, 0x0078, 0x97d1, 0x037e,
+	0x1078, 0x60b8, 0x1078, 0x61d3, 0x6010, 0x0d7e, 0x2068, 0x6018,
+	0x2004, 0xd0bc, 0x0040, 0x97ff, 0x684c, 0xa084, 0x0003, 0xa086,
+	0x0002, 0x0040, 0x97fb, 0x687c, 0x632c, 0xa31a, 0x632e, 0x6880,
+	0x6328, 0xa31b, 0x632a, 0x6003, 0x0002, 0x0078, 0x9810, 0x2019,
+	0x0004, 0x1078, 0x9e70, 0x6014, 0xa005, 0x00c0, 0x980c, 0x2001,
+	0xa5a1, 0x2004, 0x8003, 0x6016, 0x6013, 0x0000, 0x6003, 0x0007,
+	0x0d7f, 0x037f, 0x007c, 0xa186, 0x0013, 0x00c0, 0x9821, 0x6004,
+	0xa086, 0x0042, 0x10c0, 0x1328, 0x1078, 0x6010, 0x1078, 0x6109,
+	0x007c, 0xa186, 0x0027, 0x0040, 0x9829, 0xa186, 0x0014, 0x00c0,
+	0x9839, 0x6004, 0xa086, 0x0042, 0x10c0, 0x1328, 0x2001, 0x0007,
+	0x1078, 0x4472, 0x1078, 0x6010, 0x1078, 0x8c01, 0x1078, 0x6109,
+	0x007c, 0xa182, 0x0040, 0x0079, 0x983d, 0x9850, 0x9850, 0x9850,
+	0x9850, 0x9850, 0x9850, 0x9850, 0x9852, 0x985e, 0x9850, 0x9850,
+	0x9850, 0x9850, 0x9850, 0x9850, 0x9850, 0x9850, 0x9850, 0x9850,
+	0x1078, 0x1328, 0x037e, 0x047e, 0x20e1, 0x0005, 0x3d18, 0x3e20,
+	0x2c10, 0x1078, 0x15ec, 0x047f, 0x037f, 0x007c, 0x6010, 0x0d7e,
+	0x2068, 0x6810, 0x6a14, 0x6118, 0x210c, 0xd1bc, 0x0040, 0x987d,
+	0x6124, 0xd1f4, 0x00c0, 0x987d, 0x007e, 0x047e, 0x057e, 0x6c7c,
+	0xa422, 0x6d80, 0x2200, 0xa52b, 0x602c, 0xa420, 0x642e, 0x6028,
+	0xa529, 0x652a, 0x057f, 0x047f, 0x007f, 0xa20d, 0x00c0, 0x9891,
+	0x684c, 0xd0fc, 0x0040, 0x9889, 0x2009, 0x0041, 0x0d7f, 0x0078,
+	0x98c1, 0x6003, 0x0007, 0x6017, 0x0000, 0x1078, 0x5a41, 0x0d7f,
+	0x007c, 0x007e, 0x0f7e, 0x2c78, 0x1078, 0x4893, 0x0f7f, 0x007f,
+	0x0040, 0x989e, 0x6003, 0x0002, 0x0d7f, 0x007c, 0x2009, 0xa30d,
+	0x210c, 0xd19c, 0x0040, 0x98a8, 0x6003, 0x0007, 0x0078, 0x98aa,
+	0x6003, 0x0006, 0x1078, 0x98b0, 0x1078, 0x5a43, 0x0d7f, 0x007c,
+	0xd2fc, 0x0040, 0x98bc, 0x8002, 0x8000, 0x8212, 0xa291, 0x0000,
+	0x2009, 0x0009, 0x0078, 0x98be, 0x2009, 0x0015, 0x6a6a, 0x6866,
+	0x007c, 0xa182, 0x0040, 0x0048, 0x98c7, 0x0079, 0x98d4, 0xa186,
+	0x0013, 0x0040, 0x98cf, 0xa186, 0x0014, 0x10c0, 0x1328, 0x6024,
+	0xd0dc, 0x1040, 0x1328, 0x007c, 0x98e7, 0x98ee, 0x98fa, 0x9906,
+	0x98e7, 0x98e7, 0x98e7, 0x9915, 0x98e7, 0x98e9, 0x98e9, 0x98e7,
+	0x98e7, 0x98e7, 0x98e7, 0x98e7, 0x98e7, 0x98e7, 0x98e7, 0x1078,
+	0x1328, 0x6024, 0xd0dc, 0x1040, 0x1328, 0x007c, 0x6003, 0x0001,
+	0x6106, 0x1078, 0x5bf8, 0x127e, 0x2091, 0x8000, 0x1078, 0x6109,
+	0x127f, 0x007c, 0x6003, 0x0001, 0x6106, 0x1078, 0x5bf8, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x6109, 0x127f, 0x007c, 0x6003, 0x0003,
+	0x6106, 0x2c10, 0x1078, 0x1cab, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x5c64, 0x1078, 0x61d3, 0x127f, 0x007c, 0xa016, 0x1078, 0x15ec,
+	0x007c, 0x127e, 0x2091, 0x8000, 0x037e, 0x0d7e, 0xa182, 0x0040,
+	0x1079, 0x9926, 0x0d7f, 0x037f, 0x127f, 0x007c, 0x9936, 0x9938,
+	0x994d, 0x996c, 0x9936, 0x9936, 0x9936, 0x9984, 0x9936, 0x9936,
+	0x9936, 0x9936, 0x9936, 0x9936, 0x9936, 0x9936, 0x1078, 0x1328,
+	0x6010, 0x2068, 0x684c, 0xd0fc, 0x0040, 0x9962, 0xa09c, 0x0003,
+	0xa39e, 0x0003, 0x0040, 0x9962, 0x6003, 0x0001, 0x6106, 0x1078,
+	0x5bf8, 0x1078, 0x6109, 0x0078, 0x9987, 0x6010, 0x2068, 0x684c,
+	0xd0fc, 0x0040, 0x9962, 0xa09c, 0x0003, 0xa39e, 0x0003, 0x0040,
+	0x9962, 0x6003, 0x0001, 0x6106, 0x1078, 0x5bf8, 0x1078, 0x6109,
+	0x0078, 0x9987, 0x6013, 0x0000, 0x6017, 0x0000, 0x2019, 0x0004,
+	0x1078, 0x9e70, 0x0078, 0x9987, 0x6010, 0x2068, 0x684c, 0xd0fc,
+	0x0040, 0x9962, 0xa09c, 0x0003, 0xa39e, 0x0003, 0x0040, 0x9962,
+	0x6003, 0x0003, 0x6106, 0x2c10, 0x1078, 0x1cab, 0x1078, 0x5c64,
+	0x1078, 0x61d3, 0x0078, 0x9987, 0xa016, 0x1078, 0x15ec, 0x007c,
+	0x1078, 0x6010, 0x6110, 0x81ff, 0x0040, 0x9999, 0x0d7e, 0x2168,
+	0x1078, 0xa181, 0x037e, 0x2019, 0x0029, 0x1078, 0x9e70, 0x037f,
+	0x0d7f, 0x1078, 0x8c01, 0x1078, 0x6109, 0x007c, 0x1078, 0x60b8,
+	0x6110, 0x81ff, 0x0040, 0x99af, 0x0d7e, 0x2168, 0x1078, 0xa181,
+	0x037e, 0x2019, 0x0029, 0x1078, 0x9e70, 0x037f, 0x0d7f, 0x1078,
+	0x8c01, 0x1078, 0x61d3, 0x007c, 0xa182, 0x0085, 0x0079, 0x99b8,
+	0x99c1, 0x99bf, 0x99bf, 0x99cd, 0x99bf, 0x99bf, 0x99bf, 0x1078,
+	0x1328, 0x6003, 0x000b, 0x6106, 0x1078, 0x5bf8, 0x127e, 0x2091,
+	0x8000, 0x1078, 0x6109, 0x127f, 0x007c, 0x027e, 0x0e7e, 0x1078,
+	0xa0bf, 0x0040, 0x99d7, 0x1078, 0x753d, 0x0078, 0x99f3, 0x2071,
+	0xa880, 0x7224, 0x6212, 0x7220, 0x1078, 0x9d10, 0x0040, 0x99e4,
+	0x6007, 0x0086, 0x0078, 0x99ed, 0x6007, 0x0087, 0x7224, 0xa296,
+	0xffff, 0x00c0, 0x99ed, 0x6007, 0x0086, 0x6003, 0x0001, 0x1078,
+	0x5bf8, 0x1078, 0x6109, 0x0e7f, 0x027f, 0x007c, 0xa186, 0x0013,
+	0x00c0, 0x9a07, 0x6004, 0xa08a, 0x0085, 0x1048, 0x1328, 0xa08a,
+	0x008c, 0x10c8, 0x1328, 0xa082, 0x0085, 0x0079, 0x9a1e, 0xa186,
+	0x0027, 0x0040, 0x9a13, 0xa186, 0x0014, 0x0040, 0x9a13, 0x1078,
+	0x7583, 0x0078, 0x9a1d, 0x2001, 0x0007, 0x1078, 0x4472, 0x1078,
+	0x6010, 0x1078, 0x8c01, 0x1078, 0x6109, 0x007c, 0x9a25, 0x9a27,
+	0x9a27, 0x9a25, 0x9a25, 0x9a25, 0x9a25, 0x1078, 0x1328, 0x1078,
+	0x6010, 0x1078, 0x8c01, 0x1078, 0x6109, 0x007c, 0xa182, 0x0085,
+	0x1048, 0x1328, 0xa182, 0x008c, 0x10c8, 0x1328, 0xa182, 0x0085,
+	0x0079, 0x9a3a, 0x9a41, 0x9a41, 0x9a41, 0x9a43, 0x9a41, 0x9a41,
+	0x9a41, 0x1078, 0x1328, 0x007c, 0xa186, 0x0013, 0x0040, 0x9a54,
+	0xa186, 0x0014, 0x0040, 0x9a54, 0xa186, 0x0027, 0x0040, 0x9a54,
+	0x1078, 0x7583, 0x0078, 0x9a5a, 0x1078, 0x6010, 0x1078, 0x8c01,
+	0x1078, 0x6109, 0x007c, 0x037e, 0x1078, 0xa134, 0x603f, 0x0000,
+	0x2019, 0x000b, 0x1078, 0x9a6a, 0x601f, 0x0006, 0x6003, 0x0007,
+	0x037f, 0x007c, 0x127e, 0x037e, 0x2091, 0x8000, 0x087e, 0x2c40,
+	0x097e, 0x2049, 0x0000, 0x1078, 0x7058, 0x097f, 0x087f, 0x00c0,
+	0x9aa5, 0x077e, 0x2c38, 0x1078, 0x7105, 0x077f, 0x00c0, 0x9aa5,
+	0x6000, 0xa086, 0x0000, 0x0040, 0x9aa5, 0x601c, 0xa086, 0x0007,
+	0x0040, 0x9aa5, 0x0d7e, 0x6000, 0xa086, 0x0004, 0x00c0, 0x9a96,
+	0x1078, 0xa134, 0x601f, 0x0007, 0x1078, 0x1749, 0x6010, 0x2068,
+	0x1078, 0x8a44, 0x0040, 0x9a9e, 0x1078, 0x9e70, 0x0d7f, 0x6013,
+	0x0000, 0x1078, 0xa134, 0x601f, 0x0007, 0x037f, 0x127f, 0x007c,
+	0x0f7e, 0x0c7e, 0x037e, 0x157e, 0x2079, 0xa880, 0x7938, 0x783c,
+	0x1078, 0x24e3, 0x00c0, 0x9af6, 0x017e, 0x0c7e, 0x1078, 0x4501,
+	0x00c0, 0x9af6, 0x2011, 0xa890, 0xac98, 0x000a, 0x20a9, 0x0004,
+	0x1078, 0x7e55, 0x00c0, 0x9af6, 0x017f, 0x027f, 0x027e, 0x017e,
+	0x2019, 0x0029, 0x1078, 0x71e0, 0x1078, 0x5d53, 0x077e, 0x2039,
+	0x0000, 0x1078, 0x5c78, 0x077f, 0x017f, 0x077e, 0x2039, 0x0000,
+	0x1078, 0x9c38, 0x077f, 0x1078, 0x471b, 0x027e, 0x6204, 0xa294,
+	0xff00, 0x8217, 0xa286, 0x0006, 0x0040, 0x9aea, 0xa286, 0x0004,
+	0x00c0, 0x9aed, 0x62a0, 0x1078, 0x28d5, 0x027f, 0x017f, 0x1078,
+	0x4235, 0x6612, 0x6516, 0xa006, 0x0078, 0x9af8, 0x0c7f, 0x017f,
+	0x157f, 0x037f, 0x0c7f, 0x0f7f, 0x007c, 0x0c7e, 0x0d7e, 0x0e7e,
+	0x017e, 0x2009, 0xa31f, 0x2104, 0xa086, 0x0074, 0x00c0, 0x9b60,
+	0x2069, 0xa88e, 0x690c, 0xa182, 0x0100, 0x0048, 0x9b50, 0x6908,
+	0xa184, 0x8000, 0x0040, 0x9b5c, 0x6018, 0x2070, 0x7010, 0xa084,
+	0x00ff, 0x0040, 0x9b1f, 0x7000, 0xd0f4, 0x0040, 0x9b23, 0xa184,
+	0x0800, 0x0040, 0x9b5c, 0x6910, 0xa18a, 0x0001, 0x0048, 0x9b54,
+	0x6914, 0x2069, 0xa8ae, 0x6904, 0x81ff, 0x00c0, 0x9b48, 0x690c,
+	0xa182, 0x0100, 0x0048, 0x9b50, 0x6908, 0x81ff, 0x00c0, 0x9b4c,
+	0x6910, 0xa18a, 0x0001, 0x0048, 0x9b54, 0x6918, 0xa18a, 0x0001,
+	0x0048, 0x9b5c, 0x0078, 0x9b66, 0x6013, 0x0100, 0x0078, 0x9b62,
+	0x6013, 0x0300, 0x0078, 0x9b62, 0x6013, 0x0500, 0x0078, 0x9b62,
+	0x6013, 0x0700, 0x0078, 0x9b62, 0x6013, 0x0900, 0x0078, 0x9b62,
+	0x6013, 0x0b00, 0x0078, 0x9b62, 0x6013, 0x0f00, 0x0078, 0x9b62,
+	0x6013, 0x2d00, 0xa085, 0x0001, 0x0078, 0x9b67, 0xa006, 0x017f,
+	0x0e7f, 0x0d7f, 0x0c7f, 0x007c, 0x0c7e, 0x0d7e, 0x027e, 0x037e,
+	0x157e, 0x6218, 0x2268, 0x6b04, 0xa394, 0x00ff, 0xa286, 0x0006,
+	0x0040, 0x9b90, 0xa286, 0x0004, 0x0040, 0x9b90, 0xa394, 0xff00,
+	0x8217, 0xa286, 0x0006, 0x0040, 0x9b90, 0xa286, 0x0004, 0x0040,
+	0x9b90, 0x0c7e, 0x2d60, 0x1078, 0x4513, 0x0c7f, 0x0078, 0x9bcb,
+	0x2011, 0xa896, 0xad98, 0x000a, 0x20a9, 0x0004, 0x1078, 0x7e55,
+	0x00c0, 0x9bcc, 0x2011, 0xa89a, 0xad98, 0x0006, 0x20a9, 0x0004,
+	0x1078, 0x7e55, 0x00c0, 0x9bcc, 0x047e, 0x017e, 0x6aa0, 0xa294,
+	0x00ff, 0x8227, 0xa006, 0x2009, 0xa352, 0x210c, 0xd1a4, 0x0040,
+	0x9bb8, 0x2009, 0x0029, 0x1078, 0x9ec0, 0x6800, 0xc0e5, 0x6802,
+	0x2019, 0x0029, 0x1078, 0x5d53, 0x077e, 0x2039, 0x0000, 0x1078,
+	0x5c78, 0x2c08, 0x1078, 0x9c38, 0x077f, 0x2001, 0x0007, 0x1078,
+	0x4472, 0x017f, 0x047f, 0xa006, 0x157f, 0x037f, 0x027f, 0x0d7f,
+	0x0c7f, 0x007c, 0x0d7e, 0x2069, 0xa88e, 0x6800, 0xa086, 0x0800,
+	0x0040, 0x9bde, 0x6013, 0x0000, 0x0078, 0x9bdf, 0xa006, 0x0d7f,
+	0x007c, 0x0c7e, 0x0f7e, 0x017e, 0x027e, 0x037e, 0x157e, 0x2079,
+	0xa88c, 0x7930, 0x7834, 0x1078, 0x24e3, 0x00c0, 0x9c05, 0x1078,
+	0x4501, 0x00c0, 0x9c05, 0x2011, 0xa890, 0xac98, 0x000a, 0x20a9,
+	0x0004, 0x1078, 0x7e55, 0x00c0, 0x9c05, 0x2011, 0xa894, 0xac98,
+	0x0006, 0x20a9, 0x0004, 0x1078, 0x7e55, 0x157f, 0x037f, 0x027f,
+	0x017f, 0x0f7f, 0x0c7f, 0x007c, 0x0c7e, 0x007e, 0x017e, 0x027e,
+	0x037e, 0x157e, 0x2011, 0xa883, 0x2204, 0x8211, 0x220c, 0x1078,
+	0x24e3, 0x00c0, 0x9c31, 0x1078, 0x4501, 0x00c0, 0x9c31, 0x2011,
+	0xa896, 0xac98, 0x000a, 0x20a9, 0x0004, 0x1078, 0x7e55, 0x00c0,
+	0x9c31, 0x2011, 0xa89a, 0xac98, 0x0006, 0x20a9, 0x0004, 0x1078,
+	0x7e55, 0x157f, 0x037f, 0x027f, 0x017f, 0x007f, 0x0c7f, 0x007c,
+	0x0e7e, 0x0c7e, 0x087e, 0x077e, 0x067e, 0x057e, 0x047e, 0x027e,
+	0x127e, 0x2091, 0x8000, 0x2740, 0x2029, 0xa5b4, 0x252c, 0x2021,
+	0xa5ba, 0x2424, 0x2061, 0xaa00, 0x2071, 0xa300, 0x7644, 0x7060,
+	0x81ff, 0x0040, 0x9c59, 0x8001, 0xa602, 0x00c8, 0x9cc3, 0x0078,
+	0x9c5c, 0xa606, 0x0040, 0x9cc3, 0x2100, 0xac06, 0x0040, 0x9cb9,
+	0x1078, 0x9ee5, 0x0040, 0x9cb9, 0x671c, 0xa786, 0x0001, 0x0040,
+	0x9cde, 0xa786, 0x0004, 0x0040, 0x9cde, 0xa786, 0x0007, 0x0040,
+	0x9cb9, 0x2500, 0xac06, 0x0040, 0x9cb9, 0x2400, 0xac06, 0x0040,
+	0x9cb9, 0x1078, 0x9ef9, 0x00c0, 0x9cb9, 0x88ff, 0x0040, 0x9c84,
+	0x6020, 0xa906, 0x00c0, 0x9cb9, 0x0d7e, 0x6000, 0xa086, 0x0004,
+	0x00c0, 0x9c8e, 0x017e, 0x1078, 0x1749, 0x017f, 0xa786, 0x0008,
+	0x00c0, 0x9c9d, 0x1078, 0x8c3b, 0x00c0, 0x9c9d, 0x1078, 0x7a05,
+	0x0d7f, 0x1078, 0x8c01, 0x0078, 0x9cb9, 0x6010, 0x2068, 0x1078,
+	0x8a44, 0x0040, 0x9cb6, 0xa786, 0x0003, 0x00c0, 0x9ccd, 0x6837,
+	0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0xa181, 0x017e, 0x1078,
+	0x8cb8, 0x1078, 0x4982, 0x017f, 0x1078, 0x8bf4, 0x0d7f, 0x1078,
+	0x8c01, 0xace0, 0x0010, 0x2001, 0xa315, 0x2004, 0xac02, 0x00c8,
+	0x9cc3, 0x0078, 0x9c4c, 0x127f, 0x027f, 0x047f, 0x057f, 0x067f,
+	0x077f, 0x087f, 0x0c7f, 0x0e7f, 0x007c, 0xa786, 0x0006, 0x00c0,
+	0x9ca7, 0xa386, 0x0005, 0x0040, 0x9cdb, 0x1078, 0xa181, 0x1078,
+	0x9e70, 0x0078, 0x9cb6, 0x0d7f, 0x0078, 0x9cb9, 0x1078, 0x9ef9,
+	0x00c0, 0x9cb9, 0x81ff, 0x0040, 0x9cb9, 0xa180, 0x0001, 0x2004,
+	0xa086, 0x0018, 0x0040, 0x9cf3, 0xa180, 0x0001, 0x2004, 0xa086,
+	0x002d, 0x00c0, 0x9cb9, 0x6000, 0xa086, 0x0002, 0x00c0, 0x9cb9,
+	0x1078, 0x8c27, 0x0040, 0x9d04, 0x1078, 0x8c3b, 0x00c0, 0x9cb9,
+	0x1078, 0x7a05, 0x0078, 0x9d0c, 0x1078, 0x2839, 0x1078, 0x8c3b,
+	0x00c0, 0x9d0c, 0x1078, 0x7a05, 0x1078, 0x8c01, 0x0078, 0x9cb9,
+	0x0c7e, 0x0e7e, 0x017e, 0x2c08, 0x2170, 0x1078, 0x9e8c, 0x017f,
+	0x0040, 0x9d1f, 0x601c, 0xa084, 0x000f, 0x1079, 0x9d22, 0x0e7f,
+	0x0c7f, 0x007c, 0x9d2a, 0x9d2a, 0x9d2a, 0x9d2a, 0x9d2a, 0x9d2a,
+	0x9d2c, 0x9d2a, 0xa006, 0x007c, 0x047e, 0x017e, 0x7018, 0xa080,
+	0x0028, 0x2024, 0xa4a4, 0x00ff, 0x8427, 0x2c00, 0x2009, 0x0020,
+	0x1078, 0x9ec0, 0x017f, 0x047f, 0x037e, 0x2019, 0x0002, 0x1078,
+	0x9a6a, 0x037f, 0xa085, 0x0001, 0x007c, 0x2001, 0x0001, 0x1078,
+	0x442b, 0x157e, 0x017e, 0x027e, 0x037e, 0x20a9, 0x0004, 0x2019,
+	0xa305, 0x2011, 0xa896, 0x1078, 0x7e55, 0x037f, 0x027f, 0x017f,
+	0x157f, 0xa005, 0x007c, 0x0f7e, 0x0e7e, 0x0c7e, 0x087e, 0x077e,
+	0x067e, 0x027e, 0x127e, 0x2091, 0x8000, 0x2740, 0x2061, 0xaa00,
+	0x2079, 0x0001, 0x8fff, 0x0040, 0x9dc3, 0x2071, 0xa300, 0x7644,
+	0x7060, 0x8001, 0xa602, 0x00c8, 0x9dc3, 0x88ff, 0x0040, 0x9d7e,
+	0x2800, 0xac06, 0x00c0, 0x9db9, 0x2079, 0x0000, 0x1078, 0x9ee5,
+	0x0040, 0x9db9, 0x2400, 0xac06, 0x0040, 0x9db9, 0x671c, 0xa786,
+	0x0006, 0x00c0, 0x9db9, 0xa786, 0x0007, 0x0040, 0x9db9, 0x88ff,
+	0x00c0, 0x9d9d, 0x6018, 0xa206, 0x00c0, 0x9db9, 0x85ff, 0x0040,
+	0x9d9d, 0x6020, 0xa106, 0x00c0, 0x9db9, 0x0d7e, 0x6000, 0xa086,
+	0x0004, 0x00c0, 0x9da9, 0x1078, 0xa134, 0x601f, 0x0007, 0x1078,
+	0x1749, 0x6010, 0x2068, 0x1078, 0x8a44, 0x0040, 0x9db3, 0x047e,
+	0x1078, 0x9e70, 0x047f, 0x0d7f, 0x1078, 0x8c01, 0x88ff, 0x00c0,
+	0x9dcd, 0xace0, 0x0010, 0x2001, 0xa315, 0x2004, 0xac02, 0x00c8,
+	0x9dc3, 0x0078, 0x9d6a, 0xa006, 0x127f, 0x027f, 0x067f, 0x077f,
+	0x087f, 0x0c7f, 0x0e7f, 0x0f7f, 0x007c, 0xa8c5, 0x0001, 0x0078,
+	0x9dc4, 0x077e, 0x057e, 0x087e, 0x2041, 0x0000, 0x2029, 0x0001,
+	0x2c20, 0x2019, 0x0002, 0x6218, 0x097e, 0x2049, 0x0000, 0x1078,
+	0x7058, 0x097f, 0x087f, 0x2039, 0x0000, 0x1078, 0x7105, 0x1078,
+	0x9d5b, 0x057f, 0x077f, 0x007c, 0x027e, 0x047e, 0x057e, 0x077e,
+	0x0c7e, 0x157e, 0x2c20, 0x2128, 0x20a9, 0x007f, 0x2009, 0x0000,
+	0x017e, 0x037e, 0x1078, 0x4501, 0x00c0, 0x9e14, 0x2c10, 0x057e,
+	0x087e, 0x2041, 0x0000, 0x2508, 0x2029, 0x0001, 0x097e, 0x2049,
+	0x0000, 0x1078, 0x7058, 0x097f, 0x087f, 0x2039, 0x0000, 0x1078,
+	0x7105, 0x1078, 0x9d5b, 0x057f, 0x037f, 0x017f, 0x8108, 0x00f0,
+	0x9df8, 0x157f, 0x0c7f, 0x077f, 0x057f, 0x047f, 0x027f, 0x007c,
+	0x077e, 0x057e, 0x6218, 0x087e, 0x2041, 0x0000, 0x2029, 0x0001,
+	0x2019, 0x0048, 0x097e, 0x2049, 0x0000, 0x1078, 0x7058, 0x097f,
+	0x087f, 0x2039, 0x0000, 0x1078, 0x7105, 0x2c20, 0x1078, 0x9d5b,
+	0x057f, 0x077f, 0x007c, 0x027e, 0x047e, 0x057e, 0x077e, 0x0c7e,
+	0x157e, 0x2c20, 0x20a9, 0x007f, 0x2009, 0x0000, 0x017e, 0x037e,
+	0x1078, 0x4501, 0x00c0, 0x9e64, 0x2c10, 0x087e, 0x2041, 0x0000,
+	0x2828, 0x047e, 0x2021, 0x0001, 0x1078, 0xa111, 0x047f, 0x097e,
+	0x2049, 0x0000, 0x1078, 0x7058, 0x097f, 0x087f, 0x2039, 0x0000,
+	0x1078, 0x7105, 0x1078, 0x9d5b, 0x037f, 0x017f, 0x8108, 0x00f0,
+	0x9e46, 0x157f, 0x0c7f, 0x077f, 0x057f, 0x047f, 0x027f, 0x007c,
+	0x017e, 0x0f7e, 0xad82, 0xca00, 0x0048, 0x9e89, 0xad82, 0xffff,
+	0x00c8, 0x9e89, 0x6800, 0xa07d, 0x0040, 0x9e86, 0x6803, 0x0000,
+	0x6b52, 0x1078, 0x4982, 0x2f68, 0x0078, 0x9e7a, 0x6b52, 0x1078,
+	0x4982, 0x0f7f, 0x017f, 0x007c, 0x0e7e, 0x047e, 0x037e, 0x2061,
+	0xaa00, 0x2071, 0xa300, 0x7444, 0x7060, 0x8001, 0xa402, 0x00c8,
+	0x9ebb, 0x2100, 0xac06, 0x0040, 0x9ead, 0x6000, 0xa086, 0x0000,
+	0x0040, 0x9ead, 0x6008, 0xa206, 0x00c0, 0x9ead, 0x6018, 0xa1a0,
+	0x0006, 0x2424, 0xa406, 0x0040, 0x9eb7, 0xace0, 0x0010, 0x2001,
+	0xa315, 0x2004, 0xac02, 0x00c8, 0x9ebb, 0x0078, 0x9e91, 0xa085,
+	0x0001, 0x0078, 0x9ebc, 0xa006, 0x037f, 0x047f, 0x0e7f, 0x007c,
+	0x0d7e, 0x007e, 0x1078, 0x1381, 0x007f, 0x1040, 0x1328, 0x6837,
+	0x010d, 0x685e, 0x027e, 0x2010, 0x1078, 0x8a30, 0x2001, 0x0000,
+	0x0040, 0x9ed6, 0x2200, 0xa080, 0x0008, 0x2004, 0x027f, 0x684a,
+	0x6956, 0x6c46, 0x684f, 0x0000, 0xa006, 0x68b2, 0x6802, 0x683a,
+	0x685a, 0x1078, 0x4982, 0x0d7f, 0x007c, 0x6700, 0xa786, 0x0000,
+	0x0040, 0x9ef8, 0xa786, 0x0001, 0x0040, 0x9ef8, 0xa786, 0x000a,
+	0x0040, 0x9ef8, 0xa786, 0x0009, 0x0040, 0x9ef8, 0xa085, 0x0001,
+	0x007c, 0x0e7e, 0x6018, 0x2070, 0x70a0, 0xa206, 0x0e7f, 0x007c,
+	0x017e, 0x6004, 0xa08e, 0x001e, 0x00c0, 0x9f1a, 0x8007, 0x6130,
+	0xa18c, 0x00ff, 0xa105, 0x6032, 0x6007, 0x0085, 0x6003, 0x000b,
+	0x601f, 0x0005, 0x2001, 0xa5a1, 0x2004, 0x6016, 0x1078, 0x5bf8,
+	0x1078, 0x6109, 0x017f, 0x007c, 0x0005, 0x0005, 0x007c, 0x6024,
+	0xd0e4, 0x0040, 0x9f30, 0xd0cc, 0x0040, 0x9f2a, 0x1078, 0x8cfa,
+	0x0078, 0x9f30, 0x1078, 0xa134, 0x1078, 0x5a41, 0x1078, 0x753d,
+	0x007c, 0xa280, 0x0007, 0x2004, 0xa084, 0x000f, 0x0079, 0x9f38,
+	0x9f41, 0x9f41, 0x9f41, 0x9f43, 0x9f41, 0x9f43, 0x9f43, 0x9f41,
+	0x9f43, 0xa006, 0x007c, 0xa085, 0x0001, 0x007c, 0xa280, 0x0007,
+	0x2004, 0xa084, 0x000f, 0x0079, 0x9f4d, 0x9f56, 0x9f56, 0x9f56,
+	0x9f56, 0x9f56, 0x9f56, 0x9f61, 0x9f56, 0x9f56, 0x6007, 0x003b,
+	0x602b, 0x0009, 0x6013, 0x2a00, 0x6003, 0x0001, 0x1078, 0x5bf8,
+	0x007c, 0x0c7e, 0x2260, 0x1078, 0xa134, 0x603f, 0x0000, 0x6024,
+	0xc0f4, 0xc0cc, 0x6026, 0x0c7f, 0x0d7e, 0x2268, 0xa186, 0x0007,
+	0x00c0, 0x9fc2, 0x6810, 0xa005, 0x0040, 0x9f7f, 0xa080, 0x0013,
+	0x2004, 0xd0fc, 0x00c0, 0x9f7f, 0x0d7f, 0x0078, 0x9f56, 0x6007,
+	0x003a, 0x6003, 0x0001, 0x1078, 0x5bf8, 0x1078, 0x6109, 0x0c7e,
+	0x2d60, 0x6100, 0xa186, 0x0002, 0x00c0, 0xa050, 0x6010, 0xa005,
+	0x00c0, 0x9f99, 0x6000, 0xa086, 0x0007, 0x10c0, 0x1328, 0x0078,
+	0xa050, 0xa08c, 0xf000, 0x00c0, 0x9fa5, 0x0078, 0x9fa5, 0x2068,
+	0x6800, 0xa005, 0x00c0, 0x9f9f, 0x2d00, 0xa080, 0x0013, 0x2004,
+	0xa084, 0x0003, 0xa086, 0x0002, 0x00c0, 0x9fbe, 0x6010, 0x2068,
+	0x684c, 0xc0dc, 0xc0f4, 0x684e, 0x6850, 0xc0f4, 0xc0fc, 0x6852,
+	0x2009, 0x0043, 0x1078, 0x98c1, 0x0078, 0xa050, 0x2009, 0x0041,
+	0x0078, 0xa04a, 0xa186, 0x0005, 0x00c0, 0xa009, 0x6810, 0xa080,
+	0x0013, 0x2004, 0xd0bc, 0x00c0, 0x9fd0, 0x0d7f, 0x0078, 0x9f56,
+	0xd0b4, 0x0040, 0x9fd8, 0xd0fc, 0x1040, 0x1328, 0x0078, 0x9f72,
+	0x6007, 0x003a, 0x6003, 0x0001, 0x1078, 0x5bf8, 0x1078, 0x6109,
+	0x0c7e, 0x2d60, 0x6100, 0xa186, 0x0002, 0x0040, 0x9feb, 0xa186,
+	0x0004, 0x00c0, 0xa050, 0x2071, 0xa5e1, 0x7000, 0xa086, 0x0003,
+	0x00c0, 0x9ff8, 0x7004, 0xac06, 0x00c0, 0x9ff8, 0x7003, 0x0000,
+	0x6810, 0xa080, 0x0013, 0x200c, 0xc1f4, 0xc1dc, 0x2102, 0x8000,
+	0x200c, 0xc1f4, 0xc1fc, 0xc1bc, 0x2102, 0x2009, 0x0042, 0x0078,
+	0xa04a, 0x037e, 0x0d7e, 0x0d7e, 0x1078, 0x1381, 0x037f, 0x1040,
+	0x1328, 0x6837, 0x010d, 0x6803, 0x0000, 0x683b, 0x0000, 0x685b,
+	0x0000, 0x6b5e, 0x6857, 0x0045, 0x2c00, 0x6862, 0x6034, 0x6872,
+	0x2360, 0x6024, 0xc0dd, 0x6026, 0x6018, 0xa080, 0x0028, 0x2004,
+	0xa084, 0x00ff, 0x8007, 0x6320, 0x6b4a, 0x6846, 0x684f, 0x0000,
+	0x6d6a, 0x6e66, 0x686f, 0x0001, 0x1078, 0x4982, 0x2019, 0x0045,
+	0x6008, 0x2068, 0x1078, 0x9a6a, 0x2d00, 0x600a, 0x601f, 0x0006,
+	0x6003, 0x0007, 0x6017, 0x0000, 0x603f, 0x0000, 0x0d7f, 0x037f,
+	0x0078, 0xa051, 0x603f, 0x0000, 0x6003, 0x0007, 0x1078, 0x98c1,
+	0x0c7f, 0x0d7f, 0x007c, 0xa186, 0x0013, 0x00c0, 0xa05d, 0x6004,
+	0xa082, 0x0085, 0x2008, 0x0079, 0xa077, 0xa186, 0x0027, 0x00c0,
+	0xa070, 0x1078, 0x6010, 0x037e, 0x0d7e, 0x6010, 0x2068, 0x2019,
+	0x0004, 0x1078, 0x9e70, 0x0d7f, 0x037f, 0x1078, 0x6109, 0x007c,
+	0xa186, 0x0014, 0x0040, 0xa061, 0x1078, 0x7583, 0x007c, 0xa080,
+	0xa07e, 0xa07e, 0xa07e, 0xa07e, 0xa07e, 0xa080, 0x1078, 0x1328,
+	0x1078, 0x6010, 0x6003, 0x000c, 0x1078, 0x6109, 0x007c, 0xa182,
+	0x008c, 0x00c8, 0xa091, 0xa182, 0x0085, 0x0048, 0xa091, 0x0079,
+	0xa094, 0x1078, 0x7583, 0x007c, 0xa09b, 0xa09b, 0xa09b, 0xa09b,
+	0xa09d, 0xa0bc, 0xa09b, 0x1078, 0x1328, 0x0d7e, 0x2c68, 0x1078,
+	0x74d7, 0x0040, 0xa0b7, 0x6003, 0x0001, 0x6007, 0x001e, 0x2009,
+	0xa88e, 0x210c, 0x6136, 0x2009, 0xa88f, 0x210c, 0x613a, 0x600b,
+	0xffff, 0x6918, 0x611a, 0x601f, 0x0004, 0x1078, 0x5bf8, 0x2d60,
+	0x1078, 0x753d, 0x0d7f, 0x007c, 0x1078, 0x753d, 0x007c, 0x0e7e,
+	0x6018, 0x2070, 0x7000, 0xd0ec, 0x0e7f, 0x007c, 0x6010, 0xa080,
+	0x0013, 0x200c, 0xd1ec, 0x0040, 0xa110, 0x2001, 0xa371, 0x2004,
+	0xd0ec, 0x0040, 0xa110, 0x6003, 0x0002, 0x6024, 0xc0e5, 0x6026,
+	0xd1ac, 0x0040, 0xa0ee, 0x0f7e, 0x2c78, 0x1078, 0x488f, 0x0f7f,
+	0x0040, 0xa0ee, 0x2001, 0xa5a2, 0x2004, 0x603e, 0x2009, 0xa371,
+	0x210c, 0xd1f4, 0x00c0, 0xa10e, 0x0078, 0xa100, 0x2009, 0xa371,
+	0x210c, 0xd1f4, 0x0040, 0xa0fa, 0x6024, 0xc0e4, 0x6026, 0xa006,
+	0x0078, 0xa110, 0x2001, 0xa5a2, 0x200c, 0x8103, 0xa100, 0x603e,
+	0x6018, 0xa088, 0x002b, 0x2104, 0xa005, 0x0040, 0xa10b, 0xa088,
+	0x0003, 0x0078, 0xa103, 0x2c0a, 0x600f, 0x0000, 0xa085, 0x0001,
+	0x007c, 0x017e, 0x0c7e, 0x0e7e, 0x6120, 0xa2f0, 0x002b, 0x2e04,
+	0x2060, 0x8cff, 0x0040, 0xa130, 0x84ff, 0x00c0, 0xa123, 0x6020,
+	0xa106, 0x00c0, 0xa12b, 0x600c, 0x2072, 0x1078, 0x5a41, 0x1078,
+	0x753d, 0x0078, 0xa12d, 0xacf0, 0x0003, 0x2e64, 0x0078, 0xa119,
+	0x0e7f, 0x0c7f, 0x017f, 0x007c, 0x0d7e, 0x6018, 0xa0e8, 0x002b,
+	0x2d04, 0xa005, 0x0040, 0xa146, 0xac06, 0x0040, 0xa144, 0x2d04,
+	0xa0e8, 0x0003, 0x0078, 0xa138, 0x600c, 0x206a, 0x0d7f, 0x007c,
+	0x027e, 0x037e, 0x157e, 0x2011, 0xa325, 0x2204, 0xa084, 0x00ff,
+	0x2019, 0xa88e, 0x2334, 0xa636, 0x00c0, 0xa174, 0x8318, 0x2334,
+	0x2204, 0xa084, 0xff00, 0xa636, 0x00c0, 0xa174, 0x2011, 0xa890,
+	0x6018, 0xa098, 0x000a, 0x20a9, 0x0004, 0x1078, 0x7e55, 0x00c0,
+	0xa174, 0x2011, 0xa894, 0x6018, 0xa098, 0x0006, 0x20a9, 0x0004,
+	0x1078, 0x7e55, 0x00c0, 0xa174, 0x157f, 0x037f, 0x027f, 0x007c,
+	0x0e7e, 0x2071, 0xa300, 0x1078, 0x41f5, 0x1078, 0x260d, 0x0e7f,
+	0x007c, 0x0e7e, 0x6018, 0x2070, 0x7000, 0xd0fc, 0x0040, 0xa18a,
+	0x1078, 0xa18c, 0x0e7f, 0x007c, 0x6850, 0xc0e5, 0x6852, 0x007c,
+	0x0e7e, 0x0c7e, 0x077e, 0x067e, 0x057e, 0x047e, 0x027e, 0x017e,
+	0x127e, 0x2091, 0x8000, 0x2029, 0xa5b4, 0x252c, 0x2021, 0xa5ba,
+	0x2424, 0x2061, 0xaa00, 0x2071, 0xa300, 0x7644, 0x7060, 0xa606,
+	0x0040, 0xa1e4, 0x671c, 0xa786, 0x0001, 0x0040, 0xa1b3, 0xa786,
+	0x0008, 0x00c0, 0xa1da, 0x2500, 0xac06, 0x0040, 0xa1da, 0x2400,
+	0xac06, 0x0040, 0xa1da, 0x1078, 0x9ee5, 0x0040, 0xa1da, 0x1078,
+	0x9ef9, 0x00c0, 0xa1da, 0x6000, 0xa086, 0x0004, 0x00c0, 0xa1cc,
+	0x017e, 0x1078, 0x1749, 0x017f, 0x1078, 0x8c27, 0x00c0, 0xa1d2,
+	0x1078, 0x2839, 0x1078, 0x8c3b, 0x00c0, 0xa1d8, 0x1078, 0x7a05,
+	0x1078, 0x8c01, 0xace0, 0x0010, 0x2001, 0xa315, 0x2004, 0xac02,
+	0x00c8, 0xa1e4, 0x0078, 0xa1a3, 0x127f, 0x017f, 0x027f, 0x047f,
+	0x057f, 0x067f, 0x077f, 0x0c7f, 0x0e7f, 0x007c, 0x127e, 0x007e,
+	0x0e7e, 0x2091, 0x8000, 0x2071, 0xa340, 0xd5a4, 0x0040, 0xa1fb,
+	0x7034, 0x8000, 0x7036, 0xd5b4, 0x0040, 0xa201, 0x7030, 0x8000,
+	0x7032, 0xd5ac, 0x0040, 0xa208, 0x2071, 0xa34a, 0x1078, 0xa237,
+	0x0e7f, 0x007f, 0x127f, 0x007c, 0x127e, 0x007e, 0x0e7e, 0x2091,
+	0x8000, 0x2071, 0xa340, 0xd5a4, 0x0040, 0xa219, 0x7034, 0x8000,
+	0x7036, 0xd5b4, 0x0040, 0xa21f, 0x7030, 0x8000, 0x7032, 0xd5ac,
+	0x0040, 0xa226, 0x2071, 0xa34a, 0x1078, 0xa237, 0x0e7f, 0x007f,
+	0x127f, 0x007c, 0x127e, 0x007e, 0x0e7e, 0x2091, 0x8000, 0x2071,
+	0xa342, 0x1078, 0xa237, 0x0e7f, 0x007f, 0x127f, 0x007c, 0x2e04,
+	0x8000, 0x2072, 0x00c8, 0xa240, 0x8e70, 0x2e04, 0x8000, 0x2072,
+	0x007c, 0x0e7e, 0x2071, 0xa340, 0x1078, 0xa237, 0x0e7f, 0x007c,
+	0x0e7e, 0x2071, 0xa344, 0x1078, 0xa237, 0x0e7f, 0x007c, 0x0001,
+	0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
+	0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x6286
+};
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_length01 = 0x9260;
+#else
+unsigned short risc_code_length01 = 0x9260;
+#endif
+
diff -urN linux.orig/drivers/scsi/ql2200_fw.h linux/drivers/scsi/ql2200_fw.h
--- linux.orig/drivers/scsi/ql2200_fw.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/ql2200_fw.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,5179 @@
+/************************************************************************
+ *									*
+ *               --- ISP2200 Initiator/Target Firmware ---              *
+ *             with Fabric (Public Loop), Point-point, and              *
+ *             expanded LUN addressing for FCTAPE                       *
+ *									*
+ ************************************************************************
+  Copyright (C) 2000,2001 Qlogic Corporation 
+  (www.qlogic.com)
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+ ************************************************************************/
+/*
+ *	Firmware Version 2.01.34 (18:00 Jun 05, 2001)
+ */
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_version = 2*1024+1;
+#else
+unsigned short risc_code_version = 2*1024+1;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned char fw2200tp_version_str[] = {2,1,34};
+#else
+unsigned char firmware_version[] = {2,1,34};
+#endif
+
+#ifdef UNIQUE_FW_NAME
+#define fw2200tp_VERSION_STRING "2.01.34"
+#else
+#define FW_VERSION_STRING "2.01.34"
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_addr01 = 0x1000 ;
+#else
+unsigned short risc_code_addr01 = 0x1000 ;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_code01[] = { 
+#else
+unsigned short risc_code01[] = { 
+#endif
+	0x0470, 0x0000, 0x0000, 0xa019, 0x0000, 0x0002, 0x0001, 0x0022,
+	0x0017, 0x2043, 0x4f50, 0x5952, 0x4947, 0x4854, 0x2032, 0x3030,
+	0x3120, 0x514c, 0x4f47, 0x4943, 0x2043, 0x4f52, 0x504f, 0x5241,
+	0x5449, 0x4f4e, 0x2049, 0x5350, 0x3232, 0x3030, 0x2046, 0x6972,
+	0x6d77, 0x6172, 0x6520, 0x2056, 0x6572, 0x7369, 0x6f6e, 0x2030,
+	0x322e, 0x3031, 0x2e33, 0x3420, 0x2020, 0x2020, 0x2400, 0x20c1,
+	0x0005, 0x2001, 0x017f, 0x2003, 0x0000, 0x20c9, 0xb5ff, 0x2091,
+	0x2000, 0x2059, 0x0000, 0x2b78, 0x7823, 0x0004, 0x2089, 0x2843,
+	0x2051, 0xb100, 0x2a70, 0x2029, 0xe800, 0x2031, 0xffff, 0x2039,
+	0xe7e9, 0x2021, 0x0200, 0x0804, 0x144d, 0x20a1, 0xb019, 0xa00e,
+	0x20a9, 0x07e7, 0x41a4, 0x3400, 0x755e, 0x7662, 0x775a, 0x7466,
+	0x746a, 0x20a1, 0xb800, 0x7160, 0x810d, 0x810d, 0x810d, 0x810d,
+	0xa18c, 0x000f, 0x2001, 0x000b, 0xa112, 0xa00e, 0x21a8, 0x41a4,
+	0x3400, 0x8211, 0x1dd8, 0x7160, 0x3400, 0xa102, 0x0120, 0x0218,
+	0x20a8, 0xa00e, 0x41a4, 0x3800, 0xd08c, 0x01d8, 0x2009, 0xb100,
+	0x810d, 0x810d, 0x810d, 0x810d, 0xa18c, 0x000f, 0x2001, 0x0001,
+	0xa112, 0x20a1, 0x1000, 0xa00e, 0x21a8, 0x41a4, 0x8211, 0x1de0,
+	0x2009, 0xb100, 0x3400, 0xa102, 0x0120, 0x0218, 0x20a8, 0xa00e,
+	0x41a4, 0x080c, 0x1400, 0x080c, 0x1617, 0x080c, 0x17b0, 0x080c,
+	0x1ebd, 0x080c, 0x4a74, 0x080c, 0x828d, 0x080c, 0x15a0, 0x080c,
+	0x2d8c, 0x080c, 0x5b8b, 0x080c, 0x51aa, 0x080c, 0x668a, 0x080c,
+	0x23ea, 0x080c, 0x68d4, 0x080c, 0x6194, 0x080c, 0x22de, 0x080c,
+	0x23b8, 0x2091, 0x3009, 0x7823, 0x0000, 0x1004, 0x10c5, 0x7820,
+	0xa086, 0x0002, 0x1150, 0x7823, 0x4000, 0x0e04, 0x10bd, 0x781b,
+	0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x2a70, 0x7003, 0x0000,
+	0x2a70, 0x7000, 0xa08e, 0x0003, 0x1158, 0x080c, 0x3d97, 0x080c,
+	0x2db3, 0x080c, 0x5bd9, 0x080c, 0x5359, 0x080c, 0x66b4, 0x0c80,
+	0x000b, 0x0c98, 0x10e4, 0x10e5, 0x1207, 0x10e2, 0x12d0, 0x13fd,
+	0x13fe, 0x13ff, 0x080c, 0x14fa, 0x0005, 0x0126, 0x00f6, 0x2091,
+	0x8000, 0x7000, 0xa086, 0x0001, 0x1904, 0x11d5, 0x080c, 0x156d,
+	0x080c, 0x58d5, 0x0150, 0x080c, 0x58fb, 0x15a0, 0x2079, 0x0100,
+	0x7828, 0xa085, 0x1800, 0x782a, 0x0468, 0x080c, 0x5816, 0x7000,
+	0xa086, 0x0001, 0x1904, 0x11d5, 0x7088, 0xa086, 0x0028, 0x1904,
+	0x11d5, 0x2001, 0x0161, 0x2003, 0x0001, 0x2079, 0x0100, 0x7827,
+	0xffff, 0x7a28, 0xa295, 0x1e2f, 0x7a2a, 0x2011, 0x57ea, 0x080c,
+	0x6742, 0x2011, 0x57f7, 0x080c, 0x6742, 0x2011, 0x494f, 0x080c,
+	0x6742, 0x2011, 0x8030, 0x2019, 0x0000, 0x7087, 0x0000, 0x080c,
+	0x1d33, 0x00e8, 0x080c, 0x4305, 0x2079, 0x0100, 0x7844, 0xa005,
+	0x1904, 0x11d5, 0x2011, 0x494f, 0x080c, 0x6742, 0x2011, 0x57f7,
+	0x080c, 0x6742, 0x080c, 0x1d33, 0x2001, 0xb38d, 0x2004, 0x780e,
+	0x7840, 0xa084, 0xfffb, 0x7842, 0x2011, 0x8010, 0x73c8, 0x080c,
+	0x3d5b, 0x7238, 0xc284, 0x723a, 0x2001, 0xb10c, 0x200c, 0xc1ac,
+	0x2102, 0x080c, 0x7c1d, 0x2011, 0x0004, 0x080c, 0x9870, 0x080c,
+	0x50bf, 0x080c, 0x58d5, 0x0158, 0x080c, 0x4a5d, 0x0140, 0x7087,
+	0x0001, 0x70c3, 0x0000, 0x080c, 0x44a2, 0x0804, 0x11d5, 0x080c,
+	0x517b, 0x0120, 0x7a0c, 0xc2b4, 0x7a0e, 0x0050, 0x080c, 0x9c16,
+	0x70d0, 0xd09c, 0x1128, 0x709c, 0xa005, 0x0110, 0x080c, 0x4a3b,
+	0x70db, 0x0000, 0x70d7, 0x0000, 0x72d0, 0x080c, 0x58d5, 0x1178,
+	0x2011, 0x0000, 0x0016, 0x080c, 0x27c4, 0x2019, 0xb38f, 0x211a,
+	0x001e, 0x704f, 0xffff, 0x7053, 0x00ef, 0x7073, 0x0000, 0x2079,
+	0xb152, 0x7804, 0xd0ac, 0x0108, 0xc295, 0x72d2, 0x080c, 0x58d5,
+	0x0118, 0xa296, 0x0004, 0x0508, 0x2011, 0x0001, 0x080c, 0x9870,
+	0x7097, 0x0000, 0x709b, 0xffff, 0x7003, 0x0002, 0x00fe, 0x080c,
+	0x2991, 0x2011, 0x0005, 0x080c, 0x7d52, 0x080c, 0x6e9e, 0x080c,
+	0x58d5, 0x0148, 0x00c6, 0x2061, 0x0100, 0x0016, 0x080c, 0x27c4,
+	0x61e2, 0x001e, 0x00ce, 0x012e, 0x00d0, 0x7097, 0x0000, 0x709b,
+	0xffff, 0x7003, 0x0002, 0x2011, 0x0005, 0x080c, 0x7d52, 0x080c,
+	0x6e9e, 0x080c, 0x58d5, 0x0148, 0x00c6, 0x2061, 0x0100, 0x0016,
+	0x080c, 0x27c4, 0x61e2, 0x001e, 0x00ce, 0x00fe, 0x012e, 0x0005,
+	0x00c6, 0x080c, 0x58d5, 0x1118, 0x20a9, 0x0100, 0x0010, 0x20a9,
+	0x0082, 0x080c, 0x58d5, 0x1118, 0x2009, 0x0000, 0x0010, 0x2009,
+	0x007e, 0x0016, 0x0026, 0x0036, 0x2110, 0x0026, 0x2019, 0x0029,
+	0x080c, 0x7f67, 0x002e, 0x080c, 0xaf53, 0x003e, 0x002e, 0x001e,
+	0x080c, 0x2c6e, 0x8108, 0x1f04, 0x11e9, 0x00ce, 0x706f, 0x0000,
+	0x7070, 0xa084, 0x00ff, 0x7072, 0x709f, 0x0000, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x7000, 0xa086, 0x0002, 0x1904, 0x12ce, 0x7098,
+	0xa086, 0xffff, 0x0130, 0x080c, 0x2991, 0x080c, 0x6e9e, 0x0804,
+	0x12ce, 0x70d0, 0xd0ac, 0x1110, 0xd09c, 0x0540, 0xd084, 0x0530,
+	0x0006, 0x0016, 0x2001, 0x0103, 0x2009, 0xb38d, 0x210c, 0x2102,
+	0x001e, 0x000e, 0xd08c, 0x01d0, 0x70d4, 0xa086, 0xffff, 0x0190,
+	0x080c, 0x2af0, 0x080c, 0x6e9e, 0x70d0, 0xd094, 0x1904, 0x12ce,
+	0x2011, 0x0001, 0x2019, 0x0000, 0x080c, 0x2b26, 0x080c, 0x6e9e,
+	0x0804, 0x12ce, 0x70d8, 0xa005, 0x1904, 0x12ce, 0x7094, 0xa005,
+	0x1904, 0x12ce, 0x70d0, 0xd0a4, 0x0118, 0xd0b4, 0x0904, 0x12ce,
+	0x080c, 0x517b, 0x1904, 0x12ce, 0x2001, 0xb153, 0x2004, 0xd0ac,
+	0x01c8, 0x0156, 0x00c6, 0x20a9, 0x007f, 0x2009, 0x0000, 0x0016,
+	0x080c, 0x4e21, 0x1118, 0x6000, 0xd0ec, 0x1138, 0x001e, 0x8108,
+	0x1f04, 0x125f, 0x00ce, 0x015e, 0x0028, 0x001e, 0x00ce, 0x015e,
+	0x0804, 0x12ce, 0x0006, 0x0016, 0x2001, 0x0103, 0x2009, 0xb38d,
+	0x210c, 0x2102, 0x001e, 0x000e, 0xa006, 0x2009, 0x0700, 0x20a9,
+	0x0002, 0x20a1, 0xb3c7, 0x40a1, 0x706c, 0x8007, 0x7170, 0x810f,
+	0x20a9, 0x0002, 0x40a1, 0x2009, 0x0000, 0x080c, 0x14e0, 0x2001,
+	0x0000, 0x810f, 0x20a9, 0x0002, 0x40a1, 0xa006, 0x2009, 0x0200,
+	0x20a9, 0x0002, 0x20a1, 0xb3d7, 0x40a1, 0x7030, 0xc08c, 0x7032,
+	0x7003, 0x0003, 0x709b, 0xffff, 0x080c, 0x1566, 0xa006, 0x080c,
+	0x269e, 0x080c, 0x3dcd, 0x00f6, 0x2079, 0x0100, 0x080c, 0x58fb,
+	0x0150, 0x080c, 0x58d5, 0x7828, 0x0118, 0xa084, 0xe1ff, 0x0010,
+	0xa084, 0xffdf, 0x782a, 0x00fe, 0x2001, 0xb3da, 0x2004, 0xa086,
+	0x0005, 0x1120, 0x2011, 0x0000, 0x080c, 0x7d52, 0x2011, 0x0000,
+	0x080c, 0x7d5c, 0x080c, 0x6e9e, 0x080c, 0x6f5b, 0x012e, 0x0005,
+	0x0016, 0x0046, 0x00f6, 0x0126, 0x2091, 0x8000, 0x2079, 0x0100,
+	0x2009, 0xb133, 0x2104, 0xa005, 0x1110, 0x080c, 0x27f0, 0x2009,
+	0x00f7, 0x080c, 0x4a24, 0x7940, 0xa18c, 0x0010, 0x7942, 0x7924,
+	0xd1b4, 0x0110, 0x7827, 0x0040, 0xd19c, 0x0110, 0x7827, 0x0008,
+	0x0006, 0x0036, 0x0156, 0x7954, 0xd1ac, 0x1904, 0x133e, 0x080c,
+	0x58e7, 0x0158, 0x080c, 0x58fb, 0x1128, 0x2001, 0xb39e, 0x2003,
+	0x0000, 0x0070, 0x080c, 0x58dd, 0x0dc0, 0x2001, 0xb39e, 0x2003,
+	0xaaaa, 0x2001, 0xb39f, 0x2003, 0x0001, 0x080c, 0x5816, 0x0058,
+	0x080c, 0x58d5, 0x0140, 0x2009, 0x00f8, 0x080c, 0x4a24, 0x7843,
+	0x0090, 0x7843, 0x0010, 0x20a9, 0x09c4, 0x7820, 0xd09c, 0x1138,
+	0x080c, 0x58d5, 0x0138, 0x7824, 0xd0ac, 0x1904, 0x13e4, 0x1f04,
+	0x131d, 0x0070, 0x7824, 0x080c, 0x58f1, 0x0118, 0xd0ac, 0x1904,
+	0x13e4, 0xa084, 0x1800, 0x0d98, 0x7003, 0x0001, 0x0804, 0x13e4,
+	0x2001, 0x0001, 0x080c, 0x269e, 0x0804, 0x13f3, 0x7850, 0xa084,
+	0x0180, 0x7852, 0x782f, 0x0020, 0x20a9, 0x0046, 0x1d04, 0x1346,
+	0x2091, 0x6000, 0x1f04, 0x1346, 0x7850, 0xa084, 0x0180, 0xa085,
+	0x0400, 0x7852, 0x782f, 0x0000, 0x080c, 0x58e7, 0x0158, 0x080c,
+	0x58fb, 0x1128, 0x2001, 0xb39e, 0x2003, 0x0000, 0x0070, 0x080c,
+	0x58dd, 0x0dc0, 0x2001, 0xb39e, 0x2003, 0xaaaa, 0x2001, 0xb39f,
+	0x2003, 0x0001, 0x080c, 0x5816, 0x0020, 0x2009, 0x00f8, 0x080c,
+	0x4a24, 0x20a9, 0x000e, 0xe000, 0x1f04, 0x1373, 0x7850, 0xa084,
+	0x0180, 0xa085, 0x1400, 0x7852, 0x080c, 0x58d5, 0x0120, 0x7843,
+	0x0090, 0x7843, 0x0010, 0x2021, 0xe678, 0x2019, 0xea60, 0x7820,
+	0xd09c, 0x1558, 0x080c, 0x58d5, 0x05b8, 0x7824, 0xd0ac, 0x1904,
+	0x13e4, 0x080c, 0x58fb, 0x1508, 0x0046, 0x2021, 0x0190, 0x8421,
+	0x1df0, 0x004e, 0x8421, 0x11c8, 0x7827, 0x0048, 0x20a9, 0x01f4,
+	0x1d04, 0x13a0, 0x2091, 0x6000, 0x1f04, 0x13a0, 0x7824, 0xa084,
+	0x0068, 0x15a8, 0x2001, 0xb39e, 0x2003, 0xaaaa, 0x2001, 0xb39f,
+	0x2003, 0x0001, 0x7003, 0x0001, 0x0478, 0x8319, 0x1980, 0x2009,
+	0xb133, 0x2104, 0x8000, 0x200a, 0xa084, 0xfff0, 0x0120, 0x200b,
+	0x0000, 0x080c, 0x27f0, 0x00d8, 0x080c, 0x58e7, 0x1140, 0xa4a2,
+	0x0064, 0x1128, 0x080c, 0x58ac, 0x7003, 0x0001, 0x00a8, 0x7827,
+	0x1800, 0xe000, 0xe000, 0x7824, 0x080c, 0x58f1, 0x0110, 0xd0ac,
+	0x1158, 0xa084, 0x1800, 0x09c8, 0x7003, 0x0001, 0x0028, 0x2001,
+	0x0001, 0x080c, 0x269e, 0x0048, 0x2001, 0xb133, 0x2003, 0x0000,
+	0x7827, 0x0048, 0x7828, 0xc09d, 0x782a, 0x7850, 0xa084, 0x0180,
+	0xa085, 0x0400, 0x7852, 0x015e, 0x003e, 0x000e, 0x080c, 0x153d,
+	0x012e, 0x00fe, 0x004e, 0x001e, 0x0005, 0x0005, 0x0005, 0x0005,
+	0x2a70, 0x2001, 0xb39e, 0x2003, 0x0000, 0x7087, 0x0000, 0x2009,
+	0x0100, 0x2104, 0xa082, 0x0002, 0x0218, 0x704f, 0xffff, 0x0010,
+	0x704f, 0x0000, 0x7057, 0xffff, 0x706f, 0x0000, 0x7073, 0x0000,
+	0x080c, 0x9c16, 0x2061, 0xb38e, 0x6003, 0x0909, 0x6007, 0x0000,
+	0x600b, 0x8800, 0x600f, 0x0200, 0x6013, 0x00ff, 0x6017, 0x0003,
+	0x601b, 0x0000, 0x601f, 0x07d0, 0x2061, 0xb396, 0x6003, 0x8000,
+	0x6007, 0x0000, 0x600b, 0x0000, 0x600f, 0x0200, 0x6013, 0x00ff,
+	0x6017, 0x0000, 0x601b, 0x0001, 0x601f, 0x0000, 0x2061, 0xb3b8,
+	0x6003, 0x514c, 0x6007, 0x4f47, 0x600b, 0x4943, 0x600f, 0x2020,
+	0x2001, 0xb127, 0x2003, 0x0000, 0x0005, 0x04a0, 0x2011, 0x0000,
+	0x81ff, 0x0570, 0xa186, 0x0001, 0x1148, 0x2031, 0x8fff, 0x2039,
+	0xd001, 0x2021, 0x0100, 0x2029, 0xd000, 0x00e8, 0xa186, 0x0002,
+	0x1118, 0x2011, 0x0000, 0x00b8, 0xa186, 0x0005, 0x1118, 0x2011,
+	0x0001, 0x0088, 0xa186, 0x0009, 0x1118, 0x2011, 0x0002, 0x0058,
+	0xa186, 0x000a, 0x1118, 0x2011, 0x0002, 0x0028, 0xa186, 0x0055,
+	0x1110, 0x2011, 0x0003, 0x3800, 0xa084, 0xfffc, 0xa205, 0x20c0,
+	0x0804, 0x104d, 0xa00e, 0x2011, 0x0003, 0x2019, 0x1489, 0x0804,
+	0x14da, 0x2019, 0xaaaa, 0x2061, 0xffff, 0x2c14, 0x2362, 0xe000,
+	0xe000, 0x2c04, 0xa306, 0x2262, 0x1110, 0xc1b5, 0xc1a5, 0x2011,
+	0x0000, 0x2019, 0x149c, 0x04f0, 0x2019, 0xaaaa, 0x2061, 0xffff,
+	0x2c14, 0x2362, 0xe000, 0xe000, 0x2c1c, 0x2061, 0x7fff, 0xe000,
+	0xe000, 0x2c04, 0x2061, 0xffff, 0x2262, 0xa306, 0x0110, 0xc18d,
+	0x0008, 0xc185, 0x2011, 0x0002, 0x2019, 0x14b7, 0x0418, 0x2061,
+	0xffff, 0x2019, 0xaaaa, 0x2c14, 0x2362, 0xe000, 0xe000, 0x2c04,
+	0x2262, 0xa306, 0x1180, 0x2c14, 0x2362, 0xe000, 0xe000, 0x2c1c,
+	0x2061, 0x7fff, 0x2c04, 0x2061, 0xffff, 0x2262, 0xa306, 0x1110,
+	0xc195, 0x0008, 0xc19d, 0x2011, 0x0001, 0x2019, 0x14d8, 0x0010,
+	0x0804, 0x144e, 0x3800, 0xa084, 0xfffc, 0xa205, 0x20c0, 0x0837,
+	0x2011, 0x0000, 0x080c, 0x4e21, 0x1178, 0x6004, 0xa0c4, 0x00ff,
+	0xa8c6, 0x0006, 0x0128, 0xa0c4, 0xff00, 0xa8c6, 0x0600, 0x1120,
+	0xa186, 0x0080, 0x0108, 0x8210, 0x8108, 0xa186, 0x0100, 0x1d50,
+	0x2208, 0x0005, 0x2091, 0x8000, 0x0e04, 0x14fc, 0x0006, 0x0016,
+	0x2079, 0x0000, 0x7818, 0xd084, 0x1de8, 0x001e, 0x792e, 0x000e,
+	0x782a, 0x000e, 0x7826, 0x3900, 0x783a, 0x7823, 0x8002, 0x781b,
+	0x0001, 0x2091, 0x5000, 0x0126, 0x0156, 0x0146, 0x20a9, 0x0010,
+	0x20a1, 0xb4fc, 0x2091, 0x2000, 0x40a1, 0x20a9, 0x0010, 0x2091,
+	0x2200, 0x40a1, 0x20a9, 0x0010, 0x2091, 0x2400, 0x40a1, 0x20a9,
+	0x0010, 0x2091, 0x2600, 0x40a1, 0x20a9, 0x0010, 0x2091, 0x2800,
+	0x40a1, 0x014e, 0x015e, 0x012e, 0x2079, 0xb100, 0x7803, 0x0005,
+	0x2091, 0x4080, 0x04c9, 0x0cf8, 0x0005, 0x0006, 0x080c, 0x1588,
+	0x1518, 0x00f6, 0x2079, 0xb123, 0x2f04, 0x8000, 0x207a, 0xa082,
+	0x000f, 0x0258, 0xa006, 0x207a, 0x2079, 0xb125, 0x2f04, 0xa084,
+	0x0001, 0xa086, 0x0001, 0x207a, 0x0070, 0x2079, 0xb125, 0x2f7c,
+	0x8fff, 0x1128, 0x2001, 0x0c03, 0x2003, 0x0040, 0x0020, 0x2001,
+	0x0c03, 0x2003, 0x00c0, 0x00fe, 0x000e, 0x0005, 0x0409, 0x1120,
+	0x2001, 0x0c03, 0x2003, 0x0080, 0x0005, 0x00d1, 0x1120, 0x2001,
+	0x0c03, 0x2003, 0x0040, 0x0005, 0x0006, 0x0091, 0x1178, 0x2001,
+	0x0c03, 0x2003, 0x0040, 0x2009, 0x0fff, 0x00a1, 0x2001, 0x0c03,
+	0x2003, 0x0080, 0x2009, 0x0fff, 0x0069, 0x0c88, 0x000e, 0x0005,
+	0x00c6, 0x2061, 0x0c00, 0x2c04, 0xa084, 0x00ff, 0xa086, 0x00aa,
+	0x00ce, 0x0005, 0x0156, 0x0126, 0xa18c, 0x0fff, 0x21a8, 0x1d04,
+	0x1597, 0x2091, 0x6000, 0x1f04, 0x1597, 0x012e, 0x015e, 0x0005,
+	0x2071, 0xb100, 0x715c, 0x712e, 0x2021, 0x0001, 0xa190, 0x0030,
+	0xa298, 0x0030, 0x0240, 0x7060, 0xa302, 0x1228, 0x220a, 0x2208,
+	0x2310, 0x8420, 0x0ca8, 0x3800, 0xd08c, 0x0148, 0x7060, 0xa086,
+	0xb100, 0x0128, 0x7063, 0xb100, 0x2011, 0x1000, 0x0c48, 0x200b,
+	0x0000, 0x74ae, 0x74b2, 0x0005, 0x00e6, 0x0126, 0x2091, 0x8000,
+	0x2071, 0xb100, 0x70b0, 0xa0ea, 0x0010, 0x0268, 0x8001, 0x70b2,
+	0x702c, 0x2068, 0x2d04, 0x702e, 0x206b, 0x0000, 0x6807, 0x0000,
+	0x012e, 0x00ee, 0x0005, 0xa06e, 0x0cd8, 0x00e6, 0x2071, 0xb100,
+	0x0126, 0x2091, 0x8000, 0x70b0, 0x8001, 0x0260, 0x70b2, 0x702c,
+	0x2068, 0x2d04, 0x702e, 0x206b, 0x0000, 0x6807, 0x0000, 0x012e,
+	0x00ee, 0x0005, 0xa06e, 0x0cd8, 0x00e6, 0x0126, 0x2091, 0x8000,
+	0x2071, 0xb100, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70b0, 0x8000,
+	0x70b2, 0x012e, 0x00ee, 0x0005, 0x8dff, 0x0138, 0x6804, 0x6807,
+	0x0000, 0x0006, 0x0c49, 0x00de, 0x0cb8, 0x0005, 0x00e6, 0x2071,
+	0xb100, 0x70b0, 0xa08a, 0x0010, 0xa00d, 0x00ee, 0x0005, 0x00e6,
+	0x2071, 0xb408, 0x7007, 0x0000, 0x701b, 0x0000, 0x701f, 0x0000,
+	0x2071, 0x0000, 0x7010, 0xa085, 0x8004, 0x7012, 0x00ee, 0x0005,
+	0x00e6, 0x2270, 0x700b, 0x0000, 0x2071, 0xb408, 0x7018, 0xa088,
+	0xb411, 0x220a, 0x8000, 0xa084, 0x0007, 0x701a, 0x7004, 0xa005,
+	0x1128, 0x00f6, 0x2079, 0x0010, 0x0081, 0x00fe, 0x00ee, 0x0005,
+	0x00e6, 0x2071, 0xb408, 0x7004, 0xa005, 0x1128, 0x00f6, 0x2079,
+	0x0010, 0x0019, 0x00fe, 0x00ee, 0x0005, 0x7000, 0x0002, 0x1653,
+	0x16b7, 0x16d4, 0x16d4, 0x7018, 0x711c, 0xa106, 0x1118, 0x7007,
+	0x0000, 0x0005, 0x00d6, 0xa180, 0xb411, 0x2004, 0x700a, 0x2068,
+	0x8108, 0xa18c, 0x0007, 0x711e, 0x7803, 0x0026, 0x6824, 0x7832,
+	0x6828, 0x7836, 0x682c, 0x783a, 0x6830, 0x783e, 0x6810, 0x700e,
+	0x680c, 0x7016, 0x6804, 0x00de, 0xd084, 0x0120, 0x7007, 0x0001,
+	0x0029, 0x0005, 0x7007, 0x0002, 0x00b1, 0x0005, 0x0016, 0x0026,
+	0x710c, 0x2011, 0x0040, 0xa182, 0x0040, 0x1210, 0x2110, 0xa006,
+	0x700e, 0x7212, 0x8203, 0x7822, 0x7803, 0x0020, 0x7803, 0x0041,
+	0x002e, 0x001e, 0x0005, 0x0016, 0x0026, 0x0136, 0x0146, 0x0156,
+	0x7014, 0x2098, 0x20a1, 0x0014, 0x7803, 0x0026, 0x710c, 0x2011,
+	0x0040, 0xa182, 0x0040, 0x1210, 0x2110, 0xa006, 0x700e, 0x22a8,
+	0x53a6, 0x8203, 0x7822, 0x7803, 0x0020, 0x3300, 0x7016, 0x7803,
+	0x0001, 0x015e, 0x014e, 0x013e, 0x002e, 0x001e, 0x0005, 0x0136,
+	0x0146, 0x0156, 0x2099, 0xb1fa, 0x20a1, 0x0018, 0x20a9, 0x0008,
+	0x53a3, 0x7803, 0x0020, 0x0126, 0x2091, 0x8000, 0x7803, 0x0041,
+	0x7007, 0x0003, 0x7000, 0xc084, 0x7002, 0x700b, 0xb1f5, 0x012e,
+	0x015e, 0x014e, 0x013e, 0x0005, 0x0136, 0x0146, 0x0156, 0x2001,
+	0xb229, 0x209c, 0x20a1, 0x0014, 0x7803, 0x0026, 0x2001, 0xb22a,
+	0x20ac, 0x53a6, 0x2099, 0xb22b, 0x20a1, 0x0018, 0x20a9, 0x0008,
+	0x53a3, 0x7803, 0x0020, 0x0126, 0x2091, 0x8000, 0x7803, 0x0001,
+	0x7007, 0x0004, 0x7000, 0xc08c, 0x7002, 0x700b, 0xb226, 0x012e,
+	0x015e, 0x014e, 0x013e, 0x0005, 0x0016, 0x00e6, 0x2071, 0xb408,
+	0x00f6, 0x2079, 0x0010, 0x7904, 0x7803, 0x0002, 0xd1fc, 0x0120,
+	0xa18c, 0x0700, 0x7004, 0x0023, 0x00fe, 0x00ee, 0x001e, 0x0005,
+	0x164d, 0x1717, 0x1745, 0x176f, 0x179f, 0x1716, 0x0cf8, 0xa18c,
+	0x0700, 0x1528, 0x0136, 0x0146, 0x0156, 0x7014, 0x20a0, 0x2099,
+	0x0014, 0x7803, 0x0040, 0x7010, 0x20a8, 0x53a5, 0x3400, 0x7016,
+	0x015e, 0x014e, 0x013e, 0x700c, 0xa005, 0x0570, 0x7830, 0x7832,
+	0x7834, 0x7836, 0x080c, 0x167e, 0x0005, 0x7008, 0xa080, 0x0002,
+	0x2003, 0x0100, 0x7007, 0x0000, 0x080c, 0x164d, 0x0005, 0x7008,
+	0xa080, 0x0002, 0x2003, 0x0200, 0x0ca8, 0xa18c, 0x0700, 0x1150,
+	0x700c, 0xa005, 0x0188, 0x7830, 0x7832, 0x7834, 0x7836, 0x080c,
+	0x1693, 0x0005, 0x7008, 0xa080, 0x0002, 0x2003, 0x0200, 0x7007,
+	0x0000, 0x080c, 0x164d, 0x0005, 0x00d6, 0x7008, 0x2068, 0x7830,
+	0x6826, 0x7834, 0x682a, 0x7838, 0x682e, 0x783c, 0x6832, 0x680b,
+	0x0100, 0x00de, 0x7007, 0x0000, 0x080c, 0x164d, 0x0005, 0xa18c,
+	0x0700, 0x1540, 0x0136, 0x0146, 0x0156, 0x2001, 0xb1f8, 0x2004,
+	0xa080, 0x000d, 0x20a0, 0x2099, 0x0014, 0x7803, 0x0040, 0x20a9,
+	0x0020, 0x53a5, 0x2001, 0xb1fa, 0x2004, 0xd0bc, 0x0148, 0x2001,
+	0xb203, 0x2004, 0xa080, 0x000d, 0x20a0, 0x20a9, 0x0020, 0x53a5,
+	0x015e, 0x014e, 0x013e, 0x7007, 0x0000, 0x080c, 0x5c70, 0x080c,
+	0x164d, 0x0005, 0x2011, 0x8003, 0x080c, 0x3d5b, 0x0cf8, 0xa18c,
+	0x0700, 0x1148, 0x2001, 0xb228, 0x2003, 0x0100, 0x7007, 0x0000,
+	0x080c, 0x164d, 0x0005, 0x2011, 0x8004, 0x080c, 0x3d5b, 0x0cf8,
+	0x0126, 0x2091, 0x2200, 0x2079, 0x0030, 0x2071, 0xb419, 0x7003,
+	0x0000, 0x700f, 0xb41f, 0x7013, 0xb41f, 0x780f, 0x00f6, 0x7803,
+	0x0004, 0x012e, 0x0005, 0x6934, 0xa184, 0x0007, 0x0002, 0x17cf,
+	0x180d, 0x17cf, 0x17cf, 0x17cf, 0x17f5, 0x17dc, 0x17d3, 0xa085,
+	0x0001, 0x0804, 0x1827, 0x684c, 0xd0bc, 0x0dc8, 0x6860, 0x682e,
+	0x685c, 0x682a, 0x6858, 0x04c8, 0xa18c, 0x00ff, 0xa186, 0x001e,
+	0x1d70, 0x684c, 0xd0bc, 0x0d58, 0x6860, 0x682e, 0x685c, 0x682a,
+	0x6804, 0x681a, 0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080,
+	0x21f9, 0x2005, 0x6832, 0x6858, 0x0440, 0xa18c, 0x00ff, 0xa186,
+	0x0015, 0x19a8, 0x684c, 0xd0ac, 0x0990, 0x6804, 0x681a, 0xa080,
+	0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x21f9, 0x2005, 0x6832,
+	0xa006, 0x682e, 0x682a, 0x6858, 0x0080, 0x684c, 0xd0ac, 0x0904,
+	0x17cf, 0xa006, 0x682e, 0x682a, 0x6858, 0xa18c, 0x000f, 0xa188,
+	0x21f9, 0x210d, 0x6932, 0x2d08, 0x691a, 0x6826, 0x684c, 0xc0dd,
+	0x684e, 0xa006, 0x680a, 0x697c, 0x6912, 0x6980, 0x6916, 0x0005,
+	0x20e1, 0x0007, 0x20e1, 0x2000, 0x2001, 0x020a, 0x2004, 0x82ff,
+	0x01a8, 0xa280, 0x0004, 0x00d6, 0x206c, 0x684c, 0xd0dc, 0x1150,
+	0x080c, 0x17c3, 0x0138, 0x00de, 0xa280, 0x0000, 0x2003, 0x0002,
+	0xa016, 0x0020, 0x6808, 0x8000, 0x680a, 0x00de, 0x0126, 0x0046,
+	0x0036, 0x0026, 0x2091, 0x2200, 0x002e, 0x003e, 0x004e, 0x7000,
+	0xa005, 0x01d0, 0x710c, 0x220a, 0x8108, 0x230a, 0x8108, 0x240a,
+	0x8108, 0xa182, 0xb43a, 0x0210, 0x2009, 0xb41f, 0x710e, 0x7010,
+	0xa102, 0xa082, 0x0009, 0x0118, 0xa080, 0x001b, 0x1118, 0x2009,
+	0x0138, 0x200a, 0x012e, 0x0005, 0x7206, 0x2001, 0x186a, 0x0006,
+	0x2260, 0x0804, 0x1987, 0x0126, 0x0026, 0x0036, 0x00c6, 0x0006,
+	0x2091, 0x2200, 0x000e, 0x004e, 0x003e, 0x002e, 0x00d6, 0x00c6,
+	0x2460, 0x6110, 0x2168, 0x6a62, 0x6b5e, 0xa005, 0x0904, 0x18cc,
+	0x6808, 0xa005, 0x0904, 0x1903, 0x7000, 0xa005, 0x1108, 0x0488,
+	0x700c, 0x7110, 0xa106, 0x1904, 0x190b, 0x7004, 0xa406, 0x1548,
+	0x2001, 0x0005, 0x2004, 0xd08c, 0x0168, 0x0046, 0x080c, 0x1a86,
+	0x004e, 0x2460, 0x6010, 0xa080, 0x0002, 0x2004, 0xa005, 0x0904,
+	0x1903, 0x0c10, 0x2001, 0x0207, 0x2004, 0xd09c, 0x1d48, 0x7804,
+	0xa084, 0x6000, 0x0120, 0xa086, 0x6000, 0x0108, 0x0c08, 0x7818,
+	0x6812, 0x781c, 0x6816, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004,
+	0x2060, 0x6100, 0xa18e, 0x0004, 0x1904, 0x190b, 0x2009, 0x0048,
+	0x080c, 0x831a, 0x0804, 0x190b, 0x6808, 0xa005, 0x05a0, 0x7000,
+	0xa005, 0x0588, 0x700c, 0x7110, 0xa106, 0x1118, 0x7004, 0xa406,
+	0x1550, 0x2001, 0x0005, 0x2004, 0xd08c, 0x0160, 0x0046, 0x080c,
+	0x1a86, 0x004e, 0x2460, 0x6010, 0xa080, 0x0002, 0x2004, 0xa005,
+	0x01d0, 0x0c28, 0x2001, 0x0207, 0x2004, 0xd09c, 0x1d50, 0x2001,
+	0x0005, 0x2004, 0xd08c, 0x1d50, 0x7804, 0xa084, 0x6000, 0x0118,
+	0xa086, 0x6000, 0x19f0, 0x7818, 0x6812, 0x781c, 0x6816, 0x7803,
+	0x0004, 0x7003, 0x0000, 0x6100, 0xa18e, 0x0004, 0x1120, 0x2009,
+	0x0048, 0x080c, 0x831a, 0x00ce, 0x00de, 0x012e, 0x0005, 0x00f6,
+	0x00e6, 0x0026, 0x0036, 0x0046, 0x0056, 0x2071, 0xb419, 0x7000,
+	0xa086, 0x0000, 0x0904, 0x1965, 0x7004, 0xac06, 0x15c0, 0x2079,
+	0x0030, 0x7000, 0xa086, 0x0003, 0x0590, 0x7804, 0xd0fc, 0x1560,
+	0x2001, 0x0207, 0x2004, 0xd09c, 0x1dc0, 0x7804, 0xd0fc, 0x1520,
+	0x080c, 0x1db4, 0x0026, 0x0056, 0x7803, 0x0004, 0x7804, 0xd0ac,
+	0x1de8, 0x7803, 0x0002, 0x7803, 0x0009, 0x7003, 0x0003, 0x7007,
+	0x0000, 0x005e, 0x002e, 0x2001, 0x015d, 0x2003, 0x0000, 0x080c,
+	0x58d5, 0x1118, 0x080c, 0x5957, 0x0050, 0x2001, 0x0160, 0x2502,
+	0x2001, 0x0138, 0x2202, 0x0018, 0x080c, 0x1a86, 0x0800, 0x0156,
+	0x20a9, 0x0009, 0x2009, 0xb41f, 0x2104, 0xac06, 0x1108, 0x200a,
+	0xa188, 0x0003, 0x1f04, 0x195c, 0x015e, 0x005e, 0x004e, 0x003e,
+	0x002e, 0x00ee, 0x00fe, 0x0005, 0x700c, 0x7110, 0xa106, 0x0904,
+	0x19f7, 0x2104, 0x7006, 0x2060, 0x8108, 0x211c, 0x8108, 0x2124,
+	0x8108, 0xa182, 0xb43a, 0x0210, 0x2009, 0xb41f, 0x7112, 0x700c,
+	0xa106, 0x1128, 0x080c, 0x27c4, 0x2001, 0x0138, 0x2102, 0x8cff,
+	0x0598, 0x6010, 0x2068, 0x2d58, 0x6828, 0xa406, 0x1590, 0x682c,
+	0xa306, 0x1578, 0x7004, 0x2060, 0x6020, 0xc0d4, 0x6022, 0x684c,
+	0xd0f4, 0x0128, 0x6817, 0xffff, 0x6813, 0xffff, 0x00e8, 0x6850,
+	0xd0f4, 0x1130, 0x7803, 0x0004, 0x6810, 0x781a, 0x6814, 0x781e,
+	0x6824, 0x2050, 0x6818, 0x2060, 0x6830, 0x2040, 0x6034, 0xa0cc,
+	0x000f, 0x2009, 0x0011, 0x080c, 0x19fa, 0x0120, 0x2009, 0x0001,
+	0x080c, 0x19fa, 0x2d58, 0x0005, 0x080c, 0x1d11, 0x0904, 0x196c,
+	0x0cd0, 0x6020, 0xd0f4, 0x11e0, 0xd0d4, 0x01b8, 0x6038, 0xa402,
+	0x6034, 0xa303, 0x0108, 0x1288, 0x643a, 0x6336, 0x6c2a, 0x6b2e,
+	0x0046, 0x0036, 0x2400, 0x6c7c, 0xa402, 0x6812, 0x2300, 0x6b80,
+	0xa303, 0x6816, 0x003e, 0x004e, 0x0018, 0x080c, 0x9ba8, 0x09e0,
+	0x601c, 0xa08e, 0x0008, 0x0904, 0x1992, 0xa08e, 0x000a, 0x0904,
+	0x1992, 0x2001, 0xb174, 0x2004, 0xd0b4, 0x1120, 0x6817, 0xffff,
+	0x6813, 0xffff, 0x080c, 0x2219, 0x1938, 0x0804, 0x1992, 0x7003,
+	0x0000, 0x0005, 0x8aff, 0x0904, 0x1a60, 0xa03e, 0x2730, 0x6850,
+	0xd0fc, 0x11b8, 0xd0f4, 0x1528, 0x00d6, 0x2805, 0xac68, 0x2900,
+	0x0002, 0x1a4a, 0x1a2f, 0x1a2f, 0x1a4a, 0x1a4a, 0x1a43, 0x1a4a,
+	0x1a2f, 0x1a4a, 0x1a34, 0x1a34, 0x1a4a, 0x1a4a, 0x1a4a, 0x1a3b,
+	0x1a34, 0x7803, 0x0004, 0xc0fc, 0x6852, 0x6b6c, 0x6a70, 0x6d1c,
+	0x6c20, 0x00d6, 0xd99c, 0x0548, 0x2805, 0xac68, 0x6f08, 0x6e0c,
+	0x0420, 0xc0f4, 0x6852, 0x6b6c, 0x6a70, 0x00d6, 0x0428, 0x6b08,
+	0x6a0c, 0x6d00, 0x6c04, 0x00c8, 0x6b10, 0x6a14, 0x6d00, 0x6c04,
+	0x6f08, 0x6e0c, 0x0090, 0x00de, 0x00d6, 0x6834, 0xa084, 0x00ff,
+	0xa086, 0x001e, 0x1138, 0x00de, 0x080c, 0x21bb, 0x1904, 0x19fa,
+	0xa00e, 0x00b0, 0x00de, 0x080c, 0x14fa, 0x7b22, 0x7a26, 0x7d32,
+	0x7c36, 0x7f3a, 0x7e3e, 0x7902, 0x7000, 0x8000, 0x7002, 0x00de,
+	0x6828, 0xa300, 0x682a, 0x682c, 0xa201, 0x682e, 0x080c, 0x21bb,
+	0x0005, 0x080c, 0x14fa, 0x080c, 0x1e70, 0x7004, 0x2060, 0x00d6,
+	0x6010, 0x2068, 0x7003, 0x0000, 0x080c, 0x1d48, 0x080c, 0x986a,
+	0x0170, 0x6808, 0x8001, 0x680a, 0x697c, 0x6912, 0x6980, 0x6916,
+	0x682b, 0xffff, 0x682f, 0xffff, 0x6850, 0xc0bd, 0x6852, 0x00de,
+	0x080c, 0x955c, 0x0804, 0x1c7c, 0x080c, 0x14fa, 0x0126, 0x2091,
+	0x2200, 0x0006, 0x0016, 0x2b68, 0x6818, 0x2060, 0x7904, 0x7803,
+	0x0002, 0xa184, 0x0700, 0x1978, 0xa184, 0x0003, 0xa086, 0x0003,
+	0x0d58, 0x7000, 0x0002, 0x1aa3, 0x1aa9, 0x1bb0, 0x1c57, 0x1c6b,
+	0x1aa3, 0x1aa3, 0x1aa3, 0x7804, 0xd09c, 0x1904, 0x1c7c, 0x080c,
+	0x14fa, 0x8001, 0x7002, 0xd1bc, 0x11a0, 0xd19c, 0x1904, 0x1b3b,
+	0xd1dc, 0x1178, 0x8aff, 0x0904, 0x1b3b, 0x2009, 0x0001, 0x080c,
+	0x19fa, 0x0904, 0x1c7c, 0x2009, 0x0001, 0x080c, 0x19fa, 0x0804,
+	0x1c7c, 0x7803, 0x0004, 0x7003, 0x0000, 0xd1bc, 0x1904, 0x1b1b,
+	0x0026, 0x0036, 0x7c20, 0x7d24, 0x7e30, 0x7f34, 0x7818, 0x6812,
+	0x781c, 0x6816, 0x2001, 0x0201, 0x2004, 0xa005, 0x0140, 0x7808,
+	0xd0ec, 0x1128, 0x7803, 0x0009, 0x7003, 0x0004, 0x0010, 0x080c,
+	0x1c80, 0x6b28, 0x6a2c, 0x2400, 0x686e, 0xa31a, 0x2500, 0x6872,
+	0xa213, 0x6b2a, 0x6a2e, 0x00c6, 0x7004, 0x2060, 0x6020, 0xd0f4,
+	0x1110, 0x633a, 0x6236, 0x00ce, 0x003e, 0x002e, 0x6e1e, 0x6f22,
+	0x080c, 0x21d1, 0x2a00, 0x6826, 0x2c00, 0x681a, 0x2800, 0x6832,
+	0x6850, 0xc0fd, 0x6852, 0x6808, 0x8001, 0x680a, 0x1148, 0x684c,
+	0xd0e4, 0x0130, 0x7004, 0x2060, 0x2009, 0x0048, 0x080c, 0x831a,
+	0x7000, 0xa086, 0x0004, 0x0904, 0x1c7c, 0x7003, 0x0000, 0x080c,
+	0x196c, 0x0804, 0x1c7c, 0x0056, 0x7d0c, 0xd5bc, 0x1110, 0x080c,
+	0xafbf, 0x005e, 0x080c, 0x1d48, 0x00f6, 0x7004, 0x2078, 0x080c,
+	0x5177, 0x0118, 0x7820, 0xc0f5, 0x7822, 0x00fe, 0x682b, 0xffff,
+	0x682f, 0xffff, 0x6808, 0x8001, 0x680a, 0x697c, 0x791a, 0x6980,
+	0x791e, 0x0804, 0x1c7c, 0x7004, 0x00c6, 0x2060, 0x6020, 0x00ce,
+	0xd0f4, 0x0120, 0x6808, 0x8001, 0x680a, 0x0420, 0x7818, 0x6812,
+	0x7a1c, 0x6a16, 0xd19c, 0x0160, 0xa205, 0x0150, 0x7004, 0xa080,
+	0x0007, 0x2004, 0xa084, 0xfffd, 0xa086, 0x0008, 0x1904, 0x1ac1,
+	0x684c, 0xc0f5, 0x684e, 0x7814, 0xa005, 0x1180, 0x7003, 0x0000,
+	0x6808, 0x8001, 0x680a, 0x1130, 0x7004, 0x2060, 0x2009, 0x0048,
+	0x080c, 0x831a, 0x080c, 0x196c, 0x0804, 0x1c7c, 0x7818, 0x6812,
+	0x781c, 0x6816, 0x7814, 0x7908, 0xa18c, 0x0fff, 0xa192, 0x0841,
+	0x1a04, 0x1a63, 0xa188, 0x0007, 0x8114, 0x8214, 0x8214, 0xa10a,
+	0x8104, 0x8004, 0x8004, 0xa20a, 0x810b, 0x810b, 0x810b, 0x080c,
+	0x1dd7, 0x7803, 0x0004, 0x780f, 0xffff, 0x7803, 0x0001, 0x7804,
+	0xd0fc, 0x0de8, 0x7803, 0x0002, 0x7803, 0x0004, 0x780f, 0x00f6,
+	0x7004, 0x7007, 0x0000, 0x2060, 0x2009, 0x0048, 0x080c, 0x831a,
+	0x080c, 0x1e09, 0x0938, 0x7908, 0xd1ec, 0x1118, 0x2009, 0x0009,
+	0x0010, 0x2009, 0x0019, 0x7902, 0x7003, 0x0003, 0x0804, 0x1c7c,
+	0x8001, 0x7002, 0xd194, 0x01a8, 0x7804, 0xd0fc, 0x1904, 0x1c4a,
+	0xd09c, 0x0130, 0x7804, 0xd0fc, 0x1904, 0x1a8e, 0xd09c, 0x11a8,
+	0x8aff, 0x0904, 0x1c7c, 0x2009, 0x0001, 0x080c, 0x19fa, 0x0804,
+	0x1c7c, 0xa184, 0x0888, 0x1148, 0x8aff, 0x0904, 0x1c7c, 0x2009,
+	0x0001, 0x080c, 0x19fa, 0x0804, 0x1c7c, 0x7818, 0x6812, 0x7a1c,
+	0x6a16, 0xa205, 0x0904, 0x1b58, 0x7803, 0x0004, 0x7003, 0x0000,
+	0xd1bc, 0x1904, 0x1c2d, 0x6834, 0xa084, 0x00ff, 0xa086, 0x0029,
+	0x1118, 0xd19c, 0x1904, 0x1b58, 0x0026, 0x0036, 0x7c20, 0x7d24,
+	0x7e30, 0x7f34, 0x7818, 0x6812, 0x781c, 0x6816, 0x2001, 0x0201,
+	0x2004, 0xa005, 0x0140, 0x7808, 0xd0ec, 0x1128, 0x7803, 0x0009,
+	0x7003, 0x0004, 0x0020, 0x0016, 0x080c, 0x1c80, 0x001e, 0x6b28,
+	0x6a2c, 0x080c, 0x21d1, 0x00d6, 0x2805, 0xac68, 0x6034, 0xd09c,
+	0x1128, 0x6808, 0xa31a, 0x680c, 0xa213, 0x0020, 0x6810, 0xa31a,
+	0x6814, 0xa213, 0x00de, 0xd194, 0x0904, 0x1ae3, 0x2a00, 0x6826,
+	0x2c00, 0x681a, 0x2800, 0x6832, 0x6808, 0x8001, 0x680a, 0x6b2a,
+	0x6a2e, 0x003e, 0x002e, 0x0804, 0x1b6a, 0x0056, 0x7d0c, 0x080c,
+	0xafbf, 0x005e, 0x080c, 0x1d48, 0x00f6, 0x7004, 0x2078, 0x080c,
+	0x5177, 0x0118, 0x7820, 0xc0f5, 0x7822, 0x00fe, 0x682b, 0xffff,
+	0x682f, 0xffff, 0x6808, 0x8001, 0x680a, 0x697c, 0x791a, 0x6980,
+	0x791e, 0x0490, 0x7804, 0xd09c, 0x0904, 0x1a8e, 0x7c20, 0x7824,
+	0xa405, 0x1904, 0x1a8e, 0x7803, 0x0002, 0x0804, 0x1bd5, 0x7803,
+	0x0004, 0x7003, 0x0000, 0x7004, 0xa00d, 0x0150, 0x6808, 0x8001,
+	0x680a, 0x1130, 0x7004, 0x2060, 0x2009, 0x0048, 0x080c, 0x831a,
+	0x080c, 0x196c, 0x0088, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004,
+	0x2060, 0x6010, 0xa005, 0x0da0, 0x2068, 0x6808, 0x8000, 0x680a,
+	0x6c28, 0x6b2c, 0x080c, 0x1987, 0x001e, 0x000e, 0x012e, 0x0005,
+	0x700c, 0x7110, 0xa106, 0x0904, 0x1d05, 0x7004, 0x0016, 0x210c,
+	0xa106, 0x001e, 0x0904, 0x1d05, 0x00d6, 0x00c6, 0x216c, 0x2d00,
+	0xa005, 0x0904, 0x1d03, 0x6820, 0xd0d4, 0x1904, 0x1d03, 0x6810,
+	0x2068, 0x6850, 0xd0fc, 0x0558, 0x8108, 0x2104, 0x6b2c, 0xa306,
+	0x1904, 0x1d03, 0x8108, 0x2104, 0x6a28, 0xa206, 0x1904, 0x1d03,
+	0x6850, 0xc0fc, 0xc0f5, 0x6852, 0x686c, 0x7822, 0x6870, 0x7826,
+	0x681c, 0x7832, 0x6820, 0x7836, 0x6818, 0x2060, 0x6034, 0xd09c,
+	0x0150, 0x6830, 0x2005, 0x00d6, 0xac68, 0x6808, 0x783a, 0x680c,
+	0x783e, 0x00de, 0x04d0, 0xa006, 0x783a, 0x783e, 0x04b0, 0x8108,
+	0x2104, 0xa005, 0x15c0, 0x6b2c, 0xa306, 0x15a8, 0x8108, 0x2104,
+	0xa005, 0x1588, 0x6a28, 0xa206, 0x1570, 0x6850, 0xc0f5, 0x6852,
+	0x6830, 0x2005, 0x6918, 0xa160, 0xa180, 0x000d, 0x2004, 0xd09c,
+	0x1170, 0x6008, 0x7822, 0x686e, 0x600c, 0x7826, 0x6872, 0x6000,
+	0x7832, 0x6004, 0x7836, 0xa006, 0x783a, 0x783e, 0x0070, 0x6010,
+	0x7822, 0x686e, 0x6014, 0x7826, 0x6872, 0x6000, 0x7832, 0x6004,
+	0x7836, 0x6008, 0x783a, 0x600c, 0x783e, 0x6810, 0x781a, 0x6814,
+	0x781e, 0x7803, 0x0011, 0x00ce, 0x00de, 0x0005, 0x2011, 0x0201,
+	0x2009, 0x003c, 0x2204, 0xa005, 0x1118, 0x8109, 0x1dd8, 0x0005,
+	0x0005, 0x0ca1, 0x01e0, 0x7908, 0xd1ec, 0x1160, 0x080c, 0x1e09,
+	0x0148, 0x7803, 0x0009, 0x7904, 0xd1fc, 0x0de8, 0x7803, 0x0006,
+	0x0c29, 0x0168, 0x780c, 0xd0a4, 0x1150, 0x7007, 0x0000, 0x080c,
+	0x1e09, 0x0140, 0x7803, 0x0019, 0x7003, 0x0003, 0x0018, 0x00c1,
+	0xa085, 0x0001, 0x0005, 0x0126, 0x2091, 0x2200, 0x7000, 0xa086,
+	0x0003, 0x1160, 0x700c, 0x7110, 0xa106, 0x0140, 0x080c, 0x2835,
+	0x20e1, 0x9028, 0x700f, 0xb41f, 0x7013, 0xb41f, 0x012e, 0x0005,
+	0x00c6, 0x080c, 0x58d5, 0x1570, 0x2001, 0x0160, 0x2003, 0x0000,
+	0x2001, 0x0138, 0x2003, 0x0000, 0x2011, 0x00c8, 0xe000, 0xe000,
+	0x8211, 0x1de0, 0x080c, 0x1daa, 0x700c, 0x7110, 0xa106, 0x0190,
+	0x2104, 0xa005, 0x0130, 0x2060, 0x6010, 0x2060, 0x6008, 0x8001,
+	0x600a, 0xa188, 0x0003, 0xa182, 0xb43a, 0x0210, 0x2009, 0xb41f,
+	0x7112, 0x0c50, 0x0066, 0x2031, 0x0000, 0x080c, 0x5957, 0x006e,
+	0x00ce, 0x0005, 0x04c9, 0x080c, 0x2835, 0x20e1, 0x9028, 0x700c,
+	0x7110, 0xa106, 0x01d0, 0x2104, 0xa005, 0x0130, 0x2060, 0x6010,
+	0x2060, 0x6008, 0x8001, 0x600a, 0xa188, 0x0003, 0xa182, 0xb43a,
+	0x0210, 0x2009, 0xb41f, 0x7112, 0x700c, 0xa106, 0x1d40, 0x080c,
+	0x27c4, 0x2001, 0x0138, 0x2102, 0x0c10, 0x2001, 0x015d, 0x200c,
+	0x810a, 0x2102, 0x2001, 0x0160, 0x2502, 0x2001, 0x0138, 0x2202,
+	0x00ce, 0x0005, 0x080c, 0x2835, 0x20e1, 0x9028, 0x2001, 0x015d,
+	0x200c, 0x810a, 0x2102, 0x0005, 0x2001, 0x0138, 0x2014, 0x2003,
+	0x0000, 0x2001, 0x0160, 0x202c, 0x2003, 0x0000, 0x080c, 0x58d5,
+	0x1108, 0x0005, 0x2021, 0xb015, 0x2001, 0x0141, 0x201c, 0xd3dc,
+	0x1168, 0x2001, 0x0109, 0x201c, 0xa39c, 0x0048, 0x1138, 0x2001,
+	0x0111, 0x201c, 0x83ff, 0x1110, 0x8421, 0x1d70, 0x0005, 0x00e6,
+	0x2071, 0x0200, 0x7808, 0xa084, 0xf000, 0xa10d, 0x08a9, 0x2019,
+	0x5000, 0x8319, 0x0168, 0x2001, 0xb43a, 0x2004, 0xa086, 0x0000,
+	0x0138, 0x2001, 0x0021, 0xd0fc, 0x0da0, 0x080c, 0x205e, 0x0c78,
+	0x20e1, 0x7000, 0x7324, 0x7420, 0x7028, 0x7028, 0x7426, 0x7037,
+	0x0001, 0x810f, 0x712e, 0x702f, 0x0100, 0x7037, 0x0008, 0x7326,
+	0x7422, 0x2001, 0x0160, 0x2502, 0x2001, 0x0138, 0x2202, 0x00ee,
+	0x0005, 0x0026, 0x2001, 0x015d, 0x200c, 0x810a, 0x2102, 0x7908,
+	0xa18c, 0x0fff, 0xa182, 0x0ffd, 0x0210, 0x2009, 0x0000, 0xa190,
+	0x0007, 0xa294, 0x1ff8, 0x8214, 0x8214, 0x8214, 0x2001, 0x020a,
+	0x82ff, 0x0140, 0x20e1, 0x6000, 0x200c, 0x200c, 0x200c, 0x200c,
+	0x8211, 0x1dd0, 0x20e1, 0x7000, 0x200c, 0x200c, 0x7003, 0x0000,
+	0x20e1, 0x6000, 0x2001, 0x0208, 0x200c, 0x2001, 0x0209, 0x2004,
+	0xa106, 0x0158, 0x080c, 0x1d06, 0x0130, 0x7908, 0xd1ec, 0x1128,
+	0x790c, 0xd1a4, 0x0960, 0x080c, 0x1d48, 0xa006, 0x002e, 0x0005,
+	0x00f6, 0x00e6, 0x0016, 0x0026, 0x2071, 0xb419, 0x2079, 0x0030,
+	0x2011, 0x0050, 0x7000, 0xa086, 0x0000, 0x01a8, 0x8211, 0x0188,
+	0x2001, 0x0005, 0x2004, 0xd08c, 0x0dc8, 0x7904, 0xa18c, 0x0780,
+	0x0016, 0x080c, 0x1a86, 0x001e, 0x81ff, 0x1118, 0x2011, 0x0050,
+	0x0c48, 0xa085, 0x0001, 0x002e, 0x001e, 0x00ee, 0x00fe, 0x0005,
+	0x7803, 0x0004, 0x2009, 0x0064, 0x7804, 0xd0ac, 0x0904, 0x1ebc,
+	0x8109, 0x1dd0, 0x2009, 0x0100, 0x210c, 0xa18a, 0x0003, 0x0a0c,
+	0x14fa, 0x080c, 0x2165, 0x00e6, 0x00f6, 0x2071, 0xb408, 0x2079,
+	0x0010, 0x7004, 0xa086, 0x0000, 0x0538, 0x7800, 0x0006, 0x7820,
+	0x0006, 0x7830, 0x0006, 0x7834, 0x0006, 0x7838, 0x0006, 0x783c,
+	0x0006, 0x7803, 0x0004, 0xe000, 0xe000, 0x2079, 0x0030, 0x7804,
+	0xd0ac, 0x190c, 0x14fa, 0x2079, 0x0010, 0x000e, 0x783e, 0x000e,
+	0x783a, 0x000e, 0x7836, 0x000e, 0x7832, 0x000e, 0x7822, 0x000e,
+	0x7802, 0x00fe, 0x00ee, 0x0030, 0x00fe, 0x00ee, 0x7804, 0xd0ac,
+	0x190c, 0x14fa, 0x080c, 0x6f5b, 0x0005, 0x00e6, 0x2071, 0xb43a,
+	0x7003, 0x0000, 0x00ee, 0x0005, 0x00d6, 0xa280, 0x0004, 0x206c,
+	0x694c, 0xd1dc, 0x1904, 0x1f3a, 0x6934, 0xa184, 0x0007, 0x0002,
+	0x1ed8, 0x1f25, 0x1ed8, 0x1ed8, 0x1ed8, 0x1f0c, 0x1eeb, 0x1eda,
+	0x080c, 0x14fa, 0x684c, 0xd0b4, 0x0904, 0x2022, 0x6860, 0x682e,
+	0x6816, 0x685c, 0x682a, 0x6812, 0x687c, 0x680a, 0x6880, 0x680e,
+	0x6958, 0x0804, 0x1f2d, 0x6834, 0xa084, 0x00ff, 0xa086, 0x001e,
+	0x1d38, 0x684c, 0xd0b4, 0x0904, 0x2022, 0x6860, 0x682e, 0x6816,
+	0x685c, 0x682a, 0x6812, 0x687c, 0x680a, 0x6880, 0x680e, 0x6804,
+	0x681a, 0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x21f9,
+	0x2005, 0x6832, 0x6958, 0x0450, 0xa18c, 0x00ff, 0xa186, 0x0015,
+	0x1548, 0x684c, 0xd0b4, 0x0904, 0x2022, 0x6804, 0x681a, 0xa080,
+	0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x21f9, 0x2005, 0x6832,
+	0x6958, 0xa006, 0x682e, 0x682a, 0x0088, 0x684c, 0xd0b4, 0x0904,
+	0x1a61, 0x6958, 0xa006, 0x682e, 0x682a, 0x2d00, 0x681a, 0x6834,
+	0xa084, 0x000f, 0xa080, 0x21f9, 0x2005, 0x6832, 0x6926, 0x684c,
+	0xc0dd, 0x684e, 0x00de, 0x0005, 0x00f6, 0x2079, 0x0020, 0x7804,
+	0xd0fc, 0x190c, 0x205e, 0x00e6, 0x00d6, 0x2071, 0xb43a, 0x7000,
+	0xa005, 0x1904, 0x1fa2, 0x00c6, 0x7206, 0xa280, 0x0004, 0x205c,
+	0x7004, 0x2068, 0x7803, 0x0004, 0x6818, 0x00d6, 0x2068, 0x686c,
+	0x7812, 0x6890, 0x00f6, 0x20e1, 0x9040, 0x2079, 0x0200, 0x781a,
+	0x2079, 0x0100, 0x8004, 0x78d6, 0x00fe, 0x00de, 0x2b68, 0x6824,
+	0x2050, 0x6818, 0x2060, 0x6830, 0x2040, 0x6034, 0xa0cc, 0x000f,
+	0x6908, 0x791a, 0x7116, 0x680c, 0x781e, 0x701a, 0xa006, 0x700e,
+	0x7012, 0x7004, 0x692c, 0x6814, 0xa106, 0x1120, 0x6928, 0x6810,
+	0xa106, 0x0158, 0x0036, 0x0046, 0x6b14, 0x6c10, 0x080c, 0x2219,
+	0x004e, 0x003e, 0x0110, 0x00ce, 0x00a8, 0x8aff, 0x1120, 0x00ce,
+	0xa085, 0x0001, 0x0078, 0x0126, 0x2091, 0x8000, 0x2079, 0x0020,
+	0x2009, 0x0001, 0x0059, 0x0118, 0x2009, 0x0001, 0x0039, 0x012e,
+	0x00ce, 0xa006, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x0076, 0x0066,
+	0x0056, 0x0046, 0x0036, 0x0026, 0x8aff, 0x0904, 0x201b, 0x700c,
+	0x7214, 0xa23a, 0x7010, 0x7218, 0xa203, 0x0a04, 0x201a, 0xa705,
+	0x0904, 0x201a, 0xa03e, 0x2730, 0x6850, 0xd0fc, 0x11a8, 0x00d6,
+	0x2805, 0xac68, 0x2900, 0x0002, 0x1ffd, 0x1fe2, 0x1fe2, 0x1ffd,
+	0x1ffd, 0x1ff6, 0x1ffd, 0x1fe2, 0x1ffd, 0x1fe7, 0x1fe7, 0x1ffd,
+	0x1ffd, 0x1ffd, 0x1fee, 0x1fe7, 0xc0fc, 0x6852, 0x6b6c, 0x6a70,
+	0x6d1c, 0x6c20, 0xd99c, 0x0528, 0x00d6, 0x2805, 0xac68, 0x6f08,
+	0x6e0c, 0x00f0, 0x6b08, 0x6a0c, 0x6d00, 0x6c04, 0x00c8, 0x6b10,
+	0x6a14, 0x6d00, 0x6c04, 0x6f08, 0x6e0c, 0x0090, 0x00de, 0x00d6,
+	0x6834, 0xa084, 0x00ff, 0xa086, 0x001e, 0x1138, 0x00de, 0x080c,
+	0x21bb, 0x1904, 0x1fac, 0xa00e, 0x00f0, 0x00de, 0x080c, 0x14fa,
+	0x00de, 0x7b22, 0x7a26, 0x7d32, 0x7c36, 0x7f3a, 0x7e3e, 0x7902,
+	0x7000, 0x8000, 0x7002, 0x6828, 0xa300, 0x682a, 0x682c, 0xa201,
+	0x682e, 0x700c, 0xa300, 0x700e, 0x7010, 0xa201, 0x7012, 0x080c,
+	0x21bb, 0x0008, 0xa006, 0x002e, 0x003e, 0x004e, 0x005e, 0x006e,
+	0x007e, 0x0005, 0x080c, 0x14fa, 0x0026, 0x2001, 0x0105, 0x2003,
+	0x0010, 0x20e1, 0x9040, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004,
+	0x2060, 0x00d6, 0x6010, 0x2068, 0x080c, 0x986a, 0x0118, 0x6850,
+	0xc0bd, 0x6852, 0x601c, 0xa086, 0x0006, 0x1180, 0x2061, 0x0100,
+	0x62c8, 0x2001, 0x00fa, 0x8001, 0x1df0, 0x60c8, 0xa206, 0x1dc0,
+	0x60c4, 0x686a, 0x60c8, 0x6866, 0x7004, 0x2060, 0x00de, 0x080c,
+	0x955c, 0x20e1, 0x9040, 0x080c, 0x7f2b, 0x2011, 0x0000, 0x080c,
+	0x7d5c, 0x080c, 0x6f5b, 0x002e, 0x0804, 0x2118, 0x0126, 0x2091,
+	0x2400, 0x0006, 0x0016, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x2079,
+	0x0020, 0x2071, 0xb43a, 0x2b68, 0x6818, 0x2060, 0x7904, 0x7803,
+	0x0002, 0xa184, 0x0700, 0x1904, 0x2024, 0x7000, 0x0002, 0x2118,
+	0x207b, 0x20eb, 0x2116, 0x8001, 0x7002, 0xd19c, 0x1170, 0x8aff,
+	0x05d0, 0x2009, 0x0001, 0x080c, 0x1fa6, 0x0904, 0x2118, 0x2009,
+	0x0001, 0x080c, 0x1fa6, 0x0804, 0x2118, 0x7803, 0x0004, 0xd194,
+	0x0148, 0x6850, 0xc0fc, 0x6852, 0x8aff, 0x11d8, 0x684c, 0xc0f5,
+	0x684e, 0x00b8, 0x0026, 0x0036, 0x6b28, 0x6a2c, 0x7820, 0x686e,
+	0xa31a, 0x7824, 0x6872, 0xa213, 0x7830, 0x681e, 0x7834, 0x6822,
+	0x6b2a, 0x6a2e, 0x003e, 0x002e, 0x080c, 0x21d1, 0x6850, 0xc0fd,
+	0x6852, 0x2a00, 0x6826, 0x2c00, 0x681a, 0x2800, 0x6832, 0x7003,
+	0x0000, 0x0804, 0x2118, 0x00f6, 0x0026, 0x781c, 0x0006, 0x7818,
+	0x0006, 0x2079, 0x0100, 0x7a14, 0xa284, 0x0184, 0xa085, 0x0012,
+	0x7816, 0x0036, 0x2019, 0x1000, 0x8319, 0x090c, 0x14fa, 0x7820,
+	0xd0bc, 0x1dd0, 0x003e, 0x79c8, 0x000e, 0xa102, 0x001e, 0x0006,
+	0x0016, 0x79c4, 0x000e, 0xa103, 0x78c6, 0x000e, 0x78ca, 0xa284,
+	0x0184, 0xa085, 0x0012, 0x7816, 0x002e, 0x00fe, 0x7803, 0x0008,
+	0x7003, 0x0000, 0x0468, 0x8001, 0x7002, 0xd194, 0x0168, 0x7804,
+	0xd0fc, 0x1904, 0x206e, 0xd19c, 0x11f8, 0x8aff, 0x0508, 0x2009,
+	0x0001, 0x080c, 0x1fa6, 0x00e0, 0x0026, 0x0036, 0x6b28, 0x6a2c,
+	0x080c, 0x21d1, 0x00d6, 0x2805, 0xac68, 0x6034, 0xd09c, 0x1128,
+	0x6808, 0xa31a, 0x680c, 0xa213, 0x0020, 0x6810, 0xa31a, 0x6814,
+	0xa213, 0x00de, 0x0804, 0x209e, 0x0804, 0x209a, 0x080c, 0x14fa,
+	0x00ce, 0x00de, 0x00ee, 0x00fe, 0x001e, 0x000e, 0x012e, 0x0005,
+	0x00f6, 0x00e6, 0x2071, 0xb43a, 0x7000, 0xa086, 0x0000, 0x05d0,
+	0x2079, 0x0020, 0x0016, 0x2009, 0x0207, 0x210c, 0xd194, 0x0198,
+	0x2009, 0x020c, 0x210c, 0xa184, 0x0003, 0x0168, 0x080c, 0xaffa,
+	0x2001, 0x0133, 0x2004, 0xa005, 0x090c, 0x14fa, 0x20e1, 0x9040,
+	0x2001, 0x020c, 0x2102, 0x2009, 0x0206, 0x2104, 0x2009, 0x0203,
+	0x210c, 0xa106, 0x1110, 0x20e1, 0x9040, 0x7804, 0xd0fc, 0x09d8,
+	0x080c, 0x205e, 0x7000, 0xa086, 0x0000, 0x19a8, 0x001e, 0x7803,
+	0x0004, 0x7804, 0xd0ac, 0x1de8, 0x20e1, 0x9040, 0x7803, 0x0002,
+	0x7003, 0x0000, 0x00ee, 0x00fe, 0x0005, 0x0026, 0x00c6, 0x00d6,
+	0x00e6, 0x00f6, 0x2071, 0xb43a, 0x2079, 0x0020, 0x7000, 0xa086,
+	0x0000, 0x0540, 0x7004, 0x2060, 0x6010, 0x2068, 0x080c, 0x986a,
+	0x0158, 0x6850, 0xc0b5, 0x6852, 0x680c, 0x7a1c, 0xa206, 0x1120,
+	0x6808, 0x7a18, 0xa206, 0x01e0, 0x2001, 0x0105, 0x2003, 0x0010,
+	0x20e1, 0x9040, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004, 0x2060,
+	0x080c, 0x955c, 0x20e1, 0x9040, 0x080c, 0x7f2b, 0x2011, 0x0000,
+	0x080c, 0x7d5c, 0x00fe, 0x00ee, 0x00de, 0x00ce, 0x002e, 0x0005,
+	0x6810, 0x6a14, 0xa205, 0x1d00, 0x684c, 0xc0dc, 0x684e, 0x2c10,
+	0x080c, 0x1ec4, 0x2001, 0x0105, 0x2003, 0x0010, 0x20e1, 0x9040,
+	0x7803, 0x0004, 0x7003, 0x0000, 0x2069, 0xb3d9, 0x6833, 0x0000,
+	0x683f, 0x0000, 0x08f8, 0x8840, 0x2805, 0xa005, 0x1170, 0x6004,
+	0xa005, 0x0168, 0x681a, 0x2060, 0x6034, 0xa084, 0x000f, 0xa080,
+	0x21f9, 0x2045, 0x88ff, 0x090c, 0x14fa, 0x8a51, 0x0005, 0x2050,
+	0x0005, 0x8a50, 0x8841, 0x2805, 0xa005, 0x1190, 0x2c00, 0xad06,
+	0x0120, 0x6000, 0xa005, 0x1108, 0x2d00, 0x2060, 0x681a, 0x6034,
+	0xa084, 0x000f, 0xa080, 0x2209, 0x2045, 0x88ff, 0x090c, 0x14fa,
+	0x0005, 0x0000, 0x0011, 0x0015, 0x0019, 0x001d, 0x0021, 0x0025,
+	0x0029, 0x0000, 0x000f, 0x0015, 0x001b, 0x0021, 0x0027, 0x0000,
+	0x0000, 0x0000, 0x21ee, 0x21ea, 0x0000, 0x0000, 0x21f8, 0x0000,
+	0x21ee, 0x0000, 0x21f5, 0x21f2, 0x0000, 0x0000, 0x0000, 0x21f8,
+	0x21f5, 0x0000, 0x21f0, 0x21f0, 0x0000, 0x0000, 0x21f8, 0x0000,
+	0x21f0, 0x0000, 0x21f6, 0x21f6, 0x0000, 0x0000, 0x0000, 0x21f8,
+	0x21f6, 0x00a6, 0x0096, 0x0086, 0x6b2e, 0x6c2a, 0x6858, 0xa055,
+	0x0904, 0x22aa, 0x2d60, 0x6034, 0xa0cc, 0x000f, 0xa9c0, 0x21f9,
+	0xa986, 0x0007, 0x0130, 0xa986, 0x000e, 0x0118, 0xa986, 0x000f,
+	0x1120, 0x605c, 0xa422, 0x6060, 0xa31a, 0x2805, 0xa045, 0x1140,
+	0x0310, 0x0804, 0x22aa, 0x6004, 0xa065, 0x0904, 0x22aa, 0x0c18,
+	0x2805, 0xa005, 0x01a8, 0xac68, 0xd99c, 0x1128, 0x6808, 0xa422,
+	0x680c, 0xa31b, 0x0020, 0x6810, 0xa422, 0x6814, 0xa31b, 0x0620,
+	0x2300, 0xa405, 0x0150, 0x8a51, 0x0904, 0x22aa, 0x8840, 0x0c40,
+	0x6004, 0xa065, 0x0904, 0x22aa, 0x0830, 0x8a51, 0x0904, 0x22aa,
+	0x8840, 0x2805, 0xa005, 0x1158, 0x6004, 0xa065, 0x0904, 0x22aa,
+	0x6034, 0xa0cc, 0x000f, 0xa9c0, 0x21f9, 0x2805, 0x2040, 0x2b68,
+	0x6850, 0xc0fc, 0x6852, 0x0458, 0x8422, 0x8420, 0x831a, 0xa399,
+	0x0000, 0x00d6, 0x2b68, 0x6c6e, 0x6b72, 0x00de, 0xd99c, 0x1168,
+	0x6908, 0x2400, 0xa122, 0x690c, 0x2300, 0xa11b, 0x0a0c, 0x14fa,
+	0x6800, 0xa420, 0x6804, 0xa319, 0x0060, 0x6910, 0x2400, 0xa122,
+	0x6914, 0x2300, 0xa11b, 0x0a0c, 0x14fa, 0x6800, 0xa420, 0x6804,
+	0xa319, 0x2b68, 0x6c1e, 0x6b22, 0x6850, 0xc0fd, 0x6852, 0x2c00,
+	0x681a, 0x2800, 0x6832, 0x2a00, 0x6826, 0x000e, 0x000e, 0x000e,
+	0xa006, 0x0028, 0x008e, 0x009e, 0x00ae, 0xa085, 0x0001, 0x0005,
+	0x2001, 0x0005, 0x2004, 0xa084, 0x0007, 0x0002, 0x22be, 0x22bf,
+	0x22c2, 0x22c5, 0x22ca, 0x22cd, 0x22d2, 0x22d7, 0x0005, 0x080c,
+	0x205e, 0x0005, 0x080c, 0x1a86, 0x0005, 0x080c, 0x1a86, 0x080c,
+	0x205e, 0x0005, 0x080c, 0x16fc, 0x0005, 0x080c, 0x205e, 0x080c,
+	0x16fc, 0x0005, 0x080c, 0x1a86, 0x080c, 0x16fc, 0x0005, 0x080c,
+	0x1a86, 0x080c, 0x205e, 0x080c, 0x16fc, 0x0005, 0x0126, 0x2091,
+	0x2600, 0x2079, 0x0200, 0x2071, 0xb680, 0x2069, 0xb100, 0x2009,
+	0x0004, 0x7912, 0x7817, 0x0004, 0x080c, 0x26d1, 0x781b, 0x0002,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x20a9, 0x0080, 0x782f, 0x0000,
+	0x1f04, 0x22f6, 0x20e1, 0x9080, 0x783b, 0x001f, 0x20e1, 0x8700,
+	0x012e, 0x0005, 0x0126, 0x2091, 0x2600, 0x781c, 0xd0a4, 0x190c,
+	0x23b5, 0xa084, 0x0007, 0x0002, 0x2326, 0x2314, 0x2317, 0x231a,
+	0x231f, 0x2321, 0x2323, 0x2325, 0x080c, 0x619d, 0x0078, 0x080c,
+	0x61dc, 0x0060, 0x080c, 0x619d, 0x080c, 0x61dc, 0x0038, 0x0041,
+	0x0028, 0x0031, 0x0018, 0x0021, 0x0008, 0x0011, 0x012e, 0x0005,
+	0x0006, 0x0016, 0x0026, 0x080c, 0xaffa, 0x7930, 0xa184, 0x0003,
+	0x0170, 0x2001, 0xb3e8, 0x2004, 0xa005, 0x0130, 0x2001, 0x0133,
+	0x2004, 0xa005, 0x090c, 0x14fa, 0x20e1, 0x9040, 0x04a0, 0xa184,
+	0x0030, 0x01e0, 0x6a00, 0xa286, 0x0003, 0x1108, 0x00a0, 0x080c,
+	0x58d5, 0x1178, 0x2001, 0xb39f, 0x2003, 0x0001, 0x2001, 0xb100,
+	0x2003, 0x0001, 0xa085, 0x0001, 0x080c, 0x5919, 0x080c, 0x5816,
+	0x0010, 0x080c, 0x4992, 0x20e1, 0x9010, 0x00a8, 0xa184, 0x00c0,
+	0x0168, 0x00e6, 0x0036, 0x0046, 0x0056, 0x2071, 0xb419, 0x080c,
+	0x1d48, 0x005e, 0x004e, 0x003e, 0x00ee, 0x0028, 0xa184, 0x0300,
+	0x0110, 0x20e1, 0x9020, 0x7932, 0x002e, 0x001e, 0x000e, 0x0005,
+	0x0016, 0x00e6, 0x00f6, 0x2071, 0xb100, 0x7128, 0x2001, 0xb391,
+	0x2102, 0x2001, 0xb399, 0x2102, 0xa182, 0x0211, 0x1218, 0x2009,
+	0x0008, 0x0400, 0xa182, 0x0259, 0x1218, 0x2009, 0x0007, 0x00d0,
+	0xa182, 0x02c1, 0x1218, 0x2009, 0x0006, 0x00a0, 0xa182, 0x0349,
+	0x1218, 0x2009, 0x0005, 0x0070, 0xa182, 0x0421, 0x1218, 0x2009,
+	0x0004, 0x0040, 0xa182, 0x0581, 0x1218, 0x2009, 0x0003, 0x0010,
+	0x2009, 0x0002, 0x2079, 0x0200, 0x7912, 0x7817, 0x0004, 0x080c,
+	0x26d1, 0x00fe, 0x00ee, 0x001e, 0x0005, 0x7938, 0x080c, 0x14fa,
+	0x0126, 0x2091, 0x2800, 0x2061, 0x0100, 0x2071, 0xb100, 0x6024,
+	0x6026, 0x6053, 0x0030, 0x080c, 0x2710, 0x6050, 0xa084, 0xfe7f,
+	0x6052, 0x2009, 0x00ef, 0x6132, 0x6136, 0x080c, 0x2720, 0x60e7,
+	0x0000, 0x61ea, 0x60e3, 0x0008, 0x604b, 0xf7f7, 0x6043, 0x0000,
+	0x602f, 0x0080, 0x602f, 0x0000, 0x6007, 0x0e9f, 0x601b, 0x001e,
+	0x600f, 0x00ff, 0x2001, 0xb38d, 0x2003, 0x00ff, 0x602b, 0x002f,
+	0x012e, 0x0005, 0x2001, 0xb131, 0x2003, 0x0000, 0x2001, 0xb130,
+	0x2003, 0x0001, 0x0005, 0x0126, 0x2091, 0x2800, 0x0006, 0x0016,
+	0x0026, 0x6124, 0xa184, 0x1e2c, 0x1118, 0xa184, 0x0007, 0x002a,
+	0xa195, 0x0004, 0xa284, 0x0007, 0x0002, 0x2427, 0x240d, 0x2410,
+	0x2413, 0x2418, 0x241a, 0x241e, 0x2422, 0x080c, 0x68e7, 0x00b8,
+	0x080c, 0x69c2, 0x00a0, 0x080c, 0x69c2, 0x080c, 0x68e7, 0x0078,
+	0x0099, 0x0068, 0x080c, 0x68e7, 0x0079, 0x0048, 0x080c, 0x69c2,
+	0x0059, 0x0028, 0x080c, 0x69c2, 0x080c, 0x68e7, 0x0029, 0x002e,
+	0x001e, 0x000e, 0x012e, 0x0005, 0x6124, 0xd19c, 0x1904, 0x263f,
+	0x080c, 0x58d5, 0x0578, 0x7000, 0xa086, 0x0003, 0x0198, 0x6024,
+	0xa084, 0x1800, 0x0178, 0x080c, 0x58fb, 0x0118, 0x080c, 0x58e7,
+	0x1148, 0x6027, 0x0020, 0x6043, 0x0000, 0x2001, 0xb39e, 0x2003,
+	0xaaaa, 0x0458, 0x080c, 0x58fb, 0x15d0, 0x6024, 0xa084, 0x1800,
+	0x1108, 0x04a8, 0x2001, 0xb39e, 0x2003, 0xaaaa, 0x2001, 0xb39f,
+	0x2003, 0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0x080c, 0x5816,
+	0x0804, 0x263f, 0xd1ac, 0x1518, 0x6024, 0xd0dc, 0x1170, 0xd0e4,
+	0x1188, 0xd0d4, 0x11a0, 0xd0cc, 0x0130, 0x7088, 0xa086, 0x0028,
+	0x1110, 0x080c, 0x5a64, 0x0804, 0x263f, 0x2001, 0xb39f, 0x2003,
+	0x0000, 0x0048, 0x2001, 0xb39f, 0x2003, 0x0002, 0x0020, 0x080c,
+	0x59d7, 0x0804, 0x263f, 0x080c, 0x5b04, 0x0804, 0x263f, 0xd1ac,
+	0x0904, 0x2587, 0x080c, 0x58d5, 0x11d8, 0x6027, 0x0020, 0x0006,
+	0x0026, 0x0036, 0x080c, 0x58f1, 0x1170, 0x2001, 0xb39f, 0x2003,
+	0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0x080c, 0x5816, 0x003e,
+	0x002e, 0x000e, 0x0005, 0x003e, 0x002e, 0x000e, 0x080c, 0x58ac,
+	0x0016, 0x0046, 0x00c6, 0x644c, 0xa486, 0xf0f0, 0x1138, 0x2061,
+	0x0100, 0x644a, 0x6043, 0x0090, 0x6043, 0x0010, 0x74ca, 0xa48c,
+	0xff00, 0x7034, 0xd084, 0x0178, 0xa186, 0xf800, 0x1160, 0x7038,
+	0xd084, 0x1148, 0xc085, 0x703a, 0x0036, 0x2418, 0x2011, 0x8016,
+	0x080c, 0x3d5b, 0x003e, 0xa196, 0xff00, 0x05b8, 0x7050, 0xa084,
+	0x00ff, 0x810f, 0xa116, 0x0588, 0x7130, 0xd184, 0x1570, 0x2011,
+	0xb153, 0x2214, 0xd2ec, 0x0138, 0xc18d, 0x7132, 0x2011, 0xb153,
+	0x2214, 0xd2ac, 0x1510, 0x6240, 0xa294, 0x0010, 0x0130, 0x6248,
+	0xa294, 0xff00, 0xa296, 0xff00, 0x01c0, 0x7030, 0xd08c, 0x0904,
+	0x2552, 0x7034, 0xd08c, 0x1140, 0x2001, 0xb10c, 0x200c, 0xd1ac,
+	0x1904, 0x2552, 0xc1ad, 0x2102, 0x0036, 0x73c8, 0x2011, 0x8013,
+	0x080c, 0x3d5b, 0x003e, 0x0804, 0x2552, 0x7034, 0xd08c, 0x1140,
+	0x2001, 0xb10c, 0x200c, 0xd1ac, 0x1904, 0x2552, 0xc1ad, 0x2102,
+	0x0036, 0x73c8, 0x2011, 0x8013, 0x080c, 0x3d5b, 0x003e, 0x7130,
+	0xc185, 0x7132, 0x2011, 0xb153, 0x220c, 0xd1a4, 0x01d0, 0x0016,
+	0x2009, 0x0001, 0x2011, 0x0100, 0x080c, 0x688d, 0x2019, 0x000e,
+	0x080c, 0xac2b, 0xa484, 0x00ff, 0xa080, 0x2c8c, 0x200d, 0xa18c,
+	0xff00, 0x810f, 0x8127, 0xa006, 0x2009, 0x000e, 0x080c, 0xacae,
+	0x001e, 0xd1ac, 0x1148, 0x0016, 0x2009, 0x0000, 0x2019, 0x0004,
+	0x080c, 0x2b46, 0x001e, 0x0070, 0x0156, 0x20a9, 0x007f, 0x2009,
+	0x0000, 0x080c, 0x4e21, 0x1110, 0x080c, 0x4a80, 0x8108, 0x1f04,
+	0x2549, 0x015e, 0x00ce, 0x004e, 0x2011, 0x0003, 0x080c, 0x7d52,
+	0x2011, 0x0002, 0x080c, 0x7d5c, 0x080c, 0x7c41, 0x080c, 0x67b6,
+	0x0036, 0x2019, 0x0000, 0x080c, 0x7cc4, 0x003e, 0x60e3, 0x0000,
+	0x001e, 0x2001, 0xb100, 0x2014, 0xa296, 0x0004, 0x1128, 0xd19c,
+	0x1118, 0x6228, 0xc29d, 0x622a, 0x2003, 0x0001, 0x2001, 0xb122,
+	0x2003, 0x0000, 0x6027, 0x0020, 0x080c, 0x58fb, 0x1140, 0x0016,
+	0x2009, 0x07d0, 0x2011, 0x57f7, 0x080c, 0x67c8, 0x001e, 0xd194,
+	0x0904, 0x263f, 0x0016, 0x6220, 0xd2b4, 0x0904, 0x25f0, 0x080c,
+	0x67b6, 0x080c, 0x7a8c, 0x6027, 0x0004, 0x00f6, 0x2019, 0xb3e2,
+	0x2304, 0xa07d, 0x0570, 0x7804, 0xa086, 0x0032, 0x1550, 0x00d6,
+	0x00c6, 0x00e6, 0x2069, 0x0140, 0x618c, 0x6288, 0x7818, 0x608e,
+	0x7808, 0x608a, 0x6043, 0x0002, 0x2001, 0x0003, 0x8001, 0x1df0,
+	0x6043, 0x0000, 0x6803, 0x1000, 0x6803, 0x0000, 0x618e, 0x628a,
+	0x080c, 0x6dc1, 0x080c, 0x6e9e, 0x7810, 0x2070, 0x7037, 0x0103,
+	0x2f60, 0x080c, 0x82eb, 0x00ee, 0x00ce, 0x00de, 0x00fe, 0x001e,
+	0x0005, 0x00fe, 0x00d6, 0x2069, 0x0140, 0x6804, 0xa084, 0x4000,
+	0x0120, 0x6803, 0x1000, 0x6803, 0x0000, 0x00de, 0x00c6, 0x2061,
+	0xb3d9, 0x6028, 0xa09a, 0x00c8, 0x1238, 0x8000, 0x602a, 0x00ce,
+	0x080c, 0x7a7f, 0x0804, 0x263e, 0x2019, 0xb3e2, 0x2304, 0xa065,
+	0x0120, 0x2009, 0x0027, 0x080c, 0x831a, 0x00ce, 0x0804, 0x263e,
+	0xd2bc, 0x0904, 0x263e, 0x080c, 0x67c3, 0x6014, 0xa084, 0x0184,
+	0xa085, 0x0010, 0x6016, 0x6027, 0x0004, 0x00d6, 0x2069, 0x0140,
+	0x6804, 0xa084, 0x4000, 0x0120, 0x6803, 0x1000, 0x6803, 0x0000,
+	0x00de, 0x00c6, 0x2061, 0xb3d9, 0x6044, 0xa09a, 0x00c8, 0x12f0,
+	0x8000, 0x6046, 0x603c, 0x00ce, 0xa005, 0x0540, 0x2009, 0x07d0,
+	0x080c, 0x67bb, 0xa080, 0x0007, 0x2004, 0xa086, 0x0006, 0x1138,
+	0x6114, 0xa18c, 0x0184, 0xa18d, 0x0012, 0x6116, 0x00b8, 0x6114,
+	0xa18c, 0x0184, 0xa18d, 0x0016, 0x6116, 0x0080, 0x0036, 0x2019,
+	0x0001, 0x080c, 0x7cc4, 0x003e, 0x2019, 0xb3e8, 0x2304, 0xa065,
+	0x0120, 0x2009, 0x004f, 0x080c, 0x831a, 0x00ce, 0x001e, 0xd19c,
+	0x0904, 0x269a, 0x7034, 0xd0ac, 0x1560, 0x0016, 0x0156, 0x6027,
+	0x0008, 0x602f, 0x0020, 0x20a9, 0x0006, 0x1d04, 0x264d, 0x2091,
+	0x6000, 0x1f04, 0x264d, 0x602f, 0x0000, 0x6150, 0xa185, 0x1400,
+	0x6052, 0x20a9, 0x0366, 0x1d04, 0x265b, 0x2091, 0x6000, 0x6020,
+	0xd09c, 0x1130, 0x015e, 0x6152, 0x001e, 0x6027, 0x0008, 0x0490,
+	0x080c, 0x27e0, 0x1f04, 0x265b, 0x015e, 0x6152, 0x001e, 0x6027,
+	0x0008, 0x0016, 0x6028, 0xc09c, 0x602a, 0x2011, 0x0003, 0x080c,
+	0x7d52, 0x2011, 0x0002, 0x080c, 0x7d5c, 0x080c, 0x7c41, 0x080c,
+	0x67b6, 0x0036, 0x2019, 0x0000, 0x080c, 0x7cc4, 0x003e, 0x60e3,
+	0x0000, 0x080c, 0xafd9, 0x080c, 0xaff4, 0xa085, 0x0001, 0x080c,
+	0x5919, 0x2001, 0xb100, 0x2003, 0x0004, 0x6027, 0x0008, 0x080c,
+	0x12d0, 0x001e, 0xa18c, 0xffd0, 0x6126, 0x0005, 0x0006, 0x0016,
+	0x0026, 0x00e6, 0x00f6, 0x0126, 0x2091, 0x8000, 0x2071, 0xb100,
+	0x71c0, 0x70c2, 0xa116, 0x01f0, 0x81ff, 0x0128, 0x2011, 0x8011,
+	0x080c, 0x3d5b, 0x00b8, 0x2011, 0x8012, 0x080c, 0x3d5b, 0x2001,
+	0xb172, 0x2004, 0xd0fc, 0x1170, 0x0036, 0x00c6, 0x080c, 0x276b,
+	0x2061, 0x0100, 0x2019, 0x0028, 0x2009, 0x0000, 0x080c, 0x2b46,
+	0x00ce, 0x003e, 0x012e, 0x00fe, 0x00ee, 0x002e, 0x001e, 0x000e,
+	0x0005, 0x00c6, 0x00f6, 0x0006, 0x0026, 0x2061, 0x0100, 0xa190,
+	0x26e4, 0x2205, 0x60f2, 0x2011, 0x26f1, 0x2205, 0x60ee, 0x002e,
+	0x000e, 0x00fe, 0x00ce, 0x0005, 0x0840, 0x0840, 0x0840, 0x0580,
+	0x0420, 0x0348, 0x02c0, 0x0258, 0x0210, 0x01a8, 0x01a8, 0x01a8,
+	0x01a8, 0x0140, 0x00f8, 0x00d0, 0x00b0, 0x00a0, 0x2028, 0xa18c,
+	0x00ff, 0x2130, 0xa094, 0xff00, 0x1110, 0x81ff, 0x0118, 0x080c,
+	0x646d, 0x0038, 0xa080, 0x2c8c, 0x200d, 0xa18c, 0xff00, 0x810f,
+	0xa006, 0x0005, 0xa080, 0x2c8c, 0x200d, 0xa18c, 0x00ff, 0x0005,
+	0x00d6, 0x2069, 0x0140, 0x2001, 0xb114, 0x2003, 0x00ef, 0x20a9,
+	0x0010, 0xa006, 0x6852, 0x6856, 0x1f04, 0x271b, 0x00de, 0x0005,
+	0x0006, 0x00d6, 0x0026, 0x2069, 0x0140, 0x2001, 0xb114, 0x2102,
+	0x8114, 0x8214, 0x8214, 0x8214, 0x20a9, 0x0010, 0x6853, 0x0000,
+	0xa006, 0x82ff, 0x1128, 0xa184, 0x000f, 0xa080, 0xb008, 0x2005,
+	0x6856, 0x8211, 0x1f04, 0x2730, 0x002e, 0x00de, 0x000e, 0x0005,
+	0x00c6, 0x2061, 0xb100, 0x6030, 0x0110, 0xc09d, 0x0008, 0xc09c,
+	0x6032, 0x00ce, 0x0005, 0x0156, 0x00d6, 0x0026, 0x0016, 0x0006,
+	0x2069, 0x0140, 0x6980, 0xa116, 0x0180, 0xa112, 0x1230, 0x8212,
+	0x8210, 0x22a8, 0x2001, 0x0402, 0x0018, 0x22a8, 0x2001, 0x0404,
+	0x680e, 0x1f04, 0x2760, 0x680f, 0x0000, 0x000e, 0x001e, 0x002e,
+	0x00de, 0x015e, 0x0005, 0x2001, 0xb153, 0x2004, 0xd0c4, 0x0150,
+	0xd0a4, 0x0140, 0xa006, 0x0046, 0x2020, 0x2009, 0x002e, 0x080c,
+	0xacae, 0x004e, 0x0005, 0x00f6, 0x0016, 0x0026, 0x2079, 0x0140,
+	0x78c4, 0xd0dc, 0x0548, 0xa084, 0x0700, 0xa08e, 0x0300, 0x1520,
+	0x2011, 0x0000, 0x2009, 0x0002, 0x2300, 0xa080, 0x0020, 0x2018,
+	0x2300, 0x080c, 0x68b3, 0x2011, 0x0030, 0x2200, 0x8007, 0xa085,
+	0x004c, 0x78c2, 0x2009, 0x0204, 0x210c, 0x2200, 0xa100, 0x2009,
+	0x0138, 0x200a, 0x080c, 0x58d5, 0x1118, 0x2009, 0xb38f, 0x200a,
+	0x002e, 0x001e, 0x00fe, 0x0005, 0x78c3, 0x0000, 0x0cc8, 0x0126,
+	0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x2001, 0x0170, 0x200c,
+	0x8000, 0x2014, 0xa184, 0x0003, 0x0110, 0x0804, 0x1a84, 0x002e,
+	0x001e, 0x000e, 0x012e, 0x0005, 0x0006, 0x2001, 0x0100, 0x2004,
+	0xa082, 0x0005, 0x000e, 0x0268, 0x2001, 0x0170, 0x200c, 0xa18c,
+	0x00ff, 0xa18e, 0x004c, 0x1128, 0x200c, 0xa18c, 0xff00, 0x810f,
+	0x0010, 0x2009, 0x0000, 0x2001, 0x0204, 0x2004, 0xa108, 0x0005,
+	0x0006, 0x0156, 0x00f6, 0x2079, 0x0100, 0x20a9, 0x000a, 0x7854,
+	0xd08c, 0x1110, 0x1f04, 0x27e7, 0x00fe, 0x015e, 0x000e, 0x0005,
+	0x0016, 0x00c6, 0x0006, 0x2061, 0x0100, 0x6030, 0x0006, 0x6048,
+	0x0006, 0x60e4, 0x0006, 0x60e8, 0x0006, 0x6050, 0x0006, 0x60f0,
+	0x0006, 0x60ec, 0x0006, 0x600c, 0x0006, 0x6004, 0x0006, 0x6028,
+	0x0006, 0x60e0, 0x0006, 0x602f, 0x0100, 0x602f, 0x0000, 0xe000,
+	0xe000, 0xe000, 0xe000, 0x602f, 0x0040, 0x602f, 0x0000, 0x000e,
+	0x60e2, 0x000e, 0x602a, 0x000e, 0x6006, 0x000e, 0x600e, 0x000e,
+	0x60ee, 0x000e, 0x60f2, 0x000e, 0x6052, 0x000e, 0x60ea, 0x000e,
+	0x60e6, 0x000e, 0x604a, 0x000e, 0x6032, 0x6036, 0x2008, 0x080c,
+	0x2720, 0x000e, 0x00ce, 0x001e, 0x0005, 0x2009, 0x0171, 0x2104,
+	0xd0dc, 0x0140, 0x2009, 0x0170, 0x2104, 0x200b, 0x0080, 0xe000,
+	0xe000, 0x200a, 0x0005, 0x28d3, 0x28d7, 0x28db, 0x28e1, 0x28e7,
+	0x28ed, 0x28f3, 0x28fb, 0x2903, 0x2909, 0x290f, 0x2917, 0x291f,
+	0x2927, 0x292f, 0x2939, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943,
+	0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943,
+	0x2943, 0x2943, 0x2943, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2945, 0x2945, 0x294b, 0x294b, 0x2952,
+	0x2952, 0x2959, 0x2959, 0x2962, 0x2962, 0x2969, 0x2969, 0x2972,
+	0x2972, 0x297b, 0x297b, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943,
+	0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943,
+	0x2943, 0x2943, 0x2943, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986, 0x2986,
+	0x2986, 0x2986, 0x2986, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943,
+	0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943, 0x2943,
+	0x2943, 0x2943, 0x2943, 0x0106, 0x0006, 0x0804, 0x298e, 0x0106,
+	0x0006, 0x0804, 0x298e, 0x0106, 0x0006, 0x080c, 0x23f3, 0x0804,
+	0x298e, 0x0106, 0x0006, 0x080c, 0x23f3, 0x0804, 0x298e, 0x0106,
+	0x0006, 0x080c, 0x22b0, 0x0804, 0x298e, 0x0106, 0x0006, 0x080c,
+	0x22b0, 0x0804, 0x298e, 0x0106, 0x0006, 0x080c, 0x23f3, 0x080c,
+	0x22b0, 0x0804, 0x298e, 0x0106, 0x0006, 0x080c, 0x23f3, 0x080c,
+	0x22b0, 0x0804, 0x298e, 0x0106, 0x0006, 0x080c, 0x2302, 0x0804,
+	0x298e, 0x0106, 0x0006, 0x080c, 0x2302, 0x0804, 0x298e, 0x0106,
+	0x0006, 0x080c, 0x23f3, 0x080c, 0x2302, 0x0804, 0x298e, 0x0106,
+	0x0006, 0x080c, 0x23f3, 0x080c, 0x2302, 0x0804, 0x298e, 0x0106,
+	0x0006, 0x080c, 0x22b0, 0x080c, 0x2302, 0x0804, 0x298e, 0x0106,
+	0x0006, 0x080c, 0x22b0, 0x080c, 0x2302, 0x0804, 0x298e, 0x0106,
+	0x0006, 0x080c, 0x23f3, 0x080c, 0x22b0, 0x080c, 0x2302, 0x0804,
+	0x298e, 0x0106, 0x0006, 0x080c, 0x23f3, 0x080c, 0x22b0, 0x080c,
+	0x2302, 0x0804, 0x298e, 0xe000, 0x0cf0, 0x0106, 0x0006, 0x080c,
+	0x27af, 0x0804, 0x298e, 0x0106, 0x0006, 0x080c, 0x27af, 0x080c,
+	0x23f3, 0x04e0, 0x0106, 0x0006, 0x080c, 0x27af, 0x080c, 0x22b0,
+	0x04a8, 0x0106, 0x0006, 0x080c, 0x27af, 0x080c, 0x23f3, 0x080c,
+	0x22b0, 0x0460, 0x0106, 0x0006, 0x080c, 0x27af, 0x080c, 0x2302,
+	0x0428, 0x0106, 0x0006, 0x080c, 0x27af, 0x080c, 0x23f3, 0x080c,
+	0x2302, 0x00e0, 0x0106, 0x0006, 0x080c, 0x27af, 0x080c, 0x22b0,
+	0x080c, 0x2302, 0x0098, 0x0106, 0x0006, 0x080c, 0x27af, 0x080c,
+	0x23f3, 0x080c, 0x22b0, 0x080c, 0x2302, 0x0040, 0x20d1, 0x0000,
+	0x20d1, 0x0001, 0x20d1, 0x0000, 0x080c, 0x14fa, 0x000e, 0x010e,
+	0x000d, 0x00c6, 0x0026, 0x0046, 0x2021, 0x0000, 0x080c, 0x517b,
+	0x1904, 0x2a6e, 0x72d0, 0x2001, 0xb39e, 0x2004, 0xa005, 0x1110,
+	0xd29c, 0x0148, 0xd284, 0x1138, 0xd2bc, 0x1904, 0x2a6e, 0x080c,
+	0x2a72, 0x0804, 0x2a6e, 0xd2cc, 0x1904, 0x2a6e, 0x080c, 0x58d5,
+	0x1120, 0x709b, 0xffff, 0x0804, 0x2a6e, 0xd294, 0x0120, 0x709b,
+	0xffff, 0x0804, 0x2a6e, 0x2001, 0xb114, 0x203c, 0x7284, 0xd284,
+	0x0904, 0x2a10, 0xd28c, 0x1904, 0x2a10, 0x0036, 0x7398, 0xa38e,
+	0xffff, 0x1110, 0x2019, 0x0001, 0x8314, 0xa2e0, 0xb7c0, 0x2c04,
+	0xa38c, 0x0001, 0x0120, 0xa084, 0xff00, 0x8007, 0x0010, 0xa084,
+	0x00ff, 0xa70e, 0x0560, 0xa08e, 0x0000, 0x0548, 0xa08e, 0x00ff,
+	0x1150, 0x7230, 0xd284, 0x1538, 0x7284, 0xc28d, 0x7286, 0x709b,
+	0xffff, 0x003e, 0x0428, 0x2009, 0x0000, 0x080c, 0x26f6, 0x080c,
+	0x4dc5, 0x11b8, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1150,
+	0x7030, 0xd08c, 0x0118, 0x6000, 0xd0bc, 0x0120, 0x080c, 0x2a85,
+	0x0140, 0x0028, 0x080c, 0x2bb4, 0x080c, 0x2ab3, 0x0110, 0x8318,
+	0x0818, 0x739a, 0x0010, 0x709b, 0xffff, 0x003e, 0x0804, 0x2a6e,
+	0xa780, 0x2c8c, 0x203d, 0xa7bc, 0xff00, 0x873f, 0x2041, 0x007e,
+	0x7098, 0xa096, 0xffff, 0x1120, 0x2009, 0x0000, 0x28a8, 0x0050,
+	0xa812, 0x0220, 0x2008, 0xa802, 0x20a8, 0x0020, 0x709b, 0xffff,
+	0x0804, 0x2a6e, 0x2700, 0x0156, 0x0016, 0xa106, 0x05a0, 0xc484,
+	0x080c, 0x4e21, 0x0120, 0x080c, 0x4dc5, 0x15a8, 0x0008, 0xc485,
+	0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1130, 0x7030, 0xd08c,
+	0x01e8, 0x6000, 0xd0bc, 0x11d0, 0x7284, 0xd28c, 0x0188, 0x6004,
+	0xa084, 0x00ff, 0xa082, 0x0006, 0x02b0, 0xd484, 0x1118, 0x080c,
+	0x4de4, 0x0028, 0x080c, 0x2c41, 0x0170, 0x080c, 0x2c6e, 0x0058,
+	0x080c, 0x2bb4, 0x080c, 0x2ab3, 0x0170, 0x0028, 0x080c, 0x2c41,
+	0x0110, 0x0419, 0x0140, 0x001e, 0x8108, 0x015e, 0x1f04, 0x2a2a,
+	0x709b, 0xffff, 0x0018, 0x001e, 0x015e, 0x719a, 0x004e, 0x002e,
+	0x00ce, 0x0005, 0x00c6, 0x0016, 0x709b, 0x0001, 0x2009, 0x007e,
+	0x080c, 0x4dc5, 0x1138, 0x080c, 0x2bb4, 0x04a9, 0x0118, 0x70d0,
+	0xc0bd, 0x70d2, 0x001e, 0x00ce, 0x0005, 0x0016, 0x0076, 0x00d6,
+	0x00c6, 0x2c68, 0x2001, 0xb157, 0x2004, 0xa084, 0x00ff, 0x6842,
+	0x080c, 0x9ae4, 0x01d8, 0x2d00, 0x601a, 0x080c, 0x9c35, 0x601f,
+	0x0001, 0x2001, 0x0000, 0x080c, 0x4d63, 0x2001, 0x0000, 0x080c,
+	0x4d75, 0x0126, 0x2091, 0x8000, 0x7094, 0x8000, 0x7096, 0x012e,
+	0x2009, 0x0004, 0x080c, 0x831a, 0xa085, 0x0001, 0x00ce, 0x00de,
+	0x007e, 0x001e, 0x0005, 0x0016, 0x0076, 0x00d6, 0x00c6, 0x2c68,
+	0x2001, 0xb157, 0x2004, 0xa084, 0x00ff, 0x6842, 0x080c, 0x9ae4,
+	0x0550, 0x2d00, 0x601a, 0x6800, 0xc0c4, 0x6802, 0x68a0, 0xa086,
+	0x007e, 0x0140, 0x6804, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1110,
+	0x080c, 0x2b73, 0x080c, 0x9c35, 0x601f, 0x0001, 0x2001, 0x0000,
+	0x080c, 0x4d63, 0x2001, 0x0002, 0x080c, 0x4d75, 0x0126, 0x2091,
+	0x8000, 0x7094, 0x8000, 0x7096, 0x012e, 0x2009, 0x0002, 0x080c,
+	0x831a, 0xa085, 0x0001, 0x00ce, 0x00de, 0x007e, 0x001e, 0x0005,
+	0x00c6, 0x0026, 0x2009, 0x0080, 0x080c, 0x4dc5, 0x1120, 0x0031,
+	0x0110, 0x70d7, 0xffff, 0x002e, 0x00ce, 0x0005, 0x0016, 0x0076,
+	0x00d6, 0x00c6, 0x2c68, 0x080c, 0x8295, 0x01d8, 0x2d00, 0x601a,
+	0x080c, 0x9c35, 0x601f, 0x0001, 0x2001, 0x0000, 0x080c, 0x4d63,
+	0x2001, 0x0002, 0x080c, 0x4d75, 0x0126, 0x2091, 0x8000, 0x70d8,
+	0x8000, 0x70da, 0x012e, 0x2009, 0x0002, 0x080c, 0x831a, 0xa085,
+	0x0001, 0x00ce, 0x00de, 0x007e, 0x001e, 0x0005, 0x00c6, 0x00d6,
+	0x0126, 0x2091, 0x8000, 0x2009, 0x007f, 0x080c, 0x4dc5, 0x1190,
+	0x2c68, 0x080c, 0x8295, 0x0170, 0x2d00, 0x601a, 0x6312, 0x601f,
+	0x0001, 0x620a, 0x080c, 0x9c35, 0x2009, 0x0022, 0x080c, 0x831a,
+	0xa085, 0x0001, 0x012e, 0x00de, 0x00ce, 0x0005, 0x00e6, 0x00c6,
+	0x0066, 0x0036, 0x0026, 0x080c, 0x6b41, 0x080c, 0x6aeb, 0x080c,
+	0x8cc4, 0x2130, 0x81ff, 0x0128, 0x20a9, 0x007e, 0x2009, 0x0000,
+	0x0020, 0x20a9, 0x007f, 0x2009, 0x0000, 0x0016, 0x080c, 0x4e21,
+	0x1120, 0x080c, 0x501c, 0x080c, 0x4a80, 0x001e, 0x8108, 0x1f04,
+	0x2b5d, 0x86ff, 0x1110, 0x080c, 0x11d8, 0x002e, 0x003e, 0x006e,
+	0x00ce, 0x00ee, 0x0005, 0x00e6, 0x00c6, 0x0036, 0x0026, 0x0016,
+	0x6218, 0x2270, 0x72a0, 0x0026, 0x2019, 0x0029, 0x080c, 0x6b35,
+	0x0076, 0x2039, 0x0000, 0x080c, 0x6a6b, 0x2c08, 0x080c, 0xaa51,
+	0x007e, 0x001e, 0x2e60, 0x080c, 0x501c, 0x6210, 0x6314, 0x080c,
+	0x4a80, 0x6212, 0x6316, 0x001e, 0x002e, 0x003e, 0x00ce, 0x00ee,
+	0x0005, 0x00e6, 0x0006, 0x6018, 0xa080, 0x0028, 0x2004, 0xa086,
+	0x0080, 0x0150, 0x2071, 0xb100, 0x7094, 0xa005, 0x0110, 0x8001,
+	0x7096, 0x000e, 0x00ee, 0x0005, 0x2071, 0xb100, 0x70d8, 0xa005,
+	0x0dc0, 0x8001, 0x70da, 0x0ca8, 0x6000, 0xc08c, 0x6002, 0x0005,
+	0x00f6, 0x00e6, 0x00c6, 0x0036, 0x0026, 0x0016, 0x0156, 0x2178,
+	0x81ff, 0x1118, 0x20a9, 0x0001, 0x0098, 0x2001, 0xb153, 0x2004,
+	0xd0c4, 0x0150, 0xd0a4, 0x0140, 0xa006, 0x0046, 0x2020, 0x2009,
+	0x002d, 0x080c, 0xacae, 0x004e, 0x20a9, 0x00ff, 0x2011, 0x0000,
+	0x0026, 0xa28e, 0x007e, 0x0904, 0x2c20, 0xa28e, 0x007f, 0x0904,
+	0x2c20, 0xa28e, 0x0080, 0x05e0, 0xa288, 0xb235, 0x210c, 0x81ff,
+	0x05b8, 0x8fff, 0x1148, 0x2001, 0xb3bd, 0x0006, 0x2003, 0x0001,
+	0x04d9, 0x000e, 0x2003, 0x0000, 0x00c6, 0x2160, 0x2001, 0x0001,
+	0x080c, 0x5185, 0x00ce, 0x2019, 0x0029, 0x080c, 0x6b35, 0x0076,
+	0x2039, 0x0000, 0x080c, 0x6a6b, 0x00c6, 0x0026, 0x2160, 0x6204,
+	0xa294, 0x00ff, 0xa286, 0x0006, 0x1118, 0x6007, 0x0404, 0x0028,
+	0x2001, 0x0004, 0x8007, 0xa215, 0x6206, 0x002e, 0x00ce, 0x0016,
+	0x2c08, 0x080c, 0xaa51, 0x001e, 0x007e, 0x2160, 0x080c, 0x501c,
+	0x002e, 0x8210, 0x1f04, 0x2bd8, 0x015e, 0x001e, 0x002e, 0x003e,
+	0x00ce, 0x00ee, 0x00fe, 0x0005, 0x0046, 0x0026, 0x0016, 0x2001,
+	0xb153, 0x2004, 0xd0c4, 0x0148, 0xd0a4, 0x0138, 0xa006, 0x2220,
+	0x8427, 0x2009, 0x0029, 0x080c, 0xacae, 0x001e, 0x002e, 0x004e,
+	0x0005, 0x0016, 0x0026, 0x0036, 0x00c6, 0x7284, 0x82ff, 0x01f8,
+	0x2011, 0xb153, 0x2214, 0xd2ac, 0x11d0, 0x2100, 0x080c, 0x270a,
+	0x81ff, 0x01b8, 0x2019, 0x0001, 0x8314, 0xa2e0, 0xb7c0, 0x2c04,
+	0xd384, 0x0120, 0xa084, 0xff00, 0x8007, 0x0010, 0xa084, 0x00ff,
+	0xa116, 0x0138, 0xa096, 0x00ff, 0x0110, 0x8318, 0x0c68, 0xa085,
+	0x0001, 0x00ce, 0x003e, 0x002e, 0x001e, 0x0005, 0x0016, 0x00c6,
+	0x0126, 0x2091, 0x8000, 0xa180, 0xb235, 0x2004, 0xa065, 0x0158,
+	0x0016, 0x00c6, 0x2061, 0xb4e4, 0x001e, 0x611a, 0x080c, 0x2b73,
+	0x001e, 0x080c, 0x4de4, 0x012e, 0x00ce, 0x001e, 0x0005, 0x2001,
+	0xb134, 0x2004, 0xd0cc, 0x0005, 0x7eef, 0x7de8, 0x7ce4, 0x80e2,
+	0x7be1, 0x80e0, 0x80dc, 0x80da, 0x7ad9, 0x80d6, 0x80d5, 0x80d4,
+	0x80d3, 0x80d2, 0x80d1, 0x79ce, 0x78cd, 0x80cc, 0x80cb, 0x80ca,
+	0x80c9, 0x80c7, 0x80c6, 0x77c5, 0x76c3, 0x80bc, 0x80ba, 0x75b9,
+	0x80b6, 0x74b5, 0x73b4, 0x72b3, 0x80b2, 0x80b1, 0x80ae, 0x71ad,
+	0x80ac, 0x70ab, 0x6faa, 0x6ea9, 0x80a7, 0x6da6, 0x6ca5, 0x6ba3,
+	0x6a9f, 0x699e, 0x689d, 0x809b, 0x8098, 0x6797, 0x6690, 0x658f,
+	0x6488, 0x6384, 0x6282, 0x8081, 0x8080, 0x617c, 0x607a, 0x8079,
+	0x5f76, 0x8075, 0x8074, 0x8073, 0x8072, 0x8071, 0x806e, 0x5e6d,
+	0x806c, 0x5d6b, 0x5c6a, 0x5b69, 0x8067, 0x5a66, 0x5965, 0x5863,
+	0x575c, 0x565a, 0x5559, 0x8056, 0x8055, 0x5454, 0x5353, 0x5252,
+	0x5151, 0x504e, 0x4f4d, 0x804c, 0x804b, 0x4e4a, 0x4d49, 0x8047,
+	0x4c46, 0x8045, 0x8043, 0x803c, 0x803a, 0x8039, 0x8036, 0x4b35,
+	0x8034, 0x4a33, 0x4932, 0x4831, 0x802e, 0x472d, 0x462c, 0x452b,
+	0x442a, 0x4329, 0x4227, 0x8026, 0x8025, 0x4123, 0x401f, 0x3f1e,
+	0x3e1d, 0x3d1b, 0x3c18, 0x8017, 0x8010, 0x3b0f, 0x3a08, 0x8004,
+	0x3902, 0x8001, 0x8000, 0x8000, 0x3800, 0x3700, 0x3600, 0x8000,
+	0x3500, 0x8000, 0x8000, 0x8000, 0x3400, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x3300, 0x3200, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x3100, 0x3000, 0x8000, 0x8000, 0x2f00,
+	0x8000, 0x2e00, 0x2d00, 0x2c00, 0x8000, 0x8000, 0x8000, 0x2b00,
+	0x8000, 0x2a00, 0x2900, 0x2800, 0x8000, 0x2700, 0x2600, 0x2500,
+	0x2400, 0x2300, 0x2200, 0x8000, 0x8000, 0x2100, 0x2000, 0x1f00,
+	0x1e00, 0x1d00, 0x1c00, 0x8000, 0x8000, 0x1b00, 0x1a00, 0x8000,
+	0x1900, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x1800,
+	0x8000, 0x1700, 0x1600, 0x1500, 0x8000, 0x1400, 0x1300, 0x1200,
+	0x1100, 0x1000, 0x0f00, 0x8000, 0x8000, 0x0e00, 0x0d00, 0x0c00,
+	0x0b00, 0x0a00, 0x0900, 0x8000, 0x8000, 0x0800, 0x0700, 0x8000,
+	0x0600, 0x8000, 0x8000, 0x8000, 0x0500, 0x0400, 0x0300, 0x8000,
+	0x0200, 0x8000, 0x8000, 0x8000, 0x0100, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x0000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x2071, 0xb182, 0x7003, 0x0002,
+	0xa006, 0x7012, 0x7016, 0x703a, 0x703e, 0x7033, 0xb192, 0x7037,
+	0xb192, 0x7007, 0x0001, 0x2061, 0xb1d2, 0x6003, 0x0002, 0x0005,
+	0x1004, 0x2db2, 0x0e04, 0x2db2, 0x2071, 0xb182, 0x2b78, 0x7818,
+	0xd084, 0x1140, 0x2a60, 0x7820, 0xa08e, 0x0069, 0x1904, 0x2e97,
+	0x0804, 0x2e30, 0x0005, 0x2071, 0xb182, 0x7004, 0x0002, 0x2dbb,
+	0x2dbc, 0x2dc5, 0x2dd6, 0x0005, 0x1004, 0x2dc4, 0x0e04, 0x2dc4,
+	0x2b78, 0x7818, 0xd084, 0x01e8, 0x0005, 0x2b78, 0x2061, 0xb1d2,
+	0x6008, 0xa08e, 0x0100, 0x0128, 0xa086, 0x0200, 0x0904, 0x2e91,
+	0x0005, 0x7014, 0x2068, 0x2a60, 0x7018, 0x0807, 0x7010, 0x2068,
+	0x6834, 0xa086, 0x0103, 0x0108, 0x0005, 0x2a60, 0x2b78, 0x7018,
+	0x0807, 0x2a60, 0x7820, 0xa08a, 0x0040, 0x1210, 0x61c0, 0x0042,
+	0x2100, 0xa08a, 0x003f, 0x1a04, 0x2e8e, 0x61c0, 0x0804, 0x2e30,
+	0x2e72, 0x2e9d, 0x2ea5, 0x2ea9, 0x2eb1, 0x2eb7, 0x2ebb, 0x2ec7,
+	0x2eca, 0x2ed4, 0x2ed7, 0x2e8e, 0x2e8e, 0x2e8e, 0x2eda, 0x2e8e,
+	0x2ee9, 0x2f00, 0x2f17, 0x2f8e, 0x2f93, 0x2fbc, 0x300d, 0x301e,
+	0x303d, 0x3075, 0x307f, 0x308c, 0x309f, 0x30c0, 0x30c9, 0x30ff,
+	0x3105, 0x2e8e, 0x312e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e,
+	0x3135, 0x313f, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e,
+	0x2e8e, 0x2e8e, 0x3147, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e,
+	0x3159, 0x3161, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e,
+	0x0002, 0x318b, 0x31df, 0x323a, 0x324d, 0x2e8e, 0x3267, 0x368e,
+	0x40ba, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e,
+	0x2e8e, 0x2ed4, 0x2ed7, 0x3690, 0x2e8e, 0x369d, 0x414a, 0x41a5,
+	0x4209, 0x2e8e, 0x4268, 0x428e, 0x42ad, 0x42df, 0x2e8e, 0x2e8e,
+	0x2e8e, 0x36a1, 0x3842, 0x385c, 0x387a, 0x38db, 0x393b, 0x3946,
+	0x397e, 0x398d, 0x399c, 0x399f, 0x39c2, 0x3a0c, 0x3a84, 0x3a91,
+	0x3b92, 0x3cb2, 0x3cdb, 0x3dd9, 0x3dfb, 0x3e07, 0x3e40, 0x3f04,
+	0x2e8e, 0x2e8e, 0x2e8e, 0x2e8e, 0x3f6c, 0x3f87, 0x3ff9, 0x40ab,
+	0x713c, 0x0000, 0x2021, 0x4000, 0x080c, 0x3d38, 0x0126, 0x2091,
+	0x8000, 0x0e04, 0x2e7e, 0x7818, 0xd084, 0x0110, 0x012e, 0x0cb0,
+	0x7c22, 0x7926, 0x7a2a, 0x7b2e, 0x781b, 0x0001, 0x2091, 0x4080,
+	0x7007, 0x0001, 0x2091, 0x5000, 0x012e, 0x0005, 0x2021, 0x4001,
+	0x0c18, 0x2021, 0x4002, 0x0c00, 0x2021, 0x4003, 0x08e8, 0x2021,
+	0x4005, 0x08d0, 0x2021, 0x4006, 0x08b8, 0xa02e, 0x2520, 0x7b28,
+	0x7a2c, 0x7824, 0x7930, 0x0804, 0x3d45, 0x7823, 0x0004, 0x7824,
+	0x0807, 0xa02e, 0x2520, 0x7b28, 0x7a2c, 0x7824, 0x7930, 0x0804,
+	0x3d48, 0x7924, 0x7828, 0x2114, 0x200a, 0x0804, 0x2e72, 0x7924,
+	0x2114, 0x0804, 0x2e72, 0x2099, 0x0009, 0x20a1, 0x0009, 0x20a9,
+	0x0007, 0x53a3, 0x7924, 0x7a28, 0x7b2c, 0x0804, 0x2e72, 0x7824,
+	0x2060, 0x0090, 0x2009, 0x0002, 0x2011, 0x0001, 0x2019, 0x0022,
+	0x783b, 0x0017, 0x0804, 0x2e72, 0x7d38, 0x7c3c, 0x0840, 0x7d38,
+	0x7c3c, 0x0888, 0x2061, 0x1000, 0xe10c, 0xa006, 0x2c15, 0xa200,
+	0x8c60, 0x8109, 0x1dd8, 0x2010, 0xa005, 0x0904, 0x2e72, 0x0804,
+	0x2e94, 0x2069, 0xb152, 0x7824, 0x7930, 0xa11a, 0x1a04, 0x2e9a,
+	0x8019, 0x0904, 0x2e9a, 0x684a, 0x6942, 0x782c, 0x6852, 0x7828,
+	0x6856, 0xa006, 0x685a, 0x685e, 0x080c, 0x5ba6, 0x0804, 0x2e72,
+	0x2069, 0xb152, 0x7824, 0x7934, 0xa11a, 0x1a04, 0x2e9a, 0x8019,
+	0x0904, 0x2e9a, 0x684e, 0x6946, 0x782c, 0x6862, 0x7828, 0x6866,
+	0xa006, 0x686a, 0x686e, 0x080c, 0x523e, 0x0804, 0x2e72, 0xa02e,
+	0x2520, 0x81ff, 0x1904, 0x2e97, 0x7924, 0x7b28, 0x7a2c, 0x20a9,
+	0x0005, 0x20a1, 0xb189, 0x41a1, 0x080c, 0x3d04, 0x0904, 0x2e97,
+	0x2009, 0x0020, 0x080c, 0x3d45, 0x701b, 0x2f2f, 0x0005, 0x6834,
+	0x2008, 0xa084, 0x00ff, 0xa096, 0x0011, 0x0120, 0xa096, 0x0019,
+	0x1904, 0x2e97, 0x810f, 0xa18c, 0x00ff, 0x0904, 0x2e97, 0x710e,
+	0x700c, 0x8001, 0x0528, 0x700e, 0x080c, 0x3d04, 0x0904, 0x2e97,
+	0x2009, 0x0020, 0x2061, 0xb1d2, 0x6224, 0x6328, 0x642c, 0x6530,
+	0xa290, 0x0040, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000,
+	0x080c, 0x3d45, 0x701b, 0x2f5d, 0x0005, 0x6834, 0xa084, 0x00ff,
+	0xa096, 0x0002, 0x0120, 0xa096, 0x000a, 0x1904, 0x2e97, 0x08c0,
+	0x7010, 0x2068, 0x6838, 0xc0fd, 0x683a, 0x080c, 0x4cc1, 0x1128,
+	0x7007, 0x0003, 0x701b, 0x2f77, 0x0005, 0x080c, 0x5344, 0x0126,
+	0x2091, 0x8000, 0x20a9, 0x0005, 0x2099, 0xb189, 0x530a, 0x2100,
+	0xa210, 0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0xad80,
+	0x000d, 0x2009, 0x0020, 0x012e, 0x0804, 0x3d48, 0x61a8, 0x7824,
+	0x60aa, 0x0804, 0x2e72, 0x2091, 0x8000, 0x7823, 0x4000, 0x7827,
+	0x4953, 0x782b, 0x5020, 0x782f, 0x2020, 0x2009, 0x017f, 0x2104,
+	0x7832, 0x3f00, 0x7836, 0x2061, 0x0100, 0x6200, 0x2061, 0x0200,
+	0x603c, 0x8007, 0xa205, 0x783a, 0x2009, 0x04fd, 0x2104, 0x783e,
+	0x781b, 0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x2071, 0x0010,
+	0x20c1, 0x00f0, 0x0804, 0x0427, 0x81ff, 0x1904, 0x2e97, 0x7924,
+	0x810f, 0xa18c, 0x00ff, 0x080c, 0x4e21, 0x1904, 0x2e9a, 0x7e38,
+	0xa684, 0x3fff, 0xa082, 0x4000, 0x0210, 0x0804, 0x2e9a, 0x7c28,
+	0x7d2c, 0x080c, 0x4fe3, 0xd28c, 0x1118, 0x080c, 0x4f8e, 0x0010,
+	0x080c, 0x4fbc, 0x1518, 0x2061, 0xb800, 0x0126, 0x2091, 0x8000,
+	0x6000, 0xa086, 0x0000, 0x0148, 0x6010, 0xa06d, 0x0130, 0x683c,
+	0xa406, 0x1118, 0x6840, 0xa506, 0x0150, 0x012e, 0xace0, 0x0018,
+	0x2001, 0xb116, 0x2004, 0xac02, 0x1a04, 0x2e97, 0x0c30, 0x080c,
+	0x955c, 0x012e, 0x0904, 0x2e97, 0x0804, 0x2e72, 0xa00e, 0x2001,
+	0x0005, 0x080c, 0x5344, 0x0126, 0x2091, 0x8000, 0x080c, 0x9ae0,
+	0x080c, 0x5271, 0x012e, 0x0804, 0x2e72, 0x81ff, 0x1904, 0x2e97,
+	0x080c, 0x3d19, 0x0904, 0x2e9a, 0x080c, 0x4ee3, 0x0904, 0x2e97,
+	0x080c, 0x4fef, 0x0904, 0x2e97, 0x0804, 0x2e72, 0x81ff, 0x1904,
+	0x2e97, 0x080c, 0x3d29, 0x0904, 0x2e9a, 0x080c, 0x505b, 0x0904,
+	0x2e97, 0x2019, 0x0005, 0x7924, 0x080c, 0x500a, 0x0904, 0x2e97,
+	0x7828, 0xa08a, 0x1000, 0x1a04, 0x2e9a, 0x8003, 0x800b, 0x810b,
+	0xa108, 0x080c, 0x674e, 0x0804, 0x2e72, 0x0126, 0x2091, 0x8000,
+	0x81ff, 0x0118, 0x2009, 0x0001, 0x0450, 0x2029, 0x00ff, 0x644c,
+	0x2400, 0xa506, 0x01f8, 0x2508, 0x080c, 0x4e21, 0x11d8, 0x080c,
+	0x505b, 0x1128, 0x2009, 0x0002, 0x62b0, 0x2518, 0x00c0, 0x2019,
+	0x0004, 0xa00e, 0x080c, 0x500a, 0x1118, 0x2009, 0x0006, 0x0078,
+	0x7824, 0xa08a, 0x1000, 0x1270, 0x8003, 0x800b, 0x810b, 0xa108,
+	0x080c, 0x674e, 0x8529, 0x1ae0, 0x012e, 0x0804, 0x2e72, 0x012e,
+	0x0804, 0x2e97, 0x012e, 0x0804, 0x2e9a, 0x080c, 0x3d19, 0x0904,
+	0x2e9a, 0x080c, 0x4f49, 0x080c, 0x4fe3, 0x0804, 0x2e72, 0x81ff,
+	0x1904, 0x2e97, 0x080c, 0x3d19, 0x0904, 0x2e9a, 0x080c, 0x4f3a,
+	0x080c, 0x4fe3, 0x0804, 0x2e72, 0x81ff, 0x1904, 0x2e97, 0x080c,
+	0x3d19, 0x0904, 0x2e9a, 0x080c, 0x4fbe, 0x0904, 0x2e97, 0x080c,
+	0x4d05, 0x080c, 0x4f87, 0x080c, 0x4fe3, 0x0804, 0x2e72, 0x080c,
+	0x3d19, 0x0904, 0x2e9a, 0x080c, 0x4ee3, 0x0904, 0x2e97, 0x62a0,
+	0x2019, 0x0005, 0x00c6, 0x080c, 0x501c, 0x2061, 0x0000, 0x080c,
+	0x6b35, 0x0076, 0x2039, 0x0000, 0x080c, 0x6a6b, 0x2009, 0x0000,
+	0x080c, 0xaa51, 0x007e, 0x00ce, 0x080c, 0x4fe3, 0x0804, 0x2e72,
+	0x080c, 0x3d19, 0x0904, 0x2e9a, 0x080c, 0x4fe3, 0x2208, 0x0804,
+	0x2e72, 0x0156, 0x00d6, 0x00e6, 0x2069, 0xb214, 0x6810, 0x6914,
+	0xa10a, 0x1210, 0x2009, 0x0000, 0x6816, 0x2011, 0x0000, 0x2019,
+	0x0000, 0x20a9, 0x007e, 0x2069, 0xb235, 0x2d04, 0xa075, 0x0130,
+	0x704c, 0x0071, 0xa210, 0x7080, 0x0059, 0xa318, 0x8d68, 0x1f04,
+	0x30dd, 0x2300, 0xa218, 0x00ee, 0x00de, 0x015e, 0x0804, 0x2e72,
+	0x00f6, 0x0016, 0xa07d, 0x0140, 0x2001, 0x0000, 0x8000, 0x2f0c,
+	0x81ff, 0x0110, 0x2178, 0x0cd0, 0x001e, 0x00fe, 0x0005, 0x2069,
+	0xb214, 0x6910, 0x62ac, 0x0804, 0x2e72, 0x81ff, 0x1904, 0x2e97,
+	0x614c, 0xa190, 0x2c8c, 0x2215, 0xa294, 0x00ff, 0x636c, 0x83ff,
+	0x0108, 0x6270, 0x67d0, 0xd79c, 0x0118, 0x2031, 0x0001, 0x0090,
+	0xd7ac, 0x0118, 0x2031, 0x0003, 0x0068, 0xd7a4, 0x0118, 0x2031,
+	0x0002, 0x0040, 0x080c, 0x58d5, 0x1118, 0x2031, 0x0004, 0x0010,
+	0x2031, 0x0000, 0x7e3a, 0x7f3e, 0x0804, 0x2e72, 0x613c, 0x6240,
+	0x2019, 0xb3b5, 0x231c, 0x0804, 0x2e72, 0x0126, 0x2091, 0x8000,
+	0x6134, 0xa006, 0x2010, 0x2018, 0x012e, 0x0804, 0x2e72, 0x080c,
+	0x3d29, 0x0904, 0x2e9a, 0x6244, 0x6338, 0x0804, 0x2e72, 0x613c,
+	0x6240, 0x7824, 0x603e, 0x7b28, 0x6342, 0x2069, 0xb152, 0x831f,
+	0xa305, 0x6816, 0x782c, 0x2069, 0xb3b5, 0x2d1c, 0x206a, 0x0804,
+	0x2e72, 0x0126, 0x2091, 0x8000, 0x7824, 0x6036, 0x012e, 0x0804,
+	0x2e72, 0x7838, 0xa005, 0x01a8, 0x7828, 0xa025, 0x0904, 0x2e9a,
+	0x782c, 0xa02d, 0x0904, 0x2e9a, 0xa00e, 0x080c, 0x4e21, 0x1120,
+	0x6244, 0x6338, 0x6446, 0x653a, 0xa186, 0x00ff, 0x0190, 0x8108,
+	0x0ca0, 0x080c, 0x3d29, 0x0904, 0x2e9a, 0x7828, 0xa00d, 0x0904,
+	0x2e9a, 0x782c, 0xa005, 0x0904, 0x2e9a, 0x6244, 0x6146, 0x6338,
+	0x603a, 0x0804, 0x2e72, 0x2001, 0xb100, 0x2004, 0xa086, 0x0003,
+	0x1904, 0x2e97, 0x00c6, 0x2061, 0x0100, 0x7924, 0x810f, 0xa18c,
+	0x00ff, 0xa196, 0x00ff, 0x1130, 0x2001, 0xb114, 0x2004, 0xa085,
+	0xff00, 0x0078, 0xa182, 0x007f, 0x16a0, 0xa188, 0x2c8c, 0x210d,
+	0xa18c, 0x00ff, 0x2001, 0xb114, 0x2004, 0xa116, 0x0550, 0x810f,
+	0xa105, 0x0126, 0x2091, 0x8000, 0x0006, 0x080c, 0x8295, 0x000e,
+	0x01e0, 0x601a, 0x600b, 0xbc09, 0x601f, 0x0001, 0x080c, 0x3d04,
+	0x01d8, 0x6837, 0x0000, 0x7007, 0x0003, 0x6833, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x701b, 0x3233, 0x2d00, 0x6012, 0x2009, 0x0032,
+	0x080c, 0x831a, 0x012e, 0x00ce, 0x0005, 0x012e, 0x00ce, 0x0804,
+	0x2e97, 0x00ce, 0x0804, 0x2e9a, 0x080c, 0x82eb, 0x0cb0, 0x2001,
+	0xb100, 0x2004, 0xa086, 0x0003, 0x1904, 0x2e97, 0x00c6, 0x2061,
+	0x0100, 0x7924, 0x810f, 0xa18c, 0x00ff, 0xa196, 0x00ff, 0x1130,
+	0x2001, 0xb114, 0x2004, 0xa085, 0xff00, 0x0078, 0xa182, 0x007f,
+	0x16a0, 0xa188, 0x2c8c, 0x210d, 0xa18c, 0x00ff, 0x2001, 0xb114,
+	0x2004, 0xa116, 0x0550, 0x810f, 0xa105, 0x0126, 0x2091, 0x8000,
+	0x0006, 0x080c, 0x8295, 0x000e, 0x01e0, 0x601a, 0x600b, 0xbc05,
+	0x601f, 0x0001, 0x080c, 0x3d04, 0x01d8, 0x6837, 0x0000, 0x7007,
+	0x0003, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x701b, 0x3233,
+	0x2d00, 0x6012, 0x2009, 0x0032, 0x080c, 0x831a, 0x012e, 0x00ce,
+	0x0005, 0x012e, 0x00ce, 0x0804, 0x2e97, 0x00ce, 0x0804, 0x2e9a,
+	0x080c, 0x82eb, 0x0cb0, 0x6830, 0xa086, 0x0100, 0x0904, 0x2e97,
+	0x0804, 0x2e72, 0x2061, 0xb464, 0x0126, 0x2091, 0x8000, 0x6000,
+	0xd084, 0x0140, 0x6104, 0x6208, 0x2019, 0xb111, 0x231c, 0x012e,
+	0x0804, 0x2e72, 0x012e, 0x0804, 0x2e9a, 0x81ff, 0x1904, 0x2e97,
+	0x080c, 0x58d5, 0x0904, 0x2e97, 0x0126, 0x2091, 0x8000, 0x6244,
+	0x6064, 0xa202, 0x0248, 0xa085, 0x0001, 0x080c, 0x2740, 0x080c,
+	0x44a2, 0x012e, 0x0804, 0x2e72, 0x012e, 0x0804, 0x2e9a, 0x0126,
+	0x2091, 0x8000, 0x7824, 0xa084, 0x0007, 0x0002, 0x3279, 0x3282,
+	0x3289, 0x3276, 0x3276, 0x3276, 0x3276, 0x3276, 0x012e, 0x0804,
+	0x2e9a, 0x2009, 0x0114, 0x2104, 0xa085, 0x0800, 0x200a, 0x080c,
+	0x33f2, 0x0070, 0x2009, 0x010b, 0x200b, 0x0010, 0x080c, 0x33f2,
+	0x0038, 0x81ff, 0x0128, 0x012e, 0x2021, 0x400b, 0x0804, 0x2e74,
+	0x0086, 0x0096, 0x00a6, 0x00b6, 0x00c6, 0x00d6, 0x00e6, 0x00f6,
+	0x2009, 0x0101, 0x210c, 0x0016, 0x2001, 0x0138, 0x200c, 0x2003,
+	0x0001, 0x0016, 0x2001, 0x007a, 0x2034, 0x2001, 0x007b, 0x202c,
+	0xa006, 0x2048, 0x2050, 0x2058, 0x080c, 0x3633, 0x080c, 0x359d,
+	0xa03e, 0x2720, 0x00f6, 0x00e6, 0x00c6, 0x2d60, 0x2071, 0xb43a,
+	0x2079, 0x0020, 0x00d6, 0x2069, 0x0000, 0x6824, 0xd0b4, 0x0140,
+	0x2001, 0x007d, 0x2004, 0x783e, 0x2001, 0x007c, 0x2004, 0x783a,
+	0x00de, 0x2011, 0x0001, 0x080c, 0x3549, 0x080c, 0x3549, 0x00ce,
+	0x00ee, 0x00fe, 0x080c, 0x3498, 0x080c, 0x3571, 0x080c, 0x34ee,
+	0x080c, 0x3457, 0x080c, 0x3488, 0x00f6, 0x2079, 0x0100, 0x7824,
+	0xd094, 0x0530, 0x7814, 0xa084, 0x0184, 0xa085, 0x0010, 0x7816,
+	0x2079, 0x0140, 0x080c, 0x33d0, 0x1110, 0x00fe, 0x0430, 0x7804,
+	0xd0dc, 0x0dc0, 0x2079, 0x0100, 0x7827, 0x0086, 0x7814, 0xa084,
+	0x0184, 0xa085, 0x0032, 0x7816, 0x080c, 0x33d0, 0x1110, 0x00fe,
+	0x00a0, 0x7824, 0xd0bc, 0x0dc0, 0x7827, 0x0080, 0xa026, 0x7c16,
+	0x7824, 0xd0ac, 0x0130, 0x8b58, 0x080c, 0x33da, 0x00fe, 0x0804,
+	0x339a, 0x00fe, 0x080c, 0x33d0, 0x1150, 0x8948, 0x2001, 0x007a,
+	0x2602, 0x2001, 0x007b, 0x2502, 0x080c, 0x33da, 0x0088, 0x87ff,
+	0x0140, 0x2001, 0x0201, 0x2004, 0xa005, 0x1904, 0x32d4, 0x8739,
+	0x0038, 0x2001, 0xb419, 0x2004, 0xa086, 0x0000, 0x1904, 0x32d4,
+	0x2001, 0x0033, 0x2003, 0x00f6, 0x8631, 0x1208, 0x8529, 0x2500,
+	0xa605, 0x0904, 0x339a, 0x7824, 0xd0bc, 0x0128, 0x2900, 0xaa05,
+	0xab05, 0x1904, 0x339a, 0x6033, 0x000d, 0x2001, 0x0030, 0x2003,
+	0x0004, 0x7824, 0xd0ac, 0x1148, 0x2001, 0xb419, 0x2003, 0x0003,
+	0x2001, 0x0030, 0x2003, 0x0009, 0x0040, 0x6027, 0x0001, 0x2001,
+	0x0075, 0x2004, 0xa005, 0x0108, 0x6026, 0x2c00, 0x601a, 0x20e1,
+	0x9040, 0x2d00, 0x681a, 0x6833, 0x000d, 0x7824, 0xd0a4, 0x1180,
+	0x6827, 0x0000, 0x00c6, 0x20a9, 0x0004, 0x2061, 0x0020, 0x6003,
+	0x0008, 0x2001, 0x0203, 0x2004, 0x1f04, 0x336f, 0x00ce, 0x0040,
+	0x6827, 0x0001, 0x2001, 0x0074, 0x2004, 0xa005, 0x0108, 0x6826,
+	0x00f6, 0x00c6, 0x2079, 0x0100, 0x2061, 0x0020, 0x7827, 0x0002,
+	0x2001, 0x0072, 0x2004, 0xa084, 0xfff8, 0x601a, 0x0006, 0x2001,
+	0x0073, 0x2004, 0x601e, 0x78c6, 0x000e, 0x78ca, 0x00ce, 0x00fe,
+	0x0804, 0x32b2, 0x2061, 0x0100, 0x6027, 0x0002, 0x001e, 0x61e2,
+	0x001e, 0x6106, 0x7824, 0xa084, 0x0003, 0xa086, 0x0002, 0x0188,
+	0x20e1, 0x9028, 0x6050, 0xa084, 0xf7ef, 0x6052, 0x602f, 0x0000,
+	0x602c, 0xc0ac, 0x602e, 0x604b, 0xf7f7, 0x6043, 0x0090, 0x6043,
+	0x0010, 0x2908, 0x2a10, 0x2b18, 0x2b00, 0xaa05, 0xa905, 0x00fe,
+	0x00ee, 0x00de, 0x00ce, 0x00be, 0x00ae, 0x009e, 0x008e, 0x1118,
+	0x012e, 0x0804, 0x2e72, 0x012e, 0x2021, 0x400c, 0x0804, 0x2e74,
+	0xa085, 0x0001, 0x1d04, 0x33d9, 0x2091, 0x6000, 0x8420, 0xa486,
+	0x0064, 0x0005, 0x2001, 0x0105, 0x2003, 0x0010, 0x2001, 0x0030,
+	0x2003, 0x0004, 0x2001, 0x0020, 0x2003, 0x0004, 0x2001, 0xb419,
+	0x2003, 0x0000, 0x2001, 0xb43a, 0x2003, 0x0000, 0x20e1, 0xf000,
+	0xa026, 0x0005, 0x00f6, 0x2079, 0x0100, 0x2001, 0xb114, 0x200c,
+	0x7932, 0x7936, 0x080c, 0x2720, 0x7850, 0xa084, 0x0980, 0xa085,
+	0x0030, 0x7852, 0x2019, 0x01f4, 0x8319, 0x1df0, 0xa084, 0x0980,
+	0x7852, 0x782c, 0xc0ad, 0x782e, 0x20a9, 0x0046, 0x1d04, 0x340e,
+	0x2091, 0x6000, 0x1f04, 0x340e, 0x7850, 0xa085, 0x0400, 0x7852,
+	0x2001, 0x0009, 0x2004, 0xa084, 0x0003, 0xa086, 0x0001, 0x1118,
+	0x782c, 0xc0ac, 0x782e, 0x784b, 0xf7f7, 0x7843, 0x0090, 0x7843,
+	0x0010, 0x20a9, 0x000e, 0xe000, 0x1f04, 0x342b, 0x7850, 0xa085,
+	0x1400, 0x7852, 0x2019, 0x61a8, 0x7854, 0xe000, 0xe000, 0xd08c,
+	0x1110, 0x8319, 0x1dc8, 0x7827, 0x0048, 0x7850, 0xa085, 0x0400,
+	0x7852, 0x7843, 0x0040, 0x2019, 0x01f4, 0xe000, 0xe000, 0x8319,
+	0x1de0, 0x2001, 0x0140, 0x2003, 0x0100, 0x7827, 0x0020, 0x7843,
+	0x0000, 0x2003, 0x0000, 0x7827, 0x0048, 0x00fe, 0x0005, 0x7824,
+	0xd0ac, 0x11c8, 0x00f6, 0x00e6, 0x2071, 0xb419, 0x2079, 0x0030,
+	0x2001, 0x0201, 0x2004, 0xa005, 0x0160, 0x7000, 0xa086, 0x0000,
+	0x1140, 0x0051, 0xd0bc, 0x0108, 0x8738, 0x7003, 0x0003, 0x7803,
+	0x0019, 0x00ee, 0x00fe, 0x0005, 0x780c, 0xa08c, 0x0070, 0x0178,
+	0x2009, 0x007a, 0x260a, 0x2009, 0x007b, 0x250a, 0xd0b4, 0x0108,
+	0x8a50, 0xd0ac, 0x0108, 0x8948, 0xd0a4, 0x0108, 0x8b58, 0x0005,
+	0x00f6, 0x2079, 0x0200, 0x781c, 0xd084, 0x0140, 0x20e1, 0x0007,
+	0x20e1, 0x2000, 0x2001, 0x020a, 0x2004, 0x0ca8, 0x00fe, 0x0005,
+	0x00e6, 0x2071, 0x0100, 0x2009, 0xb114, 0x210c, 0x716e, 0x7063,
+	0x0100, 0x7166, 0x719e, 0x706b, 0x0000, 0x7073, 0x0809, 0x7077,
+	0x0008, 0x7078, 0xa080, 0x0100, 0x707a, 0x7080, 0x8000, 0x7082,
+	0x7087, 0xaaaa, 0xa006, 0x708a, 0x708e, 0x707e, 0x70d6, 0x70ab,
+	0x0036, 0x70af, 0x95d5, 0x7027, 0x0080, 0x7014, 0xa084, 0x0184,
+	0xa085, 0x0032, 0x7016, 0x080c, 0x3571, 0x080c, 0x33d0, 0x1110,
+	0x8421, 0x0028, 0x7024, 0xd0bc, 0x0db0, 0x7027, 0x0080, 0x00f6,
+	0x00e6, 0x2071, 0xb419, 0x2079, 0x0030, 0x00d6, 0x2069, 0x0000,
+	0x6824, 0xd0b4, 0x0120, 0x683c, 0x783e, 0x6838, 0x783a, 0x00de,
+	0x2011, 0x0011, 0x080c, 0x3549, 0x2011, 0x0001, 0x080c, 0x3549,
+	0x00ee, 0x00fe, 0x7017, 0x0000, 0x00ee, 0x0005, 0x00f6, 0x00e6,
+	0x2071, 0xb419, 0x2079, 0x0030, 0x7904, 0xd1fc, 0x0904, 0x3546,
+	0x7803, 0x0002, 0xa026, 0xd19c, 0x1904, 0x3542, 0x7000, 0x0002,
+	0x3546, 0x3504, 0x3528, 0x3542, 0xd1bc, 0x1150, 0xd1dc, 0x1150,
+	0x8001, 0x7002, 0x2011, 0x0001, 0x04e1, 0x05c0, 0x04d1, 0x04b0,
+	0x780f, 0x0000, 0x7820, 0x7924, 0x7803, 0x0004, 0x7822, 0x7926,
+	0x2001, 0x0201, 0x200c, 0x81ff, 0x0de8, 0x080c, 0x3474, 0x2009,
+	0x0001, 0x7808, 0xd0ec, 0x0110, 0x2009, 0x0011, 0x7902, 0x00f0,
+	0x8001, 0x7002, 0xa184, 0x0880, 0x1138, 0x7804, 0xd0fc, 0x1940,
+	0x2011, 0x0001, 0x00b1, 0x0090, 0x6030, 0xa092, 0x0004, 0xa086,
+	0x0009, 0x1120, 0x6000, 0x601a, 0x2011, 0x0025, 0x6232, 0xd1dc,
+	0x1988, 0x0870, 0x7803, 0x0004, 0x7003, 0x0000, 0x00ee, 0x00fe,
+	0x0005, 0x6024, 0xa005, 0x0520, 0x8001, 0x6026, 0x6018, 0x6130,
+	0xa140, 0x2804, 0x7832, 0x8840, 0x2804, 0x7836, 0x8840, 0x2804,
+	0x7822, 0x8840, 0x2804, 0x7826, 0x8840, 0x7a02, 0x7000, 0x8000,
+	0x7002, 0x6018, 0xa802, 0xa08a, 0x0029, 0x1138, 0x6018, 0xa080,
+	0x0001, 0x2004, 0x601a, 0x2001, 0x000d, 0x6032, 0xa085, 0x0001,
+	0x0005, 0x00f6, 0x00e6, 0x00c6, 0x2071, 0xb43a, 0x2079, 0x0020,
+	0x7904, 0xd1fc, 0x01f0, 0x7803, 0x0002, 0x2d60, 0xa026, 0x7000,
+	0x0002, 0x3599, 0x3584, 0x3590, 0x8001, 0x7002, 0xd19c, 0x1188,
+	0x2011, 0x0001, 0x080c, 0x3549, 0x0160, 0x080c, 0x3549, 0x0048,
+	0x8001, 0x7002, 0x7804, 0xd0fc, 0x1d30, 0x2011, 0x0001, 0x080c,
+	0x3549, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x00f6, 0x00e6, 0x00c6,
+	0x2061, 0x0200, 0x601b, 0x0004, 0x2061, 0x0100, 0x60cf, 0x0400,
+	0x6004, 0xc0ac, 0xa085, 0x0200, 0x6006, 0x2001, 0x0074, 0x2004,
+	0xa005, 0x01f8, 0x2038, 0x2001, 0x0076, 0x2024, 0x2001, 0x0077,
+	0x201c, 0x080c, 0x3d04, 0x6833, 0x000d, 0x6f26, 0x2d00, 0x681a,
+	0xa78a, 0x0007, 0x0220, 0x2138, 0x2009, 0x0007, 0x0010, 0x2708,
+	0xa03e, 0x6818, 0xa080, 0x000d, 0x04a1, 0x1d90, 0x2d00, 0x681a,
+	0x0088, 0x080c, 0x3d04, 0x6833, 0x000d, 0x2070, 0x6827, 0x0001,
+	0x2d00, 0x681a, 0x2001, 0x0076, 0x2004, 0x2072, 0x2001, 0x0077,
+	0x2004, 0x7006, 0x2061, 0x0020, 0x2079, 0x0100, 0x6013, 0x0400,
+	0x20e1, 0x9040, 0x2001, 0x0072, 0x2004, 0xa084, 0xfff8, 0x700a,
+	0x601a, 0x0006, 0x2001, 0x0073, 0x2004, 0x700e, 0x601e, 0x78c6,
+	0x000e, 0x78ca, 0xa006, 0x603a, 0x603e, 0x00ce, 0x00ee, 0x00fe,
+	0x0005, 0x00e6, 0x2071, 0x0010, 0x20a0, 0x2099, 0x0014, 0x7003,
+	0x0026, 0x7432, 0x7336, 0xa006, 0x703a, 0x703e, 0x810b, 0x810b,
+	0x21a8, 0x810b, 0x7122, 0x7003, 0x0041, 0x7004, 0xd0fc, 0x0de8,
+	0x7003, 0x0002, 0x7003, 0x0040, 0x53a5, 0x7430, 0x7334, 0x87ff,
+	0x0180, 0x00c6, 0x00d6, 0x2d60, 0x00c6, 0x080c, 0x3d04, 0x00ce,
+	0x6018, 0x2070, 0x2d00, 0x7006, 0x601a, 0x00de, 0x00ce, 0xa085,
+	0x0001, 0x00ee, 0x0005, 0x00e6, 0x2001, 0x0075, 0x2004, 0xa005,
+	0x0508, 0x2038, 0x2001, 0x0078, 0x2024, 0x2001, 0x0079, 0x201c,
+	0x080c, 0x3d04, 0x2d60, 0x6833, 0x000d, 0x6f26, 0x2d00, 0x681a,
+	0xa78a, 0x0007, 0x0220, 0x2138, 0x2009, 0x0007, 0x0010, 0x2708,
+	0xa03e, 0x6818, 0xa080, 0x000d, 0x080c, 0x3601, 0x1d88, 0x2d00,
+	0x681a, 0x00e0, 0x080c, 0x3d04, 0x2d60, 0x6033, 0x000d, 0x2070,
+	0x6027, 0x0001, 0x2c00, 0x601a, 0x2001, 0x0078, 0x2004, 0x2072,
+	0x2001, 0x0079, 0x2004, 0x7006, 0x2001, 0x0072, 0x2004, 0xa084,
+	0xfff8, 0x700a, 0x2001, 0x0073, 0x2004, 0x700e, 0x2001, 0x0030,
+	0x2003, 0x0004, 0x7824, 0xd0ac, 0x1178, 0x2001, 0x0101, 0x200c,
+	0xc1ed, 0x2102, 0x6027, 0x0000, 0x2001, 0xb419, 0x2003, 0x0003,
+	0x2001, 0x0030, 0x2003, 0x0009, 0x00ee, 0x0005, 0x0804, 0x2e72,
+	0x0126, 0x2091, 0x8000, 0x20a9, 0x0012, 0x2001, 0xb140, 0x20a0,
+	0xa006, 0x40a4, 0x012e, 0x0804, 0x2e72, 0x7d38, 0x7c3c, 0x0804,
+	0x2f19, 0x080c, 0x3d04, 0x0904, 0x2e97, 0x080c, 0x58d5, 0x0110,
+	0x080c, 0x4a65, 0x2009, 0x001c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38,
+	0x080c, 0x3d45, 0x701b, 0x36b5, 0x0005, 0xade8, 0x000d, 0x6800,
+	0xa005, 0x0904, 0x2e9a, 0x6804, 0xd0ac, 0x0118, 0xd0a4, 0x0904,
+	0x2e9a, 0xd094, 0x00c6, 0x2061, 0x0100, 0x6104, 0x0138, 0x6200,
+	0xa292, 0x0005, 0x0218, 0xa18c, 0xffdf, 0x0010, 0xa18d, 0x0020,
+	0x6106, 0x00ce, 0xd08c, 0x00c6, 0x2061, 0x0100, 0x6104, 0x0118,
+	0xa18d, 0x0010, 0x0010, 0xa18c, 0xffef, 0x6106, 0x00ce, 0x2009,
+	0x0100, 0x210c, 0xa18a, 0x0002, 0x0268, 0xd084, 0x0158, 0x6a28,
+	0xa28a, 0x007f, 0x1a04, 0x2e9a, 0xa288, 0x2c8c, 0x210d, 0xa18c,
+	0x00ff, 0x6156, 0xd0dc, 0x0130, 0x6828, 0xa08a, 0x007f, 0x1a04,
+	0x2e9a, 0x604e, 0x6808, 0xa08a, 0x0100, 0x0a04, 0x2e9a, 0xa08a,
+	0x0841, 0x1a04, 0x2e9a, 0xa084, 0x0007, 0x1904, 0x2e9a, 0x680c,
+	0xa005, 0x0904, 0x2e9a, 0x6810, 0xa005, 0x0904, 0x2e9a, 0x6848,
+	0x6940, 0xa10a, 0x1a04, 0x2e9a, 0x8001, 0x0904, 0x2e9a, 0x684c,
+	0x6944, 0xa10a, 0x1a04, 0x2e9a, 0x8001, 0x0904, 0x2e9a, 0x6804,
+	0xd0fc, 0x0560, 0x080c, 0x3d04, 0x0904, 0x2e97, 0x2009, 0x0014,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0xa290, 0x0038, 0xa399, 0x0000,
+	0x080c, 0x3d45, 0x701b, 0x3735, 0x0005, 0xade8, 0x000d, 0x20a9,
+	0x0014, 0x2d98, 0x2069, 0xb16e, 0x2da0, 0x53a3, 0x7010, 0xa0e8,
+	0x000d, 0x2001, 0xb172, 0x200c, 0xd1e4, 0x0140, 0x00c6, 0x2061,
+	0x0100, 0x6004, 0xa085, 0x0b00, 0x6006, 0x00ce, 0x2009, 0xb3b0,
+	0x200b, 0x0000, 0x2001, 0xb174, 0x2004, 0xd0ac, 0x0158, 0x7824,
+	0x200a, 0x2009, 0x017f, 0x200a, 0x3200, 0xa084, 0x003f, 0xa085,
+	0x3020, 0x2090, 0x20a9, 0x001c, 0x2d98, 0x2069, 0xb152, 0x2da0,
+	0x53a3, 0x6814, 0xa08c, 0x00ff, 0x613e, 0x8007, 0xa084, 0x00ff,
+	0x6042, 0x080c, 0x5ba6, 0x080c, 0x51d5, 0x080c, 0x523e, 0x6000,
+	0xa086, 0x0000, 0x1904, 0x382c, 0x6808, 0x602a, 0x080c, 0x2378,
+	0x0006, 0x2001, 0x0100, 0x2004, 0xa082, 0x0005, 0x000e, 0x0268,
+	0x2009, 0x0170, 0x200b, 0x0080, 0xe000, 0xe000, 0x200b, 0x0000,
+	0x0036, 0x6b08, 0x080c, 0x277b, 0x003e, 0x6818, 0x691c, 0x6a20,
+	0x6b24, 0x8007, 0x810f, 0x8217, 0x831f, 0x6016, 0x611a, 0x621e,
+	0x6322, 0x6c04, 0xd4f4, 0x0148, 0x6830, 0x6934, 0x6a38, 0x6b3c,
+	0x8007, 0x810f, 0x8217, 0x831f, 0x0010, 0xa084, 0xf0ff, 0x6006,
+	0x610a, 0x620e, 0x6312, 0x8007, 0x810f, 0x8217, 0x831f, 0x20a9,
+	0x0004, 0x20a1, 0xb3bf, 0x40a1, 0x080c, 0x67ea, 0x6904, 0xd1fc,
+	0x0520, 0x00c6, 0x2009, 0x0000, 0x20a9, 0x0001, 0x6b70, 0xd384,
+	0x01c8, 0x0020, 0x839d, 0x12b0, 0x3508, 0x8109, 0x080c, 0x6135,
+	0x6878, 0x6016, 0x6874, 0x2008, 0xa084, 0xff00, 0x8007, 0x600a,
+	0xa184, 0x00ff, 0x6006, 0x8108, 0x1118, 0x6003, 0x0003, 0x0010,
+	0x6003, 0x0001, 0x1f04, 0x37ca, 0x00ce, 0x2069, 0xb152, 0x2001,
+	0xb39e, 0x6a80, 0xa294, 0x0030, 0xa28e, 0x0000, 0x0170, 0xa28e,
+	0x0010, 0x0118, 0xa28e, 0x0020, 0x0140, 0x2003, 0xaaaa, 0x080c,
+	0x27c4, 0x2001, 0xb38f, 0x2102, 0x0008, 0x2102, 0x00c6, 0x2061,
+	0x0100, 0x602f, 0x0040, 0x602f, 0x0000, 0x00ce, 0x080c, 0x58d5,
+	0x0128, 0x080c, 0x3f5e, 0x0110, 0x080c, 0x2740, 0x60c4, 0xa005,
+	0x01b0, 0x6003, 0x0001, 0x2009, 0x3816, 0x00c0, 0x080c, 0x58d5,
+	0x1158, 0x2011, 0x57ea, 0x080c, 0x6742, 0x2001, 0xb39f, 0x2003,
+	0x0000, 0x080c, 0x5816, 0x0040, 0x080c, 0x4992, 0x0028, 0x6003,
+	0x0004, 0x2009, 0x382c, 0x0010, 0x0804, 0x2e72, 0x2001, 0x0100,
+	0x2004, 0xa082, 0x0005, 0x0258, 0x2001, 0x0170, 0x2004, 0xa084,
+	0x00ff, 0xa086, 0x004c, 0x1118, 0x2091, 0x309d, 0x0817, 0x2091,
+	0x301d, 0x0817, 0x6000, 0xa086, 0x0000, 0x0904, 0x2e97, 0x2069,
+	0xb152, 0x7830, 0x6842, 0x7834, 0x6846, 0x6804, 0xd0fc, 0x0118,
+	0x2009, 0x0030, 0x0010, 0x2009, 0x001c, 0x2d00, 0x7a2c, 0x7b28,
+	0x7c3c, 0x7d38, 0x0804, 0x3d48, 0xa006, 0x080c, 0x2740, 0x81ff,
+	0x1904, 0x2e97, 0x080c, 0x58d5, 0x1178, 0x2001, 0xb39f, 0x2003,
+	0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0xa085, 0x0001, 0x080c,
+	0x5919, 0x080c, 0x5816, 0x0020, 0x080c, 0x4a65, 0x080c, 0x4992,
+	0x0804, 0x2e72, 0x81ff, 0x1904, 0x2e97, 0x080c, 0x58d5, 0x1110,
+	0x0804, 0x2e97, 0x6184, 0x81ff, 0x0198, 0x703f, 0x0000, 0x2001,
+	0xb7c0, 0x2009, 0x0040, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x3d48, 0x701b, 0x2e70, 0x012e, 0x0005,
+	0x703f, 0x0001, 0x00d6, 0x2069, 0xb7c0, 0x20a9, 0x0040, 0x20a1,
+	0xb7c0, 0x2019, 0xffff, 0x43a4, 0x654c, 0xa588, 0x2c8c, 0x210d,
+	0xa18c, 0x00ff, 0x216a, 0xa00e, 0x2011, 0x0002, 0x2100, 0xa506,
+	0x01a8, 0x080c, 0x4e21, 0x1190, 0x6014, 0x821c, 0x0238, 0xa398,
+	0xb7c0, 0xa085, 0xff00, 0x8007, 0x201a, 0x0038, 0xa398, 0xb7c0,
+	0x2324, 0xa4a4, 0xff00, 0xa405, 0x201a, 0x8210, 0x8108, 0xa182,
+	0x0080, 0x1208, 0x0c18, 0x8201, 0x8007, 0x2d0c, 0xa105, 0x206a,
+	0x00de, 0x20a9, 0x0040, 0x20a1, 0xb7c0, 0x2099, 0xb7c0, 0x080c,
+	0x4a04, 0x0804, 0x3887, 0x080c, 0x3d29, 0x0904, 0x2e9a, 0x00c6,
+	0x080c, 0x3d04, 0x00ce, 0x1120, 0x2009, 0x0002, 0x0804, 0x2e97,
+	0x2001, 0xb153, 0x2004, 0xd0b4, 0x0550, 0x7824, 0xa084, 0xff00,
+	0xa08e, 0x7e00, 0x0520, 0xa08e, 0x7f00, 0x0508, 0xa08e, 0x8000,
+	0x01f0, 0x6000, 0xd08c, 0x11d8, 0x6004, 0xa084, 0x00ff, 0xa086,
+	0x0006, 0x11a8, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x080c,
+	0x99e8, 0x1120, 0x2009, 0x0003, 0x0804, 0x2e97, 0x7007, 0x0003,
+	0x701b, 0x3913, 0x0005, 0x080c, 0x3d29, 0x0904, 0x2e9a, 0x20a9,
+	0x002b, 0x2c98, 0xade8, 0x0002, 0x2da0, 0x53a3, 0x20a9, 0x0004,
+	0xac80, 0x0006, 0x2098, 0xad80, 0x0006, 0x20a0, 0x080c, 0x4a04,
+	0x20a9, 0x0004, 0xac80, 0x000a, 0x2098, 0xad80, 0x000a, 0x20a0,
+	0x080c, 0x4a04, 0x2d00, 0x2009, 0x002b, 0x7a2c, 0x7b28, 0x7c3c,
+	0x7d38, 0x0804, 0x3d48, 0x81ff, 0x1904, 0x2e97, 0x080c, 0x3d19,
+	0x0904, 0x2e9a, 0x080c, 0x4ff8, 0x0804, 0x2e72, 0x81ff, 0x1904,
+	0x2e97, 0x7828, 0xa08a, 0x1000, 0x1a04, 0x2e9a, 0x080c, 0x3d29,
+	0x0904, 0x2e9a, 0x080c, 0x505b, 0x0904, 0x2e97, 0x2019, 0x0004,
+	0xa00e, 0x080c, 0x500a, 0x7924, 0x810f, 0x7a28, 0x0011, 0x0804,
+	0x2e72, 0xa186, 0x00ff, 0x0110, 0x0071, 0x0060, 0x2029, 0x007e,
+	0x2061, 0xb100, 0x644c, 0x2400, 0xa506, 0x0110, 0x2508, 0x0019,
+	0x8529, 0x1ec8, 0x0005, 0x080c, 0x4e21, 0x1138, 0x2200, 0x8003,
+	0x800b, 0x810b, 0xa108, 0x080c, 0x674e, 0x0005, 0x81ff, 0x1904,
+	0x2e97, 0x080c, 0x3d19, 0x0904, 0x2e9a, 0x080c, 0x4ee3, 0x0904,
+	0x2e97, 0x080c, 0x5001, 0x0804, 0x2e72, 0x81ff, 0x1904, 0x2e97,
+	0x080c, 0x3d19, 0x0904, 0x2e9a, 0x080c, 0x4ee3, 0x0904, 0x2e97,
+	0x080c, 0x4fef, 0x0804, 0x2e72, 0x6100, 0x0804, 0x2e72, 0x080c,
+	0x3d29, 0x0904, 0x2e9a, 0x2001, 0xb100, 0x2004, 0xa086, 0x0003,
+	0x1904, 0x2e97, 0x00d6, 0xace8, 0x000a, 0x7924, 0xd184, 0x0110,
+	0xace8, 0x0006, 0x680c, 0x8007, 0x783e, 0x6808, 0x8007, 0x783a,
+	0x6b04, 0x831f, 0x6a00, 0x8217, 0x00de, 0x6100, 0xa18c, 0x0200,
+	0x0804, 0x2e72, 0x7824, 0xa09c, 0x00ff, 0xa39a, 0x0003, 0x1a04,
+	0x2e97, 0x624c, 0xa294, 0x00ff, 0xa084, 0xff00, 0x8007, 0xa206,
+	0x1150, 0x2001, 0xb140, 0x2009, 0x000c, 0x7a2c, 0x7b28, 0x7c3c,
+	0x7d38, 0x0804, 0x3d48, 0x81ff, 0x1904, 0x2e97, 0x080c, 0x3d29,
+	0x0904, 0x2e9a, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1904,
+	0x2e97, 0x00c6, 0x080c, 0x3d04, 0x00ce, 0x0904, 0x2e97, 0x6837,
+	0x0000, 0x6838, 0xc0fd, 0x683a, 0x080c, 0x9994, 0x0904, 0x2e97,
+	0x7007, 0x0003, 0x701b, 0x39fd, 0x0005, 0x6830, 0xa086, 0x0100,
+	0x0904, 0x2e97, 0xad80, 0x000e, 0x2009, 0x000c, 0x7a2c, 0x7b28,
+	0x7c3c, 0x7d38, 0x0804, 0x3d48, 0xa006, 0x080c, 0x2740, 0x7824,
+	0xa084, 0x00ff, 0xa086, 0x00ff, 0x0118, 0x81ff, 0x1904, 0x2e97,
+	0x080c, 0x58d5, 0x0110, 0x080c, 0x4a65, 0x7828, 0xa08a, 0x1000,
+	0x1a04, 0x2e9a, 0x7924, 0xa18c, 0xff00, 0x810f, 0xa186, 0x00ff,
+	0x0138, 0xa182, 0x007f, 0x1a04, 0x2e9a, 0x2100, 0x080c, 0x270a,
+	0x0026, 0x00c6, 0x0126, 0x2091, 0x8000, 0x2061, 0xb3ec, 0x601b,
+	0x0000, 0x601f, 0x0000, 0x080c, 0x58d5, 0x1178, 0x2001, 0xb39f,
+	0x2003, 0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0xa085, 0x0001,
+	0x080c, 0x5919, 0x080c, 0x5816, 0x0430, 0x2011, 0x0003, 0x080c,
+	0x7d52, 0x2011, 0x0002, 0x080c, 0x7d5c, 0x080c, 0x7c41, 0x080c,
+	0x67b6, 0x0036, 0x2019, 0x0000, 0x080c, 0x7cc4, 0x003e, 0x2061,
+	0x0100, 0x2001, 0xb114, 0x2004, 0xa084, 0x00ff, 0x810f, 0xa105,
+	0x604a, 0x6043, 0x0090, 0x6043, 0x0010, 0x2009, 0x002d, 0x2011,
+	0x49c9, 0x080c, 0x67c8, 0x7924, 0xa18c, 0xff00, 0x810f, 0x080c,
+	0x58d5, 0x1110, 0x2009, 0x00ff, 0x7a28, 0x080c, 0x3961, 0x012e,
+	0x00ce, 0x002e, 0x0804, 0x2e72, 0x7924, 0xa18c, 0xff00, 0x810f,
+	0x00c6, 0x080c, 0x4dc5, 0x2c08, 0x00ce, 0x1904, 0x2e9a, 0x0804,
+	0x2e72, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x2e97, 0x60d0,
+	0xd0ac, 0x1130, 0xd09c, 0x1120, 0x2009, 0x0005, 0x0804, 0x2e97,
+	0x080c, 0x3d04, 0x1120, 0x2009, 0x0002, 0x0804, 0x2e97, 0x7924,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c, 0x3d45, 0x701b, 0x3ab1,
+	0x0005, 0x2009, 0x0080, 0x080c, 0x4e21, 0x1130, 0x6004, 0xa084,
+	0x00ff, 0xa086, 0x0006, 0x0120, 0x2021, 0x400a, 0x0804, 0x2e74,
+	0x00d6, 0xade8, 0x000d, 0x6900, 0x6a08, 0x6b0c, 0x6c10, 0x6d14,
+	0x6e18, 0x6820, 0xa0be, 0x0100, 0x0904, 0x3b28, 0xa0be, 0x0112,
+	0x0904, 0x3b28, 0xa0be, 0x0113, 0x0904, 0x3b28, 0xa0be, 0x0114,
+	0x0904, 0x3b28, 0xa0be, 0x0117, 0x0904, 0x3b28, 0xa0be, 0x011a,
+	0x0904, 0x3b28, 0xa0be, 0x011c, 0x0904, 0x3b28, 0xa0be, 0x0121,
+	0x05b0, 0xa0be, 0x0131, 0x0598, 0xa0be, 0x0171, 0x05c8, 0xa0be,
+	0x0173, 0x05b0, 0xa0be, 0x01a1, 0x1120, 0x6830, 0x8007, 0x6832,
+	0x04a8, 0xa0be, 0x0212, 0x0540, 0xa0be, 0x0213, 0x0528, 0xa0be,
+	0x0214, 0x01b0, 0xa0be, 0x0217, 0x0168, 0xa0be, 0x021a, 0x1120,
+	0x6838, 0x8007, 0x683a, 0x00e0, 0xa0be, 0x0300, 0x01c8, 0x00de,
+	0x0804, 0x2e9a, 0xad80, 0x0010, 0x20a9, 0x0007, 0x080c, 0x3b6e,
+	0xad80, 0x000e, 0x20a9, 0x0001, 0x080c, 0x3b6e, 0x0048, 0xad80,
+	0x000c, 0x080c, 0x3b7c, 0x0050, 0xad80, 0x000e, 0x080c, 0x3b7c,
+	0xad80, 0x000c, 0x20a9, 0x0001, 0x080c, 0x3b6e, 0x00c6, 0x080c,
+	0x3d04, 0x0568, 0x6838, 0xc0fd, 0x683a, 0x6837, 0x0119, 0x6853,
+	0x0000, 0x684f, 0x0020, 0x685b, 0x0001, 0x810b, 0x697e, 0x6883,
+	0x0000, 0x6a86, 0x6b8a, 0x6c8e, 0x6d92, 0x6996, 0x689b, 0x0000,
+	0x00ce, 0x00de, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x6823,
+	0x0000, 0x6804, 0x2068, 0x080c, 0x99b0, 0x1120, 0x2009, 0x0003,
+	0x0804, 0x2e97, 0x7007, 0x0003, 0x701b, 0x3b65, 0x0005, 0x00ce,
+	0x00de, 0x2009, 0x0002, 0x0804, 0x2e97, 0x6820, 0xa086, 0x8001,
+	0x1904, 0x2e72, 0x2009, 0x0004, 0x0804, 0x2e97, 0x0016, 0x2008,
+	0x2044, 0x8000, 0x204c, 0x8000, 0x290a, 0x8108, 0x280a, 0x8108,
+	0x1f04, 0x3b70, 0x001e, 0x0005, 0x0016, 0x00a6, 0x00b6, 0x2008,
+	0x2044, 0x8000, 0x204c, 0x8000, 0x2054, 0x8000, 0x205c, 0x2b0a,
+	0x8108, 0x2a0a, 0x8108, 0x290a, 0x8108, 0x280a, 0x00be, 0x00ae,
+	0x001e, 0x0005, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x2e97,
+	0x7924, 0x2140, 0xa18c, 0xff00, 0x810f, 0x60d0, 0xd0ac, 0x1120,
+	0xa182, 0x0080, 0x0a04, 0x2e9a, 0xa182, 0x00ff, 0x1a04, 0x2e9a,
+	0x7a2c, 0x7b28, 0x606c, 0xa306, 0x1140, 0x6070, 0xa24e, 0x0904,
+	0x2e9a, 0xa9cc, 0xff00, 0x0904, 0x2e9a, 0x00c6, 0x080c, 0x3c52,
+	0x2c68, 0x00ce, 0x0538, 0xa0c6, 0x4000, 0x1180, 0x00c6, 0x0006,
+	0x2d60, 0x2009, 0x0000, 0x080c, 0x50bc, 0x1108, 0xc185, 0x6000,
+	0xd0bc, 0x0108, 0xc18d, 0x000e, 0x00ce, 0x0088, 0xa0c6, 0x4007,
+	0x1110, 0x2408, 0x0060, 0xa0c6, 0x4008, 0x1118, 0x2708, 0x2610,
+	0x0030, 0xa0c6, 0x4009, 0x1108, 0x0010, 0x2001, 0x4006, 0x2020,
+	0x0804, 0x2e74, 0x2d00, 0x7022, 0x0016, 0x00b6, 0x00c6, 0x00e6,
+	0x2c70, 0x080c, 0x8295, 0x05d8, 0x2d00, 0x601a, 0x080c, 0x9c35,
+	0x2e58, 0x00ee, 0x00e6, 0x00c6, 0x080c, 0x3d04, 0x00ce, 0x2b70,
+	0x1150, 0x080c, 0x82eb, 0x00ee, 0x00ce, 0x00be, 0x001e, 0x2009,
+	0x0002, 0x0804, 0x2e97, 0x6837, 0x0000, 0x683b, 0x0000, 0x2d00,
+	0x6012, 0x6833, 0x0000, 0x6838, 0xc0fd, 0xd88c, 0x0108, 0xc0f5,
+	0x683a, 0x0126, 0x2091, 0x8000, 0x080c, 0x2b73, 0x012e, 0x601f,
+	0x0001, 0x2001, 0x0000, 0x080c, 0x4d63, 0x2001, 0x0002, 0x080c,
+	0x4d75, 0x2009, 0x0002, 0x080c, 0x831a, 0xa085, 0x0001, 0x00ee,
+	0x00ce, 0x00be, 0x001e, 0x1120, 0x2009, 0x0003, 0x0804, 0x2e97,
+	0x7007, 0x0003, 0x701b, 0x3c35, 0x0005, 0x6830, 0xa086, 0x0100,
+	0x7020, 0x2060, 0x1138, 0x2009, 0x0004, 0x6204, 0xa294, 0x00ff,
+	0x0804, 0x2e97, 0x2009, 0x0000, 0x6838, 0xd0f4, 0x1904, 0x2e72,
+	0x080c, 0x50bc, 0x1108, 0xc185, 0x6000, 0xd0bc, 0x0108, 0xc18d,
+	0x0804, 0x2e72, 0x00e6, 0x00d6, 0x2029, 0x0000, 0x2001, 0xb134,
+	0x2004, 0xd0ac, 0x0138, 0x2021, 0x0000, 0x20a9, 0x00ff, 0x2071,
+	0xb235, 0x0030, 0x2021, 0x0080, 0x20a9, 0x007f, 0x2071, 0xb2b5,
+	0x2e04, 0xa005, 0x1130, 0x2100, 0xa406, 0x1570, 0x2428, 0xc5fd,
+	0x0458, 0x2068, 0x6f10, 0x2700, 0xa306, 0x11b0, 0x6e14, 0x2600,
+	0xa206, 0x1190, 0x2400, 0xa106, 0x1160, 0x2d60, 0xd884, 0x0568,
+	0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1538, 0x2001, 0x4000,
+	0x0428, 0x2001, 0x4007, 0x0410, 0x2400, 0xa106, 0x1168, 0x6e14,
+	0x87ff, 0x1138, 0x86ff, 0x09d0, 0x2001, 0xb134, 0x2004, 0xd0ac,
+	0x19a8, 0x2001, 0x4008, 0x0090, 0x8420, 0x8e70, 0x1f04, 0x3c68,
+	0x85ff, 0x1130, 0x2001, 0x4009, 0x0048, 0x2001, 0x0001, 0x0030,
+	0x080c, 0x4dc5, 0x1dd0, 0x6312, 0x6216, 0xa006, 0xa005, 0x00de,
+	0x00ee, 0x0005, 0x81ff, 0x1904, 0x2e97, 0x080c, 0x3d04, 0x0904,
+	0x2e97, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x7824, 0xa005,
+	0x0904, 0x2e9a, 0xa096, 0x00ff, 0x0120, 0xa092, 0x0004, 0x1a04,
+	0x2e9a, 0x2010, 0x2d18, 0x080c, 0x2b26, 0x0904, 0x2e97, 0x7007,
+	0x0003, 0x701b, 0x3cd4, 0x0005, 0x6830, 0xa086, 0x0100, 0x0904,
+	0x2e97, 0x0804, 0x2e72, 0x7924, 0xa18c, 0xff00, 0x810f, 0x60d0,
+	0xd0ac, 0x1120, 0xa182, 0x0080, 0x0a04, 0x2e9a, 0xa182, 0x00ff,
+	0x1a04, 0x2e9a, 0x0126, 0x2091, 0x8000, 0x080c, 0x989a, 0x1188,
+	0xa190, 0xb235, 0x2204, 0xa065, 0x0160, 0x080c, 0x4a80, 0x2001,
+	0xb134, 0x2004, 0xd0ac, 0x0110, 0x6017, 0x0000, 0x012e, 0x0804,
+	0x2e72, 0x012e, 0x0804, 0x2e97, 0x080c, 0x15dd, 0x0188, 0xa006,
+	0x6802, 0x7010, 0xa005, 0x1120, 0x2d00, 0x7012, 0x7016, 0x0030,
+	0x7014, 0x6802, 0x2060, 0x2d00, 0x6006, 0x7016, 0xad80, 0x000d,
+	0x0005, 0x7924, 0x810f, 0xa18c, 0x00ff, 0x080c, 0x4e21, 0x1130,
+	0x7e28, 0xa684, 0x3fff, 0xa082, 0x4000, 0x0208, 0xa066, 0x8cff,
+	0x0005, 0x7e24, 0x860f, 0xa18c, 0x00ff, 0x080c, 0x4e21, 0x1128,
+	0xa6b4, 0x00ff, 0xa682, 0x4000, 0x0208, 0xa066, 0x8cff, 0x0005,
+	0x0016, 0x7110, 0x81ff, 0x0128, 0x2168, 0x6904, 0x080c, 0x15f4,
+	0x0cc8, 0x7112, 0x7116, 0x001e, 0x0005, 0x2031, 0x0001, 0x0010,
+	0x2031, 0x0000, 0x2061, 0xb1d2, 0x6606, 0x6112, 0x600e, 0x6226,
+	0x632a, 0x642e, 0x6532, 0x2c10, 0x080c, 0x1628, 0x7007, 0x0002,
+	0x701b, 0x2e72, 0x0005, 0x00f6, 0x0126, 0x2091, 0x8000, 0x2079,
+	0x0000, 0x2001, 0xb190, 0x2004, 0xa005, 0x1168, 0x0e04, 0x3d73,
+	0x7818, 0xd084, 0x1140, 0x7a22, 0x7b26, 0x7c2a, 0x781b, 0x0001,
+	0x2091, 0x4080, 0x0408, 0x0016, 0x00c6, 0x00e6, 0x2071, 0xb182,
+	0x7138, 0xa182, 0x0010, 0x0218, 0x7030, 0x2060, 0x0078, 0x7030,
+	0xa0e0, 0x0004, 0xac82, 0xb1d2, 0x0210, 0x2061, 0xb192, 0x2c00,
+	0x7032, 0x81ff, 0x1108, 0x7036, 0x8108, 0x713a, 0x2262, 0x6306,
+	0x640a, 0x00ee, 0x00ce, 0x001e, 0x012e, 0x00fe, 0x0005, 0x00e6,
+	0x2071, 0xb182, 0x7038, 0xa005, 0x0570, 0x0126, 0x2091, 0x8000,
+	0x0e04, 0x3dca, 0x00f6, 0x2079, 0x0000, 0x7818, 0xd084, 0x1508,
+	0x00c6, 0x7034, 0x2060, 0x2c04, 0x7822, 0x6004, 0x7826, 0x6008,
+	0x782a, 0x781b, 0x0001, 0x2091, 0x4080, 0x7038, 0x8001, 0x703a,
+	0xa005, 0x1130, 0x7033, 0xb192, 0x7037, 0xb192, 0x00ce, 0x0048,
+	0xac80, 0x0004, 0xa0fa, 0xb1d2, 0x0210, 0x2001, 0xb192, 0x7036,
+	0x00ce, 0x00fe, 0x012e, 0x00ee, 0x0005, 0x0026, 0x2001, 0xb153,
+	0x2004, 0xd0c4, 0x0120, 0x2011, 0x8014, 0x080c, 0x3d5b, 0x002e,
+	0x0005, 0x81ff, 0x1904, 0x2e97, 0x0126, 0x2091, 0x8000, 0x6030,
+	0xc08d, 0xc085, 0xc0ac, 0x6032, 0x080c, 0x58d5, 0x1178, 0x2001,
+	0xb39f, 0x2003, 0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0xa085,
+	0x0001, 0x080c, 0x5919, 0x080c, 0x5816, 0x0010, 0x080c, 0x4992,
+	0x012e, 0x0804, 0x2e72, 0x7824, 0x2008, 0xa18c, 0xfffd, 0x1128,
+	0x61dc, 0xa10d, 0x61de, 0x0804, 0x2e72, 0x0804, 0x2e9a, 0x81ff,
+	0x1904, 0x2e97, 0x6000, 0xa086, 0x0003, 0x1904, 0x2e97, 0x2001,
+	0xb153, 0x2004, 0xd0ac, 0x1904, 0x2e97, 0x080c, 0x3d29, 0x0904,
+	0x2e9a, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1120, 0x7828,
+	0xa005, 0x0904, 0x2e72, 0x00c6, 0x080c, 0x3d04, 0x00ce, 0x0904,
+	0x2e97, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a,
+	0x080c, 0x9a79, 0x0904, 0x2e97, 0x7007, 0x0003, 0x701b, 0x3e39,
+	0x0005, 0x6830, 0xa086, 0x0100, 0x0904, 0x2e97, 0x0804, 0x2e72,
+	0x2001, 0xb100, 0x2004, 0xa086, 0x0003, 0x1904, 0x2e97, 0x7f24,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c, 0x3d04, 0x0904, 0x2e97,
+	0x2009, 0x0000, 0x2031, 0x0000, 0x7023, 0x0000, 0x702f, 0x0000,
+	0xad80, 0x0005, 0x7026, 0x20a0, 0x080c, 0x4e21, 0x1904, 0x3eb3,
+	0x6004, 0xa0c4, 0x00ff, 0xa8c6, 0x0006, 0x0130, 0xa0c4, 0xff00,
+	0xa8c6, 0x0600, 0x1904, 0x3eb3, 0x2001, 0xb153, 0x2004, 0xd0ac,
+	0x1128, 0x080c, 0x50bc, 0x1110, 0xd79c, 0x05e8, 0xd794, 0x1110,
+	0xd784, 0x0158, 0xac80, 0x0006, 0x2098, 0x3400, 0x20a9, 0x0004,
+	0x53a3, 0x080c, 0x3b7c, 0xd794, 0x0148, 0xac80, 0x000a, 0x2098,
+	0x3400, 0x20a9, 0x0004, 0x53a3, 0x080c, 0x3b7c, 0x21a2, 0xd794,
+	0x01d8, 0xac80, 0x0000, 0x2098, 0x94a0, 0x20a9, 0x0002, 0x53a3,
+	0xac80, 0x0003, 0x20a6, 0x94a0, 0xac80, 0x0004, 0x2098, 0x3400,
+	0x20a9, 0x0002, 0x53a3, 0x080c, 0x3b6e, 0xac80, 0x0026, 0x2098,
+	0x20a9, 0x0002, 0x53a3, 0x0008, 0x94a0, 0xd794, 0x0110, 0xa6b0,
+	0x000b, 0xa6b0, 0x0005, 0x8108, 0x2001, 0xb134, 0x2004, 0xd0ac,
+	0x0118, 0xa186, 0x0100, 0x0040, 0xd78c, 0x0120, 0xa186, 0x0100,
+	0x0170, 0x0018, 0xa186, 0x007e, 0x0150, 0xd794, 0x0118, 0xa686,
+	0x0020, 0x0010, 0xa686, 0x0028, 0x0150, 0x0804, 0x3e5c, 0x86ff,
+	0x1120, 0x7120, 0x810b, 0x0804, 0x2e72, 0x702f, 0x0001, 0x711e,
+	0x7020, 0xa600, 0x7022, 0x772a, 0x2061, 0xb1d2, 0x6007, 0x0000,
+	0x6612, 0x7024, 0x600e, 0x6226, 0x632a, 0x642e, 0x6532, 0x2c10,
+	0x080c, 0x1628, 0x7007, 0x0002, 0x701b, 0x3eef, 0x0005, 0x702c,
+	0xa005, 0x1170, 0x711c, 0x7024, 0x20a0, 0x7728, 0x2031, 0x0000,
+	0x2061, 0xb1d2, 0x6224, 0x6328, 0x642c, 0x6530, 0x0804, 0x3e5c,
+	0x7120, 0x810b, 0x0804, 0x2e72, 0x2029, 0x007e, 0x7924, 0x7a28,
+	0x7b2c, 0x7c38, 0xa184, 0xff00, 0x8007, 0xa0e2, 0x0020, 0x0a04,
+	0x2e9a, 0xa502, 0x0a04, 0x2e9a, 0xa184, 0x00ff, 0xa0e2, 0x0020,
+	0x0a04, 0x2e9a, 0xa502, 0x0a04, 0x2e9a, 0xa284, 0xff00, 0x8007,
+	0xa0e2, 0x0020, 0x0a04, 0x2e9a, 0xa502, 0x0a04, 0x2e9a, 0xa284,
+	0x00ff, 0xa0e2, 0x0020, 0x0a04, 0x2e9a, 0xa502, 0x0a04, 0x2e9a,
+	0xa384, 0xff00, 0x8007, 0xa0e2, 0x0020, 0x0a04, 0x2e9a, 0xa502,
+	0x0a04, 0x2e9a, 0xa384, 0x00ff, 0xa0e2, 0x0020, 0x0a04, 0x2e9a,
+	0xa502, 0x0a04, 0x2e9a, 0xa484, 0xff00, 0x8007, 0xa0e2, 0x0020,
+	0x0a04, 0x2e9a, 0xa502, 0x0a04, 0x2e9a, 0xa484, 0x00ff, 0xa0e2,
+	0x0020, 0x0a04, 0x2e9a, 0xa502, 0x0a04, 0x2e9a, 0x2061, 0xb3b8,
+	0x6102, 0x6206, 0x630a, 0x640e, 0x0804, 0x2e72, 0x0006, 0x2001,
+	0xb153, 0x2004, 0xd0cc, 0x000e, 0x0005, 0x0006, 0x2001, 0xb172,
+	0x2004, 0xd0bc, 0x000e, 0x0005, 0x6164, 0x7a24, 0x6300, 0x82ff,
+	0x1118, 0x7926, 0x0804, 0x2e72, 0x83ff, 0x1904, 0x2e9a, 0x2001,
+	0xfff0, 0xa200, 0x1a04, 0x2e9a, 0x2019, 0xffff, 0x6068, 0xa302,
+	0xa200, 0x0a04, 0x2e9a, 0x7926, 0x6266, 0x0804, 0x2e72, 0x2001,
+	0xb100, 0x2004, 0xa086, 0x0003, 0x1904, 0x2e97, 0x7c28, 0x7d24,
+	0x7e38, 0x7f2c, 0x080c, 0x3d04, 0x0904, 0x2e97, 0x2009, 0x0000,
+	0x2019, 0x0000, 0x7023, 0x0000, 0x702f, 0x0000, 0xad80, 0x0003,
+	0x7026, 0x20a0, 0xa1e0, 0xb235, 0x2c64, 0x8cff, 0x01b8, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x0130, 0x6004, 0xa084, 0xff00,
+	0xa086, 0x0600, 0x1158, 0x6014, 0x20a2, 0x94a0, 0x6010, 0x8007,
+	0xa105, 0x8007, 0x20a2, 0x94a0, 0xa398, 0x0002, 0x8108, 0xa182,
+	0x00ff, 0x0120, 0xa386, 0x002a, 0x0148, 0x08e0, 0x83ff, 0x1120,
+	0x7120, 0x810c, 0x0804, 0x2e72, 0x702f, 0x0001, 0x711e, 0x7020,
+	0xa300, 0x7022, 0x2061, 0xb1d2, 0x6007, 0x0000, 0x6312, 0x7024,
+	0x600e, 0x6426, 0x652a, 0x662e, 0x6732, 0x2c10, 0x080c, 0x1628,
+	0x7007, 0x0002, 0x701b, 0x3fe5, 0x0005, 0x702c, 0xa005, 0x1168,
+	0x711c, 0x7024, 0x20a0, 0x2019, 0x0000, 0x2061, 0xb1d2, 0x6424,
+	0x6528, 0x662c, 0x6730, 0x0804, 0x3fa2, 0x7120, 0x810c, 0x0804,
+	0x2e72, 0x81ff, 0x1904, 0x2e97, 0x60d0, 0xd0ac, 0x1118, 0xd09c,
+	0x0904, 0x2e97, 0x080c, 0x3d04, 0x0904, 0x2e97, 0x7924, 0x7a2c,
+	0x7b28, 0x7c3c, 0x7d38, 0x080c, 0x3d45, 0x701b, 0x4010, 0x0005,
+	0x00d6, 0xade8, 0x000d, 0x6828, 0xa0be, 0x7000, 0x0148, 0xa0be,
+	0x7100, 0x0130, 0xa0be, 0x7200, 0x0118, 0x00de, 0x0804, 0x2e9a,
+	0x6820, 0x6924, 0x080c, 0x26f6, 0x1510, 0x080c, 0x4dc5, 0x11f8,
+	0x7122, 0x6612, 0x6516, 0x6e18, 0x00c6, 0x080c, 0x3d04, 0x01b8,
+	0x080c, 0x3d04, 0x01a0, 0x00ce, 0x00de, 0x6837, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x6823, 0x0000, 0x6804, 0x2068, 0x080c, 0x99cc,
+	0x0904, 0x2e97, 0x7007, 0x0003, 0x701b, 0x404a, 0x0005, 0x00de,
+	0x0804, 0x2e97, 0x7120, 0x080c, 0x2c6e, 0x6820, 0xa086, 0x8001,
+	0x0904, 0x2e97, 0x2d00, 0x701e, 0x6804, 0xa080, 0x0002, 0x0006,
+	0x20a9, 0x002a, 0x2098, 0x20a0, 0x080c, 0x4a04, 0x000e, 0xade8,
+	0x000d, 0x6a08, 0x6b0c, 0x6c10, 0x6d14, 0x2061, 0xb1d2, 0x6007,
+	0x0000, 0x6e00, 0x6f28, 0xa7c6, 0x7000, 0x1108, 0x0018, 0xa7c6,
+	0x7100, 0x1140, 0xa6c2, 0x0004, 0x0a04, 0x2e9a, 0x2009, 0x0004,
+	0x0804, 0x3d48, 0xa7c6, 0x7200, 0x1904, 0x2e9a, 0xa6c2, 0x0054,
+	0x0a04, 0x2e9a, 0x600e, 0x6013, 0x002a, 0x6226, 0x632a, 0x642e,
+	0x6532, 0x2c10, 0x080c, 0x1628, 0x7007, 0x0002, 0x701b, 0x4091,
+	0x0005, 0x701c, 0x2068, 0x6804, 0xa080, 0x0001, 0x2004, 0xa080,
+	0x0002, 0x0006, 0x20a9, 0x002a, 0x2098, 0x20a0, 0x080c, 0x4a04,
+	0x000e, 0x2009, 0x002a, 0x2061, 0xb1d2, 0x6224, 0x6328, 0x642c,
+	0x6530, 0x0804, 0x3d48, 0x81ff, 0x1904, 0x2e97, 0x080c, 0x3d19,
+	0x0904, 0x2e9a, 0x080c, 0x4ee3, 0x0904, 0x2e97, 0x080c, 0x5013,
+	0x0804, 0x2e72, 0x7824, 0xd084, 0x0904, 0x38db, 0x080c, 0x3d29,
+	0x0904, 0x2e9a, 0x00c6, 0x080c, 0x3d04, 0x00ce, 0x1120, 0x2009,
+	0x0002, 0x0804, 0x2e97, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006,
+	0x0128, 0xa08e, 0x0004, 0x0110, 0xa08e, 0x0005, 0x1580, 0x2001,
+	0xb153, 0x2004, 0xd0b4, 0x0904, 0x3917, 0x7824, 0xa084, 0xff00,
+	0xa08e, 0x7e00, 0x0904, 0x3917, 0xa08e, 0x7f00, 0x0904, 0x3917,
+	0xa08e, 0x8000, 0x0904, 0x3917, 0x6000, 0xd08c, 0x1904, 0x3917,
+	0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x080c, 0x99e8, 0x1120,
+	0x2009, 0x0003, 0x0804, 0x2e97, 0x7007, 0x0003, 0x701b, 0x4101,
+	0x0005, 0x080c, 0x3d29, 0x0904, 0x2e9a, 0x0804, 0x3917, 0x2009,
+	0xb130, 0x210c, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x2e97,
+	0x2001, 0xb100, 0x2004, 0xa086, 0x0003, 0x0120, 0x2009, 0x0007,
+	0x0804, 0x2e97, 0x2001, 0xb153, 0x2004, 0xd0ac, 0x0120, 0x2009,
+	0x0008, 0x0804, 0x2e97, 0x609c, 0xd0a4, 0x1118, 0xd0ac, 0x1904,
+	0x3917, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a,
+	0x080c, 0x9a79, 0x1120, 0x2009, 0x0003, 0x0804, 0x2e97, 0x7007,
+	0x0003, 0x701b, 0x413c, 0x0005, 0x6830, 0xa086, 0x0100, 0x1120,
+	0x2009, 0x0004, 0x0804, 0x2e97, 0x080c, 0x3d29, 0x0904, 0x2e9a,
+	0x0804, 0x40d7, 0x81ff, 0x2009, 0x0001, 0x1904, 0x2e97, 0x6000,
+	0xa086, 0x0003, 0x2009, 0x0007, 0x1904, 0x2e97, 0x2001, 0xb153,
+	0x2004, 0xd0ac, 0x2009, 0x0008, 0x1904, 0x2e97, 0x080c, 0x3d29,
+	0x0904, 0x2e9a, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x2009,
+	0x0009, 0x1904, 0x2e97, 0x00c6, 0x080c, 0x3d04, 0x00ce, 0x2009,
+	0x0002, 0x0904, 0x2e97, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x7928, 0xa194, 0xff00, 0xa18c, 0x00ff, 0xa006,
+	0x82ff, 0x1128, 0xc0ed, 0x6952, 0x792c, 0x6956, 0x0048, 0xa28e,
+	0x0100, 0x1904, 0x2e9a, 0xc0e5, 0x6853, 0x0000, 0x6857, 0x0000,
+	0x683e, 0x080c, 0x9c36, 0x2009, 0x0003, 0x0904, 0x2e97, 0x7007,
+	0x0003, 0x701b, 0x419c, 0x0005, 0x6830, 0xa086, 0x0100, 0x2009,
+	0x0004, 0x0904, 0x2e97, 0x0804, 0x2e72, 0x81ff, 0x2009, 0x0001,
+	0x1904, 0x2e97, 0x6000, 0xa086, 0x0003, 0x2009, 0x0007, 0x1904,
+	0x2e97, 0x080c, 0x3d29, 0x0904, 0x2e9a, 0x6004, 0xa084, 0x00ff,
+	0xa086, 0x0006, 0x2009, 0x0009, 0x1904, 0x2e97, 0x00c6, 0x080c,
+	0x3d04, 0x00ce, 0x2009, 0x0002, 0x0904, 0x2e97, 0xad80, 0x000f,
+	0x2009, 0x0008, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c, 0x3d45,
+	0x701b, 0x41d3, 0x0005, 0x00d6, 0xade8, 0x000f, 0x6800, 0xa086,
+	0x0500, 0x1140, 0x6804, 0xa005, 0x1128, 0x6808, 0xa084, 0xff00,
+	0x1108, 0x0018, 0x00de, 0x1904, 0x2e9a, 0x00de, 0x6837, 0x0000,
+	0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x00c6, 0x080c, 0x3d29,
+	0x1118, 0x00ce, 0x0804, 0x2e9a, 0x080c, 0x9c85, 0x2009, 0x0003,
+	0x00ce, 0x0904, 0x2e97, 0x7007, 0x0003, 0x701b, 0x4200, 0x0005,
+	0x6830, 0xa086, 0x0100, 0x2009, 0x0004, 0x0904, 0x2e97, 0x0804,
+	0x2e72, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x2e97, 0x6000,
+	0xa086, 0x0003, 0x0120, 0x2009, 0x0007, 0x0804, 0x2e97, 0x7e24,
+	0x860f, 0xa18c, 0x00ff, 0xa6b4, 0x00ff, 0x080c, 0x4e21, 0x1904,
+	0x2e9a, 0xa186, 0x007f, 0x0150, 0x6004, 0xa084, 0x00ff, 0xa086,
+	0x0006, 0x0120, 0x2009, 0x0009, 0x0804, 0x2e97, 0x00c6, 0x080c,
+	0x3d04, 0x00ce, 0x1120, 0x2009, 0x0002, 0x0804, 0x2e97, 0x6837,
+	0x0000, 0x6838, 0xc0fd, 0x683a, 0x080c, 0x9a03, 0x1120, 0x2009,
+	0x0003, 0x0804, 0x2e97, 0x7007, 0x0003, 0x701b, 0x4248, 0x0005,
+	0x6808, 0x8007, 0xa086, 0x0100, 0x1120, 0x2009, 0x0004, 0x0804,
+	0x2e97, 0x68b0, 0x6836, 0x6810, 0x8007, 0xa084, 0x00ff, 0x808e,
+	0x6814, 0x8007, 0xa084, 0x00ff, 0x8086, 0xa080, 0x0002, 0xa108,
+	0xad80, 0x0004, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0804, 0x3d48,
+	0x080c, 0x3d04, 0x1120, 0x2009, 0x0002, 0x0804, 0x2e97, 0x7924,
+	0xa194, 0xff00, 0xa18c, 0x00ff, 0x8217, 0x82ff, 0x0110, 0x0804,
+	0x2e9a, 0x2009, 0x001a, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c,
+	0x3d45, 0x701b, 0x4284, 0x0005, 0xad80, 0x000d, 0x2098, 0x20a9,
+	0x001a, 0x20a1, 0xb3bf, 0x53a3, 0x0804, 0x2e72, 0x080c, 0x3d04,
+	0x1120, 0x2009, 0x0002, 0x0804, 0x2e97, 0x7924, 0xa194, 0xff00,
+	0xa18c, 0x00ff, 0x8217, 0x82ff, 0x0110, 0x0804, 0x2e9a, 0x2099,
+	0xb3bf, 0x20a0, 0x20a9, 0x001a, 0x53a3, 0x2009, 0x001a, 0x7a2c,
+	0x7b28, 0x7c3c, 0x7d38, 0x0804, 0x3d48, 0x7824, 0xa08a, 0x1000,
+	0x1a04, 0x2e9a, 0x0126, 0x2091, 0x8000, 0x8003, 0x800b, 0x810b,
+	0xa108, 0x00c6, 0x2061, 0xb3ec, 0x6142, 0x00ce, 0x012e, 0x0804,
+	0x2e72, 0x00c6, 0x080c, 0x58d5, 0x1188, 0x2001, 0xb39f, 0x2003,
+	0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0xa085, 0x0001, 0x080c,
+	0x5919, 0x080c, 0x5816, 0x080c, 0x14fa, 0x0038, 0x2061, 0xb100,
+	0x6030, 0xc09d, 0x6032, 0x080c, 0x4992, 0x00ce, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x00c6, 0x2061, 0xb3ec, 0x7924, 0x6152, 0x614e,
+	0x6057, 0x0000, 0x604b, 0x0009, 0x7838, 0x606a, 0x783c, 0x6066,
+	0x7828, 0x6062, 0x782c, 0x605e, 0x2061, 0xb3a0, 0x2001, 0xb401,
+	0x600e, 0x6013, 0x0001, 0x6017, 0x0002, 0x6007, 0x0000, 0x6037,
+	0x0000, 0x00ce, 0x012e, 0x0804, 0x2e72, 0x0126, 0x00c6, 0x00e6,
+	0x2061, 0x0100, 0x2071, 0xb100, 0x6044, 0xd0a4, 0x11b0, 0xd084,
+	0x0118, 0x080c, 0x447c, 0x0068, 0xd08c, 0x0118, 0x080c, 0x439d,
+	0x0040, 0xd094, 0x0118, 0x080c, 0x436e, 0x0018, 0xd09c, 0x0108,
+	0x0061, 0x00ee, 0x00ce, 0x012e, 0x0005, 0x0016, 0x6128, 0xd19c,
+	0x1110, 0xc19d, 0x612a, 0x001e, 0x0ca0, 0x624c, 0xa286, 0xf0f0,
+	0x1150, 0x6048, 0xa086, 0xf0f0, 0x0130, 0x624a, 0x6043, 0x0090,
+	0x6043, 0x0010, 0x0490, 0xa294, 0xff00, 0xa296, 0xf700, 0x0178,
+	0x7134, 0xd1a4, 0x1160, 0x6240, 0xa295, 0x0100, 0x6242, 0xa294,
+	0x0010, 0x0128, 0x2009, 0x00f7, 0x080c, 0x4a24, 0x00f0, 0x6040,
+	0xa084, 0x0010, 0xa085, 0x0140, 0x6042, 0x6043, 0x0000, 0x7077,
+	0x0000, 0x7093, 0x0001, 0x70b7, 0x0000, 0x70d3, 0x0000, 0x2009,
+	0xb7c0, 0x200b, 0x0000, 0x7087, 0x0000, 0x707b, 0x000a, 0x2009,
+	0x000a, 0x2011, 0x4948, 0x080c, 0x67c8, 0x0005, 0x0156, 0x2001,
+	0xb174, 0x2004, 0xd08c, 0x0110, 0x704f, 0xffff, 0x7078, 0xa005,
+	0x1510, 0x2011, 0x4948, 0x080c, 0x6742, 0x6040, 0xa094, 0x0010,
+	0xa285, 0x0020, 0x6042, 0x20a9, 0x00c8, 0x6044, 0xd08c, 0x1168,
+	0x1f04, 0x4385, 0x6242, 0x708b, 0x0000, 0x6040, 0xa094, 0x0010,
+	0xa285, 0x0080, 0x6042, 0x6242, 0x0030, 0x6242, 0x708b, 0x0000,
+	0x707f, 0x0000, 0x0000, 0x015e, 0x0005, 0x707c, 0xa08a, 0x0003,
+	0x1210, 0x0023, 0x0010, 0x080c, 0x14fa, 0x0005, 0x43a9, 0x43f9,
+	0x447b, 0x00f6, 0x707f, 0x0001, 0x20e1, 0xa000, 0xe000, 0x20e1,
+	0x8700, 0x080c, 0x2378, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2079,
+	0xb600, 0x207b, 0x2200, 0x7807, 0x00ef, 0x780b, 0x0000, 0x780f,
+	0x00ef, 0x7813, 0x0138, 0x7817, 0x0000, 0x781b, 0x0000, 0x781f,
+	0x0000, 0x7823, 0xffff, 0x7827, 0xffff, 0x782b, 0x0000, 0x782f,
+	0x0000, 0x2079, 0xb60c, 0x207b, 0x1101, 0x7807, 0x0000, 0x2099,
+	0xb105, 0x20a1, 0xb60e, 0x20a9, 0x0004, 0x53a3, 0x2079, 0xb612,
+	0x207b, 0x0000, 0x7807, 0x0000, 0x2099, 0xb600, 0x20a1, 0x020b,
+	0x20a9, 0x0014, 0x53a6, 0x60c3, 0x000c, 0x600f, 0x0000, 0x080c,
+	0x4979, 0x00fe, 0x7083, 0x0000, 0x6043, 0x0008, 0x6043, 0x0000,
+	0x0005, 0x00d6, 0x7080, 0x7083, 0x0000, 0xa025, 0x0904, 0x4463,
+	0x6020, 0xd0b4, 0x1904, 0x4461, 0x7190, 0x81ff, 0x0904, 0x4451,
+	0xa486, 0x000c, 0x1904, 0x445c, 0xa480, 0x0018, 0x8004, 0x20a8,
+	0x2011, 0xb680, 0x2019, 0xb600, 0x220c, 0x2304, 0xa106, 0x11b8,
+	0x8210, 0x8318, 0x1f04, 0x4414, 0x6043, 0x0004, 0x608b, 0xbc94,
+	0x608f, 0xf0f0, 0x6043, 0x0006, 0x707f, 0x0002, 0x708b, 0x0002,
+	0x2009, 0x07d0, 0x2011, 0x494f, 0x080c, 0x67c8, 0x0490, 0x2069,
+	0xb680, 0x6930, 0xa18e, 0x1101, 0x1538, 0x6834, 0xa005, 0x1520,
+	0x6900, 0xa18c, 0x00ff, 0x1118, 0x6804, 0xa005, 0x0190, 0x2011,
+	0xb68e, 0x2019, 0xb105, 0x20a9, 0x0004, 0x220c, 0x2304, 0xa102,
+	0x0230, 0x1190, 0x8210, 0x8318, 0x1f04, 0x4445, 0x0068, 0x7093,
+	0x0000, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xb680, 0x20a1,
+	0x020b, 0x20a9, 0x0014, 0x53a6, 0x6043, 0x0008, 0x6043, 0x0000,
+	0x0010, 0x00de, 0x0005, 0x6040, 0xa085, 0x0100, 0x6042, 0x6020,
+	0xd0b4, 0x1db8, 0x60c3, 0x000c, 0x2011, 0xb3e3, 0x2013, 0x0000,
+	0x7083, 0x0000, 0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7, 0x9575,
+	0x080c, 0x7a83, 0x0c30, 0x0005, 0x7088, 0xa08a, 0x001d, 0x1210,
+	0x0023, 0x0010, 0x080c, 0x14fa, 0x0005, 0x44af, 0x44be, 0x44e6,
+	0x44ff, 0x4523, 0x454b, 0x456f, 0x45a0, 0x45c4, 0x45ec, 0x4623,
+	0x464b, 0x4667, 0x467d, 0x469d, 0x46b0, 0x46b8, 0x46e5, 0x4709,
+	0x4731, 0x4755, 0x4786, 0x47c3, 0x47f2, 0x480e, 0x484d, 0x486d,
+	0x4886, 0x4887, 0x00c6, 0x2061, 0xb100, 0x6003, 0x0007, 0x2061,
+	0x0100, 0x6004, 0xa084, 0xfff9, 0x6006, 0x00ce, 0x0005, 0x608b,
+	0xbc94, 0x608f, 0xf0f0, 0x6043, 0x0002, 0x708b, 0x0001, 0x2009,
+	0x07d0, 0x2011, 0x494f, 0x080c, 0x67c8, 0x0005, 0x00f6, 0x7080,
+	0xa086, 0x0014, 0x1508, 0x6043, 0x0000, 0x6020, 0xd0b4, 0x11e0,
+	0x2079, 0xb680, 0x7a30, 0xa296, 0x1102, 0x11a0, 0x7834, 0xa005,
+	0x1188, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0xa005, 0x1110, 0x70b7,
+	0x0001, 0x2011, 0x494f, 0x080c, 0x6742, 0x708b, 0x0010, 0x080c,
+	0x46b8, 0x0010, 0x080c, 0x4992, 0x00fe, 0x0005, 0x708b, 0x0003,
+	0x6043, 0x0004, 0x2011, 0x494f, 0x080c, 0x6742, 0x080c, 0x4a0c,
+	0x20a3, 0x1102, 0x20a3, 0x0000, 0x20a9, 0x000a, 0x20a3, 0x0000,
+	0x1f04, 0x44f6, 0x60c3, 0x0014, 0x080c, 0x4979, 0x0005, 0x00f6,
+	0x7080, 0xa005, 0x01f0, 0x2011, 0x494f, 0x080c, 0x6742, 0xa086,
+	0x0014, 0x11a8, 0x2079, 0xb680, 0x7a30, 0xa296, 0x1102, 0x1178,
+	0x7834, 0xa005, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0xa005,
+	0x1110, 0x70b7, 0x0001, 0x708b, 0x0004, 0x0029, 0x0010, 0x080c,
+	0x4992, 0x00fe, 0x0005, 0x708b, 0x0005, 0x080c, 0x4a0c, 0x20a3,
+	0x1103, 0x20a3, 0x0000, 0x3430, 0x2011, 0xb68e, 0x080c, 0x4a5d,
+	0x1160, 0x7074, 0xa005, 0x1148, 0x714c, 0xa186, 0xffff, 0x0128,
+	0x080c, 0x4913, 0x0110, 0x080c, 0x4a3b, 0x20a9, 0x0008, 0x2298,
+	0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x080c, 0x4979, 0x0005, 0x00f6, 0x7080, 0xa005, 0x01f0, 0x2011,
+	0x494f, 0x080c, 0x6742, 0xa086, 0x0014, 0x11a8, 0x2079, 0xb680,
+	0x7a30, 0xa296, 0x1103, 0x1178, 0x7834, 0xa005, 0x1160, 0x7a38,
+	0xd2fc, 0x0128, 0x70b4, 0xa005, 0x1110, 0x70b7, 0x0001, 0x708b,
+	0x0006, 0x0029, 0x0010, 0x080c, 0x4992, 0x00fe, 0x0005, 0x708b,
+	0x0007, 0x080c, 0x4a0c, 0x20a3, 0x1104, 0x20a3, 0x0000, 0x3430,
+	0x2011, 0xb68e, 0x080c, 0x4a5d, 0x11a8, 0x7074, 0xa005, 0x1190,
+	0x7154, 0xa186, 0xffff, 0x0170, 0xa180, 0x2c8c, 0x200d, 0xa18c,
+	0xff00, 0x810f, 0x080c, 0x4913, 0x0128, 0x080c, 0x3f65, 0x0110,
+	0x080c, 0x2740, 0x20a9, 0x0008, 0x2298, 0x26a0, 0x53a6, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x080c, 0x4979, 0x0005,
+	0x00f6, 0x7080, 0xa005, 0x01f0, 0x2011, 0x494f, 0x080c, 0x6742,
+	0xa086, 0x0014, 0x11a8, 0x2079, 0xb680, 0x7a30, 0xa296, 0x1104,
+	0x1178, 0x7834, 0xa005, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b4,
+	0xa005, 0x1110, 0x70b7, 0x0001, 0x708b, 0x0008, 0x0029, 0x0010,
+	0x080c, 0x4992, 0x00fe, 0x0005, 0x708b, 0x0009, 0x080c, 0x4a0c,
+	0x20a3, 0x1105, 0x20a3, 0x0100, 0x3430, 0x080c, 0x4a5d, 0x1150,
+	0x7074, 0xa005, 0x1138, 0x080c, 0x4888, 0x1170, 0xa085, 0x0001,
+	0x080c, 0x2740, 0x20a9, 0x0008, 0x2099, 0xb68e, 0x26a0, 0x53a6,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x080c, 0x4979,
+	0x0010, 0x080c, 0x44a2, 0x0005, 0x00f6, 0x7080, 0xa005, 0x0588,
+	0x2011, 0x494f, 0x080c, 0x6742, 0xa086, 0x0014, 0x1540, 0x2079,
+	0xb680, 0x7a30, 0xa296, 0x1105, 0x1510, 0x7834, 0x2011, 0x0100,
+	0xa21e, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0xa005, 0x1110,
+	0x70b7, 0x0001, 0x708b, 0x000a, 0x00b1, 0x0098, 0xa005, 0x1178,
+	0x7a38, 0xd2fc, 0x0128, 0x70b4, 0xa005, 0x1110, 0x70b7, 0x0001,
+	0x7087, 0x0000, 0x708b, 0x000e, 0x080c, 0x469d, 0x0010, 0x080c,
+	0x4992, 0x00fe, 0x0005, 0x708b, 0x000b, 0x2011, 0xb60e, 0x22a0,
+	0x20a9, 0x0040, 0x2019, 0xffff, 0x43a4, 0x20a9, 0x0002, 0x2009,
+	0x0000, 0x41a4, 0x080c, 0x4a0c, 0x20a3, 0x1106, 0x20a3, 0x0000,
+	0x080c, 0x4a5d, 0x0118, 0x2013, 0x0000, 0x0020, 0x7050, 0xa085,
+	0x0100, 0x2012, 0x2298, 0x20a9, 0x0042, 0x53a6, 0x60c3, 0x0084,
+	0x080c, 0x4979, 0x0005, 0x00f6, 0x7080, 0xa005, 0x01b0, 0x2011,
+	0x494f, 0x080c, 0x6742, 0xa086, 0x0084, 0x1168, 0x2079, 0xb680,
+	0x7a30, 0xa296, 0x1106, 0x1138, 0x7834, 0xa005, 0x1120, 0x708b,
+	0x000c, 0x0029, 0x0010, 0x080c, 0x4992, 0x00fe, 0x0005, 0x708b,
+	0x000d, 0x080c, 0x4a0c, 0x20a3, 0x1107, 0x20a3, 0x0000, 0x2099,
+	0xb68e, 0x20a9, 0x0040, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0084, 0x080c, 0x4979, 0x0005, 0x00f6, 0x7080, 0xa005,
+	0x01d0, 0x2011, 0x494f, 0x080c, 0x6742, 0xa086, 0x0084, 0x1188,
+	0x2079, 0xb680, 0x7a30, 0xa296, 0x1107, 0x1158, 0x7834, 0xa005,
+	0x1140, 0x7087, 0x0001, 0x080c, 0x49fe, 0x708b, 0x000e, 0x0029,
+	0x0010, 0x080c, 0x4992, 0x00fe, 0x0005, 0x708b, 0x000f, 0x7083,
+	0x0000, 0x608b, 0xbc85, 0x608f, 0xb5b5, 0x6043, 0x0005, 0x6043,
+	0x0004, 0x2009, 0x07d0, 0x2011, 0x494f, 0x080c, 0x6736, 0x0005,
+	0x7080, 0xa005, 0x0120, 0x2011, 0x494f, 0x080c, 0x6742, 0x0005,
+	0x708b, 0x0011, 0x080c, 0x4a5d, 0x1188, 0x716c, 0x81ff, 0x0170,
+	0x2009, 0x0000, 0x7070, 0xa084, 0x00ff, 0x080c, 0x26f6, 0xa186,
+	0x0080, 0x0120, 0x2011, 0xb68e, 0x080c, 0x4913, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x2099, 0xb680, 0x20a1, 0x020b, 0x7480, 0xa480,
+	0x0018, 0xa080, 0x0007, 0xa084, 0x03f8, 0x8004, 0x20a8, 0x53a6,
+	0x60c3, 0x0014, 0x080c, 0x4979, 0x0005, 0x00f6, 0x7080, 0xa005,
+	0x01f0, 0x2011, 0x494f, 0x080c, 0x6742, 0xa086, 0x0014, 0x11a8,
+	0x2079, 0xb680, 0x7a30, 0xa296, 0x1103, 0x1178, 0x7834, 0xa005,
+	0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0xa005, 0x1110, 0x70b7,
+	0x0001, 0x708b, 0x0012, 0x0029, 0x0010, 0x080c, 0x4992, 0x00fe,
+	0x0005, 0x708b, 0x0013, 0x080c, 0x4a18, 0x20a3, 0x1103, 0x20a3,
+	0x0000, 0x3430, 0x2011, 0xb68e, 0x080c, 0x4a5d, 0x1160, 0x7074,
+	0xa005, 0x1148, 0x714c, 0xa186, 0xffff, 0x0128, 0x080c, 0x4913,
+	0x0110, 0x080c, 0x4a3b, 0x20a9, 0x0008, 0x2298, 0x26a0, 0x53a6,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x080c, 0x4979,
+	0x0005, 0x00f6, 0x7080, 0xa005, 0x01f0, 0x2011, 0x494f, 0x080c,
+	0x6742, 0xa086, 0x0014, 0x11a8, 0x2079, 0xb680, 0x7a30, 0xa296,
+	0x1104, 0x1178, 0x7834, 0xa005, 0x1160, 0x7a38, 0xd2fc, 0x0128,
+	0x70b4, 0xa005, 0x1110, 0x70b7, 0x0001, 0x708b, 0x0014, 0x0029,
+	0x0010, 0x080c, 0x4992, 0x00fe, 0x0005, 0x708b, 0x0015, 0x080c,
+	0x4a18, 0x20a3, 0x1104, 0x20a3, 0x0000, 0x3430, 0x2011, 0xb68e,
+	0x080c, 0x4a5d, 0x11a8, 0x7074, 0xa005, 0x1190, 0x7154, 0xa186,
+	0xffff, 0x0170, 0xa180, 0x2c8c, 0x200d, 0xa18c, 0xff00, 0x810f,
+	0x080c, 0x4913, 0x0128, 0x080c, 0x3f65, 0x0110, 0x080c, 0x2740,
+	0x20a9, 0x0008, 0x2298, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x60c3, 0x0014, 0x080c, 0x4979, 0x0005, 0x00f6, 0x7080,
+	0xa005, 0x05b8, 0x2011, 0x494f, 0x080c, 0x6742, 0xa086, 0x0014,
+	0x1570, 0x2079, 0xb680, 0x7a30, 0xa296, 0x1105, 0x1540, 0x7834,
+	0x2011, 0x0100, 0xa21e, 0x1148, 0x7a38, 0xd2fc, 0x0128, 0x70b4,
+	0xa005, 0x1110, 0x70b7, 0x0001, 0x0060, 0xa005, 0x11c0, 0x7a38,
+	0xd2fc, 0x0128, 0x70b4, 0xa005, 0x1110, 0x70b7, 0x0001, 0x7087,
+	0x0000, 0x7a38, 0xd2f4, 0x0138, 0x2001, 0xb174, 0x2004, 0xd0a4,
+	0x1110, 0x70d3, 0x0008, 0x708b, 0x0016, 0x0029, 0x0010, 0x080c,
+	0x4992, 0x00fe, 0x0005, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099,
+	0xb680, 0x20a1, 0x020b, 0x20a9, 0x000e, 0x53a6, 0x3430, 0x2011,
+	0xb68e, 0x708b, 0x0017, 0x080c, 0x4a5d, 0x1150, 0x7074, 0xa005,
+	0x1138, 0x080c, 0x4888, 0x1170, 0xa085, 0x0001, 0x080c, 0x2740,
+	0x20a9, 0x0008, 0x2099, 0xb68e, 0x26a0, 0x53a6, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x0014, 0x080c, 0x4979, 0x0010, 0x080c,
+	0x44a2, 0x0005, 0x00f6, 0x7080, 0xa005, 0x01b0, 0x2011, 0x494f,
+	0x080c, 0x6742, 0xa086, 0x0084, 0x1168, 0x2079, 0xb680, 0x7a30,
+	0xa296, 0x1106, 0x1138, 0x7834, 0xa005, 0x1120, 0x708b, 0x0018,
+	0x0029, 0x0010, 0x080c, 0x4992, 0x00fe, 0x0005, 0x708b, 0x0019,
+	0x080c, 0x4a18, 0x20a3, 0x1106, 0x20a3, 0x0000, 0x3430, 0x2099,
+	0xb68e, 0x2039, 0xb60e, 0x27a0, 0x20a9, 0x0040, 0x53a3, 0x080c,
+	0x4a5d, 0x11e8, 0x2728, 0x2514, 0x8207, 0xa084, 0x00ff, 0x8000,
+	0x2018, 0xa294, 0x00ff, 0x8007, 0xa205, 0x202a, 0x7050, 0x2310,
+	0x8214, 0xa2a0, 0xb60e, 0x2414, 0xa38c, 0x0001, 0x0118, 0xa294,
+	0xff00, 0x0018, 0xa294, 0x00ff, 0x8007, 0xa215, 0x2222, 0x2798,
+	0x26a0, 0x20a9, 0x0040, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0084, 0x080c, 0x4979, 0x0005, 0x00f6, 0x7080, 0xa005,
+	0x01d0, 0x2011, 0x494f, 0x080c, 0x6742, 0xa086, 0x0084, 0x1188,
+	0x2079, 0xb680, 0x7a30, 0xa296, 0x1107, 0x1158, 0x7834, 0xa005,
+	0x1140, 0x7087, 0x0001, 0x080c, 0x49fe, 0x708b, 0x001a, 0x0029,
+	0x0010, 0x080c, 0x4992, 0x00fe, 0x0005, 0x708b, 0x001b, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x2099, 0xb680, 0x20a1, 0x020b, 0x7480,
+	0xa480, 0x0018, 0xa080, 0x0007, 0xa084, 0x03f8, 0x8004, 0x20a8,
+	0x53a6, 0x60c3, 0x0084, 0x080c, 0x4979, 0x0005, 0x0005, 0x0005,
+	0x0086, 0x0096, 0x2029, 0xb153, 0x252c, 0x20a9, 0x0008, 0x2041,
+	0xb60e, 0x28a0, 0x2099, 0xb68e, 0x53a3, 0x20a9, 0x0008, 0x2011,
+	0x0007, 0xd5d4, 0x0110, 0x2011, 0x0000, 0x2800, 0xa200, 0x200c,
+	0xa1a6, 0xffff, 0x1148, 0xd5d4, 0x0110, 0x8210, 0x0008, 0x8211,
+	0x1f04, 0x489d, 0x0804, 0x490b, 0x82ff, 0x1160, 0xd5d4, 0x0120,
+	0xa1a6, 0x3fff, 0x0d90, 0x0020, 0xa1a6, 0x3fff, 0x0904, 0x490b,
+	0xa18d, 0xc000, 0x20a9, 0x0010, 0x2019, 0x0001, 0xd5d4, 0x0110,
+	0x2019, 0x0010, 0x2120, 0xd5d4, 0x0110, 0x8423, 0x0008, 0x8424,
+	0x1240, 0xd5d4, 0x0110, 0x8319, 0x0008, 0x8318, 0x1f04, 0x48c3,
+	0x04d0, 0x23a8, 0x2021, 0x0001, 0x8426, 0x8425, 0x1f04, 0x48d5,
+	0x2328, 0x8529, 0xa2be, 0x0007, 0x0158, 0x0006, 0x2039, 0x0007,
+	0x2200, 0xa73a, 0x000e, 0x27a8, 0xa5a8, 0x0010, 0x1f04, 0x48e4,
+	0x754e, 0xa5c8, 0x2c8c, 0x292d, 0xa5ac, 0x00ff, 0x7572, 0x6532,
+	0x6536, 0x0016, 0x2508, 0x080c, 0x2720, 0x001e, 0x60e7, 0x0000,
+	0x65ea, 0x2018, 0x2304, 0xa405, 0x201a, 0x7077, 0x0001, 0x26a0,
+	0x2898, 0x20a9, 0x0008, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0xa085, 0x0001, 0x0028, 0xa006, 0x0018, 0xa006, 0x080c, 0x14fa,
+	0x009e, 0x008e, 0x0005, 0x2118, 0x2021, 0x0000, 0x2001, 0x0007,
+	0xa39a, 0x0010, 0x0218, 0x8420, 0x8001, 0x0cd0, 0x2118, 0x84ff,
+	0x0120, 0xa39a, 0x0010, 0x8421, 0x1de0, 0x2021, 0x0001, 0x83ff,
+	0x0118, 0x8423, 0x8319, 0x1de8, 0xa238, 0x2704, 0xa42c, 0x11b8,
+	0xa405, 0x203a, 0x714e, 0xa1a0, 0x2c8c, 0x242d, 0xa5ac, 0x00ff,
+	0x7572, 0x6532, 0x6536, 0x0016, 0x2508, 0x080c, 0x2720, 0x001e,
+	0x60e7, 0x0000, 0x65ea, 0x7077, 0x0001, 0xa084, 0x0000, 0x0005,
+	0x00e6, 0x2071, 0xb100, 0x707b, 0x0000, 0x00ee, 0x0005, 0x00e6,
+	0x00f6, 0x2079, 0x0100, 0x2071, 0x0140, 0x080c, 0x7a8c, 0x7004,
+	0xa084, 0x4000, 0x0120, 0x7003, 0x1000, 0x7003, 0x0000, 0x0126,
+	0x2091, 0x8000, 0x2071, 0xb122, 0x2073, 0x0000, 0x7840, 0x0026,
+	0x0016, 0x2009, 0x00f7, 0x080c, 0x4a24, 0x001e, 0xa094, 0x0010,
+	0xa285, 0x0080, 0x7842, 0x7a42, 0x002e, 0x012e, 0x00fe, 0x00ee,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x2011, 0xb3e3, 0x2013, 0x0000,
+	0x7083, 0x0000, 0x012e, 0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7,
+	0x9575, 0x080c, 0x7a83, 0x2009, 0x07d0, 0x2011, 0x494f, 0x080c,
+	0x67c8, 0x0005, 0x0016, 0x0026, 0x00c6, 0x0126, 0x2091, 0x8000,
+	0x2011, 0x0003, 0x080c, 0x7d52, 0x2011, 0x0002, 0x080c, 0x7d5c,
+	0x080c, 0x7c41, 0x080c, 0x67b6, 0x0036, 0x2019, 0x0000, 0x080c,
+	0x7cc4, 0x003e, 0x2009, 0x00f7, 0x080c, 0x4a24, 0x2061, 0xb3ec,
+	0x601b, 0x0000, 0x601f, 0x0000, 0x2061, 0xb100, 0x6003, 0x0001,
+	0x2061, 0x0100, 0x6043, 0x0090, 0x6043, 0x0010, 0x2009, 0x002d,
+	0x2011, 0x49c9, 0x080c, 0x6736, 0x012e, 0x00ce, 0x002e, 0x001e,
+	0x0005, 0x00e6, 0x0006, 0x0126, 0x2091, 0x8000, 0x2071, 0x0100,
+	0x080c, 0x7a8c, 0x2071, 0x0140, 0x7004, 0xa084, 0x4000, 0x0120,
+	0x7003, 0x1000, 0x7003, 0x0000, 0x080c, 0x58dd, 0x01a8, 0x080c,
+	0x58fb, 0x1190, 0x2001, 0xb39e, 0x2003, 0xaaaa, 0x0016, 0x080c,
+	0x27c4, 0x2001, 0xb38f, 0x2102, 0x001e, 0x2001, 0xb39f, 0x2003,
+	0x0000, 0x080c, 0x5816, 0x0030, 0x2001, 0x0001, 0x080c, 0x269e,
+	0x080c, 0x4992, 0x012e, 0x000e, 0x00ee, 0x0005, 0x20a9, 0x0040,
+	0x20a1, 0xb7c0, 0x2099, 0xb68e, 0x3304, 0x8007, 0x20a2, 0x9398,
+	0x94a0, 0x1f04, 0x4a04, 0x0005, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x2099, 0xb600, 0x20a1, 0x020b, 0x20a9, 0x000c, 0x53a6, 0x0005,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xb680, 0x20a1, 0x020b,
+	0x20a9, 0x000c, 0x53a6, 0x0005, 0x00c6, 0x0006, 0x2061, 0x0100,
+	0x810f, 0x2001, 0xb130, 0x2004, 0xa005, 0x1138, 0x2001, 0xb114,
+	0x2004, 0xa084, 0x00ff, 0xa105, 0x0010, 0xa185, 0x00f7, 0x604a,
+	0x000e, 0x00ce, 0x0005, 0x0016, 0x0046, 0x2001, 0xb153, 0x2004,
+	0xd0a4, 0x0158, 0xa006, 0x2020, 0x2009, 0x002a, 0x080c, 0xacae,
+	0x2001, 0xb10c, 0x200c, 0xc195, 0x2102, 0x2019, 0x002a, 0x2009,
+	0x0000, 0x080c, 0x2b46, 0x004e, 0x001e, 0x0005, 0x080c, 0x4992,
+	0x708b, 0x0000, 0x7083, 0x0000, 0x0005, 0x0006, 0x2001, 0xb10c,
+	0x2004, 0xd09c, 0x0100, 0x000e, 0x0005, 0x0006, 0x0016, 0x0126,
+	0x2091, 0x8000, 0x2001, 0x0101, 0x200c, 0xa18d, 0x0006, 0x2102,
+	0x012e, 0x001e, 0x000e, 0x0005, 0x0156, 0x20a9, 0x00ff, 0x2009,
+	0xb235, 0xa006, 0x200a, 0x8108, 0x1f04, 0x4a7a, 0x015e, 0x0005,
+	0x00d6, 0x0036, 0x0156, 0x0136, 0x0146, 0x2069, 0xb152, 0xa006,
+	0x6002, 0x6007, 0x0707, 0x600a, 0x600e, 0x6012, 0xa198, 0x2c8c,
+	0x231d, 0xa39c, 0x00ff, 0x6316, 0x20a9, 0x0004, 0xac98, 0x0006,
+	0x23a0, 0x40a4, 0x20a9, 0x0004, 0xac98, 0x000a, 0x23a0, 0x40a4,
+	0x603e, 0x6042, 0x604e, 0x6052, 0x6056, 0x605a, 0x605e, 0x6062,
+	0x6066, 0x606a, 0x606e, 0x6072, 0x6076, 0x607a, 0x607e, 0x6082,
+	0x6086, 0x608a, 0x608e, 0x6092, 0x6096, 0x609a, 0x609e, 0x60ae,
+	0x61a2, 0x00d6, 0x60a4, 0xa06d, 0x0110, 0x080c, 0x15f4, 0x60a7,
+	0x0000, 0x60a8, 0xa06d, 0x0110, 0x080c, 0x15f4, 0x60ab, 0x0000,
+	0x00de, 0xa006, 0x604a, 0x6810, 0x603a, 0x680c, 0x6046, 0x6814,
+	0xa084, 0x00ff, 0x6042, 0x014e, 0x013e, 0x015e, 0x003e, 0x00de,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x6944, 0x6e48, 0xa684, 0x3fff,
+	0xa082, 0x4000, 0x1a04, 0x4b8f, 0xa18c, 0xff00, 0x810f, 0xa182,
+	0x00ff, 0x1a04, 0x4b94, 0x2001, 0xb10c, 0x2004, 0xa084, 0x0003,
+	0x01c0, 0x2001, 0xb10c, 0x2004, 0xd084, 0x1904, 0x4b77, 0xa188,
+	0xb235, 0x2104, 0xa065, 0x0904, 0x4b77, 0x6004, 0xa084, 0x00ff,
+	0xa08e, 0x0006, 0x1904, 0x4b77, 0x6000, 0xd0c4, 0x0904, 0x4b77,
+	0x0068, 0xa188, 0xb235, 0x2104, 0xa065, 0x0904, 0x4b5b, 0x6004,
+	0xa084, 0x00ff, 0xa08e, 0x0006, 0x1904, 0x4b60, 0x60a4, 0xa00d,
+	0x0118, 0x080c, 0x5046, 0x05d0, 0x60a8, 0xa00d, 0x0188, 0x080c,
+	0x5091, 0x1170, 0x694c, 0xd1fc, 0x1118, 0x080c, 0x4d56, 0x0448,
+	0x080c, 0x4d18, 0x694c, 0xd1ec, 0x1520, 0x080c, 0x4f3a, 0x0408,
+	0x694c, 0xa184, 0xa000, 0x0178, 0xd1ec, 0x0140, 0xd1fc, 0x0118,
+	0x080c, 0x4f49, 0x0028, 0x080c, 0x4f49, 0x0028, 0xd1fc, 0x0118,
+	0x080c, 0x4d18, 0x0070, 0x6050, 0xa00d, 0x0130, 0x2d00, 0x200a,
+	0x6803, 0x0000, 0x6052, 0x0028, 0x2d00, 0x6052, 0x604e, 0x6803,
+	0x0000, 0x080c, 0x6a13, 0xa006, 0x012e, 0x0005, 0x2001, 0x0005,
+	0x2009, 0x0000, 0x04e8, 0x2001, 0x0028, 0x2009, 0x0000, 0x04c0,
+	0xa082, 0x0006, 0x12a0, 0x2001, 0xb134, 0x2004, 0xd0ac, 0x1160,
+	0x60a0, 0xd0bc, 0x1148, 0x6100, 0xd1fc, 0x0904, 0x4b16, 0x2001,
+	0x0029, 0x2009, 0x1000, 0x0420, 0x2001, 0x0028, 0x00a8, 0x2009,
+	0xb10c, 0x210c, 0xd18c, 0x0118, 0x2001, 0x0004, 0x0068, 0xd184,
+	0x0118, 0x2001, 0x0004, 0x0040, 0x2001, 0x0029, 0x6100, 0xd1fc,
+	0x0118, 0x2009, 0x1000, 0x0060, 0x2009, 0x0000, 0x0048, 0x2001,
+	0x0029, 0x2009, 0x0000, 0x0020, 0x2001, 0x0029, 0x2009, 0x0000,
+	0xa005, 0x012e, 0x0005, 0x00e6, 0x0126, 0x2091, 0x8000, 0x6844,
+	0x8007, 0xa084, 0x00ff, 0x2008, 0xa182, 0x00ff, 0x1a04, 0x4bee,
+	0xa188, 0xb235, 0x2104, 0xa065, 0x01c0, 0x6004, 0xa084, 0x00ff,
+	0xa08e, 0x0006, 0x11a8, 0x2c70, 0x080c, 0x8295, 0x05e8, 0x2e00,
+	0x601a, 0x2d00, 0x6012, 0x600b, 0xffff, 0x601f, 0x000a, 0x2009,
+	0x0003, 0x080c, 0x831a, 0xa006, 0x0460, 0x2001, 0x0028, 0x0440,
+	0xa082, 0x0006, 0x1298, 0x2001, 0xb134, 0x2004, 0xd0ac, 0x1158,
+	0x60a0, 0xd0bc, 0x1140, 0x6100, 0xd1fc, 0x09e8, 0x2001, 0x0029,
+	0x2009, 0x1000, 0x00a8, 0x2001, 0x0028, 0x0090, 0x2009, 0xb10c,
+	0x210c, 0xd18c, 0x0118, 0x2001, 0x0004, 0x0050, 0xd184, 0x0118,
+	0x2001, 0x0004, 0x0028, 0x2001, 0x0029, 0x0010, 0x2001, 0x0029,
+	0xa005, 0x012e, 0x00ee, 0x0005, 0x2001, 0x002c, 0x0cc8, 0x00f6,
+	0x00e6, 0x0126, 0x2091, 0x8000, 0x2011, 0x0000, 0x2079, 0xb100,
+	0x6944, 0xa18c, 0xff00, 0x810f, 0xa182, 0x00ff, 0x1a04, 0x4cbc,
+	0x2001, 0xb10c, 0x2004, 0xa084, 0x0003, 0x1904, 0x4caa, 0x080c,
+	0x4e21, 0x1180, 0x6004, 0xa084, 0x00ff, 0xa082, 0x0006, 0x1250,
+	0x2001, 0xb134, 0x2004, 0xd0ac, 0x1904, 0x4ca5, 0x60a0, 0xd0bc,
+	0x1904, 0x4ca5, 0x6864, 0xa0c6, 0x006f, 0x0118, 0x2008, 0x0804,
+	0x4c6e, 0x6968, 0x2140, 0xa18c, 0xff00, 0x810f, 0x78d0, 0xd0ac,
+	0x1118, 0xa182, 0x0080, 0x06d0, 0xa182, 0x00ff, 0x16b8, 0x6a70,
+	0x6b6c, 0x786c, 0xa306, 0x1160, 0x7870, 0xa24e, 0x1118, 0x2208,
+	0x2310, 0x0460, 0xa9cc, 0xff00, 0x1118, 0x2208, 0x2310, 0x0430,
+	0x080c, 0x3c52, 0x2c70, 0x0550, 0x2009, 0x0000, 0x2011, 0x0000,
+	0xa0c6, 0x4000, 0x1160, 0x0006, 0x2e60, 0x080c, 0x50bc, 0x1108,
+	0xc185, 0x7000, 0xd0bc, 0x0108, 0xc18d, 0x000e, 0x0088, 0xa0c6,
+	0x4007, 0x1110, 0x2408, 0x0060, 0xa0c6, 0x4008, 0x1118, 0x2708,
+	0x2610, 0x0030, 0xa0c6, 0x4009, 0x1108, 0x0010, 0x2001, 0x4006,
+	0x6866, 0x696a, 0x6a6e, 0x2001, 0x0030, 0x0450, 0x080c, 0x8295,
+	0x1138, 0x2001, 0x4005, 0x2009, 0x0003, 0x2011, 0x0000, 0x0c80,
+	0x2e00, 0x601a, 0x080c, 0x9c35, 0x2d00, 0x6012, 0x601f, 0x0001,
+	0x6838, 0xd88c, 0x0108, 0xc0f5, 0x683a, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x2b73, 0x012e, 0x2001, 0x0000, 0x080c, 0x4d63, 0x2001,
+	0x0002, 0x080c, 0x4d75, 0x2009, 0x0002, 0x080c, 0x831a, 0xa006,
+	0xa005, 0x012e, 0x00ee, 0x00fe, 0x0005, 0x2001, 0x0028, 0x2009,
+	0x0000, 0x0cb0, 0x2009, 0xb10c, 0x210c, 0xd18c, 0x0118, 0x2001,
+	0x0004, 0x0038, 0xd184, 0x0118, 0x2001, 0x0004, 0x0010, 0x2001,
+	0x0029, 0x2009, 0x0000, 0x0c20, 0x2001, 0x0029, 0x2009, 0x0000,
+	0x08f8, 0x6944, 0x6e48, 0xa684, 0x3fff, 0xa082, 0x4000, 0x16b8,
+	0xa18c, 0xff00, 0x810f, 0xa182, 0x00ff, 0x12e0, 0xa188, 0xb235,
+	0x2104, 0xa065, 0x01b8, 0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006,
+	0x11b0, 0x684c, 0xd0ec, 0x0120, 0x080c, 0x4f49, 0x04c9, 0x0030,
+	0x04b9, 0x684c, 0xd0fc, 0x0110, 0x080c, 0x4f3a, 0x080c, 0x4f87,
+	0xa006, 0x00c8, 0x2001, 0x0028, 0x2009, 0x0000, 0x00a0, 0xa082,
+	0x0006, 0x1240, 0x6100, 0xd1fc, 0x0d20, 0x2001, 0x0029, 0x2009,
+	0x1000, 0x0048, 0x2001, 0x0029, 0x2009, 0x0000, 0x0020, 0x2001,
+	0x0029, 0x2009, 0x0000, 0xa005, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x6050, 0xa00d, 0x0138, 0x2d00, 0x200a, 0x6803, 0x0000, 0x6052,
+	0x012e, 0x0005, 0x2d00, 0x6052, 0x604e, 0x6803, 0x0000, 0x0cc0,
+	0x0126, 0x2091, 0x8000, 0x604c, 0xa005, 0x0170, 0x00e6, 0x2071,
+	0xb3d9, 0x7004, 0xa086, 0x0002, 0x0168, 0x00ee, 0x604c, 0x6802,
+	0x2d00, 0x604e, 0x012e, 0x0005, 0x2d00, 0x6052, 0x604e, 0x6803,
+	0x0000, 0x0cc0, 0x701c, 0xac06, 0x1d80, 0x604c, 0x2070, 0x7000,
+	0x6802, 0x2d00, 0x7002, 0x00ee, 0x012e, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x604c, 0xa06d, 0x0130, 0x6800, 0xa005, 0x1108, 0x6052,
+	0x604e, 0xad05, 0x012e, 0x0005, 0x604c, 0xa06d, 0x0130, 0x6800,
+	0xa005, 0x1108, 0x6052, 0x604e, 0xad05, 0x0005, 0x6803, 0x0000,
+	0x6084, 0xa00d, 0x0120, 0x2d00, 0x200a, 0x6086, 0x0005, 0x2d00,
+	0x6086, 0x6082, 0x0cd8, 0x0126, 0x00c6, 0x0026, 0x2091, 0x8000,
+	0x6218, 0x2260, 0x6200, 0xa005, 0x0110, 0xc285, 0x0008, 0xc284,
+	0x6202, 0x002e, 0x00ce, 0x012e, 0x0005, 0x0126, 0x00c6, 0x2091,
+	0x8000, 0x6218, 0x2260, 0x6204, 0x0006, 0xa086, 0x0006, 0x1180,
+	0x609c, 0xd0ac, 0x0168, 0x2001, 0xb153, 0x2004, 0xd0a4, 0x0140,
+	0xa284, 0xff00, 0x8007, 0xa086, 0x0007, 0x1110, 0x2011, 0x0600,
+	0x000e, 0xa294, 0xff00, 0xa215, 0x6206, 0x0006, 0xa086, 0x0006,
+	0x1128, 0x6290, 0x82ff, 0x1110, 0x080c, 0x14fa, 0x000e, 0x00ce,
+	0x012e, 0x0005, 0x0126, 0x00c6, 0x2091, 0x8000, 0x6218, 0x2260,
+	0x6204, 0x0006, 0xa086, 0x0006, 0x1178, 0x609c, 0xd0a4, 0x0160,
+	0x2001, 0xb153, 0x2004, 0xd0ac, 0x1138, 0xa284, 0x00ff, 0xa086,
+	0x0007, 0x1110, 0x2011, 0x0006, 0x000e, 0xa294, 0x00ff, 0x8007,
+	0xa215, 0x6206, 0x00ce, 0x012e, 0x0005, 0x0026, 0xa182, 0x00ff,
+	0x0218, 0xa085, 0x0001, 0x00b0, 0xa190, 0xb235, 0x2204, 0xa065,
+	0x1180, 0x0016, 0x00d6, 0x080c, 0x15c4, 0x2d60, 0x00de, 0x001e,
+	0x0d80, 0x2c00, 0x2012, 0x60a7, 0x0000, 0x60ab, 0x0000, 0x080c,
+	0x4a80, 0xa006, 0x002e, 0x0005, 0x0126, 0x2091, 0x8000, 0x0026,
+	0xa182, 0x00ff, 0x0218, 0xa085, 0x0001, 0x0480, 0x00d6, 0xa190,
+	0xb235, 0x2204, 0xa06d, 0x0540, 0x2013, 0x0000, 0x00d6, 0x00c6,
+	0x2d60, 0x60a4, 0xa06d, 0x0110, 0x080c, 0x15f4, 0x60a8, 0xa06d,
+	0x0110, 0x080c, 0x15f4, 0x00ce, 0x00de, 0x00d6, 0x00c6, 0x68ac,
+	0x2060, 0x8cff, 0x0168, 0x600c, 0x0006, 0x6010, 0x2068, 0x080c,
+	0x986a, 0x0110, 0x080c, 0x1604, 0x080c, 0x82eb, 0x00ce, 0x0c88,
+	0x00ce, 0x00de, 0x080c, 0x15f4, 0x00de, 0xa006, 0x002e, 0x012e,
+	0x0005, 0x0016, 0xa182, 0x00ff, 0x0218, 0xa085, 0x0001, 0x0030,
+	0xa188, 0xb235, 0x2104, 0xa065, 0x0dc0, 0xa006, 0x001e, 0x0005,
+	0x00d6, 0x0156, 0x0136, 0x0146, 0x600b, 0x0000, 0x600f, 0x0000,
+	0x6000, 0xc08c, 0x6002, 0x080c, 0x58d5, 0x1538, 0x60a0, 0xa086,
+	0x007e, 0x2069, 0xb690, 0x0130, 0x2001, 0xb134, 0x2004, 0xd0ac,
+	0x11e0, 0x0098, 0x2d04, 0xd0e4, 0x01c0, 0x00d6, 0x2069, 0xb68e,
+	0x00c6, 0x2061, 0xb3b1, 0x6810, 0x2062, 0x6814, 0x6006, 0x6818,
+	0x600a, 0x681c, 0x600e, 0x00ce, 0x00de, 0x8d69, 0x2d04, 0x2069,
+	0x0140, 0x6886, 0x2069, 0xb100, 0x68a2, 0x2069, 0xb68e, 0x6808,
+	0x605e, 0x6810, 0x6062, 0x6138, 0xa10a, 0x0208, 0x603a, 0x6814,
+	0x6066, 0x2099, 0xb696, 0xac88, 0x000a, 0x21a0, 0x20a9, 0x0004,
+	0x53a3, 0x2099, 0xb69a, 0xac88, 0x0006, 0x21a0, 0x20a9, 0x0004,
+	0x53a3, 0x2069, 0xb6ae, 0x6808, 0x606a, 0x690c, 0x616e, 0x6810,
+	0x6072, 0x6818, 0x6076, 0x60a0, 0xa086, 0x007e, 0x1120, 0x2069,
+	0xb68e, 0x690c, 0x616e, 0xa182, 0x0211, 0x1218, 0x2009, 0x0008,
+	0x0400, 0xa182, 0x0259, 0x1218, 0x2009, 0x0007, 0x00d0, 0xa182,
+	0x02c1, 0x1218, 0x2009, 0x0006, 0x00a0, 0xa182, 0x0349, 0x1218,
+	0x2009, 0x0005, 0x0070, 0xa182, 0x0421, 0x1218, 0x2009, 0x0004,
+	0x0040, 0xa182, 0x0581, 0x1218, 0x2009, 0x0003, 0x0010, 0x2009,
+	0x0002, 0x6192, 0x014e, 0x013e, 0x015e, 0x00de, 0x0005, 0x0016,
+	0x0026, 0x00e6, 0x2071, 0xb68d, 0x2e04, 0x6896, 0x2071, 0xb68e,
+	0x7004, 0x689a, 0x701c, 0x689e, 0x6a00, 0x2009, 0xb172, 0x210c,
+	0xd0bc, 0x0120, 0xd1ec, 0x0110, 0xc2ad, 0x0008, 0xc2ac, 0xd0c4,
+	0x0120, 0xd1e4, 0x0110, 0xc2bd, 0x0008, 0xc2bc, 0x6a02, 0x00ee,
+	0x002e, 0x001e, 0x0005, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a4,
+	0xa06d, 0x01c0, 0x6900, 0x81ff, 0x1540, 0x6a04, 0xa282, 0x0010,
+	0x1648, 0xad88, 0x0004, 0x20a9, 0x0010, 0x2104, 0xa086, 0xffff,
+	0x0128, 0x8108, 0x1f04, 0x4ef5, 0x080c, 0x14fa, 0x260a, 0x8210,
+	0x6a06, 0x0098, 0x080c, 0x15dd, 0x01a8, 0x2d00, 0x60a6, 0x6803,
+	0x0000, 0xad88, 0x0004, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108,
+	0x1f04, 0x4f0d, 0x6807, 0x0001, 0x6e12, 0xa085, 0x0001, 0x012e,
+	0x00de, 0x0005, 0xa006, 0x0cd8, 0x0126, 0x2091, 0x8000, 0x00d6,
+	0x60a4, 0xa00d, 0x01a0, 0x2168, 0x6800, 0xa005, 0x1160, 0x080c,
+	0x5046, 0x1168, 0x200b, 0xffff, 0x6804, 0xa08a, 0x0002, 0x0218,
+	0x8001, 0x6806, 0x0020, 0x080c, 0x15f4, 0x60a7, 0x0000, 0x00de,
+	0x012e, 0x0005, 0x0126, 0x2091, 0x8000, 0x080c, 0x50a4, 0x0010,
+	0x080c, 0x4d05, 0x080c, 0x4fbe, 0x1dd8, 0x080c, 0x4f87, 0x012e,
+	0x0005, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a8, 0xa06d, 0x01c0,
+	0x6950, 0x81ff, 0x1540, 0x6a54, 0xa282, 0x0010, 0x1670, 0xad88,
+	0x0018, 0x20a9, 0x0010, 0x2104, 0xa086, 0xffff, 0x0128, 0x8108,
+	0x1f04, 0x4f5b, 0x080c, 0x14fa, 0x260a, 0x8210, 0x6a56, 0x0098,
+	0x080c, 0x15dd, 0x01d0, 0x2d00, 0x60aa, 0x6853, 0x0000, 0xad88,
+	0x0018, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108, 0x1f04, 0x4f73,
+	0x6857, 0x0001, 0x6e62, 0x0010, 0x080c, 0x4d56, 0x0089, 0x1de0,
+	0xa085, 0x0001, 0x012e, 0x00de, 0x0005, 0xa006, 0x0cd8, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x6a13, 0x012e, 0x0005, 0xa01e, 0x0010,
+	0x2019, 0x0001, 0xa00e, 0x0126, 0x2091, 0x8000, 0x604c, 0x2068,
+	0x6000, 0xd0dc, 0x1170, 0x8dff, 0x01e8, 0x83ff, 0x0120, 0x6848,
+	0xa606, 0x0158, 0x0030, 0x683c, 0xa406, 0x1118, 0x6840, 0xa506,
+	0x0120, 0x2d08, 0x6800, 0x2068, 0x0c70, 0x6a00, 0x604c, 0xad06,
+	0x1110, 0x624e, 0x0018, 0xa180, 0x0000, 0x2202, 0x82ff, 0x1110,
+	0x6152, 0x8dff, 0x012e, 0x0005, 0xa01e, 0x0010, 0x2019, 0x0001,
+	0xa00e, 0x6080, 0x2068, 0x8dff, 0x01e8, 0x83ff, 0x0120, 0x6848,
+	0xa606, 0x0158, 0x0030, 0x683c, 0xa406, 0x1118, 0x6840, 0xa506,
+	0x0120, 0x2d08, 0x6800, 0x2068, 0x0c70, 0x6a00, 0x6080, 0xad06,
+	0x1110, 0x6282, 0x0018, 0xa180, 0x0000, 0x2202, 0x82ff, 0x1110,
+	0x6186, 0x8dff, 0x0005, 0xa016, 0x080c, 0x5040, 0x1110, 0x2011,
+	0x0001, 0x080c, 0x508b, 0x1110, 0xa295, 0x0002, 0x0005, 0x080c,
+	0x50bc, 0x0118, 0x080c, 0x9928, 0x0010, 0xa085, 0x0001, 0x0005,
+	0x080c, 0x50bc, 0x0118, 0x080c, 0x98b8, 0x0010, 0xa085, 0x0001,
+	0x0005, 0x080c, 0x50bc, 0x0118, 0x080c, 0x990b, 0x0010, 0xa085,
+	0x0001, 0x0005, 0x080c, 0x50bc, 0x0118, 0x080c, 0x98d4, 0x0010,
+	0xa085, 0x0001, 0x0005, 0x080c, 0x50bc, 0x0118, 0x080c, 0x9944,
+	0x0010, 0xa085, 0x0001, 0x0005, 0x0126, 0x0006, 0x00d6, 0x2091,
+	0x8000, 0x6080, 0xa06d, 0x01a0, 0x6800, 0x0006, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x080c, 0x9ada, 0x0006, 0x6000, 0xd0fc,
+	0x0110, 0x080c, 0xaf4f, 0x000e, 0x080c, 0x5271, 0x000e, 0x0c50,
+	0x6083, 0x0000, 0x6087, 0x0000, 0x00de, 0x000e, 0x012e, 0x0005,
+	0x60a4, 0xa00d, 0x1118, 0xa085, 0x0001, 0x0005, 0x00e6, 0x2170,
+	0x7000, 0xa005, 0x1168, 0x20a9, 0x0010, 0xae88, 0x0004, 0x2104,
+	0xa606, 0x0130, 0x8108, 0x1f04, 0x504f, 0xa085, 0x0001, 0x0008,
+	0xa006, 0x00ee, 0x0005, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a4,
+	0xa06d, 0x1128, 0x080c, 0x15dd, 0x01a0, 0x2d00, 0x60a6, 0x6803,
+	0x0001, 0x6807, 0x0000, 0xad88, 0x0004, 0x20a9, 0x0010, 0x200b,
+	0xffff, 0x8108, 0x1f04, 0x506f, 0xa085, 0x0001, 0x012e, 0x00de,
+	0x0005, 0xa006, 0x0cd8, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a4,
+	0xa06d, 0x0130, 0x60a7, 0x0000, 0x080c, 0x15f4, 0xa085, 0x0001,
+	0x012e, 0x00de, 0x0005, 0x60a8, 0xa00d, 0x1118, 0xa085, 0x0001,
+	0x0005, 0x00e6, 0x2170, 0x7050, 0xa005, 0x1160, 0x20a9, 0x0010,
+	0xae88, 0x0018, 0x2104, 0xa606, 0x0128, 0x8108, 0x1f04, 0x509a,
+	0xa085, 0x0001, 0x00ee, 0x0005, 0x0126, 0x2091, 0x8000, 0x0c19,
+	0x1188, 0x200b, 0xffff, 0x00d6, 0x60a8, 0x2068, 0x6854, 0xa08a,
+	0x0002, 0x0218, 0x8001, 0x6856, 0x0020, 0x080c, 0x15f4, 0x60ab,
+	0x0000, 0x00de, 0x012e, 0x0005, 0x609c, 0xd0a4, 0x0005, 0x00f6,
+	0x080c, 0x58d5, 0x01b0, 0x71b4, 0x81ff, 0x1198, 0x71d0, 0xd19c,
+	0x0180, 0x2001, 0x007e, 0xa080, 0xb235, 0x2004, 0xa07d, 0x0148,
+	0x7804, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1118, 0x7800, 0xc0ed,
+	0x7802, 0x2079, 0xb152, 0x7804, 0xd0a4, 0x01e8, 0x0156, 0x00c6,
+	0x20a9, 0x007f, 0x2009, 0x0000, 0x0016, 0x080c, 0x4e21, 0x1168,
+	0x6004, 0xa084, 0xff00, 0x8007, 0xa096, 0x0004, 0x0118, 0xa086,
+	0x0006, 0x1118, 0x6000, 0xc0ed, 0x6002, 0x001e, 0x8108, 0x1f04,
+	0x50e4, 0x00ce, 0x015e, 0x080c, 0x517b, 0x0120, 0x2001, 0xb3b4,
+	0x200c, 0x0038, 0x2079, 0xb152, 0x7804, 0xd0a4, 0x0130, 0x2009,
+	0x07d0, 0x2011, 0x510f, 0x080c, 0x67c8, 0x00fe, 0x0005, 0x2011,
+	0x510f, 0x080c, 0x6742, 0x080c, 0x517b, 0x01f0, 0x2001, 0xb2b3,
+	0x2004, 0xa080, 0x0000, 0x200c, 0xc1ec, 0x2102, 0x2001, 0xb153,
+	0x2004, 0xd0a4, 0x0130, 0x2009, 0x07d0, 0x2011, 0x510f, 0x080c,
+	0x67c8, 0x00e6, 0x2071, 0xb100, 0x706f, 0x0000, 0x7073, 0x0000,
+	0x080c, 0x2991, 0x00ee, 0x04b0, 0x0156, 0x00c6, 0x20a9, 0x007f,
+	0x2009, 0x0000, 0x0016, 0x080c, 0x4e21, 0x1530, 0x6000, 0xd0ec,
+	0x0518, 0x0046, 0x62a0, 0xa294, 0x00ff, 0x8227, 0xa006, 0x2009,
+	0x0029, 0x080c, 0xacae, 0x6000, 0xc0e5, 0xc0ec, 0x6002, 0x6004,
+	0xa084, 0x00ff, 0xa085, 0x0700, 0x6006, 0x2019, 0x0029, 0x080c,
+	0x6b35, 0x0076, 0x2039, 0x0000, 0x080c, 0x6a6b, 0x2009, 0x0000,
+	0x080c, 0xaa51, 0x007e, 0x004e, 0x001e, 0x8108, 0x1f04, 0x513a,
+	0x00ce, 0x015e, 0x0005, 0x00c6, 0x6018, 0x2060, 0x6000, 0xc0ec,
+	0x6002, 0x00ce, 0x0005, 0x7818, 0x2004, 0xd0ac, 0x0005, 0x7818,
+	0x2004, 0xd0bc, 0x0005, 0x00f6, 0x2001, 0xb2b3, 0x2004, 0xa07d,
+	0x0110, 0x7800, 0xd0ec, 0x00fe, 0x0005, 0x0126, 0x0026, 0x2091,
+	0x8000, 0x6200, 0xa005, 0x0110, 0xc2fd, 0x0008, 0xc2fc, 0x6202,
+	0x002e, 0x012e, 0x0005, 0x2011, 0xb134, 0x2204, 0xd0cc, 0x0138,
+	0x2001, 0xb3b2, 0x200c, 0x2011, 0x51a0, 0x080c, 0x67c8, 0x0005,
+	0x2011, 0x51a0, 0x080c, 0x6742, 0x2011, 0xb134, 0x2204, 0xc0cc,
+	0x2012, 0x0005, 0x2071, 0xb214, 0x7003, 0x0001, 0x7007, 0x0000,
+	0x7013, 0x0000, 0x7017, 0x0000, 0x701b, 0x0000, 0x701f, 0x0000,
+	0x700b, 0x0000, 0x704b, 0x0001, 0x704f, 0x0000, 0x705b, 0x0020,
+	0x705f, 0x0040, 0x707f, 0x0000, 0x2071, 0xb37d, 0x7003, 0xb214,
+	0x7007, 0x0000, 0x700b, 0x0000, 0x700f, 0xb35d, 0x7013, 0x0020,
+	0x7017, 0x0040, 0x7037, 0x0000, 0x0005, 0x0016, 0x00e6, 0x2071,
+	0xb335, 0xa00e, 0x7186, 0x718a, 0x7097, 0x0001, 0x2001, 0xb153,
+	0x2004, 0xd0fc, 0x1150, 0x2001, 0xb153, 0x2004, 0xa00e, 0xd09c,
+	0x0108, 0x8108, 0x7102, 0x0804, 0x523b, 0x2001, 0xb172, 0x200c,
+	0xa184, 0x000f, 0x2009, 0xb173, 0x210c, 0x0002, 0x51e3, 0x5216,
+	0x521d, 0x5227, 0x522c, 0x51e3, 0x51e3, 0x51e3, 0x5206, 0x51e3,
+	0x51e3, 0x51e3, 0x51e3, 0x51e3, 0x51e3, 0x51e3, 0x7003, 0x0004,
+	0x0136, 0x0146, 0x0156, 0x2099, 0xb176, 0x20a1, 0xb386, 0x20a9,
+	0x0004, 0x53a3, 0x015e, 0x014e, 0x013e, 0x0428, 0x708f, 0x0005,
+	0x7007, 0x0122, 0x2001, 0x0002, 0x0030, 0x708f, 0x0002, 0x7007,
+	0x0121, 0x2001, 0x0003, 0x7002, 0x7097, 0x0001, 0x0088, 0x7007,
+	0x0122, 0x2001, 0x0002, 0x0020, 0x7007, 0x0121, 0x2001, 0x0003,
+	0x7002, 0xa006, 0x7096, 0x708e, 0xa184, 0xff00, 0x8007, 0x709a,
+	0xa184, 0x00ff, 0x7092, 0x00ee, 0x001e, 0x0005, 0x00e6, 0x2071,
+	0xb214, 0x684c, 0xa005, 0x1130, 0x7028, 0xc085, 0x702a, 0xa085,
+	0x0001, 0x0428, 0x6a60, 0x7236, 0x6b64, 0x733a, 0x6868, 0x703e,
+	0x7076, 0x686c, 0x7042, 0x707a, 0x684c, 0x702e, 0x6844, 0x7032,
+	0x2009, 0x000d, 0x200a, 0x700b, 0x0000, 0x8007, 0x8006, 0x8006,
+	0xa08c, 0x003f, 0xa084, 0xffc0, 0xa210, 0x2100, 0xa319, 0x726e,
+	0x7372, 0x7028, 0xc084, 0x702a, 0x7007, 0x0001, 0xa006, 0x00ee,
+	0x0005, 0x0156, 0x00e6, 0x0026, 0x6838, 0xd0fc, 0x1904, 0x52ca,
+	0x6804, 0xa00d, 0x0188, 0x00d6, 0x2071, 0xb100, 0xa016, 0x702c,
+	0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e,
+	0x70b0, 0xa200, 0x70b2, 0x00de, 0x2071, 0xb214, 0x701c, 0xa005,
+	0x1904, 0x52da, 0x20a9, 0x0032, 0x0f04, 0x52d8, 0x0e04, 0x5294,
+	0x2071, 0xb335, 0x7200, 0x82ff, 0x05d8, 0x6934, 0xa186, 0x0103,
+	0x1904, 0x52e8, 0x6948, 0x6844, 0xa105, 0x1540, 0x2009, 0x8020,
+	0x2200, 0x0002, 0x52d8, 0x52af, 0x5300, 0x530c, 0x52d8, 0x2071,
+	0x0000, 0x20a9, 0x0032, 0x0f04, 0x52d8, 0x7018, 0xd084, 0x1dd8,
+	0x7122, 0x683c, 0x7026, 0x6840, 0x702a, 0x701b, 0x0001, 0x2091,
+	0x4080, 0x2071, 0xb100, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70b0,
+	0x8000, 0x70b2, 0x002e, 0x00ee, 0x015e, 0x0005, 0x6844, 0xa086,
+	0x0100, 0x1130, 0x6868, 0xa005, 0x1118, 0x2009, 0x8020, 0x0880,
+	0x2071, 0xb214, 0x2d08, 0x206b, 0x0000, 0x7010, 0x8000, 0x7012,
+	0x7018, 0xa06d, 0x711a, 0x0110, 0x6902, 0x0008, 0x711e, 0x0c10,
+	0xa18c, 0x00ff, 0xa186, 0x0017, 0x0130, 0xa186, 0x001e, 0x0118,
+	0xa18e, 0x001f, 0x1d28, 0x684c, 0xd0cc, 0x0d10, 0x6850, 0xa084,
+	0x00ff, 0xa086, 0x0001, 0x19e0, 0x2009, 0x8021, 0x0804, 0x52a8,
+	0x7084, 0x8008, 0xa092, 0x001e, 0x1a98, 0x7186, 0xae90, 0x0003,
+	0xa210, 0x683c, 0x2012, 0x0078, 0x7084, 0x8008, 0xa092, 0x000f,
+	0x1a38, 0x7186, 0xae90, 0x0003, 0x8003, 0xa210, 0x683c, 0x2012,
+	0x8210, 0x6840, 0x2012, 0x7088, 0xa10a, 0x0a04, 0x52c1, 0x718c,
+	0x7084, 0xa10a, 0x0a04, 0x52c1, 0x2071, 0x0000, 0x7018, 0xd084,
+	0x1904, 0x52c1, 0x2071, 0xb335, 0x7000, 0xa086, 0x0002, 0x1150,
+	0x080c, 0x558b, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080,
+	0x0804, 0x52c1, 0x080c, 0x55b5, 0x2071, 0x0000, 0x701b, 0x0001,
+	0x2091, 0x4080, 0x0804, 0x52c1, 0x0006, 0x684c, 0x0006, 0x6837,
+	0x0103, 0x20a9, 0x001c, 0xad80, 0x0011, 0x20a0, 0x2001, 0x0000,
+	0x40a4, 0x000e, 0xa084, 0x00ff, 0x684e, 0x000e, 0x684a, 0x6952,
+	0x0005, 0x2071, 0xb214, 0x7004, 0x0002, 0x5367, 0x5378, 0x5576,
+	0x5577, 0x5584, 0x558a, 0x5368, 0x5567, 0x54fd, 0x5553, 0x0005,
+	0x0126, 0x2091, 0x8000, 0x0e04, 0x5377, 0x2009, 0x000d, 0x7030,
+	0x200a, 0x2091, 0x4080, 0x7007, 0x0001, 0x700b, 0x0000, 0x012e,
+	0x2069, 0xb3ec, 0x683c, 0xa005, 0x03f8, 0x11f0, 0x0126, 0x2091,
+	0x8000, 0x2069, 0x0000, 0x6934, 0x2001, 0xb220, 0x2004, 0xa10a,
+	0x0170, 0x0e04, 0x539b, 0x2069, 0x0000, 0x6818, 0xd084, 0x1158,
+	0x2009, 0x8040, 0x6922, 0x681b, 0x0001, 0x2091, 0x4080, 0x2069,
+	0xb3ec, 0x683f, 0xffff, 0x012e, 0x2069, 0xb100, 0x6844, 0x6964,
+	0xa102, 0x2069, 0xb335, 0x688a, 0x6984, 0x701c, 0xa06d, 0x0120,
+	0x81ff, 0x0904, 0x53f1, 0x00a0, 0x81ff, 0x0904, 0x54b7, 0x2071,
+	0xb335, 0x7184, 0x7088, 0xa10a, 0x1258, 0x7190, 0x2071, 0xb3ec,
+	0x7038, 0xa005, 0x0128, 0x1b04, 0x54b7, 0x713a, 0x0804, 0x54b7,
+	0x2071, 0xb335, 0x718c, 0x0126, 0x2091, 0x8000, 0x7084, 0xa10a,
+	0x0a04, 0x54d2, 0x0e04, 0x5473, 0x2071, 0x0000, 0x7018, 0xd084,
+	0x1904, 0x5473, 0x2001, 0xffff, 0x2071, 0xb3ec, 0x703a, 0x2071,
+	0xb335, 0x7000, 0xa086, 0x0002, 0x1150, 0x080c, 0x558b, 0x2071,
+	0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0804, 0x5473, 0x080c,
+	0x55b5, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0804,
+	0x5473, 0x2071, 0xb335, 0x7000, 0xa005, 0x0904, 0x5499, 0x6934,
+	0xa186, 0x0103, 0x1904, 0x5476, 0x684c, 0xd0bc, 0x1904, 0x5499,
+	0x6948, 0x6844, 0xa105, 0x1904, 0x548e, 0x2009, 0x8020, 0x2071,
+	0xb335, 0x7000, 0x0002, 0x5499, 0x5459, 0x5431, 0x5443, 0x5410,
+	0x0136, 0x0146, 0x0156, 0x2099, 0xb176, 0x20a1, 0xb386, 0x20a9,
+	0x0004, 0x53a3, 0x015e, 0x014e, 0x013e, 0x2071, 0xb37d, 0xad80,
+	0x000f, 0x700e, 0x7013, 0x0002, 0x7007, 0x0002, 0x700b, 0x0000,
+	0x2e10, 0x080c, 0x1628, 0x2071, 0xb214, 0x7007, 0x0009, 0x0804,
+	0x54b7, 0x7084, 0x8008, 0xa092, 0x001e, 0x1a04, 0x54b7, 0xae90,
+	0x0003, 0xa210, 0x683c, 0x2012, 0x7186, 0x2071, 0xb214, 0x080c,
+	0x560c, 0x0804, 0x54b7, 0x7084, 0x8008, 0xa092, 0x000f, 0x1a04,
+	0x54b7, 0xae90, 0x0003, 0x8003, 0xa210, 0x683c, 0x2012, 0x8210,
+	0x6840, 0x2012, 0x7186, 0x2071, 0xb214, 0x080c, 0x560c, 0x0804,
+	0x54b7, 0x0126, 0x2091, 0x8000, 0x0e04, 0x5473, 0x2071, 0x0000,
+	0x7018, 0xd084, 0x1180, 0x7122, 0x683c, 0x7026, 0x6840, 0x702a,
+	0x701b, 0x0001, 0x2091, 0x4080, 0x012e, 0x2071, 0xb214, 0x080c,
+	0x560c, 0x0804, 0x54b7, 0x012e, 0x0804, 0x54b7, 0xa18c, 0x00ff,
+	0xa186, 0x0017, 0x0130, 0xa186, 0x001e, 0x0118, 0xa18e, 0x001f,
+	0x11c0, 0x684c, 0xd0cc, 0x01a8, 0x6850, 0xa084, 0x00ff, 0xa086,
+	0x0001, 0x1178, 0x2009, 0x8021, 0x0804, 0x5407, 0x6844, 0xa086,
+	0x0100, 0x1138, 0x6868, 0xa005, 0x1120, 0x2009, 0x8020, 0x0804,
+	0x5407, 0x2071, 0xb214, 0x080c, 0x561e, 0x01c8, 0x2071, 0xb214,
+	0x700f, 0x0001, 0x6934, 0xa184, 0x00ff, 0xa086, 0x0003, 0x1130,
+	0x810f, 0xa18c, 0x00ff, 0x8101, 0x0108, 0x710e, 0x7007, 0x0003,
+	0x080c, 0x5637, 0x7050, 0xa086, 0x0100, 0x0904, 0x5577, 0x0126,
+	0x2091, 0x8000, 0x2071, 0xb214, 0x7008, 0xa086, 0x0001, 0x1180,
+	0x0e04, 0x54d0, 0x2009, 0x000d, 0x7030, 0x200a, 0x2091, 0x4080,
+	0x700b, 0x0000, 0x7004, 0xa086, 0x0006, 0x1110, 0x7007, 0x0001,
+	0x012e, 0x0005, 0x2071, 0xb214, 0x080c, 0x561e, 0x0518, 0x2071,
+	0xb335, 0x7084, 0x700a, 0x20a9, 0x0020, 0x2099, 0xb336, 0x20a1,
+	0xb35d, 0x53a3, 0x7087, 0x0000, 0x2071, 0xb214, 0x2069, 0xb37d,
+	0x706c, 0x6826, 0x7070, 0x682a, 0x7074, 0x682e, 0x7078, 0x6832,
+	0x2d10, 0x080c, 0x1628, 0x7007, 0x0008, 0x2001, 0xffff, 0x2071,
+	0xb3ec, 0x703a, 0x012e, 0x0804, 0x54b7, 0x2069, 0xb37d, 0x6808,
+	0xa08e, 0x0000, 0x0904, 0x5552, 0xa08e, 0x0200, 0x0904, 0x5550,
+	0xa08e, 0x0100, 0x1904, 0x5552, 0x0126, 0x2091, 0x8000, 0x0e04,
+	0x554e, 0x2069, 0x0000, 0x6818, 0xd084, 0x15c0, 0x702c, 0x7130,
+	0x8108, 0xa102, 0x0230, 0xa00e, 0x7034, 0x706e, 0x7038, 0x7072,
+	0x0048, 0x706c, 0xa080, 0x0040, 0x706e, 0x1220, 0x7070, 0xa081,
+	0x0000, 0x7072, 0x7132, 0x6936, 0x700b, 0x0000, 0x2001, 0xb35a,
+	0x2004, 0xa005, 0x1190, 0x6934, 0x2069, 0xb335, 0x689c, 0x699e,
+	0x2069, 0xb3ec, 0xa102, 0x1118, 0x683c, 0xa005, 0x1368, 0x2001,
+	0xb35b, 0x200c, 0x810d, 0x693e, 0x0038, 0x2009, 0x8040, 0x6922,
+	0x681b, 0x0001, 0x2091, 0x4080, 0x7007, 0x0001, 0x012e, 0x0010,
+	0x7007, 0x0005, 0x0005, 0x2001, 0xb37f, 0x2004, 0xa08e, 0x0100,
+	0x1128, 0x7007, 0x0001, 0x080c, 0x560c, 0x0005, 0xa08e, 0x0000,
+	0x0de0, 0xa08e, 0x0200, 0x1dc8, 0x7007, 0x0005, 0x0005, 0x701c,
+	0xa06d, 0x0158, 0x080c, 0x561e, 0x0140, 0x7007, 0x0003, 0x080c,
+	0x5637, 0x7050, 0xa086, 0x0100, 0x0110, 0x0005, 0x0005, 0x7050,
+	0xa09e, 0x0100, 0x1118, 0x7007, 0x0004, 0x0030, 0xa086, 0x0200,
+	0x1110, 0x7007, 0x0005, 0x0005, 0x080c, 0x55da, 0x7006, 0x080c,
+	0x560c, 0x0005, 0x0005, 0x00e6, 0x0156, 0x2071, 0xb335, 0x7184,
+	0x81ff, 0x0500, 0xa006, 0x7086, 0xae80, 0x0003, 0x2071, 0x0000,
+	0x21a8, 0x2014, 0x7226, 0x8000, 0x0f04, 0x55af, 0x2014, 0x722a,
+	0x8000, 0x0f04, 0x55af, 0x2014, 0x722e, 0x8000, 0x0f04, 0x55af,
+	0x2014, 0x723a, 0x8000, 0x0f04, 0x55af, 0x2014, 0x723e, 0xa180,
+	0x8030, 0x7022, 0x015e, 0x00ee, 0x0005, 0x00e6, 0x0156, 0x2071,
+	0xb335, 0x7184, 0x81ff, 0x01d8, 0xa006, 0x7086, 0xae80, 0x0003,
+	0x2071, 0x0000, 0x21a8, 0x2014, 0x7226, 0x8000, 0x2014, 0x722a,
+	0x8000, 0x0f04, 0x55d1, 0x2014, 0x723a, 0x8000, 0x2014, 0x723e,
+	0x0018, 0x2001, 0x8020, 0x0010, 0x2001, 0x8042, 0x7022, 0x015e,
+	0x00ee, 0x0005, 0x702c, 0x7130, 0x8108, 0xa102, 0x0230, 0xa00e,
+	0x7034, 0x706e, 0x7038, 0x7072, 0x0048, 0x706c, 0xa080, 0x0040,
+	0x706e, 0x1220, 0x7070, 0xa081, 0x0000, 0x7072, 0x7132, 0x700c,
+	0x8001, 0x700e, 0x1180, 0x0126, 0x2091, 0x8000, 0x0e04, 0x5606,
+	0x2001, 0x000d, 0x2102, 0x2091, 0x4080, 0x2001, 0x0001, 0x700b,
+	0x0000, 0x012e, 0x0005, 0x2001, 0x0007, 0x0005, 0x2001, 0x0006,
+	0x700b, 0x0001, 0x012e, 0x0005, 0x701c, 0xa06d, 0x0170, 0x0126,
+	0x2091, 0x8000, 0x7010, 0x8001, 0x7012, 0x2d04, 0x701e, 0xa005,
+	0x1108, 0x701a, 0x012e, 0x080c, 0x15f4, 0x0005, 0x2019, 0x000d,
+	0x2304, 0x230c, 0xa10e, 0x0130, 0x2304, 0x230c, 0xa10e, 0x0110,
+	0xa006, 0x0060, 0x732c, 0x8319, 0x7130, 0xa102, 0x1118, 0x2300,
+	0xa005, 0x0020, 0x0210, 0xa302, 0x0008, 0x8002, 0x0005, 0x2d00,
+	0x7026, 0xa080, 0x000d, 0x7056, 0x7053, 0x0000, 0x0126, 0x2091,
+	0x8000, 0x2009, 0xb408, 0x2104, 0xc08d, 0x200a, 0x012e, 0x080c,
+	0x1640, 0x0005, 0x7088, 0xa08a, 0x0029, 0x1220, 0xa082, 0x001d,
+	0x0033, 0x0010, 0x080c, 0x14fa, 0x6027, 0x1e00, 0x0005, 0x573d,
+	0x56c0, 0x56d6, 0x5711, 0x5730, 0x5762, 0x5774, 0x56d6, 0x574e,
+	0x5664, 0x5692, 0x5663, 0x0005, 0x00d6, 0x2069, 0x0200, 0x6804,
+	0xa005, 0x1180, 0x6808, 0xa005, 0x1518, 0x708b, 0x0028, 0x2069,
+	0xb3be, 0x2d04, 0x7002, 0x080c, 0x59d7, 0x6028, 0xa085, 0x0600,
+	0x602a, 0x00b0, 0x708b, 0x0028, 0x2069, 0xb3be, 0x2d04, 0x7002,
+	0x6028, 0xa085, 0x0600, 0x602a, 0x00e6, 0x0036, 0x0046, 0x0056,
+	0x2071, 0xb419, 0x080c, 0x1d48, 0x005e, 0x004e, 0x003e, 0x00ee,
+	0x00de, 0x0005, 0x00d6, 0x2069, 0x0200, 0x6804, 0xa005, 0x1180,
+	0x6808, 0xa005, 0x1518, 0x708b, 0x0028, 0x2069, 0xb3be, 0x2d04,
+	0x7002, 0x080c, 0x5a64, 0x6028, 0xa085, 0x0600, 0x602a, 0x00b0,
+	0x708b, 0x0028, 0x2069, 0xb3be, 0x2d04, 0x7002, 0x6028, 0xa085,
+	0x0600, 0x602a, 0x00e6, 0x0036, 0x0046, 0x0056, 0x2071, 0xb419,
+	0x080c, 0x1d48, 0x005e, 0x004e, 0x003e, 0x00ee, 0x00de, 0x0005,
+	0x6803, 0x0090, 0x6124, 0xd1e4, 0x1180, 0x080c, 0x57df, 0xd1d4,
+	0x1150, 0xd1dc, 0x1128, 0xd1cc, 0x0140, 0x708b, 0x0020, 0x0028,
+	0x708b, 0x001d, 0x0010, 0x708b, 0x001f, 0x0005, 0x6803, 0x0088,
+	0x6124, 0xd1cc, 0x1580, 0xd1dc, 0x1558, 0xd1e4, 0x1530, 0xa184,
+	0x1e00, 0x1570, 0x60e3, 0x0001, 0x600c, 0xc0b4, 0x600e, 0x080c,
+	0x5905, 0x0156, 0x6803, 0x0100, 0x20a9, 0x0014, 0x6804, 0xd0dc,
+	0x1118, 0x1f04, 0x56ee, 0x0048, 0x20a9, 0x0014, 0x6803, 0x0080,
+	0x6804, 0xd0d4, 0x1130, 0x1f04, 0x56f8, 0x080c, 0x5926, 0x015e,
+	0x0078, 0x015e, 0x708b, 0x0028, 0x0058, 0x708b, 0x001e, 0x0040,
+	0x708b, 0x001d, 0x0028, 0x708b, 0x0020, 0x0010, 0x708b, 0x001f,
+	0x0005, 0x60e3, 0x0001, 0x600c, 0xc0b4, 0x600e, 0x080c, 0x5905,
+	0x6803, 0x0080, 0x6124, 0xd1d4, 0x1180, 0xd1dc, 0x1158, 0xd1e4,
+	0x1130, 0xa184, 0x1e00, 0x1158, 0x708b, 0x0028, 0x0040, 0x708b,
+	0x001e, 0x0028, 0x708b, 0x001d, 0x0010, 0x708b, 0x001f, 0x0005,
+	0x6803, 0x00a0, 0x6124, 0xd1dc, 0x1128, 0xd1e4, 0x0128, 0x708b,
+	0x001e, 0x0010, 0x708b, 0x001d, 0x0005, 0x080c, 0x5809, 0x6124,
+	0xd1dc, 0x1158, 0x080c, 0x57df, 0xd1d4, 0x1128, 0xd1e4, 0x0128,
+	0x708b, 0x001e, 0x0010, 0x708b, 0x001f, 0x0005, 0x6803, 0x00a0,
+	0x6124, 0xd1d4, 0x1160, 0xd1cc, 0x1150, 0xd1dc, 0x1128, 0xd1e4,
+	0x0140, 0x708b, 0x001e, 0x0028, 0x708b, 0x001d, 0x0010, 0x708b,
+	0x0021, 0x0005, 0x080c, 0x5809, 0x6124, 0xd1d4, 0x1150, 0xd1dc,
+	0x1128, 0xd1e4, 0x0140, 0x708b, 0x001e, 0x0028, 0x708b, 0x001d,
+	0x0010, 0x708b, 0x001f, 0x0005, 0x6803, 0x0090, 0x6124, 0xd1d4,
+	0x1178, 0xd1cc, 0x1150, 0xd1dc, 0x1128, 0xd1e4, 0x0158, 0x708b,
+	0x001e, 0x0040, 0x708b, 0x001d, 0x0028, 0x708b, 0x0020, 0x0010,
+	0x708b, 0x001f, 0x0005, 0x0016, 0x00c6, 0x00d6, 0x00e6, 0x0126,
+	0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0xb100, 0x2091, 0x8000,
+	0x080c, 0x58d5, 0x11e8, 0x2001, 0xb10c, 0x200c, 0xd1b4, 0x01c0,
+	0xc1b4, 0x2102, 0x6027, 0x0200, 0xe000, 0xe000, 0x6024, 0xd0cc,
+	0x0158, 0x6803, 0x00a0, 0x2001, 0xb39f, 0x2003, 0x0001, 0x2001,
+	0xb100, 0x2003, 0x0001, 0x0428, 0x6028, 0xc0cd, 0x602a, 0x0408,
+	0x080c, 0x58f1, 0x0150, 0x080c, 0x58e7, 0x1138, 0x2001, 0x0001,
+	0x080c, 0x269e, 0x080c, 0x58ac, 0x00a0, 0x080c, 0x5806, 0x0178,
+	0x2001, 0x0001, 0x080c, 0x269e, 0x7088, 0xa086, 0x001e, 0x0120,
+	0x7088, 0xa086, 0x0022, 0x1118, 0x708b, 0x0025, 0x0010, 0x708b,
+	0x0021, 0x012e, 0x00ee, 0x00de, 0x00ce, 0x001e, 0x0005, 0x0016,
+	0x0026, 0x2009, 0x0064, 0x2011, 0x57ea, 0x080c, 0x6736, 0x002e,
+	0x001e, 0x0005, 0x00e6, 0x00f6, 0x0016, 0x080c, 0x7a8c, 0x2071,
+	0xb100, 0x080c, 0x578b, 0x001e, 0x00fe, 0x00ee, 0x0005, 0x2001,
+	0xb100, 0x2004, 0xa086, 0x0004, 0x0140, 0x2001, 0xb39e, 0x2003,
+	0xaaaa, 0x2001, 0xb39f, 0x2003, 0x0000, 0x0005, 0x6020, 0xd09c,
+	0x0005, 0x6803, 0x00c0, 0x0156, 0x20a9, 0x002d, 0x1d04, 0x580e,
+	0x2091, 0x6000, 0x1f04, 0x580e, 0x015e, 0x0005, 0x00c6, 0x00d6,
+	0x00e6, 0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0xb100, 0x2001,
+	0xb39f, 0x200c, 0xa186, 0x0000, 0x0158, 0xa186, 0x0001, 0x0158,
+	0xa186, 0x0002, 0x0158, 0xa186, 0x0003, 0x0158, 0x0804, 0x589a,
+	0x708b, 0x0022, 0x0040, 0x708b, 0x0021, 0x0028, 0x708b, 0x0023,
+	0x0020, 0x708b, 0x0024, 0x6043, 0x0000, 0x60e3, 0x0000, 0x6887,
+	0x0001, 0x2001, 0x0001, 0x080c, 0x274b, 0x0026, 0x2011, 0x0003,
+	0x080c, 0x7d52, 0x2011, 0x0002, 0x080c, 0x7d5c, 0x080c, 0x7c41,
+	0x080c, 0x67b6, 0x0036, 0x2019, 0x0000, 0x080c, 0x7cc4, 0x003e,
+	0x002e, 0x7000, 0xa08e, 0x0004, 0x0118, 0x602b, 0x0028, 0x0010,
+	0x602b, 0x0020, 0x0156, 0x0126, 0x2091, 0x8000, 0x20a9, 0x0005,
+	0x6024, 0xd0ac, 0x0118, 0x012e, 0x015e, 0x04d0, 0x6800, 0xa084,
+	0x00a0, 0xc0bd, 0x6802, 0x6904, 0xd1d4, 0x1130, 0x6803, 0x0100,
+	0x1f04, 0x5868, 0x080c, 0x5926, 0x012e, 0x015e, 0x080c, 0x58e7,
+	0x01a8, 0x6044, 0xa005, 0x0168, 0x6050, 0x0006, 0xa085, 0x0020,
+	0x6052, 0x080c, 0x5926, 0xa006, 0x8001, 0x1df0, 0x000e, 0x6052,
+	0x0028, 0x6804, 0xd0d4, 0x1110, 0x080c, 0x5926, 0x2001, 0xb39f,
+	0x2003, 0x0004, 0x080c, 0x564a, 0x080c, 0x58e7, 0x0148, 0x6804,
+	0xd0d4, 0x1130, 0xd0dc, 0x1100, 0x2001, 0xb39f, 0x2003, 0x0000,
+	0x00ee, 0x00de, 0x00ce, 0x0005, 0x00c6, 0x00d6, 0x00e6, 0x2061,
+	0x0100, 0x2069, 0x0140, 0x2071, 0xb100, 0x2001, 0xb39e, 0x2003,
+	0x0000, 0x2001, 0xb38f, 0x2003, 0x0000, 0x708b, 0x0000, 0x60e3,
+	0x0000, 0x6887, 0x0000, 0x2001, 0x0000, 0x080c, 0x274b, 0x6803,
+	0x0000, 0x6043, 0x0090, 0x6043, 0x0010, 0x6027, 0xffff, 0x602b,
+	0x182f, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x0006, 0x2001, 0xb39e,
+	0x2004, 0xa086, 0xaaaa, 0x000e, 0x0005, 0x0006, 0x2001, 0xb172,
+	0x2004, 0xa084, 0x0030, 0xa086, 0x0000, 0x000e, 0x0005, 0x0006,
+	0x2001, 0xb172, 0x2004, 0xa084, 0x0030, 0xa086, 0x0030, 0x000e,
+	0x0005, 0x0006, 0x2001, 0xb172, 0x2004, 0xa084, 0x0030, 0xa086,
+	0x0010, 0x000e, 0x0005, 0x0006, 0x2001, 0xb172, 0x2004, 0xa084,
+	0x0030, 0xa086, 0x0020, 0x000e, 0x0005, 0x2001, 0xb10c, 0x2004,
+	0xd0a4, 0x0170, 0x080c, 0x276b, 0x0036, 0x0016, 0x2009, 0x0000,
+	0x2019, 0x0028, 0x080c, 0x2b46, 0x001e, 0x003e, 0xa006, 0x0009,
+	0x0005, 0x00e6, 0x2071, 0xb10c, 0x2e04, 0x0118, 0xa085, 0x0010,
+	0x0010, 0xa084, 0xffef, 0x2072, 0x00ee, 0x0005, 0x6050, 0x0006,
+	0x60f0, 0x0006, 0x60ec, 0x0006, 0x600c, 0x0006, 0x6004, 0x0006,
+	0x6028, 0x0006, 0x602f, 0x0100, 0x602f, 0x0000, 0x602f, 0x0040,
+	0x602f, 0x0000, 0x000e, 0x602a, 0x000e, 0x6006, 0x000e, 0x600e,
+	0x000e, 0x60ee, 0x000e, 0x60f2, 0x60e3, 0x0000, 0x6887, 0x0001,
+	0x2001, 0x0001, 0x080c, 0x274b, 0x6800, 0xa084, 0x00a0, 0xc0bd,
+	0x6802, 0x6803, 0x00a0, 0x000e, 0x6052, 0x6050, 0x0005, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100,
+	0x2069, 0x0140, 0x2071, 0xb100, 0x6020, 0xa084, 0x0080, 0x0138,
+	0x2001, 0xb10c, 0x200c, 0xc1bd, 0x2102, 0x0804, 0x59cf, 0x2001,
+	0xb10c, 0x200c, 0xc1bc, 0x2102, 0x6028, 0xa084, 0xe1ff, 0x602a,
+	0x6027, 0x0200, 0x6803, 0x0090, 0x20a9, 0x0384, 0x6024, 0xd0cc,
+	0x1518, 0x1d04, 0x597e, 0x2091, 0x6000, 0x1f04, 0x597e, 0x2011,
+	0x0003, 0x080c, 0x7d52, 0x2011, 0x0002, 0x080c, 0x7d5c, 0x080c,
+	0x7c41, 0x080c, 0x67b6, 0x2019, 0x0000, 0x080c, 0x7cc4, 0x6803,
+	0x00a0, 0x2001, 0xb39f, 0x2003, 0x0001, 0x2001, 0xb100, 0x2003,
+	0x0001, 0xa085, 0x0001, 0x0458, 0x86ff, 0x1110, 0x080c, 0x1daa,
+	0x60e3, 0x0000, 0x2001, 0xb38f, 0x2004, 0x080c, 0x274b, 0x60e2,
+	0x6803, 0x0080, 0x20a9, 0x0384, 0x6027, 0x1e00, 0x2009, 0x1e00,
+	0xe000, 0x6024, 0xa10c, 0x0138, 0x1d04, 0x59b4, 0x2091, 0x6000,
+	0x1f04, 0x59b4, 0x0820, 0x6028, 0xa085, 0x1e00, 0x602a, 0x70a0,
+	0xa005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886, 0xa006, 0x00ee,
+	0x00de, 0x00ce, 0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100,
+	0x2071, 0xb100, 0x2069, 0x0140, 0x6020, 0xa084, 0x00c0, 0x0120,
+	0x6884, 0xa005, 0x1904, 0x5a2b, 0x6803, 0x0088, 0x60e3, 0x0000,
+	0x6887, 0x0000, 0x2001, 0x0000, 0x080c, 0x274b, 0x2069, 0x0200,
+	0x6804, 0xa005, 0x1118, 0x6808, 0xa005, 0x01c0, 0x6028, 0xa084,
+	0xfbff, 0x602a, 0x6027, 0x0400, 0x2069, 0xb3be, 0x7000, 0x206a,
+	0x708b, 0x0026, 0x7003, 0x0001, 0x20a9, 0x0002, 0x1d04, 0x5a0e,
+	0x2091, 0x6000, 0x1f04, 0x5a0e, 0x0804, 0x5a5c, 0x2069, 0x0140,
+	0x20a9, 0x0384, 0x6027, 0x1e00, 0x2009, 0x1e00, 0xe000, 0x6024,
+	0xa10c, 0x0530, 0xa084, 0x1a00, 0x1518, 0x1d04, 0x5a1a, 0x2091,
+	0x6000, 0x1f04, 0x5a1a, 0x2011, 0x0003, 0x080c, 0x7d52, 0x2011,
+	0x0002, 0x080c, 0x7d5c, 0x080c, 0x7c41, 0x080c, 0x67b6, 0x2019,
+	0x0000, 0x080c, 0x7cc4, 0x6803, 0x00a0, 0x2001, 0xb39f, 0x2003,
+	0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0xa085, 0x0001, 0x00a0,
+	0x6803, 0x0080, 0x2069, 0x0140, 0x60e3, 0x0000, 0x70a0, 0xa005,
+	0x1118, 0x6887, 0x0001, 0x0008, 0x6886, 0x2001, 0xb38f, 0x2004,
+	0x080c, 0x274b, 0x60e2, 0xa006, 0x00ee, 0x00de, 0x00ce, 0x003e,
+	0x002e, 0x001e, 0x015e, 0x0005, 0x0156, 0x0016, 0x0026, 0x0036,
+	0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2071, 0xb100, 0x6020,
+	0xa084, 0x00c0, 0x01f0, 0x2011, 0x0003, 0x080c, 0x7d52, 0x2011,
+	0x0002, 0x080c, 0x7d5c, 0x080c, 0x7c41, 0x080c, 0x67b6, 0x2019,
+	0x0000, 0x080c, 0x7cc4, 0x2069, 0x0140, 0x6803, 0x00a0, 0x2001,
+	0xb39f, 0x2003, 0x0001, 0x2001, 0xb100, 0x2003, 0x0001, 0x0804,
+	0x5afc, 0x2001, 0xb10c, 0x200c, 0xd1b4, 0x1150, 0xc1b5, 0x2102,
+	0x080c, 0x57df, 0x2069, 0x0140, 0x6803, 0x0080, 0x60e3, 0x0000,
+	0x2069, 0x0200, 0x6804, 0xa005, 0x1118, 0x6808, 0xa005, 0x01b8,
+	0x6028, 0xa084, 0xfdff, 0x602a, 0x6027, 0x0200, 0x2069, 0xb3be,
+	0x7000, 0x206a, 0x708b, 0x0027, 0x7003, 0x0001, 0x20a9, 0x0002,
+	0x1d04, 0x5ab8, 0x2091, 0x6000, 0x1f04, 0x5ab8, 0x04e8, 0x6027,
+	0x1e00, 0x2009, 0x1e00, 0xe000, 0x6024, 0xa10c, 0x01c8, 0xa084,
+	0x1c00, 0x11b0, 0x1d04, 0x5abf, 0x0006, 0x0016, 0x00c6, 0x00d6,
+	0x00e6, 0x080c, 0x66b4, 0x00ee, 0x00de, 0x00ce, 0x001e, 0x000e,
+	0x00e6, 0x2071, 0xb3ec, 0x7018, 0x00ee, 0xa005, 0x1d00, 0x01e0,
+	0x0026, 0x2011, 0x57ea, 0x080c, 0x6742, 0x002e, 0x2069, 0x0140,
+	0x60e3, 0x0000, 0x70a0, 0xa005, 0x1118, 0x6887, 0x0001, 0x0008,
+	0x6886, 0x2001, 0xb38f, 0x2004, 0x080c, 0x274b, 0x60e2, 0x2001,
+	0xb10c, 0x200c, 0xc1b4, 0x2102, 0x00ee, 0x00de, 0x00ce, 0x003e,
+	0x002e, 0x001e, 0x015e, 0x0005, 0x0156, 0x0016, 0x0026, 0x0036,
+	0x0046, 0x00c6, 0x00e6, 0x2061, 0x0100, 0x2071, 0xb100, 0x7130,
+	0xd184, 0x1180, 0x2011, 0xb153, 0x2214, 0xd2ec, 0x0138, 0xc18d,
+	0x7132, 0x2011, 0xb153, 0x2214, 0xd2ac, 0x1120, 0x7030, 0xd08c,
+	0x0904, 0x5b69, 0x7130, 0xc185, 0x7132, 0x2011, 0xb153, 0x220c,
+	0xd1a4, 0x0530, 0x0016, 0x2009, 0x0001, 0x2011, 0x0100, 0x080c,
+	0x688d, 0x2019, 0x000e, 0x080c, 0xac2b, 0x0156, 0x20a9, 0x007f,
+	0x2009, 0x0000, 0xa186, 0x007e, 0x0170, 0xa186, 0x0080, 0x0158,
+	0x080c, 0x4e21, 0x1140, 0x8127, 0xa006, 0x0016, 0x2009, 0x000e,
+	0x080c, 0xacae, 0x001e, 0x8108, 0x1f04, 0x5b3a, 0x015e, 0x001e,
+	0xd1ac, 0x1148, 0x0016, 0x2009, 0x0000, 0x2019, 0x0004, 0x080c,
+	0x2b46, 0x001e, 0x0070, 0x0156, 0x20a9, 0x007f, 0x2009, 0x0000,
+	0x080c, 0x4e21, 0x1110, 0x080c, 0x4a80, 0x8108, 0x1f04, 0x5b60,
+	0x015e, 0x2011, 0x0003, 0x080c, 0x7d52, 0x2011, 0x0002, 0x080c,
+	0x7d5c, 0x080c, 0x7c41, 0x080c, 0x67b6, 0x0036, 0x2019, 0x0000,
+	0x080c, 0x7cc4, 0x003e, 0x60e3, 0x0000, 0x2001, 0xb100, 0x2003,
+	0x0001, 0x080c, 0x5816, 0x00ee, 0x00ce, 0x004e, 0x003e, 0x002e,
+	0x001e, 0x015e, 0x0005, 0x2071, 0xb1e2, 0x7003, 0x0000, 0x7007,
+	0x0000, 0x700f, 0x0000, 0x702b, 0x0001, 0x704f, 0x0000, 0x7053,
+	0x0001, 0x705f, 0x0020, 0x7063, 0x0040, 0x7083, 0x0000, 0x708b,
+	0x0000, 0x708f, 0x0001, 0x70bf, 0x0000, 0x0005, 0x00e6, 0x2071,
+	0xb1e2, 0x6848, 0xa005, 0x1130, 0x7028, 0xc085, 0x702a, 0xa085,
+	0x0001, 0x0428, 0x6a50, 0x7236, 0x6b54, 0x733a, 0x6858, 0x703e,
+	0x707a, 0x685c, 0x7042, 0x707e, 0x6848, 0x702e, 0x6840, 0x7032,
+	0x2009, 0x000c, 0x200a, 0x8007, 0x8006, 0x8006, 0xa08c, 0x003f,
+	0xa084, 0xffc0, 0xa210, 0x2100, 0xa319, 0x7272, 0x7376, 0x7028,
+	0xc084, 0x702a, 0x7007, 0x0001, 0x700f, 0x0000, 0xa006, 0x00ee,
+	0x0005, 0x2b78, 0x2071, 0xb1e2, 0x7004, 0x0043, 0x700c, 0x0002,
+	0x5be5, 0x5bdc, 0x5bdc, 0x5bdc, 0x5bdc, 0x0005, 0x5c3b, 0x5c3c,
+	0x5c6e, 0x5c6f, 0x5c39, 0x5cbd, 0x5cc2, 0x5cf3, 0x5cf4, 0x5d0f,
+	0x5d10, 0x5d11, 0x5d12, 0x5d13, 0x5d14, 0x5dca, 0x5df1, 0x700c,
+	0x0002, 0x5bfe, 0x5c39, 0x5c39, 0x5c3a, 0x5c3a, 0x7830, 0x7930,
+	0xa106, 0x0120, 0x7830, 0x7930, 0xa106, 0x1510, 0x7030, 0xa10a,
+	0x01f8, 0x1210, 0x712c, 0xa10a, 0xa18a, 0x0002, 0x12d0, 0x080c,
+	0x15c4, 0x01b0, 0x2d00, 0x705a, 0x7063, 0x0040, 0x2001, 0x0003,
+	0x7057, 0x0000, 0x0126, 0x0006, 0x2091, 0x8000, 0x2009, 0xb408,
+	0x2104, 0xc085, 0x200a, 0x000e, 0x700e, 0x012e, 0x080c, 0x1640,
+	0x0005, 0x080c, 0x15c4, 0x0de0, 0x2d00, 0x705a, 0x080c, 0x15c4,
+	0x1108, 0x0c10, 0x2d00, 0x7086, 0x7063, 0x0080, 0x2001, 0x0004,
+	0x08f8, 0x0005, 0x0005, 0x0005, 0x700c, 0x0002, 0x5c43, 0x5c46,
+	0x5c54, 0x5c6d, 0x5c6d, 0x080c, 0x5bf7, 0x0005, 0x0126, 0x8001,
+	0x700e, 0x7058, 0x0006, 0x080c, 0x611c, 0x0120, 0x2091, 0x8000,
+	0x080c, 0x5bf7, 0x00de, 0x0048, 0x0126, 0x8001, 0x700e, 0x080c,
+	0x611c, 0x7058, 0x2068, 0x7084, 0x705a, 0x6803, 0x0000, 0x6807,
+	0x0000, 0x6834, 0xa084, 0x00ff, 0xa08a, 0x003a, 0x1218, 0x00db,
+	0x012e, 0x0005, 0x012e, 0x080c, 0x5d15, 0x0005, 0x0005, 0x0005,
+	0x00e6, 0x2071, 0xb1e2, 0x700c, 0x0002, 0x5c7a, 0x5c7a, 0x5c7a,
+	0x5c7c, 0x5c7f, 0x00ee, 0x0005, 0x700f, 0x0001, 0x0010, 0x700f,
+	0x0002, 0x00ee, 0x0005, 0x5d15, 0x5d15, 0x5d31, 0x5d15, 0x5eae,
+	0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x5d31, 0x5ef0, 0x5f33,
+	0x5f7c, 0x5f90, 0x5d15, 0x5d15, 0x5d4d, 0x5d31, 0x5d15, 0x5d15,
+	0x5da7, 0x6039, 0x6054, 0x5d15, 0x5d4d, 0x5d15, 0x5d15, 0x5d15,
+	0x5d15, 0x5d9d, 0x6054, 0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x5d15,
+	0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x5d61, 0x5d15, 0x5d15, 0x5d15,
+	0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x613a, 0x5d15,
+	0x5d15, 0x5d15, 0x5d15, 0x5d15, 0x5d76, 0x7020, 0x2068, 0x080c,
+	0x15f4, 0x0005, 0x700c, 0x0002, 0x5cc9, 0x5ccc, 0x5cda, 0x5cf2,
+	0x5cf2, 0x080c, 0x5bf7, 0x0005, 0x0126, 0x8001, 0x700e, 0x7058,
+	0x0006, 0x080c, 0x611c, 0x0120, 0x2091, 0x8000, 0x080c, 0x5bf7,
+	0x00de, 0x0048, 0x0126, 0x8001, 0x700e, 0x080c, 0x611c, 0x7058,
+	0x2068, 0x7084, 0x705a, 0x6803, 0x0000, 0x6807, 0x0000, 0x6834,
+	0xa084, 0x00ff, 0xa08a, 0x001a, 0x1218, 0x003b, 0x012e, 0x0005,
+	0x012e, 0x0419, 0x0005, 0x0005, 0x0005, 0x5d15, 0x5d31, 0x5e9a,
+	0x5d15, 0x5d31, 0x5d15, 0x5d31, 0x5d31, 0x5d15, 0x5d31, 0x5e9a,
+	0x5d31, 0x5d31, 0x5d31, 0x5d31, 0x5d31, 0x5d15, 0x5d31, 0x5e9a,
+	0x5d15, 0x5d15, 0x5d31, 0x5d15, 0x5d15, 0x5d15, 0x5d31, 0x0005,
+	0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x7007, 0x0001, 0x6838,
+	0xa084, 0x00ff, 0xc0d5, 0x683a, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x5271, 0x012e, 0x0005, 0x7007, 0x0001, 0x6838, 0xa084, 0x00ff,
+	0xc0e5, 0x683a, 0x0126, 0x2091, 0x8000, 0x080c, 0x5271, 0x012e,
+	0x0005, 0x7007, 0x0001, 0x6838, 0xa084, 0x00ff, 0xc0ed, 0x683a,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x5271, 0x012e, 0x0005, 0x7007,
+	0x0001, 0x6838, 0xa084, 0x00ff, 0xc0dd, 0x683a, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x5271, 0x012e, 0x0005, 0x6834, 0x8007, 0xa084,
+	0x00ff, 0x0988, 0x8001, 0x1120, 0x7007, 0x0001, 0x0804, 0x5e5a,
+	0x7007, 0x0006, 0x7012, 0x2d00, 0x7016, 0x701a, 0x704b, 0x5e5a,
+	0x0005, 0x6834, 0x8007, 0xa084, 0x00ff, 0x0904, 0x5d23, 0x8001,
+	0x1120, 0x7007, 0x0001, 0x0804, 0x5e77, 0x7007, 0x0006, 0x7012,
+	0x2d00, 0x7016, 0x701a, 0x704b, 0x5e77, 0x0005, 0x6834, 0x8007,
+	0xa084, 0x00ff, 0xa086, 0x0001, 0x1904, 0x5d23, 0x7007, 0x0001,
+	0x2009, 0xb130, 0x210c, 0x81ff, 0x11a8, 0x6838, 0xa084, 0x00ff,
+	0x683a, 0x6853, 0x0000, 0x080c, 0x4bf7, 0x1108, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x6837, 0x0139, 0x684a, 0x6952, 0x080c, 0x5271,
+	0x012e, 0x0ca0, 0x2001, 0x0028, 0x0c90, 0x684c, 0xa084, 0x00c0,
+	0xa086, 0x00c0, 0x1120, 0x7007, 0x0001, 0x0804, 0x606c, 0x2d00,
+	0x7016, 0x701a, 0x20a9, 0x0004, 0xa080, 0x0024, 0x2098, 0x20a1,
+	0xb20d, 0x53a3, 0x6858, 0x7012, 0xa082, 0x0401, 0x1a04, 0x5d3f,
+	0x6a84, 0xa28a, 0x0002, 0x1a04, 0x5d3f, 0x82ff, 0x1138, 0x6888,
+	0x698c, 0xa105, 0x0118, 0x2001, 0x5e2d, 0x0018, 0xa280, 0x5e23,
+	0x2005, 0x70c6, 0x7010, 0xa015, 0x0904, 0x5e0f, 0x080c, 0x15c4,
+	0x1118, 0x7007, 0x000f, 0x0005, 0x2d00, 0x7022, 0x70c4, 0x2060,
+	0x2c05, 0x6836, 0xe004, 0xad00, 0x7096, 0xe008, 0xa20a, 0x1210,
+	0xa00e, 0x2200, 0x7112, 0xe20c, 0x8003, 0x800b, 0xa296, 0x0004,
+	0x0108, 0xa108, 0x719a, 0x810b, 0x719e, 0xae90, 0x0022, 0x080c,
+	0x1628, 0x7090, 0xa08e, 0x0100, 0x0170, 0xa086, 0x0200, 0x0118,
+	0x7007, 0x0010, 0x0005, 0x7020, 0x2068, 0x080c, 0x15f4, 0x7014,
+	0x2068, 0x0804, 0x5d3f, 0x7020, 0x2068, 0x7018, 0x6802, 0x6807,
+	0x0000, 0x2d08, 0x2068, 0x6906, 0x711a, 0x0804, 0x5dca, 0x7014,
+	0x2068, 0x7007, 0x0001, 0x6884, 0xa005, 0x1128, 0x6888, 0x698c,
+	0xa105, 0x0108, 0x00b1, 0x6834, 0xa084, 0x00ff, 0xa086, 0x001e,
+	0x0904, 0x606c, 0x04b8, 0x5e25, 0x5e29, 0x0002, 0x0011, 0x0007,
+	0x0004, 0x000a, 0x000f, 0x0005, 0x0006, 0x000a, 0x0011, 0x0005,
+	0x0004, 0x00f6, 0x00e6, 0x00c6, 0x0076, 0x0066, 0x6f88, 0x6e8c,
+	0x6804, 0x2060, 0xacf0, 0x0021, 0xacf8, 0x0027, 0x2009, 0x0005,
+	0x700c, 0x7816, 0x7008, 0x7812, 0x7004, 0x7806, 0x7000, 0x7802,
+	0x7e0e, 0x7f0a, 0x8109, 0x0128, 0xaef2, 0x0004, 0xaffa, 0x0006,
+	0x0c78, 0x6004, 0xa065, 0x1d30, 0x006e, 0x007e, 0x00ce, 0x00ee,
+	0x00fe, 0x0005, 0x2009, 0xb130, 0x210c, 0x81ff, 0x1198, 0x6838,
+	0xa084, 0x00ff, 0x683a, 0x080c, 0x4ad9, 0x1108, 0x0005, 0x080c,
+	0x5344, 0x0126, 0x2091, 0x8000, 0x080c, 0x9ada, 0x080c, 0x5271,
+	0x012e, 0x0ca0, 0x2001, 0x0028, 0x2009, 0x0000, 0x0c80, 0x2009,
+	0xb130, 0x210c, 0x81ff, 0x11b0, 0x6858, 0xa005, 0x01c0, 0x6838,
+	0xa084, 0x00ff, 0x683a, 0x6853, 0x0000, 0x080c, 0x4b9b, 0x1108,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x684a, 0x6952, 0x080c, 0x5271,
+	0x012e, 0x0cb0, 0x2001, 0x0028, 0x2009, 0x0000, 0x0c90, 0x2001,
+	0x0000, 0x0c78, 0x7018, 0x6802, 0x2d08, 0x2068, 0x6906, 0x711a,
+	0x7010, 0x8001, 0x7012, 0x0118, 0x7007, 0x0006, 0x0030, 0x7014,
+	0x2068, 0x7007, 0x0001, 0x7048, 0x080f, 0x0005, 0x7007, 0x0001,
+	0x6944, 0x810f, 0xa18c, 0x00ff, 0x6848, 0xa084, 0x00ff, 0x20a9,
+	0x0001, 0xa096, 0x0001, 0x01b0, 0x2009, 0x0000, 0x20a9, 0x00ff,
+	0xa096, 0x0002, 0x0178, 0xa005, 0x11f0, 0x6944, 0x810f, 0xa18c,
+	0x00ff, 0x080c, 0x4e21, 0x11b8, 0x0066, 0x6e50, 0x080c, 0x4f1c,
+	0x006e, 0x0088, 0x0046, 0x2011, 0xb10c, 0x2224, 0xc484, 0x2412,
+	0x004e, 0x00c6, 0x080c, 0x4e21, 0x1110, 0x080c, 0x507b, 0x8108,
+	0x1f04, 0x5eda, 0x00ce, 0x684c, 0xd084, 0x1118, 0x080c, 0x15f4,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x080c, 0x5271, 0x012e, 0x0005,
+	0x0126, 0x2091, 0x8000, 0x7007, 0x0001, 0x2001, 0xb153, 0x2004,
+	0xd0a4, 0x0580, 0x2061, 0xb464, 0x6100, 0xd184, 0x0178, 0x6858,
+	0xa084, 0x00ff, 0x1550, 0x6000, 0xd084, 0x0520, 0x6004, 0xa005,
+	0x1538, 0x6003, 0x0000, 0x600b, 0x0000, 0x00c8, 0x2011, 0x0001,
+	0x6860, 0xa005, 0x1110, 0x2001, 0x001e, 0x8000, 0x6016, 0x6858,
+	0xa084, 0x00ff, 0x0178, 0x6006, 0x6858, 0x8007, 0xa084, 0x00ff,
+	0x0148, 0x600a, 0x6858, 0x8000, 0x1108, 0xc28d, 0x6202, 0x012e,
+	0x0804, 0x610b, 0x012e, 0x0804, 0x6105, 0x012e, 0x0804, 0x60ff,
+	0x012e, 0x0804, 0x6102, 0x0126, 0x2091, 0x8000, 0x7007, 0x0001,
+	0x2001, 0xb153, 0x2004, 0xd0a4, 0x05e0, 0x2061, 0xb464, 0x6000,
+	0xd084, 0x05b8, 0x6204, 0x6308, 0xd08c, 0x1530, 0x6c48, 0xa484,
+	0x0003, 0x0170, 0x6958, 0xa18c, 0x00ff, 0x8001, 0x1120, 0x2100,
+	0xa210, 0x0620, 0x0028, 0x8001, 0x1508, 0x2100, 0xa212, 0x02f0,
+	0xa484, 0x000c, 0x0188, 0x6958, 0x810f, 0xa18c, 0x00ff, 0xa082,
+	0x0004, 0x1120, 0x2100, 0xa318, 0x0288, 0x0030, 0xa082, 0x0004,
+	0x1168, 0x2100, 0xa31a, 0x0250, 0x6860, 0xa005, 0x0110, 0x8000,
+	0x6016, 0x6206, 0x630a, 0x012e, 0x0804, 0x610b, 0x012e, 0x0804,
+	0x6108, 0x012e, 0x0804, 0x6105, 0x0126, 0x2091, 0x8000, 0x7007,
+	0x0001, 0x2061, 0xb464, 0x6300, 0xd38c, 0x1120, 0x6308, 0x8318,
+	0x0220, 0x630a, 0x012e, 0x0804, 0x6119, 0x012e, 0x0804, 0x6108,
+	0x0126, 0x00c6, 0x2091, 0x8000, 0x7007, 0x0001, 0x684c, 0xd0ac,
+	0x0148, 0x00c6, 0x2061, 0xb464, 0x6000, 0xa084, 0xfcff, 0x6002,
+	0x00ce, 0x0448, 0x6858, 0xa005, 0x05d0, 0x685c, 0xa065, 0x0598,
+	0x2001, 0xb130, 0x2004, 0xa005, 0x0118, 0x080c, 0x9a2b, 0x0068,
+	0x6013, 0x0400, 0x6057, 0x0000, 0x694c, 0xd1a4, 0x0110, 0x6950,
+	0x6156, 0x2009, 0x0041, 0x080c, 0x831a, 0x6958, 0xa18c, 0xff00,
+	0xa186, 0x2000, 0x1140, 0x0026, 0x2009, 0x0000, 0x2011, 0xfdff,
+	0x080c, 0x688d, 0x002e, 0x684c, 0xd0c4, 0x0148, 0x2061, 0xb464,
+	0x6000, 0xd08c, 0x1120, 0x6008, 0x8000, 0x0208, 0x600a, 0x00ce,
+	0x012e, 0x0804, 0x610b, 0x00ce, 0x012e, 0x0804, 0x6105, 0x6954,
+	0xa186, 0x002e, 0x0d40, 0xa186, 0x002d, 0x0d28, 0xa186, 0x0045,
+	0x0510, 0xa186, 0x002a, 0x1130, 0x2001, 0xb10c, 0x200c, 0xc194,
+	0x2102, 0x08c8, 0xa186, 0x0020, 0x0170, 0xa186, 0x0029, 0x1d18,
+	0x6944, 0xa18c, 0xff00, 0x810f, 0x080c, 0x4e21, 0x1960, 0x6000,
+	0xc0e4, 0x6002, 0x0840, 0x685c, 0xa065, 0x09a8, 0x2001, 0xb3b5,
+	0x2004, 0x6016, 0x0800, 0x685c, 0xa065, 0x0968, 0x00e6, 0x6860,
+	0xa075, 0x2001, 0xb130, 0x2004, 0xa005, 0x0150, 0x080c, 0x9a2b,
+	0x8eff, 0x0118, 0x2e60, 0x080c, 0x9a2b, 0x00ee, 0x0804, 0x5fcb,
+	0x6020, 0xc0dc, 0xc0d5, 0x6022, 0x2e60, 0x6007, 0x003a, 0x6870,
+	0xa005, 0x0130, 0x6007, 0x003b, 0x6874, 0x602a, 0x6878, 0x6012,
+	0x6003, 0x0001, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x00ee, 0x0804,
+	0x5fcb, 0x2061, 0xb464, 0x6000, 0xd084, 0x0190, 0xd08c, 0x1904,
+	0x6119, 0x0126, 0x2091, 0x8000, 0x6204, 0x8210, 0x0220, 0x6206,
+	0x012e, 0x0804, 0x6119, 0x012e, 0x6853, 0x0016, 0x0804, 0x6112,
+	0x6853, 0x0007, 0x0804, 0x6112, 0x6834, 0x8007, 0xa084, 0x00ff,
+	0x1118, 0x080c, 0x5d23, 0x0078, 0x2030, 0x8001, 0x1120, 0x7007,
+	0x0001, 0x0051, 0x0040, 0x7007, 0x0006, 0x7012, 0x2d00, 0x7016,
+	0x701a, 0x704b, 0x606c, 0x0005, 0x00e6, 0x0126, 0x2091, 0x8000,
+	0x2009, 0xb130, 0x210c, 0x81ff, 0x1904, 0x60e7, 0x2009, 0xb10c,
+	0x210c, 0xd194, 0x1904, 0x60ef, 0x6848, 0x2070, 0xae82, 0xb800,
+	0x0a04, 0x60db, 0x2001, 0xb116, 0x2004, 0xae02, 0x1a04, 0x60db,
+	0x2061, 0xb464, 0x6100, 0xa184, 0x0301, 0xa086, 0x0001, 0x15a8,
+	0x711c, 0xa186, 0x0006, 0x15b0, 0x7018, 0xa005, 0x0904, 0x60e7,
+	0x2004, 0xd0e4, 0x1904, 0x60ea, 0x7020, 0xd0dc, 0x1904, 0x60f2,
+	0x6853, 0x0000, 0x6803, 0x0000, 0x2d08, 0x7010, 0xa005, 0x1158,
+	0x7112, 0x684c, 0xd0f4, 0x1904, 0x60f5, 0x2e60, 0x080c, 0x67f8,
+	0x012e, 0x00ee, 0x0005, 0x2068, 0x6800, 0xa005, 0x1de0, 0x6902,
+	0x2168, 0x684c, 0xd0f4, 0x15c8, 0x012e, 0x00ee, 0x0005, 0x012e,
+	0x00ee, 0x6853, 0x0006, 0x0804, 0x6112, 0xd184, 0x0dc0, 0xd1c4,
+	0x11a8, 0x00b8, 0x6944, 0xa18c, 0xff00, 0x810f, 0x080c, 0x4e21,
+	0x11c8, 0x6000, 0xd0e4, 0x11b0, 0x711c, 0xa186, 0x0007, 0x1118,
+	0x6853, 0x0002, 0x0088, 0x6853, 0x0008, 0x0070, 0x6853, 0x000e,
+	0x0058, 0x6853, 0x0017, 0x0040, 0x6853, 0x0035, 0x0028, 0x6853,
+	0x0028, 0x0010, 0x6853, 0x0029, 0x012e, 0x00ee, 0x0418, 0x6853,
+	0x002a, 0x0cd0, 0x6853, 0x0045, 0x0cb8, 0x2e60, 0x2019, 0x0002,
+	0x6017, 0x0014, 0x080c, 0xa8af, 0x012e, 0x00ee, 0x0005, 0x2009,
+	0x003e, 0x0058, 0x2009, 0x0004, 0x0040, 0x2009, 0x0006, 0x0028,
+	0x2009, 0x0016, 0x0010, 0x2009, 0x0001, 0x6854, 0xa084, 0xff00,
+	0xa105, 0x6856, 0x0126, 0x2091, 0x8000, 0x080c, 0x5271, 0x012e,
+	0x0005, 0x080c, 0x15f4, 0x0005, 0x702c, 0x7130, 0x8108, 0xa102,
+	0x0230, 0xa00e, 0x7034, 0x7072, 0x7038, 0x7076, 0x0058, 0x7070,
+	0xa080, 0x0040, 0x7072, 0x1230, 0x7074, 0xa081, 0x0000, 0x7076,
+	0xa085, 0x0001, 0x7932, 0x7132, 0x0005, 0x00d6, 0x080c, 0x67ef,
+	0x00de, 0x0005, 0x00d6, 0x00c6, 0x0036, 0x0026, 0x0016, 0x7007,
+	0x0001, 0x6a44, 0xa282, 0x0004, 0x1a04, 0x6185, 0xd284, 0x0170,
+	0x6a4c, 0xa290, 0xb235, 0x2204, 0xa065, 0x6004, 0x05e0, 0x8007,
+	0xa084, 0x00ff, 0xa084, 0x0006, 0x1108, 0x04a8, 0x2c10, 0x080c,
+	0x8295, 0x1118, 0x080c, 0x9ae4, 0x05a0, 0x621a, 0x6844, 0x0002,
+	0x6164, 0x6169, 0x616c, 0x6172, 0x2019, 0x0002, 0x080c, 0xac2b,
+	0x0060, 0x080c, 0xabc2, 0x0048, 0x2019, 0x0002, 0x6950, 0x080c,
+	0xabdd, 0x0018, 0x6950, 0x080c, 0xabc2, 0x080c, 0x82eb, 0x6857,
+	0x0000, 0x0126, 0x2091, 0x8000, 0x080c, 0x5271, 0x012e, 0x001e,
+	0x002e, 0x003e, 0x00ce, 0x00de, 0x0005, 0x6857, 0x0006, 0x0c88,
+	0x6857, 0x0002, 0x0c70, 0x6857, 0x0005, 0x0c58, 0x6857, 0x0004,
+	0x0c40, 0x6857, 0x0007, 0x0c28, 0x00d6, 0x2011, 0x0004, 0x2204,
+	0xa085, 0x8002, 0x2012, 0x00de, 0x0005, 0x20e1, 0x0002, 0x3d08,
+	0x20e1, 0x2000, 0x3d00, 0xa084, 0x7000, 0x0118, 0xa086, 0x1000,
+	0x1570, 0x20e1, 0x0000, 0x3d00, 0xa094, 0xff00, 0x8217, 0xa084,
+	0xf000, 0xa086, 0x3000, 0x1160, 0xa184, 0xff00, 0x8007, 0xa086,
+	0x0008, 0x11e8, 0x080c, 0x2c87, 0x11d0, 0x080c, 0x63bf, 0x0098,
+	0x20e1, 0x0004, 0x3d60, 0xd1bc, 0x1108, 0x3e60, 0xac84, 0x0007,
+	0x1170, 0xac82, 0xb800, 0x0258, 0x6858, 0xac02, 0x1240, 0x2009,
+	0x0047, 0x080c, 0x831a, 0x7a1c, 0xd284, 0x1938, 0x0005, 0xa016,
+	0x080c, 0x1828, 0x0cc0, 0x0cd8, 0x781c, 0xd08c, 0x0500, 0x0156,
+	0x0136, 0x0146, 0x20e1, 0x3000, 0x3d20, 0x3e28, 0xa584, 0x0076,
+	0x1530, 0xa484, 0x7000, 0xa086, 0x1000, 0x11a8, 0x080c, 0x623a,
+	0x01f0, 0x20e1, 0x3000, 0x7828, 0x7828, 0x080c, 0x6256, 0x014e,
+	0x013e, 0x015e, 0x2009, 0xb3e1, 0x2104, 0xa005, 0x1108, 0x0005,
+	0x080c, 0x6e9e, 0x0ce0, 0xa484, 0x7000, 0x1518, 0x0499, 0x01b8,
+	0x7000, 0xa084, 0xff00, 0xa086, 0x8100, 0x0d18, 0x0080, 0xd5a4,
+	0x0158, 0x080c, 0x1db4, 0x20e1, 0x9010, 0x2001, 0x0160, 0x2502,
+	0x2001, 0x0138, 0x2202, 0x0048, 0x00e9, 0x6883, 0x0000, 0x080c,
+	0xafa5, 0x20e1, 0x3000, 0x7828, 0x7828, 0x014e, 0x013e, 0x015e,
+	0x08b0, 0x0081, 0x1130, 0x7000, 0xa084, 0xff00, 0xa086, 0x8100,
+	0x1d70, 0x080c, 0xafa5, 0x20e1, 0x3000, 0x7828, 0x7828, 0x080c,
+	0x6630, 0x0c58, 0xa484, 0x01ff, 0x6882, 0xa005, 0x0160, 0xa080,
+	0x001f, 0xa084, 0x03f8, 0x80ac, 0x20e1, 0x1000, 0x2ea0, 0x2099,
+	0x020a, 0x53a5, 0x0005, 0x20a9, 0x000c, 0x20e1, 0x1000, 0x2ea0,
+	0x2099, 0x020a, 0x53a5, 0xa085, 0x0001, 0x0ca0, 0x7000, 0xa084,
+	0xff00, 0xa08c, 0xf000, 0x8007, 0xa196, 0x0000, 0x1118, 0x0804,
+	0x64c4, 0x0005, 0xa196, 0x2000, 0x1148, 0x6900, 0xa18e, 0x0001,
+	0x1118, 0x080c, 0x4305, 0x0ca8, 0x0039, 0x0c98, 0xa196, 0x8000,
+	0x1d80, 0x080c, 0x6570, 0x0c68, 0x00c6, 0x6a80, 0x82ff, 0x0904,
+	0x63b9, 0x7110, 0xa18c, 0xff00, 0x810f, 0xa196, 0x0001, 0x0120,
+	0xa196, 0x0023, 0x1904, 0x63b9, 0xa08e, 0x0023, 0x1570, 0x080c,
+	0x660b, 0x0904, 0x63b9, 0x7124, 0x610a, 0x7030, 0xa08e, 0x0200,
+	0x1150, 0x7034, 0xa005, 0x1904, 0x63b9, 0x2009, 0x0015, 0x080c,
+	0x831a, 0x0804, 0x63b9, 0xa08e, 0x0214, 0x0118, 0xa08e, 0x0210,
+	0x1130, 0x2009, 0x0015, 0x080c, 0x831a, 0x0804, 0x63b9, 0xa08e,
+	0x0100, 0x1904, 0x63b9, 0x7034, 0xa005, 0x1904, 0x63b9, 0x2009,
+	0x0016, 0x080c, 0x831a, 0x0804, 0x63b9, 0xa08e, 0x0022, 0x1904,
+	0x63b9, 0x7030, 0xa08e, 0x0300, 0x1580, 0x68d0, 0xd0a4, 0x0528,
+	0xc0b5, 0x68d2, 0x7100, 0xa18c, 0x00ff, 0x696e, 0x7004, 0x6872,
+	0x00f6, 0x2079, 0x0100, 0x79e6, 0x78ea, 0x0006, 0xa084, 0x00ff,
+	0x0016, 0x2008, 0x080c, 0x2720, 0x7932, 0x7936, 0x001e, 0x000e,
+	0x00fe, 0x080c, 0x26f6, 0x694e, 0x703c, 0x00e6, 0x2071, 0x0140,
+	0x7086, 0x2071, 0xb100, 0x70a2, 0x00ee, 0x7034, 0xa005, 0x1904,
+	0x63b9, 0x2009, 0x0017, 0x0804, 0x637f, 0xa08e, 0x0400, 0x1158,
+	0x7034, 0xa005, 0x1904, 0x63b9, 0x68d0, 0xc0a5, 0x68d2, 0x2009,
+	0x0030, 0x0804, 0x637f, 0xa08e, 0x0500, 0x1140, 0x7034, 0xa005,
+	0x1904, 0x63b9, 0x2009, 0x0018, 0x0804, 0x637f, 0xa08e, 0x2010,
+	0x1120, 0x2009, 0x0019, 0x0804, 0x637f, 0xa08e, 0x2110, 0x1120,
+	0x2009, 0x001a, 0x0804, 0x637f, 0xa08e, 0x5200, 0x1140, 0x7034,
+	0xa005, 0x1904, 0x63b9, 0x2009, 0x001b, 0x0804, 0x637f, 0xa08e,
+	0x5000, 0x1140, 0x7034, 0xa005, 0x1904, 0x63b9, 0x2009, 0x001c,
+	0x0804, 0x637f, 0xa08e, 0x1300, 0x1120, 0x2009, 0x0034, 0x0804,
+	0x637f, 0xa08e, 0x1200, 0x1140, 0x7034, 0xa005, 0x1904, 0x63b9,
+	0x2009, 0x0024, 0x0804, 0x637f, 0xa08c, 0xff00, 0xa18e, 0x2400,
+	0x1118, 0x2009, 0x002d, 0x04d8, 0xa08c, 0xff00, 0xa18e, 0x5300,
+	0x1118, 0x2009, 0x002a, 0x0498, 0xa08e, 0x0f00, 0x1118, 0x2009,
+	0x0020, 0x0468, 0xa08e, 0x5300, 0x1108, 0x00d8, 0xa08e, 0x6104,
+	0x11c0, 0x2011, 0xb68d, 0x8208, 0x2204, 0xa082, 0x0004, 0x20a8,
+	0x95ac, 0x95ac, 0x2011, 0x8015, 0x211c, 0x8108, 0x0046, 0x2124,
+	0x080c, 0x3d5b, 0x004e, 0x8108, 0x1f04, 0x6362, 0x2009, 0x0023,
+	0x0070, 0xa08e, 0x6000, 0x1118, 0x2009, 0x003f, 0x0040, 0xa08e,
+	0x7800, 0x1118, 0x2009, 0x0045, 0x0010, 0x2009, 0x001d, 0x0016,
+	0x2011, 0xb683, 0x2204, 0x8211, 0x220c, 0x080c, 0x26f6, 0x1598,
+	0x080c, 0x4dc5, 0x1580, 0x6612, 0x6516, 0x86ff, 0x01e8, 0x001e,
+	0x0016, 0xa186, 0x0017, 0x1158, 0x686c, 0xa606, 0x11a8, 0x6870,
+	0xa506, 0xa084, 0xff00, 0x1180, 0x6000, 0xc0f5, 0x6002, 0xa186,
+	0x0046, 0x1150, 0x686c, 0xa606, 0x1138, 0x6870, 0xa506, 0xa084,
+	0xff00, 0x1110, 0x001e, 0x0068, 0x00c6, 0x080c, 0x8295, 0x0168,
+	0x001e, 0x611a, 0x601f, 0x0004, 0x7120, 0x610a, 0x001e, 0x080c,
+	0x831a, 0x00ce, 0x0005, 0x001e, 0x0ce0, 0x00ce, 0x0ce0, 0x00c6,
+	0x0046, 0x080c, 0x6413, 0x1904, 0x6410, 0xa28e, 0x0033, 0x11e8,
+	0x080c, 0x660b, 0x0904, 0x6410, 0x7124, 0x610a, 0x7030, 0xa08e,
+	0x0200, 0x1140, 0x7034, 0xa005, 0x15d8, 0x2009, 0x0015, 0x080c,
+	0x831a, 0x04b0, 0xa08e, 0x0100, 0x1598, 0x7034, 0xa005, 0x1580,
+	0x2009, 0x0016, 0x080c, 0x831a, 0x0458, 0xa28e, 0x0032, 0x1540,
+	0x7030, 0xa08e, 0x1400, 0x1520, 0x2009, 0x0038, 0x0016, 0x2011,
+	0xb683, 0x2204, 0x8211, 0x220c, 0x080c, 0x26f6, 0x11c0, 0x080c,
+	0x4dc5, 0x11a8, 0x6612, 0x6516, 0x00c6, 0x080c, 0x8295, 0x0170,
+	0x001e, 0x611a, 0x080c, 0x9c35, 0x601f, 0x0004, 0x7120, 0x610a,
+	0x001e, 0x080c, 0x831a, 0x080c, 0x6e9e, 0x0010, 0x00ce, 0x001e,
+	0x004e, 0x00ce, 0x0005, 0x00f6, 0x00d6, 0x0026, 0x0016, 0x0136,
+	0x0146, 0x0156, 0x3c00, 0x0006, 0x2079, 0x0030, 0x2069, 0x0200,
+	0x080c, 0x1e48, 0x1590, 0x080c, 0x1d06, 0x05e0, 0x04f1, 0x1130,
+	0x7908, 0xa18c, 0x1fff, 0xa182, 0x0011, 0x1688, 0x20a9, 0x000c,
+	0x20e1, 0x0000, 0x2ea0, 0x2099, 0x020a, 0x53a5, 0x20e1, 0x2000,
+	0x2001, 0x020a, 0x2004, 0x7a0c, 0x7808, 0xa080, 0x0007, 0xa084,
+	0x1ff8, 0x0419, 0x1120, 0xa08a, 0x0140, 0x1a0c, 0x14fa, 0x80ac,
+	0x20e1, 0x6000, 0x2099, 0x020a, 0x53a5, 0x20e1, 0x7000, 0x6828,
+	0x6828, 0x7803, 0x0004, 0xa294, 0x0070, 0x000e, 0x20e0, 0x015e,
+	0x014e, 0x013e, 0x001e, 0x002e, 0x00de, 0x00fe, 0x0005, 0xa016,
+	0x080c, 0x1828, 0xa085, 0x0001, 0x0c80, 0x0006, 0x2001, 0x0111,
+	0x2004, 0xa084, 0x0003, 0x000e, 0x0005, 0x0046, 0x00e6, 0x00d6,
+	0x2028, 0x2130, 0xa696, 0x00ff, 0x1198, 0xa596, 0xfffd, 0x1120,
+	0x2009, 0x007f, 0x0804, 0x64bf, 0xa596, 0xfffe, 0x1118, 0x2009,
+	0x007e, 0x04e8, 0xa596, 0xfffc, 0x1118, 0x2009, 0x0080, 0x04b8,
+	0x2011, 0x0000, 0x2019, 0xb134, 0x231c, 0xd3ac, 0x0138, 0x2021,
+	0x0000, 0x20a9, 0x00ff, 0x2071, 0xb235, 0x0030, 0x2021, 0x0081,
+	0x20a9, 0x007e, 0x2071, 0xb2b6, 0x2e1c, 0x83ff, 0x1128, 0x82ff,
+	0x1198, 0x2410, 0xc2fd, 0x0080, 0x2368, 0x6f10, 0x0006, 0x2100,
+	0xa706, 0x000e, 0x6b14, 0x1120, 0xa346, 0x1110, 0x2408, 0x0078,
+	0x87ff, 0x1110, 0x83ff, 0x0d58, 0x8420, 0x8e70, 0x1f04, 0x649c,
+	0x82ff, 0x1118, 0xa085, 0x0001, 0x0018, 0xc2fc, 0x2208, 0xa006,
+	0x00de, 0x00ee, 0x004e, 0x0005, 0xa084, 0x0007, 0x000a, 0x0005,
+	0x64d0, 0x64d0, 0x64d0, 0x661d, 0x64d0, 0x64d1, 0x64e6, 0x655b,
+	0x0005, 0x7110, 0xd1bc, 0x0188, 0x7120, 0x2160, 0xac8c, 0x0007,
+	0x1160, 0xac8a, 0xb800, 0x0248, 0x6858, 0xac02, 0x1230, 0x7124,
+	0x610a, 0x2009, 0x0046, 0x080c, 0x831a, 0x0005, 0x00c6, 0x7110,
+	0xd1bc, 0x1904, 0x6539, 0x2011, 0xb683, 0x2204, 0x8211, 0x220c,
+	0x080c, 0x26f6, 0x1904, 0x6539, 0x080c, 0x4dc5, 0x1904, 0x6539,
+	0x6612, 0x6516, 0x6000, 0xd0ec, 0x15e0, 0x6204, 0xa294, 0xff00,
+	0x8217, 0xa286, 0x0006, 0x0160, 0x080c, 0x58d5, 0x11d0, 0x6204,
+	0xa294, 0x00ff, 0xa286, 0x0006, 0x11a0, 0xa295, 0x0600, 0x6206,
+	0x00c6, 0x080c, 0x8295, 0x001e, 0x0530, 0x611a, 0x601f, 0x0006,
+	0x7120, 0x610a, 0x7130, 0x6152, 0x2009, 0x0044, 0x080c, 0x831a,
+	0x00c0, 0x00c6, 0x080c, 0x8295, 0x001e, 0x0198, 0x611a, 0x601f,
+	0x0004, 0x7120, 0x610a, 0xa286, 0x0004, 0x1118, 0x6007, 0x0005,
+	0x0010, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x6a3c, 0x080c,
+	0x6e9e, 0x00ce, 0x0005, 0x2001, 0xb10d, 0x2004, 0xd0ec, 0x0120,
+	0x2011, 0x8049, 0x080c, 0x3d5b, 0x00c6, 0x080c, 0x9ae4, 0x001e,
+	0x0d80, 0x611a, 0x601f, 0x0006, 0x7120, 0x610a, 0x7130, 0x6152,
+	0x6013, 0x0300, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c, 0x69f6,
+	0x080c, 0x6e9e, 0x08f0, 0x7110, 0xd1bc, 0x0188, 0x7020, 0x2060,
+	0xac84, 0x0007, 0x1160, 0xac82, 0xb800, 0x0248, 0x6858, 0xac02,
+	0x1230, 0x7124, 0x610a, 0x2009, 0x0045, 0x080c, 0x831a, 0x0005,
+	0x0006, 0x080c, 0x2c87, 0x000e, 0x1168, 0x7110, 0xa18c, 0xff00,
+	0x810f, 0xa18e, 0x0000, 0x1130, 0xa084, 0x000f, 0xa08a, 0x0006,
+	0x1208, 0x000b, 0x0005, 0x6589, 0x658a, 0x6589, 0x6589, 0x65f3,
+	0x65ff, 0x0005, 0x7110, 0xd1bc, 0x0120, 0x702c, 0xd084, 0x0904,
+	0x65f2, 0x700c, 0x7108, 0x080c, 0x26f6, 0x1904, 0x65f2, 0x080c,
+	0x4dc5, 0x1904, 0x65f2, 0x6612, 0x6516, 0x6204, 0x7110, 0xd1bc,
+	0x01f8, 0xa28c, 0x00ff, 0xa186, 0x0004, 0x0118, 0xa186, 0x0006,
+	0x15c8, 0x00c6, 0x080c, 0x660b, 0x00ce, 0x0904, 0x65f2, 0x00c6,
+	0x080c, 0x8295, 0x001e, 0x05f0, 0x611a, 0x080c, 0x9c35, 0x601f,
+	0x0002, 0x7120, 0x610a, 0x2009, 0x0088, 0x080c, 0x831a, 0x0490,
+	0xa28c, 0x00ff, 0xa186, 0x0006, 0x0160, 0xa186, 0x0004, 0x0148,
+	0xa294, 0xff00, 0x8217, 0xa286, 0x0004, 0x0118, 0xa286, 0x0006,
+	0x1188, 0x00c6, 0x080c, 0x8295, 0x001e, 0x01e0, 0x611a, 0x080c,
+	0x9c35, 0x601f, 0x0005, 0x7120, 0x610a, 0x2009, 0x0088, 0x080c,
+	0x831a, 0x0080, 0x00c6, 0x080c, 0x8295, 0x001e, 0x0158, 0x611a,
+	0x080c, 0x9c35, 0x601f, 0x0004, 0x7120, 0x610a, 0x2009, 0x0001,
+	0x080c, 0x831a, 0x0005, 0x7110, 0xd1bc, 0x0140, 0x00a1, 0x0130,
+	0x7124, 0x610a, 0x2009, 0x0089, 0x080c, 0x831a, 0x0005, 0x7110,
+	0xd1bc, 0x0140, 0x0041, 0x0130, 0x7124, 0x610a, 0x2009, 0x008a,
+	0x080c, 0x831a, 0x0005, 0x7020, 0x2060, 0xac84, 0x0007, 0x1158,
+	0xac82, 0xb800, 0x0240, 0x2001, 0xb116, 0x2004, 0xac02, 0x1218,
+	0xa085, 0x0001, 0x0005, 0xa006, 0x0ce8, 0x7110, 0xd1bc, 0x1178,
+	0x7024, 0x2060, 0xac84, 0x0007, 0x1150, 0xac82, 0xb800, 0x0238,
+	0x6858, 0xac02, 0x1220, 0x2009, 0x0051, 0x080c, 0x831a, 0x0005,
+	0x2031, 0x0105, 0x0069, 0x0005, 0x2031, 0x0206, 0x0049, 0x0005,
+	0x2031, 0x0207, 0x0029, 0x0005, 0x2031, 0x0213, 0x0009, 0x0005,
+	0x00c6, 0x00d6, 0x00f6, 0x7000, 0xa084, 0xf000, 0xa086, 0xc000,
+	0x05b0, 0x080c, 0x8295, 0x0598, 0x0066, 0x00c6, 0x0046, 0x2011,
+	0xb683, 0x2204, 0x8211, 0x220c, 0x080c, 0x26f6, 0x1580, 0x080c,
+	0x4dc5, 0x1568, 0x6612, 0x6516, 0x2c00, 0x004e, 0x00ce, 0x601a,
+	0x080c, 0x9c35, 0x080c, 0x15dd, 0x01f0, 0x2d00, 0x6056, 0x6803,
+	0x0000, 0x6837, 0x0000, 0x6c3a, 0xadf8, 0x000f, 0x20a9, 0x000e,
+	0x2fa0, 0x2e98, 0x53a3, 0x006e, 0x6612, 0x6007, 0x003e, 0x601f,
+	0x0001, 0x6003, 0x0001, 0x080c, 0x6a3c, 0x080c, 0x6e9e, 0x00fe,
+	0x00de, 0x00ce, 0x0005, 0x080c, 0x82eb, 0x006e, 0x0cc0, 0x004e,
+	0x00ce, 0x0cc8, 0x2071, 0xb3ec, 0x7003, 0x0003, 0x700f, 0x0361,
+	0xa006, 0x701a, 0x7012, 0x7017, 0xb800, 0x7007, 0x0000, 0x7026,
+	0x702b, 0x7a99, 0x7032, 0x7037, 0x7af9, 0x703b, 0xffff, 0x703f,
+	0xffff, 0x7042, 0x7047, 0x42c1, 0x704a, 0x705b, 0x67d1, 0x2001,
+	0xb3a0, 0x2003, 0x0003, 0x2001, 0xb3a2, 0x2003, 0x0100, 0x3a00,
+	0xa084, 0x0005, 0x706e, 0x0005, 0x2071, 0xb3ec, 0x1d04, 0x6731,
+	0x2091, 0x6000, 0x700c, 0x8001, 0x700e, 0x1518, 0x700f, 0x0361,
+	0x7007, 0x0001, 0x0126, 0x2091, 0x8000, 0x7040, 0xa00d, 0x0128,
+	0x8109, 0x7142, 0x1110, 0x7044, 0x080f, 0x00c6, 0x2061, 0xb100,
+	0x6034, 0x00ce, 0xd0cc, 0x0180, 0x3a00, 0xa084, 0x0005, 0x726c,
+	0xa216, 0x0150, 0x706e, 0x2011, 0x8043, 0x2018, 0x080c, 0x3d5b,
+	0x0018, 0x0126, 0x2091, 0x8000, 0x7024, 0xa00d, 0x0188, 0x7020,
+	0x8001, 0x7022, 0x1168, 0x7023, 0x0009, 0x8109, 0x7126, 0xa186,
+	0x03e8, 0x1110, 0x7028, 0x080f, 0x81ff, 0x1110, 0x7028, 0x080f,
+	0x7030, 0xa00d, 0x0158, 0x702c, 0x8001, 0x702e, 0x1138, 0x702f,
+	0x0009, 0x8109, 0x7132, 0x1110, 0x7034, 0x080f, 0x7038, 0xa005,
+	0x0118, 0x0310, 0x8001, 0x703a, 0x703c, 0xa005, 0x0118, 0x0310,
+	0x8001, 0x703e, 0x704c, 0xa00d, 0x0168, 0x7048, 0x8001, 0x704a,
+	0x1148, 0x704b, 0x0009, 0x8109, 0x714e, 0x1120, 0x7150, 0x714e,
+	0x7058, 0x080f, 0x7018, 0xa00d, 0x0158, 0x7008, 0x8001, 0x700a,
+	0x1138, 0x700b, 0x0009, 0x8109, 0x711a, 0x1110, 0x701c, 0x080f,
+	0x012e, 0x7004, 0x0002, 0x6757, 0x6758, 0x6770, 0x00e6, 0x2071,
+	0xb3ec, 0x7018, 0xa005, 0x1120, 0x711a, 0x721e, 0x700b, 0x0009,
+	0x00ee, 0x0005, 0x00e6, 0x0006, 0x2071, 0xb3ec, 0x701c, 0xa206,
+	0x1110, 0x701a, 0x701e, 0x000e, 0x00ee, 0x0005, 0x00e6, 0x2071,
+	0xb3ec, 0x6088, 0xa102, 0x0208, 0x618a, 0x00ee, 0x0005, 0x0005,
+	0x7110, 0x080c, 0x4e21, 0x1158, 0x6088, 0x8001, 0x0240, 0x608a,
+	0x1130, 0x0126, 0x2091, 0x8000, 0x080c, 0x6e9e, 0x012e, 0x8108,
+	0xa182, 0x00ff, 0x0218, 0xa00e, 0x7007, 0x0002, 0x7112, 0x0005,
+	0x7014, 0x2060, 0x0126, 0x2091, 0x8000, 0x603c, 0xa005, 0x0128,
+	0x8001, 0x603e, 0x1110, 0x080c, 0x9b23, 0x6014, 0xa005, 0x0500,
+	0x8001, 0x6016, 0x11e8, 0x611c, 0xa186, 0x0003, 0x0118, 0xa186,
+	0x0006, 0x11a0, 0x6010, 0x2068, 0x6854, 0xa08a, 0x199a, 0x0270,
+	0xa082, 0x1999, 0x6856, 0xa08a, 0x199a, 0x0210, 0x2001, 0x1999,
+	0x8003, 0x800b, 0x810b, 0xa108, 0x6116, 0x0010, 0x080c, 0x9617,
+	0x012e, 0xac88, 0x0018, 0x7116, 0x2001, 0xe800, 0xa102, 0x0220,
+	0x7017, 0xb800, 0x7007, 0x0000, 0x0005, 0x00e6, 0x2071, 0xb3ec,
+	0x7027, 0x07d0, 0x7023, 0x0009, 0x00ee, 0x0005, 0x2001, 0xb3f5,
+	0x2003, 0x0000, 0x0005, 0x00e6, 0x2071, 0xb3ec, 0x7132, 0x702f,
+	0x0009, 0x00ee, 0x0005, 0x2011, 0xb3f8, 0x2013, 0x0000, 0x0005,
+	0x00e6, 0x2071, 0xb3ec, 0x711a, 0x721e, 0x700b, 0x0009, 0x00ee,
+	0x0005, 0x00c6, 0x0026, 0x7054, 0x8000, 0x7056, 0x2061, 0xb3a0,
+	0x6008, 0xa086, 0x0000, 0x0158, 0x7068, 0x6032, 0x7064, 0x602e,
+	0x7060, 0x602a, 0x705c, 0x6026, 0x2c10, 0x080c, 0x1628, 0x002e,
+	0x00ce, 0x0005, 0x00c6, 0x2061, 0xb464, 0x00ce, 0x0005, 0xa184,
+	0x000f, 0x8003, 0x8003, 0x8003, 0xa080, 0xb464, 0x2060, 0x0005,
+	0x6854, 0xa08a, 0x199a, 0x0210, 0x2001, 0x1999, 0xa005, 0x1150,
+	0x00c6, 0x2061, 0xb464, 0x6014, 0x00ce, 0xa005, 0x1138, 0x2001,
+	0x001e, 0x0020, 0xa08e, 0xffff, 0x1108, 0xa006, 0x8003, 0x800b,
+	0x810b, 0xa108, 0x6116, 0x684c, 0xa08c, 0x00c0, 0xa18e, 0x00c0,
+	0x05b0, 0xd0b4, 0x1138, 0xd0bc, 0x1528, 0x2009, 0x0006, 0x080c,
+	0x6868, 0x0005, 0xd0fc, 0x0130, 0xa084, 0x0003, 0x0118, 0xa086,
+	0x0003, 0x15c0, 0x6020, 0xd0d4, 0x0130, 0xc0d4, 0x6022, 0x6860,
+	0x602a, 0x685c, 0x602e, 0x2009, 0xb174, 0x2104, 0xd084, 0x0128,
+	0x2009, 0x0042, 0x080c, 0x831a, 0x0005, 0x2009, 0x0043, 0x080c,
+	0x831a, 0x0005, 0xd0fc, 0x0130, 0xa084, 0x0003, 0x0118, 0xa086,
+	0x0003, 0x11c0, 0x2009, 0x0042, 0x080c, 0x831a, 0x0005, 0xd0fc,
+	0x0150, 0xa084, 0x0003, 0xa08e, 0x0002, 0x0138, 0x2009, 0x0041,
+	0x080c, 0x831a, 0x0005, 0x0051, 0x0ce8, 0x2009, 0x0043, 0x080c,
+	0x831a, 0x0cc0, 0x2009, 0x0004, 0x0019, 0x0005, 0x2009, 0x0001,
+	0x00d6, 0x6010, 0xa0ec, 0xf000, 0x01f0, 0x2068, 0x6952, 0x6800,
+	0x6012, 0xa186, 0x0001, 0x1188, 0x694c, 0xa18c, 0x8100, 0xa18e,
+	0x8100, 0x1158, 0x00c6, 0x2061, 0xb464, 0x6200, 0xd28c, 0x1120,
+	0x6204, 0x8210, 0x0208, 0x6206, 0x00ce, 0x080c, 0x5271, 0x6010,
+	0xa06d, 0x190c, 0x67f8, 0x00de, 0x0005, 0x0156, 0x00c6, 0x2061,
+	0xb464, 0x6000, 0x81ff, 0x0110, 0xa205, 0x0008, 0xa204, 0x6002,
+	0x00ce, 0x015e, 0x0005, 0x6800, 0xd08c, 0x1138, 0x6808, 0xa005,
+	0x0120, 0x8001, 0x680a, 0xa085, 0x0001, 0x0005, 0x20a9, 0x0010,
+	0xa006, 0x8004, 0x8086, 0x818e, 0x1208, 0xa200, 0x1f04, 0x68aa,
+	0x8086, 0x818e, 0x0005, 0x0156, 0x20a9, 0x0010, 0xa005, 0x01b8,
+	0xa11a, 0x12a8, 0x8213, 0x818d, 0x0228, 0xa11a, 0x1220, 0x1f04,
+	0x68ba, 0x0028, 0xa11a, 0x2308, 0x8210, 0x1f04, 0x68ba, 0x0006,
+	0x3200, 0xa084, 0xefff, 0x2080, 0x000e, 0x015e, 0x0005, 0x0006,
+	0x3200, 0xa085, 0x1000, 0x0cb8, 0x0126, 0x2091, 0x2800, 0x2079,
+	0xb3d9, 0x012e, 0x00d6, 0x2069, 0xb3d9, 0x6803, 0x0005, 0x2069,
+	0x0004, 0x2d04, 0xa085, 0x8001, 0x206a, 0x00de, 0x0005, 0x00c6,
+	0x6027, 0x0001, 0x7804, 0xa084, 0x0007, 0x0002, 0x68f8, 0x6919,
+	0x696c, 0x68fe, 0x6919, 0x68f8, 0x68f6, 0x68f6, 0x080c, 0x14fa,
+	0x080c, 0x67b6, 0x080c, 0x6e9e, 0x00ce, 0x0005, 0x62c0, 0x82ff,
+	0x1110, 0x00ce, 0x0005, 0x2011, 0x494f, 0x080c, 0x6742, 0x7828,
+	0xa092, 0x00c8, 0x1228, 0x8000, 0x782a, 0x080c, 0x4989, 0x0c88,
+	0x080c, 0x494f, 0x7807, 0x0003, 0x7827, 0x0000, 0x782b, 0x0000,
+	0x0c40, 0x080c, 0x67b6, 0x3c00, 0x0006, 0x2011, 0x0209, 0x20e1,
+	0x4000, 0x2214, 0x000e, 0x20e0, 0x82ff, 0x0178, 0x62c0, 0x82ff,
+	0x1160, 0x782b, 0x0000, 0x7824, 0xa065, 0x090c, 0x14fa, 0x2009,
+	0x0013, 0x080c, 0x831a, 0x00ce, 0x0005, 0x3900, 0xa082, 0xb51c,
+	0x1210, 0x080c, 0x8000, 0x00c6, 0x7824, 0xa065, 0x090c, 0x14fa,
+	0x7804, 0xa086, 0x0004, 0x0904, 0x69ac, 0x7828, 0xa092, 0x2710,
+	0x1230, 0x8000, 0x782a, 0x00ce, 0x080c, 0x7a7f, 0x0c20, 0x6104,
+	0xa186, 0x0003, 0x1188, 0x00e6, 0x2071, 0xb100, 0x70dc, 0x00ee,
+	0xd08c, 0x0150, 0x00c6, 0x00e6, 0x2061, 0x0100, 0x2071, 0xb100,
+	0x080c, 0x4992, 0x00ee, 0x00ce, 0x080c, 0xafee, 0x2009, 0x0014,
+	0x080c, 0x831a, 0x00ce, 0x0838, 0x2001, 0xb3f5, 0x2003, 0x0000,
+	0x62c0, 0x82ff, 0x1160, 0x782b, 0x0000, 0x7824, 0xa065, 0x090c,
+	0x14fa, 0x2009, 0x0013, 0x080c, 0x836e, 0x00ce, 0x0005, 0x00c6,
+	0x00d6, 0x3900, 0xa082, 0xb51c, 0x1210, 0x080c, 0x8000, 0x7824,
+	0xa005, 0x090c, 0x14fa, 0x781c, 0xa06d, 0x090c, 0x14fa, 0x6800,
+	0xc0dc, 0x6802, 0x7924, 0x2160, 0x080c, 0x82eb, 0x693c, 0x81ff,
+	0x090c, 0x14fa, 0x8109, 0x693e, 0x6854, 0xa015, 0x0110, 0x7a1e,
+	0x0010, 0x7918, 0x791e, 0x7807, 0x0000, 0x7827, 0x0000, 0x00de,
+	0x00ce, 0x080c, 0x6e9e, 0x0888, 0x6104, 0xa186, 0x0002, 0x0128,
+	0xa186, 0x0004, 0x0110, 0x0804, 0x6945, 0x7808, 0xac06, 0x0904,
+	0x6945, 0x080c, 0x6dc1, 0x080c, 0x6a3c, 0x00ce, 0x080c, 0x6e9e,
+	0x0804, 0x6933, 0x00c6, 0x6027, 0x0002, 0x62c8, 0x60c4, 0xa205,
+	0x1178, 0x793c, 0xa1e5, 0x0000, 0x0130, 0x2009, 0x0049, 0x080c,
+	0x831a, 0x00ce, 0x0005, 0x2011, 0xb3f8, 0x2013, 0x0000, 0x0cc8,
+	0x3908, 0xa192, 0xb51c, 0x1210, 0x080c, 0x8000, 0x793c, 0x81ff,
+	0x0d90, 0x793c, 0xa188, 0x0007, 0x210c, 0xa18e, 0x0006, 0x1138,
+	0x6014, 0xa084, 0x0184, 0xa085, 0x0012, 0x6016, 0x0c10, 0x6014,
+	0xa084, 0x0184, 0xa085, 0x0016, 0x6016, 0x08d8, 0x0006, 0x0016,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x600f, 0x0000, 0x2c08, 0x2061,
+	0xb3d9, 0x6020, 0x8000, 0x6022, 0x6010, 0xa005, 0x0148, 0xa080,
+	0x0003, 0x2102, 0x6112, 0x012e, 0x00ce, 0x001e, 0x000e, 0x0005,
+	0x6116, 0x6112, 0x0cc0, 0x00d6, 0x2069, 0xb3d9, 0x6000, 0xd0d4,
+	0x0168, 0x6820, 0x8000, 0x6822, 0xa086, 0x0001, 0x1110, 0x2c00,
+	0x681e, 0x6804, 0xa084, 0x0007, 0x0804, 0x6ea4, 0xc0d5, 0x6002,
+	0x6818, 0xa005, 0x0158, 0x6056, 0x605b, 0x0000, 0x0006, 0x2c00,
+	0x681a, 0x00de, 0x685a, 0x2069, 0xb3d9, 0x0c18, 0x6056, 0x605a,
+	0x2c00, 0x681a, 0x681e, 0x08e8, 0x0006, 0x0016, 0x00c6, 0x0126,
+	0x2091, 0x8000, 0x600f, 0x0000, 0x2c08, 0x2061, 0xb3d9, 0x6020,
+	0x8000, 0x6022, 0x6008, 0xa005, 0x0148, 0xa080, 0x0003, 0x2102,
+	0x610a, 0x012e, 0x00ce, 0x001e, 0x000e, 0x0005, 0x610e, 0x610a,
+	0x0cc0, 0x00c6, 0x600f, 0x0000, 0x2c08, 0x2061, 0xb3d9, 0x6034,
+	0xa005, 0x0130, 0xa080, 0x0003, 0x2102, 0x6136, 0x00ce, 0x0005,
+	0x613a, 0x6136, 0x0cd8, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0076,
+	0x0066, 0x0026, 0x0016, 0x0006, 0x0126, 0x2071, 0xb3d9, 0x7638,
+	0x2660, 0x2678, 0x2091, 0x8000, 0x8cff, 0x0904, 0x6ad7, 0x6018,
+	0xa080, 0x0028, 0x2004, 0xa206, 0x1904, 0x6ad2, 0x87ff, 0x0120,
+	0x6050, 0xa106, 0x1904, 0x6ad2, 0x703c, 0xac06, 0x1170, 0x0036,
+	0x2019, 0x0001, 0x080c, 0x7cc4, 0x7033, 0x0000, 0x703f, 0x0000,
+	0x7043, 0x0000, 0x7047, 0x0000, 0x003e, 0x7038, 0xac36, 0x1110,
+	0x660c, 0x763a, 0x7034, 0xac36, 0x1140, 0x2c00, 0xaf36, 0x0118,
+	0x2f00, 0x7036, 0x0010, 0x7037, 0x0000, 0x660c, 0x0066, 0x2c00,
+	0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x080c,
+	0x986a, 0x0198, 0x6010, 0x2068, 0x601c, 0xa086, 0x0003, 0x1510,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c, 0x9ada, 0x080c,
+	0xaf46, 0x080c, 0x5271, 0x080c, 0x9a1f, 0x080c, 0x9a2b, 0x00ce,
+	0x0804, 0x6a7c, 0x2c78, 0x600c, 0x2060, 0x0804, 0x6a7c, 0x012e,
+	0x000e, 0x001e, 0x002e, 0x006e, 0x007e, 0x00ce, 0x00de, 0x00ee,
+	0x00fe, 0x0005, 0x601c, 0xa086, 0x0006, 0x19d0, 0x080c, 0xaf46,
+	0x080c, 0xac5f, 0x0c10, 0x0006, 0x0066, 0x00c6, 0x00d6, 0x00f6,
+	0x2031, 0x0000, 0x0126, 0x2091, 0x8000, 0x2079, 0xb3d9, 0x7838,
+	0xa065, 0x0558, 0x600c, 0x0006, 0x600f, 0x0000, 0x783c, 0xac06,
+	0x1170, 0x0036, 0x2019, 0x0001, 0x080c, 0x7cc4, 0x7833, 0x0000,
+	0x783f, 0x0000, 0x7843, 0x0000, 0x7847, 0x0000, 0x003e, 0x080c,
+	0x986a, 0x0178, 0x6010, 0x2068, 0x601c, 0xa086, 0x0003, 0x11b0,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c, 0x5271, 0x080c,
+	0x9a1f, 0x080c, 0x9a2b, 0x000e, 0x0898, 0x7e3a, 0x7e36, 0x012e,
+	0x00fe, 0x00de, 0x00ce, 0x006e, 0x000e, 0x0005, 0x601c, 0xa086,
+	0x0006, 0x1d30, 0x080c, 0xac5f, 0x0c60, 0x0016, 0x0026, 0x0086,
+	0x2041, 0x0000, 0x0099, 0x080c, 0x6bf7, 0x008e, 0x002e, 0x001e,
+	0x0005, 0x00f6, 0x0126, 0x2079, 0xb3d9, 0x2091, 0x8000, 0x080c,
+	0x6c84, 0x080c, 0x6cf6, 0x012e, 0x00fe, 0x0005, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0066, 0x0016, 0x0006, 0x0126, 0x2091, 0x8000,
+	0x2071, 0xb3d9, 0x7614, 0x2660, 0x2678, 0x8cff, 0x0904, 0x6bd3,
+	0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x1904, 0x6bce, 0x88ff,
+	0x0120, 0x6050, 0xa106, 0x1904, 0x6bce, 0x7024, 0xac06, 0x1538,
+	0x2069, 0x0100, 0x68c0, 0xa005, 0x01f0, 0x080c, 0x67b6, 0x080c,
+	0x7a8c, 0x68c3, 0x0000, 0x080c, 0x7f1b, 0x7027, 0x0000, 0x0036,
+	0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0120, 0x6803, 0x0100,
+	0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110, 0x6827,
+	0x0001, 0x003e, 0x0020, 0x6003, 0x0009, 0x630a, 0x04b8, 0x7014,
+	0xac36, 0x1110, 0x660c, 0x7616, 0x7010, 0xac36, 0x1140, 0x2c00,
+	0xaf36, 0x0118, 0x2f00, 0x7012, 0x0010, 0x7013, 0x0000, 0x660c,
+	0x0066, 0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f,
+	0x0000, 0x6010, 0x2068, 0x080c, 0x986a, 0x0188, 0x601c, 0xa086,
+	0x0003, 0x1510, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c,
+	0x9ada, 0x080c, 0xaf46, 0x080c, 0x5271, 0x080c, 0x9a1f, 0x080c,
+	0x9a2b, 0x080c, 0x7dfb, 0x00ce, 0x0804, 0x6b5d, 0x2c78, 0x600c,
+	0x2060, 0x0804, 0x6b5d, 0x012e, 0x000e, 0x001e, 0x006e, 0x00ce,
+	0x00de, 0x00ee, 0x00fe, 0x0005, 0x601c, 0xa086, 0x0006, 0x1128,
+	0x080c, 0xaf46, 0x080c, 0xac5f, 0x0c10, 0x601c, 0xa086, 0x0002,
+	0x1128, 0x6004, 0xa086, 0x0085, 0x0968, 0x08c8, 0x601c, 0xa086,
+	0x0005, 0x19a8, 0x6004, 0xa086, 0x0085, 0x0d50, 0x0880, 0x00c6,
+	0x0006, 0x0126, 0x2091, 0x8000, 0xa280, 0xb235, 0x2004, 0xa065,
+	0x0904, 0x6c80, 0x00f6, 0x00e6, 0x00d6, 0x0066, 0x2071, 0xb3d9,
+	0x6654, 0x7018, 0xac06, 0x1108, 0x761a, 0x701c, 0xac06, 0x1130,
+	0x86ff, 0x1118, 0x7018, 0x701e, 0x0008, 0x761e, 0x6058, 0xa07d,
+	0x0108, 0x7e56, 0xa6ed, 0x0000, 0x0110, 0x2f00, 0x685a, 0x6057,
+	0x0000, 0x605b, 0x0000, 0x6000, 0xc0d4, 0xc0dc, 0x6002, 0x080c,
+	0x4d4c, 0x0904, 0x6c7c, 0x7624, 0x86ff, 0x05e8, 0xa680, 0x0004,
+	0x2004, 0xad06, 0x15c0, 0x00d6, 0x2069, 0x0100, 0x68c0, 0xa005,
+	0x0548, 0x080c, 0x67b6, 0x080c, 0x7a8c, 0x68c3, 0x0000, 0x080c,
+	0x7f1b, 0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0xa384,
+	0x1000, 0x0120, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100,
+	0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x00de, 0x00c6,
+	0x603c, 0xa005, 0x0110, 0x8001, 0x603e, 0x2660, 0x080c, 0x9a2b,
+	0x00ce, 0x0048, 0x00de, 0x00c6, 0x2660, 0x6003, 0x0009, 0x630a,
+	0x00ce, 0x0804, 0x6c27, 0x8dff, 0x0158, 0x6837, 0x0103, 0x6b4a,
+	0x6847, 0x0000, 0x080c, 0x9ada, 0x080c, 0xaf46, 0x080c, 0x5271,
+	0x080c, 0x7dfb, 0x0804, 0x6c27, 0x006e, 0x00de, 0x00ee, 0x00fe,
+	0x012e, 0x000e, 0x00ce, 0x0005, 0x0006, 0x0066, 0x00c6, 0x00d6,
+	0x2031, 0x0000, 0x7814, 0xa065, 0x0904, 0x6cd6, 0x600c, 0x0006,
+	0x600f, 0x0000, 0x7824, 0xac06, 0x1540, 0x2069, 0x0100, 0x68c0,
+	0xa005, 0x01f0, 0x080c, 0x67b6, 0x080c, 0x7a8c, 0x68c3, 0x0000,
+	0x080c, 0x7f1b, 0x7827, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04,
+	0xa384, 0x1000, 0x0120, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069,
+	0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x0028,
+	0x6003, 0x0009, 0x630a, 0x2c30, 0x00b0, 0x6010, 0x2068, 0x080c,
+	0x986a, 0x0168, 0x601c, 0xa086, 0x0003, 0x11b8, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x080c, 0x5271, 0x080c, 0x9a1f, 0x080c,
+	0x9a2b, 0x080c, 0x7dfb, 0x000e, 0x0804, 0x6c8b, 0x7e16, 0x7e12,
+	0x00de, 0x00ce, 0x006e, 0x000e, 0x0005, 0x601c, 0xa086, 0x0006,
+	0x1118, 0x080c, 0xac5f, 0x0c58, 0x601c, 0xa086, 0x0002, 0x1128,
+	0x6004, 0xa086, 0x0085, 0x09d0, 0x0c10, 0x601c, 0xa086, 0x0005,
+	0x19f0, 0x6004, 0xa086, 0x0085, 0x0d60, 0x08c8, 0x0006, 0x0066,
+	0x00c6, 0x00d6, 0x7818, 0xa065, 0x0904, 0x6d5c, 0x6054, 0x0006,
+	0x6057, 0x0000, 0x605b, 0x0000, 0x6000, 0xc0d4, 0xc0dc, 0x6002,
+	0x080c, 0x4d4c, 0x0904, 0x6d59, 0x7e24, 0x86ff, 0x05e8, 0xa680,
+	0x0004, 0x2004, 0xad06, 0x15c0, 0x00d6, 0x2069, 0x0100, 0x68c0,
+	0xa005, 0x0548, 0x080c, 0x67b6, 0x080c, 0x7a8c, 0x68c3, 0x0000,
+	0x080c, 0x7f1b, 0x7827, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04,
+	0xa384, 0x1000, 0x0120, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069,
+	0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x00de,
+	0x00c6, 0x603c, 0xa005, 0x0110, 0x8001, 0x603e, 0x2660, 0x080c,
+	0x9a2b, 0x00ce, 0x0048, 0x00de, 0x00c6, 0x2660, 0x6003, 0x0009,
+	0x630a, 0x00ce, 0x0804, 0x6d08, 0x8dff, 0x0138, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x080c, 0x5271, 0x080c, 0x7dfb, 0x0804,
+	0x6d08, 0x000e, 0x0804, 0x6cfb, 0x781e, 0x781a, 0x00de, 0x00ce,
+	0x006e, 0x000e, 0x0005, 0x00e6, 0x00d6, 0x0066, 0x6000, 0xd0dc,
+	0x0188, 0x604c, 0xa06d, 0x0170, 0x6848, 0xa606, 0x1158, 0x2071,
+	0xb3d9, 0x7024, 0xa035, 0x0130, 0xa080, 0x0004, 0x2004, 0xad06,
+	0x1108, 0x0021, 0x006e, 0x00de, 0x00ee, 0x0005, 0x00f6, 0x2079,
+	0x0100, 0x78c0, 0xa005, 0x1138, 0x00c6, 0x2660, 0x6003, 0x0009,
+	0x630a, 0x00ce, 0x04a0, 0x080c, 0x7a8c, 0x78c3, 0x0000, 0x080c,
+	0x7f1b, 0x7027, 0x0000, 0x0036, 0x2079, 0x0140, 0x7b04, 0xa384,
+	0x1000, 0x0120, 0x7803, 0x0100, 0x7803, 0x0000, 0x2079, 0x0100,
+	0x7824, 0xd084, 0x0110, 0x7827, 0x0001, 0x080c, 0x7f1b, 0x003e,
+	0x080c, 0x4d4c, 0x00c6, 0x603c, 0xa005, 0x0110, 0x8001, 0x603e,
+	0x2660, 0x080c, 0x82eb, 0x00ce, 0x6837, 0x0103, 0x6b4a, 0x6847,
+	0x0000, 0x080c, 0x9ada, 0x080c, 0x5271, 0x080c, 0x7dfb, 0x00fe,
+	0x0005, 0x00e6, 0x00c6, 0x2071, 0xb3d9, 0x7004, 0xa084, 0x0007,
+	0x0002, 0x6dd3, 0x6dd6, 0x6dec, 0x6e05, 0x6e3e, 0x6dd3, 0x6dd1,
+	0x6dd1, 0x080c, 0x14fa, 0x00ce, 0x00ee, 0x0005, 0x7024, 0xa065,
+	0x0148, 0x7020, 0x8001, 0x7022, 0x600c, 0xa015, 0x0150, 0x7216,
+	0x600f, 0x0000, 0x7007, 0x0000, 0x7027, 0x0000, 0x00ce, 0x00ee,
+	0x0005, 0x7216, 0x7212, 0x0cb0, 0x6018, 0x2060, 0x080c, 0x4d4c,
+	0x6000, 0xc0dc, 0x6002, 0x7020, 0x8001, 0x7022, 0x0120, 0x6054,
+	0xa015, 0x0140, 0x721e, 0x7007, 0x0000, 0x7027, 0x0000, 0x00ce,
+	0x00ee, 0x0005, 0x7218, 0x721e, 0x0cb0, 0x7024, 0xa065, 0x0598,
+	0x700c, 0xac06, 0x1160, 0x080c, 0x7dfb, 0x600c, 0xa015, 0x0120,
+	0x720e, 0x600f, 0x0000, 0x0428, 0x720e, 0x720a, 0x0410, 0x7014,
+	0xac06, 0x1160, 0x080c, 0x7dfb, 0x600c, 0xa015, 0x0120, 0x7216,
+	0x600f, 0x0000, 0x00b0, 0x7216, 0x7212, 0x0098, 0x6018, 0x2060,
+	0x080c, 0x4d4c, 0x6000, 0xc0dc, 0x6002, 0x080c, 0x7dfb, 0x701c,
+	0xa065, 0x0138, 0x6054, 0xa015, 0x0110, 0x721e, 0x0010, 0x7218,
+	0x721e, 0x7027, 0x0000, 0x00ce, 0x00ee, 0x0005, 0x7024, 0xa065,
+	0x0140, 0x080c, 0x7dfb, 0x600c, 0xa015, 0x0150, 0x720e, 0x600f,
+	0x0000, 0x080c, 0x7f1b, 0x7027, 0x0000, 0x00ce, 0x00ee, 0x0005,
+	0x720e, 0x720a, 0x0cb0, 0x00d6, 0x2069, 0xb3d9, 0x6830, 0xa084,
+	0x0003, 0x0002, 0x6e60, 0x6e62, 0x6e86, 0x6e5e, 0x080c, 0x14fa,
+	0x00de, 0x0005, 0x00c6, 0x6840, 0xa086, 0x0001, 0x01b8, 0x683c,
+	0xa065, 0x0130, 0x600c, 0xa015, 0x0170, 0x6a3a, 0x600f, 0x0000,
+	0x6833, 0x0000, 0x683f, 0x0000, 0x2011, 0xb3f8, 0x2013, 0x0000,
+	0x00ce, 0x00de, 0x0005, 0x683a, 0x6836, 0x0c90, 0x6843, 0x0000,
+	0x6838, 0xa065, 0x0d68, 0x6003, 0x0003, 0x0c50, 0x00c6, 0x6843,
+	0x0000, 0x6847, 0x0000, 0x683c, 0xa065, 0x0168, 0x600c, 0xa015,
+	0x0130, 0x6a3a, 0x600f, 0x0000, 0x683f, 0x0000, 0x0020, 0x683f,
+	0x0000, 0x683a, 0x6836, 0x00ce, 0x00de, 0x0005, 0x00d6, 0x2069,
+	0xb3d9, 0x6804, 0xa084, 0x0007, 0x0002, 0x6eaf, 0x6f4b, 0x6f4b,
+	0x6f4b, 0x6f4b, 0x6f4d, 0x6ead, 0x6ead, 0x080c, 0x14fa, 0x6820,
+	0xa005, 0x1110, 0x00de, 0x0005, 0x00c6, 0x680c, 0xa065, 0x0150,
+	0x6807, 0x0004, 0x6826, 0x682b, 0x0000, 0x080c, 0x6f9b, 0x00ce,
+	0x00de, 0x0005, 0x6814, 0xa065, 0x0150, 0x6807, 0x0001, 0x6826,
+	0x682b, 0x0000, 0x080c, 0x6f9b, 0x00ce, 0x00de, 0x0005, 0x00e6,
+	0x0036, 0x6a1c, 0xa2f5, 0x0000, 0x0904, 0x6f47, 0x704c, 0xa00d,
+	0x0118, 0x7088, 0xa005, 0x01a0, 0x7054, 0xa075, 0x0120, 0xa20e,
+	0x0904, 0x6f47, 0x0028, 0x6818, 0xa20e, 0x0904, 0x6f47, 0x2070,
+	0x704c, 0xa00d, 0x0d88, 0x7088, 0xa005, 0x1d70, 0x2e00, 0x681e,
+	0x733c, 0x7038, 0xa302, 0x1e40, 0x080c, 0x82c2, 0x0904, 0x6f47,
+	0x8318, 0x733e, 0x6112, 0x2e10, 0x621a, 0xa180, 0x0014, 0x2004,
+	0xa084, 0x00ff, 0x605a, 0xa180, 0x0014, 0x2003, 0x0000, 0xa180,
+	0x0015, 0x2004, 0xa08a, 0x199a, 0x0210, 0x2001, 0x1999, 0x8003,
+	0x801b, 0x831b, 0xa318, 0x6316, 0x003e, 0x00f6, 0x2c78, 0x71a0,
+	0x2001, 0xb134, 0x2004, 0xd0ac, 0x1110, 0xd1bc, 0x0150, 0x7100,
+	0xd1f4, 0x0120, 0x7114, 0xa18c, 0x00ff, 0x0040, 0x2009, 0x0000,
+	0x0028, 0xa1e0, 0x2c8c, 0x2c0d, 0xa18c, 0x00ff, 0x2061, 0x0100,
+	0x619a, 0x080c, 0x75c4, 0x7300, 0xc3dd, 0x7302, 0x6807, 0x0002,
+	0x2f18, 0x6b26, 0x682b, 0x0000, 0x781f, 0x0003, 0x7803, 0x0001,
+	0x7807, 0x0040, 0x00fe, 0x00ee, 0x00ce, 0x00de, 0x0005, 0x003e,
+	0x00ee, 0x00ce, 0x0cd0, 0x00de, 0x0005, 0x00c6, 0x680c, 0xa065,
+	0x0138, 0x6807, 0x0004, 0x6826, 0x682b, 0x0000, 0x080c, 0x6f9b,
+	0x00ce, 0x00de, 0x0005, 0x00f6, 0x00d6, 0x2069, 0xb3d9, 0x6830,
+	0xa086, 0x0000, 0x11c0, 0x2001, 0xb10c, 0x200c, 0xd1bc, 0x1550,
+	0x6838, 0xa07d, 0x0180, 0x6833, 0x0001, 0x683e, 0x6847, 0x0000,
+	0x0126, 0x00f6, 0x2091, 0x2400, 0x002e, 0x080c, 0x1f3c, 0x1130,
+	0x012e, 0x080c, 0x78fd, 0x00de, 0x00fe, 0x0005, 0x012e, 0xe000,
+	0x6843, 0x0000, 0x7803, 0x0002, 0x780c, 0xa015, 0x0140, 0x6a3a,
+	0x780f, 0x0000, 0x6833, 0x0000, 0x683f, 0x0000, 0x0c60, 0x683a,
+	0x6836, 0x0cc0, 0xc1bc, 0x2102, 0x0066, 0x2031, 0x0001, 0x080c,
+	0x5957, 0x006e, 0x0868, 0x601c, 0xa084, 0x000f, 0x000b, 0x0005,
+	0x6fa9, 0x6fae, 0x7465, 0x7581, 0x6fae, 0x7465, 0x7581, 0x6fa9,
+	0x6fae, 0x080c, 0x6dc1, 0x080c, 0x6e9e, 0x0005, 0x0156, 0x0136,
+	0x0146, 0x00c6, 0x00f6, 0x6004, 0xa08a, 0x0080, 0x1a0c, 0x14fa,
+	0x6118, 0x2178, 0x79a0, 0x2011, 0xb134, 0x2214, 0xd2ac, 0x1110,
+	0xd1bc, 0x0150, 0x7900, 0xd1f4, 0x0120, 0x7914, 0xa18c, 0x00ff,
+	0x0040, 0x2009, 0x0000, 0x0028, 0xa1f8, 0x2c8c, 0x2f0d, 0xa18c,
+	0x00ff, 0x2c78, 0x2061, 0x0100, 0x619a, 0xa08a, 0x0040, 0x1a04,
+	0x7022, 0x0033, 0x00fe, 0x00ce, 0x014e, 0x013e, 0x015e, 0x0005,
+	0x70d1, 0x711c, 0x7149, 0x7216, 0x7244, 0x724c, 0x7272, 0x7283,
+	0x7294, 0x729c, 0x72b2, 0x729c, 0x730c, 0x7283, 0x732d, 0x7335,
+	0x7294, 0x7335, 0x7346, 0x7020, 0x7020, 0x7020, 0x7020, 0x7020,
+	0x7020, 0x7020, 0x7020, 0x7020, 0x7020, 0x7020, 0x7b6d, 0x7b92,
+	0x7ba7, 0x7bca, 0x7beb, 0x7272, 0x7020, 0x7272, 0x729c, 0x7020,
+	0x7149, 0x7216, 0x7020, 0x801d, 0x729c, 0x7020, 0x803d, 0x729c,
+	0x7020, 0x7294, 0x70ca, 0x7035, 0x7020, 0x8062, 0x80d7, 0x81ae,
+	0x7020, 0x81bf, 0x726d, 0x81db, 0x7020, 0x7c00, 0x8236, 0x7020,
+	0x080c, 0x14fa, 0x2100, 0x0033, 0x00fe, 0x00ce, 0x014e, 0x013e,
+	0x015e, 0x0005, 0x7033, 0x7033, 0x7033, 0x7069, 0x7087, 0x709d,
+	0x7033, 0x7033, 0x7033, 0x080c, 0x14fa, 0x00d6, 0x20a1, 0x020b,
+	0x080c, 0x7363, 0x7810, 0x2068, 0x20a3, 0x2414, 0x20a3, 0x0018,
+	0x20a3, 0x0800, 0x683c, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x6850, 0x20a2, 0x6854, 0x20a2,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0018, 0x080c, 0x7a79,
+	0x00de, 0x0005, 0x00d6, 0x7818, 0x2068, 0x68a0, 0x2069, 0xb100,
+	0x6ad0, 0xd2ac, 0x1110, 0xd0bc, 0x0110, 0xa085, 0x0001, 0x00de,
+	0x0005, 0x00d6, 0x20a1, 0x020b, 0x080c, 0x7363, 0x20a3, 0x0500,
+	0x20a3, 0x0000, 0x7810, 0xa0e8, 0x000f, 0x6808, 0x20a2, 0x680c,
+	0x20a2, 0x6810, 0x20a2, 0x6814, 0x20a2, 0x6818, 0x20a2, 0x681c,
+	0x20a2, 0x60c3, 0x0010, 0x080c, 0x7a79, 0x00de, 0x0005, 0x0156,
+	0x0146, 0x20a1, 0x020b, 0x080c, 0x7363, 0x20a3, 0x7800, 0x20a3,
+	0x0000, 0x7808, 0x8007, 0x20a2, 0x20a3, 0x0000, 0x60c3, 0x0008,
+	0x080c, 0x7a79, 0x014e, 0x015e, 0x0005, 0x0156, 0x0146, 0x20a1,
+	0x020b, 0x080c, 0x73ff, 0x20a3, 0x0200, 0x20a3, 0x0000, 0x20a3,
+	0xdf10, 0x20a3, 0x0034, 0x2099, 0xb105, 0x20a9, 0x0004, 0x53a6,
+	0x2099, 0xb101, 0x20a9, 0x0004, 0x53a6, 0x2099, 0xb3bf, 0x20a9,
+	0x001a, 0x3304, 0x8007, 0x20a2, 0x9398, 0x1f04, 0x70b9, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x004c, 0x080c, 0x7a79, 0x014e,
+	0x015e, 0x0005, 0x2001, 0xb114, 0x2004, 0x609a, 0x080c, 0x7a79,
+	0x0005, 0x20a1, 0x020b, 0x080c, 0x7363, 0x20a3, 0x5200, 0x20a3,
+	0x0000, 0x00d6, 0x2069, 0xb152, 0x6804, 0xd084, 0x0150, 0x6828,
+	0x20a3, 0x0000, 0x0016, 0x080c, 0x270a, 0x21a2, 0x001e, 0x00de,
+	0x0028, 0x00de, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a9, 0x0004,
+	0x2099, 0xb105, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xb101, 0x53a6,
+	0x2001, 0xb134, 0x2004, 0xd0ac, 0x1138, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa082, 0x007f, 0x0238, 0x2001, 0xb11b, 0x20a6, 0x2001,
+	0xb11c, 0x20a6, 0x0040, 0x20a3, 0x0000, 0x2001, 0xb114, 0x2004,
+	0xa084, 0x00ff, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x001c, 0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b, 0x080c, 0x7363,
+	0x20a3, 0x0500, 0x20a3, 0x0000, 0x2001, 0xb134, 0x2004, 0xd0ac,
+	0x1138, 0x7818, 0xa080, 0x0028, 0x2004, 0xa082, 0x007f, 0x0238,
+	0x2001, 0xb11b, 0x20a6, 0x2001, 0xb11c, 0x20a6, 0x0040, 0x20a3,
+	0x0000, 0x2001, 0xb114, 0x2004, 0xa084, 0x00ff, 0x20a2, 0x20a9,
+	0x0004, 0x2099, 0xb105, 0x53a6, 0x60c3, 0x0010, 0x080c, 0x7a79,
+	0x0005, 0x20a1, 0x020b, 0x080c, 0x7363, 0x00c6, 0x7818, 0x2060,
+	0x2001, 0x0000, 0x080c, 0x5185, 0x00ce, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa086, 0x007e, 0x1130, 0x20a3, 0x0400, 0x620c, 0xc2b4,
+	0x620e, 0x0010, 0x20a3, 0x0300, 0x20a3, 0x0000, 0x7818, 0xa080,
+	0x0028, 0x2004, 0xa086, 0x007e, 0x1904, 0x71d8, 0x2001, 0xb134,
+	0x2004, 0xd0a4, 0x01c8, 0x2099, 0xb38e, 0x33a6, 0x9398, 0x20a3,
+	0x0000, 0x9398, 0x3304, 0xa084, 0x2000, 0x20a2, 0x9398, 0x33a6,
+	0x9398, 0x20a3, 0x0000, 0x9398, 0x2001, 0x2710, 0x20a2, 0x9398,
+	0x33a6, 0x9398, 0x33a6, 0x00d0, 0x2099, 0xb38e, 0x33a6, 0x9398,
+	0x33a6, 0x9398, 0x3304, 0x080c, 0x58d5, 0x1118, 0xa084, 0x37ff,
+	0x0010, 0xa084, 0x3fff, 0x20a2, 0x9398, 0x33a6, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a9, 0x0004,
+	0x2099, 0xb105, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xb101, 0x53a6,
+	0x20a9, 0x0008, 0x20a3, 0x0000, 0x1f04, 0x71b2, 0x20a9, 0x0008,
+	0x20a3, 0x0000, 0x1f04, 0x71b8, 0x2099, 0xb396, 0x3304, 0xc0dd,
+	0x20a2, 0x2001, 0xb172, 0x2004, 0xd0e4, 0x0158, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x9398, 0x9398, 0x9398, 0x33a6, 0x20a9, 0x0004,
+	0x0010, 0x20a9, 0x0007, 0x20a3, 0x0000, 0x1f04, 0x71d3, 0x0468,
+	0x2001, 0xb134, 0x2004, 0xd0a4, 0x0140, 0x2001, 0xb38f, 0x2004,
+	0x60e3, 0x0000, 0x080c, 0x274b, 0x60e2, 0x2099, 0xb38e, 0x20a9,
+	0x0008, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xb105, 0x53a6, 0x20a9,
+	0x0004, 0x2099, 0xb101, 0x53a6, 0x20a9, 0x0008, 0x20a3, 0x0000,
+	0x1f04, 0x71f6, 0x20a9, 0x0008, 0x20a3, 0x0000, 0x1f04, 0x71fc,
+	0x2099, 0xb396, 0x20a9, 0x0008, 0x53a6, 0x20a9, 0x0008, 0x20a3,
+	0x0000, 0x1f04, 0x7207, 0x20a9, 0x000a, 0x20a3, 0x0000, 0x1f04,
+	0x720d, 0x60c3, 0x0074, 0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b,
+	0x080c, 0x7363, 0x20a3, 0x2010, 0x20a3, 0x0014, 0x20a3, 0x0800,
+	0x20a3, 0x2000, 0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a2,
+	0x00f6, 0x2079, 0xb152, 0x7904, 0x00fe, 0xd1ac, 0x1110, 0xa085,
+	0x0020, 0xd1a4, 0x0110, 0xa085, 0x0010, 0xa085, 0x0002, 0x00d6,
+	0x0804, 0x72ee, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0014, 0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b, 0x080c, 0x7363,
+	0x20a3, 0x5000, 0x0804, 0x7164, 0x20a1, 0x020b, 0x080c, 0x7363,
+	0x20a3, 0x2110, 0x20a3, 0x0014, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0014, 0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b, 0x080c,
+	0x73f7, 0x0020, 0x20a1, 0x020b, 0x080c, 0x73ff, 0x20a3, 0x0200,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0004,
+	0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b, 0x080c, 0x73ff, 0x20a3,
+	0x0100, 0x20a3, 0x0000, 0x20a3, 0x0003, 0x20a3, 0x2a00, 0x60c3,
+	0x0008, 0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b, 0x080c, 0x73ff,
+	0x20a3, 0x0200, 0x0804, 0x7164, 0x20a1, 0x020b, 0x080c, 0x73ff,
+	0x20a3, 0x0100, 0x20a3, 0x0000, 0x7828, 0xa005, 0x0110, 0x20a2,
+	0x0010, 0x20a3, 0x0003, 0x7810, 0x20a2, 0x60c3, 0x0008, 0x080c,
+	0x7a79, 0x0005, 0x00d6, 0x20a1, 0x020b, 0x080c, 0x73ff, 0x20a3,
+	0x0210, 0x20a3, 0x0014, 0x20a3, 0x0800, 0x7818, 0x2068, 0x6894,
+	0xa086, 0x0014, 0x1178, 0x6998, 0xa184, 0xc000, 0x1140, 0xd1ec,
+	0x0118, 0x20a3, 0x2100, 0x0040, 0x20a3, 0x0100, 0x0028, 0x20a3,
+	0x0400, 0x0010, 0x20a3, 0x0700, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x20a2, 0x00f6, 0x2079, 0xb152, 0x7904, 0x00fe, 0xd1ac,
+	0x1110, 0xa085, 0x0020, 0xd1a4, 0x0110, 0xa085, 0x0010, 0x2009,
+	0xb174, 0x210c, 0xd184, 0x1110, 0xa085, 0x0002, 0x0026, 0x2009,
+	0xb172, 0x210c, 0xd1e4, 0x0130, 0xc0c5, 0xa094, 0x0030, 0xa296,
+	0x0010, 0x0140, 0xd1ec, 0x0130, 0xa094, 0x0030, 0xa296, 0x0010,
+	0x0108, 0xc0bd, 0x002e, 0x20a2, 0x20a2, 0x20a2, 0x60c3, 0x0014,
+	0x080c, 0x7a79, 0x00de, 0x0005, 0x20a1, 0x020b, 0x080c, 0x73ff,
+	0x20a3, 0x0210, 0x20a3, 0x0014, 0x20a3, 0x0000, 0x20a3, 0x0100,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0014, 0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b, 0x080c,
+	0x73ff, 0x20a3, 0x0200, 0x0804, 0x70d7, 0x20a1, 0x020b, 0x080c,
+	0x73ff, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3, 0x0003, 0x20a3,
+	0x2a00, 0x60c3, 0x0008, 0x080c, 0x7a79, 0x0005, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x20a1, 0x020b, 0x080c, 0x73ff, 0x20a3, 0x0100,
+	0x20a3, 0x0000, 0x20a3, 0x000b, 0x20a3, 0x0000, 0x60c3, 0x0008,
+	0x080c, 0x7a79, 0x0005, 0x0026, 0x0036, 0x0046, 0x2019, 0x3200,
+	0x2021, 0x0800, 0x0038, 0x0026, 0x0036, 0x0046, 0x2019, 0x2200,
+	0x2021, 0x0100, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080,
+	0x0028, 0x2014, 0xa286, 0x007e, 0x11a0, 0xa385, 0x00ff, 0x20a2,
+	0x20a3, 0xfffe, 0x20a3, 0x0000, 0x2011, 0xb114, 0x2214, 0x2001,
+	0xb39e, 0x2004, 0xa005, 0x0118, 0x2011, 0xb11c, 0x2214, 0x22a2,
+	0x04d0, 0xa286, 0x007f, 0x1138, 0x00d6, 0xa385, 0x00ff, 0x20a2,
+	0x20a3, 0xfffd, 0x00c8, 0x2001, 0xb134, 0x2004, 0xd0ac, 0x1110,
+	0xd2bc, 0x01c8, 0xa286, 0x0080, 0x00d6, 0x1130, 0xa385, 0x00ff,
+	0x20a2, 0x20a3, 0xfffc, 0x0040, 0xa2e8, 0xb235, 0x2d6c, 0x6810,
+	0xa305, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xb11b, 0x2da6, 0x8d68,
+	0x2da6, 0x00de, 0x0080, 0x00d6, 0xa2e8, 0xb235, 0x2d6c, 0x6810,
+	0xa305, 0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011,
+	0xb114, 0x2214, 0x22a2, 0xa485, 0x0029, 0x20a2, 0x004e, 0x003e,
+	0x20a3, 0x0000, 0x080c, 0x7a68, 0x22a2, 0x20a3, 0x0000, 0x2fa2,
+	0x20a3, 0xffff, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x002e, 0x0005,
+	0x0026, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x20a3, 0x02ff, 0x2011,
+	0xfffc, 0x22a2, 0x00d6, 0x2069, 0xb11b, 0x2da6, 0x8d68, 0x2da6,
+	0x00de, 0x20a3, 0x2029, 0x20a3, 0x0000, 0x08e0, 0x20a3, 0x0100,
+	0x20a3, 0x0000, 0x20a3, 0xfc02, 0x20a3, 0x0000, 0x0005, 0x0026,
+	0x0036, 0x0046, 0x2019, 0x3300, 0x2021, 0x0800, 0x0038, 0x0026,
+	0x0036, 0x0046, 0x2019, 0x2300, 0x2021, 0x0100, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb134,
+	0x2214, 0xd2ac, 0x1118, 0xa092, 0x007e, 0x02d8, 0x00d6, 0xa0e8,
+	0xb235, 0x2d6c, 0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x6810,
+	0xa005, 0x1140, 0x6814, 0xa005, 0x1128, 0x20a3, 0x00ff, 0x20a3,
+	0xfffe, 0x0028, 0x2069, 0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de,
+	0x0080, 0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa305, 0x20a2,
+	0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb114, 0x2214,
+	0x22a2, 0xa485, 0x0098, 0x20a2, 0x20a3, 0x0000, 0x004e, 0x003e,
+	0x080c, 0x7a68, 0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x002e, 0x0005, 0x080c, 0x7a68,
+	0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2, 0x7810, 0x20a2, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x002e, 0x0005, 0x00c6, 0x00f6, 0x6004,
+	0xa08a, 0x0085, 0x0a0c, 0x14fa, 0xa08a, 0x008c, 0x1a0c, 0x14fa,
+	0x6118, 0x2178, 0x79a0, 0x2011, 0xb134, 0x2214, 0xd2ac, 0x1110,
+	0xd1bc, 0x0150, 0x7900, 0xd1f4, 0x0120, 0x7914, 0xa18c, 0x00ff,
+	0x0040, 0x2009, 0x0000, 0x0028, 0xa1f8, 0x2c8c, 0x2f0d, 0xa18c,
+	0x00ff, 0x2c78, 0x2061, 0x0100, 0x619a, 0xa082, 0x0085, 0x001b,
+	0x00fe, 0x00ce, 0x0005, 0x749c, 0x74a6, 0x74c1, 0x749a, 0x749a,
+	0x749a, 0x749c, 0x080c, 0x14fa, 0x0146, 0x20a1, 0x020b, 0x04a1,
+	0x60c3, 0x0000, 0x080c, 0x7a79, 0x014e, 0x0005, 0x0146, 0x20a1,
+	0x020b, 0x080c, 0x750d, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808,
+	0x20a2, 0x7810, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0xffff, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x000c, 0x080c, 0x7a79, 0x014e,
+	0x0005, 0x0146, 0x20a1, 0x020b, 0x080c, 0x7547, 0x20a3, 0x0003,
+	0x20a3, 0x0300, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0004,
+	0x080c, 0x7a79, 0x014e, 0x0005, 0x0026, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb134, 0x2214,
+	0xd2ac, 0x1118, 0xa092, 0x007e, 0x0288, 0x00d6, 0xa0e8, 0xb235,
+	0x2d6c, 0x6810, 0xa085, 0x8100, 0x20a2, 0x6814, 0x20a2, 0x2069,
+	0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6, 0xa0e8,
+	0xb235, 0x2d6c, 0x6810, 0xa085, 0x8100, 0x20a2, 0x6814, 0x20a2,
+	0x00de, 0x20a3, 0x0000, 0x2011, 0xb114, 0x2214, 0x22a2, 0x20a3,
+	0x0009, 0x20a3, 0x0000, 0x0804, 0x73ca, 0x0026, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb134,
+	0x2214, 0xd2ac, 0x1118, 0xa092, 0x007e, 0x0288, 0x00d6, 0xa0e8,
+	0xb235, 0x2d6c, 0x6810, 0xa085, 0x8400, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6,
+	0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x8400, 0x20a2, 0x6814,
+	0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb114, 0x2214, 0x22a2,
+	0x2001, 0x0099, 0x20a2, 0x20a3, 0x0000, 0x0804, 0x7456, 0x0026,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004,
+	0x2011, 0xb134, 0x2214, 0xd2ac, 0x1118, 0xa092, 0x007e, 0x0288,
+	0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x8500, 0x20a2,
+	0x6814, 0x20a2, 0x2069, 0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de,
+	0x0088, 0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x8500,
+	0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb114,
+	0x2214, 0x22a2, 0x2001, 0x0099, 0x20a2, 0x20a3, 0x0000, 0x0804,
+	0x7456, 0x00c6, 0x00f6, 0x2c78, 0x7804, 0xa08a, 0x0040, 0x0a0c,
+	0x14fa, 0xa08a, 0x0053, 0x1a0c, 0x14fa, 0x7918, 0x2160, 0x61a0,
+	0x2011, 0xb134, 0x2214, 0xd2ac, 0x1110, 0xd1bc, 0x0150, 0x6100,
+	0xd1f4, 0x0120, 0x6114, 0xa18c, 0x00ff, 0x0040, 0x2009, 0x0000,
+	0x0028, 0xa1e0, 0x2c8c, 0x2c0d, 0xa18c, 0x00ff, 0x2061, 0x0100,
+	0x619a, 0xa082, 0x0040, 0x001b, 0x00fe, 0x00ce, 0x0005, 0x75c4,
+	0x76d0, 0x766d, 0x7872, 0x75c2, 0x75c2, 0x75c2, 0x75c2, 0x75c2,
+	0x75c2, 0x75c2, 0x7db4, 0x7dc4, 0x7dd4, 0x7de4, 0x75c2, 0x81ec,
+	0x75c2, 0x7da3, 0x080c, 0x14fa, 0x00d6, 0x0156, 0x0146, 0x780b,
+	0xffff, 0x20a1, 0x020b, 0x080c, 0x7624, 0x7910, 0x2168, 0x6948,
+	0x7952, 0x21a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x694c, 0xa184,
+	0x000f, 0x1118, 0x2001, 0x0005, 0x0040, 0xd184, 0x0118, 0x2001,
+	0x0004, 0x0018, 0xa084, 0x0006, 0x8004, 0x0016, 0x2008, 0x7858,
+	0xa084, 0x00ff, 0x8007, 0xa105, 0x001e, 0x20a2, 0xd1ac, 0x0118,
+	0x20a3, 0x0002, 0x0048, 0xd1b4, 0x0118, 0x20a3, 0x0001, 0x0020,
+	0x20a3, 0x0000, 0x2230, 0x0010, 0x6a80, 0x6e7c, 0x20a9, 0x0008,
+	0x0136, 0xad88, 0x0017, 0x2198, 0x20a1, 0x021b, 0x53a6, 0x013e,
+	0x20a1, 0x020b, 0x22a2, 0x26a2, 0x60c3, 0x0020, 0x20e1, 0x9080,
+	0x6014, 0xa084, 0x0004, 0xa085, 0x0009, 0x6016, 0x2001, 0xb3f5,
+	0x2003, 0x07d0, 0x2001, 0xb3f4, 0x2003, 0x0009, 0x080c, 0x17c3,
+	0x014e, 0x015e, 0x00de, 0x0005, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x7a18, 0xa280, 0x0023, 0x2014, 0x8210, 0xa294, 0x00ff, 0x2202,
+	0x8217, 0x7818, 0xa080, 0x0028, 0x2004, 0x2019, 0xb134, 0x231c,
+	0xd3ac, 0x1110, 0xd0bc, 0x0188, 0x00d6, 0xa0e8, 0xb235, 0x2d6c,
+	0x6810, 0xa085, 0x0600, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xb11b,
+	0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6, 0xa0e8, 0xb235,
+	0x2d6c, 0x6810, 0xa085, 0x0600, 0x20a2, 0x6814, 0x20a2, 0x00de,
+	0x20a3, 0x0000, 0x2009, 0xb114, 0x210c, 0x21a2, 0x20a3, 0x0829,
+	0x20a3, 0x0000, 0x22a2, 0x20a3, 0x0000, 0x2fa2, 0x20a3, 0xffff,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x0005, 0x00d6, 0x0156, 0x0136,
+	0x0146, 0x20a1, 0x020b, 0x00c1, 0x7810, 0x2068, 0x6860, 0x20a2,
+	0x685c, 0x20a2, 0x6880, 0x20a2, 0x687c, 0x20a2, 0xa006, 0x20a2,
+	0x20a2, 0x20a2, 0x20a2, 0x60c3, 0x000c, 0x080c, 0x7a79, 0x014e,
+	0x013e, 0x015e, 0x00de, 0x0005, 0x0026, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb134, 0x2214,
+	0xd2ac, 0x1110, 0xd0bc, 0x0188, 0x00d6, 0xa0e8, 0xb235, 0x2d6c,
+	0x6810, 0xa085, 0x0500, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xb11b,
+	0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6, 0xa0e8, 0xb235,
+	0x2d6c, 0x6810, 0xa085, 0x0500, 0x20a2, 0x6814, 0x20a2, 0x00de,
+	0x20a3, 0x0000, 0x2011, 0xb114, 0x2214, 0x22a2, 0x20a3, 0x0889,
+	0x20a3, 0x0000, 0x080c, 0x7a68, 0x22a2, 0x20a3, 0x0000, 0x7a08,
+	0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x002e, 0x0005,
+	0x00d6, 0x0156, 0x0136, 0x0146, 0x7810, 0xa0ec, 0xf000, 0x0168,
+	0xa06d, 0x080c, 0x5173, 0x0148, 0x684c, 0xa084, 0x2020, 0xa086,
+	0x2020, 0x1118, 0x7820, 0xc0cd, 0x7822, 0x20a1, 0x020b, 0x080c,
+	0x7828, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x7810,
+	0xa084, 0xf000, 0x1130, 0x7810, 0xa084, 0x0700, 0x8007, 0x0043,
+	0x0010, 0xa006, 0x002b, 0x014e, 0x013e, 0x015e, 0x00de, 0x0005,
+	0x770a, 0x779f, 0x77a8, 0x77d1, 0x77e4, 0x77ff, 0x7808, 0x7708,
+	0x080c, 0x14fa, 0x0016, 0x0036, 0x694c, 0xa18c, 0x0003, 0x0118,
+	0xa186, 0x0003, 0x1170, 0x6b78, 0x7820, 0xd0cc, 0x0108, 0xc3e5,
+	0x23a2, 0x6868, 0x20a2, 0x6864, 0x20a2, 0x003e, 0x001e, 0x0804,
+	0x77db, 0xa186, 0x0001, 0x190c, 0x14fa, 0x6b78, 0x7820, 0xd0cc,
+	0x0108, 0xc3e5, 0x23a2, 0x6868, 0x20a2, 0x6864, 0x20a2, 0x22a2,
+	0x6874, 0x20a2, 0x22a2, 0x687c, 0x20a2, 0x2009, 0x0018, 0xa384,
+	0x0300, 0x0904, 0x7799, 0xd3c4, 0x0110, 0x687c, 0xa108, 0xd3cc,
+	0x0110, 0x6874, 0xa108, 0x0156, 0x20a9, 0x000d, 0xad80, 0x0020,
+	0x201c, 0x831f, 0x23a2, 0x8000, 0x1f04, 0x7748, 0x015e, 0x22a2,
+	0x22a2, 0x22a2, 0xa184, 0x0003, 0x0904, 0x7799, 0x20a1, 0x020b,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x0006, 0x7818, 0xa080, 0x0028,
+	0x2004, 0x2011, 0xb134, 0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188,
+	0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2,
+	0x6814, 0x20a2, 0x2069, 0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de,
+	0x0088, 0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x0700,
+	0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb114,
+	0x2214, 0x22a2, 0x000e, 0x7b20, 0xd3cc, 0x0118, 0x20a3, 0x0889,
+	0x0010, 0x20a3, 0x0898, 0x20a2, 0x080c, 0x7a68, 0x22a2, 0x20a3,
+	0x0000, 0x61c2, 0x003e, 0x001e, 0x080c, 0x7a79, 0x0005, 0x2011,
+	0x0008, 0x7820, 0xd0cc, 0x0108, 0xc2e5, 0x22a2, 0xa016, 0x0488,
+	0x2011, 0x0302, 0x7820, 0xd0cc, 0x0108, 0xc2e5, 0x22a2, 0xa016,
+	0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x0012, 0x22a2, 0x20a3, 0x0008,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x7000, 0x20a3, 0x0500,
+	0x22a2, 0x20a3, 0x000a, 0x22a2, 0x22a2, 0x20a3, 0x2500, 0x22a2,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x60c3, 0x0032, 0x080c, 0x7a79,
+	0x0005, 0x2011, 0x0028, 0x7820, 0xd0cc, 0x0108, 0xc2e5, 0x22a2,
+	0xa016, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x60c3,
+	0x0018, 0x080c, 0x7a79, 0x0005, 0x2011, 0x0100, 0x7820, 0xd0cc,
+	0x0108, 0xc2e5, 0x22a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x22a2,
+	0x22a2, 0x20a3, 0x0008, 0x22a2, 0x7854, 0xa084, 0x00ff, 0x20a2,
+	0x22a2, 0x22a2, 0x60c3, 0x0020, 0x080c, 0x7a79, 0x0005, 0x2011,
+	0x0008, 0x7820, 0xd0cc, 0x0108, 0xc2e5, 0x22a2, 0xa016, 0x0888,
+	0x0036, 0x7b10, 0xa384, 0xff00, 0x7812, 0xa384, 0x00ff, 0x8001,
+	0x1138, 0x7820, 0xd0cc, 0x0108, 0xc2e5, 0x22a2, 0x003e, 0x0808,
+	0x0046, 0x2021, 0x0800, 0x0006, 0x7820, 0xd0cc, 0x000e, 0x0108,
+	0xc4e5, 0x24a2, 0x004e, 0x22a2, 0x20a2, 0x003e, 0x0804, 0x77db,
+	0x0026, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028,
+	0x2004, 0x2011, 0xb134, 0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188,
+	0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2,
+	0x6814, 0x20a2, 0x2069, 0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de,
+	0x0088, 0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x0700,
+	0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb114,
+	0x2214, 0x22a2, 0x7820, 0xd0cc, 0x0118, 0x20a3, 0x0889, 0x0010,
+	0x20a3, 0x0898, 0x20a3, 0x0000, 0x080c, 0x7a68, 0x22a2, 0x20a3,
+	0x0000, 0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x002e, 0x0005, 0x00d6, 0x0156, 0x0136, 0x0146, 0x0016, 0x0036,
+	0x7810, 0xa084, 0x0700, 0x8007, 0x003b, 0x003e, 0x001e, 0x014e,
+	0x013e, 0x015e, 0x00de, 0x0005, 0x788c, 0x788c, 0x788e, 0x788c,
+	0x788c, 0x788c, 0x78b0, 0x788c, 0x080c, 0x14fa, 0x7910, 0xa18c,
+	0xf8ff, 0xa18d, 0x0600, 0x7912, 0x20a1, 0x020b, 0x2009, 0x0003,
+	0x00f9, 0x00d6, 0x2069, 0xb152, 0x6804, 0xd0bc, 0x0130, 0x682c,
+	0xa084, 0x00ff, 0x8007, 0x20a2, 0x0010, 0x20a3, 0x3f00, 0x00de,
+	0x22a2, 0x22a2, 0x22a2, 0x60c3, 0x0001, 0x080c, 0x7a79, 0x0005,
+	0x20a1, 0x020b, 0x2009, 0x0003, 0x0019, 0x20a3, 0x7f00, 0x0c80,
+	0x0026, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028,
+	0x2004, 0x2011, 0xb134, 0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188,
+	0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x0100, 0x20a2,
+	0x6814, 0x20a2, 0x2069, 0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de,
+	0x0088, 0x00d6, 0xa0e8, 0xb235, 0x2d6c, 0x6810, 0xa085, 0x0100,
+	0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb114,
+	0x2214, 0x22a2, 0x20a3, 0x0888, 0xa18d, 0x0008, 0x21a2, 0x080c,
+	0x7a68, 0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x002e, 0x0005, 0x00e6, 0x00d6, 0x00c6,
+	0x0056, 0x0046, 0x0036, 0x2061, 0x0100, 0x2071, 0xb100, 0x7150,
+	0x7818, 0x2068, 0x68a0, 0x2028, 0x76d0, 0xd6ac, 0x1130, 0xd0bc,
+	0x1120, 0x6910, 0x6a14, 0x7450, 0x0020, 0x6910, 0x6a14, 0x736c,
+	0x7470, 0x781c, 0xa0be, 0x0006, 0x0904, 0x79b3, 0xa0be, 0x000a,
+	0x15e8, 0xa185, 0x0200, 0x6062, 0x6266, 0x636a, 0x646e, 0x6073,
+	0x2029, 0x6077, 0x0000, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e,
+	0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6082, 0x7808, 0x6086,
+	0x7810, 0x2070, 0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6,
+	0x7008, 0x60ca, 0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000,
+	0x609f, 0x0000, 0x080c, 0x8287, 0x2009, 0x07d0, 0x60c4, 0xa084,
+	0xfff0, 0xa005, 0x0110, 0x2009, 0x1b58, 0x080c, 0x67bb, 0x003e,
+	0x004e, 0x005e, 0x00ce, 0x00de, 0x00ee, 0x0005, 0x70d0, 0xd0ac,
+	0x1110, 0xd5bc, 0x0138, 0xa185, 0x0100, 0x6062, 0x6266, 0x636a,
+	0x646e, 0x0038, 0xa185, 0x0100, 0x6062, 0x6266, 0x606b, 0x0000,
+	0x646e, 0x6073, 0x0809, 0x6077, 0x0008, 0x688c, 0x8000, 0xa084,
+	0x00ff, 0x688e, 0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6082,
+	0x7808, 0x6086, 0x7810, 0x2070, 0x7014, 0x608a, 0x7010, 0x608e,
+	0x700c, 0x60c6, 0x7008, 0x60ca, 0x686c, 0x60ce, 0x60af, 0x95d5,
+	0x60d7, 0x0000, 0xa582, 0x0080, 0x0248, 0x6a00, 0xd2f4, 0x0120,
+	0x6a14, 0xa294, 0x00ff, 0x0010, 0x2011, 0x0000, 0x629e, 0x080c,
+	0x8287, 0x2009, 0x07d0, 0x60c4, 0xa084, 0xfff0, 0xa005, 0x0110,
+	0x2009, 0x1b58, 0x080c, 0x67bb, 0x003e, 0x004e, 0x005e, 0x00ce,
+	0x00de, 0x00ee, 0x0005, 0x7810, 0x2070, 0x704c, 0xa084, 0x0003,
+	0xa086, 0x0002, 0x0904, 0x7a09, 0x2001, 0xb134, 0x2004, 0xd0ac,
+	0x1110, 0xd5bc, 0x0138, 0xa185, 0x0100, 0x6062, 0x6266, 0x636a,
+	0x646e, 0x0038, 0xa185, 0x0100, 0x6062, 0x6266, 0x606b, 0x0000,
+	0x646e, 0x6073, 0x0880, 0x6077, 0x0008, 0x688c, 0x8000, 0xa084,
+	0x00ff, 0x688e, 0x8007, 0x607a, 0x7834, 0x607e, 0x2f00, 0x6086,
+	0x7808, 0x6082, 0x7060, 0x608a, 0x705c, 0x608e, 0x7080, 0x60c6,
+	0x707c, 0x60ca, 0x707c, 0x792c, 0xa108, 0x792e, 0x7080, 0x7928,
+	0xa109, 0x792a, 0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000,
+	0xa582, 0x0080, 0x0248, 0x6a00, 0xd2f4, 0x0120, 0x6a14, 0xa294,
+	0x00ff, 0x0010, 0x2011, 0x0000, 0x629e, 0x080c, 0x8284, 0x0804,
+	0x79a1, 0x2001, 0xb134, 0x2004, 0xd0ac, 0x1110, 0xd5bc, 0x0138,
+	0xa185, 0x0700, 0x6062, 0x6266, 0x636a, 0x646e, 0x0038, 0xa185,
+	0x0700, 0x6062, 0x6266, 0x606b, 0x0000, 0x646e, 0x080c, 0x5173,
+	0x0180, 0x00d6, 0x7810, 0xa06d, 0x684c, 0x00de, 0xa084, 0x2020,
+	0xa086, 0x2020, 0x1130, 0x7820, 0xc0cd, 0x7822, 0x6073, 0x0889,
+	0x0010, 0x6073, 0x0898, 0x6077, 0x0000, 0x688c, 0x8000, 0xa084,
+	0x00ff, 0x688e, 0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6086,
+	0x7808, 0x6082, 0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6,
+	0x7008, 0x60ca, 0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000,
+	0xa582, 0x0080, 0x0248, 0x6a00, 0xd2f4, 0x0120, 0x6a14, 0xa294,
+	0x00ff, 0x0010, 0x2011, 0x0000, 0x629e, 0x7820, 0xd0cc, 0x0120,
+	0x080c, 0x8287, 0x0804, 0x79a1, 0x080c, 0x8284, 0x0804, 0x79a1,
+	0x7a18, 0xa280, 0x0023, 0x2014, 0x8210, 0xa294, 0x00ff, 0x2202,
+	0x8217, 0x0005, 0x00d6, 0x2069, 0xb3d9, 0x6843, 0x0001, 0x00de,
+	0x0005, 0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7, 0x9575, 0x0019,
+	0x080c, 0x67ad, 0x0005, 0x0006, 0x6014, 0xa084, 0x0004, 0xa085,
+	0x0009, 0x6016, 0x000e, 0x0005, 0x0006, 0x00c6, 0x2061, 0x0100,
+	0x6014, 0xa084, 0x0004, 0xa085, 0x0008, 0x6016, 0x00ce, 0x000e,
+	0x0005, 0x00c6, 0x00d6, 0x0016, 0x0026, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x080c, 0x58d5, 0x1198, 0x2001, 0xb3f5, 0x2004, 0xa005,
+	0x15b8, 0x0066, 0x2031, 0x0001, 0x080c, 0x5957, 0x006e, 0x1118,
+	0x080c, 0x67ad, 0x0468, 0x00c6, 0x2061, 0xb3d9, 0x00d8, 0x6904,
+	0xa194, 0x4000, 0x0550, 0x0881, 0x6803, 0x1000, 0x6803, 0x0000,
+	0x00c6, 0x2061, 0xb3d9, 0x6128, 0xa192, 0x00c8, 0x1258, 0x8108,
+	0x612a, 0x6124, 0x00ce, 0x81ff, 0x0198, 0x080c, 0x67ad, 0x080c,
+	0x7a83, 0x0070, 0x6124, 0xa1e5, 0x0000, 0x0140, 0x080c, 0xafee,
+	0x2009, 0x0014, 0x080c, 0x831a, 0x080c, 0x67b6, 0x00ce, 0x0000,
+	0x002e, 0x001e, 0x00de, 0x00ce, 0x0005, 0x2001, 0xb3f5, 0x2004,
+	0xa005, 0x1db0, 0x00c6, 0x2061, 0xb3d9, 0x6128, 0xa192, 0x0003,
+	0x1e08, 0x8108, 0x612a, 0x00ce, 0x080c, 0x67ad, 0x080c, 0x4992,
+	0x0c38, 0x00c6, 0x00d6, 0x00e6, 0x0016, 0x0026, 0x080c, 0x67c3,
+	0x2071, 0xb3d9, 0x713c, 0x81ff, 0x0590, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x080c, 0x58d5, 0x11a8, 0x0036, 0x2019, 0x0002, 0x080c,
+	0x7cc4, 0x003e, 0x713c, 0x2160, 0x080c, 0xafee, 0x2009, 0x004a,
+	0x080c, 0x831a, 0x0066, 0x2031, 0x0001, 0x080c, 0x5957, 0x006e,
+	0x00b0, 0x6904, 0xa194, 0x4000, 0x01c0, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x0036, 0x2019, 0x0001, 0x080c, 0x7cc4, 0x003e, 0x713c,
+	0x2160, 0x080c, 0xafee, 0x2009, 0x004a, 0x080c, 0x831a, 0x002e,
+	0x001e, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x0c58, 0x00e6, 0x00d6,
+	0x00c6, 0x0066, 0x0056, 0x0046, 0x0006, 0x0126, 0x2091, 0x8000,
+	0x6018, 0x2068, 0x6ca0, 0x2071, 0xb3d9, 0x7018, 0x2068, 0x8dff,
+	0x0198, 0x68a0, 0xa406, 0x0118, 0x6854, 0x2068, 0x0cc0, 0x6010,
+	0x2060, 0x643c, 0x6540, 0x6648, 0x2d60, 0x080c, 0x4f8e, 0x0120,
+	0x080c, 0x7dfb, 0xa085, 0x0001, 0x012e, 0x000e, 0x004e, 0x005e,
+	0x006e, 0x00ce, 0x00de, 0x00ee, 0x0005, 0x20a1, 0x020b, 0x080c,
+	0x7363, 0x20a3, 0x1200, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x781c,
+	0xa086, 0x0004, 0x1110, 0x6098, 0x0018, 0x2001, 0xb114, 0x2004,
+	0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a9, 0x0010, 0xa006,
+	0x20a2, 0x1f04, 0x7b88, 0x20a2, 0x20a2, 0x60c3, 0x002c, 0x080c,
+	0x7a79, 0x0005, 0x0156, 0x0146, 0x20a1, 0x020b, 0x080c, 0x7363,
+	0x20a3, 0x0f00, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808, 0x20a2,
+	0x60c3, 0x0008, 0x080c, 0x7a79, 0x014e, 0x015e, 0x0005, 0x0156,
+	0x0146, 0x20a1, 0x020b, 0x080c, 0x73ff, 0x20a3, 0x0200, 0x20a3,
+	0x0000, 0x20a9, 0x0006, 0x2011, 0xb140, 0x2019, 0xb141, 0x23a6,
+	0x22a6, 0xa398, 0x0002, 0xa290, 0x0002, 0x1f04, 0x7bb7, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x001c, 0x080c, 0x7a79, 0x014e,
+	0x015e, 0x0005, 0x0156, 0x0146, 0x0016, 0x0026, 0x20a1, 0x020b,
+	0x080c, 0x73d8, 0x080c, 0x73ee, 0x7810, 0xa080, 0x0000, 0x2004,
+	0xa080, 0x0015, 0x2098, 0x7808, 0xa088, 0x0002, 0x21a8, 0x53a6,
+	0xa080, 0x0004, 0x8003, 0x60c2, 0x080c, 0x7a79, 0x002e, 0x001e,
+	0x014e, 0x015e, 0x0005, 0x0156, 0x0146, 0x20a1, 0x020b, 0x080c,
+	0x7363, 0x20a3, 0x6200, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808,
+	0x20a2, 0x60c3, 0x0008, 0x080c, 0x7a79, 0x014e, 0x015e, 0x0005,
+	0x0156, 0x0146, 0x0016, 0x0026, 0x20a1, 0x020b, 0x080c, 0x7363,
+	0x7810, 0xa080, 0x0000, 0x2004, 0xa080, 0x0017, 0x2098, 0x7808,
+	0xa088, 0x0002, 0x21a8, 0x53a6, 0x8003, 0x60c2, 0x080c, 0x7a79,
+	0x002e, 0x001e, 0x014e, 0x015e, 0x0005, 0x00e6, 0x00c6, 0x0006,
+	0x0126, 0x2091, 0x8000, 0x2071, 0xb3d9, 0x700c, 0x2060, 0x8cff,
+	0x0178, 0x080c, 0x9a66, 0x1110, 0x080c, 0x8890, 0x600c, 0x0006,
+	0x080c, 0x9c2d, 0x080c, 0x82eb, 0x080c, 0x7dfb, 0x00ce, 0x0c78,
+	0x700f, 0x0000, 0x700b, 0x0000, 0x012e, 0x000e, 0x00ce, 0x00ee,
+	0x0005, 0x0126, 0x0156, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0026,
+	0x0016, 0x0006, 0x2091, 0x8000, 0x2069, 0x0100, 0x2079, 0x0140,
+	0x2071, 0xb3d9, 0x7024, 0x2060, 0x8cff, 0x05a0, 0x080c, 0x7a8c,
+	0x68c3, 0x0000, 0x080c, 0x67b6, 0x2009, 0x0013, 0x080c, 0x831a,
+	0x20a9, 0x01f4, 0x6824, 0xd094, 0x0158, 0x6827, 0x0004, 0x7804,
+	0xa084, 0x4000, 0x01a0, 0x7803, 0x1000, 0x7803, 0x0000, 0x0078,
+	0xd084, 0x0118, 0x6827, 0x0001, 0x0010, 0x1f04, 0x7c62, 0x7804,
+	0xa084, 0x1000, 0x0120, 0x7803, 0x0100, 0x7803, 0x0000, 0x6824,
+	0x000e, 0x001e, 0x002e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x015e,
+	0x012e, 0x0005, 0x2001, 0xb100, 0x2004, 0xa096, 0x0001, 0x0550,
+	0xa096, 0x0004, 0x0538, 0x6817, 0x0008, 0x68c3, 0x0000, 0x2011,
+	0x494f, 0x080c, 0x6742, 0x20a9, 0x01f4, 0x6824, 0xd094, 0x0158,
+	0x6827, 0x0004, 0x7804, 0xa084, 0x4000, 0x01a0, 0x7803, 0x1000,
+	0x7803, 0x0000, 0x0078, 0xd084, 0x0118, 0x6827, 0x0001, 0x0010,
+	0x1f04, 0x7c9d, 0x7804, 0xa084, 0x1000, 0x0120, 0x7803, 0x0100,
+	0x7803, 0x0000, 0x000e, 0x001e, 0x002e, 0x00ce, 0x00de, 0x00ee,
+	0x00fe, 0x015e, 0x012e, 0x0005, 0x0126, 0x0156, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0026, 0x0016, 0x0006, 0x2091, 0x8000, 0x2069,
+	0x0100, 0x2079, 0x0140, 0x2071, 0xb3d9, 0x703c, 0x2060, 0x8cff,
+	0x0904, 0x7d48, 0x6814, 0xa084, 0x0002, 0x0904, 0x7d48, 0x68af,
+	0x95f5, 0x6817, 0x0010, 0x2009, 0x00fa, 0x8109, 0x1df0, 0x68c7,
+	0x0000, 0x68cb, 0x0008, 0x080c, 0x67c3, 0x080c, 0x2120, 0x0046,
+	0x2009, 0x017f, 0x200b, 0x00a5, 0x2021, 0x0169, 0x2404, 0xa084,
+	0x000f, 0xa086, 0x0004, 0x1500, 0x68af, 0x95f5, 0x68c7, 0x0000,
+	0x68cb, 0x0008, 0x00e6, 0x00f6, 0x2079, 0x0020, 0x2071, 0xb43a,
+	0x6814, 0xa084, 0x0184, 0xa085, 0x0012, 0x6816, 0x7803, 0x0008,
+	0x7003, 0x0000, 0x00fe, 0x00ee, 0xa386, 0x0002, 0x1128, 0x7884,
+	0xa005, 0x1110, 0x7887, 0x0001, 0x2001, 0xb3b0, 0x2004, 0x200a,
+	0x004e, 0xa39d, 0x0000, 0x1120, 0x2009, 0x0049, 0x080c, 0x831a,
+	0x20a9, 0x03e8, 0x6824, 0xd094, 0x0158, 0x6827, 0x0004, 0x7804,
+	0xa084, 0x4000, 0x01a0, 0x7803, 0x1000, 0x7803, 0x0000, 0x0078,
+	0xd08c, 0x0118, 0x6827, 0x0002, 0x0010, 0x1f04, 0x7d2a, 0x7804,
+	0xa084, 0x1000, 0x0120, 0x7803, 0x0100, 0x7803, 0x0000, 0x6824,
+	0x000e, 0x001e, 0x002e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x015e,
+	0x012e, 0x0005, 0x00d6, 0x0126, 0x2091, 0x8000, 0x2069, 0xb3d9,
+	0x6a06, 0x012e, 0x00de, 0x0005, 0x00d6, 0x0126, 0x2091, 0x8000,
+	0x2069, 0xb3d9, 0x6a32, 0x012e, 0x00de, 0x0005, 0x00f6, 0x00e6,
+	0x00c6, 0x0066, 0x0006, 0x0126, 0x2071, 0xb3d9, 0x7614, 0x2660,
+	0x2678, 0x2091, 0x8000, 0x8cff, 0x0538, 0x601c, 0xa206, 0x1500,
+	0x7014, 0xac36, 0x1110, 0x660c, 0x7616, 0x7010, 0xac36, 0x1140,
+	0x2c00, 0xaf36, 0x0118, 0x2f00, 0x7012, 0x0010, 0x7013, 0x0000,
+	0x660c, 0x0066, 0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678,
+	0x600f, 0x0000, 0x080c, 0x9a2b, 0x080c, 0x7dfb, 0x00ce, 0x08d8,
+	0x2c78, 0x600c, 0x2060, 0x08b8, 0x012e, 0x000e, 0x006e, 0x00ce,
+	0x00ee, 0x00fe, 0x0005, 0x0156, 0x0146, 0x20a1, 0x020b, 0x080c,
+	0x7624, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2,
+	0x20a3, 0x1000, 0x0804, 0x7df3, 0x0156, 0x0146, 0x20a1, 0x020b,
+	0x080c, 0x7624, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x20a3, 0x4000, 0x0478, 0x0156, 0x0146, 0x20a1, 0x020b,
+	0x080c, 0x7624, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x20a3, 0x2000, 0x00f8, 0x0156, 0x0146, 0x20a1, 0x020b,
+	0x080c, 0x7624, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x20a3, 0x0400, 0x0078, 0x0156, 0x0146, 0x20a1, 0x020b,
+	0x080c, 0x7624, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x20a3, 0x0200, 0x0089, 0x60c3, 0x0020, 0x080c, 0x7a79,
+	0x014e, 0x015e, 0x0005, 0x00e6, 0x2071, 0xb3d9, 0x7020, 0xa005,
+	0x0110, 0x8001, 0x7022, 0x00ee, 0x0005, 0x20a9, 0x0008, 0x20a2,
+	0x1f04, 0x7e07, 0x20a2, 0x20a2, 0x0005, 0x00f6, 0x00e6, 0x00d6,
+	0x00c6, 0x0076, 0x0066, 0x0006, 0x0126, 0x2091, 0x8000, 0x2071,
+	0xb3d9, 0x7614, 0x2660, 0x2678, 0x2039, 0x0001, 0x87ff, 0x0904,
+	0x7e97, 0x8cff, 0x0904, 0x7e97, 0x601c, 0xa086, 0x0006, 0x1904,
+	0x7e92, 0x88ff, 0x0138, 0x2800, 0xac06, 0x1904, 0x7e92, 0x2039,
+	0x0000, 0x0050, 0x6018, 0xa206, 0x1904, 0x7e92, 0x85ff, 0x0120,
+	0x6050, 0xa106, 0x1904, 0x7e92, 0x7024, 0xac06, 0x1538, 0x2069,
+	0x0100, 0x68c0, 0xa005, 0x01f0, 0x080c, 0x67b6, 0x6817, 0x0008,
+	0x68c3, 0x0000, 0x080c, 0x7f1b, 0x7027, 0x0000, 0x0036, 0x2069,
+	0x0140, 0x6b04, 0xa384, 0x1000, 0x0120, 0x6803, 0x0100, 0x6803,
+	0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001,
+	0x003e, 0x0020, 0x6003, 0x0009, 0x630a, 0x0460, 0x7014, 0xac36,
+	0x1110, 0x660c, 0x7616, 0x7010, 0xac36, 0x1140, 0x2c00, 0xaf36,
+	0x0118, 0x2f00, 0x7012, 0x0010, 0x7013, 0x0000, 0x660c, 0x0066,
+	0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x89ff, 0x1158,
+	0x600f, 0x0000, 0x6010, 0x2068, 0x080c, 0x986a, 0x0110, 0x080c,
+	0xac5f, 0x080c, 0x9a2b, 0x080c, 0x7dfb, 0x88ff, 0x1190, 0x00ce,
+	0x0804, 0x7e1e, 0x2c78, 0x600c, 0x2060, 0x0804, 0x7e1e, 0xa006,
+	0x012e, 0x000e, 0x006e, 0x007e, 0x00ce, 0x00de, 0x00ee, 0x00fe,
+	0x0005, 0x6017, 0x0000, 0x00ce, 0xa8c5, 0x0001, 0x0c88, 0x00f6,
+	0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0026, 0x0006, 0x0126, 0x2091,
+	0x8000, 0x2071, 0xb3d9, 0x7638, 0x2660, 0x2678, 0x8cff, 0x0904,
+	0x7f0b, 0x601c, 0xa086, 0x0006, 0x1904, 0x7f06, 0x87ff, 0x0128,
+	0x2700, 0xac06, 0x1904, 0x7f06, 0x0040, 0x6018, 0xa206, 0x15f0,
+	0x85ff, 0x0118, 0x6050, 0xa106, 0x15c8, 0x703c, 0xac06, 0x1170,
+	0x0036, 0x2019, 0x0001, 0x080c, 0x7cc4, 0x7033, 0x0000, 0x703f,
+	0x0000, 0x7043, 0x0000, 0x7047, 0x0000, 0x003e, 0x7038, 0xac36,
+	0x1110, 0x660c, 0x763a, 0x7034, 0xac36, 0x1140, 0x2c00, 0xaf36,
+	0x0118, 0x2f00, 0x7036, 0x0010, 0x7037, 0x0000, 0x660c, 0x0066,
+	0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000,
+	0x6010, 0x2068, 0x080c, 0x986a, 0x0110, 0x080c, 0xac5f, 0x080c,
+	0x9a2b, 0x87ff, 0x1190, 0x00ce, 0x0804, 0x7eb6, 0x2c78, 0x600c,
+	0x2060, 0x0804, 0x7eb6, 0xa006, 0x012e, 0x000e, 0x002e, 0x006e,
+	0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x6017, 0x0000, 0x00ce,
+	0xa7bd, 0x0001, 0x0c88, 0x00e6, 0x2071, 0xb3d9, 0x2001, 0xb100,
+	0x2004, 0xa086, 0x0002, 0x1118, 0x7007, 0x0005, 0x0010, 0x7007,
+	0x0000, 0x00ee, 0x0005, 0x00f6, 0x00e6, 0x00c6, 0x0066, 0x0026,
+	0x0006, 0x0126, 0x2091, 0x8000, 0x2071, 0xb3d9, 0x2c10, 0x7638,
+	0x2660, 0x2678, 0x8cff, 0x0518, 0x2200, 0xac06, 0x11e0, 0x7038,
+	0xac36, 0x1110, 0x660c, 0x763a, 0x7034, 0xac36, 0x1140, 0x2c00,
+	0xaf36, 0x0118, 0x2f00, 0x7036, 0x0010, 0x7037, 0x0000, 0x660c,
+	0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000,
+	0xa085, 0x0001, 0x0020, 0x2c78, 0x600c, 0x2060, 0x08d8, 0x012e,
+	0x000e, 0x002e, 0x006e, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x00f6,
+	0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0006, 0x0126, 0x2091, 0x8000,
+	0x2071, 0xb3d9, 0x760c, 0x2660, 0x2678, 0x8cff, 0x0904, 0x7ff1,
+	0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x1904, 0x7fec, 0x7024,
+	0xac06, 0x1508, 0x2069, 0x0100, 0x68c0, 0xa005, 0x0904, 0x7fc8,
+	0x080c, 0x7a8c, 0x68c3, 0x0000, 0x080c, 0x7f1b, 0x7027, 0x0000,
+	0x0036, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0120, 0x6803,
+	0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110,
+	0x6827, 0x0001, 0x003e, 0x700c, 0xac36, 0x1110, 0x660c, 0x760e,
+	0x7008, 0xac36, 0x1140, 0x2c00, 0xaf36, 0x0118, 0x2f00, 0x700a,
+	0x0010, 0x700b, 0x0000, 0x660c, 0x0066, 0x2c00, 0xaf06, 0x0110,
+	0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x080c, 0x9a55, 0x1158,
+	0x080c, 0x2b99, 0x080c, 0x9a66, 0x11f0, 0x080c, 0x8890, 0x00d8,
+	0x080c, 0x7f1b, 0x08c0, 0x080c, 0x9a66, 0x1118, 0x080c, 0x8890,
+	0x0090, 0x6010, 0x2068, 0x080c, 0x986a, 0x0168, 0x601c, 0xa086,
+	0x0003, 0x11f8, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c,
+	0x5271, 0x080c, 0x9a1f, 0x080c, 0x9c2d, 0x080c, 0x9a2b, 0x080c,
+	0x7dfb, 0x00ce, 0x0804, 0x7f75, 0x2c78, 0x600c, 0x2060, 0x0804,
+	0x7f75, 0x012e, 0x000e, 0x006e, 0x00ce, 0x00de, 0x00ee, 0x00fe,
+	0x0005, 0x601c, 0xa086, 0x0006, 0x1d30, 0x080c, 0xac5f, 0x0c18,
+	0x0036, 0x0156, 0x0136, 0x0146, 0x3908, 0xa006, 0xa190, 0x0020,
+	0x221c, 0xa39e, 0x2990, 0x1118, 0x8210, 0x8000, 0x0cc8, 0xa005,
+	0x0138, 0x20a9, 0x0020, 0x2198, 0xa110, 0x22a0, 0x22c8, 0x53a3,
+	0x014e, 0x013e, 0x015e, 0x003e, 0x0005, 0x00d6, 0x20a1, 0x020b,
+	0x080c, 0x73ff, 0x20a3, 0x0200, 0x20a3, 0x0014, 0x60c3, 0x0014,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x2099, 0xb3b8, 0x20a9, 0x0004,
+	0x53a6, 0x20a3, 0x0004, 0x20a3, 0x7878, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x080c, 0x7a79, 0x00de, 0x0005, 0x20a1, 0x020b, 0x080c,
+	0x73ff, 0x20a3, 0x0214, 0x20a3, 0x0018, 0x20a3, 0x0800, 0x7810,
+	0xa084, 0xff00, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x7810, 0xa084, 0x00ff, 0x20a2, 0x7828,
+	0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0018, 0x080c,
+	0x7a79, 0x0005, 0x00d6, 0x0016, 0x2f68, 0x2009, 0x0035, 0x080c,
+	0x9d16, 0x1904, 0x80d0, 0x20a1, 0x020b, 0x080c, 0x7363, 0x20a3,
+	0x1300, 0x20a3, 0x0000, 0x7828, 0x2068, 0x681c, 0xa086, 0x0003,
+	0x0580, 0x7818, 0xa080, 0x0028, 0x2014, 0x2001, 0xb134, 0x2004,
+	0xd0ac, 0x11d0, 0xa286, 0x007e, 0x1128, 0x20a3, 0x00ff, 0x20a3,
+	0xfffe, 0x04b8, 0xa286, 0x007f, 0x1128, 0x20a3, 0x00ff, 0x20a3,
+	0xfffd, 0x0478, 0xd2bc, 0x0180, 0xa286, 0x0080, 0x1128, 0x20a3,
+	0x00ff, 0x20a3, 0xfffc, 0x0428, 0xa2e8, 0xb235, 0x2d6c, 0x6810,
+	0x20a2, 0x6814, 0x20a2, 0x00e8, 0x20a3, 0x0000, 0x6098, 0x20a2,
+	0x00c0, 0x2001, 0xb134, 0x2004, 0xd0ac, 0x1138, 0x7818, 0xa080,
+	0x0028, 0x2004, 0xa082, 0x007e, 0x0240, 0x00d6, 0x2069, 0xb11b,
+	0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0020, 0x20a3, 0x0000, 0x6034,
+	0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x60c3, 0x000c, 0x080c, 0x7a79, 0x001e, 0x00de, 0x0005,
+	0x7817, 0x0001, 0x7803, 0x0006, 0x001e, 0x00de, 0x0005, 0x00d6,
+	0x0026, 0x7928, 0x2168, 0x691c, 0xa186, 0x0006, 0x01c0, 0xa186,
+	0x0003, 0x0904, 0x8146, 0xa186, 0x0005, 0x0904, 0x812f, 0xa186,
+	0x0004, 0x05b8, 0xa186, 0x0008, 0x0904, 0x8137, 0x7807, 0x0037,
+	0x7813, 0x1700, 0x080c, 0x81ae, 0x002e, 0x00de, 0x0005, 0x080c,
+	0x816a, 0x2009, 0x4000, 0x6800, 0x0002, 0x8110, 0x811b, 0x8112,
+	0x811b, 0x8117, 0x8110, 0x8110, 0x811b, 0x811b, 0x811b, 0x811b,
+	0x8110, 0x8110, 0x8110, 0x8110, 0x8110, 0x811b, 0x8110, 0x811b,
+	0x080c, 0x14fa, 0x6820, 0xd0e4, 0x0110, 0xd0cc, 0x0110, 0xa00e,
+	0x0010, 0x2009, 0x2000, 0x6828, 0x20a2, 0x682c, 0x20a2, 0x0804,
+	0x8160, 0x080c, 0x816a, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009,
+	0x4000, 0x6a00, 0xa286, 0x0002, 0x1108, 0xa00e, 0x0488, 0x04d1,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000, 0x0448, 0x0491,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000, 0xa286, 0x0005,
+	0x0118, 0xa286, 0x0002, 0x1108, 0xa00e, 0x00d0, 0x0419, 0x6810,
+	0x2068, 0x697c, 0x6810, 0xa112, 0x6980, 0x6814, 0xa103, 0x20a2,
+	0x22a2, 0x7928, 0xa180, 0x0000, 0x2004, 0xa08e, 0x0002, 0x0130,
+	0xa08e, 0x0004, 0x0118, 0x2009, 0x4000, 0x0010, 0x2009, 0x0000,
+	0x21a2, 0x20a3, 0x0000, 0x60c3, 0x0018, 0x080c, 0x7a79, 0x002e,
+	0x00de, 0x0005, 0x0036, 0x0046, 0x0056, 0x0066, 0x20a1, 0x020b,
+	0x080c, 0x73ff, 0xa006, 0x20a3, 0x0200, 0x20a2, 0x7934, 0x21a2,
+	0x7938, 0x21a2, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb134,
+	0x2214, 0xd2ac, 0x1118, 0xa092, 0x007e, 0x0268, 0x00d6, 0x2069,
+	0xb11b, 0x2d2c, 0x8d68, 0x2d34, 0xa0e8, 0xb235, 0x2d6c, 0x6b10,
+	0x6c14, 0x00de, 0x0030, 0x2019, 0x0000, 0x6498, 0x2029, 0x0000,
+	0x6634, 0x7828, 0xa080, 0x0007, 0x2004, 0xa086, 0x0003, 0x1128,
+	0x25a2, 0x26a2, 0x23a2, 0x24a2, 0x0020, 0x23a2, 0x24a2, 0x25a2,
+	0x26a2, 0x006e, 0x005e, 0x004e, 0x003e, 0x0005, 0x20a1, 0x020b,
+	0x080c, 0x73ff, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3, 0x0009,
+	0x7810, 0x20a2, 0x60c3, 0x0008, 0x080c, 0x7a79, 0x0005, 0x20a1,
+	0x020b, 0x080c, 0x735b, 0x20a3, 0x1400, 0x20a3, 0x0000, 0x7834,
+	0x20a2, 0x7838, 0x20a2, 0x7828, 0x20a2, 0x782c, 0x20a2, 0x7830,
+	0xa084, 0x00ff, 0x8007, 0x20a2, 0x20a3, 0x0000, 0x60c3, 0x0010,
+	0x080c, 0x7a79, 0x0005, 0x20a1, 0x020b, 0x080c, 0x73f7, 0x20a3,
+	0x0100, 0x20a3, 0x0000, 0x7828, 0x20a2, 0x7810, 0x20a2, 0x60c3,
+	0x0008, 0x080c, 0x7a79, 0x0005, 0x0146, 0x20a1, 0x020b, 0x0031,
+	0x60c3, 0x0000, 0x080c, 0x7a79, 0x014e, 0x0005, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb134,
+	0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188, 0x00d6, 0xa0e8, 0xb235,
+	0x2d6c, 0x6810, 0xa085, 0x0300, 0x20a2, 0x6814, 0x20a2, 0x2069,
+	0xb11b, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0078, 0x00d6, 0xa0e8,
+	0xb235, 0x2d6c, 0x6810, 0xa085, 0x0300, 0x20a2, 0x6814, 0x20a2,
+	0x00de, 0x20a3, 0x0000, 0x6234, 0x22a2, 0x20a3, 0x0819, 0x20a3,
+	0x0000, 0x080c, 0x7a68, 0x22a2, 0x20a3, 0x0000, 0x2fa2, 0x7a08,
+	0x22a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x0005, 0x20a1, 0x020b,
+	0x0079, 0x7910, 0x21a2, 0x20a3, 0x0000, 0x60c3, 0x0000, 0x20e1,
+	0x9080, 0x60a7, 0x9575, 0x080c, 0x7a83, 0x080c, 0x67ad, 0x0005,
+	0x0156, 0x0136, 0x0036, 0x00d6, 0x00e6, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x7854, 0x2068, 0xadf0, 0x000f, 0x7210, 0xa296, 0x00c0,
+	0xa294, 0xfffd, 0x7212, 0x7214, 0xa294, 0x0300, 0x7216, 0x7100,
+	0xa194, 0x00ff, 0x7308, 0xa384, 0x00ff, 0xa08d, 0xc200, 0x7102,
+	0xa384, 0xff00, 0xa215, 0x720a, 0x7004, 0x720c, 0x700e, 0x7206,
+	0x20a9, 0x000a, 0x2e98, 0x53a6, 0x60a3, 0x0035, 0x6a38, 0xa294,
+	0x7000, 0xa286, 0x3000, 0x0110, 0x60a3, 0x0037, 0x00ee, 0x00de,
+	0x003e, 0x013e, 0x015e, 0x0005, 0x2009, 0x0092, 0x0010, 0x2009,
+	0x0096, 0x60ab, 0x0036, 0x6116, 0x0005, 0x2061, 0xb800, 0x2a70,
+	0x7064, 0x7046, 0x704b, 0xb800, 0x0005, 0x00e6, 0x0126, 0x2071,
+	0xb100, 0x2091, 0x8000, 0x7544, 0xa582, 0x0010, 0x0608, 0x7048,
+	0x2060, 0x6000, 0xa086, 0x0000, 0x0148, 0xace0, 0x0018, 0x7058,
+	0xac02, 0x1208, 0x0cb0, 0x2061, 0xb800, 0x0c98, 0x6003, 0x0008,
+	0x8529, 0x7546, 0xaca8, 0x0018, 0x7058, 0xa502, 0x1230, 0x754a,
+	0xa085, 0x0001, 0x012e, 0x00ee, 0x0005, 0x704b, 0xb800, 0x0cc0,
+	0xa006, 0x0cc0, 0x00e6, 0x2071, 0xb100, 0x7544, 0xa582, 0x0010,
+	0x0600, 0x7048, 0x2060, 0x6000, 0xa086, 0x0000, 0x0148, 0xace0,
+	0x0018, 0x7058, 0xac02, 0x1208, 0x0cb0, 0x2061, 0xb800, 0x0c98,
+	0x6003, 0x0008, 0x8529, 0x7546, 0xaca8, 0x0018, 0x7058, 0xa502,
+	0x1228, 0x754a, 0xa085, 0x0001, 0x00ee, 0x0005, 0x704b, 0xb800,
+	0x0cc8, 0xa006, 0x0cc8, 0xac82, 0xb800, 0x0a0c, 0x14fa, 0x2001,
+	0xb116, 0x2004, 0xac02, 0x1a0c, 0x14fa, 0xa006, 0x6006, 0x600a,
+	0x600e, 0x6012, 0x6016, 0x601a, 0x601f, 0x0000, 0x6003, 0x0000,
+	0x6052, 0x6056, 0x6022, 0x6026, 0x602a, 0x602e, 0x6032, 0x6036,
+	0x603a, 0x603e, 0x2061, 0xb100, 0x6044, 0x8000, 0x6046, 0xa086,
+	0x0001, 0x0108, 0x0005, 0x0126, 0x2091, 0x8000, 0x080c, 0x6e9e,
+	0x012e, 0x0cc0, 0x601c, 0xa084, 0x000f, 0x0002, 0x8329, 0x8338,
+	0x8353, 0x836e, 0x9d43, 0x9d5e, 0x9d79, 0x8329, 0x8338, 0x8329,
+	0x8389, 0xa186, 0x0013, 0x1128, 0x080c, 0x6dc1, 0x080c, 0x6e9e,
+	0x0005, 0xa18e, 0x0047, 0x1118, 0xa016, 0x080c, 0x1828, 0x0005,
+	0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c, 0x14fa, 0x0013, 0x006e,
+	0x0005, 0x8351, 0x8722, 0x88ca, 0x8351, 0x893f, 0x8442, 0x8351,
+	0x8351, 0x86b4, 0x8d40, 0x8351, 0x8351, 0x8351, 0x8351, 0x8351,
+	0x8351, 0x080c, 0x14fa, 0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c,
+	0x14fa, 0x0013, 0x006e, 0x0005, 0x836c, 0x935a, 0x836c, 0x836c,
+	0x836c, 0x836c, 0x836c, 0x836c, 0x9305, 0x94c0, 0x836c, 0x9387,
+	0x93fe, 0x9387, 0x93fe, 0x836c, 0x080c, 0x14fa, 0x0066, 0x6000,
+	0xa0b2, 0x0010, 0x1a0c, 0x14fa, 0x0013, 0x006e, 0x0005, 0x8387,
+	0x8d81, 0x8e47, 0x8f75, 0x90cf, 0x8387, 0x8387, 0x8387, 0x8d5b,
+	0x92b5, 0x92b8, 0x8387, 0x8387, 0x8387, 0x8387, 0x92e2, 0x080c,
+	0x14fa, 0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c, 0x14fa, 0x0013,
+	0x006e, 0x0005, 0x83a2, 0x83a2, 0x83a2, 0x83c5, 0x8418, 0x83a2,
+	0x83a2, 0x83a2, 0x83a4, 0x83a2, 0x83a2, 0x83a2, 0x83a2, 0x83a2,
+	0x83a2, 0x83a2, 0x080c, 0x14fa, 0xa186, 0x0003, 0x190c, 0x14fa,
+	0x00d6, 0x6003, 0x0003, 0x6106, 0x6010, 0x2068, 0x684f, 0x0040,
+	0x687c, 0x680a, 0x6880, 0x680e, 0x6813, 0x0000, 0x6817, 0x0000,
+	0x00de, 0x2c10, 0x080c, 0x1ec4, 0x080c, 0x6a59, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x6f5b, 0x012e, 0x0005, 0xa182, 0x0047, 0x0002,
+	0x83d1, 0x83d1, 0x83d3, 0x83f2, 0x83d1, 0x83d1, 0x83d1, 0x83d1,
+	0x8404, 0x080c, 0x14fa, 0x00d6, 0x0016, 0x080c, 0x6e53, 0x080c,
+	0x6f5b, 0x6003, 0x0004, 0x6110, 0x2168, 0x6854, 0x8003, 0x800b,
+	0x810b, 0xa108, 0x6116, 0x684f, 0x0020, 0x685c, 0x685a, 0x6874,
+	0x687e, 0x6878, 0x6882, 0x6897, 0x0000, 0x689b, 0x0000, 0x001e,
+	0x00de, 0x0005, 0x080c, 0x6e53, 0x00d6, 0x6110, 0x2168, 0x080c,
+	0x986a, 0x0120, 0x684b, 0x0006, 0x080c, 0x5271, 0x00de, 0x080c,
+	0x82eb, 0x080c, 0x6f5b, 0x0005, 0x080c, 0x6e53, 0x080c, 0x2b73,
+	0x00d6, 0x6110, 0x2168, 0x080c, 0x986a, 0x0120, 0x684b, 0x0029,
+	0x080c, 0x5271, 0x00de, 0x080c, 0x82eb, 0x080c, 0x6f5b, 0x0005,
+	0xa182, 0x0047, 0x0002, 0x8426, 0x8435, 0x8424, 0x8424, 0x8424,
+	0x8424, 0x8424, 0x8424, 0x8424, 0x080c, 0x14fa, 0x00d6, 0x6010,
+	0x2068, 0x684c, 0xc0f4, 0x684e, 0x00de, 0x20e1, 0x0005, 0x3d18,
+	0x3e20, 0x2c10, 0x080c, 0x1828, 0x0005, 0x00d6, 0x6110, 0x2168,
+	0x684b, 0x0000, 0x6853, 0x0000, 0x080c, 0x5271, 0x00de, 0x080c,
+	0x82eb, 0x0005, 0xa1b6, 0x0015, 0x1118, 0x080c, 0x82eb, 0x0030,
+	0xa1b6, 0x0016, 0x190c, 0x14fa, 0x080c, 0x82eb, 0x0005, 0x20a9,
+	0x000e, 0x2e98, 0x6010, 0x20a0, 0x53a3, 0x20a9, 0x0006, 0x3310,
+	0x3420, 0x9398, 0x94a0, 0x3318, 0x3428, 0x222e, 0x2326, 0xa290,
+	0x0002, 0xa5a8, 0x0002, 0xa398, 0x0002, 0xa4a0, 0x0002, 0x1f04,
+	0x845d, 0x00e6, 0x080c, 0x986a, 0x0130, 0x6010, 0x2070, 0x7007,
+	0x0000, 0x7037, 0x0103, 0x00ee, 0x080c, 0x82eb, 0x0005, 0x00d6,
+	0x0036, 0x7330, 0xa386, 0x0200, 0x1130, 0x6018, 0x2068, 0x6813,
+	0x00ff, 0x6817, 0xfffd, 0x6010, 0xa005, 0x0130, 0x2068, 0x6807,
+	0x0000, 0x6837, 0x0103, 0x6b32, 0x080c, 0x82eb, 0x003e, 0x00de,
+	0x0005, 0x0016, 0x20a9, 0x002a, 0xae80, 0x000c, 0x2098, 0x6010,
+	0xa080, 0x0002, 0x20a0, 0x53a3, 0x20a9, 0x002a, 0x6010, 0xa080,
+	0x0001, 0x2004, 0xa080, 0x0002, 0x20a0, 0x53a3, 0x00e6, 0x6010,
+	0x2004, 0x2070, 0x7037, 0x0103, 0x00ee, 0x080c, 0x82eb, 0x001e,
+	0x0005, 0x0016, 0x2009, 0x0000, 0x7030, 0xa086, 0x0100, 0x0140,
+	0x7038, 0xa084, 0x00ff, 0x808e, 0x703c, 0xa084, 0x00ff, 0x8086,
+	0xa080, 0x0004, 0xa108, 0x21a8, 0xae80, 0x000c, 0x2098, 0x6010,
+	0xa080, 0x0002, 0x20a0, 0x080c, 0x4a04, 0x00e6, 0x080c, 0x986a,
+	0x0140, 0x6010, 0x2070, 0x7007, 0x0000, 0x7034, 0x70b2, 0x7037,
+	0x0103, 0x00ee, 0x080c, 0x82eb, 0x001e, 0x0005, 0x00e6, 0x00d6,
+	0x603f, 0x0000, 0x2c68, 0x0016, 0x2009, 0x0035, 0x080c, 0x9d16,
+	0x001e, 0x1168, 0x0026, 0x6228, 0x2268, 0x002e, 0x2071, 0xb68c,
+	0x6b1c, 0xa386, 0x0003, 0x0130, 0xa386, 0x0006, 0x0128, 0x080c,
+	0x82eb, 0x0020, 0x0031, 0x0010, 0x080c, 0x85ba, 0x00de, 0x00ee,
+	0x0005, 0x00f6, 0x6810, 0x2078, 0xa186, 0x0015, 0x0904, 0x85a3,
+	0xa18e, 0x0016, 0x1904, 0x85b8, 0x700c, 0xa084, 0xff00, 0xa086,
+	0x1700, 0x1904, 0x8582, 0x8fff, 0x1138, 0x6800, 0xa086, 0x000f,
+	0x0904, 0x8566, 0x0804, 0x85b6, 0x6808, 0xa086, 0xffff, 0x1904,
+	0x85a5, 0x784c, 0xa084, 0x0060, 0xa086, 0x0020, 0x1150, 0x797c,
+	0x7810, 0xa106, 0x1904, 0x85a5, 0x7980, 0x7814, 0xa106, 0x1904,
+	0x85a5, 0x080c, 0x9a1f, 0x6858, 0x7852, 0x784c, 0xc0dc, 0xc0f4,
+	0xc0d4, 0x784e, 0x0026, 0xa00e, 0x6a14, 0x2001, 0x000a, 0x080c,
+	0x68b3, 0x7854, 0xa20a, 0x0208, 0x8011, 0x7a56, 0x82ff, 0x002e,
+	0x1138, 0x00c6, 0x2d60, 0x080c, 0x963b, 0x00ce, 0x0804, 0x85b6,
+	0x00c6, 0x00d6, 0x2f68, 0x6838, 0xd0fc, 0x1118, 0x080c, 0x4ad9,
+	0x0010, 0x080c, 0x4cc1, 0x00de, 0x00ce, 0x1904, 0x85a5, 0x00c6,
+	0x2d60, 0x080c, 0x82eb, 0x00ce, 0x0804, 0x85b6, 0x00c6, 0x080c,
+	0x9ae4, 0x0190, 0x6013, 0x0000, 0x6818, 0x601a, 0x080c, 0x9c35,
+	0x601f, 0x0003, 0x6904, 0x00c6, 0x2d60, 0x080c, 0x82eb, 0x00ce,
+	0x080c, 0x831a, 0x00ce, 0x04d0, 0x2001, 0xb3b7, 0x2004, 0x683e,
+	0x00ce, 0x04a0, 0x7008, 0xa086, 0x000b, 0x11a0, 0x6018, 0x200c,
+	0xc1bc, 0x2102, 0x00c6, 0x2d60, 0x7853, 0x0003, 0x6007, 0x0085,
+	0x6003, 0x000b, 0x601f, 0x0002, 0x080c, 0x69f6, 0x080c, 0x6e9e,
+	0x00ce, 0x00e0, 0x700c, 0xa086, 0x2a00, 0x1138, 0x2001, 0xb3b7,
+	0x2004, 0x683e, 0x0098, 0x0471, 0x0098, 0x8fff, 0x090c, 0x14fa,
+	0x00c6, 0x00d6, 0x2d60, 0x2f68, 0x684b, 0x0003, 0x080c, 0x952f,
+	0x080c, 0x9a1f, 0x080c, 0x9a2b, 0x00de, 0x00ce, 0x080c, 0x82eb,
+	0x00fe, 0x0005, 0xa186, 0x0015, 0x1128, 0x2001, 0xb3b7, 0x2004,
+	0x683e, 0x0068, 0xa18e, 0x0016, 0x1160, 0x00c6, 0x2d00, 0x2060,
+	0x080c, 0xaf00, 0x080c, 0x6866, 0x080c, 0x82eb, 0x00ce, 0x080c,
+	0x82eb, 0x0005, 0x0026, 0x0036, 0x0046, 0x7228, 0x7c80, 0x7b7c,
+	0xd2f4, 0x0130, 0x2001, 0xb3b7, 0x2004, 0x683e, 0x0804, 0x8634,
+	0x00c6, 0x2d60, 0x080c, 0x954f, 0x00ce, 0x6804, 0xa086, 0x0050,
+	0x1168, 0x00c6, 0x2d00, 0x2060, 0x6003, 0x0001, 0x6007, 0x0050,
+	0x080c, 0x69f6, 0x080c, 0x6e9e, 0x00ce, 0x04f0, 0x6800, 0xa086,
+	0x000f, 0x01c8, 0x8fff, 0x090c, 0x14fa, 0x6820, 0xd0dc, 0x1198,
+	0x6800, 0xa086, 0x0004, 0x1198, 0x784c, 0xd0ac, 0x0180, 0x784c,
+	0xc0dc, 0xc0f4, 0x784e, 0x7850, 0xc0f4, 0xc0fc, 0x7852, 0x2001,
+	0x0001, 0x682e, 0x00e0, 0x2001, 0x0007, 0x682e, 0x00c0, 0x784c,
+	0xd0b4, 0x1130, 0xd0ac, 0x0db8, 0x784c, 0xd0f4, 0x1da0, 0x0c38,
+	0xd2ec, 0x1d88, 0x7024, 0xa306, 0x1118, 0x7020, 0xa406, 0x0d58,
+	0x7020, 0x6836, 0x7024, 0x683a, 0x2001, 0x0005, 0x682e, 0x080c,
+	0x9b71, 0x080c, 0x6e9e, 0x0010, 0x080c, 0x82eb, 0x004e, 0x003e,
+	0x002e, 0x0005, 0x00e6, 0x00d6, 0x0026, 0x6034, 0x2068, 0x6a1c,
+	0xa286, 0x0007, 0x0904, 0x8698, 0xa286, 0x0002, 0x0904, 0x8698,
+	0xa286, 0x0000, 0x0904, 0x8698, 0x6808, 0x6338, 0xa306, 0x1904,
+	0x8698, 0x2071, 0xb68c, 0xa186, 0x0015, 0x05e0, 0xa18e, 0x0016,
+	0x1190, 0x6030, 0xa084, 0x00ff, 0xa086, 0x0001, 0x1160, 0x700c,
+	0xa086, 0x2a00, 0x1140, 0x6034, 0xa080, 0x0008, 0x200c, 0xc1dd,
+	0xc1f5, 0x2102, 0x0438, 0x00c6, 0x6034, 0x2060, 0x6104, 0xa186,
+	0x004b, 0x01a0, 0xa186, 0x004c, 0x0188, 0xa186, 0x004d, 0x0170,
+	0xa186, 0x004e, 0x0158, 0xa186, 0x0052, 0x0140, 0x6010, 0x2068,
+	0x080c, 0x986a, 0x090c, 0x14fa, 0x6853, 0x0003, 0x6007, 0x0085,
+	0x6003, 0x000b, 0x601f, 0x0002, 0x080c, 0x69f6, 0x080c, 0x6e9e,
+	0x00ce, 0x0030, 0x6034, 0x2070, 0x2001, 0xb3b7, 0x2004, 0x703e,
+	0x080c, 0x82eb, 0x002e, 0x00de, 0x00ee, 0x0005, 0x00d6, 0x20a9,
+	0x000e, 0x2e98, 0x6010, 0x20a0, 0x53a3, 0xa1b6, 0x0015, 0x1148,
+	0x6018, 0x2068, 0x7038, 0x680a, 0x703c, 0x680e, 0x6800, 0xc08d,
+	0x6802, 0x00de, 0x0804, 0x8469, 0x2100, 0xa1b2, 0x0080, 0x1a0c,
+	0x14fa, 0xa1b2, 0x0040, 0x1a04, 0x8718, 0x0002, 0x870c, 0x8700,
+	0x870c, 0x870c, 0x870c, 0x870c, 0x86fe, 0x86fe, 0x86fe, 0x86fe,
+	0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe,
+	0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe,
+	0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x870c, 0x86fe, 0x870c,
+	0x870c, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x870c, 0x86fe,
+	0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe,
+	0x870c, 0x870c, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe, 0x86fe,
+	0x86fe, 0x86fe, 0x86fe, 0x870c, 0x86fe, 0x86fe, 0x080c, 0x14fa,
+	0x6003, 0x0001, 0x6106, 0x080c, 0x6a3c, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x6e9e, 0x012e, 0x0005, 0x6003, 0x0001, 0x6106, 0x080c,
+	0x6a3c, 0x0126, 0x2091, 0x8000, 0x080c, 0x6e9e, 0x012e, 0x0005,
+	0x2600, 0x0002, 0x870c, 0x870c, 0x8720, 0x870c, 0x870c, 0x8720,
+	0x080c, 0x14fa, 0x6004, 0xa0b2, 0x0080, 0x1a0c, 0x14fa, 0xa1b6,
+	0x0013, 0x0904, 0x87c2, 0xa1b6, 0x0027, 0x1904, 0x8788, 0x080c,
+	0x6dc1, 0x6004, 0x080c, 0x9a55, 0x0188, 0x080c, 0x9a66, 0x0904,
+	0x8782, 0xa08e, 0x0021, 0x0904, 0x8785, 0xa08e, 0x0022, 0x0904,
+	0x8782, 0xa08e, 0x003d, 0x0904, 0x8785, 0x04a8, 0x080c, 0x2b99,
+	0x2001, 0x0007, 0x080c, 0x4d75, 0x6018, 0xa080, 0x0028, 0x200c,
+	0x080c, 0x8890, 0xa186, 0x007e, 0x1148, 0x2001, 0xb134, 0x2014,
+	0xc285, 0x080c, 0x58d5, 0x1108, 0xc2ad, 0x2202, 0x0016, 0x0026,
+	0x0036, 0x2110, 0x2019, 0x0028, 0x080c, 0x6b35, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x6a6b, 0x00c6, 0x6018, 0xa065, 0x0110, 0x080c,
+	0x501c, 0x00ce, 0x2c08, 0x080c, 0xaa51, 0x007e, 0x003e, 0x002e,
+	0x001e, 0x080c, 0x4de4, 0x080c, 0x9c2d, 0x080c, 0x82eb, 0x080c,
+	0x6e9e, 0x0005, 0x080c, 0x8890, 0x0cb0, 0x080c, 0x88be, 0x0c98,
+	0xa186, 0x0014, 0x1db0, 0x080c, 0x6dc1, 0x080c, 0x2b73, 0x080c,
+	0x9a55, 0x1188, 0x080c, 0x2b99, 0x6018, 0xa080, 0x0028, 0x200c,
+	0x080c, 0x8890, 0xa186, 0x007e, 0x1128, 0x2001, 0xb134, 0x200c,
+	0xc185, 0x2102, 0x08c0, 0x080c, 0x9a66, 0x1118, 0x080c, 0x8890,
+	0x0890, 0x6004, 0xa08e, 0x0032, 0x1158, 0x00e6, 0x00f6, 0x2071,
+	0xb182, 0x2079, 0x0000, 0x080c, 0x2e97, 0x00fe, 0x00ee, 0x0818,
+	0x6004, 0xa08e, 0x0021, 0x0d50, 0xa08e, 0x0022, 0x090c, 0x8890,
+	0x0804, 0x877b, 0xa0b2, 0x0040, 0x1a04, 0x8885, 0x2008, 0x0002,
+	0x880a, 0x880b, 0x880e, 0x8811, 0x8814, 0x8817, 0x8808, 0x8808,
+	0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808,
+	0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808,
+	0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x881a, 0x8829,
+	0x8808, 0x882b, 0x8829, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808,
+	0x8829, 0x8829, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808, 0x8808,
+	0x8808, 0x8808, 0x8865, 0x8829, 0x8808, 0x8825, 0x8808, 0x8808,
+	0x8808, 0x8826, 0x8808, 0x8808, 0x8808, 0x8829, 0x885c, 0x8808,
+	0x080c, 0x14fa, 0x00f0, 0x2001, 0x000b, 0x0460, 0x2001, 0x0003,
+	0x0448, 0x2001, 0x0005, 0x0430, 0x2001, 0x0001, 0x0418, 0x2001,
+	0x0009, 0x0400, 0x080c, 0x6dc1, 0x6003, 0x0005, 0x2001, 0xb3b7,
+	0x2004, 0x603e, 0x080c, 0x6e9e, 0x00a0, 0x0018, 0x0010, 0x080c,
+	0x4d75, 0x0804, 0x8876, 0x080c, 0x6dc1, 0x2001, 0xb3b5, 0x2004,
+	0x6016, 0x2001, 0xb3b7, 0x2004, 0x603e, 0x6003, 0x0004, 0x080c,
+	0x6e9e, 0x0005, 0x080c, 0x4d75, 0x080c, 0x6dc1, 0x6003, 0x0002,
+	0x2001, 0xb3b7, 0x2004, 0x603e, 0x0036, 0x2019, 0xb15d, 0x2304,
+	0xa084, 0xff00, 0x1120, 0x2001, 0xb3b5, 0x201c, 0x0040, 0x8007,
+	0xa09a, 0x0004, 0x0ec0, 0x8003, 0x801b, 0x831b, 0xa318, 0x6316,
+	0x003e, 0x080c, 0x6e9e, 0x08e8, 0x080c, 0x6dc1, 0x080c, 0x9c2d,
+	0x080c, 0x82eb, 0x080c, 0x6e9e, 0x08a0, 0x00e6, 0x00f6, 0x2071,
+	0xb182, 0x2079, 0x0000, 0x080c, 0x2e97, 0x00fe, 0x00ee, 0x080c,
+	0x6dc1, 0x080c, 0x82eb, 0x080c, 0x6e9e, 0x0818, 0x080c, 0x6dc1,
+	0x2001, 0xb3b7, 0x2004, 0x603e, 0x6003, 0x0002, 0x2001, 0xb3b5,
+	0x2004, 0x6016, 0x080c, 0x6e9e, 0x0005, 0x2600, 0x2008, 0x0002,
+	0x888e, 0x888e, 0x888e, 0x8876, 0x8876, 0x888e, 0x080c, 0x14fa,
+	0x00e6, 0x0026, 0x0016, 0x080c, 0x986a, 0x0508, 0x6010, 0x2070,
+	0x7034, 0xa086, 0x0139, 0x1148, 0x2001, 0x0030, 0x2009, 0x0000,
+	0x2011, 0x4005, 0x080c, 0x9ce4, 0x0090, 0x7038, 0xd0fc, 0x0178,
+	0x7007, 0x0000, 0x0016, 0x6004, 0xa08e, 0x0021, 0x0160, 0xa08e,
+	0x003d, 0x0148, 0x001e, 0x7037, 0x0103, 0x7033, 0x0100, 0x001e,
+	0x002e, 0x00ee, 0x0005, 0x001e, 0x0009, 0x0cc8, 0x00e6, 0xacf0,
+	0x0004, 0x2e74, 0x7000, 0x2070, 0x7037, 0x0103, 0x7023, 0x8001,
+	0x00ee, 0x0005, 0x00d6, 0x6618, 0x2668, 0x6804, 0xa084, 0x00ff,
+	0x00de, 0xa0b2, 0x000c, 0x1a0c, 0x14fa, 0x6604, 0xa6b6, 0x0043,
+	0x1120, 0x080c, 0x9ca0, 0x0804, 0x892f, 0x6604, 0xa6b6, 0x0033,
+	0x1120, 0x080c, 0x9c50, 0x0804, 0x892f, 0x6604, 0xa6b6, 0x0028,
+	0x1120, 0x080c, 0x9a96, 0x0804, 0x892f, 0x6604, 0xa6b6, 0x0029,
+	0x1118, 0x080c, 0x9aad, 0x04d8, 0x6604, 0xa6b6, 0x001f, 0x1118,
+	0x080c, 0x844f, 0x04a0, 0x6604, 0xa6b6, 0x0000, 0x1118, 0x080c,
+	0x869e, 0x0468, 0x6604, 0xa6b6, 0x0022, 0x1118, 0x080c, 0x8477,
+	0x0430, 0x6604, 0xa6b6, 0x0035, 0x1118, 0x080c, 0x84de, 0x00f8,
+	0x6604, 0xa6b6, 0x0039, 0x1118, 0x080c, 0x863a, 0x00c0, 0x6604,
+	0xa6b6, 0x003d, 0x1118, 0x080c, 0x8491, 0x0088, 0x6604, 0xa6b6,
+	0x0044, 0x1118, 0x080c, 0x84b1, 0x0050, 0xa1b6, 0x0015, 0x1110,
+	0x0053, 0x0028, 0xa1b6, 0x0016, 0x1118, 0x0804, 0x8aeb, 0x0005,
+	0x080c, 0x8331, 0x0ce0, 0x8956, 0x8959, 0x8956, 0x899b, 0x8956,
+	0x8a78, 0x8af9, 0x8956, 0x8956, 0x8ac7, 0x8956, 0x8adb, 0xa1b6,
+	0x0048, 0x0140, 0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10, 0x080c,
+	0x1828, 0x0005, 0x00e6, 0xacf0, 0x0004, 0x2e74, 0x7000, 0x2070,
+	0x7037, 0x0103, 0x00ee, 0x080c, 0x82eb, 0x0005, 0xe000, 0xe000,
+	0x0005, 0x00e6, 0x2071, 0xb100, 0x7080, 0xa086, 0x0074, 0x1530,
+	0x080c, 0xaa28, 0x11b0, 0x00d6, 0x6018, 0x2068, 0x7030, 0xd08c,
+	0x0128, 0x6800, 0xd0bc, 0x0110, 0xc0c5, 0x6802, 0x00d9, 0x00de,
+	0x2001, 0x0006, 0x080c, 0x4d75, 0x080c, 0x2b99, 0x080c, 0x82eb,
+	0x0078, 0x2001, 0x000a, 0x080c, 0x4d75, 0x080c, 0x2b99, 0x6003,
+	0x0001, 0x6007, 0x0001, 0x080c, 0x6a3c, 0x0010, 0x080c, 0x8a69,
+	0x00ee, 0x0005, 0x6800, 0xd084, 0x0168, 0x2001, 0x0000, 0x080c,
+	0x4d63, 0x2069, 0xb152, 0x6804, 0xd0a4, 0x0120, 0x2001, 0x0006,
+	0x080c, 0x4da2, 0x0005, 0x00d6, 0x2011, 0xb120, 0x2204, 0xa086,
+	0x0074, 0x1904, 0x8a66, 0x6018, 0x2068, 0x6aa0, 0xa286, 0x007e,
+	0x1120, 0x080c, 0x8bf7, 0x0804, 0x8a09, 0x080c, 0x8bed, 0x6018,
+	0x2068, 0xa080, 0x0028, 0x2014, 0xa286, 0x0080, 0x11c0, 0x6813,
+	0x00ff, 0x6817, 0xfffc, 0x6010, 0xa005, 0x0138, 0x2068, 0x6807,
+	0x0000, 0x6837, 0x0103, 0x6833, 0x0200, 0x2001, 0x0006, 0x080c,
+	0x4d75, 0x080c, 0x2b99, 0x080c, 0x82eb, 0x0804, 0x8a67, 0x00e6,
+	0x2071, 0xb134, 0x2e04, 0xd09c, 0x0188, 0x2071, 0xb680, 0x7108,
+	0x720c, 0xa18c, 0x00ff, 0x1118, 0xa284, 0xff00, 0x0138, 0x6018,
+	0x2070, 0x70a0, 0xd0bc, 0x1110, 0x7112, 0x7216, 0x00ee, 0x6010,
+	0xa005, 0x0198, 0x2068, 0x6838, 0xd0f4, 0x0178, 0x6834, 0xa084,
+	0x00ff, 0xa086, 0x0039, 0x1958, 0x2001, 0x0000, 0x2009, 0x0000,
+	0x2011, 0x4000, 0x080c, 0x9ce4, 0x0840, 0x2001, 0x0004, 0x080c,
+	0x4d75, 0x6003, 0x0001, 0x6007, 0x0003, 0x080c, 0x6a3c, 0x0804,
+	0x8a67, 0x685c, 0xd0e4, 0x01d8, 0x080c, 0x9be0, 0x080c, 0x58d5,
+	0x0118, 0xd0dc, 0x1904, 0x89c5, 0x2011, 0xb134, 0x2204, 0xc0ad,
+	0x2012, 0x2001, 0xb38f, 0x2004, 0x00f6, 0x2079, 0x0100, 0x78e3,
+	0x0000, 0x080c, 0x274b, 0x78e2, 0x00fe, 0x0804, 0x89c5, 0x080c,
+	0x9c16, 0x2011, 0xb134, 0x2204, 0xc0a5, 0x2012, 0x0006, 0x080c,
+	0xab41, 0x000e, 0x1904, 0x89c5, 0xc0b5, 0x2012, 0x2001, 0x0000,
+	0x080c, 0x4d63, 0x00c6, 0x2009, 0x00ef, 0x00f6, 0x2079, 0x0100,
+	0x79ea, 0x7932, 0x7936, 0x00fe, 0x080c, 0x2720, 0x00f6, 0x2079,
+	0xb100, 0x7972, 0x2100, 0x2009, 0x0000, 0x080c, 0x26f6, 0x794e,
+	0x00fe, 0x8108, 0x080c, 0x4dc5, 0x2c00, 0x00ce, 0x1904, 0x89c5,
+	0x601a, 0x2001, 0x0002, 0x080c, 0x4d75, 0x601f, 0x0001, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x080c, 0x6a3c, 0x0008, 0x0011, 0x00de,
+	0x0005, 0x2001, 0xb100, 0x2004, 0xa086, 0x0003, 0x0120, 0x2001,
+	0x0007, 0x080c, 0x4d75, 0x080c, 0x2b99, 0x080c, 0x82eb, 0x0005,
+	0x00e6, 0x0026, 0x0016, 0x2071, 0xb100, 0x7080, 0xa086, 0x0014,
+	0x15f0, 0x7000, 0xa086, 0x0003, 0x1128, 0x6010, 0xa005, 0x1110,
+	0x080c, 0x3dcd, 0x00d6, 0x6018, 0x2068, 0x080c, 0x4ebf, 0x080c,
+	0x898a, 0x00de, 0x080c, 0x8ca6, 0x1550, 0x00d6, 0x6018, 0x2068,
+	0x6890, 0x00de, 0xa005, 0x0518, 0x2001, 0x0006, 0x080c, 0x4d75,
+	0x00e6, 0x6010, 0xa075, 0x01a8, 0x7034, 0xa084, 0x00ff, 0xa086,
+	0x0039, 0x1148, 0x2001, 0x0000, 0x2009, 0x0000, 0x2011, 0x4000,
+	0x080c, 0x9ce4, 0x0030, 0x7007, 0x0000, 0x7037, 0x0103, 0x7033,
+	0x0200, 0x00ee, 0x080c, 0x2b99, 0x080c, 0x82eb, 0x0020, 0x080c,
+	0x8890, 0x080c, 0x8a69, 0x001e, 0x002e, 0x00ee, 0x0005, 0x2011,
+	0xb120, 0x2204, 0xa086, 0x0014, 0x1158, 0x2001, 0x0002, 0x080c,
+	0x4d75, 0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x6a3c, 0x0010,
+	0x080c, 0x8a69, 0x0005, 0x2011, 0xb120, 0x2204, 0xa086, 0x0004,
+	0x1138, 0x2001, 0x0007, 0x080c, 0x4d75, 0x080c, 0x82eb, 0x0010,
+	0x080c, 0x8a69, 0x0005, 0x000b, 0x0005, 0x8956, 0x8b00, 0x8956,
+	0x8b34, 0x8956, 0x8ba9, 0x8af9, 0x8956, 0x8956, 0x8bbc, 0x8956,
+	0x8bcc, 0x6604, 0xa6b6, 0x001e, 0x1110, 0x080c, 0x82eb, 0x0005,
+	0x00d6, 0x00c6, 0x080c, 0x8bdc, 0x1178, 0x2001, 0x0000, 0x080c,
+	0x4d63, 0x2001, 0x0002, 0x080c, 0x4d75, 0x6003, 0x0001, 0x6007,
+	0x0002, 0x080c, 0x6a3c, 0x00e8, 0x2009, 0xb68e, 0x2104, 0xa086,
+	0x0009, 0x1160, 0x6018, 0x2068, 0x6840, 0xa084, 0x00ff, 0xa005,
+	0x0170, 0x8001, 0x6842, 0x6017, 0x000a, 0x0058, 0x2009, 0xb68f,
+	0x2104, 0xa084, 0xff00, 0xa086, 0x1900, 0x1108, 0x08d0, 0x080c,
+	0x8a69, 0x00ce, 0x00de, 0x0005, 0x080c, 0x8bea, 0x00d6, 0x2069,
+	0xb39e, 0x2d04, 0xa005, 0x0168, 0x6018, 0x2068, 0x68a0, 0xa086,
+	0x007e, 0x1138, 0x2069, 0xb11c, 0x2d04, 0x8000, 0x206a, 0x00de,
+	0x0010, 0x00de, 0x0078, 0x2001, 0x0000, 0x080c, 0x4d63, 0x2001,
+	0x0002, 0x080c, 0x4d75, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c,
+	0x6a3c, 0x0428, 0x080c, 0x8890, 0x2009, 0xb68e, 0x2134, 0xa6b4,
+	0x00ff, 0xa686, 0x0005, 0x01e0, 0xa686, 0x000b, 0x01b0, 0x2009,
+	0xb68f, 0x2104, 0xa084, 0xff00, 0x1118, 0xa686, 0x0009, 0x0180,
+	0xa086, 0x1900, 0x1150, 0xa686, 0x0009, 0x0150, 0x2001, 0x0004,
+	0x080c, 0x4d75, 0x080c, 0x82eb, 0x0010, 0x080c, 0x8a69, 0x0005,
+	0x00d6, 0x6010, 0x2068, 0x080c, 0x986a, 0x0128, 0x6838, 0xd0fc,
+	0x0110, 0x00de, 0x0c90, 0x6018, 0x2068, 0x6840, 0xa084, 0x00ff,
+	0xa005, 0x0140, 0x8001, 0x6842, 0x6017, 0x000a, 0x6007, 0x0016,
+	0x00de, 0x0c28, 0x68a0, 0xa086, 0x007e, 0x1138, 0x00e6, 0x2071,
+	0xb100, 0x080c, 0x4a3b, 0x00ee, 0x0010, 0x080c, 0x2b73, 0x00de,
+	0x08a0, 0x080c, 0x8bea, 0x1158, 0x2001, 0x0004, 0x080c, 0x4d75,
+	0x6003, 0x0001, 0x6007, 0x0003, 0x080c, 0x6a3c, 0x0020, 0x080c,
+	0x8890, 0x080c, 0x8a69, 0x0005, 0x0469, 0x1158, 0x2001, 0x0008,
+	0x080c, 0x4d75, 0x6003, 0x0001, 0x6007, 0x0005, 0x080c, 0x6a3c,
+	0x0010, 0x080c, 0x8a69, 0x0005, 0x00e9, 0x1158, 0x2001, 0x000a,
+	0x080c, 0x4d75, 0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x6a3c,
+	0x0010, 0x080c, 0x8a69, 0x0005, 0x2009, 0xb68e, 0x2104, 0xa086,
+	0x0003, 0x1138, 0x2009, 0xb68f, 0x2104, 0xa084, 0xff00, 0xa086,
+	0x2a00, 0x0005, 0xa085, 0x0001, 0x0005, 0x00c6, 0x0016, 0xac88,
+	0x0006, 0x2164, 0x080c, 0x4e30, 0x001e, 0x00ce, 0x0005, 0x00f6,
+	0x00e6, 0x00d6, 0x0036, 0x0016, 0x6018, 0x2068, 0x2071, 0xb134,
+	0x2e04, 0xa085, 0x0003, 0x2072, 0x080c, 0x8c7b, 0x0560, 0x2009,
+	0xb134, 0x2104, 0xc0cd, 0x200a, 0x2001, 0xb153, 0x2004, 0xd0a4,
+	0x0158, 0xa006, 0x2020, 0x2009, 0x002a, 0x080c, 0xacae, 0x2001,
+	0xb10c, 0x200c, 0xc195, 0x2102, 0x2019, 0x002a, 0x2009, 0x0001,
+	0x080c, 0x2b46, 0x2071, 0xb100, 0x080c, 0x2991, 0x00c6, 0x0156,
+	0x20a9, 0x0081, 0x2009, 0x007f, 0x080c, 0x2c6e, 0x8108, 0x1f04,
+	0x8c2c, 0x015e, 0x00ce, 0x080c, 0x8bed, 0x6813, 0x00ff, 0x6817,
+	0xfffe, 0x2071, 0xb680, 0x2079, 0x0100, 0x2e04, 0xa084, 0x00ff,
+	0x2069, 0xb11b, 0x206a, 0x78e6, 0x0006, 0x8e70, 0x2e04, 0x2069,
+	0xb11c, 0x206a, 0x78ea, 0x7832, 0x7836, 0x2010, 0xa084, 0xff00,
+	0x001e, 0xa105, 0x2009, 0xb127, 0x200a, 0x2200, 0xa084, 0x00ff,
+	0x2008, 0x080c, 0x2720, 0x080c, 0x58d5, 0x0170, 0x2069, 0xb68e,
+	0x2071, 0xb3b1, 0x6810, 0x2072, 0x6814, 0x7006, 0x6818, 0x700a,
+	0x681c, 0x700e, 0x080c, 0x9be0, 0x0040, 0x2001, 0x0006, 0x080c,
+	0x4d75, 0x080c, 0x2b99, 0x080c, 0x82eb, 0x001e, 0x003e, 0x00de,
+	0x00ee, 0x00fe, 0x0005, 0x0026, 0x0036, 0x00e6, 0x0156, 0x2019,
+	0xb127, 0x231c, 0x83ff, 0x01e8, 0x2071, 0xb680, 0x2e14, 0xa294,
+	0x00ff, 0x7004, 0xa084, 0xff00, 0xa205, 0xa306, 0x1190, 0x2011,
+	0xb696, 0xad98, 0x000a, 0x20a9, 0x0004, 0x080c, 0x8d2b, 0x1148,
+	0x2011, 0xb69a, 0xad98, 0x0006, 0x20a9, 0x0004, 0x080c, 0x8d2b,
+	0x1100, 0x015e, 0x00ee, 0x003e, 0x002e, 0x0005, 0x00e6, 0x2071,
+	0xb68c, 0x7004, 0xa086, 0x0014, 0x11a8, 0x7008, 0xa086, 0x0800,
+	0x1188, 0x700c, 0xd0ec, 0x0160, 0xa084, 0x0f00, 0xa086, 0x0100,
+	0x1138, 0x7024, 0xd0a4, 0x1110, 0xd0ac, 0x0110, 0xa006, 0x0010,
+	0xa085, 0x0001, 0x00ee, 0x0005, 0x00e6, 0x00d6, 0x00c6, 0x0076,
+	0x0056, 0x0046, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000, 0x2029,
+	0xb3e2, 0x252c, 0x2021, 0xb3e8, 0x2424, 0x2061, 0xb800, 0x2071,
+	0xb100, 0x7244, 0x7064, 0xa202, 0x16f0, 0x080c, 0xacd6, 0x05a0,
+	0x671c, 0xa786, 0x0001, 0x0580, 0xa786, 0x0007, 0x0568, 0x2500,
+	0xac06, 0x0550, 0x2400, 0xac06, 0x0538, 0x00c6, 0x6000, 0xa086,
+	0x0004, 0x1110, 0x080c, 0x190f, 0xa786, 0x0008, 0x1148, 0x080c,
+	0x9a66, 0x1130, 0x00ce, 0x080c, 0x8890, 0x080c, 0x9a2b, 0x00a0,
+	0x6010, 0x2068, 0x080c, 0x986a, 0x0160, 0xa786, 0x0003, 0x11e8,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c, 0x5271, 0x080c,
+	0x9a1f, 0x080c, 0x9a2b, 0x00ce, 0xace0, 0x0018, 0x7058, 0xac02,
+	0x1210, 0x0804, 0x8cd9, 0x012e, 0x000e, 0x002e, 0x004e, 0x005e,
+	0x007e, 0x00ce, 0x00de, 0x00ee, 0x0005, 0xa786, 0x0006, 0x1d00,
+	0x080c, 0xac5f, 0x0c30, 0x220c, 0x2304, 0xa106, 0x1130, 0x8210,
+	0x8318, 0x1f04, 0x8d2b, 0xa006, 0x0005, 0x2304, 0xa102, 0x0218,
+	0x2001, 0x0001, 0x0010, 0x2001, 0x0000, 0xa18d, 0x0001, 0x0005,
+	0x6004, 0xa08a, 0x0080, 0x1a0c, 0x14fa, 0x080c, 0x9a55, 0x0120,
+	0x080c, 0x9a66, 0x0168, 0x0028, 0x080c, 0x2b99, 0x080c, 0x9a66,
+	0x0138, 0x080c, 0x6dc1, 0x080c, 0x82eb, 0x080c, 0x6e9e, 0x0005,
+	0x080c, 0x8890, 0x0cb0, 0xa182, 0x0040, 0x0002, 0x8d71, 0x8d71,
+	0x8d71, 0x8d71, 0x8d71, 0x8d71, 0x8d71, 0x8d71, 0x8d71, 0x8d71,
+	0x8d71, 0x8d73, 0x8d73, 0x8d73, 0x8d73, 0x8d71, 0x8d71, 0x8d71,
+	0x8d73, 0x080c, 0x14fa, 0x600b, 0xffff, 0x6003, 0x0001, 0x6106,
+	0x080c, 0x69f6, 0x0126, 0x2091, 0x8000, 0x080c, 0x6e9e, 0x012e,
+	0x0005, 0xa186, 0x0013, 0x1128, 0x6004, 0xa082, 0x0040, 0x0804,
+	0x8e0d, 0xa186, 0x0027, 0x11e8, 0x080c, 0x6dc1, 0x080c, 0x2b73,
+	0x00d6, 0x6110, 0x2168, 0x080c, 0x986a, 0x0168, 0x6837, 0x0103,
+	0x684b, 0x0029, 0x6847, 0x0000, 0x694c, 0xc1c5, 0x694e, 0x080c,
+	0x5271, 0x080c, 0x9a1f, 0x00de, 0x080c, 0x82eb, 0x080c, 0x6e9e,
+	0x0005, 0xa186, 0x0014, 0x1120, 0x6004, 0xa082, 0x0040, 0x0428,
+	0xa186, 0x0046, 0x0138, 0xa186, 0x0045, 0x0120, 0xa186, 0x0047,
+	0x190c, 0x14fa, 0x2001, 0x0109, 0x2004, 0xd084, 0x0198, 0x0126,
+	0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x080c, 0x68e7, 0x002e,
+	0x001e, 0x000e, 0x012e, 0xe000, 0x6000, 0xa086, 0x0002, 0x1110,
+	0x0804, 0x8e47, 0x080c, 0x8331, 0x0005, 0x0002, 0x8deb, 0x8de9,
+	0x8de9, 0x8de9, 0x8de9, 0x8de9, 0x8de9, 0x8de9, 0x8de9, 0x8de9,
+	0x8de9, 0x8e06, 0x8e06, 0x8e06, 0x8e06, 0x8de9, 0x8e06, 0x8de9,
+	0x8e06, 0x080c, 0x14fa, 0x080c, 0x6dc1, 0x00d6, 0x6110, 0x2168,
+	0x080c, 0x986a, 0x0168, 0x6837, 0x0103, 0x684b, 0x0006, 0x6847,
+	0x0000, 0x6850, 0xc0ec, 0x6852, 0x080c, 0x5271, 0x080c, 0x9a1f,
+	0x00de, 0x080c, 0x82eb, 0x080c, 0x6e9e, 0x0005, 0x080c, 0x6dc1,
+	0x080c, 0x82eb, 0x080c, 0x6e9e, 0x0005, 0x0002, 0x8e23, 0x8e21,
+	0x8e21, 0x8e21, 0x8e21, 0x8e21, 0x8e21, 0x8e21, 0x8e21, 0x8e21,
+	0x8e21, 0x8e35, 0x8e35, 0x8e35, 0x8e35, 0x8e21, 0x8e40, 0x8e21,
+	0x8e35, 0x080c, 0x14fa, 0x080c, 0x6dc1, 0x2001, 0xb3b7, 0x2004,
+	0x603e, 0x6003, 0x0002, 0x080c, 0x6e9e, 0x6010, 0xa088, 0x0013,
+	0x2104, 0xa085, 0x0400, 0x200a, 0x0005, 0x080c, 0x6dc1, 0x2001,
+	0xb3b7, 0x2004, 0x603e, 0x6003, 0x000f, 0x080c, 0x6e9e, 0x0005,
+	0x080c, 0x6dc1, 0x080c, 0x82eb, 0x080c, 0x6e9e, 0x0005, 0xa182,
+	0x0040, 0x0002, 0x8e5d, 0x8e5d, 0x8e5d, 0x8e5d, 0x8e5d, 0x8e5f,
+	0x8f37, 0x8f66, 0x8e5d, 0x8e5d, 0x8e5d, 0x8e5d, 0x8e5d, 0x8e5d,
+	0x8e5d, 0x8e5d, 0x8e5d, 0x8e5d, 0x8e5d, 0x080c, 0x14fa, 0x00e6,
+	0x00d6, 0x603f, 0x0000, 0x2071, 0xb680, 0x7124, 0x610a, 0x2071,
+	0xb68c, 0x6110, 0x2168, 0x7614, 0xa6b4, 0x0fff, 0x86ff, 0x0904,
+	0x8f03, 0xa68c, 0x0c00, 0x01e8, 0x00f6, 0x2c78, 0x080c, 0x5177,
+	0x00fe, 0x0198, 0x684c, 0xd0ac, 0x0180, 0x6020, 0xd0dc, 0x1168,
+	0x6850, 0xd0bc, 0x1150, 0x7318, 0x6814, 0xa306, 0x1904, 0x8f15,
+	0x731c, 0x6810, 0xa306, 0x1904, 0x8f15, 0x7318, 0x6b62, 0x731c,
+	0x6b5e, 0xa68c, 0x00ff, 0xa186, 0x0002, 0x0518, 0xa186, 0x0028,
+	0x1128, 0x080c, 0x9a44, 0x684b, 0x001c, 0x00e8, 0xd6dc, 0x01a0,
+	0x684b, 0x0015, 0x684c, 0xd0ac, 0x0170, 0x6914, 0x6a10, 0x2100,
+	0xa205, 0x0148, 0x7018, 0xa106, 0x1118, 0x701c, 0xa206, 0x0118,
+	0x6962, 0x6a5e, 0xc6dc, 0x0038, 0xd6d4, 0x0118, 0x684b, 0x0007,
+	0x0010, 0x684b, 0x0000, 0x6837, 0x0103, 0x6e46, 0xa01e, 0xd6c4,
+	0x01f0, 0xa686, 0x0100, 0x1140, 0x2001, 0xb699, 0x2004, 0xa005,
+	0x1118, 0xc6c4, 0x0804, 0x8e6e, 0x7328, 0x732c, 0x6b56, 0x83ff,
+	0x0170, 0xa38a, 0x0009, 0x0210, 0x2019, 0x0008, 0x0036, 0x2308,
+	0x2019, 0xb698, 0xad90, 0x0019, 0x080c, 0x953f, 0x003e, 0xd6cc,
+	0x0904, 0x8f28, 0x7124, 0x695a, 0x81ff, 0x0904, 0x8f28, 0xa192,
+	0x0021, 0x1250, 0x2071, 0xb698, 0x831c, 0x2300, 0xae18, 0xad90,
+	0x001d, 0x080c, 0x953f, 0x04a0, 0x6838, 0xd0fc, 0x0120, 0x2009,
+	0x0020, 0x695a, 0x0c78, 0x00f6, 0x2d78, 0x080c, 0x94e4, 0x00fe,
+	0x080c, 0x952f, 0x0438, 0x00f6, 0x2c78, 0x080c, 0x5177, 0x00fe,
+	0x0188, 0x684c, 0xd0ac, 0x0170, 0x6020, 0xd0dc, 0x1158, 0x6850,
+	0xd0bc, 0x1140, 0x684c, 0xd0f4, 0x1128, 0x080c, 0x9b43, 0x00de,
+	0x00ee, 0x00e0, 0x684b, 0x0000, 0x6837, 0x0103, 0x6e46, 0x684c,
+	0xd0ac, 0x0130, 0x6810, 0x6914, 0xa115, 0x0110, 0x080c, 0x90c1,
+	0x080c, 0x5271, 0x6218, 0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x080c,
+	0x9b11, 0x00de, 0x00ee, 0x1110, 0x080c, 0x82eb, 0x0005, 0x00f6,
+	0x6003, 0x0003, 0x2079, 0xb68c, 0x7c04, 0x7b00, 0x7e0c, 0x7d08,
+	0x6010, 0x2078, 0x784c, 0xd0ac, 0x0138, 0x6003, 0x0002, 0x00fe,
+	0x0005, 0x2130, 0x2228, 0x0058, 0x2400, 0x797c, 0xa10a, 0x2300,
+	0x7a80, 0xa213, 0x2600, 0xa102, 0x2500, 0xa203, 0x0e90, 0x7c12,
+	0x7b16, 0x7e0a, 0x7d0e, 0x00fe, 0x603f, 0x0000, 0x2c10, 0x080c,
+	0x1ec4, 0x080c, 0x6a59, 0x080c, 0x6f5b, 0x0005, 0x2001, 0xb3b7,
+	0x2004, 0x603e, 0x6003, 0x0004, 0x6110, 0x20e1, 0x0005, 0x3d18,
+	0x3e20, 0x2c10, 0x080c, 0x1828, 0x0005, 0xa182, 0x0040, 0x0002,
+	0x8f8b, 0x8f8b, 0x8f8b, 0x8f8b, 0x8f8b, 0x8f8d, 0x901e, 0x8f8b,
+	0x8f8b, 0x9034, 0x9098, 0x8f8b, 0x8f8b, 0x8f8b, 0x8f8b, 0x90a7,
+	0x8f8b, 0x8f8b, 0x8f8b, 0x080c, 0x14fa, 0x0076, 0x00f6, 0x00e6,
+	0x00d6, 0x2071, 0xb68c, 0x6110, 0x2178, 0x7614, 0xa6b4, 0x0fff,
+	0x7e46, 0x7f4c, 0xc7e5, 0x7f4e, 0x6218, 0x2268, 0x6a3c, 0x8211,
+	0x6a3e, 0x86ff, 0x0904, 0x9019, 0xa694, 0xff00, 0xa284, 0x0c00,
+	0x0120, 0x7018, 0x7862, 0x701c, 0x785e, 0xa284, 0x0300, 0x0904,
+	0x9019, 0x080c, 0x15dd, 0x090c, 0x14fa, 0x2d00, 0x784a, 0x7f4c,
+	0xc7cd, 0x7f4e, 0x6837, 0x0103, 0x7838, 0x683a, 0x783c, 0x683e,
+	0x7840, 0x6842, 0x6e46, 0xa68c, 0x0c00, 0x0120, 0x7318, 0x6b62,
+	0x731c, 0x6b5e, 0xa68c, 0x00ff, 0xa186, 0x0002, 0x0180, 0xa186,
+	0x0028, 0x1118, 0x684b, 0x001c, 0x0060, 0xd6dc, 0x0118, 0x684b,
+	0x0015, 0x0038, 0xd6d4, 0x0118, 0x684b, 0x0007, 0x0010, 0x684b,
+	0x0000, 0x6f4e, 0x7850, 0x6852, 0x7854, 0x6856, 0xa01e, 0xd6c4,
+	0x0198, 0x7328, 0x732c, 0x6b56, 0x83ff, 0x0170, 0xa38a, 0x0009,
+	0x0210, 0x2019, 0x0008, 0x0036, 0x2308, 0x2019, 0xb698, 0xad90,
+	0x0019, 0x080c, 0x953f, 0x003e, 0xd6cc, 0x01d8, 0x7124, 0x695a,
+	0x81ff, 0x01b8, 0xa192, 0x0021, 0x1250, 0x2071, 0xb698, 0x831c,
+	0x2300, 0xae18, 0xad90, 0x001d, 0x080c, 0x953f, 0x0050, 0x7838,
+	0xd0fc, 0x0120, 0x2009, 0x0020, 0x695a, 0x0c78, 0x2d78, 0x080c,
+	0x94e4, 0x00de, 0x00ee, 0x00fe, 0x007e, 0x0005, 0x00f6, 0x6003,
+	0x0003, 0x2079, 0xb68c, 0x7c04, 0x7b00, 0x7e0c, 0x7d08, 0x6010,
+	0x2078, 0x7c12, 0x7b16, 0x7e0a, 0x7d0e, 0x00fe, 0x2c10, 0x080c,
+	0x1ec4, 0x080c, 0x7a72, 0x0005, 0x00d6, 0x00f6, 0x2c78, 0x080c,
+	0x5177, 0x00fe, 0x0120, 0x2001, 0xb3b7, 0x2004, 0x603e, 0x6003,
+	0x0002, 0x080c, 0x6e53, 0x080c, 0x6f5b, 0x6110, 0x2168, 0x694c,
+	0xd1e4, 0x0904, 0x9096, 0xd1cc, 0x0540, 0x6948, 0x6838, 0xd0fc,
+	0x01e8, 0x0016, 0x684c, 0x0006, 0x6850, 0x0006, 0xad90, 0x000d,
+	0xa198, 0x000d, 0x2009, 0x0020, 0x0156, 0x21a8, 0x2304, 0x2012,
+	0x8318, 0x8210, 0x1f04, 0x905e, 0x015e, 0x000e, 0x6852, 0x000e,
+	0x684e, 0x001e, 0x2168, 0x080c, 0x1604, 0x0418, 0x0016, 0x080c,
+	0x1604, 0x00de, 0x080c, 0x952f, 0x00e0, 0x6837, 0x0103, 0x6944,
+	0xa184, 0x00ff, 0xa0b6, 0x0002, 0x0180, 0xa086, 0x0028, 0x1118,
+	0x684b, 0x001c, 0x0060, 0xd1dc, 0x0118, 0x684b, 0x0015, 0x0038,
+	0xd1d4, 0x0118, 0x684b, 0x0007, 0x0010, 0x684b, 0x0000, 0x080c,
+	0x5271, 0x080c, 0x9b11, 0x1110, 0x080c, 0x82eb, 0x00de, 0x0005,
+	0x2019, 0x0001, 0x080c, 0x7cc4, 0x6003, 0x0002, 0x2001, 0xb3b7,
+	0x2004, 0x603e, 0x080c, 0x6e53, 0x080c, 0x6f5b, 0x0005, 0x080c,
+	0x6e53, 0x080c, 0x2b73, 0x00d6, 0x6110, 0x2168, 0x080c, 0x986a,
+	0x0150, 0x6837, 0x0103, 0x684b, 0x0029, 0x6847, 0x0000, 0x080c,
+	0x5271, 0x080c, 0x9a1f, 0x00de, 0x080c, 0x82eb, 0x080c, 0x6f5b,
+	0x0005, 0x684b, 0x0015, 0xd1fc, 0x0138, 0x684b, 0x0007, 0x8002,
+	0x8000, 0x810a, 0xa189, 0x0000, 0x6962, 0x685e, 0x0005, 0xa182,
+	0x0040, 0x0002, 0x90e5, 0x90e5, 0x90e5, 0x90e5, 0x90e5, 0x90e7,
+	0x90e5, 0x91a0, 0x91ac, 0x90e5, 0x90e5, 0x90e5, 0x90e5, 0x90e5,
+	0x90e5, 0x90e5, 0x90e5, 0x90e5, 0x90e5, 0x080c, 0x14fa, 0x0076,
+	0x00f6, 0x00e6, 0x00d6, 0x2071, 0xb68c, 0x6110, 0x2178, 0x7614,
+	0xa6b4, 0x0fff, 0x00f6, 0x2c78, 0x080c, 0x5177, 0x00fe, 0x0150,
+	0xa684, 0x00ff, 0x1138, 0x6020, 0xd0f4, 0x0120, 0x080c, 0x9b43,
+	0x0804, 0x919b, 0x7e46, 0x7f4c, 0xc7e5, 0x7f4e, 0x6218, 0x2268,
+	0x6a3c, 0x8211, 0x6a3e, 0x86ff, 0x0904, 0x9191, 0xa694, 0xff00,
+	0xa284, 0x0c00, 0x0120, 0x7018, 0x7862, 0x701c, 0x785e, 0xa284,
+	0x0300, 0x0904, 0x918f, 0xa686, 0x0100, 0x1140, 0x2001, 0xb699,
+	0x2004, 0xa005, 0x1118, 0xc6c4, 0x7e46, 0x0c28, 0x080c, 0x15dd,
+	0x090c, 0x14fa, 0x2d00, 0x784a, 0x7f4c, 0xa7bd, 0x0200, 0x7f4e,
+	0x6837, 0x0103, 0x7838, 0x683a, 0x783c, 0x683e, 0x7840, 0x6842,
+	0x6e46, 0xa68c, 0x0c00, 0x0120, 0x7318, 0x6b62, 0x731c, 0x6b5e,
+	0xa68c, 0x00ff, 0xa186, 0x0002, 0x0180, 0xa186, 0x0028, 0x1118,
+	0x684b, 0x001c, 0x0060, 0xd6dc, 0x0118, 0x684b, 0x0015, 0x0038,
+	0xd6d4, 0x0118, 0x684b, 0x0007, 0x0010, 0x684b, 0x0000, 0x6f4e,
+	0x7850, 0x6852, 0x7854, 0x6856, 0xa01e, 0xd6c4, 0x0198, 0x7328,
+	0x732c, 0x6b56, 0x83ff, 0x0170, 0xa38a, 0x0009, 0x0210, 0x2019,
+	0x0008, 0x0036, 0x2308, 0x2019, 0xb698, 0xad90, 0x0019, 0x080c,
+	0x953f, 0x003e, 0xd6cc, 0x01d8, 0x7124, 0x695a, 0x81ff, 0x01b8,
+	0xa192, 0x0021, 0x1250, 0x2071, 0xb698, 0x831c, 0x2300, 0xae18,
+	0xad90, 0x001d, 0x080c, 0x953f, 0x0050, 0x7838, 0xd0fc, 0x0120,
+	0x2009, 0x0020, 0x695a, 0x0c78, 0x2d78, 0x080c, 0x94e4, 0xd6dc,
+	0x1110, 0xa006, 0x0030, 0x2001, 0x0001, 0x2071, 0xb68c, 0x7218,
+	0x731c, 0x080c, 0x1873, 0x00de, 0x00ee, 0x00fe, 0x007e, 0x0005,
+	0x2001, 0xb3b7, 0x2004, 0x603e, 0x20e1, 0x0005, 0x3d18, 0x3e20,
+	0x2c10, 0x080c, 0x1828, 0x0005, 0x2001, 0xb3b7, 0x2004, 0x603e,
+	0x00d6, 0x6003, 0x0002, 0x6110, 0x2168, 0x694c, 0xd1e4, 0x0904,
+	0x92b3, 0x603f, 0x0000, 0x00f6, 0x2c78, 0x080c, 0x5177, 0x00fe,
+	0x0560, 0x6814, 0x6910, 0xa115, 0x0540, 0x6a60, 0xa206, 0x1118,
+	0x685c, 0xa106, 0x0510, 0x684c, 0xc0e4, 0x684e, 0x6847, 0x0000,
+	0x6863, 0x0000, 0x685f, 0x0000, 0x6020, 0xd0f4, 0x1158, 0x697c,
+	0x6810, 0xa102, 0x603a, 0x6980, 0x6814, 0xa103, 0x6036, 0x6020,
+	0xc0f5, 0x6022, 0x00d6, 0x6018, 0x2068, 0x683c, 0x8000, 0x683e,
+	0x00de, 0x080c, 0x9b43, 0x0804, 0x92b3, 0x694c, 0xd1cc, 0x0904,
+	0x9283, 0x6948, 0x6838, 0xd0fc, 0x0904, 0x9248, 0x0016, 0x684c,
+	0x0006, 0x6850, 0x0006, 0x00f6, 0x2178, 0x7944, 0xa184, 0x00ff,
+	0xa0b6, 0x0002, 0x01e0, 0xa086, 0x0028, 0x1128, 0x684b, 0x001c,
+	0x784b, 0x001c, 0x00e8, 0xd1dc, 0x0158, 0x684b, 0x0015, 0x784b,
+	0x0015, 0x080c, 0x9ccd, 0x0118, 0x7944, 0xc1dc, 0x7946, 0x0080,
+	0xd1d4, 0x0128, 0x684b, 0x0007, 0x784b, 0x0007, 0x0048, 0x684c,
+	0xd0ac, 0x0130, 0x6810, 0x6914, 0xa115, 0x0110, 0x080c, 0x90c1,
+	0x6848, 0x784a, 0x6860, 0x7862, 0x685c, 0x785e, 0xad90, 0x000d,
+	0xaf98, 0x000d, 0x2009, 0x0020, 0x0156, 0x21a8, 0x2304, 0x2012,
+	0x8318, 0x8210, 0x1f04, 0x9236, 0x015e, 0x00fe, 0x000e, 0x6852,
+	0x000e, 0x684e, 0x001e, 0x2168, 0x080c, 0x1604, 0x0804, 0x92ae,
+	0x0016, 0x00f6, 0x2178, 0x7944, 0xa184, 0x00ff, 0xa0b6, 0x0002,
+	0x01e0, 0xa086, 0x0028, 0x1128, 0x684b, 0x001c, 0x784b, 0x001c,
+	0x00e8, 0xd1dc, 0x0158, 0x684b, 0x0015, 0x784b, 0x0015, 0x080c,
+	0x9ccd, 0x0118, 0x7944, 0xc1dc, 0x7946, 0x0080, 0xd1d4, 0x0128,
+	0x684b, 0x0007, 0x784b, 0x0007, 0x0048, 0x684c, 0xd0ac, 0x0130,
+	0x6810, 0x6914, 0xa115, 0x0110, 0x080c, 0x90c1, 0x6860, 0x7862,
+	0x685c, 0x785e, 0x684c, 0x784e, 0x00fe, 0x080c, 0x1604, 0x00de,
+	0x080c, 0x952f, 0x0458, 0x6837, 0x0103, 0x6944, 0xa184, 0x00ff,
+	0xa0b6, 0x0002, 0x01b0, 0xa086, 0x0028, 0x1118, 0x684b, 0x001c,
+	0x00d8, 0xd1dc, 0x0148, 0x684b, 0x0015, 0x080c, 0x9ccd, 0x0118,
+	0x6944, 0xc1dc, 0x6946, 0x0080, 0xd1d4, 0x0118, 0x684b, 0x0007,
+	0x0058, 0x684b, 0x0000, 0x684c, 0xd0ac, 0x0130, 0x6810, 0x6914,
+	0xa115, 0x0110, 0x080c, 0x90c1, 0x080c, 0x5271, 0x080c, 0x9b11,
+	0x1110, 0x080c, 0x82eb, 0x00de, 0x0005, 0x080c, 0x6dc1, 0x0010,
+	0x080c, 0x6e53, 0x080c, 0x986a, 0x01c0, 0x00d6, 0x6110, 0x2168,
+	0x6837, 0x0103, 0x2009, 0xb10c, 0x210c, 0xd18c, 0x11c0, 0xd184,
+	0x1198, 0x6108, 0x694a, 0xa18e, 0x0029, 0x1110, 0x080c, 0xaf46,
+	0x6847, 0x0000, 0x080c, 0x5271, 0x00de, 0x080c, 0x82eb, 0x080c,
+	0x6e9e, 0x080c, 0x6f5b, 0x0005, 0x684b, 0x0004, 0x0c88, 0x684b,
+	0x0004, 0x0c70, 0xa182, 0x0040, 0x0002, 0x92f8, 0x92f8, 0x92f8,
+	0x92f8, 0x92f8, 0x92fa, 0x92f8, 0x92fd, 0x92f8, 0x92f8, 0x92f8,
+	0x92f8, 0x92f8, 0x92f8, 0x92f8, 0x92f8, 0x92f8, 0x92f8, 0x92f8,
+	0x080c, 0x14fa, 0x080c, 0x82eb, 0x0005, 0x0006, 0x0026, 0xa016,
+	0x080c, 0x1828, 0x002e, 0x000e, 0x0005, 0xa182, 0x0085, 0x0002,
+	0x9311, 0x930f, 0x930f, 0x931d, 0x930f, 0x930f, 0x930f, 0x080c,
+	0x14fa, 0x6003, 0x0001, 0x6106, 0x080c, 0x69f6, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x6e9e, 0x012e, 0x0005, 0x0026, 0x0056, 0x00d6,
+	0x00e6, 0x2071, 0xb680, 0x7224, 0x6212, 0x7220, 0x080c, 0x985a,
+	0x01a0, 0x2268, 0x6800, 0xa086, 0x0000, 0x0178, 0x6018, 0x6d18,
+	0xa52e, 0x1158, 0x00c6, 0x2d60, 0x080c, 0x954f, 0x00ce, 0x0128,
+	0x6803, 0x0002, 0x6007, 0x0086, 0x0010, 0x6007, 0x0087, 0x6003,
+	0x0001, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x00f6, 0x2278, 0x080c,
+	0x5177, 0x00fe, 0x0150, 0x6820, 0xd0ec, 0x0138, 0x00c6, 0x2260,
+	0x603f, 0x0000, 0x080c, 0x9b43, 0x00ce, 0x00ee, 0x00de, 0x005e,
+	0x002e, 0x0005, 0xa186, 0x0013, 0x1160, 0x6004, 0xa08a, 0x0085,
+	0x0a0c, 0x14fa, 0xa08a, 0x008c, 0x1a0c, 0x14fa, 0xa082, 0x0085,
+	0x0072, 0xa186, 0x0027, 0x0120, 0xa186, 0x0014, 0x190c, 0x14fa,
+	0x080c, 0x6dc1, 0x080c, 0x9a2b, 0x080c, 0x6e9e, 0x0005, 0x937e,
+	0x9380, 0x9380, 0x937e, 0x937e, 0x937e, 0x937e, 0x080c, 0x14fa,
+	0x080c, 0x6dc1, 0x080c, 0x9a2b, 0x080c, 0x6e9e, 0x0005, 0xa186,
+	0x0013, 0x1128, 0x6004, 0xa082, 0x0085, 0x2008, 0x04a8, 0xa186,
+	0x0027, 0x11e8, 0x080c, 0x6dc1, 0x080c, 0x2b73, 0x00d6, 0x6010,
+	0x2068, 0x080c, 0x986a, 0x0150, 0x6837, 0x0103, 0x6847, 0x0000,
+	0x684b, 0x0029, 0x080c, 0x5271, 0x080c, 0x9a1f, 0x00de, 0x080c,
+	0x82eb, 0x080c, 0x6e9e, 0x0005, 0x080c, 0x8331, 0x0ce0, 0xa186,
+	0x0014, 0x1dd0, 0x080c, 0x6dc1, 0x00d6, 0x6010, 0x2068, 0x080c,
+	0x986a, 0x0d60, 0x6837, 0x0103, 0x6847, 0x0000, 0x684b, 0x0006,
+	0x6850, 0xc0ec, 0x6852, 0x08f0, 0x0002, 0x93ce, 0x93cc, 0x93cc,
+	0x93cc, 0x93cc, 0x93cc, 0x93e6, 0x080c, 0x14fa, 0x080c, 0x6dc1,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0118, 0xa186,
+	0x0035, 0x1118, 0x2001, 0xb3b5, 0x0010, 0x2001, 0xb3b6, 0x2004,
+	0x6016, 0x6003, 0x000c, 0x080c, 0x6e9e, 0x0005, 0x080c, 0x6dc1,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0118, 0xa186,
+	0x0035, 0x1118, 0x2001, 0xb3b5, 0x0010, 0x2001, 0xb3b6, 0x2004,
+	0x6016, 0x6003, 0x000e, 0x080c, 0x6e9e, 0x0005, 0xa182, 0x008c,
+	0x1220, 0xa182, 0x0085, 0x0208, 0x001a, 0x080c, 0x8331, 0x0005,
+	0x940f, 0x940f, 0x940f, 0x940f, 0x9411, 0x9464, 0x940f, 0x080c,
+	0x14fa, 0x00d6, 0x00f6, 0x2c78, 0x080c, 0x5177, 0x00fe, 0x0168,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0118, 0xa186,
+	0x0035, 0x1118, 0x00de, 0x0804, 0x9477, 0x080c, 0x9a1f, 0x080c,
+	0x986a, 0x01c8, 0x6010, 0x2068, 0x6837, 0x0103, 0x6850, 0xd0b4,
+	0x0128, 0x684b, 0x0006, 0xc0ec, 0x6852, 0x0048, 0xd0bc, 0x0118,
+	0x684b, 0x0002, 0x0020, 0x684b, 0x0005, 0x080c, 0x9ae0, 0x6847,
+	0x0000, 0x080c, 0x5271, 0x2c68, 0x080c, 0x8295, 0x01c0, 0x6003,
+	0x0001, 0x6007, 0x001e, 0x600b, 0xffff, 0x2009, 0xb68e, 0x210c,
+	0x6136, 0x2009, 0xb68f, 0x210c, 0x613a, 0x6918, 0x611a, 0x080c,
+	0x9c35, 0x6950, 0x6152, 0x601f, 0x0001, 0x080c, 0x69f6, 0x2d60,
+	0x080c, 0x82eb, 0x00de, 0x0005, 0x00f6, 0x2c78, 0x080c, 0x5177,
+	0x00fe, 0x0598, 0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0035,
+	0x0130, 0xa186, 0x001e, 0x0118, 0xa186, 0x0039, 0x1530, 0x00d6,
+	0x2c68, 0x080c, 0x9d16, 0x1904, 0x94bc, 0x080c, 0x8295, 0x01d8,
+	0x6106, 0x6003, 0x0001, 0x601f, 0x0001, 0x6918, 0x611a, 0x6928,
+	0x612a, 0x692c, 0x612e, 0x6930, 0xa18c, 0x00ff, 0x6132, 0x6934,
+	0x6136, 0x6938, 0x613a, 0x6950, 0x6152, 0x080c, 0x9c35, 0x080c,
+	0x69f6, 0x080c, 0x6e9e, 0x2d60, 0x00f8, 0x00d6, 0x6010, 0x2068,
+	0x080c, 0x986a, 0x01c8, 0x6837, 0x0103, 0x6850, 0xd0b4, 0x0128,
+	0xc0ec, 0x6852, 0x684b, 0x0006, 0x0048, 0xd0bc, 0x0118, 0x684b,
+	0x0002, 0x0020, 0x684b, 0x0005, 0x080c, 0x9ae0, 0x6847, 0x0000,
+	0x080c, 0x5271, 0x080c, 0x9a1f, 0x00de, 0x080c, 0x82eb, 0x0005,
+	0x0016, 0x00d6, 0x6010, 0x2068, 0x080c, 0x986a, 0x0140, 0x6837,
+	0x0103, 0x684b, 0x0028, 0x6847, 0x0000, 0x080c, 0x5271, 0x00de,
+	0x001e, 0xa186, 0x0013, 0x0148, 0xa186, 0x0014, 0x0130, 0xa186,
+	0x0027, 0x0118, 0x080c, 0x8331, 0x0030, 0x080c, 0x6dc1, 0x080c,
+	0x9a2b, 0x080c, 0x6e9e, 0x0005, 0x0056, 0x0066, 0x00d6, 0x00f6,
+	0x2029, 0x0001, 0xa182, 0x0101, 0x1208, 0x0010, 0x2009, 0x0100,
+	0x2130, 0x2069, 0xb698, 0x831c, 0x2300, 0xad18, 0x2009, 0x0020,
+	0xaf90, 0x001d, 0x080c, 0x953f, 0xa6b2, 0x0020, 0x7804, 0xa06d,
+	0x0110, 0x080c, 0x1604, 0x080c, 0x15dd, 0x0500, 0x8528, 0x6837,
+	0x0110, 0x683b, 0x0000, 0x2d20, 0x7c06, 0xa68a, 0x003d, 0x1228,
+	0x2608, 0xad90, 0x000f, 0x0459, 0x0088, 0xa6b2, 0x003c, 0x2009,
+	0x003c, 0x2d78, 0xad90, 0x000f, 0x0411, 0x0c28, 0x00fe, 0x852f,
+	0xa5ad, 0x0003, 0x7d36, 0xa5ac, 0x0000, 0x0028, 0x00fe, 0x852f,
+	0xa5ad, 0x0003, 0x7d36, 0x00de, 0x006e, 0x005e, 0x0005, 0x00f6,
+	0x8dff, 0x0158, 0x6804, 0xa07d, 0x0130, 0x6807, 0x0000, 0x080c,
+	0x5271, 0x2f68, 0x0cb8, 0x080c, 0x5271, 0x00fe, 0x0005, 0x0156,
+	0xa184, 0x0001, 0x0108, 0x8108, 0x810c, 0x21a8, 0x2304, 0x8007,
+	0x2012, 0x8318, 0x8210, 0x1f04, 0x9546, 0x015e, 0x0005, 0x0066,
+	0x0126, 0x2091, 0x8000, 0x2031, 0x0001, 0x601c, 0xa084, 0x000f,
+	0x0083, 0x012e, 0x006e, 0x0005, 0x0126, 0x2091, 0x8000, 0x0066,
+	0x2031, 0x0000, 0x601c, 0xa084, 0x000f, 0x001b, 0x006e, 0x012e,
+	0x0005, 0x9586, 0x9586, 0x9581, 0x95a8, 0x9574, 0x9581, 0x95a8,
+	0x9581, 0x9581, 0x9574, 0x9581, 0x080c, 0x14fa, 0x0036, 0x2019,
+	0x0010, 0x080c, 0xa8af, 0x601f, 0x0006, 0x6003, 0x0007, 0x003e,
+	0x0005, 0xa006, 0x0005, 0xa085, 0x0001, 0x0005, 0x00d6, 0x86ff,
+	0x11d8, 0x6010, 0x2068, 0x080c, 0x986a, 0x01c0, 0x6834, 0xa086,
+	0x0139, 0x1128, 0x684b, 0x0005, 0x6853, 0x0000, 0x0028, 0xa00e,
+	0x2001, 0x0005, 0x080c, 0x5344, 0x080c, 0x9ae0, 0x080c, 0x5271,
+	0x080c, 0x82eb, 0xa085, 0x0001, 0x00de, 0x0005, 0xa006, 0x0ce0,
+	0x6000, 0xa08a, 0x0010, 0x1a0c, 0x14fa, 0x000b, 0x0005, 0x95bf,
+	0x95e0, 0x95c1, 0x95ff, 0x95dd, 0x95bf, 0x9581, 0x9586, 0x9586,
+	0x9581, 0x9581, 0x9581, 0x9581, 0x9581, 0x9581, 0x9581, 0x080c,
+	0x14fa, 0x86ff, 0x11b8, 0x601c, 0xa086, 0x0006, 0x0198, 0x00d6,
+	0x6010, 0x2068, 0x080c, 0x986a, 0x0110, 0x080c, 0x9ae0, 0x00de,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x080c, 0x69f6,
+	0x080c, 0x6e9e, 0xa085, 0x0001, 0x0005, 0x080c, 0x190f, 0x0c08,
+	0x00e6, 0x2071, 0xb3d9, 0x7024, 0xac06, 0x1110, 0x080c, 0x7c41,
+	0x601c, 0xa084, 0x000f, 0xa086, 0x0006, 0x1150, 0x0086, 0x0096,
+	0x2049, 0x0001, 0x2c40, 0x080c, 0x7e0d, 0x009e, 0x008e, 0x0010,
+	0x080c, 0x7b3e, 0x00ee, 0x1928, 0x080c, 0x9581, 0x0005, 0x0036,
+	0x00e6, 0x2071, 0xb3d9, 0x703c, 0xac06, 0x1140, 0x2019, 0x0000,
+	0x080c, 0x7cc4, 0x00ee, 0x003e, 0x0804, 0x95c1, 0x080c, 0x7f2b,
+	0x00ee, 0x003e, 0x1904, 0x95c1, 0x080c, 0x9581, 0x0005, 0x00c6,
+	0x601c, 0xa084, 0x000f, 0x0013, 0x00ce, 0x0005, 0x9630, 0x969a,
+	0x97c8, 0x963b, 0x9a2b, 0x9630, 0xa8a1, 0x82eb, 0x969a, 0x9629,
+	0x9833, 0x080c, 0x14fa, 0x080c, 0x9a66, 0x1110, 0x080c, 0x8890,
+	0x0005, 0x080c, 0x6dc1, 0x080c, 0x6e9e, 0x080c, 0x82eb, 0x0005,
+	0x6017, 0x0001, 0x0005, 0x6010, 0xa080, 0x0019, 0x2c02, 0x6000,
+	0xa08a, 0x0010, 0x1a0c, 0x14fa, 0x000b, 0x0005, 0x9656, 0x9658,
+	0x9678, 0x968a, 0x9697, 0x9656, 0x9630, 0x9630, 0x9630, 0x968a,
+	0x968a, 0x9656, 0x9656, 0x9656, 0x9656, 0x9694, 0x080c, 0x14fa,
+	0x00e6, 0x6010, 0x2070, 0x7050, 0xc0b5, 0x7052, 0x2071, 0xb3d9,
+	0x7024, 0xac06, 0x0190, 0x080c, 0x7b3e, 0x6007, 0x0085, 0x6003,
+	0x000b, 0x601f, 0x0002, 0x2001, 0xb3b6, 0x2004, 0x6016, 0x080c,
+	0x69f6, 0x080c, 0x6e9e, 0x00ee, 0x0005, 0x6017, 0x0001, 0x0cd8,
+	0x00d6, 0x6010, 0x2068, 0x6850, 0xc0b5, 0x6852, 0x00de, 0x6007,
+	0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x080c, 0x69f6, 0x080c,
+	0x6e9e, 0x0005, 0x00d6, 0x6017, 0x0001, 0x6010, 0x2068, 0x6850,
+	0xc0b5, 0x6852, 0x00de, 0x0005, 0x080c, 0x82eb, 0x0005, 0x080c,
+	0x190f, 0x08f0, 0x6000, 0xa08a, 0x0010, 0x1a0c, 0x14fa, 0x000b,
+	0x0005, 0x96b1, 0x9638, 0x96b3, 0x96b1, 0x96b3, 0x96b3, 0x9631,
+	0x96b1, 0x962b, 0x962b, 0x96b1, 0x96b1, 0x96b1, 0x96b1, 0x96b1,
+	0x96b1, 0x080c, 0x14fa, 0x00d6, 0x6018, 0x2068, 0x6804, 0xa084,
+	0x00ff, 0x00de, 0xa08a, 0x000c, 0x1a0c, 0x14fa, 0x000b, 0x0005,
+	0x96cc, 0x976e, 0x96ce, 0x9708, 0x96ce, 0x9708, 0x96ce, 0x96d8,
+	0x96cc, 0x9708, 0x96cc, 0x96f4, 0x080c, 0x14fa, 0x6004, 0xa08e,
+	0x0016, 0x0588, 0xa08e, 0x0004, 0x0570, 0xa08e, 0x0002, 0x0558,
+	0x6004, 0x080c, 0x9a66, 0x0904, 0x9787, 0xa08e, 0x0021, 0x0904,
+	0x978b, 0xa08e, 0x0022, 0x0904, 0x9787, 0xa08e, 0x003d, 0x0904,
+	0x978b, 0xa08e, 0x0039, 0x0904, 0x978f, 0xa08e, 0x0035, 0x0904,
+	0x978f, 0xa08e, 0x001e, 0x0188, 0xa08e, 0x0001, 0x1150, 0x00d6,
+	0x6018, 0x2068, 0x6804, 0xa084, 0x00ff, 0x00de, 0xa086, 0x0006,
+	0x0110, 0x080c, 0x2b73, 0x080c, 0x8890, 0x080c, 0x9a2b, 0x0005,
+	0x00c6, 0x00d6, 0x6104, 0xa186, 0x0016, 0x0904, 0x975f, 0xa186,
+	0x0002, 0x1518, 0x6018, 0x2068, 0x2001, 0xb134, 0x2004, 0xd0ac,
+	0x1904, 0x97b1, 0x68a0, 0xd0bc, 0x1904, 0x97b1, 0x6840, 0xa084,
+	0x00ff, 0xa005, 0x0190, 0x8001, 0x6842, 0x6013, 0x0000, 0x601f,
+	0x0007, 0x6017, 0x0398, 0x603f, 0x0000, 0x080c, 0x8295, 0x0128,
+	0x2d00, 0x601a, 0x601f, 0x0001, 0x0450, 0x00de, 0x00ce, 0x6004,
+	0xa08e, 0x0002, 0x11a8, 0x6018, 0xa080, 0x0028, 0x2004, 0xa086,
+	0x007e, 0x1170, 0x2009, 0xb134, 0x2104, 0xc085, 0x200a, 0x00e6,
+	0x2071, 0xb100, 0x080c, 0x4a3b, 0x00ee, 0x080c, 0x8890, 0x0020,
+	0x080c, 0x8890, 0x080c, 0x2b73, 0x00e6, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x2b99, 0x012e, 0x00ee, 0x080c, 0x9a2b, 0x0005, 0x2001,
+	0x0002, 0x080c, 0x4d75, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c,
+	0x6a3c, 0x080c, 0x6e9e, 0x00de, 0x00ce, 0x0c80, 0x00c6, 0x00d6,
+	0x6104, 0xa186, 0x0016, 0x0d58, 0x6018, 0x2068, 0x6840, 0xa084,
+	0x00ff, 0xa005, 0x0904, 0x9735, 0x8001, 0x6842, 0x6003, 0x0001,
+	0x080c, 0x6a3c, 0x080c, 0x6e9e, 0x00de, 0x00ce, 0x08b8, 0x080c,
+	0x8890, 0x0804, 0x9705, 0x080c, 0x88be, 0x0804, 0x9705, 0x00d6,
+	0x2c68, 0x6104, 0x080c, 0x9d16, 0x00de, 0x0118, 0x080c, 0x82eb,
+	0x00b8, 0x6004, 0x8007, 0x6130, 0xa18c, 0x00ff, 0xa105, 0x6032,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x6038, 0x600a,
+	0x2001, 0xb3b6, 0x2004, 0x6016, 0x080c, 0x69f6, 0x080c, 0x6e9e,
+	0x0005, 0x00de, 0x00ce, 0x080c, 0x8890, 0x080c, 0x2b73, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x2b99, 0x6013, 0x0000, 0x601f,
+	0x0007, 0x6017, 0x0398, 0x603f, 0x0000, 0x012e, 0x00ee, 0x0005,
+	0x6000, 0xa08a, 0x0010, 0x1a0c, 0x14fa, 0x000b, 0x0005, 0x97df,
+	0x97df, 0x97df, 0x97df, 0x97df, 0x97df, 0x97df, 0x97df, 0x97df,
+	0x9630, 0x97df, 0x9638, 0x97e1, 0x9638, 0x97ee, 0x97df, 0x080c,
+	0x14fa, 0x6004, 0xa086, 0x008b, 0x0148, 0x6007, 0x008b, 0x6003,
+	0x000d, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x0005, 0x080c, 0x9a1f,
+	0x080c, 0x986a, 0x0580, 0x080c, 0x2b73, 0x00d6, 0x080c, 0x986a,
+	0x0168, 0x6010, 0x2068, 0x6837, 0x0103, 0x684b, 0x0006, 0x6847,
+	0x0000, 0x6850, 0xc0ed, 0x6852, 0x080c, 0x5271, 0x2c68, 0x080c,
+	0x8295, 0x0150, 0x6818, 0x601a, 0x080c, 0x9c35, 0x00c6, 0x2d60,
+	0x080c, 0x9a2b, 0x00ce, 0x0008, 0x2d60, 0x00de, 0x6013, 0x0000,
+	0x601f, 0x0001, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x6a3c,
+	0x080c, 0x6e9e, 0x0078, 0x6030, 0xa08c, 0xff00, 0x810f, 0xa186,
+	0x0039, 0x0118, 0xa186, 0x0035, 0x1118, 0x080c, 0x2b73, 0x08b0,
+	0x080c, 0x9a2b, 0x0005, 0x6000, 0xa08a, 0x0010, 0x1a0c, 0x14fa,
+	0x000b, 0x0005, 0x984a, 0x984a, 0x984a, 0x984c, 0x984d, 0x984a,
+	0x984a, 0x984a, 0x984a, 0x984a, 0x984a, 0x984a, 0x984a, 0x984a,
+	0x984a, 0x984a, 0x080c, 0x14fa, 0x0005, 0x080c, 0x7f2b, 0x190c,
+	0x14fa, 0x6110, 0x2168, 0x684b, 0x0006, 0x080c, 0x5271, 0x080c,
+	0x82eb, 0x0005, 0xa284, 0x0007, 0x1158, 0xa282, 0xb800, 0x0240,
+	0x2001, 0xb116, 0x2004, 0xa202, 0x1218, 0xa085, 0x0001, 0x0005,
+	0xa006, 0x0ce8, 0x0026, 0x6210, 0xa294, 0xf000, 0x002e, 0x0005,
+	0x00e6, 0x00c6, 0x0036, 0x0006, 0x0126, 0x2091, 0x8000, 0x2061,
+	0xb800, 0x2071, 0xb100, 0x7344, 0x7064, 0xa302, 0x12a8, 0x601c,
+	0xa206, 0x1160, 0x080c, 0x9bc0, 0x0148, 0x080c, 0x9a66, 0x1110,
+	0x080c, 0x8890, 0x00c6, 0x080c, 0x82eb, 0x00ce, 0xace0, 0x0018,
+	0x7058, 0xac02, 0x1208, 0x0c38, 0x012e, 0x000e, 0x003e, 0x00ce,
+	0x00ee, 0x0005, 0x00e6, 0x00c6, 0x0016, 0xa188, 0xb235, 0x210c,
+	0x81ff, 0x0170, 0x2061, 0xb800, 0x2071, 0xb100, 0x0016, 0x080c,
+	0x8295, 0x001e, 0x0138, 0x611a, 0x080c, 0x2b73, 0x080c, 0x82eb,
+	0xa006, 0x0010, 0xa085, 0x0001, 0x001e, 0x00ce, 0x00ee, 0x0005,
+	0x00c6, 0x0056, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x8295,
+	0x005e, 0x0180, 0x6612, 0x651a, 0x080c, 0x9c35, 0x601f, 0x0003,
+	0x2009, 0x004b, 0x080c, 0x831a, 0xa085, 0x0001, 0x012e, 0x005e,
+	0x00ce, 0x0005, 0xa006, 0x0cd0, 0x00c6, 0x0056, 0x0126, 0x2091,
+	0x8000, 0x62a0, 0x00c6, 0x080c, 0x9ae4, 0x005e, 0x0550, 0x6013,
+	0x0000, 0x651a, 0x080c, 0x9c35, 0x601f, 0x0003, 0x0016, 0x00c6,
+	0x2560, 0x080c, 0x501c, 0x00ce, 0x080c, 0x6b35, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x6a6b, 0x2c08, 0x080c, 0xaa51, 0x007e, 0x001e,
+	0xd184, 0x0128, 0x080c, 0x82eb, 0xa085, 0x0001, 0x0030, 0x2009,
+	0x004c, 0x080c, 0x831a, 0xa085, 0x0001, 0x012e, 0x005e, 0x00ce,
+	0x0005, 0xa006, 0x0cd0, 0x00f6, 0x00c6, 0x0046, 0x00c6, 0x080c,
+	0x8295, 0x2c78, 0x00ce, 0x0180, 0x7e12, 0x2c00, 0x781a, 0x781f,
+	0x0003, 0x2021, 0x0005, 0x080c, 0x9960, 0x2f60, 0x2009, 0x004d,
+	0x080c, 0x831a, 0xa085, 0x0001, 0x004e, 0x00ce, 0x00fe, 0x0005,
+	0x00f6, 0x00c6, 0x0046, 0x00c6, 0x080c, 0x8295, 0x2c78, 0x00ce,
+	0x0178, 0x7e12, 0x2c00, 0x781a, 0x781f, 0x0003, 0x2021, 0x0005,
+	0x0439, 0x2f60, 0x2009, 0x004e, 0x080c, 0x831a, 0xa085, 0x0001,
+	0x004e, 0x00ce, 0x00fe, 0x0005, 0x00f6, 0x00c6, 0x0046, 0x00c6,
+	0x080c, 0x8295, 0x2c78, 0x00ce, 0x0178, 0x7e12, 0x2c00, 0x781a,
+	0x781f, 0x0003, 0x2021, 0x0004, 0x0059, 0x2f60, 0x2009, 0x0052,
+	0x080c, 0x831a, 0xa085, 0x0001, 0x004e, 0x00ce, 0x00fe, 0x0005,
+	0x0096, 0x0076, 0x0126, 0x2091, 0x8000, 0x080c, 0x4fbe, 0x0118,
+	0x2001, 0x9965, 0x0028, 0x080c, 0x4f90, 0x0158, 0x2001, 0x996b,
+	0x0006, 0xa00e, 0x2400, 0x080c, 0x5344, 0x080c, 0x5271, 0x000e,
+	0x0807, 0x2418, 0x080c, 0x6d63, 0x62a0, 0x0086, 0x2041, 0x0001,
+	0x2039, 0x0001, 0x2608, 0x080c, 0x6b4e, 0x008e, 0x080c, 0x6a6b,
+	0x2f08, 0x2648, 0x080c, 0xaa51, 0x613c, 0x81ff, 0x090c, 0x6bf7,
+	0x012e, 0x007e, 0x009e, 0x0005, 0x00c6, 0x0126, 0x2091, 0x8000,
+	0x00c6, 0x080c, 0x8295, 0x001e, 0x0188, 0x660a, 0x611a, 0x080c,
+	0x9c35, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x001f, 0x080c,
+	0x831a, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x8295, 0x001e,
+	0x0188, 0x660a, 0x611a, 0x080c, 0x9c35, 0x601f, 0x0008, 0x2d00,
+	0x6012, 0x2009, 0x0021, 0x080c, 0x831a, 0xa085, 0x0001, 0x012e,
+	0x00ce, 0x0005, 0xa006, 0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000,
+	0x00c6, 0x080c, 0x8295, 0x001e, 0x0188, 0x660a, 0x611a, 0x080c,
+	0x9c35, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x003d, 0x080c,
+	0x831a, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x9ae4, 0x001e,
+	0x0180, 0x611a, 0x080c, 0x9c35, 0x601f, 0x0001, 0x2d00, 0x6012,
+	0x2009, 0x0000, 0x080c, 0x831a, 0xa085, 0x0001, 0x012e, 0x00ce,
+	0x0005, 0xa006, 0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6,
+	0x080c, 0x8295, 0x001e, 0x0188, 0x660a, 0x611a, 0x080c, 0x9c35,
+	0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x0044, 0x080c, 0x831a,
+	0xa085, 0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8, 0x0026,
+	0x00d6, 0x6218, 0x2268, 0x6a3c, 0x82ff, 0x0110, 0x8211, 0x6a3e,
+	0x00de, 0x002e, 0x0005, 0x0006, 0x6000, 0xa086, 0x0000, 0x0190,
+	0x6013, 0x0000, 0x601f, 0x0007, 0x2001, 0xb3b5, 0x2004, 0x0006,
+	0xa082, 0x0051, 0x000e, 0x0208, 0x8004, 0x6016, 0x080c, 0xaf00,
+	0x603f, 0x0000, 0x000e, 0x0005, 0x0066, 0x00c6, 0x00d6, 0x2031,
+	0xb153, 0x2634, 0xd6e4, 0x0128, 0x6618, 0x2660, 0x6e48, 0x080c,
+	0x4f49, 0x00de, 0x00ce, 0x006e, 0x0005, 0x0006, 0x0016, 0x6004,
+	0xa08e, 0x0002, 0x0140, 0xa08e, 0x0003, 0x0128, 0xa08e, 0x0004,
+	0x0110, 0xa085, 0x0001, 0x001e, 0x000e, 0x0005, 0x0006, 0x00d6,
+	0x6010, 0xa06d, 0x0148, 0x6834, 0xa086, 0x0139, 0x0138, 0x6838,
+	0xd0fc, 0x0110, 0xa006, 0x0010, 0xa085, 0x0001, 0x00de, 0x000e,
+	0x0005, 0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x8295,
+	0x001e, 0x0190, 0x611a, 0x080c, 0x9c35, 0x601f, 0x0001, 0x2d00,
+	0x6012, 0x080c, 0x2b73, 0x2009, 0x0028, 0x080c, 0x831a, 0xa085,
+	0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8, 0xa186, 0x0015,
+	0x1178, 0x2011, 0xb120, 0x2204, 0xa086, 0x0074, 0x1148, 0x080c,
+	0x8bed, 0x6003, 0x0001, 0x6007, 0x0029, 0x080c, 0x6a3c, 0x0020,
+	0x080c, 0x8890, 0x080c, 0x82eb, 0x0005, 0xa186, 0x0016, 0x1128,
+	0x2001, 0x0004, 0x080c, 0x4d75, 0x00e8, 0xa186, 0x0015, 0x11e8,
+	0x2011, 0xb120, 0x2204, 0xa086, 0x0014, 0x11b8, 0x00d6, 0x6018,
+	0x2068, 0x080c, 0x4ebf, 0x00de, 0x080c, 0x8ca6, 0x1170, 0x00d6,
+	0x6018, 0x2068, 0x6890, 0x00de, 0xa005, 0x0138, 0x2001, 0x0006,
+	0x080c, 0x4d75, 0x080c, 0x8469, 0x0020, 0x080c, 0x8890, 0x080c,
+	0x82eb, 0x0005, 0x6848, 0xa086, 0x0005, 0x1108, 0x0009, 0x0005,
+	0x6850, 0xc0ad, 0x6852, 0x0005, 0x00e6, 0x0126, 0x2071, 0xb100,
+	0x2091, 0x8000, 0x7544, 0xa582, 0x0001, 0x0608, 0x7048, 0x2060,
+	0x6000, 0xa086, 0x0000, 0x0148, 0xace0, 0x0018, 0x7058, 0xac02,
+	0x1208, 0x0cb0, 0x2061, 0xb800, 0x0c98, 0x6003, 0x0008, 0x8529,
+	0x7546, 0xaca8, 0x0018, 0x7058, 0xa502, 0x1230, 0x754a, 0xa085,
+	0x0001, 0x012e, 0x00ee, 0x0005, 0x704b, 0xb800, 0x0cc0, 0xa006,
+	0x0cc0, 0x00e6, 0x2071, 0xb68c, 0x7014, 0xd0e4, 0x0150, 0x6013,
+	0x0000, 0x6003, 0x0001, 0x6007, 0x0050, 0x080c, 0x69f6, 0x080c,
+	0x6e9e, 0x00ee, 0x0005, 0x00c6, 0x00f6, 0x2c78, 0x080c, 0x5177,
+	0x00fe, 0x0120, 0x601c, 0xa084, 0x000f, 0x0013, 0x00ce, 0x0005,
+	0x9630, 0x9b3b, 0x9b3e, 0x9b41, 0xaced, 0xad08, 0xad0b, 0x9630,
+	0x9630, 0x080c, 0x14fa, 0xe000, 0xe000, 0x0005, 0xe000, 0xe000,
+	0x0005, 0x0009, 0x0005, 0x00f6, 0x2c78, 0x080c, 0x5177, 0x0538,
+	0x080c, 0x8295, 0x1128, 0x2001, 0xb3b7, 0x2004, 0x783e, 0x00f8,
+	0x7818, 0x601a, 0x080c, 0x9c35, 0x781c, 0xa086, 0x0003, 0x0128,
+	0x7808, 0x6036, 0x2f00, 0x603a, 0x0020, 0x7808, 0x603a, 0x2f00,
+	0x6036, 0x602a, 0x601f, 0x0001, 0x6007, 0x0035, 0x6003, 0x0001,
+	0x7950, 0x6152, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x2f60, 0x00fe,
+	0x0005, 0x0016, 0x00f6, 0x682c, 0x6032, 0xa08e, 0x0001, 0x0138,
+	0xa086, 0x0005, 0x0140, 0xa006, 0x602a, 0x602e, 0x00a0, 0x6820,
+	0xc0f4, 0xc0d5, 0x6822, 0x6810, 0x2078, 0x787c, 0x6938, 0xa102,
+	0x7880, 0x6934, 0xa103, 0x1e78, 0x6834, 0x602a, 0x6838, 0xa084,
+	0xfffc, 0x683a, 0x602e, 0x2d00, 0x6036, 0x6808, 0x603a, 0x6918,
+	0x611a, 0x6950, 0x6152, 0x601f, 0x0001, 0x6007, 0x0039, 0x6003,
+	0x0001, 0x080c, 0x69f6, 0x6803, 0x0002, 0x00fe, 0x001e, 0x0005,
+	0x00f6, 0x2c78, 0x080c, 0x5177, 0x1118, 0xa085, 0x0001, 0x0070,
+	0x6020, 0xd0f4, 0x1150, 0xc0f5, 0x6022, 0x6010, 0x2078, 0x7828,
+	0x603a, 0x782c, 0x6036, 0x080c, 0x190f, 0xa006, 0x00fe, 0x0005,
+	0x0006, 0x0016, 0x6004, 0xa08e, 0x0034, 0x01b8, 0xa08e, 0x0035,
+	0x01a0, 0xa08e, 0x0036, 0x0188, 0xa08e, 0x0037, 0x0170, 0xa08e,
+	0x0038, 0x0158, 0xa08e, 0x0039, 0x0140, 0xa08e, 0x003a, 0x0128,
+	0xa08e, 0x003b, 0x0110, 0xa085, 0x0001, 0x001e, 0x000e, 0x0005,
+	0x0006, 0x0016, 0x0026, 0x0036, 0x00e6, 0x2001, 0xb3b1, 0x200c,
+	0x8000, 0x2014, 0x2001, 0x0032, 0x080c, 0x68b3, 0x2001, 0xb3b5,
+	0x82ff, 0x1110, 0x2011, 0x0002, 0x2202, 0x2001, 0xb3b3, 0x200c,
+	0x8000, 0x2014, 0x2071, 0xb38e, 0x711a, 0x721e, 0x2001, 0x0064,
+	0x080c, 0x68b3, 0x2001, 0xb3b6, 0x82ff, 0x1110, 0x2011, 0x0002,
+	0x2202, 0x2009, 0xb3b7, 0xa280, 0x000a, 0x200a, 0x080c, 0x5193,
+	0x00ee, 0x003e, 0x002e, 0x001e, 0x000e, 0x0005, 0x0006, 0x00e6,
+	0x2001, 0xb3b5, 0x2003, 0x0028, 0x2001, 0xb3b6, 0x2003, 0x0014,
+	0x2071, 0xb38e, 0x701b, 0x0000, 0x701f, 0x07d0, 0x2001, 0xb3b7,
+	0x2003, 0x001e, 0x00ee, 0x000e, 0x0005, 0x00d6, 0x6054, 0xa06d,
+	0x0110, 0x080c, 0x15f4, 0x00de, 0x0005, 0x0005, 0x00c6, 0x0126,
+	0x2091, 0x8000, 0x00c6, 0x080c, 0x8295, 0x001e, 0x0178, 0x611a,
+	0x0ca1, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x0033, 0x080c,
+	0x831a, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8,
+	0x00d6, 0x00e6, 0x00f6, 0x2071, 0xb100, 0xa186, 0x0015, 0x1500,
+	0x7080, 0xa086, 0x0018, 0x11e0, 0x6010, 0x2068, 0x6a3c, 0xd2e4,
+	0x1160, 0x2c78, 0x080c, 0x705a, 0x01d8, 0x706c, 0x6a50, 0xa206,
+	0x1160, 0x7070, 0x6a54, 0xa206, 0x1140, 0x6218, 0xa290, 0x0028,
+	0x2214, 0x2009, 0x0000, 0x080c, 0x2bb8, 0x080c, 0x8469, 0x0020,
+	0x080c, 0x8890, 0x080c, 0x82eb, 0x00fe, 0x00ee, 0x00de, 0x0005,
+	0x7050, 0x6a54, 0xa206, 0x0d48, 0x0c80, 0x00c6, 0x0126, 0x2091,
+	0x8000, 0x00c6, 0x080c, 0x8295, 0x001e, 0x0180, 0x611a, 0x080c,
+	0x9c35, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x0043, 0x080c,
+	0x831a, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8,
+	0x00d6, 0x00e6, 0x00f6, 0x2071, 0xb100, 0xa186, 0x0015, 0x11c0,
+	0x7080, 0xa086, 0x0004, 0x11a0, 0x6010, 0xa0e8, 0x000f, 0x2c78,
+	0x080c, 0x705a, 0x01a8, 0x706c, 0x6a08, 0xa206, 0x1130, 0x7070,
+	0x6a0c, 0xa206, 0x1110, 0x080c, 0x2b73, 0x080c, 0x8469, 0x0020,
+	0x080c, 0x8890, 0x080c, 0x82eb, 0x00fe, 0x00ee, 0x00de, 0x0005,
+	0x7050, 0x6a0c, 0xa206, 0x0d78, 0x0c80, 0x0016, 0x0026, 0x684c,
+	0xd0ac, 0x0178, 0x6914, 0x6a10, 0x2100, 0xa205, 0x0150, 0x6860,
+	0xa106, 0x1118, 0x685c, 0xa206, 0x0120, 0x6962, 0x6a5e, 0xa085,
+	0x0001, 0x002e, 0x001e, 0x0005, 0x00d6, 0x0036, 0x6310, 0x2368,
+	0x684a, 0x6952, 0xa29e, 0x4000, 0x11a0, 0x00c6, 0x6318, 0x2360,
+	0x2009, 0x0000, 0x6838, 0xd0f4, 0x1140, 0x080c, 0x50bc, 0x1108,
+	0xc185, 0x6000, 0xd0bc, 0x0108, 0xc18d, 0x6a66, 0x696a, 0x00ce,
+	0x0080, 0x6a66, 0x3918, 0xa398, 0x0006, 0x231c, 0x686b, 0x0004,
+	0x6b72, 0x00c6, 0x6318, 0x2360, 0x6004, 0xa084, 0x00ff, 0x686e,
+	0x00ce, 0x080c, 0x5271, 0x003e, 0x00de, 0x0005, 0x00c6, 0x0026,
+	0x0016, 0xa186, 0x0035, 0x0110, 0x6a34, 0x0008, 0x6a28, 0x080c,
+	0x985a, 0x01f0, 0x2260, 0x611c, 0xa186, 0x0003, 0x0118, 0xa186,
+	0x0006, 0x1190, 0x6834, 0xa206, 0x0140, 0x6838, 0xa206, 0x1160,
+	0x6108, 0x6834, 0xa106, 0x1140, 0x0020, 0x6008, 0x6938, 0xa106,
+	0x1118, 0x6018, 0x6918, 0xa106, 0x001e, 0x002e, 0x00ce, 0x0005,
+	0xa085, 0x0001, 0x0cc8, 0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c,
+	0x14fa, 0x0013, 0x006e, 0x0005, 0x9d5c, 0xa224, 0xa353, 0x9d5c,
+	0x9d5c, 0x9d5c, 0x9d5c, 0x9d5c, 0x9d94, 0xa3cf, 0x9d5c, 0x9d5c,
+	0x9d5c, 0x9d5c, 0x9d5c, 0x9d5c, 0x080c, 0x14fa, 0x0066, 0x6000,
+	0xa0b2, 0x0010, 0x1a0c, 0x14fa, 0x0013, 0x006e, 0x0005, 0x9d77,
+	0xa846, 0x9d77, 0x9d77, 0x9d77, 0x9d77, 0x9d77, 0x9d77, 0xa80a,
+	0xa88e, 0x9d77, 0xae32, 0xae62, 0xae32, 0xae62, 0x9d77, 0x080c,
+	0x14fa, 0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c, 0x14fa, 0x0013,
+	0x006e, 0x0005, 0x9d92, 0xa511, 0xa5de, 0xa60b, 0xa68f, 0x9d92,
+	0xa77c, 0xa727, 0xa3db, 0xa7e0, 0xa7f5, 0x9d92, 0x9d92, 0x9d92,
+	0x9d92, 0x9d92, 0x080c, 0x14fa, 0xa1b2, 0x0080, 0x1a0c, 0x14fa,
+	0x2100, 0xa1b2, 0x0040, 0x1a04, 0xa198, 0x0002, 0x9dde, 0x9fa9,
+	0x9dde, 0x9dde, 0x9dde, 0x9fb0, 0x9dde, 0x9dde, 0x9dde, 0x9dde,
+	0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9dde,
+	0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9de0, 0x9e3e, 0x9e4d,
+	0x9e9b, 0x9eb9, 0x9f37, 0x9f96, 0x9dde, 0x9dde, 0x9fb3, 0x9dde,
+	0x9dde, 0x9fc6, 0x9fd1, 0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9dde,
+	0xa04d, 0x9dde, 0x9dde, 0xa05c, 0x9dde, 0x9dde, 0xa023, 0x9dde,
+	0x9dde, 0x9dde, 0xa074, 0x9dde, 0x9dde, 0x9dde, 0xa0ee, 0x9dde,
+	0x9dde, 0x9dde, 0x9dde, 0x9dde, 0x9dde, 0xa15f, 0x080c, 0x14fa,
+	0x080c, 0x517b, 0x1150, 0x2001, 0xb134, 0x2004, 0xd0cc, 0x1128,
+	0xa084, 0x0009, 0xa086, 0x0008, 0x1140, 0x6007, 0x0009, 0x602b,
+	0x0009, 0x6013, 0x0000, 0x0804, 0x9fa4, 0x080c, 0x516b, 0x00e6,
+	0x00c6, 0x0036, 0x0026, 0x0016, 0x6218, 0x2270, 0x72a0, 0x0026,
+	0x2019, 0x0029, 0x080c, 0x6b35, 0x0076, 0x2039, 0x0000, 0x080c,
+	0x6a6b, 0x2c08, 0x080c, 0xaa51, 0x007e, 0x001e, 0x2e60, 0x080c,
+	0x501c, 0x001e, 0x002e, 0x003e, 0x00ce, 0x00ee, 0x6618, 0x00c6,
+	0x2660, 0x080c, 0x4e30, 0x00ce, 0xa6b0, 0x0001, 0x2634, 0xa684,
+	0x00ff, 0xa082, 0x0006, 0x0278, 0x080c, 0xa995, 0x1904, 0x9e95,
+	0x080c, 0xa935, 0x1120, 0x6007, 0x0008, 0x0804, 0x9fa4, 0x6007,
+	0x0009, 0x0804, 0x9fa4, 0x080c, 0xab41, 0x0128, 0x080c, 0xa995,
+	0x0d78, 0x0804, 0x9e95, 0x6013, 0x1900, 0x0c88, 0x080c, 0x2c87,
+	0x1904, 0xa195, 0x6106, 0x080c, 0xa8ef, 0x6007, 0x0006, 0x0804,
+	0x9fa4, 0x6007, 0x0007, 0x0804, 0x9fa4, 0x080c, 0xae96, 0x1904,
+	0xa195, 0x080c, 0x2c87, 0x1904, 0xa195, 0x00d6, 0x6618, 0x2668,
+	0x6e04, 0xa684, 0x00ff, 0xa082, 0x0006, 0x1220, 0x2001, 0x0001,
+	0x080c, 0x4d63, 0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0188,
+	0xa686, 0x0004, 0x0170, 0x6e04, 0xa6b4, 0x00ff, 0xa686, 0x0006,
+	0x0140, 0xa686, 0x0004, 0x0128, 0xa686, 0x0005, 0x0110, 0x00de,
+	0x00e0, 0x080c, 0xa9f3, 0x11a0, 0xa686, 0x0006, 0x1150, 0x0026,
+	0x6218, 0xa290, 0x0028, 0x2214, 0x2009, 0x0000, 0x080c, 0x2bb8,
+	0x002e, 0x080c, 0x4ebf, 0x6007, 0x000a, 0x00de, 0x0804, 0x9fa4,
+	0x6007, 0x000b, 0x00de, 0x0804, 0x9fa4, 0x080c, 0x2b73, 0x6007,
+	0x0001, 0x0804, 0x9fa4, 0x080c, 0xae96, 0x1904, 0xa195, 0x080c,
+	0x2c87, 0x1904, 0xa195, 0x6618, 0x00d6, 0x2668, 0x6e04, 0x00de,
+	0xa686, 0x0707, 0x0d50, 0x0026, 0x6218, 0xa290, 0x0028, 0x2214,
+	0x2009, 0x0000, 0x080c, 0x2bb8, 0x002e, 0x6007, 0x000c, 0x0804,
+	0x9fa4, 0x080c, 0x517b, 0x1140, 0x2001, 0xb134, 0x2004, 0xa084,
+	0x0009, 0xa086, 0x0008, 0x1110, 0x0804, 0x9ded, 0x080c, 0x516b,
+	0x6618, 0xa6b0, 0x0001, 0x2634, 0xa684, 0x00ff, 0xa082, 0x0006,
+	0x06e8, 0x1138, 0x0026, 0x2001, 0x0006, 0x080c, 0x4da2, 0x002e,
+	0x0050, 0xa6b4, 0xff00, 0x8637, 0xa686, 0x0004, 0x0120, 0xa686,
+	0x0006, 0x1904, 0x9e95, 0x080c, 0xaa00, 0x1120, 0x6007, 0x000e,
+	0x0804, 0x9fa4, 0x0046, 0x6418, 0xa4a0, 0x0028, 0x2424, 0xa4a4,
+	0x00ff, 0x8427, 0x0046, 0x080c, 0x2b73, 0x004e, 0x0016, 0xa006,
+	0x2009, 0xb153, 0x210c, 0xd1a4, 0x0158, 0x2009, 0x0029, 0x080c,
+	0xacae, 0x6018, 0x00d6, 0x2068, 0x6800, 0xc0e5, 0x6802, 0x00de,
+	0x001e, 0x004e, 0x6007, 0x0001, 0x0804, 0x9fa4, 0x2001, 0x0001,
+	0x080c, 0x4d63, 0x0156, 0x0016, 0x0026, 0x0036, 0x20a9, 0x0004,
+	0x2019, 0xb105, 0x2011, 0xb690, 0x080c, 0x8d2b, 0x003e, 0x002e,
+	0x001e, 0x015e, 0xa005, 0x0168, 0xa6b4, 0xff00, 0x8637, 0xa682,
+	0x0004, 0x0a04, 0x9e95, 0xa682, 0x0007, 0x0a04, 0x9ee3, 0x0804,
+	0x9e95, 0x6013, 0x1900, 0x6007, 0x0009, 0x0804, 0x9fa4, 0x080c,
+	0x517b, 0x1140, 0x2001, 0xb134, 0x2004, 0xa084, 0x0009, 0xa086,
+	0x0008, 0x1110, 0x0804, 0x9ded, 0x080c, 0x516b, 0x6618, 0xa6b0,
+	0x0001, 0x2634, 0xa684, 0x00ff, 0xa082, 0x0006, 0x06b8, 0xa6b4,
+	0xff00, 0x8637, 0xa686, 0x0004, 0x0120, 0xa686, 0x0006, 0x1904,
+	0x9e95, 0x080c, 0xaa28, 0x1138, 0x080c, 0xa935, 0x1120, 0x6007,
+	0x0010, 0x0804, 0x9fa4, 0x0046, 0x6418, 0xa4a0, 0x0028, 0x2424,
+	0xa4a4, 0x00ff, 0x8427, 0x0046, 0x080c, 0x2b73, 0x004e, 0x0016,
+	0xa006, 0x2009, 0xb153, 0x210c, 0xd1a4, 0x0158, 0x2009, 0x0029,
+	0x080c, 0xacae, 0x6018, 0x00d6, 0x2068, 0x6800, 0xc0e5, 0x6802,
+	0x00de, 0x001e, 0x004e, 0x6007, 0x0001, 0x00f0, 0x080c, 0xab41,
+	0x0140, 0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0950, 0x0804,
+	0x9e95, 0x6013, 0x1900, 0x6007, 0x0009, 0x0070, 0x080c, 0x2c87,
+	0x1904, 0xa195, 0x080c, 0xae96, 0x1904, 0xa195, 0x080c, 0xa1bd,
+	0x1904, 0x9e95, 0x6007, 0x0012, 0x6003, 0x0001, 0x080c, 0x6a3c,
+	0x0005, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x6a3c, 0x0cc0,
+	0x6007, 0x0005, 0x0cc0, 0x080c, 0xae96, 0x1904, 0xa195, 0x080c,
+	0x2c87, 0x1904, 0xa195, 0x080c, 0xa1bd, 0x1904, 0x9e95, 0x6007,
+	0x0020, 0x6003, 0x0001, 0x080c, 0x6a3c, 0x0005, 0x080c, 0x2c87,
+	0x1904, 0xa195, 0x6007, 0x0023, 0x6003, 0x0001, 0x080c, 0x6a3c,
+	0x0005, 0x080c, 0xae96, 0x1904, 0xa195, 0x080c, 0x2c87, 0x1904,
+	0xa195, 0x080c, 0xa1bd, 0x1904, 0x9e95, 0x0016, 0x0026, 0x2011,
+	0xb691, 0x2214, 0xa286, 0xffff, 0x0190, 0x2c08, 0x080c, 0x985a,
+	0x01e0, 0x2260, 0x2011, 0xb690, 0x2214, 0x6008, 0xa206, 0x11a8,
+	0x6018, 0xa190, 0x0006, 0x2214, 0xa206, 0x01e8, 0x0070, 0x2011,
+	0xb690, 0x2214, 0x2c08, 0xa006, 0x080c, 0xac80, 0x11a0, 0x2011,
+	0xb691, 0x2214, 0xa286, 0xffff, 0x01a0, 0x2160, 0x6007, 0x0026,
+	0x6013, 0x1700, 0x2011, 0xb689, 0x2214, 0xa296, 0xffff, 0x1160,
+	0x6007, 0x0025, 0x0048, 0x601c, 0xa086, 0x0007, 0x1d70, 0x080c,
+	0x82eb, 0x2160, 0x6007, 0x0025, 0x6003, 0x0001, 0x080c, 0x6a3c,
+	0x002e, 0x001e, 0x0005, 0x2001, 0x0001, 0x080c, 0x4d63, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x20a9, 0x0004, 0x2019, 0xb105, 0x2011,
+	0xb696, 0x080c, 0x8d2b, 0x003e, 0x002e, 0x001e, 0x015e, 0x0120,
+	0x6007, 0x0031, 0x0804, 0x9fa4, 0x080c, 0x8a69, 0x080c, 0x58d5,
+	0x1158, 0x0006, 0x0026, 0x0036, 0x080c, 0x58f1, 0x0110, 0x080c,
+	0x58ac, 0x003e, 0x002e, 0x000e, 0x0005, 0x080c, 0x2c87, 0x1904,
+	0xa195, 0x6106, 0x080c, 0xa1d9, 0x6007, 0x002b, 0x0804, 0x9fa4,
+	0x6007, 0x002c, 0x0804, 0x9fa4, 0x080c, 0xae96, 0x1904, 0xa195,
+	0x080c, 0x2c87, 0x1904, 0xa195, 0x080c, 0xa1bd, 0x1904, 0x9e95,
+	0x6106, 0x080c, 0xa1dd, 0x1120, 0x6007, 0x002e, 0x0804, 0x9fa4,
+	0x6007, 0x002f, 0x0804, 0x9fa4, 0x080c, 0x2c87, 0x1904, 0xa195,
+	0x00e6, 0x00d6, 0x00c6, 0x6018, 0xa080, 0x0001, 0x200c, 0xa184,
+	0x00ff, 0xa086, 0x0006, 0x0158, 0xa184, 0xff00, 0x8007, 0xa086,
+	0x0006, 0x0128, 0x00ce, 0x00de, 0x00ee, 0x0804, 0x9fa9, 0x2001,
+	0xb172, 0x2004, 0xd0e4, 0x0904, 0xa0eb, 0x2071, 0xb68c, 0x7010,
+	0x6036, 0x7014, 0x603a, 0x7108, 0x720c, 0x2001, 0xb153, 0x2004,
+	0xd0a4, 0x0140, 0x6018, 0x2068, 0x6810, 0xa106, 0x1118, 0x6814,
+	0xa206, 0x01f8, 0x2001, 0xb153, 0x2004, 0xd0ac, 0x1590, 0x2069,
+	0xb100, 0x6870, 0xa206, 0x1568, 0x686c, 0xa106, 0x1550, 0x7210,
+	0x080c, 0x985a, 0x0558, 0x080c, 0xad1a, 0x0540, 0x622a, 0x6007,
+	0x0036, 0x6003, 0x0001, 0x080c, 0x69f6, 0x00ce, 0x00de, 0x00ee,
+	0x0005, 0x7214, 0xa286, 0xffff, 0x0150, 0x080c, 0x985a, 0x01b0,
+	0xa280, 0x0002, 0x2004, 0x7110, 0xa106, 0x1180, 0x0c08, 0x7210,
+	0x2c08, 0xa085, 0x0001, 0x080c, 0xac80, 0x2c10, 0x2160, 0x0130,
+	0x08b8, 0x6007, 0x0037, 0x6013, 0x1500, 0x08d8, 0x6007, 0x0037,
+	0x6013, 0x1700, 0x08b0, 0x6007, 0x0012, 0x0898, 0x080c, 0x2c87,
+	0x1904, 0xa195, 0x6018, 0xa080, 0x0001, 0x2004, 0xa084, 0xff00,
+	0x8007, 0xa086, 0x0006, 0x1904, 0x9fa9, 0x00e6, 0x00d6, 0x00c6,
+	0x2001, 0xb172, 0x2004, 0xd0e4, 0x0904, 0xa157, 0x2069, 0xb100,
+	0x2071, 0xb68c, 0x7008, 0x6036, 0x720c, 0x623a, 0xa286, 0xffff,
+	0x1150, 0x7208, 0x00c6, 0x2c08, 0xa085, 0x0001, 0x080c, 0xac80,
+	0x2c10, 0x00ce, 0x0588, 0x080c, 0x985a, 0x0570, 0x00c6, 0x0026,
+	0x2260, 0x080c, 0x954f, 0x002e, 0x00ce, 0x7118, 0xa18c, 0xff00,
+	0x810f, 0xa186, 0x0001, 0x0158, 0xa186, 0x0005, 0x0118, 0xa186,
+	0x0007, 0x1178, 0xa280, 0x0004, 0x2004, 0xa005, 0x0150, 0x0056,
+	0x7510, 0x7614, 0x080c, 0xad31, 0x005e, 0x00ce, 0x00de, 0x00ee,
+	0x0005, 0x6007, 0x003b, 0x602b, 0x0009, 0x6013, 0x2a00, 0x6003,
+	0x0001, 0x080c, 0x69f6, 0x0c88, 0x6007, 0x003b, 0x602b, 0x0009,
+	0x6013, 0x1700, 0x6003, 0x0001, 0x080c, 0x69f6, 0x0c30, 0x6007,
+	0x003b, 0x602b, 0x000b, 0x6013, 0x0000, 0x0804, 0xa0c1, 0x00e6,
+	0x0026, 0x080c, 0x517b, 0x0558, 0x080c, 0x516b, 0x080c, 0xaf11,
+	0x1520, 0x2071, 0xb100, 0x70d0, 0xc085, 0x70d2, 0x00f6, 0x2079,
+	0x0100, 0x729c, 0xa284, 0x00ff, 0x706e, 0x78e6, 0xa284, 0xff00,
+	0x7270, 0xa205, 0x7072, 0x78ea, 0x00fe, 0x70db, 0x0000, 0x2001,
+	0xb153, 0x2004, 0xd0a4, 0x0120, 0x2011, 0xb3f2, 0x2013, 0x07d0,
+	0xd0ac, 0x1128, 0x080c, 0x2991, 0x0010, 0x080c, 0xaf3d, 0x002e,
+	0x00ee, 0x080c, 0x82eb, 0x0804, 0x9fa8, 0x080c, 0x82eb, 0x0005,
+	0x2600, 0x0002, 0xa1a3, 0xa1a3, 0xa1a3, 0xa1a3, 0xa1a3, 0xa1a5,
+	0xa1a3, 0xa1a3, 0xa1a3, 0x080c, 0x14fa, 0x080c, 0xae96, 0x1d68,
+	0x080c, 0x2c87, 0x1d50, 0x0089, 0x1138, 0x6007, 0x0045, 0x6003,
+	0x0001, 0x080c, 0x6a3c, 0x0005, 0x080c, 0x2b73, 0x6007, 0x0001,
+	0x6003, 0x0001, 0x080c, 0x6a3c, 0x0005, 0x00d6, 0x0066, 0x6618,
+	0x2668, 0x6e04, 0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0170,
+	0xa686, 0x0004, 0x0158, 0x6e04, 0xa6b4, 0x00ff, 0xa686, 0x0006,
+	0x0128, 0xa686, 0x0004, 0x0110, 0xa085, 0x0001, 0x006e, 0x00de,
+	0x0005, 0x00d6, 0x0449, 0x00de, 0x0005, 0x00d6, 0x0491, 0x11f0,
+	0x680c, 0xa08c, 0xff00, 0x6820, 0xa084, 0x00ff, 0xa115, 0x6212,
+	0x6824, 0x602a, 0xd1e4, 0x0118, 0x2009, 0x0001, 0x0060, 0xd1ec,
+	0x0168, 0x6920, 0xa18c, 0x00ff, 0x6824, 0x080c, 0x26f6, 0x1130,
+	0x2110, 0x2009, 0x0000, 0x080c, 0x2bb8, 0x0018, 0xa085, 0x0001,
+	0x0008, 0xa006, 0x00de, 0x0005, 0x2069, 0xb68d, 0x6800, 0xa082,
+	0x0010, 0x1228, 0x6013, 0x0000, 0xa085, 0x0001, 0x0008, 0xa006,
+	0x0005, 0x6013, 0x0000, 0x2069, 0xb68c, 0x6808, 0xa084, 0xff00,
+	0xa086, 0x0800, 0x1140, 0x6800, 0xa084, 0x00ff, 0xa08e, 0x0014,
+	0x0110, 0xa08e, 0x0010, 0x0005, 0x6004, 0xa0b2, 0x0080, 0x1a0c,
+	0x14fa, 0xa1b6, 0x0013, 0x1130, 0x2008, 0xa1b2, 0x0040, 0x1a04,
+	0xa324, 0x0092, 0xa1b6, 0x0027, 0x0120, 0xa1b6, 0x0014, 0x190c,
+	0x14fa, 0x2001, 0x0007, 0x080c, 0x4da2, 0x080c, 0x6dc1, 0x080c,
+	0x9a2b, 0x080c, 0x6e9e, 0x0005, 0xa284, 0xa286, 0xa284, 0xa284,
+	0xa284, 0xa286, 0xa298, 0xa31d, 0xa2e8, 0xa31d, 0xa2f9, 0xa31d,
+	0xa298, 0xa31d, 0xa315, 0xa31d, 0xa315, 0xa31d, 0xa31d, 0xa284,
+	0xa284, 0xa284, 0xa284, 0xa284, 0xa284, 0xa284, 0xa284, 0xa284,
+	0xa284, 0xa284, 0xa286, 0xa284, 0xa31d, 0xa284, 0xa284, 0xa31d,
+	0xa284, 0xa31a, 0xa31d, 0xa284, 0xa284, 0xa284, 0xa284, 0xa31d,
+	0xa31d, 0xa284, 0xa31d, 0xa31d, 0xa284, 0xa292, 0xa284, 0xa284,
+	0xa284, 0xa284, 0xa319, 0xa31d, 0xa284, 0xa284, 0xa31d, 0xa31d,
+	0xa284, 0xa284, 0xa284, 0xa284, 0x080c, 0x14fa, 0x080c, 0x6dc1,
+	0x2001, 0xb3b5, 0x2004, 0x6016, 0x6003, 0x0002, 0x080c, 0x6e9e,
+	0x0804, 0xa323, 0x2001, 0x0000, 0x080c, 0x4d63, 0x0804, 0xa31d,
+	0x00f6, 0x2079, 0xb152, 0x7804, 0x00fe, 0xd0ac, 0x1904, 0xa31d,
+	0x2001, 0x0000, 0x080c, 0x4d63, 0x6018, 0xa080, 0x0004, 0x2004,
+	0xa086, 0x00ff, 0x1140, 0x00f6, 0x2079, 0xb100, 0x7894, 0x8000,
+	0x7896, 0x00fe, 0x00e0, 0x00c6, 0x6018, 0x2060, 0x6000, 0xd0f4,
+	0x1140, 0x6010, 0xa005, 0x0128, 0x00ce, 0x080c, 0x3dcd, 0x0804,
+	0xa31d, 0x00ce, 0x2001, 0xb100, 0x2004, 0xa086, 0x0002, 0x1138,
+	0x00f6, 0x2079, 0xb100, 0x7894, 0x8000, 0x7896, 0x00fe, 0x2001,
+	0x0002, 0x080c, 0x4d75, 0x080c, 0x6dc1, 0x601f, 0x0001, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x080c, 0x6a3c, 0x080c, 0x6e9e, 0x00c6,
+	0x6118, 0x2160, 0x2009, 0x0001, 0x080c, 0x674e, 0x00ce, 0x04d8,
+	0x6618, 0x00d6, 0x2668, 0x6e04, 0x00de, 0xa6b4, 0xff00, 0x8637,
+	0xa686, 0x0006, 0x0550, 0xa686, 0x0004, 0x0538, 0x2001, 0x0004,
+	0x0410, 0x2001, 0xb100, 0x2004, 0xa086, 0x0003, 0x1110, 0x080c,
+	0x3dcd, 0x2001, 0x0006, 0x04a1, 0x6618, 0x00d6, 0x2668, 0x6e04,
+	0x00de, 0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0170, 0x2001,
+	0x0006, 0x0048, 0x2001, 0x0004, 0x0030, 0x2001, 0x0006, 0x0401,
+	0x0020, 0x0018, 0x0010, 0x080c, 0x4da2, 0x080c, 0x6dc1, 0x080c,
+	0x82eb, 0x080c, 0x6e9e, 0x0005, 0x2600, 0x0002, 0xa32f, 0xa32f,
+	0xa32f, 0xa32f, 0xa32f, 0xa331, 0xa32f, 0xa32f, 0xa32f, 0x080c,
+	0x14fa, 0x080c, 0x6dc1, 0x080c, 0x82eb, 0x080c, 0x6e9e, 0x0005,
+	0x0016, 0x00d6, 0x6118, 0x2168, 0x6900, 0xd184, 0x0188, 0x6104,
+	0xa18e, 0x000a, 0x1128, 0x699c, 0xd1a4, 0x1110, 0x2001, 0x0007,
+	0x080c, 0x4d75, 0x2001, 0x0000, 0x080c, 0x4d63, 0x080c, 0x2b99,
+	0x00de, 0x001e, 0x0005, 0x00d6, 0x6618, 0x2668, 0x6804, 0xa084,
+	0xff00, 0x8007, 0x00de, 0xa0b2, 0x000c, 0x1a0c, 0x14fa, 0xa1b6,
+	0x0015, 0x1110, 0x003b, 0x0028, 0xa1b6, 0x0016, 0x190c, 0x14fa,
+	0x006b, 0x0005, 0x8956, 0x8956, 0x8956, 0x8956, 0x8956, 0x8956,
+	0xa3bb, 0xa382, 0x8956, 0x8956, 0x8956, 0x8956, 0x8956, 0x8956,
+	0x8956, 0x8956, 0x8956, 0x8956, 0xa3bb, 0xa3c2, 0x8956, 0x8956,
+	0x8956, 0x8956, 0x00f6, 0x2079, 0xb152, 0x7804, 0xd0ac, 0x11e0,
+	0x6018, 0xa07d, 0x01c8, 0x7800, 0xd0f4, 0x1118, 0x7810, 0xa005,
+	0x1198, 0x2001, 0x0000, 0x080c, 0x4d63, 0x2001, 0x0002, 0x080c,
+	0x4d75, 0x601f, 0x0001, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c,
+	0x6a3c, 0x080c, 0x6e9e, 0x00a8, 0x2011, 0xb683, 0x2204, 0x8211,
+	0x220c, 0x080c, 0x26f6, 0x1168, 0x00c6, 0x080c, 0x4e21, 0x0120,
+	0x00ce, 0x080c, 0x82eb, 0x0028, 0x080c, 0x4a80, 0x00ce, 0x080c,
+	0x82eb, 0x00fe, 0x0005, 0x6604, 0xa6b6, 0x001e, 0x1110, 0x080c,
+	0x82eb, 0x0005, 0x080c, 0x8bea, 0x1138, 0x6003, 0x0001, 0x6007,
+	0x0001, 0x080c, 0x6a3c, 0x0010, 0x080c, 0x82eb, 0x0005, 0x6004,
+	0xa08a, 0x0080, 0x1a0c, 0x14fa, 0x080c, 0x6dc1, 0x080c, 0x9a2b,
+	0x080c, 0x6e9e, 0x0005, 0xa182, 0x0040, 0x0002, 0xa3f1, 0xa3f1,
+	0xa3f1, 0xa3f1, 0xa3f3, 0xa3f1, 0xa3f1, 0xa3f1, 0xa3f1, 0xa3f1,
+	0xa3f1, 0xa3f1, 0xa3f1, 0xa3f1, 0xa3f1, 0xa3f1, 0xa3f1, 0xa3f1,
+	0xa3f1, 0x080c, 0x14fa, 0x00d6, 0x00e6, 0x00f6, 0x0156, 0x0046,
+	0x0026, 0x6218, 0xa280, 0x002b, 0x2004, 0xa005, 0x0120, 0x2021,
+	0x0000, 0x080c, 0xaee2, 0x6106, 0x2071, 0xb680, 0x7444, 0xa4a4,
+	0xff00, 0x0904, 0xa457, 0xa486, 0x2000, 0x1130, 0x2009, 0x0001,
+	0x2011, 0x0200, 0x080c, 0x688d, 0x080c, 0x15dd, 0x090c, 0x14fa,
+	0x6003, 0x0007, 0x2d00, 0x6837, 0x010d, 0x6803, 0x0000, 0x683b,
+	0x0000, 0x6c5a, 0x2c00, 0x685e, 0x6008, 0x68b2, 0x6018, 0x2078,
+	0x78a0, 0x8007, 0x7130, 0x694a, 0x0016, 0xa084, 0xff00, 0x6846,
+	0x684f, 0x0000, 0x6853, 0x0000, 0x6857, 0x0036, 0x080c, 0x5271,
+	0x001e, 0xa486, 0x2000, 0x1130, 0x2019, 0x0017, 0x080c, 0xac2b,
+	0x0804, 0xa4b4, 0xa486, 0x0400, 0x1130, 0x2019, 0x0002, 0x080c,
+	0xabdd, 0x0804, 0xa4b4, 0xa486, 0x0200, 0x1110, 0x080c, 0xabc2,
+	0xa486, 0x1000, 0x1110, 0x080c, 0xac10, 0x0804, 0xa4b4, 0x2069,
+	0xb464, 0x6a00, 0xd284, 0x0904, 0xa50d, 0xa284, 0x0300, 0x1904,
+	0xa506, 0x6804, 0xa005, 0x0904, 0xa4ee, 0x2d78, 0x6003, 0x0007,
+	0x080c, 0x15c4, 0x0904, 0xa4bb, 0x7800, 0xd08c, 0x1118, 0x7804,
+	0x8001, 0x7806, 0x6013, 0x0000, 0x6803, 0x0000, 0x6837, 0x0116,
+	0x683b, 0x0000, 0x6008, 0x68b2, 0x2c00, 0x684a, 0x6018, 0x2078,
+	0x78a0, 0x8007, 0x7130, 0x6986, 0x6846, 0x7928, 0x698a, 0x792c,
+	0x698e, 0x7930, 0x6992, 0x7934, 0x6996, 0x6853, 0x003d, 0x7244,
+	0xa294, 0x0003, 0xa286, 0x0002, 0x1118, 0x684f, 0x0040, 0x0040,
+	0xa286, 0x0001, 0x1118, 0x684f, 0x0080, 0x0010, 0x684f, 0x0000,
+	0x20a9, 0x000a, 0x2001, 0xb690, 0xad90, 0x0015, 0x200c, 0x810f,
+	0x2112, 0x8000, 0x8210, 0x1f04, 0xa4a6, 0x200c, 0x6982, 0x8000,
+	0x200c, 0x697e, 0x080c, 0x5271, 0x002e, 0x004e, 0x015e, 0x00fe,
+	0x00ee, 0x00de, 0x0005, 0x6013, 0x0100, 0x6003, 0x0001, 0x6007,
+	0x0041, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x0c70, 0x2069, 0xb692,
+	0x2d04, 0xa084, 0xff00, 0xa086, 0x1200, 0x11a8, 0x2069, 0xb680,
+	0x686c, 0xa084, 0x00ff, 0x0016, 0x6110, 0xa18c, 0x0700, 0xa10d,
+	0x6112, 0x001e, 0x6003, 0x0001, 0x6007, 0x0043, 0x080c, 0x69f6,
+	0x080c, 0x6e9e, 0x0888, 0x6013, 0x0200, 0x6003, 0x0001, 0x6007,
+	0x0041, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x0830, 0x2001, 0xb10d,
+	0x2004, 0xd0ec, 0x0120, 0x2011, 0x8049, 0x080c, 0x3d5b, 0x6013,
+	0x0300, 0x0010, 0x6013, 0x0100, 0x6003, 0x0001, 0x6007, 0x0041,
+	0x080c, 0x69f6, 0x080c, 0x6e9e, 0x0804, 0xa4b4, 0x6013, 0x0500,
+	0x0c98, 0x6013, 0x0600, 0x0804, 0xa4c6, 0x6013, 0x0200, 0x0804,
+	0xa4c6, 0xa186, 0x0013, 0x1170, 0x6004, 0xa08a, 0x0040, 0x0a0c,
+	0x14fa, 0xa08a, 0x0053, 0x1a0c, 0x14fa, 0xa082, 0x0040, 0x2008,
+	0x0804, 0xa59b, 0xa186, 0x0051, 0x0138, 0xa186, 0x0047, 0x11d8,
+	0x6004, 0xa086, 0x0041, 0x0518, 0x2001, 0x0109, 0x2004, 0xd084,
+	0x01f0, 0x0126, 0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x080c,
+	0x68e7, 0x002e, 0x001e, 0x000e, 0x012e, 0x6000, 0xa086, 0x0002,
+	0x1170, 0x0804, 0xa5de, 0xa186, 0x0027, 0x0120, 0xa186, 0x0014,
+	0x190c, 0x14fa, 0x6004, 0xa082, 0x0040, 0x2008, 0x001a, 0x080c,
+	0x8331, 0x0005, 0xa565, 0xa567, 0xa567, 0xa58b, 0xa565, 0xa565,
+	0xa565, 0xa565, 0xa565, 0xa565, 0xa565, 0xa565, 0xa565, 0xa565,
+	0xa565, 0xa565, 0xa565, 0xa565, 0xa565, 0x080c, 0x14fa, 0x080c,
+	0x6dc1, 0x080c, 0x6e9e, 0x0036, 0x00d6, 0x6010, 0xa06d, 0x01c0,
+	0xad84, 0xf000, 0x01a8, 0x6003, 0x0002, 0x6018, 0x2004, 0xd0bc,
+	0x1178, 0x2019, 0x0004, 0x080c, 0xac5f, 0x6013, 0x0000, 0x6014,
+	0xa005, 0x1120, 0x2001, 0xb3b6, 0x2004, 0x6016, 0x6003, 0x0007,
+	0x00de, 0x003e, 0x0005, 0x00d6, 0x080c, 0x6dc1, 0x080c, 0x6e9e,
+	0x080c, 0x986a, 0x0120, 0x6010, 0x2068, 0x080c, 0x15f4, 0x080c,
+	0x9a2b, 0x00de, 0x0005, 0x0002, 0xa5af, 0xa5cc, 0xa5b8, 0xa5d8,
+	0xa5af, 0xa5af, 0xa5af, 0xa5af, 0xa5af, 0xa5af, 0xa5af, 0xa5af,
+	0xa5af, 0xa5af, 0xa5af, 0xa5af, 0xa5af, 0xa5af, 0xa5af, 0x080c,
+	0x14fa, 0x6010, 0xa088, 0x0013, 0x2104, 0xa085, 0x0400, 0x200a,
+	0x080c, 0x6dc1, 0x6010, 0xa080, 0x0013, 0x2004, 0xd0b4, 0x0138,
+	0x6003, 0x0007, 0x2009, 0x0043, 0x080c, 0x831a, 0x0010, 0x6003,
+	0x0002, 0x080c, 0x6e9e, 0x0005, 0x080c, 0x6dc1, 0x080c, 0xae9d,
+	0x1120, 0x080c, 0x6866, 0x080c, 0x82eb, 0x080c, 0x6e9e, 0x0005,
+	0x080c, 0x6dc1, 0x2009, 0x0041, 0x0804, 0xa727, 0xa182, 0x0040,
+	0x0002, 0xa5f4, 0xa5f6, 0xa5f4, 0xa5f4, 0xa5f4, 0xa5f4, 0xa5f4,
+	0xa5f7, 0xa5f4, 0xa5f4, 0xa5f4, 0xa5f4, 0xa5f4, 0xa5f4, 0xa5f4,
+	0xa5f4, 0xa5f4, 0xa602, 0xa5f4, 0x080c, 0x14fa, 0x0005, 0x6003,
+	0x0004, 0x6110, 0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10, 0x080c,
+	0x1828, 0x0005, 0x00d6, 0x080c, 0x6866, 0x00de, 0x080c, 0xaf00,
+	0x080c, 0x82eb, 0x0005, 0xa182, 0x0040, 0x0002, 0xa621, 0xa621,
+	0xa621, 0xa621, 0xa621, 0xa621, 0xa621, 0xa623, 0xa621, 0xa626,
+	0xa65f, 0xa621, 0xa621, 0xa621, 0xa621, 0xa65f, 0xa621, 0xa621,
+	0xa621, 0x080c, 0x14fa, 0x080c, 0x8331, 0x0005, 0x2001, 0xb172,
+	0x2004, 0xd0e4, 0x0158, 0x2001, 0x0100, 0x2004, 0xa082, 0x0005,
+	0x0228, 0x2001, 0x011f, 0x2004, 0x6036, 0x0010, 0x6037, 0x0000,
+	0x080c, 0x6e53, 0x080c, 0x6f5b, 0x6010, 0x00d6, 0x2068, 0x684c,
+	0xd0fc, 0x0150, 0xa08c, 0x0003, 0xa18e, 0x0002, 0x0168, 0x2009,
+	0x0041, 0x00de, 0x0804, 0xa727, 0x6003, 0x0007, 0x6017, 0x0000,
+	0x080c, 0x6866, 0x00de, 0x0005, 0x080c, 0xae9d, 0x0110, 0x00de,
+	0x0005, 0x080c, 0x6866, 0x080c, 0x82eb, 0x00de, 0x0ca0, 0x0036,
+	0x080c, 0x6e53, 0x080c, 0x6f5b, 0x6010, 0x00d6, 0x2068, 0x6018,
+	0x2004, 0xd0bc, 0x0188, 0x684c, 0xa084, 0x0003, 0xa086, 0x0002,
+	0x0140, 0x687c, 0x632c, 0xa31a, 0x632e, 0x6880, 0x6328, 0xa31b,
+	0x632a, 0x6003, 0x0002, 0x0080, 0x2019, 0x0004, 0x080c, 0xac5f,
+	0x6014, 0xa005, 0x1128, 0x2001, 0xb3b6, 0x2004, 0x8003, 0x6016,
+	0x6013, 0x0000, 0x6003, 0x0007, 0x00de, 0x003e, 0x0005, 0xa186,
+	0x0013, 0x1150, 0x6004, 0xa086, 0x0042, 0x190c, 0x14fa, 0x080c,
+	0x6dc1, 0x080c, 0x6e9e, 0x0005, 0xa186, 0x0027, 0x0118, 0xa186,
+	0x0014, 0x1180, 0x6004, 0xa086, 0x0042, 0x190c, 0x14fa, 0x2001,
+	0x0007, 0x080c, 0x4da2, 0x080c, 0x6dc1, 0x080c, 0x9a2b, 0x080c,
+	0x6e9e, 0x0005, 0xa182, 0x0040, 0x0002, 0xa6c8, 0xa6c8, 0xa6c8,
+	0xa6c8, 0xa6c8, 0xa6c8, 0xa6c8, 0xa6ca, 0xa6d6, 0xa6c8, 0xa6c8,
+	0xa6c8, 0xa6c8, 0xa6c8, 0xa6c8, 0xa6c8, 0xa6c8, 0xa6c8, 0xa6c8,
+	0x080c, 0x14fa, 0x0036, 0x0046, 0x20e1, 0x0005, 0x3d18, 0x3e20,
+	0x2c10, 0x080c, 0x1828, 0x004e, 0x003e, 0x0005, 0x6010, 0x00d6,
+	0x2068, 0x6810, 0x6a14, 0x0006, 0x0046, 0x0056, 0x6c7c, 0xa422,
+	0x6d80, 0x2200, 0xa52b, 0x602c, 0xa420, 0x642e, 0x6028, 0xa529,
+	0x652a, 0x005e, 0x004e, 0x000e, 0xa20d, 0x1178, 0x684c, 0xd0fc,
+	0x0120, 0x2009, 0x0041, 0x00de, 0x0490, 0x6003, 0x0007, 0x6017,
+	0x0000, 0x080c, 0x6866, 0x00de, 0x0005, 0x0006, 0x00f6, 0x2c78,
+	0x080c, 0x5177, 0x00fe, 0x000e, 0x0120, 0x6003, 0x0002, 0x00de,
+	0x0005, 0x2009, 0xb10d, 0x210c, 0xd19c, 0x0118, 0x6003, 0x0007,
+	0x0010, 0x6003, 0x0006, 0x0021, 0x080c, 0x6868, 0x00de, 0x0005,
+	0xd2fc, 0x0140, 0x8002, 0x8000, 0x8212, 0xa291, 0x0000, 0x2009,
+	0x0009, 0x0010, 0x2009, 0x0015, 0x6a6a, 0x6866, 0x0005, 0xa182,
+	0x0040, 0x0208, 0x0062, 0xa186, 0x0013, 0x0120, 0xa186, 0x0014,
+	0x190c, 0x14fa, 0x6020, 0xd0dc, 0x090c, 0x14fa, 0x0005, 0xa74a,
+	0xa751, 0xa75d, 0xa769, 0xa74a, 0xa74a, 0xa74a, 0xa778, 0xa74a,
+	0xa74c, 0xa74c, 0xa74a, 0xa74a, 0xa74a, 0xa74a, 0xa74c, 0xa74a,
+	0xa74c, 0xa74a, 0x080c, 0x14fa, 0x6020, 0xd0dc, 0x090c, 0x14fa,
+	0x0005, 0x6003, 0x0001, 0x6106, 0x080c, 0x69f6, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x6e9e, 0x012e, 0x0005, 0x6003, 0x0001, 0x6106,
+	0x080c, 0x69f6, 0x0126, 0x2091, 0x8000, 0x080c, 0x6e9e, 0x012e,
+	0x0005, 0x6003, 0x0003, 0x6106, 0x2c10, 0x080c, 0x1ec4, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x6a59, 0x080c, 0x6f5b, 0x012e, 0x0005,
+	0xa016, 0x080c, 0x1828, 0x0005, 0x0126, 0x2091, 0x8000, 0x0036,
+	0x00d6, 0xa182, 0x0040, 0x0023, 0x00de, 0x003e, 0x012e, 0x0005,
+	0xa798, 0xa79a, 0xa7ac, 0xa7c7, 0xa798, 0xa798, 0xa798, 0xa7dc,
+	0xa798, 0xa798, 0xa798, 0xa798, 0xa798, 0xa798, 0xa798, 0xa798,
+	0x080c, 0x14fa, 0x6010, 0x2068, 0x684c, 0xd0fc, 0x01f8, 0xa09c,
+	0x0003, 0xa39e, 0x0003, 0x01d0, 0x6003, 0x0001, 0x6106, 0x080c,
+	0x69f6, 0x080c, 0x6e9e, 0x0498, 0x6010, 0x2068, 0x684c, 0xd0fc,
+	0x0168, 0xa09c, 0x0003, 0xa39e, 0x0003, 0x0140, 0x6003, 0x0001,
+	0x6106, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x0408, 0x6013, 0x0000,
+	0x6017, 0x0000, 0x2019, 0x0004, 0x080c, 0xac5f, 0x00c0, 0x6010,
+	0x2068, 0x684c, 0xd0fc, 0x0d90, 0xa09c, 0x0003, 0xa39e, 0x0003,
+	0x0d68, 0x6003, 0x0003, 0x6106, 0x2c10, 0x080c, 0x1ec4, 0x080c,
+	0x6a59, 0x080c, 0x6f5b, 0x0018, 0xa016, 0x080c, 0x1828, 0x0005,
+	0x080c, 0x6dc1, 0x6110, 0x81ff, 0x0158, 0x00d6, 0x2168, 0x080c,
+	0xaf46, 0x0036, 0x2019, 0x0029, 0x080c, 0xac5f, 0x003e, 0x00de,
+	0x080c, 0x9a2b, 0x080c, 0x6e9e, 0x0005, 0x080c, 0x6e53, 0x6110,
+	0x81ff, 0x0158, 0x00d6, 0x2168, 0x080c, 0xaf46, 0x0036, 0x2019,
+	0x0029, 0x080c, 0xac5f, 0x003e, 0x00de, 0x080c, 0x9a2b, 0x080c,
+	0x6f5b, 0x0005, 0xa182, 0x0085, 0x0002, 0xa816, 0xa814, 0xa814,
+	0xa822, 0xa814, 0xa814, 0xa814, 0x080c, 0x14fa, 0x6003, 0x000b,
+	0x6106, 0x080c, 0x69f6, 0x0126, 0x2091, 0x8000, 0x080c, 0x6e9e,
+	0x012e, 0x0005, 0x0026, 0x00e6, 0x080c, 0xae96, 0x0118, 0x080c,
+	0x82eb, 0x00c8, 0x2071, 0xb680, 0x7224, 0x6212, 0x7220, 0x080c,
+	0xab0d, 0x0118, 0x6007, 0x0086, 0x0040, 0x6007, 0x0087, 0x7224,
+	0xa296, 0xffff, 0x1110, 0x6007, 0x0086, 0x6003, 0x0001, 0x080c,
+	0x69f6, 0x080c, 0x6e9e, 0x00ee, 0x002e, 0x0005, 0xa186, 0x0013,
+	0x1160, 0x6004, 0xa08a, 0x0085, 0x0a0c, 0x14fa, 0xa08a, 0x008c,
+	0x1a0c, 0x14fa, 0xa082, 0x0085, 0x00a2, 0xa186, 0x0027, 0x0130,
+	0xa186, 0x0014, 0x0118, 0x080c, 0x8331, 0x0050, 0x2001, 0x0007,
+	0x080c, 0x4da2, 0x080c, 0x6dc1, 0x080c, 0x9a2b, 0x080c, 0x6e9e,
+	0x0005, 0xa870, 0xa872, 0xa872, 0xa870, 0xa870, 0xa870, 0xa870,
+	0x080c, 0x14fa, 0x080c, 0x6dc1, 0x080c, 0x9a2b, 0x080c, 0x6e9e,
+	0x0005, 0xa182, 0x0085, 0x0a0c, 0x14fa, 0xa182, 0x008c, 0x1a0c,
+	0x14fa, 0xa182, 0x0085, 0x0002, 0xa88b, 0xa88b, 0xa88b, 0xa88d,
+	0xa88b, 0xa88b, 0xa88b, 0x080c, 0x14fa, 0x0005, 0xa186, 0x0013,
+	0x0148, 0xa186, 0x0014, 0x0130, 0xa186, 0x0027, 0x0118, 0x080c,
+	0x8331, 0x0030, 0x080c, 0x6dc1, 0x080c, 0x9a2b, 0x080c, 0x6e9e,
+	0x0005, 0x0036, 0x080c, 0xaf00, 0x603f, 0x0000, 0x2019, 0x000b,
+	0x0031, 0x601f, 0x0006, 0x6003, 0x0007, 0x003e, 0x0005, 0x0126,
+	0x0036, 0x2091, 0x8000, 0x0086, 0x2c40, 0x0096, 0x2049, 0x0000,
+	0x080c, 0x7e0d, 0x009e, 0x008e, 0x1578, 0x0076, 0x2c38, 0x080c,
+	0x7ea7, 0x007e, 0x1548, 0x6000, 0xa086, 0x0000, 0x0528, 0x601c,
+	0xa086, 0x0007, 0x0508, 0x00d6, 0x6000, 0xa086, 0x0004, 0x1150,
+	0x080c, 0xaf00, 0x601f, 0x0007, 0x2001, 0xb3b5, 0x2004, 0x6016,
+	0x080c, 0x190f, 0x6010, 0x2068, 0x080c, 0x986a, 0x0110, 0x080c,
+	0xac5f, 0x00de, 0x6013, 0x0000, 0x080c, 0xaf00, 0x601f, 0x0007,
+	0x2001, 0xb3b5, 0x2004, 0x6016, 0x003e, 0x012e, 0x0005, 0x00f6,
+	0x00c6, 0x0036, 0x0156, 0x2079, 0xb680, 0x7938, 0x783c, 0x080c,
+	0x26f6, 0x15b0, 0x0016, 0x00c6, 0x080c, 0x4e21, 0x1578, 0x001e,
+	0x002e, 0x0026, 0x0016, 0x2019, 0x0029, 0x080c, 0x7f67, 0x080c,
+	0x6b35, 0x0076, 0x2039, 0x0000, 0x080c, 0x6a6b, 0x007e, 0x001e,
+	0x0076, 0x2039, 0x0000, 0x080c, 0xaa51, 0x007e, 0x080c, 0x501c,
+	0x0026, 0x6204, 0xa294, 0xff00, 0x8217, 0xa286, 0x0006, 0x0118,
+	0xa286, 0x0004, 0x1118, 0x62a0, 0x080c, 0x2c2c, 0x002e, 0x001e,
+	0x080c, 0x4a80, 0x6612, 0x6516, 0xa006, 0x0010, 0x00ce, 0x001e,
+	0x015e, 0x003e, 0x00ce, 0x00fe, 0x0005, 0x00c6, 0x00d6, 0x00e6,
+	0x0016, 0x2009, 0xb120, 0x2104, 0xa086, 0x0074, 0x1904, 0xa98a,
+	0x2069, 0xb68e, 0x690c, 0xa182, 0x0100, 0x06c0, 0x6908, 0xa184,
+	0x8000, 0x05e8, 0x2001, 0xb39e, 0x2004, 0xa005, 0x1160, 0x6018,
+	0x2070, 0x7010, 0xa084, 0x00ff, 0x0118, 0x7000, 0xd0f4, 0x0118,
+	0xa184, 0x0800, 0x0560, 0x6910, 0xa18a, 0x0001, 0x0610, 0x6914,
+	0x2069, 0xb6ae, 0x6904, 0x81ff, 0x1198, 0x690c, 0xa182, 0x0100,
+	0x02a8, 0x6908, 0x81ff, 0x1178, 0x6910, 0xa18a, 0x0001, 0x0288,
+	0x6918, 0xa18a, 0x0001, 0x0298, 0x00d0, 0x6013, 0x0100, 0x00a0,
+	0x6013, 0x0300, 0x0088, 0x6013, 0x0500, 0x0070, 0x6013, 0x0700,
+	0x0058, 0x6013, 0x0900, 0x0040, 0x6013, 0x0b00, 0x0028, 0x6013,
+	0x0f00, 0x0010, 0x6013, 0x2d00, 0xa085, 0x0001, 0x0008, 0xa006,
+	0x001e, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x00c6, 0x00d6, 0x0026,
+	0x0036, 0x0156, 0x6218, 0x2268, 0x6b04, 0xa394, 0x00ff, 0xa286,
+	0x0006, 0x0190, 0xa286, 0x0004, 0x0178, 0xa394, 0xff00, 0x8217,
+	0xa286, 0x0006, 0x0148, 0xa286, 0x0004, 0x0130, 0x00c6, 0x2d60,
+	0x080c, 0x4e30, 0x00ce, 0x04c0, 0x2011, 0xb696, 0xad98, 0x000a,
+	0x20a9, 0x0004, 0x080c, 0x8d2b, 0x1580, 0x2011, 0xb69a, 0xad98,
+	0x0006, 0x20a9, 0x0004, 0x080c, 0x8d2b, 0x1538, 0x0046, 0x0016,
+	0x6aa0, 0xa294, 0x00ff, 0x8227, 0xa006, 0x2009, 0xb153, 0x210c,
+	0xd1a4, 0x0138, 0x2009, 0x0029, 0x080c, 0xacae, 0x6800, 0xc0e5,
+	0x6802, 0x2019, 0x0029, 0x080c, 0x6b35, 0x0076, 0x2039, 0x0000,
+	0x080c, 0x6a6b, 0x2c08, 0x080c, 0xaa51, 0x007e, 0x2001, 0x0007,
+	0x080c, 0x4da2, 0x001e, 0x004e, 0xa006, 0x015e, 0x003e, 0x002e,
+	0x00de, 0x00ce, 0x0005, 0x00d6, 0x2069, 0xb68e, 0x6800, 0xa086,
+	0x0800, 0x0118, 0x6013, 0x0000, 0x0008, 0xa006, 0x00de, 0x0005,
+	0x00c6, 0x00f6, 0x0016, 0x0026, 0x0036, 0x0156, 0x2079, 0xb68c,
+	0x7930, 0x7834, 0x080c, 0x26f6, 0x11a0, 0x080c, 0x4e21, 0x1188,
+	0x2011, 0xb690, 0xac98, 0x000a, 0x20a9, 0x0004, 0x080c, 0x8d2b,
+	0x1140, 0x2011, 0xb694, 0xac98, 0x0006, 0x20a9, 0x0004, 0x080c,
+	0x8d2b, 0x015e, 0x003e, 0x002e, 0x001e, 0x00fe, 0x00ce, 0x0005,
+	0x00c6, 0x0006, 0x0016, 0x0026, 0x0036, 0x0156, 0x2011, 0xb683,
+	0x2204, 0x8211, 0x220c, 0x080c, 0x26f6, 0x11a0, 0x080c, 0x4e21,
+	0x1188, 0x2011, 0xb696, 0xac98, 0x000a, 0x20a9, 0x0004, 0x080c,
+	0x8d2b, 0x1140, 0x2011, 0xb69a, 0xac98, 0x0006, 0x20a9, 0x0004,
+	0x080c, 0x8d2b, 0x015e, 0x003e, 0x002e, 0x001e, 0x000e, 0x00ce,
+	0x0005, 0x00e6, 0x00c6, 0x0086, 0x0076, 0x0066, 0x0056, 0x0046,
+	0x0026, 0x0126, 0x2091, 0x8000, 0x2740, 0x2029, 0xb3e2, 0x252c,
+	0x2021, 0xb3e8, 0x2424, 0x2061, 0xb800, 0x2071, 0xb100, 0x7644,
+	0x7064, 0x81ff, 0x0128, 0x8001, 0xa602, 0x1a04, 0xaacd, 0x0018,
+	0xa606, 0x0904, 0xaacd, 0x2100, 0xac06, 0x0904, 0xaac4, 0x080c,
+	0xacd6, 0x0904, 0xaac4, 0x671c, 0xa786, 0x0001, 0x0904, 0xaae4,
+	0xa786, 0x0004, 0x0904, 0xaae4, 0xa786, 0x0007, 0x05e8, 0x2500,
+	0xac06, 0x05d0, 0x2400, 0xac06, 0x05b8, 0x080c, 0xace6, 0x15a0,
+	0x88ff, 0x0118, 0x6050, 0xa906, 0x1578, 0x00d6, 0x6000, 0xa086,
+	0x0004, 0x1120, 0x0016, 0x080c, 0x190f, 0x001e, 0xa786, 0x0008,
+	0x1148, 0x080c, 0x9a66, 0x1130, 0x080c, 0x8890, 0x00de, 0x080c,
+	0x9a2b, 0x00d0, 0x6010, 0x2068, 0x080c, 0x986a, 0x0190, 0xa786,
+	0x0003, 0x1528, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c,
+	0xaf46, 0x0016, 0x080c, 0x9ada, 0x080c, 0x5271, 0x001e, 0x080c,
+	0x9a1f, 0x00de, 0x080c, 0x9a2b, 0xace0, 0x0018, 0x2001, 0xb116,
+	0x2004, 0xac02, 0x1210, 0x0804, 0xaa65, 0x012e, 0x002e, 0x004e,
+	0x005e, 0x006e, 0x007e, 0x008e, 0x00ce, 0x00ee, 0x0005, 0xa786,
+	0x0006, 0x19c0, 0xa386, 0x0005, 0x0128, 0x080c, 0xaf46, 0x080c,
+	0xac5f, 0x08f8, 0x00de, 0x0c00, 0x080c, 0xace6, 0x19e8, 0x81ff,
+	0x09d8, 0xa180, 0x0001, 0x2004, 0xa086, 0x0018, 0x0130, 0xa180,
+	0x0001, 0x2004, 0xa086, 0x002d, 0x1978, 0x6000, 0xa086, 0x0002,
+	0x1958, 0x080c, 0x9a55, 0x0130, 0x080c, 0x9a66, 0x1928, 0x080c,
+	0x8890, 0x0038, 0x080c, 0x2b99, 0x080c, 0x9a66, 0x1110, 0x080c,
+	0x8890, 0x080c, 0x9a2b, 0x0804, 0xaac4, 0x00c6, 0x00e6, 0x0016,
+	0x2c08, 0x2170, 0xa006, 0x080c, 0xac80, 0x001e, 0x0120, 0x601c,
+	0xa084, 0x000f, 0x001b, 0x00ee, 0x00ce, 0x0005, 0xab26, 0xab26,
+	0xab26, 0xab26, 0xab26, 0xab26, 0xab28, 0xab26, 0xa006, 0x0005,
+	0x0046, 0x0016, 0x7018, 0xa080, 0x0028, 0x2024, 0xa4a4, 0x00ff,
+	0x8427, 0x2c00, 0x2009, 0x0020, 0x080c, 0xacae, 0x001e, 0x004e,
+	0x0036, 0x2019, 0x0002, 0x080c, 0xa8af, 0x003e, 0xa085, 0x0001,
+	0x0005, 0x2001, 0x0001, 0x080c, 0x4d63, 0x0156, 0x0016, 0x0026,
+	0x0036, 0x20a9, 0x0004, 0x2019, 0xb105, 0x2011, 0xb696, 0x080c,
+	0x8d2b, 0x003e, 0x002e, 0x001e, 0x015e, 0xa005, 0x0005, 0x00f6,
+	0x00e6, 0x00c6, 0x0086, 0x0076, 0x0066, 0x0026, 0x0126, 0x2091,
+	0x8000, 0x2740, 0x2061, 0xb800, 0x2079, 0x0001, 0x8fff, 0x0904,
+	0xabb5, 0x2071, 0xb100, 0x7644, 0x7064, 0x8001, 0xa602, 0x1a04,
+	0xabb5, 0x88ff, 0x0128, 0x2800, 0xac06, 0x15b0, 0x2079, 0x0000,
+	0x080c, 0xacd6, 0x0588, 0x2400, 0xac06, 0x0570, 0x671c, 0xa786,
+	0x0006, 0x1550, 0xa786, 0x0007, 0x0538, 0x88ff, 0x1140, 0x6018,
+	0xa206, 0x1510, 0x85ff, 0x0118, 0x6050, 0xa106, 0x11e8, 0x00d6,
+	0x6000, 0xa086, 0x0004, 0x1150, 0x080c, 0xaf00, 0x601f, 0x0007,
+	0x2001, 0xb3b5, 0x2004, 0x6016, 0x080c, 0x190f, 0x6010, 0x2068,
+	0x080c, 0x986a, 0x0120, 0x0046, 0x080c, 0xac5f, 0x004e, 0x00de,
+	0x080c, 0x9a2b, 0x88ff, 0x1198, 0xace0, 0x0018, 0x2001, 0xb116,
+	0x2004, 0xac02, 0x1210, 0x0804, 0xab66, 0xa006, 0x012e, 0x002e,
+	0x006e, 0x007e, 0x008e, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0xa8c5,
+	0x0001, 0x0ca0, 0x0076, 0x0056, 0x0086, 0x2041, 0x0000, 0x2029,
+	0x0001, 0x2c20, 0x2019, 0x0002, 0x6218, 0x0096, 0x2049, 0x0000,
+	0x080c, 0x7e0d, 0x009e, 0x008e, 0x2039, 0x0000, 0x080c, 0x7ea7,
+	0x080c, 0xab57, 0x005e, 0x007e, 0x0005, 0x0026, 0x0046, 0x0056,
+	0x0076, 0x00c6, 0x0156, 0x2c20, 0x2128, 0x20a9, 0x007f, 0x2009,
+	0x0000, 0x0016, 0x0036, 0x080c, 0x4e21, 0x11b0, 0x2c10, 0x0056,
+	0x0086, 0x2041, 0x0000, 0x2508, 0x2029, 0x0001, 0x0096, 0x2049,
+	0x0000, 0x080c, 0x7e0d, 0x009e, 0x008e, 0x2039, 0x0000, 0x080c,
+	0x7ea7, 0x080c, 0xab57, 0x005e, 0x003e, 0x001e, 0x8108, 0x1f04,
+	0xabe9, 0x015e, 0x00ce, 0x007e, 0x005e, 0x004e, 0x002e, 0x0005,
+	0x0076, 0x0056, 0x6218, 0x0086, 0x2041, 0x0000, 0x2029, 0x0001,
+	0x2019, 0x0048, 0x0096, 0x2049, 0x0000, 0x080c, 0x7e0d, 0x009e,
+	0x008e, 0x2039, 0x0000, 0x080c, 0x7ea7, 0x2c20, 0x080c, 0xab57,
+	0x005e, 0x007e, 0x0005, 0x0026, 0x0046, 0x0056, 0x0076, 0x00c6,
+	0x0156, 0x2c20, 0x20a9, 0x007f, 0x2009, 0x0000, 0x0016, 0x0036,
+	0x080c, 0x4e21, 0x11c0, 0x2c10, 0x0086, 0x2041, 0x0000, 0x2828,
+	0x0046, 0x2021, 0x0001, 0x080c, 0xaee2, 0x004e, 0x0096, 0x2049,
+	0x0000, 0x080c, 0x7e0d, 0x009e, 0x008e, 0x2039, 0x0000, 0x080c,
+	0x7ea7, 0x080c, 0xab57, 0x003e, 0x001e, 0x8108, 0x1f04, 0xac36,
+	0x015e, 0x00ce, 0x007e, 0x005e, 0x004e, 0x002e, 0x0005, 0x0016,
+	0x00f6, 0x3800, 0xd08c, 0x0130, 0xad82, 0x1000, 0x02b0, 0xad82,
+	0xb100, 0x0230, 0xad82, 0xe800, 0x0280, 0xad82, 0xffff, 0x1268,
+	0x6800, 0xa07d, 0x0138, 0x6803, 0x0000, 0x6b52, 0x080c, 0x5271,
+	0x2f68, 0x0cb0, 0x6b52, 0x080c, 0x5271, 0x00fe, 0x001e, 0x0005,
+	0x00e6, 0x0046, 0x0036, 0x2061, 0xb800, 0xa005, 0x1138, 0x2071,
+	0xb100, 0x7444, 0x7064, 0x8001, 0xa402, 0x12d8, 0x2100, 0xac06,
+	0x0168, 0x6000, 0xa086, 0x0000, 0x0148, 0x6008, 0xa206, 0x1130,
+	0x6018, 0xa1a0, 0x0006, 0x2424, 0xa406, 0x0140, 0xace0, 0x0018,
+	0x2001, 0xb116, 0x2004, 0xac02, 0x1220, 0x0c40, 0xa085, 0x0001,
+	0x0008, 0xa006, 0x003e, 0x004e, 0x00ee, 0x0005, 0x00d6, 0x0006,
+	0x080c, 0x15dd, 0x000e, 0x090c, 0x14fa, 0x6837, 0x010d, 0x685e,
+	0x0026, 0x2010, 0x080c, 0x985a, 0x2001, 0x0000, 0x0120, 0x2200,
+	0xa080, 0x0014, 0x2004, 0x002e, 0x684a, 0x6956, 0x6c46, 0x684f,
+	0x0000, 0x2001, 0xb3bd, 0x2004, 0x6852, 0xa006, 0x68b2, 0x6802,
+	0x683a, 0x685a, 0x080c, 0x5271, 0x00de, 0x0005, 0x6700, 0xa786,
+	0x0000, 0x0158, 0xa786, 0x0001, 0x0140, 0xa786, 0x000a, 0x0128,
+	0xa786, 0x0009, 0x0110, 0xa085, 0x0001, 0x0005, 0x00e6, 0x6018,
+	0x2070, 0x70a0, 0xa206, 0x00ee, 0x0005, 0x0016, 0x6004, 0xa08e,
+	0x001e, 0x11a0, 0x8007, 0x6130, 0xa18c, 0x00ff, 0xa105, 0x6032,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0005, 0x2001, 0xb3b6,
+	0x2004, 0x6016, 0x080c, 0x69f6, 0x080c, 0x6e9e, 0x001e, 0x0005,
+	0xe000, 0xe000, 0x0005, 0x6020, 0xd0e4, 0x0158, 0xd0cc, 0x0118,
+	0x080c, 0x9b43, 0x0030, 0x080c, 0xaf00, 0x080c, 0x6866, 0x080c,
+	0x82eb, 0x0005, 0xa280, 0x0007, 0x2004, 0xa084, 0x000f, 0x0002,
+	0xad29, 0xad29, 0xad29, 0xad2e, 0xad29, 0xad2b, 0xad2b, 0xad29,
+	0xad2b, 0xa006, 0x0005, 0x00c6, 0x2260, 0x00ce, 0xa085, 0x0001,
+	0x0005, 0xa280, 0x0007, 0x2004, 0xa084, 0x000f, 0x0002, 0xad40,
+	0xad40, 0xad40, 0xad40, 0xad40, 0xad40, 0xad4b, 0xad40, 0xad40,
+	0x6007, 0x003b, 0x602b, 0x0009, 0x6013, 0x2a00, 0x6003, 0x0001,
+	0x080c, 0x69f6, 0x0005, 0x00c6, 0x2260, 0x080c, 0xaf00, 0x603f,
+	0x0000, 0x6020, 0xc0f4, 0xc0cc, 0x6022, 0x6037, 0x0000, 0x00ce,
+	0x00d6, 0x2268, 0xa186, 0x0007, 0x1904, 0xada6, 0x6810, 0xa005,
+	0x0138, 0xa080, 0x0013, 0x2004, 0xd0fc, 0x1110, 0x00de, 0x08c0,
+	0x6007, 0x003a, 0x6003, 0x0001, 0x080c, 0x69f6, 0x080c, 0x6e9e,
+	0x00c6, 0x2d60, 0x6100, 0xa186, 0x0002, 0x1904, 0xae2f, 0x6010,
+	0xa005, 0x1138, 0x6000, 0xa086, 0x0007, 0x190c, 0x14fa, 0x0804,
+	0xae2f, 0xa08c, 0xf000, 0x1130, 0x0028, 0x2068, 0x6800, 0xa005,
+	0x1de0, 0x2d00, 0xa080, 0x0013, 0x2004, 0xa084, 0x0003, 0xa086,
+	0x0002, 0x1180, 0x6010, 0x2068, 0x684c, 0xc0dc, 0xc0f4, 0x684e,
+	0x6850, 0xc0f4, 0xc0fc, 0x6852, 0x2009, 0x0043, 0x080c, 0xa727,
+	0x0804, 0xae2f, 0x2009, 0x0041, 0x0804, 0xae29, 0xa186, 0x0005,
+	0x15f0, 0x6810, 0xa080, 0x0013, 0x2004, 0xd0bc, 0x1118, 0x00de,
+	0x0804, 0xad40, 0xd0b4, 0x0128, 0xd0fc, 0x090c, 0x14fa, 0x0804,
+	0xad5e, 0x6007, 0x003a, 0x6003, 0x0001, 0x080c, 0x69f6, 0x080c,
+	0x6e9e, 0x00c6, 0x2d60, 0x6100, 0xa186, 0x0002, 0x0120, 0xa186,
+	0x0004, 0x1904, 0xae2f, 0x2071, 0xb419, 0x7000, 0xa086, 0x0003,
+	0x1128, 0x7004, 0xac06, 0x1110, 0x7003, 0x0000, 0x6810, 0xa080,
+	0x0013, 0x200c, 0xc1f4, 0xc1dc, 0x2102, 0x8000, 0x200c, 0xc1f4,
+	0xc1fc, 0xc1bc, 0x2102, 0x2009, 0x0042, 0x0804, 0xae29, 0x0036,
+	0x00d6, 0x00d6, 0x080c, 0x15dd, 0x003e, 0x090c, 0x14fa, 0x6837,
+	0x010d, 0x6803, 0x0000, 0x683b, 0x0000, 0x685b, 0x0000, 0x6b5e,
+	0x6857, 0x0045, 0x2c00, 0x6862, 0x6034, 0x6872, 0x2360, 0x6020,
+	0xc0dd, 0x6022, 0x6018, 0xa080, 0x0028, 0x2004, 0xa084, 0x00ff,
+	0x8007, 0x6350, 0x6b4a, 0x6846, 0x684f, 0x0000, 0x6853, 0x0000,
+	0x6d6a, 0x6e66, 0x686f, 0x0001, 0x080c, 0x5271, 0x2019, 0x0045,
+	0x6008, 0x2068, 0x080c, 0xa8af, 0x2d00, 0x600a, 0x601f, 0x0006,
+	0x6003, 0x0007, 0x6017, 0x0000, 0x603f, 0x0000, 0x00de, 0x003e,
+	0x0038, 0x603f, 0x0000, 0x6003, 0x0007, 0x080c, 0xa727, 0x00ce,
+	0x00de, 0x0005, 0xa186, 0x0013, 0x1128, 0x6004, 0xa082, 0x0085,
+	0x2008, 0x00c2, 0xa186, 0x0027, 0x1178, 0x080c, 0x6dc1, 0x0036,
+	0x00d6, 0x6010, 0x2068, 0x2019, 0x0004, 0x080c, 0xac5f, 0x00de,
+	0x003e, 0x080c, 0x6e9e, 0x0005, 0xa186, 0x0014, 0x0d70, 0x080c,
+	0x8331, 0x0005, 0xae5b, 0xae59, 0xae59, 0xae59, 0xae59, 0xae59,
+	0xae5b, 0x080c, 0x14fa, 0x080c, 0x6dc1, 0x6003, 0x000c, 0x080c,
+	0x6e9e, 0x0005, 0xa182, 0x008c, 0x1220, 0xa182, 0x0085, 0x0208,
+	0x001a, 0x080c, 0x8331, 0x0005, 0xae73, 0xae73, 0xae73, 0xae73,
+	0xae75, 0xae93, 0xae73, 0x080c, 0x14fa, 0x00d6, 0x2c68, 0x080c,
+	0x8295, 0x01a0, 0x6003, 0x0001, 0x6007, 0x001e, 0x2009, 0xb68e,
+	0x210c, 0x6136, 0x2009, 0xb68f, 0x210c, 0x613a, 0x600b, 0xffff,
+	0x6918, 0x611a, 0x601f, 0x0004, 0x080c, 0x69f6, 0x2d60, 0x080c,
+	0x82eb, 0x00de, 0x0005, 0x080c, 0x82eb, 0x0005, 0x00e6, 0x6018,
+	0x2070, 0x7000, 0xd0ec, 0x00ee, 0x0005, 0x6010, 0xa08c, 0xf000,
+	0x0904, 0xaee1, 0xa080, 0x0013, 0x200c, 0xd1ec, 0x05d0, 0x2001,
+	0xb172, 0x2004, 0xd0ec, 0x05a8, 0x6003, 0x0002, 0x6020, 0xc0e5,
+	0x6022, 0xd1ac, 0x0180, 0x00f6, 0x2c78, 0x080c, 0x5173, 0x00fe,
+	0x0150, 0x2001, 0xb3b7, 0x2004, 0x603e, 0x2009, 0xb172, 0x210c,
+	0xd1f4, 0x11e8, 0x0080, 0x2009, 0xb172, 0x210c, 0xd1f4, 0x0128,
+	0x6020, 0xc0e4, 0x6022, 0xa006, 0x00a0, 0x2001, 0xb3b7, 0x200c,
+	0x8103, 0xa100, 0x603e, 0x6018, 0xa088, 0x002b, 0x2104, 0xa005,
+	0x0118, 0xa088, 0x0003, 0x0cd0, 0x2c0a, 0x600f, 0x0000, 0xa085,
+	0x0001, 0x0005, 0x0016, 0x00c6, 0x00e6, 0x6150, 0xa2f0, 0x002b,
+	0x2e04, 0x2060, 0x8cff, 0x0180, 0x84ff, 0x1118, 0x6050, 0xa106,
+	0x1138, 0x600c, 0x2072, 0x080c, 0x6866, 0x080c, 0x82eb, 0x0010,
+	0xacf0, 0x0003, 0x2e64, 0x0c70, 0x00ee, 0x00ce, 0x001e, 0x0005,
+	0x00d6, 0x6018, 0xa0e8, 0x002b, 0x2d04, 0xa005, 0x0140, 0xac06,
+	0x0120, 0x2d04, 0xa0e8, 0x0003, 0x0cb8, 0x600c, 0x206a, 0x00de,
+	0x0005, 0x0026, 0x0036, 0x0156, 0x2011, 0xb127, 0x2204, 0xa084,
+	0x00ff, 0x2019, 0xb68e, 0x2334, 0xa636, 0x11d8, 0x8318, 0x2334,
+	0x2204, 0xa084, 0xff00, 0xa636, 0x11a0, 0x2011, 0xb690, 0x6018,
+	0xa098, 0x000a, 0x20a9, 0x0004, 0x080c, 0x8d2b, 0x1150, 0x2011,
+	0xb694, 0x6018, 0xa098, 0x0006, 0x20a9, 0x0004, 0x080c, 0x8d2b,
+	0x1100, 0x015e, 0x003e, 0x002e, 0x0005, 0x00e6, 0x2071, 0xb100,
+	0x080c, 0x4a3b, 0x080c, 0x2991, 0x00ee, 0x0005, 0x00e6, 0x6018,
+	0x2070, 0x7000, 0xd0fc, 0x0108, 0x0011, 0x00ee, 0x0005, 0x6850,
+	0xc0e5, 0x6852, 0x0005, 0x00e6, 0x00c6, 0x0076, 0x0066, 0x0056,
+	0x0046, 0x0026, 0x0016, 0x0126, 0x2091, 0x8000, 0x2029, 0xb3e2,
+	0x252c, 0x2021, 0xb3e8, 0x2424, 0x2061, 0xb800, 0x2071, 0xb100,
+	0x7644, 0x7064, 0xa606, 0x0578, 0x671c, 0xa786, 0x0001, 0x0118,
+	0xa786, 0x0008, 0x1500, 0x2500, 0xac06, 0x01e8, 0x2400, 0xac06,
+	0x01d0, 0x080c, 0xacd6, 0x01b8, 0x080c, 0xace6, 0x11a0, 0x6000,
+	0xa086, 0x0004, 0x1120, 0x0016, 0x080c, 0x190f, 0x001e, 0x080c,
+	0x9a55, 0x1110, 0x080c, 0x2b99, 0x080c, 0x9a66, 0x1110, 0x080c,
+	0x8890, 0x080c, 0x9a2b, 0xace0, 0x0018, 0x2001, 0xb116, 0x2004,
+	0xac02, 0x1208, 0x0858, 0x012e, 0x001e, 0x002e, 0x004e, 0x005e,
+	0x006e, 0x007e, 0x00ce, 0x00ee, 0x0005, 0x0126, 0x0006, 0x00e6,
+	0x2091, 0x8000, 0x2071, 0xb140, 0xd5a4, 0x0118, 0x7034, 0x8000,
+	0x7036, 0xd5b4, 0x0118, 0x7030, 0x8000, 0x7032, 0xd5ac, 0x0118,
+	0x2071, 0xb14a, 0x0451, 0x00ee, 0x000e, 0x012e, 0x0005, 0x0126,
+	0x0006, 0x00e6, 0x2091, 0x8000, 0x2071, 0xb140, 0xd5a4, 0x0118,
+	0x7034, 0x8000, 0x7036, 0xd5b4, 0x0118, 0x7030, 0x8000, 0x7032,
+	0xd5ac, 0x0118, 0x2071, 0xb14a, 0x0081, 0x00ee, 0x000e, 0x012e,
+	0x0005, 0x0126, 0x0006, 0x00e6, 0x2091, 0x8000, 0x2071, 0xb142,
+	0x0021, 0x00ee, 0x000e, 0x012e, 0x0005, 0x2e04, 0x8000, 0x2072,
+	0x1220, 0x8e70, 0x2e04, 0x8000, 0x2072, 0x0005, 0x00e6, 0x2071,
+	0xb140, 0x0c99, 0x00ee, 0x0005, 0x00e6, 0x2071, 0xb144, 0x0c69,
+	0x00ee, 0x0005, 0x0126, 0x0006, 0x00e6, 0x2091, 0x8000, 0x2071,
+	0xb140, 0x7044, 0x8000, 0x7046, 0x00ee, 0x000e, 0x012e, 0x0005,
+	0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
+	0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000,
+	0x5790
+};
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_length01 = 0xa019;
+#else
+unsigned short risc_code_length01 = 0xa019;
+#endif
+
diff -urN linux.orig/drivers/scsi/ql2300_fw.h linux/drivers/scsi/ql2300_fw.h
--- linux.orig/drivers/scsi/ql2300_fw.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/ql2300_fw.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,5486 @@
+/************************************************************************
+ *									*
+ *               --- ISP2300 Initiator/Target Firmware ---              *
+ *             with Fabric (Public Loop), Point-point, and              *
+ *             expanded LUN addressing for FCTAPE                       *
+ *									*
+ ************************************************************************
+  Copyright (C) 2000 and 2001 Qlogic Corporation 
+  (www.qlogic.com)
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+ ************************************************************************/
+/*
+ *	Firmware Version 3.00.24 (14:18 Jun 05, 2001)
+ */
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tp_version = 3*1024+0;
+#else
+unsigned short risc_code_version = 3*1024+0;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned char fw2300tp_version_str[] = {3, 0,24};
+#else
+unsigned char firmware_version[] = {3, 0,24};
+#endif
+
+#ifdef UNIQUE_FW_NAME
+#define fw2300tp_VERSION_STRING "3.00.24"
+#else
+#define FW_VERSION_STRING "3.00.24"
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tp_addr01 = 0x0800 ;
+#else
+unsigned short risc_code_addr01 = 0x0800 ;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tp_code01[] = { 
+#else
+unsigned short risc_code01[] = { 
+#endif
+	0x0470, 0x0000, 0x0000, 0xa9b8, 0x0000, 0x0003, 0x0000, 0x0018,
+	0x0017, 0x2043, 0x4f50, 0x5952, 0x4947, 0x4854, 0x2032, 0x3030,
+	0x3120, 0x514c, 0x4f47, 0x4943, 0x2043, 0x4f52, 0x504f, 0x5241,
+	0x5449, 0x4f4e, 0x2049, 0x5350, 0x3233, 0x3030, 0x2046, 0x6972,
+	0x6d77, 0x6172, 0x6520, 0x2056, 0x6572, 0x7369, 0x6f6e, 0x2030,
+	0x332e, 0x3030, 0x2e32, 0x3420, 0x2020, 0x2020, 0x2400, 0x20a9,
+	0x000f, 0x2001, 0x0000, 0x400f, 0x2091, 0x2200, 0x20a9, 0x000f,
+	0x2001, 0x0000, 0x400f, 0x2091, 0x2400, 0x20a9, 0x000f, 0x2001,
+	0x0000, 0x400f, 0x2091, 0x2600, 0x20a9, 0x000f, 0x2001, 0x0000,
+	0x400f, 0x2091, 0x2800, 0x20a9, 0x000f, 0x2001, 0x0000, 0x400f,
+	0x2091, 0x2a00, 0x20a9, 0x000f, 0x2001, 0x0000, 0x400f, 0x2091,
+	0x2c00, 0x20a9, 0x000f, 0x2001, 0x0000, 0x400f, 0x2091, 0x2e00,
+	0x20a9, 0x000f, 0x2001, 0x0000, 0x400f, 0x2091, 0x2000, 0x2001,
+	0x0000, 0x20c1, 0x0004, 0x2001, 0x017f, 0x2003, 0x0000, 0x20c9,
+	0x14ff, 0x2059, 0x0000, 0x2b78, 0x7883, 0x0004, 0x2089, 0x2102,
+	0x2051, 0x1100, 0x2a70, 0x20e1, 0x0001, 0x20e9, 0x0001, 0x2029,
+	0x45c0, 0x2031, 0xffff, 0x2039, 0x45a9, 0x2021, 0x0200, 0x20e9,
+	0x0001, 0x20a1, 0x1000, 0x900e, 0x20a9, 0x05c0, 0x4104, 0x755e,
+	0x7662, 0x775a, 0x7466, 0x746a, 0x20a1, 0x15c0, 0x7160, 0x810d,
+	0x810d, 0x810d, 0x810d, 0x918c, 0x000f, 0x2001, 0x0001, 0x9112,
+	0x900e, 0x21a8, 0x4104, 0x8211, 0x1de0, 0x7160, 0x3400, 0x8001,
+	0x9102, 0x0120, 0x0218, 0x20a8, 0x900e, 0x4104, 0x2009, 0x1100,
+	0x810d, 0x810d, 0x810d, 0x810d, 0x810d, 0x918c, 0x001f, 0x2001,
+	0x0001, 0x9112, 0x20e9, 0x0001, 0x20a1, 0x0800, 0x900e, 0x20a9,
+	0x0800, 0x4104, 0x8211, 0x1dd8, 0x2009, 0x1100, 0x3400, 0x9102,
+	0x0120, 0x0218, 0x20a8, 0x900e, 0x4104, 0x080c, 0x0e42, 0x080c,
+	0x0f8f, 0x080c, 0x13a2, 0x080c, 0x0c8a, 0x080c, 0x4721, 0x080c,
+	0x7ebf, 0x080c, 0x0dae, 0x080c, 0x27c1, 0x080c, 0x5a05, 0x080c,
+	0x4e0f, 0x080c, 0x64ba, 0x080c, 0x1956, 0x080c, 0x6721, 0x080c,
+	0x5fe8, 0x080c, 0x1768, 0x080c, 0x18cb, 0x080c, 0x194b, 0x2091,
+	0x3009, 0x7883, 0x0000, 0x1004, 0x0905, 0x7880, 0x9086, 0x0002,
+	0x1160, 0x7883, 0x4000, 0x7837, 0x4000, 0x7833, 0x0010, 0x0e04,
+	0x08ff, 0x2091, 0x5000, 0x2091, 0x4080, 0x2a70, 0x7003, 0x0000,
+	0x2a70, 0x7000, 0x908e, 0x0003, 0x1168, 0x080c, 0x3816, 0x080c,
+	0x27e5, 0x080c, 0x5a60, 0x080c, 0x52b6, 0x080c, 0x64e0, 0x080c,
+	0x20a5, 0x0c70, 0x000b, 0x0c88, 0x0926, 0x0927, 0x0a62, 0x0924,
+	0x0b34, 0x0c87, 0x0c88, 0x0c89, 0x080c, 0x0cf1, 0x0005, 0x0126,
+	0x00f6, 0x2091, 0x8000, 0x7000, 0x9086, 0x0001, 0x1904, 0x0a30,
+	0x7034, 0xd0b4, 0x1130, 0x0026, 0x2011, 0x0080, 0x080c, 0x0d63,
+	0x002e, 0x080c, 0x5745, 0x0150, 0x080c, 0x576b, 0x1570, 0x2079,
+	0x0100, 0x7828, 0x9085, 0x1800, 0x782a, 0x0438, 0x080c, 0x5682,
+	0x7000, 0x9086, 0x0001, 0x1904, 0x0a30, 0x7088, 0x9086, 0x0028,
+	0x1904, 0x0a30, 0x2001, 0x0161, 0x2003, 0x0001, 0x2079, 0x0100,
+	0x7827, 0xffff, 0x7a28, 0x9295, 0x1e2f, 0x7a2a, 0x2011, 0x5654,
+	0x080c, 0x655b, 0x2011, 0x4586, 0x080c, 0x655b, 0x2011, 0x8030,
+	0x2019, 0x0000, 0x7087, 0x0000, 0x00d8, 0x080c, 0x3e5a, 0x2079,
+	0x0100, 0x7844, 0x9005, 0x1904, 0x0a30, 0x2011, 0x4586, 0x080c,
+	0x655b, 0x2001, 0x0265, 0x2001, 0x0205, 0x2003, 0x0000, 0x780f,
+	0x006b, 0x7840, 0x9084, 0xfffb, 0x7842, 0x2011, 0x8010, 0x73c8,
+	0x080c, 0x1f80, 0x080c, 0x37dc, 0x7238, 0xc284, 0x723a, 0x2001,
+	0x110c, 0x200c, 0xc1ac, 0xc1cc, 0x2102, 0x080c, 0x788f, 0x2011,
+	0x0004, 0x080c, 0x95d8, 0x080c, 0x4d24, 0x080c, 0x5745, 0x01e8,
+	0x080c, 0x46dd, 0x0140, 0x7087, 0x0001, 0x70c3, 0x0000, 0x080c,
+	0x4016, 0x0804, 0x0a30, 0x2001, 0x1153, 0x2004, 0xd094, 0x0168,
+	0x2011, 0x110c, 0x2204, 0xc0cd, 0x2012, 0x080c, 0x1fc4, 0x1228,
+	0x2011, 0x110c, 0x2204, 0xc0bc, 0x0020, 0x2011, 0x110c, 0x2204,
+	0xc0bd, 0x2012, 0x080c, 0x4de0, 0x0120, 0x7a0c, 0xc2b4, 0x7a0e,
+	0x0050, 0x080c, 0x99a3, 0x70cc, 0xd09c, 0x1128, 0x709c, 0x9005,
+	0x0110, 0x080c, 0x46bb, 0x70d7, 0x0000, 0x70d3, 0x0000, 0x72cc,
+	0x080c, 0x5745, 0x1178, 0x2011, 0x0000, 0x0016, 0x080c, 0x1d69,
+	0x2019, 0x1280, 0x211a, 0x001e, 0x704f, 0xffff, 0x7053, 0x00ef,
+	0x7073, 0x0000, 0x2079, 0x1152, 0x7804, 0xd0ac, 0x0108, 0xc295,
+	0x72ce, 0x080c, 0x5745, 0x0118, 0x9296, 0x0004, 0x0508, 0x2011,
+	0x0001, 0x080c, 0x95d8, 0x7097, 0x0000, 0x709b, 0xffff, 0x7003,
+	0x0002, 0x00fe, 0x080c, 0x23cd, 0x2011, 0x0005, 0x080c, 0x79c2,
+	0x080c, 0x6d42, 0x080c, 0x5745, 0x0148, 0x00c6, 0x2061, 0x0100,
+	0x0016, 0x080c, 0x1d69, 0x61e2, 0x001e, 0x00ce, 0x012e, 0x00d0,
+	0x7097, 0x0000, 0x709b, 0xffff, 0x7003, 0x0002, 0x2011, 0x0005,
+	0x080c, 0x79c2, 0x080c, 0x6d42, 0x080c, 0x5745, 0x0148, 0x00c6,
+	0x2061, 0x0100, 0x0016, 0x080c, 0x1d69, 0x61e2, 0x001e, 0x00ce,
+	0x00fe, 0x012e, 0x0005, 0x00c6, 0x080c, 0x5745, 0x1118, 0x20a9,
+	0x0100, 0x0010, 0x20a9, 0x0082, 0x080c, 0x5745, 0x1118, 0x2009,
+	0x0000, 0x0010, 0x2009, 0x007e, 0x0016, 0x0026, 0x0036, 0x2110,
+	0x0026, 0x2019, 0x0029, 0x080c, 0x7ba2, 0x002e, 0x080c, 0xad6c,
+	0x003e, 0x002e, 0x001e, 0x080c, 0x26a3, 0x8108, 0x1f04, 0x0a44,
+	0x00ce, 0x706f, 0x0000, 0x7070, 0x9084, 0x00ff, 0x7072, 0x709f,
+	0x0000, 0x0005, 0x0126, 0x2091, 0x8000, 0x7000, 0x9086, 0x0002,
+	0x1904, 0x0b32, 0x7098, 0x9086, 0xffff, 0x0130, 0x080c, 0x23cd,
+	0x080c, 0x6d42, 0x0804, 0x0b32, 0x70cc, 0xd0ac, 0x1110, 0xd09c,
+	0x0520, 0xd084, 0x0510, 0x0006, 0x2001, 0x0103, 0x2003, 0x002b,
+	0x000e, 0xd08c, 0x01d0, 0x70d0, 0x9086, 0xffff, 0x0190, 0x080c,
+	0x252c, 0x080c, 0x6d42, 0x70cc, 0xd094, 0x1904, 0x0b32, 0x2011,
+	0x0001, 0x2019, 0x0000, 0x080c, 0x2562, 0x080c, 0x6d42, 0x0804,
+	0x0b32, 0x70d4, 0x9005, 0x1904, 0x0b32, 0x7094, 0x9005, 0x1904,
+	0x0b32, 0x70cc, 0xd0a4, 0x0118, 0xd0b4, 0x0904, 0x0b32, 0x080c,
+	0x4de0, 0x1904, 0x0b32, 0x2001, 0x1153, 0x2004, 0xd0ac, 0x01c8,
+	0x0156, 0x00c6, 0x20a9, 0x007f, 0x2009, 0x0000, 0x0016, 0x080c,
+	0x4b58, 0x1118, 0x6000, 0xd0ec, 0x1138, 0x001e, 0x8108, 0x1f04,
+	0x0ab6, 0x00ce, 0x015e, 0x0028, 0x001e, 0x00ce, 0x015e, 0x0804,
+	0x0b32, 0x0006, 0x2001, 0x0103, 0x2003, 0x006b, 0x000e, 0x9006,
+	0x2009, 0x0700, 0x20a9, 0x0002, 0x20a1, 0x12ca, 0x20e9, 0x0001,
+	0x4001, 0x706c, 0x8007, 0x7170, 0x810f, 0x20a9, 0x0002, 0x4001,
+	0x2009, 0x0000, 0x080c, 0x0cd7, 0x2001, 0x0000, 0x810f, 0x20a9,
+	0x0002, 0x4001, 0x9006, 0x2009, 0x0200, 0x20a9, 0x0002, 0x20a1,
+	0x12da, 0x4001, 0x7030, 0xc08c, 0x7032, 0x7003, 0x0003, 0x709b,
+	0xffff, 0x7034, 0xd0b4, 0x1130, 0x0026, 0x2011, 0x0040, 0x080c,
+	0x0d63, 0x002e, 0x9006, 0x080c, 0x1c36, 0x0036, 0x0046, 0x2019,
+	0xffff, 0x2021, 0x0006, 0x080c, 0x384a, 0x004e, 0x003e, 0x00f6,
+	0x2079, 0x0100, 0x080c, 0x576b, 0x0150, 0x080c, 0x5745, 0x7828,
+	0x0118, 0x9084, 0xe1ff, 0x0010, 0x9084, 0xffdf, 0x782a, 0x00fe,
+	0x2001, 0x12dd, 0x2004, 0x9086, 0x0005, 0x1120, 0x2011, 0x0000,
+	0x080c, 0x79c2, 0x2011, 0x0000, 0x080c, 0x79cc, 0x080c, 0x6d42,
+	0x080c, 0x6e10, 0x012e, 0x0005, 0x0016, 0x0046, 0x00f6, 0x0126,
+	0x2091, 0x8000, 0x2079, 0x0100, 0x2009, 0x00f7, 0x080c, 0x46a4,
+	0x7940, 0x918c, 0x0010, 0x7942, 0x7924, 0xd1b4, 0x0110, 0x7827,
+	0x0040, 0xd19c, 0x0110, 0x7827, 0x0008, 0x0006, 0x0036, 0x0156,
+	0x7954, 0xd1ac, 0x1904, 0x0b9b, 0x080c, 0x5757, 0x0158, 0x080c,
+	0x576b, 0x1128, 0x2001, 0x128f, 0x2003, 0x0000, 0x0070, 0x080c,
+	0x574d, 0x0dc0, 0x2001, 0x128f, 0x2003, 0xaaaa, 0x2001, 0x1290,
+	0x2003, 0x0001, 0x080c, 0x5682, 0x0058, 0x080c, 0x5745, 0x0140,
+	0x2009, 0x00f8, 0x080c, 0x46a4, 0x7843, 0x0090, 0x7843, 0x0010,
+	0x20a9, 0x09c4, 0x7820, 0xd09c, 0x1138, 0x080c, 0x5745, 0x0138,
+	0x7824, 0xd0ac, 0x1904, 0x0c6f, 0x1f04, 0x0b7a, 0x0070, 0x7824,
+	0x080c, 0x5761, 0x0118, 0xd0ac, 0x1904, 0x0c6f, 0x9084, 0x1800,
+	0x0d98, 0x7003, 0x0001, 0x0804, 0x0c6f, 0x2001, 0x0001, 0x080c,
+	0x1c36, 0x0804, 0x0c78, 0x080c, 0x203d, 0x1148, 0x2001, 0x0001,
+	0x080c, 0x1faf, 0x2001, 0x0001, 0x080c, 0x1f92, 0x00d8, 0x080c,
+	0x2045, 0x1138, 0x9006, 0x080c, 0x1faf, 0x9006, 0x080c, 0x1f92,
+	0x0088, 0x080c, 0x204d, 0x1d50, 0x2001, 0x12b8, 0x2004, 0xd0fc,
+	0x0128, 0x7828, 0x9085, 0x0020, 0x782a, 0x0020, 0x080c, 0x1d96,
+	0x0804, 0x0c6a, 0x7850, 0x9085, 0x0040, 0x7852, 0x7938, 0x7850,
+	0x9084, 0xfbcf, 0x7852, 0x080c, 0x2055, 0x9085, 0x2000, 0x7852,
+	0x793a, 0x20a9, 0x0046, 0x1d04, 0x0bd3, 0x2091, 0x6000, 0x1f04,
+	0x0bd3, 0x7850, 0x9085, 0x0400, 0x9084, 0xdfbf, 0x7852, 0x793a,
+	0x080c, 0x5757, 0x0158, 0x080c, 0x576b, 0x1128, 0x2001, 0x128f,
+	0x2003, 0x0000, 0x0070, 0x080c, 0x574d, 0x0dc0, 0x2001, 0x128f,
+	0x2003, 0xaaaa, 0x2001, 0x1290, 0x2003, 0x0001, 0x080c, 0x5682,
+	0x0020, 0x2009, 0x00f8, 0x080c, 0x46a4, 0x20a9, 0x0028, 0xa001,
+	0x1f04, 0x0bff, 0x7850, 0x9085, 0x1400, 0x7852, 0x080c, 0x5745,
+	0x0120, 0x7843, 0x0090, 0x7843, 0x0010, 0x2021, 0xe678, 0x2019,
+	0xea60, 0x7820, 0xd09c, 0x1528, 0x080c, 0x5745, 0x05c0, 0x7824,
+	0xd0ac, 0x1904, 0x0c6f, 0x080c, 0x576b, 0x11d8, 0x0046, 0x2021,
+	0x0320, 0x8421, 0x1df0, 0x004e, 0x7827, 0x1800, 0x080c, 0x2055,
+	0x7824, 0x9084, 0x1800, 0x1110, 0x8421, 0x1158, 0x2001, 0x128f,
+	0x2003, 0xaaaa, 0x2001, 0x1290, 0x2003, 0x0001, 0x7003, 0x0001,
+	0x04b0, 0x8319, 0x19b0, 0x2009, 0x12bb, 0x2104, 0x8001, 0x200a,
+	0x1168, 0x7827, 0x0048, 0x20a9, 0x0002, 0x080c, 0x2036, 0x7924,
+	0x080c, 0x2055, 0xd19c, 0x0110, 0x080c, 0x1f80, 0x00d8, 0x080c,
+	0x5757, 0x1140, 0x94a2, 0x03e8, 0x1128, 0x080c, 0x571c, 0x7003,
+	0x0001, 0x00a8, 0x7827, 0x1800, 0x080c, 0x2055, 0x7824, 0x080c,
+	0x5761, 0x0110, 0xd0ac, 0x1158, 0x9084, 0x1800, 0x0990, 0x7003,
+	0x0001, 0x0028, 0x2001, 0x0001, 0x080c, 0x1c36, 0x0028, 0x7827,
+	0x0048, 0x7828, 0xc09d, 0x782a, 0x7850, 0x9085, 0x0400, 0x7852,
+	0x9006, 0x78f2, 0x015e, 0x003e, 0x000e, 0x7034, 0xd0b4, 0x1110,
+	0x080c, 0x0d29, 0x012e, 0x00fe, 0x004e, 0x001e, 0x0005, 0x0005,
+	0x0005, 0x0005, 0x2a70, 0x2001, 0x128f, 0x2003, 0x0000, 0x7087,
+	0x0000, 0x2009, 0x0100, 0x2104, 0x9082, 0x0002, 0x0218, 0x704f,
+	0xffff, 0x0010, 0x704f, 0x0000, 0x7057, 0xffff, 0x706f, 0x0000,
+	0x7073, 0x0000, 0x080c, 0x99a3, 0x2061, 0x127f, 0x6003, 0x0909,
+	0x6007, 0x0000, 0x600b, 0x8800, 0x600f, 0x0200, 0x6013, 0x00ff,
+	0x6017, 0x0003, 0x601b, 0x0000, 0x601f, 0x07d0, 0x2061, 0x1287,
+	0x6003, 0x8000, 0x6007, 0x0000, 0x600b, 0x0000, 0x600f, 0x0200,
+	0x6013, 0x00ff, 0x6017, 0x0000, 0x601b, 0x0001, 0x601f, 0x0000,
+	0x2061, 0x12a9, 0x6003, 0x514c, 0x6007, 0x4f47, 0x600b, 0x4943,
+	0x600f, 0x2020, 0x2001, 0x1127, 0x2003, 0x0000, 0x0005, 0x2011,
+	0x0000, 0x080c, 0x4b58, 0x1178, 0x6004, 0x90c4, 0x00ff, 0x98c6,
+	0x0006, 0x0128, 0x90c4, 0xff00, 0x98c6, 0x0600, 0x1120, 0x9186,
+	0x0080, 0x0108, 0x8210, 0x8108, 0x9186, 0x0100, 0x1d50, 0x2208,
+	0x0005, 0x2091, 0x8000, 0x0e04, 0x0cf3, 0x0006, 0x0016, 0x2079,
+	0x0000, 0x001e, 0x798e, 0x000e, 0x788a, 0x000e, 0x7886, 0x3900,
+	0x789a, 0x7883, 0x8002, 0x7837, 0x8002, 0x7833, 0x0012, 0x2091,
+	0x5000, 0x0156, 0x00d6, 0x2079, 0x0300, 0x7803, 0x0000, 0x2069,
+	0x1331, 0x901e, 0x20a9, 0x0020, 0x7b26, 0x7a28, 0x226a, 0x8d68,
+	0x8318, 0x1f04, 0x0d14, 0x00de, 0x015e, 0x2079, 0x1100, 0x7803,
+	0x0005, 0x2091, 0x4080, 0x7834, 0xd0b4, 0x1108, 0x0451, 0x0cd8,
+	0x0005, 0x00f6, 0x0006, 0x2079, 0x1123, 0x2f04, 0x8000, 0x207a,
+	0x9082, 0x000f, 0x0258, 0x9006, 0x207a, 0x2079, 0x1125, 0x2f04,
+	0x9084, 0x0001, 0x9086, 0x0001, 0x207a, 0x0080, 0x2079, 0x1125,
+	0x2f7c, 0x8fff, 0x1130, 0x0026, 0x2011, 0x0080, 0x00e1, 0x002e,
+	0x0028, 0x0026, 0x2011, 0x0000, 0x00b1, 0x002e, 0x000e, 0x00fe,
+	0x0005, 0x0026, 0x2011, 0x0080, 0x0071, 0x002e, 0x2009, 0x0fff,
+	0x00b9, 0x0026, 0x2011, 0x0040, 0x0031, 0x002e, 0x2009, 0x0fff,
+	0x0079, 0x0c78, 0x0005, 0x0016, 0x3b08, 0x3a00, 0x9104, 0x918d,
+	0x00c0, 0x21d8, 0x9084, 0xff3f, 0x9205, 0x20d0, 0x001e, 0x0005,
+	0x0156, 0x0126, 0x918c, 0x0fff, 0x21a8, 0x1d04, 0x0d75, 0x2091,
+	0x6000, 0x1f04, 0x0d75, 0x012e, 0x015e, 0x0005, 0x890b, 0x810b,
+	0x810b, 0x810b, 0x810b, 0x810b, 0x9994, 0xfc00, 0x8217, 0x8214,
+	0x8214, 0x0005, 0x0006, 0x814c, 0x894c, 0x894c, 0x894c, 0x894c,
+	0x894c, 0x9284, 0x003f, 0x8007, 0x8003, 0x8003, 0x994d, 0x000e,
+	0x0005, 0x0016, 0x0026, 0x0096, 0x3348, 0x0c01, 0x2100, 0x9300,
+	0x2098, 0x22e0, 0x009e, 0x002e, 0x001e, 0x3518, 0x20a9, 0x0001,
+	0x4002, 0x8007, 0x4004, 0x8319, 0x1dd8, 0x0005, 0x2071, 0x1100,
+	0x715c, 0x712e, 0x2021, 0x0001, 0x9190, 0x0040, 0x9298, 0x0040,
+	0x0240, 0x7060, 0x9302, 0x1228, 0x220a, 0x2208, 0x2310, 0x8420,
+	0x0ca8, 0x200b, 0x0000, 0x74ae, 0x74b2, 0x0005, 0x00e6, 0x0126,
+	0x2091, 0x8000, 0x2071, 0x1100, 0x70b0, 0x90ea, 0x0010, 0x0268,
+	0x8001, 0x70b2, 0x702c, 0x2068, 0x2d04, 0x702e, 0x206b, 0x0000,
+	0x6807, 0x0000, 0x012e, 0x00ee, 0x0005, 0x906e, 0x0cd8, 0x00e6,
+	0x2071, 0x1100, 0x0126, 0x2091, 0x8000, 0x70b0, 0x8001, 0x0260,
+	0x70b2, 0x702c, 0x2068, 0x2d04, 0x702e, 0x206b, 0x0000, 0x6807,
+	0x0000, 0x012e, 0x00ee, 0x0005, 0x906e, 0x0cd8, 0x00e6, 0x0126,
+	0x2091, 0x8000, 0x2071, 0x1100, 0x702c, 0x206a, 0x2d00, 0x702e,
+	0x70b0, 0x8000, 0x70b2, 0x012e, 0x00ee, 0x0005, 0x8dff, 0x0138,
+	0x6804, 0x6807, 0x0000, 0x0006, 0x0c49, 0x00de, 0x0cb8, 0x0005,
+	0x00e6, 0x2071, 0x1100, 0x70b0, 0x908a, 0x0010, 0x900d, 0x00ee,
+	0x0005, 0x00d6, 0x0821, 0x0148, 0x0016, 0x0026, 0x2d08, 0x2011,
+	0x0001, 0x080c, 0x0d8a, 0x002e, 0x001e, 0x00de, 0x0005, 0x00d6,
+	0x080c, 0x0dc6, 0x0148, 0x0016, 0x0026, 0x2d08, 0x2011, 0x0001,
+	0x080c, 0x0d8a, 0x002e, 0x001e, 0x00de, 0x0005, 0x00d6, 0x0016,
+	0x0026, 0x080c, 0x0d7e, 0x2168, 0x002e, 0x001e, 0x080c, 0x0df6,
+	0x00de, 0x0005, 0x00e6, 0x2071, 0x130a, 0x7007, 0x0000, 0x701f,
+	0x0000, 0x7023, 0x0000, 0x7003, 0x0000, 0x2071, 0x0000, 0x7010,
+	0x9085, 0x8004, 0x7012, 0x00ee, 0x0005, 0x00e6, 0x2270, 0x700b,
+	0x0000, 0x2071, 0x130a, 0x701c, 0x9088, 0x1314, 0x220a, 0x8000,
+	0x9084, 0x0007, 0x701e, 0x7004, 0x9005, 0x1128, 0x00f6, 0x2079,
+	0x0080, 0x0081, 0x00fe, 0x00ee, 0x0005, 0x00e6, 0x2071, 0x130a,
+	0x7004, 0x9005, 0x1128, 0x00f6, 0x2079, 0x0080, 0x0019, 0x00fe,
+	0x00ee, 0x0005, 0x7000, 0x0002, 0x0e7e, 0x0cf1, 0x701c, 0x7120,
+	0x9106, 0x1118, 0x7007, 0x0000, 0x0005, 0x00d6, 0x9180, 0x1314,
+	0x2004, 0x700a, 0x2068, 0x8108, 0x918c, 0x0007, 0x7122, 0x782b,
+	0x0026, 0x6828, 0x7802, 0x682c, 0x7806, 0x6830, 0x780a, 0x6834,
+	0x780e, 0x6814, 0x700e, 0x680c, 0x7016, 0x6810, 0x701a, 0x6804,
+	0x00de, 0xd084, 0x0120, 0x7007, 0x0001, 0x0029, 0x0005, 0x7007,
+	0x0002, 0x00b1, 0x0005, 0x0016, 0x0026, 0x710c, 0x2011, 0x0040,
+	0x9182, 0x0040, 0x1210, 0x2110, 0x9006, 0x700e, 0x7212, 0x8203,
+	0x7812, 0x782b, 0x0020, 0x782b, 0x0041, 0x002e, 0x001e, 0x0005,
+	0x0016, 0x0026, 0x0136, 0x0146, 0x0156, 0x7014, 0x20e0, 0x7018,
+	0x2098, 0x20e9, 0x0000, 0x20a1, 0x0088, 0x782b, 0x0026, 0x710c,
+	0x2011, 0x0040, 0x9182, 0x0040, 0x1210, 0x2110, 0x9006, 0x700e,
+	0x22a8, 0x4006, 0x8203, 0x7812, 0x782b, 0x0020, 0x3300, 0x701a,
+	0x782b, 0x0001, 0x015e, 0x014e, 0x013e, 0x002e, 0x001e, 0x0005,
+	0x0016, 0x00e6, 0x2071, 0x130a, 0x00f6, 0x2079, 0x0080, 0x792c,
+	0x782b, 0x0002, 0xd1fc, 0x0120, 0x918c, 0x0700, 0x7004, 0x0023,
+	0x00fe, 0x00ee, 0x001e, 0x0005, 0x0e7a, 0x0f01, 0x0f33, 0x0f00,
+	0x0cf8, 0x918c, 0x0700, 0x1548, 0x0136, 0x0146, 0x0156, 0x7014,
+	0x20e8, 0x7018, 0x20a0, 0x20e1, 0x0000, 0x2099, 0x0088, 0x782b,
+	0x0040, 0x7010, 0x20a8, 0x4005, 0x3400, 0x701a, 0x015e, 0x014e,
+	0x013e, 0x700c, 0x9005, 0x0560, 0x7800, 0x7802, 0x7804, 0x7806,
+	0x080c, 0x0eab, 0x0005, 0x7008, 0x9080, 0x0002, 0x2003, 0x0100,
+	0x7007, 0x0000, 0x080c, 0x0e7a, 0x0005, 0x7008, 0x9080, 0x0002,
+	0x2003, 0x0200, 0x0ca8, 0x918c, 0x0700, 0x1150, 0x700c, 0x9005,
+	0x0178, 0x7800, 0x7802, 0x7804, 0x7806, 0x080c, 0x0ec0, 0x0005,
+	0x7008, 0x9080, 0x0002, 0x2003, 0x0200, 0x7007, 0x0000, 0x0080,
+	0x00d6, 0x7008, 0x2068, 0x7800, 0x682a, 0x7804, 0x682e, 0x7808,
+	0x6832, 0x780c, 0x6836, 0x680b, 0x0100, 0x00de, 0x7007, 0x0000,
+	0x00c6, 0x00d6, 0x7008, 0x2060, 0x0081, 0x0150, 0x6038, 0x080f,
+	0x603b, 0x0000, 0x603f, 0x0000, 0x2c00, 0x2068, 0x080c, 0x0df6,
+	0x00de, 0x00ce, 0x080c, 0x0e7a, 0x0005, 0x00e6, 0x2071, 0x1100,
+	0x8cff, 0x0140, 0x705c, 0x9c02, 0x0238, 0x9c82, 0xffff, 0x1220,
+	0x9085, 0x0001, 0x00ee, 0x0005, 0x9006, 0x0ce0, 0x603c, 0x906d,
+	0x090c, 0x0cf1, 0x6008, 0x908e, 0x0100, 0x0130, 0x687b, 0x0030,
+	0x6883, 0x0000, 0x6897, 0x4002, 0x080c, 0x50a5, 0x0005, 0x0126,
+	0x2091, 0x2200, 0x2079, 0x0300, 0x2071, 0x131c, 0x7003, 0x0000,
+	0x78bf, 0x00f6, 0x00c1, 0x7803, 0x0003, 0x780f, 0x0000, 0x20a9,
+	0x01c4, 0x2061, 0xae21, 0x2c0d, 0x7912, 0xe104, 0x9ce0, 0x0002,
+	0x7916, 0x1f04, 0x0fa3, 0x7807, 0x0001, 0x7803, 0x0000, 0x7803,
+	0x0001, 0x012e, 0x0005, 0x00c6, 0x7803, 0x0000, 0x7827, 0x0030,
+	0x782b, 0x0400, 0x7827, 0x0031, 0x782b, 0x1331, 0x781f, 0xff00,
+	0x781b, 0xff00, 0x2061, 0x1331, 0x602f, 0x15c0, 0x6033, 0x3000,
+	0x603b, 0x168e, 0x00ce, 0x0005, 0x0126, 0x2091, 0x2200, 0x7808,
+	0xd09c, 0x0138, 0x7820, 0x908c, 0xf000, 0x1508, 0x0043, 0x012e,
+	0x0005, 0x9084, 0x0070, 0x190c, 0x0cf1, 0x012e, 0x0005, 0x0ff5,
+	0x0ff7, 0x0ffe, 0x1002, 0x1006, 0x100b, 0x100e, 0x1012, 0x101f,
+	0x1024, 0x0ff5, 0x108d, 0x1091, 0x10d3, 0x0ff5, 0x0ff5, 0x0ff5,
+	0x0ff5, 0x0ff5, 0x0ff5, 0x0ff5, 0x0ff5, 0x080c, 0x0cf1, 0x2009,
+	0x0048, 0x2060, 0x080c, 0x7f4e, 0x012e, 0x0005, 0x7004, 0xc085,
+	0x7006, 0x0005, 0x7004, 0xc085, 0x7006, 0x0005, 0x080c, 0x10da,
+	0x080c, 0x1161, 0x0005, 0x080c, 0x0cf1, 0x0005, 0x7004, 0xc095,
+	0x7006, 0x0005, 0x080c, 0x10da, 0x2060, 0x6014, 0x9080, 0x000e,
+	0x2003, 0xffff, 0x2009, 0x0048, 0x080c, 0x7f4e, 0x0005, 0x080c,
+	0x10da, 0x080c, 0x0cf1, 0x0005, 0x080c, 0x10da, 0x2001, 0x0016,
+	0x080c, 0x113b, 0x7827, 0x0018, 0x79ac, 0xd1dc, 0x01c8, 0x7827,
+	0x0015, 0x7828, 0x782b, 0x0000, 0x9065, 0x0138, 0x2001, 0x020d,
+	0x2003, 0x0050, 0x2003, 0x0020, 0x0088, 0x7004, 0x9005, 0x090c,
+	0x0cf1, 0x78ab, 0x0004, 0x7803, 0x0001, 0x080c, 0x1091, 0x0005,
+	0x7828, 0x782b, 0x0000, 0x9065, 0x090c, 0x0cf1, 0x6014, 0x2068,
+	0x78ab, 0x0004, 0x918c, 0x0700, 0x01d8, 0x080c, 0x1337, 0x080c,
+	0x95d2, 0x0158, 0x69ac, 0x6936, 0x69b0, 0x693a, 0x683f, 0xffff,
+	0x6843, 0xffff, 0x6880, 0xc0bd, 0x6882, 0x7827, 0x0015, 0x782b,
+	0x0000, 0x781f, 0x0300, 0x7803, 0x0001, 0x080c, 0x92a4, 0x0005,
+	0x6010, 0x2004, 0xd0bc, 0x190c, 0x993c, 0x2001, 0x0201, 0x2004,
+	0x9005, 0x0dd8, 0x7dbc, 0x080c, 0xadd8, 0xd5a4, 0x1118, 0x080c,
+	0x10df, 0x0005, 0x080c, 0x1337, 0x7827, 0x0015, 0x782b, 0x0000,
+	0x781f, 0x0300, 0x7803, 0x0001, 0x0005, 0x7004, 0xc09d, 0x7006,
+	0x0005, 0x7104, 0x9184, 0x0004, 0x190c, 0x0cf1, 0xd184, 0x1181,
+	0xd19c, 0x0150, 0xc19c, 0x7106, 0x2001, 0x020d, 0x2003, 0x0050,
+	0x2003, 0x0020, 0x04e1, 0x0005, 0x81ff, 0x190c, 0x0cf1, 0x0005,
+	0xc184, 0x7106, 0x0016, 0x00e6, 0x2071, 0x0200, 0x080c, 0x1155,
+	0x6014, 0x9005, 0x01c0, 0x9080, 0x0019, 0x2004, 0x9084, 0x00ff,
+	0x9086, 0x0029, 0x1180, 0x00f6, 0x2c78, 0x080c, 0x119d, 0x00fe,
+	0x2001, 0x020d, 0x2003, 0x0020, 0x080c, 0x0fb3, 0x7803, 0x0001,
+	0x00ee, 0x001e, 0x0005, 0x2001, 0x020d, 0x2003, 0x0050, 0x2003,
+	0x0020, 0x0069, 0x0ca8, 0x0031, 0x2060, 0x2009, 0x0053, 0x080c,
+	0x7f4e, 0x0005, 0x7808, 0xd09c, 0x0de8, 0x7820, 0x0005, 0x00d6,
+	0x2069, 0x0200, 0x7908, 0x918c, 0x0007, 0x9186, 0x0003, 0x0120,
+	0x2001, 0x0016, 0x080c, 0x113b, 0x6804, 0x9005, 0x0de8, 0x2001,
+	0x015d, 0x2003, 0x0000, 0x79bc, 0x0016, 0x001e, 0xd1a4, 0x1518,
+	0x79b8, 0x0016, 0x001e, 0x918c, 0x0fff, 0x0178, 0x9182, 0x0841,
+	0x1260, 0x9188, 0x0007, 0x918c, 0x0ff8, 0x810c, 0x810c, 0x810c,
+	0x0421, 0x6827, 0x0001, 0x8109, 0x1dd8, 0x00f9, 0x6827, 0x0002,
+	0x00e1, 0x682c, 0xd0e4, 0x1148, 0x6804, 0x9005, 0x0de8, 0x79b8,
+	0xd1ec, 0x1118, 0x08c0, 0x080c, 0x1337, 0x7827, 0x0015, 0x782b,
+	0x0000, 0x2001, 0x020d, 0x2003, 0x0020, 0x2001, 0x0307, 0x2003,
+	0x0300, 0x7803, 0x0001, 0x00de, 0x0005, 0x6824, 0x9084, 0x0003,
+	0x1de0, 0x0005, 0x2001, 0x0030, 0x2c08, 0x621c, 0x0021, 0x7830,
+	0x9086, 0x0041, 0x0005, 0x00f6, 0x2079, 0x0300, 0x0006, 0x7808,
+	0xd09c, 0x0140, 0x0016, 0x0026, 0x00c6, 0x080c, 0x0fcc, 0x00ce,
+	0x002e, 0x001e, 0x000e, 0x7832, 0x7936, 0x7a3a, 0x781b, 0x8080,
+	0x7818, 0xd0bc, 0x1de8, 0x00fe, 0x0005, 0x7037, 0x0001, 0x7150,
+	0x7037, 0x0002, 0x7050, 0x2060, 0xd1bc, 0x1110, 0x7054, 0x2060,
+	0x0005, 0x00e6, 0x0016, 0x2071, 0x0200, 0x0c79, 0x7358, 0x745c,
+	0x6014, 0x905d, 0x0530, 0x2b68, 0x6010, 0x2004, 0xd0bc, 0x190c,
+	0x9917, 0x6b42, 0x6c3e, 0x2001, 0x1174, 0x2004, 0xd0b4, 0x1120,
+	0x683b, 0xffff, 0x6837, 0xffff, 0x080c, 0x16ae, 0x1190, 0x080c,
+	0x1255, 0x2a00, 0x6816, 0x0130, 0x2c00, 0x680e, 0x2805, 0x680a,
+	0x2800, 0x6812, 0x7037, 0x0020, 0x781f, 0x0300, 0x001e, 0x00ee,
+	0x0005, 0x7037, 0x0050, 0x7037, 0x0020, 0x001e, 0x00ee, 0x080c,
+	0x10df, 0x0005, 0x080c, 0x0cf1, 0x0005, 0x2ff0, 0x0126, 0x2091,
+	0x2200, 0x3e60, 0x6014, 0x2068, 0x2d60, 0x903e, 0x2730, 0x6964,
+	0x691a, 0x9184, 0x000f, 0x9088, 0x168e, 0x2145, 0x0002, 0x11bf,
+	0x1226, 0x11bf, 0x11bf, 0x11bf, 0x11ff, 0x11bf, 0x11c3, 0x11bf,
+	0x1214, 0x11bf, 0x11bf, 0x11bf, 0x11bf, 0x11e9, 0x11d5, 0x9085,
+	0x0001, 0x0804, 0x124d, 0x687c, 0xd0bc, 0x0dc8, 0x6890, 0x6842,
+	0x688c, 0x683e, 0x6888, 0x00d6, 0x2805, 0x9c68, 0x6b08, 0x6a0c,
+	0x6d00, 0x6c04, 0x00de, 0x0804, 0x1235, 0x687c, 0xd0bc, 0x0d38,
+	0x6890, 0x6842, 0x688c, 0x683e, 0x6888, 0x00d6, 0x2805, 0x9c68,
+	0x6b10, 0x6a14, 0x6d00, 0x6c04, 0x6f08, 0x6e0c, 0x00de, 0x0804,
+	0x1235, 0x687c, 0xd0bc, 0x0998, 0x6890, 0x6842, 0x688c, 0x683e,
+	0x6804, 0x2060, 0x9080, 0x0019, 0x200c, 0x691a, 0x91cc, 0x000f,
+	0x9980, 0x168e, 0x2045, 0x6888, 0xd19c, 0x11e8, 0x0470, 0x687c,
+	0xd0ac, 0x0904, 0x11bf, 0x6804, 0x2060, 0x9080, 0x0019, 0x200c,
+	0x691a, 0x91cc, 0x000f, 0x9980, 0x168e, 0x2045, 0x9006, 0x6842,
+	0x683e, 0xd19c, 0x1140, 0x00c8, 0x687c, 0xd0ac, 0x0904, 0x11bf,
+	0x9006, 0x6842, 0x683e, 0x00d6, 0x2805, 0x9c68, 0x6b10, 0x6a14,
+	0x6d00, 0x6c04, 0x6f08, 0x6e0c, 0x00de, 0x0078, 0x687c, 0xd0ac,
+	0x0904, 0x11bf, 0x9006, 0x6842, 0x683e, 0x00d6, 0x2805, 0x9c68,
+	0x6b08, 0x6a0c, 0x6d00, 0x6c04, 0x00de, 0x6b2e, 0x6a32, 0x6d1e,
+	0x6c22, 0x6f26, 0x6e2a, 0x6988, 0x8840, 0x281d, 0x68ac, 0x6ab0,
+	0x6836, 0x6a3a, 0x8109, 0x6916, 0x1150, 0x3e60, 0x601c, 0xc085,
+	0x601e, 0x687c, 0xc0dd, 0x687e, 0x9006, 0x012e, 0x0005, 0x2c00,
+	0x680e, 0x6b0a, 0x2800, 0x6812, 0x0c80, 0x903e, 0x2730, 0x6880,
+	0xd0fc, 0x11a8, 0x00d6, 0x2805, 0x9c68, 0x2900, 0x0002, 0x1297,
+	0x127d, 0x127d, 0x1297, 0x1297, 0x1291, 0x1297, 0x127d, 0x1297,
+	0x1282, 0x1282, 0x1297, 0x1297, 0x1297, 0x1289, 0x1282, 0xc0fc,
+	0x6882, 0x6b2c, 0x6a30, 0x6d1c, 0x6c20, 0x00d6, 0xd99c, 0x0510,
+	0x2805, 0x9c68, 0x6f08, 0x6e0c, 0x00e8, 0x6b08, 0x6a0c, 0x6d00,
+	0x6c04, 0x00c0, 0x6b10, 0x6a14, 0x6d00, 0x6c04, 0x6f08, 0x6e0c,
+	0x0088, 0x00de, 0x00d6, 0x6864, 0x9084, 0x00ff, 0x9086, 0x001e,
+	0x1130, 0x00de, 0x080c, 0x164e, 0x1900, 0x900e, 0x0060, 0x00de,
+	0x080c, 0x0cf1, 0x00de, 0x6b2e, 0x6a32, 0x6d1e, 0x6c22, 0x6f26,
+	0x6e2a, 0x080c, 0x164e, 0x0005, 0x2001, 0x020b, 0x2004, 0xd0e4,
+	0x0110, 0xd0d4, 0x1140, 0x6014, 0x9080, 0x0021, 0x6118, 0x2102,
+	0x601b, 0x0002, 0x0005, 0x0126, 0x00c6, 0x2091, 0x2200, 0x00ce,
+	0x2001, 0x0037, 0x2c08, 0x080c, 0x113b, 0x6000, 0x9086, 0x0004,
+	0x1120, 0x2009, 0x0048, 0x080c, 0x7f4e, 0x012e, 0x0005, 0x0126,
+	0x00c6, 0x2091, 0x2200, 0x00ce, 0x7908, 0x918c, 0x0007, 0x9186,
+	0x0000, 0x0904, 0x132c, 0x9186, 0x0003, 0x0904, 0x132c, 0x6020,
+	0x6023, 0x0000, 0x0006, 0x2031, 0x0190, 0x00c6, 0x7808, 0xd09c,
+	0x190c, 0x0fcc, 0x00ce, 0x2001, 0x0038, 0x2c08, 0x621c, 0x080c,
+	0x113b, 0x7930, 0x9186, 0x0040, 0x05d8, 0x9186, 0x0042, 0x190c,
+	0x0cf1, 0x2001, 0x001e, 0x8001, 0x1df0, 0x8631, 0x1d30, 0x080c,
+	0x136e, 0x0026, 0x0056, 0x2001, 0x00d2, 0x8001, 0x1df0, 0x2031,
+	0x2000, 0x8631, 0x05a1, 0x2001, 0x020b, 0x2004, 0xd0e4, 0x0dc8,
+	0x78ab, 0x0004, 0x080c, 0x0fb3, 0x781f, 0x8080, 0x78ab, 0x0009,
+	0x601c, 0xc084, 0x601e, 0x080c, 0x5745, 0x1130, 0x0066, 0x2031,
+	0x0001, 0x080c, 0x57d6, 0x006e, 0x7803, 0x0000, 0x7803, 0x0001,
+	0x005e, 0x002e, 0x2001, 0x0160, 0x2502, 0x2001, 0x0138, 0x2202,
+	0x000e, 0x6022, 0x012e, 0x0005, 0x601c, 0xc084, 0x601e, 0x7827,
+	0x0015, 0x7828, 0x9c06, 0x1db0, 0x782b, 0x0000, 0x0c98, 0x080c,
+	0x5745, 0x11b0, 0x2001, 0x0138, 0x2003, 0x0000, 0x2001, 0x0160,
+	0x2003, 0x0000, 0x2011, 0x012c, 0xa001, 0xa001, 0x8211, 0x1de0,
+	0x0081, 0x0066, 0x2031, 0x0000, 0x080c, 0x57d6, 0x006e, 0x0005,
+	0x00e9, 0x0039, 0x2001, 0x0160, 0x2502, 0x2001, 0x0138, 0x2202,
+	0x0005, 0x00e6, 0x2071, 0x0200, 0x080c, 0x205b, 0x7003, 0x002c,
+	0x2001, 0x015d, 0x2003, 0x0000, 0x7000, 0x9084, 0x002c, 0x1de0,
+	0x7098, 0x709a, 0x709c, 0x709e, 0x00ee, 0x0005, 0x2001, 0x0138,
+	0x2014, 0x2003, 0x0000, 0x2001, 0x0160, 0x202c, 0x2003, 0x0000,
+	0x2021, 0x0260, 0x2001, 0x0141, 0x201c, 0xd3dc, 0x1168, 0x2001,
+	0x0109, 0x201c, 0x939c, 0x0048, 0x1160, 0x2001, 0x0111, 0x201c,
+	0x83ff, 0x1110, 0x8421, 0x1d70, 0x2001, 0x015d, 0x2003, 0x0000,
+	0x0005, 0x0046, 0x2021, 0x0019, 0x2003, 0x0048, 0xa001, 0xa001,
+	0x201c, 0x939c, 0x0048, 0x0120, 0x8421, 0x1db0, 0x004e, 0x0c60,
+	0x004e, 0x0c40, 0x00e6, 0x2071, 0x131f, 0x7003, 0x0000, 0x00ee,
+	0x0005, 0x00d6, 0x9280, 0x0005, 0x206c, 0x697c, 0xd1dc, 0x1904,
+	0x141f, 0x6964, 0x9184, 0x0007, 0x0002, 0x13bd, 0x140a, 0x13bd,
+	0x13bd, 0x13bd, 0x13f1, 0x13d0, 0x13bf, 0x080c, 0x0cf1, 0x687c,
+	0xd0b4, 0x0904, 0x1507, 0x6890, 0x6842, 0x683a, 0x688c, 0x683e,
+	0x6836, 0x68ac, 0x6846, 0x68b0, 0x684a, 0x6988, 0x0804, 0x1412,
+	0x6864, 0x9084, 0x00ff, 0x9086, 0x001e, 0x1d38, 0x687c, 0xd0b4,
+	0x0904, 0x1507, 0x6890, 0x6842, 0x683a, 0x688c, 0x683e, 0x6836,
+	0x68ac, 0x6846, 0x68b0, 0x684a, 0x6804, 0x685a, 0x9080, 0x0019,
+	0x2004, 0x9084, 0x000f, 0x9080, 0x168e, 0x2005, 0x6812, 0x6988,
+	0x0450, 0x918c, 0x00ff, 0x9186, 0x0015, 0x1548, 0x687c, 0xd0b4,
+	0x0904, 0x1507, 0x6804, 0x685a, 0x9080, 0x0019, 0x2004, 0x9084,
+	0x000f, 0x9080, 0x168e, 0x2005, 0x6812, 0x6988, 0x9006, 0x6842,
+	0x683e, 0x0088, 0x687c, 0xd0b4, 0x0904, 0x1507, 0x6988, 0x9006,
+	0x6842, 0x683e, 0x2d00, 0x685a, 0x6864, 0x9084, 0x000f, 0x9080,
+	0x168e, 0x2005, 0x6812, 0x6916, 0x687c, 0xc0dd, 0x687e, 0x00de,
+	0x0005, 0x00f6, 0x2079, 0x0090, 0x782c, 0xd0fc, 0x190c, 0x1543,
+	0x00e6, 0x00d6, 0x2071, 0x131f, 0x7000, 0x9005, 0x1904, 0x1478,
+	0x00c6, 0x7206, 0x9280, 0x0005, 0x205c, 0x7004, 0x2068, 0x782b,
+	0x0004, 0x6810, 0x00d6, 0x2068, 0x686c, 0x7836, 0x6890, 0x00f6,
+	0x2079, 0x0200, 0x7803, 0x0040, 0x781a, 0x2079, 0x0100, 0x8004,
+	0x78d6, 0x00fe, 0x00de, 0x2b68, 0x6814, 0x2050, 0x6858, 0x2060,
+	0x6810, 0x2040, 0x6064, 0x90cc, 0x000f, 0x6944, 0x791a, 0x7116,
+	0x6848, 0x781e, 0x701a, 0x9006, 0x700e, 0x7012, 0x7004, 0x6940,
+	0x6838, 0x9106, 0x11c8, 0x693c, 0x6834, 0x9106, 0x11a8, 0x8aff,
+	0x01f0, 0x0126, 0x2091, 0x8000, 0x2079, 0x0090, 0x2009, 0x0001,
+	0x00d1, 0x0118, 0x2009, 0x0001, 0x00b1, 0x012e, 0x00ce, 0x9006,
+	0x00de, 0x00ee, 0x00fe, 0x0005, 0x0036, 0x0046, 0x6b38, 0x6c34,
+	0x080c, 0x16ae, 0x004e, 0x003e, 0x0d10, 0x00ce, 0x0c88, 0x00ce,
+	0x9085, 0x0001, 0x0c68, 0x0076, 0x0066, 0x0056, 0x0046, 0x0036,
+	0x0026, 0x8aff, 0x0904, 0x1500, 0x700c, 0x7214, 0x923a, 0x7010,
+	0x7218, 0x9203, 0x0a04, 0x14ff, 0x9705, 0x0904, 0x14ff, 0x903e,
+	0x2730, 0x6880, 0xd0fc, 0x11a8, 0x00d6, 0x2805, 0x9c68, 0x2900,
+	0x0002, 0x14e2, 0x14c7, 0x14c7, 0x14e2, 0x14e2, 0x14db, 0x14e2,
+	0x14c7, 0x14e2, 0x14cc, 0x14cc, 0x14e2, 0x14e2, 0x14e2, 0x14d3,
+	0x14cc, 0xc0fc, 0x6882, 0x6b2c, 0x6a30, 0x6d1c, 0x6c20, 0xd99c,
+	0x0528, 0x00d6, 0x2805, 0x9c68, 0x6f08, 0x6e0c, 0x00f0, 0x6b08,
+	0x6a0c, 0x6d00, 0x6c04, 0x00c8, 0x6b10, 0x6a14, 0x6d00, 0x6c04,
+	0x6f08, 0x6e0c, 0x0090, 0x00de, 0x00d6, 0x6864, 0x9084, 0x00ff,
+	0x9086, 0x001e, 0x1138, 0x00de, 0x080c, 0x164e, 0x1904, 0x1491,
+	0x900e, 0x00f0, 0x00de, 0x080c, 0x0cf1, 0x00de, 0x7b12, 0x7a16,
+	0x7d02, 0x7c06, 0x7f0a, 0x7e0e, 0x792a, 0x7000, 0x8000, 0x7002,
+	0x683c, 0x9300, 0x683e, 0x6840, 0x9201, 0x6842, 0x700c, 0x9300,
+	0x700e, 0x7010, 0x9201, 0x7012, 0x080c, 0x164e, 0x0008, 0x9006,
+	0x002e, 0x003e, 0x004e, 0x005e, 0x006e, 0x007e, 0x0005, 0x080c,
+	0x0cf1, 0x0026, 0x2001, 0x0105, 0x2003, 0x0010, 0x782b, 0x0004,
+	0x7003, 0x0000, 0x7004, 0x2060, 0x00d6, 0x6014, 0x2068, 0x080c,
+	0x95d2, 0x0118, 0x6880, 0xc0bd, 0x6882, 0x6020, 0x9086, 0x0006,
+	0x1180, 0x2061, 0x0100, 0x62c8, 0x2001, 0x00fa, 0x8001, 0x1df0,
+	0x60c8, 0x9206, 0x1dc0, 0x60c4, 0x689a, 0x60c8, 0x6896, 0x7004,
+	0x2060, 0x00de, 0x080c, 0x92a4, 0x2001, 0x0200, 0x2003, 0x0040,
+	0x080c, 0x7b66, 0x2011, 0x0000, 0x080c, 0x79cc, 0x080c, 0x6e10,
+	0x002e, 0x0804, 0x15fd, 0x0126, 0x2091, 0x2400, 0x0006, 0x0016,
+	0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x2079, 0x0090, 0x2071, 0x131f,
+	0x2b68, 0x6858, 0x2060, 0x792c, 0x782b, 0x0002, 0x9184, 0x0700,
+	0x1904, 0x1509, 0x7000, 0x0002, 0x15fd, 0x1560, 0x15d0, 0x15fb,
+	0x8001, 0x7002, 0xd19c, 0x1170, 0x8aff, 0x05d0, 0x2009, 0x0001,
+	0x080c, 0x148b, 0x0904, 0x15fd, 0x2009, 0x0001, 0x080c, 0x148b,
+	0x0804, 0x15fd, 0x782b, 0x0004, 0xd194, 0x0148, 0x6880, 0xc0fc,
+	0x6882, 0x8aff, 0x11d8, 0x687c, 0xc0f5, 0x687e, 0x00b8, 0x0026,
+	0x0036, 0x6b3c, 0x6a40, 0x7810, 0x682e, 0x931a, 0x7814, 0x6832,
+	0x9213, 0x7800, 0x681e, 0x7804, 0x6822, 0x6b3e, 0x6a42, 0x003e,
+	0x002e, 0x080c, 0x1666, 0x6880, 0xc0fd, 0x6882, 0x2a00, 0x6816,
+	0x2c00, 0x685a, 0x2800, 0x6812, 0x7003, 0x0000, 0x0804, 0x15fd,
+	0x00f6, 0x0026, 0x781c, 0x0006, 0x7818, 0x0006, 0x2079, 0x0100,
+	0x7a14, 0x9284, 0x1984, 0x9085, 0x0012, 0x7816, 0x0036, 0x2019,
+	0x1000, 0x8319, 0x090c, 0x0cf1, 0x7820, 0xd0bc, 0x1dd0, 0x003e,
+	0x79c8, 0x000e, 0x9102, 0x001e, 0x0006, 0x0016, 0x79c4, 0x000e,
+	0x9103, 0x78c6, 0x000e, 0x78ca, 0x9284, 0x1984, 0x9085, 0x0012,
+	0x7816, 0x002e, 0x00fe, 0x782b, 0x0008, 0x7003, 0x0000, 0x0468,
+	0x8001, 0x7002, 0xd194, 0x0168, 0x782c, 0xd0fc, 0x1904, 0x1553,
+	0xd19c, 0x11f8, 0x8aff, 0x0508, 0x2009, 0x0001, 0x080c, 0x148b,
+	0x00e0, 0x0026, 0x0036, 0x6b3c, 0x6a40, 0x080c, 0x1666, 0x00d6,
+	0x2805, 0x9c68, 0x6064, 0xd09c, 0x1128, 0x6808, 0x931a, 0x680c,
+	0x9213, 0x0020, 0x6810, 0x931a, 0x6814, 0x9213, 0x00de, 0x0804,
+	0x1583, 0x0804, 0x157f, 0x080c, 0x0cf1, 0x00ce, 0x00de, 0x00ee,
+	0x00fe, 0x001e, 0x000e, 0x012e, 0x0005, 0x00f6, 0x00e6, 0x2071,
+	0x131f, 0x7000, 0x9086, 0x0000, 0x05f0, 0x2079, 0x0090, 0x2009,
+	0x0207, 0x210c, 0xd194, 0x01a8, 0x2009, 0x020c, 0x210c, 0x9184,
+	0x0003, 0x0178, 0x080c, 0xae13, 0x2001, 0x0133, 0x2004, 0x9005,
+	0x090c, 0x0cf1, 0x2001, 0x0200, 0x2003, 0x0040, 0x2001, 0x020c,
+	0x2102, 0x2009, 0x0206, 0x2104, 0x2009, 0x0203, 0x210c, 0x9106,
+	0x1120, 0x2001, 0x0200, 0x2003, 0x0040, 0x782c, 0xd0fc, 0x09b8,
+	0x080c, 0x1543, 0x7000, 0x9086, 0x0000, 0x1988, 0x782b, 0x0004,
+	0x782c, 0xd0ac, 0x1de8, 0x2001, 0x0200, 0x2003, 0x0040, 0x782b,
+	0x0002, 0x7003, 0x0000, 0x00ee, 0x00fe, 0x0005, 0x8840, 0x2805,
+	0x9005, 0x0110, 0x8a51, 0x0005, 0x6004, 0x9005, 0x0168, 0x685a,
+	0x2060, 0x6064, 0x9084, 0x000f, 0x9080, 0x168e, 0x2045, 0x88ff,
+	0x090c, 0x0cf1, 0x8a51, 0x0005, 0x2050, 0x0005, 0x8a50, 0x8841,
+	0x2805, 0x9005, 0x1190, 0x2c00, 0x9d06, 0x0120, 0x6000, 0x9005,
+	0x1108, 0x2d00, 0x2060, 0x685a, 0x6064, 0x9084, 0x000f, 0x9080,
+	0x169e, 0x2045, 0x88ff, 0x090c, 0x0cf1, 0x0005, 0x0000, 0x001d,
+	0x0021, 0x0025, 0x0029, 0x002d, 0x0031, 0x0035, 0x0000, 0x001b,
+	0x0021, 0x0027, 0x002d, 0x0033, 0x0000, 0x0000, 0x0000, 0x1683,
+	0x167f, 0x0000, 0x0000, 0x168d, 0x0000, 0x1683, 0x0000, 0x168a,
+	0x1687, 0x0000, 0x0000, 0x0000, 0x168d, 0x168a, 0x0000, 0x1685,
+	0x1685, 0x0000, 0x0000, 0x168d, 0x0000, 0x1685, 0x0000, 0x168b,
+	0x168b, 0x0000, 0x0000, 0x0000, 0x168d, 0x168b, 0x00a6, 0x0096,
+	0x0086, 0x6b42, 0x6c3e, 0x6888, 0x9055, 0x0904, 0x173f, 0x2d60,
+	0x6064, 0x90cc, 0x000f, 0x99c0, 0x168e, 0x9986, 0x0007, 0x0130,
+	0x9986, 0x000e, 0x0118, 0x9986, 0x000f, 0x1120, 0x608c, 0x9422,
+	0x6090, 0x931a, 0x2805, 0x9045, 0x1140, 0x0310, 0x0804, 0x173f,
+	0x6004, 0x9065, 0x0904, 0x173f, 0x0c18, 0x2805, 0x9005, 0x01a8,
+	0x9c68, 0xd99c, 0x1128, 0x6808, 0x9422, 0x680c, 0x931b, 0x0020,
+	0x6810, 0x9422, 0x6814, 0x931b, 0x0620, 0x2300, 0x9405, 0x0150,
+	0x8a51, 0x0904, 0x173f, 0x8840, 0x0c40, 0x6004, 0x9065, 0x0904,
+	0x173f, 0x0830, 0x8a51, 0x0904, 0x173f, 0x8840, 0x2805, 0x9005,
+	0x1158, 0x6004, 0x9065, 0x0904, 0x173f, 0x6064, 0x90cc, 0x000f,
+	0x99c0, 0x168e, 0x2805, 0x2040, 0x2b68, 0x6880, 0xc0fc, 0x6882,
+	0x0458, 0x8422, 0x8420, 0x831a, 0x9399, 0x0000, 0x00d6, 0x2b68,
+	0x6c2e, 0x6b32, 0x00de, 0xd99c, 0x1168, 0x6908, 0x2400, 0x9122,
+	0x690c, 0x2300, 0x911b, 0x0a0c, 0x0cf1, 0x6800, 0x9420, 0x6804,
+	0x9319, 0x0060, 0x6910, 0x2400, 0x9122, 0x6914, 0x2300, 0x911b,
+	0x0a0c, 0x0cf1, 0x6800, 0x9420, 0x6804, 0x9319, 0x2b68, 0x6c1e,
+	0x6b22, 0x6880, 0xc0fd, 0x6882, 0x2c00, 0x685a, 0x2800, 0x6812,
+	0x2a00, 0x6816, 0x000e, 0x000e, 0x000e, 0x9006, 0x0028, 0x008e,
+	0x009e, 0x00ae, 0x9085, 0x0001, 0x0005, 0x2001, 0x0005, 0x2004,
+	0x9084, 0x0007, 0x0002, 0x1753, 0x1543, 0x1754, 0x1755, 0x1758,
+	0x175b, 0x1760, 0x1763, 0x0005, 0x0005, 0x080c, 0x1543, 0x0005,
+	0x080c, 0x0ee8, 0x0005, 0x080c, 0x1543, 0x080c, 0x0ee8, 0x0005,
+	0x080c, 0x0ee8, 0x0005, 0x080c, 0x1543, 0x080c, 0x0ee8, 0x0005,
+	0x0126, 0x2091, 0x2600, 0x2079, 0x0200, 0x2071, 0x0260, 0x2069,
+	0x1100, 0x7817, 0x0000, 0x789b, 0x0814, 0x78a3, 0x0406, 0x789f,
+	0x0410, 0x2009, 0x013b, 0x200b, 0x0400, 0x781b, 0x0002, 0x783b,
+	0x001f, 0x7837, 0x0020, 0x7803, 0x1600, 0x012e, 0x0005, 0x2091,
+	0x2600, 0x781c, 0xd0a4, 0x190c, 0x18c8, 0x9084, 0x0006, 0x0002,
+	0x17a3, 0x1798, 0x5fe9, 0x179a, 0x179c, 0x179e, 0x17a0, 0x17a2,
+	0x080c, 0x0cf1, 0x080c, 0x0cf1, 0x0039, 0x0028, 0x0029, 0x0018,
+	0x0019, 0x0008, 0x0009, 0x0005, 0x0006, 0x0016, 0x0026, 0x080c,
+	0xae13, 0x7930, 0x9184, 0x0003, 0x0178, 0x2001, 0x12eb, 0x2004,
+	0x9005, 0x0130, 0x2001, 0x0133, 0x2004, 0x9005, 0x090c, 0x0cf1,
+	0x7803, 0x0040, 0x0804, 0x17fc, 0x9184, 0x0014, 0x01f0, 0x6a00,
+	0x9286, 0x0003, 0x1108, 0x00a0, 0x080c, 0x5745, 0x1178, 0x2001,
+	0x1290, 0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001, 0x9085,
+	0x0001, 0x080c, 0x5789, 0x080c, 0x5682, 0x0010, 0x080c, 0x45d6,
+	0x7803, 0x0010, 0x78a0, 0x78a2, 0x00f8, 0x9184, 0x1400, 0x0168,
+	0x00e6, 0x0036, 0x0046, 0x0056, 0x2071, 0x131c, 0x080c, 0x1337,
+	0x005e, 0x004e, 0x003e, 0x00ee, 0x0078, 0x9184, 0x0140, 0x0118,
+	0x7803, 0x0020, 0x0048, 0x9184, 0x8000, 0x0130, 0x080c, 0x205b,
+	0x7803, 0x0004, 0x7898, 0x789a, 0x002e, 0x001e, 0x000e, 0x0005,
+	0x0016, 0x0026, 0x0036, 0x0046, 0x00e6, 0x00f6, 0x2071, 0x1100,
+	0x7128, 0x2001, 0x1282, 0x2102, 0x2001, 0x128a, 0x2102, 0x2001,
+	0x013b, 0x2102, 0x2079, 0x0200, 0x9198, 0x0007, 0x831c, 0x831c,
+	0x831c, 0x2320, 0x9182, 0x0224, 0x1228, 0x2011, 0x0004, 0x8423,
+	0x8423, 0x0088, 0x9182, 0x02d4, 0x1228, 0x2011, 0x0003, 0x8403,
+	0x9420, 0x0048, 0x9182, 0x0444, 0x1220, 0x2011, 0x0002, 0x8423,
+	0x0010, 0x2011, 0x0001, 0x9482, 0x0110, 0x8002, 0x8020, 0x8301,
+	0x9402, 0x0110, 0x0208, 0x8321, 0x8217, 0x8203, 0x9405, 0x2001,
+	0x0201, 0x789e, 0x9198, 0x0007, 0x831c, 0x831c, 0x831c, 0x9398,
+	0x0003, 0x2320, 0x9182, 0x0204, 0x1228, 0x2011, 0x0004, 0x8423,
+	0x8423, 0x0088, 0x9182, 0x02b4, 0x1228, 0x2011, 0x0003, 0x8403,
+	0x9420, 0x0048, 0x9182, 0x041c, 0x1220, 0x2011, 0x0002, 0x8423,
+	0x0010, 0x2011, 0x0001, 0x9482, 0x010c, 0x8002, 0x8020, 0x8301,
+	0x9402, 0x0110, 0x0208, 0x8321, 0x8217, 0x8203, 0x9405, 0x2001,
+	0x0200, 0x78a2, 0x9198, 0x0007, 0x831c, 0x831c, 0x831c, 0x9398,
+	0x0005, 0x2320, 0x9182, 0x0204, 0x1230, 0x2011, 0x0008, 0x8423,
+	0x8423, 0x8423, 0x0488, 0x9182, 0x024c, 0x1240, 0x2011, 0x0007,
+	0x8403, 0x8003, 0x9400, 0x9400, 0x9420, 0x0430, 0x9182, 0x02bc,
+	0x1238, 0x2011, 0x0006, 0x8403, 0x8003, 0x9400, 0x9420, 0x00e0,
+	0x9182, 0x034c, 0x1230, 0x2011, 0x0005, 0x8403, 0x8003, 0x9420,
+	0x0098, 0x9182, 0x042c, 0x1228, 0x2011, 0x0004, 0x8423, 0x8423,
+	0x0058, 0x9182, 0x059c, 0x1228, 0x2011, 0x0003, 0x8403, 0x9420,
+	0x0018, 0x2011, 0x0002, 0x8423, 0x9482, 0x0228, 0x8002, 0x8020,
+	0x8301, 0x9402, 0x0110, 0x0208, 0x8321, 0x8217, 0x8203, 0x9405,
+	0x789a, 0x00fe, 0x00ee, 0x004e, 0x003e, 0x002e, 0x001e, 0x0005,
+	0x7938, 0x080c, 0x0cf1, 0x0126, 0x2091, 0x2800, 0x2061, 0x0100,
+	0x2071, 0x1100, 0x080c, 0x1f80, 0x6054, 0x8004, 0x8004, 0x8004,
+	0x8004, 0x9084, 0x000c, 0x6150, 0x918c, 0xfff3, 0x9105, 0x6052,
+	0x6050, 0x9084, 0xfbff, 0x9085, 0x2000, 0x6052, 0x2009, 0x12bd,
+	0x2011, 0x12be, 0x6358, 0x939c, 0x38f0, 0x2320, 0x080c, 0x1fc4,
+	0x1238, 0x939d, 0x4003, 0x94a5, 0x8603, 0x230a, 0x2412, 0x0030,
+	0x939d, 0x0203, 0x94a5, 0x8603, 0x230a, 0x2412, 0x9006, 0x080c,
+	0x1faf, 0x9006, 0x080c, 0x1f92, 0x20a9, 0x0012, 0x1d04, 0x1906,
+	0x2091, 0x6000, 0x1f04, 0x1906, 0x602f, 0x0100, 0x602f, 0x0000,
+	0x6050, 0x9085, 0x0400, 0x9084, 0xdfff, 0x6052, 0x6024, 0x6026,
+	0x080c, 0x1c83, 0x2009, 0x00ef, 0x6132, 0x6136, 0x080c, 0x1c93,
+	0x60e7, 0x0000, 0x61ea, 0x60e3, 0x0008, 0x604b, 0xf7f7, 0x6043,
+	0x0000, 0x602f, 0x0080, 0x602f, 0x0000, 0x6007, 0x049f, 0x60bb,
+	0x0000, 0x20a9, 0x0018, 0x60bf, 0x0000, 0x1f04, 0x1933, 0x60bb,
+	0x0000, 0x60bf, 0x0108, 0x60bf, 0x0012, 0x60bf, 0x0320, 0x60bf,
+	0x0018, 0x601b, 0x001e, 0x601f, 0x001e, 0x600f, 0x006b, 0x602b,
+	0x402f, 0x012e, 0x0005, 0x00f6, 0x2079, 0x0140, 0x78c3, 0x0080,
+	0x78c3, 0x0083, 0x78c3, 0x0000, 0x00fe, 0x0005, 0x2001, 0x1131,
+	0x2003, 0x0000, 0x2001, 0x1130, 0x2003, 0x0001, 0x0005, 0x0126,
+	0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x6124, 0x9184, 0x5e2c,
+	0x1118, 0x9184, 0x0007, 0x002a, 0x9195, 0x0004, 0x9284, 0x0007,
+	0x0002, 0x1993, 0x1979, 0x197c, 0x197f, 0x1984, 0x1986, 0x198a,
+	0x198e, 0x080c, 0x677e, 0x00b8, 0x080c, 0x684f, 0x00a0, 0x080c,
+	0x684f, 0x080c, 0x677e, 0x0078, 0x0099, 0x0068, 0x080c, 0x677e,
+	0x0079, 0x0048, 0x080c, 0x684f, 0x0059, 0x0028, 0x080c, 0x684f,
+	0x080c, 0x677e, 0x0029, 0x002e, 0x001e, 0x000e, 0x012e, 0x0005,
+	0x6124, 0xd19c, 0x1904, 0x1bbd, 0xd1f4, 0x0110, 0x080c, 0x0cf1,
+	0x080c, 0x5745, 0x0578, 0x7000, 0x9086, 0x0003, 0x0198, 0x6024,
+	0x9084, 0x1800, 0x0178, 0x080c, 0x576b, 0x0118, 0x080c, 0x5757,
+	0x1148, 0x6027, 0x0020, 0x6043, 0x0000, 0x2001, 0x128f, 0x2003,
+	0xaaaa, 0x0458, 0x080c, 0x576b, 0x15d0, 0x6024, 0x9084, 0x1800,
+	0x1108, 0x04a8, 0x2001, 0x128f, 0x2003, 0xaaaa, 0x2001, 0x1290,
+	0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001, 0x080c, 0x5682,
+	0x0804, 0x1bbd, 0xd1ac, 0x1518, 0x6024, 0xd0dc, 0x1170, 0xd0e4,
+	0x1188, 0xd0d4, 0x11a0, 0xd0cc, 0x0130, 0x7088, 0x9086, 0x0028,
+	0x1110, 0x080c, 0x58e5, 0x0804, 0x1bbd, 0x2001, 0x1290, 0x2003,
+	0x0000, 0x0048, 0x2001, 0x1290, 0x2003, 0x0002, 0x0020, 0x080c,
+	0x5857, 0x0804, 0x1bbd, 0x080c, 0x597e, 0x0804, 0x1bbd, 0xd1ac,
+	0x0904, 0x1af0, 0x080c, 0x5745, 0x11d8, 0x6027, 0x0020, 0x0006,
+	0x0026, 0x0036, 0x080c, 0x5761, 0x1170, 0x2001, 0x1290, 0x2003,
+	0x0001, 0x2001, 0x1100, 0x2003, 0x0001, 0x080c, 0x5682, 0x003e,
+	0x002e, 0x000e, 0x0005, 0x003e, 0x002e, 0x000e, 0x080c, 0x571c,
+	0x0016, 0x0046, 0x00c6, 0x644c, 0x9486, 0xf0f0, 0x1138, 0x2061,
+	0x0100, 0x644a, 0x6043, 0x0090, 0x6043, 0x0010, 0x74ca, 0x948c,
+	0xff00, 0x7034, 0xd084, 0x0178, 0x9186, 0xf800, 0x1160, 0x7038,
+	0xd084, 0x1148, 0xc085, 0x703a, 0x0036, 0x2418, 0x2011, 0x8016,
+	0x080c, 0x37dc, 0x003e, 0x9196, 0xff00, 0x05b8, 0x7050, 0x9084,
+	0x00ff, 0x810f, 0x9116, 0x0588, 0x7130, 0xd184, 0x1570, 0x2011,
+	0x1153, 0x2214, 0xd2ec, 0x0138, 0xc18d, 0x7132, 0x2011, 0x1153,
+	0x2214, 0xd2ac, 0x1510, 0x6240, 0x9294, 0x0010, 0x0130, 0x6248,
+	0x9294, 0xff00, 0x9296, 0xff00, 0x01c0, 0x7030, 0xd08c, 0x0904,
+	0x1ac6, 0x7034, 0xd08c, 0x1140, 0x2001, 0x110c, 0x200c, 0xd1ac,
+	0x1904, 0x1ac6, 0xc1ad, 0x2102, 0x0036, 0x73c8, 0x2011, 0x8013,
+	0x080c, 0x37dc, 0x003e, 0x0804, 0x1ac6, 0x7034, 0xd08c, 0x1140,
+	0x2001, 0x110c, 0x200c, 0xd1ac, 0x1904, 0x1ac6, 0xc1ad, 0x2102,
+	0x0036, 0x73c8, 0x2011, 0x8013, 0x080c, 0x37dc, 0x003e, 0x7130,
+	0xc185, 0x7132, 0x2011, 0x1153, 0x220c, 0xd1a4, 0x01f0, 0x0016,
+	0x2009, 0x0001, 0x2011, 0x0100, 0x080c, 0x66d5, 0x2019, 0x000e,
+	0x00c6, 0x2061, 0x0000, 0x080c, 0xaa50, 0x00ce, 0x9484, 0x00ff,
+	0x9080, 0x26c1, 0x200d, 0x918c, 0xff00, 0x810f, 0x8127, 0x9006,
+	0x2009, 0x000e, 0x080c, 0xaaca, 0x001e, 0xd1ac, 0x1148, 0x0016,
+	0x2009, 0x0000, 0x2019, 0x0004, 0x080c, 0x2582, 0x001e, 0x0070,
+	0x0156, 0x20a9, 0x007f, 0x2009, 0x0000, 0x080c, 0x4b58, 0x1110,
+	0x080c, 0x472d, 0x8108, 0x1f04, 0x1abd, 0x015e, 0x00ce, 0x004e,
+	0x2011, 0x0003, 0x080c, 0x79c2, 0x2011, 0x0002, 0x080c, 0x79cc,
+	0x080c, 0x78b3, 0x080c, 0x65cf, 0x0036, 0x2019, 0x0000, 0x080c,
+	0x7936, 0x003e, 0x60e3, 0x0000, 0x001e, 0x2001, 0x1100, 0x2014,
+	0x9296, 0x0004, 0x1128, 0xd19c, 0x1118, 0x6228, 0xc29d, 0x622a,
+	0x2003, 0x0001, 0x2001, 0x1122, 0x2003, 0x0000, 0x6027, 0x0020,
+	0xd194, 0x0904, 0x1bbd, 0x0016, 0x6220, 0xd2b4, 0x0904, 0x1b6e,
+	0x080c, 0x65cf, 0x080c, 0x7721, 0x6027, 0x0004, 0x00f6, 0x2019,
+	0x12e5, 0x2304, 0x907d, 0x05f0, 0x7804, 0x9086, 0x0032, 0x15d0,
+	0x00d6, 0x00c6, 0x00e6, 0x2069, 0x0140, 0x7810, 0x685e, 0x7808,
+	0x685a, 0x6043, 0x0002, 0x2001, 0x0003, 0x8001, 0x1df0, 0x6043,
+	0x0000, 0x2001, 0x003c, 0x8001, 0x1df0, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x2001, 0x001e, 0x8001, 0x0240, 0x20a9, 0x0009, 0x080c,
+	0x2036, 0x6904, 0xd1dc, 0x1128, 0x0cb0, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x080c, 0x6c56, 0x080c, 0x6d42, 0x7814, 0x2070, 0x7067,
+	0x0103, 0x2f60, 0x080c, 0x7f1e, 0x00ee, 0x00ce, 0x00de, 0x00fe,
+	0x001e, 0x0005, 0x00fe, 0x00d6, 0x2069, 0x0140, 0x6804, 0x9084,
+	0x4000, 0x0120, 0x6803, 0x1000, 0x6803, 0x0000, 0x00de, 0x00c6,
+	0x2061, 0x12dc, 0x6028, 0x909a, 0x00c8, 0x1238, 0x8000, 0x602a,
+	0x00ce, 0x080c, 0x76fd, 0x0804, 0x1bbc, 0x2061, 0x0100, 0x62c0,
+	0x080c, 0x7e9f, 0x2019, 0x12e5, 0x2304, 0x9065, 0x0120, 0x2009,
+	0x0027, 0x080c, 0x7f4e, 0x00ce, 0x0804, 0x1bbc, 0xd2bc, 0x0904,
+	0x1bbc, 0x080c, 0x65dc, 0x6014, 0x9084, 0x1984, 0x9085, 0x0010,
+	0x6016, 0x6027, 0x0004, 0x00d6, 0x2069, 0x0140, 0x6804, 0x9084,
+	0x4000, 0x0120, 0x6803, 0x1000, 0x6803, 0x0000, 0x00de, 0x00c6,
+	0x2061, 0x12dc, 0x6044, 0x909a, 0x00c8, 0x12f0, 0x8000, 0x6046,
+	0x603c, 0x00ce, 0x9005, 0x0540, 0x2009, 0x07d0, 0x080c, 0x65d4,
+	0x9080, 0x0008, 0x2004, 0x9086, 0x0006, 0x1138, 0x6114, 0x918c,
+	0x1984, 0x918d, 0x0012, 0x6116, 0x00b8, 0x6114, 0x918c, 0x1984,
+	0x918d, 0x0016, 0x6116, 0x0080, 0x0036, 0x2019, 0x0001, 0x080c,
+	0x7936, 0x003e, 0x2019, 0x12eb, 0x2304, 0x9065, 0x0120, 0x2009,
+	0x004f, 0x080c, 0x7f4e, 0x00ce, 0x001e, 0xd19c, 0x0904, 0x1c32,
+	0x0016, 0x0156, 0x6027, 0x0008, 0x6050, 0x9085, 0x0040, 0x6052,
+	0x6050, 0x9084, 0xfbcf, 0x6052, 0x080c, 0x2055, 0x9085, 0x2000,
+	0x6052, 0x20a9, 0x0012, 0x1d04, 0x1bd3, 0x2091, 0x6000, 0x1f04,
+	0x1bd3, 0x6050, 0x9085, 0x0400, 0x9084, 0xdfbf, 0x6052, 0x20a9,
+	0x0028, 0xa001, 0x1f04, 0x1be1, 0x6150, 0x9185, 0x1400, 0x6052,
+	0x20a9, 0x0366, 0x1d04, 0x1bea, 0x2091, 0x6000, 0x6020, 0xd09c,
+	0x1130, 0x015e, 0x6152, 0x001e, 0x6027, 0x0008, 0x04d8, 0x080c,
+	0x201f, 0x1f04, 0x1bea, 0x015e, 0x6152, 0x001e, 0x6027, 0x0008,
+	0x0016, 0x6028, 0xc09c, 0x602a, 0x2011, 0x0003, 0x080c, 0x79c2,
+	0x2011, 0x0002, 0x080c, 0x79cc, 0x080c, 0x78b3, 0x080c, 0x65cf,
+	0x0036, 0x2019, 0x0000, 0x080c, 0x7936, 0x003e, 0x60e3, 0x0000,
+	0x080c, 0xadf2, 0x080c, 0xae0d, 0x2001, 0x1172, 0x2004, 0xd0fc,
+	0x1120, 0x9085, 0x0001, 0x080c, 0x5789, 0x2001, 0x0140, 0x2003,
+	0x0000, 0x2001, 0x1100, 0x2003, 0x0004, 0x6027, 0x0008, 0x080c,
+	0x0b34, 0x001e, 0x918c, 0xffd0, 0x6126, 0x0005, 0x0006, 0x0016,
+	0x0026, 0x0036, 0x00e6, 0x00f6, 0x0126, 0x2091, 0x8000, 0x2071,
+	0x1100, 0x71c0, 0x70c2, 0x9116, 0x01e0, 0x81ff, 0x0128, 0x2011,
+	0x8011, 0x080c, 0x37dc, 0x00a8, 0x2011, 0x8012, 0x080c, 0x37dc,
+	0x2001, 0x1172, 0x2004, 0xd0fc, 0x1160, 0x00c6, 0x080c, 0x1cde,
+	0x2061, 0x0100, 0x2019, 0x0028, 0x2009, 0x0000, 0x080c, 0x2582,
+	0x00ce, 0x012e, 0x00fe, 0x00ee, 0x003e, 0x002e, 0x001e, 0x000e,
+	0x0005, 0x2028, 0x918c, 0x00ff, 0x2130, 0x9094, 0xff00, 0x1110,
+	0x81ff, 0x0118, 0x080c, 0x6215, 0x0038, 0x9080, 0x26c1, 0x200d,
+	0x918c, 0xff00, 0x810f, 0x9006, 0x0005, 0x9080, 0x26c1, 0x200d,
+	0x918c, 0x00ff, 0x0005, 0x00d6, 0x2069, 0x0140, 0x2001, 0x1114,
+	0x2003, 0x00ef, 0x20a9, 0x0010, 0x9006, 0x6852, 0x6856, 0x1f04,
+	0x1c8e, 0x00de, 0x0005, 0x0006, 0x00d6, 0x0026, 0x2069, 0x0140,
+	0x2001, 0x1114, 0x2102, 0x8114, 0x8214, 0x8214, 0x8214, 0x20a9,
+	0x0010, 0x6853, 0x0000, 0x9006, 0x82ff, 0x1128, 0x9184, 0x000f,
+	0x9080, 0xb1a7, 0x2005, 0x6856, 0x8211, 0x1f04, 0x1ca3, 0x002e,
+	0x00de, 0x000e, 0x0005, 0x00c6, 0x2061, 0x1100, 0x6030, 0x0110,
+	0xc09d, 0x0008, 0xc09c, 0x6032, 0x00ce, 0x0005, 0x0156, 0x00d6,
+	0x0026, 0x0016, 0x0006, 0x2069, 0x0140, 0x6980, 0x9116, 0x0180,
+	0x9112, 0x1230, 0x8212, 0x8210, 0x22a8, 0x2001, 0x0402, 0x0018,
+	0x22a8, 0x2001, 0x0404, 0x680e, 0x1f04, 0x1cd3, 0x680f, 0x0000,
+	0x000e, 0x001e, 0x002e, 0x00de, 0x015e, 0x0005, 0x2001, 0x1153,
+	0x2004, 0xd0c4, 0x0150, 0xd0a4, 0x0140, 0x9006, 0x0046, 0x2020,
+	0x2009, 0x002e, 0x080c, 0xaaca, 0x004e, 0x0005, 0x00f6, 0x0016,
+	0x0026, 0x2079, 0x0140, 0x78c4, 0xd0dc, 0x0904, 0x1d51, 0x2009,
+	0x0100, 0x210c, 0x918a, 0x0007, 0x0610, 0x9084, 0x0700, 0x908e,
+	0x0600, 0x1128, 0x2011, 0x4000, 0x2009, 0x0000, 0x0400, 0x908e,
+	0x0500, 0x1128, 0x2011, 0x8000, 0x2009, 0x0000, 0x00c0, 0x908e,
+	0x0400, 0x1128, 0x2011, 0x0000, 0x2009, 0x0001, 0x0080, 0x908e,
+	0x0300, 0x15b8, 0x2011, 0x0000, 0x2009, 0x0002, 0x0040, 0x9084,
+	0x0700, 0x908e, 0x0300, 0x1568, 0x2011, 0x0030, 0x0038, 0x2300,
+	0x9080, 0x0020, 0x2018, 0x2300, 0x080c, 0x66ff, 0x2200, 0x8007,
+	0x9085, 0x004c, 0x78c2, 0x2009, 0x0227, 0x210c, 0x810f, 0x918c,
+	0x00ff, 0x810c, 0x2200, 0x9100, 0x2009, 0x0226, 0x210c, 0x810f,
+	0x918c, 0x00ff, 0x810c, 0x9100, 0x2009, 0x0138, 0x200a, 0x080c,
+	0x5745, 0x1118, 0x2009, 0x1280, 0x200a, 0x002e, 0x001e, 0x00fe,
+	0x0005, 0x78c3, 0x0000, 0x0cc8, 0x0126, 0x2091, 0x2800, 0x0006,
+	0x0016, 0x0026, 0x2001, 0x0170, 0x200c, 0x8000, 0x2014, 0x9184,
+	0x0003, 0x0110, 0x0804, 0x0cf1, 0x002e, 0x001e, 0x000e, 0x012e,
+	0x0005, 0x2001, 0x0171, 0x2004, 0xd0dc, 0x0168, 0x2001, 0x0170,
+	0x200c, 0x918c, 0x00ff, 0x918e, 0x004c, 0x1128, 0x200c, 0x918c,
+	0xff00, 0x810f, 0x0010, 0x2009, 0x0000, 0x2001, 0x0227, 0x2004,
+	0x8007, 0x9084, 0x00ff, 0x8004, 0x9108, 0x2001, 0x0226, 0x2004,
+	0x8007, 0x9084, 0x00ff, 0x8004, 0x9108, 0x0005, 0x0018, 0x000c,
+	0x0018, 0x0020, 0x1000, 0x0800, 0x1000, 0x1800, 0x0156, 0x0006,
+	0x0016, 0x0026, 0x00e6, 0x2001, 0x12b0, 0x2004, 0x908a, 0x0007,
+	0x1210, 0x004b, 0x0010, 0x080c, 0x0cf1, 0x00ee, 0x002e, 0x001e,
+	0x000e, 0x015e, 0x0005, 0x1db2, 0x1dd1, 0x1df6, 0x1df9, 0x1e23,
+	0x1e26, 0x1e29, 0x2001, 0x0001, 0x080c, 0x1c36, 0x080c, 0x201a,
+	0x2001, 0x12b2, 0x2003, 0x0000, 0x7828, 0x9084, 0xe1d7, 0x782a,
+	0x2001, 0x0000, 0x20a9, 0x0009, 0x080c, 0x1fd8, 0x2001, 0x12b0,
+	0x2003, 0x0006, 0x2009, 0x001e, 0x2011, 0x1e2a, 0x080c, 0x65e1,
+	0x0005, 0x2009, 0x12b5, 0x200b, 0x0000, 0x2001, 0x12ba, 0x2003,
+	0x0036, 0x2001, 0x12b9, 0x2003, 0x002a, 0x2001, 0x12b2, 0x2003,
+	0x0001, 0x2001, 0x0000, 0x080c, 0x1f92, 0x2001, 0xffff, 0x20a9,
+	0x0009, 0x080c, 0x1fd8, 0x2001, 0x12b0, 0x2003, 0x0006, 0x2009,
+	0x001e, 0x2011, 0x1e2a, 0x080c, 0x65e1, 0x0005, 0x080c, 0x0cf1,
+	0x0005, 0x2001, 0x12ba, 0x2003, 0x0036, 0x2001, 0x12b2, 0x2003,
+	0x0003, 0x7a38, 0x9294, 0x0005, 0x9296, 0x0004, 0x0118, 0x2001,
+	0x0000, 0x0010, 0x2001, 0x0001, 0x080c, 0x1f92, 0x2001, 0x12b6,
+	0x2003, 0x0000, 0x2001, 0xffff, 0x20a9, 0x0009, 0x080c, 0x1fd8,
+	0x2001, 0x12b0, 0x2003, 0x0006, 0x2009, 0x001e, 0x2011, 0x1e2a,
+	0x080c, 0x65e1, 0x0005, 0x080c, 0x0cf1, 0x0005, 0x080c, 0x0cf1,
+	0x0005, 0x0005, 0x0006, 0x0016, 0x0026, 0x00e6, 0x00f6, 0x0156,
+	0x0126, 0x2091, 0x8000, 0x2079, 0x0100, 0x2001, 0x12b2, 0x2004,
+	0x908a, 0x0007, 0x1210, 0x005b, 0x0010, 0x080c, 0x0cf1, 0x012e,
+	0x015e, 0x00fe, 0x00ee, 0x002e, 0x001e, 0x000e, 0x0005, 0x1e4e,
+	0x1e6e, 0x1eaf, 0x1edf, 0x1f03, 0x1f13, 0x1f16, 0x080c, 0x1fcc,
+	0x11b0, 0x7850, 0x9084, 0xefff, 0x7852, 0x2009, 0x12b8, 0x2104,
+	0x7a38, 0x9294, 0x0005, 0x9296, 0x0004, 0x0110, 0xc08d, 0x0008,
+	0xc085, 0x200a, 0x2001, 0x12b0, 0x2003, 0x0001, 0x0030, 0x080c,
+	0x1f3e, 0x2001, 0xffff, 0x080c, 0x1dc2, 0x0005, 0x080c, 0x1f19,
+	0x05e8, 0x2009, 0x12b9, 0x2104, 0x8001, 0x200a, 0x080c, 0x1fcc,
+	0x1178, 0x7850, 0x9084, 0xefff, 0x7852, 0x7a38, 0x9294, 0x0005,
+	0x9296, 0x0005, 0x0520, 0x2009, 0x12b8, 0x2104, 0xc085, 0x200a,
+	0x2009, 0x12b5, 0x2104, 0x8000, 0x200a, 0x9086, 0x0005, 0x0118,
+	0x080c, 0x1f22, 0x00c8, 0x200b, 0x0000, 0x7a38, 0x9294, 0x0006,
+	0x9296, 0x0004, 0x0118, 0x2001, 0x0000, 0x0010, 0x2001, 0x0001,
+	0x080c, 0x1faf, 0x2001, 0x12b2, 0x2003, 0x0002, 0x0028, 0x2001,
+	0x12b0, 0x2003, 0x0003, 0x0010, 0x080c, 0x1de5, 0x0005, 0x080c,
+	0x1f19, 0x0560, 0x2009, 0x12b9, 0x2104, 0x8001, 0x200a, 0x080c,
+	0x1fcc, 0x1168, 0x7850, 0x9084, 0xefff, 0x7852, 0x2001, 0x12b0,
+	0x2003, 0x0003, 0x2001, 0x12b1, 0x2003, 0x0000, 0x00b8, 0x2009,
+	0x12b9, 0x2104, 0x9005, 0x1118, 0x080c, 0x1f63, 0x0010, 0x080c,
+	0x1f30, 0x080c, 0x1f22, 0x2009, 0x12b5, 0x200b, 0x0000, 0x2001,
+	0x12b2, 0x2003, 0x0001, 0x080c, 0x1de5, 0x0000, 0x0005, 0x04c9,
+	0x0508, 0x080c, 0x1fcc, 0x11b8, 0x7850, 0x9084, 0xefff, 0x7852,
+	0x2009, 0x12b6, 0x2104, 0x8000, 0x200a, 0x9086, 0x0007, 0x0108,
+	0x0078, 0x2001, 0x12bb, 0x2003, 0x000a, 0x2009, 0x12b8, 0x2104,
+	0xc0fd, 0x200a, 0x0038, 0x0431, 0x2001, 0x12b2, 0x2003, 0x0004,
+	0x080c, 0x1e12, 0x0005, 0x00a9, 0x0168, 0x080c, 0x1fcc, 0x1138,
+	0x7850, 0x9084, 0xefff, 0x7852, 0x080c, 0x1dfd, 0x0018, 0x0091,
+	0x080c, 0x1e12, 0x0005, 0x080c, 0x0cf1, 0x0005, 0x080c, 0x0cf1,
+	0x0005, 0x2009, 0x12ba, 0x2104, 0x8001, 0x200a, 0x1110, 0x080c,
+	0x1f80, 0x0005, 0x7a38, 0x9294, 0x0005, 0x9296, 0x0005, 0x0118,
+	0x2001, 0x0000, 0x0010, 0x2001, 0x0001, 0x080c, 0x1faf, 0x0005,
+	0x7a38, 0x9294, 0x0006, 0x9296, 0x0006, 0x0118, 0x2001, 0x0000,
+	0x0010, 0x2001, 0x0001, 0x080c, 0x1f92, 0x0005, 0x2009, 0x12b5,
+	0x2104, 0x8000, 0x200a, 0x9086, 0x0005, 0x0108, 0x0070, 0x200b,
+	0x0000, 0x7a38, 0x9294, 0x0006, 0x9296, 0x0006, 0x0118, 0x2001,
+	0x0000, 0x0010, 0x2001, 0x0001, 0x04e9, 0x7a38, 0x9294, 0x0005,
+	0x9296, 0x0005, 0x0118, 0x2001, 0x0000, 0x0010, 0x2001, 0x0001,
+	0x080c, 0x1faf, 0x0005, 0x0086, 0x2001, 0x12b8, 0x2004, 0x9084,
+	0x7fff, 0x090c, 0x0cf1, 0x2009, 0x12b7, 0x2144, 0x8846, 0x280a,
+	0x9844, 0x0dd8, 0xd08c, 0x1120, 0xd084, 0x1128, 0x080c, 0x0cf1,
+	0x2001, 0x0000, 0x0010, 0x2001, 0x0001, 0x00a1, 0x008e, 0x0005,
+	0x0006, 0x0156, 0x2001, 0x12b0, 0x20a9, 0x0009, 0x2003, 0x0000,
+	0x8000, 0x1f04, 0x1f86, 0x2001, 0x12b7, 0x2003, 0x8000, 0x015e,
+	0x000e, 0x0005, 0x00f6, 0x2079, 0x0100, 0x9085, 0x0000, 0x0158,
+	0x7838, 0x9084, 0xfff9, 0x9085, 0x0004, 0x783a, 0x2009, 0x12bd,
+	0x210c, 0x795a, 0x0050, 0x7838, 0x9084, 0xfffb, 0x9085, 0x0006,
+	0x783a, 0x2009, 0x12be, 0x210c, 0x795a, 0x00fe, 0x0005, 0x00f6,
+	0x2079, 0x0100, 0x9085, 0x0000, 0x0138, 0x7838, 0x9084, 0xfffa,
+	0x9085, 0x0004, 0x783a, 0x0030, 0x7838, 0x9084, 0xfffb, 0x9085,
+	0x0005, 0x783a, 0x00fe, 0x0005, 0x0006, 0x2001, 0x0100, 0x2004,
+	0x9082, 0x0007, 0x000e, 0x0005, 0x0156, 0x20a9, 0x0064, 0x7820,
+	0x080c, 0x2055, 0xd09c, 0x1110, 0x1f04, 0x1fcf, 0x015e, 0x0005,
+	0x0126, 0x0016, 0x0006, 0x2091, 0x8000, 0x7850, 0x9085, 0x0040,
+	0x7852, 0x7850, 0x9084, 0xfbcf, 0x7852, 0x080c, 0x2055, 0x9085,
+	0x2000, 0x7852, 0x000e, 0x2008, 0x9186, 0x0000, 0x1118, 0x783b,
+	0x0007, 0x0090, 0x9186, 0x0001, 0x1118, 0x783b, 0x0006, 0x0060,
+	0x9186, 0x0002, 0x1118, 0x783b, 0x0005, 0x0030, 0x9186, 0x0003,
+	0x1118, 0x783b, 0x0004, 0x0000, 0x0006, 0x1d04, 0x2005, 0x2091,
+	0x6000, 0x1f04, 0x2005, 0x7850, 0x9085, 0x0400, 0x9084, 0xdfbf,
+	0x7852, 0x080c, 0x2055, 0x9085, 0x1000, 0x7852, 0x000e, 0x001e,
+	0x012e, 0x0005, 0x7850, 0x9084, 0xffcf, 0x7852, 0x0005, 0x0006,
+	0x0156, 0x00f6, 0x2079, 0x0100, 0x20a9, 0x000a, 0x7854, 0xd0ac,
+	0x1100, 0x7854, 0xd08c, 0x1110, 0x1f04, 0x2029, 0x00fe, 0x015e,
+	0x000e, 0x0005, 0x7820, 0x0409, 0xd09c, 0x0005, 0x1d04, 0x2036,
+	0x2091, 0x6000, 0x1f04, 0x2036, 0x0005, 0x0006, 0x2001, 0x12bc,
+	0x2004, 0x9086, 0x0000, 0x000e, 0x0005, 0x0006, 0x2001, 0x12bc,
+	0x2004, 0x9086, 0x0001, 0x000e, 0x0005, 0x0006, 0x2001, 0x12bc,
+	0x2004, 0x9086, 0x0002, 0x000e, 0x0005, 0xa001, 0xa001, 0xa001,
+	0xa001, 0xa001, 0x0005, 0x2009, 0x0171, 0x2104, 0xd0dc, 0x0140,
+	0x2009, 0x0170, 0x2104, 0x200b, 0x0080, 0xa001, 0xa001, 0x200a,
+	0x0005, 0x0036, 0x0046, 0x2001, 0x0141, 0x200c, 0x918c, 0xff00,
+	0x9186, 0x2000, 0x0118, 0x9186, 0x0100, 0x1560, 0x2009, 0x017f,
+	0x200b, 0x00a2, 0x2009, 0x0169, 0x2019, 0x0160, 0x2324, 0x2011,
+	0x0003, 0x2104, 0x9084, 0x0007, 0x9086, 0x0003, 0x11b8, 0x2304,
+	0x9402, 0x02a0, 0x1d98, 0x8211, 0x1da0, 0x84ff, 0x0170, 0x2001,
+	0x0141, 0x200c, 0x918c, 0xff00, 0x9186, 0x0100, 0x0130, 0x2009,
+	0x110c, 0x2104, 0xc0dd, 0x200a, 0x0008, 0x0419, 0x2001, 0x017f,
+	0x2003, 0x0000, 0x004e, 0x003e, 0x0005, 0x2001, 0x110c, 0x2004,
+	0xd0dc, 0x01b0, 0x2001, 0x0160, 0x2004, 0x9005, 0x0140, 0x2001,
+	0x0141, 0x2004, 0x9084, 0xff00, 0x9086, 0x0100, 0x1148, 0x0126,
+	0x2091, 0x8000, 0x0016, 0x0026, 0x0021, 0x002e, 0x001e, 0x012e,
+	0x0005, 0x00c6, 0x2061, 0x0100, 0x6014, 0x0006, 0x2001, 0x0161,
+	0x2003, 0x0000, 0x6017, 0x0018, 0xa001, 0xa001, 0x602f, 0x0008,
+	0x6104, 0x918e, 0x0010, 0x6106, 0x918e, 0x0010, 0x6106, 0x6017,
+	0x0040, 0x2001, 0x0140, 0x2003, 0x1000, 0x2003, 0x0000, 0x001e,
+	0x9184, 0x0003, 0x01c0, 0x0036, 0x2019, 0x0141, 0x2304, 0x9084,
+	0xff00, 0x9086, 0x0800, 0x1dd0, 0x919c, 0xffe4, 0x9184, 0x0001,
+	0x0118, 0x9385, 0x0009, 0x6016, 0x9184, 0x0002, 0x0118, 0x9385,
+	0x0012, 0x6016, 0x003e, 0x2001, 0x110c, 0x200c, 0xc1dc, 0x2102,
+	0x00ce, 0x0005, 0x23cc, 0x23cc, 0x2192, 0x219e, 0x21aa, 0x21b6,
+	0x21c2, 0x21d0, 0x21de, 0x21ea, 0x21f6, 0x2204, 0x2212, 0x2220,
+	0x222e, 0x223e, 0x2250, 0x2250, 0x225c, 0x225c, 0x226a, 0x226a,
+	0x2288, 0x2288, 0x22a8, 0x22a8, 0x2278, 0x2278, 0x2298, 0x2298,
+	0x22b6, 0x22b6, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x22c8, 0x22c8, 0x22d4, 0x22d4, 0x22e2, 0x22e2,
+	0x22f0, 0x22f0, 0x2300, 0x2300, 0x230e, 0x230e, 0x231e, 0x231e,
+	0x232e, 0x232e, 0x2340, 0x2340, 0x234e, 0x234e, 0x235e, 0x235e,
+	0x2380, 0x2380, 0x23a2, 0x23a2, 0x236e, 0x236e, 0x2391, 0x2391,
+	0x23b1, 0x23b1, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e, 0x224e,
+	0x224e, 0x224e, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x195f, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x195f,
+	0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x1745, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1745,
+	0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x195f, 0x080c, 0x1745, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x195f, 0x080c, 0x1745, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1787,
+	0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x195f,
+	0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x195f, 0x080c, 0x1787,
+	0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x1745, 0x080c, 0x1787, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1745, 0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x195f,
+	0x080c, 0x1745, 0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x195f,
+	0x080c, 0x1745, 0x080c, 0x1787, 0x0804, 0x23c4, 0xa001, 0x0cf0,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x0fcc, 0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x195f, 0x080c, 0x0fcc,
+	0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x1745, 0x080c, 0x0fcc, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x195f, 0x080c, 0x0fcc, 0x080c, 0x1787, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x195f, 0x080c, 0x1745, 0x080c, 0x0fcc, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1745, 0x080c, 0x0fcc, 0x080c, 0x1787, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x0fcc, 0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x195f,
+	0x080c, 0x1745, 0x080c, 0x0fcc, 0x080c, 0x1787, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1d54, 0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1d54, 0x080c, 0x195f,
+	0x0804, 0x23c4, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x1d54, 0x080c, 0x1745, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1d54, 0x080c, 0x195f, 0x080c, 0x1745, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1d54, 0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1d54,
+	0x080c, 0x195f, 0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1d54,
+	0x080c, 0x1745, 0x080c, 0x1787, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1d54,
+	0x080c, 0x195f, 0x080c, 0x1745, 0x080c, 0x1787, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1d54, 0x080c, 0x0fcc, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1d54,
+	0x080c, 0x195f, 0x080c, 0x0fcc, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1d54,
+	0x080c, 0x1745, 0x080c, 0x0fcc, 0x0804, 0x23c4, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1d54,
+	0x080c, 0x195f, 0x080c, 0x0fcc, 0x080c, 0x1787, 0x0804, 0x23c4,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1d54, 0x080c, 0x195f, 0x080c, 0x1745, 0x080c, 0x0fcc,
+	0x0498, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146,
+	0x0156, 0x080c, 0x1d54, 0x080c, 0x1745, 0x080c, 0x0fcc, 0x080c,
+	0x1787, 0x0410, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x1d54, 0x080c, 0x0fcc, 0x080c, 0x1787,
+	0x0098, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146,
+	0x0156, 0x080c, 0x1d54, 0x080c, 0x195f, 0x080c, 0x1745, 0x080c,
+	0x0fcc, 0x080c, 0x1787, 0x0000, 0x015e, 0x014e, 0x013e, 0x01de,
+	0x01ce, 0x012e, 0x000e, 0x010e, 0x000d, 0x00c6, 0x0026, 0x0046,
+	0x2021, 0x0000, 0x080c, 0x4de0, 0x1904, 0x24aa, 0x72cc, 0x2001,
+	0x128f, 0x2004, 0x9005, 0x1110, 0xd29c, 0x0148, 0xd284, 0x1138,
+	0xd2bc, 0x1904, 0x24aa, 0x080c, 0x24ae, 0x0804, 0x24aa, 0xd2cc,
+	0x1904, 0x24aa, 0x080c, 0x5745, 0x1120, 0x709b, 0xffff, 0x0804,
+	0x24aa, 0xd294, 0x0120, 0x709b, 0xffff, 0x0804, 0x24aa, 0x2001,
+	0x1114, 0x203c, 0x7284, 0xd284, 0x0904, 0x244c, 0xd28c, 0x1904,
+	0x244c, 0x0036, 0x7398, 0x938e, 0xffff, 0x1110, 0x2019, 0x0001,
+	0x8314, 0x92e0, 0x1580, 0x2c04, 0x938c, 0x0001, 0x0120, 0x9084,
+	0xff00, 0x8007, 0x0010, 0x9084, 0x00ff, 0x970e, 0x0560, 0x908e,
+	0x0000, 0x0548, 0x908e, 0x00ff, 0x1150, 0x7230, 0xd284, 0x1538,
+	0x7284, 0xc28d, 0x7286, 0x709b, 0xffff, 0x003e, 0x0428, 0x2009,
+	0x0000, 0x080c, 0x1c69, 0x080c, 0x4b03, 0x11b8, 0x6004, 0x9084,
+	0x00ff, 0x9086, 0x0006, 0x1150, 0x7030, 0xd08c, 0x0118, 0x6000,
+	0xd0bc, 0x0120, 0x080c, 0x24c1, 0x0140, 0x0028, 0x080c, 0x25ec,
+	0x080c, 0x24ef, 0x0110, 0x8318, 0x0818, 0x739a, 0x0010, 0x709b,
+	0xffff, 0x003e, 0x0804, 0x24aa, 0x9780, 0x26c1, 0x203d, 0x97bc,
+	0xff00, 0x873f, 0x2041, 0x007e, 0x7098, 0x9096, 0xffff, 0x1120,
+	0x2009, 0x0000, 0x28a8, 0x0050, 0x9812, 0x0220, 0x2008, 0x9802,
+	0x20a8, 0x0020, 0x709b, 0xffff, 0x0804, 0x24aa, 0x2700, 0x0156,
+	0x0016, 0x9106, 0x05a0, 0xc484, 0x080c, 0x4b58, 0x0120, 0x080c,
+	0x4b03, 0x15a8, 0x0008, 0xc485, 0x6004, 0x9084, 0x00ff, 0x9086,
+	0x0006, 0x1130, 0x7030, 0xd08c, 0x01e8, 0x6000, 0xd0bc, 0x11d0,
+	0x7284, 0xd28c, 0x0188, 0x6004, 0x9084, 0x00ff, 0x9082, 0x0006,
+	0x02b0, 0xd484, 0x1118, 0x080c, 0x4b20, 0x0028, 0x080c, 0x2676,
+	0x0170, 0x080c, 0x26a3, 0x0058, 0x080c, 0x25ec, 0x080c, 0x24ef,
+	0x0170, 0x0028, 0x080c, 0x2676, 0x0110, 0x0419, 0x0140, 0x001e,
+	0x8108, 0x015e, 0x1f04, 0x2466, 0x709b, 0xffff, 0x0018, 0x001e,
+	0x015e, 0x719a, 0x004e, 0x002e, 0x00ce, 0x0005, 0x00c6, 0x0016,
+	0x709b, 0x0001, 0x2009, 0x007e, 0x080c, 0x4b03, 0x1138, 0x080c,
+	0x25ec, 0x04a9, 0x0118, 0x70cc, 0xc0bd, 0x70ce, 0x001e, 0x00ce,
+	0x0005, 0x0016, 0x0076, 0x00d6, 0x00c6, 0x2c68, 0x2001, 0x1157,
+	0x2004, 0x9084, 0x00ff, 0x6842, 0x080c, 0x984d, 0x01d8, 0x2d00,
+	0x6012, 0x080c, 0x99cc, 0x6023, 0x0001, 0x2001, 0x0000, 0x080c,
+	0x4aa1, 0x2001, 0x0000, 0x080c, 0x4ab3, 0x0126, 0x2091, 0x8000,
+	0x7094, 0x8000, 0x7096, 0x012e, 0x2009, 0x0004, 0x080c, 0x7f4e,
+	0x9085, 0x0001, 0x00ce, 0x00de, 0x007e, 0x001e, 0x0005, 0x0016,
+	0x0076, 0x00d6, 0x00c6, 0x2c68, 0x2001, 0x1157, 0x2004, 0x9084,
+	0x00ff, 0x6842, 0x080c, 0x984d, 0x0550, 0x2d00, 0x6012, 0x6800,
+	0xc0c4, 0x6802, 0x68a0, 0x9086, 0x007e, 0x0140, 0x6804, 0x9084,
+	0x00ff, 0x9086, 0x0006, 0x1110, 0x080c, 0x25ad, 0x080c, 0x99cc,
+	0x6023, 0x0001, 0x2001, 0x0000, 0x080c, 0x4aa1, 0x2001, 0x0002,
+	0x080c, 0x4ab3, 0x0126, 0x2091, 0x8000, 0x7094, 0x8000, 0x7096,
+	0x012e, 0x2009, 0x0002, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x00ce,
+	0x00de, 0x007e, 0x001e, 0x0005, 0x00c6, 0x0026, 0x2009, 0x0080,
+	0x080c, 0x4b03, 0x1120, 0x0031, 0x0110, 0x70d3, 0xffff, 0x002e,
+	0x00ce, 0x0005, 0x0016, 0x0076, 0x00d6, 0x00c6, 0x2c68, 0x080c,
+	0x7ec8, 0x01d8, 0x2d00, 0x6012, 0x080c, 0x99cc, 0x6023, 0x0001,
+	0x2001, 0x0000, 0x080c, 0x4aa1, 0x2001, 0x0002, 0x080c, 0x4ab3,
+	0x0126, 0x2091, 0x8000, 0x70d4, 0x8000, 0x70d6, 0x012e, 0x2009,
+	0x0002, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x00ce, 0x00de, 0x007e,
+	0x001e, 0x0005, 0x00c6, 0x00d6, 0x0126, 0x2091, 0x8000, 0x2009,
+	0x007f, 0x080c, 0x4b03, 0x1190, 0x2c68, 0x080c, 0x7ec8, 0x0170,
+	0x2d00, 0x6012, 0x6316, 0x6023, 0x0001, 0x620a, 0x080c, 0x99cc,
+	0x2009, 0x0022, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x012e, 0x00de,
+	0x00ce, 0x0005, 0x00e6, 0x00c6, 0x0066, 0x0036, 0x0026, 0x080c,
+	0x69d6, 0x080c, 0x697f, 0x080c, 0x89dd, 0x2130, 0x81ff, 0x0128,
+	0x20a9, 0x007e, 0x2009, 0x0000, 0x0020, 0x20a9, 0x007f, 0x2009,
+	0x0000, 0x0016, 0x080c, 0x4b58, 0x1110, 0x080c, 0x472d, 0x001e,
+	0x8108, 0x1f04, 0x2599, 0x86ff, 0x1110, 0x080c, 0x0a33, 0x002e,
+	0x003e, 0x006e, 0x00ce, 0x00ee, 0x0005, 0x00e6, 0x00c6, 0x0036,
+	0x0026, 0x0016, 0x6210, 0x2270, 0x72a0, 0x0026, 0x2019, 0x0029,
+	0x080c, 0x69ca, 0x0076, 0x2039, 0x0000, 0x080c, 0x68fe, 0x2c08,
+	0x080c, 0xa85f, 0x007e, 0x001e, 0x2e60, 0x6210, 0x6314, 0x080c,
+	0x472d, 0x6212, 0x6316, 0x001e, 0x002e, 0x003e, 0x00ce, 0x00ee,
+	0x0005, 0x00e6, 0x0006, 0x6010, 0x9080, 0x0028, 0x2004, 0x9086,
+	0x0080, 0x0150, 0x2071, 0x1100, 0x7094, 0x9005, 0x0110, 0x8001,
+	0x7096, 0x000e, 0x00ee, 0x0005, 0x2071, 0x1100, 0x70d4, 0x9005,
+	0x0dc0, 0x8001, 0x70d6, 0x0ca8, 0x6000, 0xc08c, 0x6002, 0x0005,
+	0x00f6, 0x00e6, 0x00c6, 0x0036, 0x0026, 0x0016, 0x0156, 0x2178,
+	0x81ff, 0x1118, 0x20a9, 0x0001, 0x0098, 0x2001, 0x1153, 0x2004,
+	0xd0c4, 0x0150, 0xd0a4, 0x0140, 0x9006, 0x0046, 0x2020, 0x2009,
+	0x002d, 0x080c, 0xaaca, 0x004e, 0x20a9, 0x00ff, 0x2011, 0x0000,
+	0x0026, 0x928e, 0x007e, 0x0904, 0x2655, 0x928e, 0x007f, 0x05e8,
+	0x928e, 0x0080, 0x05d0, 0x9288, 0x1000, 0x210c, 0x81ff, 0x05a8,
+	0x8fff, 0x1148, 0x2001, 0x12ae, 0x0006, 0x2003, 0x0001, 0x04c9,
+	0x000e, 0x2003, 0x0000, 0x00c6, 0x2160, 0x2001, 0x0001, 0x080c,
+	0x4dea, 0x00ce, 0x2019, 0x0029, 0x080c, 0x69ca, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x68fe, 0x00c6, 0x0026, 0x2160, 0x6204, 0x9294,
+	0x00ff, 0x9286, 0x0006, 0x1118, 0x6007, 0x0404, 0x0028, 0x2001,
+	0x0004, 0x8007, 0x9215, 0x6206, 0x002e, 0x00ce, 0x0016, 0x2c08,
+	0x080c, 0xa85f, 0x001e, 0x007e, 0x2160, 0x002e, 0x8210, 0x1f04,
+	0x2610, 0x015e, 0x001e, 0x002e, 0x003e, 0x00ce, 0x00ee, 0x00fe,
+	0x0005, 0x0046, 0x0026, 0x0016, 0x2001, 0x1153, 0x2004, 0xd0c4,
+	0x0148, 0xd0a4, 0x0138, 0x9006, 0x2220, 0x8427, 0x2009, 0x0029,
+	0x080c, 0xaaca, 0x001e, 0x002e, 0x004e, 0x0005, 0x0016, 0x0026,
+	0x0036, 0x00c6, 0x7284, 0x82ff, 0x01f8, 0x2011, 0x1153, 0x2214,
+	0xd2ac, 0x11d0, 0x2100, 0x080c, 0x1c7d, 0x81ff, 0x01b8, 0x2019,
+	0x0001, 0x8314, 0x92e0, 0x1580, 0x2c04, 0xd384, 0x0120, 0x9084,
+	0xff00, 0x8007, 0x0010, 0x9084, 0x00ff, 0x9116, 0x0138, 0x9096,
+	0x00ff, 0x0110, 0x8318, 0x0c68, 0x9085, 0x0001, 0x00ce, 0x003e,
+	0x002e, 0x001e, 0x0005, 0x0016, 0x00c6, 0x0126, 0x2091, 0x8000,
+	0x9180, 0x1000, 0x2004, 0x9065, 0x0158, 0x0016, 0x00c6, 0x2061,
+	0x135e, 0x001e, 0x6112, 0x080c, 0x25ad, 0x001e, 0x080c, 0x4b20,
+	0x012e, 0x00ce, 0x001e, 0x0005, 0x2001, 0x1133, 0x2004, 0xd0cc,
+	0x0005, 0x7eef, 0x7de8, 0x7ce4, 0x80e2, 0x7be1, 0x80e0, 0x80dc,
+	0x80da, 0x7ad9, 0x80d6, 0x80d5, 0x80d4, 0x80d3, 0x80d2, 0x80d1,
+	0x79ce, 0x78cd, 0x80cc, 0x80cb, 0x80ca, 0x80c9, 0x80c7, 0x80c6,
+	0x77c5, 0x76c3, 0x80bc, 0x80ba, 0x75b9, 0x80b6, 0x74b5, 0x73b4,
+	0x72b3, 0x80b2, 0x80b1, 0x80ae, 0x71ad, 0x80ac, 0x70ab, 0x6faa,
+	0x6ea9, 0x80a7, 0x6da6, 0x6ca5, 0x6ba3, 0x6a9f, 0x699e, 0x689d,
+	0x809b, 0x8098, 0x6797, 0x6690, 0x658f, 0x6488, 0x6384, 0x6282,
+	0x8081, 0x8080, 0x617c, 0x607a, 0x8079, 0x5f76, 0x8075, 0x8074,
+	0x8073, 0x8072, 0x8071, 0x806e, 0x5e6d, 0x806c, 0x5d6b, 0x5c6a,
+	0x5b69, 0x8067, 0x5a66, 0x5965, 0x5863, 0x575c, 0x565a, 0x5559,
+	0x8056, 0x8055, 0x5454, 0x5353, 0x5252, 0x5151, 0x504e, 0x4f4d,
+	0x804c, 0x804b, 0x4e4a, 0x4d49, 0x8047, 0x4c46, 0x8045, 0x8043,
+	0x803c, 0x803a, 0x8039, 0x8036, 0x4b35, 0x8034, 0x4a33, 0x4932,
+	0x4831, 0x802e, 0x472d, 0x462c, 0x452b, 0x442a, 0x4329, 0x4227,
+	0x8026, 0x8025, 0x4123, 0x401f, 0x3f1e, 0x3e1d, 0x3d1b, 0x3c18,
+	0x8017, 0x8010, 0x3b0f, 0x3a08, 0x8004, 0x3902, 0x8001, 0x8000,
+	0x8000, 0x3800, 0x3700, 0x3600, 0x8000, 0x3500, 0x8000, 0x8000,
+	0x8000, 0x3400, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x3300, 0x3200, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x3100, 0x3000, 0x8000, 0x8000, 0x2f00, 0x8000, 0x2e00, 0x2d00,
+	0x2c00, 0x8000, 0x8000, 0x8000, 0x2b00, 0x8000, 0x2a00, 0x2900,
+	0x2800, 0x8000, 0x2700, 0x2600, 0x2500, 0x2400, 0x2300, 0x2200,
+	0x8000, 0x8000, 0x2100, 0x2000, 0x1f00, 0x1e00, 0x1d00, 0x1c00,
+	0x8000, 0x8000, 0x1b00, 0x1a00, 0x8000, 0x1900, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x1800, 0x8000, 0x1700, 0x1600,
+	0x1500, 0x8000, 0x1400, 0x1300, 0x1200, 0x1100, 0x1000, 0x0f00,
+	0x8000, 0x8000, 0x0e00, 0x0d00, 0x0c00, 0x0b00, 0x0a00, 0x0900,
+	0x8000, 0x8000, 0x0800, 0x0700, 0x8000, 0x0600, 0x8000, 0x8000,
+	0x8000, 0x0500, 0x0400, 0x0300, 0x8000, 0x0200, 0x8000, 0x8000,
+	0x8000, 0x0100, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x0000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x2071, 0x1193, 0x7003, 0x0002, 0x9006, 0x7012, 0x7016,
+	0x703a, 0x703e, 0x7033, 0x11a3, 0x7037, 0x11a3, 0x7007, 0x0001,
+	0x2061, 0x11e3, 0x6003, 0x0002, 0x0005, 0x1004, 0x27e4, 0x0e04,
+	0x27e4, 0x2071, 0x1193, 0x2b78, 0x2a60, 0x7880, 0x908e, 0x0069,
+	0x1904, 0x28cc, 0x0804, 0x2860, 0x0005, 0x2071, 0x1193, 0x7004,
+	0x0002, 0x27ed, 0x27ee, 0x27f5, 0x2806, 0x0005, 0x1004, 0x27f4,
+	0x0e04, 0x27f4, 0x2b78, 0x00e8, 0x0005, 0x2b78, 0x2061, 0x11e3,
+	0x6008, 0x908e, 0x0100, 0x0128, 0x9086, 0x0200, 0x0904, 0x28c6,
+	0x0005, 0x7014, 0x2068, 0x2a60, 0x7018, 0x0807, 0x7010, 0x2068,
+	0x6864, 0x9086, 0x0103, 0x0108, 0x0005, 0x2a60, 0x2b78, 0x7018,
+	0x0807, 0x2a60, 0x7880, 0x908a, 0x0040, 0x1210, 0x61c0, 0x0042,
+	0x2100, 0x908a, 0x003f, 0x1a04, 0x28c3, 0x61c0, 0x0804, 0x2860,
+	0x28a2, 0x28d2, 0x28dc, 0x28e0, 0x28ea, 0x28f0, 0x28f4, 0x2904,
+	0x2907, 0x2911, 0x2916, 0x291b, 0x2926, 0x2931, 0x2940, 0x294f,
+	0x295d, 0x2974, 0x298f, 0x2a10, 0x2a15, 0x2a3e, 0x2a8b, 0x2a9c,
+	0x2aba, 0x28c3, 0x28c3, 0x28c3, 0x2af1, 0x2b10, 0x2b19, 0x2b4c,
+	0x2b52, 0x28c3, 0x2b7b, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3,
+	0x2b86, 0x2b90, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3,
+	0x28c3, 0x28c3, 0x2b98, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3,
+	0x2bb5, 0x2bdb, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3,
+	0x0002, 0x2c05, 0x2c59, 0x2cb4, 0x2cc7, 0x28c3, 0x2ce1, 0x3102,
+	0x3b4e, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x28c3,
+	0x28c3, 0x2911, 0x2916, 0x3104, 0x28c3, 0x3116, 0x3bde, 0x3c39,
+	0x3c9f, 0x28c3, 0x3d00, 0x3d2a, 0x3d4f, 0x3e32, 0x3d81, 0x3ddc,
+	0x28c3, 0x311a, 0x32a9, 0x32bf, 0x32dd, 0x3342, 0x33a8, 0x33b3,
+	0x33ea, 0x33f9, 0x3408, 0x340b, 0x3433, 0x3486, 0x3502, 0x350f,
+	0x3612, 0x3732, 0x375b, 0x3856, 0x3878, 0x3884, 0x38bd, 0x398a,
+	0x28c3, 0x28c3, 0x28c3, 0x28c3, 0x39f2, 0x3a0d, 0x3a85, 0x3b3f,
+	0x713c, 0x0000, 0x2021, 0x4000, 0x080c, 0x37b8, 0x0126, 0x2091,
+	0x8000, 0x0e04, 0x28ac, 0x0010, 0x012e, 0x0cc0, 0x7c36, 0x9486,
+	0x4000, 0x0118, 0x7833, 0x0011, 0x0010, 0x7833, 0x0010, 0x7c82,
+	0x7986, 0x7a8a, 0x7b8e, 0x2091, 0x4080, 0x7007, 0x0001, 0x2091,
+	0x5000, 0x012e, 0x0005, 0x2021, 0x4001, 0x08f0, 0x2021, 0x4002,
+	0x08d8, 0x2021, 0x4003, 0x08c0, 0x2021, 0x4005, 0x08a8, 0x2021,
+	0x4006, 0x0890, 0x2039, 0x0001, 0x902e, 0x2520, 0x7b88, 0x7a8c,
+	0x7884, 0x7990, 0x0804, 0x37c5, 0x7883, 0x0004, 0x7884, 0x0807,
+	0x2039, 0x0001, 0x902e, 0x2520, 0x7b88, 0x7a8c, 0x7884, 0x7990,
+	0x0804, 0x37c8, 0x7984, 0x7888, 0x2114, 0x200a, 0x0804, 0x28a2,
+	0x7984, 0x2114, 0x0804, 0x28a2, 0x20e1, 0x0000, 0x2099, 0x0021,
+	0x20e9, 0x0000, 0x20a1, 0x0021, 0x20a9, 0x001f, 0x4003, 0x7984,
+	0x7a88, 0x7b8c, 0x0804, 0x28a2, 0x7884, 0x2060, 0x04d8, 0x2009,
+	0x0003, 0x2011, 0x0000, 0x2019, 0x0018, 0x789b, 0x0017, 0x0804,
+	0x28a2, 0x2039, 0x0001, 0x7d98, 0x7c9c, 0x0800, 0x2039, 0x0001,
+	0x7d98, 0x7c9c, 0x0848, 0x79a0, 0x9182, 0x0040, 0x0210, 0x0804,
+	0x28cf, 0x2138, 0x7d98, 0x7c9c, 0x0804, 0x28d6, 0x79a0, 0x9182,
+	0x0040, 0x0210, 0x0804, 0x28cf, 0x2138, 0x7d98, 0x7c9c, 0x0804,
+	0x28e4, 0x79a0, 0x9182, 0x0040, 0x0210, 0x0804, 0x28cf, 0x21e8,
+	0x7984, 0x7888, 0x20a9, 0x0001, 0x21a0, 0x4004, 0x0804, 0x28a2,
+	0x2061, 0x0800, 0xe10c, 0x9006, 0x2c15, 0x9200, 0x8c60, 0x8109,
+	0x1dd8, 0x2010, 0x9005, 0x0904, 0x28a2, 0x0804, 0x28c9, 0x79a0,
+	0x9182, 0x0040, 0x0210, 0x0804, 0x28cf, 0x21e0, 0x20a9, 0x0001,
+	0x7984, 0x2198, 0x4012, 0x0804, 0x28a2, 0x2069, 0x1152, 0x7884,
+	0x7990, 0x911a, 0x1a04, 0x28cf, 0x8019, 0x0904, 0x28cf, 0x684a,
+	0x6942, 0x788c, 0x6852, 0x7888, 0x6856, 0x9006, 0x685a, 0x685e,
+	0x080c, 0x5a12, 0x0804, 0x28a2, 0x2069, 0x1152, 0x7884, 0x7994,
+	0x911a, 0x1a04, 0x28cf, 0x8019, 0x0904, 0x28cf, 0x684e, 0x6946,
+	0x788c, 0x6862, 0x7888, 0x6866, 0x9006, 0x686a, 0x686e, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x4e87, 0x012e, 0x0804, 0x28a2, 0x902e,
+	0x2520, 0x81ff, 0x1904, 0x28cc, 0x7984, 0x7b88, 0x7a8c, 0x20a9,
+	0x0005, 0x20e9, 0x0001, 0x20a1, 0x119a, 0x4101, 0x080c, 0x3784,
+	0x0904, 0x28cc, 0x2009, 0x0020, 0x2039, 0x0001, 0x080c, 0x37c5,
+	0x701b, 0x29ab, 0x0005, 0x6864, 0x2008, 0x9084, 0x00ff, 0x9096,
+	0x0011, 0x0120, 0x9096, 0x0019, 0x1904, 0x28cc, 0x810f, 0x918c,
+	0x00ff, 0x0904, 0x28cc, 0x710e, 0x700c, 0x8001, 0x0538, 0x700e,
+	0x080c, 0x3784, 0x0904, 0x28cc, 0x2009, 0x0020, 0x2061, 0x11e3,
+	0x6228, 0x632c, 0x6430, 0x6534, 0x9290, 0x0040, 0x9399, 0x0000,
+	0x94a1, 0x0000, 0x95a9, 0x0000, 0x2039, 0x0001, 0x080c, 0x37c5,
+	0x701b, 0x29db, 0x0005, 0x6864, 0x9084, 0x00ff, 0x9096, 0x0002,
+	0x0120, 0x9096, 0x000a, 0x1904, 0x28cc, 0x08b0, 0x7010, 0x2068,
+	0x6868, 0xc0fd, 0x686a, 0x080c, 0x4a18, 0x1128, 0x7007, 0x0003,
+	0x701b, 0x29f5, 0x0005, 0x080c, 0x52a0, 0x0126, 0x2091, 0x8000,
+	0x20a9, 0x0005, 0x20e1, 0x0001, 0x2099, 0x119a, 0x400a, 0x2100,
+	0x9210, 0x9399, 0x0000, 0x94a1, 0x0000, 0x95a9, 0x0000, 0x9d80,
+	0x0019, 0x2009, 0x0020, 0x012e, 0x2039, 0x0001, 0x0804, 0x37c8,
+	0x61a8, 0x7884, 0x60aa, 0x0804, 0x28a2, 0x2091, 0x8000, 0x7837,
+	0x4000, 0x7833, 0x0010, 0x7883, 0x4000, 0x7887, 0x4953, 0x788b,
+	0x5020, 0x788f, 0x2020, 0x2009, 0x017f, 0x2104, 0x7892, 0x3f00,
+	0x7896, 0x2061, 0x0100, 0x6200, 0x2061, 0x0200, 0x603c, 0x8007,
+	0x9205, 0x789a, 0x2009, 0x04fd, 0x2104, 0x789e, 0x2091, 0x5000,
+	0x2091, 0x4080, 0x2071, 0x0080, 0x0804, 0x0427, 0x81ff, 0x1904,
+	0x28cc, 0x7984, 0x810f, 0x918c, 0x00ff, 0x080c, 0x4b58, 0x1904,
+	0x28cf, 0x7e98, 0x9684, 0x3fff, 0x9082, 0x4000, 0x0210, 0x0804,
+	0x28cf, 0x7c88, 0x7d8c, 0x080c, 0x4ca3, 0x080c, 0x4c75, 0x0000,
+	0x1518, 0x2061, 0x15c0, 0x0126, 0x2091, 0x8000, 0x6000, 0x9086,
+	0x0000, 0x0148, 0x6014, 0x906d, 0x0130, 0x686c, 0x9406, 0x1118,
+	0x6870, 0x9506, 0x0150, 0x012e, 0x9ce0, 0x0018, 0x2001, 0x1116,
+	0x2004, 0x9c02, 0x1a04, 0x28cc, 0x0c30, 0x080c, 0x92a4, 0x012e,
+	0x0904, 0x28cc, 0x0804, 0x28a2, 0x900e, 0x2001, 0x0005, 0x080c,
+	0x52a0, 0x0126, 0x2091, 0x8000, 0x080c, 0x9849, 0x080c, 0x50a5,
+	0x012e, 0x0804, 0x28a2, 0x81ff, 0x1904, 0x28cc, 0x080c, 0x3799,
+	0x0904, 0x28cf, 0x080c, 0x4c17, 0x0904, 0x28cc, 0x080c, 0x4ca9,
+	0x0904, 0x28cc, 0x0804, 0x28a2, 0x81ff, 0x1904, 0x28cc, 0x080c,
+	0x37a9, 0x0904, 0x28cf, 0x080c, 0x4cf1, 0x0904, 0x28cc, 0x2019,
+	0x0005, 0x080c, 0x4cc4, 0x0904, 0x28cc, 0x7888, 0x908a, 0x1000,
+	0x1a04, 0x28cf, 0x8003, 0x800b, 0x810b, 0x9108, 0x080c, 0x6567,
+	0x0804, 0x28a2, 0x0126, 0x2091, 0x8000, 0x81ff, 0x0118, 0x2009,
+	0x0001, 0x0448, 0x2029, 0x00ff, 0x644c, 0x2400, 0x9506, 0x01f0,
+	0x2508, 0x080c, 0x4b58, 0x11d0, 0x080c, 0x4cf1, 0x1128, 0x2009,
+	0x0002, 0x62b0, 0x2518, 0x00b8, 0x2019, 0x0004, 0x080c, 0x4cc4,
+	0x1118, 0x2009, 0x0006, 0x0078, 0x7884, 0x908a, 0x1000, 0x1270,
+	0x8003, 0x800b, 0x810b, 0x9108, 0x080c, 0x6567, 0x8529, 0x1ae8,
+	0x012e, 0x0804, 0x28a2, 0x012e, 0x0804, 0x28cc, 0x012e, 0x0804,
+	0x28cf, 0x080c, 0x3799, 0x0904, 0x28cf, 0x080c, 0x4c17, 0x0904,
+	0x28cc, 0x62a0, 0x2019, 0x0005, 0x00c6, 0x2061, 0x0000, 0x080c,
+	0x69ca, 0x0076, 0x2039, 0x0000, 0x080c, 0x68fe, 0x2009, 0x0000,
+	0x080c, 0xa85f, 0x007e, 0x00ce, 0x080c, 0x4ca3, 0x0804, 0x28a2,
+	0x080c, 0x3799, 0x0904, 0x28cf, 0x080c, 0x4ca3, 0x2208, 0x0804,
+	0x28a2, 0x0156, 0x00d6, 0x00e6, 0x2069, 0x1228, 0x6810, 0x6914,
+	0x910a, 0x1210, 0x2009, 0x0000, 0x6816, 0x2011, 0x0000, 0x2019,
+	0x0000, 0x20a9, 0x007e, 0x2069, 0x1000, 0x2d04, 0x9075, 0x0118,
+	0x704c, 0x0059, 0x9210, 0x8d68, 0x1f04, 0x2b2d, 0x2300, 0x9218,
+	0x00ee, 0x00de, 0x015e, 0x0804, 0x28a2, 0x00f6, 0x0016, 0x907d,
+	0x0140, 0x2001, 0x0000, 0x8000, 0x2f0c, 0x81ff, 0x0110, 0x2178,
+	0x0cd0, 0x001e, 0x00fe, 0x0005, 0x2069, 0x1228, 0x6910, 0x62ac,
+	0x0804, 0x28a2, 0x81ff, 0x1904, 0x28cc, 0x614c, 0x9190, 0x26c1,
+	0x2215, 0x9294, 0x00ff, 0x636c, 0x83ff, 0x0108, 0x6270, 0x67cc,
+	0xd79c, 0x0118, 0x2031, 0x0001, 0x0090, 0xd7ac, 0x0118, 0x2031,
+	0x0003, 0x0068, 0xd7a4, 0x0118, 0x2031, 0x0002, 0x0040, 0x080c,
+	0x5745, 0x1118, 0x2031, 0x0004, 0x0010, 0x2031, 0x0000, 0x7e9a,
+	0x7f9e, 0x0804, 0x28a2, 0x613c, 0x6240, 0x2019, 0x12a6, 0x231c,
+	0x2001, 0x12a7, 0x2004, 0x789a, 0x0804, 0x28a2, 0x0126, 0x2091,
+	0x8000, 0x6134, 0x9006, 0x2010, 0x2018, 0x012e, 0x0804, 0x28a2,
+	0x080c, 0x37a9, 0x0904, 0x28cf, 0x6244, 0x6338, 0x0804, 0x28a2,
+	0x613c, 0x6240, 0x7884, 0x603e, 0x7b88, 0x6342, 0x2069, 0x1152,
+	0x831f, 0x9305, 0x6816, 0x788c, 0x2069, 0x12a6, 0x2d1c, 0x206a,
+	0x7e98, 0x9682, 0x0014, 0x1210, 0x2031, 0x07d0, 0x2069, 0x12a7,
+	0x2d04, 0x266a, 0x789a, 0x0804, 0x28a2, 0x0126, 0x2091, 0x8000,
+	0x7884, 0x6036, 0xd0c4, 0x01a8, 0x00d6, 0x78a8, 0x2009, 0x12bd,
+	0x200a, 0x78ac, 0x2011, 0x12be, 0x2012, 0x2069, 0x0100, 0x6838,
+	0x9086, 0x0007, 0x1118, 0x2214, 0x6a5a, 0x0010, 0x210c, 0x695a,
+	0x00de, 0x7884, 0xd0b4, 0x0120, 0x3b00, 0x9084, 0xff3f, 0x20d8,
+	0x012e, 0x0804, 0x28a2, 0x7898, 0x9005, 0x01a8, 0x7888, 0x9025,
+	0x0904, 0x28cf, 0x788c, 0x902d, 0x0904, 0x28cf, 0x900e, 0x080c,
+	0x4b58, 0x1120, 0x6244, 0x6338, 0x6446, 0x653a, 0x9186, 0x00ff,
+	0x0190, 0x8108, 0x0ca0, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x7888,
+	0x900d, 0x0904, 0x28cf, 0x788c, 0x9005, 0x0904, 0x28cf, 0x6244,
+	0x6146, 0x6338, 0x603a, 0x0804, 0x28a2, 0x2001, 0x1100, 0x2004,
+	0x9086, 0x0003, 0x1904, 0x28cc, 0x00c6, 0x2061, 0x0100, 0x7984,
+	0x810f, 0x918c, 0x00ff, 0x9196, 0x00ff, 0x1130, 0x2001, 0x1114,
+	0x2004, 0x9085, 0xff00, 0x0078, 0x9182, 0x007f, 0x16a0, 0x9188,
+	0x26c1, 0x210d, 0x918c, 0x00ff, 0x2001, 0x1114, 0x2004, 0x9116,
+	0x0550, 0x810f, 0x9105, 0x0126, 0x2091, 0x8000, 0x0006, 0x080c,
+	0x7ec8, 0x000e, 0x01e0, 0x6012, 0x600b, 0xbc09, 0x6023, 0x0001,
+	0x080c, 0x3784, 0x01d8, 0x6867, 0x0000, 0x7007, 0x0003, 0x6833,
+	0x0000, 0x6868, 0xc0fd, 0x686a, 0x701b, 0x2cad, 0x2d00, 0x6016,
+	0x2009, 0x0032, 0x080c, 0x7f4e, 0x012e, 0x00ce, 0x0005, 0x012e,
+	0x00ce, 0x0804, 0x28cc, 0x00ce, 0x0804, 0x28cf, 0x080c, 0x7f1e,
+	0x0cb0, 0x2001, 0x1100, 0x2004, 0x9086, 0x0003, 0x1904, 0x28cc,
+	0x00c6, 0x2061, 0x0100, 0x7984, 0x810f, 0x918c, 0x00ff, 0x9196,
+	0x00ff, 0x1130, 0x2001, 0x1114, 0x2004, 0x9085, 0xff00, 0x0078,
+	0x9182, 0x007f, 0x16a0, 0x9188, 0x26c1, 0x210d, 0x918c, 0x00ff,
+	0x2001, 0x1114, 0x2004, 0x9116, 0x0550, 0x810f, 0x9105, 0x0126,
+	0x2091, 0x8000, 0x0006, 0x080c, 0x7ec8, 0x000e, 0x01e0, 0x6012,
+	0x600b, 0xbc05, 0x6023, 0x0001, 0x080c, 0x3784, 0x01d8, 0x6867,
+	0x0000, 0x7007, 0x0003, 0x6833, 0x0000, 0x6868, 0xc0fd, 0x686a,
+	0x701b, 0x2cad, 0x2d00, 0x6016, 0x2009, 0x0032, 0x080c, 0x7f4e,
+	0x012e, 0x00ce, 0x0005, 0x012e, 0x00ce, 0x0804, 0x28cc, 0x00ce,
+	0x0804, 0x28cf, 0x080c, 0x7f1e, 0x0cb0, 0x6830, 0x9086, 0x0100,
+	0x0904, 0x28cc, 0x0804, 0x28a2, 0x2061, 0x1329, 0x0126, 0x2091,
+	0x8000, 0x6000, 0xd084, 0x0140, 0x6104, 0x6208, 0x2019, 0x1111,
+	0x231c, 0x012e, 0x0804, 0x28a2, 0x012e, 0x0804, 0x28cf, 0x81ff,
+	0x1904, 0x28cc, 0x080c, 0x5745, 0x0904, 0x28cc, 0x0126, 0x2091,
+	0x8000, 0x6244, 0x6064, 0x9202, 0x0248, 0x9085, 0x0001, 0x080c,
+	0x1cb3, 0x080c, 0x4016, 0x012e, 0x0804, 0x28a2, 0x012e, 0x0804,
+	0x28cf, 0x0126, 0x2091, 0x8000, 0x81ff, 0x0148, 0x080c, 0x204d,
+	0x1130, 0x9006, 0x080c, 0x1faf, 0x9006, 0x080c, 0x1f92, 0x7884,
+	0x9084, 0x0007, 0x0002, 0x2cfe, 0x2d07, 0x2d10, 0x2cfb, 0x2cfb,
+	0x2cfb, 0x2cfb, 0x2cfb, 0x012e, 0x0804, 0x28cf, 0x2009, 0x0114,
+	0x2104, 0x9085, 0x0800, 0x200a, 0x080c, 0x2e61, 0x0080, 0x2009,
+	0x0114, 0x2104, 0x9085, 0x4000, 0x200a, 0x080c, 0x2e61, 0x0038,
+	0x81ff, 0x0128, 0x012e, 0x2021, 0x400b, 0x0804, 0x28a4, 0x0086,
+	0x0096, 0x00a6, 0x00b6, 0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x2009,
+	0x0101, 0x210c, 0x0016, 0x2001, 0x0032, 0x2034, 0x2001, 0x0033,
+	0x202c, 0x9006, 0x2048, 0x2050, 0x2058, 0x080c, 0x3098, 0x080c,
+	0x2ffe, 0x903e, 0x2720, 0x00f6, 0x00e6, 0x00c6, 0x2d60, 0x2071,
+	0x131f, 0x2079, 0x0090, 0x00d6, 0x2069, 0x0000, 0x6884, 0xd0b4,
+	0x0140, 0x2001, 0x0035, 0x2004, 0x780e, 0x2001, 0x0034, 0x2004,
+	0x780a, 0x00de, 0x2011, 0x0001, 0x080c, 0x2faa, 0x080c, 0x2faa,
+	0x00ce, 0x00ee, 0x00fe, 0x080c, 0x2f03, 0x080c, 0x2fd2, 0x080c,
+	0x2f4f, 0x080c, 0x2ec8, 0x080c, 0x2ef9, 0x00f6, 0x2079, 0x0100,
+	0x7824, 0xd0ac, 0x0130, 0x8b58, 0x080c, 0x2e43, 0x00fe, 0x0804,
+	0x2df2, 0x00fe, 0x080c, 0x2e39, 0x1150, 0x8948, 0x2001, 0x0032,
+	0x2602, 0x2001, 0x0033, 0x2502, 0x080c, 0x2e43, 0x0078, 0x87ff,
+	0x0138, 0x2001, 0x0201, 0x2004, 0x9005, 0x19b8, 0x8739, 0x0030,
+	0x2001, 0x131c, 0x2004, 0x9086, 0x0000, 0x1978, 0x2001, 0x034f,
+	0x2003, 0x00f6, 0x8631, 0x1208, 0x8529, 0x2500, 0x9605, 0x0904,
+	0x2df2, 0x7884, 0xd0bc, 0x0128, 0x2900, 0x9a05, 0x9b05, 0x1904,
+	0x2df2, 0x6013, 0x0019, 0x2001, 0x032a, 0x2003, 0x0004, 0x7884,
+	0xd0ac, 0x1148, 0x2001, 0x131c, 0x2003, 0x0003, 0x2001, 0x032a,
+	0x2003, 0x0009, 0x0040, 0x6017, 0x0001, 0x2001, 0x002d, 0x2004,
+	0x9005, 0x0108, 0x6016, 0x2c00, 0x605a, 0x2001, 0x0200, 0x2003,
+	0x0040, 0x2d00, 0x685a, 0x6813, 0x0019, 0x7884, 0xd0a4, 0x1180,
+	0x6817, 0x0000, 0x00c6, 0x20a9, 0x0004, 0x2061, 0x0090, 0x602b,
+	0x0008, 0x2001, 0x0203, 0x2004, 0x1f04, 0x2dc7, 0x00ce, 0x0040,
+	0x6817, 0x0001, 0x2001, 0x002c, 0x2004, 0x9005, 0x0108, 0x6816,
+	0x00f6, 0x00c6, 0x2079, 0x0100, 0x2061, 0x0090, 0x7827, 0x0002,
+	0x2001, 0x002a, 0x2004, 0x9084, 0xfff8, 0x601a, 0x0006, 0x2001,
+	0x002b, 0x2004, 0x601e, 0x78c6, 0x000e, 0x78ca, 0x00ce, 0x00fe,
+	0x0804, 0x2d33, 0x2001, 0x032a, 0x2003, 0x0004, 0x2061, 0x0100,
+	0x6027, 0x0002, 0x001e, 0x6106, 0x2011, 0x020d, 0x2013, 0x0020,
+	0x2001, 0x0004, 0x200c, 0x918c, 0xfffd, 0x2102, 0x080c, 0x0f8f,
+	0x7884, 0x9084, 0x0003, 0x9086, 0x0002, 0x01a0, 0x2001, 0x0200,
+	0x2003, 0x0028, 0x2001, 0x0227, 0x200c, 0x2102, 0x6050, 0x9084,
+	0xb7ef, 0x6052, 0x602f, 0x0000, 0x604b, 0xf7f7, 0x6043, 0x0090,
+	0x6043, 0x0010, 0x2908, 0x2a10, 0x2b18, 0x2b00, 0x9a05, 0x9905,
+	0x00fe, 0x00ee, 0x00de, 0x00ce, 0x00be, 0x00ae, 0x009e, 0x008e,
+	0x1118, 0x012e, 0x0804, 0x28a2, 0x012e, 0x2021, 0x400c, 0x0804,
+	0x28a4, 0x9085, 0x0001, 0x1d04, 0x2e42, 0x2091, 0x6000, 0x8420,
+	0x9486, 0x0064, 0x0005, 0x2001, 0x0105, 0x2003, 0x0010, 0x2001,
+	0x032a, 0x2003, 0x0004, 0x2001, 0x009a, 0x2003, 0x0004, 0x2001,
+	0x131c, 0x2003, 0x0000, 0x2001, 0x131f, 0x2003, 0x0000, 0x2001,
+	0x0200, 0x2003, 0x0048, 0x2001, 0x0227, 0x2024, 0x2402, 0x9026,
+	0x0005, 0x00f6, 0x2079, 0x0100, 0x2001, 0x1114, 0x200c, 0x7932,
+	0x7936, 0x080c, 0x1c93, 0x7850, 0x9084, 0xfbff, 0x9085, 0x0030,
+	0x7852, 0x2019, 0x01f4, 0x8319, 0x1df0, 0x9084, 0xffcf, 0x9085,
+	0x2000, 0x7852, 0x20a9, 0x0046, 0x1d04, 0x2e7c, 0x2091, 0x6000,
+	0x1f04, 0x2e7c, 0x7850, 0x9085, 0x0400, 0x9084, 0xdfff, 0x7852,
+	0x2001, 0x0021, 0x2004, 0x9084, 0x0003, 0x9086, 0x0001, 0x1120,
+	0x7850, 0x9084, 0xdfff, 0x7852, 0x784b, 0xf7f7, 0x7843, 0x0090,
+	0x7843, 0x0010, 0x20a9, 0x0028, 0xa001, 0x1f04, 0x2e9c, 0x7850,
+	0x9085, 0x1400, 0x7852, 0x2019, 0x61a8, 0x7854, 0xa001, 0xa001,
+	0xd08c, 0x1110, 0x8319, 0x1dc8, 0x7827, 0x0048, 0x7850, 0x9085,
+	0x0400, 0x7852, 0x7843, 0x0040, 0x2019, 0x01f4, 0xa001, 0xa001,
+	0x8319, 0x1de0, 0x2001, 0x0140, 0x2003, 0x0100, 0x7827, 0x0020,
+	0x7843, 0x0000, 0x2003, 0x0000, 0x7827, 0x0048, 0x00fe, 0x0005,
+	0x7884, 0xd0ac, 0x11c8, 0x00f6, 0x00e6, 0x2071, 0x131c, 0x2079,
+	0x0320, 0x2001, 0x0201, 0x2004, 0x9005, 0x0160, 0x7000, 0x9086,
+	0x0000, 0x1140, 0x0051, 0xd0bc, 0x0108, 0x8738, 0x7003, 0x0003,
+	0x782b, 0x0019, 0x00ee, 0x00fe, 0x0005, 0x78bc, 0x908c, 0x0070,
+	0x0178, 0x2009, 0x0032, 0x260a, 0x2009, 0x0033, 0x250a, 0xd0b4,
+	0x0108, 0x8a50, 0xd0ac, 0x0108, 0x8948, 0xd0a4, 0x0108, 0x8b58,
+	0x0005, 0x00f6, 0x2079, 0x0200, 0x781c, 0xd084, 0x0110, 0x7837,
+	0x0050, 0x00fe, 0x0005, 0x00e6, 0x2071, 0x0100, 0x70e3, 0x0005,
+	0x702c, 0x9085, 0x0002, 0x702e, 0x2009, 0x1114, 0x210c, 0x716e,
+	0x7063, 0x0100, 0x7166, 0x719e, 0x706b, 0x0000, 0x7073, 0x0809,
+	0x7077, 0x0008, 0x7078, 0x9080, 0x0100, 0x707a, 0x7080, 0x8000,
+	0x7082, 0x7087, 0xaaaa, 0x9006, 0x708a, 0x708e, 0x707e, 0x70d6,
+	0x70ab, 0x0036, 0x70af, 0x95d5, 0x7014, 0x9084, 0x1984, 0x9085,
+	0x0012, 0x7016, 0x080c, 0x2fd2, 0x00f6, 0x2071, 0x131c, 0x2079,
+	0x0320, 0x00d6, 0x2069, 0x0000, 0x6884, 0xd0b4, 0x0120, 0x689c,
+	0x780e, 0x6898, 0x780a, 0x00de, 0x2011, 0x0011, 0x080c, 0x2faa,
+	0x2011, 0x0001, 0x080c, 0x2faa, 0x00fe, 0x00ee, 0x0005, 0x00f6,
+	0x00e6, 0x2071, 0x131c, 0x2079, 0x0320, 0x792c, 0xd1fc, 0x0904,
+	0x2fa7, 0x782b, 0x0002, 0x9026, 0xd19c, 0x1904, 0x2fa3, 0x7000,
+	0x0002, 0x2fa7, 0x2f65, 0x2f89, 0x2fa3, 0xd1bc, 0x1150, 0xd1dc,
+	0x1150, 0x8001, 0x7002, 0x2011, 0x0001, 0x04e1, 0x05c0, 0x04d1,
+	0x04b0, 0x78bf, 0x0000, 0x7810, 0x7914, 0x782b, 0x0004, 0x7812,
+	0x7916, 0x2001, 0x0201, 0x200c, 0x81ff, 0x0de8, 0x080c, 0x2ee5,
+	0x2009, 0x0001, 0x78b8, 0xd0ec, 0x0110, 0x2009, 0x0011, 0x792a,
+	0x00f0, 0x8001, 0x7002, 0x9184, 0x0880, 0x1138, 0x782c, 0xd0fc,
+	0x1940, 0x2011, 0x0001, 0x00b1, 0x0090, 0x6010, 0x9092, 0x0004,
+	0x9086, 0x0015, 0x1120, 0x6000, 0x605a, 0x2011, 0x0031, 0x6212,
+	0xd1dc, 0x1988, 0x0870, 0x782b, 0x0004, 0x7003, 0x0000, 0x00ee,
+	0x00fe, 0x0005, 0x6014, 0x9005, 0x0520, 0x8001, 0x6016, 0x6058,
+	0x6110, 0x9140, 0x2804, 0x7802, 0x8840, 0x2804, 0x7806, 0x8840,
+	0x2804, 0x7812, 0x8840, 0x2804, 0x7816, 0x8840, 0x7a2a, 0x7000,
+	0x8000, 0x7002, 0x6058, 0x9802, 0x908a, 0x0029, 0x1138, 0x6058,
+	0x9080, 0x0001, 0x2004, 0x605a, 0x2001, 0x0019, 0x6012, 0x9085,
+	0x0001, 0x0005, 0x00f6, 0x00e6, 0x00c6, 0x2071, 0x131f, 0x2079,
+	0x0090, 0x792c, 0xd1fc, 0x01f0, 0x782b, 0x0002, 0x2d60, 0x9026,
+	0x7000, 0x0002, 0x2ffa, 0x2fe5, 0x2ff1, 0x8001, 0x7002, 0xd19c,
+	0x1188, 0x2011, 0x0001, 0x080c, 0x2faa, 0x0160, 0x080c, 0x2faa,
+	0x0048, 0x8001, 0x7002, 0x782c, 0xd0fc, 0x1d30, 0x2011, 0x0001,
+	0x080c, 0x2faa, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x00f6, 0x00e6,
+	0x00c6, 0x2061, 0x0200, 0x601b, 0x0004, 0x2061, 0x0100, 0x60cf,
+	0x0400, 0x6104, 0xc1ac, 0x6106, 0x2001, 0x002c, 0x2004, 0x9005,
+	0x01f8, 0x2038, 0x2001, 0x002e, 0x2024, 0x2001, 0x002f, 0x201c,
+	0x080c, 0x3784, 0x6813, 0x0019, 0x6f16, 0x2d00, 0x685a, 0x978a,
+	0x0007, 0x0220, 0x2138, 0x2009, 0x0007, 0x0010, 0x2708, 0x903e,
+	0x6858, 0x9080, 0x0019, 0x04b1, 0x1d90, 0x2d00, 0x685a, 0x0088,
+	0x080c, 0x3784, 0x6813, 0x0019, 0x2070, 0x6817, 0x0001, 0x2d00,
+	0x685a, 0x2001, 0x002e, 0x2004, 0x2072, 0x2001, 0x002f, 0x2004,
+	0x7006, 0x2061, 0x0090, 0x2079, 0x0100, 0x6037, 0x0400, 0x2001,
+	0x0200, 0x2003, 0x0040, 0x2001, 0x002a, 0x2004, 0x9084, 0xfff8,
+	0x700a, 0x601a, 0x0006, 0x2001, 0x002b, 0x2004, 0x700e, 0x601e,
+	0x78c6, 0x000e, 0x78ca, 0x9006, 0x600a, 0x600e, 0x00ce, 0x00ee,
+	0x00fe, 0x0005, 0x00e6, 0x2071, 0x0080, 0x20e9, 0x0001, 0x20a0,
+	0x20e1, 0x0000, 0x2099, 0x0088, 0x702b, 0x0026, 0x7402, 0x7306,
+	0x9006, 0x700a, 0x700e, 0x810b, 0x810b, 0x21a8, 0x810b, 0x7112,
+	0x702b, 0x0041, 0x702c, 0xd0fc, 0x0de8, 0x702b, 0x0002, 0x702b,
+	0x0040, 0x4005, 0x7400, 0x7304, 0x87ff, 0x0180, 0x00c6, 0x00d6,
+	0x2d60, 0x00c6, 0x080c, 0x3784, 0x00ce, 0x6058, 0x2070, 0x2d00,
+	0x7006, 0x605a, 0x00de, 0x00ce, 0x9085, 0x0001, 0x00ee, 0x0005,
+	0x00e6, 0x2001, 0x002d, 0x2004, 0x9005, 0x0508, 0x2038, 0x2001,
+	0x0030, 0x2024, 0x2001, 0x0031, 0x201c, 0x080c, 0x3784, 0x2d60,
+	0x6813, 0x0019, 0x6f16, 0x2d00, 0x685a, 0x978a, 0x0007, 0x0220,
+	0x2138, 0x2009, 0x0007, 0x0010, 0x2708, 0x903e, 0x6858, 0x9080,
+	0x0019, 0x080c, 0x3062, 0x1d88, 0x2d00, 0x685a, 0x00e0, 0x080c,
+	0x3784, 0x2d60, 0x6013, 0x0019, 0x2070, 0x6017, 0x0001, 0x2c00,
+	0x605a, 0x2001, 0x0030, 0x2004, 0x2072, 0x2001, 0x0031, 0x2004,
+	0x7006, 0x2001, 0x002a, 0x2004, 0x9084, 0xfff8, 0x700a, 0x2001,
+	0x002b, 0x2004, 0x700e, 0x2001, 0x032a, 0x2003, 0x0004, 0x7884,
+	0xd0ac, 0x1180, 0x2001, 0x0101, 0x200c, 0x918d, 0x0200, 0x2102,
+	0x6017, 0x0000, 0x2001, 0x131c, 0x2003, 0x0003, 0x2001, 0x032a,
+	0x2003, 0x0009, 0x2001, 0x0300, 0x2003, 0x0000, 0x2001, 0x020d,
+	0x2003, 0x0000, 0x2001, 0x0004, 0x200c, 0x918d, 0x0002, 0x2102,
+	0x00ee, 0x0005, 0x0804, 0x28a2, 0x0126, 0x2091, 0x8000, 0x20a9,
+	0x0012, 0x2001, 0x1140, 0x20e9, 0x0001, 0x20a0, 0x9006, 0x4004,
+	0x2009, 0x013c, 0x200a, 0x012e, 0x0804, 0x28a2, 0x7d98, 0x7c9c,
+	0x0804, 0x2991, 0x080c, 0x5745, 0x0110, 0x080c, 0x46e5, 0x2069,
+	0x1152, 0x2d00, 0x2009, 0x0030, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98,
+	0x2039, 0x0001, 0x080c, 0x37c5, 0x701b, 0x312f, 0x0005, 0x2069,
+	0x1152, 0x6800, 0x9005, 0x0904, 0x28cf, 0x6804, 0xd0ac, 0x0118,
+	0xd0a4, 0x0904, 0x28cf, 0xd094, 0x00c6, 0x2061, 0x0100, 0x6104,
+	0x0138, 0x6200, 0x9292, 0x0005, 0x0218, 0x918c, 0xffdf, 0x0010,
+	0x918d, 0x0020, 0x6106, 0x00ce, 0xd08c, 0x00c6, 0x2061, 0x0100,
+	0x6104, 0x0118, 0x918d, 0x0010, 0x0010, 0x918c, 0xffef, 0x6106,
+	0x00ce, 0xd084, 0x0158, 0x6a28, 0x928a, 0x007f, 0x1a04, 0x28cf,
+	0x9288, 0x26c1, 0x210d, 0x918c, 0x00ff, 0x6156, 0xd0dc, 0x0130,
+	0x6828, 0x908a, 0x007f, 0x1a04, 0x28cf, 0x604e, 0x6888, 0x9084,
+	0x0030, 0x8004, 0x8004, 0x8004, 0x8004, 0x0006, 0x2009, 0x12c0,
+	0x9080, 0x1d8e, 0x2005, 0x200a, 0x000e, 0x2009, 0x12c1, 0x9080,
+	0x1d92, 0x2005, 0x200a, 0x6808, 0x908a, 0x0100, 0x0a04, 0x28cf,
+	0x908a, 0x0841, 0x1a04, 0x28cf, 0x9084, 0x0007, 0x1904, 0x28cf,
+	0x680c, 0x9005, 0x0904, 0x28cf, 0x6810, 0x9005, 0x0904, 0x28cf,
+	0x6848, 0x6940, 0x910a, 0x1a04, 0x28cf, 0x8001, 0x0904, 0x28cf,
+	0x684c, 0x6944, 0x910a, 0x1a04, 0x28cf, 0x8001, 0x0904, 0x28cf,
+	0x6980, 0xd1e4, 0x0140, 0x00c6, 0x2061, 0x0100, 0x6004, 0x9085,
+	0x0100, 0x6006, 0x00ce, 0x6814, 0x908c, 0x00ff, 0x613e, 0x8007,
+	0x9084, 0x00ff, 0x6042, 0x080c, 0x5a12, 0x080c, 0x4e38, 0x080c,
+	0x4e87, 0x6808, 0x602a, 0x080c, 0x1800, 0x2009, 0x0170, 0x200b,
+	0x0080, 0xa001, 0xa001, 0x200b, 0x0000, 0x0036, 0x6b08, 0x080c,
+	0x1cee, 0x003e, 0x6000, 0x9086, 0x0000, 0x1904, 0x3299, 0x6818,
+	0x691c, 0x6a20, 0x6b24, 0x8007, 0x810f, 0x8217, 0x831f, 0x6016,
+	0x611a, 0x621e, 0x6322, 0x6c04, 0xd4f4, 0x0148, 0x6830, 0x6934,
+	0x6a38, 0x6b3c, 0x8007, 0x810f, 0x8217, 0x831f, 0x0010, 0x9084,
+	0xf0ff, 0x6006, 0x610a, 0x620e, 0x6312, 0x8007, 0x810f, 0x8217,
+	0x831f, 0x20a9, 0x0004, 0x20a1, 0x12c2, 0x20e9, 0x0001, 0x4001,
+	0x080c, 0x6603, 0x00c6, 0x2009, 0x0000, 0x20a9, 0x0001, 0x6b70,
+	0xd384, 0x01d0, 0x0028, 0x83f5, 0x3e18, 0x12b0, 0x3508, 0x8109,
+	0x080c, 0x5f4d, 0x6878, 0x6016, 0x6874, 0x2008, 0x9084, 0xff00,
+	0x8007, 0x600a, 0x9184, 0x00ff, 0x6006, 0x8108, 0x1118, 0x6003,
+	0x0003, 0x0010, 0x6003, 0x0001, 0x1f04, 0x320b, 0x00ce, 0x00c6,
+	0x2061, 0x12bc, 0x6a88, 0x9284, 0xc000, 0x2010, 0x9286, 0x0000,
+	0x1118, 0x2063, 0x0000, 0x0058, 0x9286, 0x4000, 0x1118, 0x2063,
+	0x0001, 0x0028, 0x9286, 0x8000, 0x1da0, 0x2063, 0x0002, 0x00ce,
+	0x6888, 0xd0ec, 0x0130, 0x2011, 0x0114, 0x2204, 0x9085, 0x0100,
+	0x2012, 0x6a80, 0x9284, 0x0030, 0x9086, 0x0030, 0x1128, 0x9294,
+	0xffcf, 0x9295, 0x0020, 0x6a82, 0x2001, 0x128f, 0x6a80, 0x9294,
+	0x0030, 0x928e, 0x0000, 0x0170, 0x928e, 0x0010, 0x0118, 0x928e,
+	0x0020, 0x0140, 0x2003, 0xaaaa, 0x080c, 0x1d69, 0x2001, 0x1280,
+	0x2102, 0x0008, 0x2102, 0x00c6, 0x2061, 0x0100, 0x602f, 0x0040,
+	0x602f, 0x0000, 0x00ce, 0x080c, 0x5745, 0x0128, 0x080c, 0x39e4,
+	0x0110, 0x080c, 0x1cb3, 0x60c4, 0x9005, 0x01b0, 0x6003, 0x0001,
+	0x2009, 0x3283, 0x00c0, 0x080c, 0x5745, 0x1158, 0x2011, 0x5654,
+	0x080c, 0x655b, 0x2001, 0x1290, 0x2003, 0x0000, 0x080c, 0x5682,
+	0x0040, 0x080c, 0x45d6, 0x0028, 0x6003, 0x0004, 0x2009, 0x3299,
+	0x0010, 0x0804, 0x28a2, 0x2001, 0x0170, 0x2004, 0x9084, 0x00ff,
+	0x9086, 0x004c, 0x1118, 0x2091, 0x30bd, 0x0817, 0x2091, 0x303d,
+	0x0817, 0x6000, 0x9086, 0x0000, 0x0904, 0x28cc, 0x2069, 0x1152,
+	0x7890, 0x6842, 0x7894, 0x6846, 0x2d00, 0x2009, 0x0030, 0x7a8c,
+	0x7b88, 0x7c9c, 0x7d98, 0x2039, 0x0001, 0x0804, 0x37c8, 0x9006,
+	0x080c, 0x1cb3, 0x81ff, 0x1904, 0x28cc, 0x080c, 0x5745, 0x1178,
+	0x2001, 0x1290, 0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001,
+	0x9085, 0x0001, 0x080c, 0x5789, 0x080c, 0x5682, 0x0020, 0x080c,
+	0x46e5, 0x080c, 0x45d6, 0x0804, 0x28a2, 0x81ff, 0x1904, 0x28cc,
+	0x080c, 0x5745, 0x1110, 0x0804, 0x28cc, 0x6184, 0x81ff, 0x01a8,
+	0x703f, 0x0000, 0x2001, 0x1580, 0x2009, 0x0040, 0x7a8c, 0x7b88,
+	0x7c9c, 0x7d98, 0x0126, 0x2091, 0x8000, 0x2039, 0x0001, 0x080c,
+	0x37c8, 0x701b, 0x28a0, 0x012e, 0x0005, 0x703f, 0x0001, 0x00d6,
+	0x2069, 0x1580, 0x20a9, 0x0040, 0x20e9, 0x0001, 0x20a1, 0x1580,
+	0x2019, 0xffff, 0x4304, 0x654c, 0x9588, 0x26c1, 0x210d, 0x918c,
+	0x00ff, 0x216a, 0x900e, 0x2011, 0x0002, 0x2100, 0x9506, 0x01a8,
+	0x080c, 0x4b58, 0x1190, 0x6014, 0x821c, 0x0238, 0x9398, 0x1580,
+	0x9085, 0xff00, 0x8007, 0x201a, 0x0038, 0x9398, 0x1580, 0x2324,
+	0x94a4, 0xff00, 0x9405, 0x201a, 0x8210, 0x8108, 0x9182, 0x0080,
+	0x1208, 0x0c18, 0x8201, 0x8007, 0x2d0c, 0x9105, 0x206a, 0x00de,
+	0x20a9, 0x0040, 0x20a1, 0x1580, 0x2099, 0x1580, 0x080c, 0x4678,
+	0x0804, 0x32ea, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x00c6, 0x080c,
+	0x3784, 0x00ce, 0x1120, 0x2009, 0x0002, 0x0804, 0x28cc, 0x2001,
+	0x1153, 0x2004, 0xd0b4, 0x0550, 0x7884, 0x9084, 0xff00, 0x908e,
+	0x7e00, 0x0520, 0x908e, 0x7f00, 0x0508, 0x908e, 0x8000, 0x01f0,
+	0x6000, 0xd08c, 0x11d8, 0x6004, 0x9084, 0x00ff, 0x9086, 0x0006,
+	0x11a8, 0x6867, 0x0000, 0x6868, 0xc0fd, 0x686a, 0x080c, 0x9744,
+	0x1120, 0x2009, 0x0003, 0x0804, 0x28cc, 0x7007, 0x0003, 0x701b,
+	0x337a, 0x0005, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x20a9, 0x002b,
+	0x20e1, 0x0001, 0x2c98, 0x9de8, 0x0002, 0x20e9, 0x0001, 0x2da0,
+	0x4003, 0x20a9, 0x0004, 0x9d80, 0x0006, 0x20a0, 0x9c80, 0x0006,
+	0x2098, 0x080c, 0x4678, 0x20a9, 0x0004, 0x9d80, 0x000a, 0x20a0,
+	0x9c80, 0x000a, 0x2098, 0x080c, 0x4678, 0x2d00, 0x2009, 0x002b,
+	0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x2039, 0x0001, 0x0804, 0x37c8,
+	0x81ff, 0x1904, 0x28cc, 0x080c, 0x3799, 0x0904, 0x28cf, 0x080c,
+	0x4cb2, 0x0804, 0x28a2, 0x81ff, 0x1904, 0x28cc, 0x7888, 0x908a,
+	0x1000, 0x1a04, 0x28cf, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x080c,
+	0x4cf1, 0x0904, 0x28cc, 0x2019, 0x0004, 0x080c, 0x4cc4, 0x7984,
+	0x810f, 0x7a88, 0x0011, 0x0804, 0x28a2, 0x9186, 0x00ff, 0x0110,
+	0x0071, 0x0060, 0x2029, 0x007e, 0x2061, 0x1100, 0x644c, 0x2400,
+	0x9506, 0x0110, 0x2508, 0x0019, 0x8529, 0x1ec8, 0x0005, 0x080c,
+	0x4b58, 0x1138, 0x2200, 0x8003, 0x800b, 0x810b, 0x9108, 0x080c,
+	0x6567, 0x0005, 0x81ff, 0x1904, 0x28cc, 0x080c, 0x3799, 0x0904,
+	0x28cf, 0x080c, 0x4c17, 0x0904, 0x28cc, 0x080c, 0x4cbb, 0x0804,
+	0x28a2, 0x81ff, 0x1904, 0x28cc, 0x080c, 0x3799, 0x0904, 0x28cf,
+	0x080c, 0x4c17, 0x0904, 0x28cc, 0x080c, 0x4ca9, 0x0804, 0x28a2,
+	0x6100, 0x0804, 0x28a2, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x6004,
+	0x9086, 0x0707, 0x0904, 0x28cf, 0x2001, 0x1100, 0x2004, 0x9086,
+	0x0003, 0x1904, 0x28cc, 0x00d6, 0x9ce8, 0x000a, 0x7984, 0xd184,
+	0x0110, 0x9ce8, 0x0006, 0x680c, 0x8007, 0x789e, 0x6808, 0x8007,
+	0x789a, 0x6b04, 0x831f, 0x6a00, 0x8217, 0x00de, 0x6100, 0x918c,
+	0x0200, 0x0804, 0x28a2, 0x7884, 0x909c, 0x00ff, 0x939a, 0x0003,
+	0x1a04, 0x28cc, 0x624c, 0x9294, 0x00ff, 0x9084, 0xff00, 0x8007,
+	0x9206, 0x1188, 0x2031, 0x1148, 0x2009, 0x013c, 0x2136, 0x2001,
+	0x1140, 0x2009, 0x000c, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x2039,
+	0x0001, 0x0804, 0x37c8, 0x81ff, 0x1904, 0x28cc, 0x080c, 0x37a9,
+	0x0904, 0x28cf, 0x6004, 0x9084, 0x00ff, 0x9086, 0x0006, 0x1904,
+	0x28cc, 0x00c6, 0x080c, 0x3784, 0x00ce, 0x0904, 0x28cc, 0x6867,
+	0x0000, 0x6868, 0xc0fd, 0x686a, 0x080c, 0x96eb, 0x0904, 0x28cc,
+	0x7007, 0x0003, 0x701b, 0x3475, 0x0005, 0x6830, 0x9086, 0x0100,
+	0x0904, 0x28cc, 0x9d80, 0x001b, 0x2009, 0x000c, 0x7a8c, 0x7b88,
+	0x7c9c, 0x7d98, 0x2039, 0x0001, 0x0804, 0x37c8, 0x9006, 0x080c,
+	0x1cb3, 0x7884, 0x9084, 0x00ff, 0x9086, 0x00ff, 0x0118, 0x81ff,
+	0x1904, 0x28cc, 0x080c, 0x5745, 0x0110, 0x080c, 0x46e5, 0x7888,
+	0x908a, 0x1000, 0x1a04, 0x28cf, 0x7984, 0x918c, 0xff00, 0x810f,
+	0x9186, 0x00ff, 0x0138, 0x9182, 0x007f, 0x1a04, 0x28cf, 0x2100,
+	0x080c, 0x1c7d, 0x0026, 0x00c6, 0x0126, 0x2091, 0x8000, 0x2061,
+	0x12ef, 0x601b, 0x0000, 0x601f, 0x0000, 0x080c, 0x5745, 0x1178,
+	0x2001, 0x1290, 0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001,
+	0x9085, 0x0001, 0x080c, 0x5789, 0x080c, 0x5682, 0x0450, 0x2011,
+	0x0003, 0x080c, 0x79c2, 0x2011, 0x0002, 0x080c, 0x79cc, 0x080c,
+	0x78b3, 0x080c, 0x65cf, 0x0036, 0x2019, 0x0000, 0x080c, 0x7936,
+	0x003e, 0x2061, 0x0100, 0x2001, 0x1114, 0x2004, 0x9084, 0x00ff,
+	0x810f, 0x9105, 0x604a, 0x6043, 0x0090, 0x6043, 0x0010, 0x2009,
+	0x12b9, 0x200b, 0x0000, 0x2009, 0x002d, 0x2011, 0x4611, 0x080c,
+	0x65e1, 0x7984, 0x918c, 0xff00, 0x810f, 0x080c, 0x5745, 0x1110,
+	0x2009, 0x00ff, 0x7a88, 0x080c, 0x33cd, 0x012e, 0x00ce, 0x002e,
+	0x0804, 0x28a2, 0x7984, 0x918c, 0xff00, 0x810f, 0x00c6, 0x080c,
+	0x4b03, 0x2c08, 0x00ce, 0x1904, 0x28cf, 0x0804, 0x28a2, 0x81ff,
+	0x0120, 0x2009, 0x0001, 0x0804, 0x28cc, 0x60cc, 0xd0ac, 0x1130,
+	0xd09c, 0x1120, 0x2009, 0x0005, 0x0804, 0x28cc, 0x080c, 0x3784,
+	0x1120, 0x2009, 0x0002, 0x0804, 0x28cc, 0x7984, 0x7a8c, 0x7b88,
+	0x7c9c, 0x7d98, 0x2039, 0x0001, 0x080c, 0x37c5, 0x701b, 0x3531,
+	0x0005, 0x2009, 0x0080, 0x080c, 0x4b58, 0x1130, 0x6004, 0x9084,
+	0x00ff, 0x9086, 0x0006, 0x0120, 0x2021, 0x400a, 0x0804, 0x28a4,
+	0x00d6, 0x9de8, 0x0019, 0x6900, 0x6a08, 0x6b0c, 0x6c10, 0x6d14,
+	0x6e18, 0x6820, 0x90be, 0x0100, 0x0904, 0x35a8, 0x90be, 0x0112,
+	0x0904, 0x35a8, 0x90be, 0x0113, 0x0904, 0x35a8, 0x90be, 0x0114,
+	0x0904, 0x35a8, 0x90be, 0x0117, 0x0904, 0x35a8, 0x90be, 0x011a,
+	0x0904, 0x35a8, 0x90be, 0x011c, 0x0904, 0x35a8, 0x90be, 0x0121,
+	0x05b0, 0x90be, 0x0131, 0x0598, 0x90be, 0x0171, 0x05c8, 0x90be,
+	0x0173, 0x05b0, 0x90be, 0x01a1, 0x1120, 0x6830, 0x8007, 0x6832,
+	0x04a8, 0x90be, 0x0212, 0x0540, 0x90be, 0x0213, 0x0528, 0x90be,
+	0x0214, 0x01b0, 0x90be, 0x0217, 0x0168, 0x90be, 0x021a, 0x1120,
+	0x6838, 0x8007, 0x683a, 0x00e0, 0x90be, 0x0300, 0x01c8, 0x00de,
+	0x0804, 0x28cf, 0x9d80, 0x0010, 0x20a9, 0x0007, 0x080c, 0x35ee,
+	0x9d80, 0x000e, 0x20a9, 0x0001, 0x080c, 0x35ee, 0x0048, 0x9d80,
+	0x000c, 0x080c, 0x35fc, 0x0050, 0x9d80, 0x000e, 0x080c, 0x35fc,
+	0x9d80, 0x000c, 0x20a9, 0x0001, 0x080c, 0x35ee, 0x00c6, 0x080c,
+	0x3784, 0x0568, 0x6868, 0xc0fd, 0x686a, 0x6867, 0x0119, 0x6883,
+	0x0000, 0x687f, 0x0020, 0x688b, 0x0001, 0x810b, 0x69ae, 0x68b3,
+	0x0000, 0x6ab6, 0x6bba, 0x6cbe, 0x6dc2, 0x69c6, 0x68cb, 0x0000,
+	0x00ce, 0x00de, 0x6867, 0x0000, 0x6868, 0xc0fd, 0x686a, 0x6823,
+	0x0000, 0x6804, 0x2068, 0x080c, 0x9707, 0x1120, 0x2009, 0x0003,
+	0x0804, 0x28cc, 0x7007, 0x0003, 0x701b, 0x35e5, 0x0005, 0x00ce,
+	0x00de, 0x2009, 0x0002, 0x0804, 0x28cc, 0x6820, 0x9086, 0x8001,
+	0x1904, 0x28a2, 0x2009, 0x0004, 0x0804, 0x28cc, 0x0016, 0x2008,
+	0x2044, 0x8000, 0x204c, 0x8000, 0x290a, 0x8108, 0x280a, 0x8108,
+	0x1f04, 0x35f0, 0x001e, 0x0005, 0x0016, 0x00a6, 0x00b6, 0x2008,
+	0x2044, 0x8000, 0x204c, 0x8000, 0x2054, 0x8000, 0x205c, 0x2b0a,
+	0x8108, 0x2a0a, 0x8108, 0x290a, 0x8108, 0x280a, 0x00be, 0x00ae,
+	0x001e, 0x0005, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x28cc,
+	0x7984, 0x2140, 0x918c, 0xff00, 0x810f, 0x60cc, 0xd0ac, 0x1120,
+	0x9182, 0x0080, 0x0a04, 0x28cf, 0x9182, 0x00ff, 0x1a04, 0x28cf,
+	0x7a8c, 0x7b88, 0x606c, 0x9306, 0x1140, 0x6070, 0x924e, 0x0904,
+	0x28cf, 0x99cc, 0xff00, 0x0904, 0x28cf, 0x00c6, 0x080c, 0x36d2,
+	0x2c68, 0x00ce, 0x0538, 0x90c6, 0x4000, 0x1180, 0x00c6, 0x0006,
+	0x2d60, 0x2009, 0x0000, 0x080c, 0x4d21, 0x1108, 0xc185, 0x6000,
+	0xd0bc, 0x0108, 0xc18d, 0x000e, 0x00ce, 0x0088, 0x90c6, 0x4007,
+	0x1110, 0x2408, 0x0060, 0x90c6, 0x4008, 0x1118, 0x2708, 0x2610,
+	0x0030, 0x90c6, 0x4009, 0x1108, 0x0010, 0x2001, 0x4006, 0x2020,
+	0x0804, 0x28a4, 0x2d00, 0x7022, 0x0016, 0x00b6, 0x00c6, 0x00e6,
+	0x2c70, 0x080c, 0x7ec8, 0x05d8, 0x2d00, 0x6012, 0x080c, 0x99cc,
+	0x2e58, 0x00ee, 0x00e6, 0x00c6, 0x080c, 0x3784, 0x00ce, 0x2b70,
+	0x1150, 0x080c, 0x7f1e, 0x00ee, 0x00ce, 0x00be, 0x001e, 0x2009,
+	0x0002, 0x0804, 0x28cc, 0x6867, 0x0000, 0x686b, 0x0000, 0x2d00,
+	0x6016, 0x6833, 0x0000, 0x6868, 0xc0fd, 0xd88c, 0x0108, 0xc0f5,
+	0x686a, 0x0126, 0x2091, 0x8000, 0x080c, 0x25ad, 0x012e, 0x6023,
+	0x0001, 0x2001, 0x0000, 0x080c, 0x4aa1, 0x2001, 0x0002, 0x080c,
+	0x4ab3, 0x2009, 0x0002, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x00ee,
+	0x00ce, 0x00be, 0x001e, 0x1120, 0x2009, 0x0003, 0x0804, 0x28cc,
+	0x7007, 0x0003, 0x701b, 0x36b5, 0x0005, 0x6830, 0x9086, 0x0100,
+	0x7020, 0x2060, 0x1138, 0x2009, 0x0004, 0x6204, 0x9294, 0x00ff,
+	0x0804, 0x28cc, 0x2009, 0x0000, 0x6868, 0xd0f4, 0x1904, 0x28a2,
+	0x080c, 0x4d21, 0x1108, 0xc185, 0x6000, 0xd0bc, 0x0108, 0xc18d,
+	0x0804, 0x28a2, 0x00e6, 0x00d6, 0x2029, 0x0000, 0x2001, 0x1133,
+	0x2004, 0xd0ac, 0x0138, 0x2021, 0x0000, 0x20a9, 0x00ff, 0x2071,
+	0x1000, 0x0030, 0x2021, 0x0080, 0x20a9, 0x007f, 0x2071, 0x1080,
+	0x2e04, 0x9005, 0x1130, 0x2100, 0x9406, 0x1570, 0x2428, 0xc5fd,
+	0x0458, 0x2068, 0x6f10, 0x2700, 0x9306, 0x11b0, 0x6e14, 0x2600,
+	0x9206, 0x1190, 0x2400, 0x9106, 0x1160, 0x2d60, 0xd884, 0x0568,
+	0x6004, 0x9084, 0x00ff, 0x9086, 0x0006, 0x1538, 0x2001, 0x4000,
+	0x0428, 0x2001, 0x4007, 0x0410, 0x2400, 0x9106, 0x1168, 0x6e14,
+	0x87ff, 0x1138, 0x86ff, 0x09d0, 0x2001, 0x1133, 0x2004, 0xd0ac,
+	0x19a8, 0x2001, 0x4008, 0x0090, 0x8420, 0x8e70, 0x1f04, 0x36e8,
+	0x85ff, 0x1130, 0x2001, 0x4009, 0x0048, 0x2001, 0x0001, 0x0030,
+	0x080c, 0x4b03, 0x1dd0, 0x6312, 0x6216, 0x9006, 0x9005, 0x00de,
+	0x00ee, 0x0005, 0x81ff, 0x1904, 0x28cc, 0x080c, 0x3784, 0x0904,
+	0x28cc, 0x6867, 0x0000, 0x6868, 0xc0fd, 0x686a, 0x7884, 0x9005,
+	0x0904, 0x28cf, 0x9096, 0x00ff, 0x0120, 0x9092, 0x0004, 0x1a04,
+	0x28cf, 0x2010, 0x2d18, 0x080c, 0x2562, 0x0904, 0x28cc, 0x7007,
+	0x0003, 0x701b, 0x3754, 0x0005, 0x6830, 0x9086, 0x0100, 0x0904,
+	0x28cc, 0x0804, 0x28a2, 0x7984, 0x918c, 0xff00, 0x810f, 0x60cc,
+	0xd0ac, 0x1120, 0x9182, 0x0080, 0x0a04, 0x28cf, 0x9182, 0x00ff,
+	0x1a04, 0x28cf, 0x0126, 0x2091, 0x8000, 0x080c, 0x9602, 0x1188,
+	0x9190, 0x1000, 0x2204, 0x9065, 0x0160, 0x080c, 0x472d, 0x2001,
+	0x1133, 0x2004, 0xd0ac, 0x0110, 0x6017, 0x0000, 0x012e, 0x0804,
+	0x28a2, 0x012e, 0x0804, 0x28cc, 0x080c, 0x0ddf, 0x0188, 0x9006,
+	0x6802, 0x7010, 0x9005, 0x1120, 0x2d00, 0x7012, 0x7016, 0x0030,
+	0x7014, 0x6802, 0x2060, 0x2d00, 0x6006, 0x7016, 0x9d80, 0x0019,
+	0x0005, 0x7984, 0x810f, 0x918c, 0x00ff, 0x080c, 0x4b58, 0x1130,
+	0x7e88, 0x9684, 0x3fff, 0x9082, 0x4000, 0x0208, 0x9066, 0x8cff,
+	0x0005, 0x7e84, 0x860f, 0x918c, 0x00ff, 0x080c, 0x4b58, 0x1128,
+	0x96b4, 0x00ff, 0x9682, 0x4000, 0x0208, 0x9066, 0x8cff, 0x0005,
+	0x0016, 0x7110, 0x81ff, 0x0128, 0x2168, 0x6904, 0x080c, 0x0df6,
+	0x0cc8, 0x7112, 0x7116, 0x001e, 0x0005, 0x2031, 0x0001, 0x0010,
+	0x2031, 0x0000, 0x2061, 0x11e3, 0x6606, 0x6116, 0x670e, 0x6012,
+	0x622a, 0x632e, 0x6432, 0x6536, 0x2c10, 0x080c, 0x0e55, 0x7007,
+	0x0002, 0x701b, 0x28a2, 0x0005, 0x00f6, 0x0126, 0x2091, 0x8000,
+	0x2079, 0x0000, 0x2001, 0x11a1, 0x2004, 0x9005, 0x1158, 0x0e04,
+	0x37f2, 0x7a36, 0x7833, 0x0012, 0x7a82, 0x7b86, 0x7c8a, 0x2091,
+	0x4080, 0x0408, 0x0016, 0x00c6, 0x00e6, 0x2071, 0x1193, 0x7138,
+	0x9182, 0x0010, 0x0218, 0x7030, 0x2060, 0x0078, 0x7030, 0x90e0,
+	0x0004, 0x9c82, 0x11e3, 0x0210, 0x2061, 0x11a3, 0x2c00, 0x7032,
+	0x81ff, 0x1108, 0x7036, 0x8108, 0x713a, 0x2262, 0x6306, 0x640a,
+	0x00ee, 0x00ce, 0x001e, 0x012e, 0x00fe, 0x0005, 0x00e6, 0x2071,
+	0x1193, 0x7038, 0x9005, 0x0560, 0x0126, 0x2091, 0x8000, 0x0e04,
+	0x3847, 0x00f6, 0x2079, 0x0000, 0x00c6, 0x7034, 0x2060, 0x2c04,
+	0x7836, 0x7833, 0x0012, 0x7882, 0x6004, 0x7886, 0x6008, 0x788a,
+	0x2091, 0x4080, 0x7038, 0x8001, 0x703a, 0x9005, 0x1130, 0x7033,
+	0x11a3, 0x7037, 0x11a3, 0x00ce, 0x0048, 0x9c80, 0x0004, 0x90fa,
+	0x11e3, 0x0210, 0x2001, 0x11a3, 0x7036, 0x00ce, 0x00fe, 0x012e,
+	0x00ee, 0x0005, 0x0026, 0x2001, 0x1153, 0x2004, 0xd0c4, 0x0120,
+	0x2011, 0x8014, 0x080c, 0x37dc, 0x002e, 0x0005, 0x81ff, 0x1904,
+	0x28cc, 0x0126, 0x2091, 0x8000, 0x6030, 0xc08d, 0xc085, 0xc0ac,
+	0x6032, 0x080c, 0x5745, 0x1178, 0x2001, 0x1290, 0x2003, 0x0001,
+	0x2001, 0x1100, 0x2003, 0x0001, 0x9085, 0x0001, 0x080c, 0x5789,
+	0x080c, 0x5682, 0x0010, 0x080c, 0x45d6, 0x012e, 0x0804, 0x28a2,
+	0x7884, 0x2008, 0x918c, 0xfffd, 0x1128, 0x61d8, 0x910d, 0x61da,
+	0x0804, 0x28a2, 0x0804, 0x28cf, 0x81ff, 0x1904, 0x28cc, 0x6000,
+	0x9086, 0x0003, 0x1904, 0x28cc, 0x2001, 0x1153, 0x2004, 0xd0ac,
+	0x1904, 0x28cc, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x6004, 0x9084,
+	0x00ff, 0x9086, 0x0006, 0x1120, 0x7888, 0x9005, 0x0904, 0x28a2,
+	0x00c6, 0x080c, 0x3784, 0x00ce, 0x0904, 0x28cc, 0x6867, 0x0000,
+	0x6833, 0x0000, 0x6868, 0xc0fd, 0x686a, 0x080c, 0x97e0, 0x0904,
+	0x28cc, 0x7007, 0x0003, 0x701b, 0x38b6, 0x0005, 0x6830, 0x9086,
+	0x0100, 0x0904, 0x28cc, 0x0804, 0x28a2, 0x2001, 0x1100, 0x2004,
+	0x9086, 0x0003, 0x1904, 0x28cc, 0x7f84, 0x7a8c, 0x7b88, 0x7c9c,
+	0x7d98, 0x080c, 0x3784, 0x0904, 0x28cc, 0x2009, 0x0000, 0x2031,
+	0x0000, 0x7023, 0x0000, 0x702f, 0x0000, 0x9d80, 0x0005, 0x7026,
+	0x20a0, 0x20e1, 0x0001, 0x20e9, 0x0001, 0x080c, 0x4b58, 0x1904,
+	0x3937, 0x6004, 0x90c4, 0x00ff, 0x98c6, 0x0006, 0x0130, 0x90c4,
+	0xff00, 0x98c6, 0x0600, 0x1904, 0x3937, 0x2001, 0x1153, 0x2004,
+	0xd0ac, 0x1130, 0x080c, 0x4d21, 0x1118, 0xd79c, 0x0904, 0x3937,
+	0xd794, 0x1110, 0xd784, 0x0158, 0x9c80, 0x0006, 0x2098, 0x3400,
+	0x20a9, 0x0004, 0x4003, 0x080c, 0x35fc, 0xd794, 0x0148, 0x9c80,
+	0x000a, 0x2098, 0x3400, 0x20a9, 0x0004, 0x4003, 0x080c, 0x35fc,
+	0x21a2, 0x3400, 0x8000, 0x20a0, 0xd794, 0x01d8, 0x9c80, 0x0000,
+	0x2098, 0x20a9, 0x0002, 0x4003, 0x9c80, 0x0003, 0x2098, 0x20a9,
+	0x0001, 0x4005, 0x9c80, 0x0004, 0x2098, 0x3400, 0x20a9, 0x0002,
+	0x4003, 0x080c, 0x35ee, 0x9c80, 0x0026, 0x2098, 0x20a9, 0x0002,
+	0x4003, 0xd794, 0x0110, 0x96b0, 0x000b, 0x96b0, 0x0005, 0x8108,
+	0x2001, 0x1133, 0x2004, 0xd0ac, 0x0118, 0x9186, 0x0100, 0x0040,
+	0xd78c, 0x0120, 0x9186, 0x0100, 0x0170, 0x0018, 0x9186, 0x007e,
+	0x0150, 0xd794, 0x0118, 0x9686, 0x0020, 0x0010, 0x9686, 0x0028,
+	0x0150, 0x0804, 0x38d9, 0x86ff, 0x1120, 0x7120, 0x810b, 0x0804,
+	0x28a2, 0x702f, 0x0001, 0x711e, 0x7020, 0x9600, 0x7022, 0x772a,
+	0x2061, 0x11e3, 0x6007, 0x0000, 0x6616, 0x7024, 0x600f, 0x0001,
+	0x6012, 0x622a, 0x632e, 0x6432, 0x6536, 0x2c10, 0x080c, 0x0e55,
+	0x7007, 0x0002, 0x701b, 0x3975, 0x0005, 0x702c, 0x9005, 0x1170,
+	0x711c, 0x7024, 0x20a0, 0x7728, 0x2031, 0x0000, 0x2061, 0x11e3,
+	0x6228, 0x632c, 0x6430, 0x6534, 0x0804, 0x38d9, 0x7120, 0x810b,
+	0x0804, 0x28a2, 0x2029, 0x007e, 0x7984, 0x7a88, 0x7b8c, 0x7c98,
+	0x9184, 0xff00, 0x8007, 0x90e2, 0x0020, 0x0a04, 0x28cf, 0x9502,
+	0x0a04, 0x28cf, 0x9184, 0x00ff, 0x90e2, 0x0020, 0x0a04, 0x28cf,
+	0x9502, 0x0a04, 0x28cf, 0x9284, 0xff00, 0x8007, 0x90e2, 0x0020,
+	0x0a04, 0x28cf, 0x9502, 0x0a04, 0x28cf, 0x9284, 0x00ff, 0x90e2,
+	0x0020, 0x0a04, 0x28cf, 0x9502, 0x0a04, 0x28cf, 0x9384, 0xff00,
+	0x8007, 0x90e2, 0x0020, 0x0a04, 0x28cf, 0x9502, 0x0a04, 0x28cf,
+	0x9384, 0x00ff, 0x90e2, 0x0020, 0x0a04, 0x28cf, 0x9502, 0x0a04,
+	0x28cf, 0x9484, 0xff00, 0x8007, 0x90e2, 0x0020, 0x0a04, 0x28cf,
+	0x9502, 0x0a04, 0x28cf, 0x9484, 0x00ff, 0x90e2, 0x0020, 0x0a04,
+	0x28cf, 0x9502, 0x0a04, 0x28cf, 0x2061, 0x12a9, 0x6102, 0x6206,
+	0x630a, 0x640e, 0x0804, 0x28a2, 0x0006, 0x2001, 0x1153, 0x2004,
+	0xd0cc, 0x000e, 0x0005, 0x0006, 0x2001, 0x1172, 0x2004, 0xd0bc,
+	0x000e, 0x0005, 0x6164, 0x7a84, 0x6300, 0x82ff, 0x1118, 0x7986,
+	0x0804, 0x28a2, 0x83ff, 0x1904, 0x28cf, 0x2001, 0xfff0, 0x9200,
+	0x1a04, 0x28cf, 0x2019, 0xffff, 0x6068, 0x9302, 0x9200, 0x0a04,
+	0x28cf, 0x7986, 0x6266, 0x0804, 0x28a2, 0x2001, 0x1100, 0x2004,
+	0x9086, 0x0003, 0x1904, 0x28cc, 0x7c88, 0x7d84, 0x7e98, 0x7f8c,
+	0x080c, 0x3784, 0x0904, 0x28cc, 0x2009, 0x0000, 0x2019, 0x0000,
+	0x7023, 0x0000, 0x702f, 0x0000, 0x9d80, 0x0003, 0x7026, 0x20a0,
+	0x91e0, 0x1000, 0x2c64, 0x8cff, 0x01d8, 0x6004, 0x9084, 0x00ff,
+	0x9086, 0x0006, 0x0130, 0x6004, 0x9084, 0xff00, 0x9086, 0x0600,
+	0x1178, 0x00d6, 0x3468, 0x6014, 0x206a, 0x8d68, 0x6010, 0x8007,
+	0x9105, 0x8007, 0x206a, 0x8d68, 0x2da0, 0x00de, 0x9398, 0x0002,
+	0x8108, 0x9182, 0x00ff, 0x0120, 0x9386, 0x002a, 0x0148, 0x08c0,
+	0x83ff, 0x1120, 0x7120, 0x810c, 0x0804, 0x28a2, 0x702f, 0x0001,
+	0x711e, 0x7020, 0x9300, 0x7022, 0x2061, 0x11e3, 0x6007, 0x0000,
+	0x6316, 0x7024, 0x600f, 0x0001, 0x6012, 0x642a, 0x652e, 0x6632,
+	0x6736, 0x2c10, 0x080c, 0x0e55, 0x7007, 0x0002, 0x701b, 0x3a71,
+	0x0005, 0x702c, 0x9005, 0x1168, 0x711c, 0x7024, 0x20a0, 0x2019,
+	0x0000, 0x2061, 0x11e3, 0x6428, 0x652c, 0x6630, 0x6734, 0x0804,
+	0x3a28, 0x7120, 0x810c, 0x0804, 0x28a2, 0x81ff, 0x1904, 0x28cc,
+	0x60cc, 0xd0ac, 0x1118, 0xd09c, 0x0904, 0x28cc, 0x080c, 0x3784,
+	0x0904, 0x28cc, 0x7984, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x2039,
+	0x0001, 0x080c, 0x37c5, 0x701b, 0x3a9e, 0x0005, 0x00d6, 0x9de8,
+	0x0019, 0x6828, 0x90be, 0x7000, 0x0148, 0x90be, 0x7100, 0x0130,
+	0x90be, 0x7200, 0x0118, 0x00de, 0x0804, 0x28cf, 0x6820, 0x6924,
+	0x080c, 0x1c69, 0x1510, 0x080c, 0x4b03, 0x11f8, 0x7122, 0x6612,
+	0x6516, 0x6e18, 0x00c6, 0x080c, 0x3784, 0x01b8, 0x080c, 0x3784,
+	0x01a0, 0x00ce, 0x00de, 0x6867, 0x0000, 0x6868, 0xc0fd, 0x686a,
+	0x6823, 0x0000, 0x6804, 0x2068, 0x080c, 0x9728, 0x0904, 0x28cc,
+	0x7007, 0x0003, 0x701b, 0x3ad8, 0x0005, 0x00de, 0x0804, 0x28cc,
+	0x7120, 0x080c, 0x26a3, 0x6820, 0x9086, 0x8001, 0x0904, 0x28cc,
+	0x2d00, 0x701e, 0x6804, 0x9080, 0x0002, 0x0006, 0x20a9, 0x002a,
+	0x2098, 0x20a0, 0x080c, 0x4678, 0x000e, 0x9de8, 0x0019, 0x6a08,
+	0x6b0c, 0x6c10, 0x6d14, 0x2061, 0x11e3, 0x6007, 0x0000, 0x6e00,
+	0x6f28, 0x97c6, 0x7000, 0x1108, 0x0018, 0x97c6, 0x7100, 0x1150,
+	0x96c2, 0x0004, 0x0a04, 0x28cf, 0x2009, 0x0004, 0x2039, 0x0001,
+	0x0804, 0x37c8, 0x97c6, 0x7200, 0x1904, 0x28cf, 0x96c2, 0x0054,
+	0x0a04, 0x28cf, 0x600f, 0x0001, 0x6012, 0x6017, 0x002a, 0x622a,
+	0x632e, 0x6432, 0x6536, 0x2c10, 0x080c, 0x0e55, 0x7007, 0x0002,
+	0x701b, 0x3b23, 0x0005, 0x701c, 0x2068, 0x6804, 0x9080, 0x0001,
+	0x2004, 0x9080, 0x0002, 0x0006, 0x20a9, 0x002a, 0x2098, 0x20a0,
+	0x080c, 0x4678, 0x000e, 0x2009, 0x002a, 0x2061, 0x11e3, 0x6228,
+	0x632c, 0x6430, 0x6534, 0x2039, 0x0001, 0x0804, 0x37c8, 0x81ff,
+	0x1904, 0x28cc, 0x080c, 0x3799, 0x0904, 0x28cf, 0x080c, 0x4c17,
+	0x0904, 0x28cc, 0x080c, 0x4ccd, 0x0804, 0x28a2, 0x7884, 0xd084,
+	0x0904, 0x3342, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x00c6, 0x080c,
+	0x3784, 0x00ce, 0x1120, 0x2009, 0x0002, 0x0804, 0x28cc, 0x6004,
+	0x9084, 0x00ff, 0x9086, 0x0006, 0x0128, 0x908e, 0x0004, 0x0110,
+	0x908e, 0x0005, 0x1580, 0x2001, 0x1153, 0x2004, 0xd0b4, 0x0904,
+	0x337e, 0x7884, 0x9084, 0xff00, 0x908e, 0x7e00, 0x0904, 0x337e,
+	0x908e, 0x7f00, 0x0904, 0x337e, 0x908e, 0x8000, 0x0904, 0x337e,
+	0x6000, 0xd08c, 0x1904, 0x337e, 0x6867, 0x0000, 0x6868, 0xc0fd,
+	0x686a, 0x080c, 0x9744, 0x1120, 0x2009, 0x0003, 0x0804, 0x28cc,
+	0x7007, 0x0003, 0x701b, 0x3b95, 0x0005, 0x080c, 0x37a9, 0x0904,
+	0x28cf, 0x0804, 0x337e, 0x2009, 0x1130, 0x210c, 0x81ff, 0x0120,
+	0x2009, 0x0001, 0x0804, 0x28cc, 0x2001, 0x1100, 0x2004, 0x9086,
+	0x0003, 0x0120, 0x2009, 0x0007, 0x0804, 0x28cc, 0x2001, 0x1153,
+	0x2004, 0xd0ac, 0x0120, 0x2009, 0x0008, 0x0804, 0x28cc, 0x609c,
+	0xd0a4, 0x1118, 0xd0ac, 0x1904, 0x337e, 0x6867, 0x0000, 0x6833,
+	0x0000, 0x6868, 0xc0fd, 0x686a, 0x080c, 0x97e0, 0x1120, 0x2009,
+	0x0003, 0x0804, 0x28cc, 0x7007, 0x0003, 0x701b, 0x3bd0, 0x0005,
+	0x6830, 0x9086, 0x0100, 0x1120, 0x2009, 0x0004, 0x0804, 0x28cc,
+	0x080c, 0x37a9, 0x0904, 0x28cf, 0x0804, 0x3b6b, 0x81ff, 0x2009,
+	0x0001, 0x1904, 0x28cc, 0x6000, 0x9086, 0x0003, 0x2009, 0x0007,
+	0x1904, 0x28cc, 0x2001, 0x1153, 0x2004, 0xd0ac, 0x2009, 0x0008,
+	0x1904, 0x28cc, 0x080c, 0x37a9, 0x0904, 0x28cf, 0x6004, 0x9084,
+	0x00ff, 0x9086, 0x0006, 0x2009, 0x0009, 0x1904, 0x28cc, 0x00c6,
+	0x080c, 0x3784, 0x00ce, 0x2009, 0x0002, 0x0904, 0x28cc, 0x6867,
+	0x0000, 0x6833, 0x0000, 0x6868, 0xc0fd, 0x686a, 0x7988, 0x9194,
+	0xff00, 0x918c, 0x00ff, 0x9006, 0x82ff, 0x1128, 0xc0ed, 0x6952,
+	0x798c, 0x6956, 0x0048, 0x928e, 0x0100, 0x1904, 0x28cf, 0xc0e5,
+	0x6853, 0x0000, 0x6857, 0x0000, 0x683e, 0x080c, 0x99cd, 0x2009,
+	0x0003, 0x0904, 0x28cc, 0x7007, 0x0003, 0x701b, 0x3c30, 0x0005,
+	0x6830, 0x9086, 0x0100, 0x2009, 0x0004, 0x0904, 0x28cc, 0x0804,
+	0x28a2, 0x81ff, 0x2009, 0x0001, 0x1904, 0x28cc, 0x6000, 0x9086,
+	0x0003, 0x2009, 0x0007, 0x1904, 0x28cc, 0x080c, 0x37a9, 0x0904,
+	0x28cf, 0x6004, 0x9084, 0x00ff, 0x9086, 0x0006, 0x2009, 0x0009,
+	0x1904, 0x28cc, 0x00c6, 0x080c, 0x3784, 0x00ce, 0x2009, 0x0002,
+	0x0904, 0x28cc, 0x9d80, 0x001b, 0x2009, 0x0008, 0x7a8c, 0x7b88,
+	0x7c9c, 0x7d98, 0x2039, 0x0001, 0x080c, 0x37c5, 0x701b, 0x3c69,
+	0x0005, 0x00d6, 0x9de8, 0x001b, 0x6800, 0x9086, 0x0500, 0x1140,
+	0x6804, 0x9005, 0x1128, 0x6808, 0x9084, 0xff00, 0x1108, 0x0018,
+	0x00de, 0x1904, 0x28cf, 0x00de, 0x6867, 0x0000, 0x6833, 0x0000,
+	0x6868, 0xc0fd, 0x686a, 0x00c6, 0x080c, 0x37a9, 0x1118, 0x00ce,
+	0x0804, 0x28cf, 0x080c, 0x9a1c, 0x2009, 0x0003, 0x00ce, 0x0904,
+	0x28cc, 0x7007, 0x0003, 0x701b, 0x3c96, 0x0005, 0x6830, 0x9086,
+	0x0100, 0x2009, 0x0004, 0x0904, 0x28cc, 0x0804, 0x28a2, 0x81ff,
+	0x0120, 0x2009, 0x0001, 0x0804, 0x28cc, 0x6000, 0x9086, 0x0003,
+	0x0120, 0x2009, 0x0007, 0x0804, 0x28cc, 0x7e84, 0x860f, 0x918c,
+	0x00ff, 0x96b4, 0x00ff, 0x080c, 0x4b58, 0x1904, 0x28cf, 0x9186,
+	0x007f, 0x0150, 0x6004, 0x9084, 0x00ff, 0x9086, 0x0006, 0x0120,
+	0x2009, 0x0009, 0x0804, 0x28cc, 0x00c6, 0x080c, 0x3784, 0x00ce,
+	0x1120, 0x2009, 0x0002, 0x0804, 0x28cc, 0x6867, 0x0000, 0x6868,
+	0xc0fd, 0x686a, 0x080c, 0x975f, 0x1120, 0x2009, 0x0003, 0x0804,
+	0x28cc, 0x7007, 0x0003, 0x701b, 0x3cde, 0x0005, 0x6808, 0x8007,
+	0x9086, 0x0100, 0x1120, 0x2009, 0x0004, 0x0804, 0x28cc, 0x68e0,
+	0x6866, 0x6810, 0x8007, 0x9084, 0x00ff, 0x800c, 0x6814, 0x8007,
+	0x9084, 0x00ff, 0x8004, 0x9080, 0x0002, 0x9108, 0x9d80, 0x0004,
+	0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x2039, 0x0001, 0x0804, 0x37c8,
+	0x080c, 0x3784, 0x1120, 0x2009, 0x0002, 0x0804, 0x28cc, 0x7984,
+	0x9194, 0xff00, 0x918c, 0x00ff, 0x8217, 0x82ff, 0x0110, 0x0804,
+	0x28cf, 0x2009, 0x001a, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x080c,
+	0x37c5, 0x701b, 0x3d1c, 0x0005, 0x9d80, 0x0019, 0x2098, 0x20a9,
+	0x001a, 0x20a1, 0x12c2, 0x20e1, 0x0001, 0x20e9, 0x0001, 0x4003,
+	0x0804, 0x28a2, 0x080c, 0x3784, 0x1120, 0x2009, 0x0002, 0x0804,
+	0x28cc, 0x7984, 0x9194, 0xff00, 0x918c, 0x00ff, 0x8217, 0x82ff,
+	0x0110, 0x0804, 0x28cf, 0x2099, 0x12c2, 0x20a0, 0x20a9, 0x001a,
+	0x20e1, 0x0001, 0x20e9, 0x0001, 0x4003, 0x2009, 0x001a, 0x7a8c,
+	0x7b88, 0x7c9c, 0x7d98, 0x2039, 0x0001, 0x0804, 0x37c8, 0x7884,
+	0x908a, 0x1000, 0x1a04, 0x28cf, 0x0126, 0x2091, 0x8000, 0x8003,
+	0x800b, 0x810b, 0x9108, 0x00c6, 0x2061, 0x12ef, 0x6142, 0x00ce,
+	0x012e, 0x0804, 0x28a2, 0x00c6, 0x080c, 0x5745, 0x1188, 0x2001,
+	0x1290, 0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001, 0x9085,
+	0x0001, 0x080c, 0x5789, 0x080c, 0x5682, 0x080c, 0x0cf1, 0x0038,
+	0x2061, 0x1100, 0x6030, 0xc09d, 0x6032, 0x080c, 0x45d6, 0x00ce,
+	0x0005, 0x00c6, 0x2001, 0x1100, 0x2004, 0x908e, 0x0000, 0x0904,
+	0x28cc, 0x7884, 0x9005, 0x0188, 0x7888, 0x2061, 0x12bc, 0x2c0c,
+	0x2062, 0x080c, 0x203d, 0x01a0, 0x080c, 0x2045, 0x0188, 0x080c,
+	0x204d, 0x0170, 0x2162, 0x0804, 0x28cf, 0x2061, 0x0100, 0x6038,
+	0x9086, 0x0007, 0x1118, 0x2009, 0x0001, 0x0010, 0x2009, 0x0000,
+	0x7884, 0x9086, 0x0002, 0x1568, 0x2061, 0x0100, 0x6028, 0xc09c,
+	0x602a, 0x0026, 0x2011, 0x0003, 0x080c, 0x79c2, 0x2011, 0x0002,
+	0x080c, 0x79cc, 0x002e, 0x080c, 0x78b3, 0x080c, 0x65cf, 0x0036,
+	0x2019, 0x0000, 0x080c, 0x7936, 0x003e, 0x60e3, 0x0000, 0x080c,
+	0xadf2, 0x080c, 0xae0d, 0x9085, 0x0001, 0x080c, 0x5789, 0x2001,
+	0x0140, 0x2003, 0x0000, 0x2001, 0x1100, 0x2003, 0x0004, 0x6027,
+	0x0008, 0x00ce, 0x0804, 0x28a2, 0x81ff, 0x0120, 0x2009, 0x0001,
+	0x0804, 0x28cc, 0x6000, 0x9086, 0x0003, 0x0120, 0x2009, 0x0007,
+	0x0804, 0x28cc, 0x7e84, 0x860f, 0x918c, 0x00ff, 0x96b4, 0x00ff,
+	0x080c, 0x4b58, 0x1904, 0x28cf, 0x9186, 0x007f, 0x0150, 0x6004,
+	0x9084, 0x00ff, 0x9086, 0x0006, 0x0120, 0x2009, 0x0009, 0x0804,
+	0x28cc, 0x00c6, 0x080c, 0x3784, 0x00ce, 0x1120, 0x2009, 0x0002,
+	0x0804, 0x28cc, 0x6867, 0x0000, 0x6868, 0xc0fd, 0x686a, 0x080c,
+	0x977b, 0x1120, 0x2009, 0x0003, 0x0804, 0x28cc, 0x7007, 0x0003,
+	0x701b, 0x3e1b, 0x0005, 0x6830, 0x9086, 0x0100, 0x1120, 0x2009,
+	0x0004, 0x0804, 0x28cc, 0x68e0, 0x6866, 0x6834, 0x8007, 0x800c,
+	0x9d80, 0x000c, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x2039, 0x0001,
+	0x0804, 0x37c8, 0x0126, 0x2091, 0x8000, 0x00c6, 0x2061, 0x12ef,
+	0x7984, 0x6152, 0x614e, 0x6057, 0x0000, 0x604b, 0x0009, 0x7898,
+	0x606a, 0x789c, 0x6066, 0x7888, 0x6062, 0x788c, 0x605e, 0x2061,
+	0x1291, 0x2001, 0x1304, 0x6012, 0x600f, 0x0001, 0x6017, 0x0001,
+	0x601b, 0x0002, 0x6007, 0x0000, 0x603b, 0x0000, 0x00ce, 0x012e,
+	0x0804, 0x28a2, 0x0126, 0x0156, 0x0136, 0x0146, 0x01c6, 0x01d6,
+	0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x2061, 0x0100, 0x2069, 0x0200,
+	0x2071, 0x1100, 0x6044, 0xd0a4, 0x11e8, 0xd084, 0x0118, 0x080c,
+	0x3ff0, 0x0068, 0xd08c, 0x0118, 0x080c, 0x3f00, 0x0040, 0xd094,
+	0x0118, 0x080c, 0x3ed3, 0x0018, 0xd09c, 0x0108, 0x0099, 0x00fe,
+	0x00ee, 0x00de, 0x00ce, 0x01de, 0x01ce, 0x014e, 0x013e, 0x015e,
+	0x012e, 0x0005, 0x0016, 0x6128, 0xd19c, 0x1110, 0xc19d, 0x612a,
+	0x001e, 0x0c68, 0x624c, 0x9286, 0xf0f0, 0x1150, 0x6048, 0x9086,
+	0xf0f0, 0x0130, 0x624a, 0x6043, 0x0090, 0x6043, 0x0010, 0x0490,
+	0x9294, 0xff00, 0x9296, 0xf700, 0x0178, 0x7134, 0xd1a4, 0x1160,
+	0x6240, 0x9295, 0x0100, 0x6242, 0x9294, 0x0010, 0x0128, 0x2009,
+	0x00f7, 0x080c, 0x46a4, 0x00f0, 0x6040, 0x9084, 0x0010, 0x9085,
+	0x0140, 0x6042, 0x6043, 0x0000, 0x7077, 0x0000, 0x7093, 0x0001,
+	0x70b7, 0x0000, 0x70cf, 0x0000, 0x2009, 0x1580, 0x200b, 0x0000,
+	0x7087, 0x0000, 0x707b, 0x000f, 0x2009, 0x000f, 0x2011, 0x457f,
+	0x080c, 0x65e1, 0x0005, 0x2001, 0x1174, 0x2004, 0xd08c, 0x0110,
+	0x704f, 0xffff, 0x7078, 0x9005, 0x1510, 0x2011, 0x457f, 0x080c,
+	0x655b, 0x6040, 0x9094, 0x0010, 0x9285, 0x0020, 0x6042, 0x20a9,
+	0x00c8, 0x6044, 0xd08c, 0x1168, 0x1f04, 0x3ee9, 0x6242, 0x708b,
+	0x0000, 0x6040, 0x9094, 0x0010, 0x9285, 0x0080, 0x6042, 0x6242,
+	0x0030, 0x6242, 0x708b, 0x0000, 0x707f, 0x0000, 0x0000, 0x0005,
+	0x707c, 0x908a, 0x0003, 0x1210, 0x0023, 0x0010, 0x080c, 0x0cf1,
+	0x0005, 0x3f0c, 0x3f54, 0x3fef, 0x00f6, 0x707f, 0x0001, 0x6803,
+	0x00fc, 0x20a9, 0x0004, 0x6800, 0x9084, 0x00fc, 0x0120, 0x1f04,
+	0x3f13, 0x080c, 0x0cf1, 0x68a0, 0x68a2, 0x689c, 0x689e, 0x6898,
+	0x689a, 0xa001, 0x6803, 0x1600, 0x6837, 0x0020, 0x080c, 0x4702,
+	0x2079, 0x1500, 0x7833, 0x1101, 0x7837, 0x0000, 0x20e1, 0x0001,
+	0x2099, 0x1105, 0x20e9, 0x0001, 0x20a1, 0x150e, 0x20a9, 0x0004,
+	0x4003, 0x080c, 0x7e9b, 0x20e1, 0x0001, 0x2099, 0x1500, 0x20e9,
+	0x0000, 0x20a1, 0x0240, 0x20a9, 0x0014, 0x4003, 0x60c3, 0x000c,
+	0x600f, 0x0000, 0x080c, 0x45b2, 0x00fe, 0x7083, 0x0000, 0x6043,
+	0x0008, 0x6043, 0x0000, 0x0005, 0x00f6, 0x7080, 0x7083, 0x0000,
+	0x9025, 0x0904, 0x3fcc, 0x6020, 0xd0b4, 0x1904, 0x3fca, 0x7190,
+	0x81ff, 0x0904, 0x3fb8, 0x9486, 0x000c, 0x1904, 0x3fc5, 0x9480,
+	0x0018, 0x8004, 0x20a8, 0x080c, 0x46fa, 0x2011, 0x0260, 0x2019,
+	0x1500, 0x220c, 0x2304, 0x9106, 0x11e8, 0x8210, 0x8318, 0x1f04,
+	0x3f71, 0x6043, 0x0004, 0x2061, 0x0140, 0x605b, 0xbc94, 0x605f,
+	0xf0f0, 0x2061, 0x0100, 0x6043, 0x0006, 0x707f, 0x0002, 0x708b,
+	0x0002, 0x2009, 0x07d0, 0x2011, 0x4586, 0x080c, 0x65e1, 0x080c,
+	0x4702, 0x04c0, 0x080c, 0x46fa, 0x2079, 0x0260, 0x7930, 0x918e,
+	0x1101, 0x1558, 0x7834, 0x9005, 0x1540, 0x7900, 0x918c, 0x00ff,
+	0x1118, 0x7804, 0x9005, 0x0190, 0x080c, 0x46fa, 0x2011, 0x026e,
+	0x2019, 0x1105, 0x20a9, 0x0004, 0x220c, 0x2304, 0x9102, 0x0230,
+	0x11a0, 0x8210, 0x8318, 0x1f04, 0x3fac, 0x0078, 0x7093, 0x0000,
+	0x080c, 0x46fa, 0x20e1, 0x0000, 0x2099, 0x0260, 0x20e9, 0x0001,
+	0x20a1, 0x1500, 0x20a9, 0x0014, 0x4003, 0x6043, 0x0008, 0x6043,
+	0x0000, 0x0010, 0x00fe, 0x0005, 0x6040, 0x9085, 0x0100, 0x6042,
+	0x6020, 0xd0b4, 0x1db8, 0x080c, 0x7e9b, 0x20e1, 0x0001, 0x2099,
+	0x1500, 0x20e9, 0x0000, 0x20a1, 0x0240, 0x20a9, 0x0014, 0x4003,
+	0x60c3, 0x000c, 0x2011, 0x12e6, 0x2013, 0x0000, 0x7083, 0x0000,
+	0x60a3, 0x0056, 0x60a7, 0x9575, 0x080c, 0x7718, 0x08d8, 0x0005,
+	0x7088, 0x908a, 0x001d, 0x1210, 0x0023, 0x0010, 0x080c, 0x0cf1,
+	0x0005, 0x4023, 0x4036, 0x4060, 0x4080, 0x40a6, 0x40d5, 0x40fb,
+	0x4133, 0x4159, 0x4187, 0x41c0, 0x41f8, 0x4216, 0x4241, 0x4263,
+	0x427a, 0x4282, 0x42b4, 0x42da, 0x4309, 0x432f, 0x4367, 0x43a6,
+	0x43db, 0x43f9, 0x4452, 0x4474, 0x449e, 0x449f, 0x00c6, 0x2061,
+	0x1100, 0x6003, 0x0007, 0x2061, 0x0100, 0x6004, 0x9084, 0xfff9,
+	0x6006, 0x00ce, 0x0005, 0x2061, 0x0140, 0x605b, 0xbc94, 0x605f,
+	0xf0f0, 0x2061, 0x0100, 0x6043, 0x0002, 0x708b, 0x0001, 0x2009,
+	0x07d0, 0x2011, 0x4586, 0x080c, 0x65e1, 0x0005, 0x00f6, 0x7080,
+	0x9086, 0x0014, 0x1518, 0x6043, 0x0000, 0x6020, 0xd0b4, 0x11f0,
+	0x080c, 0x46fa, 0x2079, 0x0260, 0x7a30, 0x9296, 0x1102, 0x11a0,
+	0x7834, 0x9005, 0x1188, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0x9005,
+	0x1110, 0x70b7, 0x0001, 0x2011, 0x4586, 0x080c, 0x655b, 0x708b,
+	0x0010, 0x080c, 0x4282, 0x0010, 0x7083, 0x0000, 0x00fe, 0x0005,
+	0x00f6, 0x708b, 0x0003, 0x6043, 0x0004, 0x2011, 0x4586, 0x080c,
+	0x655b, 0x080c, 0x4686, 0x2079, 0x0240, 0x7833, 0x1102, 0x7837,
+	0x0000, 0x20a9, 0x0008, 0x9f88, 0x000e, 0x200b, 0x0000, 0x8108,
+	0x1f04, 0x4075, 0x60c3, 0x0014, 0x080c, 0x45b2, 0x00fe, 0x0005,
+	0x00f6, 0x7080, 0x9005, 0x0500, 0x2011, 0x4586, 0x080c, 0x655b,
+	0x9086, 0x0014, 0x11b8, 0x080c, 0x46fa, 0x2079, 0x0260, 0x7a30,
+	0x9296, 0x1102, 0x1178, 0x7834, 0x9005, 0x1160, 0x7a38, 0xd2fc,
+	0x0128, 0x70b4, 0x9005, 0x1110, 0x70b7, 0x0001, 0x708b, 0x0004,
+	0x0029, 0x0010, 0x080c, 0x46d6, 0x00fe, 0x0005, 0x00f6, 0x708b,
+	0x0005, 0x080c, 0x4686, 0x2079, 0x0240, 0x7833, 0x1103, 0x7837,
+	0x0000, 0x080c, 0x46fa, 0x080c, 0x46dd, 0x1170, 0x7074, 0x9005,
+	0x1158, 0x714c, 0x9186, 0xffff, 0x0138, 0x2011, 0x0008, 0x080c,
+	0x4532, 0x0168, 0x080c, 0x46bb, 0x20a9, 0x0008, 0x20e1, 0x0000,
+	0x2099, 0x026e, 0x20e9, 0x0000, 0x20a1, 0x024e, 0x4003, 0x60c3,
+	0x0014, 0x080c, 0x45b2, 0x00fe, 0x0005, 0x00f6, 0x7080, 0x9005,
+	0x0500, 0x2011, 0x4586, 0x080c, 0x655b, 0x9086, 0x0014, 0x11b8,
+	0x080c, 0x46fa, 0x2079, 0x0260, 0x7a30, 0x9296, 0x1103, 0x1178,
+	0x7834, 0x9005, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0x9005,
+	0x1110, 0x70b7, 0x0001, 0x708b, 0x0006, 0x0029, 0x0010, 0x080c,
+	0x46d6, 0x00fe, 0x0005, 0x00f6, 0x708b, 0x0007, 0x080c, 0x4686,
+	0x2079, 0x0240, 0x7833, 0x1104, 0x7837, 0x0000, 0x080c, 0x46fa,
+	0x080c, 0x46dd, 0x11b8, 0x7074, 0x9005, 0x11a0, 0x7154, 0x9186,
+	0xffff, 0x0180, 0x9180, 0x26c1, 0x200d, 0x918c, 0xff00, 0x810f,
+	0x2011, 0x0008, 0x080c, 0x4532, 0x0180, 0x080c, 0x39eb, 0x0110,
+	0x080c, 0x1cb3, 0x20a9, 0x0008, 0x20e1, 0x0000, 0x2099, 0x026e,
+	0x20e9, 0x0000, 0x20a1, 0x024e, 0x4003, 0x60c3, 0x0014, 0x080c,
+	0x45b2, 0x00fe, 0x0005, 0x00f6, 0x7080, 0x9005, 0x0500, 0x2011,
+	0x4586, 0x080c, 0x655b, 0x9086, 0x0014, 0x11b8, 0x080c, 0x46fa,
+	0x2079, 0x0260, 0x7a30, 0x9296, 0x1104, 0x1178, 0x7834, 0x9005,
+	0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0x9005, 0x1110, 0x70b7,
+	0x0001, 0x708b, 0x0008, 0x0029, 0x0010, 0x080c, 0x46d6, 0x00fe,
+	0x0005, 0x00f6, 0x708b, 0x0009, 0x080c, 0x4686, 0x2079, 0x0240,
+	0x7833, 0x1105, 0x7837, 0x0100, 0x080c, 0x46dd, 0x1150, 0x7074,
+	0x9005, 0x1138, 0x080c, 0x44a0, 0x1188, 0x9085, 0x0001, 0x080c,
+	0x1cb3, 0x20a9, 0x0008, 0x080c, 0x46fa, 0x20e1, 0x0000, 0x2099,
+	0x026e, 0x20e9, 0x0000, 0x20a1, 0x024e, 0x4003, 0x60c3, 0x0014,
+	0x080c, 0x45b2, 0x0010, 0x080c, 0x4016, 0x00fe, 0x0005, 0x00f6,
+	0x7080, 0x9005, 0x0598, 0x2011, 0x4586, 0x080c, 0x655b, 0x9086,
+	0x0014, 0x1550, 0x080c, 0x46fa, 0x2079, 0x0260, 0x7a30, 0x9296,
+	0x1105, 0x1510, 0x7834, 0x2011, 0x0100, 0x921e, 0x1160, 0x7a38,
+	0xd2fc, 0x0128, 0x70b4, 0x9005, 0x1110, 0x70b7, 0x0001, 0x708b,
+	0x000a, 0x00b1, 0x0098, 0x9005, 0x1178, 0x7a38, 0xd2fc, 0x0128,
+	0x70b4, 0x9005, 0x1110, 0x70b7, 0x0001, 0x7087, 0x0000, 0x708b,
+	0x000e, 0x080c, 0x4263, 0x0010, 0x080c, 0x46d6, 0x00fe, 0x0005,
+	0x00f6, 0x708b, 0x000b, 0x2011, 0x150e, 0x20e9, 0x0001, 0x22a0,
+	0x20a9, 0x0040, 0x2019, 0xffff, 0x4304, 0x080c, 0x4686, 0x2079,
+	0x0240, 0x7833, 0x1106, 0x7837, 0x0000, 0x080c, 0x46dd, 0x0118,
+	0x2013, 0x0000, 0x0020, 0x7050, 0x9085, 0x0100, 0x2012, 0x20a9,
+	0x0040, 0x2009, 0x024e, 0x2011, 0x150e, 0x220e, 0x8210, 0x8108,
+	0x9186, 0x0260, 0x1128, 0x6810, 0x8000, 0x6812, 0x2009, 0x0240,
+	0x1f04, 0x41e5, 0x60c3, 0x0084, 0x080c, 0x45b2, 0x00fe, 0x0005,
+	0x00f6, 0x7080, 0x9005, 0x01c0, 0x2011, 0x4586, 0x080c, 0x655b,
+	0x9086, 0x0084, 0x1178, 0x080c, 0x46fa, 0x2079, 0x0260, 0x7a30,
+	0x9296, 0x1106, 0x1138, 0x7834, 0x9005, 0x1120, 0x708b, 0x000c,
+	0x0029, 0x0010, 0x080c, 0x46d6, 0x00fe, 0x0005, 0x00f6, 0x708b,
+	0x000d, 0x080c, 0x4686, 0x2079, 0x0240, 0x7833, 0x1107, 0x7837,
+	0x0000, 0x080c, 0x46fa, 0x20a9, 0x0040, 0x2011, 0x026e, 0x2009,
+	0x024e, 0x220e, 0x8210, 0x8108, 0x9186, 0x0260, 0x1150, 0x6810,
+	0x8000, 0x6812, 0x2009, 0x0240, 0x6814, 0x8000, 0x6816, 0x2011,
+	0x0260, 0x1f04, 0x4229, 0x60c3, 0x0084, 0x080c, 0x45b2, 0x00fe,
+	0x0005, 0x00f6, 0x7080, 0x9005, 0x01e0, 0x2011, 0x4586, 0x080c,
+	0x655b, 0x9086, 0x0084, 0x1198, 0x080c, 0x46fa, 0x2079, 0x0260,
+	0x7a30, 0x9296, 0x1107, 0x1158, 0x7834, 0x9005, 0x1140, 0x7087,
+	0x0001, 0x080c, 0x4658, 0x708b, 0x000e, 0x0029, 0x0010, 0x080c,
+	0x46d6, 0x00fe, 0x0005, 0x708b, 0x000f, 0x7083, 0x0000, 0x2061,
+	0x0140, 0x605b, 0xbc85, 0x605f, 0xb5b5, 0x2061, 0x0100, 0x6043,
+	0x0005, 0x6043, 0x0004, 0x2009, 0x07d0, 0x2011, 0x4586, 0x080c,
+	0x654f, 0x0005, 0x7080, 0x9005, 0x0120, 0x2011, 0x4586, 0x080c,
+	0x655b, 0x0005, 0x708b, 0x0011, 0x080c, 0x7e9b, 0x080c, 0x46fa,
+	0x20e1, 0x0000, 0x2099, 0x0260, 0x20e9, 0x0000, 0x20a1, 0x0240,
+	0x7480, 0x9480, 0x0018, 0x9080, 0x0007, 0x9084, 0x03f8, 0x8004,
+	0x20a8, 0x4003, 0x080c, 0x46dd, 0x1190, 0x716c, 0x81ff, 0x0178,
+	0x2009, 0x0000, 0x7070, 0x9084, 0x00ff, 0x0148, 0x080c, 0x1c69,
+	0x9186, 0x0080, 0x0120, 0x2011, 0x0008, 0x080c, 0x4532, 0x60c3,
+	0x0014, 0x080c, 0x45b2, 0x0005, 0x00f6, 0x7080, 0x9005, 0x0500,
+	0x2011, 0x4586, 0x080c, 0x655b, 0x9086, 0x0014, 0x11b8, 0x080c,
+	0x46fa, 0x2079, 0x0260, 0x7a30, 0x9296, 0x1103, 0x1178, 0x7834,
+	0x9005, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0x9005, 0x1110,
+	0x70b7, 0x0001, 0x708b, 0x0012, 0x0029, 0x0010, 0x7083, 0x0000,
+	0x00fe, 0x0005, 0x00f6, 0x708b, 0x0013, 0x080c, 0x4694, 0x2079,
+	0x0240, 0x7833, 0x1103, 0x7837, 0x0000, 0x080c, 0x46fa, 0x080c,
+	0x46dd, 0x1170, 0x7074, 0x9005, 0x1158, 0x714c, 0x9186, 0xffff,
+	0x0138, 0x2011, 0x0008, 0x080c, 0x4532, 0x0168, 0x080c, 0x46bb,
+	0x20a9, 0x0008, 0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9, 0x0000,
+	0x20a1, 0x024e, 0x4003, 0x60c3, 0x0014, 0x080c, 0x45b2, 0x00fe,
+	0x0005, 0x00f6, 0x7080, 0x9005, 0x0500, 0x2011, 0x4586, 0x080c,
+	0x655b, 0x9086, 0x0014, 0x11b8, 0x080c, 0x46fa, 0x2079, 0x0260,
+	0x7a30, 0x9296, 0x1104, 0x1178, 0x7834, 0x9005, 0x1160, 0x7a38,
+	0xd2fc, 0x0128, 0x70b4, 0x9005, 0x1110, 0x70b7, 0x0001, 0x708b,
+	0x0014, 0x0029, 0x0010, 0x7083, 0x0000, 0x00fe, 0x0005, 0x00f6,
+	0x708b, 0x0015, 0x080c, 0x4694, 0x2079, 0x0240, 0x7833, 0x1104,
+	0x7837, 0x0000, 0x080c, 0x46fa, 0x080c, 0x46dd, 0x11b8, 0x7074,
+	0x9005, 0x11a0, 0x7154, 0x9186, 0xffff, 0x0180, 0x9180, 0x26c1,
+	0x200d, 0x918c, 0xff00, 0x810f, 0x2011, 0x0008, 0x080c, 0x4532,
+	0x0180, 0x080c, 0x39eb, 0x0110, 0x080c, 0x1cb3, 0x20a9, 0x0008,
+	0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9, 0x0000, 0x20a1, 0x024e,
+	0x4003, 0x60c3, 0x0014, 0x080c, 0x45b2, 0x00fe, 0x0005, 0x00f6,
+	0x7080, 0x9005, 0x05c8, 0x2011, 0x4586, 0x080c, 0x655b, 0x9086,
+	0x0014, 0x1580, 0x080c, 0x46fa, 0x2079, 0x0260, 0x7a30, 0x9296,
+	0x1105, 0x1540, 0x7834, 0x2011, 0x0100, 0x921e, 0x1148, 0x7a38,
+	0xd2fc, 0x0128, 0x70b4, 0x9005, 0x1110, 0x70b7, 0x0001, 0x0060,
+	0x9005, 0x11c0, 0x7a38, 0xd2fc, 0x0128, 0x70b4, 0x9005, 0x1110,
+	0x70b7, 0x0001, 0x7087, 0x0000, 0x7a38, 0xd2f4, 0x0138, 0x2001,
+	0x1174, 0x2004, 0xd0a4, 0x1110, 0x70cf, 0x0008, 0x708b, 0x0016,
+	0x0029, 0x0010, 0x7083, 0x0000, 0x00fe, 0x0005, 0x080c, 0x7e9b,
+	0x080c, 0x46fa, 0x20e1, 0x0000, 0x2099, 0x0260, 0x20e9, 0x0000,
+	0x20a1, 0x0240, 0x20a9, 0x000e, 0x4003, 0x2011, 0x026e, 0x708b,
+	0x0017, 0x080c, 0x46dd, 0x1150, 0x7074, 0x9005, 0x1138, 0x080c,
+	0x44a0, 0x1188, 0x9085, 0x0001, 0x080c, 0x1cb3, 0x20a9, 0x0008,
+	0x080c, 0x46fa, 0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9, 0x0000,
+	0x20a1, 0x024e, 0x4003, 0x60c3, 0x0014, 0x080c, 0x45b2, 0x0010,
+	0x080c, 0x4016, 0x0005, 0x00f6, 0x7080, 0x9005, 0x01c0, 0x2011,
+	0x4586, 0x080c, 0x655b, 0x9086, 0x0084, 0x1178, 0x080c, 0x46fa,
+	0x2079, 0x0260, 0x7a30, 0x9296, 0x1106, 0x1138, 0x7834, 0x9005,
+	0x1120, 0x708b, 0x0018, 0x0029, 0x0010, 0x7083, 0x0000, 0x00fe,
+	0x0005, 0x00f6, 0x708b, 0x0019, 0x080c, 0x4694, 0x2079, 0x0240,
+	0x7833, 0x1106, 0x7837, 0x0000, 0x080c, 0x46fa, 0x2009, 0x026e,
+	0x2039, 0x150e, 0x20a9, 0x0040, 0x213e, 0x8738, 0x8108, 0x9186,
+	0x0280, 0x1128, 0x6814, 0x8000, 0x6816, 0x2009, 0x0260, 0x1f04,
+	0x440c, 0x2039, 0x150e, 0x080c, 0x46dd, 0x11e8, 0x2728, 0x2514,
+	0x8207, 0x9084, 0x00ff, 0x8000, 0x2018, 0x9294, 0x00ff, 0x8007,
+	0x9205, 0x202a, 0x7050, 0x2310, 0x8214, 0x92a0, 0x150e, 0x2414,
+	0x938c, 0x0001, 0x0118, 0x9294, 0xff00, 0x0018, 0x9294, 0x00ff,
+	0x8007, 0x9215, 0x2222, 0x20a9, 0x0040, 0x2009, 0x024e, 0x270e,
+	0x8738, 0x8108, 0x9186, 0x0260, 0x1128, 0x6810, 0x8000, 0x6812,
+	0x2009, 0x0240, 0x1f04, 0x443f, 0x60c3, 0x0084, 0x080c, 0x45b2,
+	0x00fe, 0x0005, 0x00f6, 0x7080, 0x9005, 0x01e0, 0x2011, 0x4586,
+	0x080c, 0x655b, 0x9086, 0x0084, 0x1198, 0x080c, 0x46fa, 0x2079,
+	0x0260, 0x7a30, 0x9296, 0x1107, 0x1158, 0x7834, 0x9005, 0x1140,
+	0x7087, 0x0001, 0x080c, 0x4658, 0x708b, 0x001a, 0x0029, 0x0010,
+	0x7083, 0x0000, 0x00fe, 0x0005, 0x708b, 0x001b, 0x080c, 0x7e9b,
+	0x080c, 0x46fa, 0x2011, 0x0260, 0x2009, 0x0240, 0x7480, 0x9480,
+	0x0018, 0x9080, 0x0007, 0x9084, 0x03f8, 0x8004, 0x20a8, 0x220e,
+	0x8210, 0x8108, 0x9186, 0x0260, 0x1150, 0x6810, 0x8000, 0x6812,
+	0x2009, 0x0240, 0x6814, 0x8000, 0x6816, 0x2011, 0x0260, 0x1f04,
+	0x4487, 0x60c3, 0x0084, 0x080c, 0x45b2, 0x0005, 0x0005, 0x0005,
+	0x0086, 0x0096, 0x2029, 0x1153, 0x252c, 0x20a9, 0x0008, 0x2041,
+	0x150e, 0x20e9, 0x0001, 0x28a0, 0x080c, 0x46fa, 0x20e1, 0x0000,
+	0x2099, 0x026e, 0x4003, 0x20a9, 0x0008, 0x2011, 0x0007, 0xd5d4,
+	0x0110, 0x2011, 0x0000, 0x2800, 0x9200, 0x200c, 0x91a6, 0xffff,
+	0x1148, 0xd5d4, 0x0110, 0x8210, 0x0008, 0x8211, 0x1f04, 0x44bb,
+	0x0804, 0x452a, 0x82ff, 0x1160, 0xd5d4, 0x0120, 0x91a6, 0x3fff,
+	0x0d90, 0x0020, 0x91a6, 0x3fff, 0x0904, 0x452a, 0x918d, 0xc000,
+	0x20a9, 0x0010, 0x2019, 0x0001, 0xd5d4, 0x0110, 0x2019, 0x0010,
+	0x2120, 0xd5d4, 0x0110, 0x8423, 0x0008, 0x8424, 0x1240, 0xd5d4,
+	0x0110, 0x8319, 0x0008, 0x8318, 0x1f04, 0x44e1, 0x04d8, 0x23a8,
+	0x2021, 0x0001, 0x8426, 0x8425, 0x1f04, 0x44f3, 0x2328, 0x8529,
+	0x92be, 0x0007, 0x0158, 0x0006, 0x2039, 0x0007, 0x2200, 0x973a,
+	0x000e, 0x27a8, 0x95a8, 0x0010, 0x1f04, 0x4502, 0x754e, 0x95c8,
+	0x26c1, 0x292d, 0x95ac, 0x00ff, 0x7572, 0x6532, 0x6536, 0x0016,
+	0x2508, 0x080c, 0x1c93, 0x001e, 0x60e7, 0x0000, 0x65ea, 0x2018,
+	0x2304, 0x9405, 0x201a, 0x7077, 0x0001, 0x20e9, 0x0000, 0x20a1,
+	0x024e, 0x20e1, 0x0001, 0x2898, 0x20a9, 0x0008, 0x4003, 0x9085,
+	0x0001, 0x0028, 0x9006, 0x0018, 0x9006, 0x080c, 0x0cf1, 0x009e,
+	0x008e, 0x0005, 0x0156, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x22a8,
+	0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9, 0x0000, 0x2011, 0x024e,
+	0x22a0, 0x4003, 0x014e, 0x013e, 0x01de, 0x01ce, 0x015e, 0x2118,
+	0x2021, 0x0000, 0x2001, 0x0007, 0x939a, 0x0010, 0x0218, 0x8420,
+	0x8001, 0x0cd0, 0x2118, 0x84ff, 0x0120, 0x939a, 0x0010, 0x8421,
+	0x1de0, 0x2021, 0x0001, 0x83ff, 0x0118, 0x8423, 0x8319, 0x1de8,
+	0x9238, 0x2029, 0x026e, 0x9528, 0x2504, 0x942c, 0x11b8, 0x9405,
+	0x203a, 0x714e, 0x91a0, 0x26c1, 0x242d, 0x95ac, 0x00ff, 0x7572,
+	0x6532, 0x6536, 0x0016, 0x2508, 0x080c, 0x1c93, 0x001e, 0x60e7,
+	0x0000, 0x65ea, 0x7077, 0x0001, 0x9084, 0x0000, 0x0005, 0x00e6,
+	0x2071, 0x1100, 0x707b, 0x0000, 0x00ee, 0x0005, 0x00e6, 0x00f6,
+	0x2079, 0x0100, 0x2071, 0x0140, 0x080c, 0x4647, 0x080c, 0x7721,
+	0x7004, 0x9084, 0x4000, 0x0120, 0x7003, 0x1000, 0x7003, 0x0000,
+	0x0126, 0x2091, 0x8000, 0x2071, 0x1122, 0x2073, 0x0000, 0x7840,
+	0x0026, 0x0016, 0x2009, 0x00f7, 0x080c, 0x46a4, 0x001e, 0x9094,
+	0x0010, 0x9285, 0x0080, 0x7842, 0x7a42, 0x002e, 0x012e, 0x00fe,
+	0x00ee, 0x0005, 0x0126, 0x2091, 0x8000, 0x2011, 0x12e6, 0x2013,
+	0x0000, 0x7083, 0x0000, 0x012e, 0x60a3, 0x0056, 0x60a7, 0x9575,
+	0x080c, 0x7718, 0x6144, 0xd184, 0x0120, 0x7188, 0x918d, 0x2000,
+	0x0018, 0x717c, 0x918d, 0x1000, 0x2011, 0x12b9, 0x2112, 0x2009,
+	0x07d0, 0x2011, 0x4586, 0x080c, 0x65e1, 0x0005, 0x0016, 0x0026,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x2011, 0x0003, 0x080c, 0x79c2,
+	0x2011, 0x0002, 0x080c, 0x79cc, 0x080c, 0x78b3, 0x080c, 0x65cf,
+	0x0036, 0x2019, 0x0000, 0x080c, 0x7936, 0x003e, 0x2009, 0x00f7,
+	0x080c, 0x46a4, 0x2061, 0x12ef, 0x601b, 0x0000, 0x601f, 0x0000,
+	0x2061, 0x1100, 0x6003, 0x0001, 0x2061, 0x0100, 0x6043, 0x0090,
+	0x6043, 0x0010, 0x2009, 0x12b9, 0x200b, 0x0000, 0x2009, 0x002d,
+	0x2011, 0x4611, 0x080c, 0x654f, 0x012e, 0x00ce, 0x002e, 0x001e,
+	0x0005, 0x00e6, 0x0006, 0x0126, 0x2091, 0x8000, 0x0481, 0x2071,
+	0x0100, 0x080c, 0x7721, 0x2071, 0x0140, 0x7004, 0x9084, 0x4000,
+	0x0120, 0x7003, 0x1000, 0x7003, 0x0000, 0x080c, 0x574d, 0x01a8,
+	0x080c, 0x576b, 0x1190, 0x2001, 0x128f, 0x2003, 0xaaaa, 0x0016,
+	0x080c, 0x1d69, 0x2001, 0x1280, 0x2102, 0x001e, 0x2001, 0x1290,
+	0x2003, 0x0000, 0x080c, 0x5682, 0x0030, 0x2001, 0x0001, 0x080c,
+	0x1c36, 0x080c, 0x45d6, 0x012e, 0x000e, 0x00ee, 0x0005, 0x2001,
+	0x110d, 0x2004, 0xd0bc, 0x0158, 0x0026, 0x0036, 0x2011, 0x8017,
+	0x2001, 0x12b9, 0x201c, 0x080c, 0x37dc, 0x003e, 0x002e, 0x0005,
+	0x20a9, 0x0012, 0x20e9, 0x0001, 0x20a1, 0x1580, 0x080c, 0x46fa,
+	0x20e9, 0x0000, 0x2099, 0x026e, 0x0099, 0x20a9, 0x0020, 0x080c,
+	0x46f4, 0x2099, 0x0260, 0x20a1, 0x1592, 0x0051, 0x20a9, 0x000e,
+	0x080c, 0x46f7, 0x2099, 0x0260, 0x20a1, 0x15b2, 0x0009, 0x0005,
+	0x0016, 0x0026, 0x3410, 0x3308, 0x2104, 0x8007, 0x2012, 0x8108,
+	0x8210, 0x1f04, 0x467c, 0x002e, 0x001e, 0x0005, 0x080c, 0x7e9b,
+	0x20e1, 0x0001, 0x2099, 0x1500, 0x20e9, 0x0000, 0x20a1, 0x0240,
+	0x20a9, 0x000c, 0x4003, 0x0005, 0x080c, 0x7e9b, 0x080c, 0x46fa,
+	0x20e1, 0x0000, 0x2099, 0x0260, 0x20e9, 0x0000, 0x20a1, 0x0240,
+	0x20a9, 0x000c, 0x4003, 0x0005, 0x00c6, 0x0006, 0x2061, 0x0100,
+	0x810f, 0x2001, 0x1130, 0x2004, 0x9005, 0x1138, 0x2001, 0x1114,
+	0x2004, 0x9084, 0x00ff, 0x9105, 0x0010, 0x9185, 0x00f7, 0x604a,
+	0x000e, 0x00ce, 0x0005, 0x0016, 0x0046, 0x2001, 0x1153, 0x2004,
+	0xd0a4, 0x0158, 0x9006, 0x2020, 0x2009, 0x002a, 0x080c, 0xaaca,
+	0x2001, 0x110c, 0x200c, 0xc195, 0x2102, 0x2019, 0x002a, 0x2009,
+	0x0000, 0x080c, 0x2582, 0x004e, 0x001e, 0x0005, 0x080c, 0x45d6,
+	0x708b, 0x0000, 0x7083, 0x0000, 0x0005, 0x0006, 0x2001, 0x110c,
+	0x2004, 0xd09c, 0x0100, 0x000e, 0x0005, 0x0006, 0x0016, 0x0126,
+	0x2091, 0x8000, 0x2001, 0x0101, 0x200c, 0x918d, 0x0006, 0x2102,
+	0x012e, 0x001e, 0x000e, 0x0005, 0x2009, 0x0001, 0x0028, 0x2009,
+	0x0002, 0x0010, 0x2009, 0x0000, 0x6814, 0x9084, 0xffc0, 0x910d,
+	0x6916, 0x0005, 0x00f6, 0x0156, 0x0146, 0x01d6, 0x9006, 0x20a9,
+	0x0080, 0x20e9, 0x0001, 0x20a1, 0x1500, 0x4004, 0x2079, 0x1500,
+	0x7803, 0x2200, 0x7807, 0x00ef, 0x780f, 0x00ef, 0x7813, 0x0138,
+	0x7823, 0xffff, 0x7827, 0xffff, 0x01de, 0x014e, 0x015e, 0x00fe,
+	0x0005, 0x0156, 0x20a9, 0x00ff, 0x2009, 0x1000, 0x9006, 0x200a,
+	0x8108, 0x1f04, 0x4727, 0x015e, 0x0005, 0x00d6, 0x0036, 0x0156,
+	0x0136, 0x0146, 0x2069, 0x1152, 0x9006, 0x6002, 0x6007, 0x0707,
+	0x600a, 0x600e, 0x6012, 0x9198, 0x26c1, 0x231d, 0x939c, 0x00ff,
+	0x6316, 0x20a9, 0x0004, 0x9c98, 0x0006, 0x20e9, 0x0001, 0x23a0,
+	0x4004, 0x20a9, 0x0004, 0x9c98, 0x000a, 0x23a0, 0x4004, 0x603e,
+	0x6042, 0x604e, 0x6052, 0x6056, 0x605a, 0x605e, 0x6062, 0x6066,
+	0x606a, 0x606e, 0x6072, 0x6076, 0x607a, 0x608a, 0x608e, 0x6092,
+	0x6096, 0x609a, 0x609e, 0x60ae, 0x61a2, 0x00d6, 0x60a4, 0x906d,
+	0x0110, 0x080c, 0x0df6, 0x60a7, 0x0000, 0x00de, 0x9006, 0x604a,
+	0x6810, 0x603a, 0x680c, 0x6046, 0x6814, 0x9084, 0x00ff, 0x6042,
+	0x014e, 0x013e, 0x015e, 0x003e, 0x00de, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x6974, 0x6e78, 0x9684, 0x3fff, 0x9082, 0x4000, 0x1a04,
+	0x47f0, 0x918c, 0xff00, 0x810f, 0x9182, 0x00ff, 0x1a04, 0x47f5,
+	0x2001, 0x110c, 0x2004, 0x9084, 0x0003, 0x1904, 0x47fc, 0x9188,
+	0x1000, 0x2104, 0x9065, 0x0508, 0x6004, 0x9084, 0x00ff, 0x908e,
+	0x0006, 0x1500, 0x60a4, 0x900d, 0x1904, 0x4811, 0x6050, 0x900d,
+	0x1148, 0x6802, 0x2d00, 0x6052, 0x604e, 0x080c, 0x68a3, 0x9006,
+	0x012e, 0x0005, 0x2d00, 0x200a, 0x6803, 0x0000, 0x6052, 0x0ca8,
+	0x2001, 0x0005, 0x2009, 0x0000, 0x04e0, 0x2001, 0x0028, 0x2009,
+	0x0000, 0x04b8, 0x9082, 0x0006, 0x1298, 0x2001, 0x1133, 0x2004,
+	0xd0ac, 0x1158, 0x60a0, 0xd0bc, 0x1140, 0x6100, 0xd1fc, 0x0990,
+	0x2001, 0x0029, 0x2009, 0x1000, 0x0420, 0x2001, 0x0028, 0x00a8,
+	0x2009, 0x110c, 0x210c, 0xd18c, 0x0118, 0x2001, 0x0004, 0x0068,
+	0xd184, 0x0118, 0x2001, 0x0004, 0x0040, 0x2001, 0x0029, 0x6100,
+	0xd1fc, 0x0118, 0x2009, 0x1000, 0x0060, 0x2009, 0x0000, 0x0048,
+	0x2001, 0x0029, 0x2009, 0x0000, 0x0020, 0x2001, 0x0029, 0x2009,
+	0x0000, 0x9005, 0x012e, 0x0005, 0x2001, 0x110c, 0x2004, 0xd084,
+	0x19b8, 0x9188, 0x1000, 0x2104, 0x9065, 0x0990, 0x6004, 0x9084,
+	0x00ff, 0x908e, 0x0006, 0x1960, 0x6000, 0xd0c4, 0x0948, 0x0804,
+	0x47a2, 0x080c, 0x4cdc, 0x0904, 0x47b8, 0x0804, 0x47a6, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x6874, 0x8007, 0x9084, 0x00ff, 0x2008,
+	0x9182, 0x00ff, 0x1a04, 0x486a, 0x9188, 0x1000, 0x2104, 0x9065,
+	0x01c0, 0x6004, 0x9084, 0x00ff, 0x908e, 0x0006, 0x11a8, 0x2c70,
+	0x080c, 0x7ec8, 0x05e8, 0x2e00, 0x6012, 0x2d00, 0x6016, 0x600b,
+	0xffff, 0x6023, 0x000a, 0x2009, 0x0003, 0x080c, 0x7f4e, 0x9006,
+	0x0460, 0x2001, 0x0028, 0x0440, 0x9082, 0x0006, 0x1298, 0x2001,
+	0x1133, 0x2004, 0xd0ac, 0x1158, 0x60a0, 0xd0bc, 0x1140, 0x6100,
+	0xd1fc, 0x09e8, 0x2001, 0x0029, 0x2009, 0x1000, 0x00a8, 0x2001,
+	0x0028, 0x0090, 0x2009, 0x110c, 0x210c, 0xd18c, 0x0118, 0x2001,
+	0x0004, 0x0050, 0xd184, 0x0118, 0x2001, 0x0004, 0x0028, 0x2001,
+	0x0029, 0x0010, 0x2001, 0x0029, 0x9005, 0x012e, 0x00ee, 0x0005,
+	0x2001, 0x002c, 0x0cc8, 0x00f6, 0x00e6, 0x0126, 0x2091, 0x8000,
+	0x2011, 0x0000, 0x2079, 0x1100, 0x6974, 0x918c, 0xff00, 0x810f,
+	0x9182, 0x00ff, 0x1a04, 0x4a12, 0x2001, 0x110c, 0x2004, 0x9084,
+	0x0003, 0x1904, 0x49ff, 0x080c, 0x4b58, 0x1180, 0x6004, 0x9084,
+	0x00ff, 0x9082, 0x0006, 0x1250, 0x2001, 0x1133, 0x2004, 0xd0ac,
+	0x1904, 0x49f9, 0x60a0, 0xd0bc, 0x1904, 0x49f9, 0x6894, 0x90c6,
+	0x006f, 0x0158, 0x90c6, 0x005e, 0x0904, 0x4940, 0x90c6, 0x0064,
+	0x0904, 0x4974, 0x2008, 0x0804, 0x4909, 0x6998, 0x2140, 0x918c,
+	0xff00, 0x810f, 0x78cc, 0xd0ac, 0x1120, 0x9182, 0x0080, 0x0a04,
+	0x4909, 0x9182, 0x00ff, 0x1a04, 0x4909, 0x6aa0, 0x6b9c, 0x786c,
+	0x9306, 0x1168, 0x7870, 0x924e, 0x1120, 0x2208, 0x2310, 0x0804,
+	0x4909, 0x99cc, 0xff00, 0x1118, 0x2208, 0x2310, 0x04d0, 0x080c,
+	0x36d2, 0x2c70, 0x05f0, 0x2009, 0x0000, 0x2011, 0x0000, 0x90c6,
+	0x4000, 0x1500, 0x0006, 0x2e60, 0x080c, 0x4d21, 0x1108, 0xc185,
+	0x7000, 0xd0bc, 0x0108, 0xc18d, 0x20a9, 0x0004, 0x9d80, 0x0031,
+	0x20a0, 0x9e80, 0x0006, 0x2098, 0x080c, 0x4678, 0x20a9, 0x0004,
+	0x9d80, 0x0035, 0x20a0, 0x9e80, 0x000a, 0x2098, 0x080c, 0x4678,
+	0x000e, 0x0088, 0x90c6, 0x4007, 0x1110, 0x2408, 0x0060, 0x90c6,
+	0x4008, 0x1118, 0x2708, 0x2610, 0x0030, 0x90c6, 0x4009, 0x1108,
+	0x0010, 0x2001, 0x4006, 0x6896, 0x699a, 0x6a9e, 0x2001, 0x0030,
+	0x0450, 0x080c, 0x7ec8, 0x1138, 0x2001, 0x4005, 0x2009, 0x0003,
+	0x2011, 0x0000, 0x0c80, 0x2e00, 0x6012, 0x080c, 0x99cc, 0x2d00,
+	0x6016, 0x6023, 0x0001, 0x6868, 0xd88c, 0x0108, 0xc0f5, 0x686a,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x25ad, 0x012e, 0x2001, 0x0000,
+	0x080c, 0x4aa1, 0x2001, 0x0002, 0x080c, 0x4ab3, 0x2009, 0x0002,
+	0x080c, 0x7f4e, 0x9006, 0x9005, 0x012e, 0x00ee, 0x00fe, 0x0005,
+	0x7800, 0x9086, 0x0003, 0x0118, 0x2009, 0x0007, 0x0448, 0x6e98,
+	0x860f, 0x918c, 0x00ff, 0x96b4, 0x00ff, 0x080c, 0x4b58, 0x0120,
+	0x2009, 0x000a, 0x0804, 0x4909, 0x9186, 0x007f, 0x0148, 0x6004,
+	0x9084, 0x00ff, 0x9086, 0x0006, 0x0118, 0x2009, 0x0009, 0x0080,
+	0x00d6, 0x080c, 0x0dc6, 0x1120, 0x00de, 0x2009, 0x0002, 0x0040,
+	0x2d00, 0x00de, 0x6806, 0x080c, 0x977b, 0x1960, 0x2009, 0x0003,
+	0x2001, 0x4005, 0x0804, 0x490b, 0x6e98, 0x860f, 0x918c, 0x00ff,
+	0x96b4, 0x00ff, 0x080c, 0x4b58, 0x0120, 0x2009, 0x000a, 0x0804,
+	0x4909, 0x00d6, 0x080c, 0x0dc6, 0x1128, 0x00de, 0x2009, 0x0002,
+	0x0804, 0x49dd, 0x2d00, 0x00de, 0x6806, 0x00d6, 0x6804, 0x2068,
+	0x20a9, 0x002b, 0x20e1, 0x0001, 0x2c98, 0x9de8, 0x0002, 0x20e9,
+	0x0001, 0x2da0, 0x4003, 0x20a9, 0x0004, 0x9d80, 0x0006, 0x20a0,
+	0x9c80, 0x0006, 0x2098, 0x080c, 0x4678, 0x20a9, 0x0004, 0x9d80,
+	0x000a, 0x20a0, 0x9c80, 0x000a, 0x2098, 0x080c, 0x4678, 0x2d10,
+	0x00de, 0x687b, 0x0000, 0x6883, 0x0000, 0x6897, 0x4000, 0xd684,
+	0x1170, 0x2001, 0x1153, 0x2004, 0xd0b4, 0x1118, 0x689b, 0x000b,
+	0x0400, 0x6000, 0xd08c, 0x0118, 0x689b, 0x000c, 0x00d0, 0x6004,
+	0x9084, 0x00ff, 0x9086, 0x0006, 0x0118, 0x689b, 0x0009, 0x0088,
+	0x7800, 0x9086, 0x0003, 0x0118, 0x689b, 0x0007, 0x0050, 0x080c,
+	0x9744, 0x1904, 0x493a, 0x2009, 0x0003, 0x2001, 0x4005, 0x0804,
+	0x490b, 0x687b, 0x0030, 0x6897, 0x4005, 0x2200, 0x2009, 0x002b,
+	0x6aa0, 0x6b9c, 0x6ca8, 0x6da4, 0x2031, 0x0000, 0x2039, 0x0001,
+	0x2041, 0x0f7e, 0x080c, 0x817f, 0x1904, 0x493a, 0x2009, 0x0002,
+	0x0c20, 0x2001, 0x0028, 0x2009, 0x0000, 0x0804, 0x493b, 0x2009,
+	0x110c, 0x210c, 0xd18c, 0x0118, 0x2001, 0x0004, 0x0038, 0xd184,
+	0x0118, 0x2001, 0x0004, 0x0010, 0x2001, 0x0029, 0x2009, 0x0000,
+	0x0804, 0x493b, 0x2001, 0x0029, 0x2009, 0x0000, 0x0804, 0x493b,
+	0x6974, 0x6e78, 0x9684, 0x3fff, 0x9082, 0x4000, 0x1658, 0x918c,
+	0xff00, 0x810f, 0x9182, 0x00ff, 0x1280, 0x9188, 0x1000, 0x2104,
+	0x9065, 0x0158, 0x6004, 0x9084, 0x00ff, 0x908e, 0x0006, 0x1150,
+	0x0491, 0x080c, 0x4c6e, 0x9006, 0x00c8, 0x2001, 0x0028, 0x2009,
+	0x0000, 0x00a0, 0x9082, 0x0006, 0x1240, 0x6100, 0xd1fc, 0x0d80,
+	0x2001, 0x0029, 0x2009, 0x1000, 0x0048, 0x2001, 0x0029, 0x2009,
+	0x0000, 0x0020, 0x2001, 0x0029, 0x2009, 0x0000, 0x9005, 0x0005,
+	0x0126, 0x2091, 0x8000, 0x6050, 0x900d, 0x0138, 0x2d00, 0x200a,
+	0x6803, 0x0000, 0x6052, 0x012e, 0x0005, 0x2d00, 0x6052, 0x604e,
+	0x6803, 0x0000, 0x0cc0, 0x0126, 0x2091, 0x8000, 0x604c, 0x9005,
+	0x0170, 0x00e6, 0x2071, 0x12dc, 0x7004, 0x9086, 0x0002, 0x0168,
+	0x00ee, 0x604c, 0x6802, 0x2d00, 0x604e, 0x012e, 0x0005, 0x2d00,
+	0x6052, 0x604e, 0x6803, 0x0000, 0x0cc0, 0x701c, 0x9c06, 0x1d80,
+	0x604c, 0x2070, 0x7000, 0x6802, 0x2d00, 0x7002, 0x00ee, 0x012e,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x604c, 0x906d, 0x0130, 0x6800,
+	0x9005, 0x1108, 0x6052, 0x604e, 0x9d05, 0x012e, 0x0005, 0x604c,
+	0x906d, 0x0130, 0x6800, 0x9005, 0x1108, 0x6052, 0x604e, 0x9d05,
+	0x0005, 0x0126, 0x00c6, 0x0026, 0x2091, 0x8000, 0x6210, 0x2260,
+	0x6200, 0x9005, 0x0110, 0xc285, 0x0008, 0xc284, 0x6202, 0x002e,
+	0x00ce, 0x012e, 0x0005, 0x0126, 0x00c6, 0x2091, 0x8000, 0x6210,
+	0x2260, 0x6204, 0x0006, 0x9086, 0x0006, 0x1180, 0x609c, 0xd0ac,
+	0x0168, 0x2001, 0x1153, 0x2004, 0xd0a4, 0x0140, 0x9284, 0xff00,
+	0x8007, 0x9086, 0x0007, 0x1110, 0x2011, 0x0600, 0x000e, 0x9294,
+	0xff00, 0x9215, 0x6206, 0x0006, 0x9086, 0x0006, 0x1128, 0x6290,
+	0x82ff, 0x1110, 0x080c, 0x0cf1, 0x000e, 0x00ce, 0x012e, 0x0005,
+	0x0126, 0x00c6, 0x2091, 0x8000, 0x6210, 0x2260, 0x6204, 0x0006,
+	0x9086, 0x0006, 0x1178, 0x609c, 0xd0a4, 0x0160, 0x2001, 0x1153,
+	0x2004, 0xd0ac, 0x1138, 0x9284, 0x00ff, 0x9086, 0x0007, 0x1110,
+	0x2011, 0x0006, 0x000e, 0x9294, 0x00ff, 0x8007, 0x9215, 0x6206,
+	0x00ce, 0x012e, 0x0005, 0x0026, 0x9182, 0x00ff, 0x0218, 0x9085,
+	0x0001, 0x00a0, 0x9190, 0x1000, 0x2204, 0x9065, 0x1170, 0x0016,
+	0x00d6, 0x080c, 0x0dc6, 0x2d60, 0x00de, 0x001e, 0x0d80, 0x2c00,
+	0x2012, 0x60a7, 0x0000, 0x080c, 0x472d, 0x9006, 0x002e, 0x0005,
+	0x0126, 0x2091, 0x8000, 0x0026, 0x9182, 0x00ff, 0x0218, 0x9085,
+	0x0001, 0x0458, 0x00d6, 0x9190, 0x1000, 0x2204, 0x906d, 0x0518,
+	0x2013, 0x0000, 0x00d6, 0x00c6, 0x2d60, 0x60a4, 0x906d, 0x0110,
+	0x080c, 0x0df6, 0x00ce, 0x00de, 0x00d6, 0x00c6, 0x68ac, 0x2060,
+	0x8cff, 0x0168, 0x600c, 0x0006, 0x6014, 0x2068, 0x080c, 0x95d2,
+	0x0110, 0x080c, 0x0e06, 0x080c, 0x7f1e, 0x00ce, 0x0c88, 0x00ce,
+	0x00de, 0x080c, 0x0df6, 0x00de, 0x9006, 0x002e, 0x012e, 0x0005,
+	0x0016, 0x9182, 0x00ff, 0x0218, 0x9085, 0x0001, 0x0030, 0x9188,
+	0x1000, 0x2104, 0x9065, 0x0dc0, 0x9006, 0x001e, 0x0005, 0x00d6,
+	0x0156, 0x0136, 0x0146, 0x600b, 0x0000, 0x600f, 0x0000, 0x6000,
+	0xc08c, 0x6002, 0x080c, 0x5745, 0x1500, 0x60a0, 0x9086, 0x007e,
+	0x0130, 0x2001, 0x1133, 0x2004, 0xd0ac, 0x11b8, 0x0078, 0x7040,
+	0xd0e4, 0x0198, 0x00c6, 0x2061, 0x12a2, 0x7048, 0x2062, 0x704c,
+	0x6006, 0x7050, 0x600a, 0x7054, 0x600e, 0x00ce, 0x703c, 0x2069,
+	0x0140, 0x6886, 0x2069, 0x1100, 0x68a2, 0x7040, 0x605e, 0x7048,
+	0x6062, 0x6138, 0x910a, 0x0208, 0x603a, 0x704c, 0x6066, 0x20e1,
+	0x0000, 0x2099, 0x0276, 0x9c88, 0x000a, 0x20e9, 0x0001, 0x21a0,
+	0x20a9, 0x0004, 0x4003, 0x2099, 0x027a, 0x9c88, 0x0006, 0x21a0,
+	0x20a9, 0x0004, 0x4003, 0x2069, 0x0200, 0x6817, 0x0001, 0x7040,
+	0x606a, 0x7144, 0x616e, 0x7048, 0x6072, 0x7050, 0x6076, 0x2069,
+	0x0200, 0x6817, 0x0000, 0x60a0, 0x9086, 0x007e, 0x1110, 0x7144,
+	0x616e, 0x9182, 0x0211, 0x1218, 0x2009, 0x0008, 0x0400, 0x9182,
+	0x0259, 0x1218, 0x2009, 0x0007, 0x00d0, 0x9182, 0x02c1, 0x1218,
+	0x2009, 0x0006, 0x00a0, 0x9182, 0x0349, 0x1218, 0x2009, 0x0005,
+	0x0070, 0x9182, 0x0421, 0x1218, 0x2009, 0x0004, 0x0040, 0x9182,
+	0x0581, 0x1218, 0x2009, 0x0003, 0x0010, 0x2009, 0x0002, 0x6192,
+	0x014e, 0x013e, 0x015e, 0x00de, 0x0005, 0x0016, 0x0026, 0x00e6,
+	0x2071, 0x0260, 0x7034, 0x6896, 0x703c, 0x689a, 0x7054, 0x689e,
+	0x6a00, 0x2009, 0x1172, 0x210c, 0xd0bc, 0x0120, 0xd1ec, 0x0110,
+	0xc2ad, 0x0008, 0xc2ac, 0xd0c4, 0x0120, 0xd1e4, 0x0110, 0xc2bd,
+	0x0008, 0xc2bc, 0x6a02, 0x00ee, 0x002e, 0x001e, 0x0005, 0x00d6,
+	0x0126, 0x2091, 0x8000, 0x60a4, 0x906d, 0x01c0, 0x6900, 0x81ff,
+	0x1540, 0x6a04, 0x9282, 0x0010, 0x1648, 0x9d88, 0x0004, 0x20a9,
+	0x0010, 0x2104, 0x9086, 0xffff, 0x0128, 0x8108, 0x1f04, 0x4c29,
+	0x080c, 0x0cf1, 0x260a, 0x8210, 0x6a06, 0x0098, 0x080c, 0x0ddf,
+	0x01a8, 0x2d00, 0x60a6, 0x6803, 0x0000, 0x9d88, 0x0004, 0x20a9,
+	0x0010, 0x200b, 0xffff, 0x8108, 0x1f04, 0x4c41, 0x6807, 0x0001,
+	0x6e12, 0x9085, 0x0001, 0x012e, 0x00de, 0x0005, 0x9006, 0x0cd8,
+	0x0126, 0x2091, 0x8000, 0x00d6, 0x60a4, 0x900d, 0x01a0, 0x2168,
+	0x6800, 0x9005, 0x1160, 0x080c, 0x4cdc, 0x1168, 0x200b, 0xffff,
+	0x6804, 0x908a, 0x0002, 0x0218, 0x8001, 0x6806, 0x0020, 0x080c,
+	0x0df6, 0x60a7, 0x0000, 0x00de, 0x012e, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x68a3, 0x012e, 0x0005, 0x901e, 0x0010, 0x2019,
+	0x0001, 0x900e, 0x0126, 0x2091, 0x8000, 0x604c, 0x2068, 0x6000,
+	0xd0dc, 0x1170, 0x8dff, 0x01e8, 0x83ff, 0x0120, 0x6878, 0x9606,
+	0x0158, 0x0030, 0x686c, 0x9406, 0x1118, 0x6870, 0x9506, 0x0120,
+	0x2d08, 0x6800, 0x2068, 0x0c70, 0x6a00, 0x604c, 0x9d06, 0x1110,
+	0x624e, 0x0018, 0x9180, 0x0000, 0x2202, 0x82ff, 0x1110, 0x6152,
+	0x8dff, 0x012e, 0x0005, 0x9016, 0x0489, 0x1110, 0x2011, 0x0001,
+	0x0005, 0x080c, 0x4d21, 0x0118, 0x080c, 0x9685, 0x0010, 0x9085,
+	0x0001, 0x0005, 0x080c, 0x4d21, 0x0118, 0x080c, 0x9620, 0x0010,
+	0x9085, 0x0001, 0x0005, 0x080c, 0x4d21, 0x0118, 0x080c, 0x9668,
+	0x0010, 0x9085, 0x0001, 0x0005, 0x080c, 0x4d21, 0x0118, 0x080c,
+	0x963c, 0x0010, 0x9085, 0x0001, 0x0005, 0x080c, 0x4d21, 0x0118,
+	0x080c, 0x96a1, 0x0010, 0x9085, 0x0001, 0x0005, 0x60a4, 0x900d,
+	0x1118, 0x9085, 0x0001, 0x0005, 0x00e6, 0x2170, 0x7000, 0x9005,
+	0x1168, 0x20a9, 0x0010, 0x9e88, 0x0004, 0x2104, 0x9606, 0x0130,
+	0x8108, 0x1f04, 0x4ce5, 0x9085, 0x0001, 0x0008, 0x9006, 0x00ee,
+	0x0005, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a4, 0x906d, 0x1128,
+	0x080c, 0x0ddf, 0x01a0, 0x2d00, 0x60a6, 0x6803, 0x0001, 0x6807,
+	0x0000, 0x9d88, 0x0004, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108,
+	0x1f04, 0x4d05, 0x9085, 0x0001, 0x012e, 0x00de, 0x0005, 0x9006,
+	0x0cd8, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a4, 0x906d, 0x0130,
+	0x60a7, 0x0000, 0x080c, 0x0df6, 0x9085, 0x0001, 0x012e, 0x00de,
+	0x0005, 0x609c, 0xd0a4, 0x0005, 0x00f6, 0x080c, 0x5745, 0x01b0,
+	0x71b4, 0x81ff, 0x1198, 0x71cc, 0xd19c, 0x0180, 0x2001, 0x007e,
+	0x9080, 0x1000, 0x2004, 0x907d, 0x0148, 0x7804, 0x9084, 0x00ff,
+	0x9086, 0x0006, 0x1118, 0x7800, 0xc0ed, 0x7802, 0x2079, 0x1152,
+	0x7804, 0xd0a4, 0x01e8, 0x0156, 0x00c6, 0x20a9, 0x007f, 0x2009,
+	0x0000, 0x0016, 0x080c, 0x4b58, 0x1168, 0x6004, 0x9084, 0xff00,
+	0x8007, 0x9096, 0x0004, 0x0118, 0x9086, 0x0006, 0x1118, 0x6000,
+	0xc0ed, 0x6002, 0x001e, 0x8108, 0x1f04, 0x4d49, 0x00ce, 0x015e,
+	0x080c, 0x4de0, 0x0120, 0x2001, 0x12a5, 0x200c, 0x0038, 0x2079,
+	0x1152, 0x7804, 0xd0a4, 0x0130, 0x2009, 0x07d0, 0x2011, 0x4d74,
+	0x080c, 0x65e1, 0x00fe, 0x0005, 0x2011, 0x4d74, 0x080c, 0x655b,
+	0x080c, 0x4de0, 0x01f0, 0x2001, 0x107e, 0x2004, 0x9080, 0x0000,
+	0x200c, 0xc1ec, 0x2102, 0x2001, 0x1153, 0x2004, 0xd0a4, 0x0130,
+	0x2009, 0x07d0, 0x2011, 0x4d74, 0x080c, 0x65e1, 0x00e6, 0x2071,
+	0x1100, 0x706f, 0x0000, 0x7073, 0x0000, 0x080c, 0x23cd, 0x00ee,
+	0x04b0, 0x0156, 0x00c6, 0x20a9, 0x007f, 0x2009, 0x0000, 0x0016,
+	0x080c, 0x4b58, 0x1530, 0x6000, 0xd0ec, 0x0518, 0x0046, 0x62a0,
+	0x9294, 0x00ff, 0x8227, 0x9006, 0x2009, 0x0029, 0x080c, 0xaaca,
+	0x6000, 0xc0e5, 0xc0ec, 0x6002, 0x6004, 0x9084, 0x00ff, 0x9085,
+	0x0700, 0x6006, 0x2019, 0x0029, 0x080c, 0x69ca, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x68fe, 0x2009, 0x0000, 0x080c, 0xa85f, 0x007e,
+	0x004e, 0x001e, 0x8108, 0x1f04, 0x4d9f, 0x00ce, 0x015e, 0x0005,
+	0x00c6, 0x6010, 0x2060, 0x6000, 0xc0ec, 0x6002, 0x00ce, 0x0005,
+	0x7810, 0x2004, 0xd0ac, 0x0005, 0x7810, 0x2004, 0xd0bc, 0x0005,
+	0x00f6, 0x2001, 0x107e, 0x2004, 0x907d, 0x0110, 0x7800, 0xd0ec,
+	0x00fe, 0x0005, 0x0126, 0x0026, 0x2091, 0x8000, 0x6200, 0x9005,
+	0x0110, 0xc2fd, 0x0008, 0xc2fc, 0x6202, 0x002e, 0x012e, 0x0005,
+	0x2011, 0x1133, 0x2204, 0xd0cc, 0x0138, 0x2001, 0x12a3, 0x200c,
+	0x2011, 0x4e05, 0x080c, 0x65e1, 0x0005, 0x2011, 0x4e05, 0x080c,
+	0x655b, 0x2011, 0x1133, 0x2204, 0xc0cc, 0x2012, 0x0005, 0x2071,
+	0x1228, 0x7003, 0x0001, 0x7007, 0x0000, 0x7013, 0x0000, 0x7017,
+	0x0000, 0x701b, 0x0000, 0x701f, 0x0000, 0x700b, 0x0000, 0x7047,
+	0x0000, 0x2071, 0x126e, 0x7003, 0x1228, 0x7007, 0x0000, 0x700b,
+	0x0000, 0x700f, 0x0001, 0x7013, 0x124e, 0x7017, 0x0020, 0x701b,
+	0x0040, 0x703b, 0x0000, 0x2001, 0x124a, 0x2003, 0x0000, 0x0005,
+	0x0016, 0x00e6, 0x2071, 0x124b, 0x900e, 0x710a, 0x2001, 0x1153,
+	0x2004, 0xd0fc, 0x1148, 0x2001, 0x1153, 0x2004, 0x900e, 0xd09c,
+	0x0108, 0x8108, 0x7102, 0x04c0, 0x2001, 0x1172, 0x200c, 0x9184,
+	0x000f, 0x0002, 0x4e43, 0x4e43, 0x4e43, 0x4e43, 0x4e43, 0x4e62,
+	0x4e43, 0x4e43, 0x4e70, 0x4e43, 0x4e43, 0x4e43, 0x4e43, 0x4e43,
+	0x4e43, 0x4e43, 0x7003, 0x0003, 0x2009, 0x1173, 0x210c, 0x9184,
+	0xff00, 0x8007, 0x9005, 0x1110, 0x2001, 0x0002, 0x7006, 0x00a0,
+	0x7003, 0x0004, 0x0136, 0x0146, 0x0156, 0x20e1, 0x0001, 0x2099,
+	0x1176, 0x20e9, 0x0001, 0x20a1, 0x1278, 0x20a9, 0x0004, 0x4003,
+	0x015e, 0x014e, 0x013e, 0x0000, 0x00ee, 0x001e, 0x0005, 0x00e6,
+	0x2071, 0x0050, 0x684c, 0x9005, 0x1150, 0x00e6, 0x2071, 0x1228,
+	0x7028, 0xc085, 0x702a, 0x00ee, 0x9085, 0x0001, 0x04e8, 0x6844,
+	0x9005, 0x01a8, 0x2009, 0x0000, 0x0156, 0x20a9, 0x0006, 0x8003,
+	0x81f5, 0x3e08, 0x1f04, 0x4e9f, 0x015e, 0x6a60, 0x9200, 0x7002,
+	0x6864, 0x9101, 0x7006, 0x7013, 0x0000, 0x7017, 0x0000, 0x6860,
+	0x7002, 0x6864, 0x7006, 0x6868, 0x700a, 0x686c, 0x700e, 0x6844,
+	0x9005, 0x1120, 0x7013, 0x0000, 0x7017, 0x0000, 0x684c, 0x701a,
+	0x701c, 0x9085, 0x0040, 0x701e, 0x7037, 0x0019, 0x702b, 0x0001,
+	0x00e6, 0x2071, 0x1228, 0x7028, 0xc084, 0x702a, 0x7007, 0x0001,
+	0x700b, 0x0000, 0x00ee, 0x9006, 0x00ee, 0x0005, 0x6868, 0xd0fc,
+	0x11d0, 0x00e6, 0x0026, 0x2001, 0x124b, 0x2004, 0x9005, 0x0904,
+	0x50aa, 0x687c, 0xd0bc, 0x1904, 0x50aa, 0x6978, 0x6874, 0x9105,
+	0x1904, 0x50aa, 0x2001, 0x124b, 0x2004, 0x0002, 0x50aa, 0x4f17,
+	0x4f4b, 0x4f4b, 0x53ec, 0x0005, 0x6868, 0xd0fc, 0x11f8, 0x00e6,
+	0x0026, 0x2009, 0x124b, 0x210c, 0x81ff, 0x0904, 0x50aa, 0x687c,
+	0xd0cc, 0x0904, 0x50aa, 0x6880, 0x9084, 0x00ff, 0x9086, 0x0001,
+	0x1904, 0x50aa, 0x9186, 0x0003, 0x05f0, 0x9186, 0x0004, 0x0904,
+	0x53ec, 0x684f, 0x8021, 0x6853, 0x0017, 0x0028, 0x0005, 0x684f,
+	0x8020, 0x6853, 0x0016, 0x2071, 0x1228, 0x701c, 0x9005, 0x1904,
+	0x5235, 0x0e04, 0x5278, 0x2071, 0x0000, 0x684c, 0x7082, 0x6850,
+	0x7032, 0x686c, 0x7086, 0x7036, 0x6870, 0x708a, 0x2091, 0x4080,
+	0x2071, 0x1100, 0x2011, 0x0001, 0x6804, 0x900d, 0x702c, 0x1148,
+	0x206a, 0x2d00, 0x702e, 0x70b0, 0x9200, 0x70b2, 0x002e, 0x00ee,
+	0x0005, 0x00d6, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff,
+	0x1dc8, 0x00de, 0x0c68, 0x684f, 0x0000, 0x00f6, 0x2079, 0x0050,
+	0x2071, 0x1228, 0x206b, 0x0000, 0x7010, 0x9005, 0x1904, 0x5039,
+	0x782c, 0x908c, 0x0780, 0x190c, 0x542a, 0x8004, 0x8004, 0x8004,
+	0x9084, 0x0003, 0x0002, 0x4f69, 0x5039, 0x4f8f, 0x4fd2, 0x080c,
+	0x0cf1, 0x2071, 0x1100, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x7822,
+	0x6804, 0x900d, 0x1170, 0x2071, 0x12ef, 0x703c, 0x9005, 0x1328,
+	0x2001, 0x124c, 0x2004, 0x8005, 0x703e, 0x00fe, 0x002e, 0x00ee,
+	0x0005, 0x9016, 0x702c, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00,
+	0x81ff, 0x1dc8, 0x702e, 0x70b0, 0x9200, 0x70b2, 0x0c20, 0x2071,
+	0x1100, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x7822, 0x6804, 0x900d,
+	0x1558, 0x7824, 0x00e6, 0x2071, 0x0040, 0x712c, 0xd19c, 0x1118,
+	0x7022, 0x00ee, 0x0060, 0x00ee, 0xc0d4, 0x8006, 0x8006, 0x806f,
+	0x702c, 0x206a, 0x2d00, 0x702e, 0x70b0, 0x8000, 0x70b2, 0x782c,
+	0x9094, 0x0780, 0x190c, 0x542a, 0xd0a4, 0x1d18, 0x2071, 0x12ef,
+	0x703c, 0x9005, 0x1328, 0x2001, 0x124c, 0x2004, 0x8005, 0x703e,
+	0x00fe, 0x002e, 0x00ee, 0x0005, 0x9016, 0x702c, 0x2168, 0x6904,
+	0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e, 0x70b0, 0x9200,
+	0x70b2, 0x0838, 0x00d6, 0x00e6, 0x7824, 0xc0d4, 0x8006, 0x8006,
+	0x806f, 0x2071, 0x1100, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70b0,
+	0x8000, 0x70b2, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a, 0xd0a4,
+	0x1d58, 0x00ee, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a, 0xd09c,
+	0x11b8, 0x00de, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x7822, 0x6804,
+	0x900d, 0x1560, 0x2071, 0x12ef, 0x703c, 0x9005, 0x1328, 0x2001,
+	0x124c, 0x2004, 0x8005, 0x703e, 0x00fe, 0x002e, 0x00ee, 0x0005,
+	0x00de, 0x2d08, 0x7010, 0x8000, 0x7012, 0x7018, 0x906d, 0x711a,
+	0x0110, 0x6902, 0x0008, 0x711e, 0x2168, 0x6804, 0x900d, 0x1170,
+	0x2071, 0x12ef, 0x703c, 0x9005, 0x1328, 0x2001, 0x124c, 0x2004,
+	0x8005, 0x703e, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x2071, 0x1100,
+	0x9016, 0x702c, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff,
+	0x1dc8, 0x702e, 0x70b0, 0x9200, 0x70b2, 0x00fe, 0x002e, 0x00ee,
+	0x0005, 0x2d08, 0x7010, 0x8000, 0x7012, 0x7018, 0x906d, 0x711a,
+	0x0110, 0x6902, 0x0008, 0x711e, 0x2168, 0x6804, 0x900d, 0x1904,
+	0x5092, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a, 0xd09c, 0x11b0,
+	0x701c, 0x906d, 0x0198, 0x7010, 0x8001, 0x7012, 0x1108, 0x701a,
+	0x2d04, 0x701e, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x7822, 0x782c,
+	0x9094, 0x0780, 0x190c, 0x542a, 0xd09c, 0x0d50, 0x782c, 0x9094,
+	0x0780, 0x190c, 0x542a, 0xd0a4, 0x01b8, 0x00e6, 0x7824, 0xc0d4,
+	0x8006, 0x8006, 0x806f, 0x2071, 0x1100, 0x702c, 0x206a, 0x2d00,
+	0x702e, 0x70b0, 0x8000, 0x70b2, 0x782c, 0x9094, 0x0780, 0x190c,
+	0x542a, 0xd0a4, 0x1d58, 0x00ee, 0x2071, 0x12ef, 0x703c, 0x9005,
+	0x1328, 0x2001, 0x124c, 0x2004, 0x8005, 0x703e, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x00e6, 0x2071, 0x1100, 0x9016, 0x702c, 0x2168,
+	0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e, 0x70b0,
+	0x9200, 0x70b2, 0x00ee, 0x0804, 0x5049, 0x6868, 0xd0fc, 0x1500,
+	0x00e6, 0x0026, 0x684f, 0x0000, 0x00f6, 0x2079, 0x0050, 0x2071,
+	0x1228, 0x206b, 0x0000, 0x7010, 0x9005, 0x1904, 0x51b5, 0x782c,
+	0x908c, 0x0780, 0x190c, 0x542a, 0x8004, 0x8004, 0x8004, 0x9084,
+	0x0003, 0x0002, 0x50c9, 0x51b5, 0x50e5, 0x514a, 0x080c, 0x0cf1,
+	0x0005, 0x2071, 0x1100, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x7822,
+	0x6804, 0x900d, 0x1120, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x9016,
+	0x702c, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8,
+	0x702e, 0x70b0, 0x9200, 0x70b2, 0x0c70, 0x2071, 0x1100, 0x8d07,
+	0x8005, 0x8005, 0xc0d5, 0x7822, 0x6804, 0x900d, 0x1904, 0x513b,
+	0x7830, 0x8007, 0x9084, 0x001f, 0x9082, 0x0005, 0x1220, 0x00fe,
+	0x002e, 0x00ee, 0x0005, 0x7824, 0x00e6, 0x2071, 0x0040, 0x712c,
+	0xd19c, 0x1118, 0x7022, 0x00ee, 0x0060, 0x00ee, 0xc0d4, 0x8006,
+	0x8006, 0x806f, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70b0, 0x8000,
+	0x70b2, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a, 0xd0a4, 0x1d18,
+	0x0e04, 0x5132, 0x7838, 0x7938, 0x910e, 0x1de0, 0x2069, 0x0000,
+	0x6836, 0x6833, 0x0013, 0x2001, 0x1239, 0x200c, 0xc184, 0x2102,
+	0x2091, 0x4080, 0x2009, 0x124a, 0x200b, 0x0000, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x2001, 0x1239, 0x200c, 0xc185, 0x2102, 0x00fe,
+	0x002e, 0x00ee, 0x0005, 0x9016, 0x702c, 0x2168, 0x6904, 0x206a,
+	0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e, 0x70b0, 0x9200, 0x70b2,
+	0x0804, 0x50fb, 0x00d6, 0x00e6, 0x7824, 0xc0d4, 0x8006, 0x8006,
+	0x806f, 0x2071, 0x1100, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70b0,
+	0x8000, 0x70b2, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a, 0xd0a4,
+	0x1d58, 0x00ee, 0x0e04, 0x518a, 0x7838, 0x7938, 0x910e, 0x1de0,
+	0x2069, 0x0000, 0x6836, 0x6833, 0x0013, 0x7044, 0xc084, 0x7046,
+	0x2091, 0x4080, 0x2009, 0x124a, 0x200b, 0x0000, 0x782c, 0x9094,
+	0x0780, 0x190c, 0x542a, 0xd09c, 0x1188, 0x00de, 0x8d07, 0x8005,
+	0x8005, 0xc0d5, 0x7822, 0x6804, 0x900d, 0x11e0, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x7044, 0xc085, 0x7046, 0x0c40, 0x00de, 0x2d08,
+	0x7010, 0x8000, 0x7012, 0x7018, 0x906d, 0x711a, 0x0110, 0x6902,
+	0x0008, 0x711e, 0x2168, 0x6804, 0x900d, 0x1120, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x2071, 0x1100, 0x9016, 0x702c, 0x2168, 0x6904,
+	0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e, 0x70b0, 0x9200,
+	0x70b2, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x2d08, 0x7010, 0x8000,
+	0x7012, 0x7018, 0x906d, 0x711a, 0x0110, 0x6902, 0x0008, 0x711e,
+	0x2168, 0x6804, 0x900d, 0x1904, 0x5222, 0x782c, 0x9094, 0x0780,
+	0x190c, 0x542a, 0xd09c, 0x11c8, 0x701c, 0x906d, 0x01b0, 0x684c,
+	0x9005, 0x1198, 0x7010, 0x8001, 0x7012, 0x1108, 0x701a, 0x2d04,
+	0x701e, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x7822, 0x782c, 0x9094,
+	0x0780, 0x190c, 0x542a, 0xd09c, 0x0d38, 0x782c, 0x9094, 0x0780,
+	0x190c, 0x542a, 0xd0a4, 0x0590, 0x00e6, 0x7824, 0xc0d4, 0x8006,
+	0x8006, 0x806f, 0x2071, 0x1100, 0x702c, 0x206a, 0x2d00, 0x702e,
+	0x70b0, 0x8000, 0x70b2, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a,
+	0xd0a4, 0x1d58, 0x00ee, 0x0e04, 0x521b, 0x7838, 0x7938, 0x910e,
+	0x1de0, 0x2069, 0x0000, 0x6836, 0x6833, 0x0013, 0x7044, 0xc084,
+	0x7046, 0x2091, 0x4080, 0x2009, 0x124a, 0x200b, 0x0000, 0x00fe,
+	0x002e, 0x00ee, 0x0005, 0x7044, 0xc085, 0x7046, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x00e6, 0x2071, 0x1100, 0x9016, 0x702c, 0x2168,
+	0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e, 0x70b0,
+	0x9200, 0x70b2, 0x00ee, 0x0804, 0x51c5, 0x2071, 0x1228, 0x206b,
+	0x0000, 0x2d08, 0x7010, 0x8000, 0x7012, 0x7018, 0x906d, 0x711a,
+	0x0110, 0x6902, 0x0008, 0x711e, 0x2168, 0x6804, 0x900d, 0x1128,
+	0x1e04, 0x525e, 0x002e, 0x00ee, 0x0005, 0x2071, 0x1100, 0x9016,
+	0x702c, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8,
+	0x702e, 0x70b0, 0x9200, 0x70b2, 0x0e04, 0x524a, 0x2071, 0x1228,
+	0x701c, 0x2068, 0x684c, 0x900d, 0x0d28, 0x2071, 0x0000, 0x7182,
+	0x6850, 0x7032, 0x686c, 0x7086, 0x7036, 0x6870, 0x708a, 0x2091,
+	0x4080, 0x2071, 0x1228, 0x080c, 0x5416, 0x002e, 0x00ee, 0x0005,
+	0x2071, 0x1228, 0x206b, 0x0000, 0x2d08, 0x7010, 0x8000, 0x7012,
+	0x7018, 0x906d, 0x711a, 0x0110, 0x6902, 0x0008, 0x711e, 0x2168,
+	0x6804, 0x900d, 0x1118, 0x002e, 0x00ee, 0x0005, 0x2071, 0x1100,
+	0x9016, 0x702c, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff,
+	0x1dc8, 0x702e, 0x70b0, 0x9200, 0x70b2, 0x002e, 0x00ee, 0x0005,
+	0x0006, 0x687c, 0x0006, 0x6867, 0x0103, 0x20a9, 0x001c, 0x9d80,
+	0x001d, 0x20a0, 0x9006, 0x20e9, 0x0001, 0x4004, 0x000e, 0x9084,
+	0x00ff, 0x687e, 0x000e, 0x687a, 0x6982, 0x0005, 0x2071, 0x1228,
+	0x7004, 0x0002, 0x52c0, 0x52c1, 0x53ea, 0x53d8, 0x0cf1, 0x53eb,
+	0x0005, 0x2001, 0x124b, 0x2004, 0x0002, 0x52ca, 0x52ca, 0x531c,
+	0x531d, 0x5373, 0x0126, 0x2091, 0x8000, 0x1e0c, 0x542f, 0x701c,
+	0x906d, 0x01b0, 0x684c, 0x9005, 0x01a8, 0x0e04, 0x52e8, 0x694c,
+	0x2071, 0x0000, 0x7182, 0x6850, 0x7032, 0x686c, 0x7086, 0x7036,
+	0x6870, 0x708a, 0x2091, 0x4080, 0x2071, 0x1228, 0x080c, 0x5416,
+	0x012e, 0x0488, 0x2001, 0x005b, 0x2004, 0x9094, 0x0780, 0x190c,
+	0x542a, 0xd09c, 0x2071, 0x1228, 0x1528, 0x2071, 0x1228, 0x700f,
+	0x0001, 0x6964, 0x9184, 0x00ff, 0x9086, 0x0003, 0x1130, 0x810f,
+	0x918c, 0x00ff, 0x8101, 0x0108, 0x710e, 0x8d07, 0x8005, 0x8005,
+	0xc0d5, 0x00d6, 0x2069, 0x0050, 0x6822, 0x00de, 0x2071, 0x1228,
+	0x701c, 0x2068, 0x7010, 0x8001, 0x7012, 0x2d04, 0x701e, 0x9005,
+	0x1108, 0x701a, 0x012e, 0x0005, 0x0005, 0x2069, 0x12ef, 0x683c,
+	0x9005, 0x03d8, 0x11d0, 0x0126, 0x2091, 0x8000, 0x2069, 0x0050,
+	0x693c, 0x6838, 0x9106, 0x0160, 0x0e04, 0x533c, 0x2069, 0x0000,
+	0x6837, 0x8040, 0x6833, 0x0012, 0x6883, 0x8040, 0x2091, 0x4080,
+	0x2069, 0x12ef, 0x683f, 0xffff, 0x012e, 0x0126, 0x2091, 0x8000,
+	0x1e0c, 0x548e, 0x701c, 0x906d, 0x0560, 0x2001, 0x005b, 0x2004,
+	0x9094, 0x0780, 0x190c, 0x542a, 0xd09c, 0x1518, 0x2071, 0x1228,
+	0x700f, 0x0001, 0x6964, 0x9184, 0x00ff, 0x9086, 0x0003, 0x1130,
+	0x810f, 0x918c, 0x00ff, 0x8101, 0x0108, 0x710e, 0x8d07, 0x8005,
+	0x8005, 0xc0d5, 0x00d6, 0x2069, 0x0050, 0x6822, 0x00de, 0x701c,
+	0x2068, 0x7010, 0x8001, 0x7012, 0x2d04, 0x701e, 0x9005, 0x1108,
+	0x701a, 0x012e, 0x0005, 0x0126, 0x2091, 0x8000, 0x1e0c, 0x542f,
+	0x701c, 0x906d, 0x0548, 0x684c, 0x9086, 0x0004, 0x1538, 0x0136,
+	0x0146, 0x0156, 0x2099, 0x1176, 0x20e1, 0x0001, 0x20a1, 0x1278,
+	0x20e9, 0x0001, 0x20a9, 0x0004, 0x4003, 0x015e, 0x014e, 0x013e,
+	0x2071, 0x126e, 0x9d80, 0x001b, 0x700f, 0x0001, 0x7012, 0x7017,
+	0x0002, 0x7007, 0x0002, 0x700b, 0x0000, 0x2e10, 0x080c, 0x0e55,
+	0x2071, 0x1228, 0x7007, 0x0003, 0x012e, 0x0005, 0x2001, 0x005b,
+	0x2004, 0x9094, 0x0780, 0x190c, 0x542a, 0xd09c, 0x2071, 0x1228,
+	0x1d98, 0x2071, 0x1228, 0x700f, 0x0001, 0x6964, 0x9184, 0x00ff,
+	0x9086, 0x0003, 0x1130, 0x810f, 0x918c, 0x00ff, 0x8101, 0x0108,
+	0x710e, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x00d6, 0x2069, 0x0050,
+	0x6822, 0x00de, 0x2071, 0x1228, 0x701c, 0x2068, 0x7010, 0x8001,
+	0x7012, 0x2d04, 0x701e, 0x9005, 0x1978, 0x701a, 0x012e, 0x0005,
+	0x2001, 0x1270, 0x2004, 0x908e, 0x0100, 0x1120, 0x7007, 0x0001,
+	0x04a9, 0x0005, 0x908e, 0x0000, 0x0de0, 0x908e, 0x0200, 0x1dc8,
+	0x080c, 0x542a, 0x0005, 0x0005, 0x684f, 0x0004, 0x206b, 0x0000,
+	0x2d08, 0x2071, 0x1228, 0x7010, 0x8000, 0x7012, 0x7018, 0x906d,
+	0x711a, 0x0110, 0x6902, 0x0008, 0x711e, 0x2168, 0x6804, 0x900d,
+	0x1118, 0x002e, 0x00ee, 0x0005, 0x2071, 0x1100, 0x9016, 0x702c,
+	0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e,
+	0x70b0, 0x9200, 0x70b2, 0x002e, 0x00ee, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x701c, 0x906d, 0x0160, 0x7010, 0x8001, 0x7012, 0x2d04,
+	0x701e, 0x9005, 0x1108, 0x701a, 0x012e, 0x080c, 0x0df6, 0x0005,
+	0x012e, 0x0005, 0x2011, 0x8004, 0x080c, 0x37dc, 0x0cf8, 0x00f6,
+	0x2079, 0x0050, 0x7044, 0xd084, 0x0198, 0xc084, 0x7046, 0x7838,
+	0x7938, 0x910e, 0x1de0, 0x2069, 0x0000, 0x6836, 0x6833, 0x0013,
+	0x2091, 0x4080, 0x2009, 0x124a, 0x200b, 0x0000, 0x00fe, 0x0005,
+	0x782c, 0x9094, 0x0780, 0x19f1, 0xd0a4, 0x0dc0, 0x2001, 0x124b,
+	0x2004, 0x9086, 0x0004, 0x0140, 0x2009, 0x124a, 0x2104, 0x8000,
+	0x200a, 0x9082, 0x000f, 0x0e50, 0x00e6, 0x2071, 0x1100, 0x7824,
+	0x00e6, 0x2071, 0x0040, 0x712c, 0xd19c, 0x1118, 0x7022, 0x00ee,
+	0x0060, 0x00ee, 0xc0d4, 0x8006, 0x8006, 0x806f, 0x702c, 0x206a,
+	0x2d00, 0x702e, 0x70b0, 0x8000, 0x70b2, 0x782c, 0x9094, 0x0780,
+	0x190c, 0x542a, 0xd0a4, 0x1d18, 0x7838, 0x7938, 0x910e, 0x1de0,
+	0x2069, 0x0000, 0x6836, 0x6833, 0x0013, 0x2091, 0x4080, 0x2009,
+	0x124a, 0x200b, 0x0000, 0x00ee, 0x00fe, 0x0005, 0x00f6, 0x2079,
+	0x0050, 0x7044, 0xd084, 0x0178, 0xc084, 0x7046, 0x7838, 0x7938,
+	0x910e, 0x1de0, 0x2069, 0x0000, 0x6836, 0x6833, 0x0013, 0x2091,
+	0x4080, 0x00fe, 0x0005, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a,
+	0xd0a4, 0x0db8, 0x00e6, 0x2071, 0x1100, 0x7824, 0xc0d4, 0x8006,
+	0x8006, 0x806f, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70b0, 0x8000,
+	0x70b2, 0x782c, 0x9094, 0x0780, 0x190c, 0x542a, 0xd0a4, 0x1d68,
+	0x2069, 0x0050, 0x693c, 0x2069, 0x124b, 0x6808, 0x690a, 0x2069,
+	0x12ef, 0x9102, 0x1118, 0x683c, 0x9005, 0x1328, 0x2001, 0x124c,
+	0x200c, 0x810d, 0x693e, 0x00ee, 0x00fe, 0x0005, 0x7088, 0x908a,
+	0x0029, 0x1220, 0x9082, 0x001d, 0x0033, 0x0010, 0x080c, 0x0cf1,
+	0x6027, 0x1e00, 0x0005, 0x55a7, 0x5541, 0x5557, 0x557b, 0x559a,
+	0x55cc, 0x55de, 0x5557, 0x55b8, 0x54f0, 0x552a, 0x54ef, 0x0005,
+	0x00d6, 0x2069, 0x0200, 0x6804, 0x9005, 0x1180, 0x6808, 0x9005,
+	0x1578, 0x708b, 0x0028, 0x2069, 0x12af, 0x2d04, 0x7002, 0x080c,
+	0x5857, 0x6028, 0x9085, 0x0600, 0x602a, 0x0410, 0x708b, 0x0028,
+	0x2069, 0x12af, 0x2d04, 0x7002, 0x6028, 0x9085, 0x0600, 0x602a,
+	0x00e6, 0x0036, 0x0046, 0x0056, 0x2071, 0x131c, 0x080c, 0x1337,
+	0x005e, 0x004e, 0x003e, 0x00ee, 0x0126, 0x2091, 0x2200, 0x080c,
+	0x0fb3, 0x78ab, 0x0004, 0x7803, 0x0000, 0x7803, 0x0001, 0x012e,
+	0x00de, 0x0005, 0x00d6, 0x2069, 0x0200, 0x6804, 0x9005, 0x1178,
+	0x6808, 0x9005, 0x1160, 0x708b, 0x0028, 0x2069, 0x12af, 0x2d04,
+	0x7002, 0x080c, 0x58e5, 0x6028, 0x9085, 0x0600, 0x602a, 0x00de,
+	0x0005, 0x6803, 0x0090, 0x6124, 0xd1e4, 0x1180, 0x080c, 0x5649,
+	0xd1d4, 0x1150, 0xd1dc, 0x1128, 0xd1cc, 0x0140, 0x708b, 0x0020,
+	0x0028, 0x708b, 0x001d, 0x0010, 0x708b, 0x001f, 0x0005, 0x6803,
+	0x0088, 0x6124, 0xd1cc, 0x11c8, 0xd1dc, 0x11a0, 0xd1e4, 0x1178,
+	0x9184, 0x1e00, 0x11b8, 0x60e3, 0x0001, 0x600c, 0xc0b4, 0x600e,
+	0x080c, 0x5775, 0x6803, 0x0080, 0x708b, 0x0028, 0x0058, 0x708b,
+	0x001e, 0x0040, 0x708b, 0x001d, 0x0028, 0x708b, 0x0020, 0x0010,
+	0x708b, 0x001f, 0x0005, 0x60e3, 0x0001, 0x600c, 0xc0b4, 0x600e,
+	0x080c, 0x5775, 0x6803, 0x0080, 0x6124, 0xd1d4, 0x1180, 0xd1dc,
+	0x1158, 0xd1e4, 0x1130, 0x9184, 0x1e00, 0x1158, 0x708b, 0x0028,
+	0x0040, 0x708b, 0x001e, 0x0028, 0x708b, 0x001d, 0x0010, 0x708b,
+	0x001f, 0x0005, 0x6803, 0x00a0, 0x6124, 0xd1dc, 0x1128, 0xd1e4,
+	0x0128, 0x708b, 0x001e, 0x0010, 0x708b, 0x001d, 0x0005, 0x080c,
+	0x5675, 0x6124, 0xd1dc, 0x1158, 0x080c, 0x5649, 0xd1d4, 0x1128,
+	0xd1e4, 0x0128, 0x708b, 0x001e, 0x0010, 0x708b, 0x001f, 0x0005,
+	0x6803, 0x00a0, 0x6124, 0xd1d4, 0x1160, 0xd1cc, 0x1150, 0xd1dc,
+	0x1128, 0xd1e4, 0x0140, 0x708b, 0x001e, 0x0028, 0x708b, 0x001d,
+	0x0010, 0x708b, 0x0021, 0x0005, 0x080c, 0x5675, 0x6124, 0xd1d4,
+	0x1150, 0xd1dc, 0x1128, 0xd1e4, 0x0140, 0x708b, 0x001e, 0x0028,
+	0x708b, 0x001d, 0x0010, 0x708b, 0x001f, 0x0005, 0x6803, 0x0090,
+	0x6124, 0xd1d4, 0x1178, 0xd1cc, 0x1150, 0xd1dc, 0x1128, 0xd1e4,
+	0x0158, 0x708b, 0x001e, 0x0040, 0x708b, 0x001d, 0x0028, 0x708b,
+	0x0020, 0x0010, 0x708b, 0x001f, 0x0005, 0x0016, 0x00c6, 0x00d6,
+	0x00e6, 0x0126, 0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0x1100,
+	0x2091, 0x8000, 0x080c, 0x5745, 0x11e8, 0x2001, 0x110c, 0x200c,
+	0xd1b4, 0x01c0, 0xc1b4, 0x2102, 0x6027, 0x0200, 0x080c, 0x2055,
+	0x6024, 0xd0cc, 0x0158, 0x6803, 0x00a0, 0x2001, 0x1290, 0x2003,
+	0x0001, 0x2001, 0x1100, 0x2003, 0x0001, 0x0428, 0x6028, 0xc0cd,
+	0x602a, 0x0408, 0x080c, 0x5761, 0x0150, 0x080c, 0x5757, 0x1138,
+	0x2001, 0x0001, 0x080c, 0x1c36, 0x080c, 0x571c, 0x00a0, 0x080c,
+	0x5672, 0x0178, 0x2001, 0x0001, 0x080c, 0x1c36, 0x7088, 0x9086,
+	0x001e, 0x0120, 0x7088, 0x9086, 0x0022, 0x1118, 0x708b, 0x0025,
+	0x0010, 0x708b, 0x0021, 0x012e, 0x00ee, 0x00de, 0x00ce, 0x001e,
+	0x0005, 0x0016, 0x0026, 0x2009, 0x0064, 0x2011, 0x5654, 0x080c,
+	0x654f, 0x002e, 0x001e, 0x0005, 0x00e6, 0x00f6, 0x0016, 0x080c,
+	0x7721, 0x2071, 0x1100, 0x080c, 0x55f5, 0x001e, 0x00fe, 0x00ee,
+	0x0005, 0x0026, 0x00e6, 0x2011, 0x5654, 0x2071, 0x12ef, 0x701c,
+	0x9206, 0x1118, 0x7018, 0x9005, 0x0110, 0x9085, 0x0001, 0x00ee,
+	0x002e, 0x0005, 0x6020, 0xd09c, 0x0005, 0x6803, 0x00c0, 0x0156,
+	0x20a9, 0x002d, 0x1d04, 0x567a, 0x2091, 0x6000, 0x1f04, 0x567a,
+	0x015e, 0x0005, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x2071, 0x1100, 0x2001, 0x1290, 0x200c, 0x9186, 0x0000,
+	0x0158, 0x9186, 0x0001, 0x0158, 0x9186, 0x0002, 0x0158, 0x9186,
+	0x0003, 0x0158, 0x0804, 0x570a, 0x708b, 0x0022, 0x0040, 0x708b,
+	0x0021, 0x0028, 0x708b, 0x0023, 0x0030, 0x708b, 0x0024, 0x9085,
+	0x0001, 0x080c, 0x5789, 0x60e3, 0x0000, 0x6887, 0x0001, 0x2001,
+	0x0001, 0x080c, 0x1cbe, 0x0026, 0x2011, 0x0003, 0x080c, 0x79c2,
+	0x2011, 0x0002, 0x080c, 0x79cc, 0x080c, 0x78b3, 0x080c, 0x65cf,
+	0x0036, 0x2019, 0x0000, 0x080c, 0x7936, 0x003e, 0x002e, 0x7000,
+	0x908e, 0x0004, 0x0118, 0x602b, 0x0028, 0x0010, 0x602b, 0x0020,
+	0x0156, 0x0126, 0x2091, 0x8000, 0x20a9, 0x0005, 0x6024, 0xd0ac,
+	0x0118, 0x012e, 0x015e, 0x04e0, 0x6800, 0x9084, 0x00a0, 0xc0bd,
+	0x6802, 0x080c, 0x2055, 0x6904, 0xd1d4, 0x1130, 0x6803, 0x0100,
+	0x1f04, 0x56d6, 0x080c, 0x5796, 0x012e, 0x015e, 0x080c, 0x5757,
+	0x01a8, 0x6044, 0x9005, 0x0168, 0x6050, 0x0006, 0x9085, 0x0020,
+	0x6052, 0x080c, 0x5796, 0x9006, 0x8001, 0x1df0, 0x000e, 0x6052,
+	0x0028, 0x6804, 0xd0d4, 0x1110, 0x080c, 0x5796, 0x2001, 0x1290,
+	0x2003, 0x0004, 0x080c, 0x54d6, 0x080c, 0x5757, 0x0148, 0x6804,
+	0xd0d4, 0x1130, 0xd0dc, 0x1100, 0x2001, 0x1290, 0x2003, 0x0000,
+	0x00ee, 0x00de, 0x00ce, 0x0005, 0x00c6, 0x00d6, 0x00e6, 0x2061,
+	0x0100, 0x2069, 0x0140, 0x2071, 0x1100, 0x2001, 0x128f, 0x2003,
+	0x0000, 0x2001, 0x1280, 0x2003, 0x0000, 0x708b, 0x0000, 0x60e3,
+	0x0000, 0x6887, 0x0000, 0x2001, 0x0000, 0x080c, 0x1cbe, 0x6803,
+	0x0000, 0x6043, 0x0090, 0x6043, 0x0010, 0x6027, 0xffff, 0x602b,
+	0x182f, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x0006, 0x2001, 0x128f,
+	0x2004, 0x9086, 0xaaaa, 0x000e, 0x0005, 0x0006, 0x2001, 0x1172,
+	0x2004, 0x9084, 0x0030, 0x9086, 0x0000, 0x000e, 0x0005, 0x0006,
+	0x2001, 0x1172, 0x2004, 0x9084, 0x0030, 0x9086, 0x0030, 0x000e,
+	0x0005, 0x0006, 0x2001, 0x1172, 0x2004, 0x9084, 0x0030, 0x9086,
+	0x0010, 0x000e, 0x0005, 0x0006, 0x2001, 0x1172, 0x2004, 0x9084,
+	0x0030, 0x9086, 0x0020, 0x000e, 0x0005, 0x2001, 0x110c, 0x2004,
+	0xd0a4, 0x0170, 0x080c, 0x1cde, 0x0036, 0x0016, 0x2009, 0x0000,
+	0x2019, 0x0028, 0x080c, 0x2582, 0x001e, 0x003e, 0x9006, 0x0009,
+	0x0005, 0x00e6, 0x2071, 0x110c, 0x2e04, 0x0118, 0x9085, 0x0010,
+	0x0010, 0x9084, 0xffef, 0x2072, 0x00ee, 0x0005, 0x6050, 0x0006,
+	0x60ec, 0x0006, 0x600c, 0x0006, 0x6004, 0x0006, 0x6028, 0x0006,
+	0x0016, 0x6138, 0x6050, 0x9084, 0xfbff, 0x9085, 0x2000, 0x6052,
+	0x613a, 0x20a9, 0x0012, 0x1d04, 0x57ab, 0x2091, 0x6000, 0x1f04,
+	0x57ab, 0x602f, 0x0100, 0x602f, 0x0000, 0x6050, 0x9085, 0x0400,
+	0x9084, 0xdfff, 0x6052, 0x613a, 0x001e, 0x602f, 0x0040, 0x602f,
+	0x0000, 0x000e, 0x602a, 0x000e, 0x6006, 0x000e, 0x600e, 0x000e,
+	0x60ee, 0x60e3, 0x0000, 0x6887, 0x0001, 0x2001, 0x0001, 0x080c,
+	0x1cbe, 0x6803, 0x00a0, 0x000e, 0x6052, 0x0005, 0x0156, 0x0016,
+	0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x2071, 0x1100, 0x6020, 0x9084, 0x0080, 0x0138, 0x2001,
+	0x110c, 0x200c, 0xc1c5, 0x2102, 0x0804, 0x584f, 0x2001, 0x110c,
+	0x200c, 0xc1c4, 0x2102, 0x6028, 0x9084, 0xe1ff, 0x602a, 0x6027,
+	0x0200, 0x6803, 0x0090, 0x20a9, 0x0366, 0x6024, 0xd0cc, 0x1518,
+	0x1d04, 0x57fd, 0x2091, 0x6000, 0x1f04, 0x57fd, 0x2011, 0x0003,
+	0x080c, 0x79c2, 0x2011, 0x0002, 0x080c, 0x79cc, 0x080c, 0x78b3,
+	0x080c, 0x65cf, 0x2019, 0x0000, 0x080c, 0x7936, 0x6803, 0x00a0,
+	0x2001, 0x1290, 0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001,
+	0x9085, 0x0001, 0x0460, 0x86ff, 0x1110, 0x080c, 0x1359, 0x60e3,
+	0x0000, 0x2001, 0x1280, 0x2004, 0x080c, 0x1cbe, 0x60e2, 0x6803,
+	0x0080, 0x20a9, 0x0366, 0x6027, 0x1e00, 0x2009, 0x1e00, 0x080c,
+	0x2055, 0x6024, 0x910c, 0x0138, 0x1d04, 0x5833, 0x2091, 0x6000,
+	0x1f04, 0x5833, 0x0818, 0x6028, 0x9085, 0x1e00, 0x602a, 0x70a0,
+	0x9005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886, 0x9006, 0x00ee,
+	0x00de, 0x00ce, 0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100,
+	0x2071, 0x1100, 0x2069, 0x0140, 0x6020, 0x9084, 0x00c0, 0x0120,
+	0x6884, 0x9005, 0x1904, 0x58ac, 0x6803, 0x0088, 0x60e3, 0x0000,
+	0x6887, 0x0000, 0x2001, 0x0000, 0x080c, 0x1cbe, 0x2069, 0x0200,
+	0x6804, 0x9005, 0x1118, 0x6808, 0x9005, 0x01c0, 0x6028, 0x9084,
+	0xfbff, 0x602a, 0x6027, 0x0400, 0x2069, 0x12af, 0x7000, 0x206a,
+	0x708b, 0x0026, 0x7003, 0x0001, 0x20a9, 0x0002, 0x1d04, 0x588e,
+	0x2091, 0x6000, 0x1f04, 0x588e, 0x0804, 0x58dd, 0x2069, 0x0140,
+	0x20a9, 0x0384, 0x6027, 0x1e00, 0x2009, 0x1e00, 0x080c, 0x2055,
+	0x6024, 0x910c, 0x0530, 0x9084, 0x1a00, 0x1518, 0x1d04, 0x589a,
+	0x2091, 0x6000, 0x1f04, 0x589a, 0x2011, 0x0003, 0x080c, 0x79c2,
+	0x2011, 0x0002, 0x080c, 0x79cc, 0x080c, 0x78b3, 0x080c, 0x65cf,
+	0x2019, 0x0000, 0x080c, 0x7936, 0x6803, 0x00a0, 0x2001, 0x1290,
+	0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001, 0x9085, 0x0001,
+	0x00a0, 0x6803, 0x0080, 0x2069, 0x0140, 0x60e3, 0x0000, 0x70a0,
+	0x9005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886, 0x2001, 0x1280,
+	0x2004, 0x080c, 0x1cbe, 0x60e2, 0x9006, 0x00ee, 0x00de, 0x00ce,
+	0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x0156, 0x0016, 0x0026,
+	0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2071, 0x1100,
+	0x6020, 0x9084, 0x00c0, 0x01f0, 0x2011, 0x0003, 0x080c, 0x79c2,
+	0x2011, 0x0002, 0x080c, 0x79cc, 0x080c, 0x78b3, 0x080c, 0x65cf,
+	0x2019, 0x0000, 0x080c, 0x7936, 0x2069, 0x0140, 0x6803, 0x00a0,
+	0x2001, 0x1290, 0x2003, 0x0001, 0x2001, 0x1100, 0x2003, 0x0001,
+	0x0804, 0x5976, 0x2001, 0x110c, 0x200c, 0xd1b4, 0x1150, 0xc1b5,
+	0x2102, 0x080c, 0x5649, 0x2069, 0x0140, 0x6803, 0x0080, 0x60e3,
+	0x0000, 0x2069, 0x0200, 0x6804, 0x9005, 0x1118, 0x6808, 0x9005,
+	0x0178, 0x6028, 0x9084, 0xfdff, 0x602a, 0x6027, 0x0200, 0x2069,
+	0x12af, 0x7000, 0x206a, 0x708b, 0x0027, 0x7003, 0x0001, 0x04f0,
+	0x6027, 0x1e00, 0x2009, 0x1e00, 0x080c, 0x2055, 0x6024, 0x910c,
+	0x01c8, 0x9084, 0x1c00, 0x11b0, 0x1d04, 0x5938, 0x0006, 0x0016,
+	0x00c6, 0x00d6, 0x00e6, 0x080c, 0x64e0, 0x00ee, 0x00de, 0x00ce,
+	0x001e, 0x000e, 0x00e6, 0x2071, 0x12ef, 0x7018, 0x00ee, 0x9005,
+	0x19f8, 0x01e0, 0x0026, 0x2011, 0x5654, 0x080c, 0x655b, 0x002e,
+	0x2069, 0x0140, 0x60e3, 0x0000, 0x70a0, 0x9005, 0x1118, 0x6887,
+	0x0001, 0x0008, 0x6886, 0x2001, 0x1280, 0x2004, 0x080c, 0x1cbe,
+	0x60e2, 0x2001, 0x110c, 0x200c, 0xc1b4, 0x2102, 0x00ee, 0x00de,
+	0x00ce, 0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x0156, 0x0016,
+	0x0026, 0x0036, 0x0046, 0x00c6, 0x00e6, 0x2061, 0x0100, 0x2071,
+	0x1100, 0x7130, 0xd184, 0x1180, 0x2011, 0x1153, 0x2214, 0xd2ec,
+	0x0138, 0xc18d, 0x7132, 0x2011, 0x1153, 0x2214, 0xd2ac, 0x1120,
+	0x7030, 0xd08c, 0x0904, 0x59e3, 0x7130, 0xc185, 0x7132, 0x2011,
+	0x1153, 0x220c, 0xd1a4, 0x0530, 0x0016, 0x2009, 0x0001, 0x2011,
+	0x0100, 0x080c, 0x66d5, 0x2019, 0x000e, 0x080c, 0xaa50, 0x0156,
+	0x20a9, 0x007f, 0x2009, 0x0000, 0x9186, 0x007e, 0x0170, 0x9186,
+	0x0080, 0x0158, 0x080c, 0x4b58, 0x1140, 0x8127, 0x9006, 0x0016,
+	0x2009, 0x000e, 0x080c, 0xaaca, 0x001e, 0x8108, 0x1f04, 0x59b4,
+	0x015e, 0x001e, 0xd1ac, 0x1148, 0x0016, 0x2009, 0x0000, 0x2019,
+	0x0004, 0x080c, 0x2582, 0x001e, 0x0070, 0x0156, 0x20a9, 0x007f,
+	0x2009, 0x0000, 0x080c, 0x4b58, 0x1110, 0x080c, 0x472d, 0x8108,
+	0x1f04, 0x59da, 0x015e, 0x2011, 0x0003, 0x080c, 0x79c2, 0x2011,
+	0x0002, 0x080c, 0x79cc, 0x080c, 0x78b3, 0x080c, 0x65cf, 0x0036,
+	0x2019, 0x0000, 0x080c, 0x7936, 0x003e, 0x60e3, 0x0000, 0x2001,
+	0x1100, 0x2003, 0x0001, 0x080c, 0x5682, 0x00ee, 0x00ce, 0x004e,
+	0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x2071, 0x11f4, 0x7003,
+	0x0000, 0x7007, 0x0000, 0x708f, 0x0000, 0x7093, 0x0001, 0x70c7,
+	0x0000, 0x0005, 0x00e6, 0x2071, 0x0040, 0x6848, 0x9005, 0x1120,
+	0x9085, 0x0001, 0x0804, 0x5a5e, 0x6840, 0x9005, 0x01a0, 0x900e,
+	0x0156, 0x20a9, 0x0006, 0x8003, 0x81f5, 0x3e08, 0x1f04, 0x5a23,
+	0x015e, 0x6a50, 0x9200, 0x7002, 0x6854, 0x9101, 0x7006, 0x7013,
+	0x0000, 0x7017, 0x0000, 0x6850, 0x7002, 0x6854, 0x7006, 0x6858,
+	0x700a, 0x685c, 0x700e, 0x6840, 0x9005, 0x1120, 0x7013, 0x0000,
+	0x7017, 0x0000, 0x6848, 0x701a, 0x701c, 0x9085, 0x0040, 0x701e,
+	0x2001, 0x0019, 0x7036, 0x702b, 0x0001, 0x2001, 0x0004, 0x200c,
+	0x918c, 0xfff7, 0x918d, 0x8000, 0x2102, 0x00d6, 0x2069, 0x11f4,
+	0x6807, 0x0001, 0x00de, 0x080c, 0x5f52, 0x9006, 0x00ee, 0x0005,
+	0x2079, 0x0040, 0x2071, 0x11f4, 0x7004, 0x0002, 0x5a70, 0x5a71,
+	0x5aa2, 0x5afd, 0x5bfe, 0x5a6e, 0x5a6e, 0x5c27, 0x080c, 0x0cf1,
+	0x0005, 0x2079, 0x0040, 0x782c, 0x908c, 0x0780, 0x1530, 0xd0a4,
+	0x01b0, 0x7824, 0xc0d4, 0x8006, 0x8006, 0x806f, 0x6803, 0x0000,
+	0x6807, 0x0000, 0x6864, 0x9084, 0x00ff, 0x908a, 0x0040, 0x1260,
+	0x04a3, 0x7004, 0x9086, 0x0003, 0x1d30, 0x080c, 0x5afd, 0x782c,
+	0xd09c, 0x090c, 0x5f52, 0x0005, 0x9082, 0x005a, 0x1218, 0x2100,
+	0x0053, 0x0c78, 0x080c, 0x5b37, 0x0c90, 0x2011, 0x8003, 0x080c,
+	0x37dc, 0x0cf8, 0x0005, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37,
+	0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37,
+	0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37,
+	0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b57,
+	0x5b37, 0x5cdc, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b57,
+	0x5d1e, 0x5d61, 0x5daa, 0x5dbe, 0x5b37, 0x5b37, 0x5b73, 0x5b57,
+	0x5b37, 0x5b37, 0x5bd7, 0x5e67, 0x5e82, 0x5b37, 0x5b73, 0x5b37,
+	0x5b37, 0x5b37, 0x5b37, 0x5bcd, 0x5e82, 0x5b37, 0x5b37, 0x5b37,
+	0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b87, 0x5b37,
+	0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37,
+	0x5f8e, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b9c, 0x5b37,
+	0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x5b37, 0x2079, 0x0040, 0x7004,
+	0x9086, 0x0003, 0x11b8, 0x782c, 0x080c, 0x5f83, 0xd0a4, 0x0190,
+	0x7824, 0xc0d4, 0x8006, 0x8006, 0x806f, 0x6803, 0x0000, 0x6807,
+	0x0000, 0x6864, 0x9084, 0x00ff, 0x908a, 0x001a, 0x1210, 0x002b,
+	0x0c30, 0x00e9, 0x080c, 0x5f52, 0x0005, 0x5b37, 0x5b57, 0x5cc8,
+	0x5b37, 0x5b57, 0x5b37, 0x5b57, 0x5b57, 0x5b37, 0x5b57, 0x5cc8,
+	0x5b57, 0x5b57, 0x5b57, 0x5b57, 0x5b57, 0x5b37, 0x5b57, 0x5cc8,
+	0x5b37, 0x5b37, 0x5b57, 0x5b37, 0x5b37, 0x5b37, 0x5b57, 0x00e6,
+	0x2071, 0x11f4, 0x7007, 0x0001, 0x6868, 0x9084, 0x00ff, 0xc0d5,
+	0x686a, 0x0126, 0x2091, 0x8000, 0x080c, 0x50a5, 0x012e, 0x00ee,
+	0x0005, 0x7007, 0x0001, 0x6868, 0x9084, 0x00ff, 0xc0e5, 0x686a,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x50a5, 0x012e, 0x0005, 0x7007,
+	0x0001, 0x6868, 0x9084, 0x00ff, 0xc0ed, 0x686a, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x50a5, 0x012e, 0x0005, 0x7007, 0x0001, 0x6868,
+	0x9084, 0x00ff, 0xc0dd, 0x686a, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x50a5, 0x012e, 0x0005, 0x6864, 0x8007, 0x9084, 0x00ff, 0x0988,
+	0x8001, 0x1120, 0x7007, 0x0001, 0x0804, 0x5c90, 0x7007, 0x0003,
+	0x7012, 0x2d00, 0x7016, 0x701a, 0x704b, 0x5c90, 0x0005, 0x6864,
+	0x8007, 0x9084, 0x00ff, 0x0904, 0x5b49, 0x8001, 0x1120, 0x7007,
+	0x0001, 0x0804, 0x5ca9, 0x7007, 0x0003, 0x7012, 0x2d00, 0x7016,
+	0x701a, 0x704b, 0x5ca9, 0x0005, 0x6864, 0x8007, 0x9084, 0x00ff,
+	0x9086, 0x0001, 0x1904, 0x5b49, 0x7007, 0x0001, 0x2009, 0x1130,
+	0x210c, 0x81ff, 0x11a8, 0x6868, 0x9084, 0x00ff, 0x686a, 0x6883,
+	0x0000, 0x080c, 0x4873, 0x1108, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x6867, 0x0139, 0x687a, 0x6982, 0x080c, 0x50a5, 0x012e, 0x0ca0,
+	0x6994, 0x9186, 0x0071, 0x0d38, 0x6897, 0x4005, 0x689b, 0x0001,
+	0x2001, 0x0030, 0x2009, 0x0000, 0x0c40, 0x687c, 0x9084, 0x00c0,
+	0x9086, 0x00c0, 0x1120, 0x7007, 0x0001, 0x0804, 0x5e99, 0x2d00,
+	0x7016, 0x701a, 0x20a9, 0x0004, 0x20e1, 0x0001, 0x20e9, 0x0001,
+	0x9080, 0x0030, 0x2098, 0x20a1, 0x1221, 0x4003, 0x6888, 0x7012,
+	0x9082, 0x0401, 0x1a04, 0x5b65, 0x6ab4, 0x928a, 0x0002, 0x1a04,
+	0x5b65, 0x82ff, 0x1138, 0x68b8, 0x69bc, 0x9105, 0x0118, 0x2001,
+	0x5c63, 0x0018, 0x9280, 0x5c59, 0x2005, 0x70ce, 0x7010, 0x9015,
+	0x0904, 0x5c45, 0x080c, 0x0dc6, 0x1118, 0x7007, 0x0004, 0x0005,
+	0x2d00, 0x7022, 0x70cc, 0x2060, 0xe000, 0x6866, 0xe004, 0x9d00,
+	0x709e, 0x709b, 0x0001, 0xe008, 0x920a, 0x1210, 0x900e, 0x2200,
+	0x7112, 0xe20c, 0x8003, 0x800b, 0x9296, 0x0004, 0x0108, 0x9108,
+	0x71a2, 0x810b, 0x71a6, 0x9e90, 0x0023, 0x080c, 0x0e55, 0x7094,
+	0x908e, 0x0100, 0x0170, 0x9086, 0x0200, 0x0118, 0x7007, 0x0007,
+	0x0005, 0x7020, 0x2068, 0x080c, 0x0df6, 0x7014, 0x2068, 0x0804,
+	0x5b65, 0x7020, 0x2068, 0x7018, 0x6802, 0x6807, 0x0000, 0x2d08,
+	0x2068, 0x6906, 0x711a, 0x0804, 0x5bfe, 0x7014, 0x2068, 0x7007,
+	0x0001, 0x68b4, 0x9005, 0x1128, 0x68b8, 0x69bc, 0x9105, 0x0108,
+	0x00b1, 0x6864, 0x9084, 0x00ff, 0x9086, 0x001e, 0x0904, 0x5e99,
+	0x04b8, 0x5c5b, 0x5c5f, 0x0002, 0x001d, 0x0007, 0x0004, 0x000a,
+	0x001b, 0x0005, 0x0006, 0x000a, 0x001d, 0x0005, 0x0004, 0x00f6,
+	0x00e6, 0x00c6, 0x0076, 0x0066, 0x6fb8, 0x6ebc, 0x6804, 0x2060,
+	0x9cf0, 0x002d, 0x9cf8, 0x0033, 0x2009, 0x0005, 0x700c, 0x7816,
+	0x7008, 0x7812, 0x7004, 0x7806, 0x7000, 0x7802, 0x7e0e, 0x7f0a,
+	0x8109, 0x0128, 0x9ef2, 0x0004, 0x9ffa, 0x0006, 0x0c78, 0x6004,
+	0x9065, 0x1d30, 0x006e, 0x007e, 0x00ce, 0x00ee, 0x00fe, 0x0005,
+	0x2009, 0x1130, 0x210c, 0x81ff, 0x1178, 0x080c, 0x477e, 0x1108,
+	0x0005, 0x080c, 0x52a0, 0x0126, 0x2091, 0x8000, 0x080c, 0x9843,
+	0x080c, 0x50a5, 0x012e, 0x0ca0, 0x2001, 0x0028, 0x2009, 0x0000,
+	0x0c80, 0x2009, 0x1130, 0x210c, 0x81ff, 0x1190, 0x6888, 0x9005,
+	0x01a0, 0x6883, 0x0000, 0x080c, 0x4817, 0x1108, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x687a, 0x6982, 0x080c, 0x50a5, 0x012e, 0x0cb0,
+	0x2001, 0x0028, 0x2009, 0x0000, 0x0c90, 0x2001, 0x0000, 0x0c78,
+	0x7018, 0x6802, 0x2d08, 0x2068, 0x6906, 0x711a, 0x7010, 0x8001,
+	0x7012, 0x0118, 0x7007, 0x0003, 0x0030, 0x7014, 0x2068, 0x7007,
+	0x0001, 0x7048, 0x080f, 0x0005, 0x7007, 0x0001, 0x6974, 0x810f,
+	0x918c, 0x00ff, 0x6878, 0x9084, 0x00ff, 0x20a9, 0x0001, 0x9096,
+	0x0001, 0x01b0, 0x2009, 0x0000, 0x20a9, 0x00ff, 0x9096, 0x0002,
+	0x0178, 0x9005, 0x11f0, 0x6974, 0x810f, 0x918c, 0x00ff, 0x080c,
+	0x4b58, 0x11b8, 0x0066, 0x6e80, 0x080c, 0x4c50, 0x006e, 0x0088,
+	0x0046, 0x2011, 0x110c, 0x2224, 0xc484, 0x2412, 0x004e, 0x00c6,
+	0x080c, 0x4b58, 0x1110, 0x080c, 0x4d11, 0x8108, 0x1f04, 0x5d08,
+	0x00ce, 0x687c, 0xd084, 0x1118, 0x080c, 0x0df6, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x50a5, 0x012e, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x7007, 0x0001, 0x2001, 0x1153, 0x2004, 0xd0a4, 0x0580,
+	0x2061, 0x1329, 0x6100, 0xd184, 0x0178, 0x6888, 0x9084, 0x00ff,
+	0x1550, 0x6000, 0xd084, 0x0520, 0x6004, 0x9005, 0x1538, 0x6003,
+	0x0000, 0x600b, 0x0000, 0x00c8, 0x2011, 0x0001, 0x6890, 0x9005,
+	0x1110, 0x2001, 0x001e, 0x8000, 0x6016, 0x6888, 0x9084, 0x00ff,
+	0x0178, 0x6006, 0x6888, 0x8007, 0x9084, 0x00ff, 0x0148, 0x600a,
+	0x6888, 0x8000, 0x1108, 0xc28d, 0x6202, 0x012e, 0x0804, 0x5f3c,
+	0x012e, 0x0804, 0x5f36, 0x012e, 0x0804, 0x5f30, 0x012e, 0x0804,
+	0x5f33, 0x0126, 0x2091, 0x8000, 0x7007, 0x0001, 0x2001, 0x1153,
+	0x2004, 0xd0a4, 0x05e0, 0x2061, 0x1329, 0x6000, 0xd084, 0x05b8,
+	0x6204, 0x6308, 0xd08c, 0x1530, 0x6c78, 0x9484, 0x0003, 0x0170,
+	0x6988, 0x918c, 0x00ff, 0x8001, 0x1120, 0x2100, 0x9210, 0x0620,
+	0x0028, 0x8001, 0x1508, 0x2100, 0x9212, 0x02f0, 0x9484, 0x000c,
+	0x0188, 0x6988, 0x810f, 0x918c, 0x00ff, 0x9082, 0x0004, 0x1120,
+	0x2100, 0x9318, 0x0288, 0x0030, 0x9082, 0x0004, 0x1168, 0x2100,
+	0x931a, 0x0250, 0x6890, 0x9005, 0x0110, 0x8000, 0x6016, 0x6206,
+	0x630a, 0x012e, 0x0804, 0x5f3c, 0x012e, 0x0804, 0x5f39, 0x012e,
+	0x0804, 0x5f36, 0x0126, 0x2091, 0x8000, 0x7007, 0x0001, 0x2061,
+	0x1329, 0x6300, 0xd38c, 0x1120, 0x6308, 0x8318, 0x0220, 0x630a,
+	0x012e, 0x0804, 0x5f4a, 0x012e, 0x0804, 0x5f39, 0x0126, 0x00c6,
+	0x2091, 0x8000, 0x7007, 0x0001, 0x687c, 0xd0ac, 0x0148, 0x00c6,
+	0x2061, 0x1329, 0x6000, 0x9084, 0xfcff, 0x6002, 0x00ce, 0x0448,
+	0x6888, 0x9005, 0x05d0, 0x688c, 0x9065, 0x0598, 0x2001, 0x1130,
+	0x2004, 0x9005, 0x0118, 0x080c, 0x97a3, 0x0068, 0x6017, 0x0400,
+	0x605b, 0x0000, 0x697c, 0xd1a4, 0x0110, 0x6980, 0x615a, 0x2009,
+	0x0041, 0x080c, 0x7f4e, 0x6988, 0x918c, 0xff00, 0x9186, 0x2000,
+	0x1140, 0x0026, 0x2009, 0x0000, 0x2011, 0xfdff, 0x080c, 0x66d5,
+	0x002e, 0x687c, 0xd0c4, 0x0148, 0x2061, 0x1329, 0x6000, 0xd08c,
+	0x1120, 0x6008, 0x8000, 0x0208, 0x600a, 0x00ce, 0x012e, 0x0804,
+	0x5f3c, 0x00ce, 0x012e, 0x0804, 0x5f36, 0x6984, 0x9186, 0x002e,
+	0x0d40, 0x9186, 0x002d, 0x0d28, 0x9186, 0x0045, 0x0510, 0x9186,
+	0x002a, 0x1130, 0x2001, 0x110c, 0x200c, 0xc194, 0x2102, 0x08c8,
+	0x9186, 0x0020, 0x0170, 0x9186, 0x0029, 0x1d18, 0x6974, 0x918c,
+	0xff00, 0x810f, 0x080c, 0x4b58, 0x1960, 0x6000, 0xc0e4, 0x6002,
+	0x0840, 0x688c, 0x9065, 0x09a8, 0x2001, 0x12a6, 0x2004, 0x601a,
+	0x0800, 0x688c, 0x9065, 0x0968, 0x00e6, 0x6890, 0x9075, 0x2001,
+	0x1130, 0x2004, 0x9005, 0x0150, 0x080c, 0x97a3, 0x8eff, 0x0118,
+	0x2e60, 0x080c, 0x97a3, 0x00ee, 0x0804, 0x5df9, 0x6024, 0xc0dc,
+	0xc0d5, 0x6026, 0x2e60, 0x6007, 0x003a, 0x68a0, 0x9005, 0x0130,
+	0x6007, 0x003b, 0x68a4, 0x602e, 0x68a8, 0x6016, 0x6003, 0x0001,
+	0x080c, 0x6886, 0x080c, 0x6d42, 0x00ee, 0x0804, 0x5df9, 0x2061,
+	0x1329, 0x6000, 0xd084, 0x0190, 0xd08c, 0x1904, 0x5f4a, 0x0126,
+	0x2091, 0x8000, 0x6204, 0x8210, 0x0220, 0x6206, 0x012e, 0x0804,
+	0x5f4a, 0x012e, 0x6883, 0x0016, 0x0804, 0x5f43, 0x6883, 0x0007,
+	0x0804, 0x5f43, 0x6864, 0x8007, 0x9084, 0x00ff, 0x0130, 0x8001,
+	0x1138, 0x7007, 0x0001, 0x0069, 0x0005, 0x080c, 0x5b49, 0x0040,
+	0x7007, 0x0003, 0x7012, 0x2d00, 0x7016, 0x701a, 0x704b, 0x5e99,
+	0x0005, 0x00e6, 0x0126, 0x2091, 0x8000, 0x2061, 0x1100, 0x61c0,
+	0x81ff, 0x1904, 0x5f18, 0x6130, 0xd194, 0x1904, 0x5f20, 0x6878,
+	0x2070, 0x9e82, 0x15c0, 0x0a04, 0x5f0c, 0x6058, 0x9e02, 0x1a04,
+	0x5f0c, 0x2061, 0x1329, 0x6100, 0x9184, 0x0301, 0x9086, 0x0001,
+	0x15e8, 0x7120, 0x9186, 0x0006, 0x15f0, 0x7010, 0x9005, 0x0904,
+	0x5f18, 0x2004, 0xd0e4, 0x1904, 0x5f1b, 0x7024, 0xd0dc, 0x1904,
+	0x5f23, 0x6883, 0x0000, 0x6803, 0x0000, 0x2d08, 0x7014, 0x9005,
+	0x1198, 0x7116, 0x687c, 0xd0f4, 0x1904, 0x5f26, 0x2001, 0x1153,
+	0x2004, 0xd09c, 0x1118, 0x687c, 0xc0cc, 0x687e, 0x2e60, 0x080c,
+	0x6611, 0x012e, 0x00ee, 0x0005, 0x2068, 0x6800, 0x9005, 0x1de0,
+	0x6902, 0x2168, 0x687c, 0xd0f4, 0x15c8, 0x012e, 0x00ee, 0x0005,
+	0x012e, 0x00ee, 0x6883, 0x0006, 0x0804, 0x5f43, 0xd184, 0x0dc0,
+	0xd1c4, 0x11a8, 0x00b8, 0x6974, 0x918c, 0xff00, 0x810f, 0x080c,
+	0x4b58, 0x11c8, 0x6000, 0xd0e4, 0x11b0, 0x7120, 0x9186, 0x0007,
+	0x1118, 0x6883, 0x0002, 0x0088, 0x6883, 0x0008, 0x0070, 0x6883,
+	0x000e, 0x0058, 0x6883, 0x0017, 0x0040, 0x6883, 0x0035, 0x0028,
+	0x6883, 0x0028, 0x0010, 0x6883, 0x0029, 0x012e, 0x00ee, 0x0418,
+	0x6883, 0x002a, 0x0cd0, 0x6883, 0x0045, 0x0cb8, 0x2e60, 0x2019,
+	0x0002, 0x601b, 0x0014, 0x080c, 0xa6bc, 0x012e, 0x00ee, 0x0005,
+	0x2009, 0x003e, 0x0058, 0x2009, 0x0004, 0x0040, 0x2009, 0x0006,
+	0x0028, 0x2009, 0x0016, 0x0010, 0x2009, 0x0001, 0x6884, 0x9084,
+	0xff00, 0x9105, 0x6886, 0x0126, 0x2091, 0x8000, 0x080c, 0x50a5,
+	0x012e, 0x0005, 0x080c, 0x0df6, 0x0005, 0x00d6, 0x080c, 0x6608,
+	0x00de, 0x0005, 0x00d6, 0x00e6, 0x0126, 0x2091, 0x8000, 0x2071,
+	0x0040, 0x702c, 0xd084, 0x01f0, 0x908c, 0x0780, 0x11f8, 0xd09c,
+	0x11c8, 0x2071, 0x1100, 0x70b0, 0x90ea, 0x0010, 0x0298, 0x8001,
+	0x70b2, 0x702c, 0x2068, 0x2d04, 0x702e, 0x206b, 0x0000, 0x6807,
+	0x0000, 0x2071, 0x0040, 0x8d07, 0x8005, 0x8005, 0xc0d5, 0x7022,
+	0x702c, 0x0c10, 0x012e, 0x00ee, 0x00de, 0x0005, 0x2011, 0x8003,
+	0x080c, 0x37dc, 0x0cf8, 0x0006, 0x9084, 0x0780, 0x0128, 0x2011,
+	0x8003, 0x080c, 0x37dc, 0x0cf8, 0x000e, 0x0005, 0x00d6, 0x00c6,
+	0x0036, 0x0026, 0x0016, 0x7007, 0x0001, 0x6a74, 0x9282, 0x0004,
+	0x1a04, 0x5fd9, 0xd284, 0x0170, 0x6a7c, 0x9290, 0x1000, 0x2204,
+	0x9065, 0x6004, 0x05e0, 0x8007, 0x9084, 0x00ff, 0x9084, 0x0006,
+	0x1108, 0x04a8, 0x2c10, 0x080c, 0x7ec8, 0x1118, 0x080c, 0x984d,
+	0x05a0, 0x6212, 0x6874, 0x0002, 0x5fb8, 0x5fbd, 0x5fc0, 0x5fc6,
+	0x2019, 0x0002, 0x080c, 0xaa50, 0x0060, 0x080c, 0xa9e7, 0x0048,
+	0x2019, 0x0002, 0x6980, 0x080c, 0xaa02, 0x0018, 0x6980, 0x080c,
+	0xa9e7, 0x080c, 0x7f1e, 0x6887, 0x0000, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x50a5, 0x012e, 0x001e, 0x002e, 0x003e, 0x00ce, 0x00de,
+	0x0005, 0x6887, 0x0006, 0x0c88, 0x6887, 0x0002, 0x0c70, 0x6887,
+	0x0005, 0x0c58, 0x6887, 0x0004, 0x0c40, 0x6887, 0x0007, 0x0c28,
+	0x0005, 0x781c, 0xd08c, 0x05f0, 0x7d44, 0x7c40, 0x9584, 0x00f6,
+	0x1500, 0x9484, 0x7000, 0x0138, 0x908a, 0x2000, 0x1250, 0x9584,
+	0x0700, 0x8007, 0x04b2, 0x7000, 0x9084, 0xff00, 0x9086, 0x8100,
+	0x0db0, 0x9484, 0x0fff, 0x1130, 0x7000, 0x9084, 0xff00, 0x9086,
+	0x8100, 0x11e0, 0x080c, 0xadbe, 0x080c, 0x6423, 0x7817, 0x0140,
+	0x00c8, 0x9584, 0x0076, 0x1118, 0x080c, 0x6481, 0x19d0, 0xd5a4,
+	0x0168, 0x080c, 0x136e, 0x7803, 0x0010, 0x78a0, 0x78a2, 0x2001,
+	0x0160, 0x2502, 0x2001, 0x0138, 0x2202, 0x0020, 0x080c, 0xadbe,
+	0x7817, 0x0140, 0x2001, 0x12e5, 0x2004, 0x9005, 0x090c, 0x6d42,
+	0x0005, 0x6042, 0x626b, 0x6039, 0x6039, 0x6039, 0x6039, 0x6039,
+	0x6039, 0x7817, 0x0140, 0x2001, 0x12e5, 0x2004, 0x9005, 0x090c,
+	0x6d42, 0x0005, 0x7000, 0x908c, 0xff00, 0x9194, 0xf000, 0x810f,
+	0x9484, 0x0fff, 0x6882, 0x9286, 0x2000, 0x1148, 0x6800, 0x9086,
+	0x0001, 0x1118, 0x080c, 0x3e5a, 0x0068, 0x00a9, 0x0058, 0x9286,
+	0x3000, 0x1118, 0x080c, 0x61b5, 0x0028, 0x9286, 0x8000, 0x1110,
+	0x080c, 0x635d, 0x7817, 0x0140, 0x2001, 0x12e5, 0x2004, 0x9005,
+	0x090c, 0x6d42, 0x0005, 0x00c6, 0x7010, 0x9084, 0xff00, 0x8007,
+	0x9096, 0x0001, 0x0120, 0x9096, 0x0023, 0x1904, 0x61af, 0x9186,
+	0x0023, 0x1550, 0x080c, 0x63f6, 0x0904, 0x61af, 0x7124, 0x610a,
+	0x7030, 0x908e, 0x0200, 0x1130, 0x2009, 0x0015, 0x080c, 0x7f4e,
+	0x0804, 0x61af, 0x908e, 0x0214, 0x0118, 0x908e, 0x0210, 0x1130,
+	0x2009, 0x0015, 0x080c, 0x7f4e, 0x0804, 0x61af, 0x908e, 0x0100,
+	0x1904, 0x61af, 0x7034, 0x9005, 0x1904, 0x61af, 0x2009, 0x0016,
+	0x080c, 0x7f4e, 0x0804, 0x61af, 0x9186, 0x0022, 0x1904, 0x61af,
+	0x7030, 0x908e, 0x0300, 0x1580, 0x68cc, 0xd0a4, 0x0528, 0xc0b5,
+	0x68ce, 0x7100, 0x918c, 0x00ff, 0x696e, 0x7004, 0x6872, 0x00f6,
+	0x2079, 0x0100, 0x79e6, 0x78ea, 0x0006, 0x9084, 0x00ff, 0x0016,
+	0x2008, 0x080c, 0x1c93, 0x7932, 0x7936, 0x001e, 0x000e, 0x00fe,
+	0x080c, 0x1c69, 0x694e, 0x703c, 0x00e6, 0x2071, 0x0140, 0x7086,
+	0x2071, 0x1100, 0x70a2, 0x00ee, 0x7034, 0x9005, 0x1904, 0x61af,
+	0x2009, 0x0017, 0x0804, 0x6175, 0x908e, 0x0400, 0x1158, 0x7034,
+	0x9005, 0x1904, 0x61af, 0x68cc, 0xc0a5, 0x68ce, 0x2009, 0x0030,
+	0x0804, 0x6175, 0x908e, 0x0500, 0x1140, 0x7034, 0x9005, 0x1904,
+	0x61af, 0x2009, 0x0018, 0x0804, 0x6175, 0x908e, 0x2010, 0x1120,
+	0x2009, 0x0019, 0x0804, 0x6175, 0x908e, 0x2110, 0x1120, 0x2009,
+	0x001a, 0x0804, 0x6175, 0x908e, 0x5200, 0x1140, 0x7034, 0x9005,
+	0x1904, 0x61af, 0x2009, 0x001b, 0x0804, 0x6175, 0x908e, 0x5000,
+	0x1140, 0x7034, 0x9005, 0x1904, 0x61af, 0x2009, 0x001c, 0x0804,
+	0x6175, 0x908e, 0x1300, 0x1120, 0x2009, 0x0034, 0x0804, 0x6175,
+	0x908e, 0x1200, 0x1140, 0x7034, 0x9005, 0x1904, 0x61af, 0x2009,
+	0x0024, 0x0804, 0x6175, 0x908c, 0xff00, 0x918e, 0x2400, 0x1120,
+	0x2009, 0x002d, 0x0804, 0x6175, 0x908c, 0xff00, 0x918e, 0x5300,
+	0x1118, 0x2009, 0x002a, 0x04c8, 0x908e, 0x0f00, 0x1118, 0x2009,
+	0x0020, 0x0498, 0x908e, 0x5300, 0x1108, 0x00d8, 0x908e, 0x6104,
+	0x11c0, 0x2011, 0x026d, 0x8208, 0x2204, 0x9082, 0x0004, 0x8004,
+	0x8004, 0x20a8, 0x2011, 0x8015, 0x211c, 0x8108, 0x0046, 0x2124,
+	0x080c, 0x37dc, 0x004e, 0x8108, 0x1f04, 0x6152, 0x2009, 0x0023,
+	0x00a0, 0x908e, 0x6000, 0x1118, 0x2009, 0x003f, 0x0070, 0x908e,
+	0x7800, 0x1118, 0x2009, 0x0045, 0x0040, 0x908e, 0x6300, 0x1118,
+	0x2009, 0x004a, 0x0010, 0x2009, 0x001d, 0x0016, 0x2011, 0x0263,
+	0x2204, 0x8211, 0x220c, 0x080c, 0x1c69, 0x1598, 0x080c, 0x4b03,
+	0x1580, 0x6612, 0x6516, 0x86ff, 0x01e8, 0x001e, 0x0016, 0x9186,
+	0x0017, 0x1158, 0x686c, 0x9606, 0x11a8, 0x6870, 0x9506, 0x9084,
+	0xff00, 0x1180, 0x6000, 0xc0f5, 0x6002, 0x9186, 0x0046, 0x1150,
+	0x686c, 0x9606, 0x1138, 0x6870, 0x9506, 0x9084, 0xff00, 0x1110,
+	0x001e, 0x0068, 0x00c6, 0x080c, 0x7ec8, 0x0168, 0x001e, 0x6112,
+	0x6023, 0x0004, 0x7120, 0x610a, 0x001e, 0x080c, 0x7f4e, 0x00ce,
+	0x0005, 0x001e, 0x0ce0, 0x00ce, 0x0ce0, 0x080c, 0x26bc, 0x1140,
+	0x7010, 0x9084, 0xff00, 0x8007, 0x908e, 0x0008, 0x1108, 0x0009,
+	0x0005, 0x00c6, 0x0046, 0x7000, 0x908c, 0xff00, 0x810f, 0x9186,
+	0x0033, 0x11e8, 0x080c, 0x63f6, 0x0904, 0x6212, 0x7124, 0x610a,
+	0x7030, 0x908e, 0x0200, 0x1140, 0x7034, 0x9005, 0x15d8, 0x2009,
+	0x0015, 0x080c, 0x7f4e, 0x04b0, 0x908e, 0x0100, 0x1598, 0x7034,
+	0x9005, 0x1580, 0x2009, 0x0016, 0x080c, 0x7f4e, 0x0458, 0x9186,
+	0x0032, 0x1540, 0x7030, 0x908e, 0x1400, 0x1520, 0x2009, 0x0038,
+	0x0016, 0x2011, 0x0263, 0x2204, 0x8211, 0x220c, 0x080c, 0x1c69,
+	0x11c0, 0x080c, 0x4b03, 0x11a8, 0x6612, 0x6516, 0x00c6, 0x080c,
+	0x7ec8, 0x0170, 0x001e, 0x6112, 0x080c, 0x99cc, 0x6023, 0x0004,
+	0x7120, 0x610a, 0x001e, 0x080c, 0x7f4e, 0x080c, 0x6d42, 0x0010,
+	0x00ce, 0x001e, 0x004e, 0x00ce, 0x0005, 0x0046, 0x00e6, 0x00d6,
+	0x2028, 0x2130, 0x9696, 0x00ff, 0x11b0, 0x9592, 0xfffc, 0x0298,
+	0x9596, 0xfffd, 0x1120, 0x2009, 0x007f, 0x0804, 0x6266, 0x9596,
+	0xfffe, 0x1118, 0x2009, 0x007e, 0x04c8, 0x9596, 0xfffc, 0x1118,
+	0x2009, 0x0080, 0x0498, 0x2011, 0x0000, 0x2019, 0x1133, 0x231c,
+	0xd3ac, 0x0138, 0x2021, 0x0000, 0x20a9, 0x00ff, 0x2071, 0x1000,
+	0x0030, 0x2021, 0x0081, 0x20a9, 0x007e, 0x2071, 0x1081, 0x2e1c,
+	0x93ed, 0x0000, 0x1128, 0x82ff, 0x1170, 0x2410, 0xc2fd, 0x0058,
+	0x6f10, 0x2600, 0x9706, 0x6814, 0x1120, 0x9546, 0x1110, 0x2408,
+	0x0068, 0x9745, 0x0d80, 0x8420, 0x8e70, 0x1f04, 0x6247, 0x82ff,
+	0x1118, 0x9085, 0x0001, 0x0018, 0xc2fc, 0x2208, 0x9006, 0x00de,
+	0x00ee, 0x004e, 0x0005, 0x7000, 0x908c, 0xff00, 0x810f, 0x9184,
+	0x0007, 0x004a, 0x7817, 0x0140, 0x2001, 0x12e5, 0x2004, 0x9005,
+	0x090c, 0x6d42, 0x0005, 0x628b, 0x628b, 0x628b, 0x6408, 0x628b,
+	0x6294, 0x62b1, 0x6340, 0x628b, 0x628b, 0x628b, 0x628b, 0x628b,
+	0x628b, 0x628b, 0x628b, 0x7817, 0x0140, 0x2001, 0x12e5, 0x2004,
+	0x9005, 0x090c, 0x6d42, 0x0005, 0x7110, 0xd1bc, 0x0188, 0x7120,
+	0x2160, 0x9c8c, 0x0007, 0x1160, 0x9c8a, 0x15c0, 0x0248, 0x6858,
+	0x9c02, 0x1230, 0x7124, 0x610a, 0x2009, 0x0046, 0x080c, 0x7f4e,
+	0x7817, 0x0140, 0x2001, 0x12e5, 0x2004, 0x9005, 0x090c, 0x6d42,
+	0x0005, 0x00c6, 0x7110, 0xd1bc, 0x1904, 0x6316, 0x7108, 0x700c,
+	0x2028, 0x918c, 0x00ff, 0x2130, 0x9094, 0xff00, 0x15d8, 0x81ff,
+	0x15c8, 0x9080, 0x26c1, 0x200d, 0x918c, 0xff00, 0x810f, 0x9006,
+	0x1904, 0x6316, 0x080c, 0x4b03, 0x1904, 0x6316, 0x6612, 0x6516,
+	0x6000, 0xd0ec, 0x1904, 0x6316, 0x6204, 0x9294, 0xff00, 0x8217,
+	0x9286, 0x0006, 0x1190, 0x00c6, 0x080c, 0x7ec8, 0x001e, 0x0904,
+	0x6320, 0x6112, 0x6023, 0x0006, 0x7120, 0x610a, 0x7130, 0x6156,
+	0x2009, 0x0044, 0x080c, 0x7f4e, 0x0448, 0x080c, 0x5745, 0x1170,
+	0x6204, 0x9294, 0x00ff, 0x9286, 0x0006, 0x1140, 0x9295, 0x0600,
+	0x6206, 0x0c08, 0x190c, 0x6215, 0x11c8, 0x0860, 0x00c6, 0x080c,
+	0x7ec8, 0x001e, 0x0198, 0x6112, 0x6023, 0x0004, 0x7120, 0x610a,
+	0x9286, 0x0004, 0x1118, 0x6007, 0x0005, 0x0010, 0x6007, 0x0001,
+	0x6003, 0x0001, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x7817, 0x0140,
+	0x2001, 0x12e5, 0x2004, 0x9005, 0x090c, 0x6d42, 0x00ce, 0x0005,
+	0x2001, 0x110d, 0x2004, 0xd0ec, 0x0120, 0x2011, 0x8049, 0x080c,
+	0x37dc, 0x00c6, 0x080c, 0x984d, 0x001e, 0x0d40, 0x6112, 0x6023,
+	0x0006, 0x7120, 0x610a, 0x7130, 0x6156, 0x6017, 0x0300, 0x6003,
+	0x0001, 0x6007, 0x0041, 0x080c, 0x6886, 0x080c, 0x6d42, 0x08b0,
+	0x7110, 0xd1bc, 0x0188, 0x7020, 0x2060, 0x9c84, 0x0007, 0x1160,
+	0x9c82, 0x15c0, 0x0248, 0x6858, 0x9c02, 0x1230, 0x7124, 0x610a,
+	0x2009, 0x0045, 0x080c, 0x7f4e, 0x7817, 0x0140, 0x2001, 0x12e5,
+	0x2004, 0x9005, 0x090c, 0x6d42, 0x0005, 0x080c, 0x26bc, 0x1168,
+	0x7010, 0x9084, 0xff00, 0x8007, 0x9086, 0x0000, 0x1130, 0x9184,
+	0x000f, 0x908a, 0x0006, 0x1208, 0x000b, 0x0005, 0x6374, 0x6375,
+	0x6374, 0x6374, 0x63de, 0x63ea, 0x0005, 0x7110, 0xd1bc, 0x0120,
+	0x702c, 0xd084, 0x0904, 0x63dd, 0x700c, 0x7108, 0x080c, 0x1c69,
+	0x1904, 0x63dd, 0x080c, 0x4b03, 0x1904, 0x63dd, 0x6612, 0x6516,
+	0x6204, 0x7110, 0xd1bc, 0x01f8, 0x928c, 0x00ff, 0x9186, 0x0004,
+	0x0118, 0x9186, 0x0006, 0x15c8, 0x00c6, 0x080c, 0x63f6, 0x00ce,
+	0x0904, 0x63dd, 0x00c6, 0x080c, 0x7ec8, 0x001e, 0x05f0, 0x6112,
+	0x080c, 0x99cc, 0x6023, 0x0002, 0x7120, 0x610a, 0x2009, 0x0088,
+	0x080c, 0x7f4e, 0x0490, 0x928c, 0x00ff, 0x9186, 0x0006, 0x0160,
+	0x9186, 0x0004, 0x0148, 0x9294, 0xff00, 0x8217, 0x9286, 0x0004,
+	0x0118, 0x9286, 0x0006, 0x1188, 0x00c6, 0x080c, 0x7ec8, 0x001e,
+	0x01e0, 0x6112, 0x080c, 0x99cc, 0x6023, 0x0005, 0x7120, 0x610a,
+	0x2009, 0x0088, 0x080c, 0x7f4e, 0x0080, 0x00c6, 0x080c, 0x7ec8,
+	0x001e, 0x0158, 0x6112, 0x080c, 0x99cc, 0x6023, 0x0004, 0x7120,
+	0x610a, 0x2009, 0x0001, 0x080c, 0x7f4e, 0x0005, 0x7110, 0xd1bc,
+	0x0140, 0x00a1, 0x0130, 0x7124, 0x610a, 0x2009, 0x0089, 0x080c,
+	0x7f4e, 0x0005, 0x7110, 0xd1bc, 0x0140, 0x0041, 0x0130, 0x7124,
+	0x610a, 0x2009, 0x008a, 0x080c, 0x7f4e, 0x0005, 0x7020, 0x2060,
+	0x9c84, 0x0007, 0x1158, 0x9c82, 0x15c0, 0x0240, 0x2001, 0x1116,
+	0x2004, 0x9c02, 0x1218, 0x9085, 0x0001, 0x0005, 0x9006, 0x0ce8,
+	0x7110, 0xd1bc, 0x1178, 0x7024, 0x2060, 0x9c84, 0x0007, 0x1150,
+	0x9c82, 0x15c0, 0x0238, 0x6858, 0x9c02, 0x1220, 0x2009, 0x0051,
+	0x080c, 0x7f4e, 0x7817, 0x0140, 0x2001, 0x12e5, 0x2004, 0x9005,
+	0x090c, 0x6d42, 0x0005, 0x2031, 0x0105, 0x0069, 0x0005, 0x2031,
+	0x0206, 0x0049, 0x0005, 0x2031, 0x0207, 0x0029, 0x0005, 0x2031,
+	0x0213, 0x0009, 0x0005, 0x00c6, 0x00d6, 0x00f6, 0x7000, 0x9084,
+	0xf000, 0x9086, 0xc000, 0x05d0, 0x080c, 0x7ec8, 0x05b8, 0x0066,
+	0x00c6, 0x0046, 0x2011, 0x0263, 0x2204, 0x8211, 0x220c, 0x080c,
+	0x1c69, 0x15a0, 0x080c, 0x4b03, 0x1588, 0x6612, 0x6516, 0x2c00,
+	0x004e, 0x00ce, 0x6012, 0x080c, 0x99cc, 0x080c, 0x0ddf, 0x0510,
+	0x2d00, 0x605a, 0x6803, 0x0000, 0x6867, 0x0000, 0x6c6a, 0x9df8,
+	0x001b, 0x20a9, 0x000e, 0x20e9, 0x0001, 0x20e1, 0x0000, 0x2fa0,
+	0x2e98, 0x4003, 0x006e, 0x6616, 0x6007, 0x003e, 0x6023, 0x0001,
+	0x6003, 0x0001, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x00fe, 0x00de,
+	0x00ce, 0x0005, 0x080c, 0x7f1e, 0x006e, 0x0cc0, 0x004e, 0x00ce,
+	0x0cc8, 0x00c6, 0x7000, 0x908c, 0xff00, 0x9184, 0xf000, 0x810f,
+	0x9086, 0x2000, 0x1548, 0x9186, 0x0022, 0x11d8, 0x2001, 0x0111,
+	0x2004, 0x9005, 0x1518, 0x7030, 0x908e, 0x0400, 0x01f8, 0x908e,
+	0x6000, 0x01e0, 0x908e, 0x5400, 0x01c8, 0x908e, 0x0300, 0x1140,
+	0x2009, 0x1133, 0x210c, 0xd184, 0x0118, 0x080c, 0x5745, 0x0170,
+	0x0058, 0x9186, 0x0023, 0x1140, 0x080c, 0x63f6, 0x0128, 0x6004,
+	0x9086, 0x0002, 0x0118, 0x0000, 0x9006, 0x0010, 0x9085, 0x0001,
+	0x00ce, 0x0005, 0x2071, 0x12ef, 0x7003, 0x0003, 0x700f, 0x0361,
+	0x9006, 0x701a, 0x7012, 0x7017, 0x15c0, 0x7007, 0x0000, 0x7026,
+	0x702b, 0x772e, 0x7032, 0x7037, 0x778e, 0x703b, 0xffff, 0x703f,
+	0xffff, 0x7042, 0x7047, 0x3d63, 0x704a, 0x705b, 0x65ea, 0x2001,
+	0x1291, 0x2003, 0x0003, 0x2001, 0x1293, 0x2003, 0x0100, 0x0005,
+	0x2071, 0x12ef, 0x1d04, 0x654a, 0x2091, 0x6000, 0x700c, 0x8001,
+	0x700e, 0x1180, 0x700f, 0x0361, 0x7007, 0x0001, 0x0126, 0x2091,
+	0x8000, 0x7040, 0x900d, 0x0148, 0x8109, 0x7142, 0x1130, 0x7044,
+	0x080f, 0x0018, 0x0126, 0x2091, 0x8000, 0x7024, 0x900d, 0x0188,
+	0x7020, 0x8001, 0x7022, 0x1168, 0x7023, 0x0009, 0x8109, 0x7126,
+	0x9186, 0x03e8, 0x1110, 0x7028, 0x080f, 0x81ff, 0x1110, 0x7028,
+	0x080f, 0x7030, 0x900d, 0x0158, 0x702c, 0x8001, 0x702e, 0x1138,
+	0x702f, 0x0009, 0x8109, 0x7132, 0x1110, 0x7034, 0x080f, 0x7038,
+	0x9005, 0x0118, 0x0310, 0x8001, 0x703a, 0x703c, 0x9005, 0x0118,
+	0x0310, 0x8001, 0x703e, 0x704c, 0x900d, 0x0168, 0x7048, 0x8001,
+	0x704a, 0x1148, 0x704b, 0x0009, 0x8109, 0x714e, 0x1120, 0x7150,
+	0x714e, 0x7058, 0x080f, 0x7018, 0x900d, 0x0158, 0x7008, 0x8001,
+	0x700a, 0x1138, 0x700b, 0x0009, 0x8109, 0x711a, 0x1110, 0x701c,
+	0x080f, 0x012e, 0x7004, 0x0002, 0x6570, 0x6571, 0x6589, 0x00e6,
+	0x2071, 0x12ef, 0x7018, 0x9005, 0x1120, 0x711a, 0x721e, 0x700b,
+	0x0009, 0x00ee, 0x0005, 0x00e6, 0x0006, 0x2071, 0x12ef, 0x701c,
+	0x9206, 0x1110, 0x701a, 0x701e, 0x000e, 0x00ee, 0x0005, 0x00e6,
+	0x2071, 0x12ef, 0x6088, 0x9102, 0x0208, 0x618a, 0x00ee, 0x0005,
+	0x0005, 0x7110, 0x080c, 0x4b58, 0x1158, 0x6088, 0x8001, 0x0240,
+	0x608a, 0x1130, 0x0126, 0x2091, 0x8000, 0x080c, 0x6d42, 0x012e,
+	0x8108, 0x9182, 0x00ff, 0x0218, 0x900e, 0x7007, 0x0002, 0x7112,
+	0x0005, 0x7014, 0x2060, 0x0126, 0x2091, 0x8000, 0x6040, 0x9005,
+	0x0128, 0x8001, 0x6042, 0x1110, 0x080c, 0x9887, 0x6018, 0x9005,
+	0x0500, 0x8001, 0x601a, 0x11e8, 0x6120, 0x9186, 0x0003, 0x0118,
+	0x9186, 0x0006, 0x11a0, 0x6014, 0x2068, 0x6884, 0x908a, 0x199a,
+	0x0270, 0x9082, 0x1999, 0x6886, 0x908a, 0x199a, 0x0210, 0x2001,
+	0x1999, 0x8003, 0x800b, 0x810b, 0x9108, 0x611a, 0x0010, 0x080c,
+	0x9362, 0x012e, 0x9c88, 0x0018, 0x7116, 0x2001, 0x45c0, 0x9102,
+	0x0220, 0x7017, 0x15c0, 0x7007, 0x0000, 0x0005, 0x00e6, 0x2071,
+	0x12ef, 0x7027, 0x07d0, 0x7023, 0x0009, 0x00ee, 0x0005, 0x2001,
+	0x12f8, 0x2003, 0x0000, 0x0005, 0x00e6, 0x2071, 0x12ef, 0x7132,
+	0x702f, 0x0009, 0x00ee, 0x0005, 0x2011, 0x12fb, 0x2013, 0x0000,
+	0x0005, 0x00e6, 0x2071, 0x12ef, 0x711a, 0x721e, 0x700b, 0x0009,
+	0x00ee, 0x0005, 0x00c6, 0x0026, 0x7054, 0x8000, 0x7056, 0x2061,
+	0x1291, 0x6008, 0x9086, 0x0000, 0x0158, 0x7068, 0x6036, 0x7064,
+	0x6032, 0x7060, 0x602e, 0x705c, 0x602a, 0x2c10, 0x080c, 0x0e55,
+	0x002e, 0x00ce, 0x0005, 0x00c6, 0x2061, 0x1329, 0x00ce, 0x0005,
+	0x9184, 0x000f, 0x8003, 0x8003, 0x8003, 0x9080, 0x1329, 0x2060,
+	0x0005, 0x6884, 0x908a, 0x199a, 0x1630, 0x9005, 0x1150, 0x00c6,
+	0x2061, 0x1329, 0x6014, 0x00ce, 0x9005, 0x1130, 0x2001, 0x001e,
+	0x0018, 0x908e, 0xffff, 0x01a8, 0x8003, 0x800b, 0x810b, 0x9108,
+	0x611a, 0x687c, 0x908c, 0x00c0, 0x918e, 0x00c0, 0x0904, 0x668a,
+	0xd0b4, 0x1160, 0xd0bc, 0x15b8, 0x2009, 0x0006, 0x080c, 0x66b0,
+	0x0005, 0x900e, 0x0c68, 0x2001, 0x1999, 0x08b8, 0xd0fc, 0x0160,
+	0x908c, 0x0003, 0x0120, 0x918e, 0x0003, 0x1904, 0x66aa, 0x908c,
+	0x2020, 0x918e, 0x2020, 0x0180, 0x6024, 0xd0d4, 0x11a8, 0x2009,
+	0x1174, 0x2104, 0xd084, 0x1120, 0x2009, 0x0043, 0x0804, 0x7f4e,
+	0x2009, 0x0042, 0x0804, 0x7f4e, 0x6110, 0x210c, 0xd1ac, 0x0d60,
+	0x6024, 0xc0cd, 0x6026, 0x0c40, 0xc0d4, 0x6026, 0x6890, 0x602e,
+	0x688c, 0x6032, 0x0c20, 0xd0fc, 0x0158, 0x908c, 0x0003, 0x0118,
+	0x908e, 0x0003, 0x15b8, 0x908c, 0x2020, 0x918e, 0x2020, 0x0150,
+	0x00f6, 0x2c78, 0x080c, 0x119d, 0x00fe, 0x2009, 0x0042, 0x080c,
+	0x7f4e, 0x0005, 0x6110, 0x210c, 0xd1ac, 0x0d90, 0x6124, 0xc1cd,
+	0x6126, 0x0c70, 0xd0fc, 0x0178, 0x908c, 0x2020, 0x918e, 0x2020,
+	0x0188, 0x9084, 0x0003, 0x908e, 0x0002, 0x0138, 0x2009, 0x0041,
+	0x080c, 0x7f4e, 0x0005, 0x0091, 0x0ce8, 0x2009, 0x0043, 0x080c,
+	0x7f4e, 0x0cc0, 0x6110, 0x210c, 0xd1ac, 0x0d58, 0x6124, 0xc1cd,
+	0x6126, 0x0c38, 0x2009, 0x0004, 0x0019, 0x0005, 0x2009, 0x0001,
+	0x00d6, 0x6014, 0x90ec, 0xf000, 0x01f0, 0x2068, 0x6982, 0x6800,
+	0x6016, 0x9186, 0x0001, 0x1188, 0x697c, 0x918c, 0x8100, 0x918e,
+	0x8100, 0x1158, 0x00c6, 0x2061, 0x1329, 0x6200, 0xd28c, 0x1120,
+	0x6204, 0x8210, 0x0208, 0x6206, 0x00ce, 0x080c, 0x4ef4, 0x6014,
+	0x906d, 0x190c, 0x6611, 0x00de, 0x0005, 0x0156, 0x00c6, 0x2061,
+	0x1329, 0x6000, 0x81ff, 0x0110, 0x9205, 0x0008, 0x9204, 0x6002,
+	0x00ce, 0x015e, 0x0005, 0x6800, 0xd08c, 0x1138, 0x6808, 0x9005,
+	0x0120, 0x8001, 0x680a, 0x9085, 0x0001, 0x0005, 0x20a9, 0x0010,
+	0x9006, 0x8004, 0x80f6, 0x3e00, 0x81f6, 0x3e08, 0x1208, 0x9200,
+	0x1f04, 0x66f2, 0x80f6, 0x3e00, 0x81f6, 0x3e08, 0x0005, 0x0156,
+	0x20a9, 0x0010, 0x9005, 0x01c0, 0x911a, 0x12b0, 0x8213, 0x81f5,
+	0x3e08, 0x0228, 0x911a, 0x1220, 0x1f04, 0x6706, 0x0028, 0x911a,
+	0x2308, 0x8210, 0x1f04, 0x6706, 0x0006, 0x3200, 0x9084, 0xefff,
+	0x2080, 0x000e, 0x015e, 0x0005, 0x0006, 0x3200, 0x9085, 0x1000,
+	0x0cb8, 0x0126, 0x2091, 0x2800, 0x2079, 0x12dc, 0x012e, 0x00d6,
+	0x2069, 0x12dc, 0x6803, 0x0005, 0x0156, 0x0146, 0x01d6, 0x20e9,
+	0x0000, 0x2069, 0x0200, 0x080c, 0x7e9b, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x080c, 0x7e86, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x080c, 0x7e89, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x080c, 0x7e8c, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x080c, 0x7e8f, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x080c, 0x7e92, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x080c, 0x7e95, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x080c, 0x7e98, 0x20a9, 0x0020, 0x20a1,
+	0x0240, 0x9006, 0x4004, 0x01de, 0x014e, 0x015e, 0x2069, 0x0004,
+	0x2d04, 0x9085, 0x8001, 0x206a, 0x00de, 0x0005, 0x00c6, 0x6027,
+	0x0001, 0x7804, 0x9084, 0x0007, 0x0002, 0x678f, 0x67b3, 0x67fd,
+	0x6795, 0x67b3, 0x678f, 0x678d, 0x678d, 0x080c, 0x0cf1, 0x080c,
+	0x65cf, 0x080c, 0x6d42, 0x00ce, 0x0005, 0x62c0, 0x82ff, 0x1110,
+	0x00ce, 0x0005, 0x2011, 0x4586, 0x080c, 0x655b, 0x7828, 0x9092,
+	0x00c8, 0x1228, 0x8000, 0x782a, 0x080c, 0x45c0, 0x0c88, 0x62c0,
+	0x080c, 0x7e9f, 0x080c, 0x4586, 0x7807, 0x0003, 0x7827, 0x0000,
+	0x782b, 0x0000, 0x0c28, 0x080c, 0x65cf, 0x6220, 0xd2a4, 0x0178,
+	0x62c0, 0x82ff, 0x1160, 0x782b, 0x0000, 0x7824, 0x9065, 0x090c,
+	0x0cf1, 0x2009, 0x0013, 0x080c, 0x7f4e, 0x00ce, 0x0005, 0x00c6,
+	0x7824, 0x9065, 0x090c, 0x0cf1, 0x7804, 0x9086, 0x0004, 0x0904,
+	0x6839, 0x7828, 0x9092, 0x2710, 0x1230, 0x8000, 0x782a, 0x00ce,
+	0x080c, 0x76fd, 0x0c50, 0x2011, 0x0130, 0x2214, 0x080c, 0x7e9f,
+	0x6104, 0x9186, 0x0003, 0x1188, 0x00e6, 0x2071, 0x1100, 0x70d8,
+	0x00ee, 0xd08c, 0x0150, 0x00c6, 0x00e6, 0x2061, 0x0100, 0x2071,
+	0x1100, 0x080c, 0x45d6, 0x00ee, 0x00ce, 0x080c, 0xae07, 0x2009,
+	0x0014, 0x080c, 0x7f4e, 0x00ce, 0x0840, 0x2001, 0x12f8, 0x2003,
+	0x0000, 0x62c0, 0x82ff, 0x1160, 0x782b, 0x0000, 0x7824, 0x9065,
+	0x090c, 0x0cf1, 0x2009, 0x0013, 0x080c, 0x7fa6, 0x00ce, 0x0005,
+	0x00c6, 0x00d6, 0x7824, 0x9005, 0x090c, 0x0cf1, 0x781c, 0x906d,
+	0x090c, 0x0cf1, 0x080c, 0x7e9f, 0x6800, 0xc0dc, 0x6802, 0x7924,
+	0x2160, 0x080c, 0x7f1e, 0x693c, 0x81ff, 0x090c, 0x0cf1, 0x8109,
+	0x693e, 0x6854, 0x9015, 0x0110, 0x7a1e, 0x0010, 0x7918, 0x791e,
+	0x7807, 0x0000, 0x7827, 0x0000, 0x00de, 0x00ce, 0x080c, 0x6d42,
+	0x08a8, 0x6104, 0x9186, 0x0002, 0x0128, 0x9186, 0x0004, 0x0110,
+	0x0804, 0x67d1, 0x7808, 0x9c06, 0x0904, 0x67d1, 0x080c, 0x6c56,
+	0x080c, 0x68ce, 0x00ce, 0x080c, 0x6d42, 0x0804, 0x67c5, 0x00c6,
+	0x6024, 0x6027, 0x0002, 0xd0f4, 0x1550, 0x62c8, 0x60c4, 0x9205,
+	0x1170, 0x783c, 0x9065, 0x0130, 0x2009, 0x0049, 0x080c, 0x7f4e,
+	0x00ce, 0x0005, 0x2011, 0x12fb, 0x2013, 0x0000, 0x0cc8, 0x793c,
+	0x81ff, 0x0dc0, 0x793c, 0x9188, 0x0008, 0x210c, 0x918e, 0x0006,
+	0x1138, 0x6014, 0x9084, 0x1984, 0x9085, 0x0012, 0x6016, 0x0c40,
+	0x6014, 0x9084, 0x1984, 0x9085, 0x0016, 0x6016, 0x0c08, 0x793c,
+	0x2160, 0x2009, 0x004a, 0x080c, 0x7f4e, 0x08d0, 0x0006, 0x0016,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x600f, 0x0000, 0x2c08, 0x2061,
+	0x12dc, 0x6020, 0x8000, 0x6022, 0x6010, 0x9005, 0x0148, 0x9080,
+	0x0003, 0x2102, 0x6112, 0x012e, 0x00ce, 0x001e, 0x000e, 0x0005,
+	0x6116, 0x6112, 0x0cc0, 0x00d6, 0x2069, 0x12dc, 0x6000, 0xd0d4,
+	0x0178, 0x6820, 0x8000, 0x6822, 0x9086, 0x0001, 0x1110, 0x2c00,
+	0x681e, 0x6804, 0x9084, 0x0007, 0x0804, 0x6d59, 0x00de, 0x0005,
+	0xc0d5, 0x6002, 0x6818, 0x9005, 0x0158, 0x6056, 0x605b, 0x0000,
+	0x0006, 0x2c00, 0x681a, 0x00de, 0x685a, 0x2069, 0x12dc, 0x0c08,
+	0x6056, 0x605a, 0x2c00, 0x681a, 0x681e, 0x08d8, 0x0006, 0x0016,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x600f, 0x0000, 0x2c08, 0x2061,
+	0x12dc, 0x6020, 0x8000, 0x6022, 0x6008, 0x9005, 0x0148, 0x9080,
+	0x0003, 0x2102, 0x610a, 0x012e, 0x00ce, 0x001e, 0x000e, 0x0005,
+	0x610e, 0x610a, 0x0cc0, 0x00c6, 0x600f, 0x0000, 0x2c08, 0x2061,
+	0x12dc, 0x6034, 0x9005, 0x0130, 0x9080, 0x0003, 0x2102, 0x6136,
+	0x00ce, 0x0005, 0x613a, 0x6136, 0x00ce, 0x0005, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0076, 0x0066, 0x0026, 0x0016, 0x0006, 0x0126,
+	0x2071, 0x12dc, 0x7638, 0x2660, 0x2678, 0x2091, 0x8000, 0x8cff,
+	0x0904, 0x696a, 0x6010, 0x9080, 0x0028, 0x2004, 0x9206, 0x1904,
+	0x6965, 0x87ff, 0x0120, 0x6054, 0x9106, 0x1904, 0x6965, 0x703c,
+	0x9c06, 0x1170, 0x0036, 0x2019, 0x0001, 0x080c, 0x7936, 0x7033,
+	0x0000, 0x703f, 0x0000, 0x7043, 0x0000, 0x7047, 0x0000, 0x003e,
+	0x7038, 0x9c36, 0x1110, 0x660c, 0x763a, 0x7034, 0x9c36, 0x1140,
+	0x2c00, 0x9f36, 0x0118, 0x2f00, 0x7036, 0x0010, 0x7037, 0x0000,
+	0x660c, 0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008, 0x2678,
+	0x600f, 0x0000, 0x080c, 0x95d2, 0x0198, 0x6014, 0x2068, 0x6020,
+	0x9086, 0x0003, 0x1510, 0x6867, 0x0103, 0x6b7a, 0x6877, 0x0000,
+	0x080c, 0x9843, 0x080c, 0xad5f, 0x080c, 0x50a5, 0x080c, 0x9797,
+	0x080c, 0x97a3, 0x00ce, 0x0804, 0x690f, 0x2c78, 0x600c, 0x2060,
+	0x0804, 0x690f, 0x012e, 0x000e, 0x001e, 0x002e, 0x006e, 0x007e,
+	0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x6020, 0x9086, 0x0006,
+	0x1128, 0x080c, 0xad5f, 0x080c, 0xaa84, 0x0c10, 0x08a0, 0x0006,
+	0x0066, 0x00c6, 0x00d6, 0x00f6, 0x2031, 0x0000, 0x0126, 0x2091,
+	0x8000, 0x2079, 0x12dc, 0x7838, 0x9065, 0x0558, 0x600c, 0x0006,
+	0x600f, 0x0000, 0x783c, 0x9c06, 0x1170, 0x0036, 0x2019, 0x0001,
+	0x080c, 0x7936, 0x7833, 0x0000, 0x783f, 0x0000, 0x7843, 0x0000,
+	0x7847, 0x0000, 0x003e, 0x080c, 0x95d2, 0x0178, 0x6014, 0x2068,
+	0x6020, 0x9086, 0x0003, 0x11b0, 0x6867, 0x0103, 0x6b7a, 0x6877,
+	0x0000, 0x080c, 0x50a5, 0x080c, 0x9797, 0x080c, 0x97a3, 0x000e,
+	0x0898, 0x7e3a, 0x7e36, 0x012e, 0x00fe, 0x00de, 0x00ce, 0x006e,
+	0x000e, 0x0005, 0x6020, 0x9086, 0x0006, 0x1118, 0x080c, 0xaa84,
+	0x0c60, 0x0c10, 0x0016, 0x0026, 0x0086, 0x2041, 0x0000, 0x0099,
+	0x080c, 0x6a8c, 0x008e, 0x002e, 0x001e, 0x0005, 0x00f6, 0x0126,
+	0x2079, 0x12dc, 0x2091, 0x8000, 0x080c, 0x6b19, 0x080c, 0x6b8b,
+	0x012e, 0x00fe, 0x0005, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0066,
+	0x0016, 0x0006, 0x0126, 0x2091, 0x8000, 0x2071, 0x12dc, 0x7614,
+	0x2660, 0x2678, 0x8cff, 0x0904, 0x6a68, 0x6010, 0x9080, 0x0028,
+	0x2004, 0x9206, 0x1904, 0x6a63, 0x88ff, 0x0120, 0x6054, 0x9106,
+	0x1904, 0x6a63, 0x7024, 0x9c06, 0x1538, 0x2069, 0x0100, 0x68c0,
+	0x9005, 0x01f0, 0x080c, 0x65cf, 0x080c, 0x7721, 0x68c3, 0x0000,
+	0x080c, 0x7b56, 0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04,
+	0x9384, 0x1000, 0x0120, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069,
+	0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x0020,
+	0x6003, 0x0009, 0x630a, 0x04b8, 0x7014, 0x9c36, 0x1110, 0x660c,
+	0x7616, 0x7010, 0x9c36, 0x1140, 0x2c00, 0x9f36, 0x0118, 0x2f00,
+	0x7012, 0x0010, 0x7013, 0x0000, 0x660c, 0x0066, 0x2c00, 0x9f06,
+	0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x6014, 0x2068,
+	0x080c, 0x95d2, 0x0188, 0x6020, 0x9086, 0x0003, 0x1510, 0x6867,
+	0x0103, 0x6b7a, 0x6877, 0x0000, 0x080c, 0x9843, 0x080c, 0xad5f,
+	0x080c, 0x50a5, 0x080c, 0x9797, 0x080c, 0x97a3, 0x080c, 0x7a3e,
+	0x00ce, 0x0804, 0x69f2, 0x2c78, 0x600c, 0x2060, 0x0804, 0x69f2,
+	0x012e, 0x000e, 0x001e, 0x006e, 0x00ce, 0x00de, 0x00ee, 0x00fe,
+	0x0005, 0x6020, 0x9086, 0x0006, 0x1128, 0x080c, 0xad5f, 0x080c,
+	0xaa84, 0x0c10, 0x6020, 0x9086, 0x0002, 0x1128, 0x6004, 0x9086,
+	0x0085, 0x0968, 0x08c8, 0x6020, 0x9086, 0x0005, 0x19a8, 0x6004,
+	0x9086, 0x0085, 0x0d50, 0x0880, 0x00c6, 0x0006, 0x0126, 0x2091,
+	0x8000, 0x9280, 0x1000, 0x2004, 0x9065, 0x0904, 0x6b15, 0x00f6,
+	0x00e6, 0x00d6, 0x0066, 0x2071, 0x12dc, 0x6654, 0x7018, 0x9c06,
+	0x1108, 0x761a, 0x701c, 0x9c06, 0x1130, 0x86ff, 0x1118, 0x7018,
+	0x701e, 0x0008, 0x761e, 0x6058, 0x907d, 0x0108, 0x7e56, 0x96ed,
+	0x0000, 0x0110, 0x2f00, 0x685a, 0x6057, 0x0000, 0x605b, 0x0000,
+	0x6000, 0xc0d4, 0xc0dc, 0x6002, 0x080c, 0x4a97, 0x0904, 0x6b11,
+	0x7624, 0x86ff, 0x05e8, 0x9680, 0x0005, 0x2004, 0x9d06, 0x15c0,
+	0x00d6, 0x2069, 0x0100, 0x68c0, 0x9005, 0x0548, 0x080c, 0x65cf,
+	0x080c, 0x7721, 0x68c3, 0x0000, 0x080c, 0x7b56, 0x7027, 0x0000,
+	0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0120, 0x6803,
+	0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110,
+	0x6827, 0x0001, 0x003e, 0x00de, 0x00c6, 0x603c, 0x9005, 0x0110,
+	0x8001, 0x603e, 0x2660, 0x080c, 0x97a3, 0x00ce, 0x0048, 0x00de,
+	0x00c6, 0x2660, 0x6003, 0x0009, 0x630a, 0x00ce, 0x0804, 0x6abc,
+	0x8dff, 0x0158, 0x6867, 0x0103, 0x6b7a, 0x6877, 0x0000, 0x080c,
+	0x9843, 0x080c, 0xad5f, 0x080c, 0x50a5, 0x080c, 0x7a3e, 0x0804,
+	0x6abc, 0x006e, 0x00de, 0x00ee, 0x00fe, 0x012e, 0x000e, 0x00ce,
+	0x0005, 0x0006, 0x0066, 0x00c6, 0x00d6, 0x2031, 0x0000, 0x7814,
+	0x9065, 0x0904, 0x6b6b, 0x600c, 0x0006, 0x600f, 0x0000, 0x7824,
+	0x9c06, 0x1540, 0x2069, 0x0100, 0x68c0, 0x9005, 0x01f0, 0x080c,
+	0x65cf, 0x080c, 0x7721, 0x68c3, 0x0000, 0x080c, 0x7b56, 0x7827,
+	0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0120,
+	0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084,
+	0x0110, 0x6827, 0x0001, 0x003e, 0x0028, 0x6003, 0x0009, 0x630a,
+	0x2c30, 0x00b0, 0x6014, 0x2068, 0x080c, 0x95d2, 0x0168, 0x6020,
+	0x9086, 0x0003, 0x11b8, 0x6867, 0x0103, 0x6b7a, 0x6877, 0x0000,
+	0x080c, 0x50a5, 0x080c, 0x9797, 0x080c, 0x97a3, 0x080c, 0x7a3e,
+	0x000e, 0x0804, 0x6b20, 0x7e16, 0x7e12, 0x00de, 0x00ce, 0x006e,
+	0x000e, 0x0005, 0x6020, 0x9086, 0x0006, 0x1118, 0x080c, 0xaa84,
+	0x0c58, 0x6020, 0x9086, 0x0002, 0x1128, 0x6004, 0x9086, 0x0085,
+	0x09d0, 0x0c10, 0x6020, 0x9086, 0x0005, 0x19f0, 0x6004, 0x9086,
+	0x0085, 0x0d60, 0x08c8, 0x0006, 0x0066, 0x00c6, 0x00d6, 0x7818,
+	0x9065, 0x0904, 0x6bf1, 0x6054, 0x0006, 0x6057, 0x0000, 0x605b,
+	0x0000, 0x6000, 0xc0d4, 0xc0dc, 0x6002, 0x080c, 0x4a97, 0x0904,
+	0x6bee, 0x7e24, 0x86ff, 0x05e8, 0x9680, 0x0005, 0x2004, 0x9d06,
+	0x15c0, 0x00d6, 0x2069, 0x0100, 0x68c0, 0x9005, 0x0548, 0x080c,
+	0x65cf, 0x080c, 0x7721, 0x68c3, 0x0000, 0x080c, 0x7b56, 0x7827,
+	0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0120,
+	0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084,
+	0x0110, 0x6827, 0x0001, 0x003e, 0x00de, 0x00c6, 0x603c, 0x9005,
+	0x0110, 0x8001, 0x603e, 0x2660, 0x080c, 0x97a3, 0x00ce, 0x0048,
+	0x00de, 0x00c6, 0x2660, 0x6003, 0x0009, 0x630a, 0x00ce, 0x0804,
+	0x6b9d, 0x8dff, 0x0138, 0x6867, 0x0103, 0x6b7a, 0x6877, 0x0000,
+	0x080c, 0x50a5, 0x080c, 0x7a3e, 0x0804, 0x6b9d, 0x000e, 0x0804,
+	0x6b90, 0x781e, 0x781a, 0x00de, 0x00ce, 0x006e, 0x000e, 0x0005,
+	0x00e6, 0x00d6, 0x0066, 0x6000, 0xd0dc, 0x0188, 0x604c, 0x906d,
+	0x0170, 0x6878, 0x9606, 0x1158, 0x2071, 0x12dc, 0x7024, 0x9035,
+	0x0130, 0x9080, 0x0005, 0x2004, 0x9d06, 0x1108, 0x0021, 0x006e,
+	0x00de, 0x00ee, 0x0005, 0x00f6, 0x2079, 0x0100, 0x78c0, 0x9005,
+	0x1138, 0x00c6, 0x2660, 0x6003, 0x0009, 0x630a, 0x00ce, 0x04a0,
+	0x080c, 0x7721, 0x78c3, 0x0000, 0x080c, 0x7b56, 0x7027, 0x0000,
+	0x0036, 0x2079, 0x0140, 0x7b04, 0x9384, 0x1000, 0x0120, 0x7803,
+	0x0100, 0x7803, 0x0000, 0x2079, 0x0100, 0x7824, 0xd084, 0x0110,
+	0x7827, 0x0001, 0x080c, 0x7b56, 0x003e, 0x080c, 0x4a97, 0x00c6,
+	0x603c, 0x9005, 0x0110, 0x8001, 0x603e, 0x2660, 0x080c, 0x7f1e,
+	0x00ce, 0x6867, 0x0103, 0x6b7a, 0x6877, 0x0000, 0x080c, 0x9843,
+	0x080c, 0x50a5, 0x080c, 0x7a3e, 0x00fe, 0x0005, 0x00e6, 0x00c6,
+	0x2001, 0x110c, 0x2014, 0xc2e4, 0x2202, 0x2071, 0x12dc, 0x7004,
+	0x9084, 0x0007, 0x0002, 0x6c6d, 0x6c70, 0x6c86, 0x6ca4, 0x6cdd,
+	0x6c6d, 0x6c6b, 0x6c6b, 0x080c, 0x0cf1, 0x00ce, 0x00ee, 0x0005,
+	0x7024, 0x9065, 0x0148, 0x7020, 0x8001, 0x7022, 0x600c, 0x9015,
+	0x0150, 0x7216, 0x600f, 0x0000, 0x7007, 0x0000, 0x7027, 0x0000,
+	0x00ce, 0x00ee, 0x0005, 0x7216, 0x7212, 0x0cb0, 0x6010, 0x2060,
+	0x080c, 0x4a97, 0x6000, 0xc0dc, 0x6002, 0x7007, 0x0000, 0x7027,
+	0x0000, 0x7020, 0x8001, 0x7022, 0x1118, 0x00ce, 0x00ee, 0x0005,
+	0x6054, 0x9015, 0x0120, 0x721e, 0x080c, 0x6d42, 0x0cb0, 0x7218,
+	0x721e, 0x080c, 0x6d42, 0x0c88, 0x7024, 0x9065, 0x0598, 0x700c,
+	0x9c06, 0x1160, 0x080c, 0x7a3e, 0x600c, 0x9015, 0x0120, 0x720e,
+	0x600f, 0x0000, 0x0428, 0x720e, 0x720a, 0x0410, 0x7014, 0x9c06,
+	0x1160, 0x080c, 0x7a3e, 0x600c, 0x9015, 0x0120, 0x7216, 0x600f,
+	0x0000, 0x00b0, 0x7216, 0x7212, 0x0098, 0x6010, 0x2060, 0x080c,
+	0x4a97, 0x6000, 0xc0dc, 0x6002, 0x080c, 0x7a3e, 0x701c, 0x9065,
+	0x0138, 0x6054, 0x9015, 0x0110, 0x721e, 0x0010, 0x7218, 0x721e,
+	0x7027, 0x0000, 0x00ce, 0x00ee, 0x0005, 0x7024, 0x9065, 0x0140,
+	0x080c, 0x7a3e, 0x600c, 0x9015, 0x0150, 0x720e, 0x600f, 0x0000,
+	0x080c, 0x7b56, 0x7027, 0x0000, 0x00ce, 0x00ee, 0x0005, 0x720e,
+	0x720a, 0x0cb0, 0x00d6, 0x2069, 0x12dc, 0x6830, 0x9084, 0x0003,
+	0x0002, 0x6cff, 0x6d01, 0x6d25, 0x6cfd, 0x080c, 0x0cf1, 0x00de,
+	0x0005, 0x00c6, 0x6840, 0x9086, 0x0001, 0x01b8, 0x683c, 0x9065,
+	0x0130, 0x600c, 0x9015, 0x0170, 0x6a3a, 0x600f, 0x0000, 0x6833,
+	0x0000, 0x683f, 0x0000, 0x2011, 0x12fb, 0x2013, 0x0000, 0x00ce,
+	0x00de, 0x0005, 0x683a, 0x6836, 0x0c90, 0x6843, 0x0000, 0x6838,
+	0x9065, 0x0d68, 0x6003, 0x0003, 0x0c50, 0x00c6, 0x6843, 0x0000,
+	0x6847, 0x0000, 0x683c, 0x9065, 0x0168, 0x600c, 0x9015, 0x0130,
+	0x6a3a, 0x600f, 0x0000, 0x683f, 0x0000, 0x0020, 0x683f, 0x0000,
+	0x683a, 0x6836, 0x00ce, 0x00de, 0x0005, 0xc1e5, 0x2001, 0x110c,
+	0x2102, 0x0005, 0x2001, 0x110c, 0x200c, 0xd1ec, 0x0138, 0xc1ec,
+	0x2102, 0x080c, 0x6e10, 0x2001, 0x110c, 0x200c, 0x9184, 0x0600,
+	0x9086, 0x0600, 0x0d50, 0x00d6, 0x2069, 0x12dc, 0x6804, 0x9084,
+	0x0007, 0x0002, 0x6d64, 0x6def, 0x6def, 0x6def, 0x6def, 0x6df1,
+	0x6d62, 0x6d62, 0x080c, 0x0cf1, 0x6820, 0x9005, 0x1110, 0x00de,
+	0x0005, 0x00c6, 0x680c, 0x9065, 0x0150, 0x6807, 0x0004, 0x6826,
+	0x682b, 0x0000, 0x080c, 0x6e53, 0x00ce, 0x00de, 0x0005, 0x6814,
+	0x9065, 0x0150, 0x6807, 0x0001, 0x6826, 0x682b, 0x0000, 0x080c,
+	0x6e53, 0x00ce, 0x00de, 0x0005, 0x00e6, 0x6a1c, 0x92f5, 0x0000,
+	0x0904, 0x6dec, 0x704c, 0x900d, 0x0118, 0x7088, 0x9005, 0x01a0,
+	0x7054, 0x9075, 0x0120, 0x920e, 0x0904, 0x6dec, 0x0028, 0x6818,
+	0x920e, 0x0904, 0x6dec, 0x2070, 0x704c, 0x900d, 0x0d88, 0x7088,
+	0x9005, 0x1d70, 0x2e00, 0x681e, 0x733c, 0x7038, 0x9302, 0x1e40,
+	0x080c, 0x7ef5, 0x0904, 0x6dec, 0x8318, 0x733e, 0x6116, 0x2e10,
+	0x6212, 0x9180, 0x0020, 0x2004, 0x9084, 0x00ff, 0x605e, 0x9180,
+	0x0020, 0x2003, 0x0000, 0x9180, 0x0021, 0x2004, 0x908a, 0x199a,
+	0x0210, 0x2001, 0x1999, 0x8003, 0x801b, 0x831b, 0x9318, 0x631a,
+	0x00f6, 0x2c78, 0x2061, 0x0100, 0x609b, 0x0000, 0x00d6, 0x00e6,
+	0x2069, 0x0200, 0x2071, 0x0240, 0x080c, 0x738a, 0x00ee, 0x00de,
+	0x7300, 0xc3dd, 0x7302, 0x6807, 0x0002, 0x2f18, 0x6b26, 0x682b,
+	0x0000, 0x7823, 0x0003, 0x7803, 0x0001, 0x7807, 0x0040, 0x00fe,
+	0x00ee, 0x00ce, 0x00de, 0x0005, 0x00ee, 0x00ce, 0x0cd8, 0x00de,
+	0x0005, 0x00c6, 0x680c, 0x9065, 0x0138, 0x6807, 0x0004, 0x6826,
+	0x682b, 0x0000, 0x080c, 0x6e53, 0x00ce, 0x00de, 0x0005, 0x2001,
+	0x110c, 0x2014, 0xc2ed, 0x2202, 0x00de, 0x00fe, 0x0005, 0x2001,
+	0x110c, 0x2014, 0xd2e4, 0x0120, 0xc2e4, 0x2202, 0x080c, 0x6d53,
+	0x00f6, 0x00d6, 0x2069, 0x12dc, 0x6830, 0x9086, 0x0000, 0x11e0,
+	0x2001, 0x110c, 0x200c, 0xd1c4, 0x11d0, 0x6838, 0x907d, 0x01a0,
+	0x6a04, 0x9296, 0x0000, 0x19d8, 0x6833, 0x0001, 0x683e, 0x6847,
+	0x0000, 0x0126, 0x00f6, 0x2091, 0x2400, 0x002e, 0x080c, 0x1421,
+	0x1178, 0x012e, 0x080c, 0x75b1, 0x00de, 0x00fe, 0x0005, 0xc1c4,
+	0x2102, 0x0066, 0x2031, 0x0001, 0x080c, 0x57d6, 0x006e, 0x08e8,
+	0x012e, 0x6843, 0x0000, 0x7803, 0x0002, 0x780c, 0x9015, 0x0140,
+	0x6a3a, 0x780f, 0x0000, 0x6833, 0x0000, 0x683f, 0x0000, 0x0c20,
+	0x683a, 0x6836, 0x0cc0, 0x6020, 0x9084, 0x000f, 0x000b, 0x0005,
+	0x6e66, 0x6e6b, 0x7280, 0x733f, 0x6e6b, 0x7280, 0x733f, 0x6e66,
+	0x6e6b, 0x6e66, 0x6e66, 0x6e66, 0x6e66, 0x6e66, 0x080c, 0x6c56,
+	0x080c, 0x6d42, 0x0005, 0x0156, 0x0136, 0x0146, 0x01c6, 0x01d6,
+	0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x2069, 0x0200, 0x2071, 0x0240,
+	0x6004, 0x908a, 0x004c, 0x1a0c, 0x0cf1, 0x6110, 0x2178, 0x79a0,
+	0x2011, 0x1133, 0x2214, 0xd2ac, 0x1110, 0xd1bc, 0x0150, 0x7900,
+	0xd1f4, 0x0120, 0x7914, 0x918c, 0x00ff, 0x0040, 0x2009, 0x0000,
+	0x0028, 0x91f8, 0x26c1, 0x2f0d, 0x918c, 0x00ff, 0x2c78, 0x2061,
+	0x0100, 0x619a, 0x908a, 0x0040, 0x1a04, 0x6eeb, 0x0053, 0x00fe,
+	0x00ee, 0x00de, 0x00ce, 0x01de, 0x01ce, 0x014e, 0x013e, 0x015e,
+	0x0005, 0x6fc3, 0x7004, 0x7033, 0x70d5, 0x70f8, 0x70fe, 0x710c,
+	0x7115, 0x7122, 0x7128, 0x713a, 0x7128, 0x718a, 0x7115, 0x7197,
+	0x719d, 0x7122, 0x719d, 0x71aa, 0x6ee9, 0x6ee9, 0x6ee9, 0x6ee9,
+	0x6ee9, 0x6ee9, 0x6ee9, 0x6ee9, 0x6ee9, 0x6ee9, 0x6ee9, 0x7802,
+	0x7819, 0x7824, 0x7845, 0x7867, 0x710c, 0x6ee9, 0x710c, 0x7128,
+	0x6ee9, 0x7033, 0x70d5, 0x6ee9, 0x7c3b, 0x7128, 0x6ee9, 0x7c57,
+	0x7128, 0x6ee9, 0x7122, 0x6fbc, 0x6f05, 0x6ee9, 0x7c6e, 0x7cdb,
+	0x7db2, 0x6ee9, 0x7dbf, 0x7109, 0x7dd5, 0x6ee9, 0x7872, 0x7e0f,
+	0x6ee9, 0x080c, 0x0cf1, 0x2100, 0x0053, 0x00fe, 0x00ee, 0x00de,
+	0x00ce, 0x01de, 0x01ce, 0x014e, 0x013e, 0x015e, 0x0005, 0x6f03,
+	0x6f03, 0x6f03, 0x6f2b, 0x6f45, 0x6f55, 0x6f03, 0x6f03, 0x6f03,
+	0x6f8e, 0x6f9d, 0x6f03, 0x080c, 0x0cf1, 0x00d6, 0x080c, 0x71be,
+	0x7003, 0x2414, 0x7007, 0x0018, 0x700b, 0x0800, 0x7814, 0x2068,
+	0x683c, 0x700e, 0x6850, 0x7022, 0x6854, 0x7026, 0x60c3, 0x0018,
+	0x080c, 0x76f5, 0x00de, 0x0005, 0x00d6, 0x7810, 0x2068, 0x68a0,
+	0x2069, 0x1100, 0x6acc, 0xd2ac, 0x1110, 0xd0bc, 0x0110, 0x9085,
+	0x0001, 0x00de, 0x0005, 0x00d6, 0x080c, 0x71be, 0x7003, 0x0500,
+	0x7814, 0x90e8, 0x001b, 0x6808, 0x700a, 0x680c, 0x700e, 0x6810,
+	0x7012, 0x6814, 0x7016, 0x6818, 0x701a, 0x681c, 0x701e, 0x60c3,
+	0x0010, 0x080c, 0x76f5, 0x00de, 0x0005, 0x080c, 0x71be, 0x7003,
+	0x7800, 0x7007, 0x0000, 0x7808, 0x8007, 0x700a, 0x700f, 0x0000,
+	0x60c3, 0x0008, 0x080c, 0x76f5, 0x0005, 0x00d6, 0x00e6, 0x080c,
+	0x7234, 0x2073, 0x0200, 0x8e70, 0x2073, 0x0000, 0x8e70, 0x2073,
+	0xdf10, 0x8e70, 0x2073, 0x0034, 0x8e70, 0x2069, 0x1105, 0x20a9,
+	0x0004, 0x2d76, 0x8d68, 0x8e70, 0x1f04, 0x6f69, 0x2069, 0x1101,
+	0x20a9, 0x0004, 0x2d76, 0x8d68, 0x8e70, 0x1f04, 0x6f72, 0x2069,
+	0x12c2, 0x20a9, 0x001a, 0x2d04, 0x8007, 0x2072, 0x8d68, 0x8e70,
+	0x1f04, 0x6f7b, 0x2073, 0x0000, 0x8e70, 0x2073, 0x0000, 0x60c3,
+	0x004c, 0x080c, 0x76f5, 0x00ee, 0x00de, 0x0005, 0x080c, 0x71be,
+	0x7003, 0x6300, 0x7007, 0x0028, 0x700b, 0x0000, 0x7808, 0x700e,
+	0x60c3, 0x0008, 0x080c, 0x76f5, 0x0005, 0x00d6, 0x0026, 0x0016,
+	0x080c, 0x7234, 0x7003, 0x0200, 0x7814, 0x700e, 0x00e6, 0x9ef0,
+	0x0004, 0x2009, 0x0001, 0x2011, 0x000c, 0x2073, 0x0800, 0x8e70,
+	0x2073, 0x0000, 0x00ee, 0x7206, 0x710a, 0x62c2, 0x080c, 0x76f5,
+	0x001e, 0x002e, 0x00de, 0x0005, 0x2001, 0x1114, 0x2004, 0x609a,
+	0x080c, 0x76f5, 0x0005, 0x080c, 0x71be, 0x7003, 0x5200, 0x2069,
+	0x1152, 0x6804, 0xd084, 0x0130, 0x6828, 0x0016, 0x080c, 0x1c7d,
+	0x710e, 0x001e, 0x20a9, 0x0004, 0x20e1, 0x0001, 0x2099, 0x1105,
+	0x20e9, 0x0000, 0x20a1, 0x0250, 0x4003, 0x20a9, 0x0004, 0x2099,
+	0x1101, 0x20a1, 0x0254, 0x4003, 0x2001, 0x1133, 0x2004, 0xd0ac,
+	0x1138, 0x7810, 0x9080, 0x0028, 0x2004, 0x9082, 0x007f, 0x0248,
+	0x2001, 0x111b, 0x2004, 0x7032, 0x2001, 0x111c, 0x2004, 0x7036,
+	0x0030, 0x2001, 0x1114, 0x2004, 0x9084, 0x00ff, 0x7036, 0x60c3,
+	0x001c, 0x080c, 0x76f5, 0x0005, 0x080c, 0x71be, 0x7003, 0x0500,
+	0x2001, 0x1133, 0x2004, 0xd0ac, 0x1138, 0x7810, 0x9080, 0x0028,
+	0x2004, 0x9082, 0x007f, 0x0248, 0x2001, 0x111b, 0x2004, 0x700a,
+	0x2001, 0x111c, 0x2004, 0x700e, 0x0030, 0x2001, 0x1114, 0x2004,
+	0x9084, 0x00ff, 0x700e, 0x20a9, 0x0004, 0x20e1, 0x0001, 0x2099,
+	0x1105, 0x20e9, 0x0000, 0x20a1, 0x0250, 0x4003, 0x60c3, 0x0010,
+	0x080c, 0x76f5, 0x0005, 0x080c, 0x71be, 0x00c6, 0x7810, 0x2060,
+	0x2001, 0x0000, 0x080c, 0x4dea, 0x00ce, 0x7810, 0x9080, 0x0028,
+	0x2004, 0x9086, 0x007e, 0x1130, 0x7003, 0x0400, 0x620c, 0xc2b4,
+	0x620e, 0x0010, 0x7003, 0x0300, 0x7810, 0x9080, 0x0028, 0x2004,
+	0x9086, 0x007e, 0x1904, 0x70a1, 0x00d6, 0x2069, 0x127f, 0x2001,
+	0x1133, 0x2004, 0xd0a4, 0x0178, 0x6800, 0x700a, 0x6808, 0x9084,
+	0x2000, 0x7012, 0x680c, 0x7016, 0x701f, 0x2710, 0x6818, 0x7022,
+	0x681c, 0x7026, 0x0080, 0x6800, 0x700a, 0x6804, 0x700e, 0x6808,
+	0x080c, 0x5745, 0x1118, 0x9084, 0x37ff, 0x0010, 0x9084, 0x3fff,
+	0x7012, 0x680c, 0x7016, 0x00de, 0x20a9, 0x0004, 0x20e1, 0x0001,
+	0x2099, 0x1105, 0x20e9, 0x0000, 0x20a1, 0x0256, 0x4003, 0x20a9,
+	0x0004, 0x2099, 0x1101, 0x20a1, 0x025a, 0x4003, 0x00d6, 0x080c,
+	0x7e86, 0x2069, 0x1287, 0x2071, 0x024e, 0x6800, 0xc0dd, 0x7002,
+	0x2001, 0x1172, 0x2004, 0xd0e4, 0x0110, 0x680c, 0x700e, 0x00de,
+	0x0478, 0x2001, 0x1133, 0x2004, 0xd0a4, 0x0140, 0x2001, 0x1280,
+	0x2004, 0x60e3, 0x0000, 0x080c, 0x1cbe, 0x60e2, 0x20e1, 0x0001,
+	0x2099, 0x127f, 0x20e9, 0x0000, 0x20a1, 0x024e, 0x20a9, 0x0008,
+	0x4003, 0x20a9, 0x0004, 0x2099, 0x1105, 0x20a1, 0x0256, 0x4003,
+	0x20a9, 0x0004, 0x2099, 0x1101, 0x20a1, 0x025a, 0x4003, 0x080c,
+	0x7e86, 0x20a1, 0x024e, 0x20a9, 0x0008, 0x2099, 0x1287, 0x4003,
+	0x60c3, 0x0074, 0x080c, 0x76f5, 0x0005, 0x080c, 0x71be, 0x7003,
+	0x2010, 0x7007, 0x0014, 0x700b, 0x0800, 0x700f, 0x2000, 0x9006,
+	0x00f6, 0x2079, 0x1152, 0x7904, 0x00fe, 0xd1ac, 0x1110, 0x9085,
+	0x0020, 0xd1a4, 0x0110, 0x9085, 0x0010, 0x9085, 0x0002, 0x00d6,
+	0x0804, 0x716e, 0x7026, 0x60c3, 0x0014, 0x080c, 0x76f5, 0x0005,
+	0x080c, 0x71be, 0x7003, 0x5000, 0x0804, 0x704c, 0x080c, 0x71be,
+	0x7003, 0x2110, 0x7007, 0x0014, 0x60c3, 0x0014, 0x080c, 0x76f5,
+	0x0005, 0x080c, 0x722b, 0x0010, 0x080c, 0x7234, 0x7003, 0x0200,
+	0x60c3, 0x0004, 0x080c, 0x76f5, 0x0005, 0x080c, 0x7234, 0x7003,
+	0x0100, 0x700b, 0x0003, 0x700f, 0x2a00, 0x60c3, 0x0008, 0x080c,
+	0x76f5, 0x0005, 0x080c, 0x7234, 0x7003, 0x0200, 0x0804, 0x704c,
+	0x080c, 0x7234, 0x7003, 0x0100, 0x782c, 0x9005, 0x0110, 0x700a,
+	0x0010, 0x700b, 0x0003, 0x7814, 0x700e, 0x60c3, 0x0008, 0x080c,
+	0x76f5, 0x0005, 0x00d6, 0x080c, 0x7234, 0x7003, 0x0210, 0x7007,
+	0x0014, 0x700b, 0x0800, 0x7810, 0x2068, 0x6894, 0x9086, 0x0014,
+	0x1178, 0x6998, 0x9184, 0xc000, 0x1140, 0xd1ec, 0x0118, 0x700f,
+	0x2100, 0x0040, 0x700f, 0x0100, 0x0028, 0x700f, 0x0400, 0x0010,
+	0x700f, 0x0700, 0x00f6, 0x2079, 0x1152, 0x7904, 0x00fe, 0xd1ac,
+	0x1110, 0x9085, 0x0020, 0xd1a4, 0x0110, 0x9085, 0x0010, 0x2009,
+	0x1174, 0x210c, 0xd184, 0x1110, 0x9085, 0x0002, 0x0026, 0x2009,
+	0x1172, 0x210c, 0xd1e4, 0x0130, 0xc0c5, 0x9094, 0x0030, 0x9296,
+	0x0010, 0x0140, 0xd1ec, 0x0130, 0x9094, 0x0030, 0x9296, 0x0010,
+	0x0108, 0xc0bd, 0x002e, 0x7026, 0x60c3, 0x0014, 0x00de, 0x080c,
+	0x76f5, 0x0005, 0x080c, 0x7234, 0x7003, 0x0210, 0x7007, 0x0014,
+	0x700f, 0x0100, 0x60c3, 0x0014, 0x080c, 0x76f5, 0x0005, 0x080c,
+	0x7234, 0x7003, 0x0200, 0x0804, 0x6fc7, 0x080c, 0x7234, 0x7003,
+	0x0100, 0x700b, 0x0003, 0x700f, 0x2a00, 0x60c3, 0x0008, 0x080c,
+	0x76f5, 0x0005, 0x080c, 0x7234, 0x7003, 0x0100, 0x700b, 0x000b,
+	0x60c3, 0x0008, 0x080c, 0x76f5, 0x0005, 0x0026, 0x00d6, 0x0036,
+	0x0046, 0x2019, 0x3200, 0x2021, 0x0800, 0x0040, 0x0026, 0x00d6,
+	0x0036, 0x0046, 0x2019, 0x2200, 0x2021, 0x0100, 0x080c, 0x7e9b,
+	0x7810, 0x2068, 0x6810, 0x9305, 0x7002, 0x6814, 0x7006, 0x6aa0,
+	0x2069, 0x1100, 0x6850, 0x700e, 0x9286, 0x007e, 0x1168, 0x9385,
+	0x00ff, 0x7002, 0x7007, 0xfffe, 0x2001, 0x128f, 0x2004, 0x9005,
+	0x01e8, 0x6a70, 0x720e, 0x00d0, 0x9286, 0x007f, 0x1130, 0x9385,
+	0x00ff, 0x7002, 0x7007, 0xfffd, 0x0068, 0x68cc, 0xd0ac, 0x1110,
+	0xd2bc, 0x0160, 0x9286, 0x0080, 0x1128, 0x9385, 0x00ff, 0x7002,
+	0x7007, 0xfffc, 0x686c, 0x700a, 0x6870, 0x700e, 0x9485, 0x0029,
+	0x7012, 0x004e, 0x003e, 0x00de, 0x080c, 0x76e4, 0x721a, 0x9f95,
+	0x0000, 0x7222, 0x7027, 0xffff, 0x2071, 0x024c, 0x002e, 0x0005,
+	0x0026, 0x080c, 0x7e9b, 0x7003, 0x02ff, 0x7007, 0xfffc, 0x00d6,
+	0x2069, 0x1100, 0x686c, 0x700a, 0x6870, 0x700e, 0x00de, 0x7013,
+	0x2029, 0x0c10, 0x7003, 0x0100, 0x7007, 0x0000, 0x700b, 0xfc02,
+	0x700f, 0x0000, 0x0005, 0x0026, 0x00d6, 0x0036, 0x0046, 0x2019,
+	0x3300, 0x2021, 0x0800, 0x0040, 0x0026, 0x00d6, 0x0036, 0x0046,
+	0x2019, 0x2300, 0x2021, 0x0100, 0x080c, 0x7e9b, 0x7810, 0x2068,
+	0x6810, 0x9305, 0x7002, 0x6814, 0x7006, 0x68a0, 0x2069, 0x1100,
+	0x6a50, 0x720e, 0x6acc, 0xd2ac, 0x1118, 0x9092, 0x007e, 0x02a0,
+	0x7810, 0x00c6, 0x2060, 0x6010, 0x9005, 0x1140, 0x6014, 0x9005,
+	0x1128, 0x700b, 0x00ff, 0x700f, 0xfffe, 0x0020, 0x686c, 0x700a,
+	0x6870, 0x700e, 0x00ce, 0x0000, 0x9485, 0x0098, 0x7012, 0x004e,
+	0x003e, 0x00de, 0x080c, 0x76e4, 0x721a, 0x7a08, 0x7222, 0x2f10,
+	0x7226, 0x2071, 0x024c, 0x002e, 0x0005, 0x080c, 0x76e4, 0x721a,
+	0x7a08, 0x7222, 0x7814, 0x7026, 0x2071, 0x024c, 0x002e, 0x0005,
+	0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x2069, 0x0200, 0x2071, 0x0240,
+	0x6004, 0x908a, 0x0085, 0x0a0c, 0x0cf1, 0x908a, 0x0090, 0x1a0c,
+	0x0cf1, 0x6110, 0x2178, 0x79a0, 0x2011, 0x1133, 0x2214, 0xd2ac,
+	0x1110, 0xd1bc, 0x0150, 0x7900, 0xd1f4, 0x0120, 0x7914, 0x918c,
+	0x00ff, 0x0040, 0x2009, 0x0000, 0x0028, 0x91f8, 0x26c1, 0x2f0d,
+	0x918c, 0x00ff, 0x2c78, 0x2061, 0x0100, 0x619a, 0x9082, 0x0085,
+	0x002b, 0x00fe, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x72c3, 0x72c9,
+	0x72d5, 0x72c1, 0x72c1, 0x72c1, 0x72c3, 0x72c1, 0x72c1, 0x72c1,
+	0x72c1, 0x080c, 0x0cf1, 0x00e1, 0x60c3, 0x0000, 0x080c, 0x76f5,
+	0x0005, 0x04a9, 0x7808, 0x700a, 0x7814, 0x700e, 0x7017, 0xffff,
+	0x60c3, 0x000c, 0x080c, 0x76f5, 0x0005, 0x080c, 0x731f, 0x7003,
+	0x0003, 0x7007, 0x0300, 0x60c3, 0x0004, 0x080c, 0x76f5, 0x0005,
+	0x0026, 0x080c, 0x7e9b, 0x7810, 0x2068, 0x6810, 0x9085, 0x8100,
+	0x7002, 0x6814, 0x7006, 0x68a0, 0x2069, 0x1100, 0x6acc, 0xd2ac,
+	0x1118, 0x9092, 0x007e, 0x0240, 0x686c, 0x700a, 0x6870, 0x700e,
+	0x7013, 0x0009, 0x0804, 0x7204, 0x6a50, 0x720e, 0x0cc8, 0x0026,
+	0x080c, 0x7e9b, 0x7810, 0x2068, 0x6810, 0x9085, 0x8400, 0x7002,
+	0x6814, 0x7006, 0x68a0, 0x2069, 0x1100, 0x6acc, 0xd2ac, 0x1118,
+	0x9092, 0x007e, 0x0248, 0x686c, 0x700a, 0x6870, 0x700e, 0x2001,
+	0x0099, 0x7012, 0x0804, 0x7275, 0x6a50, 0x720e, 0x0cc0, 0x0026,
+	0x080c, 0x7e9b, 0x7810, 0x2068, 0x6810, 0x9085, 0x8500, 0x7002,
+	0x6814, 0x7006, 0x68a0, 0x2069, 0x1100, 0x6acc, 0xd2ac, 0x1118,
+	0x9092, 0x007e, 0x0248, 0x686c, 0x700a, 0x6870, 0x700e, 0x2001,
+	0x0099, 0x7012, 0x0804, 0x7275, 0x6a50, 0x720e, 0x0cc0, 0x00c6,
+	0x00d6, 0x00e6, 0x00f6, 0x2c78, 0x2069, 0x0200, 0x2071, 0x0240,
+	0x7804, 0x908a, 0x0040, 0x0a0c, 0x0cf1, 0x908a, 0x0054, 0x1a0c,
+	0x0cf1, 0x7910, 0x2160, 0x61a0, 0x2011, 0x1133, 0x2214, 0xd2ac,
+	0x1110, 0xd1bc, 0x0150, 0x6100, 0xd1f4, 0x0120, 0x6114, 0x918c,
+	0x00ff, 0x0040, 0x2009, 0x0000, 0x0028, 0x91e0, 0x26c1, 0x2c0d,
+	0x918c, 0x00ff, 0x2061, 0x0100, 0x619a, 0x9082, 0x0040, 0x002b,
+	0x00fe, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x738a, 0x7448, 0x740f,
+	0x7550, 0x7388, 0x7388, 0x7388, 0x7388, 0x7388, 0x7388, 0x7388,
+	0x7a1a, 0x7a22, 0x7a2a, 0x7a32, 0x7388, 0x7de2, 0x7388, 0x7a12,
+	0x080c, 0x0cf1, 0x780b, 0xffff, 0x080c, 0x73dd, 0x7914, 0x2168,
+	0x6978, 0x7956, 0x7132, 0x697c, 0x9184, 0x000f, 0x1118, 0x2001,
+	0x0005, 0x0040, 0xd184, 0x0118, 0x2001, 0x0004, 0x0018, 0x9084,
+	0x0006, 0x8004, 0x2010, 0x785c, 0x9084, 0x00ff, 0x8007, 0x9205,
+	0x7042, 0xd1ac, 0x0128, 0x7047, 0x0002, 0x080c, 0x119d, 0x0050,
+	0xd1b4, 0x0118, 0x7047, 0x0001, 0x0028, 0x7047, 0x0000, 0x9016,
+	0x2230, 0x0010, 0x6ab0, 0x6eac, 0x726a, 0x766e, 0x20a9, 0x0008,
+	0x9d88, 0x0023, 0x20e1, 0x0001, 0x2198, 0x20e9, 0x0000, 0x20a1,
+	0x0252, 0x2069, 0x0200, 0x6813, 0x0018, 0x4003, 0x6813, 0x0008,
+	0x60c3, 0x0020, 0x6017, 0x0009, 0x2001, 0x12f8, 0x2003, 0x07d0,
+	0x2001, 0x12f7, 0x2003, 0x0009, 0x0005, 0x00d6, 0x6813, 0x0008,
+	0x7a10, 0x2268, 0x6a8c, 0x8210, 0x9294, 0x00ff, 0x6a8e, 0x8217,
+	0x721a, 0x6a10, 0x9295, 0x0600, 0x7202, 0x6a14, 0x7206, 0x68a0,
+	0x6900, 0x2069, 0x1100, 0x6bcc, 0xd3ac, 0x1138, 0xd0bc, 0x0188,
+	0xd1f4, 0x0118, 0x9294, 0x00ff, 0x629a, 0x6a6c, 0x720a, 0x6a70,
+	0x720e, 0x7013, 0x0829, 0x2f10, 0x7222, 0x7027, 0xffff, 0x00de,
+	0x0005, 0x9294, 0x00ff, 0x629a, 0x6a50, 0x720e, 0x0c90, 0x00d6,
+	0x0081, 0x7814, 0x2068, 0x6890, 0x7002, 0x688c, 0x7006, 0x68b0,
+	0x700a, 0x68ac, 0x700e, 0x60c3, 0x000c, 0x00de, 0x080c, 0x76f5,
+	0x0005, 0x00d6, 0x6813, 0x0008, 0x7810, 0x2068, 0x6810, 0x9085,
+	0x0500, 0x7002, 0x6814, 0x7006, 0x68a0, 0x2069, 0x1100, 0x6acc,
+	0xd2ac, 0x1110, 0xd0bc, 0x0188, 0x686c, 0x700a, 0x6870, 0x700e,
+	0x7013, 0x0889, 0x080c, 0x76e4, 0x721a, 0x7a08, 0x7222, 0x2f10,
+	0x7226, 0x2071, 0x024c, 0x00de, 0x0005, 0x6a50, 0x720e, 0x0c80,
+	0x00d6, 0x080c, 0x7523, 0x7814, 0x2068, 0x7814, 0x9084, 0xf000,
+	0x1130, 0x7814, 0x9084, 0x0700, 0x8007, 0x002b, 0x0010, 0x9006,
+	0x0013, 0x00de, 0x0005, 0x7465, 0x74bd, 0x74c6, 0x74de, 0x74eb,
+	0x74fd, 0x7505, 0x7463, 0x080c, 0x0cf1, 0x0016, 0x0036, 0x697c,
+	0x918c, 0x0003, 0x0118, 0x9186, 0x0003, 0x11a0, 0x6ba8, 0x7824,
+	0xd0cc, 0x1170, 0x7316, 0x6898, 0x701a, 0x6894, 0x701e, 0x003e,
+	0x001e, 0x2001, 0x12c0, 0x2004, 0x60c2, 0x080c, 0x76f5, 0x0005,
+	0xc3e5, 0x0c80, 0x9186, 0x0001, 0x190c, 0x0cf1, 0x6ba8, 0x7824,
+	0xd0cc, 0x1588, 0x7316, 0x6898, 0x701a, 0x6894, 0x701e, 0x68a4,
+	0x7026, 0x68ac, 0x702e, 0x2009, 0x0018, 0x9384, 0x0300, 0x01e8,
+	0xd3c4, 0x0110, 0x68ac, 0x9108, 0xd3cc, 0x0110, 0x68a4, 0x9108,
+	0x2011, 0x0258, 0x0156, 0x20a9, 0x000d, 0x9d80, 0x002c, 0x201c,
+	0x831f, 0x2312, 0x8000, 0x8210, 0x1f04, 0x74a7, 0x015e, 0x9184,
+	0x0003, 0x0118, 0x2019, 0x0245, 0x201a, 0x61c2, 0x003e, 0x001e,
+	0x080c, 0x76f5, 0x0005, 0xc3e5, 0x0868, 0x2011, 0x0008, 0x7824,
+	0xd0cc, 0x1110, 0x7216, 0x0400, 0x0ce8, 0xc2e5, 0x2011, 0x0302,
+	0x7824, 0xd0cc, 0x0108, 0xc2e5, 0x7216, 0x7027, 0x0012, 0x702f,
+	0x0008, 0x7043, 0x7000, 0x7047, 0x0500, 0x704f, 0x000a, 0x705b,
+	0x2500, 0x60c3, 0x0032, 0x080c, 0x76f5, 0x0005, 0x2011, 0x0028,
+	0x7824, 0xd0cc, 0x1130, 0x7216, 0x60c3, 0x0018, 0x080c, 0x76f5,
+	0x0005, 0x0cc8, 0xc2e5, 0x2011, 0x0100, 0x7824, 0xd0cc, 0x0108,
+	0xc2e5, 0x7216, 0x702f, 0x0008, 0x7858, 0x9084, 0x00ff, 0x7036,
+	0x60c3, 0x0020, 0x080c, 0x76f5, 0x0005, 0x2011, 0x0008, 0x7824,
+	0xd0cc, 0x0108, 0xc2e5, 0x7216, 0x08f8, 0x0036, 0x7b14, 0x9384,
+	0xff00, 0x7816, 0x9384, 0x00ff, 0x8001, 0x1138, 0x7824, 0xd0cc,
+	0x0108, 0xc2e5, 0x7216, 0x003e, 0x0878, 0x0046, 0x2021, 0x0800,
+	0x0006, 0x7824, 0xd0cc, 0x000e, 0x0108, 0xc4e5, 0x7416, 0x004e,
+	0x701e, 0x003e, 0x0808, 0x00d6, 0x6813, 0x0008, 0x7a10, 0x2268,
+	0x6810, 0x9085, 0x0700, 0x7002, 0x6814, 0x7006, 0x68a0, 0x2069,
+	0x1100, 0x6acc, 0xd2ac, 0x1110, 0xd0bc, 0x01a0, 0x686c, 0x700a,
+	0x6870, 0x700e, 0x7824, 0xd0cc, 0x1180, 0x7013, 0x0898, 0x080c,
+	0x76e4, 0x721a, 0x7a08, 0x7222, 0x2f10, 0x7226, 0x2071, 0x024c,
+	0x00de, 0x0005, 0x6a50, 0x720e, 0x0c68, 0x7013, 0x0889, 0x0c78,
+	0x0016, 0x7814, 0x9084, 0x0700, 0x8007, 0x0013, 0x001e, 0x0005,
+	0x7560, 0x7560, 0x7562, 0x7560, 0x7560, 0x7560, 0x757f, 0x7560,
+	0x080c, 0x0cf1, 0x7914, 0x918c, 0xf8ff, 0x918d, 0x0600, 0x7916,
+	0x2009, 0x0003, 0x00d1, 0x00d6, 0x2069, 0x1152, 0x6804, 0xd0bc,
+	0x0130, 0x682c, 0x9084, 0x00ff, 0x8007, 0x7032, 0x0010, 0x7033,
+	0x3f00, 0x00de, 0x60c3, 0x0001, 0x080c, 0x76f5, 0x0005, 0x2009,
+	0x0003, 0x0019, 0x7033, 0x7f00, 0x0ca8, 0x00d6, 0x0016, 0x080c,
+	0x7e9b, 0x001e, 0x7810, 0x2068, 0x6810, 0x9085, 0x0100, 0x7002,
+	0x6814, 0x7006, 0x68a0, 0x2069, 0x1100, 0x6acc, 0xd2ac, 0x1110,
+	0xd0bc, 0x01a0, 0x6a6c, 0x720a, 0x6a70, 0x720e, 0x7013, 0x0888,
+	0x918d, 0x0008, 0x7116, 0x080c, 0x76e4, 0x721a, 0x7a08, 0x7222,
+	0x2f10, 0x7226, 0x2071, 0x024c, 0x00de, 0x0005, 0x6a50, 0x720e,
+	0x0c68, 0x00e6, 0x00d6, 0x00c6, 0x0056, 0x0046, 0x0036, 0x2061,
+	0x0100, 0x2071, 0x1100, 0x7150, 0x7810, 0x2068, 0x68a0, 0x2028,
+	0x6910, 0x6a14, 0x76cc, 0xd6ac, 0x1130, 0xd0bc, 0x1120, 0x2019,
+	0x0000, 0x7450, 0x0010, 0x736c, 0x7470, 0x7820, 0x90be, 0x0006,
+	0x0904, 0x765a, 0x90be, 0x000a, 0x15e8, 0x9185, 0x0200, 0x6062,
+	0x6266, 0x636a, 0x646e, 0x6073, 0x2029, 0x6077, 0x0000, 0x688c,
+	0x8000, 0x9084, 0x00ff, 0x688e, 0x8007, 0x607a, 0x607f, 0x0000,
+	0x2f00, 0x6082, 0x7808, 0x6086, 0x7814, 0x2070, 0x7038, 0x608a,
+	0x7034, 0x608e, 0x7048, 0x60c6, 0x7044, 0x60ca, 0x686c, 0x60ce,
+	0x60af, 0x95d5, 0x60d7, 0x0000, 0x609f, 0x0000, 0x080c, 0x7e80,
+	0x2009, 0x07d0, 0x60c4, 0x9084, 0xfff0, 0x9005, 0x0110, 0x2009,
+	0x1b58, 0x080c, 0x65d4, 0x003e, 0x004e, 0x005e, 0x00ce, 0x00de,
+	0x00ee, 0x0005, 0x9185, 0x0100, 0x6062, 0x6266, 0x636a, 0x646e,
+	0x6073, 0x0809, 0x6077, 0x0008, 0x688c, 0x8000, 0x9084, 0x00ff,
+	0x688e, 0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6082, 0x7808,
+	0x6086, 0x7814, 0x2070, 0x7038, 0x608a, 0x7034, 0x608e, 0x7048,
+	0x60c6, 0x7044, 0x60ca, 0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7,
+	0x0000, 0x9582, 0x0080, 0x0248, 0x6a00, 0xd2f4, 0x0120, 0x6a14,
+	0x9294, 0x00ff, 0x0010, 0x2011, 0x0000, 0x629e, 0x080c, 0x7e80,
+	0x2009, 0x07d0, 0x60c4, 0x9084, 0xfff0, 0x9005, 0x0110, 0x2009,
+	0x1b58, 0x080c, 0x65d4, 0x003e, 0x004e, 0x005e, 0x00ce, 0x00de,
+	0x00ee, 0x0005, 0x7814, 0x2070, 0x707c, 0x9084, 0x0003, 0x9086,
+	0x0002, 0x05f0, 0x9185, 0x0100, 0x6062, 0x6266, 0x636a, 0x646e,
+	0x6073, 0x0880, 0x6077, 0x0008, 0x688c, 0x8000, 0x9084, 0x00ff,
+	0x688e, 0x8007, 0x607a, 0x7838, 0x607e, 0x2f00, 0x6086, 0x7808,
+	0x6082, 0x7090, 0x608a, 0x708c, 0x608e, 0x70b0, 0x60c6, 0x70ac,
+	0x60ca, 0x70ac, 0x7930, 0x9108, 0x7932, 0x70b0, 0x792c, 0x9109,
+	0x792e, 0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000, 0x9582,
+	0x0080, 0x0248, 0x6a00, 0xd2f4, 0x0120, 0x6a14, 0x9294, 0x00ff,
+	0x0010, 0x2011, 0x0000, 0x629e, 0x080c, 0x7e5b, 0x0804, 0x7648,
+	0x9185, 0x0700, 0x6062, 0x6266, 0x636a, 0x646e, 0x7824, 0xd0cc,
+	0x7826, 0x0118, 0x6073, 0x0889, 0x0010, 0x6073, 0x0898, 0x6077,
+	0x0000, 0x688c, 0x8000, 0x9084, 0x00ff, 0x688e, 0x8007, 0x607a,
+	0x607f, 0x0000, 0x2f00, 0x6086, 0x7808, 0x6082, 0x7038, 0x608a,
+	0x7034, 0x608e, 0x7048, 0x60c6, 0x7044, 0x60ca, 0x686c, 0x60ce,
+	0x60af, 0x95d5, 0x60d7, 0x0000, 0x9582, 0x0080, 0x0248, 0x6a00,
+	0xd2f4, 0x0120, 0x6a14, 0x9294, 0x00ff, 0x0010, 0x2011, 0x0000,
+	0x629e, 0x7824, 0xd0cc, 0x0120, 0x080c, 0x7e80, 0x0804, 0x7648,
+	0x080c, 0x7e5b, 0x0804, 0x7648, 0x7a10, 0x9280, 0x0023, 0x2014,
+	0x8210, 0x9294, 0x00ff, 0x2202, 0x8217, 0x0005, 0x00d6, 0x2069,
+	0x12dc, 0x6843, 0x0001, 0x00de, 0x0005, 0x60a3, 0x0056, 0x60a7,
+	0x9575, 0x00f1, 0x080c, 0x65c6, 0x0005, 0x0016, 0x2001, 0x110c,
+	0x200c, 0x9184, 0x0600, 0x9086, 0x0600, 0x0128, 0x0089, 0x080c,
+	0x65c6, 0x001e, 0x0005, 0xc1e5, 0x2001, 0x110c, 0x2102, 0x2001,
+	0x12dd, 0x2003, 0x0000, 0x2001, 0x12e5, 0x2003, 0x0000, 0x0c88,
+	0x0006, 0x6014, 0x9084, 0x1804, 0x9085, 0x0009, 0x6016, 0x000e,
+	0x0005, 0x0006, 0x00c6, 0x2061, 0x0100, 0x6014, 0x9084, 0x1804,
+	0x9085, 0x0008, 0x6016, 0x00ce, 0x000e, 0x0005, 0x00c6, 0x00d6,
+	0x0016, 0x0026, 0x2061, 0x0100, 0x2069, 0x0140, 0x080c, 0x5745,
+	0x1198, 0x2001, 0x12f8, 0x2004, 0x9005, 0x15b8, 0x0066, 0x2031,
+	0x0001, 0x080c, 0x57d6, 0x006e, 0x1118, 0x080c, 0x65c6, 0x0468,
+	0x00c6, 0x2061, 0x12dc, 0x00d8, 0x6904, 0x9194, 0x4000, 0x0550,
+	0x0881, 0x6803, 0x1000, 0x6803, 0x0000, 0x00c6, 0x2061, 0x12dc,
+	0x6128, 0x9192, 0x00c8, 0x1258, 0x8108, 0x612a, 0x6124, 0x00ce,
+	0x81ff, 0x0198, 0x080c, 0x65c6, 0x080c, 0x7718, 0x0070, 0x6124,
+	0x91e5, 0x0000, 0x0140, 0x080c, 0xae07, 0x2009, 0x0014, 0x080c,
+	0x7f4e, 0x080c, 0x65cf, 0x00ce, 0x0000, 0x002e, 0x001e, 0x00de,
+	0x00ce, 0x0005, 0x2001, 0x12f8, 0x2004, 0x9005, 0x1db0, 0x00c6,
+	0x2061, 0x12dc, 0x6128, 0x9192, 0x0003, 0x1e08, 0x8108, 0x612a,
+	0x00ce, 0x080c, 0x65c6, 0x080c, 0x45d6, 0x0c38, 0x00c6, 0x00d6,
+	0x00e6, 0x0016, 0x0026, 0x080c, 0x65dc, 0x2071, 0x12dc, 0x713c,
+	0x81ff, 0x0590, 0x2061, 0x0100, 0x2069, 0x0140, 0x080c, 0x5745,
+	0x11a8, 0x0036, 0x2019, 0x0002, 0x080c, 0x7936, 0x003e, 0x713c,
+	0x2160, 0x080c, 0xae07, 0x2009, 0x004a, 0x080c, 0x7f4e, 0x0066,
+	0x2031, 0x0001, 0x080c, 0x57d6, 0x006e, 0x00b0, 0x6904, 0x9194,
+	0x4000, 0x01c0, 0x6803, 0x1000, 0x6803, 0x0000, 0x0036, 0x2019,
+	0x0001, 0x080c, 0x7936, 0x003e, 0x713c, 0x2160, 0x080c, 0xae07,
+	0x2009, 0x004a, 0x080c, 0x7f4e, 0x002e, 0x001e, 0x00ee, 0x00de,
+	0x00ce, 0x0005, 0x0c58, 0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0056,
+	0x0046, 0x0006, 0x0126, 0x2091, 0x8000, 0x6010, 0x2068, 0x6ca0,
+	0x2071, 0x12dc, 0x7018, 0x2068, 0x8dff, 0x0198, 0x68a0, 0x9406,
+	0x0118, 0x6854, 0x2068, 0x0cc0, 0x6014, 0x2060, 0x646c, 0x6570,
+	0x6678, 0x2d60, 0x080c, 0x4c75, 0x0120, 0x080c, 0x7a3e, 0x9085,
+	0x0001, 0x012e, 0x000e, 0x004e, 0x005e, 0x006e, 0x00ce, 0x00de,
+	0x00ee, 0x0005, 0x080c, 0x71be, 0x7003, 0x1200, 0x7820, 0x9086,
+	0x0004, 0x1110, 0x6098, 0x0018, 0x2001, 0x1114, 0x2004, 0x700e,
+	0x7838, 0x7012, 0x783c, 0x7016, 0x60c3, 0x002c, 0x080c, 0x76f5,
+	0x0005, 0x080c, 0x71be, 0x7003, 0x0f00, 0x7808, 0x700e, 0x60c3,
+	0x0008, 0x080c, 0x76f5, 0x0005, 0x0156, 0x080c, 0x7234, 0x7003,
+	0x0200, 0x2011, 0x1148, 0x63f0, 0x2312, 0x20a9, 0x0006, 0x2011,
+	0x1140, 0x2019, 0x1141, 0x9ef0, 0x0002, 0x2376, 0x8e70, 0x2276,
+	0x8e70, 0x9398, 0x0002, 0x9290, 0x0002, 0x1f04, 0x7835, 0x60c3,
+	0x001c, 0x080c, 0x76f5, 0x015e, 0x0005, 0x0016, 0x0026, 0x080c,
+	0x7210, 0x080c, 0x7222, 0x9e80, 0x0004, 0x20e9, 0x0000, 0x20a0,
+	0x7814, 0x9080, 0x0000, 0x2004, 0x9080, 0x0021, 0x20e1, 0x0001,
+	0x2098, 0x7808, 0x9088, 0x0002, 0x21a8, 0x4003, 0x9080, 0x0004,
+	0x8003, 0x60c2, 0x080c, 0x76f5, 0x002e, 0x001e, 0x0005, 0x080c,
+	0x71be, 0x7003, 0x6200, 0x7808, 0x700e, 0x60c3, 0x0008, 0x080c,
+	0x76f5, 0x0005, 0x0016, 0x0026, 0x080c, 0x71be, 0x20e9, 0x0000,
+	0x20a1, 0x024c, 0x7814, 0x9080, 0x0000, 0x2004, 0x9080, 0x0023,
+	0x20e1, 0x0001, 0x2098, 0x7808, 0x9088, 0x0002, 0x21a8, 0x4003,
+	0x8003, 0x60c2, 0x080c, 0x76f5, 0x002e, 0x001e, 0x0005, 0x00e6,
+	0x00c6, 0x0006, 0x0126, 0x2091, 0x8000, 0x2071, 0x12dc, 0x700c,
+	0x2060, 0x8cff, 0x0178, 0x080c, 0x97cd, 0x1110, 0x080c, 0x8576,
+	0x600c, 0x0006, 0x080c, 0x99c4, 0x080c, 0x7f1e, 0x080c, 0x7a3e,
+	0x00ce, 0x0c78, 0x700f, 0x0000, 0x700b, 0x0000, 0x012e, 0x000e,
+	0x00ce, 0x00ee, 0x0005, 0x0126, 0x0156, 0x00f6, 0x00e6, 0x00d6,
+	0x00c6, 0x0026, 0x0016, 0x0006, 0x2091, 0x8000, 0x2069, 0x0100,
+	0x2079, 0x0140, 0x2071, 0x12dc, 0x7024, 0x2060, 0x8cff, 0x05a0,
+	0x080c, 0x7721, 0x68c3, 0x0000, 0x080c, 0x65cf, 0x2009, 0x0013,
+	0x080c, 0x7f4e, 0x20a9, 0x01f4, 0x6824, 0xd094, 0x0158, 0x6827,
+	0x0004, 0x7804, 0x9084, 0x4000, 0x01a0, 0x7803, 0x1000, 0x7803,
+	0x0000, 0x0078, 0xd084, 0x0118, 0x6827, 0x0001, 0x0010, 0x1f04,
+	0x78d4, 0x7804, 0x9084, 0x1000, 0x0120, 0x7803, 0x0100, 0x7803,
+	0x0000, 0x6824, 0x000e, 0x001e, 0x002e, 0x00ce, 0x00de, 0x00ee,
+	0x00fe, 0x015e, 0x012e, 0x0005, 0x2001, 0x1100, 0x2004, 0x9096,
+	0x0001, 0x0550, 0x9096, 0x0004, 0x0538, 0x6817, 0x0008, 0x68c3,
+	0x0000, 0x2011, 0x4586, 0x080c, 0x655b, 0x20a9, 0x01f4, 0x6824,
+	0xd094, 0x0158, 0x6827, 0x0004, 0x7804, 0x9084, 0x4000, 0x01a0,
+	0x7803, 0x1000, 0x7803, 0x0000, 0x0078, 0xd084, 0x0118, 0x6827,
+	0x0001, 0x0010, 0x1f04, 0x790f, 0x7804, 0x9084, 0x1000, 0x0120,
+	0x7803, 0x0100, 0x7803, 0x0000, 0x000e, 0x001e, 0x002e, 0x00ce,
+	0x00de, 0x00ee, 0x00fe, 0x015e, 0x012e, 0x0005, 0x0126, 0x0156,
+	0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0026, 0x0016, 0x0006, 0x2091,
+	0x8000, 0x2069, 0x0100, 0x2079, 0x0140, 0x2071, 0x12dc, 0x703c,
+	0x2060, 0x8cff, 0x0904, 0x79b8, 0x6814, 0x9084, 0x0002, 0x0904,
+	0x79b8, 0x68af, 0x95f5, 0x6817, 0x0010, 0x2009, 0x00fa, 0x8109,
+	0x1df0, 0x68c7, 0x0000, 0x68cb, 0x0008, 0x080c, 0x65dc, 0x080c,
+	0x1605, 0x0046, 0x2009, 0x017f, 0x200b, 0x00a5, 0x2021, 0x0169,
+	0x2404, 0x9084, 0x000f, 0x9086, 0x0004, 0x1500, 0x68af, 0x95f5,
+	0x68c7, 0x0000, 0x68cb, 0x0008, 0x00e6, 0x00f6, 0x2079, 0x0090,
+	0x2071, 0x131f, 0x6814, 0x9084, 0x1984, 0x9085, 0x0012, 0x6816,
+	0x782b, 0x0008, 0x7003, 0x0000, 0x00fe, 0x00ee, 0x9386, 0x0002,
+	0x1128, 0x7884, 0x9005, 0x1110, 0x7887, 0x0001, 0x200b, 0x0000,
+	0x004e, 0x939d, 0x0000, 0x1120, 0x2009, 0x0049, 0x080c, 0x7f4e,
+	0x20a9, 0x03e8, 0x6824, 0xd094, 0x0158, 0x6827, 0x0004, 0x7804,
+	0x9084, 0x4000, 0x01a0, 0x7803, 0x1000, 0x7803, 0x0000, 0x0078,
+	0xd08c, 0x0118, 0x6827, 0x0002, 0x0010, 0x1f04, 0x799a, 0x7804,
+	0x9084, 0x1000, 0x0120, 0x7803, 0x0100, 0x7803, 0x0000, 0x6824,
+	0x000e, 0x001e, 0x002e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x015e,
+	0x012e, 0x0005, 0x00d6, 0x0126, 0x2091, 0x8000, 0x2069, 0x12dc,
+	0x6a06, 0x012e, 0x00de, 0x0005, 0x00d6, 0x0126, 0x2091, 0x8000,
+	0x2069, 0x12dc, 0x6a32, 0x012e, 0x00de, 0x0005, 0x00f6, 0x00e6,
+	0x00c6, 0x0066, 0x0006, 0x0126, 0x2071, 0x12dc, 0x7614, 0x2660,
+	0x2678, 0x2091, 0x8000, 0x8cff, 0x0530, 0x6020, 0x9206, 0x11f8,
+	0x7014, 0x9c36, 0x1110, 0x660c, 0x7616, 0x7010, 0x9c36, 0x1140,
+	0x2c00, 0x9f36, 0x0118, 0x2f00, 0x7012, 0x0010, 0x7013, 0x0000,
+	0x660c, 0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008, 0x2678,
+	0x600f, 0x0000, 0x080c, 0x97a3, 0x04c9, 0x00ce, 0x08e0, 0x2c78,
+	0x600c, 0x2060, 0x08c0, 0x012e, 0x000e, 0x006e, 0x00ce, 0x00ee,
+	0x00fe, 0x0005, 0x080c, 0x73dd, 0x7814, 0x7032, 0x7042, 0x7047,
+	0x1000, 0x00f8, 0x080c, 0x73dd, 0x7814, 0x7032, 0x7042, 0x7047,
+	0x4000, 0x00b8, 0x080c, 0x73dd, 0x7814, 0x7032, 0x7042, 0x7047,
+	0x2000, 0x0078, 0x080c, 0x73dd, 0x7814, 0x7032, 0x7042, 0x7047,
+	0x0400, 0x0038, 0x080c, 0x73dd, 0x7814, 0x7032, 0x7042, 0x7047,
+	0x0200, 0x60c3, 0x0020, 0x080c, 0x76f5, 0x0005, 0x00e6, 0x2071,
+	0x12dc, 0x7020, 0x9005, 0x0110, 0x8001, 0x7022, 0x00ee, 0x0005,
+	0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0076, 0x0066, 0x0006, 0x0126,
+	0x2091, 0x8000, 0x2071, 0x12dc, 0x7614, 0x2660, 0x2678, 0x2039,
+	0x0001, 0x87ff, 0x0904, 0x7ad2, 0x8cff, 0x0904, 0x7ad2, 0x6020,
+	0x9086, 0x0006, 0x1904, 0x7acd, 0x88ff, 0x0138, 0x2800, 0x9c06,
+	0x1904, 0x7acd, 0x2039, 0x0000, 0x0050, 0x6010, 0x9206, 0x1904,
+	0x7acd, 0x85ff, 0x0120, 0x6054, 0x9106, 0x1904, 0x7acd, 0x7024,
+	0x9c06, 0x1538, 0x2069, 0x0100, 0x68c0, 0x9005, 0x01f0, 0x080c,
+	0x65cf, 0x6817, 0x0008, 0x68c3, 0x0000, 0x080c, 0x7b56, 0x7027,
+	0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0120,
+	0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084,
+	0x0110, 0x6827, 0x0001, 0x003e, 0x0020, 0x6003, 0x0009, 0x630a,
+	0x0460, 0x7014, 0x9c36, 0x1110, 0x660c, 0x7616, 0x7010, 0x9c36,
+	0x1140, 0x2c00, 0x9f36, 0x0118, 0x2f00, 0x7012, 0x0010, 0x7013,
+	0x0000, 0x660c, 0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008,
+	0x2678, 0x89ff, 0x1158, 0x600f, 0x0000, 0x6014, 0x2068, 0x080c,
+	0x95d2, 0x0110, 0x080c, 0xaa84, 0x080c, 0x97a3, 0x080c, 0x7a3e,
+	0x88ff, 0x1190, 0x00ce, 0x0804, 0x7a59, 0x2c78, 0x600c, 0x2060,
+	0x0804, 0x7a59, 0x9006, 0x012e, 0x000e, 0x006e, 0x007e, 0x00ce,
+	0x00de, 0x00ee, 0x00fe, 0x0005, 0x601b, 0x0000, 0x00ce, 0x98c5,
+	0x0001, 0x0c88, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0026,
+	0x0006, 0x0126, 0x2091, 0x8000, 0x2071, 0x12dc, 0x7638, 0x2660,
+	0x2678, 0x8cff, 0x0904, 0x7b46, 0x6020, 0x9086, 0x0006, 0x1904,
+	0x7b41, 0x87ff, 0x0128, 0x2700, 0x9c06, 0x1904, 0x7b41, 0x0040,
+	0x6010, 0x9206, 0x15f0, 0x85ff, 0x0118, 0x6054, 0x9106, 0x15c8,
+	0x703c, 0x9c06, 0x1170, 0x0036, 0x2019, 0x0001, 0x080c, 0x7936,
+	0x7033, 0x0000, 0x703f, 0x0000, 0x7043, 0x0000, 0x7047, 0x0000,
+	0x003e, 0x7038, 0x9c36, 0x1110, 0x660c, 0x763a, 0x7034, 0x9c36,
+	0x1140, 0x2c00, 0x9f36, 0x0118, 0x2f00, 0x7036, 0x0010, 0x7037,
+	0x0000, 0x660c, 0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008,
+	0x2678, 0x600f, 0x0000, 0x6014, 0x2068, 0x080c, 0x95d2, 0x0110,
+	0x080c, 0xaa84, 0x080c, 0x97a3, 0x87ff, 0x1190, 0x00ce, 0x0804,
+	0x7af1, 0x2c78, 0x600c, 0x2060, 0x0804, 0x7af1, 0x9006, 0x012e,
+	0x000e, 0x002e, 0x006e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005,
+	0x601b, 0x0000, 0x00ce, 0x97bd, 0x0001, 0x0c88, 0x00e6, 0x2071,
+	0x12dc, 0x2001, 0x1100, 0x2004, 0x9086, 0x0002, 0x1118, 0x7007,
+	0x0005, 0x0010, 0x7007, 0x0000, 0x00ee, 0x0005, 0x00f6, 0x00e6,
+	0x00c6, 0x0066, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000, 0x2071,
+	0x12dc, 0x2c10, 0x7638, 0x2660, 0x2678, 0x8cff, 0x0518, 0x2200,
+	0x9c06, 0x11e0, 0x7038, 0x9c36, 0x1110, 0x660c, 0x763a, 0x7034,
+	0x9c36, 0x1140, 0x2c00, 0x9f36, 0x0118, 0x2f00, 0x7036, 0x0010,
+	0x7037, 0x0000, 0x660c, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008,
+	0x2678, 0x600f, 0x0000, 0x9085, 0x0001, 0x0020, 0x2c78, 0x600c,
+	0x2060, 0x08d8, 0x012e, 0x000e, 0x002e, 0x006e, 0x00ce, 0x00ee,
+	0x00fe, 0x0005, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0006,
+	0x0126, 0x2091, 0x8000, 0x2071, 0x12dc, 0x760c, 0x2660, 0x2678,
+	0x8cff, 0x0904, 0x7c2c, 0x6010, 0x9080, 0x0028, 0x2004, 0x9206,
+	0x1904, 0x7c27, 0x7024, 0x9c06, 0x1508, 0x2069, 0x0100, 0x68c0,
+	0x9005, 0x0904, 0x7c03, 0x080c, 0x7721, 0x68c3, 0x0000, 0x080c,
+	0x7b56, 0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384,
+	0x1000, 0x0120, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100,
+	0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x700c, 0x9c36,
+	0x1110, 0x660c, 0x760e, 0x7008, 0x9c36, 0x1140, 0x2c00, 0x9f36,
+	0x0118, 0x2f00, 0x700a, 0x0010, 0x700b, 0x0000, 0x660c, 0x0066,
+	0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000,
+	0x080c, 0x97bc, 0x1158, 0x080c, 0x25d1, 0x080c, 0x97cd, 0x11f0,
+	0x080c, 0x8576, 0x00d8, 0x080c, 0x7b56, 0x08c0, 0x080c, 0x97cd,
+	0x1118, 0x080c, 0x8576, 0x0090, 0x6014, 0x2068, 0x080c, 0x95d2,
+	0x0168, 0x6020, 0x9086, 0x0003, 0x11f8, 0x6867, 0x0103, 0x6b7a,
+	0x6877, 0x0000, 0x080c, 0x50a5, 0x080c, 0x9797, 0x080c, 0x99c4,
+	0x080c, 0x97a3, 0x080c, 0x7a3e, 0x00ce, 0x0804, 0x7bb0, 0x2c78,
+	0x600c, 0x2060, 0x0804, 0x7bb0, 0x012e, 0x000e, 0x006e, 0x00ce,
+	0x00de, 0x00ee, 0x00fe, 0x0005, 0x6020, 0x9086, 0x0006, 0x1d30,
+	0x080c, 0xaa84, 0x0c18, 0x00d6, 0x080c, 0x7234, 0x7003, 0x0200,
+	0x7007, 0x0014, 0x60c3, 0x0014, 0x20e1, 0x0001, 0x2099, 0x12a9,
+	0x20e9, 0x0000, 0x20a1, 0x0250, 0x20a9, 0x0004, 0x4003, 0x7023,
+	0x0004, 0x7027, 0x7878, 0x080c, 0x76f5, 0x00de, 0x0005, 0x080c,
+	0x7234, 0x7003, 0x0214, 0x7007, 0x0018, 0x700b, 0x0800, 0x7814,
+	0x9084, 0xff00, 0x700e, 0x7814, 0x9084, 0x00ff, 0x7022, 0x782c,
+	0x7026, 0x60c3, 0x0018, 0x080c, 0x76f5, 0x0005, 0x00d6, 0x0016,
+	0x00d6, 0x2f68, 0x2009, 0x0035, 0x080c, 0x9ac5, 0x00de, 0x1904,
+	0x7cd4, 0x080c, 0x71be, 0x7003, 0x1300, 0x782c, 0x2068, 0x6820,
+	0x9086, 0x0003, 0x0570, 0x7810, 0x9080, 0x0028, 0x2014, 0x2001,
+	0x1133, 0x2004, 0xd0ac, 0x11d0, 0x9286, 0x007e, 0x1128, 0x700b,
+	0x00ff, 0x700f, 0xfffe, 0x04a8, 0x9286, 0x007f, 0x1128, 0x700b,
+	0x00ff, 0x700f, 0xfffd, 0x0468, 0xd2bc, 0x0180, 0x9286, 0x0080,
+	0x1128, 0x700b, 0x00ff, 0x700f, 0xfffc, 0x0418, 0x92e8, 0x1000,
+	0x2d6c, 0x6810, 0x700a, 0x6814, 0x700e, 0x00d8, 0x6098, 0x700e,
+	0x00c0, 0x2001, 0x1133, 0x2004, 0xd0ac, 0x1138, 0x7810, 0x9080,
+	0x0028, 0x2004, 0x9082, 0x007e, 0x0250, 0x00d6, 0x2069, 0x111b,
+	0x2d04, 0x700a, 0x8d68, 0x2d04, 0x700e, 0x00de, 0x0010, 0x6034,
+	0x700e, 0x7838, 0x7012, 0x783c, 0x7016, 0x60c3, 0x000c, 0x001e,
+	0x00de, 0x080c, 0x76f5, 0x0005, 0x781b, 0x0001, 0x7803, 0x0006,
+	0x001e, 0x00de, 0x0005, 0x792c, 0x9180, 0x0008, 0x200c, 0x9186,
+	0x0006, 0x01b0, 0x9186, 0x0003, 0x0904, 0x7d4b, 0x9186, 0x0005,
+	0x0904, 0x7d34, 0x9186, 0x0004, 0x05c8, 0x9186, 0x0008, 0x0904,
+	0x7d3c, 0x7807, 0x0037, 0x7817, 0x1700, 0x080c, 0x7db2, 0x0005,
+	0x080c, 0x7d71, 0x00d6, 0x0026, 0x792c, 0x2168, 0x2009, 0x4000,
+	0x6800, 0x0002, 0x7d15, 0x7d20, 0x7d17, 0x7d20, 0x7d1c, 0x7d15,
+	0x7d15, 0x7d20, 0x7d20, 0x7d20, 0x7d20, 0x7d15, 0x7d15, 0x7d15,
+	0x7d15, 0x7d15, 0x7d20, 0x7d15, 0x7d20, 0x080c, 0x0cf1, 0x6824,
+	0xd0e4, 0x0110, 0xd0cc, 0x0110, 0x900e, 0x0010, 0x2009, 0x2000,
+	0x682c, 0x7022, 0x6830, 0x7026, 0x0804, 0x7d69, 0x080c, 0x7d71,
+	0x00d6, 0x0026, 0x792c, 0x2168, 0x2009, 0x4000, 0x6a00, 0x9286,
+	0x0002, 0x1108, 0x900e, 0x04a8, 0x04e1, 0x00d6, 0x0026, 0x792c,
+	0x2168, 0x2009, 0x4000, 0x0468, 0x04a1, 0x00d6, 0x0026, 0x792c,
+	0x2168, 0x2009, 0x4000, 0x9286, 0x0005, 0x0118, 0x9286, 0x0002,
+	0x1108, 0x900e, 0x00f0, 0x0429, 0x00d6, 0x0026, 0x792c, 0x2168,
+	0x6814, 0x2068, 0x69ac, 0x6834, 0x9112, 0x69b0, 0x6838, 0x9103,
+	0x7022, 0x7226, 0x792c, 0x9180, 0x0000, 0x2004, 0x908e, 0x0002,
+	0x0130, 0x908e, 0x0004, 0x0118, 0x2009, 0x4000, 0x0010, 0x2009,
+	0x0000, 0x712a, 0x60c3, 0x0018, 0x002e, 0x00de, 0x080c, 0x76f5,
+	0x0005, 0x0036, 0x0046, 0x0056, 0x0066, 0x080c, 0x7234, 0x9006,
+	0x7003, 0x0200, 0x7938, 0x710a, 0x793c, 0x710e, 0x7810, 0x9080,
+	0x0028, 0x2004, 0x2011, 0x1133, 0x2214, 0xd2ac, 0x1118, 0x9092,
+	0x007e, 0x0268, 0x00d6, 0x2069, 0x111b, 0x2d2c, 0x8d68, 0x2d34,
+	0x90e8, 0x1000, 0x2d6c, 0x6b10, 0x6c14, 0x00de, 0x0030, 0x2019,
+	0x0000, 0x6498, 0x2029, 0x0000, 0x6634, 0x782c, 0x9080, 0x0008,
+	0x2004, 0x9086, 0x0003, 0x1128, 0x7512, 0x7616, 0x731a, 0x741e,
+	0x0020, 0x7312, 0x7416, 0x751a, 0x761e, 0x006e, 0x005e, 0x004e,
+	0x003e, 0x0005, 0x080c, 0x7234, 0x7003, 0x0100, 0x700b, 0x0009,
+	0x7814, 0x700e, 0x60c3, 0x0008, 0x080c, 0x76f5, 0x0005, 0x080c,
+	0x71b5, 0x7003, 0x1400, 0x7838, 0x700a, 0x783c, 0x700e, 0x782c,
+	0x7012, 0x7830, 0x7016, 0x7834, 0x9084, 0x00ff, 0x8007, 0x701a,
+	0x60c3, 0x0010, 0x080c, 0x76f5, 0x0005, 0x080c, 0x722b, 0x7003,
+	0x0100, 0x782c, 0x700a, 0x7814, 0x700e, 0x60c3, 0x0008, 0x080c,
+	0x76f5, 0x0005, 0x0029, 0x60c3, 0x0000, 0x080c, 0x76f5, 0x0005,
+	0x00d6, 0x080c, 0x7e9b, 0x7810, 0x2068, 0x6810, 0x9085, 0x0300,
+	0x7002, 0x6814, 0x7006, 0x68a0, 0x2069, 0x1100, 0x6acc, 0xd2ac,
+	0x1110, 0xd0bc, 0x0188, 0x686c, 0x700a, 0x6870, 0x700e, 0x7013,
+	0x0819, 0x080c, 0x76e4, 0x721a, 0x2f10, 0x7222, 0x7a08, 0x7226,
+	0x2071, 0x024c, 0x00de, 0x0005, 0x6234, 0x720e, 0x0c80, 0x0059,
+	0x7914, 0x712a, 0x60c3, 0x0000, 0x60a7, 0x9575, 0x080c, 0x7718,
+	0x080c, 0x65c6, 0x0005, 0x0036, 0x00d6, 0x00e6, 0x7858, 0x2068,
+	0x9df0, 0x001b, 0x7210, 0x9296, 0x00c0, 0x9294, 0xfffd, 0x7212,
+	0x7214, 0x9294, 0x0300, 0x7216, 0x7100, 0x9194, 0x00ff, 0x7308,
+	0x9384, 0x00ff, 0x908d, 0xc200, 0x7102, 0x9384, 0xff00, 0x9215,
+	0x720a, 0x7004, 0x720c, 0x700e, 0x7206, 0x00d6, 0x2069, 0x0200,
+	0x080c, 0x7e9b, 0x00de, 0x20e9, 0x0000, 0x20a1, 0x0240, 0x20a9,
+	0x000a, 0x20e1, 0x0001, 0x2e98, 0x4003, 0x60a3, 0x0035, 0x6a68,
+	0x9294, 0x7000, 0x9286, 0x3000, 0x0110, 0x60a3, 0x0037, 0x00ee,
+	0x00de, 0x003e, 0x0005, 0x900e, 0x7814, 0x9080, 0x001f, 0x2004,
+	0xd0fc, 0x01d8, 0x9084, 0x0003, 0x11c0, 0x2001, 0x110c, 0x2004,
+	0xd0bc, 0x0198, 0x7824, 0xd0cc, 0x1180, 0xd0c4, 0x1170, 0x7814,
+	0x9080, 0x002a, 0x2004, 0x9005, 0x1140, 0x2001, 0x110c, 0x200c,
+	0xc1d5, 0x2102, 0x2009, 0x12c1, 0x210c, 0x918d, 0x0092, 0x0010,
+	0x2009, 0x0096, 0x60ab, 0x0036, 0x6116, 0x0005, 0x2009, 0x0009,
+	0x00a0, 0x2009, 0x000a, 0x0088, 0x2009, 0x000b, 0x0070, 0x2009,
+	0x000c, 0x0058, 0x2009, 0x000d, 0x0040, 0x2009, 0x000e, 0x0028,
+	0x2009, 0x000f, 0x0010, 0x2009, 0x0008, 0x6912, 0x0005, 0x00d6,
+	0x9290, 0x0018, 0x8214, 0x20e9, 0x0000, 0x2069, 0x0200, 0x6813,
+	0x0000, 0x22a8, 0x9284, 0x00e0, 0x0128, 0x20a9, 0x0020, 0x9292,
+	0x0020, 0x0008, 0x9016, 0x20a1, 0x0240, 0x9006, 0x4004, 0x82ff,
+	0x0120, 0x6810, 0x8000, 0x6812, 0x0c60, 0x00de, 0x0005, 0x2061,
+	0x15c0, 0x2071, 0x1100, 0x7064, 0x7046, 0x704b, 0x15c0, 0x0005,
+	0x00e6, 0x0126, 0x2071, 0x1100, 0x2091, 0x8000, 0x7544, 0x9582,
+	0x0010, 0x0608, 0x7048, 0x2060, 0x6000, 0x9086, 0x0000, 0x0148,
+	0x9ce0, 0x0018, 0x7058, 0x9c02, 0x1208, 0x0cb0, 0x2061, 0x15c0,
+	0x0c98, 0x6003, 0x0008, 0x8529, 0x7546, 0x9ca8, 0x0018, 0x7058,
+	0x9502, 0x1230, 0x754a, 0x9085, 0x0001, 0x012e, 0x00ee, 0x0005,
+	0x704b, 0x15c0, 0x0cc0, 0x9006, 0x0cc0, 0x00e6, 0x2071, 0x1100,
+	0x7544, 0x9582, 0x0010, 0x0600, 0x7048, 0x2060, 0x6000, 0x9086,
+	0x0000, 0x0148, 0x9ce0, 0x0018, 0x7058, 0x9c02, 0x1208, 0x0cb0,
+	0x2061, 0x15c0, 0x0c98, 0x6003, 0x0008, 0x8529, 0x7546, 0x9ca8,
+	0x0018, 0x7058, 0x9502, 0x1228, 0x754a, 0x9085, 0x0001, 0x00ee,
+	0x0005, 0x704b, 0x15c0, 0x0cc8, 0x9006, 0x0cc8, 0x9c82, 0x15c0,
+	0x0a0c, 0x0cf1, 0x2001, 0x1116, 0x2004, 0x9c02, 0x1a0c, 0x0cf1,
+	0x9006, 0x6006, 0x600a, 0x600e, 0x6016, 0x601a, 0x6012, 0x6023,
+	0x0000, 0x6003, 0x0000, 0x601e, 0x6056, 0x605a, 0x6026, 0x602a,
+	0x602e, 0x6032, 0x6036, 0x603a, 0x603e, 0x6042, 0x2061, 0x1100,
+	0x6044, 0x8000, 0x6046, 0x9086, 0x0001, 0x0108, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x6d42, 0x012e, 0x0cc0, 0x6020, 0x9084,
+	0x000f, 0x0002, 0x7f60, 0x7f70, 0x7f8b, 0x7fa6, 0x9af2, 0x9b0d,
+	0x9b28, 0x7f60, 0x7f70, 0x7f60, 0x7fc2, 0x7f60, 0x7f60, 0x7f60,
+	0x9186, 0x0013, 0x1128, 0x080c, 0x6c56, 0x080c, 0x6d42, 0x0005,
+	0x9186, 0x0047, 0x1120, 0x9016, 0x080c, 0x119a, 0x0000, 0x0005,
+	0x0066, 0x6000, 0x90b2, 0x0016, 0x1a0c, 0x0cf1, 0x0013, 0x006e,
+	0x0005, 0x7f89, 0x8406, 0x85b0, 0x7f89, 0x862d, 0x8072, 0x7f89,
+	0x7f89, 0x8392, 0x8a82, 0x7f89, 0x7f89, 0x7f89, 0x7f89, 0x7f89,
+	0x7f89, 0x080c, 0x0cf1, 0x0066, 0x6000, 0x90b2, 0x0016, 0x1a0c,
+	0x0cf1, 0x0013, 0x006e, 0x0005, 0x7fa4, 0x9085, 0x7fa4, 0x7fa4,
+	0x7fa4, 0x7fa4, 0x7fa4, 0x7fa4, 0x902d, 0x91f5, 0x7fa4, 0x90b6,
+	0x9131, 0x90b6, 0x9131, 0x7fa4, 0x080c, 0x0cf1, 0x6000, 0x9082,
+	0x0016, 0x1a0c, 0x0cf1, 0x6000, 0x0002, 0x7fc0, 0x8ac3, 0x8b8c,
+	0x8caa, 0x8e09, 0x7fc0, 0x7fc0, 0x7fc0, 0x8a9d, 0x8fdd, 0x8fe0,
+	0x7fc0, 0x7fc0, 0x7fc0, 0x7fc0, 0x900a, 0x7fc0, 0x7fc0, 0x7fc0,
+	0x080c, 0x0cf1, 0x0066, 0x6000, 0x90b2, 0x0016, 0x1a0c, 0x0cf1,
+	0x0013, 0x006e, 0x0005, 0x7fdb, 0x7fdb, 0x7fdb, 0x7ffe, 0x8051,
+	0x7fdb, 0x7fdb, 0x7fdb, 0x7fdd, 0x7fdb, 0x7fdb, 0x7fdb, 0x7fdb,
+	0x7fdb, 0x7fdb, 0x7fdb, 0x080c, 0x0cf1, 0x9186, 0x0003, 0x190c,
+	0x0cf1, 0x00d6, 0x6003, 0x0003, 0x6106, 0x6014, 0x2068, 0x687f,
+	0x0040, 0x68ac, 0x6846, 0x68b0, 0x684a, 0x6837, 0x0000, 0x683b,
+	0x0000, 0x00de, 0x2c10, 0x080c, 0x13a9, 0x080c, 0x68eb, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x6e10, 0x012e, 0x0005, 0x9182, 0x0047,
+	0x0002, 0x800a, 0x800a, 0x800c, 0x802b, 0x800a, 0x800a, 0x800a,
+	0x800a, 0x803d, 0x080c, 0x0cf1, 0x00d6, 0x0016, 0x080c, 0x6cf2,
+	0x080c, 0x6e10, 0x6003, 0x0004, 0x6114, 0x2168, 0x6884, 0x8003,
+	0x800b, 0x810b, 0x9108, 0x611a, 0x687f, 0x0020, 0x688c, 0x688a,
+	0x68a4, 0x68ae, 0x68a8, 0x68b2, 0x68c7, 0x0000, 0x68cb, 0x0000,
+	0x001e, 0x00de, 0x0005, 0x080c, 0x6cf2, 0x00d6, 0x6114, 0x2168,
+	0x080c, 0x95d2, 0x0120, 0x687b, 0x0006, 0x080c, 0x50a5, 0x00de,
+	0x080c, 0x7f1e, 0x080c, 0x6e10, 0x0005, 0x080c, 0x6cf2, 0x080c,
+	0x25ad, 0x00d6, 0x6114, 0x2168, 0x080c, 0x95d2, 0x0120, 0x687b,
+	0x0029, 0x080c, 0x50a5, 0x00de, 0x080c, 0x7f1e, 0x080c, 0x6e10,
+	0x0005, 0x9182, 0x0047, 0x0002, 0x8061, 0x8063, 0x8061, 0x8061,
+	0x8061, 0x8061, 0x8061, 0x8061, 0x8061, 0x8061, 0x8061, 0x8061,
+	0x8063, 0x080c, 0x0cf1, 0x00d6, 0x080c, 0x1132, 0x6114, 0x2168,
+	0x687b, 0x0000, 0x6883, 0x0000, 0x080c, 0x50a5, 0x00de, 0x080c,
+	0x7f1e, 0x0005, 0x91b6, 0x0015, 0x1118, 0x080c, 0x7f1e, 0x0030,
+	0x91b6, 0x0016, 0x190c, 0x0cf1, 0x080c, 0x7f1e, 0x0005, 0x20a9,
+	0x000e, 0x20e1, 0x0000, 0x2e98, 0x6014, 0x20e9, 0x0001, 0x20a0,
+	0x4003, 0x9080, 0x001b, 0x20a0, 0x20a9, 0x0006, 0x3310, 0x3420,
+	0x9298, 0x0001, 0x94a8, 0x0001, 0x222e, 0x2326, 0x9290, 0x0002,
+	0x95a8, 0x0002, 0x9398, 0x0002, 0x94a0, 0x0002, 0x1f04, 0x8094,
+	0x00e6, 0x080c, 0x95d2, 0x0130, 0x6014, 0x2070, 0x7007, 0x0000,
+	0x7067, 0x0103, 0x00ee, 0x080c, 0x7f1e, 0x0005, 0x00d6, 0x0036,
+	0x7330, 0x9386, 0x0200, 0x1130, 0x6010, 0x2068, 0x6813, 0x00ff,
+	0x6817, 0xfffd, 0x6014, 0x9005, 0x0130, 0x2068, 0x6807, 0x0000,
+	0x6867, 0x0103, 0x6b32, 0x080c, 0x7f1e, 0x003e, 0x00de, 0x0005,
+	0x0016, 0x20a9, 0x002a, 0x9e80, 0x000c, 0x20e1, 0x0000, 0x2098,
+	0x6014, 0x9080, 0x0002, 0x20e9, 0x0001, 0x20a0, 0x4003, 0x20a9,
+	0x002a, 0x6014, 0x9080, 0x0001, 0x2004, 0x9080, 0x0002, 0x20a0,
+	0x4003, 0x00e6, 0x6014, 0x2004, 0x2070, 0x7067, 0x0103, 0x00ee,
+	0x080c, 0x7f1e, 0x001e, 0x0005, 0x0016, 0x2009, 0x0000, 0x7030,
+	0x9086, 0x0100, 0x0140, 0x7038, 0x9084, 0x00ff, 0x800c, 0x703c,
+	0x9084, 0x00ff, 0x8004, 0x9080, 0x0004, 0x9108, 0x9192, 0x0014,
+	0x1218, 0x2011, 0x0000, 0x0010, 0x2009, 0x0014, 0x21a8, 0x9e80,
+	0x000c, 0x2098, 0x6014, 0x9080, 0x0002, 0x20a0, 0x080c, 0x4678,
+	0x82ff, 0x0170, 0x2009, 0x0205, 0x2104, 0x8000, 0x200a, 0x2e00,
+	0x2098, 0x3400, 0x9080, 0x0014, 0x20a0, 0x22a8, 0x080c, 0x4678,
+	0x00e6, 0x080c, 0x95d2, 0x0140, 0x6014, 0x2070, 0x7007, 0x0000,
+	0x7064, 0x70e2, 0x7067, 0x0103, 0x00ee, 0x080c, 0x7f1e, 0x001e,
+	0x0005, 0x0016, 0x00d6, 0x7030, 0x9086, 0x0100, 0x1118, 0x2009,
+	0x0004, 0x0010, 0x7034, 0x800c, 0x21a8, 0x9e80, 0x000c, 0x2098,
+	0x6014, 0x2068, 0x6804, 0x9005, 0x1108, 0x2d00, 0x9080, 0x000c,
+	0x20a0, 0x080c, 0x4678, 0x080c, 0x95d2, 0x0148, 0x6804, 0x9005,
+	0x1158, 0x6807, 0x0000, 0x6864, 0x68e2, 0x6867, 0x0103, 0x080c,
+	0x7f1e, 0x00de, 0x001e, 0x0005, 0x00e6, 0x2070, 0x7030, 0x8007,
+	0x9086, 0x0100, 0x1118, 0x080c, 0x8576, 0x00b8, 0x7034, 0x8007,
+	0x800c, 0x9e80, 0x000c, 0x687b, 0x0000, 0x6883, 0x0000, 0x6897,
+	0x4000, 0x6aa0, 0x6b9c, 0x6ca8, 0x6da4, 0x2031, 0x0000, 0x2039,
+	0x0001, 0x2041, 0x0f7e, 0x0019, 0x0d30, 0x00ee, 0x08c0, 0x00d6,
+	0x0006, 0x080c, 0x0dc6, 0x000e, 0x0190, 0x6812, 0x000e, 0x683e,
+	0x0006, 0x6e06, 0x2800, 0x683a, 0x6916, 0x6f0e, 0x6a2a, 0x6b2e,
+	0x6c32, 0x6d36, 0x2d10, 0x080c, 0x0e55, 0x9085, 0x0001, 0x00de,
+	0x0005, 0x00e6, 0x00d6, 0x6043, 0x0000, 0x2c68, 0x0016, 0x2009,
+	0x0035, 0x080c, 0x9ac5, 0x001e, 0x1168, 0x0026, 0x622c, 0x2268,
+	0x002e, 0x2071, 0x026c, 0x6b20, 0x9386, 0x0003, 0x0130, 0x9386,
+	0x0006, 0x0128, 0x080c, 0x7f1e, 0x0020, 0x0031, 0x0010, 0x080c,
+	0x8270, 0x00de, 0x00ee, 0x0005, 0x00f6, 0x6814, 0x2078, 0x9186,
+	0x0015, 0x0904, 0x8259, 0x918e, 0x0016, 0x1904, 0x826e, 0x700c,
+	0x9084, 0xff00, 0x9086, 0x1700, 0x1904, 0x8238, 0x8fff, 0x1138,
+	0x6800, 0x9086, 0x000f, 0x0904, 0x821c, 0x0804, 0x826c, 0x6808,
+	0x9086, 0xffff, 0x1904, 0x825b, 0x787c, 0x9084, 0x0060, 0x9086,
+	0x0020, 0x1128, 0x783c, 0x7940, 0x9105, 0x1904, 0x825b, 0x080c,
+	0x9797, 0x685c, 0x7882, 0x787c, 0xc0dc, 0xc0f4, 0xc0d4, 0x787e,
+	0x0026, 0x900e, 0x6a18, 0x2001, 0x000a, 0x080c, 0x66ff, 0x7884,
+	0x920a, 0x0208, 0x8011, 0x7a86, 0x82ff, 0x002e, 0x1138, 0x00c6,
+	0x2d60, 0x080c, 0x9389, 0x00ce, 0x0804, 0x826c, 0x00c6, 0x00d6,
+	0x2f68, 0x6868, 0xd0fc, 0x1118, 0x080c, 0x477e, 0x0010, 0x080c,
+	0x4a18, 0x00de, 0x00ce, 0x1904, 0x825b, 0x00c6, 0x2d60, 0x080c,
+	0x7f1e, 0x00ce, 0x0804, 0x826c, 0x00c6, 0x080c, 0x984d, 0x0190,
+	0x6017, 0x0000, 0x6810, 0x6012, 0x080c, 0x99cc, 0x6023, 0x0003,
+	0x6904, 0x00c6, 0x2d60, 0x080c, 0x7f1e, 0x00ce, 0x080c, 0x7f4e,
+	0x00ce, 0x04d0, 0x2001, 0x12a8, 0x2004, 0x6842, 0x00ce, 0x04a0,
+	0x7008, 0x9086, 0x000b, 0x11a0, 0x6010, 0x200c, 0xc1bc, 0x2102,
+	0x00c6, 0x2d60, 0x7883, 0x0003, 0x6007, 0x0085, 0x6003, 0x000b,
+	0x6023, 0x0002, 0x080c, 0x6886, 0x080c, 0x6d42, 0x00ce, 0x00e0,
+	0x700c, 0x9086, 0x2a00, 0x1138, 0x2001, 0x12a8, 0x2004, 0x6842,
+	0x0098, 0x0471, 0x0098, 0x8fff, 0x090c, 0x0cf1, 0x00c6, 0x00d6,
+	0x2d60, 0x2f68, 0x687b, 0x0003, 0x080c, 0x926a, 0x080c, 0x9797,
+	0x080c, 0x97a3, 0x00de, 0x00ce, 0x080c, 0x7f1e, 0x00fe, 0x0005,
+	0x9186, 0x0015, 0x1128, 0x2001, 0x12a8, 0x2004, 0x6842, 0x0068,
+	0x918e, 0x0016, 0x1160, 0x00c6, 0x2d00, 0x2060, 0x080c, 0xad19,
+	0x080c, 0x66ae, 0x080c, 0x7f1e, 0x00ce, 0x080c, 0x7f1e, 0x0005,
+	0x0026, 0x0036, 0x0046, 0x7228, 0x7cb0, 0x7bac, 0xd2f4, 0x0130,
+	0x2001, 0x12a8, 0x2004, 0x6842, 0x0804, 0x82ec, 0x00c6, 0x2d60,
+	0x080c, 0x9297, 0x00ce, 0x6804, 0x9086, 0x0050, 0x1170, 0x00c6,
+	0x2d00, 0x2060, 0x6003, 0x0001, 0x6007, 0x0050, 0x080c, 0x6886,
+	0x080c, 0x6d42, 0x00ce, 0x0804, 0x82ec, 0x6800, 0x9086, 0x000f,
+	0x01c8, 0x8fff, 0x090c, 0x0cf1, 0x6824, 0xd0dc, 0x1198, 0x6800,
+	0x9086, 0x0004, 0x1198, 0x787c, 0xd0ac, 0x0180, 0x7843, 0x0fff,
+	0x783f, 0x0fff, 0x7880, 0xc0f4, 0xc0fc, 0x7882, 0x2001, 0x0001,
+	0x6832, 0x00e8, 0x2001, 0x0007, 0x6832, 0x00c8, 0x787c, 0xd0b4,
+	0x1138, 0xd0ac, 0x0db8, 0x7838, 0x7934, 0x9105, 0x0d98, 0x0c30,
+	0xd2ec, 0x1d80, 0x7024, 0x9306, 0x1118, 0x7020, 0x9406, 0x0d50,
+	0x7020, 0x683e, 0x7024, 0x683a, 0x2001, 0x0005, 0x6832, 0x080c,
+	0x98d9, 0x080c, 0x6d42, 0x0010, 0x080c, 0x7f1e, 0x004e, 0x003e,
+	0x002e, 0x0005, 0x00e6, 0x00d6, 0x0026, 0x6038, 0x2068, 0x6a20,
+	0x9286, 0x0007, 0x0904, 0x8350, 0x9286, 0x0002, 0x0904, 0x8350,
+	0x9286, 0x0000, 0x0904, 0x8350, 0x6808, 0x633c, 0x9306, 0x1904,
+	0x8350, 0x2071, 0x026c, 0x9186, 0x0015, 0x05e0, 0x918e, 0x0016,
+	0x1190, 0x6034, 0x9084, 0x00ff, 0x9086, 0x0001, 0x1160, 0x700c,
+	0x9086, 0x2a00, 0x1140, 0x6038, 0x9080, 0x0009, 0x200c, 0xc1dd,
+	0xc1f5, 0x2102, 0x0438, 0x00c6, 0x6038, 0x2060, 0x6104, 0x9186,
+	0x004b, 0x01a0, 0x9186, 0x004c, 0x0188, 0x9186, 0x004d, 0x0170,
+	0x9186, 0x004e, 0x0158, 0x9186, 0x0052, 0x0140, 0x6014, 0x2068,
+	0x080c, 0x95d2, 0x090c, 0x0cf1, 0x6883, 0x0003, 0x6007, 0x0085,
+	0x6003, 0x000b, 0x6023, 0x0002, 0x080c, 0x6886, 0x080c, 0x6d42,
+	0x00ce, 0x0030, 0x6038, 0x2070, 0x2001, 0x12a8, 0x2004, 0x7042,
+	0x080c, 0x7f1e, 0x002e, 0x00de, 0x00ee, 0x0005, 0x00d6, 0x00f6,
+	0x6014, 0x2068, 0x6010, 0x2078, 0x91b6, 0x0015, 0x0130, 0x7a08,
+	0x7b0c, 0x7c00, 0xc48c, 0x7c02, 0x0038, 0x7238, 0x7a0a, 0x733c,
+	0x7b0e, 0x7c00, 0xc48d, 0x7c02, 0x6804, 0x9005, 0x1120, 0x00fe,
+	0x00de, 0x0804, 0x80a0, 0x9080, 0x0002, 0x00d6, 0x2068, 0x6a0a,
+	0x6b0e, 0x6c02, 0x00de, 0x2009, 0x002b, 0x6aa0, 0x6b9c, 0x6ca8,
+	0x6da4, 0x2031, 0x0000, 0x2039, 0x0001, 0x2041, 0x0f7e, 0x080c,
+	0x817f, 0x0128, 0x00fe, 0x00de, 0x080c, 0x7f1e, 0x0005, 0x080c,
+	0x8576, 0x0cc0, 0x2100, 0x91b2, 0x004c, 0x1a0c, 0x0cf1, 0x91b2,
+	0x0040, 0x1a04, 0x83f6, 0x0002, 0x83ea, 0x83de, 0x83ea, 0x83ea,
+	0x83ea, 0x83ea, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc,
+	0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc,
+	0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc,
+	0x83dc, 0x83dc, 0x83dc, 0x83ea, 0x83dc, 0x83ea, 0x83ea, 0x83dc,
+	0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83ea, 0x83dc, 0x83dc, 0x83dc,
+	0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83ea, 0x83ea,
+	0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc, 0x83dc,
+	0x83dc, 0x83ea, 0x83dc, 0x83dc, 0x080c, 0x0cf1, 0x6003, 0x0001,
+	0x6106, 0x080c, 0x68ce, 0x0126, 0x2091, 0x8000, 0x080c, 0x6d42,
+	0x012e, 0x0005, 0x6003, 0x0001, 0x6106, 0x080c, 0x68ce, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x6d42, 0x012e, 0x0005, 0x2600, 0x0002,
+	0x8404, 0x8404, 0x8404, 0x83ea, 0x83ea, 0x8404, 0x8404, 0x8404,
+	0x8404, 0x83ea, 0x8404, 0x8404, 0x080c, 0x0cf1, 0x6004, 0x90b2,
+	0x004c, 0x1a0c, 0x0cf1, 0x91b6, 0x0013, 0x0904, 0x84a2, 0x91b6,
+	0x0027, 0x1904, 0x8468, 0x080c, 0x6c56, 0x6004, 0x080c, 0x97bc,
+	0x0178, 0x080c, 0x97cd, 0x0904, 0x8462, 0x908e, 0x0021, 0x0904,
+	0x8465, 0x908e, 0x0022, 0x05f0, 0x908e, 0x003d, 0x05f0, 0x0498,
+	0x080c, 0x25d1, 0x2001, 0x0007, 0x080c, 0x4ab3, 0x6010, 0x9080,
+	0x0028, 0x200c, 0x080c, 0x8576, 0x9186, 0x007e, 0x1148, 0x2001,
+	0x1133, 0x2014, 0xc285, 0x080c, 0x5745, 0x1108, 0xc2ad, 0x2202,
+	0x0016, 0x0026, 0x0036, 0x2110, 0x2019, 0x0028, 0x080c, 0x69ca,
+	0x0076, 0x2039, 0x0000, 0x080c, 0x68fe, 0x6010, 0x00c6, 0x9065,
+	0x0100, 0x00ce, 0x2c08, 0x080c, 0xa85f, 0x007e, 0x003e, 0x002e,
+	0x001e, 0x080c, 0x4b20, 0x080c, 0x99c4, 0x080c, 0x7f1e, 0x080c,
+	0x6d42, 0x0005, 0x080c, 0x8576, 0x0cb0, 0x080c, 0x85a4, 0x0c98,
+	0x9186, 0x0014, 0x1db0, 0x080c, 0x6c56, 0x080c, 0x25ad, 0x080c,
+	0x97bc, 0x1188, 0x080c, 0x25d1, 0x6010, 0x9080, 0x0028, 0x200c,
+	0x080c, 0x8576, 0x9186, 0x007e, 0x1128, 0x2001, 0x1133, 0x200c,
+	0xc185, 0x2102, 0x08c0, 0x080c, 0x97cd, 0x1118, 0x080c, 0x8576,
+	0x0890, 0x6004, 0x908e, 0x0032, 0x1158, 0x00e6, 0x00f6, 0x2071,
+	0x1193, 0x2079, 0x0000, 0x080c, 0x28cc, 0x00fe, 0x00ee, 0x0818,
+	0x6004, 0x908e, 0x0021, 0x0d50, 0x908e, 0x0022, 0x090c, 0x8576,
+	0x0804, 0x845b, 0x90b2, 0x0040, 0x1a04, 0x8565, 0x2008, 0x0002,
+	0x84ea, 0x84eb, 0x84ee, 0x84f1, 0x84f4, 0x84f7, 0x84e8, 0x84e8,
+	0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8,
+	0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8,
+	0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84fa, 0x8509,
+	0x84e8, 0x850b, 0x8509, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8,
+	0x8509, 0x8509, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8, 0x84e8,
+	0x84e8, 0x84e8, 0x8545, 0x8509, 0x84e8, 0x8505, 0x84e8, 0x84e8,
+	0x84e8, 0x8506, 0x84e8, 0x84e8, 0x84e8, 0x8509, 0x853c, 0x84e8,
+	0x080c, 0x0cf1, 0x00f0, 0x2001, 0x000b, 0x0460, 0x2001, 0x0003,
+	0x0448, 0x2001, 0x0005, 0x0430, 0x2001, 0x0001, 0x0418, 0x2001,
+	0x0009, 0x0400, 0x080c, 0x6c56, 0x6003, 0x0005, 0x2001, 0x12a8,
+	0x2004, 0x6042, 0x080c, 0x6d42, 0x00a0, 0x0018, 0x0010, 0x080c,
+	0x4ab3, 0x0804, 0x8556, 0x080c, 0x6c56, 0x2001, 0x12a6, 0x2004,
+	0x601a, 0x2001, 0x12a8, 0x2004, 0x6042, 0x6003, 0x0004, 0x080c,
+	0x6d42, 0x0005, 0x080c, 0x4ab3, 0x080c, 0x6c56, 0x6003, 0x0002,
+	0x2001, 0x12a8, 0x2004, 0x6042, 0x0036, 0x2019, 0x115d, 0x2304,
+	0x9084, 0xff00, 0x1120, 0x2001, 0x12a6, 0x201c, 0x0040, 0x8007,
+	0x909a, 0x0004, 0x0ec0, 0x8003, 0x801b, 0x831b, 0x9318, 0x631a,
+	0x003e, 0x080c, 0x6d42, 0x08e8, 0x080c, 0x6c56, 0x080c, 0x99c4,
+	0x080c, 0x7f1e, 0x080c, 0x6d42, 0x08a0, 0x00e6, 0x00f6, 0x2071,
+	0x1193, 0x2079, 0x0000, 0x080c, 0x28cc, 0x00fe, 0x00ee, 0x080c,
+	0x6c56, 0x080c, 0x7f1e, 0x080c, 0x6d42, 0x0818, 0x080c, 0x6c56,
+	0x2001, 0x12a8, 0x2004, 0x6042, 0x6003, 0x0002, 0x2001, 0x12a6,
+	0x2004, 0x601a, 0x080c, 0x6d42, 0x0005, 0x2600, 0x2008, 0x0002,
+	0x8574, 0x8574, 0x8574, 0x8556, 0x8556, 0x8574, 0x8574, 0x8574,
+	0x8574, 0x8556, 0x8574, 0x8574, 0x080c, 0x0cf1, 0x00e6, 0x0026,
+	0x0016, 0x080c, 0x95d2, 0x0508, 0x6014, 0x2070, 0x7064, 0x9086,
+	0x0139, 0x1148, 0x2001, 0x0030, 0x2009, 0x0000, 0x2011, 0x4005,
+	0x080c, 0x9a7b, 0x0090, 0x7068, 0xd0fc, 0x0178, 0x7007, 0x0000,
+	0x0016, 0x6004, 0x908e, 0x0021, 0x0160, 0x908e, 0x003d, 0x0148,
+	0x001e, 0x7067, 0x0103, 0x7033, 0x0100, 0x001e, 0x002e, 0x00ee,
+	0x0005, 0x001e, 0x0009, 0x0cc8, 0x00e6, 0x9cf0, 0x0005, 0x2e74,
+	0x7000, 0x2070, 0x7067, 0x0103, 0x7023, 0x8001, 0x00ee, 0x0005,
+	0x00d6, 0x6610, 0x2668, 0x6804, 0x9084, 0x00ff, 0x00de, 0x90b2,
+	0x000c, 0x1a0c, 0x0cf1, 0x6604, 0x96b6, 0x0043, 0x1120, 0x080c,
+	0x9a37, 0x0804, 0x861d, 0x6604, 0x96b6, 0x0033, 0x1120, 0x080c,
+	0x99e7, 0x0804, 0x861d, 0x6604, 0x96b6, 0x0028, 0x1120, 0x080c,
+	0x97fd, 0x0804, 0x861d, 0x6604, 0x96b6, 0x0029, 0x1120, 0x080c,
+	0x9816, 0x0804, 0x861d, 0x6604, 0x96b6, 0x001f, 0x1118, 0x080c,
+	0x807f, 0x04d8, 0x6604, 0x96b6, 0x0000, 0x1118, 0x080c, 0x8356,
+	0x04a0, 0x6604, 0x96b6, 0x0022, 0x1118, 0x080c, 0x80ae, 0x0468,
+	0x6604, 0x96b6, 0x0035, 0x1118, 0x080c, 0x8199, 0x0430, 0x6604,
+	0x96b6, 0x0039, 0x1118, 0x080c, 0x82f2, 0x00f8, 0x6604, 0x96b6,
+	0x003d, 0x1118, 0x080c, 0x80c8, 0x00c0, 0x6604, 0x96b6, 0x0044,
+	0x1118, 0x080c, 0x80ec, 0x0088, 0x6604, 0x96b6, 0x0049, 0x1118,
+	0x080c, 0x8131, 0x0050, 0x91b6, 0x0015, 0x1110, 0x0053, 0x0028,
+	0x91b6, 0x0016, 0x1118, 0x0804, 0x87e2, 0x0005, 0x080c, 0x7f68,
+	0x0ce0, 0x863b, 0x863e, 0x863b, 0x8682, 0x863b, 0x8762, 0x87f0,
+	0x863b, 0x863b, 0x87bc, 0x863b, 0x87d2, 0x00e6, 0x080c, 0x1132,
+	0x9cf0, 0x0005, 0x2e74, 0x7000, 0x2070, 0x7067, 0x0103, 0x00ee,
+	0x080c, 0x7f1e, 0x0005, 0xa001, 0xa001, 0x0005, 0x00e6, 0x2071,
+	0x1100, 0x7080, 0x9086, 0x0074, 0x1540, 0x080c, 0xa836, 0x11b0,
+	0x6010, 0x00d6, 0x2068, 0x7030, 0xd08c, 0x0128, 0x6800, 0xd0bc,
+	0x0110, 0xc0c5, 0x6802, 0x00e9, 0x00de, 0x2001, 0x0006, 0x080c,
+	0x4ab3, 0x080c, 0x25d1, 0x080c, 0x7f1e, 0x0088, 0x2001, 0x000a,
+	0x080c, 0x4ab3, 0x080c, 0x25d1, 0x6003, 0x0001, 0x6007, 0x0001,
+	0x080c, 0x68ce, 0x080c, 0x6d42, 0x0010, 0x080c, 0x8752, 0x00ee,
+	0x0005, 0x6800, 0xd084, 0x0168, 0x2001, 0x0000, 0x080c, 0x4aa1,
+	0x2069, 0x1152, 0x6804, 0xd0a4, 0x0120, 0x2001, 0x0006, 0x080c,
+	0x4ae0, 0x0005, 0x00d6, 0x2011, 0x1120, 0x2204, 0x9086, 0x0074,
+	0x1904, 0x874f, 0x6010, 0x2068, 0x6aa0, 0x9286, 0x007e, 0x1120,
+	0x080c, 0x88f8, 0x0804, 0x86f0, 0x080c, 0x88ee, 0x6010, 0x2068,
+	0x6aa0, 0x9286, 0x0080, 0x11c0, 0x6813, 0x00ff, 0x6817, 0xfffc,
+	0x6014, 0x9005, 0x0138, 0x2068, 0x6807, 0x0000, 0x6867, 0x0103,
+	0x6833, 0x0200, 0x2001, 0x0006, 0x080c, 0x4ab3, 0x080c, 0x25d1,
+	0x080c, 0x7f1e, 0x0804, 0x8750, 0x00e6, 0x2071, 0x1133, 0x2e04,
+	0xd09c, 0x0188, 0x2071, 0x0260, 0x7108, 0x720c, 0x918c, 0x00ff,
+	0x1118, 0x9284, 0xff00, 0x0138, 0x6010, 0x2070, 0x70a0, 0xd0bc,
+	0x1110, 0x7112, 0x7216, 0x00ee, 0x6014, 0x9005, 0x0198, 0x2068,
+	0x6868, 0xd0f4, 0x0178, 0x6864, 0x9084, 0x00ff, 0x9086, 0x0039,
+	0x1958, 0x2001, 0x0000, 0x2009, 0x0000, 0x2011, 0x4000, 0x080c,
+	0x9a7b, 0x0840, 0x2001, 0x0004, 0x080c, 0x4ab3, 0x6003, 0x0001,
+	0x6007, 0x0003, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x0804, 0x8750,
+	0x685c, 0xd0e4, 0x01d8, 0x080c, 0x9966, 0x080c, 0x5745, 0x0118,
+	0xd0dc, 0x1904, 0x86aa, 0x2011, 0x1133, 0x2204, 0xc0ad, 0x2012,
+	0x2001, 0x1280, 0x2004, 0x00f6, 0x2079, 0x0100, 0x78e3, 0x0000,
+	0x080c, 0x1cbe, 0x78e2, 0x00fe, 0x0804, 0x86aa, 0x080c, 0x99a3,
+	0x2011, 0x1133, 0x2204, 0xc0a5, 0x2012, 0x0006, 0x080c, 0xa966,
+	0x000e, 0x1904, 0x86aa, 0xc0b5, 0x2012, 0x2001, 0x0000, 0x080c,
+	0x4aa1, 0x00c6, 0x2009, 0x00ef, 0x00f6, 0x2079, 0x0100, 0x79ea,
+	0x7932, 0x7936, 0x00fe, 0x080c, 0x1c93, 0x00f6, 0x2079, 0x1100,
+	0x7972, 0x2100, 0x2009, 0x0000, 0x080c, 0x1c69, 0x794e, 0x00fe,
+	0x8108, 0x080c, 0x4b03, 0x2c00, 0x00ce, 0x1904, 0x86aa, 0x6012,
+	0x2001, 0x0002, 0x080c, 0x4ab3, 0x6023, 0x0001, 0x6003, 0x0001,
+	0x6007, 0x0002, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x0008, 0x0011,
+	0x00de, 0x0005, 0x2030, 0x2001, 0x1100, 0x2004, 0x9086, 0x0003,
+	0x0120, 0x2001, 0x0007, 0x080c, 0x4ab3, 0x080c, 0x25d1, 0x080c,
+	0x7f1e, 0x0005, 0x00e6, 0x0026, 0x0016, 0x2071, 0x1100, 0x7080,
+	0x9086, 0x0014, 0x1904, 0x87b4, 0x7000, 0x9086, 0x0003, 0x1178,
+	0x6014, 0x9005, 0x1160, 0x0036, 0x0046, 0x6010, 0x9080, 0x0028,
+	0x201c, 0x2021, 0x0006, 0x080c, 0x384a, 0x004e, 0x003e, 0x00d6,
+	0x6010, 0x2068, 0x080c, 0x4bf5, 0x080c, 0x8671, 0x00de, 0x080c,
+	0x89bf, 0x1550, 0x6010, 0x00d6, 0x2068, 0x6890, 0x00de, 0x9005,
+	0x0518, 0x2001, 0x0006, 0x080c, 0x4ab3, 0x00e6, 0x6014, 0x9075,
+	0x01a8, 0x7064, 0x9084, 0x00ff, 0x9086, 0x0039, 0x1148, 0x2001,
+	0x0000, 0x2009, 0x0000, 0x2011, 0x4000, 0x080c, 0x9a7b, 0x0030,
+	0x7007, 0x0000, 0x7067, 0x0103, 0x7033, 0x0200, 0x00ee, 0x080c,
+	0x25d1, 0x080c, 0x7f1e, 0x0020, 0x080c, 0x8576, 0x080c, 0x8752,
+	0x001e, 0x002e, 0x00ee, 0x0005, 0x2011, 0x1120, 0x2204, 0x9086,
+	0x0014, 0x1168, 0x2001, 0x0002, 0x080c, 0x4ab3, 0x6003, 0x0001,
+	0x6007, 0x0001, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x0010, 0x080c,
+	0x8752, 0x0005, 0x2011, 0x1120, 0x2204, 0x9086, 0x0004, 0x1138,
+	0x2001, 0x0007, 0x080c, 0x4ab3, 0x080c, 0x7f1e, 0x0010, 0x080c,
+	0x8752, 0x0005, 0x000b, 0x0005, 0x863b, 0x87f7, 0x863b, 0x882d,
+	0x863b, 0x88a4, 0x87f0, 0x863b, 0x863b, 0x88b9, 0x863b, 0x88cb,
+	0x6604, 0x96b6, 0x001e, 0x1110, 0x080c, 0x7f1e, 0x0005, 0x00d6,
+	0x00c6, 0x080c, 0x88dd, 0x1188, 0x2001, 0x0000, 0x080c, 0x4aa1,
+	0x2001, 0x0002, 0x080c, 0x4ab3, 0x6003, 0x0001, 0x6007, 0x0002,
+	0x080c, 0x68ce, 0x080c, 0x6d42, 0x00e8, 0x2009, 0x026e, 0x2104,
+	0x9086, 0x0009, 0x1160, 0x6010, 0x2068, 0x6840, 0x9084, 0x00ff,
+	0x9005, 0x0170, 0x8001, 0x6842, 0x601b, 0x000a, 0x0058, 0x2009,
+	0x026f, 0x2104, 0x9084, 0xff00, 0x9086, 0x1900, 0x1108, 0x08c0,
+	0x080c, 0x8752, 0x00ce, 0x00de, 0x0005, 0x080c, 0x88eb, 0x00d6,
+	0x2069, 0x128f, 0x2d04, 0x9005, 0x0168, 0x6010, 0x2068, 0x68a0,
+	0x9086, 0x007e, 0x1138, 0x2069, 0x111c, 0x2d04, 0x8000, 0x206a,
+	0x00de, 0x0010, 0x00de, 0x0088, 0x2001, 0x0000, 0x080c, 0x4aa1,
+	0x2001, 0x0002, 0x080c, 0x4ab3, 0x6003, 0x0001, 0x6007, 0x0002,
+	0x080c, 0x68ce, 0x080c, 0x6d42, 0x0428, 0x080c, 0x8576, 0x2009,
+	0x026e, 0x2134, 0x96b4, 0x00ff, 0x9686, 0x0005, 0x01e0, 0x9686,
+	0x000b, 0x01b0, 0x2009, 0x026f, 0x2104, 0x9084, 0xff00, 0x1118,
+	0x9686, 0x0009, 0x0180, 0x9086, 0x1900, 0x1150, 0x9686, 0x0009,
+	0x0150, 0x2001, 0x0004, 0x080c, 0x4ab3, 0x080c, 0x7f1e, 0x0010,
+	0x080c, 0x8752, 0x0005, 0x00d6, 0x6014, 0x2068, 0x080c, 0x95d2,
+	0x0128, 0x6868, 0xd0fc, 0x0110, 0x00de, 0x0c90, 0x6010, 0x2068,
+	0x6840, 0x9084, 0x00ff, 0x9005, 0x0140, 0x8001, 0x6842, 0x601b,
+	0x000a, 0x6007, 0x0016, 0x00de, 0x0c28, 0x68a0, 0x9086, 0x007e,
+	0x1138, 0x00e6, 0x2071, 0x1100, 0x080c, 0x46bb, 0x00ee, 0x0010,
+	0x080c, 0x25ad, 0x00de, 0x08a0, 0x080c, 0x88eb, 0x1168, 0x2001,
+	0x0004, 0x080c, 0x4ab3, 0x6003, 0x0001, 0x6007, 0x0003, 0x080c,
+	0x68ce, 0x080c, 0x6d42, 0x0020, 0x080c, 0x8576, 0x080c, 0x8752,
+	0x0005, 0x0489, 0x1168, 0x2001, 0x0008, 0x080c, 0x4ab3, 0x6003,
+	0x0001, 0x6007, 0x0005, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x0010,
+	0x080c, 0x8752, 0x0005, 0x00f9, 0x1168, 0x2001, 0x000a, 0x080c,
+	0x4ab3, 0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x68ce, 0x080c,
+	0x6d42, 0x0010, 0x080c, 0x8752, 0x0005, 0x2009, 0x026e, 0x2104,
+	0x9086, 0x0003, 0x1138, 0x2009, 0x026f, 0x2104, 0x9084, 0xff00,
+	0x9086, 0x2a00, 0x0005, 0x9085, 0x0001, 0x0005, 0x00c6, 0x0016,
+	0x9c88, 0x0004, 0x2164, 0x080c, 0x4b67, 0x001e, 0x00ce, 0x0005,
+	0x00f6, 0x00e6, 0x00d6, 0x0036, 0x0016, 0x6010, 0x2068, 0x2009,
+	0x1133, 0x2104, 0x9085, 0x0003, 0x200a, 0x080c, 0x8994, 0x0570,
+	0x2009, 0x1133, 0x2104, 0xc0cd, 0x200a, 0x2001, 0x1153, 0x2004,
+	0xd0a4, 0x0158, 0x9006, 0x2020, 0x2009, 0x002a, 0x080c, 0xaaca,
+	0x2001, 0x110c, 0x200c, 0xc195, 0x2102, 0x2019, 0x002a, 0x2009,
+	0x0001, 0x080c, 0x2582, 0x00e6, 0x2071, 0x1100, 0x080c, 0x23cd,
+	0x00ee, 0x00c6, 0x0156, 0x20a9, 0x0081, 0x2009, 0x007f, 0x080c,
+	0x26a3, 0x8108, 0x1f04, 0x892f, 0x015e, 0x00ce, 0x080c, 0x88ee,
+	0x6813, 0x00ff, 0x6817, 0xfffe, 0x2071, 0x0260, 0x2079, 0x0200,
+	0x7817, 0x0001, 0x2001, 0x1133, 0x200c, 0xc1c5, 0x7018, 0xd0fc,
+	0x0110, 0xd0dc, 0x0118, 0x7038, 0xd0dc, 0x1108, 0xc1c4, 0x7817,
+	0x0000, 0x2001, 0x1133, 0x2102, 0x2079, 0x0100, 0x2e04, 0x9084,
+	0x00ff, 0x2069, 0x111b, 0x206a, 0x78e6, 0x0006, 0x8e70, 0x2e04,
+	0x2069, 0x111c, 0x206a, 0x78ea, 0x7832, 0x7836, 0x2010, 0x9084,
+	0xff00, 0x001e, 0x9105, 0x2009, 0x1127, 0x200a, 0x2200, 0x9084,
+	0x00ff, 0x2008, 0x080c, 0x1c93, 0x080c, 0x5745, 0x0170, 0x2071,
+	0x0260, 0x2069, 0x12a2, 0x7048, 0x206a, 0x704c, 0x6806, 0x7050,
+	0x680a, 0x7054, 0x680e, 0x080c, 0x9966, 0x0040, 0x2001, 0x0006,
+	0x080c, 0x4ab3, 0x080c, 0x25d1, 0x080c, 0x7f1e, 0x001e, 0x003e,
+	0x00de, 0x00ee, 0x00fe, 0x0005, 0x0026, 0x0036, 0x00e6, 0x0156,
+	0x2019, 0x1127, 0x231c, 0x83ff, 0x01e8, 0x2071, 0x0260, 0x7200,
+	0x9294, 0x00ff, 0x7004, 0x9084, 0xff00, 0x9205, 0x9306, 0x1190,
+	0x2011, 0x0276, 0x20a9, 0x0004, 0x9d98, 0x000a, 0x080c, 0x8a45,
+	0x1148, 0x2011, 0x027a, 0x20a9, 0x0004, 0x9d98, 0x0006, 0x080c,
+	0x8a45, 0x1100, 0x015e, 0x00ee, 0x003e, 0x002e, 0x0005, 0x00e6,
+	0x2071, 0x0260, 0x7034, 0x9086, 0x0014, 0x11a8, 0x7038, 0x9086,
+	0x0800, 0x1188, 0x703c, 0xd0ec, 0x0160, 0x9084, 0x0f00, 0x9086,
+	0x0100, 0x1138, 0x7054, 0xd0a4, 0x1110, 0xd0ac, 0x0110, 0x9006,
+	0x0010, 0x9085, 0x0001, 0x00ee, 0x0005, 0x00e6, 0x00d6, 0x00c6,
+	0x0076, 0x0056, 0x0046, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000,
+	0x2029, 0x12e5, 0x252c, 0x2021, 0x12eb, 0x2424, 0x2061, 0x15c0,
+	0x2071, 0x1100, 0x7244, 0x7064, 0x9202, 0x16f0, 0x080c, 0xaaf2,
+	0x05a0, 0x6720, 0x9786, 0x0001, 0x0580, 0x9786, 0x0007, 0x0568,
+	0x2500, 0x9c06, 0x0550, 0x2400, 0x9c06, 0x0538, 0x00c6, 0x6000,
+	0x9086, 0x0004, 0x1110, 0x080c, 0x12c7, 0x9786, 0x0008, 0x1148,
+	0x080c, 0x97cd, 0x1130, 0x00ce, 0x080c, 0x8576, 0x080c, 0x97a3,
+	0x00a0, 0x6014, 0x2068, 0x080c, 0x95d2, 0x0160, 0x9786, 0x0003,
+	0x11e8, 0x6867, 0x0103, 0x6b7a, 0x6877, 0x0000, 0x080c, 0x50a5,
+	0x080c, 0x9797, 0x080c, 0x97a3, 0x00ce, 0x9ce0, 0x0018, 0x7058,
+	0x9c02, 0x1210, 0x0804, 0x89f2, 0x012e, 0x000e, 0x002e, 0x004e,
+	0x005e, 0x007e, 0x00ce, 0x00de, 0x00ee, 0x0005, 0x9786, 0x0006,
+	0x1118, 0x080c, 0xaa84, 0x0c30, 0x08e0, 0x220c, 0x2304, 0x9106,
+	0x1130, 0x8210, 0x8318, 0x1f04, 0x8a45, 0x9006, 0x0005, 0x2304,
+	0x9102, 0x0218, 0x2001, 0x0001, 0x0010, 0x2001, 0x0000, 0x918d,
+	0x0001, 0x0005, 0x0136, 0x01c6, 0x0016, 0x0026, 0x080c, 0x0d7e,
+	0x2100, 0x22e0, 0x9300, 0x2098, 0x3518, 0x20a9, 0x0001, 0x002e,
+	0x220c, 0x4002, 0x910e, 0x1140, 0x8210, 0x8319, 0x1dc8, 0x9006,
+	0x001e, 0x01ce, 0x013e, 0x0005, 0x220c, 0x9102, 0x0218, 0x2001,
+	0x0001, 0x0010, 0x2001, 0x0000, 0x918d, 0x0001, 0x001e, 0x01ce,
+	0x013e, 0x0005, 0x6004, 0x908a, 0x004c, 0x1a0c, 0x0cf1, 0x080c,
+	0x97bc, 0x0120, 0x080c, 0x97cd, 0x0168, 0x0028, 0x080c, 0x25d1,
+	0x080c, 0x97cd, 0x0138, 0x080c, 0x6c56, 0x080c, 0x7f1e, 0x080c,
+	0x6d42, 0x0005, 0x080c, 0x8576, 0x0cb0, 0x9182, 0x0040, 0x0002,
+	0x8ab3, 0x8ab3, 0x8ab3, 0x8ab3, 0x8ab3, 0x8ab3, 0x8ab3, 0x8ab3,
+	0x8ab3, 0x8ab3, 0x8ab3, 0x8ab5, 0x8ab5, 0x8ab5, 0x8ab5, 0x8ab3,
+	0x8ab3, 0x8ab3, 0x8ab5, 0x080c, 0x0cf1, 0x600b, 0xffff, 0x6003,
+	0x0001, 0x6106, 0x080c, 0x6886, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x6d42, 0x012e, 0x0005, 0x9186, 0x0013, 0x1128, 0x6004, 0x9082,
+	0x0040, 0x0804, 0x8b4d, 0x9186, 0x0027, 0x11e8, 0x080c, 0x6c56,
+	0x080c, 0x25ad, 0x00d6, 0x6114, 0x2168, 0x080c, 0x95d2, 0x0168,
+	0x6867, 0x0103, 0x687b, 0x0029, 0x6877, 0x0000, 0x697c, 0xc1c5,
+	0x697e, 0x080c, 0x50a5, 0x080c, 0x9797, 0x00de, 0x080c, 0x7f1e,
+	0x080c, 0x6d42, 0x0005, 0x9186, 0x0014, 0x1120, 0x6004, 0x9082,
+	0x0040, 0x0418, 0x9186, 0x0046, 0x0138, 0x9186, 0x0045, 0x0120,
+	0x9186, 0x0048, 0x190c, 0x0cf1, 0x2001, 0x0109, 0x2004, 0xd084,
+	0x0198, 0x0126, 0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x080c,
+	0x677e, 0x002e, 0x001e, 0x000e, 0x012e, 0xa001, 0x6000, 0x9086,
+	0x0002, 0x1110, 0x0804, 0x8b8c, 0x0005, 0x0002, 0x8b2b, 0x8b29,
+	0x8b29, 0x8b29, 0x8b29, 0x8b29, 0x8b29, 0x8b29, 0x8b29, 0x8b29,
+	0x8b29, 0x8b46, 0x8b46, 0x8b46, 0x8b46, 0x8b29, 0x8b46, 0x8b29,
+	0x8b46, 0x080c, 0x0cf1, 0x080c, 0x6c56, 0x00d6, 0x6114, 0x2168,
+	0x080c, 0x95d2, 0x0168, 0x6867, 0x0103, 0x687b, 0x0006, 0x6877,
+	0x0000, 0x6880, 0xc0ec, 0x6882, 0x080c, 0x50a5, 0x080c, 0x9797,
+	0x00de, 0x080c, 0x7f1e, 0x080c, 0x6d42, 0x0005, 0x080c, 0x6c56,
+	0x080c, 0x7f1e, 0x080c, 0x6d42, 0x0005, 0x0002, 0x8b63, 0x8b61,
+	0x8b61, 0x8b61, 0x8b61, 0x8b61, 0x8b61, 0x8b61, 0x8b61, 0x8b61,
+	0x8b61, 0x8b7a, 0x8b7a, 0x8b7a, 0x8b7a, 0x8b61, 0x8b85, 0x8b61,
+	0x8b7a, 0x080c, 0x0cf1, 0x00d6, 0x080c, 0x6c56, 0x6014, 0x2068,
+	0x2001, 0x12a8, 0x2004, 0x6042, 0x697c, 0xd1ac, 0x0140, 0x6003,
+	0x0004, 0x687c, 0x9085, 0x0400, 0x687e, 0x00de, 0x0005, 0x6003,
+	0x0002, 0x0cb8, 0x080c, 0x6c56, 0x2001, 0x12a8, 0x2004, 0x6042,
+	0x6003, 0x000f, 0x080c, 0x6d42, 0x0005, 0x080c, 0x6c56, 0x080c,
+	0x7f1e, 0x080c, 0x6d42, 0x0005, 0x9182, 0x0040, 0x0002, 0x8ba3,
+	0x8ba3, 0x8ba3, 0x8ba3, 0x8ba3, 0x8ba5, 0x8c7a, 0x8ba3, 0x8ba3,
+	0x8ba3, 0x8ba3, 0x8ba3, 0x8ba3, 0x8ba3, 0x8ba3, 0x8ba3, 0x8ba3,
+	0x8ba3, 0x8ba3, 0x8ca9, 0x080c, 0x0cf1, 0x00d6, 0x6114, 0x2168,
+	0x7644, 0x96b4, 0x0fff, 0x86ff, 0x1508, 0x6010, 0x2004, 0xd0bc,
+	0x1904, 0x8c65, 0x687b, 0x0000, 0x6867, 0x0103, 0x6e76, 0x687c,
+	0xd0ac, 0x0128, 0x6834, 0x6938, 0x9115, 0x190c, 0x8dfb, 0x080c,
+	0x4ed6, 0x6210, 0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x7044, 0xd0e4,
+	0x1904, 0x8c4b, 0x080c, 0x7f1e, 0x00de, 0x0005, 0x968c, 0x0c00,
+	0x0148, 0x6010, 0x2004, 0xd0bc, 0x1904, 0x8c4f, 0x7348, 0x6b92,
+	0x734c, 0x6b8e, 0x968c, 0x00ff, 0x9186, 0x0002, 0x0508, 0x9186,
+	0x0028, 0x1118, 0x687b, 0x001c, 0x00e8, 0xd6dc, 0x01a0, 0x687b,
+	0x0015, 0x687c, 0xd0ac, 0x0170, 0x6938, 0x6a34, 0x2100, 0x9205,
+	0x0148, 0x7048, 0x9106, 0x1118, 0x734c, 0x9206, 0x0118, 0x6992,
+	0x6a8e, 0xc6dc, 0x0038, 0xd6d4, 0x0118, 0x687b, 0x0007, 0x0010,
+	0x687b, 0x0000, 0x6867, 0x0103, 0x6e76, 0x901e, 0xd6c4, 0x01d8,
+	0x9686, 0x0100, 0x1130, 0x7064, 0x9005, 0x1118, 0xc6c4, 0x0804,
+	0x8bab, 0x735c, 0x6b86, 0x83ff, 0x0170, 0x938a, 0x0009, 0x0210,
+	0x2019, 0x0008, 0x0036, 0x2308, 0x2019, 0x0018, 0x9d90, 0x0025,
+	0x080c, 0x927a, 0x003e, 0xd6cc, 0x0904, 0x8bbf, 0x7154, 0x698a,
+	0x81ff, 0x0904, 0x8bbf, 0x9192, 0x0021, 0x1268, 0x8304, 0x9098,
+	0x0018, 0x9d90, 0x0029, 0x080c, 0x927a, 0x2011, 0x0205, 0x2013,
+	0x0000, 0x0804, 0x8bbf, 0x6868, 0xd0fc, 0x0120, 0x2009, 0x0020,
+	0x698a, 0x0c60, 0x00f6, 0x2d78, 0x080c, 0x9219, 0x00fe, 0x080c,
+	0x926a, 0x0804, 0x8bc1, 0x080c, 0x987a, 0x0804, 0x8bcc, 0x687c,
+	0xd0ac, 0x0904, 0x8bd6, 0x6024, 0xd0dc, 0x1904, 0x8bd6, 0x6880,
+	0xd0bc, 0x1904, 0x8bd6, 0x7348, 0x6838, 0x9306, 0x11b8, 0x734c,
+	0x6834, 0x9306, 0x0904, 0x8bd6, 0x0088, 0x687c, 0xd0ac, 0x0904,
+	0x8bb2, 0x6838, 0x6934, 0x9105, 0x0904, 0x8bb2, 0x6024, 0xd0dc,
+	0x1904, 0x8bb2, 0x6880, 0xd0bc, 0x1904, 0x8bb2, 0x080c, 0x98aa,
+	0x0804, 0x8bcc, 0x00f6, 0x6003, 0x0003, 0x2079, 0x026c, 0x7c04,
+	0x7b00, 0x7e0c, 0x7d08, 0x6014, 0x2078, 0x787c, 0xd0ac, 0x0138,
+	0x6003, 0x0002, 0x00fe, 0x0005, 0x2130, 0x2228, 0x0058, 0x2400,
+	0x79ac, 0x910a, 0x2300, 0x7ab0, 0x9213, 0x2600, 0x9102, 0x2500,
+	0x9203, 0x0e90, 0x7c36, 0x7b3a, 0x7e46, 0x7d4a, 0x00fe, 0x6043,
+	0x0000, 0x2c10, 0x080c, 0x13a9, 0x080c, 0x68eb, 0x080c, 0x6e10,
+	0x0005, 0x0005, 0x9182, 0x0040, 0x0002, 0x8cc0, 0x8cc0, 0x8cc0,
+	0x8cc0, 0x8cc0, 0x8cc2, 0x8d54, 0x8cc0, 0x8cc0, 0x8d6a, 0x8dd2,
+	0x8cc0, 0x8cc0, 0x8cc0, 0x8cc0, 0x8de1, 0x8cc0, 0x8cc0, 0x8cc0,
+	0x080c, 0x0cf1, 0x0076, 0x00f6, 0x00e6, 0x00d6, 0x2071, 0x0260,
+	0x6114, 0x2178, 0x7644, 0x7e76, 0x96b4, 0x0fff, 0x7f7c, 0xc7e5,
+	0x7f7e, 0x6210, 0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x86ff, 0x0904,
+	0x8d4f, 0x9694, 0xff00, 0x9284, 0x0c00, 0x0120, 0x7048, 0x7892,
+	0x704c, 0x788e, 0x9284, 0x0300, 0x0904, 0x8d4f, 0x080c, 0x0ddf,
+	0x090c, 0x0cf1, 0x2d00, 0x787a, 0x7f7c, 0xc7cd, 0x7f7e, 0x6867,
+	0x0103, 0x7868, 0x686a, 0x786c, 0x686e, 0x7870, 0x6872, 0x6e76,
+	0x968c, 0x0c00, 0x0120, 0x7348, 0x6b92, 0x734c, 0x6b8e, 0x968c,
+	0x00ff, 0x9186, 0x0002, 0x0180, 0x9186, 0x0028, 0x1118, 0x687b,
+	0x001c, 0x0060, 0xd6dc, 0x0118, 0x687b, 0x0015, 0x0038, 0xd6d4,
+	0x0118, 0x687b, 0x0007, 0x0010, 0x687b, 0x0000, 0x6f7e, 0x7880,
+	0x6882, 0x7884, 0x6886, 0x901e, 0xd6c4, 0x0190, 0x735c, 0x6b86,
+	0x83ff, 0x0170, 0x938a, 0x0009, 0x0210, 0x2019, 0x0008, 0x0036,
+	0x2308, 0x2019, 0x0018, 0x9d90, 0x0025, 0x080c, 0x927a, 0x003e,
+	0xd6cc, 0x01e8, 0x7154, 0x698a, 0x81ff, 0x01c8, 0x9192, 0x0021,
+	0x1260, 0x8304, 0x9098, 0x0018, 0x9d90, 0x0029, 0x080c, 0x927a,
+	0x2011, 0x0205, 0x2013, 0x0000, 0x0050, 0x7868, 0xd0fc, 0x0120,
+	0x2009, 0x0020, 0x698a, 0x0c68, 0x2d78, 0x080c, 0x9219, 0x00de,
+	0x00ee, 0x00fe, 0x007e, 0x0005, 0x00f6, 0x6003, 0x0003, 0x2079,
+	0x026c, 0x7c04, 0x7b00, 0x7e0c, 0x7d08, 0x6014, 0x2078, 0x7c36,
+	0x7b3a, 0x7e46, 0x7d4a, 0x00fe, 0x2c10, 0x080c, 0x13a9, 0x080c,
+	0x76ee, 0x0005, 0x00d6, 0x2001, 0x12a8, 0x2004, 0x6042, 0x6003,
+	0x0002, 0x080c, 0x6cf2, 0x080c, 0x6e10, 0x6114, 0x2168, 0x697c,
+	0xd1e4, 0x0904, 0x8dcd, 0xd1cc, 0x0570, 0x6978, 0x6868, 0xd0fc,
+	0x0500, 0x0016, 0x687c, 0x0006, 0x6880, 0x0006, 0x9d90, 0x0019,
+	0x9198, 0x0019, 0x2009, 0x0020, 0x0156, 0x21a8, 0x2304, 0x2012,
+	0x8318, 0x8210, 0x1f04, 0x8d8e, 0x015e, 0x000e, 0x6882, 0x000e,
+	0x687e, 0x001e, 0x6874, 0x0006, 0x2168, 0x080c, 0x0e06, 0x001e,
+	0x0440, 0x0016, 0x080c, 0x0e06, 0x00de, 0x6974, 0x0016, 0x080c,
+	0x926a, 0x001e, 0x00f0, 0x6867, 0x0103, 0x6974, 0x9184, 0x00ff,
+	0x90b6, 0x0002, 0x0180, 0x9086, 0x0028, 0x1118, 0x687b, 0x001c,
+	0x0060, 0xd1dc, 0x0118, 0x687b, 0x0015, 0x0038, 0xd1d4, 0x0118,
+	0x687b, 0x0007, 0x0010, 0x687b, 0x0000, 0x0016, 0x080c, 0x4ed6,
+	0x001e, 0xd1e4, 0x1120, 0x080c, 0x7f1e, 0x00de, 0x0005, 0x080c,
+	0x987a, 0x0cd8, 0x2019, 0x0001, 0x080c, 0x7936, 0x6003, 0x0002,
+	0x2001, 0x12a8, 0x2004, 0x6042, 0x080c, 0x6cf2, 0x080c, 0x6e10,
+	0x0005, 0x080c, 0x6cf2, 0x080c, 0x25ad, 0x00d6, 0x6114, 0x2168,
+	0x080c, 0x95d2, 0x0150, 0x6867, 0x0103, 0x687b, 0x0029, 0x6877,
+	0x0000, 0x080c, 0x50a5, 0x080c, 0x9797, 0x00de, 0x080c, 0x7f1e,
+	0x080c, 0x6e10, 0x0005, 0x687b, 0x0015, 0xd1fc, 0x0138, 0x687b,
+	0x0007, 0x8002, 0x8000, 0x810a, 0x9189, 0x0000, 0x6992, 0x688e,
+	0x0005, 0x9182, 0x0040, 0x0002, 0x8e20, 0x8e20, 0x8e20, 0x8e20,
+	0x8e20, 0x8e22, 0x8e20, 0x8e20, 0x8ec0, 0x8e20, 0x8e20, 0x8e20,
+	0x8e20, 0x8e20, 0x8e20, 0x8e20, 0x8e20, 0x8e20, 0x8e20, 0x8fdc,
+	0x080c, 0x0cf1, 0x0076, 0x00f6, 0x00e6, 0x00d6, 0x2071, 0x0260,
+	0x6114, 0x2178, 0x7644, 0x7e76, 0x96b4, 0x0fff, 0x7f7c, 0xc7e5,
+	0x7f7e, 0x6210, 0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x86ff, 0x0904,
+	0x8eb9, 0x9694, 0xff00, 0x9284, 0x0c00, 0x0120, 0x7048, 0x7892,
+	0x704c, 0x788e, 0x9284, 0x0300, 0x0904, 0x8eb9, 0x9686, 0x0100,
+	0x1130, 0x7064, 0x9005, 0x1118, 0xc6c4, 0x7e76, 0x0c38, 0x080c,
+	0x0ddf, 0x090c, 0x0cf1, 0x2d00, 0x787a, 0x7f7c, 0x97bd, 0x0200,
+	0x7f7e, 0x6867, 0x0103, 0x7868, 0x686a, 0x786c, 0x686e, 0x7870,
+	0x6872, 0x6e76, 0x968c, 0x0c00, 0x0120, 0x7348, 0x6b92, 0x734c,
+	0x6b8e, 0x968c, 0x00ff, 0x9186, 0x0002, 0x0180, 0x9186, 0x0028,
+	0x1118, 0x687b, 0x001c, 0x0060, 0xd6dc, 0x0118, 0x687b, 0x0015,
+	0x0038, 0xd6d4, 0x0118, 0x687b, 0x0007, 0x0010, 0x687b, 0x0000,
+	0x6f7e, 0x7880, 0x6882, 0x7884, 0x6886, 0x901e, 0xd6c4, 0x0190,
+	0x735c, 0x6b86, 0x83ff, 0x0170, 0x938a, 0x0009, 0x0210, 0x2019,
+	0x0008, 0x0036, 0x2308, 0x2019, 0x0018, 0x9d90, 0x0025, 0x080c,
+	0x927a, 0x003e, 0xd6cc, 0x01e8, 0x7154, 0x698a, 0x81ff, 0x01c8,
+	0x9192, 0x0021, 0x1260, 0x8304, 0x9098, 0x0018, 0x9d90, 0x0029,
+	0x080c, 0x927a, 0x2011, 0x0205, 0x2013, 0x0000, 0x0050, 0x7868,
+	0xd0fc, 0x0120, 0x2009, 0x0020, 0x698a, 0x0c68, 0x2d78, 0x080c,
+	0x9219, 0x080c, 0x12a4, 0x00de, 0x00ee, 0x00fe, 0x007e, 0x0005,
+	0x2001, 0x12a8, 0x2004, 0x6042, 0x00d6, 0x6114, 0x2168, 0x683c,
+	0x6940, 0x9105, 0x1118, 0x687c, 0xc0dc, 0x687e, 0x6003, 0x0002,
+	0x697c, 0xd1e4, 0x0904, 0x8fd7, 0x6043, 0x0000, 0x6010, 0x2004,
+	0xd0bc, 0x11f8, 0xd1cc, 0x0904, 0x8fa6, 0x6978, 0x6868, 0xd0fc,
+	0x0904, 0x8f69, 0x0016, 0x687c, 0x0006, 0x6880, 0x0006, 0x00f6,
+	0x2178, 0x7974, 0x9184, 0x00ff, 0x90b6, 0x0002, 0x0904, 0x8f3e,
+	0x9086, 0x0028, 0x15b8, 0x687b, 0x001c, 0x787b, 0x001c, 0x0804,
+	0x8f46, 0x6024, 0xd0f4, 0x11d0, 0x6838, 0x6a34, 0x9205, 0x09d0,
+	0x6838, 0x6a90, 0x9206, 0x1120, 0x688c, 0x6a34, 0x9206, 0x0990,
+	0x6024, 0xd0d4, 0x1148, 0x69ac, 0x6834, 0x9102, 0x603a, 0x69b0,
+	0x6838, 0x9103, 0x603e, 0x6024, 0xc0f5, 0x6026, 0x6010, 0x00d6,
+	0x2068, 0x683c, 0x8000, 0x683e, 0x00de, 0x687c, 0xc0e4, 0x687e,
+	0x6877, 0x0000, 0x6893, 0x0000, 0x688f, 0x0000, 0x080c, 0x98aa,
+	0x0804, 0x8fd7, 0xd1dc, 0x0158, 0x687b, 0x0015, 0x787b, 0x0015,
+	0x080c, 0x9a64, 0x0118, 0x7974, 0xc1dc, 0x7976, 0x0078, 0xd1d4,
+	0x0128, 0x687b, 0x0007, 0x787b, 0x0007, 0x0040, 0x687c, 0xd0ac,
+	0x0128, 0x6834, 0x6938, 0x9115, 0x190c, 0x8dfb, 0x6878, 0x787a,
+	0x6890, 0x7892, 0x688c, 0x788e, 0x9d90, 0x0019, 0x9f98, 0x0019,
+	0x2009, 0x0020, 0x0156, 0x21a8, 0x2304, 0x2012, 0x8318, 0x8210,
+	0x1f04, 0x8f54, 0x015e, 0x00fe, 0x000e, 0x6882, 0x000e, 0x687e,
+	0x001e, 0x6874, 0x0006, 0x2168, 0x080c, 0x0e06, 0x001e, 0x0804,
+	0x8fd3, 0x0016, 0x00f6, 0x2178, 0x7974, 0x9184, 0x00ff, 0x90b6,
+	0x0002, 0x01e0, 0x9086, 0x0028, 0x1128, 0x687b, 0x001c, 0x787b,
+	0x001c, 0x00e0, 0xd1dc, 0x0158, 0x687b, 0x0015, 0x787b, 0x0015,
+	0x080c, 0x9a64, 0x0118, 0x7974, 0xc1dc, 0x7976, 0x0078, 0xd1d4,
+	0x0128, 0x687b, 0x0007, 0x787b, 0x0007, 0x0040, 0x687c, 0xd0ac,
+	0x0128, 0x6834, 0x6938, 0x9115, 0x190c, 0x8dfb, 0x6890, 0x7892,
+	0x688c, 0x788e, 0x687c, 0x787e, 0x00fe, 0x080c, 0x0e06, 0x00de,
+	0x6974, 0x0016, 0x080c, 0x926a, 0x001e, 0x0468, 0x6867, 0x0103,
+	0x6974, 0x9184, 0x00ff, 0x90b6, 0x0002, 0x01b0, 0x9086, 0x0028,
+	0x1118, 0x687b, 0x001c, 0x00d0, 0xd1dc, 0x0148, 0x687b, 0x0015,
+	0x080c, 0x9a64, 0x0118, 0x6974, 0xc1dc, 0x6976, 0x0078, 0xd1d4,
+	0x0118, 0x687b, 0x0007, 0x0050, 0x687b, 0x0000, 0x687c, 0xd0ac,
+	0x0128, 0x6834, 0x6938, 0x9115, 0x190c, 0x8dfb, 0x6974, 0x0016,
+	0x080c, 0x4ed6, 0x001e, 0xd1e4, 0x1120, 0x080c, 0x7f1e, 0x00de,
+	0x0005, 0x080c, 0x987a, 0x0cd8, 0x0005, 0x080c, 0x6c56, 0x0010,
+	0x080c, 0x6cf2, 0x080c, 0x95d2, 0x01c0, 0x00d6, 0x6114, 0x2168,
+	0x6867, 0x0103, 0x2009, 0x110c, 0x210c, 0xd18c, 0x11c0, 0xd184,
+	0x1198, 0x6108, 0x697a, 0x918e, 0x0029, 0x1110, 0x080c, 0xad5f,
+	0x6877, 0x0000, 0x080c, 0x50a5, 0x00de, 0x080c, 0x7f1e, 0x080c,
+	0x6d42, 0x080c, 0x6e10, 0x0005, 0x687b, 0x0004, 0x0c88, 0x687b,
+	0x0004, 0x0c70, 0x9182, 0x0040, 0x0002, 0x9020, 0x9020, 0x9020,
+	0x9020, 0x9020, 0x9022, 0x9020, 0x9025, 0x9020, 0x9020, 0x9020,
+	0x9020, 0x9020, 0x9020, 0x9020, 0x9020, 0x9020, 0x9020, 0x9020,
+	0x080c, 0x0cf1, 0x080c, 0x7f1e, 0x0005, 0x0006, 0x0026, 0x9016,
+	0x080c, 0x119a, 0x002e, 0x000e, 0x0005, 0x9182, 0x0085, 0x0002,
+	0x903d, 0x903b, 0x903b, 0x9049, 0x903b, 0x903b, 0x903b, 0x903b,
+	0x903b, 0x903b, 0x903b, 0x080c, 0x0cf1, 0x6003, 0x0001, 0x6106,
+	0x080c, 0x6886, 0x0126, 0x2091, 0x8000, 0x080c, 0x6d42, 0x012e,
+	0x0005, 0x0026, 0x0056, 0x00d6, 0x00e6, 0x2071, 0x0260, 0x7224,
+	0x6216, 0x7220, 0x080c, 0x95c2, 0x01a0, 0x2268, 0x6800, 0x9086,
+	0x0000, 0x0178, 0x6010, 0x6d10, 0x952e, 0x1158, 0x00c6, 0x2d60,
+	0x080c, 0x9297, 0x00ce, 0x0128, 0x6803, 0x0002, 0x6007, 0x0086,
+	0x0010, 0x6007, 0x0087, 0x6003, 0x0001, 0x080c, 0x6886, 0x080c,
+	0x6d42, 0x9280, 0x0004, 0x2004, 0xd0bc, 0x0150, 0x6824, 0xd0ec,
+	0x0138, 0x00c6, 0x2260, 0x6043, 0x0000, 0x080c, 0x98aa, 0x00ce,
+	0x00ee, 0x00de, 0x005e, 0x002e, 0x0005, 0x9186, 0x0013, 0x1160,
+	0x6004, 0x908a, 0x0085, 0x0a0c, 0x0cf1, 0x908a, 0x0090, 0x1a0c,
+	0x0cf1, 0x9082, 0x0085, 0x0072, 0x9186, 0x0027, 0x0120, 0x9186,
+	0x0014, 0x190c, 0x0cf1, 0x080c, 0x6c56, 0x080c, 0x97a3, 0x080c,
+	0x6d42, 0x0005, 0x90ad, 0x90af, 0x90af, 0x90ad, 0x90ad, 0x90ad,
+	0x90ad, 0x90ad, 0x90ad, 0x90ad, 0x90ad, 0x080c, 0x0cf1, 0x080c,
+	0x6c56, 0x080c, 0x97a3, 0x080c, 0x6d42, 0x0005, 0x9186, 0x0013,
+	0x1128, 0x6004, 0x9082, 0x0085, 0x2008, 0x04a8, 0x9186, 0x0027,
+	0x11e8, 0x080c, 0x6c56, 0x080c, 0x25ad, 0x00d6, 0x6014, 0x2068,
+	0x080c, 0x95d2, 0x0150, 0x6867, 0x0103, 0x6877, 0x0000, 0x687b,
+	0x0029, 0x080c, 0x50a5, 0x080c, 0x9797, 0x00de, 0x080c, 0x7f1e,
+	0x080c, 0x6d42, 0x0005, 0x080c, 0x7f68, 0x0ce0, 0x9186, 0x0014,
+	0x1dd0, 0x080c, 0x6c56, 0x00d6, 0x6014, 0x2068, 0x080c, 0x95d2,
+	0x0d60, 0x6867, 0x0103, 0x6877, 0x0000, 0x687b, 0x0006, 0x6880,
+	0xc0ec, 0x6882, 0x08f0, 0x0002, 0x9101, 0x90ff, 0x90ff, 0x90ff,
+	0x90ff, 0x90ff, 0x9119, 0x90ff, 0x90ff, 0x90ff, 0x90ff, 0x080c,
+	0x0cf1, 0x080c, 0x6c56, 0x6034, 0x908c, 0xff00, 0x810f, 0x9186,
+	0x0039, 0x0118, 0x9186, 0x0035, 0x1118, 0x2001, 0x12a6, 0x0010,
+	0x2001, 0x12a7, 0x2004, 0x601a, 0x6003, 0x000c, 0x080c, 0x6d42,
+	0x0005, 0x080c, 0x6c56, 0x6034, 0x908c, 0xff00, 0x810f, 0x9186,
+	0x0039, 0x0118, 0x9186, 0x0035, 0x1118, 0x2001, 0x12a6, 0x0010,
+	0x2001, 0x12a7, 0x2004, 0x601a, 0x6003, 0x000e, 0x080c, 0x6d42,
+	0x0005, 0x9182, 0x0090, 0x1220, 0x9182, 0x0085, 0x0208, 0x001a,
+	0x080c, 0x7f68, 0x0005, 0x9146, 0x9146, 0x9146, 0x9146, 0x9148,
+	0x919b, 0x9146, 0x9146, 0x9146, 0x9146, 0x9146, 0x080c, 0x0cf1,
+	0x00d6, 0x6010, 0x2004, 0xd0bc, 0x0168, 0x6034, 0x908c, 0xff00,
+	0x810f, 0x9186, 0x0039, 0x0118, 0x9186, 0x0035, 0x1118, 0x00de,
+	0x0804, 0x91ac, 0x080c, 0x9797, 0x080c, 0x95d2, 0x01c8, 0x6014,
+	0x2068, 0x6867, 0x0103, 0x6880, 0xd0b4, 0x0128, 0x687b, 0x0006,
+	0xc0ec, 0x6882, 0x0048, 0xd0bc, 0x0118, 0x687b, 0x0002, 0x0020,
+	0x687b, 0x0005, 0x080c, 0x9849, 0x6877, 0x0000, 0x080c, 0x50a5,
+	0x2c68, 0x080c, 0x7ec8, 0x01d0, 0x6003, 0x0001, 0x6007, 0x001e,
+	0x600b, 0xffff, 0x2009, 0x026e, 0x210c, 0x613a, 0x2009, 0x026f,
+	0x210c, 0x613e, 0x6910, 0x6112, 0x080c, 0x99cc, 0x6954, 0x6156,
+	0x6023, 0x0001, 0x080c, 0x6886, 0x080c, 0x6d42, 0x2d60, 0x080c,
+	0x7f1e, 0x00de, 0x0005, 0x6010, 0x2004, 0xd0bc, 0x0598, 0x6034,
+	0x908c, 0xff00, 0x810f, 0x9186, 0x0035, 0x0130, 0x9186, 0x001e,
+	0x0118, 0x9186, 0x0039, 0x1530, 0x00d6, 0x2c68, 0x080c, 0x9ac5,
+	0x1904, 0x91f1, 0x080c, 0x7ec8, 0x01d8, 0x6106, 0x6003, 0x0001,
+	0x6023, 0x0001, 0x6910, 0x6112, 0x692c, 0x612e, 0x6930, 0x6132,
+	0x6934, 0x918c, 0x00ff, 0x6136, 0x6938, 0x613a, 0x693c, 0x613e,
+	0x6954, 0x6156, 0x080c, 0x99cc, 0x080c, 0x6886, 0x080c, 0x6d42,
+	0x2d60, 0x00f8, 0x00d6, 0x6014, 0x2068, 0x080c, 0x95d2, 0x01c8,
+	0x6867, 0x0103, 0x6880, 0xd0b4, 0x0128, 0xc0ec, 0x6882, 0x687b,
+	0x0006, 0x0048, 0xd0bc, 0x0118, 0x687b, 0x0002, 0x0020, 0x687b,
+	0x0005, 0x080c, 0x9849, 0x6877, 0x0000, 0x080c, 0x50a5, 0x080c,
+	0x9797, 0x00de, 0x080c, 0x7f1e, 0x0005, 0x0016, 0x00d6, 0x6014,
+	0x2068, 0x080c, 0x95d2, 0x0140, 0x6867, 0x0103, 0x687b, 0x0028,
+	0x6877, 0x0000, 0x080c, 0x50a5, 0x00de, 0x001e, 0x9186, 0x0013,
+	0x0148, 0x9186, 0x0014, 0x0130, 0x9186, 0x0027, 0x0118, 0x080c,
+	0x7f68, 0x0030, 0x080c, 0x6c56, 0x080c, 0x97a3, 0x080c, 0x6d42,
+	0x0005, 0x0056, 0x0066, 0x00d6, 0x00f6, 0x2029, 0x0001, 0x9182,
+	0x0101, 0x1208, 0x0010, 0x2009, 0x0100, 0x2130, 0x8304, 0x9098,
+	0x0018, 0x2009, 0x0020, 0x9f90, 0x0029, 0x080c, 0x927a, 0x96b2,
+	0x0020, 0x7804, 0x906d, 0x0110, 0x080c, 0x0e06, 0x080c, 0x0ddf,
+	0x0520, 0x8528, 0x6867, 0x0110, 0x686b, 0x0000, 0x2d20, 0x7c06,
+	0x968a, 0x003d, 0x1228, 0x2608, 0x9d90, 0x001b, 0x0499, 0x00a8,
+	0x96b2, 0x003c, 0x2009, 0x003c, 0x2d78, 0x9d90, 0x001b, 0x0451,
+	0x0c28, 0x2079, 0x0200, 0x7817, 0x0000, 0x00fe, 0x852f, 0x95ad,
+	0x0003, 0x7d66, 0x95ac, 0x0000, 0x0048, 0x2079, 0x0200, 0x7817,
+	0x0000, 0x00fe, 0x852f, 0x95ad, 0x0003, 0x7d66, 0x00de, 0x006e,
+	0x005e, 0x0005, 0x00f6, 0x8dff, 0x0158, 0x6804, 0x907d, 0x0130,
+	0x6807, 0x0000, 0x080c, 0x50a5, 0x2f68, 0x0cb8, 0x080c, 0x50a5,
+	0x00fe, 0x0005, 0x00f6, 0x0156, 0x2079, 0x0200, 0x9184, 0x0001,
+	0x0108, 0x8108, 0x810c, 0x21a8, 0x2300, 0x9e00, 0x2004, 0x8007,
+	0x2012, 0x8318, 0x9386, 0x0020, 0x1120, 0x2018, 0x7814, 0x8000,
+	0x7816, 0x8210, 0x1f04, 0x9284, 0x015e, 0x00fe, 0x0005, 0x0066,
+	0x0126, 0x2091, 0x8000, 0x2031, 0x0001, 0x6020, 0x9084, 0x000f,
+	0x0083, 0x012e, 0x006e, 0x0005, 0x0126, 0x2091, 0x8000, 0x0066,
+	0x2031, 0x0000, 0x6020, 0x9084, 0x000f, 0x001b, 0x006e, 0x012e,
+	0x0005, 0x92d1, 0x92d1, 0x92cc, 0x92f3, 0x92bf, 0x92cc, 0x92f3,
+	0x92cc, 0x92bf, 0x92bf, 0x92cc, 0x92cc, 0x92cc, 0x92bf, 0x080c,
+	0x0cf1, 0x0036, 0x2019, 0x0010, 0x080c, 0xa6bc, 0x6023, 0x0006,
+	0x6003, 0x0007, 0x003e, 0x0005, 0x9006, 0x0005, 0x9085, 0x0001,
+	0x0005, 0x00d6, 0x86ff, 0x11d8, 0x6014, 0x2068, 0x080c, 0x95d2,
+	0x01c0, 0x6864, 0x9086, 0x0139, 0x1128, 0x687b, 0x0005, 0x6883,
+	0x0000, 0x0028, 0x900e, 0x2001, 0x0005, 0x080c, 0x52a0, 0x080c,
+	0x9849, 0x080c, 0x50a5, 0x080c, 0x7f1e, 0x9085, 0x0001, 0x00de,
+	0x0005, 0x9006, 0x0ce0, 0x6000, 0x908a, 0x0016, 0x1a0c, 0x0cf1,
+	0x000b, 0x0005, 0x930a, 0x932b, 0x930c, 0x934a, 0x9328, 0x930a,
+	0x92cc, 0x92d1, 0x92d1, 0x92cc, 0x92cc, 0x92cc, 0x92cc, 0x92cc,
+	0x92cc, 0x92cc, 0x080c, 0x0cf1, 0x86ff, 0x11b8, 0x6020, 0x9086,
+	0x0006, 0x0198, 0x00d6, 0x6014, 0x2068, 0x080c, 0x95d2, 0x0110,
+	0x080c, 0x9849, 0x00de, 0x6007, 0x0085, 0x6003, 0x000b, 0x6023,
+	0x0002, 0x080c, 0x6886, 0x080c, 0x6d42, 0x9085, 0x0001, 0x0005,
+	0x080c, 0x12c7, 0x0c08, 0x00e6, 0x2071, 0x12dc, 0x7024, 0x9c06,
+	0x1110, 0x080c, 0x78b3, 0x6020, 0x9084, 0x000f, 0x9086, 0x0006,
+	0x1150, 0x0086, 0x0096, 0x2049, 0x0001, 0x2c40, 0x080c, 0x7a48,
+	0x009e, 0x008e, 0x0010, 0x080c, 0x77d3, 0x00ee, 0x1928, 0x080c,
+	0x92cc, 0x0005, 0x0036, 0x00e6, 0x2071, 0x12dc, 0x703c, 0x9c06,
+	0x1140, 0x2019, 0x0000, 0x080c, 0x7936, 0x00ee, 0x003e, 0x0804,
+	0x930c, 0x080c, 0x7b66, 0x00ee, 0x003e, 0x1904, 0x930c, 0x080c,
+	0x92cc, 0x0005, 0x00c6, 0x6020, 0x9084, 0x000f, 0x0013, 0x00ce,
+	0x0005, 0x937e, 0x9402, 0x9530, 0x9389, 0x97a3, 0x937e, 0xa6ae,
+	0x7f1e, 0x9402, 0x9377, 0x959b, 0x9377, 0x9377, 0x9377, 0x080c,
+	0x0cf1, 0x080c, 0x97cd, 0x1110, 0x080c, 0x8576, 0x0005, 0x080c,
+	0x6c56, 0x080c, 0x6d42, 0x080c, 0x7f1e, 0x0005, 0x601b, 0x0001,
+	0x0005, 0x6014, 0x9080, 0x0025, 0x2c02, 0x6000, 0x908a, 0x0016,
+	0x1a0c, 0x0cf1, 0x000b, 0x0005, 0x93a4, 0x93a6, 0x93c6, 0x93d8,
+	0x93e5, 0x93a4, 0x937e, 0x937e, 0x937e, 0x93d8, 0x93d8, 0x93a4,
+	0x93a4, 0x93a4, 0x93a4, 0x93e2, 0x080c, 0x0cf1, 0x00e6, 0x6014,
+	0x2070, 0x7080, 0xc0b5, 0x7082, 0x2071, 0x12dc, 0x7024, 0x9c06,
+	0x0190, 0x080c, 0x77d3, 0x6007, 0x0085, 0x6003, 0x000b, 0x6023,
+	0x0002, 0x2001, 0x12a7, 0x2004, 0x601a, 0x080c, 0x6886, 0x080c,
+	0x6d42, 0x00ee, 0x0005, 0x601b, 0x0001, 0x0cd8, 0x00d6, 0x6014,
+	0x2068, 0x6880, 0xc0b5, 0x6882, 0x00de, 0x6007, 0x0085, 0x6003,
+	0x000b, 0x6023, 0x0002, 0x080c, 0x6886, 0x080c, 0x6d42, 0x0005,
+	0x00d6, 0x601b, 0x0001, 0x6014, 0x2068, 0x6880, 0xc0b5, 0x6882,
+	0x00de, 0x0005, 0x080c, 0x7f1e, 0x0005, 0x6014, 0x9005, 0x01b8,
+	0x9088, 0x001f, 0x210c, 0xd1e4, 0x0190, 0x9080, 0x0021, 0x2004,
+	0x601a, 0x2001, 0x0037, 0x2c08, 0x080c, 0x113b, 0x6000, 0x9086,
+	0x0004, 0x1120, 0x2009, 0x0048, 0x080c, 0x7f4e, 0x0005, 0x080c,
+	0x12c7, 0x0820, 0x6000, 0x908a, 0x0016, 0x1a0c, 0x0cf1, 0x000b,
+	0x0005, 0x9419, 0x9386, 0x941b, 0x9419, 0x941b, 0x941b, 0x937f,
+	0x9419, 0x9379, 0x9379, 0x9419, 0x9419, 0x9419, 0x9419, 0x9419,
+	0x9419, 0x080c, 0x0cf1, 0x6010, 0x00d6, 0x2068, 0x6804, 0x9084,
+	0x00ff, 0x00de, 0x908a, 0x000c, 0x1a0c, 0x0cf1, 0x000b, 0x0005,
+	0x9434, 0x94d6, 0x9436, 0x9470, 0x9436, 0x9470, 0x9436, 0x9440,
+	0x9434, 0x9470, 0x9434, 0x945c, 0x080c, 0x0cf1, 0x6004, 0x908e,
+	0x0016, 0x0588, 0x908e, 0x0004, 0x0570, 0x908e, 0x0002, 0x0558,
+	0x6004, 0x080c, 0x97cd, 0x0904, 0x94ef, 0x908e, 0x0021, 0x0904,
+	0x94f3, 0x908e, 0x0022, 0x0904, 0x94ef, 0x908e, 0x003d, 0x0904,
+	0x94f3, 0x908e, 0x0039, 0x0904, 0x94f7, 0x908e, 0x0035, 0x0904,
+	0x94f7, 0x908e, 0x001e, 0x0188, 0x908e, 0x0001, 0x1150, 0x6010,
+	0x00d6, 0x2068, 0x6804, 0x9084, 0x00ff, 0x00de, 0x9086, 0x0006,
+	0x0110, 0x080c, 0x25ad, 0x080c, 0x8576, 0x080c, 0x97a3, 0x0005,
+	0x00c6, 0x00d6, 0x6104, 0x9186, 0x0016, 0x0904, 0x94c7, 0x9186,
+	0x0002, 0x1518, 0x6010, 0x2068, 0x2001, 0x1133, 0x2004, 0xd0ac,
+	0x1904, 0x9519, 0x68a0, 0xd0bc, 0x1904, 0x9519, 0x6840, 0x9084,
+	0x00ff, 0x9005, 0x0190, 0x8001, 0x6842, 0x6017, 0x0000, 0x6023,
+	0x0007, 0x601b, 0x0398, 0x6043, 0x0000, 0x080c, 0x7ec8, 0x0128,
+	0x2d00, 0x6012, 0x6023, 0x0001, 0x0450, 0x00de, 0x00ce, 0x6004,
+	0x908e, 0x0002, 0x11a8, 0x6010, 0x9080, 0x0028, 0x2004, 0x9086,
+	0x007e, 0x1170, 0x2009, 0x1133, 0x2104, 0xc085, 0x200a, 0x00e6,
+	0x2071, 0x1100, 0x080c, 0x46bb, 0x00ee, 0x080c, 0x8576, 0x0020,
+	0x080c, 0x8576, 0x080c, 0x25ad, 0x00e6, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x25d1, 0x012e, 0x00ee, 0x080c, 0x97a3, 0x0005, 0x2001,
+	0x0002, 0x080c, 0x4ab3, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c,
+	0x68ce, 0x080c, 0x6d42, 0x00de, 0x00ce, 0x0c80, 0x00c6, 0x00d6,
+	0x6104, 0x9186, 0x0016, 0x0d58, 0x6010, 0x2068, 0x6840, 0x9084,
+	0x00ff, 0x9005, 0x0904, 0x949d, 0x8001, 0x6842, 0x6003, 0x0001,
+	0x080c, 0x68ce, 0x080c, 0x6d42, 0x00de, 0x00ce, 0x08b8, 0x080c,
+	0x8576, 0x0804, 0x946d, 0x080c, 0x85a4, 0x0804, 0x946d, 0x00d6,
+	0x2c68, 0x6104, 0x080c, 0x9ac5, 0x00de, 0x0118, 0x080c, 0x7f1e,
+	0x00b8, 0x6004, 0x8007, 0x6134, 0x918c, 0x00ff, 0x9105, 0x6036,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x6023, 0x0002, 0x603c, 0x600a,
+	0x2001, 0x12a7, 0x2004, 0x601a, 0x080c, 0x6886, 0x080c, 0x6d42,
+	0x0005, 0x00de, 0x00ce, 0x080c, 0x8576, 0x080c, 0x25ad, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x25d1, 0x6017, 0x0000, 0x6023,
+	0x0007, 0x601b, 0x0398, 0x6043, 0x0000, 0x012e, 0x00ee, 0x0005,
+	0x6000, 0x908a, 0x0016, 0x1a0c, 0x0cf1, 0x000b, 0x0005, 0x9547,
+	0x9547, 0x9547, 0x9547, 0x9547, 0x9547, 0x9547, 0x9547, 0x9547,
+	0x937e, 0x9547, 0x9386, 0x9549, 0x9386, 0x9556, 0x9547, 0x080c,
+	0x0cf1, 0x6004, 0x9086, 0x008b, 0x0148, 0x6007, 0x008b, 0x6003,
+	0x000d, 0x080c, 0x6886, 0x080c, 0x6d42, 0x0005, 0x080c, 0x9797,
+	0x080c, 0x95d2, 0x0580, 0x080c, 0x25ad, 0x00d6, 0x080c, 0x95d2,
+	0x0168, 0x6014, 0x2068, 0x6867, 0x0103, 0x687b, 0x0006, 0x6877,
+	0x0000, 0x6880, 0xc0ed, 0x6882, 0x080c, 0x50a5, 0x2c68, 0x080c,
+	0x7ec8, 0x0150, 0x6810, 0x6012, 0x080c, 0x99cc, 0x00c6, 0x2d60,
+	0x080c, 0x97a3, 0x00ce, 0x0008, 0x2d60, 0x00de, 0x6017, 0x0000,
+	0x6023, 0x0001, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x68ce,
+	0x080c, 0x6d42, 0x0078, 0x6034, 0x908c, 0xff00, 0x810f, 0x9186,
+	0x0039, 0x0118, 0x9186, 0x0035, 0x1118, 0x080c, 0x25ad, 0x08b0,
+	0x080c, 0x97a3, 0x0005, 0x6000, 0x908a, 0x0016, 0x1a0c, 0x0cf1,
+	0x000b, 0x0005, 0x95b2, 0x95b2, 0x95b2, 0x95b4, 0x95b5, 0x95b2,
+	0x95b2, 0x95b2, 0x95b2, 0x95b2, 0x95b2, 0x95b2, 0x95b2, 0x95b2,
+	0x95b2, 0x95b2, 0x080c, 0x0cf1, 0x0005, 0x080c, 0x7b66, 0x190c,
+	0x0cf1, 0x6114, 0x2168, 0x687b, 0x0006, 0x080c, 0x50a5, 0x080c,
+	0x7f1e, 0x0005, 0x9284, 0x0007, 0x1158, 0x9282, 0x15c0, 0x0240,
+	0x2001, 0x1116, 0x2004, 0x9202, 0x1218, 0x9085, 0x0001, 0x0005,
+	0x9006, 0x0ce8, 0x0026, 0x6214, 0x9294, 0xf000, 0x002e, 0x0005,
+	0x00e6, 0x00c6, 0x0036, 0x0006, 0x0126, 0x2091, 0x8000, 0x2061,
+	0x15c0, 0x2071, 0x1100, 0x7344, 0x7064, 0x9302, 0x12a8, 0x6020,
+	0x9206, 0x1160, 0x080c, 0x9946, 0x0148, 0x080c, 0x97cd, 0x1110,
+	0x080c, 0x8576, 0x00c6, 0x080c, 0x7f1e, 0x00ce, 0x9ce0, 0x0018,
+	0x7058, 0x9c02, 0x1208, 0x0c38, 0x012e, 0x000e, 0x003e, 0x00ce,
+	0x00ee, 0x0005, 0x00e6, 0x00c6, 0x0016, 0x9188, 0x1000, 0x210c,
+	0x81ff, 0x0170, 0x2061, 0x15c0, 0x2071, 0x1100, 0x0016, 0x080c,
+	0x7ec8, 0x001e, 0x0138, 0x6112, 0x080c, 0x25ad, 0x080c, 0x7f1e,
+	0x9006, 0x0010, 0x9085, 0x0001, 0x001e, 0x00ce, 0x00ee, 0x0005,
+	0x00c6, 0x0056, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x7ec8,
+	0x005e, 0x0180, 0x6616, 0x6512, 0x080c, 0x99cc, 0x6023, 0x0003,
+	0x2009, 0x004b, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x012e, 0x005e,
+	0x00ce, 0x0005, 0x9006, 0x0cd0, 0x00c6, 0x0056, 0x0126, 0x2091,
+	0x8000, 0x62a0, 0x00c6, 0x080c, 0x7ec8, 0x005e, 0x01f8, 0x6017,
+	0x0000, 0x6512, 0x080c, 0x99cc, 0x6023, 0x0003, 0x00c6, 0x2560,
+	0x00ce, 0x080c, 0x69ca, 0x0076, 0x2039, 0x0000, 0x080c, 0x68fe,
+	0x2c08, 0x080c, 0xa85f, 0x007e, 0x2009, 0x004c, 0x080c, 0x7f4e,
+	0x9085, 0x0001, 0x012e, 0x005e, 0x00ce, 0x0005, 0x9006, 0x0cd0,
+	0x00f6, 0x00c6, 0x0046, 0x00c6, 0x080c, 0x7ec8, 0x2c78, 0x00ce,
+	0x0180, 0x7e16, 0x2c00, 0x7812, 0x7823, 0x0003, 0x2021, 0x0005,
+	0x080c, 0x96bd, 0x2f60, 0x2009, 0x004d, 0x080c, 0x7f4e, 0x9085,
+	0x0001, 0x004e, 0x00ce, 0x00fe, 0x0005, 0x00f6, 0x00c6, 0x0046,
+	0x00c6, 0x080c, 0x7ec8, 0x2c78, 0x00ce, 0x0178, 0x7e16, 0x2c00,
+	0x7812, 0x7823, 0x0003, 0x2021, 0x0005, 0x0439, 0x2f60, 0x2009,
+	0x004e, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x004e, 0x00ce, 0x00fe,
+	0x0005, 0x00f6, 0x00c6, 0x0046, 0x00c6, 0x080c, 0x7ec8, 0x2c78,
+	0x00ce, 0x0178, 0x7e16, 0x2c00, 0x7812, 0x7823, 0x0003, 0x2021,
+	0x0004, 0x0059, 0x2f60, 0x2009, 0x0052, 0x080c, 0x7f4e, 0x9085,
+	0x0001, 0x004e, 0x00ce, 0x00fe, 0x0005, 0x0096, 0x0076, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x4c77, 0x0158, 0x2001, 0x96c2, 0x0006,
+	0x900e, 0x2400, 0x080c, 0x52a0, 0x080c, 0x50a5, 0x000e, 0x0807,
+	0x2418, 0x080c, 0x6bf8, 0x62a0, 0x0086, 0x2041, 0x0001, 0x2039,
+	0x0001, 0x2608, 0x080c, 0x69e3, 0x008e, 0x080c, 0x68fe, 0x2f08,
+	0x2648, 0x080c, 0xa85f, 0x613c, 0x81ff, 0x090c, 0x6a8c, 0x012e,
+	0x007e, 0x009e, 0x0005, 0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6,
+	0x080c, 0x7ec8, 0x001e, 0x0188, 0x660a, 0x6112, 0x080c, 0x99cc,
+	0x6023, 0x0001, 0x2d00, 0x6016, 0x2009, 0x001f, 0x080c, 0x7f4e,
+	0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x00c6,
+	0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x7ec8, 0x001e, 0x01b0,
+	0x660a, 0x6112, 0x080c, 0x99cc, 0x6023, 0x0008, 0x2d00, 0x6016,
+	0x00f6, 0x2c78, 0x080c, 0x119d, 0x00fe, 0x2009, 0x0021, 0x080c,
+	0x7f4e, 0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x7ec8, 0x001e,
+	0x0188, 0x660a, 0x6112, 0x080c, 0x99cc, 0x6023, 0x0001, 0x2d00,
+	0x6016, 0x2009, 0x003d, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x012e,
+	0x00ce, 0x0005, 0x9006, 0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000,
+	0x00c6, 0x080c, 0x984d, 0x001e, 0x0180, 0x6112, 0x080c, 0x99cc,
+	0x6023, 0x0001, 0x2d00, 0x6016, 0x2009, 0x0000, 0x080c, 0x7f4e,
+	0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x00c6,
+	0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x7ec8, 0x001e, 0x0188,
+	0x660a, 0x6112, 0x080c, 0x99cc, 0x6023, 0x0001, 0x2d00, 0x6016,
+	0x2009, 0x0044, 0x080c, 0x7f4e, 0x9085, 0x0001, 0x012e, 0x00ce,
+	0x0005, 0x9006, 0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6,
+	0x080c, 0x7ec8, 0x001e, 0x0188, 0x660a, 0x6112, 0x080c, 0x99cc,
+	0x6023, 0x0001, 0x2d00, 0x6016, 0x2009, 0x0049, 0x080c, 0x7f4e,
+	0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x0026,
+	0x00d6, 0x6210, 0x2268, 0x6a3c, 0x82ff, 0x0110, 0x8211, 0x6a3e,
+	0x00de, 0x002e, 0x0005, 0x0006, 0x6000, 0x9086, 0x0000, 0x0190,
+	0x6017, 0x0000, 0x6023, 0x0007, 0x2001, 0x12a6, 0x2004, 0x0006,
+	0x9082, 0x0051, 0x000e, 0x0208, 0x8004, 0x601a, 0x080c, 0xad19,
+	0x6043, 0x0000, 0x000e, 0x0005, 0x0006, 0x0016, 0x6004, 0x908e,
+	0x0002, 0x0140, 0x908e, 0x0003, 0x0128, 0x908e, 0x0004, 0x0110,
+	0x9085, 0x0001, 0x001e, 0x000e, 0x0005, 0x0006, 0x00d6, 0x6014,
+	0x906d, 0x0148, 0x6864, 0x9086, 0x0139, 0x0138, 0x6868, 0xd0fc,
+	0x0110, 0x9006, 0x0010, 0x9085, 0x0001, 0x00de, 0x000e, 0x0005,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x7ec8, 0x001e,
+	0x0190, 0x6112, 0x080c, 0x99cc, 0x6023, 0x0001, 0x2d00, 0x6016,
+	0x080c, 0x25ad, 0x2009, 0x0028, 0x080c, 0x7f4e, 0x9085, 0x0001,
+	0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x9186, 0x0015, 0x1188,
+	0x2011, 0x1120, 0x2204, 0x9086, 0x0074, 0x1158, 0x080c, 0x88ee,
+	0x6003, 0x0001, 0x6007, 0x0029, 0x080c, 0x68ce, 0x080c, 0x6d42,
+	0x0020, 0x080c, 0x8576, 0x080c, 0x7f1e, 0x0005, 0x9186, 0x0016,
+	0x1128, 0x2001, 0x0004, 0x080c, 0x4ab3, 0x00e8, 0x9186, 0x0015,
+	0x11e8, 0x2011, 0x1120, 0x2204, 0x9086, 0x0014, 0x11b8, 0x6010,
+	0x00d6, 0x2068, 0x080c, 0x4bf5, 0x00de, 0x080c, 0x89bf, 0x1170,
+	0x6010, 0x00d6, 0x2068, 0x6890, 0x00de, 0x9005, 0x0138, 0x2001,
+	0x0006, 0x080c, 0x4ab3, 0x080c, 0x80a0, 0x0020, 0x080c, 0x8576,
+	0x080c, 0x7f1e, 0x0005, 0x6878, 0x9086, 0x0005, 0x1108, 0x0009,
+	0x0005, 0x6880, 0xc0ad, 0x6882, 0x0005, 0x00e6, 0x0126, 0x2071,
+	0x1100, 0x2091, 0x8000, 0x7544, 0x9582, 0x0001, 0x0608, 0x7048,
+	0x2060, 0x6000, 0x9086, 0x0000, 0x0148, 0x9ce0, 0x0018, 0x7058,
+	0x9c02, 0x1208, 0x0cb0, 0x2061, 0x15c0, 0x0c98, 0x6003, 0x0008,
+	0x8529, 0x7546, 0x9ca8, 0x0018, 0x7058, 0x9502, 0x1230, 0x754a,
+	0x9085, 0x0001, 0x012e, 0x00ee, 0x0005, 0x704b, 0x15c0, 0x0cc0,
+	0x9006, 0x0cc0, 0x6043, 0x0000, 0x6017, 0x0000, 0x6003, 0x0001,
+	0x6007, 0x0050, 0x080c, 0x6886, 0x080c, 0x6d42, 0x0005, 0x00c6,
+	0x6010, 0x2004, 0xd0bc, 0x0120, 0x6020, 0x9084, 0x000f, 0x0013,
+	0x00ce, 0x0005, 0x937e, 0x98a2, 0x98a5, 0x98a8, 0xab09, 0xab24,
+	0xab27, 0x937e, 0x937e, 0x937e, 0x937e, 0x937e, 0x937e, 0x937e,
+	0x080c, 0x0cf1, 0xa001, 0xa001, 0x0005, 0xa001, 0xa001, 0x0005,
+	0x0009, 0x0005, 0x6010, 0x2004, 0xd0bc, 0x0550, 0x00f6, 0x2c78,
+	0x080c, 0x7ec8, 0x1128, 0x2001, 0x12a8, 0x2004, 0x7842, 0x00f8,
+	0x7810, 0x6012, 0x080c, 0x99cc, 0x7820, 0x9086, 0x0003, 0x0128,
+	0x7808, 0x603a, 0x2f00, 0x603e, 0x0020, 0x7808, 0x603e, 0x2f00,
+	0x603a, 0x602e, 0x6023, 0x0001, 0x6007, 0x0035, 0x6003, 0x0001,
+	0x7954, 0x6156, 0x080c, 0x6886, 0x080c, 0x6d42, 0x2f60, 0x00fe,
+	0x0005, 0x0016, 0x00f6, 0x6830, 0x6036, 0x908e, 0x0001, 0x0148,
+	0x6803, 0x0002, 0x9086, 0x0005, 0x0168, 0x9006, 0x602e, 0x6032,
+	0x00c8, 0x681c, 0xc085, 0x681e, 0x6803, 0x0004, 0x6824, 0xc0f4,
+	0xc0d5, 0x6826, 0x6814, 0x2078, 0x78ac, 0x6938, 0x9102, 0x78b0,
+	0x693c, 0x9103, 0x1e50, 0x683c, 0x602e, 0x6838, 0x9084, 0xfffc,
+	0x683a, 0x6032, 0x2d00, 0x603a, 0x6808, 0x603e, 0x6910, 0x6112,
+	0x6954, 0x6156, 0x6023, 0x0001, 0x6007, 0x0039, 0x6003, 0x0001,
+	0x080c, 0x6886, 0x080c, 0x6d42, 0x00fe, 0x001e, 0x0005, 0x6024,
+	0xd0d4, 0x0510, 0xd0f4, 0x11f8, 0x6038, 0x940a, 0x603c, 0x9303,
+	0x0230, 0x9105, 0x0120, 0x6024, 0xc0d4, 0xc0f5, 0x0098, 0x643a,
+	0x633e, 0x6c3e, 0x6b42, 0x0046, 0x0036, 0x2400, 0x6cac, 0x9402,
+	0x6836, 0x2300, 0x6bb0, 0x9303, 0x683a, 0x003e, 0x004e, 0x6024,
+	0xc0d4, 0x0000, 0x6026, 0x0005, 0xd0f4, 0x1138, 0x683c, 0x603a,
+	0x6840, 0x603e, 0x6024, 0xc0f5, 0x6026, 0x0005, 0x0006, 0x0016,
+	0x6004, 0x908e, 0x0034, 0x01b8, 0x908e, 0x0035, 0x01a0, 0x908e,
+	0x0036, 0x0188, 0x908e, 0x0037, 0x0170, 0x908e, 0x0038, 0x0158,
+	0x908e, 0x0039, 0x0140, 0x908e, 0x003a, 0x0128, 0x908e, 0x003b,
+	0x0110, 0x9085, 0x0001, 0x001e, 0x000e, 0x0005, 0x0006, 0x0016,
+	0x0026, 0x0036, 0x00e6, 0x2001, 0x12a2, 0x200c, 0x8000, 0x2014,
+	0x2001, 0x0032, 0x080c, 0x66ff, 0x2001, 0x12a6, 0x82ff, 0x1110,
+	0x2011, 0x0002, 0x2202, 0x2001, 0x12a4, 0x200c, 0x8000, 0x2014,
+	0x2071, 0x127f, 0x711a, 0x721e, 0x2001, 0x0064, 0x080c, 0x66ff,
+	0x2001, 0x12a7, 0x82ff, 0x1110, 0x2011, 0x0002, 0x2202, 0x2001,
+	0x12a8, 0x9288, 0x000a, 0x2102, 0x2001, 0x1340, 0x2102, 0x2001,
+	0x0032, 0x080c, 0x113b, 0x080c, 0x4df8, 0x00ee, 0x003e, 0x002e,
+	0x001e, 0x000e, 0x0005, 0x0006, 0x0016, 0x00e6, 0x2001, 0x12a6,
+	0x2003, 0x0028, 0x2001, 0x12a7, 0x2003, 0x0014, 0x2071, 0x127f,
+	0x701b, 0x0000, 0x701f, 0x07d0, 0x2001, 0x12a8, 0x2009, 0x001e,
+	0x2102, 0x2001, 0x1340, 0x2102, 0x2001, 0x0032, 0x080c, 0x113b,
+	0x00ee, 0x001e, 0x000e, 0x0005, 0x00d6, 0x6058, 0x906d, 0x0110,
+	0x080c, 0x0df6, 0x00de, 0x0005, 0x0005, 0x00c6, 0x0126, 0x2091,
+	0x8000, 0x00c6, 0x080c, 0x7ec8, 0x001e, 0x0178, 0x6112, 0x0ca1,
+	0x6023, 0x0001, 0x2d00, 0x6016, 0x2009, 0x0033, 0x080c, 0x7f4e,
+	0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x00d6,
+	0x00e6, 0x00f6, 0x2071, 0x1100, 0x9186, 0x0015, 0x1500, 0x7080,
+	0x9086, 0x0018, 0x11e0, 0x6014, 0x2068, 0x6a3c, 0xd2e4, 0x1160,
+	0x2c78, 0x080c, 0x6f1c, 0x01d8, 0x706c, 0x6a50, 0x9206, 0x1160,
+	0x7070, 0x6a54, 0x9206, 0x1140, 0x6210, 0x9290, 0x0028, 0x2214,
+	0x2009, 0x0000, 0x080c, 0x25f0, 0x080c, 0x80a0, 0x0020, 0x080c,
+	0x8576, 0x080c, 0x7f1e, 0x00fe, 0x00ee, 0x00de, 0x0005, 0x7050,
+	0x6a54, 0x9206, 0x0d48, 0x0c80, 0x00c6, 0x0126, 0x2091, 0x8000,
+	0x00c6, 0x080c, 0x7ec8, 0x001e, 0x0180, 0x6112, 0x080c, 0x99cc,
+	0x6023, 0x0001, 0x2d00, 0x6016, 0x2009, 0x0043, 0x080c, 0x7f4e,
+	0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x00d6,
+	0x00e6, 0x00f6, 0x2071, 0x1100, 0x9186, 0x0015, 0x11c0, 0x7080,
+	0x9086, 0x0004, 0x11a0, 0x6014, 0x90e8, 0x001b, 0x2c78, 0x080c,
+	0x6f1c, 0x01a8, 0x706c, 0x6a08, 0x9206, 0x1130, 0x7070, 0x6a0c,
+	0x9206, 0x1110, 0x080c, 0x25ad, 0x080c, 0x80a0, 0x0020, 0x080c,
+	0x8576, 0x080c, 0x7f1e, 0x00fe, 0x00ee, 0x00de, 0x0005, 0x7050,
+	0x6a0c, 0x9206, 0x0d78, 0x0c80, 0x0016, 0x0026, 0x687c, 0xd0ac,
+	0x0178, 0x6938, 0x6a34, 0x2100, 0x9205, 0x0150, 0x6890, 0x9106,
+	0x1118, 0x688c, 0x9206, 0x0120, 0x6992, 0x6a8e, 0x9085, 0x0001,
+	0x002e, 0x001e, 0x0005, 0x00d6, 0x0036, 0x6314, 0x2368, 0x687a,
+	0x6982, 0x929e, 0x4000, 0x1560, 0x6310, 0x00c6, 0x2360, 0x2009,
+	0x0000, 0x6868, 0xd0f4, 0x1140, 0x080c, 0x4d21, 0x1108, 0xc185,
+	0x6000, 0xd0bc, 0x0108, 0xc18d, 0x6a96, 0x699a, 0x20a9, 0x0004,
+	0x20e1, 0x0001, 0x20e9, 0x0001, 0x9d80, 0x0031, 0x20a0, 0x9c80,
+	0x0006, 0x2098, 0x080c, 0x4678, 0x20a9, 0x0004, 0x9d80, 0x0035,
+	0x20a0, 0x9c80, 0x000a, 0x2098, 0x080c, 0x4678, 0x00ce, 0x0080,
+	0x6a96, 0x3918, 0x9398, 0x0006, 0x231c, 0x689b, 0x0004, 0x6ba2,
+	0x6310, 0x00c6, 0x2360, 0x6004, 0x00ce, 0x9084, 0x00ff, 0x689e,
+	0x080c, 0x50a5, 0x003e, 0x00de, 0x0005, 0x00c6, 0x0026, 0x0016,
+	0x9186, 0x0035, 0x0110, 0x6a38, 0x0008, 0x6a2c, 0x080c, 0x95c2,
+	0x01f0, 0x2260, 0x6120, 0x9186, 0x0003, 0x0118, 0x9186, 0x0006,
+	0x1190, 0x6838, 0x9206, 0x0140, 0x683c, 0x9206, 0x1160, 0x6108,
+	0x6838, 0x9106, 0x1140, 0x0020, 0x6008, 0x693c, 0x9106, 0x1118,
+	0x6010, 0x6910, 0x9106, 0x001e, 0x002e, 0x00ce, 0x0005, 0x9085,
+	0x0001, 0x0cc8, 0x0066, 0x6000, 0x90b2, 0x0016, 0x1a0c, 0x0cf1,
+	0x0013, 0x006e, 0x0005, 0x9b0b, 0x9fed, 0xa14f, 0x9b0b, 0x9b0b,
+	0x9b0b, 0x9b0b, 0x9b0b, 0x9b42, 0xa1cd, 0x9b0b, 0x9b0b, 0x9b0b,
+	0x9b0b, 0x9b0b, 0x9b0b, 0x080c, 0x0cf1, 0x0066, 0x6000, 0x90b2,
+	0x0016, 0x1a0c, 0x0cf1, 0x0013, 0x006e, 0x0005, 0x9b26, 0xa64b,
+	0x9b26, 0x9b26, 0x9b26, 0x9b26, 0x9b26, 0x9b26, 0xa60b, 0xa69b,
+	0x9b26, 0xac51, 0xac85, 0xac51, 0xac85, 0x9b26, 0x080c, 0x0cf1,
+	0x6000, 0x9082, 0x0016, 0x1a0c, 0x0cf1, 0x6000, 0x000a, 0x0005,
+	0x9b40, 0xa307, 0xa3dc, 0xa3fe, 0xa4a6, 0x9b40, 0xa57d, 0xa528,
+	0xa1d9, 0xa5e1, 0xa5f6, 0x9b40, 0x9b40, 0x9b40, 0x9b40, 0x9b40,
+	0x080c, 0x0cf1, 0x91b2, 0x004c, 0x1a0c, 0x0cf1, 0x2100, 0x91b2,
+	0x0040, 0x1a04, 0x9f4e, 0x0002, 0x9b8c, 0x9d57, 0x9b8c, 0x9b8c,
+	0x9b8c, 0x9d60, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c,
+	0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c,
+	0x9b8c, 0x9b8c, 0x9b8c, 0x9b8e, 0x9bea, 0x9bf9, 0x9c47, 0x9c65,
+	0x9ce3, 0x9d42, 0x9b8c, 0x9b8c, 0x9d63, 0x9b8c, 0x9b8c, 0x9d78,
+	0x9d85, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9b8c, 0x9dfd, 0x9b8c,
+	0x9b8c, 0x9e0c, 0x9b8c, 0x9b8c, 0x9dd3, 0x9b8c, 0x9b8c, 0x9b8c,
+	0x9e24, 0x9b8c, 0x9b8c, 0x9b8c, 0x9ea0, 0x9b8c, 0x9b8c, 0x9b8c,
+	0x9b8c, 0x9b8c, 0x9b8c, 0x9f15, 0x080c, 0x0cf1, 0x080c, 0x4de0,
+	0x1150, 0x2001, 0x1133, 0x2004, 0xd0cc, 0x1128, 0x9084, 0x0009,
+	0x9086, 0x0008, 0x1140, 0x6007, 0x0009, 0x602f, 0x0009, 0x6017,
+	0x0000, 0x0804, 0x9d50, 0x080c, 0x4dd0, 0x00e6, 0x00c6, 0x0036,
+	0x0026, 0x0016, 0x6210, 0x2270, 0x72a0, 0x0026, 0x2019, 0x0029,
+	0x080c, 0x69ca, 0x0076, 0x2039, 0x0000, 0x080c, 0x68fe, 0x2c08,
+	0x080c, 0xa85f, 0x007e, 0x001e, 0x2e60, 0x001e, 0x002e, 0x003e,
+	0x00ce, 0x00ee, 0x6610, 0x00c6, 0x2660, 0x080c, 0x4b67, 0x00ce,
+	0x96b0, 0x0001, 0x2634, 0x9684, 0x00ff, 0x9082, 0x0006, 0x0278,
+	0x080c, 0xa7a3, 0x1904, 0x9c41, 0x080c, 0xa740, 0x1120, 0x6007,
+	0x0008, 0x0804, 0x9d50, 0x6007, 0x0009, 0x0804, 0x9d50, 0x080c,
+	0xa966, 0x0128, 0x080c, 0xa7a3, 0x0d78, 0x0804, 0x9c41, 0x6017,
+	0x1900, 0x0c88, 0x080c, 0x26bc, 0x1904, 0x9f4b, 0x6106, 0x080c,
+	0xa6fc, 0x6007, 0x0006, 0x0804, 0x9d50, 0x6007, 0x0007, 0x0804,
+	0x9d50, 0x080c, 0xacbf, 0x1904, 0x9f4b, 0x080c, 0x26bc, 0x1904,
+	0x9f4b, 0x00d6, 0x6610, 0x2668, 0x6e04, 0x9684, 0x00ff, 0x9082,
+	0x0006, 0x1220, 0x2001, 0x0001, 0x080c, 0x4aa1, 0x96b4, 0xff00,
+	0x8637, 0x9686, 0x0006, 0x0188, 0x9686, 0x0004, 0x0170, 0x6e04,
+	0x96b4, 0x00ff, 0x9686, 0x0006, 0x0140, 0x9686, 0x0004, 0x0128,
+	0x9686, 0x0005, 0x0110, 0x00de, 0x00e0, 0x080c, 0xa801, 0x11a0,
+	0x9686, 0x0006, 0x1150, 0x0026, 0x6210, 0x9290, 0x0028, 0x2214,
+	0x2009, 0x0000, 0x080c, 0x25f0, 0x002e, 0x080c, 0x4bf5, 0x6007,
+	0x000a, 0x00de, 0x0804, 0x9d50, 0x6007, 0x000b, 0x00de, 0x0804,
+	0x9d50, 0x080c, 0x25ad, 0x6007, 0x0001, 0x0804, 0x9d50, 0x080c,
+	0xacbf, 0x1904, 0x9f4b, 0x080c, 0x26bc, 0x1904, 0x9f4b, 0x6610,
+	0x00d6, 0x2668, 0x6e04, 0x00de, 0x9686, 0x0707, 0x0d50, 0x0026,
+	0x6210, 0x9290, 0x0028, 0x2214, 0x2009, 0x0000, 0x080c, 0x25f0,
+	0x002e, 0x6007, 0x000c, 0x0804, 0x9d50, 0x080c, 0x4de0, 0x1140,
+	0x2001, 0x1133, 0x2004, 0x9084, 0x0009, 0x9086, 0x0008, 0x1110,
+	0x0804, 0x9b9b, 0x080c, 0x4dd0, 0x6610, 0x96b0, 0x0001, 0x2634,
+	0x9684, 0x00ff, 0x9082, 0x0006, 0x06e8, 0x1138, 0x0026, 0x2001,
+	0x0006, 0x080c, 0x4ae0, 0x002e, 0x0050, 0x96b4, 0xff00, 0x8637,
+	0x9686, 0x0004, 0x0120, 0x9686, 0x0006, 0x1904, 0x9c41, 0x080c,
+	0xa80e, 0x1120, 0x6007, 0x000e, 0x0804, 0x9d50, 0x0046, 0x6410,
+	0x94a0, 0x0028, 0x2424, 0x94a4, 0x00ff, 0x8427, 0x0046, 0x080c,
+	0x25ad, 0x004e, 0x0016, 0x9006, 0x2009, 0x1153, 0x210c, 0xd1a4,
+	0x0158, 0x2009, 0x0029, 0x080c, 0xaaca, 0x6010, 0x00d6, 0x2068,
+	0x6800, 0xc0e5, 0x6802, 0x00de, 0x001e, 0x004e, 0x6007, 0x0001,
+	0x0804, 0x9d50, 0x2001, 0x0001, 0x080c, 0x4aa1, 0x0156, 0x0016,
+	0x0026, 0x0036, 0x20a9, 0x0004, 0x2019, 0x1105, 0x2011, 0x0270,
+	0x080c, 0x8a45, 0x003e, 0x002e, 0x001e, 0x015e, 0x9005, 0x0168,
+	0x96b4, 0xff00, 0x8637, 0x9682, 0x0004, 0x0a04, 0x9c41, 0x9682,
+	0x0007, 0x0a04, 0x9c8f, 0x0804, 0x9c41, 0x6017, 0x1900, 0x6007,
+	0x0009, 0x0804, 0x9d50, 0x080c, 0x4de0, 0x1140, 0x2001, 0x1133,
+	0x2004, 0x9084, 0x0009, 0x9086, 0x0008, 0x1110, 0x0804, 0x9b9b,
+	0x080c, 0x4dd0, 0x6610, 0x96b0, 0x0001, 0x2634, 0x9684, 0x00ff,
+	0x9082, 0x0006, 0x06b8, 0x96b4, 0xff00, 0x8637, 0x9686, 0x0004,
+	0x0120, 0x9686, 0x0006, 0x1904, 0x9c41, 0x080c, 0xa836, 0x1138,
+	0x080c, 0xa740, 0x1120, 0x6007, 0x0010, 0x0804, 0x9d50, 0x0046,
+	0x6410, 0x94a0, 0x0028, 0x2424, 0x94a4, 0x00ff, 0x8427, 0x0046,
+	0x080c, 0x25ad, 0x004e, 0x0016, 0x9006, 0x2009, 0x1153, 0x210c,
+	0xd1a4, 0x0158, 0x2009, 0x0029, 0x080c, 0xaaca, 0x6010, 0x00d6,
+	0x2068, 0x6800, 0xc0e5, 0x6802, 0x00de, 0x001e, 0x004e, 0x6007,
+	0x0001, 0x00f0, 0x080c, 0xa966, 0x0140, 0x96b4, 0xff00, 0x8637,
+	0x9686, 0x0006, 0x0950, 0x0804, 0x9c41, 0x6017, 0x1900, 0x6007,
+	0x0009, 0x0070, 0x080c, 0x26bc, 0x1904, 0x9f4b, 0x080c, 0xacbf,
+	0x1904, 0x9f4b, 0x080c, 0x9f86, 0x1904, 0x9c41, 0x6007, 0x0012,
+	0x6003, 0x0001, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x0005, 0x6007,
+	0x0001, 0x6003, 0x0001, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x0cb0,
+	0x6007, 0x0005, 0x0c68, 0x080c, 0xacbf, 0x1904, 0x9f4b, 0x080c,
+	0x26bc, 0x1904, 0x9f4b, 0x080c, 0x9f86, 0x1904, 0x9c41, 0x6007,
+	0x0020, 0x6003, 0x0001, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x0005,
+	0x080c, 0x26bc, 0x1904, 0x9f4b, 0x6007, 0x0023, 0x6003, 0x0001,
+	0x080c, 0x68ce, 0x080c, 0x6d42, 0x0005, 0x080c, 0xacbf, 0x1904,
+	0x9f4b, 0x080c, 0x26bc, 0x1904, 0x9f4b, 0x080c, 0x9f86, 0x1904,
+	0x9c41, 0x0016, 0x0026, 0x00e6, 0x2071, 0x0260, 0x7244, 0x9286,
+	0xffff, 0x0180, 0x2c08, 0x080c, 0x95c2, 0x01b0, 0x2260, 0x7240,
+	0x6008, 0x9206, 0x1188, 0x6010, 0x9190, 0x0004, 0x2214, 0x9206,
+	0x01b8, 0x0050, 0x7240, 0x2c08, 0x9006, 0x080c, 0xaa9c, 0x1180,
+	0x7244, 0x9286, 0xffff, 0x0190, 0x2160, 0x6007, 0x0026, 0x6017,
+	0x1700, 0x7214, 0x9296, 0xffff, 0x1160, 0x6007, 0x0025, 0x0048,
+	0x6020, 0x9086, 0x0007, 0x1d80, 0x080c, 0x7f1e, 0x2160, 0x6007,
+	0x0025, 0x6003, 0x0001, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x00ee,
+	0x002e, 0x001e, 0x0005, 0x2001, 0x0001, 0x080c, 0x4aa1, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x20a9, 0x0004, 0x2019, 0x1105, 0x2011,
+	0x0276, 0x080c, 0x8a45, 0x003e, 0x002e, 0x001e, 0x015e, 0x0120,
+	0x6007, 0x0031, 0x0804, 0x9d50, 0x080c, 0x8752, 0x080c, 0x5745,
+	0x1158, 0x0006, 0x0026, 0x0036, 0x080c, 0x5761, 0x0110, 0x080c,
+	0x571c, 0x003e, 0x002e, 0x000e, 0x0005, 0x080c, 0x26bc, 0x1904,
+	0x9f4b, 0x6106, 0x080c, 0x9fa2, 0x6007, 0x002b, 0x0804, 0x9d50,
+	0x6007, 0x002c, 0x0804, 0x9d50, 0x080c, 0xacbf, 0x1904, 0x9f4b,
+	0x080c, 0x26bc, 0x1904, 0x9f4b, 0x080c, 0x9f86, 0x1904, 0x9c41,
+	0x6106, 0x080c, 0x9fa6, 0x1120, 0x6007, 0x002e, 0x0804, 0x9d50,
+	0x6007, 0x002f, 0x0804, 0x9d50, 0x080c, 0x26bc, 0x1904, 0x9f4b,
+	0x00e6, 0x00d6, 0x00c6, 0x6010, 0x9080, 0x0001, 0x200c, 0x9184,
+	0x00ff, 0x9086, 0x0006, 0x0158, 0x9184, 0xff00, 0x8007, 0x9086,
+	0x0006, 0x0128, 0x00ce, 0x00de, 0x00ee, 0x0804, 0x9d57, 0x2001,
+	0x1172, 0x2004, 0xd0e4, 0x0904, 0x9e9d, 0x2071, 0x026c, 0x7010,
+	0x603a, 0x7014, 0x603e, 0x7108, 0x720c, 0x2001, 0x1153, 0x2004,
+	0xd0a4, 0x0140, 0x6010, 0x2068, 0x6810, 0x9106, 0x1118, 0x6814,
+	0x9206, 0x0508, 0x2001, 0x1153, 0x2004, 0xd0ac, 0x15a0, 0x2069,
+	0x1100, 0x6870, 0x9206, 0x1578, 0x686c, 0x9106, 0x1560, 0x7210,
+	0x080c, 0x95c2, 0x0568, 0x080c, 0xab36, 0x0550, 0x622e, 0x6007,
+	0x0036, 0x6003, 0x0001, 0x080c, 0x6886, 0x080c, 0x6d42, 0x00ce,
+	0x00de, 0x00ee, 0x0005, 0x7214, 0x9286, 0xffff, 0x0150, 0x080c,
+	0x95c2, 0x01b0, 0x9280, 0x0002, 0x2004, 0x7110, 0x9106, 0x1180,
+	0x08f8, 0x7210, 0x2c08, 0x9085, 0x0001, 0x080c, 0xaa9c, 0x2c10,
+	0x2160, 0x0130, 0x08a8, 0x6007, 0x0037, 0x6017, 0x1500, 0x08c8,
+	0x6007, 0x0037, 0x6017, 0x1700, 0x08a0, 0x6007, 0x0012, 0x0888,
+	0x080c, 0x26bc, 0x1904, 0x9f4b, 0x6010, 0x9080, 0x0001, 0x2004,
+	0x9084, 0xff00, 0x8007, 0x9086, 0x0006, 0x1904, 0x9d57, 0x00e6,
+	0x00d6, 0x00c6, 0x2001, 0x1172, 0x2004, 0xd0e4, 0x0904, 0x9f0d,
+	0x2069, 0x1100, 0x2071, 0x026c, 0x7008, 0x603a, 0x720c, 0x623e,
+	0x9286, 0xffff, 0x1150, 0x7208, 0x00c6, 0x2c08, 0x9085, 0x0001,
+	0x080c, 0xaa9c, 0x2c10, 0x00ce, 0x0598, 0x080c, 0x95c2, 0x0580,
+	0x00c6, 0x0026, 0x2260, 0x080c, 0x9297, 0x002e, 0x00ce, 0x7118,
+	0x918c, 0xff00, 0x810f, 0x9186, 0x0001, 0x0158, 0x9186, 0x0005,
+	0x0118, 0x9186, 0x0007, 0x1178, 0x9280, 0x0005, 0x2004, 0x9005,
+	0x0150, 0x0056, 0x7510, 0x7614, 0x080c, 0xab4f, 0x005e, 0x00ce,
+	0x00de, 0x00ee, 0x0005, 0x6007, 0x003b, 0x602f, 0x0009, 0x6017,
+	0x2a00, 0x6003, 0x0001, 0x080c, 0x6886, 0x080c, 0x6d42, 0x0c78,
+	0x6007, 0x003b, 0x602f, 0x0009, 0x6017, 0x1700, 0x6003, 0x0001,
+	0x080c, 0x6886, 0x080c, 0x6d42, 0x0c10, 0x6007, 0x003b, 0x602f,
+	0x000b, 0x6017, 0x0000, 0x0804, 0x9e71, 0x00e6, 0x0026, 0x080c,
+	0x4de0, 0x0558, 0x080c, 0x4dd0, 0x080c, 0xad2a, 0x1520, 0x2071,
+	0x1100, 0x70cc, 0xc085, 0x70ce, 0x00f6, 0x2079, 0x0100, 0x729c,
+	0x9284, 0x00ff, 0x706e, 0x78e6, 0x9284, 0xff00, 0x7270, 0x9205,
+	0x7072, 0x78ea, 0x00fe, 0x70d7, 0x0000, 0x2001, 0x1153, 0x2004,
+	0xd0a4, 0x0120, 0x2011, 0x12f5, 0x2013, 0x07d0, 0xd0ac, 0x1128,
+	0x080c, 0x23cd, 0x0010, 0x080c, 0xad56, 0x002e, 0x00ee, 0x080c,
+	0x7f1e, 0x0804, 0x9d56, 0x080c, 0x7f1e, 0x0005, 0x2600, 0x0002,
+	0x9f5b, 0x9f5b, 0x9f5b, 0x9f5b, 0x9f5b, 0x9f5d, 0x9f5b, 0x9f5b,
+	0x9f5b, 0x9f5b, 0x9f75, 0x080c, 0x0cf1, 0x080c, 0xacbf, 0x1d58,
+	0x080c, 0x26bc, 0x1d40, 0x0411, 0x1138, 0x6007, 0x0045, 0x6003,
+	0x0001, 0x080c, 0x68ce, 0x0005, 0x080c, 0x25ad, 0x6007, 0x0001,
+	0x6003, 0x0001, 0x080c, 0x68ce, 0x0005, 0x080c, 0xacbf, 0x1998,
+	0x080c, 0x26bc, 0x1980, 0x0051, 0x1d78, 0x703c, 0x6016, 0x6007,
+	0x004a, 0x6003, 0x0001, 0x080c, 0x68ce, 0x0005, 0x00d6, 0x0066,
+	0x6610, 0x2668, 0x6e04, 0x96b4, 0xff00, 0x8637, 0x9686, 0x0006,
+	0x0170, 0x9686, 0x0004, 0x0158, 0x6e04, 0x96b4, 0x00ff, 0x9686,
+	0x0006, 0x0128, 0x9686, 0x0004, 0x0110, 0x9085, 0x0001, 0x006e,
+	0x00de, 0x0005, 0x00d6, 0x0449, 0x00de, 0x0005, 0x00d6, 0x0491,
+	0x11f0, 0x680c, 0x908c, 0xff00, 0x6820, 0x9084, 0x00ff, 0x9115,
+	0x6216, 0x6824, 0x602e, 0xd1e4, 0x0118, 0x2009, 0x0001, 0x0060,
+	0xd1ec, 0x0168, 0x6920, 0x918c, 0x00ff, 0x6824, 0x080c, 0x1c69,
+	0x1130, 0x2110, 0x2009, 0x0000, 0x080c, 0x25f0, 0x0018, 0x9085,
+	0x0001, 0x0008, 0x9006, 0x00de, 0x0005, 0x2069, 0x026d, 0x6800,
+	0x9082, 0x0010, 0x1228, 0x6017, 0x0000, 0x9085, 0x0001, 0x0008,
+	0x9006, 0x0005, 0x6017, 0x0000, 0x2069, 0x026c, 0x6808, 0x9084,
+	0xff00, 0x9086, 0x0800, 0x1140, 0x6800, 0x9084, 0x00ff, 0x908e,
+	0x0014, 0x0110, 0x908e, 0x0010, 0x0005, 0x6004, 0x90b2, 0x004c,
+	0x1a0c, 0x0cf1, 0x91b6, 0x0013, 0x1130, 0x2008, 0x91b2, 0x0040,
+	0x1a04, 0xa11e, 0x0092, 0x91b6, 0x0027, 0x0120, 0x91b6, 0x0014,
+	0x190c, 0x0cf1, 0x2001, 0x0007, 0x080c, 0x4ae0, 0x080c, 0x6c56,
+	0x080c, 0x97a3, 0x080c, 0x6d42, 0x0005, 0xa04d, 0xa04f, 0xa04d,
+	0xa04d, 0xa04d, 0xa04f, 0xa061, 0xa117, 0xa0b9, 0xa117, 0xa0cd,
+	0xa117, 0xa061, 0xa117, 0xa10f, 0xa117, 0xa10f, 0xa117, 0xa117,
+	0xa04d, 0xa04d, 0xa04d, 0xa04d, 0xa04d, 0xa04d, 0xa04d, 0xa04d,
+	0xa04d, 0xa04d, 0xa04d, 0xa04f, 0xa04d, 0xa117, 0xa04d, 0xa04d,
+	0xa117, 0xa04d, 0xa114, 0xa117, 0xa04d, 0xa04d, 0xa04d, 0xa04d,
+	0xa117, 0xa117, 0xa04d, 0xa117, 0xa117, 0xa04d, 0xa05b, 0xa04d,
+	0xa04d, 0xa04d, 0xa04d, 0xa113, 0xa117, 0xa04d, 0xa04d, 0xa117,
+	0xa117, 0xa04d, 0xa04d, 0xa04d, 0xa04d, 0x080c, 0x0cf1, 0x080c,
+	0x6c56, 0x2001, 0x12a6, 0x2004, 0x601a, 0x6003, 0x0002, 0x080c,
+	0x6d42, 0x0804, 0xa11d, 0x2001, 0x0000, 0x080c, 0x4aa1, 0x0804,
+	0xa117, 0x00f6, 0x2079, 0x1152, 0x7804, 0x00fe, 0xd0ac, 0x1904,
+	0xa117, 0x2001, 0x0000, 0x080c, 0x4aa1, 0x6010, 0x9080, 0x0004,
+	0x2004, 0x9086, 0x00ff, 0x1140, 0x00f6, 0x2079, 0x1100, 0x7894,
+	0x8000, 0x7896, 0x00fe, 0x0418, 0x6010, 0x00c6, 0x2060, 0x6000,
+	0xd0f4, 0x1178, 0x6010, 0x9005, 0x0160, 0x0036, 0x0046, 0x63a0,
+	0x2021, 0x0007, 0x080c, 0x384a, 0x004e, 0x003e, 0x00ce, 0x0804,
+	0xa117, 0x00ce, 0x2001, 0x1100, 0x2004, 0x9086, 0x0002, 0x1138,
+	0x00f6, 0x2079, 0x1100, 0x7894, 0x8000, 0x7896, 0x00fe, 0x2001,
+	0x0002, 0x080c, 0x4ab3, 0x080c, 0x6c56, 0x6023, 0x0001, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x6110,
+	0x00c6, 0x2160, 0x2009, 0x0001, 0x080c, 0x6567, 0x00ce, 0x0804,
+	0xa11d, 0x6610, 0x00d6, 0x2668, 0x6e04, 0x00de, 0x96b4, 0xff00,
+	0x8637, 0x9686, 0x0006, 0x0904, 0xa117, 0x9686, 0x0004, 0x0904,
+	0xa117, 0x2001, 0x0004, 0x0804, 0xa115, 0x2001, 0x1100, 0x2004,
+	0x9086, 0x0003, 0x1160, 0x0036, 0x0046, 0x6010, 0x9080, 0x0028,
+	0x201c, 0x2021, 0x0006, 0x080c, 0x384a, 0x004e, 0x003e, 0x2001,
+	0x0006, 0x080c, 0xa134, 0x6610, 0x00d6, 0x2668, 0x6e04, 0x00de,
+	0x0066, 0x96b4, 0xff00, 0x8637, 0x9686, 0x0006, 0x006e, 0x0120,
+	0x2001, 0x0006, 0x080c, 0x4ae0, 0x2001, 0x1153, 0x2004, 0xd0ac,
+	0x11f0, 0x2001, 0x1133, 0x2004, 0xd0a4, 0x01c8, 0x96b4, 0x00ff,
+	0x9686, 0x0006, 0x01a0, 0x00f6, 0x2079, 0x1100, 0x7894, 0x8000,
+	0x7896, 0x00fe, 0x0804, 0xa09f, 0x2001, 0x0004, 0x0030, 0x2001,
+	0x0006, 0x0411, 0x0020, 0x0018, 0x0010, 0x080c, 0x4ae0, 0x080c,
+	0x6c56, 0x080c, 0x7f1e, 0x080c, 0x6d42, 0x0005, 0x2600, 0x0002,
+	0xa12b, 0xa12b, 0xa12b, 0xa12b, 0xa12b, 0xa12d, 0xa12b, 0xa12b,
+	0xa12b, 0xa12b, 0xa12d, 0x080c, 0x0cf1, 0x080c, 0x6c56, 0x080c,
+	0x7f1e, 0x080c, 0x6d42, 0x0005, 0x0016, 0x00d6, 0x6110, 0x2168,
+	0x6900, 0xd184, 0x0188, 0x6104, 0x918e, 0x000a, 0x1128, 0x699c,
+	0xd1a4, 0x1110, 0x2001, 0x0007, 0x080c, 0x4ab3, 0x2001, 0x0000,
+	0x080c, 0x4aa1, 0x080c, 0x25d1, 0x00de, 0x001e, 0x0005, 0x6610,
+	0x00d6, 0x2668, 0x6804, 0x9084, 0xff00, 0x8007, 0x00de, 0x90b2,
+	0x000c, 0x1a0c, 0x0cf1, 0x91b6, 0x0015, 0x1110, 0x003b, 0x0028,
+	0x91b6, 0x0016, 0x190c, 0x0cf1, 0x006b, 0x0005, 0x863b, 0x863b,
+	0x863b, 0x863b, 0x863b, 0x863b, 0xa1b7, 0xa17e, 0x863b, 0x863b,
+	0x863b, 0x863b, 0x863b, 0x863b, 0x863b, 0x863b, 0x863b, 0x863b,
+	0xa1b7, 0xa1be, 0x863b, 0x863b, 0x863b, 0x863b, 0x00f6, 0x2079,
+	0x1152, 0x7804, 0xd0ac, 0x11e0, 0x6010, 0x907d, 0x01c8, 0x7800,
+	0xd0f4, 0x1118, 0x7810, 0x9005, 0x1198, 0x2001, 0x0000, 0x080c,
+	0x4aa1, 0x2001, 0x0002, 0x080c, 0x4ab3, 0x6023, 0x0001, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x080c, 0x68ce, 0x080c, 0x6d42, 0x00a8,
+	0x2011, 0x0263, 0x2204, 0x8211, 0x220c, 0x080c, 0x1c69, 0x1168,
+	0x00c6, 0x080c, 0x4b58, 0x0120, 0x00ce, 0x080c, 0x7f1e, 0x0028,
+	0x080c, 0x472d, 0x00ce, 0x080c, 0x7f1e, 0x00fe, 0x0005, 0x6604,
+	0x96b6, 0x001e, 0x1110, 0x080c, 0x7f1e, 0x0005, 0x080c, 0x88eb,
+	0x1148, 0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x68ce, 0x080c,
+	0x6d42, 0x0010, 0x080c, 0x7f1e, 0x0005, 0x6004, 0x908a, 0x004c,
+	0x1a0c, 0x0cf1, 0x080c, 0x6c56, 0x080c, 0x97a3, 0x080c, 0x6d42,
+	0x0005, 0x9182, 0x0040, 0x0002, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef,
+	0xa1f1, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef,
+	0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef, 0xa1ef, 0x080c,
+	0x0cf1, 0x00d6, 0x00e6, 0x00f6, 0x0046, 0x0026, 0x6210, 0x9280,
+	0x002b, 0x2004, 0x9005, 0x1190, 0x6106, 0x2071, 0x0260, 0x7444,
+	0x94a4, 0xff00, 0x0904, 0xa256, 0x9486, 0x2000, 0x1160, 0x2009,
+	0x0001, 0x2011, 0x0200, 0x080c, 0x66d5, 0x0028, 0x2021, 0x0000,
+	0x080c, 0xacfb, 0x0c48, 0x080c, 0x0ddf, 0x090c, 0x0cf1, 0x6003,
+	0x0007, 0x2d00, 0x6867, 0x010d, 0x6803, 0x0000, 0x686b, 0x0000,
+	0x6c8a, 0x2c00, 0x688e, 0x6008, 0x68e2, 0x6010, 0x2078, 0x78a0,
+	0x8007, 0x7130, 0x697a, 0x0016, 0x9084, 0xff00, 0x6876, 0x687f,
+	0x0000, 0x6883, 0x0000, 0x6887, 0x0036, 0x080c, 0x50a5, 0x001e,
+	0x9486, 0x2000, 0x1130, 0x2019, 0x0017, 0x080c, 0xaa50, 0x0804,
+	0xa2a9, 0x9486, 0x0400, 0x1130, 0x2019, 0x0002, 0x080c, 0xaa02,
+	0x0804, 0xa2a9, 0x9486, 0x0200, 0x1110, 0x080c, 0xa9e7, 0x9486,
+	0x1000, 0x1110, 0x080c, 0xaa35, 0x0804, 0xa2a9, 0x2069, 0x1329,
+	0x6a00, 0xd284, 0x0904, 0xa303, 0x9284, 0x0300, 0x1904, 0xa2fc,
+	0x6804, 0x9005, 0x0904, 0xa2e4, 0x2d78, 0x6003, 0x0007, 0x080c,
+	0x0dc6, 0x0904, 0xa2b3, 0x7800, 0xd08c, 0x1118, 0x7804, 0x8001,
+	0x7806, 0x6017, 0x0000, 0x6803, 0x0000, 0x6867, 0x0116, 0x686b,
+	0x0000, 0x6008, 0x68e2, 0x2c00, 0x687a, 0x6010, 0x2078, 0x78a0,
+	0x8007, 0x7130, 0x69b6, 0x6876, 0x6883, 0x003d, 0x7044, 0x9084,
+	0x0003, 0x9080, 0xa2af, 0x2005, 0x687e, 0x20a9, 0x000a, 0x2001,
+	0x0270, 0x9d90, 0x0021, 0x2009, 0x0205, 0x200b, 0x0080, 0x20e1,
+	0x0000, 0x20e9, 0x0001, 0x2098, 0x22a0, 0x4003, 0x200b, 0x0000,
+	0x2001, 0x027a, 0x200c, 0x69b2, 0x8000, 0x200c, 0x69ae, 0x080c,
+	0x50a5, 0x002e, 0x004e, 0x00fe, 0x00ee, 0x00de, 0x0005, 0x0000,
+	0x0080, 0x0040, 0x0000, 0x6017, 0x0100, 0x6003, 0x0001, 0x6007,
+	0x0041, 0x080c, 0x6886, 0x080c, 0x6d42, 0x0c58, 0x2069, 0x0260,
+	0x6848, 0x9084, 0xff00, 0x9086, 0x1200, 0x1198, 0x686c, 0x9084,
+	0x00ff, 0x0016, 0x6114, 0x918c, 0x0700, 0x910d, 0x6116, 0x001e,
+	0x6003, 0x0001, 0x6007, 0x0043, 0x080c, 0x6886, 0x080c, 0x6d42,
+	0x0880, 0x6017, 0x0200, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c,
+	0x6886, 0x080c, 0x6d42, 0x0828, 0x2001, 0x110d, 0x2004, 0xd0ec,
+	0x0120, 0x2011, 0x8049, 0x080c, 0x37dc, 0x6017, 0x0300, 0x0010,
+	0x6017, 0x0100, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c, 0x6886,
+	0x080c, 0x6d42, 0x0804, 0xa2a9, 0x6017, 0x0500, 0x0c98, 0x6017,
+	0x0600, 0x0804, 0xa2be, 0x6017, 0x0200, 0x0804, 0xa2be, 0x9186,
+	0x0013, 0x1160, 0x6004, 0x908a, 0x0054, 0x1a0c, 0x0cf1, 0x9082,
+	0x0040, 0x0a0c, 0x0cf1, 0x2008, 0x0804, 0xa38f, 0x9186, 0x0051,
+	0x0138, 0x9186, 0x0047, 0x11d8, 0x6004, 0x9086, 0x0041, 0x0518,
+	0x2001, 0x0109, 0x2004, 0xd084, 0x01f0, 0x0126, 0x2091, 0x2800,
+	0x0006, 0x0016, 0x0026, 0x080c, 0x677e, 0x002e, 0x001e, 0x000e,
+	0x012e, 0x6000, 0x9086, 0x0002, 0x1170, 0x0804, 0xa3dc, 0x9186,
+	0x0027, 0x0120, 0x9186, 0x0014, 0x190c, 0x0cf1, 0x6004, 0x9082,
+	0x0040, 0x2008, 0x001a, 0x080c, 0x7f68, 0x0005, 0xa359, 0xa35b,
+	0xa35b, 0xa37f, 0xa359, 0xa359, 0xa359, 0xa359, 0xa359, 0xa359,
+	0xa359, 0xa359, 0xa359, 0xa359, 0xa359, 0xa359, 0xa359, 0xa359,
+	0xa359, 0x080c, 0x0cf1, 0x080c, 0x6c56, 0x080c, 0x6d42, 0x0036,
+	0x00d6, 0x6014, 0x906d, 0x01c0, 0x9d84, 0xf000, 0x01a8, 0x6003,
+	0x0002, 0x6010, 0x2004, 0xd0bc, 0x1178, 0x2019, 0x0004, 0x080c,
+	0xaa84, 0x6017, 0x0000, 0x6018, 0x9005, 0x1120, 0x2001, 0x12a7,
+	0x2004, 0x601a, 0x6003, 0x0007, 0x00de, 0x003e, 0x0005, 0x00d6,
+	0x080c, 0x6c56, 0x080c, 0x6d42, 0x080c, 0x95d2, 0x0120, 0x6014,
+	0x2068, 0x080c, 0x0df6, 0x080c, 0x97a3, 0x00de, 0x0005, 0x0002,
+	0xa3a3, 0xa3c0, 0xa3ac, 0xa3d6, 0xa3a3, 0xa3a3, 0xa3a3, 0xa3a3,
+	0xa3a3, 0xa3a3, 0xa3a3, 0xa3a3, 0xa3a3, 0xa3a3, 0xa3a3, 0xa3a3,
+	0xa3a3, 0xa3a3, 0xa3a3, 0x080c, 0x0cf1, 0x6014, 0x9088, 0x001f,
+	0x2104, 0x9085, 0x0400, 0x200a, 0x080c, 0x6c56, 0x6014, 0x9080,
+	0x001f, 0x2004, 0xd0b4, 0x0138, 0x6003, 0x0007, 0x2009, 0x0043,
+	0x080c, 0x7f4e, 0x0010, 0x6003, 0x0004, 0x080c, 0x6d42, 0x0005,
+	0x080c, 0x6c56, 0x6114, 0x9184, 0xf000, 0x0128, 0x9180, 0x001f,
+	0x200c, 0xd1ec, 0x1138, 0x080c, 0x66ae, 0x080c, 0x7f1e, 0x080c,
+	0x6d42, 0x0005, 0x080c, 0xacc6, 0x0db0, 0x0cc8, 0x080c, 0x6c56,
+	0x2009, 0x0041, 0x0804, 0xa528, 0x9182, 0x0040, 0x0002, 0xa3f2,
+	0xa3f4, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2,
+	0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2, 0xa3f2,
+	0xa3f5, 0xa3f2, 0x080c, 0x0cf1, 0x0005, 0x00d6, 0x080c, 0x66ae,
+	0x00de, 0x080c, 0xad19, 0x080c, 0x7f1e, 0x0005, 0x9182, 0x0040,
+	0x0002, 0xa414, 0xa414, 0xa414, 0xa414, 0xa414, 0xa414, 0xa414,
+	0xa416, 0xa414, 0xa419, 0xa471, 0xa414, 0xa414, 0xa414, 0xa414,
+	0xa471, 0xa414, 0xa414, 0xa414, 0x080c, 0x0cf1, 0x080c, 0x7f68,
+	0x0005, 0x2001, 0x0105, 0x2004, 0x9084, 0x1800, 0x1904, 0xa471,
+	0x2001, 0x1172, 0x2004, 0xd0e4, 0x1528, 0x603b, 0x0000, 0x080c,
+	0x6cf2, 0x6014, 0x00d6, 0x2068, 0x687c, 0xd0fc, 0x0188, 0x908c,
+	0x0003, 0x918e, 0x0002, 0x0508, 0x2001, 0x110c, 0x2004, 0xd0d4,
+	0x11e0, 0x080c, 0x6e07, 0x2009, 0x0041, 0x00de, 0x0804, 0xa528,
+	0x080c, 0x6e07, 0x6003, 0x0007, 0x601b, 0x0000, 0x080c, 0x66ae,
+	0x00de, 0x0005, 0x2001, 0x0100, 0x2004, 0x9082, 0x0005, 0x0aa8,
+	0x2001, 0x011f, 0x2004, 0x603a, 0x0890, 0x2001, 0x110c, 0x200c,
+	0xc1d4, 0x2102, 0xd1cc, 0x0110, 0x080c, 0x2069, 0x080c, 0x6e07,
+	0x6014, 0x9080, 0x001f, 0x200c, 0xd1ec, 0x1130, 0x080c, 0x66ae,
+	0x080c, 0x7f1e, 0x00de, 0x0005, 0x080c, 0xacc6, 0x0db8, 0x00de,
+	0x0005, 0x2001, 0x110c, 0x200c, 0xc1d4, 0x2102, 0x0036, 0x080c,
+	0x6cf2, 0x080c, 0x6e07, 0x6014, 0x00d6, 0x2068, 0x6010, 0x2004,
+	0xd0bc, 0x0188, 0x687c, 0x9084, 0x0003, 0x9086, 0x0002, 0x0140,
+	0x68ac, 0x6330, 0x931a, 0x6332, 0x68b0, 0x632c, 0x931b, 0x632e,
+	0x6003, 0x0002, 0x0080, 0x2019, 0x0004, 0x080c, 0xaa84, 0x6018,
+	0x9005, 0x1128, 0x2001, 0x12a7, 0x2004, 0x8003, 0x601a, 0x6017,
+	0x0000, 0x6003, 0x0007, 0x00de, 0x003e, 0x0005, 0x9182, 0x0040,
+	0x0002, 0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd,
+	0xa4bd, 0xa4bf, 0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd,
+	0xa4bd, 0xa4bd, 0xa4bd, 0xa4bd, 0xa504, 0x080c, 0x0cf1, 0x6014,
+	0x00d6, 0x2068, 0x6834, 0x6a38, 0x6110, 0x210c, 0xd1bc, 0x1190,
+	0x920d, 0x1518, 0x687c, 0xd0fc, 0x0128, 0x2009, 0x0041, 0x00de,
+	0x0804, 0xa528, 0x6003, 0x0007, 0x601b, 0x0000, 0x080c, 0x66ae,
+	0x00de, 0x0005, 0x6124, 0xd1f4, 0x1d58, 0x0006, 0x0046, 0x6cac,
+	0x9422, 0x69b0, 0x2200, 0x910b, 0x6030, 0x9420, 0x6432, 0x602c,
+	0x9109, 0x612e, 0x004e, 0x000e, 0x08d8, 0x6110, 0x210c, 0xd1bc,
+	0x1178, 0x2009, 0x110d, 0x210c, 0xd19c, 0x0118, 0x6003, 0x0007,
+	0x0010, 0x6003, 0x0006, 0x00e9, 0x080c, 0x66b0, 0x00de, 0x0005,
+	0x6003, 0x0002, 0x00de, 0x0005, 0x6024, 0xd0f4, 0x0128, 0x080c,
+	0x1132, 0x1904, 0xa4bf, 0x0005, 0x00d6, 0x6014, 0x2068, 0x6834,
+	0x6938, 0x00de, 0x9105, 0x1120, 0x080c, 0x1132, 0x1904, 0xa4bf,
+	0x0005, 0xd2fc, 0x0140, 0x8002, 0x8000, 0x8212, 0x9291, 0x0000,
+	0x2009, 0x0009, 0x0010, 0x2009, 0x0015, 0x6a9a, 0x6896, 0x0005,
+	0x9182, 0x0040, 0x0208, 0x0062, 0x9186, 0x0013, 0x0120, 0x9186,
+	0x0014, 0x190c, 0x0cf1, 0x6024, 0xd0dc, 0x090c, 0x0cf1, 0x0005,
+	0xa54b, 0xa552, 0xa55e, 0xa56a, 0xa54b, 0xa54b, 0xa54b, 0xa579,
+	0xa54b, 0xa54d, 0xa54d, 0xa54b, 0xa54b, 0xa54b, 0xa54b, 0xa54d,
+	0xa54b, 0xa54d, 0xa54b, 0x080c, 0x0cf1, 0x6024, 0xd0dc, 0x090c,
+	0x0cf1, 0x0005, 0x6003, 0x0001, 0x6106, 0x080c, 0x6886, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x6d42, 0x012e, 0x0005, 0x6003, 0x0001,
+	0x6106, 0x080c, 0x6886, 0x0126, 0x2091, 0x8000, 0x080c, 0x6d42,
+	0x012e, 0x0005, 0x6003, 0x0003, 0x6106, 0x2c10, 0x080c, 0x13a9,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x68eb, 0x080c, 0x6e10, 0x012e,
+	0x0005, 0x9016, 0x080c, 0x119a, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x0036, 0x00d6, 0x9182, 0x0040, 0x0023, 0x00de, 0x003e, 0x012e,
+	0x0005, 0xa599, 0xa59b, 0xa5ad, 0xa5c8, 0xa599, 0xa599, 0xa599,
+	0xa5dd, 0xa599, 0xa599, 0xa599, 0xa599, 0xa599, 0xa599, 0xa599,
+	0xa599, 0x080c, 0x0cf1, 0x6014, 0x2068, 0x687c, 0xd0fc, 0x01f8,
+	0x909c, 0x0003, 0x939e, 0x0003, 0x01d0, 0x6003, 0x0001, 0x6106,
+	0x080c, 0x6886, 0x080c, 0x6d42, 0x0498, 0x6014, 0x2068, 0x687c,
+	0xd0fc, 0x0168, 0x909c, 0x0003, 0x939e, 0x0003, 0x0140, 0x6003,
+	0x0001, 0x6106, 0x080c, 0x6886, 0x080c, 0x6d42, 0x0408, 0x6017,
+	0x0000, 0x601b, 0x0000, 0x2019, 0x0004, 0x080c, 0xaa84, 0x00c0,
+	0x6014, 0x2068, 0x687c, 0xd0fc, 0x0d90, 0x909c, 0x0003, 0x939e,
+	0x0003, 0x0d68, 0x6003, 0x0003, 0x6106, 0x2c10, 0x080c, 0x13a9,
+	0x080c, 0x68eb, 0x080c, 0x6e10, 0x0018, 0x9016, 0x080c, 0x119a,
+	0x0005, 0x080c, 0x6c56, 0x6114, 0x81ff, 0x0158, 0x00d6, 0x2168,
+	0x080c, 0xad5f, 0x0036, 0x2019, 0x0029, 0x080c, 0xaa84, 0x003e,
+	0x00de, 0x080c, 0x97a3, 0x080c, 0x6d42, 0x0005, 0x080c, 0x6cf2,
+	0x6114, 0x81ff, 0x0158, 0x00d6, 0x2168, 0x080c, 0xad5f, 0x0036,
+	0x2019, 0x0029, 0x080c, 0xaa84, 0x003e, 0x00de, 0x080c, 0x97a3,
+	0x080c, 0x6e10, 0x0005, 0x9182, 0x0085, 0x0002, 0xa61b, 0xa619,
+	0xa619, 0xa627, 0xa619, 0xa619, 0xa619, 0xa619, 0xa619, 0xa619,
+	0xa619, 0x080c, 0x0cf1, 0x6003, 0x000b, 0x6106, 0x080c, 0x6886,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x6d42, 0x012e, 0x0005, 0x0026,
+	0x00e6, 0x080c, 0xacbf, 0x0118, 0x080c, 0x7f1e, 0x00c8, 0x2071,
+	0x0260, 0x7224, 0x6216, 0x7220, 0x080c, 0xa91c, 0x0118, 0x6007,
+	0x0086, 0x0040, 0x6007, 0x0087, 0x7224, 0x9296, 0xffff, 0x1110,
+	0x6007, 0x0086, 0x6003, 0x0001, 0x080c, 0x6886, 0x080c, 0x6d42,
+	0x00ee, 0x002e, 0x0005, 0x9186, 0x0013, 0x1160, 0x6004, 0x908a,
+	0x0085, 0x0a0c, 0x0cf1, 0x908a, 0x0090, 0x1a0c, 0x0cf1, 0x9082,
+	0x0085, 0x00a2, 0x9186, 0x0027, 0x0130, 0x9186, 0x0014, 0x0118,
+	0x080c, 0x7f68, 0x0050, 0x2001, 0x0007, 0x080c, 0x4ae0, 0x080c,
+	0x6c56, 0x080c, 0x97a3, 0x080c, 0x6d42, 0x0005, 0xa679, 0xa67b,
+	0xa67b, 0xa679, 0xa679, 0xa679, 0xa679, 0xa679, 0xa679, 0xa679,
+	0xa679, 0x080c, 0x0cf1, 0x080c, 0x6c56, 0x080c, 0x97a3, 0x080c,
+	0x6d42, 0x0005, 0x9182, 0x0085, 0x0a0c, 0x0cf1, 0x9182, 0x0090,
+	0x1a0c, 0x0cf1, 0x9182, 0x0085, 0x0002, 0xa698, 0xa698, 0xa698,
+	0xa69a, 0xa698, 0xa698, 0xa698, 0xa698, 0xa698, 0xa698, 0xa698,
+	0x080c, 0x0cf1, 0x0005, 0x9186, 0x0013, 0x0148, 0x9186, 0x0014,
+	0x0130, 0x9186, 0x0027, 0x0118, 0x080c, 0x7f68, 0x0030, 0x080c,
+	0x6c56, 0x080c, 0x97a3, 0x080c, 0x6d42, 0x0005, 0x0036, 0x080c,
+	0xad19, 0x6043, 0x0000, 0x2019, 0x000b, 0x0031, 0x6023, 0x0006,
+	0x6003, 0x0007, 0x003e, 0x0005, 0x0126, 0x0036, 0x2091, 0x8000,
+	0x0086, 0x2c40, 0x0096, 0x2049, 0x0000, 0x080c, 0x7a48, 0x009e,
+	0x008e, 0x1578, 0x0076, 0x2c38, 0x080c, 0x7ae2, 0x007e, 0x1548,
+	0x6000, 0x9086, 0x0000, 0x0528, 0x6020, 0x9086, 0x0007, 0x0508,
+	0x00d6, 0x6000, 0x9086, 0x0004, 0x1150, 0x080c, 0xad19, 0x6023,
+	0x0007, 0x2001, 0x12a6, 0x2004, 0x601a, 0x080c, 0x12c7, 0x6014,
+	0x2068, 0x080c, 0x95d2, 0x0110, 0x080c, 0xaa84, 0x00de, 0x6017,
+	0x0000, 0x080c, 0xad19, 0x6023, 0x0007, 0x2001, 0x12a6, 0x2004,
+	0x601a, 0x003e, 0x012e, 0x0005, 0x00f6, 0x00c6, 0x0036, 0x0156,
+	0x2079, 0x0260, 0x7938, 0x783c, 0x080c, 0x1c69, 0x15a0, 0x0016,
+	0x00c6, 0x080c, 0x4b58, 0x1568, 0x001e, 0x002e, 0x0026, 0x0016,
+	0x2019, 0x0029, 0x080c, 0x7ba2, 0x080c, 0x69ca, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x68fe, 0x007e, 0x001e, 0x0076, 0x2039, 0x0000,
+	0x080c, 0xa85f, 0x007e, 0x0026, 0x6204, 0x9294, 0xff00, 0x8217,
+	0x9286, 0x0006, 0x0118, 0x9286, 0x0004, 0x1118, 0x62a0, 0x080c,
+	0x2661, 0x002e, 0x001e, 0x080c, 0x472d, 0x6612, 0x6516, 0x9006,
+	0x0010, 0x00ce, 0x001e, 0x015e, 0x003e, 0x00ce, 0x00fe, 0x0005,
+	0x00c6, 0x00d6, 0x00e6, 0x0016, 0x2009, 0x1120, 0x2104, 0x9086,
+	0x0074, 0x1904, 0xa798, 0x2069, 0x0260, 0x6944, 0x9182, 0x0100,
+	0x06d8, 0x6940, 0x9184, 0x8000, 0x0904, 0xa795, 0x2001, 0x128f,
+	0x2004, 0x9005, 0x1160, 0x6010, 0x2070, 0x7010, 0x9084, 0x00ff,
+	0x0118, 0x7000, 0xd0f4, 0x0118, 0x9184, 0x0800, 0x0570, 0x6948,
+	0x918a, 0x0001, 0x0620, 0x694c, 0x2009, 0x0205, 0x200b, 0x0001,
+	0x693c, 0x81ff, 0x1198, 0x6944, 0x9182, 0x0100, 0x02a8, 0x6940,
+	0x81ff, 0x1178, 0x6948, 0x918a, 0x0001, 0x0288, 0x6950, 0x918a,
+	0x0001, 0x0298, 0x00d0, 0x6017, 0x0100, 0x00a0, 0x6017, 0x0300,
+	0x0088, 0x6017, 0x0500, 0x0070, 0x6017, 0x0700, 0x0058, 0x6017,
+	0x0900, 0x0040, 0x6017, 0x0b00, 0x0028, 0x6017, 0x0f00, 0x0010,
+	0x6017, 0x2d00, 0x9085, 0x0001, 0x0008, 0x9006, 0x001e, 0x00ee,
+	0x00de, 0x00ce, 0x0005, 0x00c6, 0x00d6, 0x0026, 0x0036, 0x0156,
+	0x6210, 0x2268, 0x6b04, 0x9394, 0x00ff, 0x9286, 0x0006, 0x0190,
+	0x9286, 0x0004, 0x0178, 0x9394, 0xff00, 0x8217, 0x9286, 0x0006,
+	0x0148, 0x9286, 0x0004, 0x0130, 0x00c6, 0x2d60, 0x080c, 0x4b67,
+	0x00ce, 0x04c0, 0x2011, 0x0276, 0x20a9, 0x0004, 0x9d98, 0x000a,
+	0x080c, 0x8a45, 0x1580, 0x2011, 0x027a, 0x20a9, 0x0004, 0x9d98,
+	0x0006, 0x080c, 0x8a45, 0x1538, 0x0046, 0x0016, 0x6aa0, 0x9294,
+	0x00ff, 0x8227, 0x9006, 0x2009, 0x1153, 0x210c, 0xd1a4, 0x0138,
+	0x2009, 0x0029, 0x080c, 0xaaca, 0x6800, 0xc0e5, 0x6802, 0x2019,
+	0x0029, 0x080c, 0x69ca, 0x0076, 0x2039, 0x0000, 0x080c, 0x68fe,
+	0x2c08, 0x080c, 0xa85f, 0x007e, 0x2001, 0x0007, 0x080c, 0x4ae0,
+	0x001e, 0x004e, 0x9006, 0x015e, 0x003e, 0x002e, 0x00de, 0x00ce,
+	0x0005, 0x00d6, 0x2069, 0x026e, 0x6800, 0x9086, 0x0800, 0x0118,
+	0x6017, 0x0000, 0x0008, 0x9006, 0x00de, 0x0005, 0x00c6, 0x00f6,
+	0x0016, 0x0026, 0x0036, 0x0156, 0x2079, 0x026c, 0x7930, 0x7834,
+	0x080c, 0x1c69, 0x11a0, 0x080c, 0x4b58, 0x1188, 0x2011, 0x0270,
+	0x20a9, 0x0004, 0x9c98, 0x000a, 0x080c, 0x8a45, 0x1140, 0x2011,
+	0x0274, 0x20a9, 0x0004, 0x9c98, 0x0006, 0x080c, 0x8a45, 0x015e,
+	0x003e, 0x002e, 0x001e, 0x00fe, 0x00ce, 0x0005, 0x00c6, 0x0006,
+	0x0016, 0x0026, 0x0036, 0x0156, 0x2011, 0x0263, 0x2204, 0x8211,
+	0x220c, 0x080c, 0x1c69, 0x11a0, 0x080c, 0x4b58, 0x1188, 0x2011,
+	0x0276, 0x20a9, 0x0004, 0x9c98, 0x000a, 0x080c, 0x8a45, 0x1140,
+	0x2011, 0x027a, 0x20a9, 0x0004, 0x9c98, 0x0006, 0x080c, 0x8a45,
+	0x015e, 0x003e, 0x002e, 0x001e, 0x000e, 0x00ce, 0x0005, 0x00e6,
+	0x00c6, 0x0086, 0x0076, 0x0066, 0x0056, 0x0046, 0x0026, 0x0126,
+	0x2091, 0x8000, 0x2740, 0x2029, 0x12e5, 0x252c, 0x2021, 0x12eb,
+	0x2424, 0x2061, 0x15c0, 0x2071, 0x1100, 0x7644, 0x7064, 0x81ff,
+	0x0128, 0x8001, 0x9602, 0x1a04, 0xa8db, 0x0018, 0x9606, 0x0904,
+	0xa8db, 0x2100, 0x9c06, 0x0904, 0xa8d2, 0x080c, 0xaaf2, 0x0904,
+	0xa8d2, 0x6720, 0x9786, 0x0001, 0x0904, 0xa8f3, 0x9786, 0x0004,
+	0x0904, 0xa8f3, 0x9786, 0x0007, 0x05e8, 0x2500, 0x9c06, 0x05d0,
+	0x2400, 0x9c06, 0x05b8, 0x080c, 0xab02, 0x15a0, 0x88ff, 0x0118,
+	0x6054, 0x9906, 0x1578, 0x00d6, 0x6000, 0x9086, 0x0004, 0x1120,
+	0x0016, 0x080c, 0x12c7, 0x001e, 0x9786, 0x0008, 0x1148, 0x080c,
+	0x97cd, 0x1130, 0x080c, 0x8576, 0x00de, 0x080c, 0x97a3, 0x00d0,
+	0x6014, 0x2068, 0x080c, 0x95d2, 0x0190, 0x9786, 0x0003, 0x1528,
+	0x6867, 0x0103, 0x6b7a, 0x6877, 0x0000, 0x080c, 0xad5f, 0x0016,
+	0x080c, 0x9843, 0x080c, 0x50a5, 0x001e, 0x080c, 0x9797, 0x00de,
+	0x080c, 0x97a3, 0x9ce0, 0x0018, 0x2001, 0x1116, 0x2004, 0x9c02,
+	0x1210, 0x0804, 0xa873, 0x012e, 0x002e, 0x004e, 0x005e, 0x006e,
+	0x007e, 0x008e, 0x00ce, 0x00ee, 0x0005, 0x9786, 0x0006, 0x19c0,
+	0x9386, 0x0005, 0x0128, 0x080c, 0xad5f, 0x080c, 0xaa84, 0x08f8,
+	0x00de, 0x0c00, 0x0868, 0x080c, 0xab02, 0x19e0, 0x81ff, 0x09d0,
+	0x9180, 0x0001, 0x2004, 0x9086, 0x0018, 0x0130, 0x9180, 0x0001,
+	0x2004, 0x9086, 0x002d, 0x1970, 0x6000, 0x9086, 0x0002, 0x1950,
+	0x080c, 0x97bc, 0x0130, 0x080c, 0x97cd, 0x1920, 0x080c, 0x8576,
+	0x0038, 0x080c, 0x25d1, 0x080c, 0x97cd, 0x1110, 0x080c, 0x8576,
+	0x080c, 0x97a3, 0x0804, 0xa8d2, 0x00c6, 0x00e6, 0x0016, 0x2c08,
+	0x2170, 0x9006, 0x080c, 0xaa9c, 0x001e, 0x0120, 0x6020, 0x9084,
+	0x000f, 0x001b, 0x00ee, 0x00ce, 0x0005, 0xa93b, 0xa93b, 0xa93b,
+	0xa93b, 0xa93b, 0xa93b, 0xa93d, 0xa93b, 0xa93b, 0xa93b, 0xa93b,
+	0x97a3, 0x97a3, 0xa93b, 0x9006, 0x0005, 0x0046, 0x0016, 0x7010,
+	0x9080, 0x0028, 0x2024, 0x94a4, 0x00ff, 0x8427, 0x2c00, 0x2009,
+	0x0020, 0x080c, 0xaaca, 0x001e, 0x004e, 0x0036, 0x2019, 0x0002,
+	0x080c, 0xa6bc, 0x003e, 0x9085, 0x0001, 0x0005, 0x00d6, 0x6014,
+	0x906d, 0x9084, 0xf000, 0x0130, 0x080c, 0x92a4, 0x687b, 0x0005,
+	0x080c, 0x50a5, 0x00de, 0x080c, 0x97a3, 0x0005, 0x2001, 0x0001,
+	0x080c, 0x4aa1, 0x0156, 0x0016, 0x0026, 0x0036, 0x20a9, 0x0004,
+	0x2019, 0x1105, 0x2011, 0x0276, 0x080c, 0x8a45, 0x003e, 0x002e,
+	0x001e, 0x015e, 0x9005, 0x0005, 0x00f6, 0x00e6, 0x00c6, 0x0086,
+	0x0076, 0x0066, 0x0026, 0x0126, 0x2091, 0x8000, 0x2740, 0x2061,
+	0x15c0, 0x2079, 0x0001, 0x8fff, 0x0904, 0xa9da, 0x2071, 0x1100,
+	0x7644, 0x7064, 0x8001, 0x9602, 0x1a04, 0xa9da, 0x88ff, 0x0128,
+	0x2800, 0x9c06, 0x15b0, 0x2079, 0x0000, 0x080c, 0xaaf2, 0x0588,
+	0x2400, 0x9c06, 0x0570, 0x6720, 0x9786, 0x0006, 0x1550, 0x9786,
+	0x0007, 0x0538, 0x88ff, 0x1140, 0x6010, 0x9206, 0x1510, 0x85ff,
+	0x0118, 0x6054, 0x9106, 0x11e8, 0x00d6, 0x6000, 0x9086, 0x0004,
+	0x1150, 0x080c, 0xad19, 0x6023, 0x0007, 0x2001, 0x12a6, 0x2004,
+	0x601a, 0x080c, 0x12c7, 0x6014, 0x2068, 0x080c, 0x95d2, 0x0120,
+	0x0046, 0x080c, 0xaa84, 0x004e, 0x00de, 0x080c, 0x97a3, 0x88ff,
+	0x1198, 0x9ce0, 0x0018, 0x2001, 0x1116, 0x2004, 0x9c02, 0x1210,
+	0x0804, 0xa98b, 0x9006, 0x012e, 0x002e, 0x006e, 0x007e, 0x008e,
+	0x00ce, 0x00ee, 0x00fe, 0x0005, 0x98c5, 0x0001, 0x0ca0, 0x0076,
+	0x0056, 0x0086, 0x2041, 0x0000, 0x2029, 0x0001, 0x2c20, 0x2019,
+	0x0002, 0x6210, 0x0096, 0x2049, 0x0000, 0x080c, 0x7a48, 0x009e,
+	0x008e, 0x2039, 0x0000, 0x080c, 0x7ae2, 0x080c, 0xa97c, 0x005e,
+	0x007e, 0x0005, 0x0026, 0x0046, 0x0056, 0x0076, 0x00c6, 0x0156,
+	0x2c20, 0x2128, 0x20a9, 0x007f, 0x2009, 0x0000, 0x0016, 0x0036,
+	0x080c, 0x4b58, 0x11b0, 0x2c10, 0x0056, 0x0086, 0x2041, 0x0000,
+	0x2508, 0x2029, 0x0001, 0x0096, 0x2049, 0x0000, 0x080c, 0x7a48,
+	0x009e, 0x008e, 0x2039, 0x0000, 0x080c, 0x7ae2, 0x080c, 0xa97c,
+	0x005e, 0x003e, 0x001e, 0x8108, 0x1f04, 0xaa0e, 0x015e, 0x00ce,
+	0x007e, 0x005e, 0x004e, 0x002e, 0x0005, 0x0076, 0x0056, 0x6210,
+	0x0086, 0x2041, 0x0000, 0x2029, 0x0001, 0x2019, 0x0048, 0x0096,
+	0x2049, 0x0000, 0x080c, 0x7a48, 0x009e, 0x008e, 0x2039, 0x0000,
+	0x080c, 0x7ae2, 0x2c20, 0x080c, 0xa97c, 0x005e, 0x007e, 0x0005,
+	0x0026, 0x0046, 0x0056, 0x0076, 0x00c6, 0x0156, 0x2c20, 0x20a9,
+	0x007f, 0x2009, 0x0000, 0x0016, 0x0036, 0x080c, 0x4b58, 0x11c0,
+	0x2c10, 0x0086, 0x2041, 0x0000, 0x2828, 0x0046, 0x2021, 0x0001,
+	0x080c, 0xacfb, 0x004e, 0x0096, 0x2049, 0x0000, 0x080c, 0x7a48,
+	0x009e, 0x008e, 0x2039, 0x0000, 0x080c, 0x7ae2, 0x080c, 0xa97c,
+	0x003e, 0x001e, 0x8108, 0x1f04, 0xaa5b, 0x015e, 0x00ce, 0x007e,
+	0x005e, 0x004e, 0x002e, 0x0005, 0x0016, 0x00f6, 0x9d82, 0x45c0,
+	0x0280, 0x9d82, 0xffff, 0x1268, 0x6800, 0x907d, 0x0138, 0x6803,
+	0x0000, 0x6b82, 0x080c, 0x50a5, 0x2f68, 0x0cb0, 0x6b82, 0x080c,
+	0x50a5, 0x00fe, 0x001e, 0x0005, 0x00e6, 0x0046, 0x0036, 0x2061,
+	0x15c0, 0x9005, 0x1138, 0x2071, 0x1100, 0x7444, 0x7064, 0x8001,
+	0x9402, 0x12d8, 0x2100, 0x9c06, 0x0168, 0x6000, 0x9086, 0x0000,
+	0x0148, 0x6008, 0x9206, 0x1130, 0x6010, 0x91a0, 0x0004, 0x2424,
+	0x9406, 0x0140, 0x9ce0, 0x0018, 0x2001, 0x1116, 0x2004, 0x9c02,
+	0x1220, 0x0c40, 0x9085, 0x0001, 0x0008, 0x9006, 0x003e, 0x004e,
+	0x00ee, 0x0005, 0x00d6, 0x0006, 0x080c, 0x0ddf, 0x000e, 0x090c,
+	0x0cf1, 0x6867, 0x010d, 0x688e, 0x0026, 0x2010, 0x080c, 0x95c2,
+	0x2001, 0x0000, 0x0120, 0x2200, 0x9080, 0x0015, 0x2004, 0x002e,
+	0x687a, 0x6986, 0x6c76, 0x687f, 0x0000, 0x2001, 0x12ae, 0x2004,
+	0x6882, 0x9006, 0x68e2, 0x6802, 0x686a, 0x688a, 0x080c, 0x50a5,
+	0x00de, 0x0005, 0x6700, 0x9786, 0x0000, 0x0158, 0x9786, 0x0001,
+	0x0140, 0x9786, 0x000a, 0x0128, 0x9786, 0x0009, 0x0110, 0x9085,
+	0x0001, 0x0005, 0x00e6, 0x6010, 0x2070, 0x70a0, 0x9206, 0x00ee,
+	0x0005, 0x0016, 0x6004, 0x908e, 0x001e, 0x11a0, 0x8007, 0x6134,
+	0x918c, 0x00ff, 0x9105, 0x6036, 0x6007, 0x0085, 0x6003, 0x000b,
+	0x6023, 0x0005, 0x2001, 0x12a7, 0x2004, 0x601a, 0x080c, 0x6886,
+	0x080c, 0x6d42, 0x001e, 0x0005, 0xa001, 0xa001, 0x0005, 0x6024,
+	0xd0e4, 0x0158, 0xd0cc, 0x0118, 0x080c, 0x98aa, 0x0030, 0x080c,
+	0xad19, 0x080c, 0x66ae, 0x080c, 0x7f1e, 0x0005, 0x9280, 0x0008,
+	0x2004, 0x9084, 0x000f, 0x0002, 0xab4a, 0xab4a, 0xab4a, 0xab4c,
+	0xab4a, 0xab4c, 0xab4c, 0xab4a, 0xab4c, 0xab4a, 0xab4a, 0xab4a,
+	0xab4a, 0xab4a, 0x9006, 0x0005, 0x9085, 0x0001, 0x0005, 0x9280,
+	0x0008, 0x2004, 0x9084, 0x000f, 0x0002, 0xab63, 0xab63, 0xab63,
+	0xab63, 0xab63, 0xab63, 0xab70, 0xab63, 0xab63, 0xab63, 0xab63,
+	0xab63, 0xab63, 0xab63, 0x6007, 0x003b, 0x602f, 0x0009, 0x6017,
+	0x2a00, 0x6003, 0x0001, 0x080c, 0x6886, 0x080c, 0x6d42, 0x0005,
+	0x00c6, 0x2260, 0x080c, 0xad19, 0x6043, 0x0000, 0x6024, 0xc0f4,
+	0xc0e4, 0x6026, 0x603b, 0x0000, 0x00ce, 0x00d6, 0x2268, 0x9186,
+	0x0007, 0x1904, 0xabcb, 0x6814, 0x9005, 0x0138, 0x9080, 0x001f,
+	0x2004, 0xd0fc, 0x1110, 0x00de, 0x08b0, 0x6007, 0x003a, 0x6003,
+	0x0001, 0x080c, 0x6886, 0x080c, 0x6d42, 0x00c6, 0x2d60, 0x6100,
+	0x9186, 0x0002, 0x1904, 0xac4e, 0x6014, 0x9005, 0x1138, 0x6000,
+	0x9086, 0x0007, 0x190c, 0x0cf1, 0x0804, 0xac4e, 0x908c, 0xf000,
+	0x1130, 0x0028, 0x2068, 0x6800, 0x9005, 0x1de0, 0x2d00, 0x9080,
+	0x001f, 0x2004, 0x9084, 0x0003, 0x9086, 0x0002, 0x1180, 0x6014,
+	0x2068, 0x687c, 0xc0dc, 0xc0f4, 0x687e, 0x6880, 0xc0f4, 0xc0fc,
+	0x6882, 0x2009, 0x0043, 0x080c, 0xa528, 0x0804, 0xac4e, 0x2009,
+	0x0041, 0x0804, 0xac48, 0x9186, 0x0005, 0x15c0, 0x6814, 0x9080,
+	0x001f, 0x2004, 0xd0bc, 0x1118, 0x00de, 0x0804, 0xab63, 0xd0b4,
+	0x0128, 0xd0fc, 0x090c, 0x0cf1, 0x0804, 0xab83, 0x6007, 0x003a,
+	0x6003, 0x0001, 0x080c, 0x6886, 0x080c, 0x6d42, 0x00c6, 0x2d60,
+	0x6100, 0x9186, 0x0002, 0x0120, 0x9186, 0x0004, 0x1904, 0xac4e,
+	0x6814, 0x9080, 0x001f, 0x200c, 0xc1f4, 0xc1dc, 0x2102, 0x8000,
+	0x200c, 0xc1f4, 0xc1fc, 0xc1bc, 0x2102, 0x00f6, 0x2c78, 0x080c,
+	0x119d, 0x00fe, 0x2009, 0x0042, 0x0804, 0xac48, 0x0036, 0x00d6,
+	0x00d6, 0x080c, 0x0ddf, 0x003e, 0x090c, 0x0cf1, 0x6867, 0x010d,
+	0x6803, 0x0000, 0x686b, 0x0000, 0x688b, 0x0000, 0x6b8e, 0x6887,
+	0x0045, 0x2c00, 0x6892, 0x6038, 0x68a2, 0x2360, 0x6024, 0xc0dd,
+	0x6026, 0x6010, 0x9080, 0x0028, 0x2004, 0x9084, 0x00ff, 0x8007,
+	0x6354, 0x6b7a, 0x6876, 0x687f, 0x0000, 0x6883, 0x0000, 0x6d9a,
+	0x6e96, 0x689f, 0x0001, 0x080c, 0x50a5, 0x2019, 0x0045, 0x6008,
+	0x2068, 0x080c, 0xa6bc, 0x2d00, 0x600a, 0x6023, 0x0006, 0x6003,
+	0x0007, 0x601b, 0x0000, 0x6043, 0x0000, 0x00de, 0x003e, 0x0038,
+	0x6043, 0x0000, 0x6003, 0x0007, 0x080c, 0xa528, 0x00ce, 0x00de,
+	0x0005, 0x9186, 0x0013, 0x1128, 0x6004, 0x9082, 0x0085, 0x2008,
+	0x00c2, 0x9186, 0x0027, 0x1178, 0x080c, 0x6c56, 0x0036, 0x00d6,
+	0x6014, 0x2068, 0x2019, 0x0004, 0x080c, 0xaa84, 0x00de, 0x003e,
+	0x080c, 0x6d42, 0x0005, 0x9186, 0x0014, 0x0d70, 0x080c, 0x7f68,
+	0x0005, 0xac7e, 0xac7c, 0xac7c, 0xac7c, 0xac7c, 0xac7c, 0xac7e,
+	0xac7c, 0xac7c, 0xac7c, 0xac7c, 0x080c, 0x0cf1, 0x080c, 0x6c56,
+	0x6003, 0x000c, 0x080c, 0x6d42, 0x0005, 0x9182, 0x0090, 0x1220,
+	0x9182, 0x0085, 0x0208, 0x001a, 0x080c, 0x7f68, 0x0005, 0xac9a,
+	0xac9a, 0xac9a, 0xac9a, 0xac9c, 0xacbc, 0xac9a, 0xac9a, 0xac9a,
+	0xac9a, 0xac9a, 0x080c, 0x0cf1, 0x00d6, 0x2c68, 0x080c, 0x7ec8,
+	0x01b0, 0x6003, 0x0001, 0x6007, 0x001e, 0x2009, 0x026e, 0x210c,
+	0x613a, 0x2009, 0x026f, 0x210c, 0x613e, 0x600b, 0xffff, 0x6910,
+	0x6112, 0x6023, 0x0004, 0x080c, 0x6886, 0x080c, 0x6d42, 0x2d60,
+	0x080c, 0x7f1e, 0x00de, 0x0005, 0x080c, 0x7f1e, 0x0005, 0x00e6,
+	0x6010, 0x2070, 0x7000, 0xd0ec, 0x00ee, 0x0005, 0x2009, 0x1172,
+	0x210c, 0xd1ec, 0x0578, 0x6003, 0x0002, 0x6024, 0xc0e5, 0x6026,
+	0xd0cc, 0x0150, 0x2001, 0x12a8, 0x2004, 0x6042, 0x2009, 0x1172,
+	0x210c, 0xd1f4, 0x11e8, 0x0080, 0x2009, 0x1172, 0x210c, 0xd1f4,
+	0x0128, 0x6024, 0xc0e4, 0x6026, 0x9006, 0x00a0, 0x2001, 0x12a8,
+	0x200c, 0x8103, 0x9100, 0x6042, 0x6010, 0x9088, 0x002b, 0x2104,
+	0x9005, 0x0118, 0x9088, 0x0003, 0x0cd0, 0x2c0a, 0x600f, 0x0000,
+	0x9085, 0x0001, 0x0005, 0x0016, 0x00c6, 0x00e6, 0x6154, 0x92f0,
+	0x002b, 0x2e04, 0x2060, 0x8cff, 0x0180, 0x84ff, 0x1118, 0x6054,
+	0x9106, 0x1138, 0x600c, 0x2072, 0x080c, 0x66ae, 0x080c, 0x7f1e,
+	0x0010, 0x9cf0, 0x0003, 0x2e64, 0x0c70, 0x00ee, 0x00ce, 0x001e,
+	0x0005, 0x00d6, 0x6010, 0x90e8, 0x002b, 0x2d04, 0x9005, 0x0140,
+	0x9c06, 0x0120, 0x2d04, 0x90e8, 0x0003, 0x0cb8, 0x600c, 0x206a,
+	0x00de, 0x0005, 0x0026, 0x0036, 0x0156, 0x2011, 0x1127, 0x2204,
+	0x9084, 0x00ff, 0x2019, 0x026e, 0x2334, 0x9636, 0x11d8, 0x8318,
+	0x2334, 0x2204, 0x9084, 0xff00, 0x9636, 0x11a0, 0x2011, 0x0270,
+	0x20a9, 0x0004, 0x6010, 0x9098, 0x000a, 0x080c, 0x8a45, 0x1150,
+	0x2011, 0x0274, 0x20a9, 0x0004, 0x6010, 0x9098, 0x0006, 0x080c,
+	0x8a45, 0x1100, 0x015e, 0x003e, 0x002e, 0x0005, 0x00e6, 0x2071,
+	0x1100, 0x080c, 0x46bb, 0x080c, 0x23cd, 0x00ee, 0x0005, 0x00e6,
+	0x6010, 0x2070, 0x7000, 0xd0fc, 0x0108, 0x0011, 0x00ee, 0x0005,
+	0x6880, 0xc0e5, 0x6882, 0x0005, 0x00e6, 0x00c6, 0x0076, 0x0066,
+	0x0056, 0x0046, 0x0026, 0x0016, 0x0126, 0x2091, 0x8000, 0x2029,
+	0x12e5, 0x252c, 0x2021, 0x12eb, 0x2424, 0x2061, 0x15c0, 0x2071,
+	0x1100, 0x7644, 0x7064, 0x9606, 0x0578, 0x6720, 0x9786, 0x0001,
+	0x0118, 0x9786, 0x0008, 0x1500, 0x2500, 0x9c06, 0x01e8, 0x2400,
+	0x9c06, 0x01d0, 0x080c, 0xaaf2, 0x01b8, 0x080c, 0xab02, 0x11a0,
+	0x6000, 0x9086, 0x0004, 0x1120, 0x0016, 0x080c, 0x12c7, 0x001e,
+	0x080c, 0x97bc, 0x1110, 0x080c, 0x25d1, 0x080c, 0x97cd, 0x1110,
+	0x080c, 0x8576, 0x080c, 0x97a3, 0x9ce0, 0x0018, 0x2001, 0x1116,
+	0x2004, 0x9c02, 0x1208, 0x0858, 0x012e, 0x001e, 0x002e, 0x004e,
+	0x005e, 0x006e, 0x007e, 0x00ce, 0x00ee, 0x0005, 0x0126, 0x0006,
+	0x00e6, 0x2091, 0x8000, 0x2071, 0x1140, 0xd5a4, 0x0118, 0x7034,
+	0x8000, 0x7036, 0xd5b4, 0x0118, 0x7030, 0x8000, 0x7032, 0xd5ac,
+	0x0118, 0x2071, 0x114a, 0x0451, 0x00ee, 0x000e, 0x012e, 0x0005,
+	0x0126, 0x0006, 0x00e6, 0x2091, 0x8000, 0x2071, 0x1140, 0xd5a4,
+	0x0118, 0x7034, 0x8000, 0x7036, 0xd5b4, 0x0118, 0x7030, 0x8000,
+	0x7032, 0xd5ac, 0x0118, 0x2071, 0x114a, 0x0081, 0x00ee, 0x000e,
+	0x012e, 0x0005, 0x0126, 0x0006, 0x00e6, 0x2091, 0x8000, 0x2071,
+	0x1142, 0x0021, 0x00ee, 0x000e, 0x012e, 0x0005, 0x2e04, 0x8000,
+	0x2072, 0x1220, 0x8e70, 0x2e04, 0x8000, 0x2072, 0x0005, 0x00e6,
+	0x2071, 0x1140, 0x0c99, 0x00ee, 0x0005, 0x00e6, 0x2071, 0x1144,
+	0x0c69, 0x00ee, 0x0005, 0x0126, 0x0006, 0x00e6, 0x2091, 0x8000,
+	0x2071, 0x1140, 0x7044, 0x8000, 0x7046, 0x00ee, 0x000e, 0x012e,
+	0x0005, 0x8064, 0x0008, 0x0010, 0x0000, 0x8066, 0x0000, 0x0101,
+	0x0008, 0x4404, 0x0003, 0x8060, 0x0000, 0x0400, 0x0000, 0x580a,
+	0x0003, 0x791e, 0x0003, 0x507c, 0x0003, 0x4c07, 0x000b, 0xbac0,
+	0x0009, 0x0082, 0x0008, 0x0c07, 0x0003, 0x15fe, 0x0008, 0x3407,
+	0x000b, 0x808c, 0x0008, 0x0001, 0x0000, 0x0000, 0x0007, 0x4047,
+	0x000a, 0x808c, 0x0008, 0x0002, 0x0000, 0x0819, 0x000b, 0x4022,
+	0x0000, 0x001a, 0x0003, 0x4122, 0x0008, 0x0bfe, 0x0008, 0x11a0,
+	0x0001, 0x11a5, 0x000b, 0x0ca0, 0x0001, 0x11a5, 0x000b, 0x9180,
+	0x0001, 0x0005, 0x0008, 0x7f62, 0x0008, 0x8066, 0x0000, 0x0019,
+	0x0000, 0x4424, 0x000b, 0x0240, 0x0002, 0x099f, 0x000b, 0x00fe,
+	0x0000, 0x31a2, 0x000b, 0x112a, 0x0000, 0x002e, 0x0008, 0x022c,
+	0x0008, 0x3a44, 0x0002, 0x0c07, 0x0003, 0x1734, 0x0000, 0x1530,
+	0x0000, 0x1632, 0x0008, 0x0d2a, 0x0008, 0x9a80, 0x0009, 0x000f,
+	0x0008, 0x7f62, 0x0008, 0x8066, 0x0000, 0x0011, 0x0008, 0x4437,
+	0x0003, 0x808c, 0x0008, 0x0002, 0x0000, 0x01fe, 0x0008, 0x42e0,
+	0x0009, 0x0d98, 0x000b, 0x00fe, 0x0000, 0x43e0, 0x0001, 0x0d98,
+	0x000b, 0x9880, 0x0001, 0x0010, 0x0000, 0x7f62, 0x0008, 0x8066,
+	0x0000, 0x1e0a, 0x0008, 0x4445, 0x0003, 0x808a, 0x0008, 0x0003,
+	0x0008, 0x9a80, 0x0009, 0x0002, 0x0000, 0x7f62, 0x0008, 0x584b,
+	0x0003, 0x8066, 0x0000, 0x3679, 0x0000, 0x444e, 0x000b, 0x584f,
+	0x000b, 0x8054, 0x0008, 0x0011, 0x0008, 0x8074, 0x0000, 0x1010,
+	0x0008, 0x1efe, 0x0000, 0x3007, 0x0003, 0x0058, 0x000c, 0x0007,
+	0x0003, 0x1cfe, 0x0008, 0x1b80, 0x0009, 0x7f62, 0x0008, 0x8066,
+	0x0000, 0x0231, 0x0008, 0x445d, 0x0003, 0x585e, 0x000b, 0x0140,
+	0x0008, 0x0140, 0x0008, 0x0242, 0x0000, 0x0242, 0x0000, 0x1f43,
+	0x0002, 0x0c6e, 0x0003, 0x0d44, 0x0000, 0x0d44, 0x0000, 0x0d46,
+	0x0008, 0x0d46, 0x0008, 0x0348, 0x0008, 0x0348, 0x0008, 0x044a,
+	0x0008, 0x044a, 0x0008, 0x0076, 0x0003, 0x0344, 0x0008, 0x0344,
+	0x0008, 0x0446, 0x0008, 0x0446, 0x0008, 0x0548, 0x0008, 0x0548,
+	0x0008, 0x064a, 0x0000, 0x064a, 0x0000, 0x5876, 0x000b, 0x8054,
+	0x0008, 0x0001, 0x0000, 0x8074, 0x0000, 0x2020, 0x0008, 0x4000,
+	0x000f, 0x3a40, 0x000a, 0x0c0a, 0x000b, 0x2b24, 0x0008, 0x2b24,
+	0x0008, 0x5880, 0x000b, 0x8054, 0x0008, 0x0002, 0x0000, 0x1242,
+	0x0002, 0x08ca, 0x0003, 0x3a45, 0x000a, 0x08bb, 0x0003, 0x1e10,
+	0x000a, 0x7f3c, 0x0000, 0x08b8, 0x0003, 0x1d00, 0x0002, 0x7f3a,
+	0x0000, 0x0d60, 0x0000, 0x7f62, 0x0008, 0x8066, 0x0000, 0x0009,
+	0x0008, 0x4490, 0x000b, 0x8060, 0x0000, 0x0400, 0x0000, 0x00fe,
+	0x0000, 0x34b5, 0x000b, 0x1cfe, 0x0008, 0xff80, 0x0009, 0x0001,
+	0x0000, 0x7f62, 0x0008, 0x8066, 0x0000, 0x0009, 0x0008, 0x449b,
+	0x0003, 0x00fe, 0x0000, 0x318b, 0x0003, 0x0038, 0x0000, 0x00fe,
+	0x0000, 0xff80, 0x0009, 0x0019, 0x0000, 0x7f62, 0x0008, 0x8066,
+	0x0000, 0x0009, 0x0008, 0x44a5, 0x000b, 0x80c0, 0x0009, 0x00ff,
+	0x0008, 0x7f3e, 0x0008, 0x0d60, 0x0000, 0x0efe, 0x0008, 0x1f80,
+	0x0001, 0x7f62, 0x0008, 0x8066, 0x0000, 0x0009, 0x0008, 0x44af,
+	0x000b, 0x8060, 0x0000, 0x0400, 0x0000, 0x003a, 0x0008, 0x1dfe,
+	0x0000, 0x008c, 0x0003, 0x0036, 0x0008, 0x0058, 0x000c, 0x00ca,
+	0x000b, 0x8074, 0x0000, 0x2000, 0x0000, 0x00ca, 0x000b, 0x3a44,
+	0x0002, 0x09a8, 0x0003, 0x8074, 0x0000, 0x1000, 0x0000, 0x2d0e,
+	0x0000, 0x2d0e, 0x0000, 0x358b, 0x000b, 0x26fe, 0x0008, 0x26fe,
+	0x0008, 0x2700, 0x0008, 0x2700, 0x0008, 0x00d0, 0x0009, 0x0cd8,
+	0x000b, 0x8074, 0x0000, 0x4040, 0x0008, 0x58ca, 0x0003, 0x507c,
+	0x0003, 0x3a46, 0x000a, 0x0cd8, 0x000b, 0x3a47, 0x0002, 0x08d5,
+	0x000b, 0x8054, 0x0008, 0x0004, 0x0000, 0x8074, 0x0000, 0x8000,
+	0x0000, 0x0112, 0x0003, 0x92c0, 0x0009, 0x0f88, 0x0008, 0x0807,
+	0x000b, 0x9a80, 0x0009, 0x0002, 0x0000, 0x7f62, 0x0008, 0x8066,
+	0x0000, 0x362a, 0x0000, 0x44dd, 0x000b, 0x2000, 0x0000, 0x2000,
+	0x0000, 0x2102, 0x0000, 0x2102, 0x0000, 0x2204, 0x0000, 0x2204,
+	0x0000, 0x2306, 0x0000, 0x2306, 0x0000, 0x2408, 0x0000, 0x2408,
+	0x0000, 0x250a, 0x0000, 0x250a, 0x0000, 0x260c, 0x0000, 0x260c,
+	0x0000, 0x270e, 0x0000, 0x270e, 0x0000, 0x2810, 0x0000, 0x2810,
+	0x0000, 0x2912, 0x0000, 0x2912, 0x0000, 0x9a80, 0x0009, 0x0007,
+	0x0000, 0x7f62, 0x0008, 0x8066, 0x0000, 0x0052, 0x0000, 0x44f7,
+	0x0003, 0x92c0, 0x0009, 0x0780, 0x0008, 0x0d92, 0x000b, 0x124b,
+	0x0002, 0x0900, 0x000b, 0x2e4d, 0x0002, 0x2e4d, 0x0002, 0x098b,
+	0x000b, 0x5900, 0x000b, 0x8054, 0x0008, 0x0004, 0x0000, 0x3a46,
+	0x000a, 0x0d0d, 0x000b, 0x1243, 0x000a, 0x0910, 0x0003, 0x8010,
+	0x0008, 0x000d, 0x0000, 0x017c, 0x0004, 0x1810, 0x0000, 0x017c,
+	0x0004, 0x0110, 0x000b, 0x0173, 0x0004, 0x1810, 0x0000, 0x017c,
+	0x0004, 0x8074, 0x0000, 0xf000, 0x0008, 0x3a42, 0x0002, 0x0d18,
+	0x0003, 0x15fe, 0x0008, 0x342e, 0x0003, 0x0d30, 0x0000, 0x0007,
+	0x0003, 0x8074, 0x0000, 0x0501, 0x0000, 0x8010, 0x0008, 0x000c,
+	0x0008, 0x017c, 0x0004, 0x0007, 0x0003, 0xbbe0, 0x0009, 0x0030,
+	0x0008, 0x0d2e, 0x0003, 0x18fe, 0x0000, 0x3ce0, 0x0009, 0x092b,
+	0x000b, 0x15fe, 0x0008, 0x3ce0, 0x0009, 0x092b, 0x000b, 0x016e,
+	0x0004, 0x8076, 0x0008, 0x0040, 0x0000, 0x016b, 0x000b, 0x8076,
+	0x0008, 0x0041, 0x0008, 0x016b, 0x000b, 0xbbe0, 0x0009, 0x0032,
+	0x0000, 0x0d33, 0x0003, 0x3c1e, 0x0008, 0x016b, 0x000b, 0xbbe0,
+	0x0009, 0x0037, 0x0000, 0x0d50, 0x0003, 0x18fe, 0x0000, 0x3ce0,
+	0x0009, 0x0d2b, 0x0003, 0x1afe, 0x0008, 0xff80, 0x0009, 0x000d,
+	0x0000, 0x7f62, 0x0008, 0x2604, 0x0008, 0x2604, 0x0008, 0x2706,
+	0x0008, 0x2706, 0x0008, 0x2808, 0x0000, 0x2808, 0x0000, 0x290a,
+	0x0000, 0x290a, 0x0000, 0x8066, 0x0000, 0x0422, 0x0000, 0x4547,
+	0x0003, 0x0173, 0x0004, 0x8054, 0x0008, 0x0004, 0x0000, 0x8074,
+	0x0000, 0xf000, 0x0008, 0x8072, 0x0000, 0x8000, 0x0000, 0x0112,
+	0x0003, 0xbbe0, 0x0009, 0x0038, 0x0000, 0x0d62, 0x000b, 0x18fe,
+	0x0000, 0x3ce0, 0x0009, 0x095f, 0x000b, 0x15fe, 0x0008, 0x3ce0,
+	0x0009, 0x0d27, 0x0003, 0x016e, 0x0004, 0x8076, 0x0008, 0x0040,
+	0x0000, 0x8072, 0x0000, 0x8000, 0x0000, 0x019f, 0x0003, 0x8076,
+	0x0008, 0x0042, 0x0008, 0x016b, 0x000b, 0xbbe0, 0x0009, 0x0016,
+	0x0000, 0x0d6b, 0x000b, 0x3a44, 0x0002, 0x0c09, 0x000b, 0x8072,
+	0x0000, 0x8000, 0x0000, 0x8000, 0x000f, 0x0007, 0x0003, 0x8072,
+	0x0000, 0x8000, 0x0000, 0x0007, 0x0003, 0x3d30, 0x000a, 0x7f00,
+	0x0000, 0xbc80, 0x0001, 0x0007, 0x0000, 0x0177, 0x0003, 0x1930,
+	0x000a, 0x7f00, 0x0000, 0x9880, 0x0001, 0x0007, 0x0000, 0x7f62,
+	0x0008, 0x8066, 0x0000, 0x000a, 0x0008, 0x457a, 0x000b, 0x4000,
+	0x000f, 0x217c, 0x0003, 0x0870, 0x0008, 0x4000, 0x000f, 0xbac0,
+	0x0009, 0x0090, 0x0008, 0x0985, 0x0003, 0x8074, 0x0000, 0x0706,
+	0x0000, 0x0187, 0x0003, 0x8074, 0x0000, 0x0703, 0x0000, 0x4000,
+	0x000f, 0x8010, 0x0008, 0x0008, 0x0000, 0x01ad, 0x000b, 0x0173,
+	0x0004, 0x8010, 0x0008, 0x0007, 0x0000, 0x017c, 0x0004, 0x1810,
+	0x0000, 0x017c, 0x0004, 0x01b7, 0x0003, 0x8010, 0x0008, 0x0009,
+	0x0008, 0x01ad, 0x000b, 0x8010, 0x0008, 0x0005, 0x0008, 0x01ad,
+	0x000b, 0x808c, 0x0008, 0x0001, 0x0000, 0x8010, 0x0008, 0x0004,
+	0x0000, 0x4143, 0x000a, 0x0840, 0x000b, 0x01ad, 0x000b, 0x8010,
+	0x0008, 0x0003, 0x0008, 0x01af, 0x0003, 0x8010, 0x0008, 0x000b,
+	0x0000, 0x01af, 0x0003, 0x8010, 0x0008, 0x0002, 0x0000, 0x01af,
+	0x0003, 0x3a47, 0x0002, 0x0cca, 0x000b, 0x8010, 0x0008, 0x0006,
+	0x0008, 0x01af, 0x0003, 0x8074, 0x0000, 0xf000, 0x0008, 0x017c,
+	0x0004, 0x017f, 0x0004, 0x3a40, 0x000a, 0x0807, 0x000b, 0x8010,
+	0x0008, 0x000c, 0x0008, 0x017c, 0x0004, 0x0007, 0x0003, 0x8074,
+	0x0000, 0xf080, 0x0000, 0x0d30, 0x0000, 0x2e4d, 0x0002, 0x2e4d,
+	0x0002, 0x09c0, 0x000b, 0x8054, 0x0008, 0x0019, 0x0000, 0x0007,
+	0x0003, 0x8054, 0x0008, 0x0009, 0x0008, 0x0007, 0x0003, 0x0001,
+	0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
+	0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0xbb4d
+};
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tp_length01 = 0xa9b8;
+#else
+unsigned short risc_code_length01 = 0xa9b8;
+#endif
+
diff -urN linux.orig/drivers/scsi/qla1280.c linux/drivers/scsi/qla1280.c
--- linux.orig/drivers/scsi/qla1280.c	Wed Jun 27 18:10:55 2001
+++ linux/drivers/scsi/qla1280.c	Mon Dec 17 20:27:41 2001
@@ -1,162 +1,110 @@
 /********************************************************************************
- *                  QLOGIC LINUX SOFTWARE
- *
- * QLogic ISP1x80/1x160 device driver for Linux 2.3.x (redhat 6.X).
- *
- * COPYRIGHT (C) 1999-2000 QLOGIC CORPORATION    
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the Qlogic's Linux Software License. See below.
- *
- * This program is WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistribution's or source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification, immediately at the beginning of the file.
- * 2. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- ********************************************************************************/
- 
-/*****************************************************************************************
-			QLOGIC CORPORATION SOFTWARE
-           "GNU" GENERAL PUBLIC LICENSE
-    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION
-                 AND MODIFICATION
-
-This GNU General Public License ("License") applies solely to QLogic Linux 
-Software ("Software") and may be distributed under the terms of this License.  
- 
-1. You may copy and distribute verbatim copies of the Software's source code as 
-you receive it, in any medium, provided that you conspicuously and appropriately 
-publish on each copy an appropriate copyright notice and disclaimer of warranty;
-keep intact all the notices that refer to this License and to the absence of any
-warranty; and give any other recipients of the Software a copy of this License along
-with the Software. 
-
-You may charge a fee for the physical act of transferring a copy, and you may at your
-option offer warranty protection in exchange for a fee.
- 
-2. You may modify your copy or copies of the Software or any portion of it, thus forming
-a work based on the Software, and copy and distribute such modifications or work under
-the terms of Section 1 above, provided that you also meet all of these conditions:
- 
-* a) You must cause the modified files to carry prominent notices stating that you
-changed the files and the date of any change. 
-
-* b) You must cause any work that you distribute or publish that in whole or in part
-contains or is derived from the Software or any part thereof, to be licensed as a
-whole at no charge to all third parties under the terms of this License. 
-
-* c) If the modified Software normally reads commands interactively when run, you
-must cause it, when started running for such interactive use in the most ordinary way,
-to print or display an announcement including an appropriate copyright notice and a 
-notice that there is no warranty (or else, saying that you provide a warranty) and that
-users may redistribute the Software under these conditions, and telling the user how to
-view a copy of this License. (Exception:if the Software itself is interactive but does 
-not normally print such an announcement, your work based on the Software is not required
-to print an announcement.) 
-
-These requirements apply to the modified work as a whole. If identifiable sections of
-that work are not derived from the Software, and can be reasonably considered independent
-and separate works in themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works. But when you distribute the same
-sections as part of a whole which is a work based on the Software, the distribution of the
-whole must be on the terms of this License, whose permissions for other licensees extend
-to the entire whole, and thus to each and every part regardless of who wrote it. 
-
-3. You may copy and distribute the Software (or a work based on it, under Section 2) in 
-object code or executable form under the terms of Sections 1 and 2 above provided that
-you also do one of the following: 
-
-* a) Accompany it with the complete corresponding machine-readable source code, which must
-be distributed under the terms of Sections 1 and 2 above on a medium customarily used for
-software interchange; or, 
-
-* b) Accompany it with a written offer, valid for at least three years, to give any third
-party, for a charge no more than your cost of physically performing source distribution,
-a complete machine-readable copy of the corresponding source code, to be distributed under
-the terms of Sections 1 and 2 above on a medium customarily used for software interchange;
-or,
-
-* c) Accompany it with the information you received as to the offer to distribute 
-corresponding source code. (This alternative is allowed only for noncommercial distribution
-and only if you received the Software in object code or executable form with such an offer,
-in accord with Subsection b above.) 
-
-The source code for a work means the preferred form of the work for making modifications
-to it. For an executable work, complete source code means all the source code for all 
-modules it contains, plus any associated interface definition files, plus the scripts used
-to control compilation and installation of the executable.     
-
-If distribution of executable or object code is made by offering access to copy from a 
-designated place, then offering equivalent access to copy the source code from the same
-place counts as distribution of the source code, even though third parties are not 
-compelled to copy the source along with the object code. 
-
-4. You may not copy, modify, sublicense, or distribute the Software except as expressly 
-provided under this License. Any attempt otherwise to copy, modify, sublicense or 
-distribute the Software is void, and will automatically terminate your rights under this
-License. However, parties who have received copies, or rights, from you under this License
-will not have their licenses terminated so long as such parties remain in full compliance. 
-
-5. This license grants you world wide, royalty free non-exclusive rights to modify or 
-distribute the Software or its derivative works. These actions are prohibited by law 
-if you do not accept this License. Therefore, by modifying or distributing the Software
-(or any work based on the Software), you indicate your acceptance of this License to do
-so, and all its terms and conditions for copying, distributing or modifying the Software
-or works based on it.
- 
-6. Each time you redistribute the Software (or any work based on the Software), the 
-recipient automatically receives a license from the original licensor to copy, distribute
-or modify the Software subject to these terms and conditions. You may not impose any 
-further restrictions on the recipients' exercise of the rights granted herein. You are
-not responsible for enforcing compliance by third parties to this License.
- 
-7. If, as a consequence of a court judgment or allegation of patent infringement or for
-any other reason (not limited to patent issues), conditions are imposed on you 
-(whether by court order, agreement or otherwise) that contradict the conditions of this
-License, they do not excuse you from the conditions of this License. If you cannot 
-distribute so as to satisfy simultaneously your obligations under this License 
-and any other pertinent obligations, then as a consequence you may not distribute the
-Software at all.    
-
-If any portion of this section is held invalid or unenforceable under any particular 
-circumstance, the balance of the section is intended to apply and the section as a whole
-is intended to apply in other circumstances. 
-NO WARRANTY
-
-11. THE SOFTWARE IS PROVIDED WITHOUT A WARRANTY OF ANY KIND. THERE IS NO 
-WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. 
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR 
-OTHER PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, 
-EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
-ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. 
-SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL 
-NECESSARY SERVICING, REPAIR OR CORRECTION.
- 
-12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
-REDISTRIBUTE THE SOFTWARE AS PERMITTED ABOVE, BE LIABLE TO YOU FOR 
-DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL 
-DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING 
-BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR 
-LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO 
-OPERATE WITH ANY OTHER SOFTWARES), EVEN IF SUCH HOLDER OR OTHER PARTY HAS 
-BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
-END OF TERMS AND CONDITIONS 
-
-*******************************************************************************************/ 
-
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic  QLA1280 (Ultra2)  and  QLA12160 (Ultra3) SCSI driver
+* Copyright (C) 2000 Qlogic Corporation 
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+**
+******************************************************************************/
+#define QLA1280_VERSION      "3.23 Beta"
 /****************************************************************************
     Revision History:
-    Rev. 3.00       Jan 17, 1999    DG  Qlogic
+    Rev  3.23 Beta January 11, 2001 BN Qlogic
+        - Added check of device_id when handling non 
+          QLA12160s during detect().
+    Rev  3.22 Beta January 5, 2001 BN Qlogic
+        - Changed queue_task() to schedule_task()
+          for kernels 2.4.0 and higher. 
+          Note: 2.4.0-testxx kernels released prior to
+                the actual 2.4.0 kernel release on January 2001
+                will get compile/link errors with schedule_task().
+                Please update your kernel to released 2.4.0 level,
+                or comment lines in this file flagged with  3.22 
+                to resolve compile/link error of schedule_task().
+        - Added -DCONFIG_SMP in addition to -D__SMP__ 
+          in Makefile for 2.4.0 builds of driver as module.
+    Rev  3.21 Beta January 4, 2001 BN Qlogic
+        - Changed criteria of 64/32 Bit mode of HBA
+          operation according to BITS_PER_LONG rather
+          than HBA's NVRAM setting of >4Gig memory bit;
+          so that the HBA auto-configures without the need
+          to setup each system individually.
+    Rev  3.20 Beta December 5, 2000 BN Qlogic
+        - Added priority handling to IA-64  onboard SCSI
+          ISP12160 chip for kernels greater than 2.3.18.
+        - Added irqrestore for qla1280_intr_handler.
+        - Enabled /proc/scsi/qla1280 interface.
+        - Clear /proc/scsi/qla1280 counters in detect().
+    Rev  3.19 Beta October 13, 2000 BN Qlogic
+        - Declare driver_template for new kernel
+          (2.4.0 and greater) scsi initialization scheme.
+        - Update /proc/scsi entry for 2.3.18 kernels and
+          above as qla1280
+    Rev  3.18 Beta October 10, 2000 BN Qlogic
+        - Changed scan order of adapters to map 
+          the QLA12160 followed by the QLA1280.
+    Rev  3.17 Beta September 18, 2000 BN Qlogic
+        - Removed warnings for 32 bit 2.4.x compiles
+        - Corrected declared size for request and response
+          DMA addresses that are kept in each ha
+    Rev. 3.16 Beta  August 25, 2000   BN  Qlogic
+        - Corrected 64 bit addressing issue on IA-64
+          where the upper 32 bits were not properly
+          passed to the RISC engine.
+    Rev. 3.15 Beta  August 22, 2000   BN  Qlogic
+        - Modified qla1280_setup_chip to properly load
+          ISP firmware for greater that 4 Gig memory on IA-64
+    Rev. 3.14 Beta  August 16, 2000   BN  Qlogic
+        - Added setting of dma_mask to full 64 bit
+          if flags.enable_64bit_addressing is set in NVRAM
+    Rev. 3.13 Beta  August 16, 2000   BN  Qlogic
+        - Use new PCI DMA mapping APIs for 2.4.x kernel
+    Rev. 3.12       July 18, 2000    Redhat & BN Qlogic
+        - Added check of pci_enable_device to detect() for 2.3.x
+        - Use pci_resource_start() instead of 
+          pdev->resource[0].start in detect() for 2.3.x
+        - Updated driver version
+    Rev. 3.11       July 14, 2000    BN  Qlogic
+	- Updated SCSI Firmware to following versions:
+	  qla1x80:   8.13.08
+	  qla1x160:  10.04.08
+	- Updated driver version to 3.11
+    Rev. 3.10    June 23, 2000   BN Qlogic
+        - Added filtering of AMI SubSys Vendor ID devices 
+    Rev. 3.9 
+        - DEBUG_QLA1280 undefined and  new version  BN Qlogic 
+    Rev. 3.08b      May 9, 2000    MD Dell
+        - Added logic to check against AMI subsystem vendor ID
+	Rev. 3.08       May 4, 2000    DG  Qlogic
+        - Added logic to check for PCI subsystem ID.
+	Rev. 3.07       Apr 24, 2000    DG & BN  Qlogic
+	   - Updated SCSI Firmware to following versions:
+	     qla12160:   10.01.19
+		 qla1280:     8.09.00
+	Rev. 3.06       Apr 12, 2000    DG & BN  Qlogic
+	   - Internal revision; not released
+    Rev. 3.05       Mar 28, 2000    DG & BN  Qlogic
+       - Edit correction for virt_to_bus and PROC.
+    Rev. 3.04       Mar 28, 2000    DG & BN  Qlogic
+       - Merge changes from ia64 port.
+    Rev. 3.03       Mar 28, 2000    BN  Qlogic
+       - Increase version to reflect new code drop with compile fix
+         of issue with inclusion of linux/spinlock for 2.3 kernels
+    Rev. 3.02       Mar 15, 2000    BN  Qlogic
+       - Merge qla1280_proc_info from 2.10 code base
+    Rev. 3.01       Feb 10, 2000    BN  Qlogic
+       - Corrected code to compile on a 2.2.x kernel.
+    Rev. 3.00       Jan 17, 2000    DG  Qlogic
 	   - Added 64-bit support.
     Rev. 2.07       Nov 9, 1999     DG  Qlogic
 	   - Added new routine to set target parameters for ISP12160. 
@@ -183,12 +131,11 @@
 *****************************************************************************/
 
 
+#include <linux/config.h>       
 #ifdef MODULE
 #include <linux/module.h>
 #endif
 
-#define QLA1280_VERSION      " 3.00-Beta"
-
 #include <stdarg.h>
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -207,8 +154,16 @@
 #include <linux/proc_fs.h>
 #include <linux/blk.h>
 #include <linux/tqueue.h>
-/* MRS #include <linux/tasks.h> */
+#ifndef KERNEL_VERSION
+#  define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+ 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+#include <linux/pci_ids.h>
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+#include <linux/tasks.h>
 # include <linux/bios32.h>
 #endif
 #include "sd.h"
@@ -216,23 +171,16 @@
 #include "hosts.h"
 #define UNIQUE_FW_NAME
 #include "qla1280.h"
-#include "ql12160_fw.h"                     /* ISP RISC code */
+#include "ql12160_fw.h"   /* ISP RISC codes */
 #include "ql1280_fw.h"
 
 #include <linux/stat.h>
-#include <linux/slab.h>        /* for kmalloc() */
-
-
-#ifndef KERNEL_VERSION
-#  define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
-#endif
-
+#include <linux/slab.h> 
 
 /*
  * Compile time Options: 
  *            0 - Disable and 1 - Enable 
  */
-#define  QLA1280_64BIT_SUPPORT         1   /* 64-bit Support */
 #define  QL1280_TARGET_MODE_SUPPORT    0   /* Target mode support */
 #define  WATCHDOGTIMER                 0
 #define  MEMORY_MAPPED_IO              0
@@ -244,15 +192,9 @@
 #define  AUTO_ESCALATE_ABORT           0   /* Automatically escalate aborts */
 #define  STOP_ON_ERROR                 0   /* Stop on aborts and resets  */
 #define  STOP_ON_RESET                 0 
-#define  STOP_ON_ABORT                 0 
-#undef   DYNAMIC_MEM_ALLOC
-
-#define  DEBUG_QLA1280                 0    /* Debugging  */
-/* #define CHECKSRBSIZE */
-
-/*
- * These macros to assist programming
- */
+#define  STOP_ON_ABORT                 0
+#define  QLA1280_PROFILE               1   /* 3.20 */ 
+#define  DEBUG_QLA1280                 0
 
 #define	BZERO(ptr, amt)		memset(ptr, 0, amt)
 #define	BCOPY(src, dst, amt)	memcpy(dst, src, amt)
@@ -260,19 +202,28 @@
 #define	KMFREE(ip,siz)	kfree((ip))
 #define	SYS_DELAY(x)		udelay(x);barrier()
 #define QLA1280_DELAY(sec)  mdelay(sec * 1000)
-#define VIRT_TO_BUS(a) virt_to_bus((a))
-#if  QLA1280_64BIT_SUPPORT
+
+/* 3.16 */
+#if  BITS_PER_LONG > 32
+#define pci_dma_lo32(a) (a & 0xffffffff)
+#define pci_dma_hi32(a) ((a >> 32) & 0xffffffff)
+#else
+#define pci_dma_lo32(a) (a & 0xffffffff)
+#define pci_dma_hi32(a) 0
+#endif
+
+#define  VIRT_TO_BUS(a)  virt_to_bus(((void *)a))
+
 #if  BITS_PER_LONG <= 32
-#define  VIRT_TO_BUS_LOW(a) (uint32_t)virt_to_bus((a))
+#define  VIRT_TO_BUS_LOW(a) (uint32_t)virt_to_bus(((void *)a))
 #define  VIRT_TO_BUS_HIGH(a) (uint32_t)(0x0)
 #else
-#define  VIRT_TO_BUS_LOW(a) (uint32_t)(0xffffffff & virt_to_bus((a)))
-#define  VIRT_TO_BUS_HIGH(a) (uint32_t)(0xffffffff & (virt_to_bus((a))>>32))
+#define  VIRT_TO_BUS_LOW(a) (uint32_t)(0xffffffff & virt_to_bus((void *)(a)))
+#define  VIRT_TO_BUS_HIGH(a) (uint32_t)(0xffffffff & (virt_to_bus((void *)(a))>>32))
 #endif
-#endif  /* QLA1280_64BIT_SUPPORT */
 
-#define STATIC     
 
+#define STATIC     
 #define NVRAM_DELAY() udelay(500) /* 2 microsecond delay */
 void qla1280_device_queue_depth(scsi_qla_host_t *, Scsi_Device *);
 
@@ -285,11 +236,11 @@
 #define  LSB(x)          (uint8_t)(x)
 
 #if  BITS_PER_LONG <= 32
-#define  LS_64BITS(x) (uint32_t)(x)
-#define  MS_64BITS(x) (uint32_t)(0x0)
+#define  LS_64BITS(x) (uint32_t)((unsigned long) x)
+#define  MS_64BITS(x) (uint32_t)((unsigned long) 0x0)
 #else
-#define  LS_64BITS(x) (uint32_t)(0xffffffff & (x))
-#define  MS_64BITS(x) (uint32_t)(0xffffffff & ((x)>>32) )
+#define  LS_64BITS(x) (uint32_t)(0xffffffff & ((unsigned long)x))
+#define  MS_64BITS(x) (uint32_t)(0xffffffff & (((unsigned long)x)>>32) )
 #endif
 
 /*
@@ -300,9 +251,6 @@
 STATIC void   qla1280_putq_t(scsi_lu_t *, srb_t *);
 STATIC void   qla1280_done_q_put(srb_t *, srb_t **, srb_t **);
 STATIC void qla1280_select_queue_depth(struct Scsi_Host *, Scsi_Device *);
-#ifdef  QLA1280_UNUSED 
-static void qla1280_dump_regs(struct Scsi_Host *host);
-#endif
 #if  STOP_ON_ERROR 
 static void qla1280_panic(char *, struct Scsi_Host *host);
 #endif
@@ -312,10 +260,7 @@
 STATIC int qla1280_return_status( sts_entry_t *sts, Scsi_Cmnd       *cp);
 STATIC void qla1280_removeq(scsi_lu_t *q, srb_t *sp);
 STATIC void qla1280_mem_free(scsi_qla_host_t *ha);
-static void qla1280_do_dpc(void *p);
-#ifdef  QLA1280_UNUSED 
-static void qla1280_set_flags(char * s);
-#endif
+void qla1280_do_dpc(void *p);
 static char	*qla1280_get_token(char *, char *);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
 STATIC inline void mdelay(int);
@@ -339,9 +284,7 @@
 STATIC uint8_t   qla1280_device_reset(scsi_qla_host_t *, uint8_t, uint32_t);
 STATIC uint8_t   qla1280_abort_device(scsi_qla_host_t *, uint8_t, uint32_t, uint32_t);
 STATIC uint8_t   qla1280_abort_command(scsi_qla_host_t *, srb_t *),
-#if  QLA1280_64BIT_SUPPORT
                  qla1280_64bit_start_scsi(scsi_qla_host_t *, srb_t *),
-#endif
                  qla1280_32bit_start_scsi(scsi_qla_host_t *, srb_t *),
                  qla1280_abort_isp(scsi_qla_host_t *);
 STATIC void      qla1280_nv_write(scsi_qla_host_t *, uint16_t),
@@ -374,12 +317,12 @@
                  qla1280_notify_ack(scsi_qla_host_t *, notify_entry_t *),
                  qla1280_immed_notify(scsi_qla_host_t *, notify_entry_t *),
                  qla1280_accept_io(scsi_qla_host_t *, ctio_ret_entry_t *),
-#if  QLA1280_64BIT_SUPPORT
-                 qla1280_64bit_continue_io(scsi_qla_host_t *, atio_entry_t *, uint32_t,
-                                     paddr32_t *),
-#endif
-                 qla1280_32bit_continue_io(scsi_qla_host_t *, atio_entry_t *, uint32_t,
-                                     paddr32_t *),
+                 qla1280_64bit_continue_io(scsi_qla_host_t *, 
+                                 atio_entry_t *, uint32_t,
+                                 paddr32_t *),
+                 qla1280_32bit_continue_io(scsi_qla_host_t *, 
+                                 atio_entry_t *, uint32_t,
+                                 paddr32_t *),
                  qla1280_atio_entry(scsi_qla_host_t *, atio_entry_t *),
                  qla1280_notify_entry(scsi_qla_host_t *, notify_entry_t *);
 #endif  /* QLA1280_TARGET_MODE_SUPPORT */
@@ -400,7 +343,7 @@
                 qla1280_dump_buffer(caddr_t, uint32_t);
 
 char          debug_buff[80];
-#if DEBUG_QLA1280 
+#if  DEBUG_QLA1280 
 STATIC uint8_t ql_debug_print = 1;
 #else
 STATIC uint8_t ql_debug_print = 0;
@@ -426,6 +369,22 @@
 
 #endif
 
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+/*
+ * Our directory Entry in /proc/scsi for the user to 
+ * access the driver. 
+ */
+/* Need to add in proc_fs.h     PROC_SCSI_QL1280 */
+#define PROC_SCSI_QL1280  PROC_SCSI_QLOGICISP
+
+struct proc_dir_entry proc_scsi_qla1280 = {
+    PROC_SCSI_QL1280, 7, "qla1280",                           
+    S_IFDIR | S_IRUGO | S_IXUGO, 2,
+    0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+};
+#endif
+
 /* We use the Scsi_Pointer structure that's included with each command
  * SCSI_Cmnd as a scratchpad for our SRB.
  *
@@ -471,17 +430,17 @@
    unsigned char   *fwver;          /* Ptr to F/W version array    */
 } qla_boards_t;
 
-struct _qlaboards   QLBoardTbl[NUM_OF_ISP_DEVICES] = 
+struct _qlaboards   QL1280BoardTbl[NUM_OF_ISP_DEVICES] = 
 {
    /* Name ,  Board PCI Device ID,         Number of ports */
+  {"QLA12160 ", QLA12160_DEVICE_ID,          2,      
+               &fw12160i_code01[0],  (unsigned long *)&fw12160i_length01,&fw12160i_addr01, &fw12160i_version_str[0] },       
   {"QLA1080 ", QLA1080_DEVICE_ID,           1,        
                &fw1280ei_code01[0],  (unsigned long *)&fw1280ei_length01,&fw1280ei_addr01, &fw1280ei_version_str[0] },       
   {"QLA1240 ", QLA1240_DEVICE_ID,           2,       
                &fw1280ei_code01[0],  (unsigned long *)&fw1280ei_length01,&fw1280ei_addr01, &fw1280ei_version_str[0] },       
   {"QLA1280 ", QLA1280_DEVICE_ID,           2,      
                &fw1280ei_code01[0],  (unsigned long *)&fw1280ei_length01,&fw1280ei_addr01, &fw1280ei_version_str[0] },       
-  {"QLA12160 ", QLA12160_DEVICE_ID,          2,      
-               &fw12160i_code01[0],  (unsigned long *)&fw12160i_length01,&fw12160i_addr01, &fw12160i_version_str[0] },       
   {"QLA10160 ", QLA10160_DEVICE_ID,          1,      
                &fw12160i_code01[0],  (unsigned long *)&fw12160i_length01,&fw12160i_addr01, &fw12160i_version_str[0] },       
   {"        ",                 0,           0}
@@ -489,7 +448,7 @@
 
 static unsigned long qla1280_verbose = 1L;
 static scsi_qla_host_t *qla1280_hostlist = NULL;
-#ifdef QLA1280_PROFILE
+#if QLA1280_PROFILE
 static int qla1280_buffer_size = 0;
 static char *qla1280_buffer = NULL;
 #endif
@@ -567,152 +526,153 @@
  *
  * Returns:
  *************************************************************************/
-#ifdef QLA1280_PROFILE
-#define	PROC_BUF	(&qla1280_buffer[size])
-#define LUN_ID       (targ_lun>>(MAX_T_BITS+MAX_L_BITS)),((targ_lun>>MAX_L_BITS)&0xf), targ_lun&0x7 
-#endif
+#define	PROC_BUF	(&qla1280_buffer[len])
 int
-qla1280_proc_info ( char *buffer, char **start, off_t offset, int length, 
-                    int hostno, int inout)
-{
-#ifdef QLA1280_PROFILE
+qla1280_proc_info( char *buffer, char **start, off_t offset, int length, 
+                    int hostno, int inout) {
+#if QLA1280_PROFILE
   struct Scsi_Host *host;
   scsi_qla_host_t *ha;
   int    size = 0;
-  int  targ_lun;
   scsi_lu_t  *up;
-  int   no_devices;
-
-  printk("Entering proc_info 0x%p,0x%lx,0x%x,0x%x\n",buffer,offset,length,hostno);
+  int   len = 0;
+  qla_boards_t   *bdp; 
+  uint32_t        b, t, l;
+  uint8_t  *temp;
   host = NULL;
-  /* find the host they want to look at */
-  for(ha=qla1280_hostlist; (ha != NULL) && ha->host->host_no != hostno; ha=ha->next)
+
+    /* Find the host that was specified */
+    for( ha=qla1280_hostlist; (ha != NULL) && ha->host->host_no != hostno; ha=ha->next )
     ;
 
-  if (!ha)
-  {
-    size += sprintf(buffer, "Can't find adapter for host number %d\n", hostno);
-    if (size > length)
-    {
+    /* if host wasn't found then exit */
+    if( !ha ) {
+        size = sprintf(buffer, "Can't find adapter for host number %d\n", hostno);
+        if( size > length ) {
       return (size);
-    }
-    else
-    {
-      return (length);
+        } else {
+            return (0);
     }
   }
 
   host = ha->host;
-  if (inout == TRUE) /* Has data been written to the file? */ 
-  {
-    return (qla1280_set_info(buffer, length, host));
-  }
 
-  /* compute number of active devices */
-  no_devices = 0;
-  for (targ_lun = 0; targ_lun < MAX_EQ; targ_lun++)
+    if( inout == TRUE ) /* Has data been written to the file? */
   {
-          if( (up = ha->dev[targ_lun]) == NULL )
-              continue;
-          no_devices++;
+        printk("qla1280_proc: has data been written to the file. \n");
+        return (qla1280_set_info(buffer, length, host));
   }
-  /* size = 112 * no_devices; */
-  size = 4096;
-  /* round up to the next page */
   
   /* 
    * if our old buffer is the right size use it otherwise 
    * allocate a new one.
    */
-  if (qla1280_buffer_size != size)
-  {
+    size = 4096;  /* get a page */
+    if( qla1280_buffer_size != size ) {
     /* deallocate this buffer and get a new one */
-    if (qla1280_buffer != NULL) 
-    {
+        if( qla1280_buffer != NULL ) {
       kfree(qla1280_buffer);
       qla1280_buffer_size = 0;
     }
     qla1280_buffer = kmalloc(size, GFP_KERNEL);
   }
-  if (qla1280_buffer == NULL)
-  {
+    if( qla1280_buffer == NULL ) {
     size = sprintf(buffer, "qla1280 - kmalloc error at line %d\n",
         __LINE__);
     return size;
   }
+    /* save the size of our buffer */
   qla1280_buffer_size = size;
 
-  size = 0;
-  size += sprintf(PROC_BUF, "Qlogic 1280/1080 SCSI driver version: ");   /* 43 bytes */
-  size += sprintf(PROC_BUF, "%5s, ", QLA1280_VERSION);                         /* 5        */
-  size += sprintf(PROC_BUF, "Qlogic Firmware version: ");                     /* 25       */
-  size += sprintf(PROC_BUF, "%2d.%2d.%2d",_firmware_version[0],           /* 8        */
-                                          ql12_firmware_version[1],
-                                          ql12_firmware_version[2]);
-  size += sprintf(PROC_BUF, "\n");                                             /* 1       */
-                           
-  size += sprintf(PROC_BUF, "SCSI Host Adapter Information: %s\n", QLBoardTbl[ha->devnum].bdName);
-  size += sprintf(PROC_BUF, "Request Queue = 0x%lx, Response Queue = 0x%lx\n",
-                        ha->request_dma,
-                        ha->response_dma);
-  size += sprintf(PROC_BUF, "Request Queue count= 0x%x, Response Queue count= 0x%x\n",
+  /* 3.20 clear the buffer we use for proc display */
+  temp = qla1280_buffer;
+  for (b=0 ; b < size; b++)     *(temp+b) = 0; 
+
+    /* start building the print buffer */ 
+    bdp = &QL1280BoardTbl[ha->devnum];
+    size =  sprintf(PROC_BUF,
+            "QLogic PCI to SCSI Adapter for ISP 1280/12160:\n"
+            "        Firmware version: %2d.%02d.%02d, Driver version %s\n",                bdp->fwver[0], bdp->fwver[1], bdp->fwver[2], QLA1280_VERSION);
+
+    len += size;
+
+    size = sprintf(PROC_BUF, "SCSI Host Adapter Information: %s\n", bdp->bdName);
+    len += size;
+    size = sprintf(PROC_BUF, "Request Queue = 0x%lx, Response Queue = 0x%lx\n",
+                        (unsigned long) ha->request_dma,
+                        (unsigned long) ha->response_dma);
+    len += size;
+    size = sprintf(PROC_BUF, "Request Queue count= 0x%x, Response Queue count= 0x%x\n",
                         REQUEST_ENTRY_CNT,
                         RESPONSE_ENTRY_CNT);
-  size += sprintf(PROC_BUF,"Number of pending commands = 0x%lx\n", ha->actthreads);
-  size += sprintf(PROC_BUF,"Number of queued commands = 0x%lx\n", ha->qthreads);
-  size += sprintf(PROC_BUF,"Number of free request entries = %d\n",ha->req_q_cnt);
-  size += sprintf(PROC_BUF, "\n");                                             /* 1       */
+    len += size; 
+    size = sprintf(PROC_BUF, "Number of pending commands = 0x%lx\n", ha->actthreads);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of queued commands = 0x%lx\n", ha->qthreads);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of free request entries = %d\n",ha->req_q_cnt);
+    len += size;
+    size = sprintf(PROC_BUF, "\n");                                             /* 1       */
+    len += size;
                         
-  size += sprintf(PROC_BUF, "Attached devices:\n");
+    size = sprintf(PROC_BUF, "SCSI device Information:\n");
+    len += size; 
   /* scan for all equipment stats */ 
-  for (targ_lun = 0; targ_lun < MAX_EQ; targ_lun++)
-  {
-      if( (up = ha->dev[targ_lun]) == NULL )
+	for (b = 0; b < MAX_BUSES; b++) 
+	for (t = 0; t < MAX_TARGETS; t++) {
+        for( l = 0; l < MAX_LUNS; l++ ) {
+           up = (scsi_lu_t *) LU_Q(ha, b, t, l);
+           if( up == NULL ) 
            continue;
-      if( up->io_cnt == 0 )
-      {
-          size += sprintf(PROC_BUF,"(%2d:%2d:%2d) No stats\n",LUN_ID);
+           /* unused device/lun */
+           if( up->io_cnt == 0 || up->io_cnt < 2 )
            continue;
-      }
       /* total reads since boot */
       /* total writes since boot */
       /* total requests since boot  */
-      size += sprintf(PROC_BUF, "Total requests %ld,",up->io_cnt);
+           size = sprintf(PROC_BUF, "(%2d:%2d:%2d): Total reqs %ld,",b,t,l,up->io_cnt);
+           len += size;
       /* current number of pending requests */
-      size += sprintf(PROC_BUF, "(%2d:%2d:%2d) pending requests %d,",LUN_ID,up->q_outcnt);
+           size = sprintf(PROC_BUF, " Pend reqs %d,",up->q_outcnt);
+           len += size;
+#if 0
       /* avg response time */
-      size += sprintf(PROC_BUF, "Avg response time %ld%%,",(up->resp_time/up->io_cnt)*100);
+           size = sprintf(PROC_BUF, " Avg resp time %ld%%,",(up->resp_time/up->io_cnt)*100);
+           len += size;
       
       /* avg active time */
-      size += sprintf(PROC_BUF, "Avg active time %ld%%\n",(up->act_time/up->io_cnt)*100);
+           size = sprintf(PROC_BUF, " Avg active time %ld%%\n",(up->act_time/up->io_cnt)*100);
+#else
+           size = sprintf(PROC_BUF, "\n");
+#endif
+           len += size; 
+        }
+        if( len >= qla1280_buffer_size ) 
+          break;
   }
 
-  if (size >= qla1280_buffer_size)
-  {
+    if( len >= qla1280_buffer_size ) {
     printk(KERN_WARNING "qla1280: Overflow buffer in qla1280_proc.c\n");
   }
 
-  if (offset > size - 1)
-  {
+    if( offset > len - 1 ) {
     kfree(qla1280_buffer);
     qla1280_buffer = NULL;
     qla1280_buffer_size = length = 0;
     *start = NULL;
-  }
-  else
-  {
+    } else {
     *start = &qla1280_buffer[offset];   /* Start of wanted data */
-    if (size - offset < length)
-    {
-      length = size - offset;
+        if( len - offset < length ) {
+            length = len - offset;
     }
   }
+    return (length);
+#else
+    return (0);
 #endif
 
-  return (length);
 }
 
-
 /**************************************************************************
  * qla1280_detect
  *    This routine will probe for Qlogic 1280 SCSI host adapters.
@@ -734,7 +694,10 @@
     struct Scsi_Host *host;
     scsi_qla_host_t *ha, *cur_ha;
     struct _qlaboards  *bdp;
-    int i, j;
+    int i,j;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+    unsigned short subsys;
+#endif
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,95)
     unsigned int piobase;
     unsigned char pci_bus, pci_devfn, pci_irq;
@@ -747,13 +710,19 @@
 #else
     int index;
 #endif
+#ifndef PCI_VENDOR_ID_AMI
+#define PCI_VENDOR_ID_AMI               0x101e
+#endif
 
     ENTER("qla1280_detect");
 
+    if (sizeof(srb_t) > sizeof(Scsi_Pointer) )
+      printk("qla1280_detect: [WARNING] srb_t Must Be Redefined");
+
 #ifdef CHECKSRBSIZE
     if (sizeof(srb_t) > sizeof(Scsi_Pointer) )
     {
-      printk("Redefine SRB - its too big");
+      printk("qla1280_detect:  srb_t Must Be Redefined - its too big");
       return 0;
     }
 #endif
@@ -784,45 +753,174 @@
                 "qla1280: insmod or else it might trash certain memory areas.\n");
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
     if ((int) !pcibios_present())
+#else
+    if (!pci_present())
+#endif
     {
-		printk("scsi: PCI not present\n");
-		return 0;
-    } /* end of IF */
-    bdp = &QLBoardTbl[0];
+	printk("scsi: PCI not present\n");
+	return 0;
+    } 
+
+    bdp = &QL1280BoardTbl[0];
     qla1280_hostlist = NULL;
-#if 0
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
     template->proc_dir = &proc_scsi_qla1280;
 #else
     template->proc_name = "qla1280";
 #endif
+
+        /* 3.20 */
+        /* First Initialize QLA12160 on PCI Bus 1 Dev 2 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+        while ((pdev = pci_find_subsys(QLA1280_VENDOR_ID,
+                               bdp->device_id,  /* QLA12160 first in list */ 
+                               PCI_ANY_ID, 
+                               PCI_ANY_ID,pdev))) {
+
+                /* find QLA12160 device on PCI bus=1 slot=2 */
+                if ((pdev->bus->number     != 1)   ||
+                    (PCI_SLOT(pdev->devfn) != 2))  continue;
+
+                if (pci_enable_device(pdev)) goto find_devices;
+                printk("qla1x160: Initializing ISP12160 on PCI Bus 1, Dev 2\n");
+		host = scsi_register(template, sizeof(scsi_qla_host_t));
+                if (!host) { 
+			printk(KERN_WARNING "qla1280: Failed to register host, aborting.\n");
+                        return 0;
+                }
+		scsi_set_pci_device(host, pdev);
+		ha = (scsi_qla_host_t *) host->hostdata;
+		/* Clear our data area */
+		for( j =0, cp = (char *)ha;  j < sizeof(scsi_qla_host_t); j++)
+			*cp++ = 0;
+		/* Sanitize the information from PCI BIOS.  */
+		host->irq = pdev->irq;
+		host->io_port = pci_resource_start(pdev, 0);
+		ha->pci_bus = pdev->bus->number;
+		ha->pci_device_fn = pdev->devfn;
+		ha->pdev = pdev;
+		ha->device_id = bdp->device_id; /* QLA12160 first in list */
     
+                ha->devnum = 0; // This priority ISP12160 is always devnum zero
+		if( qla1280_mem_alloc(ha) ) {
+  	          printk(KERN_INFO "qla1x160: Failed to get memory\n");
+		}                
+                ha->ports = bdp->numPorts; 
+                /* following needed for all cases of OS versions */
+                host->io_port &= PCI_BASE_ADDRESS_IO_MASK; 
+                ha->iobase = (device_reg_t *) host->io_port;
+                ha->host = host;
+                ha->host_no = host->host_no;
+                /* 3.20 zero out /proc/scsi/qla1280 counters */
+                ha->actthreads = 0;
+                ha->qthreads = 0;
+                ha->isr_count = 0; 
+
+                /* load the F/W, read paramaters, and init the H/W */
+                ha->instance = num_hosts;
+                if (qla1280_initialize_adapter(ha))
+                {
+                   printk(KERN_INFO "qla1x160: Failed to initialize QLA12160 on PCI Bus 1 Dev 2 \n");
+                   qla1280_mem_free(ha);
+                   scsi_unregister(host);
+                   goto find_devices;
+                }                
+                host->max_channel = bdp->numPorts-1; 
+		/* Register our resources with Linux */
+		if( qla1280_register_with_Linux(ha, bdp->numPorts-1) ) {
+		  printk(KERN_INFO "qla1x160: Failed to register resources for QLA12160 on PCI Bus 1 Dev 2\n");
+		  qla1280_mem_free(ha);
+		  scsi_unregister(host);
+		  goto find_devices;
+		}
+                reg = ha->iobase;
+                /* Disable ISP interrupts. */
+		qla1280_disable_intrs(ha);
+                /* Insure mailbox registers are free. */
+                WRT_REG_WORD(&reg->semaphore, 0);
+                WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+                WRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);
+
+                /* Enable chip interrupts. */
+		qla1280_enable_intrs(ha);
+                /* Insert new entry into the list of adapters */
+                ha->next = NULL;
+                /* this preferred device will always be the first one found */
+                cur_ha = qla1280_hostlist = ha;
+                num_hosts++;
+        }
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+ find_devices:
+#endif
+
+        pdev = NULL;
 	/* Try and find each different type of adapter we support */
-	for( i=0; bdp->device_id != 0 && i < NUM_OF_ISP_DEVICES; i++, bdp++ ) {
+	for(i=0;bdp->device_id != 0 && i < NUM_OF_ISP_DEVICES;i++,bdp++) {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+                /* PCI_SUBSYSTEM_IDS supported */ 
+		while ((pdev = pci_find_subsys(QLA1280_VENDOR_ID,
+			bdp->device_id, PCI_ANY_ID, PCI_ANY_ID, pdev) )) {
+ 			if (pci_enable_device(pdev)) continue;
+#else
 		while ((pdev = pci_find_device(QLA1280_VENDOR_ID,
 			bdp->device_id, pdev ) ))  {
-		if (pci_enable_device(pdev)) continue;
-#else
+#endif /* 2,3,18 */
+#else  /* less than 2,1,95 */  
 		while (!(pcibios_find_device(QLA1280_VENDOR_ID,
 			bdp->device_id,
 			index++, &pci_bus, &pci_devfn)) )  {
-#endif
+#endif /* 2,1,95 */ 
                 /* found a adapter */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+		  /* If it's an AMI SubSys Vendor ID adapter, skip it. */
+                  if (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) 
+                    { 
+                      printk("qla1x160: Skip AMI SubSys Vendor ID Chip\n");
+                      continue;
+                    }
+
+                  /* 3.20 and 3.23 */
+		  /* skip QLA12160 already initialized on PCI Bus 1 Dev 2 */
+                  /* since we already initialized and presented it */
+                  if ((bdp->device_id        == QLA12160_DEVICE_ID) &&
+                      (pdev->bus->number     == 1)   &&
+                      (PCI_SLOT(pdev->devfn) == 2))  continue;
+
+ 		  printk("qla1x160: Supported Device Found VID=%x DID=%x SSVID=%x SSDID=%x\n",
+			pdev->vendor, pdev->device,
+			pdev->subsystem_vendor, pdev->subsystem_device); 
+
+#else
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+                  printk("qla1x160: Supported Device Found\n");
+		  pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,
+                                       &subsys);
+		  /* Bypass all AMI SUBSYS VENDOR IDs */
+                  if (subsys == PCI_VENDOR_ID_AMI) 
+                    { 
+                      printk("qla1x160: Skip AMI SubSys Vendor ID  Chip\n");
+                      continue;
+                    }
+#endif /* 2,1,95 */
+#endif /* 2,3,18 */
 		host = scsi_register(template, sizeof(scsi_qla_host_t));
-                if (!host) { 
-			printk(KERN_WARNING "qla1280: Failed to register host, aborting.\n");
-                        return 0;
-                }
-		scsi_set_pci_device(host, pdev);
 		ha = (scsi_qla_host_t *) host->hostdata;
 		/* Clear our data area */
 		for( j =0, cp = (char *)ha;  j < sizeof(scsi_qla_host_t); j++)
-			*cp = 0;
+			*cp++ = 0;
 		/* Sanitize the information from PCI BIOS.  */
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
 		host->irq = pdev->irq;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                host->io_port = (unsigned int) pdev->base_address[0];
+#else
 		host->io_port = pci_resource_start(pdev, 0);
+#endif
 		ha->pci_bus = pdev->bus->number;
 		ha->pci_device_fn = pdev->devfn;
 		ha->pdev = pdev;
@@ -836,38 +934,38 @@
 		ha->pci_device_fn = pci_devfn;
 #endif
 		ha->device_id = bdp->device_id;
-    
-                ha->devnum = i;
+                ha->devnum = i; // specifies microcode load address
+
 		if( qla1280_mem_alloc(ha) ) {
-			printk(KERN_INFO "qla1280: Failed to allocate memory for adapter\n");
+  	          printk(KERN_INFO "qla1x160: Failed to get memory\n");
 		}
                 
                 ha->ports = bdp->numPorts; 
+                /* following needed for all cases of OS versions */
+                host->io_port &= PCI_BASE_ADDRESS_IO_MASK; 
                 ha->iobase = (device_reg_t *) host->io_port;
                 ha->host = host;
                 ha->host_no = host->host_no;
 
                 /* load the F/W, read paramaters, and init the H/W */
+                ha->instance = num_hosts;
                 if (qla1280_initialize_adapter(ha))
                 {
-
-                    printk(KERN_INFO "qla1280: Failed to initialized adapter\n");
-                    qla1280_mem_free(ha);
-                    scsi_unregister(host);
-                    continue;
+                   printk(KERN_INFO "qla1x160:Failed to initialize adapter\n");
+                   qla1280_mem_free(ha);
+                   scsi_unregister(host);
+                   continue;
                 }
                 
                 host->max_channel = bdp->numPorts-1; 
-                ha->instance = num_hosts;
 		/* Register our resources with Linux */
 		if( qla1280_register_with_Linux(ha, bdp->numPorts-1) ) {
-			printk(KERN_INFO "qla1280: Failed to register our resources\n");
-			qla1280_mem_free(ha);
-			scsi_unregister(host);
-			continue;
+		  printk(KERN_INFO "qla1x160: Failed to register resources\n");
+		  qla1280_mem_free(ha);
+		  scsi_unregister(host);
+		  continue;
 		}
 
-
                 reg = ha->iobase;
                 /* Disable ISP interrupts. */
 		qla1280_disable_intrs(ha);
@@ -924,8 +1022,11 @@
 	host->can_queue = 0xfffff;  /* unlimited  */
 	host->cmd_per_lun = 1;
        host->select_queue_depths = qla1280_select_queue_depth;
-	host->n_io_port = 0xFF;
-	host->base = (unsigned long) ha->mmpbase;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+        host->base = (unsigned char *) ha->mmpbase;
+#else
+        host->base = (u_long) ha->mmpbase;
+#endif
 	host->max_channel = maxchannels; 
        host->max_lun = MAX_LUNS-1; 
 	host->unique_id = ha->instance;
@@ -1016,10 +1117,10 @@
 
     bp = &qla1280_buffer[0];
     ha = (scsi_qla_host_t *)host->hostdata;
-    bdp = &QLBoardTbl[ha->devnum];
+    bdp = &QL1280BoardTbl[ha->devnum];
     memset(bp, 0, sizeof(qla1280_buffer));
     sprintf(bp,
-            "QLogic %sPCI to SCSI Host Adapter: bus %d device %d irq %d\n"
+            "QLogic %s PCI to SCSI Host Adapter: bus %d device %d irq %d\n"
             "       Firmware version: %2d.%02d.%02d, Driver version %s",
             (char *)&bdp->bdName[0], ha->pci_bus, (ha->pci_device_fn & 0xf8) >> 3, host->irq,
             bdp->fwver[0],bdp->fwver[1],bdp->fwver[2],
@@ -1051,8 +1152,8 @@
     scsi_lu_t       *q;
     u_long          handle;
 
-    ENTER("qla1280_queuecommand");
-    COMTRACE('C') 
+    /*ENTER("qla1280_queuecommand");
+      COMTRACE('C')*/ 
 
     host = cmd->host;
     ha = (scsi_qla_host_t *) host->hostdata;
@@ -1079,7 +1180,7 @@
         {
            LU_Q(ha, b, t, l) = q;
            BZERO(q,sizeof(struct scsi_lu));
-           DEBUG(sprintf(debug_buff,"Allocate new device queue 0x%x\n",q));
+           DEBUG(sprintf(debug_buff,"Allocate new device queue 0x%x\n\r",q));
            DEBUG(qla1280_print(debug_buff));
            DRIVER_UNLOCK
         }
@@ -1087,8 +1188,12 @@
         {
             CMD_RESULT(cmd) = (int) (DID_BUS_BUSY << 16);
             qla1280_done_q_put(sp, &ha->done_q_first, &ha->done_q_last);
-
-            schedule_task(&ha->run_qla_bh);
+/* 3.22 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) /* 3.22 */
+            queue_task(&ha->run_qla_bh,&tq_scheduler);
+#else  /* 3.22 */ 
+            schedule_task(&ha->run_qla_bh); /* 3.22 */
+#endif /* 3.22 */
             ha->flags.dpc_sched = TRUE;
             DRIVER_UNLOCK
             return(0);
@@ -1099,15 +1204,13 @@
     handle = INVALID_HANDLE;  
     CMD_HANDLE(cmd) = (unsigned char *)handle;
 
-    /* Bookkeeping information */
-    sp->r_start = jiffies;       /* time the request was received */
-    sp->u_start = 0;              
-
     /* add the command to our queue */
     ha->qthreads++;
     qla1280_putq_t(q,sp);
     
-    DEBUG(sprintf(debug_buff,"qla1280_queuecmd: queue pid=%d, hndl=0x%x\n\r",cmd->pid,handle));
+    DEBUG(sprintf(debug_buff,
+     "qla1280_QC: t=%x CDB=%x I/OSize=0x%x haQueueCount=0x%x\n\r",
+     t,cmd->cmnd[0],CMD_XFRLEN(cmd),ha->qthreads));
     DEBUG(qla1280_print(debug_buff));
 
     /* send command to adapter */
@@ -1117,7 +1220,7 @@
     DRIVER_UNLOCK
     
     
-    LEAVE("qla1280_queuecommand");
+    /*LEAVE("qla1280_queuecommand");*/
     return (0);
 }
 
@@ -1556,6 +1659,7 @@
     {
           COMTRACE('X')
           printk(KERN_INFO "scsi(%d): Already in interrupt - returning \n", (int)ha->host_no);
+          spin_unlock_irqrestore(&io_request_lock, cpu_flags);
           return;
     }
     set_bit(QLA1280_IN_ISR_BIT, (int *)&ha->flags);
@@ -1587,7 +1691,7 @@
             ha->run_qla_bh.routine = qla1280_do_dpc; 
 
              COMTRACE('P') 
-            schedule_task(&ha->run_qla_bh);
+            queue_task_irq(&ha->run_qla_bh,&tq_scheduler); 
             ha->flags.dpc_sched = TRUE;
         }
         clear_bit(QLA1280_IN_ISR_BIT, (int *)&ha->flags);
@@ -1611,7 +1715,7 @@
  * "host->can_queue". This can cause a panic if we were in our interrupt
  * code .
  **************************************************************************/
-static void qla1280_do_dpc(void *p)
+void qla1280_do_dpc(void *p)
 {
     scsi_qla_host_t *ha = (scsi_qla_host_t *) p;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
@@ -1729,6 +1833,7 @@
     scsi_lu_t       *q;
     uint32_t        b, t, l;
     Scsi_Cmnd  *cmd;
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
     unsigned long cpu_flags = 0;
 #endif
@@ -1745,7 +1850,8 @@
             *done_q_last = NULL;
         else
             (*done_q_first)->s_prev = NULL;
-                cmd = sp->cmd;
+
+        cmd = sp->cmd;
         b = SCSI_BUS_32(cmd);
         t = SCSI_TCN_32(cmd);
         l = SCSI_LUN_32(cmd);
@@ -1759,8 +1865,6 @@
             q->q_flag &= ~QLA1280_QBUSY;
         }
         
-        q->resp_time += jiffies - sp->r_start;                /* Lun bookkeeping information */
-        q->act_time += jiffies - sp->u_start;
         q->io_cnt++;
         if( sp->dir & BIT_5 )
          q->r_cnt++;
@@ -1783,7 +1887,28 @@
             default:
                 break;
         }
-
+        /* 3.13   64 and 32 bit */
+        /* Release memory used for this I/O */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+        if (cmd->use_sg) {
+            DEBUG(sprintf(debug_buff,
+            "S/G unmap_sg cmd=%x\n\r",cmd);)
+            DEBUG(qla1280_print(debug_buff));
+            pci_unmap_sg(ha->pdev, cmd->request_buffer,
+                         cmd->use_sg,
+                         scsi_to_pci_dma_dir(cmd->sc_data_direction));
+        }
+        else if (cmd->request_bufflen) {
+          /*DEBUG(sprintf(debug_buff,
+                 "No S/G unmap_single cmd=%x saved_dma_handle=%lx\n\r",
+                  cmd,sp->saved_dma_handle);)
+                  DEBUG(qla1280_print(debug_buff);)*/
+
+                  pci_unmap_single(ha->pdev,sp->saved_dma_handle,
+                                  cmd->request_bufflen,
+                                  scsi_to_pci_dma_dir(cmd->sc_data_direction));
+       }
+#endif 
         /* Call the mid-level driver interrupt handler */
         CMD_HANDLE(sp->cmd) = (unsigned char *) 0;
         ha->actthreads--;
@@ -1797,8 +1922,6 @@
         qla1280_next(ha, q, b);
     }
     DRIVER_UNLOCK 
-
-
     COMTRACE('d') 
     LEAVE("qla1280_done");
 }
@@ -1970,7 +2093,7 @@
             if (q->q_outcnt >= ha->bus_settings[b].hiwat)
                 q->q_flag |= QLA1280_QBUSY;
 
-#if  QLA1280_64BIT_SUPPORT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
             if (ha->flags.enable_64bit_addressing)
                 status = qla1280_64bit_start_scsi(ha, sp);
             else
@@ -1987,7 +2110,7 @@
                     /* Wait for 30 sec for command to be accepted. */
                     for (cnt = 6000000; cnt; cnt--)
                     {
-#if  QLA1280_64BIT_SUPPORT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
                         if (ha->flags.enable_64bit_addressing)
                             status = qla1280_64bit_start_scsi(ha, sp);
                         else
@@ -2078,7 +2201,7 @@
     ENTER("qla1280_putq_t");
 #endif
     DRIVER_LOCK
-    DEBUG(sprintf(debug_buff,"Adding to device 0x%p<-(0x%p)\n\r",q,sp));
+    DEBUG(sprintf(debug_buff,"Adding to device q=0x%p<-(0x%p)sp\n\r",q,sp));
     DEBUG(qla1280_print(debug_buff));
     sp->s_next = NULL;
     if (!q->q_first)                  /* If queue empty */
@@ -2163,28 +2286,33 @@
 {
 
 	uint8_t   status = 1;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+        dma_addr_t     dma_handle;
+#endif
 
 #ifdef QL_DEBUG_LEVEL_3
 	ENTER("qla1280_mem_alloc");
 #endif
 
-#ifdef DYNAMIC_MEM_ALLOC
-	ha->request_ring = qla1280_alloc_phys(REQUEST_ENTRY_SIZE * REQUEST_ENTRY_CNT,
-	&ha->request_dma);
-	if(ha->request_ring) {
-		ha->response_ring = qla1280_alloc_phys(RESPONSE_ENTRY_SIZE * RESPONSE_ENTRY_CNT,
-		&ha->response_dma);
-		if(ha->response_ring) {
-			status = 0;
-		}
-	}
-#else
+        /* 3.13 */
+        /* get consistent memory allocated for request and response rings */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
 	ha->request_ring = &ha->req[0];
 	ha->request_dma = VIRT_TO_BUS(&ha->req[0]);
 	ha->response_ring = &ha->res[0];
 	ha->response_dma = VIRT_TO_BUS(&ha->res[0]);
 	status = 0;
-#endif
+#else
+        ha->request_ring  = pci_alloc_consistent(ha->pdev,
+                               ((REQUEST_ENTRY_CNT+1)*(sizeof(request_t))),
+                               &dma_handle);
+        ha->request_dma    = dma_handle;
+        ha->response_ring  = pci_alloc_consistent(ha->pdev,
+                               ((RESPONSE_ENTRY_CNT+1)*(sizeof(response_t))),
+                               &dma_handle);
+        ha->response_dma   = dma_handle;
+        status = 0; 
+#endif 
 
 	if(status) {
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
@@ -2228,6 +2356,16 @@
             ha->dev[b] =  (scsi_lu_t  *)NULL;
     }
 
+    /* 3.13 */
+    /* free consistent memory allocated for request and response rings */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+    pci_free_consistent(ha->pdev, ((REQUEST_ENTRY_CNT+1)*(sizeof(request_t))),
+                        ha->request_ring, ha->request_dma);
+
+    pci_free_consistent(ha->pdev,((RESPONSE_ENTRY_CNT+1)*(sizeof(response_t))),
+    ha->response_ring, ha->response_dma); 
+#endif 
+
     LEAVE("qlc1280_mem_free");
 }
 
@@ -2488,7 +2626,7 @@
         /* Verify checksum of loaded RISC code. */
         mb[0] = MBC_VERIFY_CHECKSUM;
         /* mb[1] = ql12_risc_code_addr01; */
-        mb[1] = *QLBoardTbl[ha->devnum].fwstart;  
+        mb[1] = *QL1280BoardTbl[ha->devnum].fwstart;  
 
         if (!(status = qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0])))
         {
@@ -2498,7 +2636,7 @@
 #endif
             mb[0] = MBC_EXECUTE_FIRMWARE;
             /* mb[1] = ql12_risc_code_addr01; */
-            mb[1] = *QLBoardTbl[ha->devnum].fwstart;  
+            mb[1] = *QL1280BoardTbl[ha->devnum].fwstart;  
             qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
         }
         else
@@ -2533,18 +2671,69 @@
 qla1280_pci_config(scsi_qla_host_t *ha)
 {
     uint8_t      status = 1;
-    uint32_t     command;
 #if MEMORY_MAPPED_IO
     uint32_t  page_offset, base;
     uint32_t   mmapbase;
 #endif
-    config_reg_t *creg = 0;
     uint16_t     buf_wd;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+    uint32_t     command;
+    config_reg_t *creg = 0;
+#endif
+
 
     ENTER("qla1280_pci_config");
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+    /*
+     * Set Bus Master Enable, Memory Address Space Enable and
+     * reset any error bits, in the command register.
+     */
+    pci_read_config_word(ha->pdev, PCI_COMMAND, &buf_wd);
+    buf_wd &= ~0x7;
+#if MEMORY_MAPPED_IO
+    DEBUG(printk("qla1280: MEMORY MAPPED IO is enabled.\n"));
+    buf_wd |= BIT_2 + BIT_1 + BIT_0;
+#else
+    buf_wd |= BIT_2 + BIT_0;
+#endif
+    pci_write_config_word(ha->pdev, PCI_COMMAND, buf_wd);
+    /*
+     * Reset expansion ROM address decode enable.
+     */
+    pci_read_config_word(ha->pdev, PCI_ROM_ADDRESS, &buf_wd);
+    buf_wd &= ~PCI_ROM_ADDRESS_ENABLE;
+    pci_write_config_word(ha->pdev, PCI_ROM_ADDRESS, buf_wd);
+#if MEMORY_MAPPED_IO
+    /*
+     * Get memory mapped I/O address. 
+     */
+    pci_read_config_word(ha->pdev, PCI_BASE_ADDRESS_1, &mmapbase);
+    mmapbase &= PCI_BASE_ADDRESS_MEM_MASK;
+
+    /*
+     * Find proper memory chunk for memory map I/O reg.
+     */
+    base = mmapbase & PAGE_MASK;
+    page_offset = mmapbase - base;
+    /*
+     * Get virtual address for I/O registers.
+     */
+    ha->mmpbase = ioremap_nocache(base, page_offset + 256);
+    if( ha->mmpbase )
+    {
+        ha->mmpbase += page_offset;
+        /* ha->iobase = ha->mmpbase; */
+        status = 0;
+    }
+#else /* MEMORY_MAPPED_IO */
+    status = 0;
+#endif /* MEMORY_MAPPED_IO */
+
+#else /*LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18) */
+
     /* Get command register. */
-    if (pci_read_config_word(ha->pdev,OFFSET(creg->command), &buf_wd) == PCIBIOS_SUCCESSFUL)
+    if (pcibios_read_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->command), &buf_wd) == PCIBIOS_SUCCESSFUL)
     {
         command = buf_wd;
         /*
@@ -2558,20 +2747,20 @@
 #else
         buf_wd |= BIT_2 + BIT_0;
 #endif
-        if( pci_write_config_word(ha->pdev,OFFSET(creg->command), buf_wd) )
+        if( pcibios_write_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->command), buf_wd) )
         {
             printk(KERN_WARNING "qla1280: Could not write config word.\n");
         }
         /* Get expansion ROM address. */
-        if (pci_read_config_word(ha->pdev,OFFSET(creg->expansion_rom), &buf_wd) == PCIBIOS_SUCCESSFUL)
+        if (pcibios_read_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->expansion_rom), &buf_wd) == PCIBIOS_SUCCESSFUL)
         {
             /* Reset expansion ROM address decode enable. */
             buf_wd &= ~BIT_0;
-            if (pci_write_config_word(ha->pdev,OFFSET(creg->expansion_rom), buf_wd) == PCIBIOS_SUCCESSFUL)
+            if (pcibios_write_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->expansion_rom), buf_wd) == PCIBIOS_SUCCESSFUL)
             {
 #if MEMORY_MAPPED_IO
                 /* Get memory mapped I/O address. */
-                pci_read_config_dword(ha->pdev,OFFSET(cfgp->mem_base_addr), &mmapbase);
+                pcibios_read_config_dword(ha->pci_bus, ha->pci_device_fn,OFFSET(cfgp->mem_base_addr), &mmapbase);
                 mmapbase &= PCI_BASE_ADDRESS_MEM_MASK;
 
                 /* Find proper memory chunk for memory map I/O reg. */
@@ -2595,6 +2784,7 @@
             }
         }
     }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18) */
 
     LEAVE("qla1280_pci_config");
     return(status);
@@ -2725,6 +2915,7 @@
  * Returns:
  *      0 = success.
  */
+#define DUMP_IT_BACK 0   /* for debug of RISC loading */
 STATIC uint8_t
 qla1280_setup_chip(scsi_qla_host_t *ha)
 {
@@ -2733,37 +2924,52 @@
     uint16_t     *risc_code_address;
     long         risc_code_size;
     uint16_t     mb[MAILBOX_REGISTER_COUNT];
-#ifdef QLA1280_UNUSED
-    uint8_t	*sp;
-    int i;
-#endif
     uint16_t     cnt;
     int          num;
+#if DUMP_IT_BACK
+    int     i;
+    uint8_t *sp;
     uint8_t    *tbuf;
-    u_long     p_tbuf;
+#if BITS_PER_LONG > 32
+    dma_addr_t     p_tbuf;
+#else
+    uint32_t   p_tbuf;
+#endif
+#endif
 
 #ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_setup_chip");
 #endif
 
-	if( (tbuf = (uint8_t *)KMALLOC(8000) ) == NULL )
-        {
-            printk("setup_chip: couldn't alloacte memory\n");
-            return(1);
-        }
-        p_tbuf =  VIRT_TO_BUS(tbuf);
+    /* 3.13 */
+#if DUMP_IT_BACK
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+    if( (tbuf = (uint8_t *)KMALLOC(8000) ) == NULL )
+    {
+        printk("setup_chip: couldn't alloacte memory\n");
+        return(1);
+    }
+    p_tbuf =  VIRT_TO_BUS(tbuf);
+#else
+    /* get consistent memory allocated for setup_chip */
+    tbuf   = pci_alloc_consistent(ha->pdev, 8000, &p_tbuf);
+#endif
+#endif
+
     /* Load RISC code. */
     /* 
     risc_address      = ql12_risc_code_addr01;
     risc_code_address = &ql12_risc_code01[0];
     risc_code_size    = ql12_risc_code_length01;
     */
-    risc_address = *QLBoardTbl[ha->devnum].fwstart;  
-    risc_code_address = QLBoardTbl[ha->devnum].fwcode;  
-    risc_code_size    = (long)(*QLBoardTbl[ha->devnum].fwlen & 0xffff);  
-
-    DEBUG(printk("qla1280: DMAing RISC code (%d) words.\n",(int)risc_code_size));
-    DEBUG(sprintf(debug_buff,"qla1280_setup_chip:  Loading RISC code size =(%ld).\n\r",risc_code_size);)
+    risc_address = *QL1280BoardTbl[ha->devnum].fwstart;  
+    risc_code_address = QL1280BoardTbl[ha->devnum].fwcode;  
+    risc_code_size    = (long)(*QL1280BoardTbl[ha->devnum].fwlen & 0xffff);  
+
+    DEBUG(printk("qla1280_setup_chip: DMA RISC code (%d) words\n",
+         (int)risc_code_size));
+    DEBUG(sprintf(debug_buff,
+       "qla1280_setup_chip: DMA RISC code (%d) words\n\r",risc_code_size);)
     DEBUG(qla1280_print(debug_buff));
     num =0;
     while (risc_code_size > 0 && !status)
@@ -2773,29 +2979,31 @@
         if ( cnt > risc_code_size ) 
             cnt = risc_code_size;
 
-        DEBUG(sprintf(debug_buff,"qla1280_setup_chip:  loading risc @ =(0x%p),%d,%d(0x%x).\n\r",risc_code_address,cnt,num,risc_address);)
+        DEBUG(sprintf(debug_buff,
+         "qla1280_setup_chip:  loading risc @ =(0x%p),%d,%d(0x%x).\n\r",
+          risc_code_address,cnt,num,risc_address);)
         DEBUG(qla1280_print(debug_buff));
-        DEBUG(printk("qla1280_setup_chip:  loading risc @ =code=(0x%p),cnt=%d,seg=%d,addr=0x%x\n\r",risc_code_address,cnt,num,risc_address));
-        BCOPY((caddr_t) risc_code_address,(caddr_t) ha->request_ring, (cnt <<1));
+        BCOPY((caddr_t) risc_code_address,(caddr_t) ha->request_ring,
+              (cnt <<1));
+
+        flush_cache_all(); 
+
         mb[0] = MBC_LOAD_RAM; 
-        /* mb[0] = MBC_LOAD_RAM_A64; */
         mb[1] = risc_address;
         mb[4] = cnt;
         mb[3] = (uint16_t)  ha->request_dma & 0xffff;
         mb[2] = (uint16_t) (ha->request_dma >> 16) & 0xffff;
         mb[7] = (uint16_t) (MS_64BITS(ha->request_dma) & 0xffff);
         mb[6] = (uint16_t) (MS_64BITS(ha->request_dma) >> 16) & 0xffff;
-        DEBUG(printk("qla1280_setup_chip: op=%d  0x%lx = 0x%4x,0x%4x,0x%4x,0x%4x\n",mb[0],ha->request_dma,mb[6],mb[7],mb[2],mb[3]));
+        DEBUG(printk("qla1280_setup_chip: op=%d  0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\n",mb[0],ha->request_dma,mb[6],mb[7],mb[2],mb[3]));
         if( (status = qla1280_mailbox_command(ha, BIT_4|BIT_3|BIT_2|BIT_1|BIT_0,
             &mb[0]))  )
         {
             printk("Failed to load partial segment of f/w\n");
             break;
         }
-        /* dump it back */
-
-#if 0
-        mb[0] = MBC_DUMP_RAM_A64;
+#if DUMP_IT_BACK
+        mb[0] = MBC_READ_RAM_WORD;
         mb[1] = risc_address;
         mb[4] = cnt;
         mb[3] = (uint16_t)  p_tbuf & 0xffff;
@@ -2803,10 +3011,13 @@
         mb[7] = (uint16_t) (p_tbuf >> 32) & 0xffff;
         mb[6] = (uint16_t) (p_tbuf >> 48) & 0xffff;
 
-        if( (status = qla1280_mailbox_command(ha, BIT_4|BIT_3|BIT_2|BIT_1|BIT_0,
-            &mb[0]))  )
+        if( (status = qla1280_mailbox_command(ha, 
+                      BIT_4|BIT_3|BIT_2|BIT_1|BIT_0,&mb[0]))  )
         {
             printk("Failed to dump partial segment of f/w\n");
+            DEBUG(sprintf(debug_buff,
+               "setup_chip: Failed to dump partial segment of f/w\n\r");)
+            DEBUG(qla1280_print(debug_buff));
             break;
         }
         sp =  (uint8_t *)ha->request_ring;
@@ -2814,51 +3025,20 @@
         {
             if( tbuf[i] != sp[i] )
             {
-               printk("qla1280 : firmware compare error @ byte (0x%x)\n",i);
-                break;
+               printk("qla1280_setup_chip: FW compare error @ byte(0x%x) loop#=%x\n",i,num);
+               printk("setup_chip: FWbyte=%x  FWfromChip=%x\n",sp[i],tbuf[i]); 
+               DEBUG(sprintf(debug_buff,
+                "qla1280_setup_chip: FW compare error @ byte(0x%x) loop#=%x\n\r",i);)
+               DEBUG(qla1280_print(debug_buff);)
+               /*break;*/
             }
         }
-
 #endif
         risc_address += cnt;
         risc_code_size = risc_code_size - cnt;
         risc_code_address = risc_code_address + cnt;
         num++;
     }
-#ifdef QLA1280_UNUSED
-    DEBUG(ql_debug_print = 0;)
-    {
-        for (i = 0; i < ql12_risc_code_length01; i++)
-        {
-            mb[0] = 0x4;
-            mb[1] = ql12_risc_code_addr01 + i;
-            mb[2] = ql12_risc_code01[i];
-
-            status = qla1280_mailbox_command(ha, BIT_2|BIT_1|BIT_0,
-                    &mb[0]);
-            if (status)
-            {
-                printk("qla1280 : firmware load failure\n");
-                break;
-            }
-
-            mb[0] = 0x5;
-            mb[1] = ql12_risc_code_addr01 + i;
-            mb[2] = 0;
-
-            status = qla1280_mailbox_command(ha, BIT_2|BIT_1|BIT_0,
-                    &mb[0]);
-            if (status)
-            {
-                printk("qla1280 : firmware dump failure\n");
-                break;
-            }
-            if( mb[2] != ql12_risc_code01[i] )
-                printk("qla1280 : firmware compare error @ (0x%x)\n",ql12_risc_code_addr01+i);
-        }
-    }
-    DEBUG(ql_debug_print = 1;)
-#endif
 
     /* Verify checksum of loaded RISC code. */
     if (!status)
@@ -2866,22 +3046,29 @@
         DEBUG(printk("qla1280_setup_chip: Verifying checksum of loaded RISC code.\n");)
         mb[0] = MBC_VERIFY_CHECKSUM;
         /* mb[1] = ql12_risc_code_addr01; */
-        mb[1] = *QLBoardTbl[ha->devnum].fwstart;  
+        mb[1] = *QL1280BoardTbl[ha->devnum].fwstart;  
         
         if (!(status = qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0])))
         {
             /* Start firmware execution. */
             DEBUG(qla1280_print("qla1280_setup_chip: start firmware running.\n\r");)
             mb[0] = MBC_EXECUTE_FIRMWARE;
-            /* mb[1] = ql12_risc_code_addr01; */
-            mb[1] = *QLBoardTbl[ha->devnum].fwstart;  
+            mb[1] = *QL1280BoardTbl[ha->devnum].fwstart;  
             qla1280_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
         }
         else
             printk("qla1280_setup_chip: Failed checksum.\n");
     }
 
-	KMFREE(tbuf,8000);
+    /* 3.13 */
+#if DUMP_IT_BACK
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+    KMFREE(tbuf,8000);
+#else
+    /* free consistent memory allocated for setup_chip */
+    pci_free_consistent(ha->pdev, 8000, tbuf, p_tbuf);
+#endif
+#endif
 
 #if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
     if (status)
@@ -3158,9 +3345,29 @@
     /* Disable RISC load of firmware. */
     ha->flags.disable_risc_code_load =
             nv->cntr_flags_1.disable_loading_risc_code;
-    /* Enable 64bit addressing. */
-    ha->flags.enable_64bit_addressing =
-            nv->cntr_flags_1.enable_64bit_addressing;
+
+#if BITS_PER_LONG > 32
+    /* Enable 64bit addressing for OS/System combination supporting it   */
+    /* actual NVRAM bit is: nv->cntr_flags_1.enable_64bit_addressing     */ 
+    /* but we will ignore it and use BITS_PER_LONG macro to setup for    */
+    /* 64 or 32 bit access of host memory in all x86/ia-64/Alpha systems */
+    ha->flags.enable_64bit_addressing = 1;
+#else
+    ha->flags.enable_64bit_addressing = 0;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+    if (ha->flags.enable_64bit_addressing) {
+      printk("[[[ qla1x160: 64 Bit PCI Addressing Enabled ]]]\n");
+
+#if BITS_PER_LONG > 32
+           /* Update our PCI device dma_mask for full 64 bit mask */
+           //ha->pdev->dma_mask = (pci_dma_t) 0xffffffffffffffffull;
+           ha->pdev->dma_mask =  0xffffffffffffffff;
+
+#endif
+    }
+#endif
 
     /* Set ISP hardware DMA burst */
     mb[0] = nv->isp_config.c;
@@ -3844,7 +4051,7 @@
 #endif
 }
 
-#if  QLA1280_64BIT_SUPPORT
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
 /*
  * qla1280_64bit_start_scsi
  *      The start SCSI is responsible for building request packets on
@@ -3869,10 +4076,13 @@
     uint16_t        seg_cnt;
     struct scatterlist    *sg = (struct scatterlist *) NULL;
     uint32_t        *dword_ptr;
+    dma_addr_t       dma_handle;
 
-#ifdef QL_DEBUG_LEVEL_3
     ENTER("qla1280_64bit_start_scsi:");
-#endif
+
+    DEBUG(sprintf(debug_buff,
+          "64bit_start: cmd=%x sp=%x CDB=%x\n\r",cmd,sp,cmd->cmnd[0]);)
+    DEBUG(qla1280_print(debug_buff));
 
     if( qla1280_check_for_dead_scsi_bus(ha, sp) )
     {
@@ -3883,9 +4093,10 @@
     seg_cnt = 0;
     req_cnt = 1;
     if (cmd->use_sg)
-    {
-        seg_cnt =  cmd->use_sg;
+    {   /* 3.13 64 bit */
         sg = (struct scatterlist *) cmd->request_buffer;
+        seg_cnt = pci_map_sg(ha->pdev,sg,cmd->use_sg, 
+                    scsi_to_pci_dma_dir(cmd->sc_data_direction));
             
         if (seg_cnt > 2)
         {
@@ -3896,7 +4107,7 @@
     }
     else if (cmd->request_bufflen)  /* If data transfer. */
     {
-        DEBUG(printk("Single data transfer (0x%x)\n",cmd->request_bufflen));
+      /*DEBUG(printk("Single data transfer len=0x%x\n",cmd->request_bufflen));*/
         seg_cnt = 1;
     }
 
@@ -3957,7 +4168,7 @@
             /* Load SCSI command packet. */
             pkt->cdb_len = (uint16_t)CMD_CDBLEN(cmd);
             BCOPY(&(CMD_CDBP(cmd)), pkt->scsi_cdb, pkt->cdb_len);
-            DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]));
+            //DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]));
 
             /*
             * Load data segments.
@@ -3983,12 +4194,17 @@
                     /* Load command entry data segments. */
                     for (cnt = 0; cnt < 2 && seg_cnt; cnt++, seg_cnt--)
                     {
-                        DEBUG(sprintf(debug_buff,"SG Segment ap=0x%p, len=0x%x\n\r",sg->address,sg->length));
-                        DEBUG(qla1280_print(debug_buff));
-                        *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_LOW(sg->address));
-                        *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_HIGH(sg->address));
-                        *dword_ptr++ = sg->length;
+                        /* 3.13 64 bit */
+                        *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                        *dword_ptr++ = cpu_to_le32(pci_dma_hi32(sg_dma_address(sg)));
+                        *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
                         sg++;
+                        DEBUG(sprintf(debug_buff,
+                         "S/G Segment phys_addr=%x %x, len=0x%x\n\r",
+                          cpu_to_le32(pci_dma_hi32(sg_dma_address(sg))),
+                          cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                                      cpu_to_le32(sg_dma_len(sg)));)
+                        DEBUG(qla1280_print(debug_buff));
                     }
 #ifdef QL_DEBUG_LEVEL_5
                     qla1280_print(
@@ -4005,6 +4221,10 @@
                     /*
                     * Build continuation packets.
                     */
+                    DEBUG(sprintf(debug_buff,
+                    "S/G Building Continuation...seg_cnt=0x%x remains\n\r",
+                    seg_cnt);)
+                    DEBUG(qla1280_print(debug_buff));
                     while (seg_cnt > 0)
                     {
                         /* Adjust ring index. */
@@ -4038,10 +4258,17 @@
                         /* Load continuation entry data segments. */
                         for (cnt = 0; cnt < 5 && seg_cnt; cnt++, seg_cnt--)
                         {
-                            *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_LOW(sg->address));
-                            *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_HIGH(sg->address));
-                            *dword_ptr++ = sg->length;
-                            sg++;
+                           /* 3.13 64 bit */
+                           *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                           *dword_ptr++ = cpu_to_le32(pci_dma_hi32(sg_dma_address(sg)));
+                           *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+                           DEBUG(sprintf(debug_buff,
+                            "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n\r",
+                             cpu_to_le32(pci_dma_hi32(sg_dma_address(sg))),
+                             cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                             cpu_to_le32(sg_dma_len(sg)));)
+                           DEBUG(qla1280_print(debug_buff));
+                           sg++;
                         }
 #ifdef QL_DEBUG_LEVEL_5
                         qla1280_print(
@@ -4058,11 +4285,21 @@
 #endif
                     }
                 }
-                else                    /* No scatter gather data transfer */
-                {
-                    *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_LOW(cmd->request_buffer));
-                    *dword_ptr++ = cpu_to_le32(VIRT_TO_BUS_HIGH(cmd->request_buffer));
-                    *dword_ptr = (uint32_t) cmd->request_bufflen;
+                else         /* No scatter gather data transfer */
+                {   /* 3.13 64 bit */
+                    dma_handle = pci_map_single(ha->pdev, 
+                                                cmd->request_buffer,
+                                                cmd->request_bufflen,
+                                                scsi_to_pci_dma_dir(cmd->sc_data_direction));
+                    /* save dma_handle for pci_unmap_single */
+                    sp->saved_dma_handle = dma_handle;
+
+                    *dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
+                    *dword_ptr++ = cpu_to_le32(pci_dma_hi32(dma_handle));
+                    *dword_ptr   = (uint32_t) cmd->request_bufflen;
+                    /*DEBUG(sprintf(debug_buff,
+                    "No S/G map_single saved_dma_handle=%lx\n\r",dma_handle));
+                    DEBUG(qla1280_print(debug_buff));*/
 #ifdef QL_DEBUG_LEVEL_5
                     qla1280_print(
                             "qla1280_64bit_start_scsi: No scatter/gather command packet data - c");
@@ -4077,12 +4314,12 @@
 #endif
                 }
             }
-#ifdef QL_DEBUG_LEVEL_5
-            else                            /* No data transfer */
+            else         /* No data transfer */
             {
                 *dword_ptr++ = (uint32_t) 0;
                 *dword_ptr++ = (uint32_t) 0;
                 *dword_ptr = (uint32_t)  0;
+#ifdef QL_DEBUG_LEVEL_5
                 qla1280_print(
                         "qla1280_64bit_start_scsi: No data, command packet data - c");
                 qla1280_print(" b ");
@@ -4093,8 +4330,8 @@
                 qla1280_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
                 qla1280_print("\n\r");
                 qla1280_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
-            }
 #endif
+            }
             /* Adjust ring index. */
             ha->req_ring_index++;
             if (ha->req_ring_index == REQUEST_ENTRY_CNT)
@@ -4106,6 +4343,10 @@
                 ha->request_ring_ptr++;
 
             /* Set chip new ring index. */
+            DEBUG(qla1280_print("qla1280_64bit_start_scsi: Wakeup RISC for pending command\n\r"));
+            ha->qthreads--;
+            sp->flags |= SRB_SENT;
+            ha->actthreads++;
             WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
         }
         else
@@ -4146,7 +4387,7 @@
 #endif
     return(status);
 }
-#endif  /* QLA1280_64BIT_SUPPORT */
+#endif
 
 /*
  * qla1280_32bit_start_scsi
@@ -4181,8 +4422,15 @@
     uint8_t        *data_ptr;
     uint32_t        *dword_ptr;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+    dma_addr_t       dma_handle;
+#endif
+
     ENTER("qla1280_32bit_start_scsi");
 
+    DEBUG(sprintf(debug_buff,
+          "32bit_start: cmd=%x sp=%x CDB=%x\n\r",cmd,sp,cmd->cmnd[0]);)
+    DEBUG(qla1280_print(debug_buff));
 
     if( qla1280_check_for_dead_scsi_bus(ha, sp) )
     {
@@ -4199,8 +4447,15 @@
         * differences and the kernel SG list uses virtual addresses where
         * we need physical addresses.
         */
-        seg_cnt =  cmd->use_sg;
         sg = (struct scatterlist *) cmd->request_buffer;
+        /* 3.13 32 bit */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+        seg_cnt =  cmd->use_sg;
+#else
+        seg_cnt = pci_map_sg(ha->pdev,sg,cmd->use_sg, 
+                    scsi_to_pci_dma_dir(cmd->sc_data_direction));
+#endif
+
         /* 
         * if greater than four sg entries then we need to allocate
         * continuation entries
@@ -4211,17 +4466,22 @@
             if ((uint16_t)(seg_cnt - 4) % 7)
                 req_cnt++;
         }
-        DEBUG(sprintf(debug_buff,"S/G for data transfer -num segs(%d), req blk cnt(%d)\n\r",seg_cnt,req_cnt));
+        DEBUG(sprintf(debug_buff,
+         "S/G Transfer cmd=%x seg_cnt=0x%x, req_cnt=%x\n\r",
+          cmd,seg_cnt,req_cnt));
         DEBUG(qla1280_print(debug_buff));
     }
     else if (cmd->request_bufflen)  /* If data transfer. */
     {
-        DEBUG(printk("Single data transfer (0x%x)\n",cmd->request_bufflen));
+        DEBUG(sprintf(debug_buff,
+         "No S/G transfer t=%x cmd=%x len=%x CDB=%x\n\r",
+         SCSI_TCN_32(cmd),cmd,cmd->request_bufflen,cmd->cmnd[0]));
+        DEBUG(qla1280_print(debug_buff));
         seg_cnt = 1;
     }
     else
     {
-        DEBUG(printk("No data transfer \n"));
+      //DEBUG(printk("No data transfer \n"));
         seg_cnt = 0;
     }
 
@@ -4238,7 +4498,8 @@
             ha->req_q_cnt = REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
     }
 
-    DEBUG(sprintf(debug_buff,"Number of free entries = (%d)\n\r",ha->req_q_cnt));
+    DEBUG(sprintf(debug_buff,"Number of free entries=(%d) seg_cnt=0x%x\n\r",
+          ha->req_q_cnt,seg_cnt));
     DEBUG(qla1280_print(debug_buff));
     /* If room for request in request ring. */
     if ((uint16_t)(req_cnt + 2) < ha->req_q_cnt)
@@ -4286,20 +4547,15 @@
             data_ptr = (uint8_t *) &(CMD_CDBP(cmd));
             for (cnt = 0; cnt < pkt->cdb_len; cnt++)
                 pkt->scsi_cdb[cnt] = *data_ptr++;
-            DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]));
+            //DEBUG(printk("Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]));
             /*
             * Load data segments.
             */
             if (seg_cnt)
             {
-                DEBUG(printk("loading data segments..\n"));
                 /* Set transfer direction (READ and WRITE) */
                 /* Linux doesn't tell us                   */
-
                 /*
-                * 3/10 dg - Normally, we should need this check with our F/W
-                * but because of a small issue with it we do.
-                *
                 * For block devices, cmd->request.cmd has the operation 
                 * For character devices, this isn't always set properly, so
                 * we need to check data_cmnd[0].  This catches the conditions
@@ -4325,15 +4581,32 @@
                     /* Load command entry data segments. */
                     for (cnt = 0; cnt < 4 && seg_cnt; cnt++, seg_cnt--)
                     {
+                        /* 3.13 32 bit */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
                         *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(sg->address));
                         *dword_ptr++ = sg->length;
-                        DEBUG(sprintf(debug_buff,"SG Segment ap=0x%p, len=0x%x\n\r",sg->address,sg->length));
+                        DEBUG(sprintf(debug_buff,
+                         "S/G Segment phys_addr=0x%x, len=0x%x\n\r",
+                          cpu_to_le32(VIRT_TO_BUS(sg->address)),sg->length));
+                        DEBUG(qla1280_print(debug_buff));
+#else
+                        *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                        *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+                        DEBUG(sprintf(debug_buff,
+                         "S/G Segment phys_addr=0x%x, len=0x%x\n\r",
+                          cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                          cpu_to_le32(sg_dma_len(sg)));)
                         DEBUG(qla1280_print(debug_buff));
+#endif 
                         sg++;
                     }
                     /*
                     * Build continuation packets.
                     */
+                    DEBUG(sprintf(debug_buff,
+                    "S/G Building Continuation...seg_cnt=0x%x remains\n\r",
+                    seg_cnt);)
+                    DEBUG(qla1280_print(debug_buff));
                     while (seg_cnt > 0)
                     {
                         /* Adjust ring index. */
@@ -4368,9 +4641,25 @@
                         /* Load continuation entry data segments. */
                         for (cnt = 0; cnt < 7 && seg_cnt; cnt++, seg_cnt--)
                         {
-                            *dword_ptr++ = (u_int) cpu_to_le32(VIRT_TO_BUS(sg->address));
-                            *dword_ptr++ = sg->length;
-                            sg++;
+                           /* 3.13 32 bit */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                           *dword_ptr++ = (u_int) cpu_to_le32(VIRT_TO_BUS(sg->address));
+                           *dword_ptr++ = sg->length;
+                           DEBUG(sprintf(debug_buff,
+                           "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n\r",
+                           cpu_to_le32(pci_dma_lo32(VIRT_TO_BUS(sg->address))),
+                           sg->length);)
+                           DEBUG(qla1280_print(debug_buff));
+#else
+                           *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                           *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+                           DEBUG(sprintf(debug_buff,
+                            "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n\r",
+                             cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                             cpu_to_le32(sg_dma_len(sg)));)
+                           DEBUG(qla1280_print(debug_buff));
+#endif
+                           sg++;
                         }
 #ifdef QL_DEBUG_LEVEL_5
                         qla1280_print(
@@ -4385,14 +4674,28 @@
 #endif
                     }
                 }
-                else                    /* No scatter gather data transfer */
+                else     /* No S/G data transfer */
                 {
+                    /* 3.13 32 bit */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
                     *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(cmd->request_buffer));
                     *dword_ptr = (uint32_t) cmd->request_bufflen;
-                    DEBUG(printk("Single Segment ap=0x%p, len=0x%x\n",cmd->request_buffer,cmd->request_bufflen));
+#else
+                    dma_handle = pci_map_single(ha->pdev, 
+                                                cmd->request_buffer,
+                                                cmd->request_bufflen,
+                                                scsi_to_pci_dma_dir(cmd->sc_data_direction));
+                    sp->saved_dma_handle = dma_handle;
+
+                    *dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
+                    *dword_ptr   = (uint32_t) cmd->request_bufflen;
+                    /*DEBUG(sprintf(debug_buff,
+                    "No S/G map_single saved_dma_handle=%lx\n\r",dma_handle));
+                    DEBUG(qla1280_print(debug_buff));*/
+#endif 
                 }
             }
-            else                            /* No data transfer */
+            else         /* No data transfer at all */
             {
                 *dword_ptr++ = (uint32_t) 0;
                 *dword_ptr = (uint32_t)  0;
@@ -4420,10 +4723,8 @@
             /* Set chip new ring index. */
             DEBUG(qla1280_print("qla1280_32bit_start_scsi: Wakeup RISC for pending command\n\r"));
             ha->qthreads--;
-            sp->u_start = jiffies;
             sp->flags |= SRB_SENT;
             ha->actthreads++;
-            /* qla1280_output_number((uint32_t)ha->actthreads++, 16); */
             WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
         }
         else
@@ -4431,7 +4732,7 @@
             status = 1;
 #ifdef QL_DEBUG_LEVEL_2
             qla1280_print(
-                    "qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n\r");
+            "qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n\r");
             qla1280_print(" req_q_cnt=");
             qla1280_output_number((uint32_t)ha->req_q_cnt, 16);
             qla1280_print("\n\r");
@@ -4465,6 +4766,7 @@
     return(status);
 }
 
+
 /*
  * qla1280_req_pkt
  *      Function is responsible for locking ring and
@@ -4895,7 +5197,7 @@
 {
     device_reg_t    *reg = ha->iobase;
     response_t      *pkt;
-    srb_t           *sp;
+    srb_t           *sp = 0; 
     uint16_t        mailbox[MAILBOX_REGISTER_COUNT];
     uint16_t        *wptr;
     uint32_t        index;
@@ -4909,9 +5211,11 @@
     /* Check for mailbox interrupt. */
 
     mailbox[0] = RD_REG_WORD(&reg->semaphore);
+
     if (mailbox[0] & BIT_0)
     {
         /* Get mailbox data. */
+        //DEBUG(qla1280_print("qla1280_isr: In Get mailbox data \n\r");)
 
         wptr = &mailbox[0];
         *wptr++ = RD_REG_WORD(&reg->mailbox0);
@@ -4944,7 +5248,7 @@
         {
             case MBA_SCSI_COMPLETION:   /* Response completion */
 #ifdef QL_DEBUG_LEVEL_5
-                qla1280_print("qla1280_isr: mailbox response completion\n\r");
+                qla1280_print("qla1280_isr: mailbox SCSI response completion\n\r");
 #endif
                 if (ha->flags.online)
                 {
@@ -4973,9 +5277,11 @@
                         else
                             (*done_q_last)->s_next = sp;
                         *done_q_last = sp;
+
                     }
                     else
                     {
+
 #ifdef QL_DEBUG_LEVEL_2
                             qla1280_print("qla1280_isr: ISP invalid handle\n\r");
 #endif
@@ -5047,6 +5353,7 @@
 #endif
                 break;
             default:
+              //DEBUG(qla1280_print("qla1280_isr: default case of switch MB \n\r");)
                 if (mailbox[0] < MBA_ASYNC_EVENT)
                 {
                         wptr = &mailbox[0];
@@ -5063,9 +5370,9 @@
                 break;
         }
     }
-    else
+    else {
         WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
-
+    }
     /*
     * Response ring
     */
@@ -5129,6 +5436,7 @@
                         qla1280_error_entry(ha, pkt,
                                 done_q_first, done_q_last);
 
+
                     /* Adjust ring index. */
                     ha->rsp_ring_index++;
                     if (ha->rsp_ring_index == RESPONSE_ENTRY_CNT)
@@ -5312,9 +5620,12 @@
             }
             pkt->scsi_status = S_CKCON;
             pkt->option_flags |= (uint32_t)OF_SSTS | (uint32_t)OF_NO_DATA;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
             if (ha->flags.enable_64bit_addressing)
                 qla1280_64bit_continue_io(ha, pkt, 0, 0);
             else
+#endif
                 qla1280_32bit_continue_io(ha, pkt, 0, 0);
             break;
         case 0x16:                  /* Requested Capability Not Available */
@@ -5673,10 +5984,12 @@
                             (uint32_t)OF_NO_DATA;
                     break;
             }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
             if (ha->flags.enable_64bit_addressing)
-                qla1280_64bit_continue_io(ha, pkt, len, (paddr32_t *)&phy_addr);
+               qla1280_64bit_continue_io(ha, pkt, len, (paddr32_t *)&phy_addr);
             else
-                qla1280_32bit_continue_io(ha, pkt, len, (paddr32_t *)&phy_addr);
+#endif
+               qla1280_32bit_continue_io(ha, pkt, len, (paddr32_t *)&phy_addr);
             break;
         default:
             break;
@@ -5750,11 +6063,13 @@
         ha->outstanding_cmds[pkt->handle] = 0;
 
         cp = sp->cmd;
+
         /* Generate LU queue on cntrl, target, LUN */
         b = SCSI_BUS_32(cp);
         t = SCSI_TCN_32(cp);
         l = SCSI_LUN_32(cp);
         q = LU_Q(ha, b, t, l);
+
         if( pkt->comp_status || pkt->scsi_status )
         {
             DEBUG(qla1280_print( "scsi: comp_status = ");)
@@ -5885,7 +6200,7 @@
         /* Place command on done queue. */
         qla1280_done_q_put(sp, done_q_first, done_q_last);
     }
-#if  QLA1280_64BIT_SUPPORT
+#if  BITS_PER_LONG > 32
     else if (pkt->entry_type == COMMAND_A64_TYPE)
     {
 #ifdef QL_DEBUG_LEVEL_2
@@ -5962,7 +6277,6 @@
                 sp->timeout += 2; */
 
                 /* Place request back on top of device queue. */
-                /* sp->flags &= ~(SRB_SENT | SRB_TIMEOUT); */ 
                 sp->flags = 0;
                 qla1280_putq_t(q, sp);
             }
@@ -6080,7 +6394,7 @@
                 }
             }
 #ifdef QL_DEBUG_LEVEL_3
-            qla1280_print("qla1280_restart_queues: exiting normally\n");
+            qla1280_print("qla1280_restart_queues: exiting normally\n\r");
 #endif
 }
 
@@ -6166,13 +6480,15 @@
     return(ret);
 }
 
-
-/*
- * Declarations for load module
- */
-static Scsi_Host_Template driver_template = QLA1280_LINUX_TEMPLATE;
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#ifdef MODULE
+Scsi_Host_Template driver_template = QLA1280_LINUX_TEMPLATE;
 #include "scsi_module.c"
+#endif
+#else   /* new kernel scsi initialization scheme */
+static  Scsi_Host_Template driver_template = QLA1280_LINUX_TEMPLATE;
+#include "scsi_module.c"
+#endif
 
 /************************************************************************
  * qla1280_check_for_dead_scsi_bus                                      *
@@ -6283,13 +6599,13 @@
 #if MEMORY_MAPPED_IO
     ret = *port;
 #else
-    ret = inb((int)port);
+    ret = inb((long)port);
 #endif
 
     if (ql_debug_print)
     {
         qla1280_print("qla1280_getbyte: address = ");
-        qla1280_output_number((uint32_t)port, 16);
+        qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
         qla1280_output_number((uint32_t)ret, 16);
         qla1280_print("\n\r");
@@ -6309,13 +6625,13 @@
 #if MEMORY_MAPPED_IO
     ret = *port;
 #else
-    ret = inw((int)port);
+    ret = inw((unsigned long)port);
 #endif
 
     if (ql_debug_print)
     {
         qla1280_print("qla1280_getword: address = ");
-        qla1280_output_number((uint32_t)port, 16);
+        qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
         qla1280_output_number((uint32_t)ret, 16);
         qla1280_print("\n\r");
@@ -6335,13 +6651,13 @@
 #if MEMORY_MAPPED_IO
     ret = *port;
 #else
-    ret = inl((int)port);
+    ret = inl((unsigned long)port);
 #endif
 
     if (ql_debug_print)
     {
         qla1280_print("qla1280_getdword: address = ");
-        qla1280_output_number((uint32_t)port, 16);
+        qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
         qla1280_output_number((uint32_t)ret, 16);
         qla1280_print("\n\r");
@@ -6359,13 +6675,13 @@
 #if MEMORY_MAPPED_IO
     *port = data;
 #else
-    outb(data, (int)port);
+    outb(data, (unsigned long)port);
 #endif
 
     if (ql_debug_print)
     {
         qla1280_print("qla1280_putbyte: address = ");
-        qla1280_output_number((uint32_t)port, 16);
+        qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
         qla1280_output_number((uint32_t)data, 16);
         qla1280_print("\n\r");
@@ -6384,14 +6700,14 @@
 #ifdef _LINUX_IOPORTS
     outw(data, (int)port);
 #else
-    outw((int)port, data);
+    outw((unsigned long)port, data);
 #endif
 #endif
 
     if (ql_debug_print)
     {
         qla1280_print("qla1280_putword: address = ");
-        qla1280_output_number((uint32_t)port, 16);
+        qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
         qla1280_output_number((uint32_t)data, 16);
         qla1280_print("\n\r");
@@ -6410,14 +6726,14 @@
 #ifdef _LINUX_IOPORTS
     outl(data,(int)port);
 #else
-    outl((int)port, data);
+    outl((unsigned long)port, data);
 #endif
 #endif
 
     if (ql_debug_print)
     {
         qla1280_print("qla1280_putdword: address = ");
-        qla1280_output_number((uint32_t)port, 16);
+        qla1280_output_number((unsigned long)port, 16);
         qla1280_print(" data = 0x");
         qla1280_output_number((uint32_t)data, 16);
         qla1280_print("\n\r");
@@ -6441,8 +6757,7 @@
 
 /*
  *  Out character to COM2 port.
- *      PORT must be at standard address for COM2 = 0x2F8,
- *      or COM1 = 0x3F8
+ *      PORT must be at standard address for COM1 = 0x3f8
  */
 #define OUTB(addr,data)   outb((data),(addr))
 
@@ -6452,7 +6767,7 @@
 #ifdef QL_DEBUG_CONSOLE
     printk("%c", c);
 #else
-    int     com_addr              = 0x2f8;
+    int     com_addr              = 0x3f8;
     int     hardware_flow_control = 1;
     int     software_flow_control = 0;
     uint8_t data;
@@ -6464,7 +6779,7 @@
     }while (!(data & BIT_6));
 
     /*
-    * Set BAUD rate for COM2 to 19200 (0x6)
+    * Set BAUD rate for COM2 to 9600 (0x6)
     */
 
     /* Select rate divisor. */
@@ -6660,8 +6975,6 @@
     qla1280_print(debug_buff);
     sprintf(debug_buff,"  Pid=%d, SP=0x%p\n\r", (int)cmd->pid, CMD_SP(cmd));
     qla1280_print(debug_buff);
-    sprintf(debug_buff,"  r_start=0x%lx, u_start=0x%lx\n\r",sp->r_start,sp->u_start);
-    qla1280_print(debug_buff);
     sprintf(debug_buff," underflow size = 0x%x, direction=0x%x, req.cmd=0x%x \n\r", cmd->underflow, sp->dir,cmd->request.cmd);    
     qla1280_print(debug_buff);
 }
@@ -6689,23 +7002,6 @@
 }
 #endif
 
-#ifdef  QLA1280_UNUSED 
-/**************************************************************************
- *   ql1280_dump_regs
- *
- **************************************************************************/
-static void qla1280_dump_regs(struct Scsi_Host *host)
-{
-    printk("Mailbox registers:\n");
-    printk("qla1280 : mbox 0 0x%04x \n", inw(host->io_port + 0x70));
-    printk("qla1280 : mbox 1 0x%04x \n", inw(host->io_port + 0x72));
-    printk("qla1280 : mbox 2 0x%04x \n", inw(host->io_port + 0x74));
-    printk("qla1280 : mbox 3 0x%04x \n", inw(host->io_port + 0x76));
-    printk("qla1280 : mbox 4 0x%04x \n", inw(host->io_port + 0x78));
-    printk("qla1280 : mbox 5 0x%04x \n", inw(host->io_port + 0x7a));
-}
-#endif
-
 
 
 #if  STOP_ON_ERROR 
@@ -6732,9 +7028,6 @@
     printk("HA flags =0x%lx\n", *fp);
     DEBUG2(ql_debug_print = 1;)
     /* DEBUG2(ql1280_dump_device((scsi_qla_host_t *) host->hostdata)); */
-#ifdef  QLA1280_UNUSED 
-    qla1280_dump_regs(host);
-#endif
     sti();  
     panic("Ooops");  
     /* cli(); 
@@ -6747,11 +7040,6 @@
 }
 #endif
 
-#ifdef  QLA1280_UNUSED 
-static void qla1280_set_flags(char * s)
-{
-}
-#endif
 
 /**************************************************************************
  *   qla1280_setup
@@ -6765,24 +7053,6 @@
 {
     char *end, *str, *cp;
 
-#ifdef  QLA1280_UNUSED 
-    static struct
-    {
-        const char *name;
-        int      siz;
-        void  (*func)();
-        int   arg;
-    } options[] =
-    {
-        { "dump_regs", 9,  &qla1280_dump_regs, 0 
-        },
-        { "verbose", 7, &qla1280_set_flags, 0x1 
-        },
-        { "",    0, NULL, 0 
-        }
-    };
-#endif
-
     printk("scsi: Processing Option str = %s\n", s);
     end = strchr(s, '\0');
     /* locate command */
@@ -6831,4 +7101,3 @@
  * tab-width: 8
  * End:
  */
-
diff -urN linux.orig/drivers/scsi/qla1280.h linux/drivers/scsi/qla1280.h
--- linux.orig/drivers/scsi/qla1280.h	Thu Jul 19 22:08:29 2001
+++ linux/drivers/scsi/qla1280.h	Mon Dec 17 20:27:41 2001
@@ -1,169 +1,35 @@
-/*************************************************************************
- *                  QLOGIC LINUX SOFTWARE
- *
- * QLogic ISP1x80/1x160 device driver for Linux 2.3.x (redhat 6.x).
- *
- * COPYRIGHT (C) 1996-2000 QLOGIC CORPORATION    
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the Qlogic's Linux Software License.
- *
- * This program is WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistribution's or source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification, immediately at the beginning of the file.
- * 2. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- *****************************************************************************/
- 
-/*************************************************************************************
-			QLOGIC CORPORATION SOFTWARE
-           "GNU" GENERAL PUBLIC LICENSE
-    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION
-                 AND MODIFICATION
-
-This GNU General Public License ("License") applies solely to QLogic Linux 
-Software ("Software") and may be distributed under the terms of this License.  
- 
-1. You may copy and distribute verbatim copies of the Software's source code as 
-you receive it, in any medium, provided that you conspicuously and appropriately 
-publish on each copy an appropriate copyright notice and disclaimer of warranty;
-keep intact all the notices that refer to this License and to the absence of any
-warranty; and give any other recipients of the Software a copy of this License along
-with the Software. 
-
-You may charge a fee for the physical act of transferring a copy, and you may at your
-option offer warranty protection in exchange for a fee.
- 
-2. You may modify your copy or copies of the Software or any portion of it, thus forming
-a work based on the Software, and copy and distribute such modifications or work under
-the terms of Section 1 above, provided that you also meet all of these conditions:
- 
-* a) You must cause the modified files to carry prominent notices stating that you
-changed the files and the date of any change. 
-
-* b) You must cause any work that you distribute or publish that in whole or in part
-contains or is derived from the Software or any part thereof, to be licensed as a
-whole at no charge to all third parties under the terms of this License. 
-
-* c) If the modified Software normally reads commands interactively when run, you
-must cause it, when started running for such interactive use in the most ordinary way,
-to print or display an announcement including an appropriate copyright notice and a 
-notice that there is no warranty (or else, saying that you provide a warranty) and that
-users may redistribute the Software under these conditions, and telling the user how to
-view a copy of this License. (Exception:if the Software itself is interactive but does 
-not normally print such an announcement, your work based on the Software is not required
-to print an announcement.) 
-
-These requirements apply to the modified work as a whole. If identifiable sections of
-that work are not derived from the Software, and can be reasonably considered independent
-and separate works in themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works. But when you distribute the same
-sections as part of a whole which is a work based on the Software, the distribution of the
-whole must be on the terms of this License, whose permissions for other licensees extend
-to the entire whole, and thus to each and every part regardless of who wrote it. 
-
-3. You may copy and distribute the Software (or a work based on it, under Section 2) in 
-object code or executable form under the terms of Sections 1 and 2 above provided that
-you also do one of the following: 
-
-* a) Accompany it with the complete corresponding machine-readable source code, which must
-be distributed under the terms of Sections 1 and 2 above on a medium customarily used for
-software interchange; or, 
-
-* b) Accompany it with a written offer, valid for at least three years, to give any third
-party, for a charge no more than your cost of physically performing source distribution,
-a complete machine-readable copy of the corresponding source code, to be distributed under
-the terms of Sections 1 and 2 above on a medium customarily used for software interchange;
-or,
-
-* c) Accompany it with the information you received as to the offer to distribute 
-corresponding source code. (This alternative is allowed only for noncommercial distribution
-and only if you received the Software in object code or executable form with such an offer,
-in accord with Subsection b above.) 
-
-The source code for a work means the preferred form of the work for making modifications
-to it. For an executable work, complete source code means all the source code for all 
-modules it contains, plus any associated interface definition files, plus the scripts used
-to control compilation and installation of the executable.     
-
-If distribution of executable or object code is made by offering access to copy from a 
-designated place, then offering equivalent access to copy the source code from the same
-place counts as distribution of the source code, even though third parties are not 
-compelled to copy the source along with the object code. 
-
-4. You may not copy, modify, sublicense, or distribute the Software except as expressly 
-provided under this License. Any attempt otherwise to copy, modify, sublicense or 
-distribute the Software is void, and will automatically terminate your rights under this
-License. However, parties who have received copies, or rights, from you under this License
-will not have their licenses terminated so long as such parties remain in full compliance. 
-
-5. This license grants you world wide, royalty free non-exclusive rights to modify or 
-distribute the Software or its derivative works. These actions are prohibited by law 
-if you do not accept this License. Therefore, by modifying or distributing the Software
-(or any work based on the Software), you indicate your acceptance of this License to do
-so, and all its terms and conditions for copying, distributing or modifying the Software
-or works based on it.
- 
-6. Each time you redistribute the Software (or any work based on the Software), the 
-recipient automatically receives a license from the original licensor to copy, distribute
-or modify the Software subject to these terms and conditions. You may not impose any 
-further restrictions on the recipients' exercise of the rights granted herein. You are
-not responsible for enforcing compliance by third parties to this License.
- 
-7. If, as a consequence of a court judgment or allegation of patent infringement or for
-any other reason (not limited to patent issues), conditions are imposed on you 
-(whether by court order, agreement or otherwise) that contradict the conditions of this
-License, they do not excuse you from the conditions of this License. If you cannot 
-distribute so as to satisfy simultaneously your obligations under this License 
-and any other pertinent obligations, then as a consequence you may not distribute the
-Software at all.    
-
-If any portion of this section is held invalid or unenforceable under any particular 
-circumstance, the balance of the section is intended to apply and the section as a whole
-is intended to apply in other circumstances. 
-NO WARRANTY
-
-11. THE SOFTWARE IS PROVIDED WITHOUT A WARRANTY OF ANY KIND. THERE IS NO 
-WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. 
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR 
-OTHER PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, 
-EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
-ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. 
-SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL 
-NECESSARY SERVICING, REPAIR OR CORRECTION.
- 
-12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
-REDISTRIBUTE THE SOFTWARE AS PERMITTED ABOVE, BE LIABLE TO YOU FOR 
-DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL 
-DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING 
-BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR 
-LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO 
-OPERATE WITH ANY OTHER SOFTWARES), EVEN IF SUCH HOLDER OR OTHER PARTY HAS 
-BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
-END OF TERMS AND CONDITIONS 
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP1280 (Ultra2) /12160 (Ultra3) SCSI driver
+* Copyright (C) 2000 Qlogic Corporation 
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+**
+******************************************************************************/
 
-*************************************************************************************/ 
-
- 
 #ifndef _IO_HBA_QLA1280_H           /* wrapper symbol for kernel use */
 #define _IO_HBA_QLA1280_H           /* subject to change without notice */
 
+
+#ifndef LINUX_VERSION_CODE 
+#include <linux/version.h>
+#endif  /* LINUX_VERSION_CODE not defined */
+
 #if defined(__cplusplus)
 extern "C" {
 #endif
 
-#include <linux/version.h>
-
+#ifndef HOSTS_C                     /* included in hosts.c */
 /*
  * Enable define statement to ignore Data Underrun Errors,
  * remove define statement to enable detection.
@@ -173,15 +39,18 @@
 /*
  * Driver debug definitions.
  */
-/* #define QL_DEBUG_LEVEL_1 */       /* Output register accesses to COM2. */
-/* #define QL_DEBUG_LEVEL_2 */           /* Output error msgs to COM2. */
-/* #define QL_DEBUG_LEVEL_3 */          /* Output function trace msgs to COM2. */
-/* #define QL_DEBUG_LEVEL_4 */       /* Output NVRAM trace msgs to COM2. */
-/* #define QL_DEBUG_LEVEL_5 */         /* Output ring trace msgs to COM2. */
-/* #define QL_DEBUG_LEVEL_6 */      /* Output WATCHDOG timer trace to COM2. */
-/* #define QL_DEBUG_LEVEL_7 */      /* Output RISC load trace msgs to COM2. */
+/* #define QL_DEBUG_LEVEL_1 */      /* Output register accesses to COM1 */
+/* #define QL_DEBUG_LEVEL_2 */       /* Output error msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_3 */      /* Output function trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_4 */       /* Output NVRAM trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_5 */      /* Output ring trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_6 */      /* Output WATCHDOG timer trace to COM1 */
+/* #define QL_DEBUG_LEVEL_7 */      /* Output RISC load trace msgs to COM1 */
+
+#define QL_DEBUG_CONSOLE    /* Output to console instead of COM1   */
+  /* comment this #define to get output of qla1280_print to COM1         */
+  /* if COM1 is not connected to a host system, the driver hangs system! */
 
-#define QL_DEBUG_CONSOLE              /* Output to console instead of COM2. */
 
 #ifndef TRUE
 #  define TRUE 1
@@ -206,7 +75,11 @@
  * Locking
  */
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,0)
-#  include <linux/spinlock.h>
+#  if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+#    include <asm/spinlock.h>
+#  else
+#    include <linux/spinlock.h>
+#  endif
 #  include <linux/smp.h>
 #  define cpuid smp_processor_id()
 #  if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
@@ -314,12 +187,12 @@
 #define WRT_REG_DWORD(addr, data) qla1280_putdword((uint32_t *)addr, data)
 #else  /* QL_DEBUG_LEVEL_1 */
 #ifdef MEMORY_MAPPED_IO
-       #define RD_REG_BYTE(addr)         readb((unsigned long) (addr)
-       #define RD_REG_WORD(addr)         readw((unsigned long) (addr)
-       #define RD_REG_DWORD(addr)        readl((unsigned long) (addr)
-       #define WRT_REG_BYTE(addr, data)  writeb((data), (unsigned long) (addr))
-       #define WRT_REG_WORD(addr, data)  writew((data), (unsigned long) (addr))
-       #define WRT_REG_DWORD(addr, data) writel((data), (unsigned long) (addr))
+      #define RD_REG_BYTE(addr)         (*((volatile uint8_t *)addr))
+       #define RD_REG_WORD(addr)         (*((volatile uint16_t *)addr))
+       #define RD_REG_DWORD(addr)        (*((volatile uint32_t *)addr))
+       #define WRT_REG_BYTE(addr, data)  (*((volatile uint8_t *)addr) = data)
+       #define WRT_REG_WORD(addr, data)  (*((volatile uint16_t *)addr) = data)
+       #define WRT_REG_DWORD(addr, data) (*((volatile uint32_t *)addr) = data) 
 #else   /* MEMORY_MAPPED_IO */
 #define RD_REG_BYTE(addr)         (inb((unsigned long)addr))
 #define RD_REG_WORD(addr)         (inw((unsigned long)addr))
@@ -374,7 +247,8 @@
 typedef struct timer_list   timer_t;         /* timer */
 
 /*
- * SCSI Request Block structure
+ * SCSI Request Block structure  (sp)  that is placed
+ * on cmd->SCp location of every I/O
  */
 typedef struct srb
 {
@@ -383,10 +257,11 @@
     struct srb  *s_prev;             /* (4) Previous block on LU queue */
     uint8_t     flags;               /* (1) Status flags. */
     uint8_t     dir;                 /* direction of transfer */
-    uint8_t     unused[2];
-    u_long      r_start;             /* jiffies at start of request */
-    u_long      u_start;             /* jiffies when sent to F/W    */
-}srb_t;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+    dma_addr_t  saved_dma_handle;    /* for unmap of single transfers */
+#endif
+   
+} srb_t;
 
 /*
  * SRB flag definitions
@@ -1564,22 +1439,35 @@
 
     request_t       req[REQUEST_ENTRY_CNT+1];
     response_t      res[RESPONSE_ENTRY_CNT+1];
-    unsigned long   request_dma;        /* Physical address. */
+#if BITS_PER_LONG > 32
+    dma_addr_t      request_dma;        /* Physical Address */
+#else
+    uint32_t        request_dma;        /* Physical address. */
+#endif
     request_t       *request_ring;      /* Base virtual address */
     request_t       *request_ring_ptr;  /* Current address. */
     uint16_t        req_ring_index;     /* Current index. */
     uint16_t        req_q_cnt;          /* Number of available entries. */
 
-    unsigned long   response_dma;       /* Physical address. */
+#if BITS_PER_LONG > 32
+    dma_addr_t      response_dma;       /* Physical address. */
+#else
+    uint32_t        response_dma;       /* Physical address. */
+#endif
     response_t      *response_ring;     /* Base virtual address */
     response_t      *response_ring_ptr; /* Current address. */
     uint16_t        rsp_ring_index;     /* Current index. */
 
 #if QL1280_TARGET_MODE_SUPPORT
     /* Target buffer and sense data. */
+#if BITS_PER_LONG > 32
+    dma_addr_t      tbuf_dma;           /* Physical address. */
+    dma_addr_t      tsense_dma;         /* Physical address. */
+#else
     uint32_t        tbuf_dma;           /* Physical address. */
-    tgt_t           *tbuf;
     uint32_t        tsense_dma;         /* Physical address. */
+#endif
+    tgt_t           *tbuf;
     uint8_t         *tsense;
 #endif
 
@@ -1616,8 +1504,13 @@
        uint32_t     dpc                     :1;   /* 15 */
        uint32_t     dpc_sched               :1;   /* 16 */
        uint32_t     interrupts_on               :1;   /* 17 */
+       uint32_t     bios_enabled               :1;   /* 18 */
     }flags;
 
+  /* needed holders for PCI ordered list of hosts */
+  unsigned long io_port;
+  uint32_t irq;
+
 }scsi_qla_host_t;
 
 /*
@@ -1646,6 +1539,8 @@
 #define QLA1280_RING_LOCK(ha)  
 #define QLA1280_RING_UNLOCK(ha)   
 
+#endif  /* HOSTS_C */
+
 #if defined(__cplusplus)
 }
 #endif
@@ -1663,49 +1558,20 @@
 int qla1280_biosparam(Disk *, kdev_t, int[]);
 void qla1280_intr_handler(int, void *, struct pt_regs *);
 void qla1280_setup(char *s, int *dummy);
-#if defined(__386__)
+
 #  define QLA1280_BIOSPARAM  qla1280_biosparam
-#else
-#  define QLA1280_BIOSPARAM  NULL
-#endif
 
 /*
  * Scsi_Host_template (see hosts.h) 
  * Device driver Interfaces to mid-level SCSI driver.
  */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
-/* This interface is now obsolete !!! */ 
-#define QLA1280_LINUX_TEMPLATE {		                 \
-        next:           NULL,                                    \
-        usage_count:    NULL,                                    \
-	proc_dir:		NULL,          	                 \
-	proc_info:		NULL,	                         \
-	name:			"Qlogic ISP 1280",               \
-	detect:			qla1280_detect,	                 \
-	release:		qla1280_release,                 \
-	info:			qla1280_info,	                 \
-        command:        NULL,                                    \
-	queuecommand:	qla1280_queuecommand,	                 \
-	abort:			qla1280_abort,	                 \
-	reset:			qla1280_reset,	                 \
-        slave_attach:   NULL,                                    \
-	bios_param:		QLA1280_BIOSPARAM,               \
-	can_queue:		255, /* MAX_OUTSTANDING_COMMANDS */   \
-	this_id:		-1,  /* scsi id of host adapter */        \
-	sg_tablesize:	SG_ALL,	 \
-	cmd_per_lun:	3,	  /* max commands per lun */	       \
-	present:	    0,    /* number of 1280s present */	       \
-	unchecked_isa_dma: 0, /* no memeory DMA restrictions */    \
-	use_clustering:	ENABLE_CLUSTERING			               \
-}
-#else
 
-#define QLA1280_LINUX_TEMPLATE {		                 \
+#define QLA1280_LINUX_TEMPLATE {		                \
 	next: NULL,						\
 	module: NULL,						\
 	proc_dir: NULL,						\
 	proc_info: qla1280_proc_info,				\
-	name:			"Qlogic ISP 1280\1080",               \
+	name:			"Qlogic ISP 1280\12160",        \
 	detect: qla1280_detect,					\
 	release: qla1280_release,				\
 	info: qla1280_info,					\
@@ -1725,13 +1591,14 @@
 	this_id: -1,		/* scsi id of host adapter    */\
 	sg_tablesize: SG_ALL,	/* max scatter-gather cmds    */\
 	cmd_per_lun: 3,		/* cmds per lun (linked cmds) */\
-	present: 0,		/* number of 7xxx's present   */\
+	present: 0,		/* number of 1280's present   */\
 	unchecked_isa_dma: 0,	/* no memory DMA restrictions */\
 	use_clustering: ENABLE_CLUSTERING,			\
 	use_new_eh_code: 0,					\
 	emulated: 0					        \
 }
-#endif
+
 
 
 #endif /* _IO_HBA_QLA1280_H */
+
diff -urN linux.orig/drivers/scsi/qla2x00.c linux/drivers/scsi/qla2x00.c
--- linux.orig/drivers/scsi/qla2x00.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/qla2x00.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,12823 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic QLA2x00 device driver for Linux 2.2.x and 2.4.x 
+* Copyright (C) 2000 and 2001         Qlogic Corporation 
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+**
+******************************************************************************/
+#define QLA2100_VERSION      "4.31.7b"
+/****************************************************************************
+Revision History:
+    Rev. 4.31.7b		June 8, 2001		DG QLogic
+	- Fixed issue when loop id for target is changed to a different
+	 loop id.
+    Rev. 4.31.6		June 1, 2001		DG QLogic
+        - Official 2200 firmware: v2.01.34
+        - Official 2300 firmware: v3.00.24
+    Rev. 4.31.5b	May 30, 2001		DG QLogic
+	- Reset SRB_SENT flag in all isr routines.
+	- Fix displaying garbage when using /proc.
+    Rev. 4.31.3b	May 15, 2001		DG QLogic
+        - Using test 2200 firmware: v204.01.33
+    Rev. 4.31.2b	May 15, 2001		DG QLogic
+        - Using test 2200 firmware: v203.01.33
+    Rev. 4.31.1b	May 15, 2001		DG QLogic
+        - Upgrade FC firmware to: 2200 v209.01.27
+	- Changed logic to handle a topology of 4 after issuing the
+	  "Get Host loop id".
+    Rev. 4.31b		May 15, 2001		RL QLogic
+	- Added code to export PCI device info via a new ioctl function
+	  in kernel 2.4.4.
+	- Redirect console messages to the OS messages file only.
+	- Additional fix in ioctl functions for node/port name endianess
+	  problem.
+    Rev. 4.30b		May 3, 2001		RL QLogic
+	- Moved the allocation of host database to outside of the adapter
+	  structure allocation to avoid the allocation size limitation in the
+	  scsi_register function.
+    Rev. 4.29b		April 27, 2001		RL QLogic
+	- Fixed endianess of the node and port names read from the config
+	  file for persistent binding entries.
+    Rev. 4.28b		April 26, 2001		DG QLogic
+	- Fixed persistent binding of target devices.
+    Rev. 4.27		April 26, 2001		DG QLogic
+	- Fixed Mailbox timeout logic
+	- Fixed to compile on 2.4.x RedHat systems.
+    Rev. 4.25 	         March 15, 2001    DG QLogic
+	- released
+    Rev. 4.25 Beta       March 9, 2001    DG QLogic
+	- incl new qlavendor.c file.
+    Rev. 4.24 Beta Test32  February 22, 2001    BN QLogic
+        - Added code for scanning of missing LUN to let the
+          SCSI layer skip it.
+        - Revised init_cb_t structure in qla2x00.h for the new
+          QLA2300 as well as QLA2200 devices.
+        - Changed criteria of 64/32 Bit mode of HBA
+          operation according to BITS_PER_LONG rather
+          than HBA's NVRAM setting of >4Gig memory bit;
+          so that the HBA auto-configures without the need
+          to setup each system individually.
+        - Merged changes for proper compile and operation in Alpha systems.
+        - Upgrade FC firmware to: QLA2300 v3.00.18 *new
+          and enabled FC Loopback test on QLA2300 HBAs.
+        - Add statistics counters and IOCTL support for
+          HBA Error Count, LIP Resets, and total ISR count.
+        - Changed qla2100_reinit on loop down after 4 minutes 
+          specific to QLA2100 HBAs only.
+        - Added code and Makefile option to handle RISC code 
+          download differently for ia-64 platforms than x86 or alpha.
+    Rev. 4.23 Beta       January 12, 2001    BN QLogic
+        - Use cmd->sc_data_direction for setting of HBA data transfer
+          direction for 2.4.0 and higher kernels.
+          Note: Users must set the reply_len in sg_header.
+                For Writes and no data transfer; reply_len should
+                be the lenght of sg_header.
+                For Reads, reply_len should be the length of sg_header
+                plus the number of bytes to be read.
+        - Added check of SCSI_RESET_SUGGEST_BUS_RESET during 
+          qla2100_reset() and perform BUS_RESET. 
+          Also perform DEVICE_RESET on else of flag checking.
+        - Added new /proc/scsi/qla2x00/HbaApiNode for IOCTL interface
+          for 2.4.x kernels; so driver can be accessed with out need
+          to have at least one mapped scsi drive.
+        - Modified qla2100_mailbox_command's second parameter
+          to 32 bits for use by Loop-Back Diagnostic function
+        - Increase MAILBOX_REGISTER_COUNT to 32
+        - Added Loop-Back Diagnostic function to qla2x00ioctl.c
+          for QLA2200 HBAs only.
+        - Order HBA detection as follows:
+          QLA2300, QLA2200, QLA2100.
+        - Changed queue_task() to queue_task_irq() in 
+          qla2100_intr_handler() for proper usage.
+        - In qla2100_register_with_Linux() put check and getting 
+          device iobase before registering of interrupt with Linux;
+          to help with driver loading/unloading when ramdisk is also loaded.
+        - Change IOCTL support to SDM_VERSION 5 in qla2x00ioctl.c
+          to be support SNIA HBA API 1.0 Library
+        - Upgrade FC firmware to: QLA2200 v2.01.27 *new
+                                  QLA2300 v3.00.17 *new
+        - Added copy of HBA Serial Number to /proc entry
+        - Added sigmask(SIGKILL) as second parameter to 
+          siginitsetinv() function called during qla2100_do_dpc();
+          so that the driver can be unloaded for 2.4.0 kernels.
+    Rev. 4.22 Beta       November 22, 2000    BN QLogic
+        - Change IOCTL support to SDM_VERSION 4 in qla2x00_v4_ioctl.c
+          to be compatible with ln_rel-1.0Beta API library
+    Rev. 4.21 Beta       November 15, 2000    BN QLogic
+        - Upgrade FC firmware to: 2100 v1.19.16
+                                  2200 v2.01.24
+                                  2300 v3.00.12
+        - Merge of qla2x00 driver 2.19.16Beta changes.
+        - Updated qlavendor.c for vendor unique command
+          decoding. 
+    Rev. 4.20 Beta       October 17, 2000    BN QLogic
+        - QLA2300 Support added.
+    Rev. 4.14 Beta       October 16, 2000    BN QLogic
+        - Added setting of higher address bits for
+          MBC_INITIALIZE_FIRMWARE operation.
+        - Release also contains newer qlavendor.c file
+        - Move to the new SCSI initialization scheme
+          and always declare the static driver_template
+          for kernels 2.4.0 and higher
+    Rev. 4.13 Beta       September 21, 2000    BN QLogic
+        - Added "quiet" option to keep from printing LIP
+          occurred messages on systems that specify it.
+        - Added option to choose tp or ef, FC firmware
+    Rev. 4.12 Beta       September 18, 2000    BN QLogic
+        - Added pci_set_master() to qla2100_pci_config
+          function to make sure all systems are supported
+    Rev. 4.11 Beta       September 6, 2000    BN QLogic
+        - Enabled IOCTLs for external IOCTL and APIs
+    Rev. 4.10 Beta       August 28, 2000      BN Qlogic
+        - Use new PCI DMA mapping APIs for 2.4.x kernel
+        - Added driver IOCTL support code; but disabled
+          it with #if 0 for next release
+        - Verified correct 64 bit addressing with NVRAM:
+          enable_64bit_addressing (>4GByte Addressing)
+          enabled in BIOS advanced settings option.
+    Rev. 4.0           July  24, 2000      BN Qlogic
+        - Added FC Tape Support by use of new FC Firmware
+             ql2100_fw.h   must be  v1.19.12  or greater
+             ql2200_fw.h   must be  v2.01.16  or greater
+        - Corrected HBA Node Name equal to zero 
+        - Changed QLBoardTbl to QLBoardTbl_fc to avoid
+          double definition error with regards to qla1280
+          on new 2.4.0 kernel build tools
+    Rev. 3.90 Beta     July  21, 2000      BN Qlogic
+	- Added 64 bit OS and IA-64 hardware support
+        - Move to new major revision number
+    Rev. 2.22         July  14, 2000      BN Qlogic
+	- Updated 2100 FW to  1.19.10
+	- Updated 2200 FW to  2.01.14
+	- Move version to 2.22 for release to DVT
+    Rev. 2.19.8       July  11, 2000      DG Qlogic
+    - Fixed 2100 issue of login retry when no fabric is attached.
+    Rev. 2.19.7       July  6, 2000      DG
+    - Set queue depth per lun to 16 instead of throttle which is a
+      port max queue size and added an option "ql2xmaxqdepth=xx"
+      to allow user to change queue depth. This prevents us from
+      exceeding the adapter's throttle size which causes requests
+      to sit in the input queue for long periods of time.
+    Rev. 2.19.6       June  28, 2000      DG Qlogic
+    - GA release 
+    - Fixed panic in putq_t routine when called from abort.
+    Rev. 2.19.5b7     June  27, 2000      DG
+    - Add logic to wait reset delay if no fabric devices are found.
+    Rev. 2.19.5b6     June  26, 2000      DG
+    - Fixed Fw ready issue.
+    - Clear sent flag in SRB, so we will abort commands in Lun
+      queue that were previously sent.
+    - Flush input queue when an isp_abort occurs.
+    Rev. 2.19.5b5     June  16, 2000      DG
+    - Fixed issue of not holding off request if multiple RSCN or
+      PORT updates occur while process the currect RSCN.
+    Rev. 2.19.5b4     June  16, 2000      DG
+    - Added lock for done_q to prevent losing requests in timer.
+    Rev. 2.19.5b3     June  16, 2000      DG
+    - Added routine to set the correct direction for vendor specific
+      commands. Set the new option "QLA_SCSI_VENDOR_DIR".
+    - Fixed issue of retrying continuously on a Missing SCSI device.
+    - Fixed multiple adapter issue. Only login into adapter node 
+      once and never again. 
+    - Change code not to use loop id 0 for Fabric nodes. 
+    Rev. 2.19.5b2     June  15, 2000      DG
+    - Added code to reset port down count on good requests.
+    Rev. 2.19.5       June  8, 2000      DG
+    - Added code to display the connection type F, FL, or N.
+    - Reaarange code in DPC routine to put "retry login"
+      further  down in the routine and skip is loop is down.
+    - Check the returned status after GAN (qla2100_sns_device)
+      and retry on ISP TX timeout (0x4005).
+    Rev. 2.19.4       June  6, 2000      DG
+    - Fixed for panic that occurs when system is shutdown.
+    Rev. 2.19.3       June  5, 2000      DG
+    - Fixed retry logic for user configured targets.
+    Rev. 2.19.2       May  31, 2000      DG
+    - Remove spinlock in qla2100_timer.
+    - Change the jiffies timer to loop timer in fw_ready. 
+    Rev. 2.19.1       May  6, 2000      DG
+    - Change risc code 2200 from 2.1.12 to 2.1.13 to correct issue
+      of getting mailbox timeouts.
+    - Change mailbox timer to get correct timeout.
+    - Added qla2100_cmd_wait to wait for outstanding commands to
+      complete before querying the name server after a LIP.  
+    Rev. 2.19         May  6, 2000      DG
+    - Fixed mailbox timeout recovery logic.
+    Rev. 2.18         May  1, 2000      DG
+    - Changes from Fabric testing
+    Rev. 2.18b4       Apr 21, 2000      DG
+    - Fixed login retry count to retry count.
+    - If the loop is down for more than 4 minutes then restart 
+      queues and reset adpater if enabled.
+    - In qla2100_queuecommand we no longer return new requests 
+      immediately back to kernel when loop is down. This causes
+      SYSTEM to HANG when a lot of requests are outstanding. We 
+      now put them in the done queue and let the DPC routine 
+      return them to kernel.
+    - Fixed panic cause by changing the timeout value of new request
+      when the loop is down. 
+    - Cleanup qla2100_next.
+    Rev. 2.18b3       Apr 18, 2000      DG
+    - After the GAN, check returned status in resp buffer.
+    Rev. 2.18b2       Apr 12, 2000      DG
+    - Added handling of firmware bug when we use connection mode
+      1 (P2P). The firmware tries to change to loop mode after
+      encountering some IO failures/resets.
+    - Added logic to reset all modules during a chip reset.
+    - After the GAN, if we lost devices or have a device that was 
+      configured by the user then retry the login. This is a 
+      work-a-round for Brocade switches. It sometimes does
+      not return all the devices in the port list.
+    Rev. 2.18b1     Apr 1, 2000      DG
+    - Added logic to ignore device types other than FL/F 
+      from gan list. Mcdata switch returns a bogus port of
+      type 85 in the list.
+    - Added firmware 2.1.11 to fix issues with reusing loop ids.
+    Rev. 2.17       Mar 21, 2000      DG
+    - Fixed mailbox timeout timer.
+    - Added counters to record timeouts and aborts.
+    Rev. 2.16       Mar 8, 2000      DG
+    - Fixed Profiling code to reduced output of inactive devices.
+    - Fixed driver name in "/proc/scsi/qla2x00" instead of "qla".
+    - Fixed extended timeout value for loop down retries.
+    - Fixed code that search for target binding in command line to search
+      for all occurences instead of the first four.
+    - Disable the reinit of adapter when the LOOP is DOWN
+      for more than 4 minutes. It can be enabled with the command
+      line option "reinit_on_loopdown".
+    - Fixed issue of not setting HBA instance number before
+      calling HBA initialized.
+    Rev. 2.15       Feb 19, 2000      DG
+    - Fixed 2100 issue of driver not seeing storage when switch is connected
+      to loop.
+    Rev. 2.14       Feb 11, 2000      DG
+    - Added new logic to accept persistent binding information from the command line.
+    - Modified command parser to handle properties on the command line after
+      the regular options.
+    Rev. 2.13       Jan 27, 2000      TT
+    - Modify to use makefile parameter "IP=1" to enanle IP support.
+    - Fix SNS mailbox cmd parameter in qla2x00_register_ip_device.
+    - Reverse byte order on ha->port_id to match NT and fix compare bugs.
+    Rev. 2.12       Jan 26, 2000      TT+DG
+    - Updated Qlogic Linux sofware license.
+    - Added IP support for qla2xip driver.
+    - Fix host adapter structure initialization in qla2100_detect.
+    - Fix port name byte order in qla2100_update_fc_db.
+    - Fix the issue of not returning "NO_CONNECT" back to the user
+      when the loop is down after the loop down timer has expired.
+    - Added option QLA2100_EXT_TIMEOUT to extend timeout of each command.
+      default if OFF.
+    - Change device high water mark (hiwat) to execution throttle.
+    Rev. 2.11       Dec 8, 1999       DG
+    - Added Qlogic Linux sofware license.
+    Rev. 2.10       Oct 31, 1999      DG
+    - Fixed issue of not releasing requests if port is down (DPC issue).
+    - Ignore BIOS setting for MAX number of luns unless USE_BIOS_MAX_LUNS
+    is set.
+*****************************************************************************/
+  
+/*
+* Compile time Options:
+*            0 - Disable and 1 - Enable
+*/
+#define  QL2100_TARGET_MODE_SUPPORT    0   /* Target mode support */
+#define  MEMORY_MAPPED_IO              0
+#define  DEBUG_QLA2100_INTR            0
+#define  USE_NVRAM_DEFAULTS	       0
+#define  DEBUG_PRINT_NVRAM             0
+#define  LOADING_RISC_ACTIVITY         0
+#define  AUTO_ESCALATE_RESET           0   /* Automatically escalate resets */
+#define  AUTO_ESCALATE_ABORT           0   /* Automatically escalate aborts */
+#define  STOP_ON_ERROR                 0   /* Stop on aborts and resets  */
+#define  STOP_ON_RESET                 0
+#define  STOP_ON_ABORT                 0
+#define  QLA2100_COMTRACE              0    /* One char tracing  */
+#define  WATCH_THREADS_SIZ             0    /* watch size of pending queue */
+#define  USE_PORTNAME                  1    /* option to use port names for targets */
+#define  QLA2100_EXT_TIMEOUT           0    /* Extend timeout for commands up to 1 min*/
+#define  LUN_MASKING                   0
+#define  USE_FLASH                     0
+#define  QLA2100_PROFILE               1
+#define  QLA_SCSI_VENDOR_DIR           0 /* Decode vendor specific opcodes for direction */
+#define QLA2100_LIPTEST    	       0
+#define REQ_TRACE    		       1
+
+#undef   TRACECODE                       /* include tracing code in watchdog routines */
+#define  CHECK_BINDING
+
+#define  DEBUG_QLA2100                 0  /* For Debug of qla2x00 */
+#define  DEBUG_GET_FW_DUMP             0  /* also set DEBUG_QLA2100 and 
+                                             use COM1 and capture it */
+#define  USE_TP_FW                     1  /* use tp or ef firmware */
+
+/* The following WORD_FW_LOAD is defined in Makefile for ia-64 builds
+   and can also be decommented here for Word by Word confirmation of
+   RISC code download operation */
+/* #define  WORD_FW_LOAD               0  */
+
+/*
+* String arrays
+*/
+#define LINESIZE    256
+#define MAXARGS      26
+ 
+/*
+* Include files
+*/
+#include <linux/config.h>
+#ifdef MODULE
+#include <linux/module.h>
+#endif
+
+#ifndef LINUX_VERSION_CODE
+#include <linux/version.h>
+#endif  /* LINUX_VERSION_CODE not defined */
+
+static int num_hosts;           /* ioctl related  */
+static int apiHBAInstance = 0;  /* ioctl related keeps track of API HBA Instance */
+
+
+#include <stdarg.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/segment.h>
+#include <asm/byteorder.h>
+#include <asm/pgtable.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/blk.h>
+#include <linux/tqueue.h>
+#include <linux/interrupt.h>
+
+
+#ifndef KERNEL_VERSION
+#  define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+#define  APIDEV        1
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+#include <linux/tasks.h>
+# include <linux/bios32.h>
+#else
+/*#include <asm/spinlock.h>*/
+
+#define __KERNEL_SYSCALLS__
+
+#include <linux/unistd.h>
+#include <linux/smp_lock.h>
+
+#include <asm/system.h>
+#define SHUTDOWN_SIGS	(sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM))
+#endif
+#include "sd.h"
+#include "scsi.h"
+#include "hosts.h"
+
+#ifdef FC_IP_SUPPORT
+#include <linux/skbuff.h>
+#include "qlcommon.h"
+#endif
+
+#include "qla2x00.h"
+#define UNIQUE_FW_NAME                 /* unique F/W array names */
+#ifdef UNIQUE_FW_NAME
+#include "ql2100_fw.h"                     /* ISP RISC code */
+#ifdef FC_IP_SUPPORT
+#include "ql2200ip_fw.h"                   /* ISP RISC 2200 code */
+#include "ql2300ip_fw.h"                   /* ISP RISC 2300 code */
+#else
+#include "ql2200_fw.h"                     /* ISP RISC 2200 code */
+#include "ql2300_fw.h"                     /* ISP RISC 2300 code */
+#endif
+#else
+#include "isp_fw.h"                     /* ISP RISC code */
+#include "isp1_fw.h"                     /* ISP RISC 2200 code */
+#endif
+#include <linux/stat.h>
+#include <linux/malloc.h>       
+
+
+#define  BZERO(ptr, amt)	memset((void *)(ptr), 0, amt)
+#define  BCMP(s1, s2, amt)	memcmp((void *)(s1), (void *)(s2), amt)
+#define  BCOPY(src, dst, amt)	memcpy((void *)(dst), (void *)(src), amt)
+#define  KMALLOC(siz)		kmalloc((siz), GFP_ATOMIC | GFP_DMA)
+#define  KMFREE(ip,siz)		kfree((ip))
+#define  SYS_DELAY(x)		udelay(x);barrier()
+#define  QLA2100_DELAY(sec)	mdelay(sec * HZ)
+
+/* 4.10 */
+#if  BITS_PER_LONG > 32
+#define pci_dma_lo32(a) (a & 0xffffffff)
+#define pci_dma_hi32(a) ((a >> 32) & 0xffffffff)
+#else
+#define pci_dma_lo32(a) (a & 0xffffffff)
+#define pci_dma_hi32(a) 0
+#endif
+
+#define  VIRT_TO_BUS(a) virt_to_bus((a))
+
+#if  BITS_PER_LONG <= 32
+#define  VIRT_TO_BUS_LOW(a) (uint32_t)virt_to_bus(((void *)a))
+#define  VIRT_TO_BUS_HIGH(a) (uint32_t)(0x0)
+#else
+#define  VIRT_TO_BUS_LOW(a) (uint32_t)(0xffffffff & virt_to_bus((void *)(a)))
+#define  VIRT_TO_BUS_HIGH(a) (uint32_t)(0xffffffff & (virt_to_bus((void *)(a))>>32))
+#endif
+
+#define  CACHE_FLUSH(a) (RD_REG_WORD(a))
+#define  INVALID_HANDLE    (MAX_OUTSTANDING_COMMANDS+1)
+
+#define  STATIC
+
+#if  BITS_PER_LONG <= 32
+#define  LS_64BITS(x) (uint32_t)((unsigned long)x)
+#define  MS_64BITS(x) (uint32_t)((unsigned long) 0x0)
+#else
+#define  LS_64BITS(x) (uint32_t)(0xffffffff & ((unsigned long)x))
+#define  MS_64BITS(x) (uint32_t)(0xffffffff & (((unsigned long)x)>>32) )
+#endif
+
+#if  BITS_PER_LONG <= 32
+#define  MSB(x)          (uint8_t)(((uint16_t)(x) >> 8) & 0xff)
+#define  LSB(x)          (uint8_t)(x & 0xff)
+#define  MSW(x)          (uint16_t)(((uint32_t)(x) >> 16) & 0xffff)
+#define  LSW(x)          (uint16_t)(x & 0xffff)
+#define  QL21_64BITS_3RDWD(x)   ((uint16_t) 0)
+#define  QL21_64BITS_4THWD(x)   ((uint16_t) 0)
+#else
+#define  MSB(x)          (uint8_t)(((uint16_t)(x) >> 8) & 0xff)
+#define  LSB(x)          (uint8_t)(x & 0xff)
+#define  MSW(x)          (uint16_t)(((uint32_t)(x) >> 16) & 0xffff)
+#define  LSW(x)          (uint16_t)(x & 0xffff)
+#define  QL21_64BITS_3RDWD(x)   ((uint16_t) (x >> 32) & 0xffff)
+#define  QL21_64BITS_4THWD(x)   ((uint16_t) (x >> 48) & 0xffff)
+#endif
+
+#define  OFFSET(w)   (((u_long) &w) & 0xFFFF)  /* 256 byte offsets */
+#define  SCSI_BUS_32(scp)   ((scp)->channel)
+#define  SCSI_TCN_32(scp)    ((scp)->target)
+#define  SCSI_LUN_32(scp)    ((scp)->lun)
+
+/*
+* TIMER MACROS
+*/
+#define  QLA2100_TIMER_LOCK(ap)   spin_lock_irqsave(&(ap)->retry_lock, cpu_flags);
+#define  QLA2100_TIMER_UNLOCK(ap) spin_unlock_irqrestore(&(ap)->retry_lock, cpu_flags);
+
+
+#define	WATCH_INTERVAL		1       /* number of seconds */
+#define	START_TIMER(f, h, w)	\
+{ \
+init_timer(&(h)->timer); \
+(h)->timer.expires = jiffies + w * HZ;\
+(h)->timer.data = (unsigned long) h; \
+(h)->timer.function = (void (*)(unsigned long))f; \
+(h)->flags.start_timer = FALSE; \
+add_timer(&(h)->timer); \
+(h)->timer_active = 1;\
+}
+
+#define	RESTART_TIMER(f, h, w)	\
+{ \
+(h)->timer.expires = jiffies + w * HZ;\
+(h)->flags.start_timer = FALSE; \
+add_timer(&(h)->timer); \
+}
+
+#define	STOP_TIMER(f, h)	\
+{ \
+del_timer(&(h)->timer); \
+(h)->timer_active = 0;\
+}
+
+#define NVRAM_DELAY() udelay(500) /* 2 microsecond delay */
+
+typedef unsigned long paddr32_t;
+
+/*
+*  Qlogic Driver support Function Prototypes.
+*/
+STATIC uint8_t  qla2100_register_with_Linux(scsi_qla_host_t *ha, uint8_t maxchannels);
+STATIC void   qla2100_done(scsi_qla_host_t *, srb_t **, srb_t **),
+qla2100_next(scsi_qla_host_t *, scsi_lu_t *),
+qla2100_select_queue_depth(struct Scsi_Host *, Scsi_Device *);
+
+STATIC void      qla2100_done_q_put(scsi_qla_host_t *, srb_t *, srb_t **, srb_t **),
+qla2100_putq_b(scsi_lu_t *, srb_t *),
+qla2100_putq_t(scsi_lu_t *, srb_t *),
+qla2100_removeq(scsi_lu_t *, srb_t *),
+qla2100_timer(scsi_qla_host_t *),
+qla2100_timeout_insert(scsi_qla_host_t *, srb_t *),
+qla2100_timeout_remove(scsi_qla_host_t *, srb_t *);
+
+STATIC uint8_t   qla2100_mem_alloc(scsi_qla_host_t *);
+
+static void qla2100_dump_regs(struct Scsi_Host *host);
+#if  STOP_ON_ERROR
+static void qla2100_panic(char *, struct Scsi_Host *host);
+#endif
+void qla2100_print_scsi_cmd(Scsi_Cmnd *cmd);
+STATIC void qla2100_abort_queue_single(scsi_qla_host_t *,uint32_t,uint32_t,uint32_t,uint32_t);
+
+STATIC int qla2100_return_status(scsi_qla_host_t *ha, sts_entry_t *sts, Scsi_Cmnd       *cp);
+STATIC void qla2100_removeq(scsi_lu_t *q, srb_t *sp);
+STATIC void qla2100_mem_free(scsi_qla_host_t *ha);
+void qla2100_do_dpc(void *p);
+
+static inline void qla2100_callback(scsi_qla_host_t *ha, srb_t *sp, uint8_t dec),
+qla2100_tgt_dealloc(scsi_qla_host_t *, tgt_t *),
+qla2100_lun_dealloc(scsi_lu_t *);
+static inline tgt_t     *qla2100_tgt_alloc(scsi_qla_host_t *);
+static inline scsi_lu_t *qla2100_lun_alloc(void);
+
+static inline void qla2100_enable_intrs(scsi_qla_host_t *);
+static inline void qla2100_disable_intrs(scsi_qla_host_t *);
+#if QLA2100_EXT_TIMEOUT
+static void qla2100_extend_timeout(Scsi_Cmnd *cmd, int timeout);
+#endif
+static int  qla2100_get_tokens(char *line, char **argv, int maxargs );
+
+/*
+*  QLogic ISP2100 Hardware Support Function Prototypes.
+*/
+STATIC  uint8_t  qla2100_initialize_adapter(scsi_qla_host_t *),
+qla2100_isp_firmware(scsi_qla_host_t *),
+qla2100_pci_config(scsi_qla_host_t *),
+qla2100_set_cache_line(scsi_qla_host_t *),
+qla2100_chip_diag(scsi_qla_host_t *),
+qla2100_setup_chip(scsi_qla_host_t *),
+qla2100_init_rings(scsi_qla_host_t *),
+qla2100_fw_ready(scsi_qla_host_t *),
+qla2100_nvram_config(scsi_qla_host_t *),
+qla2200_nvram_config(scsi_qla_host_t *),
+qla2100_mailbox_command(scsi_qla_host_t *, uint32_t, uint16_t *),
+qla2100_update_device_data(scsi_qla_host_t *, device_data_t *, u_char),
+qla2100_sns_device(scsi_qla_host_t *, u_char),
+qla2100_update_fc_db(scsi_qla_host_t *, u_char),
+qla2100_map_targets(scsi_qla_host_t *),
+#if USE_FLASH
+qla2100_get_database(scsi_qla_host_t *),
+qla2100_save_database(scsi_qla_host_t *),
+qla2100_program_flash_address(scsi_qla_host_t *, uint32_t, u_char),
+qla2100_erase_flash_sector(scsi_qla_host_t *, uint32_t),
+qla2100_poll_flash(scsi_qla_host_t *, uint32_t, u_char),
+#endif
+qla2100_loop_reset(scsi_qla_host_t *),
+qla2100_device_reset(scsi_qla_host_t *, uint32_t, uint32_t),
+qla2100_abort_device(scsi_qla_host_t *, uint32_t, uint32_t, uint32_t),
+qla2100_abort_command(scsi_qla_host_t *, srb_t *),
+qla2100_64bit_start_scsi(scsi_qla_host_t *, srb_t *),
+qla2100_32bit_start_scsi(scsi_qla_host_t *, srb_t *),
+qla2100_abort_isp(scsi_qla_host_t *),
+qla2100_loop_resync(scsi_qla_host_t *);
+STATIC uint8_t qla2100_cmd_wait(scsi_qla_host_t *ha);
+
+STATIC void      qla2100_nv_write(scsi_qla_host_t *, uint16_t),
+qla2100_nv_delay(void),
+qla2100_poll(scsi_qla_host_t *),
+qla2100_init_fc_db(scsi_qla_host_t *),
+qla2100_init_tgt_map(scsi_qla_host_t *),
+#if USE_FLASH
+qla2100_flash_enable(scsi_qla_host_t *),
+qla2100_flash_disable(scsi_qla_host_t *),
+qla2100_write_flash_byte(scsi_qla_host_t *, uint32_t, u_char),
+#endif
+qla2100_reset_adapter(scsi_qla_host_t *),
+qla2100_marker(scsi_qla_host_t *, uint32_t, uint32_t, uint32_t,
+u_char),
+qla2100_enable_lun(scsi_qla_host_t *),
+qla2100_notify_ack(scsi_qla_host_t *, notify_entry_t *),
+qla2100_64bit_continue_io(scsi_qla_host_t *, atio_entry_t *,
+                                           uint32_t, u_long *),
+qla2100_32bit_continue_io(scsi_qla_host_t *, atio_entry_t *,
+                                           uint32_t, u_long *),
+qla2100_isp_cmd(scsi_qla_host_t *),
+qla2100_isr(scsi_qla_host_t *, srb_t **, srb_t **),
+qla2100_rst_aen(scsi_qla_host_t *),
+qla2100_atio_entry(scsi_qla_host_t *, atio_entry_t *),
+qla2100_status_entry(scsi_qla_host_t *, sts_entry_t *, srb_t **,
+srb_t **),
+qla2100_error_entry(scsi_qla_host_t *, response_t *, srb_t **,
+srb_t **),
+qla2100_restart_queues(scsi_qla_host_t *, uint8_t),
+qla2100_restart_watchdog_queue(scsi_qla_host_t *),
+qla2100_abort_queues(scsi_qla_host_t *, uint8_t);
+
+STATIC uint16_t  qla2100_get_nvram_word(scsi_qla_host_t *, uint32_t),
+qla2100_nvram_request(scsi_qla_host_t *, uint32_t),
+qla2100_read_flash_byte(scsi_qla_host_t *, uint32_t),
+qla2100_debounce_register(volatile uint16_t *);
+
+STATIC request_t *qla2100_req_pkt(scsi_qla_host_t *);
+STATIC request_t *qla2100_ms_req_pkt(scsi_qla_host_t *, srb_t *);
+uint8_t          qla2100_update_config(scsi_qla_host_t *ha);
+STATIC uint8_t qla2100_configure_hba(scsi_qla_host_t *ha);
+STATIC uint8_t qla2100_configure_loop(scsi_qla_host_t *ha, uint8_t );
+STATIC void qla2100_reset_chip(scsi_qla_host_t *ha);
+#if QL2100_TARGET_MODE_SUPPORT
+qla2100_enable_lun(scsi_qla_host_t *, uint8_t, uint32_t),
+qla2100_notify_ack(scsi_qla_host_t *, notify_entry_t *),
+qla2100_immed_notify(scsi_qla_host_t *, notify_entry_t *),
+qla2100_accept_io(scsi_qla_host_t *, ctio_ret_entry_t *),
+qla2100_64bit_continue_io(scsi_qla_host_t *, atio_entry_t *, uint32_t,
+                                     u_long *),
+qla2100_32bit_continue_io(scsi_qla_host_t *, atio_entry_t *, uint32_t,
+                                     u_long *),
+qla2100_atio_entry(scsi_qla_host_t *, atio_entry_t *),
+qla2100_notify_entry(scsi_qla_host_t *, notify_entry_t *),
+
+#endif  /* QLA2100_TARGET_MODE_SUPPORT */
+STATIC uint8_t qla2100_sns_get_name( scsi_qla_host_t *ha, device_data_t *device, uint8_t flag );
+STATIC void qla2100_display_fc_names(scsi_qla_host_t *ha);
+void ql2100_dump_requests(scsi_qla_host_t *ha);
+static void qla2100_get_properties(scsi_qla_host_t *ha, char *string);
+STATIC uint8_t qla2100_find_propname(scsi_qla_host_t *ha, char *propname, char *propstr, char *db);
+static int qla2100_get_prop_16chars(scsi_qla_host_t *ha, char *propname, char *propval, char *cmdline);
+static char	*qla2100_get_line(char *str, char *line);
+void qla2100_check_fabric_devices(scsi_qla_host_t *ha);
+
+#ifdef FC_IP_SUPPORT
+
+/* Entry points for IP network driver */
+int  qla2x00_ip_inquiry(uint16_t wAdapterNumber, BD_INQUIRY_DATA *pInquiryData);
+int  qla2x00_ip_enable(scsi_qla_host_t *ha, BD_ENABLE_DATA *pEnableData);
+void qla2x00_ip_disable(scsi_qla_host_t *ha);
+void qla2x00_add_buffers(scsi_qla_host_t *ha, uint16_t wBufferCount);
+int  qla2x00_send_packet(scsi_qla_host_t *ha, SEND_CB *pSendCB);
+
+static int qla2x00_ip_initialize(scsi_qla_host_t *ha);
+static int qla2x00_add_new_ip_device(scsi_qla_host_t *ha,
+uint16_t wLoopId,
+uint8_t *pPortId,
+uint8_t *pPortName,
+int bForceAdd);
+static int qla2x00_convert_to_arp(scsi_qla_host_t *ha, SEND_CB *pSendCB);
+static void qla2x00_free_ip_block(scsi_qla_host_t *ha,
+IP_DEVICE_BLOCK *pIpDevice);
+static int qla2x00_get_ip_loopid(scsi_qla_host_t *ha,
+uint8_t *pNodeName,
+uint8_t *pLoopId);
+static int qla2x00_send_farp_request(scsi_qla_host_t *ha,
+uint8_t *pPortName);
+static int qla2x00_register_ip_device(scsi_qla_host_t *ha);
+static int qla2x00_reserve_ip_block(scsi_qla_host_t *ha,
+PIP_DEVICE_BLOCK *pIpDevBlk);
+static int qla2x00_update_ip_device_data(scsi_qla_host_t *ha,
+device_data_t *pDeviceData);
+static int qla2x00_reserve_loopid(scsi_qla_host_t *ha, uint16_t *pLoopId);
+static void qla2x00_free_loopid(scsi_qla_host_t *ha, uint16_t wLoopId);
+static int qla2x00_login_public_device(scsi_qla_host_t *ha,
+uint16_t *pLoopId,
+uint8_t  *pPortID,
+uint16_t wOptions);
+static int qla2x00_logout_public_device(scsi_qla_host_t *ha,
+uint16_t wLoopId,
+uint16_t wOptions);
+#else
+/* v2.19.8 */
+static int qla2x00_login_public_device(scsi_qla_host_t *ha,
+uint16_t *pLoopId,
+uint8_t  *pPortID,
+uint16_t wOptions);
+static int qla2x00_reserve_loopid(scsi_qla_host_t *ha, uint16_t *pLoopId);
+static void qla2x00_free_loopid(scsi_qla_host_t *ha, uint16_t wLoopId);
+#endif
+
+#if  APIDEV
+static int apidev_init(struct Scsi_Host*);
+static int apidev_cleanup(void);
+#endif
+
+void qla2100_print_q_info(scsi_lu_t *q);
+
+#if  DEBUG_QLA2100
+#ifndef QL_DEBUG_ROUTINES
+#define QL_DEBUG_ROUTINES
+#endif
+#endif
+#ifdef QL_DEBUG_ROUTINES
+/*
+*  Driver Debug Function Prototypes.
+*/
+STATIC uint8_t  qla2100_getbyte(uint8_t *);
+STATIC uint16_t qla2100_getword(uint16_t *);
+STATIC uint32_t qla2100_getdword(uint32_t *);
+STATIC void     qla2100_putbyte(uint8_t *, uint8_t),
+qla2100_putword(uint16_t *, uint16_t),
+qla2100_putdword(uint32_t *, uint32_t),
+qla2100_print(int8_t *),
+qla2100_output_number(u_long, uint8_t),
+qla2100_putc(int8_t);
+#endif
+#if DEBUG_GET_FW_DUMP
+STATIC void qla2300_dump_isp(scsi_qla_host_t *ha),
+qla2100_dump_word(uint8_t *, uint32_t, uint32_t);
+#endif
+
+/* Debug print buffer */
+char          debug_buff[LINESIZE];
+#if DEBUG_QLA2100
+STATIC uint8_t ql2x_debug_print = 1;
+#else
+STATIC uint8_t ql2x_debug_print = 0;
+#endif
+
+/*
+* insmod needs to find the variable and make it point to something
+*/
+static char *ql2xdevconf = NULL;
+static int ql2xretrycount = 8;
+#ifdef MODULE
+static char *ql2xopts = NULL;
+static int ql2xmaxqdepth = 0;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,18)
+
+/* insmod qla2100 ql2xopts=verbose" */
+MODULE_PARM(ql2xopts, "s");
+MODULE_PARM(ql2xmaxqdepth, "i");
+#endif
+/*
+* Just in case someone uses commas to separate items on the insmod
+* command line, we define a dummy buffer here to avoid having insmod
+* write wild stuff into our code segment
+*/
+static char dummy_buffer[60] = "Please don't add commas in your insmod command!!\n";
+
+#endif
+
+/*
+* Macros to change names of OS remapping routines.
+*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
+#define ioremap vremap
+#define iounmap vfree
+#endif
+
+
+/*
+* This is the pointer to the /proc/scsi/qla2100 code.
+* access the driver.
+*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+#if CONFIG_PROC_FS
+/* this definition is normally in proc_fs.h     PROC_SCSI_QL2100 */
+#define PROC_SCSI_QL2100  PROC_SCSI_QLOGICISP
+
+struct proc_dir_entry proc_scsi_qla2100 = {
+PROC_SCSI_QL2100, 7, "qla2x00",
+S_IFDIR | S_IRUGO | S_IXUGO, 2,
+0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+};
+#endif
+#endif
+static int qla2100_lip = 0;
+
+#include <linux/ioctl.h>
+#include <scsi/scsi_ioctl.h>
+
+/* multi-OS QLOGIC IOCTL definition file */
+#include "qla2x00exioct.h"
+
+
+#if QLA_SCSI_VENDOR_DIR
+/* Include routine to set direction for vendor specific commands */
+#include "qlavendor.c"
+#endif 
+/***********************************************************************
+* We use the Scsi_Pointer structure that's included with each command
+* SCSI_Cmnd as a scratchpad for our SRB. This allows us to accept
+* an unlimited number of commands.
+*
+* SCp will always point to the SRB structure (defined in qla2100.h).
+* It is defined as follows:
+*  - SCp.ptr  -- > pointer back to the cmd
+*  - SCp.this_residual --> used as forward pointer to next srb
+*  - SCp.buffer --> used as backward pointer to next srb
+*  - SCp.buffers_residual --> used as flags field
+*  - SCp.have_data_in --> not used
+*  - SCp.sent_command --> not used
+*  - SCp.phase --> not used
+***********************************************************************/
+#define	CMD_SP(Cmnd)		(&(Cmnd)->SCp)
+#define	CMD_XFRLEN(Cmnd)	(Cmnd)->request_bufflen
+#define	CMD_CDBLEN(Cmnd)	(Cmnd)->cmd_len
+#define	CMD_CDBP(Cmnd)		(Cmnd)->cmnd
+#define	CMD_SNSP(Cmnd)		(Cmnd)->sense_buffer
+#define	CMD_SNSLEN(Cmnd)	(sizeof (Cmnd)->sense_buffer)
+#define	CMD_RESULT(Cmnd)	((Cmnd)->result)
+#define	CMD_HANDLE(Cmnd)	((Cmnd)->host_scribble)
+#define	CMD_TIMEOUT(Cmnd)	((Cmnd)->timeout_per_command)
+
+#define DID_RETRY		DID_ERROR
+
+
+/*
+* Macros use for debugging the driver.
+*/
+#ifdef QL_DEBUG_LEVEL_3
+#define ENTER(x)	sprintf(debug_buff,"qla2100 : Entering %s()\n\r", x); \
+qla2100_print(debug_buff);
+#define LEAVE(x)	sprintf(debug_buff,"qla2100 : Leaving %s()\n\r", x); \
+qla2100_print(debug_buff);
+#define ENTER_INTR(x)	sprintf(debug_buff,"qla2100 : Entering %s()\n\r", x); \
+qla2100_print(debug_buff);
+#define LEAVE_INTR(x)	sprintf(debug_buff,"qla2100 : Leaving %s()\n\r", x); \
+qla2100_print(debug_buff);
+#define DEBUG3(x)	x
+#else
+#define ENTER(x)
+#define LEAVE(x)
+#define ENTER_INTR(x)
+#define LEAVE_INTR(x)
+#define DEBUG3(x)
+#endif
+
+#if  QLA2100_COMTRACE
+#define COMTRACE(x)     qla2100_putc(x);
+#else
+#define COMTRACE(x)
+#endif
+
+#if  DEBUG_QLA2100
+#define DEBUG(x)	x
+#define DEBUG4(x)
+#else
+#define DEBUG(x)
+#define DEBUG4(x)
+#endif
+
+#ifdef QL_DEBUG_LEVEL_2
+#define DEBUG2(x)          x
+#else
+#define DEBUG2(x)
+#endif
+#ifdef QL_DEBUG_LEVEL_5
+#define DEBUG5(x)          x
+#else
+#define DEBUG5(x)
+#endif
+
+uint8_t copyright[48] = "Copyright 1999-2001, Qlogic Corporation";
+
+/****************************************************************************/
+/*  LINUX -  Loadable Module Functions.                                     */
+/****************************************************************************/
+
+/*****************************************/
+/*   ISP Boards supported by this driver */
+/*****************************************/
+#define QLA2100_VENDOR_ID   0x1077
+#define QLA2100_DEVICE_ID   0x2100
+#define QLA2200_DEVICE_ID   0x2200
+#define QLA2200A_DEVICE_ID  0x2200A
+#define QLA2300_DEVICE_ID   0x2300
+#define QLA2200A_RISC_ROM_VER  4
+
+#define NUM_OF_ISP_DEVICES     4
+
+typedef struct _qlaboards
+{
+unsigned char   bdName[9];       /* Board ID String             */
+unsigned long   device_id;       /* Device ID                   */
+int   numPorts;                  /* number of loops on adapter  */
+unsigned short   *fwcode;        /* pointer to FW array         */
+unsigned long    *fwlen;         /* number of words in array    */
+unsigned short   *fwstart;       /* start address for F/W       */
+unsigned char   *fwver;          /* Ptr to F/W version array    */
+} qla_boards_t;
+
+
+#if USE_TP_FW
+struct _qlaboards   QLBoardTbl_fc[NUM_OF_ISP_DEVICES] =
+{
+/* Name ,  Board PCI Device ID,         Number of ports */
+{"QLA2300 ", QLA2300_DEVICE_ID,           MAX_BUSES,
+#ifdef FC_IP_SUPPORT
+&fw2300ip_code01[0],  (unsigned long *)&fw2300ip_length01, &fw2300ip_addr01, &fw2300ip_version_str[0] },
+#else
+&fw2300tp_code01[0],  (unsigned long *)&fw2300tp_length01, &fw2300tp_addr01, &fw2300tp_version_str[0] },
+#endif
+{"QLA2200 ", QLA2200_DEVICE_ID,           MAX_BUSES,
+#ifdef FC_IP_SUPPORT
+&fw2200ip_code01[0],  (unsigned long *)&fw2200ip_length01, &fw2200ip_addr01, &fw2200ip_version_str[0] },
+#else
+&fw2200tp_code01[0],  (unsigned long *)&fw2200tp_length01, &fw2200tp_addr01, &fw2200tp_version_str[0] },
+#endif
+{"QLA2100 ", QLA2100_DEVICE_ID,           MAX_BUSES,
+&fw2100tp_code01[0],  (unsigned long *)&fw2100tp_length01,&fw2100tp_addr01, &fw2100tp_version_str[0] },
+{"        ",                 0,           0}
+};
+
+#else  /* USE_TP_FW */
+
+struct _qlaboards   QLBoardTbl_fc[NUM_OF_ISP_DEVICES] =
+{
+/* Name ,  Board PCI Device ID,         Number of ports */
+{"QLA2300 ", QLA2300_DEVICE_ID,           MAX_BUSES,
+#ifdef FC_IP_SUPPORT
+&fw2300ip_code01[0],  (unsigned long *)&fw2300ip_length01, &fw2300ip_addr01, &fw2300ip_version_str[0] },
+#else
+&fw2300ef_code01[0],  (unsigned long *)&fw2300ef_length01, &fw2300ef_addr01, &fw2300ef_version_str[0] },
+#endif
+{"QLA2200 ", QLA2200_DEVICE_ID,           MAX_BUSES,
+#ifdef FC_IP_SUPPORT
+&fw2200ip_code01[0],  (unsigned long *)&fw2200ip_length01, &fw2200ip_addr01, &fw2200ip_version_str[0] },
+#else
+&fw2200ef_code01[0],  (unsigned long *)&fw2200ef_length01, &fw2200ef_addr01, &fw2200ef_version_str[0] },
+#endif
+{"QLA2100 ", QLA2100_DEVICE_ID,           MAX_BUSES,
+&fw2100ef_code01[0],  (unsigned long *)&fw2100ef_length01,&fw2100ef_addr01, &fw2100ef_version_str[0] },
+{"        ",                 0,           0}
+};
+#endif /* USE_TP_FW  */
+
+/*
+* Stat info
+*/
+static struct _qla2100stats  {
+unsigned long   mboxtout;            /* mailbox timeouts */
+unsigned long   mboxerr;             /* mailbox errors */
+unsigned long   ispAbort;            /* ISP aborts */
+unsigned long   debugNo;
+unsigned long   loop_resync;
+unsigned long   outarray_full;
+unsigned long   retry_q_cnt;
+unsigned long   done_q_cnt;
+scsi_qla_host_t *irqhba;
+} qla2100_stats;
+
+/*
+* Command line options
+*/
+static unsigned long qla2100_verbose = 1L;
+static unsigned long qla2100_quiet   = 0L;
+static unsigned long qla2100_reinit = 1L;
+static unsigned long qla2100_req_dmp = 0L;
+static scsi_qla_host_t *qla2100_hostlist = NULL;
+
+#ifdef QLA2100_PROFILE
+static int qla2100_buffer_size = 0;
+static char *qla2100_buffer = NULL;
+#endif
+
+#include <linux/ioctl.h>
+#include <scsi/scsi_ioctl.h>
+#include <asm/uaccess.h>
+
+/*************************************************************************
+*   qla2100_set_info
+*
+* Description:
+*   Set parameters for the driver from the /proc filesystem.
+*
+* Returns:
+*************************************************************************/
+int
+qla2100_set_info(char *buffer, int length, struct Scsi_Host *HBAptr) {
+    return (-ENOSYS);  /* Currently this is a no-op */
+}
+
+
+#include "qla2x00ioctl.c"
+
+
+/*************************************************************************
+* qla2100_proc_info
+*
+* Description:
+*   Return information to handle /proc support for the driver.
+*
+* inout : decides on the direction of the dataflow and the meaning of the
+*         variables
+* buffer: If inout==FALSE data is being written to it else read from it
+*         (ptrs to a page buffer)
+* *start: If inout==FALSE start of the valid data in the buffer
+* offset: If inout==FALSE offset from the beginning of the imaginary file
+*         from which we start writing into the buffer
+* length: If inout==FALSE max number of bytes to be written into the buffer
+*         else number of bytes in the buffer
+* Returns:
+*************************************************************************/
+#define	PROC_BUF	(&qla2100_buffer[len])
+int
+qla2100_proc_info( char *buffer, char **start, off_t offset, int length,
+int hostno, int inout) {
+#if QLA2100_PROFILE
+    struct Scsi_Host *host;
+    scsi_qla_host_t *ha;
+    int    size = 0;
+    scsi_lu_t  *up;
+    int   len = 0;
+    qla_boards_t   *bdp;
+    uint32_t        t, l;
+
+#if REQ_TRACE
+    Scsi_Cmnd       *cp;
+    srb_t           *sp;
+    int i;
+#endif
+    
+    DEBUG5(printk("Entering proc_info 0x%x,0x%lx,0x%x,0x%x\n",(int)buffer,offset,length,hostno);)
+    host = NULL;
+
+    /* Find the host that was specified */
+    for( ha=qla2100_hostlist; (ha != NULL) && ha->host->host_no != hostno; ha=ha->next )
+        ;
+
+    /* if host wasn't found then exit */
+    if( !ha ) {
+        size = sprintf(buffer, "Can't find adapter for host number %d\n", hostno);
+        if( size > length ) {
+            return (size);
+        } else {
+            return (0);
+        }
+    }
+
+    host = ha->host;
+
+    if( inout == TRUE ) /* Has data been written to the file? */
+    {
+        printk(KERN_INFO "qla2100_proc: has data been written to the file. \n");
+        return (qla2100_set_info(buffer, length, host));
+    }
+
+
+    /*
+    * if our old buffer is the right size use it otherwise
+    * allocate a new one.
+    */
+    size = 4096;  /* get a page */
+    if( qla2100_buffer_size != size ) {
+        /* deallocate this buffer and get a new one */
+        if( qla2100_buffer != NULL ) {
+            kfree(qla2100_buffer);
+            qla2100_buffer_size = 0;
+        }
+        qla2100_buffer = kmalloc(size, GFP_KERNEL);
+    }
+    if( qla2100_buffer == NULL ) {
+        size = sprintf(buffer, "qla2100 - kmalloc error at line %d\n",
+        __LINE__);
+        return size;
+    }
+    /* save the size of our buffer */
+    qla2100_buffer_size = size;
+
+    /* start building the print buffer */
+    bdp = &QLBoardTbl_fc[ha->devnum];
+    qla2100_lip = 1;
+    size =  sprintf(PROC_BUF,
+    "QLogic PCI to Fibre Channel Host Adapter for ISP2100/ISP2200/ISP2300:\n"     /* 72 */
+    "        Firmware version: %2d.%02d.%02d, Driver version %s\n",                /* 66 */
+    bdp->fwver[0], bdp->fwver[1], bdp->fwver[2], QLA2100_VERSION);
+    len += size;
+
+#if 0
+    size = sprintf(PROC_BUF, 
+           "FC HBA: %s; HBA Serial# %x%x%x\n", 
+            bdp->bdName,
+            ha->serial0,
+            ha->serial1,
+            ha->serial2);
+    len += size;
+
+    size = sprintf(PROC_BUF, 
+           "[%c%c%c%c%c%c]; Part#%c%c%c%c%c%c%c%c; FRU#%c%c%c%c%c%c%c%c; EC#%c%c%c%c%c%c%c%c\n", 
+            ha->oem_string[0],
+            ha->oem_string[1],
+            ha->oem_string[2],
+            ha->oem_string[3],
+            ha->oem_string[4],
+            ha->oem_string[5],
+
+            ha->oem_part[0],
+            ha->oem_part[1],
+            ha->oem_part[2],
+            ha->oem_part[3],
+            ha->oem_part[4],
+            ha->oem_part[5],
+            ha->oem_part[6],
+            ha->oem_part[7],
+
+            ha->oem_fru[0],
+            ha->oem_fru[1],
+            ha->oem_fru[2],
+            ha->oem_fru[3],
+            ha->oem_fru[4],
+            ha->oem_fru[5],
+            ha->oem_fru[6],
+            ha->oem_fru[7],
+
+            ha->oem_ec[0],
+            ha->oem_ec[1],
+            ha->oem_ec[2],
+            ha->oem_ec[3],
+            ha->oem_ec[4],
+            ha->oem_ec[5],
+            ha->oem_ec[6],
+            ha->oem_ec[7]);
+    len += size;
+#endif
+
+    size = sprintf(PROC_BUF, "Request Queue = 0x%lx, Response Queue = 0x%lx\n",
+    (long unsigned int)ha->request_dma,
+    (long unsigned int)ha->response_dma);
+    len += size;
+    size = sprintf(PROC_BUF, "Request Queue count= %ld, Response Queue count= %ld\n",
+    (long)REQUEST_ENTRY_CNT,
+    (long)RESPONSE_ENTRY_CNT);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of pending commands = 0x%lx\n", ha->actthreads);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of queued commands = 0x%lx\n", ha->qthreads);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of free request entries = %d\n",ha->req_q_cnt);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of mailbox timeouts = %ld\n",qla2100_stats.mboxtout);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of ISP aborts = %ld\n",qla2100_stats.ispAbort);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of loop resyncs = %ld\n",qla2100_stats.ispAbort);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of retries for empty slots = %ld\n",qla2100_stats.outarray_full);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of reqs in retry_q = %ld\n",qla2100_stats.retry_q_cnt);
+    len += size;
+    size = sprintf(PROC_BUF, "Number of reqs in done_q = %ld\n",qla2100_stats.done_q_cnt);
+    len += size;
+
+#if REQ_TRACE
+    if ( qla2100_req_dmp ) {
+    	size  = sprintf(PROC_BUF,"Outstanding Commands on controller:\n");
+    	len += size;
+    	for( i=0; i < MAX_OUTSTANDING_COMMANDS; i++ ) {
+      	if( (sp = ha->outstanding_cmds[i]) == NULL )
+                 	continue;
+      	if( (cp = sp->cmd) == NULL )
+               continue;
+        size = sprintf(PROC_BUF,
+           "(%d): Pid=%ld, sp flags=0x%x, cmd=0x%p, state=%x handle=%x\n\r",
+           i, (int)sp->cmd->pid, (long)sp->flags,
+           CMD_SP(sp->cmd),(int)sp->state,CMD_HANDLE(sp->cmd));
+
+      	len += size;
+        if( len >= qla2100_buffer_size )
+                goto profile_stop;
+    	}
+    }
+#endif
+
+    /* 2.25 node/port display to proc */
+    /* Display the node name for adapter */
+    size = sprintf(PROC_BUF, "\nSCSI Device Information:\n");
+    len += size;
+    size = sprintf(PROC_BUF,
+           "scsi-qla%d-adapter-node=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+           (int)ha->instance,
+           ha->init_cb->node_name[0],
+           ha->init_cb->node_name[1],
+           ha->init_cb->node_name[2],
+           ha->init_cb->node_name[3],
+           ha->init_cb->node_name[4],
+           ha->init_cb->node_name[5],
+           ha->init_cb->node_name[6],
+           ha->init_cb->node_name[7]);
+    len += size;
+
+    /* display the port name for adapter */
+    size = sprintf(PROC_BUF,
+           "scsi-qla%d-adapter-port=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+           (int)ha->instance,
+           ha->init_cb->port_name[0],
+           ha->init_cb->port_name[1],
+           ha->init_cb->port_name[2],
+           ha->init_cb->port_name[3],
+           ha->init_cb->port_name[4],
+           ha->init_cb->port_name[5],
+           ha->init_cb->port_name[6],
+           ha->init_cb->port_name[7]);
+    len += size;
+
+    /* Print out device port names */
+    for (i = 0; i < MAX_FIBRE_DEVICES; i++) {
+         if (ha->fc_db[i].loop_id == PORT_UNUSED)
+                        continue;
+
+#if USE_PORTNAME
+		size = sprintf(PROC_BUF,
+		    	"scsi-qla%d-target-%d=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+		    	(int)ha->instance, i,
+		    	ha->fc_db[i].wwn[0],
+		    	ha->fc_db[i].wwn[1],
+		    	ha->fc_db[i].wwn[2],
+		    	ha->fc_db[i].wwn[3],
+		    	ha->fc_db[i].wwn[4],
+		    	ha->fc_db[i].wwn[5],
+		    	ha->fc_db[i].wwn[6],
+		    	ha->fc_db[i].wwn[7]);
+#else
+         size = sprintf(PROC_BUF,
+                    "scsi-qla%d-target-%d=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+                    (int)ha->instance, i,
+                    ha->fc_db[i].name[0],
+                    ha->fc_db[i].name[1],
+                    ha->fc_db[i].name[2],
+                    ha->fc_db[i].name[3],
+                    ha->fc_db[i].name[4],
+                    ha->fc_db[i].name[5],
+                    ha->fc_db[i].name[6],
+                    ha->fc_db[i].name[7]);
+#endif
+         len += size;
+    } /* 2.25 node/port display to proc */
+
+    size = sprintf(PROC_BUF, "\nSCSI LUN Information:\n");
+    len += size;
+    size = sprintf(PROC_BUF, "(Id:Lun)\n");
+    len += size;
+    /* scan for all equipment stats */
+    for (t = 0; t < MAX_FIBRE_DEVICES; t++) {
+        /* valid target */
+        if (ha->fc_db[t].loop_id == PORT_UNUSED)
+            continue;
+        /* scan all luns */
+        for( l = 0; l < ha->max_luns; l++ ) {
+            up = (scsi_lu_t *) GET_LU_Q(ha, 0, t, l);
+            if( up == NULL )
+                continue;
+            if( up->io_cnt == 0 || up->io_cnt < 5)
+                continue;
+            /* total reads since boot */
+            /* total writes since boot */
+            /* total requests since boot  */
+            size = sprintf(PROC_BUF, "(%2d:%2d): Total reqs %ld,",t,l,up->io_cnt);
+            len += size;
+            /* current number of pending requests */
+            size = sprintf(PROC_BUF, " Pending reqs %d,",up->q_outcnt);
+            len += size;
+
+            /* current number of pending requests */
+            size = sprintf(PROC_BUF, " Queued reqs %d,",(int)up->q_incnt);
+            len += size;
+            size = sprintf(PROC_BUF, "\n");
+            len += size;
+            if( len >= qla2100_buffer_size )
+                goto profile_stop;
+        }
+        if( len >= qla2100_buffer_size )
+            break;
+    }
+
+    profile_stop:
+    if( len >= qla2100_buffer_size ) {
+        printk(KERN_WARNING "qla2100: Overflow buffer in qla2100_proc.c\n");
+    }
+
+    if( offset > len - 1 ) {
+        kfree(qla2100_buffer);
+        qla2100_buffer = NULL;
+        qla2100_buffer_size = length = 0;
+        *start = NULL;
+    } else {
+        if( len - offset < length ) {
+            length = len - offset;
+        }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+        *start = &qla2100_buffer[offset];   /* Start of wanted data */
+#else
+		*start = buffer;
+		memcpy(buffer, &qla2100_buffer[offset], length);
+#endif
+    }
+    return (length);
+#else
+    return (0);
+#endif
+
+}
+
+/**************************************************************************
+* qla2100_detect
+*
+* Description:
+*    This routine will probe for Qlogic FC SCSI host adapters.
+*    It returns the number of host adapters of a particular
+*    type that were found.	 It also initialize all data necessary for
+*    the driver.  It is passed-in the host number, so that it
+*    knows where its first entry is in the scsi_hosts[] array.
+*
+* Input:
+*     template - pointer to SCSI template
+*
+* Returns:
+*  num - number of host adapters found.
+**************************************************************************/
+int
+qla2100_detect(Scsi_Host_Template *template)
+{
+	struct Scsi_Host *host;
+	scsi_qla_host_t *ha, *cur_ha;
+	struct _qlaboards  *bdp;
+	int i, j;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+	unsigned short subsys;
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,95)
+	unsigned int piobase;
+	unsigned char pci_bus, pci_devfn, pci_irq;
+	config_reg_t   *cfgp = 0;
+#endif
+	device_reg_t   *reg;
+	char   *cp;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+	struct pci_dev *pdev = NULL;
+#else
+	int index;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+	struct semaphore sem = MUTEX_LOCKED;
+#else
+	DECLARE_MUTEX_LOCKED(sem);
+#endif
+
+	unsigned long wait_switch = 0; 
+
+	ENTER("qla2100_detect");
+
+	if( sizeof(srb_t) > sizeof(Scsi_Pointer) ) 
+		printk(KERN_WARNING "qla2x00: srb_t must be re-defined "
+		    "- it's too big");
+
+#ifdef CODECHECK
+ 	if( sizeof(srb_t) > sizeof(Scsi_Pointer) ) {
+		printk(KERN_WARNING "Redefine srb_t - its too big");
+		return 0;
+	}
+#endif
+
+#ifdef MODULE
+	DEBUG2(sprintf(debug_buff,
+	    "DEBUG: qla2100_detect starts at address = 0x%8lx\n",
+	    (uint32_t)qla2100_detect);)
+	DEBUG2(qla2100_print(debug_buff);)
+	/*
+	* If we are called as a module, the qla2100 pointer may not be null
+	* and it would point to our bootup string, just like on the lilo
+	* command line.  IF not NULL, then process this config string with
+	* qla2100_setup
+	*
+	* Boot time Options
+	* To add options at boot time add a line to your lilo.conf file like:
+	* append="qla2100=verbose,tag_info:{{32,32,32,32},{32,32,32,32}}"
+	* which will result in the first four devices on the first two
+	* controllers being set to a tagged queue depth of 32.
+	*/
+	if( ql2xopts )
+		qla2100_setup(ql2xopts, NULL);
+	if( dummy_buffer[0] != 'P' )
+		printk(KERN_WARNING "qla2100: Please read the file "
+		    "/usr/src/linux/drivers/scsi/README.qla2100\n"
+		    "qla2100: to see the proper way to specify options to "
+		    "the qla2100 module\n"
+		    "qla2100: Specifically, don't use any commas when passing "
+		    "arguments to\n"
+		    "qla2100: insmod or else it might trash certain memory "
+		    "areas.\n");
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+	if( (int) !pcibios_present() ) 
+#else 
+	if (!pci_present())
+#endif
+	{
+		printk(KERN_WARNING "scsi: [ERROR] PCI not present\n");
+		return 0;
+	} /* end of IF */
+
+	bdp = &QLBoardTbl_fc[0];
+	qla2100_hostlist = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+	template->proc_dir = &proc_scsi_qla2100;
+#else
+	template->proc_name = "qla2x00";
+#endif
+
+	/* Try and find each different type of adapter we support */
+	for( i=0; bdp->device_id != 0 && i < NUM_OF_ISP_DEVICES; i++, bdp++ ) {
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+		/* PCI_SUBSYSTEM_IDS supported */ 
+		while ((pdev = pci_find_subsys(QLA2100_VENDOR_ID,
+		    bdp->device_id, PCI_ANY_ID, PCI_ANY_ID, pdev) )) {
+			if (pci_enable_device(pdev)) continue;
+#else
+		while ((pdev = pci_find_device(QLA2100_VENDOR_ID,
+		    bdp->device_id, pdev ) ))  {
+#endif /* 2,3,18 */
+
+#else  /* less than 2,1,95 */  
+		while (!(pcibios_find_device(QLA2100_VENDOR_ID,
+		    bdp->device_id, index++, &pci_bus, &pci_devfn)) )  {
+#endif /* 2,1,95 */ 
+
+			/* found an adapter */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+			printk(KERN_INFO "qla2x00: detect() found an HBA\n");
+			printk(KERN_INFO
+			    "qla2x00: VID=%x DID=%x SSVID=%x SSDID=%x\n",
+			    pdev->vendor, pdev->device,
+			    pdev->subsystem_vendor,
+			    pdev->subsystem_device); 
+
+			/* If it's an XXX SubSys Vendor ID adapter, skip it. */
+			/* if (pdev->subsystem_vendor == PCI_VENDOR_ID_XXX) 
+			{ 
+				printk(KERN_INFO "qla2x00: Skip XXX SubSys "
+				    "Vendor ID Controller\n");
+				continue;
+			}
+			*/
+#else
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+			pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,
+			    &subsys);
+
+			/* Bypass all XXX SUBSYS VENDOR IDs */
+			/* if (subsys == PCI_VENDOR_ID_XXX) 
+			{ 
+				printk(KERN_INFO "qla2x00:Skip XXX SubSys "
+				    "Vendor ID Controller\n");
+				continue;
+			}
+			*/
+#endif /* 2,1,95 */
+#endif /* 2,3,18 */
+			host = scsi_register(template, sizeof(scsi_qla_host_t));
+			ha = (scsi_qla_host_t *) host->hostdata;
+
+			/* Clear our data area */
+			for( j = 0, cp = (char *)ha;
+			    j < sizeof(scsi_qla_host_t); j++, cp++ )
+				*cp = 0;
+
+			/* Sanitize the information from PCI BIOS.  */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+			host->irq = pdev->irq;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+			host->io_port = (unsigned long) pdev->base_address[0];
+#else
+			host->io_port = pdev->resource[0].start;
+#endif
+			ha->pci_bus = pdev->bus->number;
+			ha->pci_device_fn = pdev->devfn;
+			ha->pdev = pdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4)
+			scsi_set_pci_device(host, pdev);
+#endif
+#else
+			pcibios_read_config_byte(pci_bus, pci_devfn,
+			    OFFSET(cfgp->interrupt_line), &pci_irq);
+			pcibios_read_config_dword(pci_bus, pci_devfn,
+			    OFFSET(cfgp->base_port), &piobase);
+			host->irq = pci_irq;
+			host->io_port = (unsigned int) piobase;
+			ha->pci_bus = pci_bus;
+			ha->pci_device_fn = pci_devfn;
+#endif
+			ha->device_id = bdp->device_id;
+			host->io_port &= PCI_BASE_ADDRESS_IO_MASK;
+			ha->devnum = i;
+			if( qla2100_verbose ) {
+				printk(KERN_INFO "(scsi): Found a %s @ bus %d, "
+				    "device 0x%x, irq %d, iobase 0x%lx\n",
+				    bdp->bdName, ha->pci_bus,
+				    (ha->pci_device_fn & 0xf8) >> 3,
+				    host->irq, (unsigned long)host->io_port);
+			}
+
+			ha->iobase     = (device_reg_t *)     host->io_port;
+			ha->iobase2300 = (device2300_reg_t *) host->io_port;
+			ha->host = host;
+
+			/* 4.23 Initialize /proc/scsi/qla2x00 counters */
+			ha->actthreads = 0;
+			ha->qthreads   = 0;
+			ha->dump_done  = 0;
+			ha->isp_aborts = 0;
+			ha->lip_count = 0;
+
+			if( qla2100_mem_alloc(ha) ) {
+				printk(KERN_INFO "qla2100: Failed to allocate "
+				    "memory for adapter\n");
+			}
+			ha->prev_topology = 0;
+			ha->ports = bdp->numPorts;
+			ha->host_no = host->host_no;
+
+			/* 4.10 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+			ha->ioctl_mem      = (void *)KMALLOC(PAGE_SIZE);
+			ha->ioctl_mem_phys =  VIRT_TO_BUS(ha->ioctl_mem);
+#else
+			/* get consistent memory allocated for ioctl I/O
+			 * operations
+			 */
+			ha->ioctl_mem = pci_alloc_consistent(ha->pdev,
+			    PAGE_SIZE, &ha->ioctl_mem_phys);
+#endif
+
+			if (ha->ioctl_mem == NULL) {
+				printk(KERN_WARNING "qla2100: ERROR in ioctl "
+				    "physical memory allocation\n");
+				return(0);
+			}
+
+			if( ha->device_id == QLA2100_DEVICE_ID )
+				ha->max_targets = MAX_TARGETS_2100;
+			else
+				ha->max_targets = MAX_TARGETS_2200;
+	
+			/* load the F/W, read paramaters, and init the H/W */
+			ha->instance = num_hosts;
+
+			if( qla2100_initialize_adapter(ha) ) {
+				printk(KERN_WARNING
+				    "qla2100_detect: [ERROR] Failed to "
+				    "initialize adapter\n");
+
+				qla2100_mem_free(ha);
+				scsi_unregister(host);
+				continue;
+			}
+
+			ha->next = NULL;
+			/*  Mark preallocated Loop IDs in use. */
+			ha->fabricid[SNS_FL_PORT].in_use = TRUE;
+			ha->fabricid[FABRIC_CONTROLLER].in_use = TRUE;
+			ha->fabricid[SIMPLE_NAME_SERVER].in_use = TRUE;
+
+			/* Register our resources with Linux */
+			if( qla2100_register_with_Linux(ha, bdp->numPorts-1) ) {
+				printk(KERN_WARNING 
+				    "qla2100: [ERROR] Failed to register our "
+				    "resources\n");
+				qla2100_mem_free(ha);
+				scsi_unregister(host);
+				continue;
+			}
+
+			/* reg uses here in detect() are common: 
+			 * 2100/2200/2300
+			 */
+			reg = ha->iobase;
+
+			/* Disable ISP interrupts. */
+			qla2100_disable_intrs(ha);
+
+			/*
+			 * Startup the kernel thread for this host adapter
+			 */
+
+			ha->dpc_notify = &sem;
+			kernel_thread((int (*)(void *))qla2100_do_dpc,
+			(void *) ha, 0);
+
+			/*
+			 * Now wait for the kernel dpc thread to initialize 
+			 * and go to sleep.
+			 */
+			down(&sem);
+			ha->dpc_notify = NULL;
+
+			/*
+			 * These locks are used to prevent more than one 
+			 * CPU from modifying the queue at the same time. 
+			 * The higher level "io_request_lock" will reduce 
+			 * most contention for these locks.
+			 */
+			ha->retry_lock = SPIN_LOCK_UNLOCKED;
+
+			/* Insure mailbox registers are free. */
+			WRT_REG_WORD(&reg->semaphore, 0);
+			WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+			WRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);
+
+			/* Wait around max 5 secs for the devices to come 
+			 * on-line we don't want Linux scanning before we 
+			 * are ready.
+			 */
+			/* v2.19.5b6 */
+			for (wait_switch = jiffies+(ha->loop_reset_delay * HZ); 
+			    wait_switch > jiffies &&
+			    !(ha->device_flags & DFLG_FABRIC_DEVICES) ; ) {
+
+				qla2100_check_fabric_devices(ha);
+			}
+			/* just in case we turned it on */
+			ha->dpc_flags &= ~COMMAND_WAIT_NEEDED;
+
+			/* List the target we have found */
+			qla2100_display_fc_names(ha);
+
+			/* Enable chip interrupts. */
+			qla2100_enable_intrs(ha);
+
+			/* Insert new entry into the list of adapters */
+			ha->next = NULL;
+			if( qla2100_hostlist == NULL ) {
+				qla2100_hostlist = ha;
+			} else {
+				cur_ha = qla2100_hostlist;
+
+				while( cur_ha->next != NULL )
+					cur_ha = cur_ha->next;
+
+				cur_ha->next = ha;
+			}
+			num_hosts++;
+		}
+	} /* end of FOR */
+
+	LEAVE("qla2100_detect");
+	return num_hosts;
+}
+
+/**************************************************************************
+*   qla2100_register_with_Linux
+*
+* Description:
+*   Free the passed in Scsi_Host memory structures prior to unloading the
+*   module.
+*
+* Input:
+*     ha - pointer to host adapter structure
+*     maxchannels - MAX number of channels.
+*
+* Returns:
+*  0 - Sucessfully reserved resources.
+*  1 - Failed to reserved a resource.
+**************************************************************************/
+STATIC uint8_t  qla2100_register_with_Linux(scsi_qla_host_t *ha, uint8_t maxchannels) {
+
+        struct Scsi_Host *host = ha->host;
+        char drvname[9];
+
+        host->can_queue = 0xfffff;  /* unlimited  */
+        host->cmd_per_lun = 1;
+        host->select_queue_depths = qla2100_select_queue_depth;
+        host->n_io_port = 0xFF;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+        host->base = (unsigned char *) ha->mmpbase;
+#else
+        host->base = (u_long) ha->mmpbase;
+#endif
+        host->max_channel = maxchannels;
+        /* fix: 07/31 host->max_lun = MAX_LUNS-1; */
+        host->max_lun = ha->max_luns;
+        host->unique_id = ha->instance;
+        host->max_id = ha->max_targets;
+
+        /* set our host ID  (need to do something about our two IDs) */
+        host->this_id = 255;
+
+        /* Register the I/O space with Linux */
+        if( check_region(host->io_port, 0xff) ) {
+            printk(KERN_WARNING "qla2100 : [ERROR] Failed to reserved i/o region "
+		"0x%04lx-0x%04lx already in use\n",
+            host->io_port, host->io_port + 0xff);
+            /* 4.31.5 - deleted free_irq(host->irq, NULL); */
+            return 1;
+        }
+
+        /* ER# 4368 */
+        sprintf(drvname,"qla2x00#%02d",host->unique_id);
+
+        request_region(host->io_port, 0xff, drvname);
+
+
+        /* Register the IRQ with Linux (sharable) */
+        if( request_irq(host->irq, qla2100_intr_handler, SA_INTERRUPT| SA_SHIRQ, "qla2x00", ha) ) {
+            printk(KERN_WARNING "qla2100 : [ERROR] Failed to reserved interrupt %d "
+		"already in use\n", host->irq);
+            return 1;
+        }
+
+        /* Initialized the timer */
+        START_TIMER(qla2100_timer,ha,WATCH_INTERVAL);
+
+        return 0;
+}
+
+
+/**************************************************************************
+*   qla2100_release
+*
+* Description:
+*   Free the passed in Scsi_Host memory structures prior to unloading the
+*   module.
+*
+* Input:
+*     ha - pointer to host adapter structure
+*
+* Returns:
+*  0 - Always returns good status
+**************************************************************************/
+int
+qla2100_release(struct Scsi_Host *host) {
+        scsi_qla_host_t *ha = (scsi_qla_host_t *) host->hostdata;
+
+        ENTER("qla2100_release");
+        /* if adpater is running and online */
+        if( !ha->flags.online )
+            return(0);
+
+        /* turn-off interrupts on the card */
+        qla2100_disable_intrs(ha);
+
+        /* Detach interrupts */
+        if( host->irq )
+            free_irq(host->irq, ha);
+
+        /* release io space registers  */
+        if( host->io_port )
+            release_region(host->io_port, 0xff);
+
+        /* Disable timer */
+        if( ha->timer_active )
+            STOP_TIMER(qla2100_timer,ha)
+
+            /* Kill the kernel thread for this host */
+            if( ha->dpc_handler != NULL ) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                struct semaphore sem = MUTEX_LOCKED;
+#else
+                DECLARE_MUTEX_LOCKED(sem);
+#endif
+
+                ha->dpc_notify = &sem;
+                send_sig(SIGKILL, ha->dpc_handler, 1);
+                down(&sem);
+                ha->dpc_notify = NULL;
+            }
+#if USE_FLASH
+            /* Move driver database to flash, if enabled. */
+            if( ha->flags.enable_flash_db_update && ha->flags.updated_fc_db ) {
+                ha->flags.updated_fc_db = FALSE;
+                qla2100_save_database(ha);
+            }
+#endif
+#if MEMORY_MAPPED_IO
+            if( ha->mmpbase ) {
+                iounmap((void *) (((unsigned long) ha->mmpbase) & PAGE_MASK));
+            }
+#endif /* MEMORY_MAPPED_IO */
+
+#if  APIDEV
+            apidev_cleanup();
+#endif
+
+            qla2100_mem_free(ha);
+            ha->flags.online = FALSE;
+
+            LEAVE("qla2100_release");
+            return(0);
+}
+
+/**************************************************************************
+*   qla2100_info
+*
+* Description:
+*
+* Input:
+*     host - pointer to Scsi host adapter structure
+*
+* Returns:
+*     Return a text string describing the driver.
+**************************************************************************/
+const char *
+qla2100_info(struct Scsi_Host *host) {
+        static char qla2100_buffer[255];
+        char *bp;
+        scsi_qla_host_t *ha;
+        qla_boards_t   *bdp;
+
+#if  APIDEV
+/* We must create the api node here instead of qla2100_detect since we want
+   the api node to be subdirectory of /proc/scsi/qla2x00 which will not
+   have been created when qla2100_detect exits, but which will have been
+   created by this point. */
+
+        apidev_init(host);
+#endif
+        bp = &qla2100_buffer[0];
+        ha = (scsi_qla_host_t *)host->hostdata;
+        bdp = &QLBoardTbl_fc[ha->devnum];
+        memset(bp, 0, sizeof(qla2100_buffer));
+        sprintf(bp,
+        "QLogic %sPCI to Fibre Channel Host Adapter: bus %d device %d irq %d\n"
+        "        Firmware version: %2d.%02d.%02d, Driver version %s",
+        (char *)&bdp->bdName[0], ha->pci_bus, (ha->pci_device_fn & 0xf8) >> 3, host->irq,
+        bdp->fwver[0], bdp->fwver[1], bdp->fwver[2], QLA2100_VERSION);
+        return(bp);
+}
+
+/**************************************************************************
+*   qla1200_queuecommand
+*
+* Description:
+*     Queue a command to the controller.
+*
+* Input:
+*     cmd - pointer to Scsi cmd structure
+*     fn - pointer to Scsi done function
+*
+* Returns:
+*   0 - Always
+*
+* Note:
+* The mid-level driver tries to ensures that queuecommand never gets invoked
+* concurrently with itself or the interrupt handler (although the
+* interrupt handler may call this routine as part of request-completion
+* handling).
+**************************************************************************/
+int
+qla2100_queuecommand(Scsi_Cmnd *cmd, void (*fn)(Scsi_Cmnd *)) {
+        scsi_qla_host_t *ha;
+        srb_t  *sp;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+        unsigned long cpu_flags = 0;
+#endif
+        struct Scsi_Host *host;
+        uint32_t        b, t, l;
+        scsi_lu_t       *q;
+        u_long          handle;
+
+        ENTER("qla2100_queuecommand");
+        COMTRACE('C') 
+
+        host = cmd->host;
+        ha = (scsi_qla_host_t *) host->hostdata;
+        /* Get our SCSI request pointer
+        * SCp always point to it - see definition in qla2100.h.
+        */
+        sp = (srb_t *) CMD_SP(cmd);
+        sp->cmd =  cmd;
+        cmd->scsi_done = fn;
+
+        /* If we not trying to do a recovery procedure of some sort
+        * then this is probably a new command.
+        */
+        if( cmd->flags == 0 &&
+        cmd->retries == 0 )
+            sp->flags = 0;
+
+        /* Generate LU queue on bus, target, LUN */
+        b = SCSI_BUS_32(cmd);
+        t = SCSI_TCN_32(cmd);
+        l = SCSI_LUN_32(cmd);
+
+        DEBUG5(qla2100_print_scsi_cmd(cmd);)
+        DEBUG5(sprintf(debug_buff,"qla2100_queuecmd: pid=%d, opcode=%d, timeout=%d\n",cmd->pid,cmd->cmnd[0],CMD_TIMEOUT(cmd));)
+        DEBUG5(qla2100_print(debug_buff);)
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+        /*DEBUG(sprintf(debug_buff,"\n\nQC: t=%x CDB=%x Size=%x\n\r",
+        t,cmd->cmnd[0],CMD_XFRLEN(cmd));)
+        DEBUG(qla2100_print(debug_buff)); */ 
+#endif
+        /*
+        * We found all the devices at LIP time, and created a device
+        * table for them, so we only need to check the table to see
+        * if the device is present. if PORT_AVAILABLE or PORT_UNUSED
+        * then no target exists.
+        *
+        * We return DID_NO_CONNECT if the loop is down after loop down
+        * timer has expired.
+        */
+        if( TGT_Q(ha,b,t) == NULL ||
+           (TGT_Q(ha,b,t) && TGT_Q(ha,b,t)->loop_id > LAST_SNS_LOOP_ID)  ) {
+            /* DEBUG2(printk("scsi(%2d:%2d:%2d:%2d): port unavailable\n",
+            (int)ha->host_no,b,t,l);) */ 
+            CMD_RESULT(sp->cmd) = DID_NO_CONNECT << 16;
+            qla2100_callback(ha,sp,FALSE);
+            LEAVE("qla2100_queuecommand");
+            return(0);
+        }
+        /* v218b4 */ 
+        if (ha->loop_down_timer == 0 && 
+            ha->loop_state == LOOP_DOWN ){  /* 01/21/00 DG */
+            DEBUG2(printk("scsi(%2d:%2d:%2d:%2d): Loop down - returning pid=%ld \n",(int)ha->host_no,b,t,l,cmd->pid);)
+            CMD_RESULT(sp->cmd) = DID_NO_CONNECT << 16;
+            ha->flags.done_requests_needed = TRUE;
+            qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+            LEAVE("qla2100_queuecommand");
+            return(0);
+        }
+
+        /*
+        * Allocate a LUN/DEVICE queue from this request if we haven't
+        * already did it on a previous command.
+        */
+        if( (q = GET_LU_Q(ha, b, t,l)) == NULL ) {
+            DRIVER_LOCK
+            if( (q = qla2100_lun_alloc()) == NULL ) {
+                CMD_RESULT(sp->cmd) = DID_RETRY << 16;
+                qla2100_callback(ha,sp,FALSE);
+                return(0);
+            }
+            LU_Q(ha, b, t, l) = q;
+            DEBUG(sprintf(debug_buff,"Allocate new device queue 0x%x\n",q));
+            DEBUG(qla2100_print(debug_buff));
+            DRIVER_UNLOCK
+        }
+
+        /* Set an invalid handle until we issue the command to ISP */
+        /* then we will set the real handle value.                 */
+        handle = INVALID_HANDLE;
+        CMD_HANDLE(cmd) = (unsigned char *)handle;
+
+#if QLA2100_EXT_TIMEOUT
+        /* Extend timeout for this request */
+        qla2100_extend_timeout(cmd,60*HZ);
+#endif
+
+        /*
+        * SCSI Kluge
+        * ========
+        * Whenever, we need to wait for an event such as loop down
+        * (i.e. loop_down_timer ) or port down (i.e. LUN request qeueue is
+        * suspended) then we will recycle new commands back to the SCSI layer.
+        * We do this because this is normally a temporary condition and we don't
+        * want the mid-level scsi.c driver to get upset and start aborting
+        * commands.
+
+        * The timeout value is extracted from the command minus 1-second
+        * and put on a retry queue (watchdog). Once the command timeout it
+        * is returned to the mid-level with a BUSY status, so the mid-level
+        * will retry it. This process continues until the LOOP DOWN time
+        * expires or the condition goes away.
+        */
+        if( ha->loop_down_timer ||
+        ha->loop_state ==  LOOP_DOWN ||
+        (PORT_DOWN(ha,t) > 0) ||
+        ha->loop_state != LOOP_READY ||
+        (q->q_flag & QLA2100_QSUSP) ) {
+            /* Insert command into watchdog queue */
+            qla2100_timeout_insert(ha, sp);
+            LEAVE("qla2100_queuecommand");
+            return (0);
+        }
+        /* Set retry count if this is a new command */
+        if( sp->flags == 0 &&
+        !(q->q_flag & QLA2100_QSUSP) ) {
+            sp->retry_count = ha->retry_count;
+            if( TGT_Q(ha, b, t)->down_timer == 0 ) 
+	    	sp->port_down_retry_count = ha->port_down_retry_count;
+        }
+
+        /* No timeout necessary, because the upper layer is doing it for us */
+        sp->wdg_time = 0;
+
+        /* add the command to our queue */
+        ha->qthreads++;
+        qla2100_putq_t(q,sp);
+
+        DEBUG5(sprintf(debug_buff,"\nQC: queue pid=%d, hndl=0x%x\n\r",
+               cmd->pid,handle));
+        DEBUG5(qla2100_print(debug_buff));
+
+        /* send command to adapter */
+        qla2100_restart_queues(ha,FALSE);
+
+        COMTRACE('c')
+        LEAVE("qla2100_queuecommand"); 
+        return (0);
+}
+
+/**************************************************************************
+*   qla1200_abort
+*
+* Description:
+*     Abort the specified SCSI command.
+*
+* Input:
+*     cmd - pointer to Scsi cmd structure
+*
+* Returns:
+**************************************************************************/
+int
+qla2100_abort(Scsi_Cmnd *cmd) {
+        scsi_qla_host_t *ha;
+        srb_t  *sp;
+        srb_t  *rp, *rp_next;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+        unsigned long cpu_flags = 0;
+#endif
+        struct Scsi_Host *host;
+        uint32_t        b, t, l;
+        scsi_lu_t       *q;
+        int return_status = SCSI_ABORT_SUCCESS;
+        int found = 0;
+        int i;
+        u_long          handle;
+
+        uint16_t    data;
+
+        ENTER("qla2100_abort");
+        COMTRACE('A')
+
+        ha = (scsi_qla_host_t *) cmd->host->hostdata;
+        host = cmd->host;
+
+#if DEBUG_GET_FW_DUMP
+        if (ha->device_id == QLA2300_DEVICE_ID)
+        {  
+          if (ha->dump_done != 1) {
+              DEBUG(sprintf(debug_buff,"\nqla2100_abort handle=%x: >>>>>>> DUMP 2300 FW <<<<<<<\n",CMD_HANDLE(cmd));)
+              DEBUG(qla2100_print(debug_buff);)
+              qla2300_dump_isp(ha);
+              ha->dump_done = 1;
+          }
+        }
+#endif
+
+        DRIVER_LOCK
+        /* Get the SCSI request ptr */
+        sp = (srb_t *) CMD_SP(cmd);
+
+        /*
+        * if the handle is NULL then we already completed the command.
+        * We always give the handle a value of "INVALID_HANDLE" when
+        * we received it.
+        */
+        if( (u_long)   CMD_HANDLE(cmd) == 0L ) {
+
+            DRIVER_UNLOCK
+#if  STOP_ON_ABORT
+            qla2100_panic("qla2100_abort",ha->host);
+#endif
+            return(SCSI_ABORT_NOT_RUNNING);  /* no action - we don't have command */
+        }
+
+        /* Check for a pending interrupt. */
+        if (ha->device_id == QLA2300_DEVICE_ID) 
+             data = qla2100_debounce_register((uint16_t *)&ha->iobase2300->host_status) &   RISC_2300_INT;
+        else data = qla2100_debounce_register(&ha->iobase->istatus) & 
+                    RISC_INT;
+
+        /* Check for pending interrupts. */
+        if( !(ha->flags.in_isr) && (data)) {
+            /* Add any completed commands in the done queue */
+            DEBUG(qla2100_print("qla2100_abort: Calling isr\n");)
+            qla2100_isr(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+        }
+
+        /*
+        * if no LUN queue then something is very wrong!!!
+        */
+        handle = (u_long) CMD_HANDLE(cmd);
+
+        /* Generate LU queue on bus, target, LUN */
+        b = SCSI_BUS_32(cmd);
+        t = SCSI_TCN_32(cmd);
+        l = SCSI_LUN_32(cmd);
+        if( (q = GET_LU_Q(ha, b, t, l)) == NULL ) {
+            COMTRACE('a')
+
+            DRIVER_UNLOCK
+            printk(KERN_WARNING "qla2100 (%d:%d:%d): No LUN queue for the specified device\n",(int)b,(int)t,(int)l);
+            return(SCSI_ABORT_NOT_RUNNING);  /* no action - we don't have command */
+        }
+
+#if AUTO_ESCALATE_ABORT
+        if( (sp->flags & SRB_ABORTED) ) {
+            DRIVER_UNLOCK
+            DEBUG(qla2100_print("qla2100_abort: Abort escalayted - returning SCSI_ABORT_SNOOZE.\n\r"));
+            return(SCSI_ABORT_SNOOZE);
+        }
+#endif
+        /*
+        * if the command ahs a abort pending then tell the upper layer
+        */
+        if( (sp->flags & SRB_ABORT_PENDING) ) {
+            COMTRACE('a')
+            DRIVER_UNLOCK
+            if( qla2100_verbose )
+                printk(KERN_INFO "scsi(): Command has a pending abort "
+		    "message - ABORT_PENDING.\n");
+            DEBUG(qla2100_print("qla2100: Command has a pending abort message - ABORT_PENDING.\n\r"));
+            return(SCSI_ABORT_PENDING);
+        }
+
+        DEBUG(sprintf(debug_buff,"ABORTing command= 0x%x, sp=%x sp->state=%x\n",
+        (int)cmd,sp,sp->state);)
+        DEBUG(qla2100_print(debug_buff);)
+        DEBUG(qla2100_print_scsi_cmd(cmd));
+
+        for( rp = ha->retry_q_first; (rp); rp = rp_next ) {
+            rp_next = rp->s_next;
+            if( sp != rp )
+                continue;
+            qla2100_timeout_remove(ha, sp);
+            CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+            CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+            qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+            found++;
+        }
+
+        /*
+        * Our SP pointer points at the command we want to remove from the
+        * LUN queue providing we haven't already sent it to the adapter.
+        */
+        if( found )
+            return_status = SCSI_ABORT_SUCCESS;
+        else if( !(sp->flags&SRB_SENT) ) {
+            found++;
+            DEBUG(sprintf(debug_buff,"qla2100: Cmd in LUN queue aborted pid %d.\n\r",sp->cmd->pid);)
+            DEBUG(qla2100_print(debug_buff);)
+            /* Remove srb from SCSI LU queue. */
+            qla2100_removeq(q, sp);
+            sp->flags |=  SRB_ABORTED;
+            CMD_RESULT(cmd) = DID_ABORT << 16;
+            qla2100_done_q_put(ha, sp, &ha->done_q_first, &ha->done_q_last);
+            return_status = SCSI_ABORT_SUCCESS;
+            found++;
+        } else {  /* find the command in our active list */
+            for( i = 1; i < MAX_OUTSTANDING_COMMANDS; i++ ) {
+                if( sp == ha->outstanding_cmds[i] ) {
+                    found++;
+                    DEBUG(sprintf(debug_buff,
+                          "qla2100: RISC aborting pid %d sp->state=%x\n\r",
+                          sp->cmd->pid,sp->state);)
+                    DEBUG(qla2100_print(debug_buff);)
+                    /* DEBUG(qla2100_print_scsi_cmd(cmd)); */
+                    DEBUG(qla2100_print_q_info(q);)
+                    /* v2.19.8 Ignore abort request if port is down */
+                        if ( qla2100_abort_command(ha,sp) ) {
+                            DEBUG(printk("qla2100: Failed to abort pid %ld.\n",sp->cmd->pid);)
+                            return_status = SCSI_ABORT_NOT_RUNNING;  /* no action */
+                        }
+                    else
+                        return_status = SCSI_ABORT_PENDING;
+                    break;
+                }
+            }
+        }
+
+#if  STOP_ON_ABORT
+        qla2100_panic("qla2100_abort",ha->host);
+#endif
+        if( found == 0 )
+            return_status = SCSI_ABORT_NOT_RUNNING;  /* no action */
+
+        DEBUG(sprintf(debug_buff, "qla2100_abort: Aborted status returned = 0x%x.\n\r",return_status));
+        DEBUG(qla2100_print(debug_buff));
+        /*
+        * Complete any commands
+        */
+        if( ha->done_q_first )
+            qla2100_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+
+        if( found ) {
+            qla2100_restart_queues(ha,TRUE);
+        }
+        DRIVER_UNLOCK
+
+        LEAVE("qla2100_abort");
+        COMTRACE('a')
+        return(return_status);
+}
+
+/**************************************************************************
+* qla1200_reset
+*
+* Description:
+*    The reset function will reset the SCSI bus and abort any executing
+*    commands.
+*
+* Input:
+*      cmd = Linux SCSI command packet of the command that cause the
+*            bus reset.
+*      flags = SCSI bus reset option flags (see scsi.h)
+*
+* Returns:
+*      DID_RESET in cmd.host_byte of aborted command(s)
+*
+* Note:
+*      Resetting the bus always succeeds - is has to, otherwise the
+*      kernel will panic! Try a surgical technique - sending a BUS
+*      DEVICE RESET message - on the offending target before pulling
+*      the SCSI bus reset line.
+**************************************************************************/
+int
+qla2100_reset(Scsi_Cmnd *cmd, unsigned int flags) {
+        scsi_qla_host_t *ha;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+        unsigned long cpu_flags = 0;
+#endif
+        uint32_t        b, t, l;
+        srb_t  *sp;
+        typedef enum {
+            ABORT_DEVICE = 1,
+            DEVICE_RESET = 2,
+            BUS_RESET    = 3,
+            ADAPTER_RESET= 4,
+            RESET_DELAYED= 5,
+            FAIL         = 6
+        } action_t;
+        action_t     action = ADAPTER_RESET;
+        uint16_t    data;
+        scsi_lu_t       *q;
+        int result;
+
+
+        ENTER("qla2100_reset");
+        COMTRACE('R')
+        if( cmd == NULL ) {
+            printk(KERN_WARNING "(scsi?:?:?:?) Reset called with NULL Scsi_Cmnd "
+            "pointer, failing.\n");
+            return(SCSI_RESET_SNOOZE);
+        }
+        ha = (scsi_qla_host_t *) cmd->host->hostdata;
+        sp = (srb_t *) CMD_SP(cmd);
+
+#if  STOP_ON_RESET
+        sprintf(debug_buff,"ABORTing command= 0x%x\n",(int)cmd);
+        qla2100_print(debug_buff);
+        qla2100_print_scsi_cmd(cmd);
+        qla2100_panic("qla2100_reset",ha->host);
+#endif
+
+
+        DRIVER_LOCK
+        if (ha->device_id == QLA2300_DEVICE_ID) 
+             data = qla2100_debounce_register((uint16_t *)&ha->iobase2300->host_status) &
+                    RISC_2300_INT;
+        else data = qla2100_debounce_register(&ha->iobase->istatus) & 
+                    RISC_INT;
+
+        /* Check for pending interrupts. */
+        if( !(ha->flags.in_isr) && (data) ) {
+            DEBUG(qla2100_print("qla2100_reset: Calling isr\n");)
+            qla2100_isr(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+        }
+        DRIVER_UNLOCK
+
+        /*
+        * Determine the suggested action that the mid-level driver wants
+        * us to perform.
+        */
+        if( CMD_HANDLE(cmd) == (unsigned char *) 0 ) {
+            /*
+            * if mid-level driver called reset with a orphan SCSI_Cmnd
+            * (i.e. a command that's not pending ), so perform the
+            * function specified.
+            */
+            /* 4.23 */
+            if( (flags & SCSI_RESET_SUGGEST_HOST_RESET) )
+                action = ADAPTER_RESET;
+            else if( flags & SCSI_RESET_SUGGEST_BUS_RESET )
+                action = BUS_RESET;
+            else
+                action = DEVICE_RESET;
+        } else { /*
+            * Mid-level driver has called reset with this SCSI_Cmnd and
+            * its pending.
+            */
+            if( flags & SCSI_RESET_SUGGEST_HOST_RESET )
+                action = ADAPTER_RESET;
+            else if( flags & SCSI_RESET_SUGGEST_BUS_RESET )
+                action = BUS_RESET;
+            else
+                action = DEVICE_RESET;
+        }
+
+        b = SCSI_BUS_32(cmd);
+        t = SCSI_TCN_32(cmd);
+        l = SCSI_LUN_32(cmd);
+        q = GET_LU_Q(ha, b, t, l);
+
+#if AUTO_ESCALATE_RESET
+        if( (action & DEVICE_RESET) && (q->q_flag & QLA2100_QRESET) ) {
+            printk(KERN_INFO "qla2100(%d): Bus device reset already sent to " "device, escalating.\n", (int)ha->host_no);
+            action = BUS_RESET;
+        }
+        if( (action & DEVICE_RESET) && (sp->flags & SRB_ABORT_PENDING) ) {
+            printk(KERN_INFO "qla2100(%d):Have already attempted to reach " "device with abort device\n", (int)ha->host_no);
+            printk(KERN_INFO "qla2100(%d):message, will escalate to BUS " "RESET.\n",(int) ha->host_no);
+            action = BUS_RESET;
+        }
+#endif
+
+        /*
+        *  By this point, we want to already know what we are going to do,
+        *  so we only need to perform the course of action.
+        */
+
+        DRIVER_LOCK
+        result = SCSI_RESET_ERROR;
+        switch( action ) {
+            case FAIL:
+                break;
+
+            case RESET_DELAYED:
+                result = SCSI_RESET_PENDING;
+                break;
+
+            case ABORT_DEVICE:
+                if( qla2100_verbose )
+                    printk(KERN_INFO "scsi(%d:%d:%d:%d): ABORT DEVICE ISSUED.\n", (int)ha->host_no,(int)b,(int)t,(int)l);
+                qla2100_abort_queue_single(ha,b,t,l,DID_ABORT);
+                if( !ha->loop_down_timer )
+                    if( qla2100_abort_device(ha, b, t, l) == 0 )
+                        result = SCSI_RESET_PENDING;
+                    break;
+
+                case DEVICE_RESET:
+                    if( qla2100_verbose )
+                        printk(KERN_INFO "scsi(%d:%d:%d:%d): DEVICE RESET ISSUED.\n",(int) ha->host_no,(int)b,(int)t,(int)l);
+                    for( l = 0; l <  ha->max_luns; l++ )
+                        qla2100_abort_queue_single(ha,b,t,l,DID_ABORT);
+                    if( !ha->loop_down_timer )
+                        if( qla2100_device_reset(ha, b, t) == 0 )
+                            result = SCSI_RESET_PENDING;
+                        q->q_flag |= QLA2100_QRESET;
+                        break;
+
+                    case BUS_RESET:
+                        if( qla2100_verbose )
+                            printk(KERN_INFO "scsi(%d:%d:%d:%d): LOOP RESET ISSUED.\n",(int) ha->host_no,(int)b,(int)t,(int)l);
+                        for( t = 0; t < ha->max_targets; t++ )
+                            for( l = 0; l <  ha->max_luns; l++ )
+                                qla2100_abort_queue_single(ha,b,t,l,DID_RESET);
+                            if( !ha->loop_down_timer )
+                                if( qla2100_loop_reset(ha) == 0 )
+                                    result = SCSI_RESET_SUCCESS | SCSI_RESET_BUS_RESET;
+                                /*
+                                * The reset loop routine returns all the outstanding commands back
+                                * with "DID_RESET" in the status field.
+                                */
+                                if( flags & SCSI_RESET_SYNCHRONOUS ) {
+                                    CMD_RESULT(cmd) = (int) (DID_BUS_BUSY << 16);
+                                    (*(cmd)->scsi_done)(cmd);
+                                }
+
+                                /* ha->reset_start = jiffies; */
+                                break;
+
+                            case ADAPTER_RESET:
+                            default:
+                                if( qla2100_verbose ) {
+                                        printk(KERN_INFO "scsi(%d:%d:%d:%d): ADAPTER RESET ISSUED.\n",(int) ha->host_no,(int)b,(int)t,(int)l);
+                                }
+                                ha->flags.reset_active = TRUE;
+                                /*
+                                * We restarted all of the commands automatically, so the mid-level code can expect
+                                * completions momentitarily.
+                                */
+                                if( qla2100_abort_isp(ha) == 0 )
+                                    result = SCSI_RESET_SUCCESS | SCSI_RESET_HOST_RESET;
+
+                                ha->flags.reset_active = FALSE;
+        }
+
+        if( ha->done_q_first )
+            qla2100_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+        qla2100_restart_queues(ha,TRUE);
+        DRIVER_UNLOCK
+
+        COMTRACE('r')
+        LEAVE("qla2100_reset");
+        return(result);
+}
+
+/**************************************************************************
+* qla1200_biosparam
+*
+* Description:
+*   Return the disk geometry for the given SCSI device.
+**************************************************************************/
+int
+qla2100_biosparam(Disk *disk, kdev_t dev, int geom[]) {
+        int heads, sectors, cylinders;
+
+        heads = 64;
+        sectors = 32;
+        cylinders = disk->capacity / (heads * sectors);
+        if( cylinders > 1024 ) {
+            heads = 255;
+            sectors = 63;
+            cylinders = disk->capacity / (heads * sectors);
+        }
+
+        geom[0] = heads;
+        geom[1] = sectors;
+        geom[2] = cylinders;
+
+        return (0);
+}
+
+/**************************************************************************
+* qla2100_intr_handler
+*
+* Description:
+*   Handles the actual interrupt from the adapter.
+*
+* Context: Interrupt
+**************************************************************************/
+void
+qla2100_intr_handler(int irq, void *dev_id, struct pt_regs *regs) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,95)
+        unsigned long cpu_flags = 0;
+#endif
+        scsi_qla_host_t *ha;
+        uint16_t    data;
+        device_reg_t *reg;
+        device2300_reg_t *reg2300;
+
+        ENTER_INTR("qla2100_intr_handler");
+        COMTRACE('I')
+        ha = (scsi_qla_host_t *) dev_id;
+        if( !ha ) {
+            printk(KERN_INFO "qla2100_intr_handler: NULL host ptr\n");
+            COMTRACE('X')
+            return;
+        }
+        ha->isr_count++;
+        qla2100_stats.irqhba = ha;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,95)
+        /* Prevent concurrent access to adapters register */
+        spin_lock_irqsave(&io_request_lock, cpu_flags);
+        qla2100_disable_intrs(ha);
+
+        if (ha->device_id == QLA2300_DEVICE_ID) {
+             reg2300 = ha->iobase2300;
+             data    = qla2100_debounce_register(
+                       (uint16_t *)&reg2300->host_status) &  RISC_2300_INT;
+        } else {
+              reg     = ha->iobase;
+              data    = qla2100_debounce_register(&reg->istatus) & 
+                        RISC_INT;
+         }
+
+        /* Check for pending interrupts. */
+        if( data ) {
+         /*DEBUG(qla2100_print("qla2100_intr_handler: Int active, Calling isr\n");)*/
+          qla2100_isr(ha, 
+                     (srb_t **)&ha->done_q_first, 
+                     (srb_t **)&ha->done_q_last);
+        }
+
+        if( ha->done_q_first )
+            qla2100_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+
+        spin_unlock_irqrestore(&io_request_lock, cpu_flags);
+        qla2100_enable_intrs(ha);
+
+        /* Wakeup the DPC routine */
+        if( (!ha->flags.mbox_busy && (ha->flags.isp_abort_needed   ||
+        ha->flags.reset_marker       ||
+        ha->flags.update_config_needed       ||
+        ( !ha->flags.loop_resync_active &&
+        ha->flags.loop_resync_needed)  ) )
+        && ha->dpc_wait && !ha->dpc_active ) {  /* v2.19.4 */
+            up(ha->dpc_wait);
+        }
+
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95) */
+
+        /* Prevent concurrent access to istatus register */
+        if( test_bit(QLA2100_IN_ISR_BIT, (int *)&ha->flags) ) {
+            COMTRACE('X')
+            DEBUG(printk("scsi%d: Already in interrupt - returning \n", (int)ha->host_no);)
+            return;
+        }
+        set_bit(QLA2100_IN_ISR_BIT, (int *)&ha->flags);
+        qla2100_disable_intrs(ha);
+
+        if (ha->device_id == QLA2300_DEVICE_ID) { 
+           reg2300 = ha->iobase2300;
+           data = qla2100_debounce_register(
+                  (uint16_t *)&reg2300->host_status) & RISC_2300_INT;
+        } else {
+           reg  = ha->iobase;
+           data = qla2100_debounce_register(&reg->istatus) & 
+                  RISC_INT;
+        }
+
+        /* Check for pending interrupts. */
+        if( data ) {
+            DEBUG(qla2100_print("qla2100_intr_handler_2: Int active, Calling isr\n");)
+            qla2100_isr(ha, 
+                        (srb_t **)&ha->done_q_first, 
+                        (srb_t **)&ha->done_q_last);
+        }
+
+        if( ha->done_q_first )
+            qla2100_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+
+
+        /* Schedule the DPC routine */
+        if( (ha->flags.isp_abort_needed   ||
+        ha->flags.reset_marker       ||
+        ( !ha->flags.loop_resync_active &&
+        ha->flags.loop_resync_needed) ||
+        ha->done_q_first ) && !ha->flags.dpc_sched ) {
+
+            ha->run_qla_bh.data = (void *) ha;
+            ha->run_qla_bh.routine = qla2100_do_dpc;
+
+            COMTRACE('P')
+            queue_task_irq(&ha->run_qla_bh,&tq_scheduler);
+            ha->flags.dpc_sched = TRUE;
+        }
+        clear_bit(QLA2100_IN_ISR_BIT, (int *)&ha->flags);
+        qla2100_enable_intrs(ha);
+#endif
+
+        COMTRACE('i')
+        LEAVE_INTR("qla2100_intr_handler");
+}
+
+/**************************************************************************
+* qla2100_do_dpc
+*   This kernel thread is a task that is schedule by the interrupt handler
+*   to perform the background processing for interrupts.
+*
+* Notes:
+* This task always run in the context of a kernel thread.  It
+* is kick-off by the driver's detect code and starts up
+* up one per adapter. It immediately goes to sleep and waits for
+* some fibre event.  When either the interrupt handler or
+* the timer routine detects a event it will one of the task
+* bits then wake us up.
+**************************************************************************/
+void
+qla2100_do_dpc(void *p) {
+        scsi_qla_host_t *ha = (scsi_qla_host_t *) p;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+        struct semaphore sem = MUTEX_LOCKED;
+#else 
+        DECLARE_MUTEX_LOCKED(sem);
+#endif
+        unsigned long flags;
+        srb_t *sp, *sp_next;
+        uint32_t        b, t, l;
+        scsi_lu_t       *q;
+        int status;
+
+        lock_kernel();
+
+        /*
+        * If we were started as result of loading a module, close all of the
+        * user space pages.  We don't need them, and if we didn't close them
+        * they would be locked into memory.
+        */
+        exit_mm(current);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+
+        daemonize();
+
+#endif
+        current->session = 1;
+        current->pgrp = 1;
+        /*
+        * FIXME(dg) this is still a child process of the one that did the insmod.
+        * This needs to be attached to task[0] instead.
+        */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+        siginitsetinv(&current->blocked, SHUTDOWN_SIGS);
+#else
+        siginitsetinv(&current->blocked, sigmask(SIGKILL));  
+#endif
+        current->fs->umask = 0;
+
+        /*
+        * Set the name of this process.
+        */
+        sprintf(current->comm, "qla2100_dpc_%d", (int)ha->host_no);
+
+        ha->dpc_wait = &sem;
+        ha->dpc_handler = current;
+
+        unlock_kernel();
+
+        /*
+        * Wake up the thread that created us.
+        */
+        DEBUG(printk("qla2100_dpc: Wake up parent %d\n", ha->dpc_notify->count.counter));
+
+        up(ha->dpc_notify);
+
+        while( 1 ) {
+            /*
+            * If we get a signal, it means we are supposed to go
+            * away and die.  This typically happens if the user is
+            * trying to unload a module.
+            */
+            DEBUG(printk("qla2100 %d: DPC handler sleeping\n",(int)ha->host_no));
+            down_interruptible(&sem);
+
+            if( signal_pending(current) )
+                break;   /* get out */
+
+            DEBUG(printk("qla2100 %d: DPC handler waking up\n",(int)ha->host_no);)
+
+	    if (ha->dpc_flags & COMMAND_WAIT_NEEDED) {
+		    /* Release task daemon lock. */
+                    DEBUG(printk("Waiting on commands to complete\n");)
+		    if( qla2100_cmd_wait(ha) )
+                       continue;
+		    /* Acquire task daemon lock. */
+	    }
+            spin_lock_irqsave(&io_request_lock, flags);
+            ha->dpc_active = 1;
+
+            /* Determine what action is necessary */
+
+            /* Flush all commands in watchdog queue */
+            if( ha->flags.port_restart_needed ) {
+                DEBUG(qla2100_print("qla2100: DPC port restarting - flushing all cmds in watchdog queue.\n");)
+                ha->flags.port_restart_needed = FALSE;
+                for( sp = ha->retry_q_first; (sp != NULL); sp =  sp_next ) {
+                    sp_next = sp->s_next;
+                    b = SCSI_BUS_32(sp->cmd);
+                    t = SCSI_TCN_32(sp->cmd);
+                    l = SCSI_LUN_32(sp->cmd);
+                    if( (q = GET_LU_Q(ha, b, t,l)) == NULL ||
+                    !(q->q_flag & QLA2100_QSUSP) )
+                        continue;
+                    q->q_flag &= ~QLA2100_QSUSP;
+                    qla2100_timeout_remove(ha, sp);
+                    CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+                    CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+                    qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+                }
+
+                /* v2.19 -  We want to wait until the end to 
+                 * return all requests back to OS.
+                 */ 
+                /* deleted: qla2100_restart_queues(ha, FALSE); */
+                ha->flags.restart_queues_needed = TRUE;
+            }
+
+            /* Process any pending mailbox commands */
+            if( !ha->flags.mbox_busy ) {
+                if( ha->flags.isp_abort_needed ) {
+                    DEBUG(printk("dpc: qla2100_abort_isp ha = %p\n", ha);)
+                    ha->flags.isp_abort_needed = FALSE;
+                    qla2100_abort_isp(ha);
+                }
+
+                if( ha->flags.reset_marker ) {
+                    DEBUG(printk("dpc: qla2100_reset_marker \n");)
+                    qla2100_rst_aen(ha);
+                }
+
+                if( ha->flags.update_config_needed ) {
+                    DEBUG(printk("dpc: qla2100_update_config\n");)
+                    qla2100_update_config(ha);
+                }
+
+                /* v2.19.8 Retry each device up to login retry count */
+                if ( (ha->device_flags & RELOGIN_NEEDED) &&
+                     !ha->loop_state != LOOP_DOWN ) { /* v2.19.5 */
+                    DEBUG(printk("dpc: qla2100_login\n");)
+                    ha->device_flags &= ~RELOGIN_NEEDED;
+                    for (t = 0; t < MAX_FIBRE_DEVICES; t++) {
+					    /* check if fabric logic retry needed */
+						if ( (ha->fc_db[t].flag & DEV_PUBLIC) &&
+						     (ha->fc_db[t].flag & DEV_RELOGIN) ) {
+							if ( PORT_DOWN(ha,t) ) {
+                                PORT_DOWN(ha,t)--;
+                                if ( (status = qla2x00_login_public_device(ha,
+                                  &ha->fc_db[t].loop_id,
+                                  &ha->fc_db[t].port_id[0],
+                                  (uint16_t) MBC_NO_PLOGI_IF_LOGGED_IN)) == QL_STATUS_SUCCESS ) {
+                                    DEBUG(printk("dpc: logged in ID %x\n",ha->fc_db[t].loop_id);)
+							        /* restart ports */
+						            ha->fc_db[t].flag &= ~DEV_RELOGIN;
+                                    PORT_DOWN(ha,t) = 0;
+                                  } else if ( status == QL_STATUS_FATAL_ERROR ) {
+                                    ha->flags.isp_abort_needed = TRUE;
+						            ha->fc_db[t].flag &= ~DEV_RELOGIN;
+                                    PORT_DOWN(ha,t) = 0;
+                                  } else {
+								    /* retry the login again */
+                                    ha->device_flags |= RELOGIN_NEEDED;
+                                    DEBUG(printk("dpc: Retry %d logged in ID %x\n",PORT_DOWN(ha,t),
+									      ha->fc_db[t].loop_id);)
+								  }
+							}
+						}
+                    }
+                    DEBUG(printk("dpc: qla2100_login_end.\n");)
+                }
+
+                /* v2.19.5 */
+                if ( (ha->device_flags & LOGIN_RETRY_NEEDED) &&
+                     !ha->loop_state != LOOP_DOWN ) { /* v2.19.5 */
+                    ha->device_flags &= ~LOGIN_RETRY_NEEDED;
+                    DEBUG(printk("dpc: qla2100_login_retry\n");)
+                    qla2100_loop_resync(ha);
+                    DEBUG(printk("dpc: qla2100_login_retry end.\n");)
+                }
+
+                 /* v2.19.5b5 */
+                if( ha->flags.loop_resync_needed ) {
+                   if( (ha->device_flags & RSCN_UPDATE ) ) {
+                     DEBUG(printk("dpc: qla2100_rscn_update\n");)
+                     ha->device_flags &= ~RSCN_UPDATE;
+                   }
+                   else
+                     DEBUG(printk("dpc: qla2100_loop_resync\n");)
+                     qla2100_loop_resync(ha);
+                    DEBUG(printk("dpc: qla2100_loop_resync/rscn_update done\n");)
+                }
+
+                if( ha->flags.restart_queues_needed ) {
+                    DEBUG(printk("dpc: calling qla2100_restart_queues\n");)
+                    qla2100_restart_queues(ha,FALSE);
+                }
+
+                if( ha->flags.abort_queue_needed ) {
+                    DEBUG(printk("dpc: qla2100_abort_queues\n");)
+                    qla2100_abort_queues(ha, FALSE);
+                }
+                if( !ha->interrupts_on )
+                    qla2100_enable_intrs(ha);
+            }
+
+            if( ha->flags.done_requests_needed )
+                ha->flags.done_requests_needed = FALSE;
+
+            if( ha->done_q_first ) {
+                qla2100_done(ha, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+            }
+
+            ha->dpc_active = 0;
+
+            /* The spinlock is really needed up to this point. (DB) */
+            spin_unlock_irqrestore(&io_request_lock, flags);
+        }
+        DEBUG(qla2100_print("dpc: DPC handler exiting\n");)
+
+        /*
+        * Make sure that nobody tries to wake us up again.
+        */
+        ha->dpc_wait = NULL;
+        ha->dpc_handler = NULL;
+        ha->dpc_active = 0;
+
+        /*
+        * If anyone is waiting for us to exit (i.e. someone trying to unload
+        * a driver), then wake up that process to let them know we are on
+        * the way out the door.  This may be overkill - I *think* that we
+        * could probably just unload the driver and send the signal, and when
+        * the error handling thread wakes up that it would just exit without
+        * needing to touch any memory associated with the driver itself.
+        */
+        if( ha->dpc_notify != NULL )
+            up(ha->dpc_notify);
+
+
+}
+
+/**************************************************************************
+* qla2100_device_queue_depth
+*   Determines the queue depth for a given device.  There are two ways
+*   a queue depth can be obtained for a tagged queueing device.  One
+*   way is the default queue depth which is determined by whether
+*   If it is defined, then it is used
+*   as the default queue depth.  Otherwise, we use either 4 or 8 as the
+*   default queue depth (dependent on the number of hardware SCBs).
+**************************************************************************/
+STATIC void qla2100_device_queue_depth(scsi_qla_host_t *p, Scsi_Device *device) {
+        int default_depth = 16;
+         
+        device->queue_depth = default_depth;
+        if( device->tagged_supported ) {
+            device->tagged_queue = 1;
+            device->current_tag = 0;
+#ifdef MODULE
+            if( !(ql2xmaxqdepth == 0 || ql2xmaxqdepth > 256) )
+              device->queue_depth = ql2xmaxqdepth;
+#endif
+
+            printk(KERN_INFO "scsi(%d:%d:%d:%d): Enabled tagged queuing, queue depth %d.\n",
+            (int)p->host_no, device->channel, device->id,
+            device->lun, device->queue_depth);
+        } else {
+            printk(KERN_WARNING "scsi(%d:%d:%d:%d):Device does not supoort tags queuing!!!.\n",
+            (int)p->host_no, device->channel, device->id,
+            device->lun);
+        }
+}
+
+/**************************************************************************
+*   qla2100_select_queue_depth
+*
+* Description:
+*   Sets the queue depth for each SCSI device hanging off the input
+*   host adapter.  We use a queue depth of 2 for devices that do not
+*   support tagged queueing.
+**************************************************************************/
+STATIC void
+qla2100_select_queue_depth(struct Scsi_Host *host, Scsi_Device *scsi_devs) {
+        Scsi_Device *device;
+        scsi_qla_host_t  *p = (scsi_qla_host_t *) host->hostdata;
+
+        ENTER("qla2100_select_queue_depth");
+        for( device = scsi_devs; device != NULL; device = device->next ) {
+            if( device->host == host )
+                qla2100_device_queue_depth(p, device);
+        }
+        LEAVE("qla2100_select_queue_depth");
+}
+
+/**************************************************************************
+* ** Driver Support Routines **
+*
+* qla2100_enable_intrs
+* qla2100_disable_intrs
+**************************************************************************/
+static inline void qla2100_enable_intrs(scsi_qla_host_t *ha) {
+        device_reg_t *reg;
+
+        reg = ha->iobase;
+        ha->interrupts_on = 1;
+        /* enable risc and host interrupts */
+        WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT+ ISP_EN_RISC));
+}
+
+static inline void qla2100_disable_intrs(scsi_qla_host_t *ha) {
+        device_reg_t *reg;
+
+        reg = ha->iobase;
+        ha->interrupts_on = 0;
+        /* disable risc and host interrupts */
+        WRT_REG_WORD(&reg->ictrl, 0);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
+/**************************************************************************
+*  mdelay
+*     Delay in milliseconds
+*
+**************************************************************************/
+STATIC inline void
+mdelay(int milliseconds) {
+        int i;
+
+        for( i=0; i<milliseconds; i++ ) {
+            SYS_DELAY(HZ);
+        }
+}
+#endif
+
+/**************************************************************************
+* qla2100_done
+*      Process completed commands.
+*
+* Input:
+*      ha           = adapter block pointer.
+*      done_q_first = done queue first pointer.
+*      done_q_last  = done queue last pointer.
+*
+* Returns:
+*     None
+**************************************************************************/
+STATIC void
+qla2100_done(scsi_qla_host_t *ha, srb_t **done_q_first, srb_t **done_q_last) {
+        srb_t           *sp;
+        scsi_lu_t       *q;
+        uint32_t        b, t, l;
+        Scsi_Cmnd  *cmd;
+        unsigned long cpu_flags = 0; 
+
+        /* ENTER("qla2100_done"); */
+        COMTRACE('D')
+
+        while( *done_q_first ) {
+            /* remove command from done list */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_LOCK
+#endif
+            QLA2100_TIMER_LOCK(ha);
+            sp = *done_q_first;
+            if( !(*done_q_first = sp->s_next) )
+                *done_q_last = NULL;
+            else
+                (*done_q_first)->s_prev = NULL;
+            qla2100_stats.done_q_cnt--;
+            DEBUG(sp->state = 5;)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_UNLOCK
+#endif
+            QLA2100_TIMER_UNLOCK(ha);
+            cmd = sp->cmd;
+            b = SCSI_BUS_32(cmd);
+            t = SCSI_TCN_32(cmd);
+            l = SCSI_LUN_32(cmd);
+            q = GET_LU_Q(ha, b, t, l);
+
+            /* Decrement outstanding commands on device. */
+            if( q->q_outcnt )
+                q->q_outcnt--;
+            if( q->q_outcnt < ha->hiwat ) {
+                q->q_flag &= ~QLA2100_QBUSY;
+            }
+
+            q->io_cnt++;
+
+            switch( (CMD_RESULT(cmd)>>16) ) {
+                case DID_RESET:
+                    q->q_flag &= ~QLA2100_QRESET;
+                    /* Issue marker command. */
+                    qla2100_marker(ha, b, t, 0, MK_SYNC_ID);
+                    break;
+                case DID_ABORT:
+                    sp->flags &= ~SRB_ABORT_PENDING;
+                    sp->flags |= SRB_ABORTED;
+                    if( sp->flags & SRB_TIMEOUT )
+                        CMD_RESULT(sp->cmd)= DID_TIME_OUT << 16;
+                    break;
+                default:
+                    break;
+            }
+
+        /* 4.10   64 and 32 bit */
+        /* Release memory used for this I/O */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+        if (cmd->use_sg) {
+            /* DEBUG(sprintf(debug_buff,
+            "S/G unmap_sg cmd=%x\n\r",cmd);)
+            DEBUG(qla2100_print(debug_buff)); */
+            pci_unmap_sg(ha->pdev, cmd->request_buffer,
+                         cmd->use_sg,
+                         scsi_to_pci_dma_dir(cmd->sc_data_direction));
+        }
+        else if (cmd->request_bufflen) {
+                 /* DEBUG(sprintf(debug_buff,
+                 "No S/G unmap_single cmd=%x saved_dma_handle=%lx\n\r",
+                  cmd,sp->saved_dma_handle);)
+                  DEBUG(qla2100_print(debug_buff);) */
+                  pci_unmap_single(ha->pdev,sp->saved_dma_handle,
+                                  cmd->request_bufflen,
+                                  scsi_to_pci_dma_dir(cmd->sc_data_direction));
+       }
+#endif 
+            /* Call the mid-level driver interrupt handler */
+            /* DEBUG(sprintf(debug_buff," [%d] ",cmd->pid);)
+               DEBUG(qla2100_print(debug_buff);) */
+
+            qla2100_callback(ha,sp,TRUE);
+            qla2100_next(ha, q);
+        }
+
+
+        COMTRACE('d')
+        /* LEAVE("qla2100_done"); */
+}
+
+/**************************************************************************
+* qla2100_return_status
+* 	Translates a ISP error to a Linux SCSI error
+**************************************************************************/
+STATIC int qla2100_return_status(scsi_qla_host_t *ha, 
+    sts_entry_t *sts, Scsi_Cmnd *cp) {
+        int host_status = DID_ERROR;
+        int scsi_status;
+        int comp_status;
+        unsigned resid;
+        srb_t  *sp;
+        uint32_t        t;
+        uint8_t  *strp;
+        scsi_lu_t *up;
+
+#if DEBUG_QLA2100_INTR
+        STATIC char *reason[] = {
+            "DID_OK",
+            "DID_NO_CONNECT",
+            "DID_BUS_BUSY",
+            "DID_TIME_OUT",
+            "DID_BAD_TARGET",
+            "DID_ABORT",
+            "DID_PARITY",
+            "DID_ERROR",
+            "DID_RESET",
+            "DID_BAD_INTR"
+        };
+#endif /* DEBUG_QLA2100_INTR */
+
+        ENTER("qla2100_return_status");
+
+#if DEBUG_QLA2100_INTR
+        /*
+        DEBUG(printk("qla2100: compl status = 0x%04x\n", sts->comp_status));
+        */
+#endif
+        scsi_status = sts->scsi_status;
+        comp_status = sts->comp_status;
+        sp = (srb_t *) CMD_SP(cp);
+
+        if( (scsi_status & SS_RESIDUAL_OVER) )
+            comp_status = CS_DATA_OVERRUN;
+        else if( (scsi_status & SS_RESPONSE_INFO_LEN_VALID) &&
+        sts->rsp_info[3] == (uint8_t) 0 )
+            comp_status = CS_COMPLETE;
+
+	/* If scanning and missing lun then let the scsi layer skip it */
+	/* 4.24   dg 01/18/2001 */
+        if( cp->cmnd[0] == 0x12 && 
+              	cp->lun == 0 ) { /* inquiry */
+		strp = (uint8_t *)cp->request_buffer;
+        	up = (scsi_lu_t *) GET_LU_Q(ha, 0, cp->target, cp->lun);
+		if( *strp == 0x7f && up->io_cnt < 5) {
+			/* Make lun unassigned and wrong type */
+			*strp = 0x23;
+		}
+	   }
+
+        switch( comp_status ) {
+            case CS_COMPLETE:
+                host_status = DID_OK;
+		        /* v2.19.5b2 Reset port down retry on success. */
+			sp->port_down_retry_count = ha->port_down_retry_count;
+                break;
+            case CS_PORT_UNAVAILABLE:
+                /* release target data structure */
+                host_status = DID_NO_CONNECT;
+                DEBUG(sprintf(debug_buff,"scsi: Unavail port detected 0x%x-0x%x.\n",
+                sts->comp_status, sts->scsi_status); )
+                DEBUG(qla2100_print(debug_buff);)
+                break;
+            case CS_PORT_LOGGED_OUT:
+            case CS_PORT_CONFIG_CHG:
+            case CS_PORT_BUSY:
+            case CS_INCOMPLETE:
+                host_status = DID_NO_CONNECT;
+                DEBUG(sprintf(debug_buff,"scsi: Port Error detected 0x%x-0x%x.\n",
+                sts->comp_status, sts->scsi_status); )
+                DEBUG(qla2100_print(debug_buff);)
+                break;
+            case CS_RESET:
+                host_status = DID_RESET;
+                break;
+            case CS_ABORTED:
+                /* v2.19.12 - DID_ABORT does not retry the request */
+				/* if we aborted this request then abort otherwise it must be a reset */
+                   if ( (sp->flags & SRB_ABORT_PENDING) )
+                host_status = DID_ABORT;
+		   else
+                	host_status = DID_RESET;
+                break;
+            case CS_TIMEOUT:
+                  host_status = DID_ERROR;
+                  /* v2.19.8 if timeout then check to see if logout occurred*/
+                  t = SCSI_TCN_32(cp);
+		  if ( (ha->fc_db[t].flag & DEV_PUBLIC)  &&
+                       (sts->status_flags & IOCBSTAT_SF_LOGO) ) {
+				ha->fc_db[t].flag |= DEV_RELOGIN;
+                    DEBUG(printk("scsi: Timeout occurred with Logo, status flag (%x) with public device loop id (%x), attempt new recovery\n",
+                    sts->status_flags, ha->fc_db[t].loop_id);)
+					/* Suspend port */
+                    PORT_DOWN(ha,t) = ha->port_down_retry_count;
+                    ha->device_flags |= RELOGIN_NEEDED;
+                }
+                break;
+            case CS_DATA_UNDERRUN:
+                resid = sts->residual_length;
+                /* if RISC reports underrun and target does not report it
+                * then we must have a lost frame, so tell upper layer
+                * to retry it by reporting an error.
+                */
+                if( !(sts->scsi_status & SS_RESIDUAL_UNDER) ) {
+                    resid = (unsigned)(CMD_XFRLEN(cp));
+                }
+
+                if( (unsigned)(CMD_XFRLEN(cp) - resid) < cp->underflow ) {
+                        host_status = DID_ERROR;
+                        DEBUG3(sprintf(debug_buff,"scsi: Underflow detected - retrying command.\n");)
+                        DEBUG3(qla2100_print(debug_buff);)
+                } else {
+	            /* v2.19.5b2 Reset port down retry on success. */
+	            sp->port_down_retry_count = ha->port_down_retry_count;
+                    host_status = DID_OK;
+                }
+                break;
+
+            default:
+                DEBUG3(printk("scsi: Error detected 0x%x-0x%x.\n",
+                sts->comp_status, sts->scsi_status);)
+                host_status = DID_ERROR;
+                break;
+        }
+
+#if DEBUG_QLA2100_INTR
+        sprintf(debug_buff, "qla2100 ISP status: host status (%s) scsi status %x\n\r", reason[host_status], scsi_status);
+        DEBUG(qla2100_print(debug_buff);)
+#endif
+
+        LEAVE("qla2100_return_status");
+
+        return ((scsi_status & STATUS_MASK) | (host_status << 16) );
+}
+
+/*
+* qla2100_done_q_put
+*      Place SRB command on done queue.
+*
+* Input:
+*      ha           = host pointer
+*      sp           = srb pointer.
+*      done_q_first = done queue first pointer.
+*      done_q_last  = done queue last pointer.
+*/
+STATIC void
+qla2100_done_q_put(scsi_qla_host_t *ha, srb_t *sp, srb_t **done_q_first, srb_t **done_q_last) {
+    
+        unsigned long cpu_flags = 0; 
+
+#ifdef QL_DEBUG_LEVEL_3
+        ENTER("qla2100_put_done_q");
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_LOCK
+#else
+            QLA2100_TIMER_LOCK(ha);
+#endif
+        /* Place block on done queue */
+        sp->s_next = NULL;
+        sp->s_prev = *done_q_last;
+        if( !*done_q_first )
+            *done_q_first = sp;
+        else
+            (*done_q_last)->s_next = sp;
+        *done_q_last = sp;
+
+        qla2100_stats.done_q_cnt++;
+        DEBUG(sp->state = 3;)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_LOCK
+#else
+            QLA2100_TIMER_UNLOCK(ha);
+#endif
+
+#ifdef QL_DEBUG_LEVEL_3
+        LEAVE("qla2100_put_done_q");
+#endif
+}
+
+
+/**************************************************************************
+*   qla2100_timer
+*
+* Description:
+*   One second timer 
+*
+* Context: Interrupt
+**************************************************************************/
+STATIC void
+qla2100_timer(scsi_qla_host_t *ha) {
+
+        srb_t *sp, *sp_next;
+        int  stop_timer, kick_off = 0;
+        int  cnt;
+	int t;
+        /* unsigned long cpu_flags = 0; */
+
+
+        /* ENTER("qla2100_timer"); */
+
+        /* v2.19.02 spin_lock_irqsave(&io_request_lock, cpu_flags); */
+
+        stop_timer = 0;
+
+        for( t = 0; t < ha->max_targets; t++ ) {
+            if( TGT_Q(ha, 0, t)  == NULL )
+                   continue;
+            if( TGT_Q(ha, 0, t)->down_timer > 0 )
+            	TGT_Q(ha, 0, t)->down_timer--;
+	}
+
+        /* Port Down Handler. */
+        if( ha->queue_restart_timer > 0 ) {
+            ha->queue_restart_timer--;
+#ifdef TRACECODE
+            sprintf(debug_buff,"timer: Port down time in secs %d\n",ha->queue_restart_timer);
+            qla2100_print(debug_buff);
+#endif
+            /*
+             * When a port goes DOWN, we suspend the queue and wait 1 second
+             * (one timer tick) before trying to kick off the commands again.
+             * We will do this for "port_down_retry_count" times per
+             * command before giving up on the command altogether.
+             */
+             if( !ha->queue_restart_timer ) {
+                 ha->flags.port_restart_needed = TRUE;
+                 DEBUG(qla2100_print("qla2100_timer: Port Down complete - restarting commands in the queues\n");)
+                 stop_timer++;
+             }
+         }
+            /* Loop down handler. */
+            if( ha->loop_down_timer > 0 &&
+            !ha->flags.abort_isp_active &&
+            ha->flags.online ) {
+                if( ha->loop_down_timer == LOOP_DOWN_TIME ) {
+                    DEBUG(printk("qla2100_timer: Loop Down time expired - aborting the queues before time expire\n");)
+#ifdef TRACECODE
+                    qla2100_print("qla2100_timer: Loop Down - aborting the queues before time expire\n");
+#endif
+#if 1
+                    ha->flags.abort_queue_needed = TRUE;
+#else
+                    qla2100_abort_queues(ha, TRUE);
+#endif
+                }
+
+                ha->loop_down_timer--;
+#ifdef TRACECODE
+                sprintf(debug_buff,"qla2100_timer: Loop Down - seconds remainning %d\n",ha->loop_down_timer);
+                qla2100_print(debug_buff);
+#endif
+                /* if the loop has been down for 4 minutes on QLA2100,
+                   reinit adapter */
+                if( !ha->loop_down_timer ) {
+#ifdef TRACECODE
+                    qla2100_print("qla2100_timer: Loop down for 4 mins \n");
+#endif
+                    DEBUG(printk("qla2100_timer: Loop down exceed 4 mins -restarting queues and abort ISP.\n");)
+                    ha->flags.restart_queues_needed = TRUE;
+                    if ( (ha->device_id  == QLA2100_DEVICE_ID) &&
+                          (qla2100_reinit == 1 ))
+                        ha->flags.isp_abort_needed = TRUE;
+                    stop_timer++;
+                }
+            }
+
+            /*
+            * Retry Handler -- This handler will recycle queued requests until the
+            * temporary loop down condition terminates.
+            */
+            if( !ha->flags.abort_isp_active ) {
+#ifdef TRACECODE
+                if( ha->retry_q_first )
+                    qla2100_print("qla2100_timer: Scanning for timed out commands\n");
+#endif
+                for( cnt=0, sp = ha->retry_q_first; (sp); sp =  sp_next ) {
+                    if( sp->wdg_time )
+                        sp->wdg_time--;
+                    sp_next = sp->s_next;
+                    if( sp->wdg_time ==  0 ) {
+                        kick_off++;
+                        DEBUG3(sprintf(debug_buff,"timer: CMD timeout %p,  pid %d\n",sp, sp->cmd->pid);)
+                        DEBUG3(qla2100_print(debug_buff);)
+                        cnt++;
+                        qla2100_timeout_remove(ha, sp);
+                        CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+                        CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+                        qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+                    }
+                }
+
+                if( cnt > 0 ) {
+                    DEBUG2(sprintf(debug_buff,"timer: found %d requests\n",cnt);)
+                    DEBUG2(qla2100_print(debug_buff);)
+                }
+            }
+
+            if( ha->done_q_first )
+                ha->flags.done_requests_needed = TRUE;
+
+            if( ha->dpc_flags & ISP_RESET_NEEDED) {
+               ha->dpc_flags &= ~ISP_RESET_NEEDED;
+               ha->flags.isp_abort_needed = TRUE;
+	    }
+
+
+#if QLA2100_LIPTEST
+            if( (ha->forceLip++) == (60*3) && qla2100_lip) {
+                /* qla2100_loop_reset(ha); */
+                qla2100_abort_isp(ha);
+                ha->forceLip = 0;
+            }
+#endif
+            /* v2.19.02 spin_unlock_irqrestore(&io_request_lock, cpu_flags); */
+
+            /* Schedule the DPC routine if needed */
+            if( ( ha->flags.isp_abort_needed ||
+            (!ha->flags.loop_resync_active && ha->flags.loop_resync_needed) ||
+            ha->flags.restart_queues_needed ||
+            ha->flags.port_restart_needed ||
+            ha->flags.done_requests_needed ||
+            (ha->device_flags & RELOGIN_NEEDED) ||
+		    (ha->dpc_flags & COMMAND_WAIT_NEEDED) ||
+            (ha->device_flags & LOGIN_RETRY_NEEDED) ||
+            kick_off > 0  ||
+            ha->flags.abort_queue_needed ) &&
+            ha->dpc_wait && !ha->dpc_active ) {  /* v2.19.4 */
+                up(ha->dpc_wait);
+            }
+
+            /* IOCTL SCSI Pass Thru Handler. */
+            if (ha->IoctlPassThru_InProgress)  {
+               if (ha->ioctl_timer) ha->ioctl_timer--;
+            }
+
+            /* IOCTL FCCT Pass Thru Handler. */
+            if (ha->IoctlPassFCCT_InProgress)  {
+               if (ha->ioctl_timer) ha->ioctl_timer--;
+            }
+
+            /* ha->flags.watchdog_enabled = FALSE; */
+            RESTART_TIMER(qla2100_timer,ha,WATCH_INTERVAL);
+
+            /* LEAVE("qla2100_timer");  */
+}
+
+/*
+* qla2100_timeout_insert
+*      Function used to insert a command block onto the
+*      watchdog timer queue.
+*
+*      Note: Must insure that sc_time is not zero
+*            before calling qla2100_timeout_insert.
+*
+* Input:
+*      ha = adapter block pointer.
+*      sp = srb pointer.
+*/
+STATIC void
+qla2100_timeout_insert(scsi_qla_host_t *ha, srb_t *sp) {
+            unsigned long cpu_flags = 0;
+            uint8_t timeoutcnt;
+
+#ifdef QL_DEBUG_LEVEL_3
+            /* ENTER("qla2100_timeout_insert"); */
+#endif
+
+            /* Compute number of time intervals */
+            timeoutcnt = (uint8_t) (CMD_TIMEOUT(sp->cmd)/(WATCH_INTERVAL * HZ));
+            if( timeoutcnt >= 3 )  /* 3 or more */
+                /* sp->wdg_time = timeoutcnt - 3;  */
+                sp->wdg_time = 3;
+            else
+                sp->wdg_time = 1;
+
+            DEBUG3(sprintf(debug_buff,"Watchdog (insert) - pid=%d, tmo=%d \n",sp->cmd->pid,sp->wdg_time);)
+            DEBUG3(qla2100_print(debug_buff);)
+
+            /* Acquire watchdoq queue specific lock */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_LOCK
+#else
+            QLA2100_TIMER_LOCK(ha);
+#endif
+            /* Add command to queue */
+            if (ha->retry_q_first == NULL) {
+                ha->retry_q_first = sp;
+                ha->retry_q_last = sp;
+            } else {
+                ha->retry_q_last->s_next = sp;
+                ha->retry_q_last = sp;
+            }
+            sp->s_next = NULL;
+            qla2100_stats.retry_q_cnt++;
+            sp->state = 0xd0;
+
+            sp->flags |= SRB_WATCHDOG;
+            ha->flags.watchdog_enabled = TRUE;
+
+            /* Release watchdog queue specific lock */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_UNLOCK
+#else
+            QLA2100_TIMER_UNLOCK(ha);
+#endif
+
+#ifdef QL_DEBUG_LEVEL_3
+            /*  LEAVE("qla2100_timeout_insert"); */
+#endif
+}
+
+/*
+* qla2100_timeout_remove
+*      Function used to remove a command block from the
+*      watchdog timer queue.
+*
+*      Note: Must insure that command is on watchdog
+*            list before calling qla2100_timeout_remove.
+*            if (sp->flags & SRB_WATCHDOG)
+*
+* Input:
+*      ha = adapter block pointer.
+*      sp = srb pointer.
+*/
+STATIC void
+qla2100_timeout_remove(scsi_qla_host_t *ha, srb_t *sp) {
+            unsigned long cpu_flags = 0;
+            srb_t *nextsp;
+
+#ifdef QL_DEBUG_LEVEL_3
+            /* ENTER("qla2100_timeout_remove"); */
+#endif
+
+            DEBUG3(sprintf(debug_buff,"Watchdog (remove) pid=%d time%d\n",sp->cmd->pid,sp->wdg_time);)
+            DEBUG3(qla2100_print(debug_buff);)
+
+            /* Acquire watchdoq queue specific lock */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_LOCK
+#else
+            QLA2100_TIMER_LOCK(ha);
+#endif
+            /* Remove command block from watchdog queue. */
+            if (ha->retry_q_first != NULL) {
+                if (ha->retry_q_first == sp) {
+                    /* Remove from top of queue */
+                    ha->retry_q_first = sp->s_next;
+                    if (ha->retry_q_first == NULL) {
+
+                        ha->retry_q_last = NULL;
+                        ha->flags.watchdog_enabled = FALSE;
+                    }
+                } else {
+                    /* Remove from middle of queue or bottom of queue */
+                    for (nextsp = ha->retry_q_first; nextsp->s_next != NULL;
+                    nextsp = nextsp->s_next) {
+                        if (nextsp->s_next == sp) {
+                            nextsp->s_next = sp->s_next;
+                            if (nextsp->s_next == NULL)
+                                ha->retry_q_last = nextsp;
+                            break;
+                        }
+                    }
+                }
+                sp->flags &= ~SRB_WATCHDOG;
+                qla2100_stats.retry_q_cnt--;
+            }
+
+            /* Release watchdog queue specific lock */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_UNLOCK
+#else
+            QLA2100_TIMER_UNLOCK(ha);
+#endif
+
+#ifdef QL_DEBUG_LEVEL_3
+            /* LEAVE("qla2100_timeout_remove"); */
+#endif
+}
+
+/*
+* qla2100_next
+*      Retrieve and process next job in the queue.
+*
+* Input:
+*      ha = adapter block pointer.
+*      q  = SCSI LU pointer.
+*      SCSI_LU_Q lock must be already obtained and no other locks.
+*
+* Output:
+*      Releases SCSI_LU_Q upon exit.
+*/
+STATIC void
+qla2100_next(scsi_qla_host_t *ha, scsi_lu_t *q) {
+            srb_t    *sp;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            unsigned long cpu_flags = 0;
+#endif
+            uint8_t  status;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_next"); 
+#endif
+
+            DRIVER_LOCK
+            COMTRACE('N')
+            while( ((sp = q->q_first) != NULL) &&   /* we have a pending cmds */
+            !(q->q_flag & QLA2100_QBUSY) &&     /* device can accept more cmds */
+            !((q->q_flag & QLA2100_QSUSP) &&    /* device queue not suspended */
+            !ha->flags.abort_isp_active &&      /* adapter abort active */
+            !ha->loop_down_timer) )             /* down timer not active */
+            {
+                /* Remove srb from SCSI LU queue. */
+                qla2100_removeq(q, sp);
+                sp->state = 0x32;
+                /* Set busy flag if reached high water mark. */
+                q->q_outcnt++;
+                if( q->q_outcnt >= ha->hiwat ) {
+                    q->q_flag |= QLA2100_QBUSY;
+                }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+                if( ha->flags.enable_64bit_addressing )
+                    status = qla2100_64bit_start_scsi(ha, sp);
+                else
+#endif
+                    status = qla2100_32bit_start_scsi(ha, sp);
+
+                if( status ) {
+                    qla2100_putq_t(q, sp);
+
+                    if( q->q_outcnt )
+                        q->q_outcnt--;
+                    if( q->q_outcnt < ha->hiwat )
+                       q->q_flag &= ~QLA2100_QBUSY;
+                      break;
+                }
+            }
+
+            COMTRACE('n')
+            DRIVER_UNLOCK
+            /* Release SCSI LU queue specific lock */
+
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_next");
+#endif
+}
+#if 0
+/*******************************************************
+v4.10
+* This function has been de-implemented 
+* All DMAable memory is allocated on the spot
+* according to what kernel version is in effect.
+********************************************************  
+* qla2100_alloc_phys
+*      Function used to allocate physical memory
+*      and zero it.
+*
+* Input:
+*      size     = size in bytes.
+*      flag     = sleep flag.
+*      phy_addr = physical address pointer.
+*
+* Returns:
+*      not NULL = success
+*/
+STATIC void *
+qla2100_alloc_phys(int siz, u_long *phy_addr) {
+            void        *mem = NULL;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_alloc_phys");
+#endif
+            mem = KMALLOC(siz);
+            if( mem != NULL ) {
+                *phy_addr = VIRT_TO_BUS(mem);
+                BZERO((caddr_t)mem, siz);
+                DEBUG5(sprintf(debug_buff,"qla2100: get phys mem =0x%lx\n\r",(long)*phy_addr));
+                DEBUG5(qla2100_print(debug_buff);)
+            }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( mem == NULL )
+                qla2100_print("qla2100_alloc_phys: **** FAILED ****\n\r");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            else
+                LEAVE("qla2100_alloc_phys");
+#endif
+            return(mem);
+}
+#endif
+
+/*
+* qla2100_putq_t
+*      Add the standard SCB job to the top of standard SCB commands.
+*
+* Input:
+*      q  = SCSI LU pointer.
+*      sp = srb pointer.
+*      SCSI_LU_Q lock must be already obtained.
+*/
+STATIC void
+qla2100_putq_t(scsi_lu_t *q, srb_t *sp) {
+            srb_t *srb_p;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            unsigned long cpu_flags = 0;
+#endif
+
+#ifdef QL_DEBUG_LEVEL_3
+            /* ENTER("qla2100_putq_t"); */
+#endif
+            DRIVER_LOCK
+            DEBUG5(sprintf(debug_buff,"Adding to queue 0x%x<-(0x%x)\n\r",q,sp));
+            DEBUG5(qla2100_print(debug_buff));
+            sp->s_next = NULL;
+            q->q_incnt++;
+            sp->state = 2;
+            /* v2.19.6 */
+            if( !q->q_first || !q->q_last)  /* If queue empty */
+            {
+                sp->s_prev = NULL;
+                q->q_first = sp;
+                q->q_last = sp;
+            } else {
+                srb_p = q->q_first;
+                while( srb_p )
+                    srb_p = srb_p->s_next;
+
+                if( srb_p ) {
+                    sp->s_prev = srb_p->s_prev;
+                    if( srb_p->s_prev )
+                        srb_p->s_prev->s_next = sp;
+                    else
+                        q->q_first = sp;
+                    srb_p->s_prev = sp;
+                    sp->s_next = srb_p;
+                } else {
+                    sp->s_prev = q->q_last;
+                    q->q_last->s_next = sp;
+                    q->q_last = sp;
+                }
+            }
+
+            DRIVER_UNLOCK
+#ifdef QL_DEBUG_LEVEL_3
+            /* LEAVE("qla2100_putq_t"); */
+#endif
+}
+
+/*
+* qla2100_removeq
+*      Function used to remove a command block from the
+*      LU queue.
+*
+* Input:
+*      q  = SCSI LU pointer.
+*      sp = srb pointer.
+*      SCSI_LU_Q lock must be already obtained.
+*/
+STATIC void
+qla2100_removeq(scsi_lu_t *q, srb_t *sp) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            unsigned long cpu_flags = 0;
+#endif
+            DEBUG5(sprintf(debug_buff,"Removing from device_q (0x%x)->(0x%x)\n\r",q,sp));
+            DEBUG5(qla2100_print(debug_buff));
+            DRIVER_LOCK
+            if( sp->s_prev ) {
+                if( (sp->s_prev->s_next = sp->s_next) != NULL )
+                    sp->s_next->s_prev = sp->s_prev;
+                else
+                    q->q_last = sp->s_prev;
+            } else if( !(q->q_first = sp->s_next) )
+                q->q_last = NULL;
+            else
+                q->q_first->s_prev = NULL;
+            q->q_incnt--;
+            DRIVER_UNLOCK
+}
+
+/*
+* qla2100_callback
+*      Returns the completed SCSI command to LINUX.
+*
+* Returns:
+*      None
+*/
+static inline void qla2100_callback(scsi_qla_host_t *ha, srb_t *sp, uint8_t dec) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            unsigned long cpu_flags = 0;
+#endif
+
+            CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+            sp->flags &= ~SRB_SENT;
+            
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_LOCK
+#endif
+#if 0
+            if( dec )
+                ha->actthreads--;
+#endif
+
+	/* v2.19.14 
+  	 * Perform internal retries, if needed.
+	 */
+          switch( (CMD_RESULT(sp->cmd)>>16) ) {
+                case DID_ERROR:
+			if( sp->retry_count > 0 ) {
+				sp->retry_count--;
+            			DEBUG3(printk("qla2100: RETRY - os retry %d, drv retry %d, port retry %d\n\r",sp->cmd->retries,sp->retry_count,sp->port_down_retry_count));
+                        	CMD_RESULT(sp->cmd) = (int) DID_BUS_BUSY << 16;
+			} else {
+            	  		sp->retry_count = ha->retry_count;
+				/* all resetted commands must return with RESET */
+				if(sp->cmd->flags & IS_RESETTING ) {
+                        		CMD_RESULT(sp->cmd) = (int) DID_RESET << 16;
+            				DEBUG3(printk("qla2100: RESET cmd %p\n",sp->cmd));
+				}
+            			DEBUG3(printk("qla2100: OSerr = %p\n\r",sp->cmd));
+			}
+                    break;
+                default:
+                    break;
+            }
+
+            /* Call the mid-level driver interrupt handler */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            sti();
+            (*(sp->cmd)->scsi_done)(sp->cmd);
+            cli();
+#else
+            (*(sp->cmd)->scsi_done)(sp->cmd);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+            DRIVER_UNLOCK
+#endif
+}
+
+/*
+* qla2100_mem_alloc
+*      Allocates adapter memory.
+*
+* Returns:
+*      0  = success.
+*      1  = failure.
+*/
+STATIC uint8_t
+qla2100_mem_alloc(scsi_qla_host_t *ha) {
+
+            uint8_t   status = 1;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_mem_alloc");
+#endif
+
+            /* 4.10 */
+            /* get consistent memory allocated for request/response rings */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+            ha->request_ring  = &ha->req[0];
+            ha->request_dma   = VIRT_TO_BUS(&ha->req[0]);
+            ha->response_ring = &ha->res[0];
+            ha->response_dma  = VIRT_TO_BUS(&ha->res[0]);
+#ifdef FC_IP_SUPPORT
+            ha->pIpBufferQueue          = &ha->asIpBuffers[0];
+            ha->ppIpBufferQueueLow      = VIRT_TO_BUS_LOW(&ha->asIpBuffers[0]);
+            ha->ppIpBufferQueueHigh     = VIRT_TO_BUS_HIGH(&ha->asIpBuffers[0]);
+#endif /* FC_IP_SUPPORT */
+#else  /* KERNEL >= 2.3.18 */ 
+            ha->request_ring   = pci_alloc_consistent(ha->pdev,
+                                 ((REQUEST_ENTRY_CNT+1)*(sizeof(request_t))),
+                                 &ha->request_dma);
+            ha->response_ring  = pci_alloc_consistent(ha->pdev,
+                                 ((RESPONSE_ENTRY_CNT+1)*(sizeof(response_t))),
+                                 &ha->response_dma);
+#ifdef FC_IP_SUPPORT 
+            /* not ported yet to new pci_alloc_consistent */
+            ha->pIpBufferQueue          = &ha->asIpBuffers[0];
+            ha->ppIpBufferQueueLow      = VIRT_TO_BUS_LOW(&ha->asIpBuffers[0]);
+            ha->ppIpBufferQueueHigh     = VIRT_TO_BUS_HIGH(&ha->asIpBuffers[0]);
+#endif 
+#endif
+            /* 4.10 */
+            /* get consistent memory allocated for init control block */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+            ha->init_cb = KMALLOC(sizeof(init_cb_t));
+            if( ha->init_cb != NULL ) {
+                ha->init_cb_dma = VIRT_TO_BUS(ha->init_cb);
+                BZERO((caddr_t)ha->init_cb, sizeof(init_cb_t));
+            }
+#else
+            ha->init_cb  = pci_alloc_consistent(ha->pdev,
+                                                sizeof(init_cb_t),
+                                                &ha->init_cb_dma);
+            BZERO((caddr_t)ha->init_cb, sizeof(init_cb_t));
+#endif
+            if( ha->init_cb ) status = 0;
+
+            if( status ) 
+                printk(KERN_WARNING "qla2100_mem_alloc: **** FAILED ****\n");
+
+#ifdef QL_DEBUG_LEVEL_3
+            else
+                LEAVE("qla2100_mem_alloc");
+#endif
+            return(status);
+}
+
+/*
+* qla2100_mem_free
+*      Frees all adapter allocated memory.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_mem_free(scsi_qla_host_t *ha) {
+	tgt_t    *tgt;
+	uint32_t b, t;
+
+#ifdef QL_DEBUG_LEVEL_3
+	ENTER("qla2100_mem_free");
+#endif
+	if( ha ) {
+		/* Free the target queues */
+		b = 0;
+		for( t = 0; t < MAX_FIBRE_DEVICES; t++ ) {
+			tgt = TGT_Q(ha, b, t);
+			if( tgt )
+				qla2100_tgt_dealloc(ha, tgt);
+		}
+
+		/* Free host database. */
+		if (ha->phost_db != NULL) {
+			KMFREE(ha->phost_db, sizeof(fcdev_t) * MAX_HOST_COUNT);
+		}
+
+		/* 4.10 */
+		/* free consistent memory allocated for request and response rings */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+		pci_free_consistent(ha->pdev,
+		    ((REQUEST_ENTRY_CNT+1)*(sizeof(request_t))),
+		    ha->request_ring, ha->request_dma);
+
+		pci_free_consistent(ha->pdev,
+		    ((RESPONSE_ENTRY_CNT+1)*(sizeof(response_t))),
+		    ha->response_ring, ha->response_dma); 
+#endif 
+		/* free memory allocated for ioctl operations */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+		KMFREE(ha->ioctl_mem, PAGE_SIZE);
+#else
+		pci_free_consistent(ha->pdev, PAGE_SIZE,
+		    ha->ioctl_mem, ha->ioctl_mem_phys);
+#endif
+		/* free memory allocated for init_cb */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+		KMFREE(ha->init_cb, sizeof(init_cb_t));
+#else
+		pci_free_consistent(ha->pdev, sizeof(init_cb_t),
+		    ha->init_cb, ha->init_cb_dma);
+#endif
+	}
+
+#ifdef QL_DEBUG_LEVEL_3
+	LEAVE("qla2100_mem_free");
+#endif
+}
+
+/*
+* qla2100_tgt_alloc
+*      Allocates a target queue structure.
+*
+* Input:
+*      ha  = adapter block pointer.
+*
+* Returns
+*      target queue structure = success:
+*      NULL = otherwise
+*/
+static inline tgt_t *
+qla2100_tgt_alloc(scsi_qla_host_t *ha) {
+            tgt_t    *tgt;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_tgt_alloc");
+#endif
+
+            tgt = (tgt_t *)KMALLOC(sizeof(tgt_t));   /* Could Sleep here */
+            if( tgt != NULL ) {
+                BZERO(tgt,sizeof(tgt_t));
+                DEBUG(sprintf(debug_buff,"Alloc Target @ %08x \n",tgt);)
+                DEBUG(qla2100_print(debug_buff);)
+            }
+
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_tgt_alloc");
+#endif
+            return(tgt);
+}
+
+/*
+* qla2100_lun_alloc
+*      Allocates a logical device queue structure and lock
+*
+* Returns:
+*      SCSI LU structure pointer
+*/
+STATIC inline scsi_lu_t *
+qla2100_lun_alloc(void) {
+            scsi_lu_t *q;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_lun_alloc");
+#endif
+
+            q = (scsi_lu_t *)KMALLOC(sizeof(scsi_lu_t));  /* Sleep */
+            BZERO(q,sizeof(struct scsi_lu));
+            DEBUG(sprintf(debug_buff,"Alloc Lun @ %08x \n",q);)
+            DEBUG(qla2100_print(debug_buff);)
+
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_lun_alloc");
+#endif
+            return(q);
+}
+
+/*
+* qla2100_tgt_dealloc
+*      Deallocates a target and all logical device queue structures.
+*
+* Input:
+*      ha  = adapter block pointer.
+*      tgt = Target queue structure pointer
+*/
+static inline void
+qla2100_tgt_dealloc(scsi_qla_host_t *ha, tgt_t *tgt) {
+            uint32_t  l;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_tgt_dealloc");
+#endif
+
+            if( tgt != NULL ) {
+                /* Insure all LUN memory is released. */
+                for( l = 0; l <  ha->max_luns; l++ ) {
+                    if( tgt->luns[l] )
+                        qla2100_lun_dealloc(tgt->luns[l]);
+                }
+                KMFREE(tgt, sizeof(tgt_t));
+            }
+
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_tgt_dealloc");
+#endif
+}
+
+/*
+* qla2100_lun_dealloc
+*      Deallocates a logical unit queue structure.
+*
+* Input:
+*      q = SCSI LU structure pointer
+*/
+static inline void
+qla2100_lun_dealloc(scsi_lu_t *q) {
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_lun_dealloc");
+#endif
+            if( q != NULL ) {
+                DEBUG(sprintf(debug_buff,"Dealloc Lun @ %08x -- deleted\n",q);)
+                DEBUG(qla2100_print(debug_buff);)
+                KMFREE(q, sizeof(scsi_lu_t));
+            }
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_lun_dealloc");
+#endif
+
+}
+
+/*
+*  qla2100_abort_queue_single
+*      Abort all commands on a device queues.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void qla2100_abort_queue_single(scsi_qla_host_t *ha,uint32_t b,uint32_t t,uint32_t l,uint32_t stat) {
+            scsi_lu_t *q;
+            srb_t     *sp;
+
+            ENTER("qla2100_abort_queue_single");
+            /* dg - 08/23/99
+            * We don't want to try and abort queues that don't exists
+            * (i.e. the device is not configure on the loop )
+            */
+            if( ha->loop_down_timer > 0 ) {
+                return;
+            }
+            DEBUG5(sprintf(debug_buff,"Abort queue single %2d:%2d:%2d:%2d\n",
+            ha->host_no,b,t,l);)
+            DEBUG5(qla2100_print(debug_buff);)
+            q = (scsi_lu_t * )GET_LU_Q(ha, b, t, l);
+            while( q != NULL && (sp = q->q_first) != NULL ) {
+                /* Acquire LU queue specific lock */
+
+                qla2100_removeq(q, sp);
+
+                /* Release LU queue specific lock */
+                CMD_RESULT(sp->cmd) = stat;
+                qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+            }
+            LEAVE("qla2100_abort_queue_single");
+}
+
+/****************************************************************************/
+/*                QLogic ISP2100 Hardware Support Functions.                */
+/****************************************************************************/
+
+/*
+* qla2100_initialize_adapter
+*      Initialize board.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+uint8_t
+qla2100_initialize_adapter(scsi_qla_host_t *ha)
+{
+	uint8_t      status = QL_STATUS_SUCCESS;
+	uint8_t      isp_init = 0;
+	uint8_t      restart_risc = 0;
+	uint8_t      retry;
+
+#ifdef QL_DEBUG_LEVEL_3
+	ENTER("qla2100_initialize_adapter");
+#endif
+
+	/* Clear adapter flags. */
+	ha->forceLip = 0;
+	ha->flags.online = FALSE;
+	ha->flags.isp_abort_needed = FALSE;
+	ha->flags.disable_host_adapter = FALSE;
+	ha->flags.loop_resync_active = FALSE;
+	ha->flags.reset_active = FALSE;
+	ha->flags.abort_isp_active = FALSE;
+	ha->flags.watchdog_enabled = FALSE;
+	ha->loop_down_timer = LOOP_DOWN_TIME;
+	ha->loop_state = LOOP_DOWN;
+	ha->flags.start_timer  = FALSE;
+	ha->flags.done_requests_needed = FALSE;
+	ha->device_flags = 0;
+	ha->dpc_flags = 0;
+	ha->sns_retry_cnt = 0;
+	ha->host_db_ptr = 0;
+	ha->device_flags = 0;
+	/* 4.11 */
+	ha->flags.managment_server_logged_in = 0;
+
+	/* Allocate host database */
+	ha->phost_db = (fcdev_t *)KMALLOC(sizeof(fcdev_t) * MAX_HOST_COUNT);
+	if (ha->phost_db != NULL) {
+		BZERO(ha->phost_db, sizeof(fcdev_t) * MAX_HOST_COUNT);
+		DEBUG(sprintf(debug_buff,"Alloc Host DB success. Max Cnt=%d.",
+		    MAX_HOST_COUNT);)
+		DEBUG(qla2100_print(debug_buff);)
+	} else {
+		status = QL_STATUS_RESOURCE_ERROR;
+	}
+
+	DEBUG(printk("Configure PCI space for adapter...\n"));
+
+	if ( status == QL_STATUS_SUCCESS &&
+	    (status = qla2100_pci_config(ha)) == QL_STATUS_SUCCESS ) {
+
+		qla2100_reset_chip(ha);
+
+		/* Initialize Fibre Channel database. */
+		qla2100_init_fc_db(ha);
+
+		/* Initialize target map database. */
+		qla2100_init_tgt_map(ha);
+		if( qla2100_verbose )
+			printk(KERN_INFO
+			    "scsi(%d): Configure NVRAM parameters...\n",
+			    (int)ha->host_no);
+
+		if( ha->device_id == QLA2100_DEVICE_ID )
+			qla2100_nvram_config(ha);
+		else
+			qla2200_nvram_config(ha);
+
+		/* v2.19.12 */
+		ha->retry_count = ql2xretrycount;
+
+		if( qla2100_verbose )
+			printk(KERN_INFO
+			    "scsi(%d): Verifying loaded RISC code...\n",
+			    (int)ha->host_no);
+
+		qla2100_set_cache_line(ha);
+
+		/* If the user specified a device configuration on
+		* the command line then use it as the configuration.
+		* Otherwise, we scan for all devices.
+		*/
+		if ( ql2xdevconf ) {
+			qla2100_get_properties(ha, ql2xdevconf);
+		}
+
+		retry = 10; 
+		/*
+		* Try an configure the loop.
+		*/
+		do {
+			DEBUG(qla2100_print("qla2100_initialize_adapter: check "
+			    "if firmware needs to be loaded\n");)
+
+			/* If firmware needs to be loaded */
+			if( qla2100_isp_firmware(ha) ) {
+				if( qla2100_verbose )
+					printk(KERN_INFO
+					    "scsi(%d): Verifying chip...\n",
+					    (int)ha->host_no);
+
+				if( (status = qla2100_chip_diag(ha)) ==
+				    QL_STATUS_SUCCESS )
+					status = qla2100_setup_chip(ha);
+
+				if( status == QL_STATUS_SUCCESS )
+					DEBUG(printk("scsi(%d): Chip verified "
+					    "and RISC loaded...\n",
+					    (int)ha->host_no));
+			}
+
+			if ( status != QL_STATUS_SUCCESS )
+				continue;
+
+			status = qla2100_init_rings(ha);
+
+			if ( status != QL_STATUS_SUCCESS )
+				continue;
+
+			/* dg - 7/3/1999
+			* Wait for a successful LIP up to a maximum of 
+			* (in seconds): RISC login timeout value, RISC 
+			* retry count value, and port down retry value
+			* OR a minimum of 4 seconds OR If no cable,
+			* only 5 seconds.
+			*/
+			DEBUG(printk("scsi(%d): qla2100_init_rings OK, "
+			    "call qla2100_fw_ready...\n",
+			    (int)ha->host_no));
+			DEBUG(qla2100_print("qla2100_init_rings OK, "
+			    "call qla2100_fw_ready...\n");)
+
+			if ( qla2100_fw_ready(ha) == QL_STATUS_SUCCESS ) {
+				ha->flags.reset_marker = FALSE;
+
+				/* Go setup flash database devices
+				 * with proper Loop ID's.
+				 */
+				do {
+					ha->flags.loop_resync_needed = FALSE;
+					status = qla2100_update_fc_db(ha,
+					    FALSE);
+				} while( !ha->loop_down_timer &&
+				    ha->flags.loop_resync_needed );
+
+				/* If database was full and a device
+				 * was not configured, try and reuse
+				 * the slots.
+				 */
+
+				if( status == QL_STATUS_FATAL_ERROR ) {
+					do {
+						ha->flags.loop_resync_needed =
+						    FALSE;
+						status =
+						    qla2100_update_fc_db(ha,
+						    TRUE); 
+					} while( !ha->loop_down_timer &&
+					    ha->flags.loop_resync_needed );
+				}
+			}
+			if( ha->flags.update_config_needed ) {
+				ha->init_cb->additional_firmware_options.connection_options = ha->operating_mode;
+				restart_risc = 1;
+			}
+			isp_init = 1;
+
+		} while( restart_risc && retry-- );
+
+		if( isp_init ) {
+			ha->flags.reset_marker = FALSE;
+			qla2100_marker(ha, 0, 0, 0, MK_SYNC_ALL);
+
+			ha->flags.online = TRUE;
+
+			/* Enable target response to SCSI bus. */
+			if( ha->flags.enable_target_mode )
+			    qla2100_enable_lun(ha);
+		} 
+	}
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+	if ( status != QL_STATUS_SUCCESS )
+		qla2100_print("qla2100_initialize_adapter: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+	else
+		LEAVE("qla2100_initialize_adapter");
+#endif
+
+	return(status);
+}
+
+/*
+* ISP Firmware Test
+*      Checks if present version of RISC firmware is older than
+*      driver firmware.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = firmware does not need to be loaded.
+*/
+STATIC uint8_t
+qla2100_isp_firmware(scsi_qla_host_t *ha) {
+            uint8_t  status;
+            uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2x00_isp_firmware");
+#endif
+
+            if( ha->flags.disable_risc_code_load ) {
+                /* Verify checksum of loaded RISC code. */
+                mb[0] = MBC_VERIFY_CHECKSUM;
+                mb[1] = *QLBoardTbl_fc[ha->devnum].fwstart;
+                if( !(status = qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0])) ) {
+                    /* Start firmware execution. */
+                    mb[0] = MBC_EXECUTE_FIRMWARE;
+                    mb[1] = *QLBoardTbl_fc[ha->devnum].fwstart;
+                    qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
+                }
+            } else
+                status = 1;
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                qla2100_print(
+                "qla2100_isp_firmware: **** Return status=1; RISC Load Needed ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2x00_isp_firmware");
+#endif
+            return(status);
+}
+
+/*
+* (08/05/99)
+*
+* PCI configuration
+*      Setup device PCI configuration registers.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+STATIC uint8_t
+qla2100_pci_config(scsi_qla_host_t *ha) {
+            uint8_t      status = 1;
+            uint32_t     command;
+#if MEMORY_MAPPED_IO
+            uint32_t  page_offset, base;
+            uint32_t   mmapbase;
+#endif
+            config_reg_t *creg = 0;
+            uint16_t     buf_wd;
+
+            ENTER("qla2100_pci_config");
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+/* 4.12 */
+           /* turn on PCI master; for system BIOSes that don't turn
+              it on by default */
+            pci_set_master(ha->pdev);
+
+           if (ha->device_id == QLA2300_DEVICE_ID) {
+               pci_read_config_word(ha->pdev,OFFSET(creg->command), &buf_wd);
+               buf_wd = buf_wd | 
+                        PCI_COMMAND_IO |
+                        PCI_COMMAND_MEMORY | 
+                        PCI_COMMAND_MASTER | 
+                        PCI_COMMAND_INVALIDATE |
+                        PCI_COMMAND_PARITY | 
+                        PCI_COMMAND_SERR;
+               buf_wd = buf_wd & ~PCI_COMMAND_INVALIDATE;
+               pci_write_config_word(ha->pdev,OFFSET(creg->command), buf_wd);
+               /* temporary: set upper 32 bits of 64 bit address to 0 */
+               buf_wd = 0;
+               pci_write_config_word(ha->pdev,PCI_BASE_ADDRESS_2, buf_wd);
+           }
+#endif
+            pci_read_config_word(ha->pdev,OFFSET(creg->revision_id), &buf_wd);
+            ha->revision = buf_wd;
+            if( !ha->iobase ) {
+                /* Get command register. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                if( pci_read_config_word(ha->pdev,OFFSET(creg->command), &buf_wd) == PCIBIOS_SUCCESSFUL ) {
+#else
+                if( pci_read_config_word(ha->pdev,OFFSET(creg->command), &buf_wd) == PCIBIOS_SUCCESSFUL ) {
+#endif
+                    command = buf_wd;
+                    /*
+                    * Set Bus Master Enable (bit-2), Memory Address Space Enable and
+                    * reset any error bits.
+                    */
+                    buf_wd &= ~0x7;
+#if MEMORY_MAPPED_IO
+                    DEBUG(printk("qla2100: I/O SPACE and MEMORY MAPPED IO is enabled.\n"));
+                    buf_wd |= BIT_2 + BIT_1 + BIT_0;
+#else
+                    DEBUG(printk("qla2100: I/O SPACE Enabled and MEMORY MAPPED IO is disabled.\n"));
+                    buf_wd |= BIT_2 + BIT_0;
+#endif
+                    if( pci_write_config_word(ha->pdev,OFFSET(creg->command), buf_wd) ) {
+                        printk(KERN_WARNING "qla2100: Could not write config word.\n");
+                    }
+                    /* Get expansion ROM address. */
+                    if( pci_read_config_word(ha->pdev, OFFSET(creg->expansion_rom), &buf_wd) == PCIBIOS_SUCCESSFUL ) {
+                        /* Reset expansion ROM address decode enable. */
+                        buf_wd &= ~BIT_0;
+                        if( pci_write_config_word(ha->pdev, OFFSET(creg->expansion_rom), buf_wd) == PCIBIOS_SUCCESSFUL ) {
+#if MEMORY_MAPPED_IO
+                            /* Get memory mapped I/O address. */
+                            pcibios_read_config_dword(ha->pci_bus, ha->pci_device_fn,OFFSET(cfgp->mem_base_addr), &mmapbase);
+                            mmapbase &= PCI_BASE_ADDRESS_MEM_MASK;
+
+                            /* Find proper memory chunk for memory map I/O reg. */
+                            base = mmapbase & PAGE_MASK;
+                            page_offset = mmapbase - base;
+                            /* Get virtual address for I/O registers. */
+                            ha->mmpbase = ioremap(base,page_offset + 256);
+                            if( ha->mmpbase ) {
+                                ha->mmpbase += page_offset;
+                                /* ha->iobase = ha->mmpbase; */
+                                status = 0;
+                            }
+#else /* MEMORY_MAPPED_IO */
+                            status = 0;
+#endif /* MEMORY_MAPPED_IO */
+                        }
+                    }
+                }
+            } else
+                status = 0;
+
+
+            LEAVE("qla2100_pci_config");
+            return(status);
+}
+#else
+STATIC uint8_t
+qla2100_pci_config(scsi_qla_host_t *ha) {
+            uint8_t      status = 1;
+            uint32_t     command;
+#if MEMORY_MAPPED_IO
+            uint32_t  page_offset, base;
+            uint32_t   mmapbase;
+#endif
+            config_reg_t *creg = 0;
+            uint16_t     buf_wd;
+
+            ENTER("qla2100_pci_config");
+
+            pcibios_read_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->revision_id), &buf_wd);
+            ha->revision = buf_wd;
+            if( !ha->iobase ) {
+                /* Get command register. */
+                if( pcibios_read_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->command), &buf_wd) == PCIBIOS_SUCCESSFUL ) {
+                    command = buf_wd;
+
+                    /*
+                    * Set Bus Master Enable (bit-2), Memory Address Space Enable and
+                    * reset any error bits.
+                    */
+                    buf_wd &= ~0x7;
+#if MEMORY_MAPPED_IO
+                    DEBUG(printk("qla2100: I/O SPACE and MEMORY MAPPED IO is enabled.\n"));
+                    buf_wd |= BIT_2 + BIT_1 + BIT_0;
+#else
+                    DEBUG(printk("qla2100: I/O SPACE Enabled and MEMORY MAPPED IO is disabled.\n"));
+                    buf_wd |= BIT_2 + BIT_0;
+#endif
+                    if( pcibios_write_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->command), buf_wd) ) {
+                        printk(KERN_WARNING "qla2100: Could not write config word.\n");
+                    }
+                    /* Get expansion ROM address. */
+                    if( pcibios_read_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->expansion_rom), &buf_wd) == PCIBIOS_SUCCESSFUL ) {
+                        /* Reset expansion ROM address decode enable. */
+                        buf_wd &= ~BIT_0;
+                        if( pcibios_write_config_word(ha->pci_bus,ha->pci_device_fn, OFFSET(creg->expansion_rom), buf_wd) == PCIBIOS_SUCCESSFUL ) {
+#if MEMORY_MAPPED_IO
+                            /* Get memory mapped I/O address. */
+                            pcibios_read_config_dword(ha->pci_bus, ha->pci_device_fn,OFFSET(cfgp->mem_base_addr), &mmapbase);
+                            mmapbase &= PCI_BASE_ADDRESS_MEM_MASK;
+
+                            /* Find proper memory chunk for memory map I/O reg. */
+                            base = mmapbase & PAGE_MASK;
+                            page_offset = mmapbase - base;
+                            /* Get virtual address for I/O registers. */
+                            ha->mmpbase = ioremap(base,page_offset + 256);
+                            if( ha->mmpbase ) {
+                                ha->mmpbase += page_offset;
+                                /* ha->iobase = ha->mmpbase; */
+                                status = 0;
+                            }
+#else /* MEMORY_MAPPED_IO */
+                            status = 0;
+#endif /* MEMORY_MAPPED_IO */
+                        }
+                    }
+                }
+            } else
+                status = 0;
+
+
+            LEAVE("qla2100_pci_config");
+            return(status);
+}
+#endif
+
+
+/*
+* qla2100_set_cache_line
+*      Sets PCI cache line parameter.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_set_cache_line(scsi_qla_host_t *ha) {
+            int          status = 0;
+            uint8_t      buf;
+            config_reg_t *creg = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_set_cache_line");
+#endif
+            /* Set the cache line. */
+            if( ha->flags.set_cache_line_size_1 ) {
+                buf = 1;
+                if( pcibios_write_config_byte(ha->pci_bus,
+                    ha->pci_device_fn,
+                    (u_long)&creg->cache_line,buf) != PCIBIOS_SUCCESSFUL )
+                    status = 1;
+            }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                qla2100_print("qla2100_set_cache_line: **** FAILED ****\n\r");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            else
+                LEAVE("qla2100_set_cache_line");
+#endif
+            return(status);
+}
+
+/*
+* Chip diagnostics
+*      Test chip for proper operation.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_chip_diag(scsi_qla_host_t *ha) {
+            device_reg_t     *reg       = ha->iobase;
+            device2300_reg_t *reg2300   = ha->iobase2300;
+            uint8_t      status = 0;
+            uint16_t     data;
+            uint32_t     cnt;
+            uint16_t     mb[MAILBOX_REGISTER_COUNT];
+
+            ENTER("qla2100_chip_diag");
+#ifdef QL_DEBUG_LEVEL_3
+            qla2100_print("qla2100_chip_diag: testing device at ");
+        qla2100_output_number((u_long)&reg->flash_address, 16);
+            qla2100_print("\n");
+#endif
+
+            /* Reset ISP chip. */
+            WRT_REG_WORD(&reg->ctrl_status, ISP_RESET);
+            data = qla2100_debounce_register(&reg->ctrl_status);
+            for( cnt = 6000000 ; cnt && (data & ISP_RESET); cnt-- ) {
+                SYS_DELAY(5);
+                data = RD_REG_WORD(&reg->ctrl_status);
+            }
+
+            if( cnt ) {
+#if defined(QL_DEBUG_LEVEL_2)
+                qla2100_print("{{{qla2100_chip_diag: Reset register cleared by chip}}}\n\r");
+#endif
+                /* Reset RISC processor. */
+                WRT_REG_WORD(&reg->host_cmd, HC_RESET_RISC);
+                WRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);
+                data = qla2100_debounce_register(&reg->mailbox0);
+                for( cnt = 6000000; cnt && (data == MBS_BUSY); cnt-- ) {
+                    SYS_DELAY(5);
+                    data = RD_REG_WORD(&reg->mailbox0);
+                }
+
+                if( cnt ) {
+                    /* Check product ID of chip */
+#if defined(QL_DEBUG_LEVEL_2)
+                    qla2100_print("{{{qla2100_chip_diag: Checking product ID of chip}}}\n\r");
+#endif
+                if (ha->device_id != QLA2300_DEVICE_ID) {
+                    if( RD_REG_WORD(&reg->mailbox1) != PROD_ID_1 ||
+                       (RD_REG_WORD(&reg->mailbox2) != PROD_ID_2 &&
+                        RD_REG_WORD(&reg->mailbox2) != PROD_ID_2a) ||
+                        RD_REG_WORD(&reg->mailbox3) != PROD_ID_3 ||
+                        qla2100_debounce_register(&reg->mailbox4) != PROD_ID_4 ) {
+                        printk(KERN_WARNING "qla2100: [ERROR] Wrong product ID = 0x%x,0x%x,0x%x,0x%x\n",
+                        RD_REG_WORD(&reg->mailbox1),
+                        RD_REG_WORD(&reg->mailbox2),
+                        RD_REG_WORD(&reg->mailbox3),
+                        RD_REG_WORD(&reg->mailbox4));
+                        status = 1;
+                    } else {
+                        /* Now determine if we have a 2200A board */
+                        if( ( ha->device_id == QLA2200_DEVICE_ID   ||
+                              ha->device_id == QLA2200A_DEVICE_ID ) &&
+                              RD_REG_WORD(&reg->mailbox7) ==
+                              QLA2200A_RISC_ROM_VER ) {
+                                  ha->device_id = QLA2200A_DEVICE_ID;
+#if defined(QL_DEBUG_LEVEL_2)
+                                  qla2100_print("qla2100_chip_diag: Found QLA2200A chip.\n\r");
+#endif
+                        }
+                    }
+                } else {  /* check prod id of 2300 here */
+                    if( RD_REG_WORD(&reg2300->mailbox1) != PROD_ID_1 ||
+                       (RD_REG_WORD(&reg2300->mailbox2) != PROD_ID_2 &&
+                        RD_REG_WORD(&reg2300->mailbox2) != PROD_ID_2a) ||
+                        RD_REG_WORD(&reg2300->mailbox3) != PROD_ID_3 ||
+                        qla2100_debounce_register(&reg2300->mailbox4) != PROD_ID_4 ) {
+                        printk(KERN_WARNING "qla2300: [ERROR] Wrong product ID = 0x%x,0x%x,0x%x,0x%x\n",
+                        RD_REG_WORD(&reg2300->mailbox1),
+                        RD_REG_WORD(&reg2300->mailbox2),
+                        RD_REG_WORD(&reg2300->mailbox3),
+                        RD_REG_WORD(&reg2300->mailbox4));
+                        status = 1;
+                }
+                DEBUG(printk("qla2100_chip_diag: Do MBC_MAILBOX_REGISTER_TEST\n"));
+#if defined(QL_DEBUG_LEVEL_2)
+                qla2100_print("qla2100_chip_diag: Do MBC_MAILBOX_REGISTER_TEST\n\r");
+#endif
+                        /* Wrap Incoming Mailboxes Test. */
+                        mb[0] = MBC_MAILBOX_REGISTER_TEST;
+                        mb[1] = 0xAAAA;
+                        mb[2] = 0x5555;
+                        mb[3] = 0xAA55;
+                        mb[4] = 0x55AA;
+                        mb[5] = 0xA5A5;
+                        mb[6] = 0x5A5A;
+                        mb[7] = 0x2525;
+                        if( !(status = qla2100_mailbox_command(ha,
+                        BIT_7|BIT_6|BIT_5|BIT_4|BIT_3|BIT_2|BIT_1|BIT_0,
+                        &mb[0])) ) {
+                            if( mb[1] != 0xAAAA || mb[2] != 0x5555 ||
+                            mb[3] != 0xAA55 || mb[4] != 0x55AA )
+                                status = 1;
+                            if( mb[5] != 0xA5A5 || mb[6] != 0x5A5A ||
+                            mb[7] != 0x2525 )
+                                status = 1;
+                            if( status ) {
+                                printk(KERN_WARNING "qla2100_chip_diag: [ERROR] *** Failed mailbox register test ***\n\r");
+                                DEBUG(qla2100_print("qla2100_chip_diag: *** Failed mailbox register test ***\n\r");)
+                            }
+                        } else {
+                                printk(KERN_WARNING "qla2100_chip_diag: [ERROR] failed mailbox send register test\n");
+                                DEBUG(qla2100_print("qla2100_chip_diag: Failed mailbox send register test\n\r");)
+                        }
+                    }
+                } else
+                    status = 1;
+            } else
+                status = 1;
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                 qla2100_print("qla2100_chip_diag: **** FAILED ****\n");
+            else qla2100_print("qla2100_chip_diag: Returning Good Status \n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_chip_diag");
+#endif
+            return(status);
+}
+
+/*
+* Setup chip
+*      Load and start RISC firmware.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_setup_chip(scsi_qla_host_t *ha) {
+            uint16_t cnt;
+            uint16_t risc_address;
+            uint16_t *risc_code_address;
+            long risc_code_size;
+            uint16_t mb[MAILBOX_REGISTER_COUNT];
+            uint8_t  status = 0;
+            int num, temp;
+#ifdef WORD_FW_LOAD
+            uint16_t *ql21_risc_code_addr01;
+            uint16_t  ql21_risc_code_length01;
+            uint8_t   dump_status;
+#endif
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_setup_chip");
+#endif
+
+            /* Load RISC code. */
+            risc_address = *QLBoardTbl_fc[ha->devnum].fwstart;
+            risc_code_address = QLBoardTbl_fc[ha->devnum].fwcode;
+            risc_code_size    = (long)(*QLBoardTbl_fc[ha->devnum].fwlen & 0xffff);
+
+            DEBUG(printk("qla2100_setup_chip: Loading RISC code size =(0x%lx)\n",risc_code_size);)
+            DEBUG(qla2100_print("qla2100_setup_chip: Loading RISC code now in silent mode!\n\r");)
+            num = 0;
+            DEBUG(sprintf(debug_buff,"virt=%x phys=%x\n\r",ha->request_ring,ha->request_dma);)
+            DEBUG(qla2100_print(debug_buff);)
+            /* go into silent mode */
+            temp =  ql2x_debug_print;
+            if( ql2x_debug_print )    ql2x_debug_print = 0;
+
+            while( risc_code_size > 0 && !status ) {
+                /* for 2200A set transfer size to 128 bytes */
+                if( ha->device_id == QLA2200A_DEVICE_ID )
+                    cnt = 128 >> 1;
+                else
+                    cnt = REQUEST_ENTRY_SIZE * REQUEST_ENTRY_CNT >> 1;
+                if( cnt > risc_code_size )
+                    cnt = risc_code_size;
+
+                DEBUG(sprintf(debug_buff,"qla2100_setup_chip:loading risc segment@ addr 0x%x, number of bytes 0x%x, offset 0x%x.\n\r",risc_code_address,cnt,risc_address);)
+                DEBUG(qla2100_print(debug_buff);)
+
+                BCOPY((caddr_t) risc_code_address,(caddr_t) ha->request_ring, (cnt <<1));
+
+                flush_cache_all(); /* flush written firmware to the
+                                      ha->request_ring buffer before DMA */
+
+                mb[0] = MBC_LOAD_RAM;
+                mb[1] = risc_address;
+                mb[3] = (uint16_t)(ha->request_dma & 0xffff);
+                mb[2] = (uint16_t)((ha->request_dma >> 16) & 0xffff);
+                mb[4] = cnt;
+                status = qla2100_mailbox_command(ha, BIT_4|BIT_3|BIT_2|BIT_1|BIT_0,
+                &mb[0]);
+
+                if( status ) {
+                    qla2100_dump_regs(ha->host);
+                    printk(KERN_WARNING "qla2x00: [ERROR] Failed to load segment %d of FW\n",num);
+                    DEBUG(qla2100_print("qla2100_setup_chip: Failed to load segment of FW\n");)
+                    break;
+                }
+                risc_address += cnt;
+                risc_code_size -= cnt;
+                risc_code_address += cnt;
+                num++;
+            }
+            ql2x_debug_print = temp;
+
+#ifdef WORD_FW_LOAD
+            {
+                int i;
+                uint8_t temp;
+
+                temp =  ql2x_debug_print;
+                if( ql2x_debug_print )   ql2x_debug_print = 0;
+                risc_address = *QLBoardTbl_fc[ha->devnum].fwstart;
+                ql21_risc_code_addr01  = QLBoardTbl_fc[ha->devnum].fwcode;
+                ql21_risc_code_length01= (long)(*QLBoardTbl_fc[ha->devnum].fwlen & 0xffff);
+
+                for( i = 0; i < ql21_risc_code_length01 ; i++ ) {
+
+                    mb[0] = MBC_WRITE_RAM_WORD;
+                    mb[1] = risc_address + i;
+                    mb[2] = *(ql21_risc_code_addr01 + i);
+
+                    dump_status = qla2100_mailbox_command(ha,BIT_2|BIT_1|BIT_0,
+                    &mb[0]);
+                    if( dump_status ) {
+                        printk(KERN_WARNING "qla2x00 : [ERROR] firmware load failure\n");
+                        break;
+                    }
+
+                    mb[0] = MBC_READ_RAM_WORD;
+                    mb[1] = risc_address + i;
+                    mb[2] = 0;
+
+                    dump_status = qla2100_mailbox_command(ha,BIT_2|BIT_1|BIT_0,
+                    &mb[0]);
+                    if( dump_status ) {
+                        printk(KERN_WARNING "qla2x00: [ERROR] RISC FW Read Failure\n");
+                        break;
+                    }
+                    if( mb[2] != *(ql21_risc_code_addr01 + i) )
+                        printk(KERN_WARNING "qla2x00: [ERROR] RISC FW Compare ERROR @ (0x%p)\n",
+                        (void *) (ql21_risc_code_addr01+i));
+                }
+                ql2x_debug_print = temp;
+                printk(KERN_INFO "qla2x00: RISC FW download confirmed... \n");
+            }
+#endif
+            /* Verify checksum of loaded RISC code. */
+            if( !status ) {
+                DEBUG(printk("qla2100_setup_chip: Verifying Check Sum of loaded RISC code.\n");)
+                mb[0] = MBC_VERIFY_CHECKSUM;
+                mb[1] = *QLBoardTbl_fc[ha->devnum].fwstart;
+                if( !(status = qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0])) ) {
+                    /* Start firmware execution. */
+                    DEBUG(qla2100_print("qla2100_setup_chip: CS Ok, Start firmware running\n\r");)
+                    mb[0] = MBC_EXECUTE_FIRMWARE;
+                    mb[1]= *QLBoardTbl_fc[ha->devnum].fwstart;
+                    status = qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
+                }
+#if defined(QL_DEBUG_LEVEL_2)
+                else
+                    qla2100_print("qla2100_setup_chip: ISP FW Failed Check Sum\n");
+#endif
+            }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                qla2100_print("qla2100_setup_chip: **** FAILED ****\n");
+            else qla2100_print("qla2100_setup_chip: Returning Good Status\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_setup_chip");
+#endif
+            return(status);
+}
+
+/*
+* qla2100_init_rings
+*      Initializes firmware.
+*
+*      Beginning of request ring has initialization control block
+*      already built by nvram config routine.
+*
+* Input:
+*      ha                = adapter block pointer.
+*      ha->request_ring  = request ring virtual address
+*      ha->response_ring = response ring virtual address
+*      ha->request_dma   = request ring physical address
+*      ha->response_dma  = response ring physical address
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_init_rings(scsi_qla_host_t *ha) {
+            uint8_t  status;
+            uint16_t mb[MAILBOX_REGISTER_COUNT];
+            int cnt;
+            device2300_reg_t *reg2300   = ha->iobase2300;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_init_rings");
+#endif
+            /* Clear outstanding commands array. */
+            for( cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++ )
+                ha->outstanding_cmds[cnt] = 0;
+
+#ifdef RSCN
+            /* Clear RSCN queue. */
+            ha->rscn_in_ptr = 0;
+            ha->rscn_out_ptr = 0;
+#endif
+
+            /* Initialize firmware. */
+            ha->request_ring_ptr  = ha->request_ring;
+            ha->req_ring_index    = 0;
+            ha->req_q_cnt         = REQUEST_ENTRY_CNT;
+            ha->response_ring_ptr = ha->response_ring;
+            ha->rsp_ring_index    = 0;
+            mb[0] = MBC_INITIALIZE_FIRMWARE;
+            mb[3] = LSW(ha->init_cb_dma);
+            mb[2] = MSW(ha->init_cb_dma);
+            mb[4] = 0; /* set request queue in ptr   for 2100/2200 */
+            mb[5] = 0; /* set response queue out ptr for 2100/2200*/
+            mb[7] = QL21_64BITS_3RDWD(ha->init_cb_dma);
+            mb[6] = QL21_64BITS_4THWD(ha->init_cb_dma);
+
+            if (ha->device_id == QLA2300_DEVICE_ID) {
+            /* set request queue in ptr , response queue out ptr for 2300 */ 
+               WRT_REG_WORD(&reg2300->req_q_in,  0);
+               WRT_REG_WORD(&reg2300->rsp_q_out, 0);
+            }
+
+            DEBUG(qla2100_print("qla2100_init_rings: Issue MBC_INIT_FIRMWARE op\n");)
+            status = qla2100_mailbox_command(ha,
+            BIT_7|BIT_6|BIT_5|BIT_4|BIT_3|BIT_2|BIT_0,
+            &mb[0]);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                qla2100_print("qla2100_init_rings: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_init_rings");
+#endif
+            return(status);
+}
+
+/*
+* qla2100_fw_ready
+*      Waits for firmware ready.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_fw_ready(scsi_qla_host_t *ha) {
+        uint8_t  status = 0;
+        uint32_t cnt, cnt1;
+        uint16_t mb[MAILBOX_REGISTER_COUNT];
+        uint16_t timeout;
+
+#ifdef QL_DEBUG_LEVEL_3
+        ENTER("qla2100_fw_ready");
+#endif
+        timeout = (ha->retry_count * ha->login_timeout) + 5;
+        cnt1 = 0x350;   /* 25 secs */ 
+        /* Wait for ISP to finish LIP */
+        if(!qla2100_quiet) printk(KERN_INFO "scsi(%d): Waiting for LIP to complete...\n", (int)ha->host->host_no);
+        if( timeout )
+          cnt = 36 * timeout;
+        else
+          cnt = 0x700;
+
+        for( ; cnt; cnt-- ) {
+            mb[0] = MBC_GET_FIRMWARE_STATE;
+            if( !(status = qla2100_mailbox_command(ha, BIT_0, &mb[0])) ) {
+                if( ha->loop_down_timer || mb[1] != FSTATE_READY ) {
+                    status = 1;
+                    /* Exit if no cable connected after 10 seconds. */
+                    if( !cnt1-- )
+                        if( mb[1] == FSTATE_CONFIG_WAIT || mb[1] == FSTATE_LOSS_OF_SYNC ) {
+
+                            break;   
+                        }
+                } else {
+                    DEBUG(printk("qla2100_fw_ready: F/W Ready - OK \n");)
+                    status = 0;   /* dg 09/15/99 */
+                    break;
+                }
+            }
+
+            if( ha->flags.online ) {
+                status = 0;   /* dg 09/15/99 */
+                break;
+            }
+
+            /* Delay for a while */
+            udelay(10);
+
+#ifdef QL_DEBUG_LEVEL_2
+/*            qla2100_print("qla2100_fw_ready: mailbox_out[1] = ");
+            qla2100_output_number((uint32_t)mb[1], 16);
+            qla2100_print("\n");*/
+#endif
+        }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+        if( status )
+            qla2100_print("qla2100_fw_ready: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+        else
+            LEAVE("qla2100_fw_ready");
+#endif
+        return(status);
+}
+
+/*
+*  qla2100_configure_hba
+*      Setup adapter context.
+*
+* Input:
+*      ha = adapter state pointer.
+*
+* Returns:
+*      0 = success
+*      1 = failed
+*
+* Context:
+*      Kernel context.
+*/
+STATIC uint8_t
+qla2100_configure_hba(scsi_qla_host_t *ha) {
+            uint8_t       rval;
+            uint16_t    mb[MAILBOX_REGISTER_COUNT];
+            uint8_t       connect_type[22];
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_configure_hba");
+#endif
+
+            /* Get host addresses. */
+            mb[0] = MBC_GET_ADAPTER_LOOP_ID;
+            rval = qla2100_mailbox_command(ha, BIT_0, &mb[0]);
+            if( !rval ) {
+                if( mb[6] == 4 ) {
+                	printk(KERN_INFO "scsi%d: Can't get topology - retrying\n",(int)ha->host_no);
+			return(1);
+                }
+                ha->loop_id = mb[1];
+
+                /* Get loop topology. */
+                if( ha->device_id == QLA2100_DEVICE_ID ) {
+                    mb[6] = 0;
+                }
+                ha->min_external_loopid = SNS_FIRST_LOOP_ID;
+                ha->operating_mode = LOOP;
+                switch( mb[6] ) {
+                    case 0:
+                        ha->current_topology = ISP_CFG_NL;
+                        strcpy((char *)&connect_type[0],"(Loop)");
+                        break;
+                    case 1:
+                        ha->current_topology = ISP_CFG_FL;
+                        strcpy((char *)&connect_type[0],"(FL_Port)");
+                        break;
+                    case 2:
+                        ha->operating_mode = P2P;
+                        ha->current_topology = ISP_CFG_N;
+                        ha->min_external_loopid = 1;  /* v2.19.5b3 */
+                        strcpy((char *)&connect_type[0],"(N_Port-to-N_Port)");
+                        break;
+                    case 3:
+                        ha->operating_mode = P2P;
+                        ha->current_topology = ISP_CFG_F;
+                        ha->min_external_loopid = 1;  /* v2.19.5b3 */
+                        strcpy((char *)&connect_type[0],"(F_Port)");
+                        break;
+                    default:
+                        ha->current_topology = ISP_CFG_NL;
+                        strcpy((char *)&connect_type[0],"(Loop)");
+                        break;
+                }
+
+                /* Save Host port and loop ID. */
+                /* Reverse byte order - TT */
+                ha->port_id[2] = LSB(mb[2]);
+                ha->port_id[1] = MSB(mb[2]);
+                ha->port_id[0] = LSB(mb[3]);
+                if (!qla2100_quiet) printk(KERN_INFO "scsi%d: Topology - %s, Host Loop address  0x%x\n",(int)ha->host_no,connect_type, ha->loop_id);
+            } else
+                printk(KERN_WARNING "qla2100_configure_hba: [ERROR] Get host loop ID  failed\n");
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( rval != 0 )
+                qla2100_print("qla2100_configure_hba: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            else
+                LEAVE("qla2100_configure_hba");
+#endif
+            return(rval);
+}
+
+/*
+* NVRAM configuration for 2100.
+*
+* Input:
+*      ha                = adapter block pointer.
+*      ha->request_ring  = request ring virtual address
+*      ha->response_ring = response ring virtual address
+*      ha->request_dma   = request ring physical address
+*      ha->response_dma  = response ring physical address
+*
+* Output:
+*      initialization control block in response_ring
+*      host adapters parameters in host adapter block
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_nvram_config(scsi_qla_host_t *ha) {
+            uint8_t   status = 0;
+            uint16_t  cnt;
+            caddr_t   dptr1, dptr2;
+            init_cb_t *icb   = ha->init_cb;
+            nvram21_t   *nv    = (nvram21_t *)ha->request_ring;
+            uint16_t  *wptr  = (uint16_t *)ha->request_ring;
+            uint8_t   chksum = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_nvram_config");
+#endif
+
+            /* Verify valid NVRAM checksum. */
+            for( cnt = 0; cnt < sizeof(nvram21_t)/2; cnt++ ) {
+                *wptr = qla2100_get_nvram_word(ha, cnt);
+                chksum += (uint8_t)*wptr;
+                chksum += (uint8_t)(*wptr >> 8);
+                wptr++;
+            }
+
+#if  DEBUG_PRINT_NVRAM
+            qla2100_print(
+            "qla2100_nvram_config: Contents of NVRAM ");
+            qla2100_print("\n\r");
+            qla2100_dump_buffer((uint8_t *)ha->request_ring, sizeof(nvram21_t));
+#endif
+
+            /* Bad NVRAM data, set defaults parameters. */
+            if( chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P' ||
+            nv->id[3] != ' ' || nv->nvram_version < 1 ) {
+                /* Reset NVRAM data. */
+                DEBUG(printk("Using defaults for NVRAM: \n"));
+                DEBUG(printk("checksum=0x%x, Id=%c, version=0x%x\n",chksum,nv->id[0],nv->nvram_version));
+                wptr = (uint16_t *)ha->request_ring;
+                for( cnt = 0; cnt < sizeof(nvram21_t)/2; cnt++ )
+                    *wptr++ = 0;
+
+                /*
+                * Set default initialization control block.
+                */
+                nv->parameter_block_version = ICB_VERSION;
+                nv->firmware_options.enable_fairness = 1;
+                nv->firmware_options.enable_fast_posting = 1;
+                nv->firmware_options.enable_full_login_on_lip = 1;
+
+                nv->frame_payload_size  = 1024;
+                nv->max_iocb_allocation = 256;
+                nv->execution_throttle  = 16;
+                nv->retry_count         = 8;
+                nv->retry_delay         = 1;
+                nv->node_name[0]        = 32;
+                nv->node_name[3]        = 224;
+                nv->node_name[4]        = 139;
+                nv->login_timeout       = 4;
+
+                /*
+                * Set default host adapter parameters
+                */
+                nv->host_p.enable_lip_full_login = 1;
+                nv->reset_delay = 5;
+                nv->port_down_retry_count = 8;
+                nv->maximum_luns_per_target = 8;
+                status = 1;
+            }
+
+            /*
+            * Copy over NVRAM RISC parameter block
+            * to initialization control block.
+            */
+            dptr1 = (caddr_t)icb;
+            dptr2 = (caddr_t)&nv->parameter_block_version;
+            cnt = (caddr_t)&nv->host_p - (caddr_t)&nv->parameter_block_version;
+            while( cnt-- )
+                *dptr1++ = *dptr2++;
+
+            /* HBA node name 0 correction */
+            for (cnt=0 ; cnt<8 ; cnt++) {
+                if (icb->node_name[cnt] != 0)
+                   break;
+            }
+            if (cnt == 8) {
+               for ( cnt= 0 ; cnt < 8 ; cnt++) 
+                    icb->node_name[cnt] = icb->port_name[cnt];
+               icb->node_name[0] = icb->node_name[0] & ~BIT_0;
+               icb->port_name[0] = icb->port_name[0] |  BIT_0;
+            }
+
+            /*
+            * Setup driver firmware options.
+            */
+#if  QL2100_TARGET_MODE_SUPPORT
+            icb->firmware_options.enable_target_mode       = 1;
+#else
+            icb->firmware_options.enable_target_mode       = 0;
+#endif
+            icb->firmware_options.disable_initiator_mode   = 0;
+            icb->firmware_options.enable_port_update_event = 1;
+            icb->firmware_options.enable_full_login_on_lip = 1;
+
+            /*
+            * Set host adapter parameters
+            */
+            ha->flags.enable_target_mode = icb->firmware_options.enable_target_mode;
+            ha->flags.disable_luns            = nv->host_p.disable_luns;
+            ha->flags.disable_risc_code_load  = nv->host_p.disable_risc_code_load;
+            ha->flags.set_cache_line_size_1   = nv->host_p.set_cache_line_size_1;
+            ha->flags.enable_64bit_addressing = nv->host_p.enable_64bit_addressing;
+
+#if BITS_PER_LONG > 32
+    /* Enable 64bit addressing for OS/System combination supporting it   */
+    /* actual NVRAM bit is: nv->cntr_flags_1.enable_64bit_addressing     */ 
+    /* but we will ignore it and use BITS_PER_LONG macro to setup for    */
+    /* 64 or 32 bit access of host memory in all x86/ia-64/Alpha systems */
+    ha->flags.enable_64bit_addressing = 1;
+#else
+    ha->flags.enable_64bit_addressing = 0;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+        if (ha->flags.enable_64bit_addressing)
+           printk(KERN_INFO "[[[ qla2x00: 64 Bit PCI Addressing Enabled ]]]\n");
+
+#if BITS_PER_LONG > 32
+           /* Update our PCI device dma_mask for full 64 bit mask */
+           /* ha->pdev->dma_mask = (pci_dma_t) 0xffffffffffffffffull; */
+           ha->pdev->dma_mask = 0xffffffffffffffff;
+#endif
+#endif
+            ha->flags.enable_lip_reset        = nv->host_p.enable_lip_reset;
+            ha->flags.enable_lip_full_login   = nv->host_p.enable_lip_full_login;
+            ha->flags.enable_target_reset     = nv->host_p.enable_target_reset;
+            ha->flags.enable_flash_db_update  = nv->host_p.enable_database_storage;
+
+            /* new for IOCTL support of APIs */
+            ha->node_name[0] = icb->node_name[0];
+            ha->node_name[1] = icb->node_name[1];
+            ha->node_name[2] = icb->node_name[2];
+            ha->node_name[3] = icb->node_name[3];
+            ha->node_name[4] = icb->node_name[4];
+            ha->node_name[5] = icb->node_name[5];
+            ha->node_name[6] = icb->node_name[6];
+            ha->node_name[7] = icb->node_name[7];
+            ha->nvram_version = nv->nvram_version;
+
+            /* empty data for QLA2100s OEM stuff */
+            ha->oem_id          = 0;
+            ha->oem_spare0      = 0;
+            for ( cnt= 0 ; cnt < 8 ; cnt++) {
+                 ha->oem_string[cnt] = 0; 
+                 ha->oem_part[cnt]   = 0; 
+                 ha->oem_fru[cnt]    = 0; 
+                 ha->oem_ec[cnt]     = 0; 
+            }
+
+            ha->hiwat                 = icb->iocb_allocation;
+            ha->execution_throttle  = nv->execution_throttle;
+
+            ha->retry_count           = nv->retry_count;
+            ha->login_timeout         = nv->login_timeout;
+            /* Set minimum login_timeout to 4 seconds. */
+            if( ha->login_timeout < 4 )
+                ha->login_timeout = 4;
+            ha->port_down_retry_count = nv->port_down_retry_count;
+            ha->minimum_timeout       = (ha->login_timeout * ha->retry_count)
+            + ha->port_down_retry_count;
+            ha->loop_reset_delay      = nv->reset_delay;
+            /* Will get the value from nvram. */
+            ha->loop_down_timeout     = LOOP_DOWN_TIMEOUT;
+            ha->loop_down_abort_time  = LOOP_DOWN_TIME - ha->loop_down_timeout;
+
+            /* save HBA serial number */
+            ha->serial0 = nv->node_name[5];
+            ha->serial1 = nv->node_name[6];
+            ha->serial2 = nv->node_name[7];
+
+#if  USE_BIOS_MAX_LUNS
+            if( !nv->maximum_luns_per_target )
+                ha->max_luns = MAX_LUNS-1;
+            else
+                ha->max_luns = nv->maximum_luns_per_target;
+#else
+            ha->max_luns = MAX_LUNS-1;
+#endif
+
+            /*
+            * Setup ring parameters in initialization control block
+            */
+            icb->request_q_outpointer  = 0;
+            icb->response_q_inpointer  = 0;
+            icb->request_q_length      = REQUEST_ENTRY_CNT;
+            icb->response_q_length     = RESPONSE_ENTRY_CNT;
+            icb->request_q_address[0]  = LS_64BITS(ha->request_dma);
+            icb->request_q_address[1]  = MS_64BITS(ha->request_dma);
+            icb->response_q_address[0] = LS_64BITS(ha->response_dma);
+            icb->response_q_address[1] = MS_64BITS(ha->response_dma);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                qla2100_print("qla2100_nvram_config: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            else
+                LEAVE("qla2100_nvram_config");
+#endif
+            return(status);
+}
+
+/*
+* NVRAM configuration for the 2200.
+*
+* Input:
+*      ha                = adapter block pointer.
+*      ha->request_ring  = request ring virtual address
+*      ha->response_ring = response ring virtual address
+*      ha->request_dma   = request ring physical address
+*      ha->response_dma  = response ring physical address
+*
+* Output:
+*      initialization control block in response_ring
+*      host adapters parameters in host adapter block
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2200_nvram_config(scsi_qla_host_t *ha) {
+            uint8_t   status = 0;
+            uint16_t  cnt;
+            caddr_t   dptr1, dptr2;
+            init_cb_t *icb   = ha->init_cb;
+            nvram22_t   *nv    = (nvram22_t *)ha->request_ring;
+            uint16_t  *wptr  = (uint16_t *)ha->request_ring;
+            uint8_t   chksum = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2200/2300_nvram_config");
+#endif
+
+            if( !ha->flags.nvram_config_done ) {
+
+                /* Verify valid NVRAM checksum. */
+                for( cnt = 0; cnt < sizeof(nvram22_t)/2; cnt++ ) {
+                    *wptr = qla2100_get_nvram_word(ha, cnt);
+                    chksum += (uint8_t)*wptr;
+                    chksum += (uint8_t)(*wptr >> 8);
+                    wptr++;
+                }
+
+#if  DEBUG_PRINT_NVRAM
+                qla2100_print(
+                "qla2200_nvram_config: Contents of NVRAM ");
+                qla2100_print("\n\r");
+                qla2100_dump_buffer((uint8_t *)ha->request_ring, sizeof(nvram22_t));
+#endif
+
+                /* Bad NVRAM data, set defaults parameters. */
+                if( chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P' ||
+                nv->id[3] != ' ' || nv->nvram_version < 1 ) {
+                    /* Reset NVRAM data. */
+                    DEBUG(printk("Using defaults for 2200/2300 NVRAM: \n"));
+                    DEBUG(printk("checksum=0x%x, Id0=%c Id1=%c Id2=%x, version=0x%x\n",chksum,nv->id[0],nv->id[1],nv->id[2],nv->nvram_version));
+                    wptr = (uint16_t *)nv;
+                    for( cnt = 0; cnt < sizeof(nvram21_t)/2; cnt++ )
+                        *wptr++ = 0;
+
+                    /*
+                    * Set default initialization control block.
+                    */
+                    nv->parameter_block_version = ICB_VERSION;
+                    nv->firmware_options.enable_fairness = 1;
+                    nv->firmware_options.enable_fast_posting = 1;
+                    nv->firmware_options.enable_full_login_on_lip = 1;
+                    nv->firmware_options.enable_name_change = 1;
+                    nv->firmware_options.expanded_ifwcb = 1;
+
+                    nv->frame_payload_size  = 1024;
+                    nv->max_iocb_allocation = 256;
+                    nv->execution_throttle  = 16;
+                    nv->retry_count         = 8;
+                    nv->retry_delay         = 1;
+                    nv->port_name[0]        = 32;
+                    nv->port_name[3]        = 224;
+                    nv->port_name[4]        = 139;
+                    nv->login_timeout       = 4;
+                    nv->additional_firmware_options.connection_options = P2P_LOOP;
+                    /*
+                    * Set default host adapter parameters
+                    */
+                    nv->host_p.enable_lip_full_login = 1;
+                    nv->reset_delay = 5;
+                    nv->port_down_retry_count = 8;
+                    nv->maximum_luns_per_target = 8;
+                    status = 1;
+                }
+
+                /* Reset icb data */
+                BZERO((caddr_t)icb, sizeof(init_cb_t));
+                /*
+                * Copy over NVRAM RISC parameter block
+                * to initialization control block.
+                */
+                dptr1 = (caddr_t)icb;
+                dptr2 = (caddr_t)&nv->parameter_block_version;
+                cnt = (caddr_t)&nv->additional_firmware_options - (caddr_t)&nv->parameter_block_version;
+                while( cnt-- )
+                    *dptr1++ = *dptr2++;
+
+                dptr1 += (caddr_t)&icb->additional_firmware_options - (caddr_t)&icb->request_q_outpointer;
+                cnt = (caddr_t)&nv->host_p - (caddr_t)&nv->additional_firmware_options;
+                while( cnt-- )
+                    *dptr1++ = *dptr2++;
+
+                /* HBA node name 0 correction */
+                for (cnt=0 ; cnt<8 ; cnt++) {
+                    if (icb->node_name[cnt] != 0)
+                       break;
+                }
+                if (cnt == 8) {
+                   for ( cnt= 0 ; cnt < 8 ; cnt++) 
+                       icb->node_name[cnt] = icb->port_name[cnt];
+                   icb->node_name[0] = icb->node_name[0] & ~BIT_0;
+                   icb->port_name[0] = icb->port_name[0] |  BIT_0;
+                }
+
+                /*
+                * Setup driver firmware options.
+                */
+                icb->firmware_options.enable_full_duplex       = 0;
+#if  QL2100_TARGET_MODE_SUPPORT
+                icb->firmware_options.enable_target_mode       = 1;
+#else
+                icb->firmware_options.enable_target_mode       = 0;
+#endif
+                icb->firmware_options.disable_initiator_mode   = 0;
+                icb->firmware_options.enable_port_update_event = 1;
+                icb->firmware_options.enable_full_login_on_lip = 1;
+#if USE_TP_FW
+                icb->firmware_options.enable_name_change = 1;
+                icb->firmware_options.expanded_ifwcb = 1;
+#endif
+                /*
+                * Set host adapter parameters
+                */
+                ha->flags.enable_target_mode = icb->firmware_options.enable_target_mode;
+                ha->flags.disable_luns            = nv->host_p.disable_luns;
+                ha->flags.disable_risc_code_load  = nv->host_p.disable_risc_code_load;
+                ha->flags.set_cache_line_size_1   = nv->host_p.set_cache_line_size_1;
+                ha->flags.enable_64bit_addressing = nv->host_p.enable_64bit_addressing;
+
+#if BITS_PER_LONG > 32
+    /* Enable 64bit addressing for OS/System combination supporting it   */
+    /* actual NVRAM bit is: nv->cntr_flags_1.enable_64bit_addressing     */ 
+    /* but we will ignore it and use BITS_PER_LONG macro to setup for    */
+    /* 64 or 32 bit access of host memory in all x86/ia-64/Alpha systems */
+    ha->flags.enable_64bit_addressing = 1;
+#else
+    ha->flags.enable_64bit_addressing = 0;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+        if (ha->flags.enable_64bit_addressing)
+           printk(KERN_INFO "[[[ qla2x00: 64 Bit PCI Addressing Enabled ]]]\n");
+
+#if BITS_PER_LONG > 32
+           /* Update our PCI device dma_mask for full 64 bit mask */
+           ha->pdev->dma_mask = 0xffffffffffffffff;
+#endif
+#endif
+                ha->flags.enable_lip_reset        = nv->host_p.enable_lip_reset;
+                ha->flags.enable_lip_full_login   = nv->host_p.enable_lip_full_login;
+                ha->flags.enable_target_reset     = nv->host_p.enable_target_reset;
+                ha->flags.enable_flash_db_update  = nv->host_p.enable_database_storage;
+                ha->operating_mode = icb->additional_firmware_options.connection_options;
+
+            /* new for IOCTL support of APIs */
+            ha->node_name[0] = icb->node_name[0];
+            ha->node_name[1] = icb->node_name[1];
+            ha->node_name[2] = icb->node_name[2];
+            ha->node_name[3] = icb->node_name[3];
+            ha->node_name[4] = icb->node_name[4];
+            ha->node_name[5] = icb->node_name[5];
+            ha->node_name[6] = icb->node_name[6];
+            ha->node_name[7] = icb->node_name[7];
+            ha->nvram_version = nv->nvram_version;
+ 
+
+                ha->hiwat                 = icb->iocb_allocation;
+                ha->execution_throttle  = nv->execution_throttle;
+
+                ha->retry_count           = nv->retry_count;
+                ha->login_timeout         = nv->login_timeout;
+                /* Set minimum login_timeout to 4 seconds. */
+                if( ha->login_timeout < 4 )
+                    ha->login_timeout = 4;
+                ha->port_down_retry_count = nv->port_down_retry_count;
+                ha->minimum_timeout       = (ha->login_timeout * ha->retry_count)
+                + ha->port_down_retry_count;
+                ha->loop_reset_delay      = nv->reset_delay;
+                /* Will get the value from nvram. */
+                ha->loop_down_timeout     = LOOP_DOWN_TIMEOUT;
+                ha->loop_down_abort_time  = LOOP_DOWN_TIME - ha->loop_down_timeout;
+
+                /* save HBA serial number */
+                ha->serial0 = nv->port_name[5];
+                ha->serial1 = nv->port_name[6];
+                ha->serial2 = nv->port_name[7];
+
+                /* save OEM related items for QLA2200s and QLA2300s */
+                ha->oem_id     = nv->oem_id;
+                ha->oem_spare0 = nv->oem_spare0;
+
+                for ( cnt= 2 ; cnt < 8 ; cnt++ ) 
+                  ha->oem_string[cnt] = nv->oem_string[cnt]; 
+
+                for ( cnt= 0 ; cnt < 8 ; cnt++ ) {
+                  ha->oem_part[cnt]   = nv->oem_part[cnt]; 
+                  ha->oem_fru[cnt]    = nv->oem_fru[cnt]; 
+                  ha->oem_ec[cnt]     = nv->oem_ec[cnt]; 
+                }
+
+#ifdef FC_IP_SUPPORT
+                for (cnt = 0; cnt < 8; cnt++)
+                    ha->acPortName[cnt] = nv->port_name[cnt];
+#endif
+
+#if  USE_BIOS_MAX_LUNS
+                if( !nv->maximum_luns_per_target )
+                    ha->max_luns = MAX_LUNS;
+                else if( nv->maximum_luns_per_target < MAX_LUNS )
+                    ha->max_luns = nv->maximum_luns_per_target;
+                else
+                    ha->max_luns = MAX_LUNS;
+#else
+                ha->max_luns = MAX_LUNS;
+#endif
+
+                /*
+                * Setup ring parameters in initialization control block
+                */
+                icb->request_q_outpointer  = 0;
+                icb->response_q_inpointer  = 0;
+                icb->request_q_length      = REQUEST_ENTRY_CNT;
+                icb->response_q_length     = RESPONSE_ENTRY_CNT;
+                icb->request_q_address[0]  = LS_64BITS(ha->request_dma);
+                icb->request_q_address[1]  = MS_64BITS(ha->request_dma);
+                icb->response_q_address[0] = LS_64BITS(ha->response_dma);
+                icb->response_q_address[1] = MS_64BITS(ha->response_dma);
+
+                icb->lun_enables = 0;
+                icb->command_resource_count = 0;
+                icb->immediate_notify_resource_count = 0;
+                icb->timeout = 0;
+                icb->reserved_2 = 0;
+
+                ha->flags.nvram_config_done = 1;
+            }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                qla2100_print("qla2200_nvram_config: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            else
+                LEAVE("qla2200_nvram_config");
+#endif
+            return(status);
+}
+
+/*
+* Get NVRAM data word
+*      Calculates word position in NVRAM and calls request routine to
+*      get the word from NVRAM.
+*
+* Input:
+*      ha      = adapter block pointer.
+*      address = NVRAM word address.
+*
+* Returns:
+*      data word.
+*/
+STATIC uint16_t
+qla2100_get_nvram_word(scsi_qla_host_t *ha, uint32_t address) {
+            uint32_t nv_cmd;
+            uint16_t data;
+
+#ifdef QL_DEBUG_ROUTINES
+            uint8_t  saved_print_status = ql2x_debug_print;
+#endif
+#ifdef QL_DEBUG_LEVEL_4
+            qla2100_print("qla2100_get_nvram_word: entered\n");
+#endif
+
+            nv_cmd = address << 16;
+            nv_cmd |= NV_READ_OP;
+
+#ifdef QL_DEBUG_ROUTINES
+            ql2x_debug_print = FALSE;
+#endif
+            data = qla2100_nvram_request(ha, nv_cmd);
+#ifdef QL_DEBUG_ROUTINES
+            ql2x_debug_print = saved_print_status;
+#endif
+
+#ifdef QL_DEBUG_LEVEL_4
+            qla2100_print("qla2100_get_nvram_word: exiting normally NVRAM data = ");
+        qla2100_output_number((u_long)data, 16);
+            qla2100_print("\n");
+#endif
+            return(data);
+}
+
+/*
+* NVRAM request
+*      Sends read command to NVRAM and gets data from NVRAM.
+*
+* Input:
+*      ha     = adapter block pointer.
+*      nv_cmd = Bit 26     = start bit
+*               Bit 25, 24 = opcode
+*               Bit 23-16  = address
+*               Bit 15-0   = write data
+*
+* Returns:
+*      data word.
+*/
+STATIC uint16_t
+qla2100_nvram_request(scsi_qla_host_t *ha, uint32_t nv_cmd) {
+            uint8_t      cnt;
+            device_reg_t *reg = ha->iobase;
+            uint16_t     data = 0;
+            uint16_t     reg_data;
+
+            /* Send command to NVRAM. */
+
+            nv_cmd <<= 5;
+            for( cnt = 0; cnt < 11; cnt++ ) {
+                if( nv_cmd & BIT_31 )
+                    qla2100_nv_write(ha, NV_DATA_OUT);
+                else
+                    qla2100_nv_write(ha, 0);
+                nv_cmd <<= 1;
+            }
+
+            /* Read data from NVRAM. */
+
+            for( cnt = 0; cnt < 16; cnt++ ) {
+                WRT_REG_WORD(&reg->nvram, NV_SELECT+NV_CLOCK);
+                /* qla2100_nv_delay(ha); */
+                NVRAM_DELAY();
+                data <<= 1;
+                reg_data = RD_REG_WORD(&reg->nvram);
+                if( reg_data & NV_DATA_IN )
+                    data |= BIT_0;
+                WRT_REG_WORD(&reg->nvram, NV_SELECT);
+                /* qla2100_nv_delay(ha); */
+                NVRAM_DELAY();
+            }
+
+            /* Deselect chip. */
+
+            WRT_REG_WORD(&reg->nvram, NV_DESELECT);
+            /* qla2100_nv_delay(ha); */
+            NVRAM_DELAY();
+
+            return(data);
+}
+
+STATIC void
+qla2100_nv_write(scsi_qla_host_t *ha, uint16_t data) {
+            device_reg_t *reg = ha->iobase;
+
+            WRT_REG_WORD(&reg->nvram, data | NV_SELECT);
+            NVRAM_DELAY();
+            /* qla2100_nv_delay(ha); */
+            WRT_REG_WORD(&reg->nvram, data | NV_SELECT | NV_CLOCK);
+            /* qla2100_nv_delay(ha); */
+            NVRAM_DELAY();
+            WRT_REG_WORD(&reg->nvram, data | NV_SELECT);
+            /* qla2100_nv_delay(ha); */
+            NVRAM_DELAY();
+}
+
+STATIC void
+qla2100_nv_delay(void) {
+            SYS_DELAY(NV_DELAY_COUNT);
+}
+
+
+/*
+* Mailbox Command
+*      Issue mailbox command and waits for completion.
+*
+* Input:
+*      ha = adapter block pointer.
+*      mr = mailbox registers to load.
+*      mb = data pointer for mailbox registers.
+*
+* Output:
+*      mb[MAILBOX_REGISTER_COUNT] = returned mailbox data.
+*
+* Returns:
+*      0 = success
+*      1 = failed    (mbox status != 0x4000)
+*/
+STATIC uint8_t
+qla2100_mailbox_command(scsi_qla_host_t *ha, uint32_t mr, uint16_t *mb) {
+            device_reg_t     *reg       = ha->iobase;
+            device2300_reg_t *reg2300   = ha->iobase2300;
+            uint8_t      status = 0;
+            uint32_t     cnt;
+            uint16_t     *optr, *iptr;
+            uint16_t     data, command, intreq;
+            srb_t        *done_q_first = 0;
+            srb_t        *done_q_last = 0;
+            uint32_t     longdata = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_mailbox_command");
+#endif
+
+            /* Acquire interrupt specific lock */
+            QLA2100_INTR_LOCK(ha);
+
+            DRIVER_LOCK
+            ha->flags.mbox_busy = TRUE;
+
+#ifdef QL_DEBUG_LEVEL_5
+            sprintf(debug_buff,"scsi%d ",(int)ha->host_no);
+            qla2100_print(debug_buff);
+            qla2100_print("qla2100_mailbox_command: [[Start]] mbox_out[0] = ");
+            qla2100_output_number((u_long)*mb, 16);
+            qla2100_print("\n");  
+#endif
+            /* Load mailbox registers. */
+            if (ha->device_id != QLA2300_DEVICE_ID) 
+                optr = (uint16_t *)&reg->mailbox0;
+            else
+                optr = (uint16_t *)&reg2300->mailbox0;
+
+#ifdef QL_DEBUG_LEVEL_5
+            qla2100_print(
+            "qla2100_mailbox_command: Load MB word registers (displayed in bytes) = \n");
+            qla2100_dump_buffer((uint8_t *)mb, 16);
+            qla2100_print("\n");
+            qla2100_dump_buffer(((uint8_t *)mb + 0x10), 16);
+            qla2100_print("\n");
+            qla2100_dump_buffer(((uint8_t *)mb + 0x20), 8);
+            qla2100_print("\n");
+            qla2100_print("qla2100_mailbox_command: I/O address = ");
+            qla2100_output_number((u_long)optr, 16);
+            qla2100_print("\n");
+#endif
+            iptr = mb;
+            command = *(mb);
+            for( cnt = 0; cnt < MAILBOX_REGISTER_COUNT; cnt++ ) {
+                if( mr & BIT_0 ) {
+                    WRT_REG_WORD(optr, (*iptr));
+                }
+                mr >>= 1;
+                optr++;
+                iptr++;
+            }
+#ifdef QL_DEBUG_LEVEL_5
+            qla2100_dump_regs(ha->host);
+#endif
+
+            /* Issue set host interrupt command. */
+            ha->flags.mbox_int = FALSE;
+            WRT_REG_WORD(&reg->host_cmd, HC_SET_HOST_INT);
+
+            /* Wait for 30 seconds for command to finish.  */
+            if (ha->device_id == QLA2300_DEVICE_ID) 
+               data = qla2100_debounce_register((uint16_t *)&reg2300->host_status);
+            else data = qla2100_debounce_register(&reg->istatus);
+
+            cnt = 0x100000*2;   /* 22 secs */
+
+            for( ; cnt > 0 && !ha->flags.mbox_int; cnt-- ) {
+                /* Check for pending interrupts. */
+                if (ha->device_id == QLA2300_DEVICE_ID) {
+                   switch (*mb) { 
+                     case MBC_LOAD_RAM:
+                     case MBC_EXECUTE_FIRMWARE:
+                     case MBC_MAILBOX_REGISTER_TEST:
+                     case MBC_VERIFY_CHECKSUM:
+                     case MBC_ABOUT_FIRMWARE:
+                       /* handle ROM commands the old way */
+                       data     = RD_REG_WORD(&reg->istatus);
+                       intreq   = data & RISC_INT;
+                       break;
+                     default:
+                       /* handle non-ROM commands the new way */
+                       data     = RD_REG_WORD(&reg->istatus);
+                       longdata = RD_REG_DWORD(&reg2300->host_status);
+                       intreq   = longdata & RISC_2300_INT;
+                       break;
+                   }
+                } else {
+                   /* QLA2100 or QLA2200 */
+                   data     = RD_REG_WORD(&reg->istatus);
+                   intreq   = data & RISC_INT;
+                }
+                if ( intreq != 0 ) {
+                   qla2100_isr(ha,
+                              (srb_t **)&done_q_first,
+                              (srb_t **)&done_q_last); 
+                	/* udelay(10); */
+                }
+                udelay(10); /* v4.27 */
+            } /* for */
+
+            /* Check for mailbox command timeout. */
+            if( !cnt ) {
+#ifdef QL_DEBUG_LEVEL_2
+                qla2100_print(
+                "qla2100_mailbox_command: **** MB Command Timeout for cmd = ");
+                qla2100_output_number((u_long)mb[0], 16);
+                qla2100_print(" ****\n");
+                qla2100_print(
+                "qla2100_mailbox_command: **** icontrol = ");
+                qla2100_output_number(RD_REG_WORD(&reg->ictrl), 16);
+                qla2100_print(" ****\n");
+                qla2100_print(
+                "qla2100_mailbox_command: **** istatus = ");
+                qla2100_output_number((u_long)data, 16);
+                qla2100_print(" ****\n");
+                qla2100_print(
+                "qla2100_mailbox_command: **** chip mailbox[0] = ");
+                qla2100_output_number((u_long)RD_REG_WORD(optr), 16);
+                qla2100_print(" ****\n");
+                qla2100_dump_regs(ha->host);
+#endif
+                ha->flags.isp_abort_needed = TRUE;
+                qla2100_stats.mboxtout++;
+                status = 1;
+            } else if( ha->mailbox_out[0] != MBS_CMD_CMP ) {
+                qla2100_stats.mboxerr++;
+                status = 1;
+            }
+
+            /* Load return mailbox registers. */
+            optr = mb;
+            iptr = (uint16_t *)&ha->mailbox_out[0];
+
+            mr = MAILBOX_REGISTER_COUNT;
+            while( mr-- )
+                *optr++ = *iptr++;
+
+            /* Go check for any response interrupts pending. */
+            ha->flags.mbox_busy = FALSE;
+
+            qla2100_isr(ha,(srb_t **)&done_q_first,(srb_t **)&done_q_last); 
+
+            /* Release interrupt specific lock */
+            QLA2100_INTR_UNLOCK(ha);
+            DRIVER_UNLOCK
+
+            if( ha->flags.isp_abort_needed )
+                qla2100_abort_isp(ha);
+
+            if( ha->flags.reset_marker )
+                qla2100_rst_aen(ha);
+            if( ha->flags.update_config_needed )
+                qla2100_update_config(ha);
+            if( ha->flags.loop_resync_needed )
+                qla2100_loop_resync(ha);
+
+            if( done_q_first )
+                qla2100_done(ha, (srb_t **)&done_q_first, (srb_t **)&done_q_last);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+        if( status ) {
+            qla2100_print("qla2100_mailbox_command: **** FAILED, mailbox0 = ");
+            qla2100_output_number((u_long)mb[0], 16);
+            qla2100_print(" ****\n");
+        } else {
+/* DEBUG(qla2100_print("qla2100_mbc: Completed OK operation=");)
+DEBUG(qla2100_output_number((u_long)command, 16);)
+DEBUG(qla2100_print(" \n");)
+DEBUG(qla2100_print("qla2100_mbc: mailbox[1]=");)
+DEBUG(qla2100_output_number((u_long)mb[1], 16);)
+DEBUG(qla2100_print(" \n");)
+DEBUG(qla2100_print("mbc: +++ rsp_q_in= ");)
+DEBUG(qla2100_output_number(RD_REG_WORD(&ha->iobase2300->rsp_q_in), 16);)
+DEBUG(qla2100_print(" +++ \n");)
+DEBUG(qla2100_print("mbc: +++ rsp_q_out= ");)
+DEBUG(qla2100_output_number(RD_REG_WORD(&ha->iobase2300->rsp_q_out), 16);)
+DEBUG(qla2100_print(" +++ \n\n");)
+DEBUG(printk("qla2100_mbc: Completed OK operation=%x\n\n",command);) */
+        }
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_mailbox_command");
+#endif
+            return(status);
+}
+
+
+        /*
+        * qla2100_poll
+        *      Polls ISP for interrupts.
+        *
+        * Input:
+        *      ha = adapter block pointer.
+        */
+STATIC void
+qla2100_poll(scsi_qla_host_t *ha) {
+            device_reg_t     *reg       = ha->iobase;
+            device2300_reg_t *reg2300   = ha->iobase2300;
+            uint16_t     data;
+            srb_t        *done_q_first = 0;
+            srb_t        *done_q_last = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_poll");
+#endif
+
+            /* Acquire interrupt specific lock */
+            QLA2100_INTR_LOCK(ha);
+
+            /* Check for pending interrupts. */
+            if (ha->device_id == QLA2300_DEVICE_ID) 
+              data = qla2100_debounce_register((uint16_t *)&reg2300->host_status) &
+                     RISC_2300_INT;
+            else data = qla2100_debounce_register(&reg->istatus) & 
+                         RISC_INT;
+
+            /* Check for pending interrupts. */
+            if( data ) {
+                DEBUG(qla2100_print("qla2100_poll: Calling isr\n");)
+                qla2100_isr(ha, 
+                           (srb_t **)&done_q_first,
+                           (srb_t **)&done_q_last);
+            }
+
+            /* Release interrupt specific lock */
+            QLA2100_INTR_UNLOCK(ha);
+
+            if( !ha->flags.mbox_busy ) {
+                if( ha->flags.isp_abort_needed )
+                    qla2100_abort_isp(ha);
+                if( ha->flags.reset_marker )
+                    qla2100_rst_aen(ha);
+                if( ha->flags.update_config_needed )
+                    qla2100_update_config(ha);
+                if( ha->flags.loop_resync_needed )
+                    qla2100_loop_resync(ha);
+            }
+
+            if( done_q_first )
+                qla2100_done(ha, (srb_t **)&done_q_first, (srb_t **)&done_q_last);
+
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_poll");
+#endif
+}
+        
+/*
+* qla2100_find_host
+*      This routine searches the host adapter database 
+*      and return either TRUE or FALSE.
+*
+* Input:
+*      ha = adapter block pointer.
+*      device = device data pointer.
+*
+* Returns:
+*    TRUE - found
+*/
+STATIC uint8_t
+qla2100_find_host(scsi_qla_host_t *ha, device_data_t *device) {
+	fcdev_t  *pdb;
+	uint16_t cnt;
+ 
+	pdb = ha->phost_db;
+	for (cnt = 0; cnt < ha->host_db_ptr; cnt++) {
+		/* if nodename/portname in database */
+#if  USE_PORTNAME
+		if (BCMP(device->wwn, pdb[cnt].name, 8) == 0) {
+#else
+		if (BCMP(device->name, pdb[cnt].name, 8) == 0) {
+#endif
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+        
+/*
+* qla2100_update_host_data
+*      This routine updates the host device database 
+*
+* Input:
+*      ha = adapter block pointer.
+*      device = device data pointer.
+*
+* Returns:
+*      0 = success, if device found or added to database.
+*      1 = error
+*      2 = database was full and device was not configured.
+*/
+STATIC uint8_t
+qla2100_update_host_data(scsi_qla_host_t *ha, device_data_t *device,
+    uint8_t enable_slot_reuse)
+{
+	fcdev_t  *pdb;
+	uint8_t  status = 0;
+	uint8_t index;
+
+#ifdef QL_DEBUG_LEVEL_3
+	ENTER("qla2100_update_host");
+#endif
+ 
+	pdb = ha->phost_db;
+	index = ha->host_db_ptr;
+	if (index != MAX_HOST_COUNT) {
+		index++;
+#if  USE_PORTNAME
+		BCOPY(device->wwn, pdb[index].name, 8);
+#else
+		BCOPY(device->name, pdb[index].name, 8);
+#endif
+	} else if ( enable_slot_reuse ) {
+		index = 0;
+		printk(KERN_INFO "qla2100_update_host: Host table Full."
+		    " Overwriting slot 0.");
+#if  USE_PORTNAME
+		BCOPY(device->wwn, pdb[index].name, 8);
+#else
+		BCOPY(device->name, pdb[index].name, 8);
+#endif
+	} else {
+		printk(KERN_INFO "qla2100_update_host: Host table Full.");
+		status = 2;
+	}
+	ha->host_db_ptr = index;
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+	if( status )
+		qla2100_print("qla2100_update_host: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+	else
+		LEAVE("qla2100_update_host");
+#endif
+	return(status);
+
+}
+
+/*
+* qla2100_update_device_data
+*      This routine updates the device data in the database and logs
+*      onto the device if necessary.
+*
+* Input:
+*      ha = adapter block pointer.
+*      device = device data pointer.
+*
+* Returns:
+*      0 = success, if device found or added to database.
+*      1 = error
+*      2 = database was full and device was not configured.
+*/
+STATIC uint8_t
+qla2100_update_device_data(scsi_qla_host_t *ha, device_data_t *device, uint8_t enable_slot_reuse) {
+            uint8_t     status = 0;
+            uint8_t     hostflag = 0;
+            uint8_t     dev_configured;
+            uint16_t    cnt, i;
+            uint16_t    mb[MAILBOX_REGISTER_COUNT];
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_update_device");
+#endif
+
+            dev_configured = FALSE;
+            if( ha->device_id == QLA2100_DEVICE_ID ) {
+                ha->min_external_loopid = 1;       /* v2.19.5b3 */
+                ha->max_public_loop_ids = LAST_SNS_LOOP_ID - SNS_FIRST_LOOP_ID + 1;
+            } else {
+                ha->max_public_loop_ids = LAST_SNS_LOOP_ID + 1;
+            }
+
+            DEBUG(sprintf(debug_buff,
+	        "qla2100: Found device - portname=%02x%02x%02x%02x%02x%02x%02x%02x,"
+	        " nodename=%02x%02x%02x%02x%02x%02x%02x%02x,"
+	        " port Id=%06lx, loop id=%04x\n",
+	        device->wwn[0], device->wwn[1],
+	        device->wwn[2], device->wwn[3],
+	        device->wwn[4], device->wwn[5],
+	        device->wwn[6], device->wwn[7],
+	        device->name[0], device->name[1],
+	        device->name[2], device->name[3],
+	        device->name[4], device->name[5],
+	        device->name[6], device->name[7],
+	        device->port_id[0] << 16 | device->port_id[1] <<  8 | device->port_id[2], device->loop_id);)
+            DEBUG(qla2100_print(debug_buff);)
+
+             /* if we already login to the host adapter then skip it */
+            if ( qla2100_find_host(ha, device)  ) {
+               DEBUG(printk("update_db: Skipping host adapter..\n");)
+               return( status );
+            }
+            
+            /* Search to see if node name is already in database. If found then change loop ID in database. */
+            for( cnt = 0; cnt < MAX_FIBRE_DEVICES && !dev_configured; cnt++ ) {
+                /* if nodename/portname in database then replace it */
+#if  USE_PORTNAME  /* updated for ioctl merge */
+		if (BCMP(device->wwn, ha->fc_db[cnt].wwn, 8) == 0) {
+#else
+		if (BCMP(device->name, ha->fc_db[cnt].name, 8) == 0) {
+#endif
+                        ha->fc_db[cnt].flag &= ~DEV_MISSING;
+                        /* if device was configured by user then find and assign a loop ID for it */
+                        if( ha->fc_db[cnt].loop_id == PORT_AVAILABLE ) {
+                            DEBUG(qla2100_print("Port marked as already assigned.\n");)
+                            /* If device found is on the public loop. */
+                            /* then find the next available fabric loop ID */
+                            if( device->loop_id == 0xffff ) {
+                                status = 1;
+                                /* Search the public database for first available slot.  */
+                                for( i = ha->min_external_loopid; i < ha->max_public_loop_ids; i++ ) {
+                                    if( !ha->fabricid[i].in_use ) {
+                                        ha->fabricid[i].in_use = TRUE;
+                                        if( ha->device_id == QLA2100_DEVICE_ID )
+                                            device->loop_id = SNS_FIRST_LOOP_ID + i;
+                                        else
+                                            device->loop_id = i;
+                                        ha->fc_db[cnt].loop_id = device->loop_id;
+                                        ha->fc_db[cnt].port_id[0] = device->port_id[0];
+                                        ha->fc_db[cnt].port_id[1] = device->port_id[1];
+                                        ha->fc_db[cnt].port_id[2] = device->port_id[2];
+                                        ha->fc_db[cnt].flag |= DEV_PUBLIC;
+                                        status = 0;
+                                        break;
+                                    }
+                                } /* end of for */
+                            } else {  /* change the local loop ID in database */
+                                ha->fc_db[cnt].loop_id = device->loop_id;
+                            }
+                        } else /* loop id may have been previously used */
+                        {
+                            /* If device is on public loop. */
+                            if( device->loop_id == 0xffff ) {
+                                /* It was previously public, so use previously assigned loop id. */
+                                if( ha->fc_db[cnt].flag & DEV_PUBLIC )
+                                    if( ha->device_id == QLA2100_DEVICE_ID )
+                                        device->loop_id = ha->fc_db[cnt].loop_id;
+                                    else {
+                                        /* if the same topology and public loop */
+                                        /* search for the next avaiable public loop ID */
+                                        DEBUG(printk("update_db: topology prev %d, curr %d\n",
+                                        ha->prev_topology, ha->current_topology );)
+                                        if( ha->prev_topology == ha->current_topology ) {
+                                            if( (ha->min_external_loopid) &&
+                                            (ha->fc_db[cnt].loop_id < ha->min_external_loopid) ) {
+                                                status = 1;
+                                                /* find a loop ID for the Public device */
+                                                for( i = ha->min_external_loopid; i < ha->max_public_loop_ids; i++ )
+                                                    if( !ha->fabricid[i].in_use ) {
+                                                        ha->fabricid[i].in_use = TRUE;
+                                                        device->loop_id = i;
+                                                        ha->fc_db[cnt].loop_id = device->loop_id;
+                                                        status = 0;
+                                                        break;
+                                                    }
+                                            } else
+                                                device->loop_id = ha->fc_db[cnt].loop_id;
+                                        } else {
+                                            status = 1;
+                                            /* Find an unused loop ID */
+                                            for( i = ha->min_external_loopid; i < ha->max_public_loop_ids; i++ )
+                                                if( !ha->fabricid[i].in_use ) {
+                                                    ha->fabricid[i].in_use = TRUE;
+                                                    device->loop_id = i;
+                                                    ha->fc_db[cnt].loop_id = device->loop_id;
+                                                    status = 0;
+                                                    break;
+                                                }
+                                        }
+
+                                    } else {
+                                        /* If it moved from private to public loop, assign new public loop id. */
+                                        status = 1;
+                                            /* Find an unused loop ID */
+                                        for( i = ha->min_external_loopid; i < ha->max_public_loop_ids; i++ )
+                                            if( !ha->fabricid[i].in_use ) {
+                                                ha->fabricid[i].in_use = TRUE;
+                                                if( ha->device_id == QLA2100_DEVICE_ID )
+
+                                                    device->loop_id = SNS_FIRST_LOOP_ID + i;
+                                                else
+                                                    device->loop_id = i;
+                                                ha->fc_db[cnt].loop_id = device->loop_id;
+                                                ha->fc_db[cnt].flag |= DEV_PUBLIC;
+                                                ha->fc_db[cnt].port_id[0] = device->port_id[0];
+                                                ha->fc_db[cnt].port_id[1] = device->port_id[1];
+                                                ha->fc_db[cnt].port_id[2] = device->port_id[2];
+                                                status = 0;
+                                                break;
+                                            }
+                                    }
+                            } else {
+                                /* The found device is on private loop but was
+                                previously on public loop, so free public loop id. */
+                                if( ha->fc_db[cnt].flag & DEV_PUBLIC ) {
+                                    ha->fc_db[cnt].flag &= ~DEV_PUBLIC;
+                                    i = ha->fc_db[cnt].loop_id - SNS_FIRST_LOOP_ID;
+                                    ha->fabricid[i].in_use = 0;
+                                }
+                                ha->fc_db[cnt].loop_id = device->loop_id;
+                            }
+                        }
+                        
+                        /* If public device in database */
+                        if( !status && (ha->fc_db[cnt].flag) & DEV_PUBLIC ) {
+                        
+                            
+                            /* If public loop device, compare port id to see if
+                            device moves to another NL/N port. */
+                            if( ha->fc_db[cnt].port_id[0] != device->port_id[0] ||
+                            ha->fc_db[cnt].port_id[1] != device->port_id[1] ||
+                            ha->fc_db[cnt].port_id[2] != device->port_id[2] ) {
+                                if( ha->prev_topology == ha->current_topology ) {
+                                    /* Port id changed, log device out then log back
+                                    in with new port id but same loop id. */
+                                    mb[0] = MBC_LOGOUT_FABRIC_PORT;
+                                    mb[1] = ha->fc_db[cnt].loop_id << 8;
+                                    qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
+                                    ha->fc_db[cnt].port_id[0] = device->port_id[0];
+                                    ha->fc_db[cnt].port_id[1] = device->port_id[1];
+                                    ha->fc_db[cnt].port_id[2] = device->port_id[2];
+                                }
+                            }
+                            /*
+                            * Try and find a loop Id for the given
+                            * fabric port. We keep trying Ids until we find
+                            * a good one.
+                            */
+                            mb[0] = 0x4008;
+                            while( !status && mb[0] == 0x4008 ) {
+                            DEBUG(printk("update_db: Trying Fabric Login @ loop id= %d, port id= %06x\n", device->loop_id,device->port_id);)
+                                mb[0] = MBC_LOGIN_FABRIC_PORT;
+                                mb[1] = device->loop_id << 8 | 0x01;
+                                mb[2] = device->port_id[0];
+                                mb[3] = device->port_id[1] << 8 | device->port_id[2];
+                                qla2100_mailbox_command(ha, BIT_3|BIT_2|BIT_1|BIT_0,
+                                &mb[0]);
+                                /* Command parameter error or all IDS used */
+                                if ( mb[0] == 0x4006 || mb[0] == 0x4009 ) {
+                                    status = 1;
+                                    DEBUG(printk("update_db: (1) Failed Fabric login with Loop ID = %d\n", device->loop_id);)
+                                }
+                                /*
+                                * if loop Id is in use then try the next Id .
+                                */
+                                if( mb[0] == 0x4008 ) {
+                                    DEBUG(printk("update_db: Used Loop ID = %04x, port id=%06x - trying next id\n", device->loop_id,
+                                    ((mb[1] << 16) | (((mb[2] >>8 ) &0xff) << 8) | (mb[2] & 0xff)));)
+                                    if( device->loop_id++ <= LAST_SNS_LOOP_ID )
+                                        ha->fabricid[device->loop_id].in_use = TRUE;
+                                    else
+                                        status = 1;
+                                }
+                            }
+			    /* Login succuessful */
+                            if( !status ) {     
+                            	/* if different host */
+                                if( (mb[1] & 0x1) ) {     /* v2.19.05b3 */
+                                  DEBUG(printk("update_db: Warning -- Adapter found: port id=%06x, tgt=%d\n", 
+                                    ((mb[1] << 16) | (((mb[2] >>8 ) &0xff) << 8) | (mb[2] & 0xff)),cnt);)
+                                  qla2100_update_host_data(ha, device, enable_slot_reuse); 
+                                  ha->fabricid[device->loop_id].in_use = FALSE;
+                                  hostflag++;
+				} else {
+				  /* 4.31.8 update loop id in database */
+                               	  ha->fc_db[cnt].loop_id = device->loop_id;
+				}
+			    }
+#if 0
+                            /* Command error */
+                            if( !status && mb[0] != 0x4005 ) {
+                                /* Issue Abort target command to cause RISC to
+                                flush all commands outstanding for this device.
+                                Commands will be returned with "Aborted" status. */
+                                mb[0] = MBC_ABORT_TARGET;
+                                mb[1] = device->loop_id << 8;
+                                mb[2] = 1;
+                                status = qla2100_mailbox_command(ha, BIT_2|BIT_1|BIT_0, &mb[0]);
+                            }
+#endif
+                        }
+                        dev_configured = TRUE;
+                    }
+                }
+
+                /* Device not already in database so find */
+                /* an empty slot and loop id for it.      */
+                if( !dev_configured ) {
+                    DEBUG(printk("qla2100_db_update: New Device - not in database.\n");)
+
+                    /* If device is on public loop.        */
+                    /* First find an unused Fabric loop ID */
+                    /* then find a slot.                   */
+                    if( device->loop_id == 0xffff ) {
+                        status = 1;
+                        for( i = ha->min_external_loopid; i < ha->max_public_loop_ids; i++ ) {
+                            if( !ha->fabricid[i].in_use ) {
+                                ha->fabricid[i].in_use = TRUE;
+                                if( ha->device_id == QLA2100_DEVICE_ID )
+                                    device->loop_id = SNS_FIRST_LOOP_ID + i;
+                                else
+                                    device->loop_id = i;
+                                status = 0;
+                                break;
+                            }
+                        }
+                        /* Preset status to Loop ID used */
+                        mb[0] = 0x4008;
+                        /* Check to insure loop ID for fabric device is good */
+                        while( !status && mb[0] == 0x4008 ) {
+                            DEBUG(printk("update_db: Trying Fabric Login @ loop id %d\n", device->loop_id);)
+                            mb[0] = MBC_LOGIN_FABRIC_PORT;
+                            mb[1] = device->loop_id << 8 | 0x01;
+                            mb[2] = device->port_id[0];
+                            mb[3] = device->port_id[1] << 8 | device->port_id[2];
+                            qla2100_mailbox_command(ha, BIT_3|BIT_2|BIT_1|BIT_0, &mb[0]);
+                            if ( mb[0] == 0x4006 || mb[0] == 0x4009 ) {
+                                status = 1;
+                                DEBUG(printk("update_db: (2) Failed Fabric login with Loop ID = %d\n", device->loop_id);)
+                            }
+                            if( mb[0] == 0x4008 ) {
+                                DEBUG(printk("update_db: (2) Used Fabric Loop ID = %04x, port id=%06x\n", device->loop_id,
+                                ((mb[1] << 16) | (((mb[2] >>8 ) &0xff) << 8) | (mb[2] & 0xff)));)
+                                if( device->loop_id++ <= LAST_SNS_LOOP_ID ) 
+                                    ha->fabricid[device->loop_id].in_use = TRUE;  /* v2.19.05b3 */
+                                else
+                                    status = 1;
+                            }
+                            if( (mb[1] & 0x1) ) {     /* v2.19.05b3 */
+                               qla2100_update_host_data(ha, device, enable_slot_reuse); 
+                               DEBUG(printk("update_db: Adapter found: port id=%06x\n", 
+                                        (device->port_id[0] <<16) |
+                                        (device->port_id[1] << 8) | (device->port_id[2])) );
+                               ha->fabricid[device->loop_id].in_use = FALSE; 
+                               hostflag++;
+                            }
+                        }
+                    }
+                    /* Now find an empty slot for the device */
+                    if( !status && hostflag == 0 ) {
+                        if( ha->device_id == QLA2100_DEVICE_ID )
+                            ha->min_external_loopid = SNS_FIRST_LOOP_ID;
+                        /* Find a empty slot and add device into database. */
+                        for( i = 0; i < MAX_FIBRE_DEVICES; i++ )
+                            if( ha->fc_db[i].loop_id == PORT_UNUSED ) {
+                                ha->fc_db[i].flag &= ~DEV_MISSING;
+	
+                                /* get and set both wwnn and wwpn */
+                                BCOPY(device->name, ha->fc_db[i].name, 8);
+                                BCOPY(device->wwn, ha->fc_db[i].wwn, 8);
+
+                                ha->fc_db[i].loop_id = device->loop_id;
+                                if( device->loop_id >= ha->min_external_loopid ) {
+                                    ha->fc_db[i].flag |= DEV_PUBLIC;
+                                    ha->fc_db[i].port_id[0] = device->port_id[0];
+                                    ha->fc_db[i].port_id[1] = device->port_id[1];
+                                    ha->fc_db[i].port_id[2] = device->port_id[2];
+                                }
+                                ha->flags.updated_fc_db = TRUE;
+                                dev_configured = TRUE;
+                                break;
+                            }
+                            if( !dev_configured ) {
+                                if( enable_slot_reuse ) {
+                                    for( i = 0; i < MAX_FIBRE_DEVICES; i++ )
+                                        if( ha->fc_db[i].loop_id == PORT_AVAILABLE ) {
+                                            ha->fc_db[i].flag &= ~DEV_MISSING;
+#if  USE_PORTNAME  /* ioctl support change */
+                                            BCOPY(device->wwn, ha->fc_db[i].wwn, 8);
+#else
+                                            BCOPY(device->name, ha->fc_db[i].name, 8);
+#endif
+                                            ha->fc_db[i].loop_id = device->loop_id;
+                                            if( device->loop_id >= ha->min_external_loopid ) {
+                                                ha->fc_db[i].flag |= DEV_PUBLIC;
+                                                ha->fc_db[i].port_id[0] = device->port_id[0];
+                                                ha->fc_db[i].port_id[1] = device->port_id[1];
+                                                ha->fc_db[i].port_id[2] = device->port_id[2];
+                                            }
+                                            ha->flags.updated_fc_db = TRUE;
+                                            break;
+                                        }
+                                } else {
+                                    ha->fabricid[device->loop_id].in_use = FALSE;
+                                    status = 2;
+                                }
+
+                            }
+
+                    }
+                }
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2100_update_device: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_update_device");
+#endif
+                return(status);
+            }
+
+/*
+* qla2100_sns_device
+*      Setup Simple Name Server devices with loop ID's.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*      1 = error
+*      2 = database was full and device was not configured.
+*/
+STATIC uint8_t
+qla2100_sns_device(scsi_qla_host_t *ha, uint8_t enable_slot_reuse) {
+                uint8_t     status = 1;
+                uint8_t     first_port_id[3];
+                uint8_t     next_port_id[3];
+                uint8_t     host_port_id[3];
+                sns_data_t  *sns;
+#if BITS_PER_LONG > 32
+                uint64_t    phys_address = 0;
+#else
+                uint32_t    phys_address = 0;
+#endif
+                uint16_t    mb[MAILBOX_REGISTER_COUNT];
+                uint8_t     use_gan = 1;
+                uint8_t     retry_count = 0;
+                gp_idnn_t   *gp_idnn;
+                uint16_t    i;
+                device_data_t device;
+                uint8_t     db_full = 0;
+                uint16_t    public_count;
+                uint32_t    fabric_devices = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_sns_device");
+#endif
+
+                /* If FL port exists, then SNS is present */
+                DEBUG(printk("qla2100_sns_device: Checking for Fabric.\n");)
+                mb[0] = MBC_GET_PORT_NAME;
+                mb[1] = SNS_FL_PORT << 8;  /* port name */
+                if( !qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]) ) {
+
+#ifdef RCSN
+                    /* Mark devices that need re-synchronization. */
+                    qla2100_device_resync(ha);
+#endif
+
+                    /* Fl port is present */
+                    host_port_id[0] = ha->port_id[0];
+                    host_port_id[1] = ha->port_id[1];
+                    host_port_id[2] = ha->port_id[2];
+
+                    /* Calculate the max number of public ports */
+                    if( ha->device_id == QLA2100_DEVICE_ID )
+                        public_count = ha->max_public_loop_ids;
+                    else
+                        public_count = ha->max_public_loop_ids - ha->min_external_loopid;
+
+                    /* Register with name server as type fc4 device */
+
+#ifdef FC_IP_SUPPORT
+                    /* Register with name server as type 5 device */
+                    if (ha->flags.enable_ip == TRUE) {
+                        qla2x00_register_ip_device(ha);
+                    }
+
+                    /* If IP enable, skip GP_IDNN and just use GAN */
+                    if (ha->flags.enable_ip == TRUE)
+                        goto tryGan;
+#endif /* FC_IP_SUPPORT */
+
+                    /* Find out if this is a Brocade switch, if so do GP_IDNN. */
+                    /* otherwise use the GAN                                   */
+                    mb[0] = MBC_GET_PORT_NAME;
+                    mb[1] = SNS_FL_PORT << 8 | BIT_0;   /* node name */
+                    qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
+                    if( mb[2] == 0x0010 && mb[3] == 0x6000 &&
+                    (mb[6] & 0x00FF) == 0x0069 ) {
+/* 4.10 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                        gp_idnn = KMALLOC(GP_IDNN_LENGTH);
+                        if ( gp_idnn != NULL ) {
+                            phys_address = VIRT_TO_BUS(gp_idnn);
+                            BZERO((caddr_t)gp_idnn, GP_IDNN_LENGTH);
+                        }
+#else
+                        gp_idnn  = pci_alloc_consistent(ha->pdev,
+                                                        GP_IDNN_LENGTH,
+                                                        &phys_address);
+                        BZERO((caddr_t)gp_idnn, GP_IDNN_LENGTH);
+#endif
+                        if ( gp_idnn != NULL ) {
+                            /* Retry GP_IDNN til valid list or retries done */
+                            while( retry_count++ < 10 ) {
+                                /*
+                                * Issue GP_IDNN to get list of port IDs and
+                                * node names from name server.
+                                */
+                                gp_idnn->req.buffer_length = GP_IDNN_LENGTH/2;
+                                /* 4.10 */
+                                gp_idnn->req.buffer_address[0] = 
+                                  LS_64BITS(phys_address);
+                                gp_idnn->req.buffer_address[1] = 
+                                  MS_64BITS(phys_address);
+                                gp_idnn->req.subcommand_length = 6;
+                                gp_idnn->req.subcommand = 0x173;
+                                gp_idnn->req.length = GP_IDNN_LENGTH / 4;
+                                gp_idnn->req.protocol = 0x08;
+
+                                mb[0] = MBC_SEND_SNS_COMMAND;
+                                mb[1] = 14;
+                                mb[3] = LSW(phys_address);
+                                mb[2] = MSW(phys_address);
+                                mb[7] = QL21_64BITS_3RDWD(phys_address);
+                                mb[6] = QL21_64BITS_4THWD(phys_address);
+                                if( !qla2100_mailbox_command(ha,
+                                BIT_7|BIT_6|BIT_3|BIT_2|BIT_1|BIT_0,
+                                &mb[0]) ) {
+                                    if( gp_idnn->rsp.response == SNS_ACCEPT ) {
+                                        DEBUG3(printk("Sns: Get all Fabric devices:\n");)
+                                        /* Go down device list and add devices to database. */
+                                        for( i = 0; i < public_count; i++ ) {
+                                            /* if not host port id then add it to the database */
+                                            if( gp_idnn->rsp.port_data[i].port_id[0] != host_port_id[0] ||
+                                            gp_idnn->rsp.port_data[i].port_id[1] != host_port_id[1] ||
+                                            gp_idnn->rsp.port_data[i].port_id[2] != host_port_id[2] ) {
+						BCOPY(gp_idnn->rsp.port_data[i].nodename, device.name, 8);
+                                                /* get loop id */
+                                                device.port_id[0] = gp_idnn->rsp.port_data[i].port_id[0];
+                                                device.port_id[1] = gp_idnn->rsp.port_data[i].port_id[1];
+                                                device.port_id[2] = gp_idnn->rsp.port_data[i].port_id[2];
+#if USE_PORTNAME
+                                                /* Get portname */
+                                                if( qla2100_sns_get_name(ha, &device, 0) ) {
+                                                    status =  1;  /* v2.19.5b4 */
+                                                    break;
+						}
+#endif
+                                                device.loop_id = 0xffff;
+                                                /* Update device database and login to device. */
+                                                fabric_devices++;
+                                                if( (status = qla2100_update_device_data(ha, &device, enable_slot_reuse)) ) {
+                                                    if( status == 2 )
+                                                        db_full = 1;
+                                                    else
+                                                        break;
+                                                }
+                                            }
+                                            if( gp_idnn->rsp.port_data[i].controlbyte == 0x80 )
+                                                break;
+                                        }
+                                        use_gan = 0;
+                                        break;
+                                    }
+                                }
+                                /* Wait for 100ms before retrying */
+                                for( i = 0; i <= 10000; i++ ) {
+                                    udelay(10);
+                                }
+                            }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                            KMFREE(gp_idnn, GP_IDNN_LENGTH);
+#else
+                            pci_free_consistent(ha->pdev, GP_IDNN_LENGTH,
+                                   gp_idnn, phys_address);
+#endif
+                        } else {
+                            use_gan = 0;
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_sns_device: Failed to allocate memory, No FL Port\n");
+#endif
+                        }
+                    }
+                    /* Use the GAN (GA_NXT) Name server request to discover the ports  */
+
+                    /*
+                    *	Go through GAN list to find all fabric devices.  Will perform
+                    *	necessary logout of previously existed devices that have changed
+                    *	and save new devices in a new device list.
+                    *
+                    */
+
+                    if( use_gan ) {
+#ifdef FC_IP_SUPPORT
+                        tryGan:
+#endif
+
+                        /* Find all registered ports in the Fabric */
+/* 4.10 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                        sns = KMALLOC(sizeof(sns_data_t));
+                        if ( sns != NULL ) {
+                            phys_address = VIRT_TO_BUS(sns);
+                            BZERO((caddr_t)sns, sizeof(sns_data_t));
+                        }
+#else
+                        sns  = pci_alloc_consistent(ha->pdev,
+                                                    sizeof(sns_data_t),
+                                                    &phys_address);
+                        BZERO((caddr_t)sns, sizeof(sns_data_t));
+#endif
+                        if ( sns != NULL ) {
+                            DEBUG(printk("qla2100_sns_device: Performing a GAN (%d)\n",public_count);)
+                            status = 0;
+                            /* start with port ID = 0 */
+                            first_port_id[0] = first_port_id[1] = first_port_id[2] = 0;
+                            next_port_id[0] = next_port_id[1] = next_port_id[2] = 0;
+                            mb[0] = 0;
+                            for( i = 0; i < public_count && !ha->loop_down_timer &&
+                            !ha->flags.loop_resync_needed; i++ ) {
+                                /* GAN Get all next entries for the selected port ID from SNS. */
+                                BZERO((caddr_t)sns, sizeof(sns_data_t));
+                                sns->p.req.hdr.buffer_length = 318; /*304*/
+                                sns->p.req.hdr.buffer_address[0] = 
+                                    LS_64BITS(phys_address);
+                                sns->p.req.hdr.buffer_address[1] = 
+                                    MS_64BITS(phys_address);
+                                sns->p.req.hdr.subcommand_length = 6;
+                                sns->p.req.subcommand = 0x100;
+                                sns->p.req.param[6] = next_port_id[2];
+                                sns->p.req.param[7] = next_port_id[1];
+                                sns->p.req.param[8] = next_port_id[0];
+
+                                mb[0] = MBC_SEND_SNS_COMMAND;
+                                mb[1] = 14;
+                                mb[3] = LSW(phys_address);
+                                mb[2] = MSW(phys_address);
+                                mb[7] = QL21_64BITS_3RDWD(phys_address);
+                                mb[6] = QL21_64BITS_4THWD(phys_address);
+                                if( !qla2100_mailbox_command(ha,
+                                     BIT_7|BIT_6|BIT_3|BIT_2|BIT_1|BIT_0,
+                                     &mb[0])  ) {
+                                    if( sns->p.rsp[8] != 0x80 ||  /* SNS_ACCEPT */
+                                        sns->p.rsp[9] != 0x02   ) { /* 04/18/00 */
+                                    printk(KERN_INFO "qla2100_sns_device: SEND_SNS_COMMAND Failed - 0x%2x%2x mb_res=%x\n",
+                                            sns->p.rsp[8],sns->p.rsp[9],mb[0]);
+                                       status = 1;
+                                       break;
+                                    }
+                                    /* save next port ID */
+                                    next_port_id[0] = sns->p.rsp[17];
+                                    next_port_id[1] = sns->p.rsp[18];
+                                    next_port_id[2] = sns->p.rsp[19];
+
+                                } else {
+#ifdef QL_DEBUG_LEVEL_2
+                                    qla2100_print(
+                                    "qla2100_sns_device: MBC_SEND_SNS_COMMAND Failed, No FL Port\n");
+#endif
+                                    /* v2.19.5 */
+                            	   DEBUG(printk("qla2100_sns_device: Failed Performing a GAN mb0=0x%x, mb1=0x%x\n",
+                                         mb[0],mb[1]);)
+                                    status = 1;
+                                    break;
+                                }
+
+                                /* Assign loop ID for device on SNS. */
+                                if( (next_port_id[0] != first_port_id[0] ||
+                                next_port_id[1] != first_port_id[1] ||
+                                next_port_id[2] != first_port_id[2])
+                                &&  (sns->p.rsp[284] || sns->p.rsp[285] ||
+                                sns->p.rsp[286] || sns->p.rsp[287] ||
+                                sns->p.rsp[288] || sns->p.rsp[289] ||
+                                sns->p.rsp[290] || sns->p.rsp[291]) ) {
+                                    /* if port Id local loop skip this ID  */
+                                    if( next_port_id[0] != host_port_id[0] ||
+                                    next_port_id[1] != host_port_id[1] ||
+                                    next_port_id[2] != host_port_id[2] ) {
+#if USE_PORTNAME
+                                        /* Extract portname */
+					BCOPY(&sns->p.rsp[20], device.wwn, 8);
+#endif
+                                        /* Extract nodename */
+					BCOPY(&sns->p.rsp[284], device.name, 8);
+                                        /* extract port ID */
+                                        device.port_id[0] = next_port_id[0];
+                                        device.port_id[1] = next_port_id[1];
+                                        device.port_id[2] = next_port_id[2];
+                                        device.loop_id = 0xffff;
+
+                                        /* Update device database and login device in */
+
+                                        /* if McData, skip all port types except 1 (N_port) & 2 (NL_port) */
+                                        if ( !( (sns->p.rsp[16] == 0x01) ||
+                                        (sns->p.rsp[16] == 0x02)    ) ) {
+                                            DEBUG(printk("qla2100_sns_device: Skipping port type %x\n", sns->p.rsp[16]);)
+                                        }
+
+#ifdef FC_IP_SUPPORT
+                                        else if (sns->p.rsp[579] & 0x20) {
+                                            fabric_devices++;
+                                            /* Update IP device */
+                                            if (qla2x00_update_ip_device_data(ha, &device) == QL_STATUS_FATAL_ERROR) {
+                                                status = 1;
+                                                break;
+                                            }
+                                            /* Update SCSI device */
+                                        }
+#endif
+                                        else {
+                                            fabric_devices++;
+                                            if( (status = qla2100_update_device_data(ha, &device, enable_slot_reuse)) ) {
+                                                if( status == 2 )
+                                                    db_full = 1;
+                                                break;
+                                            }
+                                        }
+#ifdef FC_IP_SUPPORT
+                                    }
+#endif
+                                }
+
+                                /*
+                                * Save first port if not repeating port
+                                * on another Loop ID.
+                                */
+                                if( !(first_port_id[0] || first_port_id[1] ||
+                                first_port_id[2]) ) {
+                                    first_port_id[0] = next_port_id[0];
+                                    first_port_id[1] = next_port_id[1];
+                                    first_port_id[2] = next_port_id[2];
+                                }
+                            } else
+                                break;
+                        }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                        KMFREE(sns, sizeof(sns_data_t));
+#else
+                        pci_free_consistent(ha->pdev, sizeof(sns_data_t),
+                                   sns, phys_address);
+#endif
+
+                    }
+#ifdef QL_DEBUG_LEVEL_2
+                    else
+                        qla2100_print(
+                        "qla2100_sns_device: Failed to allocate memory, No FL Port\n");
+#endif
+                }
+            } else
+#ifdef QL_DEBUG_LEVEL_2
+                qla2100_print(
+                "qla2100_sns_device: MBC_GET_PORT_NAME Failed, No FL Port\n");
+#else
+            DEBUG(printk("No Fabric found.\n");)
+#endif
+
+            if( fabric_devices >  0)
+              ha->device_flags |= DFLG_FABRIC_DEVICES;
+
+            if( db_full )
+                status = 2;
+
+            /* Update iff F/FL found and update O.K. */
+            if( !status )
+                ha->prev_topology = ha->current_topology;
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+            if( status )
+                qla2100_print("qla2100_sns_device: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+            else
+                LEAVE("qla2100_sns_device");
+#endif
+            return(status);
+}
+
+#if USE_PORTNAME
+/*
+* qla2100_sns_get_name
+*      This routine is called tot do the SNS Get Port/Name command
+*      of the specified port.
+*
+* Input:
+*      ha = adapter block pointer.
+*      flag = 0 - port name , 1 - node name
+*
+* Output:
+*
+*/
+STATIC uint8_t qla2100_sns_get_name( scsi_qla_host_t *ha, device_data_t *device, uint8_t flag ) {
+            uint8_t     lStatus = 0;
+            uint16_t    wRetryCount;
+#if BITS_PER_LONG > 32
+            uint64_t    phys_address = 0;
+#else
+            uint32_t    phys_address = 0;
+#endif
+            uint16_t    mb[MAILBOX_REGISTER_COUNT];
+            uint16_t    subCmd, response;
+            sns_data_t  *sns;
+
+            /* Set retry count */
+            if ( flag )
+                subCmd = 0x113;
+            else
+                subCmd = 0x112;
+            DEBUG2(printk("qla2100_SnsGetName: Get opcode %x - name for port Id %06x\n", subCmd,
+            (uint32_t)(device->port_id[0] << 16 | device->port_id[1] <<  8 | device->port_id[2]));)
+
+            wRetryCount = 2;
+            while (wRetryCount--) {
+                /* Do 'Get Port/Node name' mailbox command for the FL attached device */
+/* 4.10 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                sns = KMALLOC(sizeof(sns_data_t));
+                if ( sns != NULL ) {
+                     phys_address = VIRT_TO_BUS(sns);
+                     BZERO((caddr_t)sns, sizeof(sns_data_t));
+                }
+#else
+                sns  = pci_alloc_consistent(ha->pdev,
+                                            sizeof(sns_data_t),
+                                            &phys_address);
+                BZERO((caddr_t)sns, sizeof(sns_data_t));
+#endif
+                if ( sns != NULL ) {
+                    BZERO((caddr_t)sns, sizeof(sns_data_t));
+                    sns->p.req.hdr.buffer_length = 12;
+                    /* 4.10 */
+                    sns->p.req.hdr.buffer_address[0] = 
+                       LS_64BITS(phys_address);
+                    sns->p.req.hdr.buffer_address[1] = 
+                       MS_64BITS(phys_address);
+                    sns->p.req.hdr.subcommand_length = 6;
+                    sns->p.req.subcommand = subCmd;
+                    sns->p.req.param[6] = device->port_id[2];
+                    sns->p.req.param[7] = device->port_id[1];
+                    sns->p.req.param[8] = device->port_id[0];
+                    sns->p.req.param[9] = 0;
+
+                    mb[0] = MBC_SEND_SNS_COMMAND;
+                    mb[1] = 14;
+                    mb[3] = LSW(phys_address);
+                    mb[2] = MSW(phys_address);
+                    mb[7] = QL21_64BITS_3RDWD(phys_address);
+                    mb[6] = QL21_64BITS_4THWD(phys_address);
+                    if( !qla2100_mailbox_command(ha,
+                    BIT_7|BIT_6|BIT_3|BIT_2|BIT_1|BIT_0,
+                    &mb[0]) ) {
+
+                        response = sns->p.rsp[8] | (sns->p.rsp[9] << 8);
+                        if( response == SNS_ACCEPT ) {
+                            if ( flag ) {
+				BCOPY(&sns->p.rsp[16], device->name, 8);
+                            } else {
+				BCOPY(&sns->p.rsp[16], device->wwn, 8);
+                            }
+                        } else {
+                            printk(KERN_WARNING "qla2100_SnsGetName: [ERROR] Get Name mb cmd response is not accept - status %x\n", mb[0]);
+                        }
+                    } else if (mb[0] == MBS_FATAL_ERROR) {
+                        printk(KERN_WARNING "qla2100_SnsGetName: [ERROR] Get Name mb cmd fatal error - status %x\n", mb[0]);
+                        lStatus = 1;
+                        break;
+                    } else {
+                        printk(KERN_WARNING "qla2100_SnsGetName: [ERROR] Get Name mb cmd failed - status %x\n", mb[0]);
+                    }
+
+                }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                KMFREE(sns, sizeof(sns_data_t));
+#else
+                pci_free_consistent(ha->pdev, sizeof(sns_data_t),
+                                    sns, phys_address);
+#endif
+            }
+            return(lStatus);
+
+}
+#endif
+
+/*
+* qla2100_init_fc_db
+*      Initializes Fibre Channel Device Database.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Output:
+*      ha->fc_db = initialized
+*/
+STATIC void
+qla2100_init_fc_db(scsi_qla_host_t *ha) {
+            uint16_t cnt;
+
+#ifdef QL_DEBUG_LEVEL_3
+            ENTER("qla2100_init_fc_db");
+#endif
+
+            /* Initialize fc database if it is not initialized. */
+            if( !ha->fc_db[0].loop_id && !ha->fc_db[1].loop_id ) {
+                ha->flags.updated_fc_db = FALSE;
+
+                /* Initialize target database. */
+                for( cnt = 0; cnt < MAX_FIBRE_DEVICES; cnt++ ) {
+                    ha->fc_db[cnt].name[0] = 0L;
+                    ha->fc_db[cnt].name[1] = 0L;
+                    ha->fc_db[cnt].loop_id = PORT_UNUSED;
+                    ha->fc_db[cnt].port_login_retry_count = 8;
+                    ha->fc_db[cnt].flag = 0;   /* v2.19.5b3 */
+                    ha->fc_db[cnt].port_timer = 0;   /* v2.19.8 */
+                }
+
+#if USE_FLASH
+                /* Move flash database to driver database. */
+                qla2100_get_database(ha);
+#endif
+            }
+
+#ifdef QL_DEBUG_LEVEL_3
+            LEAVE("qla2100_init_fc_db");
+#endif
+}
+
+/*
+* qla2100_configure_fabric
+*	Setup fabric devices with loop ID's.
+*
+* Input:
+*	ha = adapter block pointer.
+*	enable_slot_reuse = allows the use of PORT_AVAILABLE slots.
+*
+* Returns:
+*	0 = success.
+*	1 = error.
+*	2 = database was full and a device was not configured.
+*
+* Context:
+*	Kernel context.
+*/
+STATIC uint8_t
+qla2100_configure_fabric(scsi_qla_host_t *ha, 
+    uint8_t enable_slot_reuse)
+{
+            uint8_t  status = 0;
+            uint16_t    i;
+
+            /* get public loop devices */
+            if( !ha->loop_down_timer && !ha->flags.loop_resync_needed ){
+               /* Configure loop */
+               if( !qla2100_configure_hba(ha) ) {
+                   if( ha->device_id == QLA2100_DEVICE_ID ) {
+                       ha->max_public_loop_ids = LAST_SNS_LOOP_ID - SNS_FIRST_LOOP_ID + 1;
+                   } else {
+                       ha->max_public_loop_ids = LAST_SNS_LOOP_ID + 1;
+                        /* dg 09/15 */
+                        /* if the topology have change then make all devices available */
+                        if( ha->prev_topology != ha->current_topology ) {
+                            /* Mark all fabric devices that where present as AVAILABLE */
+                            for( i = 0; i < ha->max_public_loop_ids; i++ )
+                                if( (i != SNS_FL_PORT) && (i != FABRIC_CONTROLLER)
+                                && (i != SIMPLE_NAME_SERVER) )
+                                    ha->fabricid[i].in_use = FALSE;
+                        }
+                }
+                status = qla2100_sns_device(ha, enable_slot_reuse);
+                qla2100_restart_queues(ha,TRUE);
+            }
+            status = 1;
+        }
+        return( status );
+}
+
+/*
+* qla2100_check_devices
+*	Check devices with loop ID's.
+*
+* Input:
+*	ha = adapter block pointer.
+*
+* Returns:
+*	0 = success.
+*   1 = retry needed
+*
+* Context:
+*	Kernel context.
+*/
+STATIC uint8_t
+qla2100_check_devices(scsi_qla_host_t *ha) {
+            int cnt;
+            uint8_t  ret = 0;
+            uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+            /*
+            * Retry any devices that wasn't found but as a WWN.
+            */
+            /* v2.19.05b6 */
+            for( cnt = 0; cnt < MAX_FIBRE_DEVICES; cnt++ ) {
+                    if( (ha->fc_db[cnt].flag & DEV_MISSING) &&
+                       !(ha->fc_db[cnt].flag & DEV_OFFLINE) ) {
+                        /*
+                        * This dev was not detected but its WWN
+                        * is valid. To handle the case where
+                        * the switch may not be giving us the
+                        * device list correctly, schedule for
+                        * a login retry later if not previously
+                        * done so.
+                        */
+                        DEBUG(printk("qla2100_sns:Port login retry - target %d, count=%d\n",cnt, 
+                                        ha->fc_db[cnt].port_login_retry_count); )
+                        if( ha->fc_db[cnt].port_login_retry_count )
+                          ha->fc_db[cnt].port_login_retry_count--;
+
+                        /*
+                        * If after decrement the retry count
+                        * becomes 0, mark this device OFFLINE so
+                        * no more retries will be done based
+                        * on this device.
+                        */
+                        if (ha->fc_db[cnt].port_login_retry_count == 0) {
+                            DEBUG(printk("qla2100_sns:Port set to OFFLINE - target %d\n",cnt); )
+                            ha->fc_db[cnt].flag |= DEV_OFFLINE;
+                        }
+                        ret = 1;
+                    }
+               }
+
+                /*
+                * Mark devices as DEV_MISSING if they were present
+                * before and have a loop ID.
+                */
+                for( cnt = 0; cnt < MAX_FIBRE_DEVICES &&
+                    !ha->loop_down_timer &&
+                    !ha->flags.loop_resync_needed; cnt++ ) {
+                    /* if this slot is used (i.e. loop ID 0 - 0xfe) */
+                    if( ha->fc_db[cnt].loop_id <= LAST_SNS_LOOP_ID ) {
+                        /* Get port name */
+                        mb[0] = MBC_GET_PORT_NAME;
+                        mb[1] = ha->fc_db[cnt].loop_id << 8 | BIT_0;
+                        if( qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]) ) {
+                            /* Flag as missing only once */
+                            if ( !(ha->fc_db[cnt].flag & DEV_MISSING) ) {
+                               if ( ha->fc_db[cnt].port_login_retry_count ) {  /* v2.19.05b3 */
+                                  ha->fc_db[cnt].port_login_retry_count--;
+                                  ha->fc_db[cnt].flag |= DEV_MISSING;
+                                  DEBUG(printk("qla2100_sns: Missing port %d @ loop ID: %x\n",
+                                     cnt, ha->fc_db[cnt].loop_id);)
+                                  ret++;
+                               }
+                            } 
+                        } else if (ha->fc_db[cnt].flag & DEV_MISSING) {
+                             ha->fc_db[cnt].flag &= ~DEV_MISSING;
+                             ha->fc_db[cnt].flag &= ~DEV_OFFLINE;
+                             ha->fc_db[cnt].flag |= DEV_RETURN;
+                             ha->fc_db[cnt].port_login_retry_count = 8;
+                             DEBUG(printk("qla2100_sns: Device %d returned\n", cnt);)
+                        } 
+                      }
+                }
+                return( ret );
+}
+
+/*
+* qla2100_update_fc_db
+*      Updates Fibre Channel Device Database with what is actually on loop.
+*
+* Input:
+*      ha                = adapter block pointer.
+*      enable_slot_reuse = allows the use of PORT_AVAILABLE slots.
+*
+* Output:
+*      ha->fc_db = updated
+*
+* Returns:
+*      0 = success.
+*      1 = error.
+*      2 = database was full and device was not configured.
+*/
+STATIC uint8_t
+qla2100_update_fc_db(scsi_qla_host_t *ha, uint8_t enable_slot_reuse) {
+	uint8_t  status = 0;
+	uint8_t  ret = 0;
+	uint8_t  db_full = 0;
+	uint16_t cnt;
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	port_list_entry_t *gn_list, *port_entry;
+	device_data_t device;
+#if BITS_PER_LONG > 32
+	uint64_t    phys_address = 0;
+#else
+	uint32_t    phys_address = 0;
+#endif
+	uint16_t i, size;
+	uint16_t localdevices = 0;
+	int retry_needed = 0;
+	
+#ifdef FC_IP_SUPPORT
+	PIP_DEVICE_BLOCK    pIpDevice;
+#endif
+
+
+#ifdef QL_DEBUG_LEVEL_3
+	ENTER("qla2100_update_fc_db");
+#endif
+
+	/* Configure loop */
+	if( !qla2100_configure_hba(ha) ) {
+	    if( ha->device_id == QLA2100_DEVICE_ID ) {
+	        ha->max_public_loop_ids = LAST_SNS_LOOP_ID - SNS_FIRST_LOOP_ID + 1;
+	    } else {
+	        ha->max_public_loop_ids = LAST_SNS_LOOP_ID + 1;
+	        /* dg 09/15 */
+	        /* if the topology have change then make all devices available */
+	        if( ha->prev_topology != ha->current_topology ) {
+	            /* Mark all fabric devices that where present as AVAILABLE */
+	            for( i = 0; i < ha->max_public_loop_ids; i++ )
+	                if( (i != SNS_FL_PORT) && (i != FABRIC_CONTROLLER)
+	                && (i != SIMPLE_NAME_SERVER) )
+	                    ha->fabricid[i].in_use = FALSE;
+
+	                /* Mark all local devices that where present as AVAILABLE */
+	                if( ha->current_topology == ISP_CFG_F )
+	                    for( cnt = 0; cnt < MAX_FIBRE_DEVICES && !ha->loop_down_timer
+	                    && !ha->flags.loop_resync_needed; cnt++ )
+	                        if( ha->fc_db[cnt].loop_id < SNS_FIRST_LOOP_ID ) {
+	                            ha->fc_db[cnt].loop_id = PORT_AVAILABLE;
+	                            ha->fc_db[cnt].flag &= ~DEV_PUBLIC;
+	                        }
+	        }
+	    }
+	    /* v2.19.03 - Mark all devices missing if configured */
+	    for( cnt = 0; cnt < MAX_FIBRE_DEVICES; cnt++ )
+	             if( ha->fc_db[cnt].flag & DEV_CONFIGURED)
+	                ha->fc_db[cnt].flag |= DEV_MISSING;
+	
+#ifdef FC_IP_SUPPORT
+	    /* Disable all IP devices in linked list */
+	    for (pIpDevice = ha->pIpDeviceTop; pIpDevice != NULL;
+	      pIpDevice = pIpDevice->pNextIpDevice) {
+	        pIpDevice->lDeviceFlags &= ~IP_DEV_FLAG_PRESENT;
+	    }
+#endif /* FC_IP_SUPPORT */
+
+	    /* Configure local */
+	    /* Get the port list of devices on the local loop */
+/* 4.10 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+	    gn_list = KMALLOC(GN_LIST_LENGTH);
+	    if ( gn_list != NULL ) {
+	         phys_address = VIRT_TO_BUS(gn_list);
+	         BZERO((caddr_t)gn_list, GN_LIST_LENGTH);
+	    }
+#else
+	    gn_list  = pci_alloc_consistent(ha->pdev,
+                                    GN_LIST_LENGTH,
+                                    &phys_address);
+	    BZERO((caddr_t)gn_list, GN_LIST_LENGTH);
+#endif
+	    if( gn_list != NULL ) {
+
+	        if( !ha->loop_down_timer && !ha->flags.loop_resync_needed ) {
+	            /* Get port list.*/
+	            mb[0] = MBC_GET_PORT_LIST;
+#ifdef FC_IP_SUPPORT
+	            if (ha->flags.enable_ip == FALSE)
+	                mb[1] = BIT_0;      /* Bit 0 - return node names */
+	            else
+	                mb[1] = BIT_0|BIT_1;/* Bit 0 - return node names, Bit 1 - loop IDs 0-255 */
+#else
+	            mb[1] = BIT_0;
+#endif
+	            mb[3] = LSW(phys_address);
+	            mb[2] = MSW(phys_address);
+	            mb[7] = QL21_64BITS_3RDWD(phys_address);
+	            mb[6] = QL21_64BITS_4THWD(phys_address);
+	            if( !qla2100_mailbox_command(ha, BIT_7|BIT_6|BIT_3|BIT_2|BIT_1|BIT_0, &mb[0]) ) {
+	                if ( mb[0] == MBS_COMMAND_COMPLETE ) {
+	                    port_entry = gn_list;
+	                    size = mb[1];
+	                    /* dg 10/29/99 - check for empty list */
+	                    if ( size/sizeof(port_list_entry_t) == 0 ) {
+	                        /* Local devices were present, but may not be reponding,
+	                        so retry them later */
+	                        DEBUG(qla2100_print("qla2100_update_fc_db: local port list - empty\n");)
+	                    } else
+	                        /* Scan through the port list and add devices to the database */
+	                        for( ; size >= sizeof(port_list_entry_t);
+	                        size -= sizeof(port_list_entry_t), port_entry++ ) {
+	                            /* Skip the known ports. */
+#ifdef FC_IP_SUPPORT
+	                            if( ((port_entry->loop_id & LOOP_ID_MASK) == SNS_FL_PORT) ||
+	                            ((port_entry->loop_id & LOOP_ID_MASK) == FABRIC_CONTROLLER) ||
+	                            ((port_entry->loop_id & LOOP_ID_MASK) == SIMPLE_NAME_SERVER) )
+#else
+	                                if( (port_entry->loop_id == SNS_FL_PORT) ||
+	                                (port_entry->loop_id == FABRIC_CONTROLLER) ||
+	                                (port_entry->loop_id == SIMPLE_NAME_SERVER) )
+#endif
+	                                    continue;
+
+	                                /* if we are on a public loop then logout the public devices. */
+	                                if( ((ha->current_topology == ISP_CFG_FL)
+	                                || (ha->current_topology == ISP_CFG_F))
+#ifdef FC_IP_SUPPORT
+	                                && !(port_entry->loop_id & PLE_NOT_SCSI_DEVICE)
+	                                && ((port_entry->loop_id & LOOP_ID_MASK) >= ha->min_external_loopid)) {
+#else
+	                                    && (port_entry->loop_id >= ha->min_external_loopid) ) {
+#endif
+	                                        mb[0] = MBC_LOGOUT_FABRIC_PORT;
+#ifdef FC_IP_SUPPORT
+	                                        mb[1] = (port_entry->loop_id & LOOP_ID_MASK) << 8;
+#else
+	                                        mb[1] = port_entry->loop_id << 8;
+#endif
+	                                        qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
+	                                    } else {
+	                                        /* We are on a local loop             */
+	                                        /* update the database with the loop  */
+	                                        /* ID and login to the device.        */
+#ifdef FC_IP_SUPPORT
+	                                        device.loop_id = port_entry->loop_id & LOOP_ID_MASK;
+#else
+	                                        device.loop_id = port_entry->loop_id;
+#endif
+
+#if USE_PORTNAME
+	                                        /* Get port name */
+	                                        mb[0] = MBC_GET_PORT_NAME;
+	                                        /* mb[1] = device.loop_id << 8 | BIT_0; */
+	                                        mb[1] = device.loop_id << 8;
+	                                        if( !qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]) ) {
+	                                            /* dg 09/15/99  */
+	                                            if ( mb[0] == MBS_COMMAND_COMPLETE ) {
+	                                                /* tt 1/18/00 */
+	                                                mb[2] = (mb[2] & 0x00FF) << 8 | mb[2] >> 8;
+	                                                mb[3] = (mb[3] & 0x00FF) << 8 | mb[3] >> 8;
+	                                                mb[6] = (mb[6] & 0x00FF) << 8 | mb[6] >> 8;
+	                                                mb[7] = (mb[7] & 0x00FF) << 8 | mb[7] >> 8;
+
+							BCOPY(&mb[7], &device.wwn[0], 2);
+							BCOPY(&mb[6], &device.wwn[2], 2);
+							BCOPY(&mb[3], &device.wwn[4], 2);
+							BCOPY(&mb[2], &device.wwn[6], 2);
+	                                            } else {
+	                                                status = 1;
+	                                                printk(KERN_WARNING "qla2100_update_fc_db: [ERROR] GET PORT NAME - bad status.\n");
+	                                                goto qla2100_update_fc_db_exit;
+	                                            }
+
+	                                        } else {   /* dg 10/29/99 */
+	                                            if ( mb[0] == MBS_FATAL_ERROR  ) {
+	                                                status = 1;
+	                                                goto qla2100_update_fc_db_exit;
+	                                            }
+	                                            continue;
+	                                        }
+#endif
+	                                        /* Get the node name */
+						BCOPY(port_entry->name, device.name, 8);
+
+
+#ifdef FC_IP_SUPPORT
+	                                        if (!(port_entry->loop_id & PLE_NOT_SCSI_DEVICE)) {
+	                                            /* SCSI type device */
+	                                            DEBUG(sprintf(debug_buff, "qla2100_update_fc_db: SCSI device at ID %x\n\r",
+	                                            device.loop_id));
+	                                            DEBUG(qla2100_print(debug_buff));
+#endif
+	                                            if( (status = qla2100_update_device_data(ha, &device, enable_slot_reuse)) ) {
+	                                                /* if not configured or full */
+	                                                if( status == 2 )
+	                                                    db_full = 1;
+	                                                else
+	                                                    break;
+	                                            } else
+	                                                localdevices++;
+#ifdef FC_IP_SUPPORT
+	                        } else if (ha->flags.enable_ip == TRUE) {
+	                                    /* SCSI login failed, assume it is IP device */
+	                                    DEBUG(sprintf(debug_buff, "qla2100_update_fc_db: IP device at ID %x\n\r",
+	                                    device.loop_id));
+	                                    DEBUG(qla2100_print(debug_buff));
+
+	                                    /* Update IP device database */
+	                                    if (qla2x00_update_ip_device_data(ha, &device) == QL_STATUS_SUCCESS) {
+	                                        localdevices++;
+	                                    } else {
+	                                        status = 1;
+	                                        break;
+	                                    }
+	                                 }
+#endif
+	                    }
+	                             }  /* end of For */
+	                           }
+	                        }
+	                }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+	                KMFREE(gn_list, GN_LIST_LENGTH);
+#else
+	                pci_free_consistent(ha->pdev, GN_LIST_LENGTH,
+                                    gn_list, phys_address);
+#endif
+	                /*
+	                * if topology is a direct attached local loop then
+	                * don't serach for public devices, unless its a 2100.
+	                */
+	                if( ((ha->current_topology == ISP_CFG_N) ||
+	                (ha->current_topology == ISP_CFG_NL)) &&
+	                ha->device_id != QLA2100_DEVICE_ID ) {  /* 2/21/00 - dg */
+	                    ha->prev_topology = ha->current_topology;
+	                } else {
+	                    /* dgER - we need to add logic to register 
+	                     * our adapter with the Name server, so we
+	                     * can send Command Transport commands (FC4).
+	                     * (target mode)
+	                     */
+ 
+	                    /* get public loop devices */
+	                    if( !ha->loop_down_timer && !ha->flags.loop_resync_needed ){
+	                         /* v2.19.5 */
+	                        if( (ret = qla2100_sns_device(ha, enable_slot_reuse)) == 2 )
+	                            db_full = 1;
+	                         /* v2.19.5b3 */
+	                        if( ret == 1 ) {
+	                          if( ha->device_id != QLA2100_DEVICE_ID ) {
+	                            status = ret;
+	                            ha->sns_retry_cnt++;
+	                            if( ha->sns_retry_cnt > 8 ) {
+	                               if( !(ha->dpc_flags & ISP_RESET_ONCE) )
+	                                 ha->dpc_flags |= ISP_RESET_NEEDED;
+	                            }
+	                            else
+	                              retry_needed++;
+	                          }
+				}
+	                     }
+ 
+	                }
+
+	                /* Set local loop devices present flag, clear retry flag */
+	                if (localdevices > 0 ) {
+	                    ha->device_flags |= DFLG_LOCAL_DEVICES;
+	                    ha->device_flags &= ~DFLG_RETRY_LOCAL_DEVICES;
+	                }
+
+	            if( qla2100_check_devices(ha) ){
+	               DEBUG(printk("qla2100: Devices are missing or configured - retrying\n");)
+	                retry_needed++;
+			}
+#ifdef FC_IP_SUPPORT
+	            /* Clean up active IP device list */
+	            for (pIpDevice = ha->pIpDeviceBottom; pIpDevice != NULL;
+	            pIpDevice = pIpDevice->pLastIpDevice) {
+	                if (!(pIpDevice->lDeviceFlags & IP_DEV_FLAG_PRESENT)) {
+	                    /* Device not present, remove it from list and free resources */
+	                    DEBUG(sprintf(debug_buff, "qla2100_update_fc_db: removing IP device, loop ID: %x, port ID: %x\n\r",
+	                    pIpDevice->wLoopId,
+	                    pIpDevice->acPortId[0]<<16 | pIpDevice->acPortId[1]<<8 | pIpDevice->acPortId[2]));
+	                    DEBUG(qla2100_print(debug_buff));
+
+	                    if (pIpDevice->lDeviceFlags & IP_DEV_FLAG_PUBLIC_DEVICE) {
+	                        /* Do fabric logout and free loop ID */
+	                        if (qla2x00_logout_public_device(ha, pIpDevice->wLoopId, 0) == QL_STATUS_FATAL_ERROR) {
+	                            status = 1;
+	                            break;
+	                        }
+	                        qla2x00_free_loopid(ha, pIpDevice->wLoopId);
+	                    }
+	                    qla2x00_free_ip_block(ha, pIpDevice);
+	                }
+	            }
+#endif /* FC_IP_SUPPORT */
+
+	        } else {
+#ifdef QL_DEBUG_LEVEL_2
+	            qla2100_print(
+	            "qla2100_update_fc_db: Failed to allocate memory, No local loop\n");
+#endif
+	            status = 1;
+	        }
+	        /* Map the devices to target IDs */
+	        if( !ha->loop_down_timer && !ha->flags.loop_resync_needed )
+	            qla2100_map_targets(ha);
+	    } else
+	        status = 1;
+
+	    if( db_full )
+	        status = 2;
+
+	    if( retry_needed ) {
+	        ha->device_flags |= LOGIN_RETRY_NEEDED;
+	        /* v2.19.5 */
+	        status = 1;
+	    }
+
+	    qla2100_update_fc_db_exit:
+
+	    if( status == 0 ) {
+	        ha->loop_state = LOOP_READY;
+	        ha->sns_retry_cnt = 0;
+	        for( cnt = 0; cnt < MAX_FIBRE_DEVICES; cnt++ )
+	          ha->fc_db[cnt].port_login_retry_count = 8;
+	        DEBUG(printk("qla2100_update_fc_db: LOOP READY\n");)
+	    }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+	if( status )
+		qla2100_print("qla2100_update_fc_db: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+	else
+		LEAVE("qla2100_update_fc_db");
+#endif
+	return(status);
+}
+
+/*
+* qla2100_init_tgt_map
+*      Initializes target map.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Output:
+*      TGT_Q initialized
+*/
+STATIC void
+qla2100_init_tgt_map(scsi_qla_host_t *ha) {
+                uint32_t b, t;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_init_tgt_map");
+#endif
+
+                for( b = 0; b < MAX_BUSES; b++ )
+                    for( t = 0; t < MAX_FIBRE_DEVICES; t++ )
+                        TGT_Q(ha, b, t) = (tgt_t *) NULL;
+
+#ifdef QL_DEBUG_LEVEL_3
+                    LEAVE("qla2100_init_tgt_map");
+#endif
+}
+
+/*
+* qla2100_map_targets
+*      Setup target queues.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_map_targets(scsi_qla_host_t *ha) {
+                tgt_t    *tgt;
+                uint32_t b;
+                uint32_t t;
+                uint8_t  status = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_map_targets");
+#endif
+
+                b = 0;
+                for( t = 0; t < MAX_FIBRE_DEVICES; t++ ) {
+                    /* if Port never been used. OR */
+                    /*  Device does not exist on port. */
+                    if( ha->fc_db[t].loop_id != PORT_UNUSED  &&
+                    ha->fc_db[t].loop_id != PORT_AVAILABLE ) {  /* dg 10/29/99 */
+
+                        if( (tgt = TGT_Q(ha, b, t)) != NULL ) {
+                            DEBUG2(sprintf(debug_buff,"Target %d already allocated\n",t));
+                            DEBUG2(qla2100_print(debug_buff));
+                        } else
+                            tgt = qla2100_tgt_alloc(ha);
+                        DEBUG(sprintf(debug_buff,"Assigning target ID %02x:%02x @ (%08x) to loop id: 0x%04x\n",b,t,tgt,ha->fc_db[t].loop_id);)
+                        DEBUG(qla2100_print(debug_buff));
+                        TGT_Q(ha, b, t) = tgt;
+                        tgt->loop_id = ha->fc_db[t].loop_id;
+                        tgt->down_timer = 0;
+                    }
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2100_map_targets: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_map_targets");
+#endif
+                return(status);
+}
+#if USE_FLASH
+/*
+* qla2100_get_database
+*      Copies and converts flash database to driver database.
+*      (may sleep)
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_get_database(scsi_qla_host_t *ha) {
+                flash_database_t *fptr;
+                uint8_t          status = 1;
+                uint32_t         addr;
+                uint16_t         cnt;
+                uint8_t          *bptr;
+                uint8_t          checksum;
+                uint32_t         b, t;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_get_database");
+#endif
+
+                /* Default setup. */
+                ha->flash_db = FLASH_DATABASE_0;
+                ha->flash_seq = 0;
+
+                if( (fptr = (flash_database_t *)KMALLOC(sizeof(flash_database_t))) ) {
+                    /* Enable Flash Read/Write. */
+                    qla2100_flash_enable(ha);
+
+                    /* Start with flash database with the highest sequence number. */
+                    b = qla2100_read_flash_byte(ha, FLASH_DATABASE_0);
+                    b |= qla2100_read_flash_byte(ha, FLASH_DATABASE_0 + 1) << 8;
+                    b |= qla2100_read_flash_byte(ha, FLASH_DATABASE_0 + 1) << 16;
+                    b |= qla2100_read_flash_byte(ha, FLASH_DATABASE_0 + 1) << 24;
+                    t = qla2100_read_flash_byte(ha, FLASH_DATABASE_1);
+                    t |= qla2100_read_flash_byte(ha, FLASH_DATABASE_1 + 1) << 8;
+                    t |= qla2100_read_flash_byte(ha, FLASH_DATABASE_1 + 1) << 16;
+                    t |= qla2100_read_flash_byte(ha, FLASH_DATABASE_1 + 1) << 24;
+                    if( t > b ) {
+                        ha->flash_db = FLASH_DATABASE_1;
+                    }
+
+                    /* Select the flash database with the good checksum. */
+                    for( t = 0; t < 2; t++ ) {
+                        checksum = 0;
+                        addr = ha->flash_db;
+                        bptr = (uint8_t *)fptr;
+                        fptr->hdr.size = sizeof(flash_database_t);
+
+                        /* Read flash database to driver. */
+                        for( cnt = 0; cnt < fptr->hdr.size; cnt++ ) {
+                            *bptr = (uint8_t)qla2100_read_flash_byte(ha, addr++);
+                            checksum += *bptr++;
+                            if( bptr == &fptr->hdr.spares[0] &&
+                            (fptr->hdr.size > sizeof(flash_database_t) ||
+                            fptr->hdr.size < sizeof(flash_hdr_t) ||
+                            !fptr->hdr.version) ) {
+                                checksum = 1;
+                                break;
+                            }
+                        }
+
+                        if( !checksum ) {
+                            status = 0;
+                            break;
+                        }
+                        /* trying other database */
+                        if( ha->flash_db == FLASH_DATABASE_0 ) {
+                            ha->flash_db = FLASH_DATABASE_1;
+                        } else {
+                            ha->flash_db = FLASH_DATABASE_0;
+                        }
+                    }
+
+                    if( !status ) {
+                        ha->flash_seq = fptr->hdr.seq;
+
+                        /* Convert flash database to driver database format. */
+                        if( fptr->hdr.size -= sizeof(flash_hdr_t) ) {
+                            for( cnt = 0; cnt < MAX_FIBRE_DEVICES; cnt++ ) {
+                                ha->fc_db[cnt].name[0] = fptr->node[cnt].name[0];
+                                ha->fc_db[cnt].name[1] = fptr->node[cnt].name[1];
+                                cnt,
+                                ha->fc_db[cnt].name[1],
+                                ha->fc_db[cnt].name[0]);
+
+                                ha->fc_db[cnt].loop_id = PORT_AVAILABLE;
+                                ha->fc_db[cnt].flag = 0;  /* v2.19.05b3 */
+                                if( !(fptr->hdr.size -= sizeof(flash_node_t)) )
+                                    break;
+                            }
+                        }
+                    }
+
+                    qla2100_flash_disable(ha);
+
+                    KMFREE(fptr, sizeof(flash_database_t));
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2100_get_database: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_get_database");
+#endif
+                return(status);
+}
+
+/*
+* qla2100_save_database
+*      Copies and converts driver database to flash database.
+*      (may sleep)
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_save_database(scsi_qla_host_t *ha) {
+                flash_database_t *fptr;
+                uint8_t          status = 1;
+                uint32_t         addr;
+                uint16_t         cnt;
+                uint8_t          *bptr;
+                uint8_t          checksum;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_save_database");
+#endif
+
+                if( (fptr = (flash_database_t *)KMALLOC(sizeof(flash_database_t)) ) ) {
+                    /* Enable Flash Read/Write. */
+                    qla2100_flash_enable(ha);
+
+                    fptr->hdr.seq     = ++ha->flash_seq;
+                    fptr->hdr.version = FLASH_DATABASE_VERSION;
+                    fptr->hdr.size    = sizeof(flash_hdr_t);
+
+                    /* Copy and convert driver database to flash database. */
+                    for( cnt = 0; cnt < MAX_FIBRE_DEVICES; cnt++ ) {
+                        if( ha->fc_db[cnt].loop_id == PORT_UNUSED )
+                            break;
+                        else {
+                            fptr->node[cnt].name[0] = ha->fc_db[cnt].name[0];
+                            fptr->node[cnt].name[1] = ha->fc_db[cnt].name[1];
+                            fptr->hdr.size += sizeof(flash_node_t);
+                        }
+                    }
+
+                    /* Calculate checksum. */
+                    checksum = 0;
+                    bptr = (uint8_t *)fptr;
+                    for( cnt = 0; cnt < fptr->hdr.size; cnt++ )
+                        checksum += *bptr++;
+                    fptr->hdr.checksum = ~checksum + 1;
+
+                    /* Setup next sector address for flash */
+                    if( ha->flash_db == FLASH_DATABASE_0 )
+                        addr = FLASH_DATABASE_1;
+                    else
+                        addr = FLASH_DATABASE_0;
+                    ha->flash_db = addr;
+
+                    /* Erase flash sector prior to write. */
+                    status = qla2100_erase_flash_sector(ha, addr);
+
+                    /* Write database to flash. */
+                    bptr = (uint8_t *)fptr;
+                    for( cnt = 0; cnt < fptr->hdr.size && !status; cnt++ )
+                        status = qla2100_program_flash_address(ha, addr++, *bptr++);
+
+                    qla2100_flash_disable(ha);
+
+                    KMFREE(fptr, sizeof(flash_database_t));
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2100_save_database: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_save_database");
+#endif
+                return(status);
+}
+
+/*
+* qla2100_program_flash_address
+*      Program flash address.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      addr = flash byte address.
+*      data = data to be written to flash.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_program_flash_address(scsi_qla_host_t *ha, uint32_t addr, uint8_t data) {
+                uint8_t status;
+
+                /* Write Program Command Sequence */
+                qla2100_write_flash_byte(ha, 0x5555, 0xaa);
+                qla2100_write_flash_byte(ha, 0x2aaa, 0x55);
+                qla2100_write_flash_byte(ha, 0x5555, 0xa0);
+                qla2100_write_flash_byte(ha, addr, data);
+
+                /* Wait for write to complete. */
+                status = qla2100_poll_flash(ha, addr, data);
+
+#ifdef QL_DEBUG_LEVEL_2
+                if( status )
+                    qla2100_print("qla2100_program_flash_address: **** FAILED ****\n");
+#endif
+                return(status);
+}
+
+/*
+* qla2100_erase_flash_sector
+*      Erases flash sector.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      addr = sector address.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_erase_flash_sector(scsi_qla_host_t *ha, uint32_t addr) {
+                uint8_t status;
+
+                addr &= 0x1c000;
+
+                /* Individual Sector Erase Command Sequence */
+                qla2100_write_flash_byte(ha, 0x5555, 0xaa);
+                qla2100_write_flash_byte(ha, 0x2aaa, 0x55);
+                qla2100_write_flash_byte(ha, 0x5555, 0x80);
+                qla2100_write_flash_byte(ha, 0x5555, 0xaa);
+                qla2100_write_flash_byte(ha, 0x2aaa, 0x55);
+                qla2100_write_flash_byte(ha, addr, 0x30);
+
+                SYS_DELAY(150);
+
+                /* Wait for erase to complete. */
+                status = qla2100_poll_flash(ha, addr, 0x80);
+
+#ifdef QL_DEBUG_LEVEL_2
+                if( status )
+                    qla2100_print("qla2100_erase_flash_sector: **** FAILED ****\n");
+#endif
+                return(status);
+}
+
+/*
+* qla2100_poll_flash
+*      Polls flash for completion.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      addr = flash byte address.
+*      data = data to be polled.
+*
+* Returns:
+*      0 = success.
+*/
+STATIC uint8_t
+qla2100_poll_flash(scsi_qla_host_t *ha, uint32_t addr, uint8_t poll_data) {
+                uint8_t  status = 1;
+                uint8_t  flash_data;
+                uint32_t cnt;
+
+                poll_data &= BIT_7;
+
+                /* Wait for 30 seconds for command to finish. */
+                for( cnt = 3000000; cnt; cnt-- ) {
+                    flash_data = (uint8_t)qla2100_read_flash_byte(ha, addr);
+
+                    if( (flash_data & BIT_7) == poll_data ) {
+                        status = 0;
+                        break;
+                    }
+                    if( flash_data & BIT_5 && cnt > 2 )
+                        cnt = 2;
+                    SYS_DELAY(10);
+                }
+
+                return(status);
+}
+
+/*
+* qla2100_flash_enable
+*      Setup flash for reading/writing.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_flash_enable(scsi_qla_host_t *ha) {
+                device_reg_t *reg = ha->iobase;
+
+                /* Setup bit 16 of flash address. */
+                WRT_REG_WORD(&reg->nvram, NV_SELECT);
+
+                /* Enable Flash Read/Write. */
+                WRT_REG_WORD(&reg->ctrl_status, ISP_FLASH_ENABLE);
+
+                /* Read/Reset Command Sequence */
+                qla2100_write_flash_byte(ha, 0x5555, 0xaa);
+                qla2100_write_flash_byte(ha, 0x2aaa, 0x55);
+                qla2100_write_flash_byte(ha, 0x5555, 0xf0);
+                qla2100_read_flash_byte(ha, FLASH_DATABASE_0);
+}
+
+/*
+* qla2100_flash_disable
+*      Disable flash and allow RISC to run.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_flash_disable(scsi_qla_host_t *ha) {
+                device_reg_t *reg = ha->iobase;
+
+                /* Restore chip registers. */
+                WRT_REG_WORD(&reg->ctrl_status, 0);
+                WRT_REG_WORD(&reg->nvram, 0);
+}
+
+/*
+* qla2100_write_flash_byte
+*      Write byte to flash.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      addr = flash byte address.
+*      data = data to be written.
+*/
+STATIC void
+qla2100_write_flash_byte(scsi_qla_host_t *ha, uint32_t addr, uint8_t data) {
+                device_reg_t *reg = ha->iobase;
+
+                WRT_REG_WORD(&reg->flash_address, (uint16_t)addr);
+                WRT_REG_WORD(&reg->flash_data, (uint16_t)data);
+}
+
+/*
+* qla2100_read_flash_byte
+*      Reads byte from flash, but must read a word from chip.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      addr = flash byte address.
+*
+* Returns:
+*      byte from flash.
+*/
+STATIC uint16_t
+qla2100_read_flash_byte(scsi_qla_host_t *ha, uint32_t addr) {
+                device_reg_t *reg = ha->iobase;
+                uint16_t     data;
+
+                WRT_REG_WORD(&reg->flash_address, (uint16_t)addr);
+                data = qla2100_debounce_register(&reg->flash_data);
+
+                return(data);
+}
+#endif
+
+/*
+* qla2100_reset_adapter
+*      Reset adapter.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_reset_adapter(scsi_qla_host_t *ha) {
+                device_reg_t *reg = ha->iobase;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_reset_adapter");
+#endif
+
+                ha->flags.online = FALSE;
+                qla2100_disable_intrs(ha);
+                /* WRT_REG_WORD(&reg->ictrl, 0); */
+                /* Reset RISC processor. */
+                WRT_REG_WORD(&reg->host_cmd, HC_RESET_RISC);
+                WRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_reset_adapter");
+#endif
+}
+
+/*
+* qla2100_loop_reset
+*      Issue loop reset.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+STATIC uint8_t
+qla2100_loop_reset(scsi_qla_host_t *ha) {
+                uint8_t  status = 0;
+                uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_loop_reset");
+#endif
+
+                if( ha->flags.enable_lip_reset ) {
+                    mb[0] = MBC_LIP_RESET;
+                    mb[1] = 0xff00;
+                    mb[2] = ha->loop_reset_delay;
+                    status |= qla2100_mailbox_command(ha, BIT_2|BIT_1|BIT_0, &mb[0]);
+                }
+                if( ha->flags.enable_target_reset ) {
+                    mb[0] = MBC_TARGET_RESET;
+                    mb[1] = ha->loop_reset_delay;
+                    status |= qla2100_mailbox_command(ha, BIT_1|BIT_0, &mb[0]);
+                }
+                if( (!ha->flags.enable_target_reset && !ha->flags.enable_lip_reset ) ||
+                ha->flags.enable_lip_full_login ) {
+                    mb[0] = MBC_LIP_FULL_LOGIN;
+                    status |= qla2100_mailbox_command(ha, BIT_0, &mb[0]);
+                }
+
+                /* Issue marker command. */
+                qla2100_marker(ha, 0, 0, 0, MK_SYNC_ALL);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2100_loop_reset: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_loop_reset");
+#endif
+                return(status);
+}
+
+/*
+* qla2100_device_reset
+*      Issue bus device reset message to the target.
+*
+* Input:
+*      ha = adapter block pointer.
+*      b  = BUS number.
+*      t  = SCSI ID.
+*
+* Returns:
+*      0 = success
+*/
+STATIC uint8_t
+qla2100_device_reset(scsi_qla_host_t *ha, uint32_t b, uint32_t t) {
+                tgt_t    *tgt;
+                uint8_t  status;
+                uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_device_reset");
+#endif
+
+                tgt =  TGT_Q(ha, b, t);
+
+                mb[0] = MBC_ABORT_TARGET;
+                mb[1] = tgt->loop_id << 8;
+                mb[2] = 1;
+                status = qla2100_mailbox_command(ha, BIT_2|BIT_1|BIT_0, &mb[0]);
+
+                /* Issue marker command. */
+                qla2100_marker(ha, b, t, 0, MK_SYNC_ID);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2100_device_reset: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_device_reset");
+#endif
+                return(status);
+}
+
+/*
+* qla2100_abort_device
+*      Issue an abort message to the device
+*
+* Input:
+*      ha = adapter block pointer.
+*      b  = BUS number.
+*      t  = SCSI ID.
+*      l  = SCSI LUN.
+*
+* Returns:
+*      0 = success
+*/
+STATIC uint8_t
+qla2100_abort_device(scsi_qla_host_t *ha, uint32_t b, uint32_t t, uint32_t l) {
+                tgt_t    *tgt;
+                uint8_t  status;
+                uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_abort_device");
+#endif
+
+                tgt = TGT_Q(ha, b, t);
+
+                mb[0] = MBC_ABORT_DEVICE;
+                mb[1] = tgt->loop_id << 8;
+                mb[2] = l;
+                status = qla2100_mailbox_command(ha, BIT_2|BIT_1|BIT_0, &mb[0]);
+
+                /* Issue marker command. */
+                qla2100_marker(ha, b, t, l, MK_SYNC_ID_LUN);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2100_abort_device: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_abort_device");
+#endif
+                return(status);
+}
+
+/*
+* qla2100_abort_command
+*      Abort command aborts a specified IOCB.
+*
+* Input:
+*      ha = adapter block pointer.
+*      sp = SB structure pointer.
+*
+* Returns:
+*      0 = success
+*/
+STATIC uint8_t
+qla2100_abort_command(scsi_qla_host_t *ha, srb_t *sp) {
+                uint8_t        status;
+                uint16_t       mb[MAILBOX_REGISTER_COUNT];
+                uint32_t       b, t, l;
+                uint32_t       handle;
+                tgt_t          *tgt;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_abort_command");
+#endif
+		/* v2.19.8 */
+                t  = SCSI_TCN_32(sp->cmd);
+                if( ha->loop_state == LOOP_DOWN ||
+                       PORT_DOWN(ha,t) > 0 ) {
+                    return(0);
+                }
+
+                /* Locate handle number. */
+                for( handle = 0; handle < MAX_OUTSTANDING_COMMANDS; handle++ )
+                    if( ha->outstanding_cmds[handle] == sp )
+                        break;
+
+                    DEBUG(qla2100_print("qla2100_abort_command: Sending Abort Command for Handle =  ");)
+                    DEBUG(qla2100_output_number((u_long) handle, 16);)
+                    DEBUG(qla2100_print("\n");)
+
+                    /* Get a pointer to the SCSI address */
+                    b  = SCSI_BUS_32(sp->cmd);
+                    l  = SCSI_LUN_32(sp->cmd);
+
+                    tgt = TGT_Q(ha, b, t);
+
+                    mb[0] = MBC_ABORT_COMMAND;
+                    mb[1] = tgt->loop_id << 8;
+                    mb[2] = (uint16_t)handle;
+                    mb[3] = handle >> 16;
+                    mb[6] = l;
+                    if( !(status = qla2100_mailbox_command(ha, BIT_6|BIT_3|BIT_2|BIT_1|BIT_0,
+                    &mb[0])) )
+                        sp->flags |= SRB_ABORT_PENDING;
+
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                    if( status )
+                        qla2100_print("qla2100_abort_command: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                    else
+                        LEAVE("qla2100_abort_command");
+#endif
+                    return(status);
+}
+
+/*
+*  Issue marker command.
+*      Function issues marker IOCB.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      b    = BUS number.
+*      t    = SCSI ID
+*      l    = SCSI LUN
+*      type = marker modifier
+*/
+STATIC void
+qla2100_marker(scsi_qla_host_t *ha, uint32_t b, uint32_t t, uint32_t l, uint8_t type) {
+                mrk_entry_t *pkt;
+                tgt_t       *tgt;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_marker");
+#endif
+
+                tgt = TGT_Q(ha, b, t);
+
+                /* Get request packet. */
+                if( (pkt = (mrk_entry_t *)qla2100_req_pkt(ha) ) ) {
+                    pkt->entry_type = MARKER_TYPE;
+                    pkt->modifier = type;
+
+                    if( type == MK_SYNC_LIP )
+                        pkt->sequence_number = ha->lip_seq;
+                    else if( type != MK_SYNC_ALL ) {
+                        pkt->lun = l;
+                        pkt->target = (uint8_t)tgt->loop_id;
+                    }
+
+                    /* Issue command to ISP */
+                    qla2100_isp_cmd(ha);
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( !pkt )
+                    qla2100_print("qla2100_marker: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_marker");
+#endif
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,18)
+/*
+* qla2100_64bit_start_scsi
+*      The start SCSI is responsible for building request packets on
+*      request ring and modifying ISP input pointer.
+*
+* Input:
+*      ha = adapter block pointer.
+*      sp = SB structure pointer.
+*
+* Returns:
+*      0 = success, was able to issue command.
+*/
+STATIC uint8_t
+qla2100_64bit_start_scsi(scsi_qla_host_t *ha, srb_t *sp) {
+                device_reg_t        *reg       = ha->iobase;
+                device2300_reg_t    *reg2300   = ha->iobase2300;
+                uint8_t         status = 0;
+                Scsi_Cmnd       *cmd = sp->cmd;
+                uint32_t        cnt;
+                cmd_a64_entry_t     *pkt;
+                uint16_t        req_cnt;
+                uint16_t        seg_cnt;
+                uint16_t        cdb_len,temp;
+                struct scatterlist    *sg = (struct scatterlist *) NULL;
+                uint32_t        timeout;
+                caddr_t         data_ptr;
+                uint32_t        *dword_ptr;
+                uint64_t        dma_handle;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_64bit_start_scsi:");
+#endif
+                DEBUG(sprintf(debug_buff,
+                 "64bit_start: cmd=%x sp=%x CDB=%x\n\r",cmd,sp,cmd->cmnd[0]);)
+                DEBUG(qla2100_print(debug_buff));
+
+                /* Calculate number of entries and segments required. */
+                seg_cnt = 0;
+                req_cnt = 1;
+                if ( cmd->use_sg ) { 
+                    /* 4.10 64 bit S/G Data Transfer */
+                    sg = (struct scatterlist *) cmd->request_buffer;
+                    seg_cnt = pci_map_sg(ha->pdev,
+                               sg,cmd->use_sg, 
+                               scsi_to_pci_dma_dir(cmd->sc_data_direction));
+
+                    if( seg_cnt > 2 ) {
+                        req_cnt += (uint16_t)(seg_cnt - 2) / 5;
+                        if( (uint16_t)(seg_cnt - 2) % 5 )
+                            req_cnt++;
+                    }
+                } else if( cmd->request_bufflen )
+                {   /* no S/G Data Transfer */
+                    /* DEBUG5(printk("Single data transfer (0x%x)\n",
+                    cmd->request_bufflen)); */
+                    seg_cnt = 1;
+                }
+
+                /* Acquire ring specific lock */
+                QLA2100_RING_LOCK(ha);
+
+                if( (uint16_t)(req_cnt + 2) >= ha->req_q_cnt ) {
+                    /* Calculate number of free request q out entries. */
+                    if (ha->device_id == QLA2300_DEVICE_ID)  cnt = RD_REG_WORD(&reg2300->req_q_out);
+                    else                                     cnt = RD_REG_WORD(&reg->mailbox4);
+                    if( ha->req_ring_index < cnt )
+                        ha->req_q_cnt = cnt - ha->req_ring_index;
+                    else
+                        ha->req_q_cnt = REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
+                }
+
+                /* If room for request in request ring. */
+                if( (uint16_t)(req_cnt + 2) < ha->req_q_cnt ) {
+                    /* Check for room in outstanding command list. */
+                    for( cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS &&
+                    ha->outstanding_cmds[cnt] != 0; cnt++ )
+                        ;
+
+                    if( cnt < MAX_OUTSTANDING_COMMANDS ) {
+                        ha->outstanding_cmds[cnt] = sp;
+                        ha->req_q_cnt -= req_cnt;
+                        CMD_HANDLE(sp->cmd) = (unsigned char *) (u_long) cnt;
+
+                        /*
+                        * Build command packet.
+                        */
+                        pkt = ha->request_ring_ptr;
+
+                        pkt->entry_type = COMMAND_A64_TYPE;
+                        pkt->entry_count = (uint8_t)req_cnt;
+                        pkt->sys_define = (uint8_t)ha->req_ring_index;
+                        pkt->control_flags= 0;
+                        pkt->entry_status = 0;
+                        pkt->handle = (uint32_t)cnt;
+
+                        /* Zero out remaining portion of packet. */
+                        dword_ptr = (uint32_t *)pkt + 2;
+                        for( cnt = 2; cnt < REQUEST_ENTRY_SIZE/4; cnt++ )
+                            *dword_ptr++ = 0;
+
+                        /*
+                        * We subtract 2 sec. from the timeout value to insure
+                        * the ISP time-out before the mid-level or the driver.
+                        */
+                        timeout = (uint32_t) CMD_TIMEOUT(cmd)/HZ;
+                        if( timeout > 2 )
+                            pkt->timeout = (uint16_t) timeout - 2;
+                        else
+                            pkt->timeout = (uint16_t) timeout;
+
+                        /* Set device target ID and LUN */
+                        pkt->target = TGT_Q(ha, SCSI_BUS_32(cmd), 
+                                      SCSI_TCN_32(cmd))->loop_id;
+                        pkt->lun = SCSI_LUN_32(cmd);
+
+                        /* Enable simple tag queuing if device supports it. */
+                        if ( cmd->device->tagged_queue ) {
+                            switch (cmd->tag) {
+                                case SIMPLE_QUEUE_TAG:
+                                    pkt->control_flags = CF_SIMPLE_TAG;
+                                    break;
+                                case HEAD_OF_QUEUE_TAG:
+                                    pkt->control_flags = CF_HEAD_TAG;
+                                    break;
+                                case ORDERED_QUEUE_TAG:
+                                    pkt->control_flags = CF_ORDERED_TAG;
+                                    break;
+                                default:
+                                    pkt->control_flags = CF_SIMPLE_TAG;
+                            }
+                        } else
+                            pkt->control_flags = CF_SIMPLE_TAG;
+
+                       if (ha->device_id == QLA2300_DEVICE_ID)
+                           pkt->control_flags |= CF_NO_FAST_POSTING; 
+
+                        /* Load SCSI command packet. */
+                        cdb_len = (uint16_t)CMD_CDBLEN(cmd);
+                        if (cdb_len > MAX_CMDSZ) cdb_len = MAX_CMDSZ;
+                        data_ptr = (uint8_t *) &(CMD_CDBP(cmd));
+                        for( cnt = 0; cnt < cdb_len; cnt++ )
+                            pkt->scsi_cdb[cnt] = *data_ptr++;
+                        pkt->byte_count = (uint32_t) CMD_XFRLEN(cmd);
+
+                        /*
+                        * Load data segments.
+                        */
+                        if( seg_cnt )                /* If data transfer. */
+                        {
+                            switch( cmd->data_cmnd[0] ) {
+                                case FORMAT_UNIT:
+                                case WRITE_6:
+                                case MODE_SELECT:
+                                case SEND_DIAGNOSTIC:
+                                case WRITE_10:
+                                case WRITE_BUFFER:
+                                case WRITE_LONG:
+                                case WRITE_SAME:
+                                case MODE_SELECT_10:
+                                case WRITE_12:
+                                case WRITE_VERIFY_12:
+                                case SEND_VOLUME_TAG:
+                                    pkt->control_flags |= BIT_6; /* WRITE */
+                                    break;
+                                default:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#if QLA_SCSI_VENDOR_DIR
+    				    qla2100_set_vend_direction(ha, cmd, pkt);
+#else
+                                    pkt->control_flags |= BIT_5; /* READ */
+#endif
+#else  /* kernel version is 2.4.0 or higher */
+                                    if (cmd->sc_data_direction == SCSI_DATA_WRITE)
+                                        pkt->control_flags |= BIT_6;/*WRITE*/
+                                    else 
+                                        pkt->control_flags |= BIT_5;/*READ*/
+#endif /* kernel version 2.4.0 */
+                                    break;
+                            }
+                            sp->dir = pkt->control_flags & (BIT_5|BIT_6);
+ 
+                            /* Set total data segment count. */
+                            pkt->dseg_count = seg_cnt;
+
+                            /* Setup packet address segment pointer. */
+                            dword_ptr = (uint32_t *)&pkt->dseg_0_address;
+
+                            if( cmd->use_sg )              /* If scatter gather */
+                            {
+                                /* Load command entry data segments. */
+                                for( cnt = 0; cnt < 2 && seg_cnt; cnt++, seg_cnt-- ) {
+                                    /* 4.10 64 bit */
+                                    *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                                    *dword_ptr++ = cpu_to_le32(pci_dma_hi32(sg_dma_address(sg)));
+                                    *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+                                    sg++;
+                                      /* DEBUG(sprintf(debug_buff,
+                                      "S/G Segment phys_addr=%x %x, len=0x%x\n\r",
+                                      cpu_to_le32(pci_dma_hi32(sg_dma_address(sg))),
+                                      cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                                      cpu_to_le32(sg_dma_len(sg)));)
+                                      DEBUG(qla2100_print(debug_buff)); */
+                                }
+#ifdef QL_DEBUG_LEVEL_5
+                                qla2100_print(
+                                "qla2x00_64bit_start_scsi: Scatter/gather command packet data - ");
+                                qla2100_print("b");
+                                qla2100_output_number((uint32_t)SCSI_BUS_32(cmd), 10);
+                                qla2100_print("t");
+                                qla2100_output_number((uint32_t)SCSI_TCN_32(cmd), 10);
+                                qla2100_print("d");
+                                qla2100_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
+                                qla2100_print("\n\r");
+                                qla2100_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+#endif
+                                /*
+                                * Build continuation packets.
+                                */
+                                while( seg_cnt > 0 ) {
+                                    /* Adjust ring index. */
+                                    ha->req_ring_index++;
+                                    if( ha->req_ring_index == REQUEST_ENTRY_CNT ) {
+                                        ha->req_ring_index = 0;
+                                        ha->request_ring_ptr = ha->request_ring;
+                                    } else
+                                        ha->request_ring_ptr++;
+
+                                    pkt = (cmd_a64_entry_t *)ha->request_ring_ptr;
+
+                                    /* Zero out packet. */
+                                    dword_ptr = (uint32_t *)pkt;
+                                    for( cnt = 0;cnt < REQUEST_ENTRY_SIZE/4; cnt++ )
+                                        *dword_ptr++ = 0;
+
+                                    /* Load packet defaults. */
+                                    ((cont_a64_entry_t *)pkt)->entry_type =
+                                    CONTINUE_A64_TYPE;
+                                    ((cont_a64_entry_t *)pkt)->entry_count = 1;
+                                    ((cont_a64_entry_t *)pkt)->sys_define = (uint8_t)
+                                    ha->req_ring_index;
+
+                                    /* Setup packet address segment pointer. */
+                                    dword_ptr = (uint32_t *)
+                                    &((cont_a64_entry_t *)pkt)->dseg_0_address;
+
+                                    /* Load continuation entry data segments. */
+                                    for( cnt = 0; cnt < 5 && seg_cnt; cnt++, seg_cnt-- ) {
+                                       /* 4.10 64 bit */
+                                       *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                                       *dword_ptr++ = cpu_to_le32(pci_dma_hi32(sg_dma_address(sg)));
+                                       *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+                                       sg++;
+                                      /* DEBUG(sprintf(debug_buff,
+                                      "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n\r",
+                                       cpu_to_le32(pci_dma_hi32(sg_dma_address(sg))),
+                                       cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                                       cpu_to_le32(sg_dma_len(sg)));)
+                                       DEBUG(qla2100_print(debug_buff)); */
+                                    }
+#ifdef QL_DEBUG_LEVEL_5
+                                    qla2100_print(
+                                    "qla2x00_64bit_start_scsi: continuation packet data - c");
+                                    qla2100_print("b");
+                            qla2100_output_number((u_long)SCSI_BUS_32(cmd), 10);
+
+                            qla2100_print("t");
+                            qla2100_output_number((u_long)SCSI_TCN_32(cmd), 10);
+                            qla2100_print("d");
+                            qla2100_output_number((u_long)SCSI_LUN_32(cmd), 10);
+                            qla2100_print("\n\r");
+                                    qla2100_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+#endif
+                                }
+                            } else   /* No scatter gather data transfer */
+                            {   /* 4.10 64 bit */
+                                dma_handle = pci_map_single(ha->pdev, 
+                                                         cmd->request_buffer,
+                                                         cmd->request_bufflen,
+                                                         scsi_to_pci_dma_dir(cmd->sc_data_direction));
+                                /* save dma_handle for pci_unmap_single */
+                                sp->saved_dma_handle = dma_handle;
+
+                                *dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
+                                *dword_ptr++ = cpu_to_le32(pci_dma_hi32(dma_handle));
+                                *dword_ptr   = (uint32_t) cmd->request_bufflen;
+                                /* DEBUG(sprintf(debug_buff,
+                                "64_bit: No S/G map_single saved_dma_handle=%lx len=%x \n\r",dma_handle, cmd->request_bufflen));
+                                DEBUG(qla2100_print(debug_buff)); */
+#ifdef QL_DEBUG_LEVEL_5
+                                qla2100_print(
+                                "qla2x00_64bit_start_scsi: No scatter/gather command packet data - c");
+                                qla2100_print("b");
+                                qla2100_output_number((uint32_t)SCSI_BUS_32(cmd), 10);
+                                qla2100_print("t");
+                                qla2100_output_number((uint32_t)SCSI_TCN_32(cmd), 10);
+                                qla2100_print("d");
+                                qla2100_output_number((uint32_t)SCSI_LUN_32(cmd), 10);
+                                qla2100_print("\n\r");
+                                qla2100_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+#endif
+                            }
+                        }
+                        else                            /* No data transfer */
+                        {
+                            *dword_ptr++ = (uint32_t) 0;
+                            *dword_ptr++ = (uint32_t) 0;
+                            *dword_ptr = (uint32_t)  0;
+#ifdef QL_DEBUG_LEVEL_5
+                         qla2100_print(
+                         "qla2x00_64bit_start_scsi: No data, command packet data - c");
+                         qla2100_print("b");
+                         qla2100_output_number((u_long)SCSI_BUS_32(cmd), 10);
+                         qla2100_print("t");
+                         qla2100_output_number((u_long)SCSI_TCN_32(cmd), 10);
+                         qla2100_print("d");
+                         qla2100_output_number((u_long)SCSI_LUN_32(cmd), 10);
+                         qla2100_print("\n\r");
+                         qla2x00_dump_buffer((caddr_t)pkt, REQUEST_ENTRY_SIZE);
+#endif
+                        }
+                        DEBUG4(qla2100_print("\nqla2100_64bit_start_scsi: Wakeup RISC for pending command\n\r"));
+                        /* Adjust ring index. */
+                        ha->req_ring_index++;
+                        if( ha->req_ring_index == REQUEST_ENTRY_CNT ) {
+                            ha->req_ring_index = 0;
+                            ha->request_ring_ptr = ha->request_ring;
+                        } else
+                            ha->request_ring_ptr++;
+
+                        /* Set chip new ring index. */
+#if WATCH_THREADS_SIZE
+                        DEBUG3(qla2100_output_number((uint32_t)ha->actthreads, 16));
+#endif
+                        if (ha->device_id == QLA2300_DEVICE_ID) {
+                           temp = CACHE_FLUSH(&reg2300->req_q_in);
+                           WRT_REG_WORD(&reg2300->req_q_in, ha->req_ring_index);
+                        } else {
+                           temp = CACHE_FLUSH(&reg->mailbox4);
+                           WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
+                        }
+                    } else {
+                        status = 1;
+#ifdef QL_DEBUG_LEVEL_2
+                        qla2100_print(
+                        "qla2x00_64bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n\r");
+                        qla2100_print(" req_q_cnt=");
+                qla2100_output_number((u_long)ha->req_q_cnt, 16);
+#endif
+                    }
+                } else {
+                    status = 1;
+#ifdef QL_DEBUG_LEVEL_2
+                    qla2100_print("qla2x00_64bit_start_scsi: in-ptr=");
+            qla2100_output_number((u_long)ha->req_ring_index, 16);
+            qla2100_print(" req_q_cnt=");
+            qla2100_output_number((u_long)ha->req_q_cnt, 16);
+            qla2100_print(" req_cnt=");
+            qla2100_output_number((u_long)req_cnt, 16);
+                    qla2100_print("\n\r");
+#endif
+                }
+
+                /* Release ring specific lock */
+                QLA2100_RING_UNLOCK(ha);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                    qla2100_print("qla2x00_64bit_start_scsi: **** FAILED ****\n\r");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    qla2100_print("qla2x00_64bit_start_scsi: exiting normally\n\r");
+#endif
+                return(status);
+}
+#endif
+
+/*
+* qla2100_32bit_start_scsi
+*      The start SCSI is responsible for building request packets on
+*      request ring and modifying ISP input pointer.
+*
+*      The Qlogic firmware interface allows every queue slot to have a SCSI
+*      command and up to 4 scatter/gather (SG) entries.  If we need more
+*      than 4 SG entries, then continuation entries are used that can
+*      hold another 7 entries each.  The start routine determines if there
+*      is eought empty slots then build the combination of requests to
+*      fulfill the OS request.
+*
+* Input:
+*      ha = adapter block pointer.
+*      sp = SCSI Request Block structure pointer.
+*
+* Returns:
+*      0 = success, was able to issue command.
+*/
+STATIC uint8_t
+qla2100_32bit_start_scsi(scsi_qla_host_t *ha, srb_t *sp) {
+                device_reg_t        *reg       = ha->iobase;
+                device2300_reg_t    *reg2300   = ha->iobase2300;
+                uint8_t         status = 0;
+                Scsi_Cmnd       *cmd = sp->cmd;
+                uint16_t        cdb_len, temp;
+                uint32_t        cnt;
+                cmd_entry_t     *pkt;
+                uint16_t        req_cnt;
+                uint16_t        seg_cnt;
+                struct scatterlist    *sg = (struct scatterlist *) NULL;
+                caddr_t         data_ptr;
+                uint32_t        *dword_ptr;
+                uint32_t        timeout;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+                uint64_t       dma_handle;
+#endif
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_32bit_start_scsi"); 
+#endif
+
+#if defined(QL_DEBUG_LEVEL_5) || defined(QL_DEBUG_LEVEL_3)
+                printk(
+                          "32bit_start BEGIN: cmd=%x sp=%x CDB=%x\n\r",
+                           cmd,sp,cmd->cmnd[0]);
+#endif
+#ifdef NEW
+                /*
+                * Send marker if required.
+                */
+                if (ha->marker_needed != 0) {
+                    if (qla2200_marker(ha, 0, 0, MK_SYNC_ALL) != 0) {
+                        RING_UNLOCK(ha);
+                        return (1);
+                    }
+                }
+#endif
+                COMTRACE('S')
+                /* Calculate number of entries and segments required. */
+                seg_cnt = 0;
+                req_cnt = 1;
+                if( cmd->use_sg ) {
+                    sg = (struct scatterlist *) cmd->request_buffer;
+                    /* 4.10 32 bit S/G Data Transfer */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                    seg_cnt =  cmd->use_sg;
+#else
+                    seg_cnt = pci_map_sg(ha->pdev,sg,cmd->use_sg, 
+                              scsi_to_pci_dma_dir(cmd->sc_data_direction));
+#endif
+                    /*
+                    * if greater than four sg entries then we need to allocate
+                    * continuation entries
+                    */
+                    if( seg_cnt > 2 ) {
+                        req_cnt += (uint16_t)(seg_cnt - 3) / 7;
+                        if( (uint16_t)(seg_cnt - 3) % 7 )
+                            req_cnt++;
+                    }
+                    DEBUG5(sprintf(debug_buff,
+                    "S/G for data transfer -num segs(%d), req blk cnt(%d)\n\r",seg_cnt,req_cnt));
+                    DEBUG5(qla2100_print(debug_buff));
+                } else if( CMD_XFRLEN(cmd) )  /* If data transfer. */
+                {  /* no S/G Data Transfer */
+                   /*  DEBUG5(printk("Single data transfer (0x%x)\n",
+                       cmd->request_bufflen));*/
+                    seg_cnt = 1;
+                }
+
+                /* Acquire ring specific lock */
+                QLA2100_RING_LOCK(ha);
+
+                if( (uint16_t)(req_cnt + 2) >= ha->req_q_cnt ) {
+                    /* Calculate number of free request entries. */
+                    if (ha->device_id == QLA2300_DEVICE_ID)  
+                      cnt = qla2100_debounce_register(&reg2300->req_q_out);
+                    else   
+                      cnt = qla2100_debounce_register(&reg->mailbox4);
+
+                    if( ha->req_ring_index < cnt )
+                        ha->req_q_cnt = cnt - ha->req_ring_index;
+                    else
+                        ha->req_q_cnt = REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
+                }
+
+                DEBUG5(sprintf(debug_buff,
+                 "Number of free entries = (%d)\n\r",ha->req_q_cnt));
+                DEBUG5(qla2100_print(debug_buff));
+                /* If room for request in request ring. */
+                if( (uint16_t)(req_cnt + 2) < ha->req_q_cnt ) {
+                    /* Check for room in outstanding command list. */
+                    for( cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS &&
+                    (ha->outstanding_cmds[cnt] != 0); cnt++ )
+                        ;
+
+                    if( cnt < MAX_OUTSTANDING_COMMANDS ) {
+                        ha->outstanding_cmds[cnt] = sp;
+                        ha->req_q_cnt -= req_cnt;
+                        /* save the handle -- helps if we want to abort it */
+                        CMD_HANDLE(sp->cmd) = (unsigned char *) (u_long) cnt;
+
+                        /*
+                        * Build command packet.
+                        */
+                        pkt = (cmd_entry_t *)ha->request_ring_ptr;
+
+                        pkt->entry_type = COMMAND_TYPE;
+                        pkt->entry_count = (uint8_t)req_cnt;
+                        pkt->sys_define = (uint8_t)ha->req_ring_index;
+                        pkt->entry_status = 0;
+                        pkt->control_flags= 0;
+                        pkt->handle = (uint32_t)cnt;
+
+                        /* Zero out remaining portion of packet. */
+                        dword_ptr = (uint32_t *)pkt + 2;
+                        for( cnt = 2; cnt < REQUEST_ENTRY_SIZE/4; cnt++ )
+                            *dword_ptr++ = 0;
+
+                        /*
+                        * v2.19.8
+                        * We subtract 5 sec. from the timeout value to insure
+                        * the ISP time-out before the mid-level or the driver.
+                        */
+                        timeout = (uint32_t) CMD_TIMEOUT(cmd)/HZ;
+                        if( timeout > 5 )
+                            pkt->timeout = (uint16_t) timeout - 5;
+                        else
+                            pkt->timeout = (uint16_t) timeout;
+
+                        /* Set device target ID and LUN */
+                        pkt->target = TGT_Q(ha, 
+                        SCSI_BUS_32(cmd), SCSI_TCN_32(cmd))->loop_id;
+                        pkt->lun = SCSI_LUN_32(cmd);
+
+                        /* Enable simple tag queuing if device supports it. */
+                        if ( cmd->device->tagged_queue ) {
+                            switch (cmd->tag) {
+                                case SIMPLE_QUEUE_TAG:
+                                    pkt->control_flags = CF_SIMPLE_TAG;
+                                    break;
+                                case HEAD_OF_QUEUE_TAG:
+                                    pkt->control_flags = CF_HEAD_TAG;
+                                    break;
+                                case ORDERED_QUEUE_TAG:
+                                    pkt->control_flags = CF_ORDERED_TAG;
+                                    break;
+                                default:
+                                    pkt->control_flags = CF_SIMPLE_TAG;
+                            }
+                        } else
+                            pkt->control_flags = CF_SIMPLE_TAG;
+
+                       if (ha->device_id == QLA2300_DEVICE_ID)
+                           pkt->control_flags |= CF_NO_FAST_POSTING; 
+
+                        /* Load SCSI command packet. */
+                        cdb_len = (uint16_t)CMD_CDBLEN(cmd);
+                        if( cdb_len > MAX_CMDSZ )
+                            cdb_len = MAX_CMDSZ;
+                        data_ptr = (uint8_t *) &(CMD_CDBP(cmd));
+                        for( cnt = 0; cnt < cdb_len; cnt++ )
+                            pkt->scsi_cdb[cnt] = *data_ptr++;
+                        DEBUG3(sprintf(debug_buff,
+                        "qla2100: Packet has command[0]=0x%x, hndl=0x%x\n",pkt->scsi_cdb[0],pkt->handle);)
+                        DEBUG3(qla2100_print(debug_buff);)
+                        pkt->byte_count = (uint32_t) CMD_XFRLEN(cmd);
+
+                        /*
+                        * Load data segments.
+                        */
+                        if( seg_cnt ) {
+                            /* Set transfer direction (READ and WRITE) */
+                            /* Linux doesn't tell us                   */
+
+                            switch( cmd->data_cmnd[0] ) {
+                                case FORMAT_UNIT:
+                                case WRITE_6:
+                                case MODE_SELECT:
+                                case SEND_DIAGNOSTIC:
+                                case WRITE_10:
+                                case WRITE_BUFFER:
+                                case WRITE_LONG:
+                                case WRITE_SAME:
+                                case MODE_SELECT_10:
+                                case WRITE_12:
+                                case WRITE_VERIFY_12:
+                                case SEND_VOLUME_TAG:
+                                    pkt->control_flags |= BIT_6; /* WRITE */
+                                    break;
+                                default:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#if QLA_SCSI_VENDOR_DIR
+    				    qla2100_set_vend_direction(ha, cmd, pkt);
+#else
+                                    pkt->control_flags |= BIT_5; /* READ */
+#endif
+#else  /* kernel version is 2.4.0 or higher */
+                                    if (cmd->sc_data_direction == SCSI_DATA_WRITE)
+                                        pkt->control_flags |= BIT_6;/*WRITE*/
+                                    else 
+                                        pkt->control_flags |= BIT_5;/*READ*/
+#endif /* kernel version 2.4.0 */
+                                    break;
+                            }
+                            sp->dir = pkt->control_flags & (BIT_5|BIT_6);
+
+                            /* Set total data segment count. */
+                            pkt->dseg_count = seg_cnt;
+
+                            /* Setup packet address segment pointer. */
+                            dword_ptr = (uint32_t *)&pkt->dseg_0_address;
+
+                            if( cmd->use_sg )     /* If scatter gather */
+                            {
+                                DEBUG5(qla2100_print("Building S/G data segments..\n\r"));
+                                DEBUG5(qla2100_dump_buffer((caddr_t)sg, 4*16));
+                                /* Load command entry data segments. */
+                                for( cnt = 0; cnt < 3 && seg_cnt; cnt++, seg_cnt-- ) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                                   *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(sg->address));
+                                   *dword_ptr++ = sg->length;
+                                   /* DEBUG(sprintf(debug_buff,
+                                      "S/G Segment phys_addr=0x%x, len=0x%x\n\r",
+                                       cpu_to_le32(VIRT_TO_BUS(sg->address)),sg->length));
+                                       DEBUG(qla2100_print(debug_buff)); */
+#else
+                                   *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                                   *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+                                      /* DEBUG(sprintf(debug_buff,
+                                      "S/G Segment phys_addr=0x%x, len=0x%x\n\r",
+                                       cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                                       cpu_to_le32(sg_dma_len(sg)));)
+                                       DEBUG(qla2100_print(debug_buff)); */
+#endif
+                                   sg++;
+                                }
+#ifdef QL_DEBUG_LEVEL_5
+                                qla2100_print(
+                                "qla2100_32bit_start_scsi: Scatter/gather command packet data - ");
+                                qla2100_output_number((u_long)ha->host_no, 10);
+                                qla2100_print(":");
+                                qla2100_output_number((u_long)SCSI_BUS_32(cmd), 10);
+                                qla2100_print(":");
+                                qla2100_output_number((u_long)SCSI_TCN_32(cmd), 10);
+                                qla2100_print(":");
+                                qla2100_output_number((u_long)SCSI_LUN_32(cmd), 10);
+                                qla2100_print("\n");
+                                qla2100_dump_buffer((uint8_t *)pkt, REQUEST_ENTRY_SIZE);
+#endif
+                                /*
+                                * Build continuation packets.
+                                */
+                                while( seg_cnt > 0 ) {
+                                    /* Adjust ring index. */
+                                    ha->req_ring_index++;
+                                    if( ha->req_ring_index == REQUEST_ENTRY_CNT ) {
+                                        ha->req_ring_index = 0;
+                                        ha->request_ring_ptr = ha->request_ring;
+                                    } else
+                                        ha->request_ring_ptr++;
+
+                                    pkt = (cmd_entry_t *)ha->request_ring_ptr;
+
+                                    /* Zero out packet. */
+                                    dword_ptr = (uint32_t *)pkt;
+                                    for( cnt = 0;cnt < REQUEST_ENTRY_SIZE/4; cnt++ )
+                                        *dword_ptr++ = 0;
+
+                                    /* Load packet defaults. */
+                                    ((cont_entry_t *)pkt)->entry_type = CONTINUE_TYPE;
+                                    ((cont_entry_t *)pkt)->entry_count = 1;
+                                    ((cont_entry_t *)pkt)->sys_define = (uint8_t)
+                                    ha->req_ring_index;
+
+                                    /* Setup packet address segment pointer. */
+                                    dword_ptr = (uint32_t *)
+                                    &((cont_entry_t *)pkt)->dseg_0_address;
+
+                                    /* Load continuation entry data segments. */
+                                    for( cnt = 0; cnt < 7 && seg_cnt; cnt++, seg_cnt-- ) {
+                                       /* 4.10 32 bit */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                                       *dword_ptr++ = (u_int) cpu_to_le32(VIRT_TO_BUS(sg->address));
+                                       *dword_ptr++ = sg->length;
+                                       /* DEBUG(sprintf(debug_buff,
+                                       "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n\r",
+                                        cpu_to_le32(pci_dma_lo32(VIRT_TO_BUS(sg->address))),sg->length);)
+                                        DEBUG(qla2100_print(debug_buff)); */
+#else
+                                       *dword_ptr++ = cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+                                       *dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+                                       /* DEBUG(sprintf(debug_buff,
+                                       "S/G Segment Cont. phys_addr=0x%x, len=0x%x\n\r",
+                                       cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+                                       cpu_to_le32(sg_dma_len(sg)));)
+                                       DEBUG(qla2100_print(debug_buff)); */
+#endif
+                                       sg++;
+                                    }
+#ifdef QL_DEBUG_LEVEL_5
+                                    qla2100_print(
+                                    "qla2100_32bit_start_scsi: continuation packet data - ");
+                                    qla2100_output_number((u_long)ha->host_no, 10);
+                                    qla2100_print(":");
+                                    qla2100_output_number((u_long)SCSI_BUS_32(cmd), 10);
+                                    qla2100_print(":");
+                                    qla2100_output_number((u_long)SCSI_TCN_32(cmd), 10);
+                                    qla2100_print(":");
+                                    qla2100_output_number((u_long)SCSI_LUN_32(cmd), 10);
+                                    qla2100_print("\n");
+                                    qla2100_dump_buffer((uint8_t *)pkt,
+                                    REQUEST_ENTRY_SIZE);
+#endif
+                                }
+                            } else  /* No scatter gather data transfer */
+                            {
+                              /* 4.10 32 bit */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                              *dword_ptr++ = (uint32_t) cpu_to_le32(VIRT_TO_BUS(cmd->request_buffer));
+                              *dword_ptr = (uint32_t) cmd->request_bufflen;
+#else
+                              dma_handle = pci_map_single(ha->pdev, 
+                                                          cmd->request_buffer,
+                                                          cmd->request_bufflen,
+                                                          scsi_to_pci_dma_dir(cmd->sc_data_direction));
+                              sp->saved_dma_handle = dma_handle;
+
+                              *dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
+                              *dword_ptr   = (uint32_t) cmd->request_bufflen;
+                              /* DEBUG(sprintf(debug_buff,
+                              "32_bit: No S/G map_single dma_handle=%lx len=%x\n\r",dma_handle,cmd->request_bufflen));
+                              DEBUG(qla2100_print(debug_buff)); */
+#endif 
+                              /* DEBUG5(printk("Single Segment ap=0x%x, len=0x%x\n",cmd->request_buffer,cmd->request_bufflen));*/
+
+#ifdef QL_DEBUG_LEVEL_5
+                              qla2100_print("qla2100_32bit_start_scsi: No scatter/gather command packet data - ");
+                              qla2100_output_number((u_long)ha->host_no, 10);
+                              qla2100_print(":");
+                              qla2100_output_number((u_long)SCSI_BUS_32(cmd), 10);
+                              qla2100_print(":");
+                              qla2100_output_number((u_long)SCSI_TCN_32(cmd), 10);
+                              qla2100_print(":");
+                              qla2100_output_number((u_long)SCSI_LUN_32(cmd), 10);
+                              qla2100_print("\n");
+                              qla2100_dump_buffer((uint8_t *)pkt, REQUEST_ENTRY_SIZE);
+#endif
+                            }
+                        }
+                        else     /* No data transfer */
+                        {
+                            *dword_ptr++ = (uint32_t) 0;
+                            *dword_ptr = (uint32_t)  0;
+#ifdef QL_DEBUG_LEVEL_5
+                    qla2100_print(
+                    "qla2100_32bit_start_scsi: No data, command packet data - ");
+                    qla2100_output_number((u_long)ha->host_no, 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)SCSI_BUS_32(cmd), 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)SCSI_TCN_32(cmd), 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)SCSI_LUN_32(cmd), 10);
+                    qla2100_print("\n");
+                    qla2100_dump_buffer((uint8_t *)pkt, REQUEST_ENTRY_SIZE);
+#endif
+                        }
+                        /* Adjust ring index. */
+                        ha->req_ring_index++;
+                        if( ha->req_ring_index == REQUEST_ENTRY_CNT ) {
+                            ha->req_ring_index = 0;
+                            ha->request_ring_ptr = ha->request_ring;
+                        } else
+                            ha->request_ring_ptr++;
+
+                        /* Set chip new ring index. */
+                        DEBUG4(qla2100_print("\nqla2100_32bit_start_scsi: Wakeup RISC for pending command\n\r"));
+                        ha->qthreads--;
+                        sp->flags |= SRB_SENT;
+                        sp->state = 0xde;
+                        ha->actthreads++;
+
+                     /* DEBUG(sprintf(debug_buff," Start(pid=%d) ",cmd->pid);)
+                        DEBUG(qla2100_print(debug_buff);) */
+
+#if WATCH_THREADS_SIZE
+                DEBUG3(qla2100_output_number((u_long)ha->actthreads, 16)); 
+#endif
+                        if (ha->device_id == QLA2300_DEVICE_ID) {
+                          temp = CACHE_FLUSH(&reg2300->req_q_in);
+                          WRT_REG_WORD(&reg2300->req_q_in, ha->req_ring_index);
+                        } else { 
+                          temp = CACHE_FLUSH(&reg->mailbox4);
+                          WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
+                        }
+                    } else {
+                        status = 1;
+                        qla2100_stats.outarray_full++;
+#ifdef QL_DEBUG_LEVEL_8
+                        qla2100_print(
+                        "qla2100_32bit_start_scsi: NO ROOM IN OUTSTANDING ARRAY\n");
+#endif
+                    }
+                } else {
+                    status = 1;
+#ifdef QL_DEBUG_LEVEL_8
+                    qla2100_print("qla2100_32bit_start_scsi: in-ptr=");
+                    qla2100_output_number((u_long)ha->req_ring_index, 16);
+                    qla2100_print(" req_q_cnt=");
+                    qla2100_output_number((u_long)ha->req_q_cnt, 16);   
+                    qla2100_print(" req_cnt=");
+                    qla2100_output_number((u_long)req_cnt, 16);
+                    qla2100_print("\n");
+#endif
+                }
+
+                /* Release ring specific lock */
+                QLA2100_RING_UNLOCK(ha);
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( status )
+                      qla2100_print("qla2100_32bit_start_scsi: **** FAILED ****\n");
+#ifdef QL_DEBUG_LEVEL_3
+                else  qla2100_print("qla2100_32bit_start_scsi: exiting normally\n\n\r");
+#endif
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_32bit_start_scsi"); 
+#endif
+                COMTRACE('s')
+                return(status);
+}
+
+/*
+* qla2100_ms_req_pkt
+*      Function is responsible for locking ring and
+*      getting a zeroed out Managment Server request packet.
+*
+* Input:
+*      ha  = adapter block pointer.
+*      sp  = srb_t pointer to handle post function call
+* Returns:
+*      0 = failed to get slot.
+*/
+STATIC request_t *
+qla2100_ms_req_pkt(scsi_qla_host_t *ha, srb_t  *sp) {
+                device_reg_t     *reg     = ha->iobase;
+                device2300_reg_t *reg2300 = ha->iobase2300;
+                request_t    *pkt = 0;
+                uint16_t     cnt,i;
+                uint32_t     *dword_ptr;
+                uint32_t     timer;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_ms_req_pkt");
+#endif
+
+                /* Wait for 30 seconds for slot. */
+                for( timer = 3000000; timer; timer-- ) {
+                    /* Acquire ring specific lock */
+                    QLA2100_RING_LOCK(ha);
+
+                    if( !ha->req_q_cnt ) {
+                        /* Calculate number of free request entries. */
+                        if (ha->device_id == QLA2300_DEVICE_ID) cnt = qla2100_debounce_register(&reg2300->req_q_out);
+                        else                                    cnt = qla2100_debounce_register(&reg->mailbox4);
+                        if( ha->req_ring_index < cnt )
+                            ha->req_q_cnt = cnt - ha->req_ring_index;
+                        else
+                            ha->req_q_cnt = REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
+                    }
+
+                    /* Check for room in outstanding command list. */
+                    for( cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS &&
+                    (ha->outstanding_cmds[cnt] != 0); cnt++ )
+                        ;
+
+                    if( (cnt < MAX_OUTSTANDING_COMMANDS) &&
+                        ( ha->req_q_cnt != 0 )) {
+
+                        pkt = ha->request_ring_ptr;
+
+                        /* Zero out packet. */
+                        dword_ptr = (uint32_t *)pkt;
+                        for( i = 0; i < REQUEST_ENTRY_SIZE/4; i++ )
+                            *dword_ptr++ = 0;
+
+                        DEBUG(sprintf(debug_buff,
+                          "qla2100_ms_req: putting sp=%x in outstanding_cmds[%x]\n",sp,cnt));
+                        DEBUG(qla2100_print(debug_buff));
+
+                        ha->outstanding_cmds[cnt] = sp;
+                        /* save the handle */
+                        CMD_HANDLE(sp->cmd) = (unsigned char *) (u_long) cnt;
+
+                        ha->req_q_cnt--;
+                        pkt->handle = (uint32_t)cnt;
+
+                        /* Set system defined field. */
+                        pkt->sys_define = (uint8_t)ha->req_ring_index;
+                        pkt->entry_status = 0;
+
+                        break;
+                    }
+
+                    /* Release ring specific lock */
+                    QLA2100_RING_UNLOCK(ha);
+
+                    SYS_DELAY(2);  
+
+                    /* Check for pending interrupts. */
+                    qla2100_poll(ha);
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( !pkt )
+                    qla2100_print("qla2100_ms_req_pkt: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_ms_req_pkt");
+#endif
+                return(pkt);
+}
+
+
+/*
+* qla2100_req_pkt
+*      Function is responsible for locking ring and
+*      getting a zeroed out request packet.
+*
+* Input:
+*      ha  = adapter block pointer.
+*
+* Returns:
+*      0 = failed to get slot.
+*/
+STATIC request_t *
+qla2100_req_pkt(scsi_qla_host_t *ha) {
+                device_reg_t     *reg     = ha->iobase;
+                device2300_reg_t *reg2300 = ha->iobase2300;
+                request_t    *pkt = 0;
+                uint16_t     cnt;
+                uint32_t     *dword_ptr;
+                uint32_t     timer;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_req_pkt");
+#endif
+
+                /* Wait for 30 seconds for slot. */
+                for( timer = 3000000; timer; timer-- ) {
+                    /* Acquire ring specific lock */
+                    QLA2100_RING_LOCK(ha);
+
+                    if( !ha->req_q_cnt ) {
+                        /* Calculate number of free request entries. */
+                        if (ha->device_id == QLA2300_DEVICE_ID) cnt = qla2100_debounce_register(&reg2300->req_q_out);
+                        else                                    cnt = qla2100_debounce_register(&reg->mailbox4);
+                        if( ha->req_ring_index < cnt )
+                            ha->req_q_cnt = cnt - ha->req_ring_index;
+                        else
+                            ha->req_q_cnt = REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
+                    }
+
+                    /* Found empty request ring slot? */
+                    if( ha->req_q_cnt ) {
+                        ha->req_q_cnt--;
+                        pkt = ha->request_ring_ptr;
+
+                        /* Zero out packet. */
+                        dword_ptr = (uint32_t *)pkt;
+                        for( cnt = 0; cnt < REQUEST_ENTRY_SIZE/4; cnt++ )
+                            *dword_ptr++ = 0;
+
+                        /* Set system defined field. */
+                        pkt->sys_define = (uint8_t)ha->req_ring_index;
+
+                        /* Set entry count. */
+                        pkt->entry_count = 1;
+
+                        break;
+                    }
+
+                    /* Release ring specific lock */
+                    QLA2100_RING_UNLOCK(ha);
+
+                    SYS_DELAY(2);   /* 10 */
+
+                    /* Check for pending interrupts. */
+                    qla2100_poll(ha);
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( !pkt )
+                    qla2100_print("qla2100_req_pkt: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_req_pkt");
+#endif
+                return(pkt);
+}
+
+/*
+* qla2100_isp_cmd
+*      Function is responsible for modifying ISP input pointer.
+*      Releases ring lock.
+*
+* Input:
+*      ha  = adapter block pointer.
+*/
+STATIC void
+qla2100_isp_cmd(scsi_qla_host_t *ha) {
+                device_reg_t     *reg     = ha->iobase;
+                device2300_reg_t *reg2300 = ha->iobase2300;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_isp_cmd");
+#endif
+
+#ifdef QL_DEBUG_LEVEL_5
+                qla2100_print("qla2100_isp_cmd: IOCB data:\n");
+                qla2100_dump_buffer((uint8_t *)ha->request_ring_ptr, REQUEST_ENTRY_SIZE);
+#endif
+
+                /* Adjust ring index. */
+                ha->req_ring_index++;
+                if( ha->req_ring_index == REQUEST_ENTRY_CNT ) {
+                    ha->req_ring_index = 0;
+                    ha->request_ring_ptr = ha->request_ring;
+                } else
+                    ha->request_ring_ptr++;
+
+                /* Set chip new ring index. */
+                if (ha->device_id == QLA2300_DEVICE_ID) WRT_REG_WORD(&reg2300->req_q_in, ha->req_ring_index);
+                else                                    WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
+
+                /* Release ring specific lock */
+                QLA2100_RING_UNLOCK(ha);
+
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_isp_cmd");
+#endif
+}
+
+/*
+* qla2100_enable_lun
+*      Issue enable LUN entry IOCB.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_enable_lun(scsi_qla_host_t *ha) {
+                elun_entry_t *pkt;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_enable_lun");
+#endif
+
+                /* Get request packet. */
+                if( (pkt = (elun_entry_t *)qla2100_req_pkt(ha)) != NULL ) {
+                    pkt->entry_type = ENABLE_LUN_TYPE;
+                    pkt->command_count = 32;
+                    pkt->immed_notify_count = 1;
+                    pkt->timeout = 0xffff;
+
+                    /* Issue command to ISP */
+                    qla2100_isp_cmd(ha);
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( !pkt )
+                    qla2100_print("qla2100_enable_lun: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_enable_lun");
+#endif
+}
+
+
+
+#if QL2100_TARGET_MODE_SUPPORT
+/****************************************************************************/
+/*                      Target Mode Support Functions.                      */
+/****************************************************************************/
+
+
+/*
+* qla2100_notify_ack
+*      Issue notify acknowledge IOCB.
+*      If sequence ID is zero, acknowledgement of
+*      SCSI bus reset or bus device reset is assumed.
+*
+* Input:
+*      ha      = adapter block pointer.
+*      inotify = immediate notify entry pointer.
+*/
+STATIC void
+qla2100_notify_ack(scsi_qla_host_t *ha, notify_entry_t *inotify) {
+                nack_entry_t *pkt;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_notify_ack: entered\n");
+#endif
+
+                /* Get request packet. */
+                if( pkt = (nack_entry_t *)qla2100_req_pkt(ha) ) {
+                    pkt->entry_type = NOTIFY_ACK_TYPE;
+                    pkt->initiator_id = inotify->initiator_id;
+                    pkt->target_id = inotify->target_id;
+
+                    if( (pkt->status = inotify->status) == 0xe )
+                        /* Reset LIP occurred. */
+                        pkt->flags = OF_RESET;
+                    else
+                        /* Increment Immediate Notify Resource Count. */
+                        pkt->flags = OF_INC_RC;
+
+                    pkt->task_flags = inotify->task_flags;
+                    pkt->seq_id = inotify->seq_id;
+
+                    /* Issue command to ISP */
+                    qla2100_isp_cmd(ha);
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( !pkt )
+                    qla2100_print("qla2100_notify_ack: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_notify_ack: exiting normally\n");
+#endif
+}
+
+/*
+* qla2100_64bit_continue_io
+*      Issue continue target I/O IOCB.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      atio = atio pointer.
+*      len  = total bytecount.
+*      addr = physical address pointer.
+*/
+STATIC void
+qla2100_64bit_continue_io(scsi_qla_host_t *ha, atio_entry_t *atio, uint32_t len,
+        u_long    *addr) {
+                ctio_a64_entry_t *pkt;
+                uint32_t         *dword_ptr;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_64bit_continue_io: entered\n");
+#endif
+
+                /* Get request packet. */
+                if( pkt = (ctio_a64_entry_t *)qla2100_req_pkt(ha) ) {
+                    pkt->entry_type = CTIO_A64_TYPE;
+                    pkt->initiator_id = atio->initiator_id;
+                    pkt->exchange_id = atio->exchange_id;
+                    pkt->flags = atio->flags | OF_FAST_POST;
+                    pkt->scsi_status = atio->scsi_status;
+
+                    if( len ) {
+                        pkt->dseg_count = 1;
+                        pkt->transfer_length = len;
+                        pkt->dseg_0_length = len;
+                        dword_ptr = (uint32_t *)addr;
+                        pkt->dseg_0_address[0] = *dword_ptr++;
+                        pkt->dseg_0_address[1] = *dword_ptr;
+                    }
+
+                    /* Issue command to ISP */
+                    qla2100_isp_cmd(ha);
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( !pkt )
+                    qla2100_print("qla2100_64bit_continue_io: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_64bit_continue_io: exiting normally\n");
+#endif
+}
+
+/*
+* qla2100_32bit_continue_io
+*      Issue continue target I/O IOCB.
+*
+* Input:
+*      ha   = adapter block pointer.
+*      atio = atio pointer.
+*      len  = total bytecount.
+*      addr = physical address pointer.
+*/
+STATIC void
+qla2100_32bit_continue_io(scsi_qla_host_t *ha, atio_entry_t *atio, uint32_t len,
+        u_long    *addr) {
+                ctio_entry_t *pkt;
+                uint32_t     *dword_ptr;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_continue_io: entered\n");
+#endif
+
+                /* Get request packet. */
+                if( pkt = (ctio_entry_t *)qla2100_req_pkt(ha) ) {
+                    pkt->entry_type = CONTINUE_TGT_IO_TYPE;
+                    pkt->initiator_id = atio->initiator_id;
+                    pkt->exchange_id = atio->exchange_id;
+                    pkt->flags = atio->flags | OF_FAST_POST;
+                    pkt->scsi_status = atio->scsi_status;
+
+                    if( len ) {
+                        pkt->dseg_count = 1;
+                        pkt->transfer_length = len;
+                        pkt->dseg_0_length = len;
+                        dword_ptr = (uint32_t *)addr;
+                        pkt->dseg_0_address = *dword_ptr;
+                    }
+
+                    /* Issue command to ISP */
+                    qla2100_isp_cmd(ha);
+                }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                if( !pkt )
+                    qla2100_print("qla2100_32bit_continue_io: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                else
+                    LEAVE("qla2100_32bit_continue_io: exiting normally\n");
+#endif
+}
+#endif /* QL2100_TARGET_MODE_SUPPORT */
+
+
+
+/****************************************************************************/
+/*                        Interrupt Service Routine.                        */
+/****************************************************************************/
+
+/*
+*  qla2100_isr
+*      Calls I/O done on command completion.
+*
+* Input:
+*      ha           = adapter block pointer.
+*      done_q_first = done queue first pointer.
+*      done_q_last  = done queue last pointer.
+*      INTR_LOCK must be already obtained.
+*/
+STATIC void
+qla2100_isr(scsi_qla_host_t *ha, srb_t **done_q_first, srb_t **done_q_last) {
+                device_reg_t     *reg     = ha->iobase;
+                device2300_reg_t *reg2300 = ha->iobase2300;
+                response_t   *pkt, response_entry;
+                srb_t        *sp;
+                uint16_t     mailbox[MAILBOX_REGISTER_COUNT];
+                uint16_t     *wptr, status2 = 0;
+                uint32_t     index, longstatus, *dptr1, *dptr2;
+                unsigned long cpu_flags = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_isr"); 
+#endif
+                if (ha->device_id != QLA2300_DEVICE_ID) { 
+                    /* Check for 2100/2200 mailbox interrupt (semaphore set) */
+                    longstatus = RD_REG_WORD(&reg->semaphore);
+                    if (longstatus & BIT_0)     status2 = SEMAPHORE_SET;
+                } else {
+                    /* Get 2300's Interrupt Status byte */
+                    longstatus = RD_REG_DWORD(&reg2300->host_status);
+/*#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                    DEBUG(qla2100_print("qla2100_isr: +++ 2300 RISC_TO_HOST reg= ");)
+                    DEBUG(qla2100_output_number((u_long)longstatus, 16);)
+                    DEBUG(qla2100_print(" +++ \n");)
+#endif */
+                    switch(longstatus & 0xff) {
+                      case 0x1:
+                      case 0x2:
+                      case 0x10:
+                      case 0x11:
+                      case 0x12:
+                      case 0x14:
+                      case 0x15:
+                      case 0x16:
+                      case 0x17:
+                        status2 = SEMAPHORE_SET;
+                        break;
+                      case 0x13:
+                      default:
+                        status2 = 0;
+                        break;
+                    }
+                }
+
+                if ( status2 == SEMAPHORE_SET ) {
+
+                    /* Get mailbox data. */
+                    wptr    = &mailbox[0];
+                    if (ha->device_id != QLA2300_DEVICE_ID) {
+                      *wptr++ = qla2100_debounce_register(&reg->mailbox0);
+                      *wptr++ = RD_REG_WORD(&reg->mailbox1);
+                      *wptr   = RD_REG_WORD(&reg->mailbox2);
+                    } else { 
+                      *wptr++ = qla2100_debounce_register(&reg2300->mailbox0);
+                      *wptr++ = RD_REG_WORD(&reg2300->mailbox1);
+                      *wptr   = RD_REG_WORD(&reg2300->mailbox2);
+                    }
+
+                    WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+
+#if defined(QL_DEBUG_LEVEL_4)
+DEBUG(qla2100_print("qla2100_isr: SEMAPHORE SET Processing, mailbox[0]=");)
+DEBUG(qla2100_output_number((u_long)mailbox[0], 16);)
+DEBUG(qla2100_print(" \n");)
+DEBUG(qla2100_print("qla2100_isr: mailbox[1]=");)
+DEBUG(qla2100_output_number((u_long)mailbox[1], 16);)
+DEBUG(qla2100_print(" \n");)
+DEBUG(qla2100_print("qla2100_isr: mailbox[2]=");)
+DEBUG(qla2100_output_number((u_long)mailbox[2], 16);)
+DEBUG(qla2100_print(" \n");)
+DEBUG(qla2100_print("qla2100_isr: mailbox[3]=");)
+DEBUG(qla2100_output_number((u_long)mailbox[3], 16);)
+DEBUG(qla2100_print(" \n");)
+#endif 
+
+#ifdef FC_IP_SUPPORT /*******************************************/
+                    /* Handle IP send fast post */
+                    if (mailbox[0] == MBA_IP_TRANSMIT_COMPLETE) {
+                        SEND_CB *pSendCB;
+
+                        /* Clear the semaphore lock , if it was set */
+                        if (RD_REG_WORD(&reg->semaphore) & BIT_0)
+                            WRT_REG_WORD(&reg->semaphore, 0);
+
+                        /* Validate cmd handle and get packet pointer */
+                        if (mailbox[1] < MAX_SEND_PACKETS) {
+                            if ((pSendCB = (SEND_CB *)ha->apActiveIpQueue[mailbox[1]]) != NULL) {
+                                ha->apActiveIpQueue[mailbox[1]] = NULL;
+
+                                /* Complete backdoor command */
+                                (*ha->pSendCompletionRoutine)(pSendCB);
+
+                                return;
+                            }
+                        }
+
+                        /* Invalid handle from RISC, reset RISC firmware */
+                        printk(KERN_WARNING "qla2100_isr: bad IP send fast post handle %x\n",
+                        mailbox[1]);
+                        ha->flags.isp_abort_needed = TRUE;
+                        return;
+                    }
+
+                    /* Handle IP receive fast post */
+                    else if (mailbox[0] == MBA_IP_RECEIVE_COMPLETE ||
+                    mailbox[0] == MBA_IP_RECEIVE_COMPLETE_SPLIT) {
+                        PBUFFER_CB      pBufferCB, pNextBufferCB;
+                        uint32_t        lTagVal;
+                        uint32_t        lPacketSize;
+                        uint32_t        lReceiveBufferSize;
+                        volatile uint16_t *pNextMailbox;
+                        uint16_t        wBufferCount;
+
+                        pNextMailbox = &reg->mailbox10;
+
+                        /* If split buffer, set header size for 1st buffer */
+                        if (mailbox[0] == MBA_IP_RECEIVE_COMPLETE_SPLIT)
+                            lReceiveBufferSize = ha->wHeaderSize;
+                        else
+                            lReceiveBufferSize = ha->lReceiveBufferSize;
+
+                        if ((lTagVal = RD_REG_WORD(pNextMailbox)) >= ha->wReceiveBufferCount) {
+                            goto InvalidIpBufferHandle;
+                        }
+
+                        pBufferCB = &ha->pReceiveBufferCBs[lTagVal];
+
+                        if (!(pBufferCB->lFlags &  BCB_FLAGS_RISC_OWNS_BUFFER)) {
+                            goto InvalidIpBufferHandle;
+                        }
+
+                        /* Set buffer belongs to driver now */
+                        pBufferCB->lFlags &= ~BCB_FLAGS_RISC_OWNS_BUFFER;
+
+                        lPacketSize = RD_REG_WORD(&reg->mailbox3);
+                        pBufferCB->lPacketSize = lPacketSize;
+                        pNextBufferCB = pBufferCB;
+
+                        for (wBufferCount = 1; ; wBufferCount++) {
+                            if (lPacketSize > lReceiveBufferSize) {
+                                pNextBufferCB->lBufferSize = lReceiveBufferSize;
+                                lPacketSize               -= lReceiveBufferSize;
+
+                                /* If split buffer, only use header size on 1st buffer */
+                                lReceiveBufferSize = ha->lReceiveBufferSize;
+
+                                pNextMailbox++;
+                                if ((lTagVal = RD_REG_WORD(pNextMailbox)) >=
+                                ha->wReceiveBufferCount) {
+                                    InvalidIpBufferHandle:
+                                    printk(KERN_WARNING "qla2100_isr: bad IP receive fast post handle %x\n",
+                                    lTagVal);
+                                    ha->flags.isp_abort_needed = TRUE;
+                                    return;
+                                }
+
+                                pNextBufferCB->pNextBufferCB = &ha->pReceiveBufferCBs[lTagVal];
+                                pNextBufferCB = pNextBufferCB->pNextBufferCB;
+
+                                if (!(pNextBufferCB->lFlags & BCB_FLAGS_RISC_OWNS_BUFFER)) {
+                                    goto InvalidIpBufferHandle;
+                                }
+
+                                /* Set buffer belongs to driver now */
+                                pNextBufferCB->lFlags &= ~BCB_FLAGS_RISC_OWNS_BUFFER;
+                            } else {
+                                pNextBufferCB->lBufferSize = lPacketSize;
+                                pNextBufferCB->pNextBufferCB = NULL;
+                                break;
+                            }
+                        }
+
+                        /* Clear the semaphore lock , if it was set */
+                        if (RD_REG_WORD(&reg->semaphore) & BIT_0)
+                            WRT_REG_WORD(&reg->semaphore, 0);
+
+                        /* Pass received packet to IP driver */
+                        pBufferCB->wBufferCount = wBufferCount;
+
+                        (*ha->pReturnReceivePacketsRoutine)
+                        (ha->pReturnReceivePacketsContext,
+                        pBufferCB);
+
+                        /* Keep track of RISC buffer pointer (for IP reinit) */
+                        ha->wIpBufferOut += wBufferCount;
+                        if (ha->wIpBufferOut >= IP_BUFFER_QUEUE_DEPTH)
+                            ha->wIpBufferOut -= IP_BUFFER_QUEUE_DEPTH;
+
+                        return;
+                    }
+#endif /* FC_IP_SUPPORT ****************************************8*/
+
+                    if( mailbox[0] != MBA_SCSI_COMPLETION ) {
+#ifdef QL_DEBUG_LEVEL_4
+                        qla2100_print("qla2100_isr: non MBA_SCSI_COMPLETION ; Saving mailbox data\n");
+#endif
+                        wptr++;
+                        if (ha->device_id != QLA2300_DEVICE_ID) {
+                          *wptr++ = RD_REG_WORD(&reg->mailbox3);
+                          *wptr++ = qla2100_debounce_register(&reg->mailbox4);
+                          *wptr++ = qla2100_debounce_register(&reg->mailbox5);
+                          *wptr++ = RD_REG_WORD(&reg->mailbox6);
+                          *wptr   = RD_REG_WORD(&reg->mailbox7);
+                        } else {
+                          *wptr++ = RD_REG_WORD(&reg2300->mailbox3);
+                          *wptr++ = qla2100_debounce_register(&reg2300->mailbox4);
+                          *wptr++ = qla2100_debounce_register(&reg2300->mailbox5);
+                          *wptr++ = RD_REG_WORD(&reg2300->mailbox6);
+                          *wptr   = RD_REG_WORD(&reg2300->mailbox7);
+                        }
+                    }
+
+                    /* Clear the semaphore lock , if it was set */
+                    if (RD_REG_WORD(&reg->semaphore) & BIT_0)
+                        WRT_REG_WORD(&reg->semaphore, 0);
+
+#ifdef QL_DEBUG_LEVEL_4
+                    qla2100_print("qla2100_isr: +++ mailbox interrupt mailbox[0] = ");
+                    qla2100_output_number((u_long)mailbox[0], 16);
+                    qla2100_print("+++ \n");
+ #endif 
+                    /* Handle asynchronous (0x80xx) and 
+                       mailbox command completion (0x400x) events */ 
+                    switch( mailbox[0] ) {
+                        case MBA_SCSI_COMPLETION:   /* 0x8020 */
+                            if( ha->flags.online ) {
+                                /* Get outstanding command index. */
+                                index = (uint32_t)(mailbox[2] << 16 | mailbox[1]);
+                                /* Validate handle. */
+                                if( index < MAX_OUTSTANDING_COMMANDS ) {
+                                    sp = ha->outstanding_cmds[index];
+                                } else
+                                    sp = 0;
+
+                                if( sp ) {
+                                    /* Free outstanding command slot. */
+                                    ha->outstanding_cmds[index] = 0;
+
+                                    /* Save ISP completion status */
+                                    CMD_RESULT(sp->cmd) = DID_OK;
+            						sp->flags &= ~SRB_SENT;
+		                    /* v2.19.5b2 Reset port down retry on success. */
+			            sp->port_down_retry_count = ha->port_down_retry_count;
+        
+                                    QLA2100_TIMER_LOCK(ha);
+                                    ha->actthreads--;
+                                    /* Place block on done queue */
+                                    qla2100_stats.done_q_cnt++;
+                                    DEBUG(sp->state = 3;)
+                                    
+                                    sp->s_next = NULL;
+                                    sp->s_prev = *done_q_last;
+                                    if( !(*done_q_first) )
+                                        *done_q_first = sp;
+                                    else
+                                        (*done_q_last)->s_next = sp;
+                                    *done_q_last = sp;
+                                    QLA2100_TIMER_UNLOCK(ha);
+                                } else {
+#ifdef QL_DEBUG_LEVEL_2
+                                    qla2100_print("qla2100_isr: ISP invalid handle\n");
+#endif
+                                    ha->flags.isp_abort_needed = TRUE;
+                                }
+                            }
+                            break;
+                        case MBA_RESET:                 /* Reset 0x8001*/
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr: asynchronous RESET\n");
+#endif
+                            ha->flags.reset_marker = TRUE;
+                            break;
+                        case MBA_SYSTEM_ERR:        /* System Error 0x8002 */
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr: ISP System Error - mbx1=");
+                            qla2100_output_number((u_long)mailbox[1], 16);
+                            qla2100_print(", mbx2=");
+                            qla2100_output_number((u_long)mailbox[2], 16);
+                            qla2100_print(", mbx3=");
+                            qla2100_output_number((u_long)mailbox[3], 16);
+                            qla2100_print("\n");
+#endif
+                            printk(KERN_WARNING
+                            "!qla2100_isr: ISP System Error - mbx1=%xh, mbx2=%xh, mbx3=%xh",
+                            mailbox[1], mailbox[2], mailbox[3]);
+                            ha->flags.isp_abort_needed = TRUE;
+                            break;
+                        case MBA_REQ_TRANSFER_ERR:  /* Request Transfer Error */
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr: ISP Request Transfer Error\n");
+#endif
+                            printk(KERN_WARNING "qla2100: ISP Request Transfer Error\n");
+                            ha->flags.isp_abort_needed = TRUE;
+                            break;
+                        case MBA_RSP_TRANSFER_ERR:  /* Response Transfer Error */
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr: ISP Response Transfer Error\n");
+#endif
+                            printk(KERN_WARNING "qla2100: ISP Response Transfer Error\n");
+                            ha->flags.isp_abort_needed = TRUE;
+                            break;
+                        case MBA_WAKEUP_THRES:      /* Request Queue Wake-up */
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr: asynchronous WAKEUP_THRES\n");
+#endif
+                            break;
+                        case MBA_LIP_OCCURRED:      /* Loop Initialization Procedure */
+                            if(!qla2100_quiet) printk(KERN_INFO "scsi(%d): LIP occurred.\n",(int)ha->host_no);       
+                            DEBUG(sprintf(debug_buff,"\n\nscsi(%d): LIP occurred.\n",(int)ha->host_no);)
+                            DEBUG(qla2100_print(debug_buff));
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_isr: asynchronous MBA_LIP_OCCURRED\n");
+#endif
+		                    ha->dpc_flags = ha->dpc_flags | COMMAND_WAIT_NEEDED;
+                            /* Save LIP sequence. */
+                            ha->lip_seq = mailbox[1];
+                            if( ha->loop_state != LOOP_DOWN ) {
+                                    ha->loop_state = LOOP_DOWN;
+                                    ha->loop_down_timer = LOOP_DOWN_TIME;
+                            }
+                            ha->lip_count++;
+                            break;
+                        case MBA_LOOP_UP:
+                            printk(KERN_INFO "scsi(%d): LOOP UP detected\n",(int)ha->host_no);
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr: asynchronous MBA_LOOP_UP\n");
+#endif
+                            ha->loop_state = LOOP_UP;
+                            break;
+                        case MBA_LOOP_DOWN:
+                            printk(KERN_INFO "scsi(%d): LOOP DOWN detected\n",(int)ha->host_no);
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr: asynchronous MBA_LOOP_DOWN\n");
+#endif
+		                    ha->dpc_flags = ha->dpc_flags | COMMAND_WAIT_NEEDED;
+                            if( ha->loop_state != LOOP_DOWN ) {
+                                    ha->loop_state = LOOP_DOWN;
+                                    ha->loop_down_timer = LOOP_DOWN_TIME;
+                            }
+                            break;
+                        case MBA_LIP_RESET:         /* LIP reset occurred. */
+                            if(!qla2100_quiet) printk(KERN_INFO "scsi(%d): LIP reset occurred\n",(int)ha->host_no);
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_isr: asynchronous MBA_LIP_RESET\n");
+#endif
+		            ha->dpc_flags = ha->dpc_flags | COMMAND_WAIT_NEEDED;
+                            ha->flags.reset_marker = TRUE;
+                            ha->loop_down_timer = LOOP_DOWN_TIME;
+                            ha->loop_state = LOOP_DOWN;
+                            ha->operating_mode = LOOP;
+                            break;
+                        case MBA_LINK_MODE_UP:      /* Link mode up. */
+                            DEBUG(printk(KERN_INFO "scsi(%d): Link node is up\n",(int)ha->host_no);)
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_isr: asynchronous MBA_LINK_MODE_UP\n");
+#endif
+		                    ha->dpc_flags = ha->dpc_flags | COMMAND_WAIT_NEEDED;
+                            break;
+                        case MBA_UPDATE_CONFIG:      /* Update Configuration. */
+                            printk(KERN_INFO "scsi(%d): Configuration change detected: value %d.\n",(int)ha->host_no,mailbox[1]);
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_isr: asynchronous MBA_UPDATE_CONFIG\n");
+#endif
+                            ha->flags.update_config_needed = 1;
+                            ha->loop_state = LOOP_DOWN;  /* dg - 03/30 */
+                            ha->flags.isp_abort_needed = TRUE;
+                            break;
+                        case MBA_PORT_UPDATE:       /* Port database update occurred. */
+                            DEBUG(printk("scsi(%d): Port database changed\n",(int)ha->host_no);)
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_isr: asynchronous MBA_PORT_UPDATE\n");
+#endif
+                            ha->loop_down_timer = 0;
+                            ha->flags.loop_resync_needed = TRUE;
+                            ha->loop_state = LOOP_UPDATE;
+                            break;
+                        case MBA_SCR_UPDATE:        /* State Change Registration. */
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_isr: asynchronous MBA_RSCR_UPDATE\n");
+#endif
+                            mailbox[1] = RD_REG_WORD(&reg->mailbox1);
+                            mailbox[2] = RD_REG_WORD(&reg->mailbox2);
+
+                            DEBUG(printk("scsi(%d): RSCN database changed - 0x%x,0x%x\n",(int)ha->host_no,mailbox[1],mailbox[2]);)
+#ifdef RCSN
+                            index = ha->rscn_in_ptr + 1;
+                            if (index == MAX_RSCN_COUNT)
+                                index = 0;
+                            if (index != ha->rscn_out_ptr) {
+                                    ha->rscn_queue[ha->rscn_in_ptr].format =
+                                    MSB(mb[1]);
+                                    ha->rscn_queue[ha->rscn_in_ptr].d_id.b.domain =
+                                    LSB(mb[1]);
+                                    ha->rscn_queue[ha->rscn_in_ptr].d_id.b.area =
+                                    MSB(mb[2]);
+                                    ha->rscn_queue[ha->rscn_in_ptr].d_id.b.al_pa =
+                                    LSB(mb[2]);
+                                    ha->rscn_in_ptr = (uint8_t)index;
+                            } else {
+                                    ha->device_flags |= RSCN_QUEUE_OVERFLOW;
+                            }
+#endif
+                            ha->device_flags |= RSCN_UPDATE;
+                            ha->loop_down_timer = 0;
+                            ha->flags.loop_resync_needed = TRUE;
+                            ha->loop_state = LOOP_UPDATE;
+		         /*    ha->dpc_flags = ha->dpc_flags | COMMAND_WAIT_NEEDED; */
+                            break;
+                        case MBA_CTIO_COMPLETION:
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print(
+                            "qla2100_isr: asynchronous MBA_CTIO_COMPLETION\n");
+#endif
+                            break;
+                        default:
+                            if( mailbox[0] < MBA_ASYNC_EVENT  /* 0x8000 */) {
+                                    wptr = &mailbox[0];
+                                    ha->mailbox_out[0] = *wptr++;
+                                    ha->mailbox_out[1] = *wptr++;
+                                    ha->mailbox_out[2] = *wptr++;
+                                    ha->mailbox_out[3] = *wptr++;
+                                    ha->mailbox_out[4] = *wptr++;
+                                    ha->mailbox_out[5] = *wptr++;
+                                    ha->mailbox_out[6] = *wptr++;
+                                    ha->mailbox_out[7] = *wptr;
+                                    ha->flags.mbox_int = TRUE;
+#ifdef QL_DEBUG_LEVEL_2
+	if (mailbox[0] != 0x4000) {
+                            qla2100_print("qla2100_isr: MBA Switch Default mailbox[0]= ");
+                            qla2100_output_number(mailbox[0] , 16);
+                            qla2100_print("\n");
+	}
+#endif 
+#ifdef QL_DEBUG_LEVEL_4
+                                    qla2100_print("qla2100_isr: Setting flags.mbox_int=1 in Default mailbox[0]= ");
+                                    qla2100_output_number(mailbox[0] , 16);
+                                    qla2100_print("\n");
+#endif
+                            }
+                            break;
+                    } /* switch */
+                } else { /* not a SEMAPHORE Set Completion */
+                   if (ha->device_id != QLA2300_DEVICE_ID) 
+                     mailbox[5]=qla2100_debounce_register(&reg->mailbox5);
+                   else 
+                     mailbox[5]=qla2100_debounce_register(&reg2300->rsp_q_in);
+
+                    WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+                    /*
+                    * Response Ring Update
+                    */
+                    /* Clear mailbox busy flag for 2300s;
+                       so we don't ignore its Respose Ring Updates 
+                       during send of mailbox command */
+                    if (ha->device_id == QLA2300_DEVICE_ID) 
+                        ha->flags.mbox_busy = FALSE;
+
+                    if( ha->flags.online && !(ha->flags.mbox_busy) ) { 
+                        if( mailbox[5] < RESPONSE_ENTRY_CNT ) {
+                            while( ha->rsp_ring_index != mailbox[5] ) {
+                                pkt = ha->response_ring_ptr;
+
+#ifdef QL_DEBUG_LEVEL_5
+                                qla2100_print("qla2100_isr: ha->rsp_ring_index = ");
+                                qla2100_output_number((u_long)ha->rsp_ring_index, 16);
+                                qla2100_print(" mailbox[5] = ");
+                                qla2100_output_number((u_long)mailbox[5], 16);
+                                qla2100_print("\n");
+                                qla2100_print("\nqla2100_isr: response packet data\n");
+                                qla2100_dump_buffer((uint8_t *)pkt, RESPONSE_ENTRY_SIZE);
+#endif
+
+#ifdef FC_IP_SUPPORT /************************************************/
+                                /* Handle IP send completion */
+                                if (pkt->entry_type == ET_IP_COMMAND_64) {
+                                    uint32_t            lTagVal;
+                                    SEND_CB             *pSendCB;
+
+                                    /* Set packet pointer from queue entry handle */
+                                    if ((lTagVal = pkt->handle) < MAX_SEND_PACKETS) {
+                                        if ((pSendCB = (SEND_CB *)ha->apActiveIpQueue[lTagVal]) != NULL) {
+                                            ha->apActiveIpQueue[lTagVal] = NULL;
+
+                                            /* Return send packet to IP driver */
+                                            (*ha->pSendCompletionRoutine)(pSendCB);
+                                        } else {
+                                            /* Invalid handle from RISC, reset RISC firmware */
+                                            printk(KERN_WARNING "qla2100_isr: bad IP send handle %x\n", lTagVal);
+                                            ha->flags.isp_abort_needed = TRUE;
+                                        }
+                                    } else {
+                                        /* Invalid handle from RISC, reset RISC firmware */
+                                        printk(KERN_WARNING "qla2100_isr: bad IP send handle %x\n", lTagVal);
+                                        ha->flags.isp_abort_needed = TRUE;
+                                    }
+
+                                    /* Adjust ring index. */
+                                    ha->rsp_ring_index++;
+                                    if( ha->rsp_ring_index == RESPONSE_ENTRY_CNT ) {
+                                        ha->rsp_ring_index = 0;
+                                        ha->response_ring_ptr = ha->response_ring;
+                                    } else
+                                        ha->response_ring_ptr++;
+                                        if (ha->device_id != QLA2300_DEVICE_ID) 
+                                             WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
+                                        else     
+                                             WRT_REG_WORD(&reg2300->rsp_q_out, ha->rsp_ring_index);
+                                    continue;
+                                }
+
+                                /* Handle IP receive packet */
+                                else if (pkt->entry_type == ET_IP_RECEIVE) {
+                                    PIP_RECEIVE_ENTRY   pIpReceiveEntry = (PIP_RECEIVE_ENTRY)pkt;
+                                    PBUFFER_CB          pBufferCB, pNextBufferCB;
+                                    uint32_t            lTagVal;
+                                    uint32_t            lPacketSize;
+                                    uint16_t            wBufferCount;
+                                    uint32_t            lReceiveBufferSize;
+
+                                    /* If split buffer, set header size for 1st buffer */
+                                    if (pIpReceiveEntry->wCompletionStatus & IP_REC_STATUS_SPLIT_BUFFER)
+                                        lReceiveBufferSize = ha->wHeaderSize;
+                                    else
+                                        lReceiveBufferSize = ha->lReceiveBufferSize;
+
+                                    if ((lTagVal = pIpReceiveEntry->waBufferHandle[0]) >=
+                                    ha->wReceiveBufferCount) {
+                                        /* Invalid handle from RISC, reset RISC firmware */
+                                        printk(KERN_WARNING "qla2100_isr: bad IP buffer handle %x\n", lTagVal);
+                                        ha->flags.isp_abort_needed = TRUE;
+                                        goto InvalidIpHandle;
+                                    }
+                                    pBufferCB = &ha->pReceiveBufferCBs[lTagVal];
+
+                                    if (!(pBufferCB->lFlags &  BCB_FLAGS_RISC_OWNS_BUFFER)) {
+                                        /* Invalid handle from RISC, reset RISC firmware */
+                                        printk(KERN_WARNING "qla2100_isr: bad IP buffer handle %x\n", lTagVal);
+                                        ha->flags.isp_abort_needed = TRUE;
+                                        goto InvalidIpHandle;
+                                    }
+
+                                    /* Set buffer belongs to driver now */
+                                    pBufferCB->lFlags &= ~BCB_FLAGS_RISC_OWNS_BUFFER;
+
+                                    lPacketSize = pIpReceiveEntry->wSequenseLength;
+                                    pBufferCB->lPacketSize = lPacketSize;
+                                    pNextBufferCB = pBufferCB;
+
+                                    for (wBufferCount = 1; ; wBufferCount++) {
+                                        if (lPacketSize > lReceiveBufferSize) {
+                                            pNextBufferCB->lBufferSize = lReceiveBufferSize;
+                                            lPacketSize               -= lReceiveBufferSize;
+
+                                            /* If split buffer, only use header size on 1st buffer */
+                                            lReceiveBufferSize = ha->lReceiveBufferSize;
+
+                                            if ((lTagVal = pIpReceiveEntry->waBufferHandle[wBufferCount]) >=
+                                            ha->wReceiveBufferCount) {
+                                                /* Invalid handle from RISC, reset RISC firmware */
+                                                printk(KERN_WARNING "qla2100_isr: bad IP buffer handle %x\n", lTagVal);
+                                                ha->flags.isp_abort_needed = TRUE;
+                                                goto InvalidIpHandle;
+                                            }
+                                            pNextBufferCB->pNextBufferCB = &ha->pReceiveBufferCBs[lTagVal];;
+                                            pNextBufferCB = pNextBufferCB->pNextBufferCB;
+
+                                            if (!(pNextBufferCB->lFlags & BCB_FLAGS_RISC_OWNS_BUFFER)) {
+                                                /* Invalid handle from RISC, reset RISC firmware */
+                                                printk(KERN_WARNING "qla2100_isr: bad IP buffer handle %x\n", lTagVal);
+                                                ha->flags.isp_abort_needed = TRUE;
+                                                goto InvalidIpHandle;
+                                            }
+
+                                            /* Set buffer belongs to driver now */
+                                            pNextBufferCB->lFlags &= ~BCB_FLAGS_RISC_OWNS_BUFFER;
+                                        } else {
+                                            pNextBufferCB->lBufferSize = lPacketSize;
+                                            pNextBufferCB->pNextBufferCB = NULL;
+                                            break;
+                                        }
+                                    }
+
+                                    /* Check for incoming ARP packet with matching IP address */
+                                    if (pIpReceiveEntry->wServiceClass == 0) {
+                                        PPACKET_HEADER  pPacket = (PPACKET_HEADER)pBufferCB->pBuffer;
+                                        PIP_DEVICE_BLOCK pIpDevice;
+                                        uint8_t     acPortId[3];
+
+                                        /* Scan list of IP devices to see if login needed */
+                                        for (pIpDevice = ha->pIpDeviceTop; pIpDevice != NULL;
+                                        pIpDevice = pIpDevice->pNextIpDevice) {
+                                            if (*(uint16_t *)(&pIpDevice->acWorldWideName[2]) ==
+                                            pPacket->sNetworkHeader.wSourceAddrHigh &&
+                                            *(uint32_t *)(&pIpDevice->acWorldWideName[4]) ==
+                                            pPacket->sNetworkHeader.lSourceAddrLow) {
+                                                /* Device already in IP list, skip login */
+                                                goto SkipDeviceLogin;
+                                            }
+                                        }
+
+                                        /* Device not in list, need to do login */
+                                        acPortId[0] = pIpReceiveEntry->cS_IDHigh;
+                                        acPortId[1] = (uint8_t)(pIpReceiveEntry->wS_IDLow >> 8);
+                                        acPortId[2] = (uint8_t)pIpReceiveEntry->wS_IDLow;
+
+                                        /* Make sure its not a local device */
+                                        if (acPortId[0] == ha->port_id[0] &&
+                                        acPortId[1] == ha->port_id[1]) {
+                                            goto SkipDeviceLogin;
+                                        }
+
+                                        if (qla2x00_add_new_ip_device(ha, PUBLIC_LOOP_DEVICE,
+                                        acPortId,
+                                        (uint8_t *)&pPacket->sNetworkHeader.wSourceNAA,
+                                        TRUE) == QL_STATUS_FATAL_ERROR) {
+                                            /* Fatal error, reinitialize */
+                                            ha->flags.isp_abort_needed = TRUE;
+                                        }
+                                    }
+                                    SkipDeviceLogin:
+                                    /* Pass received packet to IP driver */
+                                    pBufferCB->wBufferCount = wBufferCount;
+
+                                    (*ha->pReturnReceivePacketsRoutine)
+                                    (ha->pReturnReceivePacketsContext,
+                                    pBufferCB);
+
+                                    /* Keep track of RISC buffer pointer (for IP reinit) */
+                                    ha->wIpBufferOut += wBufferCount;
+                                    if (ha->wIpBufferOut >= IP_BUFFER_QUEUE_DEPTH)
+                                        ha->wIpBufferOut -= IP_BUFFER_QUEUE_DEPTH;
+                                    InvalidIpHandle:
+                                    /* Adjust ring index. */
+                                    ha->rsp_ring_index++;
+                                    if( ha->rsp_ring_index == RESPONSE_ENTRY_CNT ) {
+                                        ha->rsp_ring_index = 0;
+                                        ha->response_ring_ptr = ha->response_ring;
+                                    } else
+                                        ha->response_ring_ptr++;
+                                        if (ha->device_id != QLA2300_DEVICE_ID) 
+                                            WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
+                                        else
+                                            WRT_REG_WORD(&reg2300->rsp_q_out, ha->rsp_ring_index);
+                                        continue;
+                                }
+
+                                /* Handle IP FARP request */
+                                else if (pkt->entry_type == ET_IP_FARP_REQUEST) {
+                                    PIP_FARP_REQUEST_ENTRY  pIpFarpRequestEntry;
+                                    uint8_t                 acPortId[3];
+                                    uint8_t                 acPortName[8];
+
+                                    pIpFarpRequestEntry = (PIP_FARP_REQUEST_ENTRY)pkt;
+                                    acPortId[0] = pIpFarpRequestEntry->cRequesterPortIdHigh;
+                                    acPortId[1] = (uint8_t)(pIpFarpRequestEntry->wRequesterPortIdLow >> 8);
+                                    acPortId[2] = (uint8_t)pIpFarpRequestEntry->wRequesterPortIdLow;
+                                    acPortName[0] = pIpFarpRequestEntry->acRequesterPortName[7];
+                                    acPortName[1] = pIpFarpRequestEntry->acRequesterPortName[6];
+                                    acPortName[2] = pIpFarpRequestEntry->acRequesterPortName[5];
+                                    acPortName[3] = pIpFarpRequestEntry->acRequesterPortName[4];
+                                    acPortName[4] = pIpFarpRequestEntry->acRequesterPortName[3];
+                                    acPortName[5] = pIpFarpRequestEntry->acRequesterPortName[2];
+                                    acPortName[6] = pIpFarpRequestEntry->acRequesterPortName[1];
+                                    acPortName[7] = pIpFarpRequestEntry->acRequesterPortName[0];
+
+                                    /* Login and add device to IP database */
+                                    if (qla2x00_add_new_ip_device(ha, PUBLIC_LOOP_DEVICE,
+                                    acPortId,
+                                    acPortName,
+                                    TRUE) == QL_STATUS_FATAL_ERROR) {
+                                        /* Fatal error, reinitialize */
+                                        ha->flags.isp_abort_needed = TRUE;
+                                    }
+
+                                    /* Adjust ring index. */
+                                    ha->rsp_ring_index++;
+                                    if( ha->rsp_ring_index == RESPONSE_ENTRY_CNT ) {
+                                        ha->rsp_ring_index = 0;
+                                        ha->response_ring_ptr = ha->response_ring;
+                                    } else
+                                        ha->response_ring_ptr++;
+                                        if (ha->device_id != QLA2300_DEVICE_ID) 
+                                          WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
+                                        else
+                                          WRT_REG_WORD(&reg2300->rsp_q_out, ha->rsp_ring_index);
+
+                                    continue;
+                                }
+#endif /* FC_IP_SUPPORT *******************************************/
+
+                                if( pkt->entry_type == STATUS_TYPE ||
+                                    pkt->entry_status ) {
+                                    ha->actthreads--; 
+                                    if( pkt->entry_type == STATUS_TYPE ) {
+                                        qla2100_status_entry(ha, (sts_entry_t *)pkt,
+                                        done_q_first, done_q_last);
+                                        /* DEBUG(printk("qla2100_isr: RespRingUpdate STATUS TYPE\n");) */
+                                    } else {
+                                        qla2100_error_entry(ha, pkt,
+                                        done_q_first, done_q_last);
+                                        /* DEBUG(printk("qla2100_isr: RespRingUpdate ERROR TYPE \n");)*/
+                                    }
+                                    /* Adjust ring index. */
+                                    ha->rsp_ring_index++;
+                                    if( ha->rsp_ring_index == RESPONSE_ENTRY_CNT ) {
+                                        ha->rsp_ring_index = 0;
+                                        ha->response_ring_ptr = ha->response_ring;
+                                    } else
+                                        ha->response_ring_ptr++;
+                                        if (ha->device_id != QLA2300_DEVICE_ID) 
+                                           WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
+                                        else
+                                           WRT_REG_WORD(&reg2300->rsp_q_out, ha->rsp_ring_index);
+                                } else {
+                                    pkt = &response_entry;
+
+                                    /* Copy packet. */
+                                    dptr1 = (uint32_t *)ha->response_ring_ptr;
+                                    dptr2 = (uint32_t *)pkt;
+                                    for( index = 0; index < RESPONSE_ENTRY_SIZE/4;
+                                    index++ )
+                                        *dptr2++ = *dptr1++;
+
+                                    /* Adjust ring index. */
+                                    ha->rsp_ring_index++;
+                                    if( ha->rsp_ring_index == RESPONSE_ENTRY_CNT ) {
+                                        ha->rsp_ring_index = 0;
+                                        ha->response_ring_ptr = ha->response_ring;
+                                    } else
+                                        ha->response_ring_ptr++;
+                                        if (ha->device_id != QLA2300_DEVICE_ID) 
+                                          WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
+                                        else
+                                          WRT_REG_WORD(&reg2300->rsp_q_out, ha->rsp_ring_index);
+
+                                    /* Release interrupt specific lock */
+                                    QLA2100_INTR_UNLOCK(ha);
+
+#if QLA2100_TARGET_MODE_SUPPORT
+                                    switch( pkt->entry_type ) {
+                                        case ACCEPT_TGT_IO_TYPE:
+                                            qla2100_atio_entry(ha, (atio_entry_t *)pkt);
+                                            break;
+                                        case IMMED_NOTIFY_TYPE:
+                                            qla2100_notify_ack(ha, (notify_entry_t *)pkt);
+                                            break;
+                                        default:
+                                            break;
+                                    }
+#endif   /**** FC_TARGET_MODE_SUPPORT */
+
+                                    /* Acquire interrupt specific lock */
+                                    QLA2100_INTR_LOCK(ha);
+                                }
+                            }
+                        } else {
+                            ha->flags.isp_abort_needed = TRUE;
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_isr:  $$$ Response Pointer Error $$$ mb5=\n");
+                            qla2100_output_number((u_long)mailbox[5], 16);
+                            qla2100_print(" \n");
+                            printk(KERN_WARNING "qla2100_isr: [ERROR] Response pointer Error mailbox[5]=%x\n",mailbox[5]);
+#endif
+                        }
+                    }  
+                }
+
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_isr"); 
+#endif
+}
+
+
+
+/*
+*  qla2100_rst_aen
+*      Processes asynchronous reset.
+*
+* Input:
+*      ha  = adapter block pointer.
+*/
+STATIC void
+qla2100_rst_aen(scsi_qla_host_t *ha) {
+#if QL2100_TARGET_MODE_SUPPORT
+                notify_entry_t nentry;
+#endif /* QL2100_TARGET_MODE_SUPPORT */
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_rst_aen");
+#endif
+
+                if( ha->flags.online && !ha->flags.reset_active &&
+                !ha->loop_down_timer && !ha->flags.abort_isp_active ) {
+                    ha->flags.reset_active = TRUE;
+                    do {
+                        ha->flags.reset_marker = FALSE;
+
+                        /* Issue marker command. */
+                        qla2100_marker(ha, 0, 0, 0, MK_SYNC_ALL);
+
+#if QL2100_TARGET_MODE_SUPPORT
+                        if( !ha->loop_down_timer && !ha->flags.reset_marker ) {
+                            /* Issue notify acknowledgement command. */
+                            BZERO((caddr_t)&nentry, sizeof(notify_entry_t));
+                            nentry.initiator_id = ha->id;
+                            /* dg 7/3/99 nentry.target_id = ha->id; */
+                            nentry.task_flags = BIT_13;
+                            qla2100_notify_ack(ha, &nentry);
+                        }
+#endif /* QL2100_TARGET_MODE_SUPPORT */
+                    }while( !ha->loop_down_timer && ha->flags.reset_marker );
+                    ha->flags.reset_active = FALSE;
+                }
+
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_rst_aen");
+#endif
+}
+
+#if  QLA2100_TARGET_MODE_SUPPORT
+/*
+*  qla2100_atio_entry
+*      Processes received ISP accept target I/O entry.
+*
+* Input:
+*      ha  = adapter block pointer.
+*      pkt = entry pointer.
+*/
+STATIC void
+qla2100_atio_entry(scsi_qla_host_t *ha, atio_entry_t *pkt) {
+                uint64_t  *a64;
+                uint64_t  *end_a64;
+        u_long    phy_addr[2];
+        u_long    end_addr[2];
+                uint32_t  len;
+                uint32_t  offset;
+                uint8_t   t;
+                uint8_t   *sense_ptr;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_atio_entry: entered\n");
+#endif
+
+                t = pkt->initiator_id;
+                sense_ptr = ha->tsense + t * TARGET_SENSE_SIZE;
+                a64 = (uint64_t *)&phy_addr[0];
+                end_a64 = (uint64_t *)&end_addr[0];
+
+                switch( pkt->status & ~BIT_7 ) {
+                    case 7:                         /* Path invalid */
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                        qla2100_print("qla2100_atio_entry: Path invalid\n");
+#endif
+                        break;
+                    case 0x16:                  /* Requested Capability Not Available */
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                        qla2100_print(
+                        "qla2100_atio_entry: Requested Capability Not Available\n");
+#endif
+                        break;
+                    case 0x17:                  /* Bus Device Reset Message Received */
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                        qla2100_print(
+                        "qla2100_atio_entry: Bus Device Reset Message Received\n");
+#endif
+                        break;
+                    case 0x3D:                  /* CDB Received */
+
+                        /* Check for invalid LUN */
+                        if( pkt->lun && pkt->cdb[0] != SS_INQUIR &&
+                        pkt->cdb[0] != SS_REQSEN )
+                            pkt->cdb[0] = SS_TEST;
+
+                        switch( pkt->cdb[0] ) {
+                        case SS_TEST:
+#ifdef QL_DEBUG_LEVEL_3
+                            qla2100_print("qla2100_atio_entry: SS_TEST\n");
+#endif
+                            BZERO(sense_ptr, TARGET_SENSE_SIZE);
+                            len = 0;
+                            if( pkt->lun == 0 )
+                                pkt->scsi_status = S_GOOD;
+                            else {
+                                *sense_ptr = 0x70;
+                                *(sense_ptr+2) = SD_ILLREQ;
+                                *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
+                                *(sense_ptr+12) = SC_INVLUN;
+                                pkt->scsi_status = S_CKCON;
+                            }
+                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC | OF_NO_DATA);
+                            break;
+                        case SS_REQSEN:
+#ifdef QL_DEBUG_LEVEL_3
+                            qla2100_print("qla2100_atio_entry: SS_REQSEN\n");
+#endif
+                            phy_addr[0] = ha->tsense_dma;
+                            phy_addr[1] = 0;
+                            *a64 += t * TARGET_SENSE_SIZE;
+                            if( pkt->cdb[4] > TARGET_SENSE_SIZE )
+                                len = TARGET_SENSE_SIZE;
+                            else
+                                len = pkt->cdb[4];
+                            pkt->scsi_status = S_GOOD;
+                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC | OF_DATA_IN);
+                            break;
+                        case SS_INQUIR:
+#ifdef QL_DEBUG_LEVEL_3
+                            qla2100_print("qla2100_atio_entry: SS_INQUIR\n");
+#endif
+                            BZERO(sense_ptr, TARGET_SENSE_SIZE);
+                            phy_addr[0] = ha->tbuf_dma;
+                            phy_addr[1] = 0;
+                            *a64 += TARGET_INQ_OFFSET;
+
+                            if( pkt->lun == 0 ) {
+                                    ha->tbuf->inq.id_type = ID_PROCESOR;
+                                    ha->tbuf->inq.id_pqual = ID_QOK;
+                            } else {
+                                    ha->tbuf->inq.id_type = ID_NODEV;
+                                    ha->tbuf->inq.id_pqual = ID_QNOLU;
+                            }
+
+                            if( pkt->cdb[4] > sizeof(struct ident) )
+                                len = sizeof(struct ident);
+                            else
+                                len = pkt->cdb[4];
+                            pkt->scsi_status = S_GOOD;
+                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC | OF_DATA_IN);
+                            break;
+                        case SM_WRDB:
+                            BZERO(sense_ptr, TARGET_SENSE_SIZE);
+                            offset = pkt->cdb[5];
+                            offset |= pkt->cdb[4] << 8;
+                            offset |= pkt->cdb[3] << 16;
+                            len = pkt->cdb[8];
+                            len |= pkt->cdb[7] << 8;
+                            len |= pkt->cdb[6] << 16;
+                            end_addr[0] = phy_addr[0] = ha->tbuf_dma;
+                            end_addr[1] = phy_addr[1] = 0;
+                            *end_a64 += TARGET_DATA_OFFSET + TARGET_DATA_SIZE;
+                            switch( pkt->cdb[1] & 7 ) {
+                                case RW_BUF_HDATA:
+#ifdef QL_DEBUG_LEVEL_3
+                                    qla2100_print("qla2100_atio_entry: SM_WRDB, RW_BUF_HDATA\n");
+#endif
+                                    if( len > TARGET_DATA_SIZE + 4 ) {
+#ifdef QL_DEBUG_LEVEL_2
+                                        qla2100_print("qla2100_atio_entry: SM_WRDB, length > buffer size\n");
+#endif
+                                        *sense_ptr = 0x70;
+                                        *(sense_ptr+2) = SD_ILLREQ;
+                                        *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
+                                        *(sense_ptr+12) = SC_ILLCDB;
+                                        pkt->scsi_status = S_CKCON;
+                                        pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                        OF_NO_DATA);
+                                        len = 0;
+                                    } else if( len ) {
+                                            pkt->scsi_status = S_GOOD;
+                                            pkt->flags =(uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_DATA_OUT);
+                                    } else {
+#ifdef QL_DEBUG_LEVEL_2
+                                            qla2100_print("qla2100_atio_entry: SM_WRDB, zero length\n");
+#endif
+                                            pkt->scsi_status = S_GOOD;
+                                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_NO_DATA);
+                                    }
+
+                                    break;
+                                case RW_BUF_DATA:
+#ifdef QL_DEBUG_LEVEL_3
+                                    qla2100_print("qla2100_atio_entry: SM_WRDB, RW_BUF_DATA\n");
+#endif
+                                    *a64 += offset + TARGET_DATA_OFFSET;
+                                    if( pkt->cdb[2] != 0 || *a64 >= *end_a64 ||
+                                    *a64 + len > *end_a64 ) {
+#ifdef QL_DEBUG_LEVEL_2
+                                            qla2100_print("qla2100_atio_entry: SM_WRDB, RW_BUF_DATA BAD\n");
+                                            qla2100_print("buf_id=");
+                        qla2100_output_number((u_long)pkt->cdb[2], 16);
+                        qla2100_print(", offset=");
+                        qla2100_output_number((u_long)offset, 16);
+                                            qla2100_print(", length=");
+                        qla2100_output_number((u_long)len, 16);
+                                            qla2100_print("\n");
+#endif
+                                            *sense_ptr = 0x70;
+                                            *(sense_ptr+2) = SD_ILLREQ;
+                                            *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
+                                            *(sense_ptr+12) = SC_ILLCDB;
+                                            len = 0;
+                                            pkt->scsi_status = S_CKCON;
+                                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_NO_DATA);
+                                    } else if( len ) {
+                                            pkt->scsi_status = S_GOOD;
+                                            pkt->flags =(uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_DATA_OUT);
+                                    } else {
+#ifdef QL_DEBUG_LEVEL_2
+                                            qla2100_print("qla2100_atio_entry: SM_WRDB, zero length\n");
+#endif
+                                            pkt->scsi_status = S_GOOD;
+                                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_NO_DATA);
+                                    }
+                                    break;
+                                default:
+#ifdef QL_DEBUG_LEVEL_2
+                                    qla2100_print("qla2100_atio_entry: SM_WRDB unknown mode\n");
+#endif
+                                    *sense_ptr = 0x70;
+                                    *(sense_ptr+2) = SD_ILLREQ;
+                                    *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
+                                    *(sense_ptr+12) = SC_ILLCDB;
+                                    len = 0;
+                                    pkt->scsi_status = S_CKCON;
+                                    pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                    OF_NO_DATA);
+                                    break;
+                            }
+                            break;
+                        case SM_RDDB:
+                            BZERO(sense_ptr, TARGET_SENSE_SIZE);
+                            offset = pkt->cdb[5];
+                            offset |= pkt->cdb[4] << 8;
+                            offset |= pkt->cdb[3] << 16;
+                            len = pkt->cdb[8];
+                            len |= pkt->cdb[7] << 8;
+                            len |= pkt->cdb[6] << 16;
+                            end_addr[0] = phy_addr[0] = ha->tbuf_dma;
+                            end_addr[1] = phy_addr[1] = 0;
+                            *end_a64 += TARGET_DATA_OFFSET + TARGET_DATA_SIZE;
+                            switch( pkt->cdb[1] & 7 ) {
+                                case RW_BUF_HDATA:
+#ifdef QL_DEBUG_LEVEL_3
+                                    qla2100_print("qla2100_atio_entry: SM_RDDB, RW_BUF_HDATA\n");
+#endif
+                                    if( len ) {
+                                        ha->tbuf->hdr[0] = 0;
+                                        ha->tbuf->hdr[1] =
+                                        (uint8_t)(TARGET_DATA_SIZE >> 16);
+                                        ha->tbuf->hdr[2] =
+                                        (uint8_t)(TARGET_DATA_SIZE >> 8);
+                                        ha->tbuf->hdr[3] = (uint8_t)TARGET_DATA_SIZE;
+                                        if( len > TARGET_DATA_SIZE + 4 )
+                                            len = TARGET_DATA_SIZE + 4;
+                                        pkt->scsi_status = S_GOOD;
+                                        pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                        OF_DATA_IN);
+                                    } else {
+#ifdef QL_DEBUG_LEVEL_2
+                                            qla2100_print("qla2100_atio_entry: SM_RDDB, zero length\n");
+#endif
+                                            pkt->scsi_status = S_GOOD;
+                                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_NO_DATA);
+                                    }
+                                    break;
+                                case RW_BUF_DATA:
+#ifdef QL_DEBUG_LEVEL_3
+                                    qla2100_print("qla2100_atio_entry: SM_RDDB, RW_BUF_DATA\n");
+#endif
+                                    *a64 += offset + TARGET_DATA_OFFSET;
+                                    if( pkt->cdb[2] != 0 || *a64 >= *end_a64 ) {
+#ifdef QL_DEBUG_LEVEL_2
+                                            qla2100_print("qla2100_atio_entry: SM_RDDB, RW_BUF_DATA BAD\n");
+                                            qla2100_print("buf_id=");
+                        qla2100_output_number((u_long)pkt->cdb[2], 16);
+                        qla2100_print(", offset=");
+                        qla2100_output_number((u_long)offset, 16);
+                                            qla2100_print("\n");
+#endif
+                                            *sense_ptr = 0x70;
+                                            *(sense_ptr+2) = SD_ILLREQ;
+                                            *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
+                                            *(sense_ptr+12) = SC_ILLCDB;
+                                            len = 0;
+                                            pkt->scsi_status = S_CKCON;
+                                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_NO_DATA);
+                                    } else {
+                                            if( *a64 + len > *end_a64 )
+                                                len = *end_a64 - *a64;
+                                            if( len ) {
+                                                pkt->scsi_status = S_GOOD;
+                                                pkt->flags = (uint16_t)(OF_SSTS |
+                                                OF_INC_RC | OF_DATA_IN);
+                                            } else {
+#ifdef QL_DEBUG_LEVEL_2
+                                                    qla2100_print("qla2100_atio_entry: SM_RDDB, zero length\n");
+#endif
+                                                    pkt->scsi_status = S_GOOD;
+                                                    pkt->flags = (uint16_t)(OF_SSTS |
+                                                    OF_INC_RC | OF_NO_DATA);
+                                            }
+                                    }
+                                    break;
+                                case RW_BUF_DESC:
+#ifdef QL_DEBUG_LEVEL_3
+                                    qla2100_print("qla2100_atio_entry: SM_RDDB, RW_BUF_DESC\n");
+#endif
+                                    if( len ) {
+                                            if( len > 4 )
+                                                len = 4;
+
+                                            ha->tbuf->hdr[0] = 0;
+                                            if( pkt->cdb[2] != 0 ) {
+                                                ha->tbuf->hdr[1] = 0;
+                                                ha->tbuf->hdr[2] = 0;
+                                                ha->tbuf->hdr[3] = 0;
+                                            } else {
+                                                    ha->tbuf->hdr[1] =
+                                                    (uint8_t)(TARGET_DATA_SIZE >> 16);
+                                                    ha->tbuf->hdr[2] =
+                                                    (uint8_t)(TARGET_DATA_SIZE >> 8);
+                                                    ha->tbuf->hdr[3] =
+                                                    (uint8_t)TARGET_DATA_SIZE;
+                                            }
+                                            pkt->scsi_status = S_GOOD;
+                                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_DATA_IN);
+                                    } else {
+#ifdef QL_DEBUG_LEVEL_2
+                                            qla2100_print("qla2100_atio_entry: SM_RDDB, zero length\n");
+#endif
+                                            pkt->scsi_status = S_GOOD;
+                                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                            OF_NO_DATA);
+                                    }
+                                    break;
+                                default:
+#ifdef QL_DEBUG_LEVEL_2
+                                    qla2100_print("qla2100_atio_entry: SM_RDDB unknown mode\n");
+#endif
+                                    *sense_ptr = 0x70;
+                                    *(sense_ptr+2) = SD_ILLREQ;
+                                    *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
+                                    *(sense_ptr+12) = SC_ILLCDB;
+                                    len = 0;
+                                    pkt->scsi_status = S_CKCON;
+                                    pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC |
+                                    OF_NO_DATA);
+                                    break;
+                            }
+                            break;
+                        default:
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("qla2100_atio_entry: Unknown SCSI command\n");
+                            qla2100_dump_buffer((uint8_t *)&pkt->cdb[0], MAX_CMDSZ);
+#endif
+                            BZERO(sense_ptr, TARGET_SENSE_SIZE);
+                            *sense_ptr = 0x70;
+                            *(sense_ptr+2) = SD_ILLREQ;
+                            *(sense_ptr+7) = TARGET_SENSE_SIZE-8;
+                            *(sense_ptr+12) = SC_INVOPCODE;
+                            len = 0;
+                            pkt->scsi_status = S_CKCON;
+                            pkt->flags = (uint16_t)(OF_SSTS | OF_INC_RC | OF_NO_DATA);
+                            break;
+                        }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+                        if ( ha->flags.enable_64bit_addressing )
+                            qla2100_64bit_continue_io(ha, pkt, len, &phy_addr);
+                        else
+#endif
+                        qla2100_32bit_continue_io(ha, pkt, len, &phy_addr);
+                        break;
+                    default:
+                        break;
+                }
+
+#ifdef QL_DEBUG_LEVEL_3
+                LEAVE("qla2100_atio_entry: exiting normally\n");
+#endif
+}
+#endif  /* QLA2100_TARGET_MODE_SUPPORT */
+
+/*
+*  qla2100_status_entry
+*      Processes received ISP status entry.
+*
+* Input:
+*      ha           = adapter block pointer.
+*      pkt          = entry pointer.
+*      done_q_first = done queue first pointer.
+*      done_q_last  = done queue last pointer.
+*/
+STATIC void
+qla2100_status_entry(scsi_qla_host_t *ha, sts_entry_t *pkt, srb_t **done_q_first,
+            srb_t **done_q_last) {
+                uint32_t       b, t, l;
+                uint8_t        sense_sz = 0;
+                srb_t          *sp, *sp2;
+                scsi_lu_t      *q;
+                Scsi_Cmnd       *cp;
+
+#ifdef QL_DEBUG_LEVEL_3
+                ENTER("qla2100_status_entry");
+#endif
+                /* Validate handle. */
+                if( pkt->handle < MAX_OUTSTANDING_COMMANDS )
+                    sp = ha->outstanding_cmds[pkt->handle];
+                else
+                    sp = 0;
+
+                if( sp ) {
+                    /* Free outstanding command slot. */
+                    ha->outstanding_cmds[pkt->handle] = 0;
+                    cp = sp->cmd;
+                    sp->ccode = pkt->comp_status;
+                    sp->scode = pkt->scsi_status;
+
+            sp->flags &= ~SRB_SENT;
+                    /* Generate LU queue on cntrl, target, LUN */
+                    b = SCSI_BUS_32(cp);
+                    t = SCSI_TCN_32(cp);
+                    l = SCSI_LUN_32(cp);
+                    q = GET_LU_Q(ha, b, t, l);
+
+                    /* Target busy */
+                    if( pkt->scsi_status & SS_BUSY_CONDITION &&
+                    (uint8_t)pkt->scsi_status != SS_RESERVE_CONFLICT ) {
+#ifdef QL_DEBUG_LEVEL_2
+                     qla2100_print("qla2100_status_entry: SCSI busy status, scsi(");
+                qla2100_output_number((u_long)ha->host_no, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)b, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)t, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)l, 10);
+                        qla2100_print(")\n");
+#endif
+                        sp->retry_count--;
+                        CMD_RESULT(cp) = (int) (DID_BUS_BUSY << 16) |
+                        (pkt->scsi_status & 0xff);
+
+                    }
+#if 0
+                    /* dg - 03/30      */
+                    else if( ha->loop_down_timer  ) {
+#endif
+                        else if( ha->loop_down_timer ||
+                        ha->loop_state != LOOP_READY ) {
+#ifdef QL_DEBUG_LEVEL_3
+                            qla2100_print("scsi(");
+                qla2100_output_number((u_long)ha->host_no, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)b, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)t, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)l, 10);
+                qla2100_print("): Loop Not ready - pid =");
+                qla2100_output_number((u_long)sp->cmd->pid, 16);
+                            qla2100_print("\n");
+#endif
+                            CMD_RESULT(cp) = (int) (DID_BUS_BUSY << 16);
+                        } else if( sp->port_down_retry_count > 1 &&
+                        (pkt->comp_status == CS_PORT_UNAVAILABLE ||
+                        pkt->comp_status == CS_PORT_LOGGED_OUT ||
+                        pkt->comp_status == CS_PORT_CONFIG_CHG ||
+                        pkt->comp_status == CS_PORT_BUSY) ) {
+                            /* if the port is unavaliable and we haven't exceeded the port down count */
+                            /* then send command back to the mid-level. */
+#ifdef QL_DEBUG_LEVEL_2
+                            qla2100_print("scsi(");
+                qla2100_output_number((u_long)ha->host_no, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)b, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)t, 10);
+                qla2100_print(":");
+                qla2100_output_number((u_long)l, 10);
+                            qla2100_print("): Port Down Retry Cnt =(");
+                qla2100_output_number((u_long)sp->port_down_retry_count, 10);
+                            qla2100_print("): , pid =");
+                qla2100_output_number((u_long)sp->cmd->pid, 16);
+                            qla2100_print(", status =");
+                qla2100_output_number((u_long)pkt->comp_status, 16);
+                            qla2100_print("\n");
+#endif
+                            sp->port_down_retry_count--;
+
+                            /* dg 08/17/99
+                            * Force the SCSI layer to keep retrying until our
+                            * port_down_retry_count expire. They will normally
+                            * try and reset the bus after half the retries
+                            * have completed, so double the count.
+                            */
+                            CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+
+                            /* Acquire target queue lock */
+                            if( !(q->q_flag & QLA2100_QSUSP) ) {
+                                q->q_flag |= QLA2100_QSUSP;  /* suspend starting new commands */
+
+                                /* Decrement port down count on all pending commands. */
+                                /* and return them back to OS.                        */
+                                for( sp2 = q->q_first; sp2; sp2 = sp2->s_next ) {
+#if 0
+                                    if( sp2->port_down_retry_count ) /* dg - v4.31.4 */
+                                        sp2->port_down_retry_count--;
+#endif
+                                    /*  v2.19.14  - unconditionally retry these 
+				     *	requests.
+				     */
+                                    CMD_RESULT(sp2->cmd) = DID_BUS_BUSY << 16;
+                                    qla2100_callback(ha,sp2, TRUE);
+                                }
+                                q->q_first = q->q_last = NULL;
+                                /* if port timer is not active then start it */
+                                if( !ha->queue_restart_timer ) {
+                                    ha->queue_restart_timer = PORT_RETRY_TIME;
+                                }
+                                if( TGT_Q(ha, b, t)->down_timer == 0 ) {
+                		    TGT_Q(ha, b, t)->down_timer = 
+                                        ha->port_down_retry_count * PORT_RETRY_TIME;
+				}
+                            }
+
+                            /* Release LU queue specific lock */
+                        } else {
+#ifdef QL_DEBUG_LEVEL_2
+                            if( pkt->comp_status ) {
+                                qla2100_print(
+                        "qla2100_status_entry: Compl error = ");
+                    qla2100_output_number((u_long)pkt->comp_status, 16);
+                                qla2100_print(", scsi(");
+                    qla2100_output_number((u_long)ha->host_no, 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)b, 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)t, 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)l, 10);
+                                qla2100_print("), retry count= ");
+                    qla2100_output_number((u_long)sp->port_down_retry_count, 10);
+                                qla2100_print(", pid = ");
+                    qla2100_output_number((u_long)cp->pid, 16);
+                                qla2100_print("\n");
+                            }
+#endif
+                            /* Set ISP completion status and target status byte. */
+                            CMD_RESULT(cp) = qla2100_return_status(ha, pkt, cp);
+
+                            memset((caddr_t)cp->sense_buffer, 0,sizeof(cp->sense_buffer));
+                            if( pkt->scsi_status & SS_CHECK_CONDITION ) {
+                                /* Mid-level always zero sense buffer before giving it to us */
+                                if( pkt->scsi_status & SS_SENSE_LEN_VALID ) {
+                                    if( pkt->req_sense_length < CMD_SNSLEN(cp) )
+                                        sense_sz = pkt->req_sense_length;
+                                    else
+                                        sense_sz = CMD_SNSLEN(cp) - 1;
+
+                                    BCOPY((caddr_t)&pkt->req_sense_data, cp->sense_buffer, sense_sz);
+
+                                }
+
+#ifdef QL_DEBUG_LEVEL_2
+                                qla2100_print(
+                                "qla2100_status_entry: Check condition Sense data, scsi(");
+                    qla2100_output_number((u_long)ha->host_no, 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)b, 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)t, 10);
+                    qla2100_print(":");
+                    qla2100_output_number((u_long)l, 10);
+                                qla2100_print(")\n");
+                                if( sense_sz )
+                                    qla2100_dump_buffer(cp->sense_buffer, sense_sz);
+#endif
+                            }
+                        }
+                        /* Place command on done queue. */
+                        qla2100_done_q_put(ha, sp, done_q_first, done_q_last);
+                    } else {
+#ifdef QL_DEBUG_LEVEL_2
+                        qla2100_print("qla2100_status_entry: ISP Invalid handle\n");
+#endif
+                        printk(KERN_WARNING "!qla2100: Status Entry invalid handle");
+                        ha->flags.isp_abort_needed = TRUE;
+                    }
+#ifdef QL_DEBUG_LEVEL_3
+                    LEAVE("qla2100_status_entry");
+#endif
+}
+
+/*
+*  qla2100_error_entry
+*      Processes error entry.
+*
+* Input:
+*      ha           = adapter block pointer.
+*      pkt          = entry pointer.
+*      done_q_first = done queue first pointer.
+*      done_q_last  = done queue last pointer.
+*/
+STATIC void
+qla2100_error_entry(scsi_qla_host_t *ha, response_t *pkt, srb_t **done_q_first,
+                srb_t **done_q_last) {
+                    srb_t *sp;
+
+#ifdef QL_DEBUG_LEVEL_3
+                    ENTER("qla2100_error_entry");
+#endif
+
+#ifdef QL_DEBUG_LEVEL_2
+                    if( pkt->entry_status & BIT_5 )
+                        qla2100_print("qla2100_error_entry: Invalid Entry Order\n");
+                    else if( pkt->entry_status & BIT_4 )
+                        qla2100_print("qla2100_error_entry: Invalid Entry Count\n");
+                    else if( pkt->entry_status & BIT_3 )
+                        qla2100_print("qla2100_error_entry: Invalid Entry Parameter\n");
+                    else if( pkt->entry_status & BIT_2 )
+                        qla2100_print("qla2100_error_entry: Invalid Entry Type\n");
+                    else if( pkt->entry_status & BIT_1 )
+                        qla2100_print("qla2100_error_entry: Busy\n");
+                    else
+                        qla2100_print("qla2100_error_entry: UNKNOWN flag error\n");
+#endif
+
+                    /* Validate handle. */
+                    if( pkt->handle < MAX_OUTSTANDING_COMMANDS )
+                        sp = ha->outstanding_cmds[pkt->handle];
+                    else
+                        sp = 0;
+
+                    if( sp ) {
+                        /* Free outstanding command slot. */
+                        ha->outstanding_cmds[pkt->handle] = 0;
+
+            sp->flags &= ~SRB_SENT;
+                        /* Bad payload or header */
+                        if( pkt->entry_status & (BIT_5 + BIT_4 + BIT_3 + BIT_2) ) {
+                            /* Bad payload or header, set error status. */
+                            CMD_RESULT(sp->cmd) = (int) DID_ERROR << 16;
+
+                        } else if( pkt->entry_status & BIT_1 && sp->retry_count ) /* FULL flag */
+                        {
+                            sp->retry_count--;
+                            CMD_RESULT(sp->cmd) = (int) DID_BUS_BUSY << 16;
+                        } else {
+                            /* Set error status. */
+                            CMD_RESULT(sp->cmd) =(int)  DID_ERROR << 16;
+                        }
+                        /* Place command on done queue. */
+                        qla2100_done_q_put(ha, sp, done_q_first, done_q_last);
+                    } else if( pkt->entry_type == COMMAND_A64_TYPE ||
+                    pkt->entry_type == COMMAND_TYPE ) {
+#ifdef QL_DEBUG_LEVEL_2
+                        qla2100_print("qla2100_error_entry: ISP Invalid handle\n");
+#endif
+                        printk(KERN_WARNING "!qla2100: Error Entry invalid handle");
+                        ha->flags.isp_abort_needed = TRUE;
+                    }
+
+#ifdef QL_DEBUG_LEVEL_3
+                    LEAVE("qla2100_error_entry");
+#endif
+}
+
+/*
+*  qla2100_abort_isp
+*      Resets ISP and aborts all outstanding commands.
+*
+* Input:
+*      ha           = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+STATIC uint8_t
+qla2100_abort_isp(scsi_qla_host_t *ha) {
+                    uint16_t       cnt;
+                    srb_t          *sp;
+                    scsi_lu_t      *q;
+                    uint32_t       b, t, l;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+                    unsigned long cpu_flags = 0;
+#endif
+                    uint8_t        status = 0;
+
+                    ENTER("qla2100_abort_isp");
+
+                    DRIVER_LOCK
+                    ha->flags.isp_abort_needed = FALSE;
+                    if( !ha->flags.abort_isp_active && ha->flags.online ) {
+                        ha->flags.abort_isp_active = TRUE;
+                        ha->flags.online = FALSE;
+	                ha->dpc_flags &= ~COMMAND_WAIT_NEEDED;
+	                ha->dpc_flags &= ~COMMAND_WAIT_ACTIVE;
+                        qla2100_stats.ispAbort++;
+                        ha->isp_aborts++; 
+                        ha->sns_retry_cnt = 0;
+                        printk(KERN_INFO
+                        "qla2100: Performing ISP error recovery - ha= %p\n",
+                         (void *) ha);
+                        qla2100_reset_chip(ha);
+
+                        if( ha->loop_state != LOOP_DOWN ) {
+                            ha->loop_state = LOOP_DOWN;
+                            ha->loop_down_timer = LOOP_DOWN_TIME;
+                        }
+
+#ifdef FC_IP_SUPPORT
+                        /* Return all IP send packets */
+                        for (cnt = 0; cnt < MAX_SEND_PACKETS; cnt++) {
+                            if (ha->apActiveIpQueue[cnt] != NULL) {
+                                (*ha->pSendCompletionRoutine)(ha->apActiveIpQueue[cnt]);
+
+                                ha->apActiveIpQueue[cnt] = NULL;
+                            }
+                        }
+#endif
+
+                        /* Requeue all commands in outstanding command list. */
+                        for( cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS; cnt++ ) {
+                            sp = ha->outstanding_cmds[cnt];
+                            if( sp ) {
+                                ha->outstanding_cmds[cnt] = 0;
+                                /* Generate LU queue on controller, target, LUN */
+                                b = SCSI_BUS_32(sp->cmd);
+                                t = SCSI_TCN_32(sp->cmd);
+                                l = SCSI_LUN_32(sp->cmd);
+                                if ((q = (scsi_lu_t *)GET_LU_Q(ha, b, t, l))) {
+                                    /* Reset outstanding command count. */
+                                    q->q_outcnt = 0;
+                                    q->q_flag &= ~QLA2100_QBUSY;
+                                }
+                                /* sp->flags &= ~(SRB_SENT | SRB_TIMEOUT); */
+                                sp->flags = 0;
+                                /* we need to send the command back to OS */
+                                CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+                                CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+                                qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+                            }
+                        }
+
+                        if( ha->device_id == QLA2100_DEVICE_ID )
+                            qla2100_nvram_config(ha);
+                        else
+                            qla2200_nvram_config(ha);
+
+						/* v2.19.12 */	
+		        		ha->retry_count = ql2xretrycount;
+                        if( !qla2100_configure_loop(ha, TRUE) ) {
+                            ha->flags.reset_marker = FALSE;
+
+                            if( !ha->loop_down_timer )
+                                qla2100_marker(ha, 0, 0, 0, MK_SYNC_ALL);
+
+                            ha->flags.online = TRUE;
+
+                            /* Enable target response to SCSI bus. */
+                            if( ha->flags.enable_target_mode )
+                                qla2100_enable_lun(ha);
+
+#ifdef FC_IP_SUPPORT
+                            /* Reenable IP support */
+                            if (ha->flags.enable_ip)
+                                qla2x00_ip_initialize(ha);
+#endif
+                            /* Enable ISP interrupts. */
+                            qla2100_enable_intrs(ha);
+
+                            /* v2.19.5b6 Return all commands */
+                            qla2100_abort_queues(ha, TRUE);
+                            
+                            /* Restart queues that may have been stopped. */
+                            ha->flags.abort_isp_active = FALSE;
+                            /* 6/9 if( !ha->loop_down_timer ) */
+                                qla2100_restart_queues(ha,TRUE);
+                        } else {
+                            printk(KERN_WARNING
+                            "qla2100: ISP error recovery failed, board disabled");
+                            qla2100_reset_adapter(ha);
+                            qla2100_abort_queues(ha, FALSE);
+                        }
+                    }
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                    if( status )
+                        qla2100_print("qla2100_abort_isp: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                    else
+                        LEAVE("qla2100_abort_isp");
+#endif
+                    return(status);
+}
+/*
+*  qla2100_restart_watchdog_queue
+*      Restart device queues.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_restart_watchdog_queue(scsi_qla_host_t *ha) {
+                    srb_t  *sp, *sp_next;
+
+                    for( sp = ha->retry_q_first; (sp); sp = sp_next ) {
+                        sp_next = sp->s_next;
+                        /* when time expire return request back to OS as BUSY */
+                        qla2100_timeout_remove(ha, sp);
+                        CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+                        CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+                        qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+                    }
+
+}
+
+/*
+*  qla2100_restart_queues
+*      Restart device queues.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_restart_queues(scsi_qla_host_t *ha, uint8_t flush) {
+                    scsi_lu_t *q;
+                    uint32_t  b, t, l;
+                    srb_t  *sp, *sp_next;
+                    srb_t        *done_q_first = (srb_t *) NULL;
+                    srb_t        *done_q_last = (srb_t *) NULL;
+                    int cnt;
+                    unsigned long cpu_flags = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+                    ENTER("qla2100_restart_queues");
+#endif
+
+                    ha->flags.restart_queues_needed = FALSE;
+
+                    /*
+                    * start all queues working again.
+                    */
+                    for( b = 0; b < MAX_BUSES; b++ )
+                        for( t = 0; t < ha->max_targets; t++ ) {
+                            if( TGT_Q(ha, b, t)  == NULL )
+                                continue;
+                            for( l = 0; l < ha->max_luns; l++ ) {
+                                q = (scsi_lu_t *) GET_LU_Q(ha, b, t, l);
+                                if( q != NULL ) {
+                                    q->q_flag &= ~QLA2100_QSUSP;
+                                    if( q->q_first )
+                                        qla2100_next(ha, q);
+                                }
+                            }
+                        }
+
+                        /*
+                        * Clear out our retry queue
+                        */
+                        if( flush ) {
+                            for( sp = ha->retry_q_first; (sp); sp = sp_next ) {
+                                sp_next = sp->s_next;
+                                /* when time expire return request back to OS as BUSY */
+                                qla2100_timeout_remove(ha, sp);
+                                CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+                                CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+                                qla2100_done_q_put(ha, sp, (srb_t **)&done_q_first, (srb_t **)&done_q_last);
+                            }
+
+                            /* Callback everything in done queue */
+                    	    cnt = 0;
+                            while( done_q_first ) {
+                                QLA2100_TIMER_LOCK(ha);
+                                /* remove command from done list */
+                                sp = done_q_first;
+                                if( !(done_q_first = sp->s_next) )
+                                    done_q_last = NULL;
+                                else
+                                    (done_q_first)->s_prev = NULL;
+                                cnt++;
+                                qla2100_stats.done_q_cnt--;
+                                DEBUG(sp->state = 5;)
+                                QLA2100_TIMER_UNLOCK(ha);
+                                /* DEBUG(sprintf(debug_buff,
+                                  "qla2100_restart_queues: callback pid %d\n",
+                                  sp->cmd->pid);)
+                                  DEBUG(qla2100_print(debug_buff);) */
+                                qla2100_callback(ha,sp,FALSE);
+                            }
+                            DEBUG(sprintf(debug_buff,"qla2100_restart_queues: callback %d commands.\n",cnt);)
+                            DEBUG(qla2100_print(debug_buff);)
+                      }
+
+#ifdef QL_DEBUG_LEVEL_3
+                            LEAVE("qla2100_restart_queues");
+#endif
+}
+
+/*
+*  qla2100_abort_queues
+*      Abort all commands on device queues.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_abort_queues(scsi_qla_host_t *ha, uint8_t doneqflg) {
+                    scsi_lu_t   *q;
+                    uint32_t    b, t, l;
+                    srb_t       *sp, *sp_next;
+
+#ifdef QL_DEBUG_LEVEL_3
+                    ENTER("qla2100_abort_queues");
+#endif
+                    ha->flags.abort_queue_needed = FALSE;
+
+                    for( b = 0; b < MAX_BUSES; b++ )
+                        for( t = 0; t < ha->max_targets; t++ ) {
+                            if( TGT_Q(ha, b, t) == NULL )
+                                continue;
+                            for( l = 0; l < MAX_LUNS; l++ ) {
+                                q = GET_LU_Q(ha, b, t, l);
+                                if( q != NULL ) {
+                                    /* Try to acquire LU queue specific lock */
+                                    /* if( queue is not busy )
+                                    { */
+                                    sp = q->q_first;
+                                    q->q_first = q->q_last = NULL;
+
+                                    while( sp ) {
+                                        q->q_incnt--;
+                                        sp_next = sp->s_next;
+                                        CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+                                        if ( doneqflg ) {
+                                            CMD_HANDLE(sp->cmd) = (unsigned char *) NULL;
+                                            qla2100_done_q_put(ha, sp, (srb_t **)&ha->done_q_first, (srb_t **)&ha->done_q_last);
+                                        } else
+                                            qla2100_callback(ha,sp,FALSE);
+                                        sp = sp_next;
+                                    }
+                                    /* }
+                                    else
+                                    ha->flags.abort_queue_needed = TRUE;
+                                    */
+                                }
+                            }
+                        }
+
+#ifdef QL_DEBUG_LEVEL_3
+                        LEAVE("qla2100_abort_queues");
+#endif
+}
+
+/*
+*  qla2100_update_config
+*      Restart RISC in order to update the connection mode.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+uint8_t
+qla2100_update_config(scsi_qla_host_t *ha) {
+                    uint8_t   status = 0;
+
+#ifdef QL_DEBUG_LEVEL_3
+                    qla2100_print("qla2100_update_config: entered\n");
+#endif
+                    /* Turn-off flag, so we don't get called again */
+                    ha->flags.update_config_needed = FALSE;
+
+                    /* get the new topology */
+                    qla2100_configure_hba(ha);
+
+                    ha->init_cb->additional_firmware_options.connection_options = ha->operating_mode;
+                    DEBUG(printk("qla2100_update_config: Setting new topology to %d\n" , ha->operating_mode);)
+
+                    qla2100_reset_chip(ha);
+
+                    if( ha->loop_state != LOOP_DOWN ) {
+                        ha->loop_state = LOOP_DOWN;
+                        ha->loop_down_timer = LOOP_DOWN_TIME;
+                    }
+
+                    if( !(status = qla2100_configure_loop(ha, TRUE)) ) {
+                        ha->flags.reset_marker = FALSE;
+                        if( !ha->loop_down_timer )
+                            qla2100_marker(ha, 0, 0, 0, MK_SYNC_ALL);
+
+                        ha->flags.online = TRUE;
+
+                        /* Enable target response to SCSI bus. */
+                        if( ha->flags.enable_target_mode )
+                            qla2100_enable_lun(ha);
+
+                    }
+
+                    /* Enable ISP interrupts. */
+                    qla2100_enable_intrs(ha);
+                    /* WRT_REG_WORD(&reg->ictrl, ISP_EN_INT + ISP_EN_RISC); */
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                    if( status )
+                        qla2100_print("qla2100_update_config: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                    else
+                        qla2100_print("qla2100_update_config: exiting normally\n");
+#endif
+                    return(status);
+}
+
+/*
+*  qla2100_loop_resync
+*      Resync with fibre channel devices.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+STATIC uint8_t
+qla2100_loop_resync(scsi_qla_host_t *ha) {
+                    uint8_t   status;
+
+#ifdef QL_DEBUG_LEVEL_3
+                    ENTER("qla2100_loop_resync");
+#endif
+
+                    ha->loop_state = LOOP_UPDATE;
+                    if( ha->flags.online && !ha->flags.loop_resync_active &&
+                    !ha->flags.abort_isp_active ) {
+                        ha->flags.loop_resync_active = TRUE;
+                        if( !(status = qla2100_fw_ready(ha)) ) {
+                            do {
+                                ha->flags.loop_resync_needed = FALSE;
+                                /* v2.19.05b6 */
+                                ha->loop_state = LOOP_UPDATE;
+
+                                /* Issue marker command. */
+                                qla2100_marker(ha, 0, 0, 0, MK_SYNC_ALL);
+
+                                /* Remap devices on Loop. */
+                                qla2100_update_fc_db(ha, TRUE);
+
+                            }while( !ha->loop_down_timer && ha->flags.loop_resync_needed );
+                        }
+                        ha->flags.loop_resync_active = FALSE;
+                        /* v2.19 - we don't want to call this if we are already
+                         * in the loop resync code
+                         */
+                        qla2100_restart_queues(ha,TRUE);
+                    } else
+                        status = 0;
+
+                    /* Restart queues that may have been stopped. */
+                    /* 04/10 if( !ha->loop_down_timer ) {
+                        qla2100_restart_queues(ha,TRUE);
+                    } */
+                    /* v2.19 */ 
+                    /* deleted qla2100_restart_queues(ha,TRUE); */
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3)
+                    if( status )
+                        qla2100_print("qla2100_loop_resync: **** FAILED ****\n");
+#endif
+#ifdef QL_DEBUG_LEVEL_3
+                    else
+                        LEAVE("qla2100_loop_resync");
+#endif
+                    return(status);
+}
+
+/*
+* qla2100_debounce_register
+*      Debounce register.
+*
+* Input:
+*      port = register address.
+*
+* Returns:
+*      register value.
+*/
+STATIC uint16_t
+qla2100_debounce_register(volatile uint16_t *addr) {
+                    volatile uint16_t ret;
+                    volatile uint16_t ret2;
+
+                    do {
+                        ret = RD_REG_WORD(addr);
+                        ret2 = RD_REG_WORD(addr);
+                    }while( ret != ret2 );
+
+                    return(ret);
+}
+                
+/* qla2100_cmd_wait
+*	Stall driver until all outstanding commands are returned.
+*
+* Input:
+*	ha = adapter state pointer.
+*
+* Return;
+*  0 -- Done
+*  1 -- continue;
+*
+* Context:
+*	Kernel context.
+*/
+STATIC uint8_t
+qla2100_cmd_wait(scsi_qla_host_t *ha) {
+	    uint16_t index;
+	    uint8_t stat = 1;
+
+	    ENTER("qla2200_cmd_wait: started\n");
+
+	    /* Wait for all outstanding commands to be returned. */
+	    for (index = 1; index < MAX_OUTSTANDING_COMMANDS; index++) {
+		    if (ha->outstanding_cmds[index] == NULL)
+			    continue;
+                
+            /* if command not completed then wait for it */
+            if (ha->flags.isp_abort_needed){
+	        stat = 0;
+                break;
+            }
+                
+	    if( (ha->dpc_flags & COMMAND_WAIT_ACTIVE) &&
+		 ha->cmd_wait_cnt-- == 0 ) {
+                   ha->flags.isp_abort_needed = TRUE;
+	           DEBUG(printk("qla2200_cmd_wait: ISP abort %d\n",index);)
+	    } else {
+    	       ha->cmd_wait_cnt = 30;
+	       ha->dpc_flags |= COMMAND_WAIT_ACTIVE;
+            }
+
+	    DEBUG5( if( (ha->dpc_flags & COMMAND_WAIT_ACTIVE) ) )
+	    DEBUG5(printk("qla2200_cmd_wait: on handle %d - cnt %d\n",index,ha->cmd_wait_cnt);)
+
+            }
+
+	if (index == MAX_OUTSTANDING_COMMANDS ||
+            ha->flags.isp_abort_needed) {
+	   ha->dpc_flags &= ~COMMAND_WAIT_NEEDED;
+	   ha->dpc_flags &= ~COMMAND_WAIT_ACTIVE;
+	   stat = 0;
+        }
+        return( stat );
+}
+
+/*
+* qla2100_reset_chip
+*      Reset ISP chip.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+STATIC void
+qla2100_reset_chip(scsi_qla_host_t *ha) {
+                    uint32_t     cnt;
+                    device_reg_t *reg = ha->iobase;
+
+#ifdef QL_DEBUG_LEVEL_3
+                    ENTER("qla2100_reset_chip");
+#endif
+
+                    /* Disable ISP interrupts. */
+                    qla2100_disable_intrs(ha);
+                    /* WRT_REG_WORD(&reg->ictrl, 0); */
+
+#if 1
+                    /* Pause RISC. */
+                    WRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);
+                    for (cnt = 0; cnt < 30000; cnt++) {
+                        if ((RD_REG_WORD(&reg->host_cmd) & HC_RISC_PAUSE) != 0)
+                            break;
+                        else
+                            udelay(100);
+                    }
+
+                    /* Select FPM registers. */
+                    WRT_REG_WORD(&reg->ctrl_status, 0x20);
+
+                    /* FPM Soft Reset. */
+                    WRT_REG_WORD(&reg->fpm_diag_config, 0x100);
+
+                    /* Select frame buffer registers. */
+                    WRT_REG_WORD(&reg->ctrl_status, 0x10);
+
+                    /* Reset frame buffer FIFOs. */
+                    WRT_REG_WORD(&reg->fb_cmd, 0xa000);
+
+                    /* Select RISC module registers. */
+                    WRT_REG_WORD(&reg->ctrl_status, 0);
+
+                    /* Reset RISC module. */
+                    WRT_REG_WORD(&reg->host_cmd, HC_RESET_RISC);
+
+                    /* Reset ISP semaphore. */
+                    WRT_REG_WORD(&reg->semaphore, 0);
+
+                    /* Release RISC module. */
+                    WRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);
+
+                    /* Wait for RISC to recover from reset. */
+                    for (cnt = 0; cnt < 30000; cnt++) {
+                        if (RD_REG_WORD(&reg->mailbox0) != MBS_BUSY)
+                            break;
+                        else
+                            udelay(100);
+                    }
+
+                    /* Disable RISC pause on FPM parity error. */
+                    WRT_REG_WORD(&reg->host_cmd, HC_DISABLE_PARITY_PAUSE);
+#else
+                    /* Insure mailbox registers are free. */
+                    WRT_REG_WORD(&reg->semaphore, 0);
+                    WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+                    WRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);
+
+                    /* clear mailbox busy */
+                    ha->flags.mbox_busy = FALSE;
+
+                    /* Reset ISP chip. */
+                    WRT_REG_WORD(&reg->ctrl_status, ISP_RESET);
+
+                    /*
+                    * Delay after reset, for chip to recover.
+                    * Otherwise causes system PANIC
+                    */
+                    mdelay(2);
+
+                    for( cnt = 30000; cnt; cnt-- ) {
+                        if( !(RD_REG_WORD(&reg->ctrl_status) & ISP_RESET) )
+                            break;
+                        udelay(100);
+                    }
+
+                    /* Reset RISC processor. */
+                    WRT_REG_WORD(&reg->host_cmd, HC_RESET_RISC);
+                    WRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);
+                    for( cnt = 30000; cnt; cnt-- ) {
+                        if( RD_REG_WORD(&reg->mailbox0) != MBS_BUSY )
+                            break;
+                        udelay(100);
+                    }
+#endif
+
+#ifdef QL_DEBUG_LEVEL_3
+                    LEAVE("qla2100_reset_chip");
+#endif
+}
+                
+                
+#ifdef RCSN
+/*
+* qla2100_device_resync
+*	Marks devices in the database that needs resynchronization.
+*
+* Input:
+*	ha = adapter block pointer.
+*
+* Context:
+*	Kernel context.
+*/
+STATIC void
+qla2100_device_resync(scsi_qla_host_t *ha) {
+                    uint16_t index;
+                    uint32_t mask;
+                    rscn_t dev;
+                    port_id_t p;
+
+                    ENTERT("qla2100_device_resync:");
+                    while (ha->rscn_out_ptr != ha->rscn_in_ptr ||
+                    ha->device_flags & RSCN_QUEUE_OVERFLOW) {
+                        INTR_LOCK(ha);
+                        BCOPY(&ha->rscn_queue[ha->rscn_out_ptr],
+                          &dev,	sizeof (rscn_t));
+ 
+                        ha->rscn_out_ptr++;
+                        if (ha->rscn_out_ptr == MAX_RSCN_COUNT)
+                            ha->rscn_out_ptr = 0;
+
+                        /* Queue overflow, set switch default case. */
+                        if (ha->device_flags & RSCN_QUEUE_OVERFLOW) {
+                            dev.format = 3;
+                            ha->device_flags = ha->device_flags & ~RSCN_QUEUE_OVERFLOW;
+                        }
+
+                        switch (dev.format) {
+                            case 0:
+                                mask = 0xffffff;
+                                break;
+                            case 1:
+                                mask = 0xffff00;
+                                break;
+                            case 2:
+                                mask = 0xff0000;
+                                break;
+                            default:
+                                mask = 0x0;
+                                dev.d_id.b24 = 0;
+                                ha->rscn_out_ptr = ha->rscn_in_ptr;
+                                break;
+                        }
+                        INTR_UNLOCK(ha);
+
+                        for (index = 0; index < MAX_FIBRE_DEVICES; index++) {
+                            p.b.b24 = dev.d_id.b24;
+                            if (ha->fc_db[index].flags & DEV_PUBLIC &&
+                            ha->fc_db[index].port_id[2] == p.r.port_id[2] &&
+                            ha->fc_db[index].port_id[1] == p.r.port_id[1] &&
+                            ha->fc_db[index].port_id[0] == p.r.port_id[0]  )
+                                if (ha->fc_db[index].loop_id <= SNS_LAST_LOOP_ID)
+                                    printk(KERN_INFO "qla2100_device_resync: %d:%d:%d\n",
+                                    ha->fc_db[index].port_id[2] ,
+                                    ha->fc_db[index].port_id[1] ,
+                                    ha->fc_db[index].port_id[0] )
+                                    ha->fc_db[index].flags |= DEV_MISSING;
+                        }
+                    }
+                }
+
+                LEAVE("qla2100_device_resync: exiting normally");
+}
+#endif /* RCSN */
+
+#ifdef   GET_PORT_INFO
+
+/*
+* qla2100_get_port_database
+*	Issue enhanced get port database mailbox command
+*	and copy device name as necessary.
+*
+* Input:
+*	ha = adapter state pointer.
+*	dev = structure pointer.
+*	opt = mailbox 1 option byte.
+*
+* Returns:
+*	qla2100 local function return status code.
+*
+* Context:
+*	Kernel context.
+*/
+STATIC int
+qla2100_get_port_database(scsi_qla_host_t *ha, fcdev_t *dev, uint8_t opt) {
+                int rval = 0;
+                port_database_t *pd;
+                u_long      phys_address = 0;
+                uint16_t    mb[MAILBOX_REGISTER_COUNT];
+
+                ENTER("qla2200_get_port_database:");
+/* 4.10 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                pd = KMALLOC(PORT_DATABASE_SIZE);
+                if ( pd != NULL ) {
+                     phys_address = VIRT_TO_BUS(pd);
+                     BZERO((caddr_t)pd, PORT_DATABASE_SIZE);
+                }
+#else
+                pd  = pci_alloc_consistent(ha->pdev,
+                                           PORT_DATABASE_SIZE,
+                                           &phys_address);
+                BZERO((caddr_t)pd, PORT_DATABASE_SIZE);
+#endif
+                if( pd  == NULL ) {
+                    return 2;
+                }
+                BZERO((caddr_t)pd, PORT_DATABASE_SIZE);
+
+                mb[0] = MBC_GET_PORT_DATABASE;
+                mb[1] = dev->loop_id << 8 | opt;
+                mb[2] = MSW(phys_address);
+                mb[3] = LSW(phys_address);
+                mb[6] = 0;
+                mb[7] = 0;
+                if( !qla2100_mailbox_command(ha,
+                BIT_7|BIT_6|BIT_3|BIT_2|BIT_1|BIT_0,
+                &mb[0]) ) {
+                    /* Get d_id of device. */
+                    /*
+                    dev->d_id.b.al_pa = pd->port_id[2];
+                    dev->d_id.b.area = pd->port_id[3];
+                    dev->d_id.b.domain = pd->port_id[0];
+                    dev->d_id.b.rsvd_1 = 0;
+                    */
+
+                    /* Get initiator status of device. */
+                    pd->prli_svc_param_word_3[0] & BIT_5 ?
+                    (dev->flags = dev->flags | DEV_INITIATOR) :
+                    (dev->flags = dev->flags & ~DEV_INITIATOR);
+                } else {
+                    printk(KERN_WARNING "qla2200_get_port_database: [ERROR] failed");
+                    rval = 1;
+                }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+                KMFREE(pd, PORT_DATABASE_SIZE);
+#else
+                pci_free_consistent(ha->pdev, PORT_DATABASE_SIZE,
+                                    pd, phys_address);
+#endif
+                LEAVE("qla2200_get_port_database:");
+
+                return (rval);
+}
+#endif
+
+/*
+*  qla2100_configure_loop
+*      Resync with fibre channel devices.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+
+STATIC uint8_t qla2100_configure_loop(scsi_qla_host_t *ha, uint8_t reuse) {
+                uint8_t status = 0;
+
+                /* If firmware needs to be loaded */
+                if( qla2100_isp_firmware(ha) ) {
+                    ha->flags.online = FALSE;
+                    if( !(status = qla2100_chip_diag(ha)) )
+                        status = qla2100_setup_chip(ha);
+                }
+
+                if( !status && !(status = qla2100_init_rings(ha)) ) {
+                    if( !qla2100_fw_ready(ha) ) {
+                        ha->flags.reset_marker = FALSE;
+                        do {
+                            ha->flags.loop_resync_needed = FALSE;
+                            /* remap devices on loop */
+                            qla2100_update_fc_db(ha, reuse);
+                        }while( !ha->loop_down_timer && ha->flags.loop_resync_needed );
+                    }
+                }
+                return(status);
+}
+
+/*
+ * This routine will wait for fabric devices for
+ * the reset delay.
+ */ 
+void qla2100_check_fabric_devices(scsi_qla_host_t *ha) {
+               uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+               mb[0] = MBC_GET_FIRMWARE_STATE;
+               qla2100_mailbox_command(ha, BIT_0, &mb[0]);
+}
+
+#if QLA2100_EXT_TIMEOUT
+/*
+* qla2100_extend_timeout
+*      This routine will extend the timeout to the specified value.
+*
+* Input:
+*      cmd = SCSI command structure
+*
+* Returns:
+*      None.
+*/
+static void qla2100_extend_timeout(Scsi_Cmnd *cmd, int timeout) {
+                del_timer(&cmd->eh_timeout);
+                cmd->eh_timeout.expires = jiffies + timeout;
+                add_timer(&cmd->eh_timeout);
+}
+#endif
+/*
+* qla2100_display_fc_names
+*      This routine will the node names of the different devices found
+*      after port inquiry.
+*
+* Input:
+*      cmd = SCSI command structure
+*
+* Returns:
+*      None.
+*/
+STATIC void qla2100_display_fc_names(scsi_qla_host_t *ha) {
+	uint16_t	index;
+
+	/* Display the node name for adapter */
+	printk(KERN_INFO
+	    "scsi-qla%d-adapter-node=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+	    (int)ha->instance,
+	    ha->init_cb->node_name[0],
+	    ha->init_cb->node_name[1],
+	    ha->init_cb->node_name[2],
+	    ha->init_cb->node_name[3],
+	    ha->init_cb->node_name[4],
+	    ha->init_cb->node_name[5],
+	    ha->init_cb->node_name[6],
+	    ha->init_cb->node_name[7]);
+
+	/* display the port name for adapter */
+	printk(KERN_INFO
+	    "scsi-qla%d-adapter-port=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+	    (int)ha->instance,
+	    ha->init_cb->port_name[0],
+	    ha->init_cb->port_name[1],
+	    ha->init_cb->port_name[2],
+	    ha->init_cb->port_name[3],
+	    ha->init_cb->port_name[4],
+	    ha->init_cb->port_name[5],
+	    ha->init_cb->port_name[6],
+	    ha->init_cb->port_name[7]);
+
+	/* Print out device port names */
+	for (index = 0; index < MAX_FIBRE_DEVICES; index++) {
+		if (ha->fc_db[index].loop_id == PORT_UNUSED ||
+		    ha->fc_db[index].loop_id == PORT_AVAILABLE )
+			continue;
+
+#if USE_PORTNAME
+		printk(KERN_INFO
+		    "scsi-qla%d-target-%d=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+		    (int)ha->instance, index,
+		    ha->fc_db[index].wwn[0],
+		    ha->fc_db[index].wwn[1],
+		    ha->fc_db[index].wwn[2],
+		    ha->fc_db[index].wwn[3],
+		    ha->fc_db[index].wwn[4],
+		    ha->fc_db[index].wwn[5],
+		    ha->fc_db[index].wwn[6],
+		    ha->fc_db[index].wwn[7]);
+#else
+		printk(KERN_INFO
+		    "scsi-qla%d-target-%d=%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+		    (int)ha->instance, index,
+		    ha->fc_db[index].name[0],
+		    ha->fc_db[index].name[1],
+		    ha->fc_db[index].name[2],
+		    ha->fc_db[index].name[3],
+		    ha->fc_db[index].name[4],
+		    ha->fc_db[index].name[5],
+		    ha->fc_db[index].name[6],
+		    ha->fc_db[index].name[7]);
+#endif
+	}
+}
+
+/*
+* qla2100_find_propname
+*	Get property in database.
+*
+* Input:
+*	ha = adapter structure pointer.
+*      db = pointer to database
+*      propstr = pointer to dest array for string
+*	propname = name of property to search for.
+*
+* Returns:
+*	0 = no property
+*  value = index of property value.
+*
+* Context:
+*	Kernel context.
+*/
+STATIC uint8_t
+qla2100_find_propname(scsi_qla_host_t *ha,
+            char *propname, char *propstr, char *db) {
+                char	*np, *cp;
+                int   i,k,l;
+
+                /* find the specified string */
+                for( l=0, cp = db; (*cp) && l < strlen(db) ; cp = np, l++ ) {
+                    np = qla2100_get_line(cp, propstr);
+                    DEBUG5(printk("qla2100_find_propname: %d - Searching for {%s} in cmd substr: {%s}, next line: {%s} \n",l,propname,propstr, np);)
+                    /* find the property name */
+                    k = strlen(propname);
+                    for ( i = 0; (propstr[i]) && i < strlen(db); i++ ) {
+                        if( BCMP(propname,&propstr[i],k) == 0) {
+                            DEBUG5(printk("qla2100_find_propname: found at index = %d\n",i+k );)
+                            return (i+k);   /* match */
+                        }
+                    }
+                }
+                return (0);
+}
+
+
+
+/*
+* qla2100_get_prop_16chars
+*	Get an 8-byte property value for the specified property name by
+*      converting from the property string found in the configuration file.
+*      The resulting converted value is in big endian format (MSB at byte0).
+*
+* Input:
+*	ha = adapter state pointer.
+*	propname = property name pointer.
+*	propval  = pointer to location for the converted property val.
+*       db = pointer to database
+*
+* Returns:
+*	0 = value returned successfully.
+*
+* Context:
+*	Kernel context.
+*/
+static int
+qla2100_get_prop_16chars(scsi_qla_host_t *ha,  char *propname,
+    char *propval, char *db) {
+	char		*propstr;
+	int		i, k;
+	int		rval;
+	uint8_t		nval;
+	uint8_t		*pchar;
+	uint8_t		*ret_byte;
+	uint8_t		*tmp_byte;
+	uint8_t		*retval = (uint8_t*)propval;
+	uint8_t		tmpval[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	uint16_t	max_byte_cnt = 8; /* 16 chars = 8 bytes */
+	uint16_t	max_strlen = 16;
+	char		buf[LINESIZE];
+
+	rval = qla2100_find_propname(ha, propname, buf, db);
+	if ( rval >= LINESIZE )
+		rval = 0;
+	    
+	propstr = &buf[rval];
+	if ( *propstr == '=' )
+		propstr++;   /* ignore equal sign */
+
+	if (rval == 0 ) {
+		return (1);
+	}
+
+	if (strlen(propstr) != max_strlen) {
+		printk(KERN_INFO
+		    "qla2x00: Failed to find prop for %s - rval=%d, "
+		    "strlen(propstr)=%d->(16), val=%s.\n",
+		    propname, rval, (int)strlen(propstr),propstr);
+		return (1);
+	}
+
+	/* Convert string to numbers. */
+
+	pchar = (uint8_t *)propstr;
+	tmp_byte = (uint8_t *)tmpval;
+
+	rval = 0;
+	for (i = 0; i < max_strlen; i++) {
+		/*
+		* Check for invalid character, two at a time,
+		* then convert them starting with first byte.
+		*/
+
+		if ((pchar[i] >= '0') && (pchar[i] <= '9')) {
+			nval = pchar[i] - '0';
+		} else if ((pchar[i] >= 'A') && (pchar[i] <= 'F')) {
+			nval = pchar[i] - 'A' + 10;
+		} else if ((pchar[i] >= 'a') && (pchar[i] <= 'f')) {
+			nval = pchar[i] - 'a' + 10;
+		} else {
+			/* invalid character */
+			rval = 1;
+			break;
+		}
+
+		if (i & BIT_0) {
+			*tmp_byte = *tmp_byte | nval;
+			tmp_byte++;
+		} else {
+			*tmp_byte = *tmp_byte | nval << 4;
+		}
+	}
+
+	if (rval != 0) {
+		/* Encountered invalid character. */
+		return (rval);
+	}
+
+	/* Copy over the converted value. */
+
+	ret_byte = retval;
+	tmp_byte = tmpval;
+
+	i = max_byte_cnt;
+	k = 0;
+	while (i--) {
+		*ret_byte++ = *tmp_byte++;
+	}
+
+	/* big endian retval[0]; */
+	return (0);
+}
+
+/*
+* qla2100_get_properties
+*	Find all properties for the specified adapeter in
+*      command line.
+*
+* Input:
+*	ha = adapter block pointer.
+*	cmdline = pointer to command line string
+*
+* Context:
+*	Kernel context.
+*/
+static void
+qla2100_get_properties(scsi_qla_host_t *ha, char *cmdline) {
+	char		propbuf[LINESIZE];
+	int		tmp_rval;
+	uint16_t	tgt;
+	uint8_t		tmp_name[8];
+
+	/* Adapter FC node names. */
+	sprintf(propbuf, "scsi-qla%d-adapter-node", (int) ha->instance);
+	qla2100_get_prop_16chars (ha, propbuf,
+	    (caddr_t)(&ha->init_cb->node_name), cmdline);
+	    
+	sprintf(propbuf, "scsi-qla%d-adapter-port", (int) ha->instance);
+	
+	/* DG 04/07 check portname of adapter */
+	qla2100_get_prop_16chars (ha, propbuf,
+	    (caddr_t)(tmp_name), cmdline);
+	if (BCMP(&ha->init_cb->port_name[0], &tmp_name[0], 8) != 0) {
+		/*
+		 * Adapter port name is WWN, and cannot be changed.
+		 * Inform users of the mismatch, then just continue driver
+		 * loading using the original adapter port name in NVRAM.
+		 */
+		printk(KERN_WARNING
+		    "qla2x00: qla%ld found mismatch in adapter port names.\n",
+		    ha->instance);
+		printk(KERN_INFO
+		    "       qla%ld port name found in NVRAM -> %02x%02x%02x%02x%02x%02x%02x%02x\n",
+		    ha->instance,
+		    ha->init_cb->port_name[0],
+		    ha->init_cb->port_name[1],
+		    ha->init_cb->port_name[2],
+		    ha->init_cb->port_name[3],
+		    ha->init_cb->port_name[4],
+		    ha->init_cb->port_name[5],
+		    ha->init_cb->port_name[6],
+		    ha->init_cb->port_name[7]);
+		printk(KERN_INFO
+		    "      qla%ld port name found on command line -> %02x%02x%02x%02x%02x%02x%02x%02x\n",
+		    ha->instance,
+		    tmp_name[0],
+		    tmp_name[1],
+		    tmp_name[2],
+		    tmp_name[3],
+		    tmp_name[4],
+		    tmp_name[5],
+		    tmp_name[6],
+		    tmp_name[7]);
+		printk(KERN_INFO
+		    "      Using port name from NVRAM.\n");
+	}
+
+	/* FC name for devices */
+	for (tgt = 0; tgt < MAX_FIBRE_DEVICES; tgt++) { 
+		sprintf(propbuf, "scsi-qla%d-target-%d",
+		    (int) ha->instance, tgt);
+
+		tmp_rval = qla2100_get_prop_16chars (ha, propbuf,
+		    tmp_name, cmdline);
+		if ( tmp_rval == 0 ) {
+			/* Got a name for this ID. */
+
+			/* Save to appropriate fields. */
+#if  USE_PORTNAME  /* updated for ioctl merge */
+			BCOPY(tmp_name, ha->fc_db[tgt].wwn, 8);
+#else
+			BCOPY(tmp_name, ha->fc_db[tgt].name, 8);
+#endif
+			ha->fc_db[tgt].loop_id = PORT_AVAILABLE;
+			ha->fc_db[tgt].flag = 0;  /* v2.19.05b3 */
+			ha->fc_db[tgt].flag |= DEV_CONFIGURED;
+			DEBUG(printk("Target %d - configured by user: ",tgt);)
+			DEBUG(printk("scsi-target=\"%08x%08x\"\n",
+			    tmp_name[1],
+			    tmp_name[0]);)/*ioctl support change*/
+		}
+	}
+
+}
+
+/*
+* Declarations for load module
+*/
+
+/* 2.19.15 */
+#ifndef FC_IP_SUPPORT
+/************************************************************************/
+/* qla2x00_reserve_loopid                                               */
+/*    This routine reserves an unused public loop ID.                   */
+/*                                                                      */
+/* Arguments:                                                           */
+/*    ha - adapter block pointer                                        */
+/*    pLoopID   - pointer to word for returning loop ID                 */
+/*                                                                      */
+/* Return Value:                                                        */
+/*    QL_STATUS_SUCCESS         if no error                             */
+/*    QL_STATUS_RESOURCE_ERROR  if out of loop IDs                      */
+/************************************************************************/
+
+static int qla2x00_reserve_loopid(scsi_qla_host_t *ha, uint16_t *pLoopId)
+{
+    int     i;
+
+    /* Look for unused loop ID */
+    for (i = ha->min_external_loopid; i < ha->max_public_loop_ids; i++)
+    {
+        if (!ha->fabricid[i].in_use)
+        {
+            /* Found free loop ID */
+            ha->fabricid[i].in_use = TRUE;
+            *pLoopId = i;
+
+            DEBUG(sprintf(debug_buff, "qla2x00_reserve_loopid: assigned loop ID %x\n\r", *pLoopId));
+            DEBUG(qla2100_print(debug_buff));
+            return QL_STATUS_SUCCESS;
+        }
+    }
+
+    /* Out of loop IDs */
+    *pLoopId = ha->max_public_loop_ids + 1;     /* Set out of range */
+    DEBUG(qla2100_print("qla2x00_reserve_loopid: out of loop IDs\n\r"));
+    return QL_STATUS_RESOURCE_ERROR;
+} /* qla2x00_reserve_loopid */
+
+
+/************************************************************************/
+/* qla2x00_free_loopid                                                  */
+/*    This routine frees a public loop ID.                              */
+/*                                                                      */
+/* Arguments:                                                           */
+/*    ha - adapter block pointer                                        */
+/*    wLoopID   - loop ID to free                                       */
+/*                                                                      */
+/* Return Value:                                                        */
+/*    none                                                              */
+/************************************************************************/
+
+static void qla2x00_free_loopid(scsi_qla_host_t *ha, uint16_t wLoopId)
+{
+    if (wLoopId < ha->max_public_loop_ids)
+    {
+        ha->fabricid[wLoopId].in_use = FALSE;
+        DEBUG(sprintf(debug_buff, "qla2x00_free_loopid: free loop ID %x\n\r", wLoopId));
+        DEBUG(qla2100_print(debug_buff));
+    }
+    else
+    {
+        DEBUG(sprintf(debug_buff, "qla2x00_free_loopid: loop ID %x out of range\n\r", wLoopId));
+        DEBUG(qla2100_print(debug_buff));
+    }
+} /* qla2x00_free_loopid */
+
+			
+/************************************************************************/
+/* qla2x00_login_public_device                                          */
+/*    This routine issues mailbox command to login fabric port.         */
+/*                                                                      */
+/* Arguments:                                                           */
+/*    ha - adapter block pointer                                        */
+/*    wLoopID   - public loop ID for device                             */
+/*    pPortID   - pointer to port ID for fabric login                   */
+/*    wOptions  - MBC_NO_PLOGI_IF_LOGGED_IN (bit 0)                     */
+/*                MBC_NO_PROCESS_LOGIN (bit 1)                          */
+/*                                                                      */
+/* Return Value:                                                        */
+/*    QL_STATUS_SUCCESS         if no error                             */
+/*    QL_STATUS_ERROR           if any other error                      */
+/*    QL_STATUS_RESOURCE_ERROR  if out of loop IDs                      */
+/*    QL_STATUS_FATAL_ERROR     if fatal error                          */
+/************************************************************************/
+
+static int qla2x00_login_public_device(scsi_qla_host_t *ha,
+                                       uint16_t *pLoopId,
+                                       uint8_t  *pPortID,
+                                       uint16_t wOptions)
+{
+    int         status = QL_STATUS_SUCCESS;
+    int         wRetryCount;
+    uint16_t    mb[MAILBOX_REGISTER_COUNT];
+
+    /* Set retry count */
+    wRetryCount = 2;
+
+    while (wRetryCount--)
+    {
+        DEBUG(sprintf(debug_buff, "qla2x00_login_public_device: login loop ID: %x  port ID: %x, option: %x\n\r",
+        *pLoopId, *pPortID << 16 | *(pPortID+1) << 8 | *(pPortID+2), wOptions ));
+        DEBUG(qla2100_print(debug_buff));
+
+        /* Issue fabric login request */
+        mb[0] = MBC_LOGIN_FABRIC_PORT;
+        mb[1] = (uint16_t)(*pLoopId << 8 | (wOptions & 0x00FF));
+        mb[2] = (uint16_t)(*pPortID);
+        mb[3] = (uint16_t)(*(pPortID+1) << 8 | *(pPortID+2));
+        if (qla2100_mailbox_command(ha, BIT_3|BIT_2|BIT_1|BIT_0, &mb[0]) == 0)
+        {
+            /* Login successful */
+            status = QL_STATUS_SUCCESS;
+            break;
+        }
+
+        /* Login failed, check status */
+        if (mb[0] == MBS_FATAL_ERROR)
+        {
+            DEBUG(qla2100_print("qla2x00_login_public_device: LOGIN_FABRIC_PORT fatal error\n\r"));
+            status = QL_STATUS_FATAL_ERROR;
+            break;
+        }
+        else if (mb[0] == MBS_LOOP_ID_IN_USE)
+        {
+            DEBUG(sprintf(debug_buff, "qla2x00_login_public_device: loop ID %x in use by port ID %x (4008)\n\r",
+                     *pLoopId, mb[1] << 16 | mb[2]));
+            DEBUG(qla2100_print(debug_buff));
+
+            /* Allocate another loop ID and retry */
+            if ((status = qla2x00_reserve_loopid(ha, pLoopId)) == QL_STATUS_SUCCESS)
+            {
+                wRetryCount++;
+            }
+            else
+            {
+                break;
+            }
+        }
+        else if (mb[0] == MBS_PORT_ID_IN_USE)
+        {
+            DEBUG(sprintf(debug_buff, "qla2x00_login_public_device: port ID already assigned to loop ID %x (4007)\n\r",
+                     mb[1]));
+            DEBUG(qla2100_print(debug_buff));
+
+            /* Free loop ID and use one assigned by RISC */
+            qla2x00_free_loopid(ha, *pLoopId);
+            *pLoopId = mb[1];
+
+            /* Must reissue login mailbox command with new loop ID */
+            wRetryCount++;
+        }
+        else
+        {
+            DEBUG(sprintf(debug_buff, "qla2x00_login_public_device: login error status %x, MB1: %x, MB2: %x\n\r",
+                     mb[0], mb[1], mb[2]));
+            DEBUG(qla2100_print(debug_buff));
+            status = QL_STATUS_ERROR;
+        }
+    }
+    return(status);
+} /* qla2x00_login_public_device */
+
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#ifdef MODULE
+Scsi_Host_Template driver_template = QLA2100_LINUX_TEMPLATE;
+#include "scsi_module.c"
+#endif
+#else   /* new kernel scsi initialization scheme */
+static  Scsi_Host_Template driver_template = QLA2100_LINUX_TEMPLATE;
+#include "scsi_module.c"
+#endif
+
+#ifdef QL_DEBUG_ROUTINES
+/****************************************************************************/
+/*                         Driver Debug Functions.                          */
+/****************************************************************************/
+
+            /*
+            *  Get byte from I/O port
+            */
+STATIC uint8_t
+qla2100_getbyte(uint8_t *port) {
+                uint8_t ret;
+
+#ifdef MEMORY_MAPPED_IO
+                ret = *port;
+#else
+                ret = inb((int)port);
+#endif
+
+                if( ql2x_debug_print ) {
+                    qla2100_print("qla2100_getbyte: address = ");
+            qla2100_output_number((u_long)port, 16);
+            qla2100_print(" data = 0x");
+            qla2100_output_number((u_long)ret, 16);
+                    qla2100_print("\n");
+                }
+
+                return(ret);
+}
+
+            /*
+            *  Get word from I/O port
+            */
+STATIC uint16_t
+qla2100_getword(uint16_t *port) {
+                uint16_t ret;
+
+#ifdef MEMORY_MAPPED_IO
+                ret = *port;
+#else
+                ret = inw((int)port);
+#endif
+
+                if( ql2x_debug_print ) {
+                    qla2100_print("qla2100_getword: address = ");
+            qla2100_output_number((u_long)port, 16);
+            qla2100_print(" data = 0x");
+            qla2100_output_number((u_long)ret, 16);
+                    qla2100_print("\n");
+                }
+
+                return(ret);
+}
+
+            /*
+            *  Get double word from I/O port
+            */
+STATIC uint32_t
+qla2100_getdword(uint32_t *port) {
+                uint32_t ret;
+
+#ifdef MEMORY_MAPPED_IO
+                ret = *port;
+#else
+                ret = inl((int)port);
+#endif
+
+                if( ql2x_debug_print ) {
+                    qla2100_print("qla2100_getdword: address = ");
+            qla2100_output_number((u_long)port, 16);
+            qla2100_print(" data = 0x");
+            qla2100_output_number((u_long)ret, 16);
+                    qla2100_print("\n");
+                }
+
+                return(ret);
+}
+
+            /*
+            *  Send byte to I/O port
+            */
+STATIC void
+qla2100_putbyte(uint8_t *port, uint8_t data) {
+#ifdef MEMORY_MAPPED_IO
+                *port = data;
+#else
+                outb(data, (int)port);
+#endif
+
+                if( ql2x_debug_print ) {
+                    qla2100_print("qla2100_putbyte: address = ");
+            qla2100_output_number((u_long)port, 16);
+            qla2100_print(" data = 0x");
+            qla2100_output_number((u_long)data, 16);
+                    qla2100_print("\n");
+                }
+}
+
+            /*
+            *  Send word to I/O port
+            */
+STATIC void
+qla2100_putword(uint16_t *port, uint16_t data) {
+#ifdef MEMORY_MAPPED_IO
+                *port = data;
+#else
+#ifdef _LINUX_IOPORTS
+                outw(data, (int)port);
+#else
+                outw((int)port, data);
+#endif
+#endif
+
+                if( ql2x_debug_print ) {
+                    qla2100_print("qla2100_putword: address = ");
+            qla2100_output_number((u_long)port, 16);
+            qla2100_print(" data = 0x");
+            qla2100_output_number((u_long)data, 16);
+                    qla2100_print("\n");
+                }
+}
+
+            /*
+            *  Send double word to I/O port
+            */
+STATIC void
+qla2100_putdword(uint32_t *port, uint32_t data) {
+#ifdef MEMORY_MAPPED_IO
+                *port = data;
+#else
+#ifdef _LINUX_IOPORTS
+                outl(data,(int)port);
+#else
+                outl((int)port, data);
+#endif
+#endif
+
+                if( ql2x_debug_print ) {
+                    qla2100_print("qla2100_putdword: address = ");
+            qla2100_output_number((u_long)port, 16);
+            qla2100_print(" data = 0x");
+            qla2100_output_number((u_long)data, 16);
+                    qla2100_print("\n");
+                }
+}
+
+            /*
+            * Dummy function to prevent warnings for
+            * declared and unused debug functions
+            */
+void
+qla2100_debug(void) {
+                qla2100_getbyte(0);
+                qla2100_getword(0);
+                qla2100_getdword(0);
+                qla2100_putbyte(0, 0);
+                qla2100_putword(0, 0);
+                qla2100_putdword(0, 0);
+}
+
+            /*
+            *  Out character to COM1 port.
+            *      PORT must be at standard address for COM1 = 0x3F8
+            *      This port is available on both Lion and ia32 systems
+            */
+#define OUTB(addr,data)   outb((data),(addr))
+STATIC void
+qla2100_putc(int8_t c) {
+#ifdef QL_DEBUG_CONSOLE
+
+                printk("%c",c);
+
+#else /* QL_DEBUG_CONSOLE */
+
+                uint8_t data;
+                int     com_addr              = 0x3f8; /* COM1 */
+                int     hardware_flow_control = 1;
+                int     software_flow_control = 0;
+                uint8_t loop                  = TRUE;
+
+                do {
+
+                    /* Wait for transmitter holding and shift registers for empty. */
+                    do {
+                        data = inb(com_addr+5);
+                    }while( !(data & BIT_6) );
+
+                    /*
+                    * Set BAUD rate for COM1 to 9600
+                    */
+
+                    /* BAUD rate divisor LSB. */
+                    OUTB(com_addr+3, 0x83);
+
+                    /* BAUD rate divisor MSB. */
+                    OUTB(com_addr, 0xc);           /* 0xC = 9600 baud */
+
+                    /* Set No parity, 8 bits, 1 stop bit and
+                    select interrupt enable register. */
+                    OUTB(com_addr+3, 3);
+
+                    /* Disable interrupts. */
+                    OUTB(com_addr+1, 0);
+
+                    /* Set data terminal ready and request to send */
+                    OUTB(com_addr+1, 0);
+
+                    if( hardware_flow_control ) {
+                        /* Wait for clear-to-send and data-set-ready */
+                        do {
+                            data = inb(com_addr+6) & (BIT_5 + BIT_4);
+                        }while( data != (BIT_5 + BIT_4) );
+                    } else if( software_flow_control ) {
+                        /* Test for data ready. */
+                        data = inb(com_addr+5);
+                        if( data & BIT_0 ) {
+                            /* If XOFF */
+                            data = inb(com_addr);
+                            if( data == '\023' ) {
+                                /* Wait for XON */
+                                do {
+                                    /* Wait for int8_t */
+                                    do {
+                                        data = inb(com_addr+5);
+                                    }while( !(data & BIT_0) );
+                                    data = inb(com_addr);
+                                }while( data != '\021' );
+                            }
+                        }
+                    }
+
+                    /* Output character. */
+                    OUTB(com_addr, c);
+
+                    /* Add return. */
+                    if( c == '\n' )
+                        c = '\r';
+                    else
+                        loop = FALSE;
+
+                }while( loop );
+#endif  /* QL_DEBUG_CONSOLE */
+}
+
+            /*
+            *  Out NULL terminated string to COM port.
+            */
+STATIC void
+qla2100_print(int8_t *s) {
+                if( ql2x_debug_print ) {
+#ifdef QL_DEBUG_CONSOLE
+                    printk("%s",s);
+#else
+                    /* Output string. */
+                    while( *s )
+                        qla2100_putc(*s++);
+#endif
+                }
+}
+
+            /*
+            *  Output long number to COM port.
+            */
+STATIC void
+        qla2100_output_number(u_long n, uint8_t base) {
+                int8_t str[12];
+                int8_t *s      = &str[11];
+                uint8_t output = 0;
+                uint8_t hex    = FALSE;
+
+                if( ql2x_debug_print ) {
+                    if( base == 10 || base == 16 ) {
+                        if( base == 16 && n > 9 )
+                            hex = TRUE;
+
+                        *s = 0;
+                        do {
+                            s--;
+                            *s = n % base;
+                            if( *s > 9 )
+                                *s += 55;
+                            else
+                                *s += '0';
+                            n /= base;
+                        }while( n );
+
+                        for( ; *s; s++ ) {
+                            if( *s != '0' )
+                                output = 1;
+                            if( output )
+                                qla2100_putc(*s);
+                        }
+                        if( !output )
+                            qla2100_putc(*--s);
+
+                        if( hex )
+                            qla2100_putc('h');
+                    }
+                }
+}
+
+STATIC void
+qla2100_dump_buffer(uint8_t *b, uint32_t size) {
+                uint32_t cnt;
+                uint8_t c;
+
+                if( ql2x_debug_print ) {
+                    qla2100_print(
+                    " 0   1   2   3   4   5   6   7   8   9   Ah  Bh  Ch  Dh  Eh  Fh\n");
+                    qla2100_print(
+                    "---------------------------------------------------------------\n");
+
+                    for( cnt = 0; cnt < size; ) {
+                        c = *b++;
+                        if( c < 16 )
+                            qla2100_putc(' ');
+                        qla2100_output_number((uint32_t)c, 16);
+                        cnt++;
+                        if( !(cnt % 16) )
+                            qla2100_print("\n");
+                        else if( c < 10 )
+                            qla2100_print("  ");
+                        else
+                            qla2100_putc(' ');
+                    }
+                    if( cnt % 16 )
+                        qla2100_print("\n");
+                }
+}
+            /**************************************************************************
+            *   ql2100_print_scsi_cmd
+            *
+            **************************************************************************/
+void qla2100_print_scsi_cmd(Scsi_Cmnd *cmd) {
+                scsi_qla_host_t *ha;
+                struct Scsi_Host  *host = cmd->host;
+                srb_t           *sp;
+
+                int i;
+                ha = (scsi_qla_host_t *) host->hostdata;
+
+                ql2x_debug_print = 1;
+                sp = (srb_t *) CMD_SP(cmd);
+                sprintf(debug_buff,"SCSI Command=0x%p, Handle=0x%08lx pid=%x\n\r", cmd, (u_long)CMD_HANDLE(cmd),cmd->pid);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"  chan=%d, target = 0x%02x, lun = 0x%02x, cmd_len = 0x%02x\n\r",
+                cmd->channel, cmd->target, cmd->lun, cmd->cmd_len);
+                qla2100_print(debug_buff);
+                qla2100_print(" CDB = ");
+                for( i = 0; i < cmd->cmd_len; i++ ) {
+                    sprintf(debug_buff,"0x%02x ", cmd->cmnd[i]);
+                    qla2100_print(debug_buff);
+                }
+
+                sprintf(debug_buff,"\n\r  seg_cnt =%d, retries=%d, serial_number_at_timeout=0x%lx\n\r",cmd->use_sg,cmd->retries,cmd->serial_number_at_timeout);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"  request buffer=0x%p, request buffer len=0x%x\n\r",cmd->request_buffer,cmd->request_bufflen);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"  tag=%d, flags=0x%x, transfersize=0x%x \n\r",
+                cmd->tag, cmd->flags,cmd->transfersize);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"  Pid=%d, SP=0x%x\n\r", (int)cmd->pid, CMD_SP(cmd));
+
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"  sp flags=0x%lx, sp state=%x, wdgtime=%d\n\r",sp->flags,sp->state,sp->wdg_time);
+                qla2100_print(debug_buff);
+}
+
+
+void qla2100_print_q_info(scsi_lu_t *q) {
+                sprintf(debug_buff,"Queue info: queue in =%d, queue out= %d, flags=0x%lx\n\r", q->q_incnt, q->q_outcnt, q->q_flag);
+                qla2100_print(debug_buff);
+}
+#endif
+
+
+
+
+            /**************************************************************************
+            *   ql2100_dump_regs
+            *
+            **************************************************************************/
+static void qla2100_dump_regs(struct Scsi_Host *host) {
+                printk("Mailbox registers:\n");
+                printk("qla2100 : mbox 0 0x%04x \n", inw(host->io_port + 0x10));
+                printk("qla2100 : mbox 1 0x%04x \n", inw(host->io_port + 0x12));
+                printk("qla2100 : mbox 2 0x%04x \n", inw(host->io_port + 0x14));
+                printk("qla2100 : mbox 3 0x%04x \n", inw(host->io_port + 0x16));
+                printk("qla2100 : mbox 4 0x%04x \n", inw(host->io_port + 0x18));
+                printk("qla2100 : mbox 5 0x%04x \n", inw(host->io_port + 0x1a));
+#ifdef TRACECODE
+                sprintf(debug_buff,"qla2100 : mbox 0 0x%04x \n\r", inw(host->io_port + 0x10));
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"qla2100 : mbox 1 0x%04x \n\r", inw(host->io_port + 0x12));
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"qla2100 : mbox 2 0x%04x \n\r", inw(host->io_port + 0x14));
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"qla2100 : mbox 3 0x%04x \n\r", inw(host->io_port + 0x16));
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"qla2100 : mbox 4 0x%04x \n\r", inw(host->io_port + 0x18));
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"qla2100 : mbox 5 0x%04x \n\r", inw(host->io_port + 0x1a));
+                qla2100_print(debug_buff);
+#endif
+}
+
+
+#if  STOP_ON_ERROR
+            /**************************************************************************
+            *   ql2100_panic
+            *
+            **************************************************************************/
+static void qla2100_panic(char *cp, struct Scsi_Host *host) {
+                scsi_qla_host_t *ha;
+                long  *fp;
+
+                ha = (scsi_qla_host_t *) host->hostdata;
+                DEBUG2(ql2x_debug_print = 1;)
+                sprintf(debug_buff,"qla2100 - PANIC:  %s\n",cp);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"Current time=0x%lx\n", jiffies);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"Number of pending commands =0x%lx\n", ha->actthreads);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"Number of queued commands =0x%lx\n", ha->qthreads);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"Number of free entries = (%d)\n",ha->req_q_cnt);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"Request Queue @ 0x%lx, Response Queue @ 0x%lx\n",
+                ha->request_dma,
+                ha->response_dma);
+                qla2100_print(debug_buff);
+                sprintf(debug_buff,"Request In Ptr %d\n", ha->req_ring_index);
+                qla2100_print(debug_buff);
+                fp = (long *) &ha->flags;
+                sprintf(debug_buff,"HA flags =0x%lx\n", *fp);
+                qla2100_print(debug_buff);
+                ql2100_dump_requests(ha);
+                qla2100_dump_regs(host);
+                cli();
+                for( ;; ) {
+                    QLA2100_DELAY(2); barrier();
+                }
+                sti();
+}
+#endif
+#if 0
+    static void qla2100_set_flags(int flag) {
+
+        switch( flag ) {
+        case 0x1:
+            qla2100_verbose = 1L;
+
+        }
+
+    }
+#endif
+            /**************************************************************************
+            *   ql2100_dump_requests
+            *
+            **************************************************************************/
+void
+ql2100_dump_requests(scsi_qla_host_t *ha) {
+
+                Scsi_Cmnd       *cp;
+                srb_t           *sp;
+                int i;
+#ifdef QL_DEBUG_ROUTINES
+                qla2100_print("Outstanding Commands on controller:\n\r");
+#else
+                printk(KERN_INFO "Outstanding Commands on controller:\n");
+#endif
+                for( i=0; i < MAX_OUTSTANDING_COMMANDS; i++ ) {
+                    if( (sp = ha->outstanding_cmds[i]) == NULL )
+                        continue;
+                    if( (cp = sp->cmd) == NULL )
+                        continue;
+                    sprintf(debug_buff,"(%d): Pid=%ld, sp flags=0x%x, cmd=0x%p\n\r", i, (int)sp->cmd->pid, (long)sp->flags,CMD_SP(sp->cmd));
+
+#ifdef QL_DEBUG_ROUTINES
+                    qla2100_print(debug_buff);
+#else
+                    printk(KERN_INFO "%s",debug_buff);
+#endif
+                }
+
+}
+            
+
+            /**************************************************************************
+            *   qla2100_setup
+            *
+            *   Handle Linux boot parameters. This routine allows for assigning a value
+            *   to a parameter with a ';' between the parameter and the value.
+            *   ie. qla2x00=arg0;arg1;...;argN;<properties .... properties>  OR
+            *   via the command line.
+            *   ie. qla2x00 ql2xopts=arg0;arg1;...;argN;<properties .... properties>
+            **************************************************************************/
+void qla2100_setup(char *s, int *dummy) {
+                char *cp, *np;
+                char	*slots[MAXARGS];
+                char	**argv = &slots[0];
+                char	buf[LINESIZE];
+                int	argc, opts;
+
+                /*
+                * Determine if we have any properties.
+                */
+                cp = s;
+                opts = 1;
+                while( *cp && (np = qla2100_get_line(cp, buf)) != NULL ) {
+                    if( BCMP("scsi-qla",buf,8) == 0 ) {
+                        DEBUG(printk("qla2100: devconf=%s\n",cp);)
+                        ql2xdevconf = cp;
+                        (opts > 0)? opts-- : 0;
+                        break;
+                    }
+                    opts++;
+                    cp = np;
+                }
+                /*
+                * Parse the args before the properties
+                */
+                if( opts ) {
+                    opts = (opts > MAXARGS-1)? MAXARGS-1: opts;
+                    argc = qla2100_get_tokens(s, argv, opts);
+                    while (argc > 0 ) {
+                        cp = *argv;
+                        DEBUG(printk("scsi: found cmd arg =[%s]\n", cp);)
+                        if( strcmp(cp, "verbose") == 0 ) {
+                            DEBUG(printk("qla2100: verbose\n");)
+                            qla2100_verbose++;
+                        } else if (strcmp(cp, "quiet") == 0) {
+                            qla2100_quiet = 1;
+                        } else if( strcmp(cp, "reinit_on_loopdown") == 0 ) {
+                            qla2100_reinit++;
+                            DEBUG(printk("qla2100: reinit_on_loopdown\n");)
+                        }
+                        argc--, argv++;
+                    }
+                }
+
+}
+
+            /********************** qla2100_get_line *********************
+            * qla2100_get_line
+            * Copy a substring from the specified string. The substring
+            * consists of any number of chars seperated by white spaces (i.e. spaces)
+            * and ending with a newline '\n' or a semicolon ';'.
+            *
+            * Enter:
+            * str - orig string
+            * line - substring
+            *
+            * Returns:
+            *   cp - pointer to next string
+            *     or
+            *   null - End of string
+            *************************************************************/
+static char	*qla2100_get_line(char *str, char *line) {
+                register	char 	*cp = str;
+                register	char 	*sp = line;
+
+                /* skip preceeding spaces */
+                while( *cp && *cp == ' ' )
+                    ++cp;
+                while ( (*cp) && *cp != '\n' && *cp != ';' )   /* end of line */
+                    *sp++ = *cp++;
+
+                *sp = '\0';
+                DEBUG5(printk("qla2100_get_line: %s\n",line);)
+                if( (*cp) ) {
+                    cp++;
+                    return( cp );
+                }
+                return( NULL );
+}
+
+
+            /**************************** get_tokens *********************
+            * Parse command line into argv1, argv2, ... argvX
+            * Arguments are seperated by white spaces and colons and end
+            * with a NULL.
+            *************************************************************/
+static int	qla2100_get_tokens(char *line, char **argv, int maxargs ) {
+                register	char 	*cp = line;
+                int	count = 0;
+
+                while( *cp && count < maxargs ) {
+                    /* skip preceeding spaces */
+                    while((*cp) && *cp == ' ')
+                        ++cp;
+                    /* symbol starts here */
+                    argv[count++] = cp;
+                    /* skip symbols */
+                    while ( (*cp) && !( *cp == ' ' || *cp == ';' || *cp == ':' ) )
+                        cp++;
+                    /* replace comma or space with a null */
+                    if( (*cp) && (*cp ==' ' ) && argv[count-1] != cp )
+                        *cp++ = '\0';
+                }
+                return( count );
+}
+
+#ifdef FC_IP_SUPPORT
+            /* Include routines for supporting IP */
+#include "qla2100ip.c"
+#endif /* FC_IP_SUPPORT */
+
+#if  APIDEV
+/****************************************************************************/
+/* Create character driver "HbaApiDev" w dynamically allocated major number */
+/* and create "/proc/scsi/qla2x00/HbaApiNode" as the device node associated */
+/* with the major number.                                                   */
+/****************************************************************************/
+
+#define APIDEV_NODE  "HbaApiNode"
+#define APIDEV_NAME  "HbaApiDev"
+
+static int apidev_major = 0;
+static struct Scsi_Host *apidev_host = 0;
+
+static int apidev_open(struct inode *inode, struct file *file)
+{
+    printk (KERN_INFO "qla2100_apidev: open MAJOR number = %d, MINOR number = %d\n", MAJOR (inode->i_rdev), MINOR (inode->i_rdev));
+    return 0;
+}
+static int apidev_close(struct inode *inode, struct file *file)
+{
+    printk (KERN_INFO "qla2100_apidev: closed\n");
+    return 0;
+}
+
+static int apidev_ioctl(struct inode *inode, struct file *fp, unsigned int cmd, unsigned long arg)
+{
+    Scsi_Device fake_scsi_device;
+    fake_scsi_device.host = apidev_host;
+    return(qla2100_ioctl(&fake_scsi_device, (int)cmd, (void*)arg));
+}
+
+static struct file_operations apidev_fops = {
+    ioctl:    apidev_ioctl,
+    open:     apidev_open,
+    release:  apidev_close
+};
+
+static int apidev_init(struct Scsi_Host *host)
+{
+    if(apidev_host) return 0;
+    if (0 > (apidev_major = register_chrdev(0, APIDEV_NAME, &apidev_fops)))
+    {
+        DEBUG(printk("qla2100_apidev: register_chrdev rc=%d\n",apidev_major);)
+        return apidev_major;
+    }
+    apidev_host = host;
+    DEBUG(printk("qla2x00: Created /proc/scsi/qla2x00/%s major=%d\n",APIDEV_NODE,apidev_major);)
+    proc_mknod(APIDEV_NODE, 0777+S_IFCHR,host->hostt->proc_dir,(kdev_t)MKDEV(apidev_major,0));
+    return 0;
+}
+
+static int apidev_cleanup()
+{
+    if(!apidev_host) return 0;
+    unregister_chrdev(apidev_major,APIDEV_NAME);
+    remove_proc_entry(APIDEV_NODE,apidev_host->hostt->proc_dir);
+    apidev_host = 0;
+    return 0;
+}
+#endif /* APIDEV */
+
+#ifdef QL_DEBUG_ROUTINES
+#if  DEBUG_GET_FW_DUMP
+#include  "x2300dbg.c"
+#endif
+#endif
+
+
+/*
+* Overrides for Emacs so that we almost follow Linus's tabbing style.
+* Emacs will notice this stuff at the end of the file and automatically
+* adjust the settings for this buffer only.  This must remain at the end
+* of the file.
+* ---------------------------------------------------------------------------
+* Local variables:
+* c-indent-level: 2
+* c-brace-imaginary-offset: 0
+* c-brace-offset: -2
+* c-argdecl-indent: 2
+* c-label-offset: -2
+* c-continued-statement-offset: 2
+* c-continued-brace-offset: 0
+* indent-tabs-mode: nil
+* tab-width: 8
+* End:
+*/
diff -urN linux.orig/drivers/scsi/qla2x00.h linux/drivers/scsi/qla2x00.h
--- linux.orig/drivers/scsi/qla2x00.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/qla2x00.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,2492 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP2x00 device driver for Linux 2.2.x and 2.4.x 
+* Copyright (C) 2000 and 2001         Qlogic Corporation 
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+**
+******************************************************************************/
+
+#ifndef _IO_HBA_QLA2100_H          /* wrapper symbol for kernel use */
+#define _IO_HBA_QLA2100_H          /* subject to change without notice */
+
+#ifndef LINUX_VERSION_CODE 
+#include <linux/version.h>
+#endif  /* LINUX_VERSION_CODE not defined */
+
+#ifndef  HOSTS_C
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#ifndef ISP2200 
+#define ISP2200
+#endif
+
+ 
+/*
+ * Driver debug definitions.
+ */
+/* #define QL_DEBUG_LEVEL_1 */      /* Output register accesses to COM1 */
+/* #define QL_DEBUG_LEVEL_2 */       /* Output error msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_3 */      /* Output function trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_4 */      /* Output NVRAM trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_5 */      /* Output ring trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_6 */      /* Output WATCHDOG timer trace to COM1 */
+/* #define QL_DEBUG_LEVEL_7 */      /* Output RISC load trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_8 */      /* Output ring saturation msgs to COM1 */
+
+#define QL_DEBUG_CONSOLE        /* Output to console instead of COM1 */
+  /* comment this #define to get output of qla2100_print to COM1         */
+  /* if COM1 is not connected to a host system, the driver hangs system! */
+
+/*
+ * Data bit definitions.
+ */
+#define BIT_0   0x1
+#define BIT_1   0x2
+#define BIT_2   0x4
+#define BIT_3   0x8
+#define BIT_4   0x10
+#define BIT_5   0x20
+#define BIT_6   0x40
+#define BIT_7   0x80
+#define BIT_8   0x100
+#define BIT_9   0x200
+#define BIT_10  0x400
+#define BIT_11  0x800
+#define BIT_12  0x1000
+#define BIT_13  0x2000
+#define BIT_14  0x4000
+#define BIT_15  0x8000
+#define BIT_16  0x10000
+#define BIT_17  0x20000
+#define BIT_18  0x40000
+#define BIT_19  0x80000
+#define BIT_20  0x100000
+#define BIT_21  0x200000
+#define BIT_22  0x400000
+#define BIT_23  0x800000
+#define BIT_24  0x1000000
+#define BIT_25  0x2000000
+#define BIT_26  0x4000000
+#define BIT_27  0x8000000
+#define BIT_28  0x10000000
+#define BIT_29  0x20000000
+#define BIT_30  0x40000000
+#define BIT_31  0x80000000
+
+/*
+ * Common size type definitions
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0)
+typedef unsigned char  uint8_t; 
+typedef unsigned short uint16_t; 
+typedef unsigned long  uint32_t; 
+typedef char  int8_t; 
+typedef short int16_t; 
+typedef long  int32_t; 
+#endif
+
+/*
+ *  Local Macro Definitions.
+ */
+#if defined(QL_DEBUG_LEVEL_1) || defined(QL_DEBUG_LEVEL_2) || \
+    defined(QL_DEBUG_LEVEL_3) || defined(QL_DEBUG_LEVEL_4) || \
+    defined(QL_DEBUG_LEVEL_5) || defined(QL_DEBUG_LEVEL_6) || \
+    defined(QL_DEBUG_LEVEL_7) || defined(QL_DEBUG_LEVEL_8)
+    #define QL_DEBUG_ROUTINES
+#endif
+
+#ifndef TRUE
+    #define TRUE  1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+#ifndef KERNEL_VERSION
+#  define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,92)
+#  if defined(__sparc_v9__) || defined(__powerpc__)
+#    error "PPC and Sparc platforms are only support under 2.1.92 and above"
+#  endif
+#endif
+
+
+/* 
+ * Locking
+ */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,0)
+#  if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,18)
+#    include <asm/spinlock.h>
+#  else
+#    include <linux/spinlock.h>
+#  endif
+#  include <linux/smp.h>
+#  define cpuid smp_processor_id()
+#  if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+#    define DRIVER_LOCK_INIT \
+       spin_lock_init(&ha->spin_lock);
+#    define DRIVER_LOCK \
+       if(!ha->cpu_lock_count[cpuid]) { \
+         spin_lock_irqsave(&ha->spin_lock, cpu_flags); \
+         ha->cpu_lock_count[cpuid]++; \
+       } else { \
+         ha->cpu_lock_count[cpuid]++; \
+       }
+#    define DRIVER_UNLOCK \
+       if(--ha->cpu_lock_count[cpuid] == 0) \
+         spin_unlock_irqrestore(&ha->spin_lock, cpu_flags);
+#  else
+#    define DRIVER_LOCK_INIT
+#    define DRIVER_LOCK
+#    define DRIVER_UNLOCK
+#  endif 
+#else
+#  define cpuid 0
+#  define DRIVER_LOCK_INIT
+#  define DRIVER_LOCK \
+       save_flags(cpu_flags); \
+       cli();
+#  define DRIVER_UNLOCK \
+       restore_flags(cpu_flags);
+#  define le32_to_cpu(x) (x)
+#  define cpu_to_le32(x) (x)
+#endif
+
+
+/*
+ * I/O register
+*/
+/* #define MEMORY_MAPPED_IO  */           /* Enable memory mapped I/O */
+#undef MEMORY_MAPPED_IO            /* Disable memory mapped I/O */
+#define LINUX_IOPORTS              /* Linux in/out routines are define*/
+                                   /* differently from other OSs      */
+
+#ifdef QL_DEBUG_LEVEL_1
+    #define RD_REG_BYTE(addr)         qla2100_getbyte((uint8_t *)addr)
+    #define RD_REG_WORD(addr)         qla2100_getword((uint16_t *)addr)
+    #define RD_REG_DWORD(addr)        qla2100_getdword((uint32_t *)addr)
+    #define WRT_REG_BYTE(addr, data)  qla2100_putbyte((uint8_t *)addr, data)
+    #define WRT_REG_WORD(addr, data)  qla2100_putword((uint16_t *)addr, data)
+    #define WRT_REG_DWORD(addr, data) qla2100_putdword((uint32_t *)addr, data)
+#else  /* QL_DEBUG_LEVEL_1 */
+#ifdef MEMORY_MAPPED_IO
+#define RD_REG_BYTE(addr)         (*((volatile uint8_t *)addr))
+#define RD_REG_WORD(addr)         (*((volatile uint16_t *)addr))
+#define RD_REG_DWORD(addr)        (*((volatile uint32_t *)addr))
+#define WRT_REG_BYTE(addr, data)  (*((volatile uint8_t *)addr) = data)
+#define WRT_REG_WORD(addr, data)  (*((volatile uint16_t *)addr) = data)
+#define WRT_REG_DWORD(addr, data) (*((volatile uint32_t *)addr) = data)
+#else   /* MEMORY_MAPPED_IO */
+#define RD_REG_BYTE(addr)         (inb((unsigned long)addr))
+#define RD_REG_WORD(addr)         (inw((unsigned long)addr))
+#define RD_REG_DWORD(addr)        (inl((unsigned long)addr))
+#define WRT_REG_BYTE(addr, data)  (outb(data,(unsigned long)addr))
+#define WRT_REG_WORD(addr, data)  (outw(data,(unsigned long)addr))
+#define WRT_REG_DWORD(addr, data) (outl(data,(unsigned long)addr))
+#endif  /* MEMORY_MAPPED_IO */
+#endif    /* QL_DEBUG_LEVEL_1 */
+
+#define MAX_FIBRE_DEVICES   256
+#define	MAX_RSCN_COUNT      10
+#define	MAX_HOST_COUNT      16
+
+/*
+ * Host adapter default definitions.
+ */
+#define MAX_BUSES        1         /* We only have one bus today */
+#define MAX_TARGETS_2100 255
+#define MAX_TARGETS_2200 255
+#define MAX_LUNS         255
+                                    
+/*
+ * Fibre Channel device definitions.
+ */
+#define LAST_LOCAL_LOOP_ID  0x7d
+#define SNS_FL_PORT         0x7e
+#define FABRIC_CONTROLLER   0x7f
+#define SIMPLE_NAME_SERVER  0x80
+#define SNS_FIRST_LOOP_ID   0x81
+#define LAST_SNS_LOOP_ID    0xfe
+#define MANAGEMENT_SERVER   0xfe
+#define BROADCAST           0xff
+#define SNS_ACCEPT          0x0280 /* 8002 swapped */
+#define SNS_REJECT          0x0180 /* 8001 swapped */
+
+/* Loop ID's used as database flags, must be higher than any valid Loop ID */
+#define PORT_UNUSED         0x100  /* Port never been used. */
+#define PORT_AVAILABLE      0x101  /* Device does not exist on port. */
+
+/*
+ * Timeout timer counts in seconds
+ */
+#define QLA2100_WDG_TIME_QUANTUM   1    /* In seconds */
+#define PORT_RETRY_TIME            2
+#define LOOP_DOWN_TIMEOUT          60
+#define LOOP_DOWN_TIME             240  /* 240 */
+
+/* Maximum outstanding commands in ISP queues (1-65535) */
+#define	LOOP_DOWN_RESET		(LOOP_DOWN_TIME - 30)
+
+/* Maximum outstanding commands in ISP queues (1-65535) */
+#define MAX_OUTSTANDING_COMMANDS   512*2
+
+#define REQUEST_ENTRY_CNT       256   /* # of request entries, was 512 */
+#define RESPONSE_ENTRY_CNT      256   /* # of response entries, was 16 */
+
+/*
+ * UnixWare required definitions.
+ */
+#define HBA_PREFIX qla2100
+
+/* Physical DMA memory requirements */
+#define QLA2100_MEMALIGN    4
+#define QLA2100_BOUNDARY    0x80000000  /* 2GB */
+
+/* Number of segments 1 - 65535 */
+#define SG_SEGMENTS     32             /* Cmd entry + 6 continuations */
+
+/*
+ * SCSI Request Block 
+ */
+typedef struct srb
+{
+    Scsi_Cmnd  *cmd;                 /* (4) SCSI command block */
+    struct srb  *s_next;             /* (4) Next block on LU queue */
+    struct srb  *s_prev;             /* (4) Previous block on LU queue */
+    uint8_t     flags;               /* (1) Status flags. */
+    uint8_t     dir;                 /* direction of transfer */
+    uint8_t     retry_count;            /* Retry count. */
+    uint8_t     port_down_retry_count;  /* Port down retry count. */
+    uint8_t     ccode;               /* risc completion code */
+    uint8_t     scode;               /* scsi status code */
+    uint8_t     wdg_time;            /* watchdog time in seconds */
+    uint8_t     state;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,18)
+    uint64_t         saved_dma_handle;    /* for unmap of single transfers */
+#endif
+}srb_t;
+
+/*
+ * SRB flag definitions
+ */
+#define SRB_TIMEOUT     BIT_0           /* Command timed out */
+#define SRB_SENT        BIT_1           /* Command sent to ISP */
+#define SRB_WATCHDOG    BIT_2           /* Command on watchdog list */
+#define SRB_ABORT_PENDING BIT_3     /* Command abort sent to device */
+#define SRB_ABORTED     BIT_4           /* Command aborted command already */
+#define SRB_RETRY     BIT_5           /* Command aborted command already */
+
+/*
+ * LUN - Logical Unit Queue structure
+ */
+typedef struct scsi_lu
+{
+    srb_t           *q_first;           /* First block on LU queue */
+    srb_t           *q_last;            /* Last block on LU queue */
+    u_char          q_flag;             /* LU queue state flags */
+    u_short         q_outcnt;           /* Pending jobs for this LU */
+    u_long          q_incnt;            /* queued jobs for this LU */
+    u_long          io_cnt;             /* total xfer count */
+    u_long          resp_time;          /* total response time (start - finish) */
+    u_long          act_time;           /* total actived time (minus queuing time) */
+    u_long          w_cnt;              /* total writes */
+    u_long          r_cnt;              /* total reads */
+#if QLA2X00_TARGET_MODE_SUPPORT
+    void            (*q_func)();        /* Target driver event handler */
+    long            q_param;            /* Target driver event param */
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,0)
+    spinlock_t      *q_spin_lock;       /* Device Queue Lock */
+#endif
+    volatile unsigned char cpu_lock_count[NR_CPUS];
+    u_long          q_timeout;           /* total command timeouts */
+}scsi_lu_t;
+
+/*
+ * Logical Unit q_flag definitions
+ */
+#define QLA2100_QBUSY   BIT_0
+#define QLA2100_QWAIT   BIT_1
+#define QLA2100_QSUSP   BIT_2
+#define QLA2100_QRESET  BIT_4
+#define QLA2100_QHBA    BIT_5
+#define QLA2100_BSUSP   BIT_6           /* controller is suspended */
+#define QLA2100_BREM    BIT_7           /* controller is removed */
+
+/*
+ *  ISP PCI Configuration Register Set
+ */
+typedef volatile struct
+{
+    uint16_t vendor_id;                 /* 0x0 */
+    uint16_t device_id;                 /* 0x2 */
+    uint16_t command;                   /* 0x4 */
+    uint16_t status;                    /* 0x6 */
+    uint8_t revision_id;                /* 0x8 */
+    uint8_t programming_interface;      /* 0x9 */
+    uint8_t sub_class;                  /* 0xa */
+    uint8_t base_class;                 /* 0xb */
+    uint8_t cache_line;                 /* 0xc */
+    uint8_t latency_timer;              /* 0xd */
+    uint8_t header_type;                /* 0xe */
+    uint8_t bist;                       /* 0xf */
+    uint32_t base_port;                 /* 0x10 */
+    uint32_t mem_base_addr;             /* 0x14 */
+    uint32_t base_addr[4];              /* 0x18-0x24 */
+    uint32_t reserved_1[2];             /* 0x28-0x2c */
+    uint16_t expansion_rom;             /* 0x30 */
+    uint32_t reserved_2[2];             /* 0x34-0x38 */
+    uint8_t interrupt_line;             /* 0x3c */
+    uint8_t interrupt_pin;              /* 0x3d */
+    uint8_t min_grant;                  /* 0x3e */
+    uint8_t max_latency;                /* 0x3f */
+}config_reg_t;
+
+
+/*
+ *  2100/2200 ISP I/O Register Set structure definitions.
+ */
+typedef volatile struct
+{
+    uint16_t flash_address;             /* Flash BIOS address */
+    uint16_t flash_data;                /* Flash BIOS data */
+    uint16_t unused_1[1];               /* Gap */
+    uint16_t ctrl_status;               /* Control/Status */
+        #define ISP_FLASH_ENABLE BIT_1  /* Flash BIOS Read/Write enable */
+        #define ISP_RESET       BIT_0   /* ISP soft reset */
+    uint16_t ictrl;                     /* Interrupt control */
+        #define ISP_EN_INT      BIT_15  /* ISP enable interrupts. */
+        #define ISP_EN_RISC     BIT_3   /* ISP enable RISC interrupts. */
+    uint16_t istatus;                   /* Interrupt status @0xa*/
+        #define RISC_INT        BIT_3   /* RISC interrupt */
+    uint16_t semaphore;                 /* Semaphore */
+    uint16_t nvram;                     /* NVRAM register. @0xe */
+        #define NV_DESELECT     0
+        #define NV_CLOCK        BIT_0
+        #define NV_SELECT       BIT_1
+        #define NV_DATA_OUT     BIT_2
+        #define NV_DATA_IN      BIT_3
+
+  /* 2100 and 2200 */
+    uint16_t mailbox0;                  /* Mailbox 0 @0x10 */
+    uint16_t mailbox1;                  /* Mailbox 1 */
+    uint16_t mailbox2;                  /* Mailbox 2 */
+    uint16_t mailbox3;                  /* Mailbox 3 */
+    uint16_t mailbox4;                  /* Mailbox 4 */
+    uint16_t mailbox5;                  /* Mailbox 5 */
+    uint16_t mailbox6;                  /* Mailbox 6 */
+    uint16_t mailbox7;                  /* Mailbox 7 */
+
+    uint16_t unused_2[0x3b];	/* Gap */
+    uint16_t fpm_diag_config;
+    uint16_t unused_3[0x6];		/* Gap */
+    uint16_t pcr;		/* Processor Control Register. */
+    uint16_t unused_4[0x5];		/* Gap */
+    uint16_t mctr;		/* Memory Configuration and Timing. */
+    uint16_t unused_5[0x3];		/* Gap */
+    uint16_t fb_cmd;
+    uint16_t unused_6[0x3];		/* Gap */
+    uint16_t host_cmd;                  /* Host command and control */
+
+        #define HOST_INT      BIT_7     /* host interrupt bit */
+#ifdef FC_IP_SUPPORT
+    uint16_t unused_3[0x0F];            /* Gap */
+    uint16_t mailbox8;                  /* Mailbox 8 */
+    uint16_t mailbox9;                  /* Mailbox 9 */
+    uint16_t mailbox10;                 /* Mailbox 10 */
+    uint16_t mailbox11;                 /* Mailbox 11 */
+    uint16_t mailbox12;                 /* Mailbox 12 */
+    uint16_t mailbox13;                 /* Mailbox 13 */
+    uint16_t mailbox14;                 /* Mailbox 14 */
+    uint16_t mailbox15;                 /* Mailbox 15 */
+    uint16_t mailbox16;                 /* Mailbox 16 */
+    uint16_t mailbox17;                 /* Mailbox 17 */
+    uint16_t mailbox18;                 /* Mailbox 18 */
+    uint16_t mailbox19;                 /* Mailbox 19 */
+    uint16_t mailbox20;                 /* Mailbox 20 */
+    uint16_t mailbox21;                 /* Mailbox 21 */
+    uint16_t mailbox22;                 /* Mailbox 22 */
+    uint16_t mailbox23;                 /* Mailbox 23 */
+#endif
+
+}device_reg_t;
+
+/*
+ *  2300 ISP I/O Register Set structure definitions.
+ */
+typedef volatile struct
+{
+    uint16_t flash_address;             /* Flash BIOS address */
+    uint16_t flash_data;                /* Flash BIOS data */
+    uint16_t unused_1[1];               /* Gap */
+    uint16_t ctrl_status;               /* Control/Status */
+        #define ISP_FLASH_ENABLE BIT_1  /* Flash BIOS Read/Write enable */
+        #define ISP_RESET       BIT_0   /* ISP soft reset */
+    uint16_t ictrl;                     /* Interrupt control */
+        #define ISP_EN_INT      BIT_15  /* ISP enable interrupts. */
+        #define ISP_EN_RISC     BIT_3   /* ISP enable RISC interrupts. */
+    uint16_t istatus;                   /* Interrupt status @0xa*/
+        #define RISC_2300_INT   BIT_15  /* 2300 RISC int for non-ROM cmds */
+    uint16_t semaphore;                 /* Semaphore */
+    uint16_t nvram;                     /* NVRAM register. @0xf */
+        #define NV_DESELECT     0
+        #define NV_CLOCK        BIT_0
+        #define NV_SELECT       BIT_1
+        #define NV_DATA_OUT     BIT_2
+        #define NV_DATA_IN      BIT_3
+  /* 2300 */
+  uint16_t req_q_in    /* @0x10 */;
+  uint16_t req_q_out   /* @0x12 */;
+  uint16_t rsp_q_in    /* @0x14 */;
+  uint16_t rsp_q_out   /* @0x16 */; 
+  uint32_t host_status /* @0x18 */;
+  uint16_t unused3[0x12];
+    uint16_t mailbox0;                  /* Mailbox 0 @0x40 */
+    uint16_t mailbox1;                  /* Mailbox 1 */
+    uint16_t mailbox2;                  /* Mailbox 2 */
+    uint16_t mailbox3;                  /* Mailbox 3 */
+    uint16_t mailbox4;                  /* Mailbox 4 */
+    uint16_t mailbox5;                  /* Mailbox 5 */
+    uint16_t mailbox6;                  /* Mailbox 6 */
+    uint16_t mailbox7;                  /* Mailbox 7 @0x4E */
+    uint16_t mailbox8;                  /* Mailbox 8 */
+    uint16_t mailbox9;                  /* Mailbox 9 */
+    uint16_t mailbox10;                 /* Mailbox 10 */
+    uint16_t mailbox11;                 /* Mailbox 11 */
+    uint16_t mailbox12;                 /* Mailbox 12 */
+    uint16_t mailbox13;                 /* Mailbox 13 */
+    uint16_t mailbox14;                 /* Mailbox 14 */
+    uint16_t mailbox15;                 /* Mailbox 15 */
+    uint16_t mailbox16;                 /* Mailbox 16 */
+    uint16_t mailbox17;                 /* Mailbox 17 */
+    uint16_t mailbox18;                 /* Mailbox 18 */
+    uint16_t mailbox19;                 /* Mailbox 19 */
+    uint16_t mailbox20;                 /* Mailbox 20 */
+    uint16_t mailbox21;                 /* Mailbox 21 */
+    uint16_t mailbox22;                 /* Mailbox 22 */
+    uint16_t mailbox23;                 /* Mailbox 23 */
+    uint16_t mailbox24;                  /* Mailbox 24 */
+    uint16_t mailbox25;                  /* Mailbox 25 */
+    uint16_t mailbox26;                 /* Mailbox 26 */
+    uint16_t mailbox27;                 /* Mailbox 27 */
+    uint16_t mailbox28;                 /* Mailbox 28 */
+    uint16_t mailbox29;                 /* Mailbox 29 */
+    uint16_t mailbox30;                 /* Mailbox 30 */
+    uint16_t mailbox31;                 /* Mailbox 31 @0x7E */
+    uint16_t unused4[0xb];  /* gap */
+
+    uint16_t fpm_diag_config;
+    uint16_t unused_3[0x6];		/* Gap */
+    uint16_t pcr;		/* Processor Control Register. */
+    uint16_t unused_4[0x5];		/* Gap */
+    uint16_t mctr;		/* Memory Configuration and Timing. */
+    uint16_t unused_5[0x3];		/* Gap */
+    uint16_t fb_cmd;
+    uint16_t unused_6[0x3];		/* Gap */
+    uint16_t host_cmd;                  /* Host command and control */
+
+        #define HOST_INT      BIT_7     /* host interrupt bit */
+#ifdef FC_IP_SUPPORT
+    uint16_t unused_3[0x0F];            /* Gap */
+    uint16_t mailbox8;                  /* Mailbox 8 */
+    uint16_t mailbox9;                  /* Mailbox 9 */
+    uint16_t mailbox10;                 /* Mailbox 10 */
+    uint16_t mailbox11;                 /* Mailbox 11 */
+    uint16_t mailbox12;                 /* Mailbox 12 */
+    uint16_t mailbox13;                 /* Mailbox 13 */
+    uint16_t mailbox14;                 /* Mailbox 14 */
+    uint16_t mailbox15;                 /* Mailbox 15 */
+    uint16_t mailbox16;                 /* Mailbox 16 */
+    uint16_t mailbox17;                 /* Mailbox 17 */
+    uint16_t mailbox18;                 /* Mailbox 18 */
+    uint16_t mailbox19;                 /* Mailbox 19 */
+    uint16_t mailbox20;                 /* Mailbox 20 */
+    uint16_t mailbox21;                 /* Mailbox 21 */
+    uint16_t mailbox22;                 /* Mailbox 22 */
+    uint16_t mailbox23;                 /* Mailbox 23 */
+#endif
+
+}device2300_reg_t;
+
+
+#define MAILBOX_REGISTER_COUNT  32
+
+/*
+ *  ISP product identification definitions in mailboxes after reset.
+ */
+#define PROD_ID_1           0x4953
+#define PROD_ID_2           0x0000
+#define PROD_ID_2a          0x5020
+#define PROD_ID_3           0x2020
+#define PROD_ID_4           0x1
+
+/*
+ * ISP host command and control register command definitions
+ */
+#define HC_RESET_RISC       0x1000      /* Reset RISC */
+#define HC_PAUSE_RISC       0x2000      /* Pause RISC */
+#define HC_RELEASE_RISC     0x3000      /* Release RISC from reset. */
+#define HC_SET_HOST_INT     0x5000      /* Set host interrupt */
+#define HC_CLR_HOST_INT     0x6000      /* Clear HOST interrupt */
+#define HC_CLR_RISC_INT     0x7000      /* Clear RISC interrupt */
+#define HC_RISC_PAUSE       BIT_5
+#define	HC_DISABLE_PARITY_PAUSE	0x4001	/* Disable parity error RISC pause. */
+
+#define SEMAPHORE_SET  0x1234
+
+/*
+ * ISP mailbox Self-Test status codes
+ */
+#define MBS_FRM_ALIVE       0           /* Firmware Alive. */
+#define MBS_CHKSUM_ERR      1           /* Checksum Error. */
+#define MBS_BUSY            4           /* Busy. */
+
+/*
+ * ISP mailbox command complete status codes
+ */
+#define MBS_CMD_CMP         0x4000      /* Command Complete. */
+#define MBS_INV_CMD         0x4001      /* Invalid Command. */
+#define MBS_HOST_INF_ERR    0x4002      /* Host Interface Error. */
+#define MBS_TEST_FAILED     0x4003      /* Test Failed. */
+#define MBS_CMD_ERR         0x4005      /* Command Error. */
+#define MBS_CMD_PARAM_ERR   0x4006      /* Command Parameter Error. */
+#define MBS_FATAL_ERROR     0xF000      /* Command Fatal Error. */
+
+#define MBS_FIRMWARE_ALIVE          0x0000 
+#define MBS_COMMAND_COMPLETE        0x4000 
+#define MBS_INVALID_COMMAND         0x4001 
+
+/* QLogic subroutine status definitions */
+#define QL_STATUS_SUCCESS           0
+#define QL_STATUS_ERROR             1
+#define QL_STATUS_FATAL_ERROR       2
+#define QL_STATUS_RESOURCE_ERROR    3
+#define QL_STATUS_LOOP_ID_IN_USE    4
+#define QL_STATUS_NO_DATA           5
+
+/*
+ * ISP mailbox asynchronous event status codes
+ */
+#define MBA_ASYNC_EVENT         0x8000  /* Asynchronous event. */
+#define MBA_RESET               0x8001  /* Reset Detected. */
+#define MBA_SYSTEM_ERR          0x8002  /* System Error. */
+#define MBA_REQ_TRANSFER_ERR    0x8003  /* Request Transfer Error. */
+#define MBA_RSP_TRANSFER_ERR    0x8004  /* Response Transfer Error. */
+#define MBA_WAKEUP_THRES        0x8005  /* Request Queue Wake-up. */
+#define MBA_LIP_OCCURRED        0x8010  /* Loop Initialization Procedure */
+                                        /* occurred. */
+#define MBA_LOOP_UP             0x8011  /* FC Loop UP. */
+#define MBA_LOOP_DOWN           0x8012  /* FC Loop Down. */
+#define MBA_LIP_RESET           0x8013  /* LIP reset occurred. */
+#define MBA_PORT_UPDATE         0x8014  /* Port Database update. */
+#define MBA_SCR_UPDATE          0x8015  /* State Change Registration. */
+#define MBA_SCSI_COMPLETION     0x8020  /* SCSI Command Complete. */
+#define MBA_CTIO_COMPLETION     0x8021  /* CTIO Complete. */
+#ifdef ISP2200
+#define MBA_LINK_MODE_UP        0x8030  /* FC Link Mode UP. */
+#define MBA_UPDATE_CONFIG       0x8036  /* FC Update Configuration. */
+#endif
+
+/*
+ * ISP mailbox commands
+ */
+#define MBC_LOAD_RAM              1     /* Load RAM. */
+#define MBC_EXECUTE_FIRMWARE      2     /* Execute firmware. */
+#define MBC_WRITE_RAM_WORD        4     /* Write RAM word. */
+#define MBC_READ_RAM_WORD         5     /* Read RAM word. */
+#define MBC_MAILBOX_REGISTER_TEST 6     /* Wrap incoming mailboxes */
+#define MBC_VERIFY_CHECKSUM       7     /* Verify checksum. */
+#define MBC_ABOUT_FIRMWARE        8     /* Get firmware revision. */
+#define MBC_DUMP_RAM              0xA   /* READ BACK FW */
+#define MBC_DUMP_SRAM             0xC   /* Dump SRAM    */
+#define MBC_IOCB_EXECUTE          0x12  /* Execute an IOCB command */
+#define MBC_ABORT_COMMAND         0x15  /* Abort IOCB command. */
+#define MBC_ABORT_DEVICE          0x16  /* Abort device (ID/LUN). */
+#define MBC_ABORT_TARGET          0x17  /* Abort target (ID). */
+#define MBC_TARGET_RESET          0x18  /* Target reset. */
+#define MBC_GET_ADAPTER_LOOP_ID   0x20  /* Get loop id of ISP2100. */
+#define MBC_SET_TARGET_PARAMATERS 0x38  /* Set target parameters. */
+#define MBC_DIAGNOSTIC_LOOP_BACK  0x45  /* Perform LoopBack diagnostic */
+#define MBC_INITIALIZE_FIRMWARE   0x60  /* Initialize firmware */
+#define MBC_INITIATE_LIP          0x62  /* Initiate Loop Initialization */
+                                        /* Procedure */
+#define MBC_GET_PORT_DATABASE     0x64  /* Get port database. */
+#define MBC_GET_FIRMWARE_STATE    0x69  /* Get firmware state. */
+#define MBC_GET_PORT_NAME         0x6a  /* Get port name. */
+#define MBC_LIP_RESET             0x6c  /* LIP reset. */
+#define MBC_SEND_SNS_COMMAND      0x6e  /* Send Simple Name Server command. */
+#define MBC_LOGIN_FABRIC_PORT     0x6f  /* Login fabric port. */
+#define MBC_LOGOUT_FABRIC_PORT    0x71  /* Logout fabric port. */
+#define MBC_LIP_FULL_LOGIN        0x72  /* Full login LIP. */
+#define MBC_GET_PORT_LIST         0x75  /* Get port list. */
+
+/*
+ * Firmware state codes from get firmware state mailbox command
+ */
+#define FSTATE_CONFIG_WAIT      0
+#define FSTATE_WAIT_AL_PA       1
+#define FSTATE_WAIT_LOGIN       2
+#define FSTATE_READY            3
+#define FSTATE_LOSS_OF_SYNC     4
+#define FSTATE_ERROR            5
+#define FSTATE_REINIT           6
+#define FSTATE_NON_PART         7
+
+#define FSTATE_CONFIG_CORRECT      0
+#define FSTATE_P2P_RCV_LIP         1
+#define FSTATE_P2P_CHOOSE_LOOP     2
+#define FSTATE_P2P_RCV_UNIDEN_LIP  3
+#define FSTATE_FATAL_ERROR         4
+#define FSTATE_LOOP_BACK_CONN      5
+
+/*
+ * ISP Initialization Control Block.
+ */
+typedef struct
+{
+    uint8_t  version;
+        #define ICB_VERSION 1
+    uint8_t  reserved_1;
+    struct
+    {
+        uint8_t enable_hard_loop_id          :1; /* bit 0 */
+        uint8_t enable_fairness              :1;
+        uint8_t enable_full_duplex           :1;
+        uint8_t enable_fast_posting          :1;
+        uint8_t enable_target_mode           :1;
+        uint8_t disable_initiator_mode       :1;
+        uint8_t enable_adisc                 :1;
+        uint8_t enable_lun_response          :1; /* bit 7 */
+        uint8_t enable_port_update_event     :1;
+        uint8_t disable_initial_lip          :1;
+        uint8_t enable_decending_soft_assign :1;
+        uint8_t previous_assigned_addressing :1;
+        uint8_t enable_stop_q_on_full        :1;
+        uint8_t enable_full_login_on_lip     :1;
+        uint8_t enable_name_change           :1;
+        uint8_t expanded_ifwcb               :1; /* bit 15 */
+    }firmware_options;
+    uint16_t frame_length;
+    uint16_t iocb_allocation;
+    uint16_t execution_throttle;
+    uint8_t  retry_count;
+    uint8_t  retry_delay;
+#ifdef ISP2200
+    uint8_t  port_name[8];
+#else
+    uint8_t  node_name[8];
+#endif
+    uint16_t adapter_hard_loop_id;
+    uint8_t  inquiry_data;
+    uint8_t  login_timeout;
+#ifdef ISP2200
+    uint8_t  node_name[8];
+#else
+    uint8_t  reserved_1[8];
+#endif
+    uint16_t request_q_outpointer;
+    uint16_t response_q_inpointer;
+    uint16_t request_q_length;
+    uint16_t response_q_length;
+    uint32_t request_q_address[2];
+    uint32_t response_q_address[2];
+    uint16_t lun_enables;
+    uint8_t  command_resource_count;
+    uint8_t  immediate_notify_resource_count;
+    uint16_t timeout;
+    uint16_t reserved_2;
+    struct
+    {
+        uint8_t operation_mode               :4; /* Bits 0 1 2 3 */
+        uint8_t connection_options           :3; /* Bits 4 5 6 */
+                #define LOOP      0
+                #define P2P       1
+                #define LOOP_P2P  2
+                #define P2P_LOOP  3
+        uint8_t nonpart_if_hard_addr_failed  :1; /* Bit 7 */
+        uint8_t enable_class2                :1; /* Bit 8 */
+        uint8_t enable_ack0                  :1; /* Bit 9 */
+        uint8_t unused_10                    :1; /* bit 10 */
+        uint8_t unused_11                    :1; /* bit 11 */
+        uint8_t enable_fc_tape               :1; /* bit 12 */
+        uint8_t enable_fc_confirm            :1; /* bit 13 */
+        uint8_t enable_cmd_q_target_mode     :1; /* bit 14 */
+        uint8_t unused_15                    :1; /* bit 15 */
+    }additional_firmware_options;
+    uint8_t     response_accum_timer;
+    uint8_t     interrupt_delay_timer;
+    struct
+    {
+      uint8_t enable_read_xfr_rdy            :1; /* Bit 0 */
+      uint8_t soft_id_only                   :1; /* Bit 1 */
+      uint8_t unused_2                       :1; /* Bit 2 */
+      uint8_t unused_3                       :1; /* Bit 3 */
+      uint8_t fcp_rsp_payload                :2; /* Bits 4 5 */
+              #define send_24_bytes_0          0
+              #define send_12_bytes_0          1
+              #define second_send_24_bytes_0   2
+              #define send_32_bytes_0          3 
+      uint8_t unused_6                       :1; /* Bit 6 */
+      uint8_t unused_7                       :1; /* Bit 7 */
+      uint8_t unused_8                       :1; /* Bit 8 */
+      uint8_t unused_9                       :1; /* Bit 9 */
+      uint8_t unused_10                      :1; /* Bit 10 */
+      uint8_t unused_11                      :1; /* Bit 11 */
+      uint8_t unused_12                      :1; /* Bit 12 */
+      uint8_t set_50_ohms_term_enable        :1; /* Bit 13 */
+      uint8_t data_rate                      :2; /* Bits 14 15 */
+              #define set_1_gig_rate       0
+              #define set_2_gig_rate       1
+              #define auto_negotiate       2
+    }special_options;
+    uint16_t    reserved_3[13];
+}init_cb_t;
+
+/*
+ * ISP Get/Set Target Parameters mailbox command control flags.
+ */
+
+/*
+ * NVRAM Command values.
+ */
+#define NV_START_BIT            BIT_2
+#define NV_WRITE_OP             (BIT_26+BIT_24)
+#define NV_READ_OP              (BIT_26+BIT_25)
+#define NV_ERASE_OP             (BIT_26+BIT_25+BIT_24)
+#define NV_MASK_OP              (BIT_26+BIT_25+BIT_24)
+#define NV_DELAY_COUNT          10
+
+/*
+ *  ISP2200 NVRAM structure definitions.
+ */
+typedef struct
+{
+    /*
+     * NVRAM header
+     */
+
+    uint8_t     id[4];
+    uint8_t     nvram_version;
+    uint8_t     reserved_0;
+
+    /*
+     * NVRAM RISC parameter block
+     */
+
+    uint8_t     parameter_block_version;
+    uint8_t     reserved_1;
+
+    struct
+    {
+        uint8_t enable_hard_loop_id          :1;
+        uint8_t enable_fairness              :1;
+        uint8_t enable_full_duplex           :1;
+        uint8_t enable_fast_posting          :1;
+        uint8_t enable_target_mode           :1;
+        uint8_t disable_initiator_mode       :1;
+        uint8_t enable_adisc                 :1;
+        uint8_t enable_lun_response          :1;
+        uint8_t enable_port_update_event     :1;
+        uint8_t disable_initial_lip          :1;
+        uint8_t enable_decending_soft_assign :1;
+        uint8_t previous_assigned_addressing :1;
+        uint8_t enable_stop_q_on_full        :1;
+        uint8_t enable_full_login_on_lip     :1;
+        uint8_t enable_name_change           :1;
+        uint8_t expanded_ifwcb               :1;
+    }firmware_options;
+
+    uint16_t    frame_payload_size;
+    uint16_t    max_iocb_allocation;
+    uint16_t    execution_throttle;
+    uint8_t     retry_count;
+    uint8_t     retry_delay;
+    uint8_t     port_name[8];
+    uint16_t    adapter_hard_loop_id;
+    uint8_t     inquiry_data;
+    uint8_t     login_timeout;
+
+    uint8_t     node_name[8];
+
+    /* Expanded RISC parameter block */
+    struct
+    {
+        uint8_t operation_mode               :4;
+        uint8_t connection_options           :3;
+        uint8_t nonpart_if_hard_addr_failed  :1;
+        uint8_t enable_class2                :1;
+        uint8_t enable_ack0                  :1;
+        uint8_t unused_10                    :1;
+        uint8_t unused_11                    :1;
+        uint8_t enable_fc_tape               :1;
+        uint8_t enable_fc_confirm            :1;
+        uint8_t enable_command_reference_num :1;
+    }additional_firmware_options;
+
+    uint8_t     response_accum_timer;
+    uint8_t     interrupt_delay_timer;
+    uint16_t    reserved_2[14];
+
+    /*
+     * NVRAM host parameter block
+     */
+
+    struct
+    {
+        uint8_t unused_0                :1;
+        uint8_t disable_bios            :1;
+        uint8_t disable_luns            :1;
+        uint8_t enable_selectable_boot  :1;
+        uint8_t disable_risc_code_load  :1;
+        uint8_t set_cache_line_size_1   :1;
+        uint8_t pci_parity_disable      :1;
+        uint8_t enable_extended_logging :1;
+        uint8_t enable_64bit_addressing :1;
+        uint8_t enable_lip_reset        :1;
+        uint8_t enable_lip_full_login   :1;
+        uint8_t enable_target_reset     :1;
+        uint8_t enable_database_storage :1;
+        uint8_t unused_13               :1;
+        uint8_t unused_14               :1;
+        uint8_t unused_15               :1;
+    }host_p;
+
+    uint8_t     boot_node_name[8];
+    uint8_t     boot_lun_number;
+    uint8_t     reset_delay;
+    uint8_t     port_down_retry_count;
+    uint8_t     reserved_3;
+
+   uint16_t    maximum_luns_per_target;
+
+    uint16_t    reserved_6[7];
+
+    /* Offset 100 */
+    uint16_t    reserved_7[25];
+
+    /* Offset 150 */
+    uint16_t    reserved_8[25];
+
+    /* Offset 200 */
+    uint8_t oem_id;
+
+    uint8_t oem_spare0;
+
+    uint8_t oem_string[6];
+
+    uint8_t oem_part[8];
+
+    uint8_t oem_fru[8];
+
+    uint8_t oem_ec[8];
+
+
+    /* Offset 232 */
+    struct
+    {
+        uint8_t external_gbic           :1;
+        uint8_t risc_ram_parity         :1;
+        uint8_t buffer_plus_module      :1;
+        uint8_t multi_chip_hba          :1;
+        uint8_t unused_1                :1;
+        uint8_t unused_2                :1;
+        uint8_t unused_3                :1;
+        uint8_t unused_4                :1;
+        uint8_t unused_5                :1;
+        uint8_t unused_6                :1;
+        uint8_t unused_7                :1;
+        uint8_t unused_8                :1;
+        uint8_t unused_9                :1;
+        uint8_t unused_10               :1;
+        uint8_t unused_11               :1;
+        uint8_t unused_12               :1;
+    }hba_features;
+
+    uint16_t   reserved_9;
+    uint16_t   reserved_10;
+    uint16_t   reserved_11;
+
+    uint16_t   reserved_12;
+    uint16_t   reserved_13;
+
+    /* Subsystem ID must be at offset 244 */
+    uint16_t    subsystem_vendor_id;
+
+    uint16_t    reserved_14;
+
+    /* Subsystem device ID must be at offset 248 */
+    uint16_t    subsystem_device_id;
+
+    uint16_t    reserved_15[2];
+    uint8_t     reserved_16;
+    uint8_t     checksum;
+}nvram22_t;
+
+typedef struct
+{
+    /*
+     * NVRAM header for 2100 board.
+     */
+
+    uint8_t     id[4];
+    uint8_t     nvram_version;
+    uint8_t     reserved_0;
+
+    /*
+     * NVRAM RISC parameter block
+     */
+
+    uint8_t     parameter_block_version;
+    uint8_t     reserved_1;
+
+    struct
+    {
+        uint8_t enable_hard_loop_id          :1;
+        uint8_t enable_fairness              :1;
+        uint8_t enable_full_duplex           :1;
+        uint8_t enable_fast_posting          :1;
+        uint8_t enable_target_mode           :1;
+        uint8_t disable_initiator_mode       :1;
+        uint8_t enable_adisc                 :1;
+        uint8_t enable_lun_response          :1;
+        uint8_t enable_port_update_event     :1;
+        uint8_t disable_initial_lip          :1;
+        uint8_t enable_decending_soft_assign :1;
+        uint8_t previous_assigned_addressing :1;
+        uint8_t enable_stop_q_on_full        :1;
+        uint8_t enable_full_login_on_lip     :1;
+        uint8_t enable_name_change           :1;
+        uint8_t unused_15                    :1;
+    }firmware_options;
+
+    uint16_t    frame_payload_size;
+    uint16_t    max_iocb_allocation;
+    uint16_t    execution_throttle;
+    uint8_t     retry_count;
+    uint8_t     retry_delay;
+    uint8_t     node_name[8];
+    uint16_t    adapter_hard_loop_id;
+    uint8_t     reserved_2;
+    uint8_t     login_timeout;
+    uint16_t    reserved_3[4];
+
+    /* Reserved for expanded RISC parameter block */
+    uint16_t    reserved_4[16];
+
+    /*
+     * NVRAM host parameter block
+     */
+
+    struct
+    {
+        uint8_t unused_0                :1;
+        uint8_t disable_bios            :1;
+        uint8_t disable_luns            :1;
+        uint8_t enable_selectable_boot  :1;
+        uint8_t disable_risc_code_load  :1;
+        uint8_t set_cache_line_size_1   :1;
+        uint8_t pci_parity_disable      :1;
+        uint8_t enable_extended_logging :1;
+        uint8_t enable_64bit_addressing :1;
+        uint8_t enable_lip_reset        :1;
+        uint8_t enable_lip_full_login   :1;
+        uint8_t enable_target_reset     :1;
+        uint8_t enable_database_storage :1;
+        uint8_t unused_13               :1;
+        uint8_t unused_14               :1;
+        uint8_t unused_15               :1;
+    }host_p;
+
+    uint8_t     boot_node_name[8];
+    uint8_t     boot_lun_number;
+    uint8_t     reset_delay;
+    uint8_t     port_down_retry_count;
+    uint8_t     reserved_5;
+
+    uint16_t    maximum_luns_per_target;
+
+    uint16_t    reserved_6[7];
+
+    /* Offset 100 */
+    uint16_t    reserved_7[25];
+
+    /* Offset 150 */
+    uint16_t    reserved_8[25];
+
+    /* Offset 200 */
+    uint16_t    reserved_9[22];
+
+    /* Subsystem ID must be at offset 244 */
+    uint16_t    subsystem_vendor_id;
+
+    uint16_t    reserved_10;
+
+    /* Subsystem device ID must be at offset 248 */
+    uint16_t    subsystem_device_id;
+
+    uint16_t    reserved_11[2];
+    uint8_t     reserved_12;
+    uint8_t     checksum;
+}nvram21_t;
+
+/*
+ * ISP queue - command entry structure definition.
+ */
+#define MAX_CMDSZ   16                  /* SCSI maximum CDB size. */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define COMMAND_TYPE    0x11    /* Command entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t handle;                    /* System handle. */
+    uint8_t  reserved;
+    uint8_t  target;                    /* SCSI ID */
+    uint16_t lun;                       /* SCSI LUN */
+    uint16_t control_flags;             /* Control flags. */
+#define CF_HEAD_TAG		BIT_1
+#define CF_ORDERED_TAG		BIT_2
+#define CF_SIMPLE_TAG		BIT_3
+#define CF_READ		BIT_5
+#define CF_WRITE		BIT_6
+#define CF_NO_FAST_POSTING      BIT_7
+    uint16_t reserved_1;
+    uint16_t timeout;                   /* Command timeout. */
+    uint16_t dseg_count;                /* Data segment count. */
+    uint8_t  scsi_cdb[MAX_CMDSZ];       /* SCSI command words. */
+    uint32_t byte_count;                /* Total byte count. */
+    uint32_t dseg_0_address;            /* Data segment 0 address. */
+    uint32_t dseg_0_length;             /* Data segment 0 length. */
+    uint32_t dseg_1_address;            /* Data segment 1 address. */
+    uint32_t dseg_1_length;             /* Data segment 1 length. */
+    uint32_t dseg_2_address;            /* Data segment 2 address. */
+    uint32_t dseg_2_length;             /* Data segment 2 length. */
+}cmd_entry_t;
+
+/*
+ * ISP queue - 64-Bit addressing, command entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define COMMAND_A64_TYPE 0x19   /* Command A64 entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t handle;                    /* System handle. */
+    uint8_t  reserved;
+    uint8_t  target;                    /* SCSI ID */
+    uint16_t lun;                       /* SCSI LUN */
+    uint16_t control_flags;             /* Control flags. */
+    uint16_t reserved_1;
+    uint16_t timeout;                   /* Command timeout. */
+    uint16_t dseg_count;                /* Data segment count. */
+    uint8_t  scsi_cdb[MAX_CMDSZ];       /* SCSI command words. */
+    uint32_t byte_count;                /* Total byte count. */
+    uint32_t dseg_0_address[2];         /* Data segment 0 address. */
+    uint32_t dseg_0_length;             /* Data segment 0 length. */
+    uint32_t dseg_1_address[2];         /* Data segment 1 address. */
+    uint32_t dseg_1_length;             /* Data segment 1 length. */
+}cmd_a64_entry_t, request_t;
+
+/*
+ * ISP queue - continuation entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define CONTINUE_TYPE   0x02    /* Continuation entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t reserved;
+    uint32_t dseg_0_address;            /* Data segment 0 address. */
+    uint32_t dseg_0_length;             /* Data segment 0 length. */
+    uint32_t dseg_1_address;            /* Data segment 1 address. */
+    uint32_t dseg_1_length;             /* Data segment 1 length. */
+    uint32_t dseg_2_address;            /* Data segment 2 address. */
+    uint32_t dseg_2_length;             /* Data segment 2 length. */
+    uint32_t dseg_3_address;            /* Data segment 3 address. */
+    uint32_t dseg_3_length;             /* Data segment 3 length. */
+    uint32_t dseg_4_address;            /* Data segment 4 address. */
+    uint32_t dseg_4_length;             /* Data segment 4 length. */
+    uint32_t dseg_5_address;            /* Data segment 5 address. */
+    uint32_t dseg_5_length;             /* Data segment 5 length. */
+    uint32_t dseg_6_address;            /* Data segment 6 address. */
+    uint32_t dseg_6_length;             /* Data segment 6 length. */
+}cont_entry_t;
+
+/*
+ * ISP queue - 64-Bit addressing, continuation entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define CONTINUE_A64_TYPE 0x0A  /* Continuation A64 entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t dseg_0_address[2];         /* Data segment 0 address. */
+    uint32_t dseg_0_length;             /* Data segment 0 length. */
+    uint32_t dseg_1_address[2];         /* Data segment 1 address. */
+    uint32_t dseg_1_length;             /* Data segment 1 length. */
+    uint32_t dseg_2_address[2];         /* Data segment 2 address. */
+    uint32_t dseg_2_length;             /* Data segment 2 length. */
+    uint32_t dseg_3_address[2];         /* Data segment 3 address. */
+    uint32_t dseg_3_length;             /* Data segment 3 length. */
+    uint32_t dseg_4_address[2];         /* Data segment 4 address. */
+    uint32_t dseg_4_length;             /* Data segment 4 length. */
+}cont_a64_entry_t;
+
+/*
+ * ISP queue - status entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define STATUS_TYPE     0x03    /* Status entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+        #define RF_INV_E_ORDER  BIT_5   /* Invalid entry order. */
+        #define RF_INV_E_COUNT  BIT_4   /* Invalid entry count. */
+        #define RF_INV_E_PARAM  BIT_3   /* Invalid entry parameter. */
+        #define RF_INV_E_TYPE   BIT_2   /* Invalid entry type. */
+        #define RF_BUSY         BIT_1   /* Busy */
+    uint32_t handle;                    /* System handle. */
+    uint16_t scsi_status;               /* SCSI status. */
+    uint16_t comp_status;               /* Completion status. */
+    uint16_t state_flags;               /* State flags. */
+    uint16_t status_flags;              /* Status flags. */
+    #define IOCBSTAT_SF_LOGO   0x2000	/* logo after 2 abts w/ no response (2 sec) */
+    uint16_t rsp_info_len;              /* Response Info Length. */
+    uint16_t req_sense_length;          /* Request sense data length. */
+    uint32_t residual_length;           /* Residual transfer length. */
+    uint8_t  rsp_info[8];               /* FCP response information. */
+    uint8_t  req_sense_data[32];        /* Request sense data. */
+}sts_entry_t, response_t;
+
+/*
+ * ISP queue - marker entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define MARKER_TYPE     0x04    /* Marker entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved;
+    uint8_t  target;                    /* SCSI ID */
+    uint8_t  modifier;                  /* Modifier (7-0). */
+        #define MK_SYNC_ID_LUN      0   /* Synchronize ID/LUN */
+        #define MK_SYNC_ID          1   /* Synchronize ID */
+        #define MK_SYNC_ALL         2   /* Synchronize all ID/LUN */
+        #define MK_SYNC_LIP         3   /* Synchronize all ID/LUN, */
+                                        /* clear port changed, */
+                                        /* use sequence number. */
+    uint8_t  reserved_1;
+    uint16_t sequence_number;           /* Sequence number of event */
+    uint16_t lun;                       /* SCSI LUN */
+    uint8_t  reserved_2[48];
+}mrk_entry_t;
+
+/*
+ * ISP queue - enable LUN entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define ENABLE_LUN_TYPE 0x0B    /* Enable LUN entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  reserved_1;
+    uint16_t reserved_2;
+    uint32_t reserved_3;
+    uint8_t  status;
+    uint8_t  reserved_4;
+    uint8_t  command_count;             /* Number of ATIOs allocated. */
+    uint8_t  immed_notify_count;        /* Number of Immediate Notify */
+                                        /* entries allocated. */
+    uint16_t reserved_5;
+    uint16_t timeout;                   /* 0 = 30 seconds, 0xFFFF = disable */
+    uint16_t reserved_6[20];
+}elun_entry_t;
+
+/*
+ * ISP queue - modify LUN entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define MODIFY_LUN_TYPE 0x0C    /* Modify LUN entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  reserved_1;
+    uint8_t  operators;
+    uint8_t  reserved_2;
+    uint32_t reserved_3;
+    uint8_t  status;
+    uint8_t  reserved_4;
+    uint8_t  command_count;             /* Number of ATIOs allocated. */
+    uint8_t  immed_notify_count;        /* Number of Immediate Notify */
+                                        /* entries allocated. */
+    uint16_t reserved_5;
+    uint16_t timeout;                   /* 0 = 30 seconds, 0xFFFF = disable */
+    uint16_t reserved_7[20];
+}modify_lun_entry_t;
+
+/*
+ * ISP queue - immediate notify entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define IMMED_NOTIFY_TYPE 0x0D  /* Immediate notify entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  initiator_id;
+    uint8_t  reserved_1;
+    uint8_t  target_id;
+    uint32_t reserved_2;
+    uint16_t status;
+    uint16_t task_flags;
+    uint16_t seq_id;
+    uint16_t reserved_5[11];
+    uint16_t scsi_status;
+    uint8_t  sense_data[18];
+}notify_entry_t;
+
+/*
+ * ISP queue - notify acknowledge entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define NOTIFY_ACK_TYPE 0x0E    /* Notify acknowledge entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  initiator_id;
+    uint8_t  reserved_1;
+    uint8_t  target_id;
+    uint16_t flags;
+    uint16_t reserved_2;
+    uint16_t status;
+    uint16_t task_flags;
+    uint16_t seq_id;
+    uint16_t reserved_3[21];
+}nack_entry_t;
+
+/*
+ * ISP queue - Accept Target I/O (ATIO) entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define ACCEPT_TGT_IO_TYPE 0x16 /* Accept target I/O entry. */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  initiator_id;
+    uint16_t exchange_id;
+    uint16_t flags;
+    uint16_t status;
+    uint8_t  reserved_1;
+    uint8_t  task_codes;
+    uint8_t  task_flags;
+    uint8_t  execution_codes;
+    uint8_t  cdb[MAX_CMDSZ];
+    uint32_t data_length;
+    uint16_t lun;
+    uint16_t reserved_2A;
+    uint16_t scsi_status;
+    uint8_t  sense_data[18];
+}atio_entry_t;
+
+/*
+ * ISP queue - Continue Target I/O (CTIO) entry for status mode 0
+ *             structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                  /* Entry type. */
+        #define CONTINUE_TGT_IO_TYPE 0x17 /* CTIO entry */
+    uint8_t  entry_count;                 /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  initiator_id;
+    uint16_t exchange_id;
+    uint16_t flags;
+    uint16_t status;
+    uint16_t timeout;                   /* 0 = 30 seconds, 0xFFFF = disable */
+    uint16_t dseg_count;                /* Data segment count. */
+    uint32_t relative_offset;
+    uint32_t residual;
+    uint16_t reserved_1[3];
+    uint16_t scsi_status;
+    uint32_t transfer_length;
+    uint32_t dseg_0_address;            /* Data segment 0 address. */
+    uint32_t dseg_0_length;             /* Data segment 0 length. */
+    uint32_t dseg_1_address;            /* Data segment 1 address. */
+    uint32_t dseg_1_length;             /* Data segment 1 length. */
+    uint32_t dseg_2_address;            /* Data segment 2 address. */
+    uint32_t dseg_2_length;             /* Data segment 2 length. */
+}ctio_entry_t;
+
+/*
+ * ISP queue - CTIO returned entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define CTIO_RET_TYPE   0x17    /* CTIO return entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  initiator_id;
+    uint16_t exchange_id;
+    uint16_t flags;
+    uint16_t status;
+    uint16_t timeout;                   /* 0 = 30 seconds, 0xFFFF = disable */
+    uint16_t dseg_count;                /* Data segment count. */
+    uint32_t relative_offset;
+    uint32_t residual;
+    uint16_t reserved_1[8];
+    uint16_t scsi_status;
+    uint8_t  sense_data[18];
+}ctio_ret_entry_t;
+
+/*
+ * ISP queue - CTIO A64 entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define CTIO_A64_TYPE 0x1F      /* CTIO A64 entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  initiator_id;
+    uint16_t exchange_id;
+    uint16_t flags;
+    uint16_t status;
+    uint16_t timeout;                   /* 0 = 30 seconds, 0xFFFF = disable */
+    uint16_t dseg_count;                /* Data segment count. */
+    uint32_t relative_offset;
+    uint32_t residual;
+    uint16_t reserved_1[3];
+    uint16_t scsi_status;
+    uint32_t transfer_length;
+    uint32_t dseg_0_address[2];         /* Data segment 0 address. */
+    uint32_t dseg_0_length;             /* Data segment 0 length. */
+    uint32_t dseg_1_address[2];         /* Data segment 1 address. */
+    uint32_t dseg_1_length;             /* Data segment 1 length. */
+}ctio_a64_entry_t;
+
+/*
+ * ISP queue - CTIO returned entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define CTIO_A64_RET_TYPE 0x1F  /* CTIO A64 returned entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint8_t  reserved_8;
+    uint8_t  initiator_id;
+    uint16_t exchange_id;
+    uint16_t flags;
+    uint16_t status;
+    uint16_t timeout;                   /* 0 = 30 seconds, 0xFFFF = disable */
+    uint16_t dseg_count;                /* Data segment count. */
+    uint32_t relative_offset;
+    uint32_t residual;
+    uint16_t reserved_1[8];
+    uint16_t scsi_status;
+    uint8_t  sense_data[18];
+}ctio_a64_ret_entry_t;
+
+/*
+ * ISP queue - Status Contination entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define STATUS_CONT_TYPE 0x10   /* Status contination entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  reserved;
+    uint8_t  entry_status;              /* Entry Status. */
+    uint8_t  sense_data[60];
+}status_cont_entry_t;
+
+/*
+ * ISP queue - Command Set entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define CMD_SET_TYPE 0x18       /* Command set entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint16_t reserved;
+    uint16_t status;
+    uint16_t control_flags;             /* Control flags. */
+    uint16_t count;
+    uint32_t iocb_0_address;
+    uint32_t iocb_1_address;
+    uint32_t iocb_2_address;
+    uint32_t iocb_3_address;
+    uint32_t iocb_4_address;
+    uint32_t iocb_5_address;
+    uint32_t iocb_6_address;
+    uint32_t iocb_7_address;
+    uint32_t iocb_8_address;
+    uint32_t iocb_9_address;
+    uint32_t iocb_10_address;
+    uint32_t iocb_11_address;
+}cmd_set_entry_t;
+
+/*
+ * ISP queue - Command Set A64 entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define CMD_SET_TYPE 0x18       /* Command set entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t sys_define_2;              /* System defined. */
+    uint16_t reserved;
+    uint16_t status;
+    uint16_t control_flags;             /* Control flags. */
+    uint16_t count;
+    uint32_t iocb_0_address[2];
+    uint32_t iocb_1_address[2];
+    uint32_t iocb_2_address[2];
+    uint32_t iocb_3_address[2];
+    uint32_t iocb_4_address[2];
+    uint32_t iocb_5_address[2];
+}cmd_set_a64_entry_t;
+
+/* 4.11
+ * ISP queue - Command Set entry structure definition.
+ */
+typedef struct
+{
+    uint8_t  entry_type;                /* Entry type. */
+        #define MS_IOCB_TYPE 0x29       /*  Management Server IOCB entry */
+    uint8_t  entry_count;               /* Entry count. */
+    uint8_t  sys_define;                /* System defined. */
+    uint8_t  entry_status;              /* Entry Status. */
+    uint32_t handle;                    /* System handle. */
+    uint8_t  reserved;
+    uint8_t  loop_id;
+    uint16_t status;
+    uint16_t control_flags;             /* Control flags. */
+    uint16_t reserved2;
+    uint16_t timeout;
+    uint16_t DSDcount;
+    uint16_t RespDSDcount;
+    uint8_t  reserved3[10];
+    uint32_t Response_bytecount;
+    uint32_t Request_bytecount;
+    uint32_t dseg_req_address[2];         /* Data segment 0 address. */
+    uint32_t dseg_req_length;             /* Data segment 0 length. */
+    uint32_t dseg_rsp_address[2];         /* Data segment 1 address. */
+    uint32_t dseg_rsp_length;             /* Data segment 1 length. */
+}cmd_ms_iocb_entry_t;
+
+
+/*
+ * ISP request and response queue entry sizes
+ */
+#define RESPONSE_ENTRY_SIZE     (sizeof(response_t))
+#define REQUEST_ENTRY_SIZE      (sizeof(request_t))
+
+/*
+ * ISP status entry - completion status definitions.
+ */
+#define CS_COMPLETE         0x0         /* No errors */
+#define CS_INCOMPLETE       0x1         /* Incomplete transfer of cmd. */
+#define CS_DMA              0x2         /* A DMA direction error. */
+#define CS_TRANSPORT        0x3         /* Transport error. */
+#define CS_RESET            0x4         /* SCSI bus reset occurred */
+#define CS_ABORTED          0x5         /* System aborted command. */
+#define CS_TIMEOUT          0x6         /* Timeout error. */
+#define CS_DATA_OVERRUN     0x7         /* Data overrun. */
+#define CS_DATA_UNDERRUN    0x15        /* Data Underrun. */
+#define CS_ABORT_MSG        0xE         /* Target rejected abort msg. */
+#define CS_DEV_RESET_MSG    0x12        /* Target rejected dev rst msg. */
+#define CS_PORT_UNAVAILABLE 0x28        /* Port unavailable (selection timeout) */
+#define CS_PORT_LOGGED_OUT  0x29        /* Port Logged Out */
+#define CS_PORT_CONFIG_CHG  0x2A        /* Port Configuration Changed */
+#define CS_PORT_BUSY        0x2B        /* Port Busy */
+#define CS_BAD_PAYLOAD      0x80        /* Driver defined */
+#define CS_UNKNOWN          0x81        /* Driver defined */
+#define CS_RETRY            0x82        /* Driver defined */
+
+/*
+ * ISP status entry - SCSI status byte bit definitions.
+ */
+#define SS_RESIDUAL_UNDER       BIT_11
+#define SS_RESIDUAL_OVER        BIT_10
+#define SS_SENSE_LEN_VALID      BIT_9
+#ifdef ISP2200
+#define SS_RESPONSE_INFO_LEN_VALID BIT_8
+#else
+#define SS_RESIDUAL_LEN_VALID   BIT_8
+#endif
+
+#define SS_RESERVE_CONFLICT     (BIT_4 | BIT_3)
+#define SS_BUSY_CONDITION       BIT_3
+#define SS_CONDITION_MET        BIT_2
+#define SS_CHECK_CONDITION      BIT_1
+
+/*
+ * ISP target entries - Flags bit definitions.
+ */
+#define OF_RESET            BIT_5       /* Reset LIP flag */
+#define OF_DATA_IN          BIT_6       /* Data in to initiator */
+                                        /*  (data from target to initiator) */
+#define OF_DATA_OUT         BIT_7       /* Data out from initiator */
+                                        /*  (data from initiator to target) */
+#define OF_NO_DATA          (BIT_7 | BIT_6)
+#define OF_INC_RC           BIT_8       /* Increment command resource count */
+#define OF_FAST_POST        BIT_9       /* Enable mailbox fast posting. */
+#define OF_SSTS             BIT_15      /* Send SCSI status */
+
+/*
+ * Target Read/Write buffer structure.
+ */
+#define TARGET_DATA_OFFSET  4
+#define TARGET_DATA_SIZE    0x2000      /* 8K */
+#define TARGET_INQ_OFFSET   (TARGET_DATA_OFFSET + TARGET_DATA_SIZE)
+#define TARGET_SENSE_SIZE   18
+#define TARGET_BUF_SIZE     36
+
+#if  QL1280_TARGET_MODE_SUPPORT
+typedef struct
+{
+    uint8_t         hdr[4];
+    uint8_t         data[TARGET_DATA_SIZE];
+}tgt_buf_t;
+#endif  /* QL1280_TARGET_MODE_SUPPORT */
+typedef struct
+{
+    uint16_t  loop_id;
+#ifdef QL_MAPPED_TARGETS
+    uint16_t  lun_offset;
+#endif
+    uint32_t  down_timer;
+    scsi_lu_t *luns[MAX_LUNS];
+}tgt_t;
+
+/*
+ * 24 bit port ID type definition.
+ */
+typedef union {
+	struct {
+		uint8_t port_id[3];
+		uint8_t rsvd_1;
+	}r;
+#if defined(_BIT_FIELDS_LTOH)
+	uint32_t	b24  : 24,
+			rsvd : 8;
+	struct {
+		uint8_t al_pa;
+		uint8_t area;
+		uint8_t domain;
+		uint8_t rsvd_1;
+	}b;
+#else
+	uint32_t	rsvd : 8,
+			b24  : 24;
+	struct {
+		uint8_t domain;
+		uint8_t area;
+		uint8_t al_pa;
+		uint8_t rsvd_1;
+	}b;
+#endif
+} port_id_t;
+
+
+typedef struct
+{
+    uint8_t  name[8];         /* big endian node name */
+    uint8_t  wwn[8];          /* big endian port name */
+    uint16_t  loop_id;
+    uint8_t   port_id[3];            /* 24-bit port ID */
+    uint8_t   rsvd_1;
+	/*
+	 * This is used to retry login for devices specified for
+	 * persistent binding or lost devices.
+	 */
+	uint8_t   port_login_retry_count;
+    uint8_t  port_timer;
+    uint16_t   flag;
+    uint32_t  mask[8];         /* LUN Mask for this Device */
+  /* flags bits defined as follows */
+#define DEV_PUBLIC          BIT_0
+#define DEV_OFFLINE         BIT_1
+#define DEV_LUNMASK_SET     BIT_2  /* some LUNs masked for this device */
+#define DEV_MP_DISABLED     BIT_3  /* device disabled for qlmultipath  */
+#define	DEV_TAPE_DEVICE		BIT_4
+#define	DEV_CONFIGURED    	BIT_5
+#define	DEV_MISSING	        BIT_6
+#define	DEV_RETURN	        BIT_7
+#define	DEV_HOST	        BIT_8
+#define	DEV_RELOGIN	        BIT_9
+#define	DEV_PORT_DOWN	        BIT_10
+}fcdev_t;
+
+
+typedef struct
+{
+    uint8_t   in_use;
+}fabricid_t;
+
+/*
+ * Flash Database structures.
+ */
+#define FLASH_DATABASE_0        0x1c000
+#define FLASH_DATABASE_1        0x18000
+#define FLASH_DATABASE_VERSION  1
+
+typedef struct
+{
+    uint32_t seq;
+    uint8_t  version;
+    uint8_t  checksum;
+    uint16_t size;
+    uint8_t  spares[8];
+}flash_hdr_t;
+
+typedef struct
+{
+    uint32_t name[2];
+    uint8_t  spares[8];
+}flash_node_t;
+
+typedef struct
+{
+    flash_hdr_t  hdr;
+    flash_node_t node[MAX_FIBRE_DEVICES];
+}flash_database_t;
+
+/*
+ * SNS structures.
+ */
+#define SNS_DATA_SIZE       608
+
+typedef struct
+{
+    uint16_t buffer_length;
+    uint16_t reserved;
+    uint32_t buffer_address[2];
+    uint16_t subcommand_length;
+    uint16_t reserved_1;
+}sns_hdr_t;
+
+typedef struct
+{
+    union
+    {
+        struct
+        {
+            sns_hdr_t   hdr;
+            uint16_t    subcommand;
+            uint8_t     param[SNS_DATA_SIZE - sizeof(sns_hdr_t) - 2];
+        }req;
+
+        uint8_t rsp[SNS_DATA_SIZE];
+    }p;
+}sns_data_t;
+
+/*
+ * SNS request/response structures for GP_IDNN.
+ */
+typedef struct
+{
+    uint8_t    controlbyte;
+    uint8_t    port_id[3];
+    uint32_t   reserved;
+    uint8_t    nodename[8];
+}port_data_t;
+
+#ifdef ISP2200
+#define GP_IDNN_LENGTH  (256 * sizeof(port_data_t)) + 16
+#else
+#define GP_IDNN_LENGTH  (126 * sizeof(port_data_t)) + 16
+#endif
+
+typedef union
+{
+    struct
+    {
+        uint16_t buffer_length;
+        uint16_t reserved;
+        uint32_t buffer_address[2];
+        uint16_t subcommand_length;
+        uint16_t reserved_1;
+        uint16_t subcommand;
+        uint16_t length;
+        uint32_t reserved2;
+        uint32_t protocol;
+        uint8_t  param[GP_IDNN_LENGTH - 28];
+    }req;
+
+    struct
+    {
+        uint8_t revision;
+        uint8_t inid[3];
+        uint8_t fcstype;
+        uint8_t subtype;
+        uint8_t options;
+        uint8_t reserved;
+        uint16_t response;
+        uint16_t residual;
+        uint8_t reserved1;
+        uint8_t reason_code;
+        uint8_t explanation_code;
+        uint8_t vendor_unique;
+#ifdef ISP2200
+        port_data_t  port_data[256];
+#else
+        port_data_t  port_data[126];
+#endif
+    }rsp;
+
+}gp_idnn_t;
+
+#ifdef ISP2200
+#define GN_LIST_LENGTH  256 * sizeof(port_list_entry_t)
+#else
+#define GN_LIST_LENGTH  126 * sizeof(port_list_entry_t)
+#endif
+/*
+ * Structure used in Get Port List mailbox command (0x75).
+ */
+typedef struct
+{
+    uint8_t    name[8];
+    uint16_t   loop_id;
+}port_list_entry_t;
+
+/*
+ * Structure used for device info.
+ */
+typedef struct
+{
+    uint8_t	name[8]; /* big endian node name */
+    uint8_t	wwn[8];  /* big endian port name */
+    uint16_t	loop_id;
+    uint8_t	port_id[3];
+}device_data_t;
+
+/*
+ * Port Database structure definition
+ * Little endian except where noted.
+ */
+#define	PORT_DATABASE_SIZE	128	/* bytes */
+typedef struct {
+	uint8_t options;
+	uint8_t control;
+	uint8_t master_state;
+	uint8_t slave_state;
+#define	PD_STATE_DISCOVERY			0
+#define	PD_STATE_WAIT_DISCOVERY_ACK		1
+#define	PD_STATE_PORT_LOGIN			2
+#define	PD_STATE_WAIT_PORT_LOGIN_ACK		3
+#define	PD_STATE_PROCESS_LOGIN			4
+#define	PD_STATE_WAIT_PROCESS_LOGIN_ACK		5
+#define	PD_STATE_PORT_LOGGED_IN			6
+#define	PD_STATE_PORT_UNAVAILABLE		7
+#define	PD_STATE_PROCESS_LOGOUT			8
+#define	PD_STATE_WAIT_PROCESS_LOGOUT_ACK	9
+#define	PD_STATE_PORT_LOGOUT			10
+#define	PD_STATE_WAIT_PORT_LOGOUT_ACK		11
+	uint8_t reserved[2];
+	uint8_t hard_address;
+	uint8_t reserved_1;
+	uint8_t port_id[4];
+	uint8_t node_name[8];			/* Big endian. */
+	uint8_t port_name[8];			/* Big endian. */
+	uint16_t execution_throttle;
+	uint16_t execution_count;
+	uint8_t reset_count;
+	uint8_t reserved_2;
+	uint16_t resource_allocation;
+	uint16_t current_allocation;
+	uint16_t queue_head;
+	uint16_t queue_tail;
+	uint16_t transmit_execution_list_next;
+	uint16_t transmit_execution_list_previous;
+	uint16_t common_features;
+	uint16_t total_concurrent_sequences;
+	uint16_t RO_by_information_category;
+	uint8_t recipient;
+	uint8_t initiator;
+	uint16_t receive_data_size;
+	uint16_t concurrent_sequences;
+	uint16_t open_sequences_per_exchange;
+	uint16_t lun_abort_flags;
+	uint16_t lun_stop_flags;
+	uint16_t stop_queue_head;
+	uint16_t stop_queue_tail;
+	uint16_t port_retry_timer;
+	uint16_t next_sequence_id;
+	uint16_t frame_count;
+	uint16_t PRLI_payload_length;
+	uint8_t prli_svc_param_word_0[2];	/* Big endian */
+						/* Bits 15-0 of word 0 */
+	uint8_t prli_svc_param_word_3[2];	/* Big endian */
+						/* Bits 15-0 of word 3 */
+	uint16_t loop_id;
+	uint16_t extended_lun_info_list_pointer;
+	uint16_t extended_lun_stop_list_pointer;
+} port_database_t;
+
+
+
+/*
+ * Registered State Change Notification structures.
+ */
+typedef struct {
+	port_id_t d_id; 
+	uint8_t format;
+} rscn_t;
+
+
+
+#ifdef FC_IP_SUPPORT
+/*
+ * Definitions for IP support 
+ */
+#define LOOP_ID_MASK            0x00FF
+#define PLE_NOT_SCSI_DEVICE     0x8000  /* Upper bit of loop ID set if not SCSI */
+
+/* Firmware IP initialization control block definitions */
+typedef struct  _IPInitBlock
+{
+    uint8_t     cVersion;
+    uint8_t	    cReserved1;
+    uint16_t	wIpFirmwareOptions;
+    uint16_t	wIpHeaderSize;
+    uint16_t	wIpMTUSize;
+    uint16_t	wIpBufferSize;
+    uint16_t	wReserved2;
+    uint16_t	wReserved3;
+    uint16_t	wReserved4;
+    uint16_t	wReserved5;
+    uint16_t	wIpQueueSize;
+    uint16_t	wIpLowWaterMark;
+    uint16_t	wIpQueueAddr[4];
+    uint16_t	wIpQueueInPointer;
+    uint16_t	wIpFastPostCount;
+    uint16_t	wIpBufferContainerCount;
+    uint16_t	wIpIocbResourceAllocation;
+} IP_INIT_BLOCK, *PIP_INIT_BLOCK;
+
+#define IPIB_VERSION                    0x01
+#define IPIB_LOW_WATER_MARK             0
+#define IPIB_FAST_POST_COUNT            4
+#define IPIB_BUFFER_CONTAINER_COUNT     64
+#define IPIB_IOCB_RESERVE_COUNT         250
+
+/* IP firmware options */
+#define IPIB_OPTION_64BIT_ADDRESSING            0x0001
+#define IPIB_OPTION_NO_BROADCAST_FASTPOST       0x0002
+#define IPIB_OPTION_OUT_OF_BUFFERS_EVENT        0x0004
+
+/* IP device data structure */
+typedef struct _IpDeviceBlock
+{
+    uint32_t    lDeviceFlags;       
+    uint16_t    wLoopId;            
+    uint16_t    wUnused1;
+    uint8_t     acWorldWideName[8]; 
+    uint8_t     acPortId[3];        
+    uint8_t     cUnused2;
+    struct _IpDeviceBlock *pNextIpDevice;      
+    struct _IpDeviceBlock *pLastIpDevice;      
+    uint32_t    lUnused3;
+} IP_DEVICE_BLOCK, *PIP_DEVICE_BLOCK;
+
+#define IP_DEV_FLAG_PRESENT         0x00000001 
+#define IP_DEV_FLAG_PUBLIC_DEVICE   0x00000002
+
+#define PUBLIC_LOOP_DEVICE          ((uint16_t)-1)
+
+/* Maximum number of IP connections */
+#define QLLAN_MAX_IP_DEVICES        64
+
+/* IP IOCB types */
+#define ET_IP_COMMAND_32            0x13
+#define ET_IP_COMMAND_64            0x1B
+#define ET_IP_RECEIVE               0x23
+#define ET_IP_RECEIVE_CONTINUATION  0x2B
+#define ET_IP_FARP_REQUEST          0x30
+
+/* Data segment descriptor structures */
+typedef struct
+{
+    uint32_t    lBase;
+    uint32_t    lCount;
+} DATA_SEG;
+
+typedef struct
+{
+    uint32_t    lBase[2];
+    uint32_t    lCount;
+} DATA_SEG_A64;
+
+/* IP Command IOCB structure */
+typedef struct  _IpCommandEntry
+{
+    uint32_t    lHeader;
+    uint32_t    lHandle;
+    uint8_t     cReserved1;
+    uint8_t     cLoopId;
+    uint16_t    wCompletionStatus;
+    uint16_t    wControlFlags;
+    uint16_t    wReserved2;
+    uint16_t    wTimeout;
+    uint16_t    wSegmentCount;
+    uint16_t    wServiceClass;
+    uint16_t    wReserved3[7];
+    uint32_t    lTotalByteCount;
+    union
+    {
+        DATA_SEG        asDataSeg[3];
+        DATA_SEG_A64    asDataSeg64[2];
+    } ds;
+} IP_COMMAND_ENTRY, *PIP_COMMAND_ENTRY;
+
+/* IP Receive IOCB structure */
+#define IP_RECEIVE_ENTRY_MAX_HANDLES    24
+typedef struct  _IpReceiveEntry
+{
+    uint8_t     cEntryType;
+    uint8_t     cEntryCount;
+    uint8_t     cSegmentCount;
+    uint8_t     cEntryStatus;
+    uint16_t    wS_IDLow;
+    uint8_t     cS_IDHigh;
+    uint8_t     cReserved1;
+    uint8_t     cReserved2;
+    uint8_t     cLoopId;
+    uint16_t    wCompletionStatus;
+    uint16_t    wServiceClass;
+    uint16_t    wSequenseLength;
+    uint16_t    waBufferHandle[IP_RECEIVE_ENTRY_MAX_HANDLES];
+} IP_RECEIVE_ENTRY, *PIP_RECEIVE_ENTRY;
+
+/* IP Receive IOCB completion status bits */
+#define IP_REC_STATUS_SPLIT_BUFFER              0x0001
+
+/* IP FARP Request IOCB structure */
+typedef struct  _IpFarpRequestEntry
+{
+    uint8_t     cEntryType;
+    uint8_t     cEntryCount;
+    uint8_t     cReserved1;
+    uint8_t     cEntryStatus;
+    uint16_t    wRequesterPortIdLow;
+    uint8_t     cRequesterPortIdHigh;
+    uint8_t     cReserved2;
+    uint8_t     acRequesterPortName[8];
+} IP_FARP_REQUEST_ENTRY, *PIP_FARP_REQUEST_ENTRY;
+
+/* IP mailbox commands */
+#define MBC_INITIALIZE_IP               0x0077
+#define MBC_SEND_FARP_REQUEST           0x0078
+
+/* Fabric login mailbox command option bits */
+#define MBC_NO_PLOGI_IF_LOGGED_IN       0x01
+#define MBC_NO_PROCESS_LOGIN            0x02
+
+/* Mailbox command completion status */
+#define MBS_PORT_ID_IN_USE              0x4007
+#define MBS_LOOP_ID_IN_USE              0x4008
+#define MBS_ALL_LOOP_IDS_IN_USE         0x4009
+#define MBS_NAME_SERVER_NOT_LOGGED_IN   0x400A
+
+/* IP async events */
+#define MBA_IP_TRANSMIT_COMPLETE        0x8022
+#define MBA_IP_RECEIVE_COMPLETE         0x8023
+#define MBA_IP_BROADCAST_RECEIVED       0x8024
+#define MBA_IP_RECEIVE_BUFFERS_LOW      0x8025
+#define MBA_IP_OUT_OF_BUFFERS           0x8026
+#define MBA_IP_RECEIVE_COMPLETE_SPLIT   0x8027
+
+/* FARP request payload structure */
+typedef struct  _IpSendFarpPayload
+{
+    uint8_t     cMatchAddressCode;
+    uint8_t     acReserved1[3];
+    uint8_t     cResponderFlags;
+    uint8_t     acReserved2[3];
+    uint8_t     acRequesterPortName[8];
+    uint8_t     acRequesterNodeName[8];
+    uint8_t     acResponderPortName[8];
+    uint8_t     acResponderNodeName[8];
+} IP_SEND_FARP_PAYLOAD, *PIP_SEND_FARP_PAYLOAD;
+
+#define IP_FARP_MATCH_PORTNAME  0x01
+#define IP_FARP_REQUEST_LOGIN   0x01
+#else
+/* Fabric login mailbox command option bits */
+#define MBC_NO_PLOGI_IF_LOGGED_IN       0x01
+#define MBC_NO_PROCESS_LOGIN            0x02
+
+/* Mailbox command completion status */
+#define MBS_PORT_ID_IN_USE              0x4007
+#define MBS_LOOP_ID_IN_USE              0x4008
+#define MBS_ALL_LOOP_IDS_IN_USE         0x4009
+#define MBS_NAME_SERVER_NOT_LOGGED_IN   0x400A
+
+#endif /* FC_IP_SUPPORT */
+
+/*
+ * Linux Host Adapter structure
+ */
+typedef struct scsi_qla_host
+{
+	/* ISP ring lock, rings, and indexes */
+	request_t  req[REQUEST_ENTRY_CNT+1];
+	response_t res[RESPONSE_ENTRY_CNT+1];
+
+	/* Linux adapter configuration data */
+	struct Scsi_Host     *host;   /* pointer to host data */
+	struct scsi_qla_host *next;
+	device_reg_t         *iobase; /* Base Memory-mapped or I/O address */
+	device2300_reg_t     *iobase2300;/* Base Memory-mapped or I/O address */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,95)
+	struct   pci_dev  *pdev;
+#endif
+	uint8_t  pci_bus;
+	uint8_t  pci_device_fn;
+	uint8_t  devnum;
+	volatile unsigned char *mmpbase; /* memory mapped address */
+	u_long   host_no;
+	u_long   instance;
+	uint8_t  revision;
+	uint8_t  ports;
+	u_long   actthreads;
+	u_long   qthreads;
+	u_long   isr_count;          /* Interrupt count */
+	u_long   isp_aborts;
+	u_long   lip_count;
+	u_long   spurious_int;
+	uint32_t device_id;
+ 
+	/* ISP connection configuration data */
+	uint16_t max_public_loop_ids;
+	uint16_t min_external_loopid; /* First external loop Id */
+	uint8_t  current_topology;   /* Current ISP configuration */
+	uint8_t  prev_topology;      /* Previous ISP configuration */
+#define ISP_CFG_NL   1
+#define ISP_CFG_N    2
+#define ISP_CFG_FL   4
+#define ISP_CFG_F    8
+
+	uint8_t  id;                 /* Host adapter SCSI id */
+	uint16_t loop_id;            /* Host adapter loop id */
+	uint8_t  port_id[3];         /* Host adapter port id */
+	uint8_t  operating_mode;     /* current F/W operating connection mode */
+	                             /* 0 - LOOP, 1 - P2P, 2 - LOOP_P2P,
+	                              * 3 - P2P_LOOP
+	                              */
+
+	/* NVRAM configuration data */
+	uint16_t loop_reset_delay;   /* Loop reset delay. */
+	uint16_t hiwat;              /* High water mark per device. */
+	uint16_t execution_throttle; /* queue depth */ 
+	uint16_t minimum_timeout;    /* Minimum timeout. */
+	uint8_t  retry_count;
+	uint8_t  login_timeout;
+	uint8_t  port_down_retry_count;
+	uint8_t  loop_down_timeout;
+	uint16_t max_luns;
+	uint16_t max_targets;
+
+	/* Device TGT/LUN queues. */
+	tgt_t    *tgt[MAX_BUSES][MAX_FIBRE_DEVICES]; /* Logical unit queues */
+
+	/* Interrupt lock, and data */
+
+	/* Fibre Channel Device Database and LIP sequence. */
+	fcdev_t    fc_db[MAX_FIBRE_DEVICES]; /* Driver database. */
+	uint32_t   flash_db;         /* Flash database address in use. */
+	fabricid_t fabricid[MAX_FIBRE_DEVICES]; /* Fabric ids table . */
+	uint32_t   flash_seq;        /* Flash database seq # in use. */
+	volatile   uint16_t lip_seq;   /* LIP sequence number. */
+    
+	/* Linux bottom half run queue */
+	struct tq_struct run_qla_bh;
+
+	/* Linux kernel thread */
+	struct task_struct *dpc_handler; /* kernel thread */
+	struct semaphore   *dpc_wait;    /* DPC waits on this semaphore */
+	struct semaphore   *dpc_notify;  /* requester waits for DPC on this
+	                                   * semaphore
+	                                   */
+	uint8_t dpc_active;               /* DPC routine is active */
+
+	/* Received ISP mailbox data. */
+	volatile uint16_t mailbox_out[MAILBOX_REGISTER_COUNT];
+
+	/* Outstandings ISP commands. */
+	srb_t    *outstanding_cmds[MAX_OUTSTANDING_COMMANDS];
+
+#if BITS_PER_LONG > 32
+	uint64_t request_dma;        /* Physical address. */
+#else
+	uint32_t request_dma;        /* Physical address. */
+#endif
+	request_t *request_ring;     /* Base virtual address */
+	request_t *request_ring_ptr; /* Current address. */
+	uint16_t req_ring_index;     /* Current index. */
+	uint16_t req_q_cnt;          /* Number of available entries. */
+
+#if BITS_PER_LONG > 32
+	uint64_t response_dma;       /* Physical address. */
+#else
+	uint32_t response_dma;       /* Physical address. */
+#endif
+	response_t *response_ring;   /* Base virtual address */
+	response_t *response_ring_ptr; /* Current address. */
+	uint16_t rsp_ring_index;     /* Current index. */
+    
+#if QL2X00_TARGET_MODE_SUPPORT
+	/* Target buffer and sense data. */
+	u_long   tbuf_dma;           /* Physical address. */
+	tgt_buf_t *tbuf;
+	u_long   tsense_dma;         /* Physical address. */
+	uint8_t  *tsense;
+#endif
+
+#ifdef FC_IP_SUPPORT
+	/* Data for IP support */
+	uint8_t  acPortName[8];
+	IP_BUFFER_ENTRY asIpBuffers[IP_BUFFER_QUEUE_DEPTH];
+	uint32_t ppIpBufferQueueLow;
+	uint32_t ppIpBufferQueueHigh;
+	IP_BUFFER_ENTRY *pIpBufferQueue;  
+	uint16_t wIpBufferIn;
+	uint16_t wIpBufferOut;
+	uint32_t lMaximumTransferSize;
+	uint32_t lReceiveBufferSize;
+	uint16_t wReceiveBufferCount;
+	uint16_t wHeaderSize;
+	PSEND_COMPLETION_CALLBACK pSendCompletionRoutine;
+	PRECEIVE_PACKETS_CALLBACK pReturnReceivePacketsRoutine;
+	void     *pReturnReceivePacketsContext;
+	PNOTIFY_CALLBACK pNotifyRoutine;
+	void     *pNotifyContext;
+	BUFFER_CB *pReceiveBufferCBs;
+	IP_DEVICE_BLOCK asIpDeviceDatabase[QLLAN_MAX_IP_DEVICES];
+	IP_DEVICE_BLOCK *pIpDeviceFree;
+	IP_DEVICE_BLOCK *pIpDeviceTop;
+	IP_DEVICE_BLOCK *pIpDeviceBottom;
+	uint32_t lCurrentTagIndex;
+	void     *apActiveIpQueue[MAX_SEND_PACKETS];
+#endif
+
+	/* Firmware Initialization Control Block data */
+#if BITS_PER_LONG > 32
+	uint64_t init_cb_dma;        /* Physical address. */
+#else
+	uint32_t init_cb_dma;        /* Physical address. */
+#endif
+	init_cb_t *init_cb;
+  
+	/* Timeout timers. */
+	uint8_t  queue_restart_timer;   
+	uint8_t  loop_down_timer;    /* loop down timer */
+	uint8_t  loop_down_abort_time; /* port down timer */
+	uint32_t timer_active;
+	uint32_t forceLip;
+	struct   timer_list timer;
+
+	/* Watchdog queue, lock and total timer */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,1,0)
+	spinlock_t retry_lock;       /* Watchdog Queue Lock */
+#endif
+	srb_t    *retry_q_first;     /* First job on watchdog queue */
+	srb_t    *retry_q_last;      /* Last job on watchdog queue */
+
+	srb_t    *done_q_first;      /* First job on done queue */
+	srb_t    *done_q_last;       /* Last job on done queue */
+
+	/* RSCN queue. */
+	rscn_t   rscn_queue[MAX_RSCN_COUNT];
+	uint8_t  rscn_in_ptr;
+	uint8_t  rscn_out_ptr;
+
+	/* Host Adapter database */
+	fcdev_t  *phost_db;
+	uint8_t  host_db_ptr;
+
+	volatile struct
+	{
+	    uint32_t online                  :1;   /* 0 */
+	    uint32_t enable_64bit_addressing :1;   /* 1 */
+	    uint32_t mbox_int                :1;   /* 2 */
+	    uint32_t mbox_busy               :1;   /* 3 */
+	    uint32_t reset_marker            :1;   /* 4 */
+	    uint32_t loop_resync_needed      :1;   /* 5 */
+	    uint32_t watchdog_enabled        :1;   /* 6 */
+	    uint32_t isp_abort_needed        :1;   /* 7 */
+	    uint32_t disable_host_adapter    :1;   /* 8 */
+	    uint32_t loop_resync_active      :1;   /* 9 */
+	    uint32_t reset_active            :1;   /* 10 */
+	    uint32_t abort_isp_active        :1;   /* 11 */
+	    uint32_t disable_risc_code_load  :1;   /* 12 */
+	    uint32_t set_cache_line_size_1   :1;   /* 13 */
+	    uint32_t enable_target_mode      :1;   /* 14 */
+	    uint32_t disable_luns            :1;   /* 15 */
+	    uint32_t enable_lip_reset        :1;   /* 16 */
+	    uint32_t enable_lip_full_login   :1;   /* 17 */
+	    uint32_t enable_target_reset     :1;   /* 18 */
+	    uint32_t updated_fc_db           :1;   /* 19 */
+	    uint32_t enable_flash_db_update  :1;   /* 20 */
+	    uint32_t abort_queue_needed      :1;   /* 21 */
+
+#define QLA2100_IN_ISR_BIT      22
+	    uint32_t in_isr                  :1;   /* 22 */
+	    uint32_t dpc_sched               :1;   /* 23 */
+	    uint32_t start_timer             :1;   /* 24 */
+	    uint32_t nvram_config_done       :1;   /* 25 */
+	    uint32_t update_config_needed    :1;   /* 26 */
+	    uint32_t done_requests_needed    :1;   /* 27 */
+	    uint32_t restart_queues_needed   :1;   /* 28 */
+	    uint32_t port_restart_needed     :1;   /* 29 */
+#ifdef FC_IP_SUPPORT
+	    uint32_t enable_ip               :1;   /* 30 */
+#endif
+	  /* 4.11 */
+	    uint32_t managment_server_logged_in:1; /* 31 */
+	} flags;
+
+	    uint32_t device_flags;
+#define DFLG_LOCAL_DEVICES       BIT_0
+#define DFLG_RETRY_LOCAL_DEVICES BIT_1
+#define	RSCN_UPDATE              BIT_2
+#define	LOGIN_RETRY_NEEDED       BIT_3
+#define	RSCN_QUEUE_OVERFLOW      BIT_4
+#define DFLG_FABRIC_DEVICES      BIT_5
+#define	RELOGIN_NEEDED           BIT_6
+
+	uint8_t  marker_needed;
+	uint8_t  missing_targets;
+	uint8_t  sns_retry_cnt;
+	uint8_t  cmd_wait_cnt;
+	uint32_t dpc_flags;
+#define MAILBOX_RETRY            BIT_0
+#define COMMAND_WAIT_NEEDED      BIT_1
+#define COMMAND_WAIT_ACTIVE      BIT_2
+#define ISP_RESET_NEEDED         BIT_3
+#define LOGOUT_DONE              BIT_4
+#define ISP_RESET_ONCE           BIT_5
+
+	uint16_t interrupts_on;
+
+	volatile uint16_t loop_state;
+/* These values are NOT used as flags. */
+#define LOOP_TIMEOUT   0x1
+#define LOOP_DOWN      0x2
+#define LOOP_UP        0x4
+#define LOOP_UPDATE    0x8
+#define LOOP_READY     0x10
+
+	/* following are new and needed for IOCTL support */
+	uint8_t  node_name[8];
+	uint8_t  nvram_version; 
+	uint8_t  ioctl_timer;
+	uint8_t  IoctlPassThru_InProgress;
+	uint8_t  IoctlPassFCCT_InProgress;
+	void     *ioctl_mem;
+#if BITS_PER_LONG > 32
+	uint64_t ioctl_mem_phys;
+#else
+	uint32_t ioctl_mem_phys;
+#endif
+
+	/* HBA serial number */
+	uint8_t  serial0;
+	uint8_t  serial1;
+	uint8_t  serial2;
+
+	/* oem related items */
+	uint8_t  oem_id;
+	uint8_t  oem_spare0;
+	uint8_t  oem_part[6];
+	uint8_t  oem_fru[8];
+	uint8_t  oem_ec[8];
+	uint8_t  oem_string[8];
+
+	uint32_t dump_done;
+
+} scsi_qla_host_t;
+
+/*
+ * Macros to help code, maintain, etc.
+ */
+#define TGT_Q(ha, b, t)    (ha->tgt[b][t])
+#define GET_LU_Q(ha, b, t, l)  ( (TGT_Q(ha,b,t) != NULL)? TGT_Q(ha, b, t)->luns[l] : NULL)
+#define LU_Q(ha, b, t, l)  (TGT_Q(ha, b, t)->luns[l])
+#define PORT_DOWN(ha, t)    ((ha)->fc_db[(t)].port_timer)
+
+/*
+ * Locking Macro Definitions
+ *
+ * LOCK/UNLOCK definitions are lock/unlock primitives for multi-processor
+ * or spl/splx for uniprocessor.
+ */
+#define QLA2100_INTR_LOCK(ha)    
+#define QLA2100_INTR_UNLOCK(ha) 
+
+#define QLA2100_RING_LOCK(ha)  
+#define QLA2100_RING_UNLOCK(ha)
+
+#if defined(__cplusplus)
+}
+#endif
+#endif
+
+#if defined(__386__)
+#  define QLA2100_BIOSPARAM  qla2100_biosparam
+#else
+#  define QLA2100_BIOSPARAM  NULL
+#endif
+
+/*
+ *  Linux - SCSI Driver Interface Function Prototypes.
+ */
+int qla2100_ioctl(Scsi_Device *, int , void *);
+int qla2100_proc_info ( char *, char **, off_t, int, int, int);
+const char * qla2100_info(struct Scsi_Host *host);
+int qla2100_detect(Scsi_Host_Template *);
+int qla2100_release(struct Scsi_Host *);
+const char * qla2100_info(struct Scsi_Host *);
+int qla2100_queuecommand(Scsi_Cmnd *, void (* done)(Scsi_Cmnd *));
+int qla2100_abort(Scsi_Cmnd *);
+int qla2100_reset(Scsi_Cmnd *, unsigned int);
+int qla2100_biosparam(Disk *, kdev_t, int[]);
+void qla2100_intr_handler(int, void *, struct pt_regs *);
+//void qla2100_device_queue_depth(scsi_qla_host_t *, Scsi_Device *);
+void qla2100_setup(char *s, int *dummy);
+
+/* Number of segments 1 - 65535 */
+#define SG_SEGMENTS     32             /* Cmd entry + 6 continuations */
+
+/*
+ * Scsi_Host_template (see hosts.h) 
+ * Device driver Interfaces to mid-level SCSI driver.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,1,95)
+/* This interface is now obsolete !!! */ 
+#define QLA2100_LINUX_TEMPLATE {		                 \
+        next:           NULL,                                    \
+        usage_count:    NULL,                                    \
+	proc_dir:		NULL,          	                 \
+	proc_info:		qla2100_proc_info,	                         \
+	name:			"Qlogic Fibre Channel 2100",               \
+	detect:			qla2100_detect,	                 \
+	release:		qla2100_release,                 \
+	info:			qla2100_info,	                 \
+        command:        NULL,                                    \
+	queuecommand:	qla2100_queuecommand,	                 \
+	abort:			qla2100_abort,	                 \
+	reset:			qla2100_reset,	                 \
+        slave_attach:   NULL,                                    \
+	bios_param:		QLA2100_BIOSPARAM,               \
+	can_queue:		1, /* MAX_OUTSTANDING_COMMANDS */   \
+	this_id:		-1,  /* scsi id of host adapter */        \
+	sg_tablesize:	SG_ALL,   \
+	cmd_per_lun:	1,	  /* max commands per lun */	       \
+	present:	    0,    /* number of ISP present */	       \
+	unchecked_isa_dma: 0, /* no memeory DMA restrictions */    \
+	use_clustering:	ENABLE_CLUSTERING			               \
+}
+#else
+
+#define QLA2100_LINUX_TEMPLATE {		                 \
+	next: NULL,						\
+	module: NULL,						\
+	proc_dir: NULL,						\
+	proc_info: qla2100_proc_info,	                        \
+	name:			"Qlogic Fibre Channel 2100",    \
+	detect:			qla2100_detect,	                 \
+	release:		qla2100_release,                 \
+	info:			qla2100_info,	                 \
+	ioctl: qla2100_ioctl,                                    \
+	command: NULL,						\
+	queuecommand: qla2100_queuecommand,			\
+	eh_strategy_handler: NULL,				\
+	eh_abort_handler: NULL,					\
+	eh_device_reset_handler: NULL,				\
+	eh_bus_reset_handler: NULL,				\
+	eh_host_reset_handler: NULL,				\
+	abort: qla2100_abort,					\
+	reset: qla2100_reset,					\
+	slave_attach: NULL,					\
+	bios_param: QLA2100_BIOSPARAM,				\
+	can_queue: 255,		/* max simultaneous cmds      */\
+	this_id: -1,		/* scsi id of host adapter    */\
+	sg_tablesize: SG_SEGMENTS,	/* max scatter-gather cmds    */\
+	cmd_per_lun: 3,		/* cmds per lun (linked cmds) */\
+	present: 0,		/* number of 7xxx's present   */\
+	unchecked_isa_dma: 0,	/* no memory DMA restrictions */\
+	use_clustering: ENABLE_CLUSTERING,			\
+	use_new_eh_code: 0,					\
+	emulated: 0					        \
+}
+#endif
+#endif /* _IO_HBA_QLA2100_H */
diff -urN linux.orig/drivers/scsi/qla2x00exioct.h linux/drivers/scsi/qla2x00exioct.h
--- linux.orig/drivers/scsi/qla2x00exioct.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/qla2x00exioct.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,823 @@
+/*
+ * File Name: exioct.h
+ *
+ * San/Device Management Ioctl Header
+ * File is created to adhere to Solaris requirement using 8-space tabs.
+ *
+ * !!!!! PLEASE DO NOT REMOVE THE TABS !!!!!
+ * !!!!! PLEASE NO SINGLE LINE COMMENTS: // !!!!!
+ * !!!!! PLEASE NO MORE THAN 80 CHARS PER LINE !!!!!
+ *
+ * ***********************************************************************
+ * *                                                                    **
+ * *                            NOTICE                                  **
+ * *            COPYRIGHT (C) 2000 QLOGIC CORPORATION                   **
+ * *                    ALL RIGHTS RESERVED                             **
+ * *                                                                    **
+ * ***********************************************************************
+ *
+ * Revision History:
+ *
+ * Rev. 0	March 1, 2000
+ * YPL	- Created.
+ *
+ * Rev. 1	March 2, 2000
+ * RLU	- Updated with latest definitions.  Added more comments.
+ *
+ * Rev. 2	May 16, 2000		    
+ * SP	- Updated definitions and changed structures (March 27, 2000)
+ * SP   - Addded structures 
+ *
+ * Rev. 3	June 1, 2000		     
+ * THL	- Made major changes to include all changes talked in our meeting.
+ *
+ * Rev. 4	June 5, 2000
+ * RLU	- Added new definitions/structures for SDM_GET_AEN and SDM_REG_AEN 
+ *	  functions.
+ *	- Major definition/structure name changes as discussed in meetings.
+ *	- Deleted duplicated command code and structure definitions.
+ *
+ * Rev. 4.1	June 14, 2000
+ * WTR  - Moved Solaris specific defines to exioctso.h. This makes it
+ *	  possible for application developers to include only exioct.h
+ *	  in their Solaris application development.
+ *
+ * Rev. 4.2	June 15, 2000
+ * THL  - Changed UINT16 and UINT32 back to WORD and DWORD for NT; otherwise,
+ *	  NT will get a compilation error for redefining UINT16 and UINT32.
+ *	  Added RISC_CODE/FLASH_RAM macros.
+ *
+ * Rev. 4.3	June 22, 2000
+ * THL  - Changed SDM_FC_ADDR according to External Ioctls document.
+ *	  Added SDM_DEF_TYPE macros.
+ *
+ * Rev. 4.4	June 22, 2000
+ * THL  - Moved NT specific defines to exioctnt.h.
+ *
+ * Rev. 4.5     August 15, 2000
+ * SP   - Rolled back some changes made by Todd R.
+ *        Kept new status code SDM_STATUS_NO_MEMORY
+ *        Port types fabric and tape device 
+ *
+ * Rev. 4.7     Sep 6, 2000
+ * YPL  - Replace SDM_ with EXT_, _ISP with _CHIP.
+ *        Add vendor specific statuses, device update, config defines.
+ *
+ * Rev. 5.0     Sep 13, 2000
+ * YPL  - Update version to 5, remove max defines, make port type bit.
+ *        Change HBA_PORT_PROPERTY to have bus/target/lun defined as UINT16
+ *
+ * Rev. 5.1     Sep 22, 2000
+ * THL  - Add destination address for specify scsi address or FC address.
+ *        Remove "not support" comment and add more macros.
+ *
+ * Rev. 5.2     Sep 27, 2000
+ * THL  - Add new macros and structure for add and swap target device.
+ *        Create new data structure for get port database.
+ * TLE  - Merge changes needed for FailOver
+ *
+ * Rev. 5.3     Sep 29, 2000
+ * THL  - Add access mode for NVRAM.
+ * 
+ * Rev. 5.4     Oct 03, 2000
+ * THL  - Add EXT_SC_GET_FC_STATISTICS.
+ *
+ * Rev. 5.5	Oct 18, 2000
+ * THL  - Remove duplicated EXT_DEF_ADDR_MODE_32 and EXT_DEF_ADDR_MODE_16.
+ *        Reformat new data structures and defines.
+ *
+ * Rev. 5.6	Oct 19, 2000
+ * RLU	- Changed file name from ExIoct.h to exioct.h.
+ *	- Added definition of EXT_RNID_DATA for API implementation.
+ *	- Reformat some lines to conform to the format agreed
+ *	  upon in IOCTL meeting (and mentioned at beginning of
+ *	  this file).
+ *
+ * Rev. 5.7 Oct 25, 2000
+ * BN   - Added LUN bitmask structure and macros
+ *
+ * Rev. 5.8 Oct 25, 2000
+ * BN   - Added EXT_CC_DRIVER_PROP define
+ * 
+ * Rev. 5.9 Oct 26, 2000
+ * BN   - Sync with UnixApi project
+ * 
+ * Rev. 5.10 Oct 30, 2000
+ * BN   - Remove not needed #define for EXT_CC_DRIVER_PROP
+ *      - Add EXT_ to IS_LUN_BIT_SET, SET_LUN_BIT, CLR_LUN_BIT
+ * 
+ * Rev. 5.11 Nov 1, 2000
+ * BN   - Increased [1] of EXT_DEVICEDATA to [EXT_MAX_TARGET]
+ * TLE  - Decreased [EXT_MAX_TARGET] of EXT_DEVICEDATA to [1]
+ * 
+ * Rev. 5.12	Nov 7, 2000
+ * RLU	- Deleted EXT_DEF_MAX_LUNS define and changed all references
+ *	  to it to use EXT_MAX_LUN.
+ *	- Changed the revision numbers for the last 2 revisions down
+ *	  to use 5.x.
+ * 
+ * Rev. 5.13	Nov 28, 2000
+ * RLU	- Change value defines from EXT_... to EXT_DEF_...
+ * 
+ * Rev. 5.14    Jan 08, 2001
+ * BN   - Added    #define SDM_CC_LOOPBACK   SDM_CC_LOOPBACK_OS
+ * 
+ */
+
+#ifndef	_EXIOCT_H
+#define	_EXIOCT_H
+
+/*
+ * NOTE: the following version defines must be updated each time the
+ *	 changes made may affect the backward compatibility of the
+ *	 input/output relations of the SDM IOCTL functions.
+ */
+#define	EXT_VERSION					5
+
+
+/*
+ * OS independent General definitions
+ */
+#define	EXT_DEF_SIGNATURE_SIZE				8
+#define	EXT_DEF_WWN_NAME_SIZE				8
+#define	EXT_DEF_WWP_NAME_SIZE				8
+#define	EXT_DEF_SERIAL_NUM_SIZE				4
+#define	EXT_DEF_PORTID_SIZE				4
+#define	EXT_DEF_PORTID_SIZE_ACTUAL			3
+#define	EXT_DEF_MAX_STR_SIZE				128
+#define	EXT_DEF_SCSI_PASSTHRU_CDB_LENGTH		12
+
+#define	EXT_DEF_ADDR_MODE_32				1
+#define	EXT_DEF_ADDR_MODE_64				2
+
+/*
+ * ***********************************************************************
+ * X OS type definitions
+ * ***********************************************************************
+ */
+#ifdef _MSC_VER						/* NT */
+
+#pragma pack(1)
+#include "ExIoctNT.h"
+
+#elif defined(linux)					/* Linux */
+
+#include "qla2x00exioctln.h"
+
+#elif defined(sun) || defined(__sun)			/* Solaris */
+
+#include "exioctso.h"
+
+#endif
+
+/*
+ * ***********************************************************************
+ * OS dependent General configuration defines
+ * ***********************************************************************
+ */
+#define	EXT_DEF_MAX_HBA                 EXT_DEF_MAX_HBA_OS
+#define	EXT_DEF_MAX_BUS                 EXT_DEF_MAX_BUS_OS
+#define	EXT_DEF_MAX_TARGET              EXT_DEF_MAX_TARGET_OS
+#define	EXT_DEF_MAX_LUN                 EXT_DEF_MAX_LUN_OS
+
+/*
+ * ***********************************************************************
+ * Common header struct definitions for San/Device Mgmt
+ * ***********************************************************************
+ */
+typedef struct {
+	UINT64    Signature;			/* 8 chars string */
+	UINT16    AddrMode;			/* 2 */
+	UINT16    Version;			/* 2 */
+	UINT16    SubCode;			/* 2 */
+	UINT16    Instance;			/* 2 */
+	UINT32    Status;			/* 4 */
+	UINT32    DetailStatus;			/* 4 */
+	UINT32    Reserved1;			/* 4 */
+	UINT32    RequestLen;			/* 4 */
+	UINT32    ResponseLen;			/* 4 */
+	UINT64    RequestAdr;			/* 8 */
+	UINT64    ResponseAdr;			/* 8 */
+	UINT16    HbaSelect;			/* 2 */
+	UINT16    VendorSpecificStatus[11];	/* 22 */
+	UINT64    VendorSpecificData;		/* 8 chars string */
+} EXT_IOCTL, *PEXT_IOCTL;			/* 84 / 0x54 */
+
+/*
+ * Addressing mode used by the user application
+ */
+#define	EXT_ADDR_MODE			EXT_ADDR_MODE_OS
+
+/*
+ * Status.  These macros are being used for setting Status field in
+ * EXT_IOCTL structure.
+ */
+#define	EXT_STATUS_OK				0
+#define	EXT_STATUS_ERR				1
+#define	EXT_STATUS_BUSY				2
+#define	EXT_STATUS_PENDING			3
+#define	EXT_STATUS_SUSPENDED			4
+#define	EXT_STATUS_RETRY_PENDING		5
+#define	EXT_STATUS_INVALID_PARAM		6
+#define	EXT_STATUS_DATA_OVERRUN			7
+#define	EXT_STATUS_DATA_UNDERRUN		8
+#define	EXT_STATUS_DEV_NOT_FOUND		9
+#define	EXT_STATUS_COPY_ERR			10
+#define	EXT_STATUS_MAILBOX			11
+#define	EXT_STATUS_UNSUPPORTED_SUBCODE		12
+#define	EXT_STATUS_UNSUPPORTED_VERSION		13
+#define	EXT_STATUS_MS_NO_RESPONSE		14
+#define	EXT_STATUS_SCSI_STATUS			15
+#define	EXT_STATUS_BUFFER_TOO_SMALL		16
+#define	EXT_STATUS_NO_MEMORY			17
+#define	EXT_STATUS_UNKNOWN			18
+#define	EXT_STATUS_UNKNOWN_DSTATUS		19
+#define	EXT_STATUS_INVALID_REQUEST		20
+
+/*
+ * Detail Status contains the SCSI bus status codes.
+ */
+
+#define	EXT_DSTATUS_GOOD			0x00
+#define	EXT_DSTATUS_CHECK_CONDITION		0x02
+#define	EXT_DSTATUS_CONDITION_MET		0x04
+#define	EXT_DSTATUS_BUSY			0x08
+#define	EXT_DSTATUS_INTERMEDIATE		0x10
+#define	EXT_DSTATUS_INTERMEDIATE_COND_MET	0x14
+#define	EXT_DSTATUS_RESERVATION_CONFLICT	0x18
+#define	EXT_DSTATUS_COMMAND_TERMINATED		0x22
+#define	EXT_DSTATUS_QUEUE_FULL			0x28
+
+/*
+ * Detail Status contains the needed Response buffer space(bytes)
+ * when Status = EXT_STATUS_BUFFER_TOO_SMALL
+ */
+
+
+/*
+ * Detail Status contains one of the following codes
+ * when Status = EXT_STATUS_INVALID_PARAM or
+ *             = EXT_STATUS_DEV_NOT_FOUND
+ */
+#define EXT_DSTATUS_NOADNL_INFO			0x00
+#define EXT_DSTATUS_HBA_INST			0x01
+#define EXT_DSTATUS_TARGET			0x02
+#define EXT_DSTATUS_LUN				0x03
+#define EXT_DSTATUS_REQUEST_LEN			0x04
+#define EXT_DSTATUS_PATH_INDEX			0x05
+
+/*
+ * Currently supported DeviceControl / ioctl command codes
+ */
+#define	EXT_CC_QUERY			EXT_CC_QUERY_OS
+#define	EXT_CC_SEND_FCCT_PASSTHRU	EXT_CC_SEND_FCCT_PASSTHRU_OS
+#define	EXT_CC_REG_AEN			EXT_CC_REG_AEN_OS
+#define	EXT_CC_GET_AEN			EXT_CC_GET_AEN_OS
+#define	EXT_CC_SEND_ELS_RNID		EXT_CC_SEND_ELS_RNID_OS
+#define	EXT_CC_SEND_SCSI_PASSTHRU	EXT_CC_SCSI_PASSTHRU_OS
+#define	EXT_CC_READ_HOST_PARAMS		EXT_CC_READ_HOST_PARAMS_OS    
+#define	EXT_CC_READ_RISC_PARAMS		EXT_CC_READ_RISC_PARAMS_OS    
+#define	EXT_CC_UPDATE_HOST_PARAMS	EXT_CC_UPDATE_HOST_PARAMS_OS
+#define	EXT_CC_UPDATE_RISC_PARAMS	EXT_CC_UPDATE_RISC_PARAMS_OS
+#define	EXT_CC_READ_NVRAM		EXT_CC_READ_NVRAM_OS
+#define	EXT_CC_UPDATE_NVRAM		EXT_CC_UPDATE_NVRAM_OS
+
+#define EXT_CC_LOOPBACK                 EXT_CC_LOOPBACK_OS
+/*
+ * HBA port operations
+ */
+#define	EXT_CC_GET_DATA			EXT_CC_GET_DATA_OS
+#define	EXT_CC_SET_DATA			EXT_CC_SET_DATA_OS
+
+/*
+ * The following DeviceControl / ioctl command codes currently are not
+ * supported.
+ */
+#define	EXT_CC_SEND_ELS_RTIN		EXT_CC_SEND_ELS_RTIN_OS
+
+
+/*
+ * ***********************************************************************
+ * EXT_IOCTL SubCode definition.
+ * These macros are being used for setting SubCode field in EXT_IOCTL
+ * structure.
+ * ***********************************************************************
+ */
+
+/*
+ * Query.
+ * Uses with EXT_QUERY as the ioctl code.
+ */
+#define	EXT_SC_QUERY_HBA_NODE		1
+#define	EXT_SC_QUERY_HBA_PORT		2
+#define	EXT_SC_QUERY_DISC_PORT		3
+#define	EXT_SC_QUERY_DISC_TGT		4
+#define	EXT_SC_QUERY_DISC_LUN		5	/* Currently Not Supported */
+#define	EXT_SC_QUERY_DRIVER		6
+#define	EXT_SC_QUERY_FW			7
+#define	EXT_SC_QUERY_CHIP		8
+
+/*
+ * Get.
+ * Uses with EXT_GET_DATA as the ioctl code
+ */
+/* 1 - 99 Common */
+#define	EXT_SC_GET_SCSI_ADDR		1	/* Currently Not Supported */
+#define	EXT_SC_GET_ERR_DETECTIONS	2	/* Currently Not Supported */
+#define	EXT_SC_GET_STATISTICS		3
+#define	EXT_SC_GET_BUS_MODE		4	/* Currently Not Supported */
+#define	EXT_SC_GET_DR_DUMP_BUF		5	/* Currently Not Supported */
+#define	EXT_SC_GET_RISC_CODE		6
+#define	EXT_SC_GET_FLASH_RAM		7
+
+/* 100 - 199 FC_INTF_TYPE */
+#define	EXT_SC_GET_LINK_STATUS		101	/* Currently Not Supported */
+#define	EXT_SC_GET_LOOP_ID		102	/* Currently Not Supported */
+#define	EXT_SC_GET_LUN_BITMASK		103
+#define	EXT_SC_GET_PORT_DATABASE	104	/* Currently Not Supported */
+#define	EXT_SC_GET_PORT_DATABASE_MEM	105	/* Currently Not Supported */
+#define	EXT_SC_GET_PORT_SUMMARY		106
+#define	EXT_SC_GET_POSITION_MAP		107
+#define	EXT_SC_GET_RETRY_CNT		108	/* Currently Not Supported */
+#define	EXT_SC_GET_RNID			109	
+#define	EXT_SC_GET_RTIN			110	/* Currently Not Supported */
+#define	EXT_SC_GET_FC_LUN_BITMASK	111
+#define	EXT_SC_GET_FC_STATISTICS	112
+
+/* 200 - 299 SCSI_INTF_TYPE */
+#define	EXT_SC_GET_SEL_TIMEOUT		201	/* Currently Not Supported */
+
+
+/* 
+ * Set.
+ * Uses with EXT_SET_DATA as the ioctl code
+ */
+/* 1 - 99 Common */
+#define	EXT_SC_RST_STATISTICS		3	/* Currently Not Supported */
+#define	EXT_SC_SET_BUS_MODE		4	/* Currently Not Supported */
+#define	EXT_SC_SET_DR_DUMP_BUF		5	/* Currently Not Supported */
+#define	EXT_SC_SET_RISC_CODE		6
+#define	EXT_SC_SET_FLASH_RAM		7
+
+/* 100 - 199 FC_INTF_TYPE */
+#define	EXT_SC_SET_LUN_BITMASK		103
+#define	EXT_SC_SET_RETRY_CNT		108	/* Currently Not Supported */
+#define	EXT_SC_SET_RNID			109	
+#define	EXT_SC_SET_RTIN			110	/* Currently Not Supported */
+#define	EXT_SC_SET_FC_LUN_BITMASK	111
+#define	EXT_SC_ADD_TARGET_DEVICE	112
+#define	EXT_SC_SWAP_TARGET_DEVICE	113
+
+/* 200 - 299 SCSI_INTF_TYPE */
+#define	EXT_SC_SET_SEL_TIMEOUT		201	/* Currently Not Supported */
+
+/* SCSI passthrough */
+#define	EXT_SC_SEND_SCSI_PASSTHRU	0
+#define	EXT_SC_SEND_FC_SCSI_PASSTHRU	1
+
+/* NVRAM */
+#define	EXT_SC_NVRAM_HARDWARE		0	/* Save */
+#define	EXT_SC_NVRAM_DRIVER		1	/* Driver (Apply) */
+#define	EXT_SC_NVRAM_ALL		2	/* NVRAM/Driver (Save+Apply) */
+
+/* Read */
+
+/* Write */
+
+/* Reset */
+
+/* Request struct */
+
+
+/*
+ * Response struct
+ */
+typedef struct _EXT_HBA_NODE {
+	UINT8     WWNN         [EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+	UINT8     Manufacturer [EXT_DEF_MAX_STR_SIZE];	/* 128; "QLOGIC" */
+	UINT8     Model        [EXT_DEF_MAX_STR_SIZE];	/* 128; "QLA2200" */
+	UINT8     SerialNum    [EXT_DEF_SERIAL_NUM_SIZE];/* 4;  123  */
+	UINT8     DriverVersion[EXT_DEF_MAX_STR_SIZE];	/* 128; "7.4.3" */
+	UINT8     FWVersion    [EXT_DEF_MAX_STR_SIZE];	/* 128; "2.1.6" */
+
+	/* The following field is currently not supported */
+	UINT8     OptRomVersion[EXT_DEF_MAX_STR_SIZE];	/* 128; "1.44" */
+
+	UINT16    PortCount;				/* 2; 1 */
+	UINT16    InterfaceType;			/* 2; FC/SCSI */
+
+	/* The following two fields are not yet supported */
+	UINT32    DriverAttr;				/* 4 */
+	UINT32    FWAttr;				/* 4 */
+
+	UINT32    Reserved[8];				/* 32 */
+} EXT_HBA_NODE, *PEXT_HBA_NODE;				/* 696 */
+
+/* HBA node query interface type */
+#define	EXT_DEF_FC_INTF_TYPE			1
+#define	EXT_DEF_SCSI_INTF_TYPE			2
+
+typedef struct _EXT_HBA_PORT {
+	UINT8     WWPN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+	UINT8     Id  [EXT_DEF_PORTID_SIZE];	/* 4; 3 bytes valid Port Id. */
+	UINT16    Type;				/* 2; Port Type */
+	UINT16    State;			/* 2; Port State */
+	UINT16    Mode;				/* 2 */
+	UINT16    DiscPortCount;		/* 2 */
+	UINT16    DiscPortNameType;		/* 2; USE_NODE_NAME or */
+						/* USE_PORT_NAME */
+	UINT16    DiscTargetCount;		/* 2 */
+	UINT16    Bus;				/* 1 */
+	UINT16    Target;			/* 1 */
+	UINT16    Lun;				/* 1 */
+	UINT16    Unused;			/* 1 */
+	UINT32    Reserved[6];			/* 28 */
+} EXT_HBA_PORT, *PEXT_HBA_PORT;			/* 56 */
+
+/* port type bit definitions */
+#define	EXT_DEF_INITIATOR_DEV		0x1
+#define	EXT_DEF_TARGET_DEV		0x2
+#define	EXT_DEF_TAPE_DEV		0x4
+#define	EXT_DEF_FABRIC_DEV		0x8
+
+
+/* HBA port state */
+#define	EXT_DEF_HBA_OK			0
+#define	EXT_DEF_HBA_SUSPENDED		1
+#define	EXT_DEF_HBA_LOOP_DOWN		2
+
+/* Connection mode */
+#define	EXT_DEF_P2P_MODE		1
+#define	EXT_DEF_LOOP_MODE		2
+
+/* Valid name type for Disc. port/target */
+#define	EXT_DEF_USE_NODE_NAME		1
+#define	EXT_DEF_USE_PORT_NAME		2
+
+typedef struct _EXT_DISC_PORT {
+	UINT8     WWNN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+	UINT8     WWPN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+	UINT8     Id  [EXT_DEF_PORTID_SIZE];	/* 4; 3 bytes used. big endian*/
+
+	/* The following fields currently are not supported */
+	UINT16    Type;				/* 2; Port Type */
+	UINT16    Status;			/* 2; Port Status */
+	UINT16    Bus;				/* 2; n/a for Solaris */
+
+	UINT16    TargetId;			/* 2 */
+	UINT32    Reserved[8];			/* 32 */
+} EXT_DISC_PORT, *PEXT_DISC_PORT;		/* 60 */
+
+typedef struct _EXT_DISC_TARGET {
+	UINT8     WWNN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+	UINT8     WWPN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+	UINT8     Id  [EXT_DEF_PORTID_SIZE];	/* 4; 3 bytes used. big endian*/
+
+	/* The following fields currently are not supported */
+	UINT16    Type;				/* 2; Target Type */
+	UINT16    Status;			/* 2; Target Status*/
+	UINT16    Bus;				/* 2; n/a for Solaris */
+
+	UINT16    TargetId;			/* 2 */
+
+	/* The following field is currently not supported */
+	UINT16    LunCount;			/* 2; n/a for nt */
+
+	UINT16    Reserved[15];			/* 30 */
+} EXT_DISC_TARGET, *PEXT_DISC_TARGET;		/* 60 */
+
+/* The following command is not supported */
+typedef struct _EXT_DISC_LUN {			/* n/a for nt */
+	UINT16    Id;				/* 2 */
+	UINT16    State;			/* 2 */
+	UINT16    IoCount;			/* 2 */
+	UINT16    Reserved[15];			/* 30 */
+} EXT_DISC_LUN, *PEXT_DISC_LUN;			/* 36 */
+
+
+/* SCSI address */
+typedef struct _EXT_SCSI_ADDR {
+	UINT16    Bus;				/* 2 */
+	UINT16    Target;			/* 2 */
+	UINT16    Lun;				/* 2 */
+	UINT16    Padding[5];			/* 10 */
+} EXT_SCSI_ADDR, *PEXT_SCSI_ADDR;		/* 16 */
+
+
+/* Fibre Channel address */
+typedef struct _EXT_FC_ADDR {
+	union {
+		UINT8    WWNN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+		UINT8    WWPN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+		UINT8    Id[EXT_DEF_PORTID_SIZE];	/* 4 */
+	} FcAddr;
+	UINT16    Type;					/* 2 */
+	UINT16    Padding[2];				/* 2 */
+} EXT_FC_ADDR, *PEXT_FC_ADDR;				/* 24 */
+
+#define	EXT_DEF_TYPE_WWNN                   1
+#define	EXT_DEF_TYPE_WWPN                   2
+#define	EXT_DEF_TYPE_PORTID                 3
+#define	EXT_DEF_TYPE_FABRIC                 4
+
+
+/* Destination address */
+typedef struct _EXT_DEST_ADDR {
+	union {
+		UINT8    WWNN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+		UINT8    WWPN[EXT_DEF_WWN_NAME_SIZE];	/* 8 */
+		UINT8    Id[EXT_DEF_PORTID_SIZE];	/* 4 */
+		struct {
+			UINT16    Bus;			/* 2 */
+			UINT16    Target;		/* 2 */
+		} ScsiAddr;
+	} DestAddr;
+	UINT16    DestType;				/* 2 */
+	UINT16    Lun;					/* 2 */
+	UINT16    Padding[2];				/* 4 */
+} EXT_DEST_ADDR, *PEXT_DEST_ADDR;			/* 20 */
+
+
+#define	EXT_DEF_DESTTYPE_WWNN			1
+#define	EXT_DEF_DESTTYPE_WWPN			2
+#define	EXT_DEF_DESTTYPE_PORTID			3
+#define	EXT_DEF_DESTTYPE_FABRIC			4
+#define	EXT_DEF_DESTTYPE_SCSI			5
+
+/* Statistic */
+typedef struct _EXT_HBA_PORT_STAT {
+	UINT32    ControllerErrorCount;		/* 4 */
+	UINT32    DeviceErrorCount;		/* 4 */
+	UINT32    TotalIoCount;			/* 4 */
+	UINT32    TotalMBytes;			/* 4; MB of data processed */
+	UINT32    TotalLipResets;		/* 4; Total no. of LIP Reset */
+	UINT32    TotalInterrupts;		/* 4; Total no. of Interrupts */
+	UINT32    TotalLinkFailures;		/* 4 */
+	UINT32    TotalLossOfSync;		/* 4 */
+	UINT32    TotalLossOfSignals;		/* 4 */
+	UINT32    PrimitiveSeqProtocolErrorCount;/* 4 */
+	UINT32    InvalidTransmissionWordCount;	/* 4 */
+	UINT32    InvalidCRCCount;		/* 4 */
+	UINT32    Reserved[16];			/* 64 */
+} EXT_HBA_PORT_STAT, *PEXT_HBA_PORT_STAT;	/* 112 */
+
+
+/* Driver property */
+typedef struct _EXT_DRIVER {
+	UINT8     Version[EXT_DEF_MAX_STR_SIZE];/* 128 */
+	UINT16    NumOfBus;			/* 2; Port Type */
+	UINT16    TargetsPerBus;		/* 2; Port Status */
+	UINT16    LunsPerTarget;		/* 2 */
+	UINT32    MaxTransferLen;		/* 4 */
+	UINT32    MaxDataSegments;		/* 4 */
+	UINT16    DmaBitAddresses;		/* 2 */
+	UINT16    IoMapType;			/* 2 */
+	UINT32    Attrib;			/* 4 */
+	UINT32    InternalFlags[4];		/* 16 */
+	UINT32    Reserved[8];			/* 32 */
+} EXT_DRIVER, *PEXT_DRIVER;			/* 198 */
+
+
+/* Firmware property */
+typedef struct _EXT_FW {
+	UINT8     Version[EXT_DEF_MAX_STR_SIZE];/* 128 */
+	UINT32    Attrib;			/* 4 */
+	UINT16    Reserved[33];			/* 66 */
+} EXT_FW, *PEXT_FW;				/* 198 */
+
+
+/* ISP/Chip property */
+typedef struct _EXT_CHIP {
+	UINT16    VendorId;			/* 2 */
+	UINT16    DeviceId;			/* 2 */
+	UINT16    SubVendorId;			/* 2 */
+	UINT16    SubSystemId;			/* 2 */
+	UINT16    PciBusNumber;			/* 2 */
+	UINT16    PciSlotNumber;		/* 2 */
+	UINT32    IoAddr;			/* 4 */
+	UINT32    IoAddrLen;			/* 4 */
+	UINT32    MemAddr;			/* 4 */
+	UINT32    MemAddrLen;			/* 4 */
+	UINT16    ChipType;			/* 2 */
+	UINT16    InterruptLevel;		/* 2 */
+	UINT16    OutMbx[8];			/* 16 */
+	UINT32    Reserved[8];			/* 32 */
+} EXT_CHIP, *PEXT_CHIP;				/* 80 */
+
+
+/* Request Buffer for RNID */
+typedef struct _EXT_RNID_REQ {
+	EXT_FC_ADDR Addr;
+	UINT8       DataFormat;
+	UINT32      Reserved[16];	
+} EXT_RNID_REQ, *PEXT_RNID_REQ;	
+
+/* Request Buffer for Set RNID */
+typedef struct _EXT_SET_RNID_REQ {
+	UINT8     IPVersion[2];
+	UINT8     UDPPortNumber[2];
+	UINT8     IPAddress[16];
+	UINT32    Reserved[16];
+} EXT_SET_RNID_REQ, *PEXT_SET_RNID_REQ;
+
+/* RNID definition and data struct */
+#define	SEND_RNID_RSP_SIZE  72
+
+typedef struct _RNID_DATA
+{
+	UINT8     WWN[16];			/* 16 */
+	UINT32    UnitType;			/* 4 */
+	UINT8     PortId[4];			/* 4 */
+	UINT32    NumOfAttachedNodes;		/* 4 */
+	UINT8     IPVersion[2];			/* 2 */
+	UINT8     UDPPortNumber[2];		/* 2 */
+	UINT8     IPAddress[16];		/* 16 */
+	UINT16    Reserved;			/* 2 */
+	UINT16    TopoDiscFlags;		/* 2 */
+} EXT_RNID_DATA, *PEXT_RNID_DATA;		/* 52 */
+
+
+/* SCSI pass-through */
+typedef struct _EXT_SCSI_PASSTHRU {
+	EXT_SCSI_ADDR   TargetAddr;
+	UINT8           Direction;
+	UINT8           CdbLength;
+	UINT8           Cdb[EXT_DEF_SCSI_PASSTHRU_CDB_LENGTH];
+	UINT32          Reserved[16];
+	UINT8           SenseData[256];
+} EXT_SCSI_PASSTHRU, *PEXT_SCSI_PASSTHRU;
+
+/* FC SCSI pass-through */
+typedef struct _EXT_FC_SCSI_PASSTHRU {
+	EXT_DEST_ADDR   FCScsiAddr;
+	UINT8           Direction;
+	UINT8           CdbLength;
+	UINT8           Cdb[EXT_DEF_SCSI_PASSTHRU_CDB_LENGTH];
+	UINT32          Reserved[16];
+	UINT8           SenseData[256];
+} EXT_FC_SCSI_PASSTHRU, *PEXT_FC_SCSI_PASSTHRU;
+
+/* SCSI pass-through direction */
+#define	EXT_DEF_SCSI_PASSTHRU_DATA_IN		1
+#define	EXT_DEF_SCSI_PASSTHRU_DATA_OUT		2
+
+
+/* EXT_REG_AEN Request struct */
+typedef struct _EXT_REG_AEN {
+	UINT32    Enable;	/* 4; non-0 to enable, 0 to disable. */
+	UINT32    Reserved;	/* 4 */
+} EXT_REG_AEN, *PEXT_REG_AEN;	/* 8 */
+
+/* EXT_GET_AEN Response struct */
+typedef struct _EXT_ASYNC_EVENT {
+	UINT32	AsyncEventCode;		/* 4 */
+	union {
+		struct {
+			UINT8   RSCNInfo[EXT_DEF_PORTID_SIZE_ACTUAL];/* 3, BE */
+			UINT8   AddrFormat;			/* 1 */
+			UINT32  Rsvd_1[2];			/* 8 */
+		} RSCN;
+
+		UINT32  Reserved[3];	/* 12 */
+	} Payload;
+} EXT_ASYNC_EVENT, *PEXT_ASYNC_EVENT;	/* 16 */
+
+/* Asynchronous Event Codes */
+#define	EXT_DEF_LIP_OCCURRED		0x8010
+#define	EXT_DEF_LINK_UP			0x8011
+#define	EXT_DEF_LINK_DOWN		0x8012
+#define	EXT_DEF_LIP_RESET		0x8013
+#define	EXT_DEF_RSCN			0x8015
+#define	EXT_DEF_DEVICE_UPDATE		0x8014
+
+/* Required # of entries in the queue buffer allocated. */
+#define	EXT_DEF_MAX_AEN_QUEUE		EXT_DEF_MAX_AEN_QUEUE_OS
+
+/* LUN BitMask structure definition, array of 32bit words,
+ * 1 bit per lun.  When bit == 1, the lun is masked.
+ * Most significant bit of mask[0] is lun 0, bit 24 is lun 7.
+ */
+typedef struct _EXT_LUN_BIT_MASK {
+#if ((EXT_MAX_LUN & 0x7) == 0)
+	UINT8	mask[EXT_DEF_MAX_LUN >> 3];
+#else
+	UINT8	mask[(EXT_DEF_MAX_LUN + 8) >> 3 ];
+#endif
+} EXT_LUN_BIT_MASK, *PEXT_LUN_BIT_MASK;
+
+/* Device type to get for EXT_SC_GET_PORT_SUMMARY */
+#define	EXT_DEF_GET_KNOWN_DEVICE	0x1
+#define	EXT_DEF_GET_VISIBLE_DEVICE	0x2
+#define	EXT_DEF_GET_HIDDEN_DEVICE	0x4
+#define	EXT_DEF_GET_FABRIC_DEVICE	0x8
+#define	EXT_DEF_GET_LOOP_DEVICE		0x10
+
+/* Each entry in device database */
+typedef struct _EXT_DEVICEDATAENTRY
+{
+	UINT8		NodeWWN[8];	/* Node World Wide Name for device */
+	UINT8		PortWWN[8];	/* Port World Wide Name for device */
+	UINT8		PortID[3];	/* Current PortId for device */
+	UINT8		ControlFlags;	/* Control flag */
+	EXT_SCSI_ADDR	TargetAddress;	/* scsi address */
+	UINT32		DeviceFlags;	/* Flags for device */
+	UINT16		LoopID;		/* Loop ID */
+	UINT16		BaseLunNumber;  
+	UINT32		Reserved[32];
+} EXT_DEVICEDATAENTRY, *PEXT_DEVICEDATAENTRY;
+
+#define	EXT_DEF_EXTERNAL_LUN_COUNT          2048
+#define	EXT_DEF_EXTERNAL_LUN_BITMASK_BYTES  (EXT_DEF_EXTERNAL_LUN_COUNT / 8)
+
+/* Structure as used in the IOCTL. */
+
+typedef struct _EXT_EXTERNAL_LUN_BITMASK_ENTRY
+{
+	UINT8	NodeName[EXT_DEF_WWN_NAME_SIZE];
+	UINT8	PortName[EXT_DEF_WWN_NAME_SIZE];
+
+	UINT32	Reserved2;
+	UINT32	Reserved3;
+	UINT32	Reserved4;
+	UINT32	Reserved5;     /* Pad to 32-byte header.*/
+
+	UINT8	Bitmask[EXT_DEF_EXTERNAL_LUN_BITMASK_BYTES];
+} EXT_EXTERNAL_LUN_BITMASK_ENTRY, *PEXT_EXTERNAL_LUN_BITMASK_ENTRY;
+
+
+/* Structure as it is stored in the NT registry.*/
+
+typedef struct _LUN_BITMASK_LIST
+{
+	UINT16	Version;       /* Should be LUN_BITMASK_REGISTRY_VERSION */
+	UINT16	EntryCount;    /* Count of variable entries following.*/
+	UINT32	Reserved1;
+	UINT32	Reserved2;
+	UINT32	Reserved3;
+	UINT32	Reserved4;
+	UINT32	Reserved5;
+	UINT32	Reserved6;
+	UINT32	Reserved7;     /* Pad to 32-byte header.*/
+
+	EXT_EXTERNAL_LUN_BITMASK_ENTRY BitmaskEntry[1];
+		               /* Variable-length data.*/
+
+} EXT_LUN_BITMASK_LIST, *PEXT_LUN_BITMASK_LIST;
+
+
+/* Device database information */
+typedef struct _EXT_DEVICEDATA
+{
+	UINT32	TotalDevices;          /* Set to total number of device. */
+	UINT32	ReturnListEntryCount;  /* Set to number of device entries */
+		                       /* returned in list. */
+
+	EXT_DEVICEDATAENTRY  EntryList[1]; /* Variable length */
+} EXT_DEVICEDATA, *PEXT_DEVICEDATA;
+
+
+/* Swap Target Device Data structure */
+typedef struct _EXT_SWAPTARGETDEVICE
+{
+	EXT_DEVICEDATAENTRY CurrentExistDevice;
+	EXT_DEVICEDATAENTRY NewDevice;
+} EXT_SWAPTARGETDEVICE, *PEXT_SWAPTARGETDEVICE;
+
+#define	EXT_DEF_LUN_BITMASK_LIST_MIN_ENTRIES	1
+#define	EXT_DEF_LUN_BITMASK_LIST_MAX_ENTRIES	256
+
+#ifdef _WIN64
+#define	EXT_DEF_LUN_BITMASK_LIST_HEADER_SIZE	32
+#else
+#define	EXT_DEF_LUN_BITMASK_LIST_HEADER_SIZE \
+    offsetof(LUN_BITMASK_LIST_BUFFER, asBitmaskEntry)
+#endif
+
+#define	EXT_DEF_LUN_BITMASK_LIST_MIN_SIZE   \
+    (EXT_DEF_LUN_BITMASK_LIST_HEADER_SIZE + \
+    (sizeof(EXT_EXTERNAL_LUN_BITMASK_ENTRY) * EXT_DEF_LUN_BITMASK_LIST_MIN_ENTRIES))
+#define	EXT_LUN_BITMASK_LIST_MAX_SIZE   \
+    (EXT_LUN_BITMASK_LIST_HEADER_SIZE + \
+    (sizeof(EXT_EXTERNAL_LUN_BITMASK_ENTRY) * EXT_DEF_LUN_BITMASK_LIST_MAX_ENTRIES))
+/*
+ * LUN mask bit manipulation macros
+ *
+ *   P = Pointer to an EXT_LUN_BIT_MASK union.
+ *   L = LUN number.
+ */
+#define EXT_IS_LUN_BIT_SET(P,L) \
+    ((P->mask[L/8] & (0x80 >> (L%8)))?1:0)
+
+#define EXT_SET_LUN_BIT(P,L) \
+    (P->mask[L/8] |= (0x80 >> (L%8)))
+
+#define EXT_CLR_LUN_BIT(P,L) \
+    (P->mask[L/8] &= ~(0x80 >> (L%8)))
+
+
+
+#ifdef _MSC_VER
+#pragma pack()
+#endif
+
+#endif /* _EXIOCT_H */
diff -urN linux.orig/drivers/scsi/qla2x00exioctln.h linux/drivers/scsi/qla2x00exioctln.h
--- linux.orig/drivers/scsi/qla2x00exioctln.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/qla2x00exioctln.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,131 @@
+/*****************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP2x00 device driver for Linux 2.2.x and 2.4.x 
+* Copyright (C) 2000 Qlogic Corporation 
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+****************************************************************************/
+
+/* 
+   Rev 8     Jan 08, 2001   BN
+             - Added LOOP_BACK ioctl define
+
+   Rev 7     Nov 06, 2000   BN
+             - Added EXT_DEF_MAX_AEN_QUEUE_OS define
+             - Added define for handle_hba_t
+
+   Rev 6     Oct 25, 2000   BN
+             - Added EXT_CC_DRIVER_PROP_OS define
+
+   Rev 5     Oct 25, 2000   BN
+             - Redo the copyright header and add AEN details
+
+   Rev 4     Oct 23, 2000   BN
+             - Added definition for BOOLEAN
+
+   Rev 3     Oct 23, 2000
+             BN
+             - Added definitions for EXT_ADDR_MODE_OS
+               and also include of <linux/ioctl.h>
+
+   Rev 2     Oct 18, 2000
+             BN
+             - Enable API Exention support
+
+   Rev 1     Original version Sep 7, 2000 
+             BN
+
+
+
+*/
+
+#include <linux/ioctl.h>
+
+#if BITS_PER_LONG <= 32
+#define EXT_ADDR_MODE_OS  EXT_DEF_ADDR_MODE_32
+#else
+#define EXT_ADDR_MODE_OS  EXT_DEF_ADDR_MODE_64
+#endif
+
+#define	UINT8	uint8_t
+#define	UINT16	uint16_t
+#define	UINT32	uint32_t
+#define	UINT64	void *
+#define BOOLEAN uint8_t
+
+#define uint8_t  unsigned char
+#define uint16_t unsigned short
+#define uint32_t unsigned int
+
+#if BITS_PER_LONG > 32
+#define uint64_t unsigned long
+#else
+#define uint64_t unsigned long long
+#endif
+
+typedef struct  track_instance
+{
+
+  int   handle;
+
+} track_instance_t;
+
+
+#define	EXT_DEF_MAX_HBA_OS		256	/* 0 - 0xFF */
+#define	EXT_DEF_MAX_BUS_OS		1
+#define	EXT_DEF_MAX_TARGET_OS		256	/* 0 - 0xFF */
+#define	EXT_DEF_MAX_LUN_OS		256	/* 0 - 0xFF */
+
+#define EXT_DEF_MAX_AEN_QUEUE_OS        64
+
+#define QLMULTIPATH_MAGIC 'y'
+#define _QLBUILD   /* for exioct.h to enable include of qinsdmgt.h */
+
+#define EXT_CC_STARTIOCTL   _IOWR(QLMULTIPATH_MAGIC, 0 , sizeof(EXT_IOCTL))
+#define EXT_CC_SETINSTANCE  _IOWR(QLMULTIPATH_MAGIC, 1 , sizeof(EXT_IOCTL))
+
+#define EXT_CC_QUERY_OS  _IOWR(QLMULTIPATH_MAGIC, 2 , sizeof(EXT_IOCTL))
+#define EXT_CC_SEND_FCCT_PASSTHRU_OS _IOWR(QLMULTIPATH_MAGIC, 3 , sizeof(EXT_IOCTL))
+#define EXT_CC_READ_NVRAM_OS _IOWR(QLMULTIPATH_MAGIC, 4 , sizeof(EXT_IOCTL))
+#define EXT_CC_SCSI_PASSTHRU_OS _IOWR(QLMULTIPATH_MAGIC, 5 , sizeof(EXT_IOCTL))
+#define EXT_CC_STOP_QCMD     _IOWR(QLMULTIPATH_MAGIC, 6 , sizeof(EXT_IOCTL))
+#define EXT_CC_RESUME_QCMD   _IOWR(QLMULTIPATH_MAGIC, 7 , sizeof(EXT_IOCTL))
+#define EXT_CC_GET_DATA_OS   _IOWR(QLMULTIPATH_MAGIC, 8 , sizeof(EXT_IOCTL))
+#define	EXT_CC_WWPN_TO_SCSIADDR _IOWR(QLMULTIPATH_MAGIC, 9 , sizeof(EXT_IOCTL))
+#define	EXT_CC_REG_AEN_OS  _IOWR(QLMULTIPATH_MAGIC, 10 , sizeof(EXT_IOCTL))
+#define	EXT_CC_GET_AEN_OS  _IOWR(QLMULTIPATH_MAGIC, 11 , sizeof(EXT_IOCTL))
+
+#define	EXT_CC_DRIVER_PROP_OS  _IOWR(QLMULTIPATH_MAGIC, 12 , sizeof(EXT_IOCTL))
+
+#define EXT_CC_LOOPBACK_OS   _IOWR(QLMULTIPATH_MAGIC, 20 , sizeof(EXT_IOCTL))
+
+
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 2
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -2
+ * c-argdecl-indent: 2
+ * c-label-offset: -2
+ * c-continued-statement-offset: 2
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urN linux.orig/drivers/scsi/qla2x00ioctl.c linux/drivers/scsi/qla2x00ioctl.c
--- linux.orig/drivers/scsi/qla2x00ioctl.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/qla2x00ioctl.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,1179 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic QLA2x00 device driver for Linux 2.2.x and 2.4.x 
+* Copyright (C) 2000 Qlogic Corporation 
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+**
+******************************************************************************/
+/****************************************************************************
+Revision History:
+    Rev. 1.3 Beta       February 20, 2001   BN QLogic
+        - Zero the sp used for IOCTL SCSI Passthru operations
+    Rev. 1.2 Beta       January 31, 2001   BN QLogic
+        - Added setting of scsi completion to pext->DetailStatus
+          and set pext->Status to EXT_STATUS_SCSI_STATUS.
+        - Added details to Statistics IOCTL for ispaborts,
+          lip_count, isr_count.
+
+    Rev. 1.2 Beta       January 8, 2001    BN QLogic
+        - Added loop-back diagnostic IOCTL support.
+
+    Rev. 1.1 Beta       October 27, 2000    BN QLogic
+        - Updated return status from ioctl function.
+
+    Rev. 1.0 Beta       October 20, 2000    BN QLogic
+        - Initial version check in
+  
+
+*/
+
+void copy_up_EXT( PEXT_IOCTL pext, void *arg) {
+uint32_t i;
+uint8_t  *usr_temp, *kernel_tmp;
+
+  /* copy up the EXT_IOCTL to application (api library) */
+  for (i=0 ; i < sizeof(EXT_IOCTL) ; i++) {
+    usr_temp   = (uint8_t *)arg + i;
+    kernel_tmp = (uint8_t *)pext + i;
+    __put_user(*kernel_tmp, usr_temp);
+  }
+  
+  return;
+}
+
+
+/*************************************************************************
+ *   ioctl_scsi_pt_done
+ *
+ * Description:
+ *   Sets completion flag.
+ *
+ * Returns:
+ *************************************************************************/
+void  ioctl_scsi_pt_done(Scsi_Cmnd *pscsi_cmd) {
+  struct Scsi_Host *host;
+  scsi_qla_host_t  *ha;
+
+      host = pscsi_cmd->host;
+      ha = (scsi_qla_host_t *) host->hostdata; 
+
+      ha->IoctlPassThru_InProgress = 0;
+      return;
+}
+
+
+/*************************************************************************
+ *   ioctl_fcct_done
+ *
+ * Description:
+ *   Sets completion flag.
+ *
+ * Returns:
+ *************************************************************************/
+void  ioctl_fcct_done(Scsi_Cmnd *pscsi_cmd) {
+  struct Scsi_Host *host;
+  scsi_qla_host_t  *ha;
+
+      host = pscsi_cmd->host;
+      ha = (scsi_qla_host_t *) host->hostdata; 
+      /* printk("ioctl_fcct_done post function called OK\n"); */
+      DEBUG(sprintf(debug_buff,"ioctl_fcct_done post function called OK\n"));
+      DEBUG(qla2100_print(debug_buff));
+      ha->IoctlPassFCCT_InProgress = 0;
+      return;
+}
+
+
+/*************************************************************************
+ *   qla2100_ioctl
+ *
+ * Description:
+ *   Performs ioctl requests not satified by the upper levels.
+ *
+ * Returns:
+ *   ret  = 0    Success
+ *   ret != 0    Failed; detailed status copied to EXT_IOCTL structure
+ *               if applicable     
+ *************************************************************************/
+int
+qla2100_ioctl(Scsi_Device *dev, int cmd, void *arg){
+
+  static  EXT_IOCTL    ext;
+  PEXT_IOCTL   pext = &ext;
+  struct Scsi_Host   *host;
+  scsi_qla_host_t  *ha, *search_ha; 
+  scsi_lu_t        *q;
+#if BITS_PER_LONG <= 32
+  uint32_t    handle;
+#else
+  uint64_t    handle;
+#endif
+  uint32_t    cnt, i, b, t, l, port_cnt, status;
+  uint32_t    tgt_cnt, tgt, transfer_size, inst;
+  uint8_t     *extptr, *usrsrc, *usr_temp, *kernel_tmp, *kernel_tmp1;
+  static Scsi_Cmnd          scsi_cmd;
+  Scsi_Cmnd   *pscsi_cmd = &scsi_cmd;
+  static Scsi_Device scsi_device;
+  static srb_t             ioctl_sp;
+  srb_t             *sp = &ioctl_sp;
+  static         EXT_SCSI_PASSTHRU   scsi_pass;
+  EXT_SCSI_PASSTHRU   *pscsi_pass = &scsi_pass;
+  static EXT_HBA_NODE      tmp_hba_node;
+  static EXT_HBA_PORT      tmp_hba_port;
+  static EXT_DISC_PORT     tmp_disc_port;
+  static EXT_DISC_TARGET   tmp_disc_target;
+  static EXT_CHIP          tmp_isp;
+  static EXT_HBA_PORT_STAT tmp_stat;
+  uint16_t    mb[MAILBOX_REGISTER_COUNT];
+  unsigned long cpu_flags = 0;
+  uint16_t       scratch;
+  uint16_t       *wptr = &scratch;
+  qla_boards_t   *bdp;
+  uint8_t *temp;
+  uint8_t tempbuf[8];
+  cmd_ms_iocb_entry_t  *pkt;
+ 
+  int  ret = EINVAL;  
+ 
+  BZERO((caddr_t)sp,sizeof(srb_t));
+
+  host = dev->host;
+  ha = (scsi_qla_host_t *) host->hostdata; /* midlayer chosen instance */
+
+  ret = verify_area(VERIFY_READ, (void *)arg, sizeof(EXT_IOCTL)); 
+  if (ret) {
+    DEBUG2(printk("[qla2100_ioctl: ERROR in verify_area READ ha=%8x]\n",(uint32_t)ha);)
+    return(ret);
+  }
+  /* copy in application layer EXT_IOCTL */
+  for (i=0 ; i < sizeof(EXT_IOCTL) ; i++) {
+    usrsrc = (uint8_t *)(arg + i);
+    extptr = (uint8_t *)pext + i;
+    __get_user(*extptr, usrsrc);
+  }
+
+  /* printk("[GOT QLA2100 IOCTL sig=%s cmd=%x]\n",
+     (char *)&pext->Signature,cmd); */
+
+  /* check signature of this ioctl */
+  temp = (uint8_t *) &pext->Signature;
+#if BITS_PER_LONG <= 32
+for (i=0 ; i<4 ; i++,temp++) tempbuf[i] = *temp;
+  if( (tempbuf[0] == 'Q') && (tempbuf[1] == 'L') && 
+      (tempbuf[2] == 'O') && (tempbuf[3] == 'G')) status = 0;
+  else status = 1;
+#else
+  if( (tempbuf[0] == 'Q') && (tempbuf[1] == 'L') && 
+      (tempbuf[2] == 'O') && (tempbuf[3] == 'G') &&
+      (tempbuf[4] == 'I') && (tempbuf[5] == 'C')) status = 0;
+      else status = 1; 
+#endif 
+  if ( status != 0) {
+    DEBUG2(printk("[GOT QLA2100 IOCTL but signature did not match ha=%8x]\n",
+          (uint32_t)ha);)
+    ret = EXT_STATUS_ERR;
+    return(ret);
+  }
+  /* check version of this ioctl */
+  if (pext->Version  !=  EXT_VERSION) {
+    pext->Status       = EXT_STATUS_ERR;
+    pext->DetailStatus = EXT_STATUS_INVALID_PARAM;
+    copy_up_EXT(pext,arg);
+    printk(KERN_WARNING "qla2x00: GOT QLA2100 IOCTL but version did not match.\n");
+    ret = EXT_STATUS_ERR;
+    return(ret);
+  }
+  /* check for API setting HBA Instance for subsequent operations */
+  if (cmd == (int)EXT_CC_SETINSTANCE) {
+      /* since API opens devices once and uses handle for subsequent calls */
+      /* we keep a parameter to designate the "active HBA" for ioctls */
+      if (pext->HbaSelect < num_hosts) {
+         apiHBAInstance     = pext->HbaSelect;
+         pext->Status       = EXT_STATUS_OK;
+         pext->DetailStatus = EXT_STATUS_OK;
+         copy_up_EXT(pext,arg);
+         ret = EXT_STATUS_OK;
+      } else {
+         pext->Status       = EXT_STATUS_ERR;
+         pext->DetailStatus = EXT_STATUS_INVALID_PARAM;
+         copy_up_EXT(pext,arg);
+         DEBUG2(printk("[qla2100_ioctl: ERROR in EXT_SETINSTANCE ha=%8x]\n",(uint32_t)ha);)
+         ret = EXT_STATUS_ERR;
+      }
+      return(ret); /* Instance for subsequent IOCTLs are not set */
+  }
+
+  /* check for valid  apiHBAInstance (set previously by EXT_SETINSTANCE 
+     or default 0)  and set   ha   context for this IOCTL */    
+  for (search_ha=qla2100_hostlist; 
+      (search_ha != NULL) && search_ha->instance != apiHBAInstance;
+       search_ha = search_ha->next) ;
+  if ( !search_ha ) { 
+     pext->Status       = EXT_STATUS_ERR;
+     pext->DetailStatus = EXT_STATUS_INVALID_PARAM;
+     copy_up_EXT(pext,arg);
+     DEBUG2(printk("[qla2100_ioctl: ERROR in matching apiHBAInstance to an HBA Instance]\n");)
+     ret = EXT_STATUS_ERR;
+     return(ret);
+  }
+  /* IOCTL ha context is ready to be set from apiHBAInstance */
+  ha = search_ha;
+  /* set EXT_IOCTL.HbaSelect  for reference by IOCTL caller */
+  pext->HbaSelect = apiHBAInstance;
+
+  switch (cmd) { /* switch on EXT IOCTL COMMAND CODE */
+    case EXT_CC_STARTIOCTL:
+      pext->Instance     = num_hosts;
+      pext->Status       = EXT_STATUS_OK;
+      pext->DetailStatus = EXT_STATUS_OK;
+      copy_up_EXT(pext,arg);
+      /*printk("[QLA2100 EXT_STARTIOCTL did OK ]\n");*/ 
+      ret = EXT_STATUS_OK;
+      break;
+    case EXT_CC_QUERY:
+      /* All Query type ioctls are done here */
+      switch(pext->SubCode) {
+        case EXT_SC_QUERY_HBA_NODE:
+        /* fill all available HBA NODE Information */
+          bdp = &QLBoardTbl_fc[ha->devnum];
+          for (i=0; i < 8 ;i++)   tmp_hba_node.WWNN[i] = ha->node_name[i];
+          sprintf((char *)(tmp_hba_node.Manufacturer),"Qlogic Corp.");
+          sprintf((char *)(tmp_hba_node.Model),(char *)&bdp->bdName[0]);
+          tmp_hba_node.SerialNum[0] = ha->node_name[5];
+          tmp_hba_node.SerialNum[1] = ha->node_name[6];
+          tmp_hba_node.SerialNum[2] = ha->node_name[7];
+          sprintf((char *)(tmp_hba_node.DriverVersion),QLA2100_VERSION);
+          sprintf((char *)(tmp_hba_node.FWVersion),"%2d.%02d.%02d",
+                  bdp->fwver[0], bdp->fwver[1], bdp->fwver[2]);
+          /* tmp_hba_node.NvramVersion = ha->nvram_version; */  
+          sprintf((char *)(tmp_hba_node.OptRomVersion),"0");
+          tmp_hba_node.InterfaceType = EXT_DEF_FC_INTF_TYPE;
+          tmp_hba_node.PortCount = 1;
+          
+          ret = verify_area(VERIFY_WRITE, (void  *)pext->ResponseAdr,
+                sizeof(EXT_HBA_NODE)); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE ha=%8x]\n",(uint32_t)ha);)
+            return(ret);
+          }
+          /* now copy up the HBA_NODE to user */
+          if (pext->ResponseLen < sizeof(EXT_HBA_NODE)) transfer_size = pext->ResponseLen;
+          else       transfer_size = sizeof(EXT_HBA_NODE);
+          for (i=0 ; i < transfer_size ; i++) {
+            usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+            kernel_tmp = (uint8_t *)&tmp_hba_node + i;
+            __put_user(*kernel_tmp, usr_temp);
+          }
+          /*printk("[finished QLA2100 IOCTL QUERY_HBA_NODE ]\n"); */
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+          break;
+        case EXT_SC_QUERY_HBA_PORT:
+          /* reflect all HBA PORT related info */
+          tmp_hba_port.WWPN[7] = ha->init_cb->port_name[7];  
+          tmp_hba_port.WWPN[6] = ha->init_cb->port_name[6];
+          tmp_hba_port.WWPN[5] = ha->init_cb->port_name[5];
+          tmp_hba_port.WWPN[4] = ha->init_cb->port_name[4];
+          tmp_hba_port.WWPN[3] = ha->init_cb->port_name[3];
+          tmp_hba_port.WWPN[2] = ha->init_cb->port_name[2];
+          tmp_hba_port.WWPN[1] = ha->init_cb->port_name[1];
+	  tmp_hba_port.WWPN[0] = ha->init_cb->port_name[0];
+          tmp_hba_port.Id[1] = ha->port_id[0];
+          tmp_hba_port.Id[2] = ha->port_id[1];
+          tmp_hba_port.Id[3] = ha->port_id[2];
+          tmp_hba_port.Type =  EXT_DEF_INITIATOR_DEV;
+
+          port_cnt = 0; 
+          tgt_cnt  = 0;
+          for (tgt = 0; tgt < MAX_FIBRE_DEVICES ; tgt++) {
+          if (ha->fc_db[tgt].loop_id > LAST_SNS_LOOP_ID) 
+               continue;
+            port_cnt++;
+
+          /* at this point the linux driver does not differentiate */
+          /* Initiator devices (ie HBAs) from Targets; so the count */
+          /* is same for both */
+          /*      if (ha->fc_db[tgt] & FC_INITIATOR_DEVICE) 
+                  continue;  */
+            tgt_cnt++;
+          }
+          tmp_hba_port.DiscPortCount   = port_cnt;
+          tmp_hba_port.DiscTargetCount = tgt_cnt;
+
+          if ( ha->loop_down_timer == 0 && ha->loop_state == LOOP_DOWN) {
+                  tmp_hba_port.State    = EXT_DEF_HBA_LOOP_DOWN;
+          } else  tmp_hba_port.State    = EXT_DEF_HBA_OK;
+          tmp_hba_port.DiscPortNameType = EXT_DEF_USE_PORT_NAME;
+
+          ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr ,
+                sizeof(EXT_HBA_PORT)); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE ha=%8x]\n",(uint32_t)ha);)
+            return(ret);
+          }
+          /* now copy up the HBA_PORT to user */
+          if (pext->ResponseLen < sizeof(EXT_HBA_PORT)) transfer_size = pext->ResponseLen;
+          else         transfer_size = sizeof(EXT_HBA_PORT);
+          for (i=0 ; i < transfer_size ; i++) {
+            usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+            kernel_tmp = (uint8_t *)&tmp_hba_port + i;
+            __put_user(*kernel_tmp, usr_temp);
+          }
+          /*printk("[finished QLA2100 IOCTL QUERY_HBA_PORT ports=%x tgts=%x]\n",port_cnt,tgt_cnt); */
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+          break;
+        case EXT_SC_QUERY_DISC_PORT:
+          for (tgt=0, inst=0; tgt < MAX_FIBRE_DEVICES; tgt++) {
+            if (ha->fc_db[tgt].loop_id > LAST_SNS_LOOP_ID)
+               continue; 
+            if( inst != pext->Instance ) {
+              inst++;
+              continue;
+            }
+            break;
+          }
+          if (tgt == MAX_FIBRE_DEVICES) {
+            pext->Status       = ret = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+            copy_up_EXT(pext,arg);
+            return(ret); 
+          }
+
+            tmp_disc_port.WWNN[0] = ha->fc_db[tgt].name[0];
+            tmp_disc_port.WWNN[1] = ha->fc_db[tgt].name[1];
+            tmp_disc_port.WWNN[2] = ha->fc_db[tgt].name[2];
+            tmp_disc_port.WWNN[3] = ha->fc_db[tgt].name[3];
+
+            tmp_disc_port.WWNN[4] = ha->fc_db[tgt].name[4];
+            tmp_disc_port.WWNN[5] = ha->fc_db[tgt].name[5];
+            tmp_disc_port.WWNN[6] = ha->fc_db[tgt].name[6];
+            tmp_disc_port.WWNN[7] = ha->fc_db[tgt].name[7];
+
+            tmp_disc_port.WWPN[0] = ha->fc_db[tgt].wwn[0];
+            tmp_disc_port.WWPN[1] = ha->fc_db[tgt].wwn[1];
+            tmp_disc_port.WWPN[2] = ha->fc_db[tgt].wwn[2];
+            tmp_disc_port.WWPN[3] = ha->fc_db[tgt].wwn[3];
+
+            tmp_disc_port.WWPN[4] = ha->fc_db[tgt].wwn[4];
+            tmp_disc_port.WWPN[5] = ha->fc_db[tgt].wwn[5];
+            tmp_disc_port.WWPN[6] = ha->fc_db[tgt].wwn[6];
+            tmp_disc_port.WWPN[7] = ha->fc_db[tgt].wwn[7];
+
+          tmp_disc_port.Id[1] = ha->fc_db[tgt].port_id[0];
+          tmp_disc_port.Id[2] = ha->fc_db[tgt].port_id[1];
+          tmp_disc_port.Id[3] = ha->fc_db[tgt].port_id[2];
+          tmp_disc_port.Type  = EXT_DEF_TARGET_DEV;
+
+          tmp_disc_port.Status   = EXT_STATUS_OK;
+          tmp_disc_port.Bus      = 0;
+          tmp_disc_port.TargetId = tgt;
+ 
+          ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr ,
+                sizeof(EXT_DISC_PORT)); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE ha=%8x]\n",(uint32_t)ha);)
+            return(ret);
+          }
+
+          /* now copy up the DISC_PORT to user */
+          if (pext->ResponseLen < sizeof(EXT_DISC_PORT)) transfer_size = pext->ResponseLen;
+          else        transfer_size = sizeof(EXT_DISC_PORT);
+          for (i=0 ; i < transfer_size ; i++) {
+            usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+            kernel_tmp = (uint8_t *)&tmp_disc_port + i;
+            __put_user(*kernel_tmp, usr_temp);
+          }
+          /*printk("[finished QLA2100 IOCTL QUERY_DISC_PORT ]\n"); */
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+          break;
+        case EXT_SC_QUERY_DISC_TGT:
+	  /* (for multipath merge) to do: search the ha->tgt[][] data base 
+             instead of ha->fc_db[] so that we give details on Targets that
+             are visible to the OS. */
+          for (tgt=0, inst=0; tgt < MAX_FIBRE_DEVICES; tgt++) {
+            if (ha->fc_db[tgt].loop_id > LAST_SNS_LOOP_ID)
+               continue; 
+            if( inst != pext->Instance ) {
+              inst++;
+              continue;
+            }
+            break;
+          }
+          if (tgt == MAX_FIBRE_DEVICES) {
+            pext->Status       = ret = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+            copy_up_EXT(pext,arg);
+            return(ret); 
+          }
+            tmp_disc_target.WWNN[0]= ha->fc_db[tgt].name[0];
+            tmp_disc_target.WWNN[1]= ha->fc_db[tgt].name[1];
+            tmp_disc_target.WWNN[2]= ha->fc_db[tgt].name[2];
+            tmp_disc_target.WWNN[3]= ha->fc_db[tgt].name[3];
+
+            tmp_disc_target.WWNN[4]= ha->fc_db[tgt].name[4];
+            tmp_disc_target.WWNN[5]= ha->fc_db[tgt].name[5];
+            tmp_disc_target.WWNN[6]= ha->fc_db[tgt].name[6];
+            tmp_disc_target.WWNN[7]= ha->fc_db[tgt].name[7];
+
+
+            tmp_disc_target.WWPN[0]= ha->fc_db[tgt].wwn[0];
+            tmp_disc_target.WWPN[1]= ha->fc_db[tgt].wwn[1];
+            tmp_disc_target.WWPN[2]= ha->fc_db[tgt].wwn[2];
+            tmp_disc_target.WWPN[3]= ha->fc_db[tgt].wwn[3];
+
+            tmp_disc_target.WWPN[4]= ha->fc_db[tgt].wwn[4];
+            tmp_disc_target.WWPN[5]= ha->fc_db[tgt].wwn[5];
+            tmp_disc_target.WWPN[6]= ha->fc_db[tgt].wwn[6];
+            tmp_disc_target.WWPN[7]= ha->fc_db[tgt].wwn[7];
+            tmp_disc_target.Id[1] = ha->fc_db[tgt].port_id[0];
+            tmp_disc_target.Id[2] = ha->fc_db[tgt].port_id[1];
+            tmp_disc_target.Id[3] = ha->fc_db[tgt].port_id[2];
+            tmp_disc_target.Type  = EXT_DEF_TARGET_DEV;
+
+          tmp_disc_target.Status   = EXT_STATUS_OK;
+          tmp_disc_target.Bus      = 0;
+          tmp_disc_target.TargetId = tgt;
+ 
+          cnt = 0;
+          for (i=0; i < MAX_LUNS ; i++) {
+          if ((ha->tgt[0][tgt])->luns[i] !=0) 
+              cnt++;
+          }
+          tmp_disc_target.LunCount = cnt;
+
+          ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr ,
+                sizeof(EXT_DISC_TARGET)); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE ha=%8x]\n",(uint32_t)ha);)
+            return(ret);
+          }
+          /* now copy up the DISC_TGT to user */
+          if (pext->ResponseLen < sizeof(EXT_DISC_PORT)) transfer_size = pext->ResponseLen;
+          else     transfer_size = sizeof(EXT_DISC_TARGET);
+          for (i=0 ; i < transfer_size ; i++) {
+            usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+            kernel_tmp = (uint8_t *)&tmp_disc_target + i;
+            __put_user(*kernel_tmp, usr_temp);
+          }
+          /* printk("[finished QLA2100 IOCTL QUERY_DISC_TGT Luns=%x pid0=%x pid1=%x pid2=%x]\n",cnt,ha->fc_db[tgt].port_id[0],ha->fc_db[tgt].port_id[1],ha->fc_db[tgt].port_id[2]);*/
+ 
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+          break;
+        case EXT_SC_QUERY_CHIP:
+          host = ha->host;
+	  tmp_isp.VendorId       = QLA2100_VENDOR_ID;
+	  tmp_isp.DeviceId       = ha->device_id;
+	  tmp_isp.SubVendorId    = QLA2100_VENDOR_ID;
+          tmp_isp.SubSystemId    = 0;	
+	  tmp_isp.PciBusNumber   = ha->pci_bus;	
+	  tmp_isp.PciSlotNumber  = (ha->pci_device_fn & 0xf8) >> 3;
+	  tmp_isp.IoAddr         = host->io_port;	
+	  tmp_isp.IoAddrLen      = 512;	
+          tmp_isp.MemAddr        = 0; 
+          tmp_isp.MemAddrLen     = 0; 	
+          tmp_isp.ChipType       = 0; 	
+          tmp_isp.InterruptLevel = host->irq;
+          for (i=0;i<8;i++)      tmp_isp.OutMbx[i] = 0;		
+
+          ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr ,
+                sizeof(EXT_CHIP)); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE ha=%8x]\n",(uint32_t)ha);)
+            return(ret);
+          }
+          /* now copy up the ISP to user */
+          if (pext->ResponseLen < sizeof(EXT_CHIP)) transfer_size = pext->ResponseLen;
+          else         transfer_size = sizeof(EXT_CHIP);
+          for (i=0 ; i < transfer_size ; i++) {
+            usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+            kernel_tmp = (uint8_t *)&tmp_isp + i;
+            __put_user(*kernel_tmp, usr_temp);
+          }
+          /* printk("[finished QLA2100 IOCTL QUERY_CHIP]\n"); */ 
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+          break;
+
+        case EXT_SC_QUERY_DISC_LUN:
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+          break;
+        default:
+          ret = EXT_STATUS_ERR;
+          break;
+      }
+      break;
+    case EXT_CC_GET_DATA:
+      switch(pext->SubCode) {
+        case EXT_SC_GET_STATISTICS:
+
+  	  tmp_stat.ControllerErrorCount   =  ha->isp_aborts;
+	  tmp_stat.DeviceErrorCount       =  0;
+	  tmp_stat.TotalIoCount           =  ha->qthreads;
+	  tmp_stat.TotalMBytes            =  0;
+	  tmp_stat.TotalLipResets         =  ha->lip_count;
+	  tmp_stat.TotalInterrupts        =  ha->isr_count;
+
+          ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr,
+                sizeof(EXT_HBA_PORT_STAT)); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE ha=%8x]\n",(uint32_t)ha);)
+            return(ret);
+          }
+          /* now copy up the STATISTICS to user */
+          if (pext->ResponseLen < sizeof(EXT_HBA_PORT_STAT)) transfer_size = pext->ResponseLen;
+          else       transfer_size = sizeof(EXT_HBA_PORT_STAT);
+          for (i=0 ; i < transfer_size ; i++) {
+            usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+            kernel_tmp = (uint8_t *)&tmp_stat + i;
+            __put_user(*kernel_tmp, usr_temp);
+          }
+          /*printk("[finished QLA2100 IOCTL STATISTICS ]\n");*/ 
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+          break;
+        default:
+          break;
+      }
+      break;
+    case EXT_CC_SEND_FCCT_PASSTHRU:
+    DEBUG(sprintf(debug_buff,"qla2100_ioctl: start EXT_CC_SEND_FCCT_PASSTHRU\n"));
+    DEBUG(qla2100_print(debug_buff));
+    /* Management Server type (fc switch) pass thru ioctl */
+    /* same as EXT_FCSCSI_REQ but it is going to the FC switch */
+    /* clear ioctl_sp and scsi_cmd to be used */
+    kernel_tmp = (uint8_t *)sp;
+    for (i=0;i<sizeof(srb_t);i++)  *(kernel_tmp+i) = 0; 
+    kernel_tmp = (uint8_t *)ha->ioctl_mem;
+    for (i=0;i<PAGE_SIZE;i++)      *(kernel_tmp+i) = 0; 
+    kernel_tmp = (uint8_t *)pscsi_cmd;
+    for (i=0;i<sizeof(Scsi_Cmnd);i++)   *(kernel_tmp+i) = 0; 
+    kernel_tmp = (uint8_t *)&scsi_device;
+    for (i=0;i<sizeof(Scsi_Device);i++) *(kernel_tmp+i) = 0; 
+
+      /*printk("[start EXT_CC_SEND_FCCT_PASSTHRU]\n"); */
+      if (pext->ResponseLen > PAGE_SIZE)  pext->ResponseLen = PAGE_SIZE;
+      if (pext->RequestLen  > PAGE_SIZE)  {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_INVALID_PARAM;
+        copy_up_EXT(pext,arg);
+        /*printk("[EXT_CC_SEND_FCCT_PASSTHRU too big ResponseLen=%x ReqLen=%x]\n",pext->ResponseLen,pext->RequestLen); */
+        DEBUG2(printk("[qla2100_ioctl: ERROR size of requested Resp_len in EXT_CC_SEND_FCCT_PASSTHRU]\n");)
+        return(ret);
+      }
+      ret = verify_area(VERIFY_READ, (void *)pext->RequestAdr,
+                        pext->RequestLen); 
+      if (ret){
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_COPY_ERR;
+        copy_up_EXT(pext,arg);
+        /*printk("[EXT_CC_SEND_FCCT_PASSTHRU verify read error]\n");*/ 
+        DEBUG2(printk("[qla2100_ioctl: ERROR verify_area READ of EXT_CC_SEND_FCCT_PASSTHRU]\n");)
+        return(ret);
+      }
+      for (i=0 ; i < pext->RequestLen ; i++) {
+        /* copy in from user space the fcct command to be sent */
+        usr_temp   = (uint8_t *)pext->RequestAdr + i;
+        kernel_tmp = (uint8_t *)ha->ioctl_mem + i;
+        __get_user(*kernel_tmp, usr_temp);
+        /* printk("{%x}",*kernel_tmp); */
+      }
+      /* check on current topology or loop down */
+      if ((ha->current_topology != ISP_CFG_F)  && 
+          (ha->current_topology != ISP_CFG_FL ) ) {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+        copy_up_EXT(pext,arg);
+        /*printk("[EXT_CC_SEND_FCCT_PASSTHRU wrong topology current=%x]\n",
+          ha->current_topology); */
+        DEBUG2(printk("[qla2100_ioctl: ERROR EXT_CC_SEND_FCCT_PASSTHRU not in F-Port or FL-Port mode]\n");)
+        return(ret);
+      }
+      /* check on loop down */
+      if ( ha->loop_down_timer == 0 && ha->loop_state == LOOP_DOWN)  {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+        copy_up_EXT(pext,arg);
+        /* printk("[EXT_CC_SEND_FCCT_PASSTHRU loop down]\n"); */
+        DEBUG2(printk("[qla2100_ioctl: ERROR EXT_CC_SEND_FCCT_PASSTHRU not in F-Port mode]\n");)
+        return(ret);
+      }
+      /* login to management server device */
+      if (ha->flags.managment_server_logged_in == 0) {
+          mb[0] = MBC_LOGIN_FABRIC_PORT;
+          mb[1] = MANAGEMENT_SERVER << 8;
+          mb[2] = 0xff;
+          mb[3] = 0xfffa;
+
+          ret = qla2100_mailbox_command(ha, BIT_3|BIT_2|BIT_1|BIT_0,
+                                &mb[0]);
+          if ( (ret != 0) || (mb[0] == 0x4006)  ||
+               (mb[0] == 0x4009) || (mb[0] != 0x4000) ) {
+              pext->Status       = EXT_STATUS_ERR;
+              pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+              copy_up_EXT(pext,arg);
+              /* printk("[EXT_CC_SEND_FCCT_PASSTHRU could not login to sns]\n"); */
+              DEBUG2(printk("[qla2100_ioctl: ERROR could not login to Management Server]\n");)
+              DEBUG(sprintf(debug_buff,"FCCT ioctl: call qla2100_ms_req_pkt\n"));
+              DEBUG(qla2100_print(debug_buff));
+              return(ret);
+          }
+          ha->flags.managment_server_logged_in = 1;
+      }
+
+      /* setup  sp  for this FCCT pass thru */
+      pscsi_cmd->host = ha->host;
+      sp->cmd         = pscsi_cmd;
+      sp->flags       = SRB_WATCHDOG;
+
+      /* mark this as a special delivery and collection command */
+      scsi_cmd.flags     = 0;      
+      scsi_cmd.scsi_done = ioctl_fcct_done;
+
+      DEBUG(sprintf(debug_buff,"FCCT ioctl: FABRIC_LOGIN OK, call qla2100_ms_req_pkt\n"));
+      DEBUG(qla2100_print(debug_buff));
+
+      /* get spin lock for this operation */
+      spin_lock_irqsave(&io_request_lock, cpu_flags);
+
+      /* Get MS request packet. */
+      if( (pkt = (cmd_ms_iocb_entry_t *)qla2100_ms_req_pkt(ha, sp) ) ) {
+            pkt->entry_type  = MS_IOCB_TYPE;
+            pkt->entry_count = 1;
+            pkt->loop_id     = MANAGEMENT_SERVER;
+            pkt->timeout     = 4;
+            pkt->DSDcount    = 1;
+            pkt->RespDSDcount = 2;
+            pkt->Response_bytecount = pext->ResponseLen;
+            pkt->Request_bytecount  = pext->RequestLen;
+
+            /* loading command payload address */
+            pkt->dseg_req_address[0] = LS_64BITS(ha->ioctl_mem_phys);
+            pkt->dseg_req_address[1] = MS_64BITS(ha->ioctl_mem_phys);
+            pkt->dseg_req_length = pext->RequestLen;
+  
+            /* loading command response address */
+            pkt->dseg_rsp_address[0] = LS_64BITS(ha->ioctl_mem_phys);
+            pkt->dseg_rsp_address[1] = MS_64BITS(ha->ioctl_mem_phys);
+            pkt->dseg_rsp_length = pext->ResponseLen;
+
+            /* set flag to indicate IOCTL FCCT PassThru in progress */
+            ha->IoctlPassFCCT_InProgress = 1;
+
+            ha->ioctl_timer = 6; /* 6 ticks of 1 second timer max wait */
+
+            /* Issue command to ISP */
+            qla2100_isp_cmd(ha);
+      }
+      /* release spin lock since command is issued */  
+      spin_unlock_irqrestore(&io_request_lock, cpu_flags);
+
+      DEBUG(sprintf(debug_buff,
+        "FCCT ioctl: Command issued and released spin lock\n"));
+      DEBUG(qla2100_print(debug_buff));
+
+      if (!pkt) {
+          pext->Status       = EXT_STATUS_ERR;
+          pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+          copy_up_EXT(pext,arg);
+          /* printk("[EXT_CC_SEND_FCCT_PASSTHRU could not get Request Packet]\n"); */
+          DEBUG2(printk("[qla2100_ioctl:EXT_CC_SEND_FCCT_PASSTHRU could not get Request Packet]\n");)
+          return(ret);
+      }
+
+      /* wait for post function or timer to zero the InProgress flag */
+      while (ha->IoctlPassFCCT_InProgress == 1)  {
+        udelay(35);
+      }
+
+      DEBUG(sprintf(debug_buff,
+        "FCCT ioctl: finished while(InProgress) wait loop \n"));
+      DEBUG(qla2100_print(debug_buff));
+      /* printk("[FCCT IOCTL finished while(InProgress) wait loop ]\n");*/
+
+        if (ha->IoctlPassFCCT_InProgress == 1) {
+          /* We waited and post function did not get called */ 
+          DEBUG(printk("[FCCT IOCTL post function not called]\n");)
+          DEBUG(sprintf(debug_buff,
+           "FCCT ioctl: post function not called \n"));
+          DEBUG(qla2100_print(debug_buff));
+          pext->Status       = EXT_STATUS_ERR;
+          pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;   
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_ERR;
+        } else {
+             /* getting device data and putting in pext->ResponseAdr */
+             /* printk("[post function called; start FCCT IOCTL returning up data ]\n");*/
+             ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr ,
+                               pext->ResponseLen); 
+             if (ret) {
+               pext->Status       = EXT_STATUS_ERR;
+               pext->DetailStatus = EXT_STATUS_COPY_ERR;
+               copy_up_EXT(pext,arg);
+               DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE for IOCTL PT ha=%8x]\n",
+                     (uint32_t)ha);)
+               return(ret);
+             }
+             /* sending back data returned from Management Server */
+             for (i=0 ; i < pext->ResponseLen ; i++) {
+                usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+                kernel_tmp = (uint8_t *)ha->ioctl_mem + i;
+                /*printk("[%x]",*kernel_tmp);*/
+                __put_user(*kernel_tmp, usr_temp);
+             }
+          /*printk("[finished QLA2100 IOCTL EXT_CC_SEND_FCCT_PASSTHRU]\n");*/
+          pext->Status       = EXT_STATUS_SCSI_STATUS;
+          pext->DetailStatus = sp->scode;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+        }
+      break;
+
+    case EXT_CC_SEND_SCSI_PASSTHRU: 
+      /* printk("[start EXT_CC_SEND_SCSI_PASSTHRU]\n"); */
+      ret = verify_area(VERIFY_READ, (void *)pext->RequestAdr,
+            sizeof(EXT_SCSI_PASSTHRU)); 
+      if (ret) {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_COPY_ERR;
+        copy_up_EXT(pext,arg);
+        DEBUG2(printk("[qla2100_ioctl: ERROR verify_area READ of EXT_SCSI_PASSTHRU]\n");)
+        return(ret);
+      }
+      for (i=0 ; i < sizeof(EXT_SCSI_PASSTHRU) ; i++) {
+        usr_temp   = (uint8_t *)pext->RequestAdr + i;
+        kernel_tmp = (uint8_t *)pscsi_pass + i;
+        __get_user(*kernel_tmp, usr_temp);
+      }
+      if (pext->ResponseLen > PAGE_SIZE) {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_INVALID_PARAM;
+        copy_up_EXT(pext,arg);
+        DEBUG2(printk("[qla2100_ioctl: ERROR size of requested EXT_SCSI_PASSTHRU]\n");)
+        return(ret);
+      }
+      /* clear ioctl_sp and scsi_cmd and scsi_device to be used */
+      kernel_tmp = (uint8_t *)sp;
+      for (i=0;i<sizeof(srb_t);i++)       *(kernel_tmp+i) = 0; 
+      kernel_tmp = (uint8_t *)pscsi_cmd;
+      for (i=0;i<sizeof(Scsi_Cmnd);i++)   *(kernel_tmp+i) = 0; 
+      kernel_tmp = (uint8_t *)&scsi_device;
+      for (i=0;i<sizeof(Scsi_Device);i++) *(kernel_tmp+i) = 0; 
+      kernel_tmp = (uint8_t *)ha->ioctl_mem;
+      for (i=0;i<PAGE_SIZE;i++) *kernel_tmp = 0; 
+
+      pscsi_cmd->host = ha->host;
+      sp->cmd         = pscsi_cmd;
+      sp->flags       = SRB_WATCHDOG;
+
+      /* mark this as a special delivery and collection command */
+      scsi_cmd.flags     = 0;      
+      scsi_cmd.scsi_done = ioctl_scsi_pt_done;
+
+      scsi_cmd.device               = &scsi_device;     
+      scsi_cmd.device->tagged_queue = 0;
+      scsi_cmd.use_sg               = 0; /* no ScatterGather */
+      scsi_cmd.target               = pscsi_pass->TargetAddr.Target;
+      scsi_cmd.lun                  = pscsi_pass->TargetAddr.Lun;
+      scsi_cmd.request_bufflen      = pext->ResponseLen;
+      scsi_cmd.request_buffer       = ha->ioctl_mem;
+      scsi_cmd.timeout_per_command  = 0x300;
+
+      // printk("[start FCSCSI IOCTL look at direction t=%x l=%x]\n",
+      // scsi_cmd.target,scsi_cmd.lun);
+      if (pscsi_pass->Direction == EXT_DEF_SCSI_PASSTHRU_DATA_OUT) {
+          /* sending user data from pext->ResponseAdr to device */
+          ret = verify_area(VERIFY_READ, (void *)pext->ResponseAdr,
+                            pext->ResponseLen); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area READ EXT_SCSI_PASSTHRU]\n");)
+            return(ret);
+          }
+          for (i=0 ; i < pext->ResponseLen ; i++) {
+            usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+            kernel_tmp = (uint8_t *)ha->ioctl_mem    + i;
+            __get_user(*kernel_tmp, usr_temp);
+          }
+      }
+      if (pscsi_pass->CdbLength == 6) {
+        scsi_cmd.cmd_len = 6;
+        scsi_cmd.data_cmnd[0] = scsi_cmd.cmnd[0] = pscsi_pass->Cdb[0];
+        scsi_cmd.data_cmnd[1] = scsi_cmd.cmnd[1] = pscsi_pass->Cdb[1];
+        scsi_cmd.data_cmnd[2] = scsi_cmd.cmnd[2] = pscsi_pass->Cdb[2];
+        scsi_cmd.data_cmnd[3] = scsi_cmd.cmnd[3] = pscsi_pass->Cdb[3];
+        scsi_cmd.data_cmnd[4] = scsi_cmd.cmnd[4] = pscsi_pass->Cdb[4];
+        scsi_cmd.data_cmnd[5] = scsi_cmd.cmnd[5] = pscsi_pass->Cdb[5];
+        scsi_cmd.data_cmnd[6] = scsi_cmd.cmnd[6] = 0;
+        scsi_cmd.data_cmnd[7] = scsi_cmd.cmnd[7] = 0;
+        scsi_cmd.data_cmnd[8] = scsi_cmd.cmnd[8] = 0;
+        scsi_cmd.data_cmnd[9] = scsi_cmd.cmnd[9] = 0;
+      } else if (pscsi_pass->CdbLength == 10) {
+        scsi_cmd.cmd_len = 0x0A;
+        scsi_cmd.data_cmnd[0] = scsi_cmd.cmnd[0] = pscsi_pass->Cdb[0];
+        scsi_cmd.data_cmnd[1] = scsi_cmd.cmnd[1] = pscsi_pass->Cdb[1];
+        scsi_cmd.data_cmnd[2] = scsi_cmd.cmnd[2] = pscsi_pass->Cdb[2];
+        scsi_cmd.data_cmnd[3] = scsi_cmd.cmnd[3] = pscsi_pass->Cdb[3];
+        scsi_cmd.data_cmnd[4] = scsi_cmd.cmnd[4] = pscsi_pass->Cdb[4];
+        scsi_cmd.data_cmnd[5] = scsi_cmd.cmnd[5] = pscsi_pass->Cdb[5];
+        scsi_cmd.data_cmnd[6] = scsi_cmd.cmnd[6] = pscsi_pass->Cdb[6];
+        scsi_cmd.data_cmnd[7] = scsi_cmd.cmnd[7] = pscsi_pass->Cdb[7];
+        scsi_cmd.data_cmnd[8] = scsi_cmd.cmnd[8] = pscsi_pass->Cdb[8];
+        scsi_cmd.data_cmnd[9] = scsi_cmd.cmnd[9] = pscsi_pass->Cdb[9];
+      } else if (pscsi_pass->CdbLength == 12) {
+        scsi_cmd.cmd_len = 0x0C;
+        scsi_cmd.data_cmnd[0] = scsi_cmd.cmnd[0] = pscsi_pass->Cdb[0];
+        scsi_cmd.data_cmnd[1] = scsi_cmd.cmnd[1] = pscsi_pass->Cdb[1];
+        scsi_cmd.data_cmnd[2] = scsi_cmd.cmnd[2] = pscsi_pass->Cdb[2];
+        scsi_cmd.data_cmnd[3] = scsi_cmd.cmnd[3] = pscsi_pass->Cdb[3];
+        scsi_cmd.data_cmnd[4] = scsi_cmd.cmnd[4] = pscsi_pass->Cdb[4];
+        scsi_cmd.data_cmnd[5] = scsi_cmd.cmnd[5] = pscsi_pass->Cdb[5];
+        scsi_cmd.data_cmnd[6] = scsi_cmd.cmnd[6] = pscsi_pass->Cdb[6];
+        scsi_cmd.data_cmnd[7] = scsi_cmd.cmnd[7] = pscsi_pass->Cdb[7];
+        scsi_cmd.data_cmnd[8] = scsi_cmd.cmnd[8] = pscsi_pass->Cdb[8];
+        scsi_cmd.data_cmnd[9] = scsi_cmd.cmnd[9] = pscsi_pass->Cdb[9];
+        scsi_cmd.data_cmnd[10] = scsi_cmd.cmnd[10] = pscsi_pass->Cdb[10];
+        scsi_cmd.data_cmnd[11] = scsi_cmd.cmnd[10] = pscsi_pass->Cdb[11];
+       }
+      /* Generate LU queue on bus, target, LUN */
+      b = SCSI_BUS_32(pscsi_cmd);
+      t = SCSI_TCN_32(pscsi_cmd);
+      l = SCSI_LUN_32(pscsi_cmd);
+
+      /* set sp->target for 32bit/64bit delivery */
+      sp->wdg_time                   = 0;
+
+      /* check presense of requested target and other conditions */
+      if( TGT_Q(ha,b,t) == NULL ||
+        ( TGT_Q(ha,b,t) && TGT_Q(ha,b,t)->loop_id > LAST_SNS_LOOP_ID)  ||
+        ( ha->loop_down_timer == 0 && ha->loop_state == LOOP_DOWN)) {  
+            printk(KERN_WARNING "qla2x00: FCSCSI IOCTL Target MISSING.\n");
+            DEBUG2(printk("scsi(%2d:%2d:%2d:%2d): SCSI PT port unavailable\n",
+                  (int)ha->host_no,b,t,l);)
+           pext->Status       = EXT_STATUS_ERR;
+           pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+           copy_up_EXT(pext,arg);
+           return(ret);
+       }  
+      /* get spin lock for this operation */
+      spin_lock_irqsave(&io_request_lock, cpu_flags);
+
+      /* Allocate a LUN/DEVICE queue from this request */
+        if( (q = GET_LU_Q(ha, b, t,l)) == NULL ) {
+            DRIVER_LOCK
+            if( (q = qla2100_lun_alloc()) == NULL ) {
+               pext->Status       = EXT_STATUS_ERR;
+               pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+               copy_up_EXT(pext,arg);
+               DEBUG2(printk("[qla2100_ioctl: ERROR in GET_LU_Q for SCSI_PASSTHRU ha=%8x]\n",
+                     (uint32_t)ha);)
+               ret = EXT_STATUS_ERR;
+               return(ret);
+            }
+            LU_Q(ha, b, t, l) = q;
+            DEBUG(sprintf(debug_buff,"Allocate new device queue 0x%x\n",q));
+            DEBUG(qla2100_print(debug_buff));
+            DRIVER_UNLOCK
+        }
+        /* Set an invalid handle until we issue the command to ISP */
+        /* then we will set the real handle value.                 */
+        handle = INVALID_HANDLE;  
+        CMD_HANDLE(pscsi_cmd) = (unsigned char *)handle;
+
+        if( sp->flags ) {
+            sp->port_down_retry_count = ha->port_down_retry_count - 1;
+            sp->retry_count = ha->retry_count; 
+            DEBUG3(sprintf(debug_buff,"qla2100: PT Set retry counts =0x%x,0x%x\n\r",
+                   sp->port_down_retry_count,sp->retry_count));
+            DEBUG3(qla2100_print(debug_buff));
+        }
+        qla2100_putq_t(q,sp); 
+
+        /* set flag to indicate IOCTL SCSI PassThru in progress */
+        ha->IoctlPassThru_InProgress = 1;
+
+        //printk("[start FCSCSI IOCTL restart queues]\n");
+        /* send command to adapter */
+        qla2100_restart_queues(ha,FALSE);
+
+        /* release spin lock since command is queued */  
+        spin_unlock_irqrestore(&io_request_lock, cpu_flags);
+
+        ha->ioctl_timer = 6; /* 6 ticks of 1 second timer max wait */
+
+        /* wait for post function or timer to zero the InProgress flag */
+        while (ha->IoctlPassThru_InProgress == 1) {
+             udelay(35);
+        }
+
+        //printk("[start FCSCSI IOCTL finished while]\n");
+        if (ha->IoctlPassThru_InProgress == 1) {
+          /* We waited and post function did not get called */ 
+          DEBUG(printk("[FCSCSI IOCTL post function not called]\n");)
+          pext->Status       = EXT_STATUS_ERR;
+          pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;   
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_ERR;
+        } else {
+          if (pscsi_pass->Direction == EXT_DEF_SCSI_PASSTHRU_DATA_IN) {
+             /* getting device data and putting in pext->ResponseAdr */
+             ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr ,
+                               pext->ResponseLen); 
+             if (ret) {
+               pext->Status       = EXT_STATUS_ERR;
+               pext->DetailStatus = EXT_STATUS_COPY_ERR;
+               copy_up_EXT(pext,arg);
+               DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE for IOCTL PT ha=%8x]\n",
+                     (uint32_t)ha);)
+               return(ret);
+             }
+             /* now copy up the READ data to user */
+             for (i=0 ; i < pext->ResponseLen ; i++) {
+                usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+                kernel_tmp = (uint8_t *)ha->ioctl_mem + i;
+                /*printk("[%x]",*kernel_tmp);*/
+                __put_user(*kernel_tmp, usr_temp);
+             }
+          }
+          //printk("[[sense0=%x sense2=%x]]\n",
+          //pscsi_cmd->sense_buffer[0],
+          //pscsi_cmd->sense_buffer[2]);
+          /* copy up structure to make sense data available to user */
+          for (i=0;i<16;i++) 
+               pscsi_pass->SenseData[i] = pscsi_cmd->sense_buffer[i];
+          ret = verify_area(VERIFY_WRITE, (void *)pext->RequestAdr,
+                            sizeof(EXT_SCSI_PASSTHRU)); 
+          if (ret) {
+            pext->Status       = EXT_STATUS_ERR;
+            pext->DetailStatus = EXT_STATUS_COPY_ERR;
+            copy_up_EXT(pext,arg);
+            DEBUG2(printk("[qla2100_ioctl: ERROR verify_area WRITE of EXT_SCSI_PASSTHRU]\n");)
+            return(ret);
+          }
+          for (i=0 ; i < sizeof(EXT_SCSI_PASSTHRU) ; i++) {
+            usr_temp   = (uint8_t *)pext->RequestAdr + i;
+            kernel_tmp = (uint8_t *)pscsi_pass + i;
+            __put_user(*kernel_tmp, usr_temp);
+          }
+          /* printk("[finished QLA2100 IOCTL EXT_FCSCSI_REQ]\n"); */ 
+          pext->Status       = EXT_STATUS_SCSI_STATUS;
+          pext->DetailStatus = sp->scode;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+        }
+      break;
+ 
+   case EXT_CC_READ_NVRAM:
+      if (pext->ResponseLen < sizeof(nvram21_t)) transfer_size = pext->ResponseLen;
+      else      transfer_size = sizeof(nvram21_t)/2;
+      for( i = 0, cnt = 0; cnt < transfer_size ; cnt++ , i++ ) {
+          *wptr = qla2100_get_nvram_word(ha, cnt);
+
+          usr_temp    = (uint8_t *)pext->ResponseAdr;
+          kernel_tmp  = (uint8_t *)wptr;
+
+          usr_temp += i; /* even byte */
+          __put_user(*kernel_tmp, usr_temp);
+
+          i++;
+          usr_temp    = (uint8_t *)pext->ResponseAdr;
+          kernel_tmp1 = (uint8_t *)wptr + 1;
+          usr_temp += i; /* odd byte */
+          __put_user(*kernel_tmp1, usr_temp);
+      }
+
+      /* printk("[finished QLA2100 IOCTL EXT_NVR_RD]\n"); */ 
+      pext->Status       = EXT_STATUS_OK;
+      pext->DetailStatus = EXT_STATUS_OK;
+      copy_up_EXT(pext,arg);
+      ret = EXT_STATUS_OK;
+      break;
+
+    case EXT_CC_LOOPBACK:
+    DEBUG(sprintf(debug_buff,"qla2100_ioctl: start EXT_CC_LOOPBACK\n"));
+    DEBUG(qla2100_print(debug_buff));
+
+    /* printk("[start EXT_CC_LOOPBACK]\n"); */
+
+    if (ha->device_id == QLA2100_DEVICE_ID) {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+        copy_up_EXT(pext,arg);
+        DEBUG2(printk("[EXT_CC_SEND_LOOP_BACK not supported on QLA2100]\n");)
+        return(ret);
+    }
+
+      if (pext->ResponseLen > PAGE_SIZE)  pext->ResponseLen = PAGE_SIZE;
+      if (pext->RequestLen  > PAGE_SIZE)  {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_INVALID_PARAM;
+        copy_up_EXT(pext,arg);
+        /*printk("[EXT_CC_LOOPBACK too big ResponseLen=%x ReqLen=%x]\n",pext->ResponseLen,pext->RequestLen); */
+        DEBUG2(printk("[qla2100_ioctl: ERROR size of requested Resp_len in EXT_CC_SEND_LOOP_BACK]\n");)
+        return(ret);
+      }
+      ret = verify_area(VERIFY_READ, (void *)pext->RequestAdr,
+                        pext->RequestLen); 
+      if (ret){
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_COPY_ERR;
+        copy_up_EXT(pext,arg);
+        /*printk("[EXT_CC_LOOPBACK verify read error]\n");*/ 
+        DEBUG2(printk("[qla2100_ioctl: ERROR verify_area READ of EXT_CC_LOOPBACK]\n");)
+        return(ret);
+      }
+      for (i=0 ; i < pext->ResponseLen ; i++) {
+        /* copy in from user space the user data pattern to be sent */
+        usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+        kernel_tmp = (uint8_t *)ha->ioctl_mem + i;
+        __get_user(*kernel_tmp, usr_temp);
+	/*  printk("{%x}",*kernel_tmp); */ 
+      }
+      /* check on loop down */
+      if ( ha->loop_down_timer == 0 && ha->loop_state == LOOP_DOWN)  {
+        pext->Status       = EXT_STATUS_ERR;
+        pext->DetailStatus = EXT_STATUS_DEV_NOT_FOUND;
+        copy_up_EXT(pext,arg);
+        /* printk("[EXT_CC_LOOPBACK loop down]\n"); */
+        return(ret);
+      }
+
+      /* get spin lock for this operation */
+      spin_lock_irqsave(&io_request_lock, cpu_flags);
+
+      mb[0] = MBC_DIAGNOSTIC_LOOP_BACK;
+      mb[1] = 0x72; /* options: 64 bit, use buffer for snd/rcv on ext. loop */
+      mb[2] = mb[3] = mb[4] = mb[5] = mb[6] = mb[7] = mb[8] = mb[9] = 0;
+      mb[10] = LSW(pext->ResponseLen);
+      mb[11] = MSW(pext->ResponseLen);
+      mb[12] = 0; /* transfer segment count */
+      mb[13] = 0; /* receive segment count */
+      mb[14] = LSW(ha->ioctl_mem_phys); /* send data address */
+      mb[15] = MSW(ha->ioctl_mem_phys);
+      mb[20] = QL21_64BITS_3RDWD(ha->ioctl_mem_phys);
+      mb[21] = QL21_64BITS_4THWD(ha->ioctl_mem_phys);
+      mb[16] = LSW(ha->ioctl_mem_phys); /* recv data address */
+      mb[17] = MSW(ha->ioctl_mem_phys);
+      mb[6]  = QL21_64BITS_3RDWD(ha->ioctl_mem_phys);
+      mb[7]  = QL21_64BITS_4THWD(ha->ioctl_mem_phys); 
+      mb[18] = 1; /* iteration count lsb */
+      mb[19] = 0; /* iteration count msb */
+
+      DEBUG(sprintf(debug_buff,
+            "LoopBack ioctl: issue loop back mailbox command\n"));
+      DEBUG(qla2100_print(debug_buff));
+
+      // wait for 64 bit loopback ready firmware
+      status = qla2100_mailbox_command(ha,BIT_21|BIT_20|BIT_19|BIT_18|
+                                       BIT_17|BIT_16|BIT_15|BIT_14|
+                                       BIT_13|BIT_12|BIT_11|
+                                       BIT_10|BIT_7|BIT_6|BIT_1|BIT_0,
+                                       &mb[0]);
+
+      /* release spin lock since command is issued */  
+      spin_unlock_irqrestore(&io_request_lock, cpu_flags);
+
+        if (status) {
+          DEBUG(sprintf(debug_buff,
+           "LoopBack ioctl: issue loop back mailbox command FAILED\n"));
+          DEBUG(qla2100_print(debug_buff));
+          pext->Status       = EXT_STATUS_ERR;
+          pext->DetailStatus = EXT_STATUS_ERR;   
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_ERR;
+        } else {
+             /* put looped back data in pext->ResponseAdr */
+             /* printk("[LoopBack ioctl: LoopBack was OK ]\n");*/
+             ret = verify_area(VERIFY_WRITE, (void *)pext->ResponseAdr ,
+                               pext->ResponseLen); 
+             if (ret) {
+               pext->Status       = EXT_STATUS_ERR;
+               pext->DetailStatus = EXT_STATUS_COPY_ERR;
+               copy_up_EXT(pext,arg);
+               DEBUG2(printk("[LoopBack ioctl: ERROR verify_area WRITE ha=%x]\n",
+                     (uint32_t)ha);)
+               return(ret);
+             }
+             /* sending back looped back data */
+             for (i=0 ; i < pext->ResponseLen ; i++) {
+                usr_temp   = (uint8_t *)pext->ResponseAdr + i;
+                kernel_tmp = (uint8_t *)ha->ioctl_mem + i;
+                /*printk("[%x]",*kernel_tmp);*/
+                __put_user(*kernel_tmp, usr_temp);
+             }
+          /*printk("[finished QLA2100 IOCTL EXT_CC_LOOPBACK]\n");*/
+          pext->Status       = EXT_STATUS_OK;
+          pext->DetailStatus = EXT_STATUS_OK;
+          copy_up_EXT(pext,arg);
+          ret = EXT_STATUS_OK;
+        }
+      break;
+
+/* case EXT_CC_RSCN_REG:
+      break;
+    case EXT_CC_RSCN_GET:
+      break; 
+    case EXT_CC_ELS_RNID_SEND:
+      break;
+    case EXT_CC_ELS_RTIN_SEND:
+      break;
+    case EXT_CC_PLATFORM_REG:
+      break;
+
+all others go here */
+
+    default:
+      break;
+  }
+
+  return(ret);
+}
+
diff -urN linux.orig/drivers/scsi/qlavendor.c linux/drivers/scsi/qlavendor.c
--- linux.orig/drivers/scsi/qlavendor.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/qlavendor.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,325 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP2x00 device driver for Linux 2.2.x (redhat 6.X).
+*
+* COPYRIGHT (C) 2000 QLOGIC CORPORATION
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the Qlogic's Linux Software License. See below.
+*
+* This program is WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistribution's or source code must retain the above copyright
+*    notice, this list of conditions, and the following disclaimer,
+*    without modification, immediately at the beginning of the file.
+* 2. The name of the author may not be used to endorse or promote products
+*    derived from this software without specific prior written permission.
+*
+********************************************************************************/
+
+/*****************************************************************************************
+                       QLOGIC CORPORATION SOFTWARE
+                      "GNU" GENERAL PUBLIC LICENSE
+             TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION
+                            AND MODIFICATION
+
+This GNU General Public License ("License") applies solely to QLogic Linux
+Software ("Software") and may be distributed under the terms of this License.
+
+1. You may copy and distribute verbatim copies of the Software's source code as
+you receive it, in any medium, provided that you conspicuously and appropriately
+publish on each copy an appropriate copyright notice and disclaimer of warranty;
+keep intact all the notices that refer to this License and to the absence of any
+warranty; and give any other recipients of the Software a copy of this License along
+with the Software.
+
+You may charge a fee for the physical act of transferring a copy, and you may at your
+option offer warranty protection in exchange for a fee.
+
+2. You may modify your copy or copies of the Software or any portion of it, thus forming
+a work based on the Software, and copy and distribute such modifications or work under
+the terms of Section 1 above, provided that you also meet all of these conditions:
+
+* a) You must cause the modified files to carry prominent notices stating that you
+changed the files and the date of any change.
+
+* b) You must cause any work that you distribute or publish that in whole or in part
+contains or is derived from the Software or any part thereof, to be licensed as a
+whole at no charge to all third parties under the terms of this License.
+
+* c) If the modified Software normally reads commands interactively when run, you
+must cause it, when started running for such interactive use in the most ordinary way,
+to print or display an announcement including an appropriate copyright notice and a
+notice that there is no warranty (or else, saying that you provide a warranty) and that
+users may redistribute the Software under these conditions, and telling the user how to
+view a copy of this License. (Exception:if the Software itself is interactive but does
+not normally print such an announcement, your work based on the Software is not required
+to print an announcement.)
+
+These requirements apply to the modified work as a whole. If identifiable sections of
+that work are not derived from the Software, and can be reasonably considered independent
+and separate works in themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works. But when you distribute the same
+sections as part of a whole which is a work based on the Software, the distribution of the
+whole must be on the terms of this License, whose permissions for other licensees extend
+to the entire whole, and thus to each and every part regardless of who wrote it.
+
+3. You may copy and distribute the Software (or a work based on it, under Section 2) in
+object code or executable form under the terms of Sections 1 and 2 above provided that
+you also do one of the following:
+
+* a) Accompany it with the complete corresponding machine-readable source code, which must
+be distributed under the terms of Sections 1 and 2 above on a medium customarily used for
+software interchange; or,
+
+* b) Accompany it with a written offer, valid for at least three years, to give any third
+party, for a charge no more than your cost of physically performing source distribution,
+a complete machine-readable copy of the corresponding source code, to be distributed under
+the terms of Sections 1 and 2 above on a medium customarily used for software interchange;
+or,
+
+* c) Accompany it with the information you received as to the offer to distribute
+corresponding source code. (This alternative is allowed only for noncommercial distribution
+and only if you received the Software in object code or executable form with such an offer,
+in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for making modifications
+to it. For an executable work, complete source code means all the source code for all
+modules it contains, plus any associated interface definition files, plus the scripts used
+to control compilation and installation of the executable.
+
+If distribution of executable or object code is made by offering access to copy from a
+designated place, then offering equivalent access to copy the source code from the same
+place counts as distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+4. You may not copy, modify, sublicense, or distribute the Software except as expressly
+provided under this License. Any attempt otherwise to copy, modify, sublicense or
+distribute the Software is void, and will automatically terminate your rights under this
+License. However, parties who have received copies, or rights, from you under this License
+will not have their licenses terminated so long as such parties remain in full compliance.
+
+5. This license grants you world wide, royalty free non-exclusive rights to modify or
+distribute the Software or its derivative works. These actions are prohibited by law
+if you do not accept this License. Therefore, by modifying or distributing the Software
+(or any work based on the Software), you indicate your acceptance of this License to do
+so, and all its terms and conditions for copying, distributing or modifying the Software
+or works based on it.
+
+6. Each time you redistribute the Software (or any work based on the Software), the
+recipient automatically receives a license from the original licensor to copy, distribute
+or modify the Software subject to these terms and conditions. You may not impose any
+further restrictions on the recipients' exercise of the rights granted herein. You are
+not responsible for enforcing compliance by third parties to this License.
+
+7. If, as a consequence of a court judgment or allegation of patent infringement or for
+any other reason (not limited to patent issues), conditions are imposed on you
+(whether by court order, agreement or otherwise) that contradict the conditions of this
+License, they do not excuse you from the conditions of this License. If you cannot
+distribute so as to satisfy simultaneously your obligations under this License
+and any other pertinent obligations, then as a consequence you may not distribute the
+Software at all.
+
+If any portion of this section is held invalid or unenforceable under any particular
+circumstance, the balance of the section is intended to apply and the section as a whole
+is intended to apply in other circumstances.
+NO WARRANTY
+
+11. THE SOFTWARE IS PROVIDEDWITHOUT A WARRANTY OF ANY KIND. THERE IS NO
+WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
+EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
+ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU.
+SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
+NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE SOFTWARE AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
+DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
+DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING
+BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
+LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO
+OPERATE WITH ANY OTHER SOFTWARES), EVEN IF SUCH HOLDER OR OTHER PARTY HAS
+BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+END OF TERMS AND CONDITIONS
+
+******************************************************************************/
+/*
+ * vendor specific op codes.
+*/
+
+#define	UCSCSI_DCMD			0x20 /* DAC960 direct command */
+#define UCSCSI_DCMD_PASSTHRU		0x21 /* DAC960 pass-through command */
+#define	UC_SCSI_DCMD			0x22 /* DAC960 FSI direct command */
+#define DAC_CDB_LEN			12
+#define DAC_SENSE_LEN			64
+
+#define SCSI_WRITE10			0x2A	/* Required for direct disk writes */
+#define SCSI_WRITE6			0x0A	/* Required for direct disk writes */
+#define SCSI_WRITEBUFFER		0x3B	/* Required for flashing disk FW */
+#define DACMD_WRITE_CONF_ONDISK		0x4B
+#define	DACMD_WRITE_CONFIG		0x06
+#define	DACMD_WRITE_CONF2		0x3C
+#define	DACMD_WRITE_CONFLABEL		0x49 /* Write configuration label */
+#define	DACMD_WRITE_CONFIG_V3x		0x4F
+#define	DACMD_ADD_CONFIG_V2x		0x18
+#define	DACMD_ADD_CONFIG_V3x		0x4C
+#define	DACMD_STORE_IMAGE		0x21
+#define	DACMD_ADD_CAPACITY		0x2A /* add physical drives to existing array */
+#define	DACMD_WRITE_IOPORT		0x3A /* write port B */
+#define	DACMD_S2S_WRITEFULLCONF		0x60 /* write full configuration */
+#define	DACMD_S2S_ADDFULLCONF		0x62 /* add   full configuration */
+#define	DACMD_S2S_WRITELUNMAP_OLD	0x58 /* write LUN map information */
+#define DACMD_S2S_WRITELUNMAP		0xD2 /* Write LUN MAP Information */
+#define	DACMD_S2S_WRITE_IOPORT		0x66 /* write expanded IO port */
+#define	DACMD_WRITE_V3x			0x34 /* write data from plain memory */
+#define	DACMD_S2S_WRITESIG		0x4D /* write signature information */
+
+#define MDACIOCTL_STOREIMAGE		0x2C /* Store the softeware image on controller */
+#define MDACIOCTL_WRITESIGNATURE	0xA6 /* Write Controller Signature */
+#define MDACIOCTL_SETREALTIMECLOCK	0xAC /* Set real time clock value */
+#define MDACIOCTL_PASS_THRU_CDB		0xAD /* Set up a pass-through command */
+#define MDACIOCTL_PASS_THRU_INITIATE	0xAE /* Initiates a pass-through read/write command (bi-directional) */
+#define MDACIOCTL_CREATENEWCONF		0xC0 /* Create new configruation */
+#define MDACIOCTL_ADDNEWCONF		0xC4 /* Add new logical/physical device to configruation */
+#define MDACIOCTL_MORE			0xC6 /* Do MORE operation */
+#define MDACIOCTL_SETPHYSDEVPARAMETER	0xC8 /* Set physical device parameters */
+#define MDACIOCTL_SETLOGDEVPARAMETER	0xCF /* Set logical device parameters */
+#define MDACIOCTL_SETCONTROLLERPARAMTER	0xD1 /* Set controller parameter */
+#define MDACIOCTL_WRITESANMAP		0xD4 /* Set logical device LUN map */
+#define MDACIOCTL_SETMACADDRESS		0xD5 /* Set controller MAC address */
+
+    /*
+    * qla2100_set_scsi_direction
+    *      This routine will set the proper direction for vendor specific
+    *      commands. 
+    *
+    *      Note: Vendors should modify this routine to set the proper 
+    *      direction of the transfer if they used vendor specific commands.
+    *
+    * Input:
+    *      ha = adapter block pointer.
+    *      sp = SCSI Request Block structure pointer.
+    *
+    * Returns:
+    *      0 = success, was able to issue command.
+    */
+
+     void qla2100_set_vend_direction(scsi_qla_host_t *ha, 
+ 			Scsi_Cmnd       *cmd, cmd_entry_t     *pkt) {
+			/* This section added 10-JAN-2001 by Lethe. Required to facilitate SCSI
+			   pass-through for flashing disk firmware, and direct disk writes under
+			   Mylex 6.x and 5.x Firmware */
+           	if( cmd->data_cmnd[0] == UCSCSI_DCMD_PASSTHRU) {
+				pkt->control_flags = 0;
+				switch (cmd->data_cmnd[2]) {
+						case SCSI_WRITE6:
+						case SCSI_WRITE10:
+						case SCSI_WRITEBUFFER:
+							pkt->control_flags |= BIT_6;
+							break;
+						default:
+							pkt->control_flags |= BIT_5;
+			    }
+			} 
+			else if( cmd->data_cmnd[0] == UCSCSI_DCMD )
+			{
+			    pkt->control_flags = 0;
+			    switch( cmd->data_cmnd[2] )
+			    {
+				case DACMD_WRITE_CONF_ONDISK:
+				case DACMD_WRITE_CONFIG:
+				case DACMD_WRITE_CONF2:
+				case DACMD_WRITE_CONFLABEL:
+				case DACMD_WRITE_CONFIG_V3x:
+				case DACMD_ADD_CONFIG_V2x:
+				case DACMD_ADD_CONFIG_V3x:
+				case DACMD_STORE_IMAGE:
+				case DACMD_ADD_CAPACITY:
+				case DACMD_WRITE_IOPORT:
+				case DACMD_S2S_WRITEFULLCONF:
+				case DACMD_S2S_ADDFULLCONF:
+				case DACMD_S2S_WRITELUNMAP_OLD:
+				case DACMD_S2S_WRITELUNMAP:
+				case DACMD_S2S_WRITE_IOPORT:
+				case DACMD_WRITE_V3x:
+				case DACMD_S2S_WRITESIG:
+					pkt->control_flags |= BIT_6;
+					break;
+				default:
+					pkt->control_flags |= BIT_5;
+			    }
+			}
+
+/*******************************************************************************************
+* The below logic is required to operate correctly with Mylex (IBM's) DAC960 family of     *
+* external RAID controllers.                                                               *
+*                                                                                          *
+* In addition to defining whether below CDBs are Reads or Writes, Mylex, in their infinite *
+* wisdom, defined a vendor-specific CDB which can act as a Read OR a write, depending on   *
+* the parameters sent in a previous MDACIOCTL_PASS_THRU_CDB.  Instead of adding a lot of   *
+* logic to define and maintain a MDACIOCTL_PASS_THRU_CDB queue, and parse each one of them *
+* to determine direction, I took easy way out (also the low-overhead method).              *
+*                                                                                          *
+* If the high-order bit of the 32-bit UniqueID, defined in byte 3 of data_cmnd[3] is set   *
+* then I will mark that as a CDB which is going to be a write, otherwise the pass thru     *
+* operation will be a read. If somebody wishes to rewrite the driver to maintain a 30-sec  *
+* command queue, and parse the contents of each data buffer passed in to determine R or W  *
+* then they are free to do so, and it will not impact future versions of the Distributed   *
+* Array Manager, which required this fix in the first place.                               *
+*                                                                                          *
+* This configurator and patch was written by David A. Lethe of Xyratex david@santools.com. *
+* In addition, the logic to check cmd->data_cmnd[0] == UC_SCSI_DCMD, was written by        *
+* Sammy Wilborn of Silicon Graphics, Inc, and David Lethe                                  *
+* They define CDBs used by the DAC960FF family, when running FW 7.x and above.             *
+*                                                                                          *
+*******************************************************************************************/
+
+			else if ( cmd->data_cmnd[0] == UC_SCSI_DCMD ) /* Mylex DAC960 FW 7.x */
+			{
+			    pkt->control_flags = 0;
+			    switch( cmd->data_cmnd[2] )
+			    {
+				case MDACIOCTL_STOREIMAGE:
+				case MDACIOCTL_SETREALTIMECLOCK:
+				case MDACIOCTL_WRITESIGNATURE:
+			        case MDACIOCTL_CREATENEWCONF:
+			        case MDACIOCTL_ADDNEWCONF:
+			        case MDACIOCTL_MORE:
+			        case MDACIOCTL_SETPHYSDEVPARAMETER:
+			        case MDACIOCTL_SETLOGDEVPARAMETER:
+			        case MDACIOCTL_SETCONTROLLERPARAMTER:
+			        case MDACIOCTL_WRITESANMAP:
+			        case MDACIOCTL_SETMACADDRESS:
+				case MDACIOCTL_PASS_THRU_CDB:
+					pkt->control_flags |= BIT_6;
+					break;
+				default:
+					if (cmd->data_cmnd[2] == MDACIOCTL_PASS_THRU_INITIATE) {
+					/* If the high bit of the UniqueID field of the vendor-
+					   specific field is TRUE, then it is marked as a write. */
+						if (cmd->data_cmnd[3] & 0x80)
+							pkt->control_flags |= BIT_6;
+						else
+							pkt->control_flags |= BIT_5;
+					}
+					else
+						pkt->control_flags |= BIT_5;
+					break;
+			    }
+			}
+			else
+			{
+                       		pkt->control_flags |= BIT_5;
+			}
+
+    }
diff -urN linux.orig/drivers/scsi/scsi_ioctl.c linux/drivers/scsi/scsi_ioctl.c
--- linux.orig/drivers/scsi/scsi_ioctl.c	Wed Aug 15 02:22:16 2001
+++ linux/drivers/scsi/scsi_ioctl.c	Mon Dec 17 20:27:41 2001
@@ -198,6 +198,9 @@
 	unsigned int needed, buf_needed;
 	int timeout, retries, result;
 	int data_direction;
+#if __GNUC__ < 3
+        int foo;
+#endif
 
 	if (!sic)
 		return -EINVAL;
@@ -207,12 +210,21 @@
 	if (verify_area(VERIFY_READ, sic, sizeof(Scsi_Ioctl_Command)))
 		return -EFAULT;
 
-	if(__get_user(inlen, &sic->inlen))
+#if __GNUC__ < 3
+        foo = __get_user(inlen, &sic->inlen);
+	if(foo)
 		return -EFAULT;
 		
-	if(__get_user(outlen, &sic->outlen))
+        foo = __get_user(outlen, &sic->outlen);
+	if(foo)
+		return -EFAULT;
+#else
+	if(__get_user(inlen, &sic->inlen))
 		return -EFAULT;
 
+	if(__get_user(outlen, &sic->outlen))
+		return -EFAULT;
+#endif
 	/*
 	 * We do not transfer more than MAX_BUF with this interface.
 	 * If the user needs to transfer more data than this, they
diff -urN linux.orig/drivers/scsi/simscsi.c linux/drivers/scsi/simscsi.c
--- linux.orig/drivers/scsi/simscsi.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/simscsi.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,382 @@
+/*
+ * Simulated SCSI driver.
+ *
+ * Copyright (C) 1999, 2001 Hewlett-Packard Co
+ * Copyright (C) 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1999 Stephane Eranian <eranian@hpl.hp.com>
+ *
+ * 99/12/18 David Mosberger	Added support for READ10/WRITE10 needed by linux v2.3.33
+ */
+#include <linux/config.h>
+#include <linux/blk.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+
+#include <scsi/scsi.h>
+
+#include <asm/irq.h>
+
+#include "scsi.h"
+#include "sd.h"
+#include "hosts.h"
+#include "simscsi.h"
+
+#define DEBUG_SIMSCSI	1
+
+/* Simulator system calls: */
+
+#define SSC_OPEN			50
+#define SSC_CLOSE			51
+#define SSC_READ			52
+#define SSC_WRITE			53
+#define SSC_GET_COMPLETION		54
+#define SSC_WAIT_COMPLETION		55
+
+#define SSC_WRITE_ACCESS		2
+#define SSC_READ_ACCESS			1
+
+#ifdef DEBUG_SIMSCSI
+  int simscsi_debug;
+# define DBG	simscsi_debug
+#else
+# define DBG	0
+#endif
+
+#if 0
+struct timer_list disk_timer;
+#else
+static void simscsi_interrupt (unsigned long val);
+DECLARE_TASKLET(simscsi_tasklet, simscsi_interrupt, 0);
+#endif
+
+struct disk_req {
+	unsigned long addr;
+	unsigned len;
+};
+
+struct disk_stat {
+	int fd;
+	unsigned count;
+};
+
+extern long ia64_ssc (long arg0, long arg1, long arg2, long arg3, int nr);
+
+static int desc[8] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+
+static struct queue_entry {
+	Scsi_Cmnd *sc;
+} queue[SIMSCSI_REQ_QUEUE_LEN];
+
+static int rd, wr;
+static atomic_t num_reqs = ATOMIC_INIT(0);
+
+/* base name for default disks */
+static char *simscsi_root = DEFAULT_SIMSCSI_ROOT;
+
+#define MAX_ROOT_LEN	128
+
+/*
+ * used to setup a new base for disk images
+ * to use /foo/bar/disk[a-z] as disk images
+ * you have to specify simscsi=/foo/bar/disk on the command line
+ */
+static int __init
+simscsi_setup (char *s)
+{
+	/* XXX Fix me we may need to strcpy() ? */
+	if (strlen(s) > MAX_ROOT_LEN) {
+		printk("simscsi_setup: prefix too long---using default %s\n", simscsi_root);
+	}
+	simscsi_root = s;
+	return 1;
+}
+
+__setup("simscsi=", simscsi_setup);
+
+static void
+simscsi_interrupt (unsigned long val)
+{
+	unsigned long flags;
+	Scsi_Cmnd *sc;
+
+	spin_lock_irqsave(&io_request_lock, flags);
+	{
+		while ((sc = queue[rd].sc) != 0) {
+			atomic_dec(&num_reqs);
+			queue[rd].sc = 0;
+			if (DBG)
+				printk("simscsi_interrupt: done with %ld\n", sc->serial_number);
+			(*sc->scsi_done)(sc);
+			rd = (rd + 1) % SIMSCSI_REQ_QUEUE_LEN;
+		}
+	}
+	spin_unlock_irqrestore(&io_request_lock, flags);
+}
+
+int
+simscsi_detect (Scsi_Host_Template *templ)
+{
+	templ->proc_name = "simscsi";
+#if 0
+	init_timer(&disk_timer);
+	disk_timer.function = simscsi_interrupt;
+#endif
+	return 1;	/* fake one SCSI host adapter */
+}
+
+int
+simscsi_release (struct Scsi_Host *host)
+{
+	return 0;	/* this is easy...  */
+}
+
+const char *
+simscsi_info (struct Scsi_Host *host)
+{
+	return "simulated SCSI host adapter";
+}
+
+int
+simscsi_abort (Scsi_Cmnd *cmd)
+{
+	printk ("simscsi_abort: unimplemented\n");
+	return SCSI_ABORT_SUCCESS;
+}
+
+int
+simscsi_reset (Scsi_Cmnd *cmd, unsigned int reset_flags)
+{
+	printk ("simscsi_reset: unimplemented\n");
+	return SCSI_RESET_SUCCESS;
+}
+
+int
+simscsi_biosparam (Disk *disk, kdev_t n, int ip[])
+{
+	int size = disk->capacity;
+
+	ip[0] = 64;
+	ip[1] = 32;
+	ip[2] = size >> 11;
+	return 0;
+}
+
+static void
+simscsi_readwrite (Scsi_Cmnd *sc, int mode, unsigned long offset, unsigned long len)
+{
+	struct disk_stat stat;
+	struct disk_req req;
+
+	req.addr = __pa(sc->request_buffer);
+	req.len  = len;			/* # of bytes to transfer */
+
+	if (sc->request_bufflen < req.len)
+		return;
+
+	stat.fd = desc[sc->target];
+	if (DBG)
+		printk("simscsi_%s @ %lx (off %lx)\n",
+		       mode == SSC_READ ? "read":"write", req.addr, offset);
+	ia64_ssc(stat.fd, 1, __pa(&req), offset, mode);
+	ia64_ssc(__pa(&stat), 0, 0, 0, SSC_WAIT_COMPLETION);
+
+	if (stat.count == req.len) {
+		sc->result = GOOD;
+	} else {
+		sc->result = DID_ERROR << 16;
+	}
+}
+
+static void
+simscsi_sg_readwrite (Scsi_Cmnd *sc, int mode, unsigned long offset)
+{
+	int list_len = sc->use_sg;
+	struct scatterlist *sl = (struct scatterlist *)sc->buffer;
+	struct disk_stat stat;
+	struct disk_req req;
+
+	stat.fd = desc[sc->target];
+
+	while (list_len) {
+		req.addr = __pa(sl->address);
+		req.len  = sl->length;
+		if (DBG)
+			printk("simscsi_sg_%s @ %lx (off %lx) use_sg=%d len=%d\n",
+			       mode == SSC_READ ? "read":"write", req.addr, offset,
+			       list_len, sl->length);
+		ia64_ssc(stat.fd, 1, __pa(&req), offset, mode);
+		ia64_ssc(__pa(&stat), 0, 0, 0, SSC_WAIT_COMPLETION);
+
+		/* should not happen in our case */
+		if (stat.count != req.len) {
+			sc->result = DID_ERROR << 16;
+			return;
+		}
+		offset +=  sl->length;
+		sl++;
+		list_len--;
+	}
+	sc->result = GOOD;
+}
+
+/*
+ * function handling both READ_6/WRITE_6 (non-scatter/gather mode)
+ * commands.
+ * Added 02/26/99 S.Eranian
+ */
+static void
+simscsi_readwrite6 (Scsi_Cmnd *sc, int mode)
+{
+	unsigned long offset;
+
+	offset = (((sc->cmnd[1] & 0x1f) << 16) | (sc->cmnd[2] << 8) | sc->cmnd[3])*512;
+	if (sc->use_sg > 0)
+		simscsi_sg_readwrite(sc, mode, offset);
+	else
+		simscsi_readwrite(sc, mode, offset, sc->cmnd[4]*512);
+}
+
+
+static void
+simscsi_readwrite10 (Scsi_Cmnd *sc, int mode)
+{
+	unsigned long offset;
+
+	offset = (  (sc->cmnd[2] << 24) | (sc->cmnd[3] << 16)
+		  | (sc->cmnd[4] <<  8) | (sc->cmnd[5] <<  0))*512;
+	if (sc->use_sg > 0)
+		simscsi_sg_readwrite(sc, mode, offset);
+	else
+		simscsi_readwrite(sc, mode, offset, ((sc->cmnd[7] << 8) | sc->cmnd[8])*512);
+}
+
+int
+simscsi_queuecommand (Scsi_Cmnd *sc, void (*done)(Scsi_Cmnd *))
+{
+	char fname[MAX_ROOT_LEN+16];
+	char *buf;
+#if DEBUG_SIMSCSI
+	register long sp asm ("sp");
+
+	if (DBG)
+		printk("simscsi_queuecommand: target=%d,cmnd=%u,sc=%lu,sp=%lx,done=%p\n",
+		       sc->target, sc->cmnd[0], sc->serial_number, sp, done);
+#endif
+
+	sc->result = DID_BAD_TARGET << 16;
+	sc->scsi_done = done;
+	if (sc->target <= 7 && sc->lun == 0) {
+		switch (sc->cmnd[0]) {
+		      case INQUIRY:
+			if (sc->request_bufflen < 35) {
+				break;
+			}
+			sprintf (fname, "%s%c", simscsi_root, 'a' + sc->target);
+			desc[sc->target] = ia64_ssc (__pa(fname), SSC_READ_ACCESS|SSC_WRITE_ACCESS,
+						     0, 0, SSC_OPEN);
+			if (desc[sc->target] < 0) {
+				/* disk doesn't exist... */
+				break;
+			}
+			buf = sc->request_buffer;
+			buf[0] = 0;	/* magnetic disk */
+			buf[1] = 0;	/* not a removable medium */
+			buf[2] = 2;	/* SCSI-2 compliant device */
+			buf[3] = 2;	/* SCSI-2 response data format */
+			buf[4] = 31;	/* additional length (bytes) */
+			buf[5] = 0;	/* reserved */
+			buf[6] = 0;	/* reserved */
+			buf[7] = 0;	/* various flags */
+			memcpy(buf + 8, "HP      SIMULATED DISK  0.00",  28);
+			sc->result = GOOD;
+			break;
+
+		      case TEST_UNIT_READY:
+			sc->result = GOOD;
+			break;
+
+		      case READ_6:
+			if (desc[sc->target] < 0 )
+				break;
+			simscsi_readwrite6(sc, SSC_READ);
+			break;
+
+		      case READ_10:
+			if (desc[sc->target] < 0 )
+				break;
+			simscsi_readwrite10(sc, SSC_READ);
+			break;
+
+		      case WRITE_6:
+			if (desc[sc->target] < 0)
+				break;
+			simscsi_readwrite6(sc, SSC_WRITE);
+			break;
+
+		      case WRITE_10:
+			if (desc[sc->target] < 0)
+				break;
+			simscsi_readwrite10(sc, SSC_WRITE);
+			break;
+
+
+		      case READ_CAPACITY:
+			if (desc[sc->target] < 0 || sc->request_bufflen < 8) {
+				break;
+			}
+			buf = sc->request_buffer;
+
+			/* pretend to be a 1GB disk (partition table contains real stuff): */
+			buf[0] = 0x00;
+			buf[1] = 0x1f;
+			buf[2] = 0xff;
+			buf[3] = 0xff;
+			/* set block size of 512 bytes: */
+			buf[4] = 0;
+			buf[5] = 0;
+			buf[6] = 2;
+			buf[7] = 0;
+			sc->result = GOOD;
+			break;
+
+		      case MODE_SENSE:
+			printk("MODE_SENSE\n");
+			break;
+
+		      case START_STOP:
+			printk("START_STOP\n");
+			break;
+
+		      default:
+			panic("simscsi: unknown SCSI command %u\n", sc->cmnd[0]);
+		}
+	}
+	if (sc->result == DID_BAD_TARGET) {
+		sc->result |= DRIVER_SENSE << 24;
+		sc->sense_buffer[0] = 0x70;
+		sc->sense_buffer[2] = 0x00;
+	}
+	if (atomic_read(&num_reqs) >= SIMSCSI_REQ_QUEUE_LEN) {
+		panic("Attempt to queue command while command is pending!!");
+	}
+	atomic_inc(&num_reqs);
+	queue[wr].sc = sc;
+	wr = (wr + 1) % SIMSCSI_REQ_QUEUE_LEN;
+
+#if 0
+	if (!timer_pending(&disk_timer)) {
+		disk_timer.expires = jiffies;
+		add_timer(&disk_timer);
+	}
+#else
+	tasklet_schedule(&simscsi_tasklet);
+#endif
+	return 0;
+}
+
+
+static Scsi_Host_Template driver_template = SIMSCSI;
+
+#include "scsi_module.c"
diff -urN linux.orig/drivers/scsi/simscsi.h linux/drivers/scsi/simscsi.h
--- linux.orig/drivers/scsi/simscsi.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/scsi/simscsi.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,39 @@
+/*
+ * Simulated SCSI driver.
+ *
+ * Copyright (C) 1999 Hewlett-Packard Co
+ * Copyright (C) 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ */
+#ifndef SIMSCSI_H
+#define SIMSCSI_H
+
+#define SIMSCSI_REQ_QUEUE_LEN	64
+
+#define DEFAULT_SIMSCSI_ROOT	"/var/ski-disks/sd"
+
+extern int simscsi_detect (Scsi_Host_Template *);
+extern int simscsi_release (struct Scsi_Host *);
+extern const char *simscsi_info (struct Scsi_Host *);
+extern int simscsi_queuecommand (Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
+extern int simscsi_abort (Scsi_Cmnd *);
+extern int simscsi_reset (Scsi_Cmnd *, unsigned int);
+extern int simscsi_biosparam (Disk *, kdev_t, int[]);
+
+#define SIMSCSI {					\
+	detect:			simscsi_detect,		\
+	release:		simscsi_release,	\
+	info:			simscsi_info,		\
+	queuecommand:		simscsi_queuecommand,	\
+	abort:			simscsi_abort,		\
+	reset:			simscsi_reset,		\
+	bios_param:		simscsi_biosparam,	\
+	can_queue:		SIMSCSI_REQ_QUEUE_LEN,	\
+	this_id:		-1,			\
+	sg_tablesize:		SG_ALL,			\
+	cmd_per_lun:		SIMSCSI_REQ_QUEUE_LEN,	\
+	present:		0,			\
+	unchecked_isa_dma:	0,			\
+	use_clustering:		DISABLE_CLUSTERING	\
+}
+
+#endif /* SIMSCSI_H */
diff -urN linux.orig/drivers/sound/cs4281/cs4281m.c linux/drivers/sound/cs4281/cs4281m.c
--- linux.orig/drivers/sound/cs4281/cs4281m.c	Sun Aug 12 11:51:41 2001
+++ linux/drivers/sound/cs4281/cs4281m.c	Mon Dec 17 20:27:41 2001
@@ -1942,8 +1942,8 @@
 		len -= x;
 	}
 	CS_DBGOUT(CS_WAVE_WRITE, 4, printk(KERN_INFO
-		"cs4281: clear_advance(): memset %d at 0x%.8x for %d size \n",
-			(unsigned)c, (unsigned)((char *) buf) + bptr, len));
+		"cs4281: clear_advance(): memset %d at %p for %d size \n",
+			(unsigned)c, ((char *) buf) + bptr, len));
 	memset(((char *) buf) + bptr, c, len);
 }
 
@@ -1978,9 +1978,8 @@
 				wake_up(&s->dma_adc.wait);
 		}
 		CS_DBGOUT(CS_PARMS, 8, printk(KERN_INFO
-			"cs4281: cs4281_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d \n",
-				(unsigned)s, s->dma_adc.hwptr, 
-				s->dma_adc.total_bytes, s->dma_adc.count));
+			"cs4281: cs4281_update_ptr(): s=%p hwptr=%d total_bytes=%d count=%d \n",
+				s, s->dma_adc.hwptr, s->dma_adc.total_bytes, s->dma_adc.count));
 	}
 	// update DAC pointer 
 	//
@@ -2012,11 +2011,10 @@
 				// Continue to play silence until the _release.
 				//
 				CS_DBGOUT(CS_WAVE_WRITE, 6, printk(KERN_INFO
-					"cs4281: cs4281_update_ptr(): memset %d at 0x%.8x for %d size \n",
+					"cs4281: cs4281_update_ptr(): memset %d at %p for %d size \n",
 						(unsigned)(s->prop_dac.fmt & 
 						(AFMT_U8 | AFMT_U16_LE)) ? 0x80 : 0, 
-						(unsigned)s->dma_dac.rawbuf, 
-						s->dma_dac.dmasize));
+						s->dma_dac.rawbuf, s->dma_dac.dmasize));
 				memset(s->dma_dac.rawbuf,
 				       (s->prop_dac.
 					fmt & (AFMT_U8 | AFMT_U16_LE)) ?
@@ -2047,9 +2045,8 @@
 			}
 		}
 		CS_DBGOUT(CS_PARMS, 8, printk(KERN_INFO
-			"cs4281: cs4281_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d \n",
-				(unsigned) s, s->dma_dac.hwptr, 
-				s->dma_dac.total_bytes, s->dma_dac.count));
+			"cs4281: cs4281_update_ptr(): s=%p hwptr=%d total_bytes=%d count=%d \n",
+				s, s->dma_dac.hwptr, s->dma_dac.total_bytes, s->dma_dac.count));
 	}
 }
 
@@ -2180,8 +2177,7 @@
 
 	VALIDATE_STATE(s);
 	CS_DBGOUT(CS_FUNCTION, 4, printk(KERN_INFO
-		 "cs4281: mixer_ioctl(): s=0x%.8x cmd=0x%.8x\n",
-			 (unsigned) s, cmd));
+		 "cs4281: mixer_ioctl(): s=%p cmd=0x%.8x\n", s, cmd));
 #if CSDEBUG
 	cs_printioctl(cmd);
 #endif
@@ -2746,9 +2742,8 @@
 	CS_DBGOUT(CS_FUNCTION, 2,
 		  printk(KERN_INFO "cs4281: CopySamples()+ "));
 	CS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO
-		 " dst=0x%x src=0x%x count=%d iChannels=%d fmt=0x%x\n",
-			 (unsigned) dst, (unsigned) src, (unsigned) count,
-			 (unsigned) iChannels, (unsigned) fmt));
+		 " dst=%p src=%p count=%d iChannels=%d fmt=0x%x\n",
+			 dst, src, (unsigned) count, (unsigned) iChannels, (unsigned) fmt));
 
 	// Gershwin does format conversion in hardware so normally
 	// we don't do any host based coversion. The data formatter
@@ -2828,9 +2823,9 @@
 	void *src = hwsrc;	//default to the standard destination buffer addr
 
 	CS_DBGOUT(CS_FUNCTION, 6, printk(KERN_INFO
-		"cs_copy_to_user()+ fmt=0x%x fmt_o=0x%x cnt=%d dest=0x%.8x\n",
+		"cs_copy_to_user()+ fmt=0x%x fmt_o=0x%x cnt=%d dest=%p\n",
 			s->prop_adc.fmt, s->prop_adc.fmt_original,
-			(unsigned) cnt, (unsigned) dest));
+			(unsigned) cnt, dest));
 
 	if (cnt > s->dma_adc.dmasize) {
 		cnt = s->dma_adc.dmasize;
@@ -2875,7 +2870,7 @@
 	unsigned copied = 0;
 
 	CS_DBGOUT(CS_FUNCTION | CS_WAVE_READ, 2,
-		  printk(KERN_INFO "cs4281: cs4281_read()+ %d \n", count));
+		  printk(KERN_INFO "cs4281: cs4281_read()+ %Zu \n", count));
 
 	VALIDATE_STATE(s);
 	if (ppos != &file->f_pos)
@@ -2898,7 +2893,7 @@
 //
 	while (count > 0) {
 		CS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO
-			"_read() count>0 count=%d .count=%d .swptr=%d .hwptr=%d \n",
+			"_read() count>0 count=%Zu .count=%d .swptr=%d .hwptr=%d \n",
 				count, s->dma_adc.count,
 				s->dma_adc.swptr, s->dma_adc.hwptr));
 		spin_lock_irqsave(&s->lock, flags);
@@ -2955,11 +2950,10 @@
 		// the "cnt" is the number of bytes to read.
 
 		CS_DBGOUT(CS_WAVE_READ, 2, printk(KERN_INFO
-			"_read() copy_to cnt=%d count=%d ", cnt, count));
+			"_read() copy_to cnt=%d count=%Zu ", cnt, count));
 		CS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO
-			 " .dmasize=%d .count=%d buffer=0x%.8x ret=%d\n",
-				 s->dma_adc.dmasize, s->dma_adc.count,
-				 (unsigned) buffer, ret));
+			 " .dmasize=%d .count=%d buffer=%p ret=%Zd\n",
+				 s->dma_adc.dmasize, s->dma_adc.count, buffer, ret));
 
 		if (cs_copy_to_user
 		    (s, buffer, s->dma_adc.rawbuf + swptr, cnt, &copied))
@@ -2975,7 +2969,7 @@
 		start_adc(s);
 	}
 	CS_DBGOUT(CS_FUNCTION | CS_WAVE_READ, 2,
-		  printk(KERN_INFO "cs4281: cs4281_read()- %d\n", ret));
+		  printk(KERN_INFO "cs4281: cs4281_read()- %Zd\n", ret));
 	return ret;
 }
 
@@ -2991,7 +2985,7 @@
 	int cnt;
 
 	CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE, 2,
-		  printk(KERN_INFO "cs4281: cs4281_write()+ count=%d\n",
+		  printk(KERN_INFO "cs4281: cs4281_write()+ count=%Zu\n",
 			 count));
 	VALIDATE_STATE(s);
 
@@ -3047,7 +3041,7 @@
 		start_dac(s);
 	}
 	CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE, 2,
-		  printk(KERN_INFO "cs4281: cs4281_write()- %d\n", ret));
+		  printk(KERN_INFO "cs4281: cs4281_write()- %Zd\n", ret));
 	return ret;
 }
 
@@ -3168,8 +3162,7 @@
 	int val, mapped, ret;
 
 	CS_DBGOUT(CS_FUNCTION, 4, printk(KERN_INFO
-		 "cs4281: cs4281_ioctl(): file=0x%.8x cmd=0x%.8x\n",
-			 (unsigned) file, cmd));
+		 "cs4281: cs4281_ioctl(): file=%p cmd=0x%.8x\n", file, cmd));
 #if CSDEBUG
 	cs_printioctl(cmd);
 #endif
@@ -3595,8 +3588,8 @@
 	    (struct cs4281_state *) file->private_data;
 
 	CS_DBGOUT(CS_FUNCTION | CS_RELEASE, 2, printk(KERN_INFO
-		 "cs4281: cs4281_release(): inode=0x%.8x file=0x%.8x f_mode=%d\n",
-			 (unsigned) inode, (unsigned) file, file->f_mode));
+		 "cs4281: cs4281_release(): inode=%p file=%p f_mode=%d\n",
+			 inode, file, file->f_mode));
 
 	VALIDATE_STATE(s);
 
@@ -3630,8 +3623,8 @@
 	struct list_head *entry;
 
 	CS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO
-		"cs4281: cs4281_open(): inode=0x%.8x file=0x%.8x f_mode=0x%x\n",
-			(unsigned) inode, (unsigned) file, file->f_mode));
+		"cs4281: cs4281_open(): inode=%p file=%p f_mode=0x%x\n",
+			inode, file, file->f_mode));
 
 	list_for_each(entry, &cs4281_devs)
 	{
@@ -4340,10 +4333,8 @@
 
 	CS_DBGOUT(CS_INIT, 2,
 		  printk(KERN_INFO
-			 "cs4281: probe() BA0=0x%.8x BA1=0x%.8x pBA0=0x%.8x pBA1=0x%.8x \n",
-			 (unsigned) temp1, (unsigned) temp2,
-			 (unsigned) s->pBA0, (unsigned) s->pBA1));
-
+			 "cs4281: probe() BA0=0x%.8x BA1=0x%.8x pBA0=%p pBA1=%p \n",
+			 (unsigned) temp1, (unsigned) temp2, s->pBA0, s->pBA1));
 	CS_DBGOUT(CS_INIT, 2,
 		  printk(KERN_INFO
 			 "cs4281: probe() pBA0phys=0x%.8x pBA1phys=0x%.8x\n",
@@ -4390,15 +4381,13 @@
 	if (pmdev)
 	{
 		CS_DBGOUT(CS_INIT | CS_PM, 4, printk(KERN_INFO
-			 "cs4281: probe() pm_register() succeeded (0x%x).\n",
-				(unsigned)pmdev));
+			 "cs4281: probe() pm_register() succeeded (%p).\n", pmdev));
 		pmdev->data = s;
 	}
 	else
 	{
 		CS_DBGOUT(CS_INIT | CS_PM | CS_ERROR, 0, printk(KERN_INFO
-			 "cs4281: probe() pm_register() failed (0x%x).\n",
-				(unsigned)pmdev));
+			 "cs4281: probe() pm_register() failed (%p).\n", pmdev));
 		s->pm.flags |= CS4281_PM_NOT_REGISTERED;
 	}
 #endif
diff -urN linux.orig/drivers/sound/cs4281/cs4281pm-24.c linux/drivers/sound/cs4281/cs4281pm-24.c
--- linux.orig/drivers/sound/cs4281/cs4281pm-24.c	Sun Feb  4 11:05:29 2001
+++ linux/drivers/sound/cs4281/cs4281pm-24.c	Mon Dec 17 20:27:41 2001
@@ -38,16 +38,16 @@
 #define CS4281_SUSPEND_TBL cs4281_suspend_tbl
 #define CS4281_RESUME_TBL cs4281_resume_tbl
 */
-#define CS4281_SUSPEND_TBL cs4281_null
-#define CS4281_RESUME_TBL cs4281_null
+#define CS4281_SUSPEND_TBL	(int (*) (struct pci_dev *, u32)) cs4281_null
+#define CS4281_RESUME_TBL	(int (*) (struct pci_dev *)) cs4281_null
 
 int cs4281_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
 {
 	struct cs4281_state *state;
 
 	CS_DBGOUT(CS_PM, 2, printk(KERN_INFO 
-		"cs4281: cs4281_pm_callback dev=0x%x rqst=0x%x state=%d\n",
-			(unsigned)dev,(unsigned)rqst,(unsigned)data));
+		"cs4281: cs4281_pm_callback dev=%p rqst=0x%x state=%p\n",
+			dev,(unsigned)rqst,data));
 	state = (struct cs4281_state *) dev->data;
 	if (state) {
 		switch(rqst) {
@@ -78,7 +78,7 @@
 }
 
 #else /* CS4281_PM */
-#define CS4281_SUSPEND_TBL cs4281_null
-#define CS4281_RESUME_TBL cs4281_null
+#define CS4281_SUSPEND_TBL	(int (*) (struct pci_dev *, u32)) cs4281_null
+#define CS4281_RESUME_TBL 	(int (*) (struct pci_dev *)) cs4281_null
 #endif /* CS4281_PM */
 
diff -urN linux.orig/drivers/sound/sound_firmware.c linux/drivers/sound/sound_firmware.c
--- linux.orig/drivers/sound/sound_firmware.c	Fri Feb  9 12:30:23 2001
+++ linux/drivers/sound/sound_firmware.c	Mon Dec 17 20:27:41 2001
@@ -7,7 +7,6 @@
 #include <linux/unistd.h>
 #include <asm/uaccess.h>
 
-static int errno;
 static int do_mod_firmware_load(const char *fn, char **fp)
 {
 	int fd;
diff -urN linux.orig/drivers/usb/usb-ohci.c linux/drivers/usb/usb-ohci.c
--- linux.orig/drivers/usb/usb-ohci.c	Wed Aug 15 02:22:16 2001
+++ linux/drivers/usb/usb-ohci.c	Mon Dec 17 20:27:41 2001
@@ -2326,21 +2326,22 @@
 {
 	ohci_t * ohci;
 	struct usb_bus * bus;
+	dma_addr_t bus_addr;
 
 	ohci = (ohci_t *) kmalloc (sizeof *ohci, GFP_KERNEL);
 	if (!ohci)
 		return NULL;
-		
+
 	memset (ohci, 0, sizeof (ohci_t));
 
-	ohci->hcca = pci_alloc_consistent (dev, sizeof *ohci->hcca,
-			&ohci->hcca_dma);
+	ohci->hcca = pci_alloc_consistent (dev, sizeof *ohci->hcca, &bus_addr);
         if (!ohci->hcca) {
                 kfree (ohci);
                 return NULL;
         }
         memset (ohci->hcca, 0, sizeof (struct ohci_hcca));
 
+	ohci->hcca_dma = bus_addr;
 	ohci->disabled = 1;
 	ohci->sleeping = 0;
 	ohci->irq = -1;
diff -urN linux.orig/drivers/video/fbmem.c linux/drivers/video/fbmem.c
--- linux.orig/drivers/video/fbmem.c	Tue Jul 10 21:16:30 2001
+++ linux/drivers/video/fbmem.c	Mon Dec 17 20:27:41 2001
@@ -605,6 +605,8 @@
 	vma->vm_flags |= VM_IO;
 #elif defined(__sh__)
 	pgprot_val(vma->vm_page_prot) &= ~_PAGE_CACHABLE;
+#elif defined(__ia64__)
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 #else
 #warning What do we have to do here??
 #endif
diff -urN linux.orig/drivers/video/vgacon.c linux/drivers/video/vgacon.c
--- linux.orig/drivers/video/vgacon.c	Fri Feb  9 12:30:23 2001
+++ linux/drivers/video/vgacon.c	Mon Dec 17 20:27:41 2001
@@ -108,14 +108,7 @@
 static unsigned int    vga_default_font_height;	/* Height of default screen font */
 static unsigned char   vga_video_type;		/* Card type */
 static unsigned char   vga_hardscroll_enabled;
-#ifdef CONFIG_IA64_SOFTSDV_HACKS
-/*
- * SoftSDV doesn't have hardware assist VGA scrolling 
- */
-static unsigned char   vga_hardscroll_user_enable = 0;
-#else
 static unsigned char   vga_hardscroll_user_enable = 1;
-#endif
 static unsigned char   vga_font_is_default = 1;
 static int	       vga_vesa_blanked;
 static int	       vga_palette_blanked;
diff -urN linux.orig/fs/devfs/base.c linux/fs/devfs/base.c
--- linux.orig/fs/devfs/base.c	Wed Jul 11 15:55:41 2001
+++ linux/fs/devfs/base.c	Mon Dec 17 20:27:41 2001
@@ -1945,6 +1945,27 @@
     return master->slave;
 }   /*  End Function devfs_get_unregister_slave  */
 
+#ifdef CONFIG_DEVFS_GUID
+/**
+ *	devfs_unregister_slave - remove the slave that is unregistered when @master is unregistered.
+ *      Destroys the connection established by devfs_auto_unregister.
+ *
+ *	@master: The master devfs entry.
+ */
+
+void devfs_unregister_slave (devfs_handle_t master)
+{
+	devfs_handle_t slave;
+
+	if (master == NULL) return;
+
+	slave = master->slave;
+	if (slave) {
+		master->slave = NULL;
+		unregister (slave);
+	};
+}
+#endif /* CONFIG_DEVFS_GUID */
 
 /**
  *	devfs_get_name - Get the name for a device entry in its parent directory.
@@ -2122,6 +2143,9 @@
 EXPORT_SYMBOL(devfs_register_blkdev);
 EXPORT_SYMBOL(devfs_unregister_chrdev);
 EXPORT_SYMBOL(devfs_unregister_blkdev);
+#ifdef CONFIG_DEVFS_GUID
+EXPORT_SYMBOL(devfs_unregister_slave);
+#endif
 
 
 /**
diff -urN linux.orig/fs/exec.c linux/fs/exec.c
--- linux.orig/fs/exec.c	Thu Jul 19 21:32:54 2001
+++ linux/fs/exec.c	Mon Dec 17 20:27:41 2001
@@ -150,7 +150,7 @@
 }
 
 /*
- * count() counts the number of arguments/envelopes
+ * count() counts the number of strings in array ARGV.
  */
 static int count(char ** argv, int max)
 {
diff -urN linux.orig/fs/fcntl.c linux/fs/fcntl.c
--- linux.orig/fs/fcntl.c	Tue May 22 10:26:06 2001
+++ linux/fs/fcntl.c	Mon Dec 17 20:27:41 2001
@@ -269,6 +269,7 @@
 			 * to fix this will be in libc.
 			 */
 			err = filp->f_owner.pid;
+			force_successful_syscall_return();
 			break;
 		case F_SETOWN:
 			lock_kernel();
diff -urN linux.orig/fs/inode.c linux/fs/inode.c
--- linux.orig/fs/inode.c	Thu Aug  9 17:41:36 2001
+++ linux/fs/inode.c	Mon Dec 17 20:27:41 2001
@@ -15,6 +15,7 @@
 #include <linux/cache.h>
 #include <linux/swap.h>
 #include <linux/swapctl.h>
+#include <linux/prefetch.h>
 
 /*
  * New inode.c implementation.
@@ -806,6 +807,8 @@
 	static unsigned long last_ino;
 	struct inode * inode;
 
+	prefetch_spin_lock(&inode_lock);
+	
 	inode = alloc_inode();
 	if (inode)
 	{
diff -urN linux.orig/fs/ntfs/unistr.c linux/fs/ntfs/unistr.c
--- linux.orig/fs/ntfs/unistr.c	Wed Aug 15 02:22:17 2001
+++ linux/fs/ntfs/unistr.c	Mon Dec 17 20:27:41 2001
@@ -22,6 +22,7 @@
  */
 
 #include <linux/string.h>
+#include <linux/kernel.h>
 #include <asm/byteorder.h>
 
 #include "unistr.h"
diff -urN linux.orig/fs/partitions/Config.in linux/fs/partitions/Config.in
--- linux.orig/fs/partitions/Config.in	Sun Aug 12 12:13:59 2001
+++ linux/fs/partitions/Config.in	Mon Dec 17 20:27:41 2001
@@ -24,6 +24,8 @@
       bool '    Minix subpartition support' CONFIG_MINIX_SUBPARTITION
       bool '    Solaris (x86) partition table support' CONFIG_SOLARIS_X86_PARTITION
       bool '    Unixware slices support' CONFIG_UNIXWARE_DISKLABEL
+      bool '    EFI GUID Partition support' CONFIG_EFI_PARTITION
+      dep_bool '    /dev/guid support (EXPERIMENTAL)' CONFIG_DEVFS_GUID $CONFIG_DEVFS_FS $CONFIG_EFI_PARTITION
    fi
    dep_bool '  Windows Logical Disk Manager (Dynamic Disk) support' CONFIG_LDM_PARTITION $CONFIG_EXPERIMENTAL
    if [ "$CONFIG_LDM_PARTITION" = "y" ]; then
diff -urN linux.orig/fs/partitions/Makefile linux/fs/partitions/Makefile
--- linux.orig/fs/partitions/Makefile	Thu Jul 26 17:30:04 2001
+++ linux/fs/partitions/Makefile	Mon Dec 17 20:27:41 2001
@@ -24,6 +24,7 @@
 obj-$(CONFIG_SUN_PARTITION) += sun.o
 obj-$(CONFIG_ULTRIX_PARTITION) += ultrix.o
 obj-$(CONFIG_IBM_PARTITION) += ibm.o
+obj-$(CONFIG_EFI_PARTITION) += efi.o
 
 include $(TOPDIR)/Rules.make
 
diff -urN linux.orig/fs/partitions/check.c linux/fs/partitions/check.c
--- linux.orig/fs/partitions/check.c	Sun Aug  5 14:12:41 2001
+++ linux/fs/partitions/check.c	Mon Dec 17 20:27:41 2001
@@ -34,6 +34,10 @@
 #include "ibm.h"
 #include "ultrix.h"
 
+#ifdef CONFIG_EFI_PARTITION
+# include "efi.h"
+#endif
+
 extern int *blk_size[];
 
 struct gendisk *gendisk_head;
@@ -43,6 +47,9 @@
 #ifdef CONFIG_ACORN_PARTITION
 	acorn_partition,
 #endif
+#ifdef CONFIG_EFI_PARTITION
+	efi_partition,
+#endif
 #ifdef CONFIG_LDM_PARTITION
 	ldm_partition,		/* this must come before msdos */
 #endif
@@ -76,6 +83,20 @@
 	NULL
 };
 
+#ifdef CONFIG_DEVFS_GUID
+static devfs_handle_t guid_top_handle;
+
+#define GUID_UNPARSED_LEN 36
+static void
+uuid_unparse_1(efi_guid_t *guid, char *out)
+{
+	sprintf(out, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+		guid->data1, guid->data2, guid->data3,
+ 		guid->data4[0], guid->data4[1], guid->data4[2], guid->data4[3],
+		guid->data4[4], guid->data4[5], guid->data4[6], guid->data4[7]);
+}
+#endif
+
 /*
  *	This is ucking fugly but its probably the best thing for 2.4.x
  *	Take it as a clear reminder than we should put the device name
@@ -329,6 +350,101 @@
 	devfs_register_partitions (hd, i, hd->sizes ? 0 : 1);
 }
 
+#ifdef CONFIG_DEVFS_GUID
+/*
+  devfs_register_guid: create a /dev/guid entry for a disk or partition
+                       if it has a GUID.
+
+  The /dev/guid entry will be a symlink to the "real" devfs device.
+  It is marked as "slave" of the real device,
+  to be automatically unregistered by devfs if that device is unregistered.
+
+  If the partition already had a /dev/guid entry, delete (unregister) it.
+  (If the disk was repartitioned, it's likely the old GUID entry will be wrong).
+
+  dev, minor:  Device for which an entry is to be created.
+
+  Prerequisites: dev->part[minor].guid must be either NULL or point
+                 to a valid kmalloc'ed GUID.
+*/
+
+static void devfs_register_guid (struct gendisk *dev, int minor)
+{
+	efi_guid_t *guid = dev->part[minor].guid;
+	devfs_handle_t guid_handle, slave,
+		real_master = dev->part[minor].de;
+	devfs_handle_t master = real_master;
+	char guid_link[GUID_UNPARSED_LEN + 1];
+	char dirname[128];
+	int pos, st;
+
+	if (!guid_top_handle)
+		guid_top_handle = devfs_mk_dir (NULL, "guid", NULL);
+
+	if (!guid || !master) return;
+
+	do {
+		slave = devfs_get_unregister_slave (master);
+		if (slave) {
+			if (slave == master || slave == real_master) {
+				printk (KERN_WARNING
+					"devfs_register_guid: infinite slave loop!\n");
+				return;
+			} else if (devfs_get_parent (slave) == guid_top_handle) {
+				printk (KERN_INFO
+					"devfs_register_guid: unregistering %s\n",
+					devfs_get_name (slave, NULL));
+				devfs_unregister_slave (master);
+				slave = NULL;
+			} else
+				master = slave;
+		};
+	} while (slave);
+
+	uuid_unparse_1 (guid, guid_link);
+	pos = devfs_generate_path (real_master, dirname + 3,
+				   sizeof (dirname) - 3);
+	if (pos < 0) {
+		printk (KERN_WARNING
+			"devfs_register_guid: error generating path: %d\n",
+			pos);
+		return;
+	};
+
+	strncpy (dirname + pos, "../", 3);
+
+	st = devfs_mk_symlink (guid_top_handle, guid_link,
+			       DEVFS_FL_DEFAULT,
+			       dirname + pos, &guid_handle, NULL);
+
+	if (st < 0) {
+		printk ("Error %d creating symlink\n", st);
+	} else {
+		devfs_auto_unregister (master, guid_handle);
+	};
+};
+
+/*
+  free_disk_guids: kfree all guid data structures alloced for
+  the disk device specified by (dev, minor) and all its partitions.
+
+  This function does not remove symlinks in /dev/guid.
+*/
+static void free_disk_guids (struct gendisk *dev, int minor)
+{
+	int i;
+	efi_guid_t *guid;
+
+	for (i = 0; i < dev->max_p; i++) {
+		guid = dev->part[minor + i].guid;
+		if (!guid) continue;
+		kfree (guid);
+		dev->part[minor + i].guid = NULL;
+	};
+}
+
+#endif /* CONFIG_DEVFS_GUID */
+
 #ifdef CONFIG_DEVFS_FS
 static void devfs_register_partition (struct gendisk *dev, int minor, int part)
 {
@@ -337,7 +453,11 @@
 	unsigned int devfs_flags = DEVFS_FL_DEFAULT;
 	char devname[16];
 
-	if (dev->part[minor + part].de) return;
+	/* Even if the devfs handle is still up-to-date,
+	   the GUID entry probably isn't */
+	if (dev->part[minor + part].de)
+		goto do_guid;
+
 	dir = devfs_get_parent (dev->part[minor].de);
 	if (!dir) return;
 	if ( dev->flags && (dev->flags[devnum] & GENHD_FL_REMOVABLE) )
@@ -348,6 +468,11 @@
 			    dev->major, minor + part,
 			    S_IFBLK | S_IRUSR | S_IWUSR,
 			    dev->fops, NULL);
+ do_guid:
+#ifdef CONFIG_DEVFS_GUID
+	devfs_register_guid (dev, minor + part);
+#endif
+	return;
 }
 
 static struct unique_numspace disc_numspace = UNIQUE_NUMBERSPACE_INITIALISER;
@@ -361,7 +486,9 @@
 	char dirname[64], symlink[16];
 	static devfs_handle_t devfs_handle;
 
-	if (dev->part[minor].de) return;
+	if (dev->part[minor].de)
+		goto do_guid;
+
 	if ( dev->flags && (dev->flags[devnum] & GENHD_FL_REMOVABLE) )
 		devfs_flags |= DEVFS_FL_REMOVABLE;
 	if (dev->de_arr) {
@@ -389,6 +516,12 @@
 	devfs_auto_unregister (dev->part[minor].de, slave);
 	if (!dev->de_arr)
 		devfs_auto_unregister (slave, dir);
+
+ do_guid:
+#ifdef CONFIG_DEVFS_GUID
+	devfs_register_guid (dev, minor);
+#endif
+	return;
 }
 #endif  /*  CONFIG_DEVFS_FS  */
 
@@ -412,6 +545,9 @@
 		dev->part[minor].de = NULL;
 		devfs_dealloc_unique_number (&disc_numspace,
 					     dev->part[minor].number);
+# ifdef CONFIG_DEVFS_GUID
+		free_disk_guids (dev, minor);
+# endif
 	}
 #endif  /*  CONFIG_DEVFS_FS  */
 }
@@ -429,8 +565,21 @@
 void register_disk(struct gendisk *gdev, kdev_t dev, unsigned minors,
 	struct block_device_operations *ops, long size)
 {
+	int i;
+
 	if (!gdev)
 		return;
+
+#ifdef CONFIG_DEVFS_GUID
+	/* Initialize all guid fields to NULL (=^ not kmalloc'ed).
+	   It is assumed that drivers call register_disk after
+	   allocating the gen_hd structure, and call grok_partitions
+	   directly for a revalidate event, as those drives I've inspected
+	   (among which hd and sd) do. */
+	for (i = 0; i < gdev->max_p; i++)
+		gdev->part[MINOR(dev) + i].guid = NULL;
+#endif
+
 	grok_partitions(gdev, MINOR(dev)>>gdev->minor_shift, minors, size);
 }
 
@@ -448,6 +597,13 @@
 	if (!size || minors == 1)
 		return;
 
+#ifdef CONFIG_DEVFS_GUID
+	/* In case this is a revalidation, free GUID memory.
+	   On the first call for this device,
+	   register_disk has set all entries to NULL,
+	   and nothing will happen. */
+	free_disk_guids (dev, first_minor);
+#endif
 	check_partition(dev, MKDEV(dev->major, first_minor), 1 + first_minor);
 
  	/*
diff -urN linux.orig/fs/partitions/efi.c linux/fs/partitions/efi.c
--- linux.orig/fs/partitions/efi.c	Wed Dec 31 17:00:00 1969
+++ linux/fs/partitions/efi.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,633 @@
+/************************************************************
+ * EFI GUID Partition Table handling
+ * Per Intel EFI Specification v0.99
+ * http://developer.intel.com/technology/efi/efi.htm
+ * efi.[ch] by Matt Domsch <Matt_Domsch@dell.com>
+ *   Copyright 2000 Dell Computer Corporation
+ *
+ * Note, the EFI Specification, v0.99, has a reference to
+ * Dr. Dobbs Journal, May 1994 (actually it's in May 1992)
+ * but that isn't the CRC function being used by EFI.  Intel's
+ * EFI Sample Implementation shows that they use the same function
+ * as was COPYRIGHT (C) 1986 Gary S. Brown.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * TODO:
+ *
+ * Changelog:
+ * Tue Dec  5 2000 Matt Domsch <Matt_Domsch@dell.com>
+ * - Moved crc32() to linux/lib, added efi_crc32().
+ *
+ * Thu Nov 30 2000 Matt Domsch <Matt_Domsch@dell.com>
+ * - Replaced Intel's CRC32 function with an equivalent
+ *   non-license-restricted version.
+ *
+ * Wed Oct 25 2000 Matt Domsch <Matt_Domsch@dell.com>
+ * - Fixed the LastLBA() call to return the proper last block
+ *
+ * Thu Oct 12 2000 Matt Domsch <Matt_Domsch@dell.com>
+ * - Thanks to Andries Brouwer for his debugging assistance.
+ * - Code works, detects all the partitions.
+ *
+ ************************************************************/
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/genhd.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/blkpg.h>
+#include <linux/malloc.h>
+#include <linux/smp_lock.h>
+#include <asm/system.h>
+#include <asm/efi.h>
+#include <linux/crc32.h>
+
+#include "check.h"
+#include "efi.h"
+
+#if CONFIG_BLK_DEV_MD
+extern void md_autodetect_dev(kdev_t dev);
+#endif
+
+
+#undef EFI_DEBUG
+#ifdef EFI_DEBUG
+static char *efi_printk_level = KERN_DEBUG;
+#define debug_printk printk
+#else
+#define debug_printk(...)
+#endif
+
+/************************************************************
+ * efi_crc32()
+ * Requires:
+ *  - a buffer of length len
+ * Modifies: nothing
+ * Returns:
+ *  EFI-style CRC32 value for buf
+ *
+ * This function uses the crc32 function by Gary S. Brown,
+ * but seeds the function with ~0, and xor's with ~0 at the end.
+ ************************************************************/
+
+u32 static inline
+efi_crc32(const void *buf, unsigned long len)
+{
+  return (crc32(buf, len, ~0L) ^ ~0L);
+}
+
+
+
+
+/************************************************************
+ * IsLegacyMBRValid()
+ * Requires:
+ *  - mbr is a pointer to a legacy mbr structure
+ * Modifies: nothing
+ * Returns:
+ *  1 on true
+ *  0 on false
+ ************************************************************/
+static inline int
+IsLegacyMBRValid(LegacyMBR_t *mbr)
+{
+	return (mbr ? (mbr->Signature == MSDOS_MBR_SIGNATURE) : 0);
+}
+
+
+
+/************************************************************
+ * LastLBA()
+ * Requires:
+ *  - struct gendisk hd
+ *  - kdev_t dev
+ * Modifies: nothing
+ * Returns:
+ *  Last LBA value on success.  This is stored (by sd and
+ *  ide-geometry) in
+ *  the part[0] entry for this disk, and is the number of
+ *  physical sectors available on the disk.
+ *  0 on error
+ ************************************************************/
+u64
+LastLBA(struct gendisk *hd, kdev_t dev)
+{
+  if (!hd || !hd->part) return 0;
+  return hd->part[MINOR(dev)].nr_sects - 1;
+}
+
+
+/************************************************************
+ * ReadLBA()
+ * Requires:
+ *  - hd is our disk device.
+ *  - dev is our device major number
+ *  - lba is the logical block address desired (disk hardsector number)
+ *  - buffer is a buffer of size size into which data copied
+ *  - size_t count is size of the read (in bytes)
+ * Modifies:
+ *  - buffer
+ * Returns:
+ *  - count of bytes read
+ *  - 0 on error
+ * Bugs:
+ *  - bread() takes second argument as a signed int, not a u64.
+ *    This is because getblk() takes the block number as a signed int.
+ *    This overflow is known on l-k.   We overflow at about 1TB.
+ *
+ ************************************************************/
+
+static size_t
+ReadLBA(struct gendisk *hd, kdev_t dev, u64 _lba, u8 *buffer, size_t count)
+{
+	struct buffer_head *bh;
+	size_t totalreadcount = 0, bytesread;
+	int lba = (_lba & 0x7FFFFFFF), i, blockstoread, blocksize;
+	debug_printk(efi_printk_level "ReadLBA(%p,%s,%x,%p,%x)\n",
+		     hd, kdevname(dev), lba, buffer, count);
+
+	if (!hd || !buffer || !count) return 0;
+
+
+	blocksize = get_hardsect_size(dev);
+	blockstoread = count / blocksize;
+	if (count % blocksize) blockstoread += 1;
+	debug_printk(efi_printk_level "about to read %d blocks\n",
+		     blockstoread);
+
+
+	for (i=0; i<blockstoread; i++) {
+		bh = bread(dev, lba+i, blocksize);
+		if (!bh) {
+			/* We hit the end of the disk */
+			debug_printk(efi_printk_level
+				     "bread returned NULL.\n");
+			return totalreadcount;
+		}
+
+		bytesread = (count > bh->b_size ? bh->b_size : count);
+		memcpy(buffer, bh->b_data, bytesread);
+
+		buffer += bytesread;         /* Advance the buffer pointer */
+		totalreadcount += bytesread; /* Advance the total read count */
+		count -= bytesread;         /* Subtract bytesread from count */
+
+		brelse(bh);
+	}
+
+	return totalreadcount;
+}
+
+void
+PrintGuidPartitionTableHeader(GuidPartitionTableHeader_t *gpt)
+{
+	debug_printk(efi_printk_level "GUID Partition Table Header\n");
+	if (!gpt) return;
+	debug_printk(efi_printk_level "Signature      : %lx\n",
+		     gpt->Signature);
+	debug_printk(efi_printk_level "Revision       : %x\n",
+		     gpt->Revision);
+	debug_printk(efi_printk_level "HeaderSize     : %x\n",
+		     gpt->HeaderSize);
+	debug_printk(efi_printk_level "HeaderCRC32    : %x\n",
+		     gpt->HeaderCRC32);
+	debug_printk(efi_printk_level "MyLBA          : %lx\n",
+		     gpt->MyLBA);
+	debug_printk(efi_printk_level "AlternateLBA   : %lx\n",
+		     gpt->AlternateLBA);
+	debug_printk(efi_printk_level "FirstUsableLBA : %lx\n",
+		     gpt->FirstUsableLBA);
+	debug_printk(efi_printk_level "LastUsableLBA  : %lx\n",
+		     gpt->LastUsableLBA);
+
+	debug_printk(efi_printk_level "PartitionEntryLBA : %lx\n",
+		     gpt->PartitionEntryLBA);
+	debug_printk(efi_printk_level "NumberOfPartitionEntries : %x\n",
+		     gpt->NumberOfPartitionEntries);
+	debug_printk(efi_printk_level "SizeOfPartitionEntry : %x\n",
+		     gpt->SizeOfPartitionEntry);
+	debug_printk(efi_printk_level "PartitionEntryArrayCRC32 : %x\n",
+		     gpt->PartitionEntryArrayCRC32);
+
+	return;
+}
+
+
+
+/************************************************************
+ * ReadGuidPartitionEntries()
+ * Requires:
+ *  - filedes is an open file descriptor, suitable for reading
+ *  - lba is the Logical Block Address of the partition table
+ *  - gpt is a buffer into which the GPT will be put
+ * Modifies:
+ *  - filedes file and pointer
+ *  - gpt
+ * Returns:
+ *   pte on success
+ *   NULL on error
+ * Notes: remember to free pte when you're done!
+ ************************************************************/
+GuidPartitionEntry_t *
+ReadGuidPartitionEntries(struct gendisk *hd, kdev_t dev,
+			 GuidPartitionTableHeader_t *gpt)
+{
+	size_t count;
+	GuidPartitionEntry_t *pte;
+	if (!hd || !gpt) return NULL;
+
+	count = gpt->NumberOfPartitionEntries * gpt->SizeOfPartitionEntry;
+	debug_printk(efi_printk_level "ReadGPTEs() kmallocing %x bytes\n",
+		     count);
+	if (!count) return NULL;
+	pte = kmalloc(count, GFP_KERNEL);
+	if (!pte)  return NULL;
+	memset(pte, 0, count);
+
+	if (ReadLBA(hd, dev, gpt->PartitionEntryLBA, (u8 *)pte,
+		    count) < count) {
+		kfree(pte);
+		return NULL;
+	}
+	return pte;
+}
+
+
+
+/************************************************************
+ * ReadGuidPartitionTableHeader()
+ * Requires:
+ *  - hd is our struct gendisk
+ *  - dev is our device major number
+ *  - lba is the Logical Block Address of the partition table
+ *  - gpt is a buffer into which the GPT will be put
+ *  - pte is a buffer into which the PTEs will be put
+ * Modifies:
+ *  - gpt and pte
+ * Returns:
+ *   1 on success
+ *   0 on error
+ ************************************************************/
+
+GuidPartitionTableHeader_t *
+ReadGuidPartitionTableHeader(struct gendisk *hd, kdev_t dev, u64 lba)
+
+{
+	GuidPartitionTableHeader_t *gpt;
+	if (!hd) return NULL;
+
+	gpt = kmalloc(sizeof(GuidPartitionTableHeader_t), GFP_KERNEL);
+	if (!gpt) return NULL;
+	memset(gpt, 0, sizeof(GuidPartitionTableHeader_t));
+
+	debug_printk(efi_printk_level "GPTH() calling ReadLBA().\n");
+	if (ReadLBA(hd, dev, lba, (u8 *)gpt,
+		    sizeof(GuidPartitionTableHeader_t)) <
+	    sizeof(GuidPartitionTableHeader_t)) {
+		debug_printk(efi_printk_level "ReadGPTH(%lx) read failed.\n",
+			     lba);
+		kfree(gpt);
+		return NULL;
+	}
+	PrintGuidPartitionTableHeader(gpt);
+
+	return gpt;
+}
+
+
+
+/************************************************************
+ * IsGuidPartitionTableValid()
+ * Requires:
+ *  - gd points to our struct gendisk
+ *  - dev is our device major number
+ *  - lba is the logical block address of the GPTH to test
+ *  - gpt is a GPTH if it's valid
+ *  - ptes is a PTEs if it's valid
+ * Modifies:
+ *  - gpt and ptes
+ * Returns:
+ *   1 if valid
+ *   0 on error
+ ************************************************************/
+static int
+IsGuidPartitionTableValid(struct gendisk *hd, kdev_t dev, u64 lba,
+			  GuidPartitionTableHeader_t **gpt,
+			  GuidPartitionEntry_t **ptes)
+{
+	u32 crc, origcrc;
+
+	if (!hd || !gpt || !ptes) return 0;
+	if (!(*gpt = ReadGuidPartitionTableHeader(hd, dev, lba))) return 0;
+
+	/* Check the GUID Partition Table Signature */
+	if ((*gpt)->Signature != GUID_PT_HEADER_SIGNATURE) {
+		debug_printk(efi_printk_level "GUID Partition Table Header Signature is wrong: %x != %x\n", (*gpt)->Signature, GUID_PT_HEADER_SIGNATURE);
+		kfree(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+
+	/* Check the GUID Partition Table CRC */
+	origcrc = (*gpt)->HeaderCRC32;
+	(*gpt)->HeaderCRC32 = 0;
+	crc = efi_crc32((const unsigned char *)(*gpt), (*gpt)->HeaderSize);
+
+
+	if (crc != origcrc) {
+		debug_printk(efi_printk_level "GUID Partition Table Header CRC is wrong: %x != %x\n", (*gpt)->HeaderCRC32, origcrc);
+		kfree(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+	(*gpt)->HeaderCRC32 = origcrc;
+
+	/* Check that the MyLBA entry points to the LBA that contains
+	 * the GUID Partition Table */
+	if ((*gpt)->MyLBA != lba) {
+		debug_printk(efi_printk_level "GPT MyLBA incorrect: %lx != %lx\n", (*gpt)->MyLBA, lba);
+		kfree(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+
+	if (!(*ptes = ReadGuidPartitionEntries(hd, dev, *gpt))) {
+		debug_printk(efi_printk_level "read PTEs failed.\n");
+		kfree(*gpt);
+		*gpt = NULL;
+		return 0;
+	}
+
+	/* Check the GUID Partition Entry Array CRC */
+	crc = efi_crc32((const unsigned char *)(*ptes),
+		    (*gpt)->NumberOfPartitionEntries *
+			   (*gpt)->SizeOfPartitionEntry);
+
+	if (crc != (*gpt)->PartitionEntryArrayCRC32)  {
+		debug_printk(efi_printk_level "GUID Partitition Entry Array CRC check failed.\n");
+		kfree(*gpt);
+		*gpt = NULL;
+		kfree(*ptes);
+		*ptes = NULL;
+		return 0;
+	}
+
+
+	/* We're done, all's well */
+	return 1;
+}
+
+
+
+/************************************************************
+ * FindValidGPT()
+ * Requires:
+ *  - gd points to our struct gendisk
+ *  - dev is our device major number
+ *  - gpt is a GPTH if it's valid
+ *  - ptes is a PTE
+ * Modifies:
+ *  - gpt & ptes
+ * Returns:
+ *   1 if valid
+ *   0 on error
+ ************************************************************/
+static int
+FindValidGPT(struct gendisk *hd, kdev_t dev,
+	     GuidPartitionTableHeader_t **gpt,
+	     GuidPartitionEntry_t **ptes)
+{
+	int rc = 0;
+	GuidPartitionTableHeader_t *pgpt = NULL, *agpt = NULL;
+	GuidPartitionEntry_t *pptes = NULL, *aptes = NULL;
+	u64 lastlba;
+	if (!hd || !gpt || !ptes) return 0;
+
+	lastlba = LastLBA(hd, dev);
+	/* Check the Primary GPT */
+	rc = IsGuidPartitionTableValid(hd, dev, 1, &pgpt, &pptes);
+	if (rc) {
+		/* Primary GPT is OK, check the alternate and warn if bad */
+		rc = IsGuidPartitionTableValid(hd, dev, pgpt->AlternateLBA,
+					       &agpt, &aptes);
+		if (!rc){
+			printk(KERN_WARNING "Alternate GPT is invalid, using primary GPT.\n");
+		}
+
+		*gpt = pgpt;
+		*ptes = pptes;
+		if (agpt)  kfree(agpt);
+		if (aptes) kfree(aptes);
+		return 1;
+	} /* if primary is valid */
+	else {
+		/* Primary GPT is bad, check the Alternate GPT */
+		rc = IsGuidPartitionTableValid(hd, dev, lastlba,
+					       &agpt, &aptes);
+		if (rc) {
+			/* Primary is bad, alternate is good.
+			   Return values from the alternate and warn.
+			*/
+			printk(KERN_WARNING "Primary GPT is invalid, using alternate GPT.\n");
+			*gpt = agpt;
+			*ptes = aptes;
+			return 1;
+		}
+		else {
+			/* Primary is bad, alternate is bad, try "other"
+			 * alternate.  This is necessary because if we
+			 * have an odd-sized disk, user-space might
+			 * have put the alternate in block lastlba-1.
+			 */
+			if (!(lastlba & 1)) {
+				lastlba--;
+				rc = IsGuidPartitionTableValid(hd, dev,
+							       lastlba,
+							       &agpt, &aptes);
+				if (rc) {
+					/* Primary is bad, alternate is good.
+					 * Return values from the alternate
+					 * and warn.
+					 */
+					printk("Primary GPT is invalid, using alternate GPT.\n");
+					*gpt = agpt;
+					*ptes = aptes;
+					return 1;
+				}
+			}
+		}
+	}
+	/* Both primary and alternate GPTs are bad.
+	 * This isn't our disk, return 0.
+	 */
+	return 0;
+}
+
+#ifdef CONFIG_DEVFS_GUID
+/* set_partition_guid */
+/* Fill in the GUID field of the partition.
+   It is set to NULL by register_disk before. */
+static void set_partition_guid (struct gendisk *hd,
+				const int minor,
+				const efi_guid_t *guid)
+{
+	efi_guid_t *part_guid = hd->part[minor].guid;
+
+	if (!guid || !hd) return;
+
+	part_guid = kmalloc (sizeof (efi_guid_t), GFP_KERNEL);
+
+        if (part_guid) {
+		memcpy (part_guid, guid, sizeof (efi_guid_t));
+	} else {
+		printk (KERN_WARNING
+                        "add_gpt_partitions: cannot allocate GUID memory!\n");
+	};
+
+	hd->part[minor].guid = part_guid;
+}
+#endif /* CONFIG_DEVFS_GUID */
+
+/*
+ * Create devices for each entry in the GUID Partition Table Entries.
+ * The first block of each partition is a Legacy MBR.
+ *
+ * We do not create a Linux partition for GPT, but
+ * only for the actual data partitions.
+ * Returns:
+ * -1 if unable to read the partition table
+ *  0 if this isn't our partition table
+ *  1 if successful
+ *
+ */
+
+static int
+add_gpt_partitions(struct gendisk *hd, kdev_t dev, int nextminor)
+{
+	GuidPartitionTableHeader_t *gpt = NULL;
+	GuidPartitionEntry_t *ptes = NULL;
+	u32 i, nummade=0;
+
+	efi_guid_t unusedGuid = UNUSED_ENTRY_GUID;
+#if CONFIG_BLK_DEV_MD
+	efi_guid_t raidGuid = PARTITION_LINUX_RAID_GUID;
+#endif
+
+	if (!hd) return -1;
+
+	if (!FindValidGPT(hd, dev, &gpt, &ptes) ||
+	    !gpt || !ptes) {
+		if (gpt) kfree(gpt);
+		if (ptes) kfree(ptes);
+		return 0;
+	}
+
+	debug_printk(efi_printk_level "GUID Partition Table is valid!  Yea!\n");
+
+#ifdef CONFIG_DEVFS_GUID
+	set_partition_guid (hd, nextminor - 1, &(gpt->DiskGUID));
+#endif
+
+	for (i = 0; i < gpt->NumberOfPartitionEntries &&
+		     nummade < (hd->max_p - 1); i++) {
+		if (!efi_guidcmp(unusedGuid, ptes[i].PartitionTypeGuid))
+			continue;
+
+		add_gd_partition(hd, nextminor, ptes[i].StartingLBA,
+				 (ptes[i].EndingLBA-ptes[i].StartingLBA + 1));
+
+#ifdef CONFIG_DEVFS_GUID
+		set_partition_guid (hd, nextminor, &(ptes[i].UniquePartitionGuid));
+#endif
+
+		/* If there's this is a RAID volume, tell md */
+#if CONFIG_BLK_DEV_MD
+		if (!efi_guidcmp(raidGuid, ptes[i].PartitionTypeGuid)) {
+			md_autodetect_dev(MKDEV(MAJOR(dev),nextminor));
+		}
+#endif
+		nummade++;
+		nextminor++;
+
+	}
+	kfree(ptes);
+	kfree(gpt);
+	printk("\n");
+	return 1;
+
+}
+
+
+/*
+ * efi_partition()
+ *
+ * If the first block on the disk is a legacy MBR,
+ * it got handled already by msdos_partition().
+ * If it's a Protective MBR, we'll handle it here.
+ *
+ * Returns:
+ * -1 if unable to read the partition table
+ *  0 if this isn't our partitoin table
+ *  1 if successful
+ *
+ */
+
+int
+efi_partition(struct gendisk *hd, kdev_t dev,
+	      unsigned long first_sector, int first_part_minor) {
+	int hardblocksize = get_hardsect_size(dev);
+	int orig_blksize_size = BLOCK_SIZE;
+	int rc = 0;
+
+	/* Need to change the block size that the block layer uses */
+	if (blksize_size[MAJOR(dev)]){
+		orig_blksize_size = blksize_size[MAJOR(dev)][MINOR(dev)];
+	}
+
+	if (orig_blksize_size != hardblocksize)
+		set_blocksize(dev, hardblocksize);
+
+	rc = add_gpt_partitions(hd, dev, first_part_minor);
+
+	/* change back */
+	if (orig_blksize_size != hardblocksize)
+		set_blocksize(dev, orig_blksize_size);
+
+	return rc;
+}
+
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urN linux.orig/fs/partitions/efi.h linux/fs/partitions/efi.h
--- linux.orig/fs/partitions/efi.h	Wed Dec 31 17:00:00 1969
+++ linux/fs/partitions/efi.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,154 @@
+/************************************************************
+ * EFI GUID Partition Table
+ * Per Intel EFI Specification v0.99
+ * http://developer.intel.com/technology/efi/efi.htm
+ *
+ * By Matt Domsch <Matt_Domsch@dell.com>  Fri Sep 22 22:15:56 CDT 2000  
+ *   Copyright 2000 Dell Computer Corporation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ ************************************************************/
+
+#ifndef FS_PART_EFI_H_INCLUDED
+#define FS_PART_EFI_H_INCLUDED
+
+#include <linux/types.h>
+#include <asm/efi.h>
+
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/genhd.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+
+#define MSDOS_MBR_SIGNATURE 0xaa55
+#define EFI_PMBR_OSTYPE_EFI 0xEF
+#define EFI_PMBR_OSTYPE_EFI_GPT 0xEE
+
+#define GUID_PT_BLOCK_SIZE 512
+
+#define GUID_PT_HEADER_SIGNATURE 0x5452415020494645L
+#define GUID_PT_HEADER_REVISION_V1 0x00010000
+#define GUID_PT_HEADER_REVISION_V0_99 0x00000099
+#define UNUSED_ENTRY_GUID    \
+    ((efi_guid_t) { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }})
+#define PARTITION_SYSTEM_GUID \
+((efi_guid_t) { 0xC12A7328, 0xF81F, 0x11d2, { 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B }})
+#define LEGACY_MBR_PARTITION_GUID \
+    ((efi_guid_t) { 0x024DEE41, 0x33E7, 0x11d3, { 0x9D, 0x69, 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F }})
+#define PARTITION_MSFT_RESERVED_GUID \
+    ((efi_guid_t) { 0xE3C9E316, 0x0B5C, 0x4DB8, { 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE }})
+#define PARTITION_BASIC_DATA_GUID \
+    ((efi_guid_t) { 0xEBD0A0A2, 0xB9E5, 0x4433, { 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7 }})
+#define PARTITION_LINUX_RAID_GUID \
+    ((efi_guid_t) { 0xa19d880f, 0x05fc, 0x4d3b, { 0xa0, 0x06, 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e  }})
+#define PARTITION_LINUX_SWAP_GUID \
+    ((efi_guid_t) { 0x0657fd6d, 0xa4ab, 0x43c4, { 0x84, 0xe5, 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f  }})
+
+typedef struct _GuidPartitionTableHeader_t {
+  u64 Signature;
+  u32 Revision;
+  u32 HeaderSize;
+  u32 HeaderCRC32;
+  u32 Reserved1;
+  u64 MyLBA;
+  u64 AlternateLBA;
+  u64 FirstUsableLBA;
+  u64 LastUsableLBA;
+  efi_guid_t DiskGUID;
+  u64 PartitionEntryLBA;
+  u32 NumberOfPartitionEntries;
+  u32 SizeOfPartitionEntry;
+  u32 PartitionEntryArrayCRC32;
+  u8 Reserved2[GUID_PT_BLOCK_SIZE - 92];
+} GuidPartitionTableHeader_t;
+
+typedef struct _GuidPartitionEntryAttributes_t {
+  __u64 RequiredToFunction:1;
+  __u64 Reserved:63;
+} GuidPartitionEntryAttributes_t;
+
+typedef struct _GuidPartitionEntry_t {
+  efi_guid_t PartitionTypeGuid;
+  efi_guid_t UniquePartitionGuid;
+  u64 StartingLBA;
+  u64 EndingLBA;
+  GuidPartitionEntryAttributes_t Attributes;
+  efi_char16_t PartitionName[72/sizeof(efi_char16_t)];
+} GuidPartitionEntry_t;
+
+
+
+typedef struct _PartitionRecord_t {
+  u8 BootIndicator;  /* Not used by EFI firmware. Set to 0x80 to indicate that this
+                        is the bootable legacy partition. */
+  u8 StartHead;      /* Start of partition in CHS address, not used by EFI firmware. */
+  u8 StartSector;    /* Start of partition in CHS address, not used by EFI firmware. */
+  u8 StartTrack;     /* Start of partition in CHS address, not used by EFI firmware. */
+  u8 OSType;         /* OS type. A value of 0xEF defines an EFI system partition.
+                        Other values are reserved for legacy operating systems, and
+                        allocated independently of the EFI specification. */
+  u8 EndHead;        /* End of partition in CHS address, not used by EFI firmware. */
+  u8 EndSector;      /* End of partition in CHS address, not used by EFI firmware. */
+  u8 EndTrack;       /* End of partition in CHS address, not used by EFI firmware. */
+  u32 StartingLBA;   /* Starting LBA address of the partition on the disk. Used by
+                        EFI firmware to define the start of the partition. */
+  u32 SizeInLBA;     /* Size of partition in LBA. Used by EFI firmware to determine
+                        the size of the partition. */
+} PartitionRecord_t;
+
+typedef struct _LegacyMBR_t {
+  u8 BootCode[440];
+  u32 UniqueMBRSignature;
+  u16 Unknown;
+  PartitionRecord_t PartitionRecord[4];
+  u16 Signature;
+} __attribute__ ((packed)) LegacyMBR_t;
+
+
+
+#define EFI_GPT_PRIMARY_PARTITION_TABLE_LBA 1
+
+/* Functions */
+extern int
+efi_partition(struct gendisk *hd, kdev_t dev,
+              unsigned long first_sector, int first_part_minor);
+
+
+
+
+#endif
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * --------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4 
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urN linux.orig/fs/partitions/msdos.c linux/fs/partitions/msdos.c
--- linux.orig/fs/partitions/msdos.c	Sat Jul 28 13:50:13 2001
+++ linux/fs/partitions/msdos.c	Mon Dec 17 20:27:41 2001
@@ -36,6 +36,10 @@
 #include "check.h"
 #include "msdos.h"
 
+#ifdef CONFIG_EFI_PARTITION
+#include "efi.h"
+#endif
+
 #if CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(kdev_t dev);
 #endif
@@ -454,6 +458,16 @@
 		return 0;
 	}
 	p = (struct partition *) (data + 0x1be);
+#ifdef CONFIG_EFI_PARTITION
+	for (i=1 ; i<=4 ; i++,p++) {
+		/* If this is an EFI GPT disk, msdos should ignore it. */
+		if (SYS_IND(p) == EFI_PMBR_OSTYPE_EFI_GPT) {
+			bforget(bh);
+			return 0;
+		}
+	}
+	p = (struct partition *) (data + 0x1be);
+#endif
 
 #ifdef CONFIG_BLK_DEV_IDE
 	if (!tested_for_xlate++) {	/* Do this only once per disk */
diff -urN linux.orig/fs/proc/base.c linux/fs/proc/base.c
--- linux.orig/fs/proc/base.c	Fri Jul 20 13:39:56 2001
+++ linux/fs/proc/base.c	Mon Dec 17 20:27:41 2001
@@ -419,7 +419,24 @@
 }
 #endif
 
+static loff_t mem_lseek(struct file * file, loff_t offset, int orig)
+{
+	switch (orig) {
+	      case 0:
+		file->f_pos = offset;
+		break;
+	      case 1:
+		file->f_pos += offset;
+		break;
+	      default:
+		return -EINVAL;
+	}
+	force_successful_syscall_return();
+	return file->f_pos;
+}
+
 static struct file_operations proc_mem_operations = {
+	llseek:		mem_lseek,
 	read:		mem_read,
 	write:		mem_write,
 	open:		mem_open,
diff -urN linux.orig/include/asm-alpha/processor.h linux/include/asm-alpha/processor.h
--- linux.orig/include/asm-alpha/processor.h	Sat Dec 30 10:35:40 2000
+++ linux/include/asm-alpha/processor.h	Mon Dec 17 20:27:41 2001
@@ -149,4 +149,25 @@
 #define init_task	(init_task_union.task)
 #define init_stack	(init_task_union.stack)
 
+#define ARCH_HAS_PREFETCH
+#define ARCH_HAS_PREFETCHW
+#define ARCH_HAS_SPINLOCK_PREFETCH
+
+extern inline void prefetch(const void *ptr)  
+{ 
+	__asm__ ("ldl $31,%0" : : "m"(*(char *)ptr)); 
+}
+
+extern inline void prefetchw(const void *ptr)  
+{
+	__asm__ ("ldl $31,%0" : : "m"(*(char *)ptr)); 
+}
+
+extern inline void prefetch_spin_lock(const void *ptr)  
+{
+	__asm__ ("ldl $31,%0" : : "m"(*(char *)ptr)); 
+}
+	
+
+
 #endif /* __ASM_ALPHA_PROCESSOR_H */
diff -urN linux.orig/include/asm-i386/processor.h linux/include/asm-i386/processor.h
--- linux.orig/include/asm-i386/processor.h	Wed Aug 15 15:21:11 2001
+++ linux/include/asm-i386/processor.h	Mon Dec 17 20:27:41 2001
@@ -477,4 +477,32 @@
 	__asm__ __volatile__("rep;nop");
 }
 
+/* Prefetch instructions for Pentium III and AMD Athlon */
+#ifdef 	CONFIG_MPENTIUMIII
+
+#define ARCH_HAS_PREFETCH
+extern inline void prefetch(const void *x)
+{
+	__asm__ __volatile__ ("prefetchnta (%0)" : : "r"(x));
+}
+
+#elif CONFIG_X86_USE_3DNOW
+
+#define ARCH_HAS_PREFETCH
+#define ARCH_HAS_PREFETCHW
+#define ARCH_HAS_SPINLOCK_PREFETCH
+
+extern inline void prefetch(const void *x)
+{
+	 __asm__ __volatile__ ("prefetch (%0)" : : "r"(x));
+}
+
+extern inline void prefetchw(const void *x)
+{
+	 __asm__ __volatile__ ("prefetch (%0)" : : "r"(x));
+}
+#define prefetch_spin_lock(x)	prefetchw(x)
+
+#endif
+
 #endif /* __ASM_I386_PROCESSOR_H */
diff -urN linux.orig/include/asm-i386/uaccess.h linux/include/asm-i386/uaccess.h
--- linux.orig/include/asm-i386/uaccess.h	Wed Aug 15 15:21:12 2001
+++ linux/include/asm-i386/uaccess.h	Mon Dec 17 20:27:41 2001
@@ -6,6 +6,7 @@
  */
 #include <linux/config.h>
 #include <linux/sched.h>
+#include <linux/prefetch.h>
 #include <asm/page.h>
 
 #define VERIFY_READ 0
@@ -526,6 +527,7 @@
 static inline unsigned long
 __constant_copy_to_user(void *to, const void *from, unsigned long n)
 {
+	prefetch(from);
 	if (access_ok(VERIFY_WRITE, to, n))
 		__constant_copy_user(to,from,n);
 	return n;
diff -urN linux.orig/include/asm-ia64/acpi-ext.h linux/include/asm-ia64/acpi-ext.h
--- linux.orig/include/asm-ia64/acpi-ext.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/acpi-ext.h	Mon Dec 17 20:27:41 2001
@@ -9,7 +9,7 @@
  * Copyright (C) 1999 VA Linux Systems
  * Copyright (C) 1999 Walt Drummond <drummond@valinux.com>
  * Copyright (C) 2000 Intel Corp.
- * Copyright (C) 2000 J.I. Lee <jung-ik.lee@intel.com>
+ * Copyright (C) 2000,2001 J.I. Lee <jung-ik.lee@intel.com>
  *	ACPI 2.0 specification
  */
 
@@ -178,6 +178,12 @@
 	unsigned long lapic_address;
 } acpi20_entry_lapic_addr_override_t;
 
+#define ACPI_SPCRT_SIG	"SPCR"
+#define ACPI_SPCRT_SIG_LEN 4
+
+#define ACPI_DBGPT_SIG	"DBGP"
+#define ACPI_DBGPT_SIG_LEN 4
+
 typedef struct {
 	u8 type;
 	u8 length;
@@ -189,9 +195,16 @@
 	u32 global_vector;
 } acpi20_entry_platform_src_t;
 
+/* constants for interrupt routing API for device drivers */
+#define	ACPI20_ENTRY_PIS_PMI	1
+#define	ACPI20_ENTRY_PIS_INIT	2
+#define	ACPI20_ENTRY_PIS_CPEI	3
+#define	ACPI_MAX_PLATFORM_IRQS	4
+
 extern int acpi20_parse(acpi20_rsdp_t *);
 extern int acpi_parse(acpi_rsdp_t *);
 extern const char *acpi_get_sysname (void);
+extern int acpi_request_vector(u32 int_type);
 
 extern void (*acpi_idle) (void);	/* power-management idle function, if any */
 #pragma	pack()
diff -urN linux.orig/include/asm-ia64/efi.h linux/include/asm-ia64/efi.h
--- linux.orig/include/asm-ia64/efi.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/efi.h	Mon Dec 17 20:27:41 2001
@@ -239,6 +239,7 @@
 extern void efi_gettimeofday (struct timeval *tv);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
 extern u64  efi_get_iobase (void);
+extern int  efi_page_is_ram (u64 phys_addr);
 
 /*
  * Variable Attributes
diff -urN linux.orig/include/asm-ia64/ia32.h linux/include/asm-ia64/ia32.h
--- linux.orig/include/asm-ia64/ia32.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/ia32.h	Mon Dec 17 20:27:41 2001
@@ -34,6 +34,8 @@
 
 #define IA32_PAGE_SHIFT		12	/* 4KB pages */
 #define IA32_PAGE_SIZE		(1ULL << IA32_PAGE_SHIFT)
+#define IA32_PAGE_MASK		(~(IA32_PAGE_SIZE - 1))
+#define IA32_PAGE_ALIGN(addr)	(((addr) + IA32_PAGE_SIZE - 1) & IA32_PAGE_MASK)
 #define IA32_CLOCKS_PER_SEC	100	/* Cast in stone for IA32 Linux */
 #define IA32_TICK(tick)		((unsigned long long)(tick) * IA32_CLOCKS_PER_SEC / CLOCKS_PER_SEC)
 
@@ -421,6 +423,7 @@
 extern void ia32_init_addr_space (struct pt_regs *regs);
 extern int ia32_setup_arg_pages (struct linux_binprm *bprm);
 extern int ia32_exception (struct pt_regs *regs, unsigned long isr);
+extern unsigned long ia32_do_mmap (struct file *, unsigned long, unsigned long, int, int, loff_t);
 
 #endif /* !CONFIG_IA32_SUPPORT */
 
diff -urN linux.orig/include/asm-ia64/io.h linux/include/asm-ia64/io.h
--- linux.orig/include/asm-ia64/io.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/io.h	Mon Dec 17 20:27:41 2001
@@ -43,7 +43,7 @@
 }
 
 static inline void*
-phys_to_virt(unsigned long address)
+phys_to_virt (unsigned long address)
 {
 	return (void *) (address + PAGE_OFFSET);
 }
@@ -54,6 +54,7 @@
  */
 #define bus_to_virt	phys_to_virt
 #define virt_to_bus	virt_to_phys
+#define page_to_bus	page_to_phys
 
 # endif /* KERNEL */
 
diff -urN linux.orig/include/asm-ia64/iosapic.h linux/include/asm-ia64/iosapic.h
--- linux.orig/include/asm-ia64/iosapic.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/iosapic.h	Mon Dec 17 20:27:41 2001
@@ -53,8 +53,14 @@
 
 extern void __init iosapic_init (unsigned long address, unsigned int base_irq,
                                  int pcat_compat);
+extern int iosapic_register_irq (u32 global_vector, unsigned long polarity,
+                                 unsigned long edge_triggered, u32 base_irq,
+                                 char *iosapic_address);
 extern void iosapic_register_legacy_irq (unsigned long irq, unsigned long pin,
 					 unsigned long polarity, unsigned long trigger);
+extern int iosapic_register_platform_irq (u32 int_type, u32 global_vector, u32 iosapic_vector, u16 eid, u16 id, unsigned long polarity, unsigned long edge_triggered, u32 base_irq, char *iosapic_address);
+extern unsigned int iosapic_version (char *addr);
+
 extern void iosapic_pci_fixup (int);
 
 # endif /* !__ASSEMBLY__ */
diff -urN linux.orig/include/asm-ia64/keyboard.h linux/include/asm-ia64/keyboard.h
--- linux.orig/include/asm-ia64/keyboard.h	Fri Apr 21 17:38:40 2000
+++ linux/include/asm-ia64/keyboard.h	Mon Dec 17 20:27:41 2001
@@ -2,16 +2,16 @@
 #define _ASM_IA64_KEYBOARD_H
 
 /*
- * This file contains the ia-64 architecture specific keyboard
- * definitions.
+ * This file contains the ia64 architecture specific keyboard definitions.
  *
- * Copyright (C) 1998, 1999 Hewlett-Packard Co
- * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1998, 1999, 2001 Hewlett-Packard Co
+ * Copyright (C) 1998, 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
 # ifdef __KERNEL__
 
 #include <linux/irq.h>
+#include <linux/kd.h>
 
 #define KEYBOARD_IRQ			isa_irq_to_vector(1)
 #define DISABLE_KBD_DURING_INTERRUPTS	0
@@ -23,6 +23,7 @@
 			   char raw_mode);
 extern char pckbd_unexpected_up(unsigned char keycode);
 extern void pckbd_leds(unsigned char leds);
+extern int pckbd_rate(struct kbd_repeat *rep);
 extern void pckbd_init_hw(void);
 extern unsigned char pckbd_sysrq_xlate[128];
 
@@ -32,12 +33,14 @@
 #define kbd_translate		pckbd_translate
 #define kbd_unexpected_up	pckbd_unexpected_up
 #define kbd_leds		pckbd_leds
+#define kbd_rate		pckbd_rate
 #define kbd_init_hw		pckbd_init_hw
 #define kbd_sysrq_xlate		pckbd_sysrq_xlate
 
 #define INIT_KBD
 
 #define SYSRQ_KEY		0x54
+#define E1_PAUSE   119		/* PAUSE key */
 
 /* resource allocation */
 #define kbd_request_region()
diff -urN linux.orig/include/asm-ia64/mca.h linux/include/asm-ia64/mca.h
--- linux.orig/include/asm-ia64/mca.h	Thu Apr  5 13:51:47 2001
+++ linux/include/asm-ia64/mca.h	Mon Dec 17 20:27:41 2001
@@ -8,7 +8,7 @@
  */
 
 /* XXX use this temporary define for MP systems trying to INIT */
-#define SAL_MPINIT_WORKAROUND
+#undef SAL_MPINIT_WORKAROUND
 
 #ifndef _ASM_IA64_MCA_H
 #define _ASM_IA64_MCA_H
@@ -128,7 +128,11 @@
 extern void ia64_mca_rendez_int_handler(int,void *,struct pt_regs *);
 extern void ia64_mca_wakeup_int_handler(int,void *,struct pt_regs *);
 extern void ia64_mca_cmc_int_handler(int,void *,struct pt_regs *);
-extern void ia64_log_print(int,int,prfunc_t);
+extern void ia64_mca_cpe_int_handler(int,void *,struct pt_regs *);
+extern void ia64_log_print(int,prfunc_t);
+extern void ia64_mca_cmc_vector_setup(void);
+extern void ia64_mca_check_errors( void );
+extern u64  ia64_log_get(int, prfunc_t);
 
 #define PLATFORM_CALL(fn, args)	printk("Platform call TBD\n")
 
diff -urN linux.orig/include/asm-ia64/mca_asm.h linux/include/asm-ia64/mca_asm.h
--- linux.orig/include/asm-ia64/mca_asm.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/mca_asm.h	Mon Dec 17 20:27:41 2001
@@ -41,7 +41,7 @@
  */
 #define DATA_PA_TO_VA(addr,temp)							\
 	mov	temp	= 0x7	;;							\
-	dep	addr	= temp, addr, 61, 3;
+	dep	addr	= temp, addr, 61, 3;;
 
 /*
  * This macro jumps to the instruction at the given virtual address
@@ -74,6 +74,7 @@
 											\
 	mov	ar.rsc = 0 ;								\
 	;;										\
+	srlz.d;										\
 	mov	temp2 = ar.bspstore;							\
 	;;										\
 	DATA_VA_TO_PA(temp2);								\
@@ -102,6 +103,8 @@
 	;;										\
 	dep	temp1 = 0, temp1, PSR_I, 1;						\
 	;;										\
+	dep	temp1 = 0, temp1, PSR_IC, 1;						\
+	;;										\
 	movl	temp2 = start_addr;							\
 	mov	cr.ipsr = temp1;							\
 	;;										\
@@ -145,6 +148,8 @@
 #define VIRTUAL_MODE_ENTER(temp1, temp2, start_addr, old_psr)	\
 	mov	temp2 = psr;					\
 	;;							\
+	mov	old_psr = temp2;				\
+	;;							\
 	dep	temp2 = 0, temp2, PSR_IC, 2;			\
 	;;							\
 	mov	psr.l = temp2;					\
@@ -163,7 +168,7 @@
 	;;							\
 	mov	temp1 = old_psr;				\
 	;;							\
-	mov	temp2 = 1					\
+	mov	temp2 = 1;					\
 	;;							\
 	dep	temp1 = temp2, temp1, PSR_I,  1;		\
 	;;							\
@@ -182,8 +187,10 @@
 	movl	temp2 = start_addr;				\
 	;;							\
 	mov	cr.iip = temp2;					\
+	;;							\
 	DATA_PA_TO_VA(sp, temp1);				\
 	DATA_PA_TO_VA(gp, temp2);				\
+	srlz.i;							\
 	;;							\
 	nop	1;						\
 	nop	2;						\
@@ -246,7 +253,7 @@
 	mov     ar.bspstore=p_bspstore;;					\
 	mov     temp=ar.bsp;;							\
 	sub     temp=temp,p_bspstore;;						\
-	st8     [p_stackframe]=temp,8
+	st8     [p_stackframe]=temp,8;;
 
 /*
  * rse_return_context
@@ -278,28 +285,20 @@
 	mov     ar.rnat=temp;;							\
 	add     p_stackframe=-rse_rnat_offset+rse_pfs_offset,p_stackframe;;	\
 	ld8     temp=[p_stackframe];;						\
-	mov     ar.pfs=temp;							\
+	mov     ar.pfs=temp;;							\
 	add     p_stackframe=-rse_pfs_offset+rse_ifs_offset,p_stackframe;;	\
 	ld8     temp=[p_stackframe];;						\
-	mov     cr.ifs=temp;							\
+	mov     cr.ifs=temp;;							\
 	add     p_stackframe=-rse_ifs_offset+rse_rsc_offset,p_stackframe;;	\
 	ld8     temp=[p_stackframe];;						\
 	mov     ar.rsc=temp ;							\
-	add     p_stackframe=-rse_rsc_offset,p_stackframe;			\
-	mov     temp=cr.ipsr;;							\
-	st8     [p_stackframe]=temp,8;						\
-	mov     temp=cr.iip;;							\
-	st8     [p_stackframe]=temp,-8;						\
 	mov     temp=psr;;							\
 	or      temp=temp,psr_mask_reg;;					\
 	mov     cr.ipsr=temp;;							\
 	mov     temp=ip;;							\
 	add     temp=0x30,temp;;						\
 	mov     cr.iip=temp;;							\
-	rfi;;									\
-	ld8     temp=[p_stackframe],8;;						\
-	mov     cr.ipsr=temp;;							\
-	ld8     temp=[p_stackframe];;						\
-	mov     cr.iip=temp
+	srlz.i;;								\
+	rfi;;
 
 #endif /* _ASM_IA64_MCA_ASM_H */
diff -urN linux.orig/include/asm-ia64/offsets.h linux/include/asm-ia64/offsets.h
--- linux.orig/include/asm-ia64/offsets.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/offsets.h	Mon Dec 17 20:27:41 2001
@@ -1,14 +1,17 @@
 #ifndef _ASM_IA64_OFFSETS_H
 #define _ASM_IA64_OFFSETS_H
+
 /*
  * DO NOT MODIFY
  *
- * This file was generated by arch/ia64/tools/print_offsets.awk.
+ * This file was generated by arch/ia64/tools/print_offsets.
  *
  */
-#define PT_PTRACED_BIT		0
-#define PT_TRACESYS_BIT		1
-#define IA64_TASK_SIZE			3904	/* 0xf40 */
+
+#define PT_PTRACED_BIT			0
+#define PT_TRACESYS_BIT			1
+
+#define IA64_TASK_SIZE			2800	/* 0xaf0 */
 #define IA64_PT_REGS_SIZE		400	/* 0x190 */
 #define IA64_SWITCH_STACK_SIZE		560	/* 0x230 */
 #define IA64_SIGINFO_SIZE		128	/* 0x80 */
@@ -20,10 +23,8 @@
 #define IA64_TASK_SIGPENDING_OFFSET	16	/* 0x10 */
 #define IA64_TASK_NEED_RESCHED_OFFSET	40	/* 0x28 */
 #define IA64_TASK_PROCESSOR_OFFSET	100	/* 0x64 */
-#define IA64_TASK_THREAD_OFFSET		1456	/* 0x5b0 */
-#define IA64_TASK_THREAD_KSP_OFFSET	1456	/* 0x5b0 */
-#define IA64_TASK_THREAD_SIGMASK_OFFSET	1568	/* 0x620 */
-#define IA64_TASK_PFM_NOTIFY_OFFSET	2088	/* 0x828 */
+#define IA64_TASK_THREAD_OFFSET		960	/* 0x3c0 */
+#define IA64_TASK_THREAD_KSP_OFFSET	960	/* 0x3c0 */
 #define IA64_TASK_PID_OFFSET		196	/* 0xc4 */
 #define IA64_TASK_MM_OFFSET		88	/* 0x58 */
 #define IA64_PT_REGS_CR_IPSR_OFFSET	0	/* 0x0 */
@@ -73,7 +74,7 @@
 #define IA64_PT_REGS_F8_OFFSET		368	/* 0x170 */
 #define IA64_PT_REGS_F9_OFFSET		384	/* 0x180 */
 #define IA64_SWITCH_STACK_CALLER_UNAT_OFFSET 0	/* 0x0 */
-#define IA64_SWITCH_STACK_AR_FPSR_OFFSET 8	/* 0x8 */
+#define IA64_SWITCH_STACK_AR_FPSR_OFFSET	8	/* 0x8 */
 #define IA64_SWITCH_STACK_F2_OFFSET	16	/* 0x10 */
 #define IA64_SWITCH_STACK_F3_OFFSET	32	/* 0x20 */
 #define IA64_SWITCH_STACK_F4_OFFSET	48	/* 0x30 */
@@ -112,8 +113,8 @@
 #define IA64_SWITCH_STACK_B5_OFFSET	504	/* 0x1f8 */
 #define IA64_SWITCH_STACK_AR_PFS_OFFSET	512	/* 0x200 */
 #define IA64_SWITCH_STACK_AR_LC_OFFSET	520	/* 0x208 */
-#define IA64_SWITCH_STACK_AR_UNAT_OFFSET 528	/* 0x210 */
-#define IA64_SWITCH_STACK_AR_RNAT_OFFSET 536	/* 0x218 */
+#define IA64_SWITCH_STACK_AR_UNAT_OFFSET	528	/* 0x210 */
+#define IA64_SWITCH_STACK_AR_RNAT_OFFSET	536	/* 0x218 */
 #define IA64_SWITCH_STACK_AR_BSPSTORE_OFFSET 544	/* 0x220 */
 #define IA64_SWITCH_STACK_PR_OFFSET	552	/* 0x228 */
 #define IA64_SIGCONTEXT_AR_BSP_OFFSET	72	/* 0x48 */
@@ -132,10 +133,10 @@
 #define IA64_SIGFRAME_RBS_BASE_OFFSET	24	/* 0x18 */
 #define IA64_SIGFRAME_HANDLER_OFFSET	32	/* 0x20 */
 #define IA64_SIGFRAME_SIGCONTEXT_OFFSET	176	/* 0xb0 */
-#define IA64_CLONE_VFORK		16384	/* 0x4000 */
+#define IA64_CLONE_VFORK			16384	/* 0x4000 */
 #define IA64_CLONE_VM			256	/* 0x100 */
 #define IA64_CPU_IRQ_COUNT_OFFSET	0	/* 0x0 */
-#define IA64_CPU_BH_COUNT_OFFSET	4	/* 0x4 */
+#define IA64_CPU_BH_COUNT_OFFSET		4	/* 0x4 */
 #define IA64_CPU_PHYS_STACKED_SIZE_P8_OFFSET 12	/* 0xc */
 
 #endif /* _ASM_IA64_OFFSETS_H */
diff -urN linux.orig/include/asm-ia64/page.h linux/include/asm-ia64/page.h
--- linux.orig/include/asm-ia64/page.h	Thu Apr  5 13:51:47 2001
+++ linux/include/asm-ia64/page.h	Mon Dec 17 20:27:41 2001
@@ -55,12 +55,15 @@
 #ifdef CONFIG_IA64_GENERIC
 # include <asm/machvec.h>
 # define virt_to_page(kaddr)	(mem_map + platform_map_nr(kaddr))
+# define page_to_phys(page)	XXX fix me
 #elif defined (CONFIG_IA64_SGI_SN1)
 # ifndef CONFIG_DISCONTIGMEM
 #  define virt_to_page(kaddr)	(mem_map + MAP_NR_DENSE(kaddr))
+#  define page_to_phys(page)	XXX fix me
 # endif
 #else
 # define virt_to_page(kaddr)	(mem_map + MAP_NR_DENSE(kaddr))
+# define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
 #endif
 #define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
 
diff -urN linux.orig/include/asm-ia64/pci.h linux/include/asm-ia64/pci.h
--- linux.orig/include/asm-ia64/pci.h	Wed May 16 11:31:27 2001
+++ linux/include/asm-ia64/pci.h	Mon Dec 17 20:27:41 2001
@@ -62,4 +62,8 @@
 
 #define sg_dma_len(sg)		((sg)->length)
 
+#define HAVE_PCI_MMAP
+extern int pci_mmap_page_range (struct pci_dev *dev, struct vm_area_struct *vma,
+				enum pci_mmap_state mmap_state, int write_combine);
+
 #endif /* _ASM_IA64_PCI_H */
diff -urN linux.orig/include/asm-ia64/processor.h linux/include/asm-ia64/processor.h
--- linux.orig/include/asm-ia64/processor.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/processor.h	Mon Dec 17 20:27:41 2001
@@ -633,10 +633,11 @@
 }
 
 /*
- * Save the processor status flags in FLAGS and then clear the
- * interrupt collection and interrupt enable bits.
+ * Save the processor status flags in FLAGS and then clear the interrupt collection and
+ * interrupt enable bits.  Don't trigger any mandatory RSE references while this bit is
+ * off!
  */
-#define ia64_clear_ic(flags)							\
+#define ia64_clear_ic(flags)						\
 	asm volatile ("mov %0=psr;; rsm psr.i | psr.ic;; srlz.i;;"	\
 			      : "=r"(flags) :: "memory");
 
@@ -973,6 +974,26 @@
 	asm ("thash %0=%1" : "=r"(result) : "r" (addr));
 	return result;
 }
+
+#define ARCH_HAS_PREFETCH
+#define ARCH_HAS_PREFETCHW
+#define ARCH_HAS_SPINLOCK_PREFETCH
+
+#define PREFETCH_STRIDE		256
+
+extern inline void
+prefetch (const void *x)
+{
+	__asm__ __volatile__ ("lfetch [%0]" : : "r"(x));
+}
+
+extern inline void
+prefetchw (const void *x)
+{
+	__asm__ __volatile__ ("lfetch.excl [%0]" : : "r"(x));
+}
+
+#define prefetch_spin_lock(x)   prefetchw(x)
 
 #endif /* !__ASSEMBLY__ */
 
diff -urN linux.orig/include/asm-ia64/sal.h linux/include/asm-ia64/sal.h
--- linux.orig/include/asm-ia64/sal.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/sal.h	Mon Dec 17 20:27:41 2001
@@ -7,10 +7,14 @@
  * This is based on version 2.5 of the manual "IA-64 System
  * Abstraction Layer".
  *
+ * Copyright (C) 2001 Intel
+ * Copyright (C) 2001 Fred Lewis <frederick.v.lewis@intel.com>
  * Copyright (C) 1998, 1999, 2001 Hewlett-Packard Co
  * Copyright (C) 1998, 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
  * Copyright (C) 1999 Srinivasa Prasad Thirumalachar <sprasad@sprasad.engr.sgi.com>
  *
+ * 01/01/03 fvlewis Updated Error Record Structures to conform with Nov. 2000
+ *                  revision of the SAL spec.
  * 99/09/29 davidm	Updated for SAL 2.6.
  * 00/03/29 cfleck      Updated SAL Error Logging info for processor (SAL 2.6) 
  *                      (plus examples of platform error info structures from smariset @ Intel)
@@ -19,7 +23,9 @@
 #include <linux/spinlock.h>
 
 #include <asm/pal.h>
+#include <asm/efi.h>
 #include <asm/system.h>
+#include <asm/fpu.h>
 
 extern spinlock_t sal_lock;
 
@@ -199,19 +205,15 @@
 enum {
 	SAL_INFO_TYPE_MCA	=		0,	/* Machine check abort information */
         SAL_INFO_TYPE_INIT	=		1,	/* Init information */
-        SAL_INFO_TYPE_CMC	=		2 	/* Corrected machine check information */
-};
-
-/* Sub information type encodings */
-enum {
-        SAL_SUB_INFO_TYPE_PROCESSOR	=	0,	/* Processor information */
-        SAL_SUB_INFO_TYPE_PLATFORM	=	1	/* Platform information */
+        SAL_INFO_TYPE_CMC   =       2,  /* Corrected machine check information */
+        SAL_INFO_TYPE_CPE   =       3   /* Corrected platform error information */
 };
 
 /* Encodings for machine check parameter types */
 enum {
         SAL_MC_PARAM_RENDEZ_INT		=	1,	/* Rendezevous interrupt */
-        SAL_MC_PARAM_RENDEZ_WAKEUP	=	2	/* Wakeup */
+        SAL_MC_PARAM_RENDEZ_WAKEUP  =   2,  /* Wakeup */
+        SAL_MC_PARAM_CPE_INT        =   3   /* Corrected Platform Error Int */
 };
 
 /* Encodings for rendezvous mechanisms */
@@ -227,174 +229,389 @@
 	SAL_VECTOR_OS_BOOT_RENDEZ	= 2
 };
 
-/* Definition of the SAL Error Log from the SAL spec */
+/*
+** Definition of the SAL Error Log from the SAL spec
+*/
 
-/* Definition of timestamp according to SAL spec for logging purposes */
+/* SAL Error Record Section GUID Definitions */
+#define SAL_PROC_DEV_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_MEM_DEV_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_SEL_DEV_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_PCI_BUS_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_SMBIOS_DEV_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_PCI_COMP_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_SPECIFIC_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_HOST_CTLR_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+#define SAL_PLAT_BUS_ERR_SECT_GUID  \
+    ((efi_guid_t) { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 }} )
+
+#define MAX_CACHE_ERRORS			6
+#define MAX_TLB_ERRORS				6
+#define MAX_BUS_ERRORS				1
+
+/* Definition of version  according to SAL spec for logging purposes */
+typedef struct sal_log_revision
+{
+    u8  minor;              /* BCD (0..99) */
+    u8  major;              /* BCD (0..99) */
+} sal_log_revision_t;
 
-typedef struct sal_log_timestamp {
-	u8 slh_century;		/* Century (19, 20, 21, ...) */
-	u8 slh_year;		/* Year (00..99) */
-	u8 slh_month;		/* Month (1..12) */
-	u8 slh_day;		/* Day (1..31) */
-	u8 slh_reserved;					
-	u8 slh_hour;		/* Hour (0..23)	*/
-	u8 slh_minute;		/* Minute (0..59) */
+/* Definition of timestamp according to SAL spec for logging purposes */
+typedef struct sal_log_timestamp
+{
 	u8 slh_second;		/* Second (0..59) */
+    u8 slh_minute;      /* Minute (0..59) */
+    u8 slh_hour;        /* Hour (0..23) */
+    u8 slh_reserved;
+    u8 slh_day;         /* Day (1..31) */
+    u8 slh_month;       /* Month (1..12) */
+    u8 slh_year;        /* Year (00..99) */
+    u8 slh_century;     /* Century (19, 20, 21, ...) */
 } sal_log_timestamp_t;
 
+/* Definition of log record  header structures */
+typedef struct sal_log_record_header
+{
+    u64                 id;             /* Unique monotonically increasing ID */
+    sal_log_revision_t  revision;       /* Major and Minor revision of header */
+    u16                 severity;       /* Error Severity */
+    u32                 len;            /* Length of this error log in bytes */
+    sal_log_timestamp_t timestamp;      /* Timestamp */
+    efi_guid_t          platform_guid;  /* Unique OEM Platform ID */
+} sal_log_record_header_t;
 
-#define MAX_CACHE_ERRORS			6
-#define MAX_TLB_ERRORS				6
-#define MAX_BUS_ERRORS				1
+/* Definition of log section header structures */
+typedef struct sal_log_sec_header
+{
+    efi_guid_t          guid;       /* Unique Section ID */
+    sal_log_revision_t  revision;   /* Major and Minor revision of Section */
+    u16                 reserved;
+    u32                 len;        /* Section length */
+} sal_log_section_hdr_t;
+
+typedef struct sal_log_mod_error_info
+{
+    struct
+    {
+        u64 check_info              : 1,
+            requestor_identifier    : 1,
+            responder_identifier    : 1,
+            target_identifier       : 1,
+            precise_ip              : 1,
+            reserved                : 59;
+    } valid;
+    u64 check_info;
+    u64 requestor_identifier;
+    u64 responder_identifier;
+    u64 target_identifier;
+    u64 precise_ip;
+} sal_log_mod_error_info_t;
+
+typedef struct sal_processor_static_info
+{
+    struct
+    {
+        u64 minstate        : 1,
+            br              : 1,
+            cr              : 1,
+            ar              : 1,
+            rr              : 1,
+            fr              : 1,
+            reserved        : 58;
+    } valid;
+    pal_min_state_area_t    min_state_area;
+    u64                     br[8];
+    u64                     cr[128];
+    u64                     ar[128];
+    u64                     rr[8];
+    struct ia64_fpreg       fr[128];
+} sal_processor_static_info_t;
 
-typedef struct sal_log_processor_info {
-	struct	{
-		u64 slpi_psi		: 1,
-		    slpi_cache_check: MAX_CACHE_ERRORS,
-		    slpi_tlb_check	: MAX_TLB_ERRORS,
-		    slpi_bus_check	: MAX_BUS_ERRORS,
-		    slpi_reserved2	: (31 - (MAX_TLB_ERRORS + MAX_CACHE_ERRORS
-		    			 + MAX_BUS_ERRORS)),
-		    slpi_minstate	: 1,
-		    slpi_bank1_gr	: 1,
-		    slpi_br		: 1,
-		    slpi_cr		: 1,
-		    slpi_ar		: 1,
-		    slpi_rr		: 1,
-		    slpi_fr		: 1,
-		    slpi_reserved1	: 25;
-	} slpi_valid;
-
-	pal_processor_state_info_t slpi_processor_state_info;
-
-	struct {
-		pal_cache_check_info_t slpi_cache_check;
-		u64 slpi_target_address;
-	} slpi_cache_check_info[MAX_CACHE_ERRORS];
-		
-	pal_tlb_check_info_t slpi_tlb_check_info[MAX_TLB_ERRORS];
-
-	struct {
-		pal_bus_check_info_t slpi_bus_check;
-		u64 slpi_requestor_addr;	
-		u64 slpi_responder_addr;	
-		u64 slpi_target_addr;
-	} slpi_bus_check_info[MAX_BUS_ERRORS];
-
-	pal_min_state_area_t slpi_min_state_area;
-	u64 slpi_br[8];
-	u64 slpi_cr[128];
-	u64 slpi_ar[128];
-	u64 slpi_rr[8];
-	u64 slpi_fr[128];
+typedef struct sal_log_processor_info
+{
+    sal_log_section_hdr_t       header;
+    struct
+    {
+        u64 proc_error_map      : 1,
+            proc_state_param    : 1,
+            proc_cr_lid         : 1,
+            psi_static_struct   : 1,
+            num_cache_check     : 4,
+            num_tlb_check       : 4,
+            num_bus_check       : 4,
+            num_reg_file_check  : 4,
+            num_ms_check        : 4,
+            cpuid_info          : 1,
+            reserved1           : 39;
+    } valid;
+    u64                         proc_error_map;
+    u64                         proc_state_parameter;
+    u64                         proc_cr_lid;
+    sal_log_mod_error_info_t    cache_check_info[16];
+    sal_log_mod_error_info_t    tlb_check_info[16];
+    sal_log_mod_error_info_t    bus_check_info[16];
+    sal_log_mod_error_info_t    reg_file_check_info[16];
+    sal_log_mod_error_info_t    ms_check_info[16];
+    struct
+    {
+        u64 regs[5];
+        u64 reserved;
+    } cpuid_info;
+    sal_processor_static_info_t processor_static_info;
 } sal_log_processor_info_t;
 
 /* platform error log structures */
-typedef struct platerr_logheader {
-	u64 nextlog;		/* next log offset if present */
-	u64 loglength;		/* log length */
-	u64 logsubtype;		/* log subtype memory/bus/component */
-	u64 eseverity;		/* error severity */
-} ehdr_t;
-
-typedef struct sysmem_errlog {
-	ehdr_t lhdr;		/* header */
-	u64 vflag;		/* valid bits for each field in the log */
-	u64 addr;		/* memory address */
-	u64 data;		/* memory data */
-	u64 cmd;		/* command bus value if any */
-	u64 ctrl;		/* control bus value if any */
-	u64 addrsyndrome;	/* memory address ecc/parity syndrome bits */
-	u64 datasyndrome;	/* data ecc/parity syndrome */
-	u64 cacheinfo;		/* platform cache info as defined in pal spec. table 7-34 */
-} merrlog_t;
-
-typedef struct sysbus_errlog {
-	ehdr_t lhdr;		/* linkded list header */
-	u64 vflag;		/* valid bits for each field in the log */
-	u64 busnum;		/* bus number in error */
-	u64 reqaddr;		/* requestor address */
-	u64 resaddr;		/* responder address */
-	u64 taraddr;		/* target address */
-	u64 data;		/* requester r/w data */
-	u64 cmd;		/* bus commands */
-	u64 ctrl;		/* bus controls (be# &-0) */
-	u64 addrsyndrome;	/* addr bus ecc/parity bits */
-	u64 datasyndrome;	/* data bus ecc/parity bits */
-	u64 cmdsyndrome;	/* command bus ecc/parity bits */
-	u64 ctrlsyndrome;	/* control bus ecc/parity bits */
-} berrlog_t;
 
-/* platform error log structures */
-typedef struct syserr_chdr {	/* one header per component */
-	u64 busnum;		/* bus number on which the component resides */
-	u64 devnum;		/* same as device select */
-	u64 funcid;		/* function id of the device */
-	u64 devid;		/* pci device id */
-	u64 classcode;		/* pci class code for the device */
-	u64 cmdreg;		/* pci command reg value */
-	u64 statreg;		/* pci status reg value */
-} chdr_t;
-
-typedef struct cfginfo {
-	u64 cfgaddr;
-	u64 cfgval;
-} cfginfo_t;
-
-typedef struct sys_comperr {	/* per component */
-	ehdr_t lhdr;		/* linked list header */
-	u64 vflag;		/* valid bits for each field in the log */
-	chdr_t scomphdr;	
-	u64 numregpair;		/* number of reg addr/value pairs */
-	cfginfo_t cfginfo;
-} cerrlog_t;
-
-typedef struct sel_records {
-	ehdr_t lhdr;
-	u64 seldata;
-} isel_t;
-
-typedef struct plat_errlog {
-	u64 mbcsvalid;		/* valid bits for each type of log */
-	merrlog_t smemerrlog;	/* platform memory error logs */
-	berrlog_t sbuserrlog;	/* platform bus error logs */
-	cerrlog_t scomperrlog;	/* platform chipset error logs */
-	isel_t selrecord;	/* ipmi sel record */
-} platforminfo_t;
-
-/* over all log structure (processor+platform) */
-
-typedef union udev_specific_log {
-	sal_log_processor_info_t proclog;
-	platforminfo_t platlog;
-} devicelog_t;
-
-
-#define sal_log_processor_info_psi_valid		slpi_valid.spli_psi
-#define sal_log_processor_info_cache_check_valid	slpi_valid.spli_cache_check
-#define sal_log_processor_info_tlb_check_valid		slpi_valid.spli_tlb_check
-#define sal_log_processor_info_bus_check_valid		slpi_valid.spli_bus_check
-#define sal_log_processor_info_minstate_valid		slpi_valid.spli_minstate
-#define sal_log_processor_info_bank1_gr_valid		slpi_valid.slpi_bank1_gr
-#define sal_log_processor_info_br_valid			slpi_valid.slpi_br
-#define sal_log_processor_info_cr_valid			slpi_valid.slpi_cr
-#define sal_log_processor_info_ar_valid			slpi_valid.slpi_ar
-#define sal_log_processor_info_rr_valid			slpi_valid.slpi_rr
-#define sal_log_processor_info_fr_valid			slpi_valid.slpi_fr
-
-typedef struct sal_log_header {
-	u64 slh_next_log;	/* Offset of the next log from the beginning of this structure */
-	u32 slh_log_len;	/* Length of this error log in bytes */
-	u16 slh_log_type;	/* Type of log (0 - cpu ,1 - platform) */
-	u16 slh_log_sub_type;	/* SGI specific sub type */
-	sal_log_timestamp_t slh_log_timestamp;	/* Timestamp */
-} sal_log_header_t;
-
-/* SAL PSI log structure */
-typedef struct psilog {
-	sal_log_header_t sal_elog_header;
-	devicelog_t devlog;
-} ia64_psilog_t;
+typedef struct sal_log_mem_dev_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 error_status    : 1,
+            physical_addr   : 1,
+            addr_mask       : 1,
+            node            : 1,
+            card            : 1,
+            module          : 1,
+            bank            : 1,
+            device          : 1,
+            row             : 1,
+            column          : 1,
+            bit_position    : 1,
+            requestor_id    : 1,
+            responder_id    : 1,
+            target_id       : 1,
+            bus_spec_data   : 1,
+            oem_id          : 1,
+            oem_data        : 1,
+            reserved        : 47;
+    } valid;
+    u64             error_status;
+    u64             physical_addr;
+    u64             addr_mask;
+    u16             node;
+    u16             card;
+    u16             module;
+    u16             bank;
+    u16             device;
+    u16             row;
+    u16             column;
+    u16             bit_position;
+    u64             requestor_id;
+    u64             responder_id;
+    u64             target_id;
+    u64             bus_spec_data;
+    u8              oem_id[16];
+    u8              oem_data[1];        /* Variable length data */
+} sal_log_mem_dev_err_info_t;
+
+typedef struct sal_log_sel_dev_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 record_id       : 1,
+            record_type     : 1,
+            generator_id    : 1,
+            evm_rev         : 1,
+            sensor_type     : 1,
+            sensor_num      : 1,
+            event_dir       : 1,
+            event_data1     : 1,
+            event_data2     : 1,
+            event_data3     : 1,
+            reserved        : 54;
+    } valid;
+    u16             record_id;
+    u8              record_type;
+    u8              timestamp[4];
+    u16             generator_id;
+    u8              evm_rev;
+    u8              sensor_type;
+    u8              sensor_num;
+    u8              event_dir;
+    u8              event_data1;
+    u8              event_data2;
+    u8              event_data3;
+} sal_log_sel_dev_err_info_t;
+
+typedef struct sal_log_pci_bus_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 err_status      : 1,
+            err_type        : 1,
+            bus_id          : 1,
+            bus_address     : 1,
+            bus_data        : 1,
+            bus_cmd         : 1,
+            requestor_id    : 1,
+            responder_id    : 1,
+            target_id       : 1,
+            oem_data        : 1,
+            reserved        : 54;
+    } valid;
+    u64             err_status;
+    u16             err_type;
+    u16             bus_id;
+    u32             reserved;
+    u64             bus_address;
+    u64             bus_data;
+    u64             bus_cmd;
+    u64             requestor_id;
+    u64             responder_id;
+    u64             target_id;
+    u8              oem_data[1];        /* Variable length data */
+} sal_log_pci_bus_err_info_t;
+
+typedef struct sal_log_smbios_dev_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 event_type      : 1,
+            length          : 1,
+            time_stamp      : 1,
+            data            : 1,
+            reserved1       : 60;
+    } valid;
+    u8              event_type;
+    u8              length;
+    u8              time_stamp[6];
+    u8              data[1];  // data of variable length, length == slsmb_length
+} sal_log_smbios_dev_err_info_t;
+
+typedef struct sal_log_pci_comp_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 err_status      : 1,
+            comp_info       : 1,
+            num_mem_regs    : 1,
+            num_io_regs     : 1,
+            reg_data_pairs  : 1,
+            oem_data        : 1,
+            reserved        : 58;
+    } valid;
+    u64             err_status;
+    struct
+    {
+        u16 vendor_id;
+        u16 device_id;
+        u16 class_code;
+        u8  func_num;
+        u8  dev_num;
+        u8  bus_num;
+        u8  seg_num;
+        u8  reserved[6];
+    }               comp_info;
+    u32             num_mem_regs;
+    u32             num_io_regs;
+    u64             reg_data_pairs[1];
+    /* array of address/data register pairs is num_mem_regs + num_io_regs
+       elements long.  Each array element consists of a u64 address followed
+       by a u64 data value.  The oem_data array immediately follows the the
+       reg_data_pairs array */
+    u8              oem_data[1];        /* Variable length data */
+} sal_log_pci_comp_err_info_t;
+
+typedef struct sal_log_plat_specific_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 err_status      : 1,
+            guid            : 1,
+            oem_data        : 1,
+            reserved        : 61;
+    } valid;
+    u64             err_status;
+    efi_guid_t      guid;
+    u8              oem_data[1];      /* platform specific variable length data */
+} sal_log_plat_specific_err_info_t;
+
+typedef struct sal_log_host_ctlr_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 err_status      : 1,
+            requestor_id    : 1,
+            responder_id    : 1,
+            target_id       : 1,
+            bus_spec_data   : 1,
+            oem_data        : 1,
+            reserved        : 58;
+    } valid;
+    u64             err_status;
+    u64             requestor_id;
+    u64             responder_id;
+    u64             target_id;
+    u64             bus_spec_data;
+    u8              oem_data[1];        /* Variable length OEM data */
+} sal_log_host_ctlr_err_info_t;
+
+typedef struct sal_log_plat_bus_err_info
+{
+    sal_log_section_hdr_t   header;
+    struct
+    {
+        u64 err_status      : 1,
+            requestor_id    : 1,
+            responder_id    : 1,
+            target_id       : 1,
+            bus_spec_data   : 1,
+            oem_data        : 1,
+            reserved        : 58;
+    } valid;
+    u64             err_status;
+    u64             requestor_id;
+    u64             responder_id;
+    u64             target_id;
+    u64             bus_spec_data;
+    u8              oem_data[1];        /* Variable length OEM data */
+} sal_log_plat_bus_err_info_t;
+
+/* Overall platform error section structure */
+typedef union sal_log_platform_err_info
+{
+    sal_log_mem_dev_err_info_t          mem_dev_err;
+    sal_log_sel_dev_err_info_t          sel_dev_err;
+    sal_log_pci_bus_err_info_t          pci_bus_err;
+    sal_log_smbios_dev_err_info_t       smbios_dev_err;
+    sal_log_pci_comp_err_info_t         pci_comp_err;
+    sal_log_plat_specific_err_info_t    plat_specific_err;
+    sal_log_host_ctlr_err_info_t        host_ctlr_err;
+    sal_log_plat_bus_err_info_t         plat_bus_err;
+} sal_log_platform_err_info_t;
+
+/* SAL log over-all, multi-section error record structure (processor+platform) */
+typedef struct err_rec
+{
+    sal_log_record_header_t     sal_elog_header;
+    sal_log_processor_info_t    proc_err;
+    sal_log_platform_err_info_t plat_err;
+    u8                          oem_data_pad[1024];
+} ia64_err_rec_t;
 
 /*
  * Now define a couple of inline functions for improved type checking
@@ -433,19 +650,20 @@
 }
 
 /* Clear the processor and platform information logged by SAL with respect to the 
- * machine state at the time of MCA's, INITs or CMCs 
+ * machine state at the time of MCA's, INITs, CMCs, or CPEs.
  */
 static inline s64
 ia64_sal_clear_state_info (u64 sal_info_type)
 {
 	struct ia64_sal_retval isrv;
-	SAL_CALL(isrv, SAL_CLEAR_STATE_INFO, sal_info_type, 0, 0, 0, 0, 0, 0);
+    SAL_CALL(isrv, SAL_CLEAR_STATE_INFO, sal_info_type, 0,
+             0, 0, 0, 0, 0);
 	return isrv.status;
 }
 
 
 /* Get the processor and platform information logged by SAL with respect to the machine
- * state at the time of the MCAs, INITs or CMCs.
+ * state at the time of the MCAs, INITs, CMCs, or CPEs.
  */
 static inline u64
 ia64_sal_get_state_info (u64 sal_info_type, u64 *sal_info)
@@ -455,16 +673,18 @@
 	         sal_info, 0, 0, 0, 0);
 	if (isrv.status)
 		return 0;
+
 	return isrv.v0;
 }	
 /* Get the maximum size of the information logged by SAL with respect to the machine 
- * state at the time of MCAs, INITs or CMCs
+ * state at the time of MCAs, INITs, CMCs, or CPEs.
  */
 static inline u64
 ia64_sal_get_state_info_size (u64 sal_info_type)
 {
 	struct ia64_sal_retval isrv;
-	SAL_CALL(isrv, SAL_GET_STATE_INFO_SIZE, sal_info_type, 0, 0, 0, 0, 0, 0);
+    SAL_CALL(isrv, SAL_GET_STATE_INFO_SIZE, sal_info_type, 0,
+             0, 0, 0, 0, 0);
 	if (isrv.status)
 		return 0;
 	return isrv.v0;
diff -urN linux.orig/include/asm-ia64/serial.h linux/include/asm-ia64/serial.h
--- linux.orig/include/asm-ia64/serial.h	Sun Feb  6 19:42:40 2000
+++ linux/include/asm-ia64/serial.h	Mon Dec 17 20:27:41 2001
@@ -52,6 +52,17 @@
 
 #define C_P(card,port) (((card)<<6|(port)<<3) + 1)
 
+#ifdef CONFIG_ACPI
+/* tty ports reserved for the ACPI serial console port and debug port */
+#define ACPI_SERIAL_CONSOLE_PORT	4
+#define ACPI_SERIAL_DEBUG_PORT		5
+#endif
+
+#if 0
+	{ 0, BASE_BAUD, 0, 30, STD_COM_FLAGS, 0, PORT_16550, 1, 0, 16, 0, 0, 0xc0000000FF5E2000, 0, 0, 0, {0}, {0}, {0}, SERIAL_IO_MEM },
+	{ 0, BASE_BAUD, 0, 20, STD_COM_FLAGS, 0, PORT_16550, 0, 0, 16, 0, 0, 0xc0000000FF5E0000, 0, 0, 0, {0}, {0}, {0}, SERIAL_IO_MEM },
+#endif
+
 #define STD_SERIAL_PORT_DEFNS			\
 	/* UART CLK   PORT IRQ     FLAGS        */			\
 	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
@@ -59,37 +70,44 @@
 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
 	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
 
+#ifdef CONFIG_ACPI
+#define ACPI_SERIAL_PORT_DEFNS            \
+	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS, 0, 0, 4 },   /* ttyS4 */ \
+	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS, 0, 0, 5 },   /* ttyS5 */
+#else
+#define ACPI_SERIAL_PORT_DEFNS
+#endif
 
 #ifdef CONFIG_SERIAL_MANY_PORTS
 #define EXTRA_SERIAL_PORT_DEFNS			\
-	{ 0, BASE_BAUD, 0x1A0, 9, FOURPORT_FLAGS }, 	/* ttyS4 */	\
-	{ 0, BASE_BAUD, 0x1A8, 9, FOURPORT_FLAGS },	/* ttyS5 */	\
-	{ 0, BASE_BAUD, 0x1B0, 9, FOURPORT_FLAGS },	/* ttyS6 */	\
-	{ 0, BASE_BAUD, 0x1B8, 9, FOURPORT_FLAGS },	/* ttyS7 */	\
-	{ 0, BASE_BAUD, 0x2A0, 5, FOURPORT_FLAGS },	/* ttyS8 */	\
-	{ 0, BASE_BAUD, 0x2A8, 5, FOURPORT_FLAGS },	/* ttyS9 */	\
-	{ 0, BASE_BAUD, 0x2B0, 5, FOURPORT_FLAGS },	/* ttyS10 */	\
-	{ 0, BASE_BAUD, 0x2B8, 5, FOURPORT_FLAGS },	/* ttyS11 */	\
-	{ 0, BASE_BAUD, 0x330, 4, ACCENT_FLAGS },	/* ttyS12 */	\
-	{ 0, BASE_BAUD, 0x338, 4, ACCENT_FLAGS },	/* ttyS13 */	\
-	{ 0, BASE_BAUD, 0x000, 0, 0 },	/* ttyS14 (spare) */		\
-	{ 0, BASE_BAUD, 0x000, 0, 0 },	/* ttyS15 (spare) */		\
-	{ 0, BASE_BAUD, 0x100, 12, BOCA_FLAGS },	/* ttyS16 */	\
-	{ 0, BASE_BAUD, 0x108, 12, BOCA_FLAGS },	/* ttyS17 */	\
-	{ 0, BASE_BAUD, 0x110, 12, BOCA_FLAGS },	/* ttyS18 */	\
-	{ 0, BASE_BAUD, 0x118, 12, BOCA_FLAGS },	/* ttyS19 */	\
-	{ 0, BASE_BAUD, 0x120, 12, BOCA_FLAGS },	/* ttyS20 */	\
-	{ 0, BASE_BAUD, 0x128, 12, BOCA_FLAGS },	/* ttyS21 */	\
-	{ 0, BASE_BAUD, 0x130, 12, BOCA_FLAGS },	/* ttyS22 */	\
-	{ 0, BASE_BAUD, 0x138, 12, BOCA_FLAGS },	/* ttyS23 */	\
-	{ 0, BASE_BAUD, 0x140, 12, BOCA_FLAGS },	/* ttyS24 */	\
-	{ 0, BASE_BAUD, 0x148, 12, BOCA_FLAGS },	/* ttyS25 */	\
-	{ 0, BASE_BAUD, 0x150, 12, BOCA_FLAGS },	/* ttyS26 */	\
-	{ 0, BASE_BAUD, 0x158, 12, BOCA_FLAGS },	/* ttyS27 */	\
-	{ 0, BASE_BAUD, 0x160, 12, BOCA_FLAGS },	/* ttyS28 */	\
-	{ 0, BASE_BAUD, 0x168, 12, BOCA_FLAGS },	/* ttyS29 */	\
-	{ 0, BASE_BAUD, 0x170, 12, BOCA_FLAGS },	/* ttyS30 */	\
-	{ 0, BASE_BAUD, 0x178, 12, BOCA_FLAGS },	/* ttyS31 */
+	{ 0, BASE_BAUD, 0x1A0, 9, FOURPORT_FLAGS },	/* ttyS6 */	\
+	{ 0, BASE_BAUD, 0x1A8, 9, FOURPORT_FLAGS },	/* ttyS7 */	\
+	{ 0, BASE_BAUD, 0x1B0, 9, FOURPORT_FLAGS },	/* ttyS8 */	\
+	{ 0, BASE_BAUD, 0x1B8, 9, FOURPORT_FLAGS },	/* ttyS9 */	\
+	{ 0, BASE_BAUD, 0x2A0, 5, FOURPORT_FLAGS },	/* ttyS10 */	\
+	{ 0, BASE_BAUD, 0x2A8, 5, FOURPORT_FLAGS },	/* ttyS11 */	\
+	{ 0, BASE_BAUD, 0x2B0, 5, FOURPORT_FLAGS },	/* ttyS12 */	\
+	{ 0, BASE_BAUD, 0x2B8, 5, FOURPORT_FLAGS },	/* ttyS13 */	\
+	{ 0, BASE_BAUD, 0x330, 4, ACCENT_FLAGS },	/* ttyS14 */	\
+	{ 0, BASE_BAUD, 0x338, 4, ACCENT_FLAGS },	/* ttyS15 */	\
+	{ 0, BASE_BAUD, 0x000, 0, 0 },	/* ttyS16 (spare) */		\
+	{ 0, BASE_BAUD, 0x000, 0, 0 },	/* ttyS17 (spare) */		\
+	{ 0, BASE_BAUD, 0x100, 12, BOCA_FLAGS },	/* ttyS18 */	\
+	{ 0, BASE_BAUD, 0x108, 12, BOCA_FLAGS },	/* ttyS19 */	\
+	{ 0, BASE_BAUD, 0x110, 12, BOCA_FLAGS },	/* ttyS20 */	\
+	{ 0, BASE_BAUD, 0x118, 12, BOCA_FLAGS },	/* ttyS21 */	\
+	{ 0, BASE_BAUD, 0x120, 12, BOCA_FLAGS },	/* ttyS22 */	\
+	{ 0, BASE_BAUD, 0x128, 12, BOCA_FLAGS },	/* ttyS23 */	\
+	{ 0, BASE_BAUD, 0x130, 12, BOCA_FLAGS },	/* ttyS24 */	\
+	{ 0, BASE_BAUD, 0x138, 12, BOCA_FLAGS },	/* ttyS25 */	\
+	{ 0, BASE_BAUD, 0x140, 12, BOCA_FLAGS },	/* ttyS26 */	\
+	{ 0, BASE_BAUD, 0x148, 12, BOCA_FLAGS },	/* ttyS27 */	\
+	{ 0, BASE_BAUD, 0x150, 12, BOCA_FLAGS },	/* ttyS28 */	\
+	{ 0, BASE_BAUD, 0x158, 12, BOCA_FLAGS },	/* ttyS29 */	\
+	{ 0, BASE_BAUD, 0x160, 12, BOCA_FLAGS },	/* ttyS30 */	\
+	{ 0, BASE_BAUD, 0x168, 12, BOCA_FLAGS },	/* ttyS31 */	\
+	{ 0, BASE_BAUD, 0x170, 12, BOCA_FLAGS },	/* ttyS32 */	\
+	{ 0, BASE_BAUD, 0x178, 12, BOCA_FLAGS },	/* ttyS33 */
 #else
 #define EXTRA_SERIAL_PORT_DEFNS
 #endif
@@ -99,18 +117,18 @@
  */
 #if (defined(CONFIG_HUB6) && defined(CONFIG_SERIAL_MANY_PORTS))
 #define HUB6_SERIAL_PORT_DFNS		\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,0) },  /* ttyS32 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,1) },  /* ttyS33 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,2) },  /* ttyS34 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,3) },  /* ttyS35 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,4) },  /* ttyS36 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,5) },  /* ttyS37 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,0) },  /* ttyS38 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,1) },  /* ttyS39 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,2) },  /* ttyS40 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,3) },  /* ttyS41 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,4) },  /* ttyS42 */	\
-	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,5) },  /* ttyS43 */
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,0) },  /* ttyS34 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,1) },  /* ttyS35 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,2) },  /* ttyS36 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,3) },  /* ttyS37 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,4) },  /* ttyS38 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,5) },  /* ttyS39 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,0) },  /* ttyS40 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,1) },  /* ttyS41 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,2) },  /* ttyS42 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,3) },  /* ttyS43 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,4) },  /* ttyS44 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,5) },  /* ttyS45 */
 #else
 #define HUB6_SERIAL_PORT_DFNS
 #endif
diff -urN linux.orig/include/asm-ia64/sigcontext.h linux/include/asm-ia64/sigcontext.h
--- linux.orig/include/asm-ia64/sigcontext.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/sigcontext.h	Mon Dec 17 20:27:41 2001
@@ -2,13 +2,13 @@
 #define _ASM_IA64_SIGCONTEXT_H
 
 /*
- * Copyright (C) 1998, 1999 Hewlett-Packard Co
- * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1998, 1999, 2001 Hewlett-Packard Co
+ * Copyright (C) 1998, 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
 #include <asm/fpu.h>
 
-#define IA64_SC_FLAG_ONSTACK_BIT		1	/* is handler running on signal stack? */
+#define IA64_SC_FLAG_ONSTACK_BIT		0	/* is handler running on signal stack? */
 #define IA64_SC_FLAG_IN_SYSCALL_BIT		1	/* did signal interrupt a syscall? */
 #define IA64_SC_FLAG_FPH_VALID_BIT		2	/* is state in f[32]-f[127] valid? */
 
diff -urN linux.orig/include/asm-ia64/spinlock.h linux/include/asm-ia64/spinlock.h
--- linux.orig/include/asm-ia64/spinlock.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/spinlock.h	Mon Dec 17 20:27:41 2001
@@ -2,8 +2,8 @@
 #define _ASM_IA64_SPINLOCK_H
 
 /*
- * Copyright (C) 1998-2000 Hewlett-Packard Co
- * Copyright (C) 1998-2000 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1998-2001 Hewlett-Packard Co
+ * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
  * Copyright (C) 1999 Walt Drummond <drummond@valinux.com>
  *
  * This file is used for SMP configurations only.
@@ -39,7 +39,7 @@
 		"mov r30=1\n"								\
 		"mov ar.ccv=r0\n"							\
 		";;\n"									\
-		IA64_SEMFIX"cmpxchg4.acq r30=[%0],r30,ar.ccv\n"				\
+		"cmpxchg4.acq r30=[%0],r30,ar.ccv\n"					\
 		";;\n"									\
 		"cmp.ne p15,p0=r30,r0\n"						\
 		"(p15) br.call.spnt.few b7=ia64_spinlock_contention\n"			\
@@ -56,7 +56,7 @@
 	__asm__ __volatile__ (								\
 		"mov ar.ccv=r0\n"							\
 		";;\n"									\
-		IA64_SEMFIX"cmpxchg4.acq %0=[%2],%1,ar.ccv\n"				\
+		"cmpxchg4.acq %0=[%2],%1,ar.ccv\n"					\
 		: "=r"(result) : "r"(1), "r"(&(x)->lock) : "ar.ccv", "memory");		\
 	(result == 0);									\
 })
@@ -88,7 +88,7 @@
 	";;\n"							\
 	"cmp4.eq p0,p7 = r0,r2\n"				\
 	"(p7) br.cond.spnt.few 1b \n"				\
-	IA64_SEMFIX"cmpxchg4.acq r2 = [%0], r29, ar.ccv\n"	\
+	"cmpxchg4.acq r2 = [%0], r29, ar.ccv\n"			\
 	";;\n"							\
 	"cmp4.eq p0,p7 = r0, r2\n"				\
 	"(p7) br.cond.spnt.few 1b\n"				\
@@ -108,15 +108,17 @@
 } rwlock_t;
 #define RW_LOCK_UNLOCKED (rwlock_t) { 0, 0 }
 
+#define rwlock_init(x) do { *(x) = RW_LOCK_UNLOCKED; } while(0)
+
 #define read_lock(rw)								\
 do {										\
 	int tmp = 0;								\
-	__asm__ __volatile__ ("1:\t"IA64_SEMFIX"fetchadd4.acq %0 = [%1], 1\n"	\
+	__asm__ __volatile__ ("1:\tfetchadd4.acq %0 = [%1], 1\n"		\
 			      ";;\n"						\
 			      "tbit.nz p6,p0 = %0, 31\n"			\
 			      "(p6) br.cond.sptk.few 2f\n"			\
 			      ".section .text.lock,\"ax\"\n"			\
-			      "2:\t"IA64_SEMFIX"fetchadd4.rel %0 = [%1], -1\n"	\
+			      "2:\tfetchadd4.rel %0 = [%1], -1\n"		\
 			      ";;\n"						\
 			      "3:\tld4.acq %0 = [%1]\n"				\
 			      ";;\n"						\
@@ -132,7 +134,7 @@
 #define read_unlock(rw)								\
 do {										\
 	int tmp = 0;								\
-	__asm__ __volatile__ (IA64_SEMFIX"fetchadd4.rel %0 = [%1], -1\n"	\
+	__asm__ __volatile__ ("fetchadd4.rel %0 = [%1], -1\n"			\
 			      : "=r" (tmp)					\
 			      : "r" (rw)					\
 			      : "memory");					\
@@ -142,14 +144,14 @@
 do {										\
  	__asm__ __volatile__ (							\
 		"mov ar.ccv = r0\n"						\
-		"movl r29 = 0x80000000\n"					\
+		"dep r29 = -1, r0, 31, 1\n"					\
 		";;\n"								\
 		"1:\n"								\
 		"ld4 r2 = [%0]\n"						\
 		";;\n"								\
 		"cmp4.eq p0,p7 = r0,r2\n"					\
 		"(p7) br.cond.spnt.few 1b \n"					\
-		IA64_SEMFIX"cmpxchg4.acq r2 = [%0], r29, ar.ccv\n"		\
+		"cmpxchg4.acq r2 = [%0], r29, ar.ccv\n"				\
 		";;\n"								\
 		"cmp4.eq p0,p7 = r0, r2\n"					\
 		"(p7) br.cond.spnt.few 1b\n"					\
diff -urN linux.orig/include/asm-ia64/system.h linux/include/asm-ia64/system.h
--- linux.orig/include/asm-ia64/system.h	Tue Jul 31 11:30:09 2001
+++ linux/include/asm-ia64/system.h	Mon Dec 17 20:27:41 2001
@@ -29,15 +29,6 @@
 #define GATE_ADDR		(0xa000000000000000 + PAGE_SIZE)
 #define PERCPU_ADDR		(0xa000000000000000 + 2*PAGE_SIZE)
 
-#if defined(CONFIG_ITANIUM_B0_SPECIFIC) || defined(CONFIG_ITANIUM_B1_SPECIFIC)
-  /* Workaround for Errata 97.  */
-# define IA64_SEMFIX_INSN	mf;
-# define IA64_SEMFIX	"mf;"
-#else
-# define IA64_SEMFIX_INSN
-# define IA64_SEMFIX	""
-#endif
-
 #ifndef __ASSEMBLY__
 
 #include <linux/kernel.h>
@@ -210,12 +201,12 @@
 ({										\
 	switch (sz) {								\
 	      case 4:								\
-		__asm__ __volatile__ (IA64_SEMFIX"fetchadd4.rel %0=[%1],%2"	\
+		__asm__ __volatile__ ("fetchadd4.rel %0=[%1],%2"		\
 				      : "=r"(tmp) : "r"(v), "i"(n) : "memory");	\
 		break;								\
 										\
 	      case 8:								\
-		__asm__ __volatile__ (IA64_SEMFIX"fetchadd8.rel %0=[%1],%2"	\
+		__asm__ __volatile__ ("fetchadd8.rel %0=[%1],%2"		\
 				      : "=r"(tmp) : "r"(v), "i"(n) : "memory");	\
 		break;								\
 										\
@@ -257,22 +248,22 @@
 
 	switch (size) {
 	      case 1:
-		__asm__ __volatile (IA64_SEMFIX"xchg1 %0=[%1],%2" : "=r" (result)
+		__asm__ __volatile ("xchg1 %0=[%1],%2" : "=r" (result)
 				    : "r" (ptr), "r" (x) : "memory");
 		return result;
 
 	      case 2:
-		__asm__ __volatile (IA64_SEMFIX"xchg2 %0=[%1],%2" : "=r" (result)
+		__asm__ __volatile ("xchg2 %0=[%1],%2" : "=r" (result)
 				    : "r" (ptr), "r" (x) : "memory");
 		return result;
 
 	      case 4:
-		__asm__ __volatile (IA64_SEMFIX"xchg4 %0=[%1],%2" : "=r" (result)
+		__asm__ __volatile ("xchg4 %0=[%1],%2" : "=r" (result)
 				    : "r" (ptr), "r" (x) : "memory");
 		return result;
 
 	      case 8:
-		__asm__ __volatile (IA64_SEMFIX"xchg8 %0=[%1],%2" : "=r" (result)
+		__asm__ __volatile ("xchg8 %0=[%1],%2" : "=r" (result)
 				    : "r" (ptr), "r" (x) : "memory");
 		return result;
 	}
@@ -313,22 +304,22 @@
 	 __asm__ __volatile__ ("mov ar.ccv=%0;;" :: "rO"(_o_));				\
 	switch (size) {									\
 	      case 1:									\
-		__asm__ __volatile__ (IA64_SEMFIX"cmpxchg1."sem" %0=[%1],%2,ar.ccv"	\
+		__asm__ __volatile__ ("cmpxchg1."sem" %0=[%1],%2,ar.ccv"		\
 				      : "=r"(_r_) : "r"(_p_), "r"(_n_) : "memory");	\
 		break;									\
 											\
 	      case 2:									\
-		__asm__ __volatile__ (IA64_SEMFIX"cmpxchg2."sem" %0=[%1],%2,ar.ccv"	\
+		__asm__ __volatile__ ("cmpxchg2."sem" %0=[%1],%2,ar.ccv"		\
 				      : "=r"(_r_) : "r"(_p_), "r"(_n_) : "memory");	\
 		break;									\
 											\
 	      case 4:									\
-		__asm__ __volatile__ (IA64_SEMFIX"cmpxchg4."sem" %0=[%1],%2,ar.ccv"	\
+		__asm__ __volatile__ ("cmpxchg4."sem" %0=[%1],%2,ar.ccv"		\
 				      : "=r"(_r_) : "r"(_p_), "r"(_n_) : "memory");	\
 		break;									\
 											\
 	      case 8:									\
-		__asm__ __volatile__ (IA64_SEMFIX"cmpxchg8."sem" %0=[%1],%2,ar.ccv"	\
+		__asm__ __volatile__ ("cmpxchg8."sem" %0=[%1],%2,ar.ccv"		\
 				      : "=r"(_r_) : "r"(_p_), "r"(_n_) : "memory");	\
 		break;									\
 											\
diff -urN linux.orig/include/asm-ia64/user.h linux/include/asm-ia64/user.h
--- linux.orig/include/asm-ia64/user.h	Sun Feb  6 19:42:40 2000
+++ linux/include/asm-ia64/user.h	Mon Dec 17 20:27:41 2001
@@ -24,11 +24,12 @@
  *	current->start_stack, so we round each of these in order to be able
  *	to write an integer number of pages.
  *
- * Copyright (C) 1998, 1999 Hewlett-Packard Co
- * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1998, 1999, 2001 Hewlett-Packard Co
+ * Copyright (C) 1998, 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
 #include <linux/ptrace.h>
+#include <linux/types.h>
 
 #include <asm/page.h>
 
diff -urN linux.orig/include/linux/acpi_serial.h linux/include/linux/acpi_serial.h
--- linux.orig/include/linux/acpi_serial.h	Wed Dec 31 17:00:00 1969
+++ linux/include/linux/acpi_serial.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,103 @@
+/*
+ *  linux/drivers/acpi/serial.h
+ *
+ *  Copyright (C) 2000  Hewlett-Packard Co.
+ *  Copyright (C) 2000  Khalid Aziz <khalid_aziz@hp.com>
+ *
+ *  Definitions for ACPI defined serial ports (headless console and 
+ *  debug ports)
+ *
+ */
+
+extern void setup_serial_acpi(void *);
+
+/* ACPI table signatures */
+#define ACPI_SPCRT_SIGNATURE	"SPCR"
+#define ACPI_DBGPT_SIGNATURE	"DBGP"
+
+/* Interface type as defined in ACPI serial port tables */
+#define ACPI_SERIAL_INTFC_16550	0
+#define ACPI_SERIAL_INTFC_16450	1
+
+/* Interrupt types for ACPI serial port tables */
+#define ACPI_SERIAL_INT_PCAT	0x01
+#define ACPI_SERIAL_INT_APIC	0x02
+#define ACPI_SERIAL_INT_SAPIC	0x04
+
+/* Baud rates as defined in ACPI serial port tables */
+#define ACPI_SERIAL_BAUD_9600		3
+#define ACPI_SERIAL_BAUD_19200		4
+#define ACPI_SERIAL_BAUD_57600		6
+#define ACPI_SERIAL_BAUD_115200		7
+
+/* Parity as defined in ACPI serial port tables */
+#define ACPI_SERIAL_PARITY_NONE		0
+
+/* Flow control methods as defined in ACPI serial port tables */
+#define ACPI_SERIAL_FLOW_DCD	0x01
+#define ACPI_SERIAL_FLOW_RTS	0x02
+#define ACPI_SERIAL_FLOW_XON	0x04
+
+/* Terminal types as defined in ACPI serial port tables */
+#define ACPI_SERIAL_TERM_VT100		0
+#define ACPI_SERIAL_TERM_VT100X	1
+
+/* PCI Flags as defined by SPCR table */
+#define ACPI_SERIAL_PCIFLAG_PNP	0x00000001
+
+/* Space ID as defined in base address structure in ACPI serial port tables */
+#define ACPI_SERIAL_MEM_SPACE		0
+#define ACPI_SERIAL_IO_SPACE		1
+#define ACPI_SERIAL_PCICONF_SPACE	2
+
+/* 
+ * Generic Register Address Structure - as defined by Microsoft 
+ * in http://www.microsoft.com/hwdev/onnow/download/LFreeACPI.doc
+ *
+*/
+typedef struct {
+	u8  space_id;
+	u8  bit_width;
+	u8  bit_offset;
+	u8  resv;
+	u32 addrl;
+	u32 addrh;
+} gen_regaddr;
+
+/* Space ID for generic register address structure */
+#define REGADDR_SPACE_SYSMEM	0
+#define REGADDR_SPACE_SYSIO	1
+#define REGADDR_SPACE_PCICONFIG	2
+
+/* Serial Port Console Redirection and Debug Port Table formats */
+typedef struct {
+	u8 signature[4];
+	u32 length;
+	u8  rev;
+	u8  chksum;
+	u8  oemid[6];
+	u8  oem_tabid[8];
+	u32 oem_rev;
+	u8  creator_id[4];
+	u32 creator_rev;
+	u8  intfc_type;
+	u8  resv1[3];
+	gen_regaddr base_addr;
+	u8  int_type;
+	u8  irq;
+	u8  global_int[4];
+	u8  baud;
+	u8  parity;
+	u8  stop_bits;
+	u8  flow_ctrl;
+	u8  termtype;
+	u8  language;
+	u16 pci_dev_id;
+	u16 pci_vendor_id;
+	u8  pci_bus;
+	u8  pci_dev;
+	u8  pci_func;
+	u8  pci_flags[4];
+	u8  pci_seg;
+	u32 resv2;
+} acpi_ser_t;
diff -urN linux.orig/include/linux/agp_backend.h linux/include/linux/agp_backend.h
--- linux.orig/include/linux/agp_backend.h	Mon Jul  2 16:27:56 2001
+++ linux/include/linux/agp_backend.h	Mon Dec 17 20:27:41 2001
@@ -27,6 +27,8 @@
 #ifndef _AGP_BACKEND_H
 #define _AGP_BACKEND_H 1
 
+#include <linux/config.h>
+
 #ifndef TRUE
 #define TRUE 1
 #endif
@@ -48,6 +50,7 @@
 	INTEL_I815,
 	INTEL_I840,
 	INTEL_I850,
+	INTEL_460GX,
 	VIA_GENERIC,
 	VIA_VP3,
 	VIA_MVP3,
@@ -85,6 +88,8 @@
 	size_t aper_size;
 	int max_memory;		/* In pages */
 	int current_memory;
+	int cant_use_aperture;
+	unsigned long page_mask;
 } agp_kern_info;
 
 /* 
@@ -107,6 +112,7 @@
 	size_t page_count;
 	int num_scratch_pages;
 	unsigned long *memory;
+	void *vmptr;
 	off_t pg_start;
 	u32 type;
 	u32 physical;
diff -urN linux.orig/include/linux/crc32.h linux/include/linux/crc32.h
--- linux.orig/include/linux/crc32.h	Wed Dec 31 17:00:00 1969
+++ linux/include/linux/crc32.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,17 @@
+/*
+ * crc32.h
+ * See linux/lib/crc32.c for license and changes
+ */
+#ifndef _LINUX_CRC32_H
+#define _LINUX_CRC32_H
+
+#include <linux/types.h>
+
+/*
+ * This computes a 32 bit CRC of the data in the buffer, and returns the CRC.
+ * The polynomial used is 0xedb88320.
+ */
+
+extern u32 crc32 (const void *buf, unsigned long len, u32 seed);
+
+#endif /* _LINUX_CRC32_H */
diff -urN linux.orig/include/linux/devfs_fs_kernel.h linux/include/linux/devfs_fs_kernel.h
--- linux.orig/include/linux/devfs_fs_kernel.h	Wed Aug 15 15:21:30 2001
+++ linux/include/linux/devfs_fs_kernel.h	Mon Dec 17 20:27:41 2001
@@ -99,6 +99,9 @@
 extern devfs_handle_t devfs_get_next_sibling (devfs_handle_t de);
 extern void devfs_auto_unregister (devfs_handle_t master,devfs_handle_t slave);
 extern devfs_handle_t devfs_get_unregister_slave (devfs_handle_t master);
+#ifdef CONFIG_DEVFS_GUID
+extern void devfs_unregister_slave (devfs_handle_t master);
+#endif
 extern const char *devfs_get_name (devfs_handle_t de, unsigned int *namelen);
 extern int devfs_register_chrdev (unsigned int major, const char *name,
 				  struct file_operations *fops);
diff -urN linux.orig/include/linux/elf.h linux/include/linux/elf.h
--- linux.orig/include/linux/elf.h	Wed Aug 15 15:25:02 2001
+++ linux/include/linux/elf.h	Mon Dec 17 20:27:41 2001
@@ -16,8 +16,10 @@
 typedef __u16	Elf64_Half;
 typedef __s16	Elf64_SHalf;
 typedef __u64	Elf64_Off;
-typedef __s64	Elf64_Sword;
-typedef __u64	Elf64_Word;
+typedef __s32	Elf64_Sword;
+typedef __u32	Elf64_Word;
+typedef __u64	Elf64_Xword;
+typedef __s64	Elf64_Sxword;
 
 /* These constants are for the segment types stored in the image headers */
 #define PT_NULL    0
@@ -180,10 +182,10 @@
 } Elf32_Dyn;
 
 typedef struct {
-  Elf64_Word d_tag;		/* entry tag value */
+  Elf64_Sxword d_tag;		/* entry tag value */
   union {
-    Elf64_Word d_val;
-    Elf64_Word d_ptr;
+    Elf64_Xword d_val;
+    Elf64_Addr d_ptr;
   } d_un;
 } Elf64_Dyn;
 
@@ -374,7 +376,7 @@
 
 typedef struct elf64_rel {
   Elf64_Addr r_offset;	/* Location at which to apply the action */
-  Elf64_Word r_info;	/* index and type of relocation */
+  Elf64_Xword r_info;	/* index and type of relocation */
 } Elf64_Rel;
 
 typedef struct elf32_rela{
@@ -385,8 +387,8 @@
 
 typedef struct elf64_rela {
   Elf64_Addr r_offset;	/* Location at which to apply the action */
-  Elf64_Word r_info;	/* index and type of relocation */
-  Elf64_Word r_addend;	/* Constant addend used to compute value */
+  Elf64_Xword r_info;	/* index and type of relocation */
+  Elf64_Sxword r_addend;	/* Constant addend used to compute value */
 } Elf64_Rela;
 
 typedef struct elf32_sym{
@@ -399,12 +401,12 @@
 } Elf32_Sym;
 
 typedef struct elf64_sym {
-  Elf32_Word st_name;		/* Symbol name, index in string tbl (yes, Elf32) */
+  Elf64_Word st_name;		/* Symbol name, index in string tbl */
   unsigned char	st_info;	/* Type and binding attributes */
   unsigned char	st_other;	/* No defined meaning, 0 */
   Elf64_Half st_shndx;		/* Associated section index */
   Elf64_Addr st_value;		/* Value of the symbol */
-  Elf64_Word st_size;		/* Associated symbol size */
+  Elf64_Xword st_size;		/* Associated symbol size */
 } Elf64_Sym;
 
 
@@ -429,19 +431,19 @@
 
 typedef struct elf64_hdr {
   unsigned char	e_ident[16];		/* ELF "magic number" */
-  Elf64_SHalf e_type;
+  Elf64_Half e_type;
   Elf64_Half e_machine;
-  __s32 e_version;
+  Elf64_Word e_version;
   Elf64_Addr e_entry;		/* Entry point virtual address */
   Elf64_Off e_phoff;		/* Program header table file offset */
   Elf64_Off e_shoff;		/* Section header table file offset */
-  __s32 e_flags;
-  Elf64_SHalf e_ehsize;
-  Elf64_SHalf e_phentsize;
-  Elf64_SHalf e_phnum;
-  Elf64_SHalf e_shentsize;
-  Elf64_SHalf e_shnum;
-  Elf64_SHalf e_shstrndx;
+  Elf64_Word e_flags;
+  Elf64_Half e_ehsize;
+  Elf64_Half e_phentsize;
+  Elf64_Half e_phnum;
+  Elf64_Half e_shentsize;
+  Elf64_Half e_shnum;
+  Elf64_Half e_shstrndx;
 } Elf64_Ehdr;
 
 /* These constants define the permissions on sections in the program
@@ -462,14 +464,14 @@
 } Elf32_Phdr;
 
 typedef struct elf64_phdr {
-  __s32 p_type;
-  __s32 p_flags;
+  Elf64_Word p_type;
+  Elf64_Word p_flags;
   Elf64_Off p_offset;		/* Segment file offset */
   Elf64_Addr p_vaddr;		/* Segment virtual address */
   Elf64_Addr p_paddr;		/* Segment physical address */
-  Elf64_Word p_filesz;		/* Segment size in file */
-  Elf64_Word p_memsz;		/* Segment size in memory */
-  Elf64_Word p_align;		/* Segment alignment, file & memory */
+  Elf64_Xword p_filesz;		/* Segment size in file */
+  Elf64_Xword p_memsz;		/* Segment size in memory */
+  Elf64_Xword p_align;		/* Segment alignment, file & memory */
 } Elf64_Phdr;
 
 /* sh_type */
@@ -526,16 +528,16 @@
 } Elf32_Shdr;
 
 typedef struct elf64_shdr {
-  Elf32_Word sh_name;		/* Section name, index in string tbl (yes Elf32) */
-  Elf32_Word sh_type;		/* Type of section (yes Elf32) */
-  Elf64_Word sh_flags;		/* Miscellaneous section attributes */
+  Elf64_Word sh_name;		/* Section name, index in string tbl */
+  Elf64_Word sh_type;		/* Type of section */
+  Elf64_Xword sh_flags;		/* Miscellaneous section attributes */
   Elf64_Addr sh_addr;		/* Section virtual addr at execution */
   Elf64_Off sh_offset;		/* Section file offset */
-  Elf64_Word sh_size;		/* Size of section in bytes */
-  Elf32_Word sh_link;		/* Index of another section (yes Elf32) */
-  Elf32_Word sh_info;		/* Additional section information (yes Elf32) */
-  Elf64_Word sh_addralign;	/* Section alignment */
-  Elf64_Word sh_entsize;	/* Entry size if section holds table */
+  Elf64_Xword sh_size;		/* Size of section in bytes */
+  Elf64_Word sh_link;		/* Index of another section */
+  Elf64_Word sh_info;		/* Additional section information */
+  Elf64_Xword sh_addralign;	/* Section alignment */
+  Elf64_Xword sh_entsize;	/* Entry size if section holds table */
 } Elf64_Shdr;
 
 #define	EI_MAG0		0		/* e_ident[] indexes */
@@ -582,15 +584,10 @@
 } Elf32_Nhdr;
 
 /* Note header in a PT_NOTE section */
-/*
- * For now we use the 32 bit version of the structure until we figure
- * out whether we need anything better.  Note - on the Alpha, "unsigned int"
- * is only 32 bits.
- */
 typedef struct elf64_note {
-  Elf32_Word n_namesz;	/* Name size */
-  Elf32_Word n_descsz;	/* Content size */
-  Elf32_Word n_type;	/* Content type */
+  Elf64_Word n_namesz;	/* Name size */
+  Elf64_Word n_descsz;	/* Content size */
+  Elf64_Word n_type;	/* Content type */
 } Elf64_Nhdr;
 
 #if ELF_CLASS == ELFCLASS32
diff -urN linux.orig/include/linux/genhd.h linux/include/linux/genhd.h
--- linux.orig/include/linux/genhd.h	Wed Aug 15 15:21:30 2001
+++ linux/include/linux/genhd.h	Mon Dec 17 20:27:41 2001
@@ -13,6 +13,10 @@
 #include <linux/types.h>
 #include <linux/major.h>
 
+#ifdef CONFIG_DEVFS_GUID
+#include <asm/efi.h>
+#endif
+
 /* These three have identical behaviour; use the second one if DOS fdisk gets
    confused about extended/logical partitions starting past cylinder 1023. */
 #define DOS_EXTENDED_PARTITION 5
@@ -52,6 +56,9 @@
 	long nr_sects;
 	devfs_handle_t de;              /* primary (master) devfs entry  */
 	int number;                     /* stupid old code wastes space  */
+#ifdef CONFIG_DEVFS_GUID
+	efi_guid_t *guid;
+#endif
 };
 
 #define GENHD_FL_REMOVABLE  1
diff -urN linux.orig/include/linux/highmem.h linux/include/linux/highmem.h
--- linux.orig/include/linux/highmem.h	Wed Aug 15 15:21:21 2001
+++ linux/include/linux/highmem.h	Mon Dec 17 20:27:41 2001
@@ -45,7 +45,7 @@
 /* when CONFIG_HIGHMEM is not set these will be plain clear/copy_page */
 static inline void clear_user_highpage(struct page *page, unsigned long vaddr)
 {
-	clear_user_page(kmap(page), vaddr);
+	clear_user_page(kmap(page), vaddr, page);
 	kunmap(page);
 }
 
@@ -87,7 +87,7 @@
 
 	vfrom = kmap(from);
 	vto = kmap(to);
-	copy_user_page(vto, vfrom, vaddr);
+	copy_user_page(vto, vfrom, vaddr, to);
 	kunmap(from);
 	kunmap(to);
 }
diff -urN linux.orig/include/linux/irq.h linux/include/linux/irq.h
--- linux.orig/include/linux/irq.h	Wed Aug 15 15:21:11 2001
+++ linux/include/linux/irq.h	Mon Dec 17 20:27:41 2001
@@ -44,15 +44,13 @@
  *
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
-typedef struct {
+typedef struct irq_desc {
 	unsigned int status;		/* IRQ status */
 	hw_irq_controller *handler;
 	struct irqaction *action;	/* IRQ action list */
 	unsigned int depth;		/* nested irq disables */
 	spinlock_t lock;
 } ____cacheline_aligned irq_desc_t;
-
-extern irq_desc_t irq_desc [NR_IRQS];
 
 #include <asm/hw_irq.h> /* the arch dependent stuff */
 
diff -urN linux.orig/include/linux/irq_cpustat.h linux/include/linux/irq_cpustat.h
--- linux.orig/include/linux/irq_cpustat.h	Wed Aug 15 15:21:11 2001
+++ linux/include/linux/irq_cpustat.h	Mon Dec 17 20:27:41 2001
@@ -23,12 +23,12 @@
 #define __IRQ_STAT(cpu, member)	(irq_stat[cpu].member)
 #else
 #define __IRQ_STAT(cpu, member)	((void)(cpu), irq_stat[0].member)
-#endif	
+#endif
 
   /* arch independent irq_stat fields */
 #define softirq_pending(cpu)	__IRQ_STAT((cpu), __softirq_pending)
-#define local_irq_count(cpu)	__IRQ_STAT((cpu), __local_irq_count)
-#define local_bh_count(cpu)	__IRQ_STAT((cpu), __local_bh_count)
+#define irq_count(cpu)		__IRQ_STAT((cpu), __irq_count)
+#define bh_count(cpu)		__IRQ_STAT((cpu), __bh_count)
 #define syscall_count(cpu)	__IRQ_STAT((cpu), __syscall_count)
 #define ksoftirqd_task(cpu)	__IRQ_STAT((cpu), __ksoftirqd_task)
   /* arch dependent irq_stat fields */
diff -urN linux.orig/include/linux/list.h linux/include/linux/list.h
--- linux.orig/include/linux/list.h	Fri Feb 16 17:06:17 2001
+++ linux/include/linux/list.h	Mon Dec 17 20:27:41 2001
@@ -3,6 +3,8 @@
 
 #if defined(__KERNEL__) || defined(_LVM_H_INCLUDE)
 
+#include <linux/prefetch.h>
+
 /*
  * Simple doubly linked list implementation.
  *
@@ -147,8 +149,9 @@
  * @head:	the head for your list.
  */
 #define list_for_each(pos, head) \
-	for (pos = (head)->next; pos != (head); pos = pos->next)
-
+	for (pos = (head)->next, prefetch(pos->next); pos != (head); \
+        	pos = pos->next, prefetch(pos->next))
+        	
 #endif /* __KERNEL__ || _LVM_H_INCLUDE */
 
 #endif
diff -urN linux.orig/include/linux/loop.h linux/include/linux/loop.h
--- linux.orig/include/linux/loop.h	Thu Jul 26 14:55:24 2001
+++ linux/include/linux/loop.h	Mon Dec 17 20:27:41 2001
@@ -48,6 +48,10 @@
 
 	int		old_gfp_mask;
 
+ 	int		lo_blksize;
+	int			lo_current;
+	unsigned long		lo_pending_reads[2];
+	struct semaphore	*lo_change;
 	spinlock_t		lo_lock;
 	struct buffer_head	*lo_bh;
 	struct buffer_head	*lo_bhtail;
@@ -150,5 +154,6 @@
 #define LOOP_CLR_FD	0x4C01
 #define LOOP_SET_STATUS	0x4C02
 #define LOOP_GET_STATUS	0x4C03
+#define LOOP_CHANGE_FD	0x4C04
 
 #endif
diff -urN linux.orig/include/linux/mm.h linux/include/linux/mm.h
--- linux.orig/include/linux/mm.h	Wed Aug 15 15:21:11 2001
+++ linux/include/linux/mm.h	Mon Dec 17 20:27:41 2001
@@ -103,6 +103,8 @@
 #define VM_DONTCOPY	0x00020000      /* Do not copy this vma on fork */
 #define VM_DONTEXPAND	0x00040000	/* Cannot expand with mremap() */
 #define VM_RESERVED	0x00080000	/* Don't unmap it from swap_out */
+#define VM_WRITECOMBINED 0x00100000	/* Write-combined */
+#define VM_NONCACHED	0x00200000	/* Noncached access */
 
 #define VM_STACK_FLAGS	0x00000177
 
diff -urN linux.orig/include/linux/prefetch.h linux/include/linux/prefetch.h
--- linux.orig/include/linux/prefetch.h	Wed Dec 31 17:00:00 1969
+++ linux/include/linux/prefetch.h	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,60 @@
+/*
+ *  Generic cache management functions. Everything is arch-specific,  
+ *  but this header exists to make sure the defines/functions can be
+ *  used in a generic way.
+ *
+ *  2000-11-13  Arjan van de Ven   <arjanv@redhat.com>
+ *
+ */
+
+#ifndef _LINUX_PREFETCH_H
+#define _LINUX_PREFETCH_H
+
+#include <asm/processor.h>
+#include <asm/cache.h>
+
+/*
+	prefetch(x) attempts to pre-emptively get the memory pointed to
+	by address "x" into the CPU L1 cache. 
+	prefetch(x) should not cause any kind of exception, prefetch(0) is
+	specifically ok.
+
+	prefetch() should be defined by the architecture, if not, the 
+	#define below provides a no-op define.	
+	
+	There are 3 prefetch() macros:
+	
+	prefetch(x)  	- prefetches the cacheline at "x" for read
+	prefetchw(x)	- prefetches the cacheline at "x" for write
+	prefetch_spin_lock(x) - prefectches the spinlock *x for taking
+	
+	there is also PREFETCH_STRIDE which is the architecure-prefered 
+	"lookahead" size for prefetching streamed operations.
+	
+*/
+
+/*
+ *	These cannot be do{}while(0) macros. See the mental gymnastics in
+ *	the loop macro.
+ */
+ 
+#ifndef ARCH_HAS_PREFETCH
+#define ARCH_HAS_PREFETCH
+static inline void prefetch(const void *x) {;}
+#endif
+
+#ifndef ARCH_HAS_PREFETCHW
+#define ARCH_HAS_PREFETCHW
+static inline void prefetchw(const void *x) {;}
+#endif
+
+#ifndef ARCH_HAS_SPINLOCK_PREFETCH
+#define ARCH_HAS_SPINLOCK_PREFETCH
+#define prefetch_spin_lock(x) prefetchw(x)
+#endif
+
+#ifndef PREFETCH_STRIDE
+#define PREFETCH_STRIDE (4*L1_CACHE_BYTES)
+#endif
+
+#endif
diff -urN linux.orig/include/linux/serial.h linux/include/linux/serial.h
--- linux.orig/include/linux/serial.h	Wed Aug 15 15:21:30 2001
+++ linux/include/linux/serial.h	Mon Dec 17 20:27:41 2001
@@ -182,5 +182,11 @@
 /* Allow complicated architectures to specify rs_table[] at run time */
 extern int early_serial_setup(struct serial_struct *req);
 
+#ifdef CONFIG_ACPI
+/* tty ports reserved for the ACPI serial console port and debug port */
+#define ACPI_SERIAL_CONSOLE_PORT        4
+#define ACPI_SERIAL_DEBUG_PORT          5
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SERIAL_H */
diff -urN linux.orig/include/linux/smp.h linux/include/linux/smp.h
--- linux.orig/include/linux/smp.h	Wed Aug 15 15:21:11 2001
+++ linux/include/linux/smp.h	Mon Dec 17 20:27:41 2001
@@ -53,7 +53,7 @@
 /*
  * True once the per process idle is forked
  */
-extern int smp_threads_ready;
+extern volatile int smp_threads_ready;
 
 extern int smp_num_cpus;
 
diff -urN linux.orig/include/linux/string.h linux/include/linux/string.h
--- linux.orig/include/linux/string.h	Wed Aug 15 15:21:11 2001
+++ linux/include/linux/string.h	Mon Dec 17 20:27:41 2001
@@ -79,6 +79,7 @@
 #ifndef __HAVE_ARCH_MEMCHR
 extern void * memchr(const void *,int,__kernel_size_t);
 #endif
+extern char * kstrdup(const char *,int);
 
 #ifdef __cplusplus
 }
diff -urN linux.orig/include/linux/time.h linux/include/linux/time.h
--- linux.orig/include/linux/time.h	Wed Aug 15 15:21:11 2001
+++ linux/include/linux/time.h	Mon Dec 17 20:27:41 2001
@@ -101,7 +101,10 @@
 extern void do_gettimeofday(struct timeval *tv);
 extern void do_settimeofday(struct timeval *tv);
 extern void get_fast_time(struct timeval *tv);
-extern void (*do_get_fast_time)(struct timeval *);
+# ifdef __ia64__
+   /* XXX clean this up: this should be platform-specific... */
+   extern void (*do_get_fast_time)(struct timeval *);
+# endif
 #endif
 
 #define FD_SETSIZE		__FD_SETSIZE
diff -urN linux.orig/include/net/inetpeer.h linux/include/net/inetpeer.h
--- linux.orig/include/net/inetpeer.h	Wed Aug 15 15:21:32 2001
+++ linux/include/net/inetpeer.h	Mon Dec 17 20:27:41 2001
@@ -38,7 +38,7 @@
 extern struct inet_peer *inet_peer_unused_head;
 extern struct inet_peer **inet_peer_unused_tailp;
 /* can be called from BH context or outside */
-extern inline void	inet_putpeer(struct inet_peer *p)
+static inline void	inet_putpeer(struct inet_peer *p)
 {
 	spin_lock_bh(&inet_peer_unused_lock);
 	if (atomic_dec_and_test(&p->refcnt)) {
@@ -53,7 +53,7 @@
 
 extern spinlock_t inet_peer_idlock;
 /* can be called with or without local BH being disabled */
-extern inline __u16	inet_getid(struct inet_peer *p)
+static inline __u16	inet_getid(struct inet_peer *p)
 {
 	__u16 id;
 
diff -urN linux.orig/init/main.c linux/init/main.c
--- linux.orig/init/main.c	Thu Jul  5 12:31:58 2001
+++ linux/init/main.c	Mon Dec 17 20:27:41 2001
@@ -108,6 +108,9 @@
 #if defined(CONFIG_SYSVIPC)
 extern void ipc_init(void);
 #endif
+#ifdef CONFIG_PERFMON
+extern void perfmon_init(void);
+#endif
 
 /*
  * Boot command-line arguments
@@ -573,6 +576,9 @@
 #endif
 	mem_init();
 	kmem_cache_sizes_init();
+#ifdef CONFIG_PERFMON
+	perfmon_init();
+#endif
 	mempages = num_physpages;
 
 	fork_init(mempages);
diff -urN linux.orig/kernel/ksyms.c linux/kernel/ksyms.c
--- linux.orig/kernel/ksyms.c	Sun Aug 12 18:35:38 2001
+++ linux/kernel/ksyms.c	Mon Dec 17 20:27:41 2001
@@ -359,7 +359,7 @@
 EXPORT_SYMBOL(del_timer);
 EXPORT_SYMBOL(request_irq);
 EXPORT_SYMBOL(free_irq);
-#if !defined(CONFIG_ARCH_S390)
+#if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_IA64)
 EXPORT_SYMBOL(irq_stat);	/* No separate irq_stat for s390, it is part of PSA */
 #endif
 
diff -urN linux.orig/kernel/module.c linux/kernel/module.c
--- linux.orig/kernel/module.c	Sun Aug 12 12:13:59 2001
+++ linux/kernel/module.c	Mon Dec 17 20:27:41 2001
@@ -246,8 +246,23 @@
 {
 	kernel_module.nsyms = __stop___ksymtab - __start___ksymtab;
 
+	/*
+	 * XXX fix me: this should be cleaned up.  Perhaps calling
+	 * module_arch_init(&kernel_module) here would be cleanest, but this would require
+	 * updating all platform specific header files.
+	 */
 #ifdef __alpha__
 	__asm__("stq $29,%0" : "=m"(kernel_module.gp));
+#endif
+#ifdef __ia64__
+	{
+		static struct archdata archdata;
+		register char *kernel_gp asm ("gp");
+
+		archdata.gp = kernel_gp;
+		kernel_module.archdata_start = (const char *) &archdata;
+		kernel_module.archdata_end   = (const char *) (&archdata + 1);
+	}
 #endif
 }
 
diff -urN linux.orig/kernel/pm.c linux/kernel/pm.c
--- linux.orig/kernel/pm.c	Fri Apr  6 11:51:19 2001
+++ linux/kernel/pm.c	Mon Dec 17 20:27:41 2001
@@ -162,7 +162,7 @@
 	case PM_SUSPEND:
 	case PM_RESUME:
 		prev_state = dev->state;
-		next_state = (int) data;
+		next_state = (long) data;
 		if (prev_state != next_state) {
 			if (dev->callback)
 				status = (*dev->callback)(dev, rqst, data);
@@ -197,7 +197,7 @@
 			 */
 			pm_request_t undo = (dev->prev_state
 					     ? PM_SUSPEND:PM_RESUME);
-			pm_send(dev, undo, (void*) dev->prev_state);
+			pm_send(dev, undo, (void*) (long) dev->prev_state);
 		}
 		entry = entry->prev;
 	}
diff -urN linux.orig/kernel/printk.c linux/kernel/printk.c
--- linux.orig/kernel/printk.c	Fri Jun 29 20:30:36 2001
+++ linux/kernel/printk.c	Mon Dec 17 20:27:41 2001
@@ -14,6 +14,8 @@
  *     manfreds@colorfullife.com
  */
 
+#include <linux/config.h>
+
 #include <linux/mm.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
@@ -296,6 +298,12 @@
 				break;
 			}
 		}
+#ifdef CONFIG_IA64_EARLY_PRINTK
+		if (!console_drivers) {
+			static void early_printk (const char *str);
+			early_printk(msg);
+		} else
+#endif
 		if (msg_level < console_loglevel && console_drivers) {
 			struct console *c = console_drivers;
 			while(c) {
@@ -412,6 +420,10 @@
 	}
 	if ((console->flags & CON_PRINTBUFFER) == 0)
 		goto done;
+#ifdef CONFIG_IA64_EARLY_PRINTK
+	goto done;
+#endif
+
 	/*
 	 *	Print out buffered log messages.
 	 */
@@ -495,3 +507,65 @@
 		tty->driver.write(tty, 0, msg, strlen(msg));
 	return;
 }
+
+#ifdef CONFIG_IA64_EARLY_PRINTK
+
+#include <asm/io.h>
+#include <linux/serial_reg.h>
+
+#define VGABASE		((char *)0xc0000000000b8000)
+#define VGALINES	24
+#define VGACOLS		80
+
+#define UART_BASE       ((char *)0xc0000000FF5E0000)
+
+static int current_ypos = VGALINES, current_xpos = 0;
+
+void
+early_printk (const char *str)
+{
+	char c;
+#ifndef CONFIG_IA64_HP_PROTO
+	int  i, k, j;
+#endif
+
+	while ((c = *str++) != '\0') {
+#ifdef CONFIG_IA64_HP_PROTO
+		while (!(UART_LSR_TEMT & readb((char *)(UART_BASE + UART_LSR))))
+			; /* spin */
+
+		writeb(c, (char *)UART_BASE + UART_TX);
+
+		if (c == '\n')
+			writeb('\r', (char *)UART_BASE + UART_TX);
+#else
+
+		if (current_ypos >= VGALINES) {
+			/* scroll 1 line up */
+			for (k = 1, j = 0; k < VGALINES; k++, j++) {
+				for (i = 0; i < VGACOLS; i++) {
+					writew(readw(VGABASE + 2*(VGACOLS*k + i)),
+					       VGABASE + 2*(VGACOLS*j + i));
+				}
+			}
+			for (i = 0; i < VGACOLS; i++) {
+				writew(0x720, VGABASE + 2*(VGACOLS*j + i));
+			}
+			current_ypos = VGALINES-1;
+		}
+		if (c == '\n') {
+			current_xpos = 0;
+			current_ypos++;
+		} else if (c != '\r')  {
+			writew(((0x7 << 8) | (unsigned short) c),
+			       VGABASE + 2*(VGACOLS*current_ypos + current_xpos++));
+			if (current_xpos >= VGACOLS) {
+				current_xpos = 0;
+				current_ypos++;
+			}
+		}
+#endif
+	}
+}
+
+#endif /* CONFIG_IA64_EARLY_PRINTK */
diff -urN linux.orig/kernel/ptrace.c linux/kernel/ptrace.c
--- linux.orig/kernel/ptrace.c	Fri Jul 20 13:39:56 2001
+++ linux/kernel/ptrace.c	Mon Dec 17 20:27:41 2001
@@ -103,14 +103,14 @@
 	flush_cache_page(vma, addr);
 
 	if (write) {
-		maddr = kmap(page);
-		memcpy(maddr + (addr & ~PAGE_MASK), buf, len);
+		maddr = kmap(page) + (addr & ~PAGE_MASK);
+		memcpy(maddr, buf, len);
 		flush_page_to_ram(page);
-		flush_icache_page(vma, page);
+		flush_icache_range((unsigned long) maddr, (unsigned long)maddr + len);
 		kunmap(page);
 	} else {
-		maddr = kmap(page);
-		memcpy(buf, maddr + (addr & ~PAGE_MASK), len);
+		maddr = kmap(page) + (addr & ~PAGE_MASK);
+		memcpy(buf, maddr, len);
 		flush_page_to_ram(page);
 		kunmap(page);
 	}
@@ -120,7 +120,7 @@
 fault_in_page:
 	spin_unlock(&mm->page_table_lock);
 	/* -1: out of memory. 0 - unmapped page */
-	if (handle_mm_fault(mm, vma, addr, write) > 0)
+	if (handle_mm_fault(mm, vma, addr, write ? VM_WRITE : VM_READ) > 0)
 		goto repeat;
 	return 0;
 
diff -urN linux.orig/kernel/sched.c linux/kernel/sched.c
--- linux.orig/kernel/sched.c	Tue Jul 17 19:30:50 2001
+++ linux/kernel/sched.c	Mon Dec 17 20:27:41 2001
@@ -23,9 +23,11 @@
 #include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/smp_lock.h>
+#include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
 #include <linux/completion.h>
+#include <linux/prefetch.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -263,7 +265,7 @@
 				target_tsk = tsk;
 			}
 		} else {
-			if (oldest_idle == -1ULL) {
+			if (oldest_idle == (cycles_t) -1) {
 				int prio = preemption_goodness(tsk, p, cpu);
 
 				if (prio > max_prio) {
@@ -275,7 +277,7 @@
 	}
 	tsk = target_tsk;
 	if (tsk) {
-		if (oldest_idle != -1ULL) {
+		if (oldest_idle != (cycles_t) -1) {
 			best_cpu = tsk->processor;
 			goto send_now_idle;
 		}
@@ -534,6 +536,9 @@
 	struct list_head *tmp;
 	int this_cpu, c;
 
+
+	prefetch_spin_lock(&runqueue_lock);
+
 	if (!current->active_mm) BUG();
 need_resched_back:
 	prev = current;
@@ -719,18 +724,16 @@
 static inline void __wake_up_common (wait_queue_head_t *q, unsigned int mode,
 			 	     int nr_exclusive, const int sync)
 {
-	struct list_head *tmp, *head;
+	struct list_head *tmp;
 	struct task_struct *p;
 
 	CHECK_MAGIC_WQHEAD(q);
-	head = &q->task_list;
-	WQ_CHECK_LIST_HEAD(head);
-	tmp = head->next;
-	while (tmp != head) {
+	WQ_CHECK_LIST_HEAD(&q->task_list);
+	
+	list_for_each(tmp,&q->task_list) {
 		unsigned int state;
                 wait_queue_t *curr = list_entry(tmp, wait_queue_t, task_list);
 
-		tmp = tmp->next;
 		CHECK_MAGIC(curr->__magic);
 		p = curr->task;
 		state = p->state;
diff -urN linux.orig/kernel/softirq.c linux/kernel/softirq.c
--- linux.orig/kernel/softirq.c	Sat Jul 28 13:59:12 2001
+++ linux/kernel/softirq.c	Mon Dec 17 20:27:41 2001
@@ -40,7 +40,10 @@
    - Bottom halves: globally serialized, grr...
  */
 
+/* No separate irq_stat for ia64, it is part of PSA */
+#if !defined(CONFIG_IA64)
 irq_cpustat_t irq_stat[NR_CPUS];
+#endif	/* CONFIG_IA64 */
 
 static struct softirq_action softirq_vec[32] __cacheline_aligned;
 
@@ -60,7 +63,6 @@
 
 asmlinkage void do_softirq()
 {
-	int cpu = smp_processor_id();
 	__u32 pending;
 	long flags;
 	__u32 mask;
@@ -70,7 +72,7 @@
 
 	local_irq_save(flags);
 
-	pending = softirq_pending(cpu);
+	pending = local_softirq_pending();
 
 	if (pending) {
 		struct softirq_action *h;
@@ -79,7 +81,7 @@
 		local_bh_disable();
 restart:
 		/* Reset the pending bitmask before enabling irqs */
-		softirq_pending(cpu) = 0;
+		local_softirq_pending() = 0;
 
 		local_irq_enable();
 
@@ -94,7 +96,7 @@
 
 		local_irq_disable();
 
-		pending = softirq_pending(cpu);
+		pending = local_softirq_pending();
 		if (pending & mask) {
 			mask &= ~pending;
 			goto restart;
@@ -102,7 +104,7 @@
 		__local_bh_enable();
 
 		if (pending)
-			wakeup_softirqd(cpu);
+			wakeup_softirqd(smp_processor_id());
 	}
 
 	local_irq_restore(flags);
@@ -121,7 +123,7 @@
 	 * Otherwise we wake up ksoftirqd to make sure we
 	 * schedule the softirq soon.
 	 */
-	if (!(local_irq_count(cpu) | local_bh_count(cpu)))
+	if (!(irq_count(cpu) | bh_count(cpu)))
 		wakeup_softirqd(cpu);
 }
 
@@ -281,18 +283,16 @@
 
 static void bh_action(unsigned long nr)
 {
-	int cpu = smp_processor_id();
-
 	if (!spin_trylock(&global_bh_lock))
 		goto resched;
 
-	if (!hardirq_trylock(cpu))
+	if (!local_hardirq_trylock())
 		goto resched_unlock;
 
 	if (bh_base[nr])
 		bh_base[nr]();
 
-	hardirq_endlock(cpu);
+	local_hardirq_endlock();
 	spin_unlock(&global_bh_lock);
 	return;
 
@@ -371,15 +371,15 @@
 	__set_current_state(TASK_INTERRUPTIBLE);
 	mb();
 
-	ksoftirqd_task(cpu) = current;
+	local_ksoftirqd_task() = current;
 
 	for (;;) {
-		if (!softirq_pending(cpu))
+		if (!local_softirq_pending())
 			schedule();
 
 		__set_current_state(TASK_RUNNING);
 
-		while (softirq_pending(cpu)) {
+		while (local_softirq_pending()) {
 			do_softirq();
 			if (current->need_resched)
 				schedule();
diff -urN linux.orig/kernel/time.c linux/kernel/time.c
--- linux.orig/kernel/time.c	Mon Oct 16 13:58:51 2000
+++ linux/kernel/time.c	Mon Dec 17 20:27:41 2001
@@ -36,11 +36,16 @@
  */
 struct timezone sys_tz;
 
+#ifndef __ia64__
+
 static void do_normal_gettime(struct timeval * tm)
 {
         *tm=xtime;
 }
 
+/* This indirection is needed only for x86 and other architectures
+   which do not have uniform support for cycle counters... */
+
 void (*do_get_fast_time)(struct timeval *) = do_normal_gettime;
 
 /*
@@ -54,9 +59,12 @@
 	do_get_fast_time(t);
 }
 
+#endif /* !__ia64__ */
+
 /* The xtime_lock is not only serializing the xtime read/writes but it's also
    serializing all accesses to the global NTP variables now. */
 extern rwlock_t xtime_lock;
+extern unsigned long last_time_offset;
 
 #if !defined(__alpha__) && !defined(__ia64__)
 
@@ -100,6 +108,7 @@
 	write_lock_irq(&xtime_lock);
 	xtime.tv_sec = value;
 	xtime.tv_usec = 0;
+	last_time_offset = 0;
 	time_adjust = 0;	/* stop active adjtime() */
 	time_status |= STA_UNSYNC;
 	time_maxerror = NTP_PHASE_LIMIT;
@@ -145,6 +154,7 @@
 {
 	write_lock_irq(&xtime_lock);
 	xtime.tv_sec += sys_tz.tz_minuteswest * 60;
+	last_time_offset = 0;
 	write_unlock_irq(&xtime_lock);
 }
 
@@ -231,13 +241,13 @@
 	/* In order to modify anything, you gotta be super-user! */
 	if (txc->modes && !capable(CAP_SYS_TIME))
 		return -EPERM;
-		
+
 	/* Now we validate the data before disabling interrupts */
 
 	if (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))
 	  /* adjustment Offset limited to +- .512 seconds */
 		if (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )
-			return -EINVAL;	
+			return -EINVAL;
 
 	/* if the quartz is off by more than 10% something is VERY wrong ! */
 	if (txc->modes & ADJ_TICK)
@@ -374,7 +384,7 @@
 		&& (time_status & (STA_PPSWANDER|STA_PPSERROR)) != 0))
 	    /* p. 24, (d) */
 		result = TIME_ERROR;
-	
+
 	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT)
 	    txc->offset	   = save_adjust;
 	else {
@@ -399,6 +409,7 @@
 	txc->calcnt	   = pps_calcnt;
 	txc->errcnt	   = pps_errcnt;
 	txc->stbcnt	   = pps_stbcnt;
+	last_time_offset = 0;
 	write_unlock_irq(&xtime_lock);
 	do_gettimeofday(&txc->time);
 	return(result);
diff -urN linux.orig/kernel/timer.c linux/kernel/timer.c
--- linux.orig/kernel/timer.c	Tue Jun 12 17:40:11 2001
+++ linux/kernel/timer.c	Mon Dec 17 20:27:41 2001
@@ -592,7 +592,7 @@
 		else
 			kstat.per_cpu_user[cpu] += user_tick;
 		kstat.per_cpu_system[cpu] += system;
-	} else if (local_bh_count(cpu) || local_irq_count(cpu) > 1)
+	} else if (local_bh_count() || local_irq_count() > 1)
 		kstat.per_cpu_system[cpu] += system;
 }
 
@@ -644,6 +644,7 @@
  * This spinlock protect us from races in SMP while playing with xtime. -arca
  */
 rwlock_t xtime_lock = RW_LOCK_UNLOCKED;
+unsigned long last_time_offset;
 
 static inline void update_times(void)
 {
@@ -661,6 +662,7 @@
 		wall_jiffies += ticks;
 		update_wall_time(ticks);
 	}
+	last_time_offset = 0;
 	write_unlock_irq(&xtime_lock);
 	calc_load(ticks);
 }
@@ -673,7 +675,7 @@
 
 void do_timer(struct pt_regs *regs)
 {
-	(*(unsigned long *)&jiffies)++;
+	(*(volatile unsigned long *)&jiffies)++;
 #ifndef CONFIG_SMP
 	/* SMP process accounting uses the local APIC timer */
 
@@ -805,7 +807,7 @@
 	if (t.tv_nsec >= 1000000000L || t.tv_nsec < 0 || t.tv_sec < 0)
 		return -EINVAL;
 
-
+#if !defined(__ia64__)
 	if (t.tv_sec == 0 && t.tv_nsec <= 2000000L &&
 	    current->policy != SCHED_OTHER)
 	{
@@ -818,6 +820,7 @@
 		udelay((t.tv_nsec + 999) / 1000);
 		return 0;
 	}
+#endif
 
 	expire = timespec_to_jiffies(&t) + (t.tv_sec || t.tv_nsec);
 
diff -urN linux.orig/lib/Makefile linux/lib/Makefile
--- linux.orig/lib/Makefile	Wed Apr 25 14:31:03 2001
+++ linux/lib/Makefile	Mon Dec 17 20:27:41 2001
@@ -10,7 +10,7 @@
 
 export-objs := cmdline.o rwsem-spinlock.o rwsem.o
 
-obj-y := errno.o ctype.o string.o vsprintf.o brlock.o cmdline.o
+obj-y := errno.o ctype.o string.o vsprintf.o brlock.o cmdline.o crc32.o
 
 obj-$(CONFIG_RWSEM_GENERIC_SPINLOCK) += rwsem-spinlock.o
 obj-$(CONFIG_RWSEM_XCHGADD_ALGORITHM) += rwsem.o
diff -urN linux.orig/lib/crc32.c linux/lib/crc32.c
--- linux.orig/lib/crc32.c	Wed Dec 31 17:00:00 1969
+++ linux/lib/crc32.c	Mon Dec 17 20:27:41 2001
@@ -0,0 +1,125 @@
+/* 
+ * Dec 5, 2000 Matt Domsch <Matt_Domsch@dell.com>
+ * - Copied crc32.c from the linux/drivers/net/cipe directory.
+ * - Now pass seed as an arg
+ * - changed unsigned long to u32, added #include<linux/types.h>
+ * - changed len to be an unsigned long
+ * - changed crc32val to be a register
+ * - License remains unchanged!  It's still GPL-compatable!
+ */
+
+  /* ============================================================= */
+  /*  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or       */
+  /*  code or tables extracted from it, as desired without restriction.     */
+  /*                                                                        */
+  /*  First, the polynomial itself and its table of feedback terms.  The    */
+  /*  polynomial is                                                         */
+  /*  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0   */
+  /*                                                                        */
+  /*  Note that we take it "backwards" and put the highest-order term in    */
+  /*  the lowest-order bit.  The X^32 term is "implied"; the LSB is the     */
+  /*  X^31 term, etc.  The X^0 term (usually shown as "+1") results in      */
+  /*  the MSB being 1.                                                      */
+  /*                                                                        */
+  /*  Note that the usual hardware shift register implementation, which     */
+  /*  is what we're using (we're merely optimizing it by doing eight-bit    */
+  /*  chunks at a time) shifts bits into the lowest-order term.  In our     */
+  /*  implementation, that means shifting towards the right.  Why do we     */
+  /*  do it this way?  Because the calculated CRC must be transmitted in    */
+  /*  order from highest-order term to lowest-order term.  UARTs transmit   */
+  /*  characters in order from LSB to MSB.  By storing the CRC this way,    */
+  /*  we hand it to the UART in the order low-byte to high-byte; the UART   */
+  /*  sends each low-bit to hight-bit; and the result is transmission bit   */
+  /*  by bit from highest- to lowest-order term without requiring any bit   */
+  /*  shuffling on our part.  Reception works similarly.                    */
+  /*                                                                        */
+  /*  The feedback terms table consists of 256, 32-bit entries.  Notes:     */
+  /*                                                                        */
+  /*      The table can be generated at runtime if desired; code to do so   */
+  /*      is shown later.  It might not be obvious, but the feedback        */
+  /*      terms simply represent the results of eight shift/xor opera-      */
+  /*      tions for all combinations of data and CRC register values.       */
+  /*                                                                        */
+  /*      The values must be right-shifted by eight bits by the "updcrc"    */
+  /*      logic; the shift must be unsigned (bring in zeroes).  On some     */
+  /*      hardware you could probably optimize the shift in assembler by    */
+  /*      using byte-swap instructions.                                     */
+  /*      polynomial $edb88320                                              */
+  /*                                                                        */
+  /*  --------------------------------------------------------------------  */
+
+#include <linux/crc32.h>
+
+static u32 crc32_tab[] = {
+      0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+      0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+      0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+      0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+      0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+      0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+      0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+      0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+      0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+      0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+      0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+      0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+      0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+      0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+      0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+      0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+      0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+      0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+      0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+      0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+      0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+      0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+      0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+      0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+      0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+      0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+      0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+      0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+      0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+      0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+      0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+      0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+      0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+      0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+      0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+      0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+      0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+      0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+      0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+      0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+      0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+      0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+      0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+      0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+      0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+      0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+      0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+      0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+      0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+      0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+      0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+      0x2d02ef8dL
+   };
+
+/* Return a 32-bit CRC of the contents of the buffer. */
+
+u32
+crc32(const void *buf, unsigned long len, u32 seed)
+{
+  unsigned long i;
+  register u32 crc32val;
+  const unsigned char *s = buf;
+
+  crc32val = seed;
+  for (i = 0;  i < len;  i ++)
+    {
+      crc32val =
+	crc32_tab[(crc32val ^ s[i]) & 0xff] ^
+	  (crc32val >> 8);
+    }
+  return crc32val;
+}
diff -urN linux.orig/lib/vsprintf.c linux/lib/vsprintf.c
--- linux.orig/lib/vsprintf.c	Sun Aug  5 14:12:41 2001
+++ linux/lib/vsprintf.c	Mon Dec 17 20:27:41 2001
@@ -308,6 +308,10 @@
 		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
 			qualifier = *fmt;
 			++fmt;
+			if (qualifier == 'l' && *fmt == 'l') {
+				qualifier = 'L';
+				++fmt;
+			}
 		}
 
 		/* default base */
diff -urN linux.orig/mm/memory.c linux/mm/memory.c
--- linux.orig/mm/memory.c	Mon Aug 13 17:16:41 2001
+++ linux/mm/memory.c	Mon Dec 17 20:27:41 2001
@@ -44,6 +44,7 @@
 #include <linux/iobuf.h>
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
+#include <linux/prefetch.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -103,8 +104,10 @@
 	}
 	pmd = pmd_offset(dir, 0);
 	pgd_clear(dir);
-	for (j = 0; j < PTRS_PER_PMD ; j++)
+	for (j = 0; j < PTRS_PER_PMD ; j++) {
+		prefetchw(pmd + j + PREFETCH_STRIDE/sizeof(*pmd));
 		free_one_pmd(pmd+j);
+	}
 	pmd_free(pmd);
 }
 
@@ -494,7 +497,7 @@
 			int ret;
 
 			spin_unlock(&mm->page_table_lock);
-			ret = handle_mm_fault(current->mm, vma, ptr, datain);
+			ret = handle_mm_fault(current->mm, vma, ptr, datain ? VM_WRITE : VM_READ);
 			if (ret <= 0) {
 				if (!ret)
 					goto out_unlock;
@@ -1155,7 +1158,6 @@
 	UnlockPage(page);
 
 	flush_page_to_ram(page);
-	flush_icache_page(vma, page);
 	set_pte(page_table, pte);
 
 	/* No need to invalidate - it was non-present before */
@@ -1256,7 +1258,6 @@
 	if (pte_none(*page_table)) {
 		++mm->rss;
 		flush_page_to_ram(new_page);
-		flush_icache_page(vma, new_page);
 		entry = mk_pte(new_page, vma->vm_page_prot);
 		if (write_access) {
 			entry = pte_mkwrite(pte_mkdirty(entry));
@@ -1295,8 +1296,10 @@
  */
 static inline int handle_pte_fault(struct mm_struct *mm,
 	struct vm_area_struct * vma, unsigned long address,
-	int write_access, pte_t * pte)
+	int access_type, pte_t * pte)
 {
+	int write_access = is_write_access(access_type);
+	int exec_access = is_exec_access(access_type);
 	pte_t entry;
 
 	entry = *pte;
@@ -1317,6 +1320,8 @@
 
 		entry = pte_mkdirty(entry);
 	}
+	if (exec_access)
+		entry = pte_mkexec(entry);
 	entry = pte_mkyoung(entry);
 	establish_pte(vma, address, pte, entry);
 	return 1;
@@ -1326,7 +1331,7 @@
  * By the time we get here, we already hold the mm semaphore
  */
 int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct * vma,
-	unsigned long address, int write_access)
+	unsigned long address, int access_type)
 {
 	int ret = -1;
 	pgd_t *pgd;
@@ -1345,7 +1350,7 @@
 	if (pmd) {
 		pte_t * pte = pte_alloc(mm, pmd, address);
 		if (pte)
-			ret = handle_pte_fault(mm, vma, address, write_access, pte);
+			ret = handle_pte_fault(mm, vma, address, access_type, pte);
 	}
 	spin_unlock(&mm->page_table_lock);
 	return ret;
@@ -1436,7 +1441,7 @@
 	if (addr >= end)
 		BUG();
 	do {
-		if (handle_mm_fault(mm, vma, addr, write) < 0)
+		if (handle_mm_fault(mm, vma, addr, write ? VM_WRITE : VM_READ) < 0)
 			return -1;
 		addr += PAGE_SIZE;
 	} while (addr < end);
diff -urN linux.orig/mm/mmap.c linux/mm/mmap.c
--- linux.orig/mm/mmap.c	Wed Aug 15 12:10:03 2001
+++ linux/mm/mmap.c	Mon Dec 17 20:27:41 2001
@@ -197,6 +197,12 @@
 		_trans(prot, PROT_WRITE, VM_WRITE) |
 		_trans(prot, PROT_EXEC, VM_EXEC);
 	flag_bits =
+#ifdef MAP_WRITECOMBINED
+		_trans(flags, MAP_WRITECOMBINED, VM_WRITECOMBINED) |
+#endif
+#ifdef MAP_NONCACHED
+		_trans(flags, MAP_NONCACHED, VM_NONCACHED) |
+#endif
 		_trans(flags, MAP_GROWSDOWN, VM_GROWSDOWN) |
 		_trans(flags, MAP_DENYWRITE, VM_DENYWRITE) |
 		_trans(flags, MAP_EXECUTABLE, VM_EXECUTABLE);
diff -urN linux.orig/mm/shmem.c linux/mm/shmem.c
--- linux.orig/mm/shmem.c	Sun Aug 12 19:58:52 2001
+++ linux/mm/shmem.c	Mon Dec 17 20:27:41 2001
@@ -26,7 +26,7 @@
 #include <linux/pagemap.h>
 #include <linux/string.h>
 #include <linux/locks.h>
-#include <asm/smplock.h>
+#include <linux/smp_lock.h>
 
 #include <asm/uaccess.h>
 
diff -urN linux.orig/net/ipv4/fib_semantics.c linux/net/ipv4/fib_semantics.c
--- linux.orig/net/ipv4/fib_semantics.c	Tue Aug 22 09:59:00 2000
+++ linux/net/ipv4/fib_semantics.c	Mon Dec 17 20:27:41 2001
@@ -155,7 +155,7 @@
 	return 0;
 }
 
-extern __inline__ struct fib_info * fib_find_info(const struct fib_info *nfi)
+static __inline__ struct fib_info * fib_find_info(const struct fib_info *nfi)
 {
 	for_fib_info() {
 		if (fi->fib_nhs != nfi->fib_nhs)
diff -urN linux.orig/net/ipv4/ip_fragment.c linux/net/ipv4/ip_fragment.c
--- linux.orig/net/ipv4/ip_fragment.c	Thu Apr 12 13:11:39 2001
+++ linux/net/ipv4/ip_fragment.c	Mon Dec 17 20:27:41 2001
@@ -130,19 +130,19 @@
 atomic_t ip_frag_mem = ATOMIC_INIT(0);	/* Memory used for fragments */
 
 /* Memory Tracking Functions. */
-extern __inline__ void frag_kfree_skb(struct sk_buff *skb)
+static __inline__ void frag_kfree_skb(struct sk_buff *skb)
 {
 	atomic_sub(skb->truesize, &ip_frag_mem);
 	kfree_skb(skb);
 }
 
-extern __inline__ void frag_free_queue(struct ipq *qp)
+static __inline__ void frag_free_queue(struct ipq *qp)
 {
 	atomic_sub(sizeof(struct ipq), &ip_frag_mem);
 	kfree(qp);
 }
 
-extern __inline__ struct ipq *frag_alloc_queue(void)
+static __inline__ struct ipq *frag_alloc_queue(void)
 {
 	struct ipq *qp = kmalloc(sizeof(struct ipq), GFP_ATOMIC);
 
