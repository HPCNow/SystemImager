###############################################################################
# extraced from the kernel-image-2.4.18-ia64-020508.4 package in Debian       #
###############################################################################
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/Documentation/Configure.help linux/Documentation/Configure.help
--- ../prev/linux/Documentation/Configure.help	Tue Jul  9 18:03:36 2002
+++ linux/Documentation/Configure.help	Wed May 29 13:45:31 2002
@@ -3110,13 +3110,11 @@
   say N here to save some memory. You can also say Y if you have an
   "intelligent" multiport card such as Cyclades, Digiboards, etc.
 
-Support for serial ports defined by ACPI tables
+Support for serial ports defined in ACPI namespace
 CONFIG_SERIAL_ACPI
-  Legacy free machines may not have serial ports at the legacy COM1, 
-  COM2 etc addresses. Serial ports on such machines are described by
-  the ACPI tables SPCR (Serial Port Console Redirection) table and 
-  DBGP (Debug Port) table. Say Y here if you want to include support
-  for these serial ports.
+  Some machines have non-PCI serial ports described in the ACPI namespace.
+  This option adds support to the serial driver for discovering them.
+  If you are unsure, say Y.
 
 Support for sharing serial interrupts
 CONFIG_SERIAL_SHARE_IRQ
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/Makefile linux/arch/ia64/Makefile
--- ../prev/linux/arch/ia64/Makefile	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/Makefile	Wed May 15 10:15:02 2002
@@ -36,6 +36,8 @@
 	CORE_FILES      :=      arch/$(ARCH)/hp/hp.o			\
 				arch/$(ARCH)/dig/dig.a			\
 				$(CORE_FILES)
+#				arch/$(ARCH)/sn/sn.o
+#				arch/$(ARCH)/sn/io/sgiio.o
 	SUBDIRS		:=	arch/$(ARCH)/hp		\
 				arch/$(ARCH)/dig	\
 				$(SUBDIRS)
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/config.in linux/arch/ia64/config.in
--- ../prev/linux/arch/ia64/config.in	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/config.in	Thu Jul  4 08:02:44 2002
@@ -58,8 +58,6 @@
 	 64KB			CONFIG_IA64_PAGE_SIZE_64KB" 16KB
 fi
 
-bool 'Virtually mapped mem_map?' CONFIG_VIRTUAL_MEM_MAP n
-
 if [ "$CONFIG_ITANIUM" = "y" ]; then
 	define_bool CONFIG_IA64_BRL_EMU y
 	bool '  Enable Itanium B-step specific code' CONFIG_ITANIUM_BSTEP_SPECIFIC
@@ -72,10 +70,6 @@
 
 if [ "$CONFIG_MCKINLEY" = "y" ]; then
 	define_int CONFIG_IA64_L1_CACHE_SHIFT 7
-	bool '  Enable McKinley A-step specific code' CONFIG_MCKINLEY_ASTEP_SPECIFIC
-	if [ "$CONFIG_MCKINLEY_ASTEP_SPECIFIC" = "y" ]; then
-	  bool '   Enable McKinley A0/A1-step specific code' CONFIG_MCKINLEY_A0_SPECIFIC
-	fi
 fi
 
 if [ "$CONFIG_IA64_GENERIC" = "y" ] || [ "$CONFIG_IA64_DIG" = "y" ] \
@@ -84,6 +78,10 @@
 	define_bool CONFIG_PM y
 fi
 
+if [ "$CONFIG_IA64_GENERIC" = "y" ] || [ "$CONFIG_IA64_HP_ZX1" = "y" ]; then
+	bool '  Enable Hewlett-Packard prototype suport' CONFIG_IA64_HP_PROTO
+fi
+
 if [ "$CONFIG_IA64_SGI_SN1" = "y" ] || [ "$CONFIG_IA64_SGI_SN2" = "y" ]; then
 	define_bool CONFIG_IA64_SGI_SN y
 	bool '  Enable extra debugging code' CONFIG_IA64_SGI_SN_DEBUG n
@@ -101,6 +99,8 @@
 	define_bool CONFIG_PERCPU_IRQ y
 	tristate '  PCIBA support' CONFIG_PCIBA
 fi
+
+bool '  BMC support' CONFIG_BMC
 
 define_bool CONFIG_KCORE_ELF y	# On IA-64, we always want an ELF /proc/kcore.
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/defconfig linux/arch/ia64/defconfig
--- ../prev/linux/arch/ia64/defconfig	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/defconfig	Fri Jun 14 11:28:06 2002
@@ -12,7 +12,7 @@
 #
 CONFIG_MODULES=y
 CONFIG_MODVERSIONS=y
-# CONFIG_KMOD is not set
+CONFIG_KMOD=y
 
 #
 # General setup
@@ -28,22 +28,22 @@
 CONFIG_ACPI_EFI=y
 CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_KERNEL_CONFIG=y
-CONFIG_ITANIUM=y
-# CONFIG_MCKINLEY is not set
-# CONFIG_IA64_GENERIC is not set
-CONFIG_IA64_DIG=y
+# CONFIG_ITANIUM is not set
+CONFIG_MCKINLEY=y
+CONFIG_IA64_GENERIC=y
+# CONFIG_IA64_DIG is not set
 # CONFIG_IA64_HP_SIM is not set
+# CONFIG_IA64_HP_ZX1 is not set
 # CONFIG_IA64_SGI_SN1 is not set
 # CONFIG_IA64_SGI_SN2 is not set
 # CONFIG_IA64_PAGE_SIZE_4KB is not set
 # CONFIG_IA64_PAGE_SIZE_8KB is not set
 CONFIG_IA64_PAGE_SIZE_16KB=y
 # CONFIG_IA64_PAGE_SIZE_64KB is not set
-CONFIG_IA64_BRL_EMU=y
-# CONFIG_ITANIUM_BSTEP_SPECIFIC is not set
-CONFIG_IA64_L1_CACHE_SHIFT=6
+CONFIG_IA64_L1_CACHE_SHIFT=7
 CONFIG_IA64_MCA=y
 CONFIG_PM=y
+# CONFIG_IA64_HP_PROTO is not set
 CONFIG_KCORE_ELF=y
 CONFIG_SMP=y
 CONFIG_IA32_SUPPORT=y
@@ -52,46 +52,119 @@
 CONFIG_EFI_VARS=y
 CONFIG_NET=y
 CONFIG_SYSVIPC=y
-# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_BSD_PROCESS_ACCT=y
 CONFIG_SYSCTL=y
 CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
+CONFIG_BINFMT_MISC=m
+
+#
+# ACPI Support
+#
+CONFIG_ACPI=y
+CONFIG_ACPI_EFI=y
+CONFIG_ACPI_BOOT=y
+CONFIG_ACPI_BUS=y
+CONFIG_ACPI_INTERPRETER=y
+CONFIG_ACPI_PCI=y
+CONFIG_ACPI_POWER=y
+CONFIG_ACPI_SYSTEM=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_THERMAL=y
 # CONFIG_ACPI_DEBUG is not set
-# CONFIG_ACPI_BUSMGR is not set
-# CONFIG_ACPI_SYS is not set
-# CONFIG_ACPI_CPU is not set
-# CONFIG_ACPI_BUTTON is not set
-# CONFIG_ACPI_AC is not set
-# CONFIG_ACPI_EC is not set
-# CONFIG_ACPI_CMBATT is not set
-# CONFIG_ACPI_THERMAL is not set
 CONFIG_PCI=y
 CONFIG_PCI_NAMES=y
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
 # CONFIG_PCMCIA is not set
 
 #
 # Parallel port support
 #
-# CONFIG_PARPORT is not set
+CONFIG_PARPORT=m
+CONFIG_PARPORT_PC=m
+CONFIG_PARPORT_PC_CML1=m
+CONFIG_PARPORT_SERIAL=m
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+# CONFIG_PARPORT_AMIGA is not set
+# CONFIG_PARPORT_MFC3 is not set
+# CONFIG_PARPORT_ATARI is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_SUNBPP is not set
+# CONFIG_PARPORT_OTHER is not set
+CONFIG_PARPORT_1284=y
 
 #
 # Networking options
 #
 CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-# CONFIG_NETLINK is not set
-# CONFIG_NETFILTER is not set
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=m
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
 CONFIG_FILTER=y
 CONFIG_UNIX=y
 CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_FWMARK=y
+CONFIG_IP_ROUTE_NAT=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_TOS=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_ROUTE_LARGE_TABLES=y
 # CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
+CONFIG_NET_IPIP=m
 # CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
 # CONFIG_INET_ECN is not set
-# CONFIG_SYN_COOKIES is not set
+CONFIG_SYN_COOKIES=y
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+# CONFIG_IP_NF_MATCH_AH_ESP is not set
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_UNCLEAN=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_MIRROR=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_LOG=m
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_IP_NF_TARGET_TCPMSS=m
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 # CONFIG_IPV6 is not set
 # CONFIG_KHTTPD is not set
 # CONFIG_ATM is not set
@@ -134,14 +207,66 @@
 #
 # CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_XD is not set
-# CONFIG_PARIDE is not set
+CONFIG_PARIDE=m
+CONFIG_PARIDE_PARPORT=m
+
+#
+# Parallel IDE high-level drivers
+#
+CONFIG_PARIDE_PD=m
+CONFIG_PARIDE_PCD=m
+CONFIG_PARIDE_PF=m
+CONFIG_PARIDE_PT=m
+CONFIG_PARIDE_PG=m
+
+#
+# Parallel IDE protocol modules
+#
+CONFIG_PARIDE_ATEN=m
+CONFIG_PARIDE_BPCK=m
+CONFIG_PARIDE_BPCK6=m
+CONFIG_PARIDE_COMM=m
+CONFIG_PARIDE_DSTR=m
+CONFIG_PARIDE_FIT2=m
+CONFIG_PARIDE_FIT3=m
+CONFIG_PARIDE_EPAT=m
+CONFIG_PARIDE_EPATC8=y
+CONFIG_PARIDE_EPIA=m
+CONFIG_PARIDE_FRIQ=m
+CONFIG_PARIDE_FRPW=m
+CONFIG_PARIDE_KBIC=m
+CONFIG_PARIDE_KTTI=m
+CONFIG_PARIDE_ON20=m
+CONFIG_PARIDE_ON26=m
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+CONFIG_IEEE1394=m
+
+#
+# Device Drivers
+#
+CONFIG_IEEE1394_PCILYNX=m
+# CONFIG_IEEE1394_PCILYNX_LOCALRAM is not set
+# CONFIG_IEEE1394_PCILYNX_PORTS is not set
+CONFIG_IEEE1394_OHCI1394=m
+
+#
+# Protocol Drivers
+#
+CONFIG_IEEE1394_VIDEO1394=m
+CONFIG_IEEE1394_SBP2=m
+CONFIG_IEEE1394_RAWIO=m
+# CONFIG_IEEE1394_VERBOSEDEBUG is not set
 
 #
 # I2O device support
@@ -156,14 +281,24 @@
 #
 # Multi-device support (RAID and LVM)
 #
-# CONFIG_MD is not set
-# CONFIG_BLK_DEV_MD is not set
-# CONFIG_MD_LINEAR is not set
-# CONFIG_MD_RAID0 is not set
-# CONFIG_MD_RAID1 is not set
-# CONFIG_MD_RAID5 is not set
-# CONFIG_MD_MULTIPATH is not set
-# CONFIG_BLK_DEV_LVM is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID5=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_BLK_DEV_LVM=m
+
+#
+# Fusion MPT device support
+#
+CONFIG_FUSION=y
+CONFIG_FUSION_BOOT=y
+CONFIG_FUSION_ISENSE=m
+CONFIG_FUSION_CTL=m
+CONFIG_FUSION_LAN=m
+CONFIG_NET_FC=y
 
 #
 # ATA/IDE/MFM/RLL support
@@ -181,7 +316,7 @@
 # CONFIG_BLK_DEV_HD_IDE is not set
 # CONFIG_BLK_DEV_HD is not set
 CONFIG_BLK_DEV_IDEDISK=y
-CONFIG_IDEDISK_MULTI_MODE=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
 # CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
 # CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
 # CONFIG_BLK_DEV_IDEDISK_IBM is not set
@@ -209,7 +344,7 @@
 CONFIG_BLK_DEV_IDEDMA_PCI=y
 CONFIG_BLK_DEV_ADMA=y
 # CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_IDEDMA_PCI_AUTO is not set
+CONFIG_IDEDMA_PCI_AUTO=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_PCI_WIP is not set
 # CONFIG_IDEDMA_NEW_DRIVE_LISTINGS is not set
@@ -219,14 +354,14 @@
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
-# CONFIG_BLK_DEV_CMD64X is not set
+CONFIG_BLK_DEV_CMD64X=y
 # CONFIG_BLK_DEV_CY82C693 is not set
 # CONFIG_BLK_DEV_CS5530 is not set
 # CONFIG_BLK_DEV_HPT34X is not set
 # CONFIG_HPT34X_AUTODMA is not set
 # CONFIG_BLK_DEV_HPT366 is not set
 CONFIG_BLK_DEV_PIIX=y
-# CONFIG_PIIX_TUNING is not set
+CONFIG_PIIX_TUNING=y
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_OPTI621 is not set
 # CONFIG_BLK_DEV_PDC202XX is not set
@@ -238,7 +373,7 @@
 # CONFIG_BLK_DEV_TRM290 is not set
 # CONFIG_BLK_DEV_VIA82CXXX is not set
 # CONFIG_IDE_CHIPSETS is not set
-# CONFIG_IDEDMA_AUTO is not set
+CONFIG_IDEDMA_AUTO=y
 # CONFIG_IDEDMA_IVB is not set
 # CONFIG_DMA_NONPCI is not set
 CONFIG_BLK_DEV_IDE_MODES=y
@@ -256,16 +391,18 @@
 #
 CONFIG_BLK_DEV_SD=y
 CONFIG_SD_EXTRA_DEVS=40
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_ST=y
+CONFIG_CHR_DEV_OSST=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=2
+CONFIG_CHR_DEV_SG=y
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
-CONFIG_SCSI_DEBUG_QUEUES=y
-# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+CONFIG_SCSI_MULTI_LUN=y
 CONFIG_SCSI_CONSTANTS=y
 CONFIG_SCSI_LOGGING=y
 
@@ -278,13 +415,16 @@
 # CONFIG_SCSI_AHA152X is not set
 # CONFIG_SCSI_AHA1542 is not set
 # CONFIG_SCSI_AHA1740 is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=y
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=253
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_BUILD_FIRMWARE is not set
 # CONFIG_SCSI_DPT_I2O is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_IN2000 is not set
 # CONFIG_SCSI_AM53C974 is not set
-# CONFIG_SCSI_MEGARAID is not set
+CONFIG_SCSI_MEGARAID=y
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -297,11 +437,21 @@
 # CONFIG_SCSI_GENERIC_NCR5380 is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_PPA is not set
+# CONFIG_SCSI_IMM is not set
 # CONFIG_SCSI_NCR53C406A is not set
 # CONFIG_SCSI_NCR53C7xx is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
 # CONFIG_SCSI_NCR53C8XX is not set
 # CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_NCR53C8XX_PROFILE is not set
+# CONFIG_SCSI_NCR53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_NCR53C8XX_PQS_PDS is not set
+# CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT is not set
 # CONFIG_SCSI_PAS16 is not set
 # CONFIG_SCSI_PCI2000 is not set
 # CONFIG_SCSI_PCI2220I is not set
@@ -327,10 +477,11 @@
 # ARCnet devices
 #
 # CONFIG_ARCNET is not set
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
 
 #
 # Ethernet (10 or 100Mbit)
@@ -340,77 +491,141 @@
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNBMAC is not set
 # CONFIG_SUNQE is not set
-# CONFIG_SUNLANCE is not set
 # CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_EL1 is not set
+# CONFIG_EL2 is not set
+# CONFIG_ELPLUS is not set
+# CONFIG_EL16 is not set
+# CONFIG_ELMC is not set
+# CONFIG_ELMC_II is not set
+CONFIG_VORTEX=m
 # CONFIG_LANCE is not set
-# CONFIG_NET_VENDOR_SMC is not set
-# CONFIG_NET_VENDOR_RACAL is not set
+CONFIG_NET_VENDOR_SMC=y
+# CONFIG_WD80x3 is not set
+# CONFIG_ULTRAMCA is not set
+# CONFIG_ULTRA is not set
+# CONFIG_ULTRA32 is not set
+# CONFIG_SMC9194 is not set
+CONFIG_NET_VENDOR_RACAL=y
+# CONFIG_NI5010 is not set
+# CONFIG_NI52 is not set
+# CONFIG_NI65 is not set
 # CONFIG_HP100 is not set
 # CONFIG_NET_ISA is not set
 CONFIG_NET_PCI=y
-# CONFIG_PCNET32 is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_PCNET32=m
+CONFIG_ADAPTEC_STARFIRE=m
 # CONFIG_APRICOT is not set
 # CONFIG_CS89x0 is not set
-# CONFIG_TULIP is not set
-# CONFIG_DE4X5 is not set
-# CONFIG_DGRS is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+CONFIG_DE4X5=m
+CONFIG_DGRS=m
 # CONFIG_DM9102 is not set
 CONFIG_EEPRO100=y
 # CONFIG_LNE390 is not set
 # CONFIG_FEALNX is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NE2K_PCI is not set
+CONFIG_NATSEMI=m
+# CONFIG_NATSEMI_CABLE_MAGIC is not set
+CONFIG_NE2K_PCI=m
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
+CONFIG_8139TOO=m
 # CONFIG_8139TOO_PIO is not set
 # CONFIG_8139TOO_TUNE_TWISTER is not set
 # CONFIG_8139TOO_8129 is not set
-# CONFIG_SIS900 is not set
-# CONFIG_EPIC100 is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
-# CONFIG_VIA_RHINE is not set
+# CONFIG_8139_NEW_RX_RESET is not set
+CONFIG_SIS900=m
+CONFIG_EPIC100=m
+CONFIG_SUNDANCE=m
+CONFIG_TLAN=m
+CONFIG_VIA_RHINE=m
 # CONFIG_VIA_RHINE_MMIO is not set
-# CONFIG_WINBOND_840 is not set
+CONFIG_WINBOND_840=m
 # CONFIG_NET_POCKET is not set
 
 #
 # Ethernet (1000 Mbit)
 #
-# CONFIG_ACENIC is not set
-# CONFIG_DL2K is not set
+CONFIG_ACENIC=m
+CONFIG_ACENIC_OMIT_TIGON_I=y
+CONFIG_NET_BROADCOM=m
+CONFIG_DL2K=m
+CONFIG_E1000=y
 # CONFIG_MYRI_SBUS is not set
 # CONFIG_NS83820 is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_SK98LIN is not set
-# CONFIG_FDDI is not set
+CONFIG_HAMACHI=m
+CONFIG_YELLOWFIN=m
+CONFIG_SK98LIN=m
+CONFIG_TIGON3=m
+CONFIG_FDDI=y
+CONFIG_DEFXX=m
+CONFIG_SKFP=m
 # CONFIG_HIPPI is not set
-# CONFIG_PLIP is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
+CONFIG_PLIP=m
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPPOE=m
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_SLIP_MODE_SLIP6=y
 
 #
 # Wireless LAN (non-hamradio)
 #
-# CONFIG_NET_RADIO is not set
+CONFIG_NET_RADIO=y
+CONFIG_STRIP=m
+CONFIG_WAVELAN=m
+# CONFIG_ARLAN is not set
+CONFIG_AIRONET4500=m
+CONFIG_AIRONET4500_NONCS=m
+# CONFIG_AIRONET4500_PNP is not set
+CONFIG_AIRONET4500_PCI=y
+# CONFIG_AIRONET4500_ISA is not set
+# CONFIG_AIRONET4500_I365 is not set
+CONFIG_AIRONET4500_PROC=m
+CONFIG_AIRO=m
+# CONFIG_HERMES is not set
+# CONFIG_PLX_HERMES is not set
+CONFIG_NET_WIRELESS=y
 
 #
 # Token Ring devices
 #
 # CONFIG_TR is not set
-# CONFIG_NET_FC is not set
+CONFIG_NET_FC=y
+CONFIG_IPHASE5526=m
 # CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 
 #
 # Wan interfaces
 #
-# CONFIG_WAN is not set
+CONFIG_WAN=y
+# CONFIG_HOSTESS_SV11 is not set
+# CONFIG_COSA is not set
+# CONFIG_COMX is not set
+# CONFIG_DSCC4 is not set
+CONFIG_FARSYNC=m
+# CONFIG_LANMEDIA is not set
+# CONFIG_SEALEVEL_4021 is not set
+# CONFIG_SYNCLINK_SYNCPPP is not set
+# CONFIG_HDLC is not set
+CONFIG_DLCI=m
+CONFIG_DLCI_COUNT=24
+CONFIG_DLCI_MAX=8
+CONFIG_SDLA=m
+# CONFIG_LAPBETHER is not set
+# CONFIG_X25_ASY is not set
 
 #
 # Amateur Radio support
@@ -420,7 +635,89 @@
 #
 # ISDN subsystem
 #
-# CONFIG_ISDN is not set
+CONFIG_ISDN=m
+CONFIG_ISDN_PPP=y
+CONFIG_ISDN_PPP_VJ=y
+CONFIG_ISDN_MPP=y
+CONFIG_ISDN_PPP_BSDCOMP=m
+CONFIG_ISDN_AUDIO=y
+CONFIG_ISDN_TTY_FAX=y
+
+#
+# ISDN feature submodules
+#
+CONFIG_ISDN_DRV_LOOP=m
+# CONFIG_ISDN_DIVERSION is not set
+
+#
+# low-level hardware drivers
+#
+
+#
+# Passive ISDN cards
+#
+CONFIG_ISDN_DRV_HISAX=m
+
+#
+#   D-channel protocol features
+#
+CONFIG_HISAX_EURO=y
+CONFIG_DE_AOC=y
+# CONFIG_HISAX_NO_SENDCOMPLETE is not set
+# CONFIG_HISAX_NO_LLC is not set
+# CONFIG_HISAX_NO_KEYPAD is not set
+CONFIG_HISAX_1TR6=y
+CONFIG_HISAX_NI1=y
+CONFIG_HISAX_MAX_CARDS=8
+
+#
+#   HiSax supported cards
+#
+CONFIG_HISAX_16_0=y
+CONFIG_HISAX_16_3=y
+CONFIG_HISAX_TELESPCI=y
+CONFIG_HISAX_S0BOX=y
+CONFIG_HISAX_AVM_A1=y
+CONFIG_HISAX_FRITZPCI=y
+CONFIG_HISAX_AVM_A1_PCMCIA=y
+# CONFIG_HISAX_ELSA is not set
+CONFIG_HISAX_IX1MICROR2=y
+CONFIG_HISAX_DIEHLDIVA=y
+CONFIG_HISAX_ASUSCOM=y
+CONFIG_HISAX_TELEINT=y
+CONFIG_HISAX_HFCS=y
+# CONFIG_HISAX_SEDLBAUER is not set
+CONFIG_HISAX_SPORTSTER=y
+CONFIG_HISAX_MIC=y
+CONFIG_HISAX_NETJET=y
+CONFIG_HISAX_NETJET_U=y
+CONFIG_HISAX_NICCY=y
+CONFIG_HISAX_ISURF=y
+CONFIG_HISAX_HSTSAPHIR=y
+CONFIG_HISAX_BKM_A4T=y
+CONFIG_HISAX_SCT_QUADRO=y
+CONFIG_HISAX_GAZEL=y
+CONFIG_HISAX_HFC_PCI=y
+CONFIG_HISAX_W6692=y
+CONFIG_HISAX_HFC_SX=y
+CONFIG_HISAX_DEBUG=y
+# CONFIG_HISAX_SEDLBAUER_CS is not set
+# CONFIG_HISAX_ELSA_CS is not set
+# CONFIG_HISAX_ST5481 is not set
+# CONFIG_HISAX_FRITZ_PCIPNP is not set
+
+#
+# Active ISDN cards
+#
+CONFIG_ISDN_DRV_ICN=m
+CONFIG_ISDN_DRV_PCBIT=m
+# CONFIG_ISDN_DRV_SC is not set
+# CONFIG_ISDN_DRV_ACT2000 is not set
+# CONFIG_ISDN_DRV_EICON is not set
+CONFIG_ISDN_DRV_TPAM=m
+# CONFIG_ISDN_CAPI is not set
+CONFIG_HYSDN=m
+# CONFIG_HYSDN_CAPI is not set
 
 #
 # CD-ROM drivers (not for SCSI or IDE/ATAPI drives)
@@ -435,8 +732,8 @@
 CONFIG_INPUT_MOUSEDEV=y
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=m
 
 #
 # Character devices
@@ -445,16 +742,32 @@
 CONFIG_VT_CONSOLE=y
 CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
-# CONFIG_SERIAL_ACPI is not set
-# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_HCDP=y
+CONFIG_SERIAL_ACPI=y
+CONFIG_SERIAL_EXTENDED=y
+CONFIG_SERIAL_MANY_PORTS=y
+CONFIG_SERIAL_SHARE_IRQ=y
+# CONFIG_SERIAL_DETECT_IRQ is not set
+CONFIG_SERIAL_MULTIPORT=y
+# CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
+CONFIG_PRINTER=m
+# CONFIG_LP_CONSOLE is not set
+# CONFIG_PPDEV is not set
 
 #
 # I2C support
 #
-# CONFIG_I2C is not set
+CONFIG_I2C=m
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_PHILIPSPAR is not set
+# CONFIG_I2C_ELV is not set
+# CONFIG_I2C_VELLEMAN is not set
+# CONFIG_I2C_ALGOPCF is not set
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_PROC=m
 
 #
 # Mice
@@ -468,14 +781,14 @@
 #
 # Joysticks
 #
-# CONFIG_INPUT_GAMEPORT is not set
+CONFIG_INPUT_GAMEPORT=m
 # CONFIG_INPUT_NS558 is not set
-# CONFIG_INPUT_LIGHTNING is not set
-# CONFIG_INPUT_PCIGAME is not set
-# CONFIG_INPUT_CS461X is not set
-# CONFIG_INPUT_EMU10K1 is not set
-CONFIG_INPUT_SERIO=y
-CONFIG_INPUT_SERPORT=y
+CONFIG_INPUT_LIGHTNING=m
+CONFIG_INPUT_PCIGAME=m
+CONFIG_INPUT_CS461X=m
+CONFIG_INPUT_EMU10K1=m
+CONFIG_INPUT_SERIO=m
+# CONFIG_INPUT_SERPORT is not set
 
 #
 # Joysticks
@@ -518,8 +831,9 @@
 #
 # CONFIG_FTAPE is not set
 CONFIG_AGP=y
-# CONFIG_AGP_INTEL is not set
+CONFIG_AGP_INTEL=y
 CONFIG_AGP_I460=y
+CONFIG_AGP_HP_ZX1=y
 # CONFIG_AGP_I810 is not set
 # CONFIG_AGP_VIA is not set
 # CONFIG_AGP_AMD is not set
@@ -527,35 +841,45 @@
 # CONFIG_AGP_ALI is not set
 # CONFIG_AGP_SWORKS is not set
 CONFIG_DRM=y
-# CONFIG_DRM_NEW is not set
-CONFIG_DRM_OLD=y
-CONFIG_DRM40_TDFX=y
-# CONFIG_DRM40_GAMMA is not set
-# CONFIG_DRM40_R128 is not set
-# CONFIG_DRM40_RADEON is not set
-# CONFIG_DRM40_I810 is not set
-# CONFIG_DRM40_MGA is not set
+# CONFIG_DRM_OLD is not set
+
+#
+# DRM 4.1 drivers
+#
+CONFIG_DRM_NEW=y
+# CONFIG_DRM_TDFX is not set
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+# CONFIG_DRM_I810 is not set
+CONFIG_DRM_MGA=m
+# CONFIG_DRM_SIS is not set
 
 #
 # Multimedia devices
 #
-CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_DEV=m
 
 #
 # Video For Linux
 #
 CONFIG_VIDEO_PROC_FS=y
-# CONFIG_I2C_PARPORT is not set
+CONFIG_I2C_PARPORT=m
 
 #
 # Video Adapters
 #
+CONFIG_VIDEO_BT848=m
 # CONFIG_VIDEO_PMS is not set
-# CONFIG_VIDEO_CPIA is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_TUNER_3036 is not set
-# CONFIG_VIDEO_STRADIS is not set
-# CONFIG_VIDEO_ZORAN is not set
+CONFIG_VIDEO_BWQCAM=m
+CONFIG_VIDEO_CQCAM=m
+CONFIG_VIDEO_W9966=m
+CONFIG_VIDEO_CPIA=m
+# CONFIG_VIDEO_CPIA_PP is not set
+CONFIG_VIDEO_CPIA_USB=m
+CONFIG_VIDEO_SAA5249=m
+CONFIG_TUNER_3036=m
+CONFIG_VIDEO_STRADIS=m
+CONFIG_VIDEO_ZORAN=m
 # CONFIG_VIDEO_ZORAN_BUZ is not set
 # CONFIG_VIDEO_ZORAN_DC10 is not set
 # CONFIG_VIDEO_ZORAN_LML33 is not set
@@ -565,28 +889,29 @@
 #
 # Radio Adapters
 #
-# CONFIG_RADIO_CADET is not set
-# CONFIG_RADIO_RTRACK is not set
-# CONFIG_RADIO_RTRACK2 is not set
-# CONFIG_RADIO_AZTECH is not set
-# CONFIG_RADIO_GEMTEK is not set
-# CONFIG_RADIO_GEMTEK_PCI is not set
-# CONFIG_RADIO_MAXIRADIO is not set
-# CONFIG_RADIO_MAESTRO is not set
+CONFIG_RADIO_CADET=m
+CONFIG_RADIO_RTRACK=m
+CONFIG_RADIO_RTRACK2=m
+CONFIG_RADIO_AZTECH=m
+CONFIG_RADIO_GEMTEK=m
+CONFIG_RADIO_GEMTEK_PCI=m
+CONFIG_RADIO_MAXIRADIO=m
+CONFIG_RADIO_MAESTRO=m
 # CONFIG_RADIO_MIROPCM20 is not set
 # CONFIG_RADIO_MIROPCM20_RDS is not set
-# CONFIG_RADIO_SF16FMI is not set
-# CONFIG_RADIO_TERRATEC is not set
-# CONFIG_RADIO_TRUST is not set
-# CONFIG_RADIO_TYPHOON is not set
-# CONFIG_RADIO_ZOLTRIX is not set
+CONFIG_RADIO_SF16FMI=m
+CONFIG_RADIO_TERRATEC=m
+CONFIG_RADIO_TRUST=m
+CONFIG_RADIO_TYPHOON=m
+CONFIG_RADIO_TYPHOON_PROC_FS=y
+CONFIG_RADIO_ZOLTRIX=m
 
 #
 # File systems
 #
 # CONFIG_QUOTA is not set
 CONFIG_AUTOFS_FS=y
-# CONFIG_AUTOFS4_FS is not set
+CONFIG_AUTOFS4_FS=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
@@ -595,9 +920,9 @@
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
 # CONFIG_BFS_FS is not set
-CONFIG_EXT3_FS=m
-CONFIG_JBD=m
-CONFIG_JBD_DEBUG=y
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
 CONFIG_FAT_FS=y
 CONFIG_MSDOS_FS=y
 # CONFIG_UMSDOS_FS is not set
@@ -605,13 +930,13 @@
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
 # CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 # CONFIG_TMPFS is not set
-# CONFIG_RAMFS is not set
+CONFIG_RAMFS=m
 CONFIG_ISO9660_FS=y
-# CONFIG_JOLIET is not set
+CONFIG_JOLIET=y
 # CONFIG_ZISOFS is not set
-# CONFIG_MINIX_FS is not set
+CONFIG_MINIX_FS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_NTFS_FS is not set
 # CONFIG_NTFS_RW is not set
@@ -626,9 +951,9 @@
 # CONFIG_ROMFS_FS is not set
 CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_UDF_FS=m
 # CONFIG_UDF_RW is not set
-# CONFIG_UFS_FS is not set
+CONFIG_UFS_FS=m
 # CONFIG_UFS_FS_WRITE is not set
 
 #
@@ -644,7 +969,9 @@
 CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_SMB_FS is not set
+CONFIG_SMB_FS=m
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="cp437"
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
 # CONFIG_NCPFS_IOCTL_LOCKING is not set
@@ -655,7 +982,7 @@
 # CONFIG_NCPFS_NLS is not set
 # CONFIG_NCPFS_EXTRAS is not set
 # CONFIG_ZISOFS_FS is not set
-# CONFIG_ZLIB_FS_INFLATE is not set
+CONFIG_ZLIB_FS_INFLATE=m
 
 #
 # Partition Types
@@ -671,54 +998,55 @@
 # CONFIG_MINIX_SUBPARTITION is not set
 # CONFIG_SOLARIS_X86_PARTITION is not set
 # CONFIG_UNIXWARE_DISKLABEL is not set
-CONFIG_EFI_PARTITION=y
 # CONFIG_LDM_PARTITION is not set
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
-# CONFIG_SMB_NLS is not set
+CONFIG_EFI_PARTITION=y
+CONFIG_SMB_NLS=y
 CONFIG_NLS=y
 
 #
 # Native Language Support
 #
 CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+# CONFIG_NLS_CODEPAGE_1250 is not set
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
 
 #
 # Console drivers
@@ -728,33 +1056,66 @@
 #
 # Frame-buffer support
 #
-# CONFIG_FB is not set
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FB_RIVA=y
+# CONFIG_FB_CLGEN is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+CONFIG_FB_MATROX=y
+CONFIG_FB_MATROX_MILLENIUM=y
+# CONFIG_FB_MATROX_MYSTIQUE is not set
+CONFIG_FB_MATROX_G100=y
+CONFIG_FB_MATROX_I2C=m
+CONFIG_FB_MATROX_MAVEN=m
+CONFIG_FB_MATROX_G450=m
+CONFIG_FB_MATROX_MULTIHEAD=y
+CONFIG_FB_ATY=m
+# CONFIG_FB_ATY_GX is not set
+# CONFIG_FB_ATY_CT is not set
+# CONFIG_FB_RADEON is not set
+CONFIG_FB_ATY128=y
+# CONFIG_FB_SIS is not set
+CONFIG_FB_3DFX=m
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FBCON_ADVANCED is not set
+CONFIG_FBCON_CFB8=y
+CONFIG_FBCON_CFB16=y
+CONFIG_FBCON_CFB24=y
+CONFIG_FBCON_CFB32=y
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+# CONFIG_FBCON_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_PCI_CONSOLE=y
 
 #
 # Sound
 #
 CONFIG_SOUND=y
-# CONFIG_SOUND_BT878 is not set
+CONFIG_SOUND_BT878=m
 # CONFIG_SOUND_CMPCI is not set
 # CONFIG_SOUND_EMU10K1 is not set
 # CONFIG_MIDI_EMU10K1 is not set
-# CONFIG_SOUND_FUSION is not set
-CONFIG_SOUND_CS4281=y
+CONFIG_SOUND_FUSION=m
+CONFIG_SOUND_CS4281=m
 # CONFIG_SOUND_ES1370 is not set
 # CONFIG_SOUND_ES1371 is not set
 # CONFIG_SOUND_ESSSOLO1 is not set
-# CONFIG_SOUND_MAESTRO is not set
-# CONFIG_SOUND_MAESTRO3 is not set
-# CONFIG_SOUND_ICH is not set
-# CONFIG_SOUND_RME96XX is not set
-# CONFIG_SOUND_SONICVIBES is not set
-# CONFIG_SOUND_TRIDENT is not set
+CONFIG_SOUND_MAESTRO=m
+CONFIG_SOUND_MAESTRO3=m
+CONFIG_SOUND_ICH=m
+CONFIG_SOUND_RME96XX=m
+CONFIG_SOUND_SONICVIBES=m
+CONFIG_SOUND_TRIDENT=m
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_MIDI_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
-# CONFIG_SOUND_TVMIXER is not set
+CONFIG_SOUND_TVMIXER=m
 
 #
 # USB support
@@ -766,108 +1127,109 @@
 # Miscellaneous USB options
 #
 CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_BANDWIDTH is not set
+CONFIG_USB_BANDWIDTH=y
 # CONFIG_USB_LONG_TIMEOUT is not set
 
 #
 # USB Controllers
 #
-CONFIG_USB_UHCI=m
-# CONFIG_USB_UHCI_ALT is not set
-# CONFIG_USB_OHCI is not set
+CONFIG_USB_UHCI_ALT=y
+CONFIG_USB_OHCI=y
 
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_AUDIO is not set
-# CONFIG_USB_BLUETOOTH is not set
-# CONFIG_USB_STORAGE is not set
+CONFIG_USB_AUDIO=m
+CONFIG_USB_BLUETOOTH=m
+CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
 # CONFIG_USB_STORAGE_DATAFAB is not set
 # CONFIG_USB_STORAGE_FREECOM is not set
 # CONFIG_USB_STORAGE_ISD200 is not set
 # CONFIG_USB_STORAGE_DPCM is not set
-# CONFIG_USB_STORAGE_HP8200e is not set
+CONFIG_USB_STORAGE_HP8200e=y
 # CONFIG_USB_STORAGE_SDDR09 is not set
 # CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
 
 #
 # USB Human Interface Devices (HID)
 #
-CONFIG_USB_HID=m
-CONFIG_USB_HIDDEV=y
-CONFIG_USB_KBD=m
-CONFIG_USB_MOUSE=m
-# CONFIG_USB_WACOM is not set
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_WACOM=m
 
 #
 # USB Imaging devices
 #
-# CONFIG_USB_DC2XX is not set
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_SCANNER is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_HPUSBSCSI is not set
+CONFIG_USB_DC2XX=m
+CONFIG_USB_MDC800=m
+CONFIG_USB_SCANNER=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_HPUSBSCSI=m
 
 #
 # USB Multimedia devices
 #
-# CONFIG_USB_IBMCAM is not set
-# CONFIG_USB_OV511 is not set
-# CONFIG_USB_PWC is not set
-# CONFIG_USB_SE401 is not set
-# CONFIG_USB_DSBR is not set
-# CONFIG_USB_DABUSB is not set
+CONFIG_USB_IBMCAM=m
+CONFIG_USB_OV511=m
+CONFIG_USB_PWC=m
+CONFIG_USB_SE401=m
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_VICAM is not set
+CONFIG_USB_DSBR=m
+CONFIG_USB_DABUSB=m
 
 #
 # USB Network adaptors
 #
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_CDCETHER is not set
-# CONFIG_USB_USBNET is not set
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_CATC=m
+CONFIG_USB_CDCETHER=m
+CONFIG_USB_USBNET=m
 
 #
 # USB port drivers
 #
-# CONFIG_USB_USS720 is not set
+CONFIG_USB_USS720=m
 
 #
 # USB Serial Converter support
 #
-# CONFIG_USB_SERIAL is not set
-# CONFIG_USB_SERIAL_GENERIC is not set
-# CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_WHITEHEAT is not set
-# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
-# CONFIG_USB_SERIAL_VISOR is not set
-# CONFIG_USB_SERIAL_IR is not set
-# CONFIG_USB_SERIAL_EDGEPORT is not set
-# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
-# CONFIG_USB_SERIAL_KEYSPAN is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28 is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28X is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA19 is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA18X is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA19W is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA49W is not set
-# CONFIG_USB_SERIAL_MCT_U232 is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
-# CONFIG_USB_SERIAL_CYBERJACK is not set
-# CONFIG_USB_SERIAL_XIRCOM is not set
-# CONFIG_USB_SERIAL_OMNINET is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_VISOR=m
+# CONFIG_USB_SERIAL_IPAQ is not set
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_MCT_U232=m
+# CONFIG_USB_SERIAL_KLSI is not set
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OMNINET=m
 
 #
 # USB Miscellaneous drivers
 #
-# CONFIG_USB_RIO500 is not set
+CONFIG_USB_RIO500=m
 
 #
 # Bluetooth support
@@ -875,16 +1237,15 @@
 # CONFIG_BLUEZ is not set
 
 #
+# Simulated drivers
+#
+# CONFIG_SIMETH is not set
+# CONFIG_SIM_SERIAL is not set
+# CONFIG_SCSI_SIM is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_IA64_GRANULE_16MB is not set
 CONFIG_IA64_GRANULE_64MB=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_IA64_PRINT_HAZARDS=y
-# CONFIG_DISABLE_VHPT is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_IA64_EARLY_PRINTK=y
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_IA64_DEBUG_CMPXCHG is not set
-# CONFIG_IA64_DEBUG_IRQ is not set
+# CONFIG_DEBUG_KERNEL is not set
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/Makefile linux/arch/ia64/hp/Makefile
--- ../prev/linux/arch/ia64/hp/Makefile	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/hp/Makefile	Thu Jul  4 08:02:44 2002
@@ -1,13 +1,14 @@
 # arch/ia64/hp/Makefile
 # Copyright (c) 2002 Matthew Wilcox for Hewlett Packard
 
-ALL_SUB_DIRS := sim zx1 common
+ALL_SUB_DIRS := sim zx1 common bmc
 
 O_TARGET := hp.o
 
 subdir-$(CONFIG_IA64_GENERIC) += $(ALL_SUB_DIRS)
 subdir-$(CONFIG_IA64_HP_SIM) += sim
 subdir-$(CONFIG_IA64_HP_ZX1) += zx1 common
+subdir-$(CONFIG_IA64_HP_BMC) += bmc
 
 SUB_DIRS := $(subdir-y)
 obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/Makefile linux/arch/ia64/hp/bmc/Makefile
--- ../prev/linux/arch/ia64/hp/bmc/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/Makefile	Thu Jul  4 08:02:44 2002
@@ -0,0 +1,10 @@
+# Makefile for BMC
+
+#CFLAGS += -DDEBUG -DEXPORT_SYMTAB
+
+#CFLAGS += -DPANIC_EVENT
+
+obj-y := bmcmain.o bmc2.o imb.o bmc_discovery.o
+O_TARGET := bmc.o
+
+include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/bmc.h linux/arch/ia64/hp/bmc/bmc.h
--- ../prev/linux/arch/ia64/hp/bmc/bmc.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/bmc.h	Thu Jul  4 08:02:44 2002
@@ -0,0 +1,73 @@
+/****************************************************************************
+*
+* Copyright 2002 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 10955 Tantau Av
+* Cupertino, CA 95014 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+//////////////////////////////////////////////////////////////////////
+//
+// BMC.h: functions to access BMC
+//
+// Note: BMC stands for Baseboard Management Controller.  Hence BMC code
+//       deals with talking to the hardware controller.
+//
+// History:
+//     Jan 2002: Initial creation by Xiaojie Dong
+//
+//////////////////////////////////////////////////////////////////////
+
+#include "constant.h"
+
+#define MIN_BMC_REQUEST_SIZE    2
+#define MAX_BMC_BUFFER_SIZE     68	//68 for Zirconlite
+#define MIN_BMC_RESPONSE_SIZE   3	//nfLn, cmd, cCode
+
+#define BMC_SA                  0x20    // BMC slave address
+#define BMC_LUN                 0       // BMC only responds to this LUN
+#define CCODE_UNKNOWN		0xff
+#define NETFN_OF(x)		(((x)>>2) & 0x3f)	// extract netFn from nfLn
+
+//
+// Values to pass to DelayRetryFunc()
+//
+#define KCS_READY_DELAY		(WAIT_1_MS)
+#define BMC_RESPONSE_DELAY	WAIT_10_MS       // how long to wait for a response after sending req
+#define FORCE_DELAY		0xFFFFFFFF       // if retryCount has this value, force a delay
+#define BMC_RETRY_DELAY		(60 * WAIT_1_MS) // how long to wait after an error before retrying
+
+
+typedef struct {
+	BYTE    nfLn;
+	BYTE    cmd;
+	BYTE    data[1]; // placeholder for array of bytes
+} BmcRequest;
+
+typedef struct {
+	BYTE    nfLn;
+	BYTE    cmd;
+	BYTE    cCode;
+	BYTE    data[1]; // placeholder for array of bytes
+} BmcResponse;
+
+
+
+///////////////////////////////////
+//Function Prototypes
+///////////////////////////////////
+
+unsigned long ExecuteBmcCommand( BmcRequest *request, DWORD request_length, BmcResponse *response, 
+	DWORD max_response_length, DWORD *returned_length, DWORD time_out );
+
+extern PUCHAR kcsBaseAddr;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/bmc2.c linux/arch/ia64/hp/bmc/bmc2.c
--- ../prev/linux/arch/ia64/hp/bmc/bmc2.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/bmc2.c	Fri Jul  5 14:32:55 2002
@@ -0,0 +1,747 @@
+/****************************************************************************
+*
+* Copyright 2002 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 10955 Tantau Av
+* Cupertino, CA 95014 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+
+//////////////////////////////////////////////////////////////////////
+//
+// BMC.c: implementation of the functions to access BMC.
+//
+// Note: BMC stands for Baseboard Management Controller.  Hence BMC code
+//       deals with talking to the hardware controller.
+//
+// History:
+//     Jan 2002: Initial creation by Xiaojie Dong
+//
+//////////////////////////////////////////////////////////////////////
+
+//
+// Keyboard Controller Style Interface addresses and defines
+//
+
+// The BMC base address.  Defined by the IPMI spec v1.0 as the address of the
+// motherboard baseboard controller.  Rather than use this constant, the
+// driver ought to enhanced to use the address in SMBIOS table 38 ("IPMI
+// Device Information").  However, the HPImb driver does not access the
+// SMBIOS tables.  The best way for this driver to get the BMC slave address
+// would be for the HPGate driver to pass down the address.  (Unfortunately,
+// the HPGate driver doesn't read the SMBIOS tables either, so it would have
+// to get the BMC slave address from Toptools itself).  I (Kent) suggest that
+// this enhancement be done only when a device comes along that doesn't use
+// 0xCA2 as the address.  This is unlikely inasmuch as the IPMI spec defines
+// 0x2CA2 as the default location of the Motherboard BMC controller.
+
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+
+#include "bmc.h"
+#include "imb_err.h"
+
+#define MAX_INVALID_RESPONSE_COUNT	1	// number of BMC request send retries.
+
+//
+// Status register bit flags (from spec)
+//
+#define KCS_STATE_MASK		0xc0
+#define KCS_IDLE_STATE		0x00
+#define KCS_READ_STATE		0x40
+#define KCS_WRITE_STATE		0x80
+#define KCS_ERROR_STATE		0xc0
+
+#define KCS_IBF			0x02
+#define KCS_OBF			0x01
+
+//
+// KCS commands (from spec)
+//
+#define WRITE_START		0x61
+#define WRITE_END		0x62
+#define READ			0x68
+
+//
+// State machine states
+//
+#define TRANSFER_INIT		1  // initialize 
+#define TRANSFER_START		2  // start the writing phase of the request
+#define TRANSFER_NEXT		3  // send the next byte of a request
+#define TRANSFER_END		4  // send last byte of request
+#define RECEIVE_START		5  // wait for BMC to transition to read state
+#define RECEIVE_INIT		6  // wait for first data byte to become available
+#define RECEIVE_NEXT		7  // collect data byte and ask for more
+#define RECEIVE_INIT2		8  // wait for next data byte to become available
+#define RECEIVE_END		9  // terminate the reading operation
+#define MACHINE_END		10 // quit and return to the user.
+#define TRANSFER_ERROR		0
+
+
+//#define KdPrint( a ) printk a
+#define KdPrint( a )
+
+//
+//Static functions
+//
+static void WriteKcsCmd( BYTE cmd );
+static void WriteKcsData( BYTE data );
+static BYTE ReadKcsData();
+static BYTE GetKcsState();
+static int WaitOnIBF();
+static int OBFset();
+static int ClearOBF();
+static int WaitOnOBF();
+static void DelayRetryFunc ( DWORD retryCount, DWORD delayTime );
+
+
+//
+//Static variables
+//
+PUCHAR kcsBaseAddr;
+static PUCHAR kcsCommandReg;
+static PUCHAR kcsStatusReg;
+static PUCHAR kcsDatainReg;
+static PUCHAR kcsDataoutReg;
+
+
+//
+//Functions
+//
+
+
+static unsigned long g_timeout;
+
+void SetTimeout( unsigned long microseconds )
+{
+	g_timeout = jiffies +  (microseconds * HZ) / 1000000;
+}
+
+
+int IsTimeout()
+{
+	if ( jiffies > g_timeout )
+		return TRUE;
+	else
+		return FALSE;
+}
+
+/////////////////////////////////////////////////////////////////////
+//  ExecuteBmcCommand
+// 
+//	Routine Description:
+//		Low level routine for executing any IPMI command.  Communicates
+//		directly with the Baseboard Management Controller.
+//
+//	Parameters:
+//      request: the input buffer.  Contains "raw" data for writing to the
+//				 BMC
+//		request_length: amount of data in request to send.
+//		response: the output buffer.  "Raw" data from the BMC is put here.
+//		max_response_length: the max number of bytes that can be written
+//				to response.
+//		returned_length: the actual number of bytes written to response.
+//		time_out: The number of microseconds before timing out when writing to
+//				the BMC.
+//
+//		Note: any error checking on these values is presumed to be done by the
+//			  calling program.
+//
+//	Return Value:
+//		NTSTATUS - Return STATUS_SUCCESS if no errors are encountered.
+//			Any other indicates to the system that an error has occured.
+//
+//  Algorithm:
+//		Refer to figures 8-2 and 8-3 of the IPMI Specification v1.0 (Document
+//		revision 1.1, datd November 15, 1999).  Some tweaks were made to these
+//		figures in the " IPMI Addenda, Errata and Clarifications" revision 3
+//		dated June 6, 2000.
+//
+
+
+unsigned long ExecuteBmcCommand( BmcRequest *request, DWORD request_length, BmcResponse *response,
+	DWORD max_response_length, DWORD *returned_length, DWORD time_out )
+								   
+{
+	BYTE invalidRespCount = 0;
+	unsigned long status;
+	BYTE *transmitBuf = (BYTE *) request;
+	BYTE *receiveBuf = (BYTE *) response;
+	int machineState = TRANSFER_INIT;
+	DWORD request_ctr=0, receive_ctr=0;
+
+	kcsStatusReg  = kcsBaseAddr + 1;
+	kcsCommandReg = kcsBaseAddr + 1;
+	kcsDataoutReg = kcsBaseAddr;
+	kcsDatainReg  = kcsBaseAddr;
+
+	status = STATUS_SUCCESS;
+	response->cCode = CCODE_UNKNOWN;
+	
+	SetTimeout( time_out );
+	
+	KdPrint(("Start state machine \n"));
+
+	while( TRUE ) { // look for breaks for way out of this infinite loop.  No returns are allowed.
+		//
+		// check for timeout
+		//
+		if ( IsTimeout()) {
+			//
+			// determine the cause
+			//
+			printk( KERN_ERR "bmcdev : bmc timeout\n" );
+
+			if ( status == STATUS_SUCCESS ) {
+
+				if ( machineState > TRANSFER_END )
+					status = IMB_IF_RECEIVE_TIMEOUT;
+				else
+					status = IMB_IF_SEND_TIMEOUT;
+			}                       
+			break;
+		}
+		//
+		// check for successful termination
+		//
+		if ( machineState == MACHINE_END ) {
+			status = STATUS_SUCCESS;
+			KdPrint(("In MACHINE_END\n"));
+			break; // one of two ways out of while(1).
+		}
+		//
+		// check for too many bad responses
+		//
+		else if ( invalidRespCount > MAX_INVALID_RESPONSE_COUNT ) {
+			// The code that increments invalidRespCount may or may not have
+			// changed variable status.  So, if it didn't change it from SUCCESS,
+			// we do it here.  This fixes a quirk in the Intel Sample driver.
+			if( status == STATUS_SUCCESS )
+				status = IMB_INVALID_IF_RESPONSE;
+			KdPrint(("Too many bad responses!\n"));
+			break; // the other of two ways out of while(1).
+		}
+
+		switch (machineState) {
+
+		case  TRANSFER_INIT:
+			KdPrint(("Entering TRANSFER_INIT!\n"));
+			
+			request_ctr = 0;
+			machineState = TRANSFER_START;
+
+			//KdBreakPoint();
+
+			(void) WaitOnIBF();
+
+			if ( ClearOBF() != TRUE) {
+				machineState = TRANSFER_ERROR;
+				break;
+			}
+	
+			//
+			// fall through
+			//
+			
+		case  TRANSFER_START:
+			KdPrint(("Enterring TRANSFER_START! Ready to write WRITE_START\n\n"));
+			
+			machineState = TRANSFER_NEXT;
+
+			//KdBreakPoint();
+
+			//to avoid machine check
+			writeb(WRITE_START, kcsCommandReg);
+			(void) WaitOnIBF();
+
+			KdPrint(("TRANSFER_START: after WaitonIBF\n"));
+
+			//KdBreakPoint();
+			
+			if( GetKcsState() != KCS_WRITE_STATE ) {
+				machineState = TRANSFER_ERROR;
+				break;
+			}
+			
+			KdPrint(("TRANSFER_START: after GetKcsState\n"));
+
+			//KdBreakPoint();
+
+			if ( ClearOBF() != TRUE) {
+				machineState = TRANSFER_ERROR;
+				break;
+			}
+			KdPrint(("TRANSFER_START: after ClearOBF\n"));
+
+			//KdBreakPoint();
+
+			//
+			// fall through, again
+			//
+		case  TRANSFER_NEXT:
+			KdPrint(("Enterring TRANSFER_NEXT!\n\n"));
+			//
+			// check for end of request, transition to the END state which will transfer
+			// our last byte
+			//
+			if ( request_ctr == (request_length - 1) ) {
+				machineState = TRANSFER_END ;
+				break;
+			}
+
+			// Following was commented out in Intel IPMI driver.  We keep it commented
+			// out even though the flowchart in the IPMI spec has it in it.
+			/*
+				if( GetKcsState() != KCS_WRITE_STATE ) {
+					machineState = TRANSFER_ERROR;
+					break;
+				}
+			*/
+			WriteKcsData( transmitBuf[request_ctr++] );
+			KdPrint(("*** Sent data : %X ***\n", transmitBuf[request_ctr-1]));
+
+			
+			(void) WaitOnIBF();
+
+/*
+			if( GetKcsState() != KCS_WRITE_STATE ) {
+				machineState = TRANSFER_ERROR;
+				break;
+
+			}
+*/
+			if ( ClearOBF() != TRUE) {
+				machineState = TRANSFER_ERROR;
+				break;
+			}
+
+			break;
+
+		case  TRANSFER_END:
+			KdPrint(("Enterring TRANSFER_END!\n\n"));
+			
+			//
+			// Transfer the last byte of the request and
+			// transition to Reading.
+			//
+
+			// Following was commented out in Intel reference driver.
+			/*
+				WaitOnIBF( context );
+				if ( ClearObf(context) != TRUE) {
+					machineState = TRANSFER_ERROR;
+					break;
+				}
+			*/
+
+			WriteKcsCmd( WRITE_END );
+
+			WaitOnIBF();
+
+			if( GetKcsState() != KCS_WRITE_STATE ) {
+				machineState = TRANSFER_ERROR;
+				break;
+			} 
+
+			if ( ClearOBF() != TRUE) {
+				machineState = TRANSFER_ERROR;
+				break;
+			}
+
+			KdPrint(("Write next byte\n"));
+			WriteKcsData( transmitBuf[request_ctr++] );
+			KdPrint(("*** Sent data : %X  ***\n", transmitBuf[request_ctr-1]));			
+
+			 WaitOnIBF();
+
+    			machineState = RECEIVE_START;
+			//
+			// fall through
+			//
+
+		case  RECEIVE_START:
+			KdPrint(("Enterring RECEIVE_START!\n\n"));
+			
+			//
+			// end of request, now transition to receiving the response
+			//
+			switch( GetKcsState() ) {
+
+				case KCS_ERROR_STATE:
+					machineState = TRANSFER_ERROR;
+					break;
+
+				case KCS_WRITE_STATE:
+				case KCS_IDLE_STATE:
+					//
+					// not ready with our response, hang out for a bit
+					//
+					DelayRetryFunc( FORCE_DELAY, BMC_RESPONSE_DELAY );
+					break;
+
+				case KCS_READ_STATE:
+					//
+					// ready with our response, setup to receive
+					//
+					receive_ctr = 0; 
+					//RtlZeroMemory( receiveBuf, max_response_length );
+					machineState = RECEIVE_INIT;
+					break;
+			}
+			break;
+
+		case  RECEIVE_INIT:
+			KdPrint(("Enterring RECEIVE_INIT!\n\n"));
+			
+			//
+			// wait for a data byte to come available
+			//
+			switch( GetKcsState() ) {
+
+				case KCS_ERROR_STATE:
+				case KCS_WRITE_STATE:
+					machineState = TRANSFER_ERROR;
+					break;
+
+				case KCS_IDLE_STATE:
+					//
+					// BMC is done sending data
+					//
+					machineState = RECEIVE_END;
+					break;
+
+				case KCS_READ_STATE:
+					// The following was rewritten from the IPMI reference driver to
+					// match the flowchart in figure 8-3 of IPMI Addenda, Errata and
+					// Clarifications
+					if( WaitOnOBF() == TRUE )
+						machineState = RECEIVE_NEXT;
+					else
+						machineState = TRANSFER_ERROR;
+					break;
+
+				default:
+					DelayRetryFunc( FORCE_DELAY, WAIT_1_MS );
+			}
+			break;
+
+		case  RECEIVE_NEXT:
+			KdPrint(("Enterring RECEIVE_NEXT!\n\n"));
+			
+			//
+			// Read the next data byte from the BMC
+			//
+
+			// check for overrun
+			if (  receive_ctr >= max_response_length ) {
+				status		= IMB_RESPONSE_DATA_OVERFLOW;
+				machineState	= TRANSFER_ERROR;
+				break;
+			}
+
+			//
+			// get the data from the BMC
+			//
+			receiveBuf[receive_ctr++] = ReadKcsData();
+			
+			KdPrint(("*** The data returned is %x *** \n", receiveBuf[receive_ctr-1]));
+			
+			WriteKcsData( READ );
+
+			WaitOnIBF();
+
+			machineState = RECEIVE_INIT2;
+
+			break;
+
+		case  RECEIVE_INIT2:
+			KdPrint(("Enterring RECEIVE_INIT2!\n\n"));
+			
+			//
+			// wait for a data byte to come available
+			//
+			switch( GetKcsState() ) {
+
+				case KCS_ERROR_STATE:
+				case KCS_WRITE_STATE:
+					machineState = TRANSFER_ERROR;
+					break;
+
+				case KCS_IDLE_STATE:
+					//
+					// BMC is done sending data
+					//
+
+					if ( WaitOnOBF() == TRUE) {
+						ClearOBF();
+						machineState = RECEIVE_END;
+					}
+					else
+						machineState =  TRANSFER_ERROR;;
+
+					break;
+
+				case KCS_READ_STATE:
+
+					if ( WaitOnOBF() == TRUE)
+						machineState = RECEIVE_NEXT;
+					else
+						machineState =  TRANSFER_ERROR;;
+
+					// Following was commented out in Intel reference driver.
+					/*
+						if( OBFset() )
+   							machineState = RECEIVE_NEXT;
+					*/
+					break;
+			}
+			break;
+
+		case  RECEIVE_END:
+			KdPrint(("Enterring RECEIVE_END!\n\n"));
+			
+		   //
+		   // check for size, appropriate response netfun (which should be the original
+		   // netfun with last bit set), and command
+		   //
+		   if ( receive_ctr < MIN_BMC_RESPONSE_SIZE ||
+						NETFN_OF(response->nfLn) != (NETFN_OF(request->nfLn) | 1) ||
+						response->cmd != request->cmd ) {
+				//
+			    // bad response, wait for a while and try sending it again
+			    //
+				DelayRetryFunc( FORCE_DELAY, BMC_RETRY_DELAY );
+				machineState = TRANSFER_INIT;
+
+				++invalidRespCount; // We'll do MAX_INVALID_RESPONSE_COUNT before
+									// reporting failure.
+				break;
+			}
+			//
+		    // all done, return triumphant
+		    //
+			*returned_length	= receive_ctr;
+			machineState		= MACHINE_END;
+
+			break;
+
+		case  TRANSFER_ERROR:
+			KdPrint(("Enterring TRANSFER_ERROR!\n\n"));
+			
+		default:
+			//
+			// We've failed somehow, or maybe it was the BMC fault.
+			// Try again, as per comm spec. allow 60 ms. for controllers to recover
+			//
+			DelayRetryFunc( FORCE_DELAY, BMC_RETRY_DELAY );
+			receive_ctr = request_ctr = 0;
+			++invalidRespCount;
+			machineState = TRANSFER_INIT;
+			
+			if ( invalidRespCount <= MAX_INVALID_RESPONSE_COUNT )
+				printk( KERN_ERR "bmcdev : retrying command\n" );
+			
+			break;
+		} // switch
+
+	} // while(TRUE)
+	 
+	return status;
+}
+	
+
+
+//*****************************************************************************
+//* DelayRetryFunc(...)
+//*****************************************************************************
+//  Purpose:    This function inserts a delay into the execution of 
+//				current thread
+//  Parameters: 
+//    retryCount: A counter, incremented by the calling function, to be tested
+//				  against the constant 0x50.  Up until it reaches that value,
+//				  this function just does a return.  The net effect is that the
+//				  calling function together with this function, spins on the CPU.
+//    delayTime Delay interval to be used in uSec
+//*****************************************************************************
+void DelayRetryFunc( DWORD retryCount, DWORD delayTime )
+{
+	// The following value is the number of times the DelayRetryFunc() just returns
+	// instead of doing a real OS delay.  Intel chose this number in its sample driver.
+	//
+	const int NO_RETRY_DELAY_COUNT = 0x50;
+
+	if (retryCount < (DWORD)NO_RETRY_DELAY_COUNT && retryCount != FORCE_DELAY )
+		return ;
+
+//	udelay( delayTime );
+	set_current_state(TASK_INTERRUPTIBLE);	
+	schedule_timeout( (delayTime * HZ)/1000000 );
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// WaitOnIBF: Wait until the IBF bit of the STATUS REGISTER is set.
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Clears OBF flag if set
+/////////////
+int WaitOnIBF()
+{
+	DWORD retryCount = 0;
+	BYTE  status;
+
+	while( TRUE ) {
+	
+		status = readb(kcsStatusReg);	
+		if ( (status & KCS_IBF) == 0 ) {
+			KdPrint(("IBF cleared!\n"));
+			break;
+		}
+
+ 		DelayRetryFunc( retryCount++, KCS_READY_DELAY );
+		
+		if ( IsTimeout() ) 
+			return FALSE;
+	}
+	return TRUE;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// ClearOBF
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Clears OBF flag if set
+//  Returns:    TRUE if OBF flag gets cleared else FALSE
+////////////
+int ClearOBF()
+{
+#if 1
+	ReadKcsData();
+	return TRUE;
+#else // "ifdeffed-out" code follows
+
+	// The following logic was in the Intel Reference driver but commented out.  I've
+	// included it here in case the above simple read is not sufficient.  Note that
+	// logic is weak inasmuch as the retryCount never gets tested.
+	DWORD	retryCount = 0;
+
+	if( !OBFset() )
+		return TRUE;
+
+	ReadKcsData();
+
+	while( TRUE ) {
+
+		if( !OBFset() )
+			break;
+
+		DelayRetryFunc( retryCount++, KCS_READY_DELAY );
+
+		if (KeReadStateTimer(pTimer))
+			//if ( pTimer->Triggered() )
+			return FALSE;
+	}
+
+	return TRUE;
+#endif
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// WaitOnOBF
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Check to see if OutPut Buffer Full Flag is set
+//  Returns:    TRUE if OBF set,else if Timeout FALSE
+//  Paramenter: pTimer: pointer to timer that has been armed.
+/////////////
+int WaitOnOBF()
+{
+	DWORD retryCount = 0;
+
+	while( TRUE ) {
+		if( OBFset() )
+			break;
+
+		DelayRetryFunc( retryCount++, KCS_READY_DELAY );
+		
+		if ( IsTimeout() )
+			return FALSE;
+	}
+	return TRUE;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// OBFset
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Get the OBF bit in the KCS interface
+//  Returns:    TRUE if OBF set,else  FALSE
+/////////////
+int OBFset()
+{
+	BYTE status;
+
+	status = readb(kcsStatusReg);
+	return (status & KCS_OBF) == KCS_OBF;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// ReadKcsData
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Read the data port of the KCS interface
+/////////////
+BYTE ReadKcsData()
+{
+	BYTE data;
+	data = readb(kcsDataoutReg);
+	return data;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// GetKcsState
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Get the STATE bits of the STATUS flag
+//  Returns:    STATE bits
+/////////////
+BYTE GetKcsState()
+{
+	BYTE state;
+
+	state = readb(kcsStatusReg);
+	return state & KCS_STATE_MASK;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// WriteKcsData
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Write to the data port of the KCS interface
+/////////////
+void WriteKcsData(BYTE data)
+{
+	writeb(data, kcsDatainReg);
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+// WriteKcsCmd
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//  Purpose:    Write to the command port of the KCS interface
+/////////////
+void WriteKcsCmd(BYTE cmd)
+{
+	writeb(cmd, kcsCommandReg);
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/bmc_discovery.c linux/arch/ia64/hp/bmc/bmc_discovery.c
--- ../prev/linux/arch/ia64/hp/bmc/bmc_discovery.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/bmc_discovery.c	Fri Jul  5 14:37:54 2002
@@ -0,0 +1,62 @@
+/****************************************************************************
+*
+* Copyright 2001 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 10955 Tantau Av
+* Cupertino, CA 95014 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+#include <linux/acpi.h>
+
+struct SPMITable {
+	char		Signature[4];
+	unsigned int	Length;
+	unsigned char	Revision;
+	unsigned char	Checksum;
+	char		OEMID[6];
+	char		OEMTableID[8];
+	char		OEMRevision[4];
+	char		CreatorID[4];
+	char		CreatorRevision[4];
+	short		InterfaceType;
+	short		SpecificationRevision;
+	unsigned char	InterruptType;
+	unsigned char	GPE;
+	short		Reserved;
+	unsigned long	GlobalSystemInterrupt;
+	unsigned char	BaseAddress[12];
+	unsigned char	UID[4];
+} __attribute__ ((packed));
+
+unsigned long Get_BMC_Base_Address(void)
+{
+	acpi_status status;
+	acpi_table_header *spmi;
+	static unsigned long io_base = 0;
+
+	if (io_base != 0)
+		return io_base;
+
+	status = acpi_get_firmware_table("SPMI", 1,
+			ACPI_LOGICAL_ADDRESSING, &spmi);
+
+	if (status != AE_OK) {
+		printk(KERN_ERR "bmcdev : SPMI table not found.\n");
+		return 0;
+	}
+
+	memcpy(&io_base, ((struct SPMITable *)spmi)->BaseAddress,
+			sizeof(io_base));
+	
+	return io_base;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/bmc_discovery.h linux/arch/ia64/hp/bmc/bmc_discovery.h
--- ../prev/linux/arch/ia64/hp/bmc/bmc_discovery.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/bmc_discovery.h	Fri Jul  5 14:36:12 2002
@@ -0,0 +1,20 @@
+/****************************************************************************
+*
+* Copyright 2001 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 10955 Tantau Av
+* Cupertino, CA 95014 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+unsigned long Get_BMC_Base_Address(void);
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/bmcmain.c linux/arch/ia64/hp/bmc/bmcmain.c
--- ../prev/linux/arch/ia64/hp/bmc/bmcmain.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/bmcmain.c	Thu Jul  4 15:26:40 2002
@@ -0,0 +1,330 @@
+/****************************************************************************
+*
+* Copyright 2002 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 10955 Tantau Av
+* Cupertino, CA 95014 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+#include "imb.h"
+#include "bmc.h"
+#include "bmcmain.h"
+#include "bmc_discovery.h"
+#include "imb_err.h"
+
+static int bmcdev_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+static int bmcdev_open(struct inode *, struct file *);
+static int bmcdev_release(struct inode *, struct file *);
+int bmcdev_getmajor();
+
+static struct file_operations bmcdev_fops = {
+    ioctl:	bmcdev_ioctl,
+    open:	bmcdev_open,
+    release:	bmcdev_release,
+};
+
+static int bmcdev_major;
+static int bmcdev_count;
+static spinlock_t bmcdev_lock;
+
+static unsigned long LinuxBMCTunnelIMBCommand( void * arg );
+static int ReserveBMCMemory();
+static void ReleaseBMCMemory();
+
+MODULE_LICENSE("GPL");
+
+#ifdef PANIC_EVENT
+
+#include <linux/notifier.h>
+extern void DelayRetryFunc( DWORD retryCount, DWORD delayTime );
+static int WritePanicEvent(struct notifier_block *this, unsigned long command, void *ptr );
+static struct notifier_block panic_block = { WritePanicEvent, NULL, 0 };
+
+#endif
+
+
+//
+//Functions
+//
+
+static int __init bmc_init(void)
+{
+	int result = 0;
+
+	printk("BMC module initialising\n");
+
+	result = register_chrdev( bmcdev_major, "bmcdev", &bmcdev_fops );
+	if (result < 0)
+		return result;
+
+	if (bmcdev_major == 0)
+		bmcdev_major = result;
+
+	if ( ! ReserveBMCMemory() ) {
+		result = -EBUSY;
+		goto init_error;
+	}
+
+	spin_lock_init(&bmcdev_lock);
+	bmcdev_count = 0;
+	EXPORT_NO_SYMBOLS;
+	
+#ifdef PANIC_EVENT
+	//WritePanicEvent(NULL,0,NULL);
+	register_panic_notifier(&panic_block);
+#endif
+	return 0;
+	
+init_error:
+	unregister_chrdev( bmcdev_major, "bmcdev" );
+	return result;
+}
+
+
+int bmcdev_getmajor() { return bmcdev_major; }
+
+static void __exit bmc_exit(void)
+{
+	ReleaseBMCMemory();
+	
+	if (bmcdev_major)
+		unregister_chrdev( bmcdev_major, "bmcdev" );
+
+#ifdef PANIC_EVENT	
+	unregister_panic_notifier(&panic_block);
+#endif
+}
+
+
+int bmcdev_open(struct inode *inode, struct file *filp)
+{
+	spin_lock(&bmcdev_lock);
+  
+	if (bmcdev_count) {
+		spin_unlock(&bmcdev_lock);
+		return -EBUSY;
+	}
+
+	bmcdev_count++;
+	spin_unlock(&bmcdev_lock);	
+	
+	MOD_INC_USE_COUNT;
+	
+	return 0;
+}
+
+
+int bmcdev_release(struct inode *inode, struct file *filp)
+{
+	if (bmcdev_count) {
+		bmcdev_count--;
+		MOD_DEC_USE_COUNT;
+		return 0;
+	} else {
+		return -EBADF;
+	}
+}
+
+
+int bmcdev_ioctl(struct inode *inode, struct file *filp,
+                 unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case IOCTL_IMB_EXECUTE_COMMAND:
+		return LinuxBMCTunnelIMBCommand( (void *) arg );
+
+	default:
+		return -ENOTTY;
+	}
+
+	return 0;
+}
+
+
+
+unsigned long LinuxBMCTunnelIMBCommand( void * arg )
+{
+	SEND_RCV sr;
+
+#ifdef DEBUG
+	int f;
+#endif
+
+	/* first copy the structure from userspace */
+	if (copy_from_user(&sr, arg, sizeof(SEND_RCV)) != 0)
+		return -EFAULT;
+
+	/* allocate an area to copy the input buffer into */
+	if ((sr.input = kmalloc(sr.ilen, GFP_KERNEL)) == NULL)
+		return -EFAULT;
+	
+	/* now copy the input buffer from userspace */
+	if (copy_from_user( sr.input, ((PSEND_RCV)arg)->input, sr.ilen)) {
+		kfree(sr.input);
+		return -EFAULT;
+	}
+	
+	/* allocate an area to output buffer */
+	if ((sr.output = kmalloc(sr.olen, GFP_KERNEL)) == NULL) {
+		kfree(sr.input);
+		return -EFAULT;
+	}
+
+#ifdef DEBUG
+	printk( KERN_ERR "bmcdev req data  : " );
+	for ( f = 0; f < sr.ilen; f++ )
+		printk( "%x ", sr.input[f]);
+	printk( "\n" );
+#endif
+
+	IOCTL_IMB_EXECUTE_COMMAND_Handler( &sr );
+
+#ifdef DEBUG	
+	printk( KERN_ERR "bmcdev resp code : %x\n", sr.retcode );
+	printk( KERN_ERR "bmcdev resp data : " );
+	for ( f = 0; f < sr.olen; f++ )
+		printk( "%x ", sr.output[f]);
+	printk( "\n" );
+#endif
+	
+        /* copy to userspace the output buffer, its len and the retcode */
+	if (copy_to_user(&(((PSEND_RCV)arg)->olen), &sr.olen, sizeof(sr.olen)) ||
+	  copy_to_user(&(((PSEND_RCV)arg)->retcode), &sr.retcode, sizeof(sr.retcode)) ||
+	  copy_to_user(((PSEND_RCV)arg)->output, sr.output, sr.olen)) {
+		kfree(sr.input);
+		kfree(sr.output);
+		return -EFAULT;
+	}
+
+	kfree(sr.input);
+	kfree(sr.output);
+		
+	return 0;
+}
+
+
+
+int ReserveBMCMemory()
+{
+	const unsigned long BmcIoLength = 0x00000004;
+	unsigned long BmcIoBase;
+
+	BmcIoBase = Get_BMC_Base_Address();
+	if ( BmcIoBase == 0 ) {
+		printk(KERN_ERR "bmcdev : bmc address not found\n");
+		return FALSE;
+	}
+
+	if ( check_mem_region( BmcIoBase, BmcIoLength ) ) {
+		printk(KERN_ERR "bmcdev : check_mem_region() error\n");
+		return FALSE;
+	}
+	request_mem_region( BmcIoBase, BmcIoLength, "bmcdev" );
+	kcsBaseAddr = ioremap( BmcIoBase, BmcIoLength );
+	return TRUE;
+}
+
+
+void ReleaseBMCMemory()
+{
+	const unsigned long BmcIoLength = 0x00000004;
+	unsigned long BmcIoBase;
+	
+	BmcIoBase = Get_BMC_Base_Address();
+	
+	release_mem_region( BmcIoBase, BmcIoLength );
+}
+
+#ifdef PANIC_EVENT
+
+#define MAX_DEVICE_OPEN_RETRIES  	1000
+#define SEL_ENTRY_SIZE 			16
+#define COMMAND_HEADER 			2
+#define RESPONSE_SIZE 			3
+#define MAX_RETRY_COUNT			30
+
+/* Write in SEL a event when System Panic occurs */
+static int WritePanicEvent(struct notifier_block *this, unsigned long command, void *ptr ){
+    	int retval,nRetry=0;
+	BmcRequest *ibuffer;
+	BmcResponse *obuffer;
+	DWORD ilen,olen;
+	int RetryCount = 0;
+	struct inode inode;
+	int bmcdev_major;
+
+	bmcdev_major = bmcdev_getmajor();
+	inode.i_rdev = MKDEV( bmcdev_major  ,  0 );
+
+	while( nRetry < MAX_DEVICE_OPEN_RETRIES ) {
+		if( ( retval = bmcdev_open(&inode, NULL) ) == STATUS_SUCCESS )
+			break;
+		if( retval != -EBUSY )
+			break;
+		DelayRetryFunc( nRetry++, BMC_RETRY_DELAY );		
+	}
+
+	ilen = SEL_ENTRY_SIZE+COMMAND_HEADER;    /* the send header is composed of 3 bytes */
+	ibuffer = (BmcRequest*) kmalloc(ilen, GFP_KERNEL);
+	if (ibuffer) {
+		olen = RESPONSE_SIZE + COMMAND_HEADER;
+		obuffer = (BmcResponse*) kmalloc(olen, GFP_KERNEL);
+		
+		if (obuffer) {
+			ibuffer->nfLn = 0x28;  //STORAGE
+			ibuffer->cmd = 0x44;	
+			ibuffer->data[2]=0x02; //SEL_RT_STANDARD2
+			ibuffer->data[7]=0x21; //SEL_GI_NSA
+			ibuffer->data[8]=0x00;
+			ibuffer->data[9]=0x03; //SEL_EV_STANDARD3
+			ibuffer->data[10]=0x20; //SENSOR_TYPE
+			ibuffer->data[11]=0x00;
+			ibuffer->data[12]=0x6F; //EVENT_TYPE
+			ibuffer->data[13]=0x01;
+			ibuffer->data[14]=0xFF; 
+			ibuffer->data[15]=0xFF;
+			retval = ExecuteBmcCommand(ibuffer, ilen, obuffer,olen,&olen,BMC_TIME_OUT);
+			while (  retval != STATUS_SUCCESS ) {
+				/* Check Retry Count */
+				if ( RetryCount < MAX_RETRY_COUNT )
+					RetryCount++;
+				else
+					break;			
+				/* Sleep before retrying */
+				DelayRetryFunc( RetryCount, BMC_RETRY_DELAY );	
+				retval = ExecuteBmcCommand(ibuffer, ilen, obuffer,olen,&olen,BMC_TIME_OUT);									
+			}
+		}
+	}
+	nRetry=0;
+	while( nRetry < MAX_DEVICE_OPEN_RETRIES ) {
+		if( ( retval = bmcdev_release(NULL, NULL) ) == STATUS_SUCCESS )
+			break;
+		if( retval != -EBUSY )
+			break;
+		DelayRetryFunc( nRetry++, BMC_RETRY_DELAY );		
+	    }
+	return 0;
+}    
+#endif
+
+module_init(bmc_init);
+module_exit(bmc_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/bmcmain.h linux/arch/ia64/hp/bmc/bmcmain.h
--- ../prev/linux/arch/ia64/hp/bmc/bmcmain.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/bmcmain.h	Thu Jul  4 08:02:44 2002
@@ -0,0 +1,44 @@
+/****************************************************************************
+*
+* Copyright 2001 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 10955 Tantau Av
+* Cupertino, CA 95014 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+
+#ifndef UINT8
+#define UINT8	unsigned char
+#endif
+
+#ifndef UINT16
+#define UINT16	unsigned short
+#endif
+
+
+
+#define IOCTL_IMB_EXECUTE_COMMAND	0x882
+
+
+struct _SEND_RCV    
+{
+   UINT16       retcode; 
+   UINT8*       input;
+   UINT8        ilen;
+   UINT8*       output;
+   UINT8        olen;
+} __attribute__ ((packed));
+
+typedef struct _SEND_RCV SEND_RCV;
+typedef struct _SEND_RCV *PSEND_RCV;
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/constant.h linux/arch/ia64/hp/bmc/constant.h
--- ../prev/linux/arch/ia64/hp/bmc/constant.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/constant.h	Thu Jul  4 08:02:44 2002
@@ -0,0 +1,72 @@
+/****************************************************************************
+*
+* Copyright 2002 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 3000 Hanover Street
+* Palo Alto, CA 94304 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+///////////////////////////////////////////////////////////////////
+//
+// Often used constants
+//
+// History:
+//     January 2002: Initial creation by WSO - IPF
+//
+///////////////////////////////////////////////////////////////////
+
+#ifndef __CONSTANTS__
+#define __CONSTANTS__
+   
+// Constants defined by DriverWizard.
+
+#ifndef BYTE
+#define BYTE	unsigned char
+#endif
+
+#ifndef WORD
+#define WORD	unsigned short
+#endif
+
+#ifndef DWORD
+#define DWORD	unsigned long
+#endif
+
+#ifndef BOOL
+#define BOOL	bool
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+typedef unsigned char UCHAR;
+typedef unsigned char * PUCHAR;
+
+typedef unsigned short USHORT;
+typedef unsigned long  ULONG;
+
+//
+// The following constants are used in setting timeout values.
+//
+#define WAIT_1_MS                       1000            // in uSecs
+#define WAIT_5_MS                       5000            // in uSecs
+#define WAIT_10_MS                      10000           // in uSecs
+#define DEFAULT_MESSAGE_TIMEOUT (1000 * WAIT_5_MS) // Timeout after which a command
+                                                   // to the IMB will fail.
+
+#endif			// __CONSTANTS__
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/imb.c linux/arch/ia64/hp/bmc/imb.c
--- ../prev/linux/arch/ia64/hp/bmc/imb.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/imb.c	Thu Jul  4 08:02:44 2002
@@ -0,0 +1,220 @@
+/****************************************************************************
+*
+* Copyright 2002 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 3000 Hanover Street
+* Palo Alto, CA 94304 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+#include "imb.h"
+#include "bmc.h"
+#include "imb_err.h"
+#include "bmcmain.h"
+
+
+//#define KdPrint( a ) printk a
+#define KdPrint( a )
+
+
+//++
+// Function:	IOCTL_IMB_EXECUTE_COMMAND_Handler
+//
+// Description:
+//		Handler for IO Control Code IOCTL_IMB_EXECUTE_COMMAND
+//
+// Arguments:
+//		SEND_RCV - tunneling structure
+//
+// Return value:
+//		None
+//
+//Comments:
+//		This routine implements the IOCTL_IMB_EXECUTE_COMMAND function.
+//--
+
+
+unsigned long ExecuteImbCommand( ImbRequestBuffer *imb_request, ULONG imb_request_data_length,
+	ImbResponseBuffer *imb_response, ULONG imb_response_data_length, ULONG *imb_returned_length );
+
+
+void IOCTL_IMB_EXECUTE_COMMAND_Handler( SEND_RCV *sr )
+{
+	unsigned long status;
+	ULONG inputBufferLength;
+	ULONG outputBufferLength;
+	ImbRequestBuffer  *ImbReq;
+	ImbResponseBuffer *ImbResp;
+	ULONG imb_response_data_length;
+	ULONG imb_request_data_length;
+	ULONG imb_returned_length;
+	
+//	UCHAR tempNfLn;
+//	UCHAR tempCmd;
+
+	inputBufferLength = sr->ilen;
+	outputBufferLength =  sr->olen;
+	ImbReq = (ImbRequestBuffer *) sr->input;
+	ImbResp = (ImbResponseBuffer *) sr->output;
+
+//	tempNfLn = ImbReq->nfLn;
+//	tempCmd = ImbReq->cmd;
+	if (inputBufferLength < MIN_IMB_REQ_BUF_SIZE) {
+		status = INVALID_INPUT_BUFFER;
+	}
+	else if (outputBufferLength < MIN_IMB_RESP_BUF_SIZE)
+		status = INVALID_OUTPUT_BUFFER;
+	else {	
+		imb_request_data_length = (ULONG) (inputBufferLength - MIN_IMB_REQ_BUF_SIZE);
+		imb_response_data_length = outputBufferLength - MIN_IMB_RESP_BUF_SIZE;
+	
+		status = ExecuteImbCommand( ImbReq, imb_request_data_length, ImbResp,
+			imb_response_data_length, &imb_returned_length );
+			
+		if ( status == STATUS_SUCCESS ) {
+			sr->olen = imb_returned_length;
+//			//Fill in known output fields
+//			ImbResp->outputData.nfLn = tempNfLn | 0x04; //Forcibly set bit2 for response
+//			ImbResp->outputData.cmd = tempCmd;			
+		}
+		
+	}	
+	sr->retcode = status;	
+}
+
+
+//++
+//  Function: ExecuteImbCommand
+// 
+//	Routine Description:
+//		This routine executes all supported IPMI commands
+//
+//	Parameters:
+//      imb_request: the input buffer as passed in by the calling
+//                   program/driver.
+//      imb_response: the output buffer as passed in by the calling
+//                    program/driver.  It points to the same memory
+//                    as imb_request.  Hence, all data from imb_request
+//                    must be saved away before imb_response is written to.
+//      imb_response_data_length: the size of imb_response->data that is
+//                    legal to write to.]
+//      imb_returned_length: the amount of data written to imb_response.
+//                    Note that this parameter and imb_response_data_length
+//                    do not pertain to the same information.  This
+//                    seemingly inconsistency is carried over from the Intel
+//                    sample IPMI driver.
+//
+//	Return Value:
+//		NTSTATUS - Return STATUS_SUCCESS if no errors are encountered.
+//			Any other indicates to the system that an error has occured.
+//
+//  Algorithm:
+//      The function is mainly a massager that converts the input to a form
+//      expected by ExecuteBmcCommand and then convers the output from
+//      that function to a form returnable by this function.
+//
+
+
+unsigned long ExecuteImbCommand( ImbRequestBuffer *imb_request, ULONG imb_request_data_length,
+	ImbResponseBuffer *imb_response, ULONG imb_response_data_length, ULONG *imb_returned_length )
+{
+	unsigned long status = STATUS_SUCCESS;
+	BYTE bmc_request_buffer[MAX_BMC_BUFFER_SIZE];
+	BYTE bmc_response_buffer[MAX_BMC_BUFFER_SIZE];
+	BmcRequest *bmc_request;
+	BmcResponse *bmc_response;
+	DWORD bmc_request_length;
+	DWORD bmc_response_length;
+	DWORD bmc_returned_length;
+	DWORD time_out;
+	ULONG data_length;
+
+	if ( (imb_request->nfLn & 0x03) != BMC_LUN ) {
+		return IMB_INVALID_REQUEST;
+	}
+	
+	// Ensure that function number is even, meaning it is a request, not a response
+	if ( (imb_request->nfLn & 0x04) != 0 ) {
+		return IMB_INVALID_REQUEST;
+	}	
+			
+	if ( MIN_BMC_RESPONSE_SIZE + imb_response_data_length > MAX_BMC_BUFFER_SIZE ) {
+		return IMB_RESPONSE_DATA_OVERFLOW;
+	}
+	
+	if ( MIN_BMC_REQUEST_SIZE + imb_request_data_length > MAX_BMC_BUFFER_SIZE ) {
+		return INVALID_INPUT_BUFFER;
+	}
+
+	bmc_request  = (BmcRequest *) bmc_request_buffer;
+	bmc_response = (BmcResponse *) bmc_response_buffer;
+
+	//Convert IMB-style input data structure to a BMC-style data structure
+	bmc_request->nfLn = imb_request->nfLn;
+	bmc_request->cmd = imb_request->cmd;
+	if ( imb_request_data_length > 0 )
+		memcpy( bmc_request->data, imb_request->data, imb_request_data_length );		
+	bmc_request_length = MIN_BMC_REQUEST_SIZE + imb_request_data_length;
+	bmc_response_length = MIN_BMC_RESPONSE_SIZE + imb_response_data_length;
+	time_out = BMC_TIME_OUT;	
+
+	KdPrint(( KERN_ERR "The BMC request command is %x\n", bmc_request->cmd));
+	KdPrint(( KERN_ERR "The BMC request netFnLn is %x\n", bmc_request->nfLn));
+	KdPrint(( KERN_ERR "The BMC request length  is %d\n", bmc_request_length));
+
+	//Execute the command
+	status = ExecuteBmcCommand( bmc_request, bmc_request_length, bmc_response,
+		bmc_response_length, &bmc_returned_length, time_out );
+
+	if ( ! status == STATUS_SUCCESS ) {
+		KdPrint(("ExecuteBmcCommand failed : %x\n", status));
+		return status;
+	} else {
+		KdPrint(("ExecuteBmcCommand ok\n"));
+	}
+
+	//Convert the BMC-style output data structure to IMB-style data structure
+	data_length = bmc_returned_length - MIN_BMC_RESPONSE_SIZE;
+
+	if( data_length > imb_response_data_length ) {
+		status = IMB_RESPONSE_DATA_OVERFLOW;
+		return status;
+	}
+
+	//Check if completion code is valid
+	if ( !( (bmc_response->cCode == 0x00) || \
+		(bmc_response->cCode >= 0xc0 && bmc_response->cCode <= 0xd4) || \
+		(bmc_response->cCode == 0xff) || \
+		(bmc_response->cCode >= 0x01 && bmc_response->cCode <= 0x7e) || \
+		(bmc_response->cCode >= 0x80 && bmc_response->cCode <= 0xbe) ) ) 
+	{
+		status = IMB_UNEXPECTED_COMPLETION_CODE;
+		return status;
+	}
+
+	//Copy the nFln, cmd and cCode
+	memcpy( &(imb_response->outputData), bmc_response, 3 );
+	if( data_length != 0 )
+		memcpy( &(imb_response->outputData.data[0]), bmc_response->data, data_length );		
+
+	// returned lenth is MIN_IMB_RESP_BUF_SIZE greater than data_length to account for nfLn, cmd, retCode[2]
+	*imb_returned_length = data_length + MIN_IMB_RESP_BUF_SIZE;
+
+	imb_response->retCode = (USHORT) status;
+
+	return status;
+}
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/imb.h linux/arch/ia64/hp/bmc/imb.h
--- ../prev/linux/arch/ia64/hp/bmc/imb.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/imb.h	Thu Jul  4 08:02:44 2002
@@ -0,0 +1,60 @@
+/****************************************************************************
+*
+* Copyright 2002 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 10955 Tantau Av
+* Cupertino, CA 95014 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+#include "constant.h"
+
+#define MIN_IMB_REQ_BUF_SIZE	2 	// Size of ImbRequestBuffer less the data field (nfLn, cmd)
+#define MIN_IMB_RESP_BUF_SIZE	5 	// Size of ImbResponseBuffer less the data field (nfLn, cmd, retCode[2], completionCode)
+#define MIN_BMC_REQUEST_SIZE	2
+#define BMC_TIME_OUT		100000	//Maximum time the BMC can do its IO for an IRP
+
+#define	BMC_SA			0x20
+#define BMC_LUN			0
+#define CCODE_UNKNOWN		0xff
+#define NETFN_OF(x)		(((x)>>2) & 0x3f)
+
+
+typedef struct  {
+	UCHAR nfLn;		// Net Function + logical unit on responder
+	UCHAR cmd;		// IMB command
+	UCHAR data[1];		// request data.  At end of structure so that it can be 0
+				// or more bytes long.
+} ImbRequestBuffer;
+
+
+typedef struct outputBuffer {
+	UCHAR nfLn;		// Net Function + logical unit on responder
+	UCHAR cmd;		// IMB command
+	UCHAR completionCode;	// Completion Code
+	UCHAR data[1];		// request data.  At end of structure so that it can be 0
+				// or more bytes long.
+} OUTPUT_BUFFER;
+
+
+typedef struct {
+	USHORT		retCode;
+	OUTPUT_BUFFER	outputData; 
+} ImbResponseBuffer;
+
+
+///////////////////////////////////
+//Function Prototypes
+///////////////////////////////////
+
+void IOCTL_IMB_EXECUTE_COMMAND_Handler();
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/bmc/imb_err.h linux/arch/ia64/hp/bmc/imb_err.h
--- ../prev/linux/arch/ia64/hp/bmc/imb_err.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/bmc/imb_err.h	Thu Jul  4 08:02:44 2002
@@ -0,0 +1,125 @@
+/****************************************************************************
+*
+* Copyright 2001 Hewlett-Packard Inc., All Rights Reserved.
+*
+* RESTRICTED RIGHTS LEGEND
+* Use, duplication, or disclosure by the U.S. Government is subject to
+* restrictions as set forth in sub-paragraph (c)(1)(ii) of the Rights in
+* Technical Data and Computer Software clause in DFARS 252.227-7013.
+*
+* Hewlett-Packard Company
+* 3000 Hanover Street
+* Palo Alto, CA 94304 U.S.A.
+*
+* Rights for non-DOD U.S. Government Departments and Agencies are as set
+* forth in FAR 52.227-19(c)(1,2).
+*
+****************************************************************************/
+
+
+////////////////////////
+//
+// MessageId: STATUS_SUCCESS
+//
+//  Operation ok
+//
+#define STATUS_SUCCESS			(0x00000000L)
+
+////////////////////////
+//
+// MessageId: INVALID_INPUT_BUFFER
+//
+//  Invalid Input Arguments passed to the IOCTL function
+//
+#define INVALID_INPUT_BUFFER             (0x00000002L)
+
+////////////////////////
+//
+// MessageId: INVALID_OUTPUT_BUFFER
+//
+//  Improper Buffer size for output values passed to the IOCTL function
+//
+#define INVALID_OUTPUT_BUFFER            (0x00000003L)
+
+////////////////////////
+//
+// MessageId: IMB_RESPONSE_DATA_OVERFLOW
+//
+//  Response data size is more than application allocated buffer size
+//
+#define IMB_RESPONSE_DATA_OVERFLOW       (0x0000000CL)
+
+////////////////////////
+//
+// MessageId: IMB_INVALID_REQUEST
+//
+//  Invalid data found in IMB request frame
+//
+#define IMB_INVALID_REQUEST              (0x0000000DL)
+
+////////////////////////
+//
+// MessageId: IMB_IF_RECEIVE_TIMEOUT
+//
+//  Timeout during receiving a BMC response
+//
+#define IMB_IF_RECEIVE_TIMEOUT           (0x00000007L)
+
+////////////////////////
+//
+// MessageId: IMB_IF_SEND_TIMEOUT
+//
+//  Timeout during sending a BMC request
+//
+#define IMB_IF_SEND_TIMEOUT              (0x00000006L)
+
+////////////////////////
+//
+// MessageId: IMB_INVALID_IF_RESPONSE
+//
+//  Error during communication with BMC through SMS stream
+//
+#define IMB_INVALID_IF_RESPONSE          (0x0000000AL)
+
+////////////////////////
+//
+// MessageId: IMB_UNEXPECTED_COMPLETION_CODE
+//
+//  An IPMI command returned an unexpected completion code
+//
+#define IMB_UNEXPECTED_COMPLETION_CODE   (0x00000100L)
+
+////////////////////////
+//
+// MessageId: IMB_PASSWORD_MISMATCH
+//
+//  A password was supplied where it shouldn't have, or a password
+//  was not supplied where it should have.
+//
+#define IMB_PASSWORD_MISMATCH             (0x00000101L)
+
+////////////////////////
+//
+// MessageId: IMB_PASSWORD_INVALID
+//
+//  A password was supplied where it shouldn't have, or a password
+//  was not supplied where it should have.
+//
+#define IMB_PASSWORD_INVALID               (0x00000102L)
+
+////////////////////////
+//
+// MessageId: IMB_UNEXPECTED_VALUE
+//
+//  An unexpected value occurred
+//
+#define IMB_UNEXPECTED_VALUE               (0x00000103L)
+
+////////////////////////
+//
+// MessageId: IMB_INTERNAL_ERROR
+//
+//  An error internal to HPImbDrv occurred
+//
+#define IMB_INTERNAL_ERROR                 (0x00000104L)
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/common/sba_iommu.c linux/arch/ia64/hp/common/sba_iommu.c
--- ../prev/linux/arch/ia64/hp/common/sba_iommu.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/hp/common/sba_iommu.c	Tue May 21 12:30:53 2002
@@ -120,7 +120,7 @@
 
 #define SBA_FUNC_SIZE	0x10000   /* SBA configuration function reg set */
 
-unsigned int __initdata zx1_func_offsets[] = {0x1000, 0x4000, 0x8000,
+unsigned int __initdata zx1_func_offsets[] = {0x1000, 0x8000,
                                               0x9000, 0xa000, -1};
 
 #define SBA_IOC_OFFSET	0x1000
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/hp/zx1/hpzx1_misc.c linux/arch/ia64/hp/zx1/hpzx1_misc.c
--- ../prev/linux/arch/ia64/hp/zx1/hpzx1_misc.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/hp/zx1/hpzx1_misc.c	Thu May 30 10:37:50 2002
@@ -15,76 +15,29 @@
 #include <asm/iosapic.h>
 #include <asm/efi.h>
 
-#include "../drivers/acpi/include/platform/acgcc.h"
-#include "../drivers/acpi/include/actypes.h"
-#include "../drivers/acpi/include/acexcep.h"
-#include "../drivers/acpi/include/acpixf.h"
-#include "../drivers/acpi/include/actbl.h"
-#include "../drivers/acpi/include/acconfig.h"
-#include "../drivers/acpi/include/acmacros.h"
-#include "../drivers/acpi/include/aclocal.h"
-#include "../drivers/acpi/include/acobject.h"
-#include "../drivers/acpi/include/acstruct.h"
-#include "../drivers/acpi/include/acnamesp.h"
-#include "../drivers/acpi/include/acutils.h"
+extern acpi_status acpi_evaluate_integer (acpi_handle, acpi_string, acpi_object_list *, unsigned long *);
 
 #define PFX "hpzx1: "
 
+static int hpzx1_devices;
+
 struct fake_pci_dev {
-	struct fake_pci_dev *next;
-	unsigned char bus;
-	unsigned int devfn;
-	int sizing;		// in middle of BAR sizing operation?
 	unsigned long csr_base;
-	unsigned int csr_size;
+	unsigned long csr_size;
 	unsigned long mapped_csrs;	// ioremapped
+	int sizing;			// in middle of BAR sizing operation?
 };
 
-static struct fake_pci_dev *fake_pci_head, **fake_pci_tail = &fake_pci_head;
-
 static struct pci_ops *orig_pci_ops;
 
-static inline struct fake_pci_dev *
-fake_pci_find_slot(unsigned char bus, unsigned int devfn)
-{
-	struct fake_pci_dev *dev;
-
-	for (dev = fake_pci_head; dev; dev = dev->next)
-		if (dev->bus == bus && dev->devfn == devfn)
-			return dev;
-	return NULL;
-}
-
-static struct fake_pci_dev *
-alloc_fake_pci_dev(void)
-{
-        struct fake_pci_dev *dev;
-
-        dev = kmalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev)
-		return NULL;
-
-	memset(dev, 0, sizeof(*dev));
-
-        *fake_pci_tail = dev;
-        fake_pci_tail = &dev->next;
-
-        return dev;
-}
-
 #define HP_CFG_RD(sz, bits, name) \
 static int hp_cfg_read##sz (struct pci_dev *dev, int where, u##bits *value) \
 { \
 	struct fake_pci_dev *fake_dev; \
-	if (!(fake_dev = fake_pci_find_slot(dev->bus->number, dev->devfn))) \
+	if (!(fake_dev = (struct fake_pci_dev *) dev->sysdata)) \
 		return orig_pci_ops->name(dev, where, value); \
 	\
-	switch (where) { \
-	case PCI_COMMAND: \
-		*value = read##sz(fake_dev->mapped_csrs + where); \
-		*value |= PCI_COMMAND_MEMORY; /* SBA omits this */ \
-		break; \
-	case PCI_BASE_ADDRESS_0: \
+	if (where == PCI_BASE_ADDRESS_0) { \
 		if (fake_dev->sizing) \
 			*value = ~(fake_dev->csr_size - 1); \
 		else \
@@ -92,11 +45,11 @@
 				    PCI_BASE_ADDRESS_MEM_MASK) | \
 				PCI_BASE_ADDRESS_SPACE_MEMORY; \
 		fake_dev->sizing = 0; \
-		break; \
-	default: \
-		*value = read##sz(fake_dev->mapped_csrs + where); \
-		break; \
+		return PCIBIOS_SUCCESSFUL; \
 	} \
+	*value = read##sz(fake_dev->mapped_csrs + where); \
+	if (where == PCI_COMMAND) \
+		*value |= PCI_COMMAND_MEMORY; /* SBA omits this */ \
 	return PCIBIOS_SUCCESSFUL; \
 }
 
@@ -104,18 +57,16 @@
 static int hp_cfg_write##sz (struct pci_dev *dev, int where, u##bits value) \
 { \
 	struct fake_pci_dev *fake_dev; \
-	if (!(fake_dev = fake_pci_find_slot(dev->bus->number, dev->devfn))) \
+	\
+	if (!(fake_dev = (struct fake_pci_dev *) dev->sysdata)) \
 		return orig_pci_ops->name(dev, where, value); \
 	\
-	switch (where) { \
-	case PCI_BASE_ADDRESS_0: \
+	if (where == PCI_BASE_ADDRESS_0) { \
 		if (value == ~0) \
 			fake_dev->sizing = 1; \
-		break; \
-	default: \
+		return PCIBIOS_SUCCESSFUL; \
+	} else \
 		write##sz(value, fake_dev->mapped_csrs + where); \
-		break; \
-	} \
 	return PCIBIOS_SUCCESSFUL; \
 }
 
@@ -135,51 +86,81 @@
 	hp_cfg_writel,
 };
 
-/*
- * Assume we'll never have a physical slot higher than 0x10, so we can
- * use slots above that for "fake" PCI devices to represent things
- * that only show up in the ACPI namespace.
- */
-#define HP_MAX_SLOT	0x10
-
-static struct fake_pci_dev *
-hpzx1_fake_pci_dev(unsigned long addr, unsigned int bus, unsigned int size)
+static void
+hpzx1_fake_pci_dev(char *name, unsigned int busnum, unsigned long addr, unsigned int size)
 {
-	struct fake_pci_dev *dev;
+	struct fake_pci_dev *fake;
 	int slot;
+	struct pci_dev *dev;
+	struct pci_bus *b, *bus = NULL;
+	u8 hdr;
+
+        fake = kmalloc(sizeof(*fake), GFP_KERNEL);
+	if (!fake) {
+		printk(KERN_ERR PFX "No memory for %s (0x%p) sysdata\n", name,
+			(void *) addr);
+		return;
+	}
 
-	// Note: lspci thinks 0x1f is invalid
-	for (slot = 0x1e; slot > HP_MAX_SLOT; slot--) {
-		if (!fake_pci_find_slot(bus, PCI_DEVFN(slot, 0)))
+	memset(fake, 0, sizeof(*fake));
+	fake->csr_base = addr;
+	fake->csr_size = size;
+	fake->mapped_csrs = (unsigned long) ioremap(addr, size);
+	fake->sizing = 0;
+
+	pci_for_each_bus(b)
+		if (busnum == b->number) {
+			bus = b;
 			break;
+		}
+
+	if (!bus) {
+		printk(KERN_ERR PFX "No host bus 0x%02x for %s (0x%p)\n",
+			busnum, name, (void *) addr);
+		kfree(fake);
+		return;
 	}
-	if (slot == HP_MAX_SLOT) {
-		printk(KERN_ERR PFX
-			"no slot space for device (0x%p) on bus 0x%02x\n",
-			(void *) addr, bus);
-		return NULL;
+
+	for (slot = 0x1e; slot; slot--)
+		if (!pci_find_slot(busnum, PCI_DEVFN(slot, 0)))
+			break;
+
+	if (slot < 0) {
+		printk(KERN_ERR PFX "No space for %s (0x%p) on bus 0x%02x\n",
+			name, (void *) addr, busnum);
+		kfree(fake);
+		return;
 	}
 
-	dev = alloc_fake_pci_dev();
+        dev = kmalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
-		printk(KERN_ERR PFX
-			"no memory for device (0x%p) on bus 0x%02x\n",
-			(void *) addr, bus);
-		return NULL;
+		printk(KERN_ERR PFX "No memory for %s (0x%p)\n", name,
+			(void *) addr);
+		kfree(fake);
+		return;
 	}
 
+	bus->ops = &hp_pci_conf;	// replace pci ops for this bus
+
+	memset(dev, 0, sizeof(*dev));
 	dev->bus = bus;
+	dev->sysdata = fake;
 	dev->devfn = PCI_DEVFN(slot, 0);
-	dev->csr_base = addr;
-	dev->csr_size = size;
+	pci_read_config_word(dev, PCI_VENDOR_ID, &dev->vendor);
+	pci_read_config_word(dev, PCI_DEVICE_ID, &dev->device);
+	pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr);
+	dev->hdr_type = hdr & 0x7f;
 
-	/*
-	 * Drivers should ioremap what they need, but we have to do
-	 * it here, too, so PCI config accesses work.
-	 */
-	dev->mapped_csrs = (unsigned long) ioremap(dev->csr_base, dev->csr_size);
+	pci_setup_device(dev);
+
+	// pci_insert_device() without running /sbin/hotplug
+	list_add_tail(&dev->bus_list, &bus->devices);
+	list_add_tail(&dev->global_list, &pci_devices);
 
-	return dev;
+	printk(KERN_INFO PFX "%s at 0x%lx; pci dev %s\n", name, addr,
+		dev->slot_name);
+
+	hpzx1_devices++;
 }
 
 typedef struct {
@@ -191,14 +172,13 @@
 
 #define HP_CCSR_LENGTH 0x21
 #define HP_CCSR_TYPE 0x2
-#define HP_CCSR_GUID EFI_GUID(0x69e9adf9, 0x924f, 0xab5f,			\
+#define HP_CCSR_GUID EFI_GUID(0x69e9adf9, 0x924f, 0xab5f, \
 			      0xf6, 0x4a, 0x24, 0xd2, 0x01, 0x37, 0x0e, 0xad)
 
 extern acpi_status acpi_get_crs(acpi_handle, acpi_buffer *);
 extern acpi_resource *acpi_get_crs_next(acpi_buffer *, int *);
 extern acpi_resource_data *acpi_get_crs_type(acpi_buffer *, int *, int);
 extern void acpi_dispose_crs(acpi_buffer *);
-extern acpi_status acpi_cf_evaluate_method(acpi_handle, UINT8 *, NATIVE_UINT *);
 
 static acpi_status
 hp_csr_space(acpi_handle obj, u64 *csr_base, u64 *csr_length)
@@ -214,7 +194,7 @@
 	*csr_length = 0;
 
 	status = acpi_get_crs(obj, &buf);
-	if (status != AE_OK) {
+	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PFX "Unable to get _CRS data on object\n");
 		return status;
 	}
@@ -255,13 +235,12 @@
 hpzx1_sba_probe(acpi_handle obj, u32 depth, void *context, void **ret)
 {
 	u64 csr_base = 0, csr_length = 0;
-	char *name = context;
-	struct fake_pci_dev *dev;
 	acpi_status status;
+	char *name = context;
+	char fullname[16];
 
 	status = hp_csr_space(obj, &csr_base, &csr_length);
-
-	if (status != AE_OK)
+	if (ACPI_FAILURE(status))
 		return status;
 
 	/*
@@ -269,14 +248,10 @@
 	 * includes both SBA and IOC.  Make SBA and IOC show up
 	 * separately in PCI space.
 	 */
-	if ((dev = hpzx1_fake_pci_dev(csr_base, 0, 0x1000)))
-		printk(KERN_INFO PFX "%s SBA at 0x%lx; pci dev %02x:%02x.%d\n",
-			name, csr_base, dev->bus,
-			PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
-	if ((dev = hpzx1_fake_pci_dev(csr_base + 0x1000, 0, 0x1000)))
-		printk(KERN_INFO PFX "%s IOC at 0x%lx; pci dev %02x:%02x.%d\n",
-			name, csr_base + 0x1000, dev->bus,
-			PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+	sprintf(fullname, "%s SBA", name);
+	hpzx1_fake_pci_dev(fullname, 0, csr_base, 0x1000);
+	sprintf(fullname, "%s IOC", name);
+	hpzx1_fake_pci_dev(fullname, 0, csr_base + 0x1000, 0x1000);
 
 	return AE_OK;
 }
@@ -284,28 +259,24 @@
 static acpi_status
 hpzx1_lba_probe(acpi_handle obj, u32 depth, void *context, void **ret)
 {
-	acpi_status status;
 	u64 csr_base = 0, csr_length = 0;
+	acpi_status status;
+	NATIVE_UINT busnum;
 	char *name = context;
-	NATIVE_UINT busnum = 0;
-	struct fake_pci_dev *dev;
+	char fullname[32];
 
 	status = hp_csr_space(obj, &csr_base, &csr_length);
-
-	if (status != AE_OK)
+	if (ACPI_FAILURE(status))
 		return status;
 
 	status = acpi_evaluate_integer(obj, METHOD_NAME__BBN, NULL, &busnum);
 	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PFX "evaluate _BBN fail=0x%x\n", status);
+		printk(KERN_WARNING PFX "evaluate _BBN fail=0x%x\n", status);
 		busnum = 0;	// no _BBN; stick it on bus 0
 	}
 
-	if ((dev = hpzx1_fake_pci_dev(csr_base, busnum, csr_length)))
-		printk(KERN_INFO PFX "%s LBA at 0x%lx, _BBN 0x%02x; "
-			"pci dev %02x:%02x.%d\n",
-			name, csr_base, busnum, dev->bus,
-			PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+	sprintf(fullname, "%s _BBN 0x%02x", name, busnum);
+	hpzx1_fake_pci_dev(fullname, busnum, csr_base, csr_length);
 
 	return AE_OK;
 }
@@ -315,6 +286,8 @@
 {
 	extern struct pci_ops *pci_root_ops;
 
+	orig_pci_ops = pci_root_ops;
+
 	/*
 	 * Make fake PCI devices for the following hardware in the
 	 * ACPI namespace.  This makes it more convenient for drivers
@@ -329,10 +302,10 @@
 	 */
 	acpi_get_devices("HWP0001", hpzx1_sba_probe, "HWP0001", NULL);
 #ifdef CONFIG_IA64_HP_PROTO
-	if (fake_pci_tail != &fake_pci_head) {
+	if (hpzx1_devices) {
 #endif
-	acpi_get_devices("HWP0002", hpzx1_lba_probe, "HWP0002", NULL);
-	acpi_get_devices("HWP0003", hpzx1_lba_probe, "HWP0003", NULL);
+	acpi_get_devices("HWP0002", hpzx1_lba_probe, "HWP0002 PCI LBA", NULL);
+	acpi_get_devices("HWP0003", hpzx1_lba_probe, "HWP0003 AGP LBA", NULL);
 
 #ifdef CONFIG_IA64_HP_PROTO
 	}
@@ -343,48 +316,25 @@
 	 * if we didn't find anything, add the things we know are
 	 * there.
 	 */
-	if (fake_pci_tail == &fake_pci_head) {
+	if (hpzx1_devices == 0) {
 		u64 hpa, csr_base;
-		struct fake_pci_dev *dev;
 
 		csr_base = 0xfed00000UL;
-		hpa = (u64) ioremap(csr_base, 0x1000);
+		hpa = (u64) ioremap(csr_base, 0x2000);
 		if (__raw_readl(hpa) == ZX1_FUNC_ID_VALUE) {
-			if ((dev = hpzx1_fake_pci_dev(csr_base, 0, 0x1000)))
-				printk(KERN_INFO PFX "HWP0001 SBA at 0x%lx; "
-					"pci dev %02x:%02x.%d\n", csr_base,
-					dev->bus, PCI_SLOT(dev->devfn),
-					PCI_FUNC(dev->devfn));
-			if ((dev = hpzx1_fake_pci_dev(csr_base + 0x1000, 0,
-					0x1000)))
-				printk(KERN_INFO PFX "HWP0001 IOC at 0x%lx; "
-					"pci dev %02x:%02x.%d\n",
-					csr_base + 0x1000,
-					dev->bus, PCI_SLOT(dev->devfn),
-					PCI_FUNC(dev->devfn));
+			hpzx1_fake_pci_dev("HWP0001 SBA", 0, csr_base, 0x1000);
+			hpzx1_fake_pci_dev("HWP0001 IOC", 0, csr_base + 0x1000,
+					    0x1000);
 
 			csr_base = 0xfed24000UL;
 			iounmap(hpa);
 			hpa = (u64) ioremap(csr_base, 0x1000);
-			if ((dev = hpzx1_fake_pci_dev(csr_base, 0x40, 0x1000)))
-				printk(KERN_INFO PFX "HWP0003 AGP LBA at "
-					"0x%lx; pci dev %02x:%02x.%d\n",
-					csr_base,
-					dev->bus, PCI_SLOT(dev->devfn),
-					PCI_FUNC(dev->devfn));
+			hpzx1_fake_pci_dev("HWP0003 AGP LBA", 0x40, csr_base,
+					    0x1000);
 		}
 		iounmap(hpa);
 	}
 #endif
-
-	if (fake_pci_tail == &fake_pci_head)
-		return;
-
-	/*
-	 * Replace PCI ops, but only if we made fake devices.
-	 */
-	orig_pci_ops = pci_root_ops;
-	pci_root_ops = &hp_pci_conf;
 }
 
 extern void sba_init(void);
@@ -392,9 +342,9 @@
 void
 hpzx1_pci_fixup (int phase)
 {
-	if (phase == 0)
-		hpzx1_acpi_dev_init();
 	iosapic_pci_fixup(phase);
-        if (phase == 1)
+	if (phase == 1) {
+		hpzx1_acpi_dev_init();
 		sba_init();
+	}
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/acpi.c linux/arch/ia64/kernel/acpi.c
--- ../prev/linux/arch/ia64/kernel/acpi.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/acpi.c	Wed Jun 12 09:55:34 2002
@@ -47,6 +47,8 @@
 
 #define PREFIX			"ACPI: "
 
+enum acpi_irq_model_id		acpi_irq_model;
+
 asm (".weak iosapic_register_irq");
 asm (".weak iosapic_register_legacy_irq");
 asm (".weak iosapic_register_platform_irq");
@@ -60,12 +62,13 @@
 acpi_get_sysname (void)
 {
 #ifdef CONFIG_IA64_GENERIC
-	unsigned long rsdp_phys = 0;
+	unsigned long rsdp_phys;
 	struct acpi20_table_rsdp *rsdp;
 	struct acpi_table_xsdt *xsdt;
 	struct acpi_table_header *hdr;
 
-	if ((0 != acpi_find_rsdp(&rsdp_phys)) || !rsdp_phys) {
+	rsdp_phys = acpi_find_rsdp();
+	if (!rsdp_phys) {
 		printk("ACPI 2.0 RSDP not found, default to \"dig\"\n");
 		return "dig";
 	}
@@ -193,6 +196,13 @@
 	return vector;
 }
 
+char *
+__acpi_map_table (
+	unsigned long	phys_addr,
+	unsigned long	size)
+{
+	return __va(phys_addr);
+}
 
 /* --------------------------------------------------------------------------
                             Boot-time Table Parsing
@@ -449,33 +459,27 @@
 }
 
 
-int __init
-acpi_find_rsdp (unsigned long *rsdp_phys)
+unsigned long __init
+acpi_find_rsdp (void)
 {
-	if (!rsdp_phys)
-		return -EINVAL;
+	unsigned long rsdp_phys = 0;
 
 	if (efi.acpi20) {
-		(*rsdp_phys) = __pa(efi.acpi20);
-		return 0;
+		rsdp_phys = __pa(efi.acpi20);
 	}
 	else if (efi.acpi) {
 		printk(KERN_WARNING PREFIX "v1.0/r0.71 tables no longer supported\n");
 	}
 
-	return -ENODEV;
+	return rsdp_phys;
 }
 
 
-#ifdef CONFIG_SERIAL_ACPI
-
-#include <linux/acpi_serial.h>
-
 static int __init
-acpi_parse_spcr (unsigned long phys_addr, unsigned long size)
+acpi_parse_facp (unsigned long phys_addr, unsigned long size)
 {
-	acpi_ser_t *spcr = NULL;
-	unsigned long global_int = 0;
+	struct acpi_table_header *facp_header;
+	fadt_descriptor_rev2 *facp;
 
 	if (!phys_addr || !size)
 		return -EINVAL;
@@ -483,54 +487,36 @@
 	if (!iosapic_register_irq)
 		return -ENODEV;
 
-	/*
-	 * ACPI is able to describe serial ports that live at non-standard
-	 * memory addresses and use non-standard interrupts, either via
-	 * direct SAPIC mappings or via PCI interrupts.  We handle interrupt
-	 * routing for SAPIC-based (non-PCI) devices here.  Interrupt routing
-	 * for PCI devices will be handled when processing the PCI Interrupt
-	 * Routing Table (PRT).
-	 */
+	facp_header = (struct acpi_table_header *) __va(phys_addr);
+	if (!facp_header) {
+		printk(KERN_WARNING PREFIX "Unable to map FACP\n");
+		return -ENODEV;
+	}
 
-	spcr = (acpi_ser_t *) __va(phys_addr);
-	if (!spcr) {
-		printk(KERN_WARNING PREFIX "Unable to map SPCR\n");
+	if (facp_header->revision != 3) {
+		/* Only deal with ACPI 2.0 FACP */
 		return -ENODEV;
 	}
 
-	setup_serial_acpi(spcr);
+	facp = (fadt_descriptor_rev2 *)facp_header;
 
-	if (spcr->length < sizeof(acpi_ser_t))
-		/* Table not long enough for full info, thus no interrupt */
-		return -ENODEV;
+	if (!acpi_madt->flags.pcat_compat || (facp->sci_int >= 16)) {
 
-	if ((spcr->base_addr.space_id != ACPI_SERIAL_PCICONF_SPACE) &&
-	    (spcr->int_type == ACPI_SERIAL_INT_SAPIC))
-	{
 		u32 irq_base = 0;
 		char *iosapic_address = NULL;
-		int vector = 0;
 
-		/* We have a UART in memory space with an SAPIC interrupt */
+		if (!acpi_find_iosapic(facp->sci_int, &irq_base, &iosapic_address)) {
 
-		global_int = (  (spcr->global_int[3] << 24) |
-				(spcr->global_int[2] << 16) |
-				(spcr->global_int[1] << 8)  |
-				(spcr->global_int[0])  );
+			(void)iosapic_register_irq (facp->sci_int, 0, 0,
+			                            irq_base, iosapic_address);
 
-		/* Which iosapic does this IRQ belong to? */
-
-		if (0 == acpi_find_iosapic(global_int, &irq_base, &iosapic_address)) {
-			vector = iosapic_register_irq (global_int, 1, 1,
-						       irq_base, iosapic_address);
 		}
+
 	}
+
 	return 0;
 }
 
-#endif /*CONFIG_SERIAL_ACPI*/
-
-
 int __init
 acpi_boot_init (char *cmdline)
 {
@@ -601,15 +587,12 @@
 		return result;
 	}
 
-#ifdef CONFIG_SERIAL_ACPI
 	/*
-	 * TBD: Need phased approach to table parsing (only do those absolutely
-	 *      required during boot-up).  Recommend expanding concept of fix-
-	 *      feature devices (LDM) to include table-based devices such as
-	 *      serial ports, EC, SMBus, etc.
+	 * The FADT table contains an SCI_INT line, by which the system
+	 * gets interrupts such as power and sleep buttons.  If it's not
+	 * on a Legacy interrupt, it needs to be setup.
 	 */
-	acpi_table_parse(ACPI_SPCR, acpi_parse_spcr);
-#endif /*CONFIG_SERIAL_ACPI*/
+	acpi_table_parse(ACPI_FACP, acpi_parse_facp);
 
 #ifdef CONFIG_SMP
 	if (available_cpus == 0) {
@@ -643,14 +626,14 @@
 	*vectors = NULL;
 	*count = 0;
 
-	if (acpi_prts.count < 0) {
+	if (acpi_prt.count < 0) {
 		printk(KERN_ERR PREFIX "No PCI IRQ routing entries\n");
 		return -ENODEV;
 	}
 
 	/* Allocate vectors */
 
-	*vectors = kmalloc(sizeof(struct pci_vector_struct) * acpi_prts.count, GFP_KERNEL);
+	*vectors = kmalloc(sizeof(struct pci_vector_struct) * acpi_prt.count, GFP_KERNEL);
 	if (!(*vectors))
 		return -ENOMEM;
 
@@ -658,15 +641,15 @@
 
 	vector = *vectors;
 
-	list_for_each(node, &acpi_prts.entries) {
+	list_for_each(node, &acpi_prt.entries) {
 		entry = (struct acpi_prt_entry *)node;
 		vector[i].bus    = entry->id.bus;
-		vector[i].pci_id = ((u32) entry->id.dev << 16) | 0xffff;
-		vector[i].pin    = entry->id.pin;
-		vector[i].irq    = entry->source.index;
+		vector[i].pci_id = ((u32) entry->id.device << 16) | 0xffff;
+		vector[i].pin    = entry->pin;
+		vector[i].irq    = entry->link.index;
 		i++;
 	}
-	*count = acpi_prts.count;
+	*count = acpi_prt.count;
 	return 0;
 }
 
@@ -678,9 +661,33 @@
         if (!type)
                 return -EINVAL;
 
-	*type = ACPI_INT_MODEL_IOSAPIC;
+	*type = ACPI_IRQ_MODEL_IOSAPIC;
 
         return 0;
+}
+
+int __init
+acpi_register_irq (u32 gsi, u32 polarity, u32 trigger)
+{
+	int vector = 0;
+	u32 irq_base;
+	char *iosapic_address;
+
+	if(acpi_madt->flags.pcat_compat && (gsi < 16))
+		return isa_irq_to_vector(gsi);
+
+	if (!iosapic_register_irq)
+		return 0;
+
+	/* Find the IOSAPIC */
+	if (!acpi_find_iosapic(gsi, &irq_base, &iosapic_address)) {
+
+		/* Turn it on */
+		vector = iosapic_register_irq (gsi, polarity, trigger,
+		              irq_base, iosapic_address);
+
+	}
+	return vector;
 }
 
 #endif /* CONFIG_ACPI_BOOT */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/efi.c linux/arch/ia64/kernel/efi.c
--- ../prev/linux/arch/ia64/kernel/efi.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/efi.c	Wed May 15 10:14:35 2002
@@ -137,7 +137,7 @@
 		u64 start;
 		u64 end;
 	} prev, curr;
-	void *efi_map_start, *efi_map_end, *p;
+	void *efi_map_start, *efi_map_end, *p, *p_next;
 	efi_memory_desc_t *md;
 	u64 efi_desc_size, start, end;
 
@@ -166,6 +166,36 @@
 				continue;
 			}
 
+			/*
+			 * Check if we're going to get into an attibute aliasing problem
+			 * with a WB entry bumping into a ~WB entry within a granule.
+			 */
+			p_next = (p + efi_desc_size);
+
+			if (p_next < efi_map_end) {
+				efi_memory_desc_t *md_next = p_next;
+
+				if ((md_next->attribute & EFI_MEMORY_WB) == 0) {
+
+					/*
+					 * If the entries meet and it's not a granule
+					 * boundary, they're mapped by the same TR and
+					 * we should try to prevent casual collisions
+					 * by making a gap.
+					 */
+					if (md_next->phys_addr ==
+					    (md->phys_addr + (md->num_pages << 12)) &&
+					    (md_next->phys_addr & (IA64_GRANULE_SIZE - 1)) != 0) {
+
+						printk("Ignoring last page of region [0x%lx-0x%lx) " \
+						       "to avoid attribute aliasing\n", md->phys_addr,
+							   md->phys_addr + (md->num_pages << 12) - 1);
+
+						md->num_pages--;
+					}
+				}
+			}
+
 			curr.start = PAGE_OFFSET + md->phys_addr;
 			curr.end   = curr.start + (md->num_pages << EFI_PAGE_SHIFT);
 
@@ -293,6 +323,23 @@
 			if (end != cp)
 				break;
 			cp = end;
+#ifdef CONFIG_IA64_HP_PROTO
+		} else if (memcmp(cp, "baud=", 4) == 0) {
+			extern int acpi_base_baud;
+
+			cp +=5;
+
+			acpi_base_baud = simple_strtoul(cp, NULL, 10);
+			printk("Using manual ACPI UART baud rate (%dMHz)\n",acpi_base_baud);
+			acpi_base_baud *= 1000000;
+			acpi_base_baud /= 16;
+		} else if (memcmp(cp, "noautoconf", 10) == 0) {
+			extern int acpi_autoconf_flag;
+
+			cp +=10;
+			printk("Autoconfig disabled for ACPI UARTs\n");
+			acpi_autoconf_flag = 0x0;
+#endif
 		} else {
 			while (*cp != ' ' && *cp)
 				++cp;
@@ -347,6 +394,9 @@
 		} else if (efi_guidcmp(config_tables[i].guid, SAL_SYSTEM_TABLE_GUID) == 0) {
 			efi.sal_systab = __va(config_tables[i].table);
 			printk(" SALsystab=0x%lx", config_tables[i].table);
+		} else if (efi_guidcmp(config_tables[i].guid, HCDP_TABLE_GUID) == 0) {
+			efi.hcdp = __va(config_tables[i].table);
+			printk(" HCDP=0x%lx", config_tables[i].table);
 		}
 	}
 	printk("\n");
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/ia64_ksyms.c linux/arch/ia64/kernel/ia64_ksyms.c
--- ../prev/linux/arch/ia64/kernel/ia64_ksyms.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/ia64_ksyms.c	Tue Jun 11 21:36:13 2002
@@ -28,6 +28,7 @@
 
 #include <linux/irq.h>
 EXPORT_SYMBOL(isa_irq_to_vector_map);
+EXPORT_SYMBOL(gsi_to_vector_map);
 EXPORT_SYMBOL(enable_irq);
 EXPORT_SYMBOL(disable_irq);
 EXPORT_SYMBOL(disable_irq_nosync);
@@ -56,6 +57,10 @@
 
 #include <asm/page.h>
 EXPORT_SYMBOL(clear_page);
+
+#include <asm/pgtable.h>
+EXPORT_SYMBOL(vmalloc_end);
+EXPORT_SYMBOL(ia64_page_valid);
 
 #include <asm/processor.h>
 # ifndef CONFIG_NUMA
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/iosapic.c linux/arch/ia64/kernel/iosapic.c
--- ../prev/linux/arch/ia64/kernel/iosapic.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/iosapic.c	Tue Jun 11 21:36:13 2002
@@ -421,6 +421,7 @@
 	irq_desc_t *idesc;
 	struct hw_interrupt_type *irq_type;
 
+	gsi_to_vector(global_vector) = vector;
 	iosapic_irq[vector].pin	= pin;
 	iosapic_irq[vector].polarity = polarity ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW;
 	iosapic_irq[vector].dmode    = delivery;
@@ -679,10 +680,6 @@
 		       iosapic_irq[vector].base_irq + iosapic_irq[vector].pin, vector);
 #endif
 
-		/*
-		 * Forget not to program the IOSAPIC RTE per ACPI _PRT
-		 */
-		set_rte(vector, (ia64_get_lid() >> 16) & 0xffff);
 	}
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/irq_ia64.c linux/arch/ia64/kernel/irq_ia64.c
--- ../prev/linux/arch/ia64/kernel/irq_ia64.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/irq_ia64.c	Tue Jun 11 21:36:13 2002
@@ -50,6 +50,11 @@
 	0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21
 };
 
+/*
+ * GSI to IA-64 vector translation table.
+ */
+__u8 gsi_to_vector_map[255] = { [0 ... 254] = {0x0}};
+
 int
 ia64_alloc_irq (void)
 {
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/pci.c linux/arch/ia64/kernel/pci.c
--- ../prev/linux/arch/ia64/kernel/pci.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/pci.c	Fri May 31 11:41:56 2002
@@ -165,7 +165,7 @@
  */
 
 struct pci_bus *
-pcibios_scan_root(int seg, int bus)
+pcibios_scan_root(int bus)
 {
 	struct list_head *list = NULL;
 	struct pci_bus *pci_bus = NULL;
@@ -174,12 +174,12 @@
 		pci_bus = pci_bus_b(list);
 		if (pci_bus->number == bus) {
 			/* Already scanned */
-			printk("PCI: Bus (%02x:%02x) already probed\n", seg, bus);
+			printk("PCI: Bus (%02x) already probed\n", bus);
 			return pci_bus;
 		}
 	}
 
-	printk("PCI: Probing PCI hardware on bus (%02x:%02x)\n", seg, bus);
+	printk("PCI: Probing PCI hardware on bus (%02x)\n", bus);
 
 	return pci_scan_bus(bus, pci_root_ops, NULL);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/perfmon.c linux/arch/ia64/kernel/perfmon.c
--- ../prev/linux/arch/ia64/kernel/perfmon.c	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/perfmon.c	Fri May 31 15:29:00 2002
@@ -106,6 +106,12 @@
 
 #define PFM_REG_RETFLAG_SET(flags, val)	do { flags &= ~PFM_REG_RETFL_MASK; flags |= (val); } while(0)
 
+#ifdef CONFIG_SMP
+#define cpu_is_online(i) (cpu_online_map & (1UL << i))
+#else
+#define cpu_is_online(i)        (i==0)
+#endif
+
 /*
  * debugging
  */
@@ -277,8 +283,8 @@
 typedef struct {
 	pfm_pmu_reg_type_t	type;
 	int			pm_pos;
-	int			(*read_check)(struct task_struct *task, unsigned int cnum, unsigned long *val);
-	int			(*write_check)(struct task_struct *task, unsigned int cnum, unsigned long *val);
+	int			(*read_check)(struct task_struct *task, unsigned int cnum, unsigned long *val, struct pt_regs *regs);
+	int			(*write_check)(struct task_struct *task, unsigned int cnum, unsigned long *val, struct pt_regs *regs);
 	unsigned long		dep_pmd[4];
 	unsigned long		dep_pmc[4];
 } pfm_reg_desc_t;
@@ -359,6 +365,7 @@
 	unsigned long pfm_spurious_ovfl_intr_count; /* keep track of spurious ovfl interrupts */
 	unsigned long pfm_ovfl_intr_count; /* keep track of ovfl interrupts */
 	unsigned long pfm_recorded_samples_count;
+	unsigned long pfm_full_smpl_buffer_count; /* how many times the sampling buffer was full */
 } pfm_stats_t;
 
 /*
@@ -675,7 +682,7 @@
 	while (size > 0) {
 		page = pfm_kvirt_to_pa(buf);
 
-		if (remap_page_range(addr, page, PAGE_SIZE, PAGE_SHARED)) return -ENOMEM;
+		if (remap_page_range(addr, page, PAGE_SIZE, PAGE_READONLY)) return -ENOMEM;
 		
 		addr  += PAGE_SIZE;
 		buf   += PAGE_SIZE;
@@ -882,7 +889,6 @@
 	    && (current->uid ^ task->suid) && (current->uid ^ task->uid);
 }
 
-
 static int
 pfx_is_sane(struct task_struct *task, pfarg_context_t *pfx)
 {
@@ -922,8 +928,8 @@
 		/*
 		 * and it must be a valid CPU
 		 */
-		cpu = ffs(pfx->ctx_cpu_mask);
-		if (cpu > smp_num_cpus) {
+		cpu = ffz(~pfx->ctx_cpu_mask);
+		if (cpu_is_online(cpu) == 0) {
 			DBprintk(("CPU%d is not online\n", cpu));
 			return -EINVAL;
 		}
@@ -945,11 +951,12 @@
 			DBprintk(("must have notify_pid when blocking for [%d]\n", task->pid));
 			return -EINVAL;
 		}
-
+#if 0
 		if ((ctx_flags & PFM_FL_NOTIFY_BLOCK) && pfx->ctx_notify_pid == task->pid) {
 			DBprintk(("cannot notify self when blocking for [%d]\n", task->pid));
 			return -EINVAL;
 		}
+#endif
 	}
 	/* probably more to add here */
 
@@ -988,7 +995,7 @@
 	if (ctx_flags & PFM_FL_SYSTEM_WIDE) {
 
 		/* at this point, we know there is at least one bit set */
-		cpu = ffs(tmp.ctx_cpu_mask) - 1;
+		cpu = ffz(~tmp.ctx_cpu_mask);
 
 		DBprintk(("requesting CPU%d currently on CPU%d\n",cpu, smp_processor_id()));
 
@@ -1301,7 +1308,7 @@
 		/*
 		 * execute write checker, if any
 		 */
-		if (PMC_WR_FUNC(cnum)) ret = PMC_WR_FUNC(cnum)(task, cnum, &tmp.reg_value);
+		if (PMC_WR_FUNC(cnum)) ret = PMC_WR_FUNC(cnum)(task, cnum, &tmp.reg_value, regs);
 abort_mission:
 		if (ret == -EINVAL) reg_retval = PFM_REG_RETFL_EINVAL;
 
@@ -1392,7 +1399,7 @@
 		/*
 		 * execute write checker, if any
 		 */
-		if (PMD_WR_FUNC(cnum)) ret = PMD_WR_FUNC(cnum)(task, cnum, &tmp.reg_value);
+		if (PMD_WR_FUNC(cnum)) ret = PMD_WR_FUNC(cnum)(task, cnum, &tmp.reg_value, regs);
 abort_mission:
 		if (ret == -EINVAL) reg_retval = PFM_REG_RETFL_EINVAL;
 
@@ -1415,6 +1422,8 @@
 
 		/* keep track of what we use */
 		CTX_USED_PMD(ctx, pmu_conf.pmd_desc[(cnum)].dep_pmd[0]);
+		/* mark this register as used as well */
+		CTX_USED_PMD(ctx, RDEP(cnum));
 
 		/* writes to unimplemented part is ignored, so this is safe */
 		ia64_set_pmd(cnum, tmp.reg_value & pmu_conf.perf_ovfl_val);
@@ -1459,7 +1468,7 @@
 	DBprintk(("ctx_last_cpu=%d for [%d]\n", atomic_read(&ctx->ctx_last_cpu), task->pid));
 
 	for (i = 0; i < count; i++, req++) {
-		unsigned long reg_val = ~0UL, ctx_val = ~0UL;
+		unsigned long ctx_val = ~0UL;
 
 		if (copy_from_user(&tmp, req, sizeof(tmp))) return -EFAULT;
 
@@ -1483,7 +1492,7 @@
 		 */
 		if (atomic_read(&ctx->ctx_last_cpu) == smp_processor_id()){
 			ia64_srlz_d();
-			val = reg_val = ia64_get_pmd(cnum);
+			val = ia64_get_pmd(cnum);
 			DBprintk(("reading pmd[%u]=0x%lx from hw\n", cnum, val));
 		} else {
 #ifdef CONFIG_SMP
@@ -1505,7 +1514,7 @@
 			}
 #endif
 			/* context has been saved */
-			val = reg_val = th->pmd[cnum];
+			val = th->pmd[cnum];
 		}
 		if (PMD_IS_COUNTING(cnum)) {
 			/*
@@ -1514,9 +1523,7 @@
 
 			val &= pmu_conf.perf_ovfl_val;
 			val += ctx_val = ctx->ctx_soft_pmds[cnum].val;
-		} else {
-			val = reg_val = ia64_get_pmd(cnum);
-		}
+		} 
 
 		tmp.reg_value = val;
 
@@ -1524,14 +1531,13 @@
 		 * execute read checker, if any
 		 */
 		if (PMD_RD_FUNC(cnum)) {
-			ret = PMD_RD_FUNC(cnum)(task, cnum, &tmp.reg_value);
+			ret = PMD_RD_FUNC(cnum)(task, cnum, &tmp.reg_value, regs);
 		}
 
 		PFM_REG_RETFLAG_SET(tmp.reg_flags, ret);
 
-		DBprintk(("read pmd[%u] ret=%d soft_pmd=0x%lx reg=0x%lx pmc=0x%lx\n", 
-					cnum, ret, ctx_val, reg_val, 
-					ia64_get_pmc(cnum)));
+		DBprintk(("read pmd[%u] ret=%d value=0x%lx pmc=0x%lx\n", 
+					cnum, ret, val, ia64_get_pmc(cnum)));
 
 		if (copy_to_user(req, &tmp, sizeof(tmp))) return -EFAULT;
 	}
@@ -1574,15 +1580,11 @@
 	 */
 	if (ctx && ctx->ctx_fl_using_dbreg == 1) return -1;
 
-	/*
-	 * XXX: not pretty
-	 */
 	LOCK_PFS();
 
 	/*
-	 * We only allow the use of debug registers when there is no system
-	 * wide monitoring 
-	 * XXX: we could relax this by 
+	 * We cannot allow setting breakpoints when system wide monitoring
+	 * sessions are using the debug registers.
 	 */
 	if (pfm_sessions.pfs_sys_use_dbregs> 0)
 		ret = -1;
@@ -1984,8 +1986,8 @@
 	if (ctx->ctx_fl_system) {
 		/* we mark ourselves as owner  of the debug registers */
 		ctx->ctx_fl_using_dbreg = 1;
-	} else {
-       		if (ctx->ctx_fl_using_dbreg == 0) {
+		DBprintk(("system-wide setting fl_using_dbreg for [%d]\n", task->pid));
+	} else if (first_time) {
 			ret= -EBUSY;
 			if ((thread->flags & IA64_THREAD_DBG_VALID) != 0) {
 				DBprintk(("debug registers already in use for [%d]\n", task->pid));
@@ -1994,6 +1996,7 @@
 			/* we mark ourselves as owner  of the debug registers */
 			ctx->ctx_fl_using_dbreg = 1;
 
+			DBprintk(("setting fl_using_dbreg for [%d]\n", task->pid));
 			/* 
 			 * Given debug registers cannot be used for both debugging 
 			 * and performance monitoring at the same time, we reuse
@@ -2001,20 +2004,27 @@
 			 */
 			memset(task->thread.dbr, 0, sizeof(task->thread.dbr));
 			memset(task->thread.ibr, 0, sizeof(task->thread.ibr));
+	}
 
-			/*
-			 * clear hardware registers to make sure we don't
-			 * pick up stale state
-			 */
-			for (i=0; i < pmu_conf.num_ibrs; i++) {
-				ia64_set_ibr(i, 0UL);
-			}
-			ia64_srlz_i();
-			for (i=0; i < pmu_conf.num_dbrs; i++) {
-				ia64_set_dbr(i, 0UL);
-			}
-			ia64_srlz_d();
+	if (first_time) {
+		DBprintk(("[%d] clearing ibrs,dbrs\n", task->pid));
+		/*
+	 	 * clear hardware registers to make sure we don't
+	 	 * pick up stale state. 
+		 *
+		 * for a system wide session, we do not use
+		 * thread.dbr, thread.ibr because this process
+		 * never leaves the current CPU and the state
+		 * is shared by all processes running on it
+	 	 */
+		for (i=0; i < pmu_conf.num_ibrs; i++) {
+			ia64_set_ibr(i, 0UL);
+		}
+		ia64_srlz_i();
+		for (i=0; i < pmu_conf.num_dbrs; i++) {
+			ia64_set_dbr(i, 0UL);
 		}
+		ia64_srlz_d();
 	}
 
 	ret = -EFAULT;
@@ -2392,9 +2402,9 @@
 {
 	struct pt_regs *regs = (struct pt_regs *)&stack;
 	struct task_struct *task = current;
-	pfm_context_t *ctx = task->thread.pfm_context;
+	pfm_context_t *ctx;
 	size_t sz;
-	int ret = -ESRCH, narg;
+	int ret, narg;
 
 	/* 
 	 * reject any call if perfmon was disabled at initialization time
@@ -2424,6 +2434,8 @@
 
 		if (pid != current->pid) {
 
+			ret = -ESRCH;
+
 			read_lock(&tasklist_lock);
 
 			task = find_task_by_pid(pid);
@@ -2438,10 +2450,11 @@
 				ret = check_task_state(task);
 				if (ret != 0) goto abort_call;
 			}
-			ctx = task->thread.pfm_context;
-		}
+		} 
 	} 
 
+	ctx = task->thread.pfm_context;
+
 	if (PFM_CMD_USE_CTX(cmd)) {
 		ret = -EINVAL;
 	       if (ctx == NULL) {
@@ -2557,7 +2570,6 @@
 	int j;
 
 
-	pfm_stats.pfm_recorded_samples_count++;
 
 	idx = ia64_fetch_and_add(1, &psb->psb_index);
 	DBprintk_ovfl(("recording index=%ld entries=%ld\n", idx-1, psb->psb_entries));
@@ -2611,6 +2623,8 @@
 		DBprintk_ovfl(("e=%p pmd%d =0x%lx\n", (void *)e, j, *e));
 		e++;
 	}
+	pfm_stats.pfm_recorded_samples_count++;
+
 	/*
 	 * make the new entry visible to user, needs to be atomic
 	 */
@@ -2626,6 +2640,7 @@
 		/*
 		 * XXX: must reset buffer in blocking mode and lost notified
 		 */
+		pfm_stats.pfm_full_smpl_buffer_count++;
 		return 1;
 	}
 	return 0;
@@ -2990,11 +3005,6 @@
 static int
 perfmon_proc_info(char *page)
 {
-#ifdef CONFIG_SMP
-#define cpu_is_online(i) (cpu_online_map & (1UL << i))
-#else
-#define cpu_is_online(i)        1
-#endif
 	char *p = page;
 	int i;
 
@@ -3004,6 +3014,7 @@
 	p += sprintf(p, "overflow intrs   : %lu\n", pfm_stats.pfm_ovfl_intr_count);
 	p += sprintf(p, "spurious intrs   : %lu\n", pfm_stats.pfm_spurious_ovfl_intr_count);
 	p += sprintf(p, "recorded samples : %lu\n", pfm_stats.pfm_recorded_samples_count);
+	p += sprintf(p, "smpl buffer full : %lu\n", pfm_stats.pfm_full_smpl_buffer_count);
 
 #ifdef CONFIG_SMP
 	p += sprintf(p, "CPU%d syst_wide   : %d\n"
@@ -3732,13 +3743,12 @@
 	 */
 	if (ctx->ctx_fl_system) {
 		task->cpus_allowed = ctx->ctx_saved_cpus_allowed;
+		task->need_resched = 1;
 
 	 	DBprintk(("setting cpus_allowed for [%d] to 0x%lx from 0x%lx\n", 
 			task->pid,
 			ctx->ctx_saved_cpus_allowed, 
 			current->cpus_allowed));
-
-		task->need_resched = 1;
 	}
 
 	/*
@@ -3944,7 +3954,7 @@
 	 * direct pointer to a task structure thereby bypassing the tasklist. 
 	 * We must make sure that, if we have task!= NULL, the target task is still 
 	 * present and is identical to the initial task specified 
-	 * during pfm_create_context(). It may already be detached from the tasklist but 
+	 * during pfm_context_create(). It may already be detached from the tasklist but 
 	 * that's okay. Note that it is okay if we miss the deadline and the task scans 
 	 * the list for nothing, it will affect performance but not correctness. 
 	 * The correctness is ensured by using the ctx_lock which prevents the 
@@ -3982,7 +3992,8 @@
 		pfm_sessions.pfs_sys_session[ctx->ctx_cpu] = NULL;
 		pfm_sessions.pfs_sys_sessions--;
 		DBprintk(("freeing syswide session on CPU%ld\n", ctx->ctx_cpu));
-		/* update perfmon debug register counter */
+
+		/* update perfmon debug register usage counter */
 		if (ctx->ctx_fl_using_dbreg) {
 			if (pfm_sessions.pfs_sys_use_dbregs == 0) {
 				printk("perfmon: invalid release for [%d] sys_use_dbregs=0\n", task->pid);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/perfmon_itanium.h linux/arch/ia64/kernel/perfmon_itanium.h
--- ../prev/linux/arch/ia64/kernel/perfmon_itanium.h	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/kernel/perfmon_itanium.h	Thu May 30 08:41:10 2002
@@ -4,7 +4,8 @@
 #error "This file is only valid when CONFIG_ITANIUM is defined"
 #endif
 
-static int pfm_ita_pmc_check(struct task_struct *task, unsigned int cnum, unsigned long *val);
+static int pfm_ita_pmc_check(struct task_struct *task, unsigned int cnum, unsigned long *val, struct pt_regs *regs);
+static int pfm_write_ibr_dbr(int mode, struct task_struct *task, void *arg, int count, struct pt_regs *regs);
 
 static pfm_reg_desc_t pmc_desc[256]={
 /* pmc0  */ { PFM_REG_CONTROL, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
@@ -47,18 +48,43 @@
 };
 
 static int
-pfm_ita_pmc_check(struct task_struct *task, unsigned int cnum, unsigned long *val)
+pfm_ita_pmc_check(struct task_struct *task, unsigned int cnum, unsigned long *val, struct pt_regs *regs)
 {
 	pfm_context_t *ctx = task->thread.pfm_context;
+	int ret;
 
-	if (cnum == 13 && (*val & 0x1) && ctx->ctx_fl_using_dbreg == 0) {
-		DBprintk(("cannot configure range restriction without initializing the instruction debug registers first\n"));
-		return -EINVAL;
+	/*
+	 * we must clear the (instruction) debug registers if pmc13.ta bit is cleared
+	 * before they are written (fl_using_dbreg==0) to avoid picking up stale information. 
+	 */
+	if (cnum == 13 && ((*val & 0x1) == 0UL) && ctx->ctx_fl_using_dbreg == 0) {
+
+		/* don't mix debug with perfmon */
+		if ((task->thread.flags & IA64_THREAD_DBG_VALID) != 0) return -EINVAL;
+
+		/* 
+		 * a count of 0 will mark the debug registers as in use and also
+		 * ensure that they are properly cleared.
+		 */
+		ret = pfm_write_ibr_dbr(1, task, NULL, 0, regs);
+		if (ret) return ret;
 	}
 
+	/*
+	 * we must clear the (data) debug registers if pmc11.pt bit is cleared
+	 * before they are written (fl_using_dbreg==0) to avoid picking up stale information. 
+	 */
 	if (cnum == 11 && ((*val >> 28)& 0x1) == 0 && ctx->ctx_fl_using_dbreg == 0) {
-		DBprintk(("cannot configure range restriction without initializing the data debug registers first pmc11=0x%lx\n", *val));
-		return -EINVAL;
+
+		/* don't mix debug with perfmon */
+		if ((task->thread.flags & IA64_THREAD_DBG_VALID) != 0) return -EINVAL;
+
+		/* 
+		 * a count of 0 will mark the debug registers as in use and also
+		 * ensure that they are properly cleared.
+		 */
+		ret = pfm_write_ibr_dbr(0, task, NULL, 0, regs);
+		if (ret) return ret;
 	}
 	return 0;
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/perfmon_mckinley.h linux/arch/ia64/kernel/perfmon_mckinley.h
--- ../prev/linux/arch/ia64/kernel/perfmon_mckinley.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/kernel/perfmon_mckinley.h	Thu May 30 08:41:10 2002
@@ -0,0 +1,127 @@
+
+#define RDEP(x)	(1UL<<(x))
+
+#ifndef CONFIG_MCKINLEY
+#error "This file is only valid when CONFIG_MCKINLEY is defined"
+#endif
+
+static int pfm_mck_pmc_check(struct task_struct *task, unsigned int cnum, unsigned long *val, struct pt_regs *regs);
+static int pfm_write_ibr_dbr(int mode, struct task_struct *task, void *arg, int count, struct pt_regs *regs);
+
+static pfm_reg_desc_t pmc_desc[256]={
+/* pmc0  */ { PFM_REG_CONTROL, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc1  */ { PFM_REG_CONTROL, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc2  */ { PFM_REG_CONTROL, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc3  */ { PFM_REG_CONTROL, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc4  */ { PFM_REG_COUNTING, 6, NULL, pfm_mck_pmc_check, {RDEP(4),0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc5  */ { PFM_REG_COUNTING, 6, NULL, NULL, {RDEP(5),0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc6  */ { PFM_REG_COUNTING, 6, NULL, NULL, {RDEP(6),0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc7  */ { PFM_REG_COUNTING, 6, NULL, NULL, {RDEP(7),0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc8  */ { PFM_REG_CONFIG, 0, NULL, pfm_mck_pmc_check, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc9  */ { PFM_REG_CONFIG, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc10 */ { PFM_REG_MONITOR, 4, NULL, NULL, {RDEP(0)|RDEP(1),0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc11 */ { PFM_REG_MONITOR, 6, NULL, NULL, {RDEP(2)|RDEP(3)|RDEP(17),0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc12 */ { PFM_REG_MONITOR, 6, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(10)|RDEP(11)|RDEP(12)|RDEP(13)|RDEP(14)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc13 */ { PFM_REG_CONFIG, 0, NULL, pfm_mck_pmc_check, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc14 */ { PFM_REG_CONFIG, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+/* pmc15 */ { PFM_REG_CONFIG, 0, NULL, pfm_mck_pmc_check, {0UL,0UL, 0UL, 0UL}, {0UL,0UL, 0UL, 0UL}},
+	    { PFM_REG_NONE, 0, NULL, NULL, {0,}, {0,}}, /* end marker */
+};
+
+static pfm_reg_desc_t pmd_desc[256]={
+/* pmd0  */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(1),0UL, 0UL, 0UL}, {RDEP(10),0UL, 0UL, 0UL}},
+/* pmd1  */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(0),0UL, 0UL, 0UL}, {RDEP(10),0UL, 0UL, 0UL}},
+/* pmd2  */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(3)|RDEP(17),0UL, 0UL, 0UL}, {RDEP(11),0UL, 0UL, 0UL}},
+/* pmd3  */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(2)|RDEP(17),0UL, 0UL, 0UL}, {RDEP(11),0UL, 0UL, 0UL}},
+/* pmd4  */ { PFM_REG_COUNTING, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {RDEP(4),0UL, 0UL, 0UL}},
+/* pmd5  */ { PFM_REG_COUNTING, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {RDEP(5),0UL, 0UL, 0UL}},
+/* pmd6  */ { PFM_REG_COUNTING, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {RDEP(6),0UL, 0UL, 0UL}},
+/* pmd7  */ { PFM_REG_COUNTING, 0, NULL, NULL, {0UL,0UL, 0UL, 0UL}, {RDEP(7),0UL, 0UL, 0UL}},
+/* pmd8  */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(9)|RDEP(10)|RDEP(11)|RDEP(12)|RDEP(13)|RDEP(14)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd9  */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(10)|RDEP(11)|RDEP(12)|RDEP(13)|RDEP(14)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd10 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(11)|RDEP(12)|RDEP(13)|RDEP(14)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd11 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(10)|RDEP(12)|RDEP(13)|RDEP(14)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd12 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(10)|RDEP(11)|RDEP(13)|RDEP(14)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd13 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(10)|RDEP(11)|RDEP(12)|RDEP(14)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd14 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(10)|RDEP(11)|RDEP(12)|RDEP(13)|RDEP(15)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd15 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(10)|RDEP(11)|RDEP(12)|RDEP(13)|RDEP(14)|RDEP(16),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd16 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(8)|RDEP(9)|RDEP(10)|RDEP(11)|RDEP(12)|RDEP(13)|RDEP(14)|RDEP(15),0UL, 0UL, 0UL}, {RDEP(12),0UL, 0UL, 0UL}},
+/* pmd17 */ { PFM_REG_BUFFER, 0, NULL, NULL, {RDEP(2)|RDEP(3),0UL, 0UL, 0UL}, {RDEP(11),0UL, 0UL, 0UL}},
+	    { PFM_REG_NONE, 0, NULL, NULL, {0,}, {0,}}, /* end marker */
+};
+
+static int
+pfm_mck_pmc_check(struct task_struct *task, unsigned int cnum, unsigned long *val, struct pt_regs *regs)
+{
+	struct thread_struct *th = &task->thread;
+	pfm_context_t *ctx = task->thread.pfm_context;
+	int ret = 0, check_case1 = 0;
+	unsigned long val8 = 0, val14 = 0, val13 = 0;
+
+	/*
+	 * we must clear the debug registers if any pmc13.ena_dbrpX bit is enabled 
+	 * before they are written (fl_using_dbreg==0) to avoid picking up stale information. 
+	 */
+	if (cnum == 13 && (*val & (0xfUL << 45)) && ctx->ctx_fl_using_dbreg == 0) {
+
+		/* don't mix debug with perfmon */
+		if ((task->thread.flags & IA64_THREAD_DBG_VALID) != 0) return -EINVAL;
+
+		/* 
+		 * a count of 0 will mark the debug registers as in use and also
+		 * ensure that they are properly cleared.
+		 */
+		ret = pfm_write_ibr_dbr(1, task, NULL, 0, regs);
+		if (ret) return ret;
+	}
+	/* 
+	 * we must clear the (instruction) debug registers if any pmc14.ibrpX bit is enabled 
+	 * before they are (fl_using_dbreg==0) to avoid picking up stale information. 
+	 */
+	if (cnum == 14 && ((*val & 0x2222) != 0x2222) && ctx->ctx_fl_using_dbreg == 0) {
+
+		/* don't mix debug with perfmon */
+		if ((task->thread.flags & IA64_THREAD_DBG_VALID) != 0) return -EINVAL;
+
+		/* 
+		 * a count of 0 will mark the debug registers as in use and also
+		 * ensure that they are properly cleared.
+		 */
+		ret = pfm_write_ibr_dbr(0, task, NULL, 0, regs);
+		if (ret) return ret;
+
+	}
+
+	switch(cnum) {
+		case  4: *val |= 1UL << 23;
+			 break;
+		case  8: val8 = *val;
+			 val13 = th->pmc[13];
+			 val14 = th->pmc[14];
+			 check_case1 = 1;
+			 break;
+		case 13: val8  = th->pmc[8];
+			 val13 = *val;
+			 val14 = th->pmc[14];
+			 check_case1 = 1;
+			 break;
+		case 14: val8  = th->pmc[13];
+			 val13 = th->pmc[13];
+			 val14 = *val;
+			 check_case1 = 1;
+			 break;
+	}
+	/* check illegal configuration which can produce inconsistencies in tagging
+	 * i-side events in L1D and L2 caches
+	 */
+	if (check_case1) {
+		ret =   ((val13 >> 45) & 0xf) == 0 
+		   && ((val8 & 0x1) == 0)
+		   && ((((val14>>1) & 0x3) == 0x2 || ((val14>>1) & 0x3) == 0x0)
+		       ||(((val14>>4) & 0x3) == 0x2 || ((val14>>4) & 0x3) == 0x0));
+
+		if (ret) printk("perfmon: failure check_case1\n");
+	}
+
+	return ret ? -EINVAL : 0;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/kernel/setup.c linux/arch/ia64/kernel/setup.c
--- ../prev/linux/arch/ia64/kernel/setup.c	Tue Jul  9 18:03:52 2002
+++ linux/arch/ia64/kernel/setup.c	Mon Jun  3 11:07:16 2002
@@ -66,6 +66,8 @@
 unsigned long ia64_iobase;	/* virtual address for I/O accesses */
 
 unsigned char aux_device_present = 0xaa;        /* XXX remove this when legacy I/O is gone */
+unsigned long MAX_DMA_ADDRESS;
+#define MAX_DMA_BASE_ADDR (PAGE_OFFSET + 0x100000000UL)
 
 #define COMMAND_LINE_SIZE	512
 
@@ -107,6 +109,22 @@
 	return 0;
 }
 
+static int
+find_max_dma_addr (unsigned long start, unsigned long end, void *arg)
+{
+	unsigned long *max_dma = arg; 
+
+	if (start >= MAX_DMA_BASE_ADDR) {
+		if (start < *max_dma)
+			*max_dma = start;
+	}
+	else {
+		if (end > MAX_DMA_BASE_ADDR)
+			*max_dma = MAX_DMA_BASE_ADDR;
+	}
+	return 0;
+}
+
 #define IGNORE_PFN0	1	/* XXX fix me: ignore pfn 0 until TLB miss handler is updated... */
 
 /*
@@ -255,6 +273,10 @@
 	max_pfn = 0;
 	efi_memmap_walk(find_max_pfn, &max_pfn);
 
+	/* Set MAX_DMA_ADDRESS */
+	MAX_DMA_ADDRESS = ~0UL;
+	efi_memmap_walk(find_max_dma_addr, &MAX_DMA_ADDRESS);
+
 	/* how many bytes to cover all the pages */
 	bootmap_size = bootmem_bootmap_pages(max_pfn) << PAGE_SHIFT;
 
@@ -345,6 +367,13 @@
 #ifdef CONFIG_ACPI_BOOT
 	acpi_boot_init(*cmdline_p);
 #endif
+#ifdef CONFIG_SERIAL_HCDP
+	if (efi.hcdp) {
+		void setup_serial_hcdp(void *);
+		/* Setup the serial ports described by HCDP */
+		setup_serial_hcdp(efi.hcdp);
+	}
+#endif
 #ifdef CONFIG_VT
 # if defined(CONFIG_DUMMY_CONSOLE)
 	conswitchp = &dummy_con;
@@ -359,7 +388,7 @@
 	if (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)
 		conswitchp = &vga_con;
 # endif
-#endif
+#endif /* CONFIG_VT */
 
 #ifdef CONFIG_IA64_MCA
 	/* enable IA-64 Machine Check Abort Handling */
@@ -393,7 +422,7 @@
 
 	switch (c->family) {
 	      case 0x07:	memcpy(family, "Itanium", 8); break;
-	      case 0x1f:	memcpy(family, "Itanium 2", 9); break;
+	      case 0x1f:	memcpy(family, "Itanium 2", 10); break;
 	      default:		sprintf(family, "%u", c->family); break;
 	}
 
@@ -570,6 +599,24 @@
 	 * accessing cpu_data() the old way, through identity mapped space.
 	 */
 	identify_cpu(my_cpu_data);
+
+#ifdef CONFIG_MCKINLEY
+	{
+#define FEATURE_SET 16
+		struct ia64_pal_retval iprv;
+
+		if (my_cpu_data->family == 0x1f) {
+
+			PAL_CALL_PHYS(iprv, PAL_PROC_GET_FEATURES, 0, FEATURE_SET, 0);
+
+			if ((iprv.status == 0) && (iprv.v0 & 0x80) && (iprv.v2 & 0x80)) {
+
+				PAL_CALL_PHYS(iprv, PAL_PROC_SET_FEATURES,
+				              (iprv.v1 | 0x80), FEATURE_SET, 0);
+			}
+		}
+	}
+#endif
 
 	/* Clear the stack memory reserved for pt_regs: */
 	memset(ia64_task_regs(current), 0, sizeof(struct pt_regs));
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/lib/Makefile linux/arch/ia64/lib/Makefile
--- ../prev/linux/arch/ia64/lib/Makefile	Tue Jul  9 18:03:52 2002
+++ linux/arch/ia64/lib/Makefile	Wed Jun 12 10:01:41 2002
@@ -12,12 +12,12 @@
 obj-y := __divsi3.o __udivsi3.o __modsi3.o __umodsi3.o					\
 	__divdi3.o __udivdi3.o __moddi3.o __umoddi3.o					\
 	checksum.o clear_page.o csum_partial_copy.o					\
-	copy_user.o clear_user.o strncpy_from_user.o strlen_user.o strnlen_user.o	\
+	clear_user.o strncpy_from_user.o strlen_user.o strnlen_user.o	\
 	flush.o ip_fast_csum.o io.o do_csum.o						\
-	memcpy.o memset.o strlen.o swiotlb.o
+	memcpy.o memset.o strlen.o swiotlb.o page_valid.o
 
-obj-$(CONFIG_ITANIUM) += copy_page.o
-obj-$(CONFIG_MCKINLEY) += copy_page_mck.o
+obj-$(CONFIG_ITANIUM) += copy_page.o copy_user.o
+obj-$(CONFIG_MCKINLEY) += copy_page_mck.o copy_user_mck.o
 
 IGNORE_FLAGS_OBJS =	__divsi3.o __udivsi3.o __modsi3.o __umodsi3.o \
 			__divdi3.o __udivdi3.o __moddi3.o __umoddi3.o
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/lib/copy_user_mck.S linux/arch/ia64/lib/copy_user_mck.S
--- ../prev/linux/arch/ia64/lib/copy_user_mck.S	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/lib/copy_user_mck.S	Wed Jun 12 10:01:41 2002
@@ -0,0 +1,642 @@
+/*
+ *
+ * Itanium2-optimized version of copy_user() function
+ *
+ * Inputs:
+ * 	in0:	destination address
+ *	in1:	source address
+ *	in2:	number of bytes to copy
+ * Output:
+ * 	0 if success, or number of byte NOT copied if error occurred.
+ *
+ * Copyright (C) 2002 Intel Corp.
+ * Copyright (C) 2002 Ken Chen <kenneth.w.chen@intel.com>
+ *
+ */
+#include <linux/config.h>
+
+#include <asm/asmmacro.h>
+#include <asm/page.h>
+
+# define EK(y,x...)  x
+
+GLOBAL_ENTRY(__copy_user)
+
+/* McKinley specific optimization */
+
+#define retval		r8
+#define saved_pfs	r31
+#define saved_lc	r10
+#define saved_pr	r11
+#define saved_in0	r14
+#define saved_in1	r15
+#define saved_in2	r16
+
+#define src0		r2
+#define src1		r3
+#define dst0		r17
+#define dst1		r18
+#define cnt		r9
+
+/* r19-r30 are temp for each code section */
+#define PREFETCH_DIST	8
+#define src_pre_mem	r19
+#define dst_pre_mem	r20
+#define src_pre_l2	r21
+#define dst_pre_l2	r22
+#define t1		r23
+#define t2		r24
+#define t3		r25
+#define t4		r26
+#define t5		t1	// alias!
+#define t6		t2	// alias!
+#define t7		t3	// alias!
+#define n8		r27
+#define t9		t5	// alias!
+#define t10		t4	// alias!
+#define t11		t7	// alias!
+#define t12		t6	// alias!
+#define t14		t10	// alias!
+#define t13		r28
+#define t15		r29
+#define tmp		r30
+
+/* defines for long_copy block */
+#define	A	0
+#define B	(PREFETCH_DIST)
+#define C	(B + PREFETCH_DIST)
+#define D	(C + 1)
+#define N	(D + 1)
+#define Nrot	((N + 7) & ~7)
+
+/* alias */
+#define in0		r32
+#define in1		r33
+#define in2		r34
+
+
+// check dest alignment
+	and	r28=0x7,in0
+	and	r29=0x7,in1
+	mov	saved_in0=in0	// save dest pointer
+	mov	saved_in1=in1	// save src pointer
+	mov	saved_in2=in2	// save len
+	mov	retval=r0	// initialize return value
+	;;
+	cmp.gt	p15,p0=8,in2	// check for small size
+	cmp.ne	p13,p0=0,r28	// check dest alignment
+	cmp.ne	p14,p0=0,r29	// check src alignment
+	add	src0=0,in1
+	add	src1=1,in1	// source odd index
+	sub	r30=8,r28	// for .align_dest
+	;;
+	add	dst0=0,in0
+	add	dst1=1,in0	// dest odd index
+	cmp.le	p6,p0 = 1,r30	// for .align_dest
+(p15)	br.cond.dpnt .memcpy_short
+(p13)	br.cond.dpnt .align_dest
+(p14)	br.cond.dpnt .unaligned_src
+	;;
+
+// both dest and src are aligned on 8-byte boundary
+.aligned_src:
+	.prologue
+	.save ar.pfs, saved_pfs
+	alloc	saved_pfs=ar.pfs,3,Nrot-3,0,Nrot
+	.save pr, saved_pr
+	mov	saved_pr=pr
+
+	.body
+	shr.u	cnt=in2,7	// this much cache line
+	;;
+	cmp.lt	p6,p0=2*PREFETCH_DIST,cnt
+	cmp.lt	p7,p8=1,cnt
+	.save ar.lc, saved_lc
+	mov	saved_lc=ar.lc
+	add	cnt=-1,cnt
+	add	src_pre_mem=0,in1	// prefetch src pointer
+	add	dst_pre_mem=0,in0	// prefetch dest pointer
+	;;
+(p7)	mov	ar.lc=cnt	// prefetch count
+(p8)	mov	ar.lc=r0
+(p6)	br.cond.dpnt .long_copy
+	;;
+
+.prefetch:
+	lfetch.fault	  [src_pre_mem], 128
+	lfetch.fault.excl [dst_pre_mem], 128
+	br.cloop.dptk.few .prefetch
+	;;
+
+.medium_copy:
+	and	tmp=31,in2	// copy length after iteration
+	shr.u	r29=in2,5	// number of 32-byte iteration
+	add	dst1=8,dst0	// 2nd dest pointer
+	;;
+	add	cnt=-1,r29	// ctop iteration adjustment
+	cmp.eq	p10,p0=r29,r0	// do we really need to loop?
+	add	src1=8,src0	// 2nd src pointer
+	cmp.le	p6,p0=8,tmp
+	;;
+	cmp.le	p7,p0=16,tmp
+	mov	ar.lc=cnt	// loop setup
+	cmp.eq	p16,p17 = r0,r0
+	mov	ar.ec=2
+(p10)	br.dpnt.few .aligned_src_tail
+	;;
+	.align 32
+1:
+EX(.ex_handler, (p16)	ld8	r34=[src0],16)
+EK(.ex_handler, (p16)	ld8	r38=[src1],16)
+EX(.ex_handler, (p17)	st8	[dst0]=r33,16)
+EK(.ex_handler, (p17)	st8	[dst1]=r37,16)
+	;;
+EX(.ex_handler, (p16)	ld8	r32=[src0],16)
+EK(.ex_handler, (p16)	ld8	r36=[src1],16)
+EX(.ex_handler, (p16)	st8	[dst0]=r34,16)
+EK(.ex_handler, (p16)	st8	[dst1]=r38,16)
+	br.ctop.dptk.few 1b
+	;;
+
+.aligned_src_tail:
+EX(.ex_handler, (p6)	ld8	t1=[src0])
+	mov	ar.lc=saved_lc
+	mov	ar.pfs=saved_pfs
+EX(.ex_handler, (p7)	ld8	t2=[src1],8)
+	cmp.le	p8,p0=24,tmp
+	and	r21=-8,tmp
+	;;
+EX(.ex_handler, (p8)	ld8	t3=[src1])
+EK(.ex_handler, (p6)	st8	[dst0]=t1)	// store byte 1
+	and	in2=7,tmp	// remaining length
+EX(.ex_handler, (p7)	st8	[dst1]=t2,8)	// store byte 2
+	add	src0=src0,r21	// setting up src pointer
+	add	dst0=dst0,r21	// setting up dest pointer
+	;;
+EX(.ex_handler, (p8)	st8	[dst1]=t3)	// store byte 3
+	mov	pr=saved_pr,-1
+	br.dptk.many .memcpy_short
+	;;
+
+/* code taken from copy_page_mck */
+.long_copy:
+	.rotr v[2*PREFETCH_DIST]
+	.rotp p[N]
+
+	mov src_pre_mem = src0
+	mov pr.rot = 0x10000
+	mov ar.ec = 1				// special unrolled loop
+
+	mov dst_pre_mem = dst0
+
+	add src_pre_l2 = 8*8, src0
+	add dst_pre_l2 = 8*8, dst0
+	;;
+	add src0 = 8, src_pre_mem		// first t1 src
+	mov ar.lc = 2*PREFETCH_DIST - 1
+	shr.u cnt=in2,7				// number of lines
+	add src1 = 3*8, src_pre_mem		// first t3 src
+	add dst0 = 8, dst_pre_mem		// first t1 dst
+	add dst1 = 3*8, dst_pre_mem		// first t3 dst
+	;;
+	and tmp=127,in2				// remaining bytes after this block
+	add cnt = -(2*PREFETCH_DIST) - 1, cnt
+	// same as .line_copy loop, but with all predicated-off instructions removed:
+.prefetch_loop:
+EX(.ex_handler_lcpy, (p[A])	ld8 v[A] = [src_pre_mem], 128)		// M0
+EK(.ex_handler_lcpy, (p[B])	st8 [dst_pre_mem] = v[B], 128)		// M2
+	br.ctop.sptk .prefetch_loop
+	;;
+	cmp.eq p16, p0 = r0, r0			// reset p16 to 1
+	mov ar.lc = cnt
+	mov ar.ec = N				// # of stages in pipeline
+	;;
+.line_copy:
+EX(.ex_handler,	(p[D])	ld8 t2 = [src0], 3*8)			// M0
+EK(.ex_handler,	(p[D])	ld8 t4 = [src1], 3*8)			// M1
+EX(.ex_handler_lcpy,	(p[B])	st8 [dst_pre_mem] = v[B], 128)		// M2 prefetch dst from memory
+EK(.ex_handler_lcpy,	(p[D])	st8 [dst_pre_l2] = n8, 128)		// M3 prefetch dst from L2
+	;;
+EX(.ex_handler_lcpy,	(p[A])	ld8 v[A] = [src_pre_mem], 128)		// M0 prefetch src from memory
+EK(.ex_handler_lcpy,	(p[C])	ld8 n8 = [src_pre_l2], 128)		// M1 prefetch src from L2
+EX(.ex_handler,	(p[D])	st8 [dst0] =  t1, 8)			// M2
+EK(.ex_handler,	(p[D])	st8 [dst1] =  t3, 8)			// M3
+	;;
+EX(.ex_handler,	(p[D])	ld8  t5 = [src0], 8)
+EK(.ex_handler,	(p[D])	ld8  t7 = [src1], 3*8)
+EX(.ex_handler,	(p[D])	st8 [dst0] =  t2, 3*8)
+EK(.ex_handler,	(p[D])	st8 [dst1] =  t4, 3*8)
+	;;
+EX(.ex_handler,	(p[D])	ld8  t6 = [src0], 3*8)
+EK(.ex_handler,	(p[D])	ld8 t10 = [src1], 8)
+EX(.ex_handler,	(p[D])	st8 [dst0] =  t5, 8)
+EK(.ex_handler,	(p[D])	st8 [dst1] =  t7, 3*8)
+	;;
+EX(.ex_handler,	(p[D])	ld8  t9 = [src0], 3*8)
+EK(.ex_handler,	(p[D])	ld8 t11 = [src1], 3*8)
+EX(.ex_handler,	(p[D])	st8 [dst0] =  t6, 3*8)
+EK(.ex_handler,	(p[D])	st8 [dst1] = t10, 8)
+	;;
+EX(.ex_handler,	(p[D])	ld8 t12 = [src0], 8)
+EK(.ex_handler,	(p[D])	ld8 t14 = [src1], 8)
+EX(.ex_handler,	(p[D])	st8 [dst0] =  t9, 3*8)
+EK(.ex_handler,	(p[D])	st8 [dst1] = t11, 3*8)
+	;;
+EX(.ex_handler,	(p[D])	ld8 t13 = [src0], 4*8)
+EK(.ex_handler,	(p[D])	ld8 t15 = [src1], 4*8)
+EX(.ex_handler,	(p[D])	st8 [dst0] = t12, 8)
+EK(.ex_handler,	(p[D])	st8 [dst1] = t14, 8)
+	;;
+EX(.ex_handler,	(p[C])	ld8  t1 = [src0], 8)
+EK(.ex_handler,	(p[C])	ld8  t3 = [src1], 8)
+EX(.ex_handler,	(p[D])	st8 [dst0] = t13, 4*8)
+EK(.ex_handler,	(p[D])	st8 [dst1] = t15, 4*8)
+	br.ctop.sptk .line_copy
+	;;
+
+	add dst0=-8,dst0
+	add src0=-8,src0
+	mov in2=tmp
+	br.sptk.many .medium_copy
+	;;
+
+#define BLOCK_SIZE	128*32
+#define blocksize	r23
+#define curlen		r24
+
+// dest is on 8-byte boundary, src is not. We need to do
+// ld8-ld8, shrp, then st8.  Max 8 byte copy per cycle.
+.unaligned_src:
+	.prologue
+	.save ar.pfs, saved_pfs
+	alloc	saved_pfs=ar.pfs,3,5,0,8
+	.save ar.lc, saved_lc
+	mov	saved_lc=ar.lc
+	.save pr, saved_pr
+	mov	saved_pr=pr
+
+	.body
+.4k_block:
+	mov	saved_in0=dst0	// need to save all input arguments
+	mov	saved_in2=in2
+	mov	blocksize=BLOCK_SIZE
+	;;
+	cmp.lt	p6,p7=blocksize,in2
+	mov	saved_in1=src0
+	;;
+(p6)	mov	in2=blocksize
+	;;
+	shr.u	r21=in2,7	// this much cache line
+	shr.u	r22=in2,4	// number of 16-byte iteration
+	and	curlen=15,in2	// copy length after iteration
+	and	r30=7,src0	// source alignment
+	;;
+	cmp.lt	p7,p8=1,r21
+	add	cnt=-1,r21
+	;;
+
+	add	src_pre_mem=0,src0	// prefetch src pointer
+	add	dst_pre_mem=0,dst0	// prefetch dest pointer
+	and	src0=-8,src0		// 1st src pointer
+(p7)	mov	ar.lc = r21
+(p8)	mov	ar.lc = r0
+	;;
+	.align 32
+1:	lfetch.fault	  [src_pre_mem], 128
+	lfetch.fault.excl [dst_pre_mem], 128
+	br.cloop.dptk.few 1b
+	;;
+
+	.body
+	shladd	dst1=r22,3,dst0	// 2nd dest pointer
+	shladd	src1=r22,3,src0	// 2nd src pointer
+	cmp.eq	p8,p9=r22,r0	// do we really need to loop?
+	cmp.le	p6,p7=8,curlen;	// have at least 8 byte remaining?
+	add	cnt=-1,r22	// ctop iteration adjustment
+	;;
+EX(.ex_handler, (p9)	ld8	r33=[src0],8)	// loop primer
+EK(.ex_handler, (p9)	ld8	r37=[src1],8)
+(p8)	br.dpnt.few .noloop
+	;;
+
+// The jump address is calculated based on src alignment. The COPYU
+// macro below need to confine its size to power of two, so an entry
+// can be caulated using shl instead of an expensive multiply. The
+// size is then hard coded by the following #define to match the
+// actual size.  This make it somewhat tedious when COPYU macro gets
+// changed and this need to be adjusted to match.
+#define LOOP_SIZE 6
+1:
+	mov	r29=ip		// jmp_table thread
+	mov	ar.lc=cnt
+	;;
+	add	r29=.jump_table - 1b - (.jmp1-.jump_table), r29
+	shl	r28=r30, LOOP_SIZE	// jmp_table thread
+	mov	ar.ec=2		// loop setup
+	;;
+	add	r29=r29,r28		// jmp_table thread
+	cmp.eq	p16,p17=r0,r0
+	;;
+	mov	b6=r29			// jmp_table thread
+	;;
+	br.cond.sptk.few b6
+
+// for 8-15 byte case
+// We will skip the loop, but need to replicate the side effect
+// that the loop produces.
+.noloop:
+EX(.ex_handler, (p6)	ld8	r37=[src1],8)
+	nop.m	0
+(p6)	shl	r25=r30,3
+	;;
+EX(.ex_handler, (p6)	ld8	r27=[src1])
+(p6)	shr.u	r28=r37,r25
+(p6)	sub	r26=64,r25
+	;;
+(p6)	shl	r27=r27,r26
+	;;
+(p6)	or	r21=r28,r27
+
+.unaligned_src_tail:
+/* check if we have more than blocksize to copy, if so go back */
+	cmp.gt	p8,p0=saved_in2,blocksize
+	;;
+(p8)	add	dst0=saved_in0,blocksize
+(p8)	add	src0=saved_in1,blocksize
+(p8)	sub	in2=saved_in2,blocksize
+(p8)	br.dpnt	.4k_block
+	;;
+
+/* we have up to 15 byte to copy in the tail.
+ * part of work is already done in the jump table code
+ * we are at the following state.
+ * src side:
+ *
+ *   xxxxxx xx                   <----- r21 has xxxxxxxx already
+ * -------- -------- --------
+ * 0        8        16
+ *          ^
+ *          |
+ *          src1
+ *
+ * dst
+ * -------- -------- --------
+ * ^
+ * |
+ * dst1
+ */
+EX(.ex_handler, (p6)	st8	[dst1]=r21,8)	// more than 8 byte to copy
+(p6)	add	curlen=-8,curlen	// update length
+	mov	ar.pfs=saved_pfs
+	;;
+	mov	ar.lc=saved_lc
+	mov	pr=saved_pr,-1
+	mov	in2=curlen	// remaining length
+	mov	dst0=dst1	// dest pointer
+	add	src0=src1,r30	// forward by src alignment
+	;;
+
+// 7 byte or smaller.
+.memcpy_short:
+	cmp.le	p8,p9   = 1,in2
+	cmp.le	p10,p11 = 2,in2
+	cmp.le	p12,p13 = 3,in2
+	cmp.le	p14,p15 = 4,in2
+	add	src1=1,src0	// second src pointer
+	add	dst1=1,dst0	// second dest pointer
+	;;
+
+EX(.ex_handler_short, (p8)	ld1	t1=[src0],2)
+EK(.ex_handler_short, (p10)	ld1	t2=[src1],2)
+(p9)	br.ret.dpnt rp		// 0 byte copy
+	;;
+
+EX(.ex_handler_short, (p8)	st1	[dst0]=t1,2)
+EK(.ex_handler_short, (p10)	st1	[dst1]=t2,2)
+(p11)	br.ret.dpnt rp		// 1 byte copy
+
+EX(.ex_handler_short, (p12)	ld1	t3=[src0],2)
+EK(.ex_handler_short, (p14)	ld1	t4=[src1],2)
+(p13)	br.ret.dpnt rp		// 2 byte copy
+	;;
+
+	cmp.le	p6,p7   = 5,in2
+	cmp.le	p8,p9   = 6,in2
+	cmp.le	p10,p11 = 7,in2
+
+EX(.ex_handler_short, (p12)	st1	[dst0]=t3,2)
+EK(.ex_handler_short, (p14)	st1	[dst1]=t4,2)
+(p15)	br.ret.dpnt rp		// 3 byte copy
+	;;
+
+EX(.ex_handler_short, (p6)	ld1	t5=[src0],2)
+EK(.ex_handler_short, (p8)	ld1	t6=[src1],2)
+(p7)	br.ret.dpnt rp		// 4 byte copy
+	;;
+
+EX(.ex_handler_short, (p6)	st1	[dst0]=t5,2)
+EK(.ex_handler_short, (p8)	st1	[dst1]=t6,2)
+(p9)	br.ret.dptk rp		// 5 byte copy
+
+EX(.ex_handler_short, (p10)	ld1	t7=[src0],2)
+(p11)	br.ret.dptk rp		// 6 byte copy
+	;;
+
+EX(.ex_handler_short, (p10)	st1	[dst0]=t7,2)
+	br.ret.dptk rp		// done all cases
+
+
+/* Align dest to nearest 8-byte boundary. We know we have at
+ * least 7 bytes to copy, enough to crawl to 8-byte boundary.
+ * Actual number of byte to crawl depend on the dest alignment.
+ * 7 byte or less is taken care at .memcpy_short
+
+ * src0 - source even index
+ * src1 - source  odd index
+ * dst0 - dest even index
+ * dst1 - dest  odd index
+ * r30  - distance to 8-byte boundary
+ */
+
+.align_dest:
+EX(.ex_handler_short, (p6)	ld1	t1=[src0],2)
+	cmp.le	p7,p0 = 2,r30	// for .align_dest
+	cmp.le	p8,p0 = 3,r30	// for .align_dest
+	cmp.le	p9,p0 = 4,r30	// for .align_dest
+	cmp.le	p10,p0 = 5,r30
+	cmp.le	p11,p0 = 6,r30
+	;;
+EX(.ex_handler_short, (p7)	ld1	t2=[src1],2)
+EK(.ex_handler_short, (p8)	ld1	t3=[src0],2)
+	cmp.le	p12,p0 = 7,r30
+EX(.ex_handler_short, (p6)	st1	[dst0] = t1,2)
+	nop.m	0
+	nop.i	0
+	;;
+EX(.ex_handler_short, (p9)	ld1	t4=[src1],2)
+EK(.ex_handler_short, (p10)	ld1	t5=[src0],2)
+EX(.ex_handler_short, (p7)	st1	[dst1] = t2,2)
+EK(.ex_handler_short, (p8)	st1	[dst0] = t3,2)
+	;;
+EX(.ex_handler_short, (p11)	ld1	t6=[src1],2)
+EK(.ex_handler_short, (p12)	ld1	t7=[src0],2)
+	cmp.eq	p6,p7=r28,r29
+EX(.ex_handler_short, (p9)	st1	[dst1] = t4,2)
+EK(.ex_handler_short, (p10)	st1	[dst0] = t5,2)
+	sub	in2=in2,r30
+	;;
+EX(.ex_handler_short, (p11)	st1	[dst1] = t6,2)
+EK(.ex_handler_short, (p12)	st1	[dst0] = t7)
+	add	dst0=in0,r30	// setup arguments
+	add	src0=in1,r30
+(p6)	br.cond.dptk .aligned_src
+(p7)	br.cond.dpnt .unaligned_src
+	;;
+
+/* main loop body in jump table format */
+#define COPYU(shift)									\
+1:											\
+EX(.ex_handler,  (p16)	ld8	r32=[src0],8);		/* 1 */				\
+EK(.ex_handler,  (p16)	ld8	r36=[src1],8);						\
+		 (p17)	shrp	r35=r33,r34,shift;;	/* 1 */				\
+EX(.ex_handler,  (p6)	ld8	r22=[src1]);	/* common, prime for tail section */	\
+		 nop.m	0;								\
+		 (p16)	shrp	r38=r36,r37,shift;					\
+EX(.ex_handler,  (p17)	st8	[dst0]=r35,8);		/* 1 */				\
+EK(.ex_handler,  (p17)	st8	[dst1]=r39,8);						\
+		 br.ctop.dptk.few 1b;;							\
+		 (p7)	add	src1=-8,src1;	/* back out for <8 byte case */		\
+		 shrp	r21=r22,r38,shift;	/* speculative work */			\
+		 br.sptk.few .unaligned_src_tail /* branch out of jump table */		\
+		 ;;
+	.align 32
+.jump_table:
+	COPYU(8)	// unaligned cases
+.jmp1:
+	COPYU(16)
+	COPYU(24)
+	COPYU(32)
+	COPYU(40)
+	COPYU(48)
+	COPYU(56)
+
+#undef A
+#undef B
+#undef C
+#undef D
+
+/*
+ * Due to lack of local tag support in assembler, it is not clear which
+ * instruction failed in the bundle.  The exception algorithm is that we
+ * first figure out the faulting address, then detect if there is any
+ * progress made on the copy, if so, redo the copy from last known copied
+ * location up to the faulting address (exclusive). In the copy_from_user
+ * case, remaining byte in kernel buffer will be zeroed.
+ *
+ * Take copy_from_user as an example, in the code there are multiple loads
+ * in a bundle and those multiple loads could span over two pages, the
+ * faulting address is calculated as page_round_down(max(src0, src1)).
+ * This is based on knowledge that if we can access one byte in a page, we
+ * can access any byte in that page.
+ *
+ * predicate used in the exception handler:
+ * p6-p7: direction
+ * p10-p11: src faulting addr calculation
+ * p12-p13: dst faulting addr calculation
+ */
+
+#define A	r19
+#define B	r20
+#define C	r21
+#define D	r22
+#define F	r28
+
+#define memset_arg0	r32
+#define memset_arg2	r33
+
+#define saved_retval	loc0
+#define saved_rtlink	loc1
+#define saved_pfs_stack	loc2
+
+.ex_handler_lcpy:
+	// in long copy block, the preload addresses should always ahead
+	// of the other two src/det pointers.  Furthermore, src1/dst1 should
+	// always ahead of src0/dst0.
+	cmp.ltu	p10,p11=src_pre_l2,src_pre_mem
+	cmp.ltu	p12,p13=dst_pre_l2,dst_pre_mem
+	;;
+(p10)	mov	src1=src_pre_mem
+(p11)	mov	src1=src_pre_l2
+(p12)	mov	dst1=dst_pre_mem
+(p13)	mov	dst1=dst_pre_l2
+	;;
+.ex_handler:
+	mov	pr=saved_pr,-1		// first restore pr, lc, and pfs
+	mov	ar.lc=saved_lc
+	mov	ar.pfs=saved_pfs
+	;;
+.ex_handler_short: // fault occurred in these sections didn't change pr, lc, pfs
+	cmp.ltu	p6,p7=saved_in0, saved_in1	// get the copy direction
+	cmp.ltu	p10,p11=src0,src1
+	cmp.ltu	p12,p13=dst0,dst1
+	mov	tmp = dst0
+	;;
+(p11)	mov	src1 = src0		// pick the larger of the two
+(p13)	mov	dst0 = dst1		// make dst0 the smaller one
+(p13)	mov	dst1 = tmp		// and dst1 the larger one
+	;;
+(p6)	dep	F = r0,dst1,0,PAGE_SHIFT // usr dst round down to page boundary
+(p7)	dep	F = r0,src1,0,PAGE_SHIFT // usr src round down to page boundary
+	;;
+(p6)	cmp.le	p14,p0=F,saved_in0	// bad address to start with
+(p7)	cmp.le	p14,p0=F,saved_in1	// here too
+	mov	retval=saved_in2
+(p14)	br.ret.sptk.many rp
+
+/*
+ * The remaining byte to copy is calculated as:
+ *
+ * A =	(faulting_addr - orig_src)	-> len to faulting ld address
+ *	or
+ * 	(faulting_addr - orig_dst)	-> len to faulting st address
+ * B =	(cur_dst - orig_dst)		-> len copied so far
+ * C =	A - B				-> len need to be copied
+ * D =	orig_len - A			-> len need to be zeroed
+ */
+(p6)	sub	A = F, saved_in0
+(p7)	sub	A = F, saved_in1
+	clrrrb
+	;;
+	alloc	saved_pfs_stack=ar.pfs,3,3,3,0
+	sub	B = dst0, saved_in0	// how many byte copied so far
+	;;
+	sub	C = A, B
+	sub	D = saved_in2, A
+	;;
+	cmp.gt	p8,p0=C,r0		// more than 1 byte?
+	add	memset_arg0=saved_in0, A
+(p6)	mov	memset_arg2=0		// copy_to_user should not call memset
+(p7)	mov	memset_arg2=D		// copy_from_user need to have kbuf zeroed
+	mov	saved_retval = D
+	mov	saved_rtlink = b0
+
+	add	out0=saved_in0, B
+	add	out1=saved_in1, B
+	mov	out2=C
+	mov	r8=0
+(p8)	br.call.sptk.few b0=__copy_user	// recursive call
+	;;
+
+	add	saved_retval=saved_retval,r8	// above might return non-zero value
+	cmp.gt	p8,p0=memset_arg2,r0	// more than 1 byte?
+	mov	out0=memset_arg0	// *s
+	mov	out1=r0			// c
+	mov	out2=memset_arg2	// n
+(p8)	br.call.sptk.few b0=memset
+	;;
+
+	mov	retval=saved_retval
+	mov	ar.pfs=saved_pfs_stack
+	mov	b0=saved_rtlink
+	br.ret.sptk.many rp
+END(__copy_user)
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/lib/page_valid.S linux/arch/ia64/lib/page_valid.S
--- ../prev/linux/arch/ia64/lib/page_valid.S	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/lib/page_valid.S	Fri Feb  8 07:42:53 2002
@@ -0,0 +1,33 @@
+/*
+ * Simple routine to check if an address is valid or not. Currently
+ * used for validating struct page pointers.
+ *
+ * Inputs:
+ * 	in0:	address to validate
+ * Output:
+ *	1 if address valid, 0 if not
+ *
+ * Copyright (C) 2000-2001 Hewlett-Packard Co
+ *	John Marvin <jsm@fc.hp.com>
+ */
+#include <linux/config.h>
+
+#include <asm/asmmacro.h>
+
+#define saved_pfs r11
+
+GLOBAL_ENTRY(ia64_page_valid)
+	.prologue
+	.save ar.pfs, saved_pfs
+	alloc	saved_pfs=ar.pfs,2,0,0,0
+	.body
+
+	EX(.Laddr_invalid, ld8 r14 = [in0])
+	;;
+	addl r8 = 1, r0
+	br.ret.sptk.many rp
+	;;
+.Laddr_invalid:
+	mov r8 = r0
+	br.ret.sptk.many rp
+END(ia64_page_valid)
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/mm/fault.c linux/arch/ia64/mm/fault.c
--- ../prev/linux/arch/ia64/mm/fault.c	Tue Jul  9 18:03:52 2002
+++ linux/arch/ia64/mm/fault.c	Mon Jun 10 08:38:30 2002
@@ -58,16 +58,14 @@
 	if (in_interrupt() || !mm)
 		goto no_context;
 
-#ifdef CONFIG_VIRTUAL_MEM_MAP
-	/*
-	 * If fault is in region 5 and we are in the kernel, we may already
+	/* If fault is in region 5 and we are in the kernel, we may already 
          * have the mmap_sem (VALID_PAGE macro is called during mmap). There
 	 * should be no vma for region 5 addr's anyway, so skip getting the
 	 * semaphore and go directly to the code that handles a bad area.
   	 */
+	
 	if ((REGION_NUMBER(address) == 5) && !user_mode(regs))
 		goto bad_area_no_up;
-#endif
 
 	down_read(&mm->mmap_sem);
 
@@ -148,9 +146,8 @@
 
   bad_area:
 	up_read(&mm->mmap_sem);
-#ifdef CONFIG_VIRTUAL_MEM_MAP
+
   bad_area_no_up:
-#endif
 	if ((isr & IA64_ISR_SP)
 	    || ((isr & IA64_ISR_NA) && (isr & IA64_ISR_CODE_MASK) == IA64_ISR_CODE_LFETCH))
 	{
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/mm/init.c linux/arch/ia64/mm/init.c
--- ../prev/linux/arch/ia64/mm/init.c	Tue Jul  9 18:03:52 2002
+++ linux/arch/ia64/mm/init.c	Wed May 15 10:15:03 2002
@@ -33,16 +33,15 @@
 
 extern void ia64_tlb_init (void);
 
-unsigned long MAX_DMA_ADDRESS = PAGE_OFFSET + 0x100000000UL;
+#define LARGE_GAP 0x40000000 /* Use virtual mem map if a hole is > than this */
+
+static unsigned long num_dma_physpages;
 
 static unsigned long totalram_pages;
 
-#ifdef CONFIG_VIRTUAL_MEM_MAP
 unsigned long vmalloc_end = VMALLOC_END_INIT;
 
 static struct page *vmem_map;
-static unsigned long num_dma_physpages;
-#endif
 
 int
 do_check_pgt_cache (int low, int high)
@@ -342,10 +341,6 @@
 	ia64_tlb_init();
 }
 
-#ifdef CONFIG_VIRTUAL_MEM_MAP
-
-#include <asm/pgtable.h>
-
 static int
 create_mem_map_page_table (u64 start, u64 end, void *arg)
 {
@@ -355,12 +350,12 @@
 	pmd_t *pmd;
 	pte_t *pte;
 	void *page;
-
+ 
 	/* should we use platform_map_nr here? */
 
 	map_start = vmem_map + MAP_NR_DENSE(start);
 	map_end   = vmem_map + MAP_NR_DENSE(end);
-
+ 
 	start_page = (unsigned long) map_start & PAGE_MASK;
 	end_page = PAGE_ALIGN((unsigned long) map_end);
 
@@ -387,35 +382,54 @@
  	return 0;
 }
 
+struct vmmi_callback_data {
+	memmap_init_callback_t *callback;
+	struct page *min_start;
+	struct page *max_end;
+};
+
 static int
 virtual_memmap_init (u64 start, u64 end, void *arg)
 {
 	struct page *map_start, *map_end;
+	struct vmmi_callback_data *vmmi_datap 
+                = (struct vmmi_callback_data *)arg;
 
 	/* Should we use platform_map_nr here? */
 
-	map_start = vmem_map + MAP_NR_DENSE(start);
-	map_end   = vmem_map + MAP_NR_DENSE(end);
+	map_start = mem_map + MAP_NR_DENSE(start);
+	map_end   = mem_map + MAP_NR_DENSE(end);
 
-	/*
-	 * We initialize "out of bounds" struct page elements that fit completely on the
-	 * same pages that were allocated for the "in bounds" struct page elements.
-	 */
-	map_start -= ((unsigned long) map_start & (PAGE_SIZE - 1)) / sizeof(struct page);
-	map_end += ((PAGE_ALIGN((unsigned long) map_end) - (unsigned long) map_end)
-		    / sizeof(struct page));
+	/* We initialize "out of bounds" struct page elements that
+	 * fit completely on the same pages that were allocated for
+	 * the "in bounds" struct page elements. 
+	 */ 
+
+	map_start -= ((unsigned long) map_start & (PAGE_SIZE - 1)) 
+			/ sizeof(struct page);
+	map_end += (PAGE_ALIGN((unsigned long) map_end)
+			- (unsigned long) map_end) / sizeof(struct page);
+
+	if (map_start < vmmi_datap->min_start)
+		map_start = vmmi_datap->min_start;
+	
+	if (map_end > vmmi_datap->max_end)
+		map_end = vmmi_datap->max_end;
 
-	(*(memmap_init_callback_t *)arg)(map_start,map_end);
+	(*(vmmi_datap->callback))(map_start,map_end);
 	return 0;
 }
 
-void
-arch_memmap_init (memmap_init_callback_t *callback, struct page *start, struct page *end)
-{
-	if ((start != vmem_map) || (end != vmem_map + max_low_pfn))
-		printk(KERN_WARNING "mem_map out of range!\n");
-
-	efi_memmap_walk(virtual_memmap_init, (void *) callback);
+void 
+arch_memmap_init(memmap_init_callback_t *callback,
+			struct page *start, struct page *end)
+{
+	struct vmmi_callback_data vmmi_data;
+
+	vmmi_data.callback = callback;
+	vmmi_data.min_start = start;
+	vmmi_data.max_end = end;
+	efi_memmap_walk(virtual_memmap_init,(void *)&vmmi_data);
 }
 
 struct zone_callback_data {
@@ -428,7 +442,7 @@
 };
 
 static int
-zone_init (u64 start, u64 end, void *arg)
+zone_init(u64 start, u64 end, void *arg)
 {
 	struct page *map_start, *map_end;
 	struct zone_callback_data *cb_datap = (struct zone_callback_data *)arg;
@@ -436,29 +450,31 @@
 
 	/* Should we use platform_map_nr here? */
 
-	map_start = vmem_map + MAP_NR_DENSE(start);
-	map_end   = vmem_map + MAP_NR_DENSE(end);
+	map_start = mem_map + MAP_NR_DENSE(start);
+	map_end   = mem_map + MAP_NR_DENSE(end);
 
 	start_paddr = cb_datap->start_paddr;
-	if (map_start < cb_datap->start)
+	if (map_start < cb_datap->start) 
 		map_start = cb_datap->start;
-	else
+	else 
 		start_paddr += ((map_start - cb_datap->start) << PAGE_SHIFT);
 
 	if (map_end > cb_datap->end)
 		map_end = cb_datap->end;
 
 	if (map_start < map_end) {
-		(*(cb_datap->callback))(map_start, map_end, cb_datap->zone, start_paddr,
-					cb_datap->highmem_flag);
+		(*(cb_datap->callback))(map_start,map_end,cb_datap->zone,
+					start_paddr,cb_datap->highmem_flag);
 	}
 
 	return 0;
 }
 
-void
-arch_memmap_zone_init (memmap_zone_callback_t *callback, struct page *start, struct page *end,
-		       zone_t *zone, unsigned long start_paddr, int highmem_flag)
+void 
+arch_memmap_zone_init(memmap_zone_callback_t *callback,
+			struct page *start, struct page *end,
+			zone_t *zone, unsigned long start_paddr,
+			int highmem_flag)
 {
 	struct zone_callback_data cb_data;
 
@@ -473,33 +489,42 @@
 }
 
 static int
-count_dma_pages (u64 start, u64 end, void *arg)
+count_pages (u64 start, u64 end, void *arg)
 {
 	unsigned long *count = arg;
 
-	if (end <= MAX_DMA_ADDRESS)
-		*count += (end - start) >> PAGE_SHIFT;
+	*count += (end - start) >> PAGE_SHIFT;
 	return 0;
 }
 
-int
-ia64_page_valid (struct page *page)
+static int
+count_dma_pages (u64 start, u64 end, void *arg)
 {
-	char byte;
+	unsigned long *count = arg;
 
-	return __get_user(byte, (char *) page) == 0;
+	if (end <= MAX_DMA_ADDRESS)
+		*count += (end - start) >> PAGE_SHIFT;
+	return 0;
 }
 
-#endif /* CONFIG_VIRTUAL_MEM_MAP */
-
+#ifndef CONFIG_DISCONTIGMEM
 static int
-count_pages (u64 start, u64 end, void *arg)
+find_largest_hole(u64 start, u64 end, void *arg)
 {
-	unsigned long *count = arg;
+	u64 *max_gap = arg;
+	static u64 last_end = PAGE_OFFSET;
 
-	*count += (end - start) >> PAGE_SHIFT;
+	if (start < last_end)
+		printk("Oops! efi memmap table not ordered!\n");
+	else {
+		if (*max_gap < (start - last_end))
+			*max_gap = start - last_end;
+	}
+
+	last_end = end;
 	return 0;
 }
+#endif
 
 /*
  * Set up the page tables.
@@ -507,59 +532,64 @@
 void
 paging_init (void)
 {
-	unsigned long max_dma, zones_size[MAX_NR_ZONES];
+	unsigned long max_dma; 
+	unsigned long zones_size[MAX_NR_ZONES];
+	unsigned long zholes_size[MAX_NR_ZONES];
+#ifndef CONFIG_DISCONTIGMEM
+	unsigned long max_gap;
+#endif
 
 	/* initialize mem_map[] */
 
 	memset(zones_size, 0, sizeof(zones_size));
+	memset(zholes_size, 0, sizeof(zholes_size));
 
 	num_physpages = 0;
 	efi_memmap_walk(count_pages, &num_physpages);
 
-	max_dma = virt_to_phys((void *) MAX_DMA_ADDRESS) >> PAGE_SHIFT;
+	num_dma_physpages = 0;
+	efi_memmap_walk(count_dma_pages, &num_dma_physpages);
 
-#ifdef CONFIG_VIRTUAL_MEM_MAP
-	{
-		unsigned long zholes_size[MAX_NR_ZONES];
-		unsigned long map_size;
-
-		memset(zholes_size, 0, sizeof(zholes_size));
+	num_physpages = 0;
+	efi_memmap_walk(count_pages, &num_physpages);
 
-		num_dma_physpages = 0;
-		efi_memmap_walk(count_dma_pages, &num_dma_physpages);
+	max_dma = virt_to_phys((void *) MAX_DMA_ADDRESS) >> PAGE_SHIFT;
 
-		if (max_low_pfn < max_dma) {
-			zones_size[ZONE_DMA] = max_low_pfn;
-			zholes_size[ZONE_DMA] = max_low_pfn - num_dma_physpages;
-		} else {
-			zones_size[ZONE_DMA] = max_dma;
-			zholes_size[ZONE_DMA] = max_dma - num_dma_physpages;
-			if (num_physpages > num_dma_physpages) {
-				zones_size[ZONE_NORMAL] = max_low_pfn - max_dma;
-				zholes_size[ZONE_NORMAL] = ((max_low_pfn - max_dma)
-							    - (num_physpages - num_dma_physpages));
-			}
+	if (max_low_pfn < max_dma) {
+		zones_size[ZONE_DMA] = max_low_pfn;
+		zholes_size[ZONE_DMA] = max_low_pfn - num_dma_physpages;
+	}
+	else {
+		zones_size[ZONE_DMA] = max_dma;
+		zholes_size[ZONE_DMA] = max_dma - num_dma_physpages;
+		if (num_physpages > num_dma_physpages) {
+			zones_size[ZONE_NORMAL] = max_low_pfn - max_dma;
+			zholes_size[ZONE_NORMAL] = (max_low_pfn - max_dma)
+					- (num_physpages - num_dma_physpages);
 		}
+	}
+
+#ifdef CONFIG_DISCONTIGMEM
+	free_area_init_node(0,NULL,NULL,zones_size,0,zholes_size);
+#else
+	max_gap = 0;
+	efi_memmap_walk(find_largest_hole, (u64 *)&max_gap);
 
-		/* allocate virtual mem_map: */
+	if (max_gap < LARGE_GAP)
+	    	free_area_init_node(0,NULL,NULL,zones_size,0,zholes_size);
+	else {
+		unsigned long map_size;
 
+		/* allocate virtual mem_map */
+	
 		map_size = PAGE_ALIGN(max_low_pfn*sizeof(struct page));
 		vmalloc_end -= map_size;
 		vmem_map = (struct page *) vmalloc_end;
 		efi_memmap_walk(create_mem_map_page_table, 0);
-
-		free_area_init_node(0, NULL, vmem_map, zones_size, 0, zholes_size);
+		free_area_init_node(0,NULL,vmem_map,zones_size,0,zholes_size);
 		printk("Virtual mem_map starts at %p\n",mem_map);
-	}
-#else /* !CONFIG_VIRTUAL_MEM_MAP */
-	if (max_low_pfn < max_dma)
-		zones_size[ZONE_DMA] = max_low_pfn;
-	else {
-		zones_size[ZONE_DMA] = max_dma;
-		zones_size[ZONE_NORMAL] = max_low_pfn - max_dma;
-	}
-	free_area_init(zones_size);
-#endif /* !CONFIG_VIRTUAL_MEM_MAP */
+ 	}
+#endif
 }
 
 static int
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/arch/ia64/vmlinux.lds.S linux/arch/ia64/vmlinux.lds.S
--- ../prev/linux/arch/ia64/vmlinux.lds.S	Tue Jul  9 18:03:51 2002
+++ linux/arch/ia64/vmlinux.lds.S	Wed Jun 12 16:08:55 2002
@@ -13,6 +13,8 @@
   /DISCARD/ : {
 	*(.text.exit)
 	*(.data.exit)
+	*(*.text.exit)
+	*(*.data.exit)
 	*(.exitcall.exit)
 	*(.IA_64.unwind.text.exit)
 	*(.IA_64.unwind_info.text.exit)
@@ -40,8 +42,6 @@
 
   /* Read-only data */
 
-  __gp = ALIGN(16) + 0x200000;	/* gp must be 16-byte aligned for exc. table */
-
   /* Global data */
   _data = .;
 
@@ -129,6 +129,10 @@
 
   .data : AT(ADDR(.data) - PAGE_OFFSET)
 	{ *(.data) *(.gnu.linkonce.d*) CONSTRUCTORS }
+
+
+  . = ALIGN(16);
+  __gp = . + 0x200000;	/* gp must be 16-byte aligned for exc. table */
 
   .got : AT(ADDR(.got) - PAGE_OFFSET)
 	{ *(.got.plt) *(.got) }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/Config.help linux/drivers/acpi/Config.help
--- ../prev/linux/drivers/acpi/Config.help	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/Config.help	Fri May 31 11:41:56 2002
@@ -1,4 +1,4 @@
-CONFIG_ACPI
+CONFIG_ACPI_ENABLE
   Advanced Configuration and Power Interface (ACPI) support for 
   Linux requires an ACPI compliant platform (hardware/firmware),
   and assumes the presence of OS-directed configuration and power
@@ -12,6 +12,15 @@
   Management (APM) specification.  If both ACPI and APM support 
   are configured, whichever is loaded first shall be used.
   
+  Add "acpi=off" to the kernel command line to disable this feature.
+  (Try "man bootparam" or see the documentation of your boot loader 
+  about how to pass options to the kernel at boot time.)
+
+  Add "acpi=ht-only" to the kernel command line to limit ACPI 
+  support to processor enumeration only (see CONFIG_ACPI_HT_ONLY). 
+
+  ----------
+
   The ACPI SourceForge project contains the latest source code, 
   documentation, tools, mailing list subscription, and other 
   information.  This project is available at:
@@ -26,51 +35,25 @@
   available at:
     <http://www.acpi.info>
 
-CONFIG_ACPI_BOOT
-  This option enables the use of ACPI tables for obtaining various
-  boot-time configuration information such as system processors, 
-  memory, and interrupt routing.  
-  
-  ACPI tables supercede legacy BIOS interfaces.  For example, the 
-  Multiple APIC Description Table (MADT) defined by the ACPI 
-  Specification is a replacement for the MP Configuration Table 
-  defined by the MultiProcessor Specification (MPS).
-  
-  You can disable this feature on IA32 systems by adding "acpi_boot=off" 
-  to your kernel command line. (Try "man bootparam" or see the 
-  documentation of your boot loader about how to pass options to the 
-  kernel at boot time.)
-
-  IA64 systems do not support legacy BIOS interfaces and thus rely
-  on ACPI tables to boot the system.  No kernel command line options
-  are supported.
-  
-CONFIG_ACPI_INTERPRETER
-  The ACPI Interpreter (a.k.a. ACPI Core Subsystem) provides the 
-  fundamental services required to parse the ACPI namespace, evaluate
-  control methods, and manage ACPI hardware and events.  This 
-  subsystem exposes kernel interfaces allowing higher level software
-  to manipulate ACPI defined hardware and software interfaces.
-
-  Add "acpi=off" to the kernel command line to disable this feature.
-  (Try "man bootparam" or see the documentation of your boot loader 
-  about how to pass options to the kernel at boot time.)
-
-  Note that this option will enlarge your kernel by about 100K.
+CONFIG_ACPI_HT_ONLY
+  This option enables limited ACPI support -- just enough to 
+  enumerate processors from the ACPI Multiple APIC Description 
+  Table (MADT).  Note that ACPI supports both logical (e.g. Hyper-
+  Threading) and physical processors, where the MultiProcessor 
+  Specification (MPS) table only supports physical processors.
 
-CONFIG_ACPI_BUS
-  The ACPI Bus driver enumerates and manages devices in the ACPI 
-  namespace in a manner similar to other bus drivers (e.g. PCI).
-  All ACPI device drivers rely on its services. 
+  Full ACPI support (CONFIG_ACPI) is preferred.  Use this option 
+  only if you wish to limit ACPI's role to processor enumeration.
 
 CONFIG_ACPI_AC
   This driver adds support for the AC Adapter object, which indicates
-  whether a system is on AC, or not.  Typically, only laptops have
-  this object, since desktops are always on AC.
+  whether a system is on AC, or not.  Typically, only mobile systems 
+  have this object, since desktops are always on AC.
 
 CONFIG_ACPI_BATTERY
   This driver adds support for battery information through
-  /proc/acpi/battery. If you have a laptop with a battery, say Y.
+  /proc/acpi/battery. If you have a mobile system with a battery, 
+  say Y.
 
 CONFIG_ACPI_BUTTON
   This driver registers for events based on buttons, such as the
@@ -79,21 +62,10 @@
   down the system.  Until then, you can cat it, and see output when
   a button is pressed.
 
-CONFIG_ACPI_DEBUG
-  The ACPI driver can optionally report errors with a great deal
-  of verbosity. Saying Y enables these statements. This will increase
-  your kernel size by around 50K.
-
 CONFIG_ACPI_EC
   This driver is required on some systems for the proper operation of
-  the battery and thermal drivers.  If you are compiling for a laptop,
-  say Y.
-
-CONFIG_ACPI_PCI
-  This option enables ACPI-based enumeration and configuration of PCI 
-  root bridge devices, including PCI interrupt routing (_PRT) support.  
-  This is required on platforms that no longer support legacy tables 
-  (e.g. MPS/PIR) or have erroneous table entries.
+  the battery and thermal drivers.  If you are compiling for a 
+  mobile system, say Y.
 
 CONFIG_ACPI_PROCESSOR
   This driver installs ACPI as the idle handler for Linux, and uses
@@ -114,9 +86,8 @@
   This driver will enable your system to shut down using ACPI, and
   dump your ACPI DSDT table using /proc/acpi/dsdt.
 
-CONFIG_ACPI_SLEEP
-  Enables low-level sleep support, allowing the platform to enter
-  and exit the S1-S4 states.  Note that although the platform may
-  support this capability, full sleep support will not be viable
-  until drivers properly save/restore hardware context.  (In other
-  words, use at your own risk!)
+CONFIG_ACPI_DEBUG
+  The ACPI driver can optionally report errors with a great deal
+  of verbosity. Saying Y enables these statements. This will increase
+  your kernel size by around 50K.
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/Config.in linux/drivers/acpi/Config.in
--- ../prev/linux/drivers/acpi/Config.in	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/Config.in	Fri May 31 11:41:56 2002
@@ -1,40 +1,118 @@
 #
 # ACPI Configuration
 #
+
 if [ "$CONFIG_X86" = "y" ]; then
+
   mainmenu_option next_comment
   comment 'ACPI Support'
-  dep_bool       'ACPI Support' 	CONFIG_ACPI $CONFIG_PCI
-  if [ "$CONFIG_ACPI" = "y" ]; then
+
+  if [ "$CONFIG_X86_LOCAL_APIC" = "y" ]; then
+    choice 'ACPI Support' \
+      "Enable			CONFIG_ACPI_ENABLE \
+       HyperThreading-Only	CONFIG_ACPI_HT_ONLY \
+       Disable			CONFIG_ACPI_DISABLE" Disable
+  else
+    choice 'ACPI Support' \
+      "Enable			CONFIG_ACPI_ENABLE \
+       Disable			CONFIG_ACPI_DISABLE" Disable
+  fi
+
+  if [ "$CONFIG_ACPI_ENABLE" = "y" ]; then
+    define_bool CONFIG_ACPI		y
     define_bool CONFIG_ACPI_BOOT 	y
-    define_bool CONFIG_ACPI_BUS 	y
-    define_bool CONFIG_ACPI_EC		y
+    define_bool	CONFIG_ACPI_BUS		y
     define_bool CONFIG_ACPI_INTERPRETER y
-    define_bool CONFIG_ACPI_PCI 	y
+    define_bool CONFIG_ACPI_EC		y
     define_bool CONFIG_ACPI_POWER 	y
+    if [ "$CONFIG_PCI" = "y" ]; then
+      define_bool CONFIG_ACPI_PCI 	y
+    fi
     define_bool CONFIG_ACPI_SLEEP 	y
     define_bool CONFIG_ACPI_SYSTEM 	y
-    tristate     '  AC Adapter' 	CONFIG_ACPI_AC		
-    tristate     '  Battery'		CONFIG_ACPI_BATTERY	
+    tristate     '  AC Adapter' 	CONFIG_ACPI_AC
+    tristate     '  Battery'		CONFIG_ACPI_BATTERY
     tristate     '  Button'		CONFIG_ACPI_BUTTON
     tristate     '  Fan'		CONFIG_ACPI_FAN
     tristate     '  Processor'		CONFIG_ACPI_PROCESSOR
     dep_tristate '  Thermal Zone' CONFIG_ACPI_THERMAL $CONFIG_ACPI_PROCESSOR
     bool         '  Debug Statements' 	CONFIG_ACPI_DEBUG
   fi
+
+  if [ "$CONFIG_ACPI_HT_ONLY" = "y" ]; then
+    define_bool	CONFIG_ACPI		y
+    define_bool CONFIG_ACPI_BOOT	y
+    define_bool CONFIG_ACPI_BUS		n
+    define_bool CONFIG_ACPI_INTERPRETER n
+    define_bool CONFIG_ACPI_EC		n
+    define_bool CONFIG_ACPI_PCI		n
+    define_bool CONFIG_ACPI_POWER 	n
+    define_bool CONFIG_ACPI_SYSTEM 	n
+    define_bool CONFIG_ACPI_SLEEP 	n
+    define_bool CONFIG_ACPI_AC		n
+    define_bool CONFIG_ACPI_BATTERY	n
+    define_bool CONFIG_ACPI_BUTTON	n
+    define_bool CONFIG_ACPI_FAN		n
+    define_bool CONFIG_ACPI_PROCESSOR	n
+    define_bool CONFIG_ACPI_THERMAL	n
+    define_bool CONFIG_ACPI_DEBUG	n
+  fi
+
+  if [ "$CONFIG_ACPI_DISABLE" = "y" ]; then
+    define_bool	CONFIG_ACPI		n
+    define_bool CONFIG_ACPI_BOOT	n
+    define_bool CONFIG_ACPI_BUS		n
+    define_bool CONFIG_ACPI_INTERPRETER n
+    define_bool CONFIG_ACPI_EC		n
+    define_bool CONFIG_ACPI_PCI		n
+    define_bool CONFIG_ACPI_POWER 	n
+    define_bool CONFIG_ACPI_SYSTEM 	n
+    define_bool CONFIG_ACPI_SLEEP 	n
+    define_bool CONFIG_ACPI_AC		n
+    define_bool CONFIG_ACPI_BATTERY	n
+    define_bool CONFIG_ACPI_BUTTON	n
+    define_bool CONFIG_ACPI_FAN		n
+    define_bool CONFIG_ACPI_PROCESSOR	n
+    define_bool CONFIG_ACPI_THERMAL	n
+    define_bool CONFIG_ACPI_DEBUG	n
+  fi
+  
   endmenu
+
 fi
 
+
 if [ "$CONFIG_IA64" = "y" ]; then
+
+  if [ "$CONFIG_IA64_SGI_SN" = "y" ]; then
+    mainmenu_option next_comment
+    comment 'ACPI Support'
+    define_bool CONFIG_ACPI		y
+    define_bool CONFIG_ACPI_EFI		y
+    define_bool CONFIG_ACPI_BOOT	y
+    define_bool CONFIG_ACPI_BUS		n
+    define_bool CONFIG_ACPI_INTERPRETER n
+    define_bool CONFIG_ACPI_PCI		n
+    define_bool CONFIG_ACPI_POWER 	n
+    define_bool CONFIG_ACPI_SYSTEM 	n
+    define_bool CONFIG_ACPI_BUTTON	n
+    define_bool CONFIG_ACPI_FAN		n
+    define_bool CONFIG_ACPI_PROCESSOR	n
+    define_bool CONFIG_ACPI_THERMAL	n
+    endmenu
+  fi
+
   if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
     mainmenu_option next_comment
     comment 'ACPI Support'
+    if [ "$CONFIG_PCI" = "y" ]; then
+      define_bool CONFIG_ACPI_PCI 	y
+    fi
     define_bool CONFIG_ACPI		y
     define_bool CONFIG_ACPI_EFI		y
     define_bool CONFIG_ACPI_BOOT	y
     define_bool CONFIG_ACPI_BUS		y
     define_bool CONFIG_ACPI_INTERPRETER y
-    define_bool CONFIG_ACPI_PCI		y
     define_bool CONFIG_ACPI_POWER 	y
     define_bool CONFIG_ACPI_SYSTEM 	y
     tristate     '  Button'		CONFIG_ACPI_BUTTON
@@ -44,4 +122,5 @@
     bool         '  Debug Statements' 	CONFIG_ACPI_DEBUG
     endmenu
   fi
+
 fi
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/Makefile linux/drivers/acpi/Makefile
--- ../prev/linux/drivers/acpi/Makefile	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/Makefile	Fri May 31 11:41:56 2002
@@ -22,14 +22,14 @@
 # ACPI Boot-Time Table Parsing
 #
 ifeq ($(CONFIG_ACPI_BOOT),y)
-  obj-y		+= acpi_tables.o
+  obj-y		+= tables.o
 endif
 
 #
 # ACPI Core Subsystem (Interpreter)
 #
 ifeq ($(CONFIG_ACPI_INTERPRETER),y)
-  obj-y		+= acpi_osl.o acpi_utils.o
+  obj-y		+= osl.o utils.o
   subdir-y	+= dispatcher events executer hardware namespace parser \
 		   resources tables utilities
   obj-y 	+= $(foreach dir,$(subdir-y),$(dir)/$(dir).o)
@@ -39,17 +39,17 @@
 # ACPI Bus and Device Drivers
 #
 ifeq ($(CONFIG_ACPI_BUS),y)
-  obj-y				+= acpi_bus.o 
-  obj-$(CONFIG_ACPI_AC) 	+= acpi_ac.o
-  obj-$(CONFIG_ACPI_BATTERY)	+= acpi_battery.o
-  obj-$(CONFIG_ACPI_BUTTON)	+= acpi_button.o
-  obj-$(CONFIG_ACPI_EC)		+= acpi_ec.o
-  obj-$(CONFIG_ACPI_FAN)	+= acpi_fan.o
-  obj-$(CONFIG_ACPI_PCI)	+= acpi_pci_root.o acpi_pci_link.o
-  obj-$(CONFIG_ACPI_POWER)	+= acpi_power.o
-  obj-$(CONFIG_ACPI_PROCESSOR)	+= acpi_processor.o
-  obj-$(CONFIG_ACPI_THERMAL)	+= acpi_thermal.o
-  obj-$(CONFIG_ACPI_SYSTEM)	+= acpi_system.o
+  obj-y				+= bus.o 
+  obj-$(CONFIG_ACPI_AC) 	+= ac.o
+  obj-$(CONFIG_ACPI_BATTERY)	+= battery.o
+  obj-$(CONFIG_ACPI_BUTTON)	+= button.o
+  obj-$(CONFIG_ACPI_EC)		+= ec.o
+  obj-$(CONFIG_ACPI_FAN)	+= fan.o
+  obj-$(CONFIG_ACPI_PCI)	+= pci_root.o pci_link.o pci_irq.o pci_bind.o
+  obj-$(CONFIG_ACPI_POWER)	+= power.o
+  obj-$(CONFIG_ACPI_PROCESSOR)	+= processor.o
+  obj-$(CONFIG_ACPI_THERMAL)	+= thermal.o
+  obj-$(CONFIG_ACPI_SYSTEM)	+= system.o
 endif
 
 include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/ac.c linux/drivers/acpi/ac.c
--- ../prev/linux/drivers/acpi/ac.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/ac.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,352 @@
+/*
+ *  acpi_ac.c - ACPI AC Adapter Driver ($Revision: 23 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_AC_COMPONENT
+ACPI_MODULE_NAME		("acpi_ac")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_AC_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+int acpi_ac_add (struct acpi_device *device);
+int acpi_ac_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_ac_driver = {
+	name:			ACPI_AC_DRIVER_NAME,
+	class:			ACPI_AC_CLASS,
+	ids:			ACPI_AC_HID,
+	ops:			{
+					add:	acpi_ac_add,
+					remove:	acpi_ac_remove,
+				},
+};
+
+struct acpi_ac {
+	acpi_handle		handle;
+	unsigned long		state;
+};
+
+
+/* --------------------------------------------------------------------------
+                               AC Adapter Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_ac_get_state (
+	struct acpi_ac		*ac)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_get_state");
+
+	if (!ac)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(ac->handle, "_PSR", NULL, &ac->state);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error reading AC Adapter state\n"));
+		ac->state = ACPI_AC_STATUS_UNKNOWN;
+		return_VALUE(-ENODEV);
+	}
+	
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry		*acpi_ac_dir = NULL;
+
+static int
+acpi_ac_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_ac		*ac = (struct acpi_ac *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_read_state");
+
+	if (!ac || (off != 0))
+		goto end;
+
+	if (0 != acpi_ac_get_state(ac)) {
+		p += sprintf(p, "ERROR: Unable to read AC Adapter state\n");
+		goto end;
+	}
+
+	p += sprintf(p, "state:                   ");
+	switch (ac->state) {
+	case ACPI_AC_STATUS_OFFLINE:
+		p += sprintf(p, "off-line\n");
+		break;
+	case ACPI_AC_STATUS_ONLINE:
+		p += sprintf(p, "on-line\n");
+		break;
+	default:
+		p += sprintf(p, "unknown\n");
+		break;
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_ac_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_add_fs");
+
+	if (!acpi_ac_dir) {
+		acpi_ac_dir = proc_mkdir(ACPI_AC_CLASS, acpi_root_dir);
+		if (!acpi_ac_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_ac_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'state' [R] */
+	entry = create_proc_entry(ACPI_AC_FILE_STATE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_AC_FILE_STATE));
+	else {
+		entry->read_proc = acpi_ac_read_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_ac_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_ac_remove_fs");
+
+	if (!acpi_ac_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_ac_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                   Driver Model
+   -------------------------------------------------------------------------- */
+
+void
+acpi_ac_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_ac		*ac = (struct acpi_ac *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_notify");
+
+	if (!ac)
+		return;
+
+	if (0 != acpi_bus_get_device(ac->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_AC_NOTIFY_STATUS:
+		acpi_ac_get_state(ac);
+		acpi_bus_generate_event(device, event, (u32) ac->state);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+int
+acpi_ac_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_ac		*ac = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ac = kmalloc(sizeof(struct acpi_ac), GFP_KERNEL);
+	if (!ac)
+		return_VALUE(-ENOMEM);
+	memset(ac, 0, sizeof(struct acpi_ac));
+
+	ac->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_AC_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_AC_CLASS);
+	acpi_driver_data(device) = ac;
+
+	result = acpi_ac_get_state(ac);
+	if (0 != result)
+		goto end;
+
+	result = acpi_ac_add_fs(device);
+	if (0 != result)
+		goto end;
+
+	status = acpi_install_notify_handler(ac->handle,
+		ACPI_DEVICE_NOTIFY, acpi_ac_notify, ac);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", 
+		acpi_device_name(device), acpi_device_bid(device), 
+		ac->state?"on-line":"off-line");
+
+end:
+	if (0 != result) {
+		acpi_ac_remove_fs(device);
+		kfree(ac);
+	}
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_ac_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_ac		*ac = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	ac = (struct acpi_ac *) acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(ac->handle,
+		ACPI_DEVICE_NOTIFY, acpi_ac_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	acpi_ac_remove_fs(device);
+
+	kfree(ac);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_ac_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_init");
+
+	result = acpi_bus_register_driver(&acpi_ac_driver);
+	if (0 > result) {
+		remove_proc_entry(ACPI_AC_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_ac_exit (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ac_exit");
+
+	result = acpi_bus_unregister_driver(&acpi_ac_driver);
+	if (0 == result)
+		remove_proc_entry(ACPI_AC_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_ac_init);
+module_exit(acpi_ac_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_ac.c linux/drivers/acpi/acpi_ac.c
--- ../prev/linux/drivers/acpi/acpi_ac.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_ac.c	Wed Dec 31 17:00:00 1969
@@ -1,352 +0,0 @@
-/*
- *  acpi_ac.c - ACPI AC Adapter Driver ($Revision: 23 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_AC_COMPONENT
-ACPI_MODULE_NAME		("acpi_ac")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_AC_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-#define PREFIX			"ACPI: "
-
-
-int acpi_ac_add (struct acpi_device *device);
-int acpi_ac_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_ac_driver = {
-	name:			ACPI_AC_DRIVER_NAME,
-	class:			ACPI_AC_CLASS,
-	ids:			ACPI_AC_HID,
-	ops:			{
-					add:	acpi_ac_add,
-					remove:	acpi_ac_remove,
-				},
-};
-
-struct acpi_ac {
-	acpi_handle		handle;
-	unsigned long		state;
-};
-
-
-/* --------------------------------------------------------------------------
-                               AC Adapter Management
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_ac_get_state (
-	struct acpi_ac		*ac)
-{
-	acpi_status		status = AE_OK;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_get_state");
-
-	if (!ac)
-		return_VALUE(-EINVAL);
-
-	status = acpi_evaluate_integer(ac->handle, "_PSR", NULL, &ac->state);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error reading AC Adapter state\n"));
-		ac->state = ACPI_AC_STATUS_UNKNOWN;
-		return_VALUE(-ENODEV);
-	}
-	
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-struct proc_dir_entry		*acpi_ac_dir = NULL;
-
-static int
-acpi_ac_read_state (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_ac		*ac = (struct acpi_ac *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_read_state");
-
-	if (!ac || (off != 0))
-		goto end;
-
-	if (0 != acpi_ac_get_state(ac)) {
-		p += sprintf(p, "ERROR: Unable to read AC Adapter state\n");
-		goto end;
-	}
-
-	p += sprintf(p, "state:                   ");
-	switch (ac->state) {
-	case ACPI_AC_STATUS_OFFLINE:
-		p += sprintf(p, "off-line\n");
-		break;
-	case ACPI_AC_STATUS_ONLINE:
-		p += sprintf(p, "on-line\n");
-		break;
-	default:
-		p += sprintf(p, "unknown\n");
-		break;
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_ac_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_add_fs");
-
-	if (!acpi_ac_dir) {
-		acpi_ac_dir = proc_mkdir(ACPI_AC_CLASS, acpi_root_dir);
-		if (!acpi_ac_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_ac_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-
-	/* 'state' [R] */
-	entry = create_proc_entry(ACPI_AC_FILE_STATE,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_AC_FILE_STATE));
-	else {
-		entry->read_proc = acpi_ac_read_state;
-		entry->data = acpi_driver_data(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_ac_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_ac_remove_fs");
-
-	if (!acpi_ac_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_ac_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                   Driver Model
-   -------------------------------------------------------------------------- */
-
-void
-acpi_ac_notify (
-	acpi_handle		handle,
-	u32			event,
-	void			*data)
-{
-	struct acpi_ac		*ac = (struct acpi_ac *) data;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_notify");
-
-	if (!ac)
-		return;
-
-	if (0 != acpi_bus_get_device(ac->handle, &device))
-		return_VOID;
-
-	switch (event) {
-	case ACPI_AC_NOTIFY_STATUS:
-		acpi_ac_get_state(ac);
-		acpi_bus_generate_event(device, event, (u32) ac->state);
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
-		break;
-	}
-
-	return_VOID;
-}
-
-
-int
-acpi_ac_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_ac		*ac = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	ac = kmalloc(sizeof(struct acpi_ac), GFP_KERNEL);
-	if (!ac)
-		return_VALUE(-ENOMEM);
-	memset(ac, 0, sizeof(struct acpi_ac));
-
-	ac->handle = device->handle;
-	sprintf(acpi_device_name(device), "%s", ACPI_AC_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_AC_CLASS);
-	acpi_driver_data(device) = ac;
-
-	result = acpi_ac_get_state(ac);
-	if (0 != result)
-		goto end;
-
-	result = acpi_ac_add_fs(device);
-	if (0 != result)
-		goto end;
-
-	status = acpi_install_notify_handler(ac->handle,
-		ACPI_DEVICE_NOTIFY, acpi_ac_notify, ac);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error installing notify handler\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", 
-		acpi_device_name(device), acpi_device_bid(device), 
-		ac->state?"on-line":"off-line");
-
-end:
-	if (0 != result) {
-		acpi_ac_remove_fs(device);
-		kfree(ac);
-	}
-
-	return_VALUE(result);
-}
-
-
-int
-acpi_ac_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_ac		*ac = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	ac = (struct acpi_ac *) acpi_driver_data(device);
-
-	status = acpi_remove_notify_handler(ac->handle,
-		ACPI_DEVICE_NOTIFY, acpi_ac_notify);
-	if (ACPI_FAILURE(status))
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error removing notify handler\n"));
-
-	acpi_ac_remove_fs(device);
-
-	kfree(ac);
-
-	return_VALUE(0);
-}
-
-
-int __init
-acpi_ac_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_init");
-
-	result = acpi_bus_register_driver(&acpi_ac_driver);
-	if (0 > result) {
-		remove_proc_entry(ACPI_AC_CLASS, acpi_root_dir);
-		return_VALUE(-ENODEV);
-	}
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_ac_exit (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ac_exit");
-
-	result = acpi_bus_unregister_driver(&acpi_ac_driver);
-	if (0 == result)
-		remove_proc_entry(ACPI_AC_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
-
-
-module_init(acpi_ac_init);
-module_exit(acpi_ac_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_battery.c linux/drivers/acpi/acpi_battery.c
--- ../prev/linux/drivers/acpi/acpi_battery.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_battery.c	Wed Dec 31 17:00:00 1969
@@ -1,831 +0,0 @@
-/*
- *  acpi_battery.c - ACPI Battery Driver ($Revision: 32 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_BATTERY_COMPONENT
-ACPI_MODULE_NAME		("acpi_battery")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-#define PREFIX			"ACPI: "
-
-
-#define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
-
-#define ACPI_BATTERY_FORMAT_BIF	"NNNNNNNNNSSSS"
-#define ACPI_BATTERY_FORMAT_BST	"NNNN"
-
-static int acpi_battery_add (struct acpi_device *device);
-static int acpi_battery_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_battery_driver = {
-	name:			ACPI_BATTERY_DRIVER_NAME,
-	class:			ACPI_BATTERY_CLASS,
-	ids:			ACPI_BATTERY_HID,
-	ops:			{
-					add:	acpi_battery_add,
-					remove:	acpi_battery_remove,
-				},
-};
-
-struct acpi_battery_status {
-	acpi_integer		state;
-	acpi_integer		present_rate;
-	acpi_integer		remaining_capacity;
-	acpi_integer		present_voltage;
-};
-
-struct acpi_battery_info {
-	acpi_integer		power_unit;
-	acpi_integer		design_capacity;
-	acpi_integer		last_full_capacity;
-	acpi_integer		battery_technology;
-	acpi_integer		design_voltage;
-	acpi_integer		design_capacity_warning;
-	acpi_integer		design_capacity_low;
-	acpi_integer		battery_capacity_granularity_1;
-	acpi_integer		battery_capacity_granularity_2;
-	acpi_string		model_number;
-	acpi_string		serial_number;
-	acpi_string		battery_type;
-	acpi_string		oem_info;
-};
-
-struct acpi_battery_flags {
-	u8			present:1;	/* Bay occupied? */
-	u8			power_unit:1;	/* 0=watts, 1=apms */
-	u8			alarm:1;	/* _BTP present? */
-	u8			reserved:5;
-};
-
-struct acpi_battery_trips {
-	unsigned long		warning;
-	unsigned long		low;
-};
-
-struct acpi_battery {
-	acpi_handle		handle;
-	struct acpi_battery_flags flags;
-	struct acpi_battery_trips trips;
-	unsigned long		alarm;
-	struct acpi_battery_info *info;
-};
-
-
-/* --------------------------------------------------------------------------
-                               Battery Management
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_battery_get_info (
-	struct acpi_battery	*battery,
-	struct acpi_battery_info **bif)
-{
-	int			result = 0;
-	acpi_status 		status = 0;
-	acpi_buffer 		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_buffer		format = {sizeof(ACPI_BATTERY_FORMAT_BIF),
-						ACPI_BATTERY_FORMAT_BIF};
-	acpi_buffer		data = {0, NULL};
-	acpi_object 		*package = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_get_info");
-
-	if (!battery || !bif)
-		return_VALUE(-EINVAL);
-
-	/* Evalute _BIF */
-
-	status = acpi_evaluate_object(battery->handle, "_BIF", NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BIF\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	package = (acpi_object *) buffer.pointer;
-
-	/* Extract Package Data */
-
-	status = acpi_extract_package(package, &format, &data);
-	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	data.pointer = kmalloc(data.length, GFP_KERNEL);
-	if (!data.pointer) {
-		result = -ENOMEM;
-		goto end;
-	}
-	memset(data.pointer, 0, data.length);
-
-	status = acpi_extract_package(package, &format, &data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
-		kfree(data.pointer);
-		result = -ENODEV;
-		goto end;
-	}
-
-end:
-	kfree(buffer.pointer);
-
-	if (0 == result)
-		(*bif) = (struct acpi_battery_info *) data.pointer;
-
-	return_VALUE(result);
-}
-
-static int
-acpi_battery_get_status (
-	struct acpi_battery	*battery,
-	struct acpi_battery_status **bst)
-{
-	int			result = 0;
-	acpi_status 		status = 0;
-	acpi_buffer 		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_buffer		format = {sizeof(ACPI_BATTERY_FORMAT_BST),
-						ACPI_BATTERY_FORMAT_BST};
-	acpi_buffer		data = {0, NULL};
-	acpi_object 		*package = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_get_status");
-
-	if (!battery || !bst)
-		return_VALUE(-EINVAL);
-
-	/* Evalute _BST */
-
-	status = acpi_evaluate_object(battery->handle, "_BST", NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BST\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	package = (acpi_object *) buffer.pointer;
-
-	/* Extract Package Data */
-
-	status = acpi_extract_package(package, &format, &data);
-	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	data.pointer = kmalloc(data.length, GFP_KERNEL);
-	if (!data.pointer) {
-		result = -ENOMEM;
-		goto end;
-	}
-	memset(data.pointer, 0, data.length);
-
-	status = acpi_extract_package(package, &format, &data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
-		kfree(data.pointer);
-		result = -ENODEV;
-		goto end;
-	}
-
-end:
-	kfree(buffer.pointer);
-
-	if (0 == result)
-		(*bst) = (struct acpi_battery_status *) data.pointer;
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_battery_set_alarm (
-	struct acpi_battery	*battery,
-	unsigned long		alarm)
-{
-	acpi_status		status = 0;
-	acpi_object		arg0 = {ACPI_TYPE_INTEGER};
-	acpi_object_list	arg_list = {1, &arg0};
-
-	ACPI_FUNCTION_TRACE("acpi_battery_set_alarm");
-
-	if (!battery)
-		return_VALUE(-EINVAL);
-
-	if (!battery->flags.alarm)
-		return_VALUE(-ENODEV);
-
-	arg0.integer.value = alarm;
-
-	status = acpi_evaluate(battery->handle, "_BTP", &arg_list, NULL);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", (u32) alarm));
-
-	battery->alarm = alarm;
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_battery_check (
-	struct acpi_battery	*battery)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_handle		handle = NULL;
-	struct acpi_device	*device = NULL;
-	struct acpi_battery_info *bif = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_check");
-	
-	if (!battery)
-		return_VALUE(-EINVAL);
-
-	result = acpi_bus_get_device(battery->handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-
-	result = acpi_bus_get_status(device);
-	if (0 != result)
-		return_VALUE(result);
-
-	/* Insertion? */
-
-	if (!battery->flags.present && device->status.battery_present) {
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery inserted\n"));
-
-		/* Evalute _BIF to get certain static information */
-
-		result = acpi_battery_get_info(battery, &bif);
-		if (0 != result)
-			return_VALUE(result);
-
-		battery->flags.power_unit = bif->power_unit;
-		battery->trips.warning = bif->design_capacity_warning;
-		battery->trips.low = bif->design_capacity_low;
-		kfree(bif);
-
-		/* See if alarms are supported, and if so, set default */
-
-		status = acpi_get_handle(battery->handle, "_BTP", &handle);
-		if (ACPI_SUCCESS(status)) {
-			battery->flags.alarm = 1;
-			acpi_battery_set_alarm(battery, battery->trips.warning);
-		}
-	}
-
-	/* Removal? */
-
-	else if (battery->flags.present && !device->status.battery_present) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery removed\n"));
-	}
-
-	battery->flags.present = device->status.battery_present;
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-struct proc_dir_entry		*acpi_battery_dir = NULL;
-
-static int
-acpi_battery_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_battery	*battery = (struct acpi_battery *) data;
-	struct acpi_battery_info *bif = NULL;
-	char			*units = "?";
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_read_info");
-
-	if (!battery)
-		goto end;
-
-	if (battery->flags.present)
-		p += sprintf(p, "present:                 yes\n");
-	else {
-		p += sprintf(p, "present:                 no\n");
-		goto end;
-	}
-
-	/* Battery Info (_BIF) */
-
-	result = acpi_battery_get_info(battery, &bif);
-	if ((0 != result) || !bif) {
-		p += sprintf(p, "ERROR: Unable to read battery information\n");
-		goto end;
-	}
-
-	units = bif->power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
-					
-	if (bif->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
-		p += sprintf(p, "design capacity:         unknown\n");
-	else
-		p += sprintf(p, "design capacity:         %d %sh\n",
-			(u32) bif->design_capacity, units);
-
-	if (bif->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
-		p += sprintf(p, "last full capacity:      unknown\n");
-	else
-		p += sprintf(p, "last full capacity:      %d %sh\n",
-			(u32) bif->last_full_capacity, units);
-
-	switch ((u32) bif->battery_technology) {
-	case 0:
-		p += sprintf(p, "battery technology:      non-rechargeable\n");
-		break;
-	case 1:
-		p += sprintf(p, "battery technology:      rechargeable\n");
-		break;
-	default:
-		p += sprintf(p, "battery technology:      unknown\n");
-		break;
-	}
-
-	if (bif->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
-		p += sprintf(p, "design voltage:          unknown\n");
-	else
-		p += sprintf(p, "design voltage:          %d mV\n",
-			(u32) bif->design_voltage);
-	
-	p += sprintf(p, "design capacity warning: %d %sh\n",
-		(u32) bif->design_capacity_warning, units);
-	p += sprintf(p, "design capacity low:     %d %sh\n",
-		(u32) bif->design_capacity_low, units);
-	p += sprintf(p, "capacity granularity 1:  %d %sh\n",
-		(u32) bif->battery_capacity_granularity_1, units);
-	p += sprintf(p, "capacity granularity 2:  %d %sh\n",
-		(u32) bif->battery_capacity_granularity_2, units);
-	p += sprintf(p, "model number:            %s\n",
-		bif->model_number);
-	p += sprintf(p, "serial number:           %s\n",
-		bif->serial_number);
-	p += sprintf(p, "battery type:            %s\n",
-		bif->battery_type);
-	p += sprintf(p, "OEM info:                %s\n",
-		bif->oem_info);
-
-end:
-	kfree(bif);
-
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_battery_read_state (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_battery	*battery = (struct acpi_battery *) data;
-	struct acpi_battery_status *bst = NULL;
-	char			*units = "?";
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_read_state");
-
-	if (!battery)
-		goto end;
-
-	if (battery->flags.present)
-		p += sprintf(p, "present:                 yes\n");
-	else {
-		p += sprintf(p, "present:                 no\n");
-		goto end;
-	}
-
-	/* Battery Units */
-
-	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
-
-	/* Battery Status (_BST) */
-
-	result = acpi_battery_get_status(battery, &bst);
-	if ((0 != result) || !bst) {
-		p += sprintf(p, "ERROR: Unable to read battery status\n");
-		goto end;
-	}
-
-	if (!(bst->state & 0x04))
-		p += sprintf(p, "capacity state:          ok\n");
-	else
-		p += sprintf(p, "capacity state:          critical\n");
-
-	if ((bst->state & 0x01) && (bst->state & 0x02))
-		p += sprintf(p, "charging state:          charging/discharging\n");
-	else if (bst->state & 0x01)
-		p += sprintf(p, "charging state:          discharging\n");
-	else if (bst->state & 0x02)
-		p += sprintf(p, "charging state:          charging\n");
-	else
-		p += sprintf(p, "charging state:          unknown\n");
-
-	if (bst->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
-		p += sprintf(p, "present rate:            unknown\n");
-	else
-		p += sprintf(p, "present rate:            %d %s\n",
-			(u32) bst->present_rate, units);
-
-	if (bst->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
-		p += sprintf(p, "remaining capacity:      unknown\n");
-	else
-		p += sprintf(p, "remaining capacity:      %d %sh\n",
-			(u32) bst->remaining_capacity, units);
-
-	if (bst->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
-		p += sprintf(p, "present voltage:         unknown\n");
-	else
-		p += sprintf(p, "present voltage:         %d mV\n",
-			(u32) bst->present_voltage);
-
-end:
-	kfree(bst);
-
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_battery_read_alarm (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_battery	*battery = (struct acpi_battery *) data;
-	char			*units = "?";
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_read_alarm");
-
-	if (!battery)
-		goto end;
-
-	if (!battery->flags.present) {
-		p += sprintf(p, "present:                 no\n");
-		goto end;
-	}
-
-	/* Battery Units */
-	
-	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
-
-	/* Battery Alarm */
-
-	p += sprintf(p, "alarm:                   ");
-	if (!battery->alarm)
-		p += sprintf(p, "unsupported\n");
-	else
-		p += sprintf(p, "%d %sh\n", (u32) battery->alarm, units);
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_battery_write_alarm (
-	struct file		*file,
-	const char		*buffer,
-	unsigned long		count,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_battery	*battery = (struct acpi_battery *) data;
-	char			alarm_string[12] = {'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_battery_write_alarm");
-
-	if (!battery || (count > sizeof(alarm_string) - 1))
-		return_VALUE(-EINVAL);
-
-	if (!battery->flags.present)
-		return_VALUE(-ENODEV);
-
-	if (copy_from_user(alarm_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	alarm_string[count] = '\0';
-
-	result = acpi_battery_set_alarm(battery, 
-		simple_strtoul(alarm_string, NULL, 0));
-	if (0 != result)
-		return_VALUE(result);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_battery_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_add_fs");
-
-	if (!acpi_battery_dir) {
-		acpi_battery_dir = proc_mkdir(ACPI_BATTERY_CLASS, acpi_root_dir);
-		if (!acpi_battery_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_battery_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BATTERY_FILE_INFO));
-	else {
-		entry->read_proc = acpi_battery_read_info;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'status' [R] */
-	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BATTERY_FILE_STATUS));
-	else {
-		entry->read_proc = acpi_battery_read_state;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'alarm' [R/W] */
-	entry = create_proc_entry(ACPI_BATTERY_FILE_ALARM,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BATTERY_FILE_ALARM));
-	else {
-		entry->read_proc = acpi_battery_read_alarm;
-		entry->write_proc = acpi_battery_write_alarm;
-		entry->data = acpi_driver_data(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_battery_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_battery_remove_fs");
-
-	if (!acpi_battery_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Driver Interface
-   -------------------------------------------------------------------------- */
-
-static void
-acpi_battery_notify (
-	acpi_handle		handle,
-	u32			event,
-	void			*data)
-{
-	struct acpi_battery	*battery = (struct acpi_battery *) data;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_notify");
-
-	if (!battery)
-		return_VOID;
-
-	if (0 != acpi_bus_get_device(handle, &device))
-		return_VOID;
-
-	switch (event) {
-	case ACPI_BATTERY_NOTIFY_STATUS:
-	case ACPI_BATTERY_NOTIFY_INFO:
-		acpi_battery_check(battery);
-		acpi_bus_generate_event(device, event, battery->flags.present);
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
-		break;
-	}
-
-	return_VOID;
-}
-
-
-static int
-acpi_battery_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = 0;
-	struct acpi_battery	*battery = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_add");
-	
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	battery = kmalloc(sizeof(struct acpi_battery), GFP_KERNEL);
-	if (!battery)
-		return_VALUE(-ENOMEM);
-	memset(battery, 0, sizeof(struct acpi_battery));
-
-	battery->handle = device->handle;
-	sprintf(acpi_device_name(device), "%s", ACPI_BATTERY_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_BATTERY_CLASS);
-	acpi_driver_data(device) = battery;
-
-	result = acpi_battery_check(battery);
-	if (0 != result)
-		goto end;
-
-	result = acpi_battery_add_fs(device);
-	if (0 != result)
-		goto end;
-
-	status = acpi_install_notify_handler(battery->handle,
-		ACPI_DEVICE_NOTIFY, acpi_battery_notify, battery);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error installing notify handler\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
-		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
-		device->status.battery_present?"present":"absent");
-		
-end:
-	if (0 != result) {
-		acpi_battery_remove_fs(device);
-		kfree(battery);
-	}
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_battery_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	acpi_status		status = 0;
-	struct acpi_battery	*battery = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	battery = (struct acpi_battery *) acpi_driver_data(device);
-
-	status = acpi_remove_notify_handler(battery->handle,
-		ACPI_DEVICE_NOTIFY, acpi_battery_notify);
-	if (ACPI_FAILURE(status))
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error removing notify handler\n"));
-
-	acpi_battery_remove_fs(device);
-
-	kfree(battery);
-
-	return_VALUE(0);
-}
-
-
-static int __init
-acpi_battery_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_init");
-
-	result = acpi_bus_register_driver(&acpi_battery_driver);
-	if (0 > result) {
-		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
-		return_VALUE(-ENODEV);
-	}
-
-	return_VALUE(0);
-}
-
-
-static void __exit
-acpi_battery_exit (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_battery_exit");
-
-	result = acpi_bus_unregister_driver(&acpi_battery_driver);
-	if (0 == result)
-		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
-
-
-module_init(acpi_battery_init);
-module_exit(acpi_battery_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_bus.c linux/drivers/acpi/acpi_bus.c
--- ../prev/linux/drivers/acpi/acpi_bus.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_bus.c	Wed Dec 31 17:00:00 1969
@@ -1,2201 +0,0 @@
-/*
- *  acpi_bus.c - ACPI Bus Driver ($Revision: 66 $)
- *
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/version.h>
-#include <linux/ioport.h>
-#include <linux/list.h>
-#include <linux/sched.h>
-#include <linux/pm.h>
-#include <linux/proc_fs.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-#include "include/acinterp.h"	/* for acpi_ex_eisa_id_to_string() */
-
-
-#define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME		("acpi_bus")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_BUS_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-#define	PREFIX			"ACPI: "
-
-FADT_DESCRIPTOR			acpi_fadt;
-static u8			acpi_disabled = 0;
-struct acpi_device		*acpi_root = NULL;
-struct proc_dir_entry		*acpi_root_dir = NULL;
-
-#define STRUCT_TO_INT(s)	(*((int*)&s))
-
-/*
- * POLICY: If *anything* doesn't work, put it on the blacklist.
- *	   If they are critical errors, mark it critical, and abort driver load.
- */
-static struct acpi_blacklist_item acpi_blacklist[] __initdata =
-{
-	/* Portege 7020, BIOS 8.10 */
-	{"TOSHIB", "7020CT  ", 0x19991112, ACPI_TABLE_DSDT, all_versions, "Implicit Return", 0},
-	/* Portege 4030 */
-	{"TOSHIB", "4030    ", 0x19991112, ACPI_TABLE_DSDT, all_versions, "Implicit Return", 0},
-	/* Portege 310/320, BIOS 7.1 */
-	{"TOSHIB", "310     ", 0x19990511, ACPI_TABLE_DSDT, all_versions, "Implicit Return", 0},
-	/* Seattle 2, old bios rev. */
-	{"INTEL ", "440BX   ", 0x00001000, ACPI_TABLE_DSDT, less_than_or_equal, "Field beyond end of region", 0},
-	/* ASUS K7M */
-	{"ASUS  ", "K7M     ", 0x00001000, ACPI_TABLE_DSDT, less_than_or_equal, "Field beyond end of region", 0},
-	/* Intel 810 Motherboard? */
-	{"MNTRAL", "MO81010A", 0x00000012, ACPI_TABLE_DSDT, less_than_or_equal, "Field beyond end of region", 0},
-	/* Compaq Presario 1700 */
-	{"PTLTD ", "  DSDT  ", 0x06040000, ACPI_TABLE_DSDT, less_than_or_equal, "Multiple problems", 1},
-	/* Sony FX120, FX140, FX150? */
-	{"SONY  ", "U0      ", 0x20010313, ACPI_TABLE_DSDT, less_than_or_equal, "ACPI driver problem", 1},
-	/* Compaq Presario 800, Insyde BIOS */
-	{"INT440", "SYSFexxx", 0x00001001, ACPI_TABLE_DSDT, less_than_or_equal, "Does not use _REG to protect EC OpRegions", 1},
-	/* IBM 600E - _ADR should return 7, but it returns 1 */
-	{"IBM   ", "TP600E  ", 0x00000105, ACPI_TABLE_DSDT, less_than_or_equal, "Incorrect _ADR", 1},
-	{""}
-};
-
-
-/* --------------------------------------------------------------------------
-                          Linux Driver Model (LDM) Support
-   -------------------------------------------------------------------------- */
-
-#ifdef CONFIG_LDM
-
-static int acpi_device_probe(struct device *dev);
-static int acpi_device_remove(struct device *dev, u32 flags);
-static int acpi_device_suspend(struct device *dev, u32 state, u32 stage);
-static int acpi_device_resume(struct device *dev, u32 stage);
-
-static struct device_driver acpi_bus_driver = {
-	probe: acpi_device_probe,
-	remove: acpi_device_remove,	
-	suspend: acpi_device_suspend,
-	resume: acpi_device_resume,
-};
-
-
-static int
-acpi_device_probe (
-	struct device		*dev)
-{
-	ACPI_FUNCTION_TRACE("acpi_device_probe");
-
-	if (!dev)
-		return_VALUE(-EINVAL);
-
-	/* TBD */
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_device_remove (
-	struct device		*dev,
-	u32			flags)
-{
-	ACPI_FUNCTION_TRACE("acpi_device_remove");
-
-	if (!dev)
-		return_VALUE(-EINVAL);
-
-	/* TBD */
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_device_suspend (
-	struct device		*dev,
-	u32			state,
-	u32			stage)
-{
-	ACPI_FUNCTION_TRACE("acpi_device_suspend");
-
-	if (!dev)
-		return_VALUE(-EINVAL);
-
-	/* TBD */
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_device_resume (
-	struct device		*dev,
-	u32			stage)
-{
-	ACPI_FUNCTION_TRACE("acpi_device_resume");
-
-	if (!dev)
-		return_VALUE(-EINVAL);
-
-	/* TBD */
-
-	return_VALUE(0);
-}
-
-#if 0 /* not used ATM */
-static int
-acpi_platform_add (
-	struct device		*dev)
-{
-	ACPI_FUNCTION_TRACE("acpi_platform_add");
-
-	if (!dev)
-		return -EINVAL;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s (%s) added\n",
-		dev->name, dev->bus_id));
-
-	/* TBD */
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_platform_remove (
-	struct device		*dev)
-{
-	ACPI_FUNCTION_TRACE("acpi_platform_add");
-
-	if (!dev)
-		return -EINVAL;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s (%s) removed\n",
-		dev->name, dev->bus_id));
-
-	/* TBD */
-
-	return_VALUE(0);
-}
-#endif /* unused */
-
-
-#endif /*CONFIG_LDM*/
-
-
-static int
-acpi_device_register (
-	struct acpi_device	*device,
-	struct acpi_device	*parent)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_device_register");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-#ifdef CONFIG_LDM
-	sprintf(device->dev.name, "ACPI device %s:%s", 
-		device->pnp.hardware_id, device->pnp.unique_id);
-	strncpy(device->dev.bus_id, device->pnp.bus_id, sizeof(acpi_bus_id));
-	if (parent)
-		device->dev.parent = &parent->dev;
-	device->dev.driver = &acpi_bus_driver;
-
-	result = device_register(&device->dev);
-#endif /*CONFIG_LDM*/
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_device_unregister (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_device_unregister");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-#ifdef CONFIG_LDM
-	put_device(&device->dev);
-#endif /*CONFIG_LDM*/
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Device Management
-   -------------------------------------------------------------------------- */
-
-static void
-acpi_bus_data_handler (
-	acpi_handle		handle,
-	u32			function,
-	void			*context)
-{
-	ACPI_FUNCTION_TRACE("acpi_bus_data_handler");
-
-	/* TBD */
-
-	return_VOID;
-}
-
-
-int
-acpi_bus_get_device (
-	acpi_handle		handle,
-	struct acpi_device	**device)
-{
-	acpi_status		status = AE_OK;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_get_device");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	/* TBD: Support fixed-feature devices */
-
-	status = acpi_get_data(handle, acpi_bus_data_handler, (void**) device);
-	if (ACPI_FAILURE(status) || !*device) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context for object [%p]\n",
-			handle));
-		return_VALUE(-ENODEV);
-	}
-
-	return_VALUE(0);
-}
-
-int
-acpi_bus_get_status (
-	struct acpi_device	*device)
-{
-	acpi_status		status = AE_OK;
-	unsigned long		sta = 0;
-	
-	ACPI_FUNCTION_TRACE("acpi_bus_get_status");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * Evaluate _STA if present.
-	 */
-	if (device->flags.dynamic_status) {
-		status = acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
-		if (ACPI_FAILURE(status))
-			return_VALUE(-ENODEV);
-		STRUCT_TO_INT(device->status) = (int) sta;
-	}
-
-	/*
-	 * Otherwise we assume the status of our parent (unless we don't
-	 * have one, in which case status is implied).
-	 */
-	else if (device->parent)
-		device->status = device->parent->status;
-	else
-		STRUCT_TO_INT(device->status) = 0x0F;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n", 
-		device->pnp.bus_id, (u32) STRUCT_TO_INT(device->status)));
-
-	return_VALUE(0);
-}
-
-
-/*
-static int
-acpi_bus_create_device_fs (struct device *device)
-{
-	ACPI_FUNCTION_TRACE("acpi_bus_create_device_fs");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	if (device->dir.entry)
-		return_VALUE(-EEXIST);
-
-	if (!device->parent)
-		device->dir.entry = proc_mkdir(device->pnp.bus_id, NULL);
-	else
-		device->dir.entry = proc_mkdir(device->pnp.bus_id,
-			device->parent->fs.entry);
-
-	if (!device->dir.entry) {
-		printk(KERN_ERR PREFIX "Unable to create fs entry '%s'\n",
-			device->pnp.bus_id);
-		return_VALUE(-ENODEV);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_bus_remove_device_fs (struct device *device)
-{
-	ACPI_FUNCTION_TRACE("acpi_bus_create_device_fs");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	if (!device->dir.entry)
-		return_VALUE(-ENODEV);
-
-	if (!device->parent)
-		remove_proc_entry(device->pnp_bus_id, NULL);
-	else
-		remove_proc_entry(device->pnp.bus_id, device->parent->fs.entry);
-
-	device->dir.entry = NULL;
-
-	return_VALUE(0);
-}
-*/
-
-
-/* --------------------------------------------------------------------------
-                                 Power Management
-   -------------------------------------------------------------------------- */
-
-int
-acpi_bus_get_power (
-	acpi_handle		handle,
-	int			*state)
-{
-	int			result = 0;
-	acpi_status             status = 0;
-	struct acpi_device	*device = NULL;
-	unsigned long		psc = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_get_power");
-
-	result = acpi_bus_get_device(handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-
-	*state = ACPI_STATE_UNKNOWN;
-
-	if (!device->flags.power_manageable) {
-		/* TBD: Non-recursive algorithm for walking up hierarchy */
-		if (device->parent)
-			*state = device->parent->power.state;
-		else
-			*state = ACPI_STATE_D0;
-	}
-	else {
-		/*
-		 * Get the device's power state either directly (via _PSC) or 
-		 * indirectly (via power resources).
-		 */
-		if (device->power.flags.explicit_get) {
-			status = acpi_evaluate_integer(device->handle, "_PSC", 
-				NULL, &psc);
-			if (ACPI_FAILURE(status))
-				return_VALUE(-ENODEV);
-			device->power.state = (int) psc;
-		}
-		else if (device->power.flags.power_resources) {
-			result = acpi_power_get_inferred_state(device);
-			if (0 != result)
-				return_VALUE(result);
-		}
-
-		*state = device->power.state;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
-		device->pnp.bus_id, device->power.state));
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_bus_set_power (
-	acpi_handle		handle,
-	int			state)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
-	char			object_name[5] = {'_','P','S','0'+state,'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_bus_set_power");
-
-	result = acpi_bus_get_device(handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-
-	if ((state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
-		return_VALUE(-EINVAL);
-
-	/* Make sure this is a valid target state */
-
-	if (!device->flags.power_manageable) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device is not power manageable\n"));
-		return_VALUE(-ENODEV);
-	}
-	if (state == device->power.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n", state));
-		return_VALUE(0);
-	}
-	if (!device->power.states[state].flags.valid) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n", state));
-		return_VALUE(-ENODEV);
-	}
-	if (device->parent && (state < device->parent->power.state)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Cannot set device to a higher-powered state than parent\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	/*
-	 * Transition Power
-	 * ----------------
-	 * On transitions to a high-powered state we first apply power (via
-	 * power resources) then evalute _PSx.  Conversly for transitions to
-	 * a lower-powered state.
-	 */ 
-	if (state < device->power.state) {
-		if (device->power.flags.power_resources) {
-			result = acpi_power_transition(device, state);
-			if (0 != result)
-				goto end;
-		}
-		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle, 
-				object_name, NULL, NULL);
-			if (ACPI_FAILURE(status)) {
-				result = -ENODEV;
-				goto end;
-			}
-		}
-	}
-	else {
-		if (device->power.states[state].flags.explicit_set) {
-			status = acpi_evaluate_object(device->handle, 
-				object_name, NULL, NULL);
-			if (ACPI_FAILURE(status)) {
-				result = -ENODEV;
-				goto end;
-			}
-		}
-		if (device->power.flags.power_resources) {
-			result = acpi_power_transition(device, state);
-			if (0 != result)
-				goto end;
-		}
-	}
-
-end:
-	if (0 != result)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error transitioning device [%s] to D%d\n",
-			device->pnp.bus_id, state));
-	else
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] transitioned to D%d\n",
-			device->pnp.bus_id, state));
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_bus_get_power_flags (
-	struct acpi_device	*device)
-{
-	acpi_status             status = 0;
-	acpi_handle		handle = 0;
-	u32                     i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_get_power_flags");
-
-	if (!device)
-		return -ENODEV;
-
-	/*
-	 * Power Management Flags
-	 */
-	status = acpi_get_handle(device->handle, "_PSC", &handle);
-	if (ACPI_SUCCESS(status))
-		device->power.flags.explicit_get = 1;
-	status = acpi_get_handle(device->handle, "_IRC", &handle);
-	if (ACPI_SUCCESS(status))
-		device->power.flags.inrush_current = 1;
-	status = acpi_get_handle(device->handle, "_PRW", &handle);
-	if (ACPI_SUCCESS(status))
-		device->power.flags.wake_capable = 1;
-
-	/*
-	 * Enumerate supported power management states
-	 */
-	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
-		struct acpi_device_power_state *ps = &device->power.states[i];
-		char		object_name[5] = {'_','P','R','0'+i,'\0'};
-
-		/* Evaluate "_PRx" to se if power resources are referenced */
-		acpi_evaluate_reference(device->handle, object_name, NULL,
-			&ps->resources);
-		if (ps->resources.count) {
-			device->power.flags.power_resources = 1;
-			ps->flags.valid = 1;
-		}
-
-		/* Evaluate "_PSx" to see if we can do explicit sets */
-		object_name[2] = 'S';
-		status = acpi_get_handle(device->handle, object_name, &handle);
-		if (ACPI_SUCCESS(status)) {
-			ps->flags.explicit_set = 1;
-			ps->flags.valid = 1;
-		}
-
-		/* State is valid if we have some power control */
-		if (ps->resources.count || ps->flags.explicit_set)
-			ps->flags.valid = 1;
-
-		ps->power = -1;		/* Unknown - driver assigned */
-		ps->latency = -1;	/* Unknown - driver assigned */
-	}
-
-	/* Set defaults for D0 and D3 states (always valid) */
-	device->power.states[ACPI_STATE_D0].flags.valid = 1;
-	device->power.states[ACPI_STATE_D0].power = 100;
-	device->power.states[ACPI_STATE_D3].flags.valid = 1;
-	device->power.states[ACPI_STATE_D3].power = 0;
-
-	/*
-	 * System Power States
-	 * -------------------
-	 */
-	/* TBD: S1-S4 power state support and resource requirements. */
-	/*
-	for (i=ACPI_STATE_S1; i<ACPI_STATE_S5; i++) {
-		char name[5] = {'_','S',('0'+i),'D','\0'};
-		status = acpi_evaluate_integer(device->handle, name, NULL,
-			&state);
-		if (ACPI_FAILURE(status))
-			continue;
-	}
-	*/
-
-	/* TBD: System wake support and resource requirements. */
-
-	device->power.state = ACPI_STATE_UNKNOWN;
-
-	return 0;
-}
-
-
-/* --------------------------------------------------------------------------
-                              Performance Management
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_bus_get_perf_flags (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_bus_get_perf_flags");
-
-	if (!device)
-		return -ENODEV;
-
-	device->performance.state = ACPI_STATE_UNKNOWN;
-
-	return 0;
-}
-
-
-/* --------------------------------------------------------------------------
-                                Event Management
-   -------------------------------------------------------------------------- */
-
-static spinlock_t		acpi_bus_event_lock = SPIN_LOCK_UNLOCKED;
-
-LIST_HEAD(acpi_bus_event_list);
-DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
-
-extern int			event_is_open;
-
-int
-acpi_bus_generate_event (
-	struct acpi_device	*device,
-	u8			type,
-	int			data)
-{
-	struct acpi_bus_event	*event = NULL;
-	u32			flags = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_generate_event");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	/* drop event on the floor if no one's listening */
-	if (!event_is_open)
-		return_VALUE(0);
-
-	event = kmalloc(sizeof(struct acpi_bus_event), GFP_KERNEL);
-	if (!event)
-		return_VALUE(-ENOMEM);
-
-	sprintf(event->device_class, "%s", device->pnp.device_class);
-	sprintf(event->bus_id, "%s", device->pnp.bus_id);
-	event->type = type;
-	event->data = data;
-
-	spin_lock_irqsave(&acpi_bus_event_lock, flags);
-	list_add_tail(&event->node, &acpi_bus_event_list);
-	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
-
-	wake_up_interruptible(&acpi_bus_event_queue);
-
-	return_VALUE(0);
-}
-
-int
-acpi_bus_receive_event (
-	struct acpi_bus_event	*event)
-{
-	u32			flags = 0;
-	struct acpi_bus_event	*entry = NULL;
-
-	DECLARE_WAITQUEUE(wait, current);
-
-	ACPI_FUNCTION_TRACE("acpi_bus_receive_event");
-
-	if (!event)
-		return -EINVAL;
-
-	if (list_empty(&acpi_bus_event_list)) {
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		add_wait_queue(&acpi_bus_event_queue, &wait);
-
-		if (list_empty(&acpi_bus_event_list))
-			schedule();
-
-		remove_wait_queue(&acpi_bus_event_queue, &wait);
-		set_current_state(TASK_RUNNING);
-
-		if (signal_pending(current))
-			return_VALUE(-ERESTARTSYS);
-	}
-
-	spin_lock_irqsave(&acpi_bus_event_lock, flags);
-	entry = list_entry(acpi_bus_event_list.next, struct acpi_bus_event, node);
-	if (entry)
-		list_del(&entry->node);
-	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
-
-	if (!entry)
-		return_VALUE(-ENODEV);
-
-	memcpy(event, entry, sizeof(struct acpi_bus_event));
-
-	kfree(entry);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                               Namespace Management
-   -------------------------------------------------------------------------- */
-
-#define WALK_UP			0
-#define WALK_DOWN		1
-
-typedef int (*acpi_bus_walk_callback)(struct acpi_device*, int, void*);
-
-#define HAS_CHILDREN(d)		((d)->children.next != &((d)->children))
-#define HAS_SIBLINGS(d)		(((d)->parent) && ((d)->node.next != &(d)->parent->children))
-#define NODE_TO_DEVICE(n)	(list_entry(n, struct acpi_device, node))
-
-
-/**
- * acpi_bus_walk
- * -------------
- * Used to walk the ACPI Bus's device namespace.  Can walk down (depth-first)
- * or up.  Able to parse starting at any node in the namespace.  Note that a
- * callback return value of -ELOOP will terminate the walk.
- *
- * @start:	starting point
- * callback:	function to call for every device encountered while parsing
- * direction:	direction to parse (up or down)
- * @data:	context for this search operation
- */
-static int
-acpi_bus_walk (
-	struct acpi_device	*start, 
-	acpi_bus_walk_callback	callback, 
-	int			direction, 
-	void			*data)
-{
-	int			result = 0;
-	int			level = 0;
-	struct acpi_device	*device = NULL;
-
-	if (!start || !callback)
-		return -EINVAL;
-
-	device = start;
-
-	/*
-	 * Parse Namespace
-	 * ---------------
-	 * Parse a given subtree (specified by start) in the given direction.
-	 * Walking 'up' simply means that we execute the callback on leaf
-	 * devices prior to their parents (useful for things like removing
-	 * or powering down a subtree).
-	 */
-
-	while (device) {
-
-		if (direction == WALK_DOWN)
-			if (-ELOOP == callback(device, level, data))
-				break;
-
-		/* Depth First */
-
-		if (HAS_CHILDREN(device)) {
-			device = NODE_TO_DEVICE(device->children.next);
-			++level;
-			continue;
-		}
-
-		if (direction == WALK_UP)
-			if (-ELOOP == callback(device, level, data))
-				break;
-
-		/* Now Breadth */
-
-		if (HAS_SIBLINGS(device)) {
-			device = NODE_TO_DEVICE(device->node.next);
-			continue;
-		}
-
-		/* Scope Exhausted - Find Next */
-
-		while ((device = device->parent)) {
-			--level;
-			if (HAS_SIBLINGS(device)) {
-				device = NODE_TO_DEVICE(device->node.next);
-				break;
-			}
-		}
-	}
-
-	if ((direction == WALK_UP) && (result == 0))
-		callback(start, level, data);
-
-	return result;
-}
-
-
-/* --------------------------------------------------------------------------
-                             Notification Handling
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_bus_check_device (
-	struct acpi_device	*device,
-	int			*status_changed)
-{
-	acpi_status             status = 0;
-	struct acpi_device_status old_status;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_check_device");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	if (status_changed)
-		*status_changed = 0;
-
-	old_status = device->status;
-
-	/*
-	 * Make sure this device's parent is present before we go about
-	 * messing with the device.
-	 */
-	if (device->parent && !device->parent->status.present) {
-		device->status = device->parent->status;
-		if (STRUCT_TO_INT(old_status) != STRUCT_TO_INT(device->status)) {
-			if (status_changed)
-				*status_changed = 1;
-		}
-		return_VALUE(0);
-	}
-
-	status = acpi_bus_get_status(device);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
-		return_VALUE(0);
-
-	if (status_changed)
-		*status_changed = 1;
-	
-	/*
-	 * Device Insertion/Removal
-	 */
-	if ((device->status.present) && !(old_status.present)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device insertion detected\n"));
-		/* TBD: Handle device insertion */
-	}
-	else if (!(device->status.present) && (old_status.present)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device removal detected\n"));
-		/* TBD: Handle device removal */
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_bus_check_scope (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	int			status_changed = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_check_scope");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	/* Status Change? */
-	result = acpi_bus_check_device(device, &status_changed);
-	if (0 != result)
-		return_VALUE(result);
-
-	if (!status_changed)
-		return_VALUE(0);
-
-	/*
-	 * TBD: Enumerate child devices within this device's scope and
-	 *       run acpi_bus_check_device()'s on them.
-	 */
-
-	return_VALUE(0);
-}
-
-
-/**
- * acpi_bus_notify
- * ---------------
- * Callback for all 'system-level' device notifications (values 0x00-0x7F).
- */
-static void 
-acpi_bus_notify (
-	acpi_handle             handle,
-	u32                     type,
-	void                    *data)
-{
-	int			result = 0;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_notify");
-
-	if (0 != acpi_bus_get_device(handle, &device))
-		return_VOID;
-
-	switch (type) {
-
-	case ACPI_NOTIFY_BUS_CHECK:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS CHECK notification for device [%s]\n", 
-			device->pnp.bus_id));
-		result = acpi_bus_check_scope(device);
-		/* 
-		 * TBD: We'll need to outsource certain events to non-ACPI
-		 *	drivers via the device manager (device.c).
-		 */
-		break;
-
-	case ACPI_NOTIFY_DEVICE_CHECK:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK notification for device [%s]\n", 
-			device->pnp.bus_id));
-		result = acpi_bus_check_device(device, NULL);
-		/* 
-		 * TBD: We'll need to outsource certain events to non-ACPI
-		 *	drivers via the device manager (device.c).
-		 */
-		break;
-
-	case ACPI_NOTIFY_DEVICE_WAKE:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE WAKE notification for device [%s]\n", 
-			device->pnp.bus_id));
-		/* TBD */
-		break;
-
-	case ACPI_NOTIFY_EJECT_REQUEST:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received EJECT REQUEST notification for device [%s]\n", 
-			device->pnp.bus_id));
-		/* TBD */
-		break;
-
-	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK LIGHT notification for device [%s]\n", 
-			device->pnp.bus_id));
-		/* TBD: Exactly what does 'light' mean? */
-		break;
-
-	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received FREQUENCY MISMATCH notification for device [%s]\n", 
-			device->pnp.bus_id));
-		/* TBD */
-		break;
-
-	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS MODE MISMATCH notification for device [%s]\n", 
-			device->pnp.bus_id));
-		/* TBD */
-		break;
-
-	case ACPI_NOTIFY_POWER_FAULT:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received POWER FAULT notification for device [%s]\n", 
-			device->pnp.bus_id));
-		/* TBD */
-		break;
-
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received unknown/unsupported notification [%08x]\n", 
-			type));
-		break;
-	}
-
-	return_VOID;
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Driver Management
-   -------------------------------------------------------------------------- */
-
-static LIST_HEAD(acpi_bus_drivers);
-static DECLARE_MUTEX(acpi_bus_drivers_lock);
-
-
-/**
- * acpi_bus_match 
- * --------------
- * Checks the device's hardware (_HID) or compatible (_CID) ids to see if it
- * matches the specified driver's criteria.
- */
-static int
-acpi_bus_match (
-	struct acpi_device	*device,
-	struct acpi_driver	*driver)
-{
-
-	if (!device || !driver)
-		return -EINVAL;
-
-	if (device->flags.hardware_id) {
-		if (0 != strstr(driver->ids, device->pnp.hardware_id))
-			return 0;
-	}
-
-	if (device->flags.compatible_ids) {
-		acpi_status	status = AE_OK;
-		acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-		acpi_object	*object = NULL;
-		char		cid[256];
-
-		memset(cid, 0, sizeof(cid));
-
-		status = acpi_evaluate_object(device->handle, "_CID", NULL, 
-			&buffer);
-		if (ACPI_FAILURE(status) || !buffer.pointer)
-			return -ENOENT;
-
-		object = (acpi_object *) buffer.pointer;
-
-		switch (object->type) {
-		case ACPI_TYPE_INTEGER:
-			acpi_ex_eisa_id_to_string((u32) object->integer.value, 
-				cid);
-			break;
-		case ACPI_TYPE_STRING:
-			strncpy(cid, object->string.pointer, sizeof(cid) - 1);
-			break;
-		case ACPI_TYPE_PACKAGE:
-			/* TBD: Support CID packages */
-		}
-
-		if (!cid[0])
-			return -ENOENT;
-
-		if (0 != strstr(driver->ids, cid))
-			return 0;
-	}
-
-	return -ENOENT;
-}
-
-
-/**
- * acpi_bus_driver_init 
- * --------------------
- * Used to initialize a device via its device driver.  Called whenever a 
- * driver is bound to a device.  Invokes the driver's add() and start() ops.
- */
-static int
-acpi_bus_driver_init (
-	struct acpi_device	*device, 
-	struct acpi_driver	*driver)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_driver_init");
-
-	if (!device || !driver)
-		return_VALUE(-EINVAL);
-
-	if (!driver->ops.add)
-		return_VALUE(-ENOSYS);
-
-	result = driver->ops.add(device);
-	if (0 != result) {
-		device->driver = NULL;
-		acpi_driver_data(device) = NULL;
-		return_VALUE(result);
-	}
-
-	/*
-	 * TBD - Configuration Management: Assign resources to device based
-	 * upon possible configuration and currently allocated resources.
-	 */
-
-	if (driver->ops.start) {
-		result = driver->ops.start(device);
-		if ((0 != result) && (driver->ops.remove))
-			driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
-		return_VALUE(result);
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Driver successfully bound to device\n"));
-
-#ifdef CONFIG_LDM
-	/* 
-	 * Update the device information (in the global device hierarchy) now
-	 * that there's a driver bound to it.
-	 */
-	strncpy(device->dev.name, device->pnp.device_name, 
-		sizeof(device->dev.name));
-#endif
-
-	if (driver->ops.scan) {
-		driver->ops.scan(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-/**
- * acpi_bus_attach 
- * -------------
- * Callback for acpi_bus_walk() used to find devices that match a specific 
- * driver's criteria and then attach the driver.
- */
-static int
-acpi_bus_attach (
-	struct acpi_device	*device, 
-	int			level, 
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_driver	*driver = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_attach");
-
-	if (!device || !data)
-		return_VALUE(-EINVAL);
-
-	driver = (struct acpi_driver *) data;
-
-	if (device->driver)
-		return_VALUE(-EEXIST);
-
-	if (!device->status.present)
-		return_VALUE(-ENODEV);
-
-	result = acpi_bus_match(device, driver);
-	if (0 != result)
-		return_VALUE(result);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
-		driver->name, device->pnp.bus_id));
-	
-	result = acpi_bus_driver_init(device, driver);
-	if (0 != result)
-		return_VALUE(result);
-
-	down(&acpi_bus_drivers_lock);
-	++driver->references;
-	up(&acpi_bus_drivers_lock);
-
-	return_VALUE(0);
-}
-
-
-/**
- * acpi_bus_unattach 
- * -----------------
- * Callback for acpi_bus_walk() used to find devices that match a specific 
- * driver's criteria and unattach the driver.
- */
-static int
-acpi_bus_unattach (
-	struct acpi_device	*device, 
-	int			level, 
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_driver	*driver = (struct acpi_driver *) data;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_unattach");
-
-	if (!device || !driver)
-		return_VALUE(-EINVAL);
-
-	if (device->driver != driver)
-		return_VALUE(-ENOENT);
-
-	if (!driver->ops.remove)
-		return_VALUE(-ENOSYS);
-
-	result = driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
-	if (0 != result)
-		return_VALUE(result);
-
-	device->driver = NULL;
-	acpi_driver_data(device) = NULL;
-
-	down(&acpi_bus_drivers_lock);
-	driver->references--;
-	up(&acpi_bus_drivers_lock);
-
-	return_VALUE(0);
-}
-
-
-/**
- * acpi_bus_find_driver 
- * --------------------
- * Parses the list of registered drivers looking for a driver applicable for
- * the specified device.
- */
-static int
-acpi_bus_find_driver (
-	struct acpi_device	*device)
-{
-	int			result = -ENODEV;
-	struct list_head	*entry = NULL;
-	struct acpi_driver	*driver = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_find_driver");
-
-	if (!device || device->driver)
-		return_VALUE(-EINVAL);
-
-	down(&acpi_bus_drivers_lock);
-
-	list_for_each(entry, &acpi_bus_drivers) {
-
-		driver = list_entry(entry, struct acpi_driver, node);
-
-		if (0 != acpi_bus_match(device, driver))
-			continue;
-
-		result = acpi_bus_driver_init(device, driver);
-		if (0 == result)
-			++driver->references;
-
-		break;
-	}
-
-	up(&acpi_bus_drivers_lock);
-
-	return_VALUE(result);
-}
-
-
-/**
- * acpi_bus_register_driver 
- * ------------------------ 
- * Registers a driver with the ACPI bus.  Searches the namespace for all
- * devices that match the driver's criteria and binds.
- */
-int
-acpi_bus_register_driver (
-	struct acpi_driver	*driver)
-{
-	ACPI_FUNCTION_TRACE("acpi_bus_register_driver");
-
-	if (!driver)
-		return_VALUE(-EINVAL);
-
-	down(&acpi_bus_drivers_lock);
-	list_add_tail(&driver->node, &acpi_bus_drivers);
-	up(&acpi_bus_drivers_lock);
-
-	acpi_bus_walk(acpi_root, acpi_bus_attach, 
-		WALK_DOWN, driver);
-
-	return_VALUE(driver->references);
-}
-
-
-/**
- * acpi_bus_unregister_driver 
- * --------------------------
- * Unregisters a driver with the ACPI bus.  Searches the namespace for all
- * devices that match the driver's criteria and unbinds.
- */
-int
-acpi_bus_unregister_driver (
-	struct acpi_driver	*driver)
-{
-	ACPI_FUNCTION_TRACE("acpi_bus_unregister_driver");
-
-	if (!driver)
-		return_VALUE(-EINVAL);
-
-	acpi_bus_walk(acpi_root, acpi_bus_unattach, WALK_UP, driver);
-
-	if (driver->references)
-		return_VALUE(driver->references);
-
-	down(&acpi_bus_drivers_lock);
-	list_del(&driver->node);
-	up(&acpi_bus_drivers_lock);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Device Enumeration
-   -------------------------------------------------------------------------- */
-
-static int 
-acpi_bus_get_flags (
-	struct acpi_device	*device)
-{
-	acpi_status		status = AE_OK;
-	acpi_handle		temp = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_get_flags");
-
-	/* Presence of _STA indicates 'dynamic_status' */
-	status = acpi_get_handle(device->handle, "_STA", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.dynamic_status = 1;
-
-	/* Presence of _CID indicates 'compatible_ids' */
-	status = acpi_get_handle(device->handle, "_CID", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.compatible_ids = 1;
-
-	/* Presence of _RMV indicates 'removable' */
-	status = acpi_get_handle(device->handle, "_RMV", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.removable = 1;
-
-	/* Presence of _EJD|_EJ0 indicates 'ejectable' */
-	status = acpi_get_handle(device->handle, "_EJD", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.ejectable = 1;
-	else {
-		status = acpi_get_handle(device->handle, "_EJ0", &temp);
-		if (ACPI_SUCCESS(status))
-			device->flags.ejectable = 1;
-	}
-
-	/* Presence of _LCK indicates 'lockable' */
-	status = acpi_get_handle(device->handle, "_LCK", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.lockable = 1;
-
-	/* Presence of _PS0|_PR0 indicates 'power manageable' */
-	status = acpi_get_handle(device->handle, "_PS0", &temp);
-	if (ACPI_FAILURE(status))
-		status = acpi_get_handle(device->handle, "_PR0", &temp);
-	if (ACPI_SUCCESS(status))
-		device->flags.power_manageable = 1;
-
-	/* TBD: Peformance management */
-
-	return_VALUE(0);
-}
-
-
-static int 
-acpi_bus_add (
-	struct acpi_device	**child,
-	struct acpi_device	*parent,
-	acpi_handle		handle,
-	int			type)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
-	char			bus_id[5] = {'?',0};
-	acpi_buffer		buffer = {sizeof(bus_id), bus_id};
-	acpi_device_info	info;
-	char			*hid = NULL;
-	char			*uid = NULL;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_add");
-
-	if (!child)
-		return_VALUE(-EINVAL);
-
-	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
-	if (!device) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
-		return_VALUE(-ENOMEM);
-	}
-	memset(device, 0, sizeof(struct acpi_device));
-
-	device->handle = handle;
-	device->parent = parent;
-
-	memset(&info, 0, sizeof(acpi_device_info));
-
-	/*
-	 * Bus ID
-	 * ------
-	 * The device's Bus ID is simply the object name.
-	 * TBD: Shouldn't this value be unique (within the ACPI namespace)?
-	 */
-	switch (type) {
-	case ACPI_BUS_TYPE_SYSTEM:
-		sprintf(device->pnp.bus_id, "%s", "ACPI");
-		break;
-	case ACPI_BUS_TYPE_POWER_BUTTON:
-		sprintf(device->pnp.bus_id, "%s", "PWRF");
-		break;
-	case ACPI_BUS_TYPE_SLEEP_BUTTON:
-		sprintf(device->pnp.bus_id, "%s", "SLPF");
-		break;
-	default:
-		acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);
-		/* Clean up trailing underscores (if any) */
-		for (i = 3; i > 1; i--) {
-			if (bus_id[i] == '_')
-				bus_id[i] = '\0';
-			else
-				break;
-		}
-		sprintf(device->pnp.bus_id, "%s", bus_id);
-		break;
-	}
-
-	/*
-	 * Flags
-	 * -----
-	 * Get prior to calling acpi_bus_get_status() so we know whether
-	 * or not _STA is present.  Note that we only look for object
-	 * handles -- cannot evaluate objects until we know the device is
-	 * present and properly initialized.
-	 */
-	result = acpi_bus_get_flags(device);
-	if (0 != result)
-		goto end;
-
-	/*
-	 * Status
-	 * ------
-	 * See if the device is present.  We always assume that non-Device()
-	 * objects (e.g. thermal zones, power resources, processors, etc.) are
-	 * present, functioning, etc. (at least when parent object is present).
-	 * Note that _STA has a different meaning for some objects (e.g.
-	 * power resources) so we need to be careful how we use it.
-	 */
-	switch (type) {
-	case ACPI_BUS_TYPE_DEVICE:
-		result = acpi_bus_get_status(device);
-		if (0 != result)
-			goto end;
-		break;
-	default:
-		STRUCT_TO_INT(device->status) = 0x0F;
-		break;
-	}
-	if (!device->status.present) {
-		result = -ENOENT;
-		goto end;
-	}
-
-	/*
-	 * Initialize Device
-	 * -----------------
-	 * TBD: Synch with Core's enumeration/initialization process.
-	 */
-
-	/*
-	 * Hardware ID, Unique ID, & Bus Address
-	 * -------------------------------------
-	 */
-	switch (type) {
-	case ACPI_BUS_TYPE_DEVICE:
-		status = acpi_get_object_info(handle, &info);
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				"Error reading device info\n"));
-			result = -ENODEV;
-			goto end;
-		}
-		/* Clean up info strings (not NULL terminated) */
-		info.hardware_id[sizeof(info.hardware_id)-1] = '\0';
-		info.unique_id[sizeof(info.unique_id)-1] = '\0';
-		if (info.valid & ACPI_VALID_HID)
-			hid = info.hardware_id;
-		if (info.valid & ACPI_VALID_UID)
-			uid = info.unique_id;
-		if (info.valid & ACPI_VALID_ADR) {
-			device->pnp.bus_address = info.address;
-			device->flags.bus_address = 1;
-		}
-		break;
-	case ACPI_BUS_TYPE_POWER:
-		hid = ACPI_POWER_HID;
-		break;
-	case ACPI_BUS_TYPE_PROCESSOR:
-		hid = ACPI_PROCESSOR_HID;
-		break;
-	case ACPI_BUS_TYPE_SYSTEM:
-		hid = ACPI_SYSTEM_HID;
-		break;
-	case ACPI_BUS_TYPE_THERMAL:
-		hid = ACPI_THERMAL_HID;
-		break;
-	case ACPI_BUS_TYPE_POWER_BUTTON:
-		hid = ACPI_BUTTON_HID_POWERF;
-		break;
-	case ACPI_BUS_TYPE_SLEEP_BUTTON:
-		hid = ACPI_BUTTON_HID_SLEEPF;
-		break;
-	}
-
-	/* 
-	 * \_SB
-	 * ----
-	 * Fix for the system root bus device -- the only root-level device.
-	 */
-	if ((parent == ACPI_ROOT_OBJECT) && (type == ACPI_BUS_TYPE_DEVICE)) {
-		hid = ACPI_BUS_HID;
-		sprintf(device->pnp.device_name, "%s", ACPI_BUS_DEVICE_NAME);
-		sprintf(device->pnp.device_class, "%s", ACPI_BUS_CLASS);
-	}
-
-	if (hid) {
-		sprintf(device->pnp.hardware_id, "%s", hid);
-		device->flags.hardware_id = 1;
-	}
-	if (uid) {
-		sprintf(device->pnp.unique_id, "%s", uid);
-		device->flags.unique_id = 1;
-	}
-
-	/*
-	 * Power Management
-	 * ----------------
-	 */
-	if (device->flags.power_manageable) {
-		result = acpi_bus_get_power_flags(device);
-		if (0 != result)
-			goto end;
-	}
-
-	/*
-	 * Performance Management
-	 * ----------------------
-	 */
-	if (device->flags.performance_manageable) {
-		result = acpi_bus_get_perf_flags(device);
-		if (0 != result)
-			goto end;
-	}
-
-	/*
-	 * Context
-	 * -------
-	 * Attach this 'struct acpi_device' to the ACPI object.  This makes
-	 * resolutions from handle->device very efficient.  Note that we need
-	 * to be careful with fixed-feature devices as they all attach to the
-	 * root object.
-	 */
-	switch (type) {
-	case ACPI_BUS_TYPE_POWER_BUTTON:
-	case ACPI_BUS_TYPE_SLEEP_BUTTON:
-		break;
-	default:
-		status = acpi_attach_data(device->handle,
-			acpi_bus_data_handler, device);
-		break;
-	}
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error attaching device data\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	/*
-	 * Linkage
-	 * -------
-	 * Link this device to its parent and siblings.
-	 */
-	INIT_LIST_HEAD(&device->children);
-	if (!device->parent)
-		INIT_LIST_HEAD(&device->node);
-	else
-		list_add_tail(&device->node, &device->parent->children);
-
-#ifdef CONFIG_ACPI_DEBUG
-	{
-		char		*type_string = NULL;
-		char		name[80] = {'?','\0'};
-		acpi_buffer	buffer = {sizeof(name), name};
-
-		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-
-		switch (type) {
-		case ACPI_BUS_TYPE_DEVICE:
-			type_string = "Device";
-			break;
-		case ACPI_BUS_TYPE_POWER:
-			type_string = "Power Resource";
-			break;
-		case ACPI_BUS_TYPE_PROCESSOR:
-			type_string = "Processor";
-			break;
-		case ACPI_BUS_TYPE_SYSTEM:
-			type_string = "System";
-			break;
-		case ACPI_BUS_TYPE_THERMAL:
-			type_string = "Thermal Zone";
-			break;
-		case ACPI_BUS_TYPE_POWER_BUTTON:
-			type_string = "Power Button";
-			sprintf(name, "PWRB");
-			break;
-		case ACPI_BUS_TYPE_SLEEP_BUTTON:
-			type_string = "Sleep Button";
-			sprintf(name, "SLPB");
-			break;
-		}
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s %s [%p]\n", 
-			type_string, name, handle));
-	}
-#endif /*CONFIG_ACPI_DEBUG*/
-
-	/*
-	 * Global Device Hierarchy:
-	 * ------------------------
-	 * Register this device with the global device hierarchy.
-	 */
-	acpi_device_register(device, parent);
-
-	/*
-	 * Bind _ADR-Based Devices
-	 * -----------------------
-	 * If there's a a bus address (_ADR) then we utilize the parent's 
-	 * 'bind' function (if exists) to bind the ACPI- and natively-
-	 * enumerated device representations.
-	 */
-	if (device->flags.bus_address) {
-		if (device->parent && device->parent->ops.bind)
-			device->parent->ops.bind(device);
-	}
-
-	/*
-	 * Locate & Attach Driver
-	 * ----------------------
-	 * If there's a hardware id (_HID) or compatible ids (_CID) we check
-	 * to see if there's a driver installed for this kind of device.  Note
-	 * that drivers can install before or after a device in enumerated.
-	 *
-	 * TBD: Assumes LDM provides driver hot-plug capability.
-	 */
-	if (device->flags.hardware_id || device->flags.compatible_ids)
-		acpi_bus_find_driver(device);
-
-end:
-	if (0 != result) {
-		kfree(device);
-		return_VALUE(result);
-	}
-
-	*child = device;
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_bus_remove (
-	struct acpi_device	*device, 
-	int			type)
-{
-	ACPI_FUNCTION_TRACE("acpi_bus_remove");
-
-	if (!device)
-		return_VALUE(-ENODEV);
-
-	acpi_device_unregister(device);
-
-	kfree(device);
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_bus_scan (
-	struct acpi_device	*start)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_device	*parent = NULL;
-	struct acpi_device	*child = NULL;
-	acpi_handle		phandle = 0;
-	acpi_handle		chandle = 0;
-	acpi_object_type	type = 0;
-	u32			level = 1;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_scan");
-
-	if (!start)
-		return_VALUE(-EINVAL);
-
-	parent = start;
-	phandle = start->handle;
-	
-	/*
-	 * Parse through the ACPI namespace, identify all 'devices', and
-	 * create a new 'struct acpi_device' for each.
-	 */
-	while ((level > 0) && parent) {
-
-		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
-			chandle, &chandle);
-
-		/*
-		 * If this scope is exhausted then move our way back up.
-		 */
-		if (ACPI_FAILURE(status)) {
-			level--;
-			chandle = phandle;
-			acpi_get_parent(phandle, &phandle);
-			if (parent->parent)
-				parent = parent->parent;
-			continue;
-		}
-
-		status = acpi_get_type(chandle, &type);
-		if (ACPI_FAILURE(status))
-			continue;
-
-		/*
-		 * If this is a scope object then parse it (depth-first).
-		 */
-		if (type == ACPI_TYPE_ANY) {
-			/* Hack to get around scope identity problem */
-			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle, 0, NULL);
-			if (ACPI_SUCCESS(status)) {
-				level++;
-				phandle = chandle;
-				chandle = 0;
-			}
-			continue;
-		}
-
-		/*
-		 * We're only interested in objects that we consider 'devices'.
-		 */
-		switch (type) {
-		case ACPI_TYPE_DEVICE:
-			type = ACPI_BUS_TYPE_DEVICE;
-			break;
-		case ACPI_TYPE_PROCESSOR:
-			type = ACPI_BUS_TYPE_PROCESSOR;
-			break;
-		case ACPI_TYPE_THERMAL:
-			type = ACPI_BUS_TYPE_THERMAL;
-			break;
-		case ACPI_TYPE_POWER:
-			type = ACPI_BUS_TYPE_POWER;
-			break;
-		default:
-			continue;
-		}
-
-		status = acpi_bus_add(&child, parent, chandle, type);
-		if (ACPI_FAILURE(status))
-			continue;
-
-		/*
-		 * If the device is present, enabled, and functioning then
-		 * parse its scope (depth-first).  Note that we need to
-		 * represent absent devices to facilitate PnP notifications
-		 * -- but only the subtree head (not all of its children,
-		 * which will be enumerated when the parent is inserted).
-		 *
-		 * TBD: Need notifications and other detection mechanisms
-		 *	in place before we can fully implement this.
-		 */
-		if (child->status.present) {
-			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle,
-				0, NULL);
-			if (ACPI_SUCCESS(status)) {
-				level++;
-				phandle = chandle;
-				chandle = 0;
-				parent = child;
-			}
-		}
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_bus_scan_fixed (
-	struct acpi_device	*root)
-{
-	int			result = 0;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_scan");
-
-	if (!root)
-		return_VALUE(-ENODEV);
-
-	/*
-	 * Enumerate all fixed-feature devices.
-	 */
-	if (acpi_fadt.pwr_button == 0)
-		result = acpi_bus_add(&device, acpi_root, 
-			ACPI_ROOT_OBJECT, ACPI_BUS_TYPE_POWER_BUTTON);
-
-	if (acpi_fadt.sleep_button == 0)
-		result = acpi_bus_add(&device, acpi_root, 
-			ACPI_ROOT_OBJECT, ACPI_BUS_TYPE_SLEEP_BUTTON);
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                             Initialization/Cleanup
-   -------------------------------------------------------------------------- */
-
-int __init
-acpi_blacklisted(void)
-{
-	int i = 0;
-	int blacklisted = 0;
-	acpi_table_header table_header;
-
-	while (acpi_blacklist[i].oem_id[0] != '\0')
-	{
-		if (!ACPI_SUCCESS(acpi_get_table_header(acpi_blacklist[i].table, 1, &table_header))) {
-			i++;
-			continue;
-		}
-
-		if (strncmp(acpi_blacklist[i].oem_id, table_header.oem_id, 6)) {
-			i++;
-			continue;
-		}
-
-		if (strncmp(acpi_blacklist[i].oem_table_id, table_header.oem_table_id, 8)) {
-			i++;
-			continue;
-		}
-
-		if ((acpi_blacklist[i].oem_revision_predicate == all_versions)
-		    || (acpi_blacklist[i].oem_revision_predicate == less_than_or_equal
-		        && table_header.oem_revision <= acpi_blacklist[i].oem_revision)
-		    || (acpi_blacklist[i].oem_revision_predicate == greater_than_or_equal
-		        && table_header.oem_revision >= acpi_blacklist[i].oem_revision)
-		    || (acpi_blacklist[i].oem_revision_predicate == equal
-		        && table_header.oem_revision == acpi_blacklist[i].oem_revision)) {
-
-			printk(KERN_ERR PREFIX "Vendor \"%6.6s\" System \"%8.8s\" "
-				"Revision 0x%x has a known ACPI BIOS problem.\n",
-				acpi_blacklist[i].oem_id,
-				acpi_blacklist[i].oem_table_id,
-				acpi_blacklist[i].oem_revision);
-
-			printk(KERN_ERR PREFIX "Reason: %s. This is a %s error\n",
-				acpi_blacklist[i].reason,
-				(acpi_blacklist[i].is_critical_error ? "non-recoverable" : "recoverable"));
-
-			blacklisted = acpi_blacklist[i].is_critical_error;
-			break;
-		}
-		else {
-			i++;
-		}
-	}
-
-	return blacklisted;
-}
-
-
-static int __init
-acpi_bus_init_irq (void)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_object		arg = {ACPI_TYPE_INTEGER};
-	acpi_object_list        arg_list = {1, &arg};
-	int			irq_model = 0;
-	char			*message = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_init_irq");
-
-	/* 
-	 * Let the system know what interrupt model we are using by
-	 * evaluating the \_PIC object, if exists.
-	 */
-	result = acpi_get_interrupt_model(&irq_model);
-	if (0 != result)
-		return_VALUE(result);
-
-	switch (irq_model) {
-	case ACPI_INT_MODEL_PIC:
-		message = "PIC";
-		break;
-	case ACPI_INT_MODEL_IOAPIC:
-		message = "IOAPIC";
-		break;
-	case ACPI_INT_MODEL_IOSAPIC:
-		message = "IOSAPIC";
-		break;
-	default:
-		message = "UNKNOWN";
-		break;
-	}
-
-	printk(KERN_INFO PREFIX "Using %s for interrupt routing\n", message);
-
-	arg.integer.value = irq_model;
-
-	status = acpi_evaluate_object(NULL, "\\_PIC", &arg_list, NULL);
-	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PIC\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int __init
-acpi_bus_init (void)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_buffer		buffer = {sizeof(acpi_fadt), &acpi_fadt};
-	int			progress = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_init");
-
-	/*
-	 * [0] Initailize the ACPI Core Subsystem.
-	 */
-	status = acpi_initialize_subsystem();
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to initialize the ACPI Interpreter\n");
-		result = -ENODEV;
-		goto end;
-	}
-
-	progress++;
-
-	/*
-	 * [1] Load the ACPI tables.
-	 */
-	status = acpi_load_tables();
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to load the System Description Tables\n");
-		result = -ENODEV;
-		goto end;
-	}
-
-	progress++;
-
-	/*
-	 * [2] Check the blacklist
-	 */
-	if (acpi_blacklisted()) {
-		result = -ENODEV;
-		goto end;
-	}
-
-	progress++;
-
-	/*
-	 * [3] Get a separate copy of the FADT for use by other drivers.
-	 */
-	status = acpi_get_table(ACPI_TABLE_FADT, 1, &buffer);
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to get the FADT\n");
-		result = -ENODEV;
-		goto end;
-	}
-
-	progress++;
-
-	/*
-	 * [4] Enable the ACPI Core Subsystem.
-	 */
-	status = acpi_enable_subsystem(ACPI_FULL_INITIALIZATION);
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to start the ACPI Interpreter\n");
-		result = -ENODEV;
-		goto end;
-	}
-
-	printk(KERN_INFO PREFIX "Interpreter enabled\n");
-
-	progress++;
-
-	/*
-	 * [5] Register for all standard device notifications.
-	 */
-	result = acpi_bus_init_irq();
-	if (0 != result)
-		goto end;
-
-	/*
-	 * [6] Register for all standard device notifications.
-	 */
-	status = acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY, &acpi_bus_notify, NULL);
-	if (ACPI_FAILURE(status)) {
-		printk(KERN_ERR PREFIX "Unable to register for device notifications\n");
-		result = -ENODEV;
-		goto end;
-	}
-
-	progress++;
-
-	/*
-	 * [7] Create the root device.
-	 */
-	result = acpi_bus_add(&acpi_root, NULL, ACPI_ROOT_OBJECT, 
-		ACPI_BUS_TYPE_SYSTEM);
-	if (0 != result)
-		goto end;
-
-	progress++;
-
-	/*
-	 * [8] Create the root file system.
-	 */
-	acpi_device_dir(acpi_root) = proc_mkdir(ACPI_BUS_FILE_ROOT, NULL);
-	if (!acpi_root) {
-		result = -ENODEV;
-		goto end;
-	}
-	acpi_root_dir = acpi_device_dir(acpi_root);
-
-	progress++;
-
-	/*
-	 * [9] Install drivers required for proper enumeration of the
-	 *     ACPI namespace.
-	 */
-	acpi_system_init();	/* ACPI System */
-	acpi_power_init();	/* ACPI Bus Power Management */
-#ifdef CONFIG_ACPI_EC
-	acpi_ec_init();		/* ACPI Embedded Controller */
-#endif
-#ifdef CONFIG_ACPI_PCI
-	acpi_pci_link_init();	/* ACPI PCI Interrupt Link */
-	acpi_pci_root_init();	/* ACPI PCI Root Bridge */
-#endif
-	progress++;
-
-	/*
-	 * [10] Enumerate devices in the ACPI namespace.
-	 */
-
-	result = acpi_bus_scan_fixed(acpi_root);
-	if (0 != result)
-		goto end;
-
-	result = acpi_bus_scan(acpi_root);
-	if (0 != result)
-		goto end;
-
-end:
-	if (0 != result) {
-		switch (progress) {
-		case 10:
-		case 9: remove_proc_entry("ACPI", NULL);
-		case 8: acpi_bus_remove(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
-		case 7: acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
-				ACPI_SYSTEM_NOTIFY, &acpi_bus_notify);
-		case 6:
-		case 5:
-		case 4:
-		case 3:
-		case 2: acpi_terminate();
-		case 1:
-		case 0:
-		default: return_VALUE(-ENODEV);
-		}
-	}
-
-	return_VALUE(0);
-}
-
-
-static void __exit
-acpi_bus_exit (void)
-{
-	acpi_status		status = AE_OK;
-
-	ACPI_FUNCTION_TRACE("acpi_bus_exit");
-
-	status = acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
-		ACPI_SYSTEM_NOTIFY, acpi_bus_notify);
-	if (ACPI_FAILURE(status))
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error removing notify handler\n"));
-
-#ifdef CONFIG_ACPI_PCI
-	acpi_pci_root_exit();
-	acpi_pci_link_exit();
-#endif
-#ifdef CONFIG_ACPI_EC
-	acpi_ec_exit();
-#endif
-	acpi_power_exit();
-	acpi_system_exit();
-
-	acpi_bus_remove(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
-
-	remove_proc_entry(ACPI_BUS_FILE_ROOT, NULL);
-
-	status = acpi_terminate();
-	if (ACPI_FAILURE(status))
-		printk(KERN_ERR PREFIX "Unable to terminate the ACPI Interpreter\n");
-	else
-		printk(KERN_ERR PREFIX "Interpreter disabled\n");
-
-	return_VOID;
-}
-
-
-int __init
-acpi_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_init");
-
-	printk(KERN_INFO PREFIX "Bus Driver revision %08x\n",
-		ACPI_DRIVER_VERSION);
-	printk(KERN_INFO PREFIX "Core Subsystem revision %08x\n",
-		ACPI_CA_VERSION);
-
-	/* Initial core debug level excludes drivers, so include them now */
-	acpi_set_debug(ACPI_DEBUG_LOW);
-
-	if (acpi_disabled) {
-		printk(KERN_INFO PREFIX "Disabled via command line (acpi=off)\n");
-		return -ENODEV;
-	}
-
-#ifdef CONFIG_PM
-	if (PM_IS_ACTIVE()) {
-		printk(KERN_INFO PREFIX "APM is already active, exiting\n");
-		return -ENODEV;
-	}
-#endif
-
-	result = acpi_bus_init();
-	if (0 != result)
-		return_VALUE(result);
-
-#ifdef CONFIG_PM
-	pm_active = 1;
-#endif
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_exit (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_exit");
-
-#ifdef CONFIG_PM
-	pm_active = 0;
-#endif
-
-	acpi_bus_exit();
-
-	return_VOID;
-}
-
-
-int __init
-acpi_setup(char *str)
-{
-	while (str && *str) {
-		if (strncmp(str, "off", 3) == 0)
-			acpi_disabled = 1;
-		str = strchr(str, ',');
-		if (str)
-			str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-subsys_initcall(acpi_init);
-#endif
-
-__setup("acpi=", acpi_setup);
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_bus.h linux/drivers/acpi/acpi_bus.h
--- ../prev/linux/drivers/acpi/acpi_bus.h	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/acpi_bus.h	Fri May 31 11:41:56 2002
@@ -1,5 +1,5 @@
 /*
- *  acpi_bus.h - ACPI Bus Driver ($Revision: 19 $)
+ *  acpi_bus.h - ACPI Bus Driver ($Revision: 21 $)
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
@@ -56,9 +56,7 @@
 #include <linux/proc_fs.h>
 
 #define ACPI_BUS_FILE_ROOT	"acpi"
-
 extern struct proc_dir_entry	*acpi_root_dir;
-
 extern FADT_DESCRIPTOR		acpi_fadt;
 
 enum acpi_bus_removal_type {
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_button.c linux/drivers/acpi/acpi_button.c
--- ../prev/linux/drivers/acpi/acpi_button.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_button.c	Wed Dec 31 17:00:00 1969
@@ -1,411 +0,0 @@
-/*
- *  acpi_button.c - ACPI Button Driver ($Revision: 24 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_BUTTON_COMPONENT
-ACPI_MODULE_NAME		("acpi_button")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_BUTTON_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-#define PREFIX			"ACPI: "
-
-
-int acpi_button_add (struct acpi_device *device);
-int acpi_button_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_button_driver = {
-	name:			ACPI_BUTTON_DRIVER_NAME,
-	class:			ACPI_BUTTON_CLASS,
-	ids:			"ACPI_FPB,ACPI_FSB,PNP0C0D,PNP0C0C,PNP0C0E",
-	ops:			{
-					add:	acpi_button_add,
-					remove:	acpi_button_remove,
-				},
-};
-
-struct acpi_button {
-	acpi_handle		handle;
-	struct acpi_device	*device;	/* Fixed button kludge */
-	u8			type;
-	unsigned long		pushed;
-};
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-static struct proc_dir_entry	*acpi_button_dir = NULL;
-
-
-static int
-acpi_button_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_button	*button = (struct acpi_button *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_button_read_info");
-
-	if (!button || !button->device)
-		goto end;
-
-	p += sprintf(p, "type:                    %s\n", 
-		acpi_device_name(button->device));
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_button_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-	struct acpi_button	*button = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_button_add_fs");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	button = acpi_driver_data(device);
-
-	if (!acpi_button_dir) {
-		acpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);
-		if (!acpi_button_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	switch (button->type) {
-	case ACPI_BUTTON_TYPE_POWER:
-	case ACPI_BUTTON_TYPE_POWERF:
-		entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_POWER, 
-			acpi_button_dir);
-		break;
-	case ACPI_BUTTON_TYPE_SLEEP:
-	case ACPI_BUTTON_TYPE_SLEEPF:
-		entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_SLEEP, 
-			acpi_button_dir);
-		break;
-	case ACPI_BUTTON_TYPE_LID:
-		entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, 
-			acpi_button_dir);
-		break;
-	}
-
-	acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), entry);
-	if (!acpi_device_dir(device))
-		return_VALUE(-ENODEV);
-
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_BUTTON_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_BUTTON_FILE_INFO));
-	else {
-		entry->read_proc = acpi_button_read_info;
-		entry->data = acpi_driver_data(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_button_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_button_remove_fs");
-
-	if (!acpi_button_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_button_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Driver Interface
-   -------------------------------------------------------------------------- */
-
-void
-acpi_button_notify (
-	acpi_handle		handle,
-	u32			event,
-	void			*data)
-{
-	struct acpi_button	*button = (struct acpi_button *) data;
-
-	ACPI_FUNCTION_TRACE("acpi_button_notify");
-
-	if (!button || !button->device)
-		return_VOID;
-
-	switch (event) {
-	case ACPI_BUTTON_NOTIFY_STATUS:
-		acpi_bus_generate_event(button->device, event, ++button->pushed);
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
-		break;
-	}
-
-	return_VOID;
-}
-
-
-acpi_status
-acpi_button_notify_fixed (
-	void			*data)
-{
-	struct acpi_button	*button = (struct acpi_button *) data;
-	
-	ACPI_FUNCTION_TRACE("acpi_button_notify_fixed");
-
-	if (!button)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	acpi_button_notify(button->handle, ACPI_BUTTON_NOTIFY_STATUS, button);
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-int
-acpi_button_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_button	*button = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_button_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	button = kmalloc(sizeof(struct acpi_button), GFP_KERNEL);
-	if (!button)
-		return_VALUE(-ENOMEM);
-	memset(button, 0, sizeof(struct acpi_button));
-
-	button->device = device;
-	button->handle = device->handle;
-	acpi_driver_data(device) = button;
-
-	/*
-	 * Determine the button type (via hid), as fixed-feature buttons
-	 * need to be handled a bit differently than generic-space.
-	 */
-	if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWER)) {
-		button->type = ACPI_BUTTON_TYPE_POWER;
-		sprintf(acpi_device_name(device), "%s",
-			ACPI_BUTTON_DEVICE_NAME_POWER);
-		sprintf(acpi_device_class(device), "%s/%s", 
-			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);
-	}
-	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWERF)) {
-		button->type = ACPI_BUTTON_TYPE_POWERF;
-		sprintf(acpi_device_name(device), "%s",
-			ACPI_BUTTON_DEVICE_NAME_POWERF);
-		sprintf(acpi_device_class(device), "%s/%s", 
-			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);
-	}
-	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEP)) {
-		button->type = ACPI_BUTTON_TYPE_SLEEP;
-		sprintf(acpi_device_name(device), "%s",
-			ACPI_BUTTON_DEVICE_NAME_SLEEP);
-		sprintf(acpi_device_class(device), "%s/%s", 
-			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);
-	}
-	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEPF)) {
-		button->type = ACPI_BUTTON_TYPE_SLEEPF;
-		sprintf(acpi_device_name(device), "%s",
-			ACPI_BUTTON_DEVICE_NAME_SLEEPF);
-		sprintf(acpi_device_class(device), "%s/%s", 
-			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);
-	}
-	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_LID)) {
-		button->type = ACPI_BUTTON_TYPE_LID;
-		sprintf(acpi_device_name(device), "%s",
-			ACPI_BUTTON_DEVICE_NAME_LID);
-		sprintf(acpi_device_class(device), "%s/%s", 
-			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_LID);
-	}
-	else {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unsupported hid [%s]\n",
-			acpi_device_hid(device)));
-		result = -ENODEV;
-		goto end;
-	}
-
-	result = acpi_button_add_fs(device);
-	if (0 != result)
-		goto end;
-
-	switch (button->type) {
-	case ACPI_BUTTON_TYPE_POWERF:
-		status = acpi_install_fixed_event_handler (
-			ACPI_EVENT_POWER_BUTTON,
-			acpi_button_notify_fixed,
-			button);
-		break;
-	case ACPI_BUTTON_TYPE_SLEEPF:
-		status = acpi_install_fixed_event_handler (
-			ACPI_EVENT_SLEEP_BUTTON,
-			acpi_button_notify_fixed,
-			button);
-		break;
-	default:
-		status = acpi_install_notify_handler (
-			button->handle,
-			ACPI_DEVICE_NOTIFY,
-			acpi_button_notify,
-			button);
-		break;
-	}
-
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error installing notify handler\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	printk(KERN_INFO PREFIX "%s [%s]\n", 
-		acpi_device_name(device), acpi_device_bid(device));
-
-end:
-	if (0 != result) {
-		acpi_button_remove_fs(device);
-		kfree(button);
-	}
-
-	return_VALUE(result);
-}
-
-
-int
-acpi_button_remove (struct acpi_device *device, int type)
-{
-	acpi_status		status = 0;
-	struct acpi_button	*button = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_button_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	button = acpi_driver_data(device);
-
-	/* Unregister for device notifications. */
-	switch (button->type) {
-	case ACPI_BUTTON_TYPE_POWERF:
-		status = acpi_remove_fixed_event_handler(
-			ACPI_EVENT_POWER_BUTTON, acpi_button_notify_fixed);
-		break;
-	case ACPI_BUTTON_TYPE_SLEEPF:
-		status = acpi_remove_fixed_event_handler(
-			ACPI_EVENT_SLEEP_BUTTON, acpi_button_notify_fixed);
-		break;
-	default:
-		status = acpi_remove_notify_handler(button->handle,
-			ACPI_DEVICE_NOTIFY, acpi_button_notify);
-		break;
-	}
-
-	if (ACPI_FAILURE(status))
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error removing notify handler\n"));
-
-	acpi_button_remove_fs(device);	
-
-	kfree(button);
-
-	return_VALUE(0);
-}
-
-
-static int __init
-acpi_button_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_button_init");
-
-	result = acpi_bus_register_driver(&acpi_button_driver);
-	if (0 > result)
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-static void __exit
-acpi_button_exit (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_button_exit");
-
-	acpi_bus_unregister_driver(&acpi_button_driver);
-
-	return_VOID;
-}
-
-
-module_init(acpi_button_init);
-module_exit(acpi_button_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_drivers.h linux/drivers/acpi/acpi_drivers.h
--- ../prev/linux/drivers/acpi/acpi_drivers.h	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/acpi_drivers.h	Fri May 31 11:41:56 2002
@@ -1,5 +1,5 @@
 /*
- *  acpi_drivers.h  ($Revision: 23 $)
+ *  acpi_drivers.h  ($Revision: 29 $)
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
@@ -30,7 +30,6 @@
 #include "acpi_bus.h"
 
 
-#define ACPI_DRIVER_VERSION		0x20020404
 #define ACPI_MAX_STRING			80
 
 
@@ -148,41 +147,53 @@
                                        PCI
    -------------------------------------------------------------------------- */
 
-#define ACPI_PCI_LINK_COMPONENT		0x00400000
-#define ACPI_PCI_LINK_CLASS		"irq_routing"
-#define ACPI_PCI_LINK_HID		"PNP0C0F"
-#define ACPI_PCI_LINK_DRIVER_NAME	"ACPI PCI Interrupt Link Driver"
-#define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
-#define ACPI_PCI_LINK_FILE_INFO		"info"
-#define ACPI_PCI_LINK_FILE_STATUS	"state"
+#ifdef CONFIG_ACPI_PCI
 
-#define ACPI_PCI_ROOT_COMPONENT		0x00800000
-#define ACPI_PCI_ROOT_CLASS		"bridge"
+#define ACPI_PCI_COMPONENT		0x00400000
+
+/* ACPI PCI Root Bridge (pci_root.c) */
+
+#define ACPI_PCI_ROOT_CLASS		"pci_bridge"
 #define ACPI_PCI_ROOT_HID		"PNP0A03"
 #define ACPI_PCI_ROOT_DRIVER_NAME	"ACPI PCI Root Bridge Driver"
 #define ACPI_PCI_ROOT_DEVICE_NAME	"PCI Root Bridge"
 
-#define ACPI_PCI_PRT_DEVICE_NAME	"PCI Interrupt Routing Table"
+int acpi_pci_root_init (void);
+void acpi_pci_root_exit (void);
 
-#ifdef CONFIG_ACPI_PCI
+/* ACPI PCI Interrupt Link (pci_link.c) */
 
+#define ACPI_PCI_LINK_CLASS		"pci_irq_routing"
+#define ACPI_PCI_LINK_HID		"PNP0C0F"
+#define ACPI_PCI_LINK_DRIVER_NAME	"ACPI PCI Interrupt Link Driver"
+#define ACPI_PCI_LINK_DEVICE_NAME	"PCI Interrupt Link"
+#define ACPI_PCI_LINK_FILE_INFO		"info"
+#define ACPI_PCI_LINK_FILE_STATUS	"state"
 
-int acpi_pci_link_get_irq (struct acpi_prt_entry *entry, int *irq);
-int acpi_pci_link_set_irq (struct acpi_prt_entry *entry, int irq);
+int acpi_pci_link_check (void);
+int acpi_pci_link_get_irq (acpi_handle handle, int index);
 int acpi_pci_link_init (void);
 void acpi_pci_link_exit (void);
 
-int acpi_pci_root_init (void);
-void acpi_pci_root_exit (void);
+/* ACPI PCI Interrupt Routing (pci_irq.c) */
 
-#endif
+int acpi_pci_irq_add_prt (acpi_handle handle, int segment, int bus);
+
+/* ACPI PCI Device Binding (pci_bind.c) */
+
+struct pci_bus;
+
+int acpi_pci_bind (struct acpi_device *device);
+int acpi_pci_bind_root (struct acpi_device *device, acpi_pci_id *id, struct pci_bus *bus);
+
+#endif /*CONFIG_ACPI_PCI*/
 
 
 /* --------------------------------------------------------------------------
                                   Power Resource
    -------------------------------------------------------------------------- */
 
-#define ACPI_POWER_COMPONENT		0x01000000
+#define ACPI_POWER_COMPONENT		0x00800000
 #define ACPI_POWER_CLASS		"power_resource"
 #define ACPI_POWER_HID			"ACPI_PWR"
 #define ACPI_POWER_DRIVER_NAME		"ACPI Power Resource Driver"
@@ -207,7 +218,7 @@
                                     Processor
    -------------------------------------------------------------------------- */
 
-#define ACPI_PROCESSOR_COMPONENT	0x02000000
+#define ACPI_PROCESSOR_COMPONENT	0x01000000
 #define ACPI_PROCESSOR_CLASS		"processor"
 #define ACPI_PROCESSOR_HID		"ACPI_CPU"
 #define ACPI_PROCESSOR_DRIVER_NAME	"ACPI Processor Driver"
@@ -230,7 +241,7 @@
                                      System
    -------------------------------------------------------------------------- */
 
-#define ACPI_SYSTEM_COMPONENT		0x04000000
+#define ACPI_SYSTEM_COMPONENT		0x02000000
 #define ACPI_SYSTEM_CLASS		"system"
 #define ACPI_SYSTEM_HID			"ACPI_SYS"
 #define ACPI_SYSTEM_DRIVER_NAME		"ACPI System Driver"
@@ -256,7 +267,7 @@
                                  Thermal Zone
    -------------------------------------------------------------------------- */
 
-#define ACPI_THERMAL_COMPONENT		0x08000000
+#define ACPI_THERMAL_COMPONENT		0x04000000
 #define ACPI_THERMAL_CLASS		"thermal_zone"
 #define ACPI_THERMAL_HID		"ACPI_THM"
 #define ACPI_THERMAL_DRIVER_NAME	"ACPI Thermal Zone Driver"
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_ec.c linux/drivers/acpi/acpi_ec.c
--- ../prev/linux/drivers/acpi/acpi_ec.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_ec.c	Wed Dec 31 17:00:00 1969
@@ -1,736 +0,0 @@
-/*
- *  acpi_ec.c - ACPI Embedded Controller Driver ($Revision: 28 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/delay.h>
-#include <asm/io.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_EC_COMPONENT
-ACPI_MODULE_NAME		("acpi_ec")
-
-#define PREFIX			"ACPI: "
-
-
-#define ACPI_EC_FLAG_OBF	0x01	/* Output buffer full */
-#define ACPI_EC_FLAG_IBF	0x02	/* Input buffer full */
-#define ACPI_EC_FLAG_SCI	0x20	/* EC-SCI occurred */
-
-#define ACPI_EC_EVENT_OBF	0x01	/* Output buffer full */
-#define ACPI_EC_EVENT_IBE	0x02	/* Input buffer empty */
-
-#define ACPI_EC_UDELAY		100	/* Poll @ 100us increments */
-#define ACPI_EC_UDELAY_COUNT	1000	/* Wait 10ms max. during EC ops */
-#define ACPI_EC_UDELAY_GLK	1000	/* Wait 1ms max. to get global lock */
-
-#define ACPI_EC_COMMAND_READ	0x80
-#define ACPI_EC_COMMAND_WRITE	0x81
-#define ACPI_EC_COMMAND_QUERY	0x84
-
-static int acpi_ec_add (struct acpi_device *device);
-static int acpi_ec_remove (struct acpi_device *device, int type);
-static int acpi_ec_start (struct acpi_device *device);
-static int acpi_ec_stop (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_ec_driver = {
-	name:			ACPI_EC_DRIVER_NAME,
-	class:			ACPI_EC_CLASS,
-	ids:			ACPI_EC_HID,
-	ops:			{
-					add:	acpi_ec_add,
-					remove:	acpi_ec_remove,
-					start:	acpi_ec_start,
-					stop:	acpi_ec_stop,
-				},
-};
-
-struct acpi_ec {
-	acpi_handle		handle;
-	unsigned long		gpe_bit;
-	unsigned long		status_port;
-	unsigned long		command_port;
-	unsigned long		data_port;
-	unsigned long		global_lock;
-	spinlock_t		lock;
-};
-
-
-/* --------------------------------------------------------------------------
-                             Transaction Management
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_ec_wait (
-	struct acpi_ec		*ec,
-	u8			event)
-{
-	u8			acpi_ec_status = 0;
-	u32			i = ACPI_EC_UDELAY_COUNT;
-
-	if (!ec)
-		return -EINVAL;
-
-	/* Poll the EC status register waiting for the event to occur. */
-	switch (event) {
-	case ACPI_EC_EVENT_OBF:
-		do {
-			acpi_ec_status = inb(ec->status_port);
-			if (acpi_ec_status & ACPI_EC_FLAG_OBF)
-				return 0;
-			udelay(ACPI_EC_UDELAY);
-		} while (--i>0);
-		break;
-	case ACPI_EC_EVENT_IBE:
-		do {
-			acpi_ec_status = inb(ec->status_port);
-			if (!(acpi_ec_status & ACPI_EC_FLAG_IBF))
-				return 0;
-			udelay(ACPI_EC_UDELAY);
-		} while (--i>0);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return -ETIME;
-}
-
-
-static int
-acpi_ec_read (
-	struct acpi_ec		*ec,
-	u8			address,
-	u8			*data)
-{
-	acpi_status		status = AE_OK;
-	int			result = 0;
-	unsigned long		flags = 0;
-	u32			glk = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_read");
-
-	if (!ec || !data)
-		return_VALUE(-EINVAL);
-
-	*data = 0;
-
-	if (ec->global_lock) {
-		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
-		if (ACPI_FAILURE(status))
-			return_VALUE(-ENODEV);
-	}
-	
-	spin_lock_irqsave(&ec->lock, flags);
-
-	outb(ACPI_EC_COMMAND_READ, ec->command_port);
-	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
-	if (0 != result)
-		goto end;
-
-	outb(address, ec->data_port);
-	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
-	if (0 != result)
-		goto end;
-
-	*data = inb(ec->data_port);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Read [%02x] from address [%02x]\n",
-		*data, address));
-
-end:
-	spin_unlock_irqrestore(&ec->lock, flags);
-
-	if (ec->global_lock)
-		acpi_release_global_lock(glk);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_ec_write (
-	struct acpi_ec		*ec,
-	u8			address,
-	u8			data)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	unsigned long		flags = 0;
-	u32			glk = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_write");
-
-	if (!ec)
-		return_VALUE(-EINVAL);
-
-	if (ec->global_lock) {
-		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
-		if (ACPI_FAILURE(status))
-			return_VALUE(-ENODEV);
-	}
-
-	spin_lock_irqsave(&ec->lock, flags);
-
-	outb(ACPI_EC_COMMAND_WRITE, ec->command_port);
-	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
-	if (0 != result)
-		goto end;
-
-	outb(address, ec->data_port);
-	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
-	if (0 != result)
-		goto end;
-
-	outb(data, ec->data_port);
-	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
-	if (0 != result)
-		goto end;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Wrote [%02x] to address [%02x]\n",
-		data, address));
-
-end:
-	spin_unlock_irqrestore(&ec->lock, flags);
-
-	if (ec->global_lock)
-		acpi_release_global_lock(glk);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_ec_query (
-	struct acpi_ec		*ec,
-	u8			*data)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	unsigned long		flags = 0;
-	u32			glk = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_query");
-
-	if (!ec || !data)
-		return_VALUE(-EINVAL);
-
-	*data = 0;
-
-	if (ec->global_lock) {
-		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
-		if (ACPI_FAILURE(status))
-			return_VALUE(-ENODEV);
-	}
-
-	/*
-	 * Query the EC to find out which _Qxx method we need to evaluate.
-	 * Note that successful completion of the query causes the ACPI_EC_SCI
-	 * bit to be cleared (and thus clearing the interrupt source).
-	 */
-
-	spin_lock_irqsave(&ec->lock, flags);
-
-	outb(ACPI_EC_COMMAND_QUERY, ec->command_port);
-	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
-	if (0 != result)
-		goto end;
-	
-	*data = inb(ec->data_port);
-	if (!*data)
-		result = -ENODATA;
-
-end:
-	spin_unlock_irqrestore(&ec->lock, flags);
-
-	if (ec->global_lock)
-		acpi_release_global_lock(glk);
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Event Management
-   -------------------------------------------------------------------------- */
-
-struct acpi_ec_query_data {
-	acpi_handle		handle;
-	u8			data;
-};
-
-
-static void
-acpi_ec_gpe_query (
-	void			*data)
-{
-	struct acpi_ec_query_data *query_data = NULL;
-	static char		object_name[5] = {'_','Q','0','0','\0'};
-	const char		hex[] = {'0','1','2','3','4','5','6','7',
-				         '8','9','A','B','C','D','E','F'};
-
-	ACPI_FUNCTION_TRACE("acpi_ec_gpe_query");
-
-	if (!data)
-		return;
-
-	query_data = (struct acpi_ec_query_data *) data;
-
-	object_name[2] = hex[((query_data->data >> 4) & 0x0F)];
-	object_name[3] = hex[(query_data->data & 0x0F)];
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluating %s\n", object_name));
-
-	acpi_evaluate(query_data->handle, object_name, NULL, NULL);
-
-	kfree(query_data);
-
-	return;
-}
-
-
-static void
-acpi_ec_gpe_handler (
-	void			*data)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = (struct acpi_ec *) data;
-	u8			value = 0;
-	unsigned long		flags = 0;
-	struct acpi_ec_query_data *query_data = NULL;
-
-	if (!ec)
-		return;
-
-	spin_lock_irqsave(&ec->lock, flags);
-	value = inb(ec->command_port);
-	spin_unlock_irqrestore(&ec->lock, flags);
-
-	/* TBD: Implement asynch events!
-	 * NOTE: All we care about are EC-SCI's.  Other EC events are
-	 *       handled via polling (yuck!).  This is because some systems
-	 *       treat EC-SCIs as level (versus EDGE!) triggered, preventing
-	 *       a purely interrupt-driven approach (grumble, grumble).
-	 */
-
-	if (!(value & ACPI_EC_FLAG_SCI))
-		return;
-
-	if (0 != acpi_ec_query(ec, &value))
-		return;
-
-	query_data = kmalloc(sizeof(struct acpi_ec_query_data), GFP_ATOMIC);
-	if (!query_data)
-		return;
-	query_data->handle = ec->handle;
-	query_data->data = value;
-
-	status = acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
-		acpi_ec_gpe_query, query_data);
-	if (ACPI_FAILURE(status))
-		kfree(query_data);
-
-	return;
-}
-
-
-/* --------------------------------------------------------------------------
-                             Address Space Management
-   -------------------------------------------------------------------------- */
-
-static acpi_status
-acpi_ec_space_setup (
-	acpi_handle		region_handle,
-	u32			function,
-	void			*handler_context,
-	void			**return_context)
-{
-	/*
-	 * The EC object is in the handler context and is needed
-	 * when calling the acpi_ec_space_handler.
-	 */
-	*return_context = handler_context;
-
-	return AE_OK;
-}
-
-
-static acpi_status
-acpi_ec_space_handler (
-	u32			function,
-	ACPI_PHYSICAL_ADDRESS	address,
-	u32			bit_width,
-	acpi_integer		*value,
-	void			*handler_context,
-	void			*region_context)
-{
-	int			result = 0;
-	struct acpi_ec		*ec = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_space_handler");
-
-	if ((address > 0xFF) || (bit_width != 8) || !value || !handler_context)
-		return_VALUE(AE_BAD_PARAMETER);
-
-	ec = (struct acpi_ec *) handler_context;
-
-	switch (function) {
-	case ACPI_READ:
-		result = acpi_ec_read(ec, (u8) address, (u8*) value);
-		break;
-	case ACPI_WRITE:
-		result = acpi_ec_write(ec, (u8) address, (u8) *value);
-		break;
-	default:
-		result = -EINVAL;
-		break;
-	}
-
-	switch (result) {
-	case -EINVAL:
-		return_VALUE(AE_BAD_PARAMETER);
-		break;
-	case -ENODEV:
-		return_VALUE(AE_NOT_FOUND);
-		break;
-	case -ETIME:
-		return_VALUE(AE_TIME);
-		break;
-	default:
-		return_VALUE(AE_OK);
-	}
-
-}
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-struct proc_dir_entry		*acpi_ec_dir = NULL;
-
-
-static int
-acpi_ec_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_ec		*ec = (struct acpi_ec *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_read_info");
-
-	if (!ec || (off != 0))
-		goto end;
-
-	p += sprintf(p, "gpe bit:                 0x%02x\n",
-		(u32) ec->gpe_bit);
-	p += sprintf(p, "ports:                   0x%02x, 0x%02x\n",
-		(u32) ec->status_port, (u32) ec->data_port);
-	p += sprintf(p, "use global lock:         %s\n",
-		ec->global_lock?"yes":"no");
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_ec_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_add_fs");
-
-	if (!acpi_ec_dir) {
-		acpi_ec_dir = proc_mkdir(ACPI_EC_CLASS, acpi_root_dir);
-		if (!acpi_ec_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_ec_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-
-	entry = create_proc_read_entry(ACPI_EC_FILE_INFO, S_IRUGO,
-		acpi_device_dir(device), acpi_ec_read_info,
-		acpi_driver_data(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-			"Unable to create '%s' fs entry\n",
-			ACPI_EC_FILE_INFO));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_ec_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_ec_remove_fs");
-
-	if (!acpi_ec_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_ec_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                               Driver Interface
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_ec_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	ec = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
-	if (!ec)
-		return_VALUE(-ENOMEM);
-	memset(ec, 0, sizeof(struct acpi_ec));
-
-	ec->handle = device->handle;
-	ec->lock = SPIN_LOCK_UNLOCKED;
-	sprintf(acpi_device_name(device), "%s", ACPI_EC_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_EC_CLASS);
-	acpi_driver_data(device) = ec;
-
-	/* Use the global lock for all EC transactions? */
-	acpi_evaluate_integer(ec->handle, "_GLK", NULL, &ec->global_lock);
-
-	/* Get GPE bit assignment (EC events). */
-	status = acpi_evaluate_integer(ec->handle, "_GPE", NULL, &ec->gpe_bit);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error obtaining GPE bit assignment\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	result = acpi_ec_add_fs(device);
-	if (0 != result)
-		goto end;
-
-	printk(KERN_INFO PREFIX "%s [%s] (gpe %d)\n",
-		acpi_device_name(device), acpi_device_bid(device),
-		(u32) ec->gpe_bit);
-
-end:
-	if (0 != result)
-		kfree(ec);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_ec_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	struct acpi_ec		*ec = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_remove");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	ec = (struct acpi_ec *) acpi_driver_data(device);
-
-	acpi_ec_remove_fs(device);
-
-	kfree(ec);
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_ec_start (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = NULL;
-	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_resource		*resource = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_start");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	ec = (struct acpi_ec *) acpi_driver_data(device);
-
-	if (!ec)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * Get I/O port addresses
-	 */
-
-	status = acpi_get_current_resources(ec->handle, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error getting I/O port addresses"));
-		return_VALUE(-ENODEV);
-	}
-
-	resource = (acpi_resource *) buffer.pointer;
-	if (!resource || (resource->id != ACPI_RSTYPE_IO)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid or missing resource\n"));
-		result = -ENODEV;
-		goto end;
-	}
-	ec->data_port = resource->data.io.min_base_address;
-
-	resource = ACPI_NEXT_RESOURCE(resource);
-	if (!resource || (resource->id != ACPI_RSTYPE_IO)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid or missing resource\n"));
-		result = -ENODEV;
-		goto end;
-	}
-	ec->command_port = ec->status_port = resource->data.io.min_base_address;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "gpe=0x%02x, ports=0x%2x,0x%2x\n",
-		(u32) ec->gpe_bit, (u32) ec->command_port, (u32) ec->data_port));
-
-	/*
-	 * Install GPE handler
-	 */
-
-	status = acpi_install_gpe_handler(ec->gpe_bit,
-		ACPI_EVENT_EDGE_TRIGGERED, &acpi_ec_gpe_handler, ec);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	status = acpi_install_address_space_handler (ec->handle,
-			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler,
-			&acpi_ec_space_setup, ec);
-	if (ACPI_FAILURE(status)) {
-		acpi_remove_address_space_handler(ec->handle,
-			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
-		return_VALUE(-ENODEV);
-	}
-end:
-	kfree(buffer.pointer);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_ec_stop (
-	struct acpi_device	*device,
-	int			type)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_ec		*ec = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_stop");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	ec = (struct acpi_ec *) acpi_driver_data(device);
-
-	status = acpi_remove_address_space_handler(ec->handle,
-		ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	status = acpi_remove_gpe_handler(ec->gpe_bit, &acpi_ec_gpe_handler);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-int __init
-acpi_ec_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_init");
-
-	result = acpi_bus_register_driver(&acpi_ec_driver);
-	if (0 > result) {
-		remove_proc_entry(ACPI_EC_CLASS, acpi_root_dir);
-		return_VALUE(-ENODEV);
-	}
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_ec_exit (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_ec_exit");
-
-	result = acpi_bus_unregister_driver(&acpi_ec_driver);
-	if (0 == result)
-		remove_proc_entry(ACPI_EC_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_fan.c linux/drivers/acpi/acpi_fan.c
--- ../prev/linux/drivers/acpi/acpi_fan.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_fan.c	Wed Dec 31 17:00:00 1969
@@ -1,300 +0,0 @@
-/*
- *  acpi_fan.c - ACPI Fan Driver ($Revision: 25 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_FAN_COMPONENT
-ACPI_MODULE_NAME		("acpi_fan")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_FAN_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-#define PREFIX			"ACPI: "
-
-
-int acpi_fan_add (struct acpi_device *device);
-int acpi_fan_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_fan_driver = {
-	name:			ACPI_FAN_DRIVER_NAME,
-	class:			ACPI_FAN_CLASS,
-	ids:			ACPI_FAN_HID,
-	ops:			{
-					add:	acpi_fan_add,
-					remove:	acpi_fan_remove,
-				},
-};
-
-struct acpi_fan {
-	acpi_handle		handle;
-};
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-struct proc_dir_entry		*acpi_fan_dir = NULL;
-
-
-static int
-acpi_fan_read_state (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_fan		*fan = (struct acpi_fan *) data;
-	char			*p = page;
-	int			len = 0;
-	int			state = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_fan_read_state");
-
-	if (!fan || (off != 0))
-		goto end;
-
-	if (0 != acpi_bus_get_power(fan->handle, &state))
-		goto end;
-
-	p += sprintf(p, "status:                  %s\n",
-		!state?"on":"off");
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_fan_write_state (
-	struct file		*file,
-	const char		*buffer,
-	unsigned long		count,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_fan		*fan = (struct acpi_fan *) data;
-	char			state_string[12] = {'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_fan_write_state");
-
-	if (!fan || (count > sizeof(state_string) - 1))
-		return_VALUE(-EINVAL);
-	
-	if (copy_from_user(state_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	state_string[count] = '\0';
-	
-	result = acpi_bus_set_power(fan->handle, 
-		simple_strtoul(state_string, NULL, 0));
-	if (0 != result)
-		return_VALUE(result);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_fan_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_fan_add_fs");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	if (!acpi_fan_dir) {
-		acpi_fan_dir = proc_mkdir(ACPI_FAN_CLASS, acpi_root_dir);
-		if (!acpi_fan_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_fan_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-
-	/* 'status' [R/W] */
-	entry = create_proc_entry(ACPI_FAN_FILE_STATE,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_FAN_FILE_STATE));
-	else {
-		entry->read_proc = acpi_fan_read_state;
-		entry->write_proc = acpi_fan_write_state;
-		entry->data = acpi_driver_data(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_fan_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_fan_remove_fs");
-
-	if (!acpi_fan_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_fan_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Driver Interface
-   -------------------------------------------------------------------------- */
-
-int
-acpi_fan_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	struct acpi_fan		*fan = NULL;
-	int			state = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_fan_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	fan = kmalloc(sizeof(struct acpi_fan), GFP_KERNEL);
-	if (!fan)
-		return_VALUE(-ENOMEM);
-	memset(fan, 0, sizeof(struct acpi_fan));
-
-	fan->handle = device->handle;
-	sprintf(acpi_device_name(device), "%s", ACPI_FAN_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_FAN_CLASS);
-	acpi_driver_data(device) = fan;
-
-	result = acpi_bus_get_power(fan->handle, &state);
-	if (0 != result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error reading power state\n"));
-		goto end;
-	}
-
-	result = acpi_fan_add_fs(device);
-	if (0 != result)
-		goto end;
-
-	printk(KERN_INFO PREFIX "%s [%s] (%s)\n",
-		acpi_device_name(device), acpi_device_bid(device),
-		!device->power.state?"on":"off");
-
-end:
-	if (0 != result)
-		kfree(fan);
-
-	return_VALUE(result);
-}
-
-
-int
-acpi_fan_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	struct acpi_fan		*fan = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_fan_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	fan = (struct acpi_fan *) acpi_driver_data(device);
-
-	acpi_fan_remove_fs(device);
-
-	kfree(fan);
-
-	return_VALUE(0);
-}
-
-
-int __init
-acpi_fan_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_fan_init");
-
-	result = acpi_bus_register_driver(&acpi_fan_driver);
-	if (0 > result)
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_fan_exit (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_fan_exit");
-
-	result = acpi_bus_unregister_driver(&acpi_fan_driver);
-	if (0 == result)
-		remove_proc_entry(ACPI_FAN_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
-
-
-module_init(acpi_fan_init);
-module_exit(acpi_fan_exit);
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_ksyms.c linux/drivers/acpi/acpi_ksyms.c
--- ../prev/linux/drivers/acpi/acpi_ksyms.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/acpi_ksyms.c	Fri May 31 11:41:56 2002
@@ -1,5 +1,5 @@
 /*
- *  acpi_ksyms.c - ACPI Kernel Symbols ($Revision: 13 $)
+ *  acpi_ksyms.c - ACPI Kernel Symbols ($Revision: 14 $)
  *
  *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
  *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
@@ -80,9 +80,9 @@
 EXPORT_SYMBOL(acpi_clear_event);
 EXPORT_SYMBOL(acpi_get_timer_duration);
 EXPORT_SYMBOL(acpi_get_timer);
-EXPORT_SYMBOL(acpi_hw_get_sleep_type_data);
-EXPORT_SYMBOL(acpi_hw_bit_register_read);
-EXPORT_SYMBOL(acpi_hw_bit_register_write);
+EXPORT_SYMBOL(acpi_get_sleep_type_data);
+EXPORT_SYMBOL(acpi_get_register);
+EXPORT_SYMBOL(acpi_set_register);
 EXPORT_SYMBOL(acpi_enter_sleep_state);
 EXPORT_SYMBOL(acpi_get_system_info);
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_osl.c linux/drivers/acpi/acpi_osl.c
--- ../prev/linux/drivers/acpi/acpi_osl.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_osl.c	Wed Dec 31 17:00:00 1969
@@ -1,872 +0,0 @@
-/*
- *  acpi_osl.c - OS-dependent functions ($Revision: 69 $)
- *
- *  Copyright (C) 2000 Andrew Henroid
- *  Copyright (C) 2001 Andrew Grover
- *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/kmod.h>
-#include <linux/delay.h>
-#include <asm/io.h>
-#include "acpi.h"
-
-#ifdef CONFIG_ACPI_EFI
-#include <asm/efi.h>
-#endif
-
-#ifdef _IA64
-#include <asm/hw_irq.h>
-#include <asm/delay.h>
-#endif
-
-
-#define _COMPONENT		ACPI_OS_SERVICES
-ACPI_MODULE_NAME	("osl")
-
-#define PREFIX		"ACPI: "
-
-typedef struct
-{
-    OSD_EXECUTION_CALLBACK  function;
-    void		    *context;
-} ACPI_OS_DPC;
-
-
-#ifdef ENABLE_DEBUGGER
-#include <linux/kdb.h>
-/* stuff for debugger support */
-int acpi_in_debugger = 0;
-extern NATIVE_CHAR line_buf[80];
-#endif /*ENABLE_DEBUGGER*/
-
-static int acpi_irq_irq = 0;
-static OSD_HANDLER acpi_irq_handler = NULL;
-static void *acpi_irq_context = NULL;
-
-
-acpi_status
-acpi_os_initialize(void)
-{
-	/*
-	 * Initialize PCI configuration space access, as we'll need to access
-	 * it while walking the namespace (bus 0 and root bridges w/ _BBNs).
-	 */
-	pcibios_config_init();
-	if (!pci_config_read || !pci_config_write) {
-		printk(KERN_ERR PREFIX "Access to PCI configuration space unavailable\n");
-		return AE_NULL_ENTRY;
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_terminate(void)
-{
-	if (acpi_irq_handler) {
-		acpi_os_remove_interrupt_handler(acpi_irq_irq,
-						 acpi_irq_handler);
-	}
-
-	return AE_OK;
-}
-
-void
-acpi_os_printf(const NATIVE_CHAR *fmt,...)
-{
-	va_list args;
-	va_start(args, fmt);
-	acpi_os_vprintf(fmt, args);
-	va_end(args);
-}
-
-void
-acpi_os_vprintf(const NATIVE_CHAR *fmt, va_list args)
-{
-	static char buffer[512];
-	
-	vsprintf(buffer, fmt, args);
-
-#ifdef ENABLE_DEBUGGER
-	if (acpi_in_debugger) {
-		kdb_printf("%s", buffer);
-	} else {
-		printk("%s", buffer);
-	}
-#else
-	printk("%s", buffer);
-#endif
-}
-
-void *
-acpi_os_allocate(ACPI_SIZE size)
-{
-	return kmalloc(size, GFP_KERNEL);
-}
-
-void *
-acpi_os_callocate(ACPI_SIZE size)
-{
-	void *ptr = acpi_os_allocate(size);
-	if (ptr)
-		memset(ptr, 0, size);
-
-	return ptr;
-}
-
-void
-acpi_os_free(void *ptr)
-{
-	kfree(ptr);
-}
-
-
-acpi_status
-acpi_os_get_root_pointer(u32 flags, ACPI_POINTER *addr)
-{
-#ifndef CONFIG_ACPI_EFI
-	if (ACPI_FAILURE(acpi_find_root_pointer(flags, addr))) {
-		printk(KERN_ERR PREFIX "System description tables not found\n");
-		return AE_NOT_FOUND;
-	}
-#else /*CONFIG_ACPI_EFI*/
-	addr->pointer_type = ACPI_PHYSICAL_POINTER;
-	if (efi.acpi20)
-		addr->pointer.physical = (ACPI_PHYSICAL_ADDRESS) virt_to_phys(efi.acpi20);
-	else if (efi.acpi)
-		addr->pointer.physical = (ACPI_PHYSICAL_ADDRESS) virt_to_phys(efi.acpi);
-	else {
-		printk(KERN_ERR PREFIX "System description tables not found\n");
-		addr->pointer.physical = 0;
-		return AE_NOT_FOUND;
-	}
-#endif /*CONFIG_ACPI_EFI*/
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_map_memory(ACPI_PHYSICAL_ADDRESS phys, ACPI_SIZE size, void **virt)
-{
-#ifdef CONFIG_ACPI_EFI
-	if (!(EFI_MEMORY_WB & efi_mem_attributes(phys))) {
-		*virt = ioremap(phys, size);
-	} else {
-		*virt = phys_to_virt(phys);
-	}
-#else
-	if (phys > ULONG_MAX) {
-		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
-		return AE_BAD_PARAMETER;
-	}
-
-	/*
-	 * ioremap already checks to ensure this is in reserved space
-	 */
-	*virt = ioremap((unsigned long) phys, size);
-#endif
-	if (!*virt)
-		return AE_NO_MEMORY;
-
-	return AE_OK;
-}
-
-void
-acpi_os_unmap_memory(void *virt, ACPI_SIZE size)
-{
-	iounmap(virt);
-}
-
-acpi_status
-acpi_os_get_physical_address(void *virt, ACPI_PHYSICAL_ADDRESS *phys)
-{
-	if(!phys || !virt)
-		return AE_BAD_PARAMETER;
-
-	*phys = virt_to_phys(virt);
-
-	return AE_OK;
-}
-
-static void
-acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
-{
-	(*acpi_irq_handler)(acpi_irq_context);
-}
-
-acpi_status
-acpi_os_install_interrupt_handler(u32 irq, OSD_HANDLER handler, void *context)
-{
-#ifdef _IA64
-	irq = isa_irq_to_vector(irq);
-#endif /*_IA64*/
-	acpi_irq_irq = irq;
-	acpi_irq_handler = handler;
-	acpi_irq_context = context;
-	if (request_irq(irq, acpi_irq, SA_SHIRQ, "acpi", acpi_irq)) {
-		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
-		return AE_NOT_ACQUIRED;
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_remove_interrupt_handler(u32 irq, OSD_HANDLER handler)
-{
-	if (acpi_irq_handler) {
-#ifdef _IA64
-		irq = isa_irq_to_vector(irq);
-#endif /*_IA64*/
-		free_irq(irq, acpi_irq);
-		acpi_irq_handler = NULL;
-	}
-
-	return AE_OK;
-}
-
-/*
- * Running in interpreter thread context, safe to sleep
- */
-
-void
-acpi_os_sleep(u32 sec, u32 ms)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule_timeout(HZ * sec + (ms * HZ) / 1000);
-}
-
-void
-acpi_os_stall(u32 us)
-{
-	if (us > 10000) {
-		mdelay(us / 1000);
-	}
-	else {
-		udelay(us);
-	}
-}
-
-acpi_status
-acpi_os_read_port(
-	ACPI_IO_ADDRESS	port,
-	void		*value,
-	u32		width)
-{
-	u32 dummy;
-
-	if (!value)
-		value = &dummy;
-
-	switch (width)
-	{
-	case 8:
-		*(u8*)  value = inb(port);
-		break;
-	case 16:
-		*(u16*) value = inw(port);
-		break;
-	case 32:
-		*(u32*) value = inl(port);
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_write_port(
-	ACPI_IO_ADDRESS	port,
-	acpi_integer	value,
-	u32		width)
-{
-	switch (width)
-	{
-	case 8:
-		outb(value, port);
-		break;
-	case 16:
-		outw(value, port);
-		break;
-	case 32:
-		outl(value, port);
-		break;
-	default:
-		BUG();
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_read_memory(
-	ACPI_PHYSICAL_ADDRESS	phys_addr,
-	void			*value,
-	u32			width)
-{
-	u32			dummy;
-	int			iomem = 0;
-	void			*virt_addr;
-
-#ifdef CONFIG_ACPI_EFI
-	if (EFI_MEMORY_UC & efi_mem_attributes(phys_addr)) {
-		iomem = 1;
-		virt_addr = ioremap(phys_addr, width);
-	} else {
-		virt_addr = phys_to_virt(phys_addr);
-	}
-#else
-	virt_addr = phys_to_virt(phys_addr);
-#endif
-	if (!value)
-		value = &dummy;
-
-	switch (width)
-	{
-	case 8:
-		*(u8*) value = *(u8*) virt_addr;
-		break;
-	case 16:
-		*(u16*) value = *(u16*) virt_addr;
-		break;
-	case 32:
-		*(u32*) value = *(u32*) virt_addr;
-		break;
-	default:
-		BUG();
-	}
-
-	if (iomem)
-		iounmap(virt_addr);
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_write_memory(
-	ACPI_PHYSICAL_ADDRESS	phys_addr,
-	acpi_integer		value,
-	u32			width)
-{
-	int			iomem = 0;
-	void			*virt_addr;
-
-#ifdef CONFIG_ACPI_EFI
-	if (EFI_MEMORY_UC & efi_mem_attributes(phys_addr)) {
-		iomem = 1;
-		virt_addr = ioremap(phys_addr,width);
-	} else {
-		virt_addr = phys_to_virt(phys_addr);
-	}
-#else
-	virt_addr = phys_to_virt(phys_addr);
-#endif
-
-	switch (width)
-	{
-	case 8:
-		*(u8*) virt_addr = value;
-		break;
-	case 16:
-		*(u16*) virt_addr = value;
-		break;
-	case 32:
-		*(u32*) virt_addr = value;
-		break;
-	default:
-		BUG();
-	}
-
-	if (iomem)
-		iounmap(virt_addr);
-
-	return AE_OK;
-}
-
-
-acpi_status
-acpi_os_read_pci_configuration (
-	acpi_pci_id             *pci_id,
-	u32                     reg,
-	void                    *value,
-	u32                     width)
-{
-	int			result = 0;
-	if (!value)
-		return AE_BAD_PARAMETER;
-
-	switch (width)
-	{
-	case 8:
-		result = pci_config_read(pci_id->segment, pci_id->bus,
-			pci_id->device, pci_id->function, reg, 1, value);
-		break;
-	case 16:
-		result = pci_config_read(pci_id->segment, pci_id->bus,
-			pci_id->device, pci_id->function, reg, 2, value);
-		break;
-	case 32:
-		result = pci_config_read(pci_id->segment, pci_id->bus,
-			pci_id->device, pci_id->function, reg, 4, value);
-		break;
-	default:
-		BUG();
-	}
-
-	return (result ? AE_ERROR : AE_OK);
-}
-
-acpi_status
-acpi_os_write_pci_configuration (
-	acpi_pci_id             *pci_id,
-	u32                     reg,
-	acpi_integer            value,
-	u32                     width)
-{
-	int			result = 0;
-
-	switch (width)
-	{
-	case 8:
-		result = pci_config_write(pci_id->segment, pci_id->bus,
-			pci_id->device, pci_id->function, reg, 1, value);
-		break;
-	case 16:
-		result = pci_config_write(pci_id->segment, pci_id->bus,
-			pci_id->device, pci_id->function, reg, 2, value);
-		break;
-	case 32:
-		result = pci_config_write(pci_id->segment, pci_id->bus,
-			pci_id->device, pci_id->function, reg, 4, value);
-		break;
-	default:
-		BUG();
-	}
-
-	return (result ? AE_ERROR : AE_OK);
-}
-
-
-acpi_status
-acpi_os_load_module (
-	char *module_name)
-{
-	ACPI_FUNCTION_TRACE ("os_load_module");
-
-	if (!module_name)
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-
-	if (0 > request_module(module_name)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to load module [%s].\n", module_name));
-		return_ACPI_STATUS (AE_ERROR);
-	}
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-acpi_status
-acpi_os_unload_module (
-	char *module_name)
-{
-	if (!module_name)
-		return AE_BAD_PARAMETER;
-
-	/* TODO: How on Linux? */
-	/* this is done automatically for all modules with
-	use_count = 0, I think. see: MOD_INC_USE_COUNT -ASG */
-
-	return AE_OK;
-}
-
-
-/*
- * See acpi_os_queue_for_execution()
- */
-static int
-acpi_os_queue_exec (
-	void *context)
-{
-	ACPI_OS_DPC		*dpc = (ACPI_OS_DPC*)context;
-
-	ACPI_FUNCTION_TRACE ("os_queue_exec");
-
-	daemonize();
-	strcpy(current->comm, "kacpidpc");
-
-	if (!dpc || !dpc->function)
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Executing function [%p(%p)].\n", dpc->function, dpc->context));
-
-	dpc->function(dpc->context);
-
-	kfree(dpc);
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-static void
-acpi_os_schedule_exec (
-	void *context)
-{
-	ACPI_OS_DPC		*dpc = NULL;
-	int			thread_pid = -1;
-
-	ACPI_FUNCTION_TRACE ("os_schedule_exec");
-
-	dpc = (ACPI_OS_DPC*)context;
-	if (!dpc) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return_VOID;
-	}
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Creating new thread to run function [%p(%p)].\n", dpc->function, dpc->context));
-
-	thread_pid = kernel_thread(acpi_os_queue_exec, dpc,
-		(CLONE_FS | CLONE_FILES | SIGCHLD));
-	if (thread_pid < 0) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to kernel_thread() failed.\n"));
-		acpi_os_free(dpc);
-	}
-    return_VOID;
-}
-
-acpi_status
-acpi_os_queue_for_execution(
-	u32			priority,
-	OSD_EXECUTION_CALLBACK	function,
-	void			*context)
-{
-	acpi_status 		status = AE_OK;
-	ACPI_OS_DPC 		*dpc = NULL;
-
-	ACPI_FUNCTION_TRACE ("os_queue_for_execution");
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Scheduling function [%p(%p)] for deferred execution.\n", function, context));
-
-	if (!function)
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-
-	/*
-	 * Queue via DPC:
-	 * --------------
-	 * Note that we have to use two different processes for queuing DPCs:
-	 *	 Interrupt-Level: Use schedule_task; can't spawn a new thread.
-	 *	    Kernel-Level: Spawn a new kernel thread, as schedule_task has
-	 *			  its limitations (e.g. single-threaded model), and
-	 *			  all other task queues run at interrupt-level.
-	 */
-	switch (priority) {
-
-	case OSD_PRIORITY_GPE:
-	{
-		static struct tq_struct task;
-
-		/*
-		 * Allocate/initialize DPC structure.  Note that this memory will be
-		 * freed by the callee.
-		 */
-		dpc = kmalloc(sizeof(ACPI_OS_DPC), GFP_ATOMIC);
-		if (!dpc)
-			return_ACPI_STATUS (AE_NO_MEMORY);
-
-		dpc->function = function;
-		dpc->context = context;
-
-		memset(&task, 0, sizeof(struct tq_struct));
-
-		task.routine = acpi_os_schedule_exec;
-		task.data = (void*)dpc;
-
-		if (schedule_task(&task) < 0) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to schedule_task() failed.\n"));
-			status = AE_ERROR;
-		}
-	}
-	break;
-
-	default:
-		/*
-		 * Allocate/initialize DPC structure.  Note that this memory will be
-		 * freed by the callee.
-		 */
-		dpc = kmalloc(sizeof(ACPI_OS_DPC), GFP_KERNEL);
-		if (!dpc)
-			return_ACPI_STATUS (AE_NO_MEMORY);
-
-		dpc->function = function;
-		dpc->context = context;
-
-		acpi_os_schedule_exec(dpc);
-		break;
-	}
-
-	return_ACPI_STATUS (status);
-}
-
-
-acpi_status
-acpi_os_create_semaphore(
-	u32		max_units,
-	u32		initial_units,
-	acpi_handle	*handle)
-{
-	struct semaphore	*sem = NULL;
-
-	ACPI_FUNCTION_TRACE ("os_create_semaphore");
-
-	sem = acpi_os_callocate(sizeof(struct semaphore));
-	if (!sem)
-		return_ACPI_STATUS (AE_NO_MEMORY);
-
-	sema_init(sem, initial_units);
-
-	*handle = (acpi_handle*)sem;
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Creating semaphore[%p|%d].\n", *handle, initial_units));
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-
-/*
- * TODO: A better way to delete semaphores?  Linux doesn't have a
- * 'delete_semaphore()' function -- may result in an invalid
- * pointer dereference for non-synchronized consumers.	Should
- * we at least check for blocked threads and signal/cancel them?
- */
-
-acpi_status
-acpi_os_delete_semaphore(
-	acpi_handle	handle)
-{
-	struct semaphore *sem = (struct semaphore*) handle;
-
-	ACPI_FUNCTION_TRACE ("os_delete_semaphore");
-
-	if (!sem)
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Deleting semaphore[%p].\n", handle));
-
-	acpi_os_free(sem); sem =  NULL;
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-
-/*
- * TODO: The kernel doesn't have a 'down_timeout' function -- had to
- * improvise.  The process is to sleep for one scheduler quantum
- * until the semaphore becomes available.  Downside is that this
- * may result in starvation for timeout-based waits when there's
- * lots of semaphore activity.
- *
- * TODO: Support for units > 1?
- */
-acpi_status
-acpi_os_wait_semaphore(
-	acpi_handle		handle,
-	u32			units,
-	u32			timeout)
-{
-	acpi_status		status = AE_OK;
-	struct semaphore	*sem = (struct semaphore*)handle;
-	int			ret = 0;
-
-	ACPI_FUNCTION_TRACE ("os_wait_semaphore");
-
-	if (!sem || (units < 1))
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-
-	if (units > 1)
-		return_ACPI_STATUS (AE_SUPPORT);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Waiting for semaphore[%p|%d|%d]\n", handle, units, timeout));
-
-	switch (timeout)
-	{
-		/*
-		 * No Wait:
-		 * --------
-		 * A zero timeout value indicates that we shouldn't wait - just
-		 * acquire the semaphore if available otherwise return AE_TIME
-		 * (a.k.a. 'would block').
-		 */
-		case 0:
-		if(down_trylock(sem))
-			status = AE_TIME;
-		break;
-
-		/*
-		 * Wait Indefinitely:
-		 * ------------------
-		 */
-		case WAIT_FOREVER:
-		ret = down_interruptible(sem);
-		if (ret < 0)
-			status = AE_ERROR;
-		break;
-
-		/*
-		 * Wait w/ Timeout:
-		 * ----------------
-		 */
-		default:
-		// TODO: A better timeout algorithm?
-		{
-			int i = 0;
-			static const int quantum_ms = 1000/HZ;
-
-			ret = down_trylock(sem);
-			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
-				current->state = TASK_INTERRUPTIBLE;
-				schedule_timeout(1);
-				ret = down_trylock(sem);
-			}
-	
-			if (ret != 0)
-			 status = AE_TIME;
-			}
-		break;
-	}
-
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Failed to acquire semaphore[%p|%d|%d]\n", handle, units, timeout));
-	}
-	else {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Acquired semaphore[%p|%d|%d]\n", handle, units, timeout));
-	}
-
-	return_ACPI_STATUS (status);
-}
-
-
-/*
- * TODO: Support for units > 1?
- */
-acpi_status
-acpi_os_signal_semaphore(
-    acpi_handle 	    handle,
-    u32 		    units)
-{
-	struct semaphore *sem = (struct semaphore *) handle;
-
-	ACPI_FUNCTION_TRACE ("os_signal_semaphore");
-
-	if (!sem || (units < 1))
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
-
-	if (units > 1)
-		return_ACPI_STATUS (AE_SUPPORT);
-
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Signaling semaphore[%p|%d]\n", handle, units));
-
-	up(sem);
-
-	return_ACPI_STATUS (AE_OK);
-}
-
-u32
-acpi_os_get_line(NATIVE_CHAR *buffer)
-{
-
-#ifdef ENABLE_DEBUGGER
-	if (acpi_in_debugger) {
-		u32 chars;
-
-		kdb_read(buffer, sizeof(line_buf));
-
-		/* remove the CR kdb includes */
-		chars = strlen(buffer) - 1;
-		buffer[chars] = '\0';
-	}
-#endif
-
-	return 0;
-}
-
-/*
- * We just have to assume we're dealing with valid memory
- */
-
-BOOLEAN
-acpi_os_readable(void *ptr, u32 len)
-{
-	return 1;
-}
-
-BOOLEAN
-acpi_os_writable(void *ptr, u32 len)
-{
-	return 1;
-}
-
-u32
-acpi_os_get_thread_id (void)
-{
-	if (!in_interrupt())
-		return current->pid;
-
-	return 0;
-}
-
-acpi_status
-acpi_os_signal (
-    u32		function,
-    void	*info)
-{
-	switch (function)
-	{
-	case ACPI_SIGNAL_FATAL:
-		printk(KERN_ERR PREFIX "Fatal opcode executed\n");
-		break;
-	case ACPI_SIGNAL_BREAKPOINT:
-		{
-			char *bp_info = (char*) info;
-
-			printk(KERN_ERR "ACPI breakpoint: %s\n", bp_info);
-		}
-	default:
-		break;
-	}
-
-	return AE_OK;
-}
-
-acpi_status
-acpi_os_breakpoint(NATIVE_CHAR *msg)
-{
-	acpi_os_printf("breakpoint: %s", msg);
-	
-	return AE_OK;
-}
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_pci_link.c linux/drivers/acpi/acpi_pci_link.c
--- ../prev/linux/drivers/acpi/acpi_pci_link.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_pci_link.c	Wed Dec 31 17:00:00 1969
@@ -1,588 +0,0 @@
-/*
- *  acpi_pci_link.c - ACPI PCI Interrupt Link Device Driver ($Revision: 22 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * TBD: 
- *      1. Support more than one IRQ resource entry per link device.
- *	2. Implement start/stop mechanism and use ACPI Bus Driver facilities
- *	   for IRQ management (e.g. start()->_SRS).
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <linux/spinlock.h>
-#include <linux/pm.h>
-#include <linux/pci.h>
-
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_PCI_LINK_COMPONENT
-ACPI_MODULE_NAME		("acpi_pci_link")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_PCI_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-#define PREFIX			"ACPI: "
-
-#define ACPI_PCI_LINK_MAX_IRQS	16
-
-
-static int acpi_pci_link_add (struct acpi_device *device);
-static int acpi_pci_link_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_pci_link_driver = {
-        name:                   ACPI_PCI_LINK_DRIVER_NAME,
-        class:                  ACPI_PCI_LINK_CLASS,
-        ids:                    ACPI_PCI_LINK_HID,
-        ops:                    {
-                                        add:    acpi_pci_link_add,
-                                        remove: acpi_pci_link_remove,
-                                },
-};
-
-struct acpi_pci_link_irq {
-	u8			active;			/* Current IRQ */
-	u8			possible_count;
-	u8			possible[ACPI_PCI_LINK_MAX_IRQS];
-	struct {
-		u8			valid:1;
-		u8			enabled:1;
-		u8			shareable:1;	/* 0 = Exclusive */
-		u8			polarity:1;	/* 0 = Active-High */
-		u8			trigger:1;	/* 0 = Level-Triggered */
-		u8			producer:1;	/* 0 = Consumer-Only */
-		u8			reserved:2;
-	}			flags;
-};
-
-struct acpi_pci_link {
-	acpi_handle		handle;
-	struct acpi_pci_link_irq irq;
-};
-
-
-/* --------------------------------------------------------------------------
-                            PCI Link Device Management
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_pci_link_get_possible (
-	struct acpi_pci_link	*link)
-{
-	int                     result = 0;
-	acpi_status		status = AE_OK;
-	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_resource		*resource = NULL;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_get_possible");
-
-	if (!link)
-		return_VALUE(-EINVAL);
-
-	status = acpi_get_possible_resources(link->handle, &buffer);
-	if (ACPI_FAILURE(status) || !buffer.pointer) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRS\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	resource = (acpi_resource *) buffer.pointer;
-
-	switch (resource->id) {
-	case ACPI_RSTYPE_IRQ:
-	{
-		acpi_resource_irq *p = &resource->data.irq;
-
-		if (!p || !p->number_of_interrupts) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-				"Blank IRQ resource\n"));
-			result = -ENODEV;
-			goto end;
-		}
-
-		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_IRQS); i++) {
-			link->irq.possible[i] = p->interrupts[i];
-			link->irq.possible_count++;
-		}
-
-		link->irq.flags.trigger = p->edge_level;
-		link->irq.flags.polarity = p->active_high_low;
-		link->irq.flags.shareable = p->shared_exclusive;
-
-		break;
-	}
-	case ACPI_RSTYPE_EXT_IRQ:
-	{
-		acpi_resource_ext_irq *p = &resource->data.extended_irq;
-
-		if (!p || !p->number_of_interrupts) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-				"Blank IRQ resource\n"));
-			result = -ENODEV;
-			goto end;
-		}
-
-		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_IRQS); i++) {
-			link->irq.possible[i] = p->interrupts[i];
-			link->irq.possible_count++;
-		}
-
-		link->irq.flags.trigger = p->edge_level;
-		link->irq.flags.polarity = p->active_high_low;
-		link->irq.flags.shareable = p->shared_exclusive;
-
-		break;
-	}
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Resource is not an IRQ entry\n"));
-		result = -ENODEV;
-		goto end;
-		break;
-	}
-	
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Found %d possible IRQs\n", link->irq.possible_count));
-
-end:
-	kfree(buffer.pointer);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_pci_link_get_current (
-	struct acpi_pci_link	*link)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_resource		*resource = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_get_current");
-
-	if (!link || !link->handle)
-		return_VALUE(-EINVAL);
-
-	link->irq.active = 0;
-
-	status = acpi_get_current_resources(link->handle, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _CRS\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	resource = (acpi_resource *) buffer.pointer;
-
-	switch (resource->id) {
-	case ACPI_RSTYPE_IRQ:
-	{
-		acpi_resource_irq *p = &resource->data.irq;
-
-		if (!p || !p->number_of_interrupts) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-				"Blank IRQ resource\n"));
-			result = -ENODEV;
-			goto end;
-		}
-
-		link->irq.active = p->interrupts[0];
-
-		break;
-	}
-	case ACPI_RSTYPE_EXT_IRQ:
-	{
-		acpi_resource_ext_irq *p = &resource->data.extended_irq;
-
-		if (!p || !p->number_of_interrupts) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
-				"Blank IRQ resource\n"));
-			result = -ENODEV;
-			goto end;
-		}
-
-		link->irq.active = p->interrupts[0];
-
-		break;
-	}
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Resource is not an IRQ entry\n"));
-		break;
-	}
-
-	if (!link->irq.active) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid IRQ %d\n", link->irq.active));
-		result = -ENODEV;
-	}
-
-end:
-	kfree(buffer.pointer);
-
-	if (0 == result)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link at IRQ %d \n",
-			link->irq.active));
-	
-	return_VALUE(result);
-}
-
-
-static int
-acpi_pci_link_set (
-	struct acpi_pci_link	*link,
-	int			irq)
-{
-	acpi_status		status = AE_OK;
-	struct {
-		acpi_resource	res;
-		acpi_resource   end;
-	}                       resource;
-	acpi_buffer		buffer = {sizeof(resource)+1, &resource};
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
-
-	if (!link || !irq)
-		return_VALUE(-EINVAL);
-
-	memset(&resource, 0, sizeof(resource));
-
-	resource.res.id = ACPI_RSTYPE_IRQ;
-	resource.res.length = sizeof(acpi_resource);
-	resource.res.data.irq.edge_level = link->irq.flags.trigger;
-	resource.res.data.irq.active_high_low = link->irq.flags.polarity;
-	resource.res.data.irq.shared_exclusive = link->irq.flags.shareable;
-	resource.res.data.irq.number_of_interrupts = 1;
-	resource.res.data.irq.interrupts[0] = irq;
-	resource.end.id = ACPI_RSTYPE_END_TAG;
-
-	status = acpi_set_current_resources(link->handle, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SRS\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Set IRQ %d\n", irq));
-	
-	return_VALUE(0);
-}
-
-
-int
-acpi_pci_link_get_irq (
-	struct acpi_prt_entry	*entry,
-	int			*irq)
-{
-	int                     result = -ENODEV;
-	struct acpi_device	*device = NULL;
-	struct acpi_pci_link	*link = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_get_irq");
-
-	if (!entry || !entry->source.handle || !irq)
-		return_VALUE(-EINVAL);
-
-	/* TBD: Support multiple index values (not just first). */
-	if (0 != entry->source.index) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Unsupported resource index [%d]\n", 
-			entry->source.index));
-		return_VALUE(-ENODEV);
-	}
-
-	result = acpi_bus_get_device(entry->source.handle, &device);
-	if (0 != result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link IRQ invalid\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	link = (struct acpi_pci_link *) acpi_driver_data(device);
-	if (!link) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	if (!link->irq.flags.valid) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link IRQ invalid\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	/* TBD: Support multiple index (IRQ) entries per Link Device */
-	if (0 != entry->source.index) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Unsupported IRQ resource index [%d]\n", 
-			entry->source.index));
-		return_VALUE(-EFAULT);
-	}
-
-	*irq = link->irq.active;
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_pci_link_set_irq (
-	struct acpi_prt_entry	*entry,
-	int			irq)
-{
-	int			result = 0;
-	int			i = 0;
-	int			valid = 0;
-	struct acpi_device	*device = NULL;
-	struct acpi_pci_link	*link = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_set_irq");
-
-	if (!entry || !entry->source.handle || !irq)
-		return_VALUE(-EINVAL);
-
-	/* TBD: Support multiple index (IRQ) entries per Link Device */
-	if (0 != entry->source.index) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Unsupported resource index [%d]\n", 
-			entry->source.index));
-		return_VALUE(-ENODEV);
-	}
-
-	result = acpi_bus_get_device(entry->source.handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-
-	link = (struct acpi_pci_link *) acpi_driver_data(device);
-	if (!link) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	if (!link->irq.flags.valid) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link IRQ invalid\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	/* Is the target IRQ the same as the currently enabled IRQ? */
-	if (link->irq.flags.enabled && (irq == link->irq.active)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link already at IRQ %d\n",
-			irq));
-		return_VALUE(0);
-	}
-
-	/* Is the target IRQ in the list of possible IRQs? */
-	for (i=0; i<link->irq.possible_count; i++) {
-		if (irq == link->irq.possible[i])
-			valid = 1;
-	}
-	if (!valid) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Target IRQ invalid\n"));
-		return_VALUE(-EINVAL);
-	}
-
-	/* TBD: Do we need to disable this link device before resetting? */
-
-	/* Set the new IRQ */
-	result = acpi_pci_link_set(link, irq);
-	if (0 != result)
-		return_VALUE(result);
-
-	link->irq.active = irq;
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_pci_link_enable (
-	struct acpi_device	*device,
-	struct acpi_pci_link	*link)
-{
-	int			result = -ENODEV;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_enable");
-
-	if (!device || !link)
-		return_VALUE(-EINVAL);
-
-	result = acpi_pci_link_get_possible(link);
-	if (0 != result)
-		return_VALUE(result);
-
-	result = acpi_bus_get_status(device);
-	if (0 != result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	/*
-	 * If this link device isn't enabled (_STA bit 1) then we enable it
-	 * by setting an IRQ.
-	 */
-	if (!device->status.enabled) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Attempting to enable at IRQ [%d]\n", 
-			link->irq.possible[0]));
-
-		result = acpi_pci_link_set(link, link->irq.possible[0]);
-		if (0 != result)
-			return_VALUE(result);
-
-		result = acpi_bus_get_status(device);
-		if (0 != result) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-				"Unable to read status\n"));
-			return_VALUE(-ENODEV);
-		}
-
-		if (!device->status.enabled) {
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Enable failed\n"));
-			return_VALUE(-ENODEV);
-		}
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link enabled at IRQ %d\n", 
-			link->irq.possible[0]));
-	}
-
-	/*
-	 * Now we get the current IRQ just to make sure everything is kosher.
-	 */
-	result = acpi_pci_link_get_current(link);
-	if (0 != result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-			"Current IRQ invalid, setting to default\n"));
-
-		result = acpi_pci_link_set(link, link->irq.possible[0]);
-		if (0 != result)
-			return_VALUE(result);
-
-		result = acpi_pci_link_get_current(link);
-		if (0 != result) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-				"Unable to read current IRQ\n"));
-			return_VALUE(result);
-		}
-	}
-
-  	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Using IRQ %d\n", link->irq.active));
-
-	link->irq.flags.valid = 1;
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Driver Interface
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_pci_link_add (
-	struct acpi_device *device)
-{
-	int			result = 0;
-	struct acpi_pci_link	*link = NULL;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	link = kmalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
-	if (!link)
-		return_VALUE(-ENOMEM);
-	memset(link, 0, sizeof(struct acpi_pci_link));
-
-	link->handle = device->handle;
-	sprintf(acpi_device_name(device), "%s", ACPI_PCI_LINK_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_PCI_LINK_CLASS);
-	acpi_driver_data(device) = link;
-
-	result = acpi_pci_link_enable(device, link);
-	if (0 != result)
-		goto end;
-
-	printk(PREFIX "%s [%s] (IRQs", 
-		acpi_device_name(device), acpi_device_bid(device));
-	for (i = 0; i < link->irq.possible_count; i++)
-		printk("%s%d", 
-			(link->irq.active==link->irq.possible[i])?" *":" ",
-			link->irq.possible[i]);
-	printk(")\n");
-
-end:
-	if (0 != result)
-		kfree(link);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_pci_link_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	struct acpi_pci_link *link = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_link_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	link = (struct acpi_pci_link *) acpi_driver_data(device);
-
-	kfree(link);
-
-	return_VALUE(0);
-}
-
-
-int __init
-acpi_pci_link_init (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_pci_link_init");
-
-	if (0 > acpi_bus_register_driver(&acpi_pci_link_driver))
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_pci_link_exit (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_pci_link_init");
-
-	acpi_bus_unregister_driver(&acpi_pci_link_driver);
-
-	return_VOID;
-}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_pci_root.c linux/drivers/acpi/acpi_pci_root.c
--- ../prev/linux/drivers/acpi/acpi_pci_root.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_pci_root.c	Wed Dec 31 17:00:00 1969
@@ -1,759 +0,0 @@
-/*
- *  acpi_pci_root.c - ACPI PCI Root Bridge Driver ($Revision: 31 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- * Copyright (C) 2002 J.I. Lee <jung-ik.lee@intel.com>
- * 02/04/18    J.I. Lee      Allowed defered prt parsing on PCI root bridges
- *                           that have no immediate prts.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/proc_fs.h>
-#include <linux/spinlock.h>
-#include <linux/pm.h>
-#include <linux/pci.h>
-#include <linux/acpi.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_PCI_ROOT_COMPONENT
-ACPI_MODULE_NAME		("pci_root")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_PCI_ROOT_DRIVER_NAME);
-
-extern struct pci_ops *pci_root_ops;
-
-#define PREFIX			"ACPI: "
-
-static int acpi_pci_root_add (struct acpi_device *device);
-static int acpi_pci_root_remove (struct acpi_device *device, int type);
-static int acpi_pci_bind (struct acpi_device *device);
-
-static struct acpi_driver acpi_pci_root_driver = {
-        name:                   ACPI_PCI_ROOT_DRIVER_NAME,
-        class:                  ACPI_PCI_ROOT_CLASS,
-        ids:                    ACPI_PCI_ROOT_HID,
-        ops:                    {
-                                        add:    acpi_pci_root_add,
-                                        remove: acpi_pci_root_remove,
-					bind:	acpi_pci_bind,
-                                },
-};
-
-struct acpi_pci_data {
-	acpi_pci_id		id;
-	struct pci_bus		*bus;
-	struct pci_dev		*dev;
-};
-
-struct acpi_pci_root {
-	acpi_handle		handle;
-	struct acpi_pci_data	data;
-};
-
-struct acpi_prt_list		acpi_prts;
-
-
-/* --------------------------------------------------------------------------
-                        PCI Routing Table (PRT) Support
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_prt_find_entry (
-	acpi_pci_id		*id,
-	u8			pin,
-	struct acpi_prt_entry	**entry)
-{
-	struct list_head	*node = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_prt_find_entry");
-
-	if (!id || !entry)
-		return_VALUE(-ENODEV);
-
-	/* TBD: Locking */
-	list_for_each(node, &acpi_prts.entries) {
-		(*entry) = list_entry(node, struct acpi_prt_entry, node);
-		/* TBD: Include check for segment when supported by pci_dev */
-		if ((id->bus == (*entry)->id.bus) 
-			&& (id->device == (*entry)->id.dev)
-			&& (pin == (*entry)->id.pin)) {
-			return_VALUE(0);
-		}
-	}
-
-	(*entry) = NULL;
-
-	return_VALUE(-ENODEV);
-}
-
-
-int
-acpi_prt_get_irq (
-	struct pci_dev		*dev,
-	u8			pin,
-	int			*irq)
-{
-	int			result = 0;
-	struct acpi_prt_entry	*entry = NULL;
-	acpi_pci_id		id = {0, 0, 0, 0};
-
-	ACPI_FUNCTION_TRACE("acpi_prt_get_irq");
-
-	if (!dev || !irq)
-		return_VALUE(-ENODEV);
-
-	if (!dev->bus) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Device has invalid 'bus' field\n"));
-		return_VALUE(-EFAULT);
-	}
-
-	id.segment = 0;
-	id.bus = dev->bus->number;
-	id.device = PCI_SLOT(dev->devfn);
-	id.function = PCI_FUNC(dev->devfn);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Resolving IRQ for %02x:%02x:%02x.%02x[%c]\n",
-		id.segment, id.bus, id.device, id.function, ('A'+pin)));
-
-	result = acpi_prt_find_entry(&id, pin, &entry);
-	if (0 != result)
-		return_VALUE(result);
-
-	/* Type 1: Dynamic (e.g. PCI Link Device) */
-	if (entry->source.handle)
-		result = acpi_pci_link_get_irq(entry, irq);
-
-	/* Type 2: Static (e.g. I/O [S]APIC Direct) */
-	else {
-		if (entry->source.index)
-			*irq = entry->source.index;
-		else
-			result = -ENODEV;
-	}
-	
-	if (0 == result)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", *irq));
-	else
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to reslove IRQ\n"));
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_prt_set_irq (
-	struct pci_dev		*dev,
-	u8			pin,
-	int			irq)
-{
-	int			result = 0;
-	struct acpi_prt_entry	*entry = NULL;
-	acpi_pci_id		id = {0, 0, 0, 0};
-
-	ACPI_FUNCTION_TRACE("acpi_pci_set_irq");
-
-	if (!dev || !irq)
-		return_VALUE(-EINVAL);
-
-	if (!dev->bus) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Device has invalid 'bus' field\n"));
-		return_VALUE(-EFAULT);
-	}
-
-	id.segment = 0;
-	id.bus = dev->bus->number;
-	id.device = PCI_SLOT(dev->devfn);
-	id.function = PCI_FUNC(dev->devfn);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Setting %02x:%02x:%02x.%02x[%c] to IRQ%d\n",
-		id.segment, id.bus, id.device, id.function, ('A'+pin), irq));
-
-	result = acpi_prt_find_entry(&id, pin, &entry);
-	if (0 != result)
-		return_VALUE(result);
-
-	/* Type 1: Dynamic (e.g. PCI Link Device) */
-	if (entry->source.handle)
-		result = acpi_pci_link_set_irq(entry, irq);
-	/* Type 2: Static (e.g. I/O [S]APIC Direct) */
-	else
-		result = -EFAULT;
-	
-	if (0 == result)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "IRQ set\n"));
-	else
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to set IRQ\n"));
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_prt_add_entry (
-	acpi_handle		handle,
-	u8			seg,
-	u8			bus,
-	acpi_pci_routing_table	*prt)
-{
-	struct acpi_prt_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_prt_add_entry");
-
-	if (!prt)
-		return_VALUE(-EINVAL);
-
-	entry = kmalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
-	if (!entry)
-		return_VALUE(-ENOMEM);
-	memset(entry, 0, sizeof(struct acpi_prt_entry));
-
-	entry->id.seg = seg;
-	entry->id.bus = bus;
-	entry->id.dev = prt->address >> 16;
-	entry->id.pin = prt->pin;
-
-	/*
-	 * Type 1: Dynamic
-	 * ---------------
-	 * The 'source' field specifies the PCI interrupt link device used to
-	 * configure the IRQ assigned to this slot|dev|pin.  The 'source_index'
-	 * indicates which resource descriptor in the resource template (of
-	 * the link device) this interrupt is allocated from.
-	 */
-	if (prt->source)
-		acpi_get_handle(handle, prt->source, &entry->source.handle);
-	/*
-	 * Type 2: Static
-	 * --------------
-	 * The 'source' field is NULL, and the 'source_index' field specifies
-	 * the IRQ value, which is hardwired to specific interrupt inputs on
-	 * the interrupt controller.
-	 */
-	else
-		entry->source.handle = NULL;
-
-	entry->source.index = prt->source_index;
-
-	/* 
-	 * NOTE: Don't query the Link Device for IRQ information at this time
-	 *       because Link Device enumeration may not have occurred yet
-	 *       (e.g. exists somewhere 'below' this _PRT entry in the ACPI
-	 *       namespace).
-	 */
-
-	ACPI_DEBUG_PRINT_RAW((ACPI_DB_OK, "      %02X:%02X:%02X[%c] -> %s[%d]\n", 
-		entry->id.seg, entry->id.bus, entry->id.dev, 
-		('A' + entry->id.pin), prt->source, entry->source.index));
-
-	/* TBD: Acquire/release lock */
-	list_add_tail(&entry->node, &acpi_prts.entries);
-
-	acpi_prts.count++;
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_prt_parse (
-	acpi_handle		handle,
-	u8			seg,
-	u8			bus)
-{
-	acpi_status		status = AE_OK;
-	char			pathname[PATHNAME_MAX] = {0};
-	acpi_buffer		buffer = {0, NULL};
-	acpi_pci_routing_table	*prt = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_prt_parse");
-
-	buffer.length = sizeof(pathname);
-	buffer.pointer = pathname;
-	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
-
-	printk(KERN_INFO PREFIX "%s in [%s]\n", ACPI_PCI_PRT_DEVICE_NAME, 
-		pathname);
-
-	/* 
-	 * Evaluate this _PRT and add all entries to our global list.
-	 */
-
-	buffer.length = 0;
-	buffer.pointer = NULL;
-	status = acpi_get_irq_routing_table(handle, &buffer);
-	if (status != AE_BUFFER_OVERFLOW) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
-			acpi_format_exception(status)));
-		return_VALUE(-ENODEV);
-	}
-
-	prt = kmalloc(buffer.length, GFP_KERNEL);
-	if (!prt)
-		return_VALUE(-ENOMEM);
-	memset(prt, 0, buffer.length);
-	buffer.pointer = prt;
-
-	status = acpi_get_irq_routing_table(handle, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
-			acpi_format_exception(status)));
-		kfree(buffer.pointer);
-		return_VALUE(-ENODEV);
-	}
-
-	while (prt && (prt->length > 0)) {
-		acpi_prt_add_entry(handle, seg, bus, prt);
-		prt = (acpi_pci_routing_table*)((unsigned long)prt + prt->length);
-	}
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                             PCI Device Binding
-   -------------------------------------------------------------------------- */
-
-static void
-acpi_pci_data_handler (
-	acpi_handle		handle,
-	u32			function,
-	void			*context)
-{
-	ACPI_FUNCTION_TRACE("acpi_pci_data_handler");
-
-	/* TBD: Anything we need to do here? */
-
-	return_VOID;
-}
-
-
-/**
- * acpi_os_get_pci_id
- * ------------------
- * This function gets used by the ACPI Interpreter (a.k.a. Core Subsystem)
- * to resolve PCI information for ACPI-PCI devices defined in the namespace.
- */
-acpi_status
-acpi_os_get_pci_id (
-	acpi_handle		handle,
-	acpi_pci_id		*id)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
-	struct acpi_pci_data	*data = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_os_get_pci_id");
-
-	if (!id)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	result = acpi_bus_get_device(handle, &device);
-	if (0 != result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid ACPI Bus context for device %s\n",
-			acpi_device_bid(device)));
-		return_ACPI_STATUS(AE_NOT_EXIST);
-	}
-
-	status = acpi_get_data(handle, acpi_pci_data_handler, (void**) &data);
-	if (ACPI_FAILURE(status) || !data || !data->dev) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid ACPI-PCI context for device %s\n",
-			acpi_device_bid(device)));
-		return_ACPI_STATUS(status);
-	}
-	
-	id->segment = data->id.segment;
-	id->bus = data->id.bus;
-	id->device = data->id.device;
-	id->function = data->id.function;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Device %s has PCI address %02x:%02x:%02x.%02x\n", 
-		acpi_device_bid(device), id->segment, id->bus, 
-		id->device, id->function));
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-	
-static int
-acpi_pci_bind (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_pci_data	*data = NULL;
-	struct acpi_pci_data	*pdata = NULL;
-	acpi_handle		handle = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_bind");
-
-	if (!device || !device->parent)
-		return_VALUE(-EINVAL);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Attempting to bind PCI device %s.%s\n", 
-		acpi_device_bid(device->parent), acpi_device_bid(device)));
-
-	data = kmalloc(sizeof(struct acpi_pci_data), GFP_KERNEL);
-	if (!data)
-		return_VALUE(-ENOMEM);
-	memset(data, 0, sizeof(struct acpi_pci_data));
-
-	/* 
-	 * Segment & Bus
-	 * -------------
-	 * These are obtained via the parent device's ACPI-PCI context.
-	 */
-	status = acpi_get_data(device->parent->handle, acpi_pci_data_handler, 
-		(void**) &pdata);
-	if (ACPI_FAILURE(status) || !pdata || !pdata->bus) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid ACPI-PCI context for parent device %s\n",
-			acpi_device_bid(device->parent)));
-		result = -ENODEV;
-		goto end;
-	}
-
-	data->id.segment = pdata->id.segment;
-
-	data->id.bus = pdata->bus->number;
-
-	/*
-	 * Device & Function
-	 * -----------------
-	 * These are simply obtained from the device's _ADR method.  Note
-	 * that a value of zero is valid.
-	 */
-	data->id.device = device->pnp.bus_address >> 16;
-	data->id.function = device->pnp.bus_address & 0xFFFF;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Binding device %s.%s to %02x:%02x:%02x.%02x\n", 
-		acpi_device_bid(device->parent), acpi_device_bid(device), 
-		data->id.segment, data->id.bus, data->id.device, 
-		data->id.function));
-
-	/*
-	 * TBD: Support slot devices (e.g. function=0xFFFF).
-	 */
-
-	/* 
-	 * Locate PCI Device
-	 * -----------------
-	 * Locate matching device in PCI namespace.  If it doesn't exist
-	 * this typically means that the device isn't currently inserted
-	 * (e.g. docking station, port replicator, etc.).
-	 */
-	data->dev = pci_find_slot(data->id.bus, 
-		PCI_DEVFN(data->id.device, data->id.function));
-	if (!data->dev) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Device %02x:%02x:%02x.%02x not present in PCI namespace\n",
-			data->id.segment, data->id.bus, 
-			data->id.device, data->id.function));
-		result = -ENODEV;
-		goto end;
-	}
-	if (!data->dev->bus) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Device %02x:%02x:%02x.%02x has invalid 'bus' field\n",
-			data->id.segment, data->id.bus, 
-			data->id.device, data->id.function));
-		result = -ENODEV;
-		goto end;
-	}
-
-	/*
-	 * PCI Bridge?
-	 * -----------
-	 * If so, set the 'bus' field and install the 'bind' function to 
-	 * facilitate callbacks for all of its children.
-	 */
-	if (data->dev->subordinate) {
-		data->bus = data->dev->subordinate;
-		device->ops.bind = acpi_pci_bind;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Device %02x:%02x:%02x.%02x is a PCI bridge\n",
-			data->id.segment, data->id.bus, 
-			data->id.device, data->id.function));
-	}
-
-	/*
-	 * Attach ACPI-PCI Context
-	 * -----------------------
-	 * Thus binding the ACPI and PCI devices.
-	 */
-	status = acpi_attach_data(device->handle, acpi_pci_data_handler, data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to attach ACPI-PCI context to device %s\n",
-			acpi_device_bid(device)));
-		result = -ENODEV;
-		goto end;
-	}
-
-	/*
-	 * PCI Routing Table
-	 * -----------------
-	 * Evaluate and parse _PRT, if exists.  This code is independent of 
-	 * PCI bridges (above) to allow parsing of _PRT objects within the
-	 * scope of non-bridge devices.  Note that _PRTs within the scope of
-	 * a PCI bridge assume the bridge's subordinate bus number.
-	 *
-	 * TBD: Can _PRTs exist within the scope of non-bridge PCI devices?
-	 */
-	status = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);
-	if (ACPI_SUCCESS(status)) {
-		if (data->bus)				    /* PCI-PCI bridge */
-			acpi_prt_parse(device->handle, data->id.segment, 
-				data->bus->number);
-		else				     /* non-bridge PCI device */
-			acpi_prt_parse(device->handle, data->id.segment,
-				data->id.bus);
-	}
-
-end:
-	if (0 != result)
-		kfree(data);
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Driver Interface
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_pci_root_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	struct acpi_pci_root	*root = NULL;
-	acpi_status		status = AE_OK;
-	unsigned long		value = 0;
-	acpi_handle		handle = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_root_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	root = kmalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);
-	if (!root)
-		return_VALUE(-ENOMEM);
-	memset(root, 0, sizeof(struct acpi_pci_root));
-
-	root->handle = device->handle;
-	sprintf(acpi_device_name(device), "%s", ACPI_PCI_ROOT_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_PCI_ROOT_CLASS);
-	acpi_driver_data(device) = root;
-
-	/*
-	 * TBD: Doesn't the bus driver automatically set this?
-	 */
-	device->ops.bind = acpi_pci_bind;
-
-	/* 
-	 * Segment
-	 * -------
-	 * Obtained via _SEG, if exists, otherwise assumed to be zero (0).
-	 */
-	status = acpi_evaluate_integer(root->handle, METHOD_NAME__SEG, NULL, 
-		&value);
-	switch (status) {
-	case AE_OK:
-		root->data.id.segment = (u16) value;
-		break;
-	case AE_NOT_FOUND:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Assuming segment 0 (no _SEG)\n"));
-		root->data.id.segment = 0;
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SEG\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	/* 
-	 * Bus
-	 * ---
-	 * Obtained via _BBN, if exists, otherwise assumed to be zero (0).
-	 */
-	status = acpi_evaluate_integer(root->handle, METHOD_NAME__BBN, NULL, 
-		&value);
-	switch (status) {
-	case AE_OK:
-		root->data.id.bus = (u16) value;
-		break;
-	case AE_NOT_FOUND:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Assuming bus 0 (no _BBN)\n"));
-		root->data.id.bus = 0;
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BBN\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	/*
-	 * Device & Function
-	 * -----------------
-	 * Obtained from _ADR (which has already been evaluated for us).
-	 */
-	root->data.id.device = device->pnp.bus_address >> 16;
-	root->data.id.function = device->pnp.bus_address & 0xFFFF;
-
-	/*
-	 * TBD: Evaluate _CRS to get root bridge resources
-	 * TBD: Need PCI interface for enumeration/configuration of roots.
-	 */
-
-	printk(KERN_INFO PREFIX "%s [%s] (%02x:%02x)\n", 
-		acpi_device_name(device), acpi_device_bid(device),
-		root->data.id.segment, root->data.id.bus);
-
-	/*
-	 * Scan the Root Bridge
-	 * --------------------
-	 * Must do this prior to any attempt to bind the root device, as the
-	 * PCI namespace does not get created until this call is made (and 
-	 * thus the root bridge's pci_dev does not exist).
-	 */
-	root->data.bus = pcibios_scan_root(root->data.id.segment, root->data.id.bus);
-	if (!root->data.bus) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Bus %02x:%02x not present in PCI namespace\n", 
-			root->data.id.segment, root->data.id.bus));
-		result = -ENODEV;
-		goto end;
-	}
-
-	/*
-	 * Attach ACPI-PCI Context
-	 * -----------------------
-	 * Thus binding the ACPI and PCI devices.  Note that PCI root bridges
-	 * never set a 'data.dev' member (rely on 'data.bus' instead).
-	 */
-	status = acpi_attach_data(root->handle, acpi_pci_data_handler, 
-		&root->data);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to attach ACPI-PCI context to device %s\n",
-			acpi_device_bid(device)));
-		result = -ENODEV;
-		goto end;
-	}
-
-	/*
-	 * PCI Routing Table
-	 * -----------------
-	 * Evaluate and parse _PRT, if exists.  Note that root bridges MUST
-	 * have a _PRT (optional for PCI-PCI bridges).
-	 *
-	 */
-
-	/*
-	 * J.I.
-	 * Some PCI Root Brides can have no immediate _PRTs,
-	 *  in that case, _PRTs are buried in child devices.
-	 * So, let's pass even if Root PCI bridge has no immediate _PRT
-	 *  and defer the _PRT parsing until we get somewhere down there.
-	 */
-	status = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-			"Deferred _PRT parsing for PCI Root bridge(s:b=0x%x:%x)...\n",
-			root->data.id.segment, root->data.id.bus));
-		//result = 0;
-		goto end;
-	}
-
-	result = acpi_prt_parse(device->handle, root->data.id.segment, 
-		root->data.id.bus);
-
-end:
-	if (0 != result)
-		kfree(root);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_pci_root_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	struct acpi_pci_root	*root = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_pci_root_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	root = (struct acpi_pci_root *) acpi_driver_data(device);
-
-	kfree(root);
-
-	return_VALUE(0);
-}
-
-
-int __init
-acpi_pci_root_init (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_pci_root_init");
-
-	acpi_prts.count = 0;
-	INIT_LIST_HEAD(&acpi_prts.entries);
-
-	if (0 > acpi_bus_register_driver(&acpi_pci_root_driver))
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_pci_root_exit (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_pci_root_exit");
-
-	acpi_bus_unregister_driver(&acpi_pci_root_driver);
-
-	return_VOID;
-}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_power.c linux/drivers/acpi/acpi_power.c
--- ../prev/linux/drivers/acpi/acpi_power.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_power.c	Wed Dec 31 17:00:00 1969
@@ -1,610 +0,0 @@
-/*
- *  acpi_power.c - ACPI Bus Power Management ($Revision: 34 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_POWER_COMPONENT
-ACPI_MODULE_NAME		("acpi_power")
-
-#define PREFIX			"ACPI: "
-
-
-int acpi_power_add (struct acpi_device *device);
-int acpi_power_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_power_driver = {
-	name:			ACPI_POWER_DRIVER_NAME,
-	class:			ACPI_POWER_CLASS,
-	ids:			ACPI_POWER_HID,
-	ops:			{
-					add:	acpi_power_add,
-					remove:	acpi_power_remove,
-				},
-};
-
-struct acpi_power_resource
-{
-	acpi_handle		handle;
-	acpi_bus_id		name;
-	u32			system_level;
-	u32			order;
-	int			state;
-	int			references;
-};
-
-static struct list_head		acpi_power_resource_list;
-
-
-/* --------------------------------------------------------------------------
-                             Power Resource Management
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_power_get_context (
-	acpi_handle		handle,
-	struct acpi_power_resource **resource)
-{
-	int			result = 0;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_power_get_context");
-
-	if (!resource)
-		return_VALUE(-ENODEV);
-
-	result = acpi_bus_get_device(handle, &device);
-	if (0 != result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context [%p]\n",
-			handle));
-		return_VALUE(result);
-	}
-
-	*resource = (struct acpi_power_resource *) acpi_driver_data(device);
-	if (!resource)
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_power_get_state (
-	struct acpi_power_resource *resource)
-{
-	acpi_status		status = AE_OK;
-	unsigned long		sta = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_power_get_state");
-
-	if (!resource)
-		return_VALUE(-EINVAL);
-
-	status = acpi_evaluate_integer(resource->handle, "_STA", NULL, &sta);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	if (sta & 0x01)
-		resource->state = ACPI_POWER_RESOURCE_STATE_ON;
-	else
-		resource->state = ACPI_POWER_RESOURCE_STATE_OFF;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
-		resource->name, resource->state?"on":"off"));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_power_get_list_state (
-	struct acpi_handle_list	*list,
-	int			*state)
-{
-	int			result = 0;
-	struct acpi_power_resource *resource = NULL;
-	u32			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_power_get_list_state");
-
-	if (!list || !state)
-		return_VALUE(-EINVAL);
-
-	/* The state of the list is 'on' IFF all resources are 'on'. */
-
-	for (i=0; i<list->count; i++) {
-		result = acpi_power_get_context(list->handles[i], &resource);
-		if (0 != result)
-			return_VALUE(result);
-		result = acpi_power_get_state(resource);
-		if (0 != result)
-			return_VALUE(result);
-
-		*state = resource->state;
-
-		if (*state != ACPI_POWER_RESOURCE_STATE_ON)
-			break;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource list is %s\n",
-		*state?"on":"off"));
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_power_on (
-	acpi_handle		handle)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
-	struct acpi_power_resource *resource = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_power_on");
-
-	result = acpi_power_get_context(handle, &resource);
-	if (0 != result)
-		return_VALUE(result);
-
-	resource->references++;
-
-	if ((resource->references > 1) 
-		|| (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
-			resource->name));
-		return_VALUE(0);
-	}
-
-	status = acpi_evaluate(resource->handle, "_ON", NULL, NULL);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	result = acpi_power_get_state(resource);
-	if (0 != result)
-		return_VALUE(result);
-	if (resource->state != ACPI_POWER_RESOURCE_STATE_ON)
-		return_VALUE(-ENOEXEC);
-
-	/* Update the power resource's _device_ power state */
-	result = acpi_bus_get_device(resource->handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-	device->power.state = ACPI_STATE_D0;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
-		resource->name));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_power_off (
-	acpi_handle		handle)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_device	*device = NULL;
-	struct acpi_power_resource *resource = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_power_off");
-
-	result = acpi_power_get_context(handle, &resource);
-	if (0 != result)
-		return_VALUE(result);
-
-	if (resource->references)
-		resource->references--;
-
-	if (resource->references) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Resource [%s] is still in use, dereferencing\n",
-			device->pnp.bus_id));
-		return_VALUE(0);
-	}
-
-	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
-			device->pnp.bus_id));
-		return_VALUE(0);
-	}
-
-	status = acpi_evaluate(resource->handle, "_OFF", NULL, NULL);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	result = acpi_power_get_state(resource);
-	if (0 != result)
-		return_VALUE(result);
-	if (resource->state != ACPI_POWER_RESOURCE_STATE_OFF)
-		return_VALUE(-ENOEXEC);
-
-	/* Update the power resource's _device_ power state */
-	result = acpi_bus_get_device(resource->handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-	device->power.state = ACPI_STATE_D3;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
-		resource->name));
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                             Device Power Management
-   -------------------------------------------------------------------------- */
-
-int
-acpi_power_get_inferred_state (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	struct acpi_handle_list	*list = NULL;
-	int			list_state = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_power_get_inferred_state");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	device->power.state = ACPI_STATE_UNKNOWN;
-
-	/*
-	 * We know a device's inferred power state when all the resources
-	 * required for a given D-state are 'on'.
-	 */
-	for (i=ACPI_STATE_D0; i<ACPI_STATE_D3; i++) {
-		list = &device->power.states[i].resources;
-		if (list->count < 1)
-			continue;
-
-		result = acpi_power_get_list_state(list, &list_state);
-		if (0 != result)
-			return_VALUE(result);
-
-		if (list_state == ACPI_POWER_RESOURCE_STATE_ON) {
-			device->power.state = i;
-			return_VALUE(0);
-		}
-	}
-
-	device->power.state = ACPI_STATE_D3;
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_power_transition (
-	struct acpi_device	*device,
-	int			state)
-{
-	int			result = 0;
-	struct acpi_handle_list	*cl = NULL;	/* Current Resources */
-	struct acpi_handle_list	*tl = NULL;	/* Target Resources */
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_power_transition");
-
-	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
-		return_VALUE(-EINVAL);
-
-	cl = &device->power.states[device->power.state].resources;
-	tl = &device->power.states[state].resources;
-
-	device->power.state = ACPI_STATE_UNKNOWN;
-
-	if (!cl->count && !tl->count) {
-		result = -ENODEV;
-		goto end;
-	}
-
-	/* TBD: Resources must be ordered. */
-
-	/*
-	 * First we reference all power resources required in the target list
-	 * (e.g. so the device doesn't loose power while transitioning).
-	 */
-	for (i=0; i<tl->count; i++) {
-		result = acpi_power_on(tl->handles[i]);
-		if (0 != result)
-			goto end;
-	}
-
-	device->power.state = state;
-
-	/*
-	 * Then we dereference all power resources used in the current list.
-	 */
-	for (i=0; i<cl->count; i++) {
-		result = acpi_power_off(cl->handles[i]);
-		if (0 != result)
-			goto end;
-	}
-
-end:
-	if (0 != result)
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-			"Error transitioning device [%s] to D%d\n",
-			device->pnp.bus_id, state));
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-struct proc_dir_entry		*acpi_power_dir = NULL;
-
-
-static int
-acpi_power_read_status (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_power_resource *resource = NULL;
-	char			*p = page;
-	int			len;
-
-	ACPI_FUNCTION_TRACE("acpi_power_read_status");
-
-	if (!data || (off != 0))
-		goto end;
-
-	resource = (struct acpi_power_resource *) data;
-
-	p += sprintf(p, "state:                   ");
-	switch (resource->state) {
-	case ACPI_POWER_RESOURCE_STATE_ON:
-		p += sprintf(p, "on\n");
-		break;
-	case ACPI_POWER_RESOURCE_STATE_OFF:
-		p += sprintf(p, "off\n");
-		break;
-	default:
-		p += sprintf(p, "unknown\n");
-		break;
-	}
-
-	p += sprintf(p, "system level:            S%d\n",
-		resource->system_level);
-	p += sprintf(p, "order:                   %d\n",
-		resource->order);
-	p += sprintf(p, "reference count:         %d\n",
-		resource->references);
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_power_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_power_add_fs");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	if (!acpi_power_dir) {
-		acpi_power_dir = proc_mkdir(ACPI_POWER_CLASS, acpi_root_dir);
-		if (!acpi_power_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_power_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-
-	/* 'status' [R] */
-	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_POWER_FILE_STATUS));
-	else {
-		entry->read_proc = acpi_power_read_status;
-		entry->data = acpi_driver_data(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_power_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_power_remove_fs");
-
-	if (!acpi_power_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_power_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Driver Interface
-   -------------------------------------------------------------------------- */
-
-int
-acpi_power_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_power_resource *resource = NULL;
-	acpi_object		acpi_object;
-	acpi_buffer		buffer = {sizeof(acpi_object), &acpi_object};
-
-	ACPI_FUNCTION_TRACE("acpi_power_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	resource = kmalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
-	if (!resource)
-		return_VALUE(-ENOMEM);
-	memset(resource, 0, sizeof(struct acpi_power_resource));
-
-	resource->handle = device->handle;
-	sprintf(resource->name, "%s", device->pnp.bus_id);
-	sprintf(acpi_device_name(device), "%s", ACPI_POWER_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_POWER_CLASS);
-	acpi_driver_data(device) = resource;
-
-	/* Evalute the object to get the system level and resource order. */
-	status = acpi_evaluate_object(resource->handle, NULL, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		result = -ENODEV;
-		goto end;
-	}
-	resource->system_level = acpi_object.power_resource.system_level;
-	resource->order = acpi_object.power_resource.resource_order;
-
-	result = acpi_power_get_state(resource);
-	if (0 != result)
-		goto end;
-
-	switch (resource->state) {
-	case ACPI_POWER_RESOURCE_STATE_ON:
-		device->power.state = ACPI_STATE_D0;
-		break;
-	case ACPI_POWER_RESOURCE_STATE_OFF:
-		device->power.state = ACPI_STATE_D3;
-		break;
-	default:
-		device->power.state = ACPI_STATE_UNKNOWN;
-		break;
-	}
-
-	result = acpi_power_add_fs(device);
-	if (0 != result)
-		goto end;
-	
-	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
-		acpi_device_bid(device), resource->state?"on":"off");
-
-end:
-	if (0 != result)
-		kfree(resource);
-	
-	return_VALUE(result);
-}
-
-
-int
-acpi_power_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	struct acpi_power_resource *resource = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_power_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	resource = (struct acpi_power_resource *) acpi_driver_data(device);
-
-	acpi_power_remove_fs(device);
-
-	kfree(resource);
-
-	return_VALUE(0);
-}
-
-
-int __init
-acpi_power_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_power_init");
-
-	INIT_LIST_HEAD(&acpi_power_resource_list);
-
-	result = acpi_bus_register_driver(&acpi_power_driver);
-	if (0 > result) {
-		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
-		return_VALUE(-ENODEV);
-	}
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_power_exit (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_power_exit");
-
-	/* TBD: Empty acpi_power_resource_list */
-
-	result = acpi_bus_unregister_driver(&acpi_power_driver);
-	if (0 == result)
-		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_processor.c linux/drivers/acpi/acpi_processor.c
--- ../prev/linux/drivers/acpi/acpi_processor.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_processor.c	Wed Dec 31 17:00:00 1969
@@ -1,2292 +0,0 @@
-/*
- * acpi_processor.c - ACPI Processor Driver ($Revision: 57 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *  TBD:
- *	1. Make # power/performance states dynamic.
- *	2. Support duty_cycle values that span bit 4.
- *	3. Optimize by having scheduler determine business instead of
- *	   having us try to calculate it here.
- *	4. Need C1 timing -- must modify kernel (IRQ handler) to get this.
- *	5. Convert time values to ticks (initially) to avoid having to do
- *	   the math (acpi_get_timer_duration).
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/pm.h>
-#include <asm/io.h>
-#include <asm/system.h>
-#include <asm/delay.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_PROCESSOR_COMPONENT
-ACPI_MODULE_NAME		("acpi_processor")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_PROCESSOR_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-#define PREFIX				"ACPI: "
-
-#define ACPI_PROCESSOR_BUSY_METRIC	10
-
-#define ACPI_PROCESSOR_MAX_POWER	ACPI_C_STATE_COUNT
-#define ACPI_PROCESSOR_MAX_C2_LATENCY	100
-#define ACPI_PROCESSOR_MAX_C3_LATENCY	1000
-
-#define ACPI_PROCESSOR_MAX_PERFORMANCE	8
-
-#define ACPI_PROCESSOR_MAX_THROTTLING	16
-#define ACPI_PROCESSOR_MAX_THROTTLE	250	/* 25% */
-#define ACPI_PROCESSOR_MAX_DUTY_WIDTH	4
-
-const u32 POWER_OF_2[] = {1,2,4,8,16,32,64};
-
-#define ACPI_PROCESSOR_LIMIT_USER	0
-#define ACPI_PROCESSOR_LIMIT_THERMAL	1
-
-static int acpi_processor_add (struct acpi_device *device);
-static int acpi_processor_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_processor_driver = {
-	name:			ACPI_PROCESSOR_DRIVER_NAME,
-	class:			ACPI_PROCESSOR_CLASS,
-	ids:			ACPI_PROCESSOR_HID,
-	ops:			{
-					add:	acpi_processor_add,
-					remove:	acpi_processor_remove,
-				},
-};
-
-/* Power Management */
-
-struct acpi_processor_cx_policy {
-	u32			count;
-	int			state;
-	struct {
-		u32			time;
-		u32			count;
-		u32			bm;
-	}			threshold;
-};
-
-struct acpi_processor_cx {
-	u8			valid;
-	u32			address;
-	u32			latency;
-	u32			power;
-	u32			usage;
-	struct acpi_processor_cx_policy promotion;
-	struct acpi_processor_cx_policy demotion;
-};
-
-struct acpi_processor_power {
-	int			state;
-	int			default_state;
-	u32			bm_activity;
-	struct acpi_processor_cx states[ACPI_PROCESSOR_MAX_POWER];
-};
-
-/* Performance Management */
-
-struct acpi_pct_register {
-	u8			descriptor;
-	u16			length;
-	u8			space_id;
-	u8			bit_width;
-	u8			bit_offset;
-	u8			reserved;
-	u64			address;
-} __attribute__ ((packed));
-
-struct acpi_processor_px {
-	acpi_integer		core_frequency;		/* megahertz */
-	acpi_integer		power;			/* milliWatts */
-	acpi_integer		transition_latency;	/* microseconds */
-	acpi_integer		bus_master_latency;	/* microseconds */
-	acpi_integer		control;		/* control value */
-	acpi_integer		status;			/* success indicator */
-};
-
-struct acpi_processor_performance {
-	int			state;
-	int			platform_limit;
-	u16			control_register;
-	u16			status_register;
-	int			state_count;
-	struct acpi_processor_px states[ACPI_PROCESSOR_MAX_PERFORMANCE];
-};
-
-
-/* Throttling Control */
-
-struct acpi_processor_tx {
-	u16			power;
-	u16			performance;
-};
-
-struct acpi_processor_throttling {
-	int			state;
-	u32			address;
-	u8			duty_offset;
-	u8			duty_width;
-	int			state_count;
-	struct acpi_processor_tx states[ACPI_PROCESSOR_MAX_THROTTLING];
-};
-
-/* Limit Interface */
-
-struct acpi_processor_lx {
-	int			px;		/* performace state */	
-	int			tx;		/* throttle level */
-};
-
-struct acpi_processor_limit {
-	struct acpi_processor_lx state;		/* current limit */
-	struct acpi_processor_lx thermal;	/* thermal limit */
-	struct acpi_processor_lx user;		/* user limit */
-};
-
-
-struct acpi_processor_flags {
-	u8			power:1;
-	u8			performance:1;
-	u8			throttling:1;
-	u8			limit:1;
-	u8			bm_control:1;
-	u8			bm_check:1;
-	u8			reserved:2;
-};
-
-struct acpi_processor {
-	acpi_handle		handle;
-	u32			acpi_id;
-	u32			id;
-	struct acpi_processor_flags flags;
-	struct acpi_processor_power power;
-	struct acpi_processor_performance performance;
-	struct acpi_processor_throttling throttling;
-	struct acpi_processor_limit limit;
-};
-
-struct acpi_processor_errata {
-	u8			smp;
-	struct {
-		u8			throttle:1;
-		u8			fdma:1;
-		u8			reserved:6;
-		u32			bmisx;
-	}			piix4;
-};
-
-static struct acpi_processor	*processors[NR_CPUS];
-static struct acpi_processor_errata errata;
-static void (*pm_idle_save)(void) = NULL;
-
-
-/* --------------------------------------------------------------------------
-                                Errata Handling
-   -------------------------------------------------------------------------- */
-
-int
-acpi_processor_errata_piix4 (
-	struct pci_dev		*dev)
-{
-	u8			rev = 0;
-	u8			value1 = 0;
-	u8			value2 = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_errata_piix4");
-
-	if (!dev)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * Note that 'dev' references the PIIX4 ACPI Controller.
-	 */
-
-	pci_read_config_byte(dev, PCI_REVISION_ID, &rev);
-
-	switch (rev) {
-	case 0:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 A-step\n"));
-		break;
-	case 1:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 B-step\n"));
-		break;
-	case 2:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4E\n"));
-		break;
-	case 3:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4M\n"));
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unknown PIIX4\n"));
-		break;
-	}
-
-	switch (rev) {
-
-	case 0:		/* PIIX4 A-step */
-	case 1:		/* PIIX4 B-step */
-		/*
-		 * See specification changes #13 ("Manual Throttle Duty Cycle")
-		 * and #14 ("Enabling and Disabling Manual Throttle"), plus
-		 * erratum #5 ("STPCLK# Deassertion Time") from the January 
-		 * 2002 PIIX4 specification update.  Applies to only older 
-		 * PIIX4 models.
-		 */
-		errata.piix4.throttle = 1;
-
-	case 2:		/* PIIX4E */
-	case 3:		/* PIIX4M */
-		/*
-		 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA 
-		 * Livelock") from the January 2002 PIIX4 specification update.
-		 * Applies to all PIIX4 models.
-		 */
-
-		/* 
-		 * BM-IDE
-		 * ------
-		 * Find the PIIX4 IDE Controller and get the Bus Master IDE 
-		 * Status register address.  We'll use this later to read 
-		 * each IDE controller's DMA status to make sure we catch all
-		 * DMA activity.
-		 */
-		dev = pci_find_subsys(PCI_VENDOR_ID_INTEL,
-		           PCI_DEVICE_ID_INTEL_82371AB, 
-                           PCI_ANY_ID, PCI_ANY_ID, NULL);
-		if (dev)
-			errata.piix4.bmisx = pci_resource_start(dev, 4);
-
-		/* 
-		 * Type-F DMA
-		 * ----------
-		 * Find the PIIX4 ISA Controller and read the Motherboard
-		 * DMA controller's status to see if Type-F (Fast) DMA mode
-		 * is enabled (bit 7) on either channel.  Note that we'll 
-		 * disable C3 support if this is enabled, as some legacy 
-		 * devices won't operate well if fast DMA is disabled.
-		 */
-		dev = pci_find_subsys(PCI_VENDOR_ID_INTEL, 
-			PCI_DEVICE_ID_INTEL_82371AB_0, 
-			PCI_ANY_ID, PCI_ANY_ID, NULL);
-		if (dev) {
-			pci_read_config_byte(dev, 0x76, &value1);
-			pci_read_config_byte(dev, 0x77, &value2);
-			if ((value1 & 0x80) || (value2 & 0x80))
-				errata.piix4.fdma = 1;
-		}
-
-		break;
-	}
-
-	if (errata.piix4.bmisx)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Bus master activity detection (BM-IDE) erratum enabled\n"));
-	if (errata.piix4.fdma)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Type-F DMA livelock erratum (C3 disabled)\n"));
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_processor_errata (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	struct pci_dev		*dev = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_errata");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * PIIX4
-	 */
-	dev = pci_find_subsys(PCI_VENDOR_ID_INTEL, 
-		PCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID, PCI_ANY_ID, NULL);
-	if (dev)
-		result = acpi_processor_errata_piix4(dev);
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                                Power Management
-   -------------------------------------------------------------------------- */
-
-static void
-acpi_processor_power_activate (
-	struct acpi_processor	*pr,
-	int			state)
-{
-	if (!pr)
-		return;
-
-	pr->power.states[pr->power.state].promotion.count = 0;
-	pr->power.states[pr->power.state].demotion.count = 0;
-
-	/* Cleanup from old state. */
-	switch (pr->power.state) {
-	case ACPI_STATE_C3:
-		/* Disable bus master reload */
-		acpi_hw_bit_register_write(ACPI_BITREG_BUS_MASTER_RLD, 0, ACPI_MTX_DO_NOT_LOCK);
-		break;
-	}
-
-	/* Prepare to use new state. */
-	switch (state) {
-	case ACPI_STATE_C3:
-		/* Enable bus master reload */
-		acpi_hw_bit_register_write(ACPI_BITREG_BUS_MASTER_RLD, 1, ACPI_MTX_DO_NOT_LOCK);
-		break;
-	}
-
-	pr->power.state = state;
-
-	return;
-}
-
-
-static void
-acpi_processor_idle (void)
-{
-	struct acpi_processor	*pr = NULL;
-	struct acpi_processor_cx *cx = NULL;
-	int			next_state = 0;
-	u32			start_ticks = 0;
-	u32			end_ticks = 0;
-	u32			time_elapsed = 0;
-
-	pr = processors[smp_processor_id()];
-	if (!pr)
-		return;
-
-	/*
-	 * Interrupts must be disabled during bus mastering calculations and
-	 * for C2/C3 transitions.
-	 */
-	__cli();
-
-	cx = &(pr->power.states[pr->power.state]);
-
-	/*
-	 * Check BM Activity
-	 * -----------------
-	 * Check for bus mastering activity (if required), record, and check
-	 * for demotion.
-	 */
-	if (pr->flags.bm_check) {
-
-		pr->power.bm_activity <<= 1;
-		pr->power.bm_activity &= 0xFFFFFFFE;
-
-		if (acpi_hw_bit_register_read(ACPI_BITREG_BUS_MASTER_STATUS, ACPI_MTX_DO_NOT_LOCK)) {
-			pr->power.bm_activity++;
-			acpi_hw_bit_register_write(ACPI_BITREG_BUS_MASTER_STATUS, 1, ACPI_MTX_DO_NOT_LOCK);
-		}
-		/*
-		 * PIIX4 Erratum #18: Note that BM_STS doesn't always reflect
-		 * the true state of bus mastering activity; forcing us to 
-		 * manually check the BMIDEA bit of each IDE channel.
-		 */
-		else if (errata.piix4.bmisx) {
-			if ((inb_p(errata.piix4.bmisx + 0x02) & 0x01) 
-				|| (inb_p(errata.piix4.bmisx + 0x0A) & 0x01))
-				pr->power.bm_activity++;
-		}
-
-		/*
-		 * Apply bus mastering demotion policy.  Automatically demote
-		 * to avoid a faulty transition.  Note that the processor 
-		 * won't enter a low-power state during this call (to this 
-		 * funciton) but should upon the next.
-		 */
-		if (pr->power.bm_activity & cx->demotion.threshold.bm) {
-			__sti();
-			next_state = cx->demotion.state;
-			goto end;
-		}
-	}
-
-	cx->usage++;
-
-	/*
-	 * Sleep:
-	 * ------
-	 * Invoke the current Cx state to put the processor to sleep.
-	 */
-	switch (pr->power.state) {
-
-	case ACPI_STATE_C1:
-		/* Invoke C1. */
-		safe_halt();
-		/*
-                 * TBD: Can't get time duration while in C1, as resumes
-		 *      go to an ISR rather than here.  Need to instrument
-		 *      base interrupt handler.
-		 */
-		time_elapsed = 0xFFFFFFFF;
-		break;
-
-	case ACPI_STATE_C2:
-		/* See how long we're asleep for */
-		start_ticks = inl(acpi_fadt.Xpm_tmr_blk.address);
-		/* Invoke C2 */
-		inb(pr->power.states[ACPI_STATE_C2].address);
-		/* Dummy op - must do something useless after P_LVL2 read */
-		end_ticks = inl(acpi_fadt.Xpm_tmr_blk.address);
-		/* Compute time elapsed */
-		end_ticks = inl(acpi_fadt.Xpm_tmr_blk.address);
-		/* Re-enable interrupts */
-		__sti();
-		/*
-		 * Compute the amount of time asleep (in the Cx state).
-		 * TBD: Convert to PM timer ticks initially to avoid having
-		 *      to do the math (acpi_get_timer_duration).
-		 */
-		acpi_get_timer_duration(start_ticks, end_ticks, &time_elapsed);
-		break;
-
-	case ACPI_STATE_C3:
-		/* Disable bus master arbitration */
-		acpi_hw_bit_register_write(ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
-		/* See how long we're asleep for */
-		start_ticks = inl(acpi_fadt.Xpm_tmr_blk.address);
-		/* Invoke C3 */
-		inb(pr->power.states[ACPI_STATE_C3].address);
-		/* Dummy op - must do something useless after P_LVL3 read */
-		end_ticks = inl(acpi_fadt.Xpm_tmr_blk.address);
-		/* Compute time elapsed */
-		end_ticks = inl(acpi_fadt.Xpm_tmr_blk.address);
-		/* Enable bus master arbitration */
-		acpi_hw_bit_register_write(ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_DO_NOT_LOCK);
-		/* Re-enable interrupts */
-		__sti();
-		/*
-		 * Compute the amount of time asleep (in the Cx state).
-		 * TBD: Convert to PM timer ticks initially to avoid having
-		 *      to do the math (acpi_get_timer_duration).
-		 */
-		acpi_get_timer_duration(start_ticks, end_ticks, &time_elapsed);
-		break;
-
-	default:
-		__sti();
-		return;
-	}
-
-	next_state = pr->power.state;
-
-	/*
-	 * Promotion?
-	 * ----------
-	 * Track the number of longs (time asleep is greater than threshold)
-	 * and promote when the count threshold is reached.  Note that bus
-	 * mastering activity may prevent promotions.
-	 */
-	if (cx->promotion.state) {
-		if (time_elapsed >= cx->promotion.threshold.time) {
-			cx->promotion.count++;
- 			cx->demotion.count = 0;
-			if (cx->promotion.count >= cx->promotion.threshold.count) {
-				if (pr->flags.bm_check) {
-					if (!(pr->power.bm_activity & cx->promotion.threshold.bm)) {
-						next_state = cx->promotion.state;
-						goto end;
-					}
-				}
-				else {
-					next_state = cx->promotion.state;
-					goto end;
-				}
-			}
-		}
-	}
-
-	/*
-	 * Demotion?
-	 * ---------
-	 * Track the number of shorts (time asleep is less than time threshold)
-	 * and demote when the usage threshold is reached.  Note that bus
-	 * mastering demotions are checked prior to state transitions (above).
-	 */
-	if (cx->demotion.state) {
-		if (time_elapsed < cx->demotion.threshold.time) {
-			cx->demotion.count++;
-			cx->promotion.count = 0;
-			if (cx->demotion.count >= cx->demotion.threshold.count) {
-				next_state = cx->demotion.state;
-				goto end;
-			}
-		}
-	}
-
-end:
-	/*
-	 * New Cx State?
-	 * -------------
-	 * If we're going to start using a new Cx state we must clean up
-	 * from the previous and prepare to use the new.
-	 */
-	if (next_state != pr->power.state)
-		acpi_processor_power_activate(pr, next_state);
-
-	return;
-}
-
-
-static int
-acpi_processor_set_power_policy (
-	struct acpi_processor	*pr)
-{
-	ACPI_FUNCTION_TRACE("acpi_processor_set_power_policy");
-
-	/*
-	 * This function sets the default Cx state policy (OS idle handler).
-	 * Our scheme is to promote quickly to C2 but more conservatively
-	 * to C3.  We're favoring C2  for its characteristics of low latency
-	 * (quick response), good power savings, and ability to allow bus
-	 * mastering activity.  Note that the Cx state policy is completely
-	 * customizable and can be altered dynamically.
-	 */
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * C0/C1
-	 * -----
-	 */
-	pr->power.state = ACPI_STATE_C1;
-	pr->power.default_state = ACPI_STATE_C1;
-
-	/*
-	 * C1/C2
-	 * -----
-	 * Set the default C1 promotion and C2 demotion policies, where we
-	 * promote from C1 to C2 after several (10) successive C1 transitions,
-	 * as we cannot (currently) measure the time spent in C1. Demote from
-	 * C2 to C1 after experiencing several (3) 'shorts' (time spent in C2
-	 * is less than the C2 transtional latency).
-	 */
-	if (pr->power.states[ACPI_STATE_C2].valid) {
-		pr->power.states[ACPI_STATE_C1].promotion.threshold.count = 10;
-		pr->power.states[ACPI_STATE_C1].promotion.threshold.time =
-			pr->power.states[ACPI_STATE_C2].latency;
-		pr->power.states[ACPI_STATE_C1].promotion.state = ACPI_STATE_C2;
-
-		pr->power.states[ACPI_STATE_C2].demotion.threshold.count = 3;
-		pr->power.states[ACPI_STATE_C2].demotion.threshold.time =
-			pr->power.states[ACPI_STATE_C2].latency;
-		pr->power.states[ACPI_STATE_C2].demotion.state = ACPI_STATE_C1;
-	}
-
-	/*
-	 * C2/C3
-	 * -----
-	 * Set default C2 promotion and C3 demotion policies, where we promote
-	 * from C2 to C3 after 4 cycles (0x0F) of no bus mastering activity
-	 * (while maintaining sleep time criteria).  Demote immediately on a
-	 * short or whenever bus mastering activity occurs.
-	 */
-	if ((pr->power.states[ACPI_STATE_C2].valid) &&
-		(pr->power.states[ACPI_STATE_C3].valid)) {
-		pr->power.states[ACPI_STATE_C2].promotion.threshold.count = 1;
-		pr->power.states[ACPI_STATE_C2].promotion.threshold.time =
-			pr->power.states[ACPI_STATE_C3].latency;
-		pr->power.states[ACPI_STATE_C2].promotion.threshold.bm = 0x0F;
-		pr->power.states[ACPI_STATE_C2].promotion.state = ACPI_STATE_C3;
-
-		pr->power.states[ACPI_STATE_C3].demotion.threshold.count = 1;
-		pr->power.states[ACPI_STATE_C3].demotion.threshold.time =
-			pr->power.states[ACPI_STATE_C3].latency;
-		pr->power.states[ACPI_STATE_C3].demotion.threshold.bm = 0x0F;
-		pr->power.states[ACPI_STATE_C3].demotion.state = ACPI_STATE_C2;
-	}
-
-	return_VALUE(0);
-}
-
-
-int
-acpi_processor_get_power_info (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-		"lvl2[0x%08x] lvl3[0x%08x]\n",
-		pr->power.states[ACPI_STATE_C2].address,
-		pr->power.states[ACPI_STATE_C3].address));
-
-	/* TBD: Support ACPI 2.0 objects */
-
-	/*
-	 * C0
-	 * --
-	 * This state exists only as filler in our array.
-	 */
-	pr->power.states[ACPI_STATE_C0].valid = 1;
-
-	/*
-	 * C1
-	 * --
-	 * ACPI requires C1 support for all processors.
-	 *
-	 * TBD: What about PROC_C1?
-	 */
-	pr->power.states[ACPI_STATE_C1].valid = 1;
-
-	/*
-	 * C2
-	 * --
-	 * We're (currently) only supporting C2 on UP systems.
-	 *
-	 * TBD: Support for C2 on MP (P_LVL2_UP).
-	 */
-	if (pr->power.states[ACPI_STATE_C2].address) {
-
-		pr->power.states[ACPI_STATE_C2].latency = acpi_fadt.plvl2_lat;
-
-		/*
-		 * C2 latency must be less than or equal to 100 microseconds.
-		 */
-		if (acpi_fadt.plvl2_lat >= ACPI_PROCESSOR_MAX_C2_LATENCY)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C2 latency too large [%d]\n",
-				acpi_fadt.plvl2_lat));
-		/*
-		 * Only support C2 on UP systems (see TBD above).
-		 */
-		else if (errata.smp)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C2 not supported in SMP mode\n"));
-		/*
-		 * Otherwise we've met all of our C2 requirements.
-		 */
-		else
-			pr->power.states[ACPI_STATE_C2].valid = 1;
-	}
-
-	/*
-	 * C3
-	 * --
-	 * TBD: Investigate use of WBINVD on UP/SMP system in absence of
-	 *	bm_control.
-	 */
-	if (pr->power.states[ACPI_STATE_C3].address) {
-
-		pr->power.states[ACPI_STATE_C3].latency = acpi_fadt.plvl3_lat;
-
-		/*
-		 * C3 latency must be less than or equal to 1000 microseconds.
-		 */
-		if (acpi_fadt.plvl3_lat >= ACPI_PROCESSOR_MAX_C3_LATENCY)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 latency too large [%d]\n", 
-				acpi_fadt.plvl3_lat));
-		/*
-		 * Only support C3 when bus mastering arbitration control
-		 * is present (able to disable bus mastering to maintain
-		 * cache coherency while in C3).
-		 */
-		else if (!pr->flags.bm_control)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 support requires bus mastering control\n"));
-		/*
-		 * Only support C3 on UP systems, as bm_control is only viable
-		 * on a UP system and flushing caches (e.g. WBINVD) is simply 
-		 * too costly (at this time).
-		 */
-		else if (errata.smp)
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 not supported in SMP mode\n"));
-		/*
-		 * PIIX4 Erratum #18: We don't support C3 when Type-F (fast) 
-		 * DMA transfers are used by any ISA device to avoid livelock.
-		 * Note that we could disable Type-F DMA (as recommended by
-		 * the erratum), but this is known to disrupt certain ISA 
-		 * devices thus we take the conservative approach.
-		 */
-		else if (errata.piix4.fdma) {
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				"C3 not supported on PIIX4 with Type-F DMA\n"));
-		}
-		/*
-		 * Otherwise we've met all of our C3 requirements.  Enable
-		 * checking of bus mastering status (bm_check) so we can 
-		 * use this in our C3 policy.
-		 */
-		else {
-			pr->power.states[ACPI_STATE_C3].valid = 1;
-			pr->flags.bm_check = 1;
-		}
-	}
-
-	/*
-	 * Set Default Policy
-	 * ------------------
-	 * Now that we know which state are supported, set the default
-	 * policy.  Note that this policy can be changed dynamically
-	 * (e.g. encourage deeper sleeps to conserve battery life when
-	 * not on AC).
-	 */
-	result = acpi_processor_set_power_policy(pr);
-	if (0 != result)
-		return_VALUE(result);
-
-	/*
-	 * If this processor supports C2 or C3 we denote it as being 'power
-	 * manageable'.  Note that there's really no policy involved for
-	 * when only C1 is supported.
-	 */
-	if (pr->power.states[ACPI_STATE_C2].valid 
-		|| pr->power.states[ACPI_STATE_C3].valid)
-		pr->flags.power = 1;
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                              Performance Management
-   -------------------------------------------------------------------------- */
-
-static int 
-acpi_processor_get_platform_limit (
-	struct acpi_processor*	pr)
-{
-	acpi_status		status = 0;
-	unsigned long		ppc = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_platform_limit");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/*
-	 * _PPC indicates the maximum state currently supported by the platform
-	 * (e.g. 0 = states 0..n; 1 = states 1..n; etc.
-	 */
-	status = acpi_evaluate_integer(pr->handle, "_PPC", NULL, &ppc);
-	if(ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PPC\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	pr->performance.platform_limit = (int) ppc;
-
-	return_VALUE(0);
-}
-
-
-static int 
-acpi_processor_get_performance_control (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	acpi_status		status = 0;
-	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_object		*pct = NULL;
-	acpi_object		obj = {0};
-	struct acpi_pct_register *reg = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_control");
-
-	status = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);
-	if(ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PCT\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	pct = (acpi_object *) buffer.pointer;
-	if (!pct || (pct->type != ACPI_TYPE_PACKAGE) 
-		|| (pct->package.count != 2)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PCT data\n"));
-		result = -EFAULT;
-		goto end;
-	}
-
-	/*
-	 * control_register
-	 */
-
-	obj = pct->package.elements[0];
-
-	if ((obj.type != ACPI_TYPE_BUFFER) 
-		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
-		|| (obj.buffer.pointer == NULL)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid _PCT data (control_register)\n"));
-		result = -EFAULT;
-		goto end;
-	}
-
-	reg = (struct acpi_pct_register *) (obj.buffer.pointer);
-
-	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unsupported address space [%d] (control_register)\n",
-			(u32) reg->space_id));
-		result = -EFAULT;
-		goto end;
-	}
-
-	pr->performance.control_register = (u16) reg->address;
-
-	/*
-	 * status_register
-	 */
-
-	obj = pct->package.elements[1];
-
-	if ((obj.type != ACPI_TYPE_BUFFER) 
-		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
-		|| (obj.buffer.pointer == NULL)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Invalid _PCT data (status_register)\n"));
-		result = -EFAULT;
-		goto end;
-	}
-
-	reg = (struct acpi_pct_register *) (obj.buffer.pointer);
-
-	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unsupported address space [%d] (status_register)\n",
-			(u32) reg->space_id));
-		result = -EFAULT;
-		goto end;
-	}
-
-	pr->performance.status_register = (u16) reg->address;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"control_register[0x%04x] status_register[0x%04x]\n",
-		pr->performance.control_register,
-		pr->performance.status_register));
-
-end:
-	kfree(buffer.pointer);
-
-	return_VALUE(result);
-}
-
-
-static int 
-acpi_processor_get_performance_states (
-	struct acpi_processor*	pr)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-	acpi_buffer		format = {sizeof("NNNNNN"), "NNNNNN"};
-	acpi_buffer		state = {0, NULL};
-	acpi_object 		*pss = NULL;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_states");
-
-	status = acpi_evaluate_object(pr->handle, "_PSS", NULL, &buffer);
-	if(ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PSS\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	pss = (acpi_object *) buffer.pointer;
-	if (!pss || (pss->type != ACPI_TYPE_PACKAGE)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
-		result = -EFAULT;
-		goto end;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d performance states\n", 
-		pss->package.count));
-
-	if (pss->package.count > ACPI_PROCESSOR_MAX_PERFORMANCE) {
-		pr->performance.state_count = ACPI_PROCESSOR_MAX_PERFORMANCE;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Limiting number of states to max (%d)\n", 
-			ACPI_PROCESSOR_MAX_PERFORMANCE));
-	}
-	else
-		pr->performance.state_count = pss->package.count;
-
-	if (pr->performance.state_count > 1)
-		pr->flags.performance = 1;
-
-	for (i = 0; i < pr->performance.state_count; i++) {
-
-		struct acpi_processor_px *px = &(pr->performance.states[i]);
-
-		state.length = sizeof(struct acpi_processor_px);
-		state.pointer = px;
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));
-
-		status = acpi_extract_package(&(pss->package.elements[i]), 
-			&format, &state);
-		if (ACPI_FAILURE(status)) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
-			result = -EFAULT;
-			goto end;
-		}
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\n",
-			i, 
-			(u32) px->core_frequency, 
-			(u32) px->power, 
-			(u32) px->transition_latency, 
-			(u32) px->bus_master_latency,
-			(u32) px->control, 
-			(u32) px->status));
-	}
-
-end:
-	kfree(buffer.pointer);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_processor_set_performance (
-	struct acpi_processor	*pr,
-	int			state)
-{
-	u16			port = 0;
-	u8			value = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_set_performance");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (!pr->flags.performance)
-		return_VALUE(-ENODEV);
-
-	if (state >= pr->performance.state_count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-			"Invalid target state (P%d)\n", state));
-		return_VALUE(-ENODEV);
-	}
-
-	if (state < pr->performance.platform_limit) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
-			"Platform limit (P%d) overrides target state (P%d)\n",
-			pr->performance.platform_limit, state));
-		return_VALUE(-ENODEV);
-	}
-
-	if (state == pr->performance.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Already at target state (P%d)\n", state));
-		return_VALUE(0);
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Transitioning from P%d to P%d\n",
-		pr->performance.state, state));
-
-	/*
-	 * First we write the target state's 'control' value to the
-	 * control_register.
-	 */
-
-	port = pr->performance.control_register;
-	value = (u16) pr->performance.states[state].control;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Writing 0x%02x to port 0x%04x\n", value, port));
-
-	outb(value, port); 
-
-	/*
-	 * Then we read the 'status_register' and compare the value with the
-	 * target state's 'status' to make sure the transition was successful.
-	 * Note that we'll poll for up to 1ms (100 cycles of 10us) before
-	 * giving up.
-	 */
-
-	port = pr->performance.status_register;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Looking for 0x%02x from port 0x%04x\n",
-		(u8) pr->performance.states[state].status, port));
-
-	for (i=0; i<100; i++) {
-		value = inb(port);
-		if (value == (u8) pr->performance.states[state].status)
-			break;
-		udelay(10);
-	}
-
-	if (value != pr->performance.states[state].status) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Transition failed\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Transition successful after %d microseconds\n",
-		i * 10));
-
-	pr->performance.state = state;
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_processor_get_performance_info (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	acpi_handle		handle = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_info");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	status = acpi_get_handle(pr->handle, "_PCT", &handle);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"ACPI-based processor performance control unavailable\n"));
-		return_VALUE(0);
-	}
-
-	result = acpi_processor_get_performance_control(pr);
-	if (0 != result)
-		return_VALUE(result);
-
-	result = acpi_processor_get_performance_states(pr);
-	if (0 != result)
-		return_VALUE(result);
-
-	result = acpi_processor_get_platform_limit(pr);
-	if (0 != result)
-		return_VALUE(result);
-
-	/* 
-	 * TBD: Don't trust the latency values we get from BIOS, but rather
-	 *      measure the latencies during run-time (e.g. get_latencies).
-	 */
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                              Throttling Control
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_processor_get_throttling (
-	struct acpi_processor	*pr)
-{
-	int			state = 0;
-	u32			value = 0;
-	u32			duty_mask = 0;
-	u32			duty_value = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (!pr->flags.throttling)
-		return_VALUE(-ENODEV);
-
-	pr->throttling.state = 0;
-
-	__cli();
-
-	duty_mask = pr->throttling.state_count - 1;
-
-	duty_mask <<= pr->throttling.duty_offset;
-
-	value = inl(pr->throttling.address);
-
-	/*
-	 * Compute the current throttling state when throttling is enabled
-	 * (bit 4 is on).
-	 */
-	if (value & 0x10) {
-		duty_value = value & duty_mask;
-		duty_value >>= pr->throttling.duty_offset;
-
-		if (duty_value)
-			state = pr->throttling.state_count-duty_value;
-	}
-
-	pr->throttling.state = state;
-
-	__sti();
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Throttling state is T%d (%d%% throttling applied)\n",
-		state, pr->throttling.states[state].performance));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_processor_set_throttling (
-	struct acpi_processor	*pr,
-	int			state)
-{
-	u32                     value = 0;
-	u32                     duty_mask = 0;
-	u32                     duty_value = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_set_throttling");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if ((state < 0) || (state > (pr->throttling.state_count - 1)))
-		return_VALUE(-EINVAL);
-
-	if (!pr->flags.throttling)
-		return_VALUE(-ENODEV);
-
-	if (state == pr->throttling.state)
-		return_VALUE(0);
-
-	__cli();
-
-	/*
-	 * Calculate the duty_value and duty_mask.
-	 */
-	if (state) {
-		duty_value = pr->throttling.state_count - state;
-
-		duty_value <<= pr->throttling.duty_offset;
-
-		/* Used to clear all duty_value bits */
-		duty_mask = pr->throttling.state_count - 1;
-
-		duty_mask <<= acpi_fadt.duty_offset;
-		duty_mask = ~duty_mask;
-	}
-
-	/*
-	 * Disable throttling by writing a 0 to bit 4.  Note that we must
-	 * turn it off before you can change the duty_value.
-	 */
-	value = inl(pr->throttling.address);
-	if (value & 0x10) {
-		value &= 0xFFFFFFEF;
-		outl(value, pr->throttling.address);
-	}
-
-	/*
-	 * Write the new duty_value and then enable throttling.  Note
-	 * that a state value of 0 leaves throttling disabled.
-	 */
-	if (state) {
-		value &= duty_mask;
-		value |= duty_value;
-		outl(value, pr->throttling.address);
-
-		value |= 0x00000010;
-		outl(value, pr->throttling.address);
-	}
-
-	pr->throttling.state = state;
-
-	__sti();
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-		"Throttling state set to T%d (%d%%)\n", state, 
-		(pr->throttling.states[state].performance?pr->throttling.states[state].performance/10:0)));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_processor_get_throttling_info (
-	struct acpi_processor	*pr)
-{
-	int			result = 0;
-	int			step = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling_info");
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-		"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",
-		pr->throttling.address,
-		pr->throttling.duty_offset,
-		pr->throttling.duty_width));
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	/* TBD: Support ACPI 2.0 objects */
-
-	if (!pr->throttling.address) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));
-		return_VALUE(0);
-	}
-	else if (!pr->throttling.duty_width) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));
-		return_VALUE(0);
-	}
-	/* TBD: Support duty_cycle values that span bit 4. */
-	else if ((pr->throttling.duty_offset
-		+ pr->throttling.duty_width) > 4) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "duty_cycle spans bit 4\n"));
-		return_VALUE(0);
-	}
-
-	/*
-	 * PIIX4 Errata: We don't support throttling on the original PIIX4.
-	 * This shouldn't be an issue as few (if any) mobile systems ever
-	 * used this part.
-	 */
-	if (errata.piix4.throttle) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"Throttling not supported on PIIX4 A- or B-step\n"));
-		return_VALUE(0);
-	}
-
-	pr->throttling.state_count = POWER_OF_2[acpi_fadt.duty_width];
-
-	/*
-	 * Compute state values. Note that throttling displays a linear power/
-	 * performance relationship (at 50% performance the CPU will consume
-	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.
-	 */
-
-	step = (1000 / pr->throttling.state_count);
-
-	for (i=0; i<pr->throttling.state_count; i++) {
-		pr->throttling.states[i].performance = step * i;
-		pr->throttling.states[i].power = step * i;
-	}
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n", 
-		pr->throttling.state_count));
-
-	pr->flags.throttling = 1;
-
-	/*
-	 * Disable throttling (if enabled).  We'll let subsequent policy (e.g. 
-	 * thermal) decide to lower performance if it so chooses, but for now 
-	 * we'll crank up the speed.
-	 */
-
-	result = acpi_processor_get_throttling(pr);
-	if (0 != result)
-		goto end;
-
-	if (pr->throttling.state) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabling throttling (was T%d)\n", 
-			pr->throttling.state));
-		result = acpi_processor_set_throttling(pr, 0);
-		if (0 != result)
-			goto end;
-	}
-
-end:
-	if (0 != result)
-		pr->flags.throttling = 0;
-
-	return_VALUE(result);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Limit Interface
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_processor_apply_limit (
-	struct acpi_processor* 	pr)
-{
-	int			result = 0;
-	u16			px = 0;
-	u16			tx = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_apply_limit");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (!pr->flags.limit)
-		return_VALUE(-ENODEV);
-
-	if (pr->flags.performance) {
-		px = pr->performance.platform_limit;
-		if (pr->limit.user.px > px)
-			px = pr->limit.user.px;
-		if (pr->limit.thermal.px > px)
-			px = pr->limit.thermal.px;
-
-		result = acpi_processor_set_performance(pr, px);
-		if (0 != result)
-			goto end;
-	}
-
-	if (pr->flags.throttling) {
-		if (pr->limit.user.tx > tx)
-			tx = pr->limit.user.tx;
-		if (pr->limit.thermal.tx > tx)
-			tx = pr->limit.thermal.tx;
-
-		result = acpi_processor_set_throttling(pr, tx);
-		if (0 != result)
-			goto end;
-	}
-
-	pr->limit.state.px = px;
-	pr->limit.state.tx = tx;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d] limit set to (P%d:T%d)\n",
-		pr->id,
-		pr->limit.state.px,
-		pr->limit.state.tx));
-
-end:
-	if (0 != result)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to set limit\n"));
-
-	return_VALUE(result);
-}
-
-
-int
-acpi_processor_set_thermal_limit (
-	acpi_handle		handle,
-	int			type)
-{
-	int			result = 0;
-	struct acpi_processor	*pr = NULL;
-	struct acpi_device	*device = NULL;
-	int			px = 0;
-	int			tx = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_set_thermal_limit");
-
-	if ((type < ACPI_PROCESSOR_LIMIT_NONE) 
-		|| (type > ACPI_PROCESSOR_LIMIT_DECREMENT))
-		return_VALUE(-EINVAL);
-
-	result = acpi_bus_get_device(handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-
-	pr = (struct acpi_processor *) acpi_driver_data(device);
-	if (!pr)
-		return_VALUE(-ENODEV);
-
-	if (!pr->flags.limit)
-		return_VALUE(-ENODEV);
-
-	/* Thermal limits are always relative to the current Px/Tx state. */
-	if (pr->flags.performance)
-		pr->limit.thermal.px = pr->performance.state;
-	if (pr->flags.throttling)
-		pr->limit.thermal.tx = pr->throttling.state;
-
-	/*
-	 * Our default policy is to only use throttling at the lowest
-	 * performance state.
-	 */
-
-	switch (type) {
-
-	case ACPI_PROCESSOR_LIMIT_NONE:
-		px = 0;
-		tx = 0;
-		break;
-
-	case ACPI_PROCESSOR_LIMIT_INCREMENT:
-		if (pr->flags.performance) {
-			if (px == (pr->performance.state_count - 1))
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At maximum performance state\n"));
-			else {
-				px++;
-				goto end;
-			}
-		}
-		if (pr->flags.throttling) {
-			if (tx == (pr->throttling.state_count - 1))
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At maximum throttling state\n"));
-			else
-				tx++;
-		}
-		break;
-
-	case ACPI_PROCESSOR_LIMIT_DECREMENT:
-		if (pr->flags.performance) {
-			if (px == pr->performance.platform_limit)
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At minimum performance state\n"));
-			else  {
-				px--;
-				goto end;
-			}
-		}
-		if (pr->flags.throttling) {
-			if (tx == 0)
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-					"At minimum throttling state\n"));
-			else
-				tx--;
-		}
-		break;
-	}
-
-end:
-	pr->limit.thermal.px = px;
-	pr->limit.thermal.tx = tx;
-
-	result = acpi_processor_apply_limit(pr);
-	if (0 != result)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Unable to set thermal limit\n"));
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Thermal limit now (P%d:T%d)\n",
-		pr->limit.thermal.px,
-		pr->limit.thermal.tx));
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_processor_get_limit_info (
-	struct acpi_processor	*pr)
-{
-	ACPI_FUNCTION_TRACE("acpi_processor_get_limit_info");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-	if (pr->flags.performance || pr->flags.throttling)
-		pr->flags.limit = 1;
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-struct proc_dir_entry		*acpi_processor_dir = NULL;
-
-static int
-acpi_processor_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_read_info");
-
-	if (!pr || (off != 0))
-		goto end;
-
-	p += sprintf(p, "processor id:            %d\n",
-		pr->id);
-
-	p += sprintf(p, "acpi id:                 %d\n",
-		pr->acpi_id);
-
-	p += sprintf(p, "bus mastering control:   %s\n",
-		pr->flags.bm_control ? "yes" : "no");
-
-	p += sprintf(p, "power management:        %s\n",
-		pr->flags.power ? "yes" : "no");
-
-	p += sprintf(p, "throttling control:      %s\n",
-		pr->flags.throttling ? "yes" : "no");
-
-	p += sprintf(p, "performance management:  %s\n",
-		pr->flags.performance ? "yes" : "no");
-
-	p += sprintf(p, "limit interface:         %s\n",
-		pr->flags.limit ? "yes" : "no");
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_processor_read_power (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			*p = page;
-	int			len = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_read_power");
-
-	if (!pr || (off != 0))
-		goto end;
-
-	p += sprintf(p, "active state:            C%d\n",
-		pr->power.state);
-
-	p += sprintf(p, "default state:           C%d\n",
-		pr->power.default_state);
-
-	p += sprintf(p, "bus master activity:     %08x\n",
-		pr->power.bm_activity);
-
-	p += sprintf(p, "states:\n");
-
-	for (i=1; i<ACPI_C_STATE_COUNT; i++) {
-
-		p += sprintf(p, "   %cC%d:                  ", 
-			(i == pr->power.state?'*':' '), i);
-
-		if (!pr->power.states[i].valid) {
-			p += sprintf(p, "<not supported>\n");
-			continue;
-		}
-
-		if (pr->power.states[i].promotion.state)
-			p += sprintf(p, "promotion[C%d] ",
-				pr->power.states[i].promotion.state);
-		else
-			p += sprintf(p, "promotion[--] ");
-
-		if (pr->power.states[i].demotion.state)
-			p += sprintf(p, "demotion[C%d] ",
-				pr->power.states[i].demotion.state);
-		else
-			p += sprintf(p, "demotion[--] ");
-
-		p += sprintf(p, "latency[%03d] usage[%08d]\n",
-			pr->power.states[i].latency,
-			pr->power.states[i].usage);
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_processor_read_performance (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			*p = page;
-	int			len = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_read_performance");
-
-	if (!pr || (off != 0))
-		goto end;
-
-	if (!pr->flags.performance) {
-		p += sprintf(p, "<not supported>\n");
-		goto end;
-	}
-
-	p += sprintf(p, "state count:             %d\n",
-		pr->performance.state_count);
-
-	p += sprintf(p, "active state:            P%d\n",
-		pr->performance.state);
-
-	p += sprintf(p, "states:\n");
-
-	for (i=0; i<pr->performance.state_count; i++)
-		p += sprintf(p, "   %cP%d:                  %d Mhz, %d mW, %d uS\n",
-			(i == pr->performance.state?'*':' '), i,
-			(u32) pr->performance.states[i].core_frequency,
-			(u32) pr->performance.states[i].power,
-			(u32) pr->performance.states[i].transition_latency);
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_processor_write_performance (
-        struct file		*file,
-        const char		*buffer,
-        unsigned long		count,
-        void			*data)
-{
-	int			result = 0;
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			state_string[12] = {'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_processor_write_performance");
-
-	if (!pr || (count > sizeof(state_string) - 1))
-		return_VALUE(-EINVAL);
-	
-	if (copy_from_user(state_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	state_string[count] = '\0';
-
-	result = acpi_processor_set_performance(pr, 
-		simple_strtoul(state_string, NULL, 0));
-	if (0 != result)
-		return_VALUE(result);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_processor_read_throttling (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			*p = page;
-	int			len = 0;
-	int			i = 0;
-	int                     result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_read_throttling");
-
-	if (!pr || (off != 0))
-		goto end;
-
-	if (!(pr->throttling.state_count > 0)) {
-		p += sprintf(p, "<not supported>\n");
-		goto end;
-	}
-
-	result = acpi_processor_get_throttling(pr);
-
-	if (result) {
-		p += sprintf(p, "Could not determine current throttling state.\n");
-		goto end;
-	}
-
-	p += sprintf(p, "state count:             %d\n",
-		pr->throttling.state_count);
-
-	p += sprintf(p, "active state:            T%d\n",
-		pr->throttling.state);
-
-	p += sprintf(p, "states:\n");
-
-	for (i=0; i<pr->throttling.state_count; i++)
-		p += sprintf(p, "   %cT%d:                  %02d%%\n",
-			(i == pr->throttling.state?'*':' '), i,
-			(pr->throttling.states[i].performance?pr->throttling.states[i].performance/10:0));
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_processor_write_throttling (
-        struct file		*file,
-        const char		*buffer,
-        unsigned long		count,
-        void			*data)
-{
-	int			result = 0;
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			state_string[12] = {'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_processor_write_throttling");
-
-	if (!pr || (count > sizeof(state_string) - 1))
-		return_VALUE(-EINVAL);
-	
-	if (copy_from_user(state_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	state_string[count] = '\0';
-	
-	result = acpi_processor_set_throttling(pr, 
-		simple_strtoul(state_string, NULL, 0));
-	if (0 != result)
-		return_VALUE(result);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_processor_read_limit (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_read_limit");
-
-	if (!pr || (off != 0))
-		goto end;
-
-	if (!pr->flags.limit) {
-		p += sprintf(p, "<not supported>\n");
-		goto end;
-	}
-
-	p += sprintf(p, "active limit:            P%d:T%d\n",
-		pr->limit.state.px, pr->limit.state.tx);
-
-	p += sprintf(p, "platform limit:          P%d:T0\n",
-		pr->flags.performance?pr->performance.platform_limit:0);
-
-	p += sprintf(p, "user limit:              P%d:T%d\n",
-		pr->limit.user.px, pr->limit.user.tx);
-
-	p += sprintf(p, "thermal limit:           P%d:T%d\n",
-		pr->limit.thermal.px, pr->limit.thermal.tx);
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_processor_write_limit (
-        struct file		*file,
-        const char		*buffer,
-        unsigned long		count,
-        void			*data)
-{
-	int			result = 0;
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	char			limit_string[25] = {'\0'};
-	int			px = 0;
-	int			tx = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_write_limit");
-
-	if (!pr || (count > sizeof(limit_string) - 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
-		return_VALUE(-EINVAL);
-	}
-	
-	if (copy_from_user(limit_string, buffer, count)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
-		return_VALUE(-EFAULT);
-	}
-	
-	limit_string[count] = '\0';
-
-	if (sscanf(limit_string, "%d:%d", &px, &tx) != 2) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
-		return_VALUE(-EINVAL);
-	}
-
-	if (pr->flags.performance) {
-		if ((px < pr->performance.platform_limit) 
-			|| (px > (pr->performance.state_count - 1))) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid px\n"));
-			return_VALUE(-EINVAL);
-		}
-		pr->limit.user.px = px;
-	}
-
-	if (pr->flags.throttling) {
-		if ((tx < 0) || (tx > (pr->throttling.state_count - 1))) {
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid tx\n"));
-			return_VALUE(-EINVAL);
-		}
-		pr->limit.user.tx = tx;
-	}
-
-	result = acpi_processor_apply_limit(pr);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_processor_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_add_fs");
-
-	if (!acpi_processor_dir) {
-		acpi_processor_dir = proc_mkdir(ACPI_PROCESSOR_CLASS, 
-			acpi_root_dir);
-		if (!acpi_processor_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_processor_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_INFO));
-	else {
-		entry->read_proc = acpi_processor_read_info;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'power' [R] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_POWER,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_POWER));
-	else {
-		entry->read_proc = acpi_processor_read_power;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'performance' [R/W] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_PERFORMANCE,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_PERFORMANCE));
-	else {
-		entry->read_proc = acpi_processor_read_performance;
-		entry->write_proc = acpi_processor_write_performance;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'throttling' [R/W] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_THROTTLING,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_THROTTLING));
-	else {
-		entry->read_proc = acpi_processor_read_throttling;
-		entry->write_proc = acpi_processor_write_throttling;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'limit' [R/W] */
-	entry = create_proc_entry(ACPI_PROCESSOR_FILE_LIMIT,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_PROCESSOR_FILE_LIMIT));
-	else {
-		entry->read_proc = acpi_processor_read_limit;
-		entry->write_proc = acpi_processor_write_limit;
-		entry->data = acpi_driver_data(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_processor_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_processor_remove_fs");
-
-	if (!acpi_processor_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_processor_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Driver Interface
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_processor_get_info (
-	struct acpi_processor	*pr)
-{
-	acpi_status		status = 0;
-	acpi_object		object = {0};
-	acpi_buffer		buffer = {sizeof(acpi_object), &object};
-	static int		cpu_count = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_get_info");
-
-	if (!pr)
-		return_VALUE(-EINVAL);
-
-#ifdef CONFIG_SMP
-	if (smp_num_cpus > 1)
-		errata.smp = smp_num_cpus;
-#endif
-
-	acpi_processor_errata(pr);
-
-	/*
-	 * Check to see if we have bus mastering arbitration control.  This
-	 * is required for proper C3 usage (to maintain cache coherency).
-	 */
-	if (acpi_fadt.V1_pm2_cnt_blk && acpi_fadt.pm2_cnt_len) {
-		pr->flags.bm_control = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Bus mastering arbitration control present\n"));
-	}
-	else
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"No bus mastering arbitration control\n"));
-
-	/*
-	 * Evalute the processor object.  Note that it is common on SMP to
-	 * have the first (boot) processor with a valid PBLK address while
-	 * all others have a NULL address.
-	 */
-	status = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error evaluating processor object\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	/*
-	 * TBD: Synch processor ID (via LAPIC/LSAPIC structures) on SMP.
-	 *	>>> 'acpi_get_processor_id(acpi_id, &id)' in arch/xxx/acpi.c
-	 */
-	pr->id = cpu_count++;
-	pr->acpi_id = object.processor.proc_id;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id, 
-		pr->acpi_id));
-
-	if (!object.processor.pblk_address)
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No PBLK (NULL address)\n"));
-	else if (object.processor.pblk_length < 6)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid PBLK length [%d]\n",
-			object.processor.pblk_length));
-	else {
-		pr->throttling.address = object.processor.pblk_address;
-		pr->throttling.duty_offset = acpi_fadt.duty_offset;
-		pr->throttling.duty_width = acpi_fadt.duty_width;
-		pr->power.states[ACPI_STATE_C2].address =
-			object.processor.pblk_address + 4;
-		pr->power.states[ACPI_STATE_C3].address =
-			object.processor.pblk_address + 5;
-	}
-
-	acpi_processor_get_power_info(pr);
-	acpi_processor_get_performance_info(pr);
-	acpi_processor_get_throttling_info(pr);
-	acpi_processor_get_limit_info(pr);
-
-	return_VALUE(0);
-}
-
-
-static void
-acpi_processor_notify (
-	acpi_handle		handle,
-	u32			event,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_processor	*pr = (struct acpi_processor *) data;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_notify");
-
-	if (!pr)
-		return_VOID;
-
-	if (0 != acpi_bus_get_device(pr->handle, &device))
-		return_VOID;
-
-	switch (event) {
-	case ACPI_PROCESSOR_NOTIFY_PERFORMANCE:
-		result = acpi_processor_get_platform_limit(pr);
-		if (0 == result)
-			acpi_processor_apply_limit(pr);
-
-		acpi_bus_generate_event(device, event, 
-			pr->performance.platform_limit);
-		break;
-	case ACPI_PROCESSOR_NOTIFY_POWER:
-		/* TBD */
-		acpi_bus_generate_event(device, event, 0);
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
-		break;
-	}
-
-	return_VOID;
-}
-
-
-static int
-acpi_processor_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_processor	*pr = NULL;
-	u32			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	pr = kmalloc(sizeof(struct acpi_processor), GFP_KERNEL);
-	if (!pr)
-		return_VALUE(-ENOMEM);
-	memset(pr, 0, sizeof(struct acpi_processor));
-
-	pr->handle = device->handle;
-	sprintf(acpi_device_name(device), "%s", ACPI_PROCESSOR_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_PROCESSOR_CLASS);
-	acpi_driver_data(device) = pr;
-
-	result = acpi_processor_get_info(pr);
-	if (0 != result)
-		goto end;
-
-	result = acpi_processor_add_fs(device);
-	if (0 != result)
-		goto end;
-
-	status = acpi_install_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
-		acpi_processor_notify, pr);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Error installing notify handler\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	processors[pr->id] = pr;
-
-	/*
-	 * Install the idle handler if processor power management is supported.
-	 * Note that the default idle handler (default_idle) will be used on 
-	 * platforms that only support C1.
-	 */
-	if ((pr->id == 0) && (pr->flags.power)) {
-		pm_idle_save = pm_idle;
-		pm_idle = acpi_processor_idle;
-	}
-	
-	printk(KERN_INFO PREFIX "%s [%s] (supports",
-		acpi_device_name(device), acpi_device_bid(device));
-	for (i=1; i<ACPI_C_STATE_COUNT; i++)
-		if (pr->power.states[i].valid)
-			printk(" C%d", i);
-	if (pr->flags.performance)
-		printk(", %d performance states", pr->performance.state_count);
-	if (pr->flags.throttling)
-		printk(", %d throttling states", pr->throttling.state_count);
-	printk(")\n");
-
-end:
-	if (0 != result) {
-		acpi_processor_remove_fs(device);
-		kfree(pr);
-	}
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_processor_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_processor	*pr = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	pr = (struct acpi_processor *) acpi_driver_data(device);
-
-	/* Unregister the idle handler when processor #0 is removed. */
-	if (pr->id == 0)
-		pm_idle = pm_idle_save;
-
-	status = acpi_remove_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
-		acpi_processor_notify);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
-			"Error removing notify handler\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	acpi_processor_remove_fs(device);
-
-	processors[pr->id] = NULL;
-
-	kfree(pr);
-
-	return_VALUE(0);
-}
-
-
-static int __init
-acpi_processor_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_init");
-
-	memset(&processors, 0, sizeof(processors));
-	memset(&errata, 0, sizeof(errata));
-
-	result = acpi_bus_register_driver(&acpi_processor_driver);
-	if (0 > result)
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-static void __exit
-acpi_processor_exit (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_processor_exit");
-
-	result = acpi_bus_unregister_driver(&acpi_processor_driver);
-	if (0 == result)
-		remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
-
-
-module_init(acpi_processor_init);
-module_exit(acpi_processor_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_system.c linux/drivers/acpi/acpi_system.c
--- ../prev/linux/drivers/acpi/acpi_system.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_system.c	Wed Dec 31 17:00:00 1969
@@ -1,1251 +0,0 @@
-/*
- *  acpi_system.c - ACPI System Driver ($Revision: 45 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/spinlock.h>
-#include <linux/poll.h>
-#include <linux/delay.h>
-#include <linux/sysrq.h>
-#include <linux/pm.h>
-#include <asm/uaccess.h>
-#include <asm/acpi.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-#ifdef CONFIG_X86
-#ifdef CONFIG_ACPI_SLEEP
-#include <linux/mc146818rtc.h>
-#endif
-#endif
-
-
-#define _COMPONENT		ACPI_SYSTEM_COMPONENT
-ACPI_MODULE_NAME		("acpi_system")
-
-#define PREFIX			"ACPI: "
-
-extern FADT_DESCRIPTOR		acpi_fadt;
-
-static int acpi_system_add (struct acpi_device *device);
-static int acpi_system_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_system_driver = {
-	name:			ACPI_SYSTEM_DRIVER_NAME,
-	class:			ACPI_SYSTEM_CLASS,
-	ids:			ACPI_SYSTEM_HID,
-	ops:			{
-					add:	acpi_system_add,
-					remove:	acpi_system_remove
-				},
-};
-
-struct acpi_system
-{
-	acpi_handle		handle;
-	u8			states[ACPI_S_STATE_COUNT];
-};
-
-/* Global vars for handling event proc entry */
-static spinlock_t		acpi_system_event_lock = SPIN_LOCK_UNLOCKED;
-int				event_is_open = 0;
-extern struct list_head		acpi_bus_event_list;
-extern wait_queue_head_t	acpi_bus_event_queue;
-
-/* --------------------------------------------------------------------------
-                                  System Sleep
-   -------------------------------------------------------------------------- */
-
-#ifdef CONFIG_PM
-
-static void
-acpi_power_off (void)
-{
-	acpi_enter_sleep_state_prep(ACPI_STATE_S5);
-	ACPI_DISABLE_IRQS();
-	acpi_enter_sleep_state(ACPI_STATE_S5);
-}
-
-#endif /*CONFIG_PM*/
-
-
-#ifdef CONFIG_ACPI_SLEEP
-
-/**
- * acpi_system_restore_state - OS-specific restoration of state
- * @state:	sleep state we're exiting
- *
- * Note that if we're coming back from S4, the memory image should have already
- * been loaded from the disk and is already in place. (Otherwise how else would we
- * be here?).
- */
-acpi_status
-acpi_system_restore_state (
-	u32			state)
-{
-	/* restore processor state
-	 * We should only be here if we're coming back from STR or STD.
-	 * And, in the case of the latter, the memory image should have already
-	 * been loaded from disk.
-	 */
-	if (state > ACPI_STATE_S1)
-		acpi_restore_state_mem();
-
-	/* wait for power to come back */
-	mdelay(10);
-#ifdef HAVE_NEW_DEVICE_MODEL
-	/* turn all the devices back on */
-	device_resume(RESUME_POWER_ON);
-
-	/* enable interrupts once again */
-	ACPI_ENABLE_IRQS();
-
-	/* restore device context */
-	device_resume(RESUME_RESTORE_STATE);
-#endif
-	return AE_OK;
-}
-
-/**
- * acpi_system_save_state - save OS specific state and power down devices
- * @state:	sleep state we're entering.
- *
- * This handles saving all context to memory, and possibly disk.
- * First, we call to the device driver layer to save device state.
- * Once we have that, we save whatevery processor and kernel state we
- * need to memory.
- * If we're entering S4, we then write the memory image to disk.
- *
- * Only then is it safe for us to power down devices, since we may need
- * the disks and upstream buses to write to.
- */
-acpi_status
-acpi_system_save_state(
-	u32			state)
-{
-	int			error = 0;
-
-#ifdef HAVE_NEW_DEVICE_MODEL
-	/* Send notification to devices that they will be suspended.
-	 * If any device or driver cannot make the transition, either up
-	 * or down, we'll get an error back.
-	 */
-	error = device_suspend(state, SUSPEND_NOTIFY);
-	if (error)
-		return AE_ERROR;
-#endif
-	if (state < ACPI_STATE_S5) {
-
-#ifdef HAVE_NEW_DEVICE_MODEL
-		/* Tell devices to stop I/O and actually save their state.
-		 * It is theoretically possible that something could fail,
-		 * so handle that gracefully..
-		 */
-		error = device_suspend(state, SUSPEND_SAVE_STATE);
-		if (error) {
-			/* tell devices to restore state if they have
-			 * it saved and to start taking I/O requests.
-			 */
-			device_resume(RESUME_RESTORE_STATE);
-			return error;
-		}
-#endif
-
-		/* flush caches */
-		ACPI_FLUSH_CPU_CACHE();
-
-		/* Do arch specific saving of state. */
-		if (state > ACPI_STATE_S1) {
-			error = acpi_save_state_mem();
-
-			if (!error && (state == ACPI_STATE_S4))
-				error = acpi_save_state_disk();
-
-#ifdef HAVE_NEW_DEVICE_MODEL
-			if (error) {
-				device_resume(RESUME_RESTORE_STATE);
-				return error;
-			}
-#endif
-		}
-	}
-#ifdef HAVE_NEW_DEVICE_MODEL
-	/* disable interrupts
-	 * Note that acpi_suspend -- our caller -- will do this once we return.
-	 * But, we want it done early, so we don't get any suprises during
-	 * the device suspend sequence.
-	 */
-	ACPI_DISABLE_IRQS();
-
-	/* Unconditionally turn off devices.
-	 * Obvious if we enter a sleep state.
-	 * If entering S5 (soft off), this should put devices in a
-	 * quiescent state.
-	 */
-	error = device_suspend(state, SUSPEND_POWER_DOWN);
-
-	/* We're pretty screwed if we got an error from this.
-	 * We try to recover by simply calling our own restore_state
-	 * function; see above for definition.
-	 *
-	 * If it's S5 though, go through with it anyway..
-	 */
-	if (error && state != ACPI_STATE_S5)
-		acpi_system_restore_state(state);
-#endif
-	return error ? AE_ERROR : AE_OK;
-}
-
-
-/****************************************************************************
- *
- * FUNCTION:    acpi_system_suspend
- *
- * PARAMETERS:  %state: Sleep state to enter.
- *
- * RETURN:      acpi_status, whether or not we successfully entered and
- *              exited sleep.
- *
- * DESCRIPTION: Perform OS-specific action to enter sleep state.
- *              This is the final step in going to sleep, per spec.  If we
- *              know we're coming back (i.e. not entering S5), we save the
- *              processor flags. [ We'll have to save and restore them anyway,
- *              so we use the arch-agnostic save_flags and restore_flags
- *              here.]  We then set the place to return to in arch-specific
- *              globals using arch_set_return_point. Finally, we call the
- *              ACPI function to write the proper values to I/O ports.
- *
- ****************************************************************************/
-
-acpi_status
-acpi_system_suspend(
-	u32			state)
-{
-	acpi_status		status = AE_ERROR;
-	unsigned long		flags = 0;
-
-	save_flags(flags);
-	
-	switch (state)
-	{
-	case ACPI_STATE_S1:
-		/* do nothing */
-		break;
-
-	case ACPI_STATE_S2:
-	case ACPI_STATE_S3:
-		acpi_save_register_state((unsigned long)&&acpi_sleep_done);
-		break;
-	}
-
-	barrier();
-	status = acpi_enter_sleep_state(state);
-
-acpi_sleep_done:
-
-	acpi_restore_register_state();
-	restore_flags(flags);
-
-	return status;
-}
-
-
-/**
- * acpi_suspend - OS-agnostic system suspend/resume support (S? states)
- * @state:	state we're entering
- *
- */
-acpi_status
-acpi_suspend (
-	u32			state)
-{
-	acpi_status status;
-
-	/* get out if state is invalid */
-	if (state < ACPI_STATE_S1 || state > ACPI_STATE_S5)
-		return AE_ERROR;
-
-	/* do we have a wakeup address for S2 and S3? */
-	if (state == ACPI_STATE_S2 || state == ACPI_STATE_S3) {
-		if (!acpi_wakeup_address)
-			return AE_ERROR;
-		acpi_set_firmware_waking_vector((ACPI_PHYSICAL_ADDRESS) acpi_wakeup_address);
-	}
-
-	acpi_enter_sleep_state_prep(state);
-
-	status = acpi_system_save_state(state);
-	if (!ACPI_SUCCESS(status))
-		return status;
-
-	/* disable interrupts and flush caches */
-	ACPI_DISABLE_IRQS();
-	ACPI_FLUSH_CPU_CACHE();
-
-	/* perform OS-specific sleep actions */
-	status = acpi_system_suspend(state);
-
-	/* Even if we failed to go to sleep, all of the devices are in an suspended
-	 * mode. So, we run these unconditionaly to make sure we have a usable system
-	 * no matter what.
-	 */
-	acpi_system_restore_state(state);
-	acpi_leave_sleep_state(state);
-
-	/* make sure interrupts are enabled */
-	ACPI_ENABLE_IRQS();
-
-	/* reset firmware waking vector */
-	acpi_set_firmware_waking_vector((ACPI_PHYSICAL_ADDRESS) 0);
-
-	return status;
-}
-
-#endif /* CONFIG_ACPI_SLEEP */
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-
-static int
-acpi_system_read_info (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_system	*system = (struct acpi_system *) data;
-	char			*p = page;
-	int			size = 0;
-	u32			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_system_read_info");
-
-	if (!system || (off != 0))
-		goto end;
-
-	p += sprintf(p, "version:                 %x\n", ACPI_CA_VERSION);
-
-	p += sprintf(p, "states:                  ");
-	for (i=0; i<ACPI_S_STATE_COUNT; i++) {
-		if (system->states[i])
-			p += sprintf(p, "S%d ", i);
-	}
-	p += sprintf(p, "\n");
-
-end:
-	size = (p - page);
-	if (size <= off+count) *eof = 1;
-	*start = page + off;
-	size -= off;
-	if (size>count) size = count;
-	if (size<0) size = 0;
-
-	return_VALUE(size);
-}
-
-static int acpi_system_open_event(struct inode *inode, struct file *file);
-static ssize_t acpi_system_read_event (struct file*, char*, size_t, loff_t*);
-static int acpi_system_close_event(struct inode *inode, struct file *file);
-static unsigned int acpi_system_poll_event(struct file *file, poll_table *wait);
-
-
-static struct file_operations acpi_system_event_ops = {
-	open:		acpi_system_open_event,
-	read:		acpi_system_read_event,
-	release:	acpi_system_close_event,
-	poll:		acpi_system_poll_event,
-};
-
-static int
-acpi_system_open_event(struct inode *inode, struct file *file)
-{
-	spin_lock_irq (&acpi_system_event_lock);
-
-	if(event_is_open)
-		goto out_busy;
-
-	event_is_open = 1;
-
-	spin_unlock_irq (&acpi_system_event_lock);
-	return 0;
-
-out_busy:
-	spin_unlock_irq (&acpi_system_event_lock);
-	return -EBUSY;
-}
-
-static ssize_t
-acpi_system_read_event (
-	struct file		*file,
-	char			*buffer,
-	size_t			count,
-	loff_t			*ppos)
-{
-	int			result = 0;
-	char			outbuf[ACPI_MAX_STRING];
-	int			size = 0;
-	struct acpi_bus_event	event;
-
-	ACPI_FUNCTION_TRACE("acpi_system_read_event");
-
-	memset(&event, 0, sizeof(struct acpi_bus_event));
-
-	if (count < ACPI_MAX_STRING)
-		goto end;
-
-	if ((file->f_flags & O_NONBLOCK)
-	    && (list_empty(&acpi_bus_event_list)))
-		return_VALUE(-EAGAIN);
-
-	result = acpi_bus_receive_event(&event);
-	if (0 != result) {
-		size = sprintf(outbuf, "error\n");
-		goto end;
-	}
-
-	size = sprintf(outbuf, "%s %s %08x %08x\n", 
-		event.device_class?event.device_class:"<unknown>",
-		event.bus_id?event.bus_id:"<unknown>", 
-		event.type, 
-		event.data);
-
-end:
-	if (copy_to_user(buffer, outbuf, size))
-		return_VALUE(-EFAULT);
-
-	*ppos += size;
-
-	return_VALUE(size);
-}
-
-static int
-acpi_system_close_event(struct inode *inode, struct file *file)
-{
-	spin_lock_irq (&acpi_system_event_lock);
-	event_is_open = 0;
-	spin_unlock_irq (&acpi_system_event_lock);
-	return 0;
-}
-
-static unsigned int
-acpi_system_poll_event(
-	struct file		*file,
-	poll_table		*wait)
-{
-	poll_wait(file, &acpi_bus_event_queue, wait);
-	if (!list_empty(&acpi_bus_event_list))
-		return POLLIN | POLLRDNORM;
-	return 0;
-}
-
-static ssize_t acpi_system_read_dsdt (struct file*, char*, size_t, loff_t*);
-
-static struct file_operations acpi_system_dsdt_ops = {
-	read:			acpi_system_read_dsdt,
-};
-
-static ssize_t
-acpi_system_read_dsdt (
-	struct file		*file,
-	char			*buffer,
-	size_t			count,
-	loff_t			*ppos)
-{
-	acpi_status		status = AE_OK;
-	acpi_buffer		dsdt = {ACPI_ALLOCATE_BUFFER, NULL};
-	void			*data = 0;
-	size_t			size = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_system_read_dsdt");
-
-	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	if (*ppos < dsdt.length) {
-		data = dsdt.pointer + file->f_pos;
-		size = dsdt.length - file->f_pos;
-		if (size > count)
-			size = count;
-		if (copy_to_user(buffer, data, size)) {
-			kfree(dsdt.pointer);
-			return_VALUE(-EFAULT);
-		}
-	}
-
-	kfree(dsdt.pointer);
-
-	*ppos += size;
-
-	return_VALUE(size);
-}
-
-
-static ssize_t acpi_system_read_fadt (struct file*, char*, size_t, loff_t*);
-
-static struct file_operations acpi_system_fadt_ops = {
-	read:			acpi_system_read_fadt,
-};
-
-static ssize_t
-acpi_system_read_fadt (
-	struct file		*file,
-	char			*buffer,
-	size_t			count,
-	loff_t			*ppos)
-{
-	acpi_status		status = AE_OK;
-	acpi_buffer		fadt = {ACPI_ALLOCATE_BUFFER, NULL};
-	void			*data = 0;
-	size_t			size = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_system_read_fadt");
-
-	status = acpi_get_table(ACPI_TABLE_FADT, 1, &fadt);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	if (*ppos < fadt.length) {
-		data = fadt.pointer + file->f_pos;
-		size = fadt.length - file->f_pos;
-		if (size > count)
-			size = count;
-		if (copy_to_user(buffer, data, size)) {
-			kfree(fadt.pointer);
-			return_VALUE(-EFAULT);
-		}
-	}
-
-	kfree(fadt.pointer);
-
-	*ppos += size;
-
-	return_VALUE(size);
-}
-
-
-#ifdef ACPI_DEBUG
-
-static int
-acpi_system_read_debug (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	char			*p = page;
-	int 			size = 0;
-
-	if (off != 0)
-		goto end;
-
-	switch ((unsigned long) data) {
-	case 0:
-		p += sprintf(p, "0x%08x\n", acpi_dbg_layer);
-		break;
-	case 1:
-		p += sprintf(p, "0x%08x\n", acpi_dbg_level);
-		break;
-	default:
-		p += sprintf(p, "Invalid debug option\n");
-		break;
-	}
-	
-end:
-	size = (p - page);
-	if (size <= off+count) *eof = 1;
-	*start = page + off;
-	size -= off;
-	if (size>count) size = count;
-	if (size<0) size = 0;
-
-	return size;
-}
-
-
-static int
-acpi_system_write_debug (
-	struct file             *file,
-        const char              *buffer,
-	unsigned long           count,
-        void                    *data)
-{
-	char			debug_string[12] = {'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_system_write_debug");
-
-	if (count > sizeof(debug_string) - 1)
-		return_VALUE(-EINVAL);
-
-	if (copy_from_user(debug_string, buffer, count))
-		return_VALUE(-EFAULT);
-
-	debug_string[count] = '\0';
-
-	switch ((unsigned long) data) {
-	case 0:
-		acpi_dbg_layer = simple_strtoul(debug_string, NULL, 0);
-		break;
-	case 1:
-		acpi_dbg_level = simple_strtoul(debug_string, NULL, 0);
-		break;
-	default:
-		return_VALUE(-EINVAL);
-	}
-
-	return_VALUE(count);
-}
-
-#endif /* ACPI_DEBUG */
-
-
-#ifdef CONFIG_ACPI_SLEEP
-
-static int
-acpi_system_read_sleep (
-        char                    *page,
-        char                    **start,
-        off_t                   off,
-        int                     count,
-        int                     *eof,
-        void                    *data)
-{
-	struct acpi_system	*system = (struct acpi_system *) data;
-	char			*p = page;
-	int			size;
-	int			i;
-
-	ACPI_FUNCTION_TRACE("acpi_system_read_sleep");
-
-	if (!system || (off != 0))
-		goto end;
-
-	for (i = 0; i <= ACPI_STATE_S5; i++) {
-		if (system->states[i])
-			p += sprintf(p,"S%d ", i);
-	}
-
-	p += sprintf(p, "\n");
-
-end:
-	size = (p - page);
-	if (size <= off+count) *eof = 1;
-	*start = page + off;
-	size -= off;
-	if (size>count) size = count;
-	if (size<0) size = 0;
-
-	return_VALUE(size);
-}
-
-
-static int
-acpi_system_write_sleep (
-	struct file		*file,
-	const char		*buffer,
-	unsigned long		count,
-	void			*data)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_system	*system = (struct acpi_system *) data;
-	char			state_string[12] = {'\0'};
-	u32			state = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_system_write_sleep");
-
-	if (!system || (count > sizeof(state_string) - 1))
-		return_VALUE(-EINVAL);
-
-	if (copy_from_user(state_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	state_string[count] = '\0';
-	
-	state = simple_strtoul(state_string, NULL, 0);
-	
-	if (!system->states[state])
-		return_VALUE(-ENODEV);
-	
-	status = acpi_suspend(state);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-	
-	return_VALUE(count);
-}
-
-
-static int
-acpi_system_read_alarm (
-	char                    *page,
-	char                    **start,
-	off_t                   off,
-	int                     count,
-	int                     *eof,
-	void                    *context)
-{
-	char			*p = page;
-	int			size = 0;
-	u32			sec, min, hr;
-	u32			day, mo, yr;
-
-	ACPI_FUNCTION_TRACE("acpi_system_read_alarm");
-
-	if (off != 0)
-		goto end;
-
-	spin_lock(&rtc_lock);
-
-	sec = CMOS_READ(RTC_SECONDS_ALARM);
-	min = CMOS_READ(RTC_MINUTES_ALARM);
-	hr = CMOS_READ(RTC_HOURS_ALARM);
-
-#if 0	/* If we ever get an FACP with proper values... */
-	if (acpi_gbl_FADT->day_alrm)
-		day = CMOS_READ(acpi_gbl_FADT->day_alrm);
-	else
-		day =  CMOS_READ(RTC_DAY_OF_MONTH);
-	if (acpi_gbl_FADT->mon_alrm)
-		mo = CMOS_READ(acpi_gbl_FADT->mon_alrm);
-	else
-		mo = CMOS_READ(RTC_MONTH);;
-	if (acpi_gbl_FADT->century)
-		yr = CMOS_READ(acpi_gbl_FADT->century) * 100 + CMOS_READ(RTC_YEAR);
-	else
-		yr = CMOS_READ(RTC_YEAR);
-#else
-	day = CMOS_READ(RTC_DAY_OF_MONTH);
-	mo = CMOS_READ(RTC_MONTH);
-	yr = CMOS_READ(RTC_YEAR);
-#endif
-
-	spin_unlock(&rtc_lock);
-
-	BCD_TO_BIN(sec);
-	BCD_TO_BIN(min);
-	BCD_TO_BIN(hr);
-	BCD_TO_BIN(day);
-	BCD_TO_BIN(mo);
-	BCD_TO_BIN(yr);
-
-	p += sprintf(p,"%4.4u-", yr);
-	p += (mo > 12)  ? sprintf(p, "**-")  : sprintf(p, "%2.2u-", mo);
-	p += (day > 31) ? sprintf(p, "** ")  : sprintf(p, "%2.2u ", day);
-	p += (hr > 23)  ? sprintf(p, "**:")  : sprintf(p, "%2.2u:", hr);
-	p += (min > 59) ? sprintf(p, "**:")  : sprintf(p, "%2.2u:", min);
-	p += (sec > 59) ? sprintf(p, "**\n") : sprintf(p, "%2.2u\n", sec);
-
- end:
-	size = p - page;
-	if (size < count) *eof = 1;
-	else if (size > count) size = count;
-	if (size < 0) size = 0;
-	*start = page;
-
-	return_VALUE(size);
-}
-
-
-static int
-get_date_field (
-	char			**p,
-	u32			*value)
-{
-	char			*next = NULL;
-	char			*string_end = NULL;
-	int			result = -EINVAL;
-
-	/*
-	 * Try to find delimeter, only to insert null.  The end of the
-	 * string won't have one, but is still valid.
-	 */
-	next = strpbrk(*p, "- :");
-	if (next)
-		*next++ = '\0';
-
-	*value = simple_strtoul(*p, &string_end, 10);
-
-	/* Signal success if we got a good digit */
-	if (string_end != *p)
-		result = 0;
-
-	if (next)
-		*p = next;
-
-	return result;
-}
-
-
-static int
-acpi_system_write_alarm (
-	struct file		*file,
-	const char		*buffer,
-	unsigned long		count,
-	void			*data)
-{
-	int			result = 0;
-	char			alarm_string[30] = {'\0'};
-	char			*p = alarm_string;
-	u32			sec, min, hr, day, mo, yr;
-	int			adjust = 0;
-	unsigned char		rtc_control = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_system_write_alarm");
-
-	if (count > sizeof(alarm_string) - 1)
-		return_VALUE(-EINVAL);
-	
-	if (copy_from_user(alarm_string, buffer, count))
-		return_VALUE(-EFAULT);
-
-	alarm_string[count] = '\0';
-
-	/* check for time adjustment */
-	if (alarm_string[0] == '+') {
-		p++;
-		adjust = 1;
-	}
-
-	if ((result = get_date_field(&p, &yr)))
-		goto end;
-	if ((result = get_date_field(&p, &mo)))
-		goto end;
-	if ((result = get_date_field(&p, &day)))
-		goto end;
-	if ((result = get_date_field(&p, &hr)))
-		goto end;
-	if ((result = get_date_field(&p, &min)))
-		goto end;
-	if ((result = get_date_field(&p, &sec)))
-		goto end;
-
-	if (sec > 59) {
-		min += 1;
-		sec -= 60;
-	}
-	if (min > 59) {
-		hr += 1;
-		min -= 60;
-	}
-	if (hr > 23) {
-		day += 1;
-		hr -= 24;
-	}
-	if (day > 31) {
-		mo += 1;
-		day -= 31;
-	}
-	if (mo > 12) {
-		yr += 1;
-		mo -= 12;
-	}
-
-	spin_lock_irq(&rtc_lock);
-
-	rtc_control = CMOS_READ(RTC_CONTROL);
-	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-		BIN_TO_BCD(yr);
-		BIN_TO_BCD(mo);
-		BIN_TO_BCD(day);
-		BIN_TO_BCD(hr);
-		BIN_TO_BCD(min);
-		BIN_TO_BCD(sec);
-	}
-
-	if (adjust) {
-		yr  += CMOS_READ(RTC_YEAR);
-		mo  += CMOS_READ(RTC_MONTH);
-		day += CMOS_READ(RTC_DAY_OF_MONTH);
-		hr  += CMOS_READ(RTC_HOURS);
-		min += CMOS_READ(RTC_MINUTES);
-		sec += CMOS_READ(RTC_SECONDS);
-	}
-
-	spin_unlock_irq(&rtc_lock);
-
-	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-		BCD_TO_BIN(yr);
-		BCD_TO_BIN(mo);
-		BCD_TO_BIN(day);
-		BCD_TO_BIN(hr);
-		BCD_TO_BIN(min);
-		BCD_TO_BIN(sec);
-	}
-
-	if (sec > 59) {
-		min++;
-		sec -= 60;
-	}
-	if (min > 59) {
-		hr++;
-		min -= 60;
-	}
-	if (hr > 23) {
-		day++;
-		hr -= 24;
-	}
-	if (day > 31) {
-		mo++;
-		day -= 31;
-	}
-	if (mo > 12) {
-		yr++;
-		mo -= 12;
-	}
-	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-		BIN_TO_BCD(yr);
-		BIN_TO_BCD(mo);
-		BIN_TO_BCD(day);
-		BIN_TO_BCD(hr);
-		BIN_TO_BCD(min);
-		BIN_TO_BCD(sec);
-	}
-
-	spin_lock_irq(&rtc_lock);
-
-	/* write the fields the rtc knows about */
-	CMOS_WRITE(hr, RTC_HOURS_ALARM);
-	CMOS_WRITE(min, RTC_MINUTES_ALARM);
-	CMOS_WRITE(sec, RTC_SECONDS_ALARM);
-
-	/*
-	 * If the system supports an enhanced alarm it will have non-zero
-	 * offsets into the CMOS RAM here -- which for some reason are pointing
-	 * to the RTC area of memory.
-	 */
-#if 0
-	if (acpi_gbl_FADT->day_alrm)
-		CMOS_WRITE(day, acpi_gbl_FADT->day_alrm);
-	if (acpi_gbl_FADT->mon_alrm)
-		CMOS_WRITE(mo, acpi_gbl_FADT->mon_alrm);
-	if (acpi_gbl_FADT->century)
-		CMOS_WRITE(yr/100, acpi_gbl_FADT->century);
-#endif
-	/* enable the rtc alarm interrupt */
-	if (!(rtc_control & RTC_AIE)) {
-		rtc_control |= RTC_AIE;
-		CMOS_WRITE(rtc_control,RTC_CONTROL);
-		CMOS_READ(RTC_INTR_FLAGS);
-	}
-
-	spin_unlock_irq(&rtc_lock);
-
-	acpi_hw_bit_register_write(ACPI_BITREG_RT_CLOCK_ENABLE, 1, ACPI_MTX_LOCK);
-
-	file->f_pos += count;
-
-	result = 0;
-end:
-	return_VALUE(result ? result : count);
-}
-
-#endif /*CONFIG_ACPI_SLEEP*/
-
-
-static int
-acpi_system_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_system_add_fs");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	/* 'info' [R] */
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_INFO,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_INFO));
-	else {
-		entry->read_proc = acpi_system_read_info;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'dsdt' [R] */
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_DSDT,
-		S_IRUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_DSDT));
-	else
-		entry->proc_fops = &acpi_system_dsdt_ops;
-
-	/* 'fadt' [R] */
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_FADT,
-		S_IRUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_FADT));
-	else
-		entry->proc_fops = &acpi_system_fadt_ops;
-
-	/* 'event' [R] */
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_EVENT,
-		S_IRUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_EVENT));
-	else
-		entry->proc_fops = &acpi_system_event_ops;
-
-#ifdef CONFIG_ACPI_SLEEP
-
-	/* 'sleep' [R/W]*/
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_SLEEP,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_SLEEP));
-	else {
-		entry->read_proc = acpi_system_read_sleep;
-		entry->write_proc = acpi_system_write_sleep;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'alarm' [R/W] */
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_ALARM,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_ALARM));
-	else {
-		entry->read_proc = acpi_system_read_alarm;
-		entry->write_proc = acpi_system_write_alarm;
-		entry->data = acpi_driver_data(device);
-	}
-
-#endif /*CONFIG_ACPI_SLEEP*/
-
-#ifdef ACPI_DEBUG
-
-	/* 'debug_layer' [R/W] */
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LAYER,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_DEBUG_LAYER));
-	else {
-		entry->read_proc  = acpi_system_read_debug;
-		entry->write_proc = acpi_system_write_debug;
-		entry->data = (void *) 0;
-	}
-
-	/* 'debug_level' [R/W] */
-	entry = create_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LEVEL,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_SYSTEM_FILE_DEBUG_LEVEL));
-	else {
-		entry->read_proc  = acpi_system_read_debug;
-		entry->write_proc = acpi_system_write_debug;
-		entry->data = (void *) 1;
-	}
-
-#endif /*ACPI_DEBUG*/
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_system_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_system_remove_fs");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	remove_proc_entry(ACPI_SYSTEM_FILE_INFO, acpi_device_dir(device));
-	remove_proc_entry(ACPI_SYSTEM_FILE_DSDT, acpi_device_dir(device));
-	remove_proc_entry(ACPI_SYSTEM_FILE_EVENT, acpi_device_dir(device));
-#ifdef CONFIG_ACPI_SLEEP
-	remove_proc_entry(ACPI_SYSTEM_FILE_SLEEP, acpi_device_dir(device));
-	remove_proc_entry(ACPI_SYSTEM_FILE_ALARM, acpi_device_dir(device));
-#endif
-#ifdef ACPI_DEBUG
-	remove_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LAYER,
-		acpi_device_dir(device));
-	remove_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LEVEL,
-		acpi_device_dir(device));
-#endif
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Driver Interface
-   -------------------------------------------------------------------------- */
-
-#if defined(CONFIG_MAGIC_SYSRQ) && defined(CONFIG_PM)
-
-/* Simple wrapper calling power down function. */
-static void acpi_sysrq_power_off(int key, struct pt_regs *pt_regs,
-	struct kbd_struct *kbd, struct tty_struct *tty)
-{
-	acpi_power_off();
-}
-
-struct sysrq_key_op sysrq_acpi_poweroff_op = {
-	handler:	&acpi_sysrq_power_off,
-	help_msg:	"Off",
-	action_msg:	"Power Off\n"
-};
-
-#endif  /* CONFIG_MAGIC_SYSRQ */
-
-static int
-acpi_system_add (
-	struct acpi_device	*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_system	*system = NULL;
-	u8			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_system_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	system = kmalloc(sizeof(struct acpi_system), GFP_KERNEL);
-	if (!system)
-		return_VALUE(-ENOMEM);
-	memset(system, 0, sizeof(struct acpi_system));
-
-	system->handle = device->handle;
-	sprintf(acpi_device_name(device), "%s", ACPI_SYSTEM_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_SYSTEM_CLASS);
-	acpi_driver_data(device) = system;
-
-	result = acpi_system_add_fs(device);
-	if (0 != result)
-		goto end;
-
-	printk(KERN_INFO PREFIX "%s [%s] (supports", 
-		acpi_device_name(device), acpi_device_bid(device));
-	for (i=0; i<ACPI_S_STATE_COUNT; i++) {
-		u8 type_a, type_b;
-		status = acpi_hw_get_sleep_type_data(i, &type_a, &type_b);
-		if (ACPI_SUCCESS(status)) {
-			system->states[i] = 1;
-			printk(" S%d", i);
-		}
-	}
-	printk(")\n");
-
-#ifdef CONFIG_PM
-	/* Install the soft-off (S5) handler. */
-	if (system->states[ACPI_STATE_S5]) {
-		pm_power_off = acpi_power_off;
-		register_sysrq_key('o', &sysrq_acpi_poweroff_op);
-	}
-#endif
-
-end:
-	if (0 != result)
-		kfree(system);
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_system_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	struct acpi_system	*system = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_system_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	system = (struct acpi_system *) acpi_driver_data(device);
-
-#ifdef CONFIG_PM
-	/* Remove the soft-off (S5) handler. */
-	if (system->states[ACPI_STATE_S5]) {
-		unregister_sysrq_key('o', &sysrq_acpi_poweroff_op);
-		pm_power_off = NULL;
-	}
-#endif
-
-	acpi_system_remove_fs(device);
-
-	kfree(system);
-
-	return 0;
-}
-
-
-int __init
-acpi_system_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_system_init");
-
-	result = acpi_bus_register_driver(&acpi_system_driver);
-	if (0 > result)
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-void __exit
-acpi_system_exit (void)
-{
-	ACPI_FUNCTION_TRACE("acpi_system_exit");
-	acpi_bus_unregister_driver(&acpi_system_driver);
-	return_VOID;
-}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_tables.c linux/drivers/acpi/acpi_tables.c
--- ../prev/linux/drivers/acpi/acpi_tables.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_tables.c	Wed Dec 31 17:00:00 1969
@@ -1,514 +0,0 @@
-/*
- *  acpi_tables.c - ACPI Boot-Time Table Parsing
- *
- *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/smp.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/irq.h>
-#include <linux/acpi.h>
-
-#define PREFIX			"ACPI: "
-
-#define ACPI_MAX_TABLES		ACPI_TABLE_COUNT
-
-static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
-	[ACPI_TABLE_UNKNOWN]	= "????",
-	[ACPI_APIC]		= "APIC",
-	[ACPI_BOOT]		= "BOOT",
-	[ACPI_DBGP]		= "DBGP",
-	[ACPI_DSDT]		= "DSDT",
-	[ACPI_ECDT]		= "ECDT",
-	[ACPI_ETDT]		= "ETDT",
-	[ACPI_FACP]		= "FACP",
-	[ACPI_FACS]		= "FACS",
-	[ACPI_OEMX]		= "OEM",
-	[ACPI_PSDT]		= "PSDT",
-	[ACPI_SBST]		= "SBST",
-	[ACPI_SLIT]		= "SLIT",
-	[ACPI_SPCR]		= "SPCR",
-	[ACPI_SRAT]		= "SRAT",
-	[ACPI_SSDT]		= "SSDT",
-	[ACPI_SPMI]		= "SPMI"
-};
-
-/* System Description Table (RSDT/XSDT) */
-struct acpi_table_sdt {
-	unsigned long		pa;		/* Physical Address */
-	unsigned long		count;		/* Table count */
-	struct {
-		unsigned long		pa;
-		enum acpi_table_id	id;
-		unsigned long		size;
-	}			entry[ACPI_MAX_TABLES];
-} __attribute__ ((packed));
-
-static struct acpi_table_sdt	sdt;
-
-acpi_madt_entry_handler		madt_handlers[ACPI_MADT_ENTRY_COUNT];
-
-struct acpi_boot_flags	acpi_boot = {1, 0}; /* Enabled by default */
-
-
-void
-acpi_table_print (
-	struct acpi_table_header *header,
-	unsigned long		phys_addr)
-{
-	char			*name = NULL;
-
-	if (!header)
-		return;
-
-	/* Some table signatures aren't good table names */
-
-	if (0 == strncmp((char *) &header->signature,
-		acpi_table_signatures[ACPI_APIC],
-		sizeof(header->signature))) {
-		name = "MADT";
-	}
-	else if (0 == strncmp((char *) &header->signature,
-		acpi_table_signatures[ACPI_FACP],
-		sizeof(header->signature))) {
-		name = "FADT";
-	}
-	else
-		name = header->signature;
-
-	printk(KERN_INFO PREFIX "%.4s (v%3.3d %6.6s %8.8s %5.5d.%5.5d) @ 0x%p\n",
-		name, header->revision, header->oem_id,
-		header->oem_table_id, header->oem_revision >> 16,
-		header->oem_revision & 0xffff, (void *) phys_addr);
-}
-
-
-void
-acpi_table_print_madt_entry (
-	acpi_table_entry_header	*header)
-{
-	if (!header)
-		return;
-
-	switch (header->type) {
-
-	case ACPI_MADT_LAPIC:
-	{
-		struct acpi_table_lapic *p =
-			(struct acpi_table_lapic*) header;
-		printk(KERN_INFO PREFIX "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
-			p->acpi_id, p->id, p->flags.enabled?"enabled":"disabled");
-	}
-		break;
-
-	case ACPI_MADT_IOAPIC:
-	{
-		struct acpi_table_ioapic *p =
-			(struct acpi_table_ioapic*) header;
-		printk(KERN_INFO PREFIX "IOAPIC (id[0x%02x] address[0x%08x] global_irq_base[0x%x])\n",
-			p->id, p->address, p->global_irq_base);
-	}
-		break;
-
-	case ACPI_MADT_INT_SRC_OVR:
-	{
-		struct acpi_table_int_src_ovr *p =
-			(struct acpi_table_int_src_ovr*) header;
-		printk(KERN_INFO PREFIX "INT_SRC_OVR (bus[%d] irq[0x%x] global_irq[0x%x] polarity[0x%x] trigger[0x%x])\n",
-			p->bus, p->bus_irq, p->global_irq, p->flags.polarity, p->flags.trigger);
-	}
-		break;
-
-	case ACPI_MADT_NMI_SRC:
-	{
-		struct acpi_table_nmi_src *p =
-			(struct acpi_table_nmi_src*) header;
-		printk(KERN_INFO PREFIX "NMI_SRC (polarity[0x%x] trigger[0x%x] global_irq[0x%x])\n",
-			p->flags.polarity, p->flags.trigger, p->global_irq);
-	}
-		break;
-
-	case ACPI_MADT_LAPIC_NMI:
-	{
-		struct acpi_table_lapic_nmi *p =
-			(struct acpi_table_lapic_nmi*) header;
-		printk(KERN_INFO PREFIX "LAPIC_NMI (acpi_id[0x%02x] polarity[0x%x] trigger[0x%x] lint[0x%x])\n",
-			p->acpi_id, p->flags.polarity, p->flags.trigger, p->lint);
-	}
-		break;
-
-	case ACPI_MADT_LAPIC_ADDR_OVR:
-	{
-		struct acpi_table_lapic_addr_ovr *p =
-			(struct acpi_table_lapic_addr_ovr*) header;
-		printk(KERN_INFO PREFIX "LAPIC_ADDR_OVR (address[0x%016Lx])\n",
-			p->address);
-	}
-		break;
-
-	case ACPI_MADT_IOSAPIC:
-	{
-		struct acpi_table_iosapic *p =
-			(struct acpi_table_iosapic*) header;
-		printk(KERN_INFO PREFIX "IOSAPIC (id[0x%x] global_irq_base[0x%x] address[0x%016Lx])\n",
-			p->id, p->global_irq_base, p->address);
-	}
-		break;
-
-	case ACPI_MADT_LSAPIC:
-	{
-		struct acpi_table_lsapic *p =
-			(struct acpi_table_lsapic*) header;
-		printk(KERN_INFO PREFIX "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
-			p->acpi_id, p->id, p->eid, p->flags.enabled?"enabled":"disabled");
-	}
-		break;
-
-	case ACPI_MADT_PLAT_INT_SRC:
-	{
-		struct acpi_table_plat_int_src *p =
-			(struct acpi_table_plat_int_src*) header;
-		printk(KERN_INFO PREFIX "PLAT_INT_SRC (polarity[0x%x] trigger[0x%x] type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
-			p->flags.polarity, p->flags.trigger, p->type, p->id, p->eid, p->iosapic_vector, p->global_irq);
-	}
-		break;
-
-	default:
-		printk(KERN_WARNING PREFIX "Found unsupported MADT entry (type = 0x%x)\n",
-			header->type);
-		break;
-	}
-}
-
-
-static int
-acpi_table_compute_checksum (
-	void			*table_pointer,
-	unsigned long		length)
-{
-	u8			*p = (u8 *) table_pointer;
-	unsigned long		remains = length;
-	unsigned long		sum = 0;
-
-	if (!p || !length)
-		return -EINVAL;
-
-	while (remains--)
-		sum += *p++;
-
-	return (sum & 0xFF);
-}
-
-
-int __init
-acpi_table_parse_madt (
-	enum acpi_table_id	id,
-	acpi_madt_entry_handler	handler)
-{
-	struct acpi_table_madt	*madt = NULL;
-	acpi_table_entry_header	*entry = NULL;
-	unsigned long		count = 0;
-	unsigned long		madt_end = 0;
-	int			i = 0;
-
-	if (!handler)
-		return -EINVAL;
-
-	/* Locate the MADT (if exists). There should only be one. */
-
-	for (i = 0; i < sdt.count; i++) {
-		if (sdt.entry[i].id != ACPI_APIC)
-			continue;
-		madt = (struct acpi_table_madt *)
-			__acpi_map_table(sdt.entry[i].pa, sdt.entry[i].size);
-		if (!madt) {
-			printk(KERN_WARNING PREFIX "Unable to map MADT\n");
-			return -ENODEV;
-		}
-		break;
-	}
-
-	if (!madt) {
-		printk(KERN_WARNING PREFIX "MADT not present\n");
-		return -ENODEV;
-	}
-
-	madt_end = (unsigned long) madt + sdt.entry[i].size;
-
-	/* Parse all entries looking for a match. */
-
-	entry = (acpi_table_entry_header *)
-		((unsigned long) madt + sizeof(struct acpi_table_madt));
-
-	while (((unsigned long) entry) < madt_end) {
-		if (entry->type == id) {
-			count++;
-			handler(entry);
-		}
-		entry = (acpi_table_entry_header *)
-			((unsigned long) entry += entry->length);
-	}
-
-	return count;
-}
-
-
-int __init
-acpi_table_parse (
-	enum acpi_table_id	id,
-	acpi_table_handler	handler)
-{
-	int			count = 0;
-	int			i = 0;
-
-	if (!handler)
-		return -EINVAL;
-
-	for (i = 0; i < sdt.count; i++) {
-		if (sdt.entry[i].id != id)
-			continue;
-		handler(sdt.entry[i].pa, sdt.entry[i].size);
-		count++;
-	}
-
-	return count;
-}
-
-
-static int __init
-acpi_table_get_sdt (
-	struct acpi_table_rsdp	*rsdp)
-{
-	struct acpi_table_header *header = NULL;
-	int			i, id = 0;
-
-	if (!rsdp)
-		return -EINVAL;
-
-	/* First check XSDT (but only on ACPI 2.0-compatible systems) */
-
-	if ((rsdp->revision >= 2) &&
-		(((struct acpi20_table_rsdp*)rsdp)->xsdt_address)) {
-			
-		struct acpi_table_xsdt	*mapped_xsdt = NULL;
-
-		sdt.pa = ((struct acpi20_table_rsdp*)rsdp)->xsdt_address;
-
-		header = (struct acpi_table_header *)
-			__acpi_map_table(sdt.pa, sizeof(struct acpi_table_header));
-
-		if (!header) {
-			printk(KERN_WARNING PREFIX "Unable to map XSDT header\n");
-			return -ENODEV;
-		}
-
-		if (strncmp(header->signature, "XSDT", 4)) {
-			printk(KERN_WARNING PREFIX "XSDT signature incorrect\n");
-			return -ENODEV;
-		}
-
-		sdt.count = (header->length - sizeof(struct acpi_table_header)) >> 3;
-		if (sdt.count > ACPI_MAX_TABLES) {
-			printk(KERN_WARNING PREFIX "Truncated %lu XSDT entries\n",
-				(ACPI_MAX_TABLES - sdt.count));
-			sdt.count = ACPI_MAX_TABLES;
-		}
-
-		mapped_xsdt = (struct acpi_table_xsdt *)
-			__acpi_map_table(sdt.pa, header->length);
-		if (!mapped_xsdt) {
-			printk(KERN_WARNING PREFIX "Unable to map XSDT\n");
-			return -ENODEV;
-		}
-
-		header = &mapped_xsdt->header;
-
-		for (i = 0; i < sdt.count; i++)
-			sdt.entry[i].pa = (unsigned long) mapped_xsdt->entry[i];
-	}
-
-	/* Then check RSDT */
-
-	else if (rsdp->rsdt_address) {
-
-		struct acpi_table_rsdt	*mapped_rsdt = NULL;
-
-		sdt.pa = rsdp->rsdt_address;
-
-		header = (struct acpi_table_header *)
-			__acpi_map_table(sdt.pa, sizeof(struct acpi_table_header));
-		if (!header) {
-			printk(KERN_WARNING PREFIX "Unable to map RSDT header\n");
-			return -ENODEV;
-		}
-
-		if (strncmp(header->signature, "RSDT", 4)) {
-			printk(KERN_WARNING PREFIX "RSDT signature incorrect\n");
-			return -ENODEV;
-		}
-
-		sdt.count = (header->length - sizeof(struct acpi_table_header)) >> 2;
-		if (sdt.count > ACPI_MAX_TABLES) {
-			printk(KERN_WARNING PREFIX "Truncated %lu RSDT entries\n",
-				(ACPI_TABLE_COUNT - sdt.count));
-			sdt.count = ACPI_MAX_TABLES;
-		}
-
-		mapped_rsdt = (struct acpi_table_rsdt *)
-			__acpi_map_table(sdt.pa, header->length);
-		if (!mapped_rsdt) {
-			printk(KERN_WARNING PREFIX "Unable to map RSDT\n");
-			return -ENODEV;
-		}
-
-		header = &mapped_rsdt->header;
-
-		for (i = 0; i < sdt.count; i++)
-			sdt.entry[i].pa = (unsigned long) mapped_rsdt->entry[i];
-	}
-
-	else {
-		printk(KERN_WARNING PREFIX "No System Description Table (RSDT/XSDT) specified in RSDP\n");
-		return -ENODEV;
-	}
-
-	acpi_table_print(header, sdt.pa);
-
-	for (i = 0; i < sdt.count; i++) {
-
-		header = (struct acpi_table_header *)
-			__acpi_map_table(sdt.entry[i].pa,
-				sizeof(struct acpi_table_header));
-		if (!header)
-			continue;
-
-		acpi_table_print(header, sdt.entry[i].pa);
-
-		if (0 != acpi_table_compute_checksum(header, header->length)) {
-			printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
-			continue;
-		}
-
-		sdt.entry[i].size = header->length;
-
-		for (id = 0; id < ACPI_TABLE_COUNT; id++) {
-			if (0 == strncmp((char *) &header->signature,
-				acpi_table_signatures[id],
-				sizeof(header->signature))) {
-				sdt.entry[i].id = id;
-			}
-		}
-	}
-
-	return 0;
-}
-
-
-static void __init
-acpi_table_parse_cmdline (
-	char		*cmdline)
-{
-	char		*p = NULL;
-
-	/* NOTE: We're called too early in the boot process to use __setup */
-
-	if (!cmdline || !(p = strstr(cmdline, "acpi_boot=")))
-		return;
-
-	p += 10;
-
-	while (*p && (*p != ' ')) {
-		if (0 == memcmp(p, "madt", 4)) {
-			printk(KERN_INFO PREFIX "MADT processing enabled\n");
-			acpi_boot.madt = 1;
-			p += 4;
-		}
-		else if (0 == memcmp(p, "on", 2)) {
-			printk(KERN_INFO PREFIX "Boot-time table processing enabled\n");
-			acpi_boot.madt = 1;
-			p += 2;
-		}
-		else if (0 == memcmp(p, "off", 2)) {
-			printk(KERN_INFO PREFIX "Boot-time table processing disabled\n");
-			acpi_boot.madt = 0;
-			p += 3;
-		}
-		else
-			p++;
-
-		if (*p == ',')
-			p ++;
-	}
-}
-
-
-int __init
-acpi_table_init (
-	char			*cmdline)
-{
-	struct acpi_table_rsdp	*rsdp = NULL;
-	unsigned long		rsdp_phys = 0;
-	int			result = 0;
-
-	memset(&sdt, 0, sizeof(struct acpi_table_sdt));
-	memset(&madt_handlers, 0, sizeof(madt_handlers));
-
-	acpi_table_parse_cmdline(cmdline);
-
-	/* Locate and map the Root System Description Table (RSDP) */
-
-	if ((0 != acpi_find_rsdp(&rsdp_phys)) || !rsdp_phys) {
-		printk(KERN_ERR PREFIX "Unable to locate RSDP\n");
-		return -ENODEV;
-	}
-
-	rsdp = (struct acpi_table_rsdp *) __va(rsdp_phys);
-	if (!rsdp) {
-		printk(KERN_WARNING PREFIX "Unable to map RSDP\n");
-		return -ENODEV;
-	}
-
-	printk(KERN_INFO PREFIX "RSDP (v%3.3d %6.6s                     ) @ 0x%p\n",
-		rsdp->revision, rsdp->oem_id, (void *) rsdp_phys);
-
-	if (rsdp->revision < 2)
-		result = acpi_table_compute_checksum(rsdp, sizeof(struct acpi_table_rsdp));
-	else
-		result = acpi_table_compute_checksum(rsdp, ((struct acpi20_table_rsdp *)rsdp)->length);
-
-	if (0 != result) {
-		printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
-		return -ENODEV;
-	}
-
-	/* Locate and map the System Description table (RSDT/XSDT) */
-
-	if (0 != acpi_table_get_sdt(rsdp))
-		return -ENODEV;
-
-	return 0;
-}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_thermal.c linux/drivers/acpi/acpi_thermal.c
--- ../prev/linux/drivers/acpi/acpi_thermal.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_thermal.c	Wed Dec 31 17:00:00 1969
@@ -1,1318 +0,0 @@
-/*
- *  acpi_thermal.c - ACPI Thermal Zone Driver ($Revision: 36 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This driver fully implements the ACPI thermal policy as described in the
- *  ACPI 2.0 Specification.
- *
- *  TBD: 1. Implement passive cooling hysteresis.
- *       2. Enhance passive cooling (CPU) states/limit interface to support
- *          concepts of 'multiple limiters', upper/lower limits, etc.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/kmod.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_THERMAL_COMPONENT
-ACPI_MODULE_NAME		("acpi_thermal")
-
-MODULE_AUTHOR("Paul Diefenbaugh");
-MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);
-MODULE_LICENSE("GPL");
-
-static int tzp = 0;
-MODULE_PARM(tzp, "i");
-MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
-
-#define PREFIX			"ACPI: "
-
-
-#define ACPI_THERMAL_MAX_ACTIVE	10
-
-#define KELVIN_TO_CELSIUS(t)	((t-2732+5)/10)
-
-static int acpi_thermal_add (struct acpi_device *device);
-static int acpi_thermal_remove (struct acpi_device *device, int type);
-
-static struct acpi_driver acpi_thermal_driver = {
-	name:			ACPI_THERMAL_DRIVER_NAME,
-	class:			ACPI_THERMAL_CLASS,
-	ids:			ACPI_THERMAL_HID,
-	ops:			{
-					add:	acpi_thermal_add,
-					remove:	acpi_thermal_remove,
-				},
-};
-
-struct acpi_thermal_state {
-	u8			critical:1;
-	u8			hot:1;
-	u8			passive:1;
-	u8			active:1;
-	u8			reserved:4;
-	int			active_index;
-};
-
-struct acpi_thermal_state_flags {
-	u8			valid:1;
-	u8			enabled:1;
-	u8			reserved:6;
-};
-
-struct acpi_thermal_critical {
-	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
-};
-
-struct acpi_thermal_hot {
-	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
-};
-
-struct acpi_thermal_passive {
-	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
-	unsigned long		tc1;
-	unsigned long		tc2;
-	unsigned long		tsp;
-	struct acpi_handle_list	devices;
-};
-
-struct acpi_thermal_active {
-	struct acpi_thermal_state_flags flags;
-	unsigned long		temperature;
-	struct acpi_handle_list	devices;
-};
-
-struct acpi_thermal_trips {
-	struct acpi_thermal_critical critical;
-	struct acpi_thermal_hot	hot;
-	struct acpi_thermal_passive passive;
-	struct acpi_thermal_active active[ACPI_THERMAL_MAX_ACTIVE];
-};
-
-struct acpi_thermal_flags {
-	u8			cooling_mode:1;		/* _SCP */
-	u8			devices:1;		/* _TZD */
-	u8			reserved:6;
-};
-
-struct acpi_thermal {
-	acpi_handle		handle;
-	acpi_bus_id		name;
-	unsigned long		temperature;
-	unsigned long		last_temperature;
-	unsigned long		polling_frequency;
-	u8			cooling_mode;
-	struct acpi_thermal_flags flags;
-	struct acpi_thermal_state state;
-	struct acpi_thermal_trips trips;
-	struct acpi_handle_list	devices;
-	struct timer_list	timer;
-};
-
-
-/* --------------------------------------------------------------------------
-                             Thermal Zone Management
-   -------------------------------------------------------------------------- */
-
-static int
-acpi_thermal_get_temperature (
-	struct acpi_thermal *tz)
-{
-	acpi_status		status = AE_OK;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_temperature");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	tz->last_temperature = tz->temperature;
-
-	status = acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n", tz->temperature));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_get_polling_frequency (
-	struct acpi_thermal	*tz)
-{
-	acpi_status		status = AE_OK;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_polling_frequency");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	status = acpi_evaluate_integer(tz->handle, "_TZP", NULL, &tz->polling_frequency);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n", tz->polling_frequency));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_set_polling (
-	struct acpi_thermal	*tz,
-	int			seconds)
-{
-	ACPI_FUNCTION_TRACE("acpi_thermal_set_polling");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency set to %lu seconds\n", tz->polling_frequency));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_set_cooling_mode (
-	struct acpi_thermal	*tz,
-	int			mode)
-{
-	acpi_status		status = AE_OK;
-	acpi_object		arg0 = {ACPI_TYPE_INTEGER};
-	acpi_object_list	arg_list= {1, &arg0};
-	acpi_handle		handle = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_set_cooling_mode");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	status = acpi_get_handle(tz->handle, "_SCP", &handle);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
-		return_VALUE(-ENODEV);
-	}
-
-	arg0.integer.value = mode;
-
-	status = acpi_evaluate(handle, NULL, &arg_list, NULL);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	tz->cooling_mode = mode;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n", 
-		mode?"passive":"active"));
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_get_trip_points (
-	struct acpi_thermal *tz)
-{
-	acpi_status		status = AE_OK;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_trip_points");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	/* Critical Shutdown (required) */
-
-	status = acpi_evaluate_integer(tz->handle, "_CRT", NULL, 
-		&tz->trips.critical.temperature);
-	if (ACPI_FAILURE(status)) {
-		tz->trips.critical.flags.valid = 0;
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No critical threshold\n"));
-		return -ENODEV;
-	}
-	else {
-		tz->trips.critical.flags.valid = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found critical threshold [%lu]\n", tz->trips.critical.temperature));
-	}
-
-	/* Critical Sleep (optional) */
-
-	status = acpi_evaluate_integer(tz->handle, "_HOT", NULL, &tz->trips.hot.temperature);
-	if (ACPI_FAILURE(status)) {
-		tz->trips.hot.flags.valid = 0;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No hot threshold\n"));
-	}
-	else {
-		tz->trips.hot.flags.valid = 1;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%lu]\n", tz->trips.hot.temperature));
-	}
-
-	/* Passive: Processors (optional) */
-
-	status = acpi_evaluate_integer(tz->handle, "_PSV", NULL, &tz->trips.passive.temperature);
-	if (ACPI_FAILURE(status)) {
-		tz->trips.passive.flags.valid = 0;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No passive threshold\n"));
-	}
-	else {
-		tz->trips.passive.flags.valid = 1;
-
-		status = acpi_evaluate_integer(tz->handle, "_TC1", NULL, &tz->trips.passive.tc1);
-		if (ACPI_FAILURE(status))
-			tz->trips.passive.flags.valid = 0;
-
-		status = acpi_evaluate_integer(tz->handle, "_TC2", NULL, &tz->trips.passive.tc2);
-		if (ACPI_FAILURE(status))
-			tz->trips.passive.flags.valid = 0;
-
-		status = acpi_evaluate_integer(tz->handle, "_TSP", NULL, &tz->trips.passive.tsp);
-		if (ACPI_FAILURE(status))
-			tz->trips.passive.flags.valid = 0;
-
-		status = acpi_evaluate_reference(tz->handle, "_PSL", NULL, &tz->trips.passive.devices);
-		if (ACPI_FAILURE(status))
-			tz->trips.passive.flags.valid = 0;
-
-		if (!tz->trips.passive.flags.valid)
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid passive threshold\n"));
-		else
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found passive threshold [%lu]\n", tz->trips.passive.temperature));
-	}
-
-	/* Active: Fans, etc. (optional) */
-
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
-
-		char name[5] = {'_','A','C',('0'+i),'\0'};
-
-		status = acpi_evaluate_integer(tz->handle, name, NULL, &tz->trips.active[i].temperature);
-		if (ACPI_FAILURE(status))
-			break;
-
-		name[2] = 'L';
-		status = acpi_evaluate_reference(tz->handle, name, NULL, &tz->trips.active[i].devices);
-		if (ACPI_SUCCESS(status)) {
-			tz->trips.active[i].flags.valid = 1;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found active threshold [%d]:[%lu]\n", i, tz->trips.active[i].temperature));
-		}
-		else
-			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid active threshold [%d]\n", i));
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_get_devices (
-	struct acpi_thermal	*tz)
-{
-	acpi_status		status = AE_OK;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_devices");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	status = acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
-	if (ACPI_FAILURE(status))
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_call_usermode (
-	char			*path)
-{
-	char			*argv[2] = {NULL, NULL};
-	char			*envp[3] = {NULL, NULL, NULL};
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_call_usermode");
-
-	if (!path)
-		return_VALUE(-EINVAL);;
-
-	argv[0] = path;
-
-	/* minimal command environment */
-	envp[0] = "HOME=/";
-	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
-	
-	call_usermodehelper(argv[0], argv, envp);
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_critical (
-	struct acpi_thermal	*tz)
-{
-	int			result = 0;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_critical");
-
-	if (!tz || !tz->trips.critical.flags.valid)
-		return_VALUE(-EINVAL);
-
-	if (tz->temperature >= tz->trips.critical.temperature) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Critical trip point\n"));
-		tz->trips.critical.flags.enabled = 1;
-	}
-	else if (tz->trips.critical.flags.enabled)
-		tz->trips.critical.flags.enabled = 0;
-
-	result = acpi_bus_get_device(tz->handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-
-	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_CRITICAL, tz->trips.critical.flags.enabled);
-
-	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_hot (
-	struct acpi_thermal	*tz)
-{
-	int			result = 0;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_hot");
-
-	if (!tz || !tz->trips.hot.flags.valid)
-		return_VALUE(-EINVAL);
-
-	if (tz->temperature >= tz->trips.hot.temperature) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Hot trip point\n"));
-		tz->trips.hot.flags.enabled = 1;
-	}
-	else if (tz->trips.hot.flags.enabled)
-		tz->trips.hot.flags.enabled = 0;
-
-	result = acpi_bus_get_device(tz->handle, &device);
-	if (0 != result)
-		return_VALUE(result);
-
-	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT, tz->trips.hot.flags.enabled);
-
-	/* TBD: Call user-mode "sleep(S4)" function */
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_passive (
-	struct acpi_thermal	*tz)
-{
-	int			result = 0;
-	struct acpi_thermal_passive *passive = NULL;
-	int			trend = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_passive");
-
-	if (!tz || !tz->trips.passive.flags.valid)
-		return_VALUE(-EINVAL);
-
-	passive = &(tz->trips.passive);
-
-	/*
-	 * Above Trip?
-	 * -----------
-	 * Calculate the thermal trend (using the passive cooling equation)
-	 * and modify the performance limit for all passive cooling devices
-	 * accordingly.  Note that we assume symmetry.
-	 */
-	if (tz->temperature >= passive->temperature) {
-		trend = (passive->tc1 * (tz->temperature - tz->last_temperature)) + (passive->tc2 * (tz->temperature - passive->temperature));
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-			"trend[%d]=(tc1[%lu]*(tmp[%lu]-last[%lu]))+(tc2[%lu]*(tmp[%lu]-psv[%lu]))\n", 
-			trend, passive->tc1, tz->temperature, 
-			tz->last_temperature, passive->tc2, 
-			tz->temperature, passive->temperature));
-		/* Heating up? */
-		if (trend > 0)
-			for (i=0; i<passive->devices.count; i++)
-				acpi_processor_set_thermal_limit(
-					passive->devices.handles[i], 
-					ACPI_PROCESSOR_LIMIT_INCREMENT);
-		/* Cooling off? */
-		else if (trend < 0)
-			for (i=0; i<passive->devices.count; i++)
-				acpi_processor_set_thermal_limit(
-					passive->devices.handles[i], 
-					ACPI_PROCESSOR_LIMIT_DECREMENT);
-	}
-
-	/*
-	 * Below Trip?
-	 * -----------
-	 * Implement passive cooling hysteresis to slowly increase performance
-	 * and avoid thrashing around the passive trip point.  Note that we
-	 * assume symmetry.
-	 */
-	else if (tz->trips.passive.flags.enabled) {
-		for (i=0; i<passive->devices.count; i++)
-			result = acpi_processor_set_thermal_limit(
-				passive->devices.handles[i], 
-				ACPI_PROCESSOR_LIMIT_DECREMENT);
-		if (1 == result) {
-			tz->trips.passive.flags.enabled = 0;
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
-				"Disabling passive cooling (zone is cool)\n"));
-		}
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_active (
-	struct acpi_thermal	*tz)
-{
-	int			result = 0;
-	struct acpi_thermal_active *active = NULL;
-	int                     i = 0;
-	int			j = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_active");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
-
-		active = &(tz->trips.active[i]);
-		if (!active || !active->flags.valid)
-			break;
-
-		/*
-		 * Above Threshold?
-		 * ----------------
-		 * If not already enabled, turn ON all cooling devices
-		 * associated with this active threshold.
-		 */
-		if (tz->temperature >= active->temperature) {
-			tz->state.active_index = i;
-			if (!active->flags.enabled) {
-				for (j = 0; j < active->devices.count; j++) {
-					result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D0);
-					if (0 != result) {
-						ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'on'\n", active->devices.handles[j]));
-						continue;
-					}
-					active->flags.enabled = 1;
-					ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'on'\n", active->devices.handles[j]));
-				}
-			}
-		}
-		/*
-		 * Below Threshold?
-		 * ----------------
-		 * Turn OFF all cooling devices associated with this
-		 * threshold.
-		 */
-		else if (active->flags.enabled) {
-			for (j = 0; j < active->devices.count; j++) {
-				result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D3);
-				if (0 != result) {
-					ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'off'\n", active->devices.handles[j]));
-					continue;
-				}
-				active->flags.enabled = 0;
-				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'off'\n", active->devices.handles[j]));
-			}
-		}
-	}
-
-	return_VALUE(0);
-}
-
-
-static void acpi_thermal_check (void *context);
-
-static void
-acpi_thermal_run (
-	unsigned long		data)
-{
-	acpi_os_queue_for_execution(OSD_PRIORITY_GPE,  acpi_thermal_check, (void *) data);
-}
-
-
-static void
-acpi_thermal_check (
-	void                    *data)
-{
-	int			result = 0;
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	unsigned long		sleep_time = 0;
-	int			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_check");
-
-	if (!tz) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
-		return_VOID;
-	}
-
-	result = acpi_thermal_get_temperature(tz);
-	if (0 != result)
-		return_VOID;
-	
-	memset(&tz->state, 0, sizeof(tz->state));
-	
-	/*
-	 * Check Trip Points
-	 * -----------------
-	 * Compare the current temperature to the trip point values to see
-	 * if we've entered one of the thermal policy states.  Note that
-	 * this function determines when a state is entered, but the 
-	 * individual policy decides when it is exited (e.g. hysteresis).
-	 */
-	if ((tz->trips.critical.flags.valid) && (tz->temperature >= tz->trips.critical.temperature))
-		tz->trips.critical.flags.enabled = 1;
-	if ((tz->trips.hot.flags.valid) && (tz->temperature >= tz->trips.hot.temperature))
-		tz->trips.hot.flags.enabled = 1;
-	if ((tz->trips.passive.flags.valid) && (tz->temperature >= tz->trips.passive.temperature))
-		tz->trips.passive.flags.enabled = 1;
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
-		if ((tz->trips.active[i].flags.valid) && (tz->temperature >= tz->trips.active[i].temperature))
-			tz->trips.active[i].flags.enabled = 1;
-
-	/*
-	 * Invoke Policy
-	 * -------------
-	 * Separated from the above check to allow individual policy to 
-	 * determine when to exit a given state.
-	 */
-	if (tz->trips.critical.flags.enabled)
-		acpi_thermal_critical(tz);
-	if (tz->trips.hot.flags.enabled)
-		acpi_thermal_hot(tz);
-	if (tz->trips.passive.flags.enabled)
-		acpi_thermal_passive(tz);
-	if (tz->trips.active[0].flags.enabled)
-		acpi_thermal_active(tz);
-
-	/*
-	 * Calculate State
-	 * ---------------
-	 * Again, separated from the above two to allow independent policy
-	 * decisions.
-	 */
-	if (tz->trips.critical.flags.enabled)
-		tz->state.critical = 1;
-	if (tz->trips.hot.flags.enabled)
-		tz->state.hot = 1;
-	if (tz->trips.passive.flags.enabled)
-		tz->state.passive = 1;
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
-		if (tz->trips.active[i].flags.enabled)
-			tz->state.active = 1;
-
-	/*
-	 * Calculate Sleep Time
-	 * --------------------
-	 * If we're in the passive state, use _TSP's value.  Otherwise
-	 * use the default polling frequency (e.g. _TZP).  If no polling
-	 * frequency is specified then we'll wait forever (at least until
-	 * a thermal event occurs).  Note that _TSP and _TZD values are
-	 * given in 1/10th seconds (we must covert to milliseconds).
-	 */
-	if (tz->state.passive)
-		sleep_time = tz->trips.passive.tsp * 100;
-	else if (tz->polling_frequency > 0)
-		sleep_time = tz->polling_frequency * 100;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n", 
-		tz->name, tz->temperature, sleep_time));
-
-	/*
-	 * Schedule Next Poll
-	 * ------------------
-	 */
-	if (!sleep_time) {
-		if (timer_pending(&(tz->timer)))
-			del_timer(&(tz->timer));
-	}
-	else {
-		if (timer_pending(&(tz->timer)))
-			mod_timer(&(tz->timer), (HZ * sleep_time) / 1000);
-		else {
-			tz->timer.data = (unsigned long) tz;
-			tz->timer.function = acpi_thermal_run;
-			tz->timer.expires = jiffies + (HZ * sleep_time) / 1000;
-			add_timer(&(tz->timer));
-		}
-	}
-
-	return_VOID;
-}
-
-
-/* --------------------------------------------------------------------------
-                              FS Interface (/proc)
-   -------------------------------------------------------------------------- */
-
-#include <linux/compatmac.h>
-#include <linux/proc_fs.h>
-
-struct proc_dir_entry		*acpi_thermal_dir = NULL;
-
-
-static int
-acpi_thermal_read_state (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_read_state");
-
-	if (!tz || (off != 0))
-		goto end;
-
-	p += sprintf(p, "state:                   ");
-
-	if (!tz->state.critical && !tz->state.hot && !tz->state.passive && !tz->state.active)
-		p += sprintf(p, "ok\n");
-	else {
-		if (tz->state.critical)
-			p += sprintf(p, "critical ");
-		if (tz->state.hot)
-			p += sprintf(p, "hot ");
-		if (tz->state.passive)
-			p += sprintf(p, "passive ");
-		if (tz->state.active)
-			p += sprintf(p, "active[%d]", tz->state.active_index);
-		p += sprintf(p, "\n");
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_thermal_read_temperature (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_read_temperature");
-
-	if (!tz || (off != 0))
-		goto end;
-
-	result = acpi_thermal_get_temperature(tz);
-	if (0 != result)
-		goto end;
-
-	p += sprintf(p, "temperature:             %lu C\n", 
-		KELVIN_TO_CELSIUS(tz->temperature));
-	
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_thermal_read_trip_points (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	char			*p = page;
-	int			len = 0;
-	int			i = 0;
-	int			j = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_read_trip_points");
-
-	if (!tz || (off != 0))
-		goto end;
-
-	if (tz->trips.critical.flags.valid)
-		p += sprintf(p, "critical (S5):           %lu C\n",
-			KELVIN_TO_CELSIUS(tz->trips.critical.temperature));
-
-	if (tz->trips.hot.flags.valid)
-		p += sprintf(p, "hot (S4):                %lu C\n",
-			KELVIN_TO_CELSIUS(tz->trips.hot.temperature));
-
-	if (tz->trips.passive.flags.valid) {
-		p += sprintf(p, "passive:                 %lu C: tc1=%lu tc2=%lu tsp=%lu devices=",
-			KELVIN_TO_CELSIUS(tz->trips.passive.temperature),
-			tz->trips.passive.tc1,
-			tz->trips.passive.tc2, 
-			tz->trips.passive.tsp);
-		for (j=0; j<tz->trips.passive.devices.count; j++) {
-
-			p += sprintf(p, "0x%p ", tz->trips.passive.devices.handles[j]);
-		}
-		p += sprintf(p, "\n");
-	}
-
-	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
-		if (!(tz->trips.active[i].flags.valid))
-			break;
-		p += sprintf(p, "active[%d]:               %lu C: devices=",
-			i, KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
-		for (j=0; j<tz->trips.active[i].devices.count; j++) 
-			p += sprintf(p, "0x%p ",
-				tz->trips.active[i].devices.handles[j]);
-		p += sprintf(p, "\n");
-	}
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_thermal_read_cooling_mode (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_read_cooling_mode");
-
-	if (!tz || (off != 0))
-		goto end;
-
-	if (!tz->flags.cooling_mode) {
-		p += sprintf(p, "<not supported>\n");
-		goto end;
-	}
-
-	p += sprintf(p, "cooling mode:            %s\n",
-		tz->cooling_mode?"passive":"active");
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_thermal_write_cooling_mode (
-	struct file		*file,
-	const char		*buffer,
-	unsigned long		count,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	char			mode_string[12] = {'\0'};
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_write_cooling_mode");
-
-	if (!tz || (count > sizeof(mode_string) - 1))
-		return_VALUE(-EINVAL);
-
-	if (!tz->flags.cooling_mode)
-		return_VALUE(-ENODEV);
-
-	if (copy_from_user(mode_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	mode_string[count] = '\0';
-	
-	result = acpi_thermal_set_cooling_mode(tz, 
-		simple_strtoul(mode_string, NULL, 0));
-	if (0 != result)
-		return_VALUE(result);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_thermal_read_polling (
-	char			*page,
-	char			**start,
-	off_t			off,
-	int 			count,
-	int 			*eof,
-	void			*data)
-{
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	char			*p = page;
-	int			len = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_read_polling");
-
-	if (!tz || (off != 0))
-		goto end;
-
-	if (!tz->polling_frequency) {
-		p += sprintf(p, "<polling disabled>\n");
-		goto end;
-	}
-
-	p += sprintf(p, "polling frequency:       %lu seconds\n",
-		(tz->polling_frequency / 10));
-
-end:
-	len = (p - page);
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count) len = count;
-	if (len<0) len = 0;
-
-	return_VALUE(len);
-}
-
-
-static int
-acpi_thermal_write_polling (
-	struct file		*file,
-	const char		*buffer,
-	unsigned long		count,
-	void			*data)
-{
-	int			result = 0;
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	char			polling_string[12] = {'\0'};
-	int			seconds = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_write_polling");
-
-	if (!tz || (count > sizeof(polling_string) - 1))
-		return_VALUE(-EINVAL);
-	
-	if (copy_from_user(polling_string, buffer, count))
-		return_VALUE(-EFAULT);
-	
-	polling_string[count] = '\0';
-
-	seconds = simple_strtoul(polling_string, NULL, 0);
-	
-	result = acpi_thermal_set_polling(tz, seconds);
-	if (0 != result)
-		return_VALUE(result);
-
-	acpi_thermal_check(tz);
-
-	return_VALUE(count);
-}
-
-
-static int
-acpi_thermal_add_fs (
-	struct acpi_device	*device)
-{
-	struct proc_dir_entry	*entry = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_add_fs");
-
-	if (!acpi_thermal_dir) {
-		acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, 
-			acpi_root_dir);
-		if (!acpi_thermal_dir)
-			return_VALUE(-ENODEV);
-	}
-
-	if (!acpi_device_dir(device)) {
-		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
-			acpi_thermal_dir);
-		if (!acpi_device_dir(device))
-			return_VALUE(-ENODEV);
-	}
-
-	/* 'state' [R] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_STATE));
-	else {
-		entry->read_proc = acpi_thermal_read_state;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'temperature' [R] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_TEMPERATURE));
-	else {
-		entry->read_proc = acpi_thermal_read_temperature;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'trip_points' [R] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
-		S_IRUGO, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_POLLING_FREQ));
-	else {
-		entry->read_proc = acpi_thermal_read_trip_points;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'cooling_mode' [R/W] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_COOLING_MODE));
-	else {
-		entry->read_proc = acpi_thermal_read_cooling_mode;
-		entry->write_proc = acpi_thermal_write_cooling_mode;
-		entry->data = acpi_driver_data(device);
-	}
-
-	/* 'polling_frequency' [R/W] */
-	entry = create_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
-		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
-	if (!entry)
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Unable to create '%s' fs entry\n",
-			ACPI_THERMAL_FILE_POLLING_FREQ));
-	else {
-		entry->read_proc = acpi_thermal_read_polling;
-		entry->write_proc = acpi_thermal_write_polling;
-		entry->data = acpi_driver_data(device);
-	}
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_remove_fs (
-	struct acpi_device	*device)
-{
-	ACPI_FUNCTION_TRACE("acpi_thermal_remove_fs");
-
-	if (!acpi_thermal_dir)
-		return_VALUE(-ENODEV);
-
-	if (acpi_device_dir(device))
-		remove_proc_entry(acpi_device_bid(device), acpi_thermal_dir);
-
-	return_VALUE(0);
-}
-
-
-/* --------------------------------------------------------------------------
-                                 Driver Interface
-   -------------------------------------------------------------------------- */
-
-static void
-acpi_thermal_notify (
-	acpi_handle 		handle,
-	u32 			event,
-	void 			*data)
-{
-	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
-	struct acpi_device	*device = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_notify");
-
-	if (!tz)
-		return_VOID;
-
-	if (0 != acpi_bus_get_device(tz->handle, &device))
-		return_VOID;
-
-	switch (event) {
-	case ACPI_THERMAL_NOTIFY_TEMPERATURE:
-		acpi_thermal_check(tz);
-		break;
-	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
-		acpi_thermal_get_trip_points(tz);
-		acpi_thermal_check(tz);
-		acpi_bus_generate_event(device, event, 0);
-		break;
-	case ACPI_THERMAL_NOTIFY_DEVICES:
-		if (tz->flags.devices)
-			acpi_thermal_get_devices(tz);
-		acpi_bus_generate_event(device, event, 0);
-		break;
-	default:
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-			"Unsupported event [0x%x]\n", event));
-		break;
-	}
-
-	return_VOID;
-}
-
-
-static int
-acpi_thermal_get_info (
-	struct acpi_thermal	*tz)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_get_info");
-
-	if (!tz)
-		return_VALUE(-EINVAL);
-
-	/* Get temperature [_TMP] (required) */
-	result = acpi_thermal_get_temperature(tz);
-	if (0 != result)
-		return_VALUE(result);
-
-	/* Set the cooling mode [_SCP] to active cooling (default) */
-	result = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);
-	if (0 == result)
-		tz->flags.cooling_mode = 1;
-
-	/* Get trip points [_CRT, _PSV, etc.] (required) */
-	result = acpi_thermal_get_trip_points(tz);
-	if (0 != result)
-		return_VALUE(result);
-
-	/* Get default polling frequency [_TZP] (optional) */
-	if (tzp)
-		tz->polling_frequency = tzp;
-	else
-		acpi_thermal_get_polling_frequency(tz);
-
-	/* Get devices in this thermal zone [_TZD] (optional) */
-	result = acpi_thermal_get_devices(tz);
-	if (0 == result)
-		tz->flags.devices = 1;
-
-	return_VALUE(0);
-}
-
-
-static int
-acpi_thermal_add (
-	struct acpi_device 		*device)
-{
-	int			result = 0;
-	acpi_status		status = AE_OK;
-	struct acpi_thermal	*tz = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_add");
-
-	if (!device)
-		return_VALUE(-EINVAL);
-
-	tz = kmalloc(sizeof(struct acpi_thermal), GFP_KERNEL);
-	if (!tz)
-		return_VALUE(-ENOMEM);
-	memset(tz, 0, sizeof(struct acpi_thermal));
-
-	tz->handle = device->handle;
-	sprintf(tz->name, "%s", device->pnp.bus_id);
-	sprintf(acpi_device_name(device), "%s", ACPI_THERMAL_DEVICE_NAME);
-	sprintf(acpi_device_class(device), "%s", ACPI_THERMAL_CLASS);
-	acpi_driver_data(device) = tz;
-
-	result = acpi_thermal_get_info(tz);
-	if (0 != result)
-		goto end;
-
-	result = acpi_thermal_add_fs(device);
-	if (0 != result)
-		return_VALUE(result);
-
-	acpi_thermal_check(tz);
-
-	status = acpi_install_notify_handler(tz->handle,
-		ACPI_DEVICE_NOTIFY, acpi_thermal_notify, tz);
-	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error installing notify handler\n"));
-		result = -ENODEV;
-		goto end;
-	}
-
-	init_timer(&tz->timer);
-
-	printk(KERN_INFO PREFIX "%s [%s] (%lu C)\n",
-		acpi_device_name(device), acpi_device_bid(device),
-		KELVIN_TO_CELSIUS(tz->temperature));
-
-end:
-	if (result) {
-		acpi_thermal_remove_fs(device);
-		kfree(tz);
-	}
-
-	return_VALUE(result);
-}
-
-
-static int
-acpi_thermal_remove (
-	struct acpi_device	*device,
-	int			type)
-{
-	acpi_status		status = AE_OK;
-	struct acpi_thermal	*tz = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_remove");
-
-	if (!device || !acpi_driver_data(device))
-		return_VALUE(-EINVAL);
-
-	tz = (struct acpi_thermal *) acpi_driver_data(device);
-
-	if (timer_pending(&(tz->timer)))
-		del_timer(&(tz->timer));
-
-	status = acpi_remove_notify_handler(tz->handle,
-		ACPI_DEVICE_NOTIFY, acpi_thermal_notify);
-	if (ACPI_FAILURE(status))
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-			"Error removing notify handler\n"));
-
-	/* Terminate policy */
-	if (tz->trips.passive.flags.valid
-		&& tz->trips.passive.flags.enabled) {
-		tz->trips.passive.flags.enabled = 0;
-		acpi_thermal_passive(tz);
-	}
-	if (tz->trips.active[0].flags.valid
-		&& tz->trips.active[0].flags.enabled) {
-		tz->trips.active[0].flags.enabled = 0;
-		acpi_thermal_active(tz);
-	}
-
-	acpi_thermal_remove_fs(device);
-
-	return_VALUE(0);
-}
-
-
-static int __init
-acpi_thermal_init (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_init");
-
-	result = acpi_bus_register_driver(&acpi_thermal_driver);
-	if (0 > result)
-		return_VALUE(-ENODEV);
-
-	return_VALUE(0);
-}
-
-
-static void __exit
-acpi_thermal_exit (void)
-{
-	int			result = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_thermal_exit");
-
-	result = acpi_bus_unregister_driver(&acpi_thermal_driver);
-	if (0 == result)
-		remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
-
-	return_VOID;
-}
-
-
-module_init(acpi_thermal_init);
-module_exit(acpi_thermal_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/acpi_utils.c linux/drivers/acpi/acpi_utils.c
--- ../prev/linux/drivers/acpi/acpi_utils.c	Tue May 14 17:24:22 2002
+++ linux/drivers/acpi/acpi_utils.c	Wed Dec 31 17:00:00 1969
@@ -1,460 +0,0 @@
-/*
- *  acpi_utils.c - ACPI Utility Functions ($Revision: 5 $)
- *
- *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or (at
- *  your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include "acpi_bus.h"
-#include "acpi_drivers.h"
-
-
-#define _COMPONENT		ACPI_BUS_COMPONENT
-ACPI_MODULE_NAME		("acpi_utils")
-
-
-/* --------------------------------------------------------------------------
-                            Object Evaluation Helpers
-   -------------------------------------------------------------------------- */
-
-#ifdef ACPI_DEBUG
-#define acpi_util_eval_error(h,p,s) {\
-	char prefix[80] = {'\0'};\
-	acpi_buffer buffer = {sizeof(prefix), prefix};\
-	acpi_get_name(h, ACPI_FULL_PATHNAME, &buffer);\
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate [%s.%s]: %s\n",\
-		(char *) prefix, p, acpi_format_exception(s))); }
-#else
-#define acpi_util_eval_error(h,p,s)
-#endif
-
-
-acpi_status
-acpi_extract_package (
-	acpi_object		*package,
-	acpi_buffer		*format,
-	acpi_buffer		*buffer)
-{
-	u32			size_required = 0;
-	u32			tail_offset = 0;
-	char			*format_string = NULL;
-	u32			format_count = 0;
-	u32			i = 0;
-	u8			*head = NULL;
-	u8			*tail = NULL;
-
-	ACPI_FUNCTION_TRACE("acpi_extract_package");
-
-	if (!package || (package->type != ACPI_TYPE_PACKAGE) || (package->package.count < 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'package' argument\n"));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (!format || !format->pointer || (format->length < 1)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'format' argument\n"));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	if (!buffer) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'buffer' argument\n"));
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	format_count = (format->length/sizeof(char)) - 1;
-	if (format_count > package->package.count) {
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Format specifies more objects [%d] than exist in package [%d].", format_count, package->package.count));
-		return_ACPI_STATUS(AE_BAD_DATA);
-	}
-
-	format_string = (char*)format->pointer;
-
-	/*
-	 * Calculate size_required.
-	 */
-	for (i=0; i<format_count; i++) {
-
-		acpi_object *element = &(package->package.elements[i]);
-
-		if (!element) {
-			return_ACPI_STATUS(AE_BAD_DATA);
-		}
-
-		switch (element->type) {
-
-		case ACPI_TYPE_INTEGER:
-			switch (format_string[i]) {
-			case 'N':
-				size_required += sizeof(acpi_integer);
-				tail_offset += sizeof(acpi_integer);
-				break;
-			case 'S':
-				size_required += sizeof(char*) + sizeof(acpi_integer) + sizeof(char);
-				tail_offset += sizeof(char*);
-				break;
-			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d]: got number, expecing [%c].\n", i, format_string[i]));
-				return_ACPI_STATUS(AE_BAD_DATA);
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_STRING:
-		case ACPI_TYPE_BUFFER:
-			switch (format_string[i]) {
-			case 'S':
-				size_required += sizeof(char*) + (element->string.length * sizeof(char)) + sizeof(char);
-				tail_offset += sizeof(char*);
-				break;
-			case 'B':
-				size_required += sizeof(u8*) + (element->buffer.length * sizeof(u8));
-				tail_offset += sizeof(u8*);
-				break;
-			default:
-				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d] got string/buffer, expecing [%c].\n", i, format_string[i]));
-				return_ACPI_STATUS(AE_BAD_DATA);
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_PACKAGE:
-		default:
-			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unsupported element at index=%d\n", i));
-			/* TBD: handle nested packages... */
-			return_ACPI_STATUS(AE_SUPPORT);
-			break;
-		}
-	}
-
-	/*
-	 * Validate output buffer.
-	 */
-	if (buffer->length < size_required) {
-		buffer->length = size_required;
-		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
-	}
-	else if (buffer->length != size_required || !buffer->pointer) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	head = buffer->pointer;
-	tail = buffer->pointer + tail_offset;
-
-	/*
-	 * Extract package data.
-	 */
-	for (i=0; i<format_count; i++) {
-
-		u8 **pointer = NULL;
-		acpi_object *element = &(package->package.elements[i]);
-
-		if (!element) {
-			return_ACPI_STATUS(AE_BAD_DATA);
-		}
-
-		switch (element->type) {
-
-		case ACPI_TYPE_INTEGER:
-			switch (format_string[i]) {
-			case 'N':
-				*((acpi_integer*)head) = element->integer.value;
-				head += sizeof(acpi_integer);
-				break;
-			case 'S':
-				pointer = (u8**)head;
-				*pointer = tail;
-				*((acpi_integer*)tail) = element->integer.value;
-				head += sizeof(acpi_integer*);
-				tail += sizeof(acpi_integer);
-				/* NULL terminate string */
-				*tail = (char)0;
-				tail += sizeof(char);
-				break;
-			default:
-				/* Should never get here */
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_STRING:
-		case ACPI_TYPE_BUFFER:
-			switch (format_string[i]) {
-			case 'S':
-				pointer = (u8**)head;
-				*pointer = tail;
-				memcpy(tail, element->string.pointer, element->string.length);
-				head += sizeof(char*);
-				tail += element->string.length * sizeof(char);
-				/* NULL terminate string */
-				*tail = (char)0;
-				tail += sizeof(char);
-				break;
-			case 'B':
-				pointer = (u8**)head;
-				*pointer = tail;
-				memcpy(tail, element->buffer.pointer, element->buffer.length);
-				head += sizeof(u8*);
-				tail += element->buffer.length * sizeof(u8);
-				break;
-			default:
-				/* Should never get here */
-				break;
-			}
-			break;
-
-		case ACPI_TYPE_PACKAGE:
-			/* TBD: handle nested packages... */
-		default:
-			/* Should never get here */
-			break;
-		}
-	}
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-acpi_status
-acpi_evaluate (
-	acpi_handle		handle,
-	acpi_string		pathname,
-	acpi_object_list	*arguments,
-	acpi_buffer		*buffer)
-{
-	acpi_status		status = AE_OK;
-
-	ACPI_FUNCTION_TRACE("acpi_evaluate");
-
-	/* If caller provided a buffer it must be unallocated/zero'd. */
-	if (buffer && (buffer->length != 0 || buffer->pointer))
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	/*
-	 * Evalute object. The first attempt is just to get the size of the
-	 * object data (that is unless there's no return data); the second
-	 * gets the data.
-	 */
-	status = acpi_evaluate_object(handle, pathname, arguments, buffer);
-
-	if (ACPI_SUCCESS(status)) {
-		return_ACPI_STATUS(status);
-	}
-
-	else if (buffer && (status == AE_BUFFER_OVERFLOW)) {
-
-		/* Gotta allocate - CALLER MUST FREE! */
-		buffer->pointer = kmalloc(buffer->length, GFP_KERNEL);
-		if (!buffer->pointer) {
-			return_ACPI_STATUS(AE_NO_MEMORY);
-		}
-		memset(buffer->pointer, 0, buffer->length);
-
-		/* Re-evaluate - this time it should work. */
-		status = acpi_evaluate_object(handle, pathname, arguments,
-			buffer);
-	}
-
-	if (ACPI_FAILURE(status)) {
-		if (status != AE_NOT_FOUND)
-			acpi_util_eval_error(handle, pathname, status);
-		if (buffer && buffer->pointer) {
-			kfree(buffer->pointer);
-			buffer->length = 0;
-		}
-	}
-
-	return_ACPI_STATUS(status);
-}
-
-
-acpi_status
-acpi_evaluate_integer (
-	acpi_handle		handle,
-	acpi_string		pathname,
-	acpi_object_list	*arguments,
-	unsigned long		*data)
-{
-	acpi_status             status = AE_OK;
-	acpi_object             element;
-	acpi_buffer		buffer = {sizeof(acpi_object), &element};
-
-	ACPI_FUNCTION_TRACE("acpi_evaluate_integer");
-
-	if (!data)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
-	if (ACPI_FAILURE(status)) {
-		acpi_util_eval_error(handle, pathname, status);
-		return_ACPI_STATUS(status);
-	}
-
-	if (element.type != ACPI_TYPE_INTEGER) {
-		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
-		return_ACPI_STATUS(AE_BAD_DATA);
-	}
-
-	*data = element.integer.value;
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%lu]\n", *data));
-
-	return_ACPI_STATUS(AE_OK);
-}
-
-
-#if 0
-acpi_status
-acpi_evaluate_string (
-	acpi_handle		handle,
-	acpi_string		pathname,
-	acpi_object_list	*arguments,
-	acpi_string		*data)
-{
-	acpi_status             status = AE_OK;
-	acpi_object             *element = NULL;
-	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
-
-	ACPI_FUNCTION_TRACE("acpi_evaluate_string");
-
-	if (!data)
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-
-	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
-	if (ACPI_FAILURE(status)) {
-		acpi_util_eval_error(handle, pathname, status);
-		return_ACPI_STATUS(status);
-	}
-
-	element = (acpi_object *) buffer.pointer;
-
-	if ((element->type != ACPI_TYPE_STRING) 
-		|| (element->type != ACPI_TYPE_BUFFER)
-		|| !element->string.length) {
-		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
-		return_ACPI_STATUS(AE_BAD_DATA);
-	}
-
-	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
-	if (!data) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
-		return_VALUE(-ENOMEM);
-	}
-	memset(*data, 0, element->string.length + 1);
-
-	memcpy(*data, element->string.pointer, element->string.length);
-
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%s]\n", *data));
-
-	return_ACPI_STATUS(AE_OK);
-}
-#endif
-
-
-acpi_status
-acpi_evaluate_reference (
-	acpi_handle		handle,
-	acpi_string		pathname,
-	acpi_object_list	*arguments,
-	struct acpi_handle_list	*list)
-{
-	acpi_status		status = AE_OK;
-	acpi_object		*package = NULL;
-	acpi_object		*element = NULL;
-	acpi_buffer		buffer = {0, NULL};
-	u32			i = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_evaluate_reference");
-
-	if (!list) {
-		return_ACPI_STATUS(AE_BAD_PARAMETER);
-	}
-
-	/* Evaluate object. */
-
-	status = acpi_evaluate(handle, pathname, arguments, &buffer);
-	if (ACPI_FAILURE(status))
-		goto end;
-
-	package = (acpi_object *) buffer.pointer;
-
-	if (!package || (package->type != ACPI_TYPE_PACKAGE)
-		|| (package->package.count == 0)) {
-		status = AE_BAD_DATA;
-		acpi_util_eval_error(handle, pathname, status);
-		goto end;
-	}
-
-	/* Allocate list - CALLER MUST FREE! */
-	list->count = package->package.count;
-	if (list->count > 10) {
-		return AE_NO_MEMORY;
-	}
-	/* TBD: dynamically allocate */
-	/*
-	list->handles = kmalloc(sizeof(acpi_handle)*(list->count), GFP_KERNEL);
-	if (!list->handles) {
-		return_ACPI_STATUS(AE_NO_MEMORY);
-	}
-	memset(list->handles, 0, sizeof(acpi_handle)*(list->count));
-	*/
-
-	/* Parse package data. */
-
-	for (i = 0; i < list->count; i++) {
-
-		element = &(package->package.elements[i]);
-
-		if (!element || (element->type != ACPI_TYPE_STRING)) {
-			status = AE_BAD_DATA;
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid element in package (not a device reference)\n"));
-			acpi_util_eval_error(handle, pathname, status);
-			break;
-		}
-
-		/* Convert reference (e.g. "\_PR_.CPU_") to acpi_handle. */
-
-		status = acpi_get_handle(handle, element->string.pointer,
-			&(list->handles[i]));
-		if (ACPI_FAILURE(status)) {
-			status = AE_BAD_DATA;
-			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to resolve device reference [%s]\n", element->string.pointer));
-			acpi_util_eval_error(handle, pathname, status);
-			break;
-		}
-
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resolved reference [%s]->[%p]\n", element->string.pointer, list->handles[i]));
-	}
-
-end:
-	if (ACPI_FAILURE(status)) {
-		list->count = 0;
-		//kfree(list->handles);
-	}
-
-	kfree(buffer.pointer);
-
-	return_ACPI_STATUS(status);
-}
-
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/battery.c linux/drivers/acpi/battery.c
--- ../prev/linux/drivers/acpi/battery.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/battery.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,831 @@
+/*
+ *  acpi_battery.c - ACPI Battery Driver ($Revision: 32 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_BATTERY_COMPONENT
+ACPI_MODULE_NAME		("acpi_battery")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_BATTERY_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_BATTERY_VALUE_UNKNOWN 0xFFFFFFFF
+
+#define ACPI_BATTERY_FORMAT_BIF	"NNNNNNNNNSSSS"
+#define ACPI_BATTERY_FORMAT_BST	"NNNN"
+
+static int acpi_battery_add (struct acpi_device *device);
+static int acpi_battery_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_battery_driver = {
+	name:			ACPI_BATTERY_DRIVER_NAME,
+	class:			ACPI_BATTERY_CLASS,
+	ids:			ACPI_BATTERY_HID,
+	ops:			{
+					add:	acpi_battery_add,
+					remove:	acpi_battery_remove,
+				},
+};
+
+struct acpi_battery_status {
+	acpi_integer		state;
+	acpi_integer		present_rate;
+	acpi_integer		remaining_capacity;
+	acpi_integer		present_voltage;
+};
+
+struct acpi_battery_info {
+	acpi_integer		power_unit;
+	acpi_integer		design_capacity;
+	acpi_integer		last_full_capacity;
+	acpi_integer		battery_technology;
+	acpi_integer		design_voltage;
+	acpi_integer		design_capacity_warning;
+	acpi_integer		design_capacity_low;
+	acpi_integer		battery_capacity_granularity_1;
+	acpi_integer		battery_capacity_granularity_2;
+	acpi_string		model_number;
+	acpi_string		serial_number;
+	acpi_string		battery_type;
+	acpi_string		oem_info;
+};
+
+struct acpi_battery_flags {
+	u8			present:1;	/* Bay occupied? */
+	u8			power_unit:1;	/* 0=watts, 1=apms */
+	u8			alarm:1;	/* _BTP present? */
+	u8			reserved:5;
+};
+
+struct acpi_battery_trips {
+	unsigned long		warning;
+	unsigned long		low;
+};
+
+struct acpi_battery {
+	acpi_handle		handle;
+	struct acpi_battery_flags flags;
+	struct acpi_battery_trips trips;
+	unsigned long		alarm;
+	struct acpi_battery_info *info;
+};
+
+
+/* --------------------------------------------------------------------------
+                               Battery Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_battery_get_info (
+	struct acpi_battery	*battery,
+	struct acpi_battery_info **bif)
+{
+	int			result = 0;
+	acpi_status 		status = 0;
+	acpi_buffer 		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_buffer		format = {sizeof(ACPI_BATTERY_FORMAT_BIF),
+						ACPI_BATTERY_FORMAT_BIF};
+	acpi_buffer		data = {0, NULL};
+	acpi_object 		*package = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_get_info");
+
+	if (!battery || !bif)
+		return_VALUE(-EINVAL);
+
+	/* Evalute _BIF */
+
+	status = acpi_evaluate_object(battery->handle, "_BIF", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BIF\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	package = (acpi_object *) buffer.pointer;
+
+	/* Extract Package Data */
+
+	status = acpi_extract_package(package, &format, &data);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	if (!data.pointer) {
+		result = -ENOMEM;
+		goto end;
+	}
+	memset(data.pointer, 0, data.length);
+
+	status = acpi_extract_package(package, &format, &data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BIF\n"));
+		kfree(data.pointer);
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	kfree(buffer.pointer);
+
+	if (0 == result)
+		(*bif) = (struct acpi_battery_info *) data.pointer;
+
+	return_VALUE(result);
+}
+
+static int
+acpi_battery_get_status (
+	struct acpi_battery	*battery,
+	struct acpi_battery_status **bst)
+{
+	int			result = 0;
+	acpi_status 		status = 0;
+	acpi_buffer 		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_buffer		format = {sizeof(ACPI_BATTERY_FORMAT_BST),
+						ACPI_BATTERY_FORMAT_BST};
+	acpi_buffer		data = {0, NULL};
+	acpi_object 		*package = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_get_status");
+
+	if (!battery || !bst)
+		return_VALUE(-EINVAL);
+
+	/* Evalute _BST */
+
+	status = acpi_evaluate_object(battery->handle, "_BST", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BST\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	package = (acpi_object *) buffer.pointer;
+
+	/* Extract Package Data */
+
+	status = acpi_extract_package(package, &format, &data);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	data.pointer = kmalloc(data.length, GFP_KERNEL);
+	if (!data.pointer) {
+		result = -ENOMEM;
+		goto end;
+	}
+	memset(data.pointer, 0, data.length);
+
+	status = acpi_extract_package(package, &format, &data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error extracting _BST\n"));
+		kfree(data.pointer);
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	kfree(buffer.pointer);
+
+	if (0 == result)
+		(*bst) = (struct acpi_battery_status *) data.pointer;
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_battery_set_alarm (
+	struct acpi_battery	*battery,
+	unsigned long		alarm)
+{
+	acpi_status		status = 0;
+	acpi_object		arg0 = {ACPI_TYPE_INTEGER};
+	acpi_object_list	arg_list = {1, &arg0};
+
+	ACPI_FUNCTION_TRACE("acpi_battery_set_alarm");
+
+	if (!battery)
+		return_VALUE(-EINVAL);
+
+	if (!battery->flags.alarm)
+		return_VALUE(-ENODEV);
+
+	arg0.integer.value = alarm;
+
+	status = acpi_evaluate(battery->handle, "_BTP", &arg_list, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", (u32) alarm));
+
+	battery->alarm = alarm;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_battery_check (
+	struct acpi_battery	*battery)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_handle		handle = NULL;
+	struct acpi_device	*device = NULL;
+	struct acpi_battery_info *bif = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_check");
+	
+	if (!battery)
+		return_VALUE(-EINVAL);
+
+	result = acpi_bus_get_device(battery->handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+
+	result = acpi_bus_get_status(device);
+	if (0 != result)
+		return_VALUE(result);
+
+	/* Insertion? */
+
+	if (!battery->flags.present && device->status.battery_present) {
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery inserted\n"));
+
+		/* Evalute _BIF to get certain static information */
+
+		result = acpi_battery_get_info(battery, &bif);
+		if (0 != result)
+			return_VALUE(result);
+
+		battery->flags.power_unit = bif->power_unit;
+		battery->trips.warning = bif->design_capacity_warning;
+		battery->trips.low = bif->design_capacity_low;
+		kfree(bif);
+
+		/* See if alarms are supported, and if so, set default */
+
+		status = acpi_get_handle(battery->handle, "_BTP", &handle);
+		if (ACPI_SUCCESS(status)) {
+			battery->flags.alarm = 1;
+			acpi_battery_set_alarm(battery, battery->trips.warning);
+		}
+	}
+
+	/* Removal? */
+
+	else if (battery->flags.present && !device->status.battery_present) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Battery removed\n"));
+	}
+
+	battery->flags.present = device->status.battery_present;
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry		*acpi_battery_dir = NULL;
+
+static int
+acpi_battery_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	struct acpi_battery_info *bif = NULL;
+	char			*units = "?";
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_info");
+
+	if (!battery)
+		goto end;
+
+	if (battery->flags.present)
+		p += sprintf(p, "present:                 yes\n");
+	else {
+		p += sprintf(p, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Info (_BIF) */
+
+	result = acpi_battery_get_info(battery, &bif);
+	if ((0 != result) || !bif) {
+		p += sprintf(p, "ERROR: Unable to read battery information\n");
+		goto end;
+	}
+
+	units = bif->power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+					
+	if (bif->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "design capacity:         unknown\n");
+	else
+		p += sprintf(p, "design capacity:         %d %sh\n",
+			(u32) bif->design_capacity, units);
+
+	if (bif->last_full_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "last full capacity:      unknown\n");
+	else
+		p += sprintf(p, "last full capacity:      %d %sh\n",
+			(u32) bif->last_full_capacity, units);
+
+	switch ((u32) bif->battery_technology) {
+	case 0:
+		p += sprintf(p, "battery technology:      non-rechargeable\n");
+		break;
+	case 1:
+		p += sprintf(p, "battery technology:      rechargeable\n");
+		break;
+	default:
+		p += sprintf(p, "battery technology:      unknown\n");
+		break;
+	}
+
+	if (bif->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "design voltage:          unknown\n");
+	else
+		p += sprintf(p, "design voltage:          %d mV\n",
+			(u32) bif->design_voltage);
+	
+	p += sprintf(p, "design capacity warning: %d %sh\n",
+		(u32) bif->design_capacity_warning, units);
+	p += sprintf(p, "design capacity low:     %d %sh\n",
+		(u32) bif->design_capacity_low, units);
+	p += sprintf(p, "capacity granularity 1:  %d %sh\n",
+		(u32) bif->battery_capacity_granularity_1, units);
+	p += sprintf(p, "capacity granularity 2:  %d %sh\n",
+		(u32) bif->battery_capacity_granularity_2, units);
+	p += sprintf(p, "model number:            %s\n",
+		bif->model_number);
+	p += sprintf(p, "serial number:           %s\n",
+		bif->serial_number);
+	p += sprintf(p, "battery type:            %s\n",
+		bif->battery_type);
+	p += sprintf(p, "OEM info:                %s\n",
+		bif->oem_info);
+
+end:
+	kfree(bif);
+
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_battery_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	struct acpi_battery_status *bst = NULL;
+	char			*units = "?";
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_state");
+
+	if (!battery)
+		goto end;
+
+	if (battery->flags.present)
+		p += sprintf(p, "present:                 yes\n");
+	else {
+		p += sprintf(p, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Units */
+
+	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
+	/* Battery Status (_BST) */
+
+	result = acpi_battery_get_status(battery, &bst);
+	if ((0 != result) || !bst) {
+		p += sprintf(p, "ERROR: Unable to read battery status\n");
+		goto end;
+	}
+
+	if (!(bst->state & 0x04))
+		p += sprintf(p, "capacity state:          ok\n");
+	else
+		p += sprintf(p, "capacity state:          critical\n");
+
+	if ((bst->state & 0x01) && (bst->state & 0x02))
+		p += sprintf(p, "charging state:          charging/discharging\n");
+	else if (bst->state & 0x01)
+		p += sprintf(p, "charging state:          discharging\n");
+	else if (bst->state & 0x02)
+		p += sprintf(p, "charging state:          charging\n");
+	else
+		p += sprintf(p, "charging state:          unknown\n");
+
+	if (bst->present_rate == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "present rate:            unknown\n");
+	else
+		p += sprintf(p, "present rate:            %d %s\n",
+			(u32) bst->present_rate, units);
+
+	if (bst->remaining_capacity == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "remaining capacity:      unknown\n");
+	else
+		p += sprintf(p, "remaining capacity:      %d %sh\n",
+			(u32) bst->remaining_capacity, units);
+
+	if (bst->present_voltage == ACPI_BATTERY_VALUE_UNKNOWN)
+		p += sprintf(p, "present voltage:         unknown\n");
+	else
+		p += sprintf(p, "present voltage:         %d mV\n",
+			(u32) bst->present_voltage);
+
+end:
+	kfree(bst);
+
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_battery_read_alarm (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	char			*units = "?";
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_read_alarm");
+
+	if (!battery)
+		goto end;
+
+	if (!battery->flags.present) {
+		p += sprintf(p, "present:                 no\n");
+		goto end;
+	}
+
+	/* Battery Units */
+	
+	units = battery->flags.power_unit ? ACPI_BATTERY_UNITS_AMPS : ACPI_BATTERY_UNITS_WATTS;
+
+	/* Battery Alarm */
+
+	p += sprintf(p, "alarm:                   ");
+	if (!battery->alarm)
+		p += sprintf(p, "unsupported\n");
+	else
+		p += sprintf(p, "%d %sh\n", (u32) battery->alarm, units);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_battery_write_alarm (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	char			alarm_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_battery_write_alarm");
+
+	if (!battery || (count > sizeof(alarm_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (!battery->flags.present)
+		return_VALUE(-ENODEV);
+
+	if (copy_from_user(alarm_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	alarm_string[count] = '\0';
+
+	result = acpi_battery_set_alarm(battery, 
+		simple_strtoul(alarm_string, NULL, 0));
+	if (0 != result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_battery_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_add_fs");
+
+	if (!acpi_battery_dir) {
+		acpi_battery_dir = proc_mkdir(ACPI_BATTERY_CLASS, acpi_root_dir);
+		if (!acpi_battery_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_battery_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_INFO));
+	else {
+		entry->read_proc = acpi_battery_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'status' [R] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_STATUS,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_STATUS));
+	else {
+		entry->read_proc = acpi_battery_read_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'alarm' [R/W] */
+	entry = create_proc_entry(ACPI_BATTERY_FILE_ALARM,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BATTERY_FILE_ALARM));
+	else {
+		entry->read_proc = acpi_battery_read_alarm;
+		entry->write_proc = acpi_battery_write_alarm;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_battery_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_battery_remove_fs");
+
+	if (!acpi_battery_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_battery_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_battery_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_battery	*battery = (struct acpi_battery *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_notify");
+
+	if (!battery)
+		return_VOID;
+
+	if (0 != acpi_bus_get_device(handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_BATTERY_NOTIFY_STATUS:
+	case ACPI_BATTERY_NOTIFY_INFO:
+		acpi_battery_check(battery);
+		acpi_bus_generate_event(device, event, battery->flags.present);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_battery_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = 0;
+	struct acpi_battery	*battery = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_add");
+	
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	battery = kmalloc(sizeof(struct acpi_battery), GFP_KERNEL);
+	if (!battery)
+		return_VALUE(-ENOMEM);
+	memset(battery, 0, sizeof(struct acpi_battery));
+
+	battery->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_BATTERY_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_BATTERY_CLASS);
+	acpi_driver_data(device) = battery;
+
+	result = acpi_battery_check(battery);
+	if (0 != result)
+		goto end;
+
+	result = acpi_battery_add_fs(device);
+	if (0 != result)
+		goto end;
+
+	status = acpi_install_notify_handler(battery->handle,
+		ACPI_DEVICE_NOTIFY, acpi_battery_notify, battery);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",
+		ACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),
+		device->status.battery_present?"present":"absent");
+		
+end:
+	if (0 != result) {
+		acpi_battery_remove_fs(device);
+		kfree(battery);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_battery_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = 0;
+	struct acpi_battery	*battery = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	battery = (struct acpi_battery *) acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(battery->handle,
+		ACPI_DEVICE_NOTIFY, acpi_battery_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	acpi_battery_remove_fs(device);
+
+	kfree(battery);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_battery_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_init");
+
+	result = acpi_bus_register_driver(&acpi_battery_driver);
+	if (0 > result) {
+		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_battery_exit (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_battery_exit");
+
+	result = acpi_bus_unregister_driver(&acpi_battery_driver);
+	if (0 == result)
+		remove_proc_entry(ACPI_BATTERY_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_battery_init);
+module_exit(acpi_battery_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/bus.c linux/drivers/acpi/bus.c
--- ../prev/linux/drivers/acpi/bus.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/bus.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,2200 @@
+/*
+ *  acpi_bus.c - ACPI Bus Driver ($Revision: 72 $)
+ *
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/ioport.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+#include "include/acinterp.h"	/* for acpi_ex_eisa_id_to_string() */
+
+
+#define _COMPONENT		ACPI_BUS_COMPONENT
+ACPI_MODULE_NAME		("acpi_bus")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_BUS_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define	PREFIX			"ACPI: "
+
+FADT_DESCRIPTOR			acpi_fadt;
+static u8			acpi_disabled;
+struct acpi_device		*acpi_root;
+struct proc_dir_entry		*acpi_root_dir;
+
+#define STRUCT_TO_INT(s)	(*((int*)&s))
+
+/*
+ * POLICY: If *anything* doesn't work, put it on the blacklist.
+ *	   If they are critical errors, mark it critical, and abort driver load.
+ */
+static struct acpi_blacklist_item acpi_blacklist[] __initdata =
+{
+	/* Portege 7020, BIOS 8.10 */
+	{"TOSHIB", "7020CT  ", 0x19991112, ACPI_TABLE_DSDT, all_versions, "Implicit Return", 0},
+	/* Portege 4030 */
+	{"TOSHIB", "4030    ", 0x19991112, ACPI_TABLE_DSDT, all_versions, "Implicit Return", 0},
+	/* Portege 310/320, BIOS 7.1 */
+	{"TOSHIB", "310     ", 0x19990511, ACPI_TABLE_DSDT, all_versions, "Implicit Return", 0},
+	/* Seattle 2, old bios rev. */
+	{"INTEL ", "440BX   ", 0x00001000, ACPI_TABLE_DSDT, less_than_or_equal, "Field beyond end of region", 0},
+	/* ASUS K7M */
+	{"ASUS  ", "K7M     ", 0x00001000, ACPI_TABLE_DSDT, less_than_or_equal, "Field beyond end of region", 0},
+	/* Intel 810 Motherboard? */
+	{"MNTRAL", "MO81010A", 0x00000012, ACPI_TABLE_DSDT, less_than_or_equal, "Field beyond end of region", 0},
+	/* Compaq Presario 1700 */
+	{"PTLTD ", "  DSDT  ", 0x06040000, ACPI_TABLE_DSDT, less_than_or_equal, "Multiple problems", 1},
+	/* Sony FX120, FX140, FX150? */
+	{"SONY  ", "U0      ", 0x20010313, ACPI_TABLE_DSDT, less_than_or_equal, "ACPI driver problem", 1},
+	/* Compaq Presario 800, Insyde BIOS */
+	{"INT440", "SYSFexxx", 0x00001001, ACPI_TABLE_DSDT, less_than_or_equal, "Does not use _REG to protect EC OpRegions", 1},
+	/* IBM 600E - _ADR should return 7, but it returns 1 */
+	{"IBM   ", "TP600E  ", 0x00000105, ACPI_TABLE_DSDT, less_than_or_equal, "Incorrect _ADR", 1},
+	{""}
+};
+
+
+/* --------------------------------------------------------------------------
+                          Linux Driver Model (LDM) Support
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_LDM
+
+static int acpi_device_probe(struct device *dev);
+static int acpi_device_remove(struct device *dev, u32 flags);
+static int acpi_device_suspend(struct device *dev, u32 state, u32 stage);
+static int acpi_device_resume(struct device *dev, u32 stage);
+
+static struct device_driver acpi_bus_driver = {
+	probe: acpi_device_probe,
+	remove: acpi_device_remove,	
+	suspend: acpi_device_suspend,
+	resume: acpi_device_resume,
+};
+
+
+static int
+acpi_device_probe (
+	struct device		*dev)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_probe");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_device_remove (
+	struct device		*dev,
+	u32			flags)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_remove");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_device_suspend (
+	struct device		*dev,
+	u32			state,
+	u32			stage)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_suspend");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_device_resume (
+	struct device		*dev,
+	u32			stage)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_resume");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+#if 0 /* not used ATM */
+static int
+acpi_platform_add (
+	struct device		*dev)
+{
+	ACPI_FUNCTION_TRACE("acpi_platform_add");
+
+	if (!dev)
+		return -EINVAL;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s (%s) added\n",
+		dev->name, dev->bus_id));
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_platform_remove (
+	struct device		*dev)
+{
+	ACPI_FUNCTION_TRACE("acpi_platform_add");
+
+	if (!dev)
+		return -EINVAL;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s (%s) removed\n",
+		dev->name, dev->bus_id));
+
+	/* TBD */
+
+	return_VALUE(0);
+}
+#endif /* unused */
+
+
+#endif /*CONFIG_LDM*/
+
+
+static int
+acpi_device_register (
+	struct acpi_device	*device,
+	struct acpi_device	*parent)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_device_register");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+#ifdef CONFIG_LDM
+	sprintf(device->dev.name, "ACPI device %s:%s", 
+		device->pnp.hardware_id, device->pnp.unique_id);
+	strncpy(device->dev.bus_id, device->pnp.bus_id, sizeof(acpi_bus_id));
+	if (parent)
+		device->dev.parent = &parent->dev;
+	device->dev.driver = &acpi_bus_driver;
+
+	result = device_register(&device->dev);
+#endif /*CONFIG_LDM*/
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_device_unregister (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_device_unregister");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+#ifdef CONFIG_LDM
+	put_device(&device->dev);
+#endif /*CONFIG_LDM*/
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Device Management
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_bus_data_handler (
+	acpi_handle		handle,
+	u32			function,
+	void			*context)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_data_handler");
+
+	/* TBD */
+
+	return_VOID;
+}
+
+
+int
+acpi_bus_get_device (
+	acpi_handle		handle,
+	struct acpi_device	**device)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_device");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* TBD: Support fixed-feature devices */
+
+	status = acpi_get_data(handle, acpi_bus_data_handler, (void**) device);
+	if (ACPI_FAILURE(status) || !*device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context for object [%p]\n",
+			handle));
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+int
+acpi_bus_get_status (
+	struct acpi_device	*device)
+{
+	acpi_status		status = AE_OK;
+	unsigned long		sta = 0;
+	
+	ACPI_FUNCTION_TRACE("acpi_bus_get_status");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Evaluate _STA if present.
+	 */
+	if (device->flags.dynamic_status) {
+		status = acpi_evaluate_integer(device->handle, "_STA", NULL, &sta);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+		STRUCT_TO_INT(device->status) = (int) sta;
+	}
+
+	/*
+	 * Otherwise we assume the status of our parent (unless we don't
+	 * have one, in which case status is implied).
+	 */
+	else if (device->parent)
+		device->status = device->parent->status;
+	else
+		STRUCT_TO_INT(device->status) = 0x0F;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n", 
+		device->pnp.bus_id, (u32) STRUCT_TO_INT(device->status)));
+
+	return_VALUE(0);
+}
+
+
+/*
+static int
+acpi_bus_create_device_fs (struct device *device)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_create_device_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (device->dir.entry)
+		return_VALUE(-EEXIST);
+
+	if (!device->parent)
+		device->dir.entry = proc_mkdir(device->pnp.bus_id, NULL);
+	else
+		device->dir.entry = proc_mkdir(device->pnp.bus_id,
+			device->parent->fs.entry);
+
+	if (!device->dir.entry) {
+		printk(KERN_ERR PREFIX "Unable to create fs entry '%s'\n",
+			device->pnp.bus_id);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_remove_device_fs (struct device *device)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_create_device_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (!device->dir.entry)
+		return_VALUE(-ENODEV);
+
+	if (!device->parent)
+		remove_proc_entry(device->pnp_bus_id, NULL);
+	else
+		remove_proc_entry(device->pnp.bus_id, device->parent->fs.entry);
+
+	device->dir.entry = NULL;
+
+	return_VALUE(0);
+}
+*/
+
+
+/* --------------------------------------------------------------------------
+                                 Power Management
+   -------------------------------------------------------------------------- */
+
+int
+acpi_bus_get_power (
+	acpi_handle		handle,
+	int			*state)
+{
+	int			result = 0;
+	acpi_status             status = 0;
+	struct acpi_device	*device = NULL;
+	unsigned long		psc = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_power");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+
+	*state = ACPI_STATE_UNKNOWN;
+
+	if (!device->flags.power_manageable) {
+		/* TBD: Non-recursive algorithm for walking up hierarchy */
+		if (device->parent)
+			*state = device->parent->power.state;
+		else
+			*state = ACPI_STATE_D0;
+	}
+	else {
+		/*
+		 * Get the device's power state either directly (via _PSC) or 
+		 * indirectly (via power resources).
+		 */
+		if (device->power.flags.explicit_get) {
+			status = acpi_evaluate_integer(device->handle, "_PSC", 
+				NULL, &psc);
+			if (ACPI_FAILURE(status))
+				return_VALUE(-ENODEV);
+			device->power.state = (int) psc;
+		}
+		else if (device->power.flags.power_resources) {
+			result = acpi_power_get_inferred_state(device);
+			if (0 != result)
+				return_VALUE(result);
+		}
+
+		*state = device->power.state;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is D%d\n",
+		device->pnp.bus_id, device->power.state));
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_bus_set_power (
+	acpi_handle		handle,
+	int			state)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	char			object_name[5] = {'_','P','S','0'+state,'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_bus_set_power");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+
+	if ((state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+		return_VALUE(-EINVAL);
+
+	/* Make sure this is a valid target state */
+
+	if (!device->flags.power_manageable) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device is not power manageable\n"));
+		return_VALUE(-ENODEV);
+	}
+	if (state == device->power.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device is already at D%d\n", state));
+		return_VALUE(0);
+	}
+	if (!device->power.states[state].flags.valid) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Device does not support D%d\n", state));
+		return_VALUE(-ENODEV);
+	}
+	if (device->parent && (state < device->parent->power.state)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Cannot set device to a higher-powered state than parent\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * Transition Power
+	 * ----------------
+	 * On transitions to a high-powered state we first apply power (via
+	 * power resources) then evalute _PSx.  Conversly for transitions to
+	 * a lower-powered state.
+	 */ 
+	if (state < device->power.state) {
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (0 != result)
+				goto end;
+		}
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle, 
+				object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+	}
+	else {
+		if (device->power.states[state].flags.explicit_set) {
+			status = acpi_evaluate_object(device->handle, 
+				object_name, NULL, NULL);
+			if (ACPI_FAILURE(status)) {
+				result = -ENODEV;
+				goto end;
+			}
+		}
+		if (device->power.flags.power_resources) {
+			result = acpi_power_transition(device, state);
+			if (0 != result)
+				goto end;
+		}
+	}
+
+end:
+	if (0 != result)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error transitioning device [%s] to D%d\n",
+			device->pnp.bus_id, state));
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] transitioned to D%d\n",
+			device->pnp.bus_id, state));
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_bus_get_power_flags (
+	struct acpi_device	*device)
+{
+	acpi_status             status = 0;
+	acpi_handle		handle = 0;
+	u32                     i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_power_flags");
+
+	if (!device)
+		return -ENODEV;
+
+	/*
+	 * Power Management Flags
+	 */
+	status = acpi_get_handle(device->handle, "_PSC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.explicit_get = 1;
+	status = acpi_get_handle(device->handle, "_IRC", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.inrush_current = 1;
+	status = acpi_get_handle(device->handle, "_PRW", &handle);
+	if (ACPI_SUCCESS(status))
+		device->power.flags.wake_capable = 1;
+
+	/*
+	 * Enumerate supported power management states
+	 */
+	for (i = ACPI_STATE_D0; i <= ACPI_STATE_D3; i++) {
+		struct acpi_device_power_state *ps = &device->power.states[i];
+		char		object_name[5] = {'_','P','R','0'+i,'\0'};
+
+		/* Evaluate "_PRx" to se if power resources are referenced */
+		acpi_evaluate_reference(device->handle, object_name, NULL,
+			&ps->resources);
+		if (ps->resources.count) {
+			device->power.flags.power_resources = 1;
+			ps->flags.valid = 1;
+		}
+
+		/* Evaluate "_PSx" to see if we can do explicit sets */
+		object_name[2] = 'S';
+		status = acpi_get_handle(device->handle, object_name, &handle);
+		if (ACPI_SUCCESS(status)) {
+			ps->flags.explicit_set = 1;
+			ps->flags.valid = 1;
+		}
+
+		/* State is valid if we have some power control */
+		if (ps->resources.count || ps->flags.explicit_set)
+			ps->flags.valid = 1;
+
+		ps->power = -1;		/* Unknown - driver assigned */
+		ps->latency = -1;	/* Unknown - driver assigned */
+	}
+
+	/* Set defaults for D0 and D3 states (always valid) */
+	device->power.states[ACPI_STATE_D0].flags.valid = 1;
+	device->power.states[ACPI_STATE_D0].power = 100;
+	device->power.states[ACPI_STATE_D3].flags.valid = 1;
+	device->power.states[ACPI_STATE_D3].power = 0;
+
+	/*
+	 * System Power States
+	 * -------------------
+	 */
+	/* TBD: S1-S4 power state support and resource requirements. */
+	/*
+	for (i=ACPI_STATE_S1; i<ACPI_STATE_S5; i++) {
+		char name[5] = {'_','S',('0'+i),'D','\0'};
+		status = acpi_evaluate_integer(device->handle, name, NULL,
+			&state);
+		if (ACPI_FAILURE(status))
+			continue;
+	}
+	*/
+
+	/* TBD: System wake support and resource requirements. */
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	return 0;
+}
+
+
+/* --------------------------------------------------------------------------
+                              Performance Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_bus_get_perf_flags (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_get_perf_flags");
+
+	if (!device)
+		return -ENODEV;
+
+	device->performance.state = ACPI_STATE_UNKNOWN;
+
+	return 0;
+}
+
+
+/* --------------------------------------------------------------------------
+                                Event Management
+   -------------------------------------------------------------------------- */
+
+static spinlock_t		acpi_bus_event_lock = SPIN_LOCK_UNLOCKED;
+
+LIST_HEAD(acpi_bus_event_list);
+DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
+
+extern int			event_is_open;
+
+int
+acpi_bus_generate_event (
+	struct acpi_device	*device,
+	u8			type,
+	int			data)
+{
+	struct acpi_bus_event	*event = NULL;
+	u32			flags = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_generate_event");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* drop event on the floor if no one's listening */
+	if (!event_is_open)
+		return_VALUE(0);
+
+	event = kmalloc(sizeof(struct acpi_bus_event), GFP_KERNEL);
+	if (!event)
+		return_VALUE(-ENOMEM);
+
+	sprintf(event->device_class, "%s", device->pnp.device_class);
+	sprintf(event->bus_id, "%s", device->pnp.bus_id);
+	event->type = type;
+	event->data = data;
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	list_add_tail(&event->node, &acpi_bus_event_list);
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	wake_up_interruptible(&acpi_bus_event_queue);
+
+	return_VALUE(0);
+}
+
+int
+acpi_bus_receive_event (
+	struct acpi_bus_event	*event)
+{
+	u32			flags = 0;
+	struct acpi_bus_event	*entry = NULL;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	ACPI_FUNCTION_TRACE("acpi_bus_receive_event");
+
+	if (!event)
+		return -EINVAL;
+
+	if (list_empty(&acpi_bus_event_list)) {
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&acpi_bus_event_queue, &wait);
+
+		if (list_empty(&acpi_bus_event_list))
+			schedule();
+
+		remove_wait_queue(&acpi_bus_event_queue, &wait);
+		set_current_state(TASK_RUNNING);
+
+		if (signal_pending(current))
+			return_VALUE(-ERESTARTSYS);
+	}
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	entry = list_entry(acpi_bus_event_list.next, struct acpi_bus_event, node);
+	if (entry)
+		list_del(&entry->node);
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	if (!entry)
+		return_VALUE(-ENODEV);
+
+	memcpy(event, entry, sizeof(struct acpi_bus_event));
+
+	kfree(entry);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                               Namespace Management
+   -------------------------------------------------------------------------- */
+
+#define WALK_UP			0
+#define WALK_DOWN		1
+
+typedef int (*acpi_bus_walk_callback)(struct acpi_device*, int, void*);
+
+#define HAS_CHILDREN(d)		((d)->children.next != &((d)->children))
+#define HAS_SIBLINGS(d)		(((d)->parent) && ((d)->node.next != &(d)->parent->children))
+#define NODE_TO_DEVICE(n)	(list_entry(n, struct acpi_device, node))
+
+
+/**
+ * acpi_bus_walk
+ * -------------
+ * Used to walk the ACPI Bus's device namespace.  Can walk down (depth-first)
+ * or up.  Able to parse starting at any node in the namespace.  Note that a
+ * callback return value of -ELOOP will terminate the walk.
+ *
+ * @start:	starting point
+ * callback:	function to call for every device encountered while parsing
+ * direction:	direction to parse (up or down)
+ * @data:	context for this search operation
+ */
+static int
+acpi_bus_walk (
+	struct acpi_device	*start, 
+	acpi_bus_walk_callback	callback, 
+	int			direction, 
+	void			*data)
+{
+	int			result = 0;
+	int			level = 0;
+	struct acpi_device	*device = NULL;
+
+	if (!start || !callback)
+		return -EINVAL;
+
+	device = start;
+
+	/*
+	 * Parse Namespace
+	 * ---------------
+	 * Parse a given subtree (specified by start) in the given direction.
+	 * Walking 'up' simply means that we execute the callback on leaf
+	 * devices prior to their parents (useful for things like removing
+	 * or powering down a subtree).
+	 */
+
+	while (device) {
+
+		if (direction == WALK_DOWN)
+			if (-ELOOP == callback(device, level, data))
+				break;
+
+		/* Depth First */
+
+		if (HAS_CHILDREN(device)) {
+			device = NODE_TO_DEVICE(device->children.next);
+			++level;
+			continue;
+		}
+
+		if (direction == WALK_UP)
+			if (-ELOOP == callback(device, level, data))
+				break;
+
+		/* Now Breadth */
+
+		if (HAS_SIBLINGS(device)) {
+			device = NODE_TO_DEVICE(device->node.next);
+			continue;
+		}
+
+		/* Scope Exhausted - Find Next */
+
+		while ((device = device->parent)) {
+			--level;
+			if (HAS_SIBLINGS(device)) {
+				device = NODE_TO_DEVICE(device->node.next);
+				break;
+			}
+		}
+	}
+
+	if ((direction == WALK_UP) && (result == 0))
+		callback(start, level, data);
+
+	return result;
+}
+
+
+/* --------------------------------------------------------------------------
+                             Notification Handling
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_bus_check_device (
+	struct acpi_device	*device,
+	int			*status_changed)
+{
+	acpi_status             status = 0;
+	struct acpi_device_status old_status;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_check_device");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (status_changed)
+		*status_changed = 0;
+
+	old_status = device->status;
+
+	/*
+	 * Make sure this device's parent is present before we go about
+	 * messing with the device.
+	 */
+	if (device->parent && !device->parent->status.present) {
+		device->status = device->parent->status;
+		if (STRUCT_TO_INT(old_status) != STRUCT_TO_INT(device->status)) {
+			if (status_changed)
+				*status_changed = 1;
+		}
+		return_VALUE(0);
+	}
+
+	status = acpi_bus_get_status(device);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (STRUCT_TO_INT(old_status) == STRUCT_TO_INT(device->status))
+		return_VALUE(0);
+
+	if (status_changed)
+		*status_changed = 1;
+	
+	/*
+	 * Device Insertion/Removal
+	 */
+	if ((device->status.present) && !(old_status.present)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device insertion detected\n"));
+		/* TBD: Handle device insertion */
+	}
+	else if (!(device->status.present) && (old_status.present)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device removal detected\n"));
+		/* TBD: Handle device removal */
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_check_scope (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	int			status_changed = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_check_scope");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* Status Change? */
+	result = acpi_bus_check_device(device, &status_changed);
+	if (0 != result)
+		return_VALUE(result);
+
+	if (!status_changed)
+		return_VALUE(0);
+
+	/*
+	 * TBD: Enumerate child devices within this device's scope and
+	 *       run acpi_bus_check_device()'s on them.
+	 */
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_notify
+ * ---------------
+ * Callback for all 'system-level' device notifications (values 0x00-0x7F).
+ */
+static void 
+acpi_bus_notify (
+	acpi_handle             handle,
+	u32                     type,
+	void                    *data)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_notify");
+
+	if (0 != acpi_bus_get_device(handle, &device))
+		return_VOID;
+
+	switch (type) {
+
+	case ACPI_NOTIFY_BUS_CHECK:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS CHECK notification for device [%s]\n", 
+			device->pnp.bus_id));
+		result = acpi_bus_check_scope(device);
+		/* 
+		 * TBD: We'll need to outsource certain events to non-ACPI
+		 *	drivers via the device manager (device.c).
+		 */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_CHECK:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK notification for device [%s]\n", 
+			device->pnp.bus_id));
+		result = acpi_bus_check_device(device, NULL);
+		/* 
+		 * TBD: We'll need to outsource certain events to non-ACPI
+		 *	drivers via the device manager (device.c).
+		 */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_WAKE:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE WAKE notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_EJECT_REQUEST:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received EJECT REQUEST notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_DEVICE_CHECK_LIGHT:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received DEVICE CHECK LIGHT notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD: Exactly what does 'light' mean? */
+		break;
+
+	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received FREQUENCY MISMATCH notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received BUS MODE MISMATCH notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	case ACPI_NOTIFY_POWER_FAULT:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received POWER FAULT notification for device [%s]\n", 
+			device->pnp.bus_id));
+		/* TBD */
+		break;
+
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Received unknown/unsupported notification [%08x]\n", 
+			type));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Management
+   -------------------------------------------------------------------------- */
+
+static LIST_HEAD(acpi_bus_drivers);
+static DECLARE_MUTEX(acpi_bus_drivers_lock);
+
+
+/**
+ * acpi_bus_match 
+ * --------------
+ * Checks the device's hardware (_HID) or compatible (_CID) ids to see if it
+ * matches the specified driver's criteria.
+ */
+static int
+acpi_bus_match (
+	struct acpi_device	*device,
+	struct acpi_driver	*driver)
+{
+
+	if (!device || !driver)
+		return -EINVAL;
+
+	if (device->flags.hardware_id) {
+		if (0 != strstr(driver->ids, device->pnp.hardware_id))
+			return 0;
+	}
+
+	if (device->flags.compatible_ids) {
+		acpi_status	status = AE_OK;
+		acpi_buffer	buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+		acpi_object	*object = NULL;
+		char		cid[256];
+
+		memset(cid, 0, sizeof(cid));
+
+		status = acpi_evaluate_object(device->handle, "_CID", NULL, 
+			&buffer);
+		if (ACPI_FAILURE(status) || !buffer.pointer)
+			return -ENOENT;
+
+		object = (acpi_object *) buffer.pointer;
+
+		switch (object->type) {
+		case ACPI_TYPE_INTEGER:
+			acpi_ex_eisa_id_to_string((u32) object->integer.value, 
+				cid);
+			break;
+		case ACPI_TYPE_STRING:
+			strncpy(cid, object->string.pointer, sizeof(cid) - 1);
+			break;
+		case ACPI_TYPE_PACKAGE:
+			/* TBD: Support CID packages */
+			break;
+		}
+
+		if (!cid[0])
+			return -ENOENT;
+
+		if (0 != strstr(driver->ids, cid))
+			return 0;
+	}
+
+	return -ENOENT;
+}
+
+
+/**
+ * acpi_bus_driver_init 
+ * --------------------
+ * Used to initialize a device via its device driver.  Called whenever a 
+ * driver is bound to a device.  Invokes the driver's add() and start() ops.
+ */
+static int
+acpi_bus_driver_init (
+	struct acpi_device	*device, 
+	struct acpi_driver	*driver)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_driver_init");
+
+	if (!device || !driver)
+		return_VALUE(-EINVAL);
+
+	if (!driver->ops.add)
+		return_VALUE(-ENOSYS);
+
+	result = driver->ops.add(device);
+	if (0 != result) {
+		device->driver = NULL;
+		acpi_driver_data(device) = NULL;
+		return_VALUE(result);
+	}
+
+	/*
+	 * TBD - Configuration Management: Assign resources to device based
+	 * upon possible configuration and currently allocated resources.
+	 */
+
+	if (driver->ops.start) {
+		result = driver->ops.start(device);
+		if ((0 != result) && (driver->ops.remove))
+			driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
+		return_VALUE(result);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Driver successfully bound to device\n"));
+
+#ifdef CONFIG_LDM
+	/* 
+	 * Update the device information (in the global device hierarchy) now
+	 * that there's a driver bound to it.
+	 */
+	strncpy(device->dev.name, device->pnp.device_name, 
+		sizeof(device->dev.name));
+#endif
+
+	if (driver->ops.scan) {
+		driver->ops.scan(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_attach 
+ * -------------
+ * Callback for acpi_bus_walk() used to find devices that match a specific 
+ * driver's criteria and then attach the driver.
+ */
+static int
+acpi_bus_attach (
+	struct acpi_device	*device, 
+	int			level, 
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_driver	*driver = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_attach");
+
+	if (!device || !data)
+		return_VALUE(-EINVAL);
+
+	driver = (struct acpi_driver *) data;
+
+	if (device->driver)
+		return_VALUE(-EEXIST);
+
+	if (!device->status.present)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_match(device, driver);
+	if (0 != result)
+		return_VALUE(result);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found driver [%s] for device [%s]\n",
+		driver->name, device->pnp.bus_id));
+	
+	result = acpi_bus_driver_init(device, driver);
+	if (0 != result)
+		return_VALUE(result);
+
+	down(&acpi_bus_drivers_lock);
+	++driver->references;
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_unattach 
+ * -----------------
+ * Callback for acpi_bus_walk() used to find devices that match a specific 
+ * driver's criteria and unattach the driver.
+ */
+static int
+acpi_bus_unattach (
+	struct acpi_device	*device, 
+	int			level, 
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_driver	*driver = (struct acpi_driver *) data;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_unattach");
+
+	if (!device || !driver)
+		return_VALUE(-EINVAL);
+
+	if (device->driver != driver)
+		return_VALUE(-ENOENT);
+
+	if (!driver->ops.remove)
+		return_VALUE(-ENOSYS);
+
+	result = driver->ops.remove(device, ACPI_BUS_REMOVAL_NORMAL);
+	if (0 != result)
+		return_VALUE(result);
+
+	device->driver = NULL;
+	acpi_driver_data(device) = NULL;
+
+	down(&acpi_bus_drivers_lock);
+	driver->references--;
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(0);
+}
+
+
+/**
+ * acpi_bus_find_driver 
+ * --------------------
+ * Parses the list of registered drivers looking for a driver applicable for
+ * the specified device.
+ */
+static int
+acpi_bus_find_driver (
+	struct acpi_device	*device)
+{
+	int			result = -ENODEV;
+	struct list_head	*entry = NULL;
+	struct acpi_driver	*driver = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_find_driver");
+
+	if (!device || device->driver)
+		return_VALUE(-EINVAL);
+
+	down(&acpi_bus_drivers_lock);
+
+	list_for_each(entry, &acpi_bus_drivers) {
+
+		driver = list_entry(entry, struct acpi_driver, node);
+
+		if (0 != acpi_bus_match(device, driver))
+			continue;
+
+		result = acpi_bus_driver_init(device, driver);
+		if (0 == result)
+			++driver->references;
+
+		break;
+	}
+
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(result);
+}
+
+
+/**
+ * acpi_bus_register_driver 
+ * ------------------------ 
+ * Registers a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and binds.
+ */
+int
+acpi_bus_register_driver (
+	struct acpi_driver	*driver)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_register_driver");
+
+	if (!driver)
+		return_VALUE(-EINVAL);
+
+	down(&acpi_bus_drivers_lock);
+	list_add_tail(&driver->node, &acpi_bus_drivers);
+	up(&acpi_bus_drivers_lock);
+
+	acpi_bus_walk(acpi_root, acpi_bus_attach, 
+		WALK_DOWN, driver);
+
+	return_VALUE(driver->references);
+}
+
+
+/**
+ * acpi_bus_unregister_driver 
+ * --------------------------
+ * Unregisters a driver with the ACPI bus.  Searches the namespace for all
+ * devices that match the driver's criteria and unbinds.
+ */
+int
+acpi_bus_unregister_driver (
+	struct acpi_driver	*driver)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_unregister_driver");
+
+	if (!driver)
+		return_VALUE(-EINVAL);
+
+	acpi_bus_walk(acpi_root, acpi_bus_unattach, WALK_UP, driver);
+
+	if (driver->references)
+		return_VALUE(driver->references);
+
+	down(&acpi_bus_drivers_lock);
+	list_del(&driver->node);
+	up(&acpi_bus_drivers_lock);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Device Enumeration
+   -------------------------------------------------------------------------- */
+
+static int 
+acpi_bus_get_flags (
+	struct acpi_device	*device)
+{
+	acpi_status		status = AE_OK;
+	acpi_handle		temp = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_get_flags");
+
+	/* Presence of _STA indicates 'dynamic_status' */
+	status = acpi_get_handle(device->handle, "_STA", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.dynamic_status = 1;
+
+	/* Presence of _CID indicates 'compatible_ids' */
+	status = acpi_get_handle(device->handle, "_CID", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.compatible_ids = 1;
+
+	/* Presence of _RMV indicates 'removable' */
+	status = acpi_get_handle(device->handle, "_RMV", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.removable = 1;
+
+	/* Presence of _EJD|_EJ0 indicates 'ejectable' */
+	status = acpi_get_handle(device->handle, "_EJD", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.ejectable = 1;
+	else {
+		status = acpi_get_handle(device->handle, "_EJ0", &temp);
+		if (ACPI_SUCCESS(status))
+			device->flags.ejectable = 1;
+	}
+
+	/* Presence of _LCK indicates 'lockable' */
+	status = acpi_get_handle(device->handle, "_LCK", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.lockable = 1;
+
+	/* Presence of _PS0|_PR0 indicates 'power manageable' */
+	status = acpi_get_handle(device->handle, "_PS0", &temp);
+	if (ACPI_FAILURE(status))
+		status = acpi_get_handle(device->handle, "_PR0", &temp);
+	if (ACPI_SUCCESS(status))
+		device->flags.power_manageable = 1;
+
+	/* TBD: Peformance management */
+
+	return_VALUE(0);
+}
+
+
+static int 
+acpi_bus_add (
+	struct acpi_device	**child,
+	struct acpi_device	*parent,
+	acpi_handle		handle,
+	int			type)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	char			bus_id[5] = {'?',0};
+	acpi_buffer		buffer = {sizeof(bus_id), bus_id};
+	acpi_device_info	info;
+	char			*hid = NULL;
+	char			*uid = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_add");
+
+	if (!child)
+		return_VALUE(-EINVAL);
+
+	device = kmalloc(sizeof(struct acpi_device), GFP_KERNEL);
+	if (!device) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		return_VALUE(-ENOMEM);
+	}
+	memset(device, 0, sizeof(struct acpi_device));
+
+	device->handle = handle;
+	device->parent = parent;
+
+	memset(&info, 0, sizeof(acpi_device_info));
+
+	/*
+	 * Bus ID
+	 * ------
+	 * The device's Bus ID is simply the object name.
+	 * TBD: Shouldn't this value be unique (within the ACPI namespace)?
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_SYSTEM:
+		sprintf(device->pnp.bus_id, "%s", "ACPI");
+		break;
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+		sprintf(device->pnp.bus_id, "%s", "PWRF");
+		break;
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		sprintf(device->pnp.bus_id, "%s", "SLPF");
+		break;
+	default:
+		acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);
+		/* Clean up trailing underscores (if any) */
+		for (i = 3; i > 1; i--) {
+			if (bus_id[i] == '_')
+				bus_id[i] = '\0';
+			else
+				break;
+		}
+		sprintf(device->pnp.bus_id, "%s", bus_id);
+		break;
+	}
+
+	/*
+	 * Flags
+	 * -----
+	 * Get prior to calling acpi_bus_get_status() so we know whether
+	 * or not _STA is present.  Note that we only look for object
+	 * handles -- cannot evaluate objects until we know the device is
+	 * present and properly initialized.
+	 */
+	result = acpi_bus_get_flags(device);
+	if (0 != result)
+		goto end;
+
+	/*
+	 * Status
+	 * ------
+	 * See if the device is present.  We always assume that non-Device()
+	 * objects (e.g. thermal zones, power resources, processors, etc.) are
+	 * present, functioning, etc. (at least when parent object is present).
+	 * Note that _STA has a different meaning for some objects (e.g.
+	 * power resources) so we need to be careful how we use it.
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_DEVICE:
+		result = acpi_bus_get_status(device);
+		if (0 != result)
+			goto end;
+		break;
+	default:
+		STRUCT_TO_INT(device->status) = 0x0F;
+		break;
+	}
+	if (!device->status.present) {
+		result = -ENOENT;
+		goto end;
+	}
+
+	/*
+	 * Initialize Device
+	 * -----------------
+	 * TBD: Synch with Core's enumeration/initialization process.
+	 */
+
+	/*
+	 * Hardware ID, Unique ID, & Bus Address
+	 * -------------------------------------
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_DEVICE:
+		status = acpi_get_object_info(handle, &info);
+		if (ACPI_FAILURE(status)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+				"Error reading device info\n"));
+			result = -ENODEV;
+			goto end;
+		}
+		/* Clean up info strings (not NULL terminated) */
+		info.hardware_id[sizeof(info.hardware_id)-1] = '\0';
+		info.unique_id[sizeof(info.unique_id)-1] = '\0';
+		if (info.valid & ACPI_VALID_HID)
+			hid = info.hardware_id;
+		if (info.valid & ACPI_VALID_UID)
+			uid = info.unique_id;
+		if (info.valid & ACPI_VALID_ADR) {
+			device->pnp.bus_address = info.address;
+			device->flags.bus_address = 1;
+		}
+		break;
+	case ACPI_BUS_TYPE_POWER:
+		hid = ACPI_POWER_HID;
+		break;
+	case ACPI_BUS_TYPE_PROCESSOR:
+		hid = ACPI_PROCESSOR_HID;
+		break;
+	case ACPI_BUS_TYPE_SYSTEM:
+		hid = ACPI_SYSTEM_HID;
+		break;
+	case ACPI_BUS_TYPE_THERMAL:
+		hid = ACPI_THERMAL_HID;
+		break;
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+		hid = ACPI_BUTTON_HID_POWERF;
+		break;
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		hid = ACPI_BUTTON_HID_SLEEPF;
+		break;
+	}
+
+	/* 
+	 * \_SB
+	 * ----
+	 * Fix for the system root bus device -- the only root-level device.
+	 */
+	if ((parent == ACPI_ROOT_OBJECT) && (type == ACPI_BUS_TYPE_DEVICE)) {
+		hid = ACPI_BUS_HID;
+		sprintf(device->pnp.device_name, "%s", ACPI_BUS_DEVICE_NAME);
+		sprintf(device->pnp.device_class, "%s", ACPI_BUS_CLASS);
+	}
+
+	if (hid) {
+		sprintf(device->pnp.hardware_id, "%s", hid);
+		device->flags.hardware_id = 1;
+	}
+	if (uid) {
+		sprintf(device->pnp.unique_id, "%s", uid);
+		device->flags.unique_id = 1;
+	}
+
+	/*
+	 * Power Management
+	 * ----------------
+	 */
+	if (device->flags.power_manageable) {
+		result = acpi_bus_get_power_flags(device);
+		if (0 != result)
+			goto end;
+	}
+
+	/*
+	 * Performance Management
+	 * ----------------------
+	 */
+	if (device->flags.performance_manageable) {
+		result = acpi_bus_get_perf_flags(device);
+		if (0 != result)
+			goto end;
+	}
+
+	/*
+	 * Context
+	 * -------
+	 * Attach this 'struct acpi_device' to the ACPI object.  This makes
+	 * resolutions from handle->device very efficient.  Note that we need
+	 * to be careful with fixed-feature devices as they all attach to the
+	 * root object.
+	 */
+	switch (type) {
+	case ACPI_BUS_TYPE_POWER_BUTTON:
+	case ACPI_BUS_TYPE_SLEEP_BUTTON:
+		break;
+	default:
+		status = acpi_attach_data(device->handle,
+			acpi_bus_data_handler, device);
+		break;
+	}
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error attaching device data\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Linkage
+	 * -------
+	 * Link this device to its parent and siblings.
+	 */
+	INIT_LIST_HEAD(&device->children);
+	if (!device->parent)
+		INIT_LIST_HEAD(&device->node);
+	else
+		list_add_tail(&device->node, &device->parent->children);
+
+#ifdef CONFIG_ACPI_DEBUG
+	{
+		char		*type_string = NULL;
+		char		name[80] = {'?','\0'};
+		acpi_buffer	buffer = {sizeof(name), name};
+
+		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+		switch (type) {
+		case ACPI_BUS_TYPE_DEVICE:
+			type_string = "Device";
+			break;
+		case ACPI_BUS_TYPE_POWER:
+			type_string = "Power Resource";
+			break;
+		case ACPI_BUS_TYPE_PROCESSOR:
+			type_string = "Processor";
+			break;
+		case ACPI_BUS_TYPE_SYSTEM:
+			type_string = "System";
+			break;
+		case ACPI_BUS_TYPE_THERMAL:
+			type_string = "Thermal Zone";
+			break;
+		case ACPI_BUS_TYPE_POWER_BUTTON:
+			type_string = "Power Button";
+			sprintf(name, "PWRB");
+			break;
+		case ACPI_BUS_TYPE_SLEEP_BUTTON:
+			type_string = "Sleep Button";
+			sprintf(name, "SLPB");
+			break;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s %s [%p]\n", 
+			type_string, name, handle));
+	}
+#endif /*CONFIG_ACPI_DEBUG*/
+
+	/*
+	 * Global Device Hierarchy:
+	 * ------------------------
+	 * Register this device with the global device hierarchy.
+	 */
+	acpi_device_register(device, parent);
+
+	/*
+	 * Bind _ADR-Based Devices
+	 * -----------------------
+	 * If there's a a bus address (_ADR) then we utilize the parent's 
+	 * 'bind' function (if exists) to bind the ACPI- and natively-
+	 * enumerated device representations.
+	 */
+	if (device->flags.bus_address) {
+		if (device->parent && device->parent->ops.bind)
+			device->parent->ops.bind(device);
+	}
+
+	/*
+	 * Locate & Attach Driver
+	 * ----------------------
+	 * If there's a hardware id (_HID) or compatible ids (_CID) we check
+	 * to see if there's a driver installed for this kind of device.  Note
+	 * that drivers can install before or after a device in enumerated.
+	 *
+	 * TBD: Assumes LDM provides driver hot-plug capability.
+	 */
+	if (device->flags.hardware_id || device->flags.compatible_ids)
+		acpi_bus_find_driver(device);
+
+end:
+	if (0 != result) {
+		kfree(device);
+		return_VALUE(result);
+	}
+
+	*child = device;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_remove (
+	struct acpi_device	*device, 
+	int			type)
+{
+	ACPI_FUNCTION_TRACE("acpi_bus_remove");
+
+	if (!device)
+		return_VALUE(-ENODEV);
+
+	acpi_device_unregister(device);
+
+	kfree(device);
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_bus_scan (
+	struct acpi_device	*start)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_device	*parent = NULL;
+	struct acpi_device	*child = NULL;
+	acpi_handle		phandle = 0;
+	acpi_handle		chandle = 0;
+	acpi_object_type	type = 0;
+	u32			level = 1;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_scan");
+
+	if (!start)
+		return_VALUE(-EINVAL);
+
+	parent = start;
+	phandle = start->handle;
+	
+	/*
+	 * Parse through the ACPI namespace, identify all 'devices', and
+	 * create a new 'struct acpi_device' for each.
+	 */
+	while ((level > 0) && parent) {
+
+		status = acpi_get_next_object(ACPI_TYPE_ANY, phandle,
+			chandle, &chandle);
+
+		/*
+		 * If this scope is exhausted then move our way back up.
+		 */
+		if (ACPI_FAILURE(status)) {
+			level--;
+			chandle = phandle;
+			acpi_get_parent(phandle, &phandle);
+			if (parent->parent)
+				parent = parent->parent;
+			continue;
+		}
+
+		status = acpi_get_type(chandle, &type);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		/*
+		 * If this is a scope object then parse it (depth-first).
+		 */
+		if (type == ACPI_TYPE_ANY) {
+			/* Hack to get around scope identity problem */
+			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle, 0, NULL);
+			if (ACPI_SUCCESS(status)) {
+				level++;
+				phandle = chandle;
+				chandle = 0;
+			}
+			continue;
+		}
+
+		/*
+		 * We're only interested in objects that we consider 'devices'.
+		 */
+		switch (type) {
+		case ACPI_TYPE_DEVICE:
+			type = ACPI_BUS_TYPE_DEVICE;
+			break;
+		case ACPI_TYPE_PROCESSOR:
+			type = ACPI_BUS_TYPE_PROCESSOR;
+			break;
+		case ACPI_TYPE_THERMAL:
+			type = ACPI_BUS_TYPE_THERMAL;
+			break;
+		case ACPI_TYPE_POWER:
+			type = ACPI_BUS_TYPE_POWER;
+			break;
+		default:
+			continue;
+		}
+
+		status = acpi_bus_add(&child, parent, chandle, type);
+		if (ACPI_FAILURE(status))
+			continue;
+
+		/*
+		 * If the device is present, enabled, and functioning then
+		 * parse its scope (depth-first).  Note that we need to
+		 * represent absent devices to facilitate PnP notifications
+		 * -- but only the subtree head (not all of its children,
+		 * which will be enumerated when the parent is inserted).
+		 *
+		 * TBD: Need notifications and other detection mechanisms
+		 *	in place before we can fully implement this.
+		 */
+		if (child->status.present) {
+			status = acpi_get_next_object(ACPI_TYPE_ANY, chandle,
+				0, NULL);
+			if (ACPI_SUCCESS(status)) {
+				level++;
+				phandle = chandle;
+				chandle = 0;
+				parent = child;
+			}
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_bus_scan_fixed (
+	struct acpi_device	*root)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_scan");
+
+	if (!root)
+		return_VALUE(-ENODEV);
+
+	/*
+	 * Enumerate all fixed-feature devices.
+	 */
+	if (acpi_fadt.pwr_button == 0)
+		result = acpi_bus_add(&device, acpi_root, 
+			ACPI_ROOT_OBJECT, ACPI_BUS_TYPE_POWER_BUTTON);
+
+	if (acpi_fadt.sleep_button == 0)
+		result = acpi_bus_add(&device, acpi_root, 
+			ACPI_ROOT_OBJECT, ACPI_BUS_TYPE_SLEEP_BUTTON);
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                             Initialization/Cleanup
+   -------------------------------------------------------------------------- */
+
+int __init
+acpi_blacklisted(void)
+{
+	int i = 0;
+	int blacklisted = 0;
+	acpi_table_header table_header;
+
+	while (acpi_blacklist[i].oem_id[0] != '\0')
+	{
+		if (!ACPI_SUCCESS(acpi_get_table_header(acpi_blacklist[i].table, 1, &table_header))) {
+			i++;
+			continue;
+		}
+
+		if (strncmp(acpi_blacklist[i].oem_id, table_header.oem_id, 6)) {
+			i++;
+			continue;
+		}
+
+		if (strncmp(acpi_blacklist[i].oem_table_id, table_header.oem_table_id, 8)) {
+			i++;
+			continue;
+		}
+
+		if ((acpi_blacklist[i].oem_revision_predicate == all_versions)
+		    || (acpi_blacklist[i].oem_revision_predicate == less_than_or_equal
+		        && table_header.oem_revision <= acpi_blacklist[i].oem_revision)
+		    || (acpi_blacklist[i].oem_revision_predicate == greater_than_or_equal
+		        && table_header.oem_revision >= acpi_blacklist[i].oem_revision)
+		    || (acpi_blacklist[i].oem_revision_predicate == equal
+		        && table_header.oem_revision == acpi_blacklist[i].oem_revision)) {
+
+			printk(KERN_ERR PREFIX "Vendor \"%6.6s\" System \"%8.8s\" "
+				"Revision 0x%x has a known ACPI BIOS problem.\n",
+				acpi_blacklist[i].oem_id,
+				acpi_blacklist[i].oem_table_id,
+				acpi_blacklist[i].oem_revision);
+
+			printk(KERN_ERR PREFIX "Reason: %s. This is a %s error\n",
+				acpi_blacklist[i].reason,
+				(acpi_blacklist[i].is_critical_error ? "non-recoverable" : "recoverable"));
+
+			blacklisted = acpi_blacklist[i].is_critical_error;
+			break;
+		}
+		else {
+			i++;
+		}
+	}
+
+	return blacklisted;
+}
+
+static int __init
+acpi_bus_init_irq (void)
+{
+	acpi_status		status = AE_OK;
+	acpi_object		arg = {ACPI_TYPE_INTEGER};
+	acpi_object_list        arg_list = {1, &arg};
+	char			*message = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_init_irq");
+
+	/* 
+	 * Let the system know what interrupt model we are using by
+	 * evaluating the \_PIC object, if exists.
+	 */
+
+	switch (acpi_irq_model) {
+	case ACPI_IRQ_MODEL_PIC:
+		message = "PIC";
+		break;
+	case ACPI_IRQ_MODEL_IOAPIC:
+		message = "IOAPIC";
+		break;
+	case ACPI_IRQ_MODEL_IOSAPIC:
+		message = "IOSAPIC";
+		break;
+	default:
+		printk(KERN_WARNING PREFIX "Unknown interrupt routing model\n");
+		return_VALUE(-ENODEV);
+	}
+
+	printk(KERN_INFO PREFIX "Using %s for interrupt routing\n", message);
+
+	arg.integer.value = acpi_irq_model;
+
+	status = acpi_evaluate_object(NULL, "\\_PIC", &arg_list, NULL);
+	if (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PIC\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_bus_init (void)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_buffer		buffer = {sizeof(acpi_fadt), &acpi_fadt};
+	int			progress = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_init");
+
+	/*
+	 * [0] Initailize the ACPI Core Subsystem.
+	 */
+	status = acpi_initialize_subsystem();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to initialize the ACPI Interpreter\n");
+		result = -ENODEV;
+		goto end;
+	}
+
+	progress++;
+
+	/*
+	 * [1] Load the ACPI tables.
+	 */
+	status = acpi_load_tables();
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to load the System Description Tables\n");
+		result = -ENODEV;
+		goto end;
+	}
+
+	progress++;
+
+	/*
+	 * [2] Check the blacklist
+	 */
+	if (acpi_blacklisted()) {
+		result = -ENODEV;
+		goto end;
+	}
+
+	progress++;
+
+	/*
+	 * [3] Get a separate copy of the FADT for use by other drivers.
+	 */
+	status = acpi_get_table(ACPI_TABLE_FADT, 1, &buffer);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to get the FADT\n");
+		result = -ENODEV;
+		goto end;
+	}
+
+	progress++;
+
+	/*
+	 * [4] Enable the ACPI Core Subsystem.
+	 */
+	status = acpi_enable_subsystem(ACPI_FULL_INITIALIZATION);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to start the ACPI Interpreter\n");
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "Interpreter enabled\n");
+
+	progress++;
+
+	/*
+	 * [5] Get the system interrupt model and evaluate \_PIC.
+	 */
+	result = acpi_bus_init_irq();
+	if (0 != result)
+		goto end;
+
+	progress++;
+
+	/*
+	 * [6] Register for all standard device notifications.
+	 */
+	status = acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY, &acpi_bus_notify, NULL);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PREFIX "Unable to register for device notifications\n");
+		result = -ENODEV;
+		goto end;
+	}
+
+	progress++;
+
+	/*
+	 * [7] Create the root device.
+	 */
+	result = acpi_bus_add(&acpi_root, NULL, ACPI_ROOT_OBJECT, 
+		ACPI_BUS_TYPE_SYSTEM);
+	if (0 != result)
+		goto end;
+
+	progress++;
+
+	/*
+	 * [8] Create the root file system.
+	 */
+	acpi_device_dir(acpi_root) = proc_mkdir(ACPI_BUS_FILE_ROOT, NULL);
+	if (!acpi_root) {
+		result = -ENODEV;
+		goto end;
+	}
+	acpi_root_dir = acpi_device_dir(acpi_root);
+
+	progress++;
+
+	/*
+	 * [9] Install drivers required for proper enumeration of the
+	 *     ACPI namespace.
+	 */
+	acpi_system_init();	/* ACPI System */
+	acpi_power_init();	/* ACPI Bus Power Management */
+#ifdef CONFIG_ACPI_EC
+	acpi_ec_init();		/* ACPI Embedded Controller */
+#endif
+#ifdef CONFIG_ACPI_PCI
+	acpi_pci_link_init();	/* ACPI PCI Interrupt Link */
+	acpi_pci_root_init();	/* ACPI PCI Root Bridge */
+#endif
+	progress++;
+
+	/*
+	 * [10] Enumerate devices in the ACPI namespace.
+	 */
+	result = acpi_bus_scan_fixed(acpi_root);
+	if (0 != result)
+		goto end;
+	result = acpi_bus_scan(acpi_root);
+	if (0 != result)
+		goto end;
+
+end:
+	/*
+	 * Clean up if anything went awry.
+	 */
+	if (0 != result) {
+		switch (progress) {
+		case 10:
+		case 9: remove_proc_entry("ACPI", NULL);
+		case 8: acpi_bus_remove(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
+		case 7: acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
+				ACPI_SYSTEM_NOTIFY, &acpi_bus_notify);
+		case 6:
+		case 5:
+		case 4:
+		case 3:
+		case 2: acpi_terminate();
+		case 1:
+		case 0:
+		default: return_VALUE(-ENODEV);
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_bus_exit (void)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_bus_exit");
+
+	status = acpi_remove_notify_handler(ACPI_ROOT_OBJECT,
+		ACPI_SYSTEM_NOTIFY, acpi_bus_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+#ifdef CONFIG_ACPI_PCI
+	acpi_pci_root_exit();
+	acpi_pci_link_exit();
+#endif
+#ifdef CONFIG_ACPI_EC
+	acpi_ec_exit();
+#endif
+	acpi_power_exit();
+	acpi_system_exit();
+
+	acpi_bus_remove(acpi_root, ACPI_BUS_REMOVAL_NORMAL);
+
+	remove_proc_entry(ACPI_BUS_FILE_ROOT, NULL);
+
+	status = acpi_terminate();
+	if (ACPI_FAILURE(status))
+		printk(KERN_ERR PREFIX "Unable to terminate the ACPI Interpreter\n");
+	else
+		printk(KERN_ERR PREFIX "Interpreter disabled\n");
+
+	return_VOID;
+}
+
+
+int __init
+acpi_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_init");
+	acpi_dbg_level = NORMAL_DEFAULT;
+
+	memset(&acpi_fadt, 0, sizeof(FADT_DESCRIPTOR));
+
+	printk(KERN_INFO PREFIX "Subsystem revision %08x\n",
+		ACPI_CA_VERSION);
+
+	/* Initial core debug level excludes drivers, so include them now */
+	acpi_set_debug(ACPI_DEBUG_LOW);
+
+	if (acpi_disabled) {
+		printk(KERN_INFO PREFIX "Disabled via command line (acpi=off)\n");
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_PM
+	if (PM_IS_ACTIVE()) {
+		printk(KERN_INFO PREFIX "APM is already active, exiting\n");
+		return -ENODEV;
+	}
+#endif
+
+	result = acpi_bus_init();
+	if (0 != result)
+		return_VALUE(result);
+
+#ifdef CONFIG_PM
+	pm_active = 1;
+#endif
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_exit");
+
+#ifdef CONFIG_PM
+	pm_active = 0;
+#endif
+
+	acpi_bus_exit();
+
+	return_VOID;
+}
+
+
+int __init
+acpi_setup(char *str)
+{
+	while (str && *str) {
+		if (strncmp(str, "off", 3) == 0)
+			acpi_disabled = 1;
+		str = strchr(str, ',');
+		if (str)
+			str += strspn(str, ", \t");
+	}
+	return 1;
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+subsys_initcall(acpi_init);
+#endif
+
+__setup("acpi=", acpi_setup);
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/button.c linux/drivers/acpi/button.c
--- ../prev/linux/drivers/acpi/button.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/button.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,420 @@
+/*
+ *  acpi_button.c - ACPI Button Driver ($Revision: 25 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_BUTTON_COMPONENT
+ACPI_MODULE_NAME		("acpi_button")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_BUTTON_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+int acpi_button_add (struct acpi_device *device);
+int acpi_button_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_button_driver = {
+	name:			ACPI_BUTTON_DRIVER_NAME,
+	class:			ACPI_BUTTON_CLASS,
+	ids:			"ACPI_FPB,ACPI_FSB,PNP0C0D,PNP0C0C,PNP0C0E",
+	ops:			{
+					add:	acpi_button_add,
+					remove:	acpi_button_remove,
+				},
+};
+
+struct acpi_button {
+	acpi_handle		handle;
+	struct acpi_device	*device;	/* Fixed button kludge */
+	u8			type;
+	unsigned long		pushed;
+};
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+static struct proc_dir_entry	*acpi_button_dir = NULL;
+
+
+static int
+acpi_button_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_button	*button = (struct acpi_button *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_button_read_info");
+
+	if (!button || !button->device)
+		goto end;
+
+	p += sprintf(p, "type:                    %s\n", 
+		acpi_device_name(button->device));
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_button_add_fs (
+	struct acpi_device	*device)
+{
+	static struct proc_dir_entry *power_entry;
+	static struct proc_dir_entry *sleep_entry;
+	static struct proc_dir_entry *lid_entry;
+	struct proc_dir_entry	*entry = NULL;
+	struct acpi_button	*button = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_button_add_fs");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	button = acpi_driver_data(device);
+
+	if (!acpi_button_dir) {
+		acpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);
+		if (!acpi_button_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	switch (button->type) {
+	case ACPI_BUTTON_TYPE_POWER:
+	case ACPI_BUTTON_TYPE_POWERF:
+		if (!power_entry)
+			power_entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_POWER, 
+				acpi_button_dir);
+			entry = power_entry;
+		break;
+	case ACPI_BUTTON_TYPE_SLEEP:
+	case ACPI_BUTTON_TYPE_SLEEPF:
+		if (!sleep_entry)
+			sleep_entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_SLEEP, 
+				acpi_button_dir);
+			entry = sleep_entry;
+		break;
+	case ACPI_BUTTON_TYPE_LID:
+		if (!lid_entry)
+			lid_entry = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, 
+				acpi_button_dir);
+			entry = lid_entry;
+		break;
+	}
+
+	acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), entry);
+	if (!acpi_device_dir(device))
+		return_VALUE(-ENODEV);
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_BUTTON_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_BUTTON_FILE_INFO));
+	else {
+		entry->read_proc = acpi_button_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_button_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_button_remove_fs");
+
+	if (!acpi_button_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_button_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Driver Interface
+   -------------------------------------------------------------------------- */
+
+void
+acpi_button_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	struct acpi_button	*button = (struct acpi_button *) data;
+
+	ACPI_FUNCTION_TRACE("acpi_button_notify");
+
+	if (!button || !button->device)
+		return_VOID;
+
+	switch (event) {
+	case ACPI_BUTTON_NOTIFY_STATUS:
+		acpi_bus_generate_event(button->device, event, ++button->pushed);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+acpi_status
+acpi_button_notify_fixed (
+	void			*data)
+{
+	struct acpi_button	*button = (struct acpi_button *) data;
+	
+	ACPI_FUNCTION_TRACE("acpi_button_notify_fixed");
+
+	if (!button)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	acpi_button_notify(button->handle, ACPI_BUTTON_NOTIFY_STATUS, button);
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+int
+acpi_button_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_button	*button = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_button_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	button = kmalloc(sizeof(struct acpi_button), GFP_KERNEL);
+	if (!button)
+		return_VALUE(-ENOMEM);
+	memset(button, 0, sizeof(struct acpi_button));
+
+	button->device = device;
+	button->handle = device->handle;
+	acpi_driver_data(device) = button;
+
+	/*
+	 * Determine the button type (via hid), as fixed-feature buttons
+	 * need to be handled a bit differently than generic-space.
+	 */
+	if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWER)) {
+		button->type = ACPI_BUTTON_TYPE_POWER;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_POWER);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_POWERF)) {
+		button->type = ACPI_BUTTON_TYPE_POWERF;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_POWERF);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEP)) {
+		button->type = ACPI_BUTTON_TYPE_SLEEP;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_SLEEP);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_SLEEPF)) {
+		button->type = ACPI_BUTTON_TYPE_SLEEPF;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_SLEEPF);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);
+	}
+	else if (!strcmp(acpi_device_hid(device), ACPI_BUTTON_HID_LID)) {
+		button->type = ACPI_BUTTON_TYPE_LID;
+		sprintf(acpi_device_name(device), "%s",
+			ACPI_BUTTON_DEVICE_NAME_LID);
+		sprintf(acpi_device_class(device), "%s/%s", 
+			ACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_LID);
+	}
+	else {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unsupported hid [%s]\n",
+			acpi_device_hid(device)));
+		result = -ENODEV;
+		goto end;
+	}
+
+	result = acpi_button_add_fs(device);
+	if (0 != result)
+		goto end;
+
+	switch (button->type) {
+	case ACPI_BUTTON_TYPE_POWERF:
+		status = acpi_install_fixed_event_handler (
+			ACPI_EVENT_POWER_BUTTON,
+			acpi_button_notify_fixed,
+			button);
+		break;
+	case ACPI_BUTTON_TYPE_SLEEPF:
+		status = acpi_install_fixed_event_handler (
+			ACPI_EVENT_SLEEP_BUTTON,
+			acpi_button_notify_fixed,
+			button);
+		break;
+	default:
+		status = acpi_install_notify_handler (
+			button->handle,
+			ACPI_DEVICE_NOTIFY,
+			acpi_button_notify,
+			button);
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s [%s]\n", 
+		acpi_device_name(device), acpi_device_bid(device));
+
+end:
+	if (0 != result) {
+		acpi_button_remove_fs(device);
+		kfree(button);
+	}
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_button_remove (struct acpi_device *device, int type)
+{
+	acpi_status		status = 0;
+	struct acpi_button	*button = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_button_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	button = acpi_driver_data(device);
+
+	/* Unregister for device notifications. */
+	switch (button->type) {
+	case ACPI_BUTTON_TYPE_POWERF:
+		status = acpi_remove_fixed_event_handler(
+			ACPI_EVENT_POWER_BUTTON, acpi_button_notify_fixed);
+		break;
+	case ACPI_BUTTON_TYPE_SLEEPF:
+		status = acpi_remove_fixed_event_handler(
+			ACPI_EVENT_SLEEP_BUTTON, acpi_button_notify_fixed);
+		break;
+	default:
+		status = acpi_remove_notify_handler(button->handle,
+			ACPI_DEVICE_NOTIFY, acpi_button_notify);
+		break;
+	}
+
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	acpi_button_remove_fs(device);	
+
+	kfree(button);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_button_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_button_init");
+
+	result = acpi_bus_register_driver(&acpi_button_driver);
+	if (0 > result)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_button_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_button_exit");
+
+	acpi_bus_unregister_driver(&acpi_button_driver);
+
+	return_VOID;
+}
+
+
+module_init(acpi_button_init);
+module_exit(acpi_button_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbcmds.c linux/drivers/acpi/debugger/dbcmds.c
--- ../prev/linux/drivers/acpi/debugger/dbcmds.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbcmds.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbcmds - debug commands and output routines
- *              $Revision: 79 $
+ *              $Revision: 83 $
  *
  ******************************************************************************/
 
@@ -25,15 +25,11 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "acdispat.h"
 #include "amlcode.h"
 #include "acnamesp.h"
-#include "acparser.h"
 #include "acevents.h"
-#include "acinterp.h"
 #include "acdebug.h"
-#include "actables.h"
 #include "acresrc.h"
 
 #ifdef ENABLE_DEBUGGER
@@ -47,7 +43,7 @@
  * These object types map directly to the ACPI_TYPES
  */
 
-ARGUMENT_INFO         acpi_db_object_types [] =
+static ARGUMENT_INFO        acpi_db_object_types [] =
 { {"ANY"},
 	{"NUMBERS"},
 	{"STRINGS"},
@@ -97,13 +93,13 @@
 	/* Check for match against the namespace node itself */
 
 	if (node == (void *) obj_desc) {
-		acpi_os_printf ("Object is a Node [%4.4s]\n", &node->name);
+		acpi_os_printf ("Object is a Node [%4.4s]\n", node->name.ascii);
 	}
 
 	/* Check for match against the object attached to the node */
 
 	if (acpi_ns_get_attached_object (node) == obj_desc) {
-		acpi_os_printf ("Reference at Node->Object %p [%4.4s]\n", node, &node->name);
+		acpi_os_printf ("Reference at Node->Object %p [%4.4s]\n", node, node->name.ascii);
 	}
 
 	return (AE_OK);
@@ -135,7 +131,7 @@
 
 	/* Search all nodes in namespace */
 
-	acpi_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+	(void) acpi_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
 			  acpi_db_walk_for_references, (void *) obj_desc, NULL);
 }
 
@@ -275,8 +271,8 @@
 	/* Get and verify the breakpoint address */
 
 	address = ACPI_STRTOUL (location, NULL, 16);
-	if (address <= op->aml_offset) {
-		acpi_os_printf ("Breakpoint %X is beyond current address %X\n", address, op->aml_offset);
+	if (address <= op->common.aml_offset) {
+		acpi_os_printf ("Breakpoint %X is beyond current address %X\n", address, op->common.aml_offset);
 	}
 
 	/* Save breakpoint in current walk */
@@ -482,6 +478,7 @@
 	u32                     value)
 {
 	acpi_namespace_node     *node;
+	acpi_status             status;
 
 
 	/* Translate name to an Named object */
@@ -499,7 +496,10 @@
 
 		 /* Send the notify */
 
-		acpi_ev_queue_notify_request (node, value);
+		status = acpi_ev_queue_notify_request (node, value);
+		if (ACPI_FAILURE (status)) {
+			acpi_os_printf ("Could not queue notify\n");
+		}
 		break;
 
 	default:
@@ -536,6 +536,7 @@
 	u32                     value;
 	acpi_walk_state         *walk_state;
 	acpi_operand_object     *obj_desc;
+	acpi_status             status;
 
 
 	/* Validate Type_arg */
@@ -578,12 +579,16 @@
 
 		/* Set a method argument */
 
-		if (index > MTH_NUM_ARGS) {
+		if (index > MTH_MAX_ARG) {
 			acpi_os_printf ("Arg%d - Invalid argument name\n", index);
 			return;
 		}
 
-		acpi_ds_store_object_to_local (AML_ARG_OP, index, obj_desc, walk_state);
+		status = acpi_ds_store_object_to_local (AML_ARG_OP, index, obj_desc, walk_state);
+		if (ACPI_FAILURE (status)) {
+			return;
+		}
+
 		obj_desc = walk_state->arguments[index].object;
 
 		acpi_os_printf ("Arg%d: ", index);
@@ -594,12 +599,16 @@
 
 		/* Set a method local */
 
-		if (index > MTH_NUM_LOCALS) {
+		if (index > MTH_MAX_LOCAL) {
 			acpi_os_printf ("Local%d - Invalid local variable name\n", index);
 			return;
 		}
 
-		acpi_ds_store_object_to_local (AML_LOCAL_OP, index, obj_desc, walk_state);
+		status = acpi_ds_store_object_to_local (AML_LOCAL_OP, index, obj_desc, walk_state);
+		if (ACPI_FAILURE (status)) {
+			return;
+		}
+
 		obj_desc = walk_state->local_variables[index].object;
 
 		acpi_os_printf ("Local%d: ", index);
@@ -678,6 +687,10 @@
 		case ACPI_TYPE_BUFFER:
 			acpi_os_printf (" Length %X", obj_desc->buffer.length);
 			break;
+
+		default:
+			/* Ignore other object types */
+			break;
 		}
 	}
 
@@ -722,7 +735,7 @@
 
 	/* Walk the namespace from the root */
 
-	acpi_walk_namespace (type, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+	(void) acpi_walk_namespace (type, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
 			   acpi_db_walk_for_specific_objects, (void *) &type, NULL);
 
 	acpi_db_set_output_destination (ACPI_DB_CONSOLE_OUTPUT);
@@ -762,7 +775,7 @@
 		/* Wildcard support */
 
 		if ((requested_name[i] != '?') &&
-			(requested_name[i] != ((NATIVE_CHAR *) (&((acpi_namespace_node *) obj_handle)->name))[i])) {
+			(requested_name[i] != ((acpi_namespace_node *) obj_handle)->name.ascii[i])) {
 			/* No match, just exit */
 
 			return (AE_OK);
@@ -812,7 +825,7 @@
 
 	/* Walk the namespace from the root */
 
-	acpi_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+	(void) acpi_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
 			   acpi_db_walk_and_match_name, name_arg, NULL);
 
 	acpi_db_set_output_destination (ACPI_DB_CONSOLE_OUTPUT);
@@ -899,7 +912,8 @@
 acpi_db_display_resources (
 	NATIVE_CHAR             *object_arg)
 {
-#ifndef _IA16
+#if ACPI_MACHINE_WIDTH != 16
+
 	acpi_operand_object     *obj_desc;
 	acpi_status             status;
 	acpi_buffer             return_obj;
@@ -964,7 +978,7 @@
 	}
 
 	else {
-		acpi_rs_dump_resource_list ((acpi_resource *) acpi_gbl_db_buffer);
+		acpi_rs_dump_resource_list (ACPI_CAST_PTR (acpi_resource, acpi_gbl_db_buffer));
 	}
 
 	status = acpi_set_current_resources (obj_desc, &return_obj);
@@ -997,7 +1011,7 @@
 	}
 
 	else {
-		acpi_rs_dump_resource_list ((acpi_resource *) acpi_gbl_db_buffer);
+		acpi_rs_dump_resource_list (ACPI_CAST_PTR (acpi_resource, acpi_gbl_db_buffer));
 	}
 
 
@@ -1009,5 +1023,90 @@
 
 }
 
+
+typedef struct
+{
+	u32                 nodes;
+	u32                 objects;
+} ACPI_INTEGRITY_INFO;
+
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_db_integrity_walk
+ *
+ * PARAMETERS:  Callback from Walk_namespace
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Examine one NS node for valid values.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_db_integrity_walk (
+	acpi_handle             obj_handle,
+	u32                     nesting_level,
+	void                    *context,
+	void                    **return_value)
+{
+	ACPI_INTEGRITY_INFO     *info = (ACPI_INTEGRITY_INFO *) context;
+	acpi_namespace_node     *node = (acpi_namespace_node *) obj_handle;
+	acpi_operand_object     *object;
+
+
+	info->nodes++;
+	if (ACPI_GET_DESCRIPTOR_TYPE (node) != ACPI_DESC_TYPE_NAMED) {
+		acpi_os_printf ("Invalid Descriptor Type for Node %p, Type = %X\n",
+			node, ACPI_GET_DESCRIPTOR_TYPE (node));
+	}
+
+	if (node->type > INTERNAL_TYPE_MAX) {
+		acpi_os_printf ("Invalid Object Type for Node %p, Type = %X\n",
+			node, node->type);
+	}
+
+	if (!acpi_ut_valid_acpi_name (node->name.integer)) {
+		acpi_os_printf ("Invalid Acpi_name for Node %p\n", node);
+	}
+
+	object = acpi_ns_get_attached_object (node);
+	if (object) {
+		info->objects++;
+		if (ACPI_GET_DESCRIPTOR_TYPE (object) != ACPI_DESC_TYPE_OPERAND) {
+			acpi_os_printf ("Invalid Descriptor Type for Object %p, Type = %X\n",
+				object, ACPI_GET_DESCRIPTOR_TYPE (object));
+		}
+	}
+
+
+	return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_db_check_integrity
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check entire namespace for data structure integrity
+ *
+ ******************************************************************************/
+
+void
+acpi_db_check_integrity (void)
+{
+	ACPI_INTEGRITY_INFO     info = {0,0};
+
+	/* Search all nodes in namespace */
+
+	(void) acpi_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+			  acpi_db_integrity_walk, (void *) &info, NULL);
+
+	acpi_os_printf ("Verified %d namespace nodes with %d Objects\n", info.nodes, info.objects);
+
+}
 
 #endif /* ENABLE_DEBUGGER */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbdisasm.c linux/drivers/acpi/debugger/dbdisasm.c
--- ../prev/linux/drivers/acpi/debugger/dbdisasm.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbdisasm.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbdisasm - parser op tree display routines
- *              $Revision: 61 $
+ *              $Revision: 66 $
  *
  ******************************************************************************/
 
@@ -40,7 +40,7 @@
 #define BLOCK_PAREN         1
 #define BLOCK_BRACE         2
 #define DB_NO_OP_INFO       "            [%2.2d]  "
-#define DB_FULL_OP_INFO     "%5.5X #%4.4X [%2.2d]  "
+#define DB_FULL_OP_INFO     "%5.5X #%4.4hX [%2.2d]  "
 
 
 NATIVE_CHAR                 *acpi_gbl_db_disasm_indent = "....";
@@ -63,7 +63,7 @@
 	acpi_parse_object       *op)
 {
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_METHOD_OP:
 		return (BLOCK_BRACE);
 
@@ -101,15 +101,15 @@
 	char                    *name;
 
 
-	if (op->flags & ACPI_PARSEOP_GENERIC) {
-		name = op->value.name;
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
+		name = op->common.value.name;
 		if (name[0] == '\\') {
 			acpi_os_printf (" (Fully Qualified Pathname)");
 			return (AE_OK);
 		}
 	}
 	else {
-		name = (char *) &((acpi_parse2_object *) op)->name;
+		name = (char *) &op->named.name;
 	}
 
 	/* Search parent tree up to the root if necessary */
@@ -155,11 +155,11 @@
 
 	/* Just get the Node out of the Op object */
 
-	node = op->node;
+	node = op->common.node;
 	if (!node) {
 		/* Node not defined in this scope, look it up */
 
-		status = acpi_ns_lookup (walk_state->scope_info, op->value.string, ACPI_TYPE_ANY,
+		status = acpi_ns_lookup (walk_state->scope_info, op->common.value.string, ACPI_TYPE_ANY,
 				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
 
 		if (ACPI_FAILURE (status)) {
@@ -174,7 +174,7 @@
 
 		/* Save it for next time. */
 
-		op->node = node;
+		op->common.node = node;
 	}
 
 	/* Convert Named_desc/handle to a full pathname */
@@ -244,10 +244,10 @@
 
 		/* Determine the nesting depth of this argument */
 
-		for (depth = op->parent; depth; depth = depth->parent) {
+		for (depth = op->common.parent; depth; depth = depth->common.parent) {
 			arg = acpi_ps_get_arg (depth, 0);
 			while (arg && arg != origin) {
-				arg = arg->next;
+				arg = arg->common.next;
 			}
 
 			if (arg) {
@@ -276,9 +276,9 @@
 		/* Close a block if we are nested less than last time */
 
 		else if (depth_count < last_depth) {
-			for (j = 0; j < (last_depth - depth_count); j++) {
-				VERBOSE_PRINT ((DB_NO_OP_INFO, last_depth - j));
-				for (i = 0; i < (last_depth - j - 1); i++) {
+			for (j = last_depth; j >= (depth_count + 1); j--) {
+				VERBOSE_PRINT ((DB_NO_OP_INFO, (j - 1)));
+				for (i = 1; i < j; i++) {
 					acpi_os_printf ("%s", acpi_gbl_db_disasm_indent);
 				}
 
@@ -293,7 +293,8 @@
 
 		/* In verbose mode, print the AML offset, opcode and depth count */
 
-		VERBOSE_PRINT ((DB_FULL_OP_INFO, (unsigned) op->aml_offset, op->opcode, depth_count));
+		VERBOSE_PRINT ((DB_FULL_OP_INFO, (u32) op->common.aml_offset,
+				op->common.aml_opcode, depth_count));
 
 
 		/* Indent the output according to the depth count */
@@ -308,10 +309,10 @@
 
 		/* Resolve a name reference */
 
-		if ((op->opcode == AML_INT_NAMEPATH_OP && op->value.name)  &&
-			(op->parent) &&
+		if ((op->common.aml_opcode == AML_INT_NAMEPATH_OP && op->common.value.name) &&
+			(op->common.parent) &&
 			(acpi_gbl_db_opt_verbose)) {
-			acpi_ps_display_object_pathname (walk_state, op);
+			(void) acpi_ps_display_object_pathname (walk_state, op);
 		}
 
 		acpi_os_printf ("\n");
@@ -438,7 +439,7 @@
 
 	/* We are only interested in named objects */
 
-	op_info = acpi_ps_get_opcode_info (op->opcode);
+	op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 	if (!(op_info->flags & AML_NSNODE)) {
 		return;
 	}
@@ -446,7 +447,7 @@
 	if (op_info->flags & AML_CREATE) {
 		/* Field creation - check for a fully qualified namepath */
 
-		if (op->opcode == AML_CREATE_FIELD_OP) {
+		if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
 			name_path = acpi_ps_get_arg (op, 3);
 		}
 		else {
@@ -454,9 +455,9 @@
 		}
 
 		if ((name_path) &&
-			(name_path->value.string) &&
-			(name_path->value.string[0] == '\\')) {
-			acpi_db_display_namestring (name_path->value.string);
+			(name_path->common.value.string) &&
+			(name_path->common.value.string[0] == '\\')) {
+			acpi_db_display_namestring (name_path->common.value.string);
 			return;
 		}
 	}
@@ -468,17 +469,17 @@
 
 		search = op;
 		for (; ;) {
-			if (search->parent == prev) {
+			if (search->common.parent == prev) {
 				break;
 			}
 
 			/* Go up one level */
 
-			search = search->parent;
+			search = search->common.parent;
 		}
 
 		if (prev) {
-			op_info = acpi_ps_get_opcode_info (search->opcode);
+			op_info = acpi_ps_get_opcode_info (search->common.aml_opcode);
 			if (!(op_info->flags & AML_FIELD)) {
 				/* below root scope, append scope name */
 
@@ -489,7 +490,7 @@
 				}
 
 				if (op_info->flags & AML_CREATE) {
-					if (op->opcode == AML_CREATE_FIELD_OP) {
+					if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
 						name_path = acpi_ps_get_arg (op, 3);
 					}
 					else {
@@ -497,8 +498,8 @@
 					}
 
 					if ((name_path) &&
-						(name_path->value.string)) {
-						acpi_os_printf ("%4.4s", name_path->value.string);
+						(name_path->common.value.string)) {
+						acpi_os_printf ("%4.4s", name_path->common.value.string);
 					}
 				}
 				else {
@@ -544,18 +545,19 @@
 
 	if (!op) {
 		acpi_os_printf ("<NULL OP PTR>");
+		return;
 	}
 
 	/* op and arguments */
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_BYTE_OP:
 
 		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u8) 0x%2.2X", op->value.integer8);
+			acpi_os_printf ("(u8) 0x%2.2hX", op->common.value.integer8);
 		}
 		else {
-			acpi_os_printf ("0x%2.2X", op->value.integer8);
+			acpi_os_printf ("0x%2.2hX", op->common.value.integer8);
 		}
 		break;
 
@@ -563,10 +565,10 @@
 	case AML_WORD_OP:
 
 		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u16) 0x%4.4X", op->value.integer16);
+			acpi_os_printf ("(u16) 0x%4.4hX", op->common.value.integer16);
 		}
 		else {
-			acpi_os_printf ("0x%4.4X", op->value.integer16);
+			acpi_os_printf ("0x%4.4hX", op->common.value.integer16);
 		}
 		break;
 
@@ -574,10 +576,10 @@
 	case AML_DWORD_OP:
 
 		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u32) 0x%8.8X", op->value.integer32);
+			acpi_os_printf ("(u32) 0x%8.8X", op->common.value.integer32);
 		}
 		else {
-			acpi_os_printf ("0x%8.8X", op->value.integer32);
+			acpi_os_printf ("0x%8.8X", op->common.value.integer32);
 		}
 		break;
 
@@ -585,20 +587,20 @@
 	case AML_QWORD_OP:
 
 		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("(u64) 0x%8.8X%8.8X", op->value.integer64.hi,
-					 op->value.integer64.lo);
+			acpi_os_printf ("(u64) 0x%8.8X%8.8X", op->common.value.integer64.hi,
+					 op->common.value.integer64.lo);
 		}
 		else {
-			acpi_os_printf ("0x%8.8X%8.8X", op->value.integer64.hi,
-					 op->value.integer64.lo);
+			acpi_os_printf ("0x%8.8X%8.8X", op->common.value.integer64.hi,
+					 op->common.value.integer64.lo);
 		}
 		break;
 
 
 	case AML_STRING_OP:
 
-		if (op->value.string) {
-			acpi_os_printf ("\"%s\"", op->value.string);
+		if (op->common.value.string) {
+			acpi_os_printf ("\"%s\"", op->common.value.string);
 		}
 		else {
 			acpi_os_printf ("<\"NULL STRING PTR\">");
@@ -608,8 +610,8 @@
 
 	case AML_INT_STATICSTRING_OP:
 
-		if (op->value.string) {
-			acpi_os_printf ("\"%s\"", op->value.string);
+		if (op->common.value.string) {
+			acpi_os_printf ("\"%s\"", op->common.value.string);
 		}
 		else {
 			acpi_os_printf ("\"<NULL STATIC STRING PTR>\"");
@@ -619,38 +621,38 @@
 
 	case AML_INT_NAMEPATH_OP:
 
-		acpi_db_display_namestring (op->value.name);
+		acpi_db_display_namestring (op->common.value.name);
 		break;
 
 
 	case AML_INT_NAMEDFIELD_OP:
 
-		acpi_os_printf ("Named_field (Length 0x%8.8X)  ", op->value.integer32);
+		acpi_os_printf ("Named_field (Length 0x%8.8X)  ", op->common.value.integer32);
 		break;
 
 
 	case AML_INT_RESERVEDFIELD_OP:
 
-		acpi_os_printf ("Reserved_field (Length 0x%8.8X) ", op->value.integer32);
+		acpi_os_printf ("Reserved_field (Length 0x%8.8X) ", op->common.value.integer32);
 		break;
 
 
 	case AML_INT_ACCESSFIELD_OP:
 
-		acpi_os_printf ("Access_field (Length 0x%8.8X) ", op->value.integer32);
+		acpi_os_printf ("Access_field (Length 0x%8.8X) ", op->common.value.integer32);
 		break;
 
 
 	case AML_INT_BYTELIST_OP:
 
 		if (acpi_gbl_db_opt_verbose) {
-			acpi_os_printf ("Byte_list   (Length 0x%8.8X)  ", op->value.integer32);
+			acpi_os_printf ("Byte_list   (Length 0x%8.8X)  ", op->common.value.integer32);
 		}
 		else {
-			acpi_os_printf ("0x%2.2X", op->value.integer32);
+			acpi_os_printf ("0x%2.2X", op->common.value.integer32);
 
-			byte_count = op->value.integer32;
-			byte_data = ((acpi_parse2_object *) op)->data;
+			byte_count = op->common.value.integer32;
+			byte_data = op->named.data;
 
 			for (i = 0; i < byte_count; i++) {
 				acpi_os_printf (", 0x%2.2X", byte_data[i]);
@@ -663,12 +665,13 @@
 
 		/* Just get the opcode name and print it */
 
-		op_info = acpi_ps_get_opcode_info (op->opcode);
+		op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 		acpi_os_printf ("%s", op_info->name);
 
 
 #ifndef PARSER_ONLY
-		if ((op->opcode == AML_INT_RETURN_VALUE_OP) &&
+		if ((op->common.aml_opcode == AML_INT_RETURN_VALUE_OP) &&
+			(walk_state) &&
 			(walk_state->results) &&
 			(walk_state->results->results.num_results)) {
 			acpi_db_decode_internal_object (walk_state->results->results.obj_desc [walk_state->results->results.num_results-1]);
@@ -680,7 +683,7 @@
 	if (!op_info) {
 		/* If there is another element in the list, add a comma */
 
-		if (op->next) {
+		if (op->common.next) {
 			acpi_os_printf (",");
 		}
 	}
@@ -688,13 +691,13 @@
 	/*
 	 * If this is a named opcode, print the associated name value
 	 */
-	op_info = acpi_ps_get_opcode_info (op->opcode);
+	op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 	if (op && (op_info->flags & AML_NAMED)) {
 		name = acpi_ps_get_name (op);
 		acpi_os_printf (" %4.4s", &name);
 
-		if ((acpi_gbl_db_opt_verbose) && (op->opcode != AML_INT_NAMEDFIELD_OP)) {
-			acpi_ps_display_object_pathname (walk_state, op);
+		if ((acpi_gbl_db_opt_verbose) && (op->common.aml_opcode != AML_INT_NAMEDFIELD_OP)) {
+			(void) acpi_ps_display_object_pathname (walk_state, op);
 		}
 	}
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbdisply.c linux/drivers/acpi/debugger/dbdisply.c
--- ../prev/linux/drivers/acpi/debugger/dbdisply.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbdisply.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbdisply - debug display commands
- *              $Revision: 67 $
+ *              $Revision: 73 $
  *
  ******************************************************************************/
 
@@ -25,12 +25,10 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "amlcode.h"
 #include "acdispat.h"
 #include "acnamesp.h"
 #include "acparser.h"
-#include "acevents.h"
 #include "acinterp.h"
 #include "acdebug.h"
 
@@ -61,7 +59,7 @@
 	void                    *obj_ptr;
 
 
-#ifdef _IA16
+#if ACPI_MACHINE_WIDTH == 16
 #include <stdio.h>
 
 	/* Have to handle 16-bit pointers of the form segment:offset */
@@ -101,16 +99,16 @@
 	const acpi_opcode_info  *info;
 
 
-	info = acpi_ps_get_opcode_info (op->opcode);
+	info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 
 	acpi_os_printf ("Parser Op Descriptor:\n");
-	acpi_os_printf ("%20.20s : %4.4X\n", "Opcode", op->opcode);
+	acpi_os_printf ("%20.20s : %4.4X\n", "Opcode", op->common.aml_opcode);
 
 	ACPI_DEBUG_ONLY_MEMBERS (acpi_os_printf ("%20.20s : %s\n", "Opcode Name", info->name));
 
-	acpi_os_printf ("%20.20s : %p\n", "Value/Arg_list", op->value);
-	acpi_os_printf ("%20.20s : %p\n", "Parent", op->parent);
-	acpi_os_printf ("%20.20s : %p\n", "Next_op", op->next);
+	acpi_os_printf ("%20.20s : %p\n", "Value/Arg_list", op->common.value.arg);
+	acpi_os_printf ("%20.20s : %p\n", "Parent", op->common.parent);
+	acpi_os_printf ("%20.20s : %p\n", "Next_op", op->common.next);
 }
 
 
@@ -190,7 +188,7 @@
 			goto dump_nte;
 
 
-		case ACPI_DESC_TYPE_INTERNAL:
+		case ACPI_DESC_TYPE_OPERAND:
 
 			/* This is a ACPI OPERAND OBJECT */
 
@@ -307,8 +305,8 @@
 	switch (obj_desc->common.type) {
 	case ACPI_TYPE_INTEGER:
 
-		acpi_os_printf (" %.8X%.8X", ACPI_HIDWORD (obj_desc->integer.value),
-				 ACPI_LODWORD (obj_desc->integer.value));
+		acpi_os_printf (" %8.8X%8.8X", ACPI_HIDWORD (obj_desc->integer.value),
+				   ACPI_LODWORD (obj_desc->integer.value));
 		break;
 
 
@@ -335,6 +333,11 @@
 			acpi_os_printf (" %2.2X", obj_desc->buffer.pointer[i]);
 		}
 		break;
+
+
+	default:
+		/* No additional display for other types */
+		break;
 	}
 }
 
@@ -379,7 +382,7 @@
 	case ACPI_DESC_TYPE_NAMED:
 
 		acpi_os_printf ("<Node>          Name %4.4s Type-%s",
-				  &((acpi_namespace_node *)obj_desc)->name,
+				  ((acpi_namespace_node *)obj_desc)->name.ascii,
 				  acpi_ut_get_type_name (((acpi_namespace_node *) obj_desc)->type));
 
 		if (((acpi_namespace_node *) obj_desc)->flags & ANOBJ_METHOD_ARG) {
@@ -391,11 +394,11 @@
 		break;
 
 
-	case ACPI_DESC_TYPE_INTERNAL:
+	case ACPI_DESC_TYPE_OPERAND:
 
 		type = obj_desc->common.type;
 		if (type > INTERNAL_TYPE_MAX) {
-			acpi_os_printf (" Type %x [Invalid Type]", type);
+			acpi_os_printf (" Type %hX [Invalid Type]", type);
 			return;
 		}
 
@@ -517,13 +520,13 @@
 	num_args    = obj_desc->method.param_count;
 	concurrency = obj_desc->method.concurrency;
 
-	acpi_os_printf ("Currently executing control method is [%4.4s]\n", &node->name);
+	acpi_os_printf ("Currently executing control method is [%4.4s]\n", node->name.ascii);
 	acpi_os_printf ("%X arguments, max concurrency = %X\n", num_args, concurrency);
 
 
 	root_op = start_op;
-	while (root_op->parent) {
-		root_op = root_op->parent;
+	while (root_op->common.parent) {
+		root_op = root_op->common.parent;
 	}
 
 	op = root_op;
@@ -540,7 +543,7 @@
 
 		/* Decode the opcode */
 
-		op_info = acpi_ps_get_opcode_info (op->opcode);
+		op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 		switch (op_info->class) {
 		case AML_CLASS_ARGUMENT:
 			if (count_remaining) {
@@ -604,7 +607,7 @@
 
 	obj_desc = walk_state->method_desc;
 	node = walk_state->method_node;
-	acpi_os_printf ("Local Variables for method [%4.4s]:\n", &node->name);
+	acpi_os_printf ("Local Variables for method [%4.4s]:\n", node->name.ascii);
 
 	for (i = 0; i < MTH_NUM_LOCALS; i++) {
 		obj_desc = walk_state->local_variables[i].object;
@@ -650,7 +653,7 @@
 	concurrency = obj_desc->method.concurrency;
 
 	acpi_os_printf ("Method [%4.4s] has %X arguments, max concurrency = %X\n",
-			&node->name, num_args, concurrency);
+			node->name.ascii, num_args, concurrency);
 
 	for (i = 0; i < num_args; i++) {
 		obj_desc = walk_state->arguments[i].object;
@@ -696,7 +699,7 @@
 	}
 
 	acpi_os_printf ("Method [%4.4s] has %X stacked result objects\n",
-		&node->name, num_results);
+		node->name.ascii, num_results);
 
 	for (i = 0; i < num_results; i++) {
 		obj_desc = walk_state->results->results.obj_desc[i];
@@ -721,7 +724,6 @@
 void
 acpi_db_display_calling_tree (void)
 {
-	u32                     i;
 	acpi_walk_state         *walk_state;
 	acpi_namespace_node     *node;
 
@@ -735,10 +737,10 @@
 	node = walk_state->method_node;
 	acpi_os_printf ("Current Control Method Call Tree\n");
 
-	for (i = 0; walk_state; i++) {
+	while (walk_state) {
 		node = walk_state->method_node;
 
-		acpi_os_printf ("  [%4.4s]\n", &node->name);
+		acpi_os_printf ("  [%4.4s]\n", node->name.ascii);
 
 		walk_state = walk_state->next;
 	}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbexec.c linux/drivers/acpi/debugger/dbexec.c
--- ../prev/linux/drivers/acpi/debugger/dbexec.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbexec.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbexec - debugger control method execution
- *              $Revision: 39 $
+ *              $Revision: 41 $
  *
  ******************************************************************************/
 
@@ -25,15 +25,7 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
 #include "acdebug.h"
-#include "actables.h"
 
 #ifdef ENABLE_DEBUGGER
 
@@ -41,7 +33,7 @@
 	 ACPI_MODULE_NAME    ("dbexec")
 
 
-acpi_db_method_info         acpi_gbl_db_method_info;
+static acpi_db_method_info  acpi_gbl_db_method_info;
 
 
 /*******************************************************************************
@@ -127,7 +119,7 @@
 
 void
 acpi_db_execute_setup (
-	acpi_db_method_info         *info)
+	acpi_db_method_info     *info)
 {
 
 	/* Catenate the current scope to the supplied name */
@@ -172,7 +164,8 @@
  ******************************************************************************/
 
 u32
-acpi_db_get_outstanding_allocations (void)
+acpi_db_get_outstanding_allocations (
+	void)
 {
 	u32                     outstanding = 0;
 
@@ -309,7 +302,10 @@
 
 	/* Signal our completion */
 
-	acpi_os_signal_semaphore (info->thread_gate, 1);
+	status = acpi_os_signal_semaphore (info->thread_gate, 1);
+	if (ACPI_FAILURE (status)) {
+		acpi_os_printf ("Could not signal debugger semaphore\n");
+	}
 }
 
 
@@ -373,7 +369,10 @@
 	acpi_os_printf ("Creating %X threads to execute %X times each\n", num_threads, num_loops);
 
 	for (i = 0; i < (num_threads); i++) {
-		acpi_os_queue_for_execution (OSD_PRIORITY_MED, acpi_db_method_thread, &acpi_gbl_db_method_info);
+		status = acpi_os_queue_for_execution (OSD_PRIORITY_MED, acpi_db_method_thread, &acpi_gbl_db_method_info);
+		if (ACPI_FAILURE (status)) {
+			break;
+		}
 	}
 
 	/* Wait for all threads to complete */
@@ -386,7 +385,7 @@
 
 	/* Cleanup and exit */
 
-	acpi_os_delete_semaphore (thread_gate);
+	(void) acpi_os_delete_semaphore (thread_gate);
 
 	acpi_db_set_output_destination (ACPI_DB_DUPLICATE_OUTPUT);
 	acpi_os_printf ("All threads (%X) have completed\n", num_threads);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbfileio.c linux/drivers/acpi/debugger/dbfileio.c
--- ../prev/linux/drivers/acpi/debugger/dbfileio.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbfileio.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: dbfileio - Debugger file I/O commands.  These can't usually
  *              be used when running the debugger in Ring 0 (Kernel mode)
- *              $Revision: 60 $
+ *              $Revision: 63 $
  *
  ******************************************************************************/
 
@@ -28,8 +28,6 @@
 #include "acpi.h"
 #include "acdebug.h"
 #include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
 #include "actables.h"
 
 #ifdef ENABLE_DEBUGGER
@@ -167,7 +165,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+static acpi_status
 acpi_db_load_table(
 	FILE                    *fp,
 	acpi_table_header       **table_ptr,
@@ -285,7 +283,7 @@
 
 	table_info.pointer = table_ptr;
 
-	status = acpi_tb_install_table (NULL, &table_info);
+	status = acpi_tb_install_table (&table_info);
 	if (ACPI_FAILURE (status)) {
 		/* Free table allocated by Acpi_tb_get_table */
 
@@ -371,7 +369,7 @@
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_ALREADY_EXISTS) {
 			acpi_os_printf ("Table %4.4s is already installed\n",
-					  &acpi_gbl_db_table_ptr->signature);
+					  acpi_gbl_db_table_ptr->signature);
 		}
 		else {
 			acpi_os_printf ("Could not install table, %s\n",
@@ -382,7 +380,7 @@
 	}
 
 	acpi_os_printf ("%4.4s at %p successfully installed and loaded\n",
-			  &acpi_gbl_db_table_ptr->signature, acpi_gbl_db_table_ptr);
+			  acpi_gbl_db_table_ptr->signature, acpi_gbl_db_table_ptr);
 
 	acpi_gbl_acpi_hardware_present = FALSE;
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbhistry.c linux/drivers/acpi/debugger/dbhistry.c
--- ../prev/linux/drivers/acpi/debugger/dbhistry.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbhistry.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: dbhistry - debugger HISTORY command
- *              $Revision: 22 $
+ *              $Revision: 24 $
  *
  *****************************************************************************/
 
@@ -25,15 +25,7 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
 #include "acdebug.h"
-#include "actables.h"
 
 #ifdef ENABLE_DEBUGGER
 
@@ -54,11 +46,11 @@
 } HISTORY_INFO;
 
 
-HISTORY_INFO                acpi_gbl_history_buffer[HISTORY_SIZE];
-u16                         acpi_gbl_lo_history = 0;
-u16                         acpi_gbl_num_history = 0;
-u16                         acpi_gbl_next_history_index = 0;
-u32                         acpi_gbl_next_cmd_num = 1;
+static HISTORY_INFO         acpi_gbl_history_buffer[HISTORY_SIZE];
+static u16                  acpi_gbl_lo_history = 0;
+static u16                  acpi_gbl_num_history = 0;
+static u16                  acpi_gbl_next_history_index = 0;
+static u32                  acpi_gbl_next_cmd_num = 1;
 
 
 /*******************************************************************************
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbinput.c linux/drivers/acpi/debugger/dbinput.c
--- ../prev/linux/drivers/acpi/debugger/dbinput.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbinput.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbinput - user front-end to the AML debugger
- *              $Revision: 81 $
+ *              $Revision: 86 $
  *
  ******************************************************************************/
 
@@ -25,10 +25,6 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
-#include "actables.h"
-#include "acnamesp.h"
-#include "acinterp.h"
 #include "acdebug.h"
 
 
@@ -67,6 +63,7 @@
 	CMD_HISTORY_EXE,
 	CMD_HISTORY_LAST,
 	CMD_INFORMATION,
+	CMD_INTEGRITY,
 	CMD_INTO,
 	CMD_LEVEL,
 	CMD_LIST,
@@ -97,7 +94,7 @@
 #define CMD_FIRST_VALID     2
 
 
-const COMMAND_INFO          acpi_gbl_db_commands[] =
+static const COMMAND_INFO       acpi_gbl_db_commands[] =
 { {"<NOT FOUND>",  0},
 	{"<NULL>",       0},
 	{"ALLOCATIONS",  0},
@@ -120,6 +117,7 @@
 	{"!",            1},
 	{"!!",           0},
 	{"INFORMATION",  0},
+	{"INTEGRITY",    0},
 	{"INTO",         0},
 	{"LEVEL",        0},
 	{"LIST",         0},
@@ -251,7 +249,7 @@
 		return;
 
 	default:
-		acpi_os_printf ("Unrecognized Command Class: %x\n", help_type);
+		acpi_os_printf ("Unrecognized Command Class: %X\n", help_type);
 		return;
 	}
 }
@@ -526,7 +524,7 @@
 		break;
 
 	case CMD_FIND:
-		acpi_db_find_name_in_namespace (acpi_gbl_db_args[1]);
+		status = acpi_db_find_name_in_namespace (acpi_gbl_db_args[1]);
 		break;
 
 	case CMD_GO:
@@ -574,6 +572,10 @@
 		acpi_db_display_method_info (op);
 		break;
 
+	case CMD_INTEGRITY:
+		acpi_db_check_integrity ();
+		break;
+
 	case CMD_INTO:
 		if (op)
 		{
@@ -623,7 +625,7 @@
 		break;
 
 	case CMD_METHODS:
-		acpi_db_display_objects ("METHOD", acpi_gbl_db_args[1]);
+		status = acpi_db_display_objects ("METHOD", acpi_gbl_db_args[1]);
 		break;
 
 	case CMD_NAMESPACE:
@@ -636,7 +638,8 @@
 		break;
 
 	case CMD_OBJECT:
-		acpi_db_display_objects (ACPI_STRUPR (acpi_gbl_db_args[1]), acpi_gbl_db_args[2]);
+		ACPI_STRUPR (acpi_gbl_db_args[1]);
+		status = acpi_db_display_objects (acpi_gbl_db_args[1], acpi_gbl_db_args[2]);
 		break;
 
 	case CMD_OPEN:
@@ -668,11 +671,11 @@
 		break;
 
 	case CMD_STATS:
-		acpi_db_display_statistics (acpi_gbl_db_args[1]);
+		status = acpi_db_display_statistics (acpi_gbl_db_args[1]);
 		break;
 
 	case CMD_STOP:
-		return (AE_AML_ERROR);
+		return (AE_NOT_IMPLEMENTED);
 
 	case CMD_TABLES:
 		acpi_db_display_table_info (acpi_gbl_db_args[1]);
@@ -722,6 +725,7 @@
 		return (AE_CTRL_TERMINATE);
 
 	case CMD_NOT_FOUND:
+	default:
 		acpi_os_printf ("Unknown Command\n");
 		return (AE_CTRL_TRUE);
 	}
@@ -794,13 +798,11 @@
 acpi_db_single_thread (
 	void)
 {
-	acpi_status             status;
-
 
 	acpi_gbl_method_executing = FALSE;
 	acpi_gbl_step_to_next_call = FALSE;
 
-	status = acpi_db_command_dispatch (acpi_gbl_db_line_buf, NULL, NULL);
+	(void) acpi_db_command_dispatch (acpi_gbl_db_line_buf, NULL, NULL);
 }
 
 
@@ -847,8 +849,7 @@
 
 		/* Get the user input line */
 
-		acpi_os_get_line (acpi_gbl_db_line_buf);
-
+		(void) acpi_os_get_line (acpi_gbl_db_line_buf);
 
 		/* Check for single or multithreaded debug */
 
@@ -882,7 +883,7 @@
 	 * Only this thread (the original thread) should actually terminate the subsystem,
 	 * because all the semaphores are deleted during termination
 	 */
-	acpi_terminate ();
+	status = acpi_terminate ();
 	return (status);
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbstats.c linux/drivers/acpi/debugger/dbstats.c
--- ../prev/linux/drivers/acpi/debugger/dbstats.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbstats.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbstats - Generation and display of ACPI table statistics
- *              $Revision: 55 $
+ *              $Revision: 59 $
  *
  ******************************************************************************/
 
@@ -26,8 +26,6 @@
 
 #include <acpi.h>
 #include <acdebug.h>
-#include <amlcode.h>
-#include <acparser.h>
 #include <acnamesp.h>
 
 #ifdef ENABLE_DEBUGGER
@@ -38,7 +36,7 @@
 /*
  * Statistics subcommands
  */
-ARGUMENT_INFO               acpi_db_stat_types [] =
+static ARGUMENT_INFO        acpi_db_stat_types [] =
 { {"ALLOCATIONS"},
 	{"OBJECTS"},
 	{"MEMORY"},
@@ -49,13 +47,13 @@
 	{NULL}           /* Must be null terminated */
 };
 
-#define CMD_ALLOCATIONS     0
-#define CMD_OBJECTS         1
-#define CMD_MEMORY          2
-#define CMD_MISC            3
-#define CMD_TABLES          4
-#define CMD_SIZES           5
-#define CMD_STACK           6
+#define CMD_STAT_ALLOCATIONS     0
+#define CMD_STAT_OBJECTS         1
+#define CMD_STAT_MEMORY          2
+#define CMD_STAT_MISC            3
+#define CMD_STAT_TABLES          4
+#define CMD_STAT_SIZES           5
+#define CMD_STAT_STACK           6
 
 
 /*******************************************************************************
@@ -143,6 +141,9 @@
 		acpi_db_enumerate_object (obj_desc->thermal_zone.drv_handler);
 		acpi_db_enumerate_object (obj_desc->thermal_zone.addr_handler);
 		break;
+
+	default:
+		break;
 	}
 }
 
@@ -232,7 +233,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_db_count_namespace_objects (
 	void)
 {
@@ -249,10 +250,8 @@
 		acpi_gbl_node_type_count [i] = 0;
 	}
 
-	acpi_ns_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
+	(void) acpi_ns_walk_namespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
 			   FALSE, acpi_db_classify_one_object, NULL, NULL);
-
-	return (AE_OK);
 }
 
 #endif
@@ -305,14 +304,14 @@
 	switch (type)
 	{
 #ifndef PARSER_ONLY
-	case CMD_ALLOCATIONS:
+	case CMD_STAT_ALLOCATIONS:
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
 		acpi_ut_dump_allocation_info ();
 #endif
 		break;
 #endif
 
-	case CMD_TABLES:
+	case CMD_STAT_TABLES:
 
 		acpi_os_printf ("ACPI Table Information:\n\n");
 		if (acpi_gbl_DSDT)
@@ -321,7 +320,7 @@
 		}
 		break;
 
-	case CMD_OBJECTS:
+	case CMD_STAT_OBJECTS:
 
 #ifndef PARSER_ONLY
 
@@ -345,7 +344,7 @@
 #endif
 		break;
 
-	case CMD_MEMORY:
+	case CMD_STAT_MEMORY:
 
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
 		acpi_os_printf ("\n----Object and Cache Statistics---------------------------------------------\n");
@@ -391,7 +390,7 @@
 
 		break;
 
-	case CMD_MISC:
+	case CMD_STAT_MISC:
 
 		acpi_os_printf ("\n_miscellaneous Statistics:\n\n");
 		acpi_os_printf ("Calls to Acpi_ps_find:.. ........% 7ld\n", acpi_gbl_ps_find_count);
@@ -407,7 +406,7 @@
 		break;
 
 
-	case CMD_SIZES:
+	case CMD_STAT_SIZES:
 
 		acpi_os_printf ("\n_internal object sizes:\n\n");
 
@@ -436,23 +435,29 @@
 
 		acpi_os_printf ("\n");
 
-		acpi_os_printf ("Parse_object   %3d\n", sizeof (acpi_parse_object));
-		acpi_os_printf ("Parse2_object  %3d\n", sizeof (acpi_parse2_object));
+		acpi_os_printf ("Parse_object   %3d\n", sizeof (ACPI_PARSE_OBJ_COMMON));
+		acpi_os_printf ("Parse_object_named %3d\n", sizeof (ACPI_PARSE_OBJ_NAMED));
+		acpi_os_printf ("Parse_object_asl %3d\n", sizeof (ACPI_PARSE_OBJ_ASL));
 		acpi_os_printf ("Operand_object %3d\n", sizeof (acpi_operand_object));
 		acpi_os_printf ("Namespace_node %3d\n", sizeof (acpi_namespace_node));
 
 		break;
 
 
-	case CMD_STACK:
+	case CMD_STAT_STACK:
+#if defined(ACPI_DEBUG)
 
-		size = acpi_gbl_entry_stack_pointer - acpi_gbl_lowest_stack_pointer;
+		size = (u32) (acpi_gbl_entry_stack_pointer - acpi_gbl_lowest_stack_pointer);
 
 		acpi_os_printf ("\n_subsystem Stack Usage:\n\n");
 		acpi_os_printf ("Entry Stack Pointer        %X\n", acpi_gbl_entry_stack_pointer);
 		acpi_os_printf ("Lowest Stack Pointer       %X\n", acpi_gbl_lowest_stack_pointer);
 		acpi_os_printf ("Stack Use                  %X (%d)\n", size, size);
 		acpi_os_printf ("Deepest Procedure Nesting  %d\n", acpi_gbl_deepest_nesting);
+#endif
+		break;
+
+	default:
 		break;
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbutils.c linux/drivers/acpi/debugger/dbutils.c
--- ../prev/linux/drivers/acpi/debugger/dbutils.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbutils.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbutils - AML debugger utilities
- *              $Revision: 52 $
+ *              $Revision: 55 $
  *
  ******************************************************************************/
 
@@ -28,9 +28,6 @@
 #include "acparser.h"
 #include "amlcode.h"
 #include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
 #include "acdebug.h"
 #include "acdispat.h"
 
@@ -259,7 +256,7 @@
 	acpi_parse_object       *root)
 {
 	acpi_parse_object       *op = root;
-	acpi_parse2_object      *method;
+	acpi_parse_object       *method;
 	acpi_parse_object       *search_op;
 	acpi_parse_object       *start_op;
 	acpi_status             status = AE_OK;
@@ -272,10 +269,11 @@
 
 	acpi_os_printf ("Pass two parse ....\n");
 
-
 	while (op) {
-		if (op->opcode == AML_METHOD_OP) {
-			method = (acpi_parse2_object *) op;
+		if (op->common.aml_opcode == AML_METHOD_OP) {
+			method = op;
+
+			/* Create a new walk state for the parse */
 
 			walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
 					   NULL, NULL, NULL);
@@ -283,32 +281,32 @@
 				return (AE_NO_MEMORY);
 			}
 
+			/* Init the Walk State */
 
 			walk_state->parser_state.aml        =
-			walk_state->parser_state.aml_start  = method->data;
+			walk_state->parser_state.aml_start  = method->named.data;
 			walk_state->parser_state.aml_end    =
-			walk_state->parser_state.pkg_end    = method->data + method->length;
+			walk_state->parser_state.pkg_end    = method->named.data + method->named.length;
 			walk_state->parser_state.start_scope = op;
 
 			walk_state->descending_callback     = acpi_ds_load1_begin_op;
 			walk_state->ascending_callback      = acpi_ds_load1_end_op;
 
+			/* Perform the AML parse */
 
 			status = acpi_ps_parse_aml (walk_state);
 
-
-			base_aml_offset = (method->value.arg)->aml_offset + 1;
-			start_op = (method->value.arg)->next;
+			base_aml_offset = (method->common.value.arg)->common.aml_offset + 1;
+			start_op = (method->common.value.arg)->common.next;
 			search_op = start_op;
 
 			while (search_op) {
-				search_op->aml_offset += base_aml_offset;
+				search_op->common.aml_offset += base_aml_offset;
 				search_op = acpi_ps_get_depth_next (start_op, search_op);
 			}
-
 		}
 
-		if (op->opcode == AML_REGION_OP) {
+		if (op->common.aml_opcode == AML_REGION_OP) {
 			/* TBD: [Investigate] this isn't quite the right thing to do! */
 			/*
 			 *
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/debugger/dbxface.c linux/drivers/acpi/debugger/dbxface.c
--- ../prev/linux/drivers/acpi/debugger/dbxface.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/debugger/dbxface.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dbxface - AML Debugger external interfaces
- *              $Revision: 55 $
+ *              $Revision: 59 $
  *
  ******************************************************************************/
 
@@ -25,12 +25,7 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "amlcode.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acevents.h"
-#include "acinterp.h"
 #include "acdebug.h"
 
 
@@ -71,11 +66,12 @@
 
 	/* Check for single-step breakpoint */
 
-	if (walk_state->method_breakpoint && (walk_state->method_breakpoint <= op->aml_offset)) {
+	if (walk_state->method_breakpoint &&
+	   (walk_state->method_breakpoint <= op->common.aml_offset)) {
 		/* Check if the breakpoint has been reached or passed */
 		/* Hit the breakpoint, resume single step, reset breakpoint */
 
-		acpi_os_printf ("***Break*** at AML offset %X\n", op->aml_offset);
+		acpi_os_printf ("***Break*** at AML offset %X\n", op->common.aml_offset);
 		acpi_gbl_cm_single_step = TRUE;
 		acpi_gbl_step_to_next_call = FALSE;
 		walk_state->method_breakpoint = 0;
@@ -83,8 +79,9 @@
 
 	/* Check for user breakpoint (Must be on exact Aml offset) */
 
-	else if (walk_state->user_breakpoint && (walk_state->user_breakpoint == op->aml_offset)) {
-		acpi_os_printf ("***User_breakpoint*** at AML offset %X\n", op->aml_offset);
+	else if (walk_state->user_breakpoint &&
+			(walk_state->user_breakpoint == op->common.aml_offset)) {
+		acpi_os_printf ("***User_breakpoint*** at AML offset %X\n", op->common.aml_offset);
 		acpi_gbl_cm_single_step = TRUE;
 		acpi_gbl_step_to_next_call = FALSE;
 		walk_state->method_breakpoint = 0;
@@ -95,7 +92,7 @@
 	 * Check if this is an opcode that we are interested in --
 	 * namely, opcodes that have arguments
 	 */
-	if (op->opcode == AML_INT_NAMEDFIELD_OP) {
+	if (op->common.aml_opcode == AML_INT_NAMEDFIELD_OP) {
 		return (AE_OK);
 	}
 
@@ -103,6 +100,10 @@
 	case AML_CLASS_UNKNOWN:
 	case AML_CLASS_ARGUMENT:    /* constants, literals, etc.  do nothing */
 		return (AE_OK);
+
+	default:
+		/* All other opcodes -- continue */
+		break;
 	}
 
 	/*
@@ -123,12 +124,12 @@
 		 */
 		original_debug_level = acpi_dbg_level;
 		acpi_dbg_level &= ~(ACPI_LV_PARSE | ACPI_LV_FUNCTIONS);
-		next = op->next;
-		op->next = NULL;
+		next = op->common.next;
+		op->common.next = NULL;
 
 
 		display_op = op;
-		parent_op = op->parent;
+		parent_op = op->common.parent;
 		if (parent_op) {
 			if ((walk_state->control_state) &&
 				(walk_state->control_state->common.state == ACPI_CONTROL_PREDICATE_EXECUTING)) {
@@ -138,25 +139,25 @@
 				 * entire predicate can be displayed.
 				 */
 				while (parent_op) {
-					if ((parent_op->opcode == AML_IF_OP) ||
-						(parent_op->opcode == AML_WHILE_OP)) {
+					if ((parent_op->common.aml_opcode == AML_IF_OP) ||
+						(parent_op->common.aml_opcode == AML_WHILE_OP)) {
 						display_op = parent_op;
 						break;
 					}
-					parent_op = parent_op->parent;
+					parent_op = parent_op->common.parent;
 				}
 			}
 			else {
 				while (parent_op) {
-					if ((parent_op->opcode == AML_IF_OP)    ||
-						(parent_op->opcode == AML_ELSE_OP)  ||
-						(parent_op->opcode == AML_SCOPE_OP) ||
-						(parent_op->opcode == AML_METHOD_OP) ||
-						(parent_op->opcode == AML_WHILE_OP)) {
+					if ((parent_op->common.aml_opcode == AML_IF_OP)   ||
+						(parent_op->common.aml_opcode == AML_ELSE_OP) ||
+						(parent_op->common.aml_opcode == AML_SCOPE_OP) ||
+						(parent_op->common.aml_opcode == AML_METHOD_OP) ||
+						(parent_op->common.aml_opcode == AML_WHILE_OP)) {
 						break;
 					}
 					display_op = parent_op;
-					parent_op = parent_op->parent;
+					parent_op = parent_op->common.parent;
 				}
 			}
 		}
@@ -165,8 +166,8 @@
 
 		acpi_db_display_op (walk_state, display_op, ACPI_UINT32_MAX);
 
-		if ((op->opcode == AML_IF_OP) ||
-			(op->opcode == AML_WHILE_OP)) {
+		if ((op->common.aml_opcode == AML_IF_OP) ||
+			(op->common.aml_opcode == AML_WHILE_OP)) {
 			if (walk_state->control_state->common.value) {
 				acpi_os_printf ("Predicate = [True], IF block was executed\n");
 			}
@@ -175,13 +176,13 @@
 			}
 		}
 
-		else if (op->opcode == AML_ELSE_OP) {
+		else if (op->common.aml_opcode == AML_ELSE_OP) {
 			acpi_os_printf ("Predicate = [False], ELSE block was executed\n");
 		}
 
 		/* Restore everything */
 
-		op->next = next;
+		op->common.next = next;
 		acpi_os_printf ("\n");
 		acpi_dbg_level = original_debug_level;
 	}
@@ -197,7 +198,7 @@
 	 * Check if this is a method call.
 	 */
 	if (acpi_gbl_step_to_next_call) {
-		if (op->opcode != AML_INT_METHODCALL_OP) {
+		if (op->common.aml_opcode != AML_INT_METHODCALL_OP) {
 			/* Not a method call, just keep executing */
 
 			return (AE_OK);
@@ -212,7 +213,7 @@
 	 * If the next opcode is a method call, we will "step over" it
 	 * by default.
 	 */
-	if (op->opcode == AML_INT_METHODCALL_OP) {
+	if (op->common.aml_opcode == AML_INT_METHODCALL_OP) {
 		acpi_gbl_cm_single_step = FALSE; /* No more single step while executing called method */
 
 		/* Set the breakpoint on/before the call, it will stop execution as soon as we return */
@@ -261,7 +262,7 @@
 
 			/* Get the user input line */
 
-			acpi_os_get_line (acpi_gbl_db_line_buf);
+			(void) acpi_os_get_line (acpi_gbl_db_line_buf);
 		}
 
 		status = acpi_db_command_dispatch (acpi_gbl_db_line_buf, walk_state, op);
@@ -287,9 +288,11 @@
  *
  ******************************************************************************/
 
-int
+acpi_status
 acpi_db_initialize (void)
 {
+	acpi_status             status;
+
 
 	/* Init globals */
 
@@ -309,7 +312,7 @@
 
 	acpi_gbl_db_buffer = acpi_os_allocate (ACPI_DEBUG_BUFFER_SIZE);
 	if (!acpi_gbl_db_buffer) {
-		return 0;
+		return (AE_NO_MEMORY);
 	}
 	ACPI_MEMSET (acpi_gbl_db_buffer, 0, ACPI_DEBUG_BUFFER_SIZE);
 
@@ -327,12 +330,24 @@
 	if (acpi_gbl_debugger_configuration & DEBUGGER_MULTI_THREADED) {
 		/* These were created with one unit, grab it */
 
-		acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-		acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_READY);
+		status = acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
+		if (ACPI_FAILURE (status)) {
+			acpi_os_printf ("Could not get debugger mutex\n");
+			return (status);
+		}
+		status = acpi_ut_acquire_mutex (ACPI_MTX_DEBUG_CMD_READY);
+		if (ACPI_FAILURE (status)) {
+			acpi_os_printf ("Could not get debugger mutex\n");
+			return (status);
+		}
 
 		/* Create the debug execution thread to execute commands */
 
-		acpi_os_queue_for_execution (0, acpi_db_execute_thread, NULL);
+		status = acpi_os_queue_for_execution (0, acpi_db_execute_thread, NULL);
+		if (ACPI_FAILURE (status)) {
+			acpi_os_printf ("Could not start debugger thread\n");
+			return (status);
+		}
 	}
 
 	if (!acpi_gbl_db_opt_verbose) {
@@ -341,7 +356,7 @@
 		acpi_gbl_db_opt_stats = FALSE;
 	}
 
-	return (0);
+	return (AE_OK);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dsfield.c linux/drivers/acpi/dispatcher/dsfield.c
--- ../prev/linux/drivers/acpi/dispatcher/dsfield.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/dispatcher/dsfield.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: dsfield - Dispatcher field routines
- *              $Revision: 62 $
+ *              $Revision: 65 $
  *
  *****************************************************************************/
 
@@ -74,7 +74,7 @@
 
 	/* Get the Name_string argument */
 
-	if (op->opcode == AML_CREATE_FIELD_OP) {
+	if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
 		arg = acpi_ps_get_arg (op, 3);
 	}
 	else {
@@ -102,7 +102,7 @@
 	/*
 	 * Enter the Name_string into the namespace
 	 */
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
 			 INTERNAL_TYPE_DEF_ANY, ACPI_IMODE_LOAD_PASS1,
 			 flags, walk_state, &(node));
 	if (ACPI_FAILURE (status)) {
@@ -113,7 +113,7 @@
 	 * for now, we will put it in the "op" object that the parser uses, so we
 	 * can get it again at the end of this scope
 	 */
-	op->node = node;
+	op->common.node = node;
 
 	/*
 	 * If there is no object attached to the node, this node was just created and
@@ -144,8 +144,8 @@
 	 * operands must be evaluated.
 	 */
 	second_desc                 = obj_desc->common.next_object;
-	second_desc->extra.aml_start = ((acpi_parse2_object *) op)->data;
-	second_desc->extra.aml_length = ((acpi_parse2_object *) op)->length;
+	second_desc->extra.aml_start = op->named.data;
+	second_desc->extra.aml_length = op->named.length;
 	obj_desc->buffer_field.node = node;
 
 	/* Attach constructed field descriptors to parent node */
@@ -187,6 +187,7 @@
 	acpi_parse_object       *arg)
 {
 	acpi_status             status;
+	acpi_integer            position;
 
 
 	ACPI_FUNCTION_TRACE_PTR ("Ds_get_field_names", info);
@@ -205,16 +206,18 @@
 		 * 2) Access_as - changes the access mode
 		 * 3) Name - Enters a new named field into the namespace
 		 */
-		switch (arg->opcode) {
+		switch (arg->common.aml_opcode) {
 		case AML_INT_RESERVEDFIELD_OP:
 
-			if (((acpi_integer) info->field_bit_position + arg->value.size) >
-				ACPI_UINT32_MAX) {
+			position = (acpi_integer) info->field_bit_position
+					 + (acpi_integer) arg->common.value.size;
+
+			if (position > ACPI_UINT32_MAX) {
 				ACPI_REPORT_ERROR (("Bit offset within field too large (> 0xFFFFFFFF)\n"));
 				return_ACPI_STATUS (AE_SUPPORT);
 			}
 
-			info->field_bit_position += arg->value.size;
+			info->field_bit_position = (u32) position;
 			break;
 
 
@@ -227,9 +230,9 @@
 			 * In Field_flags, preserve the flag bits other than the ACCESS_TYPE bits
 			 */
 			info->field_flags = (u8) ((info->field_flags & ~(AML_FIELD_ACCESS_TYPE_MASK)) |
-					  ((u8) (arg->value.integer32 >> 8)));
+					  ((u8) (arg->common.value.integer32 >> 8)));
 
-			info->attribute = (u8) (arg->value.integer32);
+			info->attribute = (u8) (arg->common.value.integer32);
 			break;
 
 
@@ -238,7 +241,7 @@
 			/* Lookup the name */
 
 			status = acpi_ns_lookup (walk_state->scope_info,
-					  (NATIVE_CHAR *) &((acpi_parse2_object *)arg)->name,
+					  (NATIVE_CHAR *) &arg->named.name,
 					  info->field_type, ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
 					  walk_state, &info->field_node);
 			if (ACPI_FAILURE (status)) {
@@ -247,11 +250,11 @@
 				}
 
 				ACPI_REPORT_ERROR (("Field name [%4.4s] already exists in current scope\n",
-						  &((acpi_parse2_object *)arg)->name));
+						  &arg->named.name));
 			}
 			else {
-				arg->node = info->field_node;
-				info->field_bit_length = arg->value.size;
+				arg->common.node = info->field_node;
+				info->field_bit_length = arg->common.value.size;
 
 				/* Create and initialize an object for the new Field Node */
 
@@ -263,8 +266,10 @@
 
 			/* Keep track of bit position for the next field */
 
-			if (((acpi_integer) info->field_bit_position + arg->value.size) >
-				ACPI_UINT32_MAX) {
+			position = (acpi_integer) info->field_bit_position
+					 + (acpi_integer) arg->common.value.size;
+
+			if (position > ACPI_UINT32_MAX) {
 				ACPI_REPORT_ERROR (("Field [%4.4s] bit offset too large (> 0xFFFFFFFF)\n",
 					&info->field_node->name));
 				return_ACPI_STATUS (AE_SUPPORT);
@@ -277,11 +282,11 @@
 		default:
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid opcode in field list: %X\n",
-				arg->opcode));
-			return_ACPI_STATUS (AE_AML_ERROR);
+				arg->common.aml_opcode));
+			return_ACPI_STATUS (AE_AML_BAD_OPCODE);
 		}
 
-		arg = arg->next;
+		arg = arg->common.next;
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -308,7 +313,7 @@
 	acpi_namespace_node     *region_node,
 	acpi_walk_state         *walk_state)
 {
-	acpi_status             status = AE_AML_ERROR;
+	acpi_status             status;
 	acpi_parse_object       *arg;
 	ACPI_CREATE_FIELD_INFO  info;
 
@@ -318,9 +323,9 @@
 
 	/* First arg is the name of the parent Op_region (must already exist) */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 	if (!region_node) {
-		status = acpi_ns_lookup (walk_state->scope_info, arg->value.name,
+		status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.name,
 				  ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
 				  ACPI_NS_SEARCH_PARENT, walk_state, &region_node);
 		if (ACPI_FAILURE (status)) {
@@ -330,8 +335,8 @@
 
 	/* Second arg is the field flags */
 
-	arg = arg->next;
-	info.field_flags = arg->value.integer8;
+	arg = arg->common.next;
+	info.field_flags = arg->common.value.integer8;
 	info.attribute = 0;
 
 	/* Each remaining arg is a Named Field */
@@ -339,7 +344,7 @@
 	info.field_type = INTERNAL_TYPE_REGION_FIELD;
 	info.region_node = region_node;
 
-	status = acpi_ds_get_field_names (&info, walk_state, arg->next);
+	status = acpi_ds_get_field_names (&info, walk_state, arg->common.next);
 
 	return_ACPI_STATUS (status);
 }
@@ -365,7 +370,7 @@
 	acpi_parse_object       *op,
 	acpi_walk_state         *walk_state)
 {
-	acpi_status             status = AE_AML_ERROR;
+	acpi_status             status;
 	acpi_parse_object       *arg = NULL;
 	acpi_namespace_node     *node;
 	u8                      type = 0;
@@ -389,6 +394,9 @@
 		arg = acpi_ps_get_arg (op, 3);
 		type = INTERNAL_TYPE_INDEX_FIELD;
 		break;
+
+	default:
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
 	/*
@@ -397,9 +405,9 @@
 	while (arg) {
 		/* Ignore OFFSET and ACCESSAS terms here */
 
-		if (arg->opcode == AML_INT_NAMEDFIELD_OP) {
+		if (arg->common.aml_opcode == AML_INT_NAMEDFIELD_OP) {
 			status = acpi_ns_lookup (walk_state->scope_info,
-					  (NATIVE_CHAR *) &((acpi_parse2_object *)arg)->name,
+					  (NATIVE_CHAR *) &arg->named.name,
 					  type, ACPI_IMODE_LOAD_PASS1,
 					  ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,
 					  walk_state, &node);
@@ -409,18 +417,22 @@
 				}
 
 				ACPI_REPORT_ERROR (("Field name [%4.4s] already exists in current scope\n",
-						  &((acpi_parse2_object *)arg)->name));
+						  &arg->named.name));
+
+				/* Name already exists, just ignore this error */
+
+				status = AE_OK;
 			}
 
-			arg->node = node;
+			arg->common.node = node;
 		}
 
 		/* Move to next field in the list */
 
-		arg = arg->next;
+		arg = arg->common.next;
 	}
 
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
@@ -444,7 +456,7 @@
 	acpi_namespace_node     *region_node,
 	acpi_walk_state         *walk_state)
 {
-	acpi_status             status = AE_AML_ERROR;
+	acpi_status             status;
 	acpi_parse_object       *arg;
 	ACPI_CREATE_FIELD_INFO  info;
 
@@ -454,9 +466,9 @@
 
 	/* First arg is the name of the parent Op_region (must already exist) */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 	if (!region_node) {
-		status = acpi_ns_lookup (walk_state->scope_info, arg->value.name,
+		status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.name,
 				  ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
 				  ACPI_NS_SEARCH_PARENT, walk_state, &region_node);
 		if (ACPI_FAILURE (status)) {
@@ -466,8 +478,8 @@
 
 	/* Second arg is the Bank Register (must already exist) */
 
-	arg = arg->next;
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
+	arg = arg->common.next;
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
 			  INTERNAL_TYPE_BANK_FIELD_DEFN, ACPI_IMODE_EXECUTE,
 			  ACPI_NS_SEARCH_PARENT, walk_state, &info.register_node);
 	if (ACPI_FAILURE (status)) {
@@ -476,20 +488,20 @@
 
 	/* Third arg is the Bank_value */
 
-	arg = arg->next;
-	info.bank_value = arg->value.integer32;
+	arg = arg->common.next;
+	info.bank_value = arg->common.value.integer32;
 
 	/* Fourth arg is the field flags */
 
-	arg = arg->next;
-	info.field_flags = arg->value.integer8;
+	arg = arg->common.next;
+	info.field_flags = arg->common.value.integer8;
 
 	/* Each remaining arg is a Named Field */
 
 	info.field_type = INTERNAL_TYPE_BANK_FIELD;
 	info.region_node = region_node;
 
-	status = acpi_ds_get_field_names (&info, walk_state, arg->next);
+	status = acpi_ds_get_field_names (&info, walk_state, arg->common.next);
 
 	return_ACPI_STATUS (status);
 }
@@ -525,8 +537,8 @@
 
 	/* First arg is the name of the Index register (must already exist) */
 
-	arg = op->value.arg;
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
+	arg = op->common.value.arg;
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
 			  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
 			  ACPI_NS_SEARCH_PARENT, walk_state, &info.register_node);
 	if (ACPI_FAILURE (status)) {
@@ -535,8 +547,8 @@
 
 	/* Second arg is the data register (must already exist) */
 
-	arg = arg->next;
-	status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
+	arg = arg->common.next;
+	status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
 			  INTERNAL_TYPE_INDEX_FIELD_DEFN, ACPI_IMODE_EXECUTE,
 			  ACPI_NS_SEARCH_PARENT, walk_state, &info.data_register_node);
 	if (ACPI_FAILURE (status)) {
@@ -545,8 +557,8 @@
 
 	/* Next arg is the field flags */
 
-	arg = arg->next;
-	info.field_flags = arg->value.integer8;
+	arg = arg->common.next;
+	info.field_flags = arg->common.value.integer8;
 
 
 	/* Each remaining arg is a Named Field */
@@ -554,7 +566,7 @@
 	info.field_type = INTERNAL_TYPE_INDEX_FIELD;
 	info.region_node = region_node;
 
-	status = acpi_ds_get_field_names (&info, walk_state, arg->next);
+	status = acpi_ds_get_field_names (&info, walk_state, arg->common.next);
 
 	return_ACPI_STATUS (status);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dsmethod.c linux/drivers/acpi/dispatcher/dsmethod.c
--- ../prev/linux/drivers/acpi/dispatcher/dsmethod.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/dispatcher/dsmethod.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: dsmethod - Parser/Interpreter interface - control method parsing
- *              $Revision: 81 $
+ *              $Revision: 86 $
  *
  *****************************************************************************/
 
@@ -30,8 +30,6 @@
 #include "acdispat.h"
 #include "acinterp.h"
 #include "acnamesp.h"
-#include "actables.h"
-#include "acdebug.h"
 
 
 #define _COMPONENT          ACPI_DISPATCHER
@@ -78,7 +76,7 @@
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** Parsing [%4.4s] **** Named_obj=%p\n",
-		(char *) &((acpi_namespace_node *) obj_handle)->name, obj_handle));
+		((acpi_namespace_node *) obj_handle)->name.ascii, obj_handle));
 
 	/* Extract the method object from the method Node */
 
@@ -112,7 +110,7 @@
 	/* Init new op with the method name and pointer back to the Node */
 
 	acpi_ps_set_name (op, node->name.integer);
-	op->node = node;
+	op->common.node = node;
 
 	/*
 	 * Get a new Owner_id for objects created by this method. Namespace
@@ -124,8 +122,7 @@
 
 	/* Create and initialize a new walk state */
 
-	walk_state = acpi_ds_create_walk_state (owner_id,
-			   NULL, NULL, NULL);
+	walk_state = acpi_ds_create_walk_state (owner_id, NULL, NULL, NULL);
 	if (!walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
@@ -152,8 +149,9 @@
 		return_ACPI_STATUS (status);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** [%4.4s] Parsed **** Named_obj=%p Op=%p\n",
-		(char *) &((acpi_namespace_node *) obj_handle)->name, obj_handle, op));
+	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+		"**** [%4.4s] Parsed **** Named_obj=%p Op=%p\n",
+		((acpi_namespace_node *) obj_handle)->name.ascii, obj_handle, op));
 
 	acpi_ps_delete_parse_tree (op);
 	return_ACPI_STATUS (status);
@@ -348,8 +346,8 @@
 
 	this_walk_state->num_operands = 0;
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Starting nested execution, newstate=%p\n",
-		next_walk_state));
+	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+		"Starting nested execution, newstate=%p\n", next_walk_state));
 
 	return_ACPI_STATUS (AE_OK);
 
@@ -357,7 +355,7 @@
 	/* On error, we must delete the new walk state */
 
 cleanup:
-	acpi_ds_terminate_control_method (next_walk_state);
+	(void) acpi_ds_terminate_control_method (next_walk_state);
 	acpi_ds_delete_walk_state (next_walk_state);
 	return_ACPI_STATUS (status);
 
@@ -444,6 +442,10 @@
 	ACPI_FUNCTION_TRACE_PTR ("Ds_terminate_control_method", walk_state);
 
 
+	if (!walk_state) {
+		return (AE_BAD_PARAMETER);
+	}
+
 	/* The current method object was saved in the walk state */
 
 	obj_desc = walk_state->method_desc;
@@ -468,8 +470,14 @@
 	/* Signal completion of the execution of this method if necessary */
 
 	if (walk_state->method_desc->method.semaphore) {
-		acpi_os_signal_semaphore (
-			walk_state->method_desc->method.semaphore, 1);
+		status = acpi_os_signal_semaphore (
+				  walk_state->method_desc->method.semaphore, 1);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not signal method semaphore\n"));
+			status = AE_OK;
+
+			/* Ignore error and continue cleanup */
+		}
 	}
 
 	/* Decrement the thread count on the method parse tree */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dsmthdat.c linux/drivers/acpi/dispatcher/dsmthdat.c
--- ../prev/linux/drivers/acpi/dispatcher/dsmthdat.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/dispatcher/dsmthdat.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dsmthdat - control method arguments and local variables
- *              $Revision: 59 $
+ *              $Revision: 61 $
  *
  ******************************************************************************/
 
@@ -25,9 +25,7 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "acdispat.h"
-#include "acinterp.h"
 #include "amlcode.h"
 #include "acnamesp.h"
 
@@ -57,7 +55,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ds_method_data_init (
 	acpi_walk_state         *walk_state)
 {
@@ -90,7 +88,7 @@
 		walk_state->local_variables[i].flags       = ANOBJ_END_OF_PEER_LIST | ANOBJ_METHOD_LOCAL;
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
@@ -100,14 +98,14 @@
  *
  * PARAMETERS:  Walk_state          - Current walk state object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Delete method locals and arguments.  Arguments are only
  *              deleted if this method was called from another method.
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ds_method_data_delete_all (
 	acpi_walk_state         *walk_state)
 {
@@ -127,7 +125,7 @@
 			/* Detach object (if present) and remove a reference */
 
 			acpi_ns_detach_object (&walk_state->local_variables[index]);
-	   }
+		}
 	}
 
 	/* Detach the arguments */
@@ -143,7 +141,7 @@
 		}
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
@@ -435,6 +433,9 @@
 				index, node));
 
 			return_ACPI_STATUS (AE_AML_UNINITIALIZED_LOCAL);
+
+		default:
+			return_ACPI_STATUS (AE_AML_INTERNAL);
 		}
 	}
 
@@ -457,14 +458,14 @@
  *              Index               - Which local_var or argument to delete
  *              Walk_state          - Current walk state object
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Delete the entry at Opcode:Index on the method stack.  Inserts
  *              a null into the stack slot after the object is deleted.
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ds_method_data_delete_value (
 	u16                     opcode,
 	u32                     index,
@@ -482,7 +483,7 @@
 
 	status = acpi_ds_method_data_get_node (opcode, index, walk_state, &node);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		return_VOID;
 	}
 
 	/* Get the associated object */
@@ -497,7 +498,7 @@
 	node->object = NULL;
 
 	if ((object) &&
-		(ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_INTERNAL)) {
+		(ACPI_GET_DESCRIPTOR_TYPE (object) == ACPI_DESC_TYPE_OPERAND)) {
 		/*
 		 * There is a valid object.
 		 * Decrement the reference count by one to balance the
@@ -506,7 +507,7 @@
 		acpi_ut_remove_reference (object);
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dsobject.c linux/drivers/acpi/dispatcher/dsobject.c
--- ../prev/linux/drivers/acpi/dispatcher/dsobject.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/dispatcher/dsobject.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: dsobject - Dispatcher object management routines
- *              $Revision: 91 $
+ *              $Revision: 99 $
  *
  *****************************************************************************/
 
@@ -28,7 +28,6 @@
 #include "acparser.h"
 #include "amlcode.h"
 #include "acdispat.h"
-#include "acinterp.h"
 #include "acnamesp.h"
 
 #define _COMPONENT          ACPI_DISPATCHER
@@ -65,15 +64,11 @@
 	acpi_object_type        type;
 	acpi_status             status;
 	acpi_init_walk_info     *info = (acpi_init_walk_info *) context;
-	u8                      table_revision;
 
 
 	ACPI_FUNCTION_NAME ("Ds_init_one_object");
 
 
-	info->object_count++;
-	table_revision = info->table_desc->pointer->revision;
-
 	/*
 	 * We are only interested in objects owned by the table that
 	 * was just loaded
@@ -83,6 +78,8 @@
 		return (AE_OK);
 	}
 
+	info->object_count++;
+
 	/* And even then, we are only interested in a few object types */
 
 	type = acpi_ns_get_type (obj_handle);
@@ -90,7 +87,12 @@
 	switch (type) {
 	case ACPI_TYPE_REGION:
 
-		acpi_ds_initialize_region (obj_handle);
+		status = acpi_ds_initialize_region (obj_handle);
+		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Region %p [%4.4s] - Init failure, %s\n",
+				obj_handle, ((acpi_namespace_node *) obj_handle)->name.ascii,
+				acpi_format_exception (status)));
+		}
 
 		info->op_region_count++;
 		break;
@@ -107,9 +109,11 @@
 		/*
 		 * Set the execution data width (32 or 64) based upon the
 		 * revision number of the parent ACPI table.
+		 * TBD: This is really for possible future support of integer width
+		 * on a per-table basis. Currently, we just use a global for the width.
 		 */
-		if (table_revision == 1) {
-			((acpi_namespace_node *)obj_handle)->flags |= ANOBJ_DATA_WIDTH_32;
+		if (info->table_desc->pointer->revision == 1) {
+			((acpi_namespace_node *) obj_handle)->flags |= ANOBJ_DATA_WIDTH_32;
 		}
 
 		/*
@@ -119,7 +123,7 @@
 		status = acpi_ds_parse_method (obj_handle);
 		if (ACPI_FAILURE (status)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Method %p [%4.4s] - parse failure, %s\n",
-				obj_handle, (char *) &((acpi_namespace_node *) obj_handle)->name,
+				obj_handle, ((acpi_namespace_node *) obj_handle)->name.ascii,
 				acpi_format_exception (status)));
 
 			/* This parse failed, but we will continue parsing more methods */
@@ -135,6 +139,13 @@
 		acpi_ns_delete_namespace_by_owner (((acpi_namespace_node *) obj_handle)->object->method.owning_id);
 		break;
 
+
+	case ACPI_TYPE_DEVICE:
+
+		info->device_count++;
+		break;
+
+
 	default:
 		break;
 	}
@@ -177,10 +188,10 @@
 		"**** Starting initialization of namespace objects ****\n"));
 	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK, "Parsing Methods:"));
 
-
 	info.method_count   = 0;
 	info.op_region_count = 0;
 	info.object_count   = 0;
+	info.device_count   = 0;
 	info.table_desc     = table_desc;
 
 	/* Walk entire namespace from the supplied root */
@@ -188,16 +199,17 @@
 	status = acpi_walk_namespace (ACPI_TYPE_ANY, start_node, ACPI_UINT32_MAX,
 			  acpi_ds_init_one_object, &info, NULL);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %x\n", status));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed, %s\n",
+			acpi_format_exception (status)));
 	}
 
 	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-		"\n%d Control Methods found and parsed (%d nodes total)\n",
-		info.method_count, info.object_count));
-	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Control Methods found\n", info.method_count));
+		"\n_table [%4.4s] - %hd Objects with %hd Devices %hd Methods %hd Regions\n",
+		table_desc->pointer->signature, info.object_count,
+		info.device_count, info.method_count, info.op_region_count));
+
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Op Regions found\n", info.op_region_count));
+		"%hd Methods, %hd Regions\n", info.method_count, info.op_region_count));
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -251,8 +263,8 @@
 		 * Defer evaluation of Buffer Term_arg operand
 		 */
 		obj_desc->buffer.node     = (acpi_namespace_node *) walk_state->operands[0];
-		obj_desc->buffer.aml_start = ((acpi_parse2_object *) op)->data;
-		obj_desc->buffer.aml_length = ((acpi_parse2_object *) op)->length;
+		obj_desc->buffer.aml_start = op->named.data;
+		obj_desc->buffer.aml_length = op->named.length;
 		break;
 
 
@@ -262,21 +274,21 @@
 		 * Defer evaluation of Package Term_arg operand
 		 */
 		obj_desc->package.node     = (acpi_namespace_node *) walk_state->operands[0];
-		obj_desc->package.aml_start = ((acpi_parse2_object *) op)->data;
-		obj_desc->package.aml_length = ((acpi_parse2_object *) op)->length;
+		obj_desc->package.aml_start = op->named.data;
+		obj_desc->package.aml_length = op->named.length;
 		break;
 
 
 	case ACPI_TYPE_INTEGER:
 
-		obj_desc->integer.value = op->value.integer;
+		obj_desc->integer.value = op->common.value.integer;
 		break;
 
 
 	case ACPI_TYPE_STRING:
 
-		obj_desc->string.pointer = op->value.string;
-		obj_desc->string.length = ACPI_STRLEN (op->value.string);
+		obj_desc->string.pointer = op->common.value.string;
+		obj_desc->string.length = ACPI_STRLEN (op->common.value.string);
 
 		/*
 		 * The string is contained in the ACPI table, don't ever try
@@ -313,10 +325,10 @@
 
 		default: /* Constants, Literals, etc.. */
 
-			if (op->opcode == AML_INT_NAMEPATH_OP) {
+			if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
 				/* Node was saved in Op */
 
-				obj_desc->reference.node = op->node;
+				obj_desc->reference.node = op->common.node;
 			}
 
 			obj_desc->reference.opcode = opcode;
@@ -327,7 +339,7 @@
 
 	default:
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unimplemented data type: %x\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unimplemented data type: %X\n",
 			obj_desc->common.type));
 
 		break;
@@ -366,31 +378,30 @@
 	ACPI_FUNCTION_TRACE ("Ds_build_internal_object");
 
 
-	if (op->opcode == AML_INT_NAMEPATH_OP) {
+	if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
 		/*
 		 * This is an object reference.  If this name was
 		 * previously looked up in the namespace, it was stored in this op.
 		 * Otherwise, go ahead and look it up now
 		 */
-		if (!op->node) {
-			status = acpi_ns_lookup (walk_state->scope_info, op->value.string,
+		if (!op->common.node) {
+			status = acpi_ns_lookup (walk_state->scope_info, op->common.value.string,
 					  ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
 					  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
-					  (acpi_namespace_node **) &(op->node));
+					  (acpi_namespace_node **) &(op->common.node));
 
 			if (ACPI_FAILURE (status)) {
 				if (status == AE_NOT_FOUND) {
 					name = NULL;
-					acpi_ns_externalize_name (ACPI_UINT32_MAX, op->value.string, NULL, &name);
-
-					if (name) {
+					status = acpi_ns_externalize_name (ACPI_UINT32_MAX, op->common.value.string, NULL, &name);
+					if (ACPI_SUCCESS (status)) {
 						ACPI_REPORT_WARNING (("Reference %s at AML %X not found\n",
-								 name, op->aml_offset));
+								 name, op->common.aml_offset));
 						ACPI_MEM_FREE (name);
 					}
 					else {
 						ACPI_REPORT_WARNING (("Reference %s at AML %X not found\n",
-								   op->value.string, op->aml_offset));
+								   op->common.value.string, op->common.aml_offset));
 					}
 
 					*obj_desc_ptr = NULL;
@@ -404,12 +415,12 @@
 
 	/* Create and init the internal ACPI object */
 
-	obj_desc = acpi_ut_create_internal_object ((acpi_ps_get_opcode_info (op->opcode))->object_type);
+	obj_desc = acpi_ut_create_internal_object ((acpi_ps_get_opcode_info (op->common.aml_opcode))->object_type);
 	if (!obj_desc) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	status = acpi_ds_init_object_from_op (walk_state, op, op->opcode, &obj_desc);
+	status = acpi_ds_init_object_from_op (walk_state, op, op->common.aml_opcode, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		acpi_ut_remove_reference (obj_desc);
 		return_ACPI_STATUS (status);
@@ -443,7 +454,7 @@
 {
 	acpi_parse_object       *arg;
 	acpi_operand_object     *obj_desc;
-	acpi_parse2_object      *byte_list;
+	acpi_parse_object       *byte_list;
 	u32                     byte_list_length = 0;
 
 
@@ -472,20 +483,20 @@
 	 * individual bytes or a string initializer.  In either case, a
 	 * Byte_list appears in the AML.
 	 */
-	arg = op->value.arg;         /* skip first arg */
+	arg = op->common.value.arg;         /* skip first arg */
 
-	byte_list = (acpi_parse2_object *) arg->next;
+	byte_list = arg->named.next;
 	if (byte_list) {
-		if (byte_list->opcode != AML_INT_BYTELIST_OP) {
+		if (byte_list->common.aml_opcode != AML_INT_BYTELIST_OP) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Expecting bytelist, got AML opcode %X in op %p\n",
-				byte_list->opcode, byte_list));
+				byte_list->common.aml_opcode, byte_list));
 
 			acpi_ut_remove_reference (obj_desc);
 			return (AE_TYPE);
 		}
 
-		byte_list_length = byte_list->value.integer32;
+		byte_list_length = byte_list->common.value.integer32;
 	}
 
 	/*
@@ -516,12 +527,12 @@
 	/* Initialize buffer from the Byte_list (if present) */
 
 	if (byte_list) {
-		ACPI_MEMCPY (obj_desc->buffer.pointer, byte_list->data,
+		ACPI_MEMCPY (obj_desc->buffer.pointer, byte_list->named.data,
 				  byte_list_length);
 	}
 
 	obj_desc->buffer.flags |= AOPOBJ_DATA_VALID;
-	op->node = (acpi_namespace_node *) obj_desc;
+	op->common.node = (acpi_namespace_node *) obj_desc;
 	return_ACPI_STATUS (AE_OK);
 }
 
@@ -560,11 +571,10 @@
 
 	/* Find the parent of a possibly nested package */
 
-
-	parent = op->parent;
-	while ((parent->opcode == AML_PACKAGE_OP)     ||
-		   (parent->opcode == AML_VAR_PACKAGE_OP)) {
-		parent = parent->parent;
+	parent = op->common.parent;
+	while ((parent->common.aml_opcode == AML_PACKAGE_OP)    ||
+		   (parent->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
+		parent = parent->common.parent;
 	}
 
 	obj_desc = *obj_desc_ptr;
@@ -581,7 +591,7 @@
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		obj_desc->package.node = parent->node;
+		obj_desc->package.node = parent->common.node;
 	}
 
 	obj_desc->package.count = package_length;
@@ -589,11 +599,11 @@
 	/* Count the number of items in the package list */
 
 	package_list_length = 0;
-	arg = op->value.arg;
-	arg = arg->next;
+	arg = op->common.value.arg;
+	arg = arg->common.next;
 	while (arg) {
 		package_list_length++;
-		arg = arg->next;
+		arg = arg->common.next;
 	}
 
 	/*
@@ -610,7 +620,7 @@
 	 * that the list is always null terminated.
 	 */
 	obj_desc->package.elements = ACPI_MEM_CALLOCATE (
-			 (obj_desc->package.count + 1) * sizeof (void *));
+			 ((ACPI_SIZE) obj_desc->package.count + 1) * sizeof (void *));
 
 	if (!obj_desc->package.elements) {
 		acpi_ut_delete_object_desc (obj_desc);
@@ -621,13 +631,13 @@
 	 * Now init the elements of the package
 	 */
 	i = 0;
-	arg = op->value.arg;
-	arg = arg->next;
+	arg = op->common.value.arg;
+	arg = arg->common.next;
 	while (arg) {
-		if (arg->opcode == AML_INT_RETURN_VALUE_OP) {
+		if (arg->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
 			/* Object (package or buffer) is already built */
 
-			obj_desc->package.elements[i] = (acpi_operand_object *) arg->node;
+			obj_desc->package.elements[i] = ACPI_CAST_PTR (acpi_operand_object, arg->common.node);
 		}
 		else {
 			status = acpi_ds_build_internal_object (walk_state, arg,
@@ -635,11 +645,11 @@
 		}
 
 		i++;
-		arg = arg->next;
+		arg = arg->common.next;
 	}
 
 	obj_desc->package.flags |= AOPOBJ_DATA_VALID;
-	op->node = (acpi_namespace_node *) obj_desc;
+	op->common.node = (acpi_namespace_node *) obj_desc;
 	return_ACPI_STATUS (status);
 }
 
@@ -679,7 +689,7 @@
 		return_ACPI_STATUS (AE_OK);
 	}
 
-	if (!op->value.arg) {
+	if (!op->common.value.arg) {
 		/* No arguments, there is nothing to do */
 
 		return_ACPI_STATUS (AE_OK);
@@ -687,7 +697,7 @@
 
 	/* Build an internal object for the argument(s) */
 
-	status = acpi_ds_build_internal_object (walk_state, op->value.arg, &obj_desc);
+	status = acpi_ds_build_internal_object (walk_state, op->common.value.arg, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dsopcode.c linux/drivers/acpi/dispatcher/dsopcode.c
--- ../prev/linux/drivers/acpi/dispatcher/dsopcode.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/dispatcher/dsopcode.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: dsopcode - Dispatcher Op Region support and handling of
  *                         "control" opcodes
- *              $Revision: 74 $
+ *              $Revision: 79 $
  *
  *****************************************************************************/
 
@@ -32,7 +32,6 @@
 #include "acinterp.h"
 #include "acnamesp.h"
 #include "acevents.h"
-#include "actables.h"
 
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dsopcode")
@@ -43,7 +42,8 @@
  * FUNCTION:    Acpi_ds_execute_arguments
  *
  * PARAMETERS:  Node                - Parent NS node
- *              Extra_desc          - Has AML pointer and length
+ *              Aml_length          - Length of executable AML
+ *              Aml_start           - Pointer to the AML
  *
  * RETURN:      Status.
  *
@@ -77,7 +77,7 @@
 
 	/* Save the Node for use in Acpi_ps_parse_aml */
 
-	op->node = scope_node;
+	op->common.node = scope_node;
 
 	/* Create and initialize a new parser state */
 
@@ -105,9 +105,9 @@
 
 	/* Get and init the Op created above */
 
-	arg = op->value.arg;
-	op->node = node;
-	arg->node = node;
+	arg = op->common.value.arg;
+	op->common.node = node;
+	arg->common.node = node;
 	acpi_ps_delete_parse_tree (op);
 
 	/* Evaluate the address and length arguments for the Buffer Field */
@@ -117,7 +117,7 @@
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	op->node = scope_node;
+	op->common.node = scope_node;
 
 	/* Create and initialize a new parser state */
 
@@ -175,7 +175,7 @@
 
 	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname (node, " [Field]"));
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] Buffer_field JIT Init\n",
-		(char *) &node->name));
+		node->name.ascii));
 
 	/* Execute the AML code for the Term_arg arguments */
 
@@ -320,7 +320,7 @@
 	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname (node, " [Operation Region]"));
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] Op_region Init at AML %p\n",
-		(char *) &node->name, extra_desc->extra.aml_start));
+		node->name.ascii, extra_desc->extra.aml_start));
 
 
 	status = acpi_ds_execute_arguments (node, acpi_ns_get_parent_node (node),
@@ -337,7 +337,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION:
+ * DESCRIPTION: Front end to Ev_initialize_region
  *
  ****************************************************************************/
 
@@ -360,110 +360,76 @@
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ds_eval_buffer_field_operands
+ * FUNCTION:    Acpi_ds_init_buffer_field
  *
- * PARAMETERS:  Op              - A valid Buffer_field Op object
+ * PARAMETERS:  Aml_opcode      - Create_xxx_field
+ *              Obj_desc        - Buffer_field object
+ *              Buffer_desc     - Host Buffer
+ *              Offset_desc     - Offset into buffer
+ *              Length          - Length of field (CREATE_FIELD_OP only)
+ *              Result          - Where to store the result
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Get Buffer_field Buffer and Index
- *              Called from Acpi_ds_exec_end_op during Buffer_field parse tree walk
+ * DESCRIPTION: Perform actual initialization of a buffer field
  *
  ****************************************************************************/
 
 acpi_status
-acpi_ds_eval_buffer_field_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op)
+acpi_ds_init_buffer_field (
+	u16                     aml_opcode,
+	acpi_operand_object     *obj_desc,
+	acpi_operand_object     *buffer_desc,
+	acpi_operand_object     *offset_desc,
+	acpi_operand_object     *length_desc,
+	acpi_operand_object     *result_desc)
 {
-	acpi_status             status;
-	acpi_operand_object     *obj_desc;
-	acpi_namespace_node     *node;
-	acpi_parse_object       *next_op;
 	u32                     offset;
 	u32                     bit_offset;
 	u32                     bit_count;
 	u8                      field_flags;
-	acpi_operand_object     *res_desc = NULL;
-	acpi_operand_object     *cnt_desc = NULL;
-	acpi_operand_object     *off_desc = NULL;
-	acpi_operand_object     *src_desc = NULL;
-
-
-	ACPI_FUNCTION_TRACE_PTR ("Ds_eval_buffer_field_operands", op);
-
-
-	/*
-	 * This is where we evaluate the address and length fields of the
-	 * Create_xxx_field declaration
-	 */
-	node =  op->node;
-
-	/* Next_op points to the op that holds the Buffer */
+	acpi_status             status;
 
-	next_op = op->value.arg;
 
-	/* Evaluate/create the address and length operands */
+	ACPI_FUNCTION_TRACE_PTR ("Ds_init_buffer_field", obj_desc);
 
-	status = acpi_ds_create_operands (walk_state, next_op);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
 
-	obj_desc = acpi_ns_get_attached_object (node);
-	if (!obj_desc) {
-		return_ACPI_STATUS (AE_NOT_EXIST);
-	}
-
-	/* Resolve the operands */
-
-	status = acpi_ex_resolve_operands (op->opcode, ACPI_WALK_OPERANDS, walk_state);
-	ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE, acpi_ps_get_opcode_name (op->opcode),
-			  walk_state->num_operands, "after Acpi_ex_resolve_operands");
+	/* Host object must be a Buffer */
 
-	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) bad operand(s) (%X)\n",
-			acpi_ps_get_opcode_name (op->opcode), status));
+	if (buffer_desc->common.type != ACPI_TYPE_BUFFER) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Target of Create Field is not a Buffer object - %s\n",
+			acpi_ut_get_type_name (buffer_desc->common.type)));
 
+		status = AE_AML_OPERAND_TYPE;
 		goto cleanup;
 	}
 
-	/* Get the operands */
-
-	if (AML_CREATE_FIELD_OP == op->opcode) {
-		res_desc = walk_state->operands[3];
-		cnt_desc = walk_state->operands[2];
-	}
-	else {
-		res_desc = walk_state->operands[2];
-	}
-
-	off_desc = walk_state->operands[1];
-	src_desc = walk_state->operands[0];
-	offset  = (u32) off_desc->integer.value;
-
 	/*
-	 * If Res_desc is a Name, it will be a direct name pointer after
-	 * Acpi_ex_resolve_operands()
+	 * The last parameter to all of these opcodes (Result_desc) started
+	 * out as a Name_string, and should therefore now be a NS node
+	 * after resolution in Acpi_ex_resolve_operands().
 	 */
-	if (ACPI_GET_DESCRIPTOR_TYPE (res_desc) != ACPI_DESC_TYPE_NAMED) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (result_desc) != ACPI_DESC_TYPE_NAMED) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) destination must be a NS Node\n",
-			acpi_ps_get_opcode_name (op->opcode)));
+			acpi_ps_get_opcode_name (aml_opcode)));
 
 		status = AE_AML_OPERAND_TYPE;
 		goto cleanup;
 	}
 
+	offset = (u32) offset_desc->integer.value;
+
 	/*
 	 * Setup the Bit offsets and counts, according to the opcode
 	 */
-	switch (op->opcode) {
+	switch (aml_opcode) {
 	case AML_CREATE_FIELD_OP:
 
 		/* Offset is in bits, count is in bits */
 
-		bit_offset  = offset;
-		bit_count   = (u32) cnt_desc->integer.value;
+		bit_offset = offset;
+		bit_count  = (u32) length_desc->integer.value;
 		field_flags = AML_FIELD_ACCESS_BYTE;
 		break;
 
@@ -471,8 +437,8 @@
 
 		/* Offset is in bits, Field is one bit */
 
-		bit_offset  = offset;
-		bit_count   = 1;
+		bit_offset = offset;
+		bit_count  = 1;
 		field_flags = AML_FIELD_ACCESS_BYTE;
 		break;
 
@@ -480,8 +446,8 @@
 
 		/* Offset is in bytes, field is one byte */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 8;
+		bit_offset = 8 * offset;
+		bit_count  = 8;
 		field_flags = AML_FIELD_ACCESS_BYTE;
 		break;
 
@@ -489,8 +455,8 @@
 
 		/* Offset is in bytes, field is one word */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 16;
+		bit_offset = 8 * offset;
+		bit_count  = 16;
 		field_flags = AML_FIELD_ACCESS_WORD;
 		break;
 
@@ -498,8 +464,8 @@
 
 		/* Offset is in bytes, field is one dword */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 32;
+		bit_offset = 8 * offset;
+		bit_count  = 32;
 		field_flags = AML_FIELD_ACCESS_DWORD;
 		break;
 
@@ -507,105 +473,157 @@
 
 		/* Offset is in bytes, field is one qword */
 
-		bit_offset  = 8 * offset;
-		bit_count   = 64;
+		bit_offset = 8 * offset;
+		bit_count  = 64;
 		field_flags = AML_FIELD_ACCESS_QWORD;
 		break;
 
 	default:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Internal error - unknown field creation opcode %02x\n",
-			op->opcode));
+			"Unknown field creation opcode %02x\n",
+			aml_opcode));
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
 
+
+	/* Entire field must fit within the current length of the buffer */
+
+	if ((bit_offset + bit_count) >
+		(8 * (u32) buffer_desc->buffer.length)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"Field size %d exceeds Buffer size %d (bits)\n",
+			 bit_offset + bit_count, 8 * (u32) buffer_desc->buffer.length));
+		status = AE_AML_BUFFER_LIMIT;
+		goto cleanup;
+	}
+
 	/*
-	 * Setup field according to the object type
+	 * Initialize areas of the field object that are common to all fields
+	 * For Field_flags, use LOCK_RULE = 0 (NO_LOCK), UPDATE_RULE = 0 (UPDATE_PRESERVE)
 	 */
-	switch (src_desc->common.type) {
-
-	/* Source_buff :=  Term_arg=>Buffer */
+	status = acpi_ex_prep_common_field_object (obj_desc, field_flags, 0,
+			  bit_offset, bit_count);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
 
-	case ACPI_TYPE_BUFFER:
+	obj_desc->buffer_field.buffer_obj = buffer_desc;
 
-		if ((bit_offset + bit_count) >
-			(8 * (u32) src_desc->buffer.length)) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Field size %d exceeds Buffer size %d (bits)\n",
-				 bit_offset + bit_count, 8 * (u32) src_desc->buffer.length));
-			status = AE_AML_BUFFER_LIMIT;
-			goto cleanup;
-		}
+	/* Reference count for Buffer_desc inherits Obj_desc count */
 
-		/*
-		 * Initialize areas of the field object that are common to all fields
-		 * For Field_flags, use LOCK_RULE = 0 (NO_LOCK), UPDATE_RULE = 0 (UPDATE_PRESERVE)
-		 */
-		status = acpi_ex_prep_common_field_object (obj_desc, field_flags, 0,
-				  bit_offset, bit_count);
-		if (ACPI_FAILURE (status)) {
-			return_ACPI_STATUS (status);
-		}
+	buffer_desc->common.reference_count = (u16) (buffer_desc->common.reference_count +
+			  obj_desc->common.reference_count);
 
-		obj_desc->buffer_field.buffer_obj = src_desc;
 
-		/* Reference count for Src_desc inherits Obj_desc count */
+cleanup:
 
-		src_desc->common.reference_count = (u16) (src_desc->common.reference_count +
-				  obj_desc->common.reference_count);
-		break;
+	/* Always delete the operands */
 
+	acpi_ut_remove_reference (offset_desc);
+	acpi_ut_remove_reference (buffer_desc);
 
-	/* Improper object type */
+	if (aml_opcode == AML_CREATE_FIELD_OP) {
+		acpi_ut_remove_reference (length_desc);
+	}
 
-	default:
+	/* On failure, delete the result descriptor */
 
-		if ((src_desc->common.type > (u8) INTERNAL_TYPE_REFERENCE) || !acpi_ut_valid_object_type (src_desc->common.type)) /* This line MUST be a single line until Acpi_src can handle it (block deletion) */ {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Tried to create field in invalid object type %X\n",
-				src_desc->common.type));
-		}
-		else {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Tried to create field in improper object type - %s\n",
-				acpi_ut_get_type_name (src_desc->common.type)));
-		}
+	if (ACPI_FAILURE (status)) {
+		acpi_ut_remove_reference (result_desc); /* Result descriptor */
+	}
+	else {
+		/* Now the address and length are valid for this Buffer_field */
 
-		status = AE_AML_OPERAND_TYPE;
-		goto cleanup;
+		obj_desc->buffer_field.flags |= AOPOBJ_DATA_VALID;
 	}
 
+	return_ACPI_STATUS (status);
+}
 
-	if (AML_CREATE_FIELD_OP == op->opcode) {
-		/* Delete object descriptor unique to Create_field */
 
-		acpi_ut_remove_reference (cnt_desc);
-		cnt_desc = NULL;
-	}
+/*****************************************************************************
+ *
+ * FUNCTION:    Acpi_ds_eval_buffer_field_operands
+ *
+ * PARAMETERS:  Walk_state      - Current walk
+ *              Op              - A valid Buffer_field Op object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get Buffer_field Buffer and Index
+ *              Called from Acpi_ds_exec_end_op during Buffer_field parse tree walk
+ *
+ ****************************************************************************/
 
+acpi_status
+acpi_ds_eval_buffer_field_operands (
+	acpi_walk_state         *walk_state,
+	acpi_parse_object       *op)
+{
+	acpi_status             status;
+	acpi_operand_object     *obj_desc;
+	acpi_namespace_node     *node;
+	acpi_parse_object       *next_op;
 
-cleanup:
 
-	/* Always delete the operands */
+	ACPI_FUNCTION_TRACE_PTR ("Ds_eval_buffer_field_operands", op);
+
+
+	/*
+	 * This is where we evaluate the address and length fields of the
+	 * Create_xxx_field declaration
+	 */
+	node =  op->common.node;
+
+	/* Next_op points to the op that holds the Buffer */
 
-	acpi_ut_remove_reference (off_desc);
-	acpi_ut_remove_reference (src_desc);
+	next_op = op->common.value.arg;
+
+	/* Evaluate/create the address and length operands */
+
+	status = acpi_ds_create_operands (walk_state, next_op);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	if (AML_CREATE_FIELD_OP == op->opcode) {
-		acpi_ut_remove_reference (cnt_desc);
+	obj_desc = acpi_ns_get_attached_object (node);
+	if (!obj_desc) {
+		return_ACPI_STATUS (AE_NOT_EXIST);
 	}
 
-	/* On failure, delete the result descriptor */
+	/* Resolve the operands */
+
+	status = acpi_ex_resolve_operands (op->common.aml_opcode,
+			  ACPI_WALK_OPERANDS, walk_state);
+
+	ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
+			  acpi_ps_get_opcode_name (op->common.aml_opcode),
+			  walk_state->num_operands, "after Acpi_ex_resolve_operands");
 
 	if (ACPI_FAILURE (status)) {
-		acpi_ut_remove_reference (res_desc); /* Result descriptor */
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "(%s) bad operand(s) (%X)\n",
+			acpi_ps_get_opcode_name (op->common.aml_opcode), status));
+
+		return_ACPI_STATUS (status);
+	}
+
+	/* Initialize the Buffer Field */
+
+	if (op->common.aml_opcode == AML_CREATE_FIELD_OP) {
+		/* NOTE: Slightly different operands for this opcode */
+
+		status = acpi_ds_init_buffer_field (op->common.aml_opcode, obj_desc,
+				 walk_state->operands[0], walk_state->operands[1],
+				 walk_state->operands[2], walk_state->operands[3]);
 	}
 	else {
-		/* Now the address and length are valid for this Buffer_field */
+		/* All other, Create_xxx_field opcodes */
 
-		obj_desc->buffer_field.flags |= AOPOBJ_DATA_VALID;
+		status = acpi_ds_init_buffer_field (op->common.aml_opcode, obj_desc,
+				 walk_state->operands[0], walk_state->operands[1],
+						  NULL, walk_state->operands[2]);
 	}
 
 	return_ACPI_STATUS (status);
@@ -616,7 +634,8 @@
  *
  * FUNCTION:    Acpi_ds_eval_region_operands
  *
- * PARAMETERS:  Op              - A valid region Op object
+ * PARAMETERS:  Walk_state      - Current walk
+ *              Op              - A valid region Op object
  *
  * RETURN:      Status
  *
@@ -643,15 +662,15 @@
 	/*
 	 * This is where we evaluate the address and length fields of the Op_region declaration
 	 */
-	node =  op->node;
+	node =  op->common.node;
 
 	/* Next_op points to the op that holds the Space_iD */
 
-	next_op = op->value.arg;
+	next_op = op->common.value.arg;
 
 	/* Next_op points to address op */
 
-	next_op = next_op->next;
+	next_op = next_op->common.next;
 
 	/* Evaluate/create the address and length operands */
 
@@ -662,13 +681,13 @@
 
 	/* Resolve the length and address operands to numbers */
 
-	status = acpi_ex_resolve_operands (op->opcode, ACPI_WALK_OPERANDS, walk_state);
+	status = acpi_ex_resolve_operands (op->common.aml_opcode, ACPI_WALK_OPERANDS, walk_state);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
 	ACPI_DUMP_OPERANDS (ACPI_WALK_OPERANDS, ACPI_IMODE_EXECUTE,
-			  acpi_ps_get_opcode_name (op->opcode),
+			  acpi_ps_get_opcode_name (op->common.aml_opcode),
 			  1, "after Acpi_ex_resolve_operands");
 
 	obj_desc = acpi_ns_get_attached_object (node);
@@ -711,7 +730,9 @@
  *
  * FUNCTION:    Acpi_ds_eval_data_object_operands
  *
- * PARAMETERS:  Op              - A valid Data_object Op object
+ * PARAMETERS:  Walk_state      - Current walk
+ *              Op              - A valid Data_object Op object
+ *              Obj_desc        - Data_object
  *
  * RETURN:      Status
  *
@@ -737,7 +758,7 @@
 
 	/* The first operand (for all of these data objects) is the length */
 
-	status = acpi_ds_create_operand (walk_state, op->value.arg, 1);
+	status = acpi_ds_create_operand (walk_state, op->common.value.arg, 1);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -756,13 +777,17 @@
 
 	/* Cleanup for length operand */
 
-	acpi_ds_obj_stack_pop (1, walk_state);
+	status = acpi_ds_obj_stack_pop (1, walk_state);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
 	acpi_ut_remove_reference (arg_desc);
 
 	/*
 	 * Create the actual data object
 	 */
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_BUFFER_OP:
 
 		status = acpi_ds_build_internal_buffer_obj (walk_state, op, length, &obj_desc);
@@ -784,10 +809,10 @@
 		 * in this case, the return object will be stored in the parse tree
 		 * for the package.
 		 */
-		if ((!op->parent) ||
-			((op->parent->opcode != AML_PACKAGE_OP) &&
-			 (op->parent->opcode != AML_VAR_PACKAGE_OP) &&
-			 (op->parent->opcode != AML_NAME_OP))) {
+		if ((!op->common.parent) ||
+			((op->common.parent->common.aml_opcode != AML_PACKAGE_OP) &&
+			 (op->common.parent->common.aml_opcode != AML_VAR_PACKAGE_OP) &&
+			 (op->common.parent->common.aml_opcode != AML_NAME_OP))) {
 			walk_state->result_obj = obj_desc;
 		}
 	}
@@ -823,9 +848,9 @@
 
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p Opcode=%2.2X State=%p\n", op,
-		op->opcode, walk_state));
+		op->common.aml_opcode, walk_state));
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_IF_OP:
 	case AML_WHILE_OP:
 
@@ -845,7 +870,7 @@
 		 */
 		control_state->control.aml_predicate_start = walk_state->parser_state.aml - 1;
 		control_state->control.package_end = walk_state->parser_state.pkg_end;
-		control_state->control.opcode = op->opcode;
+		control_state->control.opcode = op->common.aml_opcode;
 
 
 		/* Push the control state on this walk's control stack */
@@ -902,7 +927,7 @@
 	ACPI_FUNCTION_NAME ("Ds_exec_end_control_op");
 
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_IF_OP:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[IF_OP] Op=%p\n", op));
@@ -952,17 +977,17 @@
 	case AML_RETURN_OP:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-			"[RETURN_OP] Op=%p Arg=%p\n",op, op->value.arg));
+			"[RETURN_OP] Op=%p Arg=%p\n",op, op->common.value.arg));
 
 		/*
 		 * One optional operand -- the return value
 		 * It can be either an immediate operand or a result that
 		 * has been bubbled up the tree
 		 */
-		if (op->value.arg) {
+		if (op->common.value.arg) {
 			/* Return statement has an immediate operand */
 
-			status = acpi_ds_create_operands (walk_state, op->value.arg);
+			status = acpi_ds_create_operands (walk_state, op->common.value.arg);
 			if (ACPI_FAILURE (status)) {
 				return (status);
 			}
@@ -995,7 +1020,7 @@
 			 *
 			 * Allow references created by the Index operator to return unchanged.
 			 */
-			if ((ACPI_GET_DESCRIPTOR_TYPE (walk_state->results->results.obj_desc[0]) == ACPI_DESC_TYPE_INTERNAL) &&
+			if ((ACPI_GET_DESCRIPTOR_TYPE (walk_state->results->results.obj_desc[0]) == ACPI_DESC_TYPE_OPERAND) &&
 				((walk_state->results->results.obj_desc [0])->common.type == INTERNAL_TYPE_REFERENCE) &&
 				((walk_state->results->results.obj_desc [0])->reference.opcode != AML_INDEX_OP)) {
 				status = acpi_ex_resolve_to_value (&walk_state->results->results.obj_desc [0], walk_state);
@@ -1039,7 +1064,7 @@
 
 		/* Call up to the OS service layer to handle this */
 
-		acpi_os_signal (ACPI_SIGNAL_BREAKPOINT, "Executed AML Breakpoint opcode");
+		status = acpi_os_signal (ACPI_SIGNAL_BREAKPOINT, "Executed AML Breakpoint opcode");
 
 		/* If and when it returns, all done. */
 
@@ -1070,7 +1095,7 @@
 
 		/* Return status depending on opcode */
 
-		if (op->opcode == AML_BREAK_OP) {
+		if (op->common.aml_opcode == AML_BREAK_OP) {
 			status = AE_CTRL_BREAK;
 		}
 		else {
@@ -1082,7 +1107,7 @@
 	default:
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown control opcode=%X Op=%p\n",
-			op->opcode, op));
+			op->common.aml_opcode, op));
 
 		status = AE_AML_BAD_OPCODE;
 		break;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dsutils.c linux/drivers/acpi/dispatcher/dsutils.c
--- ../prev/linux/drivers/acpi/dispatcher/dsutils.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/dispatcher/dsutils.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: dsutils - Dispatcher utilities
- *              $Revision: 89 $
+ *              $Revision: 92 $
  *
  ******************************************************************************/
 
@@ -74,14 +74,14 @@
 	 * method is parsed separately)  However, a method that is
 	 * invoked from another method has a parent.
 	 */
-	if (!op->parent) {
+	if (!op->common.parent) {
 		return_VALUE (FALSE);
 	}
 
 	/*
 	 * Get info on the parent.  The root Op is AML_SCOPE
 	 */
-	parent_info = acpi_ps_get_opcode_info (op->parent->opcode);
+	parent_info = acpi_ps_get_opcode_info (op->common.parent->common.aml_opcode);
 	if (parent_info->class == AML_CLASS_UNKNOWN) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown parent opcode. Op=%p\n", op));
 		return_VALUE (FALSE);
@@ -96,7 +96,7 @@
 	switch (parent_info->class) {
 	case AML_CLASS_CONTROL:
 
-		switch (op->parent->opcode) {
+		switch (op->common.parent->common.aml_opcode) {
 		case AML_RETURN_OP:
 
 			/* Never delete the return value associated with a return opcode */
@@ -114,6 +114,11 @@
 				(walk_state->control_state->control.predicate_op == op)) {
 				goto result_used;
 			}
+			break;
+
+		default:
+			/* Ignore other control opcodes */
+			break;
 		}
 
 		/* The general control opcode returns no result */
@@ -132,12 +137,12 @@
 
 	case AML_CLASS_NAMED_OBJECT:
 
-		if ((op->parent->opcode == AML_REGION_OP)       ||
-			(op->parent->opcode == AML_DATA_REGION_OP)  ||
-			(op->parent->opcode == AML_PACKAGE_OP)      ||
-			(op->parent->opcode == AML_VAR_PACKAGE_OP)  ||
-			(op->parent->opcode == AML_BUFFER_OP)       ||
-			(op->parent->opcode == AML_INT_EVAL_SUBTREE_OP)) {
+		if ((op->common.parent->common.aml_opcode == AML_REGION_OP)      ||
+			(op->common.parent->common.aml_opcode == AML_DATA_REGION_OP) ||
+			(op->common.parent->common.aml_opcode == AML_PACKAGE_OP)     ||
+			(op->common.parent->common.aml_opcode == AML_VAR_PACKAGE_OP) ||
+			(op->common.parent->common.aml_opcode == AML_BUFFER_OP)      ||
+			(op->common.parent->common.aml_opcode == AML_INT_EVAL_SUBTREE_OP)) {
 			/*
 			 * These opcodes allow Term_arg(s) as operands and therefore
 			 * the operands can be method calls.  The result is used.
@@ -160,16 +165,16 @@
 
 result_used:
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] used by Parent [%s] Op=%p\n",
-			acpi_ps_get_opcode_name (op->opcode),
-			acpi_ps_get_opcode_name (op->parent->opcode), op));
+			acpi_ps_get_opcode_name (op->common.aml_opcode),
+			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
 
 	return_VALUE (TRUE);
 
 
 result_not_used:
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Result of [%s] not used by Parent [%s] Op=%p\n",
-			acpi_ps_get_opcode_name (op->opcode),
-			acpi_ps_get_opcode_name (op->parent->opcode), op));
+			acpi_ps_get_opcode_name (op->common.aml_opcode),
+			acpi_ps_get_opcode_name (op->common.parent->common.aml_opcode), op));
 
 	return_VALUE (FALSE);
 
@@ -253,6 +258,7 @@
 	u32                     arg_index)
 {
 	acpi_status             status = AE_OK;
+	acpi_status             status2;
 	NATIVE_CHAR             *name_string;
 	u32                     name_length;
 	acpi_operand_object     *obj_desc;
@@ -268,13 +274,13 @@
 
 	/* A valid name must be looked up in the namespace */
 
-	if ((arg->opcode == AML_INT_NAMEPATH_OP) &&
-		(arg->value.string)) {
+	if ((arg->common.aml_opcode == AML_INT_NAMEPATH_OP) &&
+		(arg->common.value.string)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Getting a name: Arg=%p\n", arg));
 
 		/* Get the entire name string from the AML stream */
 
-		status = acpi_ex_get_name_string (ACPI_TYPE_ANY, arg->value.buffer,
+		status = acpi_ex_get_name_string (ACPI_TYPE_ANY, arg->common.value.buffer,
 				  &name_string, &name_length);
 
 		if (ACPI_FAILURE (status)) {
@@ -292,12 +298,12 @@
 		 * IMODE_EXECUTE) in order to support the creation of
 		 * namespace objects during the execution of control methods.
 		 */
-		parent_op = arg->parent;
-		op_info = acpi_ps_get_opcode_info (parent_op->opcode);
+		parent_op = arg->common.parent;
+		op_info = acpi_ps_get_opcode_info (parent_op->common.aml_opcode);
 		if ((op_info->flags & AML_NSNODE) &&
-			(parent_op->opcode != AML_INT_METHODCALL_OP) &&
-			(parent_op->opcode != AML_REGION_OP) &&
-			(parent_op->opcode != AML_INT_NAMEPATH_OP)) {
+			(parent_op->common.aml_opcode != AML_INT_METHODCALL_OP) &&
+			(parent_op->common.aml_opcode != AML_REGION_OP) &&
+			(parent_op->common.aml_opcode != AML_INT_NAMEPATH_OP)) {
 			/* Enter name into namespace if not found */
 
 			interpreter_mode = ACPI_IMODE_LOAD_PASS2;
@@ -313,20 +319,20 @@
 				 ACPI_TYPE_ANY, interpreter_mode,
 				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
 				 walk_state,
-				 (acpi_namespace_node **) &obj_desc);
+				 ACPI_CAST_INDIRECT_PTR (acpi_namespace_node, &obj_desc));
 		/*
 		 * The only case where we pass through (ignore) a NOT_FOUND
 		 * error is for the Cond_ref_of opcode.
 		 */
 		if (status == AE_NOT_FOUND) {
-			if (parent_op->opcode == AML_COND_REF_OF_OP) {
+			if (parent_op->common.aml_opcode == AML_COND_REF_OF_OP) {
 				/*
 				 * For the Conditional Reference op, it's OK if
 				 * the name is not found;  We just need a way to
 				 * indicate this to the interpreter, set the
 				 * object to the root
 				 */
-				obj_desc = (acpi_operand_object *) acpi_gbl_root_node;
+				obj_desc = ACPI_CAST_PTR (acpi_operand_object, acpi_gbl_root_node);
 				status = AE_OK;
 			}
 
@@ -338,10 +344,12 @@
 				status = AE_AML_NAME_NOT_FOUND;
 
 				name = NULL;
-				acpi_ns_externalize_name (ACPI_UINT32_MAX, name_string, NULL, &name);
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-						"Object name [%s] was not found in namespace\n", name));
-				ACPI_MEM_FREE (name);
+				status2 = acpi_ns_externalize_name (ACPI_UINT32_MAX, name_string, NULL, &name);
+				if (ACPI_SUCCESS (status2)) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+							"Object name [%s] was not found in namespace\n", name));
+					ACPI_MEM_FREE (name);
+				}
 			}
 		}
 
@@ -368,7 +376,7 @@
 	else {
 		/* Check for null name case */
 
-		if (arg->opcode == AML_INT_NAMEPATH_OP) {
+		if (arg->common.aml_opcode == AML_INT_NAMEPATH_OP) {
 			/*
 			 * If the name is null, this means that this is an
 			 * optional result parameter that was not specified
@@ -381,7 +389,7 @@
 		}
 
 		else {
-			opcode = arg->opcode;
+			opcode = arg->common.aml_opcode;
 		}
 
 		/* Get the object type of the argument */
@@ -413,7 +421,6 @@
 				return_ACPI_STATUS (status);
 			}
 		}
-
 		else {
 			/* Create an ACPI_INTERNAL_OBJECT for the argument */
 
@@ -430,7 +437,7 @@
 				acpi_ut_delete_object_desc (obj_desc);
 				return_ACPI_STATUS (status);
 			}
-	   }
+		}
 
 		/* Put the operand object on the object stack */
 
@@ -487,7 +494,7 @@
 
 		/* Move on to next argument, if any */
 
-		arg = arg->next;
+		arg = arg->common.next;
 		arg_count++;
 	}
 
@@ -500,7 +507,7 @@
 	 * pop everything off of the operand stack and delete those
 	 * objects
 	 */
-	acpi_ds_obj_stack_pop_and_delete (arg_count, walk_state);
+	(void) acpi_ds_obj_stack_pop_and_delete (arg_count, walk_state);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "While creating Arg %d - %s\n",
 		(arg_count + 1), acpi_format_exception (status)));
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dswexec.c linux/drivers/acpi/dispatcher/dswexec.c
--- ../prev/linux/drivers/acpi/dispatcher/dswexec.c	Tue Jul  9 18:04:00 2002
+++ linux/drivers/acpi/dispatcher/dswexec.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: dswexec - Dispatcher method execution callbacks;
  *                        dispatch to interpreter.
- *              $Revision: 90 $
+ *              $Revision: 92 $
  *
  *****************************************************************************/
 
@@ -40,7 +40,7 @@
 /*
  * Dispatch table for opcode classes
  */
-ACPI_EXECUTE_OP         acpi_gbl_op_type_dispatch [] = {
+static ACPI_EXECUTE_OP      acpi_gbl_op_type_dispatch [] = {
 			 acpi_ex_opcode_1A_0T_0R,
 			 acpi_ex_opcode_1A_0T_1R,
 			 acpi_ex_opcode_1A_1T_0R,
@@ -200,13 +200,17 @@
 
 		op = *out_op;
 		walk_state->op = op;
-		walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-		walk_state->opcode = op->opcode;
+		walk_state->opcode = op->common.aml_opcode;
+		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 
 		if (acpi_ns_opens_scope (walk_state->op_info->object_type)) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
 				acpi_ut_get_type_name (walk_state->op_info->object_type), op));
-			acpi_ds_scope_stack_pop (walk_state);
+
+			status = acpi_ds_scope_stack_pop (walk_state);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
 		}
 	}
 
@@ -241,7 +245,7 @@
 
 	/* We want to send namepaths to the load code */
 
-	if (op->opcode == AML_INT_NAMEPATH_OP) {
+	if (op->common.aml_opcode == AML_INT_NAMEPATH_OP) {
 		opcode_class = AML_CLASS_NAMED_OBJECT;
 	}
 
@@ -273,7 +277,7 @@
 			status = acpi_ds_load2_begin_op (walk_state, NULL);
 		}
 
-		if (op->opcode == AML_REGION_OP) {
+		if (op->common.aml_opcode == AML_REGION_OP) {
 			status = acpi_ds_result_stack_push (walk_state);
 		}
 		break;
@@ -336,11 +340,11 @@
 	op_class = walk_state->op_info->class;
 
 	if (op_class == AML_CLASS_UNKNOWN) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown opcode %X\n", op->opcode));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown opcode %X\n", op->common.aml_opcode));
 		return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
 	}
 
-	first_arg = op->value.arg;
+	first_arg = op->common.value.arg;
 
 	/* Init the walk state */
 
@@ -432,8 +436,11 @@
 			/* 1 Operand, 0 External_result, 0 Internal_result */
 
 			status = acpi_ds_exec_end_control_op (walk_state, op);
+			if (ACPI_FAILURE (status)) {
+				break;
+			}
 
-			acpi_ds_result_stack_pop (walk_state);
+			status = acpi_ds_result_stack_pop (walk_state);
 			break;
 
 
@@ -451,7 +458,7 @@
 
 			/* Next_op points to first argument op */
 
-			next_op = next_op->next;
+			next_op = next_op->common.next;
 
 			/*
 			 * Get the method's arguments and put them on the operand stack
@@ -503,26 +510,28 @@
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 				"Executing Create_object (Buffer/Package) Op=%p\n", op));
 
-			switch (op->parent->opcode) {
+			switch (op->common.parent->common.aml_opcode) {
 			case AML_NAME_OP:
 
 				/*
 				 * Put the Node on the object stack (Contains the ACPI Name of
 				 * this object)
 				 */
-				walk_state->operands[0] = (void *) op->parent->node;
+				walk_state->operands[0] = (void *) op->common.parent->common.node;
 				walk_state->num_operands = 1;
 
-				status = acpi_ds_create_node (walk_state, op->parent->node, op->parent);
+				status = acpi_ds_create_node (walk_state, op->common.parent->common.node, op->common.parent);
 				if (ACPI_FAILURE (status)) {
 					break;
 				}
 
 				/* Fall through */
+				/*lint -fallthrough */
 
 			case AML_INT_EVAL_SUBTREE_OP:
 
-				status = acpi_ds_eval_data_object_operands (walk_state, op, acpi_ns_get_attached_object (op->parent->node));
+				status = acpi_ds_eval_data_object_operands (walk_state, op,
+						  acpi_ns_get_attached_object (op->common.parent->common.node));
 				break;
 
 			default:
@@ -552,7 +561,7 @@
 				break;
 			}
 
-			if (op->opcode == AML_REGION_OP) {
+			if (op->common.aml_opcode == AML_REGION_OP) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 					"Executing Op_region Address/Length Op=%p\n", op));
 
@@ -585,7 +594,7 @@
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Unimplemented opcode, class=%X type=%X Opcode=%X Op=%p\n",
-				op_class, op_type, op->opcode, op));
+				op_class, op_type, op->common.aml_opcode, op));
 
 			status = AE_NOT_IMPLEMENTED;
 			break;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dswload.c linux/drivers/acpi/dispatcher/dswload.c
--- ../prev/linux/drivers/acpi/dispatcher/dswload.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/dispatcher/dswload.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: dswload - Dispatcher namespace load callbacks
- *              $Revision: 62 $
+ *              $Revision: 66 $
  *
  *****************************************************************************/
 
@@ -115,21 +115,21 @@
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op, walk_state));
 
 
-	if (op && (op->opcode == AML_INT_NAMEDFIELD_OP)) {
+	if (op && (op->common.aml_opcode == AML_INT_NAMEDFIELD_OP)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op=%p State=%p\n", op, walk_state));
 	}
 
 	/* We are only interested in opcodes that have an associated name */
 
-	if (walk_state->op) {
-	   if (!(walk_state->op_info->flags & AML_NAMED)) {
+	if (op) {
+		if (!(walk_state->op_info->flags & AML_NAMED)) {
 			*out_op = op;
 			return (AE_OK);
 		}
 
 		/* Check if this object has already been installed in the namespace */
 
-		if (op->node) {
+		if (op->common.node) {
 			*out_op = op;
 			return (AE_OK);
 		}
@@ -142,7 +142,7 @@
 	object_type = walk_state->op_info->object_type;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"State=%p Op=%p Type=%x\n", walk_state, op, object_type));
+		"State=%p Op=%p Type=%X\n", walk_state, op, object_type));
 
 	/*
 	 * Enter the named type into the internal namespace.  We enter the name
@@ -167,13 +167,13 @@
 
 	/* Initialize */
 
-	((acpi_parse2_object *)op)->name = node->name.integer;
+	op->named.name = node->name.integer;
 
 	/*
 	 * Put the Node in the "op" object that the parser uses, so we
 	 * can get it again quickly when this scope is closed
 	 */
-	op->node = node;
+	op->common.node = node;
 	acpi_ps_append_arg (acpi_ps_get_parent_scope (&walk_state->parser_state), op);
 
 	*out_op = op;
@@ -202,6 +202,7 @@
 {
 	acpi_parse_object       *op;
 	acpi_object_type        object_type;
+	acpi_status             status = AE_OK;
 
 
 	ACPI_FUNCTION_NAME ("Ds_load1_end_op");
@@ -224,24 +225,26 @@
 		if (walk_state->opcode == AML_FIELD_OP         ||
 			walk_state->opcode == AML_BANK_FIELD_OP    ||
 			walk_state->opcode == AML_INDEX_FIELD_OP) {
-			acpi_ds_init_field_objects (op, walk_state);
+			status = acpi_ds_init_field_objects (op, walk_state);
 		}
-		return (AE_OK);
+		return (status);
 	}
 
 
-	if (op->opcode == AML_REGION_OP) {
-		/*Status = */acpi_ex_create_region (((acpi_parse2_object *) op)->data,
-				  ((acpi_parse2_object *) op)->length,
-						 (ACPI_ADR_SPACE_TYPE) ((op->value.arg)->value.integer), walk_state);
+	if (op->common.aml_opcode == AML_REGION_OP) {
+		status = acpi_ex_create_region (op->named.data, op->named.length,
+				   (ACPI_ADR_SPACE_TYPE) ((op->common.value.arg)->common.value.integer), walk_state);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
 	}
 
-	if (op->opcode == AML_NAME_OP) {
+	if (op->common.aml_opcode == AML_NAME_OP) {
 		/* For Name opcode, get the object type from the argument */
 
-		if (op->value.arg) {
-			object_type = (acpi_ps_get_opcode_info ((op->value.arg)->opcode))->object_type;
-			op->node->type = (u8) object_type;
+		if (op->common.value.arg) {
+			object_type = (acpi_ps_get_opcode_info ((op->common.value.arg)->common.aml_opcode))->object_type;
+			op->common.node->type = (u8) object_type;
 		}
 	}
 
@@ -251,10 +254,10 @@
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s): Popping scope for Op %p\n",
 			acpi_ut_get_type_name (object_type), op));
 
-		acpi_ds_scope_stack_pop (walk_state);
+		status = acpi_ds_scope_stack_pop (walk_state);
 	}
 
-	return (AE_OK);
+	return (status);
 }
 
 
@@ -282,7 +285,6 @@
 	acpi_status             status;
 	acpi_object_type        object_type;
 	NATIVE_CHAR             *buffer_ptr;
-	void                    *original = NULL;
 
 
 	ACPI_FUNCTION_NAME ("Ds_load2_begin_op");
@@ -305,7 +307,7 @@
 		if (walk_state->opcode == AML_INT_NAMEPATH_OP) {
 			/* For Namepath op, get the path string */
 
-			buffer_ptr = op->value.string;
+			buffer_ptr = op->common.value.string;
 			if (!buffer_ptr) {
 				/* No name, just exit */
 
@@ -315,7 +317,7 @@
 		else {
 			/* Get name from the op */
 
-			buffer_ptr = (NATIVE_CHAR *) &((acpi_parse2_object *)op)->name;
+			buffer_ptr = (NATIVE_CHAR *) &op->named.name;
 		}
 	}
 	else {
@@ -329,7 +331,7 @@
 	object_type = walk_state->op_info->object_type;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"State=%p Op=%p Type=%x\n", walk_state, op, object_type));
+		"State=%p Op=%p Type=%X\n", walk_state, op, object_type));
 
 
 	if (walk_state->opcode == AML_FIELD_OP         ||
@@ -347,9 +349,12 @@
 				  ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, walk_state, &(node));
 	}
 	else {
-		if (op && op->node) {
-			original = op->node;
-			node = op->node;
+		/* All other opcodes */
+
+		if (op && op->common.node) {
+			/* This op/node was previously entered into the namespace */
+
+			node = op->common.node;
 
 			if (acpi_ns_opens_scope (object_type)) {
 				status = acpi_ds_scope_stack_push (node, object_type, walk_state);
@@ -381,24 +386,19 @@
 
 			/* Initialize the new op */
 
-			((acpi_parse2_object *)op)->name = node->name.integer;
-			*out_op = op;
+			if (node) {
+				op->named.name = node->name.integer;
+			}
+			if (out_op) {
+				*out_op = op;
+			}
 		}
 
 		/*
 		 * Put the Node in the "op" object that the parser uses, so we
 		 * can get it again quickly when this scope is closed
 		 */
-		op->node = node;
-
-		if (original) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "old %p new %p\n", original, node));
-
-			if (original != node) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-					"Lookup match error: old %p new %p\n", original, node));
-			}
-		}
+		op->common.node = node;
 	}
 
 	return (status);
@@ -445,11 +445,11 @@
 		return (AE_OK);
 	}
 
-	if (op->opcode == AML_SCOPE_OP) {
+	if (op->common.aml_opcode == AML_SCOPE_OP) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
 			"Ending scope Op=%p State=%p\n", op, walk_state));
 
-		if (((acpi_parse2_object *)op)->name == ACPI_UINT16_MAX) {
+		if (op->named.name == ACPI_UINT16_MAX) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unnamed scope! Op=%p State=%p\n",
 				op, walk_state));
 			return (AE_OK);
@@ -463,7 +463,7 @@
 	 * Get the Node/name from the earlier lookup
 	 * (It was saved in the *op structure)
 	 */
-	node = op->node;
+	node = op->common.node;
 
 	/*
 	 * Put the Node on the object stack (Contains the ACPI Name of
@@ -477,7 +477,11 @@
 	if (acpi_ns_opens_scope (object_type)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "(%s) Popping scope for Op %p\n",
 			acpi_ut_get_type_name (object_type), op));
-		acpi_ds_scope_stack_pop (walk_state);
+
+		status = acpi_ds_scope_stack_pop (walk_state);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
 	}
 
 	/*
@@ -510,11 +514,11 @@
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
 		"Create-Load [%s] State=%p Op=%p Named_obj=%p\n",
-		acpi_ps_get_opcode_name (op->opcode), walk_state, op, node));
+		acpi_ps_get_opcode_name (op->common.aml_opcode), walk_state, op, node));
 
 	/* Decode the opcode */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 
 	switch (walk_state->op_info->type) {
 	case AML_TYPE_CREATE_FIELD:
@@ -529,21 +533,25 @@
 
 	 case AML_TYPE_NAMED_FIELD:
 
-		switch (op->opcode) {
+		switch (op->common.aml_opcode) {
 		case AML_INDEX_FIELD_OP:
 
-			status = acpi_ds_create_index_field (op, (acpi_handle) arg->node,
+			status = acpi_ds_create_index_field (op, (acpi_handle) arg->common.node,
 					   walk_state);
 			break;
 
 		case AML_BANK_FIELD_OP:
 
-			status = acpi_ds_create_bank_field (op, arg->node, walk_state);
+			status = acpi_ds_create_bank_field (op, arg->common.node, walk_state);
 			break;
 
 		case AML_FIELD_OP:
 
-			status = acpi_ds_create_field (op, arg->node, walk_state);
+			status = acpi_ds_create_field (op, arg->common.node, walk_state);
+			break;
+
+		default:
+			/* All NAMED_FIELD opcodes must be handled above */
 			break;
 		}
 		break;
@@ -556,7 +564,7 @@
 			goto cleanup;
 		}
 
-		switch (op->opcode) {
+		switch (op->common.aml_opcode) {
 		case AML_PROCESSOR_OP:
 
 			status = acpi_ex_create_processor (walk_state);
@@ -606,7 +614,7 @@
 
 	case AML_TYPE_NAMED_COMPLEX:
 
-		switch (op->opcode) {
+		switch (op->common.aml_opcode) {
 		case AML_METHOD_OP:
 			/*
 			 * Method_op Pkg_length Name_string Method_flags Term_list
@@ -621,9 +629,8 @@
 					goto cleanup;
 				}
 
-				status = acpi_ex_create_method (((acpi_parse2_object *) op)->data,
-						   ((acpi_parse2_object *) op)->length,
-						   walk_state);
+				status = acpi_ex_create_method (op->named.data,
+						   op->named.length, walk_state);
 			}
 			break;
 
@@ -655,6 +662,11 @@
 
 			status = acpi_ds_create_node (walk_state, node, op);
 			break;
+
+
+		default:
+			/* All NAMED_COMPLEX opcodes must be handled above */
+			break;
 		}
 		break;
 
@@ -674,7 +686,7 @@
 		/*
 		 * Lookup the method name and save the Node
 		 */
-		status = acpi_ns_lookup (walk_state->scope_info, arg->value.string,
+		status = acpi_ns_lookup (walk_state->scope_info, arg->common.value.string,
 				  ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS2,
 				  ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
 				  walk_state, &(new_node));
@@ -691,7 +703,7 @@
 			 * for now, we will put it in the "op" object that the parser uses, so we
 			 * can get it again at the end of this scope
 			 */
-			op->node = new_node;
+			op->common.node = new_node;
 		}
 
 		break;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/dispatcher/dswstate.c linux/drivers/acpi/dispatcher/dswstate.c
--- ../prev/linux/drivers/acpi/dispatcher/dswstate.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/dispatcher/dswstate.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: dswstate - Dispatcher parse tree walk management routines
- *              $Revision: 59 $
+ *              $Revision: 64 $
  *
  *****************************************************************************/
 
@@ -25,11 +25,9 @@
 
 
 #include "acpi.h"
-#include "amlcode.h"
 #include "acparser.h"
 #include "acdispat.h"
 #include "acnamesp.h"
-#include "acinterp.h"
 
 #define _COMPONENT          ACPI_DISPATCHER
 	 ACPI_MODULE_NAME    ("dswstate")
@@ -126,13 +124,12 @@
 		return (AE_NOT_EXIST);
 	}
 
-	if (index >= OBJ_NUM_OPERANDS) {
+	if (index >= OBJ_MAX_OPERAND) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Index out of range: %X State=%p Num=%X\n",
 			index, walk_state, state->results.num_results));
 	}
 
-
 	/* Check for a valid result object */
 
 	if (!state->results.obj_desc [index]) {
@@ -237,7 +234,7 @@
 	acpi_operand_object     **object,
 	acpi_walk_state         *walk_state)
 {
-	u32                     index;
+	NATIVE_UINT             index;
 	acpi_generic_state      *state;
 
 
@@ -251,7 +248,6 @@
 		return (AE_NOT_EXIST);
 	}
 
-
 	if (!state->results.num_results) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "No result objects! State=%p\n", walk_state));
 		return (AE_AML_NO_RETURN_VALUE);
@@ -273,7 +269,7 @@
 
 	if (!*object) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Null operand! State=%p #Ops=%X, Index=%X\n",
-			walk_state, state->results.num_results, index));
+			walk_state, state->results.num_results, (u32) index));
 		return (AE_AML_NO_RETURN_VALUE);
 	}
 
@@ -329,7 +325,6 @@
 		return (AE_BAD_PARAMETER);
 	}
 
-
 	state->results.obj_desc [state->results.num_results] = object;
 	state->results.num_results++;
 
@@ -694,7 +689,6 @@
 		return_PTR (NULL);
 	}
 
-
 	return_PTR (walk_state->operands[(NATIVE_UINT)(walk_state->num_operands - 1) -
 			  index]);
 }
@@ -728,7 +722,6 @@
 	ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Ds_get_current_walk_state, =%p\n",
 		thread->walk_state_list));
 
-
 	return (thread->walk_state_list);
 }
 
@@ -918,7 +911,6 @@
 		walk_state->method_node             = method_node;
 		walk_state->method_desc             = acpi_ns_get_attached_object (method_node);
 
-
 		/* Push start scope on scope stack and make it current  */
 
 		status = acpi_ds_scope_stack_push (method_node, ACPI_TYPE_METHOD, walk_state);
@@ -928,13 +920,15 @@
 
 		/* Init the method arguments */
 
-		acpi_ds_method_data_init_args (params, MTH_NUM_ARGS, walk_state);
+		status = acpi_ds_method_data_init_args (params, MTH_NUM_ARGS, walk_state);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
-
 	else {
 		/* Setup the current scope */
 
-		parser_state->start_node = parser_state->start_op->node;
+		parser_state->start_node = parser_state->start_op->common.node;
 		if (parser_state->start_node) {
 			/* Push start scope on scope stack and make it current  */
 
@@ -946,9 +940,8 @@
 		}
 	}
 
-	acpi_ds_init_callbacks (walk_state, pass_number);
-
-	return_ACPI_STATUS (AE_OK);
+	status = acpi_ds_init_callbacks (walk_state, pass_number);
+	return_ACPI_STATUS (status);
 }
 #endif
 
@@ -983,7 +976,6 @@
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p is not a valid walk state\n", walk_state));
 		return;
 	}
-
 
 	if (walk_state->parser_state.scope) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%p walk still has a scope list\n", walk_state));
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/ec.c linux/drivers/acpi/ec.c
--- ../prev/linux/drivers/acpi/ec.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/ec.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,736 @@
+/*
+ *  acpi_ec.c - ACPI Embedded Controller Driver ($Revision: 28 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_EC_COMPONENT
+ACPI_MODULE_NAME		("acpi_ec")
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_EC_FLAG_OBF	0x01	/* Output buffer full */
+#define ACPI_EC_FLAG_IBF	0x02	/* Input buffer full */
+#define ACPI_EC_FLAG_SCI	0x20	/* EC-SCI occurred */
+
+#define ACPI_EC_EVENT_OBF	0x01	/* Output buffer full */
+#define ACPI_EC_EVENT_IBE	0x02	/* Input buffer empty */
+
+#define ACPI_EC_UDELAY		100	/* Poll @ 100us increments */
+#define ACPI_EC_UDELAY_COUNT	1000	/* Wait 10ms max. during EC ops */
+#define ACPI_EC_UDELAY_GLK	1000	/* Wait 1ms max. to get global lock */
+
+#define ACPI_EC_COMMAND_READ	0x80
+#define ACPI_EC_COMMAND_WRITE	0x81
+#define ACPI_EC_COMMAND_QUERY	0x84
+
+static int acpi_ec_add (struct acpi_device *device);
+static int acpi_ec_remove (struct acpi_device *device, int type);
+static int acpi_ec_start (struct acpi_device *device);
+static int acpi_ec_stop (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_ec_driver = {
+	name:			ACPI_EC_DRIVER_NAME,
+	class:			ACPI_EC_CLASS,
+	ids:			ACPI_EC_HID,
+	ops:			{
+					add:	acpi_ec_add,
+					remove:	acpi_ec_remove,
+					start:	acpi_ec_start,
+					stop:	acpi_ec_stop,
+				},
+};
+
+struct acpi_ec {
+	acpi_handle		handle;
+	unsigned long		gpe_bit;
+	unsigned long		status_port;
+	unsigned long		command_port;
+	unsigned long		data_port;
+	unsigned long		global_lock;
+	spinlock_t		lock;
+};
+
+
+/* --------------------------------------------------------------------------
+                             Transaction Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_ec_wait (
+	struct acpi_ec		*ec,
+	u8			event)
+{
+	u8			acpi_ec_status = 0;
+	u32			i = ACPI_EC_UDELAY_COUNT;
+
+	if (!ec)
+		return -EINVAL;
+
+	/* Poll the EC status register waiting for the event to occur. */
+	switch (event) {
+	case ACPI_EC_EVENT_OBF:
+		do {
+			acpi_ec_status = inb(ec->status_port);
+			if (acpi_ec_status & ACPI_EC_FLAG_OBF)
+				return 0;
+			udelay(ACPI_EC_UDELAY);
+		} while (--i>0);
+		break;
+	case ACPI_EC_EVENT_IBE:
+		do {
+			acpi_ec_status = inb(ec->status_port);
+			if (!(acpi_ec_status & ACPI_EC_FLAG_IBF))
+				return 0;
+			udelay(ACPI_EC_UDELAY);
+		} while (--i>0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return -ETIME;
+}
+
+
+static int
+acpi_ec_read (
+	struct acpi_ec		*ec,
+	u8			address,
+	u8			*data)
+{
+	acpi_status		status = AE_OK;
+	int			result = 0;
+	unsigned long		flags = 0;
+	u32			glk = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_read");
+
+	if (!ec || !data)
+		return_VALUE(-EINVAL);
+
+	*data = 0;
+
+	if (ec->global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+	
+	spin_lock_irqsave(&ec->lock, flags);
+
+	outb(ACPI_EC_COMMAND_READ, ec->command_port);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (0 != result)
+		goto end;
+
+	outb(address, ec->data_port);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+	if (0 != result)
+		goto end;
+
+	*data = inb(ec->data_port);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Read [%02x] from address [%02x]\n",
+		*data, address));
+
+end:
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	if (ec->global_lock)
+		acpi_release_global_lock(glk);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_ec_write (
+	struct acpi_ec		*ec,
+	u8			address,
+	u8			data)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	unsigned long		flags = 0;
+	u32			glk = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_write");
+
+	if (!ec)
+		return_VALUE(-EINVAL);
+
+	if (ec->global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+
+	spin_lock_irqsave(&ec->lock, flags);
+
+	outb(ACPI_EC_COMMAND_WRITE, ec->command_port);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (0 != result)
+		goto end;
+
+	outb(address, ec->data_port);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (0 != result)
+		goto end;
+
+	outb(data, ec->data_port);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_IBE);
+	if (0 != result)
+		goto end;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Wrote [%02x] to address [%02x]\n",
+		data, address));
+
+end:
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	if (ec->global_lock)
+		acpi_release_global_lock(glk);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_ec_query (
+	struct acpi_ec		*ec,
+	u8			*data)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	unsigned long		flags = 0;
+	u32			glk = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_query");
+
+	if (!ec || !data)
+		return_VALUE(-EINVAL);
+
+	*data = 0;
+
+	if (ec->global_lock) {
+		status = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);
+		if (ACPI_FAILURE(status))
+			return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * Query the EC to find out which _Qxx method we need to evaluate.
+	 * Note that successful completion of the query causes the ACPI_EC_SCI
+	 * bit to be cleared (and thus clearing the interrupt source).
+	 */
+
+	spin_lock_irqsave(&ec->lock, flags);
+
+	outb(ACPI_EC_COMMAND_QUERY, ec->command_port);
+	result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF);
+	if (0 != result)
+		goto end;
+	
+	*data = inb(ec->data_port);
+	if (!*data)
+		result = -ENODATA;
+
+end:
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	if (ec->global_lock)
+		acpi_release_global_lock(glk);
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Event Management
+   -------------------------------------------------------------------------- */
+
+struct acpi_ec_query_data {
+	acpi_handle		handle;
+	u8			data;
+};
+
+
+static void
+acpi_ec_gpe_query (
+	void			*data)
+{
+	struct acpi_ec_query_data *query_data = NULL;
+	static char		object_name[5] = {'_','Q','0','0','\0'};
+	const char		hex[] = {'0','1','2','3','4','5','6','7',
+				         '8','9','A','B','C','D','E','F'};
+
+	ACPI_FUNCTION_TRACE("acpi_ec_gpe_query");
+
+	if (!data)
+		return;
+
+	query_data = (struct acpi_ec_query_data *) data;
+
+	object_name[2] = hex[((query_data->data >> 4) & 0x0F)];
+	object_name[3] = hex[(query_data->data & 0x0F)];
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluating %s\n", object_name));
+
+	acpi_evaluate(query_data->handle, object_name, NULL, NULL);
+
+	kfree(query_data);
+
+	return;
+}
+
+
+static void
+acpi_ec_gpe_handler (
+	void			*data)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = (struct acpi_ec *) data;
+	u8			value = 0;
+	unsigned long		flags = 0;
+	struct acpi_ec_query_data *query_data = NULL;
+
+	if (!ec)
+		return;
+
+	spin_lock_irqsave(&ec->lock, flags);
+	value = inb(ec->command_port);
+	spin_unlock_irqrestore(&ec->lock, flags);
+
+	/* TBD: Implement asynch events!
+	 * NOTE: All we care about are EC-SCI's.  Other EC events are
+	 *       handled via polling (yuck!).  This is because some systems
+	 *       treat EC-SCIs as level (versus EDGE!) triggered, preventing
+	 *       a purely interrupt-driven approach (grumble, grumble).
+	 */
+
+	if (!(value & ACPI_EC_FLAG_SCI))
+		return;
+
+	if (0 != acpi_ec_query(ec, &value))
+		return;
+
+	query_data = kmalloc(sizeof(struct acpi_ec_query_data), GFP_ATOMIC);
+	if (!query_data)
+		return;
+	query_data->handle = ec->handle;
+	query_data->data = value;
+
+	status = acpi_os_queue_for_execution(OSD_PRIORITY_GPE,
+		acpi_ec_gpe_query, query_data);
+	if (ACPI_FAILURE(status))
+		kfree(query_data);
+
+	return;
+}
+
+
+/* --------------------------------------------------------------------------
+                             Address Space Management
+   -------------------------------------------------------------------------- */
+
+static acpi_status
+acpi_ec_space_setup (
+	acpi_handle		region_handle,
+	u32			function,
+	void			*handler_context,
+	void			**return_context)
+{
+	/*
+	 * The EC object is in the handler context and is needed
+	 * when calling the acpi_ec_space_handler.
+	 */
+	*return_context = handler_context;
+
+	return AE_OK;
+}
+
+
+static acpi_status
+acpi_ec_space_handler (
+	u32			function,
+	ACPI_PHYSICAL_ADDRESS	address,
+	u32			bit_width,
+	acpi_integer		*value,
+	void			*handler_context,
+	void			*region_context)
+{
+	int			result = 0;
+	struct acpi_ec		*ec = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_space_handler");
+
+	if ((address > 0xFF) || (bit_width != 8) || !value || !handler_context)
+		return_VALUE(AE_BAD_PARAMETER);
+
+	ec = (struct acpi_ec *) handler_context;
+
+	switch (function) {
+	case ACPI_READ:
+		result = acpi_ec_read(ec, (u8) address, (u8*) value);
+		break;
+	case ACPI_WRITE:
+		result = acpi_ec_write(ec, (u8) address, (u8) *value);
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+
+	switch (result) {
+	case -EINVAL:
+		return_VALUE(AE_BAD_PARAMETER);
+		break;
+	case -ENODEV:
+		return_VALUE(AE_NOT_FOUND);
+		break;
+	case -ETIME:
+		return_VALUE(AE_TIME);
+		break;
+	default:
+		return_VALUE(AE_OK);
+	}
+
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry		*acpi_ec_dir = NULL;
+
+
+static int
+acpi_ec_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_ec		*ec = (struct acpi_ec *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_read_info");
+
+	if (!ec || (off != 0))
+		goto end;
+
+	p += sprintf(p, "gpe bit:                 0x%02x\n",
+		(u32) ec->gpe_bit);
+	p += sprintf(p, "ports:                   0x%02x, 0x%02x\n",
+		(u32) ec->status_port, (u32) ec->data_port);
+	p += sprintf(p, "use global lock:         %s\n",
+		ec->global_lock?"yes":"no");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_ec_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_add_fs");
+
+	if (!acpi_ec_dir) {
+		acpi_ec_dir = proc_mkdir(ACPI_EC_CLASS, acpi_root_dir);
+		if (!acpi_ec_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_ec_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	entry = create_proc_read_entry(ACPI_EC_FILE_INFO, S_IRUGO,
+		acpi_device_dir(device), acpi_ec_read_info,
+		acpi_driver_data(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+			"Unable to create '%s' fs entry\n",
+			ACPI_EC_FILE_INFO));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_ec_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_ec_remove_fs");
+
+	if (!acpi_ec_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_ec_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                               Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_ec_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = kmalloc(sizeof(struct acpi_ec), GFP_KERNEL);
+	if (!ec)
+		return_VALUE(-ENOMEM);
+	memset(ec, 0, sizeof(struct acpi_ec));
+
+	ec->handle = device->handle;
+	ec->lock = SPIN_LOCK_UNLOCKED;
+	sprintf(acpi_device_name(device), "%s", ACPI_EC_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_EC_CLASS);
+	acpi_driver_data(device) = ec;
+
+	/* Use the global lock for all EC transactions? */
+	acpi_evaluate_integer(ec->handle, "_GLK", NULL, &ec->global_lock);
+
+	/* Get GPE bit assignment (EC events). */
+	status = acpi_evaluate_integer(ec->handle, "_GPE", NULL, &ec->gpe_bit);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error obtaining GPE bit assignment\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	result = acpi_ec_add_fs(device);
+	if (0 != result)
+		goto end;
+
+	printk(KERN_INFO PREFIX "%s [%s] (gpe %d)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		(u32) ec->gpe_bit);
+
+end:
+	if (0 != result)
+		kfree(ec);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_ec_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_ec		*ec = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_remove");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = (struct acpi_ec *) acpi_driver_data(device);
+
+	acpi_ec_remove_fs(device);
+
+	kfree(ec);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_ec_start (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = NULL;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_resource		*resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_start");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = (struct acpi_ec *) acpi_driver_data(device);
+
+	if (!ec)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Get I/O port addresses
+	 */
+
+	status = acpi_get_current_resources(ec->handle, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error getting I/O port addresses"));
+		return_VALUE(-ENODEV);
+	}
+
+	resource = (acpi_resource *) buffer.pointer;
+	if (!resource || (resource->id != ACPI_RSTYPE_IO)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid or missing resource\n"));
+		result = -ENODEV;
+		goto end;
+	}
+	ec->data_port = resource->data.io.min_base_address;
+
+	resource = ACPI_NEXT_RESOURCE(resource);
+	if (!resource || (resource->id != ACPI_RSTYPE_IO)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid or missing resource\n"));
+		result = -ENODEV;
+		goto end;
+	}
+	ec->command_port = ec->status_port = resource->data.io.min_base_address;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "gpe=0x%02x, ports=0x%2x,0x%2x\n",
+		(u32) ec->gpe_bit, (u32) ec->command_port, (u32) ec->data_port));
+
+	/*
+	 * Install GPE handler
+	 */
+
+	status = acpi_install_gpe_handler(ec->gpe_bit,
+		ACPI_EVENT_EDGE_TRIGGERED, &acpi_ec_gpe_handler, ec);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	status = acpi_install_address_space_handler (ec->handle,
+			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler,
+			&acpi_ec_space_setup, ec);
+	if (ACPI_FAILURE(status)) {
+		acpi_remove_address_space_handler(ec->handle,
+			ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
+		return_VALUE(-ENODEV);
+	}
+end:
+	kfree(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_ec_stop (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_ec		*ec = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_stop");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	ec = (struct acpi_ec *) acpi_driver_data(device);
+
+	status = acpi_remove_address_space_handler(ec->handle,
+		ACPI_ADR_SPACE_EC, &acpi_ec_space_handler);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	status = acpi_remove_gpe_handler(ec->gpe_bit, &acpi_ec_gpe_handler);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_ec_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_init");
+
+	result = acpi_bus_register_driver(&acpi_ec_driver);
+	if (0 > result) {
+		remove_proc_entry(ACPI_EC_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_ec_exit (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_ec_exit");
+
+	result = acpi_bus_unregister_driver(&acpi_ec_driver);
+	if (0 == result)
+		remove_proc_entry(ACPI_EC_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evevent.c linux/drivers/acpi/events/evevent.c
--- ../prev/linux/drivers/acpi/events/evevent.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evevent.c	Fri May 31 14:02:04 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: evevent - Fixed and General Purpose Even handling and dispatch
- *              $Revision: 77 $
+ *              $Revision: 88 $
  *
  *****************************************************************************/
 
@@ -24,7 +24,6 @@
  */
 
 #include "acpi.h"
-#include "achware.h"
 #include "acevents.h"
 #include "acnamesp.h"
 
@@ -159,6 +158,7 @@
 	void)
 {
 	NATIVE_UINT             i;
+	acpi_status             status;
 
 
 	/*
@@ -172,8 +172,11 @@
 		/* Enable the fixed event */
 
 		if (acpi_gbl_fixed_event_info[i].enable_register_id != 0xFF) {
-			acpi_hw_bit_register_write (acpi_gbl_fixed_event_info[i].enable_register_id,
+			status = acpi_set_register (acpi_gbl_fixed_event_info[i].enable_register_id,
 					 0, ACPI_MTX_LOCK);
+			if (ACPI_FAILURE (status)) {
+				return (status);
+			}
 		}
 	}
 
@@ -200,7 +203,7 @@
 	u32                     int_status = ACPI_INTERRUPT_NOT_HANDLED;
 	u32                     gpe_status;
 	u32                     gpe_enable;
-	NATIVE_UINT             i;
+	NATIVE_UINT_MAX32       i;
 
 
 	ACPI_FUNCTION_NAME ("Ev_fixed_event_detect");
@@ -208,10 +211,10 @@
 
 	/*
 	 * Read the fixed feature status and enable registers, as all the cases
-	 * depend on their values.
+	 * depend on their values.  Ignore errors here.
 	 */
-	gpe_status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS);
-	gpe_enable = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS, &gpe_status);
+	(void) acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE, &gpe_enable);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
 		"Fixed Acpi_event Block: Enable %08X Status %08X\n",
@@ -259,7 +262,7 @@
 
 	/* Clear the status bit */
 
-	acpi_hw_bit_register_write (acpi_gbl_fixed_event_info[event].status_register_id,
+	(void) acpi_set_register (acpi_gbl_fixed_event_info[event].status_register_id,
 			 1, ACPI_MTX_DO_NOT_LOCK);
 
 	/*
@@ -267,7 +270,7 @@
 	 * The event is disabled to prevent further interrupts.
 	 */
 	if (NULL == acpi_gbl_fixed_event_handlers[event].handler) {
-		acpi_hw_bit_register_write (acpi_gbl_fixed_event_info[event].enable_register_id,
+		(void) acpi_set_register (acpi_gbl_fixed_event_info[event].enable_register_id,
 				0, ACPI_MTX_DO_NOT_LOCK);
 
 		ACPI_REPORT_ERROR (
@@ -299,13 +302,14 @@
 acpi_status
 acpi_ev_gpe_initialize (void)
 {
-	NATIVE_UINT             i;
-	NATIVE_UINT             j;
-	NATIVE_UINT             gpe_block;
+	NATIVE_UINT_MAX32       i;
+	NATIVE_UINT_MAX32       j;
+	u32                     gpe_block;
 	u32                     gpe_register;
 	u32                     gpe_number_index;
 	u32                     gpe_number;
 	ACPI_GPE_REGISTER_INFO  *gpe_register_info;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE ("Ev_gpe_initialize");
@@ -331,6 +335,10 @@
 
 	acpi_gbl_gpe_block_info[0].register_count = (u16) ACPI_DIV_16 (acpi_gbl_FADT->Xgpe0_blk.register_bit_width);
 	acpi_gbl_gpe_block_info[1].register_count = (u16) ACPI_DIV_16 (acpi_gbl_FADT->Xgpe1_blk.register_bit_width);
+	if (acpi_gbl_gpe_block_info[0].register_count == 0)
+		acpi_gbl_gpe_block_info[0].register_count = 1;
+	if (acpi_gbl_gpe_block_info[1].register_count == 0)
+		acpi_gbl_gpe_block_info[1].register_count = 1;
 
 	acpi_gbl_gpe_block_info[0].block_address = &acpi_gbl_FADT->Xgpe0_blk;
 	acpi_gbl_gpe_block_info[1].block_address = &acpi_gbl_FADT->Xgpe1_blk;
@@ -372,8 +380,9 @@
 	/*
 	 * Allocate the GPE number-to-index translation table
 	 */
-	acpi_gbl_gpe_number_to_index = ACPI_MEM_CALLOCATE (sizeof (ACPI_GPE_INDEX_INFO) *
-			   (acpi_gbl_gpe_number_max + 1));
+	acpi_gbl_gpe_number_to_index = ACPI_MEM_CALLOCATE (
+			   sizeof (ACPI_GPE_INDEX_INFO) *
+			   ((ACPI_SIZE) acpi_gbl_gpe_number_max + 1));
 	if (!acpi_gbl_gpe_number_to_index) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Could not allocate the Gpe_number_to_index table\n"));
@@ -383,12 +392,13 @@
 	/* Set the Gpe index table to GPE_INVALID */
 
 	ACPI_MEMSET (acpi_gbl_gpe_number_to_index, (int) ACPI_GPE_INVALID,
-			sizeof (ACPI_GPE_INDEX_INFO) * (acpi_gbl_gpe_number_max + 1));
+			sizeof (ACPI_GPE_INDEX_INFO) * ((ACPI_SIZE) acpi_gbl_gpe_number_max + 1));
 
 	/*
 	 * Allocate the GPE register information block
 	 */
-	acpi_gbl_gpe_register_info = ACPI_MEM_CALLOCATE (acpi_gbl_gpe_register_count *
+	acpi_gbl_gpe_register_info = ACPI_MEM_CALLOCATE (
+			  (ACPI_SIZE) acpi_gbl_gpe_register_count *
 			  sizeof (ACPI_GPE_REGISTER_INFO));
 	if (!acpi_gbl_gpe_register_info) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
@@ -400,7 +410,8 @@
 	 * Allocate the GPE dispatch handler block.  There are eight distinct GPEs
 	 * per register.  Initialization to zeros is sufficient.
 	 */
-	acpi_gbl_gpe_number_info = ACPI_MEM_CALLOCATE (ACPI_MUL_8 (acpi_gbl_gpe_register_count) *
+	acpi_gbl_gpe_number_info = ACPI_MEM_CALLOCATE (
+			  (ACPI_SIZE) ACPI_MUL_8 (acpi_gbl_gpe_register_count) *
 			  sizeof (ACPI_GPE_NUMBER_INFO));
 	if (!acpi_gbl_gpe_number_info) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not allocate the Gpe_number_info table\n"));
@@ -423,14 +434,17 @@
 
 			/* Init the Register info for this entire GPE register (8 GPEs) */
 
-			gpe_register_info->base_gpe_number = (u8) (acpi_gbl_gpe_block_info[gpe_block].block_base_number + (ACPI_MUL_8 (i)));
+			gpe_register_info->base_gpe_number = (u8) (acpi_gbl_gpe_block_info[gpe_block].block_base_number
+					   + (ACPI_MUL_8 (i)));
 
 			ACPI_STORE_ADDRESS (gpe_register_info->status_address.address,
-					   (ACPI_GET_ADDRESS (acpi_gbl_gpe_block_info[gpe_block].block_address->address) + i));
+					   (ACPI_GET_ADDRESS (acpi_gbl_gpe_block_info[gpe_block].block_address->address)
+							  + i));
 
 			ACPI_STORE_ADDRESS (gpe_register_info->enable_address.address,
-					   (ACPI_GET_ADDRESS (acpi_gbl_gpe_block_info[gpe_block].block_address->address) + i +
-							  acpi_gbl_gpe_block_info[gpe_block].register_count));
+					   (ACPI_GET_ADDRESS (acpi_gbl_gpe_block_info[gpe_block].block_address->address)
+							  + i
+							  + acpi_gbl_gpe_block_info[gpe_block].register_count));
 
 			gpe_register_info->status_address.address_space_id = acpi_gbl_gpe_block_info[gpe_block].address_space_id;
 			gpe_register_info->enable_address.address_space_id = acpi_gbl_gpe_block_info[gpe_block].address_space_id;
@@ -455,19 +469,26 @@
 			 * by writing a '0'.
 			 */
 
-			acpi_hw_low_level_write (8, 0x00, &gpe_register_info->enable_address, 0);
-			acpi_hw_low_level_write (8, 0xFF, &gpe_register_info->status_address, 0);
+			status = acpi_hw_low_level_write (8, 0x00, &gpe_register_info->enable_address, 0);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
+
+			status = acpi_hw_low_level_write (8, 0xFF, &gpe_register_info->status_address, 0);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
 
 			gpe_register++;
 		}
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "GPE Block%d: %X registers at %8.8X\n",
-			gpe_block, acpi_gbl_gpe_block_info[0].register_count,
-			ACPI_HIDWORD (acpi_gbl_gpe_block_info[gpe_block].block_address->address),
-			ACPI_LODWORD (acpi_gbl_gpe_block_info[gpe_block].block_address->address)));
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "GPE Block%d: %X registers at %8.8X%8.8X\n",
+			(s32) gpe_block, acpi_gbl_gpe_block_info[0].register_count,
+			ACPI_HIDWORD (ACPI_GET_ADDRESS (acpi_gbl_gpe_block_info[gpe_block].block_address->address)),
+			ACPI_LODWORD (ACPI_GET_ADDRESS (acpi_gbl_gpe_block_info[gpe_block].block_address->address))));
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "GPE Block%d Range GPE #%2.2X to GPE #%2.2X\n",
-			gpe_block,
+			(s32) gpe_block,
 			acpi_gbl_gpe_block_info[gpe_block].block_base_number,
 			acpi_gbl_gpe_block_info[gpe_block].block_base_number +
 				((acpi_gbl_gpe_block_info[gpe_block].register_count * 8) -1)));
@@ -520,6 +541,7 @@
 	u32                     gpe_number_index;
 	NATIVE_CHAR             name[ACPI_NAME_SIZE + 1];
 	u8                      type;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_NAME ("Ev_save_method_info");
@@ -528,7 +550,7 @@
 	/* Extract the name from the object and convert to a string */
 
 	ACPI_MOVE_UNALIGNED32_TO_32 (name,
-			  &((acpi_namespace_node *) obj_handle)->name);
+			  &((acpi_namespace_node *) obj_handle)->name.integer);
 	name[ACPI_NAME_SIZE] = 0;
 
 	/*
@@ -583,7 +605,10 @@
 	/*
 	 * Enable the GPE (SCIs should be disabled at this point)
 	 */
-	acpi_hw_enable_gpe (gpe_number);
+	status = acpi_hw_enable_gpe (gpe_number);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Registered GPE method %s as GPE number %X\n",
 		name, gpe_number));
@@ -652,6 +677,8 @@
 	u8                      enabled_status_byte;
 	u8                      bit_mask;
 	ACPI_GPE_REGISTER_INFO  *gpe_register_info;
+	u32                     in_value;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_NAME ("Ev_gpe_detect");
@@ -665,16 +692,22 @@
 	for (i = 0; i < acpi_gbl_gpe_register_count; i++) {
 		gpe_register_info = &acpi_gbl_gpe_register_info[i];
 
-		gpe_register_info->status = (u8) acpi_hw_low_level_read (8,
-				   &gpe_register_info->status_address, 0);
+		status = acpi_hw_low_level_read (8, &in_value, &gpe_register_info->status_address, 0);
+		gpe_register_info->status = (u8) in_value;
+		if (ACPI_FAILURE (status)) {
+			return (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 
-		gpe_register_info->enable = (u8) acpi_hw_low_level_read (8,
-				   &gpe_register_info->enable_address, 0);
+		status = acpi_hw_low_level_read (8, &in_value, &gpe_register_info->enable_address, 0);
+		gpe_register_info->enable = (u8) in_value;
+		if (ACPI_FAILURE (status)) {
+			return (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
-			"GPE block at %8.8X%8.8X - Enable %08X Status %08X\n",
-			ACPI_HIDWORD (gpe_register_info->enable_address.address),
-			ACPI_LODWORD (gpe_register_info->enable_address.address),
+			"GPE block at %8.8X%8.8X - Values: Enable %02X Status %02X\n",
+			ACPI_HIDWORD (ACPI_GET_ADDRESS (gpe_register_info->enable_address.address)),
+			ACPI_LODWORD (ACPI_GET_ADDRESS (gpe_register_info->enable_address.address)),
 			gpe_register_info->enable,
 			gpe_register_info->status));
 
@@ -731,6 +764,7 @@
 	u32                     gpe_number = (u32) ACPI_TO_INTEGER (context);
 	u32                     gpe_number_index;
 	ACPI_GPE_NUMBER_INFO    gpe_info;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE ("Ev_asynch_execute_gpe_method");
@@ -745,12 +779,14 @@
 	 * Take a snapshot of the GPE info for this level - we copy the
 	 * info to prevent a race condition with Remove_handler.
 	 */
-	if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_EVENTS))) {
+	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
 		return_VOID;
 	}
 
 	gpe_info = acpi_gbl_gpe_number_info [gpe_number_index];
-	if (ACPI_FAILURE (acpi_ut_release_mutex (ACPI_MTX_EVENTS))) {
+	status = acpi_ut_release_mutex (ACPI_MTX_EVENTS);
+	if (ACPI_FAILURE (status)) {
 		return_VOID;
 	}
 
@@ -759,7 +795,11 @@
 		 * Invoke the GPE Method (_Lxx, _Exx):
 		 * (Evaluate the _Lxx/_Exx control method that corresponds to this GPE.)
 		 */
-		acpi_ns_evaluate_by_handle (gpe_info.method_handle, NULL, NULL);
+		status = acpi_ns_evaluate_by_handle (gpe_info.method_handle, NULL, NULL);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("%s while evaluated GPE%X method\n",
+				acpi_format_exception (status), gpe_number));
+		}
 	}
 
 	if (gpe_info.type & ACPI_EVENT_LEVEL_TRIGGERED) {
@@ -767,13 +807,16 @@
 		 * GPE is level-triggered, we clear the GPE status bit after handling
 		 * the event.
 		 */
-		acpi_hw_clear_gpe (gpe_number);
+		status = acpi_hw_clear_gpe (gpe_number);
+		if (ACPI_FAILURE (status)) {
+			return_VOID;
+		}
 	}
 
 	/*
 	 * Enable the GPE.
 	 */
-	acpi_hw_enable_gpe (gpe_number);
+	(void) acpi_hw_enable_gpe (gpe_number);
 	return_VOID;
 }
 
@@ -798,6 +841,7 @@
 {
 	u32                     gpe_number_index;
 	ACPI_GPE_NUMBER_INFO    *gpe_info;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE ("Ev_gpe_dispatch");
@@ -820,7 +864,11 @@
 	 * level-triggered events are cleared after the GPE is serviced.
 	 */
 	if (gpe_info->type & ACPI_EVENT_EDGE_TRIGGERED) {
-		acpi_hw_clear_gpe (gpe_number);
+		status = acpi_hw_clear_gpe (gpe_number);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Acpi_ev_gpe_dispatch: Unable to clear GPE[%X]\n", gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 	}
 
 	/*
@@ -840,7 +888,11 @@
 		 * Disable GPE, so it doesn't keep firing before the method has a
 		 * chance to run.
 		 */
-		acpi_hw_disable_gpe (gpe_number);
+		status = acpi_hw_disable_gpe (gpe_number);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Acpi_ev_gpe_dispatch: Unable to disable GPE[%X]\n", gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 
 		/*
 		 * Execute the method associated with the GPE.
@@ -860,14 +912,22 @@
 		 * Disable the GPE.  The GPE will remain disabled until the ACPI
 		 * Core Subsystem is restarted, or the handler is reinstalled.
 		 */
-		acpi_hw_disable_gpe (gpe_number);
+		status = acpi_hw_disable_gpe (gpe_number);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Acpi_ev_gpe_dispatch: Unable to disable GPE[%X]\n", gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 	}
 
 	/*
 	 * It is now safe to clear level-triggered evnets.
 	 */
 	if (gpe_info->type & ACPI_EVENT_LEVEL_TRIGGERED) {
-		acpi_hw_clear_gpe (gpe_number);
+		status = acpi_hw_clear_gpe (gpe_number);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Acpi_ev_gpe_dispatch: Unable to clear GPE[%X]\n", gpe_number));
+			return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 	}
 
 	return_VALUE (ACPI_INTERRUPT_HANDLED);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evmisc.c linux/drivers/acpi/events/evmisc.c
--- ../prev/linux/drivers/acpi/events/evmisc.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evmisc.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: evmisc - Miscellaneous event manager support functions
- *              $Revision: 48 $
+ *              $Revision: 53 $
  *
  *****************************************************************************/
 
@@ -27,7 +27,6 @@
 #include "acevents.h"
 #include "acnamesp.h"
 #include "acinterp.h"
-#include "achware.h"
 
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evmisc")
@@ -178,7 +177,7 @@
 	}
 
 	/*
-	 * Get the notify object attached to the device Node
+	 * Get the notify object attached to the NS Node
 	 */
 	obj_desc = acpi_ns_get_attached_object (node);
 	if (obj_desc) {
@@ -186,25 +185,21 @@
 
 		switch (node->type) {
 		case ACPI_TYPE_DEVICE:
-
-			if (notify_value <= ACPI_MAX_SYS_NOTIFY) {
-				handler_obj = obj_desc->device.sys_handler;
-			}
-			else {
-				handler_obj = obj_desc->device.drv_handler;
-			}
-			break;
-
-
 		case ACPI_TYPE_THERMAL:
+		case ACPI_TYPE_PROCESSOR:
+		case ACPI_TYPE_POWER:
 
 			if (notify_value <= ACPI_MAX_SYS_NOTIFY) {
-				handler_obj = obj_desc->thermal_zone.sys_handler;
+				handler_obj = obj_desc->common_notify.sys_handler;
 			}
 			else {
-				handler_obj = obj_desc->thermal_zone.drv_handler;
+				handler_obj = obj_desc->common_notify.drv_handler;
 			}
 			break;
+
+		default:
+			/* All other types are not supported */
+			return (AE_TYPE);
 		}
 	}
 
@@ -323,14 +318,19 @@
 acpi_ev_global_lock_thread (
 	void                    *context)
 {
+	acpi_status             status;
+
 
 	/* Signal threads that are waiting for the lock */
 
 	if (acpi_gbl_global_lock_thread_count) {
 		/* Send sufficient units to the semaphore */
 
-		acpi_os_signal_semaphore (acpi_gbl_global_lock_semaphore,
+		status = acpi_os_signal_semaphore (acpi_gbl_global_lock_semaphore,
 				 acpi_gbl_global_lock_thread_count);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not signal Global Lock semaphore\n"));
+		}
 	}
 }
 
@@ -352,6 +352,7 @@
 	void                    *context)
 {
 	u8                      acquired = FALSE;
+	acpi_status             status;
 
 
 	/*
@@ -367,8 +368,14 @@
 
 		/* Run the Global Lock thread which will signal all waiting threads */
 
-		acpi_os_queue_for_execution (OSD_PRIORITY_HIGH, acpi_ev_global_lock_thread,
-				  context);
+		status = acpi_os_queue_for_execution (OSD_PRIORITY_HIGH,
+				  acpi_ev_global_lock_thread, context);
+		if (ACPI_FAILURE (status)) {
+			ACPI_REPORT_ERROR (("Could not queue Global Lock thread, %s\n",
+				acpi_format_exception (status)));
+
+			return (ACPI_INTERRUPT_NOT_HANDLED);
+		}
 	}
 
 	return (ACPI_INTERRUPT_HANDLED);
@@ -487,10 +494,11 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_ev_release_global_lock (void)
 {
 	u8                      pending = FALSE;
+	acpi_status             status = AE_OK;
 
 
 	ACPI_FUNCTION_TRACE ("Ev_release_global_lock");
@@ -498,7 +506,7 @@
 
 	if (!acpi_gbl_global_lock_thread_count) {
 		ACPI_REPORT_WARNING(("Cannot release HW Global Lock, it has not been acquired\n"));
-		return_VOID;
+		return_ACPI_STATUS (AE_NOT_ACQUIRED);
 	}
 
 	/* One fewer thread has the global lock */
@@ -507,7 +515,7 @@
 	if (acpi_gbl_global_lock_thread_count) {
 		/* There are still some threads holding the lock, cannot release */
 
-		return_VOID;
+		return_ACPI_STATUS (AE_OK);
 	}
 
 	/*
@@ -522,10 +530,10 @@
 	 * register
 	 */
 	if (pending) {
-		acpi_hw_bit_register_write (ACPI_BITREG_GLOBAL_LOCK_RELEASE, 1, ACPI_MTX_LOCK);
+		status = acpi_set_register (ACPI_BITREG_GLOBAL_LOCK_RELEASE, 1, ACPI_MTX_LOCK);
 	}
 
-	return_VOID;
+	return_ACPI_STATUS (status);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evregion.c linux/drivers/acpi/events/evregion.c
--- ../prev/linux/drivers/acpi/events/evregion.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evregion.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: evregion - ACPI Address_space (Op_region) handler dispatch
- *              $Revision: 128 $
+ *              $Revision: 133 $
  *
  *****************************************************************************/
 
@@ -28,7 +28,6 @@
 #include "acevents.h"
 #include "acnamesp.h"
 #include "acinterp.h"
-#include "amlcode.h"
 
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evregion")
@@ -36,7 +35,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_install_default_address_space_handlers
+ * FUNCTION:    Acpi_ev_init_address_spaces
  *
  * PARAMETERS:
  *
@@ -47,13 +46,13 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ev_install_default_address_space_handlers (
+acpi_ev_init_address_spaces (
 	void)
 {
 	acpi_status             status;
 
 
-	ACPI_FUNCTION_TRACE ("Ev_install_default_address_space_handlers");
+	ACPI_FUNCTION_TRACE ("Ev_init_address_spaces");
 
 
 	/*
@@ -166,7 +165,7 @@
 	/*
 	 *  Set up the parameter objects
 	 */
-	params[0]->integer.value  = region_obj->region.space_id;
+	params[0]->integer.value = region_obj->region.space_id;
 	params[1]->integer.value = function;
 	params[2] = NULL;
 
@@ -209,9 +208,10 @@
 	u32                     function,
 	ACPI_PHYSICAL_ADDRESS   address,
 	u32                     bit_width,
-	acpi_integer            *value)
+	void                    *value)
 {
 	acpi_status             status;
+	acpi_status             status2;
 	acpi_adr_space_handler  handler;
 	acpi_adr_space_setup    region_setup;
 	acpi_operand_object     *handler_desc;
@@ -267,7 +267,10 @@
 
 		/* Re-enter the interpreter */
 
-		acpi_ex_enter_interpreter ();
+		status2 = acpi_ex_enter_interpreter ();
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
 
 		/*
 		 *  Init routine may fail
@@ -325,7 +328,10 @@
 		 * We just returned from a non-default handler, we must re-enter the
 		 * interpreter
 		 */
-		acpi_ex_enter_interpreter ();
+		status2 = acpi_ex_enter_interpreter ();
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
 	}
 
 	return_ACPI_STATUS (status);
@@ -333,7 +339,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_disassociate_region_from_handler
+ * FUNCTION:    Acpi_ev_detach_region
  *
  * PARAMETERS:  Region_obj      - Region Object
  *              Acpi_ns_is_locked - Namespace Region Already Locked?
@@ -346,7 +352,7 @@
  ******************************************************************************/
 
 void
-acpi_ev_disassociate_region_from_handler(
+acpi_ev_detach_region(
 	acpi_operand_object     *region_obj,
 	u8                      acpi_ns_is_locked)
 {
@@ -359,12 +365,12 @@
 	acpi_status             status;
 
 
-	ACPI_FUNCTION_TRACE ("Ev_disassociate_region_from_handler");
+	ACPI_FUNCTION_TRACE ("Ev_detach_region");
 
 
 	region_obj2 = acpi_ns_get_secondary_object (region_obj);
 	if (!region_obj2) {
-		return;
+		return_VOID;
 	}
 	region_context = region_obj2->extra.region_context;
 
@@ -410,7 +416,12 @@
 			/*
 			 *  Now stop region accesses by executing the _REG method
 			 */
-			acpi_ev_execute_reg_method (region_obj, 0);
+			status = acpi_ev_execute_reg_method (region_obj, 0);
+			if (ACPI_FAILURE (status)) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%s from region _REG, [%s]\n",
+					acpi_format_exception (status),
+					acpi_ut_get_region_name (region_obj->region.space_id)));
+			}
 
 			if (acpi_ns_is_locked) {
 				status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
@@ -473,7 +484,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_ev_associate_region_and_handler
+ * FUNCTION:    Acpi_ev_attach_region
  *
  * PARAMETERS:  Handler_obj     - Handler Object
  *              Region_obj      - Region Object
@@ -487,15 +498,16 @@
  ******************************************************************************/
 
 acpi_status
-acpi_ev_associate_region_and_handler (
+acpi_ev_attach_region (
 	acpi_operand_object     *handler_obj,
 	acpi_operand_object     *region_obj,
 	u8                      acpi_ns_is_locked)
 {
-	acpi_status     status;
+	acpi_status             status;
+	acpi_status             status2;
 
 
-	ACPI_FUNCTION_TRACE ("Ev_associate_region_and_handler");
+	ACPI_FUNCTION_TRACE ("Ev_attach_region");
 
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
@@ -519,13 +531,19 @@
 	 * method
 	 */
 	if (acpi_ns_is_locked) {
-		acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		status2 = acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
 	}
 
 	status = acpi_ev_execute_reg_method (region_obj, 1);
 
 	if (acpi_ns_is_locked) {
-		(void) acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		status2 = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
+		if (ACPI_FAILURE (status2)) {
+			return_ACPI_STATUS (status2);
+		}
 	}
 
 	return_ACPI_STATUS (status);
@@ -665,12 +683,12 @@
 	 *
 	 *  First disconnect region for any previous handler (if any)
 	 */
-	acpi_ev_disassociate_region_from_handler (obj_desc, FALSE);
+	acpi_ev_detach_region (obj_desc, FALSE);
 
 	/*
 	 *  Then connect the region to the new handler
 	 */
-	status = acpi_ev_associate_region_and_handler (handler_obj, obj_desc, FALSE);
+	status = acpi_ev_attach_region (handler_obj, obj_desc, FALSE);
 
 	return (status);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evrgnini.c linux/drivers/acpi/events/evrgnini.c
--- ../prev/linux/drivers/acpi/events/evrgnini.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evrgnini.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: evrgnini- ACPI Address_space (Op_region) init
- *              $Revision: 57 $
+ *              $Revision: 61 $
  *
  *****************************************************************************/
 
@@ -27,8 +27,6 @@
 #include "acpi.h"
 #include "acevents.h"
 #include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
 
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evrgnini")
@@ -205,12 +203,12 @@
 	status = acpi_ut_evaluate_numeric_object (METHOD_NAME__ADR, node, &temp);
 
 	/*
-	 *  The default is zero, since the allocation above zeroed the data, just
-	 *  do nothing on failures.
+	 *  The default is zero, and since the allocation above zeroed
+	 *  the data, just do nothing on failure.
 	 */
 	if (ACPI_SUCCESS (status)) {
-		pci_id->device  = ACPI_HIWORD (temp);
-		pci_id->function = ACPI_LOWORD (temp);
+		pci_id->device  = ACPI_HIWORD (ACPI_LODWORD (temp));
+		pci_id->function = ACPI_LOWORD (ACPI_LODWORD (temp));
 	}
 
 	/*
@@ -235,9 +233,13 @@
 			if (ACPI_SUCCESS (status)) {
 				if (!(ACPI_STRNCMP (object_hID.buffer, PCI_ROOT_HID_STRING,
 						   sizeof (PCI_ROOT_HID_STRING)))) {
-					acpi_install_address_space_handler ((acpi_handle) node,
+					status = acpi_install_address_space_handler ((acpi_handle) node,
 							   ACPI_ADR_SPACE_PCI_CONFIG,
 							   ACPI_DEFAULT_HANDLER, NULL, NULL);
+					if (ACPI_FAILURE (status)) {
+						ACPI_REPORT_ERROR (("Could not install handler for %4.4s, %s\n",
+							node->name.ascii, acpi_format_exception (status)));
+					}
 					break;
 				}
 			}
@@ -457,7 +459,7 @@
 		obj_desc = acpi_ns_get_attached_object (node);
 		if (obj_desc) {
 			/*
-			 *  can only be a handler if the object exists
+			 * Can only be a handler if the object exists
 			 */
 			switch (node->type) {
 			case ACPI_TYPE_DEVICE:
@@ -474,6 +476,10 @@
 
 				handler_obj = obj_desc->thermal_zone.addr_handler;
 				break;
+
+			default:
+				/* Ignore other objects */
+				break;
 			}
 
 			while (handler_obj) {
@@ -489,8 +495,8 @@
 					/*
 					 *  Found it! Now update the region and the handler
 					 */
-					acpi_ev_associate_region_and_handler (handler_obj, region_obj,
-							acpi_ns_locked);
+					status = acpi_ev_attach_region (handler_obj, region_obj,
+							 acpi_ns_locked);
 
 					return_ACPI_STATUS (AE_OK);
 				}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evsci.c linux/drivers/acpi/events/evsci.c
--- ../prev/linux/drivers/acpi/events/evsci.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evsci.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: evsci - System Control Interrupt configuration and
  *                      legacy to ACPI mode state transition functions
- *              $Revision: 83 $
+ *              $Revision: 86 $
  *
  ******************************************************************************/
 
@@ -25,8 +25,6 @@
  */
 
 #include "acpi.h"
-#include "acnamesp.h"
-#include "achware.h"
 #include "acevents.h"
 
 
@@ -53,6 +51,8 @@
 	void                    *context)
 {
 	u32                     interrupt_handled = ACPI_INTERRUPT_NOT_HANDLED;
+	u32                     value;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE("Ev_sci_handler");
@@ -62,7 +62,12 @@
 	 * Make sure that ACPI is enabled by checking SCI_EN.  Note that we are
 	 * required to treat the SCI interrupt as sharable, level, active low.
 	 */
-	if (!acpi_hw_bit_register_read (ACPI_BITREG_SCI_ENABLE, ACPI_MTX_DO_NOT_LOCK)) {
+	status = acpi_get_register (ACPI_BITREG_SCI_ENABLE, &value, ACPI_MTX_DO_NOT_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return (ACPI_INTERRUPT_NOT_HANDLED);
+	}
+
+	if (!value) {
 		/* ACPI is not enabled;  this interrupt cannot be for us */
 
 		return_VALUE (ACPI_INTERRUPT_NOT_HANDLED);
@@ -135,15 +140,18 @@
 acpi_status
 acpi_ev_remove_sci_handler (void)
 {
+	acpi_status             status;
+
+
 	ACPI_FUNCTION_TRACE ("Ev_remove_sci_handler");
 
 
 	/* Just let the OS remove the handler and disable the level */
 
-	acpi_os_remove_interrupt_handler ((u32) acpi_gbl_FADT->sci_int,
+	status = acpi_os_remove_interrupt_handler ((u32) acpi_gbl_FADT->sci_int,
 			   acpi_ev_sci_handler);
 
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS (status);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evxface.c linux/drivers/acpi/events/evxface.c
--- ../prev/linux/drivers/acpi/events/evxface.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evxface.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: evxface - External interfaces for ACPI events
- *              $Revision: 126 $
+ *              $Revision: 128 $
  *
  *****************************************************************************/
 
@@ -25,10 +25,8 @@
 
 
 #include "acpi.h"
-#include "achware.h"
 #include "acnamesp.h"
 #include "acevents.h"
-#include "amlcode.h"
 #include "acinterp.h"
 
 #define _COMPONENT          ACPI_EVENTS
@@ -516,8 +514,12 @@
 
 	/* Clear the GPE (of stale events), the enable it */
 
-	acpi_hw_clear_gpe (gpe_number);
-	acpi_hw_enable_gpe (gpe_number);
+	status = acpi_hw_clear_gpe (gpe_number);
+	if (ACPI_FAILURE (status)) {
+		goto cleanup;
+	}
+
+	status = acpi_hw_enable_gpe (gpe_number);
 
 
 cleanup:
@@ -566,7 +568,10 @@
 
 	/* Disable the GPE before removing the handler */
 
-	acpi_hw_disable_gpe (gpe_number);
+	status = acpi_hw_disable_gpe (gpe_number);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_EVENTS);
 	if (ACPI_FAILURE (status)) {
@@ -576,7 +581,7 @@
 	/* Make sure that the installed handler is the same */
 
 	if (acpi_gbl_gpe_number_info[gpe_number_index].handler != handler) {
-		acpi_hw_enable_gpe (gpe_number);
+		(void) acpi_hw_enable_gpe (gpe_number);
 		status = AE_BAD_PARAMETER;
 		goto cleanup;
 	}
@@ -651,13 +656,15 @@
 acpi_release_global_lock (
 	u32                     handle)
 {
+	acpi_status             status;
+
 
 	if (handle != acpi_gbl_global_lock_handle) {
 		return (AE_NOT_ACQUIRED);
 	}
 
-	acpi_ev_release_global_lock ();
-	return (AE_OK);
+	status = acpi_ev_release_global_lock ();
+	return (status);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evxfevnt.c linux/drivers/acpi/events/evxfevnt.c
--- ../prev/linux/drivers/acpi/events/evxfevnt.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evxfevnt.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: evxfevnt - External Interfaces, ACPI event disable/enable
- *              $Revision: 51 $
+ *              $Revision: 55 $
  *
  *****************************************************************************/
 
@@ -25,11 +25,7 @@
 
 
 #include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
 #include "acevents.h"
-#include "amlcode.h"
-#include "acinterp.h"
 
 #define _COMPONENT          ACPI_EVENTS
 	 ACPI_MODULE_NAME    ("evxfevnt")
@@ -118,7 +114,7 @@
 
 	/* Unload the SCI interrupt handler  */
 
-	acpi_ev_remove_sci_handler ();
+	status = acpi_ev_remove_sci_handler ();
 	return_ACPI_STATUS (status);
 }
 
@@ -144,6 +140,7 @@
 	u32                     flags)
 {
 	acpi_status             status = AE_OK;
+	u32                     value;
 
 
 	ACPI_FUNCTION_TRACE ("Acpi_enable_event");
@@ -156,7 +153,7 @@
 
 		/* Decode the Fixed Event */
 
-		if (event > ACPI_NUM_FIXED_EVENTS) {
+		if (event > ACPI_EVENT_MAX) {
 			return_ACPI_STATUS (AE_BAD_PARAMETER);
 		}
 
@@ -164,13 +161,21 @@
 		 * Enable the requested fixed event (by writing a one to the
 		 * enable register bit)
 		 */
-		acpi_hw_bit_register_write (acpi_gbl_fixed_event_info[event].enable_register_id,
-				1, ACPI_MTX_LOCK);
+		status = acpi_set_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+				 1, ACPI_MTX_LOCK);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 
 		/* Make sure that the hardware responded */
 
-		if (1 != acpi_hw_bit_register_read (acpi_gbl_fixed_event_info[event].enable_register_id,
-				  ACPI_MTX_LOCK)) {
+		status = acpi_get_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+				  &value, ACPI_MTX_LOCK);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+
+		if (value != 1) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not enable %s event\n", acpi_ut_get_event_name (event)));
 			return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
@@ -188,7 +193,10 @@
 
 		/* Enable the requested GPE number */
 
-		acpi_hw_enable_gpe (event);
+		status = acpi_hw_enable_gpe (event);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 
 		if (flags & ACPI_EVENT_WAKE_ENABLE) {
 			acpi_hw_enable_gpe_for_wakeup (event);
@@ -226,6 +234,7 @@
 	u32                     flags)
 {
 	acpi_status             status = AE_OK;
+	u32                     value;
 
 
 	ACPI_FUNCTION_TRACE ("Acpi_disable_event");
@@ -238,7 +247,7 @@
 
 		/* Decode the Fixed Event */
 
-		if (event > ACPI_NUM_FIXED_EVENTS) {
+		if (event > ACPI_EVENT_MAX) {
 			return_ACPI_STATUS (AE_BAD_PARAMETER);
 		}
 
@@ -246,11 +255,19 @@
 		 * Disable the requested fixed event (by writing a zero to the
 		 * enable register bit)
 		 */
-		acpi_hw_bit_register_write (acpi_gbl_fixed_event_info[event].enable_register_id,
-				0, ACPI_MTX_LOCK);
+		status = acpi_set_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+				 0, ACPI_MTX_LOCK);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+
+		status = acpi_get_register (acpi_gbl_fixed_event_info[event].enable_register_id,
+				 &value, ACPI_MTX_LOCK);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 
-		if (0 != acpi_hw_bit_register_read (acpi_gbl_fixed_event_info[event].enable_register_id,
-				 ACPI_MTX_LOCK)) {
+		if (value != 0) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not disable %s events\n", acpi_ut_get_event_name (event)));
 			return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
@@ -275,7 +292,7 @@
 			acpi_hw_disable_gpe_for_wakeup (event);
 		}
 		else {
-			acpi_hw_disable_gpe (event);
+			status = acpi_hw_disable_gpe (event);
 		}
 		break;
 
@@ -319,7 +336,7 @@
 
 		/* Decode the Fixed Event */
 
-		if (event > ACPI_NUM_FIXED_EVENTS) {
+		if (event > ACPI_EVENT_MAX) {
 			return_ACPI_STATUS (AE_BAD_PARAMETER);
 		}
 
@@ -327,7 +344,7 @@
 		 * Clear the requested fixed event (By writing a one to the
 		 * status register bit)
 		 */
-		acpi_hw_bit_register_write (acpi_gbl_fixed_event_info[event].status_register_id,
+		status = acpi_set_register (acpi_gbl_fixed_event_info[event].status_register_id,
 				1, ACPI_MTX_LOCK);
 		break;
 
@@ -340,7 +357,7 @@
 			return_ACPI_STATUS (AE_BAD_PARAMETER);
 		}
 
-		acpi_hw_clear_gpe (event);
+		status = acpi_hw_clear_gpe (event);
 		break;
 
 
@@ -393,14 +410,14 @@
 
 		/* Decode the Fixed Event */
 
-		if (event > ACPI_NUM_FIXED_EVENTS) {
+		if (event > ACPI_EVENT_MAX) {
 			return_ACPI_STATUS (AE_BAD_PARAMETER);
 		}
 
 		/* Get the status of the requested fixed event */
 
-		*event_status = acpi_hw_bit_register_read (acpi_gbl_fixed_event_info[event].status_register_id,
-				   ACPI_MTX_LOCK);
+		status = acpi_get_register (acpi_gbl_fixed_event_info[event].status_register_id,
+				  event_status, ACPI_MTX_LOCK);
 		break;
 
 
@@ -414,7 +431,7 @@
 
 		/* Obtain status on the requested GPE number */
 
-		acpi_hw_get_gpe_status (event, event_status);
+		status = acpi_hw_get_gpe_status (event, event_status);
 		break;
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/events/evxfregn.c linux/drivers/acpi/events/evxfregn.c
--- ../prev/linux/drivers/acpi/events/evxfregn.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/events/evxfregn.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: evxfregn - External Interfaces, ACPI Operation Regions and
  *                         Address Spaces.
- *              $Revision: 48 $
+ *              $Revision: 50 $
  *
  *****************************************************************************/
 
@@ -26,10 +26,8 @@
 
 
 #include "acpi.h"
-#include "achware.h"
 #include "acnamesp.h"
 #include "acevents.h"
-#include "amlcode.h"
 #include "acinterp.h"
 
 #define _COMPONENT          ACPI_EVENTS
@@ -356,7 +354,7 @@
 				 * The region is just inaccessible as indicated to
 				 * the _REG method
 				 */
-				acpi_ev_disassociate_region_from_handler(region_obj, TRUE);
+				acpi_ev_detach_region (region_obj, TRUE);
 
 				/*
 				 * Walk the list, since we took the first region and it
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exconfig.c linux/drivers/acpi/executer/exconfig.c
--- ../prev/linux/drivers/acpi/executer/exconfig.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exconfig.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: exconfig - Namespace reconfiguration (Load/Unload opcodes)
- *              $Revision: 60 $
+ *              $Revision: 65 $
  *
  *****************************************************************************/
 
@@ -25,13 +25,11 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "acinterp.h"
 #include "amlcode.h"
 #include "acnamesp.h"
 #include "acevents.h"
 #include "actables.h"
-#include "acdispat.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -77,11 +75,11 @@
 	/* Install the new table into the local data structures */
 
 	table_info.pointer     = table;
-	table_info.length      = table->length;
+	table_info.length      = (ACPI_SIZE) table->length;
 	table_info.allocation  = ACPI_MEM_ALLOCATED;
 	table_info.base_pointer = table;
 
-	status = acpi_tb_install_table (NULL, &table_info);
+	status = acpi_tb_install_table (&table_info);
 	if (ACPI_FAILURE (status)) {
 		goto cleanup;
 	}
@@ -92,7 +90,7 @@
 	if (ACPI_FAILURE (status)) {
 		/* Uninstall table on error */
 
-		acpi_tb_uninstall_table (table_info.installed_desc);
+		(void) acpi_tb_uninstall_table (table_info.installed_desc);
 		goto cleanup;
 	}
 
@@ -227,10 +225,10 @@
 	if (parameter_node) {
 		/* Store the parameter data into the optional parameter object */
 
-		status = acpi_ex_store (operand[5], (acpi_operand_object *) parameter_node,
+		status = acpi_ex_store (operand[5], ACPI_CAST_PTR (acpi_operand_object, parameter_node),
 				 walk_state);
 		if (ACPI_FAILURE (status)) {
-			acpi_ex_unload_table (ddb_handle);
+			(void) acpi_ex_unload_table (ddb_handle);
 		}
 	}
 
@@ -267,7 +265,6 @@
 	acpi_table_header       table_header;
 	u32                     i;
 
-
 	ACPI_FUNCTION_TRACE ("Ex_load_op");
 
 
@@ -285,7 +282,7 @@
 		for (i = 0; i < sizeof (acpi_table_header); i++) {
 			status = acpi_ev_address_space_dispatch (obj_desc, ACPI_READ,
 					   (ACPI_PHYSICAL_ADDRESS) i, 8,
-					   (acpi_integer *) ((u8 *) &table_header + i));
+					   ((u8 *) &table_header) + i);
 			if (ACPI_FAILURE (status)) {
 				return_ACPI_STATUS (status);
 			}
@@ -308,7 +305,7 @@
 		for (i = 0; i < table_header.length; i++) {
 			status = acpi_ev_address_space_dispatch (obj_desc, ACPI_READ,
 					   (ACPI_PHYSICAL_ADDRESS) i, 8,
-					   (acpi_integer *) (table_data_ptr + i));
+					   ((u8 *) table_data_ptr + i));
 			if (ACPI_FAILURE (status)) {
 				goto cleanup;
 			}
@@ -334,7 +331,7 @@
 			goto cleanup;
 		}
 
-		table_ptr = (acpi_table_header *) buffer_desc->buffer.pointer;
+		table_ptr = ACPI_CAST_PTR (acpi_table_header, buffer_desc->buffer.pointer);
 		break;
 
 
@@ -352,7 +349,7 @@
 				 acpi_gbl_acpi_table_data[ACPI_TABLE_SSDT].sig_length))) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Table has invalid signature [%4.4s], must be SSDT or PSDT\n",
-			(char *) &table_ptr->signature));
+			table_ptr->signature));
 		status = AE_BAD_SIGNATURE;
 		goto cleanup;
 	}
@@ -368,7 +365,7 @@
 
 	status = acpi_ex_store (ddb_handle, target, walk_state);
 	if (ACPI_FAILURE (status)) {
-		acpi_ex_unload_table (ddb_handle);
+		(void) acpi_ex_unload_table (ddb_handle);
 	}
 
 	return_ACPI_STATUS (status);
@@ -417,7 +414,7 @@
 	 * validated here.
 	 */
 	if ((!ddb_handle) ||
-		(ACPI_GET_DESCRIPTOR_TYPE (ddb_handle) != ACPI_DESC_TYPE_INTERNAL) ||
+		(ACPI_GET_DESCRIPTOR_TYPE (ddb_handle) != ACPI_DESC_TYPE_OPERAND) ||
 		(((acpi_operand_object  *)ddb_handle)->common.type !=
 				INTERNAL_TYPE_REFERENCE)) {
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
@@ -431,14 +428,11 @@
 	 * Delete the entire namespace under this table Node
 	 * (Offset contains the Table_id)
 	 */
-	status = acpi_ns_delete_namespace_by_owner (table_info->table_id);
-	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
-	}
+	acpi_ns_delete_namespace_by_owner (table_info->table_id);
 
 	/* Delete the table itself */
 
-	acpi_tb_uninstall_table (table_info->installed_desc);
+	(void) acpi_tb_uninstall_table (table_info->installed_desc);
 
 	/* Delete the table descriptor (Ddb_handle) */
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exconvrt.c linux/drivers/acpi/executer/exconvrt.c
--- ../prev/linux/drivers/acpi/executer/exconvrt.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exconvrt.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: exconvrt - Object conversion routines
- *              $Revision: 32 $
+ *              $Revision: 36 $
  *
  *****************************************************************************/
 
@@ -25,12 +25,8 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
-#include "acnamesp.h"
 #include "acinterp.h"
-#include "acevents.h"
 #include "amlcode.h"
-#include "acdispat.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -60,9 +56,9 @@
 	u32                     i;
 	acpi_operand_object     *ret_desc;
 	u32                     count;
-	char                    *pointer;
+	u8                      *pointer;
 	acpi_integer            result;
-	u32                     integer_size = sizeof (acpi_integer);
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE_PTR ("Ex_convert_to_integer", obj_desc);
@@ -74,12 +70,12 @@
 		return_ACPI_STATUS (AE_OK);
 
 	case ACPI_TYPE_STRING:
-		pointer = obj_desc->string.pointer;
+		pointer = (u8 *) obj_desc->string.pointer;
 		count   = obj_desc->string.length;
 		break;
 
 	case ACPI_TYPE_BUFFER:
-		pointer = (char *) obj_desc->buffer.pointer;
+		pointer = obj_desc->buffer.pointer;
 		count   = obj_desc->buffer.length;
 		break;
 
@@ -88,24 +84,6 @@
 	}
 
 	/*
-	 * Create a new integer
-	 */
-	ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
-	if (!ret_desc) {
-		return_ACPI_STATUS (AE_NO_MEMORY);
-	}
-
-	/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
-
-	if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-		/*
-		 * We are running a method that exists in a 32-bit ACPI table.
-		 * Truncate the value to 32 bits by zeroing out the upper 32-bit field
-		 */
-		integer_size = sizeof (u32);
-	}
-
-	/*
 	 * Convert the buffer/string to an integer.  Note that both buffers and
 	 * strings are treated as raw data - we don't convert ascii to hex for
 	 * strings.
@@ -118,8 +96,8 @@
 
 	/* Transfer no more than an integer's worth of data */
 
-	if (count > integer_size) {
-		count = integer_size;
+	if (count > acpi_gbl_integer_byte_width) {
+		count = acpi_gbl_integer_byte_width;
 	}
 
 	/*
@@ -128,13 +106,14 @@
 	switch (obj_desc->common.type) {
 	case ACPI_TYPE_STRING:
 
-		/* TBD: Need to use 64-bit ACPI_STRTOUL */
-
 		/*
 		 * Convert string to an integer
 		 * String must be hexadecimal as per the ACPI specification
 		 */
-		result = ACPI_STRTOUL (pointer, NULL, 16);
+		status = acpi_ut_strtoul64 ((char *) pointer, 16, &result);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 		break;
 
 
@@ -153,6 +132,19 @@
 			result |= (((acpi_integer) pointer[i]) << (i * 8));
 		}
 		break;
+
+
+	default:
+		/* No other types can get here */
+		break;
+	}
+
+	/*
+	 * Create a new integer
+	 */
+	ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
+	if (!ret_desc) {
+		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
 	/* Save the Result, delete original descriptor, store new descriptor */
@@ -192,7 +184,6 @@
 {
 	acpi_operand_object     *ret_desc;
 	u32                     i;
-	u32                     integer_size = sizeof (acpi_integer);
 	u8                      *new_buf;
 
 
@@ -203,27 +194,16 @@
 	case ACPI_TYPE_INTEGER:
 
 		/*
-		 * Create a new Buffer
+		 * Create a new Buffer object
 		 */
 		ret_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
 		if (!ret_desc) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
-
-		if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-			/*
-			 * We are running a method that exists in a 32-bit ACPI table.
-			 * Use only 32 bits of the Integer for conversion.
-			 */
-			integer_size = sizeof (u32);
-		}
-
 		/* Need enough space for one integer */
 
-		ret_desc->buffer.length = integer_size;
-		new_buf = ACPI_MEM_CALLOCATE (integer_size);
+		new_buf = ACPI_MEM_CALLOCATE (acpi_gbl_integer_byte_width);
 		if (!new_buf) {
 			ACPI_REPORT_ERROR
 				(("Ex_convert_to_buffer: Buffer allocation failure\n"));
@@ -233,10 +213,15 @@
 
 		/* Copy the integer to the buffer */
 
-		for (i = 0; i < integer_size; i++) {
+		for (i = 0; i < acpi_gbl_integer_byte_width; i++) {
 			new_buf[i] = (u8) (obj_desc->integer.value >> (i * 8));
 		}
+
+		/* Complete buffer object initialization */
+
+		ret_desc->buffer.flags |= AOPOBJ_DATA_VALID;
 		ret_desc->buffer.pointer = new_buf;
+		ret_desc->buffer.length = acpi_gbl_integer_byte_width;
 
 		/* Return the new buffer descriptor */
 
@@ -286,7 +271,7 @@
 	u32                     i;
 	u32                     j;
 	u32                     k = 0;
-	u8                      hex_digit;
+	char                    hex_digit;
 	acpi_integer            digit;
 	u32                     remainder;
 	u32                     length = sizeof (acpi_integer);
@@ -305,7 +290,7 @@
 
 			digit = integer;
 			for (j = 1; j < i; j++) {
-				acpi_ut_short_divide (&digit, 10, &digit, &remainder);
+				(void) acpi_ut_short_divide (&digit, 10, &digit, &remainder);
 			}
 
 			/* Create the decimal digit */
@@ -333,7 +318,7 @@
 			}
 
 			if (!leading_zero) {
-				string[k] = hex_digit;
+				string[k] = (u8) hex_digit;
 				k++;
 			}
 		}
@@ -385,7 +370,6 @@
 	u32                     i;
 	u32                     index;
 	u32                     string_length;
-	u32                     integer_size = sizeof (acpi_integer);
 	u8                      *new_buf;
 	u8                      *pointer;
 
@@ -396,17 +380,7 @@
 	switch (obj_desc->common.type) {
 	case ACPI_TYPE_INTEGER:
 
-		/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
-
-		if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-			/*
-			 * We are running a method that exists in a 32-bit ACPI table.
-			 * Use only 32 bits of the Integer
-			 */
-			integer_size = sizeof (u32);
-		}
-
-		string_length = integer_size * 2;
+		string_length = acpi_gbl_integer_byte_width * 2;
 		if (base == 10) {
 			string_length = ACPI_MAX_DECIMAL_DIGITS;
 		}
@@ -421,7 +395,7 @@
 
 		/* Need enough space for one ASCII integer plus null terminator */
 
-		new_buf = ACPI_MEM_CALLOCATE (string_length + 1);
+		new_buf = ACPI_MEM_CALLOCATE ((ACPI_SIZE) string_length + 1);
 		if (!new_buf) {
 			ACPI_REPORT_ERROR
 				(("Ex_convert_to_string: Buffer allocation failure\n"));
@@ -429,7 +403,6 @@
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-
 		/* Convert */
 
 		i = acpi_ex_convert_to_ascii (obj_desc->integer.value, base, new_buf);
@@ -486,7 +459,7 @@
 			string_length = max_length;
 		}
 
-		new_buf = ACPI_MEM_CALLOCATE (string_length + 1);
+		new_buf = ACPI_MEM_CALLOCATE ((ACPI_SIZE) string_length + 1);
 		if (!new_buf) {
 			ACPI_REPORT_ERROR
 				(("Ex_convert_to_string: Buffer allocation failure\n"));
@@ -500,7 +473,7 @@
 		pointer = obj_desc->buffer.pointer;
 		index = 0;
 		for (i = 0, index = 0; i < obj_desc->buffer.length; i++) {
-			index = acpi_ex_convert_to_ascii (pointer[i], base, &new_buf[index]);
+			index = acpi_ex_convert_to_ascii ((acpi_integer) pointer[i], base, &new_buf[index]);
 
 			new_buf[index] = ' ';
 			index++;
@@ -512,7 +485,6 @@
 		ret_desc->buffer.pointer = new_buf;
 		ret_desc->string.length = ACPI_STRLEN ((char *) new_buf);
 
-
 		/* Return the new buffer descriptor */
 
 		if (*result_desc == obj_desc) {
@@ -641,6 +613,11 @@
 			 */
 			status = acpi_ex_convert_to_buffer (source_desc, result_desc, walk_state);
 			break;
+
+
+		default:
+			status = AE_AML_INTERNAL;
+			break;
 		}
 		break;
 
@@ -660,7 +637,6 @@
 
 		status = AE_AML_INTERNAL;
 	}
-
 
 	/*
 	 * Source-to-Target conversion semantics:
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/excreate.c linux/drivers/acpi/executer/excreate.c
--- ../prev/linux/drivers/acpi/executer/excreate.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/excreate.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: excreate - Named object creation
- *              $Revision: 89 $
+ *              $Revision: 91 $
  *
  *****************************************************************************/
 
@@ -25,12 +25,10 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "acinterp.h"
 #include "amlcode.h"
 #include "acnamesp.h"
 #include "acevents.h"
-#include "acdispat.h"
 #include "actables.h"
 
 
@@ -234,7 +232,7 @@
 
 	/* Get the Node from the object stack  */
 
-	node = walk_state->op->node;
+	node = walk_state->op->common.node;
 
 	/*
 	 * If the region object is already attached to this node,
@@ -323,7 +321,7 @@
 
 	/* Get the Node from the object stack  */
 
-	node = walk_state->op->node;
+	node = walk_state->op->common.node;
 
 	/*
 	 * If the region object is already attached to this node,
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exdump.c linux/drivers/acpi/executer/exdump.c
--- ../prev/linux/drivers/acpi/executer/exdump.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exdump.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: exdump - Interpreter debug output routines
- *              $Revision: 147 $
+ *              $Revision: 153 $
  *
  *****************************************************************************/
 
@@ -28,7 +28,6 @@
 #include "acinterp.h"
 #include "amlcode.h"
 #include "acnamesp.h"
-#include "actables.h"
 #include "acparser.h"
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -43,90 +42,6 @@
 
 /*****************************************************************************
  *
- * FUNCTION:    Acpi_ex_show_hex_value
- *
- * PARAMETERS:  Byte_count          - Number of bytes to print (1, 2, or 4)
- *              *Aml_start            - Address in AML stream of bytes to print
- *              Interpreter_mode    - Current running mode (load1/Load2/Exec)
- *              Lead_space          - # of spaces to print ahead of value
- *                                    0 => none ahead but one behind
- *
- * DESCRIPTION: Print Byte_count byte(s) starting at Aml_start as a single
- *              value, in hex.  If Byte_count > 1 or the value printed is > 9, also
- *              print in decimal.
- *
- ****************************************************************************/
-
-void
-acpi_ex_show_hex_value (
-	u32                     byte_count,
-	u8                      *aml_start,
-	u32                     lead_space)
-{
-	u32                     value;                  /*  Value retrieved from AML stream */
-	u32                     show_decimal_value;
-	u32                     length;                 /*  Length of printed field */
-	u8                      *current_aml_ptr = NULL; /* Pointer to current byte of AML value    */
-
-
-	ACPI_FUNCTION_TRACE ("Ex_show_hex_value");
-
-
-	if (!((ACPI_LV_LOAD & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer))) {
-		return;
-	}
-
-	if (!aml_start) {
-		ACPI_REPORT_ERROR (("Ex_show_hex_value: null pointer\n"));
-		return;
-	}
-
-	/*
-	 * AML numbers are always stored little-endian,
-	 * even if the processor is big-endian.
-	 */
-	for (current_aml_ptr = aml_start + byte_count,
-			value = 0;
-			current_aml_ptr > aml_start; ) {
-		value = (value << 8) + (u32)* --current_aml_ptr;
-	}
-
-	length = lead_space * byte_count + 2;
-	if (byte_count > 1) {
-		length += (byte_count - 1);
-	}
-
-	show_decimal_value = (byte_count > 1 || value > 9);
-	if (show_decimal_value) {
-		length += 3 + acpi_ex_digits_needed (value, 10);
-	}
-
-	for (length = lead_space; length; --length ) {
-		acpi_os_printf (" ");
-	}
-
-	while (byte_count--) {
-		acpi_os_printf ("%02x", *aml_start++);
-		if (byte_count) {
-			acpi_os_printf (" ");
-		}
-	}
-
-	if (show_decimal_value) {
-		acpi_os_printf (" [%d]", value);
-	}
-
-	if (0 == lead_space) {
-		acpi_os_printf (" ");
-	}
-
-	acpi_os_printf ("\n");
-	return_VOID;
-}
-
-
-/*****************************************************************************
- *
  * FUNCTION:    Acpi_ex_dump_operand
  *
  * PARAMETERS:  *Obj_desc         - Pointer to entry to be dumped
@@ -137,20 +52,22 @@
  *
  ****************************************************************************/
 
-acpi_status
+void
 acpi_ex_dump_operand (
 	acpi_operand_object     *obj_desc)
 {
 	u8                      *buf = NULL;
 	u32                     length;
 	u32                     i;
+	acpi_operand_object     **element;
+	u16                     element_index;
 
 
 	ACPI_FUNCTION_NAME ("Ex_dump_operand")
 
 
 	if (!((ACPI_LV_EXEC & acpi_dbg_level) && (_COMPONENT & acpi_dbg_layer))) {
-		return (AE_OK);
+		return;
 	}
 
 	if (!obj_desc) {
@@ -160,19 +77,19 @@
 		 * code that dumps the stack expects something to be there!
 		 */
 		acpi_os_printf ("Null stack entry ptr\n");
-		return (AE_OK);
+		return;
 	}
 
 	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_NAMED) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p NS Node: ", obj_desc));
 		ACPI_DUMP_ENTRY (obj_desc, ACPI_LV_EXEC);
-		return (AE_OK);
+		return;
 	}
 
-	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_INTERNAL) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_OPERAND) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%p is not a local object\n", obj_desc));
 		ACPI_DUMP_BUFFER (obj_desc, sizeof (acpi_operand_object));
-		return (AE_OK);
+		return;
 	}
 
 	/*  Obj_desc is a valid object */
@@ -265,7 +182,7 @@
 
 		case AML_INT_NAMEPATH_OP:
 			acpi_os_printf ("Reference.Node->Name %X\n",
-					 obj_desc->reference.node->name);
+					 obj_desc->reference.node->name.integer);
 			break;
 
 		default:
@@ -343,18 +260,13 @@
 		if (obj_desc->package.count &&
 			obj_desc->package.elements &&
 			acpi_dbg_level > 1) {
-			acpi_operand_object**element;
-			u16                 element_index;
-
 			for (element_index = 0, element = obj_desc->package.elements;
 				  element_index < obj_desc->package.count;
 				  ++element_index, ++element) {
 				acpi_ex_dump_operand (*element);
 			}
 		}
-
 		acpi_os_printf ("\n");
-
 		break;
 
 
@@ -389,7 +301,6 @@
 			acpi_os_printf ("%c",
 					 obj_desc->string.pointer[i]);
 		}
-
 		acpi_os_printf ("\"\n");
 		break;
 
@@ -429,13 +340,11 @@
 		{
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "*NULL* \n"));
 		}
-
 		else if (ACPI_TYPE_BUFFER !=
 				  obj_desc->buffer_field.buffer_obj->common.type)
 		{
 			acpi_os_printf ("*not a Buffer* \n");
 		}
-
 		else
 		{
 			ACPI_DUMP_STACK_ENTRY (obj_desc->buffer_field.buffer_obj);
@@ -490,13 +399,13 @@
 
 
 	default:
-		/*  unknown Obj_desc->Common.Type value   */
+		/* Unknown Obj_desc->Common.Type value */
 
 		acpi_os_printf ("Unknown Type %X\n", obj_desc->common.type);
 		break;
 	}
 
-	return (AE_OK);
+	return;
 }
 
 
@@ -540,7 +449,6 @@
 		note = "?";
 	}
 
-
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 		"************* Operand Stack Contents (Opcode [%s], %d Operands)\n",
 		ident, num_levels));
@@ -550,16 +458,12 @@
 		num_levels = 1;
 	}
 
-	/* Dump the stack starting at the top, working down */
+	/* Dump the operand stack starting at the top */
 
 	for (i = 0; num_levels > 0; i--, num_levels--)
 	{
 		obj_desc = &operands[i];
-
-		if (ACPI_FAILURE (acpi_ex_dump_operand (*obj_desc)))
-		{
-			break;
-		}
+		acpi_ex_dump_operand (*obj_desc);
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
@@ -611,7 +515,8 @@
 	char                    *title,
 	ACPI_PHYSICAL_ADDRESS   value)
 {
-#ifdef _IA16
+
+#if ACPI_MACHINE_WIDTH == 16
 	acpi_os_printf ("%20s : %p\n", title, value);
 #else
 	acpi_os_printf ("%20s : %8.8X%8.8X\n", title,
@@ -648,8 +553,7 @@
 		}
 	}
 
-
-	acpi_os_printf ("%20s : %4.4s\n",     "Name", (char *) &node->name);
+	acpi_os_printf ("%20s : %4.4s\n",     "Name", node->name.ascii);
 	acpi_ex_out_string ("Type",           acpi_ut_get_type_name (node->type));
 	acpi_ex_out_integer ("Flags",         node->flags);
 	acpi_ex_out_integer ("Owner Id",      node->owner_id);
@@ -691,7 +595,7 @@
 		}
 	}
 
-	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_INTERNAL)
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_OPERAND)
 	{
 		acpi_os_printf ("Ex_dump_object_descriptor: %p is not a valid ACPI object\n", obj_desc);
 		return;
@@ -709,7 +613,7 @@
 	{
 	case ACPI_TYPE_INTEGER:
 
-		acpi_os_printf ("%20s : %X%8.8X\n", "Value",
+		acpi_os_printf ("%20s : %8.8X%8.8X\n", "Value",
 				  ACPI_HIDWORD (obj_desc->integer.value),
 				  ACPI_LODWORD (obj_desc->integer.value));
 		break;
@@ -811,7 +715,7 @@
 
 		acpi_ex_out_integer ("Processor ID", obj_desc->processor.proc_id);
 		acpi_ex_out_integer ("Length",       obj_desc->processor.length);
-		acpi_ex_out_integer ("Address",      obj_desc->processor.address);
+		acpi_ex_out_address ("Address",      (ACPI_PHYSICAL_ADDRESS) obj_desc->processor.address);
 		acpi_ex_out_pointer ("Sys_handler",  obj_desc->processor.sys_handler);
 		acpi_ex_out_pointer ("Drv_handler",  obj_desc->processor.drv_handler);
 		acpi_ex_out_pointer ("Addr_handler", obj_desc->processor.addr_handler);
@@ -861,6 +765,10 @@
 			acpi_ex_out_integer ("Value",        obj_desc->index_field.value);
 			acpi_ex_out_pointer ("Index",        obj_desc->index_field.index_obj);
 			acpi_ex_out_pointer ("Data",         obj_desc->index_field.data_obj);
+			break;
+
+		default:
+			/* All object types covered above */
 			break;
 		}
 		break;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exfield.c linux/drivers/acpi/executer/exfield.c
--- ../prev/linux/drivers/acpi/executer/exfield.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exfield.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: exfield - ACPI AML (p-code) execution - field manipulation
- *              $Revision: 108 $
+ *              $Revision: 110 $
  *
  *****************************************************************************/
 
@@ -27,10 +27,6 @@
 #include "acpi.h"
 #include "acdispat.h"
 #include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -61,7 +57,6 @@
 	acpi_status             status;
 	acpi_operand_object     *buffer_desc;
 	u32                     length;
-	u32                     integer_size;
 	void                    *buffer;
 	u8                      locked;
 
@@ -99,19 +94,7 @@
 	 * Note: Field.length is in bits.
 	 */
 	length = ACPI_ROUND_BITS_UP_TO_BYTES (obj_desc->field.bit_length);
-
-	/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
-
-	integer_size = sizeof (acpi_integer);
-	if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-		/*
-		 * We are running a method that exists in a 32-bit ACPI table.
-		 * Integer size is 4.
-		 */
-		integer_size = sizeof (u32);
-	}
-
-	if (length > integer_size) {
+	if (length > acpi_gbl_integer_byte_width) {
 		/* Field is too large for an Integer, create a Buffer instead */
 
 		buffer_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
@@ -139,7 +122,7 @@
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
 
-		length = integer_size;
+		length = acpi_gbl_integer_byte_width;
 		buffer_desc->integer.value = 0;
 		buffer = &buffer_desc->integer.value;
 	}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exfldio.c linux/drivers/acpi/executer/exfldio.c
--- ../prev/linux/drivers/acpi/executer/exfldio.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exfldio.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: exfldio - Aml Field I/O
- *              $Revision: 84 $
+ *              $Revision: 86 $
  *
  *****************************************************************************/
 
@@ -27,8 +27,6 @@
 #include "acpi.h"
 #include "acinterp.h"
 #include "amlcode.h"
-#include "acnamesp.h"
-#include "achware.h"
 #include "acevents.h"
 #include "acdispat.h"
 
@@ -67,7 +65,7 @@
 	rgn_desc = obj_desc->common_field.region_obj;
 
 	if (ACPI_TYPE_REGION != rgn_desc->common.type) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Needed Region, found type %x %s\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Needed Region, found type %X (%s)\n",
 			rgn_desc->common.type, acpi_ut_get_type_name (rgn_desc->common.type)));
 		return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
 	}
@@ -99,8 +97,8 @@
 			 */
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Field [%4.4s] access width (%d bytes) too large for region [%4.4s] (length %X)\n",
-				(char *) &obj_desc->common_field.node->name, obj_desc->common_field.access_byte_width,
-				(char *) &rgn_desc->region.node->name, rgn_desc->region.length));
+				obj_desc->common_field.node->name.ascii, obj_desc->common_field.access_byte_width,
+				rgn_desc->region.node->name.ascii, rgn_desc->region.length));
 		}
 
 		/*
@@ -109,9 +107,9 @@
 		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Field [%4.4s] Base+Offset+Width %X+%X+%X is beyond end of region [%4.4s] (length %X)\n",
-			(char *) &obj_desc->common_field.node->name, obj_desc->common_field.base_byte_offset,
+			obj_desc->common_field.node->name.ascii, obj_desc->common_field.base_byte_offset,
 			field_datum_byte_offset, obj_desc->common_field.access_byte_width,
-			(char *) &rgn_desc->region.node->name, rgn_desc->region.length));
+			rgn_desc->region.node->name.ascii, rgn_desc->region.length));
 
 		return_ACPI_STATUS (AE_AML_REGION_LIMIT);
 	}
@@ -235,7 +233,7 @@
 		return (FALSE);
 	}
 
-	if (value >= (acpi_integer) (1 << obj_desc->common_field.bit_length)) {
+	if (value >= ((acpi_integer) 1 << obj_desc->common_field.bit_length)) {
 		/*
 		 * The Value is larger than the maximum value that can fit into
 		 * the register.
@@ -343,7 +341,7 @@
 		/* Ensure that the Bank_value is not beyond the capacity of the register */
 
 		if (acpi_ex_register_overflow (obj_desc->bank_field.bank_obj,
-				  obj_desc->bank_field.value)) {
+				  (acpi_integer) obj_desc->bank_field.value)) {
 			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
 		}
 
@@ -363,7 +361,7 @@
 		 * Region_field case and write the datum to the Operation Region
 		 */
 
-		/* No break; ! */
+		/*lint -fallthrough */
 
 
 	case INTERNAL_TYPE_REGION_FIELD:
@@ -387,7 +385,7 @@
 		/* Ensure that the Index_value is not beyond the capacity of the register */
 
 		if (acpi_ex_register_overflow (obj_desc->index_field.index_obj,
-				  obj_desc->index_field.value)) {
+				  (acpi_integer) obj_desc->index_field.value)) {
 			return_ACPI_STATUS (AE_AML_REGISTER_LIMIT);
 		}
 
@@ -472,7 +470,7 @@
 
 	/* If the mask is all ones, we don't need to worry about the update rule */
 
-	if (mask != ACPI_UINT32_MAX) {
+	if (mask != ACPI_INTEGER_MAX) {
 		/* Decode the update rule */
 
 		switch (obj_desc->common_field.field_flags & AML_FIELD_UPDATE_RULE_MASK) {
@@ -509,7 +507,7 @@
 
 		default:
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-				"Write_with_update_rule: Unknown Update_rule setting: %x\n",
+				"Write_with_update_rule: Unknown Update_rule setting: %X\n",
 				(obj_desc->common_field.field_flags & AML_FIELD_UPDATE_RULE_MASK)));
 			return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
 		}
@@ -579,6 +577,10 @@
 
 		ACPI_MOVE_UNALIGNED64_TO_64 (datum, &(((u64 *) buffer) [offset]));
 		break;
+
+	default:
+		/* Should not get here */
+		break;
 	}
 }
 
@@ -631,6 +633,10 @@
 
 		ACPI_MOVE_UNALIGNED64_TO_64 (&(((u64 *) buffer)[offset]), &merged_datum);
 		break;
+
+	default:
+		/* Should not get here */
+		break;
 	}
 }
 
@@ -685,7 +691,7 @@
 			   obj_desc->common_field.access_byte_width);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-		"Byte_len=%x, Datum_len=%x, Byte_gran=%x\n",
+		"Byte_len=%X, Datum_len=%X, Byte_gran=%X\n",
 		byte_field_length, datum_count,obj_desc->common_field.access_byte_width));
 
 	/*
@@ -863,7 +869,7 @@
 	datum_count = ACPI_ROUND_UP_TO (byte_field_length, obj_desc->common_field.access_byte_width);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-		"Byte_len=%x, Datum_len=%x, Byte_gran=%x\n",
+		"Byte_len=%X, Datum_len=%X, Byte_gran=%X\n",
 		byte_field_length, datum_count, obj_desc->common_field.access_byte_width));
 
 	/*
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exmisc.c linux/drivers/acpi/executer/exmisc.c
--- ../prev/linux/drivers/acpi/executer/exmisc.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exmisc.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exmisc - ACPI AML (p-code) execution - specific opcodes
- *              $Revision: 100 $
+ *              $Revision: 105 $
  *
  *****************************************************************************/
 
@@ -26,7 +26,6 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "acinterp.h"
 #include "amlcode.h"
 #include "acdispat.h"
@@ -63,7 +62,7 @@
 
 
 	switch (ACPI_GET_DESCRIPTOR_TYPE (obj_desc)) {
-	case ACPI_DESC_TYPE_INTERNAL:
+	case ACPI_DESC_TYPE_OPERAND:
 
 		if (obj_desc->common.type != INTERNAL_TYPE_REFERENCE) {
 			*return_desc = NULL;
@@ -81,7 +80,7 @@
 
 			status = acpi_ds_method_data_get_node (obj_desc->reference.opcode,
 					  obj_desc->reference.offset, walk_state,
-					  (acpi_namespace_node **) return_desc);
+					  ACPI_CAST_INDIRECT_PTR (acpi_namespace_node, return_desc));
 			break;
 
 		default:
@@ -185,15 +184,15 @@
 	ACPI_MEMCPY (new_buf, obj_desc1->buffer.pointer, length1);
 	ACPI_MEMCPY (new_buf + length1, obj_desc2->buffer.pointer, length2);
 
-	/*
-	 * Point the return object to the new buffer
-	 */
+	/* Complete the buffer object initialization */
+
+	return_desc->common.flags  = AOPOBJ_DATA_VALID;
 	return_desc->buffer.pointer = (u8 *) new_buf;
-	return_desc->buffer.length = length1 + length2;
+	return_desc->buffer.length = (u32) (length1 + length2);
 
 	/* Compute the new checksum */
 
-	new_buf[return_desc->buffer.length - 1] =
+	new_buf[return_desc->buffer.length - 1] = (NATIVE_CHAR)
 			acpi_ut_generate_checksum (return_desc->buffer.pointer,
 					 (return_desc->buffer.length - 1));
 
@@ -237,7 +236,6 @@
 	acpi_integer            this_integer;
 	acpi_operand_object     *return_desc;
 	NATIVE_CHAR             *new_buf;
-	u32                     integer_size = sizeof (acpi_integer);
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -245,34 +243,24 @@
 
 	/*
 	 * There are three cases to handle:
-	 * 1) Two Integers concatenated to produce a buffer
-	 * 2) Two Strings concatenated to produce a string
-	 * 3) Two Buffers concatenated to produce a buffer
+	 *
+	 * 1) Two Integers concatenated to produce a new Buffer
+	 * 2) Two Strings concatenated to produce a new String
+	 * 3) Two Buffers concatenated to produce a new Buffer
 	 */
 	switch (obj_desc1->common.type) {
 	case ACPI_TYPE_INTEGER:
 
-		/* Handle both ACPI 1.0 and ACPI 2.0 Integer widths */
-
-		if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
-			/*
-			 * We are running a method that exists in a 32-bit ACPI table.
-			 * Truncate the value to 32 bits by zeroing out the upper
-			 * 32-bit field
-			 */
-			integer_size = sizeof (u32);
-		}
-
-		/* Result of two integers is a buffer */
+		/* Result of two Integers is a Buffer */
 
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
 		if (!return_desc) {
 			return (AE_NO_MEMORY);
 		}
 
-		/* Need enough space for two integers */
+		/* Need enough buffer space for two integers */
 
-		return_desc->buffer.length = integer_size * 2;
+		return_desc->buffer.length = acpi_gbl_integer_byte_width * 2;
 		new_buf = ACPI_MEM_CALLOCATE (return_desc->buffer.length);
 		if (!new_buf) {
 			ACPI_REPORT_ERROR
@@ -281,29 +269,33 @@
 			goto cleanup;
 		}
 
-		return_desc->buffer.pointer = (u8 *) new_buf;
-
 		/* Convert the first integer */
 
 		this_integer = obj_desc1->integer.value;
-		for (i = 0; i < integer_size; i++) {
-			new_buf[i] = (u8) this_integer;
+		for (i = 0; i < acpi_gbl_integer_byte_width; i++) {
+			new_buf[i] = (NATIVE_CHAR) this_integer;
 			this_integer >>= 8;
 		}
 
 		/* Convert the second integer */
 
 		this_integer = obj_desc2->integer.value;
-		for (; i < (integer_size * 2); i++) {
-			new_buf[i] = (u8) this_integer;
+		for (; i < (ACPI_MUL_2 (acpi_gbl_integer_byte_width)); i++) {
+			new_buf[i] = (NATIVE_CHAR) this_integer;
 			this_integer >>= 8;
 		}
 
+		/* Complete the buffer object initialization */
+
+		return_desc->common.flags  = AOPOBJ_DATA_VALID;
+		return_desc->buffer.pointer = (u8 *) new_buf;
 		break;
 
 
 	case ACPI_TYPE_STRING:
 
+		/* Result of two Strings is a String */
+
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_STRING);
 		if (!return_desc) {
 			return (AE_NO_MEMORY);
@@ -311,8 +303,8 @@
 
 		/* Operand0 is string  */
 
-		new_buf = ACPI_MEM_ALLOCATE (obj_desc1->string.length +
-				  obj_desc2->string.length + 1);
+		new_buf = ACPI_MEM_ALLOCATE ((ACPI_SIZE) obj_desc1->string.length +
+				  (ACPI_SIZE) obj_desc2->string.length + 1);
 		if (!new_buf) {
 			ACPI_REPORT_ERROR
 				(("Ex_do_concatenate: String allocation failure\n"));
@@ -320,11 +312,13 @@
 			goto cleanup;
 		}
 
+		/* Concatenate the strings */
+
 		ACPI_STRCPY (new_buf, obj_desc1->string.pointer);
 		ACPI_STRCPY (new_buf + obj_desc1->string.length,
 				  obj_desc2->string.pointer);
 
-		/* Point the return object to the new string */
+		/* Complete the String object initialization */
 
 		return_desc->string.pointer = new_buf;
 		return_desc->string.length = obj_desc1->string.length +
@@ -334,15 +328,15 @@
 
 	case ACPI_TYPE_BUFFER:
 
-		/* Operand0 is a buffer */
+		/* Result of two Buffers is a Buffer */
 
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_BUFFER);
 		if (!return_desc) {
 			return (AE_NO_MEMORY);
 		}
 
-		new_buf = ACPI_MEM_ALLOCATE (obj_desc1->buffer.length +
-				  obj_desc2->buffer.length);
+		new_buf = ACPI_MEM_ALLOCATE ((ACPI_SIZE) obj_desc1->buffer.length +
+				  (ACPI_SIZE) obj_desc2->buffer.length);
 		if (!new_buf) {
 			ACPI_REPORT_ERROR
 				(("Ex_do_concatenate: Buffer allocation failure\n"));
@@ -350,22 +344,26 @@
 			goto cleanup;
 		}
 
+		/* Concatenate the buffers */
+
 		ACPI_MEMCPY (new_buf, obj_desc1->buffer.pointer,
 				  obj_desc1->buffer.length);
 		ACPI_MEMCPY (new_buf + obj_desc1->buffer.length, obj_desc2->buffer.pointer,
 				   obj_desc2->buffer.length);
 
-		/*
-		 * Point the return object to the new buffer
-		 */
+		/* Complete the buffer object initialization */
 
+		return_desc->common.flags  = AOPOBJ_DATA_VALID;
 		return_desc->buffer.pointer = (u8 *) new_buf;
 		return_desc->buffer.length = obj_desc1->buffer.length +
-				  obj_desc2->buffer.length;
+				   obj_desc2->buffer.length;
 		break;
 
 
 	default:
+
+		/* Invalid object type, should not happen here */
+
 		status = AE_AML_INTERNAL;
 		return_desc = NULL;
 	}
@@ -530,6 +528,9 @@
 		if (operand0 || operand1) {
 			return (TRUE);
 		}
+		break;
+
+	default:
 		break;
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exmutex.c linux/drivers/acpi/executer/exmutex.c
--- ../prev/linux/drivers/acpi/executer/exmutex.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exmutex.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exmutex - ASL Mutex Acquire/Release functions
- *              $Revision: 10 $
+ *              $Revision: 13 $
  *
  *****************************************************************************/
 
@@ -27,9 +27,6 @@
 
 #include "acpi.h"
 #include "acinterp.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
 
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exmutex")
@@ -269,12 +266,13 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_release_all_mutexes (
 	ACPI_THREAD_STATE       *thread)
 {
 	acpi_operand_object     *next = thread->acquired_mutex_list;
 	acpi_operand_object     *this;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -293,14 +291,15 @@
 
 		 /* Release the mutex */
 
-		acpi_ex_system_release_mutex (this);
+		status = acpi_ex_system_release_mutex (this);
+		if (ACPI_FAILURE (status)) {
+			continue;
+		}
 
 		/* Mark mutex unowned */
 
 		this->mutex.owner_thread     = NULL;
 	}
-
-	return (AE_OK);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exnames.c linux/drivers/acpi/executer/exnames.c
--- ../prev/linux/drivers/acpi/executer/exnames.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exnames.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exnames - interpreter/scanner name load/execute
- *              $Revision: 90 $
+ *              $Revision: 91 $
  *
  *****************************************************************************/
 
@@ -28,7 +28,6 @@
 #include "acpi.h"
 #include "acinterp.h"
 #include "amlcode.h"
-#include "acnamesp.h"
 
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exnames")
@@ -148,10 +147,10 @@
 	u8                      **in_aml_address,
 	NATIVE_CHAR             *name_string)
 {
-	u8                      *aml_address = *in_aml_address;
+	char                    *aml_address = (void *) *in_aml_address;
 	acpi_status             status = AE_OK;
 	u32                     index;
-	NATIVE_CHAR             char_buf[5];
+	char                    char_buf[5];
 
 
 	ACPI_FUNCTION_TRACE ("Ex_name_segment");
@@ -170,17 +169,17 @@
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Bytes from stream:\n"));
 
-	for (index = 4;
-		(index > 0) && (acpi_ut_valid_acpi_character (*aml_address));
-		index--) {
-		char_buf[4 - index] = *aml_address++;
-		ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "%c\n", char_buf[4 - index]));
+	for (index = 0;
+		(index < ACPI_NAME_SIZE) && (acpi_ut_valid_acpi_character (*aml_address));
+		index++) {
+		char_buf[index] = *aml_address++;
+		ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "%c\n", char_buf[index]));
 	}
 
 
 	/* Valid name segment  */
 
-	if (0 == index) {
+	if (index == 4) {
 		/* Found 4 valid characters */
 
 		char_buf[4] = '\0';
@@ -195,7 +194,7 @@
 				"No Name string - %s \n", char_buf));
 		}
 	}
-	else if (4 == index) {
+	else if (index == 0) {
 		/*
 		 * First character was not a valid name character,
 		 * so we are looking at something other than a name.
@@ -213,7 +212,7 @@
 			*aml_address, aml_address));
 	}
 
-	*in_aml_address = aml_address;
+	*in_aml_address = (u8 *) aml_address;
 	return_ACPI_STATUS (status);
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exoparg1.c linux/drivers/acpi/executer/exoparg1.c
--- ../prev/linux/drivers/acpi/executer/exoparg1.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exoparg1.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exoparg1 - AML execution - opcodes with 1 argument
- *              $Revision: 135 $
+ *              $Revision: 137 $
  *
  *****************************************************************************/
 
@@ -212,7 +212,7 @@
 	ACPI_FUNCTION_TRACE_STR ("Ex_opcode_1A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
 
 
-	/* Create a return object of type Integer for most opcodes */
+	/* Examine the AML opcode */
 
 	switch (walk_state->opcode) {
 	case AML_BIT_NOT_OP:
@@ -222,156 +222,159 @@
 	case AML_TO_BCD_OP:
 	case AML_COND_REF_OF_OP:
 
+		/* Create a return object of type Integer for these opcodes */
+
 		return_desc = acpi_ut_create_internal_object (ACPI_TYPE_INTEGER);
 		if (!return_desc) {
 			status = AE_NO_MEMORY;
 			goto cleanup;
 		}
 
-		break;
-	}
+		switch (walk_state->opcode) {
+		case AML_BIT_NOT_OP:            /* Not (Operand, Result)  */
 
-	/* Examine the AML opcode */
+			return_desc->integer.value = ~operand[0]->integer.value;
+			break;
 
-	switch (walk_state->opcode) {
 
-	case AML_BIT_NOT_OP:            /* Not (Operand, Result)  */
+		case AML_FIND_SET_LEFT_BIT_OP:  /* Find_set_left_bit (Operand, Result) */
 
-		return_desc->integer.value = ~operand[0]->integer.value;
-		break;
+			return_desc->integer.value = operand[0]->integer.value;
 
+			/*
+			 * Acpi specification describes Integer type as a little
+			 * endian unsigned value, so this boundary condition is valid.
+			 */
+			for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
+				return_desc->integer.value >>= 1;
+			}
 
-	case AML_FIND_SET_LEFT_BIT_OP:  /* Find_set_left_bit (Operand, Result) */
+			return_desc->integer.value = temp32;
+			break;
 
-		return_desc->integer.value = operand[0]->integer.value;
 
-		/*
-		 * Acpi specification describes Integer type as a little
-		 * endian unsigned value, so this boundary condition is valid.
-		 */
-		for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
-			return_desc->integer.value >>= 1;
-		}
+		case AML_FIND_SET_RIGHT_BIT_OP: /* Find_set_right_bit (Operand, Result) */
 
-		return_desc->integer.value = temp32;
-		break;
+			return_desc->integer.value = operand[0]->integer.value;
 
+			/*
+			 * The Acpi specification describes Integer type as a little
+			 * endian unsigned value, so this boundary condition is valid.
+			 */
+			for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
+				return_desc->integer.value <<= 1;
+			}
 
-	case AML_FIND_SET_RIGHT_BIT_OP: /* Find_set_right_bit (Operand, Result) */
+			/* Since the bit position is one-based, subtract from 33 (65) */
 
-		return_desc->integer.value = operand[0]->integer.value;
+			return_desc->integer.value = temp32 == 0 ? 0 : (ACPI_INTEGER_BIT_SIZE + 1) - temp32;
+			break;
 
-		/*
-		 * The Acpi specification describes Integer type as a little
-		 * endian unsigned value, so this boundary condition is valid.
-		 */
-		for (temp32 = 0; return_desc->integer.value && temp32 < ACPI_INTEGER_BIT_SIZE; ++temp32) {
-			return_desc->integer.value <<= 1;
-		}
 
-		/* Since the bit position is one-based, subtract from 33 (65) */
+		case AML_FROM_BCD_OP:           /* From_bcd (BCDValue, Result) */
 
-		return_desc->integer.value = temp32 == 0 ? 0 : (ACPI_INTEGER_BIT_SIZE + 1) - temp32;
-		break;
+			/*
+			 * The 64-bit ACPI integer can hold 16 4-bit BCD integers
+			 */
+			return_desc->integer.value = 0;
+			for (i = 0; i < ACPI_MAX_BCD_DIGITS; i++) {
+				/* Get one BCD digit */
 
+				digit = (acpi_integer) ((operand[0]->integer.value >> (i * 4)) & 0xF);
 
-	case AML_FROM_BCD_OP:           /* From_bcd (BCDValue, Result) */
+				/* Check the range of the digit */
 
-		/*
-		 * The 64-bit ACPI integer can hold 16 4-bit BCD integers
-		 */
-		return_desc->integer.value = 0;
-		for (i = 0; i < ACPI_MAX_BCD_DIGITS; i++) {
-			/* Get one BCD digit */
+				if (digit > 9) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "BCD digit too large: %d\n",
+						(u32) digit));
+					status = AE_AML_NUMERIC_OVERFLOW;
+					goto cleanup;
+				}
+
+				if (digit > 0) {
+					/* Sum into the result with the appropriate power of 10 */
+
+					for (j = 0; j < i; j++) {
+						digit *= 10;
+					}
+
+					return_desc->integer.value += digit;
+				}
+			}
+			break;
 
-			digit = (acpi_integer) ((operand[0]->integer.value >> (i * 4)) & 0xF);
 
-			/* Check the range of the digit */
+		case AML_TO_BCD_OP:             /* To_bcd (Operand, Result) */
 
-			if (digit > 9) {
-				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "BCD digit too large: %d\n",
-					(u32) digit));
+			if (operand[0]->integer.value > ACPI_MAX_BCD_VALUE) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "BCD overflow: %8.8X%8.8X\n",
+					ACPI_HIDWORD(operand[0]->integer.value),
+					ACPI_LODWORD(operand[0]->integer.value)));
 				status = AE_AML_NUMERIC_OVERFLOW;
 				goto cleanup;
 			}
 
-			if (digit > 0) {
-				/* Sum into the result with the appropriate power of 10 */
+			return_desc->integer.value = 0;
+			for (i = 0; i < ACPI_MAX_BCD_DIGITS; i++) {
+				/* Divide by nth factor of 10 */
 
+				temp32 = 0;
+				digit = operand[0]->integer.value;
 				for (j = 0; j < i; j++) {
-					digit *= 10;
+					(void) acpi_ut_short_divide (&digit, 10, &digit, &temp32);
 				}
 
-				return_desc->integer.value += digit;
+				/* Create the BCD digit from the remainder above */
+
+				if (digit > 0) {
+					return_desc->integer.value += ((acpi_integer) temp32 << (i * 4));
+				}
 			}
-		}
-		break;
+			break;
 
 
-	case AML_TO_BCD_OP:             /* To_bcd (Operand, Result) */
+		case AML_COND_REF_OF_OP:        /* Cond_ref_of (Source_object, Result) */
 
-		if (operand[0]->integer.value > ACPI_MAX_BCD_VALUE) {
-			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "BCD overflow: %8.8X%8.8X\n",
-				ACPI_HIDWORD(operand[0]->integer.value),
-				ACPI_LODWORD(operand[0]->integer.value)));
-			status = AE_AML_NUMERIC_OVERFLOW;
-			goto cleanup;
-		}
+			/*
+			 * This op is a little strange because the internal return value is
+			 * different than the return value stored in the result descriptor
+			 * (There are really two return values)
+			 */
+			if ((acpi_namespace_node *) operand[0] == acpi_gbl_root_node) {
+				/*
+				 * This means that the object does not exist in the namespace,
+				 * return FALSE
+				 */
+				return_desc->integer.value = 0;
 
-		return_desc->integer.value = 0;
-		for (i = 0; i < ACPI_MAX_BCD_DIGITS; i++) {
-			/* Divide by nth factor of 10 */
-
-			temp32 = 0;
-			digit = operand[0]->integer.value;
-			for (j = 0; j < i; j++) {
-				acpi_ut_short_divide (&digit, 10, &digit, &temp32);
+				/*
+				 * Must delete the result descriptor since there is no reference
+				 * being returned
+				 */
+				acpi_ut_remove_reference (operand[1]);
+				goto cleanup;
 			}
 
-			/* Create the BCD digit from the remainder above */
+			/* Get the object reference and store it */
 
-			if (digit > 0) {
-				return_desc->integer.value += ((acpi_integer) temp32 << (i * 4));
+			status = acpi_ex_get_object_reference (operand[0], &return_desc2, walk_state);
+			if (ACPI_FAILURE (status)) {
+				goto cleanup;
 			}
-		}
-		break;
 
+			status = acpi_ex_store (return_desc2, operand[1], walk_state);
 
-	case AML_COND_REF_OF_OP:        /* Cond_ref_of (Source_object, Result) */
+			/* The object exists in the namespace, return TRUE */
 
-		/*
-		 * This op is a little strange because the internal return value is
-		 * different than the return value stored in the result descriptor
-		 * (There are really two return values)
-		 */
-		if ((acpi_namespace_node *) operand[0] == acpi_gbl_root_node) {
-			/*
-			 * This means that the object does not exist in the namespace,
-			 * return FALSE
-			 */
-			return_desc->integer.value = 0;
-
-			/*
-			 * Must delete the result descriptor since there is no reference
-			 * being returned
-			 */
-			acpi_ut_remove_reference (operand[1]);
+			return_desc->integer.value = ACPI_INTEGER_MAX;
 			goto cleanup;
-		}
 
-		/* Get the object reference and store it */
 
-		status = acpi_ex_get_object_reference (operand[0], &return_desc2, walk_state);
-		if (ACPI_FAILURE (status)) {
-			goto cleanup;
+		default:
+			/* No other opcodes get here */
+			break;
 		}
-
-		status = acpi_ex_store (return_desc2, operand[1], walk_state);
-
-		/* The object exists in the namespace, return TRUE */
-
-		return_desc->integer.value = ACPI_INTEGER_MAX;
-		goto cleanup;
+		break;
 
 
 	case AML_STORE_OP:              /* Store (Source, Target) */
@@ -520,7 +523,7 @@
 		 * can be either a NS Node or an internal object.
 		 */
 		return_desc = operand[0];
-		if (ACPI_GET_DESCRIPTOR_TYPE (operand[0]) == ACPI_DESC_TYPE_INTERNAL) {
+		if (ACPI_GET_DESCRIPTOR_TYPE (operand[0]) == ACPI_DESC_TYPE_OPERAND) {
 			/* Internal reference object - prevent deletion */
 
 			acpi_ut_add_reference (return_desc);
@@ -628,6 +631,11 @@
 			case INTERNAL_TYPE_INDEX_FIELD:
 
 				type = ACPI_TYPE_FIELD_UNIT;
+				break;
+
+			default:
+				/* No change to Type required */
+				break;
 			}
 
 		}
@@ -722,8 +730,11 @@
 
 					/* Set Operand[0] to the value of the local/arg */
 
-					acpi_ds_method_data_get_value (operand[0]->reference.opcode,
-							operand[0]->reference.offset, walk_state, &temp_desc);
+					status = acpi_ds_method_data_get_value (operand[0]->reference.opcode,
+							 operand[0]->reference.offset, walk_state, &temp_desc);
+					if (ACPI_FAILURE (status)) {
+						goto cleanup;
+					}
 
 					/*
 					 * Delete our reference to the input object and
@@ -750,13 +761,15 @@
 				 * 2) Dereference the node to an actual object.  Could be a Field, so we nee
 				 *    to resolve the node to a value.
 				 */
-				status = acpi_ns_get_node_by_path (operand[0]->string.pointer, walk_state->scope_info->scope.node,
-						  ACPI_NS_SEARCH_PARENT, (acpi_namespace_node **) &return_desc);
+				status = acpi_ns_get_node_by_path (operand[0]->string.pointer,
+						  walk_state->scope_info->scope.node, ACPI_NS_SEARCH_PARENT,
+						  ACPI_CAST_INDIRECT_PTR (acpi_namespace_node, &return_desc));
 				if (ACPI_FAILURE (status)) {
 					goto cleanup;
 				}
 
-				status = acpi_ex_resolve_node_to_value ((acpi_namespace_node **) &return_desc, walk_state);
+				status = acpi_ex_resolve_node_to_value (
+						  ACPI_CAST_INDIRECT_PTR (acpi_namespace_node, &return_desc), walk_state);
 				goto cleanup;
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exoparg2.c linux/drivers/acpi/executer/exoparg2.c
--- ../prev/linux/drivers/acpi/executer/exoparg2.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exoparg2.c	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: exoparg2 - AML execution - opcodes with 2 arguments
- *              $Revision: 105 $
+ *              $Revision: 106 $
  *
  *****************************************************************************/
 
@@ -26,11 +26,9 @@
 
 #include "acpi.h"
 #include "acparser.h"
-#include "acnamesp.h"
 #include "acinterp.h"
 #include "acevents.h"
 #include "amlcode.h"
-#include "acdispat.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exoparg3.c linux/drivers/acpi/executer/exoparg3.c
--- ../prev/linux/drivers/acpi/executer/exoparg3.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exoparg3.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exoparg3 - AML execution - opcodes with 3 arguments
- *              $Revision: 9 $
+ *              $Revision: 13 $
  *
  *****************************************************************************/
 
@@ -87,7 +87,7 @@
 	case AML_FATAL_OP:          /* Fatal (Fatal_type Fatal_code Fatal_arg)   */
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-			"Fatal_op: Type %x Code %x Arg %x <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
+			"Fatal_op: Type %X Code %X Arg %X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
 			(u32) operand[0]->integer.value, (u32) operand[1]->integer.value,
 			(u32) operand[2]->integer.value));
 
@@ -102,7 +102,7 @@
 		/*
 		 * Always signal the OS!
 		 */
-		acpi_os_signal (ACPI_SIGNAL_FATAL, fatal);
+		status = acpi_os_signal (ACPI_SIGNAL_FATAL, fatal);
 
 		/* Might return while OS is shutting down, just continue */
 
@@ -145,8 +145,8 @@
 	acpi_operand_object     *return_desc = NULL;
 	char                    *buffer;
 	acpi_status             status = AE_OK;
-	u32                     index;
-	u32                     length;
+	NATIVE_UINT             index;
+	ACPI_SIZE               length;
 
 
 	ACPI_FUNCTION_TRACE_STR ("Ex_opcode_3A_1T_1R", acpi_ps_get_opcode_name (walk_state->opcode));
@@ -167,8 +167,8 @@
 
 		/* Get the Integer values from the objects */
 
-		index = (u32) operand[1]->integer.value;
-		length = (u32) operand[2]->integer.value;
+		index = (NATIVE_UINT) operand[1]->integer.value;
+		length = (ACPI_SIZE) operand[2]->integer.value;
 
 		/*
 		 * If the index is beyond the length of the String/Buffer, or if the
@@ -180,12 +180,12 @@
 
 			if ((index + length) >
 				operand[0]->string.length) {
-				length = operand[0]->string.length - index;
+				length = (ACPI_SIZE) operand[0]->string.length - index;
 			}
 
 			/* Allocate a new buffer for the String/Buffer */
 
-			buffer = ACPI_MEM_CALLOCATE (length + 1);
+			buffer = ACPI_MEM_CALLOCATE ((ACPI_SIZE) length + 1);
 			if (!buffer) {
 				status = AE_NO_MEMORY;
 				goto cleanup;
@@ -199,7 +199,7 @@
 			/* Set the length of the new String/Buffer */
 
 			return_desc->string.pointer = buffer;
-			return_desc->string.length = length;
+			return_desc->string.length = (u32) length;
 		}
 		break;
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exprep.c linux/drivers/acpi/executer/exprep.c
--- ../prev/linux/drivers/acpi/executer/exprep.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exprep.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exprep - ACPI AML (p-code) execution - field prep utilities
- *              $Revision: 115 $
+ *              $Revision: 117 $
  *
  *****************************************************************************/
 
@@ -29,7 +29,6 @@
 #include "acinterp.h"
 #include "amlcode.h"
 #include "acnamesp.h"
-#include "acparser.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -57,16 +56,15 @@
 	u32                     *return_byte_alignment)
 {
 	u32                     access;
-	u32                     length;
 	u8                      byte_alignment;
 	u8                      bit_length;
+/*    u32                     Length; */
 
 
 	ACPI_FUNCTION_NAME ("Ex_decode_field_access");
 
 
 	access = (field_flags & AML_FIELD_ACCESS_TYPE_MASK);
-	length = obj_desc->common_field.bit_length;
 
 	switch (access) {
 	case AML_FIELD_ACCESS_ANY:
@@ -86,6 +84,8 @@
 
 		/* Use the length to set the access type */
 
+		length = obj_desc->common_field.bit_length;
+
 		if (length <= 8) {
 			bit_length = 8;
 		}
@@ -135,7 +135,7 @@
 		/* Invalid field access type */
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
-			"Unknown field access type %x\n",
+			"Unknown field access type %X\n",
 			access));
 		return (0);
 	}
@@ -410,6 +410,10 @@
 			obj_desc->index_field.index_obj,
 			obj_desc->index_field.data_obj));
 		break;
+
+	default:
+		/* No other types should get here */
+		break;
 	}
 
 	/*
@@ -420,7 +424,7 @@
 			  acpi_ns_get_type (info->field_node));
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "set Named_obj %p (%4.4s) val = %p\n",
-			info->field_node, (char *) &(info->field_node->name), obj_desc));
+			info->field_node, info->field_node->name.ascii, obj_desc));
 
 	/* Remove local reference to the object */
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exregion.c linux/drivers/acpi/executer/exregion.c
--- ../prev/linux/drivers/acpi/executer/exregion.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exregion.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exregion - ACPI default Op_region (address space) handlers
- *              $Revision: 74 $
+ *              $Revision: 79 $
  *
  *****************************************************************************/
 
@@ -27,10 +27,6 @@
 
 #include "acpi.h"
 #include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "achware.h"
-#include "acevents.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -68,8 +64,10 @@
 	void                    *logical_addr_ptr = NULL;
 	acpi_mem_space_context  *mem_info = region_context;
 	u32                     length;
-	u32                     window_size;
-
+	ACPI_SIZE               window_size;
+#ifndef _HW_ALIGNMENT_SUPPORT
+	u32                     remainder;
+#endif
 
 	ACPI_FUNCTION_TRACE ("Ex_system_memory_space_handler");
 
@@ -99,6 +97,18 @@
 		return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
 	}
 
+
+#ifndef _HW_ALIGNMENT_SUPPORT
+	/*
+	 * Hardware does not support non-aligned data transfers, we must verify
+	 * the request.
+	 */
+	(void) acpi_ut_short_divide ((acpi_integer *) &address, length, NULL, &remainder);
+	if (remainder != 0) {
+		return_ACPI_STATUS (AE_AML_ALIGNMENT);
+	}
+#endif
+
 	/*
 	 * Does the request fit into the cached memory mapping?
 	 * Is 1) Address below the current mapping? OR
@@ -122,7 +132,7 @@
 		 * Don't attempt to map memory beyond the end of the region, and
 		 * constrain the maximum mapping size to something reasonable.
 		 */
-		window_size = (u32) ((mem_info->address + mem_info->length) - address);
+		window_size = (ACPI_SIZE) ((mem_info->address + mem_info->length) - address);
 		if (window_size > SYSMEM_REGION_WINDOW_SIZE) {
 			window_size = SYSMEM_REGION_WINDOW_SIZE;
 		}
@@ -132,6 +142,8 @@
 		status = acpi_os_map_memory (address, window_size,
 				  (void **) &mem_info->mapped_logical_address);
 		if (ACPI_FAILURE (status)) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not map memory at %8.8X%8.8X, size %X\n",
+				ACPI_HIDWORD (address), ACPI_LODWORD (address), (u32) window_size));
 			mem_info->mapped_length = 0;
 			return_ACPI_STATUS (status);
 		}
@@ -153,27 +165,38 @@
 		"System_memory %d (%d width) Address=%8.8X%8.8X\n", function, bit_width,
 		ACPI_HIDWORD (address), ACPI_LODWORD (address)));
 
-   /* Perform the memory read or write */
-
+   /*
+	* Perform the memory read or write
+	*
+	* Note: For machines that do not support non-aligned transfers, the target
+	* address was checked for alignment above.  We do not attempt to break the
+	* transfer up into smaller (byte-size) chunks because the AML specifically
+	* asked for a transfer width that the hardware may require.
+	*/
 	switch (function) {
 	case ACPI_READ:
 
 		*value = 0;
 		switch (bit_width) {
 		case 8:
-			*value = (u32)* (u8 *) logical_addr_ptr;
+			*value = (acpi_integer) *((u8 *) logical_addr_ptr);
 			break;
 
 		case 16:
-			ACPI_MOVE_UNALIGNED16_TO_16 (value, logical_addr_ptr);
+			*value = (acpi_integer) *((u16 *) logical_addr_ptr);
 			break;
 
 		case 32:
-			ACPI_MOVE_UNALIGNED32_TO_32 (value, logical_addr_ptr);
+			*value = (acpi_integer) *((u32 *) logical_addr_ptr);
 			break;
 
+#if ACPI_MACHINE_WIDTH != 16
 		case 64:
-			ACPI_MOVE_UNALIGNED64_TO_64 (value, logical_addr_ptr);
+			*value = (acpi_integer) *((u64 *) logical_addr_ptr);
+			break;
+#endif
+		default:
+			/* Bit_width was already validated */
 			break;
 		}
 		break;
@@ -186,15 +209,21 @@
 			break;
 
 		case 16:
-			ACPI_MOVE_UNALIGNED16_TO_16 (logical_addr_ptr, value);
+			*(u16 *) logical_addr_ptr = (u16) *value;
 			break;
 
 		case 32:
-			ACPI_MOVE_UNALIGNED32_TO_32 (logical_addr_ptr, value);
+			*(u32 *) logical_addr_ptr = (u32) *value;
 			break;
 
+#if ACPI_MACHINE_WIDTH != 16
 		case 64:
-			ACPI_MOVE_UNALIGNED64_TO_64 (logical_addr_ptr, value);
+			*(u64 *) logical_addr_ptr = (u64) *value;
+			break;
+#endif
+
+		default:
+			/* Bit_width was already validated */
 			break;
 		}
 		break;
@@ -316,7 +345,7 @@
 	 *
 	 */
 	pci_id      = (acpi_pci_id *) region_context;
-	pci_register = (u16) (ACPI_SIZE) address;
+	pci_register = (u16) (u32) address;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 		"Pci_config %d (%d) Seg(%04x) Bus(%04x) Dev(%04x) Func(%04x) Reg(%04x)\n",
@@ -469,6 +498,7 @@
 		break;
 
 	case ACPI_WRITE:
+	default:
 
 		return_ACPI_STATUS (AE_SUPPORT);
 	}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exresnte.c linux/drivers/acpi/executer/exresnte.c
--- ../prev/linux/drivers/acpi/executer/exresnte.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exresnte.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exresnte - AML Interpreter object resolution
- *              $Revision: 52 $
+ *              $Revision: 53 $
  *
  *****************************************************************************/
 
@@ -27,12 +27,9 @@
 
 #include "acpi.h"
 #include "amlcode.h"
-#include "acparser.h"
 #include "acdispat.h"
 #include "acinterp.h"
 #include "acnamesp.h"
-#include "actables.h"
-#include "acevents.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exresolv.c linux/drivers/acpi/executer/exresolv.c
--- ../prev/linux/drivers/acpi/executer/exresolv.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exresolv.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exresolv - AML Interpreter object resolution
- *              $Revision: 109 $
+ *              $Revision: 111 $
  *
  *****************************************************************************/
 
@@ -27,12 +27,8 @@
 
 #include "acpi.h"
 #include "amlcode.h"
-#include "acparser.h"
 #include "acdispat.h"
 #include "acinterp.h"
-#include "acnamesp.h"
-#include "actables.h"
-#include "acevents.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -75,7 +71,7 @@
 	 * 1) A valid acpi_operand_object, or
 	 * 2) A acpi_namespace_node (Named_obj)
 	 */
-	if (ACPI_GET_DESCRIPTOR_TYPE (*stack_ptr) == ACPI_DESC_TYPE_INTERNAL) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (*stack_ptr) == ACPI_DESC_TYPE_OPERAND) {
 		status = acpi_ex_resolve_object_to_value (stack_ptr, walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
@@ -87,7 +83,8 @@
 	 * was called (i.e., we can't use an _else_ here.)
 	 */
 	if (ACPI_GET_DESCRIPTOR_TYPE (*stack_ptr) == ACPI_DESC_TYPE_NAMED) {
-		status = acpi_ex_resolve_node_to_value ((acpi_namespace_node **) stack_ptr,
+		status = acpi_ex_resolve_node_to_value (
+				  ACPI_CAST_INDIRECT_PTR (acpi_namespace_node, stack_ptr),
 				  walk_state);
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
@@ -216,6 +213,10 @@
 
 			case AML_REVISION_OP:
 				obj_desc->integer.value = ACPI_CA_SUPPORT_LEVEL;
+				break;
+
+			default:
+				/* No other opcodes can get here */
 				break;
 			}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exresop.c linux/drivers/acpi/executer/exresop.c
--- ../prev/linux/drivers/acpi/executer/exresop.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exresop.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exresop - AML Interpreter operand/object resolution
- *              $Revision: 47 $
+ *              $Revision: 50 $
  *
  *****************************************************************************/
 
@@ -28,11 +28,8 @@
 #include "acpi.h"
 #include "amlcode.h"
 #include "acparser.h"
-#include "acdispat.h"
 #include "acinterp.h"
 #include "acnamesp.h"
-#include "actables.h"
-#include "acevents.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -69,7 +66,7 @@
 	}
 
 	if (type_needed != this_type) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Needed [%s], found [%s] %p\n",
 			acpi_ut_get_type_name (type_needed),
 			acpi_ut_get_type_name (this_type), object));
@@ -135,8 +132,8 @@
 		return_ACPI_STATUS (AE_AML_INTERNAL);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Opcode %X Operand_types=%X \n",
-		opcode, arg_types));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Opcode %X [%s] Operand_types=%X \n",
+		opcode, op_info->name, arg_types));
 
 	/*
 	 * Normal exit is with (Arg_types == 0) at end of argument list.
@@ -168,7 +165,7 @@
 			break;
 
 
-		case ACPI_DESC_TYPE_INTERNAL:
+		case ACPI_DESC_TYPE_OPERAND:
 
 			/* ACPI internal object */
 
@@ -203,7 +200,7 @@
 				case AML_LOCAL_OP:
 				case AML_REVISION_OP:
 
-					ACPI_DEBUG_ONLY_MEMBERS (ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+					ACPI_DEBUG_ONLY_MEMBERS (ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 						"Reference Opcode: %s\n", op_info->name)));
 					break;
 
@@ -243,7 +240,7 @@
 		switch (this_arg_type) {
 		case ARGI_REF_OR_STRING:        /* Can be a String or Reference */
 
-			if ((ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_INTERNAL) &&
+			if ((ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_OPERAND) &&
 				(ACPI_GET_OBJECT_TYPE (obj_desc) == ACPI_TYPE_STRING)) {
 				/*
 				 * String found - the string references a named object and must be
@@ -253,6 +250,7 @@
 			}
 
 			/* Else not a string - fall through to the normal Reference case below */
+			/*lint -fallthrough */
 
 		case ARGI_REFERENCE:            /* References: */
 		case ARGI_INTEGER_REF:
@@ -299,6 +297,10 @@
 				((*stack_ptr)->reference.opcode == AML_INDEX_OP)) {
 				goto next_operand;
 			}
+			break;
+
+		default:
+			/* All cases covered above */
 			break;
 		}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exstore.c linux/drivers/acpi/executer/exstore.c
--- ../prev/linux/drivers/acpi/executer/exstore.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exstore.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exstore - AML Interpreter object store support
- *              $Revision: 163 $
+ *              $Revision: 164 $
  *
  *****************************************************************************/
 
@@ -26,12 +26,10 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
 #include "acdispat.h"
 #include "acinterp.h"
 #include "amlcode.h"
 #include "acnamesp.h"
-#include "actables.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -328,7 +326,7 @@
 
 		case ACPI_TYPE_STRING:
 
-			value = source_desc->string.pointer[0];
+			value = (u8) source_desc->string.pointer[0];
 			break;
 
 		default:
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exstoren.c linux/drivers/acpi/executer/exstoren.c
--- ../prev/linux/drivers/acpi/executer/exstoren.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exstoren.c	Fri May 31 11:41:57 2002
@@ -3,7 +3,7 @@
  *
  * Module Name: exstoren - AML Interpreter object store support,
  *                        Store to Node (namespace object)
- *              $Revision: 47 $
+ *              $Revision: 48 $
  *
  *****************************************************************************/
 
@@ -27,12 +27,7 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
 #include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "actables.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exstorob.c linux/drivers/acpi/executer/exstorob.c
--- ../prev/linux/drivers/acpi/executer/exstorob.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exstorob.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exstorob - AML Interpreter object store support, store to object
- *              $Revision: 42 $
+ *              $Revision: 44 $
  *
  *****************************************************************************/
 
@@ -26,12 +26,7 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
-#include "acdispat.h"
 #include "acinterp.h"
-#include "amlcode.h"
-#include "acnamesp.h"
-#include "actables.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -166,7 +161,7 @@
 			ACPI_MEM_FREE (target_desc->string.pointer);
 		}
 
-		target_desc->string.pointer = ACPI_MEM_ALLOCATE (length + 1);
+		target_desc->string.pointer = ACPI_MEM_ALLOCATE ((ACPI_SIZE) length + 1);
 		if (!target_desc->string.pointer) {
 			return (AE_NO_MEMORY);
 		}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exsystem.c linux/drivers/acpi/executer/exsystem.c
--- ../prev/linux/drivers/acpi/executer/exsystem.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exsystem.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exsystem - Interface to OS services
- *              $Revision: 71 $
+ *              $Revision: 73 $
  *
  *****************************************************************************/
 
@@ -27,8 +27,6 @@
 
 #include "acpi.h"
 #include "acinterp.h"
-#include "acnamesp.h"
-#include "achware.h"
 #include "acevents.h"
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -246,8 +244,8 @@
 	 * Support for the _GL_ Mutex object -- release the global lock
 	 */
 	if (obj_desc->mutex.semaphore == acpi_gbl_global_lock_semaphore) {
-		acpi_ev_release_global_lock ();
-		return_ACPI_STATUS (AE_OK);
+		status = acpi_ev_release_global_lock ();
+		return_ACPI_STATUS (status);
 	}
 
 	status = acpi_os_signal_semaphore (obj_desc->mutex.semaphore, 1);
@@ -350,7 +348,7 @@
 	 */
 	status = acpi_os_create_semaphore (ACPI_NO_UNIT_LIMIT, 0, &temp_semaphore);
 	if (ACPI_SUCCESS (status)) {
-		acpi_os_delete_semaphore (obj_desc->event.semaphore);
+		(void) acpi_os_delete_semaphore (obj_desc->event.semaphore);
 		obj_desc->event.semaphore = temp_semaphore;
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/executer/exutils.c linux/drivers/acpi/executer/exutils.c
--- ../prev/linux/drivers/acpi/executer/exutils.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/executer/exutils.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: exutils - interpreter/scanner utilities
- *              $Revision: 93 $
+ *              $Revision: 98 $
  *
  *****************************************************************************/
 
@@ -42,12 +42,9 @@
 #define DEFINE_AML_GLOBALS
 
 #include "acpi.h"
-#include "acparser.h"
 #include "acinterp.h"
 #include "amlcode.h"
-#include "acnamesp.h"
 #include "acevents.h"
-#include "acparser.h"
 
 #define _COMPONENT          ACPI_EXECUTER
 	 ACPI_MODULE_NAME    ("exutils")
@@ -74,7 +71,7 @@
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_EXECUTE);
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Fatal - Could not acquire interpreter lock\n"));
+		ACPI_REPORT_ERROR (("Could not acquire interpreter mutex\n"));
 	}
 
 	return_ACPI_STATUS (status);
@@ -111,6 +108,9 @@
 
 
 	status = acpi_ut_release_mutex (ACPI_MTX_EXECUTE);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not release interpreter mutex\n"));
+	}
 
 	return_VOID;
 }
@@ -177,7 +177,7 @@
 		return;
 	}
 
-	if (walk_state->method_node->flags & ANOBJ_DATA_WIDTH_32) {
+	if (acpi_gbl_integer_byte_width == 4) {
 		/*
 		 * We are running a method that exists in a 32-bit ACPI table.
 		 * Truncate the value to 32 bits by zeroing out the upper 32-bit field
@@ -245,10 +245,12 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_release_global_lock (
 	u8                      locked_by_me)
 {
+	acpi_status             status;
+
 
 	ACPI_FUNCTION_TRACE ("Ex_release_global_lock");
 
@@ -258,10 +260,13 @@
 	if (locked_by_me) {
 		/* OK, now release the lock */
 
-		acpi_ev_release_global_lock ();
-	}
+		status = acpi_ev_release_global_lock ();
+		if (ACPI_FAILURE (status)) {
+			/* Report the error, but there isn't much else we can do */
 
-	return_ACPI_STATUS (AE_OK);
+			ACPI_REPORT_ERROR (("Could not release ACPI Global Lock\n"));
+		}
+	}
 }
 
 
@@ -281,22 +286,24 @@
 	acpi_integer            value,
 	u32                     base)
 {
-	u32                     num_digits = 0;
+	u32                     num_digits;
+	acpi_integer            current_value;
+	acpi_integer            quotient;
 
 
 	ACPI_FUNCTION_TRACE ("Ex_digits_needed");
 
 
-	if (base < 1) {
-		ACPI_REPORT_ERROR (("Ex_digits_needed: Internal error - Invalid base\n"));
-	}
-	else {
-		/*
-		 * acpi_integer is unsigned, which is why we don't worry about a '-'
-		 */
-		for (num_digits = 1;
-			(acpi_ut_short_divide (&value, base, &value, NULL));
-			++num_digits) { ; }
+	/*
+	 * acpi_integer is unsigned, so we don't worry about a '-'
+	 */
+	current_value = value;
+	num_digits = 0;
+
+	while (current_value) {
+		(void) acpi_ut_short_divide (&current_value, base, &quotient, NULL);
+		num_digits++;
+		current_value = quotient;
 	}
 
 	return_VALUE (num_digits);
@@ -305,45 +312,6 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    ntohl
- *
- * PARAMETERS:  Value           - Value to be converted
- *
- * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
- *
- ******************************************************************************/
-
-static u32
-_ntohl (
-	u32                     value)
-{
-	union {
-		u32                 value;
-		u8                  bytes[4];
-	} out;
-
-	union {
-		u32                 value;
-		u8                  bytes[4];
-	} in;
-
-
-	ACPI_FUNCTION_ENTRY ();
-
-
-	in.value = value;
-
-	out.bytes[0] = in.bytes[3];
-	out.bytes[1] = in.bytes[2];
-	out.bytes[2] = in.bytes[1];
-	out.bytes[3] = in.bytes[0];
-
-	return (out.value);
-}
-
-
-/*******************************************************************************
- *
  * FUNCTION:    Acpi_ex_eisa_id_to_string
  *
  * PARAMETERS:  Numeric_id      - EISA ID to be converted
@@ -353,31 +321,29 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_eisa_id_to_string (
 	u32                     numeric_id,
 	NATIVE_CHAR             *out_string)
 {
-	u32                     id;
+	u32                     eisa_id;
 
 
 	ACPI_FUNCTION_ENTRY ();
 
 
-	/* swap to big-endian to get contiguous bits */
+	/* Swap ID to big-endian to get contiguous bits */
 
-	id = _ntohl (numeric_id);
+	eisa_id = acpi_ut_dword_byte_swap (numeric_id);
 
-	out_string[0] = (char) ('@' + ((id >> 26) & 0x1f));
-	out_string[1] = (char) ('@' + ((id >> 21) & 0x1f));
-	out_string[2] = (char) ('@' + ((id >> 16) & 0x1f));
-	out_string[3] = acpi_ut_hex_to_ascii_char (id, 12);
-	out_string[4] = acpi_ut_hex_to_ascii_char (id, 8);
-	out_string[5] = acpi_ut_hex_to_ascii_char (id, 4);
-	out_string[6] = acpi_ut_hex_to_ascii_char (id, 0);
+	out_string[0] = (char) ('@' + ((eisa_id >> 26) & 0x1f));
+	out_string[1] = (char) ('@' + ((eisa_id >> 21) & 0x1f));
+	out_string[2] = (char) ('@' + ((eisa_id >> 16) & 0x1f));
+	out_string[3] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 12);
+	out_string[4] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 8);
+	out_string[5] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 4);
+	out_string[6] = acpi_ut_hex_to_ascii_char ((acpi_integer) eisa_id, 0);
 	out_string[7] = 0;
-
-	return (AE_OK);
 }
 
 
@@ -392,7 +358,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ex_unsigned_integer_to_string (
 	acpi_integer            value,
 	NATIVE_CHAR             *out_string)
@@ -400,6 +366,7 @@
 	u32                     count;
 	u32                     digits_needed;
 	u32                     remainder;
+	acpi_integer            quotient;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -409,11 +376,10 @@
 	out_string[digits_needed] = 0;
 
 	for (count = digits_needed; count > 0; count--) {
-		acpi_ut_short_divide (&value, 10, &value, &remainder);
-		out_string[count-1] = (NATIVE_CHAR) ('0' + remainder);
+		(void) acpi_ut_short_divide (&value, 10, &quotient, &remainder);
+		out_string[count-1] = (NATIVE_CHAR) ('0' + remainder);\
+		value = quotient;
 	}
-
-	return (AE_OK);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/fan.c linux/drivers/acpi/fan.c
--- ../prev/linux/drivers/acpi/fan.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/fan.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,300 @@
+/*
+ *  acpi_fan.c - ACPI Fan Driver ($Revision: 25 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_FAN_COMPONENT
+ACPI_MODULE_NAME		("acpi_fan")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_FAN_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX			"ACPI: "
+
+
+int acpi_fan_add (struct acpi_device *device);
+int acpi_fan_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_fan_driver = {
+	name:			ACPI_FAN_DRIVER_NAME,
+	class:			ACPI_FAN_CLASS,
+	ids:			ACPI_FAN_HID,
+	ops:			{
+					add:	acpi_fan_add,
+					remove:	acpi_fan_remove,
+				},
+};
+
+struct acpi_fan {
+	acpi_handle		handle;
+};
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry		*acpi_fan_dir = NULL;
+
+
+static int
+acpi_fan_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_fan		*fan = (struct acpi_fan *) data;
+	char			*p = page;
+	int			len = 0;
+	int			state = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_read_state");
+
+	if (!fan || (off != 0))
+		goto end;
+
+	if (0 != acpi_bus_get_power(fan->handle, &state))
+		goto end;
+
+	p += sprintf(p, "status:                  %s\n",
+		!state?"on":"off");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_fan_write_state (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_fan		*fan = (struct acpi_fan *) data;
+	char			state_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_fan_write_state");
+
+	if (!fan || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+	
+	result = acpi_bus_set_power(fan->handle, 
+		simple_strtoul(state_string, NULL, 0));
+	if (0 != result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_fan_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_add_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (!acpi_fan_dir) {
+		acpi_fan_dir = proc_mkdir(ACPI_FAN_CLASS, acpi_root_dir);
+		if (!acpi_fan_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_fan_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'status' [R/W] */
+	entry = create_proc_entry(ACPI_FAN_FILE_STATE,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_FAN_FILE_STATE));
+	else {
+		entry->read_proc = acpi_fan_read_state;
+		entry->write_proc = acpi_fan_write_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_fan_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_fan_remove_fs");
+
+	if (!acpi_fan_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_fan_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+int
+acpi_fan_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct acpi_fan		*fan = NULL;
+	int			state = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	fan = kmalloc(sizeof(struct acpi_fan), GFP_KERNEL);
+	if (!fan)
+		return_VALUE(-ENOMEM);
+	memset(fan, 0, sizeof(struct acpi_fan));
+
+	fan->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_FAN_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_FAN_CLASS);
+	acpi_driver_data(device) = fan;
+
+	result = acpi_bus_get_power(fan->handle, &state);
+	if (0 != result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error reading power state\n"));
+		goto end;
+	}
+
+	result = acpi_fan_add_fs(device);
+	if (0 != result)
+		goto end;
+
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		!device->power.state?"on":"off");
+
+end:
+	if (0 != result)
+		kfree(fan);
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_fan_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_fan		*fan = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	fan = (struct acpi_fan *) acpi_driver_data(device);
+
+	acpi_fan_remove_fs(device);
+
+	kfree(fan);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_fan_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_init");
+
+	result = acpi_bus_register_driver(&acpi_fan_driver);
+	if (0 > result)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_fan_exit (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_fan_exit");
+
+	result = acpi_bus_unregister_driver(&acpi_fan_driver);
+	if (0 == result)
+		remove_proc_entry(ACPI_FAN_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_fan_init);
+module_exit(acpi_fan_exit);
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/hardware/hwacpi.c linux/drivers/acpi/hardware/hwacpi.c
--- ../prev/linux/drivers/acpi/hardware/hwacpi.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/hardware/hwacpi.c	Wed Jun 12 09:54:38 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: hwacpi - ACPI Hardware Initialization/Mode Interface
- *              $Revision: 53 $
+ *              $Revision: 58 $
  *
  *****************************************************************************/
 
@@ -26,7 +26,6 @@
 
 
 #include "acpi.h"
-#include "achware.h"
 
 
 #define _COMPONENT          ACPI_HARDWARE
@@ -91,35 +90,69 @@
 	u32                     mode)
 {
 
-	acpi_status             status = AE_NO_HARDWARE_RESPONSE;
+	acpi_status             status;
+	u32                     retry;
 
 
 	ACPI_FUNCTION_TRACE ("Hw_set_mode");
 
 
-	if (mode == ACPI_SYS_MODE_ACPI) {
+	if (mode == acpi_hw_get_mode())
+		return_ACPI_STATUS (AE_OK);
+
+	/* If no SMI_CMD, system does not support SMI */
+	if (!acpi_gbl_FADT->smi_cmd)
+		return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+
+	switch (mode) {
+	case ACPI_SYS_MODE_ACPI:
+
 		/* BIOS should have disabled ALL fixed and GP events */
 
-		acpi_os_write_port (acpi_gbl_FADT->smi_cmd, acpi_gbl_FADT->acpi_enable, 8);
+		status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd,
+				  (acpi_integer) acpi_gbl_FADT->acpi_enable, 8);
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Attempting to enable ACPI mode\n"));
-	}
-	else if (mode == ACPI_SYS_MODE_LEGACY) {
+		break;
+
+	case ACPI_SYS_MODE_LEGACY:
+
+		/* If both enable/disable are zero, legacy mode is not supported */
+		if (!acpi_gbl_FADT->acpi_enable && !acpi_gbl_FADT->acpi_disable)
+			return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+			
 		/*
 		 * BIOS should clear all fixed status bits and restore fixed event
 		 * enable bits to default
 		 */
-		acpi_os_write_port (acpi_gbl_FADT->smi_cmd, acpi_gbl_FADT->acpi_disable, 8);
+		status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd,
+				 (acpi_integer) acpi_gbl_FADT->acpi_disable, 8);
 		ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 				 "Attempting to enable Legacy (non-ACPI) mode\n"));
-	}
+		break;
 
-	/* Give the platform some time to react */
+	default:
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
 
-	acpi_os_stall (20000);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	if (acpi_hw_get_mode () == mode) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n", mode));
-		status = AE_OK;
+	/*
+	 * Some hardware takes a LONG time to switch modes. Give them 3 sec to
+	 * do so, but allow faster systems to proceed more quickly.
+	 */
+	retry = 3000;
+	while (retry) {
+		status = AE_NO_HARDWARE_RESPONSE;
+
+		if (acpi_hw_get_mode() == mode) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n", mode));
+			status = AE_OK;
+			break;
+		}
+		acpi_os_stall(1000);
+		retry--;
 	}
 
 	return_ACPI_STATUS (status);
@@ -142,14 +175,33 @@
 u32
 acpi_hw_get_mode (void)
 {
+	acpi_status             status;
+	u32                     value;
+
 
 	ACPI_FUNCTION_TRACE ("Hw_get_mode");
 
+	status = acpi_get_register (ACPI_BITREG_SCI_ENABLE, &value, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_VALUE (ACPI_SYS_MODE_LEGACY);
+	}
 
-	if (acpi_hw_bit_register_read (ACPI_BITREG_SCI_ENABLE, ACPI_MTX_LOCK)) {
+	if (value) {
 		return_VALUE (ACPI_SYS_MODE_ACPI);
 	}
 	else {
+#ifdef CONFIG_IA64_HP_PROTO
+		/*
+ 		 * If enable/disable are zero, the system doesn't support
+		 * legacy mode, so the SCI_EN is wrong.
+ 		 */
+		if (!acpi_gbl_FADT->acpi_enable &&
+		    !acpi_gbl_FADT->acpi_disable) {
+			printk("Warning: Ignoring bogus SCI_EN value\n");
+			return_VALUE (ACPI_SYS_MODE_ACPI);
+		}
+#endif
+
 		return_VALUE (ACPI_SYS_MODE_LEGACY);
 	}
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/hardware/hwgpe.c linux/drivers/acpi/hardware/hwgpe.c
--- ../prev/linux/drivers/acpi/hardware/hwgpe.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/hardware/hwgpe.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Module Name: hwgpe - Low level GPE enable/disable/clear functions
- *              $Revision: 40 $
+ *              $Revision: 41 $
  *
  *****************************************************************************/
 
@@ -25,8 +25,6 @@
  */
 
 #include "acpi.h"
-#include "achware.h"
-#include "acnamesp.h"
 #include "acevents.h"
 
 #define _COMPONENT          ACPI_HARDWARE
@@ -45,7 +43,7 @@
  *
  ******************************************************************************/
 
-u32
+u8
 acpi_hw_get_gpe_bit_mask (
 	u32                     gpe_number)
 {
@@ -65,13 +63,14 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_enable_gpe (
 	u32                     gpe_number)
 {
 	u32                     in_byte;
 	u32                     register_index;
-	u32                     bit_mask;
+	u8                      bit_mask;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -89,10 +88,16 @@
 	 * Read the current value of the register, set the appropriate bit
 	 * to enable the GPE, and write out the new register.
 	 */
-	in_byte = acpi_hw_low_level_read (8,
-			 &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
-	acpi_hw_low_level_write (8, (in_byte | bit_mask),
-			 &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
+	status = acpi_hw_low_level_read (8, &in_byte,
+			  &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	status = acpi_hw_low_level_write (8, (in_byte | bit_mask),
+			  &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
+
+	return (status);
 }
 
 
@@ -114,7 +119,7 @@
 	u32                     gpe_number)
 {
 	u32                     register_index;
-	u32                     bit_mask;
+	u8                      bit_mask;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -147,13 +152,14 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_disable_gpe (
 	u32                     gpe_number)
 {
 	u32                     in_byte;
 	u32                     register_index;
-	u32                     bit_mask;
+	u8                      bit_mask;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -171,12 +177,20 @@
 	 * Read the current value of the register, clear the appropriate bit,
 	 * and write out the new register value to disable the GPE.
 	 */
-	in_byte = acpi_hw_low_level_read (8,
-			 &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
-	acpi_hw_low_level_write (8, (in_byte & ~bit_mask),
-			 &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
+	status = acpi_hw_low_level_read (8, &in_byte,
+			  &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
+	status = acpi_hw_low_level_write (8, (in_byte & ~bit_mask),
+			  &acpi_gbl_gpe_register_info[register_index].enable_address, 0);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
 
 	acpi_hw_disable_gpe_for_wakeup(gpe_number);
+	return (AE_OK);
 }
 
 
@@ -198,7 +212,7 @@
 	u32                     gpe_number)
 {
 	u32                     register_index;
-	u32                     bit_mask;
+	u8                      bit_mask;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -231,12 +245,13 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_clear_gpe (
 	u32                     gpe_number)
 {
 	u32                     register_index;
-	u32                     bit_mask;
+	u8                      bit_mask;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -254,8 +269,10 @@
 	 * Write a one to the appropriate bit in the status register to
 	 * clear this GPE.
 	 */
-	acpi_hw_low_level_write (8, bit_mask,
-			   &acpi_gbl_gpe_register_info[register_index].status_address, 0);
+	status = acpi_hw_low_level_write (8, bit_mask,
+			  &acpi_gbl_gpe_register_info[register_index].status_address, 0);
+
+	return (status);
 }
 
 
@@ -271,22 +288,23 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_get_gpe_status (
 	u32                     gpe_number,
 	acpi_event_status       *event_status)
 {
 	u32                     in_byte = 0;
 	u32                     register_index = 0;
-	u32                     bit_mask = 0;
+	u8                      bit_mask = 0;
 	ACPI_GPE_REGISTER_INFO  *gpe_register_info;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_ENTRY ();
 
 
 	if (!event_status) {
-		return;
+		return (AE_BAD_PARAMETER);
 	}
 
 	(*event_status) = 0;
@@ -302,7 +320,11 @@
 
 	/* GPE Enabled? */
 
-	in_byte = acpi_hw_low_level_read (8, &gpe_register_info->enable_address, 0);
+	status = acpi_hw_low_level_read (8, &in_byte, &gpe_register_info->enable_address, 0);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
 	if (bit_mask & in_byte) {
 		(*event_status) |= ACPI_EVENT_FLAG_ENABLED;
 	}
@@ -315,10 +337,15 @@
 
 	/* GPE active (set)? */
 
-	in_byte = acpi_hw_low_level_read (8, &gpe_register_info->status_address, 0);
+	status = acpi_hw_low_level_read (8, &in_byte, &gpe_register_info->status_address, 0);
+	if (ACPI_FAILURE (status)) {
+		return (status);
+	}
+
 	if (bit_mask & in_byte) {
 		(*event_status) |= ACPI_EVENT_FLAG_SET;
 	}
+	return (AE_OK);
 }
 
 
@@ -338,12 +365,14 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_disable_non_wakeup_gpes (
 	void)
 {
 	u32                     i;
 	ACPI_GPE_REGISTER_INFO  *gpe_register_info;
+	u32                     in_value;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -356,15 +385,24 @@
 		 * Read the enabled status of all GPEs. We
 		 * will be using it to restore all the GPEs later.
 		 */
-		gpe_register_info->enable = (u8) acpi_hw_low_level_read (8,
+		status = acpi_hw_low_level_read (8, &in_value,
 				 &gpe_register_info->enable_address, 0);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+
+		gpe_register_info->enable = (u8) in_value;
 
 		/*
 		 * Disable all GPEs except wakeup GPEs.
 		 */
-		acpi_hw_low_level_write (8, gpe_register_info->wake_enable,
+		status = acpi_hw_low_level_write (8, gpe_register_info->wake_enable,
 				&gpe_register_info->enable_address, 0);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
 	}
+	return (AE_OK);
 }
 
 
@@ -380,12 +418,13 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_enable_non_wakeup_gpes (
 	void)
 {
 	u32                     i;
 	ACPI_GPE_REGISTER_INFO  *gpe_register_info;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -398,7 +437,11 @@
 		 * We previously stored the enabled status of all GPEs.
 		 * Blast them back in.
 		 */
-		acpi_hw_low_level_write (8, gpe_register_info->enable, &
-				gpe_register_info->enable_address, 0);
+		status = acpi_hw_low_level_write (8, gpe_register_info->enable,
+				 &gpe_register_info->enable_address, 0);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
 	}
+	return (AE_OK);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/hardware/hwregs.c linux/drivers/acpi/hardware/hwregs.c
--- ../prev/linux/drivers/acpi/hardware/hwregs.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/hardware/hwregs.c	Fri May 31 11:41:57 2002
@@ -3,7 +3,7 @@
  *
  * Module Name: hwregs - Read/write access functions for the various ACPI
  *                       control and status registers.
- *              $Revision: 121 $
+ *              $Revision: 130 $
  *
  ******************************************************************************/
 
@@ -27,7 +27,6 @@
 
 
 #include "acpi.h"
-#include "achware.h"
 #include "acnamesp.h"
 
 #define _COMPONENT          ACPI_HARDWARE
@@ -46,10 +45,10 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_clear_acpi_status (void)
 {
-	NATIVE_UINT             i;
+	NATIVE_UINT_MAX32       i;
 	NATIVE_UINT             gpe_block;
 	acpi_status             status;
 
@@ -64,36 +63,46 @@
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
 	if (ACPI_FAILURE (status)) {
-		return_VOID;
+		return_ACPI_STATUS (status);
 	}
 
-	acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
-			ACPI_BITMASK_ALL_FIXED_STATUS);
+	status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
+			  ACPI_BITMASK_ALL_FIXED_STATUS);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
 	/* Clear the fixed events */
 
 	if (ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xpm1b_evt_blk.address)) {
-		acpi_hw_low_level_write (16, ACPI_BITMASK_ALL_FIXED_STATUS,
-				&acpi_gbl_FADT->Xpm1b_evt_blk, 0);
+		status = acpi_hw_low_level_write (16, ACPI_BITMASK_ALL_FIXED_STATUS,
+				 &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 	}
 
 	/* Clear the GPE Bits */
 
 	for (gpe_block = 0; gpe_block < ACPI_MAX_GPE_BLOCKS; gpe_block++) {
 		for (i = 0; i < acpi_gbl_gpe_block_info[gpe_block].register_count; i++) {
-			acpi_hw_low_level_write (8, 0xFF,
-				acpi_gbl_gpe_block_info[gpe_block].block_address, i);
+			status = acpi_hw_low_level_write (8, 0xFF,
+					 acpi_gbl_gpe_block_info[gpe_block].block_address, i);
+			if (ACPI_FAILURE (status)) {
+				goto unlock_and_exit;
+			}
 		}
 	}
 
+unlock_and_exit:
 	(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
-	return_VOID;
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_hw_get_sleep_type_data
+ * FUNCTION:    Acpi_get_sleep_type_data
  *
  * PARAMETERS:  Sleep_state         - Numeric sleep state
  *              *Sleep_type_a        - Where SLP_TYPa is returned
@@ -107,7 +116,7 @@
  ******************************************************************************/
 
 acpi_status
-acpi_hw_get_sleep_type_data (
+acpi_get_sleep_type_data (
 	u8                      sleep_state,
 	u8                      *sleep_type_a,
 	u8                      *sleep_type_b)
@@ -116,7 +125,7 @@
 	acpi_operand_object     *obj_desc;
 
 
-	ACPI_FUNCTION_TRACE ("Hw_get_sleep_type_data");
+	ACPI_FUNCTION_TRACE ("Acpi_get_sleep_type_data");
 
 
 	/*
@@ -213,7 +222,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_hw_bit_register_read
+ * FUNCTION:    Acpi_get_register
  *
  * PARAMETERS:  Register_id     - index of ACPI Register to access
  *              Use_lock        - Lock the hardware
@@ -225,24 +234,20 @@
  *
  ******************************************************************************/
 
-u32
-acpi_hw_bit_register_read (
+acpi_status
+acpi_get_register (
 	u32                     register_id,
+	u32                     *return_value,
 	u32                     flags)
 {
 	u32                     register_value = 0;
 	ACPI_BIT_REGISTER_INFO  *bit_reg_info;
+	acpi_status             status;
 
 
-	ACPI_FUNCTION_TRACE ("Hw_bit_register_read");
+	ACPI_FUNCTION_TRACE ("Acpi_get_register");
 
 
-	if (flags & ACPI_MTX_LOCK) {
-		if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE))) {
-			return_VALUE (0);
-		}
-	}
-
 	/* Get the info structure corresponding to the requested ACPI Register */
 
 	bit_reg_info = acpi_hw_get_bit_register_info (register_id);
@@ -250,66 +255,86 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, bit_reg_info->parent_register);
+	if (flags & ACPI_MTX_LOCK) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+	}
+
+	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+			  bit_reg_info->parent_register, &register_value);
 
 	if (flags & ACPI_MTX_LOCK) {
 		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
 	}
 
-	/* Normalize the value that was read */
+	if (ACPI_SUCCESS (status)) {
+		/* Normalize the value that was read */
 
-	register_value = ((register_value & bit_reg_info->access_bit_mask) >> bit_reg_info->bit_position);
+		register_value = ((register_value & bit_reg_info->access_bit_mask)
+				   >> bit_reg_info->bit_position);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "ACPI Register_read: got %X\n", register_value));
-	return_VALUE (register_value);
+		*return_value = register_value;
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Read value %X\n", register_value));
+	}
+
+	return_ACPI_STATUS (status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_hw_bit_register_write
+ * FUNCTION:    Acpi_set_register
  *
  * PARAMETERS:  Register_id     - ID of ACPI Bit_register to access
  *              Value           - (only used on write) value to write to the
  *                                Register, NOT pre-normalized to the bit pos.
  *              Flags           - Lock the hardware or not
  *
- * RETURN:      Value written to from specified Register.  This value
- *              is shifted all the way right.
+ * RETURN:      None
  *
  * DESCRIPTION: ACPI Bit Register write function.
  *
  ******************************************************************************/
 
-u32
-acpi_hw_bit_register_write (
+acpi_status
+acpi_set_register (
 	u32                     register_id,
 	u32                     value,
 	u32                     flags)
 {
 	u32                     register_value = 0;
 	ACPI_BIT_REGISTER_INFO  *bit_reg_info;
+	acpi_status             status;
 
 
-	ACPI_FUNCTION_TRACE_U32 ("Hw_bit_register_write", register_id);
+	ACPI_FUNCTION_TRACE_U32 ("Acpi_set_register", register_id);
 
 
-	if (flags & ACPI_MTX_LOCK) {
-		if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE))) {
-			return_VALUE (0);
-		}
-	}
-
 	/* Get the info structure corresponding to the requested ACPI Register */
 
 	bit_reg_info = acpi_hw_get_bit_register_info (register_id);
 	if (!bit_reg_info) {
+		ACPI_REPORT_ERROR (("Bad ACPI HW Register_id: %X\n", register_id));
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
+	if (flags & ACPI_MTX_LOCK) {
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+	}
+
 	/* Always do a register read first so we can insert the new bits  */
 
-	register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, bit_reg_info->parent_register);
+	status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+			  bit_reg_info->parent_register, &register_value);
+	if (ACPI_FAILURE (status)) {
+		goto unlock_and_exit;
+	}
 
 	/*
 	 * Decode the Register ID
@@ -327,10 +352,11 @@
 		 * information is the single bit we're interested in, all others should
 		 * be written as 0 so they will be left unchanged
 		 */
-		value = ACPI_REGISTER_PREPARE_BITS (value, bit_reg_info->bit_position, bit_reg_info->access_bit_mask);
+		value = ACPI_REGISTER_PREPARE_BITS (value,
+				 bit_reg_info->bit_position, bit_reg_info->access_bit_mask);
 		if (value) {
-			acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_STATUS,
-				(u16) value);
+			status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+					 ACPI_REGISTER_PM1_STATUS, (u16) value);
 			register_value = 0;
 		}
 		break;
@@ -338,9 +364,11 @@
 
 	case ACPI_REGISTER_PM1_ENABLE:
 
-		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position, bit_reg_info->access_bit_mask, value);
+		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
+				bit_reg_info->access_bit_mask, value);
 
-		acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_ENABLE, (u16) register_value);
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+				  ACPI_REGISTER_PM1_ENABLE, (u16) register_value);
 		break;
 
 
@@ -353,29 +381,36 @@
 		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "PM1 control: Read %X\n", register_value));
 
-		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position, bit_reg_info->access_bit_mask, value);
+		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
+				bit_reg_info->access_bit_mask, value);
 
-		acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, register_id,
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK, register_id,
 				(u16) register_value);
 		break;
 
 
 	case ACPI_REGISTER_PM2_CONTROL:
 
-		register_value = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM2_CONTROL);
+		status = acpi_hw_register_read (ACPI_MTX_DO_NOT_LOCK,
+				 ACPI_REGISTER_PM2_CONTROL, &register_value);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "PM2 control: Read %X from %8.8X%8.8X\n",
-			register_value, ACPI_HIDWORD (acpi_gbl_FADT->Xpm2_cnt_blk.address),
-			ACPI_LODWORD (acpi_gbl_FADT->Xpm2_cnt_blk.address)));
+			register_value,
+			ACPI_HIDWORD (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm2_cnt_blk.address)),
+			ACPI_LODWORD (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm2_cnt_blk.address))));
 
-		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position, bit_reg_info->access_bit_mask, value);
+		ACPI_REGISTER_INSERT_VALUE (register_value, bit_reg_info->bit_position,
+				bit_reg_info->access_bit_mask, value);
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %04X to %8.8X%8.8X\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_IO, "About to write %4.4X to %8.8X%8.8X\n",
 			register_value,
-			ACPI_HIDWORD (acpi_gbl_FADT->Xpm2_cnt_blk.address),
-			ACPI_LODWORD (acpi_gbl_FADT->Xpm2_cnt_blk.address)));
+			ACPI_HIDWORD (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm2_cnt_blk.address)),
+			ACPI_LODWORD (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm2_cnt_blk.address))));
 
-		acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
+		status = acpi_hw_register_write (ACPI_MTX_DO_NOT_LOCK,
 				   ACPI_REGISTER_PM2_CONTROL, (u8) (register_value));
 		break;
 
@@ -384,16 +419,19 @@
 		break;
 	}
 
+
+unlock_and_exit:
+
 	if (flags & ACPI_MTX_LOCK) {
 		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
 	}
 
 	/* Normalize the value that was read */
 
-	register_value = ((register_value & bit_reg_info->access_bit_mask) >> bit_reg_info->bit_position);
+	ACPI_DEBUG_EXEC (register_value = ((register_value & bit_reg_info->access_bit_mask) >> bit_reg_info->bit_position));
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "ACPI Register_write actual %X\n", register_value));
-	return_VALUE (register_value);
+	ACPI_DEBUG_PRINT ((ACPI_DB_IO, "ACPI Register Write actual %X\n", register_value));
+	return_ACPI_STATUS (status);
 }
 
 
@@ -411,73 +449,98 @@
  *
  ******************************************************************************/
 
-u32
+acpi_status
 acpi_hw_register_read (
 	u8                      use_lock,
-	u32                     register_id)
+	u32                     register_id,
+	u32                     *return_value)
 {
-	u32                     value = 0;
+	u32                     value1 = 0;
+	u32                     value2 = 0;
 	u32                     bank_offset;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE ("Hw_register_read");
 
 
 	if (ACPI_MTX_LOCK == use_lock) {
-		if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE))) {
-			return_VALUE (0);
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
 	}
 
 	switch (register_id) {
 	case ACPI_REGISTER_PM1_STATUS:           /* 16-bit access */
 
-		value =  acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1a_evt_blk, 0);
-		value |= acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
+		status = acpi_hw_low_level_read (16, &value1, &acpi_gbl_FADT->Xpm1a_evt_blk, 0);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
+
+		status = acpi_hw_low_level_read (16, &value2, &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
+		value1 |= value2;
 		break;
 
 
 	case ACPI_REGISTER_PM1_ENABLE:           /* 16-bit access*/
 
 		bank_offset = ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len);
-		value =  acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1a_evt_blk, bank_offset);
-		value |= acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1b_evt_blk, bank_offset);
+		status = acpi_hw_low_level_read (16, &value1, &acpi_gbl_FADT->Xpm1a_evt_blk, bank_offset);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
+
+		status = acpi_hw_low_level_read (16, &value2, &acpi_gbl_FADT->Xpm1b_evt_blk, bank_offset);
+		value1 |= value2;
 		break;
 
 
 	case ACPI_REGISTER_PM1_CONTROL:          /* 16-bit access */
 
-		value =  acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
-		value |= acpi_hw_low_level_read (16, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
+		status = acpi_hw_low_level_read (16, &value1, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
+
+		status = acpi_hw_low_level_read (16, &value2, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
+		value1 |= value2;
 		break;
 
 
 	case ACPI_REGISTER_PM2_CONTROL:          /* 8-bit access */
 
-		value =  acpi_hw_low_level_read (8, &acpi_gbl_FADT->Xpm2_cnt_blk, 0);
+		status = acpi_hw_low_level_read (8, &value1, &acpi_gbl_FADT->Xpm2_cnt_blk, 0);
 		break;
 
 
 	case ACPI_REGISTER_PM_TIMER:             /* 32-bit access */
 
-		value =  acpi_hw_low_level_read (32, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
+		status = acpi_hw_low_level_read (32, &value1, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
 		break;
 
 	case ACPI_REGISTER_SMI_COMMAND_BLOCK:    /* 8-bit access */
 
-		acpi_os_read_port (acpi_gbl_FADT->smi_cmd, &value, 8);
+		status = acpi_os_read_port (acpi_gbl_FADT->smi_cmd, &value1, 8);
 		break;
 
 	default:
-		/* Value will be returned as 0 */
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unknown Register ID: %X\n", register_id));
+		status = AE_BAD_PARAMETER;
 		break;
 	}
 
+unlock_and_exit:
 	if (ACPI_MTX_LOCK == use_lock) {
 		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
 	}
 
-	return_VALUE (value);
+	if (ACPI_SUCCESS (status)) {
+		*return_value = value1;
+	}
+
+	return_ACPI_STATUS (status);
 }
 
 
@@ -495,68 +558,82 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_register_write (
 	u8                      use_lock,
 	u32                     register_id,
 	u32                     value)
 {
 	u32                     bank_offset;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE ("Hw_register_write");
 
 
 	if (ACPI_MTX_LOCK == use_lock) {
-		if (ACPI_FAILURE (acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE))) {
-			return_VOID;
+		status = acpi_ut_acquire_mutex (ACPI_MTX_HARDWARE);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
 		}
 	}
 
 	switch (register_id) {
 	case ACPI_REGISTER_PM1_STATUS:           /* 16-bit access */
 
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_evt_blk, 0);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_evt_blk, 0);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
+
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
 		break;
 
 
 	case ACPI_REGISTER_PM1_ENABLE:           /* 16-bit access*/
 
 		bank_offset = ACPI_DIV_2 (acpi_gbl_FADT->pm1_evt_len);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_evt_blk, bank_offset);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_evt_blk, bank_offset);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_evt_blk, bank_offset);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
+
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_evt_blk, bank_offset);
 		break;
 
 
 	case ACPI_REGISTER_PM1_CONTROL:          /* 16-bit access */
 
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
+		if (ACPI_FAILURE (status)) {
+			goto unlock_and_exit;
+		}
+
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
 		break;
 
 
 	case ACPI_REGISTER_PM1A_CONTROL:         /* 16-bit access */
 
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1a_cnt_blk, 0);
 		break;
 
 
 	case ACPI_REGISTER_PM1B_CONTROL:         /* 16-bit access */
 
-		acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
+		status = acpi_hw_low_level_write (16, value, &acpi_gbl_FADT->Xpm1b_cnt_blk, 0);
 		break;
 
 
 	case ACPI_REGISTER_PM2_CONTROL:          /* 8-bit access */
 
-		acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->Xpm2_cnt_blk, 0);
+		status = acpi_hw_low_level_write (8, value, &acpi_gbl_FADT->Xpm2_cnt_blk, 0);
 		break;
 
 
 	case ACPI_REGISTER_PM_TIMER:             /* 32-bit access */
 
-		acpi_hw_low_level_write (32, value, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
+		status = acpi_hw_low_level_write (32, value, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
 		break;
 
 
@@ -564,20 +641,21 @@
 
 		/* SMI_CMD is currently always in IO space */
 
-		acpi_os_write_port (acpi_gbl_FADT->smi_cmd, value, 8);
+		status = acpi_os_write_port (acpi_gbl_FADT->smi_cmd, (acpi_integer) value, 8);
 		break;
 
 
 	default:
-		value = 0;
+		status = AE_BAD_PARAMETER;
 		break;
 	}
 
+unlock_and_exit:
 	if (ACPI_MTX_LOCK == use_lock) {
 		(void) acpi_ut_release_mutex (ACPI_MTX_HARDWARE);
 	}
 
-	return_VOID;
+	return_ACPI_STATUS (status);
 }
 
 
@@ -595,30 +673,33 @@
  *
  ******************************************************************************/
 
-u32
+acpi_status
 acpi_hw_low_level_read (
 	u32                     width,
+	u32                     *value,
 	acpi_generic_address    *reg,
 	u32                     offset)
 {
-	u32                     value = 0;
 	ACPI_PHYSICAL_ADDRESS   mem_address;
 	ACPI_IO_ADDRESS         io_address;
 	acpi_pci_id             pci_id;
 	u16                     pci_register;
+	acpi_status             status;
 
 
-	ACPI_FUNCTION_ENTRY ();
+	ACPI_FUNCTION_NAME ("Hw_low_level_read");
 
 
 	/*
 	 * Must have a valid pointer to a GAS structure, and
-	 * a non-zero address within
+	 * a non-zero address within. However, don't return an error
+	 * because the PM1A/B code must not fail if B isn't present.
 	 */
 	if ((!reg) ||
 		(!ACPI_VALID_ADDRESS (reg->address))) {
-		return 0;
+		return (AE_OK);
 	}
+	*value = 0;
 
 	/*
 	 * Three address spaces supported:
@@ -627,17 +708,19 @@
 	switch (reg->address_space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
 
-		mem_address = (ACPI_PHYSICAL_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
+		mem_address = (ACPI_GET_ADDRESS (reg->address)
+				  + (ACPI_PHYSICAL_ADDRESS) offset);
 
-		acpi_os_read_memory (mem_address, &value, width);
+		status = acpi_os_read_memory (mem_address, value, width);
 		break;
 
 
 	case ACPI_ADR_SPACE_SYSTEM_IO:
 
-		io_address = (ACPI_IO_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
+		io_address = (ACPI_IO_ADDRESS) (ACPI_GET_ADDRESS (reg->address)
+				   + (ACPI_PHYSICAL_ADDRESS) offset);
 
-		acpi_os_read_port (io_address, &value, width);
+		status = acpi_os_read_port (io_address, value, width);
 		break;
 
 
@@ -647,13 +730,20 @@
 		pci_id.bus     = 0;
 		pci_id.device  = ACPI_PCI_DEVICE (ACPI_GET_ADDRESS (reg->address));
 		pci_id.function = ACPI_PCI_FUNCTION (ACPI_GET_ADDRESS (reg->address));
-		pci_register   = (u16) (ACPI_PCI_REGISTER (ACPI_GET_ADDRESS (reg->address)) + offset);
+		pci_register   = (u16) (ACPI_PCI_REGISTER (ACPI_GET_ADDRESS (reg->address))
+				  + offset);
+
+		status = acpi_os_read_pci_configuration (&pci_id, pci_register, value, width);
+		break;
+
 
-		acpi_os_read_pci_configuration (&pci_id, pci_register, &value, width);
+	default:
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unsupported address space: %X\n", reg->address_space_id));
+		status = AE_BAD_PARAMETER;
 		break;
 	}
 
-	return value;
+	return (status);
 }
 
 
@@ -673,7 +763,7 @@
  *
  ******************************************************************************/
 
-void
+acpi_status
 acpi_hw_low_level_write (
 	u32                     width,
 	u32                     value,
@@ -684,20 +774,21 @@
 	ACPI_IO_ADDRESS         io_address;
 	acpi_pci_id             pci_id;
 	u16                     pci_register;
+	acpi_status             status;
 
 
-	ACPI_FUNCTION_ENTRY ();
+	ACPI_FUNCTION_NAME ("Hw_low_level_write");
 
 
 	/*
 	 * Must have a valid pointer to a GAS structure, and
-	 * a non-zero address within
+	 * a non-zero address within. However, don't return an error
+	 * because the PM1A/B code must not fail if B isn't present.
 	 */
 	if ((!reg) ||
 		(!ACPI_VALID_ADDRESS (reg->address))) {
-		return;
+		return (AE_OK);
 	}
-
 	/*
 	 * Three address spaces supported:
 	 * Memory, Io, or PCI config.
@@ -705,17 +796,19 @@
 	switch (reg->address_space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
 
-		mem_address = (ACPI_PHYSICAL_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
+		mem_address = (ACPI_GET_ADDRESS (reg->address)
+				  + (ACPI_PHYSICAL_ADDRESS) offset);
 
-		acpi_os_write_memory (mem_address, value, width);
+		status = acpi_os_write_memory (mem_address, (acpi_integer) value, width);
 		break;
 
 
 	case ACPI_ADR_SPACE_SYSTEM_IO:
 
-		io_address = (ACPI_IO_ADDRESS) (ACPI_GET_ADDRESS (reg->address) + offset);
+		io_address = (ACPI_IO_ADDRESS) (ACPI_GET_ADDRESS (reg->address)
+				   + (ACPI_PHYSICAL_ADDRESS) offset);
 
-		acpi_os_write_port (io_address, value, width);
+		status = acpi_os_write_port (io_address, (acpi_integer) value, width);
 		break;
 
 
@@ -725,9 +818,18 @@
 		pci_id.bus     = 0;
 		pci_id.device  = ACPI_PCI_DEVICE (ACPI_GET_ADDRESS (reg->address));
 		pci_id.function = ACPI_PCI_FUNCTION (ACPI_GET_ADDRESS (reg->address));
-		pci_register   = (u16) (ACPI_PCI_REGISTER (ACPI_GET_ADDRESS (reg->address)) + offset);
+		pci_register   = (u16) (ACPI_PCI_REGISTER (ACPI_GET_ADDRESS (reg->address))
+				  + offset);
 
-		acpi_os_write_pci_configuration (&pci_id, pci_register, value, width);
+		status = acpi_os_write_pci_configuration (&pci_id, pci_register, (acpi_integer) value, width);
+		break;
+
+
+	default:
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Unsupported address space: %X\n", reg->address_space_id));
+		status = AE_BAD_PARAMETER;
 		break;
 	}
+
+	return (status);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/hardware/hwsleep.c linux/drivers/acpi/hardware/hwsleep.c
--- ../prev/linux/drivers/acpi/hardware/hwsleep.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/hardware/hwsleep.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Name: hwsleep.c - ACPI Hardware Sleep/Wake Interface
- *              $Revision: 37 $
+ *              $Revision: 45 $
  *
  *****************************************************************************/
 
@@ -25,8 +25,6 @@
  */
 
 #include "acpi.h"
-#include "acnamesp.h"
-#include "achware.h"
 
 #define _COMPONENT          ACPI_HARDWARE
 	 ACPI_MODULE_NAME    ("hwsleep")
@@ -56,10 +54,12 @@
 	/* Set the vector */
 
 	if (acpi_gbl_common_fACS.vector_width == 32) {
-		*(u32 *) acpi_gbl_common_fACS.firmware_waking_vector = (u32) physical_address;
+		*(ACPI_CAST_PTR (u32, acpi_gbl_common_fACS.firmware_waking_vector))
+				= (u32) physical_address;
 	}
 	else {
-		*acpi_gbl_common_fACS.firmware_waking_vector = physical_address;
+		*acpi_gbl_common_fACS.firmware_waking_vector
+				= physical_address;
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -95,10 +95,12 @@
 	/* Get the vector */
 
 	if (acpi_gbl_common_fACS.vector_width == 32) {
-		*physical_address = *(u32 *) acpi_gbl_common_fACS.firmware_waking_vector;
+		*physical_address = (ACPI_PHYSICAL_ADDRESS)
+			*(ACPI_CAST_PTR (u32, acpi_gbl_common_fACS.firmware_waking_vector));
 	}
 	else {
-		*physical_address = *acpi_gbl_common_fACS.firmware_waking_vector;
+		*physical_address =
+			*acpi_gbl_common_fACS.firmware_waking_vector;
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -135,7 +137,7 @@
 	/*
 	 * _PSW methods could be run here to enable wake-on keyboard, LAN, etc.
 	 */
-	status = acpi_hw_get_sleep_type_data (sleep_state,
+	status = acpi_get_sleep_type_data (sleep_state,
 			  &acpi_gbl_sleep_type_a, &acpi_gbl_sleep_type_b);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -182,10 +184,12 @@
 acpi_enter_sleep_state (
 	u8                      sleep_state)
 {
-	u16                     PM1Acontrol;
-	u16                     PM1Bcontrol;
+	u32                     PM1Acontrol;
+	u32                     PM1Bcontrol;
 	ACPI_BIT_REGISTER_INFO  *sleep_type_reg_info;
 	ACPI_BIT_REGISTER_INFO  *sleep_enable_reg_info;
+	u32                     in_value;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE ("Acpi_enter_sleep_state");
@@ -193,7 +197,7 @@
 
 	if ((acpi_gbl_sleep_type_a > ACPI_SLEEP_TYPE_MAX) ||
 		(acpi_gbl_sleep_type_b > ACPI_SLEEP_TYPE_MAX)) {
-		ACPI_REPORT_ERROR (("Sleep values out of range: A=%x B=%x\n",
+		ACPI_REPORT_ERROR (("Sleep values out of range: A=%X B=%X\n",
 			acpi_gbl_sleep_type_a, acpi_gbl_sleep_type_b));
 		return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
 	}
@@ -204,16 +208,34 @@
 
 	/* Clear wake status */
 
-	acpi_hw_bit_register_write (ACPI_BITREG_WAKE_STATUS, 1, ACPI_MTX_LOCK);
-	acpi_hw_clear_acpi_status();
+	status = acpi_set_register (ACPI_BITREG_WAKE_STATUS, 1, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	/* TBD: Disable arbitration here? */
+	status = acpi_hw_clear_acpi_status();
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	acpi_hw_disable_non_wakeup_gpes();
+	/* Disable BM arbitration */
+
+	status = acpi_set_register (ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_hw_disable_non_wakeup_gpes();
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Get current value of PM1A control */
 
-	PM1Acontrol = (u16) acpi_hw_register_read (ACPI_MTX_LOCK, ACPI_REGISTER_PM1_CONTROL);
+	status = acpi_hw_register_read (ACPI_MTX_LOCK, ACPI_REGISTER_PM1_CONTROL, &PM1Acontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 	ACPI_DEBUG_PRINT ((ACPI_DB_OK, "Entering S%d\n", sleep_state));
 
 	/* Clear SLP_EN and SLP_TYP fields */
@@ -228,8 +250,15 @@
 
 	/* Write #1: fill in SLP_TYP data */
 
-	acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
-	acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	status = acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/* Insert SLP_ENABLE bit */
 
@@ -237,26 +266,48 @@
 	PM1Bcontrol |= sleep_enable_reg_info->access_bit_mask;
 
 	/* Write #2: SLP_TYP + SLP_EN */
-	ACPI_FLUSH_CPU_CACHE();
 
-	acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
-	acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	ACPI_FLUSH_CPU_CACHE ();
+
+	status = acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1Acontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	status = acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1Bcontrol);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
 	/*
 	 * Wait a second, then try again. This is to get S4/5 to work on all machines.
 	 */
 	if (sleep_state > ACPI_STATE_S3) {
-		acpi_os_stall (1000000);
-
-		acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1_CONTROL,
-				sleep_enable_reg_info->access_bit_mask);
+		/*
+		 * We wait so long to allow chipsets that poll this reg very slowly to
+		 * still read the right value. Ideally, this entire block would go
+		 * away entirely.
+		 */
+		acpi_os_stall (10000000);
+
+		status = acpi_hw_register_write (ACPI_MTX_LOCK, ACPI_REGISTER_PM1_CONTROL,
+				 sleep_enable_reg_info->access_bit_mask);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
 	}
 
 	/* Wait until we enter sleep state */
 
-	while (!acpi_hw_bit_register_read (ACPI_BITREG_WAKE_STATUS, ACPI_MTX_LOCK)) {
+	do {
+		status = acpi_get_register (ACPI_BITREG_WAKE_STATUS, &in_value, ACPI_MTX_LOCK);
+		if (ACPI_FAILURE (status)) {
+			return_ACPI_STATUS (status);
+		}
+
 		/* Spin until we wake */
-	}
+
+	} while (!in_value);
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -311,7 +362,13 @@
 
 	/* _WAK returns stuff - do we want to look at it? */
 
-	acpi_hw_enable_non_wakeup_gpes();
+	status = acpi_hw_enable_non_wakeup_gpes();
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
 
-	return_ACPI_STATUS (AE_OK);
+	/* Disable BM arbitration */
+	status = acpi_set_register (ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_LOCK);
+
+	return_ACPI_STATUS (status);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/hardware/hwtimer.c linux/drivers/acpi/hardware/hwtimer.c
--- ../prev/linux/drivers/acpi/hardware/hwtimer.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/hardware/hwtimer.c	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Name: hwtimer.c - ACPI Power Management Timer Interface
- *              $Revision: 20 $
+ *              $Revision: 21 $
  *
  *****************************************************************************/
 
@@ -25,7 +25,6 @@
  */
 
 #include "acpi.h"
-#include "achware.h"
 
 #define _COMPONENT          ACPI_HARDWARE
 	 ACPI_MODULE_NAME    ("hwtimer")
@@ -81,6 +80,9 @@
 acpi_get_timer (
 	u32                     *ticks)
 {
+	acpi_status             status;
+
+
 	ACPI_FUNCTION_TRACE ("Acpi_get_timer");
 
 
@@ -88,9 +90,9 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	*ticks = acpi_hw_low_level_read (32, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
+	status = acpi_hw_low_level_read (32, ticks, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
 
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS (status);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acconfig.h linux/drivers/acpi/include/acconfig.h
--- ../prev/linux/drivers/acpi/include/acconfig.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acconfig.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acconfig.h - Global configuration constants
- *       $Revision: 95 $
+ *       $Revision: 102 $
  *
  *****************************************************************************/
 
@@ -54,7 +54,7 @@
 
 /* Version string */
 
-#define ACPI_CA_VERSION             0x20020329
+#define ACPI_CA_VERSION             0x20020517
 
 /* Version of ACPI supported */
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acdebug.h linux/drivers/acpi/include/acdebug.h
--- ../prev/linux/drivers/acpi/include/acdebug.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acdebug.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acdebug.h - ACPI/AML debugger
- *       $Revision: 58 $
+ *       $Revision: 61 $
  *
  *****************************************************************************/
 
@@ -63,7 +63,7 @@
  * dbapi - external debugger interfaces
  */
 
-int
+acpi_status
 acpi_db_initialize (
 	void);
 
@@ -82,7 +82,6 @@
  * dbcmds - debug commands and output routines
  */
 
-
 void
 acpi_db_display_table_info (
 	NATIVE_CHAR             *table_arg);
@@ -153,6 +152,38 @@
 acpi_db_display_resources (
 	NATIVE_CHAR             *object_arg);
 
+void
+acpi_db_check_integrity (
+	void);
+
+acpi_status
+acpi_db_integrity_walk (
+	acpi_handle             obj_handle,
+	u32                     nesting_level,
+	void                    *context,
+	void                    **return_value);
+
+acpi_status
+acpi_db_walk_and_match_name (
+	acpi_handle             obj_handle,
+	u32                     nesting_level,
+	void                    *context,
+	void                    **return_value);
+
+acpi_status
+acpi_db_walk_for_references (
+	acpi_handle             obj_handle,
+	u32                     nesting_level,
+	void                    *context,
+	void                    **return_value);
+
+acpi_status
+acpi_db_walk_for_specific_objects (
+	acpi_handle             obj_handle,
+	u32                     nesting_level,
+	void                    *context,
+	void                    **return_value);
+
 
 /*
  * dbdisasm - AML disassembler
@@ -181,12 +212,20 @@
 acpi_db_decode_internal_object (
 	acpi_operand_object     *obj_desc);
 
+u32
+acpi_db_block_type (
+	acpi_parse_object       *op);
+
+acpi_status
+acpi_ps_display_object_pathname (
+	acpi_walk_state         *walk_state,
+	acpi_parse_object       *op);
+
 
 /*
  * dbdisply - debug display commands
  */
 
-
 void
 acpi_db_display_method_info (
 	acpi_parse_object       *op);
@@ -231,6 +270,14 @@
 	acpi_operand_object     *obj_desc,
 	acpi_walk_state         *walk_state);
 
+void
+acpi_db_dump_parser_descriptor (
+	acpi_parse_object       *op);
+
+void *
+acpi_db_get_pointer (
+	void                    *target);
+
 
 /*
  * dbexec - debugger control method execution
@@ -248,6 +295,23 @@
 	NATIVE_CHAR             *num_loops_arg,
 	NATIVE_CHAR             *method_name_arg);
 
+acpi_status
+acpi_db_execute_method (
+	acpi_db_method_info     *info,
+	acpi_buffer             *return_obj);
+
+void
+acpi_db_execute_setup (
+	acpi_db_method_info     *info);
+
+u32
+acpi_db_get_outstanding_allocations (
+	void);
+
+void ACPI_SYSTEM_XFACE
+acpi_db_method_thread (
+	void                    *context);
+
 
 /*
  * dbfileio - Debugger file I/O commands
@@ -258,6 +322,9 @@
 	NATIVE_CHAR             *user_argument,
 	ARGUMENT_INFO           *arguments);
 
+acpi_status
+ae_local_load_table (
+	acpi_table_header       *table_ptr);
 
 void
 acpi_db_close_debug_file (
@@ -310,6 +377,27 @@
 	NATIVE_CHAR             prompt,
 	acpi_parse_object       *op);
 
+void
+acpi_db_display_help (
+	NATIVE_CHAR             *help_type);
+
+NATIVE_CHAR *
+acpi_db_get_next_token (
+	NATIVE_CHAR             *string,
+	NATIVE_CHAR             **next);
+
+u32
+acpi_db_get_line (
+	NATIVE_CHAR             *input_buffer);
+
+u32
+acpi_db_match_command (
+	NATIVE_CHAR             *user_command);
+
+void
+acpi_db_single_thread (
+	void);
+
 
 /*
  * dbstats - Generation and display of ACPI table statistics
@@ -324,6 +412,21 @@
 acpi_status
 acpi_db_display_statistics (
 	NATIVE_CHAR             *type_arg);
+
+acpi_status
+acpi_db_classify_one_object (
+	acpi_handle             obj_handle,
+	u32                     nesting_level,
+	void                    *context,
+	void                    **return_value);
+
+void
+acpi_db_count_namespace_objects (
+	void);
+
+void
+acpi_db_enumerate_object (
+	acpi_operand_object     *obj_desc);
 
 
 /*
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acdispat.h linux/drivers/acpi/include/acdispat.h
--- ../prev/linux/drivers/acpi/include/acdispat.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acdispat.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acdispat.h - dispatcher (parser to interpreter interface)
- *       $Revision: 52 $
+ *       $Revision: 54 $
  *
  *****************************************************************************/
 
@@ -58,6 +58,13 @@
 /* dsopcode - support for late evaluation */
 
 acpi_status
+acpi_ds_execute_arguments (
+	acpi_namespace_node     *node,
+	acpi_namespace_node     *scope_node,
+	u32                     aml_length,
+	u8                      *aml_start);
+
+acpi_status
 acpi_ds_get_buffer_field_arguments (
 	acpi_operand_object     *obj_desc);
 
@@ -73,6 +80,35 @@
 acpi_ds_get_package_arguments (
 	acpi_operand_object     *obj_desc);
 
+acpi_status
+acpi_ds_init_buffer_field (
+	u16                     aml_opcode,
+	acpi_operand_object     *obj_desc,
+	acpi_operand_object     *buffer_desc,
+	acpi_operand_object     *offset_desc,
+	acpi_operand_object     *length_desc,
+	acpi_operand_object     *result_desc);
+
+acpi_status
+acpi_ds_eval_buffer_field_operands (
+	acpi_walk_state         *walk_state,
+	acpi_parse_object       *op);
+
+acpi_status
+acpi_ds_eval_region_operands (
+	acpi_walk_state         *walk_state,
+	acpi_parse_object       *op);
+
+acpi_status
+acpi_ds_eval_data_object_operands (
+	acpi_walk_state         *walk_state,
+	acpi_parse_object       *op,
+	acpi_operand_object     *obj_desc);
+
+acpi_status
+acpi_ds_initialize_region (
+	acpi_handle             obj_handle);
+
 
 /* dsctrl - Parser/Interpreter interface, control stack routines */
 
@@ -109,6 +145,12 @@
 /* dsfield - Parser/Interpreter interface for AML fields */
 
 acpi_status
+acpi_ds_get_field_names (
+	ACPI_CREATE_FIELD_INFO  *info,
+	acpi_walk_state         *walk_state,
+	acpi_parse_object       *arg);
+
+acpi_status
 acpi_ds_create_field (
 	acpi_parse_object       *op,
 	acpi_namespace_node     *region_node,
@@ -180,7 +222,7 @@
 	acpi_walk_state         *walk_state,
 	acpi_operand_object     ***node);
 
-acpi_status
+void
 acpi_ds_method_data_delete_all (
 	acpi_walk_state         *walk_state);
 
@@ -201,7 +243,7 @@
 	acpi_walk_state         *walk_state,
 	acpi_operand_object     **dest_desc);
 
-acpi_status
+void
 acpi_ds_method_data_delete_value (
 	u16                     opcode,
 	u32                     index,
@@ -220,7 +262,7 @@
 	acpi_walk_state         *walk_state,
 	acpi_namespace_node     **node);
 
-acpi_status
+void
 acpi_ds_method_data_init (
 	acpi_walk_state         *walk_state);
 
@@ -306,29 +348,6 @@
 	acpi_walk_state         *walk_state,
 	acpi_namespace_node     *node,
 	acpi_parse_object       *op);
-
-
-/* dsregn - Parser/Interpreter interface - Op Region parsing */
-
-acpi_status
-acpi_ds_eval_buffer_field_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-acpi_status
-acpi_ds_eval_region_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op);
-
-acpi_status
-acpi_ds_eval_data_object_operands (
-	acpi_walk_state         *walk_state,
-	acpi_parse_object       *op,
-	acpi_operand_object     *obj_desc);
-
-acpi_status
-acpi_ds_initialize_region (
-	acpi_handle             obj_handle);
 
 
 /* dsutils - Parser/Interpreter interface utility routines */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acevents.h linux/drivers/acpi/include/acevents.h
--- ../prev/linux/drivers/acpi/include/acevents.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acevents.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acevents.h - Event subcomponent prototypes and defines
- *       $Revision: 76 $
+ *       $Revision: 79 $
  *
  *****************************************************************************/
 
@@ -65,7 +65,7 @@
 acpi_ev_acquire_global_lock(
 	u32                     timeout);
 
-void
+acpi_status
 acpi_ev_release_global_lock(
 	void);
 
@@ -116,7 +116,7 @@
  */
 
 acpi_status
-acpi_ev_install_default_address_space_handlers (
+acpi_ev_init_address_spaces (
 	void);
 
 acpi_status
@@ -125,7 +125,7 @@
 	u32                     function,
 	ACPI_PHYSICAL_ADDRESS   address,
 	u32                     bit_width,
-	acpi_integer            *value);
+	void                    *value);
 
 acpi_status
 acpi_ev_addr_handler_helper (
@@ -134,15 +134,15 @@
 	void                    *context,
 	void                    **return_value);
 
-void
-acpi_ev_disassociate_region_from_handler(
-	acpi_operand_object    *region_obj,
-	u8                      acpi_ns_is_locked);
-
 acpi_status
-acpi_ev_associate_region_and_handler (
+acpi_ev_attach_region (
 	acpi_operand_object     *handler_obj,
 	acpi_operand_object     *region_obj,
+	u8                      acpi_ns_is_locked);
+
+void
+acpi_ev_detach_region (
+	acpi_operand_object    *region_obj,
 	u8                      acpi_ns_is_locked);
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acexcep.h linux/drivers/acpi/include/acexcep.h
--- ../prev/linux/drivers/acpi/include/acexcep.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acexcep.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acexcep.h - Exception codes returned by the ACPI subsystem
- *       $Revision: 59 $
+ *       $Revision: 63 $
  *
  *****************************************************************************/
 
@@ -102,8 +102,9 @@
 #define AE_BAD_CHECKSUM                 (acpi_status) (0x0003 | AE_CODE_ACPI_TABLES)
 #define AE_BAD_VALUE                    (acpi_status) (0x0004 | AE_CODE_ACPI_TABLES)
 #define AE_TABLE_NOT_SUPPORTED          (acpi_status) (0x0005 | AE_CODE_ACPI_TABLES)
+#define AE_INVALID_TABLE_LENGTH         (acpi_status) (0x0006 | AE_CODE_ACPI_TABLES)
 
-#define AE_CODE_TBL_MAX                 0x0005
+#define AE_CODE_TBL_MAX                 0x0006
 
 
 /*
@@ -138,8 +139,11 @@
 #define AE_AML_INVALID_INDEX            (acpi_status) (0x001A | AE_CODE_AML)
 #define AE_AML_REGISTER_LIMIT           (acpi_status) (0x001B | AE_CODE_AML)
 #define AE_AML_NO_WHILE                 (acpi_status) (0x001C | AE_CODE_AML)
+#define AE_AML_ALIGNMENT                (acpi_status) (0x001D | AE_CODE_AML)
+#define AE_AML_NO_RESOURCE_END_TAG      (acpi_status) (0x001E | AE_CODE_AML)
+#define AE_AML_BAD_RESOURCE_VALUE       (acpi_status) (0x001F | AE_CODE_AML)
 
-#define AE_CODE_AML_MAX                 0x001C
+#define AE_CODE_AML_MAX                 0x001F
 
 /*
  * Internal exceptions used for control
@@ -215,7 +219,8 @@
 	"AE_BAD_HEADER",
 	"AE_BAD_CHECKSUM",
 	"AE_BAD_VALUE",
-	"AE_TABLE_NOT_SUPPORTED"
+	"AE_TABLE_NOT_SUPPORTED",
+	"AE_INVALID_TABLE_LENGTH"
 };
 
 NATIVE_CHAR const   *acpi_gbl_exception_names_aml[] =
@@ -247,7 +252,10 @@
 	"AE_AML_INVALID_RESOURCE_TYPE",
 	"AE_AML_INVALID_INDEX",
 	"AE_AML_REGISTER_LIMIT",
-	"AE_AML_NO_WHILE"
+	"AE_AML_NO_WHILE",
+	"AE_AML_ALIGNMENT",
+	"AE_AML_NO_RESOURCE_END_TAG",
+	"AE_AML_BAD_RESOURCE_VALUE"
 };
 
 NATIVE_CHAR const   *acpi_gbl_exception_names_ctrl[] =
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acglobal.h linux/drivers/acpi/include/acglobal.h
--- ../prev/linux/drivers/acpi/include/acglobal.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acglobal.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acglobal.h - Declarations for global variables
- *       $Revision: 121 $
+ *       $Revision: 125 $
  *
  *****************************************************************************/
 
@@ -80,6 +80,14 @@
 ACPI_EXTERN acpi_common_facs            acpi_gbl_common_fACS;
 
 /*
+ * Handle both ACPI 1.0 and ACPI 2.0 Integer widths
+ * If we are running a method that exists in a 32-bit ACPI table.
+ * Use only 32 bits of the Integer for conversion.
+ */
+ACPI_EXTERN u8                          acpi_gbl_integer_bit_width;
+ACPI_EXTERN u8                          acpi_gbl_integer_byte_width;
+
+/*
  * Since there may be multiple SSDTs and PSDTS, a single pointer is not
  * sufficient; Therefore, there isn't one!
  */
@@ -109,6 +117,7 @@
 ACPI_EXTERN ACPI_MEMORY_LIST            acpi_gbl_memory_lists[ACPI_NUM_MEM_LISTS];
 ACPI_EXTERN ACPI_OBJECT_NOTIFY_HANDLER  acpi_gbl_drv_notify;
 ACPI_EXTERN ACPI_OBJECT_NOTIFY_HANDLER  acpi_gbl_sys_notify;
+ACPI_EXTERN ACPI_INIT_HANDLER           acpi_gbl_init_handler;
 ACPI_EXTERN acpi_walk_state            *acpi_gbl_breakpoint_walk;
 ACPI_EXTERN acpi_handle                 acpi_gbl_global_lock_semaphore;
 
@@ -131,6 +140,7 @@
 extern u32                              acpi_gbl_startup_flags;
 extern const u8                         acpi_gbl_decode_to8bit[8];
 extern const NATIVE_CHAR                *acpi_gbl_db_sleep_states[ACPI_NUM_SLEEP_STATES];
+extern const acpi_opcode_info           acpi_gbl_aml_op_info[AML_NUM_OPCODES];
 
 
 /*****************************************************************************
@@ -186,7 +196,7 @@
  *
  ****************************************************************************/
 
-ACPI_EXTERN ACPI_BIT_REGISTER_INFO      acpi_gbl_bit_register_info[ACPI_NUM_BITREG];
+extern      ACPI_BIT_REGISTER_INFO      acpi_gbl_bit_register_info[ACPI_NUM_BITREG];
 ACPI_EXTERN u8                          acpi_gbl_sleep_type_a;
 ACPI_EXTERN u8                          acpi_gbl_sleep_type_b;
 
@@ -229,13 +239,11 @@
 
 #ifdef ENABLE_DEBUGGER
 
-ACPI_EXTERN u8                          acpi_gbl_method_executing;
-ACPI_EXTERN u8                          acpi_gbl_db_terminate_threads;
+extern      u8                          acpi_gbl_method_executing;
+extern      u8                          acpi_gbl_db_terminate_threads;
 
 ACPI_EXTERN int                         optind;
 ACPI_EXTERN NATIVE_CHAR                *optarg;
-ACPI_EXTERN u8                         *aml_start;
-ACPI_EXTERN u32                         aml_length;
 
 ACPI_EXTERN u8                          acpi_gbl_db_opt_tables;
 ACPI_EXTERN u8                          acpi_gbl_db_opt_disasm;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/achware.h linux/drivers/acpi/include/achware.h
--- ../prev/linux/drivers/acpi/include/achware.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/achware.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: achware.h -- hardware specific interfaces
- *       $Revision: 58 $
+ *       $Revision: 60 $
  *
  *****************************************************************************/
 
@@ -64,49 +64,44 @@
 acpi_hw_get_bit_register_info (
 	u32                     register_id);
 
-u32
-acpi_hw_bit_register_read (
-	u32                     register_id,
-	u32                     flags);
-
-u32
-acpi_hw_bit_register_write (
-	u32                     register_id,
-	u32                     value,
-	u32                     flags);
-
-u32
+acpi_status
 acpi_hw_register_read (
 	u8                      use_lock,
-	u32                     register_id);
+	u32                     register_id,
+	u32                     *return_value);
 
-void
+acpi_status
 acpi_hw_register_write (
 	u8                      use_lock,
 	u32                     register_id,
 	u32                     value);
 
-u32
+acpi_status
 acpi_hw_low_level_read (
 	u32                     width,
+	u32                     *value,
 	acpi_generic_address    *reg,
 	u32                     offset);
 
-void
+acpi_status
 acpi_hw_low_level_write (
 	u32                     width,
 	u32                     value,
 	acpi_generic_address    *reg,
 	u32                     offset);
 
-void
+acpi_status
 acpi_hw_clear_acpi_status (
    void);
 
 
 /* GPE support */
 
-void
+u8
+acpi_hw_get_gpe_bit_mask (
+	u32                     gpe_number);
+
+acpi_status
 acpi_hw_enable_gpe (
 	u32                     gpe_number);
 
@@ -114,7 +109,7 @@
 acpi_hw_enable_gpe_for_wakeup (
 	u32                     gpe_number);
 
-void
+acpi_status
 acpi_hw_disable_gpe (
 	u32                     gpe_number);
 
@@ -122,31 +117,22 @@
 acpi_hw_disable_gpe_for_wakeup (
 	u32                     gpe_number);
 
-void
+acpi_status
 acpi_hw_clear_gpe (
 	u32                     gpe_number);
 
-void
+acpi_status
 acpi_hw_get_gpe_status (
 	u32                     gpe_number,
 	acpi_event_status       *event_status);
 
-void
+acpi_status
 acpi_hw_disable_non_wakeup_gpes (
 	void);
 
-void
+acpi_status
 acpi_hw_enable_non_wakeup_gpes (
 	void);
-
-
-/* Sleep Prototypes */
-
-acpi_status
-acpi_hw_get_sleep_type_data (
-	u8                      sleep_state,
-	u8                      *slp_typ_a,
-	u8                      *slp_typ_b);
 
 
 /* ACPI Timer prototypes */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acinterp.h linux/drivers/acpi/include/acinterp.h
--- ../prev/linux/drivers/acpi/include/acinterp.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acinterp.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acinterp.h - Interpreter subcomponent prototypes and defines
- *       $Revision: 133 $
+ *       $Revision: 137 $
  *
  *****************************************************************************/
 
@@ -36,6 +36,11 @@
 	acpi_operand_object     **stack_ptr,
 	acpi_walk_state         *walk_state);
 
+acpi_status
+acpi_ex_check_object_type (
+	acpi_object_type        type_needed,
+	acpi_object_type        this_type,
+	void                    *object);
 
 /*
  * exxface - External interpreter interfaces
@@ -83,6 +88,11 @@
 	acpi_operand_object     **result_desc,
 	acpi_walk_state         *walk_state);
 
+u32
+acpi_ex_convert_to_ascii (
+	acpi_integer            integer,
+	u32                     base,
+	u8                      *string);
 
 /*
  * exfield - ACPI AML (p-code) execution - field manipulation
@@ -172,6 +182,12 @@
 acpi_ex_opcode_6A_0T_1R (
 	acpi_walk_state         *walk_state);
 
+u8
+acpi_ex_do_match (
+	u32                     match_op,
+	acpi_integer            package_value,
+	acpi_integer            match_value);
+
 acpi_status
 acpi_ex_get_object_reference (
 	acpi_operand_object     *obj_desc,
@@ -283,7 +299,7 @@
 	acpi_operand_object     *obj_desc,
 	acpi_walk_state         *walk_state);
 
-acpi_status
+void
 acpi_ex_release_all_mutexes (
 	ACPI_THREAD_STATE       *thread);
 
@@ -423,13 +439,6 @@
  */
 
 void
-acpi_ex_show_hex_value (
-	u32                     byte_count,
-	u8                      *aml_start,
-	u32                     lead_space);
-
-
-acpi_status
 acpi_ex_dump_operand (
 	acpi_operand_object     *entry_desc);
 
@@ -448,12 +457,31 @@
 	acpi_operand_object     *object,
 	u32                     flags);
 
-
 void
 acpi_ex_dump_node (
 	acpi_namespace_node     *node,
 	u32                     flags);
 
+void
+acpi_ex_out_string (
+	char                    *title,
+	char                    *value);
+
+void
+acpi_ex_out_pointer (
+	char                    *title,
+	void                    *value);
+
+void
+acpi_ex_out_integer (
+	char                    *title,
+	u32                     value);
+
+void
+acpi_ex_out_address (
+	char                    *title,
+	ACPI_PHYSICAL_ADDRESS   value);
+
 
 /*
  * exnames - interpreter/scanner name load/execute
@@ -586,7 +614,7 @@
 acpi_ex_acquire_global_lock (
 	u32                     rule);
 
-acpi_status
+void
 acpi_ex_release_global_lock (
 	u8                      locked);
 
@@ -595,12 +623,12 @@
 	acpi_integer            value,
 	u32                     base);
 
-acpi_status
+void
 acpi_ex_eisa_id_to_string (
 	u32                     numeric_id,
 	NATIVE_CHAR             *out_string);
 
-acpi_status
+void
 acpi_ex_unsigned_integer_to_string (
 	acpi_integer            value,
 	NATIVE_CHAR             *out_string);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/aclocal.h linux/drivers/acpi/include/aclocal.h
--- ../prev/linux/drivers/acpi/include/aclocal.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/aclocal.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: aclocal.h - Internal data types used across the ACPI subsystem
- *       $Revision: 162 $
+ *       $Revision: 167 $
  *
  *****************************************************************************/
 
@@ -37,23 +37,9 @@
 #define ACPI_LOGICAL_ADDRESSING         0x00
 #define ACPI_PHYSICAL_ADDRESSING        0x01
 
-/* Object descriptor types */
+/* Total number of aml opcodes defined */
 
-#define ACPI_CACHED_OBJECT              0x11    /* ORed in when object is cached */
-#define ACPI_DESC_TYPE_STATE            0x20
-#define ACPI_DESC_TYPE_STATE_UPDATE     0x21
-#define ACPI_DESC_TYPE_STATE_PACKAGE    0x22
-#define ACPI_DESC_TYPE_STATE_CONTROL    0x23
-#define ACPI_DESC_TYPE_STATE_RPSCOPE    0x24
-#define ACPI_DESC_TYPE_STATE_PSCOPE     0x25
-#define ACPI_DESC_TYPE_STATE_WSCOPE     0x26
-#define ACPI_DESC_TYPE_STATE_RESULT     0x27
-#define ACPI_DESC_TYPE_STATE_NOTIFY     0x28
-#define ACPI_DESC_TYPE_STATE_THREAD     0x29
-#define ACPI_DESC_TYPE_WALK             0x44
-#define ACPI_DESC_TYPE_PARSER           0x66
-#define ACPI_DESC_TYPE_INTERNAL         0x88
-#define ACPI_DESC_TYPE_NAMED            0xAA
+#define AML_NUM_OPCODES                 0x7E
 
 
 /*****************************************************************************
@@ -234,7 +220,7 @@
 	u8                      *aml_start;
 	u64                     physical_address;
 	u32                     aml_length;
-	u32                     length;
+	ACPI_SIZE               length;
 	u32                     count;
 	acpi_owner_id           table_id;
 	u8                      type;
@@ -411,8 +397,8 @@
 
 /* Forward declarations */
 struct acpi_walk_state;
-struct acpi_parse_obj;
 struct acpi_obj_mutex;
+union acpi_parse_obj;
 
 
 #define ACPI_STATE_COMMON                  /* Two 32-bit fields and a pointer */\
@@ -463,7 +449,7 @@
 typedef struct acpi_control_state
 {
 	ACPI_STATE_COMMON
-	struct acpi_parse_obj   *predicate_op;
+	union acpi_parse_obj    *predicate_op;
 	u8                      *aml_predicate_start;   /* Start of if/while predicate */
 	u8                      *package_end;           /* End of if/while block */
 	u16                     opcode;
@@ -485,7 +471,7 @@
 typedef struct acpi_pscope_state
 {
 	ACPI_STATE_COMMON
-	struct acpi_parse_obj   *op;                    /* current op being parsed */
+	union acpi_parse_obj    *op;                    /* current op being parsed */
 	u8                      *arg_end;               /* current argument end */
 	u8                      *pkg_end;               /* current package end */
 	u32                     arg_list;               /* next argument to parse */
@@ -526,7 +512,7 @@
 typedef
 acpi_status (*acpi_parse_downwards) (
 	struct acpi_walk_state  *walk_state,
-	struct acpi_parse_obj   **out_op);
+	union acpi_parse_obj    **out_op);
 
 typedef
 acpi_status (*acpi_parse_upwards) (
@@ -609,7 +595,7 @@
 	NATIVE_CHAR             *string;        /* NULL terminated string */
 	u8                      *buffer;        /* buffer or string */
 	NATIVE_CHAR             *name;          /* NULL terminated string */
-	struct acpi_parse_obj   *arg;           /* arguments and contained ops */
+	union acpi_parse_obj    *arg;           /* arguments and contained ops */
 
 } acpi_parse_value;
 
@@ -617,12 +603,12 @@
 #define ACPI_PARSE_COMMON \
 	u8                      data_type;      /* To differentiate various internal objs */\
 	u8                      flags;          /* Type of Op */\
-	u16                     opcode;         /* AML opcode */\
+	u16                     aml_opcode;     /* AML opcode */\
 	u32                     aml_offset;     /* offset of declaration in AML */\
-	struct acpi_parse_obj   *parent;        /* parent op */\
-	struct acpi_parse_obj   *next;          /* next op */\
+	union acpi_parse_obj    *parent;        /* parent op */\
+	union acpi_parse_obj    *next;          /* next op */\
 	ACPI_DEBUG_ONLY_MEMBERS (\
-	NATIVE_CHAR             op_name[16])    /* op name (debug only) */\
+	NATIVE_CHAR             aml_op_name[16]) /* op name (debug only) */\
 			  /* NON-DEBUG members below: */\
 	acpi_namespace_node     *node;          /* for use by interpreter */\
 	acpi_parse_value        value;          /* Value or args associated with the opcode */\
@@ -631,24 +617,68 @@
 /*
  * generic operation (eg. If, While, Store)
  */
-typedef struct acpi_parse_obj
+typedef struct acpi_parseobj_common
 {
 	ACPI_PARSE_COMMON
-} acpi_parse_object;
+} ACPI_PARSE_OBJ_COMMON;
 
 
 /*
  * Extended Op for named ops (Scope, Method, etc.), deferred ops (Methods and Op_regions),
  * and bytelists.
  */
-typedef struct acpi_parse2_obj
+typedef struct acpi_parseobj_named
 {
 	ACPI_PARSE_COMMON
 	u8                      *data;          /* AML body or bytelist data */
 	u32                     length;         /* AML length */
 	u32                     name;           /* 4-byte name or zero if no name */
 
-} acpi_parse2_object;
+} ACPI_PARSE_OBJ_NAMED;
+
+
+/* The parse node is the fundamental element of the parse tree */
+
+typedef struct acpi_parseobj_asl
+{
+	ACPI_PARSE_COMMON
+
+	union acpi_parse_obj        *child;
+
+
+	union acpi_parse_obj        *parent_method;
+	char                        *filename;
+	char                        *external_name;
+	char                        *namepath;
+	u32                         extra_value;
+	u32                         column;
+	u32                         line_number;
+	u32                         logical_line_number;
+	u32                         logical_byte_offset;
+	u32                         end_line;
+	u32                         end_logical_line;
+	u16                         parse_opcode;
+	u32                         acpi_btype;
+	u32                         aml_length;
+	u32                         aml_subtree_length;
+	u32                         final_aml_length;
+	u32                         final_aml_offset;
+	u8                          aml_opcode_length;
+	u8                          aml_pkg_len_bytes;
+	u16                         compile_flags;
+	u8                          extra;
+	char                        parse_op_name[12];
+
+} ACPI_PARSE_OBJ_ASL;
+
+
+typedef union acpi_parse_obj
+{
+	ACPI_PARSE_OBJ_COMMON       common;
+	ACPI_PARSE_OBJ_NAMED        named;
+	ACPI_PARSE_OBJ_ASL          asl;
+
+} acpi_parse_object;
 
 
 /*
@@ -663,10 +693,10 @@
 	u8                      *aml_end;       /* (last + 1) AML byte */
 	u8                      *pkg_start;     /* current package begin */
 	u8                      *pkg_end;       /* current package end */
-	struct acpi_parse_obj   *start_op;      /* root of parse tree */
+	union acpi_parse_obj    *start_op;      /* root of parse tree */
 	struct acpi_node        *start_node;
 	union acpi_gen_state    *scope;         /* current scope */
-	struct acpi_parse_obj   *start_scope;
+	union acpi_parse_obj    *start_scope;
 
 } acpi_parse_state;
 
@@ -712,38 +742,6 @@
 #define ACPI_REGISTER_SMI_COMMAND_BLOCK         0x09
 
 
-/*
- * Bit_register IDs
- * These are bitfields defined within the full ACPI registers
- */
-#define ACPI_BITREG_TIMER_STATUS                0x00
-#define ACPI_BITREG_BUS_MASTER_STATUS           0x01
-#define ACPI_BITREG_GLOBAL_LOCK_STATUS          0x02
-#define ACPI_BITREG_POWER_BUTTON_STATUS         0x03
-#define ACPI_BITREG_SLEEP_BUTTON_STATUS         0x04
-#define ACPI_BITREG_RT_CLOCK_STATUS             0x05
-#define ACPI_BITREG_WAKE_STATUS                 0x06
-
-#define ACPI_BITREG_TIMER_ENABLE                0x07
-#define ACPI_BITREG_GLOBAL_LOCK_ENABLE          0x08
-#define ACPI_BITREG_POWER_BUTTON_ENABLE         0x09
-#define ACPI_BITREG_SLEEP_BUTTON_ENABLE         0x0A
-#define ACPI_BITREG_RT_CLOCK_ENABLE             0x0B
-#define ACPI_BITREG_WAKE_ENABLE                 0x0C
-
-#define ACPI_BITREG_SCI_ENABLE                  0x0D
-#define ACPI_BITREG_BUS_MASTER_RLD              0x0E
-#define ACPI_BITREG_GLOBAL_LOCK_RELEASE         0x0F
-#define ACPI_BITREG_SLEEP_TYPE_A                0x10
-#define ACPI_BITREG_SLEEP_TYPE_B                0x11
-#define ACPI_BITREG_SLEEP_ENABLE                0x12
-
-#define ACPI_BITREG_ARB_DISABLE                 0x13
-
-#define ACPI_BITREG_MAX                         0x13
-#define ACPI_NUM_BITREG                         ACPI_BITREG_MAX + 1
-
-
 /* Masks used to access the Bit_registers */
 
 #define ACPI_BITMASK_TIMER_STATUS               0x0001
@@ -870,6 +868,7 @@
  ****************************************************************************/
 
 #define ACPI_ASCII_ZERO                      0x30
+
 
 /*****************************************************************************
  *
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acmacros.h linux/drivers/acpi/include/acmacros.h
--- ../prev/linux/drivers/acpi/include/acmacros.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acmacros.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acmacros.h - C macros for the entire subsystem.
- *       $Revision: 115 $
+ *       $Revision: 123 $
  *
  *****************************************************************************/
 
@@ -31,22 +31,23 @@
  * Data manipulation macros
  */
 
-#define ACPI_LOWORD(l)                  ((u16)(NATIVE_UINT)(l))
-#define ACPI_HIWORD(l)                  ((u16)((((NATIVE_UINT)(l)) >> 16) & 0xFFFF))
+#define ACPI_LOWORD(l)                  ((u16)(u32)(l))
+#define ACPI_HIWORD(l)                  ((u16)((((u32)(l)) >> 16) & 0xFFFF))
 #define ACPI_LOBYTE(l)                  ((u8)(u16)(l))
 #define ACPI_HIBYTE(l)                  ((u8)((((u16)(l)) >> 8) & 0xFF))
 
 
-#ifdef _IA16
+#if ACPI_MACHINE_WIDTH == 16
+
 /*
  * For 16-bit addresses, we have to assume that the upper 32 bits
  * are zero.
  */
-#define ACPI_LODWORD(l)                 (l)
-#define ACPI_HIDWORD(l)                 (0)
+#define ACPI_LODWORD(l)                 ((u32)(l))
+#define ACPI_HIDWORD(l)                 ((u32)(0))
 
 #define ACPI_GET_ADDRESS(a)             ((a).lo)
-#define ACPI_STORE_ADDRESS(a,b)         {(a).hi=0;(a).lo=(b);}
+#define ACPI_STORE_ADDRESS(a,b)         {(a).hi=0;(a).lo=(u32)(b);}
 #define ACPI_VALID_ADDRESS(a)           ((a).hi | (a).lo)
 
 #else
@@ -55,7 +56,7 @@
  * acpi_integer is 32-bits, no 64-bit support on this platform
  */
 #define ACPI_LODWORD(l)                 ((u32)(l))
-#define ACPI_HIDWORD(l)                 (0)
+#define ACPI_HIDWORD(l)                 ((u32)(0))
 
 #define ACPI_GET_ADDRESS(a)             (a)
 #define ACPI_STORE_ADDRESS(a,b)         ((a)=(b))
@@ -67,10 +68,10 @@
  * Full 64-bit address/integer on both 32-bit and 64-bit platforms
  */
 #define ACPI_LODWORD(l)                 ((u32)(u64)(l))
-#define ACPI_HIDWORD(l)                 ((u32)(((*(uint64_struct *)(&l))).hi))
+#define ACPI_HIDWORD(l)                 ((u32)(((*(uint64_struct *)(void *)(&l))).hi))
 
 #define ACPI_GET_ADDRESS(a)             (a)
-#define ACPI_STORE_ADDRESS(a,b)         ((a)=(b))
+#define ACPI_STORE_ADDRESS(a,b)         ((a)=(ACPI_PHYSICAL_ADDRESS)(b))
 #define ACPI_VALID_ADDRESS(a)           (a)
 #endif
 #endif
@@ -83,20 +84,23 @@
 
 /* Pointer arithmetic */
 
-#define ACPI_PTR_ADD(t,a,b)             (t *) ((char *)(a) + (b))
+#define ACPI_PTR_ADD(t,a,b)             (t *) (void *)((char *)(a) + (NATIVE_UINT)(b))
 #define ACPI_PTR_DIFF(a,b)              (NATIVE_UINT) ((char *)(a) - (char *)(b))
 
 /* Pointer/Integer type conversions */
 
-#define ACPI_TO_POINTER(i)              ACPI_PTR_ADD (void,NULL,(NATIVE_UINT)i)
-#define ACPI_TO_INTEGER(p)              ACPI_PTR_DIFF (p,NULL)
-#define ACPI_OFFSET(d,o)                ((ACPI_SIZE) ACPI_TO_INTEGER (&(((d *)0)->o)))
-#define ACPI_FADT_OFFSET(o)             ACPI_OFFSET (FADT_DESCRIPTOR, o)
+#define ACPI_TO_POINTER(i)              ACPI_PTR_ADD (void, (void *) NULL,(NATIVE_UINT)i)
+#define ACPI_TO_INTEGER(p)              ACPI_PTR_DIFF (p,(void *) NULL)
+#define ACPI_OFFSET(d,f)                (ACPI_SIZE) ACPI_PTR_DIFF (&(((d *)0)->f),(void *) NULL)
+#define ACPI_FADT_OFFSET(f)             ACPI_OFFSET (FADT_DESCRIPTOR, f)
 
+#define ACPI_CAST_PTR(t, p)             ((t *)(void *)(p))
+#define ACPI_CAST_INDIRECT_PTR(t, p)    ((t **)(void *)(p))
 
-#ifdef _IA16
+#if ACPI_MACHINE_WIDTH == 16
+#define ACPI_STORE_POINTER(d,s)         ACPI_MOVE_UNALIGNED32_TO_32(d,s)
 #define ACPI_PHYSADDR_TO_PTR(i)         (void *)(i)
-#define ACPI_PTR_TO_PHYSADDR(i)         (char *)(i)
+#define ACPI_PTR_TO_PHYSADDR(i)         (u32) (char *)(i)
 #else
 #define ACPI_PHYSADDR_TO_PTR(i)         ACPI_TO_POINTER(i)
 #define ACPI_PTR_TO_PHYSADDR(i)         ACPI_TO_INTEGER(i)
@@ -112,10 +116,10 @@
 
 /* The hardware supports unaligned transfers, just do the move */
 
-#define ACPI_MOVE_UNALIGNED16_TO_16(d,s)    *(u16 *)(d) = *(u16 *)(s)
-#define ACPI_MOVE_UNALIGNED32_TO_32(d,s)    *(u32 *)(d) = *(u32 *)(s)
-#define ACPI_MOVE_UNALIGNED16_TO_32(d,s)    *(u32 *)(d) = *(u16 *)(s)
-#define ACPI_MOVE_UNALIGNED64_TO_64(d,s)    *(u64 *)(d) = *(u64 *)(s)
+#define ACPI_MOVE_UNALIGNED16_TO_16(d,s)    *(u16 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_UNALIGNED32_TO_32(d,s)    *(u32 *)(void *)(d) = *(u32 *)(void *)(s)
+#define ACPI_MOVE_UNALIGNED16_TO_32(d,s)    *(u32 *)(void *)(d) = *(u16 *)(void *)(s)
+#define ACPI_MOVE_UNALIGNED64_TO_64(d,s)    *(u64 *)(void *)(d) = *(u64 *)(void *)(s)
 
 #else
 /*
@@ -124,24 +128,24 @@
  * the destination (or both) is/are unaligned.
  */
 
-#define ACPI_MOVE_UNALIGNED16_TO_16(d,s)    {((u8 *)(d))[0] = ((u8 *)(s))[0];\
-	  ((u8 *)(d))[1] = ((u8 *)(s))[1];}
+#define ACPI_MOVE_UNALIGNED16_TO_16(d,s)    {((u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+	  ((u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];}
 
-#define ACPI_MOVE_UNALIGNED32_TO_32(d,s)    {((u8 *)(d))[0] = ((u8 *)(s))[0];\
-			   ((u8 *)(d))[1] = ((u8 *)(s))[1];\
-			   ((u8 *)(d))[2] = ((u8 *)(s))[2];\
-			   ((u8 *)(d))[3] = ((u8 *)(s))[3];}
-
-#define ACPI_MOVE_UNALIGNED16_TO_32(d,s)    {(*(u32*)(d)) = 0; ACPI_MOVE_UNALIGNED16_TO_16(d,s);}
-
-#define ACPI_MOVE_UNALIGNED64_TO_64(d,s)    {((u8 *)(d))[0] = ((u8 *)(s))[0];\
-					 ((u8 *)(d))[1] = ((u8 *)(s))[1];\
-					 ((u8 *)(d))[2] = ((u8 *)(s))[2];\
-					 ((u8 *)(d))[3] = ((u8 *)(s))[3];\
-					 ((u8 *)(d))[4] = ((u8 *)(s))[4];\
-					 ((u8 *)(d))[5] = ((u8 *)(s))[5];\
-					 ((u8 *)(d))[6] = ((u8 *)(s))[6];\
-					 ((u8 *)(d))[7] = ((u8 *)(s))[7];}
+#define ACPI_MOVE_UNALIGNED32_TO_32(d,s)    {((u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+			   ((u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];\
+			   ((u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[2];\
+			   ((u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[3];}
+
+#define ACPI_MOVE_UNALIGNED16_TO_32(d,s)    {(*(u32*)(void *)(d)) = 0; ACPI_MOVE_UNALIGNED16_TO_16(d,s);}
+
+#define ACPI_MOVE_UNALIGNED64_TO_64(d,s)    {((u8 *)(void *)(d))[0] = ((u8 *)(void *)(s))[0];\
+					 ((u8 *)(void *)(d))[1] = ((u8 *)(void *)(s))[1];\
+					 ((u8 *)(void *)(d))[2] = ((u8 *)(void *)(s))[2];\
+					 ((u8 *)(void *)(d))[3] = ((u8 *)(void *)(s))[3];\
+					 ((u8 *)(void *)(d))[4] = ((u8 *)(void *)(s))[4];\
+					 ((u8 *)(void *)(d))[5] = ((u8 *)(void *)(s))[5];\
+					 ((u8 *)(void *)(d))[6] = ((u8 *)(void *)(s))[6];\
+					 ((u8 *)(void *)(d))[7] = ((u8 *)(void *)(s))[7];}
 
 #endif
 
@@ -174,8 +178,8 @@
 /*
  * Rounding macros (Power of two boundaries only)
  */
-#define ACPI_ROUND_DOWN(value,boundary)      (((NATIVE_UINT)(value)) & (~((boundary)-1)))
-#define ACPI_ROUND_UP(value,boundary)        ((((NATIVE_UINT)(value)) + ((boundary)-1)) & (~((boundary)-1)))
+#define ACPI_ROUND_DOWN(value,boundary)      (((NATIVE_UINT)(value)) & (~(((NATIVE_UINT) boundary)-1)))
+#define ACPI_ROUND_UP(value,boundary)        ((((NATIVE_UINT)(value)) + (((NATIVE_UINT) boundary)-1)) & (~(((NATIVE_UINT) boundary)-1)))
 
 #define ACPI_ROUND_DOWN_TO_32_BITS(a)        ACPI_ROUND_DOWN(a,4)
 #define ACPI_ROUND_DOWN_TO_64_BITS(a)        ACPI_ROUND_DOWN(a,8)
@@ -201,22 +205,33 @@
  * MASK_BITS_ABOVE creates a mask starting AT the position and above
  * MASK_BITS_BELOW creates a mask starting one bit BELOW the position
  */
-#define ACPI_MASK_BITS_ABOVE(position)       (~(((acpi_integer)(-1)) << ((u32) (position))))
-#define ACPI_MASK_BITS_BELOW(position)       (((acpi_integer)(-1)) << ((u32) (position)))
+#define ACPI_MASK_BITS_ABOVE(position)       (~((ACPI_INTEGER_MAX) << ((u32) (position))))
+#define ACPI_MASK_BITS_BELOW(position)       ((ACPI_INTEGER_MAX) << ((u32) (position)))
 
 #define ACPI_IS_OCTAL_DIGIT(d)               (((char)(d) >= '0') && ((char)(d) <= '7'))
 
 /* Macros for GAS addressing */
 
-#ifndef _IA16
+#if ACPI_MACHINE_WIDTH != 16
 
 #define ACPI_PCI_DEVICE_MASK            (u64) 0x0000FFFF00000000
 #define ACPI_PCI_FUNCTION_MASK          (u64) 0x00000000FFFF0000
 #define ACPI_PCI_REGISTER_MASK          (u64) 0x000000000000FFFF
 
-#define ACPI_PCI_FUNCTION(a)            (u16) ((((a) & ACPI_PCI_FUNCTION_MASK) >> 16))
-#define ACPI_PCI_DEVICE(a)              (u16) ((((a) & ACPI_PCI_DEVICE_MASK) >> 32))
-#define ACPI_PCI_REGISTER(a)            (u16) (((a) & ACPI_PCI_REGISTER_MASK))
+/*
+ * Obsolete
+ */
+
+/*
+#define ACPI_PCI_FUNCTION(a)            (u16) ((((u64)((u64)(a) & ACPI_PCI_FUNCTION_MASK)) >> 16))
+#define ACPI_PCI_DEVICE(a)              (u16) ((((u64)((u64)(a) & ACPI_PCI_DEVICE_MASK)) >> 32))
+#define ACPI_PCI_REGISTER(a)            (u16) (((u64)((u64)(a) & ACPI_PCI_REGISTER_MASK)))
+*/
+
+
+#define ACPI_PCI_DEVICE(a)              (u16) ((ACPI_HIDWORD ((a))) & 0x0000FFFF)
+#define ACPI_PCI_FUNCTION(a)            (u16) ((ACPI_LODWORD ((a))) >> 16)
+#define ACPI_PCI_REGISTER(a)            (u16) ((ACPI_LODWORD ((a))) & 0x0000FFFF)
 
 #else
 
@@ -241,13 +256,13 @@
  *
  * The "Descriptor" field is the first field in both structures.
  */
-#define ACPI_GET_DESCRIPTOR_TYPE(d)     (((acpi_namespace_node *)d)->descriptor)
-#define ACPI_SET_DESCRIPTOR_TYPE(d,t)   (((acpi_namespace_node *)d)->descriptor = t)
+#define ACPI_GET_DESCRIPTOR_TYPE(d)     (((ACPI_DESCRIPTOR *)(void *)(d))->descriptor_id)
+#define ACPI_SET_DESCRIPTOR_TYPE(d,t)   (((ACPI_DESCRIPTOR *)(void *)(d))->descriptor_id = t)
 
 
 /* Macro to test the object type */
 
-#define ACPI_GET_OBJECT_TYPE(d)         (((acpi_operand_object *)d)->common.type)
+#define ACPI_GET_OBJECT_TYPE(d)         (((acpi_operand_object *)(void *)d)->common.type)
 
 /* Macro to check the table flags for SINGLE or MULTIPLE tables are allowed */
 
@@ -259,7 +274,7 @@
  * as a pointer to an acpi_table_header.  (b+1) then points past the header,
  * and ((u8 *)b+b->Length) points one byte past the end of the table.
  */
-#ifndef _IA16
+#if ACPI_MACHINE_WIDTH != 16
 #define ACPI_IS_IN_ACPI_TABLE(a,b)      (((u8 *)(a) >= (u8 *)(b + 1)) &&\
 							 ((u8 *)(a) < ((u8 *)b + b->length)))
 
@@ -272,7 +287,7 @@
 /*
  * Macros for the master AML opcode table
  */
-#ifdef ACPI_DEBUG
+#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
 #define ACPI_OP(name,Pargs,Iargs,obj_type,class,type,flags)    {name,Pargs,Iargs,flags,obj_type,class,type}
 #else
 #define ACPI_OP(name,Pargs,Iargs,obj_type,class,type,flags)    {Pargs,Iargs,flags,obj_type,class,type}
@@ -317,7 +332,7 @@
 											 a.register_bit_width = (u8) ACPI_MUL_8 (b);\
 											 a.register_bit_offset = 0;\
 											 a.reserved = 0;\
-											 ACPI_STORE_ADDRESS (a.address,c);}
+											 ACPI_STORE_ADDRESS (a.address,(ACPI_PHYSICAL_ADDRESS) c);}
 
 /* ACPI V1.0 entries -- address space is always I/O */
 
@@ -402,11 +417,16 @@
  * One of the FUNCTION_TRACE macros above must be used in conjunction with these macros
  * so that "_Proc_name" is defined.
  */
-#define return_VOID                     {acpi_ut_exit(__LINE__,&_dbg);return;}
-#define return_ACPI_STATUS(s)           {acpi_ut_status_exit(__LINE__,&_dbg,s);return(s);}
-#define return_VALUE(s)                 {acpi_ut_value_exit(__LINE__,&_dbg,s);return(s);}
-#define return_PTR(s)                   {acpi_ut_ptr_exit(__LINE__,&_dbg,(u8 *)s);return(s);}
+#ifdef ACPI_USE_DO_WHILE_0
+#define ACPI_DO_WHILE0(a)               do a while(0)
+#else
+#define ACPI_DO_WHILE0(a)               a
+#endif
 
+#define return_VOID                     ACPI_DO_WHILE0 ({acpi_ut_exit(__LINE__,&_dbg);return;})
+#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({acpi_ut_status_exit(__LINE__,&_dbg,(s));return((s));})
+#define return_VALUE(s)                 ACPI_DO_WHILE0 ({acpi_ut_value_exit(__LINE__,&_dbg,(acpi_integer)(s));return((s));})
+#define return_PTR(s)                   ACPI_DO_WHILE0 ({acpi_ut_ptr_exit(__LINE__,&_dbg,(u8 *)(s));return((s));})
 
 /* Conditional execution */
 
@@ -427,7 +447,7 @@
 
 #define ACPI_DUMP_ENTRY(a,b)            acpi_ns_dump_entry (a,b)
 #define ACPI_DUMP_TABLES(a,b)           acpi_ns_dump_tables(a,b)
-#define ACPI_DUMP_PATHNAME(a,b,c,d)     acpi_ns_dump_pathname(a,b,c,d)
+#define ACPI_DUMP_PATHNAME(a,b,c,d)     (void) acpi_ns_dump_pathname(a,b,c,d)
 #define ACPI_DUMP_RESOURCE_LIST(a)      acpi_rs_dump_resource_list(a)
 #define ACPI_DUMP_BUFFER(a,b)           acpi_ut_dump_buffer((u8 *)a,b,DB_BYTE_DISPLAY,_COMPONENT)
 #define ACPI_BREAK_MSG(a)               acpi_os_signal (ACPI_SIGNAL_BREAKPOINT,(a))
@@ -495,6 +515,10 @@
 #define return_VALUE(s)                 return(s)
 #define return_PTR(s)                   return(s)
 
+#ifdef ENABLE_DEBUGGER
+#define _OPCODE_NAMES
+#endif
+
 #endif
 
 /*
@@ -513,7 +537,7 @@
  * For 16-bit code, we want to shrink some things even though
  * we are using ACPI_DEBUG to get the debug output
  */
-#ifdef _IA16
+#if ACPI_MACHINE_WIDTH == 16
 #undef ACPI_DEBUG_ONLY_MEMBERS
 #undef _VERBOSE_STRUCTURES
 #define ACPI_DEBUG_ONLY_MEMBERS(a)
@@ -541,8 +565,8 @@
 
 /* Memory allocation */
 
-#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate(a,_COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate(a, _COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate((ACPI_SIZE)(a),_COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate((ACPI_SIZE)(a), _COMPONENT,_THIS_MODULE,__LINE__)
 #define ACPI_MEM_FREE(a)                acpi_os_free(a)
 #define ACPI_MEM_TRACKING(a)
 
@@ -551,8 +575,8 @@
 
 /* Memory allocation */
 
-#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate_and_track(a,_COMPONENT,_THIS_MODULE,__LINE__)
-#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate_and_track(a, _COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_ALLOCATE(a)            acpi_ut_allocate_and_track((ACPI_SIZE)(a),_COMPONENT,_THIS_MODULE,__LINE__)
+#define ACPI_MEM_CALLOCATE(a)           acpi_ut_callocate_and_track((ACPI_SIZE)(a), _COMPONENT,_THIS_MODULE,__LINE__)
 #define ACPI_MEM_FREE(a)                acpi_ut_free_and_track(a,_COMPONENT,_THIS_MODULE,__LINE__)
 #define ACPI_MEM_TRACKING(a)            a
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acnamesp.h linux/drivers/acpi/include/acnamesp.h
--- ../prev/linux/drivers/acpi/include/acnamesp.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acnamesp.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acnamesp.h - Namespace subcomponent prototypes and defines
- *       $Revision: 123 $
+ *       $Revision: 125 $
  *
  *****************************************************************************/
 
@@ -108,7 +108,7 @@
 	acpi_namespace_node     *parent,
 	acpi_namespace_node     *child);
 
-acpi_status
+void
 acpi_ns_delete_namespace_by_owner (
 	u16                     table_id);
 
@@ -139,7 +139,6 @@
  * Top-level namespace access - nsaccess
  */
 
-
 acpi_status
 acpi_ns_root_initialize (
 	void);
@@ -159,7 +158,6 @@
  * Named object allocation/deallocation - nsalloc
  */
 
-
 acpi_namespace_node *
 acpi_ns_create_node (
 	u32                     name);
@@ -168,7 +166,7 @@
 acpi_ns_delete_node (
 	acpi_namespace_node     *node);
 
-acpi_status
+void
 acpi_ns_delete_namespace_subtree (
 	acpi_namespace_node     *parent_handle);
 
@@ -220,10 +218,24 @@
 	u32                     num_segments,
 	char                    *pathname);
 
+acpi_status
+acpi_ns_dump_one_device (
+	acpi_handle             obj_handle,
+	u32                     level,
+	void                    *context,
+	void                    **return_value);
+
 void
 acpi_ns_dump_root_devices (
 	void);
 
+acpi_status
+acpi_ns_dump_one_object (
+	acpi_handle             obj_handle,
+	u32                     level,
+	void                    *context,
+	void                    **return_value);
+
 void
 acpi_ns_dump_objects (
 	acpi_object_type        type,
@@ -289,6 +301,12 @@
 acpi_ns_opens_scope (
 	acpi_object_type        type);
 
+void
+acpi_ns_build_external_path (
+	acpi_namespace_node     *node,
+	ACPI_SIZE               size,
+	NATIVE_CHAR             *name_buffer);
+
 NATIVE_CHAR *
 acpi_ns_get_external_pathname (
 	acpi_namespace_node     *node);
@@ -408,7 +426,7 @@
 acpi_ns_build_internal_name (
 	acpi_namestring_info    *info);
 
-acpi_status
+void
 acpi_ns_get_internal_name_length (
 	acpi_namestring_info    *info);
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acobject.h linux/drivers/acpi/include/acobject.h
--- ../prev/linux/drivers/acpi/include/acobject.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acobject.h	Fri May 31 11:41:57 2002
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Name: acobject.h - Definition of acpi_operand_object  (Internal object only)
- *       $Revision: 110 $
+ *       $Revision: 111 $
  *
  *****************************************************************************/
 
@@ -481,5 +481,42 @@
 	ACPI_OBJECT_CACHE_LIST      cache;
 
 } acpi_operand_object;
+
+
+/******************************************************************************
+ *
+ * ACPI_DESCRIPTOR - objects that share a common descriptor identifier
+ *
+ *****************************************************************************/
+
+
+/* Object descriptor types */
+
+#define ACPI_DESC_TYPE_CACHED           0x11    /* Used only when object is cached */
+#define ACPI_DESC_TYPE_STATE            0x20
+#define ACPI_DESC_TYPE_STATE_UPDATE     0x21
+#define ACPI_DESC_TYPE_STATE_PACKAGE    0x22
+#define ACPI_DESC_TYPE_STATE_CONTROL    0x23
+#define ACPI_DESC_TYPE_STATE_RPSCOPE    0x24
+#define ACPI_DESC_TYPE_STATE_PSCOPE     0x25
+#define ACPI_DESC_TYPE_STATE_WSCOPE     0x26
+#define ACPI_DESC_TYPE_STATE_RESULT     0x27
+#define ACPI_DESC_TYPE_STATE_NOTIFY     0x28
+#define ACPI_DESC_TYPE_STATE_THREAD     0x29
+#define ACPI_DESC_TYPE_WALK             0x44
+#define ACPI_DESC_TYPE_PARSER           0x66
+#define ACPI_DESC_TYPE_OPERAND          0x88
+#define ACPI_DESC_TYPE_NAMED            0xAA
+
+
+typedef union acpi_desc
+{
+	u8                          descriptor_id;        /* To differentiate various internal objs */\
+	acpi_operand_object         object;
+	acpi_namespace_node         node;
+	acpi_parse_object           op;
+
+} ACPI_DESCRIPTOR;
+
 
 #endif /* _ACOBJECT_H */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acparser.h linux/drivers/acpi/include/acparser.h
--- ../prev/linux/drivers/acpi/include/acparser.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acparser.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: acparser.h - AML Parser subcomponent prototypes and defines
- *       $Revision: 58 $
+ *       $Revision: 59 $
  *
  *****************************************************************************/
 
@@ -134,7 +134,7 @@
 acpi_ps_get_opcode_size (
 	u32                     opcode);
 
-u8
+void
 acpi_ps_complete_this_op (
 	acpi_walk_state         *walk_state,
 	acpi_parse_object       *op);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acpixf.h linux/drivers/acpi/include/acpixf.h
--- ../prev/linux/drivers/acpi/include/acpixf.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acpixf.h	Fri May 31 11:41:57 2002
@@ -71,6 +71,10 @@
 acpi_purge_cached_objects (
 	void);
 
+acpi_status
+acpi_install_initialization_handler (
+	ACPI_INIT_HANDLER       handler,
+	u32                     function);
 
 /*
  * ACPI Memory manager
@@ -330,6 +334,18 @@
  */
 
 acpi_status
+acpi_get_register (
+	u32                     register_id,
+	u32                     *return_value,
+	u32                     flags);
+
+acpi_status
+acpi_set_register (
+	u32                     register_id,
+	u32                     value,
+	u32                     flags);
+
+acpi_status
 acpi_set_firmware_waking_vector (
 	ACPI_PHYSICAL_ADDRESS   physical_address);
 
@@ -337,17 +353,23 @@
 acpi_get_firmware_waking_vector (
 	ACPI_PHYSICAL_ADDRESS   *physical_address);
 
+acpi_status
+acpi_get_sleep_type_data (
+	u8                      sleep_state,
+	u8                      *slp_typ_a,
+	u8                      *slp_typ_b);
 
 acpi_status
 acpi_enter_sleep_state_prep (
-	u8 sleep_state);
+	u8                      sleep_state);
 
 acpi_status
 acpi_enter_sleep_state (
-	u8 sleep_state);
+	u8                      sleep_state);
 
 acpi_status
 acpi_leave_sleep_state (
-	u8 sleep_state);
+	u8                      sleep_state);
+
 
 #endif /* __ACXFACE_H__ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acresrc.h linux/drivers/acpi/include/acresrc.h
--- ../prev/linux/drivers/acpi/include/acresrc.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acresrc.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acresrc.h - Resource Manager function prototypes
- *       $Revision: 30 $
+ *       $Revision: 33 $
  *
  *****************************************************************************/
 
@@ -69,8 +69,59 @@
 
 
 /*
- *Function prototypes called from Acpi_rs_create*
+ * Function prototypes called from Acpi_rs_create*
  */
+void
+acpi_rs_dump_irq (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_address16 (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_address32 (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_address64 (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_dma (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_io (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_extended_irq (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_fixed_io (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_fixed_memory32 (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_memory24 (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_memory32 (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_start_depend_fns (
+	acpi_resource_data      *data);
+
+void
+acpi_rs_dump_vendor_specific (
+	acpi_resource_data      *data);
 
 void
 acpi_rs_dump_resource_list (
@@ -87,18 +138,18 @@
 	u32                     *size);
 
 acpi_status
-acpi_rs_calculate_list_length (
+acpi_rs_get_list_length (
 	u8                      *byte_stream_buffer,
 	u32                     byte_stream_buffer_length,
 	ACPI_SIZE               *size_needed);
 
 acpi_status
-acpi_rs_calculate_byte_stream_length (
+acpi_rs_get_byte_stream_length (
 	acpi_resource           *linked_list_buffer,
 	ACPI_SIZE               *size_needed);
 
 acpi_status
-acpi_rs_calculate_pci_routing_table_length (
+acpi_rs_get_pci_routing_table_length (
 	acpi_operand_object     *package_object,
 	ACPI_SIZE               *buffer_size_needed);
 
@@ -111,7 +162,7 @@
 acpi_status
 acpi_rs_list_to_byte_stream (
 	acpi_resource           *linked_list,
-	u32                     byte_stream_size_needed,
+	ACPI_SIZE               byte_stream_size_needed,
 	u8                      *output_buffer);
 
 acpi_status
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acstruct.h linux/drivers/acpi/include/acstruct.h
--- ../prev/linux/drivers/acpi/include/acstruct.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acstruct.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acstruct.h - Internal structs
- *       $Revision: 17 $
+ *       $Revision: 19 $
  *
  *****************************************************************************/
 
@@ -39,12 +39,14 @@
  * the tree (for whatever reason), and for control method execution.
  */
 
-#define ACPI_NEXT_OP_DOWNWARD    1
-#define ACPI_NEXT_OP_UPWARD      2
+#define ACPI_NEXT_OP_DOWNWARD       1
+#define ACPI_NEXT_OP_UPWARD         2
 
-#define ACPI_WALK_NON_METHOD     0
-#define ACPI_WALK_METHOD         1
-#define ACPI_WALK_METHOD_RESTART 2
+#define ACPI_WALK_NON_METHOD        0
+#define ACPI_WALK_METHOD            1
+#define ACPI_WALK_METHOD_RESTART    2
+#define ACPI_WALK_CONST_REQUIRED    3
+#define ACPI_WALK_CONST_OPTIONAL    4
 
 typedef struct acpi_walk_state
 {
@@ -102,6 +104,7 @@
 typedef struct acpi_init_walk_info
 {
 	u16                     method_count;
+	u16                     device_count;
 	u16                     op_region_count;
 	u16                     field_count;
 	u16                     buffer_count;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/actables.h linux/drivers/acpi/include/actables.h
--- ../prev/linux/drivers/acpi/include/actables.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/actables.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: actables.h - ACPI table management
- *       $Revision: 36 $
+ *       $Revision: 41 $
  *
  *****************************************************************************/
 
@@ -63,6 +63,15 @@
  * tbget - Table "get" routines
  */
 
+void
+acpi_tb_table_override (
+	acpi_table_desc         *table_info);
+
+acpi_status
+acpi_tb_get_table_with_override (
+	ACPI_POINTER            *address,
+	acpi_table_desc         *table_info);
+
 acpi_status
 acpi_tb_get_table_ptr (
 	acpi_table_type         table_type,
@@ -90,7 +99,7 @@
 acpi_tb_get_table_pointer (
 	ACPI_POINTER            *address,
 	u32                     flags,
-	u32                     *size,
+	ACPI_SIZE               *size,
 	acpi_table_header       **table_ptr);
 
 /*
@@ -99,8 +108,7 @@
 
 acpi_status
 acpi_tb_get_all_tables (
-	u32                     number_of_tables,
-	acpi_table_header       *buffer_ptr);
+	u32                     number_of_tables);
 
 
 /*
@@ -109,7 +117,6 @@
 
 acpi_status
 acpi_tb_install_table (
-	acpi_table_header       *table_ptr,
 	acpi_table_desc         *table_info);
 
 acpi_status
@@ -119,7 +126,6 @@
 
 acpi_status
 acpi_tb_recognize_table (
-	acpi_table_header       *table_ptr,
 	acpi_table_desc         *table_info);
 
 acpi_status
@@ -186,7 +192,7 @@
 acpi_status
 acpi_tb_map_acpi_table (
 	ACPI_PHYSICAL_ADDRESS   physical_address,
-	u32                     *size,
+	ACPI_SIZE               *size,
 	acpi_table_header       **logical_address);
 
 acpi_status
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/actypes.h linux/drivers/acpi/include/actypes.h
--- ../prev/linux/drivers/acpi/include/actypes.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/actypes.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: actypes.h - Common data types for the entire ACPI subsystem
- *       $Revision: 226 $
+ *       $Revision: 237 $
  *
  *****************************************************************************/
 
@@ -28,13 +28,23 @@
 
 /*! [Begin] no source code translation (keep the typedefs) */
 
+
+
+/*
+ * Data type ranges
+ */
+#define ACPI_UINT8_MAX                  (UINT8)  0xFF
+#define ACPI_UINT16_MAX                 (UINT16) 0xFFFF
+#define ACPI_UINT32_MAX                 (UINT32) 0xFFFFFFFF
+#define ACPI_UINT64_MAX                 (UINT64) 0xFFFFFFFFFFFFFFFF
+#define ACPI_ASCII_MAX                  0x7F
+
+
+
 /*
  * Data types - Fixed across all compilation models
  *
  * BOOLEAN      Logical Boolean.
- *              1 byte value containing a 0 for FALSE or a 1 for TRUE.
- *              Other values are undefined.
- *
  * INT8         8-bit  (1 byte) signed value
  * UINT8        8-bit  (1 byte) unsigned value
  * INT16        16-bit (2 byte) signed value
@@ -47,8 +57,11 @@
  * NATIVE_UINT  32-bit on IA-32, 64-bit on IA-64 unsigned value
  */
 
+#ifndef ACPI_MACHINE_WIDTH
+#error ACPI_MACHINE_WIDTH not defined
+#endif
 
-#ifdef _IA64
+#if ACPI_MACHINE_WIDTH == 64
 /*
  * 64-bit type definitions
  */
@@ -57,10 +70,14 @@
 typedef unsigned short                  UINT16;
 typedef int                             INT32;
 typedef unsigned int                    UINT32;
+typedef COMPILER_DEPENDENT_INT64        INT64;
 typedef COMPILER_DEPENDENT_UINT64       UINT64;
 
+typedef INT64                           NATIVE_INT;
 typedef UINT64                          NATIVE_UINT;
-typedef UINT64                          NATIVE_INT;
+
+typedef UINT32                          NATIVE_UINT_MAX32;
+typedef UINT64                          NATIVE_UINT_MIN32;
 
 typedef UINT64                          ACPI_TBLPTR;
 typedef UINT64                          ACPI_IO_ADDRESS;
@@ -69,10 +86,11 @@
 
 #define ALIGNED_ADDRESS_BOUNDARY        0x00000008      /* No hardware alignment support in IA64 */
 #define ACPI_USE_NATIVE_DIVIDE                          /* Native 64-bit integer support */
-#define ACPI_MAX_PTR                    0xFFFFFFFFFFFFFFFF
+#define ACPI_MAX_PTR                    ACPI_UINT64_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT64_MAX
 
 
-#elif _IA16
+#elif ACPI_MACHINE_WIDTH == 16
 /*
  * 16-bit type definitions
  */
@@ -93,15 +111,19 @@
 typedef UINT16                          NATIVE_UINT;
 typedef INT16                           NATIVE_INT;
 
+typedef UINT16                          NATIVE_UINT_MAX32;
+typedef UINT32                          NATIVE_UINT_MIN32;
+
 typedef UINT32                          ACPI_TBLPTR;
 typedef UINT32                          ACPI_IO_ADDRESS;
 typedef char                            *ACPI_PHYSICAL_ADDRESS;
-typedef UINT32                          ACPI_SIZE;
+typedef UINT16                          ACPI_SIZE;
 
 #define ALIGNED_ADDRESS_BOUNDARY        0x00000002
 #define _HW_ALIGNMENT_SUPPORT
 #define ACPI_USE_NATIVE_DIVIDE                          /* No 64-bit integers, ok to use native divide */
-#define ACPI_MAX_PTR                    0xFFFF
+#define ACPI_MAX_PTR                    ACPI_UINT16_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT16_MAX
 
 /*
  * (16-bit only) internal integers must be 32-bits, so
@@ -110,7 +132,7 @@
 #define ACPI_NO_INTEGER64_SUPPORT
 
 
-#else
+#elif ACPI_MACHINE_WIDTH == 32
 /*
  * 32-bit type definitions (default)
  */
@@ -119,10 +141,14 @@
 typedef unsigned short                  UINT16;
 typedef int                             INT32;
 typedef unsigned int                    UINT32;
+typedef COMPILER_DEPENDENT_INT64        INT64;
 typedef COMPILER_DEPENDENT_UINT64       UINT64;
 
-typedef UINT32                          NATIVE_UINT;
 typedef INT32                           NATIVE_INT;
+typedef UINT32                          NATIVE_UINT;
+
+typedef UINT32                          NATIVE_UINT_MAX32;
+typedef UINT32                          NATIVE_UINT_MIN32;
 
 typedef UINT64                          ACPI_TBLPTR;
 typedef UINT32                          ACPI_IO_ADDRESS;
@@ -131,9 +157,12 @@
 
 #define ALIGNED_ADDRESS_BOUNDARY        0x00000004
 #define _HW_ALIGNMENT_SUPPORT
-#define ACPI_MAX_PTR                    0xFFFFFFFF
-#endif
+#define ACPI_MAX_PTR                    ACPI_UINT32_MAX
+#define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
+#else
+#error unknown ACPI_MACHINE_WIDTH
+#endif
 
 
 /*
@@ -145,16 +174,6 @@
 typedef char                            NATIVE_CHAR;
 
 
-/*
- * Data type ranges
- */
-#define ACPI_UINT8_MAX                  (UINT8)  0xFF
-#define ACPI_UINT16_MAX                 (UINT16) 0xFFFF
-#define ACPI_UINT32_MAX                 (UINT32) 0xFFFFFFFF
-#define ACPI_UINT64_MAX                 (UINT64) 0xFFFFFFFFFFFFFFFF
-#define ACPI_ASCII_MAX                  0x7F
-
-
 #ifdef DEFINE_ALTERNATE_TYPES
 /*
  * Types used only in translated source, defined here to enable
@@ -173,7 +192,7 @@
  * Pointer overlays to avoid lots of typecasting for
  * code that accepts both physical and logical pointers.
  */
-typedef union acpi_pointers
+typedef union acpi_ptrs
 {
 	ACPI_PHYSICAL_ADDRESS       physical;
 	void                        *logical;
@@ -184,7 +203,7 @@
 typedef struct acpi_pointer
 {
 	u32                         pointer_type;
-	ACPI_POINTERS               pointer;
+	union acpi_ptrs             pointer;
 
 } ACPI_POINTER;
 
@@ -236,6 +255,13 @@
 
 } uint64_overlay;
 
+typedef struct
+{
+	u32                         lo;
+	u32                         hi;
+
+} UINT32_STRUCT;
+
 
 /*
  * Acpi integer width. In ACPI version 1, integers are
@@ -269,7 +295,7 @@
 #define ACPI_MAX_BCD_DIGITS             16
 #define ACPI_MAX_DECIMAL_DIGITS         19
 
-#ifdef _IA64
+#if ACPI_MACHINE_WIDTH == 64
 #define ACPI_USE_NATIVE_DIVIDE          /* Use compiler native 64-bit divide */
 #endif
 #endif
@@ -279,7 +305,7 @@
  * Constants with special meanings
  */
 
-#define ACPI_ROOT_OBJECT                (acpi_handle) ACPI_PTR_ADD (char, NULL, ACPI_UINT32_MAX)
+#define ACPI_ROOT_OBJECT                (acpi_handle) ACPI_PTR_ADD (char, NULL, ACPI_MAX_PTR)
 
 
 /*
@@ -560,6 +586,37 @@
 
 
 /*
+ * Bit_register IDs
+ * These are bitfields defined within the full ACPI registers
+ */
+#define ACPI_BITREG_TIMER_STATUS                0x00
+#define ACPI_BITREG_BUS_MASTER_STATUS           0x01
+#define ACPI_BITREG_GLOBAL_LOCK_STATUS          0x02
+#define ACPI_BITREG_POWER_BUTTON_STATUS         0x03
+#define ACPI_BITREG_SLEEP_BUTTON_STATUS         0x04
+#define ACPI_BITREG_RT_CLOCK_STATUS             0x05
+#define ACPI_BITREG_WAKE_STATUS                 0x06
+
+#define ACPI_BITREG_TIMER_ENABLE                0x07
+#define ACPI_BITREG_GLOBAL_LOCK_ENABLE          0x08
+#define ACPI_BITREG_POWER_BUTTON_ENABLE         0x09
+#define ACPI_BITREG_SLEEP_BUTTON_ENABLE         0x0A
+#define ACPI_BITREG_RT_CLOCK_ENABLE             0x0B
+#define ACPI_BITREG_WAKE_ENABLE                 0x0C
+
+#define ACPI_BITREG_SCI_ENABLE                  0x0D
+#define ACPI_BITREG_BUS_MASTER_RLD              0x0E
+#define ACPI_BITREG_GLOBAL_LOCK_RELEASE         0x0F
+#define ACPI_BITREG_SLEEP_TYPE_A                0x10
+#define ACPI_BITREG_SLEEP_TYPE_B                0x11
+#define ACPI_BITREG_SLEEP_ENABLE                0x12
+
+#define ACPI_BITREG_ARB_DISABLE                 0x13
+
+#define ACPI_BITREG_MAX                         0x13
+#define ACPI_NUM_BITREG                         ACPI_BITREG_MAX + 1
+
+/*
  * External ACPI object definition
  */
 
@@ -718,6 +775,13 @@
 	u32                         function,
 	void                        *data);
 
+typedef
+acpi_status (*ACPI_INIT_HANDLER) (
+	acpi_handle                 object,
+	u32                         function);
+
+#define ACPI_INIT_DEVICE_INI        1
+
 
 /* Address Spaces (Operation Regions */
 
@@ -730,7 +794,7 @@
 	void                        *handler_context,
 	void                        *region_context);
 
-#define ACPI_DEFAULT_HANDLER        ((acpi_adr_space_handler) NULL)
+#define ACPI_DEFAULT_HANDLER        NULL
 
 
 typedef
@@ -805,7 +869,7 @@
 	ACPI_PHYSICAL_ADDRESS       address;
 	ACPI_PHYSICAL_ADDRESS       mapped_physical_address;
 	u8                          *mapped_logical_address;
-	u32                         mapped_length;
+	ACPI_SIZE                   mapped_length;
 } acpi_mem_space_context;
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/acutils.h linux/drivers/acpi/include/acutils.h
--- ../prev/linux/drivers/acpi/include/acutils.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/acutils.h	Fri May 31 11:41:57 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acutils.h -- prototypes for the common (subsystem-wide) procedures
- *       $Revision: 130 $
+ *       $Revision: 137 $
  *
  *****************************************************************************/
 
@@ -82,7 +82,7 @@
 acpi_ut_hardware_initialize (
 	void);
 
-acpi_status
+void
 acpi_ut_subsystem_shutdown (
 	void);
 
@@ -94,7 +94,7 @@
  * Ut_global - Global data structures and procedures
  */
 
-#ifdef ACPI_DEBUG
+#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
 
 NATIVE_CHAR *
 acpi_ut_get_mutex_name (
@@ -115,7 +115,7 @@
 acpi_ut_get_event_name (
 	u32                     event_id);
 
-u8
+char
 acpi_ut_hex_to_ascii_char (
 	acpi_integer            integer,
 	u32                     position);
@@ -150,7 +150,7 @@
 	const NATIVE_CHAR       *src_string,
 	NATIVE_UINT             count);
 
-u32
+int
 acpi_ut_strncmp (
 	const NATIVE_CHAR       *string1,
 	const NATIVE_CHAR       *string2,
@@ -195,13 +195,32 @@
 	NATIVE_UINT             value,
 	NATIVE_UINT             count);
 
-u32
+int
 acpi_ut_to_upper (
-	u32                     c);
+	int                     c);
 
-u32
+int
 acpi_ut_to_lower (
-	u32                     c);
+	int                     c);
+
+extern const u8 _acpi_ctype[];
+
+#define _ACPI_XA     0x00    /* extra alphabetic - not supported */
+#define _ACPI_XS     0x40    /* extra space */
+#define _ACPI_BB     0x00    /* BEL, BS, etc. - not supported */
+#define _ACPI_CN     0x20    /* CR, FF, HT, NL, VT */
+#define _ACPI_DI     0x04    /* '0'-'9' */
+#define _ACPI_LO     0x02    /* 'a'-'z' */
+#define _ACPI_PU     0x10    /* punctuation */
+#define _ACPI_SP     0x08    /* space */
+#define _ACPI_UP     0x01    /* 'A'-'Z' */
+#define _ACPI_XD     0x80    /* '0'-'9', 'A'-'F', 'a'-'f' */
+
+#define ACPI_IS_DIGIT(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_DI))
+#define ACPI_IS_SPACE(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_SP))
+#define ACPI_IS_XDIGIT(c) (_acpi_ctype[(unsigned char)(c)] & (_ACPI_XD))
+#define ACPI_IS_UPPER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_UP))
+#define ACPI_IS_LOWER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO))
 
 #endif /* ACPI_USE_SYSTEM_CLIBRARY */
 
@@ -223,6 +242,20 @@
 	u32                     *space_used);
 
 acpi_status
+acpi_ut_copy_ielement_to_eelement (
+	u8                      object_type,
+	acpi_operand_object     *source_object,
+	acpi_generic_state      *state,
+	void                    *context);
+
+acpi_status
+acpi_ut_copy_ielement_to_ielement (
+	u8                      object_type,
+	acpi_operand_object     *source_object,
+	acpi_generic_state      *state,
+	void                    *context);
+
+acpi_status
 acpi_ut_copy_iobject_to_eobject (
 	acpi_operand_object     *obj,
 	acpi_buffer             *ret_buffer);
@@ -386,7 +419,7 @@
 acpi_ut_delete_internal_simple_object (
 	acpi_operand_object     *object);
 
-acpi_status
+void
 acpi_ut_delete_internal_object_list (
 	acpi_operand_object     **obj_list);
 
@@ -524,6 +557,13 @@
 	acpi_operand_object     *obj,
 	ACPI_SIZE               *obj_length);
 
+acpi_status
+acpi_ut_get_element_length (
+	u8                      object_type,
+	acpi_operand_object     *source_object,
+	acpi_generic_state      *state,
+	void                    *context);
+
 
 /*
  * Ut_state - Generic state creation/cache routines
@@ -613,6 +653,12 @@
 acpi_ut_valid_acpi_character (
 	NATIVE_CHAR             character);
 
+acpi_status
+acpi_ut_strtoul64 (
+	NATIVE_CHAR             *string,
+	u32                     base,
+	acpi_integer            *ret_integer);
+
 NATIVE_CHAR *
 acpi_ut_strupr (
 	NATIVE_CHAR             *src_string);
@@ -621,6 +667,13 @@
 acpi_ut_resolve_package_references (
 	acpi_operand_object     *obj_desc);
 
+acpi_status
+acpi_ut_resolve_reference (
+	u8                      object_type,
+	acpi_operand_object     *source_object,
+	acpi_generic_state      *state,
+	void                    *context);
+
 u8 *
 acpi_ut_get_resource_end_tag (
 	acpi_operand_object     *obj_desc);
@@ -630,6 +683,14 @@
 	u8                      *buffer,
 	u32                     length);
 
+u32
+acpi_ut_dword_byte_swap (
+	u32                     value);
+
+void
+acpi_ut_set_integer_width (
+	u8                      revision);
+
 #ifdef ACPI_DEBUG
 void
 acpi_ut_display_init_pathname (
@@ -705,6 +766,12 @@
 	u32                     component,
 	NATIVE_CHAR             *module,
 	u32                     line);
+
+acpi_debug_mem_block *
+acpi_ut_find_allocation (
+	u32                     list_id,
+	void                    *allocation);
+
 acpi_status
 acpi_ut_track_allocation (
 	u32                     list_id,
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/adisasm.h linux/drivers/acpi/include/adisasm.h
--- ../prev/linux/drivers/acpi/include/adisasm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/include/adisasm.h	Fri May 31 11:41:57 2002
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Module Name: adisasm - AML disassembler
+ *
+ *****************************************************************************/
+
+/*
+ *  Copyright (C) 2000 - 2002, R. Byron Moore
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ADISASM
+#define _ADISASM
+
+
+extern u8                       *dsdt_ptr;
+extern u32                      acpi_dsdt_length;
+extern int                      optind;
+extern char                     *optarg;
+extern u8                       *aml_start;
+extern u32                      aml_length;
+
+
+int
+getopt (
+	int                     argc,
+	char                    **argv,
+	char                    *opts);
+
+
+acpi_status
+ad_aml_disassemble (
+	char                *filename);
+
+void
+ad_print_statistics (void);
+
+
+acpi_status
+ad_find_dsdt(
+	u8                      **dsdt_ptr,
+	u32                     *dsdt_length);
+
+void
+ad_dump_tables (void);
+
+
+acpi_status
+ad_get_tables (
+	char                    *filename);
+
+acpi_status
+ad_parse_tables (void);
+
+acpi_status
+ad_display_tables (void);
+
+acpi_status
+ad_display_statistics (void);
+
+
+#endif
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/amlcode.h linux/drivers/acpi/include/amlcode.h
--- ../prev/linux/drivers/acpi/include/amlcode.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/amlcode.h	Fri May 31 11:41:57 2002
@@ -3,7 +3,7 @@
  * Name: amlcode.h - Definitions for AML, as included in "definition blocks"
  *                   Declarations and definitions contained herein are derived
  *                   directly from the ACPI specification.
- *       $Revision: 67 $
+ *       $Revision: 68 $
  *
  *****************************************************************************/
 
@@ -28,7 +28,6 @@
 #ifndef __AMLCODE_H__
 #define __AMLCODE_H__
 
-
 /* primary opcodes */
 
 #define AML_NULL_CHAR               (u16) 0x00
@@ -290,6 +289,7 @@
 #define AML_CREATE                  0x0004
 #define AML_MATH                    0x0002
 #define AML_LOGICAL                 0x0001
+#define AML_CONSTANT                0x1000
 
 /* Convenient flag groupings */
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/platform/acdos16.h linux/drivers/acpi/include/platform/acdos16.h
--- ../prev/linux/drivers/acpi/include/platform/acdos16.h	Tue May 14 17:24:24 2002
+++ linux/drivers/acpi/include/platform/acdos16.h	Wed Dec 31 17:00:00 1969
@@ -1,60 +0,0 @@
-/******************************************************************************
- *
- * Name: acdos16.h - DOS specific defines, etc.
- *       $Revision: 2 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000 - 2002, R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACDOS16_H__
-#define __ACDOS16_H__
-
-#define ACPI_USE_STANDARD_HEADERS
-#define ACPI_OS_NAME                "MSDOS"
-
-/*
- * Calling conventions:
- *
- * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
- * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
- * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
- * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
- */
-#define ACPI_SYSTEM_XFACE           __cdecl
-#define ACPI_EXTERNAL_XFACE
-#define ACPI_INTERNAL_XFACE
-#define ACPI_INTERNAL_VAR_XFACE     __cdecl
-
-#define ACPI_ASM_MACROS
-#define BREAKPOINT3
-#define ACPI_DISABLE_IRQS()
-#define ACPI_ENABLE_IRQS()
-#define halt()
-#define ACPI_ACQUIRE_GLOBAL_LOCK(Glptr, acq)
-#define ACPI_RELEASE_GLOBAL_LOCK(Glptr, acq)
-
-
-/* This macro is used to tag functions as "printf-like" because
- * some compilers can catch printf format string problems. MSVC
- * doesn't, so this is proprocessed away.
- */
-#define ACPI_PRINTF_LIKE_FUNC
-
-#endif /* __ACDOS16_H__ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/platform/acenv.h linux/drivers/acpi/include/platform/acenv.h
--- ../prev/linux/drivers/acpi/include/platform/acenv.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/platform/acenv.h	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acenv.h - Generation environment specific items
- *       $Revision: 86 $
+ *       $Revision: 94 $
  *
  *****************************************************************************/
 
@@ -51,7 +51,7 @@
 #ifdef _ACPI_ASL_COMPILER
 #define ACPI_DEBUG
 #define ACPI_APPLICATION
-#define ENABLE_DEBUGGER
+/* #define ENABLE_DEBUGGER */
 #define ACPI_USE_SYSTEM_CLIBRARY
 #endif
 
@@ -61,7 +61,7 @@
  * 2) This is NOT a 16-bit version of the code (not enough real-mode memory)
  */
 #ifdef ACPI_DEBUG
-#ifndef _IA16
+#if ACPI_MACHINE_WIDTH != 16
 #define ACPI_DBG_TRACK_ALLOCATIONS
 #endif
 #endif
@@ -111,15 +111,15 @@
 #elif defined(_AED_EFI)
 #include "acefi.h"
 
-#elif defined(MSDOS)
-#include "acdos16.h"
-
 #elif defined(WIN32)
 #include "acwin.h"
 
 #elif defined(WIN64)
 #include "acwin64.h"
 
+#elif defined(MSDOS)        /* Must appear after WIN32 and WIN64 check */
+#include "acdos16.h"
+
 #elif defined(__FreeBSD__)
 #include "acfreebsd.h"
 
@@ -135,6 +135,10 @@
 
 #define ACPI_USE_STANDARD_HEADERS
 
+#define COMPILER_DEPENDENT_INT64   long long
+#define COMPILER_DEPENDENT_UINT64  unsigned long long
+
+
 /* Name of host operating system (returned by the _OS_ namespace object) */
 
 #define ACPI_OS_NAME         "Intel ACPI/CA Core Subsystem"
@@ -178,20 +182,23 @@
  */
 
 #define ACPI_STRSTR(s1,s2)      strstr((s1), (s2))
-#define ACPI_STRUPR(s)          acpi_ut_strupr ((s))
-#define ACPI_STRLEN(s)          (u32) strlen((s))
-#define ACPI_STRCPY(d,s)        strcpy((d), (s))
-#define ACPI_STRNCPY(d,s,n)     strncpy((d), (s), (NATIVE_INT)(n))
-#define ACPI_STRNCMP(d,s,n)     strncmp((d), (s), (NATIVE_INT)(n))
+#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
+#define ACPI_STRLEN(s)          (ACPI_SIZE) strlen((s))
+#define ACPI_STRCPY(d,s)        (void) strcpy((d), (s))
+#define ACPI_STRNCPY(d,s,n)     (void) strncpy((d), (s), (ACPI_SIZE)(n))
+#define ACPI_STRNCMP(d,s,n)     strncmp((d), (s), (ACPI_SIZE)(n))
 #define ACPI_STRCMP(d,s)        strcmp((d), (s))
-#define ACPI_STRCAT(d,s)        strcat((d), (s))
-#define ACPI_STRNCAT(d,s,n)     strncat((d), (s), (NATIVE_INT)(n))
-#define ACPI_STRTOUL(d,s,n)     strtoul((d), (s), (NATIVE_INT)(n))
-#define ACPI_MEMCPY(d,s,n)      (void) memcpy((d), (s), (NATIVE_INT)(n))
-#define ACPI_MEMSET(d,s,n)      (void) memset((d), (s), (NATIVE_INT)(n))
+#define ACPI_STRCAT(d,s)        (void) strcat((d), (s))
+#define ACPI_STRNCAT(d,s,n)     strncat((d), (s), (ACPI_SIZE)(n))
+#define ACPI_STRTOUL(d,s,n)     strtoul((d), (s), (ACPI_SIZE)(n))
+#define ACPI_MEMCPY(d,s,n)      (void) memcpy((d), (s), (ACPI_SIZE)(n))
+#define ACPI_MEMSET(d,s,n)      (void) memset((d), (s), (ACPI_SIZE)(n))
 #define ACPI_TOUPPER            toupper
 #define ACPI_TOLOWER            tolower
 #define ACPI_IS_XDIGIT          isxdigit
+#define ACPI_IS_DIGIT           isdigit
+#define ACPI_IS_SPACE           isspace
+#define ACPI_IS_UPPER           isupper
 
 /******************************************************************************
  *
@@ -234,17 +241,17 @@
 
 
 #define ACPI_STRSTR(s1,s2)      acpi_ut_strstr ((s1), (s2))
-#define ACPI_STRUPR(s)          acpi_ut_strupr ((s))
-#define ACPI_STRLEN(s)          acpi_ut_strlen ((s))
-#define ACPI_STRCPY(d,s)        acpi_ut_strcpy ((d), (s))
-#define ACPI_STRNCPY(d,s,n)     acpi_ut_strncpy ((d), (s), (n))
-#define ACPI_STRNCMP(d,s,n)     acpi_ut_strncmp ((d), (s), (n))
+#define ACPI_STRUPR(s)          (void) acpi_ut_strupr ((s))
+#define ACPI_STRLEN(s)          (ACPI_SIZE) acpi_ut_strlen ((s))
+#define ACPI_STRCPY(d,s)        (void) acpi_ut_strcpy ((d), (s))
+#define ACPI_STRNCPY(d,s,n)     (void) acpi_ut_strncpy ((d), (s), (ACPI_SIZE)(n))
+#define ACPI_STRNCMP(d,s,n)     acpi_ut_strncmp ((d), (s), (ACPI_SIZE)(n))
 #define ACPI_STRCMP(d,s)        acpi_ut_strcmp ((d), (s))
-#define ACPI_STRCAT(d,s)        acpi_ut_strcat ((d), (s))
-#define ACPI_STRNCAT(d,s,n)     acpi_ut_strncat ((d), (s), (n))
-#define ACPI_STRTOUL(d,s,n)     acpi_ut_strtoul ((d), (s),(n))
-#define ACPI_MEMCPY(d,s,n)      (void) acpi_ut_memcpy ((d), (s), (n))
-#define ACPI_MEMSET(d,v,n)      (void) acpi_ut_memset ((d), (v), (n))
+#define ACPI_STRCAT(d,s)        (void) acpi_ut_strcat ((d), (s))
+#define ACPI_STRNCAT(d,s,n)     acpi_ut_strncat ((d), (s), (ACPI_SIZE)(n))
+#define ACPI_STRTOUL(d,s,n)     acpi_ut_strtoul ((d), (s), (ACPI_SIZE)(n))
+#define ACPI_MEMCPY(d,s,n)      (void) acpi_ut_memcpy ((d), (s), (ACPI_SIZE)(n))
+#define ACPI_MEMSET(d,v,n)      (void) acpi_ut_memset ((d), (v), (ACPI_SIZE)(n))
 #define ACPI_TOUPPER            acpi_ut_to_upper
 #define ACPI_TOLOWER            acpi_ut_to_lower
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/platform/acgcc.h linux/drivers/acpi/include/platform/acgcc.h
--- ../prev/linux/drivers/acpi/include/platform/acgcc.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/platform/acgcc.h	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: acgcc.h - GCC specific defines, etc.
- *       $Revision: 21 $
+ *       $Revision: 23 $
  *
  *****************************************************************************/
 
@@ -25,170 +25,6 @@
 
 #ifndef __ACGCC_H__
 #define __ACGCC_H__
-
-
-#ifdef __ia64__
-#define _IA64
-
-#define COMPILER_DEPENDENT_UINT64   unsigned long
-
-/*
- * Calling conventions:
- *
- * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
- * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
- * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
- * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
- */
-#define ACPI_SYSTEM_XFACE
-#define ACPI_EXTERNAL_XFACE
-#define ACPI_INTERNAL_XFACE
-#define ACPI_INTERNAL_VAR_XFACE
-
-/* Single threaded */
-
-#define ACPI_APPLICATION
-
-/* Asm macros */
-
-#define ACPI_ASM_MACROS
-#define BREAKPOINT3
-#define ACPI_DISABLE_IRQS() __cli()
-#define ACPI_ENABLE_IRQS()  __sti()
-
-/*! [Begin] no source code translation */
-
-#include <asm/pal.h>
-
-#define halt()              ia64_pal_halt_light()           /* PAL_HALT[_LIGHT] */
-#define safe_halt()         ia64_pal_halt(1)                /* PAL_HALT */
-
-
-#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-	__asm__ volatile ("1:  ld4      r29=%1\n"  \
-		";;\n"                  \
-		"mov    ar.ccv=r29\n"   \
-		"mov    r2=r29\n"       \
-		"shr.u  r30=r29,1\n"    \
-		"and    r29=-4,r29\n"   \
-		";;\n"                  \
-		"add    r29=2,r29\n"    \
-		"and    r30=1,r30\n"    \
-		";;\n"                  \
-		"add    r29=r29,r30\n"  \
-		";;\n"                  \
-		"cmpxchg4.acq   r30=%1,r29,ar.ccv\n" \
-		";;\n"                  \
-		"cmp.eq p6,p7=r2,r30\n" \
-		"(p7) br.dpnt.few 1b\n" \
-		"cmp.gt p8,p9=3,r29\n"  \
-		";;\n"                  \
-		"(p8) mov %0=-1\n"      \
-		"(p9) mov %0=r0\n"      \
-		:"=r"(Acq):"m"(GLptr):"r2","r29","r30","memory"); \
-	} while (0)
-
-#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-	__asm__ volatile ("1:  ld4      r29=%1\n" \
-		";;\n"                  \
-		"mov    ar.ccv=r29\n"   \
-		"mov    r2=r29\n"       \
-		"and    r29=-4,r29\n"   \
-		";;\n"                  \
-		"cmpxchg4.acq   r30=%1,r29,ar.ccv\n" \
-		";;\n"                  \
-		"cmp.eq p6,p7=r2,r30\n" \
-		"(p7) br.dpnt.few 1b\n" \
-		"and    %0=1,r2\n"      \
-		";;\n"                  \
-		:"=r"(Acq):"m"(GLptr):"r2","r29","r30","memory"); \
-	} while (0)
-/*! [End] no source code translation !*/
-
-
-#else /* DO IA32 */
-
-#define COMPILER_DEPENDENT_UINT64   unsigned long long
-
-/*
- * Calling conventions:
- *
- * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
- * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
- * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
- * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
- */
-#define ACPI_SYSTEM_XFACE
-#define ACPI_EXTERNAL_XFACE
-#define ACPI_INTERNAL_XFACE
-#define ACPI_INTERNAL_VAR_XFACE
-
-/* Asm macros */
-
-#define ACPI_ASM_MACROS
-#define BREAKPOINT3
-#define ACPI_DISABLE_IRQS() __cli()
-#define ACPI_ENABLE_IRQS()  __sti()
-
-/*! [Begin] no source code translation
- *
- * A brief explanation as GNU inline assembly is a bit hairy
- *  %0 is the output parameter in EAX ("=a")
- *  %1 and %2 are the input parameters in ECX ("c")
- *  and an immediate value ("i") respectively
- *  All actual register references are preceded with "%%" as in "%%edx"
- *  Immediate values in the assembly are preceded by "$" as in "$0x1"
- *  The final asm parameter are the operation altered non-output registers.
- */
-#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		int dummy; \
-		asm("1:     movl (%1),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andl   %2,%%edx;" \
-			"btsl   $0x1,%%edx;" \
-			"adcl   $0x0,%%edx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"cmpb   $0x3,%%dl;" \
-			"sbbl   %%eax,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~1L):"dx"); \
-	} while(0)
-
-#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
-	do { \
-		int dummy; \
-		asm("1:     movl (%1),%%eax;" \
-			"movl   %%eax,%%edx;" \
-			"andl   %2,%%edx;" \
-			"lock;  cmpxchgl %%edx,(%1);" \
-			"jnz    1b;" \
-			"andl   $0x1,%%eax" \
-			:"=a"(Acq),"=c"(dummy):"c"(GLptr),"i"(~3L):"dx"); \
-	} while(0)
-
-
-/*
- * Math helper asm macros
- */
-#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
-		asm("divl %2;"        \
-		:"=a"(q32), "=d"(r32) \
-		:"r"(d32),            \
-		"0"(n_lo), "1"(n_hi))
-
-
-#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
-	asm("shrl   $1,%2;"             \
-		"rcrl   $1,%3;"             \
-		:"=r"(n_hi), "=r"(n_lo)     \
-		:"0"(n_hi), "1"(n_lo))
-
-/*! [End] no source code translation !*/
-
-#endif /* IA 32 */
 
 /* This macro is used to tag functions as "printf-like" because
  * some compilers (like GCC) can catch printf format string problems.
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/platform/acintel.h linux/drivers/acpi/include/platform/acintel.h
--- ../prev/linux/drivers/acpi/include/platform/acintel.h	Tue May 14 17:24:25 2002
+++ linux/drivers/acpi/include/platform/acintel.h	Wed Dec 31 17:00:00 1969
@@ -1,77 +0,0 @@
-/******************************************************************************
- *
- * Name: acintel.h - VC specific defines, etc.
- *       $Revision: 5 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000 - 2002, R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACINTEL_H__
-#define __ACINTEL_H__
-
-
-#define COMPILER_DEPENDENT_UINT64   unsigned __int64
-
-/*
- * Calling conventions:
- *
- * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
- * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
- * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
- * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
- */
-#define ACPI_SYSTEM_XFACE
-#define ACPI_EXTERNAL_XFACE
-#define ACPI_INTERNAL_XFACE
-#define ACPI_INTERNAL_VAR_XFACE
-
-/*
- * Math helper functions
- */
-#define ACPI_DIV_64_BY_32(n, n_hi, n_lo, d32, q32, r32) \
-{ \
-	q32 = n / d32; \
-	r32 = n % d32; \
-}
-
-#define ACPI_SHIFT_RIGHT_64(n, n_hi, n_lo) \
-{ \
-	n <<= 1; \
-}
-
-
-#pragma warning(disable:810)
-
-/* warn C4100: unreferenced formal parameter */
-#pragma warning(disable:4100)
-
-/* warn C4127: conditional expression is constant */
-#pragma warning(disable:4127)
-
-/* warn C4706: assignment within conditional expression */
-#pragma warning(disable:4706)
-
-/* This macro is used to tag functions as "printf-like" because
- * some compilers can catch printf format string problems. MSVC
- * doesn't, so this is proprocessed away.
- */
-#define ACPI_PRINTF_LIKE_FUNC
-
-#endif /* __ACINTEL_H__ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/platform/aclinux.h linux/drivers/acpi/include/platform/aclinux.h
--- ../prev/linux/drivers/acpi/include/platform/aclinux.h	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/include/platform/aclinux.h	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Name: aclinux.h - OS specific defines, etc.
- *       $Revision: 19 $
+ *       $Revision: 25 $
  *
  *****************************************************************************/
 
@@ -39,14 +39,11 @@
 #include <asm/system.h>
 #include <asm/atomic.h>
 #include <asm/div64.h>
+#include <asm/acpi.h>
 
 #define strtoul simple_strtoul
 
-#ifdef __ia64__
-#define ACPI_FLUSH_CPU_CACHE()
-#else
-#define ACPI_FLUSH_CPU_CACHE()	wbinvd()
-#endif
+#define ACPI_MACHINE_WIDTH	BITS_PER_LONG
 
 #else /* !__KERNEL__ */
 
@@ -55,6 +52,17 @@
 #include <stdlib.h>
 #include <ctype.h>
 
+#if defined(__ia64__) || defined(__x86_64__)
+#define ACPI_MACHINE_WIDTH		64
+#define COMPILER_DEPENDENT_INT64	long
+#define COMPILER_DEPENDENT_UINT64	unsigned long
+#else
+#define ACPI_MACHINE_WIDTH		32
+#define COMPILER_DEPENDENT_INT64	long long
+#define COMPILER_DEPENDENT_UINT64	unsigned long long
+#define ACPI_USE_NATIVE_DIVIDE
+#endif
+
 #endif /* __KERNEL__ */
 
 /* Linux uses GCC */
@@ -62,7 +70,6 @@
 #include "acgcc.h"
 
 #undef DEBUGGER_THREADING
-#define DEBUGGER_THREADING          DEBUGGER_SINGLE_THREADED
-
+#define DEBUGGER_THREADING	DEBUGGER_SINGLE_THREADED
 
 #endif /* __ACLINUX_H__ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/include/platform/acwin64.h linux/drivers/acpi/include/platform/acwin64.h
--- ../prev/linux/drivers/acpi/include/platform/acwin64.h	Tue May 14 17:24:25 2002
+++ linux/drivers/acpi/include/platform/acwin64.h	Wed Dec 31 17:00:00 1969
@@ -1,72 +0,0 @@
-/******************************************************************************
- *
- * Name: acwin.h - OS specific defines, etc.
- *       $Revision: 6 $
- *
- *****************************************************************************/
-
-/*
- *  Copyright (C) 2000 - 2002, R. Byron Moore
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef __ACWIN64_H__
-#define __ACWIN64_H__
-
-/*! [Begin] no source code translation (Keep the include) */
-
-#include "acintel.h"
-/*! [End] no source code translation !*/
-
-#define ACPI_OS_NAME                "Windows"
-
-#define strupr              _strupr
-#define ACPI_USE_STANDARD_HEADERS
-
-/*
- * Handle platform- and compiler-specific assembly language differences.
- *
- * Notes:
- * 1) Interrupt 3 is used to break into a debugger
- * 2) Interrupts are turned off during ACPI register setup
- */
-
-/*! [Begin] no source code translation  */
-
-#define ACPI_ASM_MACROS
-#define causeinterrupt(level)
-#define BREAKPOINT3
-#define ACPI_DISABLE_IRQS()
-#define ACPI_ENABLE_IRQS()
-#define ACPI_FLUSH_CPU_CACHE()
-
-
-/*
- * For Acpi applications, we don't want to try to access the global lock
- */
-#ifdef ACPI_APPLICATION
-#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq)       (Acq = 0xFF)
-#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Pnd)       (Pnd = 0)
-#else
-
-#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq)
-
-#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Pnd)
-
-#endif
-
-
-#endif /* __ACWIN_H__ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsaccess.c linux/drivers/acpi/namespace/nsaccess.c
--- ../prev/linux/drivers/acpi/namespace/nsaccess.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsaccess.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: nsaccess - Top-level functions for accessing ACPI namespace
- *              $Revision: 153 $
+ *              $Revision: 155 $
  *
  ******************************************************************************/
 
@@ -26,7 +26,6 @@
 
 #include "acpi.h"
 #include "amlcode.h"
-#include "acinterp.h"
 #include "acnamesp.h"
 #include "acdispat.h"
 
@@ -180,7 +179,7 @@
 
 			/* Store pointer to value descriptor in the Node */
 
-			acpi_ns_attach_object (new_node, obj_desc, obj_desc->common.type);
+			status = acpi_ns_attach_object (new_node, obj_desc, obj_desc->common.type);
 
 			/* Remove local reference to the object */
 
@@ -298,9 +297,10 @@
 
 		num_segments = 0;
 		this_node    = acpi_gbl_root_node;
+		pathname     = "";
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-			"Null Pathname (Zero segments), Flags=%x\n", flags));
+			"Null Pathname (Zero segments), Flags=%X\n", flags));
 	}
 	else {
 		/*
@@ -316,7 +316,7 @@
 		 * Parent Prefixes (in which case the name's scope is relative
 		 * to the current scope).
 		 */
-		if (*pathname == AML_ROOT_PREFIX) {
+		if (*pathname == (u8) AML_ROOT_PREFIX) {
 			/* Pathname is fully qualified, start from the root */
 
 			this_node = acpi_gbl_root_node;
@@ -340,7 +340,7 @@
 			 * the parent node for each prefix instance.
 			 */
 			this_node = prefix_node;
-			while (*pathname == AML_PARENT_PREFIX) {
+			while (*pathname == (u8) AML_PARENT_PREFIX) {
 				/*
 				 * Point past this prefix to the name segment
 				 * part or the next Parent Prefix
@@ -382,7 +382,7 @@
 			num_segments = 0;
 
 			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-				"Prefix-only Pathname (Zero name segments), Flags=%x\n", flags));
+				"Prefix-only Pathname (Zero name segments), Flags=%X\n", flags));
 			break;
 
 		case AML_DUAL_NAME_PREFIX:
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsalloc.c linux/drivers/acpi/namespace/nsalloc.c
--- ../prev/linux/drivers/acpi/namespace/nsalloc.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsalloc.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: nsalloc - Namespace allocation and deletion utilities
- *              $Revision: 72 $
+ *              $Revision: 74 $
  *
  ******************************************************************************/
 
@@ -26,7 +26,6 @@
 
 #include "acpi.h"
 #include "acnamesp.h"
-#include "acinterp.h"
 
 
 #define _COMPONENT          ACPI_NAMESPACE
@@ -207,7 +206,7 @@
 		 * real definition is found later.
 		 */
 		ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "[%4.4s] is a forward reference\n",
-			(char *) &node->name));
+			node->name.ascii));
 	}
 
 	/*
@@ -232,7 +231,7 @@
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%4.4s added to %p at %p\n",
-		(char *) &node->name, parent_node, node));
+		node->name.ascii, parent_node, node));
 
 	/*
 	 * Increment the reference count(s) of all parents up to
@@ -339,7 +338,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ns_delete_namespace_subtree (
 	acpi_namespace_node     *parent_node)
 {
@@ -351,7 +350,7 @@
 
 
 	if (!parent_node) {
-		return_ACPI_STATUS (AE_OK);
+		return_VOID;
 	}
 
 	/*
@@ -403,7 +402,7 @@
 		}
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
@@ -475,7 +474,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ns_delete_namespace_by_owner (
 	u16                     owner_id)
 {
@@ -553,7 +552,7 @@
 		}
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsdump.c linux/drivers/acpi/namespace/nsdump.c
--- ../prev/linux/drivers/acpi/namespace/nsdump.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsdump.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: nsdump - table dumping routines for debug
- *              $Revision: 129 $
+ *              $Revision: 135 $
  *
  *****************************************************************************/
 
@@ -25,9 +25,7 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
 #include "acnamesp.h"
-#include "actables.h"
 #include "acparser.h"
 
 
@@ -202,11 +200,11 @@
 		}
 		else {
 			if (acpi_ns_exist_downstream_sibling (this_node + 1)) {
-				downstream_sibling_mask |= (1 << (level - 1));
+				downstream_sibling_mask |= ((u32) 1 << (level - 1));
 				acpi_os_printf ("+");
 			}
 			else {
-				downstream_sibling_mask &= ACPI_UINT32_MAX ^ (1 << (level - 1));
+				downstream_sibling_mask &= ACPI_UINT32_MAX ^ ((u32) 1 << (level - 1));
 				acpi_os_printf ("+");
 			}
 
@@ -229,14 +227,14 @@
 	}
 
 	if (!acpi_ut_valid_acpi_name (this_node->name.integer)) {
-		ACPI_REPORT_WARNING (("Invalid ACPI Name %08X\n", this_node->name));
+		ACPI_REPORT_WARNING (("Invalid ACPI Name %08X\n", this_node->name.integer));
 	}
 
 	/*
 	 * Now we can print out the pertinent information
 	 */
 	acpi_os_printf (" %4.4s %-12s %p",
-			(char *) &this_node->name, acpi_ut_get_type_name (type), this_node);
+			this_node->name.ascii, acpi_ut_get_type_name (type), this_node);
 
 	dbg_level = acpi_dbg_level;
 	acpi_dbg_level = 0;
@@ -256,7 +254,7 @@
 		switch (type) {
 		case ACPI_TYPE_PROCESSOR:
 
-			acpi_os_printf (" ID %d Addr %.4X Len %.4X\n",
+			acpi_os_printf (" ID %hd Addr %.4X Len %.4X\n",
 					 obj_desc->processor.proc_id,
 					 obj_desc->processor.address,
 					 obj_desc->processor.length);
@@ -271,7 +269,7 @@
 
 		case ACPI_TYPE_METHOD:
 
-			acpi_os_printf (" Args %d Len %.4X Aml %p \n",
+			acpi_os_printf (" Args %hd Len %.4X Aml %p \n",
 					 obj_desc->method.param_count,
 					 obj_desc->method.aml_length,
 					 obj_desc->method.aml_start);
@@ -309,7 +307,7 @@
 				if (obj_desc->buffer.length > 0) {
 					acpi_os_printf (" =");
 					for (i = 0; (i < obj_desc->buffer.length && i < 12); i++) {
-						acpi_os_printf (" %.2X", obj_desc->buffer.pointer[i]);
+						acpi_os_printf (" %.2hX", obj_desc->buffer.pointer[i]);
 					}
 				}
 				acpi_os_printf ("\n");
@@ -361,7 +359,7 @@
 			if (obj_desc->buffer_field.buffer_obj &&
 				obj_desc->buffer_field.buffer_obj->buffer.node) {
 				acpi_os_printf (" Buf [%4.4s]",
-						(char *) &obj_desc->buffer_field.buffer_obj->buffer.node->name);
+						obj_desc->buffer_field.buffer_obj->buffer.node->name.ascii);
 			}
 			break;
 
@@ -369,23 +367,23 @@
 		case INTERNAL_TYPE_REGION_FIELD:
 
 			acpi_os_printf (" Rgn [%4.4s]",
-					(char *) &obj_desc->common_field.region_obj->region.node->name);
+					obj_desc->common_field.region_obj->region.node->name.ascii);
 			break;
 
 
 		case INTERNAL_TYPE_BANK_FIELD:
 
 			acpi_os_printf (" Rgn [%4.4s] Bnk [%4.4s]",
-					(char *) &obj_desc->common_field.region_obj->region.node->name,
-					(char *) &obj_desc->bank_field.bank_obj->common_field.node->name);
+					obj_desc->common_field.region_obj->region.node->name.ascii,
+					obj_desc->bank_field.bank_obj->common_field.node->name.ascii);
 			break;
 
 
 		case INTERNAL_TYPE_INDEX_FIELD:
 
 			acpi_os_printf (" Idx [%4.4s] Dat [%4.4s]",
-					(char *) &obj_desc->index_field.index_obj->common_field.node->name,
-					(char *) &obj_desc->index_field.data_obj->common_field.node->name);
+					obj_desc->index_field.index_obj->common_field.node->name.ascii,
+					obj_desc->index_field.data_obj->common_field.node->name.ascii);
 			break;
 
 
@@ -402,14 +400,16 @@
 		case INTERNAL_TYPE_REGION_FIELD:
 		case INTERNAL_TYPE_BANK_FIELD:
 		case INTERNAL_TYPE_INDEX_FIELD:
-			acpi_os_printf (" Off %.2X Len %.2X Acc %.2d\n",
+			acpi_os_printf (" Off %.2X Len %.2X Acc %.2hd\n",
 					(obj_desc->common_field.base_byte_offset * 8)
 						+ obj_desc->common_field.start_field_bit_offset,
 					obj_desc->common_field.bit_length,
 					obj_desc->common_field.access_byte_width);
 			break;
-		}
 
+		default:
+			break;
+		}
 		break;
 
 
@@ -498,7 +498,7 @@
 			break;
 
 
-		case ACPI_DESC_TYPE_INTERNAL:
+		case ACPI_DESC_TYPE_OPERAND:
 
 			obj_type = obj_desc->common.type;
 
@@ -507,8 +507,8 @@
 				bytes_to_dump = 32;
 			}
 			else {
-				acpi_os_printf ("(Ptr to ACPI Object type %2.2X [%s])\n",
-						   obj_type, acpi_ut_get_type_name (obj_type));
+				acpi_os_printf ("(Ptr to ACPI Object type %s, %X)\n",
+						   acpi_ut_get_type_name (obj_type), obj_type);
 				bytes_to_dump = sizeof (acpi_operand_object);
 			}
 			break;
@@ -525,7 +525,7 @@
 
 		/* If value is NOT an internal object, we are done */
 
-		if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_INTERNAL) {
+		if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) != ACPI_DESC_TYPE_OPERAND) {
 			goto cleanup;
 		}
 
@@ -534,11 +534,11 @@
 		 */
 		switch (obj_type) {
 		case ACPI_TYPE_STRING:
-			obj_desc = (acpi_operand_object *) obj_desc->string.pointer;
+			obj_desc = (void *) obj_desc->string.pointer;
 			break;
 
 		case ACPI_TYPE_BUFFER:
-			obj_desc = (acpi_operand_object *) obj_desc->buffer.pointer;
+			obj_desc = (void *) obj_desc->buffer.pointer;
 			break;
 
 		case ACPI_TYPE_BUFFER_FIELD:
@@ -546,26 +546,26 @@
 			break;
 
 		case ACPI_TYPE_PACKAGE:
-			obj_desc = (acpi_operand_object *) obj_desc->package.elements;
+			obj_desc = (void *) obj_desc->package.elements;
 			break;
 
 		case ACPI_TYPE_METHOD:
-			obj_desc = (acpi_operand_object *) obj_desc->method.aml_start;
+			obj_desc = (void *) obj_desc->method.aml_start;
 			break;
 
 		case INTERNAL_TYPE_REGION_FIELD:
-			obj_desc = (acpi_operand_object *) obj_desc->field.region_obj;
+			obj_desc = (void *) obj_desc->field.region_obj;
 			break;
 
 		case INTERNAL_TYPE_BANK_FIELD:
-			obj_desc = (acpi_operand_object *) obj_desc->bank_field.region_obj;
+			obj_desc = (void *) obj_desc->bank_field.region_obj;
 			break;
 
 		case INTERNAL_TYPE_INDEX_FIELD:
-			obj_desc = (acpi_operand_object *) obj_desc->index_field.index_obj;
+			obj_desc = (void *) obj_desc->index_field.index_obj;
 			break;
 
-	   default:
+		default:
 			goto cleanup;
 		}
 
@@ -613,8 +613,9 @@
 	info.display_type = display_type;
 
 
-	acpi_ns_walk_namespace (type, start_handle, max_depth, ACPI_NS_WALK_NO_UNLOCK, acpi_ns_dump_one_object,
-			   (void *) &info, NULL);
+	(void) acpi_ns_walk_namespace (type, start_handle, max_depth,
+			 ACPI_NS_WALK_NO_UNLOCK, acpi_ns_dump_one_object,
+			 (void *) &info, NULL);
 }
 
 
@@ -655,7 +656,7 @@
 			ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, " "));
 		}
 
-		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "    HID: %s, ADR: %8.8X%8.8X, Status: %x\n",
+		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_TABLES, "    HID: %s, ADR: %8.8X%8.8X, Status: %X\n",
 				  info.hardware_id,
 				  ACPI_HIDWORD (info.address), ACPI_LODWORD (info.address),
 				  info.current_status));
@@ -679,6 +680,7 @@
 acpi_ns_dump_root_devices (void)
 {
 	acpi_handle             sys_bus_handle;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_NAME ("Ns_dump_root_devices");
@@ -690,11 +692,16 @@
 		return;
 	}
 
-	acpi_get_handle (0, ACPI_NS_SYSTEM_BUS, &sys_bus_handle);
+	status = acpi_get_handle (0, ACPI_NS_SYSTEM_BUS, &sys_bus_handle);
+	if (ACPI_FAILURE (status)) {
+		return;
+	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "Display of all devices in the namespace:\n"));
-	acpi_ns_walk_namespace (ACPI_TYPE_DEVICE, sys_bus_handle, ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
-			   acpi_ns_dump_one_device, NULL, NULL);
+
+	status = acpi_ns_walk_namespace (ACPI_TYPE_DEVICE, sys_bus_handle,
+			 ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+			 acpi_ns_dump_one_device, NULL, NULL);
 }
 
 #endif
@@ -772,7 +779,7 @@
 	info.owner_id = ACPI_UINT32_MAX;
 	info.display_type = ACPI_DISPLAY_SUMMARY;
 
-	acpi_ns_dump_one_object (handle, 1, &info, NULL);
+	(void) acpi_ns_dump_one_object (handle, 1, &info, NULL);
 }
 
 #endif
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nseval.c linux/drivers/acpi/namespace/nseval.c
--- ../prev/linux/drivers/acpi/namespace/nseval.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nseval.c	Fri May 31 11:41:58 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: nseval - Object evaluation interfaces -- includes control
  *                       method lookup and execution.
- *              $Revision: 112 $
+ *              $Revision: 114 $
  *
  ******************************************************************************/
 
@@ -26,7 +26,6 @@
 
 
 #include "acpi.h"
-#include "amlcode.h"
 #include "acparser.h"
 #include "acinterp.h"
 #include "acnamesp.h"
@@ -332,12 +331,9 @@
 			*return_object = local_return_object;
 		}
 
+		/* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
 
-		/* Map AE_RETURN_VALUE to AE_OK, we are done with it */
-
-		if (status == AE_CTRL_RETURN_VALUE) {
-			status = AE_OK;
-		}
+		status = AE_OK;
 	}
 
 	/*
@@ -393,7 +389,7 @@
 	ACPI_DUMP_PATHNAME (method_node, "Ns_execute_control_method: Executing",
 		ACPI_LV_INFO, _COMPONENT);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Method at AML address %p Length %x\n",
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Method at AML address %p Length %X\n",
 		obj_desc->method.aml_start + 1, obj_desc->method.aml_length - 1));
 
 	/*
@@ -444,7 +440,7 @@
 	acpi_operand_object     **return_obj_desc)
 {
 	acpi_status             status = AE_OK;
-	acpi_operand_object     *obj_desc;
+	acpi_namespace_node     *resolved_node = node;
 
 
 	ACPI_FUNCTION_TRACE ("Ns_get_object_value");
@@ -455,7 +451,6 @@
 	 * Node may be a field that must be read, etc.) -- we can't just grab
 	 * the object out of the node.
 	 */
-	obj_desc = (acpi_operand_object *) node;
 
 	/*
 	 * Use Resolve_node_to_value() to get the associated value. This call
@@ -482,17 +477,17 @@
 
 	status = acpi_ex_enter_interpreter ();
 	if (ACPI_SUCCESS (status)) {
-		status = acpi_ex_resolve_node_to_value ((acpi_namespace_node **) &obj_desc, NULL);
+		status = acpi_ex_resolve_node_to_value (&resolved_node, NULL);
 		/*
 		 * If Acpi_ex_resolve_node_to_value() succeeded, the return value was
-		 * placed in Obj_desc.
+		 * placed in Resolved_node.
 		 */
 		acpi_ex_exit_interpreter ();
 
 		if (ACPI_SUCCESS (status)) {
 			status = AE_CTRL_RETURN_VALUE;
-			*return_obj_desc = obj_desc;
-			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Returning obj %p\n", *return_obj_desc));
+			*return_obj_desc = ACPI_CAST_PTR (acpi_operand_object, resolved_node);
+			ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Returning obj %p\n", resolved_node));
 		}
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsinit.c linux/drivers/acpi/namespace/nsinit.c
--- ../prev/linux/drivers/acpi/namespace/nsinit.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsinit.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: nsinit - namespace initialization
- *              $Revision: 42 $
+ *              $Revision: 47 $
  *
  *****************************************************************************/
 
@@ -71,19 +71,20 @@
 			  ACPI_UINT32_MAX, acpi_ns_init_one_object,
 			  &info, NULL);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %x\n", status));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %s\n",
+			acpi_format_exception (status)));
 	}
 
 	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-		"\n_initialized %d/%d Regions %d/%d Fields %d/%d Buffers %d/%d Packages (%d nodes)\n",
+		"\n_initialized %hd/%hd Regions %hd/%hd Fields %hd/%hd Buffers %hd/%hd Packages (%hd nodes)\n",
 		info.op_region_init, info.op_region_count,
 		info.field_init,    info.field_count,
 		info.buffer_init,   info.buffer_count,
 		info.package_init,  info.package_count, info.object_count));
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Control Methods found\n", info.method_count));
+		"%hd Control Methods found\n", info.method_count));
 	ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-		"%d Op Regions found\n", info.op_region_count));
+		"%hd Op Regions found\n", info.op_region_count));
 
 	return_ACPI_STATUS (AE_OK);
 }
@@ -130,11 +131,12 @@
 			  ACPI_UINT32_MAX, FALSE, acpi_ns_init_one_device, &info, NULL);
 
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %x\n", status));
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Walk_namespace failed! %s\n",
+			acpi_format_exception (status)));
 	}
 
 	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
-		"\n%d Devices found containing: %d _STA, %d _INI methods\n",
+		"\n%hd Devices found containing: %hd _STA, %hd _INI methods\n",
 		info.device_count, info.num_STA, info.num_INI));
 
 	return_ACPI_STATUS (status);
@@ -259,13 +261,17 @@
 		info->package_init++;
 		status = acpi_ds_get_package_arguments (obj_desc);
 		break;
+
+	default:
+		/* No other types can get here */
+		break;
 	}
 
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_ERROR, "\n"));
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"Could not execute arguments for [%4.4s] (%s), %s\n",
-				(char *) &node->name, acpi_ut_get_type_name (type), acpi_format_exception (status)));
+				node->name.ascii, acpi_ut_get_type_name (type), acpi_format_exception (status)));
 	}
 
 	if (!(acpi_dbg_level & ACPI_LV_INIT)) {
@@ -357,30 +363,36 @@
 	 */
 	ACPI_DEBUG_EXEC (acpi_ut_display_init_pathname (obj_handle, "_INI [Method]"));
 	status = acpi_ns_evaluate_relative (obj_handle, "_INI", NULL, NULL);
-	if (AE_NOT_FOUND == status) {
-		/* No _INI means device requires no initialization */
+	if (ACPI_FAILURE (status)) {
+		/* No _INI (AE_NOT_FOUND) means device requires no initialization */
 
-		status = AE_OK;
-	}
+		if (status != AE_NOT_FOUND) {
+			/* Ignore error and move on to next device */
 
-	else if (ACPI_FAILURE (status)) {
-		/* Ignore error and move on to next device */
+	#ifdef ACPI_DEBUG
+			NATIVE_CHAR *scope_name = acpi_ns_get_external_pathname (obj_handle);
 
-#ifdef ACPI_DEBUG
-		NATIVE_CHAR *scope_name = acpi_ns_get_external_pathname (obj_handle);
+			ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "%s._INI failed: %s\n",
+					scope_name, acpi_format_exception (status)));
 
-		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "%s._INI failed: %s\n",
-				scope_name, acpi_format_exception (status)));
+			ACPI_MEM_FREE (scope_name);
+	#endif
+		}
 
-		ACPI_MEM_FREE (scope_name);
-#endif
+		status = AE_OK;
 	}
-
 	else {
 		/* Count of successful INIs */
 
 		info->num_INI++;
 	}
 
-	return_ACPI_STATUS (AE_OK);
+	if (acpi_gbl_init_handler) {
+		/* External initialization handler is present, call it */
+
+		status = acpi_gbl_init_handler (obj_handle, ACPI_INIT_DEVICE_INI);
+	}
+
+
+	return_ACPI_STATUS (status);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsload.c linux/drivers/acpi/namespace/nsload.c
--- ../prev/linux/drivers/acpi/namespace/nsload.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsload.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: nsload - namespace loading/expanding/contracting procedures
- *              $Revision: 53 $
+ *              $Revision: 55 $
  *
  *****************************************************************************/
 
@@ -25,12 +25,10 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
 #include "acnamesp.h"
 #include "amlcode.h"
 #include "acparser.h"
 #include "acdispat.h"
-#include "acdebug.h"
 
 
 #define _COMPONENT          ACPI_NAMESPACE
@@ -78,8 +76,8 @@
 
 	/* Ignore exceptions from these */
 
-	acpi_ns_load_table_by_type (ACPI_TABLE_SSDT);
-	acpi_ns_load_table_by_type (ACPI_TABLE_PSDT);
+	(void) acpi_ns_load_table_by_type (ACPI_TABLE_SSDT);
+	(void) acpi_ns_load_table_by_type (ACPI_TABLE_PSDT);
 
 	ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OK,
 		"ACPI Namespace successfully loaded at root %p\n",
@@ -122,7 +120,7 @@
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
-	((acpi_parse2_object *) parse_root)->name = ACPI_ROOT_NAME;
+	parse_root->named.name = ACPI_ROOT_NAME;
 
 	/* Create and initialize a new walk state */
 
@@ -497,7 +495,10 @@
 			acpi_ns_delete_children (child_handle);
 
 			child_handle = parent_handle;
-			acpi_get_parent (parent_handle, &parent_handle);
+			status = acpi_get_parent (parent_handle, &parent_handle);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
 		}
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsnames.c linux/drivers/acpi/namespace/nsnames.c
--- ../prev/linux/drivers/acpi/namespace/nsnames.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsnames.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: nsnames - Name manipulation and search
- *              $Revision: 74 $
+ *              $Revision: 77 $
  *
  ******************************************************************************/
 
@@ -26,7 +26,6 @@
 
 #include "acpi.h"
 #include "amlcode.h"
-#include "acinterp.h"
 #include "acnamesp.h"
 
 
@@ -55,7 +54,7 @@
 	ACPI_SIZE               size,
 	NATIVE_CHAR             *name_buffer)
 {
-	u32                     index;
+	ACPI_SIZE               index;
 	acpi_namespace_node     *parent_node;
 
 
@@ -97,7 +96,7 @@
 	if (index != 0) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Could not construct pathname; index=%X, size=%X, Path=%s\n",
-			index, size, &name_buffer[size]));
+			(u32) index, (u32) size, &name_buffer[size]));
 	}
 
 	return;
@@ -236,7 +235,7 @@
 
 	acpi_ns_build_external_path (node, required_size, buffer->pointer);
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s [%X] \n", (char *) buffer->pointer, required_size));
+	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s [%X] \n", (char *) buffer->pointer, (u32) required_size));
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsobject.c linux/drivers/acpi/namespace/nsobject.c
--- ../prev/linux/drivers/acpi/namespace/nsobject.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsobject.c	Fri May 31 11:41:58 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: nsobject - Utilities for objects attached to namespace
  *                         table entries
- *              $Revision: 80 $
+ *              $Revision: 82 $
  *
  ******************************************************************************/
 
@@ -26,10 +26,7 @@
 
 
 #include "acpi.h"
-#include "amlcode.h"
 #include "acnamesp.h"
-#include "acinterp.h"
-#include "actables.h"
 
 
 #define _COMPONENT          ACPI_NAMESPACE
@@ -141,13 +138,7 @@
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Installing %p into Node %p [%4.4s]\n",
-		obj_desc, node, (char *) &node->name));
-
-	/*
-	 * Must increment the new value's reference count
-	 * (if it is an internal object)
-	 */
-	acpi_ut_add_reference (obj_desc);
+		obj_desc, node, node->name.ascii));
 
 	/* Detach an existing attached object if present */
 
@@ -155,19 +146,26 @@
 		acpi_ns_detach_object (node);
 	}
 
+	if (obj_desc) {
+		/*
+		 * Must increment the new value's reference count
+		 * (if it is an internal object)
+		 */
+		acpi_ut_add_reference (obj_desc);
 
-	/*
-	 * Handle objects with multiple descriptors - walk
-	 * to the end of the descriptor list
-	 */
-	last_obj_desc = obj_desc;
-	while (last_obj_desc->common.next_object) {
-		last_obj_desc = last_obj_desc->common.next_object;
-	}
+		/*
+		 * Handle objects with multiple descriptors - walk
+		 * to the end of the descriptor list
+		 */
+		last_obj_desc = obj_desc;
+		while (last_obj_desc->common.next_object) {
+			last_obj_desc = last_obj_desc->common.next_object;
+		}
 
-	/* Install the object at the front of the object list */
+		/* Install the object at the front of the object list */
 
-	last_obj_desc->common.next_object = node->object;
+		last_obj_desc->common.next_object = node->object;
+	}
 
 	node->type     = (u8) object_type;
 	node->object   = obj_desc;
@@ -209,7 +207,7 @@
 	/* Clear the entry in all cases */
 
 	node->object = NULL;
-	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_INTERNAL) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (obj_desc) == ACPI_DESC_TYPE_OPERAND) {
 		node->object = obj_desc->common.next_object;
 		if (node->object &&
 		   (node->object->common.type != INTERNAL_TYPE_DATA)) {
@@ -222,7 +220,7 @@
 	node->type = ACPI_TYPE_ANY;
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Node %p [%4.4s] Object %p\n",
-		node, (char *) &node->name, obj_desc));
+		node, node->name.ascii, obj_desc));
 
 	/* Remove one reference on the object (and all subobjects) */
 
@@ -255,8 +253,8 @@
 	}
 
 	if (!node->object ||
-			((ACPI_GET_DESCRIPTOR_TYPE (node->object) != ACPI_DESC_TYPE_INTERNAL)  &&
-			 (ACPI_GET_DESCRIPTOR_TYPE (node->object) != ACPI_DESC_TYPE_NAMED))    ||
+			((ACPI_GET_DESCRIPTOR_TYPE (node->object) != ACPI_DESC_TYPE_OPERAND) &&
+			 (ACPI_GET_DESCRIPTOR_TYPE (node->object) != ACPI_DESC_TYPE_NAMED))  ||
 		(node->object->common.type == INTERNAL_TYPE_DATA)) {
 		return_PTR (NULL);
 	}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nssearch.c linux/drivers/acpi/namespace/nssearch.c
--- ../prev/linux/drivers/acpi/namespace/nssearch.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nssearch.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: nssearch - Namespace search
- *              $Revision: 84 $
+ *              $Revision: 85 $
  *
  ******************************************************************************/
 
@@ -25,8 +25,6 @@
 
 
 #include "acpi.h"
-#include "amlcode.h"
-#include "acinterp.h"
 #include "acnamesp.h"
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsutils.c linux/drivers/acpi/namespace/nsutils.c
--- ../prev/linux/drivers/acpi/namespace/nsutils.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsutils.c	Fri May 31 11:41:58 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing
  *                        parents and siblings and Scope manipulation
- *              $Revision: 105 $
+ *              $Revision: 109 $
  *
  *****************************************************************************/
 
@@ -27,7 +27,6 @@
 
 #include "acpi.h"
 #include "acnamesp.h"
-#include "acinterp.h"
 #include "amlcode.h"
 #include "actables.h"
 
@@ -146,7 +145,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ns_get_internal_name_length (
 	acpi_namestring_info    *info)
 {
@@ -204,8 +203,6 @@
 			  4 + info->num_carats;
 
 	info->next_external_char = next_external_char;
-
-	return (AE_OK);
 }
 
 
@@ -230,7 +227,7 @@
 	NATIVE_CHAR             *internal_name = info->internal_name;
 	NATIVE_CHAR             *external_name = info->next_external_char;
 	NATIVE_CHAR             *result = NULL;
-	u32                     i;
+	NATIVE_UINT_MIN32       i;
 
 
 	ACPI_FUNCTION_TRACE ("Ns_build_internal_name");
@@ -293,7 +290,7 @@
 			else {
 				/* Convert the character to uppercase and save it */
 
-				result[i] = (char) ACPI_TOUPPER (*external_name);
+				result[i] = (char) ACPI_TOUPPER ((int) *external_name);
 				external_name++;
 			}
 		}
@@ -410,12 +407,12 @@
 	u32                     *converted_name_length,
 	char                    **converted_name)
 {
-	u32                     prefix_length = 0;
-	u32                     names_index = 0;
-	u32                     num_segments = 0;
-	u32                     i = 0;
-	u32                     j = 0;
-	u32                     required_length;
+	NATIVE_UINT_MIN32       prefix_length = 0;
+	NATIVE_UINT_MIN32       names_index = 0;
+	NATIVE_UINT_MIN32       num_segments = 0;
+	NATIVE_UINT_MIN32       i = 0;
+	NATIVE_UINT_MIN32       j = 0;
+	NATIVE_UINT_MIN32       required_length;
 
 
 	ACPI_FUNCTION_TRACE ("Ns_externalize_name");
@@ -447,6 +444,9 @@
 		}
 
 		break;
+
+	default:
+		break;
 	}
 
 	/*
@@ -534,7 +534,7 @@
 	}
 
 	if (converted_name_length) {
-		*converted_name_length = required_length;
+		*converted_name_length = (u32) required_length;
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -818,16 +818,16 @@
 		parent_node = acpi_ns_get_parent_node (child_node);
 		if (parent_node) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Parent of %p [%4.4s] is %p [%4.4s]\n",
-				child_node, (char *) &child_node->name,
-				parent_node, (char *) &parent_node->name));
+				child_node, child_node->name.ascii,
+				parent_node, parent_node->name.ascii));
 
 			if (parent_node->name.integer) {
-				return_VALUE (parent_node->name.integer);
+				return_VALUE ((acpi_name) parent_node->name.integer);
 			}
 		}
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "unable to find parent of %p (%4.4s)\n",
-			child_node, (char *) &child_node->name));
+			child_node, child_node->name.ascii));
 	}
 
 	return_VALUE (ACPI_UNKNOWN_NAME);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nswalk.c linux/drivers/acpi/namespace/nswalk.c
--- ../prev/linux/drivers/acpi/namespace/nswalk.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nswalk.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: nswalk - Functions for walking the ACPI namespace
- *              $Revision: 32 $
+ *              $Revision: 33 $
  *
  *****************************************************************************/
 
@@ -25,7 +25,6 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
 #include "acnamesp.h"
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsxfname.c linux/drivers/acpi/namespace/nsxfname.c
--- ../prev/linux/drivers/acpi/namespace/nsxfname.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsxfname.c	Fri May 31 11:41:58 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: nsxfname - Public interfaces to the ACPI subsystem
  *                         ACPI Namespace oriented interfaces
- *              $Revision: 90 $
+ *              $Revision: 91 $
  *
  *****************************************************************************/
 
@@ -26,12 +26,7 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
 #include "acnamesp.h"
-#include "amlcode.h"
-#include "acparser.h"
-#include "acdispat.h"
-#include "acevents.h"
 
 
 #define _COMPONENT          ACPI_NAMESPACE
@@ -185,7 +180,7 @@
 
 	/* Just copy the ACPI name from the Node and zero terminate it */
 
-	ACPI_STRNCPY (buffer->pointer, (NATIVE_CHAR *) &node->name,
+	ACPI_STRNCPY (buffer->pointer, node->name.ascii,
 			 ACPI_NAME_SIZE);
 	((NATIVE_CHAR *) buffer->pointer) [ACPI_NAME_SIZE] = 0;
 	status = AE_OK;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/namespace/nsxfobj.c linux/drivers/acpi/namespace/nsxfobj.c
--- ../prev/linux/drivers/acpi/namespace/nsxfobj.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/namespace/nsxfobj.c	Fri May 31 11:41:58 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: nsxfobj - Public interfaces to the ACPI subsystem
  *                         ACPI Object oriented interfaces
- *              $Revision: 108 $
+ *              $Revision: 112 $
  *
  ******************************************************************************/
 
@@ -26,9 +26,7 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
 #include "acnamesp.h"
-#include "acdispat.h"
 
 
 #define _COMPONENT          ACPI_NAMESPACE
@@ -37,6 +35,99 @@
 
 /*******************************************************************************
  *
+ * FUNCTION:    Acpi_evaluate_object_typed
+ *
+ * PARAMETERS:  Handle              - Object handle (optional)
+ *              *Pathname           - Object pathname (optional)
+ *              **External_params   - List of parameters to pass to method,
+ *                                    terminated by NULL.  May be NULL
+ *                                    if no parameters are being passed.
+ *              *Return_buffer      - Where to put method's return value (if
+ *                                    any).  If NULL, no value is returned.
+ *              Return_type         - Expected type of return object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Find and evaluate the given object, passing the given
+ *              parameters if necessary.  One of "Handle" or "Pathname" must
+ *              be valid (non-null)
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_evaluate_object_typed (
+	acpi_handle             handle,
+	acpi_string             pathname,
+	acpi_object_list        *external_params,
+	acpi_buffer             *return_buffer,
+	acpi_object_type        return_type)
+{
+	acpi_status             status;
+	u8                      must_free = FALSE;
+
+
+	ACPI_FUNCTION_TRACE ("Acpi_evaluate_object_typed");
+
+
+	/* Return buffer must be valid */
+
+	if (!return_buffer) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
+	if (return_buffer->length == ACPI_ALLOCATE_BUFFER) {
+		must_free = TRUE;
+	}
+
+	/* Evaluate the object */
+
+	status = acpi_evaluate_object (handle, pathname, external_params, return_buffer);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	/* Type ANY means "don't care" */
+
+	if (return_type == ACPI_TYPE_ANY) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	if (return_buffer->length == 0) {
+		/* Error because caller specifically asked for a return value */
+
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+			"No return value\n"));
+
+		return_ACPI_STATUS (AE_NULL_OBJECT);
+	}
+
+	/* Examine the object type returned from Evaluate_object */
+
+	if (((acpi_object *) return_buffer->pointer)->type == return_type) {
+		return_ACPI_STATUS (AE_OK);
+	}
+
+	/* Return object type does not match requested type */
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
+		"Incorrect return type [%s] requested [%s]\n",
+		acpi_ut_get_type_name (((acpi_object *) return_buffer->pointer)->type),
+		acpi_ut_get_type_name (return_type)));
+
+	if (must_free) {
+		/* Caller used ACPI_ALLOCATE_BUFFER, free the return buffer */
+
+		acpi_os_free (return_buffer->pointer);
+		return_buffer->pointer = NULL;
+	}
+
+	return_buffer->length = 0;
+	return_ACPI_STATUS (AE_TYPE);
+}
+
+
+/*******************************************************************************
+ *
  * FUNCTION:    Acpi_evaluate_object
  *
  * PARAMETERS:  Handle              - Object handle (optional)
@@ -82,7 +173,7 @@
 		 * Allocate a new parameter block for the internal objects
 		 * Add 1 to count to allow for null terminated internal list
 		 */
-		internal_params = ACPI_MEM_CALLOCATE ((external_params->count + 1) *
+		internal_params = ACPI_MEM_CALLOCATE (((ACPI_SIZE) external_params->count + 1) *
 				  sizeof (void *));
 		if (!internal_params) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
@@ -198,7 +289,7 @@
 						 */
 						ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
 							"Needed buffer size %X, %s\n",
-							buffer_space_needed, acpi_format_exception (status)));
+							(u32) buffer_space_needed, acpi_format_exception (status)));
 					}
 					else {
 						/*
@@ -602,8 +693,8 @@
 		}
 	}
 
-	info->user_function (obj_handle, nesting_level, info->context, return_value);
-	return (AE_OK);
+	status = info->user_function (obj_handle, nesting_level, info->context, return_value);
+	return (status);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/osl.c linux/drivers/acpi/osl.c
--- ../prev/linux/drivers/acpi/osl.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/osl.c	Tue Jun 11 21:36:13 2002
@@ -0,0 +1,911 @@
+/*
+ *  acpi_osl.c - OS-dependent functions ($Revision: 1.2 $)
+ *
+ *  Copyright (C) 2000       Andrew Henroid
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/kmod.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include "acpi.h"
+
+#ifdef CONFIG_ACPI_EFI
+#include <asm/efi.h>
+u64 efi_mem_attributes (u64 phys_addr);
+#endif
+
+#ifdef CONFIG_IA64
+#include <asm/hw_irq.h>
+#include <asm/delay.h>
+#endif
+
+
+#define _COMPONENT		ACPI_OS_SERVICES
+ACPI_MODULE_NAME	("osl")
+
+#define PREFIX		"ACPI: "
+
+typedef struct
+{
+    OSD_EXECUTION_CALLBACK  function;
+    void		    *context;
+} ACPI_OS_DPC;
+
+
+#ifdef ENABLE_DEBUGGER
+#include <linux/kdb.h>
+/* stuff for debugger support */
+int acpi_in_debugger = 0;
+extern NATIVE_CHAR line_buf[80];
+#endif /*ENABLE_DEBUGGER*/
+
+static int acpi_irq_irq = 0;
+static OSD_HANDLER acpi_irq_handler = NULL;
+static void *acpi_irq_context = NULL;
+
+
+acpi_status
+acpi_os_initialize(void)
+{
+	/*
+	 * Initialize PCI configuration space access, as we'll need to access
+	 * it while walking the namespace (bus 0 and root bridges w/ _BBNs).
+	 */
+#ifdef CONFIG_ACPI_PCI
+	pcibios_config_init();
+	if (!pci_config_read || !pci_config_write) {
+		printk(KERN_ERR PREFIX "Access to PCI configuration space unavailable\n");
+		return AE_NULL_ENTRY;
+	}
+#endif
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_terminate(void)
+{
+	if (acpi_irq_handler) {
+		acpi_os_remove_interrupt_handler(acpi_irq_irq,
+						 acpi_irq_handler);
+	}
+
+	return AE_OK;
+}
+
+void
+acpi_os_printf(const NATIVE_CHAR *fmt,...)
+{
+	va_list args;
+	va_start(args, fmt);
+	acpi_os_vprintf(fmt, args);
+	va_end(args);
+}
+
+void
+acpi_os_vprintf(const NATIVE_CHAR *fmt, va_list args)
+{
+	static char buffer[512];
+	
+	vsprintf(buffer, fmt, args);
+
+#ifdef ENABLE_DEBUGGER
+	if (acpi_in_debugger) {
+		kdb_printf("%s", buffer);
+	} else {
+		printk("%s", buffer);
+	}
+#else
+	printk("%s", buffer);
+#endif
+}
+
+void *
+acpi_os_allocate(ACPI_SIZE size)
+{
+	return kmalloc(size, GFP_KERNEL);
+}
+
+void *
+acpi_os_callocate(ACPI_SIZE size)
+{
+	void *ptr = acpi_os_allocate(size);
+	if (ptr)
+		memset(ptr, 0, size);
+
+	return ptr;
+}
+
+void
+acpi_os_free(void *ptr)
+{
+	kfree(ptr);
+}
+
+acpi_status
+acpi_os_get_root_pointer(u32 flags, ACPI_POINTER *addr)
+{
+#ifdef CONFIG_ACPI_EFI
+	addr->pointer_type = ACPI_PHYSICAL_POINTER;
+	if (efi.acpi20)
+		addr->pointer.physical = (ACPI_PHYSICAL_ADDRESS) virt_to_phys(efi.acpi20);
+	else if (efi.acpi)
+		addr->pointer.physical = (ACPI_PHYSICAL_ADDRESS) virt_to_phys(efi.acpi);
+	else {
+		printk(KERN_ERR PREFIX "System description tables not found\n");
+		return AE_NOT_FOUND;
+	}
+#else
+	if (ACPI_FAILURE(acpi_find_root_pointer(flags, addr))) {
+		printk(KERN_ERR PREFIX "System description tables not found\n");
+		return AE_NOT_FOUND;
+	}
+#endif /*CONFIG_ACPI_EFI*/
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_map_memory(ACPI_PHYSICAL_ADDRESS phys, ACPI_SIZE size, void **virt)
+{
+#ifdef CONFIG_ACPI_EFI
+	if (!(EFI_MEMORY_WB & efi_mem_attributes(phys))) {
+		*virt = ioremap(phys, size);
+	} else {
+		*virt = phys_to_virt(phys);
+	}
+#else
+	if (phys > ULONG_MAX) {
+		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
+		return AE_BAD_PARAMETER;
+	}
+	/*
+	 * ioremap checks to ensure this is in reserved space
+	 */
+	*virt = ioremap((unsigned long) phys, size);
+#endif
+
+	if (!*virt)
+		return AE_NO_MEMORY;
+
+	return AE_OK;
+}
+
+void
+acpi_os_unmap_memory(void *virt, ACPI_SIZE size)
+{
+	iounmap(virt);
+}
+
+acpi_status
+acpi_os_get_physical_address(void *virt, ACPI_PHYSICAL_ADDRESS *phys)
+{
+	if(!phys || !virt)
+		return AE_BAD_PARAMETER;
+
+	*phys = virt_to_phys(virt);
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_table_override (acpi_table_header *existing_table, acpi_table_header **new_table)
+{
+	if (!existing_table || !new_table)
+		return AE_BAD_PARAMETER;
+
+	*new_table = NULL;
+	return AE_OK;
+}
+
+static void
+acpi_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	(*acpi_irq_handler)(acpi_irq_context);
+}
+
+acpi_status
+acpi_os_install_interrupt_handler(u32 irq, OSD_HANDLER handler, void *context)
+{
+#ifdef CONFIG_IA64
+	irq = gsi_to_vector(irq);
+#endif /* CONFIG_IA64 */
+	acpi_irq_irq = irq;
+	acpi_irq_handler = handler;
+	acpi_irq_context = context;
+	if (request_irq(irq, acpi_irq, SA_SHIRQ, "acpi", acpi_irq)) {
+		printk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);
+		return AE_NOT_ACQUIRED;
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_remove_interrupt_handler(u32 irq, OSD_HANDLER handler)
+{
+	if (acpi_irq_handler) {
+#ifdef CONFIG_IA64
+		irq = gsi_to_vector(irq);
+#endif /* CONFIG_IA64 */
+		free_irq(irq, acpi_irq);
+		acpi_irq_handler = NULL;
+	}
+
+	return AE_OK;
+}
+
+/*
+ * Running in interpreter thread context, safe to sleep
+ */
+
+void
+acpi_os_sleep(u32 sec, u32 ms)
+{
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(HZ * sec + (ms * HZ) / 1000);
+}
+
+void
+acpi_os_stall(u32 us)
+{
+	if (us > 10000) {
+		mdelay(us / 1000);
+	}
+	else {
+		udelay(us);
+	}
+}
+
+acpi_status
+acpi_os_read_port(
+	ACPI_IO_ADDRESS	port,
+	void		*value,
+	u32		width)
+{
+	u32 dummy;
+
+	if (!value)
+		value = &dummy;
+
+	switch (width)
+	{
+	case 8:
+		*(u8*)  value = inb(port);
+		break;
+	case 16:
+		*(u16*) value = inw(port);
+		break;
+	case 32:
+		*(u32*) value = inl(port);
+		break;
+	default:
+		BUG();
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_write_port(
+	ACPI_IO_ADDRESS	port,
+	acpi_integer	value,
+	u32		width)
+{
+	switch (width)
+	{
+	case 8:
+		outb(value, port);
+		break;
+	case 16:
+		outw(value, port);
+		break;
+	case 32:
+		outl(value, port);
+		break;
+	default:
+		BUG();
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_read_memory(
+	ACPI_PHYSICAL_ADDRESS	phys_addr,
+	void			*value,
+	u32			width)
+{
+	u32			dummy;
+	void			*virt_addr;
+
+#ifdef CONFIG_ACPI_EFI
+	int			iomem = 0;
+
+	if (EFI_MEMORY_UC & efi_mem_attributes(phys_addr)) {
+		iomem = 1;
+		virt_addr = ioremap(phys_addr, width);
+	} else {
+		virt_addr = phys_to_virt(phys_addr);
+	}
+#else
+	virt_addr = phys_to_virt(phys_addr);
+#endif
+	if (!value)
+		value = &dummy;
+
+	switch (width) {
+	case 8:
+		*(u8*) value = *(u8*) virt_addr;
+		break;
+	case 16:
+		*(u16*) value = *(u16*) virt_addr;
+		break;
+	case 32:
+		*(u32*) value = *(u32*) virt_addr;
+		break;
+	default:
+		BUG();
+	}
+
+#ifdef CONFIG_ACPI_EFI
+	if (iomem)
+		iounmap(virt_addr);
+#endif
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_write_memory(
+	ACPI_PHYSICAL_ADDRESS	phys_addr,
+	acpi_integer		value,
+	u32			width)
+{
+	void			*virt_addr;
+
+#ifdef CONFIG_ACPI_EFI
+	int			iomem = 0;
+
+	if (EFI_MEMORY_UC & efi_mem_attributes(phys_addr)) {
+		iomem = 1;
+		virt_addr = ioremap(phys_addr,width);
+	} else {
+		virt_addr = phys_to_virt(phys_addr);
+	}
+#else
+	virt_addr = phys_to_virt(phys_addr);
+#endif
+
+	switch (width) {
+	case 8:
+		*(u8*) virt_addr = value;
+		break;
+	case 16:
+		*(u16*) virt_addr = value;
+		break;
+	case 32:
+		*(u32*) virt_addr = value;
+		break;
+	default:
+		BUG();
+	}
+
+#ifdef CONFIG_ACPI_EFI
+	if (iomem)
+		iounmap(virt_addr);
+#endif
+
+	return AE_OK;
+}
+
+#ifdef CONFIG_ACPI_PCI
+
+acpi_status
+acpi_os_read_pci_configuration (
+	acpi_pci_id             *pci_id,
+	u32                     reg,
+	void                    *value,
+	u32                     width)
+{
+	int			result = 0;
+	if (!value)
+		return AE_BAD_PARAMETER;
+
+	switch (width)
+	{
+	case 8:
+		result = pci_config_read(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 1, value);
+		break;
+	case 16:
+		result = pci_config_read(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 2, value);
+		break;
+	case 32:
+		result = pci_config_read(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 4, value);
+		break;
+	default:
+		BUG();
+	}
+
+	return (result ? AE_ERROR : AE_OK);
+}
+
+acpi_status
+acpi_os_write_pci_configuration (
+	acpi_pci_id             *pci_id,
+	u32                     reg,
+	acpi_integer            value,
+	u32                     width)
+{
+	int			result = 0;
+
+	switch (width)
+	{
+	case 8:
+		result = pci_config_write(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 1, value);
+		break;
+	case 16:
+		result = pci_config_write(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 2, value);
+		break;
+	case 32:
+		result = pci_config_write(pci_id->segment, pci_id->bus,
+			pci_id->device, pci_id->function, reg, 4, value);
+		break;
+	default:
+		BUG();
+	}
+
+	return (result ? AE_ERROR : AE_OK);
+}
+
+#else /*!CONFIG_ACPI_PCI*/
+
+acpi_status
+acpi_os_write_pci_configuration (
+	acpi_pci_id             *pci_id,
+	u32                     reg,
+	acpi_integer            value,
+	u32                     width)
+{
+	return (AE_SUPPORT);
+}
+
+acpi_status
+acpi_os_read_pci_configuration (
+	acpi_pci_id             *pci_id,
+	u32                     reg,
+	void                    *value,
+	u32                     width)
+{
+	return (AE_SUPPORT);
+}
+
+#endif /*CONFIG_ACPI_PCI*/
+
+acpi_status
+acpi_os_load_module (
+	char *module_name)
+{
+	ACPI_FUNCTION_TRACE ("os_load_module");
+
+	if (!module_name)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	if (0 > request_module(module_name)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_WARN, "Unable to load module [%s].\n", module_name));
+		return_ACPI_STATUS (AE_ERROR);
+	}
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+acpi_status
+acpi_os_unload_module (
+	char *module_name)
+{
+	if (!module_name)
+		return AE_BAD_PARAMETER;
+
+	/* TODO: How on Linux? */
+	/* this is done automatically for all modules with
+	use_count = 0, I think. see: MOD_INC_USE_COUNT -ASG */
+
+	return AE_OK;
+}
+
+
+/*
+ * See acpi_os_queue_for_execution()
+ */
+static int
+acpi_os_queue_exec (
+	void *context)
+{
+	ACPI_OS_DPC		*dpc = (ACPI_OS_DPC*)context;
+
+	ACPI_FUNCTION_TRACE ("os_queue_exec");
+
+	daemonize();
+	strcpy(current->comm, "kacpidpc");
+
+	if (!dpc || !dpc->function)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Executing function [%p(%p)].\n", dpc->function, dpc->context));
+
+	dpc->function(dpc->context);
+
+	kfree(dpc);
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+static void
+acpi_os_schedule_exec (
+	void *context)
+{
+	ACPI_OS_DPC		*dpc = NULL;
+	int			thread_pid = -1;
+
+	ACPI_FUNCTION_TRACE ("os_schedule_exec");
+
+	dpc = (ACPI_OS_DPC*)context;
+	if (!dpc) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		return_VOID;
+	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Creating new thread to run function [%p(%p)].\n", dpc->function, dpc->context));
+
+	thread_pid = kernel_thread(acpi_os_queue_exec, dpc,
+		(CLONE_FS | CLONE_FILES | SIGCHLD));
+	if (thread_pid < 0) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to kernel_thread() failed.\n"));
+		acpi_os_free(dpc);
+	}
+    return_VOID;
+}
+
+acpi_status
+acpi_os_queue_for_execution(
+	u32			priority,
+	OSD_EXECUTION_CALLBACK	function,
+	void			*context)
+{
+	acpi_status 		status = AE_OK;
+	ACPI_OS_DPC 		*dpc = NULL;
+
+	ACPI_FUNCTION_TRACE ("os_queue_for_execution");
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Scheduling function [%p(%p)] for deferred execution.\n", function, context));
+
+	if (!function)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	/*
+	 * Queue via DPC:
+	 * --------------
+	 * Note that we have to use two different processes for queuing DPCs:
+	 *	 Interrupt-Level: Use schedule_task; can't spawn a new thread.
+	 *	    Kernel-Level: Spawn a new kernel thread, as schedule_task has
+	 *			  its limitations (e.g. single-threaded model), and
+	 *			  all other task queues run at interrupt-level.
+	 */
+	switch (priority) {
+
+	case OSD_PRIORITY_GPE:
+	{
+		static struct tq_struct task;
+
+		/*
+		 * Allocate/initialize DPC structure.  Note that this memory will be
+		 * freed by the callee.
+		 */
+		dpc = kmalloc(sizeof(ACPI_OS_DPC), GFP_ATOMIC);
+		if (!dpc)
+			return_ACPI_STATUS (AE_NO_MEMORY);
+
+		dpc->function = function;
+		dpc->context = context;
+
+		memset(&task, 0, sizeof(struct tq_struct));
+
+		task.routine = acpi_os_schedule_exec;
+		task.data = (void*)dpc;
+
+		if (schedule_task(&task) < 0) {
+			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Call to schedule_task() failed.\n"));
+			status = AE_ERROR;
+		}
+	}
+	break;
+
+	default:
+		/*
+		 * Allocate/initialize DPC structure.  Note that this memory will be
+		 * freed by the callee.
+		 */
+		dpc = kmalloc(sizeof(ACPI_OS_DPC), GFP_KERNEL);
+		if (!dpc)
+			return_ACPI_STATUS (AE_NO_MEMORY);
+
+		dpc->function = function;
+		dpc->context = context;
+
+		acpi_os_schedule_exec(dpc);
+		break;
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+acpi_status
+acpi_os_create_semaphore(
+	u32		max_units,
+	u32		initial_units,
+	acpi_handle	*handle)
+{
+	struct semaphore	*sem = NULL;
+
+	ACPI_FUNCTION_TRACE ("os_create_semaphore");
+
+	sem = acpi_os_callocate(sizeof(struct semaphore));
+	if (!sem)
+		return_ACPI_STATUS (AE_NO_MEMORY);
+
+	sema_init(sem, initial_units);
+
+	*handle = (acpi_handle*)sem;
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Creating semaphore[%p|%d].\n", *handle, initial_units));
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*
+ * TODO: A better way to delete semaphores?  Linux doesn't have a
+ * 'delete_semaphore()' function -- may result in an invalid
+ * pointer dereference for non-synchronized consumers.	Should
+ * we at least check for blocked threads and signal/cancel them?
+ */
+
+acpi_status
+acpi_os_delete_semaphore(
+	acpi_handle	handle)
+{
+	struct semaphore *sem = (struct semaphore*) handle;
+
+	ACPI_FUNCTION_TRACE ("os_delete_semaphore");
+
+	if (!sem)
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Deleting semaphore[%p].\n", handle));
+
+	acpi_os_free(sem); sem =  NULL;
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*
+ * TODO: The kernel doesn't have a 'down_timeout' function -- had to
+ * improvise.  The process is to sleep for one scheduler quantum
+ * until the semaphore becomes available.  Downside is that this
+ * may result in starvation for timeout-based waits when there's
+ * lots of semaphore activity.
+ *
+ * TODO: Support for units > 1?
+ */
+acpi_status
+acpi_os_wait_semaphore(
+	acpi_handle		handle,
+	u32			units,
+	u32			timeout)
+{
+	acpi_status		status = AE_OK;
+	struct semaphore	*sem = (struct semaphore*)handle;
+	int			ret = 0;
+
+	ACPI_FUNCTION_TRACE ("os_wait_semaphore");
+
+	if (!sem || (units < 1))
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	if (units > 1)
+		return_ACPI_STATUS (AE_SUPPORT);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Waiting for semaphore[%p|%d|%d]\n", handle, units, timeout));
+
+	switch (timeout)
+	{
+		/*
+		 * No Wait:
+		 * --------
+		 * A zero timeout value indicates that we shouldn't wait - just
+		 * acquire the semaphore if available otherwise return AE_TIME
+		 * (a.k.a. 'would block').
+		 */
+		case 0:
+		if(down_trylock(sem))
+			status = AE_TIME;
+		break;
+
+		/*
+		 * Wait Indefinitely:
+		 * ------------------
+		 */
+		case WAIT_FOREVER:
+		ret = down_interruptible(sem);
+		if (ret < 0)
+			status = AE_ERROR;
+		break;
+
+		/*
+		 * Wait w/ Timeout:
+		 * ----------------
+		 */
+		default:
+		// TODO: A better timeout algorithm?
+		{
+			int i = 0;
+			static const int quantum_ms = 1000/HZ;
+
+			ret = down_trylock(sem);
+			for (i = timeout; (i > 0 && ret < 0); i -= quantum_ms) {
+				current->state = TASK_INTERRUPTIBLE;
+				schedule_timeout(1);
+				ret = down_trylock(sem);
+			}
+	
+			if (ret != 0)
+			 status = AE_TIME;
+			}
+		break;
+	}
+
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Failed to acquire semaphore[%p|%d|%d]\n", handle, units, timeout));
+	}
+	else {
+		ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Acquired semaphore[%p|%d|%d]\n", handle, units, timeout));
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*
+ * TODO: Support for units > 1?
+ */
+acpi_status
+acpi_os_signal_semaphore(
+    acpi_handle 	    handle,
+    u32 		    units)
+{
+	struct semaphore *sem = (struct semaphore *) handle;
+
+	ACPI_FUNCTION_TRACE ("os_signal_semaphore");
+
+	if (!sem || (units < 1))
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+
+	if (units > 1)
+		return_ACPI_STATUS (AE_SUPPORT);
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Signaling semaphore[%p|%d]\n", handle, units));
+
+	up(sem);
+
+	return_ACPI_STATUS (AE_OK);
+}
+
+u32
+acpi_os_get_line(NATIVE_CHAR *buffer)
+{
+
+#ifdef ENABLE_DEBUGGER
+	if (acpi_in_debugger) {
+		u32 chars;
+
+		kdb_read(buffer, sizeof(line_buf));
+
+		/* remove the CR kdb includes */
+		chars = strlen(buffer) - 1;
+		buffer[chars] = '\0';
+	}
+#endif
+
+	return 0;
+}
+
+/*
+ * We just have to assume we're dealing with valid memory
+ */
+
+BOOLEAN
+acpi_os_readable(void *ptr, u32 len)
+{
+	return 1;
+}
+
+BOOLEAN
+acpi_os_writable(void *ptr, u32 len)
+{
+	return 1;
+}
+
+u32
+acpi_os_get_thread_id (void)
+{
+	if (!in_interrupt())
+		return current->pid;
+
+	return 0;
+}
+
+acpi_status
+acpi_os_signal (
+    u32		function,
+    void	*info)
+{
+	switch (function)
+	{
+	case ACPI_SIGNAL_FATAL:
+		printk(KERN_ERR PREFIX "Fatal opcode executed\n");
+		break;
+	case ACPI_SIGNAL_BREAKPOINT:
+		{
+			char *bp_info = (char*) info;
+
+			printk(KERN_ERR "ACPI breakpoint: %s\n", bp_info);
+		}
+	default:
+		break;
+	}
+
+	return AE_OK;
+}
+
+acpi_status
+acpi_os_breakpoint(NATIVE_CHAR *msg)
+{
+	acpi_os_printf("breakpoint: %s", msg);
+	
+	return AE_OK;
+}
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/parser/psargs.c linux/drivers/acpi/parser/psargs.c
--- ../prev/linux/drivers/acpi/parser/psargs.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/parser/psargs.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: psargs - Parse AML opcode arguments
- *              $Revision: 58 $
+ *              $Revision: 61 $
  *
  *****************************************************************************/
 
@@ -93,6 +93,10 @@
 				  (encoded_length & 0x0F));
 		parser_state->aml += 3;
 		break;
+
+	default:
+		/* Can't get here, only 2 bits / 4 cases */
+		break;
 	}
 
 	return_VALUE (length);
@@ -148,9 +152,8 @@
 acpi_ps_get_next_namestring (
 	acpi_parse_state        *parser_state)
 {
-	u8                       *start = parser_state->aml;
-	u8                       *end = parser_state->aml;
-	u32                     length;
+	u8                      *start = parser_state->aml;
+	u8                      *end = parser_state->aml;
 
 
 	ACPI_FUNCTION_TRACE ("Ps_get_next_namestring");
@@ -177,35 +180,29 @@
 		end++;
 		break;
 
-
 	case AML_DUAL_NAME_PREFIX:
 
-		/* two name segments */
+		/* Two name segments */
 
 		end += 9;
 		break;
 
-
 	case AML_MULTI_NAME_PREFIX_OP:
 
-		/* multiple name segments */
+		/* Multiple name segments, 4 chars each */
 
-		length = (u32) ACPI_GET8 (end + 1) * 4;
-		end += 2 + length;
+		end += 2 + ((ACPI_SIZE) ACPI_GET8 (end + 1) * 4);
 		break;
 
-
 	default:
 
-		/* single name segment */
-		/* assert (Acpi_ps_is_lead (GET8 (End))); */
+		/* Single name segment */
 
 		end += 4;
 		break;
 	}
 
 	parser_state->aml = (u8*) end;
-
 	return_PTR ((NATIVE_CHAR *) start);
 }
 
@@ -255,7 +252,7 @@
 		/* Null name case, create a null namepath object */
 
 		acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-		arg->value.name = path;
+		arg->common.value.name = path;
 		return_VOID;
 	}
 
@@ -271,7 +268,7 @@
 		}
 
 		if (op) {
-			if (op->opcode == AML_METHOD_OP) {
+			if (op->common.aml_opcode == AML_METHOD_OP) {
 				/*
 				 * The name refers to a control method, so this namepath is a
 				 * method invocation.  We need to 1) Get the number of arguments
@@ -279,21 +276,21 @@
 				 * object into a METHODCALL object.
 				 */
 				count = acpi_ps_get_arg (op, 0);
-				if (count && count->opcode == AML_BYTE_OP) {
+				if (count && count->common.aml_opcode == AML_BYTE_OP) {
 					name_op = acpi_ps_alloc_op (AML_INT_NAMEPATH_OP);
 					if (name_op) {
 						/* Change arg into a METHOD CALL and attach the name */
 
 						acpi_ps_init_op (arg, AML_INT_METHODCALL_OP);
 
-						name_op->value.name = path;
+						name_op->common.value.name = path;
 
 						/* Point METHODCALL/NAME to the METHOD Node */
 
-						name_op->node = (acpi_namespace_node *) op;
+						name_op->common.node = (acpi_namespace_node *) op;
 						acpi_ps_append_arg (arg, name_op);
 
-						*arg_count = (u32) count->value.integer &
+						*arg_count = (u32) count->common.value.integer &
 								 METHOD_FLAGS_ARG_COUNT;
 					}
 				}
@@ -315,7 +312,7 @@
 	 * pathname
 	 */
 	acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-	arg->value.name = path;
+	arg->common.value.name = path;
 
 
 	return_VOID;
@@ -348,65 +345,62 @@
 		/* Null name case, create a null namepath object */
 
 		acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-		arg->value.name = path;
+		arg->common.value.name = path;
 		return_VOID;
 	}
 
+	/*
+	 * Lookup the name in the internal namespace
+	 */
+	scope_info.scope.node = NULL;
+	node = parser_state->start_node;
+	if (node) {
+		scope_info.scope.node = node;
+	}
 
-	if (method_call) {
-		/*
-		 * Lookup the name in the internal namespace
-		 */
-		scope_info.scope.node = NULL;
-		node = parser_state->start_node;
-		if (node) {
-			scope_info.scope.node = node;
-		}
-
-		/*
-		 * Lookup object.  We don't want to add anything new to the namespace
-		 * here, however.  So we use MODE_EXECUTE.  Allow searching of the
-		 * parent tree, but don't open a new scope -- we just want to lookup the
-		 * object  (MUST BE mode EXECUTE to perform upsearch)
-		 */
-		status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-				 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
-				 &node);
-		if (ACPI_SUCCESS (status)) {
-			if (node->type == ACPI_TYPE_METHOD) {
-				method_node = node;
-				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "method - %p Path=%p\n",
-					method_node, path));
-
-				name_op = acpi_ps_alloc_op (AML_INT_NAMEPATH_OP);
-				if (name_op) {
-					/* Change arg into a METHOD CALL and attach name to it */
-
-					acpi_ps_init_op (arg, AML_INT_METHODCALL_OP);
-
-					name_op->value.name = path;
-
-					/* Point METHODCALL/NAME to the METHOD Node */
+	/*
+	 * Lookup object.  We don't want to add anything new to the namespace
+	 * here, however.  So we use MODE_EXECUTE.  Allow searching of the
+	 * parent tree, but don't open a new scope -- we just want to lookup the
+	 * object  (MUST BE mode EXECUTE to perform upsearch)
+	 */
+	status = acpi_ns_lookup (&scope_info, path, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+			 ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
+			 &node);
+	if (ACPI_SUCCESS (status)) {
+		if (node->type == ACPI_TYPE_METHOD) {
+			method_node = node;
+			ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "method - %p Path=%p\n",
+				method_node, path));
+
+			name_op = acpi_ps_alloc_op (AML_INT_NAMEPATH_OP);
+			if (name_op) {
+				/* Change arg into a METHOD CALL and attach name to it */
+
+				acpi_ps_init_op (arg, AML_INT_METHODCALL_OP);
+
+				name_op->common.value.name = path;
 
-					name_op->node = method_node;
-					acpi_ps_append_arg (arg, name_op);
+				/* Point METHODCALL/NAME to the METHOD Node */
 
-					if (!acpi_ns_get_attached_object (method_node)) {
-						return_VOID;
-					}
+				name_op->common.node = method_node;
+				acpi_ps_append_arg (arg, name_op);
 
-					*arg_count = (acpi_ns_get_attached_object (method_node))->method.param_count;
+				if (!acpi_ns_get_attached_object (method_node)) {
+					return_VOID;
 				}
 
-				return_VOID;
+				*arg_count = (acpi_ns_get_attached_object (method_node))->method.param_count;
 			}
 
-			/*
-			 * Else this is normal named object reference.
-			 * Just init the NAMEPATH object with the pathname.
-			 * (See code below)
-			 */
+			return_VOID;
 		}
+
+		/*
+		 * Else this is normal named object reference.
+		 * Just init the NAMEPATH object with the pathname.
+		 * (See code below)
+		 */
 	}
 
 	/*
@@ -415,7 +409,7 @@
 	 * pathname.
 	 */
 	acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-	arg->value.name = path;
+	arg->common.value.name = path;
 
 
 	return_VOID;
@@ -448,11 +442,10 @@
 
 
 	switch (arg_type) {
-
 	case ARGP_BYTEDATA:
 
 		acpi_ps_init_op (arg, AML_BYTE_OP);
-		arg->value.integer = (u32) ACPI_GET8 (parser_state->aml);
+		arg->common.value.integer = (u32) ACPI_GET8 (parser_state->aml);
 		parser_state->aml++;
 		break;
 
@@ -463,7 +456,7 @@
 
 		/* Get 2 bytes from the AML stream */
 
-		ACPI_MOVE_UNALIGNED16_TO_32 (&arg->value.integer, parser_state->aml);
+		ACPI_MOVE_UNALIGNED16_TO_32 (&arg->common.value.integer, parser_state->aml);
 		parser_state->aml += 2;
 		break;
 
@@ -474,7 +467,7 @@
 
 		/* Get 4 bytes from the AML stream */
 
-		ACPI_MOVE_UNALIGNED32_TO_32 (&arg->value.integer, parser_state->aml);
+		ACPI_MOVE_UNALIGNED32_TO_32 (&arg->common.value.integer, parser_state->aml);
 		parser_state->aml += 4;
 		break;
 
@@ -485,7 +478,7 @@
 
 		/* Get 8 bytes from the AML stream */
 
-		ACPI_MOVE_UNALIGNED64_TO_64 (&arg->value.integer, parser_state->aml);
+		ACPI_MOVE_UNALIGNED64_TO_64 (&arg->common.value.integer, parser_state->aml);
 		parser_state->aml += 8;
 		break;
 
@@ -493,7 +486,7 @@
 	case ARGP_CHARLIST:
 
 		acpi_ps_init_op (arg, AML_STRING_OP);
-		arg->value.string = (char *) parser_state->aml;
+		arg->common.value.string = (char *) parser_state->aml;
 
 		while (ACPI_GET8 (parser_state->aml) != '\0') {
 			parser_state->aml++;
@@ -506,7 +499,12 @@
 	case ARGP_NAMESTRING:
 
 		acpi_ps_init_op (arg, AML_INT_NAMEPATH_OP);
-		arg->value.name = acpi_ps_get_next_namestring (parser_state);
+		arg->common.value.name = acpi_ps_get_next_namestring (parser_state);
+		break;
+
+
+	default:
+		ACPI_REPORT_ERROR (("Invalid Arg_type %X\n", arg_type));
 		break;
 	}
 
@@ -530,8 +528,8 @@
 acpi_ps_get_next_field (
 	acpi_parse_state        *parser_state)
 {
-	u32                     aml_offset = parser_state->aml -
-			 parser_state->aml_start;
+	u32                     aml_offset = ACPI_PTR_DIFF (parser_state->aml,
+			  parser_state->aml_start);
 	acpi_parse_object       *field;
 	u16                     opcode;
 	u32                     name;
@@ -543,20 +541,17 @@
 	/* determine field type */
 
 	switch (ACPI_GET8 (parser_state->aml)) {
-
 	default:
 
 		opcode = AML_INT_NAMEDFIELD_OP;
 		break;
 
-
 	case 0x00:
 
 		opcode = AML_INT_RESERVEDFIELD_OP;
 		parser_state->aml++;
 		break;
 
-
 	case 0x01:
 
 		opcode = AML_INT_ACCESSFIELD_OP;
@@ -568,46 +563,52 @@
 	/* Allocate a new field op */
 
 	field = acpi_ps_alloc_op (opcode);
-	if (field) {
-		field->aml_offset = aml_offset;
+	if (!field) {
+		return_PTR (NULL);
+	}
 
-		/* Decode the field type */
+	field->common.aml_offset = aml_offset;
 
-		switch (opcode) {
-		case AML_INT_NAMEDFIELD_OP:
+	/* Decode the field type */
 
-			/* Get the 4-character name */
+	switch (opcode) {
+	case AML_INT_NAMEDFIELD_OP:
 
-			ACPI_MOVE_UNALIGNED32_TO_32 (&name, parser_state->aml);
-			acpi_ps_set_name (field, name);
-			parser_state->aml += 4;
+		/* Get the 4-character name */
 
-			/* Get the length which is encoded as a package length */
+		ACPI_MOVE_UNALIGNED32_TO_32 (&name, parser_state->aml);
+		acpi_ps_set_name (field, name);
+		parser_state->aml += 4;
 
-			field->value.size = acpi_ps_get_next_package_length (parser_state);
-			break;
+		/* Get the length which is encoded as a package length */
 
+		field->common.value.size = acpi_ps_get_next_package_length (parser_state);
+		break;
 
-		case AML_INT_RESERVEDFIELD_OP:
 
-			/* Get the length which is encoded as a package length */
+	case AML_INT_RESERVEDFIELD_OP:
 
-			field->value.size = acpi_ps_get_next_package_length (parser_state);
-			break;
+		/* Get the length which is encoded as a package length */
 
+		field->common.value.size = acpi_ps_get_next_package_length (parser_state);
+		break;
 
-		case AML_INT_ACCESSFIELD_OP:
 
-			/*
-			 * Get Access_type and Access_attrib and merge into the field Op
-			 * Access_type is first operand, Access_attribute is second
-			 */
-			field->value.integer32 = (ACPI_GET8 (parser_state->aml) << 8);
-			parser_state->aml++;
-			field->value.integer32 |= ACPI_GET8 (parser_state->aml);
-			parser_state->aml++;
-			break;
-		}
+	case AML_INT_ACCESSFIELD_OP:
+
+		/*
+		 * Get Access_type and Access_attrib and merge into the field Op
+		 * Access_type is first operand, Access_attribute is second
+		 */
+		field->common.value.integer32 = (ACPI_GET8 (parser_state->aml) << 8);
+		parser_state->aml++;
+		field->common.value.integer32 |= ACPI_GET8 (parser_state->aml);
+		parser_state->aml++;
+		break;
+
+	default:
+		/* Opcode was set in previous switch */
+		break;
 	}
 
 	return_PTR (field);
@@ -682,7 +683,7 @@
 				}
 
 				if (prev) {
-					prev->next = field;
+					prev->common.next = field;
 				}
 
 				else {
@@ -708,8 +709,8 @@
 			if (arg) {
 				/* fill in bytelist data */
 
-				arg->value.size = (parser_state->pkg_end - parser_state->aml);
-				((acpi_parse2_object *) arg)->data = parser_state->aml;
+				arg->common.value.size = ACPI_PTR_DIFF (parser_state->pkg_end, parser_state->aml);
+				arg->named.data = parser_state->aml;
 			}
 
 			/* skip to End of byte data */
@@ -761,6 +762,10 @@
 
 			*arg_count = ACPI_VAR_ARGS;
 		}
+		break;
+
+	default:
+		ACPI_REPORT_ERROR (("Invalid Arg_type: %X\n", arg_type));
 		break;
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/parser/psopcode.c linux/drivers/acpi/parser/psopcode.c
--- ../prev/linux/drivers/acpi/parser/psopcode.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/parser/psopcode.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: psopcode - Parser/Interpreter opcode information table
- *              $Revision: 65 $
+ *              $Revision: 69 $
  *
  *****************************************************************************/
 
@@ -45,9 +45,9 @@
 #define _UNKNOWN_OPCODE             0x02    /* An example unknown opcode */
 
 #define MAX_EXTENDED_OPCODE         0x88
-#define NUM_EXTENDED_OPCODE         MAX_EXTENDED_OPCODE + 1
+#define NUM_EXTENDED_OPCODE         (MAX_EXTENDED_OPCODE + 1)
 #define MAX_INTERNAL_OPCODE
-#define NUM_INTERNAL_OPCODE         MAX_INTERNAL_OPCODE + 1
+#define NUM_INTERNAL_OPCODE         (MAX_INTERNAL_OPCODE + 1)
 
 
 /*******************************************************************************
@@ -448,22 +448,22 @@
  */
 
 
-static const acpi_opcode_info    acpi_gbl_aml_op_info[] =
+const acpi_opcode_info    acpi_gbl_aml_op_info[AML_NUM_OPCODES] =
 {
 /*! [Begin] no source code translation */
 /* Index           Name                 Parser Args               Interpreter Args                ObjectType                Class                      Type                  Flags */
 
-/* 00 */ ACPI_OP ("Zero",               ARGP_ZERO_OP,              ARGI_ZERO_OP,               INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
-/* 01 */ ACPI_OP ("One",                ARGP_ONE_OP,               ARGI_ONE_OP,                INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
+/* 00 */ ACPI_OP ("Zero",               ARGP_ZERO_OP,              ARGI_ZERO_OP,               INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        AML_CONSTANT),
+/* 01 */ ACPI_OP ("One",                ARGP_ONE_OP,               ARGI_ONE_OP,                INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        AML_CONSTANT),
 /* 02 */ ACPI_OP ("Alias",              ARGP_ALIAS_OP,             ARGI_ALIAS_OP,              INTERNAL_TYPE_ALIAS,     AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
 /* 03 */ ACPI_OP ("Name",               ARGP_NAME_OP,              ARGI_NAME_OP,               ACPI_TYPE_ANY,           AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 04 */ ACPI_OP ("ByteConst",          ARGP_BYTE_OP,              ARGI_BYTE_OP,               ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 05 */ ACPI_OP ("WordConst",          ARGP_WORD_OP,              ARGI_WORD_OP,               ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 06 */ ACPI_OP ("DwordConst",         ARGP_DWORD_OP,             ARGI_DWORD_OP,              ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
-/* 07 */ ACPI_OP ("String",             ARGP_STRING_OP,            ARGI_STRING_OP,             ACPI_TYPE_STRING,        AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
+/* 04 */ ACPI_OP ("ByteConst",          ARGP_BYTE_OP,              ARGI_BYTE_OP,               ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 05 */ ACPI_OP ("WordConst",          ARGP_WORD_OP,              ARGI_WORD_OP,               ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 06 */ ACPI_OP ("DwordConst",         ARGP_DWORD_OP,             ARGI_DWORD_OP,              ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
+/* 07 */ ACPI_OP ("String",             ARGP_STRING_OP,            ARGI_STRING_OP,             ACPI_TYPE_STRING,        AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
 /* 08 */ ACPI_OP ("Scope",              ARGP_SCOPE_OP,             ARGI_SCOPE_OP,              INTERNAL_TYPE_SCOPE,     AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_NO_OBJ,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
-/* 09 */ ACPI_OP ("Buffer",             ARGP_BUFFER_OP,            ARGI_BUFFER_OP,             ACPI_TYPE_BUFFER,        AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER),
-/* 0A */ ACPI_OP ("Package",            ARGP_PACKAGE_OP,           ARGI_PACKAGE_OP,            ACPI_TYPE_PACKAGE,       AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS),
+/* 09 */ ACPI_OP ("Buffer",             ARGP_BUFFER_OP,            ARGI_BUFFER_OP,             ACPI_TYPE_BUFFER,        AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER | AML_CONSTANT),
+/* 0A */ ACPI_OP ("Package",            ARGP_PACKAGE_OP,           ARGI_PACKAGE_OP,            ACPI_TYPE_PACKAGE,       AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER | AML_CONSTANT),
 /* 0B */ ACPI_OP ("Method",             ARGP_METHOD_OP,            ARGI_METHOD_OP,             ACPI_TYPE_METHOD,        AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_COMPLEX,   AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED | AML_DEFER),
 /* 0C */ ACPI_OP ("Local0",             ARGP_LOCAL0,               ARGI_LOCAL0,                INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
 /* 0D */ ACPI_OP ("Local1",             ARGP_LOCAL1,               ARGI_LOCAL1,                INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_LOCAL_VARIABLE,  0),
@@ -482,39 +482,39 @@
 /* 1A */ ACPI_OP ("Arg6",               ARGP_ARG6,                 ARGI_ARG6,                  INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_METHOD_ARGUMENT, 0),
 /* 1B */ ACPI_OP ("Store",              ARGP_STORE_OP,             ARGI_STORE_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
 /* 1C */ ACPI_OP ("RefOf",              ARGP_REF_OF_OP,            ARGI_REF_OF_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 1D */ ACPI_OP ("Add",                ARGP_ADD_OP,               ARGI_ADD_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 1E */ ACPI_OP ("Concatenate",        ARGP_CONCAT_OP,            ARGI_CONCAT_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 1F */ ACPI_OP ("Subtract",           ARGP_SUBTRACT_OP,          ARGI_SUBTRACT_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 20 */ ACPI_OP ("Increment",          ARGP_INCREMENT_OP,         ARGI_INCREMENT_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 21 */ ACPI_OP ("Decrement",          ARGP_DECREMENT_OP,         ARGI_DECREMENT_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 22 */ ACPI_OP ("Multiply",           ARGP_MULTIPLY_OP,          ARGI_MULTIPLY_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 23 */ ACPI_OP ("Divide",             ARGP_DIVIDE_OP,            ARGI_DIVIDE_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_2T_1R,   AML_FLAGS_EXEC_2A_2T_1R),
-/* 24 */ ACPI_OP ("ShiftLeft",          ARGP_SHIFT_LEFT_OP,        ARGI_SHIFT_LEFT_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 25 */ ACPI_OP ("ShiftRight",         ARGP_SHIFT_RIGHT_OP,       ARGI_SHIFT_RIGHT_OP,        ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 26 */ ACPI_OP ("And",                ARGP_BIT_AND_OP,           ARGI_BIT_AND_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 27 */ ACPI_OP ("NAnd",               ARGP_BIT_NAND_OP,          ARGI_BIT_NAND_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 28 */ ACPI_OP ("Or",                 ARGP_BIT_OR_OP,            ARGI_BIT_OR_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 29 */ ACPI_OP ("NOr",                ARGP_BIT_NOR_OP,           ARGI_BIT_NOR_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 2A */ ACPI_OP ("XOr",                ARGP_BIT_XOR_OP,           ARGI_BIT_XOR_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH),
-/* 2B */ ACPI_OP ("Not",                ARGP_BIT_NOT_OP,           ARGI_BIT_NOT_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 2C */ ACPI_OP ("FindSetLeftBit",     ARGP_FIND_SET_LEFT_BIT_OP, ARGI_FIND_SET_LEFT_BIT_OP,  ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 2D */ ACPI_OP ("FindSetRightBit",    ARGP_FIND_SET_RIGHT_BIT_OP,ARGI_FIND_SET_RIGHT_BIT_OP, ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
+/* 1D */ ACPI_OP ("Add",                ARGP_ADD_OP,               ARGI_ADD_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 1E */ ACPI_OP ("Concatenate",        ARGP_CONCAT_OP,            ARGI_CONCAT_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 1F */ ACPI_OP ("Subtract",           ARGP_SUBTRACT_OP,          ARGI_SUBTRACT_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 20 */ ACPI_OP ("Increment",          ARGP_INCREMENT_OP,         ARGI_INCREMENT_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 21 */ ACPI_OP ("Decrement",          ARGP_DECREMENT_OP,         ARGI_DECREMENT_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 22 */ ACPI_OP ("Multiply",           ARGP_MULTIPLY_OP,          ARGI_MULTIPLY_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 23 */ ACPI_OP ("Divide",             ARGP_DIVIDE_OP,            ARGI_DIVIDE_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_2T_1R,   AML_FLAGS_EXEC_2A_2T_1R | AML_CONSTANT),
+/* 24 */ ACPI_OP ("ShiftLeft",          ARGP_SHIFT_LEFT_OP,        ARGI_SHIFT_LEFT_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 25 */ ACPI_OP ("ShiftRight",         ARGP_SHIFT_RIGHT_OP,       ARGI_SHIFT_RIGHT_OP,        ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 26 */ ACPI_OP ("And",                ARGP_BIT_AND_OP,           ARGI_BIT_AND_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 27 */ ACPI_OP ("NAnd",               ARGP_BIT_NAND_OP,          ARGI_BIT_NAND_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 28 */ ACPI_OP ("Or",                 ARGP_BIT_OR_OP,            ARGI_BIT_OR_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 29 */ ACPI_OP ("NOr",                ARGP_BIT_NOR_OP,           ARGI_BIT_NOR_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 2A */ ACPI_OP ("XOr",                ARGP_BIT_XOR_OP,           ARGI_BIT_XOR_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_MATH | AML_CONSTANT),
+/* 2B */ ACPI_OP ("Not",                ARGP_BIT_NOT_OP,           ARGI_BIT_NOT_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2C */ ACPI_OP ("FindSetLeftBit",     ARGP_FIND_SET_LEFT_BIT_OP, ARGI_FIND_SET_LEFT_BIT_OP,  ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 2D */ ACPI_OP ("FindSetRightBit",    ARGP_FIND_SET_RIGHT_BIT_OP,ARGI_FIND_SET_RIGHT_BIT_OP, ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
 /* 2E */ ACPI_OP ("DerefOf",            ARGP_DEREF_OF_OP,          ARGI_DEREF_OF_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
 /* 2F */ ACPI_OP ("Notify",             ARGP_NOTIFY_OP,            ARGI_NOTIFY_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_0R,   AML_FLAGS_EXEC_2A_0T_0R),
 /* 30 */ ACPI_OP ("SizeOf",             ARGP_SIZE_OF_OP,           ARGI_SIZE_OF_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 31 */ ACPI_OP ("Index",              ARGP_INDEX_OP,             ARGI_INDEX_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 32 */ ACPI_OP ("Match",              ARGP_MATCH_OP,             ARGI_MATCH_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R),
+/* 31 */ ACPI_OP ("Index",              ARGP_INDEX_OP,             ARGI_INDEX_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 32 */ ACPI_OP ("Match",              ARGP_MATCH_OP,             ARGI_MATCH_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R | AML_CONSTANT),
 /* 33 */ ACPI_OP ("CreateDWordField",   ARGP_CREATE_DWORD_FIELD_OP,ARGI_CREATE_DWORD_FIELD_OP, ACPI_TYPE_BUFFER_FIELD,  AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 34 */ ACPI_OP ("CreateWordField",    ARGP_CREATE_WORD_FIELD_OP, ARGI_CREATE_WORD_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,  AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 35 */ ACPI_OP ("CreateByteField",    ARGP_CREATE_BYTE_FIELD_OP, ARGI_CREATE_BYTE_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,  AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 36 */ ACPI_OP ("CreateBitField",     ARGP_CREATE_BIT_FIELD_OP,  ARGI_CREATE_BIT_FIELD_OP,   ACPI_TYPE_BUFFER_FIELD,  AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 37 */ ACPI_OP ("ObjectType",         ARGP_TYPE_OP,              ARGI_TYPE_OP,               ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 38 */ ACPI_OP ("LAnd",               ARGP_LAND_OP,              ARGI_LAND_OP,               ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 39 */ ACPI_OP ("LOr",                ARGP_LOR_OP,               ARGI_LOR_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 3A */ ACPI_OP ("LNot",               ARGP_LNOT_OP,              ARGI_LNOT_OP,               ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R),
-/* 3B */ ACPI_OP ("LEqual",             ARGP_LEQUAL_OP,            ARGI_LEQUAL_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 3C */ ACPI_OP ("LGreater",           ARGP_LGREATER_OP,          ARGI_LGREATER_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
-/* 3D */ ACPI_OP ("LLess",              ARGP_LLESS_OP,             ARGI_LLESS_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL),
+/* 38 */ ACPI_OP ("LAnd",               ARGP_LAND_OP,              ARGI_LAND_OP,               ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 39 */ ACPI_OP ("LOr",                ARGP_LOR_OP,               ARGI_LOR_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3A */ ACPI_OP ("LNot",               ARGP_LNOT_OP,              ARGI_LNOT_OP,               ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
+/* 3B */ ACPI_OP ("LEqual",             ARGP_LEQUAL_OP,            ARGI_LEQUAL_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3C */ ACPI_OP ("LGreater",           ARGP_LGREATER_OP,          ARGI_LGREATER_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
+/* 3D */ ACPI_OP ("LLess",              ARGP_LLESS_OP,             ARGI_LLESS_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL | AML_CONSTANT),
 /* 3E */ ACPI_OP ("If",                 ARGP_IF_OP,                ARGI_IF_OP,                 ACPI_TYPE_ANY,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
 /* 3F */ ACPI_OP ("Else",               ARGP_ELSE_OP,              ARGI_ELSE_OP,               ACPI_TYPE_ANY,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
 /* 40 */ ACPI_OP ("While",              ARGP_WHILE_OP,             ARGI_WHILE_OP,              ACPI_TYPE_ANY,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
@@ -522,7 +522,7 @@
 /* 42 */ ACPI_OP ("Return",             ARGP_RETURN_OP,            ARGI_RETURN_OP,             ACPI_TYPE_ANY,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         AML_HAS_ARGS),
 /* 43 */ ACPI_OP ("Break",              ARGP_BREAK_OP,             ARGI_BREAK_OP,              ACPI_TYPE_ANY,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
 /* 44 */ ACPI_OP ("BreakPoint",         ARGP_BREAK_POINT_OP,       ARGI_BREAK_POINT_OP,        ACPI_TYPE_ANY,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
-/* 45 */ ACPI_OP ("Ones",               ARGP_ONES_OP,              ARGI_ONES_OP,               INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
+/* 45 */ ACPI_OP ("Ones",               ARGP_ONES_OP,              ARGI_ONES_OP,               INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        AML_CONSTANT),
 
 /* Prefixed opcodes (Two-byte opcodes with a prefix op) */
 
@@ -538,8 +538,8 @@
 /* 4F */ ACPI_OP ("Wait",               ARGP_WAIT_OP,              ARGI_WAIT_OP,               ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R),
 /* 50 */ ACPI_OP ("Reset",              ARGP_RESET_OP,             ARGI_RESET_OP,              ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
 /* 51 */ ACPI_OP ("Release",            ARGP_RELEASE_OP,           ARGI_RELEASE_OP,            ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
-/* 52 */ ACPI_OP ("FromBCD",            ARGP_FROM_BCD_OP,          ARGI_FROM_BCD_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 53 */ ACPI_OP ("ToBCD",              ARGP_TO_BCD_OP,            ARGI_TO_BCD_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
+/* 52 */ ACPI_OP ("FromBCD",            ARGP_FROM_BCD_OP,          ARGI_FROM_BCD_OP,           ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 53 */ ACPI_OP ("ToBCD",              ARGP_TO_BCD_OP,            ARGI_TO_BCD_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
 /* 54 */ ACPI_OP ("Unload",             ARGP_UNLOAD_OP,            ARGI_UNLOAD_OP,             ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_0R,   AML_FLAGS_EXEC_1A_0T_0R),
 /* 55 */ ACPI_OP ("Revision",           ARGP_REVISION_OP,          ARGI_REVISION_OP,           INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
 /* 56 */ ACPI_OP ("Debug",              ARGP_DEBUG_OP,             ARGI_DEBUG_OP,              INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_CONSTANT,        0),
@@ -555,9 +555,9 @@
 
 /* Internal opcodes that map to invalid AML opcodes */
 
-/* 60 */ ACPI_OP ("LNotEqual",          ARGP_LNOTEQUAL_OP,         ARGI_LNOTEQUAL_OP,          ACPI_TYPE_ANY,           AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 61 */ ACPI_OP ("LLessEqual",         ARGP_LLESSEQUAL_OP,        ARGI_LLESSEQUAL_OP,         ACPI_TYPE_ANY,           AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 62 */ ACPI_OP ("LGreaterEqual",      ARGP_LGREATEREQUAL_OP,     ARGI_LGREATEREQUAL_OP,      ACPI_TYPE_ANY,           AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS),
+/* 60 */ ACPI_OP ("LNotEqual",          ARGP_LNOTEQUAL_OP,         ARGI_LNOTEQUAL_OP,          ACPI_TYPE_ANY,           AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS | AML_CONSTANT),
+/* 61 */ ACPI_OP ("LLessEqual",         ARGP_LLESSEQUAL_OP,        ARGI_LLESSEQUAL_OP,         ACPI_TYPE_ANY,           AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS | AML_CONSTANT),
+/* 62 */ ACPI_OP ("LGreaterEqual",      ARGP_LGREATEREQUAL_OP,     ARGI_LGREATEREQUAL_OP,      ACPI_TYPE_ANY,           AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS | AML_CONSTANT),
 /* 63 */ ACPI_OP ("[NamePath]",         ARGP_NAMEPATH_OP,          ARGI_NAMEPATH_OP,           INTERNAL_TYPE_REFERENCE, AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_NSOBJECT | AML_NSNODE ),
 /* 64 */ ACPI_OP ("[MethodCall]",       ARGP_METHODCALL_OP,        ARGI_METHODCALL_OP,         ACPI_TYPE_METHOD,        AML_CLASS_METHOD_CALL,     AML_TYPE_METHOD_CALL,     AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE),
 /* 65 */ ACPI_OP ("[ByteList]",         ARGP_BYTELIST_OP,          ARGI_BYTELIST_OP,           ACPI_TYPE_ANY,           AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
@@ -573,18 +573,18 @@
 
 /* ACPI 2.0 opcodes */
 
-/* 6E */ ACPI_OP ("QwordConst",         ARGP_QWORD_OP,             ARGI_QWORD_OP,              ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         0),
+/* 6E */ ACPI_OP ("QwordConst",         ARGP_QWORD_OP,             ARGI_QWORD_OP,              ACPI_TYPE_INTEGER,       AML_CLASS_ARGUMENT,        AML_TYPE_LITERAL,         AML_CONSTANT),
 /* 6F */ ACPI_OP ("Package /*Var*/",    ARGP_VAR_PACKAGE_OP,       ARGI_VAR_PACKAGE_OP,        ACPI_TYPE_PACKAGE,       AML_CLASS_CREATE,          AML_TYPE_CREATE_OBJECT,   AML_HAS_ARGS | AML_DEFER),
-/* 70 */ ACPI_OP ("ConcatenateResTemplate", ARGP_CONCAT_RES_OP,    ARGI_CONCAT_RES_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
-/* 71 */ ACPI_OP ("Mod",                ARGP_MOD_OP,               ARGI_MOD_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
+/* 70 */ ACPI_OP ("ConcatenateResTemplate", ARGP_CONCAT_RES_OP,    ARGI_CONCAT_RES_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
+/* 71 */ ACPI_OP ("Mod",                ARGP_MOD_OP,               ARGI_MOD_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
 /* 72 */ ACPI_OP ("CreateQWordField",   ARGP_CREATE_QWORD_FIELD_OP,ARGI_CREATE_QWORD_FIELD_OP, ACPI_TYPE_BUFFER_FIELD,  AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 73 */ ACPI_OP ("ToBuffer",           ARGP_TO_BUFFER_OP,         ARGI_TO_BUFFER_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 74 */ ACPI_OP ("ToDecimalString",    ARGP_TO_DEC_STR_OP,        ARGI_TO_DEC_STR_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 75 */ ACPI_OP ("ToHexString",        ARGP_TO_HEX_STR_OP,        ARGI_TO_HEX_STR_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 76 */ ACPI_OP ("ToInteger",          ARGP_TO_INTEGER_OP,        ARGI_TO_INTEGER_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 77 */ ACPI_OP ("ToString",           ARGP_TO_STRING_OP,         ARGI_TO_STRING_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R),
+/* 73 */ ACPI_OP ("ToBuffer",           ARGP_TO_BUFFER_OP,         ARGI_TO_BUFFER_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 74 */ ACPI_OP ("ToDecimalString",    ARGP_TO_DEC_STR_OP,        ARGI_TO_DEC_STR_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 75 */ ACPI_OP ("ToHexString",        ARGP_TO_HEX_STR_OP,        ARGI_TO_HEX_STR_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 76 */ ACPI_OP ("ToInteger",          ARGP_TO_INTEGER_OP,        ARGI_TO_INTEGER_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R | AML_CONSTANT),
+/* 77 */ ACPI_OP ("ToString",           ARGP_TO_STRING_OP,         ARGI_TO_STRING_OP,          ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_1T_1R,   AML_FLAGS_EXEC_2A_1T_1R | AML_CONSTANT),
 /* 78 */ ACPI_OP ("CopyObject",         ARGP_COPY_OP,              ARGI_COPY_OP,               ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_1T_1R,   AML_FLAGS_EXEC_1A_1T_1R),
-/* 79 */ ACPI_OP ("Mid",                ARGP_MID_OP,               ARGI_MID_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_3A_1T_1R,   AML_FLAGS_EXEC_3A_1T_1R),
+/* 79 */ ACPI_OP ("Mid",                ARGP_MID_OP,               ARGI_MID_OP,                ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_3A_1T_1R,   AML_FLAGS_EXEC_3A_1T_1R | AML_CONSTANT),
 /* 7A */ ACPI_OP ("Continue",           ARGP_CONTINUE_OP,          ARGI_CONTINUE_OP,           ACPI_TYPE_ANY,           AML_CLASS_CONTROL,         AML_TYPE_CONTROL,         0),
 /* 7B */ ACPI_OP ("LoadTable",          ARGP_LOAD_TABLE_OP,        ARGI_LOAD_TABLE_OP,         ACPI_TYPE_ANY,           AML_CLASS_EXECUTE,         AML_TYPE_EXEC_6A_0T_1R,   AML_FLAGS_EXEC_6A_0T_1R),
 /* 7C */ ACPI_OP ("DataTableRegion",    ARGP_DATA_REGION_OP,       ARGI_DATA_REGION_OP,        ACPI_TYPE_REGION,        AML_CLASS_NAMED_OBJECT,    AML_TYPE_NAMED_SIMPLE,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSOPCODE | AML_NSNODE | AML_NAMED),
@@ -702,6 +702,7 @@
 		}
 
 		/* Else fall through to error case below */
+		/*lint -fallthrough */
 
 	default:
 
@@ -749,5 +750,4 @@
 
 #endif
 }
-
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/parser/psparse.c linux/drivers/acpi/parser/psparse.c
--- ../prev/linux/drivers/acpi/parser/psparse.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/parser/psparse.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: psparse - Parser top level AML parse routines
- *              $Revision: 121 $
+ *              $Revision: 127 $
  *
  *****************************************************************************/
 
@@ -38,15 +38,13 @@
 #include "acdispat.h"
 #include "amlcode.h"
 #include "acnamesp.h"
-#include "acdebug.h"
 #include "acinterp.h"
 
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("psparse")
 
 
-u32                         acpi_gbl_depth = 0;
-extern u32                  acpi_gbl_scope_depth;
+static u32                  acpi_gbl_depth = 0;
 
 
 /*******************************************************************************
@@ -172,13 +170,13 @@
  * PARAMETERS:  Walk_state      - Current State
  *              Op              - Op to complete
  *
- * RETURN:      TRUE if Op and subtree was deleted
+ * RETURN:      None.
  *
  * DESCRIPTION: Perform any cleanup at the completion of an Op.
  *
  ******************************************************************************/
 
-u8
+void
 acpi_ps_complete_this_op (
 	acpi_walk_state         *walk_state,
 	acpi_parse_object       *op)
@@ -196,7 +194,7 @@
 	/* Check for null Op, can happen if AML code is corrupt */
 
 	if (!op) {
-		return_VALUE (TRUE);
+		return_VOID;
 	}
 
 	/* Delete this op and the subtree below it if asked to */
@@ -205,12 +203,12 @@
 		(walk_state->op_info->class != AML_CLASS_ARGUMENT)) {
 		/* Make sure that we only delete this subtree */
 
-		if (op->parent) {
+		if (op->common.parent) {
 			/*
 			 * Check if we need to replace the operator and its subtree
 			 * with a return value op (placeholder op)
 			 */
-			parent_info = acpi_ps_get_opcode_info (op->parent->opcode);
+			parent_info = acpi_ps_get_opcode_info (op->common.parent->common.aml_opcode);
 
 			switch (parent_info->class) {
 			case AML_CLASS_CONTROL:
@@ -224,7 +222,7 @@
 				 */
 				replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 				if (!replacement_op) {
-					return_VALUE (FALSE);
+					return_VOID;
 				}
 				break;
 
@@ -234,31 +232,29 @@
 				 * These opcodes contain Term_arg operands. The current
 				 * op must be replaced by a placeholder return op
 				 */
-				if ((op->parent->opcode == AML_REGION_OP)       ||
-					(op->parent->opcode == AML_DATA_REGION_OP)  ||
-					(op->parent->opcode == AML_BUFFER_OP)       ||
-					(op->parent->opcode == AML_PACKAGE_OP)      ||
-					(op->parent->opcode == AML_VAR_PACKAGE_OP)) {
+				if ((op->common.parent->common.aml_opcode == AML_REGION_OP)      ||
+					(op->common.parent->common.aml_opcode == AML_DATA_REGION_OP) ||
+					(op->common.parent->common.aml_opcode == AML_BUFFER_OP)      ||
+					(op->common.parent->common.aml_opcode == AML_PACKAGE_OP)     ||
+					(op->common.parent->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
 					replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 					if (!replacement_op) {
-						return_VALUE (FALSE);
+						return_VOID;
 					}
 				}
 
-				if ((op->parent->opcode == AML_NAME_OP) &&
+				if ((op->common.parent->common.aml_opcode == AML_NAME_OP) &&
 					(walk_state->descending_callback != acpi_ds_exec_begin_op)) {
-					if ((op->opcode == AML_BUFFER_OP) ||
-						(op->opcode == AML_PACKAGE_OP) ||
-						(op->opcode == AML_VAR_PACKAGE_OP)) {
-						replacement_op = acpi_ps_alloc_op (op->opcode);
+					if ((op->common.aml_opcode == AML_BUFFER_OP) ||
+						(op->common.aml_opcode == AML_PACKAGE_OP) ||
+						(op->common.aml_opcode == AML_VAR_PACKAGE_OP)) {
+						replacement_op = acpi_ps_alloc_op (op->common.aml_opcode);
 						if (!replacement_op) {
-							return_VALUE (FALSE);
+							return_VOID;
 						}
 
-						((acpi_parse2_object *) replacement_op)->data =
-							((acpi_parse2_object *) op)->data;
-						((acpi_parse2_object *) replacement_op)->length =
-							((acpi_parse2_object *) op)->length;
+						replacement_op->named.data = op->named.data;
+						replacement_op->named.length = op->named.length;
 					}
 				}
 				break;
@@ -266,25 +262,25 @@
 			default:
 				replacement_op = acpi_ps_alloc_op (AML_INT_RETURN_VALUE_OP);
 				if (!replacement_op) {
-					return_VALUE (FALSE);
+					return_VOID;
 				}
 			}
 
 			/* We must unlink this op from the parent tree */
 
-			prev = op->parent->value.arg;
+			prev = op->common.parent->common.value.arg;
 			if (prev == op) {
 				/* This op is the first in the list */
 
 				if (replacement_op) {
-					replacement_op->parent   = op->parent;
-					replacement_op->value.arg = NULL;
-					replacement_op->node     = op->node;
-					op->parent->value.arg    = replacement_op;
-					replacement_op->next     = op->next;
+					replacement_op->common.parent       = op->common.parent;
+					replacement_op->common.value.arg    = NULL;
+					replacement_op->common.node         = op->common.node;
+					op->common.parent->common.value.arg = replacement_op;
+					replacement_op->common.next         = op->common.next;
 				}
 				else {
-					op->parent->value.arg    = op->next;
+					op->common.parent->common.value.arg    = op->common.next;
 				}
 			}
 
@@ -293,18 +289,18 @@
 			else while (prev) {
 				/* Traverse all siblings in the parent's argument list */
 
-				next = prev->next;
+				next = prev->common.next;
 				if (next == op) {
 					if (replacement_op) {
-						replacement_op->parent   = op->parent;
-						replacement_op->value.arg = NULL;
-						replacement_op->node     = op->node;
-						prev->next               = replacement_op;
-						replacement_op->next     = op->next;
+						replacement_op->common.parent   = op->common.parent;
+						replacement_op->common.value.arg = NULL;
+						replacement_op->common.node     = op->common.node;
+						prev->common.next               = replacement_op;
+						replacement_op->common.next     = op->common.next;
 						next = NULL;
 					}
 					else {
-						prev->next = op->next;
+						prev->common.next = op->common.next;
 						next = NULL;
 					}
 				}
@@ -317,13 +313,13 @@
 
 		acpi_ps_delete_parse_tree (op);
 
-		return_VALUE (TRUE);
+		return_VOID;
 	}
 
-	return_VALUE (FALSE);
+	return_VOID;
 
 #else
-	return (FALSE);
+	return;
 #endif
 }
 
@@ -422,7 +418,7 @@
 		status = AE_CTRL_TRANSFER;
 		walk_state->prev_op = op;
 		walk_state->method_call_op = op;
-		walk_state->method_call_node = (op->value.arg)->node;
+		walk_state->method_call_node = (op->common.value.arg)->common.node;
 
 		/* Will return value (if any) be used by the caller? */
 
@@ -469,6 +465,10 @@
 
 	ACPI_FUNCTION_TRACE_PTR ("Ps_parse_loop", walk_state);
 
+	if (walk_state->descending_callback == NULL) {
+		return_ACPI_STATUS (AE_BAD_PARAMETER);
+	}
+
 
 	parser_state = &walk_state->parser_state;
 	walk_state->arg_types = 0;
@@ -483,8 +483,8 @@
 			 * was just completed
 			 */
 			if ((parser_state->scope->parse_scope.op) &&
-			   ((parser_state->scope->parse_scope.op->opcode == AML_IF_OP) ||
-				(parser_state->scope->parse_scope.op->opcode == AML_WHILE_OP)) &&
+			   ((parser_state->scope->parse_scope.op->common.aml_opcode == AML_IF_OP) ||
+				(parser_state->scope->parse_scope.op->common.aml_opcode == AML_WHILE_OP)) &&
 				(walk_state->control_state) &&
 				(walk_state->control_state->common.state ==
 					ACPI_CONTROL_PREDICATE_EXECUTING)) {
@@ -526,12 +526,12 @@
 	 * Iterative parsing loop, while there is more aml to process:
 	 */
 	while ((parser_state->aml < parser_state->aml_end) || (op)) {
+		aml_op_start = parser_state->aml;
 		if (!op) {
 			/* Get the next opcode from the AML stream */
 
-			aml_op_start = parser_state->aml;
-			walk_state->aml_offset = parser_state->aml - parser_state->aml_start;
-			walk_state->opcode    = acpi_ps_peek_opcode (parser_state);
+			walk_state->aml_offset = ACPI_PTR_DIFF (parser_state->aml, parser_state->aml_start);
+			walk_state->opcode   = acpi_ps_peek_opcode (parser_state);
 
 			/*
 			 * First cut to determine what we have found:
@@ -578,8 +578,8 @@
 			/* Create Op structure and append to parent's argument list */
 
 			if (walk_state->op_info->flags & AML_NAMED) {
-				pre_op.value.arg = NULL;
-				pre_op.opcode = walk_state->opcode;
+				pre_op.common.value.arg = NULL;
+				pre_op.common.aml_opcode = walk_state->opcode;
 
 				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) != ARGP_NAME) {
 					arg = acpi_ps_get_next_arg (parser_state,
@@ -593,39 +593,37 @@
 
 				INCREMENT_ARG_LIST (walk_state->arg_types);
 
-				if (walk_state->descending_callback != NULL) {
-					/*
-					 * Find the object.  This will either insert the object into
-					 * the namespace or simply look it up
-					 */
-					walk_state->op = NULL;
+				/*
+				 * Find the object.  This will either insert the object into
+				 * the namespace or simply look it up
+				 */
+				walk_state->op = NULL;
 
-					status = walk_state->descending_callback (walk_state, &op);
-					if (ACPI_FAILURE (status)) {
-						ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "During name lookup/catalog, %s\n",
-								acpi_format_exception (status)));
-						goto close_this_op;
-					}
+				status = walk_state->descending_callback (walk_state, &op);
+				if (ACPI_FAILURE (status)) {
+					ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "During name lookup/catalog, %s\n",
+							acpi_format_exception (status)));
+					goto close_this_op;
+				}
 
-					if (op == NULL) {
-						continue;
-					}
+				if (op == NULL) {
+					continue;
+				}
 
-					status = acpi_ps_next_parse_state (walk_state, op, status);
-					if (status == AE_CTRL_PENDING) {
-						status = AE_OK;
-						goto close_this_op;
-					}
+				status = acpi_ps_next_parse_state (walk_state, op, status);
+				if (status == AE_CTRL_PENDING) {
+					status = AE_OK;
+					goto close_this_op;
+				}
 
-					if (ACPI_FAILURE (status)) {
-						goto close_this_op;
-					}
+				if (ACPI_FAILURE (status)) {
+					goto close_this_op;
 				}
 
-				acpi_ps_append_arg (op, pre_op.value.arg);
+				acpi_ps_append_arg (op, pre_op.common.value.arg);
 				acpi_gbl_depth++;
 
-				if (op->opcode == AML_REGION_OP) {
+				if (op->common.aml_opcode == AML_REGION_OP) {
 					/*
 					 * Defer final parsing of an Operation_region body,
 					 * because we don't have enough info in the first pass
@@ -638,8 +636,8 @@
 					 *
 					 * (Length is unknown until parse of the body complete)
 					 */
-					((acpi_parse2_object * ) op)->data    = aml_op_start;
-					((acpi_parse2_object * ) op)->length  = 0;
+					op->named.data    = aml_op_start;
+					op->named.length  = 0;
 				}
 			}
 			else {
@@ -656,8 +654,8 @@
 					 * Backup to beginning of Create_xXXfield declaration
 					 * Body_length is unknown until we parse the body
 					 */
-					((acpi_parse2_object * ) op)->data    = aml_op_start;
-					((acpi_parse2_object * ) op)->length  = 0;
+					op->named.data    = aml_op_start;
+					op->named.length  = 0;
 				}
 
 				acpi_ps_append_arg (acpi_ps_get_parent_scope (parser_state), op);
@@ -682,12 +680,13 @@
 				}
 			}
 
-			op->aml_offset = walk_state->aml_offset;
+			op->common.aml_offset = walk_state->aml_offset;
 
 			if (walk_state->op_info) {
 				ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
-					"Opcode %4.4X [%s] Op %p Aml %p Aml_offset %5.5X\n",
-					 op->opcode, walk_state->op_info->name, op, parser_state->aml, op->aml_offset));
+					"Opcode %4.4hX [%s] Op %p Aml %p Aml_offset %5.5X\n",
+					 op->common.aml_opcode, walk_state->op_info->name,
+					 op, parser_state->aml, op->common.aml_offset));
 			}
 		}
 
@@ -699,7 +698,7 @@
 		if (walk_state->arg_types) /* Are there any arguments that must be processed? */ {
 			/* Get arguments */
 
-			switch (op->opcode) {
+			switch (op->common.aml_opcode) {
 			case AML_BYTE_OP:       /* AML_BYTEDATA_ARG */
 			case AML_WORD_OP:       /* AML_WORDDATA_ARG */
 			case AML_DWORD_OP:      /* AML_DWORDATA_ARG */
@@ -724,19 +723,20 @@
 				/* Op is not a constant or string, append each argument */
 
 				while (GET_CURRENT_ARG_TYPE (walk_state->arg_types) && !walk_state->arg_count) {
-					walk_state->aml_offset = parser_state->aml - parser_state->aml_start;
+					walk_state->aml_offset = ACPI_PTR_DIFF (parser_state->aml,
+							   parser_state->aml_start);
 					arg = acpi_ps_get_next_arg (parser_state,
 							 GET_CURRENT_ARG_TYPE (walk_state->arg_types),
 							 &walk_state->arg_count);
 					if (arg) {
-						arg->aml_offset = walk_state->aml_offset;
+						arg->common.aml_offset = walk_state->aml_offset;
 						acpi_ps_append_arg (op, arg);
 					}
 
 					INCREMENT_ARG_LIST (walk_state->arg_types);
 				}
 
-				switch (op->opcode) {
+				switch (op->common.aml_opcode) {
 				case AML_METHOD_OP:
 
 					/* For a method, save the length and address of the body */
@@ -746,9 +746,8 @@
 					 * because we don't have enough info in the first pass
 					 * to parse them correctly.
 					 */
-					((acpi_parse2_object * ) op)->data   = parser_state->aml;
-					((acpi_parse2_object * ) op)->length = (u32) (parser_state->pkg_end -
-							  parser_state->aml);
+					op->named.data   = parser_state->aml;
+					op->named.length = (u32) (parser_state->pkg_end - parser_state->aml);
 					/*
 					 * Skip body of method.  For Op_regions, we must continue
 					 * parsing because the opregion is not a standalone
@@ -762,17 +761,16 @@
 				case AML_PACKAGE_OP:
 				case AML_VAR_PACKAGE_OP:
 
-					if ((op->parent) &&
-						(op->parent->opcode == AML_NAME_OP) &&
+					if ((op->common.parent) &&
+						(op->common.parent->common.aml_opcode == AML_NAME_OP) &&
 						(walk_state->descending_callback != acpi_ds_exec_begin_op)) {
 						/*
 						 * Skip parsing of
 						 * because we don't have enough info in the first pass
 						 * to parse them correctly.
 						 */
-						((acpi_parse2_object * ) op)->data   = aml_op_start;
-						((acpi_parse2_object * ) op)->length = (u32) (parser_state->pkg_end -
-								  aml_op_start);
+						op->named.data   = aml_op_start;
+						op->named.length = (u32) (parser_state->pkg_end - aml_op_start);
 						/*
 						 * Skip body
 						 */
@@ -787,6 +785,10 @@
 						walk_state->control_state->control.package_end = parser_state->pkg_end;
 					}
 					break;
+
+				default:
+					/* No action for all other opcodes */
+					break;
 				}
 				break;
 			}
@@ -797,20 +799,23 @@
 		if (walk_state->arg_count) {
 			/* There are arguments (complex ones), push Op and prepare for argument */
 
-			acpi_ps_push_scope (parser_state, op, walk_state->arg_types, walk_state->arg_count);
+			status = acpi_ps_push_scope (parser_state, op, walk_state->arg_types, walk_state->arg_count);
+			if (ACPI_FAILURE (status)) {
+				return_ACPI_STATUS (status);
+			}
 			op = NULL;
 			continue;
 		}
 
 		/* All arguments have been processed -- Op is complete, prepare for next */
 
-		walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
+		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 		if (walk_state->op_info->flags & AML_NAMED) {
 			if (acpi_gbl_depth) {
 				acpi_gbl_depth--;
 			}
 
-			if (op->opcode == AML_REGION_OP) {
+			if (op->common.aml_opcode == AML_REGION_OP) {
 				/*
 				 * Skip parsing of control method or opregion body,
 				 * because we don't have enough info in the first pass
@@ -819,8 +824,7 @@
 				 * Completed parsing an Op_region declaration, we now
 				 * know the length.
 				 */
-				((acpi_parse2_object * ) op)->length = (u32) (parser_state->aml -
-						   ((acpi_parse2_object * ) op)->data);
+				op->named.length = (u32) (parser_state->aml - op->named.data);
 			}
 		}
 
@@ -831,15 +835,14 @@
 			 *
 			 * Body_length is unknown until we parse the body
 			 */
-			((acpi_parse2_object * ) op)->length = (u32) (parser_state->aml -
-					   ((acpi_parse2_object * ) op)->data);
+			op->named.length = (u32) (parser_state->aml - op->named.data);
 		}
 
 		/* This op complete, notify the dispatcher */
 
 		if (walk_state->ascending_callback != NULL) {
 			walk_state->op    = op;
-			walk_state->opcode = op->opcode;
+			walk_state->opcode = op->common.aml_opcode;
 
 			status = walk_state->ascending_callback (walk_state);
 			status = acpi_ps_next_parse_state (walk_state, op, status);
@@ -856,11 +859,10 @@
 		 */
 		parser_state->scope->parse_scope.arg_count--;
 
-		/* Close this Op (may result in parse subtree deletion) */
+		/* Close this Op (will result in parse subtree deletion) */
 
-		if (acpi_ps_complete_this_op (walk_state, op)) {
-			op = NULL;
-		}
+		acpi_ps_complete_this_op (walk_state, op);
+		op = NULL;
 
 		switch (status) {
 		case AE_OK:
@@ -882,8 +884,8 @@
 			acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
 
 			walk_state->op    = op;
-			walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-			walk_state->opcode = op->opcode;
+			walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+			walk_state->opcode = op->common.aml_opcode;
 
 			status = walk_state->ascending_callback (walk_state);
 			status = acpi_ps_next_parse_state (walk_state, op, status);
@@ -899,15 +901,15 @@
 
 			/* Pop off scopes until we find the While */
 
-			while (!op || (op->opcode != AML_WHILE_OP)) {
+			while (!op || (op->common.aml_opcode != AML_WHILE_OP)) {
 				acpi_ps_pop_scope (parser_state, &op, &walk_state->arg_types, &walk_state->arg_count);
 			}
 
 			/* Close this iteration of the While loop */
 
 			walk_state->op    = op;
-			walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-			walk_state->opcode = op->opcode;
+			walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+			walk_state->opcode = op->common.aml_opcode;
 
 			status = walk_state->ascending_callback (walk_state);
 			status = acpi_ps_next_parse_state (walk_state, op, status);
@@ -983,8 +985,8 @@
 		if (op) {
 			if (walk_state->ascending_callback != NULL) {
 				walk_state->op    = op;
-				walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-				walk_state->opcode = op->opcode;
+				walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+				walk_state->opcode = op->common.aml_opcode;
 
 				status = walk_state->ascending_callback (walk_state);
 				status = acpi_ps_next_parse_state (walk_state, op, status);
@@ -1125,7 +1127,13 @@
 		 * there's lots of cleanup to do
 		 */
 		if ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) == ACPI_PARSE_EXECUTE) {
-			acpi_ds_terminate_control_method (walk_state);
+			status = acpi_ds_terminate_control_method (walk_state);
+			if (ACPI_FAILURE (status)) {
+				ACPI_REPORT_ERROR (("Could not terminate control method properly\n"));
+				status = AE_OK;
+
+				/* Ignore error and continue */
+			}
 		}
 
 		/* Delete this walk state and all linked control states */
@@ -1147,8 +1155,10 @@
 				 * If the method return value is not used by the parent,
 				 * The object is deleted
 				 */
-				acpi_ds_restart_control_method (walk_state, previous_walk_state->return_desc);
-				walk_state->walk_type |= ACPI_WALK_METHOD_RESTART;
+				status = acpi_ds_restart_control_method (walk_state, previous_walk_state->return_desc);
+				if (ACPI_SUCCESS (status)) {
+					walk_state->walk_type |= ACPI_WALK_METHOD_RESTART;
+				}
 			}
 			else {
 				/* On error, delete any return object */
@@ -1181,7 +1191,7 @@
 	/* Normal exit */
 
 	acpi_ex_release_all_mutexes (thread);
-	acpi_ut_delete_generic_state ((acpi_generic_state *) thread);
+	acpi_ut_delete_generic_state (ACPI_CAST_PTR (acpi_generic_state, thread));
 	acpi_gbl_current_walk_list = prev_walk_list;
 	return_ACPI_STATUS (status);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/parser/pstree.c linux/drivers/acpi/parser/pstree.c
--- ../prev/linux/drivers/acpi/parser/pstree.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/parser/pstree.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: pstree - Parser op tree manipulation/traversal/search
- *              $Revision: 37 $
+ *              $Revision: 39 $
  *
  *****************************************************************************/
 
@@ -59,7 +59,7 @@
 
 	/* Get the info structure for this opcode */
 
-	op_info = acpi_ps_get_opcode_info (op->opcode);
+	op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 	if (op_info->class == AML_CLASS_UNKNOWN) {
 		/* Invalid opcode or ASCII character */
 
@@ -76,10 +76,10 @@
 
 	/* Get the requested argument object */
 
-	arg = op->value.arg;
+	arg = op->common.value.arg;
 	while (arg && argn) {
 		argn--;
-		arg = arg->next;
+		arg = arg->common.next;
 	}
 
 	return (arg);
@@ -117,11 +117,12 @@
 
 	/* Get the info structure for this opcode */
 
-	op_info = acpi_ps_get_opcode_info (op->opcode);
+	op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
 	if (op_info->class == AML_CLASS_UNKNOWN) {
 		/* Invalid opcode */
 
-		ACPI_REPORT_ERROR (("Ps_append_arg: Invalid AML Opcode: 0x%2.2X\n", op->opcode));
+		ACPI_REPORT_ERROR (("Ps_append_arg: Invalid AML Opcode: 0x%2.2X\n",
+			op->common.aml_opcode));
 		return;
 	}
 
@@ -136,28 +137,28 @@
 
 	/* Append the argument to the linked argument list */
 
-	if (op->value.arg) {
+	if (op->common.value.arg) {
 		/* Append to existing argument list */
 
-		prev_arg = op->value.arg;
-		while (prev_arg->next) {
-			prev_arg = prev_arg->next;
+		prev_arg = op->common.value.arg;
+		while (prev_arg->common.next) {
+			prev_arg = prev_arg->common.next;
 		}
-		prev_arg->next = arg;
+		prev_arg->common.next = arg;
 	}
 
 	else {
 		/* No argument list, this will be the first argument */
 
-		op->value.arg = arg;
+		op->common.value.arg = arg;
 	}
 
 
 	/* Set the parent in this arg and any args linked after it */
 
 	while (arg) {
-		arg->parent = op;
-		arg = arg->next;
+		arg->common.parent = op;
+		arg = arg->common.next;
 	}
 }
 
@@ -184,7 +185,7 @@
 	ACPI_FUNCTION_ENTRY ();
 
 
-	switch (op->opcode) {
+	switch (op->common.aml_opcode) {
 	case AML_SCOPE_OP:
 	case AML_ELSE_OP:
 	case AML_DEVICE_OP:
@@ -219,6 +220,10 @@
 		child = acpi_ps_get_arg (op, 3);
 		break;
 
+
+	default:
+		/* All others have no children */
+		break;
 	}
 
 	return (child);
@@ -265,19 +270,19 @@
 
 	/* look for a sibling */
 
-	next = op->next;
+	next = op->common.next;
 	if (next) {
 		return (next);
 	}
 
 	/* look for a sibling of parent */
 
-	parent = op->parent;
+	parent = op->common.parent;
 
 	while (parent) {
 		arg = acpi_ps_get_arg (parent, 0);
 		while (arg && (arg != origin) && (arg != op)) {
-			arg = arg->next;
+			arg = arg->common.next;
 		}
 
 		if (arg == origin) {
@@ -286,13 +291,14 @@
 			return (NULL);
 		}
 
-		if (parent->next) {
+		if (parent->common.next) {
 			/* found sibling of parent */
-			return (parent->next);
+
+			return (parent->common.next);
 		}
 
 		op = parent;
-		parent = parent->parent;
+		parent = parent->common.parent;
 	}
 
 	return (next);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/parser/psutils.c linux/drivers/acpi/parser/psutils.c
--- ../prev/linux/drivers/acpi/parser/psutils.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/parser/psutils.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: psutils - Parser miscellaneous utilities (Parser only)
- *              $Revision: 50 $
+ *              $Revision: 51 $
  *
  *****************************************************************************/
 
@@ -54,11 +54,11 @@
 	ACPI_FUNCTION_ENTRY ();
 
 
-	op->data_type = ACPI_DESC_TYPE_PARSER;
-	op->opcode = opcode;
+	op->common.data_type = ACPI_DESC_TYPE_PARSER;
+	op->common.aml_opcode = opcode;
 
-	ACPI_DEBUG_ONLY_MEMBERS (ACPI_STRNCPY (op->op_name,
-			(acpi_ps_get_opcode_info (opcode))->name, sizeof (op->op_name)));
+	ACPI_DEBUG_ONLY_MEMBERS (ACPI_STRNCPY (op->common.aml_op_name,
+			(acpi_ps_get_opcode_info (opcode))->name, sizeof (op->common.aml_op_name)));
 }
 
 
@@ -94,23 +94,23 @@
 	/* Allocate the minimum required size object */
 
 	if (op_info->flags & AML_DEFER) {
-		size = sizeof (acpi_parse2_object);
+		size = sizeof (ACPI_PARSE_OBJ_NAMED);
 		flags = ACPI_PARSEOP_DEFERRED;
 	}
 	else if (op_info->flags & AML_NAMED) {
-		size = sizeof (acpi_parse2_object);
+		size = sizeof (ACPI_PARSE_OBJ_NAMED);
 		flags = ACPI_PARSEOP_NAMED;
 	}
 	else if (opcode == AML_INT_BYTELIST_OP) {
-		size = sizeof (acpi_parse2_object);
+		size = sizeof (ACPI_PARSE_OBJ_NAMED);
 		flags = ACPI_PARSEOP_BYTELIST;
 	}
 	else {
-		size = sizeof (acpi_parse_object);
+		size = sizeof (ACPI_PARSE_OBJ_COMMON);
 		flags = ACPI_PARSEOP_GENERIC;
 	}
 
-	if (size == sizeof (acpi_parse_object)) {
+	if (size == sizeof (ACPI_PARSE_OBJ_COMMON)) {
 		/*
 		 * The generic op is by far the most common (16 to 1)
 		 */
@@ -124,7 +124,7 @@
 
 	if (op) {
 		acpi_ps_init_op (op, opcode);
-		op->flags = flags;
+		op->common.flags = flags;
 	}
 
 	return (op);
@@ -151,11 +151,11 @@
 	ACPI_FUNCTION_NAME ("Ps_free_op");
 
 
-	if (op->opcode == AML_INT_RETURN_VALUE_OP) {
+	if (op->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Free retval op: %p\n", op));
 	}
 
-	if (op->flags == ACPI_PARSEOP_GENERIC) {
+	if (op->common.flags == ACPI_PARSEOP_GENERIC) {
 		acpi_ut_release_to_cache (ACPI_MEM_LIST_PSNODE, op);
 	}
 	else {
@@ -231,13 +231,13 @@
 
 	/* The "generic" object has no name associated with it */
 
-	if (op->flags & ACPI_PARSEOP_GENERIC) {
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
 		return (0);
 	}
 
 	/* Only the "Extended" parse objects have a name */
 
-	return (((acpi_parse2_object *) op)->name);
+	return (op->named.name);
 }
 
 
@@ -252,10 +252,10 @@
 
 	/* The "generic" object has no name associated with it */
 
-	if (op->flags & ACPI_PARSEOP_GENERIC) {
+	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
 		return;
 	}
 
-	((acpi_parse2_object *) op)->name = name;
+	op->named.name = name;
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/parser/pswalk.c linux/drivers/acpi/parser/pswalk.c
--- ../prev/linux/drivers/acpi/parser/pswalk.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/parser/pswalk.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: pswalk - Parser routines to walk parsed op tree(s)
- *              $Revision: 63 $
+ *              $Revision: 67 $
  *
  *****************************************************************************/
 
@@ -25,11 +25,8 @@
 
 
 #include "acpi.h"
-#include "amlcode.h"
 #include "acparser.h"
 #include "acdispat.h"
-#include "acnamesp.h"
-#include "acinterp.h"
 
 #define _COMPONENT          ACPI_PARSER
 	 ACPI_MODULE_NAME    ("pswalk")
@@ -84,12 +81,12 @@
 		 * No more children, this Op is complete.  Save Next and Parent
 		 * in case the Op object gets deleted by the callback routine
 		 */
-		next    = op->next;
-		parent  = op->parent;
+		next    = op->common.next;
+		parent  = op->common.parent;
 
 		walk_state->op    = op;
-		walk_state->op_info = acpi_ps_get_opcode_info (op->opcode);
-		walk_state->opcode = op->opcode;
+		walk_state->op_info = acpi_ps_get_opcode_info (op->common.aml_opcode);
+		walk_state->opcode = op->common.aml_opcode;
 
 		status = ascending_callback (walk_state);
 
@@ -142,12 +139,12 @@
 	while (parent) {
 		/* We are moving up the tree, therefore this parent Op is complete */
 
-		grand_parent = parent->parent;
-		next        = parent->next;
+		grand_parent = parent->common.parent;
+		next        = parent->common.next;
 
 		walk_state->op    = parent;
-		walk_state->op_info = acpi_ps_get_opcode_info (parent->opcode);
-		walk_state->opcode = parent->opcode;
+		walk_state->op_info = acpi_ps_get_opcode_info (parent->common.aml_opcode);
+		walk_state->opcode = parent->common.aml_opcode;
 
 		status = ascending_callback (walk_state);
 
@@ -238,6 +235,7 @@
 {
 	acpi_walk_state         *walk_state;
 	ACPI_THREAD_STATE       *thread;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE_PTR ("Ps_delete_parse_tree", subtree_root);
@@ -254,7 +252,6 @@
 		return_VOID;
 	}
 
-
 	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT, NULL, NULL, thread);
 	if (!walk_state) {
 		return_VOID;
@@ -274,13 +271,16 @@
 	/* Visit all nodes in the subtree */
 
 	while (walk_state->next_op) {
-		acpi_ps_get_next_walk_op (walk_state, walk_state->next_op,
+		status = acpi_ps_get_next_walk_op (walk_state, walk_state->next_op,
 				 acpi_ps_delete_completed_op);
+		if (ACPI_FAILURE (status)) {
+			break;
+		}
 	}
 
 	/* We are done with this walk */
 
-	acpi_ut_delete_generic_state ((acpi_generic_state *) thread);
+	acpi_ut_delete_generic_state (ACPI_CAST_PTR (acpi_generic_state, thread));
 	acpi_ds_delete_walk_state (walk_state);
 
 	return_VOID;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/parser/psxface.c linux/drivers/acpi/parser/psxface.c
--- ../prev/linux/drivers/acpi/parser/psxface.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/parser/psxface.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: psxface - Parser external interfaces
- *              $Revision: 61 $
+ *              $Revision: 64 $
  *
  *****************************************************************************/
 
@@ -140,7 +140,6 @@
 	status = acpi_ps_parse_aml (walk_state);
 	acpi_ps_delete_parse_tree (op);
 
-
 	/*
 	 * 2) Execute the method.  Performs second pass parse simultaneously
 	 */
@@ -158,12 +157,11 @@
 	/* Init new op with the method name and pointer back to the NS node */
 
 	acpi_ps_set_name (op, method_node->name.integer);
-	op->node = method_node;
+	op->common.node = method_node;
 
 	/* Create and initialize a new walk state */
 
-	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT,
-			   NULL, NULL, NULL);
+	walk_state = acpi_ds_create_walk_state (TABLE_ID_DSDT, NULL, NULL, NULL);
 	if (!walk_state) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
@@ -185,7 +183,9 @@
 		/* Take away the extra reference that we gave the parameters above */
 
 		for (i = 0; params[i]; i++) {
-			acpi_ut_update_object_reference (params[i], REF_DECREMENT);
+			/* Ignore errors, just do them all */
+
+			(void) acpi_ut_update_object_reference (params[i], REF_DECREMENT);
 		}
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/pci_bind.c linux/drivers/acpi/pci_bind.c
--- ../prev/linux/drivers/acpi/pci_bind.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/pci_bind.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,309 @@
+/*
+ *  pci_bind.c - ACPI PCI Device Binding ($Revision: 1 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_bind")
+
+#define PREFIX			"ACPI: "
+
+
+struct acpi_pci_data {
+	acpi_pci_id		id;
+	struct pci_bus		*bus;
+	struct pci_dev		*dev;
+};
+
+
+void
+acpi_pci_data_handler (
+	acpi_handle		handle,
+	u32			function,
+	void			*context)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_data_handler");
+
+	/* TBD: Anything we need to do here? */
+
+	return_VOID;
+}
+
+
+/**
+ * acpi_os_get_pci_id
+ * ------------------
+ * This function is used by the ACPI Interpreter (a.k.a. Core Subsystem)
+ * to resolve PCI information for ACPI-PCI devices defined in the namespace.
+ * This typically occurs when resolving PCI operation region information.
+ */
+acpi_status
+acpi_os_get_pci_id (
+	acpi_handle		handle,
+	acpi_pci_id		*id)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_pci_data	*data = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_os_get_pci_id");
+
+	if (!id)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (0 != result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid ACPI Bus context for device %s\n",
+			acpi_device_bid(device)));
+		return_ACPI_STATUS(AE_NOT_EXIST);
+	}
+
+	status = acpi_get_data(handle, acpi_pci_data_handler, (void**) &data);
+	if (ACPI_FAILURE(status) || !data || !data->dev) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid ACPI-PCI context for device %s\n",
+			acpi_device_bid(device)));
+		return_ACPI_STATUS(status);
+	}
+
+	*id = data->id;
+	
+	/*
+	id->segment = data->id.segment;
+	id->bus = data->id.bus;
+	id->device = data->id.device;
+	id->function = data->id.function;
+	*/
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Device %s has PCI address %02x:%02x:%02x.%02x\n", 
+		acpi_device_bid(device), id->segment, id->bus, 
+		id->device, id->function));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+	
+int
+acpi_pci_bind (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_pci_data	*data = NULL;
+	struct acpi_pci_data	*pdata = NULL;
+	char			pathname[PATHNAME_MAX] = {0};
+	acpi_buffer		buffer = {PATHNAME_MAX, pathname};
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_bind");
+
+	if (!device || !device->parent)
+		return_VALUE(-EINVAL);
+
+	data = kmalloc(sizeof(struct acpi_pci_data), GFP_KERNEL);
+	if (!data)
+		return_VALUE(-ENOMEM);
+	memset(data, 0, sizeof(struct acpi_pci_data));
+
+	acpi_get_name(device->handle, ACPI_FULL_PATHNAME, &buffer);
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Binding PCI device [%s]...\n", 
+		pathname));
+
+	/* 
+	 * Segment & Bus
+	 * -------------
+	 * These are obtained via the parent device's ACPI-PCI context.
+	 */
+	status = acpi_get_data(device->parent->handle, acpi_pci_data_handler, 
+		(void**) &pdata);
+	if (ACPI_FAILURE(status) || !pdata || !pdata->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid ACPI-PCI context for parent device %s\n",
+			acpi_device_bid(device->parent)));
+		result = -ENODEV;
+		goto end;
+	}
+	data->id.segment = pdata->id.segment;
+	data->id.bus = pdata->bus->number;
+
+	/*
+	 * Device & Function
+	 * -----------------
+	 * These are simply obtained from the device's _ADR method.  Note
+	 * that a value of zero is valid.
+	 */
+	data->id.device = device->pnp.bus_address >> 16;
+	data->id.function = device->pnp.bus_address & 0xFFFF;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "...to %02x:%02x:%02x.%02x\n",
+		data->id.segment, data->id.bus, data->id.device, 
+		data->id.function));
+
+	/*
+	 * TBD: Support slot devices (e.g. function=0xFFFF).
+	 */
+
+	/* 
+	 * Locate PCI Device
+	 * -----------------
+	 * Locate matching device in PCI namespace.  If it doesn't exist
+	 * this typically means that the device isn't currently inserted
+	 * (e.g. docking station, port replicator, etc.).
+	 */
+	data->dev = pci_find_slot(data->id.bus, PCI_DEVFN(data->id.device, data->id.function));
+	if (!data->dev) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Device %02x:%02x:%02x.%02x not present in PCI namespace\n",
+			data->id.segment, data->id.bus, 
+			data->id.device, data->id.function));
+		result = -ENODEV;
+		goto end;
+	}
+	if (!data->dev->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Device %02x:%02x:%02x.%02x has invalid 'bus' field\n",
+			data->id.segment, data->id.bus, 
+			data->id.device, data->id.function));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * PCI Bridge?
+	 * -----------
+	 * If so, set the 'bus' field and install the 'bind' function to 
+	 * facilitate callbacks for all of its children.
+	 */
+	if (data->dev->subordinate) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Device %02x:%02x:%02x.%02x is a PCI bridge\n",
+			data->id.segment, data->id.bus, 
+			data->id.device, data->id.function));
+		data->bus = data->dev->subordinate;
+		device->ops.bind = acpi_pci_bind;
+	}
+
+	/*
+	 * Attach ACPI-PCI Context
+	 * -----------------------
+	 * Thus binding the ACPI and PCI devices.
+	 */
+	status = acpi_attach_data(device->handle, acpi_pci_data_handler, data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to attach ACPI-PCI context to device %s\n",
+			acpi_device_bid(device)));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * PCI Routing Table
+	 * -----------------
+	 * Evaluate and parse _PRT, if exists.  This code is independent of 
+	 * PCI bridges (above) to allow parsing of _PRT objects within the
+	 * scope of non-bridge devices.  Note that _PRTs within the scope of
+	 * a PCI bridge assume the bridge's subordinate bus number.
+	 *
+	 * TBD: Can _PRTs exist within the scope of non-bridge PCI devices?
+	 */
+	status = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);
+	if (ACPI_SUCCESS(status)) {
+		if (data->bus)				    /* PCI-PCI bridge */
+			acpi_pci_irq_add_prt(device->handle, data->id.segment, 
+				data->bus->number);
+		else				     /* non-bridge PCI device */
+			acpi_pci_irq_add_prt(device->handle, data->id.segment,
+				data->id.bus);
+	}
+
+end:
+	if (0 != result)
+		kfree(data);
+
+	return_VALUE(result);
+}
+
+
+int 
+acpi_pci_bind_root (
+	struct acpi_device	*device,
+	acpi_pci_id		*id,
+	struct pci_bus		*bus) 
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_pci_data	*data = NULL;
+	char			pathname[PATHNAME_MAX] = {0};
+	acpi_buffer		buffer = {PATHNAME_MAX, pathname};
+
+	ACPI_FUNCTION_TRACE("acpi_pci_bind_root");
+
+	if (!device || !id || !bus)
+		return_VALUE(-EINVAL);
+
+	data = kmalloc(sizeof(struct acpi_pci_data), GFP_KERNEL);
+	if (!data)
+		return_VALUE(-ENOMEM);
+	memset(data, 0, sizeof(struct acpi_pci_data));
+
+	data->id = *id;
+	data->bus = bus;
+	device->ops.bind = acpi_pci_bind;
+
+	acpi_get_name(device->handle, ACPI_FULL_PATHNAME, &buffer);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Binding PCI root bridge [%s] to "
+		"%02x:%02x\n", pathname, id->segment, id->bus));
+
+	status = acpi_attach_data(device->handle, acpi_pci_data_handler, data);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to attach ACPI-PCI context to device %s\n",
+			pathname));
+		result = -ENODEV;
+		goto end;
+	}
+
+end:
+	if (result != 0)
+		kfree(data);
+
+	return_VALUE(result);
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/pci_irq.c linux/drivers/acpi/pci_irq.c
--- ../prev/linux/drivers/acpi/pci_irq.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/pci_irq.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,391 @@
+/*
+ *  pci_irq.c - ACPI PCI Interrupt Routing ($Revision: 8 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_irq")
+
+#define PREFIX			"PCI: "
+
+struct acpi_prt_list		acpi_prt;
+
+#ifdef CONFIG_X86
+extern void eisa_set_level_irq(unsigned int irq);
+#endif
+
+
+/* --------------------------------------------------------------------------
+                         PCI IRQ Routing Table (PRT) Support
+   -------------------------------------------------------------------------- */
+
+static struct acpi_prt_entry *
+acpi_pci_irq_find_prt_entry (
+	int			segment,
+	int			bus,
+	int			device,
+	int			pin)
+{
+	struct list_head	*node = NULL;
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_find_prt_entry");
+
+	/*
+	 * Parse through all PRT entries looking for a match on the specified
+	 * PCI device's segment, bus, device, and pin (don't care about func).
+	 *
+	 * TBD: Acquire/release lock
+	 */
+	list_for_each(node, &acpi_prt.entries) {
+		entry = list_entry(node, struct acpi_prt_entry, node);
+		if ((segment == entry->id.segment) 
+			&& (bus == entry->id.bus) 
+			&& (device == entry->id.device)
+			&& (pin == entry->pin)) {
+			return_PTR(entry);
+		}
+	}
+
+	return_PTR(NULL);
+}
+
+
+static int
+acpi_pci_irq_add_entry (
+	acpi_handle		handle,
+	int			segment,
+	int			bus,
+	acpi_pci_routing_table	*prt)
+{
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_entry");
+
+	if (!prt)
+		return_VALUE(-EINVAL);
+
+	entry = kmalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);
+	if (!entry)
+		return_VALUE(-ENOMEM);
+	memset(entry, 0, sizeof(struct acpi_prt_entry));
+
+	entry->id.segment = segment;
+	entry->id.bus = bus;
+	entry->id.device = (prt->address >> 16) & 0xFFFF;
+	entry->id.function = prt->address & 0xFFFF;
+	entry->pin = prt->pin;
+
+	/*
+	 * Type 1: Dynamic
+	 * ---------------
+	 * The 'source' field specifies the PCI interrupt link device used to
+	 * configure the IRQ assigned to this slot|dev|pin.  The 'source_index'
+	 * indicates which resource descriptor in the resource template (of
+	 * the link device) this interrupt is allocated from.
+	 * 
+	 * NOTE: Don't query the Link Device for IRQ information at this time
+	 *       because Link Device enumeration may not have occurred yet
+	 *       (e.g. exists somewhere 'below' this _PRT entry in the ACPI
+	 *       namespace).
+	 */
+	if (prt->source[0]) {
+		acpi_get_handle(handle, prt->source, &entry->link.handle);
+		entry->link.index = prt->source_index;
+	}
+	/*
+	 * Type 2: Static
+	 * --------------
+	 * The 'source' field is NULL, and the 'source_index' field specifies
+	 * the IRQ value, which is hardwired to specific interrupt inputs on
+	 * the interrupt controller.
+	 */
+	else
+		entry->link.index = prt->source_index;
+
+	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,
+		"      %02X:%02X:%02X[%c] -> %s[%d]\n", 
+		entry->id.segment, entry->id.bus, entry->id.device, 
+		('A' + entry->pin), prt->source, entry->link.index));
+
+	/* TBD: Acquire/release lock */
+	list_add_tail(&entry->node, &acpi_prt.entries);
+	acpi_prt.count++;
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_pci_irq_add_prt (
+	acpi_handle		handle,
+	int			segment,
+	int			bus)
+{
+	acpi_status		status = AE_OK;
+	char			pathname[PATHNAME_MAX] = {0};
+	acpi_buffer		buffer = {0, NULL};
+	acpi_pci_routing_table	*prt = NULL;
+	acpi_pci_routing_table	*entry = NULL;
+	static int		first_time = 1;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_add_prt");
+
+	if (first_time) {
+		acpi_prt.count = 0;
+		INIT_LIST_HEAD(&acpi_prt.entries);
+		first_time = 0;
+	}
+
+	/* 
+	 * NOTE: We're given a 'handle' to the _PRT object's parent device
+	 *       (either a PCI root bridge or PCI-PCI bridge).
+	 */
+
+	buffer.length = sizeof(pathname);
+	buffer.pointer = pathname;
+	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
+
+	printk(KERN_DEBUG "ACPI: PCI Interrupt Routing Table [%s._PRT]\n",
+		pathname);
+
+	/* 
+	 * Evaluate this _PRT and add its entries to our global list (acpi_prt).
+	 */
+
+	buffer.length = 0;
+	buffer.pointer = NULL;
+	status = acpi_get_irq_routing_table(handle, &buffer);
+	if (status != AE_BUFFER_OVERFLOW) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
+			acpi_format_exception(status)));
+		return_VALUE(-ENODEV);
+	}
+
+	prt = kmalloc(buffer.length, GFP_KERNEL);
+	if (!prt)
+		return_VALUE(-ENOMEM);
+	memset(prt, 0, buffer.length);
+	buffer.pointer = prt;
+
+	status = acpi_get_irq_routing_table(handle, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRT [%s]\n",
+			acpi_format_exception(status)));
+		kfree(buffer.pointer);
+		return_VALUE(-ENODEV);
+	}
+
+	entry = prt;
+
+	while (entry && (entry->length > 0)) {
+		acpi_pci_irq_add_entry(handle, segment, bus, entry);
+		entry = (acpi_pci_routing_table *)
+			((unsigned long) entry + entry->length);
+	}
+
+	kfree(prt);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                          PCI Interrupt Routing Support
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_pci_irq_lookup (
+	int			segment,
+	int			bus,
+	int			device,
+	int			pin)
+{
+	struct acpi_prt_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_lookup");
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Searching for PRT entry for %02x:%02x:%02x[%c]\n", 
+		segment, bus, device, ('A' + pin)));
+
+	entry = acpi_pci_irq_find_prt_entry(segment, bus, device, pin); 
+	if (!entry) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PRT entry not found\n"));
+		return_VALUE(0);
+	}
+
+	if (!entry->irq && entry->link.handle)
+		entry->irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index);
+	else if (!entry->irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Invalid static routing entry (IRQ 0)\n"));
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found IRQ %d\n", entry->irq));
+
+	return_VALUE(entry->irq);
+}
+
+
+static int
+acpi_pci_irq_derive (
+	struct pci_dev		*dev,
+	int			pin)
+{
+	struct pci_dev		*bridge = dev;
+	int			irq = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_derive");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/* 
+	 * Attempt to derive an IRQ for this device from a parent bridge's
+	 * PCI interrupt routing entry (a.k.a. the "bridge swizzle").
+	 */
+	while (!irq && (bridge = bridge->bus->self)) {
+		pin = (pin + PCI_SLOT(bridge->devfn)) % 4;
+		irq = acpi_pci_irq_lookup(0, bridge->bus->number, PCI_SLOT(bridge->devfn), pin);
+	}
+
+	if (!irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to derive IRQ for device %s\n", dev->slot_name));
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived IRQ %d\n", irq));
+
+	return_VALUE(irq);
+}
+
+
+int
+acpi_pci_irq_enable (
+	struct pci_dev		*dev)
+{
+	int			irq = 0;
+	u8			pin = 0;
+	static u16		irq_mask = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_enable");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+	
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	if (!pin) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No interrupt pin configured for device %s\n", dev->slot_name));
+		return_VALUE(0);
+	}
+	pin--;
+
+	if (!dev->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) 'bus' field\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/* 
+	 * First we check the PCI IRQ routing table (PRT) for an IRQ.  PRT
+	 * values override any BIOS-assinged IRQs set during boot.
+	 */
+ 	irq = acpi_pci_irq_lookup(0, dev->bus->number, PCI_SLOT(dev->devfn), pin);
+	if (irq)
+		dev->irq = irq;
+
+	/*
+	 * If no PRT entry was found and the device wasn't assigned an IRQ 
+	 * during boot we'll try to derive an IRQ from the device's parent 
+	 * bridge.
+	 */
+	if (!dev->irq && dev->bus->self) {
+		irq = acpi_pci_irq_derive(dev, pin);
+		if (irq)
+			dev->irq = irq;
+	}
+
+		
+	if (!dev->irq) {
+		printk(KERN_WARNING PREFIX "No IRQ known for interrupt pin %c of device %s\n", ('A' + pin), dev->slot_name);
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s using IRQ %d\n", dev->slot_name, dev->irq));
+
+	/* 
+	 * Make sure all (legacy) PCI IRQs are set as level-triggered.
+	 */
+#ifdef CONFIG_X86
+	if ((dev->irq < 16) &&  !((1 << dev->irq) & irq_mask)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Setting IRQ %d as level-triggered\n", dev->irq));
+		irq_mask |= (1 << dev->irq);
+		eisa_set_level_irq(dev->irq);
+	}
+#endif
+
+	return_VALUE(dev->irq);
+}
+
+
+int __init
+acpi_pci_irq_init (void)
+{
+	struct pci_dev          *dev = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_irq_init");
+
+	if (!acpi_prt.count) {
+		printk(KERN_WARNING PREFIX "ACPI tables contain no PCI IRQ "
+			"routing entries\n");
+		return_VALUE(-ENODEV);
+	}
+
+	/* Make sure all link devices have a valid IRQ. */
+	acpi_pci_link_check();
+
+#ifdef CONFIG_X86_IO_APIC
+	/* Program IOAPICs using data from PRT entries. */
+	if (acpi_irq_model == ACPI_IRQ_MODEL_IOAPIC)
+		mp_parse_prt();
+#endif
+
+	pci_for_each_dev(dev)
+		acpi_pci_irq_enable(dev);
+
+	return_VALUE(acpi_prt.count);
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/pci_link.c linux/drivers/acpi/pci_link.c
--- ../prev/linux/drivers/acpi/pci_link.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/pci_link.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,581 @@
+/*
+ *  pci_link.c - ACPI PCI Interrupt Link Device Driver ($Revision: 31 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2002       Dominik Brodowski <devel@brodo.de>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * TBD: 
+ *      1. Support more than one IRQ resource entry per link device (index).
+ *	2. Implement start/stop mechanism and use ACPI Bus Driver facilities
+ *	   for IRQ management (e.g. start()->_SRS).
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_link")
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_PCI_LINK_MAX_POSSIBLE 16
+
+static int acpi_pci_link_add (struct acpi_device *device);
+static int acpi_pci_link_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_pci_link_driver = {
+        name:                   ACPI_PCI_LINK_DRIVER_NAME,
+        class:                  ACPI_PCI_LINK_CLASS,
+        ids:                    ACPI_PCI_LINK_HID,
+        ops:                    {
+                                        add:    acpi_pci_link_add,
+                                        remove: acpi_pci_link_remove,
+                                },
+};
+
+struct acpi_pci_link_irq {
+	u8			active;			/* Current IRQ */
+	u8			possible_count;
+	u8			possible[ACPI_PCI_LINK_MAX_POSSIBLE];
+};
+
+struct acpi_pci_link {
+	struct list_head	node;
+	struct acpi_device	*device;
+	acpi_handle		handle;
+	struct acpi_pci_link_irq irq;
+};
+
+static struct {
+	int			count;
+	struct list_head	entries;
+}				acpi_link;
+
+
+/* --------------------------------------------------------------------------
+                            PCI Link Device Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_pci_link_get_possible (
+	struct acpi_pci_link	*link)
+{
+	int                     result = 0;
+	acpi_status		status = AE_OK;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_resource		*resource = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_possible");
+
+	if (!link)
+		return_VALUE(-EINVAL);
+
+	status = acpi_get_possible_resources(link->handle, &buffer);
+	if (ACPI_FAILURE(status) || !buffer.pointer) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PRS\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	resource = (acpi_resource *) buffer.pointer;
+
+	switch (resource->id) {
+	case ACPI_RSTYPE_IRQ:
+	{
+		acpi_resource_irq *p = &resource->data.irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Blank IRQ resource\n"));
+			result = -ENODEV;
+			goto end;
+		}
+		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+			if (!p->interrupts[i]) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
+				continue;
+			}
+			link->irq.possible[i] = p->interrupts[i];
+			link->irq.possible_count++;
+		}
+		break;
+	}
+	case ACPI_RSTYPE_EXT_IRQ:
+	{
+		acpi_resource_ext_irq *p = &resource->data.extended_irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+				"Blank IRQ resource\n"));
+			result = -ENODEV;
+			goto end;
+		}
+		for (i = 0; (i<p->number_of_interrupts && i<ACPI_PCI_LINK_MAX_POSSIBLE); i++) {
+			if (!p->interrupts[i]) {
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid IRQ %d\n", p->interrupts[i]));
+				continue;
+			}
+			link->irq.possible[i] = p->interrupts[i];
+			link->irq.possible_count++;
+		}
+		break;
+	}
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Resource is not an IRQ entry\n"));
+		result = -ENODEV;
+		goto end;
+		break;
+	}
+	
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Found %d possible IRQs\n", link->irq.possible_count));
+
+end:
+	kfree(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_link_get_current (
+	struct acpi_pci_link	*link)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_resource		*resource = NULL;
+	int			irq = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_current");
+
+	if (!link || !link->handle)
+		return_VALUE(-EINVAL);
+
+	link->irq.active = 0;
+
+	/* Make sure the link is enabled (no use querying if it isn't). */
+	result = acpi_bus_get_status(link->device);
+	if (0 != result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+		goto end;
+	}
+	if (!link->device->status.enabled) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link disabled\n"));
+		return_VALUE(0);
+	}
+
+	/* 
+	 * Query and parse _CRS to get the current IRQ assignment. 
+	 */
+
+	status = acpi_get_current_resources(link->handle, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _CRS\n"));
+		result = -ENODEV;
+		goto end;
+	}
+	resource = (acpi_resource *) buffer.pointer;
+
+	switch (resource->id) {
+	case ACPI_RSTYPE_IRQ:
+	{
+		acpi_resource_irq *p = &resource->data.irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+				"Blank IRQ resource\n"));
+			result = -ENODEV;
+			goto end;
+		}
+		irq = p->interrupts[0];
+		break;
+	}
+	case ACPI_RSTYPE_EXT_IRQ:
+	{
+		acpi_resource_ext_irq *p = &resource->data.extended_irq;
+		if (!p || !p->number_of_interrupts) {
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN,
+				"Blank IRQ resource\n"));
+			result = -ENODEV;
+			goto end;
+		}
+		irq = p->interrupts[0];
+		break;
+	}
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Resource isn't an IRQ\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	if (!irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid use of IRQ 0\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Note that we don't validate that the current IRQ (_CRS) exists
+	 * within the possible IRQs (_PRS): we blindly assume that whatever
+	 * IRQ a boot-enabled Link device is set to is the correct one.
+	 * (Required to support systems such as the Toshiba 5005-S504.)
+	 */
+
+	link->irq.active = irq;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link at IRQ %d \n", link->irq.active));
+
+end:
+	kfree(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_link_set (
+	struct acpi_pci_link	*link,
+	int			irq)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct {
+		acpi_resource	res;
+		acpi_resource   end;
+	}                       resource;
+	acpi_buffer		buffer = {sizeof(resource)+1, &resource};
+	int			i = 0;
+	int			valid = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_set");
+
+	if (!link || !irq)
+		return_VALUE(-EINVAL);
+
+	/* See if we're already at the target IRQ. */
+	if (irq == link->irq.active)
+		return_VALUE(0);
+
+	/* Make sure the target IRQ in the list of possible IRQs. */
+	for (i=0; i<link->irq.possible_count; i++) {
+		if (irq == link->irq.possible[i])
+			valid = 1;
+	}
+	if (!valid) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Target IRQ %d invalid\n", irq));
+		return_VALUE(-EINVAL);
+	}
+
+	memset(&resource, 0, sizeof(resource));
+
+	/* NOTE: PCI interrupts are always level / active_low / shared. */
+	resource.res.id = ACPI_RSTYPE_IRQ;
+	resource.res.length = sizeof(acpi_resource);
+	resource.res.data.irq.edge_level = ACPI_LEVEL_SENSITIVE;
+	resource.res.data.irq.active_high_low = ACPI_ACTIVE_LOW;
+	resource.res.data.irq.shared_exclusive = ACPI_SHARED;
+	resource.res.data.irq.number_of_interrupts = 1;
+	resource.res.data.irq.interrupts[0] = irq;
+	resource.end.id = ACPI_RSTYPE_END_TAG;
+
+	status = acpi_set_current_resources(link->handle, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SRS\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/* Make sure the device is enabled. */
+	result = acpi_bus_get_status(link->device);
+	if (0 != result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to read status\n"));
+		return_VALUE(result);
+	}
+	if (!link->device->status.enabled) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link disabled\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/* Make sure the active IRQ is the one we requested. */
+	result = acpi_pci_link_get_current(link);
+	if (0 != result) {
+		return_VALUE(result);
+	}
+	if (link->irq.active != irq) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Attempt to enable at IRQ %d resulted in IRQ %d\n", 
+			irq, link->irq.active));
+		link->irq.active = 0;
+		return_VALUE(-ENODEV);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Set IRQ %d\n", link->irq.active));
+	
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                            PCI Link IRQ Management
+   -------------------------------------------------------------------------- */
+
+#define ACPI_MAX_IRQS		256
+#define ACPI_MAX_ISA_IRQ	16
+
+/*
+ * IRQ penalties are used to promote PCI IRQ balancing.  We set each ISA-
+ * possible IRQ (0-15) with a default penalty relative to its feasibility
+ * for PCI's use:
+ *
+ *   Never use:		0, 1, 2 (timer, keyboard, and cascade)
+ *   Avoid using:	13, 14, and 15 (FP error and IDE)
+ *   Penalize:		3, 4, 6, 7, 12 (known ISA uses)
+ *
+ * Thus we're left with IRQs 5, 9, 10, 11, and everything above 15 (IO[S]APIC)
+ * as 'best bets' for PCI use.
+ */
+
+static int acpi_irq_penalty[ACPI_MAX_IRQS] = {
+	1000000,  1000000,  1000000,    10000, 
+	  10000,        0,    10000,    10000,
+	  10000,        0,        0,        0, 
+	  10000,   100000,   100000,   100000,
+};
+
+
+int
+acpi_pci_link_check (void)
+{
+	struct list_head	*node = NULL;
+	struct acpi_pci_link    *link = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_check");
+
+	/*
+	 * Pass #1: Update penalties to facilitate IRQ balancing.
+	 */
+	list_for_each(node, &acpi_link.entries) {
+
+		link = list_entry(node, struct acpi_pci_link, node);
+		if (!link) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			continue;
+		}
+
+		if (link->irq.active)
+			acpi_irq_penalty[link->irq.active] += 100;
+		else {
+			int penalty = 100 / link->irq.possible_count;
+			for (i=0; i<link->irq.possible_count; i++) {
+				if (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)
+					acpi_irq_penalty[link->irq.possible[i]] += penalty;
+			}
+		}
+	}
+
+	/*
+	 * Pass #2: Enable boot-disabled Links at 'best' IRQ.
+	 */
+	list_for_each(node, &acpi_link.entries) {
+		int		irq = 0;
+		int		i = 0;
+
+		link = list_entry(node, struct acpi_pci_link, node);
+		if (!link) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+			continue;
+		}
+
+		if (link->irq.active)
+			continue;
+
+		irq = link->irq.possible[0];
+
+		/* 
+		 * Select the best IRQ.  This is done in reverse to promote 
+		 * the use of IRQs 9, 10, 11, and >15.
+		 */
+		for (i=(link->irq.possible_count-1); i>0; i--) {
+			if (acpi_irq_penalty[irq] > acpi_irq_penalty[link->irq.possible[i]])
+				irq = link->irq.possible[i];
+		}
+
+		/* Enable the link device at this IRQ. */
+		acpi_pci_link_set(link, irq);
+
+		acpi_irq_penalty[link->irq.active] += 100;
+
+		printk(PREFIX "%s [%s] enabled at IRQ %d\n", 
+			acpi_device_name(link->device), 
+			acpi_device_bid(link->device), irq);
+	}
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_pci_link_get_irq (
+	acpi_handle		handle,
+	int			index)
+{
+	int                     result = 0;
+	struct acpi_device	*device = NULL;
+	struct acpi_pci_link	*link = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_get_irq");
+
+	result = acpi_bus_get_device(handle, &device);
+	if (0 != result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link device\n"));
+		return_VALUE(0);
+	}
+
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+	if (!link) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid link context\n"));
+		return_VALUE(0);
+	}
+
+	/* TBD: Support multiple index (IRQ) entries per Link Device */
+	if (0 != index) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid index %d\n", index));
+		return_VALUE(0);
+	}
+
+	if (!link->irq.active) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Link disabled\n"));
+		return_VALUE(0);
+	}
+
+	return_VALUE(link->irq.active);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_pci_link_add (
+	struct acpi_device *device)
+{
+	int			result = 0;
+	struct acpi_pci_link	*link = NULL;
+	int			i = 0;
+	int			found = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	link = kmalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);
+	if (!link)
+		return_VALUE(-ENOMEM);
+	memset(link, 0, sizeof(struct acpi_pci_link));
+
+	link->device = device;
+	link->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_PCI_LINK_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_PCI_LINK_CLASS);
+	acpi_driver_data(device) = link;
+
+	result = acpi_pci_link_get_possible(link);
+	if (0 != result)
+		goto end;
+
+	acpi_pci_link_get_current(link);
+
+	printk(PREFIX "%s [%s] (IRQs", acpi_device_name(device), acpi_device_bid(device));
+	for (i = 0; i < link->irq.possible_count; i++) {
+		if (link->irq.active == link->irq.possible[i]) {
+			printk(" *%d", link->irq.possible[i]);
+			found = 1;
+		}
+		else
+			printk(" %d", link->irq.possible[i]);
+	}
+	if (!link->irq.active)
+		printk(", disabled");
+	else if (!found)
+		printk(", enabled at IRQ %d", link->irq.active);
+	printk(")\n");
+
+	/* TBD: Acquire/release lock */
+	list_add_tail(&link->node, &acpi_link.entries);
+	acpi_link.count++;
+
+end:
+	if (0 != result)
+		kfree(link);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_link_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_pci_link *link = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_link_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	link = (struct acpi_pci_link *) acpi_driver_data(device);
+
+	/* TBD: Acquire/release lock */
+	list_del(&link->node);
+
+	kfree(link);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_pci_link_init (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_link_init");
+
+	acpi_link.count = 0;
+	INIT_LIST_HEAD(&acpi_link.entries);
+
+	if (0 > acpi_bus_register_driver(&acpi_pci_link_driver))
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/pci_root.c linux/drivers/acpi/pci_root.c
--- ../prev/linux/drivers/acpi/pci_root.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/pci_root.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,246 @@
+/*
+ *  pci_root.c - ACPI PCI Root Bridge Driver ($Revision: 37 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pm.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_PCI_COMPONENT
+ACPI_MODULE_NAME		("pci_root")
+
+extern struct pci_ops *pci_root_ops;
+
+#define PREFIX			"ACPI: "
+
+static int acpi_pci_root_add (struct acpi_device *device);
+static int acpi_pci_root_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_pci_root_driver = {
+        name:                   ACPI_PCI_ROOT_DRIVER_NAME,
+        class:                  ACPI_PCI_ROOT_CLASS,
+        ids:                    ACPI_PCI_ROOT_HID,
+        ops:                    {
+                                        add:    acpi_pci_root_add,
+                                        remove: acpi_pci_root_remove,
+                                },
+};
+
+struct acpi_pci_root {
+	acpi_handle		handle;
+	acpi_pci_id		id;
+	struct pci_bus		*bus;
+};
+
+
+static int
+acpi_pci_root_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct acpi_pci_root	*root = NULL;
+	acpi_status		status = AE_OK;
+	unsigned long		value = 0;
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_root_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	root = kmalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);
+	if (!root)
+		return_VALUE(-ENOMEM);
+	memset(root, 0, sizeof(struct acpi_pci_root));
+
+	root->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_PCI_ROOT_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_PCI_ROOT_CLASS);
+	acpi_driver_data(device) = root;
+
+	/*
+	 * TBD: Doesn't the bus driver automatically set this?
+	 */
+	device->ops.bind = acpi_pci_bind;
+
+	/* 
+	 * Segment
+	 * -------
+	 * Obtained via _SEG, if exists, otherwise assumed to be zero (0).
+	 */
+	status = acpi_evaluate_integer(root->handle, METHOD_NAME__SEG, NULL, 
+		&value);
+	switch (status) {
+	case AE_OK:
+		root->id.segment = (u16) value;
+		printk("_SEG exists! Unsupported. Abort.\n");
+		BUG();
+		break;
+	case AE_NOT_FOUND:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Assuming segment 0 (no _SEG)\n"));
+		root->id.segment = 0;
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _SEG\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/* 
+	 * Bus
+	 * ---
+	 * Obtained via _BBN, if exists, otherwise assumed to be zero (0).
+	 */
+	status = acpi_evaluate_integer(root->handle, METHOD_NAME__BBN, NULL, 
+		&value);
+	switch (status) {
+	case AE_OK:
+		root->id.bus = (u16) value;
+		break;
+	case AE_NOT_FOUND:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Assuming bus 0 (no _BBN)\n"));
+		root->id.bus = 0;
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _BBN\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Device & Function
+	 * -----------------
+	 * Obtained from _ADR (which has already been evaluated for us).
+	 */
+	root->id.device = device->pnp.bus_address >> 16;
+	root->id.function = device->pnp.bus_address & 0xFFFF;
+
+	/*
+	 * TBD: Evaluate _CRS to get root bridge resources
+	 * TBD: Need PCI interface for enumeration/configuration of roots.
+	 */
+
+	printk(KERN_INFO PREFIX "%s [%s] (%02x:%02x)\n", 
+		acpi_device_name(device), acpi_device_bid(device),
+		root->id.segment, root->id.bus);
+
+	/*
+	 * Scan the Root Bridge
+	 * --------------------
+	 * Must do this prior to any attempt to bind the root device, as the
+	 * PCI namespace does not get created until this call is made (and 
+	 * thus the root bridge's pci_dev does not exist).
+	 */
+	root->bus = pcibios_scan_root(root->id.bus);
+	if (!root->bus) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Bus %02x:%02x not present in PCI namespace\n", 
+			root->id.segment, root->id.bus));
+		result = -ENODEV;
+		goto end;
+	}
+
+	/*
+	 * Attach ACPI-PCI Context
+	 * -----------------------
+	 * Thus binding the ACPI and PCI devices.
+	 */
+	result = acpi_pci_bind_root(device, &root->id, root->bus);
+	if (0 != result)
+		goto end;
+
+	/*
+	 * PCI Routing Table
+	 * -----------------
+	 * Evaluate and parse _PRT, if exists.
+	 */
+	status = acpi_get_handle(root->handle, METHOD_NAME__PRT, &handle);
+	if (ACPI_SUCCESS(status))
+		result = acpi_pci_irq_add_prt(root->handle, root->id.segment,
+			root->id.bus);
+
+end:
+	if (0 != result)
+		kfree(root);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_pci_root_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_pci_root	*root = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_pci_root_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	root = (struct acpi_pci_root *) acpi_driver_data(device);
+
+	kfree(root);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_pci_root_init (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_root_init");
+
+	/* DEBUG:
+	acpi_dbg_layer = ACPI_PCI_COMPONENT;
+	acpi_dbg_level = 0xFFFFFFFF;
+	 */
+
+	if (0 > acpi_bus_register_driver(&acpi_pci_root_driver))
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_pci_root_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_pci_root_exit");
+
+	acpi_bus_unregister_driver(&acpi_pci_root_driver);
+
+	return_VOID;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/power.c linux/drivers/acpi/power.c
--- ../prev/linux/drivers/acpi/power.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/power.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,610 @@
+/*
+ *  acpi_power.c - ACPI Bus Power Management ($Revision: 34 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_POWER_COMPONENT
+ACPI_MODULE_NAME		("acpi_power")
+
+#define PREFIX			"ACPI: "
+
+
+int acpi_power_add (struct acpi_device *device);
+int acpi_power_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_power_driver = {
+	name:			ACPI_POWER_DRIVER_NAME,
+	class:			ACPI_POWER_CLASS,
+	ids:			ACPI_POWER_HID,
+	ops:			{
+					add:	acpi_power_add,
+					remove:	acpi_power_remove,
+				},
+};
+
+struct acpi_power_resource
+{
+	acpi_handle		handle;
+	acpi_bus_id		name;
+	u32			system_level;
+	u32			order;
+	int			state;
+	int			references;
+};
+
+static struct list_head		acpi_power_resource_list;
+
+
+/* --------------------------------------------------------------------------
+                             Power Resource Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_power_get_context (
+	acpi_handle		handle,
+	struct acpi_power_resource **resource)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_context");
+
+	if (!resource)
+		return_VALUE(-ENODEV);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (0 != result) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Error getting context [%p]\n",
+			handle));
+		return_VALUE(result);
+	}
+
+	*resource = (struct acpi_power_resource *) acpi_driver_data(device);
+	if (!resource)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_get_state (
+	struct acpi_power_resource *resource)
+{
+	acpi_status		status = AE_OK;
+	unsigned long		sta = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_state");
+
+	if (!resource)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(resource->handle, "_STA", NULL, &sta);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (sta & 0x01)
+		resource->state = ACPI_POWER_RESOURCE_STATE_ON;
+	else
+		resource->state = ACPI_POWER_RESOURCE_STATE_OFF;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] is %s\n",
+		resource->name, resource->state?"on":"off"));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_get_list_state (
+	struct acpi_handle_list	*list,
+	int			*state)
+{
+	int			result = 0;
+	struct acpi_power_resource *resource = NULL;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_list_state");
+
+	if (!list || !state)
+		return_VALUE(-EINVAL);
+
+	/* The state of the list is 'on' IFF all resources are 'on'. */
+
+	for (i=0; i<list->count; i++) {
+		result = acpi_power_get_context(list->handles[i], &resource);
+		if (0 != result)
+			return_VALUE(result);
+		result = acpi_power_get_state(resource);
+		if (0 != result)
+			return_VALUE(result);
+
+		*state = resource->state;
+
+		if (*state != ACPI_POWER_RESOURCE_STATE_ON)
+			break;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource list is %s\n",
+		*state?"on":"off"));
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_power_on (
+	acpi_handle		handle)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_on");
+
+	result = acpi_power_get_context(handle, &resource);
+	if (0 != result)
+		return_VALUE(result);
+
+	resource->references++;
+
+	if ((resource->references > 1) 
+		|| (resource->state == ACPI_POWER_RESOURCE_STATE_ON)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already on\n",
+			resource->name));
+		return_VALUE(0);
+	}
+
+	status = acpi_evaluate(resource->handle, "_ON", NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	result = acpi_power_get_state(resource);
+	if (0 != result)
+		return_VALUE(result);
+	if (resource->state != ACPI_POWER_RESOURCE_STATE_ON)
+		return_VALUE(-ENOEXEC);
+
+	/* Update the power resource's _device_ power state */
+	result = acpi_bus_get_device(resource->handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+	device->power.state = ACPI_STATE_D0;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned on\n",
+		resource->name));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_off (
+	acpi_handle		handle)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_device	*device = NULL;
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_off");
+
+	result = acpi_power_get_context(handle, &resource);
+	if (0 != result)
+		return_VALUE(result);
+
+	if (resource->references)
+		resource->references--;
+
+	if (resource->references) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Resource [%s] is still in use, dereferencing\n",
+			device->pnp.bus_id));
+		return_VALUE(0);
+	}
+
+	if (resource->state == ACPI_POWER_RESOURCE_STATE_OFF) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] already off\n",
+			device->pnp.bus_id));
+		return_VALUE(0);
+	}
+
+	status = acpi_evaluate(resource->handle, "_OFF", NULL, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	result = acpi_power_get_state(resource);
+	if (0 != result)
+		return_VALUE(result);
+	if (resource->state != ACPI_POWER_RESOURCE_STATE_OFF)
+		return_VALUE(-ENOEXEC);
+
+	/* Update the power resource's _device_ power state */
+	result = acpi_bus_get_device(resource->handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+	device->power.state = ACPI_STATE_D3;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resource [%s] turned off\n",
+		resource->name));
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                             Device Power Management
+   -------------------------------------------------------------------------- */
+
+int
+acpi_power_get_inferred_state (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	struct acpi_handle_list	*list = NULL;
+	int			list_state = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_get_inferred_state");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	/*
+	 * We know a device's inferred power state when all the resources
+	 * required for a given D-state are 'on'.
+	 */
+	for (i=ACPI_STATE_D0; i<ACPI_STATE_D3; i++) {
+		list = &device->power.states[i].resources;
+		if (list->count < 1)
+			continue;
+
+		result = acpi_power_get_list_state(list, &list_state);
+		if (0 != result)
+			return_VALUE(result);
+
+		if (list_state == ACPI_POWER_RESOURCE_STATE_ON) {
+			device->power.state = i;
+			return_VALUE(0);
+		}
+	}
+
+	device->power.state = ACPI_STATE_D3;
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_power_transition (
+	struct acpi_device	*device,
+	int			state)
+{
+	int			result = 0;
+	struct acpi_handle_list	*cl = NULL;	/* Current Resources */
+	struct acpi_handle_list	*tl = NULL;	/* Target Resources */
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_transition");
+
+	if (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3))
+		return_VALUE(-EINVAL);
+
+	cl = &device->power.states[device->power.state].resources;
+	tl = &device->power.states[state].resources;
+
+	device->power.state = ACPI_STATE_UNKNOWN;
+
+	if (!cl->count && !tl->count) {
+		result = -ENODEV;
+		goto end;
+	}
+
+	/* TBD: Resources must be ordered. */
+
+	/*
+	 * First we reference all power resources required in the target list
+	 * (e.g. so the device doesn't loose power while transitioning).
+	 */
+	for (i=0; i<tl->count; i++) {
+		result = acpi_power_on(tl->handles[i]);
+		if (0 != result)
+			goto end;
+	}
+
+	device->power.state = state;
+
+	/*
+	 * Then we dereference all power resources used in the current list.
+	 */
+	for (i=0; i<cl->count; i++) {
+		result = acpi_power_off(cl->handles[i]);
+		if (0 != result)
+			goto end;
+	}
+
+end:
+	if (0 != result)
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+			"Error transitioning device [%s] to D%d\n",
+			device->pnp.bus_id, state));
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry		*acpi_power_dir = NULL;
+
+
+static int
+acpi_power_read_status (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_power_resource *resource = NULL;
+	char			*p = page;
+	int			len;
+
+	ACPI_FUNCTION_TRACE("acpi_power_read_status");
+
+	if (!data || (off != 0))
+		goto end;
+
+	resource = (struct acpi_power_resource *) data;
+
+	p += sprintf(p, "state:                   ");
+	switch (resource->state) {
+	case ACPI_POWER_RESOURCE_STATE_ON:
+		p += sprintf(p, "on\n");
+		break;
+	case ACPI_POWER_RESOURCE_STATE_OFF:
+		p += sprintf(p, "off\n");
+		break;
+	default:
+		p += sprintf(p, "unknown\n");
+		break;
+	}
+
+	p += sprintf(p, "system level:            S%d\n",
+		resource->system_level);
+	p += sprintf(p, "order:                   %d\n",
+		resource->order);
+	p += sprintf(p, "reference count:         %d\n",
+		resource->references);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_power_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_add_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	if (!acpi_power_dir) {
+		acpi_power_dir = proc_mkdir(ACPI_POWER_CLASS, acpi_root_dir);
+		if (!acpi_power_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_power_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'status' [R] */
+	entry = create_proc_entry(ACPI_POWER_FILE_STATUS,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_POWER_FILE_STATUS));
+	else {
+		entry->read_proc = acpi_power_read_status;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_power_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_power_remove_fs");
+
+	if (!acpi_power_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_power_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Driver Interface
+   -------------------------------------------------------------------------- */
+
+int
+acpi_power_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_power_resource *resource = NULL;
+	acpi_object		acpi_object;
+	acpi_buffer		buffer = {sizeof(acpi_object), &acpi_object};
+
+	ACPI_FUNCTION_TRACE("acpi_power_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	resource = kmalloc(sizeof(struct acpi_power_resource), GFP_KERNEL);
+	if (!resource)
+		return_VALUE(-ENOMEM);
+	memset(resource, 0, sizeof(struct acpi_power_resource));
+
+	resource->handle = device->handle;
+	sprintf(resource->name, "%s", device->pnp.bus_id);
+	sprintf(acpi_device_name(device), "%s", ACPI_POWER_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_POWER_CLASS);
+	acpi_driver_data(device) = resource;
+
+	/* Evalute the object to get the system level and resource order. */
+	status = acpi_evaluate_object(resource->handle, NULL, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		result = -ENODEV;
+		goto end;
+	}
+	resource->system_level = acpi_object.power_resource.system_level;
+	resource->order = acpi_object.power_resource.resource_order;
+
+	result = acpi_power_get_state(resource);
+	if (0 != result)
+		goto end;
+
+	switch (resource->state) {
+	case ACPI_POWER_RESOURCE_STATE_ON:
+		device->power.state = ACPI_STATE_D0;
+		break;
+	case ACPI_POWER_RESOURCE_STATE_OFF:
+		device->power.state = ACPI_STATE_D3;
+		break;
+	default:
+		device->power.state = ACPI_STATE_UNKNOWN;
+		break;
+	}
+
+	result = acpi_power_add_fs(device);
+	if (0 != result)
+		goto end;
+	
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n", acpi_device_name(device),
+		acpi_device_bid(device), resource->state?"on":"off");
+
+end:
+	if (0 != result)
+		kfree(resource);
+	
+	return_VALUE(result);
+}
+
+
+int
+acpi_power_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_power_resource *resource = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_power_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	resource = (struct acpi_power_resource *) acpi_driver_data(device);
+
+	acpi_power_remove_fs(device);
+
+	kfree(resource);
+
+	return_VALUE(0);
+}
+
+
+int __init
+acpi_power_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_init");
+
+	INIT_LIST_HEAD(&acpi_power_resource_list);
+
+	result = acpi_bus_register_driver(&acpi_power_driver);
+	if (0 > result) {
+		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
+		return_VALUE(-ENODEV);
+	}
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_power_exit (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_power_exit");
+
+	/* TBD: Empty acpi_power_resource_list */
+
+	result = acpi_bus_unregister_driver(&acpi_power_driver);
+	if (0 == result)
+		remove_proc_entry(ACPI_POWER_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/processor.c linux/drivers/acpi/processor.c
--- ../prev/linux/drivers/acpi/processor.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/processor.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,2324 @@
+/*
+ * acpi_processor.c - ACPI Processor Driver ($Revision: 62 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  TBD:
+ *	1. Make # power/performance states dynamic.
+ *	2. Support duty_cycle values that span bit 4.
+ *	3. Optimize by having scheduler determine business instead of
+ *	   having us try to calculate it here.
+ *	4. Need C1 timing -- must modify kernel (IRQ handler) to get this.
+ *	5. Convert time values to ticks (initially) to avoid having to do
+ *	   the math (acpi_get_timer_duration).
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/delay.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_PROCESSOR_COMPONENT
+ACPI_MODULE_NAME		("acpi_processor")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_PROCESSOR_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+#define PREFIX				"ACPI: "
+
+#define US_TO_PM_TIMER_TICKS(t)		((t * PM_TIMER_FREQUENCY) / 1000000)
+#define C2_OVERHEAD			4	/* 1us (3.579 ticks per us) */
+#define C3_OVERHEAD			4	/* 1us (3.579 ticks per us) */
+
+#define ACPI_PROCESSOR_BUSY_METRIC	10
+
+#define ACPI_PROCESSOR_MAX_POWER	ACPI_C_STATE_COUNT
+#define ACPI_PROCESSOR_MAX_C2_LATENCY	100
+#define ACPI_PROCESSOR_MAX_C3_LATENCY	1000
+
+#define ACPI_PROCESSOR_MAX_PERFORMANCE	8
+
+#define ACPI_PROCESSOR_MAX_THROTTLING	16
+#define ACPI_PROCESSOR_MAX_THROTTLE	250	/* 25% */
+#define ACPI_PROCESSOR_MAX_DUTY_WIDTH	4
+
+const u32 POWER_OF_2[] = {1,2,4,8,16,32,64};
+
+#define ACPI_PROCESSOR_LIMIT_USER	0
+#define ACPI_PROCESSOR_LIMIT_THERMAL	1
+
+static int acpi_processor_add (struct acpi_device *device);
+static int acpi_processor_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_processor_driver = {
+	name:			ACPI_PROCESSOR_DRIVER_NAME,
+	class:			ACPI_PROCESSOR_CLASS,
+	ids:			ACPI_PROCESSOR_HID,
+	ops:			{
+					add:	acpi_processor_add,
+					remove:	acpi_processor_remove,
+				},
+};
+
+/* Power Management */
+
+struct acpi_processor_cx_policy {
+	u32			count;
+	int			state;
+	struct {
+		u32			time;
+		u32			ticks;
+		u32			count;
+		u32			bm;
+	}			threshold;
+};
+
+struct acpi_processor_cx {
+	u8			valid;
+	u32			address;
+	u32			latency;
+	u32			latency_ticks;
+	u32			power;
+	u32			usage;
+	struct acpi_processor_cx_policy promotion;
+	struct acpi_processor_cx_policy demotion;
+};
+
+struct acpi_processor_power {
+	int			state;
+	int			default_state;
+	u32			bm_activity;
+	struct acpi_processor_cx states[ACPI_PROCESSOR_MAX_POWER];
+};
+
+/* Performance Management */
+
+struct acpi_pct_register {
+	u8			descriptor;
+	u16			length;
+	u8			space_id;
+	u8			bit_width;
+	u8			bit_offset;
+	u8			reserved;
+	u64			address;
+} __attribute__ ((packed));
+
+struct acpi_processor_px {
+	acpi_integer		core_frequency;		/* megahertz */
+	acpi_integer		power;			/* milliWatts */
+	acpi_integer		transition_latency;	/* microseconds */
+	acpi_integer		bus_master_latency;	/* microseconds */
+	acpi_integer		control;		/* control value */
+	acpi_integer		status;			/* success indicator */
+};
+
+struct acpi_processor_performance {
+	int			state;
+	int			platform_limit;
+	u16			control_register;
+	u16			status_register;
+	int			state_count;
+	struct acpi_processor_px states[ACPI_PROCESSOR_MAX_PERFORMANCE];
+};
+
+
+/* Throttling Control */
+
+struct acpi_processor_tx {
+	u16			power;
+	u16			performance;
+};
+
+struct acpi_processor_throttling {
+	int			state;
+	u32			address;
+	u8			duty_offset;
+	u8			duty_width;
+	int			state_count;
+	struct acpi_processor_tx states[ACPI_PROCESSOR_MAX_THROTTLING];
+};
+
+/* Limit Interface */
+
+struct acpi_processor_lx {
+	int			px;		/* performace state */	
+	int			tx;		/* throttle level */
+};
+
+struct acpi_processor_limit {
+	struct acpi_processor_lx state;		/* current limit */
+	struct acpi_processor_lx thermal;	/* thermal limit */
+	struct acpi_processor_lx user;		/* user limit */
+};
+
+
+struct acpi_processor_flags {
+	u8			power:1;
+	u8			performance:1;
+	u8			throttling:1;
+	u8			limit:1;
+	u8			bm_control:1;
+	u8			bm_check:1;
+	u8			reserved:2;
+};
+
+struct acpi_processor {
+	acpi_handle		handle;
+	u32			acpi_id;
+	u32			id;
+	struct acpi_processor_flags flags;
+	struct acpi_processor_power power;
+	struct acpi_processor_performance performance;
+	struct acpi_processor_throttling throttling;
+	struct acpi_processor_limit limit;
+};
+
+struct acpi_processor_errata {
+	u8			smp;
+	struct {
+		u8			throttle:1;
+		u8			fdma:1;
+		u8			reserved:6;
+		u32			bmisx;
+	}			piix4;
+};
+
+static struct acpi_processor	*processors[NR_CPUS];
+static struct acpi_processor_errata errata;
+static void (*pm_idle_save)(void) = NULL;
+
+
+/* --------------------------------------------------------------------------
+                                Errata Handling
+   -------------------------------------------------------------------------- */
+
+int
+acpi_processor_errata_piix4 (
+	struct pci_dev		*dev)
+{
+	u8			rev = 0;
+	u8			value1 = 0;
+	u8			value2 = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_errata_piix4");
+
+	if (!dev)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * Note that 'dev' references the PIIX4 ACPI Controller.
+	 */
+
+	pci_read_config_byte(dev, PCI_REVISION_ID, &rev);
+
+	switch (rev) {
+	case 0:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 A-step\n"));
+		break;
+	case 1:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 B-step\n"));
+		break;
+	case 2:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4E\n"));
+		break;
+	case 3:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4M\n"));
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unknown PIIX4\n"));
+		break;
+	}
+
+	switch (rev) {
+
+	case 0:		/* PIIX4 A-step */
+	case 1:		/* PIIX4 B-step */
+		/*
+		 * See specification changes #13 ("Manual Throttle Duty Cycle")
+		 * and #14 ("Enabling and Disabling Manual Throttle"), plus
+		 * erratum #5 ("STPCLK# Deassertion Time") from the January 
+		 * 2002 PIIX4 specification update.  Applies to only older 
+		 * PIIX4 models.
+		 */
+		errata.piix4.throttle = 1;
+
+	case 2:		/* PIIX4E */
+	case 3:		/* PIIX4M */
+		/*
+		 * See erratum #18 ("C3 Power State/BMIDE and Type-F DMA 
+		 * Livelock") from the January 2002 PIIX4 specification update.
+		 * Applies to all PIIX4 models.
+		 */
+
+		/* 
+		 * BM-IDE
+		 * ------
+		 * Find the PIIX4 IDE Controller and get the Bus Master IDE 
+		 * Status register address.  We'll use this later to read 
+		 * each IDE controller's DMA status to make sure we catch all
+		 * DMA activity.
+		 */
+		dev = pci_find_subsys(PCI_VENDOR_ID_INTEL,
+		           PCI_DEVICE_ID_INTEL_82371AB, 
+                           PCI_ANY_ID, PCI_ANY_ID, NULL);
+		if (dev)
+			errata.piix4.bmisx = pci_resource_start(dev, 4);
+
+		/* 
+		 * Type-F DMA
+		 * ----------
+		 * Find the PIIX4 ISA Controller and read the Motherboard
+		 * DMA controller's status to see if Type-F (Fast) DMA mode
+		 * is enabled (bit 7) on either channel.  Note that we'll 
+		 * disable C3 support if this is enabled, as some legacy 
+		 * devices won't operate well if fast DMA is disabled.
+		 */
+		dev = pci_find_subsys(PCI_VENDOR_ID_INTEL, 
+			PCI_DEVICE_ID_INTEL_82371AB_0, 
+			PCI_ANY_ID, PCI_ANY_ID, NULL);
+		if (dev) {
+			pci_read_config_byte(dev, 0x76, &value1);
+			pci_read_config_byte(dev, 0x77, &value2);
+			if ((value1 & 0x80) || (value2 & 0x80))
+				errata.piix4.fdma = 1;
+		}
+
+		break;
+	}
+
+	if (errata.piix4.bmisx)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Bus master activity detection (BM-IDE) erratum enabled\n"));
+	if (errata.piix4.fdma)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Type-F DMA livelock erratum (C3 disabled)\n"));
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_processor_errata (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	struct pci_dev		*dev = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_errata");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * PIIX4
+	 */
+	dev = pci_find_subsys(PCI_VENDOR_ID_INTEL, 
+		PCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID, PCI_ANY_ID, NULL);
+	if (dev)
+		result = acpi_processor_errata_piix4(dev);
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                                Power Management
+   -------------------------------------------------------------------------- */
+
+static inline u32
+ticks_elapsed (
+	u32			t1,
+	u32			t2)
+{
+	if (t2 >= t1)
+		return (t2 - t1);
+	else if (!acpi_fadt.tmr_val_ext)
+		return (((0x00FFFFFF - t1) + t2) & 0x00FFFFFF);
+	else
+		return ((0xFFFFFFFF - t1) + t2);
+}
+
+
+static void
+acpi_processor_power_activate (
+	struct acpi_processor	*pr,
+	int			state)
+{
+	if (!pr)
+		return;
+
+	pr->power.states[pr->power.state].promotion.count = 0;
+	pr->power.states[pr->power.state].demotion.count = 0;
+
+	/* Cleanup from old state. */
+	switch (pr->power.state) {
+	case ACPI_STATE_C3:
+		/* Disable bus master reload */
+		acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 0, ACPI_MTX_DO_NOT_LOCK);
+		break;
+	}
+
+	/* Prepare to use new state. */
+	switch (state) {
+	case ACPI_STATE_C3:
+		/* Enable bus master reload */
+		acpi_set_register(ACPI_BITREG_BUS_MASTER_RLD, 1, ACPI_MTX_DO_NOT_LOCK);
+		break;
+	}
+
+	pr->power.state = state;
+
+	return;
+}
+
+
+static void
+acpi_processor_idle (void)
+{
+	struct acpi_processor	*pr = NULL;
+	struct acpi_processor_cx *cx = NULL;
+	int			next_state = 0;
+	int			sleep_ticks = 0;
+	u32			t1, t2 = 0;
+
+	pr = processors[smp_processor_id()];
+	if (!pr)
+		return;
+
+	/*
+	 * Interrupts must be disabled during bus mastering calculations and
+	 * for C2/C3 transitions.
+	 */
+	__cli();
+
+	cx = &(pr->power.states[pr->power.state]);
+
+	/*
+	 * Check BM Activity
+	 * -----------------
+	 * Check for bus mastering activity (if required), record, and check
+	 * for demotion.
+	 */
+	if (pr->flags.bm_check) {
+		u32		bm_status = 0;
+
+		pr->power.bm_activity <<= 1;
+
+		acpi_get_register(ACPI_BITREG_BUS_MASTER_STATUS, 
+			&bm_status, ACPI_MTX_DO_NOT_LOCK);
+		if (bm_status) {
+			pr->power.bm_activity++;
+			acpi_set_register(ACPI_BITREG_BUS_MASTER_STATUS,
+				1, ACPI_MTX_DO_NOT_LOCK);
+		}
+		/*
+		 * PIIX4 Erratum #18: Note that BM_STS doesn't always reflect
+		 * the true state of bus mastering activity; forcing us to 
+		 * manually check the BMIDEA bit of each IDE channel.
+		 */
+		else if (errata.piix4.bmisx) {
+			if ((inb_p(errata.piix4.bmisx + 0x02) & 0x01) 
+				|| (inb_p(errata.piix4.bmisx + 0x0A) & 0x01))
+				pr->power.bm_activity++;
+		}
+		/*
+		 * Apply bus mastering demotion policy.  Automatically demote
+		 * to avoid a faulty transition.  Note that the processor 
+		 * won't enter a low-power state during this call (to this 
+		 * funciton) but should upon the next.
+		 *
+		 * TBD: A better policy might be to fallback to the demotion 
+		 *      state (use it for this quantum only) istead of 
+		 *      demoting -- and rely on duration as our sole demotion
+		 *      qualification.  This may, however, introduce DMA 
+		 *      issues (e.g. floppy DMA transfer overrun/underrun).
+		 */
+		if (pr->power.bm_activity & cx->demotion.threshold.bm) {
+			__sti();
+			next_state = cx->demotion.state;
+			goto end;
+		}
+	}
+
+	cx->usage++;
+
+	/*
+	 * Sleep:
+	 * ------
+	 * Invoke the current Cx state to put the processor to sleep.
+	 */
+	switch (pr->power.state) {
+
+	case ACPI_STATE_C1:
+		/* Invoke C1. */
+		safe_halt();
+		/*
+                 * TBD: Can't get time duration while in C1, as resumes
+		 *      go to an ISR rather than here.  Need to instrument
+		 *      base interrupt handler.
+		 */
+		sleep_ticks = 0xFFFFFFFF;
+		break;
+
+	case ACPI_STATE_C2:
+		/* Get start time (ticks) */
+		t1 = inl(acpi_fadt.Xpm_tmr_blk.address);
+		/* Invoke C2 */
+		inb(pr->power.states[ACPI_STATE_C2].address);
+		/* Dummy op - must do something useless after P_LVL2 read */
+		t2 = inl(acpi_fadt.Xpm_tmr_blk.address);
+		/* Get end time (ticks) */
+		t2 = inl(acpi_fadt.Xpm_tmr_blk.address);
+		/* Re-enable interrupts */
+		__sti();
+		/* Compute time (ticks) that we were actually asleep */
+		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C2_OVERHEAD;
+		break;
+
+	case ACPI_STATE_C3:
+		/* Disable bus master arbitration */
+		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+		/* Get start time (ticks) */
+		t1 = inl(acpi_fadt.Xpm_tmr_blk.address);
+		/* Invoke C3 */
+		inb(pr->power.states[ACPI_STATE_C3].address);
+		/* Dummy op - must do something useless after P_LVL3 read */
+		t2 = inl(acpi_fadt.Xpm_tmr_blk.address);
+		/* Get end time (ticks) */
+		t2 = inl(acpi_fadt.Xpm_tmr_blk.address);
+		/* Enable bus master arbitration */
+		acpi_set_register(ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_DO_NOT_LOCK);
+		/* Re-enable interrupts */
+		__sti();
+		/* Compute time (ticks) that we were actually asleep */
+		sleep_ticks = ticks_elapsed(t1, t2) - cx->latency_ticks - C3_OVERHEAD;
+		break;
+
+	default:
+		__sti();
+		return;
+	}
+
+	next_state = pr->power.state;
+
+	/*
+	 * Promotion?
+	 * ----------
+	 * Track the number of longs (time asleep is greater than threshold)
+	 * and promote when the count threshold is reached.  Note that bus
+	 * mastering activity may prevent promotions.
+	 */
+	if (cx->promotion.state) {
+		if (sleep_ticks > cx->promotion.threshold.ticks) {
+			cx->promotion.count++;
+ 			cx->demotion.count = 0;
+			if (cx->promotion.count >= cx->promotion.threshold.count) {
+				if (pr->flags.bm_check) {
+					if (!(pr->power.bm_activity & cx->promotion.threshold.bm)) {
+						next_state = cx->promotion.state;
+						goto end;
+					}
+				}
+				else {
+					next_state = cx->promotion.state;
+					goto end;
+				}
+			}
+		}
+	}
+
+	/*
+	 * Demotion?
+	 * ---------
+	 * Track the number of shorts (time asleep is less than time threshold)
+	 * and demote when the usage threshold is reached.
+	 */
+	if (cx->demotion.state) {
+		if (sleep_ticks < cx->demotion.threshold.ticks) {
+			cx->demotion.count++;
+			cx->promotion.count = 0;
+			if (cx->demotion.count >= cx->demotion.threshold.count) {
+				next_state = cx->demotion.state;
+				goto end;
+			}
+		}
+	}
+
+end:
+	/*
+	 * New Cx State?
+	 * -------------
+	 * If we're going to start using a new Cx state we must clean up
+	 * from the previous and prepare to use the new.
+	 */
+	if (next_state != pr->power.state)
+		acpi_processor_power_activate(pr, next_state);
+
+	return;
+}
+
+
+static int
+acpi_processor_set_power_policy (
+	struct acpi_processor	*pr)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_set_power_policy");
+
+	/*
+	 * This function sets the default Cx state policy (OS idle handler).
+	 * Our scheme is to promote quickly to C2 but more conservatively
+	 * to C3.  We're favoring C2  for its characteristics of low latency
+	 * (quick response), good power savings, and ability to allow bus
+	 * mastering activity.  Note that the Cx state policy is completely
+	 * customizable and can be altered dynamically.
+	 */
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * C0/C1
+	 * -----
+	 */
+	pr->power.state = ACPI_STATE_C1;
+	pr->power.default_state = ACPI_STATE_C1;
+
+	/*
+	 * C1/C2
+	 * -----
+	 * Set the default C1 promotion and C2 demotion policies, where we
+	 * promote from C1 to C2 after several (10) successive C1 transitions,
+	 * as we cannot (currently) measure the time spent in C1. Demote from
+	 * C2 to C1 anytime we experience a 'short' (time spent in C2 is less
+	 * than the C2 transtion latency).  Note the simplifying assumption 
+	 * that the 'cost' of a transition is amortized when we sleep for at
+	 * least as long as the transition's latency (thus the total transition
+	 * time is two times the latency).
+	 *
+	 * TBD: Measure C1 sleep times by instrumenting the core IRQ handler.
+	 * TBD: Demote to default C-State after long periods of activity.
+	 * TBD: Investigate policy's use of CPU utilization -vs- sleep duration.
+	 */
+	if (pr->power.states[ACPI_STATE_C2].valid) {
+		pr->power.states[ACPI_STATE_C1].promotion.threshold.count = 10;
+		pr->power.states[ACPI_STATE_C1].promotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C2].latency_ticks;
+		pr->power.states[ACPI_STATE_C1].promotion.state = ACPI_STATE_C2;
+
+		pr->power.states[ACPI_STATE_C2].demotion.threshold.count = 1;
+		pr->power.states[ACPI_STATE_C2].demotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C2].latency_ticks;
+		pr->power.states[ACPI_STATE_C2].demotion.state = ACPI_STATE_C1;
+	}
+
+	/*
+	 * C2/C3
+	 * -----
+	 * Set default C2 promotion and C3 demotion policies, where we promote
+	 * from C2 to C3 after several (4) cycles of no bus mastering activity
+	 * while maintaining sleep time criteria.  Demote immediately on a
+	 * short or whenever bus mastering activity occurs.
+	 */
+	if ((pr->power.states[ACPI_STATE_C2].valid) &&
+		(pr->power.states[ACPI_STATE_C3].valid)) {
+		pr->power.states[ACPI_STATE_C2].promotion.threshold.count = 4;
+		pr->power.states[ACPI_STATE_C2].promotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C3].latency_ticks;
+		pr->power.states[ACPI_STATE_C2].promotion.threshold.bm = 0x0F;
+		pr->power.states[ACPI_STATE_C2].promotion.state = ACPI_STATE_C3;
+
+		pr->power.states[ACPI_STATE_C3].demotion.threshold.count = 1;
+		pr->power.states[ACPI_STATE_C3].demotion.threshold.ticks =
+			pr->power.states[ACPI_STATE_C3].latency_ticks;
+		pr->power.states[ACPI_STATE_C3].demotion.threshold.bm = 0x0F;
+		pr->power.states[ACPI_STATE_C3].demotion.state = ACPI_STATE_C2;
+	}
+
+	return_VALUE(0);
+}
+
+
+int
+acpi_processor_get_power_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_power_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"lvl2[0x%08x] lvl3[0x%08x]\n",
+		pr->power.states[ACPI_STATE_C2].address,
+		pr->power.states[ACPI_STATE_C3].address));
+
+	/* TBD: Support ACPI 2.0 objects */
+
+	/*
+	 * C0
+	 * --
+	 * This state exists only as filler in our array.
+	 */
+	pr->power.states[ACPI_STATE_C0].valid = 1;
+
+	/*
+	 * C1
+	 * --
+	 * ACPI requires C1 support for all processors.
+	 *
+	 * TBD: What about PROC_C1?
+	 */
+	pr->power.states[ACPI_STATE_C1].valid = 1;
+
+	/*
+	 * C2
+	 * --
+	 * We're (currently) only supporting C2 on UP systems.
+	 *
+	 * TBD: Support for C2 on MP (P_LVL2_UP).
+	 */
+	if (pr->power.states[ACPI_STATE_C2].address) {
+
+		pr->power.states[ACPI_STATE_C2].latency = acpi_fadt.plvl2_lat;
+
+		/*
+		 * C2 latency must be less than or equal to 100 microseconds.
+		 */
+		if (acpi_fadt.plvl2_lat >= ACPI_PROCESSOR_MAX_C2_LATENCY)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C2 latency too large [%d]\n",
+				acpi_fadt.plvl2_lat));
+		/*
+		 * Only support C2 on UP systems (see TBD above).
+		 */
+		else if (errata.smp)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C2 not supported in SMP mode\n"));
+		/*
+		 * Otherwise we've met all of our C2 requirements.
+		 * Normalize the C2 latency to expidite policy.
+		 */
+		else {
+			pr->power.states[ACPI_STATE_C2].valid = 1;
+			pr->power.states[ACPI_STATE_C2].latency_ticks = 
+				US_TO_PM_TIMER_TICKS(acpi_fadt.plvl2_lat);
+		}
+	}
+
+	/*
+	 * C3
+	 * --
+	 * TBD: Investigate use of WBINVD on UP/SMP system in absence of
+	 *	bm_control.
+	 */
+	if (pr->power.states[ACPI_STATE_C3].address) {
+
+		pr->power.states[ACPI_STATE_C3].latency = acpi_fadt.plvl3_lat;
+
+		/*
+		 * C3 latency must be less than or equal to 1000 microseconds.
+		 */
+		if (acpi_fadt.plvl3_lat >= ACPI_PROCESSOR_MAX_C3_LATENCY)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 latency too large [%d]\n", 
+				acpi_fadt.plvl3_lat));
+		/*
+		 * Only support C3 when bus mastering arbitration control
+		 * is present (able to disable bus mastering to maintain
+		 * cache coherency while in C3).
+		 */
+		else if (!pr->flags.bm_control)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 support requires bus mastering control\n"));
+		/*
+		 * Only support C3 on UP systems, as bm_control is only viable
+		 * on a UP system and flushing caches (e.g. WBINVD) is simply 
+		 * too costly (at this time).
+		 */
+		else if (errata.smp)
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 not supported in SMP mode\n"));
+		/*
+		 * PIIX4 Erratum #18: We don't support C3 when Type-F (fast) 
+		 * DMA transfers are used by any ISA device to avoid livelock.
+		 * Note that we could disable Type-F DMA (as recommended by
+		 * the erratum), but this is known to disrupt certain ISA 
+		 * devices thus we take the conservative approach.
+		 */
+		else if (errata.piix4.fdma) {
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				"C3 not supported on PIIX4 with Type-F DMA\n"));
+		}
+		/*
+		 * Otherwise we've met all of our C3 requirements.  
+		 * Normalize the C2 latency to expidite policy.  Enable
+		 * checking of bus mastering status (bm_check) so we can 
+		 * use this in our C3 policy.
+		 */
+		else {
+			pr->power.states[ACPI_STATE_C3].valid = 1;
+			pr->power.states[ACPI_STATE_C3].latency_ticks = 
+				US_TO_PM_TIMER_TICKS(acpi_fadt.plvl3_lat);
+			pr->flags.bm_check = 1;
+		}
+	}
+
+	/*
+	 * Set Default Policy
+	 * ------------------
+	 * Now that we know which state are supported, set the default
+	 * policy.  Note that this policy can be changed dynamically
+	 * (e.g. encourage deeper sleeps to conserve battery life when
+	 * not on AC).
+	 */
+	result = acpi_processor_set_power_policy(pr);
+	if (0 != result)
+		return_VALUE(result);
+
+	/*
+	 * If this processor supports C2 or C3 we denote it as being 'power
+	 * manageable'.  Note that there's really no policy involved for
+	 * when only C1 is supported.
+	 */
+	if (pr->power.states[ACPI_STATE_C2].valid 
+		|| pr->power.states[ACPI_STATE_C3].valid)
+		pr->flags.power = 1;
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              Performance Management
+   -------------------------------------------------------------------------- */
+
+static int 
+acpi_processor_get_platform_limit (
+	struct acpi_processor*	pr)
+{
+	acpi_status		status = 0;
+	unsigned long		ppc = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_platform_limit");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/*
+	 * _PPC indicates the maximum state currently supported by the platform
+	 * (e.g. 0 = states 0..n; 1 = states 1..n; etc.
+	 */
+	status = acpi_evaluate_integer(pr->handle, "_PPC", NULL, &ppc);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PPC\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pr->performance.platform_limit = (int) ppc;
+
+	return_VALUE(0);
+}
+
+
+static int 
+acpi_processor_get_performance_control (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	acpi_status		status = 0;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_object		*pct = NULL;
+	acpi_object		obj = {0};
+	struct acpi_pct_register *reg = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_control");
+
+	status = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PCT\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pct = (acpi_object *) buffer.pointer;
+	if (!pct || (pct->type != ACPI_TYPE_PACKAGE) 
+		|| (pct->package.count != 2)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PCT data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	/*
+	 * control_register
+	 */
+
+	obj = pct->package.elements[0];
+
+	if ((obj.type != ACPI_TYPE_BUFFER) 
+		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
+		|| (obj.buffer.pointer == NULL)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid _PCT data (control_register)\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	reg = (struct acpi_pct_register *) (obj.buffer.pointer);
+
+	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unsupported address space [%d] (control_register)\n",
+			(u32) reg->space_id));
+		result = -EFAULT;
+		goto end;
+	}
+
+	pr->performance.control_register = (u16) reg->address;
+
+	/*
+	 * status_register
+	 */
+
+	obj = pct->package.elements[1];
+
+	if ((obj.type != ACPI_TYPE_BUFFER) 
+		|| (obj.buffer.length < sizeof(struct acpi_pct_register)) 
+		|| (obj.buffer.pointer == NULL)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Invalid _PCT data (status_register)\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	reg = (struct acpi_pct_register *) (obj.buffer.pointer);
+
+	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unsupported address space [%d] (status_register)\n",
+			(u32) reg->space_id));
+		result = -EFAULT;
+		goto end;
+	}
+
+	pr->performance.status_register = (u16) reg->address;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"control_register[0x%04x] status_register[0x%04x]\n",
+		pr->performance.control_register,
+		pr->performance.status_register));
+
+end:
+	kfree(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int 
+acpi_processor_get_performance_states (
+	struct acpi_processor*	pr)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_buffer		format = {sizeof("NNNNNN"), "NNNNNN"};
+	acpi_buffer		state = {0, NULL};
+	acpi_object 		*pss = NULL;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_states");
+
+	status = acpi_evaluate_object(pr->handle, "_PSS", NULL, &buffer);
+	if(ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Error evaluating _PSS\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	pss = (acpi_object *) buffer.pointer;
+	if (!pss || (pss->type != ACPI_TYPE_PACKAGE)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d performance states\n", 
+		pss->package.count));
+
+	if (pss->package.count > ACPI_PROCESSOR_MAX_PERFORMANCE) {
+		pr->performance.state_count = ACPI_PROCESSOR_MAX_PERFORMANCE;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Limiting number of states to max (%d)\n", 
+			ACPI_PROCESSOR_MAX_PERFORMANCE));
+	}
+	else
+		pr->performance.state_count = pss->package.count;
+
+	if (pr->performance.state_count > 1)
+		pr->flags.performance = 1;
+
+	for (i = 0; i < pr->performance.state_count; i++) {
+
+		struct acpi_processor_px *px = &(pr->performance.states[i]);
+
+		state.length = sizeof(struct acpi_processor_px);
+		state.pointer = px;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));
+
+		status = acpi_extract_package(&(pss->package.elements[i]), 
+			&format, &state);
+		if (ACPI_FAILURE(status)) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _PSS data\n"));
+			result = -EFAULT;
+			goto end;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\n",
+			i, 
+			(u32) px->core_frequency, 
+			(u32) px->power, 
+			(u32) px->transition_latency, 
+			(u32) px->bus_master_latency,
+			(u32) px->control, 
+			(u32) px->status));
+	}
+
+end:
+	kfree(buffer.pointer);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_set_performance (
+	struct acpi_processor	*pr,
+	int			state)
+{
+	u16			port = 0;
+	u8			value = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_performance");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.performance)
+		return_VALUE(-ENODEV);
+
+	if (state >= pr->performance.state_count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+			"Invalid target state (P%d)\n", state));
+		return_VALUE(-ENODEV);
+	}
+
+	if (state < pr->performance.platform_limit) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, 
+			"Platform limit (P%d) overrides target state (P%d)\n",
+			pr->performance.platform_limit, state));
+		return_VALUE(-ENODEV);
+	}
+
+	if (state == pr->performance.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Already at target state (P%d)\n", state));
+		return_VALUE(0);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Transitioning from P%d to P%d\n",
+		pr->performance.state, state));
+
+	/*
+	 * First we write the target state's 'control' value to the
+	 * control_register.
+	 */
+
+	port = pr->performance.control_register;
+	value = (u16) pr->performance.states[state].control;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Writing 0x%02x to port 0x%04x\n", value, port));
+
+	outb(value, port); 
+
+	/*
+	 * Then we read the 'status_register' and compare the value with the
+	 * target state's 'status' to make sure the transition was successful.
+	 * Note that we'll poll for up to 1ms (100 cycles of 10us) before
+	 * giving up.
+	 */
+
+	port = pr->performance.status_register;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Looking for 0x%02x from port 0x%04x\n",
+		(u8) pr->performance.states[state].status, port));
+
+	for (i=0; i<100; i++) {
+		value = inb(port);
+		if (value == (u8) pr->performance.states[state].status)
+			break;
+		udelay(10);
+	}
+
+	if (value != pr->performance.states[state].status) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Transition failed\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Transition successful after %d microseconds\n",
+		i * 10));
+
+	pr->performance.state = state;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_get_performance_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_performance_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	status = acpi_get_handle(pr->handle, "_PCT", &handle);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"ACPI-based processor performance control unavailable\n"));
+		return_VALUE(0);
+	}
+
+	result = acpi_processor_get_performance_control(pr);
+	if (0 != result)
+		return_VALUE(result);
+
+	result = acpi_processor_get_performance_states(pr);
+	if (0 != result)
+		return_VALUE(result);
+
+	result = acpi_processor_get_platform_limit(pr);
+	if (0 != result)
+		return_VALUE(result);
+
+	/* 
+	 * TBD: Don't trust the latency values we get from BIOS, but rather
+	 *      measure the latencies during run-time (e.g. get_latencies).
+	 */
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              Throttling Control
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_get_throttling (
+	struct acpi_processor	*pr)
+{
+	int			state = 0;
+	u32			value = 0;
+	u32			duty_mask = 0;
+	u32			duty_value = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.throttling)
+		return_VALUE(-ENODEV);
+
+	pr->throttling.state = 0;
+
+	__cli();
+
+	duty_mask = pr->throttling.state_count - 1;
+
+	duty_mask <<= pr->throttling.duty_offset;
+
+	value = inl(pr->throttling.address);
+
+	/*
+	 * Compute the current throttling state when throttling is enabled
+	 * (bit 4 is on).
+	 */
+	if (value & 0x10) {
+		duty_value = value & duty_mask;
+		duty_value >>= pr->throttling.duty_offset;
+
+		if (duty_value)
+			state = pr->throttling.state_count-duty_value;
+	}
+
+	pr->throttling.state = state;
+
+	__sti();
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Throttling state is T%d (%d%% throttling applied)\n",
+		state, pr->throttling.states[state].performance));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_set_throttling (
+	struct acpi_processor	*pr,
+	int			state)
+{
+	u32                     value = 0;
+	u32                     duty_mask = 0;
+	u32                     duty_value = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_throttling");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if ((state < 0) || (state > (pr->throttling.state_count - 1)))
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.throttling)
+		return_VALUE(-ENODEV);
+
+	if (state == pr->throttling.state)
+		return_VALUE(0);
+
+	__cli();
+
+	/*
+	 * Calculate the duty_value and duty_mask.
+	 */
+	if (state) {
+		duty_value = pr->throttling.state_count - state;
+
+		duty_value <<= pr->throttling.duty_offset;
+
+		/* Used to clear all duty_value bits */
+		duty_mask = pr->throttling.state_count - 1;
+
+		duty_mask <<= acpi_fadt.duty_offset;
+		duty_mask = ~duty_mask;
+	}
+
+	/*
+	 * Disable throttling by writing a 0 to bit 4.  Note that we must
+	 * turn it off before you can change the duty_value.
+	 */
+	value = inl(pr->throttling.address);
+	if (value & 0x10) {
+		value &= 0xFFFFFFEF;
+		outl(value, pr->throttling.address);
+	}
+
+	/*
+	 * Write the new duty_value and then enable throttling.  Note
+	 * that a state value of 0 leaves throttling disabled.
+	 */
+	if (state) {
+		value &= duty_mask;
+		value |= duty_value;
+		outl(value, pr->throttling.address);
+
+		value |= 0x00000010;
+		outl(value, pr->throttling.address);
+	}
+
+	pr->throttling.state = state;
+
+	__sti();
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+		"Throttling state set to T%d (%d%%)\n", state, 
+		(pr->throttling.states[state].performance?pr->throttling.states[state].performance/10:0)));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_get_throttling_info (
+	struct acpi_processor	*pr)
+{
+	int			result = 0;
+	int			step = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling_info");
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+		"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",
+		pr->throttling.address,
+		pr->throttling.duty_offset,
+		pr->throttling.duty_width));
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	/* TBD: Support ACPI 2.0 objects */
+
+	if (!pr->throttling.address) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));
+		return_VALUE(0);
+	}
+	else if (!pr->throttling.duty_width) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));
+		return_VALUE(0);
+	}
+	/* TBD: Support duty_cycle values that span bit 4. */
+	else if ((pr->throttling.duty_offset
+		+ pr->throttling.duty_width) > 4) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "duty_cycle spans bit 4\n"));
+		return_VALUE(0);
+	}
+
+	/*
+	 * PIIX4 Errata: We don't support throttling on the original PIIX4.
+	 * This shouldn't be an issue as few (if any) mobile systems ever
+	 * used this part.
+	 */
+	if (errata.piix4.throttle) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"Throttling not supported on PIIX4 A- or B-step\n"));
+		return_VALUE(0);
+	}
+
+	pr->throttling.state_count = POWER_OF_2[acpi_fadt.duty_width];
+
+	/*
+	 * Compute state values. Note that throttling displays a linear power/
+	 * performance relationship (at 50% performance the CPU will consume
+	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.
+	 */
+
+	step = (1000 / pr->throttling.state_count);
+
+	for (i=0; i<pr->throttling.state_count; i++) {
+		pr->throttling.states[i].performance = step * i;
+		pr->throttling.states[i].power = step * i;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n", 
+		pr->throttling.state_count));
+
+	pr->flags.throttling = 1;
+
+	/*
+	 * Disable throttling (if enabled).  We'll let subsequent policy (e.g. 
+	 * thermal) decide to lower performance if it so chooses, but for now 
+	 * we'll crank up the speed.
+	 */
+
+	result = acpi_processor_get_throttling(pr);
+	if (0 != result)
+		goto end;
+
+	if (pr->throttling.state) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabling throttling (was T%d)\n", 
+			pr->throttling.state));
+		result = acpi_processor_set_throttling(pr, 0);
+		if (0 != result)
+			goto end;
+	}
+
+end:
+	if (0 != result)
+		pr->flags.throttling = 0;
+
+	return_VALUE(result);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Limit Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_apply_limit (
+	struct acpi_processor* 	pr)
+{
+	int			result = 0;
+	u16			px = 0;
+	u16			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_apply_limit");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (!pr->flags.limit)
+		return_VALUE(-ENODEV);
+
+	if (pr->flags.performance) {
+		px = pr->performance.platform_limit;
+		if (pr->limit.user.px > px)
+			px = pr->limit.user.px;
+		if (pr->limit.thermal.px > px)
+			px = pr->limit.thermal.px;
+
+		result = acpi_processor_set_performance(pr, px);
+		if (0 != result)
+			goto end;
+	}
+
+	if (pr->flags.throttling) {
+		if (pr->limit.user.tx > tx)
+			tx = pr->limit.user.tx;
+		if (pr->limit.thermal.tx > tx)
+			tx = pr->limit.thermal.tx;
+
+		result = acpi_processor_set_throttling(pr, tx);
+		if (0 != result)
+			goto end;
+	}
+
+	pr->limit.state.px = px;
+	pr->limit.state.tx = tx;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d] limit set to (P%d:T%d)\n",
+		pr->id,
+		pr->limit.state.px,
+		pr->limit.state.tx));
+
+end:
+	if (0 != result)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unable to set limit\n"));
+
+	return_VALUE(result);
+}
+
+
+int
+acpi_processor_set_thermal_limit (
+	acpi_handle		handle,
+	int			type)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = NULL;
+	struct acpi_device	*device = NULL;
+	int			px = 0;
+	int			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_set_thermal_limit");
+
+	if ((type < ACPI_PROCESSOR_LIMIT_NONE) 
+		|| (type > ACPI_PROCESSOR_LIMIT_DECREMENT))
+		return_VALUE(-EINVAL);
+
+	result = acpi_bus_get_device(handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+
+	pr = (struct acpi_processor *) acpi_driver_data(device);
+	if (!pr)
+		return_VALUE(-ENODEV);
+
+	if (!pr->flags.limit)
+		return_VALUE(-ENODEV);
+
+	/* Thermal limits are always relative to the current Px/Tx state. */
+	if (pr->flags.performance)
+		pr->limit.thermal.px = pr->performance.state;
+	if (pr->flags.throttling)
+		pr->limit.thermal.tx = pr->throttling.state;
+
+	/*
+	 * Our default policy is to only use throttling at the lowest
+	 * performance state.
+	 */
+
+	switch (type) {
+
+	case ACPI_PROCESSOR_LIMIT_NONE:
+		px = 0;
+		tx = 0;
+		break;
+
+	case ACPI_PROCESSOR_LIMIT_INCREMENT:
+		if (pr->flags.performance) {
+			if (px == (pr->performance.state_count - 1))
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At maximum performance state\n"));
+			else {
+				px++;
+				goto end;
+			}
+		}
+		if (pr->flags.throttling) {
+			if (tx == (pr->throttling.state_count - 1))
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At maximum throttling state\n"));
+			else
+				tx++;
+		}
+		break;
+
+	case ACPI_PROCESSOR_LIMIT_DECREMENT:
+		if (pr->flags.performance) {
+			if (px == pr->performance.platform_limit)
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At minimum performance state\n"));
+			else  {
+				px--;
+				goto end;
+			}
+		}
+		if (pr->flags.throttling) {
+			if (tx == 0)
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+					"At minimum throttling state\n"));
+			else
+				tx--;
+		}
+		break;
+	}
+
+end:
+	pr->limit.thermal.px = px;
+	pr->limit.thermal.tx = tx;
+
+	result = acpi_processor_apply_limit(pr);
+	if (0 != result)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Unable to set thermal limit\n"));
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Thermal limit now (P%d:T%d)\n",
+		pr->limit.thermal.px,
+		pr->limit.thermal.tx));
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_get_limit_info (
+	struct acpi_processor	*pr)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_get_limit_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+	if (pr->flags.performance || pr->flags.throttling)
+		pr->flags.limit = 1;
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry		*acpi_processor_dir = NULL;
+
+static int
+acpi_processor_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_info");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	p += sprintf(p, "processor id:            %d\n",
+		pr->id);
+
+	p += sprintf(p, "acpi id:                 %d\n",
+		pr->acpi_id);
+
+	p += sprintf(p, "bus mastering control:   %s\n",
+		pr->flags.bm_control ? "yes" : "no");
+
+	p += sprintf(p, "power management:        %s\n",
+		pr->flags.power ? "yes" : "no");
+
+	p += sprintf(p, "throttling control:      %s\n",
+		pr->flags.throttling ? "yes" : "no");
+
+	p += sprintf(p, "performance management:  %s\n",
+		pr->flags.performance ? "yes" : "no");
+
+	p += sprintf(p, "limit interface:         %s\n",
+		pr->flags.limit ? "yes" : "no");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_read_power (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_power");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	p += sprintf(p, "active state:            C%d\n",
+		pr->power.state);
+
+	p += sprintf(p, "default state:           C%d\n",
+		pr->power.default_state);
+
+	p += sprintf(p, "bus master activity:     %08x\n",
+		pr->power.bm_activity);
+
+	p += sprintf(p, "states:\n");
+
+	for (i=1; i<ACPI_C_STATE_COUNT; i++) {
+
+		p += sprintf(p, "   %cC%d:                  ", 
+			(i == pr->power.state?'*':' '), i);
+
+		if (!pr->power.states[i].valid) {
+			p += sprintf(p, "<not supported>\n");
+			continue;
+		}
+
+		if (pr->power.states[i].promotion.state)
+			p += sprintf(p, "promotion[C%d] ",
+				pr->power.states[i].promotion.state);
+		else
+			p += sprintf(p, "promotion[--] ");
+
+		if (pr->power.states[i].demotion.state)
+			p += sprintf(p, "demotion[C%d] ",
+				pr->power.states[i].demotion.state);
+		else
+			p += sprintf(p, "demotion[--] ");
+
+		p += sprintf(p, "latency[%03d] usage[%08d]\n",
+			pr->power.states[i].latency,
+			pr->power.states[i].usage);
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_read_performance (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_performance");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	if (!pr->flags.performance) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "state count:             %d\n",
+		pr->performance.state_count);
+
+	p += sprintf(p, "active state:            P%d\n",
+		pr->performance.state);
+
+	p += sprintf(p, "states:\n");
+
+	for (i=0; i<pr->performance.state_count; i++)
+		p += sprintf(p, "   %cP%d:                  %d MHz, %d mW, %d uS\n",
+			(i == pr->performance.state?'*':' '), i,
+			(u32) pr->performance.states[i].core_frequency,
+			(u32) pr->performance.states[i].power,
+			(u32) pr->performance.states[i].transition_latency);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_write_performance (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			state_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_performance");
+
+	if (!pr || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+
+	result = acpi_processor_set_performance(pr, 
+		simple_strtoul(state_string, NULL, 0));
+	if (0 != result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_processor_read_throttling (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+	int                     result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_throttling");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	if (!(pr->throttling.state_count > 0)) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	result = acpi_processor_get_throttling(pr);
+
+	if (result) {
+		p += sprintf(p, "Could not determine current throttling state.\n");
+		goto end;
+	}
+
+	p += sprintf(p, "state count:             %d\n",
+		pr->throttling.state_count);
+
+	p += sprintf(p, "active state:            T%d\n",
+		pr->throttling.state);
+
+	p += sprintf(p, "states:\n");
+
+	for (i=0; i<pr->throttling.state_count; i++)
+		p += sprintf(p, "   %cT%d:                  %02d%%\n",
+			(i == pr->throttling.state?'*':' '), i,
+			(pr->throttling.states[i].performance?pr->throttling.states[i].performance/10:0));
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_write_throttling (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			state_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_throttling");
+
+	if (!pr || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+	
+	result = acpi_processor_set_throttling(pr, 
+		simple_strtoul(state_string, NULL, 0));
+	if (0 != result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_processor_read_limit (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_read_limit");
+
+	if (!pr || (off != 0))
+		goto end;
+
+	if (!pr->flags.limit) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "active limit:            P%d:T%d\n",
+		pr->limit.state.px, pr->limit.state.tx);
+
+	p += sprintf(p, "platform limit:          P%d:T0\n",
+		pr->flags.performance?pr->performance.platform_limit:0);
+
+	p += sprintf(p, "user limit:              P%d:T%d\n",
+		pr->limit.user.px, pr->limit.user.tx);
+
+	p += sprintf(p, "thermal limit:           P%d:T%d\n",
+		pr->limit.thermal.px, pr->limit.thermal.tx);
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_processor_write_limit (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	char			limit_string[25] = {'\0'};
+	int			px = 0;
+	int			tx = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_write_limit");
+
+	if (!pr || (count > sizeof(limit_string) - 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid argument\n"));
+		return_VALUE(-EINVAL);
+	}
+	
+	if (copy_from_user(limit_string, buffer, count)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data\n"));
+		return_VALUE(-EFAULT);
+	}
+	
+	limit_string[count] = '\0';
+
+	if (sscanf(limit_string, "%d:%d", &px, &tx) != 2) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid data format\n"));
+		return_VALUE(-EINVAL);
+	}
+
+	if (pr->flags.performance) {
+		if ((px < pr->performance.platform_limit) 
+			|| (px > (pr->performance.state_count - 1))) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid px\n"));
+			return_VALUE(-EINVAL);
+		}
+		pr->limit.user.px = px;
+	}
+
+	if (pr->flags.throttling) {
+		if ((tx < 0) || (tx > (pr->throttling.state_count - 1))) {
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid tx\n"));
+			return_VALUE(-EINVAL);
+		}
+		pr->limit.user.tx = tx;
+	}
+
+	result = acpi_processor_apply_limit(pr);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_processor_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_add_fs");
+
+	if (!acpi_processor_dir) {
+		acpi_processor_dir = proc_mkdir(ACPI_PROCESSOR_CLASS, 
+			acpi_root_dir);
+		if (!acpi_processor_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_processor_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_INFO));
+	else {
+		entry->read_proc = acpi_processor_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'power' [R] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_POWER,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_POWER));
+	else {
+		entry->read_proc = acpi_processor_read_power;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'performance' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_PERFORMANCE,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_PERFORMANCE));
+	else {
+		entry->read_proc = acpi_processor_read_performance;
+		entry->write_proc = acpi_processor_write_performance;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'throttling' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_THROTTLING,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_THROTTLING));
+	else {
+		entry->read_proc = acpi_processor_read_throttling;
+		entry->write_proc = acpi_processor_write_throttling;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'limit' [R/W] */
+	entry = create_proc_entry(ACPI_PROCESSOR_FILE_LIMIT,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_PROCESSOR_FILE_LIMIT));
+	else {
+		entry->read_proc = acpi_processor_read_limit;
+		entry->write_proc = acpi_processor_write_limit;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_processor_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_processor_remove_fs");
+
+	if (!acpi_processor_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_processor_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_processor_get_info (
+	struct acpi_processor	*pr)
+{
+	acpi_status		status = 0;
+	acpi_object		object = {0};
+	acpi_buffer		buffer = {sizeof(acpi_object), &object};
+	static int		cpu_count = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_get_info");
+
+	if (!pr)
+		return_VALUE(-EINVAL);
+
+#ifdef CONFIG_SMP
+	if (smp_num_cpus > 1)
+		errata.smp = smp_num_cpus;
+#endif
+
+	acpi_processor_errata(pr);
+
+	/*
+	 * Check to see if we have bus mastering arbitration control.  This
+	 * is required for proper C3 usage (to maintain cache coherency).
+	 */
+	if (acpi_fadt.V1_pm2_cnt_blk && acpi_fadt.pm2_cnt_len) {
+		pr->flags.bm_control = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Bus mastering arbitration control present\n"));
+	}
+	else
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"No bus mastering arbitration control\n"));
+
+	/*
+	 * Evalute the processor object.  Note that it is common on SMP to
+	 * have the first (boot) processor with a valid PBLK address while
+	 * all others have a NULL address.
+	 */
+	status = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error evaluating processor object\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	/*
+	 * TBD: Synch processor ID (via LAPIC/LSAPIC structures) on SMP.
+	 *	>>> 'acpi_get_processor_id(acpi_id, &id)' in arch/xxx/acpi.c
+	 */
+	pr->id = cpu_count++;
+	pr->acpi_id = object.processor.proc_id;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id, 
+		pr->acpi_id));
+
+	if (!object.processor.pblk_address)
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No PBLK (NULL address)\n"));
+	else if (object.processor.pblk_length < 6)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid PBLK length [%d]\n",
+			object.processor.pblk_length));
+	else {
+		pr->throttling.address = object.processor.pblk_address;
+		pr->throttling.duty_offset = acpi_fadt.duty_offset;
+		pr->throttling.duty_width = acpi_fadt.duty_width;
+		pr->power.states[ACPI_STATE_C2].address =
+			object.processor.pblk_address + 4;
+		pr->power.states[ACPI_STATE_C3].address =
+			object.processor.pblk_address + 5;
+	}
+
+	acpi_processor_get_power_info(pr);
+	acpi_processor_get_performance_info(pr);
+	acpi_processor_get_throttling_info(pr);
+	acpi_processor_get_limit_info(pr);
+
+	return_VALUE(0);
+}
+
+
+static void
+acpi_processor_notify (
+	acpi_handle		handle,
+	u32			event,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_processor	*pr = (struct acpi_processor *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_notify");
+
+	if (!pr)
+		return_VOID;
+
+	if (0 != acpi_bus_get_device(pr->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_PROCESSOR_NOTIFY_PERFORMANCE:
+		result = acpi_processor_get_platform_limit(pr);
+		if (0 == result)
+			acpi_processor_apply_limit(pr);
+
+		acpi_bus_generate_event(device, event, 
+			pr->performance.platform_limit);
+		break;
+	case ACPI_PROCESSOR_NOTIFY_POWER:
+		/* TBD */
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_processor_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_processor	*pr = NULL;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	pr = kmalloc(sizeof(struct acpi_processor), GFP_KERNEL);
+	if (!pr)
+		return_VALUE(-ENOMEM);
+	memset(pr, 0, sizeof(struct acpi_processor));
+
+	pr->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_PROCESSOR_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_PROCESSOR_CLASS);
+	acpi_driver_data(device) = pr;
+
+	result = acpi_processor_get_info(pr);
+	if (0 != result)
+		goto end;
+
+	result = acpi_processor_add_fs(device);
+	if (0 != result)
+		goto end;
+
+	status = acpi_install_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
+		acpi_processor_notify, pr);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	processors[pr->id] = pr;
+
+	/*
+	 * Install the idle handler if processor power management is supported.
+	 * Note that the default idle handler (default_idle) will be used on 
+	 * platforms that only support C1.
+	 */
+	if ((pr->id == 0) && (pr->flags.power)) {
+		pm_idle_save = pm_idle;
+		pm_idle = acpi_processor_idle;
+	}
+	
+	printk(KERN_INFO PREFIX "%s [%s] (supports",
+		acpi_device_name(device), acpi_device_bid(device));
+	for (i=1; i<ACPI_C_STATE_COUNT; i++)
+		if (pr->power.states[i].valid)
+			printk(" C%d", i);
+	if (pr->flags.performance)
+		printk(", %d performance states", pr->performance.state_count);
+	if (pr->flags.throttling)
+		printk(", %d throttling states", pr->throttling.state_count);
+	printk(")\n");
+
+end:
+	if (0 != result) {
+		acpi_processor_remove_fs(device);
+		kfree(pr);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_processor_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_processor	*pr = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	pr = (struct acpi_processor *) acpi_driver_data(device);
+
+	/* Unregister the idle handler when processor #0 is removed. */
+	if (pr->id == 0)
+		pm_idle = pm_idle_save;
+
+	status = acpi_remove_notify_handler(pr->handle, ACPI_DEVICE_NOTIFY, 
+		acpi_processor_notify);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
+			"Error removing notify handler\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	acpi_processor_remove_fs(device);
+
+	processors[pr->id] = NULL;
+
+	kfree(pr);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_processor_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_init");
+
+	memset(&processors, 0, sizeof(processors));
+	memset(&errata, 0, sizeof(errata));
+
+	result = acpi_bus_register_driver(&acpi_processor_driver);
+	if (0 > result)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_processor_exit (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_processor_exit");
+
+	result = acpi_bus_unregister_driver(&acpi_processor_driver);
+	if (0 == result)
+		remove_proc_entry(ACPI_PROCESSOR_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_processor_init);
+module_exit(acpi_processor_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsaddr.c linux/drivers/acpi/resources/rsaddr.c
--- ../prev/linux/drivers/acpi/resources/rsaddr.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsaddr.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsaddr - Address resource descriptors (16/32/64)
- *              $Revision: 24 $
+ *              $Revision: 26 $
  *
  ******************************************************************************/
 
@@ -60,8 +60,8 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
-	NATIVE_CHAR             *temp_ptr;
+	acpi_resource           *output_struct = (void *) *output_buffer;
+	u8                      *temp_ptr;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_address16);
 	u32                     index;
 	u16                     temp16;
@@ -200,7 +200,7 @@
 		output_struct->data.address16.resource_source.string_ptr =
 				(NATIVE_CHAR *)((u8 * )output_struct + struct_size);
 
-		temp_ptr = output_struct->data.address16.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.address16.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -238,7 +238,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -390,8 +390,7 @@
 		 * Buffer needs to be set to the length of the sting + one for the
 		 *  terminating null
 		 */
-		buffer += (ACPI_STRLEN (linked_list->data.address16.resource_source.string_ptr)
-				 + 1);
+		buffer += (ACPI_STRLEN (linked_list->data.address16.resource_source.string_ptr) + 1);
 	}
 
 	/*
@@ -439,10 +438,10 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer;
-	acpi_resource           *output_struct;
+	acpi_resource           *output_struct= (void *) *output_buffer;
 	u16                     temp16;
 	u8                      temp8;
-	NATIVE_CHAR             *temp_ptr;
+	u8                      *temp_ptr;
 	ACPI_SIZE               struct_size;
 	u32                     index;
 
@@ -451,8 +450,6 @@
 
 
 	buffer = byte_stream_buffer;
-	output_struct = (acpi_resource *) *output_buffer;
-
 	struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_address32);
 
 	/*
@@ -588,7 +585,7 @@
 		output_struct->data.address32.resource_source.string_ptr =
 				(NATIVE_CHAR *)((u8 *)output_struct + struct_size);
 
-		temp_ptr = output_struct->data.address32.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.address32.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -624,7 +621,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -676,7 +673,7 @@
 	/*
 	 * Set a pointer to the Length field - to be filled in later
 	 */
-	length_field = (u16 *) buffer;
+	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
 	/*
@@ -823,10 +820,10 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer;
-	acpi_resource           *output_struct;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16;
 	u8                      temp8;
-	NATIVE_CHAR             *temp_ptr;
+	u8                      *temp_ptr;
 	ACPI_SIZE               struct_size;
 	u32                     index;
 
@@ -835,8 +832,6 @@
 
 
 	buffer = byte_stream_buffer;
-	output_struct = (acpi_resource *) *output_buffer;
-
 	struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_address64);
 
 	/*
@@ -975,7 +970,7 @@
 		output_struct->data.address64.resource_source.string_ptr =
 				(NATIVE_CHAR *)((u8 *)output_struct + struct_size);
 
-		temp_ptr = output_struct->data.address64.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.address64.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -1012,7 +1007,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -1065,7 +1060,7 @@
 	 * Set a pointer to the Length field - to be filled in later
 	 */
 
-	length_field = (u16 *)buffer;
+	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
 	/*
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rscalc.c linux/drivers/acpi/resources/rscalc.c
--- ../prev/linux/drivers/acpi/resources/rscalc.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rscalc.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rscalc - Calculate stream and list lengths
- *              $Revision: 39 $
+ *              $Revision: 42 $
  *
  ******************************************************************************/
 
@@ -35,7 +35,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_calculate_byte_stream_length
+ * FUNCTION:    Acpi_rs_get_byte_stream_length
  *
  * PARAMETERS:  Linked_list         - Pointer to the resource linked list
  *              Size_needed         - u32 pointer of the size buffer needed
@@ -50,7 +50,7 @@
  ******************************************************************************/
 
 acpi_status
-acpi_rs_calculate_byte_stream_length (
+acpi_rs_get_byte_stream_length (
 	acpi_resource           *linked_list,
 	ACPI_SIZE               *size_needed)
 {
@@ -60,7 +60,7 @@
 	u8                      done = FALSE;
 
 
-	ACPI_FUNCTION_TRACE ("Rs_calculate_byte_stream_length");
+	ACPI_FUNCTION_TRACE ("Rs_get_byte_stream_length");
 
 
 	while (!done) {
@@ -180,9 +180,9 @@
 			 */
 			segment_size = 16;
 
-			if (NULL != linked_list->data.address16.resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.address16.resource_source.string_length);
+			if (linked_list->data.address16.resource_source.string_ptr) {
+				segment_size += linked_list->data.address16.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -196,9 +196,9 @@
 			 */
 			segment_size = 26;
 
-			if (NULL != linked_list->data.address32.resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.address32.resource_source.string_length);
+			if (linked_list->data.address32.resource_source.string_ptr) {
+				segment_size += linked_list->data.address32.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -212,9 +212,9 @@
 			 */
 			segment_size = 46;
 
-			if (NULL != linked_list->data.address64.resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.address64.resource_source.string_length);
+			if (linked_list->data.address64.resource_source.string_ptr) {
+				segment_size += linked_list->data.address64.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -229,11 +229,11 @@
 			 * Resource Source + 1 for the null.
 			 */
 			segment_size = 9 +
-				((linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
+				(((ACPI_SIZE) linked_list->data.extended_irq.number_of_interrupts - 1) * 4);
 
-			if (NULL != ex_irq->resource_source.string_ptr) {
-				segment_size += (1 +
-					linked_list->data.extended_irq.resource_source.string_length);
+			if (ex_irq && ex_irq->resource_source.string_ptr) {
+				segment_size += linked_list->data.extended_irq.resource_source.string_length;
+				segment_size++;
 			}
 			break;
 
@@ -268,7 +268,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_calculate_list_length
+ * FUNCTION:    Acpi_rs_get_list_length
  *
  * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource byte stream
  *              Byte_stream_buffer_length - Size of Byte_stream_buffer
@@ -285,7 +285,7 @@
  ******************************************************************************/
 
 acpi_status
-acpi_rs_calculate_list_length (
+acpi_rs_get_list_length (
 	u8                      *byte_stream_buffer,
 	u32                     byte_stream_buffer_length,
 	ACPI_SIZE               *size_needed)
@@ -304,7 +304,7 @@
 	u8                      additional_bytes;
 
 
-	ACPI_FUNCTION_TRACE ("Rs_calculate_list_length");
+	ACPI_FUNCTION_TRACE ("Rs_get_list_length");
 
 
 	while (bytes_parsed < byte_stream_buffer_length) {
@@ -705,7 +705,7 @@
 
 /*******************************************************************************
  *
- * FUNCTION:    Acpi_rs_calculate_pci_routing_table_length
+ * FUNCTION:    Acpi_rs_get_pci_routing_table_length
  *
  * PARAMETERS:  Package_object          - Pointer to the package object
  *              Buffer_size_needed      - u32 pointer of the size buffer
@@ -721,12 +721,12 @@
  ******************************************************************************/
 
 acpi_status
-acpi_rs_calculate_pci_routing_table_length (
+acpi_rs_get_pci_routing_table_length (
 	acpi_operand_object     *package_object,
 	ACPI_SIZE               *buffer_size_needed)
 {
 	u32                     number_of_elements;
-	u32                     temp_size_needed = 0;
+	ACPI_SIZE               temp_size_needed = 0;
 	acpi_operand_object     **top_object_list;
 	u32                     index;
 	acpi_operand_object     *package_element;
@@ -735,7 +735,7 @@
 	u32                     table_index;
 
 
-	ACPI_FUNCTION_TRACE ("Rs_calculate_pci_routing_table_length");
+	ACPI_FUNCTION_TRACE ("Rs_get_pci_routing_table_length");
 
 
 	number_of_elements = package_object->package.count;
@@ -788,7 +788,7 @@
 		/*
 		 * Was a String type found?
 		 */
-		if (TRUE == name_found) {
+		if (name_found) {
 			if (ACPI_TYPE_STRING == (*sub_object_list)->common.type) {
 				/*
 				 * The length String.Length field includes the
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rscreate.c linux/drivers/acpi/resources/rscreate.c
--- ../prev/linux/drivers/acpi/resources/rscreate.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rscreate.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rscreate - Create resource lists/tables
- *              $Revision: 53 $
+ *              $Revision: 56 $
  *
  ******************************************************************************/
 
@@ -79,11 +79,11 @@
 	 * Pass the Byte_stream_buffer into a module that can calculate
 	 * the buffer size needed for the linked list
 	 */
-	status = acpi_rs_calculate_list_length (byte_stream_start, byte_stream_buffer_length,
+	status = acpi_rs_get_list_length (byte_stream_start, byte_stream_buffer_length,
 			 &list_size_needed);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Status=%X List_size_needed=%X\n",
-		status, list_size_needed));
+		status, (u32) list_size_needed));
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -104,7 +104,7 @@
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Output_buffer %p Length %X\n",
-			output_buffer->pointer, output_buffer->length));
+			output_buffer->pointer, (u32) output_buffer->length));
 	return_ACPI_STATUS (AE_OK);
 }
 
@@ -157,13 +157,13 @@
 	/*
 	 * Get the required buffer length
 	 */
-	status = acpi_rs_calculate_pci_routing_table_length (package_object,
+	status = acpi_rs_get_pci_routing_table_length (package_object,
 			 &buffer_size_needed);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Buffer_size_needed = %X\n", buffer_size_needed));
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Buffer_size_needed = %X\n", (u32) buffer_size_needed));
 
 	/* Validate/Allocate/Clear caller buffer */
 
@@ -179,7 +179,7 @@
 	top_object_list  = package_object->package.elements;
 	number_of_elements = package_object->package.count;
 	buffer           = output_buffer->pointer;
-	user_prt         = (acpi_pci_routing_table *) buffer;
+	user_prt         = ACPI_CAST_PTR (acpi_pci_routing_table, buffer);
 
 	for (index = 0; index < number_of_elements; index++) {
 		/*
@@ -189,7 +189,7 @@
 		 * be zero because we cleared the return buffer earlier
 		 */
 		buffer += user_prt->length;
-		user_prt = (acpi_pci_routing_table *) buffer;
+		user_prt = ACPI_CAST_PTR (acpi_pci_routing_table, buffer);
 
 		/*
 		 * Fill in the Length field with the information we have at this point.
@@ -257,7 +257,7 @@
 					   (u32) ((u8 *) user_prt->source - (u8 *) output_buffer->pointer);
 			path_buffer.pointer = user_prt->source;
 
-			status = acpi_ns_handle_to_pathname ((acpi_handle *) node, &path_buffer);
+			status = acpi_ns_handle_to_pathname ((acpi_handle) node, &path_buffer);
 
 			user_prt->length += ACPI_STRLEN (user_prt->source) + 1; /* include null terminator */
 			break;
@@ -316,7 +316,7 @@
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Output_buffer %p Length %X\n",
-			output_buffer->pointer, output_buffer->length));
+			output_buffer->pointer, (u32) output_buffer->length));
 	return_ACPI_STATUS (AE_OK);
 }
 
@@ -359,11 +359,11 @@
 	 * Pass the Linked_list_buffer into a module that calculates
 	 * the buffer size needed for the byte stream.
 	 */
-	status = acpi_rs_calculate_byte_stream_length (linked_list_buffer,
+	status = acpi_rs_get_byte_stream_length (linked_list_buffer,
 			 &byte_stream_size_needed);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Byte_stream_size_needed=%X, %s\n",
-		byte_stream_size_needed, acpi_format_exception (status)));
+		(u32) byte_stream_size_needed, acpi_format_exception (status)));
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -384,7 +384,7 @@
 	}
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Output_buffer %p Length %X\n",
-			output_buffer->pointer, output_buffer->length));
+			output_buffer->pointer, (u32) output_buffer->length));
 	return_ACPI_STATUS (AE_OK);
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsdump.c linux/drivers/acpi/resources/rsdump.c
--- ../prev/linux/drivers/acpi/resources/rsdump.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsdump.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsdump - Functions to display the resource structures.
- *              $Revision: 29 $
+ *              $Revision: 32 $
  *
  ******************************************************************************/
 
@@ -31,7 +31,7 @@
 	 ACPI_MODULE_NAME    ("rsdump")
 
 
-#ifdef ACPI_DEBUG
+#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
 
 /*******************************************************************************
  *
@@ -172,9 +172,9 @@
 
 void
 acpi_rs_dump_start_depend_fns (
-	acpi_resource_data          *data)
+	acpi_resource_data      *data)
 {
-	acpi_resource_start_dpf     *sdf_data = (acpi_resource_start_dpf *) data;
+	acpi_resource_start_dpf *sdf_data = (acpi_resource_start_dpf *) data;
 
 
 	ACPI_FUNCTION_ENTRY ();
@@ -977,7 +977,7 @@
 
 	if (acpi_dbg_level & ACPI_LV_RESOURCES && _COMPONENT & acpi_dbg_layer) {
 		while (!done) {
-			acpi_os_printf ("Resource structure %x.\n", count++);
+			acpi_os_printf ("Resource structure %X.\n", count++);
 
 			switch (resource->id) {
 			case ACPI_RSTYPE_IRQ:
@@ -1082,7 +1082,7 @@
 
 
 	if (acpi_dbg_level & ACPI_LV_RESOURCES && _COMPONENT & acpi_dbg_layer) {
-		prt_element = (acpi_pci_routing_table *) buffer;
+		prt_element = ACPI_CAST_PTR (acpi_pci_routing_table, buffer);
 
 		while (!done) {
 			acpi_os_printf ("PCI IRQ Routing Table structure %X.\n", count++);
@@ -1100,7 +1100,7 @@
 
 			buffer += prt_element->length;
 
-			prt_element = (acpi_pci_routing_table *) buffer;
+			prt_element = ACPI_CAST_PTR (acpi_pci_routing_table, buffer);
 
 			if(0 == prt_element->length) {
 				done = TRUE;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsio.c linux/drivers/acpi/resources/rsio.c
--- ../prev/linux/drivers/acpi/resources/rsio.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsio.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsio - IO and DMA resource descriptors
- *              $Revision: 17 $
+ *              $Revision: 20 $
  *
  ******************************************************************************/
 
@@ -60,7 +60,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_io);
@@ -119,7 +119,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -158,7 +158,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_fixed_io);
@@ -193,7 +193,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -377,7 +377,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u8                      temp8 = 0;
 	u8                      index;
 	u8                      i;
@@ -407,13 +407,18 @@
 			i++;
 		}
 	}
+	if (i == 0) {
+		/* Zero channels is invalid! */
+
+		return_ACPI_STATUS (AE_BAD_DATA);
+	}
 	output_struct->data.dma.number_of_channels = i;
 
 
 	/*
 	 * Calculate the structure size based upon the number of interrupts
 	 */
-	struct_size += (output_struct->data.dma.number_of_channels - 1) * 4;
+	struct_size += ((ACPI_SIZE) output_struct->data.dma.number_of_channels - 1) * 4;
 
 	/*
 	 * Point to Byte 2
@@ -443,7 +448,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsirq.c linux/drivers/acpi/resources/rsirq.c
--- ../prev/linux/drivers/acpi/resources/rsirq.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsirq.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsirq - IRQ resource descriptors
- *              $Revision: 24 $
+ *              $Revision: 28 $
  *
  ******************************************************************************/
 
@@ -60,7 +60,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
 	u8                      index;
@@ -90,17 +90,23 @@
 	/* Decode the IRQ bits */
 
 	for (i = 0, index = 0; index < 16; index++) {
-		if((temp16 >> index) & 0x01) {
+		if ((temp16 >> index) & 0x01) {
 			output_struct->data.irq.interrupts[i] = index;
 			i++;
 		}
 	}
+
+	if (i == 0) {
+		/* Zero interrupts is invalid! */
+
+		return_ACPI_STATUS (AE_BAD_DATA);
+	}
 	output_struct->data.irq.number_of_interrupts = i;
 
 	/*
 	 * Calculate the structure size based upon the number of interrupts
 	 */
-	struct_size += (output_struct->data.irq.number_of_interrupts - 1) * 4;
+	struct_size += ((ACPI_SIZE) output_struct->data.irq.number_of_interrupts - 1) * 4;
 
 	/*
 	 * Point to Byte 3 if it is used
@@ -149,7 +155,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -279,10 +285,10 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
-	NATIVE_CHAR             *temp_ptr;
+	u8                      *temp_ptr;
 	u8                      index;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_ext_irq);
 
@@ -351,8 +357,8 @@
 	 * Cycle through every IRQ in the table
 	 */
 	for (index = 0; index < temp8; index++) {
-		output_struct->data.extended_irq.interrupts[index] =
-				(u32)*buffer;
+		ACPI_MOVE_UNALIGNED32_TO_32 (
+			&output_struct->data.extended_irq.interrupts[index], buffer);
 
 		/* Point to the next IRQ */
 
@@ -367,7 +373,7 @@
 	 * stream that are default.
 	 */
 	if (*bytes_consumed >
-		(u32)(output_struct->data.extended_irq.number_of_interrupts * 4) + 5) {
+		((ACPI_SIZE) output_struct->data.extended_irq.number_of_interrupts * 4) + 5) {
 		/* Dereference the Index */
 
 		temp8 = *buffer;
@@ -383,7 +389,7 @@
 		output_struct->data.extended_irq.resource_source.string_ptr =
 				(NATIVE_CHAR *)(output_struct + struct_size);
 
-		temp_ptr = output_struct->data.extended_irq.resource_source.string_ptr;
+		temp_ptr = (u8 *) output_struct->data.extended_irq.resource_source.string_ptr;
 
 		/* Copy the string into the buffer */
 
@@ -419,7 +425,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -470,7 +476,7 @@
 	/*
 	 * Set a pointer to the Length field - to be filled in later
 	 */
-	length_field = (u16 *)buffer;
+	length_field = ACPI_CAST_PTR (u16, buffer);
 	buffer += 2;
 
 	/*
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rslist.c linux/drivers/acpi/resources/rslist.c
--- ../prev/linux/drivers/acpi/resources/rslist.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rslist.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rslist - Linked list utilities
- *              $Revision: 26 $
+ *              $Revision: 30 $
  *
  ******************************************************************************/
 
@@ -70,6 +70,11 @@
 		 * Large Resource Type -- All bits are valid
 		 */
 		return (resource_start_byte);
+
+
+	default:
+		/* No other types of resource descriptor */
+		break;
 	}
 
 	return (0xFF);
@@ -99,7 +104,7 @@
 	u8                      *output_buffer)
 {
 	acpi_status             status;
-	u32                     bytes_parsed = 0;
+	ACPI_SIZE               bytes_parsed = 0;
 	u8                      resource_type = 0;
 	ACPI_SIZE               bytes_consumed = 0;
 	u8                      *buffer = output_buffer;
@@ -111,7 +116,7 @@
 
 
 	while (bytes_parsed < byte_stream_buffer_length &&
-			FALSE == end_tag_processed) {
+			!end_tag_processed) {
 		/*
 		 * The next byte in the stream is the resource type
 		 */
@@ -265,9 +270,9 @@
 
 		default:
 			/*
-			 * Invalid/Unknowns resource type
+			 * Invalid/Unknown resource type
 			 */
-			status = AE_AML_ERROR;
+			status = AE_AML_INVALID_RESOURCE_TYPE;
 			break;
 		}
 
@@ -288,7 +293,7 @@
 		/*
 		 * Set the Buffer to the next structure
 		 */
-		resource = (acpi_resource *)buffer;
+		resource = ACPI_CAST_PTR (acpi_resource, buffer);
 		resource->length = ACPI_ALIGN_RESOURCE_SIZE(resource->length);
 		buffer += ACPI_ALIGN_RESOURCE_SIZE(structure_size);
 
@@ -297,8 +302,8 @@
 	/*
 	 * Check the reason for exiting the while loop
 	 */
-	if (TRUE != end_tag_processed) {
-		return_ACPI_STATUS (AE_AML_ERROR);
+	if (!end_tag_processed) {
+		return_ACPI_STATUS (AE_AML_NO_RESOURCE_END_TAG);
 	}
 
 	return_ACPI_STATUS (AE_OK);
@@ -312,7 +317,7 @@
  * PARAMETERS:  Linked_list             - Pointer to the resource linked list
  *              Byte_steam_size_needed  - Calculated size of the byte stream
  *                                        needed from calling
- *                                        Acpi_rs_calculate_byte_stream_length()
+ *                                        Acpi_rs_get_byte_stream_length()
  *                                        The size of the Output_buffer is
  *                                        guaranteed to be >=
  *                                        Byte_stream_size_needed
@@ -329,7 +334,7 @@
 acpi_status
 acpi_rs_list_to_byte_stream (
 	acpi_resource           *linked_list,
-	u32                     byte_stream_size_needed,
+	ACPI_SIZE               byte_stream_size_needed,
 	u8                      *output_buffer)
 {
 	acpi_status             status;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsmemory.c linux/drivers/acpi/resources/rsmemory.c
--- ../prev/linux/drivers/acpi/resources/rsmemory.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsmemory.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsmem24 - Memory resource descriptors
- *              $Revision: 17 $
+ *              $Revision: 20 $
  *
  ******************************************************************************/
 
@@ -60,7 +60,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_mem24);
@@ -76,7 +76,7 @@
 
 	ACPI_MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
 	buffer += 2;
-	*bytes_consumed = temp16 + 3;
+	*bytes_consumed = (ACPI_SIZE) temp16 + 3;
 	output_struct->id = ACPI_RSTYPE_MEM24;
 
 	/*
@@ -116,7 +116,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -237,7 +237,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_mem32);
@@ -253,7 +253,7 @@
 
 	ACPI_MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
 	buffer += 2;
-	*bytes_consumed = temp16 + 3;
+	*bytes_consumed = (ACPI_SIZE) temp16 + 3;
 
 	output_struct->id = ACPI_RSTYPE_MEM32;
 
@@ -303,7 +303,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -342,7 +342,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_fixed_mem32);
@@ -358,7 +358,7 @@
 	ACPI_MOVE_UNALIGNED16_TO_16 (&temp16, buffer);
 
 	buffer += 2;
-	*bytes_consumed = temp16 + 3;
+	*bytes_consumed = (ACPI_SIZE) temp16 + 3;
 
 	output_struct->id = ACPI_RSTYPE_FIXED_MEM32;
 
@@ -385,7 +385,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsmisc.c linux/drivers/acpi/resources/rsmisc.c
--- ../prev/linux/drivers/acpi/resources/rsmisc.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsmisc.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsmisc - Miscellaneous resource descriptors
- *              $Revision: 20 $
+ *              $Revision: 24 $
  *
  ******************************************************************************/
 
@@ -59,7 +59,7 @@
 	u8                      **output_buffer,
 	ACPI_SIZE               *structure_size)
 {
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	ACPI_SIZE               struct_size = ACPI_RESOURCE_LENGTH;
 
 
@@ -170,7 +170,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u16                     temp16 = 0;
 	u8                      temp8 = 0;
 	u8                      index;
@@ -197,7 +197,7 @@
 
 		/* Calculate bytes consumed */
 
-		*bytes_consumed = temp16 + 3;
+		*bytes_consumed = (ACPI_SIZE) temp16 + 3;
 
 		/* Point to the first vendor byte */
 
@@ -211,7 +211,7 @@
 
 		/* Calculate bytes consumed */
 
-		*bytes_consumed = temp16 + 1;
+		*bytes_consumed = (ACPI_SIZE) temp16 + 1;
 
 		/* Point to the first vendor byte */
 
@@ -236,7 +236,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -297,7 +297,7 @@
 		 * Small Item, Set the descriptor field
 		 */
 		temp8 = 0x70;
-		temp8 |= linked_list->data.vendor_specific.length;
+		temp8 |= (u8) linked_list->data.vendor_specific.length;
 
 		*buffer = temp8;
 		buffer += 1;
@@ -350,7 +350,7 @@
 	ACPI_SIZE               *structure_size)
 {
 	u8                      *buffer = byte_stream_buffer;
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	u8                      temp8 = 0;
 	ACPI_SIZE               struct_size = ACPI_SIZEOF_RESOURCE (acpi_resource_start_dpf);
 
@@ -380,7 +380,7 @@
 		output_struct->data.start_dpf.compatibility_priority = temp8 & 0x03;
 
 		if (3 == output_struct->data.start_dpf.compatibility_priority) {
-			return_ACPI_STATUS (AE_AML_ERROR);
+			return_ACPI_STATUS (AE_AML_BAD_RESOURCE_VALUE);
 		}
 
 		/*
@@ -389,7 +389,7 @@
 		output_struct->data.start_dpf.performance_robustness = (temp8 >> 2) & 0x03;
 
 		if (3 == output_struct->data.start_dpf.performance_robustness) {
-			return_ACPI_STATUS (AE_AML_ERROR);
+			return_ACPI_STATUS (AE_AML_BAD_RESOURCE_VALUE);
 		}
 	}
 	else {
@@ -403,7 +403,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
@@ -441,7 +441,7 @@
 	u8                      **output_buffer,
 	ACPI_SIZE               *structure_size)
 {
-	acpi_resource           *output_struct = (acpi_resource *) *output_buffer;
+	acpi_resource           *output_struct = (void *) *output_buffer;
 	ACPI_SIZE               struct_size = ACPI_RESOURCE_LENGTH;
 
 
@@ -461,7 +461,7 @@
 	/*
 	 * Set the Length parameter
 	 */
-	output_struct->length = struct_size;
+	output_struct->length = (u32) struct_size;
 
 	/*
 	 * Return the final size of the structure
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsutils.c linux/drivers/acpi/resources/rsutils.c
--- ../prev/linux/drivers/acpi/resources/rsutils.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsutils.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsutils - Utilities for the resource manager
- *              $Revision: 29 $
+ *              $Revision: 30 $
  *
  ******************************************************************************/
 
@@ -317,7 +317,7 @@
 	/*
 	 * Set up the parameter object
 	 */
-	params[0]->buffer.length  = buffer.length;
+	params[0]->buffer.length  = (u32) buffer.length;
 	params[0]->buffer.pointer = buffer.pointer;
 	params[1] = NULL;
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/resources/rsxface.c linux/drivers/acpi/resources/rsxface.c
--- ../prev/linux/drivers/acpi/resources/rsxface.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/resources/rsxface.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: rsxface - Public interfaces to the resource manager
- *              $Revision: 18 $
+ *              $Revision: 19 $
  *
  ******************************************************************************/
 
@@ -25,8 +25,6 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
-#include "acnamesp.h"
 #include "acresrc.h"
 
 #define _COMPONENT          ACPI_RESOURCES
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/system.c linux/drivers/acpi/system.c
--- ../prev/linux/drivers/acpi/system.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/system.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,1282 @@
+/*
+ *  acpi_system.c - ACPI System Driver ($Revision: 50 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/sysrq.h>
+#include <linux/pm.h>
+#include <asm/uaccess.h>
+#include <asm/acpi.h>
+#ifdef __i386__
+#include <asm/save_state.h>
+#endif
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+#ifdef CONFIG_X86
+#ifdef CONFIG_ACPI_SLEEP
+#include <linux/mc146818rtc.h>
+#endif
+#endif
+
+
+#define _COMPONENT		ACPI_SYSTEM_COMPONENT
+ACPI_MODULE_NAME		("acpi_system")
+
+#define PREFIX			"ACPI: "
+
+extern FADT_DESCRIPTOR		acpi_fadt;
+
+static int acpi_system_add (struct acpi_device *device);
+static int acpi_system_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_system_driver = {
+	name:			ACPI_SYSTEM_DRIVER_NAME,
+	class:			ACPI_SYSTEM_CLASS,
+	ids:			ACPI_SYSTEM_HID,
+	ops:			{
+					add:	acpi_system_add,
+					remove:	acpi_system_remove
+				},
+};
+
+struct acpi_system
+{
+	acpi_handle		handle;
+	u8			states[ACPI_S_STATE_COUNT];
+};
+
+/* Global vars for handling event proc entry */
+static spinlock_t		acpi_system_event_lock = SPIN_LOCK_UNLOCKED;
+int				event_is_open = 0;
+extern struct list_head		acpi_bus_event_list;
+extern wait_queue_head_t	acpi_bus_event_queue;
+
+/* --------------------------------------------------------------------------
+                                  System Sleep
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_PM
+
+static void
+acpi_power_off (void)
+{
+	acpi_enter_sleep_state_prep(ACPI_STATE_S5);
+	ACPI_DISABLE_IRQS();
+	acpi_enter_sleep_state(ACPI_STATE_S5);
+}
+
+#endif /*CONFIG_PM*/
+
+
+#ifdef CONFIG_ACPI_SLEEP
+
+/**
+ * acpi_system_restore_state - OS-specific restoration of state
+ * @state:	sleep state we're exiting
+ *
+ * Note that if we're coming back from S4, the memory image should have already
+ * been loaded from the disk and is already in place. (Otherwise how else would we
+ * be here?).
+ */
+acpi_status
+acpi_system_restore_state (
+	u32			state)
+{
+	/* restore processor state
+	 * We should only be here if we're coming back from STR or STD.
+	 * And, in the case of the latter, the memory image should have already
+	 * been loaded from disk.
+	 */
+	if (state > ACPI_STATE_S1)
+		acpi_restore_state_mem();
+
+	/* wait for power to come back */
+	mdelay(10);
+#ifdef HAVE_NEW_DEVICE_MODEL
+	/* turn all the devices back on */
+	device_resume(RESUME_POWER_ON);
+
+	/* enable interrupts once again */
+	ACPI_ENABLE_IRQS();
+
+	/* restore device context */
+	device_resume(RESUME_RESTORE_STATE);
+#endif
+	return AE_OK;
+}
+
+/**
+ * acpi_system_save_state - save OS specific state and power down devices
+ * @state:	sleep state we're entering.
+ *
+ * This handles saving all context to memory, and possibly disk.
+ * First, we call to the device driver layer to save device state.
+ * Once we have that, we save whatevery processor and kernel state we
+ * need to memory.
+ * If we're entering S4, we then write the memory image to disk.
+ *
+ * Only then is it safe for us to power down devices, since we may need
+ * the disks and upstream buses to write to.
+ */
+acpi_status
+acpi_system_save_state(
+	u32			state)
+{
+	int			error = 0;
+
+#ifdef HAVE_NEW_DEVICE_MODEL
+	/* Send notification to devices that they will be suspended.
+	 * If any device or driver cannot make the transition, either up
+	 * or down, we'll get an error back.
+	 */
+	error = device_suspend(state, SUSPEND_NOTIFY);
+	if (error)
+		return AE_ERROR;
+#endif
+	if (state < ACPI_STATE_S5) {
+
+#ifdef HAVE_NEW_DEVICE_MODEL
+		/* Tell devices to stop I/O and actually save their state.
+		 * It is theoretically possible that something could fail,
+		 * so handle that gracefully..
+		 */
+		error = device_suspend(state, SUSPEND_SAVE_STATE);
+		if (error) {
+			/* tell devices to restore state if they have
+			 * it saved and to start taking I/O requests.
+			 */
+			device_resume(RESUME_RESTORE_STATE);
+			return error;
+		}
+#endif
+
+		/* flush caches */
+		ACPI_FLUSH_CPU_CACHE();
+
+		/* Do arch specific saving of state. */
+		if (state > ACPI_STATE_S1) {
+			error = acpi_save_state_mem();
+
+			if (!error && (state == ACPI_STATE_S4))
+				error = acpi_save_state_disk();
+
+#ifdef HAVE_NEW_DEVICE_MODEL
+			if (error) {
+				device_resume(RESUME_RESTORE_STATE);
+				return error;
+			}
+#endif
+		}
+	}
+#ifdef HAVE_NEW_DEVICE_MODEL
+	/* disable interrupts
+	 * Note that acpi_suspend -- our caller -- will do this once we return.
+	 * But, we want it done early, so we don't get any suprises during
+	 * the device suspend sequence.
+	 */
+	ACPI_DISABLE_IRQS();
+
+	/* Unconditionally turn off devices.
+	 * Obvious if we enter a sleep state.
+	 * If entering S5 (soft off), this should put devices in a
+	 * quiescent state.
+	 */
+	error = device_suspend(state, SUSPEND_POWER_DOWN);
+
+	/* We're pretty screwed if we got an error from this.
+	 * We try to recover by simply calling our own restore_state
+	 * function; see above for definition.
+	 *
+	 * If it's S5 though, go through with it anyway..
+	 */
+	if (error && state != ACPI_STATE_S5)
+		acpi_system_restore_state(state);
+#endif
+	return error ? AE_ERROR : AE_OK;
+}
+
+
+/****************************************************************************
+ *
+ * FUNCTION:    acpi_system_suspend
+ *
+ * PARAMETERS:  %state: Sleep state to enter.
+ *
+ * RETURN:      acpi_status, whether or not we successfully entered and
+ *              exited sleep.
+ *
+ * DESCRIPTION: Perform OS-specific action to enter sleep state.
+ *              This is the final step in going to sleep, per spec.  If we
+ *              know we're coming back (i.e. not entering S5), we save the
+ *              processor flags. [ We'll have to save and restore them anyway,
+ *              so we use the arch-agnostic save_flags and restore_flags
+ *              here.]  We then set the place to return to in arch-specific
+ *              globals using arch_set_return_point. Finally, we call the
+ *              ACPI function to write the proper values to I/O ports.
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_system_suspend(
+	u32			state)
+{
+	acpi_status		status = AE_ERROR;
+	unsigned long		flags = 0;
+
+	save_flags(flags);
+	kernel_fpu_begin();
+	
+	switch (state)
+	{
+	case ACPI_STATE_S1:
+		/* do nothing */
+		break;
+
+	case ACPI_STATE_S2:
+	case ACPI_STATE_S3:
+		save_register_state((unsigned long)&&acpi_sleep_done);
+		break;
+	}
+
+	barrier();
+	status = acpi_enter_sleep_state(state);
+
+acpi_sleep_done:
+
+	restore_register_state();
+	fix_processor_context();
+
+	kernel_fpu_end();
+	restore_flags(flags);
+
+	return status;
+}
+
+
+/**
+ * acpi_suspend - OS-agnostic system suspend/resume support (S? states)
+ * @state:	state we're entering
+ *
+ */
+acpi_status
+acpi_suspend (
+	u32			state)
+{
+	acpi_status status;
+
+	/* get out if state is invalid */
+	if (state < ACPI_STATE_S1 || state > ACPI_STATE_S5)
+		return AE_ERROR;
+
+	/* do we have a wakeup address for S2 and S3? */
+	if (state == ACPI_STATE_S2 || state == ACPI_STATE_S3) {
+		if (!acpi_wakeup_address)
+			return AE_ERROR;
+		acpi_set_firmware_waking_vector((ACPI_PHYSICAL_ADDRESS) acpi_wakeup_address);
+	}
+
+	acpi_enter_sleep_state_prep(state);
+
+	status = acpi_system_save_state(state);
+	if (!ACPI_SUCCESS(status))
+		return status;
+
+	/* disable interrupts and flush caches */
+	ACPI_DISABLE_IRQS();
+	ACPI_FLUSH_CPU_CACHE();
+
+	/* perform OS-specific sleep actions */
+	status = acpi_system_suspend(state);
+
+	/* Even if we failed to go to sleep, all of the devices are in an suspended
+	 * mode. So, we run these unconditionaly to make sure we have a usable system
+	 * no matter what.
+	 */
+	acpi_system_restore_state(state);
+	acpi_leave_sleep_state(state);
+
+	/* make sure interrupts are enabled */
+	ACPI_ENABLE_IRQS();
+
+	/* reset firmware waking vector */
+	acpi_set_firmware_waking_vector((ACPI_PHYSICAL_ADDRESS) 0);
+
+	return status;
+}
+
+#endif /* CONFIG_ACPI_SLEEP */
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+
+static int
+acpi_system_read_info (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_system	*system = (struct acpi_system *) data;
+	char			*p = page;
+	int			size = 0;
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_info");
+
+	if (!system || (off != 0))
+		goto end;
+
+	p += sprintf(p, "version:                 %x\n", ACPI_CA_VERSION);
+
+	p += sprintf(p, "states:                  ");
+	for (i=0; i<ACPI_S_STATE_COUNT; i++) {
+		if (system->states[i])
+			p += sprintf(p, "S%d ", i);
+	}
+	p += sprintf(p, "\n");
+
+end:
+	size = (p - page);
+	if (size <= off+count) *eof = 1;
+	*start = page + off;
+	size -= off;
+	if (size>count) size = count;
+	if (size<0) size = 0;
+
+	return_VALUE(size);
+}
+
+static int acpi_system_open_event(struct inode *inode, struct file *file);
+static ssize_t acpi_system_read_event (struct file*, char*, size_t, loff_t*);
+static int acpi_system_close_event(struct inode *inode, struct file *file);
+static unsigned int acpi_system_poll_event(struct file *file, poll_table *wait);
+
+
+static struct file_operations acpi_system_event_ops = {
+	open:		acpi_system_open_event,
+	read:		acpi_system_read_event,
+	release:	acpi_system_close_event,
+	poll:		acpi_system_poll_event,
+};
+
+static int
+acpi_system_open_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&acpi_system_event_lock);
+
+	if(event_is_open)
+		goto out_busy;
+
+	event_is_open = 1;
+
+	spin_unlock_irq (&acpi_system_event_lock);
+	return 0;
+
+out_busy:
+	spin_unlock_irq (&acpi_system_event_lock);
+	return -EBUSY;
+}
+
+static ssize_t
+acpi_system_read_event (
+	struct file		*file,
+	char			*buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	int			result = 0;
+	char			outbuf[ACPI_MAX_STRING];
+	int			size = 0;
+	struct acpi_bus_event	event;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_event");
+
+	memset(&event, 0, sizeof(struct acpi_bus_event));
+
+	if (count < ACPI_MAX_STRING)
+		goto end;
+
+	if ((file->f_flags & O_NONBLOCK)
+	    && (list_empty(&acpi_bus_event_list)))
+		return_VALUE(-EAGAIN);
+
+	result = acpi_bus_receive_event(&event);
+	if (0 != result) {
+		size = sprintf(outbuf, "error\n");
+		goto end;
+	}
+
+	size = sprintf(outbuf, "%s %s %08x %08x\n", 
+		event.device_class?event.device_class:"<unknown>",
+		event.bus_id?event.bus_id:"<unknown>", 
+		event.type, 
+		event.data);
+
+end:
+	if (copy_to_user(buffer, outbuf, size))
+		return_VALUE(-EFAULT);
+
+	*ppos += size;
+
+	return_VALUE(size);
+}
+
+static int
+acpi_system_close_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&acpi_system_event_lock);
+	event_is_open = 0;
+	spin_unlock_irq (&acpi_system_event_lock);
+	return 0;
+}
+
+static unsigned int
+acpi_system_poll_event(
+	struct file		*file,
+	poll_table		*wait)
+{
+	poll_wait(file, &acpi_bus_event_queue, wait);
+	if (!list_empty(&acpi_bus_event_list))
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static ssize_t acpi_system_read_dsdt (struct file*, char*, size_t, loff_t*);
+
+static struct file_operations acpi_system_dsdt_ops = {
+	read:			acpi_system_read_dsdt,
+};
+
+static ssize_t
+acpi_system_read_dsdt (
+	struct file		*file,
+	char			*buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	acpi_status		status = AE_OK;
+	acpi_buffer		dsdt = {ACPI_ALLOCATE_BUFFER, NULL};
+	void			*data = 0;
+	size_t			size = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_dsdt");
+
+	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (*ppos < dsdt.length) {
+		data = dsdt.pointer + file->f_pos;
+		size = dsdt.length - file->f_pos;
+		if (size > count)
+			size = count;
+		if (copy_to_user(buffer, data, size)) {
+			kfree(dsdt.pointer);
+			return_VALUE(-EFAULT);
+		}
+	}
+
+	kfree(dsdt.pointer);
+
+	*ppos += size;
+
+	return_VALUE(size);
+}
+
+
+static ssize_t acpi_system_read_fadt (struct file*, char*, size_t, loff_t*);
+
+static struct file_operations acpi_system_fadt_ops = {
+	read:			acpi_system_read_fadt,
+};
+
+static ssize_t
+acpi_system_read_fadt (
+	struct file		*file,
+	char			*buffer,
+	size_t			count,
+	loff_t			*ppos)
+{
+	acpi_status		status = AE_OK;
+	acpi_buffer		fadt = {ACPI_ALLOCATE_BUFFER, NULL};
+	void			*data = 0;
+	size_t			size = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_fadt");
+
+	status = acpi_get_table(ACPI_TABLE_FADT, 1, &fadt);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	if (*ppos < fadt.length) {
+		data = fadt.pointer + file->f_pos;
+		size = fadt.length - file->f_pos;
+		if (size > count)
+			size = count;
+		if (copy_to_user(buffer, data, size)) {
+			kfree(fadt.pointer);
+			return_VALUE(-EFAULT);
+		}
+	}
+
+	kfree(fadt.pointer);
+
+	*ppos += size;
+
+	return_VALUE(size);
+}
+
+
+#ifdef ACPI_DEBUG
+
+static int
+acpi_system_read_debug (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	char			*p = page;
+	int 			size = 0;
+
+	if (off != 0)
+		goto end;
+
+	switch ((unsigned long) data) {
+	case 0:
+		p += sprintf(p, "0x%08x\n", acpi_dbg_layer);
+		break;
+	case 1:
+		p += sprintf(p, "0x%08x\n", acpi_dbg_level);
+		break;
+	default:
+		p += sprintf(p, "Invalid debug option\n");
+		break;
+	}
+	
+end:
+	size = (p - page);
+	if (size <= off+count) *eof = 1;
+	*start = page + off;
+	size -= off;
+	if (size>count) size = count;
+	if (size<0) size = 0;
+
+	return size;
+}
+
+
+static int
+acpi_system_write_debug (
+	struct file             *file,
+        const char              *buffer,
+	unsigned long           count,
+        void                    *data)
+{
+	char			debug_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_system_write_debug");
+
+	if (count > sizeof(debug_string) - 1)
+		return_VALUE(-EINVAL);
+
+	if (copy_from_user(debug_string, buffer, count))
+		return_VALUE(-EFAULT);
+
+	debug_string[count] = '\0';
+
+	switch ((unsigned long) data) {
+	case 0:
+		acpi_dbg_layer = simple_strtoul(debug_string, NULL, 0);
+		break;
+	case 1:
+		acpi_dbg_level = simple_strtoul(debug_string, NULL, 0);
+		break;
+	default:
+		return_VALUE(-EINVAL);
+	}
+
+	return_VALUE(count);
+}
+
+#endif /* ACPI_DEBUG */
+
+
+#ifdef CONFIG_ACPI_SLEEP
+
+static int
+acpi_system_read_sleep (
+        char                    *page,
+        char                    **start,
+        off_t                   off,
+        int                     count,
+        int                     *eof,
+        void                    *data)
+{
+	struct acpi_system	*system = (struct acpi_system *) data;
+	char			*p = page;
+	int			size;
+	int			i;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_sleep");
+
+	if (!system || (off != 0))
+		goto end;
+
+	for (i = 0; i <= ACPI_STATE_S5; i++) {
+		if (system->states[i])
+			p += sprintf(p,"S%d ", i);
+	}
+
+	p += sprintf(p, "\n");
+
+end:
+	size = (p - page);
+	if (size <= off+count) *eof = 1;
+	*start = page + off;
+	size -= off;
+	if (size>count) size = count;
+	if (size<0) size = 0;
+
+	return_VALUE(size);
+}
+
+
+static int
+acpi_system_write_sleep (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_system	*system = (struct acpi_system *) data;
+	char			state_string[12] = {'\0'};
+	u32			state = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_write_sleep");
+
+	if (!system || (count > sizeof(state_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (copy_from_user(state_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	state_string[count] = '\0';
+	
+	state = simple_strtoul(state_string, NULL, 0);
+	
+	if (!system->states[state])
+		return_VALUE(-ENODEV);
+	
+	status = acpi_suspend(state);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+	
+	return_VALUE(count);
+}
+
+
+static int
+acpi_system_read_alarm (
+	char                    *page,
+	char                    **start,
+	off_t                   off,
+	int                     count,
+	int                     *eof,
+	void                    *context)
+{
+	char			*p = page;
+	int			size = 0;
+	u32			sec, min, hr;
+	u32			day, mo, yr;
+
+	ACPI_FUNCTION_TRACE("acpi_system_read_alarm");
+
+	if (off != 0)
+		goto end;
+
+	spin_lock(&rtc_lock);
+
+	sec = CMOS_READ(RTC_SECONDS_ALARM);
+	min = CMOS_READ(RTC_MINUTES_ALARM);
+	hr = CMOS_READ(RTC_HOURS_ALARM);
+
+#if 0	/* If we ever get an FACP with proper values... */
+	if (acpi_gbl_FADT->day_alrm)
+		day = CMOS_READ(acpi_gbl_FADT->day_alrm);
+	else
+		day =  CMOS_READ(RTC_DAY_OF_MONTH);
+	if (acpi_gbl_FADT->mon_alrm)
+		mo = CMOS_READ(acpi_gbl_FADT->mon_alrm);
+	else
+		mo = CMOS_READ(RTC_MONTH);;
+	if (acpi_gbl_FADT->century)
+		yr = CMOS_READ(acpi_gbl_FADT->century) * 100 + CMOS_READ(RTC_YEAR);
+	else
+		yr = CMOS_READ(RTC_YEAR);
+#else
+	day = CMOS_READ(RTC_DAY_OF_MONTH);
+	mo = CMOS_READ(RTC_MONTH);
+	yr = CMOS_READ(RTC_YEAR);
+#endif
+
+	spin_unlock(&rtc_lock);
+
+	BCD_TO_BIN(sec);
+	BCD_TO_BIN(min);
+	BCD_TO_BIN(hr);
+	BCD_TO_BIN(day);
+	BCD_TO_BIN(mo);
+	BCD_TO_BIN(yr);
+
+#if 0
+	/* we're trusting the FADT (see above)*/
+#else
+	/* If we're not trusting the FADT, we should at least make it
+	 * right for _this_ century... ehm, what is _this_ century?
+	 *
+	 * TBD:
+	 *  ASAP: find piece of code in the kernel, e.g. star tracker driver,
+	 *        which we can trust to determine the century correctly. Atom
+	 *        watch driver would be nice, too...
+	 *
+	 *  if that has not happened, change for first release in 2050:
+ 	 *        if (yr<50)
+	 *                yr += 2100;
+	 *        else
+	 *                yr += 2000;   // current line of code
+	 *
+	 *  if that has not happened either, please do on 2099/12/31:23:59:59
+	 *        s/2000/2100
+	 *
+	 */
+	yr += 2000;
+#endif
+
+	p += sprintf(p,"%4.4u-", yr);
+	p += (mo > 12)  ? sprintf(p, "**-")  : sprintf(p, "%2.2u-", mo);
+	p += (day > 31) ? sprintf(p, "** ")  : sprintf(p, "%2.2u ", day);
+	p += (hr > 23)  ? sprintf(p, "**:")  : sprintf(p, "%2.2u:", hr);
+	p += (min > 59) ? sprintf(p, "**:")  : sprintf(p, "%2.2u:", min);
+	p += (sec > 59) ? sprintf(p, "**\n") : sprintf(p, "%2.2u\n", sec);
+
+ end:
+	size = p - page;
+	if (size < count) *eof = 1;
+	else if (size > count) size = count;
+	if (size < 0) size = 0;
+	*start = page;
+
+	return_VALUE(size);
+}
+
+
+static int
+get_date_field (
+	char			**p,
+	u32			*value)
+{
+	char			*next = NULL;
+	char			*string_end = NULL;
+	int			result = -EINVAL;
+
+	/*
+	 * Try to find delimeter, only to insert null.  The end of the
+	 * string won't have one, but is still valid.
+	 */
+	next = strpbrk(*p, "- :");
+	if (next)
+		*next++ = '\0';
+
+	*value = simple_strtoul(*p, &string_end, 10);
+
+	/* Signal success if we got a good digit */
+	if (string_end != *p)
+		result = 0;
+
+	if (next)
+		*p = next;
+
+	return result;
+}
+
+
+static int
+acpi_system_write_alarm (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	char			alarm_string[30] = {'\0'};
+	char			*p = alarm_string;
+	u32			sec, min, hr, day, mo, yr;
+	int			adjust = 0;
+	unsigned char		rtc_control = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_write_alarm");
+
+	if (count > sizeof(alarm_string) - 1)
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(alarm_string, buffer, count))
+		return_VALUE(-EFAULT);
+
+	alarm_string[count] = '\0';
+
+	/* check for time adjustment */
+	if (alarm_string[0] == '+') {
+		p++;
+		adjust = 1;
+	}
+
+	if ((result = get_date_field(&p, &yr)))
+		goto end;
+	if ((result = get_date_field(&p, &mo)))
+		goto end;
+	if ((result = get_date_field(&p, &day)))
+		goto end;
+	if ((result = get_date_field(&p, &hr)))
+		goto end;
+	if ((result = get_date_field(&p, &min)))
+		goto end;
+	if ((result = get_date_field(&p, &sec)))
+		goto end;
+
+	if (sec > 59) {
+		min += 1;
+		sec -= 60;
+	}
+	if (min > 59) {
+		hr += 1;
+		min -= 60;
+	}
+	if (hr > 23) {
+		day += 1;
+		hr -= 24;
+	}
+	if (day > 31) {
+		mo += 1;
+		day -= 31;
+	}
+	if (mo > 12) {
+		yr += 1;
+		mo -= 12;
+	}
+
+	spin_lock_irq(&rtc_lock);
+
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		BIN_TO_BCD(yr);
+		BIN_TO_BCD(mo);
+		BIN_TO_BCD(day);
+		BIN_TO_BCD(hr);
+		BIN_TO_BCD(min);
+		BIN_TO_BCD(sec);
+	}
+
+	if (adjust) {
+		yr  += CMOS_READ(RTC_YEAR);
+		mo  += CMOS_READ(RTC_MONTH);
+		day += CMOS_READ(RTC_DAY_OF_MONTH);
+		hr  += CMOS_READ(RTC_HOURS);
+		min += CMOS_READ(RTC_MINUTES);
+		sec += CMOS_READ(RTC_SECONDS);
+	}
+
+	spin_unlock_irq(&rtc_lock);
+
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		BCD_TO_BIN(yr);
+		BCD_TO_BIN(mo);
+		BCD_TO_BIN(day);
+		BCD_TO_BIN(hr);
+		BCD_TO_BIN(min);
+		BCD_TO_BIN(sec);
+	}
+
+	if (sec > 59) {
+		min++;
+		sec -= 60;
+	}
+	if (min > 59) {
+		hr++;
+		min -= 60;
+	}
+	if (hr > 23) {
+		day++;
+		hr -= 24;
+	}
+	if (day > 31) {
+		mo++;
+		day -= 31;
+	}
+	if (mo > 12) {
+		yr++;
+		mo -= 12;
+	}
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		BIN_TO_BCD(yr);
+		BIN_TO_BCD(mo);
+		BIN_TO_BCD(day);
+		BIN_TO_BCD(hr);
+		BIN_TO_BCD(min);
+		BIN_TO_BCD(sec);
+	}
+
+	spin_lock_irq(&rtc_lock);
+
+	/* write the fields the rtc knows about */
+	CMOS_WRITE(hr, RTC_HOURS_ALARM);
+	CMOS_WRITE(min, RTC_MINUTES_ALARM);
+	CMOS_WRITE(sec, RTC_SECONDS_ALARM);
+
+	/*
+	 * If the system supports an enhanced alarm it will have non-zero
+	 * offsets into the CMOS RAM here -- which for some reason are pointing
+	 * to the RTC area of memory.
+	 */
+#if 0
+	if (acpi_gbl_FADT->day_alrm)
+		CMOS_WRITE(day, acpi_gbl_FADT->day_alrm);
+	if (acpi_gbl_FADT->mon_alrm)
+		CMOS_WRITE(mo, acpi_gbl_FADT->mon_alrm);
+	if (acpi_gbl_FADT->century)
+		CMOS_WRITE(yr/100, acpi_gbl_FADT->century);
+#endif
+	/* enable the rtc alarm interrupt */
+	if (!(rtc_control & RTC_AIE)) {
+		rtc_control |= RTC_AIE;
+		CMOS_WRITE(rtc_control,RTC_CONTROL);
+		CMOS_READ(RTC_INTR_FLAGS);
+	}
+
+	spin_unlock_irq(&rtc_lock);
+
+	acpi_set_register(ACPI_BITREG_RT_CLOCK_ENABLE, 1, ACPI_MTX_LOCK);
+
+	file->f_pos += count;
+
+	result = 0;
+end:
+	return_VALUE(result ? result : count);
+}
+
+#endif /*CONFIG_ACPI_SLEEP*/
+
+
+static int
+acpi_system_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_system_add_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	/* 'info' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_INFO,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_INFO));
+	else {
+		entry->read_proc = acpi_system_read_info;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'dsdt' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_DSDT,
+		S_IRUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_DSDT));
+	else
+		entry->proc_fops = &acpi_system_dsdt_ops;
+
+	/* 'fadt' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_FADT,
+		S_IRUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_FADT));
+	else
+		entry->proc_fops = &acpi_system_fadt_ops;
+
+	/* 'event' [R] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_EVENT,
+		S_IRUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_EVENT));
+	else
+		entry->proc_fops = &acpi_system_event_ops;
+
+#ifdef CONFIG_ACPI_SLEEP
+
+	/* 'sleep' [R/W]*/
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_SLEEP,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_SLEEP));
+	else {
+		entry->read_proc = acpi_system_read_sleep;
+		entry->write_proc = acpi_system_write_sleep;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'alarm' [R/W] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_ALARM,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_ALARM));
+	else {
+		entry->read_proc = acpi_system_read_alarm;
+		entry->write_proc = acpi_system_write_alarm;
+		entry->data = acpi_driver_data(device);
+	}
+
+#endif /*CONFIG_ACPI_SLEEP*/
+
+#ifdef ACPI_DEBUG
+
+	/* 'debug_layer' [R/W] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LAYER,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_DEBUG_LAYER));
+	else {
+		entry->read_proc  = acpi_system_read_debug;
+		entry->write_proc = acpi_system_write_debug;
+		entry->data = (void *) 0;
+	}
+
+	/* 'debug_level' [R/W] */
+	entry = create_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LEVEL,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_SYSTEM_FILE_DEBUG_LEVEL));
+	else {
+		entry->read_proc  = acpi_system_read_debug;
+		entry->write_proc = acpi_system_write_debug;
+		entry->data = (void *) 1;
+	}
+
+#endif /*ACPI_DEBUG*/
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_system_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_system_remove_fs");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	remove_proc_entry(ACPI_SYSTEM_FILE_INFO, acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_DSDT, acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_EVENT, acpi_device_dir(device));
+#ifdef CONFIG_ACPI_SLEEP
+	remove_proc_entry(ACPI_SYSTEM_FILE_SLEEP, acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_ALARM, acpi_device_dir(device));
+#endif
+#ifdef ACPI_DEBUG
+	remove_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LAYER,
+		acpi_device_dir(device));
+	remove_proc_entry(ACPI_SYSTEM_FILE_DEBUG_LEVEL,
+		acpi_device_dir(device));
+#endif
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+#if defined(CONFIG_MAGIC_SYSRQ) && defined(CONFIG_PM)
+
+/* Simple wrapper calling power down function. */
+static void acpi_sysrq_power_off(int key, struct pt_regs *pt_regs,
+	struct kbd_struct *kbd, struct tty_struct *tty)
+{
+	acpi_power_off();
+}
+
+struct sysrq_key_op sysrq_acpi_poweroff_op = {
+	handler:	&acpi_sysrq_power_off,
+	help_msg:	"Off",
+	action_msg:	"Power Off\n"
+};
+
+#endif  /* CONFIG_MAGIC_SYSRQ */
+
+static int
+acpi_system_add (
+	struct acpi_device	*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_system	*system = NULL;
+	u8			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	system = kmalloc(sizeof(struct acpi_system), GFP_KERNEL);
+	if (!system)
+		return_VALUE(-ENOMEM);
+	memset(system, 0, sizeof(struct acpi_system));
+
+	system->handle = device->handle;
+	sprintf(acpi_device_name(device), "%s", ACPI_SYSTEM_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_SYSTEM_CLASS);
+	acpi_driver_data(device) = system;
+
+	result = acpi_system_add_fs(device);
+	if (0 != result)
+		goto end;
+
+	printk(KERN_INFO PREFIX "%s [%s] (supports", 
+		acpi_device_name(device), acpi_device_bid(device));
+	for (i=0; i<ACPI_S_STATE_COUNT; i++) {
+		u8 type_a, type_b;
+		status = acpi_get_sleep_type_data(i, &type_a, &type_b);
+		if (ACPI_SUCCESS(status)) {
+			system->states[i] = 1;
+			printk(" S%d", i);
+		}
+	}
+	printk(")\n");
+
+#ifdef CONFIG_PM
+	/* Install the soft-off (S5) handler. */
+	if (system->states[ACPI_STATE_S5]) {
+		pm_power_off = acpi_power_off;
+		register_sysrq_key('o', &sysrq_acpi_poweroff_op);
+	}
+#endif
+
+end:
+	if (0 != result)
+		kfree(system);
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_system_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	struct acpi_system	*system = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_system_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	system = (struct acpi_system *) acpi_driver_data(device);
+
+#ifdef CONFIG_PM
+	/* Remove the soft-off (S5) handler. */
+	if (system->states[ACPI_STATE_S5]) {
+		unregister_sysrq_key('o', &sysrq_acpi_poweroff_op);
+		pm_power_off = NULL;
+	}
+#endif
+
+	acpi_system_remove_fs(device);
+
+	kfree(system);
+
+	return 0;
+}
+
+
+int __init
+acpi_system_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_system_init");
+
+	result = acpi_bus_register_driver(&acpi_system_driver);
+	if (0 > result)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+void __exit
+acpi_system_exit (void)
+{
+	ACPI_FUNCTION_TRACE("acpi_system_exit");
+	acpi_bus_unregister_driver(&acpi_system_driver);
+	return_VOID;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/tables/tbconvrt.c linux/drivers/acpi/tables/tbconvrt.c
--- ../prev/linux/drivers/acpi/tables/tbconvrt.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/tables/tbconvrt.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: tbconvrt - ACPI Table conversion utilities
- *              $Revision: 36 $
+ *              $Revision: 41 $
  *
  *****************************************************************************/
 
@@ -55,7 +55,7 @@
 	ACPI_FUNCTION_ENTRY ();
 
 
-#ifndef _IA64
+#if ACPI_MACHINE_WIDTH != 64
 
 	if (RSDP->revision < 2) {
 		pointer_size = sizeof (u32);
@@ -93,7 +93,7 @@
 	acpi_table_desc         *table_info,
 	u32                     *number_of_tables)
 {
-	u32                     table_size;
+	ACPI_SIZE               table_size;
 	u32                     i;
 	xsdt_descriptor         *new_table;
 
@@ -107,7 +107,7 @@
 
 	/* Compute size of the converted XSDT */
 
-	table_size = (*number_of_tables * sizeof (u64)) + sizeof (acpi_table_header);
+	table_size = ((ACPI_SIZE) *number_of_tables * sizeof (u64)) + sizeof (acpi_table_header);
 
 	/* Allocate an XSDT */
 
@@ -119,7 +119,7 @@
 	/* Copy the header and set the length */
 
 	ACPI_MEMCPY (new_table, table_info->pointer, sizeof (acpi_table_header));
-	new_table->header.length = table_size;
+	new_table->header.length = (u32) table_size;
 
 	/* Copy the table pointers */
 
@@ -151,6 +151,165 @@
 
 /*******************************************************************************
  *
+ * FUNCTION:    Acpi_tb_convert_fadt1
+ *
+ * PARAMETERS:  Local_fadt      - Pointer to new FADT
+ *              Original_fadt   - Pointer to old FADT
+ *
+ * RETURN:      Populates Local_fadt
+ *
+ * DESCRIPTION: Convert an ACPI 1.0 FADT to common internal format
+ *
+ ******************************************************************************/
+
+static void
+acpi_tb_convert_fadt1 (
+	fadt_descriptor_rev2   *local_fadt,
+	fadt_descriptor_rev1   *original_fadt)
+{
+
+
+	/* ACPI 1.0 FACS */
+	/* The BIOS stored FADT should agree with Revision 1.0 */
+
+	/*
+	 * Copy the table header and the common part of the tables.
+	 *
+	 * The 2.0 table is an extension of the 1.0 table, so the entire 1.0
+	 * table can be copied first, then expand some fields to 64 bits.
+	 */
+	ACPI_MEMCPY (local_fadt, original_fadt, sizeof (fadt_descriptor_rev1));
+
+	/* Convert table pointers to 64-bit fields */
+
+	ACPI_STORE_ADDRESS (local_fadt->Xfirmware_ctrl, local_fadt->V1_firmware_ctrl);
+	ACPI_STORE_ADDRESS (local_fadt->Xdsdt, local_fadt->V1_dsdt);
+
+	/*
+	 * System Interrupt Model isn't used in ACPI 2.0 (Local_fadt->Reserved1 = 0;)
+	 */
+
+	/*
+	 * This field is set by the OEM to convey the preferred power management
+	 * profile to OSPM. It doesn't have any 1.0 equivalence.  Since we don't
+	 * know what kind of 32-bit system this is, we will use "unspecified".
+	 */
+	local_fadt->prefer_PM_profile = PM_UNSPECIFIED;
+
+	/*
+	 * Processor Performance State Control. This is the value OSPM writes to
+	 * the SMI_CMD register to assume processor performance state control
+	 * responsibility. There isn't any equivalence in 1.0, leave it zeroed.
+	 */
+	local_fadt->pstate_cnt = 0;
+
+	/*
+	 * Support for the _CST object and C States change notification.
+	 * This data item hasn't any 1.0 equivalence so leave it zero.
+	 */
+	local_fadt->cst_cnt = 0;
+
+	/*
+	 * Since there isn't any equivalence in 1.0 and since it highly likely
+	 * that a 1.0 system has legacy support.
+	 */
+	local_fadt->iapc_boot_arch = BAF_LEGACY_DEVICES;
+
+	/*
+	 * Convert the V1.0 block addresses to V2.0 GAS structures
+	 */
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1a_evt_blk, local_fadt->pm1_evt_len, local_fadt->V1_pm1a_evt_blk);
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1b_evt_blk, local_fadt->pm1_evt_len, local_fadt->V1_pm1b_evt_blk);
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1a_cnt_blk, local_fadt->pm1_cnt_len, local_fadt->V1_pm1a_cnt_blk);
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1b_cnt_blk, local_fadt->pm1_cnt_len, local_fadt->V1_pm1b_cnt_blk);
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm2_cnt_blk, local_fadt->pm2_cnt_len, local_fadt->V1_pm2_cnt_blk);
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm_tmr_blk, local_fadt->pm_tm_len, local_fadt->V1_pm_tmr_blk);
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xgpe0_blk,  local_fadt->gpe0_blk_len, local_fadt->V1_gpe0_blk);
+	ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xgpe1_blk,  local_fadt->gpe1_blk_len, local_fadt->V1_gpe1_blk);
+
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_tb_convert_fadt2
+ *
+ * PARAMETERS:  Local_fadt      - Pointer to new FADT
+ *              Original_fadt   - Pointer to old FADT
+ *
+ * RETURN:      Populates Local_fadt
+ *
+ * DESCRIPTION: Convert an ACPI 2.0 FADT to common internal format.
+ *              Handles optional "X" fields.
+ *
+ ******************************************************************************/
+
+static void
+acpi_tb_convert_fadt2 (
+	fadt_descriptor_rev2   *local_fadt,
+	fadt_descriptor_rev2   *original_fadt)
+{
+
+	/* We have an ACPI 2.0 FADT but we must copy it to our local buffer */
+
+	ACPI_MEMCPY (local_fadt, original_fadt, sizeof (fadt_descriptor_rev2));
+
+	/*
+	 * "X" fields are optional extensions to the original V1.0 fields, so
+	 * we must selectively expand V1.0 fields if the corresponding X field
+	 * is zero.
+	 */
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xfirmware_ctrl))) {
+		ACPI_STORE_ADDRESS (local_fadt->Xfirmware_ctrl, local_fadt->V1_firmware_ctrl);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xdsdt))) {
+		ACPI_STORE_ADDRESS (local_fadt->Xdsdt, local_fadt->V1_dsdt);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xpm1a_evt_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1a_evt_blk,
+			local_fadt->pm1_evt_len, local_fadt->V1_pm1a_evt_blk);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xpm1b_evt_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1b_evt_blk,
+			local_fadt->pm1_evt_len, local_fadt->V1_pm1b_evt_blk);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xpm1a_cnt_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1a_cnt_blk,
+			local_fadt->pm1_cnt_len, local_fadt->V1_pm1a_cnt_blk);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xpm1b_cnt_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm1b_cnt_blk,
+			local_fadt->pm1_cnt_len, local_fadt->V1_pm1b_cnt_blk);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xpm2_cnt_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm2_cnt_blk,
+			local_fadt->pm2_cnt_len, local_fadt->V1_pm2_cnt_blk);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xpm_tmr_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xpm_tmr_blk,
+			local_fadt->pm_tm_len, local_fadt->V1_pm_tmr_blk);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xgpe0_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xgpe0_blk,
+			local_fadt->gpe0_blk_len, local_fadt->V1_gpe0_blk);
+	}
+
+	if (!(ACPI_GET_ADDRESS (local_fadt->Xgpe1_blk.address))) {
+		ASL_BUILD_GAS_FROM_V1_ENTRY (local_fadt->Xgpe1_blk,
+			local_fadt->gpe1_blk_len, local_fadt->V1_gpe1_blk);
+	}
+}
+
+/*******************************************************************************
+ *
  * FUNCTION:    Acpi_tb_convert_table_fadt
  *
  * PARAMETERS:  None
@@ -170,8 +329,7 @@
 acpi_status
 acpi_tb_convert_table_fadt (void)
 {
-	fadt_descriptor_rev1   *FADT1;
-	fadt_descriptor_rev2   *FADT2;
+	fadt_descriptor_rev2   *local_fadt;
 	acpi_table_desc        *table_desc;
 
 
@@ -182,97 +340,45 @@
 	 * Acpi_gbl_FADT is valid
 	 * Allocate and zero the 2.0 FADT buffer
 	 */
-	FADT2 = ACPI_MEM_CALLOCATE (sizeof (fadt_descriptor_rev2));
-	if (FADT2 == NULL) {
+	local_fadt = ACPI_MEM_CALLOCATE (sizeof (fadt_descriptor_rev2));
+	if (local_fadt == NULL) {
 		return_ACPI_STATUS (AE_NO_MEMORY);
 	}
 
 	/*
-	 * The ACPI FADT revision number is FADT2_REVISION_ID=3
-	 * So, if the current table revision is less than 3 it is type 1.0
+	 * FADT length and version validation.  The table must be at least as
+	 * long as the version 1.0 FADT
 	 */
+	if (acpi_gbl_FADT->header.length < sizeof (fadt_descriptor_rev1)) {
+		ACPI_REPORT_ERROR (("Invalid FADT table length: 0x%X\n", acpi_gbl_FADT->header.length));
+		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
+	}
+
 	if (acpi_gbl_FADT->header.revision >= FADT2_REVISION_ID) {
-		/* We have an ACPI 2.0 FADT but we must copy it to our local buffer */
+		if (acpi_gbl_FADT->header.length < sizeof (fadt_descriptor_rev2)) {
+			/* Length is too short to be a V2.0 table */
 
-		*FADT2 = *((fadt_descriptor_rev2*) acpi_gbl_FADT);
-	}
-	else {
-		/* ACPI 1.0 FACS */
+			ACPI_REPORT_WARNING (("Inconsistent FADT length (0x%X) and revision (0x%X), using FADT V1.0 portion of table\n",
+					 acpi_gbl_FADT->header.length, acpi_gbl_FADT->header.revision));
 
-		/* The BIOS stored FADT should agree with Revision 1.0 */
+			acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
+		}
+		else {
+			/* Valid V2.0 table */
 
-		FADT1 = (fadt_descriptor_rev1*) acpi_gbl_FADT;
+			acpi_tb_convert_fadt2 (local_fadt, acpi_gbl_FADT);
+		}
+	}
+	else {
+		/* Valid V1.0 table */
 
-		/*
-		 * Copy the table header and the common part of the tables.
-		 *
-		 * The 2.0 table is an extension of the 1.0 table, so the entire 1.0
-		 * table can be copied first, then expand some fields to 64 bits.
-		 */
-		ACPI_MEMCPY (FADT2, FADT1, sizeof (fadt_descriptor_rev1));
-
-		/* Convert table pointers to 64-bit fields */
-
-		ACPI_STORE_ADDRESS (FADT2->Xfirmware_ctrl, FADT1->firmware_ctrl);
-		ACPI_STORE_ADDRESS (FADT2->Xdsdt, FADT1->dsdt);
-
-		/*
-		 * System Interrupt Model isn't used in ACPI 2.0 (FADT2->Reserved1 = 0;)
-		 */
-
-		/*
-		 * This field is set by the OEM to convey the preferred power management
-		 * profile to OSPM. It doesn't have any 1.0 equivalence.  Since we don't
-		 * know what kind of 32-bit system this is, we will use "unspecified".
-		 */
-		FADT2->prefer_PM_profile = PM_UNSPECIFIED;
-
-		/*
-		 * Processor Performance State Control. This is the value OSPM writes to
-		 * the SMI_CMD register to assume processor performance state control
-		 * responsibility. There isn't any equivalence in 1.0, leave it zeroed.
-		 */
-		FADT2->pstate_cnt = 0;
-
-		/*
-		 * Support for the _CST object and C States change notification.
-		 * This data item hasn't any 1.0 equivalence so leave it zero.
-		 */
-		FADT2->cst_cnt = 0;
-
-		/*
-		 * Since there isn't any equivalence in 1.0 and since it highly likely
-		 * that a 1.0 system has legacy support.
-		 */
-		FADT2->iapc_boot_arch = BAF_LEGACY_DEVICES;
-
-		/*
-		 * Convert the V1.0 block addresses to V2.0 GAS structures
-		 * in this order:
-		 *
-		 * PM 1_a Events
-		 * PM 1_b Events
-		 * PM 1_a Control
-		 * PM 1_b Control
-		 * PM 2 Control
-		 * PM Timer Control
-		 * GPE Block 0
-		 * GPE Block 1
-		 */
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1a_evt_blk, FADT1->pm1_evt_len, FADT1->pm1a_evt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1b_evt_blk, FADT1->pm1_evt_len, FADT1->pm1b_evt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1a_cnt_blk, FADT1->pm1_cnt_len, FADT1->pm1a_cnt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm1b_cnt_blk, FADT1->pm1_cnt_len, FADT1->pm1b_cnt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm2_cnt_blk, FADT1->pm2_cnt_len, FADT1->pm2_cnt_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xpm_tmr_blk, FADT1->pm_tm_len,  FADT1->pm_tmr_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xgpe0_blk,   FADT1->gpe0_blk_len, FADT1->gpe0_blk);
-		ASL_BUILD_GAS_FROM_V1_ENTRY (FADT2->Xgpe1_blk,   FADT1->gpe1_blk_len, FADT1->gpe1_blk);
+		acpi_tb_convert_fadt1 (local_fadt, (void *) acpi_gbl_FADT);
 	}
 
 	/*
-	 * Global FADT pointer will point to the common V2.0 FADT
+	 * Global FADT pointer will point to the new common V2.0 FADT
 	 */
-	acpi_gbl_FADT = FADT2;
+	acpi_gbl_FADT = local_fadt;
 	acpi_gbl_FADT->header.length = sizeof (FADT_DESCRIPTOR);
 
 	/* Free the original table */
@@ -282,10 +388,10 @@
 
 	/* Install the new table */
 
-	table_desc->pointer = (acpi_table_header *) acpi_gbl_FADT;
+	table_desc->pointer     = (acpi_table_header *) acpi_gbl_FADT;
 	table_desc->base_pointer = acpi_gbl_FADT;
-	table_desc->allocation = ACPI_MEM_ALLOCATED;
-	table_desc->length = sizeof (fadt_descriptor_rev2);
+	table_desc->allocation  = ACPI_MEM_ALLOCATED;
+	table_desc->length      = sizeof (fadt_descriptor_rev2);
 
 	/* Dump the entire FADT */
 
@@ -315,35 +421,42 @@
 acpi_tb_build_common_facs (
 	acpi_table_desc         *table_info)
 {
-	facs_descriptor_rev1    *FACS1;
-	facs_descriptor_rev2    *FACS2;
-
 
 	ACPI_FUNCTION_TRACE ("Tb_build_common_facs");
 
 
+	/* Absolute minimum length is 24, but the ACPI spec says 64 */
+
+	if (acpi_gbl_FACS->length < 24) {
+		ACPI_REPORT_ERROR (("Invalid FACS table length: 0x%X\n", acpi_gbl_FACS->length));
+		return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
+	}
+
+	if (acpi_gbl_FACS->length < 64) {
+		ACPI_REPORT_WARNING (("FACS is shorter than the ACPI specification allows: 0x%X, using anyway\n",
+			acpi_gbl_FACS->length));
+	}
+
 	/* Copy fields to the new FACS */
 
-	if (acpi_gbl_RSDP->revision < 2) {
-		/* ACPI 1.0 FACS */
+	acpi_gbl_common_fACS.global_lock = &(acpi_gbl_FACS->global_lock);
 
-		FACS1 = (facs_descriptor_rev1 *) acpi_gbl_FACS;
+	if ((acpi_gbl_RSDP->revision < 2) ||
+		(acpi_gbl_FACS->length < 32) ||
+		(!(ACPI_GET_ADDRESS (acpi_gbl_FACS->Xfirmware_waking_vector)))) {
+		/* ACPI 1.0 FACS or short table or optional X_ field is zero */
 
-		acpi_gbl_common_fACS.global_lock = &(FACS1->global_lock);
-		acpi_gbl_common_fACS.firmware_waking_vector = (u64 *) &FACS1->firmware_waking_vector;
+		acpi_gbl_common_fACS.firmware_waking_vector = ACPI_CAST_PTR (u64, &(acpi_gbl_FACS->firmware_waking_vector));
 		acpi_gbl_common_fACS.vector_width = 32;
 	}
 	else {
-		/* ACPI 2.0 FACS */
+		/* ACPI 2.0 FACS with valid X_ field */
 
-		FACS2 = (facs_descriptor_rev2 *) acpi_gbl_FACS;
-
-		acpi_gbl_common_fACS.global_lock = &(FACS2->global_lock);
-		acpi_gbl_common_fACS.firmware_waking_vector = &FACS2->Xfirmware_waking_vector;
+		acpi_gbl_common_fACS.firmware_waking_vector = &acpi_gbl_FACS->Xfirmware_waking_vector;
 		acpi_gbl_common_fACS.vector_width = 64;
 	}
 
-	return_ACPI_STATUS  (AE_OK);
+	return_ACPI_STATUS (AE_OK);
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/tables/tbget.c linux/drivers/acpi/tables/tbget.c
--- ../prev/linux/drivers/acpi/tables/tbget.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/tables/tbget.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: tbget - ACPI Table get* routines
- *              $Revision: 67 $
+ *              $Revision: 77 $
  *
  *****************************************************************************/
 
@@ -34,6 +34,123 @@
 
 /*******************************************************************************
  *
+ * FUNCTION:    Acpi_tb_table_override
+ *
+ * PARAMETERS:  *Table_info         - Info for current table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Attempts override of current table with a new one if provided
+ *              by the host OS.
+ *
+ ******************************************************************************/
+
+void
+acpi_tb_table_override (
+	acpi_table_desc         *table_info)
+{
+	acpi_table_header       *new_table;
+	acpi_status             status;
+	ACPI_POINTER            address;
+	acpi_table_desc         new_table_info;
+
+
+	ACPI_FUNCTION_TRACE ("Acpi_tb_table_override");
+
+
+	status = acpi_os_table_override (table_info->pointer, &new_table);
+	if (ACPI_FAILURE (status)) {
+		/* Some severe error from the OSL, but we basically ignore it */
+
+		ACPI_REPORT_ERROR (("Could not override ACPI table, %s\n",
+			acpi_format_exception (status)));
+		return_VOID;
+	}
+
+	if (!new_table) {
+		/* No table override */
+
+		return_VOID;
+	}
+
+	/*
+	 * We have a new table to override the old one.  Get a copy of
+	 * the new one.  We know that the new table has a logical pointer.
+	 */
+	address.pointer_type    = ACPI_LOGICAL_POINTER;
+	address.pointer.logical = new_table;
+
+	status = acpi_tb_get_table (&address, &new_table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not copy ACPI table override\n"));
+		return_VOID;
+	}
+
+	/*
+	 * Delete the original table
+	 */
+	acpi_tb_delete_single_table (table_info);
+
+	/* Copy the table info */
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Successful table override [%4.4s]\n",
+		((acpi_table_header *) new_table_info.pointer)->signature));
+
+	ACPI_MEMCPY (table_info, &new_table_info, sizeof (acpi_table_desc));
+	return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_tb_get_table_with_override
+ *
+ * PARAMETERS:  Address             - Physical or logical address of table
+ *              *Table_info         - Where the table info is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Gets and installs the table with possible table override by OS.
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_tb_get_table_with_override (
+	ACPI_POINTER            *address,
+	acpi_table_desc         *table_info)
+{
+	acpi_status             status;
+
+
+	ACPI_FUNCTION_TRACE ("Acpi_tb_get_table_with_override");
+
+
+	status = acpi_tb_get_table (address, table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not get ACPI table, %s\n",
+			acpi_format_exception (status)));
+		return_ACPI_STATUS (status);
+	}
+
+	/*
+	 * Attempt override.  It either happens or it doesn't, no status
+	 */
+	acpi_tb_table_override (table_info);
+
+	/* Install the table */
+
+	status = acpi_tb_install_table (table_info);
+	if (ACPI_FAILURE (status)) {
+		ACPI_REPORT_ERROR (("Could not install ACPI table, %s\n",
+			acpi_format_exception (status)));
+	}
+
+	return_ACPI_STATUS (status);
+}
+
+
+/*******************************************************************************
+ *
  * FUNCTION:    Acpi_tb_get_table_ptr
  *
  * PARAMETERS:  Table_type      - one of the defined table types
@@ -112,10 +229,8 @@
  *
  * FUNCTION:    Acpi_tb_get_table
  *
- * PARAMETERS:  Physical_address        - Physical address of table to retrieve
- *              *Buffer_ptr             - If Buffer_ptr is valid, read data from
- *                                         buffer rather than searching memory
- *              *Table_info             - Where the table info is returned
+ * PARAMETERS:  Address             - Physical address of table to retrieve
+ *              *Table_info         - Where the table info is returned
  *
  * RETURN:      Status
  *
@@ -130,7 +245,7 @@
 {
 	acpi_table_header       *table_header = NULL;
 	acpi_table_header       *full_table = NULL;
-	u32                     size;
+	ACPI_SIZE               size;
 	u8                      allocation;
 	acpi_status             status = AE_OK;
 
@@ -159,7 +274,7 @@
 
 		/* Copy the entire table (including header) to the local buffer */
 
-		size = table_header->length;
+		size = (ACPI_SIZE) table_header->length;
 		ACPI_MEMCPY (full_table, table_header, size);
 
 		/* Save allocation type */
@@ -213,7 +328,6 @@
  * FUNCTION:    Acpi_tb_get_all_tables
  *
  * PARAMETERS:  Number_of_tables    - Number of tables to get
- *              Table_ptr           - Input buffer pointer, optional
  *
  * RETURN:      Status
  *
@@ -230,8 +344,7 @@
 
 acpi_status
 acpi_tb_get_all_tables (
-	u32                     number_of_tables,
-	acpi_table_header       *table_ptr)
+	u32                     number_of_tables)
 {
 	acpi_status             status = AE_OK;
 	u32                     index;
@@ -268,18 +381,23 @@
 
 		/* Recognize and install the table */
 
-		status = acpi_tb_install_table (table_ptr, &table_info);
+		status = acpi_tb_install_table (&table_info);
 		if (ACPI_FAILURE (status)) {
 			/*
 			 * Unrecognized or unsupported table, delete it and ignore the
 			 * error.  Just get as many tables as we can, later we will
 			 * determine if there are enough tables to continue.
 			 */
-			acpi_tb_uninstall_table (&table_info);
+			(void) acpi_tb_uninstall_table (&table_info);
 			status = AE_OK;
 		}
 	}
 
+	if (!acpi_gbl_FADT) {
+		ACPI_REPORT_ERROR (("No FADT present in R/XSDT\n"));
+		return_ACPI_STATUS (AE_NO_ACPI_TABLES);
+	}
+
 	/*
 	 * Convert the FADT to a common format.  This allows earlier revisions of the
 	 * table to coexist with newer versions, using common access code.
@@ -299,15 +417,17 @@
 
 	status = acpi_tb_get_table (&address, &table_info);
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not get the FACS\n"));
+		ACPI_REPORT_ERROR (("Could not get the FACS, %s\n",
+			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
 	/* Install the FACS */
 
-	status = acpi_tb_install_table (table_ptr, &table_info);
+	status = acpi_tb_install_table (&table_info);
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not install the FACS\n"));
+		ACPI_REPORT_ERROR (("Could not install the FACS, %s\n",
+			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
 
@@ -317,35 +437,30 @@
 	 */
 	status = acpi_tb_build_common_facs (&table_info);
 	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not convert FACS to common internal format\n"));
 		return_ACPI_STATUS (status);
 	}
 
 	/*
-	 * Get the DSDT (We know that the FADT is valid now)
+	 * Get/install the DSDT (We know that the FADT is valid now)
 	 */
 	address.pointer_type  = acpi_gbl_table_flags;
 	address.pointer.value = ACPI_GET_ADDRESS (acpi_gbl_FADT->Xdsdt);
 
-	status = acpi_tb_get_table (&address, &table_info);
+	status = acpi_tb_get_table_with_override (&address, &table_info);
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("Could not get the DSDT\n"));
 		return_ACPI_STATUS (status);
 	}
 
-	/* Install the DSDT */
+	/* Set Integer Width (32/64) based upon DSDT revision */
 
-	status = acpi_tb_install_table (table_ptr, &table_info);
-	if (ACPI_FAILURE (status)) {
-		ACPI_REPORT_ERROR (("Could not install the DSDT\n"));
-		return_ACPI_STATUS (status);
-	}
+	acpi_ut_set_integer_width (acpi_gbl_DSDT->revision);
 
 	/* Dump the entire DSDT */
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_TABLES,
-		"Hex dump of entire DSDT, size %d (0x%X)\n",
-		acpi_gbl_DSDT->length, acpi_gbl_DSDT->length));
+		"Hex dump of entire DSDT, size %d (0x%X), Integer width = %d\n",
+		acpi_gbl_DSDT->length, acpi_gbl_DSDT->length, acpi_gbl_integer_bit_width));
 	ACPI_DUMP_BUFFER ((u8 *) acpi_gbl_DSDT, acpi_gbl_DSDT->length);
 
 	/* Always delete the RSDP mapping, we are done with it */
@@ -428,7 +543,7 @@
 
 	/* The RSDP supplied is OK */
 
-	table_info.pointer     = (acpi_table_header *) rsdp;
+	table_info.pointer     = ACPI_CAST_PTR (acpi_table_header, rsdp);
 	table_info.length      = sizeof (RSDP_DESCRIPTOR);
 	table_info.allocation  = ACPI_MEM_MAPPED;
 	table_info.base_pointer = rsdp;
@@ -442,7 +557,7 @@
 
 	/* Save the RSDP in a global for easy access */
 
-	acpi_gbl_RSDP = (RSDP_DESCRIPTOR *) table_info.pointer;
+	acpi_gbl_RSDP = ACPI_CAST_PTR (RSDP_DESCRIPTOR, table_info.pointer);
 	return_ACPI_STATUS (status);
 
 
@@ -508,7 +623,7 @@
 acpi_tb_validate_rsdt (
 	acpi_table_header       *table_ptr)
 {
-	u32                     no_match;
+	int                     no_match;
 
 
 	ACPI_FUNCTION_NAME ("Tb_validate_rsdt");
@@ -535,8 +650,9 @@
 		ACPI_DUMP_BUFFER (acpi_gbl_RSDP, 20);
 
 		ACPI_DEBUG_PRINT_RAW ((ACPI_DB_ERROR,
-			"RSDT/XSDT signature at %X is invalid\n",
-			acpi_gbl_RSDP->rsdt_physical_address));
+			"RSDT/XSDT signature at %X (%p) is invalid\n",
+			acpi_gbl_RSDP->rsdt_physical_address,
+			(void *) (NATIVE_UINT) acpi_gbl_RSDP->rsdt_physical_address));
 
 		return (AE_BAD_SIGNATURE);
 	}
@@ -563,7 +679,7 @@
 acpi_tb_get_table_pointer (
 	ACPI_POINTER            *address,
 	u32                     flags,
-	u32                     *size,
+	ACPI_SIZE               *size,
 	acpi_table_header       **table_ptr)
 {
 	acpi_status             status = AE_OK;
@@ -590,6 +706,9 @@
 			*table_ptr = address->pointer.logical;
 			*size = 0;
 			break;
+
+		default:
+			return (AE_BAD_PARAMETER);
 		}
 	}
 	else {
@@ -605,6 +724,9 @@
 
 			status = AE_BAD_PARAMETER;
 			break;
+
+		default:
+			return (AE_BAD_PARAMETER);
 		}
 	}
 
@@ -636,25 +758,21 @@
 	ACPI_FUNCTION_TRACE ("Tb_get_table_rsdt");
 
 
-	/*
-	 * Get the RSDT from the RSDP
-	 */
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"RSDP located at %p, RSDT physical=%8.8X%8.8X \n",
-		acpi_gbl_RSDP,
-		ACPI_HIDWORD (acpi_gbl_RSDP->rsdt_physical_address),
-		ACPI_LODWORD (acpi_gbl_RSDP->rsdt_physical_address)));
-
-
-	/* Get the RSDT/XSDT */
+	/* Get the RSDT/XSDT from the RSDP */
 
 	acpi_tb_get_rsdt_address (&address);
 	status = acpi_tb_get_table (&address, &table_info);
 	if (ACPI_FAILURE (status)) {
-		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not get the RSDT, %s\n",
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not get the R/XSDT, %s\n",
 			acpi_format_exception (status)));
 		return_ACPI_STATUS (status);
 	}
+
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"RSDP located at %p, RSDT physical=%8.8X%8.8X \n",
+		acpi_gbl_RSDP,
+		ACPI_HIDWORD (address.pointer.value),
+		ACPI_LODWORD (address.pointer.value)));
 
 	/* Check the RSDT or XSDT signature */
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/tables/tbinstal.c linux/drivers/acpi/tables/tbinstal.c
--- ../prev/linux/drivers/acpi/tables/tbinstal.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/tables/tbinstal.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: tbinstal - ACPI table installation and removal
- *              $Revision: 57 $
+ *              $Revision: 61 $
  *
  *****************************************************************************/
 
@@ -84,8 +84,7 @@
  *
  * FUNCTION:    Acpi_tb_install_table
  *
- * PARAMETERS:  Table_ptr           - Input buffer pointer, optional
- *              Table_info          - Return value from Acpi_tb_get_table
+ * PARAMETERS:  Table_info          - Return value from Acpi_tb_get_table
  *
  * RETURN:      Status
  *
@@ -97,7 +96,6 @@
 
 acpi_status
 acpi_tb_install_table (
-	acpi_table_header       *table_ptr,
 	acpi_table_desc         *table_info)
 {
 	acpi_status             status;
@@ -109,7 +107,7 @@
 	 * Check the table signature and make sure it is recognized
 	 * Also checks the header checksum
 	 */
-	status = acpi_tb_recognize_table (table_ptr, table_info);
+	status = acpi_tb_recognize_table (table_info);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
 	}
@@ -137,8 +135,7 @@
  *
  * FUNCTION:    Acpi_tb_recognize_table
  *
- * PARAMETERS:  Table_ptr           - Input buffer pointer, optional
- *              Table_info          - Return value from Acpi_tb_get_table
+ * PARAMETERS:  Table_info          - Return value from Acpi_tb_get_table
  *
  * RETURN:      Status
  *
@@ -156,7 +153,6 @@
 
 acpi_status
 acpi_tb_recognize_table (
-	acpi_table_header       *table_ptr,
 	acpi_table_desc         *table_info)
 {
 	acpi_table_header       *table_header;
@@ -193,7 +189,7 @@
 
 	/* Return the table type and length via the info struct */
 
-	table_info->length  = table_header->length;
+	table_info->length = (ACPI_SIZE) table_header->length;
 
 	/*
 	 * Validate checksum for _most_ tables,
@@ -201,12 +197,14 @@
 	 */
 	if (table_info->type != ACPI_TABLE_FACS) {
 		status = acpi_tb_verify_table_checksum (table_header);
-		if (ACPI_FAILURE (status) &&
-			(!ACPI_CHECKSUM_ABORT)) {
+
+#if (!ACPI_CHECKSUM_ABORT)
+		if (ACPI_FAILURE (status)) {
 			/* Ignore the error if configuration says so */
 
 			status = AE_OK;
 		}
+#endif
 	}
 
 	return_ACPI_STATUS (status);
@@ -497,6 +495,9 @@
 
 			acpi_os_unmap_memory (table_desc->base_pointer, table_desc->length);
 			break;
+
+		default:
+			break;
 		}
 	}
 }
@@ -508,7 +509,7 @@
  *
  * PARAMETERS:  Table_info          - A table info struct
  *
- * RETURN:      None.
+ * RETURN:      Pointer to the next table in the list (of same type)
  *
  * DESCRIPTION: Free the memory associated with an internal ACPI table that
  *              is either installed or has never been installed.
@@ -523,7 +524,7 @@
 	acpi_table_desc         *next_desc;
 
 
-	ACPI_FUNCTION_TRACE_PTR ("Tb_delete_single_table", table_desc);
+	ACPI_FUNCTION_TRACE_PTR ("Acpi_tb_uninstall_table", table_desc);
 
 
 	if (!table_desc) {
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/tables/tbutils.c linux/drivers/acpi/tables/tbutils.c
--- ../prev/linux/drivers/acpi/tables/tbutils.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/tables/tbutils.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: tbutils - Table manipulation utilities
- *              $Revision: 51 $
+ *              $Revision: 53 $
  *
  *****************************************************************************/
 
@@ -26,7 +26,6 @@
 
 #include "acpi.h"
 #include "actables.h"
-#include "acinterp.h"
 
 
 #define _COMPONENT          ACPI_TABLES
@@ -116,7 +115,7 @@
 
 	/* Ensure that the signature is 4 ASCII characters */
 
-	ACPI_MOVE_UNALIGNED32_TO_32 (&signature, &table_header->signature);
+	ACPI_MOVE_UNALIGNED32_TO_32 (&signature, table_header->signature);
 	if (!acpi_ut_valid_acpi_name (signature)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Table signature at %p [%p] has invalid characters\n",
@@ -162,11 +161,11 @@
 acpi_status
 acpi_tb_map_acpi_table (
 	ACPI_PHYSICAL_ADDRESS   physical_address,
-	u32                     *size,
+	ACPI_SIZE               *size,
 	acpi_table_header       **logical_address)
 {
 	acpi_table_header       *table;
-	u32                     table_size = *size;
+	ACPI_SIZE               table_size = *size;
 	acpi_status             status = AE_OK;
 
 
@@ -186,7 +185,7 @@
 
 		/* Extract the full table length before we delete the mapping */
 
-		table_size = table->length;
+		table_size = (ACPI_SIZE) table->length;
 
 		/*
 		 * Validate the header and delete the mapping.
@@ -255,7 +254,7 @@
 
 	if (checksum) {
 		ACPI_REPORT_WARNING (("Invalid checksum (%X) in table %4.4s\n",
-			checksum, (char *) &table_header->signature));
+			checksum, table_header->signature));
 
 		status = AE_BAD_CHECKSUM;
 	}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/tables/tbxface.c linux/drivers/acpi/tables/tbxface.c
--- ../prev/linux/drivers/acpi/tables/tbxface.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/tables/tbxface.c	Fri May 31 11:41:58 2002
@@ -2,7 +2,7 @@
  *
  * Module Name: tbxface - Public interfaces to the ACPI subsystem
  *                         ACPI table oriented interfaces
- *              $Revision: 52 $
+ *              $Revision: 57 $
  *
  *****************************************************************************/
 
@@ -27,7 +27,6 @@
 
 #include "acpi.h"
 #include "acnamesp.h"
-#include "acinterp.h"
 #include "actables.h"
 
 
@@ -91,7 +90,7 @@
 
 	/* Now get the rest of the tables */
 
-	status = acpi_tb_get_all_tables (number_of_tables, NULL);
+	status = acpi_tb_get_all_tables (number_of_tables);
 	if (ACPI_FAILURE (status)) {
 		ACPI_REPORT_ERROR (("Acpi_load_tables: Error getting required tables (DSDT/FADT/FACS): %s\n",
 				  acpi_format_exception (status)));
@@ -165,7 +164,7 @@
 
 	/* Install the new table into the local data structures */
 
-	status = acpi_tb_install_table (NULL, &table_info);
+	status = acpi_tb_install_table (&table_info);
 	if (ACPI_FAILURE (status)) {
 		/* Free table allocated by Acpi_tb_get_table */
 
@@ -196,7 +195,7 @@
 	if (ACPI_FAILURE (status)) {
 		/* Uninstall table and free the buffer */
 
-		acpi_tb_uninstall_table (table_info.installed_desc);
+		(void) acpi_tb_uninstall_table (table_info.installed_desc);
 	}
 
 	return_ACPI_STATUS (status);
@@ -358,7 +357,7 @@
 {
 	acpi_table_header       *tbl_ptr;
 	acpi_status             status;
-	u32                     table_length;
+	ACPI_SIZE               table_length;
 
 
 	ACPI_FUNCTION_TRACE ("Acpi_get_table");
@@ -408,7 +407,7 @@
 		table_length = sizeof (RSDP_DESCRIPTOR);
 	}
 	else {
-		table_length = tbl_ptr->length;
+		table_length = (ACPI_SIZE) tbl_ptr->length;
 	}
 
 	/* Validate/Allocate/Clear caller buffer */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/tables/tbxfroot.c linux/drivers/acpi/tables/tbxfroot.c
--- ../prev/linux/drivers/acpi/tables/tbxfroot.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/tables/tbxfroot.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: tbxfroot - Find the root ACPI table (RSDT)
- *              $Revision: 61 $
+ *              $Revision: 63 $
  *
  *****************************************************************************/
 
@@ -123,8 +123,8 @@
 	acpi_table_header       *rsdt_ptr = NULL;
 	acpi_table_header       *table_ptr;
 	acpi_status             status;
-	u32                     rsdt_size = 0;
-	u32                     table_size;
+	ACPI_SIZE               rsdt_size = 0;
+	ACPI_SIZE               table_size;
 	u32                     table_count;
 	u32                     i;
 	u32                     j;
@@ -187,16 +187,16 @@
 		}
 	}
 
-	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-		"RSDP located at %p, RSDT physical=%8.8X%8.8X \n",
-		acpi_gbl_RSDP,
-		ACPI_HIDWORD (acpi_gbl_RSDP->rsdt_physical_address),
-		ACPI_LODWORD (acpi_gbl_RSDP->rsdt_physical_address)));
-
 	/* Get the RSDT and validate it */
 
 	acpi_tb_get_rsdt_address (&address);
 
+	ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+		"RSDP located at %p, RSDT physical=%8.8X%8.8X \n",
+		acpi_gbl_RSDP,
+		ACPI_HIDWORD (address.pointer.value),
+		ACPI_LODWORD (address.pointer.value)));
+
 	status = acpi_tb_get_table_pointer (&address, flags, &rsdt_size, &rsdt_ptr);
 	if (ACPI_FAILURE (status)) {
 		return_ACPI_STATUS (status);
@@ -272,7 +272,7 @@
 
 /* TBD: Move to a new file */
 
-#ifndef _IA16
+#if ACPI_MACHINE_WIDTH != 16
 
 /*******************************************************************************
  *
@@ -417,7 +417,7 @@
 			/* Found it, return the physical address */
 
 			phys_addr = LO_RSDP_WINDOW_BASE;
-			phys_addr += (mem_rover - table_ptr);
+			phys_addr += ACPI_PTR_DIFF (mem_rover,table_ptr);
 
 			table_info->physical_address = phys_addr;
 			return_ACPI_STATUS (AE_OK);
@@ -439,7 +439,7 @@
 			/* Found it, return the physical address */
 
 			phys_addr = HI_RSDP_WINDOW_BASE;
-			phys_addr += (mem_rover - table_ptr);
+			phys_addr += ACPI_PTR_DIFF (mem_rover, table_ptr);
 
 			table_info->physical_address = phys_addr;
 			return_ACPI_STATUS (AE_OK);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/tables.c linux/drivers/acpi/tables.c
--- ../prev/linux/drivers/acpi/tables.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/tables.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,475 @@
+/*
+ *  acpi_tables.c - ACPI Boot-Time Table Parsing
+ *
+ *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/irq.h>
+#include <linux/errno.h>
+#include <linux/acpi.h>
+
+#define PREFIX			"ACPI: "
+
+#define ACPI_MAX_TABLES		ACPI_TABLE_COUNT
+
+static char *acpi_table_signatures[ACPI_TABLE_COUNT] = {
+	[ACPI_TABLE_UNKNOWN]	= "????",
+	[ACPI_APIC]		= "APIC",
+	[ACPI_BOOT]		= "BOOT",
+	[ACPI_DBGP]		= "DBGP",
+	[ACPI_DSDT]		= "DSDT",
+	[ACPI_ECDT]		= "ECDT",
+	[ACPI_ETDT]		= "ETDT",
+	[ACPI_FACP]		= "FACP",
+	[ACPI_FACS]		= "FACS",
+	[ACPI_OEMX]		= "OEM",
+	[ACPI_PSDT]		= "PSDT",
+	[ACPI_SBST]		= "SBST",
+	[ACPI_SLIT]		= "SLIT",
+	[ACPI_SPCR]		= "SPCR",
+	[ACPI_SRAT]		= "SRAT",
+	[ACPI_SSDT]		= "SSDT",
+	[ACPI_SPMI]		= "SPMI"
+};
+
+/* System Description Table (RSDT/XSDT) */
+struct acpi_table_sdt {
+	unsigned long		pa;		/* Physical Address */
+	unsigned long		count;		/* Table count */
+	struct {
+		unsigned long		pa;
+		enum acpi_table_id	id;
+		unsigned long		size;
+	}			entry[ACPI_MAX_TABLES];
+} __attribute__ ((packed));
+
+static struct acpi_table_sdt	sdt;
+
+acpi_madt_entry_handler		madt_handlers[ACPI_MADT_ENTRY_COUNT];
+
+
+void
+acpi_table_print (
+	struct acpi_table_header *header,
+	unsigned long		phys_addr)
+{
+	char			*name = NULL;
+
+	if (!header)
+		return;
+
+	/* Some table signatures aren't good table names */
+
+	if (0 == strncmp((char *) &header->signature,
+		acpi_table_signatures[ACPI_APIC],
+		sizeof(header->signature))) {
+		name = "MADT";
+	}
+	else if (0 == strncmp((char *) &header->signature,
+		acpi_table_signatures[ACPI_FACP],
+		sizeof(header->signature))) {
+		name = "FADT";
+	}
+	else
+		name = header->signature;
+
+	printk(KERN_INFO PREFIX "%.4s (v%3.3d %6.6s %8.8s %5.5d.%5.5d) @ 0x%p\n",
+		name, header->revision, header->oem_id,
+		header->oem_table_id, header->oem_revision >> 16,
+		header->oem_revision & 0xffff, (void *) phys_addr);
+}
+
+
+void
+acpi_table_print_madt_entry (
+	acpi_table_entry_header	*header)
+{
+	if (!header)
+		return;
+
+	switch (header->type) {
+
+	case ACPI_MADT_LAPIC:
+	{
+		struct acpi_table_lapic *p =
+			(struct acpi_table_lapic*) header;
+		printk(KERN_INFO PREFIX "LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",
+			p->acpi_id, p->id, p->flags.enabled?"enabled":"disabled");
+	}
+		break;
+
+	case ACPI_MADT_IOAPIC:
+	{
+		struct acpi_table_ioapic *p =
+			(struct acpi_table_ioapic*) header;
+		printk(KERN_INFO PREFIX "IOAPIC (id[0x%02x] address[0x%08x] global_irq_base[0x%x])\n",
+			p->id, p->address, p->global_irq_base);
+	}
+		break;
+
+	case ACPI_MADT_INT_SRC_OVR:
+	{
+		struct acpi_table_int_src_ovr *p =
+			(struct acpi_table_int_src_ovr*) header;
+		printk(KERN_INFO PREFIX "INT_SRC_OVR (bus[%d] irq[0x%x] global_irq[0x%x] polarity[0x%x] trigger[0x%x])\n",
+			p->bus, p->bus_irq, p->global_irq, p->flags.polarity, p->flags.trigger);
+	}
+		break;
+
+	case ACPI_MADT_NMI_SRC:
+	{
+		struct acpi_table_nmi_src *p =
+			(struct acpi_table_nmi_src*) header;
+		printk(KERN_INFO PREFIX "NMI_SRC (polarity[0x%x] trigger[0x%x] global_irq[0x%x])\n",
+			p->flags.polarity, p->flags.trigger, p->global_irq);
+	}
+		break;
+
+	case ACPI_MADT_LAPIC_NMI:
+	{
+		struct acpi_table_lapic_nmi *p =
+			(struct acpi_table_lapic_nmi*) header;
+		printk(KERN_INFO PREFIX "LAPIC_NMI (acpi_id[0x%02x] polarity[0x%x] trigger[0x%x] lint[0x%x])\n",
+			p->acpi_id, p->flags.polarity, p->flags.trigger, p->lint);
+	}
+		break;
+
+	case ACPI_MADT_LAPIC_ADDR_OVR:
+	{
+		struct acpi_table_lapic_addr_ovr *p =
+			(struct acpi_table_lapic_addr_ovr*) header;
+		printk(KERN_INFO PREFIX "LAPIC_ADDR_OVR (address[%p])\n",
+			(void *) (unsigned long) p->address);
+	}
+		break;
+
+	case ACPI_MADT_IOSAPIC:
+	{
+		struct acpi_table_iosapic *p =
+			(struct acpi_table_iosapic*) header;
+		printk(KERN_INFO PREFIX "IOSAPIC (id[0x%x] global_irq_base[0x%x] address[%p])\n",
+			p->id, p->global_irq_base, (void *) (unsigned long) p->address);
+	}
+		break;
+
+	case ACPI_MADT_LSAPIC:
+	{
+		struct acpi_table_lsapic *p =
+			(struct acpi_table_lsapic*) header;
+		printk(KERN_INFO PREFIX "LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",
+			p->acpi_id, p->id, p->eid, p->flags.enabled?"enabled":"disabled");
+	}
+		break;
+
+	case ACPI_MADT_PLAT_INT_SRC:
+	{
+		struct acpi_table_plat_int_src *p =
+			(struct acpi_table_plat_int_src*) header;
+		printk(KERN_INFO PREFIX "PLAT_INT_SRC (polarity[0x%x] trigger[0x%x] type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",
+			p->flags.polarity, p->flags.trigger, p->type, p->id, p->eid, p->iosapic_vector, p->global_irq);
+	}
+		break;
+
+	default:
+		printk(KERN_WARNING PREFIX "Found unsupported MADT entry (type = 0x%x)\n",
+			header->type);
+		break;
+	}
+}
+
+
+static int
+acpi_table_compute_checksum (
+	void			*table_pointer,
+	unsigned long		length)
+{
+	u8			*p = (u8 *) table_pointer;
+	unsigned long		remains = length;
+	unsigned long		sum = 0;
+
+	if (!p || !length)
+		return -EINVAL;
+
+	while (remains--)
+		sum += *p++;
+
+	return (sum & 0xFF);
+}
+
+
+int __init
+acpi_table_parse_madt (
+	enum acpi_table_id	id,
+	acpi_madt_entry_handler	handler)
+{
+	struct acpi_table_madt	*madt = NULL;
+	acpi_table_entry_header	*entry = NULL;
+	unsigned long		count = 0;
+	unsigned long		madt_end = 0;
+	int			i = 0;
+
+	if (!handler)
+		return -EINVAL;
+
+	/* Locate the MADT (if exists). There should only be one. */
+
+	for (i = 0; i < sdt.count; i++) {
+		if (sdt.entry[i].id != ACPI_APIC)
+			continue;
+		madt = (struct acpi_table_madt *)
+			__acpi_map_table(sdt.entry[i].pa, sdt.entry[i].size);
+		if (!madt) {
+			printk(KERN_WARNING PREFIX "Unable to map MADT\n");
+			return -ENODEV;
+		}
+		break;
+	}
+
+	if (!madt) {
+		printk(KERN_WARNING PREFIX "MADT not present\n");
+		return -ENODEV;
+	}
+
+	madt_end = (unsigned long) madt + sdt.entry[i].size;
+
+	/* Parse all entries looking for a match. */
+
+	entry = (acpi_table_entry_header *)
+		((unsigned long) madt + sizeof(struct acpi_table_madt));
+
+	while (((unsigned long) entry) < madt_end) {
+		if (entry->type == id) {
+			count++;
+			handler(entry);
+		}
+		entry = (acpi_table_entry_header *)
+			((unsigned long) entry += entry->length);
+	}
+
+	return count;
+}
+
+
+int __init
+acpi_table_parse (
+	enum acpi_table_id	id,
+	acpi_table_handler	handler)
+{
+	int			count = 0;
+	int			i = 0;
+
+	if (!handler)
+		return -EINVAL;
+
+	for (i = 0; i < sdt.count; i++) {
+		if (sdt.entry[i].id != id)
+			continue;
+		handler(sdt.entry[i].pa, sdt.entry[i].size);
+		count++;
+	}
+
+	return count;
+}
+
+
+static int __init
+acpi_table_get_sdt (
+	struct acpi_table_rsdp	*rsdp)
+{
+	struct acpi_table_header *header = NULL;
+	int			i, id = 0;
+
+	if (!rsdp)
+		return -EINVAL;
+
+	/* First check XSDT (but only on ACPI 2.0-compatible systems) */
+
+	if ((rsdp->revision >= 2) &&
+		(((struct acpi20_table_rsdp*)rsdp)->xsdt_address)) {
+			
+		struct acpi_table_xsdt	*mapped_xsdt = NULL;
+
+		sdt.pa = ((struct acpi20_table_rsdp*)rsdp)->xsdt_address;
+
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt.pa, sizeof(struct acpi_table_header));
+
+		if (!header) {
+			printk(KERN_WARNING PREFIX "Unable to map XSDT header\n");
+			return -ENODEV;
+		}
+
+		if (strncmp(header->signature, "XSDT", 4)) {
+			printk(KERN_WARNING PREFIX "XSDT signature incorrect\n");
+			return -ENODEV;
+		}
+
+		sdt.count = (header->length - sizeof(struct acpi_table_header)) >> 3;
+		if (sdt.count > ACPI_MAX_TABLES) {
+			printk(KERN_WARNING PREFIX "Truncated %lu XSDT entries\n",
+				(ACPI_MAX_TABLES - sdt.count));
+			sdt.count = ACPI_MAX_TABLES;
+		}
+
+		mapped_xsdt = (struct acpi_table_xsdt *)
+			__acpi_map_table(sdt.pa, header->length);
+		if (!mapped_xsdt) {
+			printk(KERN_WARNING PREFIX "Unable to map XSDT\n");
+			return -ENODEV;
+		}
+
+		header = &mapped_xsdt->header;
+
+		for (i = 0; i < sdt.count; i++)
+			sdt.entry[i].pa = (unsigned long) mapped_xsdt->entry[i];
+	}
+
+	/* Then check RSDT */
+
+	else if (rsdp->rsdt_address) {
+
+		struct acpi_table_rsdt	*mapped_rsdt = NULL;
+
+		sdt.pa = rsdp->rsdt_address;
+
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt.pa, sizeof(struct acpi_table_header));
+		if (!header) {
+			printk(KERN_WARNING PREFIX "Unable to map RSDT header\n");
+			return -ENODEV;
+		}
+
+		if (strncmp(header->signature, "RSDT", 4)) {
+			printk(KERN_WARNING PREFIX "RSDT signature incorrect\n");
+			return -ENODEV;
+		}
+
+		sdt.count = (header->length - sizeof(struct acpi_table_header)) >> 2;
+		if (sdt.count > ACPI_MAX_TABLES) {
+			printk(KERN_WARNING PREFIX "Truncated %lu RSDT entries\n",
+				(ACPI_TABLE_COUNT - sdt.count));
+			sdt.count = ACPI_MAX_TABLES;
+		}
+
+		mapped_rsdt = (struct acpi_table_rsdt *)
+			__acpi_map_table(sdt.pa, header->length);
+		if (!mapped_rsdt) {
+			printk(KERN_WARNING PREFIX "Unable to map RSDT\n");
+			return -ENODEV;
+		}
+
+		header = &mapped_rsdt->header;
+
+		for (i = 0; i < sdt.count; i++)
+			sdt.entry[i].pa = (unsigned long) mapped_rsdt->entry[i];
+	}
+
+	else {
+		printk(KERN_WARNING PREFIX "No System Description Table (RSDT/XSDT) specified in RSDP\n");
+		return -ENODEV;
+	}
+
+	acpi_table_print(header, sdt.pa);
+
+	for (i = 0; i < sdt.count; i++) {
+
+		header = (struct acpi_table_header *)
+			__acpi_map_table(sdt.entry[i].pa,
+				sizeof(struct acpi_table_header));
+		if (!header)
+			continue;
+
+		acpi_table_print(header, sdt.entry[i].pa);
+
+		if (0 != acpi_table_compute_checksum(header, header->length)) {
+			printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
+			continue;
+		}
+
+		sdt.entry[i].size = header->length;
+
+		for (id = 0; id < ACPI_TABLE_COUNT; id++) {
+			if (0 == strncmp((char *) &header->signature,
+				acpi_table_signatures[id],
+				sizeof(header->signature))) {
+				sdt.entry[i].id = id;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+int __init
+acpi_table_init (
+	char			*cmdline)
+{
+	struct acpi_table_rsdp	*rsdp = NULL;
+	unsigned long		rsdp_phys = 0;
+	int			result = 0;
+
+	memset(&sdt, 0, sizeof(struct acpi_table_sdt));
+	memset(&madt_handlers, 0, sizeof(madt_handlers));
+
+	/* Locate and map the Root System Description Table (RSDP) */
+
+	rsdp_phys = acpi_find_rsdp();
+	if (!rsdp_phys) {
+		printk(KERN_ERR PREFIX "Unable to locate RSDP\n");
+		return -ENODEV;
+	}
+
+	rsdp = (struct acpi_table_rsdp *) __va(rsdp_phys);
+	if (!rsdp) {
+		printk(KERN_WARNING PREFIX "Unable to map RSDP\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO PREFIX "RSDP (v%3.3d %6.6s                     ) @ 0x%p\n",
+		rsdp->revision, rsdp->oem_id, (void *) rsdp_phys);
+
+	if (rsdp->revision < 2)
+		result = acpi_table_compute_checksum(rsdp, sizeof(struct acpi_table_rsdp));
+	else
+		result = acpi_table_compute_checksum(rsdp, ((struct acpi20_table_rsdp *)rsdp)->length);
+
+	if (0 != result) {
+		printk(KERN_WARNING "  >>> ERROR: Invalid checksum\n");
+		return -ENODEV;
+	}
+
+	/* Locate and map the System Description table (RSDT/XSDT) */
+
+	if (0 != acpi_table_get_sdt(rsdp))
+		return -ENODEV;
+
+	return 0;
+}
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/thermal.c linux/drivers/acpi/thermal.c
--- ../prev/linux/drivers/acpi/thermal.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/thermal.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,1318 @@
+/*
+ *  acpi_thermal.c - ACPI Thermal Zone Driver ($Revision: 36 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This driver fully implements the ACPI thermal policy as described in the
+ *  ACPI 2.0 Specification.
+ *
+ *  TBD: 1. Implement passive cooling hysteresis.
+ *       2. Enhance passive cooling (CPU) states/limit interface to support
+ *          concepts of 'multiple limiters', upper/lower limits, etc.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/kmod.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_THERMAL_COMPONENT
+ACPI_MODULE_NAME		("acpi_thermal")
+
+MODULE_AUTHOR("Paul Diefenbaugh");
+MODULE_DESCRIPTION(ACPI_THERMAL_DRIVER_NAME);
+MODULE_LICENSE("GPL");
+
+static int tzp = 0;
+MODULE_PARM(tzp, "i");
+MODULE_PARM_DESC(tzp, "Thermal zone polling frequency, in 1/10 seconds.\n");
+
+#define PREFIX			"ACPI: "
+
+
+#define ACPI_THERMAL_MAX_ACTIVE	10
+
+#define KELVIN_TO_CELSIUS(t)	((t-2732+5)/10)
+
+static int acpi_thermal_add (struct acpi_device *device);
+static int acpi_thermal_remove (struct acpi_device *device, int type);
+
+static struct acpi_driver acpi_thermal_driver = {
+	name:			ACPI_THERMAL_DRIVER_NAME,
+	class:			ACPI_THERMAL_CLASS,
+	ids:			ACPI_THERMAL_HID,
+	ops:			{
+					add:	acpi_thermal_add,
+					remove:	acpi_thermal_remove,
+				},
+};
+
+struct acpi_thermal_state {
+	u8			critical:1;
+	u8			hot:1;
+	u8			passive:1;
+	u8			active:1;
+	u8			reserved:4;
+	int			active_index;
+};
+
+struct acpi_thermal_state_flags {
+	u8			valid:1;
+	u8			enabled:1;
+	u8			reserved:6;
+};
+
+struct acpi_thermal_critical {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+};
+
+struct acpi_thermal_hot {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+};
+
+struct acpi_thermal_passive {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+	unsigned long		tc1;
+	unsigned long		tc2;
+	unsigned long		tsp;
+	struct acpi_handle_list	devices;
+};
+
+struct acpi_thermal_active {
+	struct acpi_thermal_state_flags flags;
+	unsigned long		temperature;
+	struct acpi_handle_list	devices;
+};
+
+struct acpi_thermal_trips {
+	struct acpi_thermal_critical critical;
+	struct acpi_thermal_hot	hot;
+	struct acpi_thermal_passive passive;
+	struct acpi_thermal_active active[ACPI_THERMAL_MAX_ACTIVE];
+};
+
+struct acpi_thermal_flags {
+	u8			cooling_mode:1;		/* _SCP */
+	u8			devices:1;		/* _TZD */
+	u8			reserved:6;
+};
+
+struct acpi_thermal {
+	acpi_handle		handle;
+	acpi_bus_id		name;
+	unsigned long		temperature;
+	unsigned long		last_temperature;
+	unsigned long		polling_frequency;
+	u8			cooling_mode;
+	struct acpi_thermal_flags flags;
+	struct acpi_thermal_state state;
+	struct acpi_thermal_trips trips;
+	struct acpi_handle_list	devices;
+	struct timer_list	timer;
+};
+
+
+/* --------------------------------------------------------------------------
+                             Thermal Zone Management
+   -------------------------------------------------------------------------- */
+
+static int
+acpi_thermal_get_temperature (
+	struct acpi_thermal *tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_temperature");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	tz->last_temperature = tz->temperature;
+
+	status = acpi_evaluate_integer(tz->handle, "_TMP", NULL, &tz->temperature);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n", tz->temperature));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_polling_frequency (
+	struct acpi_thermal	*tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_polling_frequency");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_integer(tz->handle, "_TZP", NULL, &tz->polling_frequency);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n", tz->polling_frequency));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_set_polling (
+	struct acpi_thermal	*tz,
+	int			seconds)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_set_polling");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	tz->polling_frequency = seconds * 10;	/* Convert value to deci-seconds */
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency set to %lu seconds\n", tz->polling_frequency));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_set_cooling_mode (
+	struct acpi_thermal	*tz,
+	int			mode)
+{
+	acpi_status		status = AE_OK;
+	acpi_object		arg0 = {ACPI_TYPE_INTEGER};
+	acpi_object_list	arg_list= {1, &arg0};
+	acpi_handle		handle = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_set_cooling_mode");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_get_handle(tz->handle, "_SCP", &handle);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));
+		return_VALUE(-ENODEV);
+	}
+
+	arg0.integer.value = mode;
+
+	status = acpi_evaluate(handle, NULL, &arg_list, NULL);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	tz->cooling_mode = mode;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling mode [%s]\n", 
+		mode?"passive":"active"));
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_trip_points (
+	struct acpi_thermal *tz)
+{
+	acpi_status		status = AE_OK;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_trip_points");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	/* Critical Shutdown (required) */
+
+	status = acpi_evaluate_integer(tz->handle, "_CRT", NULL, 
+		&tz->trips.critical.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.critical.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "No critical threshold\n"));
+		return -ENODEV;
+	}
+	else {
+		tz->trips.critical.flags.valid = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found critical threshold [%lu]\n", tz->trips.critical.temperature));
+	}
+
+	/* Critical Sleep (optional) */
+
+	status = acpi_evaluate_integer(tz->handle, "_HOT", NULL, &tz->trips.hot.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.hot.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No hot threshold\n"));
+	}
+	else {
+		tz->trips.hot.flags.valid = 1;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found hot threshold [%lu]\n", tz->trips.hot.temperature));
+	}
+
+	/* Passive: Processors (optional) */
+
+	status = acpi_evaluate_integer(tz->handle, "_PSV", NULL, &tz->trips.passive.temperature);
+	if (ACPI_FAILURE(status)) {
+		tz->trips.passive.flags.valid = 0;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No passive threshold\n"));
+	}
+	else {
+		tz->trips.passive.flags.valid = 1;
+
+		status = acpi_evaluate_integer(tz->handle, "_TC1", NULL, &tz->trips.passive.tc1);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_integer(tz->handle, "_TC2", NULL, &tz->trips.passive.tc2);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_integer(tz->handle, "_TSP", NULL, &tz->trips.passive.tsp);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		status = acpi_evaluate_reference(tz->handle, "_PSL", NULL, &tz->trips.passive.devices);
+		if (ACPI_FAILURE(status))
+			tz->trips.passive.flags.valid = 0;
+
+		if (!tz->trips.passive.flags.valid)
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid passive threshold\n"));
+		else
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found passive threshold [%lu]\n", tz->trips.passive.temperature));
+	}
+
+	/* Active: Fans, etc. (optional) */
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+
+		char name[5] = {'_','A','C',('0'+i),'\0'};
+
+		status = acpi_evaluate_integer(tz->handle, name, NULL, &tz->trips.active[i].temperature);
+		if (ACPI_FAILURE(status))
+			break;
+
+		name[2] = 'L';
+		status = acpi_evaluate_reference(tz->handle, name, NULL, &tz->trips.active[i].devices);
+		if (ACPI_SUCCESS(status)) {
+			tz->trips.active[i].flags.valid = 1;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found active threshold [%d]:[%lu]\n", i, tz->trips.active[i].temperature));
+		}
+		else
+			ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid active threshold [%d]\n", i));
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_get_devices (
+	struct acpi_thermal	*tz)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_devices");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	status = acpi_evaluate_reference(tz->handle, "_TZD", NULL, &tz->devices);
+	if (ACPI_FAILURE(status))
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_call_usermode (
+	char			*path)
+{
+	char			*argv[2] = {NULL, NULL};
+	char			*envp[3] = {NULL, NULL, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_call_usermode");
+
+	if (!path)
+		return_VALUE(-EINVAL);;
+
+	argv[0] = path;
+
+	/* minimal command environment */
+	envp[0] = "HOME=/";
+	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	
+	call_usermodehelper(argv[0], argv, envp);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_critical (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_critical");
+
+	if (!tz || !tz->trips.critical.flags.valid)
+		return_VALUE(-EINVAL);
+
+	if (tz->temperature >= tz->trips.critical.temperature) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Critical trip point\n"));
+		tz->trips.critical.flags.enabled = 1;
+	}
+	else if (tz->trips.critical.flags.enabled)
+		tz->trips.critical.flags.enabled = 0;
+
+	result = acpi_bus_get_device(tz->handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_CRITICAL, tz->trips.critical.flags.enabled);
+
+	acpi_thermal_call_usermode(ACPI_THERMAL_PATH_POWEROFF);
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_hot (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_hot");
+
+	if (!tz || !tz->trips.hot.flags.valid)
+		return_VALUE(-EINVAL);
+
+	if (tz->temperature >= tz->trips.hot.temperature) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Hot trip point\n"));
+		tz->trips.hot.flags.enabled = 1;
+	}
+	else if (tz->trips.hot.flags.enabled)
+		tz->trips.hot.flags.enabled = 0;
+
+	result = acpi_bus_get_device(tz->handle, &device);
+	if (0 != result)
+		return_VALUE(result);
+
+	acpi_bus_generate_event(device, ACPI_THERMAL_NOTIFY_HOT, tz->trips.hot.flags.enabled);
+
+	/* TBD: Call user-mode "sleep(S4)" function */
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_passive (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_thermal_passive *passive = NULL;
+	int			trend = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_passive");
+
+	if (!tz || !tz->trips.passive.flags.valid)
+		return_VALUE(-EINVAL);
+
+	passive = &(tz->trips.passive);
+
+	/*
+	 * Above Trip?
+	 * -----------
+	 * Calculate the thermal trend (using the passive cooling equation)
+	 * and modify the performance limit for all passive cooling devices
+	 * accordingly.  Note that we assume symmetry.
+	 */
+	if (tz->temperature >= passive->temperature) {
+		trend = (passive->tc1 * (tz->temperature - tz->last_temperature)) + (passive->tc2 * (tz->temperature - passive->temperature));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+			"trend[%d]=(tc1[%lu]*(tmp[%lu]-last[%lu]))+(tc2[%lu]*(tmp[%lu]-psv[%lu]))\n", 
+			trend, passive->tc1, tz->temperature, 
+			tz->last_temperature, passive->tc2, 
+			tz->temperature, passive->temperature));
+		/* Heating up? */
+		if (trend > 0)
+			for (i=0; i<passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(
+					passive->devices.handles[i], 
+					ACPI_PROCESSOR_LIMIT_INCREMENT);
+		/* Cooling off? */
+		else if (trend < 0)
+			for (i=0; i<passive->devices.count; i++)
+				acpi_processor_set_thermal_limit(
+					passive->devices.handles[i], 
+					ACPI_PROCESSOR_LIMIT_DECREMENT);
+	}
+
+	/*
+	 * Below Trip?
+	 * -----------
+	 * Implement passive cooling hysteresis to slowly increase performance
+	 * and avoid thrashing around the passive trip point.  Note that we
+	 * assume symmetry.
+	 */
+	else if (tz->trips.passive.flags.enabled) {
+		for (i=0; i<passive->devices.count; i++)
+			result = acpi_processor_set_thermal_limit(
+				passive->devices.handles[i], 
+				ACPI_PROCESSOR_LIMIT_DECREMENT);
+		if (1 == result) {
+			tz->trips.passive.flags.enabled = 0;
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+				"Disabling passive cooling (zone is cool)\n"));
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_active (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+	struct acpi_thermal_active *active = NULL;
+	int                     i = 0;
+	int			j = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_active");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+
+		active = &(tz->trips.active[i]);
+		if (!active || !active->flags.valid)
+			break;
+
+		/*
+		 * Above Threshold?
+		 * ----------------
+		 * If not already enabled, turn ON all cooling devices
+		 * associated with this active threshold.
+		 */
+		if (tz->temperature >= active->temperature) {
+			tz->state.active_index = i;
+			if (!active->flags.enabled) {
+				for (j = 0; j < active->devices.count; j++) {
+					result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D0);
+					if (0 != result) {
+						ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'on'\n", active->devices.handles[j]));
+						continue;
+					}
+					active->flags.enabled = 1;
+					ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'on'\n", active->devices.handles[j]));
+				}
+			}
+		}
+		/*
+		 * Below Threshold?
+		 * ----------------
+		 * Turn OFF all cooling devices associated with this
+		 * threshold.
+		 */
+		else if (active->flags.enabled) {
+			for (j = 0; j < active->devices.count; j++) {
+				result = acpi_bus_set_power(active->devices.handles[j], ACPI_STATE_D3);
+				if (0 != result) {
+					ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to turn cooling device [%p] 'off'\n", active->devices.handles[j]));
+					continue;
+				}
+				active->flags.enabled = 0;
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Cooling device [%p] now 'off'\n", active->devices.handles[j]));
+			}
+		}
+	}
+
+	return_VALUE(0);
+}
+
+
+static void acpi_thermal_check (void *context);
+
+static void
+acpi_thermal_run (
+	unsigned long		data)
+{
+	acpi_os_queue_for_execution(OSD_PRIORITY_GPE,  acpi_thermal_check, (void *) data);
+}
+
+
+static void
+acpi_thermal_check (
+	void                    *data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	unsigned long		sleep_time = 0;
+	int			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_check");
+
+	if (!tz) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid (NULL) context.\n"));
+		return_VOID;
+	}
+
+	result = acpi_thermal_get_temperature(tz);
+	if (0 != result)
+		return_VOID;
+	
+	memset(&tz->state, 0, sizeof(tz->state));
+	
+	/*
+	 * Check Trip Points
+	 * -----------------
+	 * Compare the current temperature to the trip point values to see
+	 * if we've entered one of the thermal policy states.  Note that
+	 * this function determines when a state is entered, but the 
+	 * individual policy decides when it is exited (e.g. hysteresis).
+	 */
+	if ((tz->trips.critical.flags.valid) && (tz->temperature >= tz->trips.critical.temperature))
+		tz->trips.critical.flags.enabled = 1;
+	if ((tz->trips.hot.flags.valid) && (tz->temperature >= tz->trips.hot.temperature))
+		tz->trips.hot.flags.enabled = 1;
+	if ((tz->trips.passive.flags.valid) && (tz->temperature >= tz->trips.passive.temperature))
+		tz->trips.passive.flags.enabled = 1;
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+		if ((tz->trips.active[i].flags.valid) && (tz->temperature >= tz->trips.active[i].temperature))
+			tz->trips.active[i].flags.enabled = 1;
+
+	/*
+	 * Invoke Policy
+	 * -------------
+	 * Separated from the above check to allow individual policy to 
+	 * determine when to exit a given state.
+	 */
+	if (tz->trips.critical.flags.enabled)
+		acpi_thermal_critical(tz);
+	if (tz->trips.hot.flags.enabled)
+		acpi_thermal_hot(tz);
+	if (tz->trips.passive.flags.enabled)
+		acpi_thermal_passive(tz);
+	if (tz->trips.active[0].flags.enabled)
+		acpi_thermal_active(tz);
+
+	/*
+	 * Calculate State
+	 * ---------------
+	 * Again, separated from the above two to allow independent policy
+	 * decisions.
+	 */
+	if (tz->trips.critical.flags.enabled)
+		tz->state.critical = 1;
+	if (tz->trips.hot.flags.enabled)
+		tz->state.hot = 1;
+	if (tz->trips.passive.flags.enabled)
+		tz->state.passive = 1;
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
+		if (tz->trips.active[i].flags.enabled)
+			tz->state.active = 1;
+
+	/*
+	 * Calculate Sleep Time
+	 * --------------------
+	 * If we're in the passive state, use _TSP's value.  Otherwise
+	 * use the default polling frequency (e.g. _TZP).  If no polling
+	 * frequency is specified then we'll wait forever (at least until
+	 * a thermal event occurs).  Note that _TSP and _TZD values are
+	 * given in 1/10th seconds (we must covert to milliseconds).
+	 */
+	if (tz->state.passive)
+		sleep_time = tz->trips.passive.tsp * 100;
+	else if (tz->polling_frequency > 0)
+		sleep_time = tz->polling_frequency * 100;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "%s: temperature[%lu] sleep[%lu]\n", 
+		tz->name, tz->temperature, sleep_time));
+
+	/*
+	 * Schedule Next Poll
+	 * ------------------
+	 */
+	if (!sleep_time) {
+		if (timer_pending(&(tz->timer)))
+			del_timer(&(tz->timer));
+	}
+	else {
+		if (timer_pending(&(tz->timer)))
+			mod_timer(&(tz->timer), (HZ * sleep_time) / 1000);
+		else {
+			tz->timer.data = (unsigned long) tz;
+			tz->timer.function = acpi_thermal_run;
+			tz->timer.expires = jiffies + (HZ * sleep_time) / 1000;
+			add_timer(&(tz->timer));
+		}
+	}
+
+	return_VOID;
+}
+
+
+/* --------------------------------------------------------------------------
+                              FS Interface (/proc)
+   -------------------------------------------------------------------------- */
+
+#include <linux/compatmac.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry		*acpi_thermal_dir = NULL;
+
+
+static int
+acpi_thermal_read_state (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_state");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	p += sprintf(p, "state:                   ");
+
+	if (!tz->state.critical && !tz->state.hot && !tz->state.passive && !tz->state.active)
+		p += sprintf(p, "ok\n");
+	else {
+		if (tz->state.critical)
+			p += sprintf(p, "critical ");
+		if (tz->state.hot)
+			p += sprintf(p, "hot ");
+		if (tz->state.passive)
+			p += sprintf(p, "passive ");
+		if (tz->state.active)
+			p += sprintf(p, "active[%d]", tz->state.active_index);
+		p += sprintf(p, "\n");
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_read_temperature (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_temperature");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	result = acpi_thermal_get_temperature(tz);
+	if (0 != result)
+		goto end;
+
+	p += sprintf(p, "temperature:             %lu C\n", 
+		KELVIN_TO_CELSIUS(tz->temperature));
+	
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_read_trip_points (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+	int			i = 0;
+	int			j = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_trip_points");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	if (tz->trips.critical.flags.valid)
+		p += sprintf(p, "critical (S5):           %lu C\n",
+			KELVIN_TO_CELSIUS(tz->trips.critical.temperature));
+
+	if (tz->trips.hot.flags.valid)
+		p += sprintf(p, "hot (S4):                %lu C\n",
+			KELVIN_TO_CELSIUS(tz->trips.hot.temperature));
+
+	if (tz->trips.passive.flags.valid) {
+		p += sprintf(p, "passive:                 %lu C: tc1=%lu tc2=%lu tsp=%lu devices=",
+			KELVIN_TO_CELSIUS(tz->trips.passive.temperature),
+			tz->trips.passive.tc1,
+			tz->trips.passive.tc2, 
+			tz->trips.passive.tsp);
+		for (j=0; j<tz->trips.passive.devices.count; j++) {
+
+			p += sprintf(p, "0x%p ", tz->trips.passive.devices.handles[j]);
+		}
+		p += sprintf(p, "\n");
+	}
+
+	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++) {
+		if (!(tz->trips.active[i].flags.valid))
+			break;
+		p += sprintf(p, "active[%d]:               %lu C: devices=",
+			i, KELVIN_TO_CELSIUS(tz->trips.active[i].temperature));
+		for (j=0; j<tz->trips.active[i].devices.count; j++) 
+			p += sprintf(p, "0x%p ",
+				tz->trips.active[i].devices.handles[j]);
+		p += sprintf(p, "\n");
+	}
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_read_cooling_mode (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_cooling_mode");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	if (!tz->flags.cooling_mode) {
+		p += sprintf(p, "<not supported>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "cooling mode:            %s\n",
+		tz->cooling_mode?"passive":"active");
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_write_cooling_mode (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			mode_string[12] = {'\0'};
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_cooling_mode");
+
+	if (!tz || (count > sizeof(mode_string) - 1))
+		return_VALUE(-EINVAL);
+
+	if (!tz->flags.cooling_mode)
+		return_VALUE(-ENODEV);
+
+	if (copy_from_user(mode_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	mode_string[count] = '\0';
+	
+	result = acpi_thermal_set_cooling_mode(tz, 
+		simple_strtoul(mode_string, NULL, 0));
+	if (0 != result)
+		return_VALUE(result);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_thermal_read_polling (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			*p = page;
+	int			len = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_read_polling");
+
+	if (!tz || (off != 0))
+		goto end;
+
+	if (!tz->polling_frequency) {
+		p += sprintf(p, "<polling disabled>\n");
+		goto end;
+	}
+
+	p += sprintf(p, "polling frequency:       %lu seconds\n",
+		(tz->polling_frequency / 10));
+
+end:
+	len = (p - page);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+
+	return_VALUE(len);
+}
+
+
+static int
+acpi_thermal_write_polling (
+	struct file		*file,
+	const char		*buffer,
+	unsigned long		count,
+	void			*data)
+{
+	int			result = 0;
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	char			polling_string[12] = {'\0'};
+	int			seconds = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_write_polling");
+
+	if (!tz || (count > sizeof(polling_string) - 1))
+		return_VALUE(-EINVAL);
+	
+	if (copy_from_user(polling_string, buffer, count))
+		return_VALUE(-EFAULT);
+	
+	polling_string[count] = '\0';
+
+	seconds = simple_strtoul(polling_string, NULL, 0);
+	
+	result = acpi_thermal_set_polling(tz, seconds);
+	if (0 != result)
+		return_VALUE(result);
+
+	acpi_thermal_check(tz);
+
+	return_VALUE(count);
+}
+
+
+static int
+acpi_thermal_add_fs (
+	struct acpi_device	*device)
+{
+	struct proc_dir_entry	*entry = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_add_fs");
+
+	if (!acpi_thermal_dir) {
+		acpi_thermal_dir = proc_mkdir(ACPI_THERMAL_CLASS, 
+			acpi_root_dir);
+		if (!acpi_thermal_dir)
+			return_VALUE(-ENODEV);
+	}
+
+	if (!acpi_device_dir(device)) {
+		acpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),
+			acpi_thermal_dir);
+		if (!acpi_device_dir(device))
+			return_VALUE(-ENODEV);
+	}
+
+	/* 'state' [R] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_STATE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_STATE));
+	else {
+		entry->read_proc = acpi_thermal_read_state;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'temperature' [R] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_TEMPERATURE,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_TEMPERATURE));
+	else {
+		entry->read_proc = acpi_thermal_read_temperature;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'trip_points' [R] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_TRIP_POINTS,
+		S_IRUGO, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_POLLING_FREQ));
+	else {
+		entry->read_proc = acpi_thermal_read_trip_points;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'cooling_mode' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_COOLING_MODE,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_COOLING_MODE));
+	else {
+		entry->read_proc = acpi_thermal_read_cooling_mode;
+		entry->write_proc = acpi_thermal_write_cooling_mode;
+		entry->data = acpi_driver_data(device);
+	}
+
+	/* 'polling_frequency' [R/W] */
+	entry = create_proc_entry(ACPI_THERMAL_FILE_POLLING_FREQ,
+		S_IFREG|S_IRUGO|S_IWUSR, acpi_device_dir(device));
+	if (!entry)
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Unable to create '%s' fs entry\n",
+			ACPI_THERMAL_FILE_POLLING_FREQ));
+	else {
+		entry->read_proc = acpi_thermal_read_polling;
+		entry->write_proc = acpi_thermal_write_polling;
+		entry->data = acpi_driver_data(device);
+	}
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_remove_fs (
+	struct acpi_device	*device)
+{
+	ACPI_FUNCTION_TRACE("acpi_thermal_remove_fs");
+
+	if (!acpi_thermal_dir)
+		return_VALUE(-ENODEV);
+
+	if (acpi_device_dir(device))
+		remove_proc_entry(acpi_device_bid(device), acpi_thermal_dir);
+
+	return_VALUE(0);
+}
+
+
+/* --------------------------------------------------------------------------
+                                 Driver Interface
+   -------------------------------------------------------------------------- */
+
+static void
+acpi_thermal_notify (
+	acpi_handle 		handle,
+	u32 			event,
+	void 			*data)
+{
+	struct acpi_thermal	*tz = (struct acpi_thermal *) data;
+	struct acpi_device	*device = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_notify");
+
+	if (!tz)
+		return_VOID;
+
+	if (0 != acpi_bus_get_device(tz->handle, &device))
+		return_VOID;
+
+	switch (event) {
+	case ACPI_THERMAL_NOTIFY_TEMPERATURE:
+		acpi_thermal_check(tz);
+		break;
+	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
+		acpi_thermal_get_trip_points(tz);
+		acpi_thermal_check(tz);
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	case ACPI_THERMAL_NOTIFY_DEVICES:
+		if (tz->flags.devices)
+			acpi_thermal_get_devices(tz);
+		acpi_bus_generate_event(device, event, 0);
+		break;
+	default:
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Unsupported event [0x%x]\n", event));
+		break;
+	}
+
+	return_VOID;
+}
+
+
+static int
+acpi_thermal_get_info (
+	struct acpi_thermal	*tz)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_get_info");
+
+	if (!tz)
+		return_VALUE(-EINVAL);
+
+	/* Get temperature [_TMP] (required) */
+	result = acpi_thermal_get_temperature(tz);
+	if (0 != result)
+		return_VALUE(result);
+
+	/* Set the cooling mode [_SCP] to active cooling (default) */
+	result = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);
+	if (0 == result)
+		tz->flags.cooling_mode = 1;
+
+	/* Get trip points [_CRT, _PSV, etc.] (required) */
+	result = acpi_thermal_get_trip_points(tz);
+	if (0 != result)
+		return_VALUE(result);
+
+	/* Get default polling frequency [_TZP] (optional) */
+	if (tzp)
+		tz->polling_frequency = tzp;
+	else
+		acpi_thermal_get_polling_frequency(tz);
+
+	/* Get devices in this thermal zone [_TZD] (optional) */
+	result = acpi_thermal_get_devices(tz);
+	if (0 == result)
+		tz->flags.devices = 1;
+
+	return_VALUE(0);
+}
+
+
+static int
+acpi_thermal_add (
+	struct acpi_device 		*device)
+{
+	int			result = 0;
+	acpi_status		status = AE_OK;
+	struct acpi_thermal	*tz = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_add");
+
+	if (!device)
+		return_VALUE(-EINVAL);
+
+	tz = kmalloc(sizeof(struct acpi_thermal), GFP_KERNEL);
+	if (!tz)
+		return_VALUE(-ENOMEM);
+	memset(tz, 0, sizeof(struct acpi_thermal));
+
+	tz->handle = device->handle;
+	sprintf(tz->name, "%s", device->pnp.bus_id);
+	sprintf(acpi_device_name(device), "%s", ACPI_THERMAL_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_THERMAL_CLASS);
+	acpi_driver_data(device) = tz;
+
+	result = acpi_thermal_get_info(tz);
+	if (0 != result)
+		goto end;
+
+	result = acpi_thermal_add_fs(device);
+	if (0 != result)
+		return_VALUE(result);
+
+	acpi_thermal_check(tz);
+
+	status = acpi_install_notify_handler(tz->handle,
+		ACPI_DEVICE_NOTIFY, acpi_thermal_notify, tz);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error installing notify handler\n"));
+		result = -ENODEV;
+		goto end;
+	}
+
+	init_timer(&tz->timer);
+
+	printk(KERN_INFO PREFIX "%s [%s] (%lu C)\n",
+		acpi_device_name(device), acpi_device_bid(device),
+		KELVIN_TO_CELSIUS(tz->temperature));
+
+end:
+	if (result) {
+		acpi_thermal_remove_fs(device);
+		kfree(tz);
+	}
+
+	return_VALUE(result);
+}
+
+
+static int
+acpi_thermal_remove (
+	struct acpi_device	*device,
+	int			type)
+{
+	acpi_status		status = AE_OK;
+	struct acpi_thermal	*tz = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_remove");
+
+	if (!device || !acpi_driver_data(device))
+		return_VALUE(-EINVAL);
+
+	tz = (struct acpi_thermal *) acpi_driver_data(device);
+
+	if (timer_pending(&(tz->timer)))
+		del_timer(&(tz->timer));
+
+	status = acpi_remove_notify_handler(tz->handle,
+		ACPI_DEVICE_NOTIFY, acpi_thermal_notify);
+	if (ACPI_FAILURE(status))
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
+			"Error removing notify handler\n"));
+
+	/* Terminate policy */
+	if (tz->trips.passive.flags.valid
+		&& tz->trips.passive.flags.enabled) {
+		tz->trips.passive.flags.enabled = 0;
+		acpi_thermal_passive(tz);
+	}
+	if (tz->trips.active[0].flags.valid
+		&& tz->trips.active[0].flags.enabled) {
+		tz->trips.active[0].flags.enabled = 0;
+		acpi_thermal_active(tz);
+	}
+
+	acpi_thermal_remove_fs(device);
+
+	return_VALUE(0);
+}
+
+
+static int __init
+acpi_thermal_init (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_init");
+
+	result = acpi_bus_register_driver(&acpi_thermal_driver);
+	if (0 > result)
+		return_VALUE(-ENODEV);
+
+	return_VALUE(0);
+}
+
+
+static void __exit
+acpi_thermal_exit (void)
+{
+	int			result = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_thermal_exit");
+
+	result = acpi_bus_unregister_driver(&acpi_thermal_driver);
+	if (0 == result)
+		remove_proc_entry(ACPI_THERMAL_CLASS, acpi_root_dir);
+
+	return_VOID;
+}
+
+
+module_init(acpi_thermal_init);
+module_exit(acpi_thermal_exit);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utalloc.c linux/drivers/acpi/utilities/utalloc.c
--- ../prev/linux/drivers/acpi/utilities/utalloc.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utalloc.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: utalloc - local cache and memory allocation routines
- *              $Revision: 121 $
+ *              $Revision: 127 $
  *
  *****************************************************************************/
 
@@ -25,10 +25,6 @@
 
 
 #include "acpi.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "acnamesp.h"
-#include "acglobal.h"
 
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utalloc")
@@ -77,11 +73,11 @@
 		/* Mark the object as cached */
 
 		ACPI_MEMSET (object, 0xCA, cache_info->object_size);
-		ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_CACHED_OBJECT);
+		ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_CACHED);
 
 		/* Put the object at the head of the cache list */
 
-		* (char **) (((char *) object) + cache_info->link_offset) = cache_info->list_head;
+		* (ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset]))) = cache_info->list_head;
 		cache_info->list_head = object;
 		cache_info->cache_depth++;
 
@@ -128,7 +124,7 @@
 		/* There is an object available, use it */
 
 		object = cache_info->list_head;
-		cache_info->list_head = * (char **) (((char *) object) + cache_info->link_offset);
+		cache_info->list_head = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) object)[cache_info->link_offset])));
 
 		ACPI_MEM_TRACKING (cache_info->cache_hits++);
 		cache_info->cache_depth--;
@@ -191,7 +187,7 @@
 	while (cache_info->list_head) {
 		/* Delete one cached state object */
 
-		next = * (char **) (((char *) cache_info->list_head) + cache_info->link_offset);
+		next = *(ACPI_CAST_INDIRECT_PTR (char, &(((char *) cache_info->list_head)[cache_info->link_offset])));
 		ACPI_MEM_FREE (cache_info->list_head);
 
 		cache_info->list_head = next;
@@ -362,7 +358,7 @@
 		/* Report allocation error */
 
 		_ACPI_REPORT_ERROR (module, line, component,
-				("Ut_allocate: Could not allocate size %X\n", size));
+				("Ut_allocate: Could not allocate size %X\n", (u32) size));
 
 		return_PTR (NULL);
 	}
@@ -412,7 +408,7 @@
 		/* Report allocation error */
 
 		_ACPI_REPORT_ERROR (module, line, component,
-				("Ut_callocate: Could not allocate size %X\n", size));
+				("Ut_callocate: Could not allocate size %X\n", (u32) size));
 		return_PTR (NULL);
 	}
 
@@ -514,7 +510,7 @@
 		/* Report allocation error */
 
 		_ACPI_REPORT_ERROR (module, line, component,
-				("Ut_callocate: Could not allocate size %X\n", size));
+				("Ut_callocate: Could not allocate size %X\n", (u32) size));
 		return (NULL);
 	}
 
@@ -555,6 +551,7 @@
 	u32                     line)
 {
 	acpi_debug_mem_block    *debug_block;
+	acpi_status             status;
 
 
 	ACPI_FUNCTION_TRACE_PTR ("Ut_free", allocation);
@@ -567,14 +564,19 @@
 		return_VOID;
 	}
 
-	debug_block = (acpi_debug_mem_block *)
-			  (((char *) allocation) - sizeof (acpi_debug_mem_header));
+	debug_block = ACPI_CAST_PTR (acpi_debug_mem_block,
+			  (((char *) allocation) - sizeof (acpi_debug_mem_header)));
 
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].total_freed++;
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_GLOBAL].current_total_size -= debug_block->size;
 
-	acpi_ut_remove_allocation (ACPI_MEM_LIST_GLOBAL, debug_block,
-			component, module, line);
+	status = acpi_ut_remove_allocation (ACPI_MEM_LIST_GLOBAL, debug_block,
+			  component, module, line);
+	if (ACPI_FAILURE (status)) {
+		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "Could not free memory, %s\n",
+			acpi_format_exception (status)));
+	}
+
 	acpi_os_free (debug_block);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p freed\n", allocation));
@@ -864,6 +866,7 @@
 	NATIVE_CHAR             *module)
 {
 	acpi_debug_mem_block    *element;
+	ACPI_DESCRIPTOR         *descriptor;
 	u32                     num_outstanding = 0;
 
 
@@ -883,28 +886,29 @@
 			((module == NULL) || (0 == ACPI_STRCMP (module, element->module)))) {
 			/* Ignore allocated objects that are in a cache */
 
-			if (((acpi_operand_object  *)(&element->user_space))->common.type != ACPI_CACHED_OBJECT) {
+			descriptor = ACPI_CAST_PTR (ACPI_DESCRIPTOR, &element->user_space);
+			if (descriptor->descriptor_id != ACPI_DESC_TYPE_CACHED) {
 				acpi_os_printf ("%p Len %04X %9.9s-%d ",
-						 &element->user_space, element->size, element->module,
+						 descriptor, element->size, element->module,
 						 element->line);
 
 				/* Most of the elements will be internal objects. */
 
-				switch (ACPI_GET_DESCRIPTOR_TYPE (&element->user_space)) {
-				case ACPI_DESC_TYPE_INTERNAL:
-					acpi_os_printf ("Obj_type %12.12s R%d",
-							acpi_ut_get_type_name (((acpi_operand_object *)(&element->user_space))->common.type),
-							((acpi_operand_object *)(&element->user_space))->common.reference_count);
+				switch (ACPI_GET_DESCRIPTOR_TYPE (descriptor)) {
+				case ACPI_DESC_TYPE_OPERAND:
+					acpi_os_printf ("Obj_type %12.12s R%hd",
+							acpi_ut_get_type_name (descriptor->object.common.type),
+							descriptor->object.common.reference_count);
 					break;
 
 				case ACPI_DESC_TYPE_PARSER:
-					acpi_os_printf ("Parse_obj Opcode %04X",
-							((acpi_parse_object *)(&element->user_space))->opcode);
+					acpi_os_printf ("Parse_obj Aml_opcode %04hX",
+							descriptor->op.asl.aml_opcode);
 					break;
 
 				case ACPI_DESC_TYPE_NAMED:
 					acpi_os_printf ("Node %4.4s",
-							(char *) &((acpi_namespace_node *)(&element->user_space))->name);
+							descriptor->node.name.ascii);
 					break;
 
 				case ACPI_DESC_TYPE_STATE:
@@ -946,6 +950,10 @@
 				case ACPI_DESC_TYPE_STATE_THREAD:
 					acpi_os_printf ("THREAD State_obj");
 					break;
+
+				default:
+					/* All types should appear above */
+					break;
 				}
 
 				acpi_os_printf ( "\n");
@@ -961,7 +969,7 @@
 
 	if (!num_outstanding) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_OK,
-				"No outstanding allocations.\n"));
+			"No outstanding allocations.\n"));
 	}
 	else {
 		ACPI_DEBUG_PRINT ((ACPI_DB_OK,
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utcopy.c linux/drivers/acpi/utilities/utcopy.c
--- ../prev/linux/drivers/acpi/utilities/utcopy.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utcopy.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: utcopy - Internal to external object translation utilities
- *              $Revision: 95 $
+ *              $Revision: 98 $
  *
  *****************************************************************************/
 
@@ -25,7 +25,6 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
 #include "acnamesp.h"
 #include "amlcode.h"
 
@@ -92,10 +91,10 @@
 
 		external_object->string.pointer = (NATIVE_CHAR *) data_space;
 		external_object->string.length = internal_object->string.length;
-		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (internal_object->string.length + 1);
+		*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD ((ACPI_SIZE) internal_object->string.length + 1);
 
 		ACPI_MEMCPY ((void *) data_space, (void *) internal_object->string.pointer,
-				 internal_object->string.length + 1);
+				 (ACPI_SIZE) internal_object->string.length + 1);
 		break;
 
 
@@ -153,12 +152,12 @@
 			buffer.length = MAX_STRING_LENGTH;
 			buffer.pointer = data_space;
 
-			status = acpi_ns_handle_to_pathname ((acpi_handle *) internal_object->reference.node,
+			status = acpi_ns_handle_to_pathname ((acpi_handle) internal_object->reference.node,
 					 &buffer);
 
 			/* Converted (external) string length is returned from above */
 
-			external_object->string.length = buffer.length;
+			external_object->string.length = (u32) buffer.length;
 			*buffer_space_used = ACPI_ROUND_UP_TO_NATIVE_WORD (buffer.length);
 			break;
 
@@ -257,7 +256,7 @@
 		 */
 		target_object->type             = ACPI_TYPE_PACKAGE;
 		target_object->package.count    = source_object->package.count;
-		target_object->package.elements = (acpi_object *) info->free_space;
+		target_object->package.elements = ACPI_CAST_PTR (acpi_object, info->free_space);
 
 		/*
 		 * Pass the new package object back to the package walk routine
@@ -269,7 +268,7 @@
 		 * update the buffer length counter
 		 */
 		object_space = ACPI_ROUND_UP_TO_NATIVE_WORD (
-				   target_object->package.count * sizeof (acpi_object));
+				   (ACPI_SIZE) target_object->package.count * sizeof (acpi_object));
 		break;
 
 
@@ -319,7 +318,7 @@
 	/*
 	 * First package at head of the buffer
 	 */
-	external_object = (acpi_object *) buffer;
+	external_object = ACPI_CAST_PTR (acpi_object, buffer);
 
 	/*
 	 * Free space begins right after the first package
@@ -331,7 +330,7 @@
 
 	external_object->type              = internal_object->common.type;
 	external_object->package.count     = internal_object->package.count;
-	external_object->package.elements  = (acpi_object *) info.free_space;
+	external_object->package.elements  = ACPI_CAST_PTR (acpi_object, info.free_space);
 
 	/*
 	 * Build an array of ACPI_OBJECTS in the buffer
@@ -456,7 +455,7 @@
 
 	case ACPI_TYPE_STRING:
 
-		internal_object->string.pointer = ACPI_MEM_CALLOCATE (external_object->string.length + 1);
+		internal_object->string.pointer = ACPI_MEM_CALLOCATE ((ACPI_SIZE) external_object->string.length + 1);
 		if (!internal_object->string.pointer) {
 			return_ACPI_STATUS (AE_NO_MEMORY);
 		}
@@ -488,6 +487,10 @@
 
 		internal_object->integer.value  = external_object->integer.value;
 		break;
+
+	default:
+		/* Other types can't get here */
+		break;
 	}
 
 	*ret_internal_object = internal_object;
@@ -657,6 +660,7 @@
 		dest_desc->common.flags = source_desc->common.flags;
 
 		/* Fall through to common string/buffer case */
+		/*lint -fallthrough */
 
 	case ACPI_TYPE_STRING:
 
@@ -677,6 +681,10 @@
 					  source_desc->string.length);
 		}
 		break;
+
+	default:
+		/* Nothing to do for other simple objects */
+		break;
 	}
 
 	return (AE_OK);
@@ -803,7 +811,7 @@
 	/*
 	 * Create the object array and walk the source package tree
 	 */
-	dest_obj->package.elements = ACPI_MEM_CALLOCATE ((source_obj->package.count + 1) *
+	dest_obj->package.elements = ACPI_MEM_CALLOCATE (((ACPI_SIZE) source_obj->package.count + 1) *
 			 sizeof (void *));
 	if (!dest_obj->package.elements) {
 		ACPI_REPORT_ERROR (
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utdebug.c linux/drivers/acpi/utilities/utdebug.c
--- ../prev/linux/drivers/acpi/utilities/utdebug.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utdebug.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: utdebug - Debug print routines
- *              $Revision: 97 $
+ *              $Revision: 103 $
  *
  *****************************************************************************/
 
@@ -30,13 +30,12 @@
 	 ACPI_MODULE_NAME    ("utdebug")
 
 
-u32             acpi_gbl_prev_thread_id = 0xFFFFFFFF;
-char            *acpi_gbl_fn_entry_str = "----Entry";
-char            *acpi_gbl_fn_exit_str = "----Exit-";
-
-
 #ifdef ACPI_DEBUG
 
+static u32   acpi_gbl_prev_thread_id = 0xFFFFFFFF;
+static char     *acpi_gbl_fn_entry_str = "----Entry";
+static char     *acpi_gbl_fn_exit_str = "----Exit-";
+
 
 /*****************************************************************************
  *
@@ -132,7 +131,6 @@
 		return;
 	}
 
-
 	/*
 	 * Thread tracking and context switch notification
 	 */
@@ -151,14 +149,13 @@
 	 * Display the module name, current line number, thread ID (if requested),
 	 * current procedure nesting level, and the current procedure name
 	 */
-	acpi_os_printf ("%8s-%04d ", dbg_info->module_name, line_number);
+	acpi_os_printf ("%8s-%04ld ", dbg_info->module_name, line_number);
 
 	if (ACPI_LV_THREADS & acpi_dbg_level) {
-		acpi_os_printf ("[%04X] ", thread_id, acpi_gbl_nesting_level, dbg_info->proc_name);
+		acpi_os_printf ("[%04lX] ", thread_id, acpi_gbl_nesting_level, dbg_info->proc_name);
 	}
 
-	acpi_os_printf ("[%02d] %-22.22s: ", acpi_gbl_nesting_level, dbg_info->proc_name);
-
+	acpi_os_printf ("[%02ld] %-22.22s: ", acpi_gbl_nesting_level, dbg_info->proc_name);
 
 	va_start (args, format);
 	acpi_os_vprintf (format, args);
@@ -202,7 +199,6 @@
 	}
 
 	va_start (args, format);
-
 	acpi_os_vprintf (format, args);
 }
 
@@ -495,8 +491,8 @@
 	u32                     display,
 	u32                     component_id)
 {
-	u32                     i = 0;
-	u32                     j;
+	NATIVE_UINT             i = 0;
+	NATIVE_UINT             j;
 	u32                     temp32;
 	u8                      buf_char;
 
@@ -522,7 +518,6 @@
 
 		acpi_os_printf ("%05X  ", i);
 
-
 		/* Print 16 hex chars */
 
 		for (j = 0; j < 16;) {
@@ -576,12 +571,10 @@
 			}
 		}
 
-
 		/*
 		 * Print the ASCII equivalent characters
 		 * But watch out for the bad unprintable ones...
 		 */
-
 		for (j = 0; j < 16; j++) {
 			if (i + j >= count) {
 				acpi_os_printf ("\n");
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utdelete.c linux/drivers/acpi/utilities/utdelete.c
--- ../prev/linux/drivers/acpi/utilities/utdelete.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utdelete.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: utdelete - object deletion and reference count utilities
- *              $Revision: 88 $
+ *              $Revision: 90 $
  *
  ******************************************************************************/
 
@@ -27,8 +27,6 @@
 #include "acpi.h"
 #include "acinterp.h"
 #include "acnamesp.h"
-#include "actables.h"
-#include "acparser.h"
 
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utdelete")
@@ -114,7 +112,7 @@
 			object, object->mutex.semaphore));
 
 		acpi_ex_unlink_mutex (object);
-		acpi_os_delete_semaphore (object->mutex.semaphore);
+		(void) acpi_os_delete_semaphore (object->mutex.semaphore);
 		break;
 
 
@@ -123,7 +121,7 @@
 		ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "***** Event %p, Semaphore %p\n",
 			object, object->event.semaphore));
 
-		acpi_os_delete_semaphore (object->event.semaphore);
+		(void) acpi_os_delete_semaphore (object->event.semaphore);
 		object->event.semaphore = NULL;
 		break;
 
@@ -135,7 +133,7 @@
 		/* Delete the method semaphore if it exists */
 
 		if (object->method.semaphore) {
-			acpi_os_delete_semaphore (object->method.semaphore);
+			(void) acpi_os_delete_semaphore (object->method.semaphore);
 			object->method.semaphore = NULL;
 		}
 		break;
@@ -205,14 +203,14 @@
  *
  * PARAMETERS:  *Obj_list       - Pointer to the list to be deleted
  *
- * RETURN:      Status          - the status of the call
+ * RETURN:      None
  *
  * DESCRIPTION: This function deletes an internal object list, including both
  *              simple objects and package objects
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ut_delete_internal_object_list (
 	acpi_operand_object     **obj_list)
 {
@@ -231,7 +229,7 @@
 	/* Free the combined parameter pointer list and object array */
 
 	ACPI_MEM_FREE (obj_list);
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
@@ -411,7 +409,7 @@
 			status = acpi_ut_create_update_state_and_push (object->device.addr_handler,
 					   action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 
 			acpi_ut_update_ref_count (object->device.sys_handler, action);
@@ -448,7 +446,7 @@
 				status = acpi_ut_create_update_state_and_push (
 						 object->package.elements[i], action, &state_list);
 				if (ACPI_FAILURE (status)) {
-					return_ACPI_STATUS (status);
+					goto error_exit;
 				}
 			}
 			break;
@@ -458,9 +456,8 @@
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->buffer_field.buffer_obj, action, &state_list);
-
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 			break;
 
@@ -470,7 +467,7 @@
 			status = acpi_ut_create_update_state_and_push (
 					 object->field.region_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 		   break;
 
@@ -480,13 +477,13 @@
 			status = acpi_ut_create_update_state_and_push (
 					 object->bank_field.bank_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->bank_field.region_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 			break;
 
@@ -496,19 +493,20 @@
 			status = acpi_ut_create_update_state_and_push (
 					 object->index_field.index_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 
 			status = acpi_ut_create_update_state_and_push (
 					 object->index_field.data_obj, action, &state_list);
 			if (ACPI_FAILURE (status)) {
-				return_ACPI_STATUS (status);
+				goto error_exit;
 			}
 			break;
 
 
 		case ACPI_TYPE_REGION:
 		case INTERNAL_TYPE_REFERENCE:
+		default:
 
 			/* No subobjects */
 			break;
@@ -527,6 +525,14 @@
 	}
 
 	return_ACPI_STATUS (AE_OK);
+
+
+error_exit:
+
+	ACPI_REPORT_ERROR (("Could not update object reference count, %s\n",
+		acpi_format_exception (status)));
+
+	return_ACPI_STATUS (status);
 }
 
 
@@ -561,7 +567,7 @@
 	/*
 	 * We have a valid ACPI internal object, now increment the reference count
 	 */
-	acpi_ut_update_object_reference (object, REF_INCREMENT);
+	(void) acpi_ut_update_object_reference (object, REF_INCREMENT);
 	return_VOID;
 }
 
@@ -610,7 +616,7 @@
 	 * if the reference count becomes 0.  (Must also decrement the ref count
 	 * of all subobjects!)
 	 */
-	acpi_ut_update_object_reference (object, REF_DECREMENT);
+	(void) acpi_ut_update_object_reference (object, REF_DECREMENT);
 	return_VOID;
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/uteval.c linux/drivers/acpi/utilities/uteval.c
--- ../prev/linux/drivers/acpi/utilities/uteval.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/uteval.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: uteval - Object evaluation
- *              $Revision: 38 $
+ *              $Revision: 39 $
  *
  *****************************************************************************/
 
@@ -69,11 +69,11 @@
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_NOT_FOUND) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s on %4.4s was not found\n",
-				object_name, (char *) &device_node->name));
+				object_name, device_node->name.ascii));
 		}
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "%s on %4.4s failed with status %s\n",
-				object_name, (char *) &device_node->name,
+				object_name, device_node->name.ascii,
 				acpi_format_exception (status)));
 		}
 
@@ -148,11 +148,11 @@
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_NOT_FOUND) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "_HID on %4.4s was not found\n",
-				(char *) &device_node->name));
+				device_node->name.ascii));
 		}
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "_HID on %4.4s failed %s\n",
-				(char *) &device_node->name, acpi_format_exception (status)));
+				device_node->name.ascii, acpi_format_exception (status)));
 		}
 
 		return_ACPI_STATUS (status);
@@ -231,11 +231,11 @@
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_NOT_FOUND) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "_CID on %4.4s was not found\n",
-				(char *)&device_node->name));
+				device_node->name.ascii));
 		}
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "_CID on %4.4s failed %s\n",
-				(char *)&device_node->name, acpi_format_exception (status)));
+				device_node->name.ascii, acpi_format_exception (status)));
 		}
 
 		return_ACPI_STATUS (status);
@@ -325,12 +325,12 @@
 	if (ACPI_FAILURE (status)) {
 		if (status == AE_NOT_FOUND) {
 			ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "_UID on %4.4s was not found\n",
-				(char *) &device_node->name));
+				device_node->name.ascii));
 		}
 		else {
 			ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 				"_UID on %4.4s failed %s\n",
-				(char *) &device_node->name, acpi_format_exception (status)));
+				device_node->name.ascii, acpi_format_exception (status)));
 		}
 
 		return (status);
@@ -411,7 +411,7 @@
 	if (AE_NOT_FOUND == status) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
 			"_STA on %4.4s was not found, assuming present.\n",
-			(char *) &device_node->name));
+			device_node->name.ascii));
 
 		*flags = 0x0F;
 		status = AE_OK;
@@ -419,7 +419,7 @@
 
 	else if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "_STA on %4.4s failed %s\n",
-			(char *) &device_node->name,
+			device_node->name.ascii,
 			acpi_format_exception (status)));
 	}
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utglobal.c linux/drivers/acpi/utilities/utglobal.c
--- ../prev/linux/drivers/acpi/utilities/utglobal.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utglobal.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: utglobal - Global variables for the ACPI subsystem
- *              $Revision: 155 $
+ *              $Revision: 161 $
  *
  *****************************************************************************/
 
@@ -26,11 +26,7 @@
 #define DEFINE_ACPI_GLOBALS
 
 #include "acpi.h"
-#include "acevents.h"
 #include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
-
 
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utglobal")
@@ -180,15 +176,15 @@
  */
 
 const acpi_predefined_names     acpi_gbl_pre_defined_names[] =
-{ {"_GPE",    INTERNAL_TYPE_DEF_ANY},
-	{"_PR_",    INTERNAL_TYPE_DEF_ANY},
-	{"_SB_",    ACPI_TYPE_DEVICE},
-	{"_SI_",    INTERNAL_TYPE_DEF_ANY},
-	{"_TZ_",    INTERNAL_TYPE_DEF_ANY},
+{ {"_GPE",    INTERNAL_TYPE_DEF_ANY,      NULL},
+	{"_PR_",    INTERNAL_TYPE_DEF_ANY,      NULL},
+	{"_SB_",    ACPI_TYPE_DEVICE,           NULL},
+	{"_SI_",    INTERNAL_TYPE_DEF_ANY,      NULL},
+	{"_TZ_",    INTERNAL_TYPE_DEF_ANY,      NULL},
 	{"_REV",    ACPI_TYPE_INTEGER,          "2"},
 	{"_OS_",    ACPI_TYPE_STRING,           ACPI_OS_NAME},
 	{"_GL_",    ACPI_TYPE_MUTEX,            "0"},
-	{NULL,      ACPI_TYPE_ANY}              /* Table terminator */
+	{NULL,      ACPI_TYPE_ANY,              NULL}              /* Table terminator */
 };
 
 
@@ -243,9 +239,9 @@
 
 /* Hex to ASCII conversion table */
 
-const NATIVE_CHAR           acpi_gbl_hex_to_ascii[] =
+static const NATIVE_CHAR    acpi_gbl_hex_to_ascii[] =
 			  {'0','1','2','3','4','5','6','7',
-			  '8','9','A','B','C','D','E','F'};
+					 '8','9','A','B','C','D','E','F'};
 
 /*****************************************************************************
  *
@@ -261,7 +257,7 @@
  *
  ****************************************************************************/
 
-u8
+char
 acpi_ut_hex_to_ascii_char (
 	acpi_integer            integer,
 	u32                     position)
@@ -361,7 +357,7 @@
 
 /* Region type decoding */
 
-const NATIVE_CHAR *acpi_gbl_region_types[ACPI_NUM_PREDEFINED_REGIONS] =
+static const NATIVE_CHAR *acpi_gbl_region_types[ACPI_NUM_PREDEFINED_REGIONS] =
 {
 	"System_memory",
 	"System_iO",
@@ -407,7 +403,7 @@
 
 /* Event type decoding */
 
-const NATIVE_CHAR *acpi_gbl_event_types[ACPI_NUM_FIXED_EVENTS] =
+static const NATIVE_CHAR *acpi_gbl_event_types[ACPI_NUM_FIXED_EVENTS] =
 {
 	"PM_Timer",
 	"Global_lock",
@@ -431,7 +427,7 @@
 }
 
 
-#ifdef ACPI_DEBUG
+#if defined(ACPI_DEBUG) || defined(ENABLE_DEBUGGER)
 
 /*
  * Strings and procedures used for debug only
@@ -545,16 +541,21 @@
 }
 
 
+/* Various strings for future use */
+
+#if 0
+#include "amlcode.h"
+
 /* Data used in keeping track of fields */
 
-const NATIVE_CHAR *acpi_gbl_FEnames[NUM_FIELD_NAMES] =
+static const NATIVE_CHAR *acpi_gbl_FEnames[NUM_FIELD_NAMES] =
 {
 	"skip",
 	"?access?"
 };              /* FE = Field Element */
 
 
-const NATIVE_CHAR *acpi_gbl_match_ops[NUM_MATCH_OPS] =
+static const NATIVE_CHAR *acpi_gbl_match_ops[NUM_MATCH_OPS] =
 {
 	"Error",
 	"MTR",
@@ -568,7 +569,7 @@
 
 /* Access type decoding */
 
-const NATIVE_CHAR *acpi_gbl_access_types[NUM_ACCESS_TYPES] =
+static const NATIVE_CHAR *acpi_gbl_access_types[NUM_ACCESS_TYPES] =
 {
 	"Any_acc",
 	"Byte_acc",
@@ -581,12 +582,13 @@
 
 /* Update rule decoding */
 
-const NATIVE_CHAR *acpi_gbl_update_rules[NUM_UPDATE_RULES] =
+static const NATIVE_CHAR *acpi_gbl_update_rules[NUM_UPDATE_RULES] =
 {
 	"Preserve",
 	"Write_as_ones",
 	"Write_as_zeros"
 };
+#endif /* Future use */
 
 #endif
 
@@ -670,6 +672,9 @@
 			acpi_gbl_next_method_owner_id = ACPI_FIRST_METHOD_ID;
 		}
 		break;
+
+	default:
+		break;
 	}
 
 	(void) acpi_ut_release_mutex (ACPI_MTX_CACHES);
@@ -702,15 +707,15 @@
 	ACPI_MEMSET (acpi_gbl_memory_lists, 0, sizeof (ACPI_MEMORY_LIST) * ACPI_NUM_MEM_LISTS);
 
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].link_offset      = (u16) ACPI_PTR_DIFF (&(((acpi_generic_state *) NULL)->common.next), NULL);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].link_offset     = (u16) ACPI_PTR_DIFF (&(((acpi_parse_object *) NULL)->next), NULL);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].link_offset = (u16) ACPI_PTR_DIFF (&(((acpi_parse2_object *) NULL)->next), NULL);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].link_offset     = (u16) ACPI_PTR_DIFF (&(((acpi_parse_object *) NULL)->common.next), NULL);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].link_offset = (u16) ACPI_PTR_DIFF (&(((acpi_parse_object *) NULL)->common.next), NULL);
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].link_offset    = (u16) ACPI_PTR_DIFF (&(((acpi_operand_object *) NULL)->cache.next), NULL);
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].link_offset       = (u16) ACPI_PTR_DIFF (&(((acpi_walk_state *) NULL)->next), NULL);
 
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_NSNODE].object_size     = sizeof (acpi_namespace_node);
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_STATE].object_size      = sizeof (acpi_generic_state);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].object_size     = sizeof (acpi_parse_object);
-	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].object_size = sizeof (acpi_parse2_object);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE].object_size     = sizeof (ACPI_PARSE_OBJ_COMMON);
+	acpi_gbl_memory_lists[ACPI_MEM_LIST_PSNODE_EXT].object_size = sizeof (ACPI_PARSE_OBJ_NAMED);
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_OPERAND].object_size    = sizeof (acpi_operand_object);
 	acpi_gbl_memory_lists[ACPI_MEM_LIST_WALK].object_size       = sizeof (acpi_walk_state);
 
@@ -753,6 +758,7 @@
 
 	acpi_gbl_sys_notify.handler         = NULL;
 	acpi_gbl_drv_notify.handler         = NULL;
+	acpi_gbl_init_handler               = NULL;
 
 	/* Global "typed" ACPI table pointers */
 
@@ -802,7 +808,7 @@
 
 
 #ifdef ACPI_DEBUG
-	acpi_gbl_lowest_stack_pointer       = ACPI_UINT32_MAX;
+	acpi_gbl_lowest_stack_pointer       = ACPI_SIZE_MAX;
 #endif
 
 	return_VOID;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utinit.c linux/drivers/acpi/utilities/utinit.c
--- ../prev/linux/drivers/acpi/utilities/utinit.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utinit.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: utinit - Common ACPI subsystem initialization
- *              $Revision: 109 $
+ *              $Revision: 112 $
  *
  *****************************************************************************/
 
@@ -25,7 +25,6 @@
 
 
 #include "acpi.h"
-#include "achware.h"
 #include "acnamesp.h"
 #include "acevents.h"
 
@@ -56,7 +55,7 @@
 {
 
 	ACPI_REPORT_WARNING (
-		("Invalid FADT value %s=%lX at offset %lX FADT=%p\n",
+		("Invalid FADT value %s=%X at offset %X FADT=%p\n",
 		register_name, value, offset, acpi_gbl_FADT));
 }
 
@@ -181,7 +180,7 @@
  *
  ******************************************************************************/
 
-acpi_status
+void
 acpi_ut_subsystem_shutdown (void)
 {
 
@@ -191,7 +190,7 @@
 
 	if (acpi_gbl_shutdown) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "ACPI Subsystem is already terminated\n"));
-		return_ACPI_STATUS (AE_OK);
+		return_VOID;
 	}
 
 	/* Subsystem appears active, go ahead and shut it down */
@@ -213,7 +212,7 @@
 
 	/* Purge the local caches */
 
-	acpi_purge_cached_objects ();
+	(void) acpi_purge_cached_objects ();
 
 	/* Debug only - display leftover memory allocation, if any */
 
@@ -221,7 +220,7 @@
 	acpi_ut_dump_allocations (ACPI_UINT32_MAX, NULL);
 #endif
 
-	return_ACPI_STATUS (AE_OK);
+	return_VOID;
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utmath.c linux/drivers/acpi/utilities/utmath.c
--- ../prev/linux/drivers/acpi/utilities/utmath.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utmath.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: utmath - Integer math support routines
- *              $Revision: 10 $
+ *              $Revision: 11 $
  *
  ******************************************************************************/
 
@@ -193,7 +193,7 @@
 		 */
 		partial1      = quotient.part.lo * divisor.part.hi;
 		partial2.full = (acpi_integer) quotient.part.lo * divisor.part.lo;
-		partial3.full = partial2.part.hi + partial1;
+		partial3.full = (acpi_integer) partial2.part.hi + partial1;
 
 		remainder.part.hi = partial3.part.lo;
 		remainder.part.lo = partial2.part.lo;
@@ -213,8 +213,8 @@
 			}
 
 			remainder.full    = remainder.full - dividend.full;
-			remainder.part.hi = -((s32) remainder.part.hi);
-			remainder.part.lo = -((s32) remainder.part.lo);
+			remainder.part.hi = (u32) -((s32) remainder.part.hi);
+			remainder.part.lo = (u32) -((s32) remainder.part.lo);
 
 			if (remainder.part.lo) {
 				remainder.part.hi--;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utmisc.c linux/drivers/acpi/utilities/utmisc.c
--- ../prev/linux/drivers/acpi/utilities/utmisc.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utmisc.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /*******************************************************************************
  *
  * Module Name: utmisc - common utility procedures
- *              $Revision: 67 $
+ *              $Revision: 75 $
  *
  ******************************************************************************/
 
@@ -25,18 +25,84 @@
 
 
 #include "acpi.h"
-#include "acevents.h"
-#include "achware.h"
 #include "acnamesp.h"
-#include "acinterp.h"
 #include "amlcode.h"
-#include "acdebug.h"
 
 
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utmisc")
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_ut_dword_byte_swap
+ *
+ * PARAMETERS:  Value           - Value to be converted
+ *
+ * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
+ *
+ ******************************************************************************/
+
+u32
+acpi_ut_dword_byte_swap (
+	u32                     value)
+{
+	union {
+		u32                 value;
+		u8                  bytes[4];
+	} out;
+
+	union {
+		u32                 value;
+		u8                  bytes[4];
+	} in;
+
+
+	ACPI_FUNCTION_ENTRY ();
+
+
+	in.value = value;
+
+	out.bytes[0] = in.bytes[3];
+	out.bytes[1] = in.bytes[2];
+	out.bytes[2] = in.bytes[1];
+	out.bytes[3] = in.bytes[0];
+
+	return (out.value);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_ut_set_integer_width
+ *
+ * PARAMETERS:  Revision            From DSDT header
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set the global integer bit width based upon the revision
+ *              of the DSDT.  For Revision 1 and 0, Integers are 32 bits.
+ *              For Revision 2 and above, Integers are 64 bits.  Yes, this
+ *              makes a difference.
+ *
+ ******************************************************************************/
+
+void
+acpi_ut_set_integer_width (
+	u8                      revision)
+{
+
+	if (revision <= 1) {
+		acpi_gbl_integer_bit_width = 32;
+		acpi_gbl_integer_byte_width = 4;
+	}
+	else {
+		acpi_gbl_integer_bit_width = 64;
+		acpi_gbl_integer_byte_width = 8;
+	}
+}
+
+
 #ifdef ACPI_DEBUG
 /*******************************************************************************
  *
@@ -145,6 +211,152 @@
 
 /*******************************************************************************
  *
+ * FUNCTION:    Acpi_ut_strtoul64
+ *
+ * PARAMETERS:  String          - Null terminated string
+ *              Terminater      - Where a pointer to the terminating byte is returned
+ *              Base            - Radix of the string
+ *
+ * RETURN:      Converted value
+ *
+ * DESCRIPTION: Convert a string into an unsigned value.
+ *
+ ******************************************************************************/
+#define NEGATIVE    1
+#define POSITIVE    0
+
+acpi_status
+acpi_ut_strtoul64 (
+	NATIVE_CHAR             *string,
+	u32                     base,
+	acpi_integer            *ret_integer)
+{
+	u32                     index;
+	acpi_integer            return_value = 0;
+	acpi_status             status = AE_OK;
+	acpi_integer            dividend;
+	acpi_integer            quotient;
+
+
+	*ret_integer = 0;
+
+	switch (base) {
+	case 0:
+	case 8:
+	case 10:
+	case 16:
+		break;
+
+	default:
+		/*
+		 * The specified Base parameter is not in the domain of
+		 * this function:
+		 */
+		return (AE_BAD_PARAMETER);
+	}
+
+	/*
+	 * skip over any white space in the buffer:
+	 */
+	while (ACPI_IS_SPACE (*string) || *string == '\t') {
+		++string;
+	}
+
+	/*
+	 * If the input parameter Base is zero, then we need to
+	 * determine if it is octal, decimal, or hexadecimal:
+	 */
+	if (base == 0) {
+		if (*string == '0') {
+			if (ACPI_TOLOWER (*(++string)) == 'x') {
+				base = 16;
+				++string;
+			}
+			else {
+				base = 8;
+			}
+		}
+		else {
+			base = 10;
+		}
+	}
+
+	/*
+	 * For octal and hexadecimal bases, skip over the leading
+	 * 0 or 0x, if they are present.
+	 */
+	if (base == 8 && *string == '0') {
+		string++;
+	}
+
+	if (base == 16 &&
+		*string == '0' &&
+		ACPI_TOLOWER (*(++string)) == 'x') {
+		string++;
+	}
+
+	/* Main loop: convert the string to an unsigned long */
+
+	while (*string) {
+		if (ACPI_IS_DIGIT (*string)) {
+			index = ((u8) *string) - '0';
+		}
+		else {
+			index = (u8) ACPI_TOUPPER (*string);
+			if (ACPI_IS_UPPER ((char) index)) {
+				index = index - 'A' + 10;
+			}
+			else {
+				goto error_exit;
+			}
+		}
+
+		if (index >= base) {
+			goto error_exit;
+		}
+
+		/* Check to see if value is out of range: */
+
+		dividend = ACPI_INTEGER_MAX - (acpi_integer) index;
+		(void) acpi_ut_short_divide (&dividend, base, &quotient, NULL);
+		if (return_value > quotient) {
+			goto error_exit;
+		}
+
+		return_value *= base;
+		return_value += index;
+		++string;
+	}
+
+	*ret_integer = return_value;
+	return (status);
+
+
+error_exit:
+	switch (base) {
+	case 8:
+		status = AE_BAD_OCTAL_CONSTANT;
+		break;
+
+	case 10:
+		status = AE_BAD_DECIMAL_CONSTANT;
+		break;
+
+	case 16:
+		status = AE_BAD_HEX_CONSTANT;
+		break;
+
+	default:
+		/* Base validated above */
+		break;
+	}
+
+	return (status);
+}
+
+
+/*******************************************************************************
+ *
  * FUNCTION:    Acpi_ut_strupr
  *
  * PARAMETERS:  Src_string      - The source string to convert to
@@ -239,7 +451,7 @@
 	 * Delete each predefined mutex object
 	 */
 	for (i = 0; i < NUM_MTX; i++) {
-		acpi_ut_delete_mutex (i);
+		(void) acpi_ut_delete_mutex (i);
 	}
 
 	return_VOID;
@@ -933,6 +1145,10 @@
 				source_object->common.type = ACPI_TYPE_INTEGER;
 				source_object->integer.value = ACPI_INTEGER_MAX;
 				break;
+
+			default:
+				/* Other types not supported */
+				return (AE_SUPPORT);
 			}
 		}
 		break;
@@ -945,6 +1161,9 @@
 		info->num_packages++;
 		state->pkg.this_target_obj = NULL;
 		break;
+
+	default:
+		return (AE_BAD_PARAMETER);
 	}
 
 	return (AE_OK);
@@ -1040,7 +1259,7 @@
 		 *    case below.
 		 */
 		if ((!this_source_obj) ||
-			(ACPI_GET_DESCRIPTOR_TYPE (this_source_obj) != ACPI_DESC_TYPE_INTERNAL) ||
+			(ACPI_GET_DESCRIPTOR_TYPE (this_source_obj) != ACPI_DESC_TYPE_OPERAND) ||
 			(this_source_obj->common.type != ACPI_TYPE_PACKAGE)) {
 			status = walk_callback (ACPI_COPY_TYPE_SIMPLE, this_source_obj,
 					 state, context);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utobject.c linux/drivers/acpi/utilities/utobject.c
--- ../prev/linux/drivers/acpi/utilities/utobject.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utobject.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: utobject - ACPI object create/delete/size/cache routines
- *              $Revision: 68 $
+ *              $Revision: 73 $
  *
  *****************************************************************************/
 
@@ -25,9 +25,7 @@
 
 
 #include "acpi.h"
-#include "acinterp.h"
 #include "acnamesp.h"
-#include "actables.h"
 #include "amlcode.h"
 
 
@@ -97,6 +95,10 @@
 
 		object->common.next_object = second_object;
 		break;
+
+	default:
+		/* All others have no secondary object */
+		break;
 	}
 
 	/* Save the object type in the object descriptor */
@@ -142,7 +144,7 @@
 	/* Check the descriptor type field */
 
 	switch (ACPI_GET_DESCRIPTOR_TYPE (object)) {
-	case ACPI_DESC_TYPE_INTERNAL:
+	case ACPI_DESC_TYPE_OPERAND:
 
 		/* The object appears to be a valid acpi_operand_object  */
 
@@ -210,10 +212,10 @@
 
 	/* Mark the descriptor type */
 
-	ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_INTERNAL);
+	ACPI_SET_DESCRIPTOR_TYPE (object, ACPI_DESC_TYPE_OPERAND);
 
 	ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p Size %X\n",
-			object, sizeof (acpi_operand_object)));
+			object, (u32) sizeof (acpi_operand_object)));
 
 	return_PTR (object);
 }
@@ -240,7 +242,7 @@
 
 	/* Object must be an acpi_operand_object  */
 
-	if (ACPI_GET_DESCRIPTOR_TYPE (object) != ACPI_DESC_TYPE_INTERNAL) {
+	if (ACPI_GET_DESCRIPTOR_TYPE (object) != ACPI_DESC_TYPE_OPERAND) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR,
 			"Obj %p is not an ACPI object\n", object));
 		return_VOID;
@@ -337,13 +339,13 @@
 
 	case ACPI_TYPE_STRING:
 
-		length += internal_object->string.length + 1;
+		length += (ACPI_SIZE) internal_object->string.length + 1;
 		break;
 
 
 	case ACPI_TYPE_BUFFER:
 
-		length += internal_object->buffer.length;
+		length += (ACPI_SIZE) internal_object->buffer.length;
 		break;
 
 
@@ -461,6 +463,13 @@
 		info->num_packages++;
 		state->pkg.this_target_obj = NULL;
 		break;
+
+
+	default:
+
+		/* No other types allowed */
+
+		return (AE_BAD_PARAMETER);
 	}
 
 	return (status);
@@ -512,7 +521,7 @@
 	 * Round up to the next machine word.
 	 */
 	info.length += ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (acpi_object)) *
-			  info.num_packages;
+			  (ACPI_SIZE) info.num_packages;
 
 	/* Return the total package length */
 
@@ -546,7 +555,7 @@
 	ACPI_FUNCTION_ENTRY ();
 
 
-	if ((ACPI_GET_DESCRIPTOR_TYPE (internal_object) == ACPI_DESC_TYPE_INTERNAL) &&
+	if ((ACPI_GET_DESCRIPTOR_TYPE (internal_object) == ACPI_DESC_TYPE_OPERAND) &&
 		(internal_object->common.type == ACPI_TYPE_PACKAGE)) {
 		status = acpi_ut_get_package_object_size (internal_object, obj_length);
 	}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utilities/utxface.c linux/drivers/acpi/utilities/utxface.c
--- ../prev/linux/drivers/acpi/utilities/utxface.c	Tue Jul  9 18:04:01 2002
+++ linux/drivers/acpi/utilities/utxface.c	Fri May 31 11:41:58 2002
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Module Name: utxface - External interfaces for "global" ACPI functions
- *              $Revision: 92 $
+ *              $Revision: 96 $
  *
  *****************************************************************************/
 
@@ -26,15 +26,10 @@
 
 #include "acpi.h"
 #include "acevents.h"
-#include "achware.h"
 #include "acnamesp.h"
-#include "acinterp.h"
-#include "amlcode.h"
-#include "acdebug.h"
-#include "acexcep.h"
 #include "acparser.h"
 #include "acdispat.h"
-
+#include "acdebug.h"
 
 #define _COMPONENT          ACPI_UTILITIES
 	 ACPI_MODULE_NAME    ("utxface")
@@ -102,7 +97,7 @@
 
 	/* If configured, initialize the AML debugger */
 
-	ACPI_DEBUGGER_EXEC (acpi_db_initialize ());
+	ACPI_DEBUGGER_EXEC (status = acpi_db_initialize ());
 
 	return_ACPI_STATUS (status);
 }
@@ -139,7 +134,7 @@
 	if (!(flags & ACPI_NO_ADDRESS_SPACE_INIT)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Installing default address space handlers\n"));
 
-		status = acpi_ev_install_default_address_space_handlers ();
+		status = acpi_ev_init_address_spaces ();
 		if (ACPI_FAILURE (status)) {
 			return_ACPI_STATUS (status);
 		}
@@ -251,6 +246,9 @@
 acpi_status
 acpi_terminate (void)
 {
+	acpi_status         status;
+
+
 	ACPI_FUNCTION_TRACE ("Acpi_terminate");
 
 
@@ -277,10 +275,8 @@
 
 	/* Now we can shutdown the OS-dependent layer */
 
-	acpi_os_terminate ();
-
-
-	return_ACPI_STATUS (AE_OK);
+	status = acpi_os_terminate ();
+	return_ACPI_STATUS (status);
 }
 
 
@@ -396,6 +392,39 @@
 	}
 
 	return_ACPI_STATUS (AE_OK);
+}
+
+
+/*****************************************************************************
+ *
+ * FUNCTION:    Acpi_install_initialization_handler
+ *
+ * PARAMETERS:  Handler             - Callback procedure
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install an initialization handler
+ *
+ * TBD: When a second function is added, must save the Function also.
+ *
+ ****************************************************************************/
+
+acpi_status
+acpi_install_initialization_handler (
+	ACPI_INIT_HANDLER       handler,
+	u32                     function)
+{
+
+	if (!handler) {
+		return (AE_BAD_PARAMETER);
+	}
+
+	if (acpi_gbl_init_handler) {
+		return (AE_ALREADY_EXISTS);
+	}
+
+	acpi_gbl_init_handler = handler;
+	return AE_OK;
 }
 
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/acpi/utils.c linux/drivers/acpi/utils.c
--- ../prev/linux/drivers/acpi/utils.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/utils.c	Fri May 31 11:41:56 2002
@@ -0,0 +1,460 @@
+/*
+ *  acpi_utils.c - ACPI Utility Functions ($Revision: 5 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include "acpi_bus.h"
+#include "acpi_drivers.h"
+
+
+#define _COMPONENT		ACPI_BUS_COMPONENT
+ACPI_MODULE_NAME		("acpi_utils")
+
+
+/* --------------------------------------------------------------------------
+                            Object Evaluation Helpers
+   -------------------------------------------------------------------------- */
+
+#ifdef ACPI_DEBUG
+#define acpi_util_eval_error(h,p,s) {\
+	char prefix[80] = {'\0'};\
+	acpi_buffer buffer = {sizeof(prefix), prefix};\
+	acpi_get_name(h, ACPI_FULL_PATHNAME, &buffer);\
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Evaluate [%s.%s]: %s\n",\
+		(char *) prefix, p, acpi_format_exception(s))); }
+#else
+#define acpi_util_eval_error(h,p,s)
+#endif
+
+
+acpi_status
+acpi_extract_package (
+	acpi_object		*package,
+	acpi_buffer		*format,
+	acpi_buffer		*buffer)
+{
+	u32			size_required = 0;
+	u32			tail_offset = 0;
+	char			*format_string = NULL;
+	u32			format_count = 0;
+	u32			i = 0;
+	u8			*head = NULL;
+	u8			*tail = NULL;
+
+	ACPI_FUNCTION_TRACE("acpi_extract_package");
+
+	if (!package || (package->type != ACPI_TYPE_PACKAGE) || (package->package.count < 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'package' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!format || !format->pointer || (format->length < 1)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'format' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	if (!buffer) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid 'buffer' argument\n"));
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	format_count = (format->length/sizeof(char)) - 1;
+	if (format_count > package->package.count) {
+		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Format specifies more objects [%d] than exist in package [%d].", format_count, package->package.count));
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	format_string = (char*)format->pointer;
+
+	/*
+	 * Calculate size_required.
+	 */
+	for (i=0; i<format_count; i++) {
+
+		acpi_object *element = &(package->package.elements[i]);
+
+		if (!element) {
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		switch (element->type) {
+
+		case ACPI_TYPE_INTEGER:
+			switch (format_string[i]) {
+			case 'N':
+				size_required += sizeof(acpi_integer);
+				tail_offset += sizeof(acpi_integer);
+				break;
+			case 'S':
+				size_required += sizeof(char*) + sizeof(acpi_integer) + sizeof(char);
+				tail_offset += sizeof(char*);
+				break;
+			default:
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d]: got number, expecing [%c].\n", i, format_string[i]));
+				return_ACPI_STATUS(AE_BAD_DATA);
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+			switch (format_string[i]) {
+			case 'S':
+				size_required += sizeof(char*) + (element->string.length * sizeof(char)) + sizeof(char);
+				tail_offset += sizeof(char*);
+				break;
+			case 'B':
+				size_required += sizeof(u8*) + (element->buffer.length * sizeof(u8));
+				tail_offset += sizeof(u8*);
+				break;
+			default:
+				ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid package element [%d] got string/buffer, expecing [%c].\n", i, format_string[i]));
+				return_ACPI_STATUS(AE_BAD_DATA);
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+		default:
+			ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unsupported element at index=%d\n", i));
+			/* TBD: handle nested packages... */
+			return_ACPI_STATUS(AE_SUPPORT);
+			break;
+		}
+	}
+
+	/*
+	 * Validate output buffer.
+	 */
+	if (buffer->length < size_required) {
+		buffer->length = size_required;
+		return_ACPI_STATUS(AE_BUFFER_OVERFLOW);
+	}
+	else if (buffer->length != size_required || !buffer->pointer) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	head = buffer->pointer;
+	tail = buffer->pointer + tail_offset;
+
+	/*
+	 * Extract package data.
+	 */
+	for (i=0; i<format_count; i++) {
+
+		u8 **pointer = NULL;
+		acpi_object *element = &(package->package.elements[i]);
+
+		if (!element) {
+			return_ACPI_STATUS(AE_BAD_DATA);
+		}
+
+		switch (element->type) {
+
+		case ACPI_TYPE_INTEGER:
+			switch (format_string[i]) {
+			case 'N':
+				*((acpi_integer*)head) = element->integer.value;
+				head += sizeof(acpi_integer);
+				break;
+			case 'S':
+				pointer = (u8**)head;
+				*pointer = tail;
+				*((acpi_integer*)tail) = element->integer.value;
+				head += sizeof(acpi_integer*);
+				tail += sizeof(acpi_integer);
+				/* NULL terminate string */
+				*tail = (char)0;
+				tail += sizeof(char);
+				break;
+			default:
+				/* Should never get here */
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_STRING:
+		case ACPI_TYPE_BUFFER:
+			switch (format_string[i]) {
+			case 'S':
+				pointer = (u8**)head;
+				*pointer = tail;
+				memcpy(tail, element->string.pointer, element->string.length);
+				head += sizeof(char*);
+				tail += element->string.length * sizeof(char);
+				/* NULL terminate string */
+				*tail = (char)0;
+				tail += sizeof(char);
+				break;
+			case 'B':
+				pointer = (u8**)head;
+				*pointer = tail;
+				memcpy(tail, element->buffer.pointer, element->buffer.length);
+				head += sizeof(u8*);
+				tail += element->buffer.length * sizeof(u8);
+				break;
+			default:
+				/* Should never get here */
+				break;
+			}
+			break;
+
+		case ACPI_TYPE_PACKAGE:
+			/* TBD: handle nested packages... */
+		default:
+			/* Should never get here */
+			break;
+		}
+	}
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+acpi_status
+acpi_evaluate (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	acpi_object_list	*arguments,
+	acpi_buffer		*buffer)
+{
+	acpi_status		status = AE_OK;
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate");
+
+	/* If caller provided a buffer it must be unallocated/zero'd. */
+	if (buffer && (buffer->length != 0 || buffer->pointer))
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	/*
+	 * Evalute object. The first attempt is just to get the size of the
+	 * object data (that is unless there's no return data); the second
+	 * gets the data.
+	 */
+	status = acpi_evaluate_object(handle, pathname, arguments, buffer);
+
+	if (ACPI_SUCCESS(status)) {
+		return_ACPI_STATUS(status);
+	}
+
+	else if (buffer && (status == AE_BUFFER_OVERFLOW)) {
+
+		/* Gotta allocate - CALLER MUST FREE! */
+		buffer->pointer = kmalloc(buffer->length, GFP_KERNEL);
+		if (!buffer->pointer) {
+			return_ACPI_STATUS(AE_NO_MEMORY);
+		}
+		memset(buffer->pointer, 0, buffer->length);
+
+		/* Re-evaluate - this time it should work. */
+		status = acpi_evaluate_object(handle, pathname, arguments,
+			buffer);
+	}
+
+	if (ACPI_FAILURE(status)) {
+		if (status != AE_NOT_FOUND)
+			acpi_util_eval_error(handle, pathname, status);
+		if (buffer && buffer->pointer) {
+			kfree(buffer->pointer);
+			buffer->length = 0;
+		}
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+
+acpi_status
+acpi_evaluate_integer (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	acpi_object_list	*arguments,
+	unsigned long		*data)
+{
+	acpi_status             status = AE_OK;
+	acpi_object             element;
+	acpi_buffer		buffer = {sizeof(acpi_object), &element};
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_integer");
+
+	if (!data)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status)) {
+		acpi_util_eval_error(handle, pathname, status);
+		return_ACPI_STATUS(status);
+	}
+
+	if (element.type != ACPI_TYPE_INTEGER) {
+		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	*data = element.integer.value;
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%lu]\n", *data));
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+
+#if 0
+acpi_status
+acpi_evaluate_string (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	acpi_object_list	*arguments,
+	acpi_string		*data)
+{
+	acpi_status             status = AE_OK;
+	acpi_object             *element = NULL;
+	acpi_buffer		buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_string");
+
+	if (!data)
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+
+	status = acpi_evaluate_object(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status)) {
+		acpi_util_eval_error(handle, pathname, status);
+		return_ACPI_STATUS(status);
+	}
+
+	element = (acpi_object *) buffer.pointer;
+
+	if ((element->type != ACPI_TYPE_STRING) 
+		|| (element->type != ACPI_TYPE_BUFFER)
+		|| !element->string.length) {
+		acpi_util_eval_error(handle, pathname, AE_BAD_DATA);
+		return_ACPI_STATUS(AE_BAD_DATA);
+	}
+
+	*data = kmalloc(element->string.length + 1, GFP_KERNEL);
+	if (!data) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Memory allocation error\n"));
+		return_VALUE(-ENOMEM);
+	}
+	memset(*data, 0, element->string.length + 1);
+
+	memcpy(*data, element->string.pointer, element->string.length);
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Return value [%s]\n", *data));
+
+	return_ACPI_STATUS(AE_OK);
+}
+#endif
+
+
+acpi_status
+acpi_evaluate_reference (
+	acpi_handle		handle,
+	acpi_string		pathname,
+	acpi_object_list	*arguments,
+	struct acpi_handle_list	*list)
+{
+	acpi_status		status = AE_OK;
+	acpi_object		*package = NULL;
+	acpi_object		*element = NULL;
+	acpi_buffer		buffer = {0, NULL};
+	u32			i = 0;
+
+	ACPI_FUNCTION_TRACE("acpi_evaluate_reference");
+
+	if (!list) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Evaluate object. */
+
+	status = acpi_evaluate(handle, pathname, arguments, &buffer);
+	if (ACPI_FAILURE(status))
+		goto end;
+
+	package = (acpi_object *) buffer.pointer;
+
+	if (!package || (package->type != ACPI_TYPE_PACKAGE)
+		|| (package->package.count == 0)) {
+		status = AE_BAD_DATA;
+		acpi_util_eval_error(handle, pathname, status);
+		goto end;
+	}
+
+	/* Allocate list - CALLER MUST FREE! */
+	list->count = package->package.count;
+	if (list->count > 10) {
+		return AE_NO_MEMORY;
+	}
+	/* TBD: dynamically allocate */
+	/*
+	list->handles = kmalloc(sizeof(acpi_handle)*(list->count), GFP_KERNEL);
+	if (!list->handles) {
+		return_ACPI_STATUS(AE_NO_MEMORY);
+	}
+	memset(list->handles, 0, sizeof(acpi_handle)*(list->count));
+	*/
+
+	/* Parse package data. */
+
+	for (i = 0; i < list->count; i++) {
+
+		element = &(package->package.elements[i]);
+
+		if (!element || (element->type != ACPI_TYPE_STRING)) {
+			status = AE_BAD_DATA;
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Invalid element in package (not a device reference)\n"));
+			acpi_util_eval_error(handle, pathname, status);
+			break;
+		}
+
+		/* Convert reference (e.g. "\_PR_.CPU_") to acpi_handle. */
+
+		status = acpi_get_handle(handle, element->string.pointer,
+			&(list->handles[i]));
+		if (ACPI_FAILURE(status)) {
+			status = AE_BAD_DATA;
+			ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Unable to resolve device reference [%s]\n", element->string.pointer));
+			acpi_util_eval_error(handle, pathname, status);
+			break;
+		}
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Resolved reference [%s]->[%p]\n", element->string.pointer, list->handles[i]));
+	}
+
+end:
+	if (ACPI_FAILURE(status)) {
+		list->count = 0;
+		//kfree(list->handles);
+	}
+
+	kfree(buffer.pointer);
+
+	return_ACPI_STATUS(status);
+}
+
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/Config.in linux/drivers/char/Config.in
--- ../prev/linux/drivers/char/Config.in	Tue Jul  9 18:04:03 2002
+++ linux/drivers/char/Config.in	Thu May 30 15:06:04 2002
@@ -11,13 +11,16 @@
 tristate 'Standard/generic (8250/16550 and compatible UARTs) serial support' CONFIG_SERIAL
 if [ "$CONFIG_SERIAL" = "y" ]; then
    bool '  Support for console on serial port' CONFIG_SERIAL_CONSOLE
+   if [ "$CONFIG_IA64" = "y" ]; then
+      bool '  Support for serial console port described by EFI HCDP table' CONFIG_SERIAL_HCDP
+   fi
    if [ "$CONFIG_ARCH_ACORN" = "y" ]; then
-      tristate '   Atomwide serial port support' CONFIG_ATOMWIDE_SERIAL
-      tristate '   Dual serial port support' CONFIG_DUALSP_SERIAL
+      tristate '  Atomwide serial port support' CONFIG_ATOMWIDE_SERIAL
+      tristate '  Dual serial port support' CONFIG_DUALSP_SERIAL
    fi
 fi
 if [ "$CONFIG_ACPI" = "y" ]; then
-   bool '  Support for serial ports defined by ACPI tables' CONFIG_SERIAL_ACPI
+   bool '  Support for serial ports defined in ACPI namespace' CONFIG_SERIAL_ACPI
 fi
 dep_mbool 'Extended dumb serial driver options' CONFIG_SERIAL_EXTENDED $CONFIG_SERIAL
 if [ "$CONFIG_SERIAL_EXTENDED" = "y" ]; then
@@ -212,7 +215,8 @@
 if [ "$CONFIG_AGP" != "n" ]; then
    bool '  Intel 440LX/BX/GX and I815/I830M/I840/I850 support' CONFIG_AGP_INTEL
    if [ "$CONFIG_IA64" != "n" ]; then
-   	bool '  Intel 460GX support' CONFIG_AGP_I460
+      bool '  Intel 460GX support' CONFIG_AGP_I460
+      bool '  HP ZX1 AGP support' CONFIG_AGP_HP_ZX1
    fi
    bool '  Intel I810/I815/I830M (on-board) support' CONFIG_AGP_I810
    bool '  VIA chipset support' CONFIG_AGP_VIA
@@ -220,7 +224,6 @@
    bool '  Generic SiS support' CONFIG_AGP_SIS
    bool '  ALI chipset support' CONFIG_AGP_ALI
    bool '  Serverworks LE/HE support' CONFIG_AGP_SWORKS
-   dep_bool '  HP ZX1 AGP support' CONFIG_AGP_HP_ZX1 $CONFIG_IA64
 fi
 
 bool 'Direct Rendering Manager (XFree86 DRI support)' CONFIG_DRM
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/Makefile linux/drivers/char/Makefile
--- ../prev/linux/drivers/char/Makefile	Tue Jul  9 18:04:03 2002
+++ linux/drivers/char/Makefile	Wed May 29 13:45:32 2002
@@ -126,7 +126,7 @@
 
 obj-$(CONFIG_VT) += vt.o vc_screen.o consolemap.o consolemap_deftbl.o $(CONSOLE) selection.o
 obj-$(CONFIG_SERIAL) += $(SERIAL)
-obj-$(CONFIG_SERIAL_ACPI) += acpi_serial.o
+obj-$(CONFIG_SERIAL_HCDP) += hcdp_serial.o
 obj-$(CONFIG_SERIAL_21285) += serial_21285.o
 obj-$(CONFIG_SERIAL_SA1100) += serial_sa1100.o
 obj-$(CONFIG_SERIAL_AMBA) += serial_amba.o
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/acpi_serial.c linux/drivers/char/acpi_serial.c
--- ../prev/linux/drivers/char/acpi_serial.c	Fri Jan 25 13:11:15 2002
+++ linux/drivers/char/acpi_serial.c	Wed Dec 31 17:00:00 1969
@@ -1,203 +0,0 @@
-/*
- *  linux/drivers/char/acpi_serial.c
- *
- *  Copyright (C) 2000  Hewlett-Packard Co.
- *  Copyright (C) 2000  Khalid Aziz <khalid_aziz@hp.com>
- *
- *  Detect and initialize the headless console serial port defined in 
- *  SPCR table and debug serial port defined in DBGP table
- *
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/pm.h>
-#include <linux/acpi.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <asm/serial.h>
-#include <asm/io.h>
-#include <linux/acpi_serial.h>
-/*#include <asm/acpi-ext.h>*/
-
-#undef SERIAL_DEBUG_ACPI
-
-/*
- * Query ACPI tables for a debug and a headless console serial
- * port. If found, add them to rs_table[]. A pointer to either SPCR
- * or DBGP table is passed as parameter. This function should be called 
- * before serial_console_init() is called to make sure the SPCR serial 
- * console will be available for use. IA-64 kernel calls this function
- * from within acpi.c when it encounters SPCR or DBGP tables as it parses 
- * the ACPI 2.0 tables during bootup.
- *
- */
-void __init setup_serial_acpi(void *tablep) 
-{
-	acpi_ser_t *acpi_ser_p;
-	struct serial_struct serial_req;
-	unsigned long iobase;
-	int global_sys_irq;
-
-#ifdef SERIAL_DEBUG_ACPI
-	printk("Entering setup_serial_acpi()\n");
-#endif
-
-	/* Now get the table */
-	if (tablep == NULL) {
-		return;
-	}
-
-	acpi_ser_p = (acpi_ser_t *)tablep;
-
-	/*
-	 * Perform a sanity check on the table. Table should have a 
-	 * signature of "SPCR" or "DBGP" and it should be atleast 52 bytes
-	 * long.
-	 */
-	if ((strncmp(acpi_ser_p->signature, ACPI_SPCRT_SIGNATURE, 
-					ACPI_SIG_LEN) != 0) && 
-		(strncmp(acpi_ser_p->signature, ACPI_DBGPT_SIGNATURE, 
-					ACPI_SIG_LEN) != 0)) {
-		return;
-	}
-	if (acpi_ser_p->length < 52) {
-		return;
-	}
-
-	iobase = (((u64) acpi_ser_p->base_addr.addrh) << 32) | acpi_ser_p->base_addr.addrl;
-	global_sys_irq = (acpi_ser_p->global_int[3] << 24) | 
-			(acpi_ser_p->global_int[2] << 16) |
-			(acpi_ser_p->global_int[1] << 8) |
-			acpi_ser_p->global_int[0];
-
-#ifdef SERIAL_DEBUG_ACPI
-	printk("setup_serial_acpi(): table pointer = 0x%p\n", acpi_ser_p);
-	printk("                     sig = '%c%c%c%c'\n",
-			acpi_ser_p->signature[0],
-			acpi_ser_p->signature[1],
-			acpi_ser_p->signature[2],
-			acpi_ser_p->signature[3]);
-	printk("                     length = %d\n", acpi_ser_p->length);
-	printk("                     Rev = %d\n", acpi_ser_p->rev);
-	printk("                     Interface type = %d\n", acpi_ser_p->intfc_type);
-	printk("                     Base address = 0x%lX\n", iobase);
-	printk("                     IRQ = %d\n", acpi_ser_p->irq);
-	printk("                     Global System Int = %d\n", global_sys_irq);
-	printk("                     Baud rate = ");
-	switch (acpi_ser_p->baud) {
-		case ACPI_SERIAL_BAUD_9600:
-			printk("9600\n");
-			break;
-
-		case ACPI_SERIAL_BAUD_19200:
-			printk("19200\n");
-			break;
-
-		case ACPI_SERIAL_BAUD_57600:
-			printk("57600\n");
-			break;
-
-		case ACPI_SERIAL_BAUD_115200:
-			printk("115200\n");
-			break;
-
-		default:
-			printk("Huh (%d)\n", acpi_ser_p->baud);
-			break;
-
-	}
-	if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_PCICONF_SPACE) {
-		printk("                     PCI serial port:\n");
-		printk("                         Bus %d, Device %d, Vendor ID 0x%x, Dev ID 0x%x\n",
-		acpi_ser_p->pci_bus, acpi_ser_p->pci_dev,
-		acpi_ser_p->pci_vendor_id, acpi_ser_p->pci_dev_id);
-	}
-#endif
-
-	/* 
-	 * Now build a serial_req structure to update the entry in
-	 * rs_table for the headless console port.
-	 */
-	switch (acpi_ser_p->intfc_type) {
- 		case ACPI_SERIAL_INTFC_16550:
-			serial_req.type = PORT_16550;
-			serial_req.baud_base = BASE_BAUD;
-			break;
-
- 		case ACPI_SERIAL_INTFC_16450:
-			serial_req.type = PORT_16450;
-			serial_req.baud_base = BASE_BAUD;
-			break;
-
-		default:
-			serial_req.type = PORT_UNKNOWN;
-			break;
-	}
-	if (strncmp(acpi_ser_p->signature, ACPI_SPCRT_SIGNATURE,
-					ACPI_SIG_LEN) == 0) {
-		serial_req.line = ACPI_SERIAL_CONSOLE_PORT;
-	}
-	else if (strncmp(acpi_ser_p->signature, ACPI_DBGPT_SIGNATURE, 
-					ACPI_SIG_LEN) == 0) {
-		serial_req.line = ACPI_SERIAL_DEBUG_PORT;
-	}
-	/*
-	 * Check if this is an I/O mapped address or a memory mapped address
-	 */
-	if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_MEM_SPACE) {
-		serial_req.port = 0;
-		serial_req.port_high = 0;
-		serial_req.iomem_base = (void *)ioremap(iobase, 64);
-		serial_req.io_type = SERIAL_IO_MEM;
-	}
-	else if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_IO_SPACE) {
-		serial_req.port = (unsigned long) iobase & 0xffffffff;
-		serial_req.port_high = (unsigned long)(((u64)iobase) >> 32);
-		serial_req.iomem_base = NULL;
-		serial_req.io_type = SERIAL_IO_PORT;
-	}
-	else if (acpi_ser_p->base_addr.space_id == ACPI_SERIAL_PCICONF_SPACE) {
-		printk("WARNING: No support for PCI serial console\n");
-		return;
-	}
-
-	/*
-	 * If the table does not have IRQ information, use 0 for IRQ. 
-	 * This will force rs_init() to probe for IRQ. 
-	 */
-	if (acpi_ser_p->length < 53) {
-		serial_req.irq = 0;
-	}
-	else {
-		serial_req.flags = ASYNC_SKIP_TEST | ASYNC_BOOT_AUTOCONF | 
-					ASYNC_AUTO_IRQ;
-		if (acpi_ser_p->int_type & 
-			(ACPI_SERIAL_INT_APIC | ACPI_SERIAL_INT_SAPIC)) {
-			serial_req.irq = global_sys_irq;
-		}
-		else if (acpi_ser_p->int_type & ACPI_SERIAL_INT_PCAT) {
-			serial_req.irq = acpi_ser_p->irq;
-		}
-		else {
-			/*
-			 * IRQ type not being set would mean UART will
-			 * run in polling mode. Do not probe for IRQ in
-			 * that case.
-			 */
-			serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF;
-		}
-	}
-
-	serial_req.xmit_fifo_size = serial_req.custom_divisor = 0;
-	serial_req.close_delay = serial_req.hub6 = serial_req.closing_wait = 0;
-	serial_req.iomem_reg_shift = 0;
-	if (early_serial_setup(&serial_req) < 0) {
-		printk("early_serial_setup() for ACPI serial console port failed\n");
-		return;
-	}
-
-#ifdef SERIAL_DEBUG_ACPI
-	printk("Leaving setup_serial_acpi()\n");
-#endif
-}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/agp/agpgart_be.c linux/drivers/char/agp/agpgart_be.c
--- ../prev/linux/drivers/char/agp/agpgart_be.c	Tue Jul  9 18:04:05 2002
+++ linux/drivers/char/agp/agpgart_be.c	Wed May 15 10:15:08 2002
@@ -309,11 +309,7 @@
 		pte_t *pte;
 
 		vmblock = __vmalloc(page_count << PAGE_SHIFT, GFP_KERNEL,
-#ifdef __ia64__
-					pgprot_writecombine(PAGE_KERNEL));
-#else
 					PAGE_KERNEL);
-#endif
 		if(vmblock == NULL) {
 			MOD_DEC_USE_COUNT;
 			return NULL;
@@ -569,8 +565,18 @@
 	 *        command registers.
 	 */
 
-	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
-					device)) != NULL) {
+
+	pci_for_each_dev(device)
+	{
+		/*
+		 *	Enable AGP devices. Most will be VGA display but
+		 *	some may be coprocessors on non VGA devices too
+		 */
+		 
+		if((((device->class >> 16) & 0xFF) != PCI_BASE_CLASS_DISPLAY) &&
+			(device->class != (PCI_CLASS_PROCESSOR_CO << 8)))
+			continue;
+
 		pci_read_config_dword(device, 0x04, &scratch);
 
 		if (!(scratch & 0x00100000))
@@ -1477,10 +1483,6 @@
 
 #endif /* CONFIG_AGP_I810 */
  
- #ifdef CONFIG_AGP_INTEL
-
-#endif /* CONFIG_AGP_I810 */
-
 #ifdef CONFIG_AGP_I460
 
 /* BIOS configures the chipset so that one of two apbase registers are used */
@@ -1756,10 +1758,14 @@
 		j++;
 	}
 
+#if 0
+	/* not necessary since 460 GART is operated in coherent mode... */
+
 	if (mem->is_flushed == FALSE) {
 		CACHE_FLUSH();
 		mem->is_flushed = TRUE;
 	}
+#endif
 
 	for (i = 0, j = pg_start; i < mem->page_count; i++) {
 
@@ -1923,10 +1929,13 @@
 		}
 	}
 		
+#if 0
+	/* not necessary since 460 GART is operated in coherent mode... */
 	if (mem->is_flushed == FALSE) {
 		CACHE_FLUSH();
 		mem->is_flushed = TRUE;
 	}
+#endif
 
 	for(pg = start_pg, i = 0; pg <= end_pg; pg++)
 	{
@@ -2040,7 +2049,7 @@
 static gatt_mask intel_i460_masks[] =
 {
 	{ 
-	  INTEL_I460_GATT_VALID, 
+	  INTEL_I460_GATT_VALID | INTEL_I460_GATT_COHERENT,
 	  0
 	}
 };
@@ -4117,8 +4126,18 @@
 	 *        command registers.
 	 */
 
-	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
-					device)) != NULL) {
+
+	pci_for_each_dev(device)
+	{
+		/*
+		 *	Enable AGP devices. Most will be VGA display but
+		 *	some may be coprocessors on non VGA devices too
+		 */
+		 
+		if((((device->class >> 16) & 0xFF) != PCI_BASE_CLASS_DISPLAY) &&
+			(device->class != (PCI_CLASS_PROCESSOR_CO << 8)))
+			continue;
+
 		pci_read_config_dword(device, 0x04, &scratch);
 
 		if (!(scratch & 0x00100000))
@@ -4214,6 +4233,10 @@
 
 #ifdef CONFIG_AGP_HP_ZX1
 
+#ifdef CONFIG_IA64_HP_PROTO
+#include <asm/efi.h>
+#endif
+
 #ifndef log2
 #define log2(x)		ffz(~(x))
 #endif
@@ -4232,11 +4255,6 @@
 	{0, 0, 0},		/* filled in by hp_zx1_fetch_size() */
 };
 
-static gatt_mask hp_zx1_masks[] =
-{
-	{HP_ZX1_PDIR_VALID_BIT, 0}
-};
-
 static struct _hp_private {
 	struct pci_dev *ioc;
 	volatile u8 *registers;
@@ -4252,6 +4270,7 @@
 	int io_tlb_shift;
 	int io_tlb_ps;		// IOC ps config
 	int io_pages_per_kpage;
+	u8 ioc_rev;
 } hp_private;
 
 static int __init hp_zx1_ioc_shared(void)
@@ -4302,7 +4321,7 @@
 	return 0;
 }
 
-static int __init hp_zx1_ioc_owner(u8 ioc_rev)
+static int __init hp_zx1_ioc_owner(void)
 {
 	struct _hp_private *hp = &hp_private;
 
@@ -4329,6 +4348,15 @@
 
 	hp->iova_base = HP_ZX1_IOVA_BASE;
 	hp->gart_size = HP_ZX1_GART_SIZE;
+#ifdef CONFIG_IA64_HP_PROTO
+	if (hp->ioc_rev < 0x20) {
+		printk(KERN_WARNING PFX "WARNING: SBA rev 2.x or newer will "
+			"be required for GART support in the future\n");
+		hp->iova_base = 0;
+		hp->gart_size = HP_ZX1_GART_SIZE / 2;
+	}
+#endif
+
 	hp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - hp->gart_size;
 
 	hp->gatt_entries = hp->gart_size / hp->io_page_size;
@@ -4342,7 +4370,6 @@
 	struct _hp_private *hp = &hp_private;
 	struct pci_dev *ioc;
 	int i;
-	u8 ioc_rev;
 
 	ioc = pci_find_device(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_ZX1_IOC, NULL);
 	if (!ioc) {
@@ -4351,7 +4378,7 @@
 	}
 	hp->ioc = ioc;
 
-	pci_read_config_byte(ioc, PCI_REVISION_ID, &ioc_rev);
+	pci_read_config_byte(ioc, PCI_REVISION_ID, &hp->ioc_rev);
 
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		if (pci_resource_flags(ioc, i) == IORESOURCE_MEM) {
@@ -4373,8 +4400,27 @@
 	 */
 	hp->io_pdir_owner = (INREG64(hp->registers, HP_ZX1_IBASE) & 0x1) == 0;
 
+#ifdef CONFIG_IA64_HP_PROTO
+	if (hp->ioc_rev < 0x20) {
+		if (hp->io_pdir_owner) {
+			printk(KERN_ERR PFX "SBA 1.x without sba_iommu; "
+				"GART disabled\n");
+			return -ENODEV;
+		}
+	} else {
+		printk(KERN_INFO PFX "SBA 2.x or newer\n");
+		if (hp->io_pdir_owner &&
+		    efi_mem_type(HP_ZX1_IOVA_BASE) == EFI_CONVENTIONAL_MEMORY) {
+			printk(KERN_ERR PFX "SBA 2.x without sba_iommu "
+				"and memory at 0x%lx; GART disabled\n",
+				HP_ZX1_IOVA_BASE);
+			return -ENODEV;
+		}
+	}
+#endif
+
 	if (hp->io_pdir_owner)
-		return hp_zx1_ioc_owner(ioc_rev);
+		return hp_zx1_ioc_owner();
 
 	return hp_zx1_ioc_shared();
 }
@@ -4448,6 +4494,22 @@
 		memset(hp->io_pdir, 0, hp->io_pdir_size);
 
 		hp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];
+
+#ifdef CONFIG_IA64_HP_PROTO
+		if (hp->ioc_rev < 0x20) {
+			int i, entries;
+			u64 *pdir, io_addr;
+
+			printk(KERN_INFO PFX "identity-mapping IOVA space "
+				"(1.x SBA)\n");
+			pdir = hp->io_pdir;
+			entries = HP_ZX1_IOVA_SIZE / hp->io_page_size;
+			io_addr = hp->iova_base;
+			for (i = 0; i < entries; i++, io_addr += hp->io_page_size) {
+				*pdir++ = HP_ZX1_PDIR_VALID_BIT | io_addr;
+			}
+		}
+#endif
 	}
 
 	for (i = 0; i < hp->gatt_entries; i++) {
@@ -4494,10 +4556,13 @@
 		j++;
 	}
 
+#if 0
+	/* Not necessary since zx1 agp is coherent */
 	if (mem->is_flushed == FALSE) {
 		CACHE_FLUSH();
 		mem->is_flushed = TRUE;
 	}
+#endif
 
 	for (i = 0, j = io_pg_start; i < mem->page_count; i++) {
 		unsigned long paddr;
@@ -4545,7 +4610,6 @@
 
 static int __init hp_zx1_setup (struct pci_dev *pdev)
 {
-	agp_bridge.masks = hp_zx1_masks;
 	agp_bridge.dev_private_data = NULL;
 	agp_bridge.size_type = FIXED_APER_SIZE;
 	agp_bridge.needs_scratch_page = FALSE;
@@ -5195,7 +5259,7 @@
 {
 	long memory, index, result;
 
-	memory = virt_to_phys(high_memory) >> 20;
+	memory = (num_physpages << PAGE_SHIFT) >> 20;
 	index = 1;
 
 	while ((memory > maxes_table[index].mem) &&
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/drm/drm_vm.h linux/drivers/char/drm/drm_vm.h
--- ../prev/linux/drivers/char/drm/drm_vm.h	Tue Jul  9 18:04:05 2002
+++ linux/drivers/char/drm/drm_vm.h	Mon Apr 29 17:17:12 2002
@@ -456,6 +456,7 @@
 	drm_map_list_t  *r_list;
 	unsigned long   offset  = 0;
 	struct list_head *list;
+	struct page 	*page;
 
 	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
 		  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
@@ -511,17 +512,14 @@
                 	 * in nopage()
                 	 */
                 	vma->vm_ops = &DRM(vm_ops);
-#if defined(__ia64__)
-			vma->vm_page_prot =
-			                pgprot_writecombine(vma->vm_page_prot);
-#endif
 			goto mapswitch_out;
 		}
 #endif
                 /* fall through to _DRM_FRAME_BUFFER... */        
 	case _DRM_FRAME_BUFFER:
 	case _DRM_REGISTERS:
-		if (VM_OFFSET(vma) >= __pa(high_memory)) {
+		page = virt_to_page(__va(VM_OFFSET(vma)));
+		if (!VALID_PAGE(page) || PageReserved(page)) {
 #if defined(__i386__)
 			if (boot_cpu_data.x86 > 3 && map->type != _DRM_AGP) {
 				pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/drm-4.0/vm.c linux/drivers/char/drm-4.0/vm.c
--- ../prev/linux/drivers/char/drm-4.0/vm.c	Tue Jul  9 18:04:05 2002
+++ linux/drivers/char/drm-4.0/vm.c	Mon Apr 29 17:17:12 2002
@@ -391,7 +391,6 @@
                  * in nopage()
                  */
                 vma->vm_ops = &drm_vm_ops;
-		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
                 break;
 #endif
 	case _DRM_FRAME_BUFFER:
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/hcdp_serial.c linux/drivers/char/hcdp_serial.c
--- ../prev/linux/drivers/char/hcdp_serial.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/char/hcdp_serial.c	Wed May 29 13:45:32 2002
@@ -0,0 +1,221 @@
+/*
+ *  linux/arch/ia64/kernel/hcdp_serial.c
+ *
+ *  Copyright (C) 2002  Hewlett-Packard Co.
+ *  Copyright (C) 2002  Khalid Aziz <khalid_aziz@hp.com>
+ *
+ *  Parse the EFI HCDP table to locate serial console and debug ports
+ *  and initialize them
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <asm/serial.h>
+#include <asm/io.h>
+#include <asm/efi.h>
+#include <linux/hcdp_serial.h>
+
+#undef SERIAL_DEBUG_HCDP
+
+extern struct serial_state rs_table[];
+extern int serial_nr_ports;
+
+/*
+ * Parse the HCDP table to find descriptions for headless console and 
+ * debug serial ports and add them to rs_table[]. A pointer to HCDP
+ * table is passed as parameter. This function should be called 
+ * before serial_console_init() is called to make sure the HCDP serial 
+ * console will be available for use. IA-64 kernel calls this function
+ * from setup_arch() after the EFI and ACPI tables have been parsed.
+ */
+void __init setup_serial_hcdp(void *tablep) 
+{
+	hcdp_t hcdp;
+	hcdp_dev_t *hcdp_dev;
+	struct serial_struct serial_req;
+	unsigned long iobase;
+	int global_sys_irq;
+	int i, nr;
+	int shift_once = 1;
+
+#ifdef SERIAL_DEBUG_HCDP
+	printk("Entering setup_serial_hcdp()\n");
+#endif
+
+	/* Verify we have a valid table pointer */
+	if (tablep == NULL) {
+		return;
+	}
+
+	/*
+	 * We do not trust firmware to give us a table starting at an
+	 * aligned address. Make a local copy of the HCDP table with 
+	 * aligned structures.
+	 */
+	memcpy(&hcdp, tablep, sizeof(hcdp));
+
+	/*
+	 * Perform a sanity check on the table. Table should have a 
+	 * signature of "HCDP" and it should be atleast 82 bytes
+	 * long to have any useful information.
+	 */
+	if ((strncmp(hcdp.signature, HCDP_SIGNATURE, 
+					HCDP_SIG_LEN) != 0)) {
+		return;
+	}
+	if (hcdp.len < 82) {
+		return;
+	}
+
+#ifdef SERIAL_DEBUG_HCDP
+	printk("setup_serial_hcdp(): table pointer = 0x%p\n", tablep);
+	printk("                     sig = '%c%c%c%c'\n",
+			hcdp.signature[0],
+			hcdp.signature[1],
+			hcdp.signature[2],
+			hcdp.signature[3]);
+	printk("                     length = %d\n", hcdp.len);
+	printk("                     Rev = %d\n", hcdp.rev);
+	printk("                     OEM ID = %c%c%c%c%c%c\n", 
+			hcdp.oemid[0], hcdp.oemid[1], hcdp.oemid[2],
+			hcdp.oemid[3], hcdp.oemid[4], hcdp.oemid[5]);
+	printk("                     Number of entries = %d\n", hcdp.num_entries);
+#endif
+
+	/*
+	 * Parse each device entry
+	 */
+	for (nr=0; nr<hcdp.num_entries; nr++) {
+		hcdp_dev = &(hcdp.hcdp_dev[nr]);
+
+		/*
+		 * We will parse only the primary console device
+		 * which is the first entry for these devices. We will
+		 * ignore rest of the entries for the same type device that
+		 * has already been parsed and initialized
+		 */
+		if (hcdp_dev->type != HCDP_DEV_CONSOLE)
+			continue;
+
+		iobase = (u64)(hcdp_dev->base_addr.addrhi)<<32 | hcdp_dev->base_addr.addrlo;
+		global_sys_irq = hcdp_dev->global_int;
+#ifdef SERIAL_DEBUG_HCDP
+		printk("                 type = %s\n", 
+			((hcdp_dev->type == HCDP_DEV_CONSOLE)?"Headless Console":((hcdp_dev->type == HCDP_DEV_DEBUG)?"Debug port":"Huh????")));
+		printk("                 Base address space = %s\n", ((hcdp_dev->base_addr.space_id == ACPI_MEM_SPACE)?"Memory Space":((hcdp_dev->base_addr.space_id == ACPI_IO_SPACE)?"I/O space":"PCI space")));
+		printk("                 Base address = 0x%p\n", iobase);
+		printk("                 Global System Int = %d\n", global_sys_irq);
+		printk("                 Baud rate = %d\n", hcdp_dev->baud);
+		printk("                 Bits = %d\n", hcdp_dev->bits);
+		printk("                 Clock rate = %d\n", hcdp_dev->clock_rate);
+		if (hcdp_dev->base_addr.space_id == ACPI_PCICONF_SPACE) {
+			printk("                     PCI serial port:\n");
+			printk("                         Bus %d, Device %d, Vendor ID 0x%x, Dev ID 0x%x\n",
+			hcdp_dev->pci_bus, hcdp_dev->pci_dev,
+			hcdp_dev->pci_vendor_id, hcdp_dev->pci_dev_id);
+		}
+#endif
+
+
+		/* 
+	 	* Now build a serial_req structure to update the entry in
+	 	* rs_table for the headless console port.
+	 	*/
+		if (hcdp_dev->clock_rate)
+			serial_req.baud_base = hcdp_dev->clock_rate;
+		else
+			serial_req.baud_base = DEFAULT_BAUD_BASE;
+		/*
+	 	* Check if this is an I/O mapped address or a memory mapped address
+	 	*/
+		if (hcdp_dev->base_addr.space_id == ACPI_MEM_SPACE) {
+			serial_req.port = 0;
+			serial_req.port_high = 0;
+			serial_req.iomem_base = (void *)ioremap(iobase, 64);
+			serial_req.io_type = SERIAL_IO_MEM;
+		}
+		else if (hcdp_dev->base_addr.space_id == ACPI_IO_SPACE) {
+			serial_req.port = (unsigned long) iobase & 0xffffffff;
+			serial_req.port_high = (unsigned long)(((u64)iobase) >> 32);
+			serial_req.iomem_base = NULL;
+			serial_req.io_type = SERIAL_IO_PORT;
+		}
+		else if (hcdp_dev->base_addr.space_id == ACPI_PCICONF_SPACE) {
+			printk("WARNING: No support for PCI serial console\n");
+			return;
+		}
+
+		/*
+		 * Check if HCDP defines a port already in rs_table
+		 */
+		for (i = 0; i < serial_nr_ports; i++) {
+			if ((rs_table[i].port == serial_req.port) &&
+				(rs_table[i].iomem_base==serial_req.iomem_base))
+				break;
+		}
+		if (i == serial_nr_ports) {
+			/*
+			 * We have reserved a slot for HCDP defined console
+			 * port at HCDP_SERIAL_CONSOLE_PORT in rs_table
+			 * which is not 0. This means using this slot would
+			 * put the console at a device other than ttyS0. 
+			 * Users expect to see the console at ttyS0. Now 
+			 * that we have determined HCDP does describe a 
+			 * serial console and it is not one of the compiled
+			 * in ports, let us move the entries in rs_table
+			 * up by a slot towards HCDP_SERIAL_CONSOLE_PORT to 
+			 * make room for the HCDP console at ttyS0. We may go
+			 * through this loop more than once if 
+			 * early_serial_setup() fails. Make sure we shift the
+			 * entries in rs_table only once.
+			 */
+			if (shift_once) {
+				int j;
+
+				for (j=HCDP_SERIAL_CONSOLE_PORT; j>0; j--)
+					memcpy(rs_table+j, rs_table+j-1, 
+						sizeof(struct serial_state));
+				shift_once = 0;
+			}
+			serial_req.line = 0;
+		}
+		else
+			serial_req.line = i;
+
+		/*
+	 	* If the table does not have IRQ information, use 0 for IRQ. 
+	 	* This will force rs_init() to probe for IRQ. 
+	 	*/
+		serial_req.irq = global_sys_irq;
+		if (global_sys_irq == 0) {
+			serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF;
+		}
+		else {
+			serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF|
+						ASYNC_AUTO_IRQ;
+		}
+
+		serial_req.xmit_fifo_size = serial_req.custom_divisor = 0;
+		serial_req.close_delay = serial_req.hub6 = serial_req.closing_wait = 0;
+		serial_req.iomem_reg_shift = 0;
+		if (early_serial_setup(&serial_req) < 0) {
+			printk("setup_serial_hcdp(): early_serial_setup() for HCDP serial console port failed. Will try any additional consoles in HCDP.\n");
+			continue;
+		}
+		else
+			if (hcdp_dev->type == HCDP_DEV_CONSOLE)
+				break;
+#ifdef SERIAL_DEBUG_HCDP
+		printk("\n");
+#endif
+	}
+
+#ifdef SERIAL_DEBUG_HCDP
+	printk("Leaving setup_serial_hcdp()\n");
+#endif
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/mem.c linux/drivers/char/mem.c
--- ../prev/linux/drivers/char/mem.c	Tue Jul  9 18:04:04 2002
+++ linux/drivers/char/mem.c	Fri Feb  8 07:42:53 2002
@@ -177,6 +177,11 @@
 		  test_bit(X86_FEATURE_CYRIX_ARR, &boot_cpu_data.x86_capability) ||
 		  test_bit(X86_FEATURE_CENTAUR_MCR, &boot_cpu_data.x86_capability) )
 	  && addr >= __pa(high_memory);
+#elif defined(__ia64__)
+	struct page *page;
+
+	page = virt_to_page(__va(addr));
+	return (!VALID_PAGE(page) || PageReserved(page));
 #else
 	return addr >= __pa(high_memory);
 #endif
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/char/serial.c linux/drivers/char/serial.c
--- ../prev/linux/drivers/char/serial.c	Tue Jul  9 18:04:04 2002
+++ linux/drivers/char/serial.c	Tue Jun  4 09:07:06 2002
@@ -87,9 +87,8 @@
  * 		ever possible.
  *
  * CONFIG_SERIAL_ACPI
- *		Enable support for serial console port and serial 
- *		debug port as defined by the SPCR and DBGP tables in 
- *		ACPI 2.0.
+ *		Enable support for serial ports found in the ACPI
+ *		namespace.
  */
 
 #include <linux/config.h>
@@ -217,6 +216,10 @@
 #ifdef CONFIG_MAGIC_SYSRQ
 #include <linux/sysrq.h>
 #endif
+#ifdef ENABLE_SERIAL_ACPI
+#include <linux/acpi.h>
+#include "../acpi/acpi_bus.h"
+#endif
 
 /*
  * All of the compatibilty code so we can compile serial.c against
@@ -321,11 +324,12 @@
 MODULE_PARM_DESC(force_rsa, "Force I/O ports for RSA");
 #endif /* CONFIG_SERIAL_RSA  */
 
-static struct serial_state rs_table[RS_TABLE_SIZE] = {
+struct serial_state rs_table[RS_TABLE_SIZE] = {
 	SERIAL_PORT_DFNS	/* Defined in serial.h */
 };
 
 #define NR_PORTS	(sizeof(rs_table)/sizeof(struct serial_state))
+int serial_nr_ports = NR_PORTS;
 
 #if (defined(ENABLE_SERIAL_PCI) || defined(ENABLE_SERIAL_PNP))
 #define NR_PCI_BOARDS	8
@@ -2133,6 +2137,7 @@
 	if (new_serial.type) {
 		for (i = 0 ; i < NR_PORTS; i++)
 			if ((state != &rs_table[i]) &&
+			    (rs_table[i].io_type == SERIAL_IO_PORT) &&
 			    (rs_table[i].port == new_port) &&
 			    rs_table[i].type)
 				return -EADDRINUSE;
@@ -2195,7 +2200,7 @@
 
 	
 check_and_exit:
-	if (!state->port || !state->type)
+	if ((!state->port && !state->iomem_base) || !state->type)
 		return 0;
 	if (info->flags & ASYNC_INITIALIZED) {
 		if (((old_state.flags & ASYNC_SPD_MASK) !=
@@ -3251,7 +3256,9 @@
 		      state->line, uart_config[state->type].name, 
 		      state->port, state->irq);
 
-	if (!state->port || (state->type == PORT_UNKNOWN)) {
+	if ((state->type == PORT_UNKNOWN) ||
+	    (state->io_type == SERIAL_IO_PORT && !state->port) ||
+	    (state->io_type == SERIAL_IO_MEM && !state->iomem_base)) {
 		ret += sprintf(buf+ret, "\n");
 		return ret;
 	}
@@ -3912,6 +3919,25 @@
 		
 	}
   
+	/* HP's Diva chip puts the 4th/5th serial port further out, and
+	 * some serial ports are supposed to be hidden on certain models.
+	 */
+	if (dev->vendor == PCI_VENDOR_ID_HP &&
+			dev->device == PCI_DEVICE_ID_HP_SAS) {
+		switch (dev->subsystem_device) {
+		case 0x104B: /* Maestro */
+			if (idx == 3) idx++;
+			break;
+		case 0x1282: /* Everest / Longs Peak */
+			if (idx > 0) idx++;
+			if (idx > 2) idx++;
+			break;
+		}
+		if (idx > 2) {
+			offset = 0x18;
+		}
+	}
+
 	port =  pci_resource_start(dev, base_idx) + offset;
 
 	if ((board->flags & SPCI_FL_BASE_TABLE) == 0)
@@ -4215,6 +4241,40 @@
 	return 0;
 }
 
+/*
+ * HP's Remote Management Console.  The Diva chip came in several
+ * different versions.  N-class, L2000 and A500 have two Diva chips, each
+ * with 3 UARTs (the third UART on the second chip is unused).  Superdome
+ * and Keystone have one Diva chip with 3 UARTs.  Some later machines have
+ * one Diva chip, but it has been expanded to 5 UARTs.
+ */
+static int __devinit
+pci_hp_diva(struct pci_dev *dev, struct pci_board *board, int enable)
+{
+	if (!enable)
+		return 0;
+
+	switch (dev->subsystem_device) {
+	case 0x1049: /* Prelude Diva 1 */
+	case 0x1223: /* Superdome */
+	case 0x1226: /* Keystone */
+	case 0x1282: /* Everest / Longs Peak */
+		board->num_ports = 3;
+		break;
+	case 0x104A: /* Prelude Diva 2 */
+		board->num_ports = 2;
+		break;
+	case 0x104B: /* Maestro */
+		board->num_ports = 4;
+		break;
+	case 0x1227: /* Powerbar */
+		board->num_ports = 1;
+		break;
+	}
+
+	return 0;
+}
+
 static int __devinit
 pci_xircom_fn(struct pci_dev *dev, struct pci_board *board, int enable)
 {
@@ -4258,6 +4318,7 @@
 	pbn_b1_4_1382400,
 	pbn_b1_8_1382400,
 
+	pbn_b2_1_115200,
 	pbn_b2_8_115200,
 	pbn_b2_4_460800,
 	pbn_b2_8_460800,
@@ -4278,6 +4339,7 @@
 	pbn_timedia,
 	pbn_intel_i960,
 	pbn_sgi_ioc3,
+	pbn_hp_diva,
 #ifdef CONFIG_DDB5074
 	pbn_nec_nile4,
 #endif
@@ -4336,6 +4398,7 @@
 	{ SPCI_FL_BASE1, 4, 1382400 },		/* pbn_b1_4_1382400 */
 	{ SPCI_FL_BASE1, 8, 1382400 },		/* pbn_b1_8_1382400 */
 
+	{ SPCI_FL_BASE2, 1, 115200 },		/* pbn_b2_1_115200 */
 	{ SPCI_FL_BASE2, 8, 115200 },		/* pbn_b2_8_115200 */
 	{ SPCI_FL_BASE2, 4, 460800 },		/* pbn_b2_4_460800 */
 	{ SPCI_FL_BASE2, 8, 460800 },		/* pbn_b2_8_460800 */
@@ -4366,6 +4429,7 @@
 		8<<2, 2, pci_inteli960ni_fn, 0x10000},
 	{ SPCI_FL_BASE0 | SPCI_FL_IRQRESOURCE,		   /* pbn_sgi_ioc3 */
 		1, 458333, 0, 0, 0, 0x20178 },
+	{ SPCI_FL_BASE0, 5, 115200, 8, 0, pci_hp_diva, 0},   /* pbn_hp_diva */
 #ifdef CONFIG_DDB5074
 	/*
 	 * NEC Vrc-5074 (Nile 4) builtin UART.
@@ -4507,6 +4571,93 @@
 	}
 }
 
+#ifdef ENABLE_SERIAL_ACPI
+static int acpi_serial_add(struct acpi_device *device)
+{
+	acpi_status result;
+	acpi_buffer buffer;
+	struct serial_struct serial_req;
+	int line, offset = 0;
+
+	memset(&serial_req, 0, sizeof(serial_req));
+	buffer.length = 0;
+	buffer.pointer = NULL;
+	result = acpi_get_current_resources(device->handle, &buffer);
+	if (result != AE_BUFFER_OVERFLOW)
+		return -ENODEV;
+	buffer.pointer = kmalloc(buffer.length, GFP_KERNEL);
+	if (!buffer.pointer)
+		return -ENOMEM;
+	result = acpi_get_current_resources(device->handle, &buffer);
+	if (result != AE_OK) {
+		result = -ENODEV;
+		goto out;
+	}
+
+	while (offset <= buffer.length) {
+		acpi_resource *res = buffer.pointer + offset;
+		if (res->length == 0)
+			break;
+		offset += res->length;
+		if (res->id == ACPI_RSTYPE_ADDRESS32) {
+			acpi_resource_address32 *addr32 = &res->data.address32;
+			serial_req.iomem_base = ioremap(addr32->min_address_range, addr32->max_address_range - addr32->min_address_range + 1);
+			serial_req.io_type = SERIAL_IO_MEM;
+			serial_req.port = 0;
+			serial_req.port_high = 0;
+		} else if (res->id == ACPI_RSTYPE_EXT_IRQ) {
+			acpi_resource_ext_irq *ext_irq = &res->data.extended_irq;
+			if (ext_irq->number_of_interrupts > 0) {
+#ifdef CONFIG_IA64
+				serial_req.irq = acpi_register_irq(ext_irq->interrupts[0],
+				                  ext_irq->active_high_low == ACPI_ACTIVE_HIGH,
+				                  ext_irq->edge_level == ACPI_EDGE_SENSITIVE);
+#else
+				serial_req.irq = ext_irq->interrupts[0];
+#endif
+			}
+		}
+	}
+
+	serial_req.baud_base = BASE_BAUD;
+	serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF|ASYNC_AUTO_IRQ;
+	serial_req.xmit_fifo_size = serial_req.custom_divisor = 0;
+	serial_req.close_delay = serial_req.hub6 = serial_req.closing_wait = 0;
+	serial_req.iomem_reg_shift = 0;
+
+	result = 0;
+	line = register_serial(&serial_req);
+	if (line < 0)
+		result = -ENODEV;
+
+ out:
+	kfree(buffer.pointer);
+	return result;
+}
+
+static int acpi_serial_remove(struct acpi_device *device, int type)
+{
+	return 0;
+}
+
+static struct acpi_driver acpi_serial_driver = {
+	name:	"serial",
+	class:	"",
+	ids:	"PNP0501",
+	ops:	{
+			add:	acpi_serial_add,
+			remove:	acpi_serial_remove,
+		},
+};
+
+/*
+ * Look for serial ports in the ACPI namespace.
+ */
+static void __devinit probe_serial_acpi(void)
+{
+	acpi_bus_register_driver(&acpi_serial_driver);
+}
+#endif /* ENABLE_SERIAL_ACPI */
 
 static struct pci_device_id serial_pci_tbl[] __devinitdata = {
 	{	PCI_VENDOR_ID_V3, PCI_DEVICE_ID_V3_V960,
@@ -4864,6 +5015,14 @@
 		0xFF00, 0, 0, 0,
 		pbn_sgi_ioc3 },
 
+	/* HP Diva card */
+	{	PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_SAS,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		pbn_hp_diva },
+	{	PCI_VENDOR_ID_HP, 0x1290,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		pbn_b2_1_115200 },
+
 #ifdef CONFIG_DDB5074
 	/*
 	 * NEC Vrc-5074 (Nile 4) builtin UART.
@@ -5455,7 +5614,17 @@
 	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
 		state->magic = SSTATE_MAGIC;
 		state->line = i;
+#if defined(CONFIG_IA64_HP_PROTO)
+		{
+			extern int acpi_autoconf_flag;
+			if (acpi_autoconf_flag)
+				state->type = PORT_UNKNOWN;
+			else
+				state->irq = 0;
+		}
+#else
 		state->type = PORT_UNKNOWN;
+#endif
 		state->custom_divisor = 0;
 		state->close_delay = 5*HZ/10;
 		state->closing_wait = 30*HZ;
@@ -5486,7 +5655,7 @@
 		    && (state->port != 0 || state->iomem_base != 0))
 			state->irq = detect_uart_irq(state);
 		if (state->io_type == SERIAL_IO_MEM) {
-			printk(KERN_INFO"ttyS%02d%s at 0x%px (irq = %d) is a %s\n",
+			printk(KERN_INFO"ttyS%02d%s at 0x%p (irq = %d) is a %s\n",
 	 		       state->line + SERIAL_DEV_OFFSET,
 			       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
 			       state->iomem_base, state->irq,
@@ -5504,11 +5673,14 @@
 		tty_register_devfs(&callout_driver, 0,
 				   callout_driver.minor_start + state->line);
 	}
+#ifdef ENABLE_SERIAL_ACPI
+	probe_serial_acpi();
+#endif
 #ifdef ENABLE_SERIAL_PCI
 	probe_serial_pci();
 #endif
 #ifdef ENABLE_SERIAL_PNP
-       probe_serial_pnp();
+	probe_serial_pnp();
 #endif
 	return 0;
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/linux_compat.h linux/drivers/message/fusion/linux_compat.h
--- ../prev/linux/drivers/message/fusion/linux_compat.h	Tue Jul  9 18:04:12 2002
+++ linux/drivers/message/fusion/linux_compat.h	Tue Jun  4 15:09:10 2002
@@ -21,6 +21,20 @@
 #define SET_NICE(current,x)
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+#define pci_enable_device(pdev)	(0)
+#define SCSI_DATA_UNKNOWN	0
+#define SCSI_DATA_WRITE		1
+#define SCSI_DATA_READ		2
+#define SCSI_DATA_NONE		3
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,4)
+#define pci_set_dma_mask(pdev, mask)	(0)
+#define scsi_set_pci_device(sh, pdev)	(0)
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 #	if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
 		typedef unsigned int dma_addr_t;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/mptbase.c linux/drivers/message/fusion/mptbase.c
--- ../prev/linux/drivers/message/fusion/mptbase.c	Tue Jul  9 18:04:12 2002
+++ linux/drivers/message/fusion/mptbase.c	Tue Jun  4 15:09:10 2002
@@ -49,7 +49,7 @@
  *  (mailto:sjralston1@netscape.net)
  *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptbase.c,v 1.110 2002/02/27 18:44:20 sralston Exp $
+ *  $Id: mptbase.c,v 1.115 2002/05/06 18:29:03 pdelaney Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -443,7 +443,7 @@
 			if ((mf) && ((mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))
 				|| (mf < ioc->req_frames)) ) {
 				printk(MYIOC_s_WARN_FMT 
-					"mpt_interrupt: Invalid mf (%p) req_idx (%d)!\n", ioc->name, mf, req_idx);
+					"mpt_interrupt: Invalid mf (%p) req_idx (%d)!\n", ioc->name, (void *)mf, req_idx);
 				cb_idx = 0;
 				pa = 0;
 				freeme = 0;
@@ -451,7 +451,7 @@
 			if ((pa) && (mr) && ((mr >= MPT_INDEX_2_RFPTR(ioc, ioc->req_depth))
 				|| (mr < ioc->reply_frames)) ) {
 				printk(MYIOC_s_WARN_FMT 
-					"mpt_interrupt: Invalid rf (%p)!\n", ioc->name, mr);
+					"mpt_interrupt: Invalid rf (%p)!\n", ioc->name, (void *)mr);
 				cb_idx = 0;
 				pa = 0;
 				freeme = 0;
@@ -525,7 +525,7 @@
 	if ((mf == NULL) ||
 	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
 		printk(MYIOC_s_ERR_FMT "NULL or BAD request frame ptr! (=%p)\n",
-				ioc->name, mf);
+				ioc->name, (void *)mf);
 		return 1;
 	}
 
@@ -1090,7 +1090,7 @@
 	dprintk((KERN_INFO MYNAM ": Checking for MPT adapters...\n"));
 
 	/*
-	 *  NOTE: The 929 and 1030 will appear as 2 separate PCI devices,
+	 *  NOTE: The 929, 929X and 1030 will appear as 2 separate PCI devices,
 	 *  one for each channel.
 	 */
 	pci_for_each_dev(pdev) {
@@ -1101,6 +1101,8 @@
 		if ((pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC909) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC929) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC919) &&
+		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC929X) &&
+		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC919X) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030) &&
 #if 0
 		    /* FIXME! C103x family */
@@ -1113,7 +1115,7 @@
 		}
 
 		/* GRRRRR
-		 * dual function devices (929, 1030) may be presented in Func 1,0 order,
+		 * dual function devices (929, 929X, 1030) may be presented in Func 1,0 order,
 		 * but we'd really really rather have them in Func 0,1 order.
 		 * Do some kind of look ahead here...
 		 */
@@ -1216,6 +1218,18 @@
 	int		 r = -ENODEV;
 	int		 len;
 
+	if (pci_enable_device(pdev))
+		return r;
+
+	if (!pci_set_dma_mask(pdev, (u64) MPT_MAX_PCI_MASK)) {
+		dprintk((KERN_INFO MYNAM 
+			": %dBIT PCI BUS DMA ADDRESSING SUPPORTED\n",
+			(int) sizeof(MPT_MAX_PCI_MASK) * 8));
+	} else if (pci_set_dma_mask(pdev, (u64) 0xffffffff)) {
+		printk(KERN_WARNING MYNAM ": 32 BIT PCI BUS DMA ADDRESSING NOT SUPPORTED\n");
+		return r;
+	}
+
 	ioc = kmalloc(sizeof(MPT_ADAPTER), GFP_KERNEL);
 	if (ioc == NULL) {
 		printk(KERN_ERR MYNAM ": ERROR - Insufficient memory to add adapter!\n");
@@ -1338,6 +1352,14 @@
 		ioc->chip_type = FC919;
 		ioc->prod_name = "LSIFC919";
 	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC929X) {
+		ioc->chip_type = FC929X;
+		ioc->prod_name = "LSIFC929X";
+	}
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC919X) {
+		ioc->chip_type = FC919X;
+		ioc->prod_name = "LSIFC919X";
+	}
 	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_53C1030) {
 		ioc->chip_type = C1030;
 		ioc->prod_name = "LSI53C1030";
@@ -1400,9 +1422,9 @@
 	mpt_adapters[ioc->id] = ioc;
 
 	/* NEW!  20010220 -sralston
-	 * Check for "bound ports" (929, 1030) to reduce redundant resets.
+	 * Check for "bound ports" (929, 929X, 1030) to reduce redundant resets.
 	 */
-	if ((ioc->chip_type == FC929) || (ioc->chip_type == C1030))
+	if ((ioc->chip_type == FC929) || (ioc->chip_type == C1030) || (ioc->chip_type == FC929X))
 		mpt_detect_bound_ports(ioc, pdev);
 
 	if ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP, CAN_SLEEP)) != 0) {
@@ -1645,8 +1667,8 @@
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mpt_detect_bound_ports - Search for PCI bus/dev_function
- *	which matches PCI bus/dev_function (+/-1) for newly discovered 929
- *	or 1030.
+ *	which matches PCI bus/dev_function (+/-1) for newly discovered 929,
+ *	929X or 1030.
  *	@ioc: Pointer to MPT adapter structure
  *	@pdev: Pointer to (struct pci_dev) structure
  *
@@ -2271,6 +2293,13 @@
 	ioc_init.Function = MPI_FUNCTION_IOC_INIT;
 /*	ioc_init.Flags = 0;				*/
 
+	/* If we are in a recovery mode and we uploaded the FW image,
+	 * then this pointer is not NULL. Skip the upload a second time.
+	 * Set this flag if FWImage set for either IOC.
+	 */
+	if ((ioc->FWImage) || (ioc->alt_ioc && ioc->alt_ioc->FWImage))
+		ioc_init.Flags = MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE;
+
 	if ((int)ioc->chip_type <= (int)FC929) {
 		ioc_init.MaxDevices = MPT_MAX_FC_DEVICES;
 	}
@@ -4431,6 +4460,7 @@
 		/* Search the configQ for internal commands. 
 		 * Flush the Q, and wake up all suspended threads.
 		 */
+#if 1
 		spin_lock_irqsave(&ioc->FreeQlock, flags);
 		if (! Q_IS_EMPTY(&ioc->configQ)){
 			pCfg = (CONFIGPARMS *)ioc->configQ.head;
@@ -4447,6 +4477,23 @@
 			} while (pCfg != (CONFIGPARMS *)&ioc->configQ);
 		}
 		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+#else
+		while (1) {
+			spin_lock_irqsave(&ioc->FreeQlock, flags);
+			if (! Q_IS_EMPTY(&ioc->configQ)){
+				spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+				break;
+			}
+			pCfg = (CONFIGPARMS *)ioc->configQ.head;
+
+			Q_DEL_ITEM(&pCfg->linkage);
+			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+			pCfg->status = MPT_CONFIG_ERROR;
+			pCfg->wait_done = 1;
+			wake_up(&mpt_waitq);
+		}
+#endif
 	}
 
 	return 1;		/* currently means nothing really */
@@ -4732,7 +4779,7 @@
 	len += sprintf(buf+len, "  MinBlockSize = 0x%02x bytes\n", 4*ioc->facts.BlockSize);
 
 	len += sprintf(buf+len, "  RequestFrames @ 0x%p (Dma @ 0x%p)\n",
-					ioc->req_alloc, (void *)(ulong)ioc->req_alloc_dma);
+					(void *)ioc->req_alloc, (void *)(ulong)ioc->req_alloc_dma);
 	/*
 	 *  Rounding UP to nearest 4-kB boundary here...
 	 */
@@ -4745,7 +4792,7 @@
 					ioc->facts.GlobalCredits);
 
 	len += sprintf(buf+len, "  ReplyFrames   @ 0x%p (Dma @ 0x%p)\n",
-					ioc->reply_alloc, (void *)(ulong)ioc->reply_alloc_dma);
+					(void *)ioc->reply_alloc, (void *)(ulong)ioc->reply_alloc_dma);
 	sz = (ioc->reply_sz * ioc->reply_depth) + 128;
 	len += sprintf(buf+len, "    {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\n",
 					ioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/mptbase.h linux/drivers/message/fusion/mptbase.h
--- ../prev/linux/drivers/message/fusion/mptbase.h	Tue Jul  9 18:04:12 2002
+++ linux/drivers/message/fusion/mptbase.h	Wed Jun  5 11:40:28 2002
@@ -13,7 +13,7 @@
  *  (mailto:sjralston1@netscape.net)
  *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptbase.h,v 1.103 2002/02/27 20:24:38 pdelaney Exp $
+ *  $Id: mptbase.h,v 1.116 2002/05/08 12:17:25 pdelaney Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -80,8 +80,8 @@
 #define COPYRIGHT	"Copyright (c) 1999-2002 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"2.00.11"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.00.11"
+#define MPT_LINUX_VERSION_COMMON	"2.01.03hp"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.01.03hp"
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 
 #define show_mptmod_ver(s,ver)  \
@@ -295,6 +295,8 @@
  */
 
 typedef enum {
+	FC919X = 0x0819,
+	FC929X = 0x0829,
 	FC909 = 0x0909,
 	FC919 = 0x0919,
 	FC929 = 0x0929,
@@ -396,11 +398,13 @@
 	u32			 luns;		/* Max LUNs is 32 */
 	u8			 inq_data[SCSI_STD_INQUIRY_BYTES];	/* 36 */
 	u8			 pad0[4];
-	u8			 uniq_prepad[8];
 	u8			 inq00_data[20];
 	u8			 pad1[4];
 		/* IEEE Registered Extended Identifier
 		   obtained via INQUIRY VPD page 0x83 */
+		/* NOTE: Do not separate uniq_prepad and uniq_data
+		   as they are treateed as a single entity in the code */
+	u8			 uniq_prepad[8];
 	u8			 uniq_data[20];
 	u8			 pad2[4];
 	u8			 inqC3_data[12];
@@ -653,6 +657,7 @@
 
 #define MPT_SGE_ADDRESS_SIZE		MPI_SGE_FLAGS_64_BIT_ADDRESSING
 #define MPT_SCSIIO_MSG_FLAGS		MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_64
+#define MPT_MAX_PCI_MASK		0xffffffffffffffff
 
 
 #else
@@ -669,6 +674,7 @@
 
 #define MPT_SGE_ADDRESS_SIZE		MPI_SGE_FLAGS_32_BIT_ADDRESSING
 #define MPT_SCSIIO_MSG_FLAGS		MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_32
+#define MPT_MAX_PCI_MASK		0xffffffff
 
 #endif
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/mptctl.h linux/drivers/message/fusion/mptctl.h
--- ../prev/linux/drivers/message/fusion/mptctl.h	Tue Jul  9 18:04:12 2002
+++ linux/drivers/message/fusion/mptctl.h	Tue Jun  4 15:09:10 2002
@@ -20,7 +20,7 @@
  *  (mailto:sjralston1@netscape.net)
  *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptctl.h,v 1.2 2002/03/19 23:05:36 awilliam Exp $
+ *  $Id: mptctl.h,v 1.9 2002/02/27 18:44:26 sralston Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/mptlan.c linux/drivers/message/fusion/mptlan.c
--- ../prev/linux/drivers/message/fusion/mptlan.c	Tue Jul  9 18:04:12 2002
+++ linux/drivers/message/fusion/mptlan.c	Tue Jun  4 15:09:10 2002
@@ -26,7 +26,7 @@
  *  Copyright (c) 2000-2002 LSI Logic Corporation
  *  Originally By: Noah Romer
  *
- *  $Id: mptlan.c,v 1.51 2002/02/11 14:40:55 sralston Exp $
+ *  $Id: mptlan.c,v 1.52 2002/05/06 13:45:07 sshirron Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -669,7 +669,7 @@
 
 	/* Add check for Loginfo Flag in IOCStatus */
 
-	switch (le16_to_cpu(pSendRep->IOCStatus)) {
+	switch (le16_to_cpu(pSendRep->IOCStatus) & MPI_IOCSTATUS_MASK) {
 	case MPI_IOCSTATUS_SUCCESS:
 		priv->stats.tx_packets += count;
 		break;
@@ -1045,7 +1045,8 @@
 	dioprintk((KERN_INFO MYNAM ": receive_post_reply: IOCStatus: %04x\n",
 		 le16_to_cpu(pRecvRep->IOCStatus)));
 
-	if (le16_to_cpu(pRecvRep->IOCStatus) & MPI_IOCSTATUS_LAN_CANCELED)
+	if ((le16_to_cpu(pRecvRep->IOCStatus) & MPI_IOCSTATUS_MASK) ==
+						MPI_IOCSTATUS_LAN_CANCELED)
 		return mpt_lan_receive_post_free(dev, pRecvRep);
 
 	len = le32_to_cpu(pRecvRep->PacketLength);
@@ -1436,7 +1437,7 @@
 {
 	struct net_device *dev;
 	MPT_ADAPTER *curadapter;
-	int i = 0, j;
+	int i, j;
 
 	show_mptmod_ver(LANAME, LANVER);
 
@@ -1468,7 +1469,6 @@
 	for (j = 0; j < MPT_MAX_ADAPTERS; j++) {
 		mpt_landev[j] = NULL;
 	}
-	j = 0;
 
 	curadapter = mpt_adapter_find_first();
 	while (curadapter != NULL) {
@@ -1492,11 +1492,11 @@
 //					printk (KERN_INFO MYNAM ": %s/%s: Max_TX_outstanding = %d\n",
 //							IOC_AND_NETDEV_NAMES_s_s(dev),
 //							NETDEV_TO_LANPRIV_PTR(dev)->tx_max_out);
+					j = curadapter->id;
 					mpt_landev[j] = dev;
 					dlprintk((KERN_INFO MYNAM "/init: dev_addr=%p, mpt_landev[%d]=%p\n",
 							dev, j,  mpt_landev[j]));
 
-					j++;
 				} else {
 					printk (KERN_ERR MYNAM ": %s: Unable to register port%d as a LAN device\n",
 							curadapter->name,
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/mptlinux.txt linux/drivers/message/fusion/mptlinux.txt
--- ../prev/linux/drivers/message/fusion/mptlinux.txt	Tue Jul  9 18:04:12 2002
+++ linux/drivers/message/fusion/mptlinux.txt	Tue Jun  4 15:09:11 2002
@@ -44,7 +44,7 @@
 o  Supports SCSI and IETF-compliant LAN protocols concurrently over FC
 o  Supports 1Gbit/s Fibre Channel transfer rates (LSIFC909)
 o  Supports 1Gbit/s and 2Gbit/s Fibre Channel transfer rates (LSIFC919,
-   LSIFC929)
+   LSIFC929, LSIFC919X, LSIFC929X)
 o  Supports Ultra320 transfer rates (LSI53C1030)
 o  Supports LSI Logic Fusion MPT Architecture and common software interface
 o  Low host CPU utilization with one, or less than one, interrupt per I/O
@@ -53,8 +53,11 @@
 
 o LSIFC909 chips and LSI40909 adapters
 o LSIFC919 chips and LSI40919 adapters
-o LSIFC929 chips and LSI44929 adapters
-o LSI53C1030 chips and LSI22320 adapters
+o LSIFC919X chips and LSI7102X adapters
+o LSIFC929 chips and LSI44929, LSI7402 adapters
+o LSIFC929X chips and LSI7202X, LSI7402X adapters
+o LSI53C1020 chips and LSI20320 adapters
+o LSI53C1030 chips and LSI22320, LSI21320 adapters
 
 ****************** Installing the Fusion MPT Linux Drivers *******************
 
@@ -73,7 +76,7 @@
 your linux kernel source tree (normally /usr/src/linux).
   Example:
     $ cd /usr/src/linux
-    $ zcat /tmp/mptlinux-2.00.11-src.tar.gz | tar xvf -
+    $ zcat /tmp/mptlinux-2.01.03-src.tar.gz | tar xvf -
 
 ------ Updating Bundled Fusion MPT Driver
 
@@ -90,7 +93,7 @@
   Example:
   # rm -rf fusion
   # cd /usr/src/linux
-  # zcat /tmp/mptlinux-2.00.11-src.tar.gz | tar xvf -
+  # zcat /tmp/mptlinux-2.01.03-src.tar.gz | tar xvf -
 
 (Deletion of the original driver tree is necessary to remove obsolete files.)
 
@@ -125,10 +128,12 @@
     2.4.2-2,                           (Red Hat 7.1)
     <not needed>,                      (Caldera 3.1)		
     2.4.3,
+    2.4.3-6,                           (Red Hat 7.1, SBE)
     2.4.3-12,                          (Red Hat 7.1, upd#1)
     2.4.4,
-    2.4.4-4GB,                         (SuSE 7.2)
+    2.4.4-4GB,                         (SuSE 7.2 - i386 and ia64)
     2.4.5,
+    2.4.5-3,                           (TurboLinux 7.0)
     2.4.6,
     2.4.7,
     2.4.7-10,                          (Red Hat 7.2) 
@@ -138,7 +143,9 @@
     2.4.9-13,  <zero patches>          (Red Hat 7.2, upd#1)
     2.4.9-18,                          (Red Hat 7.2 IA64)
     2.4.9-21,  <zero patches>          (Red Hat 7.2, upd#2)
+    2.4.9-31,  <zero patches>          (Red Hat 7.2 IA64, upd#1)
     2.4.10,
+    2.4.10-4GB,                        (SuSE 7.3)
     2.4.11 (broken kernel, do not use),
     2.4.12,
     2.4.13,
@@ -146,7 +153,9 @@
     2.4.15,
     2.4.16,
     2.4.17,
-    2.4.18
+    2.4.18,
+    2.4.18-3,  <zero patches>          (Red Hat 7.3)
+    2.4.18-4GB <zero patches>          (SuSE 8.0)
 
   NOTES:
     o  The Fusion MPT LAN driver is NOT supported in any of the 2.2.x
@@ -278,7 +287,7 @@
 
 1.  Load the Fusion MPT base driver.
         # insmod mptbase
-        Fusion MPT base driver 2.00.11
+        Fusion MPT base driver 2.01.03
         Copyright (c) 1999-2002 LSI Logic Corporation
         mptbase: Initiating ioc0 bringup
         ioc0: FC919: Capabilities={Initiator,Target,LAN}
@@ -287,12 +296,12 @@
 2.  Load the isense driver (optional but highly recommended),
     to enable enhanced SCSI error reporting.
         # insmod isense
-        SCSI-3 Opcodes & ASC/ASCQ Strings 2.00.11
+        SCSI-3 Opcodes & ASC/ASCQ Strings 2.01.03
         mptbase: English readable SCSI-3 OPs & ASC/ASCQ strings enabled:-)
 
 3.  Load the Fusion MPT SCSI host driver.
         # insmod mptscsih
-        Fusion MPT SCSI Host driver 2.00.11
+        Fusion MPT SCSI Host driver 2.01.03
 
       Depending on what FC devices you have attached to your FC link,
       you should see something like the following on the console and
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/mptscsih.c linux/drivers/message/fusion/mptscsih.c
--- ../prev/linux/drivers/message/fusion/mptscsih.c	Tue Jul  9 18:04:13 2002
+++ linux/drivers/message/fusion/mptscsih.c	Tue Jun  4 15:35:40 2002
@@ -26,7 +26,7 @@
  *  (mailto:sjralston1@netscape.net)
  *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptscsih.c,v 1.80 2002/02/27 18:44:27 sralston Exp $
+ *  $Id: mptscsih.c,v 1.89 2002/05/08 12:17:26 pdelaney Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -294,7 +294,7 @@
 	if ((mf == NULL) ||
 	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
 		printk(MYIOC_s_ERR_FMT "%s req frame ptr! (=%p)!\n",
-				ioc->name, mf?"BAD":"NULL", mf);
+				ioc->name, mf?"BAD":"NULL", (void *) mf);
 		/* return 1; CHECKME SteveR. Don't free. */
 		return 0;
 	}
@@ -700,6 +700,7 @@
 	unsigned long flags;
 
 	dprintk((KERN_INFO MYNAM ": clean_taskQ called\n"));
+
 	spin_lock_irqsave(&ioc->FreeQlock, flags);
 	if (! Q_IS_EMPTY(&hd->taskQ)) {
 		mf = hd->taskQ.head;
@@ -951,7 +952,7 @@
 	sz = numChain * sizeof(int);
 
 	if (hd->ReqToChain == NULL) {
-		mem = kmalloc(sz, GFP_KERNEL);
+		mem = kmalloc(sz, GFP_ATOMIC);
 		if (mem == NULL)
 			return -1;
 
@@ -962,7 +963,7 @@
 	memset(mem, 0xFF, sz);
 
 	if (hd->ChainToChain == NULL) {
-		mem = kmalloc(sz, GFP_KERNEL);
+		mem = kmalloc(sz, GFP_ATOMIC);
 		if (mem == NULL)
 			return -1;
 
@@ -1199,6 +1200,10 @@
 					sh->sg_tablesize = numSGE;
 				}
 
+				/* Set the pci device pointer in Scsi_Host structure.
+				 */
+				scsi_set_pci_device(sh, this->pcidev);
+
 				restore_flags(flags);
 
 				hd = (MPT_SCSI_HOST *) sh->hostdata;
@@ -1217,7 +1222,7 @@
 				 * (with size equal to req_depth*PtrSz!)
 				 */
 				sz = hd->ioc->req_depth * sizeof(void *);
-				mem = kmalloc(sz, GFP_KERNEL);
+				mem = kmalloc(sz, GFP_ATOMIC);
 				if (mem == NULL)
 					goto done;
 
@@ -1233,7 +1238,7 @@
 				/* Allocate memory for free and doneQ's
 				 */
 				sz = sh->can_queue * sizeof(MPT_DONE_Q);
-				mem = kmalloc(sz, GFP_KERNEL);
+				mem = kmalloc(sz, GFP_ATOMIC);
 				if (mem == NULL)
 					goto done;
 
@@ -1266,7 +1271,7 @@
 				 * max_id = 1 + maximum id (hosts.h)
 				 */
 				sz = sh->max_id * sizeof(void *);
-				mem = kmalloc(sz, GFP_KERNEL);
+				mem = kmalloc(sz, GFP_ATOMIC);
 				if (mem == NULL)
 					goto done;
 
@@ -1387,10 +1392,9 @@
 	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
 #endif
 
+	count = 10 * HZ;
 	spin_lock_irqsave(&mytaskQ_lock, flags);
 	if (mytaskQ_bh_active) {
-		count = 10 * HZ;
-
 		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 		dprintk((KERN_INFO MYNAM ": Info: Zapping TaskMgmt thread!\n"));
 		clean_taskQ(hd);
@@ -1399,23 +1403,25 @@
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(1);
 		}
-		if (!count)
-			printk(KERN_ERR MYNAM ": ERROR - TaskMgmt thread still active!\n");
-	}
-	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+	} else
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
+	if (!count)
+		printk(KERN_ERR MYNAM ": ERROR - TaskMgmt thread still active!\n");
+
 #endif
 
 #ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
 	/* Check DV thread active */
 	count = 10 * HZ;
 	spin_lock_irqsave(&dvtaskQ_lock, flags);
-	while(dvtaskQ_active && --count) {
+	if (dvtaskQ_active) {
+		spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+		while(dvtaskQ_active && --count) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		}
+	} else
 		spin_unlock_irqrestore(&dvtaskQ_lock, flags);
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(1);
-		spin_lock_irqsave(&dvtaskQ_lock, flags);
-	}
-	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
 	if (!count)
 		printk(KERN_ERR MYNAM ": ERROR - DV thread still active!\n");
 #if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
@@ -1728,7 +1734,9 @@
 				SCpnt->resid = SCpnt->request_bufflen - sz;
 #endif
 				SCpnt->result = 0;
+				spin_lock_irqsave(&io_request_lock, flags);
 				SCpnt->scsi_done(SCpnt);
+				spin_unlock_irqrestore(&io_request_lock, flags);
 
 				//sjr-moved-up//pTarget->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;
 
@@ -1772,10 +1780,10 @@
 	 *    will be no data transfer!  GRRRRR...
 	 */
 	datadir = mptscsih_io_direction(SCpnt);
-	if (datadir < 0) {
+	if (datadir == SCSI_DATA_READ) {
 		datalen = SCpnt->request_bufflen;
 		scsidir = MPI_SCSIIO_CONTROL_READ;	/* DATA IN  (host<--ioc<--dev) */
-	} else if (datadir > 0) {
+	} else if (datadir == SCSI_DATA_WRITE) {
 		datalen = SCpnt->request_bufflen;
 		scsidir = MPI_SCSIIO_CONTROL_WRITE;	/* DATA OUT (host-->ioc-->dev) */
 	} else {
@@ -1910,14 +1918,15 @@
 					spin_lock_irqsave(&dvtaskQ_lock, lflags);
 					if (!dvtaskQ_active) {
 						dvtaskQ_active = 1;
+						spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
 						mptscsih_dvTask.sync = 0;
 						mptscsih_dvTask.routine = mptscsih_domainValidation;
 						mptscsih_dvTask.data = (void *) hd;
 
 						SCHEDULE_TASK(&mptscsih_dvTask);
-					}
+					}  else 
+						spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
 					hd->ioc->spi_data.forceDv = 0;
-					spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
 				}
 
 				/* Trying to do DV to this target, extend timeout.
@@ -1955,7 +1964,9 @@
 			} else {
 				spin_unlock_irqrestore(&hd->freedoneQlock, flags);
 				SCpnt->result = (DID_BUS_BUSY << 16);
+				spin_lock_irqsave(&io_request_lock, flags);
 				SCpnt->scsi_done(SCpnt);
+				spin_unlock_irqrestore(&io_request_lock, flags);
 			}
 		}
 	} else {
@@ -1987,7 +1998,9 @@
 		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
 	} else {
 		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+		spin_lock_irqsave(&io_request_lock, flags);
 		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
 	}
 
 	return 0;
@@ -2058,7 +2071,8 @@
 
 		/* 0xD1000000 = LAST | EOB | SIMPLE | EOL */
 		psge->FlagsLength = cpu_to_le32(
-				0xD1000000|sgdir|SCpnt->request_bufflen);
+				0xD1000000|MPT_SGE_FLAGS_ADDRESSING|
+				sgdir|SCpnt->request_bufflen);
 		cpu_to_leXX(buf_dma_addr, psge->Address);
 
 		return SUCCESS;
@@ -2333,11 +2347,9 @@
 
 		chain = (MPT_FRAME_HDR *) (hd->ChainBuffer
 					+ (chain_idx * hd->ioc->req_sz));
-		//spin_lock_irqsave(&hd->FreeChainQlock, flags);
 		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
 		Q_ADD_TAIL(&hd->FreeChainQ.head,
 					&chain->u.frame.linkage, MPT_FRAME_HDR);
-		//spin_unlock_irqrestore(&hd->FreeChainQlock, flags);
 		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
 		dmfprintk((MYIOC_s_INFO_FMT "FreeChainBuffers (index %d)\n",
@@ -2963,13 +2975,15 @@
 	unsigned long		 flags;
 	int			 scpnt_idx;
 
-	printk(KERN_WARNING MYNAM ": OldAbort scheduling ABORT SCSI IO (sc=%p)\n", SCpnt);
+	printk(KERN_WARNING MYNAM ": OldAbort scheduling ABORT SCSI IO (sc=%p)\n", (void *) SCpnt);
 	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
 
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
 		printk(KERN_WARNING "  WARNING - OldAbort, NULL hostdata ptr!!\n");
 		SCpnt->result = DID_ERROR << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
 		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
 		return SCSI_ABORT_NOT_RUNNING;
 	}
 
@@ -2981,7 +2995,9 @@
 		search_doneQ_for_cmd(hd, SCpnt);
 
 		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
 		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
 		return SCSI_ABORT_SUCCESS;
 	} else {
 		/* If this command is pended, then timeout/hang occurred
@@ -3061,6 +3077,8 @@
 
 	if (! mytaskQ_bh_active) {
 		mytaskQ_bh_active = 1;
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
+
 		/*
 		 *  Oh how cute, no alloc/free/mgmt needed if we use
 		 *  (bottom/unused portion of) MPT request frame.
@@ -3071,8 +3089,8 @@
 		ptaskfoo->data = SCpnt;
 
 		SCHEDULE_TASK(ptaskfoo);
-	}
-	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+	} else 
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 
 	return SCSI_ABORT_PENDING;
 }
@@ -3096,12 +3114,14 @@
 	unsigned long		 flags;
 	int			 scpnt_idx;
 
-	printk(KERN_WARNING MYNAM ": OldReset scheduling BUS_RESET (sc=%p)\n", SCpnt);
+	printk(KERN_WARNING MYNAM ": OldReset scheduling BUS_RESET (sc=%p)\n", (void *) SCpnt);
 	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
 
 	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
 		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
 		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
 		return SCSI_RESET_SUCCESS;
 	}
 
@@ -3113,7 +3133,9 @@
 		search_doneQ_for_cmd(hd, SCpnt);
 
 		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
 		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
 		return SCSI_RESET_SUCCESS;
 	} else {
 		/* If this command is pended, then timeout/hang occurred
@@ -3174,8 +3196,11 @@
 	atomic_inc(&mpt_taskQdepth);
 	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
-	spin_lock_irqsave(&mytaskQ_lock, flags);
 
+	dtmprintk((MYIOC_s_INFO_FMT "OldReset: _bh_handler state (%d) taskQ count (%d)\n",
+		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
 	/* Save the original SCpnt mf pointer
 	 */
 	SCpnt->host_scribble = (u8 *) MPT_INDEX_2_MFPTR (hd->ioc, scpnt_idx);
@@ -3184,11 +3209,9 @@
 	mf->u.frame.linkage.argp1 = SCpnt;
 	mf->u.frame.linkage.argp2 = (void *) hd;
 
-	dtmprintk((MYIOC_s_INFO_FMT "OldReset: _bh_handler state (%d) taskQ count (%d)\n",
-		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
-
 	if (! mytaskQ_bh_active) {
 		mytaskQ_bh_active = 1;
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 		/*
 		 *  Oh how cute, no alloc/free/mgmt needed if we use
 		 *  (bottom/unused portion of) MPT request frame.
@@ -3199,8 +3222,8 @@
 		ptaskfoo->data = SCpnt;
 
 		SCHEDULE_TASK(ptaskfoo);
-	}
-	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+	} else 
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
 	return SCSI_RESET_PENDING;
 }
 
@@ -3243,7 +3266,7 @@
 					printk(KERN_ERR MYNAM
 							": ERROR - TaskMgmt NULL SCSI Host!"
 							"(ioc=%p, sh=%p hd=%p)\n",
-							ioc, ioc->sh, hd);
+							(void *) ioc, (void *) ioc->sh, (void *) hd);
 					continue;
 				}
 
@@ -3276,7 +3299,7 @@
 				SCpnt = (Scsi_Cmnd*)mf->u.frame.linkage.argp1;
 				if (SCpnt == NULL) {
 					printk(KERN_ERR MYNAM ": ERROR - TaskMgmt has NULL SCpnt! (mf=%p:sc=%p)\n",
-							mf, SCpnt);
+							(void *) mf, (void *) SCpnt);
 					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
 					spin_lock_irqsave(&ioc->FreeQlock, flags);
 					hd->tmPending = 0;
@@ -3330,7 +3353,7 @@
 
 					hd->abortSCpnt = SCpnt;
 					printk(KERN_WARNING MYNAM ": Attempting ABORT SCSI IO! (mf=%p:sc=%p)\n",
-							mf, SCpnt);
+							(void *) mf, (void *) SCpnt);
 				}
 
 				/* The TM handler will allocate a new mf,
@@ -3345,7 +3368,7 @@
 					 * Fatal error case.
 					 */
 					printk(KERN_WARNING MYNAM
-						": WARNING[1] - IOC error processing TaskMgmt request (sc=%p)\n", SCpnt);
+						": WARNING[1] - IOC error processing TaskMgmt request (sc=%p)\n", (void *) SCpnt);
 
 					if (hd->ScsiLookup[scpnt_idx] != NULL) {
 						atomic_dec(&queue_depth);
@@ -3623,10 +3646,22 @@
  *     1 = _DATA_OUT
  *     0 = _DIR_NONE
  *    -1 = _DATA_IN
+ *
+ * Changed: 3-20-2002 pdelaney to use the default data
+ * direction and the defines set up in the
+ * 2.4 kernel series
+ *     1 = _DATA_OUT	changed to SCSI_DATA_WRITE (1)
+ *     0 = _DIR_NONE	changed to SCSI_DATA_NONE (3)
+ *    -1 = _DATA_IN	changed to SCSI_DATA_READ (2)
+ * If the direction is unknown, fall through to original code.
  */
 static int
 mptscsih_io_direction(Scsi_Cmnd *cmd)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	if (cmd->sc_data_direction != SCSI_DATA_UNKNOWN)
+		return cmd->sc_data_direction;
+#endif
 	switch (cmd->cmnd[0]) {
 	/*  _DATA_OUT commands	*/
 	case WRITE_6:		case WRITE_10:		case WRITE_12:
@@ -3642,7 +3677,7 @@
 	case PERSISTENT_RESERVE_OUT:
 	case 0xea:
 	case 0xa3:
-		return 1;
+		return SCSI_DATA_WRITE;
 
 	/*  No data transfer commands  */
 	case SEEK_6:		case SEEK_10:
@@ -3650,26 +3685,26 @@
 	case TEST_UNIT_READY:
 	case START_STOP:
 	case ALLOW_MEDIUM_REMOVAL:
-		return 0;
+		return SCSI_DATA_NONE;
 
 	/*  Conditional data transfer commands	*/
 	case FORMAT_UNIT:
 		if (cmd->cmnd[1] & 0x10)	/* FmtData (data out phase)? */
-			return 1;
+			return SCSI_DATA_WRITE;
 		else
-			return 0;
+			return SCSI_DATA_NONE;
 
 	case VERIFY:
 		if (cmd->cmnd[1] & 0x02)	/* VERIFY:BYTCHK (data out phase)? */
-			return 1;
+			return SCSI_DATA_WRITE;
 		else
-			return 0;
+			return SCSI_DATA_NONE;
 
 	case RESERVE_10:
 		if (cmd->cmnd[1] & 0x03)	/* RESERVE:{LongID|Extent} (data out phase)? */
-			return 1;
+			return SCSI_DATA_WRITE;
 		else
-			return 0;
+			return SCSI_DATA_NONE;
 
 #if 0
 	case REZERO_UNIT:	/* (or REWIND) */
@@ -3681,7 +3716,7 @@
 
 	/*  Must be data _IN!  */
 	default:
-		return -1;
+		return SCSI_DATA_READ;
 	}
 }
 
@@ -3874,23 +3909,22 @@
 		Q_DEL_ITEM(buffer);
 
 		mf = (MPT_FRAME_HDR *) buffer->argp;
+		buffer->argp = NULL;
+
+		/* Add to the freeQ
+		 */
+		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+
 		if (!mf) {
 			/* This should never happen */
-			printk(MYIOC_s_WARN_FMT "post_pendingQ_commands: mf %p\n", hd->ioc->name, mf);
-			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			printk(MYIOC_s_WARN_FMT "post_pendingQ_commands: mf %p\n", hd->ioc->name, (void *) mf);
 			continue;
 		}
 
 		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
 		ddvtprintk((MYIOC_s_INFO_FMT "Issued SCSI cmd (mf=%p)\n",
 				hd->ioc->name, mf));
-
-		buffer->argp = NULL;
-
-		/* Add to the freeQ
-		 */
-		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
-		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
 	}
 
 	return;
@@ -4102,14 +4136,18 @@
 		/*
 		 *  CHECKME!  Falling thru...
 		 */
+		break;
 
 	case MPI_EVENT_INTEGRATED_RAID:			/* 0B */
 #ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
 		/* negoNvram set to 0 if DV enabled and to USE_NVRAM if 
-		 * if DV disabled
+		 * if DV disabled. Need to check for target mode.
 		 */
-		hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
-		if (hd->negoNvram == 0) {
+		hd = NULL;
+		if (ioc->sh)
+			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+
+		if (hd && (hd->is_spi) && (hd->negoNvram == 0)) {
 			ScsiCfgData	*pSpi;
 			Ioc3PhysDisk_t	*pPDisk;
 			int		 numPDisk;
@@ -4739,7 +4777,7 @@
 			}
 
 			if (target->inq_data[7] & 0x10) {
-				if (version == 2)
+				if ((version == 2) && !width)
 					factor = MPT_ULTRA2;
 				else
 					factor = MPT_ULTRA320;
@@ -4810,6 +4848,12 @@
 
 		if (!offset)
 			target->negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+
+		/* GEM, processor WORKAROUND
+		 */
+		if (((target->inq_data[0] & 0x1F) == 0x03) || ((target->inq_data[0] & 0x1F) > 0x08)) {
+			target->negoFlags |= (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC);
+		}
 	}
 
 	return;
@@ -5163,7 +5207,7 @@
 	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
 		printk(MYIOC_s_ERR_FMT
 			"ScanDvComplete, %s req frame ptr! (=%p)\n",
-				ioc->name, mf?"BAD":"NULL", mf);
+				ioc->name, mf?"BAD":"NULL", (void *) mf);
 		goto wakeup;
 	}
 
@@ -5175,7 +5219,7 @@
 
 	if (mf != hd->cmdPtr) {
 		printk(MYIOC_s_WARN_FMT "ScanDvComplete (mf=%p, cmdPtr=%p)\n",
-				hd->ioc->name, mf, hd->cmdPtr);
+				hd->ioc->name, (void *)mf, (void *) hd->cmdPtr);
 	}
 	hd->cmdPtr = NULL;
 
@@ -6078,6 +6122,16 @@
 	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES))
 		iocmd.flags |= MPT_ICFLAG_TAGGED_CMD;
 
+	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)) {
+		/* Another GEM workaround. Check peripheral device type,
+		 * if PROCESSOR, quit DV.
+		 */
+		if (((pTarget->inq_data[0] & 0x1F) == 0x03) || ((pTarget->inq_data[0] & 0x1F) > 0x08)) {
+			pTarget->negoFlags |= (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC);
+			return;
+		}
+	}
+
 	/* Prep cfg structure
 	 */
 	cfg.pageAddr = (bus<<8) | id;
@@ -6985,20 +7039,22 @@
 			/* Preserv all flags, use
 			 * read-modify-write algorithm
 			 */
-			data = hd->ioc->spi_data.nvram[id];
+			if (hd->ioc->spi_data.nvram) {
+				data = hd->ioc->spi_data.nvram[id];
 
-			if (dv->now.width)
-				data &= ~MPT_NVRAM_WIDE_DISABLE;
-			else
-				data |= MPT_NVRAM_WIDE_DISABLE;
+				if (dv->now.width)
+					data &= ~MPT_NVRAM_WIDE_DISABLE;
+				else
+					data |= MPT_NVRAM_WIDE_DISABLE;
 
-			if (!dv->now.offset)
-				factor = MPT_ASYNC;
+				if (!dv->now.offset)
+					factor = MPT_ASYNC;
 
-			data &= ~MPT_NVRAM_SYNC_MASK;
-			data |= (dv->now.factor << MPT_NVRAM_SYNC_SHIFT) & MPT_NVRAM_SYNC_MASK;
+				data &= ~MPT_NVRAM_SYNC_MASK;
+				data |= (dv->now.factor << MPT_NVRAM_SYNC_SHIFT) & MPT_NVRAM_SYNC_MASK;
 
-			hd->ioc->spi_data.nvram[id] = data;
+				hd->ioc->spi_data.nvram[id] = data;
+			}
 		}
 		break;
 	}
@@ -7185,8 +7241,6 @@
 	char *pc, *pv;
 	unsigned long val;
 	int  c;
-
-	printk("KERN_WARNING: mptscsih_setup arg %s\n", str);
 
 	while (cur != NULL && (pc = strchr(cur, ':')) != NULL) {
 		char *pe;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/mptscsih.h linux/drivers/message/fusion/mptscsih.h
--- ../prev/linux/drivers/message/fusion/mptscsih.h	Tue Jul  9 18:04:13 2002
+++ linux/drivers/message/fusion/mptscsih.h	Tue Jun  4 15:09:11 2002
@@ -20,7 +20,7 @@
  *  (mailto:netscape.net)
  *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptscsih.h,v 1.16 2002/02/27 18:44:30 sralston Exp $
+ *  $Id: mptscsih.h,v 1.17 2002/05/06 18:29:05 pdelaney Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -73,7 +73,8 @@
  *	Try to keep these at 2^N-1
  */
 #define MPT_FC_CAN_QUEUE	63
-#define MPT_SCSI_CAN_QUEUE	31
+//#define MPT_SCSI_CAN_QUEUE	31
+#define MPT_SCSI_CAN_QUEUE	MPT_FC_CAN_QUEUE
 #define MPT_SCSI_CMD_PER_LUN	 7
 
 #define MPT_SCSI_SG_DEPTH	40
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/t10.org/op-num.txt linux/drivers/message/fusion/t10.org/op-num.txt
--- ../prev/linux/drivers/message/fusion/t10.org/op-num.txt	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/t10.org/op-num.txt	Wed Dec 31 17:00:00 1969
@@ -1,234 +0,0 @@
-File: OP-NUM.TXT
-
-SCSI Operation Codes
-Numeric Sorted Listing
-as of  3/21/00
-
-    D - DIRECT ACCESS DEVICE (SBC)                     device column key
-    .T - SEQUENTIAL ACCESS DEVICE (SSC)               -------------------
-    . L - PRINTER DEVICE (SSC)                        M = Mandatory
-    .  P - PROCESSOR DEVICE (SPC)                     O = Optional
-    .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC)     V = Vendor specific
-    .  . R - CD DEVICE (MMC)                          Z = Obsolete
-    .  .  S - SCANNER DEVICE (SCSI-2)
-    .  .  .O - OPTICAL MEMORY DEVICE (SBC)
-    .  .  . M - MEDIA CHANGER DEVICE (SMC)
-    .  .  .  C - COMMUNICATION DEVICE (SCSI-2)
-    .  .  .  .A - STORAGE ARRAY DEVICE (SCC)
-    .  .  .  . E - ENCLOSURE SERVICES DEVICE (SES)
-    .  .  .  .  B - SIMPLIFIED DIRECT-ACCESS DEVICE (RBC)
-    .  .  .  .  .K - OPTICAL CARD READER/WRITER DEVICE (OCRW)
-OP  DTLPWRSOMCAEBK  Description
---  --------------  ----------------------------------------------------
-00  MMMMMMMMMMMMMM  TEST UNIT READY
-01   M              REWIND
-01  Z V ZZ ZO       REZERO UNIT
-02  VVVVVV  V
-03  MMMMMMMMMMMM M  REQUEST SENSE
-04  M    O O        FORMAT UNIT
-04   O              FORMAT MEDIUM
-04    O             FORMAT
-05  VMVVVV  V       READ BLOCK LIMITS
-06  VVVVVV  V
-07  OVV O  OV       REASSIGN BLOCKS
-07          O       INITIALIZE ELEMENT STATUS
-08  O V OO OV       READ(06)
-08   M              READ
-08     O            RECEIVE
-08           M      GET MESSAGE(06)
-09  VVVVVV  V
-0A  O   O  OV       WRITE(06)
-0A   M              WRITE
-0A     M            SEND(06)
-0A           M      SEND MESSAGE(06)
-0A    M             PRINT
-0B  Z   ZO ZV       SEEK(06)
-0B    O             SLEW AND PRINT
-0C  VVVVVV  V
-0D  VVVVVV  V
-0E  VVVVVV  V
-0F  VOVVVV  V       READ REVERSE
-10  VM VVV          WRITE FILEMARKS
-10    O O           SYNCHRONIZE BUFFER
-11  VMVVVV          SPACE(6)
-12  MMMMMMMMMMMMMM  INQUIRY
-13  V VVVV
-13   O              VERIFY
-14  VOOVVV          RECOVER BUFFERED DATA
-15  OMO OOOOOOOO O  MODE SELECT(06)
-16  MMMOMOMM  OO O  RESERVE(06)
-16          M       RESERVE ELEMENT(06)
-17  MMMOMOMM  OO O  RELEASE(06)
-17          M       RELEASE ELEMENT(06)
-18  OOOOOOOO     O  COPY
-19  VMVVVV          ERASE
-1A  OMO OOOOOOOO O  MODE SENSE(06)
-1B  O   OM O  O MO  STOP START UNIT
-1B   O              LOAD UNLOAD
-1B        O         SCAN
-1B    O             STOP PRINT
-1C  OOOOOOOOOOOM O  RECEIVE DIAGNOSTIC RESULTS
-1D  MMMMMMMMMMOM M  SEND DIAGNOSTIC
-1E  OO  OM OO    O  PREVENT ALLOW MEDIUM REMOVAL
-1F
-20  V   VV V     V
-21  V   VV V     V
-22  V   VV V     V
-23  V   V  V     V
-23       O          READ FORMAT CAPACITIES
-24  V   VVM         SET WINDOW
-25  M   MM M        READ CAPACITY
-25               M  READ CARD CAPACITY
-25        O         GET WINDOW
-26  V   VV
-27  V   VV
-28  M   MMMM    MM  READ(10)
-28           O      GET MESSAGE(10)
-29  V   VV O        READ GENERATION
-2A  M   MM M    MO  WRITE(10)
-2A        O         SEND(10)
-2A           O      SEND MESSAGE(10)
-2B  O   OM O     O  SEEK(10)
-2B   O              LOCATE(10)
-2B          O       POSITION TO ELEMENT
-2C  V    O O        ERASE(10)
-2D  V   O  O        READ UPDATED BLOCK
-2E  O   OO O    MO  WRITE AND VERIFY(10)
-2F  O   OO O        VERIFY(10)
-30  Z   ZZ Z        SEARCH DATA HIGH(10)
-31  Z   ZZ Z        SEARCH DATA EQUAL(10)
-31        O         OBJECT POSITION
-32  Z   ZZ Z        SEARCH DATA LOW(10)
-33  O   OO O        SET LIMITS(10)
-34  O   OO O     O  PRE-FETCH(10)
-34   M              READ POSITION
-34        O         GET DATA BUFFER STATUS
-35  O   OM O    MO  SYNCHRONIZE CACHE(10)
-36  O   OO O     O  LOCK UNLOCK CACHE(10)
-37  O      O        READ DEFECT DATA(10)
-38      O  O     O  MEDIUM SCAN
-39  OOOOOOOO     O  COMPARE
-3A  OOOOOOOO     O  COPY AND VERIFY
-3B  OOOOOOOOOOOOMO  WRITE BUFFER
-3C  OOOOOOOOOOO  O  READ BUFFER
-3D      O  O        UPDATE BLOCK
-3E  O   OO O        READ LONG
-3F  O   O  O        WRITE LONG
-40  ZZZZZZZZZZ      CHANGE DEFINITION
-41  O               WRITE SAME(10)
-42       M          READ SUB-CHANNEL
-43       M          READ TOC/PMA/ATIP
-44   M              REPORT DENSITY SUPPORT
-44       M          READ HEADER
-45       O          PLAY AUDIO(10)
-46       O          GET CONFIGURATION
-47       O          PLAY AUDIO MSF
-48       Z          PLAY AUDIO TRACK INDEX
-49       Z          PLAY TRACK RELATIVE(10)
-4A       O          GET EVENT STATUS NOTIFICATION
-4B       O          PAUSE/RESUME
-4C  OOOOOOOOOOO  O  LOG SELECT
-4D  OOOOOOOOOOO  O  LOG SENSE
-4E       O          STOP PLAY/SCAN
-4F
-50  O               XDWRITE(10)
-51  O               XPWRITE(10)
-51       M          READ DISC INFORMATION
-52  O               XDREAD(10)
-52       M          READ TRACK INFORMATION
-53       M          RESERVE TRACK
-54       O          SEND OPC INFORMATION
-55  OOO OOOOOOOOMO  MODE SELECT(10)
-56  MMMOMMMM  OO    RESERVE(10)
-56          M       RESERVE ELEMENT(10)
-57  MMMOMMMM  OO    RELEASE(10)
-57          M       RELEASE ELEMENT(10)
-58       O          REPAIR TRACK
-59       O          READ MASTER CUE
-5A  OOO OOOOOOOOMO  MODE SENSE(10)
-5B       M          CLOSE TRACK/SESSION
-5C       O          READ BUFFER CAPACITY
-5D       O          SEND CUE SHEET
-5E  OOOOOOOOO OO    PERSISTENT RESERVE IN
-5F  OOOOOOOOO OO    PERSISTENT RESERVE OUT
-80  O               XDWRITE EXTENDED(16)
-81  O               REBUILD(16)
-82  O               REGENERATE(16)
-83  OOOOOOOO     O  EXTENDED COPY
-84  OOOOOOOO     O  RECEIVE COPY RESULTS
-85
-86                  ACCESS CONTROL IN  [proposed]
-87                  ACCESS CONTROL OUT  [proposed]
-88  O   OO O    O   READ(16)
-89                  DEVICE LOCKS  [proposed]
-8A  O   O  O    O   WRITE(16)
-8B
-8C                  READ ATTRIBUTES [proposed]
-8D                  WRITE ATTRIBUTES [proposed]
-8E  O   O  O    O   WRITE AND VERIFY(16)
-8F  O   OO O    O   VERIFY(16)
-90  O   OO O    O   PRE-FETCH(16)
-91  O   OO O    O   SYNCHRONIZE CACHE(16)
-91   O              SPACE(16) [1]
-92  O   OO O        LOCK UNLOCK CACHE(16)
-92   O              LOCATE(16) [1]
-93  O               WRITE SAME(16)
-94                  [usage proposed by SCSI Socket Services project]
-95                  [usage proposed by SCSI Socket Services project]
-96                  [usage proposed by SCSI Socket Services project]
-97                  [usage proposed by SCSI Socket Services project]
-98                  MARGIN CONTROL [proposed]
-99
-9A
-9B
-9C
-9D
-9E                  SERVICE ACTION IN [proposed]
-9F                  SERVICE ACTION OUT [proposed]
-A0  OOOOOOOOOOMO O  REPORT LUNS
-A1       O          BLANK
-A2       O          SEND EVENT
-A3  OOO O  OOOMO    MAINTENANCE (IN)
-A3       O          SEND KEY
-A4  OOO O  OOOOO    MAINTENANCE (OUT)
-A4       O          REPORT KEY
-A5   O      M       MOVE MEDIUM
-A5       O          PLAY AUDIO(12)
-A6          O       EXCHANGE MEDIUM
-A6       O          LOAD/UNLOAD C/DVD
-A7  OO  O  OO       MOVE MEDIUM ATTACHED
-A7       O          SET READ AHEAD
-A8      OM O        READ(12)
-A8           O      GET MESSAGE(12)
-A9       Z          PLAY TRACK RELATIVE(12)
-AA      O  O        WRITE(12)
-AA           O      SEND MESSAGE(12)
-AB
-AC         O        ERASE(12)
-AC       O          GET PERFORMANCE
-AD         O        READ DVD STRUCTURE
-AE      O  O        WRITE AND VERIFY(12)
-AF      OZ O        VERIFY(12)
-B0      ZZ Z        SEARCH DATA HIGH(12)
-B1      ZZ Z        SEARCH DATA EQUAL(12)
-B2      ZZ Z        SEARCH DATA LOW(12)
-B3      OO O        SET LIMITS(12)
-B4  OO  OZ OO       READ ELEMENT STATUS ATTACHED
-B5          O       REQUEST VOLUME ELEMENT ADDRESS
-B6          O       SEND VOLUME TAG
-B6       O          SET STREAMING
-B7         O        READ DEFECT DATA(12)
-B8   O   Z  M       READ ELEMENT STATUS
-B9       M          READ CD MSF
-BA  O   O  OO MO    REDUNDANCY GROUP (IN)
-BA       O          SCAN
-BB  O   O  OO OO    REDUNDANCY GROUP (OUT)
-BB       O          SET CD-ROM SPEED
-BC  O   O  OO MO    SPARE (IN)
-BC       O          PLAY CD
-BD  O   O  OO OO    SPARE (OUT)
-BD       M          MECHANISM STATUS
-BE  O   O  OO MO    VOLUME SET (IN)
-BE       O          READ CD
-BF  O   O  OO OO    VOLUME SET (OUT)
-BF       O          SEND DVD STRUCTURE
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/t10.org/stds.txt linux/drivers/message/fusion/t10.org/stds.txt
--- ../prev/linux/drivers/message/fusion/t10.org/stds.txt	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/t10.org/stds.txt	Wed Dec 31 17:00:00 1969
@@ -1,120 +0,0 @@
-File: STDS.TXT
-
-SCSI Standards Version Descriptor Value Assignments
-as of  3/29/00
-
-Code  Standard
------ ----------------------------------------------------------------
-14BDh ANSI IEEE 1394:1995
-0B20h EPI (no version claimed)
-0B3Ch EPI ANSI NCITS TR-23:1999
-0B3Bh EPI T10/1134 revision 16
-0D40h FC-AL (no version claimed)
-0D5Ch FC-AL ANSI X3.272:1996
-0D60h FC-AL-2 (no version claimed)
-0D61h FC-AL-2 T11/1133 revision 7.0
-1320h FC-FLA (no version claimed)
-133Ch FC-FLA ANSI NCITS TR-20:1998
-133Bh FC-FLA T11/1235 revision 7
-0DA0h FC-FS (no version claimed)
-0D20h FC-PH (no version claimed)
-0D3Bh FC-PH ANSI X3.230:1994
-0D3Ch FC-PH ANSI X3.230:1994 with Amnd 1 ANSI X3.230/AM1:1996
-0D80h FC-PH-3 (no version claimed)
-0D9Ch FC-PH-3 ANSI X3.303-1998
-1340h FC-PLDA (no version claimed)
-135Ch FC-PLDA ANSI NCITS TR-19:1998
-135Bh FC-PLDA T11/1162 revision 2.1
-1300h FC-Tape (no version claimed)
-1301h FC-Tape T11/1315 revision 1.16
-08C0h FCP (no version claimed)
-08DCh FCP ANSI X3.269:1996
-08DBh FCP T10/0993 revision 12
-0900h FCP-2 (no version claimed)
-0901h FCP-2 T10/1144 revision 4
-0AC0h Fast-20 (no version claimed)
-0ADCh Fast-20 ANSI X3.277:1996
-0ADBh Fast-20 T10/1071 revision 06
-14A0h IEEE 1394 (no version claimed)
-14C0h IEEE 1394a (no version claimed)
-14E0h IEEE 1394b (no version claimed)
-0140h MMC (no version claimed)
-015Ch MMC ANSI X3.304:1997
-015Bh MMC T10/1048 revision 10a
-0240h MMC-2 (no version claimed)
-0255h MMC-2 T10/1228 revision 11
-02A0h MMC-3 (no version claimed)
-0280h OCRW (no version claimed)
-029Eh OCRW ISO/IEC 14776-381
-0220h RBC (no version claimed)
-0238h RBC T10/1240 revision 10a
-02C0h RMC (no version claimed)
-0020h SAM (no version claimed)
-003Ch SAM ANSI X3.270:1996
-003Bh SAM T10/0994 revision 18
-0040h SAM-2 (no version claimed)
-0180h SBC (no version claimed)
-019Ch SBC ANSI NCITS.306:1998
-019Bh SBC T10/0996 revision 08c
-0320h SBC-2 (no version claimed)
-08E0h SBP-2 (no version claimed)
-08FCh SBP-2 ANSI NCITS.325:1999
-08FBh SBP-2 T10/1155 revision 04
-0160h SCC (no version claimed)
-017Ch SCC ANSI X3.276:1997
-017Bh SCC T10/1047 revision 06c
-01E0h SCC-2 (no version claimed)
-01FCh SCC-2 ANSI NCITS.318:1998
-01FBh SCC-2 T10/1125 revision 04
-01C0h SES (no version claimed)
-01DCh SES ANSI NCITS.305:1998
-01DBh SES T10/1212 revision 08b
-08A0h SIP (no version claimed)
-08BCh SIP ANSI X3.292:1997
-08BBh SIP T10/0856 revision 10
-01A0h SMC (no version claimed)
-01BCh SMC ANSI NCITS.314:1998
-01BBh SMC T10/0999 revision 10a
-02E0h SMC-2 (no version claimed)
-0120h SPC (no version claimed)
-013Ch SPC ANSI X3.301:1997
-013Bh SPC T10/0995 revision 11a
-0260h SPC-2 (no version claimed)
-0267h SPC-2 T10/1236 revision 12
-0300h SPC-3 (no version claimed)
-0AA0h SPI (no version claimed)
-0ABAh SPI ANSI X3.253:1995
-0ABCh SPI ANSI X3.253:1995 with SPI Amnd ANSI X3.253/AM1:1998
-0AB9h SPI T10/0855 revision 15a
-0ABBh SPI T10/0855 revision 15a with SPI Amnd revision 3a
-0AE0h SPI-2 (no version claimed)
-0AFCh SPI-2 ANSI X3.302:1999
-0AFBh SPI-2 T10/1142 revision 20b
-0B00h SPI-3 (no version claimed)
-0B18h SPI-3 T10/1302-D revision 10
-0B19h SPI-3 T10/1302-D revision 13a
-0B40h SPI-4 (no version claimed)
-1360h SSA-PH2 (no version claimed)
-137Ch SSA-PH2 ANSI X3.293:1996
-137Bh SSA-PH2 T10.1/1145 revision 09c
-1380h SSA-PH3 (no version claimed)
-139Ch SSA-PH3 ANSI NCITS.307:1998
-139Bh SSA-PH3 T10.1/1146 revision 05b
-0880h SSA-S2P (no version claimed)
-089Ch SSA-S2P ANSI X3.294:1996
-089Bh SSA-S2P T10.1/1121 revision 07b
-0860h SSA-S3P (no version claimed)
-087Ch SSA-S3P ANSI NCITS.309:1998
-087Bh SSA-S3P T10.1/1051 revision 05b
-0840h SSA-TL1 (no version claimed)
-085Ch SSA-TL1 ANSI X3.295:1996
-085Bh SSA-TL1 T10.1/0989 revision 10b
-0820h SSA-TL2 (no version claimed)
-083Ch SSA-TL2 ANSI NCITS.308:1998
-083Bh SSA-TL2 T10.1/1147 revision 05b
-0200h SSC (no version claimed)
-0201h SSC T10/0997 revision 17
-0207h SSC T10/0997 revision 22
-0920h SST (no version claimed)
-0940h SVP (no version claimed)
-0000h Version Descriptor Not Supported or No Standard Identified
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/t10.org/vendorid.txt linux/drivers/message/fusion/t10.org/vendorid.txt
--- ../prev/linux/drivers/message/fusion/t10.org/vendorid.txt	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/t10.org/vendorid.txt	Wed Dec 31 17:00:00 1969
@@ -1,340 +0,0 @@
-This file contains the list of T10 Technical Committee vendor identifications 
-as of 2000/06/16 at 16:03:08.  The purpose of this list is to help avoid redundant
-usage of vendor identifications.   T10, a subcommittee of the National
-Committee on Information Technology Standards (NCITS), maintains an 
-informal list of vendor identifications currently in use.  Please contact 
-the chairman of T10 prior to using a new vendor identification to avoid 
-conflicts.
-
-        John Lohmeyer, Chair T10 Technical Committee
-        LSI Logic Corp.
-        4420 ArrowsWest Dr.
-        Colorado Springs, CO 80907
-        Tel: 719-533-7560
-        Fax: 719-533-7183
-        Email: lohmeyer@t10.org
-
-When requesting a new vendor ID, please specify your preferred vendor ID 
-code and your organization name EXACTLY as you would like it to appear in
-this list.  There are a few simple rules to follow:
-
-   1.   The Vendor ID code shall be 8 or fewer ASCII graphic characters
-        (codes 21h through 7Eh).  Spaces (20h) are added to the right to
-        make exactly 8 characters.
-
-   2.   The Organization Name shall be 68 or fewer ASCII graphic characters
-        (codes 20h through 7Eh).
-
-   3.   Please avoid requesting previously assigned vendor IDs.  While the
-        committee list includes both upper and lowercase characters, 
-        vendor IDs that are the same as an existing ID except for case 
-        will not be accepted.
-
- Vendor ID                          Organization
- --------- ---------------------------------------------------------------
- 3M        3M Company
- ACL       Automated Cartridge Librarys, Inc.
- AcuLab    AcuLab, Inc. (Tulsa, OK)
- ADAPTEC   Adaptec
- ADIC      Advanced Digital Information Corporation
- ADSI      Adaptive Data Systems, Inc. (a Western Digital subsidiary)
- ADTX      ADTX Co., Ltd.
- AERONICS  Aeronics, Inc.
- AGFA      AGFA
- AMCODYNE  Amcodyne
- ANAMATIC  Anamartic Limited (England)
- Ancor     Ancor Communications, Inc.
- ANCOT     ANCOT Corp.
- ANDATACO  Andataco  (now nStor)
- ANRITSU   Anritsu Corporation
- APPLE     Apple Computer, Inc.
- ARCHIVE   Archive
- ARK       ARK Research Corporation
- ARTECON   Artecon Inc.  (Obs. - now Dot Hill)
- ASACA     ASACA Corp.
- ASC       Advanced Storage Concepts, Inc.
- ASPEN     Aspen Peripherals
- AST       AST Research
- ASTK      Alcatel STK A/S
- AT&T      AT&T
- ATARI     Atari Corporation
- ATG CYG   ATG Cygnet Inc.
- ATTO      ATTO Technology Inc.
- ATX       Alphatronix
- AVR       Advanced Vision Research
- BALLARD   Ballard Synergy Corp.
- BERGSWD   Berg Software Design
- BEZIER    Bezier Systems, Inc.
- BHTi      Breece Hill Technologies
- BiT       BiT Microsystems (obsolete, new ID: BITMICRO)
- BITMICRO  BiT Microsystems, Inc.
- BNCHMARK  Benchmark Tape Systems Corporation
- BoxHill   Box Hill Systems Corporation  (Obs. - now Dot Hill)
- BREA      BREA Technologies, Inc.
- BULL      Bull Peripherals Corp.
- BUSLOGIC  BusLogic Inc.
- CalComp   CalComp, A Lockheed Company
- CALIPER   Caliper (California Peripheral Corp.)
- CAST      Advanced Storage Tech
- CDC       Control Data or MPI
- CDP       Columbia Data Products
- CenData   Central Data Corporation
- Cereva    Cereva Networks Inc.
- CHEROKEE  Cherokee Data Systems
- CHINON    Chinon
- CIE&YED   YE Data, C.Itoh Electric Corp.
- CIPHER    Cipher Data Products
- Ciprico   Ciprico, Inc.
- CIRRUSL   Cirrus Logic Inc.
- CMD       CMD Technology Inc.
- CNGR SFW  Congruent Software, Inc.
- CNSi      Chaparral Network Storage, Inc.
- COGITO    Cogito
- COMPAQ    Compaq Computer Corporation
- COMPORT   Comport Corp.
- COMPSIG   Computer Signal Corporation
- COMPTEX   Comptex Pty Limited
- CONNER    Conner Peripherals
- CORE      Core International, Inc.
- CPL       Cross Products Ltd
- CPU TECH  CPU Technology, Inc.
- CREO      Creo Products Inc.
- CROSFLD   Crosfield Electronics (now FujiFilm Electonic Imaging Ltd)
- CROSSRDS  Crossroads Systems, Inc.
- CSM, INC  Computer SM, Inc.
- Data Com  Data Com Information Systems Pty. Ltd.
- DATABOOK  Databook, Inc.
- DATACOPY  Datacopy Corp.
- DataCore  DataCore Software Corporation
- DATAPT    Datapoint Corp.
- DEC       Digital Equipment (Obsolete: New products use 'COMPAQ')
- DEI       Digital Engineering, Inc.
- DELL      Dell Computer Corporation
- DELPHI    Delphi Data Div. of Sparks Industries, Inc.
- DENON     Denon/Nippon Columbia
- DenOptix  DenOptix, Inc.
- DEST      DEST Corp.
- DGC       Data General Corp.
- DIGIDATA  Digi-Data Corporation
- DigiIntl  Digi International
- Digital   Digital Equipment Corporation (Obs: New products use 'COMPAQ')
- DILOG     Distributed Logic Corp.
- DISC      Document Imaging Systems Corp.
- DotHill   Dot Hill Systems Corp.
- DPT       Distributed Processing Technology
- DSI       Data Spectrum, Inc.
- DSM       Deterner Steuerungs- und Maschinenbau GmbH & Co.
- DTC QUME  Data Technology Qume
- DXIMAGIN  DX Imaging
- ECCS      ECCS, Inc.
- ECMA      European Computer Manufacturers Association
- Elms      Elms Systems Corporation
- EMASS     EMASS, Inc.
- EMC       EMC Corp.
- EMTEC     EMTEC Magnetics
- EMULEX    Emulex
- EPSON     Epson
- Eris/RSI  RSI Systems, Inc.
- EuroLogc  Eurologic Systems Limited
- EXABYTE   Exabyte Corp.
- FFEILTD   FujiFilm Electonic Imaging Ltd
- FILENET   FileNet Corp.
- FRAMDRV   FRAMEDRIVE Corp.
- FUJI      Fuji Electric Co., Ltd. (Japan)
- FUJIFILM  Fuji Photo Film, Co., Ltd.
- FUJITSU   Fujitsu
- FUNAI     Funai Electric Co., Ltd.
- FUTURED   Future Domain Corp.
- G&D       Giesecke & Devrient GmbH
- GENSIG    General Signal Networks
- Gen_Dyn   General Dynamics
- GIGATAPE  GIGATAPE GmbH
- GIGATRND  GigaTrend Incorporated
- Global    Global Memory Test Consortium
- Goidelic  Goidelic Precision, Inc.
- GoldStar  LG Electronics Inc.
- GOULD     Gould
- HAGIWARA  Hagiwara Sys-Com Co., Ltd.
- HITACHI   Hitachi America Ltd or Nissei Sangyo America Ltd
- HONEYWEL  Honeywell Inc.
- HP        Hewlett Packard
- i-cubed   i-cubed ltd.
- IBM       International Business Machines
- ICL       ICL
- ICP       ICP vortex Computersysteme GmbH
- IDE       International Data Engineering, Inc.
- IGR       Intergraph Corp.
- IMATION   Imation
- IMPLTD    Integrated Micro Products Ltd.
- IMPRIMIS  Imprimis Technology Inc.
- Indigita  Indigita Corporation
- INITIO    Initio Corporation
- INSITE    Insite Peripherals
- INTEL     Intel Corporation
- IOC       I/O Concepts, Inc.
- IOMEGA    Iomega
- ISi       Information Storage inc.
- ISO       International Standards Organization
- ITC       International Tapetronics Corporation
- JPC Inc.  JPC Inc.
- JVC       JVC Information Products Co.
- KENNEDY   Kennedy Company
- KENWOOD   KENWOOD Corporation
- KODAK     Eastman Kodak
- KONAN     Konan
- KONICA    Konica Japan
- Kyocera   Kyocera Corporation
- LAPINE    Lapine Technology
- LASERDRV  LaserDrive Limited
- LASERGR   Lasergraphics, Inc.
- LG        LG Electronics Inc.
- LGE       LG Electronics Inc.
- LION      Lion Optics Corporation
- LMS       Laser Magnetic Storage International Company
- LSI       LSI Logic Corp.
- LSILOGIC  LSI Logic Storage Systems, Inc.
- LTO-CVE   Linear Tape - Open, Compliance Verification Entity
- MATSHITA  Matsushita
- MAXELL    Hitachi Maxell, Ltd.
- MaxOptix  Maxoptix Corp.
- MAXSTRAT  Maximum Strategy, Inc.
- MAXTOR    Maxtor Corp.
- McDATA    McDATA Corporation
- MDI       Micro Design International, Inc.
- MEADE     Meade Instruments Corporation
- MEII      Mountain Engineering II, Inc.
- MELA      Mitsubishi Electronics America
- MELCO     Mitsubishi Electric (Japan)
- MEMREL    Memrel Corporation
- MEMTECH   MemTech Technology
- MERIDATA  Oy Meridata Finland Ltd
- METRUM    Metrum, Inc.
- MICROBTX  Microbotics Inc.
- MICROP    Micropolis
- MICROTEK  Microtek Storage Corp
- Minitech  Minitech (UK) Limited
- Minolta   Minolta Corporation
- MINSCRIB  Miniscribe
- MITSUMI   Mitsumi Electric Co., Ltd.
- MOSAID    Mosaid Technologies Inc.
- MOTOROLA  Motorola
- MPM       Mitsubishi Paper Mills, Ltd.
- MST       Morning Star Technologies, Inc.
- MTNGATE   MountainGate Data Systems
- NAI       North Atlantic Industries
- NAKAMICH  Nakamichi Corporation
- NatInst   National Instruments
- NatSemi   National Semiconductor Corp.
- NCITS     National Committee for Information Technology Standards
- NCL       NCL America
- NCR       NCR Corporation
- NEC       NEC
- NEXSAN    Nexsan Technologies, Ltd.
- NISCA     NISCA Inc.
- NKK       NKK Corp.
- NRC       Nakamichi Research Corporation
- NSD       Nippon Systems Development Co.,Ltd.
- NSM       NSM Jukebox GmbH
- nStor     nStor Technologies, Inc.
- NT        Northern Telecom
- OAI       Optical Access International
- OCE       Oce Graphics
- OKI       OKI Electric Industry Co.,Ltd (Japan)
- OMI       Optical Media International
- OMNIS     OMNIS Company (FRANCE)
- OPTIMEM   Cipher/Optimem
- OPTOTECH  Optotech
- ORANGE    Orange Micro, Inc.
- ORCA      Orca Technology
- OSI       Optical Storage International
- OTL       OTL Engineering
- PASCOsci  Pasco Scientific
- PATHLGHT  Pathlight Technology, Inc.
- PERTEC    Pertec Peripherals Corporation
- PFTI      Performance Technology Inc.
- PFU       PFU Limited
- PICO      Packard Instrument Company
- PIONEER   Pioneer Electronic Corp.
- PLASMON   Plasmon Data
- PRAIRIE   PrairieTek
- PREPRESS  PrePRESS Solutions
- PRESOFT   PreSoft Architects
- PRESTON   Preston Scientific
- PRIAM     Priam
- PRIMAGFX  Primagraphics Ltd
- PROCOM    Procom Technology
- PTI       Peripheral Technology Inc.
- QIC       Quarter-Inch Cartridge Drive Standards, Inc.
- QUALSTAR  Qualstar
- QUANTEL   Quantel Ltd.
- QUANTUM   Quantum Corp.
- R-BYTE    R-Byte, Inc.
- RACALREC  Racal Recorders
- RADSTONE  Radstone Technology
- RGI       Raster Graphics, Inc.
- RHS       Racal-Heim Systems GmbH
- RICOH     Ricoh
- RODIME    Rodime
- RTI       Reference Technology
- SAMSUNG   Samsung Electronics Co., Ltd.
- SAN       Storage Area Networks, Ltd.
- SANKYO    Sankyo Seiki
- SANYO     SANYO Electric Co., Ltd.
- SCInc.    Storage Concepts, Inc.
- SCREEN    Dainippon Screen Mfg. Co., Ltd.
- SDI       Storage Dimensions, Inc.
- SDS       Solid Data Systems
- SEAGATE   Seagate
- SEQUOIA   Sequoia Advanced Technologies, Inc.
- Shinko    Shinko Electric Co., Ltd.
- SIEMENS   Siemens
- SII       Seiko Instruments Inc.
- SMS       Scientific Micro Systems/OMTI
- SNYSIDE   Sunnyside Computing Inc.
- SONIC     Sonic Solutions
- SONY      Sony Corporation Japan
- SPD       Storage Products Distribution, Inc.
- SPECIAL   Special Computing Co.
- SPECTRA   Spectra Logic, a Division of Western Automation Labs, Inc.
- SPERRY    Sperry (now Unisys Corp.)
- Sterling  Sterling Diagnostic Imaging, Inc.
- STK       Storage Technology Corporation
- STORAPP   StorageApps, Inc.
- STORM     Storm Technology, Inc.
- StrmLgc   StreamLogic Corp.
- SUMITOMO  Sumitomo Electric Industries, Ltd.
- SUN       Sun Microsystems, Inc.
- SYMBIOS   Symbios Logic Inc.
- SyQuest   SyQuest Technology, Inc.
- SYSGEN    Sysgen
- T-MITTON  Transmitton England
- TALARIS   Talaris Systems, Inc.
- TALLGRAS  Tallgrass Technologies
- TANDBERG  Tandberg Data A/S
- TANDON    Tandon
- TDK       TDK Corporation
- TEAC      TEAC Japan
- TECOLOTE  Tecolote Designs
- TEGRA     Tegra Varityper
- Tek       Tektronix
- TENTIME   Laura Technologies, Inc.
- TI-DSG    Texas Instruments
- TMS       Texas Memory Systems, Inc.
- TOSHIBA   Toshiba Japan
- TRIPACE   Tripace
- ULTRA     UltraStor Corporation
- UNISYS    Unisys
- USCORE    Underscore, Inc.
- USDC      US Design Corp.
- VDS       Victor Data Systems Co., Ltd.
- VERBATIM  Verbatim Corporation
- VEXCEL    VEXCEL IMAGING GmbH
- VICOMSL1  Vicom Systems, Inc.
- VRC       Vermont Research Corp.
- WangDAT   WangDAT
- WANGTEK   Wangtek
- WDIGTL    Western Digital
- WEARNES   Wearnes Technology Corporation
- WSC0001   Wisecom, Inc.
- X3        National Committee for Information Technology Standards (NCITS)
- XEBEC     Xebec Corporation
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/utils/Config.help linux/drivers/message/fusion/utils/Config.help
--- ../prev/linux/drivers/message/fusion/utils/Config.help	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/utils/Config.help	Wed Dec 31 17:00:00 1969
@@ -1,112 +0,0 @@
-
-Fusion MPT device support
-CONFIG_FUSION
-  LSI Logic Fusion(TM) Message Passing Technology (MPT) device support
-  provides high performance SCSI host initiator, and LAN [1] interface
-  services to a host system.  The Fusion architecture is capable of
-  duplexing these protocols on high-speed Fibre Channel
-  (up to 2 GHz x 2 ports = 4 GHz) and parallel SCSI (up to Ultra-320)
-  physical medium.
-
-          [1] LAN is not supported on parallel SCSI medium.
-
-  These drivers require a Fusion MPT compatible PCI adapter installed in
-  the host system.  MPT adapters contain specialized I/O processors
-  to handle I/O workload, and more importantly to offload this work
-  from the host CPU(s).
-
-  If you have Fusion MPT hardware and want to use it, you can say
-  Y or M here to add MPT (base + ScsiHost) drivers.
-    <Y> = build lib (fusion.o), and link [static] into the kernel [2] proper
-    <M> = compiled as [dynamic] modules [3] named: (mptbase.o, mptscsih.o)
-
-          [2] In order enable capability to boot the linux kernel natively
-              from a Fusion MPT target device, you MUST answer Y here!
-              (currently requires CONFIG_BLK_DEV_SD)
-          [3] This support is also available as a module
-              ( = code which can be inserted in and removed
-              from the running kernel whenever you want).
-              If you want to compile as modules, say M here and read
-              Documentation/modules.txt.
-
-  If unsure, say N.
-
-  If you say Y or M here you will get a choice of these
-  additional protocol and support module options:           Module Name:
-    <M>   Enhanced SCSI error reporting                       (isense.o)
-    <M>   Fusion MPT misc device (ioctl) driver               (mptctl.o)
-    <M>   Fusion MPT LAN driver                               (mptlan.o)
-
-  ---
-  Fusion MPT is trademark of LSI Logic Corporation, and it's architecture
-  is based on LSI Logic's Message Passing Interface (MPI) specification.
-
-Fusion MPT enhanced SCSI error reporting [optional] module
-CONFIG_FUSION_ISENSE
-  The isense module (roughly stands for Interpret SENSE data) is
-  completely optional.  It simply provides extra English readable
-  strings in SCSI Error Report(s) that might be generated from the
-  Fusion MPT SCSI Host driver, for example when a target device
-  returns a SCSI check condition on a I/O.  Without this module
-  loaded you might see:
-
-    SCSI Error Report =-=-= (ioc0,scsi5:0)
-      SCSI_Status=02h (CHECK_CONDITION)
-      Original_CDB[]: 2A 00 00 00 00 41 00 00 02 00
-      SenseData[12h]: 70 00 02 00 00 00 00 0A 00 00 00 00 04 02 02 00 00 00
-      SenseKey=2h (NOT READY); FRU=02h
-      ASC/ASCQ=29h/00h
-
-  Where otherwise, if this module had been loaded, you would see:
-
-    SCSI Error Report =-=-= (ioc0,scsi5:0)
-      SCSI_Status=02h (CHECK_CONDITION)
-      Original_CDB[]: 2A 00 00 00 00 41 00 00 02 00 - "WRITE(10)"
-      SenseData[12h]: 70 00 02 00 00 00 00 0A 00 00 00 00 04 02 02 00 00 00
-      SenseKey=2h (NOT READY); FRU=02h
-      ASC/ASCQ=29h/00h "LOGICAL UNIT NOT READY, INITIALIZING CMD. REQUIRED"
-
-  Say M for "Enhanced SCSI error reporting" to compile this optional module,
-  creating a driver named: isense.o
-
-  NOTE: Support for building this feature into the kernel is not
-  available, due to kernel size considerations.
-
-Fusion MPT misc device (ioctl) driver [optional] module
-CONFIG_FUSION_CTL
-  The Fusion MPT misc device driver provides specialized control
-  of MPT adapters via system ioctl calls.  Use of ioctl calls to
-  the MPT driver requires that you create and use a misc device
-  node ala:
-    mknod /dev/mptctl c 10 220
-
-  One use of this ioctl interface is to perform an upgrade (reflash)
-  of the MPT adapter firmware.  Refer to readme file(s) distributed
-  with the Fusion MPT linux driver for additional details.
-
-  If enabled by saying M to this, a driver named: mptctl.o
-  will be compiled.
-
-  If unsure whether you really want or need this, say no.
-
-Fusion MPT LAN driver [optional]
-CONFIG_FUSION_LAN
-  This module supports LAN IP traffic over Fibre Channel port(s)
-  on Fusion MPT compatible hardware (LSIFC9xx chips).
-  The physical interface used is defined in RFC 2625.
-  Please refer to that document for details.
-
-  Installing this driver requires the knowledge to configure and
-  activate a new network interface, "fc0", using standard Linux tools.
-
-  If enabled by saying M to this, a driver named: mptlan.o
-  will be compiled.
-
-  If unsure whether you really want or need this, say no.
-
-  NOTES: This feature is NOT available nor supported for linux-2.2.x
-  kernels.  You must be building a linux-2.3.x or linux-2.4.x kernel
-  in order to configure this option.
-  Support for building this feature into the linux kernel is not
-  yet available.
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/utils/makefile linux/drivers/message/fusion/utils/makefile
--- ../prev/linux/drivers/message/fusion/utils/makefile	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/utils/makefile	Wed Dec 31 17:00:00 1969
@@ -1,42 +0,0 @@
-# drivers/message/fusion/utils/makefile
-
-ifndef $(TOPDIR)
-	TOPDIR = ../../../..
-endif
-ifndef $(HOSTCC)
-	CC = gcc
-endif
-
-BIG_CONFIG_HELP = $(TOPDIR)/Documentation/Configure.help
-
-CFLAGS = -g -O -Wall -I. -I.. -I$(TOPDIR)/include
-
-default all: check_fusion_help mptflash what mptfdu
-
-check_fusion_help: $(TOPDIR)/Documentation/Configure.help FRC
-	@ if ! grep '^Fusion MPT device support$$' $< >/dev/null 2>&1; then\
-		cat Config.help >> $<;\
-		echo "$@: Appended Fusion MPT help sections to ${<F}";\
-	else\
-		echo "$@: Check of ${<F} for Fusion MPT help sections: OK";\
-	fi
-
-$(TOPDIR)/Documentation/Configure.help: Config.help FRC
-
-
-clean:
-	rm -f *.o mptflash what mptfdu
-
-FRC:
-
-# Dependencies...
-mptflash.o: mptflash.c ../mptbase.h makefile
-what.o: what.c makefile
-mptfdu.o: mptfdu.c makefile\
-  ../mptbase.h ../linux_compat.h ../scsi3.h \
-  ../lsi/mpi_type.h ../lsi/mpi.h ../lsi/mpi_ioc.h \
-  ../lsi/mpi_cnfg.h ../lsi/mpi_init.h ../lsi/mpi_lan.h \
-  ../lsi/mpi_raid.h ../lsi/mpi_fc.h ../lsi/mpi_targ.h \
-  ../lsi/fc_log.h ../mptctl.h
-
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/utils/mptflash.c linux/drivers/message/fusion/utils/mptflash.c
--- ../prev/linux/drivers/message/fusion/utils/mptflash.c	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/utils/mptflash.c	Wed Dec 31 17:00:00 1969
@@ -1,533 +0,0 @@
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include "mptbase.h"
-#include "mptctl.h"
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-
-static char *mptflash_name_ver	= WHAT_MAGIC_STRING "MptFlash-" MPT_LINUX_VERSION_COMMON;
-
-/*
- *	Special/reserved names...
- */
-static char *ctlname	= MPT_MISCDEV_PATHNAME;
-static char *versearch	= MPT_FW_REV_MAGIC_ID_STRING;
-static int step = 0;
-
-/*
- *  Forward protos...
- */
-static char *get_oldver(char *results_buf, int iocnum);
-static char *what_search(const char *buf, int size_in, int *size_out);
-int verify_pid(char *fwbuf, struct mpt_fw_xfer *fwdata);
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-int
-main (int argc, char **argv)
-{
-	char userinp[128];
-	char newver[64];
-	char oldver[64];
-	char what2[64];
-	char *oldverp;
-	struct mpt_fw_xfer fwdata;
-	unsigned long ctlnum = MPTFWDOWNLOAD;
-	char *fwbuf;
-	int fwfd;
-	int ctlfd;
-	int size;
-	struct stat fwstat;
-	char *myname;
-	char *fwfname = NULL;
-	char *arg2 = NULL;
-	char *whatstr;
-	int whatsz;
-	int i, j;
-	u32 checksum;
-
-	if ( (myname = strrchr(argv[0], '/')) == NULL ) {
-		myname = argv[0];
-	} else {
-		myname++;
-		argv[0] = myname;
-	}
-	if (argc > 1)
-		fwfname = argv[1];
-	if (argc > 2)
-		arg2 = argv[2];
-	else
-		arg2 = "0";
-
-	step = 1;				/* step #1 */
-
-	if (!fwfname || strlen(fwfname)<1 || !arg2 || !isdigit(arg2[0]))
-	{
-		fprintf(stderr, "%s\n", mptflash_name_ver+4);
-		fprintf(stderr, "Usage: %s fwfname.rom [0|1|2|...|7 for ioc# ]\n", myname);
-		return step;
-	}
-	fprintf(stderr, "  step%d: Cmd line check: Ok\n", step);
-
-	fwdata.iocnum = atoi(arg2);
-	if (fwdata.iocnum > MPT_MAX_ADAPTERS || fwdata.iocnum < 0) {
-		fprintf(stderr, "  step%db: Cmd line Oops, resetting ioc from %d to 0\n", step, fwdata.iocnum);
-		fwdata.iocnum = 0;
-	}
-
-	++step;
-	if ((oldverp = get_oldver(oldver, fwdata.iocnum)) == NULL) {
-		oldverp = "unknown";
-	}
-	fprintf(stderr, "  step%d: get_oldver() results: \"%s\"\n",
-			step, oldverp);
-
-	/*
-	 *  Open f/w image file
-	 */
-	++step;
-	if ((fwfd = open(fwfname, O_RDONLY)) < 0) {
-		fprintf(stderr, "ERROR: open(\"%s\") FAILED: %s\n", fwfname, strerror(errno));
-		return step;
-	}
-	fprintf(stderr, "  step%d: open(\"%s\"): Ok, fwfd=%d\n", step, fwfname, fwfd);
-
-	/*
-	 *  Stat the f/w image file to get size
-	 */
-	++step;
-	if (fstat(fwfd, &fwstat) < 0) {
-		fprintf(stderr, "ERROR: fstat(%d) FAILED: %s\n",
-				fwfd, strerror(errno));
-		return step;
-	}
-	size = (int)fwstat.st_size;
-	fprintf(stderr, "  step%d: stat(\"%s\"): Ok, size=%d bytes\n",
-			step, fwfname, size);
-
-	/*
-	 *  Malloc big enough buffer for entire f/w image
-	 */
-	++step;
-	if ((fwbuf = malloc(size)) == NULL) {
-		fprintf(stderr, "ERROR: Firmware buffer malloc %d bytes FAILED: %s\n",
-				size, strerror(errno));
-		return step;
-	}
-	fprintf(stderr, "  step%d: malloc(%d): Ok\n", step, size);
-
-	bzero(fwbuf, size);
-
-	fwdata.fwlen = size;
-	fwdata.bufp = fwbuf;
-
-	/*
-	 *  Read all bytes from f/w image file to malloc'd buffer
-	 */
-	++step;
-	if ((j = read(fwfd, fwbuf, size)) < 0) {
-		fprintf(stderr, "ERROR: Firmware read from \"%s\" FAILED: %s\n",
-				fwfname, strerror(errno));
-		return step;
-	}
-	fprintf(stderr, "  step%d: read(%d,,%d): Ok\n", step, fwfd, size);
-
-	if (verify_pid(fwbuf, &fwdata) != 0)
-		exit(1);
-
-	/*
-	 * Checksum algorithm pulled from Stephen's lsiupdate utility
-	 * for Solaris. This should work for both little and big endian
-	 * systems.
-	 */
-
-	checksum = 0;
-	for (i = 0; i < j; i++)
-		checksum += ((U32)((U8)fwbuf[i])) << (8 * (i & 3));
-	if (checksum != 0) {
-		fprintf (stderr, "ERROR: Bad checksum for specified firmwware"
-			 " image (%s).\n", fwfname);
-		exit (1);
-	}
-
-	/*
-	 *  Scan file for new version (magic what string identifier)
-	 */
-	newver[0] = what2[0] = '\0';
-	if ((whatstr = what_search(fwbuf, size, &whatsz)) != NULL && whatsz) {
-		strncpy(newver, whatstr, MIN(sizeof(newver)-1, whatsz));
-		newver[MIN(sizeof(newver)-1, whatsz)] = '\0';
-		if ((whatstr = what_search(whatstr, size-(whatstr-fwbuf+whatsz), &whatsz)) != NULL && whatsz) {
-			strncpy(what2, whatstr, MIN(sizeof(what2)-1, whatsz));
-			what2[MIN(sizeof(what2)-1, whatsz)] = '\0';
-		}
-	}
-	fprintf(stderr, "         Current F/W Version = \"%s\"\n", oldverp);
-	fprintf(stderr, "             New F/W Version = \"%s\"\n", newver);
-
-	/*
-	 *  Open /dev/mptctl for ioctl() call
-	 */
-	++step;
-	if ((ctlfd = open(ctlname, O_RDWR)) < 0) {
-		fprintf(stderr, "ERROR: open(\"%s\") FAILED: %s\n", ctlname, strerror(errno));
-		return step;
-	}
-	fprintf(stderr, "  step%d: open(\"%s\"): Ok, ctlfd=%d\n", step, ctlname, ctlfd);
-
-	++step;
-	fprintf(stderr, "  pre-step%d: ioctl(%d,MPTFWDOWNLOAD,)\n", step, ctlfd);
-
-	fprintf(stdout, "\n  You are at irreversible step %d of %d in this process.\n",
-			step, step);
-	fprintf(stdout, "  Are you absolutely sure you want to proceed with download? (y/[n]) ");
-	fgets(userinp, sizeof(userinp), stdin);
-
-	if (userinp[0] == 'y') {
-//fprintf(stderr, "DbG: fwdata.iocnum = %02xh\n", fwdata.iocnum);
-//fprintf(stderr, "DbG: fwdata.bufp   = %p\n", fwdata.bufp);
-//fprintf(stderr, "DbG: fwdata.fwlen  = %d\n", fwdata.fwlen);
-		if (ioctl(ctlfd, ctlnum, (char *) &fwdata) < 0) {
-			fprintf(stderr, "ERROR: Firmware transfer to ioc%d FAILED: %s\n",
-					fwdata.iocnum, strerror(errno));
-			return step;
-		} else {
-			fprintf(stdout, "\n  !!! MPT firmware transfer to ioc%d SUCCEEDED !!!\n", fwdata.iocnum);
-			fprintf(stdout, "  (%d of %d f/w update steps were successful)\n\n",
-					step, step);
-			fprintf(stdout, "  CHANGE EFFECTIVE ONLY AFTER NEXT RESET / POWER CYCLE!\n\n");
-		}
-	} else {
-		fprintf(stderr, "User Aborted Download.\n");
-	}
-
-	return 0;
-}
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- * Verify that the ProductID in the FW matches the board we're
- * sending the image to. ProductID format:
- * 4 bits - type { FC, SCSI, Unknown }
- * 4 bits - Product { Initiator, Target, ...}
- * 8 bits - Family { 1030 A0, 1030 B0, ...}
- *
- * Return: 
- *	-1 	unable to open proc file system
- *	-2	mismatch in type field
- *	-3	mismatch in family field
- *	-4	mismatch in product field or user aborts
- */
-int verify_pid(char *fwbuf, struct mpt_fw_xfer *fwdata)
-{
-	u16 fwpid, iocpid;
-	FILE *iocinfofp;
-	char iipath[256], fwpidbuf[256], *fpbptr;
-	char userinp[128];
-	int i;
-
-	snprintf(iipath, 256, "/proc/mpt/ioc%d/info", fwdata->iocnum);
-
-	if ((iocinfofp = fopen(iipath, "r")) == NULL) {
-		fprintf(stderr, "ERROR: unable to open %s to get ProductID of"
-			" ioc%d.\n", iipath, fwdata->iocnum);
-		return (-1);
-	}
-
-	while (1) {
-		if (fgets(fwpidbuf, 256, iocinfofp) == NULL) {
-			fprintf (stderr, "ERROR: unable to find ProductID "
-				 "string in %s.\n", iipath);
-			return (-1);
-		}
-		if (strstr(fwpidbuf, "ProductID") != NULL) {
-			fpbptr = strchr(fwpidbuf, '=');
-			fpbptr = &fpbptr[2];
-			iocpid = (u16) strtol(fpbptr, NULL, 16);
-			break;
-		}
-	}
-
-	if (iocpid == MPI_MANUFACTPAGE_DEVICEID_FC909) {
-		u8 *fwptr = (u8 *) fwbuf;
-
-		for (i = 0x017000; (i+7) < fwdata->fwlen; i++) {
-			if ((((fwptr[i+1] << 8)| fwptr[i]) == MPI_MANUFACTPAGE_DEVICEID_FC909)
-			    && (fwptr[i+2] == 0x00) && (fwptr[i+3] == 0x00)
-			    && (fwptr[i+4] == 0x00) && (fwptr[i+5] == 0x00)
-			    && (fwptr[i+6] == 0xff) && (fwptr[i+7] == 0x03)) {
-				return (0);
-			}
-		}
-		fwpid = 0xdead;
-	} else {
-		fwpid = (((u16)((u8)fwbuf[35])) << 8) | ((u16)((u8)fwbuf[34]));
-	}
-
-	/*
-	 * Check the Type (FC vs SCSI), upper nibble of pid. MUST Match
-	 */
-	if ((fwpid & MPI_FW_HEADER_PID_TYPE_MASK) != (iocpid & MPI_FW_HEADER_PID_TYPE_MASK)){
-		uint fwtype = fwpid & MPI_FW_HEADER_PID_TYPE_MASK;
-		uint ioctype = iocpid & MPI_FW_HEADER_PID_TYPE_MASK;
-
-		fprintf(stderr, "ERROR: This fw image is for %s product \n"
-			"and the specified board/ioc type is %s.\n",
-			fwtype==0?"a SCSI":(fwtype == 1?"a FC":"an unknown"),
-			ioctype==0?"SCSI":(ioctype == 1?"FC":"unknown"));
-
-		return (-2);
-	}
-
-	/*
-	 * Check the Family, lower byte. MUST Match
-	 */
-	if ((fwpid & MPI_FW_HEADER_PID_FAMILY_MASK) != (iocpid & MPI_FW_HEADER_PID_FAMILY_MASK)){
-		uint fwfam = fwpid & MPI_FW_HEADER_PID_FAMILY_MASK;
-		uint iocfam = iocpid & MPI_FW_HEADER_PID_FAMILY_MASK;
-
-		fprintf(stderr, "ERROR: This fw image is for revision %d\n"
-			" product and the specified board/ioc chip "
-			" revision is %d.\n",
-			fwfam & MPI_FW_HEADER_PID_FAMILY_MASK,
-			iocfam & MPI_FW_HEADER_PID_FAMILY_MASK);
-
-		return (-3);
-	}
-
-
-	/*
-	 * Check the Product
-	 */
-	if ((fwpid & MPI_FW_HEADER_PID_PROD_MASK) != (iocpid & MPI_FW_HEADER_PID_PROD_MASK)){
-		uint fwprod = fwpid & MPI_FW_HEADER_PID_PROD_MASK;
-		uint iocprod = iocpid & MPI_FW_HEADER_PID_PROD_MASK;
-		char *fwProdString;
-		char *iocProdString;
-
-		if ((fwpid & MPI_FW_HEADER_PID_TYPE_MASK) == MPI_FW_HEADER_PID_TYPE_SCSI) {
-			switch(fwprod) {
-			case MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI:
-				fwProdString="Initiator";
-				break;
-			case MPI_FW_HEADER_PID_PROD_TARGET_INITIATOR_SCSI:
-				fwProdString="Initiator-Target";
-				break;
-			case MPI_FW_HEADER_PID_PROD_TARGET_SCSI:
-				fwProdString="Target";
-				break;
-			case MPI_FW_HEADER_PID_PROD_IM_SCSI:
-				fwProdString="Integrated Mirroring";
-				break;
-			case MPI_FW_HEADER_PID_PROD_IS_SCSI:
-				fwProdString="Integrated Striping";
-				break;
-			case MPI_FW_HEADER_PID_PROD_CTX_SCSI:
-				fwProdString="Context";
-				break;
-			default:
-				fwProdString="Unknown";
-				break;
-			}
-
-			switch(iocprod) {
-			case MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI:
-				iocProdString="Initiator";
-				break;
-			case MPI_FW_HEADER_PID_PROD_TARGET_INITIATOR_SCSI:
-				iocProdString="Initiator-Target";
-				break;
-			case MPI_FW_HEADER_PID_PROD_TARGET_SCSI:
-				iocProdString="Target";
-				break;
-			case MPI_FW_HEADER_PID_PROD_IM_SCSI:
-				iocProdString="Integrated Mirroring";
-				break;
-			case MPI_FW_HEADER_PID_PROD_IS_SCSI:
-				iocProdString="Integrated Striping";
-				break;
-			case MPI_FW_HEADER_PID_PROD_CTX_SCSI:
-				iocProdString="Context";
-				break;
-			default:
-				iocProdString="Unknown";
-				break;
-			}
-		} else  {
-			fwProdString="Unknown";
-			iocProdString="Unknown";
-		}
-
-		fprintf(stderr, "WARNING! The fw image contains %s firmware. \n"
-			" The specified board/ioc contains %s firmware. \n"
-			" Removing Integrated Mirroring or Striping firmware \n"
-			" may leave your system unable to boot.  \n",
-			fwProdString, iocProdString);
-		fprintf(stdout, "  Are you absolutely sure you want to update \n"
-			" the firwmare? (y/[n]) ");
-		fgets(userinp, sizeof(userinp), stdin);
-		if (userinp[0] == 'y')
-			;
-		else
-			return (-4);
-	}
-
-	return (0);
-}
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *  See if we can open "/proc/mpt/iocN/summary" to obtain
- *  current f/w version.
- */
-static char *
-get_oldver(char *results_buf, int iocnum)
-{
-	char pname[32];
-	char oldver_scratch[256];
-	int procfd;
-	unsigned int oldver_value = 0;
-	char *str = NULL;
-	char isscsi = 0;
-
-	(void) sprintf(pname, "/proc/mpt/ioc%d/summary", iocnum);
-	if ((procfd = open(pname, O_RDONLY)) >= 0) {
-		char *found;
-		/*
-		 *  Dependency: Current format of /proc/mpt/iocN/summary output:
-		 *    iocN: ... FwRev=0e0c1800h (Exp 1218), ...\n
-		 *  or
-		 *    iocN: ... FwRev=01010100h, ...\n
-		 *
-		 *                     ^^^^^^---- What we want!
-		 */
-		if (read(procfd, oldver_scratch, sizeof(oldver_scratch)) < 0) {
-			fprintf(stderr, "         OldVer-read-fail-WARNING\n");
-		} else {
-			str = oldver_scratch;
-			if ((found = strstr(str, versearch)) != NULL) {
-				if (strstr(str, "LSI53C") != NULL)
-					isscsi = 1;
-				str = found + strlen(versearch);
-				if (sscanf(str, "%x", &oldver_value) == 1) {
-					;	// done!
-				} else {
-					fprintf(stderr, "         OldVer-sscanf-fail-WARNING\n");
-					str = NULL;
-				}
-			} else {
-				fprintf(stderr, "         OldVer-search-fail-WARNING\n");
-			}
-		}
-		close(procfd);
-	}
-
-	/*
-	 *	Changes to handle both old and new-style FWVersion encoding
-	 */
-	if ((isscsi == 0) && (oldver_value < 0x00010000)) {
-		int mdbg = 0;
-
-		if (oldver_value & 0x0080) {
-			oldver_value &= ~0x0080;
-			mdbg++;
-		}
-
-		if ((oldver_value & 0xE000) == 0xE000) {
-			oldver_value &= 0x0FFFF;
-			(void) sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d%s",
-					2001,
-					(oldver_value & 0x0F00) >> 8,
-					oldver_value & 0x00FF,
-					mdbg ? " (MDBG)" : "" );
-		} else {
-			(void) sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d%s",
-					(oldver_value & 0xF000) >> 12,
-					(oldver_value & 0x0F00) >> 8,
-					oldver_value & 0x00FF,
-					mdbg ? " (MDBG)" : "" );
-		}
-		str = results_buf;
-	} else {
-		int mdbg = 0;
-
-		if (isscsi == 0) {
-			if (oldver_value & 0x00008000) {
-				oldver_value &= ~0x00008000;
-				mdbg++;
-			}
-
-			if ((oldver_value & 0x0E000000) == 0x0E000000) {
-				oldver_value &= 0x0FFFFFF;
-				sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d%s",
-					2001,
-					(oldver_value >> 16) & 0x00FF,
-					(oldver_value >> 8) & 0x00FF,
-					mdbg ? " (MDBG)" : "" );
-			} else {
-				int	 len;
-				len = sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d",
-					oldver_value >> 24,
-					(oldver_value >> 16) & 0x00FF,
-					(oldver_value >> 8) & 0x00FF);
-				if ((oldver_value & 0x0FF) != 0)
-					(void) sprintf(results_buf+len, ".%02d",
-						oldver_value & 0x0FF);
-				if (mdbg)
-					strcat(results_buf, " (MDBG)");
-			}
-		} else {
-			int	 len;
-			len = sprintf(results_buf, "LSI53Cxx-%02x.%02x.%02x",
-					oldver_value >> 24,
-					(oldver_value >> 16) & 0x00FF,
-					(oldver_value >> 8) & 0x00FF);
-			if ((oldver_value & 0x0FF) != 0)
-				(void) sprintf(results_buf+len, ".%02d",
-						oldver_value & 0x0FF);
-		}
-		str = results_buf;
-	}
-
-	return str;
-}
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static char *
-what_search(const char *buf, int size_in, int *size_out)
-{
-	register char c;
-	register char *found = NULL;
-
-	*size_out = 0;
-	while (--size_in) {
-		c = *buf++;
-loop:
-		if (size_in < 5)
-			return NULL;
-		if (c != '@')
-			continue;
-		if (--size_in && (c = *buf++) != '(')
-			goto loop;
-		if (--size_in && (c = *buf++) != '#')
-			goto loop;
-		if (--size_in && (c = *buf++) != ')')
-			goto loop;
-		found = (char*)buf;
-		while (--size_in && (c = *buf++) && c != '"' && c != '>' && c != '\n')
-			(*size_out)++;
-//		fprintf(stderr, "\nDbG: offset=%d, size_out=%d\n", found-fwbuf, *size_out);
-		return found;
-	}
-	return NULL;
-}
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/utils/mptflash.txt linux/drivers/message/fusion/utils/mptflash.txt
--- ../prev/linux/drivers/message/fusion/utils/mptflash.txt	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/utils/mptflash.txt	Wed Dec 31 17:00:00 1969
@@ -1,172 +0,0 @@
-******************************************************************************
-                                 mptflash.txt
-******************************************************************************
-
-This document provides the information required to update the LSI Logic
-Fusion MPT(TM) firmware for LSIFC909, LSIFC919, LSIFC929 Fibre Channel
-and the LSI53C1020 and LSI53C1030 SCSI chips when running from a
-Linux(TM) operating system.
-
-Adapter boards: LSI40909, LSI40919, LSI44929, LSIXXXX
-
-This text file is divided into these sections:
-   MPT Flash Utility Description
-   Updating the Firmware
-   Troubleshooting
-
-*********************** MPT Flash Utility Description ************************
-
-The MPT flash utility is used to update the Fusion MPT firmware on LSIFC909,
-LSIFC919, and LSIFC929 Fibre Channel and the firmware on the 
-LSI53C1020 and LSI53C1030 SCSI chips / HABs.
-
-This utility uses the MPI FwDownload command to update the firmware image in
-flash, while the current firmare is running.  The firmware update becomes
-effective after a subsequent reboot or diagnostic reset.
-
-IMPORTANT NOTES:
- o  Dual channel devices will appear as two separate IO controllers, from
-    the system point of view.  You only need to perform this update 
-    procedure to one of the two visible IO controllers.
-    Chips:  LSIFC929, LSI53C1030
- o  Typically, each chip and each revisionl requires a unique firmware image. 
-    That is, the firmware for the LSIFC909 is different that that for the 
-    LSIFC929 or the LSI53C1030.  Likewise, the firmware for the LSI53C1030 
-    A0 revision and LSI53C1030 B0 revision is different.
-
-    Exceptions:  
-       o The LSIFC929 and the LSIFC919 can use the same firmware image.
-
-    WARNING! There are currently no checks to ensure that you are
-             using the proper firmware image for a given IO Controller.
-
-             USE EXTREME CAUTION WHEN USING THIS UTILITY!
- o  The /proc filesystem MUST be enabled for this utility to be able
-    to verify the adapter.
-
-*************************** Updating the Firmware ****************************
-
-The following examples show procedures for updating a single LCIFC929 when
-a single LSIFC919, a single LSIFC929 and a single LSI53C1030 are present 
-in a system.
-
-To update the Fusion MPT firmware, complete the following steps:
-
-1. Make sure that the LSI Fibre Channel and SCSI adapters 
-   are properly installed in a system PCI slot, boot the system 
-   into Linux, and then log in as root.
-
-2. Verify that the Fusion MPT base driver is properly installed.
-      # insmod mptbase
-        Fusion MPT base driver 2.00.08
-        mptbase: Initiating ioc0 bringup
-        ioc0: FC919: Capabilities={Initiator,Target,LAN}
-        mptbase: Initiating ioc1 bringup
-        ioc1: FC929: Capabilities={Initiator,Target,LAN}
-        mptbase: Initiating ioc2 bringup
-        ioc2: FC929: Capabilities={Initiator,Target,LAN}
-        mptbase: Initiating ioc3 bringup
-        ioc3: C1030: Capabilities={Initiator}
-        mptbase: Initiating ioc4 bringup
-        ioc4: C1030: Capabilities={Initiator}
-        mptbase: 5 MPT adapters found, 5 installed.
-
-3. Verify and the current layout and version of existing MPT I/O controllers.
-      # cat /proc/mpt/summary
-        ioc0: LSIFC919, FwRev=01000000h, Ports=1, MaxQ=256, \
-                                        LanAddr=00:A0:B8:04:78:55, IRQ=9
-        ioc1: LSIFC929, FwRev=00090000h, Ports=1, MaxQ=256, \
-                                        LanAddr=00:A0:B8:04:0B:32, IRQ=10
-        ioc2: LSIFC929, FwRev=00090000h, Ports=1, MaxQ=256, \
-                                        LanAddr=00:A0:B8:04:0B:33, IRQ=5
-        ioc3: LSI53C1030, FwRev=00000700h, Ports=1, MaxQ=256, IRQ=17
-        ioc4: LSI53C1030, FwRev=00000700h, Ports=1, MaxQ=256, IRQ=19
-
-   NOTE: The ioc1 and ioc2 entries in the listing above represent a 
-   single LSIFC929, ioc3 and ioc4 entries represent a single LSI53C1030.
-
-4. Verify that the Fusion MPT misc device (ioctl) driver is loaded.
-      # insmod mptctl
-        Fusion MPT misc device (ioctl) driver 2.00.08
-        mptctl: Registered with Fusion MPT base driver
-        mptctl: /dev/mptctl @ (major,minor=10,220)
-
-5. Make sure that a proper /dev/mptctl character special device node exists.
-   It should look something like this:
-      # ls -l /dev/mptctl
-        crw-r--r--   1 root     root      10, 220 Dec 27 16:32 /dev/mptctl
-
-   If you don't have one, create it with this command:
-      # mknod /dev/mptctl c 10 220
-
-6. Create the mptflash utility program, by changing to the
-   drivers/message/fusion/utils subdirectory:
-      # cd /usr/src/linux/drivers/message/fusion/utils
-
-   and then execute this command:
-      # make mptflash
-        gcc -g -O -Wall -I. -I.. -I../../../../include   -c mptflash.c \
-                                        -o mptflash.o
-        gcc   mptflash.o   -o mptflash
-
-   Now move the resulting mptflash program to a useful place:
-      # mv mptflash /sbin
-
-7. Find the appropriate IOC firmware image file you want to update to,
-   for example:
-      # cd /tmp
-      # ls -l fc929-100.rom
-        -rw-rw-r--   1 fibre    fibre      195876 Jul 19 01:00 fc929-100.rom
-
-8. Now execute the mptflash utility program, specifying which IOC you will
-   be updating.  For our example we want to update the single LSIFC929
-   which is represented as ioc1 (and ioc2) for this example:
-      # mptflash fc929-100.rom 1
-          step1: Cmd line check: Ok
-          step2: get_oldver() results: "LSIFC9x9-0.09.00"
-          step3: open("fc929-100.rom"): Ok, fwfd=3
-          step4: stat("fc929-100.rom"): Ok, size=195876 bytes
-          step5: malloc(195876): Ok
-          step6: read(3,,195876): Ok
-                 Current F/W Version = "LSIFC9x9-0.09.00"
-                     New F/W Version = "LSIFC929-1.00.00  (2001.07.19)"
-          step7: open("/dev/mptctl"): Ok, ctlfd=4
-          pre-step8: ioctl(4,MPTFWDOWNLOAD,)
-
-          Okay, this is like, a *really* DANGEROUS procedure.
-
-          You are at irreversible step 8 of 8 in this process.
-          Are you absolutely sure you want to do this? (y/[n]) _
-
-   Press "y" followed by <Enter> to begin the process.
-   It should only take about 10-25 seconds and you should see:
-
-          !!! MPT firmware transfer to ioc1 SUCCEEDED !!!
-          (8 of 8 f/w update steps were successful)
-
-          CHANGE EFFECTIVE ONLY AFTER NEXT RESET / POWER CYCLE!
-
-9. Reboot your system!
-
-****************************** Troubleshooting *******************************
-
-If firmware download using mptflash fails, the only recourse is to reinstall
-the firmware using the DOS-based utility. 
-    Chip Name         Utility
-    --------------------------
-    FC909               FcProm
-    FC919               FcUtil
-    FC929               FcUtil
-    53C1020             flsh1030
-    53C1030             flsh1030
-
-These utilities are available from:  XXXX
-
-
-******************************************************************************
-
-Fusion MPT is a trademark of LSI Logic Corporation
-Linux is a registered trademark of Linus Torvalds
-
-*****************************************************************************
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/message/fusion/utils/what.c linux/drivers/message/fusion/utils/what.c
--- ../prev/linux/drivers/message/fusion/utils/what.c	Tue May 14 17:24:33 2002
+++ linux/drivers/message/fusion/utils/what.c	Wed Dec 31 17:00:00 1969
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 1980, 1988 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef lint
-char copyright[] =
-"@(#) Copyright (c) 1980, 1988 Regents of the University of California.\n All rights reserved.\n";
-#endif /* not lint */
-
-#ifndef lint
-static char sccsid[] = "@(#)what.c	5.5 (Berkeley) 3/2/91";
-#endif /* not lint */
-
-int search(int stop);
-
-#include <stdio.h>
-#include <string.h>
-
-/*
- * what
- */
-/* ARGSUSED */
-int
-main(int argc, char **argv)
-{
-	 int stop = 0;
-
-	if (argc > 1) {
-		if (strcmp(*++argv, "-s") == 0)
-			stop++;
-		else
-			argv--;
-	}
-
-	if (!*++argv)
-		search(stop);
-	else do {
-		if (!freopen(*argv, "rb", stdin)) {
-			perror(*argv);
-			return 1;
-		}
-		printf("%s:\n", *argv);
-		search(stop);
-	} while(*++argv);
-	return 0;
-}
-
-int
-search(int stop)
-{
-	register int c;
-
-	while ((c = getchar()) != EOF) {
-loop:		if (c != '@')
-			continue;
-		if ((c = getchar()) != '(')
-			goto loop;
-		if ((c = getchar()) != '#')
-			goto loop;
-		if ((c = getchar()) != ')')
-			goto loop;
-		putchar('\t');
-		while ((c = getchar()) != EOF && c && c != '"' &&
-		    c != '>' && c != '\n')
-			putchar(c);
-		putchar('\n');
-        if (stop)
-            return 0;
-	}
-    return 0;
-}
-
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/Config.in linux/drivers/net/Config.in
--- ../prev/linux/drivers/net/Config.in	Tue Jul  9 18:04:14 2002
+++ linux/drivers/net/Config.in	Wed May 15 10:15:10 2002
@@ -234,12 +234,15 @@
 if [ "$CONFIG_ACENIC" != "n" ]; then
    bool '  Omit support for old Tigon I based AceNICs' CONFIG_ACENIC_OMIT_TIGON_I
 fi
+dep_tristate 'Broadcom BCM5700 support' CONFIG_NET_BROADCOM $CONFIG_PCI
 dep_tristate 'D-Link DL2000-based Gigabit Ethernet support' CONFIG_DL2K $CONFIG_PCI
+dep_tristate 'Intel Pro/1000 Gigabit Ethernet support' CONFIG_E1000 $CONFIG_PCI
 dep_tristate 'MyriCOM Gigabit Ethernet support' CONFIG_MYRI_SBUS $CONFIG_SBUS
 dep_tristate 'National Semiconduct DP83820 support' CONFIG_NS83820 $CONFIG_PCI
 dep_tristate 'Packet Engines Hamachi GNIC-II support' CONFIG_HAMACHI $CONFIG_PCI
 dep_tristate 'Packet Engines Yellowfin Gigabit-NIC support (EXPERIMENTAL)' CONFIG_YELLOWFIN $CONFIG_PCI $CONFIG_EXPERIMENTAL
 dep_tristate 'SysKonnect SK-98xx support' CONFIG_SK98LIN $CONFIG_PCI
+dep_tristate 'Broadcom Tigon3 support' CONFIG_TIGON3 $CONFIG_PCI
 
 endmenu
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/Makefile linux/drivers/net/Makefile
--- ../prev/linux/drivers/net/Makefile	Tue Jul  9 18:04:14 2002
+++ linux/drivers/net/Makefile	Wed May 15 10:15:10 2002
@@ -29,6 +29,14 @@
   obj-$(CONFIG_ISDN) += slhc.o
 endif
 
+ifeq ($(CONFIG_NET_BROADCOM),y)
+  obj-y += bcm/bcm5700.o
+endif
+
+ifeq ($(CONFIG_E1000),y)
+  obj-y += e1000/e1000.o
+endif
+
 subdir-$(CONFIG_NET_PCMCIA) += pcmcia
 subdir-$(CONFIG_NET_WIRELESS) += wireless
 subdir-$(CONFIG_TULIP) += tulip
@@ -40,6 +48,9 @@
 subdir-$(CONFIG_APPLETALK) += appletalk
 subdir-$(CONFIG_SK98LIN) += sk98lin
 subdir-$(CONFIG_SKFP) += skfp
+subdir-$(CONFIG_NET_BROADCOM) += bcm
+
+subdir-$(CONFIG_E1000) += e1000
 
 #
 # link order important here
@@ -78,6 +89,7 @@
 obj-$(CONFIG_NS83820) += ns83820.o
 obj-$(CONFIG_STNIC) += stnic.o 8390.o
 obj-$(CONFIG_FEALNX) += fealnx.o mii.o
+obj-$(CONFIG_TIGON3) += tg3.o
 
 ifeq ($(CONFIG_SK98LIN),y)
 obj-y += sk98lin/sk98lin.o
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/acenic.c linux/drivers/net/acenic.c
--- ../prev/linux/drivers/net/acenic.c	Tue Jul  9 18:04:14 2002
+++ linux/drivers/net/acenic.c	Wed May 15 10:15:10 2002
@@ -823,10 +823,13 @@
 		if (ap->version >= 2)
 			writel(readl(&regs->CpuBCtrl) | CPU_HALT,
 			       &regs->CpuBCtrl);
+		readl(&regs->CpuCtrl);	/* GGG flush write */
+
 		/*
 		 * This clears any pending interrupts
 		 */
 		writel(1, &regs->Mb0Lo);
+		readl(&regs->Mb0Lo);	/* GGG flush write */
 
 		/*
 		 * Make sure no other CPUs are processing interrupts
@@ -1104,35 +1107,28 @@
 	 * to any crashes involving the NIC
 	 */
 	writel(HW_RESET | (HW_RESET << 24), &regs->HostCtrl);
-	wmb();
+	wmb(); readl(&regs->HostCtrl);	/* GGG flush write */
+	mdelay(1);
 
 	/*
-	 * Don't access any other registes before this point!
+	 * Don't access any other registers before this point!
 	 */
-#ifdef __BIG_ENDIAN
 	/*
 	 * This will most likely need BYTE_SWAP once we switch
 	 * to using __raw_writel()
 	 */
-#ifdef __parisc__
-	writel((WORD_SWAP | BYTE_SWAP | CLR_INT |
-		((WORD_SWAP | BYTE_SWAP | CLR_INT) << 24)),
-	       &regs->HostCtrl);
-#else
-	writel((WORD_SWAP | CLR_INT | ((WORD_SWAP | CLR_INT) << 24)),
-	       &regs->HostCtrl);
-#endif
-#else
 	writel((CLR_INT | WORD_SWAP | ((CLR_INT | WORD_SWAP) << 24)),
 	       &regs->HostCtrl);
-#endif
-	mb();
+	mb();	readl(&regs->HostCtrl);	/* GGG flush write */
 
 	/*
 	 * Stop the NIC CPU and clear pending interrupts
 	 */
 	writel(readl(&regs->CpuCtrl) | CPU_HALT, &regs->CpuCtrl);
+	readl(&regs->CpuCtrl);	/* GGG flush write */
+
 	writel(0, &regs->Mb0Lo);
+	readl(&regs->Mb0Lo);	/* GGG flush write */
 
 	tig_ver = readl(&regs->HostCtrl) >> 28;
 
@@ -1151,6 +1147,7 @@
 		       tig_ver, tigon2FwReleaseMajor, tigon2FwReleaseMinor,
 		       tigon2FwReleaseFix);
 		writel(readl(&regs->CpuBCtrl) | CPU_HALT, &regs->CpuBCtrl);
+		readl(&regs->CpuBCtrl); /* GGG flush write */
 		/*
 		 * The SRAM bank size does _not_ indicate the amount
 		 * of memory on the card, it controls the _bank_ size!
@@ -1181,7 +1178,7 @@
 	writel(ACE_BYTE_SWAP_DMA | ACE_WARN | ACE_FATAL |
 	       ACE_WORD_SWAP_BD | ACE_NO_JUMBO_FRAG, &regs->ModeStat);
 #endif
-	mb();
+	mb(); readl(&regs->ModeStat); 	/* GGG flush write */
 
 	mac1 = 0;
 	for(i = 0; i < 4; i++) {
@@ -1318,7 +1315,7 @@
 	tmp &= ~DMA_READ_WRITE_MASK;
 	tmp |= DMA_READ_MAX_128;
 	/*
-	 * All the docs sy MUST NOT. Well, I did.
+	 * All the docs say MUST NOT. Well, I did.
 	 * Nothing terrible happens, if we load wrong size.
 	 * Bit w&i still works better!
 	 */
@@ -1327,6 +1324,12 @@
 	writel(tmp, &regs->PciState);
 
 #if 0
+/* The Host PCI bus controller driver has to set FBB.
+ * If all devices on that PCI bus support FBB, then the controller
+ * can enable FBB support in the Host PCI Bus controller (or on
+ * the PCI-PCI bridge if that applies).
+ * -ggg
+ */
 	/*
 	 * I have received reports from people having problems when this
 	 * bit is enabled.
@@ -1395,6 +1398,7 @@
 	memset(ap->skb, 0, sizeof(struct ace_skb));
 
 	ace_load_firmware(dev);
+
 	ap->fw_running = 0;
 
 	tmp_ptr = ap->info_dma;
@@ -1406,9 +1410,9 @@
 	set_aceaddr(&info->evt_ctrl.rngptr, ap->evt_ring_dma);
 	info->evt_ctrl.flags = 0;
 
-	set_aceaddr(&info->evt_prd_ptr, ap->evt_prd_dma);
 	*(ap->evt_prd) = 0;
-	wmb();
+	set_aceaddr(&info->evt_prd_ptr, ap->evt_prd_dma);
+
 	writel(0, &regs->EvtCsm);
 
 	set_aceaddr(&info->cmd_ctrl.rngptr, 0x100);
@@ -1518,9 +1522,9 @@
 	writel(DMA_THRESH_8W, &regs->DmaWriteCfg);
 #endif
 
-	writel(0, &regs->MaskInt);
 	writel(1, &regs->IfIdx);
-	writel(1, &regs->AssistState);
+	writel(0, &regs->MaskInt);
+	readl(&regs->MaskInt);	/* GGG flush write */
 
 	writel(DEF_STAT, &regs->TuneStatTicks);
 	writel(DEF_TRACE, &regs->TuneTrace);
@@ -1611,6 +1615,7 @@
 		writel(tigon2FwStartAddr, &regs->Pc);
 
 	writel(0, &regs->Mb0Lo);
+	readl(&regs->Mb0Lo);	/* GGG flush write */
 
 	/*
 	 * Set tx_csm before we start receiving interrupts, otherwise
@@ -1630,10 +1635,21 @@
 	 */
 	memset(&ap->stats, 0, sizeof(ap->stats));
 
+        /*
+	 * Enable DMA engine now.
+	 * If we do this sooner, Mckinley box pukes.
+	 * I assume it's because Tigon II DMA engine wants to check
+	 * *something* even before the CPU is started.
+	 */
+	writel(1, &regs->AssistState);	/* enable DMA */
+	readl(&regs->AssistState);	/* GGG flush write */
+	mdelay(1);
+
 	/*
 	 * Start the NIC CPU
 	 */
 	writel(readl(&regs->CpuCtrl) & ~(CPU_HALT|CPU_TRACE), &regs->CpuCtrl);
+	readl(&regs->CpuCtrl);	/* GGG flush write */
 
 	/*
 	 * Wait for the firmware to spin up - max 3 seconds.
@@ -1646,6 +1662,7 @@
 
 		ace_dump_trace(ap);
 		writel(readl(&regs->CpuCtrl) | CPU_HALT, &regs->CpuCtrl);
+		readl(&regs->CpuCtrl);	/* GGG flush write */
 
 		/* aman@sgi.com - account for badly behaving firmware/NIC:
 		 * - have observed that the NIC may continue to generate
@@ -1660,6 +1677,7 @@
 			writel(readl(&regs->CpuBCtrl) | CPU_HALT,
 			       &regs->CpuBCtrl);
 		writel(0, &regs->Mb0Lo);
+		readl(&regs->Mb0Lo);	/* GGG flush write */
 
 		ecode = -EBUSY;
 		goto init_error;
@@ -2328,6 +2346,7 @@
 	 * threads and it is wrong even for that case.
 	 */
 	writel(0, &regs->Mb0Lo);
+	readl(&regs->Mb0Lo);	/* GGG flush write */
 
 	/*
 	 * There is no conflict between transmit handling in
@@ -3088,6 +3107,7 @@
 			 tigon2FwRodataLen);
 		ace_copy(regs, tigon2FwData, tigon2FwDataAddr,tigon2FwDataLen);
 	}
+	readl(&regs->CpuCtrl);	/* GGG flush write */
 
 	return 0;
 }
@@ -3112,23 +3132,24 @@
 {
 	u32 local;
 
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local = readl(&regs->LocalCtrl);
 	local |= EEPROM_DATA_OUT | EEPROM_WRITE_ENABLE;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local |= EEPROM_CLK_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local &= ~EEPROM_DATA_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local &= ~EEPROM_CLK_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 }
 
 
@@ -3142,7 +3163,7 @@
 	local &= ~EEPROM_DATA_OUT;
 	local |= EEPROM_WRITE_ENABLE;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 
 	for (i = 0; i < 8; i++, magic <<= 1) {
 		udelay(ACE_SHORT_DELAY);
@@ -3151,16 +3172,16 @@
 		else
 			local &= ~EEPROM_DATA_OUT;
 		writel(local, &regs->LocalCtrl);
-		mb();
+		mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 
 		udelay(ACE_SHORT_DELAY);
 		local |= EEPROM_CLK_OUT;
 		writel(local, &regs->LocalCtrl);
-		mb();
+		mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 		udelay(ACE_SHORT_DELAY);
 		local &= ~(EEPROM_CLK_OUT | EEPROM_DATA_OUT);
 		writel(local, &regs->LocalCtrl);
-		mb();
+		mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	}
 }
 
@@ -3173,18 +3194,18 @@
 	local = readl(&regs->LocalCtrl);
 	local &= ~EEPROM_WRITE_ENABLE;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	udelay(ACE_LONG_DELAY);
 	local |= EEPROM_CLK_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	/* sample data in middle of high clk */
 	state = (readl(&regs->LocalCtrl) & EEPROM_DATA_IN) != 0;
 	udelay(ACE_SHORT_DELAY);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	writel(readl(&regs->LocalCtrl) & ~EEPROM_CLK_OUT, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 
 	return state;
 }
@@ -3239,7 +3260,7 @@
 	regs = ((struct ace_private *)dev->priv)->regs;
 
 	/*
-	 * Don't take interrupts on this CPU will bit banging
+	 * Don't take interrupts on this CPU while bit banging
 	 * the %#%#@$ I2C device
 	 */
 	__save_flags(flags);
@@ -3287,12 +3308,14 @@
 		local = readl(&regs->LocalCtrl);
 		local &= ~EEPROM_WRITE_ENABLE;
 		writel(local, &regs->LocalCtrl);
+		readl(&regs->LocalCtrl);	/* GGG flush write */
 		udelay(ACE_LONG_DELAY);
 		mb();
 		local |= EEPROM_CLK_OUT;
 		writel(local, &regs->LocalCtrl);
-		mb();
+		readl(&regs->LocalCtrl);	/* GGG flush write */
 		udelay(ACE_SHORT_DELAY);
+		mb();
 		/* sample data mid high clk */
 		result = (result << 1) |
 			((readl(&regs->LocalCtrl) & EEPROM_DATA_IN) != 0);
@@ -3301,11 +3324,13 @@
 		local = readl(&regs->LocalCtrl);
 		local &= ~EEPROM_CLK_OUT;
 		writel(local, &regs->LocalCtrl);
+		readl(&regs->LocalCtrl);	/* GGG flush write */
 		udelay(ACE_SHORT_DELAY);
 		mb();
 		if (i == 7) {
 			local |= EEPROM_WRITE_ENABLE;
 			writel(local, &regs->LocalCtrl);
+			readl(&regs->LocalCtrl);	/* GGG flush write */
 			mb();
 			udelay(ACE_SHORT_DELAY);
 		}
@@ -3313,12 +3338,12 @@
 
 	local |= EEPROM_DATA_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb();	readl(&regs->LocalCtrl);	/* GGG Flush write */
 	udelay(ACE_SHORT_DELAY);
 	writel(readl(&regs->LocalCtrl) | EEPROM_CLK_OUT, &regs->LocalCtrl);
 	udelay(ACE_LONG_DELAY);
 	writel(readl(&regs->LocalCtrl) & ~EEPROM_CLK_OUT, &regs->LocalCtrl);
-	mb();
+	mb();	readl(&regs->LocalCtrl);	/* GGG Flush write */
 	udelay(ACE_SHORT_DELAY);
 	eeprom_stop(regs);
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/5701rls.c linux/drivers/net/bcm/5701rls.c
--- ../prev/linux/drivers/net/bcm/5701rls.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/5701rls.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,48 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*                                                                            */
+/******************************************************************************/
+
+#if INCLUDE_5701_AX_FIX
+
+#include "mm.h"
+#include "5701rls.h"
+
+LM_STATUS LM_LoadRlsFirmware(PLM_DEVICE_BLOCK pDevice)
+{
+  T3_FWIMG_INFO FwImgInfo;
+
+  FwImgInfo.StartAddress = t3FwStartAddr;
+  FwImgInfo.Text.Buffer = (PLM_UINT8)t3FwText;
+  FwImgInfo.Text.Offset  = t3FwTextAddr;
+  FwImgInfo.Text.Length  = t3FwTextLen;
+  FwImgInfo.ROnlyData.Buffer = (PLM_UINT8)t3FwRodata;
+  FwImgInfo.ROnlyData.Offset  = t3FwRodataAddr;
+  FwImgInfo.ROnlyData.Length  = t3FwRodataLen;
+  FwImgInfo.Data.Buffer = (PLM_UINT8)t3FwData;
+  FwImgInfo.Data.Offset  = t3FwDataAddr;
+  FwImgInfo.Data.Length  = t3FwDataLen;
+
+  if (LM_LoadFirmware(pDevice,
+                      &FwImgInfo,
+                      T3_RX_CPU_ID | T3_TX_CPU_ID,
+                      T3_RX_CPU_ID) != LM_STATUS_SUCCESS)
+    {
+      DbgMessage(FATAL, ("Failed loading firmware.\n"));
+      DbgBreak();
+      return LM_STATUS_FAILURE;
+    }
+  
+  return LM_STATUS_SUCCESS;
+}
+
+#endif /* INCLUDE_5701_AX_FIX */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/5701rls.h linux/drivers/net/bcm/5701rls.h
--- ../prev/linux/drivers/net/bcm/5701rls.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/5701rls.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,198 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+typedef unsigned long U32;
+int t3FwReleaseMajor = 0x0;
+int t3FwReleaseMinor = 0x0;
+int t3FwReleaseFix = 0x0;
+U32 t3FwStartAddr = 0x08000000;
+U32 t3FwTextAddr = 0x08000000;
+int t3FwTextLen = 0x9c0;
+U32 t3FwRodataAddr = 0x080009c0;
+int t3FwRodataLen = 0x60;
+U32 t3FwDataAddr = 0x08000a40;
+int t3FwDataLen = 0x20;
+U32 t3FwSbssAddr = 0x08000a60;
+int t3FwSbssLen = 0xc;
+U32 t3FwBssAddr = 0x08000a70;
+int t3FwBssLen = 0x10;
+U32 t3FwText[(0x9c0/4) + 1] = {
+0x0, 
+0x10000003, 0x0, 0xd, 0xd, 
+0x3c1d0800, 0x37bd3ffc, 0x3a0f021, 0x3c100800, 
+0x26100000, 0xe000018, 0x0, 0xd, 
+0x3c1d0800, 0x37bd3ffc, 0x3a0f021, 0x3c100800, 
+0x26100034, 0xe00021c, 0x0, 0xd, 
+0x0, 0x0, 0x0, 0x27bdffe0, 
+0x3c1cc000, 0xafbf0018, 0xaf80680c, 0xe00004c, 
+0x241b2105, 0x97850000, 0x97870002, 0x9782002c, 
+0x9783002e, 0x3c040800, 0x248409c0, 0xafa00014, 
+0x21400, 0x621825, 0x52c00, 0xafa30010, 
+0x8f860010, 0xe52825, 0xe000060, 0x24070102, 
+0x3c02ac00, 0x34420100, 0x3c03ac01, 0x34630100, 
+0xaf820490, 0x3c02ffff, 0xaf820494, 0xaf830498, 
+0xaf82049c, 0x24020001, 0xaf825ce0, 0xe00003f, 
+0xaf825d00, 0xe000140, 0x0, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x2402ffff, 0xaf825404, 
+0x8f835400, 0x34630400, 0xaf835400, 0xaf825404, 
+0x3c020800, 0x24420034, 0xaf82541c, 0x3e00008, 
+0xaf805400, 0x0, 0x0, 0x3c020800, 
+0x34423000, 0x3c030800, 0x34633000, 0x3c040800, 
+0x348437ff, 0x3c010800, 0xac220a64, 0x24020040, 
+0x3c010800, 0xac220a68, 0x3c010800, 0xac200a60, 
+0xac600000, 0x24630004, 0x83102b, 0x5040fffd, 
+0xac600000, 0x3e00008, 0x0, 0x804821, 
+0x8faa0010, 0x3c020800, 0x8c420a60, 0x3c040800, 
+0x8c840a68, 0x8fab0014, 0x24430001, 0x44102b, 
+0x3c010800, 0xac230a60, 0x14400003, 0x4021, 
+0x3c010800, 0xac200a60, 0x3c020800, 0x8c420a60, 
+0x3c030800, 0x8c630a64, 0x91240000, 0x21140, 
+0x431021, 0x481021, 0x25080001, 0xa0440000, 
+0x29020008, 0x1440fff4, 0x25290001, 0x3c020800, 
+0x8c420a60, 0x3c030800, 0x8c630a64, 0x8f84680c, 
+0x21140, 0x431021, 0xac440008, 0xac45000c, 
+0xac460010, 0xac470014, 0xac4a0018, 0x3e00008, 
+0xac4b001c, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x2000008, 
+0x0, 0xa0001e3, 0x3c0a0001, 0xa0001e3, 
+0x3c0a0002, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x3c0a0007, 0xa0001e3, 0x3c0a0008, 0xa0001e3, 
+0x3c0a0009, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x3c0a000b, 0xa0001e3, 
+0x3c0a000c, 0xa0001e3, 0x3c0a000d, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x3c0a000e, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x3c0a0013, 0xa0001e3, 
+0x3c0a0014, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x27bdffe0, 
+0x1821, 0x1021, 0xafbf0018, 0xafb10014, 
+0xafb00010, 0x3c010800, 0x220821, 0xac200a70, 
+0x3c010800, 0x220821, 0xac200a74, 0x3c010800, 
+0x220821, 0xac200a78, 0x24630001, 0x1860fff5, 
+0x2442000c, 0x24110001, 0x8f906810, 0x32020004, 
+0x14400005, 0x24040001, 0x3c020800, 0x8c420a78, 
+0x18400003, 0x2021, 0xe000182, 0x0, 
+0x32020001, 0x10400003, 0x0, 0xe000169, 
+0x0, 0xa000153, 0xaf915028, 0x8fbf0018, 
+0x8fb10014, 0x8fb00010, 0x3e00008, 0x27bd0020, 
+0x3c050800, 0x8ca50a70, 0x3c060800, 0x8cc60a80, 
+0x3c070800, 0x8ce70a78, 0x27bdffe0, 0x3c040800, 
+0x248409d0, 0xafbf0018, 0xafa00010, 0xe000060, 
+0xafa00014, 0xe00017b, 0x2021, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x24020001, 0x8f836810, 
+0x821004, 0x21027, 0x621824, 0x3e00008, 
+0xaf836810, 0x27bdffd8, 0xafbf0024, 0x1080002e, 
+0xafb00020, 0x8f825cec, 0xafa20018, 0x8f825cec, 
+0x3c100800, 0x26100a78, 0xafa2001c, 0x34028000, 
+0xaf825cec, 0x8e020000, 0x18400016, 0x0, 
+0x3c020800, 0x94420a74, 0x8fa3001c, 0x221c0, 
+0xac830004, 0x8fa2001c, 0x3c010800, 0xe000201, 
+0xac220a74, 0x10400005, 0x0, 0x8e020000, 
+0x24420001, 0xa0001df, 0xae020000, 0x3c020800, 
+0x8c420a70, 0x21c02, 0x321c0, 0xa0001c5, 
+0xafa2001c, 0xe000201, 0x0, 0x1040001f, 
+0x0, 0x8e020000, 0x8fa3001c, 0x24420001, 
+0x3c010800, 0xac230a70, 0x3c010800, 0xac230a74, 
+0xa0001df, 0xae020000, 0x3c100800, 0x26100a78, 
+0x8e020000, 0x18400028, 0x0, 0xe000201, 
+0x0, 0x14400024, 0x0, 0x8e020000, 
+0x3c030800, 0x8c630a70, 0x2442ffff, 0xafa3001c, 
+0x18400006, 0xae020000, 0x31402, 0x221c0, 
+0x8c820004, 0x3c010800, 0xac220a70, 0x97a2001e, 
+0x2442ff00, 0x2c420300, 0x1440000b, 0x24024000, 
+0x3c040800, 0x248409dc, 0xafa00010, 0xafa00014, 
+0x8fa6001c, 0x24050008, 0xe000060, 0x3821, 
+0xa0001df, 0x0, 0xaf825cf8, 0x3c020800, 
+0x8c420a40, 0x8fa3001c, 0x24420001, 0xaf835cf8, 
+0x3c010800, 0xac220a40, 0x8fbf0024, 0x8fb00020, 
+0x3e00008, 0x27bd0028, 0x27bdffe0, 0x3c040800, 
+0x248409e8, 0x2821, 0x3021, 0x3821, 
+0xafbf0018, 0xafa00010, 0xe000060, 0xafa00014, 
+0x8fbf0018, 0x3e00008, 0x27bd0020, 0x8f82680c, 
+0x8f85680c, 0x21827, 0x3182b, 0x31823, 
+0x431024, 0x441021, 0xa2282b, 0x10a00006, 
+0x0, 0x401821, 0x8f82680c, 0x43102b, 
+0x1440fffd, 0x0, 0x3e00008, 0x0, 
+0x3c040800, 0x8c840000, 0x3c030800, 0x8c630a40, 
+0x64102b, 0x54400002, 0x831023, 0x641023, 
+0x2c420008, 0x3e00008, 0x38420001, 0x27bdffe0, 
+0x802821, 0x3c040800, 0x24840a00, 0x3021, 
+0x3821, 0xafbf0018, 0xafa00010, 0xe000060, 
+0xafa00014, 0xa000216, 0x0, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x0, 0x27bdffe0, 
+0x3c1cc000, 0xafbf0018, 0xe00004c, 0xaf80680c, 
+0x3c040800, 0x24840a10, 0x3802821, 0x3021, 
+0x3821, 0xafa00010, 0xe000060, 0xafa00014, 
+0x2402ffff, 0xaf825404, 0x3c0200aa, 0xe000234, 
+0xaf825434, 0x8fbf0018, 0x3e00008, 0x27bd0020, 
+0x0, 0x0, 0x0, 0x27bdffe8, 
+0xafb00010, 0x24100001, 0xafbf0014, 0x3c01c003, 
+0xac200000, 0x8f826810, 0x30422000, 0x10400003, 
+0x0, 0xe000246, 0x0, 0xa00023a, 
+0xaf905428, 0x8fbf0014, 0x8fb00010, 0x3e00008, 
+0x27bd0018, 0x27bdfff8, 0x8f845d0c, 0x3c0200ff, 
+0x3c030800, 0x8c630a50, 0x3442fff8, 0x821024, 
+0x1043001e, 0x3c0500ff, 0x34a5fff8, 0x3c06c003, 
+0x3c074000, 0x851824, 0x8c620010, 0x3c010800, 
+0xac230a50, 0x30420008, 0x10400005, 0x871025, 
+0x8cc20000, 0x24420001, 0xacc20000, 0x871025, 
+0xaf825d0c, 0x8fa20000, 0x24420001, 0xafa20000, 
+0x8fa20000, 0x8fa20000, 0x24420001, 0xafa20000, 
+0x8fa20000, 0x8f845d0c, 0x3c030800, 0x8c630a50, 
+0x851024, 0x1443ffe8, 0x851824, 0x27bd0008, 
+0x3e00008, 0x0, 0x0, 0x0 };
+U32 t3FwRodata[(0x60/4) + 1] = {
+0x35373031, 0x726c7341, 0x0, 
+0x0, 0x53774576, 0x656e7430, 0x0, 
+0x726c7045, 0x76656e74, 0x31000000, 0x556e6b6e, 
+0x45766e74, 0x0, 0x0, 0x0, 
+0x0, 0x66617461, 0x6c457272, 0x0, 
+0x0, 0x4d61696e, 0x43707542, 0x0, 
+0x0, 0x0 };
+U32 t3FwData[(0x20/4) + 1] = {
+0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0 };
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/Makefile linux/drivers/net/bcm/Makefile
--- ../prev/linux/drivers/net/bcm/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/Makefile	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,13 @@
+
+#
+# Makefile for linux/drivers/net/bcm
+#
+
+O_TARGET := bcm5700.o
+obj-y    := b57um.o b57proc.o tigon3.o autoneg.o 5701rls.o
+obj-m    := $(O_TARGET)
+
+EXTRA_CFLAGS = -DDBG=0 -DT3_JUMBO_RCV_RCB_ENTRY_COUNT=256 -DNICE_SUPPORT -DPCIX_TARGET_WORKAROUND=1 -DINCLUDE_TBI_SUPPORT -DINCLUDE_5701_AX_FIX=1
+
+include $(TOPDIR)/Rules.make
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/autoneg.c linux/drivers/net/bcm/autoneg.c
--- ../prev/linux/drivers/net/bcm/autoneg.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/autoneg.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,535 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+#if INCLUDE_TBI_SUPPORT
+#include "autoneg.h"
+#include "mm.h"
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+MM_AnTxConfig(
+    PAN_STATE_INFO pAnInfo)
+{
+    PLM_DEVICE_BLOCK pDevice;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    REG_WR(pDevice, MacCtrl.TxAutoNeg, (LM_UINT32) pAnInfo->TxConfig.AsUSHORT);
+
+    pDevice->MacMode |= MAC_MODE_SEND_CONFIGS;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+MM_AnTxIdle(
+    PAN_STATE_INFO pAnInfo)
+{
+    PLM_DEVICE_BLOCK pDevice;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    pDevice->MacMode &= ~MAC_MODE_SEND_CONFIGS;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+char
+MM_AnRxConfig(
+    PAN_STATE_INFO pAnInfo,
+    unsigned short *pRxConfig)
+{
+    PLM_DEVICE_BLOCK pDevice;
+    LM_UINT32 Value32;
+    char Retcode;
+
+    Retcode = AN_FALSE;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if(Value32 & MAC_STATUS_RECEIVING_CFG)
+    {
+        Value32 = REG_RD(pDevice, MacCtrl.RxAutoNeg);
+        *pRxConfig = (unsigned short) Value32;
+
+        Retcode = AN_TRUE;
+    }
+
+    return Retcode;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+AutonegInit(
+    PAN_STATE_INFO pAnInfo)
+{
+    unsigned long j;
+
+    for(j = 0; j < sizeof(AN_STATE_INFO); j++)
+    {
+        ((unsigned char *) pAnInfo)[j] = 0;
+    }
+
+    /* Initialize the default advertisement register. */
+    pAnInfo->mr_adv_full_duplex = 1;
+    pAnInfo->mr_adv_sym_pause = 1;
+    pAnInfo->mr_adv_asym_pause = 1;
+    pAnInfo->mr_an_enable = 1;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+AUTONEG_STATUS
+Autoneg8023z(
+    PAN_STATE_INFO pAnInfo)
+{
+    unsigned short RxConfig;
+    unsigned long Delta_us;
+    AUTONEG_STATUS AnRet;
+
+    /* Get the current time. */
+    if(pAnInfo->State == AN_STATE_UNKNOWN)
+    {
+        pAnInfo->RxConfig.AsUSHORT = 0;
+        pAnInfo->CurrentTime_us = 0;
+        pAnInfo->LinkTime_us = 0;
+        pAnInfo->AbilityMatchCfg = 0;
+        pAnInfo->AbilityMatchCnt = 0;
+        pAnInfo->AbilityMatch = AN_FALSE;
+        pAnInfo->IdleMatch = AN_FALSE;
+        pAnInfo->AckMatch = AN_FALSE;
+    }
+
+    /* Increment the timer tick.  This function is called every microsecon. */
+//    pAnInfo->CurrentTime_us++;
+
+    /* Set the AbilityMatch, IdleMatch, and AckMatch flags if their */
+    /* corresponding conditions are satisfied. */
+    if(MM_AnRxConfig(pAnInfo, &RxConfig))
+    {
+        if(RxConfig != pAnInfo->AbilityMatchCfg)
+        {
+            pAnInfo->AbilityMatchCfg = RxConfig;
+            pAnInfo->AbilityMatch = AN_FALSE;
+            pAnInfo->AbilityMatchCnt = 0;
+        }
+        else
+        {
+            pAnInfo->AbilityMatchCnt++;
+            if(pAnInfo->AbilityMatchCnt > 1)
+            {
+                pAnInfo->AbilityMatch = AN_TRUE;
+                pAnInfo->AbilityMatchCfg = RxConfig;
+            }
+        }
+
+        if(RxConfig & AN_CONFIG_ACK)
+        {
+            pAnInfo->AckMatch = AN_TRUE;
+        }
+        else
+        {
+            pAnInfo->AckMatch = AN_FALSE;
+        }
+
+        pAnInfo->IdleMatch = AN_FALSE;
+    }
+    else
+    {
+        pAnInfo->IdleMatch = AN_TRUE;
+
+        pAnInfo->AbilityMatchCfg = 0;
+        pAnInfo->AbilityMatchCnt = 0;
+        pAnInfo->AbilityMatch = AN_FALSE;
+        pAnInfo->AckMatch = AN_FALSE;
+
+        RxConfig = 0;
+    }
+
+    /* Save the last Config. */
+    pAnInfo->RxConfig.AsUSHORT = RxConfig;
+
+    /* Default return code. */
+    AnRet = AUTONEG_STATUS_OK;
+
+    /* Autoneg state machine as defined in 802.3z section 37.3.1.5. */
+    switch(pAnInfo->State)
+    {
+        case AN_STATE_UNKNOWN:
+            if(pAnInfo->mr_an_enable || pAnInfo->mr_restart_an)
+            {
+                pAnInfo->CurrentTime_us = 0;
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+            }
+
+            /* Fall through.*/
+
+        case AN_STATE_AN_ENABLE:
+            pAnInfo->mr_an_complete = AN_FALSE;
+            pAnInfo->mr_page_rx = AN_FALSE;
+
+            if(pAnInfo->mr_an_enable)
+            {
+                pAnInfo->LinkTime_us = 0;
+                pAnInfo->AbilityMatchCfg = 0;
+                pAnInfo->AbilityMatchCnt = 0;
+                pAnInfo->AbilityMatch = AN_FALSE;
+                pAnInfo->IdleMatch = AN_FALSE;
+                pAnInfo->AckMatch = AN_FALSE;
+
+                pAnInfo->State = AN_STATE_AN_RESTART_INIT;
+            }
+            else
+            {
+                pAnInfo->State = AN_STATE_DISABLE_LINK_OK;
+            }
+            break;
+
+        case AN_STATE_AN_RESTART_INIT:
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+            pAnInfo->mr_np_loaded = AN_FALSE;
+
+            pAnInfo->TxConfig.AsUSHORT = 0;
+            MM_AnTxConfig(pAnInfo);
+
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            pAnInfo->State = AN_STATE_AN_RESTART;
+
+            /* Fall through.*/
+
+        case AN_STATE_AN_RESTART:
+            /* Get the current time and compute the delta with the saved */
+            /* link timer. */
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+                pAnInfo->State = AN_STATE_ABILITY_DETECT_INIT;
+            }
+            else
+            {
+                AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+            }
+            break;
+
+        case AN_STATE_DISABLE_LINK_OK:
+            AnRet = AUTONEG_STATUS_DONE;
+            break;
+
+        case AN_STATE_ABILITY_DETECT_INIT:
+            /* Note: in the state diagram, this variable is set to */
+            /* mr_adv_ability<12>.  Is this right?. */
+            pAnInfo->mr_toggle_tx = AN_FALSE;
+
+#if DBG
+            DbgMessage(INFORM, ("TxConfig: "));
+
+            if(pAnInfo->mr_adv_full_duplex)
+            {
+                DbgMessage(INFORM, ("FD "));
+            }
+
+            if(pAnInfo->mr_adv_half_duplex)
+            {
+                DbgMessage(INFORM, ("HD "));
+            }
+
+            if(pAnInfo->mr_adv_sym_pause)
+            {
+                DbgMessage(INFORM, ("PS1 "));
+            }
+
+            if(pAnInfo->mr_adv_asym_pause)
+            {
+                DbgMessage(INFORM, ("PS2 "));
+            }
+
+            if(pAnInfo->mr_adv_remote_fault1)
+            {
+                DbgMessage(INFORM, ("RF1 "));
+            }
+
+            if(pAnInfo->mr_adv_remote_fault2)
+            {
+                DbgMessage(INFORM, ("RF2 "));
+            }
+
+            if(pAnInfo->mr_adv_next_page)
+            {
+                DbgMessage(INFORM, ("NP "));
+            }
+
+            DbgMessage(INFORM, ("\n"));
+#endif
+
+            /* Send the config as advertised in the advertisement register. */
+            pAnInfo->TxConfig.AsUSHORT = 0;
+            pAnInfo->TxConfig.D5_FD = pAnInfo->mr_adv_full_duplex;
+            pAnInfo->TxConfig.D6_HD = pAnInfo->mr_adv_half_duplex;
+            pAnInfo->TxConfig.D7_PS1 = pAnInfo->mr_adv_sym_pause;
+            pAnInfo->TxConfig.D8_PS2 = pAnInfo->mr_adv_asym_pause;
+            pAnInfo->TxConfig.D12_RF1 = pAnInfo->mr_adv_remote_fault1;
+            pAnInfo->TxConfig.D13_RF2 = pAnInfo->mr_adv_remote_fault2;
+            pAnInfo->TxConfig.D15_NP = pAnInfo->mr_adv_next_page;
+
+            MM_AnTxConfig(pAnInfo);
+
+            pAnInfo->State = AN_STATE_ABILITY_DETECT;
+
+            break;
+
+        case AN_STATE_ABILITY_DETECT:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT != 0)
+            {
+                pAnInfo->State = AN_STATE_ACK_DETECT_INIT;
+            }
+
+            break;
+
+        case AN_STATE_ACK_DETECT_INIT:
+            pAnInfo->TxConfig.D14_ACK = 1;
+            MM_AnTxConfig(pAnInfo);
+
+            pAnInfo->State = AN_STATE_ACK_DETECT;
+
+            /* Fall through. */
+
+        case AN_STATE_ACK_DETECT:
+            if(pAnInfo->AckMatch == AN_TRUE)
+            {
+                if((pAnInfo->RxConfig.AsUSHORT & ~AN_CONFIG_ACK) ==
+                    (pAnInfo->AbilityMatchCfg & ~AN_CONFIG_ACK))
+                {
+                    pAnInfo->State = AN_STATE_COMPLETE_ACK_INIT;
+                }
+                else
+                {
+                    DbgMessage(FATAL, ("1 ACK_DETECT ===> AN_ENABLE.\n"));
+                    pAnInfo->State = AN_STATE_AN_ENABLE;
+                }
+            }
+            else if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("2 ACK_DETECT ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+            }
+
+            break;
+
+        case AN_STATE_COMPLETE_ACK_INIT:
+            /* Make sure invalid bits are not set. */
+            if(pAnInfo->RxConfig.bits.D0 || pAnInfo->RxConfig.bits.D1 ||
+                pAnInfo->RxConfig.bits.D2 || pAnInfo->RxConfig.bits.D3 ||
+                pAnInfo->RxConfig.bits.D4 || pAnInfo->RxConfig.bits.D9 ||
+                pAnInfo->RxConfig.bits.D10 || pAnInfo->RxConfig.bits.D11)
+            {
+                DbgMessage(FATAL, ("Received an invalid Config.\n"));
+                DbgBreak();
+                AnRet = AUTONEG_STATUS_FAILED;
+                break;
+            }
+
+            /* Set up the link partner advertisement register. */
+            pAnInfo->mr_lp_adv_full_duplex = pAnInfo->RxConfig.D5_FD;
+            pAnInfo->mr_lp_adv_half_duplex = pAnInfo->RxConfig.D6_HD;
+            pAnInfo->mr_lp_adv_sym_pause = pAnInfo->RxConfig.D7_PS1;
+            pAnInfo->mr_lp_adv_asym_pause = pAnInfo->RxConfig.D8_PS2;
+            pAnInfo->mr_lp_adv_remote_fault1 = pAnInfo->RxConfig.D12_RF1;
+            pAnInfo->mr_lp_adv_remote_fault2 = pAnInfo->RxConfig.D13_RF2;
+            pAnInfo->mr_lp_adv_next_page = pAnInfo->RxConfig.D15_NP;
+#if DBG
+            DbgMessage(INFORM, ("RxConfig: "));
+
+            if(pAnInfo->mr_lp_adv_full_duplex)
+            {
+                DbgMessage(INFORM, ("FD "));
+            }
+
+            if(pAnInfo->mr_lp_adv_half_duplex)
+            {
+                DbgMessage(INFORM, ("HD "));
+            }
+
+            if(pAnInfo->mr_lp_adv_sym_pause)
+            {
+                DbgMessage(INFORM, ("PS1 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_asym_pause)
+            {
+                DbgMessage(INFORM, ("PS2 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_remote_fault1)
+            {
+                DbgMessage(INFORM, ("RF1 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_remote_fault2)
+            {
+                DbgMessage(INFORM, ("RF2 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_next_page)
+            {
+                DbgMessage(INFORM, ("NP "));
+            }
+
+            DbgMessage(INFORM, ("\n"));
+#endif
+
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+
+            pAnInfo->mr_toggle_tx = !pAnInfo->mr_toggle_tx;
+            pAnInfo->mr_toggle_rx = pAnInfo->RxConfig.bits.D11;
+            pAnInfo->mr_np_rx = pAnInfo->RxConfig.D15_NP;
+            pAnInfo->mr_page_rx = AN_TRUE;
+
+            pAnInfo->State = AN_STATE_COMPLETE_ACK;
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            break;
+
+        case AN_STATE_COMPLETE_ACK:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("COMPLETE_ACK ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+                break;
+            }
+
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+                if(pAnInfo->mr_adv_next_page == 0 ||
+                    pAnInfo->mr_lp_adv_next_page == 0)
+                {
+                    pAnInfo->State = AN_STATE_IDLE_DETECT_INIT;
+                }
+                else
+                {
+                    if(pAnInfo->TxConfig.bits.D15 == 0 &&
+                        pAnInfo->mr_np_rx == 0)
+                    {
+                        pAnInfo->State = AN_STATE_IDLE_DETECT_INIT;
+                    }
+                    else
+                    {
+                        DbgMessage(FATAL, ("Next page not implemented.\n"));
+                        DbgBreak();
+                        AnRet = AUTONEG_STATUS_FAILED;
+                    }
+                }
+            }
+
+            break;
+
+        case AN_STATE_IDLE_DETECT_INIT:
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+
+            MM_AnTxIdle(pAnInfo);
+
+            pAnInfo->State = AN_STATE_IDLE_DETECT;
+
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            break;
+
+        case AN_STATE_IDLE_DETECT:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("IDLE_DETECT ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+                break;
+            }
+
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+//                if(pAnInfo->IdleMatch == AN_TRUE)
+//                {
+                    pAnInfo->State = AN_STATE_LINK_OK;
+//                }
+//                else
+//                {
+//                    DbgMessage(FATAL, ("Autoneg failed in IDLE_DETECT.\n"));
+//                    AnRet = AUTONEG_STATUS_FAILED;
+//                    break;
+//                }
+            }
+
+            break;
+
+        case AN_STATE_LINK_OK:
+            pAnInfo->mr_an_complete = AN_TRUE;
+            pAnInfo->mr_link_ok = AN_TRUE;
+            AnRet = AUTONEG_STATUS_DONE;
+
+            break;
+
+        case AN_STATE_NEXT_PAGE_WAIT_INIT:
+            DbgMessage(FATAL, ("Not implemented.\n"));
+            DbgBreak();
+            break;
+
+        case AN_STATE_NEXT_PAGE_WAIT:
+            DbgMessage(FATAL, ("Not implemented.\n"));
+            DbgBreak();
+            break;
+
+        default:
+            DbgMessage(FATAL, ("Invalid AN state.\n"));
+            DbgBreak();
+            AnRet = AUTONEG_STATUS_FAILED;
+            break;
+    }
+
+    return AnRet;
+}
+#endif /* INCLUDE_TBI_SUPPORT */
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/autoneg.h linux/drivers/net/bcm/autoneg.h
--- ../prev/linux/drivers/net/bcm/autoneg.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/autoneg.h	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,416 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+
+#ifndef AUTONEG_H
+#define AUTONEG_H
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+#define AN_LINK_TIMER_INTERVAL_US           9000       /* 10ms */
+
+/* TRUE, FALSE */
+#define AN_TRUE                             1
+#define AN_FALSE                            0
+
+
+
+/******************************************************************************/
+/* Main data structure for keeping track of 802.3z auto-negotation state */
+/* variables as shown in Figure 37-6 of the IEEE 802.3z specification. */
+/******************************************************************************/
+
+typedef struct
+{
+    /* Current auto-negotiation state. */
+    unsigned long State;
+    #define AN_STATE_UNKNOWN                        0
+    #define AN_STATE_AN_ENABLE                      1
+    #define AN_STATE_AN_RESTART_INIT                2
+    #define AN_STATE_AN_RESTART                     3
+    #define AN_STATE_DISABLE_LINK_OK                4
+    #define AN_STATE_ABILITY_DETECT_INIT            5
+    #define AN_STATE_ABILITY_DETECT                 6
+    #define AN_STATE_ACK_DETECT_INIT                7
+    #define AN_STATE_ACK_DETECT                     8
+    #define AN_STATE_COMPLETE_ACK_INIT              9
+    #define AN_STATE_COMPLETE_ACK                   10
+    #define AN_STATE_IDLE_DETECT_INIT               11
+    #define AN_STATE_IDLE_DETECT                    12
+    #define AN_STATE_LINK_OK                        13
+    #define AN_STATE_NEXT_PAGE_WAIT_INIT            14
+    #define AN_STATE_NEXT_PAGE_WAIT                 16
+
+    /* Link timer. */
+    unsigned long LinkTime_us;
+
+    /* Current time. */
+    unsigned long CurrentTime_us;
+
+    /* Need these values for consistency check. */
+    unsigned short AbilityMatchCfg;
+
+    /* Ability, idle, and ack match functions. */
+    unsigned long AbilityMatchCnt;
+    char AbilityMatch;
+    char IdleMatch;
+    char AckMatch;
+
+    /* Tx config data */
+    union
+    {
+        /* The TxConfig register is arranged as follows:                      */
+        /*                                                                    */
+        /* MSB                                                           LSB  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        /* | D7| D6| D5| D4| D3| D2| D1| D0|D15|D14|D13|D12|D11|D10| D9| D8|  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        struct
+        {
+#ifdef BIG_ENDIAN_HOST
+            unsigned short D7:1;        /* PS1 */
+            unsigned short D6:1;        /* HD */
+            unsigned short D5:1;        /* FD */
+            unsigned short D4:1;
+            unsigned short D3:1;
+            unsigned short D2:1;
+            unsigned short D1:1;
+            unsigned short D0:1;
+            unsigned short D15:1;       /* NP */
+            unsigned short D14:1;       /* ACK */
+            unsigned short D13:1;       /* RF2 */
+            unsigned short D12:1;       /* RF1 */
+            unsigned short D11:1;
+            unsigned short D10:1;
+            unsigned short D9:1;
+            unsigned short D8:1;        /* PS2 */
+#else /* BIG_ENDIAN_HOST */
+            unsigned int D8:1;        /* PS2 */
+            unsigned int D9:1;
+            unsigned int D10:1;
+            unsigned int D11:1;
+            unsigned int D12:1;       /* RF1 */
+            unsigned int D13:1;       /* RF2 */
+            unsigned int D14:1;       /* ACK */
+            unsigned int D15:1;       /* NP */
+            unsigned int D0:1;
+            unsigned int D1:1;
+            unsigned int D2:1;
+            unsigned int D3:1;
+            unsigned int D4:1;
+            unsigned int D5:1;        /* FD */
+            unsigned int D6:1;        /* HD */
+            unsigned int D7:1;        /* PS1 */
+#endif
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define D8_PS2                      bits.D8
+        #define D12_RF1                     bits.D12
+        #define D13_RF2                     bits.D13
+        #define D14_ACK                     bits.D14
+        #define D15_NP                      bits.D15
+        #define D5_FD                       bits.D5
+        #define D6_HD                       bits.D6
+        #define D7_PS1                      bits.D7
+    } TxConfig;
+
+    /* Rx config data */
+    union
+    {
+        /* The RxConfig register is arranged as follows:                      */
+        /*                                                                    */
+        /* MSB                                                           LSB  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        /* | D7| D6| D5| D4| D3| D2| D1| D0|D15|D14|D13|D12|D11|D10| D9| D8|  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        struct
+        {
+#ifdef BIG_ENDIAN_HOST
+	    unsigned short D7:1;        /* PS1 */
+            unsigned short D6:1;        /* HD */
+	    unsigned short D5:1;        /* FD */
+            unsigned short D4:1;
+            unsigned short D3:1;
+            unsigned short D2:1;
+            unsigned short D1:1;
+            unsigned short D0:1;
+  	    unsigned short D15:1;       /* NP */
+            unsigned short D14:1;       /* ACK */
+            unsigned short D13:1;       /* RF2 */    
+            unsigned short D12:1;       /* RF1 */
+            unsigned short D11:1;
+            unsigned short D10:1;
+            unsigned short D9:1;
+            unsigned short D8:1;        /* PS2 */
+#else /* BIG_ENDIAN_HOST */
+            unsigned int D8:1;        /* PS2 */
+            unsigned int D9:1;
+            unsigned int D10:1;
+            unsigned int D11:1;
+            unsigned int D12:1;       /* RF1 */
+            unsigned int D13:1;       /* RF2 */
+            unsigned int D14:1;       /* ACK */
+            unsigned int D15:1;       /* NP */
+            unsigned int D0:1;
+            unsigned int D1:1;
+            unsigned int D2:1;
+            unsigned int D3:1;
+            unsigned int D4:1;
+            unsigned int D5:1;        /* FD */
+            unsigned int D6:1;        /* HD */
+            unsigned int D7:1;        /* PS1 */
+#endif
+        } bits;
+
+        unsigned short AsUSHORT;
+    } RxConfig;
+
+    #define AN_CONFIG_NP                            0x0080
+    #define AN_CONFIG_ACK                           0x0040
+    #define AN_CONFIG_RF2                           0x0020
+    #define AN_CONFIG_RF1                           0x0010
+    #define AN_CONFIG_PS2                           0x0001
+    #define AN_CONFIG_PS1                           0x8000
+    #define AN_CONFIG_HD                            0x4000
+    #define AN_CONFIG_FD                            0x2000
+
+
+    /* Management registers. */
+
+    /* Control register. */
+    union
+    {
+        struct
+        {
+            unsigned int an_enable:1;
+            unsigned int loopback:1;
+            unsigned int reset:1;
+            unsigned int restart_an:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_an_enable                Mr0.bits.an_enable
+        #define mr_loopback                 Mr0.bits.loopback
+        #define mr_main_reset               Mr0.bits.reset
+        #define mr_restart_an               Mr0.bits.restart_an
+    } Mr0;
+
+    /* Status register. */
+    union
+    {
+        struct
+        {
+            unsigned int an_complete:1;
+            unsigned int link_ok:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_an_complete              Mr1.bits.an_complete
+        #define mr_link_ok                  Mr1.bits.link_ok
+    } Mr1;
+
+    /* Advertisement register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_4:5;
+            unsigned int full_duplex:1;
+            unsigned int half_duplex:1;
+            unsigned int sym_pause:1;
+            unsigned int asym_pause:1;
+            unsigned int reserved_11:3;
+            unsigned int remote_fault1:1;
+            unsigned int remote_fault2:1;
+            unsigned int reserved_14:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_adv_full_duplex          Mr4.bits.full_duplex
+        #define mr_adv_half_duplex          Mr4.bits.half_duplex
+        #define mr_adv_sym_pause            Mr4.bits.sym_pause
+        #define mr_adv_asym_pause           Mr4.bits.asym_pause
+        #define mr_adv_remote_fault1        Mr4.bits.remote_fault1
+        #define mr_adv_remote_fault2        Mr4.bits.remote_fault2
+        #define mr_adv_next_page            Mr4.bits.next_page
+    } Mr4;
+
+    /* Link partner advertisement register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_4:5;
+            unsigned int lp_full_duplex:1;
+            unsigned int lp_half_duplex:1;
+            unsigned int lp_sym_pause:1;
+            unsigned int lp_asym_pause:1;
+            unsigned int reserved_11:3;
+            unsigned int lp_remote_fault1:1;
+            unsigned int lp_remote_fault2:1;
+            unsigned int lp_ack:1;
+            unsigned int lp_next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_lp_adv_full_duplex       Mr5.bits.lp_full_duplex
+        #define mr_lp_adv_half_duplex       Mr5.bits.lp_half_duplex
+        #define mr_lp_adv_sym_pause         Mr5.bits.lp_sym_pause
+        #define mr_lp_adv_asym_pause        Mr5.bits.lp_asym_pause
+        #define mr_lp_adv_remote_fault1     Mr5.bits.lp_remote_fault1
+        #define mr_lp_adv_remote_fault2     Mr5.bits.lp_remote_fault2
+        #define mr_lp_adv_next_page         Mr5.bits.lp_next_page
+    } Mr5;
+
+    /* Auto-negotiation expansion register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_0:1;
+            unsigned int page_received:1;
+            unsigned int next_pageable:1;
+            unsigned int reserved_15:13;
+        } bits;
+
+        unsigned short AsUSHORT;
+    } Mr6;
+
+    /* Auto-negotiation next page transmit register. */
+    union
+    {
+        struct
+        {
+            unsigned int code_field:11;
+            unsigned int toggle:1;
+            unsigned int ack2:1;
+            unsigned int message_page:1;
+            unsigned int reserved_14:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_np_tx                    Mr7.AsUSHORT
+    } Mr7;
+
+    /* Auto-negotiation link partner ability register. */
+    union
+    {
+        struct
+        {
+            unsigned int code_field:11;
+            unsigned int toggle:1;
+            unsigned int ack2:1;
+            unsigned int message_page:1;
+            unsigned int ack:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+        
+        #define mr_lp_np_rx                 Mr8.AsUSHORT
+    } Mr8;
+
+    /* Extended status register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_11:12;
+            unsigned int base1000_t_hd:1;
+            unsigned int base1000_t_fd:1;
+            unsigned int base1000_x_hd:1;
+            unsigned int base1000_x_fd:1;
+        } bits;      
+
+        unsigned short AsUSHORT;
+    } Mr15;
+
+    /* Miscellaneous state variables. */
+    union
+    {
+        struct
+        {
+            unsigned int toggle_tx:1;
+            unsigned int toggle_rx:1;
+            unsigned int np_rx:1;
+            unsigned int page_rx:1;
+            unsigned int np_loaded:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_toggle_tx                MrMisc.bits.toggle_tx
+        #define mr_toggle_rx                MrMisc.bits.toggle_rx
+        #define mr_np_rx                    MrMisc.bits.np_rx
+        #define mr_page_rx                  MrMisc.bits.page_rx
+        #define mr_np_loaded                MrMisc.bits.np_loaded
+    } MrMisc;
+
+
+    /* Implement specifics */
+
+    /* Pointer to the operating system specific data structure. */
+    void *pContext;
+} AN_STATE_INFO, *PAN_STATE_INFO;
+
+
+
+/******************************************************************************/
+/* Return code of Autoneg8023z. */
+/******************************************************************************/
+
+typedef enum
+{
+    AUTONEG_STATUS_OK               = 0,
+    AUTONEG_STATUS_DONE             = 1,
+    AUTONEG_STATUS_TIMER_ENABLED    = 2,
+//    AUTONEG_STATUS_FAILED           = 0xffffffff,
+    AUTONEG_STATUS_FAILED           = 0xfffffff
+} AUTONEG_STATUS, *PAUTONEG_STATUS;
+
+
+
+/******************************************************************************/
+/* Function prototypes. */
+/******************************************************************************/
+
+AUTONEG_STATUS Autoneg8023z(PAN_STATE_INFO pAnInfo);
+void AutonegInit(PAN_STATE_INFO pAnInfo);
+
+
+
+/******************************************************************************/
+/* The following functions are defined in the os-dependent module. */
+/******************************************************************************/
+
+void MM_AnTxConfig(PAN_STATE_INFO pAnInfo);
+void MM_AnTxIdle(PAN_STATE_INFO pAnInfo);
+char MM_AnRxConfig(PAN_STATE_INFO pAnInfo, unsigned short *pRxConfig);
+
+
+
+#endif /* AUTONEG_H */
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/b57proc.c linux/drivers/net/bcm/b57proc.c
--- ../prev/linux/drivers/net/bcm/b57proc.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/b57proc.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,341 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* /proc file system handling code.                                           */
+/*                                                                            */
+/******************************************************************************/
+
+#include "mm.h"
+#ifdef CONFIG_PROC_FS
+
+#define NICINFO_PROC_DIR "nicinfo"
+
+static struct proc_dir_entry *bcm5700_procfs_dir;
+
+extern char bcm5700_driver[], bcm5700_version[];
+
+extern LM_UINT32 bcm5700_crc_count(PUM_DEVICE_BLOCK pUmDevice);
+
+static struct proc_dir_entry *
+proc_getdir(char *name, struct proc_dir_entry *proc_dir)
+{
+	struct proc_dir_entry *pde = proc_dir;
+
+	lock_kernel();
+	for (pde=pde->subdir; pde; pde = pde->next) {
+		if (pde->namelen && (strcmp(name, pde->name) == 0)) {
+			/* directory exists */
+			break;
+		}
+	}
+	if (pde == (struct proc_dir_entry *) 0)
+	{
+		/* create the directory */
+#if (LINUX_VERSION_CODE > 0x20300)
+		pde = proc_mkdir(name, proc_dir);
+#else
+		pde = create_proc_entry(name, S_IFDIR, proc_dir);
+#endif
+		if (pde == (struct proc_dir_entry *) 0) {
+			unlock_kernel();
+			return (pde);
+		}
+	}
+	unlock_kernel();
+	return (pde);
+}
+
+int
+bcm5700_proc_create(void)
+{
+	bcm5700_procfs_dir = proc_getdir(NICINFO_PROC_DIR, proc_net);
+
+	if (bcm5700_procfs_dir == (struct proc_dir_entry *) 0) {
+		printk(KERN_DEBUG "Could not create procfs nicinfo directory %s\n", NICINFO_PROC_DIR);
+		return -1;
+	}
+	return 0;
+}
+
+int
+bcm5700_read_pfs(char *page, char **start, off_t off, int count,
+	int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	int len = 0;
+	LM_UINT32 value32, rx_mac_errors, rx_crc_errors, rx_align_errors;
+	LM_UINT32 rx_runt_errors, rx_frag_errors, rx_long_errors;
+	LM_UINT32 rx_overrun_errors, rx_jabber_errors;
+
+	if (pUmDevice->opened == 0)
+		pStats = 0;
+
+	len += sprintf(page+len, "Description\t\t\t%s\n", pUmDevice->name);
+	len += sprintf(page+len, "Driver_Name\t\t\t%s\n", bcm5700_driver);
+	len += sprintf(page+len, "Driver_Version\t\t\t%s\n", bcm5700_version);
+	len += sprintf(page+len, "Bootcode_Version\t\t%s\n", pDevice->BootCodeVer);
+	len += sprintf(page+len, "PCI_Vendor\t\t\t0x%04x\n", pDevice->PciVendorId);
+	len += sprintf(page+len, "PCI_Device_ID\t\t\t0x%04x\n",
+		pDevice->PciDeviceId);
+	len += sprintf(page+len, "PCI_Subsystem_Vendor\t\t0x%04x\n",
+		pDevice->SubsystemVendorId);
+	len += sprintf(page+len, "PCI_Subsystem_ID\t\t0x%04x\n",
+		pDevice->SubsystemId);
+	len += sprintf(page+len, "PCI_Revision_ID\t\t\t0x%02x\n",
+		pDevice->PciRevId);
+	len += sprintf(page+len, "PCI_Slot\t\t\t%d\n",
+		PCI_SLOT(pUmDevice->pdev->devfn));
+	len += sprintf(page+len, "PCI_Bus\t\t\t\t%d\n",
+		pUmDevice->pdev->bus->number);
+
+	value32 = pDevice->PciState & (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED);
+	len += sprintf(page+len, "PCI_Bus_Speed\t\t\t%s\n",
+		(value32 == (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS)) ? "32-bit PCI 33MHz" : 
+		((value32 == (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED)) ? "32-bit PCI 66MHz" : 
+		((value32 == T3_PCI_STATE_NOT_PCI_X_BUS) ? "64-bit PCI 33MHz" : 
+		((value32 == (T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED)) ? "64-bit PCI 66MHz" : 
+		((value32 == 0) ? "64-bit PCIX 100MHz" : 
+		(value32 == T3_PCI_STATE_HIGH_BUS_SPEED) ? "64-bit PCIX 133MHz":
+			"N/A")))));
+	len += sprintf(page+len, "Memory\t\t\t\t0x%lx\n", pUmDevice->dev->base_addr);
+	len += sprintf(page+len, "IRQ\t\t\t\t%d\n", dev->irq);
+	len += sprintf(page+len, "System_Device_Name\t\t%s\n", dev->name);
+	len += sprintf(page+len, "Current_HWaddr\t\t\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+	len += sprintf(page+len,
+		"Permanent_HWaddr\t\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+		pDevice->NodeAddress[0], pDevice->NodeAddress[1],
+		pDevice->NodeAddress[2], pDevice->NodeAddress[3],
+		pDevice->NodeAddress[4], pDevice->NodeAddress[5]);
+	len += sprintf(page+len, "Part_Number\t\t\t%s\n\n", pDevice->PartNo);
+
+	len += sprintf(page+len, "Link\t\t\t\t%s\n", 
+		(pUmDevice->opened == 0) ? "unknown" :
+    		((pDevice->LinkStatus == LM_STATUS_LINK_ACTIVE) ? "up" :
+		"down"));
+	len += sprintf(page+len, "Speed\t\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+    		((pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) ? "1000" :
+    		((pDevice->LineSpeed == LM_LINE_SPEED_100MBPS) ? "100" :
+    		(pDevice->LineSpeed == LM_LINE_SPEED_10MBPS) ? "10" : "N/A")));
+	len += sprintf(page+len, "Duplex\t\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+		((pDevice->DuplexMode == LM_DUPLEX_MODE_FULL) ? "full" :
+			"half"));
+	len += sprintf(page+len, "Flow_Control\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+		((pDevice->FlowControl == LM_FLOW_CONTROL_NONE) ? "off" :
+		(((pDevice->FlowControl & LM_FLOW_CONTROL_RX_TX_PAUSE) ==
+			LM_FLOW_CONTROL_RX_TX_PAUSE) ? "receive/transmit" :
+		(pDevice->FlowControl & LM_FLOW_CONTROL_RECEIVE_PAUSE) ?
+			"receive" : "transmit")));
+	len += sprintf(page+len, "State\t\t\t\t%s\n", 
+    		(dev->flags & IFF_UP) ? "up" : "down");
+	len += sprintf(page+len, "MTU_Size\t\t\t%d\n\n", dev->mtu);
+	len += sprintf(page+len, "Rx_Packets\t\t\t%u\n", 
+			((pStats == 0) ? 0 :
+			pStats->ifHCInUcastPkts.Low +
+			pStats->ifHCInMulticastPkts.Low +
+			pStats->ifHCInBroadcastPkts.Low));
+	if (dev->mtu > 1500) {
+		len += sprintf(page+len, "Rx_Jumbo_Packets\t\t%u\n", 
+			((pStats == 0) ? 0 :
+			pStats->etherStatsPkts1523Octetsto2047Octets.Low +
+			pStats->etherStatsPkts2048Octetsto4095Octets.Low +
+			pStats->etherStatsPkts4096Octetsto8191Octets.Low +
+			pStats->etherStatsPkts8192Octetsto9022Octets.Low));
+	}
+	len += sprintf(page+len, "Tx_Packets\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->COSIfHCOutPkts[0].Low));
+	len += sprintf(page+len, "Rx_Bytes\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifHCInOctets.Low));
+	len += sprintf(page+len, "Tx_Bytes\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifHCOutOctets.Low));
+	if (pStats == 0) {
+		rx_crc_errors = 0;
+		rx_align_errors = 0;
+		rx_runt_errors = 0;
+		rx_frag_errors = 0;
+		rx_long_errors = 0;
+		rx_overrun_errors = 0;
+		rx_jabber_errors = 0;
+	}
+	else {
+		rx_crc_errors = bcm5700_crc_count(pUmDevice);
+		rx_align_errors = pStats->dot3StatsAlignmentErrors.Low;
+		rx_runt_errors = pStats->etherStatsUndersizePkts.Low;
+		rx_frag_errors = pStats->etherStatsFragments.Low;
+		rx_long_errors = pStats->dot3StatsFramesTooLong.Low;
+		rx_overrun_errors = pStats->nicNoMoreRxBDs.Low;
+		rx_jabber_errors = pStats->etherStatsJabbers.Low;
+	}
+	rx_mac_errors = rx_crc_errors + rx_align_errors + rx_runt_errors +
+		rx_frag_errors + rx_long_errors + rx_jabber_errors;
+	len += sprintf(page+len, "Rx_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		rx_mac_errors + rx_overrun_errors + pUmDevice->rx_misc_errors));
+	len += sprintf(page+len, "Tx_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifOutErrors.Low));
+	len += sprintf(page+len, "\nTx_Carrier_Errors\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->dot3StatsCarrierSenseErrors.Low));
+	len += sprintf(page+len, "Tx_Abort_Excess_Coll\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsExcessiveCollisions.Low));
+	len += sprintf(page+len, "Tx_Abort_Late_Coll\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsLateCollisions.Low));
+	len += sprintf(page+len, "Tx_Deferred_Ok\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsDeferredTransmissions.Low));
+	len += sprintf(page+len, "Tx_Single_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsSingleCollisionFrames.Low));
+	len += sprintf(page+len, "Tx_Multi_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsMultipleCollisionFrames.Low));
+	len += sprintf(page+len, "Tx_Total_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->etherStatsCollisions.Low));
+	len += sprintf(page+len, "\nRx_CRC_Errors\t\t\t%u\n", rx_crc_errors);
+	len += sprintf(page+len, "Rx_Short_Fragment_Errors\t%u\n",
+		rx_frag_errors);
+	len += sprintf(page+len, "Rx_Short_Length_Errors\t\t%u\n",
+		rx_runt_errors);
+	len += sprintf(page+len, "Rx_Long_Length_Errors\t\t%u\n",
+		rx_long_errors);
+	len += sprintf(page+len, "Rx_Align_Errors\t\t\t%u\n",
+		rx_align_errors);
+	len += sprintf(page+len, "Rx_Overrun_Errors\t\t%u\n",
+		rx_overrun_errors);
+	len += sprintf(page+len, "\nTx_MAC_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->dot3StatsInternalMacTransmitErrors.Low));
+	len += sprintf(page+len, "Rx_MAC_Errors\t\t\t%u\n\n",
+		rx_mac_errors);
+
+	len += sprintf(page+len, "Tx_Checksum\t\t\t%s\n",
+		((pDevice->TaskToOffload & LM_TASK_OFFLOAD_TX_TCP_CHECKSUM) ?
+		"ON" : "OFF"));
+	len += sprintf(page+len, "Rx_Checksum\t\t\t%s\n",
+		((pDevice->TaskToOffload & LM_TASK_OFFLOAD_RX_TCP_CHECKSUM) ?
+		"ON" : "OFF"));
+	len += sprintf(page+len, "Scatter_Gather\t\t\t%s\n",
+#if (LINUX_VERSION_CODE >= 0x20400)
+		((dev->features & NETIF_F_SG) ? "ON" : "OFF"));
+#else
+		"OFF");
+#endif
+	len += sprintf(page+len, "Tx_Desc_Count\t\t\t%u\n",
+		pDevice->TxPacketDescCnt);
+	len += sprintf(page+len, "Rx_Desc_Count\t\t\t%u\n",
+		pDevice->RxStdDescCnt);
+	len += sprintf(page+len, "Rx_Jumbo_Desc_Count\t\t%u\n",
+		pDevice->RxJumboDescCnt);
+	len += sprintf(page+len, "Adaptive_Coalescing\t\t%s\n",
+		(pUmDevice->adaptive_coalesce ? "ON" : "OFF"));
+	len += sprintf(page+len, "Rx_Coalescing_Ticks\t\t%u\n",
+		pUmDevice->rx_curr_coalesce_ticks);
+	len += sprintf(page+len, "Rx_Coalesced_Frames\t\t%u\n",
+		pUmDevice->rx_curr_coalesce_frames);
+	len += sprintf(page+len, "Tx_Coalescing_Ticks\t\t%u\n",
+		pDevice->TxCoalescingTicks);
+	len += sprintf(page+len, "Tx_Coalesced_Frames\t\t%u\n",
+		pUmDevice->tx_curr_coalesce_frames);
+	len += sprintf(page+len, "Stats_Coalescing_Ticks\t\t%u\n",
+		pDevice->StatsCoalescingTicks);
+	len += sprintf(page+len, "Wake_On_LAN\t\t\t%s\n",
+        	((pDevice->WakeUpMode & LM_WAKE_UP_MODE_MAGIC_PACKET) ?
+		"ON" : "OFF"));
+#if TIGON3_DEBUG
+	len += sprintf(page+len, "\nDmaReadWriteCtrl\t\t%x\n",
+		pDevice->DmaReadWriteCtrl);
+	len += sprintf(page+len, "\nTx_Zero_Copy_Packets\t\t%u\n",
+		pUmDevice->tx_zc_count);
+	len += sprintf(page+len, "Tx_Chksum_Packets\t\t%u\n",
+		pUmDevice->tx_chksum_count);
+	len += sprintf(page+len, "Tx_Highmem_Fragments\t\t%u\n",
+		pUmDevice->tx_himem_count);
+	len += sprintf(page+len, "Rx_Good_Chksum_Packets\t\t%u\n",
+		pUmDevice->rx_good_chksum_count);
+	len += sprintf(page+len, "Rx_Bad_Chksum_Packets\t\t%u\n",
+		pUmDevice->rx_bad_chksum_count);
+	if (!pDevice->EnableTbi) {
+        	LM_ReadPhy(pDevice, 0, &value32);
+		len += sprintf(page+len, "\nPhy_Register_0x00\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 1, &value32);
+		len += sprintf(page+len, "Phy_Register_0x01\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 2, &value32);
+		len += sprintf(page+len, "Phy_Register_0x02\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 3, &value32);
+		len += sprintf(page+len, "Phy_Register_0x03\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 4, &value32);
+		len += sprintf(page+len, "Phy_Register_0x04\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 5, &value32);
+		len += sprintf(page+len, "Phy_Register_0x05\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 9, &value32);
+		len += sprintf(page+len, "Phy_Register_0x09\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0xa, &value32);
+		len += sprintf(page+len, "Phy_Register_0x0A\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0xf, &value32);
+		len += sprintf(page+len, "Phy_Register_0x0F\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0x10, &value32);
+		len += sprintf(page+len, "Phy_Register_0x10\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0x19, &value32);
+		len += sprintf(page+len, "Phy_Register_0x19\t\t0x%x\n", value32);
+	}
+#endif
+
+	*eof = 1;
+	return len;
+}
+
+int
+bcm5700_proc_create_dev(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	if (!bcm5700_procfs_dir)
+		return -1;
+
+	sprintf(pUmDevice->pfs_name, "%s.info", dev->name);
+	pUmDevice->pfs_entry = create_proc_entry(pUmDevice->pfs_name,
+		S_IFREG, bcm5700_procfs_dir);
+	if (pUmDevice->pfs_entry == 0)
+		return -1;
+	pUmDevice->pfs_entry->read_proc = bcm5700_read_pfs;
+	pUmDevice->pfs_entry->data = dev;
+	return 0;
+}
+int
+bcm5700_proc_remove_dev(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	remove_proc_entry(pUmDevice->pfs_name, bcm5700_procfs_dir);
+	return 0;
+}
+
+#endif
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/b57um.c linux/drivers/net/bcm/b57um.c
--- ../prev/linux/drivers/net/bcm/b57um.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/b57um.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,2922 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/******************************************************************************/
+
+
+char bcm5700_driver[] = "bcm5700";
+char bcm5700_version[] = "2.2.19";
+char bcm5700_date[] = "(04/10/02)";
+
+#define B57UM
+#include "mm.h"
+
+#define TASKLET
+
+/* A few user-configurable values. */
+
+#define MAX_UNITS 16
+/* Used to pass the full-duplex flag, etc. */
+static int line_speed[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int auto_speed[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int full_duplex[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int rx_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int tx_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int auto_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int mtu[MAX_UNITS] = {1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500};	/* Jumbo MTU for interfaces. */
+static int tx_checksum[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int rx_checksum[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int scatter_gather[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+
+#define TX_DESC_CNT DEFAULT_TX_PACKET_DESC_COUNT
+static unsigned int tx_pkt_desc_cnt[MAX_UNITS] =
+	{TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT};
+
+#define RX_DESC_CNT DEFAULT_STD_RCV_DESC_COUNT
+static unsigned int rx_std_desc_cnt[MAX_UNITS] =
+	{RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT };
+
+#define JBO_DESC_CNT DEFAULT_JUMBO_RCV_DESC_COUNT
+static unsigned int rx_jumbo_desc_cnt[MAX_UNITS] =
+	{JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT };
+
+#if INCLUDE_EXT_MEMORY_SUPPORT
+#define MIN_DESC_CNT DEFAULT_MINI_RCV_DESC_COUNT
+static unsigned int rx_mini_desc_cnt[MAX_UNITS] =
+	{MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,
+	MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,
+	MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,
+	MIN_DESC_CNT };
+
+#endif
+static unsigned int adaptive_coalesce[MAX_UNITS] =
+	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+
+#define RX_COAL_TK DEFAULT_RX_COALESCING_TICKS
+static unsigned int rx_coalesce_ticks[MAX_UNITS] =
+	{RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK, RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK,RX_COAL_TK, RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK};
+
+#define RX_COAL_FM DEFAULT_RX_MAX_COALESCED_FRAMES
+static unsigned int rx_max_coalesce_frames[MAX_UNITS] =
+	{RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM};
+
+#define TX_COAL_TK DEFAULT_TX_COALESCING_TICKS
+static unsigned int tx_coalesce_ticks[MAX_UNITS] =
+	{TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK, TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK,TX_COAL_TK, TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK};
+
+#define TX_COAL_FM DEFAULT_TX_MAX_COALESCED_FRAMES
+static unsigned int tx_max_coalesce_frames[MAX_UNITS] =
+	{TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM};
+
+#define ST_COAL_TK DEFAULT_STATS_COALESCING_TICKS
+static unsigned int stats_coalesce_ticks[MAX_UNITS] =
+	{ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,};
+
+static int enable_wol[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+/* Operational parameters that usually are not changed. */
+/* Time in jiffies before concluding the transmitter is hung. */
+#define TX_TIMEOUT  (2*HZ)
+
+#if (LINUX_VERSION_CODE < 0x02030d)
+#define pci_resource_start(dev, bar)	(dev->base_address[bar] & PCI_BASE_ADDRESS_MEM_MASK)
+#elif (LINUX_VERSION_CODE < 0x02032b)
+#define pci_resource_start(dev, bar)	(dev->resource[bar] & PCI_BASE_ADDRESS_MEM_MASK)
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+#define dev_kfree_skb_irq(skb)  dev_kfree_skb(skb)
+#define netif_wake_queue(dev)	clear_bit(0, &dev->tbusy); mark_bh(NET_BH)
+#define netif_stop_queue(dev)	set_bit(0, &dev->tbusy)
+
+static inline void netif_start_queue(struct net_device *dev)
+{
+	dev->tbusy = 0;
+	dev->interrupt = 0;
+	dev->start = 1;
+}
+
+#define netif_queue_stopped(dev)	dev->tbusy
+#define netif_running(dev)		dev->start
+
+static inline void tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	queue_task(tasklet, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static inline void tasklet_init(struct tasklet_struct *tasklet,
+				void (*func)(unsigned long),
+				unsigned long data)
+{
+        tasklet->next = NULL;
+        tasklet->sync = 0;
+        tasklet->routine = (void (*)(void *))func;
+        tasklet->data = (void *)data;
+}
+
+#define tasklet_kill(tasklet)
+
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020300)
+struct pci_device_id {
+	unsigned int vendor, device;		/* Vendor and device ID or PCI_ANY_ID */
+	unsigned int subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
+	unsigned int class, class_mask;		/* (class,subclass,prog-if) triplet */
+	unsigned long driver_data;		/* Data private to the driver */
+};
+
+#define PCI_ANY_ID		0
+
+#define pci_set_drvdata(pdev, dev)
+#define pci_get_drvdata(pdev) 0
+
+#define pci_enable_device(pdev) 0
+
+#define __devinit		__init
+#define __devinitdata		__initdata
+#define __devexit
+
+#define SET_MODULE_OWNER(dev)
+#define MODULE_DEVICE_TABLE(pci, pci_tbl)
+
+#endif
+
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(license)
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032a)
+static inline void *pci_alloc_consistent(struct pci_dev *pdev, size_t size,
+					 dma_addr_t *dma_handle)
+{
+	void *virt_ptr;
+
+	/* Maximum in slab.c */
+	if (size > 131072)
+		return 0;
+
+	virt_ptr = kmalloc(size, GFP_KERNEL);
+	*dma_handle = virt_to_bus(virt_ptr);
+	return virt_ptr;
+}
+#define pci_free_consistent(dev, size, ptr, dma_ptr)	kfree(ptr)
+
+#define pci_map_single(dev, address, size, dir) virt_to_bus(address)
+#define pci_unmap_single(dev, dma_addr, size, dir)
+
+#endif /*#if (LINUX_VERSION_CODE < 0x02032a) */
+
+#if MAX_SKB_FRAGS
+#if (LINUX_VERSION_CODE >= 0x02040d)
+
+typedef dma_addr_t dmaaddr_high_t;
+
+#else
+
+#if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)
+
+typedef unsigned long long dmaaddr_high_t;
+
+#ifndef pci_map_page
+#define pci_map_page bcm_pci_map_page
+#endif
+
+static inline dmaaddr_high_t
+bcm_pci_map_page(struct pci_dev *dev, struct page *page,
+		    int offset, size_t size, int dir)
+{
+	dmaaddr_high_t phys;
+
+	phys = (page-mem_map) *	(dmaaddr_high_t) PAGE_SIZE + offset;
+
+	return phys;
+}
+
+#define pci_unmap_page(dev, map, size, dir)
+
+#else
+
+typedef dma_addr_t dmaaddr_high_t;
+
+/* Warning - This may not work for all architectures if HIGHMEM is defined */
+
+#ifndef pci_map_page
+#define pci_map_page(dev, page, offset, size, dir) \
+	pci_map_single(dev, page_address(page) + (offset), size, dir)
+#endif
+#ifndef pci_unmap_page
+#define pci_unmap_page(dev, map, size, dir) \
+	pci_unmap_single(dev, map, size, dir)
+#endif
+
+#endif /* #if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)*/
+
+#endif /* #if (LINUX_VERSION_CODE >= 0x02040d)*/
+#endif /* #if MAX_SKB_FRAGS*/
+
+#if (LINUX_VERSION_CODE < 0x020329)
+#define pci_set_dma_mask(pdev, mask) (0)
+#else
+#if (LINUX_VERSION_CODE < 0x020403)
+int
+pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask)
+{
+    if(! pci_dma_supported(dev, mask))
+        return -EIO;
+
+    dev->dma_mask = mask;
+
+    return 0;
+}
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020402)
+#define pci_request_regions(pdev, name) (0)
+#define pci_release_regions(pdev)
+#endif
+
+#define set_64bit_addr(paddr, low, high) \
+	(paddr)->Low = low;		\
+	(paddr)->High = high;
+
+static inline void bcm_set_addr(LM_PHYSICAL_ADDRESS *paddr, dma_addr_t addr)
+{
+	unsigned long baddr = (unsigned long) addr;
+#if (BITS_PER_LONG == 64)
+	set_64bit_addr(paddr, baddr & 0xffffffff, baddr >> 32);
+#else
+	set_64bit_addr(paddr, baddr, 0);
+#endif
+}
+
+#if defined (CONFIG_X86)
+#define NO_PCI_UNMAP 1
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020412)
+#if ! defined (NO_PCI_UNMAP)
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME) dma_addr_t ADDR_NAME;
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME) __u32 LEN_NAME;
+
+#define pci_unmap_addr(PTR, ADDR_NAME)	\
+	((PTR)->ADDR_NAME)
+
+#define pci_unmap_len(PTR, LEN_NAME)	\
+	((PTR)->LEN_NAME)
+
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL)	\
+	(((PTR)->ADDR_NAME) = (VAL))
+
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL)	\
+	(((PTR)->LEN_NAME) = (VAL))
+#else
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME)
+#define DECLARE_PCI_UNMAP_LEN(ADDR_NAME)
+
+#define pci_unmap_addr(PTR, ADDR_NAME)	0
+#define pci_unmap_len(PTR, LEN_NAME)	0
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL) do { } while (0)
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL) do { } while (0)
+#endif
+#endif
+
+#if MAX_SKB_FRAGS
+static inline void bcm_set_addr_high(LM_PHYSICAL_ADDRESS *paddr, dmaaddr_high_t addr)
+{
+#if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)
+	set_64bit_addr(paddr, (unsigned long) (addr & 0xffffffff),
+		(unsigned long) (addr >> 32));
+#else
+	bcm_set_addr(paddr, (dma_addr_t) addr);
+#endif
+}
+#endif
+
+#if ! defined(spin_is_locked)
+#define spin_is_locked(lock)    (test_bit(0,(lock)))
+#endif
+
+inline long
+bcm5700_lock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	long flags;
+	
+	if (pUmDevice->do_global_lock) {
+		spin_lock_irqsave(&pUmDevice->global_lock, flags);
+		return flags;
+	}
+	return 0;
+}
+
+inline void
+bcm5700_unlock(PUM_DEVICE_BLOCK pUmDevice, long flags)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_unlock_irqrestore(&pUmDevice->global_lock, flags);
+	}
+}
+
+inline int
+bcm5700_trylock(PUM_DEVICE_BLOCK pUmDevice, long *flags)
+{
+	if (pUmDevice->do_global_lock) {
+		if (spin_is_locked(&pUmDevice->global_lock))
+			return 0;
+		spin_lock_irqsave(&pUmDevice->global_lock, *flags);
+		return 1;
+	}
+	return 1;
+}
+
+inline void
+bcm5700_intr_lock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_lock(&pUmDevice->global_lock);
+	}
+}
+
+inline void
+bcm5700_intr_unlock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_unlock(&pUmDevice->global_lock);
+	}
+}
+
+/*
+ * Broadcom NIC Extension support
+ * -ffan
+ */
+#ifdef NICE_SUPPORT
+#include "nicext.h"
+
+typedef struct {
+	ushort  tag;
+	ushort  signature;
+} vlan_tag_t;
+
+#endif /* NICE_SUPPORT */
+
+typedef struct _UM_PACKET {
+	LM_PACKET lm_packet;
+	struct sk_buff *skbuff;
+#if MAX_SKB_FRAGS
+	DECLARE_PCI_UNMAP_ADDR(map[MAX_SKB_FRAGS + 1])
+	DECLARE_PCI_UNMAP_LEN(map_len[MAX_SKB_FRAGS + 1])
+#else
+	DECLARE_PCI_UNMAP_ADDR(map[1])
+	DECLARE_PCI_UNMAP_LEN(map_len[1])
+#endif
+	LM_FRAG_LIST frag_list;
+#if MAX_SKB_FRAGS
+        LM_FRAG frag_list_bufs[MAX_SKB_FRAGS];
+#endif
+} UM_PACKET, *PUM_PACKET;
+
+int MM_Packet_Desc_Size = sizeof(UM_PACKET);
+
+#if defined(MODULE)
+MODULE_AUTHOR("Michael Chan <mchan@broadcom.com>");
+MODULE_DESCRIPTION("BCM5700 Driver");
+MODULE_LICENSE("GPL");
+MODULE_PARM(debug, "i");
+MODULE_PARM(line_speed, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(auto_speed, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(full_duplex, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(auto_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(mtu, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_checksum, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_checksum, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(scatter_gather, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_pkt_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_std_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_jumbo_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+#if INCLUDE_EXT_MEMORY_SUPPORT
+MODULE_PARM(rx_mini_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+#endif
+MODULE_PARM(adaptive_coalesce, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_max_coalesce_frames, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_max_coalesce_frames, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(stats_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(enable_wol, "1-" __MODULE_STRING(MAX_UNITS) "i");
+#endif
+
+#define RUN_AT(x) (jiffies + (x))
+
+char kernel_version[] = UTS_RELEASE;
+
+#define PCI_SUPPORT_VER2
+
+#if ! defined(CAP_NET_ADMIN)
+#define capable(CAP_XXX) (suser())
+#endif
+
+#define tigon3_debug debug
+#if TIGON3_DEBUG
+static int tigon3_debug = TIGON3_DEBUG;
+#else
+static int tigon3_debug = 0;
+#endif
+
+
+#if DBG
+#define STATIC
+#else
+#define STATIC static
+#endif
+
+STATIC int bcm5700_open(struct net_device *dev);
+STATIC void bcm5700_timer(unsigned long data);
+STATIC void bcm5700_tx_timeout(struct net_device *dev);
+STATIC int bcm5700_start_xmit(struct sk_buff *skb, struct net_device *dev);
+STATIC void bcm5700_interrupt(int irq, void *dev_instance, struct pt_regs *regs);
+STATIC void bcm5700_tasklet(unsigned long data);
+STATIC int bcm5700_close(struct net_device *dev);
+STATIC struct net_device_stats *bcm5700_get_stats(struct net_device *dev);
+STATIC int bcm5700_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+STATIC void bcm5700_set_rx_mode(struct net_device *dev);
+STATIC int bcm5700_set_mac_addr(struct net_device *dev, void *p);
+STATIC int replenish_rx_buffers(PUM_DEVICE_BLOCK pUmDevice);
+STATIC int check_4G_boundary(PUM_DEVICE_BLOCK pUmDevice, PUM_PACKET pUmPacket);
+STATIC int bcm5700_freemem(struct net_device *dev);
+STATIC int bcm5700_adapt_coalesce(PUM_DEVICE_BLOCK pUmDevice);
+
+
+/* A list of all installed bcm5700 devices. */
+static struct net_device *root_tigon3_dev = NULL;
+
+typedef enum {
+	BCM5700VIGIL = 0,
+	BCM5700A6,
+	BCM5700T6,
+	BCM5700A9,
+	BCM5700T9,
+	BCM5700,
+	BCM5701A5,
+	BCM5701T1,
+	BCM5701T8,
+	BCM5701A7,
+	BCM5701A10,
+	BCM5701A12,
+	BCM5701,
+	BCM5702,
+	BCM5703,
+	BCM5703A31,
+	TC996T,
+	TC996ST,
+	TC996SSX,
+	TC996SX,
+	TC996BT,
+	TC997T,
+	TC997SX,
+	TC1000T,
+	TC940BR01,
+	TC942BR01,
+	NC6770,
+	NC7760,
+	NC7770,
+	NC7771,
+	NC7780,
+	NC7781,
+} board_t;
+
+
+/* indexed by board_t, above */
+static struct {
+	char *name;
+} board_info[] __devinitdata = {
+	{ "Broadcom Vigil B5700 1000Base-T" },
+	{ "Broadcom BCM5700 1000Base-T" },
+	{ "Broadcom BCM5700 1000Base-SX" },
+	{ "Broadcom BCM5700 1000Base-SX" },
+	{ "Broadcom BCM5700 1000Base-T" },
+	{ "Broadcom BCM5700" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-SX" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701" },
+	{ "Broadcom BCM5702 1000Base-T" },
+	{ "Broadcom BCM5703 1000Base-T" },
+	{ "Broadcom BCM5703 1000Base-SX" },
+	{ "3Com 3C996 10/100/1000 Server NIC" },
+	{ "3Com 3C996 10/100/1000 Server NIC" },
+	{ "3Com 3C996 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C996 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C996B Gigabit Server NIC" },
+	{ "3Com 3C997 Gigabit Server NIC" },
+	{ "3Com 3C997 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C1000 Gigabit NIC" },
+	{ "3Com 3C940 Gigabit LOM (21X21)" },
+	{ "3Com 3C942 Gigabit LOM (31X31)" },
+	{ "Compaq NC6770 Gigabit Server Adapter" },
+	{ "Compaq NC7760 Gigabit Server Adapter" },
+	{ "Compaq NC7770 Gigabit Server Adapter" },
+	{ "Compaq NC7771 Gigabit Server Adapter" },
+	{ "Compaq NC7780 Gigabit Server Adapter" },
+	{ "Compaq NC7781 Gigabit Server Adapter" },
+	{ 0 },
+	};
+
+static struct pci_device_id bcm5700_pci_tbl[] __devinitdata = {
+	{0x14e4, 0x1644, 0x1014, 0x0277, 0, 0, BCM5700VIGIL },
+	{0x14e4, 0x1644, 0x14e4, 0x1644, 0, 0, BCM5700A6 },
+	{0x14e4, 0x1644, 0x14e4, 0x2, 0, 0, BCM5700T6 },
+	{0x14e4, 0x1644, 0x14e4, 0x3, 0, 0, BCM5700A9 },
+	{0x14e4, 0x1644, 0x14e4, 0x4, 0, 0, BCM5700T9 },
+	{0x14e4, 0x1644, 0x1028, 0xd1, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x0106, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x0109, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x010a, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x10b7, 0x1000, 0, 0, TC996T },
+	{0x14e4, 0x1644, 0x10b7, 0x1001, 0, 0, TC996ST },
+	{0x14e4, 0x1644, 0x10b7, 0x1002, 0, 0, TC996SSX },
+	{0x14e4, 0x1644, 0x10b7, 0x1003, 0, 0, TC997T },
+	{0x14e4, 0x1644, 0x10b7, 0x1005, 0, 0, TC997SX },
+	{0x14e4, 0x1644, 0x10b7, 0x1008, 0, 0, TC942BR01 },
+	{0x14e4, 0x1644, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5700 },
+	{0x14e4, 0x1645, 0x14e4, 1, 0, 0, BCM5701A5 },
+	{0x14e4, 0x1645, 0x14e4, 5, 0, 0, BCM5701T1 },
+	{0x14e4, 0x1645, 0x14e4, 6, 0, 0, BCM5701T8 },
+	{0x14e4, 0x1645, 0x14e4, 7, 0, 0, BCM5701A7 },
+	{0x14e4, 0x1645, 0x14e4, 8, 0, 0, BCM5701A10 },
+	{0x14e4, 0x1645, 0x14e4, 0x8008, 0, 0, BCM5701A12 },
+	{0x14e4, 0x1645, 0x0e11, 0xc1, 0, 0, NC6770 },
+	{0x14e4, 0x1645, 0x0e11, 0x7c, 0, 0, NC7770 },
+	{0x14e4, 0x1645, 0x0e11, 0x85, 0, 0, NC7780 },
+	{0x14e4, 0x1645, 0x1028, 0x0121, 0, 0, BCM5701 },
+	{0x14e4, 0x1645, 0x10b7, 0x1004, 0, 0, TC996SX },
+	{0x14e4, 0x1645, 0x10b7, 0x1006, 0, 0, TC996BT },
+	{0x14e4, 0x1645, 0x10b7, 0x1007, 0, 0, TC1000T },
+	{0x14e4, 0x1645, 0x10b7, 0x1008, 0, 0, TC940BR01 },
+	{0x14e4, 0x1645, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5701 },
+	{0x14e4, 0x1646, 0x14e4, 0x8009, 0, 0, BCM5702 },
+	{0x14e4, 0x1646, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5702 },
+	{0x14e4, 0x16a6, 0x14e4, 0x8009, 0, 0, BCM5702 },
+	{0x14e4, 0x16a6, 0x14e4, 0x000c, 0, 0, BCM5702 },
+	{0x14e4, 0x16a6, 0x0e11, 0xbb, 0, 0, NC7760 },
+	{0x14e4, 0x16a6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5702 },
+	{0x14e4, 0x1647, 0x14e4, 0x0009, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, 0x14e4, 0x000a, 0, 0, BCM5703A31 },
+	{0x14e4, 0x1647, 0x14e4, 0x000b, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, 0x14e4, 0x800a, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x14e4, 0x0009, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x14e4, 0x000a, 0, 0, BCM5703A31 },
+	{0x14e4, 0x16a7, 0x14e4, 0x000b, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x14e4, 0x800a, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x0e11, 0xca, 0, 0, NC7771 },
+	{0x14e4, 0x16a7, 0x0e11, 0xcb, 0, 0, NC7781 },
+	{0x14e4, 0x16a7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5703 },
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, bcm5700_pci_tbl);
+
+#ifdef CONFIG_PROC_FS
+extern int bcm5700_proc_create(void);
+extern int bcm5700_proc_create_dev(struct net_device *dev);
+extern int bcm5700_proc_remove_dev(struct net_device *dev);
+#endif
+
+static int __devinit bcm5700_init_board(struct pci_dev *pdev,
+					struct net_device **dev_out,
+					int board_idx)
+{
+	struct net_device *dev;
+	PUM_DEVICE_BLOCK pUmDevice;
+	PLM_DEVICE_BLOCK pDevice;
+	int rc;
+
+	*dev_out = NULL;
+
+	/* dev zeroed in init_etherdev */
+	dev = init_etherdev(NULL, sizeof(*pUmDevice));
+	if (dev == NULL) {
+		printk (KERN_ERR "%s: unable to alloc new ethernet\n",
+			bcm5700_driver);
+		return -ENOMEM;
+	}
+	SET_MODULE_OWNER(dev);
+	pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	/* enable device (incl. PCI PM wakeup), and bus-mastering */
+	rc = pci_enable_device (pdev);
+	if (rc)
+		goto err_out;
+
+	rc = pci_request_regions(pdev, bcm5700_driver);
+	if (rc)
+		goto err_out;
+
+	pci_set_master(pdev);
+
+	if (pci_set_dma_mask(pdev, ~(0UL)) != 0) {
+		printk(KERN_ERR "System does not support DMA\n");
+		pci_release_regions(pdev);
+		goto err_out;
+	}
+
+	pUmDevice->dev = dev;
+	pUmDevice->pdev = pdev;
+	pUmDevice->mem_list_num = 0;
+	pUmDevice->next_module = root_tigon3_dev;
+	pUmDevice->index = board_idx;
+	root_tigon3_dev = dev;
+
+	spin_lock_init(&pUmDevice->global_lock);
+
+	spin_lock_init(&pUmDevice->undi_lock);
+
+
+	pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	if (mtu[board_idx] > 1500) {
+		if (mtu[board_idx] > 9000) {
+			dev->mtu = 9000;
+			printk(KERN_WARNING "%s: Invalid mtu parameter (%d), using 9000\n", dev->name, mtu[board_idx]);
+		}
+		else
+			dev->mtu = mtu[board_idx];
+	}
+	else if (mtu[board_idx] < 1500) {
+		printk(KERN_WARNING "%s: Invalid mtu parameter (%d), using 1500\n", dev->name, mtu[board_idx]);
+	}
+
+	if (LM_GetAdapterInfo(pDevice) != LM_STATUS_SUCCESS) {
+		printk(KERN_ERR "Get Adapter info failed\n");
+		rc = -ENODEV;
+		goto err_out_unmap;
+	}
+
+	pUmDevice->do_global_lock = 0;
+	if (T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5700) {
+		/* The 5700 chip works best without interleaved register */
+		/* accesses on certain machines. */
+		pUmDevice->do_global_lock = 1;
+	}
+	if ((T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5701) &&
+		((pDevice->PciState & T3_PCI_STATE_NOT_PCI_X_BUS) == 0)) {
+
+		pUmDevice->rx_buf_align = 0;
+	}
+	else {
+		pUmDevice->rx_buf_align = 2;
+	}
+/*	dev->base_addr = pci_resource_start(pdev, 0);*/
+	dev->mem_start = pci_resource_start(pdev, 0);
+	dev->mem_end = dev->mem_start + pDevice->MemBaseSize;
+	dev->irq = pDevice->Irq = pdev->irq;
+
+	*dev_out = dev;
+	return 0;
+
+err_out_unmap:
+	pci_release_regions(pdev);
+	bcm5700_freemem(dev);
+
+err_out:
+	unregister_netdev(dev);
+	kfree (dev);
+	return rc;
+}
+
+static int __devinit
+bcm5700_print_ver(void)
+{
+	printk(KERN_INFO "Broadcom Gigabit Ethernet Driver %s ",
+		bcm5700_driver);
+#ifdef NICE_SUPPORT
+	printk("with Broadcom NIC Extension (NICE) ");
+#endif
+	printk("ver. %s %s\n", bcm5700_version, bcm5700_date);
+	return 0;
+}
+
+static int __devinit
+bcm5700_init_one(struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	struct net_device *dev = NULL;
+	PUM_DEVICE_BLOCK pUmDevice;
+	PLM_DEVICE_BLOCK pDevice;
+	int i;
+	static int board_idx = -1;
+	static int printed_version = 0;
+	struct pci_dev *amd_dev;
+
+	board_idx++;
+
+	if (!printed_version) {
+		bcm5700_print_ver();
+#ifdef CONFIG_PROC_FS
+		bcm5700_proc_create();
+#endif
+		printed_version = 1;
+	}
+
+	i = bcm5700_init_board(pdev, &dev, board_idx);
+	if (i < 0) {
+		return i;
+	}
+
+	if (dev == NULL)
+		return -ENOMEM;
+
+	dev->open = bcm5700_open;
+	dev->hard_start_xmit = bcm5700_start_xmit;
+	dev->stop = bcm5700_close;
+	dev->get_stats = bcm5700_get_stats;
+	dev->set_multicast_list = bcm5700_set_rx_mode;
+	dev->do_ioctl = bcm5700_ioctl;
+	dev->set_mac_address = &bcm5700_set_mac_addr;
+#if (LINUX_VERSION_CODE >= 0x20400)
+	dev->tx_timeout = bcm5700_tx_timeout;
+	dev->watchdog_timeo = TX_TIMEOUT;
+#endif
+
+	pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	dev->base_addr = pci_resource_start(pdev, 0);
+	dev->irq = pdev->irq;
+
+	pci_set_drvdata(pdev, dev);
+
+	memcpy(dev->dev_addr, pDevice->NodeAddress, 6);
+	pUmDevice->name = board_info[ent->driver_data].name,
+	printk(KERN_INFO "%s: %s found at mem %lx, IRQ %d, ",
+		dev->name, pUmDevice->name, dev->base_addr,
+		dev->irq);
+	printk("node addr ");
+	for (i = 0; i < 6; i++) {
+		printk("%2.2x", dev->dev_addr[i]);
+	}
+	printk("\n");
+
+	printk(KERN_INFO "%s: ", dev->name);
+	if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5400_PHY_ID)
+		printk("Broadcom BCM5400 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+		printk("Broadcom BCM5401 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5411_PHY_ID)
+		printk("Broadcom BCM5411 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5701_PHY_ID)
+		printk("Broadcom BCM5701 Integrated Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5703_PHY_ID)
+		printk("Broadcom BCM5703 Integrated Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM8002_PHY_ID)
+		printk("Broadcom BCM8002 SerDes ");
+	else if (pDevice->EnableTbi)
+		printk("Agilent HDMP-1636 SerDes ");
+	else
+		printk("Unknown ");
+	printk("transceiver found\n");
+
+	printk(KERN_INFO "%s: ", dev->name);
+#if (LINUX_VERSION_CODE >= 0x20400)
+	if (scatter_gather[board_idx]) {
+		dev->features |= NETIF_F_SG | NETIF_F_HIGHDMA;
+	}
+	if ((pDevice->ChipRevId != T3_CHIP_ID_5700_B0) &&
+		tx_checksum[board_idx]) {
+		dev->features |= NETIF_F_IP_CSUM;
+	}
+
+	printk("Scatter-gather %s, 64-bit DMA %s, Tx Checksum %s, ",
+		(char *) ((dev->features & NETIF_F_SG) ? "ON" : "OFF"),
+		(char *) ((dev->features & NETIF_F_HIGHDMA) ? "ON" : "OFF"),
+		(char *) ((dev->features & NETIF_F_IP_CSUM) ? "ON" : "OFF"));
+#endif
+	if ((pDevice->ChipRevId != T3_CHIP_ID_5700_B0) &&
+		rx_checksum[board_idx])
+		printk("Rx Checksum ON\n");
+	else
+		printk("Rx Checksum OFF\n");
+
+#ifdef CONFIG_PROC_FS
+	bcm5700_proc_create_dev(dev);
+#endif
+#ifdef TASKLET
+	tasklet_init(&pUmDevice->tasklet, bcm5700_tasklet,
+		(unsigned long) pUmDevice);
+#endif
+	if ((amd_dev = pci_find_device(0x1022, 0x700c, NULL))) {
+		u32 val;
+
+		/* Found AMD 762 North bridge */
+		pci_read_config_dword(amd_dev, 0x4c, &val);
+		if ((val & 0x02) == 0) {
+			pci_write_config_dword(amd_dev, 0x4c, val | 0x02);
+			printk(KERN_INFO "%s: Setting AMD762 Northbridge to enable PCI ordering compliance\n", bcm5700_driver);
+		}
+	}
+	return 0;
+
+}
+
+
+static void __devexit
+bcm5700_remove_one (struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata (pdev);
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+
+#ifdef CONFIG_PROC_FS
+	bcm5700_proc_remove_dev(dev); 
+#endif
+	unregister_netdev(dev);
+
+	if (pUmDevice->lm_dev.pMappedMemBase)
+		iounmap(pUmDevice->lm_dev.pMappedMemBase);
+
+	pci_release_regions(pdev);
+
+	kfree(dev);
+
+	pci_set_drvdata(pdev, NULL);
+
+/*	pci_power_off(pdev, -1);*/
+
+}
+
+int __devinit
+bcm5700_probe(struct net_device *dev)
+{
+	int cards_found = 0;
+	struct pci_dev *pdev = NULL;
+	struct pci_device_id *pci_tbl;
+	u16 ssvid, ssid;
+
+	if ( ! pci_present())
+		return -ENODEV;
+
+	pci_tbl = bcm5700_pci_tbl;
+	while ((pdev = pci_find_class(PCI_CLASS_NETWORK_ETHERNET << 8, pdev))) {
+		int idx;
+
+		pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &ssvid);
+		pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &ssid);
+		for (idx = 0; pci_tbl[idx].vendor; idx++) {
+			if ((pci_tbl[idx].vendor == PCI_ANY_ID ||
+				pci_tbl[idx].vendor == pdev->vendor) &&
+				(pci_tbl[idx].device == PCI_ANY_ID ||
+				pci_tbl[idx].device == pdev->device) &&
+				(pci_tbl[idx].subvendor == PCI_ANY_ID ||
+				pci_tbl[idx].subvendor == ssvid) &&
+				(pci_tbl[idx].subdevice == PCI_ANY_ID ||
+				pci_tbl[idx].subdevice == ssid))
+			{
+
+				break;
+			}
+		}
+		if (pci_tbl[idx].vendor == 0)
+			continue;
+
+
+		if (bcm5700_init_one(pdev, &pci_tbl[idx]) == 0)
+			cards_found++;
+	}
+
+	return cards_found ? 0 : -ENODEV;
+}
+
+
+
+STATIC int
+bcm5700_open(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	int index;
+
+	index = pUmDevice->index;
+	if (pDevice->ChipRevId == T3_CHIP_ID_5700_B0) {
+		pDevice->TaskToOffload = LM_TASK_OFFLOAD_NONE; 
+	}
+	else {
+		if (rx_checksum[index]) {
+			pDevice->TaskToOffload |=
+				LM_TASK_OFFLOAD_RX_TCP_CHECKSUM |
+				LM_TASK_OFFLOAD_RX_UDP_CHECKSUM;
+		}
+		if (tx_checksum[index]) {
+			pDevice->TaskToOffload |=
+				LM_TASK_OFFLOAD_TX_TCP_CHECKSUM |
+				LM_TASK_OFFLOAD_TX_UDP_CHECKSUM;
+			pDevice->NoTxPseudoHdrChksum = TRUE;
+		}
+	}
+	/* delay for 4 seconds */
+	pUmDevice->delayed_link_ind = (4 * HZ) / pUmDevice->timer_interval;
+
+	pUmDevice->adaptive_expiry = HZ / pUmDevice->timer_interval;
+
+#if INCLUDE_TBI_SUPPORT
+	if(pDevice->PollTbiLink)
+		pUmDevice->poll_tbi_expiry = HZ / pUmDevice->timer_interval;
+#endif
+
+	/* Sometimes we get spurious ints. after reset when link is down. */
+	/* This field tells the isr to service the int. even if there is */
+	/* no status block update. */
+	if (pDevice->LedMode != LED_MODE_LINK10) {
+		pUmDevice->adapter_just_inited = (3 * HZ) /
+			pUmDevice->timer_interval;
+	}
+	else {
+		pUmDevice->adapter_just_inited = 0;
+	}
+
+	if (request_irq(dev->irq, &bcm5700_interrupt, SA_SHIRQ, dev->name, dev)) {
+		return -EAGAIN;
+	}
+
+	pUmDevice->opened = 1;
+#if TIGON3_DEBUG
+	pUmDevice->tx_zc_count = 0;
+	pUmDevice->tx_chksum_count = 0;
+	pUmDevice->tx_himem_count = 0;
+	pUmDevice->rx_good_chksum_count = 0;
+	pUmDevice->rx_bad_chksum_count = 0;
+#endif
+	if (LM_InitializeAdapter(pDevice) != LM_STATUS_SUCCESS) {
+		free_irq(dev->irq, dev);
+		bcm5700_freemem(dev);
+		return -EAGAIN;
+	}
+
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+
+	if (tigon3_debug > 1)
+		printk(KERN_DEBUG "%s: tigon3_open() irq %d.\n", dev->name, dev->irq);
+
+	QQ_InitQueue(&pUmDevice->rx_out_of_buf_q.Container,
+        MAX_RX_PACKET_DESC_COUNT);
+	netif_start_queue(dev);
+
+#if (LINUX_VERSION_CODE < 0x020300)
+	MOD_INC_USE_COUNT;
+#endif
+
+	init_timer(&pUmDevice->timer);
+	pUmDevice->timer.expires = RUN_AT(pUmDevice->timer_interval);
+	pUmDevice->timer.data = (unsigned long)dev;
+	pUmDevice->timer.function = &bcm5700_timer;
+	add_timer(&pUmDevice->timer);
+
+	LM_EnableInterrupt(pDevice);
+
+	return 0;
+}
+
+STATIC void
+bcm5700_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	long flags;
+	LM_UINT32 value32;
+
+	if (!pUmDevice->opened)
+		return;
+
+#if INCLUDE_TBI_SUPPORT
+	if(pDevice->PollTbiLink && (--pUmDevice->poll_tbi_expiry == 0)) {
+		value32 = REG_RD(pDevice, MacCtrl.Status);
+		if (((pDevice->LinkStatus == LM_STATUS_LINK_ACTIVE) &&
+			((value32 & MAC_STATUS_LINK_STATE_CHANGED) ||
+			!(value32 & MAC_STATUS_PCS_SYNCED)))
+			||
+			((pDevice->LinkStatus != LM_STATUS_LINK_ACTIVE) &&
+			(value32 & MAC_STATUS_PCS_SYNCED)))
+		{
+			LM_SetupPhy(pDevice);
+		}
+		pUmDevice->poll_tbi_expiry = HZ / pUmDevice->timer_interval;
+		
+        }
+#endif
+
+	if (pUmDevice->delayed_link_ind > 0) {
+		if (pUmDevice->delayed_link_ind == 1)
+			MM_IndicateStatus(pDevice, pDevice->LinkStatus);
+		else
+			pUmDevice->delayed_link_ind--;
+	}
+	if (pUmDevice->adapter_just_inited > 0) {
+		pUmDevice->adapter_just_inited--;
+		if (pDevice->EnableTbi && !pUmDevice->adapter_just_inited &&
+			!pUmDevice->interrupt) {
+			LM_EnableInterrupt(pDevice);
+		}
+	}
+
+	if (pUmDevice->crc_counter_expiry > 0)
+		pUmDevice->crc_counter_expiry--;
+
+	if (!pUmDevice->interrupt) {
+		if (!pDevice->UseTaggedStatus) {
+			flags = bcm5700_lock(pUmDevice);
+			if (pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) {
+				/* This will generate an interrupt */
+				REG_WR(pDevice, Grc.LocalCtrl,
+					pDevice->GrcLocalCtrl |
+					GRC_MISC_LOCAL_CTRL_SET_INT);
+			}
+			else {
+				REG_WR(pDevice, HostCoalesce.Mode,
+					HOST_COALESCE_ENABLE |
+					HOST_COALESCE_NOW);
+			}
+			if (!(REG_RD(pDevice, DmaWrite.Mode) &
+				DMA_WRITE_MODE_ENABLE)) {
+				bcm5700_tx_timeout(dev);
+			}
+			bcm5700_unlock(pUmDevice, flags);
+			if (pUmDevice->tx_queued) {
+				pUmDevice->tx_queued = 0;
+				netif_wake_queue(dev);
+			}
+		}
+#if (LINUX_VERSION_CODE < 0x02032b)
+		if ((QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) !=
+			pDevice->TxPacketDescCnt) &&
+			((jiffies - dev->trans_start) > TX_TIMEOUT)) {
+
+			printk(KERN_WARNING "%s: Tx hung\n", dev->name);
+			bcm5700_tx_timeout(dev);
+		}
+#endif
+	}
+	if (pUmDevice->adaptive_coalesce) {
+		pUmDevice->adaptive_expiry--;
+		if (pUmDevice->adaptive_expiry == 0) {	
+			pUmDevice->adaptive_expiry = HZ /
+				pUmDevice->timer_interval;
+			bcm5700_adapt_coalesce(pUmDevice);
+		}
+	}
+	if (QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container) >=
+		pUmDevice->rx_buf_repl_panic_thresh) {
+		/* Generate interrupt and let isr allocate buffers */
+		REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+			GRC_MISC_LOCAL_CTRL_SET_INT);
+	}
+
+	pUmDevice->timer.expires = RUN_AT(pUmDevice->timer_interval);
+	add_timer(&pUmDevice->timer);
+	pUmDevice->spurious_int = 0;
+}
+
+STATIC int
+bcm5700_adapt_coalesce(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	uint rx_curr_cnt, tx_curr_cnt, rx_delta, tx_delta, total_delta;
+	int adapt = 0;
+	long flags;
+
+	rx_curr_cnt = pDevice->pStatsBlkVirt->ifHCInUcastPkts.Low;
+	tx_curr_cnt = pDevice->pStatsBlkVirt->COSIfHCOutPkts[0].Low;
+	if ((rx_curr_cnt <= pUmDevice->rx_last_cnt) ||
+		(tx_curr_cnt <= pUmDevice->tx_last_cnt)) {
+
+		/* skip if there is counter rollover */
+		pUmDevice->rx_last_cnt = rx_curr_cnt;
+		pUmDevice->tx_last_cnt = tx_curr_cnt;
+		return 0;
+	}
+
+	rx_delta = rx_curr_cnt - pUmDevice->rx_last_cnt;
+	tx_delta = tx_curr_cnt - pUmDevice->tx_last_cnt;
+	total_delta = rx_delta + tx_delta;
+
+	pUmDevice->rx_last_cnt = rx_curr_cnt;
+	pUmDevice->tx_last_cnt = tx_curr_cnt;
+
+	if (total_delta < rx_delta)
+		return 0;
+
+	if (total_delta < ADAPTIVE_LO_PKT_THRESH) {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+
+			adapt = 1;
+
+			pUmDevice->rx_curr_coalesce_frames =
+				ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				ADAPTIVE_LO_RX_COALESCING_TICKS;
+			pUmDevice->tx_curr_coalesce_frames =
+				ADAPTIVE_LO_TX_MAX_COALESCED_FRAMES;
+
+		}
+	}
+	else if (total_delta < ADAPTIVE_HI_PKT_THRESH) {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			DEFAULT_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+
+			adapt = 1;
+
+			pUmDevice->rx_curr_coalesce_frames = 
+				DEFAULT_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				DEFAULT_RX_COALESCING_TICKS;
+			pUmDevice->tx_curr_coalesce_frames = 
+				DEFAULT_TX_MAX_COALESCED_FRAMES;
+
+		}
+	}
+	else {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+
+			adapt = 1;
+
+			pUmDevice->rx_curr_coalesce_frames = 
+				ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				ADAPTIVE_HI_RX_COALESCING_TICKS;
+			pUmDevice->tx_curr_coalesce_frames = 
+				ADAPTIVE_HI_TX_MAX_COALESCED_FRAMES;
+
+		}
+	}
+	if (adapt) {
+    		REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+			pUmDevice->rx_curr_coalesce_frames); 
+
+		REG_WR(pDevice, HostCoalesce.RxCoalescingTicks,
+			pUmDevice->rx_curr_coalesce_ticks);
+
+		REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFrames,
+			pUmDevice->tx_curr_coalesce_frames); 
+		bcm5700_unlock(pUmDevice, flags);
+	}
+	return 0;
+}
+
+STATIC void
+bcm5700_tx_timeout(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	netif_stop_queue(dev);
+	LM_DisableInterrupt(pDevice);
+	LM_ResetAdapter(pDevice);	
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+	LM_EnableInterrupt(pDevice);
+	netif_wake_queue(dev);
+}
+
+
+STATIC int
+bcm5700_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	PLM_FRAG_LIST pfrag_list;
+	long flags;
+	unsigned int len;
+	dma_addr_t map;
+#if MAX_SKB_FRAGS
+	skb_frag_t *frag;
+	int i;
+	int frag_no;
+	dmaaddr_high_t hi_map;
+#endif
+#ifdef NICE_SUPPORT
+	vlan_tag_t *vlan_tag;
+#endif
+
+	if ((pDevice->LinkStatus == LM_STATUS_LINK_DOWN) || !pDevice->InitDone)
+	{
+		dev_kfree_skb(skb);
+		return 0;
+	}
+	
+#if (LINUX_VERSION_CODE < 0x02032b)
+	if (test_and_set_bit(0, &dev->tbusy)) {
+		return 1;
+	}
+#endif
+
+	if (pUmDevice->do_global_lock && pUmDevice->interrupt) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_queued = 1;
+		if (!pUmDevice->interrupt) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_queued = 0;
+		}
+		return 1;
+	}
+
+	pPacket = (PLM_PACKET)
+		QQ_PopHead(&pDevice->TxPacketFreeQ.Container);
+	if (pPacket == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+	pUmPacket = (PUM_PACKET) pPacket;
+	pUmPacket->skbuff = skb;
+	pfrag_list = &pUmPacket->frag_list;
+	pPacket->u.Tx.pFraglist = pfrag_list;
+	if (skb->ip_summed == CHECKSUM_HW) {
+		pPacket->Flags = SND_BD_FLAG_TCP_UDP_CKSUM;
+#if TIGON3_DEBUG
+		pUmDevice->tx_chksum_count++;
+#endif
+	}
+	else {
+		pPacket->Flags = 0;
+	}
+#if MAX_SKB_FRAGS
+	if ((frag_no = skb_shinfo(skb)->nr_frags))
+		len = skb->len - skb->data_len;
+	else
+		len = skb->len;
+	if (atomic_read(&pDevice->SendBdLeft) < (frag_no + 1)) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+		if (atomic_read(&pDevice->SendBdLeft) >= (frag_no + 1)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+#else
+	len = skb->len;
+	if (atomic_read(&pDevice->SendBdLeft) == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+		if (atomic_read(&pDevice->SendBdLeft)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+#endif
+
+	pfrag_list->Fragments[0].FragSize = len;
+	map = pci_map_single(pUmDevice->pdev, skb->data, len, PCI_DMA_TODEVICE);
+	bcm_set_addr(&pfrag_list->Fragments[0].FragBuf, map);
+	pci_unmap_addr_set(pUmPacket, map[0], map);
+	pci_unmap_len_set(pUmPacket, map_len[0], len);
+
+#if MAX_SKB_FRAGS
+	pPacket->u.Tx.FragCount = frag_no + 1;
+#if TIGON3_DEBUG
+	if (pPacket->u.Tx.FragCount > 1)
+		pUmDevice->tx_zc_count++;
+#endif
+	for (i = 1; i < pPacket->u.Tx.FragCount; i++) {
+		frag = &skb_shinfo(skb)->frags[i - 1];
+			
+		hi_map = pci_map_page(pUmDevice->pdev,
+				frag->page,
+				frag->page_offset,
+				frag->size, PCI_DMA_TODEVICE);
+
+		pci_unmap_addr_set(pUmPacket, map[i], hi_map);
+		pci_unmap_len_set(pUmPacket, map_len[i], frag->size);
+		bcm_set_addr_high(&pfrag_list->Fragments[i].FragBuf, hi_map);
+#if TIGON3_DEBUG
+		if (pfrag_list->Fragments[i].FragBuf.High)
+			pUmDevice->tx_himem_count++;
+#endif
+		pfrag_list->Fragments[i].FragSize = frag->size;
+	}
+#else
+	pPacket->u.Tx.FragCount = 1;
+#endif
+
+	/* Work around 4GB dma problem */
+	if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700) {
+		if (check_4G_boundary(pUmDevice, pUmPacket) == 0) {
+			QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+#if (LINUX_VERSION_CODE < 0x02032b)
+			netif_wake_queue(dev);
+#endif
+			return 0;
+		}
+		skb = pUmPacket->skbuff;
+	}
+
+#ifdef NICE_SUPPORT
+	vlan_tag = (vlan_tag_t *) &skb->cb[0];
+	if (vlan_tag->signature == 0x5555) {
+		pPacket->VlanTag = vlan_tag->tag;
+		pPacket->Flags |= SND_BD_FLAG_VLAN_TAG;
+		vlan_tag->signature = 0;
+	}
+#endif
+	flags = bcm5700_lock(pUmDevice);
+	LM_SendPacket(pDevice, pPacket);
+	bcm5700_unlock(pUmDevice, flags);
+	if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) != 0) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+	}
+#if (LINUX_VERSION_CODE < 0x02032b)
+	else {
+		netif_wake_queue(dev);
+	}
+#endif
+	dev->trans_start = jiffies;
+	return 0;
+}
+
+STATIC
+int
+check_4G_boundary(PUM_DEVICE_BLOCK pUmDevice, PUM_PACKET pUmPacket)
+{
+	u32 base;
+	int i;
+	PLM_FRAG_LIST pfrag_list = &pUmPacket->frag_list;
+	PLM_FRAG pfrag;
+	struct sk_buff *skb, *nskb;
+	dma_addr_t map;
+	int do_copy = 0;
+
+	/* Work around 4GB dma problem */
+	for (i = 0; i < pUmPacket->lm_packet.u.Tx.FragCount; i++) {
+		pfrag = &pfrag_list->Fragments[i];
+
+		if (((base = pfrag->FragBuf.Low) > 0xffffdcc0) &&
+			(pfrag->FragBuf.High == 0) &&
+			((base + 8 + pfrag->FragSize) < base)) {
+
+			do_copy = 1;
+			break;
+		}
+	}
+	if (do_copy) {
+		skb = pUmPacket->skbuff;
+#if ! defined(NO_PCI_UNMAP)
+		pci_unmap_single(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[0]),
+				pci_unmap_len(pUmPacket, map_len[0]),
+				PCI_DMA_TODEVICE);
+#if MAX_SKB_FRAGS
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			pci_unmap_page(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[i + 1]),
+				pci_unmap_len(pUmPacket, map_len[i + 1]),
+				PCI_DMA_TODEVICE);
+		}
+#endif
+#endif
+		if ((nskb = skb_copy(skb, GFP_ATOMIC))) {
+			pfrag_list->Fragments[0].FragSize = nskb->len;
+			map = pci_map_single(pUmDevice->pdev, nskb->data,
+				nskb->len, PCI_DMA_TODEVICE);
+			bcm_set_addr(&pfrag_list->Fragments[0].FragBuf, map);
+			pci_unmap_addr_set(pUmPacket, map[0], map);
+			pci_unmap_len_set(pUmPacket, map_len[0], nskb->len);
+			pUmPacket->lm_packet.u.Tx.FragCount = 1;
+		}
+		dev_kfree_skb(skb);
+		pUmPacket->skbuff = nskb;
+		if (nskb == 0) {
+			return 0;
+		}
+	}
+	return 1;
+}
+
+STATIC void
+bcm5700_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *)dev_instance;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	LM_UINT32 oldtag, newtag;
+	int repl_buf_count, i;
+
+	if (!pDevice->InitDone)
+		return;
+
+	bcm5700_intr_lock(pUmDevice);
+	if (test_and_set_bit(0, (void*)&pUmDevice->interrupt)) {
+		printk(KERN_ERR "%s: Duplicate entry of the interrupt handler by "
+			   "processor %d.\n",
+			   dev->name, hard_smp_processor_id());
+		bcm5700_intr_unlock(pUmDevice);
+		return;
+	}
+
+	if (pDevice->UseTaggedStatus) {
+		if ((pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) ||
+			pUmDevice->adapter_just_inited) {
+			RAW_REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+			oldtag = pDevice->pStatusBlkVirt->StatusTag;
+
+			for (i = 0; ; i++) {
+   				pDevice->pStatusBlkVirt->Status &=
+					~STATUS_BLOCK_UPDATED;
+
+				LM_ServiceInterrupts(pDevice);
+				newtag = pDevice->pStatusBlkVirt->StatusTag;
+				if ((newtag == oldtag) || (i > 50)) {
+					RAW_REG_WR(pDevice,
+						Mailbox.Interrupt[0].Low,
+						newtag << 24);
+					break;
+				}
+				oldtag = newtag;
+			}
+		}
+	}
+	else if ((pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) ||
+			pUmDevice->adapter_just_inited) {
+		do {
+			uint dummy;
+
+			RAW_REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+   			pDevice->pStatusBlkVirt->Status &= ~STATUS_BLOCK_UPDATED;
+			LM_ServiceInterrupts(pDevice);
+			RAW_REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+			dummy = REG_RD(pDevice, Mailbox.Interrupt[0].Low);
+		}
+		while (pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED);
+	}
+	if (pUmDevice->adapter_just_inited && pDevice->EnableTbi) {
+		if (pDevice->LinkStatus != LM_STATUS_LINK_ACTIVE) {
+			pUmDevice->spurious_int++;
+			if (pUmDevice->spurious_int > 25) {
+				LM_DisableInterrupt(pDevice);
+    				REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+					MAC_MODE_LINK_POLARITY);
+				MM_Wait(1);
+				pUmDevice->spurious_int = 0;
+    				REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+				if (pUmDevice->adapter_just_inited == 0)
+					LM_EnableInterrupt(pDevice);
+			}
+		}
+	}
+#ifdef TASKLET
+	repl_buf_count = QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container);
+	if (repl_buf_count >= pUmDevice->rx_buf_repl_thresh) {
+		if ((repl_buf_count >= pUmDevice->rx_buf_repl_panic_thresh) &&
+			(!test_and_set_bit(0, &pUmDevice->tasklet_busy))) {
+			replenish_rx_buffers(pUmDevice);
+			clear_bit(0, (void*)&pUmDevice->tasklet_busy);
+		}
+		else if (!pUmDevice->tasklet_pending) {
+			pUmDevice->tasklet_pending = 1;
+			tasklet_schedule(&pUmDevice->tasklet);
+		}
+	}
+#else
+	if (QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container)) {
+		replenish_rx_buffers(pUmDevice);
+	}
+
+	if (QQ_GetEntryCnt(&pDevice->RxPacketFreeQ.Container)) {
+		LM_QueueRxPackets(pDevice);
+	}
+#endif
+
+	clear_bit(0, (void*)&pUmDevice->interrupt);
+	bcm5700_intr_unlock(pUmDevice);
+	if (pUmDevice->tx_queued) {
+		pUmDevice->tx_queued = 0;
+		netif_wake_queue(dev);
+	}
+	return;
+}
+
+
+STATIC void
+bcm5700_tasklet(unsigned long data)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)data;
+
+	/* RH 7.2 Beta 3 tasklets are reentrant */
+	if (test_and_set_bit(0, &pUmDevice->tasklet_busy)) {
+		pUmDevice->tasklet_pending = 0;
+		return;
+	}
+
+	pUmDevice->tasklet_pending = 0;
+	replenish_rx_buffers(pUmDevice);
+	clear_bit(0, &pUmDevice->tasklet_busy);
+}
+
+STATIC int
+bcm5700_close(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+	dev->start = 0;
+#endif
+	netif_stop_queue(dev);
+	pUmDevice->opened = 0;
+
+	if (tigon3_debug > 1)
+		printk(KERN_DEBUG "%s: Shutting down Tigon3\n",
+			   dev->name);
+
+	LM_DisableInterrupt(pDevice);
+#ifdef TASKLET
+//	tasklet_disable(&pUmDevice->tasklet);
+	tasklet_kill(&pUmDevice->tasklet);
+#endif
+	LM_Halt(pDevice);
+	pDevice->InitDone = 0;
+	del_timer(&pUmDevice->timer);
+
+	free_irq(dev->irq, dev);
+#if (LINUX_VERSION_CODE < 0x020300)
+	MOD_DEC_USE_COUNT;
+#endif
+	LM_SetPowerState(pDevice, LM_POWER_STATE_D3);
+	bcm5700_freemem(dev);
+
+	return 0;
+}
+
+STATIC int
+bcm5700_freemem(struct net_device *dev)
+{
+	int i;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+
+	for (i = 0; i < pUmDevice->mem_list_num; i++) {
+		if (pUmDevice->mem_size_list[i] == 0) {
+			kfree(pUmDevice->mem_list[i]);
+		}
+		else {
+			pci_free_consistent(pUmDevice->pdev,
+				(size_t) pUmDevice->mem_size_list[i],
+				pUmDevice->mem_list[i],
+				pUmDevice->dma_list[i]);
+		}
+	}
+	pUmDevice->mem_list_num = 0;
+	return 0;
+}
+
+LM_UINT32
+bcm5700_crc_count(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	LM_UINT32 Value32;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	unsigned long flags;
+
+#if INCLUDE_TBI_SUPPORT
+	if(pDevice->EnableTbi)
+		return (pStats->dot3StatsFCSErrors.Low);
+#endif
+	if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+		T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701) {
+
+		if (!pUmDevice->opened || pUmDevice->adapter_just_inited)
+			return 0;
+
+		/* regulate MDIO access during run time */
+		if (pUmDevice->crc_counter_expiry > 0)
+			return pDevice->PhyCrcCount;
+
+		pUmDevice->crc_counter_expiry = (5 * HZ) /
+			pUmDevice->timer_interval;
+
+		flags = bcm5700_lock(pUmDevice);
+		LM_ReadPhy(pDevice, 0x1e, &Value32);
+		if ((Value32 & 0x8000) == 0)
+			LM_WritePhy(pDevice, 0x1e, Value32 | 0x8000);
+		LM_ReadPhy(pDevice, 0x14, &Value32);
+		bcm5700_unlock(pUmDevice, flags);
+		/* Sometimes data on the MDIO bus can be corrupted */
+		if (Value32 != 0xffff)
+			pDevice->PhyCrcCount += Value32;
+		return pDevice->PhyCrcCount;
+	}
+	else if (pStats == 0) {
+		return 0;
+	}
+	else {
+		return (pStats->dot3StatsFCSErrors.Low);
+	}
+}
+
+STATIC struct net_device_stats *
+bcm5700_get_stats(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	struct net_device_stats *p_netstats = &pUmDevice->stats;
+
+	if (pStats == 0)
+		return p_netstats;
+
+	/* Get stats from LM */
+	p_netstats->rx_packets = pStats->ifHCInUcastPkts.Low +
+			pStats->ifHCInMulticastPkts.Low +
+			pStats->ifHCInBroadcastPkts.Low;
+	p_netstats->tx_packets = pStats->COSIfHCOutPkts[0].Low;
+	p_netstats->rx_bytes = pStats->ifHCInOctets.Low;
+	p_netstats->tx_bytes = pStats->ifHCOutOctets.Low;
+	p_netstats->tx_errors = pStats->dot3StatsInternalMacTransmitErrors.Low +
+			pStats->dot3StatsCarrierSenseErrors.Low +
+			pStats->ifOutDiscards.Low +
+			pStats->ifOutErrors.Low;
+	p_netstats->multicast = pStats->ifHCInMulticastPkts.Low;
+	p_netstats->collisions = pStats->etherStatsCollisions.Low;
+	p_netstats->rx_length_errors = pStats->dot3StatsFramesTooLong.Low +
+			pStats->etherStatsUndersizePkts.Low;
+	p_netstats->rx_over_errors = pStats->nicNoMoreRxBDs.Low;
+	p_netstats->rx_frame_errors = pStats->dot3StatsAlignmentErrors.Low;
+	p_netstats->rx_crc_errors = bcm5700_crc_count(pUmDevice);
+	p_netstats->rx_errors = p_netstats->rx_length_errors +
+				p_netstats->rx_over_errors +
+				p_netstats->rx_frame_errors +
+				p_netstats->rx_crc_errors +
+				pStats->etherStatsFragments.Low +
+				pStats->etherStatsJabbers.Low;
+	
+	p_netstats->tx_aborted_errors = pStats->ifOutDiscards.Low;
+	p_netstats->tx_carrier_errors = pStats->dot3StatsCarrierSenseErrors.Low;
+
+	return p_netstats;
+}
+
+#ifdef SIOCETHTOOL
+static int netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_cmd ethcmd;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+		
+	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
+		return -EFAULT;
+
+        switch (ethcmd.cmd) {
+#ifdef ETHTOOL_GDRVINFO
+        case ETHTOOL_GDRVINFO: {
+		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
+
+		strcpy(info.driver,  bcm5700_driver);
+#if INCLUDE_5701_AX_FIX
+		if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0) {
+			extern int t3FwReleaseMajor;
+			extern int t3FwReleaseMinor;
+			extern int t3FwReleaseFix;
+
+			sprintf(info.fw_version, "%i.%i.%i",
+				t3FwReleaseMajor, t3FwReleaseMinor, 
+				t3FwReleaseFix);
+		}
+#endif
+		strcpy(info.version, bcm5700_version);
+		strcpy(info.bus_info, pUmDevice->pdev->slot_name);
+		if (copy_to_user(useraddr, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+#endif
+        case ETHTOOL_GSET: {
+		if (pDevice->EnableTbi) {
+			ethcmd.supported =
+				(SUPPORTED_1000baseT_Full |
+				SUPPORTED_Autoneg);
+			ethcmd.supported |= SUPPORTED_FIBRE;
+			ethcmd.port = PORT_FIBRE;
+		}
+		else {
+			ethcmd.supported =
+				(SUPPORTED_10baseT_Half |
+				SUPPORTED_10baseT_Full |
+				SUPPORTED_100baseT_Half |
+				SUPPORTED_100baseT_Full |
+				SUPPORTED_1000baseT_Half |
+				SUPPORTED_1000baseT_Full |
+				SUPPORTED_Autoneg);
+			ethcmd.supported |= SUPPORTED_TP;
+			ethcmd.port = PORT_TP;
+		}
+
+		ethcmd.transceiver = XCVR_INTERNAL;
+		ethcmd.phy_address = 0;
+
+		if (pUmDevice->line_speed == 1000)
+			ethcmd.speed = SPEED_1000;
+		else if (pUmDevice->line_speed == 100)
+			ethcmd.speed = SPEED_100;
+		else if (pUmDevice->line_speed == 10)
+			ethcmd.speed = SPEED_10;
+		else
+			ethcmd.speed = 0;
+
+		if (pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+			ethcmd.duplex = DUPLEX_FULL;
+		else
+			ethcmd.duplex = DUPLEX_HALF;
+
+		if (pDevice->DisableAutoNeg == FALSE) {
+			ethcmd.autoneg = AUTONEG_ENABLE;
+			ethcmd.advertising = ADVERTISED_Autoneg;
+			if (pDevice->EnableTbi) {
+				ethcmd.advertising |=
+					ADVERTISED_1000baseT_Full |
+					ADVERTISED_FIBRE;
+			}
+			else {
+				ethcmd.advertising |=
+					ADVERTISED_TP;
+				if (pDevice->advertising &
+					PHY_AN_AD_10BASET_HALF) {
+
+					ethcmd.advertising |=
+						ADVERTISED_10baseT_Half;
+				}
+				if (pDevice->advertising &
+					PHY_AN_AD_10BASET_FULL) {
+
+					ethcmd.advertising |=
+						ADVERTISED_10baseT_Full;
+				}
+				if (pDevice->advertising &
+					PHY_AN_AD_100BASETX_HALF) {
+
+					ethcmd.advertising |=
+						ADVERTISED_100baseT_Half;
+				}
+				if (pDevice->advertising &
+					PHY_AN_AD_100BASETX_FULL) {
+
+					ethcmd.advertising |=
+						ADVERTISED_100baseT_Full;
+				}
+				if (pDevice->advertising1000 &
+					BCM540X_AN_AD_1000BASET_HALF) {
+
+					ethcmd.advertising |=
+						ADVERTISED_1000baseT_Half;
+				}
+				if (pDevice->advertising1000 &
+					BCM540X_AN_AD_1000BASET_FULL) {
+
+					ethcmd.advertising |=
+						ADVERTISED_1000baseT_Full;
+				}
+			}
+		}
+		else {
+			ethcmd.autoneg = AUTONEG_DISABLE;
+			ethcmd.advertising = 0;
+		}
+
+		ethcmd.maxtxpkt = pDevice->TxMaxCoalescedFrames;
+		ethcmd.maxrxpkt = pDevice->RxMaxCoalescedFrames;
+
+		if(copy_to_user(useraddr, &ethcmd, sizeof(ethcmd)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SSET: {
+		if(!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if (ethcmd.autoneg == AUTONEG_ENABLE) {
+			if (pDevice->EnableTbi) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_AUTO;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_AUTO;
+			}
+			pDevice->DisableAutoNeg = FALSE;
+		}
+		else if (ethcmd.speed == SPEED_1000) {
+			if (!pDevice->EnableTbi)
+				return -EINVAL;
+			pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX;
+			pDevice->DisableAutoNeg = TRUE;
+		}
+		else if (ethcmd.speed == SPEED_100) {
+			if (ethcmd.duplex == DUPLEX_FULL) {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS;
+			}
+			pDevice->DisableAutoNeg = TRUE;
+		}
+		else if (ethcmd.speed == SPEED_10) {
+			if (ethcmd.duplex == DUPLEX_FULL) {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+			}
+			pDevice->DisableAutoNeg = TRUE;
+		}
+		else {
+			return -EINVAL;
+		}
+		LM_SetupPhy(pDevice);
+		return 0;
+	}
+#ifdef ETHTOOL_GWOL
+	case ETHTOOL_GWOL: {
+		struct ethtool_wolinfo wol = {ETHTOOL_GWOL};
+
+		if (pDevice->EnableTbi) {
+			wol.supported = 0;
+			wol.wolopts = 0;
+		}
+		else {
+			wol.supported = WAKE_MAGIC;
+			if (pDevice->WakeUpMode == LM_WAKE_UP_MODE_MAGIC_PACKET)
+			{
+				wol.wolopts = WAKE_MAGIC;
+			}
+			else {
+				wol.wolopts = 0;
+			}
+		}
+		if (copy_to_user(useraddr, &wol, sizeof(wol)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SWOL: {
+		struct ethtool_wolinfo wol;
+
+		if(!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if (copy_from_user(&wol, useraddr, sizeof(wol)))
+			return -EFAULT;
+		if (pDevice->EnableTbi && wol.wolopts)
+			return -EINVAL;
+		
+		if ((wol.wolopts & ~WAKE_MAGIC) != 0) {
+			return -EINVAL;
+		}
+		if (wol.wolopts & WAKE_MAGIC) {
+			pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_MAGIC_PACKET;
+			pDevice->WakeUpMode = LM_WAKE_UP_MODE_MAGIC_PACKET;
+		}
+		else {
+			pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_NONE;
+			pDevice->WakeUpMode = LM_WAKE_UP_MODE_NONE;
+		}
+		return 0;
+        }
+#endif
+#ifdef ETHTOOL_GLINK
+	case ETHTOOL_GLINK: {
+		struct ethtool_value edata = {ETHTOOL_GLINK};
+
+		if (pDevice->LinkStatus == LM_STATUS_LINK_ACTIVE)
+			edata.data =  1;
+		else
+			edata.data =  0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+#endif
+#ifdef ETHTOOL_NWAY_RST
+	case ETHTOOL_NWAY_RST: {
+		LM_UINT32 phyctrl;
+
+		if (pDevice->DisableAutoNeg) {
+			return -EINVAL;
+		}
+		if (pDevice->EnableTbi) {
+			LM_SetupPhy(pDevice);
+		}
+		else {
+			LM_ReadPhy(pDevice, PHY_CTRL_REG, &phyctrl);
+			LM_WritePhy(pDevice, PHY_CTRL_REG, phyctrl |
+				PHY_CTRL_AUTO_NEG_ENABLE |
+				PHY_CTRL_RESTART_AUTO_NEG);
+		}
+		return 0;
+	}
+#endif
+	}
+	
+	return -EOPNOTSUPP;
+}
+#endif
+
+/* Provide ioctl() calls to examine the MII xcvr state. */
+STATIC int bcm5700_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	u16 *data = (u16 *)&rq->ifr_data;
+	u32 value;
+	unsigned long flags;
+
+	switch(cmd) {
+	case SIOCDEVPRIVATE:		/* Get the address of the PHY in use. */
+		data[0] = pDevice->PhyAddr;
+	case SIOCDEVPRIVATE+1:		/* Read the specified MII register. */
+		flags = bcm5700_lock(pUmDevice);
+		LM_ReadPhy(pDevice, data[1] & 0x1f, (LM_UINT32 *) &value);
+		bcm5700_unlock(pUmDevice, flags);
+		data[3] = value & 0xffff;
+		return 0;
+	case SIOCDEVPRIVATE+2:		/* Write the specified MII register */
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		flags = bcm5700_lock(pUmDevice);
+		LM_WritePhy(pDevice, data[1] & 0x1f, data[2]);
+		bcm5700_unlock(pUmDevice, flags);
+		return 0;
+#ifdef NICE_SUPPORT
+	case SIOCNICE:
+		{
+			struct nice_req* nrq;
+
+			if (!capable(CAP_NET_ADMIN))
+				return -EPERM;
+
+			nrq = (struct nice_req*)&rq->ifr_ifru;
+			if( nrq->cmd == NICE_CMD_QUERY_SUPPORT ) {
+				nrq->nrq_magic = NICE_DEVICE_MAGIC;
+				nrq->nrq_support_rx = 1;
+				nrq->nrq_support_vlan = 1;
+				nrq->nrq_support_get_speed = 1;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_SET_RX ) {
+				pUmDevice->nice_rx = nrq->nrq_rx;
+				pUmDevice->nice_ctx = nrq->nrq_ctx;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_GET_RX ) {
+				nrq->nrq_rx = pUmDevice->nice_rx;
+				nrq->nrq_ctx = pUmDevice->nice_ctx;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_GET_SPEED ) {
+				nrq->nrq_speed = pUmDevice->line_speed;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_BLINK_LED ) {
+				return LM_BlinkLED(pDevice, nrq->nrq_blink_time);
+			}
+			break;
+		}
+#endif /* NICE_SUPPORT */
+#ifdef SIOCETHTOOL
+	case SIOCETHTOOL:
+		return netdev_ethtool_ioctl(dev, (void *) rq->ifr_data);
+#endif
+	default:
+		return -EOPNOTSUPP;
+	}
+	return -EOPNOTSUPP;
+}
+
+STATIC void bcm5700_set_rx_mode(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	int i;
+	struct dev_mc_list *mclist;
+
+	LM_MulticastClear(pDevice);
+	for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+			 i++, mclist = mclist->next) {
+		LM_MulticastAdd(pDevice, (PLM_UINT8) &mclist->dmi_addr);
+	}
+	if (dev->flags & IFF_ALLMULTI) {
+		if (!(pDevice->ReceiveMask & LM_ACCEPT_ALL_MULTICAST)) {
+			LM_SetReceiveMask(pDevice,
+				pDevice->ReceiveMask | LM_ACCEPT_ALL_MULTICAST);
+		}
+	}
+	else if (pDevice->ReceiveMask & LM_ACCEPT_ALL_MULTICAST) {
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask & ~LM_ACCEPT_ALL_MULTICAST);
+	}
+	if (dev->flags & IFF_PROMISC) {
+		if (!(pDevice->RxMode & RX_MODE_PROMISCUOUS_MODE)) {
+			LM_SetReceiveMask(pDevice,
+				pDevice->ReceiveMask | LM_PROMISCUOUS_MODE);
+		}
+	}
+	else if (pDevice->RxMode & RX_MODE_PROMISCUOUS_MODE) {
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask & ~LM_PROMISCUOUS_MODE);
+	}
+}
+
+/*
+ * Set the hardware MAC address.
+ */
+STATIC int bcm5700_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr=p;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) dev->priv;
+
+	if (netif_running(dev))
+		return -EBUSY;
+	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
+	LM_SetMacAddress(pDevice, dev->dev_addr);
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE < 0x020300)
+#ifdef MODULE
+int init_module(void)
+{
+	return bcm5700_probe(NULL);
+}
+
+void cleanup_module(void)
+{
+	struct net_device *next_dev;
+	PUM_DEVICE_BLOCK pUmDevice;
+
+	/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
+	while (root_tigon3_dev) {
+		pUmDevice = (PUM_DEVICE_BLOCK)root_tigon3_dev->priv;
+#ifdef CONFIG_PROC_FS
+		bcm5700_proc_remove_dev(root_tigon3_dev); 
+#endif
+		next_dev = pUmDevice->next_module;
+		unregister_netdev(root_tigon3_dev);
+		if (pUmDevice->lm_dev.pMappedMemBase)
+			iounmap(pUmDevice->lm_dev.pMappedMemBase);
+		kfree(root_tigon3_dev);
+		root_tigon3_dev = next_dev;
+	}
+}
+
+#endif  /* MODULE */
+#else	/* LINUX_VERSION_CODE < 0x020300 */
+
+#if (LINUX_VERSION_CODE >= 0x020406)
+static int bcm5700_suspend (struct pci_dev *pdev, u32 state)
+#else
+static void bcm5700_suspend (struct pci_dev *pdev)
+#endif
+{
+	struct net_device *dev = (struct net_device *) pci_get_drvdata(pdev);
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	if (!netif_running(dev))
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#else
+		return;
+#endif
+
+	LM_DisableInterrupt(pDevice);
+	netif_device_detach (dev);
+
+	/* Disable interrupts, stop Tx and Rx. */
+	LM_Halt(pDevice);
+	LM_SetPowerState(pDevice, LM_POWER_STATE_D3);
+
+/*	pci_power_off(pdev, -1);*/
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE >= 0x020406)
+static int bcm5700_resume(struct pci_dev *pdev)
+#else
+static void bcm5700_resume(struct pci_dev *pdev)
+#endif
+{
+	struct net_device *dev = (struct net_device *) pci_get_drvdata(pdev);
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) dev->priv;
+
+	if (!netif_running(dev))
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#else
+		return;
+#endif
+/*	pci_power_on(pdev);*/
+	netif_device_attach(dev);
+	LM_InitializeAdapter(pDevice);
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+	LM_EnableInterrupt(pDevice);
+#if (LINUX_VERSION_CODE >= 0x020406)
+	return 0;
+#endif
+}
+
+
+static struct pci_driver bcm5700_pci_driver = {
+	name:		bcm5700_driver,
+	id_table:	bcm5700_pci_tbl,
+	probe:		bcm5700_init_one,
+	remove:		bcm5700_remove_one,
+	suspend:	bcm5700_suspend,
+	resume:		bcm5700_resume,
+};
+
+
+static int __init bcm5700_init_module (void)
+{
+	return pci_module_init(&bcm5700_pci_driver);
+}
+
+
+static void __exit bcm5700_cleanup_module (void)
+{
+	pci_unregister_driver(&bcm5700_pci_driver);
+}
+
+
+module_init(bcm5700_init_module);
+module_exit(bcm5700_cleanup_module);
+#endif
+
+/*
+ * Middle Module
+ *
+ */
+
+
+LM_STATUS
+MM_ReadConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT16 *pValue16)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_read_config_word(pUmDevice->pdev, Offset, (u16 *) pValue16);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_ReadConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT32 *pValue32)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_read_config_dword(pUmDevice->pdev, Offset, (u32 *) pValue32);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_WriteConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT16 Value16)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_write_config_word(pUmDevice->pdev, Offset, Value16);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_WriteConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT32 Value32)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_write_config_dword(pUmDevice->pdev, Offset, Value32);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_AllocateSharedMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+	PLM_VOID *pMemoryBlockVirt, PLM_PHYSICAL_ADDRESS pMemoryBlockPhy,
+	LM_BOOL Cached)
+{
+	PLM_VOID pvirt;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	dma_addr_t mapping;
+
+	pvirt = pci_alloc_consistent(pUmDevice->pdev, BlockSize,
+					       &mapping);
+	if (!pvirt) {
+		return LM_STATUS_FAILURE;
+	}
+	pUmDevice->mem_list[pUmDevice->mem_list_num] = pvirt;
+	pUmDevice->dma_list[pUmDevice->mem_list_num] = mapping;
+	pUmDevice->mem_size_list[pUmDevice->mem_list_num++] = BlockSize;
+	memset(pvirt, 0, BlockSize);
+	*pMemoryBlockVirt = (PLM_VOID) pvirt;
+	bcm_set_addr(pMemoryBlockPhy, mapping);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_AllocateMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+	PLM_VOID *pMemoryBlockVirt)
+{
+	PLM_VOID pvirt;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+
+
+	/* Maximum in slab.c */
+	if (BlockSize > 131072) {
+		goto MM_Alloc_error;
+	}
+
+	pvirt = kmalloc(BlockSize, GFP_KERNEL);
+	if (!pvirt) {
+		goto MM_Alloc_error;
+	}
+	pUmDevice->mem_list[pUmDevice->mem_list_num] = pvirt;
+	pUmDevice->dma_list[pUmDevice->mem_list_num] = 0;
+	pUmDevice->mem_size_list[pUmDevice->mem_list_num++] = 0;
+	/* mem_size_list[i] == 0 indicates that the memory should be freed */
+	/* using kfree */
+	memset(pvirt, 0, BlockSize);
+	*pMemoryBlockVirt = pvirt;
+	return LM_STATUS_SUCCESS;
+
+MM_Alloc_error:
+	printk(KERN_WARNING "%s: Memory allocation failed - buffer parameters may be set too high\n", pUmDevice->dev->name);
+	return LM_STATUS_FAILURE;
+}
+
+LM_STATUS
+MM_MapMemBase(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+
+	pDevice->pMappedMemBase = ioremap_nocache(
+		pci_resource_start(pUmDevice->pdev, 0), pDevice->MemBaseSize);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_InitializeUmPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	int i;
+	struct sk_buff *skb;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PUM_PACKET pUmPacket;
+	PLM_PACKET pPacket;
+	dma_addr_t map;
+
+	for (i = 0; i < pDevice->RxPacketDescCnt; i++) {
+		pPacket = QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+		pUmPacket = (PUM_PACKET) pPacket;
+		if (pPacket == 0) {
+			printk(KERN_DEBUG "Bad RxPacketFreeQ\n");
+		}
+		skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2);
+		if (skb == 0) {
+			pUmPacket->skbuff = 0;
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+			continue;
+		}
+		pUmPacket->skbuff = skb;
+		skb->dev = pUmDevice->dev;
+		skb_reserve(skb, pUmDevice->rx_buf_align);
+		map = pci_map_single(pUmDevice->pdev, skb->tail,
+			pPacket->u.Rx.RxBufferSize, PCI_DMA_FROMDEVICE);
+		pci_unmap_addr_set(pUmPacket, map[0], map);
+		bcm_set_addr(&pPacket->u.Rx.RxBufferPhy, map);
+		QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+	}
+	if (T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5700) {
+		/* reallocate buffers in the ISR */
+		pUmDevice->rx_buf_repl_thresh = 0;
+		pUmDevice->rx_buf_repl_panic_thresh = 0;
+	}
+	else if (T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5703) {
+		pUmDevice->rx_buf_repl_thresh = pDevice->RxPacketDescCnt / 10;
+		pUmDevice->rx_buf_repl_panic_thresh =
+			pDevice->RxPacketDescCnt / 3;
+	}
+	else {
+		pUmDevice->rx_buf_repl_thresh = pDevice->RxPacketDescCnt / 8;
+		pUmDevice->rx_buf_repl_panic_thresh =
+			pDevice->RxPacketDescCnt / 2;
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_GetConfig(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	int index = pUmDevice->index;
+
+	if (auto_speed[index] == 0)
+		pDevice->DisableAutoNeg = TRUE;
+	else
+		pDevice->DisableAutoNeg = FALSE;
+
+	if (line_speed[index] == 0) {
+		pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_AUTO;
+		pDevice->DisableAutoNeg = FALSE;
+	}
+	else {
+		if (line_speed[index] == 1000) {
+			if (pDevice->EnableTbi) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX;
+			}
+			else if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS;
+			}
+			if (!pDevice->EnableTbi)
+				pDevice->DisableAutoNeg = FALSE;
+		}
+		else if (line_speed[index] == 100) {
+			if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS;
+			}
+		}
+		else if (line_speed[index] == 10) {
+			if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+			}
+		}
+		else {
+			pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_AUTO;
+			pDevice->DisableAutoNeg = FALSE;
+			printk(KERN_WARNING "%s: Invalid line_speed parameter (%d), using 0\n", pUmDevice->dev->name, line_speed[index]);
+		}
+
+	}
+	pDevice->FlowControlCap = 0;
+	if (rx_flow_control[index] != 0) {
+		pDevice->FlowControlCap |= LM_FLOW_CONTROL_RECEIVE_PAUSE;
+	}
+	if (tx_flow_control[index] != 0) {
+		pDevice->FlowControlCap |= LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+	}
+	if (auto_flow_control[index] != 0) {
+		if (pDevice->DisableAutoNeg == FALSE) {
+
+			pDevice->FlowControlCap |= LM_FLOW_CONTROL_AUTO_PAUSE;
+			if ((tx_flow_control[index] == 0) &&
+				(rx_flow_control[index] == 0)) {
+
+				pDevice->FlowControlCap |=
+					LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+					LM_FLOW_CONTROL_RECEIVE_PAUSE;
+			}
+		}
+		else {
+			printk(KERN_WARNING "%s: Conflicting auto_flow_control parameter (%d), using 0\n",
+				pUmDevice->dev->name, auto_flow_control[index]);
+		}
+
+	}
+
+	if (pUmDevice->dev->mtu > 1500) {
+		pDevice->RxMtu = pUmDevice->dev->mtu + 14;
+	}
+
+	if (T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700) {
+		pDevice->UseTaggedStatus = TRUE;
+		pUmDevice->timer_interval = HZ;
+	}
+	else {
+		pUmDevice->timer_interval = HZ/10;
+	}
+
+	if ((tx_pkt_desc_cnt[index] == 0) ||
+		(tx_pkt_desc_cnt[index] > MAX_TX_PACKET_DESC_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid tx_pkt_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, tx_pkt_desc_cnt[index],
+			DEFAULT_TX_PACKET_DESC_COUNT);
+
+		tx_pkt_desc_cnt[index] = DEFAULT_TX_PACKET_DESC_COUNT;
+	}
+	pDevice->TxPacketDescCnt = tx_pkt_desc_cnt[index];
+	if ((rx_std_desc_cnt[index] == 0) ||
+		(rx_std_desc_cnt[index] >= T3_STD_RCV_RCB_ENTRY_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid rx_std_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, rx_std_desc_cnt[index],
+			DEFAULT_RX_PACKET_DESC_COUNT);
+
+		rx_std_desc_cnt[index] = DEFAULT_RX_PACKET_DESC_COUNT;
+	}
+	pDevice->RxStdDescCnt = rx_std_desc_cnt[index];
+
+	if (mtu[index] <= 1514) {
+		rx_jumbo_desc_cnt[index] = 0;
+	}
+	else if ((rx_jumbo_desc_cnt[index] == 0) ||
+		(rx_jumbo_desc_cnt[index] >= T3_JUMBO_RCV_RCB_ENTRY_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid rx_jumbo_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, rx_jumbo_desc_cnt[index],
+			DEFAULT_JUMBO_RCV_DESC_COUNT);
+
+		rx_jumbo_desc_cnt[index] = DEFAULT_JUMBO_RCV_DESC_COUNT;
+	}
+	pDevice->RxJumboDescCnt = rx_jumbo_desc_cnt[index];
+
+#if INCLUDE_EXT_MEMORY_SUPPORT
+	if ((rx_mini_desc_cnt[index] == 0) ||
+		(rx_mini_desc_cnt[index] >= T3_MINI_RCV_RCB_ENTRY_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid rx_mini_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, rx_mini_desc_cnt[index],
+			DEFAULT_MINI_RCV_DESC_COUNT);
+
+		rx_mini_desc_cnt[index] = DEFAULT_MINI_RCV_DESC_COUNT;
+	}
+	pDevice->RxMiniDescCnt = rx_mini_desc_cnt[index];
+#endif
+
+	pUmDevice->adaptive_coalesce = adaptive_coalesce[index];
+	if (!pUmDevice->adaptive_coalesce) {
+		if (rx_coalesce_ticks[index] > MAX_RX_COALESCING_TICKS) {
+
+			printk(KERN_WARNING "%s: Invalid rx_coalesce_ticks parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				rx_coalesce_ticks[index],
+				MAX_RX_COALESCING_TICKS);
+
+			rx_coalesce_ticks[index] = MAX_RX_COALESCING_TICKS;
+		}
+		else if ((rx_coalesce_ticks[index] == 0) &&
+			(rx_max_coalesce_frames[index] == 0)) {
+
+			printk(KERN_WARNING "%s: Conflicting rx_coalesce_ticks (0) and rx_max_coalesce_frames (0) parameters, using %d and %d respectively\n",
+				pUmDevice->dev->name,
+				DEFAULT_RX_COALESCING_TICKS,
+				DEFAULT_RX_MAX_COALESCED_FRAMES);
+
+			rx_coalesce_ticks[index] = DEFAULT_RX_COALESCING_TICKS;
+			rx_max_coalesce_frames[index] =
+				DEFAULT_RX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->RxCoalescingTicks = rx_coalesce_ticks[index];
+		pUmDevice->rx_curr_coalesce_ticks = pDevice->RxCoalescingTicks;
+
+		if (rx_max_coalesce_frames[index] > MAX_RX_MAX_COALESCED_FRAMES)
+		{
+			printk(KERN_WARNING "%s: Invalid rx_max_coalesce_frames parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				rx_max_coalesce_frames[index],
+				MAX_RX_MAX_COALESCED_FRAMES);
+
+			rx_max_coalesce_frames[index] =
+				MAX_RX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->RxMaxCoalescedFrames = rx_max_coalesce_frames[index];
+		pUmDevice->rx_curr_coalesce_frames =
+			pDevice->RxMaxCoalescedFrames;
+
+		if (tx_coalesce_ticks[index] > MAX_TX_COALESCING_TICKS) {
+			printk(KERN_WARNING "%s: Invalid tx_coalesce_ticks parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				tx_coalesce_ticks[index],
+				MAX_TX_COALESCING_TICKS);
+
+			tx_coalesce_ticks[index] = MAX_TX_COALESCING_TICKS;
+		}
+		else if ((tx_coalesce_ticks[index] == 0) &&
+			(tx_max_coalesce_frames[index] == 0)) {
+
+			printk(KERN_WARNING "%s: Conflicting tx_coalesce_ticks (0) and tx_max_coalesce_frames (0) parameters, using %d and %d respectively\n",
+				pUmDevice->dev->name,
+				DEFAULT_TX_COALESCING_TICKS,
+				DEFAULT_TX_MAX_COALESCED_FRAMES);
+
+			tx_coalesce_ticks[index] = DEFAULT_TX_COALESCING_TICKS;
+			tx_max_coalesce_frames[index] =
+				DEFAULT_TX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->TxCoalescingTicks = tx_coalesce_ticks[index];
+		if (tx_max_coalesce_frames[index] > MAX_TX_MAX_COALESCED_FRAMES) {
+			printk(KERN_WARNING "%s: Invalid tx_max_coalesce_frames parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				tx_max_coalesce_frames[index],
+				MAX_TX_MAX_COALESCED_FRAMES);
+
+			tx_max_coalesce_frames[index] = MAX_TX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->TxMaxCoalescedFrames = tx_max_coalesce_frames[index];
+		pUmDevice->tx_curr_coalesce_frames =
+			pDevice->TxMaxCoalescedFrames;
+
+		if (stats_coalesce_ticks[index] > MAX_STATS_COALESCING_TICKS) {
+			printk(KERN_WARNING "%s: Invalid stats_coalesce_ticks parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				stats_coalesce_ticks[index],
+				MAX_STATS_COALESCING_TICKS);
+
+			stats_coalesce_ticks[index] =
+				MAX_STATS_COALESCING_TICKS;
+		}
+		pDevice->StatsCoalescingTicks = stats_coalesce_ticks[index];
+	}
+	else {
+		pUmDevice->rx_curr_coalesce_frames =
+			DEFAULT_RX_MAX_COALESCED_FRAMES;
+		pUmDevice->rx_curr_coalesce_ticks =
+			DEFAULT_RX_COALESCING_TICKS;
+		pUmDevice->tx_curr_coalesce_frames =
+			DEFAULT_TX_MAX_COALESCED_FRAMES;
+	}
+
+	if (enable_wol[index]) {
+		pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_MAGIC_PACKET;
+		pDevice->WakeUpMode = LM_WAKE_UP_MODE_MAGIC_PACKET;
+	}
+	if (pDevice->EnablePciXFix)
+		pDevice->NicSendBd = FALSE;
+	else
+		pDevice->NicSendBd = TRUE;
+#if INCLUDE_TBI_SUPPORT
+	pDevice->PollTbiLink = TRUE;
+#endif
+#if INCLUDE_EXT_MEMORY_SUPPORT
+	pDevice->EnableExtMemory = TRUE;
+#endif
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_StartTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_CompleteTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_IndicateRxPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+	int size;
+
+	while (1) {
+		pPacket = (PLM_PACKET)
+			QQ_PopHead(&pDevice->RxPacketReceivedQ.Container);
+		if (pPacket == 0)
+			break;
+		pUmPacket = (PUM_PACKET) pPacket;
+#if ! defined(NO_PCI_UNMAP)
+		pci_unmap_single(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[0]),
+				pPacket->u.Rx.RxBufferSize,
+				PCI_DMA_FROMDEVICE);
+#endif
+		if ((pPacket->PacketStatus != LM_STATUS_SUCCESS) ||
+			((size = pPacket->PacketSize) > pDevice->RxMtu)) {
+
+			/* reuse skb */
+#ifdef TASKLET
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+#else
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+#endif
+			pUmDevice->rx_misc_errors++;
+			continue;
+		}
+		skb = pUmPacket->skbuff;
+		skb_put(skb, size);
+		skb->pkt_type = 0;
+		skb->protocol = eth_type_trans(skb, skb->dev);
+		if ((pPacket->Flags & RCV_BD_FLAG_TCP_UDP_CHKSUM_FIELD) &&
+			(pDevice->TaskToOffload &
+				LM_TASK_OFFLOAD_RX_TCP_CHECKSUM)) {
+			if (pPacket->u.Rx.TcpUdpChecksum == 0xffff) {
+
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+#if TIGON3_DEBUG
+				pUmDevice->rx_good_chksum_count++;
+#endif
+			}
+			else {
+				skb->ip_summed = CHECKSUM_NONE;
+				pUmDevice->rx_bad_chksum_count++;
+			}
+		}
+		else {
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+#ifdef NICE_SUPPORT
+		if( pUmDevice->nice_rx ) {
+			vlan_tag_t *vlan_tag;
+
+			vlan_tag = (vlan_tag_t *) &skb->cb[0];
+			if (pPacket->Flags & RCV_BD_FLAG_VLAN_TAG) {
+				vlan_tag->signature = 0x7777;
+				vlan_tag->tag = pPacket->VlanTag;
+			}
+			else {
+				vlan_tag->signature = 0;
+			}
+			pUmDevice->nice_rx(skb, pUmDevice->nice_ctx);
+		}
+		else {
+			netif_rx(skb);
+		}
+#else
+		netif_rx(skb);
+#endif
+
+#ifdef TASKLET
+		pUmPacket->skbuff = 0;
+		QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+#else
+		skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2);
+		if (skb == 0) {
+			pUmPacket->skbuff = 0;
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+		}
+		else {
+			pUmPacket->skbuff = skb;
+			skb->dev = pUmDevice->dev;
+			skb_reserve(skb, pUmDevice->rx_buf_align);
+			map = pci_map_single(pUmDevice->pdev, skb->tail,
+				pPacket->u.Rx.RxBufferSize, PCI_DMA_FROMDEVICE);
+			pci_unmap_addr_set(pUmPacket, map[0], map);
+			bcm_set_addr(&pPacket->u.Rx.RxBufferPhy, map);
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+		}
+#endif
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+/* Returns 1 if not all buffers are allocated */
+STATIC int
+replenish_rx_buffers(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	struct sk_buff *skb;
+	int queue_rx = 0;
+	int ret = 0;
+	dma_addr_t map;
+
+	while ((pUmPacket = (PUM_PACKET)
+		QQ_PopHead(&pUmDevice->rx_out_of_buf_q.Container)) != 0) {
+		pPacket = (PLM_PACKET) pUmPacket;
+		if (pUmPacket->skbuff) {
+			/* reuse an old skb */
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+			queue_rx = 1;
+			continue;
+		}
+		if ((skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2)) == 0) {
+			QQ_PushHead(&pUmDevice->rx_out_of_buf_q.Container,
+				pPacket);
+			ret = 1;
+			break;
+		}
+		pUmPacket->skbuff = skb;
+		skb->dev = pUmDevice->dev;
+		skb_reserve(skb, pUmDevice->rx_buf_align);
+		map = pci_map_single(pUmDevice->pdev, skb->tail,
+			pPacket->u.Rx.RxBufferSize, PCI_DMA_FROMDEVICE);
+		pci_unmap_addr_set(pUmPacket, map[0], map);
+		bcm_set_addr(&pPacket->u.Rx.RxBufferPhy, map);
+		QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+		queue_rx = 1;
+	}
+	if (queue_rx) {
+		LM_QueueRxPackets(pDevice);
+	}
+	return ret;
+}
+
+LM_STATUS
+MM_IndicateTxPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+#if ! defined(NO_PCI_UNMAP) && MAX_SKB_FRAGS
+	int i;
+#endif
+
+	while (1) {
+		pPacket = (PLM_PACKET)
+			QQ_PopHead(&pDevice->TxPacketXmittedQ.Container);
+		if (pPacket == 0)
+			break;
+		pUmPacket = (PUM_PACKET) pPacket;
+		skb = pUmPacket->skbuff;
+#if ! defined(NO_PCI_UNMAP)
+		pci_unmap_single(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[0]),
+				pci_unmap_len(pUmPacket, map_len[0]),
+				PCI_DMA_TODEVICE);
+#if MAX_SKB_FRAGS
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			pci_unmap_page(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[i + 1]),
+				pci_unmap_len(pUmPacket, map_len[i + 1]),
+				PCI_DMA_TODEVICE);
+		}
+#endif
+#endif
+		dev_kfree_skb_irq(skb);
+		pUmPacket->skbuff = 0;
+		QQ_PushTail(&pDevice->TxPacketFreeQ.Container, pPacket);
+	}
+	if (pUmDevice->tx_full) {
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) >=
+			(pDevice->TxPacketDescCnt >> 1)) {
+
+			pUmDevice->tx_full = 0;
+			netif_wake_queue(pUmDevice->dev);
+		}
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_IndicateStatus(PLM_DEVICE_BLOCK pDevice, LM_STATUS Status)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	struct net_device *dev = pUmDevice->dev;
+	LM_FLOW_CONTROL flow_control;
+
+	if (!pUmDevice->opened)
+		return LM_STATUS_SUCCESS;
+
+	if (pUmDevice->delayed_link_ind > 0) {
+		pUmDevice->delayed_link_ind = 0;
+		if (Status == LM_STATUS_LINK_DOWN) {
+			printk(KERN_ERR "%s: %s NIC Link is DOWN\n", bcm5700_driver, dev->name);
+		}
+		else if (Status == LM_STATUS_LINK_ACTIVE) {
+			printk(KERN_INFO "%s: %s NIC Link is UP, ", bcm5700_driver, dev->name);
+		}
+	}
+	else {
+		if (Status == LM_STATUS_LINK_DOWN) {
+			pUmDevice->line_speed = 0;
+			printk(KERN_ERR "%s: %s NIC Link is Down\n", bcm5700_driver, dev->name);
+		}
+		else if (Status == LM_STATUS_LINK_ACTIVE) {
+			printk(KERN_INFO "%s: %s NIC Link is Up, ", bcm5700_driver, dev->name);
+		}
+	}
+
+	if (Status == LM_STATUS_LINK_ACTIVE) {
+		if (pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS)
+			pUmDevice->line_speed = 1000;
+		else if (pDevice->LineSpeed == LM_LINE_SPEED_100MBPS)
+			pUmDevice->line_speed = 100;
+		else if (pDevice->LineSpeed == LM_LINE_SPEED_10MBPS)
+			pUmDevice->line_speed = 10;
+
+		printk("%d Mbps ", pUmDevice->line_speed);
+
+		if (pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+			printk("full duplex");
+		else
+			printk("half duplex");
+
+		flow_control = pDevice->FlowControl &
+			(LM_FLOW_CONTROL_RECEIVE_PAUSE |
+			LM_FLOW_CONTROL_TRANSMIT_PAUSE);
+		if (flow_control) {
+			if (flow_control & LM_FLOW_CONTROL_RECEIVE_PAUSE) {
+				printk(", receive ");
+				if (flow_control & LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+					printk("& transmit ");
+			}
+			else {
+				printk(", transmit ");
+			}
+			printk("flow control ON");
+		}
+		printk("\n");
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_FreeRxBuffer(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+
+	if (pPacket == 0)
+		return LM_STATUS_SUCCESS;
+	pUmPacket = (PUM_PACKET) pPacket;
+	if ((skb = pUmPacket->skbuff))
+		dev_kfree_skb(skb);
+	pUmPacket->skbuff = 0;
+	return LM_STATUS_SUCCESS;
+}
+
+
Binary files ../prev/linux/drivers/net/bcm/bcm5700.4.gz and linux/drivers/net/bcm/bcm5700.4.gz differ
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/bits.h linux/drivers/net/bcm/bits.h
--- ../prev/linux/drivers/net/bcm/bits.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/bits.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,62 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef BITS_H
+#define BITS_H
+
+
+
+/******************************************************************************/
+/* Bit Mask definitions */
+/******************************************************************************/
+
+#define BIT_NONE            0x00
+#define BIT_0               0x01
+#define BIT_1               0x02
+#define BIT_2               0x04
+#define BIT_3               0x08
+#define BIT_4               0x10
+#define BIT_5               0x20
+#define BIT_6               0x40
+#define BIT_7               0x80
+#define BIT_8               0x0100
+#define BIT_9               0x0200
+#define BIT_10              0x0400
+#define BIT_11              0x0800
+#define BIT_12              0x1000
+#define BIT_13              0x2000
+#define BIT_14              0x4000
+#define BIT_15              0x8000
+#define BIT_16              0x010000
+#define BIT_17              0x020000
+#define BIT_18              0x040000
+#define BIT_19              0x080000
+#define BIT_20              0x100000
+#define BIT_21              0x200000
+#define BIT_22              0x400000
+#define BIT_23              0x800000
+#define BIT_24              0x01000000
+#define BIT_25              0x02000000
+#define BIT_26              0x04000000
+#define BIT_27              0x08000000
+#define BIT_28              0x10000000
+#define BIT_29              0x20000000
+#define BIT_30              0x40000000
+#define BIT_31              0x80000000
+
+
+
+#endif /* BITS_H */
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/debug.h linux/drivers/net/bcm/debug.h
--- ../prev/linux/drivers/net/bcm/debug.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/debug.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,108 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef DEBUG_H 
+#define DEBUG_H 
+
+
+
+/******************************************************************************/
+/* Debug macros                                                               */
+/******************************************************************************/
+
+/* Code path for controlling output debug messages. */
+/* Define your code path here. */
+#define CP_INIT                     0x010000
+#define CP_SEND                     0x020000
+#define CP_RCV                      0x040000
+#define CP_INT                      0x080000
+#define CP_UINIT                    0x100000
+#define CP_RESET                    0x200000
+
+#define CP_ALL                      (CP_INIT | CP_SEND | CP_RCV | CP_INT | \
+                                    CP_RESET | CP_UINIT)
+
+#define CP_MASK                     0xffff0000
+
+
+/* Debug message levels. */
+#define LV_VERBOSE                  0x03
+#define LV_INFORM                   0x02
+#define LV_WARN                     0x01
+#define LV_FATAL                    0x00
+
+#define LV_MASK                     0xffff
+
+
+/* Code path and messsage level combined.  These are the first argument of */
+/* the DbgMessage macro. */
+#define INIT_V                      (CP_INIT | LV_VERBOSE)
+#define INIT_I                      (CP_INIT | LV_INFORM)
+#define INIT_W                      (CP_INIT | LV_WARN)
+#define SEND_V                      (CP_SEND | LV_VERBOSE)
+#define SEND_I                      (CP_SEND | LV_INFORM)
+#define SEND_W                      (CP_SEND | LV_WARN)
+#define RCV_V                       (CP_RCV | LV_VERBOSE)
+#define RCV_I                       (CP_RCV | LV_INFORM)
+#define RCV_W                       (CP_RCV | LV_WARN)
+#define INT_V                       (CP_INT | LV_VERBOSE)
+#define INT_I                       (CP_INT | LV_INFORM)
+#define INT_W                       (CP_INT | LV_WARN)
+#define UINIT_V                     (CP_UINIT | LV_VERBOSE)
+#define UINIT_I                     (CP_UINIT | LV_INFORM)
+#define UINIT_W                     (CP_UINIT | LV_WARN)
+#define RESET_V                     (CP_RESET | LV_VERBOSE)
+#define RESET_I                     (CP_RESET | LV_INFORM)
+#define RESET_W                     (CP_RESET | LV_WARN)
+#define CPALL_V                     (CP_ALL | LV_VERBOSE)
+#define CPALL_I                     (CP_ALL | LV_INFORM)
+#define CPALL_W                     (CP_ALL | LV_WARN)
+
+
+/* All code path message levels. */
+#define FATAL                       (CP_ALL | LV_FATAL)
+#define WARN                        (CP_ALL | LV_WARN)
+#define INFORM                      (CP_ALL | LV_INFORM)
+#define VERBOSE                     (CP_ALL | LV_VERBOSE)
+
+
+/* These constants control the message output. */
+/* Set your debug message output level and code path here. */
+#ifndef DBG_MSG_CP
+#define DBG_MSG_CP                  CP_ALL      /* Where to output messages. */
+#endif
+
+#ifndef DBG_MSG_LV
+#define DBG_MSG_LV                  LV_VERBOSE  /* Level of message output. */
+#endif
+
+
+/* DbgMessage macro. */
+#if DBG
+#define DbgMessage(CNTRL, MESSAGE)  \
+    if((CNTRL & DBG_MSG_CP) && ((CNTRL & LV_MASK) <= DBG_MSG_LV)) \
+        DbgPrint MESSAGE
+#define DbgBreak()                 DbgBreakPoint() 
+#define STATIC
+#else
+#define DbgMessage(CNTRL, MESSAGE)
+#define DbgBreak()
+#define STATIC static
+#endif /* DBG */
+
+
+
+#endif /* DEBUG_H */
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/lm.h linux/drivers/net/bcm/lm.h
--- ../prev/linux/drivers/net/bcm/lm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/lm.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,478 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef LM_H
+#define LM_H
+
+#include "debug.h"
+#include "queue.h"
+#include "bits.h"
+#include "lmcfg.h"
+
+
+
+/******************************************************************************/
+/* Basic types. */
+/******************************************************************************/
+
+typedef char           LM_CHAR,    *PLM_CHAR;
+typedef unsigned int   LM_UINT,    *PLM_UINT;
+typedef unsigned char  LM_UINT8,   *PLM_UINT8;
+typedef unsigned short LM_UINT16,  *PLM_UINT16;
+typedef unsigned int   LM_UINT32,  *PLM_UINT32;
+typedef unsigned int   LM_COUNTER, *PLM_COUNTER;
+typedef void           LM_VOID,    *PLM_VOID;
+typedef char           LM_BOOL,    *PLM_BOOL;
+
+/* 64bit value. */
+typedef struct {
+#ifdef BIG_ENDIAN_HOST
+    LM_UINT32 High;
+    LM_UINT32 Low;
+#else /* BIG_ENDIAN_HOST */
+    LM_UINT32 Low;
+    LM_UINT32 High;
+#endif /* !BIG_ENDIAN_HOST */
+} LM_UINT64, *PLM_UINT64;
+
+typedef LM_UINT64 LM_PHYSICAL_ADDRESS, *PLM_PHYSICAL_ADDRESS;
+
+/* void LM_INC_PHYSICAL_ADDRESS(PLM_PHYSICAL_ADDRESS pAddr,LM_UINT32 IncSize) */
+#define LM_INC_PHYSICAL_ADDRESS(pAddr, IncSize)             \
+    {                                                       \
+        LM_UINT32 OrgLow;                                   \
+                                                            \
+        OrgLow = (pAddr)->Low;                              \
+        (pAddr)->Low += IncSize;                            \
+        if((pAddr)->Low < OrgLow) {                         \
+            (pAddr)->High++; /* Wrap around. */             \
+        }                                                   \
+    }
+    
+
+#ifndef TRUE
+#define TRUE           1
+#endif /* TRUE */
+
+#ifndef FALSE
+#define FALSE          0
+#endif /* FALSE */
+
+#ifndef NULL
+#define NULL                ((void *) 0)
+#endif /* NULL */
+
+#ifndef OFFSETOF
+#define OFFSETOF(_s, _m)    (MM_UINT_PTR(&(((_s *) 0)->_m)))
+#endif /* OFFSETOF */
+
+
+
+/******************************************************************************/
+/* Simple macros. */
+/******************************************************************************/
+
+#define IS_ETH_BROADCAST(_pEthAddr)                                         \
+    (((unsigned char *) (_pEthAddr))[0] == ((unsigned char) 0xff))
+
+#define IS_ETH_MULTICAST(_pEthAddr)                                         \
+    (((unsigned char *) (_pEthAddr))[0] & ((unsigned char) 0x01))
+
+#define IS_ETH_ADDRESS_EQUAL(_pEtherAddr1, _pEtherAddr2)                    \
+    ((((unsigned char *) (_pEtherAddr1))[0] ==                              \
+    ((unsigned char *) (_pEtherAddr2))[0]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[1] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[1]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[2] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[2]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[3] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[3]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[4] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[4]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[5] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[5]))
+
+#define COPY_ETH_ADDRESS(_Src, _Dst)                                        \
+    ((unsigned char *) (_Dst))[0] = ((unsigned char *) (_Src))[0];          \
+    ((unsigned char *) (_Dst))[1] = ((unsigned char *) (_Src))[1];          \
+    ((unsigned char *) (_Dst))[2] = ((unsigned char *) (_Src))[2];          \
+    ((unsigned char *) (_Dst))[3] = ((unsigned char *) (_Src))[3];          \
+    ((unsigned char *) (_Dst))[4] = ((unsigned char *) (_Src))[4];          \
+    ((unsigned char *) (_Dst))[5] = ((unsigned char *) (_Src))[5];
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+#define ETHERNET_ADDRESS_SIZE           6
+#define ETHERNET_PACKET_HEADER_SIZE     14
+#define MIN_ETHERNET_PACKET_SIZE        64      /* with 4 byte crc. */
+#define MAX_ETHERNET_PACKET_SIZE        1518    /* with 4 byte crc. */
+#define MIN_ETHERNET_PACKET_SIZE_NO_CRC 60
+#define MAX_ETHERNET_PACKET_SIZE_NO_CRC 1514
+#define MAX_ETHERNET_PACKET_BUFFER_SIZE 1536    /* A nice even number. */
+
+#ifndef LM_MAX_MC_TABLE_SIZE
+#define LM_MAX_MC_TABLE_SIZE            32
+#endif /* LM_MAX_MC_TABLE_SIZE */
+#define LM_MC_ENTRY_SIZE                (ETHERNET_ADDRESS_SIZE+1)
+#define LM_MC_INSTANCE_COUNT_INDEX      (LM_MC_ENTRY_SIZE-1)
+
+
+/* Receive filter masks. */
+#define LM_ACCEPT_UNICAST               0x0001
+#define LM_ACCEPT_MULTICAST             0x0002
+#define LM_ACCEPT_ALL_MULTICAST         0x0004
+#define LM_ACCEPT_BROADCAST             0x0008
+#define LM_ACCEPT_ERROR_PACKET          0x0010
+
+#define LM_PROMISCUOUS_MODE             0x10000
+
+
+
+/******************************************************************************/
+/* PCI registers. */
+/******************************************************************************/
+
+#define PCI_VENDOR_ID_REG               0x00
+#define PCI_DEVICE_ID_REG               0x02
+
+#define PCI_COMMAND_REG                 0x04
+#define PCI_IO_SPACE_ENABLE             0x0001
+#define PCI_MEM_SPACE_ENABLE            0x0002
+#define PCI_BUSMASTER_ENABLE            0x0004
+#define PCI_MEMORY_WRITE_INVALIDATE     0x0010
+#define PCI_PARITY_ERROR_ENABLE         0x0040
+#define PCI_SYSTEM_ERROR_ENABLE         0x0100
+#define PCI_FAST_BACK_TO_BACK_ENABLE    0x0200
+
+#define PCI_STATUS_REG                  0x06
+#define PCI_REV_ID_REG                  0x08
+
+#define PCI_CACHE_LINE_SIZE_REG         0x0c
+
+#define PCI_IO_BASE_ADDR_REG            0x10
+#define PCI_IO_BASE_ADDR_MASK           0xfffffff0
+
+#define PCI_MEM_BASE_ADDR_LOW           0x10
+#define PCI_MEM_BASE_ADDR_HIGH          0x14
+
+#define PCI_SUBSYSTEM_VENDOR_ID_REG     0x2c
+#define PCI_SUBSYSTEM_ID_REG            0x2e
+#define PCI_INT_LINE_REG                0x3c
+
+#define PCIX_CAP_REG                    0x40
+#define PCIX_ENABLE_RELAXED_ORDERING    BIT_17
+
+/******************************************************************************/
+/* Fragment structure. */
+/******************************************************************************/
+
+typedef struct {
+    LM_UINT32 FragSize;
+    LM_PHYSICAL_ADDRESS FragBuf;
+} LM_FRAG, *PLM_FRAG;
+
+typedef struct {
+    /* FragCount is initialized for the caller to the maximum array size, on */
+    /* return FragCount is the number of the actual fragments in the array. */
+    LM_UINT32 FragCount;
+
+    /* Total buffer size. */
+    LM_UINT32 TotalSize;
+
+    /* Fragment array buffer. */
+    LM_FRAG Fragments[1];
+} LM_FRAG_LIST, *PLM_FRAG_LIST;
+
+#define DECLARE_FRAG_LIST_BUFFER_TYPE(_FRAG_LIST_TYPE_NAME, _MAX_FRAG_COUNT) \
+    typedef struct {                                                         \
+        LM_FRAG_LIST FragList;                                               \
+        LM_FRAG FragListBuffer[_MAX_FRAG_COUNT-1];                           \
+    } _FRAG_LIST_TYPE_NAME, *P##_FRAG_LIST_TYPE_NAME
+
+
+
+/******************************************************************************/
+/* Status codes. */
+/******************************************************************************/
+
+#define LM_STATUS_SUCCESS                                       0
+#define LM_STATUS_FAILURE                                       1
+
+#define LM_STATUS_INTERRUPT_ACTIVE                              2
+#define LM_STATUS_INTERRUPT_NOT_ACTIVE                          3
+
+#define LM_STATUS_LINK_ACTIVE                                   4
+#define LM_STATUS_LINK_DOWN                                     5
+#define LM_STATUS_LINK_SETTING_MISMATCH                         6
+
+#define LM_STATUS_TOO_MANY_FRAGMENTS                            7
+#define LM_STATUS_TRANSMIT_ABORTED                              8
+#define LM_STATUS_TRANSMIT_ERROR                                9
+#define LM_STATUS_RECEIVE_ABORTED                               10
+#define LM_STATUS_RECEIVE_ERROR                                 11
+#define LM_STATUS_INVALID_PACKET_SIZE                           12
+#define LM_STATUS_OUT_OF_MAP_REGISTERS                          13
+#define LM_STATUS_UNKNOWN_ADAPTER                               14
+
+typedef LM_UINT LM_STATUS, *PLM_STATUS;
+
+
+
+/******************************************************************************/
+/* Requested media type. */
+/******************************************************************************/
+
+#define LM_REQUESTED_MEDIA_TYPE_AUTO                            0
+#define LM_REQUESTED_MEDIA_TYPE_BNC                             1
+#define LM_REQUESTED_MEDIA_TYPE_UTP_AUTO                        2
+#define LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS                      3
+#define LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX          4
+#define LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS                     5
+#define LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX         6
+#define LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS                    7
+#define LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX        8
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS                   9
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS_FULL_DUPLEX       10
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS                  11
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX      12
+#define LM_REQUESTED_MEDIA_TYPE_MAC_LOOPBACK                    0xfffe
+#define LM_REQUESTED_MEDIA_TYPE_PHY_LOOPBACK                    0xffff
+
+typedef LM_UINT32 LM_REQUESTED_MEDIA_TYPE, *PLM_REQUESTED_MEDIA_TYPE;
+
+
+
+/******************************************************************************/
+/* Media type. */
+/******************************************************************************/
+
+#define LM_MEDIA_TYPE_UNKNOWN                                   -1
+#define LM_MEDIA_TYPE_AUTO                                      0
+#define LM_MEDIA_TYPE_UTP                                       1
+#define LM_MEDIA_TYPE_BNC                                       2
+#define LM_MEDIA_TYPE_AUI                                       3
+#define LM_MEDIA_TYPE_FIBER                                     4
+
+typedef LM_UINT32 LM_MEDIA_TYPE, *PLM_MEDIA_TYPE;
+
+
+
+/******************************************************************************/
+/* Line speed. */
+/******************************************************************************/
+
+#define LM_LINE_SPEED_UNKNOWN                                   0
+#define LM_LINE_SPEED_10MBPS                                    1
+#define LM_LINE_SPEED_100MBPS                                   2
+#define LM_LINE_SPEED_1000MBPS                                  3
+
+typedef LM_UINT32 LM_LINE_SPEED, *PLM_LINE_SPEED;
+
+
+
+/******************************************************************************/
+/* Duplex mode. */
+/******************************************************************************/
+
+#define LM_DUPLEX_MODE_UNKNOWN                                  0
+#define LM_DUPLEX_MODE_HALF                                     1
+#define LM_DUPLEX_MODE_FULL                                     2
+
+typedef LM_UINT32 LM_DUPLEX_MODE, *PLM_DUPLEX_MODE;
+
+
+
+/******************************************************************************/
+/* Power state. */
+/******************************************************************************/
+
+#define LM_POWER_STATE_D0       0
+#define LM_POWER_STATE_D1       1
+#define LM_POWER_STATE_D2       2
+#define LM_POWER_STATE_D3       3
+
+typedef LM_UINT32 LM_POWER_STATE, *PLM_POWER_STATE;
+
+
+
+/******************************************************************************/
+/* Task offloading. */
+/******************************************************************************/
+
+#define LM_TASK_OFFLOAD_NONE                    0x0000
+#define LM_TASK_OFFLOAD_TX_IP_CHECKSUM          0x0001
+#define LM_TASK_OFFLOAD_RX_IP_CHECKSUM          0x0002
+#define LM_TASK_OFFLOAD_TX_TCP_CHECKSUM         0x0004
+#define LM_TASK_OFFLOAD_RX_TCP_CHECKSUM         0x0008
+#define LM_TASK_OFFLOAD_TX_UDP_CHECKSUM         0x0010
+#define LM_TASK_OFFLOAD_RX_UDP_CHECKSUM         0x0020
+#define LM_TASK_OFFLOAD_TCP_SEGMENTATION        0x0040
+
+typedef LM_UINT32 LM_TASK_OFFLOAD, *PLM_TASK_OFFLOAD;
+
+
+
+/******************************************************************************/
+/* Flow control. */
+/******************************************************************************/
+
+#define LM_FLOW_CONTROL_NONE                    0x00
+#define LM_FLOW_CONTROL_RECEIVE_PAUSE           0x01
+#define LM_FLOW_CONTROL_TRANSMIT_PAUSE          0x02
+#define LM_FLOW_CONTROL_RX_TX_PAUSE (LM_FLOW_CONTROL_RECEIVE_PAUSE | \
+    LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+
+/* This value can be or-ed with RECEIVE_PAUSE and TRANSMIT_PAUSE.  If the */
+/* auto-negotiation is disabled and the RECEIVE_PAUSE and TRANSMIT_PAUSE */
+/* bits are set, then flow control is enabled regardless of link partner's */
+/* flow control capability. */
+#define LM_FLOW_CONTROL_AUTO_PAUSE              0x80000000
+
+typedef LM_UINT32 LM_FLOW_CONTROL, *PLM_FLOW_CONTROL;
+
+
+
+/******************************************************************************/
+/* Wake up mode. */
+/******************************************************************************/
+
+#define LM_WAKE_UP_MODE_NONE                    0
+#define LM_WAKE_UP_MODE_MAGIC_PACKET            1
+#define LM_WAKE_UP_MODE_NWUF                    2
+#define LM_WAKE_UP_MODE_LINK_CHANGE             4
+
+typedef LM_UINT32 LM_WAKE_UP_MODE, *PLM_WAKE_UP_MODE;
+
+
+
+/******************************************************************************/
+/* Counters. */
+/******************************************************************************/
+
+#define LM_COUNTER_FRAMES_XMITTED_OK                            0
+#define LM_COUNTER_FRAMES_RECEIVED_OK                           1
+#define LM_COUNTER_ERRORED_TRANSMIT_COUNT                       2
+#define LM_COUNTER_ERRORED_RECEIVE_COUNT                        3
+#define LM_COUNTER_RCV_CRC_ERROR                                4
+#define LM_COUNTER_ALIGNMENT_ERROR                              5
+#define LM_COUNTER_SINGLE_COLLISION_FRAMES                      6
+#define LM_COUNTER_MULTIPLE_COLLISION_FRAMES                    7
+#define LM_COUNTER_FRAMES_DEFERRED                              8
+#define LM_COUNTER_MAX_COLLISIONS                               9
+#define LM_COUNTER_RCV_OVERRUN                                  10
+#define LM_COUNTER_XMIT_UNDERRUN                                11
+#define LM_COUNTER_UNICAST_FRAMES_XMIT                          12
+#define LM_COUNTER_MULTICAST_FRAMES_XMIT                        13
+#define LM_COUNTER_BROADCAST_FRAMES_XMIT                        14
+#define LM_COUNTER_UNICAST_FRAMES_RCV                           15
+#define LM_COUNTER_MULTICAST_FRAMES_RCV                         16
+#define LM_COUNTER_BROADCAST_FRAMES_RCV                         17
+
+typedef LM_UINT32 LM_COUNTER_TYPE, *PLM_COUNTER_TYPE;
+
+
+
+/******************************************************************************/
+/* Forward definition. */
+/******************************************************************************/
+
+typedef struct _LM_DEVICE_BLOCK *PLM_DEVICE_BLOCK;
+typedef struct _LM_PACKET *PLM_PACKET;
+
+
+
+/******************************************************************************/
+/* Function prototypes. */
+/******************************************************************************/
+
+LM_STATUS LM_GetAdapterInfo(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_InitializeAdapter(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_ResetAdapter(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_DisableInterrupt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_EnableInterrupt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SendPacket(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS LM_ServiceInterrupts(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_QueueRxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetReceiveMask(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Mask);
+LM_STATUS LM_Halt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_Abort(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_MulticastAdd(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMcAddress);
+LM_STATUS LM_MulticastDel(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMcAddress);
+LM_STATUS LM_MulticastClear(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetMacAddress(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMacAddress);
+LM_STATUS LM_LoopbackAddress(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pAddress);
+
+LM_UINT32 LM_GetCrcCounter(PLM_DEVICE_BLOCK pDevice);
+
+LM_WAKE_UP_MODE LM_PMCapabilities(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_NwufAdd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 ByteMaskSize,
+    LM_UINT8 *pByteMask, LM_UINT8 *pPattern);
+LM_STATUS LM_NwufRemove(PLM_DEVICE_BLOCK pDevice, LM_UINT32 ByteMaskSize,
+    LM_UINT8 *pByteMask, LM_UINT8 *pPattern);
+LM_STATUS LM_SetPowerState(PLM_DEVICE_BLOCK pDevice, LM_POWER_STATE PowerLevel);
+
+LM_VOID LM_ReadPhy(PLM_DEVICE_BLOCK pDevice, LM_UINT32 PhyReg,
+    PLM_UINT32 pData32);
+LM_VOID LM_WritePhy(PLM_DEVICE_BLOCK pDevice, LM_UINT32 PhyReg,
+    LM_UINT32 Data32);
+
+LM_STATUS LM_ControlLoopBack(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Control);
+LM_STATUS LM_SetupPhy(PLM_DEVICE_BLOCK pDevice);
+int LM_BlinkLED(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlinkDuration);
+
+
+
+/******************************************************************************/
+/* These are the OS specific functions called by LMAC. */
+/******************************************************************************/
+
+LM_STATUS MM_ReadConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT16 *pValue16);
+LM_STATUS MM_WriteConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT16 Value16);
+LM_STATUS MM_ReadConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT32 *pValue32);
+LM_STATUS MM_WriteConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT32 Value32);
+LM_STATUS MM_MapMemBase(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_MapIoBase(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateRxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateTxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_StartTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS MM_CompleteTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS MM_AllocateMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize, 
+    PLM_VOID *pMemoryBlockVirt);
+LM_STATUS MM_AllocateSharedMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+    PLM_VOID *pMemoryBlockVirt, PLM_PHYSICAL_ADDRESS pMemoryBlockPhy,
+    LM_BOOL Cached);
+LM_STATUS MM_GetConfig(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateStatus(PLM_DEVICE_BLOCK pDevice, LM_STATUS Status);
+LM_STATUS MM_InitializeUmPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_FreeRxBuffer(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS LM_MbufWorkAround(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetLinkSpeed(PLM_DEVICE_BLOCK pDevice,
+			  LM_REQUESTED_MEDIA_TYPE RequestedMediaType);
+
+#if INCLUDE_5703_A0_FIX
+LM_STATUS LM_Load5703DmaWFirmware(PLM_DEVICE_BLOCK pDevice);
+#endif
+
+
+#endif /* LM_H */
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/lmcfg.h linux/drivers/net/bcm/lmcfg.h
--- ../prev/linux/drivers/net/bcm/lmcfg.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/lmcfg.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,39 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef LMCFG_H
+#define LMCFG_H
+
+
+
+/******************************************************************************/
+/* Configurable constants */
+/******************************************************************************/
+
+#define LM_MAJOR_VER                1
+#define LM_MINOR_VER                0
+
+#define LM_SHORT_COMPANY_NAME_STR   "Broadcom"
+#define LM_LONG_COMPANY_NAME_STR    "Broadcom Corporation"
+
+#define LM_LONG_COPYRIGHT_STR    "Copyright \251 2000 Broadcom Corporation.  All rights reserved."
+#define LM_SHORT_COPYRIGHT_STR   "Copyright \251 2000 Broadcom Corporation."
+
+#define LM_DRV_PRODUCT_NAME_STR  "Gigabit Ethernet Driver"
+
+
+
+#endif /* LMCFG_H */
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/mm.h linux/drivers/net/bcm/mm.h
--- ../prev/linux/drivers/net/bcm/mm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/mm.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,192 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/******************************************************************************/
+
+#ifndef MM_H
+#define MM_H
+
+#include <linux/config.h>
+#if defined(CONFIG_SMP) && ! defined(__SMP__)
+#define __SMP__
+#endif
+#if defined(CONFIG_MODVERSIONS) && defined(MODULE) && ! defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+
+#ifndef B57UM
+#define __NO_VERSION__
+#endif
+#include <linux/version.h>
+#ifdef MODULE
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/module.h>
+#else
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#define SET_MODULE_OWNER(dev)
+#define MODULE_DEVICE_TABLE(pci, pci_tbl)
+#endif
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <asm/processor.h>		/* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+#include <linux/time.h>
+#if (LINUX_VERSION_CODE >= 0x020400)
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#endif
+#ifdef CONFIG_PROC_FS
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+#endif
+
+#ifdef __BIG_ENDIAN
+#define BIG_ENDIAN_HOST 1
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020327)
+#define __raw_readl readl
+#define __raw_writel writel
+#endif
+
+#include "lm.h"
+#include "queue.h"
+#include "tigon3.h"
+
+extern int MM_Packet_Desc_Size;
+
+#define MM_PACKET_DESC_SIZE MM_Packet_Desc_Size
+
+DECLARE_QUEUE_TYPE(UM_RX_PACKET_Q, MAX_RX_PACKET_DESC_COUNT+1);
+
+#define MAX_MEM 16
+
+#if (LINUX_VERSION_CODE < 0x020211)
+typedef u32 dma_addr_t;
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02030e)
+#define net_device device
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+#define tasklet_struct			tq_struct
+#endif
+
+typedef struct _UM_DEVICE_BLOCK {
+	LM_DEVICE_BLOCK lm_dev;
+	struct net_device *dev;
+	struct pci_dev *pdev;
+	struct net_device *next_module;
+	char *name;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *pfs_entry;
+	char pfs_name[32];
+#endif
+	void *mem_list[MAX_MEM];
+	dma_addr_t dma_list[MAX_MEM];
+	int mem_size_list[MAX_MEM];
+	int mem_list_num;
+	int index;
+	int opened;
+	int delayed_link_ind; /* Delay link status during initial load */
+	int adapter_just_inited; /* the first few seconds after init. */
+	int spurious_int;
+	int timer_interval;
+	int adaptive_expiry;
+	int crc_counter_expiry;
+	int poll_tbi_expiry;
+	int tx_full;
+	int tx_queued;
+	int line_speed;		/* in Mbps, 0 if link is down */
+	UM_RX_PACKET_Q rx_out_of_buf_q;
+	int rx_out_of_buf;
+	int rx_buf_repl_thresh;
+	int rx_buf_repl_panic_thresh;
+	int rx_buf_align;
+	struct timer_list timer;
+	int do_global_lock;
+	spinlock_t global_lock;
+	spinlock_t undi_lock;
+	long undi_flags;
+	volatile int interrupt;
+	int tasklet_pending;
+	int tasklet_busy;
+	struct tasklet_struct tasklet;
+	struct net_device_stats stats;
+#ifdef NICE_SUPPORT
+	void (*nice_rx)( struct sk_buff*, void* );
+	void* nice_ctx;
+#endif /* NICE_SUPPORT */
+	int adaptive_coalesce;
+	uint rx_last_cnt;
+	uint tx_last_cnt;
+	uint rx_curr_coalesce_frames;
+	uint rx_curr_coalesce_ticks;
+	uint tx_curr_coalesce_frames;
+#if TIGON3_DEBUG
+	uint tx_zc_count;
+	uint tx_chksum_count;
+	uint tx_himem_count;
+	uint rx_good_chksum_count;
+#endif
+	uint rx_bad_chksum_count;
+	uint rx_misc_errors;
+} UM_DEVICE_BLOCK, *PUM_DEVICE_BLOCK;
+
+#define MM_ACQUIRE_UNDI_LOCK(_pDevice) \
+	if (!(((PUM_DEVICE_BLOCK)(_pDevice))->do_global_lock)) {	\
+		long flags;						\
+		spin_lock_irqsave(&((PUM_DEVICE_BLOCK)(_pDevice))->undi_lock, flags);	\
+		((PUM_DEVICE_BLOCK)(_pDevice))->undi_flags = flags; \
+	}
+
+#define MM_RELEASE_UNDI_LOCK(_pDevice) \
+	if (!(((PUM_DEVICE_BLOCK)(_pDevice))->do_global_lock)) {	\
+		long flags = ((PUM_DEVICE_BLOCK) (_pDevice))->undi_flags; \
+		spin_unlock_irqrestore(&((PUM_DEVICE_BLOCK)(_pDevice))->undi_lock, flags); \
+	}
+
+#define MM_ACQUIRE_INT_LOCK(_pDevice) \
+	while (((PUM_DEVICE_BLOCK) _pDevice)->interrupt)
+
+#define MM_RELEASE_INT_LOCK(_pDevice)
+
+#define MM_UINT_PTR(_ptr)   ((unsigned long) (_ptr))
+
+#define DbgPrint(fmt, arg...) printk(KERN_WARNING fmt, ##arg)
+#if defined(CONFIG_X86)
+#define DbgBreakPoint() __asm__("int $129")
+#else
+#define DbgBreakPoint()
+#endif
+#define MM_Wait(time) udelay(time)
+
+#endif
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/nicext.h linux/drivers/net/bcm/nicext.h
--- ../prev/linux/drivers/net/bcm/nicext.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/nicext.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,110 @@
+/****************************************************************************
+ * Copyright(c) 2000-2001 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.          
+ *
+ * Name:        nicext.h
+ *
+ * Description: Broadcom Network Interface Card Extension (NICE) is an 
+ *              extension to Linux NET device kernel mode drivers. 
+ *              NICE is designed to provide additional functionalities, 
+ *              such as receive packet intercept. To support Broadcom NICE, 
+ *              the network device driver can be modified by adding an 
+ *              device ioctl handler and by indicating receiving packets 
+ *              to the NICE receive handler. Broadcom NICE will only be 
+ *              enabled by a NICE-aware intermediate driver, such as 
+ *              Broadcom Advanced Server Program Driver (BASP). When NICE 
+ *              is not enabled, the modified network device drivers 
+ *              functions exactly as other non-NICE aware drivers.
+ *
+ * Author:      Frankie Fan
+ *
+ * Created:     September 17, 2000
+ *
+ ****************************************************************************/
+#ifndef _nicext_h_
+#define _nicext_h_
+
+/*
+ * ioctl for NICE
+ */
+#define SIOCNICE                   	SIOCDEVPRIVATE+7
+
+/*
+ * SIOCNICE: 
+ *
+ * The following structure needs to be less than IFNAMSIZ (16 bytes) because
+ * we're overloading ifreq.ifr_ifru.
+ *
+ * If 16 bytes is not enough, we should consider relaxing this because
+ * this is no field after ifr_ifru in the ifreq structure. But we may
+ * run into future compatiability problem in case of changing struct ifreq.
+ */
+struct nice_req
+{
+    __u32 cmd;
+    
+    union
+    {
+#ifdef __KERNEL__
+        /* cmd = NICE_CMD_SET_RX or NICE_CMD_GET_RX */
+        struct
+        {
+            void (*nrqus1_rx)( struct sk_buff*, void* );
+            void* nrqus1_ctx;
+        } nrqu_nrqus1;
+
+        /* cmd = NICE_CMD_QUERY_SUPPORT */
+        struct
+        {
+            __u32 nrqus2_magic;
+            __u32 nrqus2_support_rx:1;
+            __u32 nrqus2_support_vlan:1;
+            __u32 nrqus2_support_get_speed:1;
+        } nrqu_nrqus2;
+#endif
+
+        /* cmd = NICE_CMD_GET_SPEED */
+        struct
+        {
+            unsigned int nrqus3_speed; /* 0 if link is down, */
+                                       /* otherwise speed in Mbps */
+        } nrqu_nrqus3;
+
+        /* cmd = NICE_CMD_BLINK_LED */
+        struct
+        {
+            unsigned int nrqus4_blink_time; /* blink duration in seconds */
+        } nrqu_nrqus4;
+
+    } nrq_nrqu;
+};
+
+#define nrq_rx           nrq_nrqu.nrqu_nrqus1.nrqus1_rx
+#define nrq_ctx          nrq_nrqu.nrqu_nrqus1.nrqus1_ctx
+#define nrq_support_rx   nrq_nrqu.nrqu_nrqus2.nrqus2_support_rx
+#define nrq_magic        nrq_nrqu.nrqu_nrqus2.nrqus2_magic
+#define nrq_support_vlan nrq_nrqu.nrqu_nrqus2.nrqus2_support_vlan
+#define nrq_support_get_speed nrq_nrqu.nrqu_nrqus2.nrqus2_support_get_speed
+#define nrq_speed        nrq_nrqu.nrqu_nrqus3.nrqus3_speed
+#define nrq_blink_time   nrq_nrqu.nrqu_nrqus4.nrqus4_blink_time
+
+/*
+ * magic constants
+ */
+#define NICE_REQUESTOR_MAGIC            0x4543494E // NICE in ascii
+#define NICE_DEVICE_MAGIC               0x4E494345 // ECIN in ascii
+
+/*
+ * command field
+ */
+#define NICE_CMD_QUERY_SUPPORT          0x00000001
+#define NICE_CMD_SET_RX                 0x00000002
+#define NICE_CMD_GET_RX                 0x00000003
+#define NICE_CMD_GET_SPEED              0x00000004
+#define NICE_CMD_BLINK_LED              0x00000005
+
+#endif  // _nicext_h_ 
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/queue.h linux/drivers/net/bcm/queue.h
--- ../prev/linux/drivers/net/bcm/queue.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/queue.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,338 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* Queue functions.                                                           */
+/*    void          QQ_InitQueue(PQQ_CONTAINER pQueue)                        */
+/*    char          QQ_Full(PQQ_CONTAINER pQueue)                             */
+/*    char          QQ_Empty(PQQ_CONTAINER pQueue)                            */
+/*    unsigned int QQ_GetSize(PQQ_CONTAINER pQueue)                          */
+/*    unsigned int QQ_GetEntryCnt(PQQ_CONTAINER pQueue)                      */
+/*    char          QQ_PushHead(PQQ_CONTAINER pQueue, PQQ_ENTRY pEntry)       */
+/*    char          QQ_PushTail(PQQ_CONTAINER pQueue, PQQ_ENTRY pEntry)       */
+/*    PQQ_ENTRY     QQ_PopHead(PQQ_CONTAINER pQueue)                          */
+/*    PQQ_ENTRY     QQ_PopTail(PQQ_CONTAINER pQueue)                          */
+/*    PQQ_ENTRY     QQ_GetHead(PQQ_CONTAINER pQueue, unsigned int Idx)       */
+/*    PQQ_ENTRY     QQ_GetTail(PQQ_CONTAINER pQueue, unsigned int Idx)       */
+/*                                                                            */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef BCM_QUEUE_H
+#define BCM_QUEUE_H
+
+
+
+/******************************************************************************/
+/* Queue definitions. */
+/******************************************************************************/
+
+/* Entry for queueing. */
+typedef void *PQQ_ENTRY;
+
+
+/* Queue header -- base type. */
+typedef struct {
+    unsigned int Head;
+    unsigned int Tail;
+    unsigned int Size;
+    atomic_t EntryCnt;
+    PQQ_ENTRY Array[1];
+} QQ_CONTAINER, *PQQ_CONTAINER;
+
+
+/* Declare queue type macro. */
+#define DECLARE_QUEUE_TYPE(_QUEUE_TYPE, _QUEUE_SIZE)            \
+                                                                \
+    typedef struct {                                            \
+        QQ_CONTAINER Container;                                 \
+        PQQ_ENTRY EntryBuffer[_QUEUE_SIZE];                     \
+    } _QUEUE_TYPE, *P##_QUEUE_TYPE
+
+
+
+/******************************************************************************/
+/* Compilation switches. */
+/******************************************************************************/
+
+#if DBG
+#undef QQ_NO_OVERFLOW_CHECK
+#undef QQ_NO_UNDERFLOW_CHECK
+#endif /* DBG */
+
+#ifdef QQ_USE_MACROS
+/* notdone */
+#else
+
+#ifdef QQ_NO_INLINE
+#define __inline
+#endif /* QQ_NO_INLINE */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void 
+QQ_InitQueue(
+PQQ_CONTAINER pQueue,
+unsigned int QueueSize) {
+    pQueue->Head = 0;
+    pQueue->Tail = 0;
+    pQueue->Size = QueueSize+1;
+    atomic_set(&pQueue->EntryCnt, 0);
+} /* QQ_InitQueue */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_Full(
+PQQ_CONTAINER pQueue) {
+    unsigned int NewHead;
+
+    NewHead = (pQueue->Head + 1) % pQueue->Size;
+
+    return(NewHead == pQueue->Tail);
+} /* QQ_Full */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_Empty(
+PQQ_CONTAINER pQueue) {
+    return(pQueue->Head == pQueue->Tail);
+} /* QQ_Empty */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned int 
+QQ_GetSize(
+PQQ_CONTAINER pQueue) {
+    return pQueue->Size;
+} /* QQ_GetSize */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned int 
+QQ_GetEntryCnt(
+PQQ_CONTAINER pQueue) {
+    return atomic_read(&pQueue->EntryCnt);
+} /* QQ_GetEntryCnt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    TRUE entry was added successfully.                                      */
+/*    FALSE queue is full.                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_PushHead(
+PQQ_CONTAINER pQueue, 
+PQQ_ENTRY pEntry) {
+    unsigned int Head;
+
+    Head = (pQueue->Head + 1) % pQueue->Size;
+
+#if !defined(QQ_NO_OVERFLOW_CHECK)
+    if(Head == pQueue->Tail) {
+        return 0;
+    } /* if */
+#endif /* QQ_NO_OVERFLOW_CHECK */
+
+    pQueue->Array[pQueue->Head] = pEntry;
+    pQueue->Head = Head;
+    atomic_inc(&pQueue->EntryCnt);
+
+    return -1;
+} /* QQ_PushHead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    TRUE entry was added successfully.                                      */
+/*    FALSE queue is full.                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_PushTail(
+PQQ_CONTAINER pQueue,
+PQQ_ENTRY pEntry) {
+    unsigned int Tail;
+
+    Tail = pQueue->Tail;
+    if(Tail == 0) {
+        Tail = pQueue->Size;
+    } /* if */
+    Tail--;
+
+#if !defined(QQ_NO_OVERFLOW_CHECK)
+    if(Tail == pQueue->Head) {
+        return 0;
+    } /* if */
+#endif /* QQ_NO_OVERFLOW_CHECK */
+
+    pQueue->Array[Tail] = pEntry;
+    pQueue->Tail = Tail;
+    atomic_inc(&pQueue->EntryCnt);
+
+    return -1;
+} /* QQ_PushTail */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_PopHead(
+PQQ_CONTAINER pQueue) {
+    unsigned int Head;
+    PQQ_ENTRY Entry;
+
+    Head = pQueue->Head;
+
+#if !defined(QQ_NO_UNDERFLOW_CHECK)
+    if(Head == pQueue->Tail) {
+        return (PQQ_ENTRY) 0;
+    } /* if */
+#endif /* QQ_NO_UNDERFLOW_CHECK */
+
+    if(Head == 0) {
+        Head = pQueue->Size;
+    } /* if */
+    Head--;
+
+    Entry = pQueue->Array[Head];
+    pQueue->Head = Head;
+    atomic_dec(&pQueue->EntryCnt);
+
+    return Entry;
+} /* QQ_PopHead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_PopTail(
+PQQ_CONTAINER pQueue) {
+    unsigned int Tail;
+    PQQ_ENTRY Entry;
+
+    Tail = pQueue->Tail;
+
+#if !defined(QQ_NO_UNDERFLOW_CHECK)
+    if(Tail == pQueue->Head) {
+        return (PQQ_ENTRY) 0;
+    } /* if */
+#endif /* QQ_NO_UNDERFLOW_CHECK */
+
+    Entry = pQueue->Array[Tail];
+    pQueue->Tail = (Tail + 1) % pQueue->Size;
+    atomic_dec(&pQueue->EntryCnt);
+
+    return Entry;
+} /* QQ_PopTail */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_GetHead(
+    PQQ_CONTAINER pQueue,
+    unsigned int Idx)
+{
+    if(Idx >= atomic_read(&pQueue->EntryCnt))
+    {
+        return (PQQ_ENTRY) 0;
+    }
+
+    if(pQueue->Head > Idx)
+    {
+        Idx = pQueue->Head - Idx;
+    }
+    else
+    {
+        Idx = pQueue->Size - (Idx - pQueue->Head);
+    }
+    Idx--;
+
+    return pQueue->Array[Idx];
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_GetTail(
+    PQQ_CONTAINER pQueue,
+    unsigned int Idx)
+{
+    if(Idx >= atomic_read(&pQueue->EntryCnt))
+    {
+        return (PQQ_ENTRY) 0;
+    }
+
+    Idx += pQueue->Tail;
+    if(Idx >= pQueue->Size)
+    {
+        Idx = Idx - pQueue->Size;
+    }
+
+    return pQueue->Array[Idx];
+}
+
+#endif /* QQ_USE_MACROS */
+
+
+
+#endif /* QUEUE_H */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/tigon3.c linux/drivers/net/bcm/tigon3.c
--- ../prev/linux/drivers/net/bcm/tigon3.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/tigon3.c	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,5929 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+#include "mm.h"
+
+
+
+/******************************************************************************/
+/* Local functions. */
+/******************************************************************************/
+
+LM_STATUS LM_Abort(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_QueueRxPackets(PLM_DEVICE_BLOCK pDevice);
+
+static LM_STATUS LM_TranslateRequestedMediaType(
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+    PLM_MEDIA_TYPE pMediaType, PLM_LINE_SPEED pLineSpeed,
+    PLM_DUPLEX_MODE pDuplexMode);
+
+static LM_STATUS LM_InitBcm540xPhy(PLM_DEVICE_BLOCK pDevice);
+
+__inline static LM_VOID LM_ServiceRxInterrupt(PLM_DEVICE_BLOCK pDevice);
+__inline static LM_VOID LM_ServiceTxInterrupt(PLM_DEVICE_BLOCK pDevice);
+
+static LM_STATUS LM_ForceAutoNegBcm540xPhy(PLM_DEVICE_BLOCK pDevice, 
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType, LM_BOOL WaitForLink);
+static LM_STATUS LM_ForceAutoNeg(PLM_DEVICE_BLOCK pDevice, 
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType, LM_BOOL WaitForLink);
+static LM_UINT32 GetPhyAdFlowCntrlSettings(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_SetFlowControl(PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 LocalPhyAd, LM_UINT32 RemotePhyAd);
+STATIC LM_STATUS LM_SetupFiberPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_SetupCopperPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_InitBcm800xPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC PLM_ADAPTER_INFO LM_GetAdapterInfoBySsid(LM_UINT16 Svid, LM_UINT16 Ssid);
+STATIC LM_STATUS LM_DmaTest(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pBufferVirt,
+           LM_PHYSICAL_ADDRESS BufferPhy, LM_UINT32 BufferSize);
+STATIC LM_STATUS LM_HaltCpu(PLM_DEVICE_BLOCK pDevice,LM_UINT32 cpu_number);
+STATIC LM_STATUS LM_ResetChip(PLM_DEVICE_BLOCK pDevice);
+
+
+/******************************************************************************/
+/* External functions. */
+/******************************************************************************/
+
+LM_STATUS LM_LoadRlsFirmware(PLM_DEVICE_BLOCK pDevice);
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_UINT32
+LM_RegRdInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Register) {
+    LM_UINT32 Value32;
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#endif
+    MM_WriteConfig32(pDevice, T3_PCI_REG_ADDR_REG, Register);
+    MM_ReadConfig32(pDevice, T3_PCI_REG_DATA_REG, &Value32);
+#if PCIX_TARGET_WORKAROUND
+    MM_RELEASE_UNDI_LOCK(pDevice);
+#endif
+
+    return Value32;
+} /* LM_RegRdInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_RegWrInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Register,
+LM_UINT32 Value32) {
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#endif
+    MM_WriteConfig32(pDevice, T3_PCI_REG_ADDR_REG, Register);
+    MM_WriteConfig32(pDevice, T3_PCI_REG_DATA_REG, Value32);
+#if PCIX_TARGET_WORKAROUND
+    MM_RELEASE_UNDI_LOCK(pDevice);
+#endif
+} /* LM_RegWrInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_UINT32
+LM_MemRdInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 MemAddr) {
+    LM_UINT32 Value32;
+
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#ifdef BIG_ENDIAN_HOST
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    Value32 = REG_RD(pDevice, PciCfg.MemWindowData);
+    /*    Value32 = REG_RD(pDevice,uIntMem.Mbuf[(MemAddr & 0x7fff)/4]); */
+#else
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    MM_ReadConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, &Value32);
+#endif
+    MM_RELEASE_UNDI_LOCK(pDevice);
+
+    return Value32;
+} /* LM_MemRdInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_MemWrInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 MemAddr,
+LM_UINT32 Value32) {
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#ifdef BIG_ENDIAN_HOST
+    REG_WR(pDevice,PciCfg.MemWindowBaseAddr,MemAddr);
+    REG_WR(pDevice,uIntMem.Mbuf[(MemAddr & 0x7fff)/4],Value32);
+#else
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, Value32);
+#endif
+    MM_RELEASE_UNDI_LOCK(pDevice);
+} /* LM_MemWrInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_QueueRxPackets(
+PLM_DEVICE_BLOCK pDevice) {
+    LM_STATUS Lmstatus;
+    PLM_PACKET pPacket;
+    PT3_RCV_BD pRcvBd;
+    LM_UINT32 StdBdAdded = 0;
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    LM_UINT32 JumboBdAdded = 0;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    Lmstatus = LM_STATUS_SUCCESS;
+
+    pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+    while(pPacket) {
+        switch(pPacket->u.Rx.RcvProdRing) {
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+            case T3_JUMBO_RCV_PROD_RING:        /* Jumbo Receive Ring. */
+                /* Initialize the buffer descriptor. */
+                pRcvBd = 
+                    &pDevice->pRxJumboBdVirt[pDevice->RxJumboProdIdx];
+                pRcvBd->Flags = RCV_BD_FLAG_END | RCV_BD_FLAG_JUMBO_RING;
+                pRcvBd->Len = (LM_UINT16) pDevice->RxJumboBufferSize;
+
+                /* Initialize the receive buffer pointer */
+                pRcvBd->HostAddr.Low = pPacket->u.Rx.RxBufferPhy.Low;
+                pRcvBd->HostAddr.High = pPacket->u.Rx.RxBufferPhy.High;
+
+                /* The opaque field may point to an offset from a fix addr. */
+                pRcvBd->Opaque = (LM_UINT32) (MM_UINT_PTR(pPacket) - 
+                    MM_UINT_PTR(pDevice->pPacketDescBase));
+
+                /* Update the producer index. */
+                pDevice->RxJumboProdIdx = (pDevice->RxJumboProdIdx + 1) & 
+                    T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK;
+
+                JumboBdAdded++;
+                break;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+            case T3_STD_RCV_PROD_RING:      /* Standard Receive Ring. */
+                /* Initialize the buffer descriptor. */
+                pRcvBd = &pDevice->pRxStdBdVirt[pDevice->RxStdProdIdx];
+                pRcvBd->Flags = RCV_BD_FLAG_END;
+                pRcvBd->Len = MAX_STD_RCV_BUFFER_SIZE;
+
+                /* Initialize the receive buffer pointer */
+                pRcvBd->HostAddr.Low = pPacket->u.Rx.RxBufferPhy.Low;
+                pRcvBd->HostAddr.High = pPacket->u.Rx.RxBufferPhy.High;
+
+                /* The opaque field may point to an offset from a fix addr. */
+                pRcvBd->Opaque = (LM_UINT32) (MM_UINT_PTR(pPacket) - 
+                    MM_UINT_PTR(pDevice->pPacketDescBase));
+
+                /* Update the producer index. */
+                pDevice->RxStdProdIdx = (pDevice->RxStdProdIdx + 1) & 
+                    T3_STD_RCV_RCB_ENTRY_COUNT_MASK;
+
+                StdBdAdded++;
+                break;
+
+            case T3_UNKNOWN_RCV_PROD_RING:
+            default:
+                Lmstatus = LM_STATUS_FAILURE;
+                break;
+        } /* switch */
+
+        /* Bail out if there is any error. */
+        if(Lmstatus != LM_STATUS_SUCCESS)
+        {
+            break;
+        }
+
+        pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+    } /* while */
+
+    wmb();
+    /* Update the procedure index. */
+    if(StdBdAdded)
+    {
+        RAW_REG_WR(pDevice, Mailbox.RcvStdProdIdx.Low, pDevice->RxStdProdIdx);
+    }
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    if(JumboBdAdded)
+    {
+        RAW_REG_WR(pDevice, Mailbox.RcvJumboProdIdx.Low,
+            pDevice->RxJumboProdIdx);
+    }
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    return Lmstatus;
+} /* LM_QueueRxPackets */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_VOID
+LM_NvramInit(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    /* Intialize clock period and state machine. */
+    Value32 = SEEPROM_ADDR_CLK_PERD(SEEPROM_CLOCK_PERIOD) |
+        SEEPROM_ADDR_FSM_RESET;
+    REG_WR(pDevice, Grc.EepromAddr, Value32);
+
+    for(j = 0; j < 100; j++)
+    {
+        MM_Wait(10);
+    }
+
+    /* Serial eeprom access using the Grc.EepromAddr/EepromData registers. */
+    Value32 = REG_RD(pDevice, Grc.LocalCtrl);
+    REG_WR(pDevice, Grc.LocalCtrl, Value32 | GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM);
+
+    /* Set the 5701 compatibility mode if we are using EEPROM. */
+    if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+        T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5701)
+    {
+        Value32 = REG_RD(pDevice, Nvram.Config1);
+        if((Value32 & FLASH_INTERFACE_ENABLE) == 0)
+        {
+            /* Use the new interface to read EEPROM. */
+            Value32 &= ~FLASH_COMPAT_BYPASS;
+
+            REG_WR(pDevice, Nvram.Config1, Value32);
+        }
+    }
+} /* LM_NvRamInit */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_EepromRead(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 Offset,
+    LM_UINT32 *pData)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 Addr;
+    LM_UINT32 Dev;
+    LM_UINT32 j;
+
+    if(Offset > SEEPROM_CHIP_SIZE)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    Dev = Offset / SEEPROM_CHIP_SIZE;
+    Addr = Offset % SEEPROM_CHIP_SIZE;
+    
+    Value32 = REG_RD(pDevice, Grc.EepromAddr);
+    Value32 &= ~(SEEPROM_ADDR_ADDRESS_MASK | SEEPROM_ADDR_DEV_ID_MASK |
+        SEEPROM_ADDR_RW_MASK);
+    REG_WR(pDevice, Grc.EepromAddr, Value32 | SEEPROM_ADDR_DEV_ID(Dev) |
+        SEEPROM_ADDR_ADDRESS(Addr) | SEEPROM_ADDR_START | SEEPROM_ADDR_READ);
+
+    for(j = 0; j < 1000; j++)
+    {
+        Value32 = REG_RD(pDevice, Grc.EepromAddr);
+        if(Value32 & SEEPROM_ADDR_COMPLETE)
+        {
+            break;
+        }
+        MM_Wait(10);
+    }
+
+    if(Value32 & SEEPROM_ADDR_COMPLETE)
+    {
+        Value32 = REG_RD(pDevice, Grc.EepromData);
+        *pData = Value32;
+
+        return LM_STATUS_SUCCESS;
+    }
+
+    return LM_STATUS_FAILURE;
+} /* LM_EepromRead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_NvramRead(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 Offset,
+    LM_UINT32 *pData)
+{
+    LM_UINT32 Value32;
+    LM_STATUS Status;
+    LM_UINT32 j;
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+        T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+    {
+        Status = LM_EepromRead(pDevice, Offset, pData);
+    }
+    else
+    {
+        /* Determine if we have flash or EEPROM. */
+        Value32 = REG_RD(pDevice, Nvram.Config1);
+        if(Value32 & FLASH_INTERFACE_ENABLE)
+        {
+            if(Value32 & FLASH_SSRAM_BUFFERRED_MODE)
+            {
+                Offset = ((Offset/BUFFERED_FLASH_PAGE_SIZE) <<
+                    BUFFERED_FLASH_PAGE_POS) +
+                    (Offset % BUFFERED_FLASH_PAGE_SIZE);
+            }
+        }
+
+        REG_WR(pDevice, Nvram.SwArb, SW_ARB_REQ_SET1);
+        for (j = 0; j < 1000; j++)
+        {
+            if (REG_RD(pDevice, Nvram.SwArb) & SW_ARB_GNT1)
+            {
+                break;
+            }
+            MM_Wait(20);
+        }
+        if (j == 1000)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        /* Read from flash or EEPROM with the new 5703/02 interface. */
+        REG_WR(pDevice, Nvram.Addr, Offset & NVRAM_ADDRESS_MASK);
+
+        REG_WR(pDevice, Nvram.Cmd, NVRAM_CMD_RD | NVRAM_CMD_DO_IT |
+            NVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);
+
+        /* Wait for the done bit to clear. */
+        for(j = 0; j < 500; j++)
+        {
+            MM_Wait(10);
+
+            Value32 = REG_RD(pDevice, Nvram.Cmd);
+            if(!(Value32 & NVRAM_CMD_DONE))
+            {
+                break;
+            }
+        }
+        
+        /* Wait for the done bit. */
+        if(!(Value32 & NVRAM_CMD_DONE))
+        {
+            for(j = 0; j < 500; j++)
+            {
+                MM_Wait(10);
+
+                Value32 = REG_RD(pDevice, Nvram.Cmd);
+                if(Value32 & NVRAM_CMD_DONE)
+                {
+                    MM_Wait(10);
+
+                    *pData = REG_RD(pDevice, Nvram.ReadData);
+
+                    /* Change the endianess. */
+                    *pData = ((*pData & 0xff) << 24)| ((*pData & 0xff00) << 8)|
+                        ((*pData & 0xff0000) >> 8) | ((*pData >> 24) & 0xff);
+
+                    break;
+                }
+            }
+        }
+
+        REG_WR(pDevice, Nvram.SwArb, SW_ARB_REQ_CLR1);
+        if(Value32 & NVRAM_CMD_DONE)
+        {
+            Status = LM_STATUS_SUCCESS;
+        }
+        else
+        {
+            Status = LM_STATUS_FAILURE;
+        }
+    }
+
+    return Status;
+} /* LM_NvramRead */
+
+
+
+STATIC void
+LM_ReadVPD(PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT8 Vpd[256];
+    LM_UINT32 *Vpd_dptr = (LM_UINT32 *) Vpd;
+    LM_UINT32 Value32;
+    unsigned int j;
+
+    /* Read PN from VPD */
+    for (j = 0; j < 256; j += 4, Vpd_dptr++ )
+    {
+        if (LM_NvramRead(pDevice, 0x100 + j, &Value32) != LM_STATUS_SUCCESS) {
+            printk(KERN_ERR "VPD read failed\n");
+            return;
+        }
+        *Vpd_dptr = cpu_to_le32(Value32);
+    }
+    for (j = 0; j < 256; )
+    {
+        unsigned int Vpd_r_len;
+        unsigned int Vpd_r_end;
+
+        if ((Vpd[j] == 0x82) || (Vpd[j] == 0x91))
+        {
+            j = j + 3 + Vpd[j + 1] + (Vpd[j + 2] << 8);
+        }
+        else if (Vpd[j] == 0x90)
+        {
+            Vpd_r_len =  Vpd[j + 1] + (Vpd[j + 2] << 8);
+            j += 3;
+            Vpd_r_end = Vpd_r_len + j;
+            while (j < Vpd_r_end)
+            {
+                if ((Vpd[j] == 'P') && (Vpd[j + 1] == 'N'))
+                {
+                    unsigned int len = Vpd[j + 2];
+
+                    if (len <= 24)
+                    {
+                        memcpy(pDevice->PartNo, &Vpd[j + 3], len);
+                    }
+                    break;
+                }
+                else
+                {
+                    if (Vpd[j + 2] == 0)
+                    {
+                        break;
+                    }
+                    j = j + Vpd[j + 2];
+                }
+            }
+            break;
+        }
+        else {
+            break;
+        }
+    }
+}
+
+STATIC void
+LM_ReadBootCodeVersion(PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32, offset, ver_offset;
+    int i;
+
+    if (LM_NvramRead(pDevice, 0x0, &Value32) != LM_STATUS_SUCCESS)
+        return;
+    if (Value32 != 0xaa559966)
+        return;
+    if (LM_NvramRead(pDevice, 0xc, &offset) != LM_STATUS_SUCCESS)
+        return;
+
+    offset = ((offset & 0xff) << 24)| ((offset & 0xff00) << 8)|
+        ((offset & 0xff0000) >> 8) | ((offset >> 24) & 0xff);
+    if (LM_NvramRead(pDevice, offset, &Value32) != LM_STATUS_SUCCESS)
+        return;
+    if ((Value32 == 0x0300000e) &&
+        (LM_NvramRead(pDevice, offset + 4, &Value32) == LM_STATUS_SUCCESS) &&
+        (Value32 == 0)) {
+
+        if (LM_NvramRead(pDevice, offset + 8, &ver_offset) != LM_STATUS_SUCCESS)
+            return;
+        ver_offset = ((ver_offset & 0xff0000) >> 8) |
+            ((ver_offset >> 24) & 0xff);
+        for (i = 0; i < 16; i += 4) {
+            if (LM_NvramRead(pDevice, offset + ver_offset + i, &Value32) !=
+                LM_STATUS_SUCCESS)
+            {
+                return;
+            }
+            *((LM_UINT32 *) &pDevice->BootCodeVer[i]) = cpu_to_le32(Value32);
+        }
+    }
+    else {
+        char c;
+
+        if (LM_NvramRead(pDevice, 0x94, &Value32) != LM_STATUS_SUCCESS)
+            return;
+
+        i = 0;
+        c = ((Value32 & 0xff0000) >> 16);
+
+        if (c < 10) {
+            pDevice->BootCodeVer[i++] = c + '0';
+        }
+        else {
+            pDevice->BootCodeVer[i++] = (c / 10) + '0';
+            pDevice->BootCodeVer[i++] = (c % 10) + '0';
+        }
+        pDevice->BootCodeVer[i++] = '.';
+        c = (Value32 & 0xff000000) >> 24;
+        if (c < 10) {
+            pDevice->BootCodeVer[i++] = c + '0';
+        }
+        else {
+            pDevice->BootCodeVer[i++] = (c / 10) + '0';
+            pDevice->BootCodeVer[i++] = (c % 10) + '0';
+        }
+        pDevice->BootCodeVer[i] = 0;
+    }
+}
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine initializes default parameters and reads the PCI           */
+/*    configurations.                                                         */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_GetAdapterInfo(
+PLM_DEVICE_BLOCK pDevice)
+{
+    PLM_ADAPTER_INFO pAdapterInfo;
+    LM_UINT32 Value32;
+    LM_STATUS Status;
+    LM_UINT32 j;
+    LM_UINT32 EeSigFound;
+    LM_UINT32 EePhyTypeSerdes = 0;
+    LM_UINT32 EePhyLedMode = 0;
+    LM_UINT32 EePhyId = 0;
+
+    /* Get Device Id and Vendor Id */
+    Status = MM_ReadConfig32(pDevice, PCI_VENDOR_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->PciVendorId = (LM_UINT16) Value32;
+    pDevice->PciDeviceId = (LM_UINT16) (Value32 >> 16);
+
+    /* If we are not getting the write adapter, exit. */
+    if((Value32 != T3_PCI_ID_BCM5700) && 
+       (Value32 != T3_PCI_ID_BCM5701) &&
+       (Value32 != T3_PCI_ID_BCM5702) &&
+       (Value32 != T3_PCI_ID_BCM5702x) &&
+       (Value32 != T3_PCI_ID_BCM5702FE) &&
+       (Value32 != T3_PCI_ID_BCM5703) &&
+       (Value32 != T3_PCI_ID_BCM5703x))
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    Status = MM_ReadConfig32(pDevice, PCI_REV_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->PciRevId = (LM_UINT8) Value32;
+
+    /* Get IRQ. */
+    Status = MM_ReadConfig32(pDevice, PCI_INT_LINE_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->Irq = (LM_UINT8) Value32;
+
+    /* Get interrupt pin. */
+    pDevice->IntPin = (LM_UINT8) (Value32 >> 8);
+
+    /* Get chip revision id. */
+    Status = MM_ReadConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, &Value32);
+    pDevice->ChipRevId = Value32 >> 16;
+
+    /* Get subsystem vendor. */
+    Status = MM_ReadConfig32(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->SubsystemVendorId = (LM_UINT16) Value32;
+
+    /* Get PCI subsystem id. */
+    pDevice->SubsystemId = (LM_UINT16) (Value32 >> 16);
+
+    /* Get the cache line size. */
+    MM_ReadConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG, &Value32);
+    pDevice->CacheLineSize = (LM_UINT8) Value32;
+    pDevice->SavedCacheLineReg = Value32;
+
+    /* Get PCI memory base. */
+    MM_ReadConfig32(pDevice, PCI_MEM_BASE_ADDR_HIGH, &Value32);
+    pDevice->MemBaseHigh = Value32;
+
+    MM_ReadConfig32(pDevice, PCI_MEM_BASE_ADDR_LOW, &Value32);
+    Value32 &= 0xfffffff0;
+    pDevice->MemBaseLow = Value32;
+
+    /* Initialize require MemBase Size */
+    pDevice->MemBaseSize = sizeof(T3_STD_MEM_MAP); 
+
+    /* Map the memory base to system address space. */
+    Status = MM_MapMemBase(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Initialize the memory view pointer. */
+    pDevice->pMemView = (PT3_STD_MEM_MAP) pDevice->pMappedMemBase;
+
+#if PCIX_TARGET_WORKAROUND
+    /* store whether we are in PCI are PCI-X mode */
+    pDevice->EnablePciXFix = FALSE;
+
+    MM_ReadConfig32(pDevice, T3_PCI_STATE_REG, &Value32);
+    if((Value32 & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) == 0)
+    {
+        /* Enable PCI-X workaround only if we are running on 5700 BX. */
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            pDevice->EnablePciXFix = TRUE;
+        }
+    }
+#endif
+    /* Bx bug: due to the "byte_enable bug" in PCI-X mode, the power */
+    /* management register may be clobbered which may cause the */
+    /* BCM5700 to go into D3 state.  While in this state, we will */
+    /* not have memory mapped register access.  As a workaround, we */
+    /* need to restore the device to D0 state. */
+    MM_ReadConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, &Value32);
+    Value32 |= T3_PM_PME_ASSERTED;
+    Value32 &= ~T3_PM_POWER_STATE_MASK;
+    Value32 |= T3_PM_POWER_STATE_D0;
+    MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, Value32);
+
+    /* read the current PCI command word */
+    MM_ReadConfig32(pDevice, PCI_COMMAND_REG, &Value32);
+
+    /* Make sure bus-mastering is enabled. */
+    Value32 |= PCI_BUSMASTER_ENABLE;
+
+#if PCIX_TARGET_WORKAROUND
+	/* if we are in PCI-X mode, also make sure mem-mapping and SERR#/PERR#
+	   are enabled */
+        if (pDevice->EnablePciXFix == TRUE) {
+            Value32 |= (PCI_MEM_SPACE_ENABLE | PCI_SYSTEM_ERROR_ENABLE | 
+                        PCI_PARITY_ERROR_ENABLE);
+        }
+#endif
+
+    if(pDevice->EnableMWI)
+    {
+        Value32 |= PCI_MEMORY_WRITE_INVALIDATE;
+    }
+    else {
+        Value32 &= (~PCI_MEMORY_WRITE_INVALIDATE);
+    }
+
+    /* Error out if mem-mapping is NOT enabled for PCI systems */
+    if (!(Value32 | PCI_MEM_SPACE_ENABLE))
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* save the value we are going to write into the PCI command word */	
+    pDevice->PciCommandStatusWords = Value32;	
+
+    Status = MM_WriteConfig32(pDevice, PCI_COMMAND_REG, Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Set power state to D0. */
+    LM_SetPowerState(pDevice, LM_POWER_STATE_D0);
+
+    /* Setup the mode registers. */
+    pDevice->MiscHostCtrl = 
+        MISC_HOST_CTRL_MASK_PCI_INT | 
+        MISC_HOST_CTRL_ENABLE_ENDIAN_WORD_SWAP | 
+#ifdef BIG_ENDIAN_HOST
+        MISC_HOST_CTRL_ENABLE_ENDIAN_BYTE_SWAP |  
+#endif /* BIG_ENDIAN_HOST */
+        MISC_HOST_CTRL_ENABLE_INDIRECT_ACCESS |
+        MISC_HOST_CTRL_ENABLE_PCI_STATE_REG_RW;
+	/* write to PCI misc host ctr first in order to enable indirect accesses */
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, pDevice->MiscHostCtrl);
+
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl);
+
+#ifdef BIG_ENDIAN_HOST
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+              GRC_MODE_WORD_SWAP_NON_FRAME_DATA;
+#else
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | GRC_MODE_BYTE_SWAP_DATA;
+#endif
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        REG_WR(pDevice, Grc.LocalCtrl, GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1 |
+            GRC_MISC_LOCAL_CTRL_GPIO_OE1);
+    }
+    MM_Wait(40);
+
+    /* Enable indirect memory access */
+    REG_WR(pDevice, MemArbiter.Mode, T3_MEM_ARBITER_MODE_ENABLE);
+
+    if (REG_RD(pDevice, PciCfg.ClockCtrl) & T3_PCI_44MHZ_CORE_CLOCK)
+    {
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_44MHZ_CORE_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK);
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_SELECT_ALTERNATE_CLOCK);
+        MM_Wait(40);  /* required delay is 27usec */
+    }
+    REG_WR(pDevice, PciCfg.ClockCtrl, 0);
+    REG_WR(pDevice, PciCfg.MemWindowBaseAddr, 0);
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ReadConfig32(pDevice, T3_PCI_STATE_REG, &Value32);
+    if ((pDevice->EnablePciXFix == FALSE) &&
+        ((Value32 & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) == 0))
+    {
+        if (pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B2 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B5)
+        {
+            __raw_writel(0, &(pDevice->pMemView->uIntMem.MemBlock32K[0x300]));
+            __raw_writel(0, &(pDevice->pMemView->uIntMem.MemBlock32K[0x301]));
+            __raw_writel(0xffffffff, &(pDevice->pMemView->uIntMem.MemBlock32K[0x301]));
+            if (__raw_readl(&(pDevice->pMemView->uIntMem.MemBlock32K[0x300])))
+            {
+                pDevice->EnablePciXFix = TRUE;
+            }
+        }
+    }
+#endif
+    /* Get the node address.  First try to get in from the shared memory. */
+    /* If the signature is not present, then get it from the NVRAM. */
+    Value32 = MEM_RD_OFFSET(pDevice, T3_MAC_ADDR_HIGH_MAILBOX);
+    if((Value32 >> 16) == 0x484b)
+    {
+
+        pDevice->NodeAddress[0] = (LM_UINT8) (Value32 >> 8);
+        pDevice->NodeAddress[1] = (LM_UINT8) Value32;
+
+        Value32 = MEM_RD_OFFSET(pDevice, T3_MAC_ADDR_LOW_MAILBOX);
+
+        pDevice->NodeAddress[2] = (LM_UINT8) (Value32 >> 24);
+        pDevice->NodeAddress[3] = (LM_UINT8) (Value32 >> 16);
+        pDevice->NodeAddress[4] = (LM_UINT8) (Value32 >> 8);
+        pDevice->NodeAddress[5] = (LM_UINT8) Value32;
+
+        Status = LM_STATUS_SUCCESS;
+    }
+    else
+    {
+
+        MM_Wait(50);
+        LM_NvramInit(pDevice);
+
+        Status = LM_NvramRead(pDevice, 0x7c, &Value32);
+        if(Status == LM_STATUS_SUCCESS)
+        {
+            pDevice->NodeAddress[0] = (LM_UINT8) (Value32 >> 16);
+            pDevice->NodeAddress[1] = (LM_UINT8) (Value32 >> 24);
+
+            Status = LM_NvramRead(pDevice, 0x80, &Value32);
+
+            pDevice->NodeAddress[2] = (LM_UINT8) Value32;
+            pDevice->NodeAddress[3] = (LM_UINT8) (Value32 >> 8);
+            pDevice->NodeAddress[4] = (LM_UINT8) (Value32 >> 16);
+            pDevice->NodeAddress[5] = (LM_UINT8) (Value32 >> 24);
+        }
+    }
+
+    /* Assign a default address. */
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        printk(KERN_ERR "Cannot get MAC addr from NVRAM. Using default.\n");
+
+        pDevice->NodeAddress[0] = 0x00; pDevice->NodeAddress[1] = 0x10;
+        pDevice->NodeAddress[2] = 0x18; pDevice->NodeAddress[3] = 0x68;
+        pDevice->NodeAddress[4] = 0x61; pDevice->NodeAddress[5] = 0x76;
+    }
+
+    pDevice->PermanentNodeAddress[0] = pDevice->NodeAddress[0];
+    pDevice->PermanentNodeAddress[1] = pDevice->NodeAddress[1];
+    pDevice->PermanentNodeAddress[2] = pDevice->NodeAddress[2];
+    pDevice->PermanentNodeAddress[3] = pDevice->NodeAddress[3];
+    pDevice->PermanentNodeAddress[4] = pDevice->NodeAddress[4];
+    pDevice->PermanentNodeAddress[5] = pDevice->NodeAddress[5];
+
+    /* Initialize the default values. */
+    pDevice->NoTxPseudoHdrChksum = FALSE;
+    pDevice->NoRxPseudoHdrChksum = FALSE;
+    pDevice->NicSendBd = FALSE;
+    pDevice->TxPacketDescCnt = DEFAULT_TX_PACKET_DESC_COUNT;
+    pDevice->RxStdDescCnt = DEFAULT_STD_RCV_DESC_COUNT;
+    pDevice->RxCoalescingTicks = DEFAULT_RX_COALESCING_TICKS;
+    pDevice->TxCoalescingTicks = DEFAULT_TX_COALESCING_TICKS;
+    pDevice->RxMaxCoalescedFrames = DEFAULT_RX_MAX_COALESCED_FRAMES;
+    pDevice->TxMaxCoalescedFrames = DEFAULT_TX_MAX_COALESCED_FRAMES;
+    pDevice->RxCoalescingTicksDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->TxCoalescingTicksDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->RxMaxCoalescedFramesDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->TxMaxCoalescedFramesDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->StatsCoalescingTicks = DEFAULT_STATS_COALESCING_TICKS;
+    pDevice->EnableMWI = FALSE;
+    pDevice->TxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    pDevice->DisableAutoNeg = FALSE;
+    pDevice->PhyIntMode = T3_PHY_INT_MODE_AUTO;
+    pDevice->LinkChngMode = T3_LINK_CHNG_MODE_AUTO;
+    pDevice->LedMode = LED_MODE_AUTO;
+    pDevice->ResetPhyOnInit = TRUE;
+    pDevice->DelayPciGrant = TRUE;
+    pDevice->UseTaggedStatus = FALSE;
+    pDevice->OneDmaAtOnce = BAD_DEFAULT_VALUE;
+
+    pDevice->DmaMbufLowMark = T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO;
+    pDevice->RxMacMbufLowMark = T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO;
+    pDevice->MbufHighMark = T3_DEF_MBUF_HIGH_WMARK_JUMBO;
+
+    pDevice->RequestedMediaType = LM_REQUESTED_MEDIA_TYPE_AUTO;
+    pDevice->TaskOffloadCap = LM_TASK_OFFLOAD_NONE;
+    pDevice->FlowControlCap = LM_FLOW_CONTROL_AUTO_PAUSE;
+    pDevice->EnableTbi = FALSE;
+#if INCLUDE_TBI_SUPPORT
+    pDevice->PollTbiLink = BAD_DEFAULT_VALUE;
+#endif
+
+    pDevice->MbufBase = T3_NIC_MBUF_POOL_ADDR;
+    pDevice->MbufSize = T3_NIC_MBUF_POOL_SIZE;
+
+    pDevice->LinkStatus = LM_STATUS_LINK_DOWN;
+    pDevice->QueueRxPackets = TRUE;
+
+    pDevice->EnableWireSpeed = TRUE;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    pDevice->RxJumboDescCnt = DEFAULT_JUMBO_RCV_DESC_COUNT;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Make this is a known adapter. */
+    pAdapterInfo = LM_GetAdapterInfoBySsid(pDevice->SubsystemVendorId,
+        pDevice->SubsystemId);
+
+    pDevice->BondId = REG_RD(pDevice, Grc.MiscCfg) & GRC_MISC_BD_ID_MASK;
+    if (pDevice->BondId != GRC_MISC_BD_ID_5700 &&
+        pDevice->BondId != GRC_MISC_BD_ID_5701 &&
+        pDevice->BondId != GRC_MISC_BD_ID_5702FE &&
+        pDevice->BondId != GRC_MISC_BD_ID_5703 &&
+        pDevice->BondId != GRC_MISC_BD_ID_5703S)
+    {
+        return LM_STATUS_UNKNOWN_ADAPTER;
+    }
+
+    /* Get Eeprom info. */
+    Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_SIG_ADDR);
+    if (Value32 == T3_NIC_DATA_SIG)
+    {
+        EeSigFound = TRUE;
+        Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_NIC_CFG_ADDR);
+
+        /* Determine PHY type. */
+        switch (Value32 & T3_NIC_CFG_PHY_TYPE_MASK)
+        {
+            case T3_NIC_CFG_PHY_TYPE_COPPER:
+                EePhyTypeSerdes = FALSE;
+                break;
+
+            case T3_NIC_CFG_PHY_TYPE_FIBER:
+                EePhyTypeSerdes = TRUE;
+                break;
+
+            default:
+                EePhyTypeSerdes = FALSE;
+                break;
+        }
+
+        /* Determine PHY led mode. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            switch(Value32 & T3_NIC_CFG_LED_MODE_MASK)
+            {
+                case T3_NIC_CFG_LED_MODE_TRIPLE_SPEED:
+                    EePhyLedMode = LED_MODE_THREE_LINK;
+                    break;
+
+                case T3_NIC_CFG_LED_MODE_LINK_SPEED:
+                    EePhyLedMode = LED_MODE_LINK10;
+                    break;
+
+                default:
+                    EePhyLedMode = LED_MODE_AUTO;
+                    break;
+            }
+        }
+        else
+        {
+            switch(Value32 & T3_NIC_CFG_LED_MODE_MASK)
+            {
+                case T3_NIC_CFG_LED_MODE_OPEN_DRAIN:
+                    EePhyLedMode = LED_MODE_OPEN_DRAIN;
+                    break;
+
+                case T3_NIC_CFG_LED_MODE_OUTPUT:
+                    EePhyLedMode = LED_MODE_OUTPUT;
+                    break;
+
+                default:
+                    EePhyLedMode = LED_MODE_AUTO;
+                    break;
+            }
+        }
+        if(pDevice->ChipRevId == T3_CHIP_ID_5703_A1 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5703_A2)
+        {
+            /* Enable EEPROM write protection. */
+            if(Value32 & T3_NIC_EEPROM_WP)
+            {
+                pDevice->EepromWp = TRUE;
+            }
+        }
+
+        /* Get the PHY Id. */
+        Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_PHY_ID_ADDR);
+        if (Value32)
+        {
+            EePhyId = (((Value32 & T3_NIC_PHY_ID1_MASK) >> 16) &
+                PHY_ID1_OUI_MASK) << 10;
+
+            Value32 = Value32 & T3_NIC_PHY_ID2_MASK;
+
+            EePhyId |= ((Value32 & PHY_ID2_OUI_MASK) << 16) |
+              (Value32 & PHY_ID2_MODEL_MASK) | (Value32 & PHY_ID2_REV_MASK);
+        }
+        else
+        {
+            EePhyId = 0;
+        }
+    }
+    else
+    {
+        EeSigFound = FALSE;
+    }
+
+    /* Set the PHY address. */
+    pDevice->PhyAddr = PHY_DEVICE_ID;
+
+    /* Disable auto polling. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    MM_Wait(40);
+
+    /* Get the PHY id. */
+    LM_ReadPhy(pDevice, PHY_ID1_REG, &Value32);
+    pDevice->PhyId = (Value32 & PHY_ID1_OUI_MASK) << 10;
+
+    LM_ReadPhy(pDevice, PHY_ID2_REG, &Value32);
+    pDevice->PhyId |= ((Value32 & PHY_ID2_OUI_MASK) << 16) |
+      (Value32 & PHY_ID2_MODEL_MASK) | (Value32 & PHY_ID2_REV_MASK);
+
+    /* Set the EnableTbi flag to false if we have a copper PHY. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5401_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5411_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5701_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5703_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM8002_PHY_ID:
+            pDevice->EnableTbi = TRUE;
+            break;
+
+        default:
+
+            if (pAdapterInfo)
+            {
+                pDevice->PhyId = pAdapterInfo->PhyId;
+                pDevice->EnableTbi = pAdapterInfo->Serdes;
+            }
+            else if (EeSigFound)
+            {
+                pDevice->PhyId = EePhyId;
+                pDevice->EnableTbi = EePhyTypeSerdes;
+            }
+            break;
+    }
+
+    /* Bail out if we don't know the copper PHY id. */
+    if(UNKNOWN_PHY_ID(pDevice->PhyId) && !pDevice->EnableTbi)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5703)
+    {
+        if((pDevice->SavedCacheLineReg & 0xff00) < 0x4000)
+        {
+            pDevice->SavedCacheLineReg &= 0xffff00ff;
+            pDevice->SavedCacheLineReg |= 0x4000;
+        }
+    }
+    /* Change driver parameters. */
+    Status = MM_GetConfig(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+#if INCLUDE_5701_AX_FIX
+    if (pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+    {
+        pDevice->ResetPhyOnInit = TRUE;
+    }
+#endif
+
+    /* Save the current phy link status. */
+    if(!pDevice->EnableTbi)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        /* If we don't have link reset the PHY. */
+        if(!(Value32 & PHY_STATUS_LINK_PASS) || pDevice->ResetPhyOnInit)
+        {
+
+            LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_PHY_RESET);
+
+            for(j = 0; j < 100; j++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+                if(Value32 && !(Value32 & PHY_CTRL_PHY_RESET))
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+
+#if INCLUDE_5701_AX_FIX
+            /* 5701_AX_BX bug:  only advertises 10mb speed. */
+            if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+                pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+            {
+
+                Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD |
+                    PHY_AN_AD_10BASET_HALF | PHY_AN_AD_10BASET_FULL |
+                    PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+                Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+                LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+                pDevice->advertising = Value32;
+
+                Value32 = BCM540X_AN_AD_1000BASET_HALF | 
+                    BCM540X_AN_AD_1000BASET_FULL | BCM540X_CONFIG_AS_MASTER |
+                    BCM540X_ENABLE_CONFIG_AS_MASTER;
+                LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+                pDevice->advertising1000 = Value32;
+
+                LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_AUTO_NEG_ENABLE |
+                    PHY_CTRL_RESTART_AUTO_NEG);
+            }
+#endif
+            if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5703)
+            {
+                LM_WritePhy(pDevice, 0x18, 0x0c00);
+                LM_WritePhy(pDevice, 0x17, 0x201f);
+                LM_WritePhy(pDevice, 0x15, 0x2aaa);
+            }
+            /* Enable Ethernet@WireSpeed. */
+            if(pDevice->EnableWireSpeed)
+            {
+                LM_WritePhy(pDevice, 0x18, 0x7007);
+                LM_ReadPhy(pDevice, 0x18, &Value32);
+                LM_WritePhy(pDevice, 0x18, Value32 | BIT_15 | BIT_4);
+            }
+        }
+    }
+
+    /* Turn off tap power management. */
+    if((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+    {
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x0c20);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+
+        MM_Wait(40);
+    }
+
+#if INCLUDE_TBI_SUPPORT
+    if(pDevice->EnableTbi)
+    {
+        pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_NONE;
+        pDevice->PhyIntMode = T3_PHY_INT_MODE_LINK_READY;
+        if ((pDevice->PollTbiLink == BAD_DEFAULT_VALUE) ||
+            pDevice->DisableAutoNeg)
+        {
+            pDevice->PollTbiLink = FALSE;
+        }
+    }
+    else
+    {
+        pDevice->PollTbiLink = FALSE;
+    }
+#endif /* INCLUDE_TBI_SUPPORT */
+
+    /* UseTaggedStatus is only valid for 5701 and later. */
+    if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        pDevice->UseTaggedStatus = FALSE;
+
+        pDevice->CoalesceMode = 0;
+    }
+    else
+    {
+        pDevice->CoalesceMode = HOST_COALESCE_CLEAR_TICKS_ON_RX_BD_EVENT |
+            HOST_COALESCE_CLEAR_TICKS_ON_TX_BD_EVENT;
+    }
+
+    /* Set the status block size. */
+    if(T3_CHIP_REV(pDevice->ChipRevId) != T3_CHIP_REV_5700_AX &&
+        T3_CHIP_REV(pDevice->ChipRevId) != T3_CHIP_REV_5700_BX)
+    {
+        pDevice->CoalesceMode |= HOST_COALESCE_32_BYTE_STATUS_MODE;
+    }
+
+    /* Check the DURING_INT coalescing ticks parameters. */
+    if(pDevice->UseTaggedStatus)
+    {
+        if(pDevice->RxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxCoalescingTicksDuringInt =
+                DEFAULT_RX_COALESCING_TICKS_DURING_INT;
+        }
+
+        if(pDevice->TxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxCoalescingTicksDuringInt =
+                DEFAULT_TX_COALESCING_TICKS_DURING_INT;
+        }
+
+        if(pDevice->RxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxMaxCoalescedFramesDuringInt =
+                DEFAULT_RX_MAX_COALESCED_FRAMES_DURING_INT;
+        }
+
+        if(pDevice->TxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxMaxCoalescedFramesDuringInt =
+                DEFAULT_TX_MAX_COALESCED_FRAMES_DURING_INT;
+        }
+    }
+    else
+    {
+        if(pDevice->RxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxCoalescingTicksDuringInt = 0;
+        }
+
+        if(pDevice->TxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxCoalescingTicksDuringInt = 0;
+        }
+
+        if(pDevice->RxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxMaxCoalescedFramesDuringInt = 0;
+        }
+
+        if(pDevice->TxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxMaxCoalescedFramesDuringInt = 0;
+        }
+    }
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    if(pDevice->RxMtu <= (MAX_STD_RCV_BUFFER_SIZE - 8 /* CRC */))
+    {
+        pDevice->RxJumboDescCnt = 0;
+        if(pDevice->RxMtu <= MAX_ETHERNET_PACKET_SIZE_NO_CRC)
+        {
+            pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+        }
+    }
+    else
+    {
+        pDevice->RxJumboBufferSize = (pDevice->RxMtu + 8 /* CRC + VLAN */ +
+            COMMON_CACHE_LINE_SIZE-1) & ~COMMON_CACHE_LINE_MASK;
+
+        if(pDevice->RxJumboBufferSize > MAX_JUMBO_RCV_BUFFER_SIZE)
+        {
+            pDevice->RxJumboBufferSize = DEFAULT_JUMBO_RCV_BUFFER_SIZE;
+            pDevice->RxMtu = pDevice->RxJumboBufferSize - 8 /* CRC + VLAN */;
+        }
+        pDevice->TxMtu = pDevice->RxMtu;
+
+    }
+#else
+    pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    pDevice->RxPacketDescCnt = 
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+        pDevice->RxJumboDescCnt +
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+        pDevice->RxStdDescCnt;
+
+    if(pDevice->TxMtu < MAX_ETHERNET_PACKET_SIZE_NO_CRC)
+    {
+        pDevice->TxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    }
+
+    if(pDevice->TxMtu > MAX_JUMBO_TX_BUFFER_SIZE)
+    {
+        pDevice->TxMtu = MAX_JUMBO_TX_BUFFER_SIZE;
+    }
+
+    /* Configure the proper ways to get link change interrupt. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO)
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+        }
+        else
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_LINK_READY;
+        }
+    }
+    else if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        /* Auto-polling does not work on 5700_AX and 5700_BX. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+        }
+    }
+
+    /* Determine the method to get link change status. */
+    if(pDevice->LinkChngMode == T3_LINK_CHNG_MODE_AUTO)
+    {
+        /* The link status bit in the status block does not work on 5700_AX */
+        /* and 5700_BX chips. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+        }
+        else
+        {
+            pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_BLOCK;
+        }
+    }
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT ||
+        T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+    }
+
+    /* Configure PHY led mode. */
+    if(pDevice->LedMode == LED_MODE_AUTO)
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            if(pDevice->SubsystemVendorId == T3_SVID_DELL)
+            {
+                pDevice->LedMode = LED_MODE_LINK10;
+            }
+            else
+            {
+                pDevice->LedMode = LED_MODE_THREE_LINK;
+
+                if(EeSigFound && EePhyLedMode != LED_MODE_AUTO)
+                {
+                    pDevice->LedMode = EePhyLedMode;
+                }
+            }
+
+            /* bug? 5701 in LINK10 mode does not seem to work when */
+            /* PhyIntMode is LINK_READY. */
+            if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+#if INCLUDE_TBI_SUPPORT
+                pDevice->EnableTbi == FALSE &&
+#endif
+                pDevice->LedMode == LED_MODE_LINK10)
+            {
+                pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+                pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+            }
+
+            if(pDevice->EnableTbi)
+            {
+                pDevice->LedMode = LED_MODE_THREE_LINK;
+            }
+        }
+        else
+        {
+            if(EeSigFound && EePhyLedMode != LED_MODE_AUTO)
+            {
+                pDevice->LedMode = EePhyLedMode;
+            }
+            else
+            {
+                pDevice->LedMode = LED_MODE_OPEN_DRAIN;
+            }
+        }
+    }
+
+    /* Enable OneDmaAtOnce. */
+    if(pDevice->OneDmaAtOnce == BAD_DEFAULT_VALUE)
+    {
+        pDevice->OneDmaAtOnce = FALSE;
+    }
+
+    if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B2)
+    {
+        pDevice->WolSpeed = WOL_SPEED_10MB;
+    }
+    else
+    {
+        pDevice->WolSpeed = WOL_SPEED_100MB;
+    }
+
+    /* Offloadings. */
+    pDevice->TaskToOffload = LM_TASK_OFFLOAD_NONE;
+
+    /* Turn off task offloading on Ax. */
+    if(pDevice->ChipRevId == T3_CHIP_ID_5700_B0)
+    {
+        pDevice->TaskOffloadCap &= ~(LM_TASK_OFFLOAD_TX_TCP_CHECKSUM |
+            LM_TASK_OFFLOAD_TX_UDP_CHECKSUM);
+    }
+    pDevice->PciState = REG_RD(pDevice, PciCfg.PciState);
+    LM_ReadVPD(pDevice);
+    LM_ReadBootCodeVersion(pDevice);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_GetAdapterInfo */
+
+STATIC PLM_ADAPTER_INFO
+LM_GetAdapterInfoBySsid(
+    LM_UINT16 Svid,
+    LM_UINT16 Ssid)
+{
+    static LM_ADAPTER_INFO AdapterArr[] =
+    {
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700A6, PHY_BCM5401_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A5, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700T6, PHY_BCM8002_PHY_ID, 1},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700A9, 0, 1 },
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701T1, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701T8, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A7, 0, 1},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A10, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A12, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95703Ax1, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95703Ax2, PHY_BCM5701_PHY_ID, 0},
+
+        { T3_SVID_3COM, T3_SSID_3COM_3C996T, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C996BT, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C996SX, 0, 1 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C1000T, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C940BR01, PHY_BCM5701_PHY_ID, 0 },
+
+        { T3_SVID_DELL, T3_SSID_DELL_VIPER, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_JAGUAR, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_MERLOT, PHY_BCM5411_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_SLIM_MERLOT, PHY_BCM5411_PHY_ID, 0 },
+
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_BANSHEE, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_BANSHEE_2, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_CHANGELING, 0, 1 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_NC7780, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_NC7780_2, PHY_BCM5701_PHY_ID, 0 },
+
+    };
+    LM_UINT32 j;
+
+    for(j = 0; j < sizeof(AdapterArr)/sizeof(LM_ADAPTER_INFO); j++)
+    {
+        if(AdapterArr[j].Svid == Svid && AdapterArr[j].Ssid == Ssid)
+        {
+            return &AdapterArr[j];
+        }
+    }
+
+    return NULL;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine sets up receive/transmit buffer descriptions queues.       */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_InitializeAdapter(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_PHYSICAL_ADDRESS MemPhy;
+    PLM_UINT8 pMemVirt;
+    PLM_PACKET pPacket;
+    LM_STATUS Status;
+    LM_UINT32 Size;
+    LM_UINT32 j;
+
+    /* Set power state to D0. */
+    LM_SetPowerState(pDevice, LM_POWER_STATE_D0);
+
+    /* Intialize the queues. */
+    QQ_InitQueue(&pDevice->RxPacketReceivedQ.Container, 
+        MAX_RX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->RxPacketFreeQ.Container,
+        MAX_RX_PACKET_DESC_COUNT);
+
+    QQ_InitQueue(&pDevice->TxPacketFreeQ.Container,MAX_TX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->TxPacketActiveQ.Container,MAX_TX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->TxPacketXmittedQ.Container,MAX_TX_PACKET_DESC_COUNT);
+
+    /* Allocate shared memory for: status block, the buffers for receive */
+    /* rings -- standard, mini, jumbo, and return rings. */
+    Size = T3_STATUS_BLOCK_SIZE + sizeof(T3_STATS_BLOCK) +
+        T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD) +
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+        T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD) +
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+        T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+
+    /* Memory for host based Send BD. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        Size += sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT;
+    }
+
+    /* Allocate the memory block. */
+    Status = MM_AllocateSharedMemory(pDevice, Size, (PLM_VOID) &pMemVirt, &MemPhy, FALSE);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Program DMA Read/Write */
+    if (pDevice->PciState & T3_PCI_STATE_NOT_PCI_X_BUS)
+    {
+        pDevice->DmaReadWriteCtrl = 0x763f000f;    
+    }
+    else
+    {
+        pDevice->DmaReadWriteCtrl = 0x761b000f;    
+        if(pDevice->ChipRevId == T3_CHIP_ID_5703_A1 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5703_A2)
+        {
+            pDevice->OneDmaAtOnce = TRUE;
+        }
+    }
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5703)
+    {
+        pDevice->DmaReadWriteCtrl &= 0xfffffff0;
+    }
+
+    if(pDevice->OneDmaAtOnce)
+    {
+        pDevice->DmaReadWriteCtrl |= DMA_CTRL_WRITE_ONE_DMA_AT_ONCE;
+    }
+    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl, pDevice->DmaReadWriteCtrl);
+
+    if (LM_DmaTest(pDevice, pMemVirt, MemPhy, 0x400) != LM_STATUS_SUCCESS)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Status block. */
+    pDevice->pStatusBlkVirt = (PT3_STATUS_BLOCK) pMemVirt;
+    pDevice->StatusBlkPhy = MemPhy;
+    pMemVirt += T3_STATUS_BLOCK_SIZE;
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, T3_STATUS_BLOCK_SIZE);
+
+    /* Statistics block. */
+    pDevice->pStatsBlkVirt = (PT3_STATS_BLOCK) pMemVirt;
+    pDevice->StatsBlkPhy = MemPhy;
+    pMemVirt += sizeof(T3_STATS_BLOCK);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, sizeof(T3_STATS_BLOCK));
+
+    /* Receive standard BD buffer. */
+    pDevice->pRxStdBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RxStdBdPhy = MemPhy;
+
+    pMemVirt += T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Receive jumbo BD buffer. */
+    pDevice->pRxJumboBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RxJumboBdPhy = MemPhy;
+
+    pMemVirt += T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Receive return BD buffer. */
+    pDevice->pRcvRetBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RcvRetBdPhy = MemPhy;
+
+    pMemVirt += T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+
+    /* Set up Send BD. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        pDevice->pSendBdVirt = (PT3_SND_BD) pMemVirt;
+        pDevice->SendBdPhy = MemPhy;
+
+        pMemVirt += sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT;
+        LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+            sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT);
+    }
+    else
+    {
+        pDevice->pSendBdVirt = (PT3_SND_BD)
+            pDevice->pMemView->uIntMem.First32k.BufferDesc;
+        pDevice->SendBdPhy.High = 0;
+        pDevice->SendBdPhy.Low = T3_NIC_SND_BUFFER_DESC_ADDR;
+    }
+
+    /* Allocate memory for packet descriptors. */
+    Size = (pDevice->RxPacketDescCnt + 
+        pDevice->TxPacketDescCnt) * MM_PACKET_DESC_SIZE;
+    Status = MM_AllocateMemory(pDevice, Size, (PLM_VOID *) &pPacket);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->pPacketDescBase = (PLM_VOID) pPacket;
+
+    /* Create transmit packet descriptors from the memory block and add them */
+    /* to the TxPacketFreeQ for each send ring. */
+    for(j = 0; j < pDevice->TxPacketDescCnt; j++)
+    {
+        /* Ring index. */
+        pPacket->Flags = 0;
+
+        /* Queue the descriptor in the TxPacketFreeQ of the 'k' ring. */
+        QQ_PushTail(&pDevice->TxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for(j.. */
+
+    /* Create receive packet descriptors from the memory block and add them */
+    /* to the RxPacketFreeQ.  Create the Standard packet descriptors. */
+    for(j = 0; j < pDevice->RxStdDescCnt; j++)
+    {
+        /* Receive producer ring. */
+        pPacket->u.Rx.RcvProdRing = T3_STD_RCV_PROD_RING;
+
+        /* Receive buffer size. */
+        pPacket->u.Rx.RxBufferSize = MAX_STD_RCV_BUFFER_SIZE;
+
+        /* Add the descriptor to RxPacketFreeQ. */
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for */
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Create the Jumbo packet descriptors. */
+    for(j = 0; j < pDevice->RxJumboDescCnt; j++)
+    {
+        /* Receive producer ring. */
+        pPacket->u.Rx.RcvProdRing = T3_JUMBO_RCV_PROD_RING;
+
+        /* Receive buffer size. */
+        pPacket->u.Rx.RxBufferSize = pDevice->RxJumboBufferSize;
+
+        /* Add the descriptor to RxPacketFreeQ. */
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for */
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Initialize the rest of the packet descriptors. */
+    Status = MM_InitializeUmPackets(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    } /* if */
+
+    /* Default receive mask. */
+    pDevice->ReceiveMask = LM_ACCEPT_MULTICAST | LM_ACCEPT_BROADCAST |
+        LM_ACCEPT_UNICAST;
+
+    /* Make sure we are in the first 32k memory window or NicSendBd. */
+    REG_WR(pDevice, PciCfg.MemWindowBaseAddr, 0);
+
+    /* Initialize the hardware. */
+    Status = LM_ResetAdapter(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* We are done with initialization. */
+    pDevice->InitDone = TRUE;
+
+    return LM_STATUS_SUCCESS;
+} /* LM_InitializeAdapter */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This function Enables/Disables a given block.                          */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_CntrlBlock(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 mask,LM_UINT32 cntrl)
+{
+    LM_UINT32 j,i,data;
+    LM_UINT32 MaxWaitCnt;
+
+    MaxWaitCnt = 2;
+    j = 0;
+
+    for(i = 0 ; i < 32; i++) 
+    {
+        if(!(mask & (1 << i)))
+            continue;     
+ 
+        switch (1 << i) 
+        {
+            case T3_BLOCK_DMA_RD:
+                data = REG_RD(pDevice, DmaRead.Mode);
+                if (cntrl == LM_DISABLE) 
+                {
+                    data &= ~DMA_READ_MODE_ENABLE;
+                    REG_WR(pDevice, DmaRead.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaRead.Mode) & DMA_READ_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else 
+                    REG_WR(pDevice, DmaRead.Mode, data | DMA_READ_MODE_ENABLE);
+                break;
+  
+            case T3_BLOCK_DMA_COMP:
+                data = REG_RD(pDevice,DmaComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~DMA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, DmaComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaComp.Mode) & DMA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, DmaComp.Mode, data | DMA_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_BD_INITIATOR:
+                data = REG_RD(pDevice, RcvBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, RcvBdIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvBdIn.Mode) & RCV_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }              
+                }
+                else
+                    REG_WR(pDevice, RcvBdIn.Mode,data | RCV_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_BD_COMP:
+                data = REG_RD(pDevice, RcvBdComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_BD_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, RcvBdComp.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvBdComp.Mode) & RCV_BD_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, RcvBdComp.Mode,data | RCV_BD_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_DMA_WR:
+                data = REG_RD(pDevice, DmaWrite.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~DMA_WRITE_MODE_ENABLE;
+                    REG_WR(pDevice, DmaWrite.Mode,data);
+
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaWrite.Mode) & DMA_WRITE_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, DmaWrite.Mode,data | DMA_WRITE_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MSI_HANDLER:
+                data = REG_RD(pDevice, Msi.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~MSI_MODE_ENABLE;
+                    REG_WR(pDevice, Msi.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, Msi.Mode) & MSI_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, Msi.Mode, data |MSI_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_LIST_PLMT:
+                data = REG_RD(pDevice, RcvListPlmt.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_LIST_PLMT_MODE_ENABLE;
+                    REG_WR(pDevice, RcvListPlmt.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvListPlmt.Mode) & RCV_LIST_PLMT_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, RcvListPlmt.Mode,data | RCV_LIST_PLMT_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_LIST_SELECTOR:
+                data = REG_RD(pDevice, RcvListSel.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_LIST_SEL_MODE_ENABLE;
+                    REG_WR(pDevice, RcvListSel.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvListSel.Mode) & RCV_LIST_SEL_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, RcvListSel.Mode,data |RCV_LIST_SEL_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_DATA_INITIATOR:
+                data = REG_RD(pDevice, RcvDataBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_DATA_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, RcvDataBdIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvDataBdIn.Mode) & RCV_DATA_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }      
+                }
+                else
+                    REG_WR(pDevice, RcvDataBdIn.Mode, data | RCV_DATA_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_DATA_COMP:
+                data = REG_RD(pDevice, RcvDataComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_DATA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, RcvDataComp.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvDataBdIn.Mode) & RCV_DATA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }        
+                }
+                else
+                    REG_WR(pDevice, RcvDataComp.Mode,data | RCV_DATA_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_HOST_COALESING:
+                data = REG_RD(pDevice, HostCoalesce.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~HOST_COALESCE_ENABLE;
+                    REG_WR(pDevice, HostCoalesce.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdIn.Mode) & HOST_COALESCE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, HostCoalesce.Mode, data | HOST_COALESCE_ENABLE);
+                break;
+
+            case T3_BLOCK_MAC_RX_ENGINE:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->RxMode &= ~RX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MacCtrl.RxMode) & RX_MODE_ENABLE))
+                        {
+                            break;
+                        }
+                        MM_Wait(10);
+                    }
+                }
+                else
+                {
+                    pDevice->RxMode |= RX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+                }
+                break;
+
+            case T3_BLOCK_MBUF_CLUSTER_FREE:
+                data = REG_RD(pDevice, MbufClusterFree.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~MBUF_CLUSTER_FREE_MODE_ENABLE;
+                    REG_WR(pDevice, MbufClusterFree.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MbufClusterFree.Mode) & MBUF_CLUSTER_FREE_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, MbufClusterFree.Mode, data | MBUF_CLUSTER_FREE_MODE_ENABLE);         
+                break;
+
+            case T3_BLOCK_SEND_BD_INITIATOR:
+                data = REG_RD(pDevice, SndBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdIn.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdIn.Mode) & SND_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdIn.Mode, data  | SND_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_BD_COMP:
+                data = REG_RD(pDevice, SndBdComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdComp.Mode) & SND_BD_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdComp.Mode, data | SND_BD_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_BD_SELECTOR:
+                data = REG_RD(pDevice, SndBdSel.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_SEL_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdSel.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdSel.Mode) & SND_BD_SEL_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdSel.Mode, data | SND_BD_SEL_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_DATA_INITIATOR:
+                data = REG_RD(pDevice, SndDataIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~T3_SND_DATA_IN_MODE_ENABLE;
+                    REG_WR(pDevice, SndDataIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndDataIn.Mode) & T3_SND_DATA_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndDataIn.Mode,data | T3_SND_DATA_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_DATA_COMP:
+                data = REG_RD(pDevice, SndDataComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_DATA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, SndDataComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndDataComp.Mode) & SND_DATA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndDataComp.Mode,data | SND_DATA_COMP_MODE_ENABLE);
+                break;
+               
+            case T3_BLOCK_MAC_TX_ENGINE:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->TxMode &= ~TX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MacCtrl.TxMode) & TX_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else  
+                {
+                    pDevice->TxMode |= TX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+                }
+                break;
+
+            case T3_BLOCK_MEM_ARBITOR:
+                data = REG_RD(pDevice, MemArbiter.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~T3_MEM_ARBITER_MODE_ENABLE;
+                    REG_WR(pDevice, MemArbiter.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MemArbiter.Mode) & T3_MEM_ARBITER_MODE_ENABLE)) 
+                            break;
+                        MM_Wait(10);
+                    }       
+                }
+                else
+                    REG_WR(pDevice, MemArbiter.Mode,data|T3_MEM_ARBITER_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MBUF_MANAGER:
+                data = REG_RD(pDevice, BufMgr.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~BUFMGR_MODE_ENABLE;
+                    REG_WR(pDevice, BufMgr.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, BufMgr.Mode) & BUFMGR_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, BufMgr.Mode,data |  BUFMGR_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MAC_GLOBAL:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->MacMode &= ~(MAC_MODE_ENABLE_TDE |
+                        MAC_MODE_ENABLE_RDE |
+                        MAC_MODE_ENABLE_FHDE);
+                }
+                else
+                {
+                    pDevice->MacMode |= (MAC_MODE_ENABLE_TDE |
+                        MAC_MODE_ENABLE_RDE |
+                        MAC_MODE_ENABLE_FHDE);
+                }
+                REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+                break;
+
+            default:
+                return LM_STATUS_FAILURE;
+        } /* switch */
+
+        if(j >= MaxWaitCnt) 
+        {
+            return LM_STATUS_FAILURE;
+        }
+    } 
+
+    return LM_STATUS_SUCCESS;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This function reinitializes the adapter.                                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_ResetAdapter(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j, k;
+
+    /* Disable interrupt. */
+    LM_DisableInterrupt(pDevice);
+
+    /* May get a spurious interrupt */
+    pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED;
+
+    /* Disable transmit and receive DMA engines.  Abort all pending requests. */
+    if(pDevice->InitDone)
+    {
+        LM_Abort(pDevice);
+    }
+
+    pDevice->ShuttingDown = FALSE;
+
+    LM_ResetChip(pDevice);
+
+    /* Bug: Athlon fix for B3 silicon only.  This bit does not do anything */
+    /* in other chip revisions. */
+    if(pDevice->DelayPciGrant)
+    {
+        Value32 = REG_RD(pDevice, PciCfg.ClockCtrl);
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32 | BIT_31);
+    }
+
+    /* Enable TaggedStatus mode. */
+    if(pDevice->UseTaggedStatus)
+    {
+        pDevice->MiscHostCtrl |= MISC_HOST_CTRL_ENABLE_TAGGED_STATUS_MODE;
+    }
+
+    /* Restore PCI configuration registers. */
+    MM_WriteConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG,
+        pDevice->SavedCacheLineReg);
+//    LM_RegWrInd(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+//        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+    MM_WriteConfig32(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+
+    /* Clear the statistics block. */
+    for(j = 0x0300; j < 0x0b00; j++)
+    {
+        MEM_WR_OFFSET(pDevice, j, 0);
+    }
+
+    /* Initialize the statistis Block */
+    pDevice->pStatusBlkVirt->Status = 0;
+    pDevice->pStatusBlkVirt->RcvStdConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvJumboConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvMiniConIdx = 0;
+
+    for(j = 0; j < 16; j++)
+    {
+       pDevice->pStatusBlkVirt->Idx[j].RcvProdIdx = 0;
+       pDevice->pStatusBlkVirt->Idx[j].SendConIdx = 0;
+    }
+
+    for(k = 0; k < T3_STD_RCV_RCB_ENTRY_COUNT ;k++)
+    {
+       pDevice->pRxStdBdVirt[k].HostAddr.High = 0;
+       pDevice->pRxStdBdVirt[k].HostAddr.Low = 0;
+    }
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Receive jumbo BD buffer. */
+    for(k = 0; k < T3_JUMBO_RCV_RCB_ENTRY_COUNT; k++)
+    {
+        pDevice->pRxJumboBdVirt[k].HostAddr.High = 0;
+        pDevice->pRxJumboBdVirt[k].HostAddr.Low = 0;
+    }
+#endif
+
+    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl, pDevice->DmaReadWriteCtrl);    
+
+    /* GRC mode control register. */
+    Value32 = 
+#ifdef BIG_ENDIAN_HOST
+        GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+        GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+        GRC_MODE_BYTE_SWAP_DATA |
+        GRC_MODE_WORD_SWAP_DATA |
+#else
+        GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+        GRC_MODE_BYTE_SWAP_DATA |
+        GRC_MODE_WORD_SWAP_DATA |
+#endif
+        GRC_MODE_INT_ON_MAC_ATTN |
+        GRC_MODE_HOST_STACK_UP;
+
+    /* Configure send BD mode. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        Value32 |= GRC_MODE_HOST_SEND_BDS;
+    }
+    else
+    {
+        Value32 |= GRC_MODE_4X_NIC_BASED_SEND_RINGS;
+    }
+
+    /* Configure pseudo checksum mode. */
+    if(pDevice->NoTxPseudoHdrChksum)
+    {
+        Value32 |= GRC_MODE_TX_NO_PSEUDO_HEADER_CHKSUM;
+    }
+
+    if(pDevice->NoRxPseudoHdrChksum)
+    {
+        Value32 |= GRC_MODE_RX_NO_PSEUDO_HEADER_CHKSUM;
+    }
+
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    /* Setup the timer prescalar register. */
+    REG_WR(pDevice, Grc.MiscCfg, 65 << 1);      /* Clock is alwasy 66Mhz. */
+
+    /* Set up the MBUF pool base address and size. */
+    REG_WR(pDevice, BufMgr.MbufPoolAddr, pDevice->MbufBase);
+    REG_WR(pDevice, BufMgr.MbufPoolSize, pDevice->MbufSize);
+
+    /* Set up the DMA descriptor pool base address and size. */
+    REG_WR(pDevice, BufMgr.DmaDescPoolAddr, T3_NIC_DMA_DESC_POOL_ADDR);
+    REG_WR(pDevice, BufMgr.DmaDescPoolSize, T3_NIC_DMA_DESC_POOL_SIZE);
+    
+    /* Configure MBUF and Threshold watermarks */
+    /* Configure the DMA read MBUF low water mark. */
+    if(pDevice->DmaMbufLowMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark, 
+            pDevice->DmaMbufLowMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark,
+                T3_DEF_DMA_MBUF_LOW_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark,
+                T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO);
+        }
+    }
+
+    /* Configure the MAC Rx MBUF low water mark. */
+    if(pDevice->RxMacMbufLowMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+            pDevice->RxMacMbufLowMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+                T3_DEF_RX_MAC_MBUF_LOW_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+                T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO);
+        }
+    }
+
+    /* Configure the MBUF high water mark. */
+    if(pDevice->MbufHighMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufHighWaterMark, pDevice->MbufHighMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufHighWaterMark,
+                T3_DEF_MBUF_HIGH_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufHighWaterMark,
+                T3_DEF_MBUF_HIGH_WMARK_JUMBO);
+        }
+    }
+
+    REG_WR(pDevice, BufMgr.DmaLowWaterMark, T3_DEF_DMA_DESC_LOW_WMARK);
+    REG_WR(pDevice, BufMgr.DmaHighWaterMark, T3_DEF_DMA_DESC_HIGH_WMARK);
+
+    /* Enable buffer manager. */
+    REG_WR(pDevice, BufMgr.Mode, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE);
+
+    for(j = 0 ;j < 2000; j++)
+    {
+        if(REG_RD(pDevice, BufMgr.Mode) & BUFMGR_MODE_ENABLE)
+            break;
+        MM_Wait(10);
+    }
+
+    if(j >= 2000)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Enable the FTQs. */
+    REG_WR(pDevice, Ftq.Reset, 0xffffffff);
+    REG_WR(pDevice, Ftq.Reset, 0);
+
+    /* Wait until FTQ is ready */
+    for(j = 0; j < 2000; j++)
+    {
+        if(REG_RD(pDevice, Ftq.Reset) == 0)
+            break;
+        MM_Wait(10);
+    }
+
+    if(j >= 2000)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Initialize the Standard Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.HostRingAddr.High, 
+        pDevice->RxStdBdPhy.High);
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.HostRingAddr.Low, 
+        pDevice->RxStdBdPhy.Low);
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.u.MaxLen_Flags,
+        MAX_STD_RCV_BUFFER_SIZE << 16);
+
+    /* Initialize the Jumbo Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.u.MaxLen_Flags,
+        T3_RCB_FLAG_RING_DISABLED);
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.HostRingAddr.High, 
+        pDevice->RxJumboBdPhy.High);
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.HostRingAddr.Low, 
+        pDevice->RxJumboBdPhy.Low);
+
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.u.MaxLen_Flags, 0);
+
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Initialize the Mini Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.MiniRcvRcb.u.MaxLen_Flags,
+        T3_RCB_FLAG_RING_DISABLED);
+
+    {
+        REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.NicRingAddr,
+            (LM_UINT32) T3_NIC_STD_RCV_BUFFER_DESC_ADDR);
+        REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.NicRingAddr,
+            (LM_UINT32) T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR);
+    }
+
+    /* Receive BD Ring replenish threshold. */
+    REG_WR(pDevice, RcvBdIn.StdRcvThreshold, pDevice->RxStdDescCnt/8);
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    REG_WR(pDevice, RcvBdIn.JumboRcvThreshold, pDevice->RxJumboDescCnt/8);
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Disable all the unused rings. */
+    for(j = 0; j < T3_MAX_SEND_RCB_COUNT; j++) {
+        MEM_WR(pDevice, SendRcb[j].u.MaxLen_Flags, T3_RCB_FLAG_RING_DISABLED);
+    } /* for */
+
+    /* Initialize the indices. */
+    pDevice->SendProdIdx = 0;
+    pDevice->SendConIdx = 0;
+
+    REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, 0); 
+    REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, 0);
+
+    /* Set up host or NIC based send RCB. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.High, 
+            pDevice->SendBdPhy.High);
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.Low, 
+            pDevice->SendBdPhy.Low);
+
+        /* Set up the NIC ring address in the RCB. */
+        MEM_WR(pDevice, SendRcb[0].NicRingAddr,T3_NIC_SND_BUFFER_DESC_ADDR);
+
+        /* Setup the RCB. */
+        MEM_WR(pDevice, SendRcb[0].u.MaxLen_Flags,
+            T3_SEND_RCB_ENTRY_COUNT << 16);
+
+        for(k = 0; k < T3_SEND_RCB_ENTRY_COUNT; k++)
+        {
+            pDevice->pSendBdVirt[k].HostAddr.High = 0;
+            pDevice->pSendBdVirt[k].HostAddr.Low = 0;
+        }
+    }
+    else
+    {
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.High, 0);
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.Low, 0);
+        MEM_WR(pDevice, SendRcb[0].NicRingAddr,
+            pDevice->SendBdPhy.Low);
+
+        for(k = 0; k < T3_SEND_RCB_ENTRY_COUNT; k++)
+        {
+            __raw_writel(0, &(pDevice->pSendBdVirt[k].HostAddr.High));
+            __raw_writel(0, &(pDevice->pSendBdVirt[k].HostAddr.Low));
+            __raw_writel(0, &(pDevice->pSendBdVirt[k].u1.Len_Flags));
+            pDevice->ShadowSendBd[k].HostAddr.High = 0;
+            pDevice->ShadowSendBd[k].u1.Len_Flags = 0;
+        }
+    }
+    atomic_set(&pDevice->SendBdLeft, T3_SEND_RCB_ENTRY_COUNT-1);
+
+    /* Configure the receive return rings. */
+    for(j = 0; j < T3_MAX_RCV_RETURN_RCB_COUNT; j++)
+    {
+        MEM_WR(pDevice, RcvRetRcb[j].u.MaxLen_Flags, T3_RCB_FLAG_RING_DISABLED);
+    }
+
+    pDevice->RcvRetConIdx = 0;
+
+    MEM_WR(pDevice, RcvRetRcb[0].HostRingAddr.High, 
+        pDevice->RcvRetBdPhy.High);
+    MEM_WR(pDevice, RcvRetRcb[0].HostRingAddr.Low,
+        pDevice->RcvRetBdPhy.Low);
+
+    /* Set up the NIC ring address in the RCB. */
+    /* Not very clear from the spec.  I am guessing that for Receive */
+    /* Return Ring, NicRingAddr is not used. */
+    MEM_WR(pDevice, RcvRetRcb[0].NicRingAddr, 0);
+
+    /* Setup the RCB. */
+    MEM_WR(pDevice, RcvRetRcb[0].u.MaxLen_Flags,
+        T3_RCV_RETURN_RCB_ENTRY_COUNT << 16);
+
+    /* Reinitialize RX ring producer index */
+    REG_WR(pDevice, Mailbox.RcvStdProdIdx.Low, 0);
+    REG_WR(pDevice, Mailbox.RcvJumboProdIdx.Low, 0);
+    REG_WR(pDevice, Mailbox.RcvMiniProdIdx.Low, 0);
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    pDevice->RxJumboProdIdx = 0;
+    pDevice->RxJumboQueuedCnt = 0;
+#endif
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxStdProdIdx = 0;
+    pDevice->RxStdQueuedCnt = 0;
+
+#if T3_JUMBO_RCV_ENTRY_COUNT
+    pDevice->RxJumboProdIdx = 0;
+#endif /* T3_JUMBO_RCV_ENTRY_COUNT */
+
+    /* Configure the MAC address. */
+    LM_SetMacAddress(pDevice, pDevice->NodeAddress);
+
+    /* Initialize the transmit random backoff seed. */
+    Value32 = (pDevice->NodeAddress[0] + pDevice->NodeAddress[1] + 
+        pDevice->NodeAddress[2] + pDevice->NodeAddress[3] + 
+        pDevice->NodeAddress[4] + pDevice->NodeAddress[5]) & 
+        MAC_TX_BACKOFF_SEED_MASK;
+    REG_WR(pDevice, MacCtrl.TxBackoffSeed, Value32);
+
+    /* Receive MTU.  Frames larger than the MTU is marked as oversized. */
+    REG_WR(pDevice, MacCtrl.MtuSize, pDevice->RxMtu + 8);   /* CRC + VLAN. */
+
+    /* Configure Time slot/IPG per 802.3 */
+    REG_WR(pDevice, MacCtrl.TxLengths, 0x2620);
+
+    /*
+     * Configure Receive Rules so that packets don't match 
+     * Programmble rule will be queued to Return Ring 1 
+     */
+    REG_WR(pDevice, MacCtrl.RcvRuleCfg, RX_RULE_DEFAULT_CLASS);
+
+    /* 
+     * Configure to have 16 Classes of Services (COS) and one
+     * queue per class.  Bad frames are queued to RRR#1.
+     * And frames don't match rules are also queued to COS#1.
+     */
+    REG_WR(pDevice, RcvListPlmt.Config, 0x181);
+    
+    /* Enable Receive Placement Statistics */
+    REG_WR(pDevice, RcvListPlmt.StatsEnableMask,0xffffff);
+    REG_WR(pDevice, RcvListPlmt.StatsCtrl, RCV_LIST_STATS_ENABLE);
+
+    /* Enable Send Data Initator Statistics */
+    REG_WR(pDevice, SndDataIn.StatsEnableMask,0xffffff);
+    REG_WR(pDevice, SndDataIn.StatsCtrl,
+        T3_SND_DATA_IN_STATS_CTRL_ENABLE | \
+        T3_SND_DATA_IN_STATS_CTRL_FASTER_UPDATE);
+
+    /* Disable the host coalescing state machine before configuring it's */
+    /* parameters. */
+    REG_WR(pDevice, HostCoalesce.Mode, 0); 
+    for(j = 0; j < 2000; j++)
+    {
+        Value32 = REG_RD(pDevice, HostCoalesce.Mode);
+        if(!(Value32 & HOST_COALESCE_ENABLE))
+        {
+            break;
+        }
+        MM_Wait(10);
+    }
+
+    /* Host coalescing configurations. */
+    REG_WR(pDevice, HostCoalesce.RxCoalescingTicks, pDevice->RxCoalescingTicks);
+    REG_WR(pDevice, HostCoalesce.TxCoalescingTicks, pDevice->TxCoalescingTicks);
+    REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+        pDevice->RxMaxCoalescedFrames);
+    REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFrames,
+        pDevice->TxMaxCoalescedFrames);
+    REG_WR(pDevice, HostCoalesce.RxCoalescedTickDuringInt,
+        pDevice->RxCoalescingTicksDuringInt);
+    REG_WR(pDevice, HostCoalesce.TxCoalescedTickDuringInt,
+        pDevice->TxCoalescingTicksDuringInt);
+    REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFramesDuringInt,
+        pDevice->RxMaxCoalescedFramesDuringInt);
+    REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFramesDuringInt,
+        pDevice->TxMaxCoalescedFramesDuringInt);
+
+    /* Initialize the address of the status block.  The NIC will DMA */
+    /* the status block to this memory which resides on the host. */
+    REG_WR(pDevice, HostCoalesce.StatusBlkHostAddr.High, 
+        pDevice->StatusBlkPhy.High);
+    REG_WR(pDevice, HostCoalesce.StatusBlkHostAddr.Low,
+        pDevice->StatusBlkPhy.Low);
+
+    /* Initialize the address of the statistics block.  The NIC will DMA */
+    /* the statistics to this block of memory. */
+    REG_WR(pDevice, HostCoalesce.StatsBlkHostAddr.High, 
+        pDevice->StatsBlkPhy.High);
+    REG_WR(pDevice, HostCoalesce.StatsBlkHostAddr.Low,
+        pDevice->StatsBlkPhy.Low);
+
+    REG_WR(pDevice, HostCoalesce.StatsCoalescingTicks,
+        pDevice->StatsCoalescingTicks);
+
+    REG_WR(pDevice, HostCoalesce.StatsBlkNicAddr, 0x300);
+    REG_WR(pDevice, HostCoalesce.StatusBlkNicAddr,0xb00);
+
+    /* Enable Host Coalesing state machine */
+    REG_WR(pDevice, HostCoalesce.Mode, HOST_COALESCE_ENABLE |
+        pDevice->CoalesceMode);
+
+    /* Enable the Receive BD Completion state machine. */
+    REG_WR(pDevice, RcvBdComp.Mode, RCV_BD_COMP_MODE_ENABLE |
+        RCV_BD_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Receive List Placement state machine. */
+    REG_WR(pDevice, RcvListPlmt.Mode, RCV_LIST_PLMT_MODE_ENABLE);
+
+    /* Enable the Receive List Selector state machine. */
+    REG_WR(pDevice, RcvListSel.Mode, RCV_LIST_SEL_MODE_ENABLE |
+        RCV_LIST_SEL_MODE_ATTN_ENABLE);
+
+    /* Enable transmit DMA, clear statistics. */
+    pDevice->MacMode =  MAC_MODE_ENABLE_TX_STATISTICS |
+        MAC_MODE_ENABLE_RX_STATISTICS | MAC_MODE_ENABLE_TDE |
+        MAC_MODE_ENABLE_RDE | MAC_MODE_ENABLE_FHDE;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+        MAC_MODE_CLEAR_RX_STATISTICS | MAC_MODE_CLEAR_TX_STATISTICS);
+
+    /* GRC miscellaneous local control register. */
+    pDevice->GrcLocalCtrl = GRC_MISC_LOCAL_CTRL_INT_ON_ATTN |
+        GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM;
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        pDevice->GrcLocalCtrl |= GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+            GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1;
+    }
+
+    REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl);
+    MM_Wait(40);
+
+    /* Reset RX counters. */
+    for(j = 0; j < sizeof(LM_RX_COUNTERS); j++)
+    {
+        ((PLM_UINT8) &pDevice->RxCounters)[j] = 0;
+    }
+
+    /* Reset TX counters. */
+    for(j = 0; j < sizeof(LM_TX_COUNTERS); j++)
+    {
+        ((PLM_UINT8) &pDevice->TxCounters)[j] = 0;
+    }
+
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+
+    /* Enable the DMA Completion state machine. */
+    REG_WR(pDevice, DmaComp.Mode, DMA_COMP_MODE_ENABLE);
+
+    /* Enable the DMA Write state machine. */
+    Value32 = DMA_WRITE_MODE_ENABLE |
+        DMA_WRITE_MODE_TARGET_ABORT_ATTN_ENABLE |
+        DMA_WRITE_MODE_MASTER_ABORT_ATTN_ENABLE |
+        DMA_WRITE_MODE_PARITY_ERROR_ATTN_ENABLE |
+        DMA_WRITE_MODE_ADDR_OVERFLOW_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_OVERRUN_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_UNDERRUN_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_OVERREAD_ATTN_ENABLE |
+        DMA_WRITE_MODE_LONG_READ_ATTN_ENABLE;
+    REG_WR(pDevice, DmaWrite.Mode, Value32);
+
+    /* Enable the Read DMA state machine. */
+    Value32 = DMA_READ_MODE_ENABLE |
+        DMA_READ_MODE_TARGET_ABORT_ATTN_ENABLE |
+        DMA_READ_MODE_MASTER_ABORT_ATTN_ENABLE |
+        DMA_READ_MODE_PARITY_ERROR_ATTN_ENABLE |
+        DMA_READ_MODE_ADDR_OVERFLOW_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_OVERRUN_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_UNDERRUN_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_OVERREAD_ATTN_ENABLE |
+        DMA_READ_MODE_LONG_READ_ATTN_ENABLE;
+    REG_WR(pDevice, DmaRead.Mode, Value32);
+
+    /* Enable the Receive Data Completion state machine. */
+    REG_WR(pDevice, RcvDataComp.Mode, RCV_DATA_COMP_MODE_ENABLE |
+        RCV_DATA_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Mbuf Cluster Free state machine. */
+    REG_WR(pDevice, MbufClusterFree.Mode, MBUF_CLUSTER_FREE_MODE_ENABLE);
+
+    /* Enable the Send Data Completion state machine. */
+    REG_WR(pDevice, SndDataComp.Mode, SND_DATA_COMP_MODE_ENABLE);
+
+    /* Enable the Send BD Completion state machine. */
+    REG_WR(pDevice, SndBdComp.Mode, SND_BD_COMP_MODE_ENABLE |
+        SND_BD_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Receive BD Initiator state machine. */
+    REG_WR(pDevice, RcvBdIn.Mode, RCV_BD_IN_MODE_ENABLE |
+        RCV_BD_IN_MODE_BD_IN_DIABLED_RCB_ATTN_ENABLE);
+
+    /* Enable the Receive Data and Receive BD Initiator state machine. */
+    REG_WR(pDevice, RcvDataBdIn.Mode, RCV_DATA_BD_IN_MODE_ENABLE |
+        RCV_DATA_BD_IN_MODE_INVALID_RING_SIZE);
+
+    /* Enable the Send Data Initiator state machine. */
+    REG_WR(pDevice, SndDataIn.Mode, T3_SND_DATA_IN_MODE_ENABLE);
+
+    /* Enable the Send BD Initiator state machine. */
+    REG_WR(pDevice, SndBdIn.Mode, SND_BD_IN_MODE_ENABLE |
+        SND_BD_IN_MODE_ATTN_ENABLE);
+
+    /* Enable the Send BD Selector state machine. */
+    REG_WR(pDevice, SndBdSel.Mode, SND_BD_SEL_MODE_ENABLE |
+        SND_BD_SEL_MODE_ATTN_ENABLE);
+
+#if INCLUDE_5701_AX_FIX
+    /* Load the firmware for the 5701_A0 workaround. */
+    if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0)
+    {
+        LM_LoadRlsFirmware(pDevice);
+    }
+#endif
+
+    /* Enable the transmitter. */
+    pDevice->TxMode = TX_MODE_ENABLE;
+    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+    
+    /* Enable the receiver. */
+    pDevice->RxMode = RX_MODE_ENABLE;
+    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+
+    if (pDevice->RestoreOnWakeUp)
+    {
+        pDevice->RestoreOnWakeUp = FALSE;
+        pDevice->DisableAutoNeg = pDevice->WakeUpDisableAutoNeg;
+        pDevice->RequestedMediaType = pDevice->WakeUpRequestedMediaType;
+    }
+
+    /* Disable auto polling. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+        T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+    {
+        Value32 = LED_CTRL_PHY_MODE_1;
+    }
+    else
+    {
+        if(pDevice->LedMode == LED_MODE_OUTPUT)
+        {
+            Value32 = LED_CTRL_PHY_MODE_2;
+        }
+        else
+        {
+            Value32 = LED_CTRL_PHY_MODE_1;
+        }
+    }
+    REG_WR(pDevice, MacCtrl.LedCtrl, Value32);
+    
+    /* Activate Link to enable MAC state machine */
+    REG_WR(pDevice, MacCtrl.MiStatus, MI_STATUS_ENABLE_LINK_STATUS_ATTN);
+
+    if (pDevice->EnableTbi)
+    {
+        REG_WR(pDevice, MacCtrl.RxMode, RX_MODE_RESET);
+        MM_Wait(10);
+        REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+        if (pDevice->ChipRevId == T3_CHIP_ID_5703_A1)
+        {
+            REG_WR(pDevice, MacCtrl.SerdesCfg, 0x616000);
+        }
+    }
+    /* Setup the phy chip. */
+    LM_SetupPhy(pDevice);
+
+    if (!pDevice->EnableTbi) {
+        /* Clear CRC stats */
+        LM_ReadPhy(pDevice, 0x1e, &Value32);
+        LM_WritePhy(pDevice, 0x1e, Value32 | 0x8000);
+        LM_ReadPhy(pDevice, 0x14, &Value32);
+    }
+
+    /* Set up the receive mask. */
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask);
+
+    /* Queue Rx packet buffers. */
+    if(pDevice->QueueRxPackets)
+    {
+        LM_QueueRxPackets(pDevice);
+    }
+
+    /* Enable interrupt to the host. */
+    if(pDevice->InitDone)
+    {
+        LM_EnableInterrupt(pDevice);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_ResetAdapter */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine disables the adapter from generating interrupts.           */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_DisableInterrupt(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl | 
+        MISC_HOST_CTRL_MASK_PCI_INT);
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine enables the adapter to generate interrupts.                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_EnableInterrupt(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl &
+        ~MISC_HOST_CTRL_MASK_PCI_INT);
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+
+    if(pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED)
+    {
+        REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+            GRC_MISC_LOCAL_CTRL_SET_INT);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine puts a packet on the wire if there is a transmit DMA       */
+/*    descriptor available; otherwise the packet is queued for later          */
+/*    transmission.  If the second argue is NULL, this routine will put       */
+/*    the queued packet on the wire if possible.                              */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_SendPacket(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+    LM_UINT32 FragCount;
+    PT3_SND_BD pSendBd;
+    PT3_SND_BD pShadowSendBd;
+    LM_UINT32 Value32;
+    LM_UINT32 Idx;
+
+    /* Update the SendBdLeft count. */
+    atomic_sub(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+    /* Initalize the send buffer descriptors. */
+    Idx = pDevice->SendProdIdx;
+
+    pSendBd = &pDevice->pSendBdVirt[Idx];
+
+    /* Next producer index. */
+    if (pDevice->NicSendBd == TRUE)
+    {
+        pShadowSendBd = &pDevice->ShadowSendBd[Idx];
+        for(FragCount = 0; ; )
+        {
+            /* Initialize the pointer to the send buffer fragment. */
+            Value32 =
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.High;
+            if (Value32 != pShadowSendBd->HostAddr.High)
+            {
+                __raw_writel(Value32, &(pSendBd->HostAddr.High));
+                pShadowSendBd->HostAddr.High = Value32;
+            }
+            __raw_writel(pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.Low,
+                &(pSendBd->HostAddr.Low));
+
+            /* Setup the control flags and send buffer size. */
+            Value32 = (pPacket->u.Tx.pFraglist->Fragments[FragCount].
+                FragSize << 16) | pPacket->Flags;
+
+            Idx = (Idx + 1) & T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+            FragCount++;
+            if (FragCount >= pPacket->u.Tx.FragCount)
+            {
+                Value32 |= SND_BD_FLAG_END;
+                if (Value32 != pShadowSendBd->u1.Len_Flags)
+                {
+                    __raw_writel(Value32, &(pSendBd->u1.Len_Flags));
+                    pShadowSendBd->u1.Len_Flags = Value32;
+                }
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG) {
+                    __raw_writel(pPacket->VlanTag, &(pSendBd->u2.VlanTag));
+                }
+                break;
+            }
+            else
+            {
+                if (Value32 != pShadowSendBd->u1.Len_Flags)
+                {
+                    __raw_writel(Value32, &(pSendBd->u1.Len_Flags));
+                    pShadowSendBd->u1.Len_Flags = Value32;
+                }
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG) {
+                    __raw_writel(pPacket->VlanTag, &(pSendBd->u2.VlanTag));
+                }
+            }
+
+            pSendBd++;
+            pShadowSendBd++;
+            if (Idx == 0)
+            {
+                pSendBd = &pDevice->pSendBdVirt[0];
+                pShadowSendBd = &pDevice->ShadowSendBd[0];
+            }
+        } /* for */
+
+        /* Put the packet descriptor in the ActiveQ. */
+        QQ_PushTail(&pDevice->TxPacketActiveQ.Container, pPacket);
+
+        wmb();
+        RAW_REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, Idx);
+
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            RAW_REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, Idx);
+        }
+    }
+    else
+    {
+        for(FragCount = 0; ; )
+        {
+            /* Initialize the pointer to the send buffer fragment. */
+            pSendBd->HostAddr.High = 
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.High;
+            pSendBd->HostAddr.Low = 
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.Low;
+
+            /* Setup the control flags and send buffer size. */
+            Value32 = (pPacket->u.Tx.pFraglist->Fragments[FragCount].
+                FragSize << 16) | pPacket->Flags;
+
+            Idx = (Idx + 1) & T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+            FragCount++;
+            if (FragCount >= pPacket->u.Tx.FragCount)
+            {
+                pSendBd->u1.Len_Flags = Value32 | SND_BD_FLAG_END;
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+                break;
+            }
+            else
+            {
+                pSendBd->u1.Len_Flags = Value32;
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+            }
+            pSendBd++;
+            if (Idx == 0)
+            {
+                pSendBd = &pDevice->pSendBdVirt[0];
+            }
+        } /* for */
+
+        /* Put the packet descriptor in the ActiveQ. */
+        QQ_PushTail(&pDevice->TxPacketActiveQ.Container, pPacket);
+
+        wmb();
+        RAW_REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, Idx);
+
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            RAW_REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, Idx);
+        }
+    }
+
+    /* Update the producer index. */
+    pDevice->SendProdIdx = Idx;
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned long
+ComputeCrc32(
+unsigned char *pBuffer,
+unsigned long BufferSize) {
+    unsigned long Reg;
+    unsigned long Tmp;
+    unsigned long j, k;
+
+    Reg = 0xffffffff;
+
+    for(j = 0; j < BufferSize; j++)
+    {
+        Reg ^= pBuffer[j];
+
+        for(k = 0; k < 8; k++)
+        {
+            Tmp = Reg & 0x01;
+
+            Reg >>= 1;
+
+            if(Tmp)
+            {
+                Reg ^= 0xedb88320;
+            }
+        }
+    }
+
+    return ~Reg;
+} /* ComputeCrc32 */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine sets the receive control register according to ReceiveMask */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_SetReceiveMask(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Mask) {
+    LM_UINT32 ReceiveMask;
+    LM_UINT32 RxMode;
+    LM_UINT32 j, k;
+
+    ReceiveMask = Mask;
+
+    RxMode = pDevice->RxMode;
+
+    if(Mask & LM_ACCEPT_UNICAST)
+    {
+        Mask &= ~LM_ACCEPT_UNICAST;
+    }
+
+    if(Mask & LM_ACCEPT_MULTICAST)
+    {
+        Mask &= ~LM_ACCEPT_MULTICAST;
+    }
+
+    if(Mask & LM_ACCEPT_ALL_MULTICAST)
+    {
+        Mask &= ~LM_ACCEPT_ALL_MULTICAST;
+    }
+
+    if(Mask & LM_ACCEPT_BROADCAST)
+    {
+        Mask &= ~LM_ACCEPT_BROADCAST;
+    }
+
+    RxMode &= ~RX_MODE_PROMISCUOUS_MODE;
+    if(Mask & LM_PROMISCUOUS_MODE)
+    {
+        RxMode |= RX_MODE_PROMISCUOUS_MODE;
+        Mask &= ~LM_PROMISCUOUS_MODE;
+    }
+
+    RxMode &= ~(RX_MODE_ACCEPT_RUNTS | RX_MODE_ACCEPT_OVERSIZED);
+    if(Mask & LM_ACCEPT_ERROR_PACKET)
+    {
+        RxMode |= RX_MODE_ACCEPT_RUNTS | RX_MODE_ACCEPT_OVERSIZED;
+        Mask &= ~LM_ACCEPT_ERROR_PACKET;
+    }
+
+    /* Make sure all the bits are valid before committing changes. */
+    if(Mask)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Commit the new filter. */
+    pDevice->RxMode = RxMode;
+    REG_WR(pDevice, MacCtrl.RxMode, RxMode);
+
+    pDevice->ReceiveMask = ReceiveMask;
+
+    /* Set up the MC hash table. */
+    if(ReceiveMask & LM_ACCEPT_ALL_MULTICAST)
+    {
+        for(k = 0; k < 4; k++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[k], 0xffffffff);
+        }
+    }
+    else if(ReceiveMask & LM_ACCEPT_MULTICAST)
+    {
+        LM_UINT32 HashReg[4];
+
+        HashReg[0] = 0; HashReg[1] = 0; HashReg[2] = 0; HashReg[3] = 0;
+        for(j = 0; j < pDevice->McEntryCount; j++)
+        {
+            LM_UINT32 RegIndex;
+            LM_UINT32 Bitpos;
+            LM_UINT32 Crc32;
+
+            Crc32 = ComputeCrc32(pDevice->McTable[j], ETHERNET_ADDRESS_SIZE);
+
+            /* The most significant 7 bits of the CRC32 (no inversion), */
+            /* are used to index into one of the possible 128 bit positions. */
+            Bitpos = ~Crc32 & 0x7f;
+
+            /* Hash register index. */
+            RegIndex = (Bitpos & 0x60) >> 5;
+
+            /* Bit to turn on within a hash register. */
+            Bitpos &= 0x1f;
+
+            /* Enable the multicast bit. */
+            HashReg[RegIndex] |= (1 << Bitpos);
+        }
+
+        /* REV_AX has problem with multicast filtering where it uses both */
+        /* DA and SA to perform hashing. */
+        for(k = 0; k < 4; k++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[k], HashReg[k]);
+        }
+    }
+    else
+    {
+        /* Reject all multicast frames. */
+        for(j = 0; j < 4; j++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[j], 0);
+        }
+    }
+
+    /* By default, Tigon3 will accept broadcast frames.  We need to setup */
+    if(ReceiveMask & LM_ACCEPT_BROADCAST)
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Rule,
+            REJECT_BROADCAST_RULE1_RULE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Value,
+            REJECT_BROADCAST_RULE1_VALUE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Rule,
+            REJECT_BROADCAST_RULE1_RULE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Value,
+            REJECT_BROADCAST_RULE1_VALUE & RCV_DISABLE_RULE_MASK);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Rule, 
+            REJECT_BROADCAST_RULE1_RULE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Value, 
+            REJECT_BROADCAST_RULE1_VALUE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Rule, 
+            REJECT_BROADCAST_RULE2_RULE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Value, 
+            REJECT_BROADCAST_RULE2_VALUE);
+    }
+
+    /* disable the rest of the rules. */
+    for(j = RCV_LAST_RULE_IDX; j < 16; j++)
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[j].Rule, 0);
+        REG_WR(pDevice, MacCtrl.RcvRules[j].Value, 0);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetReceiveMask */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Disable the interrupt and put the transmitter and receiver engines in   */
+/*    an idle state.  Also aborts all pending send requests and receive       */
+/*    buffers.                                                                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_Abort(
+PLM_DEVICE_BLOCK pDevice)
+{
+    PLM_PACKET pPacket;
+    LM_UINT Idx;
+
+    LM_DisableInterrupt(pDevice);
+
+    /* Disable all the state machines. */
+    LM_CntrlBlock(pDevice,T3_BLOCK_MAC_RX_ENGINE,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_BD_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_LIST_PLMT,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_LIST_SELECTOR,LM_DISABLE);  
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_DATA_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_DATA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_BD_COMP,LM_DISABLE);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_SELECTOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_DATA_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_RD,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_DATA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_COMP,LM_DISABLE);
+
+    /* Clear TDE bit */
+    pDevice->MacMode &= ~MAC_MODE_ENABLE_TDE;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_MAC_TX_ENGINE,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_HOST_COALESING,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_WR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_MBUF_CLUSTER_FREE,LM_DISABLE);
+
+    /* Reset all FTQs */
+    REG_WR(pDevice, Ftq.Reset, 0xffffffff);
+    REG_WR(pDevice, Ftq.Reset, 0x0);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_MBUF_MANAGER,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_MEM_ARBITOR,LM_DISABLE);
+
+    MM_ACQUIRE_INT_LOCK(pDevice);
+
+    /* Abort packets that have already queued to go out. */
+    pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->TxPacketActiveQ.Container);
+    while(pPacket)
+    {
+//        MM_CompleteTxDma(pDevice, pPacket);
+
+        pPacket->PacketStatus = LM_STATUS_TRANSMIT_ABORTED;
+        pDevice->TxCounters.TxPacketAbortedCnt++;
+
+        atomic_add(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+        QQ_PushTail(&pDevice->TxPacketXmittedQ.Container, pPacket);
+
+        pPacket = (PLM_PACKET) 
+            QQ_PopHead(&pDevice->TxPacketActiveQ.Container);
+    }
+
+    /* Cleanup the receive return rings. */
+    LM_ServiceRxInterrupt(pDevice);
+
+    /* Don't want to indicate rx packets in Ndis miniport shutdown context. */
+    /* Doing so may cause system crash. */
+    if(!pDevice->ShuttingDown)
+    {
+        /* Indicate packets to the protocol. */
+        MM_IndicateTxPackets(pDevice);
+
+        /* Indicate received packets to the protocols. */
+        MM_IndicateRxPackets(pDevice);
+    }
+    else
+    {
+        /* Move the receive packet descriptors in the ReceivedQ to the */
+        /* free queue. */
+        for(; ;)
+        {
+            pPacket = (PLM_PACKET) QQ_PopHead(
+                &pDevice->RxPacketReceivedQ.Container);
+            if(pPacket == NULL)
+            {
+                break;
+            }
+            QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+        }
+    }
+
+    /* Clean up the Std Receive Producer ring. */
+    Idx = pDevice->pStatusBlkVirt->RcvStdConIdx;
+
+    while(Idx != pDevice->RxStdProdIdx) {
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pDevice->pRxStdBdVirt[Idx].Opaque));
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        Idx = (Idx + 1) & T3_STD_RCV_RCB_ENTRY_COUNT_MASK;
+    } /* while */
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxStdProdIdx = 0;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Clean up the Jumbo Receive Producer ring. */
+    Idx = pDevice->pStatusBlkVirt->RcvJumboConIdx;
+
+    while(Idx != pDevice->RxJumboProdIdx) {
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pDevice->pRxJumboBdVirt[Idx].Opaque));
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        Idx = (Idx + 1) & T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK;
+    } /* while */
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxJumboProdIdx = 0;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    MM_RELEASE_INT_LOCK(pDevice);
+
+    /* Initialize the statistis Block */
+    pDevice->pStatusBlkVirt->Status = 0;
+    pDevice->pStatusBlkVirt->RcvStdConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvJumboConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvMiniConIdx = 0;
+
+    return LM_STATUS_SUCCESS;
+} /* LM_Abort */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Disable the interrupt and put the transmitter and receiver engines in   */
+/*    an idle state.  Aborts all pending send requests and receive buffers.   */
+/*    Also free all the receive buffers.                                      */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_Halt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    LM_UINT32 EntryCnt;
+
+    LM_Abort(pDevice);
+
+    /* Get the number of entries in the queue. */
+    EntryCnt = QQ_GetEntryCnt(&pDevice->RxPacketFreeQ.Container);
+
+    /* Make sure all the packets have been accounted for. */
+    for(EntryCnt = 0; EntryCnt < pDevice->RxPacketDescCnt; EntryCnt++)
+    {
+        pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+        if (pPacket == 0)
+            break;
+
+        MM_FreeRxBuffer(pDevice, pPacket);
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+    }
+
+    LM_ResetChip(pDevice);
+
+    /* Restore PCI configuration registers. */
+    MM_WriteConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG,
+        pDevice->SavedCacheLineReg);
+    LM_RegWrInd(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+
+    /* Reprogram the MAC address. */
+    LM_SetMacAddress(pDevice, pDevice->NodeAddress);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_Halt */
+
+
+STATIC LM_STATUS
+LM_ResetChip(PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    /* Wait for access to the nvram interface before resetting.  This is */
+    /* a workaround to prevent EEPROM corruption. */
+    if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+        T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5701)
+    {
+        /* Request access to the flash interface. */
+        REG_WR(pDevice, Nvram.SwArb, SW_ARB_REQ_SET1);
+
+        for(j = 0; j < 100000; j++)
+        {
+            Value32 = REG_RD(pDevice, Nvram.SwArb);
+            if(Value32 & SW_ARB_GNT1)
+            {
+                break;
+            }
+            MM_Wait(10);
+        }
+    }
+
+    /* Global reset. */
+    REG_WR(pDevice, Grc.MiscCfg, GRC_MISC_CFG_CORE_CLOCK_RESET);
+    MM_Wait(40); MM_Wait(40); MM_Wait(40);
+
+    /* make sure we re-enable indirect accesses */
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG,
+        pDevice->MiscHostCtrl);
+
+    /* Set MAX PCI retry to zero. */
+    MM_WriteConfig32(pDevice, T3_PCI_STATE_REG,
+        T3_PCI_STATE_PCI_ROM_ENABLE | T3_PCI_STATE_PCI_ROM_RETRY_ENABLE);
+
+    /* Restore PCI command register. */
+    MM_WriteConfig32(pDevice, PCI_COMMAND_REG,
+        pDevice->PciCommandStatusWords);
+
+    /* Disable PCI-X relaxed ordering bit. */
+    MM_ReadConfig32(pDevice, PCIX_CAP_REG, &Value32);
+    Value32 &= ~PCIX_ENABLE_RELAXED_ORDERING;
+    MM_WriteConfig32(pDevice, PCIX_CAP_REG, Value32);
+
+    /* Enable memory arbiter. */
+    REG_WR(pDevice, MemArbiter.Mode, T3_MEM_ARBITER_MODE_ENABLE);
+
+#ifdef BIG_ENDIAN_HOST
+    /* Reconfigure the mode register. */
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+              GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+              GRC_MODE_BYTE_SWAP_DATA |
+              GRC_MODE_WORD_SWAP_DATA;
+#else
+    /* Reconfigure the mode register. */
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | GRC_MODE_BYTE_SWAP_DATA;
+#endif
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    /* Prevent PXE from restarting. */
+    MEM_WR_OFFSET(pDevice, 0x0b50, T3_MAGIC_NUM);
+
+    if(pDevice->EnableTbi) {
+        pDevice->MacMode = MAC_MODE_PORT_MODE_TBI;
+        REG_WR(pDevice, MacCtrl.Mode, MAC_MODE_PORT_MODE_TBI);
+    }
+    else {
+        REG_WR(pDevice, MacCtrl.Mode, 0);
+    }
+
+    /* Wait for the firmware to finish initialization. */
+    for(j = 0; j < 100000; j++)
+    {
+        MM_Wait(10);
+
+        Value32 = MEM_RD_OFFSET(pDevice, 0x0b50);
+        if(Value32 == ~T3_MAGIC_NUM)
+        {
+            break;
+        }
+    }
+    return LM_STATUS_SUCCESS;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void
+LM_ServiceTxInterrupt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    LM_UINT32 HwConIdx;
+    LM_UINT32 SwConIdx;
+
+    HwConIdx = pDevice->pStatusBlkVirt->Idx[0].SendConIdx;
+
+    /* Get our copy of the consumer index.  The buffer descriptors */
+    /* that are in between the consumer indices are freed. */
+    SwConIdx = pDevice->SendConIdx;
+
+    /* Move the packets from the TxPacketActiveQ that are sent out to */
+    /* the TxPacketXmittedQ.  Packets that are sent use the */
+    /* descriptors that are between SwConIdx and HwConIdx. */
+    while(SwConIdx != HwConIdx)
+    {
+        /* Get the packet that was sent from the TxPacketActiveQ. */
+        pPacket = (PLM_PACKET) QQ_PopHead(
+            &pDevice->TxPacketActiveQ.Container);
+
+        /* Set the return status. */
+        pPacket->PacketStatus = LM_STATUS_SUCCESS;
+
+        /* Complete the transmit with a call to MM_CompleteTxDma. */
+//        MM_CompleteTxDma(pDevice, pPacket);
+
+        /* Put the packet in the TxPacketXmittedQ for indication later. */
+        QQ_PushTail(&pDevice->TxPacketXmittedQ.Container, pPacket);
+
+        /* Move to the next packet's BD. */
+        SwConIdx = (SwConIdx + pPacket->u.Tx.FragCount) & 
+            T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+        /* Update the number of unused BDs. */
+        atomic_add(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+        /* Get the new updated HwConIdx. */
+        HwConIdx = pDevice->pStatusBlkVirt->Idx[0].SendConIdx;
+    } /* while */
+
+    /* Save the new SwConIdx. */
+    pDevice->SendConIdx = SwConIdx;
+
+} /* LM_ServiceTxInterrupt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void
+LM_ServiceRxInterrupt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    PT3_RCV_BD pRcvBd;
+    LM_UINT32 HwRcvRetProdIdx;
+    LM_UINT32 SwRcvRetConIdx;
+
+    /* Loop thru the receive return rings for received packets. */
+    HwRcvRetProdIdx = pDevice->pStatusBlkVirt->Idx[0].RcvProdIdx;
+
+    SwRcvRetConIdx = pDevice->RcvRetConIdx;
+    while(SwRcvRetConIdx != HwRcvRetProdIdx)
+    {
+        pRcvBd = &pDevice->pRcvRetBdVirt[SwRcvRetConIdx];
+
+        /* Get the received packet descriptor. */
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pRcvBd->Opaque));
+
+        /* Check the error flag. */
+        if(pRcvBd->ErrorFlag &&
+            pRcvBd->ErrorFlag != RCV_BD_ERR_ODD_NIBBLED_RCVD_MII)
+        {
+            pPacket->PacketStatus = LM_STATUS_FAILURE;
+
+            pDevice->RxCounters.RxPacketErrCnt++;
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_BAD_CRC)
+            {
+                pDevice->RxCounters.RxErrCrcCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_COLL_DETECT)
+            {
+                pDevice->RxCounters.RxErrCollCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_LINK_LOST_DURING_PKT)
+            {
+                pDevice->RxCounters.RxErrLinkLostCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_PHY_DECODE_ERR)
+            {
+                pDevice->RxCounters.RxErrPhyDecodeCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_ODD_NIBBLED_RCVD_MII)
+            {
+                pDevice->RxCounters.RxErrOddNibbleCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_MAC_ABORT)
+            {
+                pDevice->RxCounters.RxErrMacAbortCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_LEN_LT_64)
+            {
+                pDevice->RxCounters.RxErrShortPacketCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_TRUNC_NO_RESOURCES)
+            {
+                pDevice->RxCounters.RxErrNoResourceCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_GIANT_FRAME_RCVD)
+            {
+                pDevice->RxCounters.RxErrLargePacketCnt++;
+            }
+        }
+        else
+        {
+            pPacket->PacketStatus = LM_STATUS_SUCCESS;
+            pPacket->PacketSize = pRcvBd->Len - 4;
+
+            pPacket->Flags = pRcvBd->Flags;
+            if(pRcvBd->Flags & RCV_BD_FLAG_VLAN_TAG)
+            {
+                pPacket->VlanTag = pRcvBd->VlanTag;
+            }
+
+            pPacket->u.Rx.TcpUdpChecksum = pRcvBd->TcpUdpCksum;
+        }
+
+        /* Put the packet descriptor containing the received packet */
+        /* buffer in the RxPacketReceivedQ for indication later. */
+        QQ_PushTail(&pDevice->RxPacketReceivedQ.Container, pPacket);
+
+        /* Go to the next buffer descriptor. */
+        SwRcvRetConIdx = (SwRcvRetConIdx + 1) &
+            T3_RCV_RETURN_RCB_ENTRY_COUNT_MASK;
+
+        /* Get the updated HwRcvRetProdIdx. */
+        HwRcvRetProdIdx = pDevice->pStatusBlkVirt->Idx[0].RcvProdIdx;
+    } /* while */
+
+    pDevice->RcvRetConIdx = SwRcvRetConIdx;
+
+    /* Update the receive return ring consumer index. */
+    RAW_REG_WR(pDevice, Mailbox.RcvRetConIdx[0].Low, SwRcvRetConIdx);
+} /* LM_ServiceRxInterrupt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This is the interrupt event handler routine. It acknowledges all        */
+/*    pending interrupts and process all pending events.                      */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_ServiceInterrupts(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    int ServicePhyInt = FALSE;
+
+    /* Setup the phy chip whenever the link status changes. */
+    if(pDevice->LinkChngMode == T3_LINK_CHNG_MODE_USE_STATUS_REG)
+    {
+        Value32 = REG_RD(pDevice, MacCtrl.Status);
+        if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+        {
+            if (Value32 & MAC_STATUS_MI_INTERRUPT)
+            {
+                ServicePhyInt = TRUE;
+            }
+        }
+        else if(Value32 & MAC_STATUS_LINK_STATE_CHANGED)
+        {
+            ServicePhyInt = TRUE;
+        }
+    }
+    else
+    {
+        if(pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_LINK_CHANGED_STATUS)
+        {
+            pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED |
+                (pDevice->pStatusBlkVirt->Status & ~STATUS_BLOCK_LINK_CHANGED_STATUS);
+            ServicePhyInt = TRUE;
+        }
+    }
+#if INCLUDE_TBI_SUPPORT
+    if (pDevice->IgnoreTbiLinkChange == TRUE)
+    {
+        ServicePhyInt = FALSE;
+    }
+#endif
+    if (ServicePhyInt == TRUE)
+    {
+        LM_SetupPhy(pDevice);
+    }
+
+    /* Service receive and transmit interrupts. */
+    LM_ServiceRxInterrupt(pDevice);
+    LM_ServiceTxInterrupt(pDevice);
+        
+    /* No spinlock for this queue since this routine is serialized. */
+    if(!QQ_Empty(&pDevice->RxPacketReceivedQ.Container))
+    {
+        /* Indicate receive packets. */
+        MM_IndicateRxPackets(pDevice);
+//        LM_QueueRxPackets(pDevice);
+    }
+
+    /* No spinlock for this queue since this routine is serialized. */
+    if(!QQ_Empty(&pDevice->TxPacketXmittedQ.Container))
+    {
+        MM_IndicateTxPackets(pDevice);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_ServiceInterrupts */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastAdd(
+PLM_DEVICE_BLOCK pDevice,
+PLM_UINT8 pMcAddress) {
+    PLM_UINT8 pEntry;
+    LM_UINT32 j;
+
+    pEntry = pDevice->McTable[0];
+    for(j = 0; j < pDevice->McEntryCount; j++)
+    {
+        if(IS_ETH_ADDRESS_EQUAL(pEntry, pMcAddress))
+        {
+            /* Found a match, increment the instance count. */
+            pEntry[LM_MC_INSTANCE_COUNT_INDEX] += 1;
+
+            return LM_STATUS_SUCCESS;
+        }
+
+        pEntry += LM_MC_ENTRY_SIZE;
+    }
+    
+    if(pDevice->McEntryCount >= LM_MAX_MC_TABLE_SIZE)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    pEntry = pDevice->McTable[pDevice->McEntryCount];
+
+    COPY_ETH_ADDRESS(pMcAddress, pEntry);
+    pEntry[LM_MC_INSTANCE_COUNT_INDEX] = 1;
+
+    pDevice->McEntryCount++;
+
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask | LM_ACCEPT_MULTICAST);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_MulticastAdd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastDel(
+PLM_DEVICE_BLOCK pDevice,
+PLM_UINT8 pMcAddress) {
+    PLM_UINT8 pEntry;
+    LM_UINT32 j;
+
+    pEntry = pDevice->McTable[0];
+    for(j = 0; j < pDevice->McEntryCount; j++)
+    {
+        if(IS_ETH_ADDRESS_EQUAL(pEntry, pMcAddress))
+        {
+            /* Found a match, decrement the instance count. */
+            pEntry[LM_MC_INSTANCE_COUNT_INDEX] -= 1;
+
+            /* No more instance left, remove the address from the table. */
+            /* Move the last entry in the table to the delete slot. */
+            if(pEntry[LM_MC_INSTANCE_COUNT_INDEX] == 0 &&
+                pDevice->McEntryCount > 1)
+            {
+
+                COPY_ETH_ADDRESS(
+                    pDevice->McTable[pDevice->McEntryCount-1], pEntry);
+                pEntry[LM_MC_INSTANCE_COUNT_INDEX] =
+                    pDevice->McTable[pDevice->McEntryCount-1]
+                    [LM_MC_INSTANCE_COUNT_INDEX];
+            }
+            pDevice->McEntryCount--;
+
+            /* Update the receive mask if the table is empty. */
+            if(pDevice->McEntryCount == 0)
+            {
+                LM_SetReceiveMask(pDevice, 
+                    pDevice->ReceiveMask & ~LM_ACCEPT_MULTICAST);
+            }
+
+            return LM_STATUS_SUCCESS;
+        }
+
+        pEntry += LM_MC_ENTRY_SIZE;
+    }
+
+    return LM_STATUS_FAILURE;
+} /* LM_MulticastDel */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastClear(
+PLM_DEVICE_BLOCK pDevice) {
+    pDevice->McEntryCount = 0;
+
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask & ~LM_ACCEPT_MULTICAST);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_MulticastClear */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetMacAddress(
+    PLM_DEVICE_BLOCK pDevice,
+    PLM_UINT8 pMacAddress)
+{
+    LM_UINT32 j;
+
+    for(j = 0; j < 4; j++)
+    {
+        REG_WR(pDevice, MacCtrl.MacAddr[j].High,
+            (pMacAddress[0] << 8) | pMacAddress[1]);
+        REG_WR(pDevice, MacCtrl.MacAddr[j].Low,
+            (pMacAddress[2] << 24) | (pMacAddress[3] << 16) |
+            (pMacAddress[4] << 8) | pMacAddress[5]);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Sets up the default line speed, and duplex modes based on the requested */
+/*    media type.                                                             */
+/*                                                                            */
+/* Return:                                                                    */
+/*    None.                                                                   */
+/******************************************************************************/
+static LM_STATUS
+LM_TranslateRequestedMediaType(
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+PLM_MEDIA_TYPE pMediaType,
+PLM_LINE_SPEED pLineSpeed,
+PLM_DUPLEX_MODE pDuplexMode) {
+    *pMediaType = LM_MEDIA_TYPE_AUTO;
+    *pLineSpeed = LM_LINE_SPEED_UNKNOWN;
+    *pDuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+
+    /* determine media type */
+    switch(RequestedMediaType) {
+        case LM_REQUESTED_MEDIA_TYPE_BNC:
+            *pMediaType = LM_MEDIA_TYPE_BNC;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_AUTO:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        default:
+            break;
+    } /* switch */
+
+    return LM_STATUS_SUCCESS;
+} /* LM_TranslateRequestedMediaType */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_LINK_ACTIVE                                                   */
+/*    LM_STATUS_LINK_DOWN                                                     */
+/******************************************************************************/
+static LM_STATUS
+LM_InitBcm540xPhy(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_LINE_SPEED CurrentLineSpeed;
+    LM_DUPLEX_MODE CurrentDuplexMode;
+    LM_STATUS CurrentLinkStatus;
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        if(!pDevice->InitDone)
+        {
+            Value32 = 0;
+        }
+
+        if(!(Value32 & PHY_STATUS_LINK_PASS))
+        {
+            LM_WritePhy(pDevice, BCM5401_AUX_CTRL,  0x0c20);
+
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+            for(j = 0; j < 1000; j++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+                if(Value32 & PHY_STATUS_LINK_PASS)
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+            if((pDevice->PhyId & PHY_ID_REV_MASK) == PHY_BCM5401_B0_REV)
+            {
+                if(!(Value32 & PHY_STATUS_LINK_PASS) &&
+                    (pDevice->OldLineSpeed == LM_LINE_SPEED_1000MBPS))
+                {
+                    LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_PHY_RESET);
+                    for(j = 0; j < 100; j++)
+                    {
+                        MM_Wait(10);
+
+                        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+                        if(!(Value32 & PHY_CTRL_PHY_RESET))
+                        {
+                            MM_Wait(40);
+                            break;
+                        }
+                    }
+
+                    LM_WritePhy(pDevice, BCM5401_AUX_CTRL,  0x0c20);
+
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+                }
+            }
+        }
+    }
+    else if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+    {
+        /* Bug: 5701 A0, B0 TX CRC workaround. */
+        LM_WritePhy(pDevice, 0x15, 0x0a75);
+        LM_WritePhy(pDevice, 0x1c, 0x8c68);
+        LM_WritePhy(pDevice, 0x1c, 0x8d68);
+        LM_WritePhy(pDevice, 0x1c, 0x8c68);
+    }
+
+    /* Acknowledge interrupts. */
+    LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+    LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+
+    /* Configure the interrupt mask. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+    {
+        LM_WritePhy(pDevice, BCM540X_INT_MASK_REG, ~BCM540X_INT_LINK_CHANGE);
+    }
+
+    /* Configure PHY led mode. */
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701 ||
+        (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700))
+    {
+        if(pDevice->LedMode == LED_MODE_THREE_LINK)
+        {
+            LM_WritePhy(pDevice, BCM540X_EXT_CTRL_REG, 
+                BCM540X_EXT_CTRL_LINK3_LED_MODE);
+        }
+        else
+        {
+            LM_WritePhy(pDevice, BCM540X_EXT_CTRL_REG, 0);
+        }
+    }
+
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Get current link and duplex mode. */
+    for(j = 0; j < 100; j++)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        if(Value32 & PHY_STATUS_LINK_PASS)
+        {
+            break;
+        }
+        MM_Wait(40);
+    }
+
+    if(Value32 & PHY_STATUS_LINK_PASS)
+    {
+
+        /* Determine the current line and duplex settings. */
+        LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+        for(j = 0; j < 2000; j++)
+        {
+            MM_Wait(10);
+
+            LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+            if(Value32)
+            {
+                break;
+            }
+        }
+
+        switch(Value32 & BCM540X_AUX_SPEED_MASK)
+        {
+            case BCM540X_AUX_10BASET_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_10MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_10BASET_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_10MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            case BCM540X_AUX_100BASETX_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_100MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_100BASETX_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_100MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            case BCM540X_AUX_100BASET_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_1000MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_100BASET_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_1000MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            default:
+
+                CurrentLineSpeed = LM_LINE_SPEED_UNKNOWN;
+                CurrentDuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+                break;
+        }
+
+        /* Make sure we are in auto-neg mode. */
+        for (j = 0; j < 200; j++)
+        {
+            LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+            if(Value32 && Value32 != 0x7fff)
+            {
+                break;
+            }
+
+            if(Value32 == 0 && pDevice->RequestedMediaType == 
+                LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS)
+            {
+                break;
+            }
+
+            MM_Wait(10);
+        }
+
+        /* Use the current line settings for "auto" mode. */
+        if(pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+            pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+        {
+            if(Value32 & PHY_CTRL_AUTO_NEG_ENABLE)
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+
+                /* We may be exiting low power mode and the link is in */
+                /* 10mb.  In this case, we need to restart autoneg. */
+                LM_ReadPhy(pDevice, BCM540X_1000BASET_CTRL_REG, &Value32);
+                pDevice->advertising1000 = Value32;
+                /* 5702FE supports 10/100Mb only. */
+                if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5703 ||
+                    pDevice->BondId != GRC_MISC_BD_ID_5702FE)
+                {
+                    if(!(Value32 & (BCM540X_AN_AD_1000BASET_HALF |
+                        BCM540X_AN_AD_1000BASET_FULL)))
+                    {
+                        CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+                    }
+                }
+            }
+            else
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+            }
+        }
+        else
+        {
+            /* Force line settings. */
+            /* Use the current setting if it matches the user's requested */
+            /* setting. */
+            LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+            if((pDevice->LineSpeed == CurrentLineSpeed) &&
+                (pDevice->DuplexMode == CurrentDuplexMode))
+            {
+                if ((pDevice->DisableAutoNeg &&
+                    !(Value32 & PHY_CTRL_AUTO_NEG_ENABLE)) ||
+                    (!pDevice->DisableAutoNeg &&
+                    (Value32 & PHY_CTRL_AUTO_NEG_ENABLE)))
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+                }
+                else
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+                } 
+            }
+            else
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+            } 
+        }
+
+        /* Save line settings. */
+        pDevice->LineSpeed = CurrentLineSpeed;
+        pDevice->DuplexMode = CurrentDuplexMode;
+        pDevice->MediaType = LM_MEDIA_TYPE_UTP;
+    }
+
+    return CurrentLinkStatus;
+} /* LM_InitBcm540xPhy */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetFlowControl(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 LocalPhyAd,
+    LM_UINT32 RemotePhyAd)
+{
+    LM_FLOW_CONTROL FlowCap;
+
+    /* Resolve flow control. */
+    FlowCap = LM_FLOW_CONTROL_NONE;
+
+    /* See Table 28B-3 of 802.3ab-1999 spec. */
+    if(pDevice->FlowControlCap & LM_FLOW_CONTROL_AUTO_PAUSE)
+    {
+        if(LocalPhyAd & PHY_AN_AD_PAUSE_CAPABLE)
+        {
+            if(LocalPhyAd & PHY_AN_AD_ASYM_PAUSE)
+            {
+                if(RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE)
+                {
+                    FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+                        LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+                else if(RemotePhyAd & PHY_LINK_PARTNER_ASYM_PAUSE)
+                {
+                    FlowCap = LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+            }
+            else
+            {
+                if(RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE)
+                {
+                    FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+                        LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+            }
+        }
+        else if(LocalPhyAd & PHY_AN_AD_ASYM_PAUSE)
+        {
+            if((RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE) &&
+                (RemotePhyAd & PHY_LINK_PARTNER_ASYM_PAUSE))
+            {
+                FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+            }
+        }
+    }
+    else
+    {
+        FlowCap = pDevice->FlowControlCap;
+    }
+
+    /* Enable/disable rx PAUSE. */
+    pDevice->RxMode &= ~RX_MODE_ENABLE_FLOW_CONTROL;
+    if(FlowCap & LM_FLOW_CONTROL_RECEIVE_PAUSE &&
+        (pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE ||
+        pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE))
+    {
+        pDevice->FlowControl |= LM_FLOW_CONTROL_RECEIVE_PAUSE;
+        pDevice->RxMode |= RX_MODE_ENABLE_FLOW_CONTROL;
+
+    }
+    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+
+    /* Enable/disable tx PAUSE. */
+    pDevice->TxMode &= ~TX_MODE_ENABLE_FLOW_CONTROL;
+    if(FlowCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE &&
+        (pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE ||
+        pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE))
+    {
+        pDevice->FlowControl |= LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+        pDevice->TxMode |= TX_MODE_ENABLE_FLOW_CONTROL;
+
+    }
+    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+#if INCLUDE_TBI_SUPPORT
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_InitBcm800xPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+
+    /* Reset the SERDES during init and when we have link. */
+    if(!pDevice->InitDone || Value32 & MAC_STATUS_PCS_SYNCED)
+    {
+        /* Set PLL lock range. */
+        LM_WritePhy(pDevice, 0x16, 0x8007);
+
+        /* Software reset. */
+        LM_WritePhy(pDevice, 0x00, 0x8000);
+
+        /* Wait for reset to complete. */
+        for(j = 0; j < 500; j++)
+        {
+            MM_Wait(10);
+        }
+
+#if DBG
+        /* Verify lock (if cable attached).  Should be 0x8001. */
+        LM_ReadPhy(pDevice, 0x10, &Value32);
+        DbgMessage(INFORM, ("FiberPhy 0x10 = 0x%x\n", Value32));
+#endif
+
+        /* Config mode; seletct PMA/Ch 1 regs. */
+        LM_WritePhy(pDevice, 0x10, 0x8411);
+
+        /* Enable auto-lock and comdet, select txclk for tx. */
+        LM_WritePhy(pDevice, 0x11, 0x0a10);
+
+        LM_WritePhy(pDevice, 0x18, 0x00a0);
+        LM_WritePhy(pDevice, 0x16, 0x41ff);
+
+        /* Assert and deassert POR. */
+        LM_WritePhy(pDevice, 0x13, 0x0400);
+        MM_Wait(40);
+        LM_WritePhy(pDevice, 0x13, 0x0000);
+
+        LM_WritePhy(pDevice, 0x11, 0x0a50);
+        MM_Wait(40);
+        LM_WritePhy(pDevice, 0x11, 0x0a10);
+
+        /* Delay for signal to stabilize. */
+        for(j = 0; j < 15000; j++)
+        {
+            MM_Wait(10);
+        }
+
+        /* Deselect the channel register so we can read the PHY id later. */
+        LM_WritePhy(pDevice, 0x10, 0x8011);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_SetupFiberPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS CurrentLinkStatus;
+    AUTONEG_STATUS AnStatus = 0;
+    LM_UINT32 Value32;
+    LM_UINT32 Cnt;
+    LM_UINT32 j, k;
+
+    pDevice->MacMode &= ~(MAC_MODE_HALF_DUPLEX | MAC_MODE_PORT_MODE_MASK);
+
+    /* Initialize the send_config register. */
+    REG_WR(pDevice, MacCtrl.TxAutoNeg, 0);
+
+    /* Enable TBI and full duplex mode. */
+    pDevice->MacMode |= MAC_MODE_PORT_MODE_TBI;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    /* Initialize the BCM8002 SERDES PHY. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM8002_PHY_ID:
+            LM_InitBcm800xPhy(pDevice);
+            break;
+
+        default:
+            break;
+    }
+
+    /* Enable link change interrupt. */
+    REG_WR(pDevice, MacCtrl.MacEvent, MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN);
+
+    /* Default to link down. */
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Get the link status. */
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if(Value32 & MAC_STATUS_PCS_SYNCED)
+    {
+        if((pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO) ||
+            (pDevice->DisableAutoNeg == FALSE))
+        {
+            /* auto-negotiation mode. */
+            /* Initialize the autoneg default capaiblities. */
+            AutonegInit(&pDevice->AnInfo);
+
+            /* Set the context pointer to point to the main device structure. */
+            pDevice->AnInfo.pContext = pDevice;
+
+            /* Setup flow control advertisement register. */
+            Value32 = GetPhyAdFlowCntrlSettings(pDevice);
+            if(Value32 & PHY_AN_AD_PAUSE_CAPABLE)
+            {
+                pDevice->AnInfo.mr_adv_sym_pause = 1;
+            }
+            else
+            {
+                pDevice->AnInfo.mr_adv_sym_pause = 0;
+            }
+
+            if(Value32 & PHY_AN_AD_ASYM_PAUSE)
+            {
+                pDevice->AnInfo.mr_adv_asym_pause = 1;
+            }
+            else
+            {
+                pDevice->AnInfo.mr_adv_asym_pause = 0;
+            }
+
+            /* Try to autoneg up to six times. */
+            if (pDevice->IgnoreTbiLinkChange)
+            {
+                Cnt = 1;
+            }
+            else
+            {
+                Cnt = 6;
+            }
+            for (j = 0; j < Cnt; j++)
+            {
+                REG_WR(pDevice, MacCtrl.TxAutoNeg, 0);
+
+                Value32 = pDevice->MacMode & ~MAC_MODE_PORT_MODE_MASK;
+                REG_WR(pDevice, MacCtrl.Mode, Value32);
+                MM_Wait(20);
+
+                REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+                    MAC_MODE_SEND_CONFIGS);
+
+                MM_Wait(20);
+
+                pDevice->AnInfo.State = AN_STATE_UNKNOWN;
+                pDevice->AnInfo.CurrentTime_us = 0;
+
+                REG_WR(pDevice, Grc.Timer, 0);
+                for(k = 0; (pDevice->AnInfo.CurrentTime_us < 75000) &&
+                    (k < 75000); k++)
+                {
+                    AnStatus = Autoneg8023z(&pDevice->AnInfo);
+
+                    if((AnStatus == AUTONEG_STATUS_DONE) || 
+                        (AnStatus == AUTONEG_STATUS_FAILED))
+                    {
+                        break;
+                    }
+
+                    pDevice->AnInfo.CurrentTime_us = REG_RD(pDevice, Grc.Timer);
+                
+                }
+                if((AnStatus == AUTONEG_STATUS_DONE) || 
+                    (AnStatus == AUTONEG_STATUS_FAILED))
+                {
+                    break;
+                }
+                if (j >= 1)
+                {
+                    if (!(REG_RD(pDevice, MacCtrl.Status) &
+                        MAC_STATUS_PCS_SYNCED)) {
+                        break;
+                    }
+                }
+            }
+
+            /* Stop sending configs. */
+            MM_AnTxIdle(&pDevice->AnInfo);
+
+            /* Resolve flow control settings. */
+            if((AnStatus == AUTONEG_STATUS_DONE) &&
+                pDevice->AnInfo.mr_an_complete && pDevice->AnInfo.mr_link_ok &&
+                pDevice->AnInfo.mr_lp_adv_full_duplex)
+                {
+                LM_UINT32 RemotePhyAd;
+                LM_UINT32 LocalPhyAd;
+
+                LocalPhyAd = 0;
+                if(pDevice->AnInfo.mr_adv_sym_pause)
+                {
+                    LocalPhyAd |= PHY_AN_AD_PAUSE_CAPABLE;
+                }
+
+                if(pDevice->AnInfo.mr_adv_asym_pause)
+                {
+                    LocalPhyAd |= PHY_AN_AD_ASYM_PAUSE;
+                }
+
+                RemotePhyAd = 0;
+                if(pDevice->AnInfo.mr_lp_adv_sym_pause)
+                {
+                    RemotePhyAd |= PHY_LINK_PARTNER_PAUSE_CAPABLE;
+                }
+
+                if(pDevice->AnInfo.mr_lp_adv_asym_pause)
+                {
+                    RemotePhyAd |= PHY_LINK_PARTNER_ASYM_PAUSE;
+                }
+
+                LM_SetFlowControl(pDevice, LocalPhyAd, RemotePhyAd);
+
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+            }
+            for (j = 0; j < 30; j++)
+            {
+                MM_Wait(20);
+                REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+                    MAC_STATUS_CFG_CHANGED);
+                MM_Wait(20);
+                if ((REG_RD(pDevice, MacCtrl.Status) &
+                    (MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED)) == 0)
+                    break;
+            }
+            if (pDevice->PollTbiLink)
+            {
+                Value32 = REG_RD(pDevice, MacCtrl.Status);
+                if (Value32 & MAC_STATUS_RECEIVING_CFG)
+                {
+                    pDevice->IgnoreTbiLinkChange = TRUE;
+                }
+                else
+                {
+                    pDevice->IgnoreTbiLinkChange = FALSE;
+                }
+            }
+            Value32 = REG_RD(pDevice, MacCtrl.Status);
+            if (CurrentLinkStatus == LM_STATUS_LINK_DOWN &&
+                 (Value32 & MAC_STATUS_PCS_SYNCED) &&
+                 ((Value32 & MAC_STATUS_RECEIVING_CFG) == 0))
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+            }
+        }
+        else
+        {
+            /* We are forcing line speed. */
+            pDevice->FlowControlCap &= ~LM_FLOW_CONTROL_AUTO_PAUSE;
+            LM_SetFlowControl(pDevice, 0, 0);
+
+            CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+                MAC_MODE_SEND_CONFIGS);
+        }
+    }
+    /* Set the link polarity bit. */
+    pDevice->MacMode &= ~MAC_MODE_LINK_POLARITY;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED |
+        (pDevice->pStatusBlkVirt->Status & ~STATUS_BLOCK_LINK_CHANGED_STATUS);
+
+    for (j = 0; j < 100; j++)
+    {
+        REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+            MAC_STATUS_CFG_CHANGED);
+        MM_Wait(5);
+        if ((REG_RD(pDevice, MacCtrl.Status) &
+            (MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED)) == 0)
+            break;
+    }
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if((Value32 & MAC_STATUS_PCS_SYNCED) == 0)
+    {
+        CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+        if (pDevice->DisableAutoNeg == FALSE)
+        {
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+                MAC_MODE_SEND_CONFIGS);
+            MM_Wait(1);
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+        }
+    }
+
+    /* Initialize the current link status. */
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+        REG_WR(pDevice, MacCtrl.LedCtrl, LED_CTRL_OVERRIDE_LINK_LED |
+            LED_CTRL_1000MBPS_LED_ON);
+    }
+    else
+    {
+        pDevice->LineSpeed = LM_LINE_SPEED_UNKNOWN;
+        pDevice->DuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+        REG_WR(pDevice, MacCtrl.LedCtrl, LED_CTRL_OVERRIDE_LINK_LED |
+            LED_CTRL_OVERRIDE_TRAFFIC_LED);
+    }
+
+    /* Indicate link status. */
+    if (pDevice->LinkStatus != CurrentLinkStatus) {
+        pDevice->LinkStatus = CurrentLinkStatus;
+        MM_IndicateStatus(pDevice, CurrentLinkStatus);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+#endif /* INCLUDE_TBI_SUPPORT */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetupCopperPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS CurrentLinkStatus;
+    LM_UINT32 Value32;
+
+    /* Assume there is not link first. */
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Disable phy link change attention. */
+    REG_WR(pDevice, MacCtrl.MacEvent, 0);
+
+    /* Clear link change attention. */
+    REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+        MAC_STATUS_CFG_CHANGED);
+
+    /* Disable auto-polling for the moment. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    MM_Wait(40);
+
+    /* Determine the requested line speed and duplex. */
+    pDevice->OldLineSpeed = pDevice->LineSpeed;
+    LM_TranslateRequestedMediaType(pDevice->RequestedMediaType,
+        &pDevice->MediaType, &pDevice->LineSpeed, &pDevice->DuplexMode);
+
+    /* Initialize the phy chip. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+        case PHY_BCM5401_PHY_ID:
+        case PHY_BCM5411_PHY_ID:
+        case PHY_BCM5701_PHY_ID:
+        case PHY_BCM5703_PHY_ID:
+            CurrentLinkStatus = LM_InitBcm540xPhy(pDevice);
+            break;
+
+        default:
+            break;
+    }
+
+    if(CurrentLinkStatus == LM_STATUS_LINK_SETTING_MISMATCH)
+    {
+        CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+    }
+    
+    /* Setup flow control. */
+    pDevice->FlowControl = LM_FLOW_CONTROL_NONE;
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        LM_FLOW_CONTROL FlowCap;     /* Flow control capability. */
+
+        FlowCap = LM_FLOW_CONTROL_NONE;
+
+        if(pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+        {
+            if(pDevice->DisableAutoNeg == FALSE ||
+                pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+                pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+            {
+                LM_UINT32 ExpectedPhyAd;
+                LM_UINT32 LocalPhyAd;
+                LM_UINT32 RemotePhyAd;
+
+                LM_ReadPhy(pDevice, PHY_AN_AD_REG, &LocalPhyAd);
+		pDevice->advertising = LocalPhyAd;
+                LocalPhyAd &= (PHY_AN_AD_ASYM_PAUSE | PHY_AN_AD_PAUSE_CAPABLE);
+
+                ExpectedPhyAd = GetPhyAdFlowCntrlSettings(pDevice);
+
+                if(LocalPhyAd != ExpectedPhyAd)
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+                }
+                else
+                {
+                    LM_ReadPhy(pDevice, PHY_LINK_PARTNER_ABILITY_REG,
+                        &RemotePhyAd);
+
+                    LM_SetFlowControl(pDevice, LocalPhyAd, RemotePhyAd);
+                }
+            }
+            else
+            {
+                pDevice->FlowControlCap &= ~LM_FLOW_CONTROL_AUTO_PAUSE;
+                LM_SetFlowControl(pDevice, 0, 0);
+            }
+        }
+    }
+
+    if(CurrentLinkStatus == LM_STATUS_LINK_DOWN)
+    {
+        LM_ForceAutoNeg(pDevice, pDevice->RequestedMediaType, FALSE);
+
+        /* If we force line speed, we make get link right away. */
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        if(Value32 & PHY_STATUS_LINK_PASS)
+        {
+            CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+        }
+    }
+
+    /* GMII interface. */
+    pDevice->MacMode &= ~MAC_MODE_PORT_MODE_MASK;
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        if(pDevice->LineSpeed == LM_LINE_SPEED_100MBPS ||
+            pDevice->LineSpeed == LM_LINE_SPEED_10MBPS)
+        {
+            pDevice->MacMode |= MAC_MODE_PORT_MODE_MII;
+        }
+        else
+        {
+            pDevice->MacMode |= MAC_MODE_PORT_MODE_GMII;
+        }
+    }
+    else {
+        pDevice->MacMode |= MAC_MODE_PORT_MODE_GMII;
+    }
+
+    /* Set the MAC to operate in the appropriate duplex mode. */
+    pDevice->MacMode &= ~MAC_MODE_HALF_DUPLEX;
+    if(pDevice->DuplexMode == LM_DUPLEX_MODE_HALF)
+    {
+        pDevice->MacMode |= MAC_MODE_HALF_DUPLEX;
+    }
+
+    /* Set the link polarity bit. */
+    pDevice->MacMode &= ~MAC_MODE_LINK_POLARITY;
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        if((pDevice->LedMode == LED_MODE_LINK10) ||
+             (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE &&
+             pDevice->LineSpeed == LM_LINE_SPEED_10MBPS))
+        {
+            pDevice->MacMode |= MAC_MODE_LINK_POLARITY;
+        }
+    }
+    else
+    {
+        if (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+        {
+            pDevice->MacMode |= MAC_MODE_LINK_POLARITY;
+        }
+
+        /* Set LED mode. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = LED_CTRL_PHY_MODE_1;
+        }
+        else
+        {
+            if(pDevice->LedMode == LED_MODE_OUTPUT)
+            {
+                Value32 = LED_CTRL_PHY_MODE_2;
+            }
+            else
+            {
+                Value32 = LED_CTRL_PHY_MODE_1;
+            }
+        }
+        REG_WR(pDevice, MacCtrl.LedCtrl, Value32);
+    }
+
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    /* Enable auto polling. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        pDevice->MiMode |= MI_MODE_AUTO_POLLING_ENABLE;
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    }
+
+    /* Enable phy link change attention. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+    {
+        REG_WR(pDevice, MacCtrl.MacEvent, MAC_EVENT_ENABLE_MI_INTERRUPT);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.MacEvent, 
+            MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN);
+    }
+    if ((T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700) &&
+        (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE) &&
+        (pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) &&
+        (((pDevice->PciState & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) &&
+          (pDevice->PciState & T3_PCI_STATE_BUS_SPEED_HIGH)) ||
+         !(pDevice->PciState & T3_PCI_STATE_CONVENTIONAL_PCI_MODE)))
+    {
+        MM_Wait(120);
+        REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+            MAC_STATUS_CFG_CHANGED);
+        MEM_WR_OFFSET(pDevice, T3_FIRMWARE_MAILBOX,
+            T3_MAGIC_NUM_DISABLE_DMAW_ON_LINK_CHANGE);
+    }
+
+    /* Indicate link status. */
+    if (pDevice->LinkStatus != CurrentLinkStatus) {
+        pDevice->LinkStatus = CurrentLinkStatus;
+        MM_IndicateStatus(pDevice, CurrentLinkStatus);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetupCopperPhy */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetupPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS LmStatus;
+
+#if INCLUDE_TBI_SUPPORT
+    if(pDevice->EnableTbi)
+    {
+        LmStatus = LM_SetupFiberPhy(pDevice);
+    }
+    else
+#endif /* INCLUDE_TBI_SUPPORT */
+    {
+        LmStatus = LM_SetupCopperPhy(pDevice);
+    }
+    if ((pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) &&
+        (pDevice->DuplexMode == LM_DUPLEX_MODE_HALF))
+    {
+        REG_WR(pDevice, MacCtrl.TxLengths, 0x26ff);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.TxLengths, 0x2620);
+    }
+
+    return LmStatus;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_ReadPhy(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 PhyReg,
+PLM_UINT32 pData32) {
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode &
+            ~MI_MODE_AUTO_POLLING_ENABLE);
+        MM_Wait(40);
+    }
+
+    Value32 = (pDevice->PhyAddr << MI_COM_FIRST_PHY_ADDR_BIT) |
+        ((PhyReg & MI_COM_PHY_REG_ADDR_MASK) << MI_COM_FIRST_PHY_REG_ADDR_BIT) |
+        MI_COM_CMD_READ | MI_COM_START;
+
+    REG_WR(pDevice, MacCtrl.MiCom, Value32);
+    
+    for(j = 0; j < 20; j++)
+    {
+        MM_Wait(25);
+
+        Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+
+        if(!(Value32 & MI_COM_BUSY))
+        {
+            MM_Wait(5);
+            Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+            Value32 &= MI_COM_PHY_DATA_MASK;
+            break;
+        }
+    }
+
+    if(Value32 & MI_COM_BUSY)
+    {
+        Value32 = 0;
+    }
+
+    *pData32 = Value32;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+        MM_Wait(40);
+    }
+} /* LM_ReadPhy */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_WritePhy(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 PhyReg,
+LM_UINT32 Data32) {
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode &
+            ~MI_MODE_AUTO_POLLING_ENABLE);
+        MM_Wait(40);
+    }
+
+    Value32 = (pDevice->PhyAddr << MI_COM_FIRST_PHY_ADDR_BIT) |
+        ((PhyReg & MI_COM_PHY_REG_ADDR_MASK) << MI_COM_FIRST_PHY_REG_ADDR_BIT) |
+        (Data32 & MI_COM_PHY_DATA_MASK) | MI_COM_CMD_WRITE | MI_COM_START;
+
+    REG_WR(pDevice, MacCtrl.MiCom, Value32);
+    
+    for(j = 0; j < 20; j++)
+    {
+        MM_Wait(25);
+
+        Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+
+        if(!(Value32 & MI_COM_BUSY))
+        {
+            MM_Wait(5);
+            break;
+        }
+    }
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+        MM_Wait(40);
+    }
+} /* LM_WritePhy */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetPowerState(
+PLM_DEVICE_BLOCK pDevice,
+LM_POWER_STATE PowerLevel) {
+    LM_UINT32 PmeSupport;
+    LM_UINT32 Value32;
+    LM_UINT32 PmCtrl;
+
+    /* make sureindirect accesses are enabled*/
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, pDevice->MiscHostCtrl);
+
+    /* Clear the PME_ASSERT bit and the power state bits.  Also enable */
+    /* the PME bit. */
+    MM_ReadConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, &PmCtrl);
+
+    PmCtrl |= T3_PM_PME_ASSERTED;
+    PmCtrl &= ~T3_PM_POWER_STATE_MASK;
+
+    /* Set the appropriate power state. */
+    if(PowerLevel == LM_POWER_STATE_D0)
+    {
+
+        /* Bring the card out of low power mode. */
+        PmCtrl |= T3_PM_POWER_STATE_D0;
+        MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, PmCtrl);
+
+        REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl);
+	MM_Wait(40);	/* Required delay is about 20us. */
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x02);
+
+        return LM_STATUS_SUCCESS;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D1)
+    {
+        PmCtrl |= T3_PM_POWER_STATE_D1;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D2)
+    {
+        PmCtrl |= T3_PM_POWER_STATE_D2;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D3)
+    {
+        PmCtrl |= T3_PM_POWER_STATE_D3;
+    }
+    else
+    {
+        return LM_STATUS_FAILURE;
+    }
+    PmCtrl |= T3_PM_PME_ENABLE;
+
+#if 0
+    /* No WOL. */
+    if(pDevice->WakeUpModeCap == LM_WAKE_UP_MODE_NONE)
+    {
+        DbgMessage(INFORM, ("No power capabilities.\n"));
+        return LM_STATUS_FAILURE;
+    }
+#endif
+
+    /* Mask out all interrupts so LM_SetupPhy won't be called while we are */
+    /* setting new line speed. */
+    Value32 = REG_RD(pDevice, PciCfg.MiscHostCtrl);
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, Value32 | MISC_HOST_CTRL_MASK_PCI_INT);
+
+    if(!pDevice->RestoreOnWakeUp)
+    {
+        pDevice->RestoreOnWakeUp = TRUE;
+        pDevice->WakeUpDisableAutoNeg = pDevice->DisableAutoNeg;
+        pDevice->WakeUpRequestedMediaType = pDevice->RequestedMediaType;
+    }
+
+    /* Force auto-negotiation to 10 line speed. */
+    pDevice->DisableAutoNeg = FALSE;
+    pDevice->RequestedMediaType = LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+    LM_SetupPhy(pDevice);
+
+    /* Put the driver in the initial state, and go through the power down */
+    /* sequence. */
+    LM_Halt(pDevice);
+
+    MM_ReadConfig32(pDevice, T3_PCI_PM_CAP_REG, &PmeSupport);
+
+    if (pDevice->WakeUpModeCap != LM_WAKE_UP_MODE_NONE)
+    {
+
+        /* Enable WOL. */
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x5a);
+        MM_Wait(40);
+
+        /* Set LED mode. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = LED_CTRL_PHY_MODE_1;
+        }
+        else
+        {
+            if(pDevice->LedMode == LED_MODE_OUTPUT)
+            {
+                Value32 = LED_CTRL_PHY_MODE_2;
+            }
+            else
+            {
+                Value32 = LED_CTRL_PHY_MODE_1;
+            }
+        }
+
+        Value32 = MAC_MODE_PORT_MODE_MII;
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            if(pDevice->LedMode == LED_MODE_LINK10 ||
+                pDevice->WolSpeed == WOL_SPEED_10MB)
+            {
+                Value32 |= MAC_MODE_LINK_POLARITY;
+            }
+        }
+        else
+        {
+            Value32 |= MAC_MODE_LINK_POLARITY;
+        }
+
+        /* Always enable magic packet wake-up if we have vaux. */
+        if((PmeSupport & T3_PCI_PM_CAP_PME_D3COLD) && 
+            (pDevice->WakeUpModeCap & LM_WAKE_UP_MODE_MAGIC_PACKET))
+        {
+            Value32 |= MAC_MODE_DETECT_MAGIC_PACKET_ENABLE;
+        }
+
+        REG_WR(pDevice, MacCtrl.Mode, Value32);
+
+        /* Enable the receiver. */
+        REG_WR(pDevice, MacCtrl.RxMode, RX_MODE_ENABLE);
+    }
+
+    /* Disable tx/rx clocks, and seletect an alternate clock. */
+    if(pDevice->WolSpeed == WOL_SPEED_100MB)
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK;
+        }
+        else
+        {
+            Value32 = T3_PCI_SELECT_ALTERNATE_CLOCK;
+        }
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+
+        MM_Wait(40);
+
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK | T3_PCI_44MHZ_CORE_CLOCK;
+        }
+        else
+        {
+            Value32 = T3_PCI_SELECT_ALTERNATE_CLOCK |
+                T3_PCI_44MHZ_CORE_CLOCK;
+        }
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+
+        MM_Wait(40);
+
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_44MHZ_CORE_CLOCK;
+        }
+        else
+        {
+            Value32 = T3_PCI_44MHZ_CORE_CLOCK;
+        }
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+    }
+    else
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK |
+                T3_PCI_POWER_DOWN_PCI_PLL133;
+        }
+        else
+        {
+            Value32 = T3_PCI_SELECT_ALTERNATE_CLOCK |
+                T3_PCI_POWER_DOWN_PCI_PLL133;
+        }
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+    }
+
+    MM_Wait(40);
+
+    if(!pDevice->EepromWp && (pDevice->WakeUpModeCap != LM_WAKE_UP_MODE_NONE))
+    {
+        /* Switch adapter to auxilliary power. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            /* GPIO0 = 1, GPIO1 = 1, GPIO2 = 0. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1);
+                MM_Wait(40);
+        }
+        else
+        {
+            /* GPIO0 = 0, GPIO1 = 1, GPIO2 = 1. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT2);
+                MM_Wait(40);
+
+            /* GPIO0 = 1, GPIO1 = 1, GPIO2 = 1. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT2);
+                MM_Wait(40);
+
+            /* GPIO0 = 1, GPIO1 = 1, GPIO2 = 0. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1);
+                MM_Wait(40);
+        }
+    }
+
+    /* Set the phy to low power mode. */
+    /* Put the the hardware in low power mode. */
+    MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, PmCtrl);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetPowerState */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+static LM_UINT32
+GetPhyAdFlowCntrlSettings(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+
+    Value32 = 0;
+
+    /* Auto negotiation flow control only when autonegotiation is enabled. */
+    if(pDevice->DisableAutoNeg == FALSE ||
+        pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+        pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+    {
+        /* Please refer to Table 28B-3 of the 802.3ab-1999 spec. */
+        if((pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE) ||
+            ((pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE) &&
+            (pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE)))
+        {
+            Value32 |= PHY_AN_AD_PAUSE_CAPABLE;
+        }
+        else if(pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+        {
+            Value32 |= PHY_AN_AD_ASYM_PAUSE;
+        }
+        else if(pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE)
+        {
+            Value32 |= PHY_AN_AD_PAUSE_CAPABLE | PHY_AN_AD_ASYM_PAUSE;
+        }
+    }
+
+    return Value32;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_FAILURE                                                       */
+/*    LM_STATUS_SUCCESS                                                       */
+/*                                                                            */
+/*    If WaitForLink is TRUE, the return code is one of the following.        */
+/*       LM_STATUS_LINK_DOWN                                                  */
+/*       LM_STATUS_LINK_ACTIVE                                                */
+/******************************************************************************/
+static LM_STATUS
+LM_ForceAutoNegBcm540xPhy(
+PLM_DEVICE_BLOCK pDevice, 
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+LM_BOOL WaitForLink)
+{
+    LM_MEDIA_TYPE MediaType;
+    LM_LINE_SPEED LineSpeed;
+    LM_DUPLEX_MODE DuplexMode;
+    LM_UINT32 NewPhyCtrl;
+    LM_STATUS LmStatus;
+    LM_UINT32 Value32;
+    LM_UINT32 Cnt;
+
+    /* Get the interface type, line speed, and duplex mode. */
+    LM_TranslateRequestedMediaType(RequestedMediaType, &MediaType, &LineSpeed,
+        &DuplexMode);
+
+    if (pDevice->RestoreOnWakeUp)
+    {
+        LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+        pDevice->advertising1000 = 0;
+        Value32 = PHY_AN_AD_10BASET_FULL | PHY_AN_AD_10BASET_HALF;
+        if (pDevice->WolSpeed == WOL_SPEED_100MB)
+        {
+            Value32 |= PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+        }
+        Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+        Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+        LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+        pDevice->advertising = Value32;
+    }
+    /* Setup the auto-negotiation advertisement register. */
+    else if(LineSpeed == LM_LINE_SPEED_UNKNOWN)
+    {
+        /* Setup the 10/100 Mbps auto-negotiation advertisement register. */
+        Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD |
+            PHY_AN_AD_10BASET_HALF | PHY_AN_AD_10BASET_FULL |
+            PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+        Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+        LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+        pDevice->advertising = Value32;
+
+        /* Advertise 1000Mbps */
+        Value32 = BCM540X_AN_AD_1000BASET_HALF | BCM540X_AN_AD_1000BASET_FULL;
+
+#if INCLUDE_5701_AX_FIX
+        /* Bug: workaround for CRC error in gigabit mode when we are in */
+        /* slave mode.  This will force the PHY to operate in */
+        /* master mode. */
+        if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+        {
+            Value32 |= BCM540X_CONFIG_AS_MASTER |
+                BCM540X_ENABLE_CONFIG_AS_MASTER;
+        }
+#endif
+
+        LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+        pDevice->advertising1000 = Value32;
+    }
+    else
+    {
+        if(LineSpeed == LM_LINE_SPEED_1000MBPS)
+        {
+            Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+            pDevice->advertising = Value32;
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = BCM540X_AN_AD_1000BASET_HALF;
+            }
+            else
+            {
+                Value32 = BCM540X_AN_AD_1000BASET_FULL;
+            }
+
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+            pDevice->advertising1000 = Value32;
+        }
+        else if(LineSpeed == LM_LINE_SPEED_100MBPS)
+        {
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+            pDevice->advertising1000 = 0;
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = PHY_AN_AD_100BASETX_HALF;
+            }
+            else
+            {
+                Value32 = PHY_AN_AD_100BASETX_FULL;
+            }
+
+            Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+            pDevice->advertising = Value32;
+        }
+        else if(LineSpeed == LM_LINE_SPEED_10MBPS)
+        {
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+            pDevice->advertising1000 = 0;
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = PHY_AN_AD_10BASET_HALF;
+            }
+            else
+            {
+                Value32 = PHY_AN_AD_10BASET_FULL;
+            }
+
+            Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+            pDevice->advertising = Value32;
+        }
+    }
+
+    /* Force line speed if auto-negotiation is disabled. */
+    if(pDevice->DisableAutoNeg && LineSpeed != LM_LINE_SPEED_UNKNOWN)
+    {
+        /* This code path is executed only when there is link. */
+        pDevice->MediaType = MediaType;
+        pDevice->LineSpeed = LineSpeed;
+        pDevice->DuplexMode = DuplexMode;
+
+        /* Force line seepd. */
+        NewPhyCtrl = 0;
+        switch(LineSpeed)
+        {
+            case LM_LINE_SPEED_10MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_10MBPS;
+                break;
+            case LM_LINE_SPEED_100MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_100MBPS;
+                break;
+            case LM_LINE_SPEED_1000MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_1000MBPS;
+                break;
+            default:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_1000MBPS;
+                break;
+        }
+
+        if(DuplexMode == LM_DUPLEX_MODE_FULL)
+        {
+            NewPhyCtrl |= PHY_CTRL_FULL_DUPLEX_MODE;
+        }
+
+        /* Don't do anything if the PHY_CTRL is already what we wanted. */
+        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+        if(Value32 != NewPhyCtrl)
+        {
+            /* Temporary bring the link down before forcing line speed. */
+            LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_LOOPBACK_MODE);
+            
+            /* Wait for link to go down. */
+            for(Cnt = 0; Cnt < 15000; Cnt++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+                if(!(Value32 & PHY_STATUS_LINK_PASS))
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+            LM_WritePhy(pDevice, PHY_CTRL_REG, NewPhyCtrl);
+            MM_Wait(40);
+        }
+    }
+    else
+    {
+        LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_AUTO_NEG_ENABLE |
+            PHY_CTRL_RESTART_AUTO_NEG);
+    }
+
+    /* Wait for link. */
+    LmStatus = LM_STATUS_SUCCESS;
+    if(WaitForLink)
+    {
+        LmStatus = LM_STATUS_LINK_DOWN;
+
+        /* Wait for link up to 3 seconds. */
+        for(Cnt = 0; Cnt < 300000; Cnt++)
+        {
+            MM_Wait(10);
+
+            /* Get the current PHY status. */
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+            /* Link ok? */
+            if(Value32 & PHY_STATUS_LINK_PASS)
+            {
+                LmStatus = LM_STATUS_LINK_ACTIVE;
+                pDevice->MediaType = LM_MEDIA_TYPE_UTP;
+
+                /* Determine the current line and duplex settings. */
+                LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+                LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+
+                switch(Value32 & BCM540X_AUX_SPEED_MASK)
+                {
+                    case BCM540X_AUX_10BASET_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_10MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_10BASET_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_10MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    case BCM540X_AUX_100BASETX_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_100MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_100BASETX_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_100MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    case BCM540X_AUX_100BASET_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_100BASET_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    default:
+                        LmStatus = LM_STATUS_LINK_DOWN;
+                        break;
+                }
+
+                break;
+            }
+        }
+
+        /* Acknowledge interrupts. */
+        LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+    }
+
+    return LmStatus;
+} /* LM_ForceAutoNegBcm540xPhy */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+static LM_STATUS
+LM_ForceAutoNeg(
+PLM_DEVICE_BLOCK pDevice, 
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+LM_BOOL WaitForLink) {
+    LM_STATUS LmStatus;
+
+    /* Initialize the phy chip. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+        case PHY_BCM5401_PHY_ID:
+        case PHY_BCM5411_PHY_ID:
+        case PHY_BCM5701_PHY_ID:
+        case PHY_BCM5703_PHY_ID:
+            LmStatus = LM_ForceAutoNegBcm540xPhy(pDevice, RequestedMediaType, 
+                WaitForLink);
+            break;
+
+        default:
+            LmStatus = LM_STATUS_FAILURE;
+            break;
+    }
+
+    return LmStatus;
+} /* LM_ForceAutoNeg */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS LM_LoadFirmware(PLM_DEVICE_BLOCK pDevice,
+                          PT3_FWIMG_INFO pFwImg,
+                          LM_UINT32 LoadCpu,
+                          LM_UINT32 StartCpu)
+{
+    LM_UINT32 i;
+    LM_UINT32 address;
+
+    if (LoadCpu & T3_RX_CPU_ID)
+    {
+        if (LM_HaltCpu(pDevice,T3_RX_CPU_ID) != LM_STATUS_SUCCESS)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        /* First of all clear scrach pad memory */
+        for (i = 0; i < T3_RX_CPU_SPAD_SIZE; i+=4)
+        { 
+            LM_RegWrInd(pDevice,T3_RX_CPU_SPAD_ADDR+i,0);
+        }
+
+        /* Copy code first */
+        address = T3_RX_CPU_SPAD_ADDR + (pFwImg->Text.Offset & 0xffff);
+        for (i = 0; i <= pFwImg->Text.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Text.Buffer)[i/4]);
+        }
+
+        address = T3_RX_CPU_SPAD_ADDR + (pFwImg->ROnlyData.Offset & 0xffff);
+        for (i = 0; i <= pFwImg->ROnlyData.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->ROnlyData.Buffer)[i/4]);
+        }
+
+        address = T3_RX_CPU_SPAD_ADDR + (pFwImg->Data.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->Data.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Data.Buffer)[i/4]);
+        }
+    }
+
+    if (LoadCpu & T3_TX_CPU_ID)
+    {
+        if (LM_HaltCpu(pDevice,T3_TX_CPU_ID) != LM_STATUS_SUCCESS)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        /* First of all clear scrach pad memory */
+        for (i = 0; i < T3_TX_CPU_SPAD_SIZE; i+=4)
+        { 
+            LM_RegWrInd(pDevice,T3_TX_CPU_SPAD_ADDR+i,0);
+        }
+
+        /* Copy code first */
+        address = T3_TX_CPU_SPAD_ADDR + (pFwImg->Text.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->Text.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Text.Buffer)[i/4]);
+        }
+
+        address = T3_TX_CPU_SPAD_ADDR + (pFwImg->ROnlyData.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->ROnlyData.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->ROnlyData.Buffer)[i/4]);
+        }
+
+        address = T3_TX_CPU_SPAD_ADDR + (pFwImg->Data.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->Data.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Data.Buffer)[i/4]);
+        }
+    }
+
+    if (StartCpu & T3_RX_CPU_ID)
+    {
+        /* Start Rx CPU */
+        REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,rxCpu.reg.PC,pFwImg->StartAddress);
+        for (i = 0 ; i < 5; i++)
+        {
+          if (pFwImg->StartAddress == REG_RD(pDevice,rxCpu.reg.PC))
+             break;
+
+          REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+          REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_HALT);
+          REG_WR(pDevice,rxCpu.reg.PC,pFwImg->StartAddress);
+          MM_Wait(1000);
+        }
+
+        REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,rxCpu.reg.mode, 0);
+    }
+
+    if (StartCpu & T3_TX_CPU_ID)
+    {
+        /* Start Tx CPU */
+        REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,txCpu.reg.PC,pFwImg->StartAddress);
+        for (i = 0 ; i < 5; i++)
+        {
+          if (pFwImg->StartAddress == REG_RD(pDevice,txCpu.reg.PC))
+             break;
+
+          REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+          REG_WR(pDevice,txCpu.reg.mode,CPU_MODE_HALT);
+          REG_WR(pDevice,txCpu.reg.PC,pFwImg->StartAddress);
+          MM_Wait(1000);
+        }
+        
+        REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,txCpu.reg.mode, 0);
+    }
+    
+    return LM_STATUS_SUCCESS;
+}
+
+STATIC LM_STATUS LM_HaltCpu(PLM_DEVICE_BLOCK pDevice,LM_UINT32 cpu_number)
+{
+    LM_UINT32 i;
+
+    if (cpu_number == T3_RX_CPU_ID)
+    {
+        for (i = 0 ; i < 10000; i++)
+        {
+            REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+            REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_HALT);
+
+            if (REG_RD(pDevice,rxCpu.reg.mode) & CPU_MODE_HALT)
+              break;
+        }
+
+        REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_HALT);
+        MM_Wait(10);
+    }
+    else
+    {
+        for (i = 0 ; i < 10000; i++)
+        {
+            REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+            REG_WR(pDevice,txCpu.reg.mode,CPU_MODE_HALT);
+
+            if (REG_RD(pDevice,txCpu.reg.mode) & CPU_MODE_HALT)
+               break;
+        }
+    }
+
+  return (( i == 10000) ? LM_STATUS_FAILURE : LM_STATUS_SUCCESS);
+}
+
+
+int
+LM_BlinkLED(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlinkDurationSec)
+{
+	LM_UINT32 Oldcfg;
+	int j;
+	int ret = 0;
+
+	if(BlinkDurationSec == 0)
+	{
+		return 0;
+        }
+	if(BlinkDurationSec > 120)
+        {
+	        BlinkDurationSec = 120;
+	}
+
+	Oldcfg = REG_RD(pDevice, MacCtrl.LedCtrl);
+	for(j = 0; j < BlinkDurationSec * 2; j++)
+	{
+		if(j % 2)
+		{
+			// Turn on the LEDs.
+			REG_WR(pDevice, MacCtrl.LedCtrl,
+				LED_CTRL_OVERRIDE_LINK_LED |
+				LED_CTRL_1000MBPS_LED_ON |
+				LED_CTRL_100MBPS_LED_ON |
+				LED_CTRL_10MBPS_LED_ON |
+				LED_CTRL_OVERRIDE_TRAFFIC_LED |
+				LED_CTRL_BLINK_TRAFFIC_LED |
+				LED_CTRL_TRAFFIC_LED);
+		}
+		else
+		{
+			// Turn off the LEDs.
+			REG_WR(pDevice, MacCtrl.LedCtrl,
+				LED_CTRL_OVERRIDE_LINK_LED |
+				LED_CTRL_OVERRIDE_TRAFFIC_LED);
+		}
+		current->state = TASK_INTERRUPTIBLE;
+		if (schedule_timeout(HZ/2) != 0) {
+			ret = -EINTR;
+			break;
+		}
+	}
+	REG_WR(pDevice, MacCtrl.LedCtrl, Oldcfg);
+	return ret;
+}
+
+int t3_do_dma(PLM_DEVICE_BLOCK pDevice, 
+                   LM_PHYSICAL_ADDRESS host_addr_phy, int length,
+                   int dma_read)
+{
+    T3_DMA_DESC dma_desc;
+    int i;
+    LM_UINT32 dma_desc_addr;
+    LM_UINT32 value32;
+
+    REG_WR(pDevice, BufMgr.Mode, 0);
+    REG_WR(pDevice, Ftq.Reset, 0);
+
+    dma_desc.host_addr.High = host_addr_phy.High;
+    dma_desc.host_addr.Low = host_addr_phy.Low;
+    dma_desc.nic_mbuf = 0x2100;
+    dma_desc.len = length;
+    dma_desc.flags = 0x00000004; /* Generate Rx-CPU event */
+
+    if (dma_read)
+    {
+        dma_desc.cqid_sqid = (T3_QID_RX_BD_COMP << 8) |
+            T3_QID_DMA_HIGH_PRI_READ;
+        REG_WR(pDevice, DmaRead.Mode, DMA_READ_MODE_ENABLE);
+    }
+    else
+    {
+        dma_desc.cqid_sqid = (T3_QID_RX_DATA_COMP << 8) |
+            T3_QID_DMA_HIGH_PRI_WRITE;
+        REG_WR(pDevice, DmaWrite.Mode, DMA_WRITE_MODE_ENABLE);
+    }
+
+    dma_desc_addr = T3_NIC_DMA_DESC_POOL_ADDR;
+
+    /* Writing this DMA descriptor to DMA memory */
+    for (i = 0; i < sizeof(T3_DMA_DESC); i += 4)
+    {
+        value32 = *((PLM_UINT32) (((PLM_UINT8) &dma_desc) + i));
+        MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, dma_desc_addr+i);
+        MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, cpu_to_le32(value32));
+    }
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, 0);
+
+    if (dma_read)
+        REG_WR(pDevice, Ftq.DmaHighReadFtqFifoEnqueueDequeue, dma_desc_addr);
+    else
+        REG_WR(pDevice, Ftq.DmaHighWriteFtqFifoEnqueueDequeue, dma_desc_addr);
+
+    for (i = 0; i < 40; i++)
+    {
+        if (dma_read)
+            value32 = REG_RD(pDevice, Ftq.RcvBdCompFtqFifoEnqueueDequeue);
+        else
+            value32 = REG_RD(pDevice, Ftq.RcvDataCompFtqFifoEnqueueDequeue);
+
+        if ((value32 & 0xffff) == dma_desc_addr)
+            break;
+
+        MM_Wait(10);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+STATIC LM_STATUS
+LM_DmaTest(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pBufferVirt,
+           LM_PHYSICAL_ADDRESS BufferPhy, LM_UINT32 BufferSize)
+{
+    int j;
+    LM_UINT32 *ptr;
+    int dma_success = 0;
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+        T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5701)
+    {
+        return LM_STATUS_SUCCESS;
+    }
+    while (!dma_success)
+    {
+        /* Fill data with incremental patterns */
+        ptr = (LM_UINT32 *)pBufferVirt;
+        for (j = 0; j < BufferSize/4; j++)
+            *ptr++ = j;
+
+        if (t3_do_dma(pDevice,BufferPhy,BufferSize, 1) == LM_STATUS_FAILURE)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        MM_Wait(40);
+        ptr = (LM_UINT32 *)pBufferVirt;
+        /* Fill data with zero */
+        for (j = 0; j < BufferSize/4; j++)
+            *ptr++ = 0;
+
+        if (t3_do_dma(pDevice,BufferPhy,BufferSize, 0) == LM_STATUS_FAILURE)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        MM_Wait(40);
+        /* Check for data */
+        ptr = (LM_UINT32 *)pBufferVirt;
+        for (j = 0; j < BufferSize/4; j++)
+        {
+            if (*ptr++ != j)
+            {
+                if ((pDevice->DmaReadWriteCtrl & DMA_CTRL_WRITE_BOUNDARY_MASK)
+                    == DMA_CTRL_WRITE_BOUNDARY_DISABLE)
+                {
+                    pDevice->DmaReadWriteCtrl = (pDevice->DmaReadWriteCtrl &
+                         ~DMA_CTRL_WRITE_BOUNDARY_MASK) |
+                          DMA_CTRL_WRITE_BOUNDARY_16;
+                    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl,
+                           pDevice->DmaReadWriteCtrl);
+                    break;
+                 }
+                 else
+                 {
+                     return LM_STATUS_FAILURE;
+                 }
+            }
+        }
+        if (j == (BufferSize/4))
+            dma_success = 1;
+    }
+    return LM_STATUS_SUCCESS;
+}
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/bcm/tigon3.h linux/drivers/net/bcm/tigon3.h
--- ../prev/linux/drivers/net/bcm/tigon3.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/tigon3.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,3362 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*                                                                            */
+/******************************************************************************/
+
+#ifndef TIGON3_H
+#define TIGON3_H
+
+#include "lm.h"
+#if INCLUDE_TBI_SUPPORT
+#include "autoneg.h"
+#endif
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+/* Maxim number of packet descriptors used for sending packets. */
+#define MAX_TX_PACKET_DESC_COUNT            600
+#define DEFAULT_TX_PACKET_DESC_COUNT        100
+
+/* Maximum number of packet descriptors used for receiving packets. */
+#if T3_JUMBO_RCB_ENTRY_COUNT
+#define MAX_RX_PACKET_DESC_COUNT                                            \
+    (T3_STD_RCV_RCB_ENTRY_COUNT + T3_JUMBO_RCV_RCB_ENTRY_COUNT)
+#else
+#define MAX_RX_PACKET_DESC_COUNT            800
+#endif
+#define DEFAULT_RX_PACKET_DESC_COUNT        200
+
+/* Threshhold for double copying small tx packets.  0 will disable double */
+/* copying of small Tx packets. */
+#define DEFAULT_TX_COPY_BUFFER_SIZE         0
+#define MIN_TX_COPY_BUFFER_SIZE             64 
+#define MAX_TX_COPY_BUFFER_SIZE             512
+
+/* Cache line. */
+#define COMMON_CACHE_LINE_SIZE              0x20
+#define COMMON_CACHE_LINE_MASK              (COMMON_CACHE_LINE_SIZE-1)
+
+/* Maximum number of fragment we can handle. */
+#ifndef MAX_FRAGMENT_COUNT
+#define MAX_FRAGMENT_COUNT                  32
+#endif
+
+/* B0 bug. */
+#define BCM5700_BX_MIN_FRAG_SIZE            10
+#define BCM5700_BX_MIN_FRAG_BUF_SIZE        16  /* nice aligned size. */
+#define BCM5700_BX_MIN_FRAG_BUF_SIZE_MASK   (BCM5700_BX_MIN_FRAG_BUF_SIZE-1)
+#define BCM5700_BX_TX_COPY_BUF_SIZE         (BCM5700_BX_MIN_FRAG_BUF_SIZE * \
+                                            MAX_FRAGMENT_COUNT)
+
+/* MAGIC number. */
+//#define T3_MAGIC_NUM                        'KevT'
+#define T3_FIRMWARE_MAILBOX                0x0b50
+#define T3_MAGIC_NUM                       0x4B657654 
+#define T3_MAGIC_NUM_DISABLE_DMAW_ON_LINK_CHANGE 0x4861764b
+
+#define T3_NIC_DATA_SIG_ADDR               0x0b54
+#define T3_NIC_DATA_SIG                    0x4b657654
+
+#define T3_NIC_DATA_NIC_CFG_ADDR           0x0b58
+#define T3_NIC_CFG_LED_MODE_UNKNOWN        BIT_NONE
+#define T3_NIC_CFG_LED_MODE_TRIPLE_SPEED   BIT_2
+#define T3_NIC_CFG_LED_MODE_LINK_SPEED     BIT_3
+#define T3_NIC_CFG_LED_MODE_OPEN_DRAIN     BIT_2
+#define T3_NIC_CFG_LED_MODE_OUTPUT         BIT_3
+#define T3_NIC_CFG_LED_MODE_MASK           (BIT_2 | BIT_3)
+#define T3_NIC_CFG_PHY_TYPE_UNKNOWN         BIT_NONE
+#define T3_NIC_CFG_PHY_TYPE_COPPER          BIT_4
+#define T3_NIC_CFG_PHY_TYPE_FIBER           BIT_5
+#define T3_NIC_CFG_PHY_TYPE_MASK            (BIT_4 | BIT_5)
+#define T3_NIC_CFG_ENABLE_WOL               BIT_6
+#define T3_NIC_CFG_ENABLE_ASF               BIT_7
+#define T3_NIC_EEPROM_WP                    BIT_8
+
+#define T3_NIC_DATA_PHY_ID_ADDR            0x0b74
+#define T3_NIC_PHY_ID1_MASK                0xffff0000
+#define T3_NIC_PHY_ID2_MASK                0x0000ffff
+
+#define T3_CMD_MAILBOX                      0x0b78
+#define T3_CMD_NICDRV_ALIVE                 0x01
+#define T3_CMD_NICDRV_PAUSE_FW              0x02
+#define T3_CMD_NICDRV_IPV4ADDR_CHANGE       0x03
+#define T3_CMD_NICDRV_IPV6ADDR_CHANGE       0x04
+#define T3_CMD_5703A0_FIX_DMAFW_DMAR        0x05
+#define T3_CMD_5703A0_FIX_DMAFW_DMAW        0x06
+
+#define T3_CMD_LENGTH_MAILBOX               0x0b7c
+#define T3_CMD_DATA_MAILBOX                 0x0b80
+
+#define T3_ASF_FW_STATUS_MAILBOX            0x0c00
+
+#define T3_DRV_STATE_MAILBOX                0x0c04
+#define T3_DRV_STATE_START                  0x01
+#define T3_DRV_STATE_UNLOAD                 0x02
+#define T3_DRV_STATE_WOL                    0x03
+#define T3_DRV_STATE_SUSPEND                0x04
+
+#define T3_FW_RESET_TYPE_MAILBOX            0x0c08
+
+#define T3_MAC_ADDR_HIGH_MAILBOX            0x0c14
+#define T3_MAC_ADDR_LOW_MAILBOX             0x0c18
+
+/******************************************************************************/
+/* Hardware constants. */
+/******************************************************************************/
+
+/* Number of entries in the send ring:  must be 512. */
+#define T3_SEND_RCB_ENTRY_COUNT             512     
+#define T3_SEND_RCB_ENTRY_COUNT_MASK        (T3_SEND_RCB_ENTRY_COUNT-1)
+
+/* Number of send RCBs.  May be 1-16 but for now, only support one. */
+#define T3_MAX_SEND_RCB_COUNT               16
+
+/* Number of entries in the Standard Receive RCB.  Must be 512 entries. */
+#define T3_STD_RCV_RCB_ENTRY_COUNT          512
+#define T3_STD_RCV_RCB_ENTRY_COUNT_MASK     (T3_STD_RCV_RCB_ENTRY_COUNT-1)
+#define DEFAULT_STD_RCV_DESC_COUNT          200    /* Must be < 512. */
+#define MAX_STD_RCV_BUFFER_SIZE             0x600
+
+/* Number of entries in the Mini Receive RCB.  This value can either be */
+/* 0, 1024.  Currently Mini Receive RCB is disabled. */
+#ifndef T3_MINI_RCV_RCB_ENTRY_COUNT
+#define T3_MINI_RCV_RCB_ENTRY_COUNT         0
+#endif /* T3_MINI_RCV_RCB_ENTRY_COUNT */
+#define T3_MINI_RCV_RCB_ENTRY_COUNT_MASK    (T3_MINI_RCV_RCB_ENTRY_COUNT-1)
+#define MAX_MINI_RCV_BUFFER_SIZE            512
+#define DEFAULT_MINI_RCV_BUFFER_SIZE        64
+#define DEFAULT_MINI_RCV_DESC_COUNT         100    /* Must be < 1024. */
+
+/* Number of entries in the Jumbo Receive RCB.  This value must 256 or 0. */
+/* Currently, Jumbo Receive RCB is disabled. */
+#ifndef T3_JUMBO_RCV_RCB_ENTRY_COUNT
+#define T3_JUMBO_RCV_RCB_ENTRY_COUNT        0
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+#define T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK   (T3_JUMBO_RCV_RCB_ENTRY_COUNT-1)
+
+#define MAX_JUMBO_RCV_BUFFER_SIZE           (10 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_RCV_BUFFER_SIZE       (4 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_RCV_DESC_COUNT        128     /* Must be < 256. */
+
+#define MAX_JUMBO_TX_BUFFER_SIZE            (8 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_TX_BUFFER_SIZE        (4 * 1024) /* > 1514 */
+
+/* Number of receive return RCBs.  Maybe 1-16 but for now, only support one. */
+#define T3_MAX_RCV_RETURN_RCB_COUNT         16
+
+/* Number of entries in a Receive Return ring.  This value is either 1024 */
+/* or 2048. */
+#ifndef T3_RCV_RETURN_RCB_ENTRY_COUNT 
+#define T3_RCV_RETURN_RCB_ENTRY_COUNT       1024
+#endif /* T3_RCV_RETURN_RCB_ENTRY_COUNT */
+#define T3_RCV_RETURN_RCB_ENTRY_COUNT_MASK  (T3_RCV_RETURN_RCB_ENTRY_COUNT-1)
+
+
+/* Default coalescing parameters. */
+#define DEFAULT_RX_COALESCING_TICKS         100
+#define MAX_RX_COALESCING_TICKS             500
+#define DEFAULT_TX_COALESCING_TICKS         400
+#define MAX_TX_COALESCING_TICKS             500
+#define DEFAULT_RX_MAX_COALESCED_FRAMES     10
+#define MAX_RX_MAX_COALESCED_FRAMES         100
+#define ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES    5
+#define ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES    42
+#define ADAPTIVE_LO_RX_COALESCING_TICKS         50
+#define ADAPTIVE_HI_RX_COALESCING_TICKS         300
+#define ADAPTIVE_LO_PKT_THRESH              30000
+#define ADAPTIVE_HI_PKT_THRESH              74000
+#define DEFAULT_TX_MAX_COALESCED_FRAMES     40
+#define ADAPTIVE_LO_TX_MAX_COALESCED_FRAMES    25
+#define ADAPTIVE_HI_TX_MAX_COALESCED_FRAMES    75
+#define MAX_TX_MAX_COALESCED_FRAMES         100
+
+#define DEFAULT_RX_COALESCING_TICKS_DURING_INT          25
+#define DEFAULT_TX_COALESCING_TICKS_DURING_INT          25
+#define DEFAULT_RX_MAX_COALESCED_FRAMES_DURING_INT      5
+#define DEFAULT_TX_MAX_COALESCED_FRAMES_DURING_INT      5
+
+#define BAD_DEFAULT_VALUE                               0xffffffff
+
+#define DEFAULT_STATS_COALESCING_TICKS      1000000
+#define MAX_STATS_COALESCING_TICKS          3600000000U
+
+
+/* Receive BD Replenish thresholds. */
+#define DEFAULT_RCV_STD_BD_REPLENISH_THRESHOLD      4
+#define DEFAULT_RCV_JUMBO_BD_REPLENISH_THRESHOLD    4
+
+
+/* Maximum physical fragment size. */
+#define MAX_FRAGMENT_SIZE                   (64 * 1024)
+
+
+/* Standard view. */
+#define T3_STD_VIEW_SIZE                    (64 * 1024)
+#define T3_FLAT_VIEW_SIZE                   (32 * 1024 * 1024)
+
+
+/* Buffer descriptor base address on the NIC's memory. */
+
+#define T3_NIC_SND_BUFFER_DESC_ADDR         0x4000
+#define T3_NIC_STD_RCV_BUFFER_DESC_ADDR     0x6000
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR   0x7000
+
+#define T3_NIC_STD_RCV_BUFFER_DESC_ADDR_EXT_MEM     0xc000
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR_EXT_MEM   0xd000
+#define T3_NIC_MINI_RCV_BUFFER_DESC_ADDR_EXT_MEM    0xe000
+
+#define T3_NIC_SND_BUFFER_DESC_SIZE         (T3_SEND_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_SND_BD) / 4)
+
+#define T3_NIC_STD_RCV_BUFFER_DESC_SIZE     (T3_STD_RCV_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_RCV_BD) / 4)
+
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_SIZE   (T3_JUMBO_RCV_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_EXT_RCV_BD) / 4)
+
+
+/* MBUF pool. */
+#define T3_NIC_MBUF_POOL_ADDR               0x8000
+#define T3_NIC_MBUF_POOL_SIZE               0x18000
+
+#define T3_NIC_MBUF_POOL_ADDR_EXT_MEM       0x20000
+
+/* DMA descriptor pool */
+#define T3_NIC_DMA_DESC_POOL_ADDR           0x2000
+#define T3_NIC_DMA_DESC_POOL_SIZE           0x2000      /* 8KB. */
+
+#define T3_DEF_DMA_MBUF_LOW_WMARK           0x40
+#define T3_DEF_RX_MAC_MBUF_LOW_WMARK        0x20
+#define T3_DEF_MBUF_HIGH_WMARK              0x60
+
+#define T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO     304
+#define T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO  152
+#define T3_DEF_MBUF_HIGH_WMARK_JUMBO        380
+
+#define T3_DEF_DMA_DESC_LOW_WMARK           5
+#define T3_DEF_DMA_DESC_HIGH_WMARK          10
+
+/* Maximum size of giant TCP packet can be sent */
+#define T3_TCP_SEG_MAX_OFFLOAD_SIZE         64*1000
+#define T3_TCP_SEG_MIN_NUM_SEG              20
+
+#define T3_RX_CPU_ID    0x1
+#define T3_TX_CPU_ID    0x2
+#define T3_RX_CPU_SPAD_ADDR  0x30000
+#define T3_RX_CPU_SPAD_SIZE  0x4000
+#define T3_TX_CPU_SPAD_ADDR  0x34000
+#define T3_TX_CPU_SPAD_SIZE  0x4000
+
+typedef struct T3_DIR_ENTRY
+{
+  PLM_UINT8 Buffer;
+  LM_UINT32 Offset;
+  LM_UINT32 Length;
+} T3_DIR_ENTRY,*PT3_DIR_ENTRY;
+
+typedef struct T3_FWIMG_INFO
+{
+  LM_UINT32 StartAddress;
+  T3_DIR_ENTRY Text;
+  T3_DIR_ENTRY ROnlyData;
+  T3_DIR_ENTRY Data;
+  T3_DIR_ENTRY Sbss;
+  T3_DIR_ENTRY Bss;
+} T3_FWIMG_INFO, *PT3_FWIMG_INFO;
+
+
+
+/******************************************************************************/
+/* Tigon3 PCI Registers. */
+/******************************************************************************/
+#define T3_PCI_ID_BCM5700                   0x164414e4
+#define T3_PCI_ID_BCM5701                   0x164514e4
+#define T3_PCI_ID_BCM5702                   0x164614e4
+#define T3_PCI_ID_BCM5702x                  0x16A614e4
+#define T3_PCI_ID_BCM5703                   0x164714e4
+#define T3_PCI_ID_BCM5703x                  0x16A714e4
+#define T3_PCI_ID_BCM5702FE                 0x164D14e4
+
+#define T3_PCI_VENDOR_ID                    (T3_PCI_ID & 0xffff)
+#define T3_PCI_DEVICE_ID                    (T3_PCI_ID >> 16)
+
+#define T3_PCI_MISC_HOST_CTRL_REG           0x68
+
+/* The most significant 16bit of register 0x68. */
+/* ChipId:4, ChipRev:4, MetalRev:8 */
+#define T3_CHIP_ID_5700_A0                  0x7000
+#define T3_CHIP_ID_5700_A1                  0x7001
+#define T3_CHIP_ID_5700_B0                  0x7100
+#define T3_CHIP_ID_5700_B1                  0x7101
+#define T3_CHIP_ID_5700_C0                  0x7200
+
+#define T3_CHIP_ID_5701_A0                  0x0000
+#define T3_CHIP_ID_5701_B0                  0x0100
+#define T3_CHIP_ID_5701_B2                  0x0102
+#define T3_CHIP_ID_5701_B5                  0x0105
+
+#define T3_CHIP_ID_5703_A0                  0x1000
+#define T3_CHIP_ID_5703_A1                  0x1001
+#define T3_CHIP_ID_5703_A2                  0x1002
+
+/* Chip Id. */
+#define T3_ASIC_REV(_ChipRevId)             ((_ChipRevId) >> 12)
+#define T3_ASIC_REV_5700                    0x07
+#define T3_ASIC_REV_5701                    0x00
+#define T3_ASIC_REV_5703                    0x01
+
+/* Chip id and revision. */
+#define T3_CHIP_REV(_ChipRevId)             ((_ChipRevId) >> 8)
+#define T3_CHIP_REV_5700_AX                 0x70
+#define T3_CHIP_REV_5700_BX                 0x71
+#define T3_CHIP_REV_5700_CX                 0x72
+#define T3_CHIP_REV_5701_AX                 0x00
+
+/* Metal revision. */
+#define T3_METAL_REV(_ChipRevId)            ((_ChipRevId) & 0xff)
+#define T3_METAL_REV_A0                     0x00
+#define T3_METAL_REV_A1                     0x01
+#define T3_METAL_REV_B0                     0x00
+#define T3_METAL_REV_B1                     0x01
+#define T3_METAL_REV_B2                     0x02
+
+#define T3_PCI_REG_CLOCK_CTRL               0x74
+
+#define T3_PCI_DISABLE_RX_CLOCK             BIT_10
+#define T3_PCI_DISABLE_TX_CLOCK             BIT_11
+#define T3_PCI_SELECT_ALTERNATE_CLOCK       BIT_12
+#define T3_PCI_POWER_DOWN_PCI_PLL133        BIT_15
+#define T3_PCI_44MHZ_CORE_CLOCK             BIT_18
+
+
+#define T3_PCI_REG_ADDR_REG                 0x78
+#define T3_PCI_REG_DATA_REG                 0x80
+
+#define T3_PCI_MEM_WIN_ADDR_REG             0x7c
+#define T3_PCI_MEM_WIN_DATA_REG             0x84
+
+#define T3_PCI_PM_CAP_REG                   0x48
+
+#define T3_PCI_PM_CAP_PME_D3COLD            BIT_31
+#define T3_PCI_PM_CAP_PME_D3HOT             BIT_30
+
+#define T3_PCI_PM_STATUS_CTRL_REG           0x4c
+
+#define T3_PM_POWER_STATE_MASK              (BIT_0 | BIT_1)
+#define T3_PM_POWER_STATE_D0                BIT_NONE
+#define T3_PM_POWER_STATE_D1                BIT_0
+#define T3_PM_POWER_STATE_D2                BIT_1
+#define T3_PM_POWER_STATE_D3                (BIT_0 | BIT_1)
+
+#define T3_PM_PME_ENABLE                    BIT_8
+#define T3_PM_PME_ASSERTED                  BIT_15
+
+
+/* PCI state register. */
+#define T3_PCI_STATE_REG                    0x70
+
+#define T3_PCI_STATE_FORCE_RESET            BIT_0
+#define T3_PCI_STATE_INT_NOT_ACTIVE         BIT_1
+#define T3_PCI_STATE_CONVENTIONAL_PCI_MODE  BIT_2
+#define T3_PCI_STATE_BUS_SPEED_HIGH         BIT_3
+#define T3_PCI_STATE_32BIT_PCI_BUS          BIT_4
+
+
+/* Broadcom subsystem/subvendor IDs. */
+#define T3_SVID_BROADCOM                            0x14e4
+
+#define T3_SSID_BROADCOM_BCM95700A6                 0x1644
+#define T3_SSID_BROADCOM_BCM95701A5                 0x0001
+#define T3_SSID_BROADCOM_BCM95700T6                 0x0002  /* BCM8002 */
+#define T3_SSID_BROADCOM_BCM95700A9                 0x0003  /* Agilent */
+#define T3_SSID_BROADCOM_BCM95701T1                 0x0005
+#define T3_SSID_BROADCOM_BCM95701T8                 0x0006
+#define T3_SSID_BROADCOM_BCM95701A7                 0x0007  /* Agilent */
+#define T3_SSID_BROADCOM_BCM95701A10                0x0008
+#define T3_SSID_BROADCOM_BCM95701A12                0x8008
+#define T3_SSID_BROADCOM_BCM95703Ax1                0x0009
+#define T3_SSID_BROADCOM_BCM95703Ax2                0x8009
+
+/* 3COM subsystem/subvendor IDs. */
+#define T3_SVID_3COM                                0x10b7
+
+#define T3_SSID_3COM_3C996T                         0x1000
+#define T3_SSID_3COM_3C996BT                        0x1006
+#define T3_SSID_3COM_3C996CT                        0x1002
+#define T3_SSID_3COM_3C997T                         0x1003
+#define T3_SSID_3COM_3C1000T                        0x1007
+#define T3_SSID_3COM_3C940BR01                      0x1008
+
+/* Fiber boards. */
+#define T3_SSID_3COM_3C996SX                        0x1004
+#define T3_SSID_3COM_3C997SX                        0x1005
+
+
+/* Dell subsystem/subvendor IDs. */
+
+#define T3_SVID_DELL                                0x1028
+
+#define T3_SSID_DELL_VIPER                          0x00d1
+#define T3_SSID_DELL_JAGUAR                         0x0106
+#define T3_SSID_DELL_MERLOT                         0x0109
+#define T3_SSID_DELL_SLIM_MERLOT                    0x010a
+
+/* Compaq subsystem/subvendor IDs */
+
+#define T3_SVID_COMPAQ                              0x0e11
+
+#define T3_SSID_COMPAQ_BANSHEE                      0x007c
+#define T3_SSID_COMPAQ_BANSHEE_2                    0x009a
+#define T3_SSID_COMPAQ_CHANGELING                   0x007d
+#define T3_SSID_COMPAQ_NC7780                       0x0085
+#define T3_SSID_COMPAQ_NC7780_2                     0x0099
+
+
+/******************************************************************************/
+/* MII registers. */
+/******************************************************************************/
+
+/* Control register. */
+#define PHY_CTRL_REG                                0x00
+
+#define PHY_CTRL_SPEED_MASK                         (BIT_6 | BIT_13)
+#define PHY_CTRL_SPEED_SELECT_10MBPS                BIT_NONE
+#define PHY_CTRL_SPEED_SELECT_100MBPS               BIT_13
+#define PHY_CTRL_SPEED_SELECT_1000MBPS              BIT_6
+#define PHY_CTRL_COLLISION_TEST_ENABLE              BIT_7
+#define PHY_CTRL_FULL_DUPLEX_MODE                   BIT_8
+#define PHY_CTRL_RESTART_AUTO_NEG                   BIT_9
+#define PHY_CTRL_ISOLATE_PHY                        BIT_10
+#define PHY_CTRL_LOWER_POWER_MODE                   BIT_11
+#define PHY_CTRL_AUTO_NEG_ENABLE                    BIT_12
+#define PHY_CTRL_LOOPBACK_MODE                      BIT_14
+#define PHY_CTRL_PHY_RESET                          BIT_15
+
+
+/* Status register. */
+#define PHY_STATUS_REG                              0x01
+
+#define PHY_STATUS_LINK_PASS                        BIT_2
+#define PHY_STATUS_AUTO_NEG_COMPLETE                BIT_5
+
+
+/* Phy Id registers. */
+#define PHY_ID1_REG                                 0x02
+#define PHY_ID1_OUI_MASK                            0xffff
+
+#define PHY_ID2_REG                                 0x03
+#define PHY_ID2_REV_MASK                            0x000f
+#define PHY_ID2_MODEL_MASK                          0x03f0
+#define PHY_ID2_OUI_MASK                            0xfc00
+
+
+/* Auto-negotiation advertisement register. */
+#define PHY_AN_AD_REG                               0x04
+
+#define PHY_AN_AD_ASYM_PAUSE                        BIT_11
+#define PHY_AN_AD_PAUSE_CAPABLE                     BIT_10
+#define PHY_AN_AD_10BASET_HALF                      BIT_5
+#define PHY_AN_AD_10BASET_FULL                      BIT_6
+#define PHY_AN_AD_100BASETX_HALF                    BIT_7
+#define PHY_AN_AD_100BASETX_FULL                    BIT_8
+#define PHY_AN_AD_PROTOCOL_802_3_CSMA_CD            0x01
+
+
+/* Auto-negotiation Link Partner Ability register. */
+#define PHY_LINK_PARTNER_ABILITY_REG                0x05
+
+#define PHY_LINK_PARTNER_ASYM_PAUSE                 BIT_11
+#define PHY_LINK_PARTNER_PAUSE_CAPABLE              BIT_10
+
+
+/* Auto-negotiation expansion register. */
+#define PHY_AN_EXPANSION_REG                        0x06
+
+
+
+/******************************************************************************/
+/* BCM5400 and BCM5401 phy info. */
+/******************************************************************************/
+
+#define PHY_DEVICE_ID           1
+
+/* OUI: bit 31-10;   Model#: bit 9-4;   Rev# bit 3-0. */
+#define PHY_UNKNOWN_PHY                             0x00000000
+#define PHY_BCM5400_PHY_ID                          0x60008040
+#define PHY_BCM5401_PHY_ID                          0x60008050
+#define PHY_BCM5411_PHY_ID                          0x60008070
+#define PHY_BCM5701_PHY_ID                          0x60008110
+#define PHY_BCM5703_PHY_ID                          0x60008160
+#define PHY_BCM8002_PHY_ID                          0x60010140
+
+#define PHY_BCM5401_B0_REV                          0x1
+#define PHY_BCM5401_B2_REV                          0x3
+#define PHY_BCM5401_C0_REV                          0x6
+
+#define PHY_ID_OUI_MASK                             0xfffffc00
+#define PHY_ID_MODEL_MASK                           0x000003f0
+#define PHY_ID_REV_MASK                             0x0000000f
+#define PHY_ID_MASK                                 (PHY_ID_OUI_MASK |      \
+                                                    PHY_ID_MODEL_MASK)
+
+
+#define UNKNOWN_PHY_ID(x)   ((((x) & PHY_ID_MASK) != PHY_BCM5400_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5401_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5411_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5701_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5703_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM8002_PHY_ID))
+
+
+
+/* 1000Base-T control register. */
+#define BCM540X_1000BASET_CTRL_REG                  0x09
+
+#define BCM540X_AN_AD_1000BASET_HALF                BIT_8
+#define BCM540X_AN_AD_1000BASET_FULL                BIT_9
+#define BCM540X_CONFIG_AS_MASTER                    BIT_11
+#define BCM540X_ENABLE_CONFIG_AS_MASTER             BIT_12
+
+
+/* Extended control register. */
+#define BCM540X_EXT_CTRL_REG                        0x10
+
+#define BCM540X_EXT_CTRL_LINK3_LED_MODE             BIT_1
+#define BCM540X_EXT_CTRL_TBI                        BIT_15
+
+/* PHY extended status register. */
+#define BCM540X_EXT_STATUS_REG                      0x11
+
+#define BCM540X_EXT_STATUS_LINK_PASS                BIT_8
+
+
+/* DSP Coefficient Read/Write Port. */
+#define BCM540X_DSP_RW_PORT                         0x15
+
+
+/* DSP Coeficient Address Register. */
+#define BCM540X_DSP_ADDRESS_REG                     0x17
+
+#define BCM540X_DSP_TAP_NUMBER_MASK                 0x00
+#define BCM540X_DSP_AGC_A                           0x00
+#define BCM540X_DSP_AGC_B                           0x01
+#define BCM540X_DSP_MSE_PAIR_STATUS                 0x02
+#define BCM540X_DSP_SOFT_DECISION                   0x03
+#define BCM540X_DSP_PHASE_REG                       0x04
+#define BCM540X_DSP_SKEW                            0x05
+#define BCM540X_DSP_POWER_SAVER_UPPER_BOUND         0x06
+#define BCM540X_DSP_POWER_SAVER_LOWER_BOUND         0x07
+#define BCM540X_DSP_LAST_ECHO                       0x08
+#define BCM540X_DSP_FREQUENCY                       0x09
+#define BCM540X_DSP_PLL_BANDWIDTH                   0x0a
+#define BCM540X_DSP_PLL_PHASE_OFFSET                0x0b
+
+#define BCM540X_DSP_FILTER_DCOFFSET                 (BIT_10 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT3                    (BIT_8 | BIT_9 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT2                    (BIT_9 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT1                    (BIT_8 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT0                    BIT_11
+#define BCM540X_DSP_FILTER_NEXT3                    (BIT_8 | BIT_9 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT2                    (BIT_9 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT1                    (BIT_8 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT0                    BIT_10
+#define BCM540X_DSP_FILTER_ECHO                     (BIT_8 | BIT_9)
+#define BCM540X_DSP_FILTER_DFE                      BIT_9
+#define BCM540X_DSP_FILTER_FFE                      BIT_8
+
+#define BCM540X_DSP_CONTROL_ALL_FILTERS             BIT_12
+
+#define BCM540X_DSP_SEL_CH_0                        BIT_NONE
+#define BCM540X_DSP_SEL_CH_1                        BIT_13
+#define BCM540X_DSP_SEL_CH_2                        BIT_14
+#define BCM540X_DSP_SEL_CH_3                        (BIT_13 | BIT_14)
+
+#define BCM540X_CONTROL_ALL_CHANNELS                BIT_15
+
+
+/* Auxilliary Control Register (Shadow Register) */
+#define BCM5401_AUX_CTRL                            0x18
+
+#define BCM5401_SHADOW_SEL_MASK                     0x7
+#define BCM5401_SHADOW_SEL_NORMAL                   0x00
+#define BCM5401_SHADOW_SEL_10BASET                  0x01
+#define BCM5401_SHADOW_SEL_POWER_CONTROL            0x02
+#define BCM5401_SHADOW_SEL_IP_PHONE                 0x03
+#define BCM5401_SHADOW_SEL_MISC_TEST1               0x04
+#define BCM5401_SHADOW_SEL_MISC_TEST2               0x05
+#define BCM5401_SHADOW_SEL_IP_PHONE_SEED            0x06
+
+
+/* Shadow register selector == '000' */
+#define BCM5401_SHDW_NORMAL_DIAG_MODE               BIT_3
+#define BCM5401_SHDW_NORMAL_DISABLE_MBP             BIT_4
+#define BCM5401_SHDW_NORMAL_DISABLE_LOW_PWR         BIT_5
+#define BCM5401_SHDW_NORMAL_DISABLE_INV_PRF         BIT_6
+#define BCM5401_SHDW_NORMAL_DISABLE_PRF             BIT_7
+#define BCM5401_SHDW_NORMAL_RX_SLICING_NORMAL       BIT_NONE
+#define BCM5401_SHDW_NORMAL_RX_SLICING_4D           BIT_8
+#define BCM5401_SHDW_NORMAL_RX_SLICING_3LVL_1D      BIT_9
+#define BCM5401_SHDW_NORMAL_RX_SLICING_5LVL_1D      (BIT_8 | BIT_9)
+#define BCM5401_SHDW_NORMAL_TX_6DB_CODING           BIT_10
+#define BCM5401_SHDW_NORMAL_ENABLE_SM_DSP_CLOCK     BIT_11
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_4NS       BIT_NONE
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_5NS       BIT_12
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_3NS       BIT_13
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_0NS       (BIT_12 | BIT_13)
+#define BCM5401_SHDW_NORMAL_EXT_PACKET_LENGTH       BIT_14
+#define BCM5401_SHDW_NORMAL_EXTERNAL_LOOPBACK       BIT_15
+
+
+/* Auxilliary status summary. */
+#define BCM540X_AUX_STATUS_REG                      0x19
+
+#define BCM540X_AUX_LINK_PASS                       BIT_2
+#define BCM540X_AUX_SPEED_MASK                      (BIT_8 | BIT_9 | BIT_10)
+#define BCM540X_AUX_10BASET_HD                      BIT_8
+#define BCM540X_AUX_10BASET_FD                      BIT_9
+#define BCM540X_AUX_100BASETX_HD                    (BIT_8 | BIT_9)
+#define BCM540X_AUX_100BASET4                       BIT_10
+#define BCM540X_AUX_100BASETX_FD                    (BIT_8 | BIT_10)
+#define BCM540X_AUX_100BASET_HD                     (BIT_9 | BIT_10)
+#define BCM540X_AUX_100BASET_FD                     (BIT_8 | BIT_9 | BIT_10)
+
+
+/* Interrupt status. */
+#define BCM540X_INT_STATUS_REG                      0x1a
+
+#define BCM540X_INT_LINK_CHANGE                     BIT_1
+#define BCM540X_INT_SPEED_CHANGE                    BIT_2
+#define BCM540X_INT_DUPLEX_CHANGE                   BIT_3
+#define BCM540X_INT_AUTO_NEG_PAGE_RX                BIT_10
+
+
+/* Interrupt mask register. */
+#define BCM540X_INT_MASK_REG                        0x1b
+
+
+
+/******************************************************************************/
+/* Register definitions. */
+/******************************************************************************/
+
+typedef volatile LM_UINT8 T3_8BIT_REGISTER, *PT3_8BIT_REGISTER;
+typedef volatile LM_UINT16 T3_16BIT_REGISTER, *PT3_16BIT_REGISTER;
+typedef volatile LM_UINT32 T3_32BIT_REGISTER, *PT3_32BIT_REGISTER;
+
+typedef struct {
+    /* Big endian format. */
+    T3_32BIT_REGISTER High;
+    T3_32BIT_REGISTER Low;
+} T3_64BIT_REGISTER, *PT3_64BIT_REGISTER;
+
+typedef T3_64BIT_REGISTER T3_64BIT_HOST_ADDR, *PT3_64BIT_HOST_ADDR;
+
+#define T3_NUM_OF_DMA_DESC    256
+#define T3_NUM_OF_MBUF        768
+
+typedef struct 
+{
+  T3_64BIT_REGISTER host_addr;
+  T3_32BIT_REGISTER nic_mbuf;
+  T3_16BIT_REGISTER len;
+  T3_16BIT_REGISTER cqid_sqid;
+  T3_32BIT_REGISTER flags;
+  T3_32BIT_REGISTER opaque1;
+  T3_32BIT_REGISTER opaque2;
+  T3_32BIT_REGISTER opaque3;
+}T3_DMA_DESC, *PT3_DMA_DESC;
+
+
+
+/******************************************************************************/
+/* Ring control block. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_REGISTER HostRingAddr;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            T3_16BIT_REGISTER MaxLen;
+            T3_16BIT_REGISTER Flags;
+#else /* BIG_ENDIAN_HOST */
+            T3_16BIT_REGISTER Flags;
+            T3_16BIT_REGISTER MaxLen;
+#endif
+        } s;
+
+        T3_32BIT_REGISTER MaxLen_Flags;
+    } u;
+
+    T3_32BIT_REGISTER NicRingAddr;
+} T3_RCB, *PT3_RCB;
+
+#define T3_RCB_FLAG_USE_EXT_RECV_BD                     BIT_0
+#define T3_RCB_FLAG_RING_DISABLED                       BIT_1
+
+
+
+/******************************************************************************/
+/* Status block. */
+/******************************************************************************/
+
+/* 
+ * Size of status block is actually 0x50 bytes.  Use 0x80 bytes for
+ * cache line alignment. 
+ */
+#define T3_STATUS_BLOCK_SIZE                                    0x80
+
+typedef struct {
+    volatile LM_UINT32 Status;
+    #define STATUS_BLOCK_UPDATED                                BIT_0
+    #define STATUS_BLOCK_LINK_CHANGED_STATUS                    BIT_1
+    #define STATUS_BLOCK_ERROR                                  BIT_2
+
+    volatile LM_UINT32 StatusTag;
+
+#ifdef BIG_ENDIAN_HOST
+    volatile LM_UINT16 RcvStdConIdx;
+    volatile LM_UINT16 RcvJumboConIdx;
+
+    volatile LM_UINT16 Reserved2;
+    volatile LM_UINT16 RcvMiniConIdx;
+
+    struct {
+        volatile LM_UINT16 SendConIdx;   /* Send consumer index. */
+        volatile LM_UINT16 RcvProdIdx;   /* Receive producer index. */
+    } Idx[16];
+#else /* BIG_ENDIAN_HOST */
+    volatile LM_UINT16 RcvJumboConIdx;
+    volatile LM_UINT16 RcvStdConIdx;
+
+    volatile LM_UINT16 RcvMiniConIdx;
+    volatile LM_UINT16 Reserved2;
+
+    struct {
+        volatile LM_UINT16 RcvProdIdx;   /* Receive producer index. */
+        volatile LM_UINT16 SendConIdx;   /* Send consumer index. */
+    } Idx[16];
+#endif
+} T3_STATUS_BLOCK, *PT3_STATUS_BLOCK;
+
+
+
+/******************************************************************************/
+/* Receive buffer descriptors. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr;
+
+#ifdef BIG_ENDIAN_HOST
+    volatile LM_UINT16 Index;
+    volatile LM_UINT16 Len;
+
+    volatile LM_UINT16 Type;
+    volatile LM_UINT16 Flags;
+
+    volatile LM_UINT16 IpCksum;
+    volatile LM_UINT16 TcpUdpCksum;
+
+    volatile LM_UINT16 ErrorFlag;
+    volatile LM_UINT16 VlanTag;
+#else /* BIG_ENDIAN_HOST */
+    volatile LM_UINT16 Len;
+    volatile LM_UINT16 Index;
+
+    volatile LM_UINT16 Flags;
+    volatile LM_UINT16 Type;
+
+    volatile LM_UINT16 TcpUdpCksum;
+    volatile LM_UINT16 IpCksum;
+
+    volatile LM_UINT16 VlanTag;
+    volatile LM_UINT16 ErrorFlag;
+#endif
+
+    volatile LM_UINT32 Reserved;
+    volatile LM_UINT32 Opaque;
+} T3_RCV_BD, *PT3_RCV_BD;
+
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr[3];
+
+#ifdef BIG_ENDIAN_HOST
+    LM_UINT16 Len1;
+    LM_UINT16 Len2;
+
+    LM_UINT16 Len3;
+    LM_UINT16 Reserved1;
+#else /* BIG_ENDIAN_HOST */
+    LM_UINT16 Len2;
+    LM_UINT16 Len1;
+
+    LM_UINT16 Reserved1;
+    LM_UINT16 Len3;
+#endif
+
+    T3_RCV_BD StdRcvBd;
+} T3_EXT_RCV_BD, *PT3_EXT_RCV_BD;
+
+
+/* Error flags. */
+#define RCV_BD_ERR_BAD_CRC                          0x0001
+#define RCV_BD_ERR_COLL_DETECT                      0x0002
+#define RCV_BD_ERR_LINK_LOST_DURING_PKT             0x0004
+#define RCV_BD_ERR_PHY_DECODE_ERR                   0x0008
+#define RCV_BD_ERR_ODD_NIBBLED_RCVD_MII             0x0010
+#define RCV_BD_ERR_MAC_ABORT                        0x0020
+#define RCV_BD_ERR_LEN_LT_64                        0x0040
+#define RCV_BD_ERR_TRUNC_NO_RESOURCES               0x0080
+#define RCV_BD_ERR_GIANT_FRAME_RCVD                 0x0100
+
+
+/* Buffer descriptor flags. */
+#define RCV_BD_FLAG_END                             0x0004
+#define RCV_BD_FLAG_JUMBO_RING                      0x0020
+#define RCV_BD_FLAG_VLAN_TAG                        0x0040
+#define RCV_BD_FLAG_FRAME_HAS_ERROR                 0x0400
+#define RCV_BD_FLAG_MINI_RING                       0x0800
+#define RCV_BD_FLAG_IP_CHKSUM_FIELD                 0x1000
+#define RCV_BD_FLAG_TCP_UDP_CHKSUM_FIELD            0x2000
+#define RCV_BD_FLAG_TCP_PACKET                      0x4000
+
+
+
+/******************************************************************************/
+/* Send buffer descriptor. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            LM_UINT16 Len;
+            LM_UINT16 Flags;
+#else /* BIG_ENDIAN_HOST */
+            LM_UINT16 Flags;
+            LM_UINT16 Len;
+#endif
+        } s1;
+
+        LM_UINT32 Len_Flags;
+    } u1;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            LM_UINT16 Reserved;
+            LM_UINT16 VlanTag;
+#else /* BIG_ENDIAN_HOST */
+            LM_UINT16 VlanTag;
+            LM_UINT16 Reserved;
+#endif
+        } s2;
+
+        LM_UINT32 VlanTag;
+    } u2;
+} T3_SND_BD, *PT3_SND_BD;
+
+
+/* Send buffer descriptor flags. */
+#define SND_BD_FLAG_TCP_UDP_CKSUM                   0x0001
+#define SND_BD_FLAG_IP_CKSUM                        0x0002
+#define SND_BD_FLAG_END                             0x0004
+#define SND_BD_FLAG_IP_FRAG                         0x0008
+#define SND_BD_FLAG_IP_FRAG_END                     0x0010
+#define SND_BD_FLAG_VLAN_TAG                        0x0040
+#define SND_BD_FLAG_COAL_NOW                        0x0080
+#define SND_BD_FLAG_CPU_PRE_DMA                     0x0100
+#define SND_BD_FLAG_CPU_POST_DMA                    0x0200
+#define SND_BD_FLAG_INSERT_SRC_ADDR                 0x1000
+#define SND_BD_FLAG_CHOOSE_SRC_ADDR                 0x6000
+#define SND_BD_FLAG_DONT_GEN_CRC                    0x8000
+
+/* MBUFs */
+typedef struct T3_MBUF_FRAME_DESC {
+#ifdef BIG_ENDIAN_HOST
+  LM_UINT32 status_control;
+  union {
+    struct {
+      LM_UINT8 cqid;
+      LM_UINT8 reserved1;
+      LM_UINT16 length;
+    }s1;
+    LM_UINT32 word;
+  }u1;
+  union {
+    struct 
+    {
+      LM_UINT16 ip_hdr_start;
+      LM_UINT16 tcp_udp_hdr_start;
+    }s2;
+
+    LM_UINT32 word;
+  }u2;
+
+  union {
+    struct {
+      LM_UINT16 data_start;
+      LM_UINT16 vlan_id;
+    }s3;
+    
+    LM_UINT32 word;
+  }u3;
+
+  union {
+    struct {
+      LM_UINT16 ip_checksum;
+      LM_UINT16 tcp_udp_checksum;
+    }s4;
+
+    LM_UINT32 word;
+  }u4;
+
+  union {
+    struct {
+      LM_UINT16 pseudo_checksum;
+      LM_UINT16 checksum_status;
+    }s5;
+
+    LM_UINT32 word;
+  }u5;
+  
+  union {
+    struct {
+      LM_UINT16 rule_match;
+      LM_UINT8 class;
+      LM_UINT8 rupt;
+    }s6;
+
+    LM_UINT32 word;
+  }u6;
+
+  union {
+    struct {
+      LM_UINT16 reserved2;
+      LM_UINT16 mbuf_num;
+    }s7;
+
+    LM_UINT32 word;
+  }u7;
+
+  LM_UINT32 reserved3;
+  LM_UINT32 reserved4;
+#else
+  LM_UINT32 status_control;
+  union {
+    struct {
+      LM_UINT16 length;
+      LM_UINT8  reserved1;
+      LM_UINT8  cqid;
+    }s1;
+    LM_UINT32 word;
+  }u1;
+  union {
+    struct 
+    {
+      LM_UINT16 tcp_udp_hdr_start;
+      LM_UINT16 ip_hdr_start;
+    }s2;
+
+    LM_UINT32 word;
+  }u2;
+
+  union {
+    struct {
+      LM_UINT16 vlan_id;
+      LM_UINT16 data_start;
+    }s3;
+    
+    LM_UINT32 word;
+  }u3;
+
+  union {
+    struct {
+      LM_UINT16 tcp_udp_checksum;
+      LM_UINT16 ip_checksum;
+    }s4;
+
+    LM_UINT32 word;
+  }u4;
+
+  union {
+    struct {
+      LM_UINT16 checksum_status;
+      LM_UINT16 pseudo_checksum;
+    }s5;
+
+    LM_UINT32 word;
+  }u5;
+  
+  union {
+    struct {
+      LM_UINT8 rupt;
+      LM_UINT8 class;
+      LM_UINT16 rule_match;
+    }s6;
+
+    LM_UINT32 word;
+  }u6;
+
+  union {
+    struct {
+      LM_UINT16 mbuf_num;
+      LM_UINT16 reserved2;
+    }s7;
+
+    LM_UINT32 word;
+  }u7;
+
+  LM_UINT32 reserved3;
+  LM_UINT32 reserved4;
+#endif
+}T3_MBUF_FRAME_DESC,*PT3_MBUF_FRAME_DESC;
+
+typedef struct T3_MBUF_HDR {
+  union {
+    struct {
+      unsigned int C:1;
+      unsigned int F:1;
+      unsigned int reserved1:7;
+      unsigned int next_mbuf:16;
+      unsigned int length:7;
+    }s1;
+    
+    LM_UINT32 word;
+  }u1;
+  
+  LM_UINT32 next_frame_ptr;
+}T3_MBUF_HDR, *PT3_MBUF_HDR;
+
+typedef struct T3_MBUF
+{
+  T3_MBUF_HDR hdr;
+  union
+  {
+    struct {
+      T3_MBUF_FRAME_DESC frame_hdr;
+      LM_UINT32 data[20];
+    }s1;
+
+    struct {
+      LM_UINT32 data[30];
+    }s2;
+  }body;
+}T3_MBUF, *PT3_MBUF;
+
+#define T3_MBUF_BASE   (T3_NIC_MBUF_POOL_ADDR >> 7)
+#define T3_MBUF_END    ((T3_NIC_MBUF_POOL_ADDR + T3_NIC_MBUF_POOL_SIZE) >> 7)
+
+
+
+/******************************************************************************/
+/* Statistics block. */
+/******************************************************************************/
+
+typedef struct {
+    LM_UINT8 Reserved0[0x400-0x300];
+
+    /* Statistics maintained by Receive MAC. */
+    T3_64BIT_REGISTER ifHCInOctets;
+    T3_64BIT_REGISTER Reserved1;
+    T3_64BIT_REGISTER etherStatsFragments;
+    T3_64BIT_REGISTER ifHCInUcastPkts;
+    T3_64BIT_REGISTER ifHCInMulticastPkts;
+    T3_64BIT_REGISTER ifHCInBroadcastPkts;
+    T3_64BIT_REGISTER dot3StatsFCSErrors;
+    T3_64BIT_REGISTER dot3StatsAlignmentErrors;
+    T3_64BIT_REGISTER xonPauseFramesReceived;
+    T3_64BIT_REGISTER xoffPauseFramesReceived;
+    T3_64BIT_REGISTER macControlFramesReceived;
+    T3_64BIT_REGISTER xoffStateEntered;
+    T3_64BIT_REGISTER dot3StatsFramesTooLong;
+    T3_64BIT_REGISTER etherStatsJabbers;
+    T3_64BIT_REGISTER etherStatsUndersizePkts;
+    T3_64BIT_REGISTER inRangeLengthError;
+    T3_64BIT_REGISTER outRangeLengthError;
+    T3_64BIT_REGISTER etherStatsPkts64Octets;
+    T3_64BIT_REGISTER etherStatsPkts65Octetsto127Octets;
+    T3_64BIT_REGISTER etherStatsPkts128Octetsto255Octets;
+    T3_64BIT_REGISTER etherStatsPkts256Octetsto511Octets;
+    T3_64BIT_REGISTER etherStatsPkts512Octetsto1023Octets;
+    T3_64BIT_REGISTER etherStatsPkts1024Octetsto1522Octets;
+    T3_64BIT_REGISTER etherStatsPkts1523Octetsto2047Octets;
+    T3_64BIT_REGISTER etherStatsPkts2048Octetsto4095Octets;
+    T3_64BIT_REGISTER etherStatsPkts4096Octetsto8191Octets;
+    T3_64BIT_REGISTER etherStatsPkts8192Octetsto9022Octets;
+
+    T3_64BIT_REGISTER Unused1[37];
+
+    /* Statistics maintained by Transmit MAC. */
+    T3_64BIT_REGISTER ifHCOutOctets;
+    T3_64BIT_REGISTER Reserved2;
+    T3_64BIT_REGISTER etherStatsCollisions;
+    T3_64BIT_REGISTER outXonSent;
+    T3_64BIT_REGISTER outXoffSent;
+    T3_64BIT_REGISTER flowControlDone;
+    T3_64BIT_REGISTER dot3StatsInternalMacTransmitErrors;
+    T3_64BIT_REGISTER dot3StatsSingleCollisionFrames;
+    T3_64BIT_REGISTER dot3StatsMultipleCollisionFrames;
+    T3_64BIT_REGISTER dot3StatsDeferredTransmissions;
+    T3_64BIT_REGISTER Reserved3;
+    T3_64BIT_REGISTER dot3StatsExcessiveCollisions;
+    T3_64BIT_REGISTER dot3StatsLateCollisions;
+    T3_64BIT_REGISTER dot3Collided2Times;
+    T3_64BIT_REGISTER dot3Collided3Times;
+    T3_64BIT_REGISTER dot3Collided4Times;
+    T3_64BIT_REGISTER dot3Collided5Times;
+    T3_64BIT_REGISTER dot3Collided6Times;
+    T3_64BIT_REGISTER dot3Collided7Times;
+    T3_64BIT_REGISTER dot3Collided8Times;
+    T3_64BIT_REGISTER dot3Collided9Times;
+    T3_64BIT_REGISTER dot3Collided10Times;
+    T3_64BIT_REGISTER dot3Collided11Times;
+    T3_64BIT_REGISTER dot3Collided12Times;
+    T3_64BIT_REGISTER dot3Collided13Times;
+    T3_64BIT_REGISTER dot3Collided14Times;
+    T3_64BIT_REGISTER dot3Collided15Times;
+    T3_64BIT_REGISTER ifHCOutUcastPkts;
+    T3_64BIT_REGISTER ifHCOutMulticastPkts;
+    T3_64BIT_REGISTER ifHCOutBroadcastPkts;
+    T3_64BIT_REGISTER dot3StatsCarrierSenseErrors;
+    T3_64BIT_REGISTER ifOutDiscards;
+    T3_64BIT_REGISTER ifOutErrors;
+
+    T3_64BIT_REGISTER Unused2[31];
+
+    /* Statistics maintained by Receive List Placement. */
+    T3_64BIT_REGISTER COSIfHCInPkts[16];
+    T3_64BIT_REGISTER COSFramesDroppedDueToFilters;
+    T3_64BIT_REGISTER nicDmaWriteQueueFull;
+    T3_64BIT_REGISTER nicDmaWriteHighPriQueueFull;
+    T3_64BIT_REGISTER nicNoMoreRxBDs;
+    T3_64BIT_REGISTER ifInDiscards;
+    T3_64BIT_REGISTER ifInErrors;
+    T3_64BIT_REGISTER nicRecvThresholdHit;
+
+    T3_64BIT_REGISTER Unused3[9];
+
+    /* Statistics maintained by Send Data Initiator. */
+    T3_64BIT_REGISTER COSIfHCOutPkts[16];
+    T3_64BIT_REGISTER nicDmaReadQueueFull;
+    T3_64BIT_REGISTER nicDmaReadHighPriQueueFull;
+    T3_64BIT_REGISTER nicSendDataCompQueueFull;
+
+    /* Statistics maintained by Host Coalescing. */
+    T3_64BIT_REGISTER nicRingSetSendProdIndex;
+    T3_64BIT_REGISTER nicRingStatusUpdate;
+    T3_64BIT_REGISTER nicInterrupts;
+    T3_64BIT_REGISTER nicAvoidedInterrupts;
+    T3_64BIT_REGISTER nicSendThresholdHit;
+
+    LM_UINT8 Reserved4[0xb00-0x9c0];
+} T3_STATS_BLOCK, *PT3_STATS_BLOCK;
+
+
+
+/******************************************************************************/
+/* PCI configuration registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_16BIT_REGISTER VendorId;
+    T3_16BIT_REGISTER DeviceId;
+
+    T3_16BIT_REGISTER Command;
+    T3_16BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER ClassCodeRevId;
+
+    T3_8BIT_REGISTER CacheLineSize;
+    T3_8BIT_REGISTER LatencyTimer;
+    T3_8BIT_REGISTER HeaderType;
+    T3_8BIT_REGISTER Bist;
+
+    T3_32BIT_REGISTER MemBaseAddrLow;
+    T3_32BIT_REGISTER MemBaseAddrHigh;
+
+    LM_UINT8 Unused1[20];
+
+    T3_16BIT_REGISTER SubsystemVendorId;
+    T3_16BIT_REGISTER SubsystemId;
+
+    T3_32BIT_REGISTER RomBaseAddr;
+
+    T3_8BIT_REGISTER PciXCapiblityPtr;
+    LM_UINT8 Unused2[7];
+
+    T3_8BIT_REGISTER IntLine;
+    T3_8BIT_REGISTER IntPin;
+    T3_8BIT_REGISTER MinGnt;
+    T3_8BIT_REGISTER MaxLat;
+
+    T3_8BIT_REGISTER PciXCapabilities;
+    T3_8BIT_REGISTER PmCapabilityPtr;
+    T3_16BIT_REGISTER PciXCommand;
+
+    T3_32BIT_REGISTER PciXStatus;
+
+    T3_8BIT_REGISTER PmCapabilityId;
+    T3_8BIT_REGISTER VpdCapabilityPtr;
+    T3_16BIT_REGISTER PmCapabilities;
+
+    T3_16BIT_REGISTER PmCtrlStatus;
+    #define PM_CTRL_PME_STATUS            BIT_15
+    #define PM_CTRL_PME_ENABLE            BIT_8
+    #define PM_CTRL_PME_POWER_STATE_D0    0
+    #define PM_CTRL_PME_POWER_STATE_D1    1
+    #define PM_CTRL_PME_POWER_STATE_D2    2
+    #define PM_CTRL_PME_POWER_STATE_D3H   3
+
+    T3_8BIT_REGISTER BridgeSupportExt;
+    T3_8BIT_REGISTER PmData;
+
+    T3_8BIT_REGISTER VpdCapabilityId;
+    T3_8BIT_REGISTER MsiCapabilityPtr;
+    T3_16BIT_REGISTER VpdAddrFlag;
+    #define VPD_FLAG_WRITE      (1 << 15)
+    #define VPD_FLAG_RW_MASK    (1 << 15)
+    #define VPD_FLAG_READ       0
+
+
+    T3_32BIT_REGISTER VpdData;
+
+    T3_8BIT_REGISTER MsiCapabilityId;
+    T3_8BIT_REGISTER NextCapabilityPtr;
+    T3_16BIT_REGISTER MsiCtrl;
+    #define MSI_CTRL_64BIT_CAP     (1 << 7)
+    #define MSI_CTRL_MSG_ENABLE(x) (x << 4)
+    #define MSI_CTRL_MSG_CAP(x)    (x << 1)
+    #define MSI_CTRL_ENABLE        (1 << 0)
+  
+
+    T3_32BIT_REGISTER MsiAddrLow;
+    T3_32BIT_REGISTER MsiAddrHigh;
+
+    T3_16BIT_REGISTER MsiData;
+    T3_16BIT_REGISTER Unused3;
+
+    T3_32BIT_REGISTER MiscHostCtrl;
+    #define MISC_HOST_CTRL_CLEAR_INT                        BIT_0
+    #define MISC_HOST_CTRL_MASK_PCI_INT                     BIT_1
+    #define MISC_HOST_CTRL_ENABLE_ENDIAN_BYTE_SWAP          BIT_2
+    #define MISC_HOST_CTRL_ENABLE_ENDIAN_WORD_SWAP          BIT_3
+    #define MISC_HOST_CTRL_ENABLE_PCI_STATE_REG_RW          BIT_4
+    #define MISC_HOST_CTRL_ENABLE_CLK_REG_RW                BIT_5
+    #define MISC_HOST_CTRL_ENABLE_REG_WORD_SWAP             BIT_6
+    #define MISC_HOST_CTRL_ENABLE_INDIRECT_ACCESS           BIT_7
+    #define MISC_HOST_CTRL_ENABLE_INT_MASK_MODE             BIT_8
+    #define MISC_HOST_CTRL_ENABLE_TAGGED_STATUS_MODE        BIT_9
+
+    T3_32BIT_REGISTER DmaReadWriteCtrl;
+    #define DMA_CTRL_WRITE_BOUNDARY_MASK            (BIT_11 | BIT_12 | BIT_13)
+    #define DMA_CTRL_WRITE_BOUNDARY_DISABLE         0
+    #define DMA_CTRL_WRITE_BOUNDARY_16              BIT_11
+    #define DMA_CTRL_WRITE_BOUNDARY_32              BIT_12
+    #define DMA_CTRL_WRITE_BOUNDARY_64              (BIT_12 | BIT_11)
+    #define DMA_CTRL_WRITE_BOUNDARY_128             BIT_13
+    #define DMA_CTRL_WRITE_BOUNDARY_256             (BIT_13 | BIT_11)
+    #define DMA_CTRL_WRITE_BOUNDARY_512             (BIT_13 | BIT_12)
+    #define DMA_CTRL_WRITE_BOUNDARY_1024            (BIT_13 | BIT_12 | BIT_11)
+    #define DMA_CTRL_WRITE_ONE_DMA_AT_ONCE          BIT_14
+
+
+    T3_32BIT_REGISTER PciState;
+    #define T3_PCI_STATE_FORCE_PCI_RESET                    BIT_0
+    #define T3_PCI_STATE_INTERRUPT_NOT_ACTIVE               BIT_1
+    #define T3_PCI_STATE_NOT_PCI_X_BUS                      BIT_2
+    #define T3_PCI_STATE_HIGH_BUS_SPEED                     BIT_3
+    #define T3_PCI_STATE_32BIT_PCI_BUS                      BIT_4
+    #define T3_PCI_STATE_PCI_ROM_ENABLE                     BIT_5
+    #define T3_PCI_STATE_PCI_ROM_RETRY_ENABLE               BIT_6
+    #define T3_PCI_STATE_FLAT_VIEW                          BIT_8
+
+    T3_32BIT_REGISTER ClockCtrl;
+    #define T3_PCI_CLKCTRL_TXCPU_CLK_DISABLE                BIT_11
+    #define T3_PCI_CLKCTRL_RXCPU_CLK_DISABLE                BIT_10
+    #define T3_PCI_CLKCTRL_CORE_CLK_DISABLE                 BIT_9
+
+    T3_32BIT_REGISTER RegBaseAddr;
+
+    T3_32BIT_REGISTER MemWindowBaseAddr;
+    
+#ifdef NIC_CPU_VIEW
+  /* These registers are ONLY visible to NIC CPU */
+    T3_32BIT_REGISTER PowerConsumed;
+    T3_32BIT_REGISTER PowerDissipated;
+#else /* NIC_CPU_VIEW */
+    T3_32BIT_REGISTER RegData;
+    T3_32BIT_REGISTER MemWindowData;
+#endif /* !NIC_CPU_VIEW */
+
+    T3_32BIT_REGISTER ModeCtrl;
+
+    T3_32BIT_REGISTER MiscCfg;
+
+    T3_32BIT_REGISTER MiscLocalCtrl;
+
+    T3_32BIT_REGISTER Unused4;
+
+    /* NOTE: Big/Little-endian clarification needed.  Are these register */
+    /* in big or little endian formate. */
+    T3_64BIT_REGISTER StdRingProdIdx;
+    T3_64BIT_REGISTER RcvRetRingConIdx;
+    T3_64BIT_REGISTER SndProdIdx;
+
+    LM_UINT8 Unused5[80];
+} T3_PCI_CONFIGURATION, *PT3_PCI_CONFIGURATION;
+
+
+
+/******************************************************************************/
+/* Mac control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* MAC mode control. */
+    T3_32BIT_REGISTER Mode;
+    #define MAC_MODE_GLOBAL_RESET                       BIT_0
+    #define MAC_MODE_HALF_DUPLEX                        BIT_1
+    #define MAC_MODE_PORT_MODE_MASK                     (BIT_2 | BIT_3)
+    #define MAC_MODE_PORT_MODE_TBI                      (BIT_2 | BIT_3)
+    #define MAC_MODE_PORT_MODE_GMII                     BIT_3
+    #define MAC_MODE_PORT_MODE_MII                      BIT_2
+    #define MAC_MODE_PORT_MODE_NONE                     BIT_NONE
+    #define MAC_MODE_PORT_INTERNAL_LOOPBACK             BIT_4
+    #define MAC_MODE_TAGGED_MAC_CONTROL                 BIT_7
+    #define MAC_MODE_TX_BURSTING                        BIT_8
+    #define MAC_MODE_MAX_DEFER                          BIT_9
+    #define MAC_MODE_LINK_POLARITY                      BIT_10
+    #define MAC_MODE_ENABLE_RX_STATISTICS               BIT_11
+    #define MAC_MODE_CLEAR_RX_STATISTICS                BIT_12
+    #define MAC_MODE_FLUSH_RX_STATISTICS                BIT_13
+    #define MAC_MODE_ENABLE_TX_STATISTICS               BIT_14
+    #define MAC_MODE_CLEAR_TX_STATISTICS                BIT_15
+    #define MAC_MODE_FLUSH_TX_STATISTICS                BIT_16
+    #define MAC_MODE_SEND_CONFIGS                       BIT_17
+    #define MAC_MODE_DETECT_MAGIC_PACKET_ENABLE         BIT_18
+    #define MAC_MODE_ACPI_POWER_ON_ENABLE               BIT_19
+    #define MAC_MODE_ENABLE_MIP                         BIT_20
+    #define MAC_MODE_ENABLE_TDE                         BIT_21
+    #define MAC_MODE_ENABLE_RDE                         BIT_22
+    #define MAC_MODE_ENABLE_FHDE                        BIT_23
+
+    /* MAC status */
+    T3_32BIT_REGISTER Status;
+    #define MAC_STATUS_PCS_SYNCED                       BIT_0
+    #define MAC_STATUS_SIGNAL_DETECTED                  BIT_1
+    #define MAC_STATUS_RECEIVING_CFG                    BIT_2
+    #define MAC_STATUS_CFG_CHANGED                      BIT_3
+    #define MAC_STATUS_SYNC_CHANGED                     BIT_4
+    #define MAC_STATUS_PORT_DECODE_ERROR                BIT_10
+    #define MAC_STATUS_LINK_STATE_CHANGED               BIT_12
+    #define MAC_STATUS_MI_COMPLETION                    BIT_22
+    #define MAC_STATUS_MI_INTERRUPT                     BIT_23
+    #define MAC_STATUS_AP_ERROR                         BIT_24
+    #define MAC_STATUS_ODI_ERROR                        BIT_25
+    #define MAC_STATUS_RX_STATS_OVERRUN                 BIT_26
+    #define MAC_STATUS_TX_STATS_OVERRUN                 BIT_27
+
+    /* Event Enable */
+    T3_32BIT_REGISTER MacEvent;
+    #define MAC_EVENT_ENABLE_PORT_DECODE_ERR            BIT_10
+    #define MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN    BIT_12
+    #define MAC_EVENT_ENABLE_MI_COMPLETION              BIT_22
+    #define MAC_EVENT_ENABLE_MI_INTERRUPT               BIT_23
+    #define MAC_EVENT_ENABLE_AP_ERROR                   BIT_24
+    #define MAC_EVENT_ENABLE_ODI_ERROR                  BIT_25
+    #define MAC_EVENT_ENABLE_RX_STATS_OVERRUN           BIT_26
+    #define MAC_EVENT_ENABLE_TX_STATS_OVERRUN           BIT_27
+
+    /* Led control. */
+    T3_32BIT_REGISTER LedCtrl;
+    #define LED_CTRL_OVERRIDE_LINK_LED                  BIT_0
+    #define LED_CTRL_1000MBPS_LED_ON                    BIT_1
+    #define LED_CTRL_100MBPS_LED_ON                     BIT_2
+    #define LED_CTRL_10MBPS_LED_ON                      BIT_3
+    #define LED_CTRL_OVERRIDE_TRAFFIC_LED               BIT_4
+    #define LED_CTRL_BLINK_TRAFFIC_LED                  BIT_5
+    #define LED_CTRL_TRAFFIC_LED                        BIT_6
+    #define LED_CTRL_1000MBPS_LED_STATUS                BIT_7
+    #define LED_CTRL_100MBPS_LED_STATUS                 BIT_8
+    #define LED_CTRL_10MBPS_LED_STATUS                  BIT_9
+    #define LED_CTRL_TRAFFIC_LED_STATUS                 BIT_10
+    #define LED_CTRL_MAC_MODE                           BIT_NONE
+    #define LED_CTRL_PHY_MODE_1                         BIT_11
+    #define LED_CTRL_PHY_MODE_2                         BIT_12
+    #define LED_CTRL_BLINK_RATE_MASK                    0x7ff80000
+    #define LED_CTRL_OVERRIDE_BLINK_PERIOD              BIT_19
+    #define LED_CTRL_OVERRIDE_BLINK_RATE                BIT_31
+
+    /* MAC addresses. */
+    struct {
+        T3_32BIT_REGISTER High;             /* Upper 2 bytes. */
+        T3_32BIT_REGISTER Low;              /* Lower 4 bytes. */
+    } MacAddr[4];
+
+    /* ACPI Mbuf pointer. */
+    T3_32BIT_REGISTER AcpiMbufPtr;
+
+    /* ACPI Length and Offset. */
+    T3_32BIT_REGISTER AcpiLengthOffset;
+    #define ACPI_LENGTH_MASK                            0xffff
+    #define ACPI_OFFSET_MASK                            0x0fff0000
+    #define ACPI_LENGTH(x)                              x
+    #define ACPI_OFFSET(x)                              ((x) << 16)
+
+    /* Transmit random backoff. */
+    T3_32BIT_REGISTER TxBackoffSeed;
+    #define MAC_TX_BACKOFF_SEED_MASK                    0x3ff
+
+    /* Receive MTU */
+    T3_32BIT_REGISTER MtuSize;
+    #define MAC_RX_MTU_MASK                             0xffff
+
+    /* Gigabit PCS Test. */
+    T3_32BIT_REGISTER PcsTest;
+    #define MAC_PCS_TEST_DATA_PATTERN_MASK              0x0fffff
+    #define MAC_PCS_TEST_ENABLE                         BIT_20
+
+    /* Transmit Gigabit Auto-Negotiation. */
+    T3_32BIT_REGISTER TxAutoNeg;
+    #define MAC_AN_TX_AN_DATA_MASK                      0xffff
+
+    /* Receive Gigabit Auto-Negotiation. */
+    T3_32BIT_REGISTER RxAutoNeg;
+    #define MAC_AN_RX_AN_DATA_MASK                      0xffff
+
+    /* MI Communication. */
+    T3_32BIT_REGISTER MiCom;
+    #define MI_COM_CMD_MASK                             (BIT_26 | BIT_27)
+    #define MI_COM_CMD_WRITE                            BIT_26
+    #define MI_COM_CMD_READ                             BIT_27
+    #define MI_COM_READ_FAILED                          BIT_28
+    #define MI_COM_START                                BIT_29
+    #define MI_COM_BUSY                                 BIT_29
+
+    #define MI_COM_PHY_ADDR_MASK                        0x1f
+    #define MI_COM_FIRST_PHY_ADDR_BIT                   21
+
+    #define MI_COM_PHY_REG_ADDR_MASK                    0x1f
+    #define MI_COM_FIRST_PHY_REG_ADDR_BIT               16
+
+    #define MI_COM_PHY_DATA_MASK                        0xffff
+
+    /* MI Status. */
+    T3_32BIT_REGISTER MiStatus;
+    #define MI_STATUS_ENABLE_LINK_STATUS_ATTN           BIT_0
+
+    /* MI Mode. */
+    T3_32BIT_REGISTER MiMode;
+    #define MI_MODE_CLOCK_SPEED_10MHZ                   BIT_0
+    #define MI_MODE_USE_SHORT_PREAMBLE                  BIT_1
+    #define MI_MODE_AUTO_POLLING_ENABLE                 BIT_4
+    #define MI_MODE_CORE_CLOCK_SPEED_62MHZ              BIT_15
+
+    /* Auto-polling status. */
+    T3_32BIT_REGISTER AutoPollStatus;
+    #define AUTO_POLL_ERROR                             BIT_0
+
+    /* Transmit MAC mode. */
+    T3_32BIT_REGISTER TxMode;
+    #define TX_MODE_RESET                               BIT_0
+    #define TX_MODE_ENABLE                              BIT_1
+    #define TX_MODE_ENABLE_FLOW_CONTROL                 BIT_4
+    #define TX_MODE_ENABLE_BIG_BACKOFF                  BIT_5
+    #define TX_MODE_ENABLE_LONG_PAUSE                   BIT_6
+
+    /* Transmit MAC status. */
+    T3_32BIT_REGISTER TxStatus;
+    #define TX_STATUS_RX_CURRENTLY_XOFFED               BIT_0
+    #define TX_STATUS_SENT_XOFF                         BIT_1
+    #define TX_STATUS_SENT_XON                          BIT_2
+    #define TX_STATUS_LINK_UP                           BIT_3
+    #define TX_STATUS_ODI_UNDERRUN                      BIT_4
+    #define TX_STATUS_ODI_OVERRUN                       BIT_5
+
+    /* Transmit MAC length. */
+    T3_32BIT_REGISTER TxLengths;
+    #define TX_LEN_SLOT_TIME_MASK                       0xff
+    #define TX_LEN_IPG_MASK                             0x0f00
+    #define TX_LEN_IPG_CRS_MASK                         (BIT_12 | BIT_13)
+
+    /* Receive MAC mode. */
+    T3_32BIT_REGISTER RxMode;
+    #define RX_MODE_RESET                               BIT_0
+    #define RX_MODE_ENABLE                              BIT_1
+    #define RX_MODE_ENABLE_FLOW_CONTROL                 BIT_2
+    #define RX_MODE_KEEP_MAC_CONTROL                    BIT_3
+    #define RX_MODE_KEEP_PAUSE                          BIT_4
+    #define RX_MODE_ACCEPT_OVERSIZED                    BIT_5
+    #define RX_MODE_ACCEPT_RUNTS                        BIT_6
+    #define RX_MODE_LENGTH_CHECK                        BIT_7
+    #define RX_MODE_PROMISCUOUS_MODE                    BIT_8
+    #define RX_MODE_NO_CRC_CHECK                        BIT_9
+    #define RX_MODE_KEEP_VLAN_TAG                       BIT_10
+
+    /* Receive MAC status. */
+    T3_32BIT_REGISTER RxStatus;
+    #define RX_STATUS_REMOTE_TRANSMITTER_XOFFED         BIT_0
+    #define RX_STATUS_XOFF_RECEIVED                     BIT_1
+    #define RX_STATUS_XON_RECEIVED                      BIT_2
+
+    /* Hash registers. */
+    T3_32BIT_REGISTER HashReg[4];
+
+    /* Receive placement rules registers. */
+    struct {
+        T3_32BIT_REGISTER Rule;
+        T3_32BIT_REGISTER Value;
+    } RcvRules[16];
+
+    #define RCV_DISABLE_RULE_MASK                       0x7fffffff
+
+    #define RCV_RULE1_REJECT_BROADCAST_IDX              0x00
+    #define REJECT_BROADCAST_RULE1_RULE                 0xc2000000
+    #define REJECT_BROADCAST_RULE1_VALUE                0xffffffff
+
+    #define RCV_RULE2_REJECT_BROADCAST_IDX              0x01
+    #define REJECT_BROADCAST_RULE2_RULE                 0x86000004
+    #define REJECT_BROADCAST_RULE2_VALUE                0xffffffff
+
+#if INCLUDE_5701_AX_FIX
+    #define RCV_LAST_RULE_IDX                           0x04
+#else
+    #define RCV_LAST_RULE_IDX                           0x02
+#endif
+
+    T3_32BIT_REGISTER RcvRuleCfg;
+    #define RX_RULE_DEFAULT_CLASS                       (1 << 3)
+
+    LM_UINT8 Reserved1[140];
+
+    T3_32BIT_REGISTER SerdesCfg;
+    T3_32BIT_REGISTER SerdesStatus;
+
+    LM_UINT8 Reserved2[104];
+
+    volatile LM_UINT8 TxMacState[16];
+    volatile LM_UINT8 RxMacState[20];
+
+    LM_UINT8 Reserved3[476];
+
+    T3_32BIT_REGISTER RxStats[26];
+
+    LM_UINT8 Reserved4[24];
+
+    T3_32BIT_REGISTER TxStats[28];
+
+    LM_UINT8 Reserved5[784];
+} T3_MAC_CONTROL, *PT3_MAC_CONTROL;
+
+
+
+/******************************************************************************/
+/* Send data initiator control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define T3_SND_DATA_IN_MODE_RESET                       BIT_0
+    #define T3_SND_DATA_IN_MODE_ENABLE                      BIT_1
+    #define T3_SND_DATA_IN_MODE_STATS_OFLW_ATTN_ENABLE      BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define T3_SND_DATA_IN_STATUS_STATS_OFLW_ATTN           BIT_2
+
+    T3_32BIT_REGISTER StatsCtrl;
+    #define T3_SND_DATA_IN_STATS_CTRL_ENABLE                BIT_0
+    #define T3_SND_DATA_IN_STATS_CTRL_FASTER_UPDATE         BIT_1
+    #define T3_SND_DATA_IN_STATS_CTRL_CLEAR                 BIT_2
+    #define T3_SND_DATA_IN_STATS_CTRL_FLUSH                 BIT_3
+    #define T3_SND_DATA_IN_STATS_CTRL_FORCE_ZERO            BIT_4
+
+    T3_32BIT_REGISTER StatsEnableMask;
+    T3_32BIT_REGISTER StatsIncMask;
+
+    LM_UINT8 Reserved[108];
+
+    T3_32BIT_REGISTER ClassOfServCnt[16];
+    T3_32BIT_REGISTER DmaReadQFullCnt;
+    T3_32BIT_REGISTER DmaPriorityReadQFullCnt;
+    T3_32BIT_REGISTER SdcQFullCnt;
+
+    T3_32BIT_REGISTER NicRingSetSendProdIdxCnt;
+    T3_32BIT_REGISTER StatusUpdatedCnt;
+    T3_32BIT_REGISTER InterruptsCnt;
+    T3_32BIT_REGISTER AvoidInterruptsCnt;
+    T3_32BIT_REGISTER SendThresholdHitCnt;
+
+    /* Unused space. */
+    LM_UINT8 Unused[800];
+} T3_SEND_DATA_INITIATOR, *PT3_SEND_DATA_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Send data completion control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_DATA_COMP_MODE_RESET                        BIT_0
+    #define SND_DATA_COMP_MODE_ENABLE                       BIT_1
+
+    /* Unused space. */
+    LM_UINT8 Unused[1020];
+} T3_SEND_DATA_COMPLETION, *PT3_SEND_DATA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Send BD Ring Selector Control Registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_SEL_MODE_RESET                           BIT_0
+    #define SND_BD_SEL_MODE_ENABLE                          BIT_1
+    #define SND_BD_SEL_MODE_ATTN_ENABLE                     BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define SND_BD_SEL_STATUS_ERROR_ATTN                    BIT_2
+
+    T3_32BIT_REGISTER HwDiag;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[52];
+
+    /* Send BD Ring Selector Local NIC Send BD Consumer Index. */
+    T3_32BIT_REGISTER NicSendBdSelConIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused2[896];
+} T3_SEND_BD_SELECTOR, *PT3_SEND_BD_SELECTOR;
+
+
+
+/******************************************************************************/
+/* Send BD initiator control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_IN_MODE_RESET                            BIT_0
+    #define SND_BD_IN_MODE_ENABLE                           BIT_1
+    #define SND_BD_IN_MODE_ATTN_ENABLE                      BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define SND_BD_IN_STATUS_ERROR_ATTN                     BIT_2
+
+    /* Send BD initiator local NIC send BD producer index. */
+    T3_32BIT_REGISTER NicSendBdInProdIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused2[952];
+} T3_SEND_BD_INITIATOR, *PT3_SEND_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Send BD Completion Control. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_COMP_MODE_RESET                          BIT_0
+    #define SND_BD_COMP_MODE_ENABLE                         BIT_1
+    #define SND_BD_COMP_MODE_ATTN_ENABLE                    BIT_2
+
+    /* Unused space. */
+    LM_UINT8 Unused2[1020];
+} T3_SEND_BD_COMPLETION, *PT3_SEND_BD_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive list placement control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define RCV_LIST_PLMT_MODE_RESET                        BIT_0
+    #define RCV_LIST_PLMT_MODE_ENABLE                       BIT_1
+    #define RCV_LIST_PLMT_MODE_CLASS0_ATTN_ENABLE           BIT_2
+    #define RCV_LIST_PLMT_MODE_MAPPING_OOR_ATTN_ENABLE      BIT_3
+    #define RCV_LIST_PLMT_MODE_STATS_OFLOW_ATTN_ENABLE      BIT_4
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define RCV_LIST_PLMT_STATUS_CLASS0_ATTN                BIT_2
+    #define RCV_LIST_PLMT_STATUS_MAPPING_ATTN               BIT_3
+    #define RCV_LIST_PLMT_STATUS_STATS_OFLOW_ATTN           BIT_4
+
+    /* Receive selector list lock register. */
+    T3_32BIT_REGISTER Lock;
+    #define RCV_LIST_SEL_LOCK_REQUEST_MASK                  0xffff
+    #define RCV_LIST_SEL_LOCK_GRANT_MASK                    0xffff0000
+
+    /* Selector non-empty bits. */
+    T3_32BIT_REGISTER NonEmptyBits;
+    #define RCV_LIST_SEL_NON_EMPTY_MASK                     0xffff
+
+    /* Receive list placement configuration register. */
+    T3_32BIT_REGISTER Config;
+
+    /* Receive List Placement statistics Control. */
+    T3_32BIT_REGISTER StatsCtrl;
+#define RCV_LIST_STATS_ENABLE                               BIT_0
+#define RCV_LIST_STATS_FAST_UPDATE                          BIT_1
+
+    /* Receive List Placement statistics Enable Mask. */
+    T3_32BIT_REGISTER StatsEnableMask;
+
+    /* Receive List Placement statistics Increment Mask. */
+    T3_32BIT_REGISTER StatsIncMask;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[224];
+
+    struct {
+        T3_32BIT_REGISTER Head;
+        T3_32BIT_REGISTER Tail;
+        T3_32BIT_REGISTER Count;
+
+        /* Unused space. */
+        LM_UINT8 Unused[4];
+    } RcvSelectorList[16];
+
+    /* Local statistics counter. */
+    T3_32BIT_REGISTER ClassOfServCnt[16];
+
+    T3_32BIT_REGISTER DropDueToFilterCnt;
+    T3_32BIT_REGISTER DmaWriteQFullCnt;
+    T3_32BIT_REGISTER DmaHighPriorityWriteQFullCnt;
+    T3_32BIT_REGISTER NoMoreReceiveBdCnt;
+    T3_32BIT_REGISTER IfInDiscardsCnt;
+    T3_32BIT_REGISTER IfInErrorsCnt;
+    T3_32BIT_REGISTER RcvThresholdHitCnt;
+
+    /* Another unused space. */
+    LM_UINT8 Unused2[420];
+} T3_RCV_LIST_PLACEMENT, *PT3_RCV_LIST_PLACEMENT;
+
+
+
+/******************************************************************************/
+/* Receive Data and Receive BD Initiator Control. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define RCV_DATA_BD_IN_MODE_RESET                   BIT_0
+    #define RCV_DATA_BD_IN_MODE_ENABLE                  BIT_1
+    #define RCV_DATA_BD_IN_MODE_JUMBO_BD_NEEDED         BIT_2
+    #define RCV_DATA_BD_IN_MODE_FRAME_TOO_BIG           BIT_3
+    #define RCV_DATA_BD_IN_MODE_INVALID_RING_SIZE       BIT_4
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define RCV_DATA_BD_IN_STATUS_JUMBO_BD_NEEDED       BIT_2
+    #define RCV_DATA_BD_IN_STATUS_FRAME_TOO_BIG         BIT_3
+    #define RCV_DATA_BD_IN_STATUS_INVALID_RING_SIZE     BIT_4
+
+    /* Split frame minium size. */
+    T3_32BIT_REGISTER SplitFrameMinSize;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[0x2440-0x240c];
+
+    /* Receive RCBs. */
+    T3_RCB JumboRcvRcb;
+    T3_RCB StdRcvRcb;
+    T3_RCB MiniRcvRcb;
+
+    /* Receive Data and Receive BD Ring Initiator Local NIC Receive */
+    /* BD Consumber Index. */
+    T3_32BIT_REGISTER NicJumboConIdx;
+    T3_32BIT_REGISTER NicStdConIdx;
+    T3_32BIT_REGISTER NicMiniConIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[4];
+
+    /* Receive Data and Receive BD Initiator Local Receive Return ProdIdx. */
+    T3_32BIT_REGISTER RcvDataBdProdIdx[16];
+
+    /* Receive Data and Receive BD Initiator Hardware Diagnostic. */
+    T3_32BIT_REGISTER HwDiag;
+
+    /* Unused space. */
+    LM_UINT8 Unused3[828];
+} T3_RCV_DATA_BD_INITIATOR, *PT3_RCV_DATA_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Receive Data Completion Control Registes. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_DATA_COMP_MODE_RESET                        BIT_0
+    #define RCV_DATA_COMP_MODE_ENABLE                       BIT_1
+    #define RCV_DATA_COMP_MODE_ATTN_ENABLE                  BIT_2
+
+    /* Unused spaced. */
+    LM_UINT8 Unused[1020];
+} T3_RCV_DATA_COMPLETION, *PT3_RCV_DATA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive BD Initiator Control. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_BD_IN_MODE_RESET                            BIT_0
+    #define RCV_BD_IN_MODE_ENABLE                           BIT_1
+    #define RCV_BD_IN_MODE_BD_IN_DIABLED_RCB_ATTN_ENABLE    BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_BD_IN_STATUS_BD_IN_DIABLED_RCB_ATTN         BIT_2
+
+    T3_32BIT_REGISTER NicJumboRcvProdIdx;
+    T3_32BIT_REGISTER NicStdRcvProdIdx;
+    T3_32BIT_REGISTER NicMiniRcvProdIdx;
+
+    T3_32BIT_REGISTER MiniRcvThreshold;
+    T3_32BIT_REGISTER StdRcvThreshold;
+    T3_32BIT_REGISTER JumboRcvThreshold;
+
+    /* Unused space. */
+    LM_UINT8 Unused[992];
+} T3_RCV_BD_INITIATOR, *PT3_RCV_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Receive BD Completion Control Registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_BD_COMP_MODE_RESET                          BIT_0
+    #define RCV_BD_COMP_MODE_ENABLE                         BIT_1
+    #define RCV_BD_COMP_MODE_ATTN_ENABLE                    BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_BD_COMP_STATUS_ERROR_ATTN                   BIT_2
+
+    T3_32BIT_REGISTER  NicJumboRcvBdProdIdx;
+    T3_32BIT_REGISTER  NicStdRcvBdProdIdx;
+    T3_32BIT_REGISTER  NicMiniRcvBdProdIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1004];
+} T3_RCV_BD_COMPLETION, *PT3_RCV_BD_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive list selector control register. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_LIST_SEL_MODE_RESET                         BIT_0
+    #define RCV_LIST_SEL_MODE_ENABLE                        BIT_1
+    #define RCV_LIST_SEL_MODE_ATTN_ENABLE                   BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_LIST_SEL_STATUS_ERROR_ATTN                  BIT_2
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_RCV_LIST_SELECTOR, *PT3_RCV_LIST_SELECTOR;
+
+
+
+/******************************************************************************/
+/* Mbuf cluster free registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define MBUF_CLUSTER_FREE_MODE_RESET    BIT_0
+#define MBUF_CLUSTER_FREE_MODE_ENABLE   BIT_1
+
+    T3_32BIT_REGISTER Status;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_MBUF_CLUSTER_FREE, *PT3_MBUF_CLUSTER_FREE;
+
+
+
+/******************************************************************************/
+/* Host coalescing control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define HOST_COALESCE_RESET                         BIT_0
+    #define HOST_COALESCE_ENABLE                        BIT_1
+    #define HOST_COALESCE_ATTN                          BIT_2
+    #define HOST_COALESCE_NOW                           BIT_3
+    #define HOST_COALESCE_FULL_STATUS_MODE              BIT_NONE
+    #define HOST_COALESCE_64_BYTE_STATUS_MODE           BIT_7
+    #define HOST_COALESCE_32_BYTE_STATUS_MODE           BIT_8
+    #define HOST_COALESCE_CLEAR_TICKS_ON_RX_BD_EVENT    BIT_9
+    #define HOST_COALESCE_CLEAR_TICKS_ON_TX_BD_EVENT    BIT_10
+    #define HOST_COALESCE_NO_INT_ON_COALESCE_NOW_MODE   BIT_11
+    #define HOST_COALESCE_NO_INT_ON_FORCE_DMAD_MODE     BIT_12
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define HOST_COALESCE_ERROR_ATTN                    BIT_2
+
+    /* Receive coalescing ticks. */
+    T3_32BIT_REGISTER RxCoalescingTicks;
+
+    /* Send coalescing ticks. */
+    T3_32BIT_REGISTER TxCoalescingTicks;
+
+    /* Receive max coalesced frames. */
+    T3_32BIT_REGISTER RxMaxCoalescedFrames;
+
+    /* Send max coalesced frames. */
+    T3_32BIT_REGISTER TxMaxCoalescedFrames;
+
+    /* Receive coalescing ticks during interrupt. */
+    T3_32BIT_REGISTER RxCoalescedTickDuringInt;
+
+    /* Send coalescing ticks during interrupt. */
+    T3_32BIT_REGISTER TxCoalescedTickDuringInt;
+
+    /* Receive max coalesced frames during interrupt. */
+    T3_32BIT_REGISTER RxMaxCoalescedFramesDuringInt;
+
+    /* Send max coalesced frames during interrupt. */
+    T3_32BIT_REGISTER TxMaxCoalescedFramesDuringInt;
+
+    /* Statistics tick. */
+    T3_32BIT_REGISTER StatsCoalescingTicks;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[4];
+
+    /* Statistics host address. */
+    T3_64BIT_REGISTER StatsBlkHostAddr;
+
+    /* Status block host address.*/
+    T3_64BIT_REGISTER StatusBlkHostAddr;
+
+    /* Statistics NIC address. */
+    T3_32BIT_REGISTER StatsBlkNicAddr;
+
+    /* Statust block NIC address. */
+    T3_32BIT_REGISTER StatusBlkNicAddr;
+
+    /* Flow attention registers. */
+    T3_32BIT_REGISTER FlowAttn;
+
+    /* Unused space. */
+    LM_UINT8 Unused3[4];
+
+    T3_32BIT_REGISTER NicJumboRcvBdConIdx;
+    T3_32BIT_REGISTER NicStdRcvBdConIdx;
+    T3_32BIT_REGISTER NicMiniRcvBdConIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused4[36];
+
+    T3_32BIT_REGISTER NicRetProdIdx[16];
+    T3_32BIT_REGISTER NicSndBdConIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused5[768];
+} T3_HOST_COALESCING, *PT3_HOST_COALESCING;
+
+
+
+/******************************************************************************/
+/* Memory arbiter registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define T3_MEM_ARBITER_MODE_RESET       BIT_0
+#define T3_MEM_ARBITER_MODE_ENABLE      BIT_1
+
+    T3_32BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER ArbTrapAddrLow;
+    T3_32BIT_REGISTER ArbTrapAddrHigh;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1008];
+} T3_MEM_ARBITER, *PT3_MEM_ARBITER;
+
+
+
+/******************************************************************************/
+/* Buffer manager control register. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define BUFMGR_MODE_RESET                           BIT_0
+    #define BUFMGR_MODE_ENABLE                          BIT_1
+    #define BUFMGR_MODE_ATTN_ENABLE                     BIT_2
+    #define BUFMGR_MODE_BM_TEST                         BIT_3
+    #define BUFMGR_MODE_MBUF_LOW_ATTN_ENABLE            BIT_4
+
+    T3_32BIT_REGISTER Status;
+    #define BUFMGR_STATUS_ERROR                         BIT_2
+    #define BUFMGR_STATUS_MBUF_LOW                      BIT_4
+
+    T3_32BIT_REGISTER MbufPoolAddr;
+    T3_32BIT_REGISTER MbufPoolSize;
+    T3_32BIT_REGISTER MbufReadDmaLowWaterMark;
+    T3_32BIT_REGISTER MbufMacRxLowWaterMark;
+    T3_32BIT_REGISTER MbufHighWaterMark;
+
+    T3_32BIT_REGISTER RxCpuMbufAllocReq;
+    #define BUFMGR_MBUF_ALLOC_BIT                     BIT_31
+    T3_32BIT_REGISTER RxCpuMbufAllocResp;
+    T3_32BIT_REGISTER TxCpuMbufAllocReq;
+    T3_32BIT_REGISTER TxCpuMbufAllocResp;
+
+    T3_32BIT_REGISTER DmaDescPoolAddr;
+    T3_32BIT_REGISTER DmaDescPoolSize;
+    T3_32BIT_REGISTER DmaLowWaterMark;
+    T3_32BIT_REGISTER DmaHighWaterMark;
+
+    T3_32BIT_REGISTER RxCpuDmaAllocReq;
+    T3_32BIT_REGISTER RxCpuDmaAllocResp;
+    T3_32BIT_REGISTER TxCpuDmaAllocReq;
+    T3_32BIT_REGISTER TxCpuDmaAllocResp;
+
+    T3_32BIT_REGISTER Hwdiag[3];
+
+    /* Unused space. */
+    LM_UINT8 Unused[936];
+} T3_BUFFER_MANAGER, *PT3_BUFFER_MANAGER;
+
+
+
+/******************************************************************************/
+/* Read DMA control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_READ_MODE_RESET                         BIT_0
+    #define DMA_READ_MODE_ENABLE                        BIT_1
+    #define DMA_READ_MODE_TARGET_ABORT_ATTN_ENABLE      BIT_2
+    #define DMA_READ_MODE_MASTER_ABORT_ATTN_ENABLE      BIT_3
+    #define DMA_READ_MODE_PARITY_ERROR_ATTN_ENABLE      BIT_4
+    #define DMA_READ_MODE_ADDR_OVERFLOW_ATTN_ENABLE     BIT_5
+    #define DMA_READ_MODE_FIFO_OVERRUN_ATTN_ENABLE      BIT_6
+    #define DMA_READ_MODE_FIFO_UNDERRUN_ATTN_ENABLE     BIT_7
+    #define DMA_READ_MODE_FIFO_OVERREAD_ATTN_ENABLE     BIT_8
+    #define DMA_READ_MODE_LONG_READ_ATTN_ENABLE         BIT_9
+
+    T3_32BIT_REGISTER Status;
+    #define DMA_READ_STATUS_TARGET_ABORT_ATTN           BIT_2
+    #define DMA_READ_STATUS_MASTER_ABORT_ATTN           BIT_3
+    #define DMA_READ_STATUS_PARITY_ERROR_ATTN           BIT_4
+    #define DMA_READ_STATUS_ADDR_OVERFLOW_ATTN          BIT_5
+    #define DMA_READ_STATUS_FIFO_OVERRUN_ATTN           BIT_6
+    #define DMA_READ_STATUS_FIFO_UNDERRUN_ATTN          BIT_7
+    #define DMA_READ_STATUS_FIFO_OVERREAD_ATTN          BIT_8
+    #define DMA_READ_STATUS_LONG_READ_ATTN              BIT_9
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_DMA_READ, *PT3_DMA_READ;
+
+typedef union T3_CPU 
+{
+  struct
+  {
+    T3_32BIT_REGISTER mode;
+    #define CPU_MODE_HALT   BIT_10
+    #define CPU_MODE_RESET  BIT_0 
+    T3_32BIT_REGISTER state;
+    T3_32BIT_REGISTER EventMask;
+    T3_32BIT_REGISTER reserved1[4];
+    T3_32BIT_REGISTER PC;
+    T3_32BIT_REGISTER Instruction;
+    T3_32BIT_REGISTER SpadUnderflow;
+    T3_32BIT_REGISTER WatchdogClear;
+    T3_32BIT_REGISTER WatchdogVector;
+    T3_32BIT_REGISTER WatchdogSavedPC;
+    T3_32BIT_REGISTER HardwareBp;
+    T3_32BIT_REGISTER reserved2[3];
+    T3_32BIT_REGISTER WatchdogSavedState;    
+    T3_32BIT_REGISTER LastBrchAddr;    
+    T3_32BIT_REGISTER SpadUnderflowSet;    
+    T3_32BIT_REGISTER reserved3[(0x200-0x50)/4];
+    T3_32BIT_REGISTER Regs[32];
+    T3_32BIT_REGISTER reserved4[(0x400-0x280)/4];
+  }reg;
+}T3_CPU, *PT3_CPU;
+
+/******************************************************************************/
+/* Write DMA control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_WRITE_MODE_RESET                        BIT_0
+    #define DMA_WRITE_MODE_ENABLE                       BIT_1
+    #define DMA_WRITE_MODE_TARGET_ABORT_ATTN_ENABLE     BIT_2
+    #define DMA_WRITE_MODE_MASTER_ABORT_ATTN_ENABLE     BIT_3
+    #define DMA_WRITE_MODE_PARITY_ERROR_ATTN_ENABLE     BIT_4
+    #define DMA_WRITE_MODE_ADDR_OVERFLOW_ATTN_ENABLE    BIT_5
+    #define DMA_WRITE_MODE_FIFO_OVERRUN_ATTN_ENABLE     BIT_6
+    #define DMA_WRITE_MODE_FIFO_UNDERRUN_ATTN_ENABLE    BIT_7
+    #define DMA_WRITE_MODE_FIFO_OVERREAD_ATTN_ENABLE    BIT_8
+    #define DMA_WRITE_MODE_LONG_READ_ATTN_ENABLE        BIT_9
+
+    T3_32BIT_REGISTER Status;
+    #define DMA_WRITE_STATUS_TARGET_ABORT_ATTN          BIT_2
+    #define DMA_WRITE_STATUS_MASTER_ABORT_ATTN          BIT_3
+    #define DMA_WRITE_STATUS_PARITY_ERROR_ATTN          BIT_4
+    #define DMA_WRITE_STATUS_ADDR_OVERFLOW_ATTN         BIT_5
+    #define DMA_WRITE_STATUS_FIFO_OVERRUN_ATTN          BIT_6
+    #define DMA_WRITE_STATUS_FIFO_UNDERRUN_ATTN         BIT_7
+    #define DMA_WRITE_STATUS_FIFO_OVERREAD_ATTN         BIT_8
+    #define DMA_WRITE_STATUS_LONG_READ_ATTN             BIT_9
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_DMA_WRITE, *PT3_DMA_WRITE;
+
+
+
+/******************************************************************************/
+/* Mailbox registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Interrupt mailbox registers. */
+    T3_64BIT_REGISTER Interrupt[4];
+
+    /* General mailbox registers. */
+    T3_64BIT_REGISTER General[8];
+
+    /* Reload statistics mailbox. */
+    T3_64BIT_REGISTER ReloadStat;
+
+    /* Receive BD ring producer index registers. */
+    T3_64BIT_REGISTER RcvStdProdIdx;
+    T3_64BIT_REGISTER RcvJumboProdIdx;
+    T3_64BIT_REGISTER RcvMiniProdIdx;
+
+    /* Receive return ring consumer index registers. */
+    T3_64BIT_REGISTER RcvRetConIdx[16];
+
+    /* Send BD ring host producer index registers. */
+    T3_64BIT_REGISTER SendHostProdIdx[16];
+
+    /* Send BD ring nic producer index registers. */
+    T3_64BIT_REGISTER SendNicProdIdx[16];
+}T3_MAILBOX, *PT3_MAILBOX;
+
+typedef struct {
+    T3_MAILBOX Mailbox;
+
+    /* Priority mailbox registers. */
+    T3_32BIT_REGISTER HighPriorityEventVector;
+    T3_32BIT_REGISTER HighPriorityEventMask;
+    T3_32BIT_REGISTER LowPriorityEventVector;
+    T3_32BIT_REGISTER LowPriorityEventMask;
+
+    /* Unused space. */
+    LM_UINT8 Unused[496];
+} T3_GRC_MAILBOX, *PT3_GRC_MAILBOX;
+
+
+/******************************************************************************/
+/* Flow through queues. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Reset;
+    
+    LM_UINT8 Unused[12];
+
+    T3_32BIT_REGISTER DmaNormalReadFtqCtrl;
+    T3_32BIT_REGISTER DmaNormalReadFtqFullCnt;
+    T3_32BIT_REGISTER DmaNormalReadFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaNormalReadFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaHighReadFtqCtrl;
+    T3_32BIT_REGISTER DmaHighReadFtqFullCnt;
+    T3_32BIT_REGISTER DmaHighReadFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaHighReadFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaCompDiscardFtqCtrl;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFullCnt;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendBdCompFtqCtrl;
+    T3_32BIT_REGISTER SendBdCompFtqFullCnt;
+    T3_32BIT_REGISTER SendBdCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendBdCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendDataInitiatorFtqCtrl;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFullCnt;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaNormalWriteFtqCtrl;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFullCnt;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaHighWriteFtqCtrl;
+    T3_32BIT_REGISTER DmaHighWriteFtqFullCnt;
+    T3_32BIT_REGISTER DmaHighWriteFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaHighWriteFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SwType1FtqCtrl;
+    T3_32BIT_REGISTER SwType1FtqFullCnt;
+    T3_32BIT_REGISTER SwType1FtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SwType1FtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendDataCompFtqCtrl;
+    T3_32BIT_REGISTER SendDataCompFtqFullCnt;
+    T3_32BIT_REGISTER SendDataCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendDataCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER HostCoalesceFtqCtrl;
+    T3_32BIT_REGISTER HostCoalesceFtqFullCnt;
+    T3_32BIT_REGISTER HostCoalesceFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER HostCoalesceFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER MacTxFtqCtrl;
+    T3_32BIT_REGISTER MacTxFtqFullCnt;
+    T3_32BIT_REGISTER MacTxFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER MacTxFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER MbufClustFreeFtqCtrl;
+    T3_32BIT_REGISTER MbufClustFreeFtqFullCnt;
+    T3_32BIT_REGISTER MbufClustFreeFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER MbufClustFreeFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvBdCompFtqCtrl;
+    T3_32BIT_REGISTER RcvBdCompFtqFullCnt;
+    T3_32BIT_REGISTER RcvBdCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvBdCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvListPlmtFtqCtrl;
+    T3_32BIT_REGISTER RcvListPlmtFtqFullCnt;
+    T3_32BIT_REGISTER RcvListPlmtFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvListPlmtFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqCtrl;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFullCnt;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvDataCompFtqCtrl;
+    T3_32BIT_REGISTER RcvDataCompFtqFullCnt;
+    T3_32BIT_REGISTER RcvDataCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvDataCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SwType2FtqCtrl;
+    T3_32BIT_REGISTER SwType2FtqFullCnt;
+    T3_32BIT_REGISTER SwType2FtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SwType2FtqFifoWritePeek;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[736];
+} T3_FTQ, *PT3_FTQ;
+
+
+
+/******************************************************************************/
+/* Message signaled interrupt registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define MSI_MODE_RESET       BIT_0
+#define MSI_MODE_ENABLE      BIT_1
+    T3_32BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER MsiFifoAccess;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1012];
+} T3_MSG_SIGNALED_INT, *PT3_MSG_SIGNALED_INT;
+
+
+
+/******************************************************************************/
+/* DMA Completion registes. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_COMP_MODE_RESET                         BIT_0
+    #define DMA_COMP_MODE_ENABLE                        BIT_1
+
+    /* Unused space. */
+    LM_UINT8 Unused[1020];
+} T3_DMA_COMPLETION, *PT3_DMA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* GRC registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode control register. */
+    T3_32BIT_REGISTER Mode;
+    #define GRC_MODE_UPDATE_ON_COALESCING               BIT_0
+    #define GRC_MODE_BYTE_SWAP_NON_FRAME_DATA           BIT_1
+    #define GRC_MODE_WORD_SWAP_NON_FRAME_DATA           BIT_2
+    #define GRC_MODE_BYTE_SWAP_DATA                     BIT_4
+    #define GRC_MODE_WORD_SWAP_DATA                     BIT_5
+    #define GRC_MODE_SPLIT_HEADER_MODE                  BIT_8
+    #define GRC_MODE_NO_FRAME_CRACKING                  BIT_9
+    #define GRC_MODE_INCLUDE_CRC                        BIT_10
+    #define GRC_MODE_ALLOW_BAD_FRAMES                   BIT_11
+    #define GRC_MODE_NO_INTERRUPT_ON_SENDS              BIT_13
+    #define GRC_MODE_NO_INTERRUPT_ON_RECEIVE            BIT_14
+    #define GRC_MODE_FORCE_32BIT_PCI_BUS_MODE           BIT_15
+    #define GRC_MODE_HOST_STACK_UP                      BIT_16
+    #define GRC_MODE_HOST_SEND_BDS                      BIT_17
+    #define GRC_MODE_TX_NO_PSEUDO_HEADER_CHKSUM         BIT_20
+    #define GRC_MODE_RX_NO_PSEUDO_HEADER_CHKSUM         BIT_23
+    #define GRC_MODE_INT_ON_TX_CPU_ATTN                 BIT_24
+    #define GRC_MODE_INT_ON_RX_CPU_ATTN                 BIT_25
+    #define GRC_MODE_INT_ON_MAC_ATTN                    BIT_26
+    #define GRC_MODE_INT_ON_DMA_ATTN                    BIT_27
+    #define GRC_MODE_INT_ON_FLOW_ATTN                   BIT_28
+    #define GRC_MODE_4X_NIC_BASED_SEND_RINGS            BIT_29
+    #define GRC_MODE_MULTICAST_FRAME_ENABLE             BIT_30
+
+    /* Misc configuration register. */
+    T3_32BIT_REGISTER MiscCfg;
+    #define GRC_MISC_CFG_CORE_CLOCK_RESET               BIT_0
+    #define GRC_MISC_PRESCALAR_TIMER_MASK               0xfe
+    #define GRC_MISC_BD_ID_MASK                         0x0001e000
+    #define GRC_MISC_BD_ID_5700                         0x0001e000
+    #define GRC_MISC_BD_ID_5701                         0x00000000
+    #define GRC_MISC_BD_ID_5703                         0x00000000
+    #define GRC_MISC_BD_ID_5703S                        0x00002000
+    #define GRC_MISC_BD_ID_5702FE                       0x00004000
+
+    /* Miscellaneous local control register. */
+    T3_32BIT_REGISTER LocalCtrl;
+    #define GRC_MISC_LOCAL_CTRL_INT_ACTIVE              BIT_0
+    #define GRC_MISC_LOCAL_CTRL_CLEAR_INT               BIT_1
+    #define GRC_MISC_LOCAL_CTRL_SET_INT                 BIT_2
+    #define GRC_MISC_LOCAL_CTRL_INT_ON_ATTN             BIT_3
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT0             BIT_8
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT1             BIT_9
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT2             BIT_10
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE0                BIT_11
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE1                BIT_12
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE2                BIT_13
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0            BIT_14
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1            BIT_15
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT2            BIT_16
+    #define GRC_MISC_LOCAL_CTRL_ENABLE_EXT_MEMORY       BIT_17
+    #define GRC_MISC_LOCAL_CTRL_BANK_SELECT             BIT_21
+    #define GRC_MISC_LOCAL_CTRL_SSRAM_TYPE              BIT_22
+
+    #define GRC_MISC_MEMSIZE_256K     0
+    #define GRC_MISC_MEMSIZE_512K     (1 << 18)
+    #define GRC_MISC_MEMSIZE_1024K    (2 << 18)
+    #define GRC_MISC_MEMSIZE_2048K    (3 << 18)
+    #define GRC_MISC_MEMSIZE_4096K    (4 << 18)
+    #define GRC_MISC_MEMSIZE_8192K    (5 << 18)
+    #define GRC_MISC_MEMSIZE_16M      (6 << 18)
+    #define GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM            BIT_24
+
+
+    T3_32BIT_REGISTER Timer;
+
+    T3_32BIT_REGISTER RxCpuEvent;
+    T3_32BIT_REGISTER RxTimerRef;
+    T3_32BIT_REGISTER RxCpuSemaphore;
+    T3_32BIT_REGISTER RemoteRxCpuAttn;
+
+    T3_32BIT_REGISTER TxCpuEvent;
+    T3_32BIT_REGISTER TxTimerRef;
+    T3_32BIT_REGISTER TxCpuSemaphore;
+    T3_32BIT_REGISTER RemoteTxCpuAttn;
+
+    T3_64BIT_REGISTER MemoryPowerUp;
+
+    T3_32BIT_REGISTER EepromAddr;
+    #define SEEPROM_ADDR_WRITE       0
+    #define SEEPROM_ADDR_READ        (1 << 31)
+    #define SEEPROM_ADDR_RW_MASK     0x80000000
+    #define SEEPROM_ADDR_COMPLETE    (1 << 30)
+    #define SEEPROM_ADDR_FSM_RESET   (1 << 29)
+    #define SEEPROM_ADDR_DEV_ID(x)   (x << 26)
+    #define SEEPROM_ADDR_DEV_ID_MASK 0x1c000000
+    #define SEEPROM_ADDR_START       (1 << 25)
+    #define SEEPROM_ADDR_CLK_PERD(x) (x << 16)
+    #define SEEPROM_ADDR_ADDRESS(x)  (x & 0xfffc)
+    #define SEEPROM_ADDR_ADDRESS_MASK 0x0000ffff
+
+    #define SEEPROM_CLOCK_PERIOD        60
+    #define SEEPROM_CHIP_SIZE           (64 * 1024)
+
+    T3_32BIT_REGISTER EepromData;
+    T3_32BIT_REGISTER EepromCtrl;
+
+    T3_32BIT_REGISTER MdiCtrl;
+    T3_32BIT_REGISTER SepromDelay;
+
+    /* Unused space. */
+    LM_UINT8 Unused[948];
+} T3_GRC, *PT3_GRC;
+
+
+/******************************************************************************/
+/* NVRAM control registers. */
+/******************************************************************************/
+
+typedef struct
+{
+    T3_32BIT_REGISTER Cmd;
+    #define NVRAM_CMD_RESET                             BIT_0
+    #define NVRAM_CMD_DONE                              BIT_3
+    #define NVRAM_CMD_DO_IT                             BIT_4
+    #define NVRAM_CMD_WR                                BIT_5
+    #define NVRAM_CMD_RD                                BIT_NONE
+    #define NVRAM_CMD_ERASE                             BIT_6
+    #define NVRAM_CMD_FIRST                             BIT_7
+    #define NVRAM_CMD_LAST                              BIT_8
+
+    T3_32BIT_REGISTER Status;
+    T3_32BIT_REGISTER WriteData;
+
+    T3_32BIT_REGISTER Addr;
+    #define NVRAM_ADDRESS_MASK                          0xffffff
+
+    T3_32BIT_REGISTER ReadData;
+
+    /* Flash config 1 register. */
+    T3_32BIT_REGISTER Config1;
+    #define FLASH_INTERFACE_ENABLE                      BIT_0
+    #define FLASH_SSRAM_BUFFERRED_MODE                  BIT_1
+    #define FLASH_PASS_THRU_MODE                        BIT_2
+    #define FLASH_BIT_BANG_MODE                         BIT_3
+    #define FLASH_COMPAT_BYPASS                         BIT_31
+
+    /* Buffered flash (Atmel: AT45DB011B) specific information */
+    #define BUFFERED_FLASH_PAGE_POS         9
+    #define BUFFERED_FLASH_BYTE_ADDR_MASK   ((1<<BUFFERED_FLASH_PAGE_POS) - 1)
+    #define BUFFERED_FLASH_PAGE_SIZE        264
+    #define BUFFERED_FLASH_PHY_PAGE_SIZE    512
+
+    T3_32BIT_REGISTER Config2;
+    T3_32BIT_REGISTER Config3;
+    T3_32BIT_REGISTER SwArb;
+    #define SW_ARB_REQ_SET0                             BIT_0
+    #define SW_ARB_REQ_SET1                             BIT_1
+    #define SW_ARB_REQ_SET2                             BIT_2
+    #define SW_ARB_REQ_SET3                             BIT_3
+    #define SW_ARB_REQ_CLR0                             BIT_4
+    #define SW_ARB_REQ_CLR1                             BIT_5
+    #define SW_ARB_REQ_CLR2                             BIT_6
+    #define SW_ARB_REQ_CLR3                             BIT_7
+    #define SW_ARB_GNT0                                 BIT_8
+    #define SW_ARB_GNT1                                 BIT_9
+    #define SW_ARB_GNT2                                 BIT_10
+    #define SW_ARB_GNT3                                 BIT_11
+    #define SW_ARB_REQ0                                 BIT_12
+    #define SW_ARB_REQ1                                 BIT_13
+    #define SW_ARB_REQ2                                 BIT_14
+    #define SW_ARB_REQ3                                 BIT_15
+
+    /* Unused space. */
+    LM_UINT8 Unused[988];
+} T3_NVRAM, *PT3_NVRAM;
+
+
+/******************************************************************************/
+/* NIC's internal memory. */
+/******************************************************************************/
+
+typedef struct {
+    /* Page zero for the internal CPUs. */
+    LM_UINT8 PageZero[0x100];               /* 0x0000 */
+
+    /* Send RCBs. */
+    T3_RCB SendRcb[16];                     /* 0x0100 */
+
+    /* Receive Return RCBs. */
+    T3_RCB RcvRetRcb[16];                   /* 0x0200 */
+
+    /* Statistics block. */
+    T3_STATS_BLOCK StatsBlk;                /* 0x0300 */
+
+    /* Status block. */
+    T3_STATUS_BLOCK StatusBlk;              /* 0x0b00 */
+
+    /* Reserved for software. */
+    LM_UINT8 Reserved[1200];                /* 0x0b50 */
+
+    /* Unmapped region. */
+    LM_UINT8 Unmapped[4096];                /* 0x1000 */
+
+    /* DMA descriptors. */
+    LM_UINT8 DmaDesc[8192];                 /* 0x2000 */
+
+    /* Buffer descriptors. */
+    LM_UINT8 BufferDesc[16384];             /* 0x4000 */
+} T3_FIRST_32K_SRAM, *PT3_FIRST_32K_SRAM;
+
+
+
+/******************************************************************************/
+/* Memory layout. */
+/******************************************************************************/
+
+typedef struct {
+    /* PCI configuration registers. */
+    T3_PCI_CONFIGURATION PciCfg;
+
+    /* Unused. */
+    LM_UINT8 Unused1[0x100];                            /* 0x0100 */
+
+    /* Mailbox . */
+    T3_MAILBOX Mailbox;                                 /* 0x0200 */
+
+    /* MAC control registers. */
+    T3_MAC_CONTROL MacCtrl;                             /* 0x0400 */
+
+    /* Send data initiator control registers. */
+    T3_SEND_DATA_INITIATOR SndDataIn;                   /* 0x0c00 */
+
+    /* Send data completion Control registers. */
+    T3_SEND_DATA_COMPLETION SndDataComp;                /* 0x1000 */
+
+    /* Send BD ring selector. */
+    T3_SEND_BD_SELECTOR SndBdSel;                       /* 0x1400 */
+
+    /* Send BD initiator control registers. */
+    T3_SEND_BD_INITIATOR SndBdIn;                       /* 0x1800 */
+
+    /* Send BD completion control registers. */
+    T3_SEND_BD_COMPLETION SndBdComp;                    /* 0x1c00 */
+
+    /* Receive list placement control registers. */
+    T3_RCV_LIST_PLACEMENT RcvListPlmt;                  /* 0x2000 */
+
+    /* Receive Data and Receive BD Initiator Control. */
+    T3_RCV_DATA_BD_INITIATOR RcvDataBdIn;               /* 0x2400 */
+
+    /* Receive Data Completion Control */
+    T3_RCV_DATA_COMPLETION RcvDataComp;                 /* 0x2800 */
+
+    /* Receive BD Initiator Control Registers. */
+    T3_RCV_BD_INITIATOR RcvBdIn;                        /* 0x2c00 */
+
+    /* Receive BD Completion Control Registers. */
+    T3_RCV_BD_COMPLETION RcvBdComp;                     /* 0x3000 */
+
+    /* Receive list selector control registers. */
+    T3_RCV_LIST_SELECTOR RcvListSel;                    /* 0x3400 */
+
+    /* Mbuf cluster free registers. */
+    T3_MBUF_CLUSTER_FREE MbufClusterFree;               /* 0x3800 */
+
+    /* Host coalescing control registers. */
+    T3_HOST_COALESCING HostCoalesce;                    /* 0x3c00 */
+
+    /* Memory arbiter control registers. */
+    T3_MEM_ARBITER MemArbiter;                          /* 0x4000 */
+    
+    /* Buffer manger control registers. */
+    T3_BUFFER_MANAGER BufMgr;                           /* 0x4400 */
+
+    /* Read DMA control registers. */
+    T3_DMA_READ DmaRead;                                /* 0x4800 */
+
+    /* Write DMA control registers. */
+    T3_DMA_WRITE DmaWrite;                              /* 0x4c00 */
+
+    T3_CPU rxCpu;                                       /* 0x5000 */
+    T3_CPU txCpu;                                       /* 0x5400 */
+
+    /* Mailboxes. */
+    T3_GRC_MAILBOX GrcMailbox;                          /* 0x5800 */
+
+    /* Flow Through queues. */
+    T3_FTQ Ftq;                                         /* 0x5c00 */
+
+    /* Message signaled interrupt registes. */
+    T3_MSG_SIGNALED_INT Msi;                            /* 0x6000 */
+
+    /* DMA completion registers. */
+    T3_DMA_COMPLETION DmaComp;                          /* 0x6400 */
+
+    /* GRC registers. */
+    T3_GRC Grc;                                         /* 0x6800 */
+
+    /* Unused space. */
+    LM_UINT8 Unused2[1024];                             /* 0x6c00 */
+
+    /* NVRAM registers. */
+    T3_NVRAM Nvram;                                     /* 0x7000 */
+
+    /* Unused space. */
+    LM_UINT8 Unused3[3072];                             /* 0x7400 */
+    
+    /* The 32k memory window into the NIC's */
+    /* internal memory.  The memory window is */
+    /* controlled by the Memory Window Base */
+    /* Address register.  This register is located */
+    /* in the PCI configuration space. */
+    union {                                             /* 0x8000 */
+        T3_FIRST_32K_SRAM First32k;
+
+        /* Use the memory window base address register to determine the */
+        /* MBUF segment. */
+        LM_UINT32 Mbuf[32768/4];
+        LM_UINT32 MemBlock32K[32768/4];
+    } uIntMem;
+} T3_STD_MEM_MAP, *PT3_STD_MEM_MAP;
+
+
+/******************************************************************************/
+/* Adapter info. */
+/******************************************************************************/
+
+typedef struct
+{
+    LM_UINT16 Svid;
+    LM_UINT16 Ssid;
+    LM_UINT32 PhyId;
+    LM_UINT32 Serdes;   /* 0 = copper PHY, 1 = Serdes */
+} LM_ADAPTER_INFO, *PLM_ADAPTER_INFO;
+
+
+/******************************************************************************/
+/* Packet queues. */
+/******************************************************************************/
+
+DECLARE_QUEUE_TYPE(LM_RX_PACKET_Q, MAX_RX_PACKET_DESC_COUNT);
+DECLARE_QUEUE_TYPE(LM_TX_PACKET_Q, MAX_TX_PACKET_DESC_COUNT);
+
+
+
+/******************************************************************************/
+/* Tx counters. */
+/******************************************************************************/
+
+typedef struct {
+    LM_COUNTER TxPacketGoodCnt;
+    LM_COUNTER TxBytesGoodCnt;
+    LM_COUNTER TxPacketAbortedCnt;
+    LM_COUNTER NoSendBdLeftCnt;
+    LM_COUNTER NoMapRegisterLeftCnt;
+    LM_COUNTER TooManyFragmentsCnt;
+    LM_COUNTER NoTxPacketDescCnt;
+} LM_TX_COUNTERS, *PLM_TX_COUNTERS;
+
+
+
+/******************************************************************************/
+/* Rx counters. */
+/******************************************************************************/
+
+typedef struct {
+    LM_COUNTER RxPacketGoodCnt;
+    LM_COUNTER RxBytesGoodCnt;
+    LM_COUNTER RxPacketErrCnt;
+    LM_COUNTER RxErrCrcCnt;
+    LM_COUNTER RxErrCollCnt;
+    LM_COUNTER RxErrLinkLostCnt;
+    LM_COUNTER RxErrPhyDecodeCnt;
+    LM_COUNTER RxErrOddNibbleCnt;
+    LM_COUNTER RxErrMacAbortCnt;
+    LM_COUNTER RxErrShortPacketCnt;
+    LM_COUNTER RxErrNoResourceCnt;
+    LM_COUNTER RxErrLargePacketCnt;
+} LM_RX_COUNTERS, *PLM_RX_COUNTERS;
+
+
+
+/******************************************************************************/
+/* Receive producer rings. */
+/******************************************************************************/
+
+typedef enum {
+    T3_UNKNOWN_RCV_PROD_RING    = 0,
+    T3_STD_RCV_PROD_RING        = 1,
+    T3_MINI_RCV_PROD_RING       = 2,
+    T3_JUMBO_RCV_PROD_RING      = 3
+} T3_RCV_PROD_RING, *PT3_RCV_PROD_RING;
+
+
+
+/******************************************************************************/
+/* Packet descriptor. */
+/******************************************************************************/
+
+#define LM_PACKET_SIGNATURE_TX              0x6861766b
+#define LM_PACKET_SIGNATURE_RX              0x6b766168
+
+typedef struct _LM_PACKET {
+    /* Set in LM. */
+    LM_STATUS PacketStatus;
+
+    /* Set in LM for Rx, in UM for Tx. */
+    LM_UINT32 PacketSize;
+
+    LM_UINT16 Flags;
+
+#define LM_VALID_VLAN_TAG                   (1 << 0)
+#define LM_VALID_IP_CHKSUM_FIELD            (1 << 1)
+#define LM_VALID_TCP_UDP_CHKSUM_FIELD       (1 << 2)
+#define LM_TCP_PACKET                       (1 << 3)
+#define LM_DONT_GEN_CRC                     (1 << 4)
+#define LM_TCP_SEGMENTATION                 (1 << 5)
+
+    LM_UINT16 VlanTag;
+
+    union {
+        /* Send info. */
+        struct {
+            /* Set up by UM. */
+            LM_UINT32 FragCount;
+
+            /* Checksum offload info. */
+            LM_TASK_OFFLOAD TaskOffload;
+
+            /* Fragment buffer for MM_StartTxDma to fill in. */
+            PLM_FRAG_LIST pFraglist;
+        } Tx;
+
+        /* Receive info. */
+        struct {
+            /* This descriptor belongs to either Std, Mini, or Jumbo ring. */
+            T3_RCV_PROD_RING RcvProdRing;
+
+            /* Receive buffer size */
+            LM_UINT32 RxBufferSize;
+
+            /* Virtual and physical address of the receive buffer. */
+            PLM_UINT8 pRxBufferVirt;
+            LM_PHYSICAL_ADDRESS RxBufferPhy;
+            
+            /* Checksum information. */
+            LM_UINT16 IpChecksum;
+            LM_UINT16 TcpUdpChecksum;
+
+        } Rx;
+    } u;
+} LM_PACKET;
+
+
+
+/******************************************************************************/
+/* Tigon3 device block. */
+/******************************************************************************/
+
+typedef struct _LM_DEVICE_BLOCK {
+    /* Memory view. */
+    PT3_STD_MEM_MAP pMemView;
+
+    /* Base address of the block of memory in which the LM_PACKET descriptors */
+    /* are allocated from. */
+    PLM_VOID pPacketDescBase;
+
+    LM_UINT32 MiscHostCtrl;
+    LM_UINT32 GrcLocalCtrl;
+    LM_UINT32 DmaReadWriteCtrl;
+    LM_UINT32 PciState;
+
+    /* Rx info */
+    LM_UINT32 RxStdDescCnt;
+    LM_UINT32 RxStdQueuedCnt;
+    LM_UINT32 RxStdProdIdx;
+
+    PT3_RCV_BD pRxStdBdVirt;
+    LM_PHYSICAL_ADDRESS RxStdBdPhy;
+
+    LM_UINT32 RxPacketDescCnt;
+    LM_RX_PACKET_Q RxPacketFreeQ;
+    LM_RX_PACKET_Q RxPacketReceivedQ;
+
+    /* Receive info. */
+    PT3_RCV_BD pRcvRetBdVirt;
+    LM_PHYSICAL_ADDRESS RcvRetBdPhy;
+    LM_UINT32 RcvRetConIdx;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    LM_UINT32 RxJumboDescCnt;
+    LM_UINT32 RxJumboBufferSize;
+    LM_UINT32 RxJumboQueuedCnt;
+
+    LM_UINT32 RxJumboProdIdx;
+
+    PT3_RCV_BD pRxJumboBdVirt;
+    LM_PHYSICAL_ADDRESS RxJumboBdPhy;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* These values are used by the upper module to inform the protocol */
+    /* of the maximum transmit/receive packet size. */
+    LM_UINT32 TxMtu;    /* Does not include CRC. */
+    LM_UINT32 RxMtu;    /* Does not include CRC. */
+
+    /* We need to shadow the EMAC, Rx, Tx mode registers.  With B0 silicon, */
+    /* we may have problems reading any MAC registers in 10mb mode. */
+    LM_UINT32 MacMode;
+    LM_UINT32 RxMode;
+    LM_UINT32 TxMode;
+
+    /* MiMode register. */
+    LM_UINT32 MiMode;
+
+    /* Host coalesce mode register. */
+    LM_UINT32 CoalesceMode;
+
+    /* Send info. */
+    LM_UINT32 TxPacketDescCnt;
+
+    /* Tx info. */
+    LM_TX_PACKET_Q TxPacketFreeQ;
+    LM_TX_PACKET_Q TxPacketActiveQ;
+    LM_TX_PACKET_Q TxPacketXmittedQ;
+
+    /* Pointers to SendBd. */
+    PT3_SND_BD pSendBdVirt;
+    LM_PHYSICAL_ADDRESS SendBdPhy;  /* Only valid for Host based Send BD. */
+
+    /* Send producer and consumer indices. */
+    LM_UINT32 SendProdIdx;
+    LM_UINT32 SendConIdx;
+
+    /* Number of BD left. */
+    atomic_t SendBdLeft;
+
+    T3_SND_BD ShadowSendBd[T3_SEND_RCB_ENTRY_COUNT];
+
+    /* Counters. */
+    LM_RX_COUNTERS RxCounters;
+    LM_TX_COUNTERS TxCounters;
+
+    /* Host coalescing parameters. */
+    LM_UINT32 RxCoalescingTicks;
+    LM_UINT32 TxCoalescingTicks;
+    LM_UINT32 RxMaxCoalescedFrames;
+    LM_UINT32 TxMaxCoalescedFrames;
+    LM_UINT32 StatsCoalescingTicks;
+    LM_UINT32 RxCoalescingTicksDuringInt;
+    LM_UINT32 TxCoalescingTicksDuringInt;
+    LM_UINT32 RxMaxCoalescedFramesDuringInt;
+    LM_UINT32 TxMaxCoalescedFramesDuringInt;
+
+    /* DMA water marks. */
+    LM_UINT32 DmaMbufLowMark;
+    LM_UINT32 RxMacMbufLowMark;
+    LM_UINT32 MbufHighMark;
+
+    /* Status block. */
+    PT3_STATUS_BLOCK pStatusBlkVirt;
+    LM_PHYSICAL_ADDRESS StatusBlkPhy;
+
+    /* Statistics block. */
+    PT3_STATS_BLOCK pStatsBlkVirt;
+    LM_PHYSICAL_ADDRESS StatsBlkPhy;
+
+    /* Current receive mask. */
+    LM_UINT32 ReceiveMask;
+
+    /* Task offload capabilities. */
+    LM_TASK_OFFLOAD TaskOffloadCap;
+
+    /* Task offload selected. */
+    LM_TASK_OFFLOAD TaskToOffload;
+
+    /* Wake up capability. */
+    LM_WAKE_UP_MODE WakeUpModeCap;
+
+    /* Wake up capability. */
+    LM_WAKE_UP_MODE WakeUpMode;
+
+    /* Flow control. */
+    LM_FLOW_CONTROL FlowControlCap;
+    LM_FLOW_CONTROL FlowControl;
+
+    /* Enable or disable PCI MWI. */
+    LM_UINT32 EnableMWI;
+
+    /* Enable 5701 tagged status mode. */
+    LM_UINT32 UseTaggedStatus;
+
+    /* NIC will not compute the pseudo header checksum.  The driver or OS */
+    /* must seed the checksum field with the pseudo checksum. */
+    LM_UINT32 NoTxPseudoHdrChksum;
+
+    /* The receive checksum in the BD does not include the pseudo checksum. */
+    /* The OS or the driver must calculate the pseudo checksum and add it to */
+    /* the checksum in the BD. */
+    LM_UINT32 NoRxPseudoHdrChksum;
+
+    /* Current node address. */
+    LM_UINT8 NodeAddress[8];
+
+    /* The adapter's node address. */
+    LM_UINT8 PermanentNodeAddress[8];
+
+    /* Adapter info. */
+    LM_UINT16 BusNum;               // Init by the upper module.
+    LM_UINT8 DevNum;                // Init by the upper module.
+    LM_UINT8 FunctNum;              // Init by the upper module.
+    LM_UINT16 PciVendorId;
+    LM_UINT16 PciDeviceId;
+    LM_UINT32 BondId;
+    LM_UINT8 Irq;
+    LM_UINT8 IntPin;
+    LM_UINT8 CacheLineSize;
+    LM_UINT8 PciRevId;
+#if PCIX_TARGET_WORKAROUND
+	LM_UINT32 EnablePciXFix;
+#endif
+	LM_UINT32 PciCommandStatusWords;
+    LM_UINT32 ChipRevId;
+    LM_UINT16 SubsystemVendorId;
+    LM_UINT16 SubsystemId;
+    LM_UINT32 MemBaseLow;
+    LM_UINT32 MemBaseHigh;
+    LM_UINT32 MemBaseSize;
+    PLM_UINT8 pMappedMemBase;
+
+    /* Saved PCI configuration registers for restoring after a reset. */
+    LM_UINT32 SavedCacheLineReg;
+
+    /* Phy info. */
+    LM_UINT32 PhyAddr;
+    LM_UINT32 PhyId;
+
+    /* Requested phy settings. */
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType;
+
+    /* Disable auto-negotiation. */
+    LM_UINT32 DisableAutoNeg;
+
+    /* Ways for the MAC to get link change interrupt. */
+    LM_UINT32 PhyIntMode;
+    #define T3_PHY_INT_MODE_AUTO                        0
+    #define T3_PHY_INT_MODE_MI_INTERRUPT                1
+    #define T3_PHY_INT_MODE_LINK_READY                  2
+    #define T3_PHY_INT_MODE_AUTO_POLLING                3
+
+    /* Ways to determine link change status. */
+    LM_UINT32 LinkChngMode;
+    #define T3_LINK_CHNG_MODE_AUTO                      0
+    #define T3_LINK_CHNG_MODE_USE_STATUS_REG            1
+    #define T3_LINK_CHNG_MODE_USE_STATUS_BLOCK          2
+
+    /* LED mode. */
+    LM_UINT32 LedMode;
+
+    #define LED_MODE_AUTO                               0
+
+    /* 5700/01 LED mode. */
+    #define LED_MODE_THREE_LINK                         1
+    #define LED_MODE_LINK10                             2
+
+    /* 5703/02/04 LED mode. */
+    #define LED_MODE_OPEN_DRAIN                         1
+    #define LED_MODE_OUTPUT                             2
+
+    /* WOL Speed */
+    LM_UINT32 WolSpeed;
+    #define WOL_SPEED_10MB                              1
+    #define WOL_SPEED_100MB                             2
+
+    /* Reset the PHY on initialization. */
+    LM_UINT32 ResetPhyOnInit;
+
+    LM_UINT32 RestoreOnWakeUp;
+    LM_REQUESTED_MEDIA_TYPE WakeUpRequestedMediaType;
+    LM_UINT32 WakeUpDisableAutoNeg;
+
+    /* Current phy settings. */
+    LM_MEDIA_TYPE MediaType;
+    LM_LINE_SPEED LineSpeed;
+    LM_LINE_SPEED OldLineSpeed;
+    LM_DUPLEX_MODE DuplexMode;
+    LM_STATUS LinkStatus;
+    LM_UINT32 advertising;
+    LM_UINT32 advertising1000;
+
+    /* Multicast address list. */
+    LM_UINT32 McEntryCount;
+    LM_UINT8 McTable[LM_MAX_MC_TABLE_SIZE][LM_MC_ENTRY_SIZE];
+
+    /* Use NIC or Host based send BD. */
+    LM_UINT32 NicSendBd;
+
+    /* Athlon fix. */
+    LM_UINT32 DelayPciGrant;
+
+    /* Enable OneDmaAtOnce */
+    LM_UINT32 OneDmaAtOnce;
+
+    /* Init flag. */
+    LM_BOOL InitDone;
+
+    /* Shutdown flag.  Set by the upper module. */
+    LM_BOOL ShuttingDown;
+
+    /* Flag to determine whether to call LM_QueueRxPackets or not in */
+    /* LM_ResetAdapter routine. */
+    LM_BOOL QueueRxPackets;
+
+    LM_UINT32 MbufBase;
+    LM_UINT32 MbufSize;
+
+    /* TRUE if we have a SERDES PHY. */
+    LM_UINT32 EnableTbi;
+
+    /* Ethernet@WireSpeed. */
+    LM_UINT32 EnableWireSpeed;
+
+    LM_UINT32 EepromWp;
+
+#if INCLUDE_TBI_SUPPORT
+    /* Autoneg state info. */
+    AN_STATE_INFO AnInfo;
+    LM_UINT32 PollTbiLink;
+    LM_UINT32 IgnoreTbiLinkChange;
+#endif
+    char PartNo[24];
+    char BootCodeVer[16];
+    LM_UINT32 PhyCrcCount;
+} LM_DEVICE_BLOCK;
+
+
+#define T3_REG_CPU_VIEW               0xc0000000
+
+#define T3_BLOCK_DMA_RD               (1 << 0)
+#define T3_BLOCK_DMA_COMP             (1 << 1)
+#define T3_BLOCK_RX_BD_INITIATOR      (1 << 2)
+#define T3_BLOCK_RX_BD_COMP           (1 << 3)
+#define T3_BLOCK_DMA_WR               (1 << 4)
+#define T3_BLOCK_MSI_HANDLER          (1 << 5)
+#define T3_BLOCK_RX_LIST_PLMT         (1 << 6)
+#define T3_BLOCK_RX_LIST_SELECTOR     (1 << 7)
+#define T3_BLOCK_RX_DATA_INITIATOR    (1 << 8)
+#define T3_BLOCK_RX_DATA_COMP         (1 << 9)
+#define T3_BLOCK_HOST_COALESING       (1 << 10)
+#define T3_BLOCK_MAC_RX_ENGINE        (1 << 11)
+#define T3_BLOCK_MBUF_CLUSTER_FREE    (1 << 12)
+#define T3_BLOCK_SEND_BD_INITIATOR    (1 << 13)
+#define T3_BLOCK_SEND_BD_COMP         (1 << 14)
+#define T3_BLOCK_SEND_BD_SELECTOR     (1 << 15)
+#define T3_BLOCK_SEND_DATA_INITIATOR  (1 << 16)
+#define T3_BLOCK_SEND_DATA_COMP       (1 << 17)
+#define T3_BLOCK_MAC_TX_ENGINE        (1 << 18)
+#define T3_BLOCK_MEM_ARBITOR          (1 << 19)
+#define T3_BLOCK_MBUF_MANAGER         (1 << 20)
+#define T3_BLOCK_MAC_GLOBAL           (1 << 21)
+
+#define LM_ENABLE               1
+#define LM_DISABLE              2
+
+#define RX_CPU_EVT_SW0              0
+#define RX_CPU_EVT_SW1              1
+#define RX_CPU_EVT_RLP              2
+#define RX_CPU_EVT_SW3              3
+#define RX_CPU_EVT_RLS              4
+#define RX_CPU_EVT_SW4              5
+#define RX_CPU_EVT_RX_BD_COMP       6
+#define RX_CPU_EVT_SW5              7
+#define RX_CPU_EVT_RDI              8
+#define RX_CPU_EVT_DMA_WR           9
+#define RX_CPU_EVT_DMA_RD           10
+#define RX_CPU_EVT_SWQ              11
+#define RX_CPU_EVT_SW6              12
+#define RX_CPU_EVT_RDC              13
+#define RX_CPU_EVT_SW7              14
+#define RX_CPU_EVT_HOST_COALES      15
+#define RX_CPU_EVT_SW8              16
+#define RX_CPU_EVT_HIGH_DMA_WR      17
+#define RX_CPU_EVT_HIGH_DMA_RD      18
+#define RX_CPU_EVT_SW9              19
+#define RX_CPU_EVT_DMA_ATTN         20
+#define RX_CPU_EVT_LOW_P_MBOX       21
+#define RX_CPU_EVT_HIGH_P_MBOX      22
+#define RX_CPU_EVT_SW10             23
+#define RX_CPU_EVT_TX_CPU_ATTN      24
+#define RX_CPU_EVT_MAC_ATTN         25
+#define RX_CPU_EVT_RX_CPU_ATTN      26
+#define RX_CPU_EVT_FLOW_ATTN        27
+#define RX_CPU_EVT_SW11             28
+#define RX_CPU_EVT_TIMER            29
+#define RX_CPU_EVT_SW12             30
+#define RX_CPU_EVT_SW13             31
+
+/* RX-CPU event */
+#define RX_CPU_EVENT_SW_EVENT0      (1 << RX_CPU_EVT_SW0)
+#define RX_CPU_EVENT_SW_EVENT1      (1 << RX_CPU_EVT_SW1)
+#define RX_CPU_EVENT_RLP            (1 << RX_CPU_EVT_RLP)
+#define RX_CPU_EVENT_SW_EVENT3      (1 << RX_CPU_EVT_SW3)
+#define RX_CPU_EVENT_RLS            (1 << RX_CPU_EVT_RLS)
+#define RX_CPU_EVENT_SW_EVENT4      (1 << RX_CPU_EVT_SW4)
+#define RX_CPU_EVENT_RX_BD_COMP     (1 << RX_CPU_EVT_RX_BD_COMP)
+#define RX_CPU_EVENT_SW_EVENT5      (1 << RX_CPU_EVT_SW5)
+#define RX_CPU_EVENT_RDI            (1 << RX_CPU_EVT_RDI)
+#define RX_CPU_EVENT_DMA_WR         (1 << RX_CPU_EVT_DMA_WR)
+#define RX_CPU_EVENT_DMA_RD         (1 << RX_CPU_EVT_DMA_RD)
+#define RX_CPU_EVENT_SWQ            (1 << RX_CPU_EVT_SWQ)
+#define RX_CPU_EVENT_SW_EVENT6      (1 << RX_CPU_EVT_SW6)
+#define RX_CPU_EVENT_RDC            (1 << RX_CPU_EVT_RDC)
+#define RX_CPU_EVENT_SW_EVENT7      (1 << RX_CPU_EVT_SW7)
+#define RX_CPU_EVENT_HOST_COALES    (1 << RX_CPU_EVT_HOST_COALES)
+#define RX_CPU_EVENT_SW_EVENT8      (1 << RX_CPU_EVT_SW8)
+#define RX_CPU_EVENT_HIGH_DMA_WR    (1 << RX_CPU_EVT_HIGH_DMA_WR)
+#define RX_CPU_EVENT_HIGH_DMA_RD    (1 << RX_CPU_EVT_HIGH_DMA_RD)
+#define RX_CPU_EVENT_SW_EVENT9      (1 << RX_CPU_EVT_SW9)
+#define RX_CPU_EVENT_DMA_ATTN       (1 << RX_CPU_EVT_DMA_ATTN)
+#define RX_CPU_EVENT_LOW_P_MBOX     (1 << RX_CPU_EVT_LOW_P_MBOX)
+#define RX_CPU_EVENT_HIGH_P_MBOX    (1 << RX_CPU_EVT_HIGH_P_MBOX)
+#define RX_CPU_EVENT_SW_EVENT10     (1 << RX_CPU_EVT_SW10)
+#define RX_CPU_EVENT_TX_CPU_ATTN    (1 << RX_CPU_EVT_TX_CPU_ATTN)
+#define RX_CPU_EVENT_MAC_ATTN       (1 << RX_CPU_EVT_MAC_ATTN)
+#define RX_CPU_EVENT_RX_CPU_ATTN    (1 << RX_CPU_EVT_RX_CPU_ATTN)
+#define RX_CPU_EVENT_FLOW_ATTN      (1 << RX_CPU_EVT_FLOW_ATTN)
+#define RX_CPU_EVENT_SW_EVENT11     (1 << RX_CPU_EVT_SW11)
+#define RX_CPU_EVENT_TIMER          (1 << RX_CPU_EVT_TIMER)
+#define RX_CPU_EVENT_SW_EVENT12     (1 << RX_CPU_EVT_SW12)
+#define RX_CPU_EVENT_SW_EVENT13     (1 << RX_CPU_EVT_SW13)
+
+#define RX_CPU_MASK (RX_CPU_EVENT_SW_EVENT0 | \
+		     RX_CPU_EVENT_RLP | \
+		     RX_CPU_EVENT_RDI | \
+		     RX_CPU_EVENT_RDC)
+
+#define TX_CPU_EVT_SW0              0
+#define TX_CPU_EVT_SW1              1
+#define TX_CPU_EVT_SW2              2
+#define TX_CPU_EVT_SW3              3
+#define TX_CPU_EVT_TX_MAC           4
+#define TX_CPU_EVT_SW4              5
+#define TX_CPU_EVT_SBDC             6
+#define TX_CPU_EVT_SW5              7
+#define TX_CPU_EVT_SDI              8
+#define TX_CPU_EVT_DMA_WR           9
+#define TX_CPU_EVT_DMA_RD           10
+#define TX_CPU_EVT_SWQ              11
+#define TX_CPU_EVT_SW6              12
+#define TX_CPU_EVT_SDC              13
+#define TX_CPU_EVT_SW7              14
+#define TX_CPU_EVT_HOST_COALES      15
+#define TX_CPU_EVT_SW8              16
+#define TX_CPU_EVT_HIGH_DMA_WR      17
+#define TX_CPU_EVT_HIGH_DMA_RD      18
+#define TX_CPU_EVT_SW9              19
+#define TX_CPU_EVT_DMA_ATTN         20
+#define TX_CPU_EVT_LOW_P_MBOX       21
+#define TX_CPU_EVT_HIGH_P_MBOX      22
+#define TX_CPU_EVT_SW10             23
+#define TX_CPU_EVT_RX_CPU_ATTN      24
+#define TX_CPU_EVT_MAC_ATTN         25
+#define TX_CPU_EVT_TX_CPU_ATTN      26
+#define TX_CPU_EVT_FLOW_ATTN        27
+#define TX_CPU_EVT_SW11             28
+#define TX_CPU_EVT_TIMER            29
+#define TX_CPU_EVT_SW12             30
+#define TX_CPU_EVT_SW13             31
+
+
+/* TX-CPU event */
+#define TX_CPU_EVENT_SW_EVENT0      (1 << TX_CPU_EVT_SW0)
+#define TX_CPU_EVENT_SW_EVENT1      (1 << TX_CPU_EVT_SW1)
+#define TX_CPU_EVENT_SW_EVENT2      (1 << TX_CPU_EVT_SW2)
+#define TX_CPU_EVENT_SW_EVENT3      (1 << TX_CPU_EVT_SW3)
+#define TX_CPU_EVENT_TX_MAC         (1 << TX_CPU_EVT_TX_MAC)
+#define TX_CPU_EVENT_SW_EVENT4      (1 << TX_CPU_EVT_SW4)
+#define TX_CPU_EVENT_SBDC           (1 << TX_CPU_EVT_SBDC)
+#define TX_CPU_EVENT_SW_EVENT5      (1 << TX_CPU_EVT_SW5)
+#define TX_CPU_EVENT_SDI            (1 << TX_CPU_EVT_SDI)
+#define TX_CPU_EVENT_DMA_WR         (1 << TX_CPU_EVT_DMA_WR)
+#define TX_CPU_EVENT_DMA_RD         (1 << TX_CPU_EVT_DMA_RD)
+#define TX_CPU_EVENT_SWQ            (1 << TX_CPU_EVT_SWQ)
+#define TX_CPU_EVENT_SW_EVENT6      (1 << TX_CPU_EVT_SW6)
+#define TX_CPU_EVENT_SDC            (1 << TX_CPU_EVT_SDC)
+#define TX_CPU_EVENT_SW_EVENT7      (1 << TX_CPU_EVT_SW7)
+#define TX_CPU_EVENT_HOST_COALES    (1 << TX_CPU_EVT_HOST_COALES)
+#define TX_CPU_EVENT_SW_EVENT8      (1 << TX_CPU_EVT_SW8)
+#define TX_CPU_EVENT_HIGH_DMA_WR    (1 << TX_CPU_EVT_HIGH_DMA_WR)
+#define TX_CPU_EVENT_HIGH_DMA_RD    (1 << TX_CPU_EVT_HIGH_DMA_RD)
+#define TX_CPU_EVENT_SW_EVENT9      (1 << TX_CPU_EVT_SW9)
+#define TX_CPU_EVENT_DMA_ATTN       (1 << TX_CPU_EVT_DMA_ATTN)
+#define TX_CPU_EVENT_LOW_P_MBOX     (1 << TX_CPU_EVT_LOW_P_MBOX)
+#define TX_CPU_EVENT_HIGH_P_MBOX    (1 << TX_CPU_EVT_HIGH_P_MBOX)
+#define TX_CPU_EVENT_SW_EVENT10     (1 << TX_CPU_EVT_SW10)
+#define TX_CPU_EVENT_RX_CPU_ATTN    (1 << TX_CPU_EVT_RX_CPU_ATTN)
+#define TX_CPU_EVENT_MAC_ATTN       (1 << TX_CPU_EVT_MAC_ATTN)
+#define TX_CPU_EVENT_TX_CPU_ATTN    (1 << TX_CPU_EVT_TX_CPU_ATTN)
+#define TX_CPU_EVENT_FLOW_ATTN      (1 << TX_CPU_EVT_FLOW_ATTN)
+#define TX_CPU_EVENT_SW_EVENT11     (1 << TX_CPU_EVT_SW11)
+#define TX_CPU_EVENT_TIMER          (1 << TX_CPU_EVT_TIMER)
+#define TX_CPU_EVENT_SW_EVENT12     (1 << TX_CPU_EVT_SW12)
+#define TX_CPU_EVENT_SW_EVENT13     (1 << TX_CPU_EVT_SW13)
+
+
+#define TX_CPU_MASK (TX_CPU_EVENT_SW_EVENT0 | \
+		     TX_CPU_EVENT_SDI  | \
+		     TX_CPU_EVENT_SDC)
+
+
+#define T3_FTQ_TYPE1_UNDERFLOW_BIT   (1 << 29)
+#define T3_FTQ_TYPE1_PASS_BIT        (1 << 30)
+#define T3_FTQ_TYPE1_SKIP_BIT        (1 << 31)
+
+#define T3_FTQ_TYPE2_UNDERFLOW_BIT   (1 << 13)
+#define T3_FTQ_TYPE2_PASS_BIT        (1 << 14)
+#define T3_FTQ_TYPE2_SKIP_BIT        (1 << 15)
+
+#define T3_QID_DMA_READ               1
+#define T3_QID_DMA_HIGH_PRI_READ      2
+#define T3_QID_DMA_COMP_DX            3
+#define T3_QID_SEND_BD_COMP           4
+#define T3_QID_SEND_DATA_INITIATOR    5
+#define T3_QID_DMA_WRITE              6
+#define T3_QID_DMA_HIGH_PRI_WRITE     7
+#define T3_QID_SW_TYPE_1              8
+#define T3_QID_SEND_DATA_COMP         9
+#define T3_QID_HOST_COALESCING        10
+#define T3_QID_MAC_TX                 11
+#define T3_QID_MBUF_CLUSTER_FREE      12
+#define T3_QID_RX_BD_COMP             13
+#define T3_QID_RX_LIST_PLM            14
+#define T3_QID_RX_DATA_BD_INITIATOR   15
+#define T3_QID_RX_DATA_COMP           16
+#define T3_QID_SW_TYPE2               17
+
+LM_STATUS LM_LoadFirmware(PLM_DEVICE_BLOCK pDevice,
+                          PT3_FWIMG_INFO pFwImg,
+                          LM_UINT32 LoadCpu,
+                          LM_UINT32 StartCpu);
+
+/******************************************************************************/
+/* NIC register read/write macros. */
+/******************************************************************************/
+
+/* MAC register access. */
+LM_UINT32 LM_RegRdInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Register);
+LM_VOID LM_RegWrInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Register,
+    LM_UINT32 Value32);
+
+/* MAC memory access. */
+LM_UINT32 LM_MemRdInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 MemAddr);
+LM_VOID LM_MemWrInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 MemAddr,
+    LM_UINT32 Value32);
+
+#define RAW_REG_WR(pDevice, OffsetName, Value32)                            \
+    __raw_writel(Value32, &((pDevice)->pMemView->OffsetName))
+
+#if PCIX_TARGET_WORKAROUND
+
+/* use memor-mapped accesses for mailboxes and reads, UNDI accesses
+   for writes to all other registers */
+#define REG_RD(pDevice, OffsetName)                                         \
+    __raw_readl(&((pDevice)->pMemView->OffsetName))
+
+#define REG_WR(pDevice, OffsetName, Value32)                                \
+	(((OFFSETOF(T3_STD_MEM_MAP, OffsetName) >=0x200 ) &&					\
+	  (OFFSETOF(T3_STD_MEM_MAP, OffsetName) <0x400)) ||						\
+	 ((pDevice)->EnablePciXFix == FALSE)) ?	   								\
+    (void) __raw_writel(Value32, &((pDevice)->pMemView->OffsetName)) :							\
+    LM_RegWrInd(pDevice, OFFSETOF(T3_STD_MEM_MAP, OffsetName), Value32)
+
+#define MB_REG_RD(pDevice, OffsetName)                                      \
+    __raw_readl(&((pDevice)->pMemView->OffsetName))
+
+#define MB_REG_WR(pDevice, OffsetName, Value32)                             \
+    __raw_writel(Value32, &((pDevice)->pMemView->OffsetName))
+
+#define REG_RD_OFFSET(pDevice, Offset)                                      \
+    __raw_readl(&((LM_UINT8 *) (pDevice)->pMemView + Offset))
+
+#define REG_WR_OFFSET(pDevice, Offset, Value32)                             \
+	(((Offset >=0x200 ) && (Offset < 0x400)) ||								\
+	 ((pDevice)->EnablePciXFix == FALSE)) ?	   								\
+    (void) __raw_writel(Value32, ((LM_UINT8 *) (pDevice)->pMemView + Offset)) : \
+    LM_RegWrInd(pDevice, Offset, Value32)
+
+#define MEM_RD(pDevice, AddrName)                                           \
+    LM_MemRdInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName))
+#define MEM_WR(pDevice, AddrName, Value32)                                  \
+    LM_MemWrInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName), Value32)
+
+#define MEM_RD_OFFSET(pDevice, Offset)                                      \
+    LM_MemRdInd(pDevice, Offset)
+#define MEM_WR_OFFSET(pDevice, Offset, Value32)                             \
+    LM_MemWrInd(pDevice, Offset, Value32)
+				
+#else /* normal target access path below */
+
+/* Register access. */
+#define REG_RD(pDevice, OffsetName)                                         \
+    __raw_readl(&((pDevice)->pMemView->OffsetName))
+#define REG_WR(pDevice, OffsetName, Value32)                                \
+    __raw_writel(Value32, &((pDevice)->pMemView->OffsetName))
+
+#define REG_RD_OFFSET(pDevice, Offset)                                      \
+    __raw_readl(((LM_UINT8 *) (pDevice)->pMemView + Offset))
+#define REG_WR_OFFSET(pDevice, Offset, Value32)                             \
+    __raw_writel(Value32, ((LM_UINT8 *) (pDevice)->pMemView + Offset))
+
+
+/* There could be problem access the memory window directly.  For now, */
+/* we have to go through the PCI configuration register. */
+#define MEM_RD(pDevice, AddrName)                                           \
+    LM_MemRdInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName))
+#define MEM_WR(pDevice, AddrName, Value32)                                  \
+    LM_MemWrInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName), Value32)
+
+#define MEM_RD_OFFSET(pDevice, Offset)                                      \
+    LM_MemRdInd(pDevice, Offset)
+#define MEM_WR_OFFSET(pDevice, Offset, Value32)                             \
+    LM_MemWrInd(pDevice, Offset, Value32)
+
+#endif  /* PCIX_TARGET_WORKAROUND */
+
+#endif /* TIGON3_H */
+
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/Makefile linux/drivers/net/e1000/Makefile
--- ../prev/linux/drivers/net/e1000/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/Makefile	Wed May 29 13:00:02 2002
@@ -0,0 +1,92 @@
+################################################################################
+#
+# This software program is available to you under a choice of one of two 
+# licenses. You may choose to be licensed under either the GNU General Public 
+# License (GPL) Version 2, June 1991, available at 
+# http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+# text of which follows:
+# 
+# Recipient has requested a license and Intel Corporation ("Intel") is willing
+# to grant a license for the software entitled Linux Base Driver for the 
+# Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+# by Intel Corporation. The following definitions apply to this license:
+# 
+# "Licensed Patents" means patent claims licensable by Intel Corporation which 
+# are necessarily infringed by the use of sale of the Software alone or when 
+# combined with the operating system referred to below.
+# 
+# "Recipient" means the party to whom Intel delivers this Software.
+# 
+# "Licensee" means Recipient and those third parties that receive a license to 
+# any operating system available under the GNU Public License version 2.0 or 
+# later.
+# 
+# Copyright (c) 1999 - 2002 Intel Corporation.
+# All rights reserved.
+# 
+# The license is provided to Recipient and Recipient's Licensees under the 
+# following terms.
+# 
+# Redistribution and use in source and binary forms of the Software, with or 
+# without modification, are permitted provided that the following conditions 
+# are met:
+# 
+# Redistributions of source code of the Software may retain the above 
+# copyright notice, this list of conditions and the following disclaimer.
+# 
+# Redistributions in binary form of the Software may reproduce the above 
+# copyright notice, this list of conditions and the following disclaimer in 
+# the documentation and/or materials provided with the distribution.
+# 
+# Neither the name of Intel Corporation nor the names of its contributors 
+# shall be used to endorse or promote products derived from this Software 
+# without specific prior written permission.
+# 
+# Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+# royalty-free patent license under Licensed Patents to make, use, sell, offer 
+# to sell, import and otherwise transfer the Software, if any, in source code 
+# and object code form. This license shall include changes to the Software 
+# that are error corrections or other minor changes to the Software that do 
+# not add functionality or features when the Software is incorporated in any 
+# version of an operating system that has been distributed under the GNU 
+# General Public License 2.0 or later. This patent license shall apply to the 
+# combination of the Software and any operating system licensed under the GNU 
+# Public License version 2.0 or later if, at the time Intel provides the 
+# Software to Recipient, such addition of the Software to the then publicly 
+# available versions of such operating systems available under the GNU Public 
+# License version 2.0 or later (whether in gold, beta or alpha form) causes 
+# such combination to be covered by the Licensed Patents. The patent license 
+# shall not apply to any other combinations which include the Software. NO 
+# hardware per se is licensed hereunder.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+# IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+# ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+# (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+# ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+################################################################################
+
+###########################################################################
+# Configuration Section
+
+# Optional features - set to 'y' for on, anything else for off
+# Intel(R) Advanced Network Services
+IANS := n
+# Intel(R) PRO Diagnostics
+IDIAG := n
+
+###########################################################################
+# Driver files
+
+# core driver files
+O_TARGET := e1000.o
+obj-y 	 := e1000_main.o e1000_mac.o e1000_phy.o e1000_proc.o
+obj-m	 := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000.h linux/drivers/net/e1000/e1000.h
--- ../prev/linux/drivers/net/e1000/e1000.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000.h	Wed May 29 13:00:02 2002
@@ -0,0 +1,362 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+/* Linux PRO/1000 Ethernet Driver main header file */
+
+#ifndef _E1000_H_
+#define _E1000_H_
+
+#ifndef __E1000_MAIN__
+#define __NO_VERSION__
+#endif
+
+#include <linux/stddef.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/pagemap.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <linux/capability.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <net/pkt_sched.h>
+
+/* ethtool support */
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#define  E1000_ETHTOOL_COPPER_INTERFACE_SUPPORTS (SUPPORTED_10baseT_Half | \
+                    SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half | \
+                    SUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Full | \
+                    SUPPORTED_Autoneg | SUPPORTED_MII)
+#define  E1000_ETHTOOL_COPPER_INTERFACE_ADVERTISE (ADVERTISED_10baseT_Half | \
+                    ADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half | \
+                    ADVERTISED_100baseT_Full | ADVERTISED_1000baseT_Full | \
+                    ADVERTISED_Autoneg | ADVERTISED_MII)
+#define E1000_ETHTOOL_FIBER_INTERFACE_SUPPORTS (SUPPORTED_Autoneg | \
+                    SUPPORTED_FIBRE)
+#define E1000_ETHTOOL_FIBER_INTERFACE_ADVERTISE (ADVERTISED_Autoneg | \
+                    ADVERTISED_FIBRE)
+#endif /* SIOCETHTOOL */
+
+
+
+struct e1000_adapter;
+
+#include "e1000_mac.h"
+#include "e1000_phy.h"
+
+#ifdef IANS
+#include "base_comm.h"
+#include "ans_driver.h"
+#include "ans.h"
+#endif
+
+#ifdef IDIAG
+#include "idiag_pro.h"
+#include "idiag_e1000.h"
+#endif
+
+#define BAR_0 0
+
+/* 8254x can use Dual Address Cycles for 64-bit addressing */
+
+/* Advertise that we can DMA from any address location */
+#define E1000_DMA_MASK (~0x0UL)
+#define E1000_DBG(args...)
+// #define E1000_DBG(args...) printk("e1000: " args)
+#define E1000_ERR(args...) printk(KERN_ERR "e1000: " args)
+#ifdef CONFIG_PPC
+#define E1000_MAX_INTR 1
+#else
+#define E1000_MAX_INTR 10
+#endif
+#define MAX_NUM_MULTICAST_ADDRESSES 128
+
+/* command line options defaults */
+#define DEFAULT_TXD                  256
+#define MAX_TXD                      256
+#define MIN_TXD                       80
+#define MAX_82544_TXD               4096
+#define DEFAULT_RXD                  256
+#define MAX_RXD                      256
+#define MIN_RXD                       80
+#define MAX_82544_RXD               4096
+#define DEFAULT_TIDV                  64
+#define MAX_TIDV                  0xFFFF
+#define MIN_TIDV                       0
+#define DEFAULT_RIDV                  64
+#define MAX_RIDV                  0xFFFF
+#define MIN_RIDV                       0
+#define DEFAULT_MDIX                   0
+#define MAX_MDIX                       3
+#define MIN_MDIX                       0
+
+#define OPTION_UNSET    -1
+#define OPTION_DISABLED 0
+#define OPTION_ENABLED  1
+#define XSUMRX_DEFAULT       OPTION_ENABLED
+#define WAITFORLINK_DEFAULT  OPTION_ENABLED
+#define AUTONEG_ADV_DEFAULT  0x2F
+#define AUTONEG_ADV_MASK     0x2F
+#define FLOW_CONTROL_DEFAULT FLOW_CONTROL_FULL
+
+#define E1000_REPORT_TX_EARLY  2
+
+/* Supported RX Buffer Sizes */
+#define E1000_RXBUFFER_2048  2048
+#define E1000_RXBUFFER_4096  4096
+#define E1000_RXBUFFER_8192  8192
+#define E1000_RXBUFFER_16384 16384
+
+#define E1000_JUMBO_PBA      0x00000028
+#define E1000_DEFAULT_PBA    0x00000030
+
+/* Round size up to the next multiple of unit */
+#define E1000_ROUNDUP(size, unit) ((((size) + (unit) - 1) / (unit)) * (unit))
+
+/* This is better, but only works for unit sizes that are powers of 2 */
+#define E1000_ROUNDUP2(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))
+
+/* wrapper around a pointer to a socket buffer,
+ * so a DMA handle can be stored along with the buffer */
+struct e1000_buffer {
+    struct sk_buff *skb;
+    uint64_t dma;
+    unsigned long length;
+};
+
+/* Adapter->flags definitions */
+#define E1000_BOARD_OPEN 0
+#define E1000_RX_REFILL 1
+#define E1000_DIAG_OPEN 2
+#define E1000_LINK_STATUS_CHANGED 3
+
+typedef enum _XSUM_CONTEXT_T {
+    OFFLOAD_NONE,
+    OFFLOAD_TCP_IP,
+    OFFLOAD_UDP_IP
+} XSUM_CONTEXT_T;
+
+struct e1000_desc_ring {
+    void *desc;                 /* pointer to the descriptor ring memory      */
+    dma_addr_t dma;             /* physical address of the descriptor ring    */
+    unsigned int size;          /* length of descriptor ring in bytes         */
+    unsigned int count;         /* number of descriptors in the ring          */
+    atomic_t unused;            /* number of descriptors with no buffer       */
+    unsigned int next_to_use;   /* next descriptor to associate a buffer with */
+    unsigned int next_to_clean; /* next descriptor to check for DD status bit */
+    struct e1000_buffer *buffer_info; /* array of buffer information structs  */
+};
+
+#define E1000_RX_DESC(ring, i) \
+    (&(((struct e1000_rx_desc *)(ring.desc))[i]))
+
+#define E1000_TX_DESC(ring, i) \
+    (&(((struct e1000_tx_desc *)(ring.desc))[i]))
+
+#define E1000_CONTEXT_DESC(ring, i) \
+    (&(((struct e1000_context_desc *)(ring.desc))[i]))
+
+/* board specific private data structure */
+
+struct e1000_adapter {
+    struct e1000_adapter *next;
+    struct e1000_adapter *prev;
+
+    struct e1000_shared_adapter shared;
+
+#ifdef IANS
+    void *iANSReserved;
+    piANSsupport_t iANSdata;
+    uint32_t ans_link;
+    uint32_t ans_speed;
+    uint32_t ans_duplex;
+    uint32_t ans_suspend;
+    IANS_BD_TAGGING_MODE tag_mode;
+#endif
+
+    spinlock_t stats_lock;
+    spinlock_t rx_fill_lock;
+
+    unsigned long flags;
+    uint32_t bd_number;
+    struct timer_list timer_id;
+
+    /* Ethernet Node Address */
+    uint8_t perm_net_addr[ETH_LENGTH_OF_ADDRESS];
+
+    /* Status Flags */
+    boolean_t link_active;
+    uint16_t link_speed;
+    uint16_t link_duplex;
+    uint32_t rx_buffer_len;
+
+    /* PCI Device Info */
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint8_t rev_id;
+    uint16_t subven_id;
+    uint16_t subsys_id;
+
+    uint32_t part_num;
+
+    uint32_t int_mask;
+
+    /* driver specific */
+    struct tasklet_struct rx_fill_tasklet;
+
+    struct e1000_desc_ring tx_ring;
+    uint32_t tx_int_delay;
+    uint32_t TxdCmd;
+    atomic_t tx_timeout;
+
+    struct e1000_desc_ring rx_ring;
+    uint32_t rx_int_delay;
+
+    uint64_t XsumRXGood;
+    uint64_t XsumRXError;
+
+    /* Linux driver specific */
+    struct net_device *netdev;
+    struct pci_dev *pdev;
+    struct net_device_stats net_stats;
+    char *id_string;
+    boolean_t RxChecksum;
+    XSUM_CONTEXT_T ActiveChecksumContext;
+
+    struct e1000_phy_info phy_info;
+    struct e1000_shared_stats stats;
+
+    /* PHY Statistics */
+    struct e1000_phy_stats phy_stats;
+};
+
+/* Prototypes */
+
+/* e1000_main.c */
+extern int e1000_init_module(void);
+extern int e1000_probe_all(void);
+extern void e1000_exit_module(void);
+extern int e1000_probe(struct pci_dev *pdev,
+                       const struct pci_device_id *ent);
+extern void e1000_remove(struct pci_dev *pdev);
+extern void e1000_delete(struct e1000_adapter *Adapter);
+extern int e1000_open(struct net_device *netdev);
+extern int e1000_close(struct net_device *netdev);
+extern void e1000_set_multi(struct net_device *netdev);
+extern int e1000_xmit_frame(struct sk_buff *skb,
+                            struct net_device *netdev);
+extern struct net_device_stats *e1000_get_stats(struct net_device *netdev);
+extern int e1000_change_mtu(struct net_device *netdev,
+                            int new_mtu);
+extern int e1000_set_mac(struct net_device *netdev,
+                         void *p);
+extern void e1000_intr(int irq,
+                       void *data,
+                       struct pt_regs *regs);
+extern int e1000_ioctl(struct net_device *netdev,
+                       struct ifreq *ifr,
+                       int cmd);
+extern void e1000_watchdog(unsigned long data);
+extern void e1000_diag_ioctl(struct net_device *netdev,
+                             struct ifreq *ifr);
+
+#ifdef CONFIG_PROC_FS
+#include "e1000_proc.h"
+#endif
+#ifdef IDIAG
+#include "e1000_idiag.h"
+#endif
+#endif /* _E1000_H_ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_mac.c linux/drivers/net/e1000/e1000_mac.c
--- ../prev/linux/drivers/net/e1000/e1000_mac.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_mac.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,2093 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_mac.c
+ * Shared functions for accessing and configuring the MAC
+ */
+
+#include "e1000_mac.h"
+#include "e1000_phy.h"
+
+/******************************************************************************
+ * Raises the EEPROM's clock input.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * eecd_reg - EECD's current value
+ *****************************************************************************/
+static void
+e1000_raise_clock(struct e1000_shared_adapter *shared,
+                  uint32_t *eecd_reg)
+{
+    /* Raise the clock input to the EEPROM (by setting the SK bit), and then
+     * wait 50 microseconds.
+     */
+    *eecd_reg = *eecd_reg | E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, *eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Lowers the EEPROM's clock input.
+ *
+ * shared - Struct containing variables accessed by shared code 
+ * eecd_reg - EECD's current value
+ *****************************************************************************/
+static void
+e1000_lower_clock(struct e1000_shared_adapter *shared,
+                  uint32_t *eecd_reg)
+{
+    /* Lower the clock input to the EEPROM (by clearing the SK bit), and then 
+     * wait 50 microseconds. 
+     */
+    *eecd_reg = *eecd_reg & ~E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, *eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Shift data bits out to the EEPROM.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * data - data to send to the EEPROM
+ * count - number of bits to shift out
+ *****************************************************************************/
+static void
+e1000_shift_out_bits(struct e1000_shared_adapter *shared,
+                     uint16_t data,
+                     uint16_t count)
+{
+    uint32_t eecd_reg;
+    uint32_t mask;
+
+    /* We need to shift "count" bits out to the EEPROM. So, value in the
+     * "data" parameter will be shifted out to the EEPROM one bit at a time.
+     * In order to do this, "data" must be broken down into bits. 
+     */
+    mask = 0x01 << (count - 1);
+    eecd_reg = E1000_READ_REG(shared, EECD);
+    eecd_reg &= ~(E1000_EECD_DO | E1000_EECD_DI);
+    do {
+        /* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",
+         * and then raising and then lowering the clock (the SK bit controls
+         * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM
+         * by setting "DI" to "0" and then raising and then lowering the clock.
+         */
+        eecd_reg &= ~E1000_EECD_DI;
+
+        if(data & mask)
+            eecd_reg |= E1000_EECD_DI;
+
+        E1000_WRITE_REG(shared, EECD, eecd_reg);
+
+        usec_delay(50);
+
+        e1000_raise_clock(shared, &eecd_reg);
+        e1000_lower_clock(shared, &eecd_reg);
+
+        mask = mask >> 1;
+
+    } while(mask);
+
+    /* We leave the "DI" bit set to "0" when we leave this routine. */
+    eecd_reg &= ~E1000_EECD_DI;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    return;
+}
+
+/******************************************************************************
+ * Shift data bits in from the EEPROM
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static uint16_t
+e1000_shift_in_bits(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+    uint32_t i;
+    uint16_t data;
+
+    /* In order to read a register from the EEPROM, we need to shift 16 bits 
+     * in from the EEPROM. Bits are "shifted in" by raising the clock input to
+     * the EEPROM (setting the SK bit), and then reading the value of the "DO"
+     * bit.  During this "shifting in" process the "DI" bit should always be 
+     * clear..
+     */
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    eecd_reg &= ~(E1000_EECD_DO | E1000_EECD_DI);
+    data = 0;
+
+    for(i = 0; i < 16; i++) {
+        data = data << 1;
+        e1000_raise_clock(shared, &eecd_reg);
+
+        eecd_reg = E1000_READ_REG(shared, EECD);
+
+        eecd_reg &= ~(E1000_EECD_DI);
+        if(eecd_reg & E1000_EECD_DO)
+            data |= 1;
+
+        e1000_lower_clock(shared, &eecd_reg);
+    }
+
+    return data;
+}
+
+/******************************************************************************
+ * Prepares EEPROM for access
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This 
+ * function should be called before issuing a command to the EEPROM.
+ *****************************************************************************/
+static void
+e1000_setup_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    /* Clear SK and DI */
+    eecd_reg &= ~(E1000_EECD_SK | E1000_EECD_DI);
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+
+    /* Set CS */
+    eecd_reg |= E1000_EECD_CS;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    return;
+}
+
+/******************************************************************************
+ * Returns EEPROM to a "standby" state
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_standby_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    /* Deselct EEPROM */
+    eecd_reg &= ~(E1000_EECD_CS | E1000_EECD_SK);
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Clock high */
+    eecd_reg |= E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Select EEPROM */
+    eecd_reg |= E1000_EECD_CS;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Clock low */
+    eecd_reg &= ~E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Raises then lowers the EEPROM's clock pin
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_clock_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    /* Rising edge of clock */
+    eecd_reg |= E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Falling edge of clock */
+    eecd_reg &= ~E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Terminates a command by lowering the EEPROM's chip select pin
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_cleanup_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    eecd_reg &= ~(E1000_EECD_CS | E1000_EECD_DI);
+
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+
+    e1000_clock_eeprom(shared);
+    return;
+}
+
+/******************************************************************************
+ * Waits for the EEPROM to finish the current command.
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * The command is done when the EEPROM's data out pin goes high.
+ *****************************************************************************/
+static uint16_t
+e1000_wait_eeprom_command(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+    uint32_t i;
+
+
+    /* Toggle the CS line.  This in effect tells to EEPROM to actually execute 
+     * the command in question.
+     */
+    e1000_standby_eeprom(shared);
+
+    /* Now read DO repeatedly until is high (equal to '1').  The EEEPROM will
+     * signal that the command has been completed by raising the DO signal.
+     * If DO does not go high in 10 milliseconds, then error out.
+     */
+    for(i = 0; i < 200; i++) {
+        eecd_reg = E1000_READ_REG(shared, EECD);
+
+        if(eecd_reg & E1000_EECD_DO)
+            return (TRUE);
+
+        usec_delay(50);
+    }
+    ASSERT(0);
+    return (FALSE);
+}
+
+/******************************************************************************
+ * Forces the MAC's flow control settings.
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Sets the TFCE and RFCE bits in the device control register to reflect
+ * the adapter settings. TFCE and RFCE need to be explicitly set by
+ * software when a Copper PHY is used because autonegotiation is managed
+ * by the PHY rather than the MAC. Software must also configure these
+ * bits when link is forced on a fiber connection.
+ *****************************************************************************/
+static void
+e1000_force_mac_fc(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+
+    DEBUGFUNC("e1000_force_mac_fc");
+
+    /* Get the current configuration of the Device Control Register */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Because we didn't get link via the internal auto-negotiation
+     * mechanism (we either forced link or we got link via PHY
+     * auto-neg), we have to manually enable/disable transmit an
+     * receive flow control.
+     *
+     * The "Case" statement below enables/disable flow control
+     * according to the "shared->fc" parameter.
+     *
+     * The possible values of the "fc" parameter are:
+     *      0:  Flow control is completely disabled
+     *      1:  Rx flow control is enabled (we can receive pause
+     *          frames but not send pause frames).
+     *      2:  Tx flow control is enabled (we can send pause frames
+     *          frames but we do not receive pause frames).
+     *      3:  Both Rx and TX flow control (symmetric) is enabled.
+     *  other:  No other values should be possible at this point.
+     */
+
+    switch (shared->fc) {
+    case e1000_fc_none:
+        ctrl_reg &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
+        break;
+    case e1000_fc_rx_pause:
+        ctrl_reg &= (~E1000_CTRL_TFCE);
+        ctrl_reg |= E1000_CTRL_RFCE;
+        break;
+    case e1000_fc_tx_pause:
+        ctrl_reg &= (~E1000_CTRL_RFCE);
+        ctrl_reg |= E1000_CTRL_TFCE;
+        break;
+    case e1000_fc_full:
+        ctrl_reg |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
+        break;
+    default:
+        DEBUGOUT("Flow control param set incorrectly\n");
+        ASSERT(0);
+        break;
+    }
+
+    /* Disable TX Flow Control for 82542 (rev 2.0) */
+    if(shared->mac_type == e1000_82542_rev2_0)
+        ctrl_reg &= (~E1000_CTRL_TFCE);
+
+
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    return;
+}
+
+/******************************************************************************
+ * Reset the transmit and receive units; mask and clear all interrupts.
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_adapter_stop(struct e1000_shared_adapter *shared)
+{
+#if DBG
+    uint32_t ctrl_reg;
+#endif
+    uint32_t ctrl_ext_reg;
+    uint32_t icr_reg;
+    uint16_t pci_cmd_word;
+
+    DEBUGFUNC("e1000_shared_adapter_stop");
+
+    /* If we are stopped or resetting exit gracefully and wait to be
+     * started again before accessing the hardware.
+     */
+    if(shared->adapter_stopped) {
+        DEBUGOUT("Exiting because the adapter is already stopped!!!\n");
+        return;
+    }
+
+    /* Set the Adapter Stopped flag so other driver functions stop
+     * touching the Hardware.
+     */
+    shared->adapter_stopped = TRUE;
+
+    /* For 82542 (rev 2.0), disable MWI before issuing a device reset */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+
+            pci_cmd_word = shared->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE;
+
+            e1000_write_pci_cfg(shared, PCI_COMMAND_REGISTER, &pci_cmd_word);
+        }
+    }
+
+    /* Clear interrupt mask to stop board from generating interrupts */
+    DEBUGOUT("Masking off all interrupts\n");
+    E1000_WRITE_REG(shared, IMC, 0xffffffff);
+
+    /* Disable the Transmit and Receive units.  Then delay to allow
+     * any pending transactions to complete before we hit the MAC with
+     * the global reset.
+     */
+    E1000_WRITE_REG(shared, RCTL, 0);
+    E1000_WRITE_REG(shared, TCTL, E1000_TCTL_PSP);
+
+    /* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
+    shared->tbi_compatibility_on = FALSE;
+
+    msec_delay(10);
+
+    /* Issue a global reset to the MAC.  This will reset the chip's
+     * transmit, receive, DMA, and link units.  It will not effect
+     * the current PCI configuration.  The global reset bit is self-
+     * clearing, and should clear within a microsecond.
+     */
+    DEBUGOUT("Issuing a global reset to MAC\n");
+    E1000_WRITE_REG(shared, CTRL, E1000_CTRL_RST);
+
+    /* Delay a few ms just to allow the reset to complete */
+    msec_delay(10);
+
+#if DBG
+    /* Make sure the self-clearing global reset bit did self clear */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    ASSERT(!(ctrl_reg & E1000_CTRL_RST));
+#endif
+
+    /* Force a reload from the EEPROM */
+    ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+    ctrl_ext_reg |= E1000_CTRL_EXT_EE_RST;
+    E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+    msec_delay(2);
+    
+    /* Clear interrupt mask to stop board from generating interrupts */
+    DEBUGOUT("Masking off all interrupts\n");
+    E1000_WRITE_REG(shared, IMC, 0xffffffff);
+
+    /* Clear any pending interrupt events. */
+    icr_reg = E1000_READ_REG(shared, ICR);
+
+    /* If MWI was previously enabled, reenable it. */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            e1000_write_pci_cfg(shared,
+                                PCI_COMMAND_REGISTER, &shared->pci_cmd_word);
+        }
+    }
+    return;
+}
+
+/******************************************************************************
+ * Performs basic configuration of the adapter.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * 
+ * Assumes that the controller has previously been reset and is in a 
+ * post-reset uninitialized state. Initializes the receive address registers,
+ * multicast table, and VLAN filter table. Calls routines to setup link
+ * configuration and flow control settings. Clears all on-chip counters. Leaves
+ * the transmit and receive units disabled and uninitialized.
+ *****************************************************************************/
+boolean_t
+e1000_init_hw(struct e1000_shared_adapter *shared)
+{
+    uint32_t status_reg;
+    uint32_t i;
+    uint16_t pci_cmd_word;
+    boolean_t status;
+
+    DEBUGFUNC("e1000_init_hw");
+
+    /* Set the Media Type and exit with error if it is not valid. */
+    if(shared->mac_type != e1000_82543) {
+        /* tbi_compatibility is only valid on 82543 */
+        shared->tbi_compatibility_en = FALSE;
+    }
+
+    if(shared->mac_type >= e1000_82543) {
+        status_reg = E1000_READ_REG(shared, STATUS);
+        if(status_reg & E1000_STATUS_TBIMODE) {
+            shared->media_type = e1000_media_type_fiber;
+            /* tbi_compatibility not valid on fiber */
+            shared->tbi_compatibility_en = FALSE;
+        } else {
+            shared->media_type = e1000_media_type_copper;
+        }
+    } else {
+        /* This is an 82542 (fiber only) */
+        shared->media_type = e1000_media_type_fiber;
+    }
+
+    /* Disabling VLAN filtering. */
+    DEBUGOUT("Initializing the IEEE VLAN\n");
+    E1000_WRITE_REG(shared, VET, 0);
+
+    e1000_clear_vfta(shared);
+
+    /* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+            pci_cmd_word = shared->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE;
+            e1000_write_pci_cfg(shared, PCI_COMMAND_REGISTER, &pci_cmd_word);
+        }
+        E1000_WRITE_REG(shared, RCTL, E1000_RCTL_RST);
+
+        msec_delay(5);
+    }
+
+    /* Setup the receive address. This involves initializing all of the Receive
+     * Address Registers (RARs 0 - 15).
+     */
+    e1000_init_rx_addrs(shared);
+
+    /* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        E1000_WRITE_REG(shared, RCTL, 0);
+
+        msec_delay(1);
+
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            e1000_write_pci_cfg(shared,
+                                PCI_COMMAND_REGISTER, &shared->pci_cmd_word);
+        }
+    }
+
+    /* Zero out the Multicast HASH table */
+    DEBUGOUT("Zeroing the MTA\n");
+    for(i = 0; i < E1000_MC_TBL_SIZE; i++)
+        E1000_WRITE_REG_ARRAY(shared, MTA, i, 0);
+
+    /* Call a subroutine to configure the link and setup flow control. */
+    status = e1000_setup_fc_and_link(shared);
+
+    /* Clear all of the statistics registers (clear on read).  It is
+     * important that we do this after we have tried to establish link
+     * because the symbol error count will increment wildly if there
+     * is no link.
+     */
+    e1000_clear_hw_cntrs(shared);
+
+    shared->low_profile = FALSE;
+    if(shared->mac_type == e1000_82544) {
+        if(e1000_read_eeprom(shared, E1000_EEPROM_LED_LOGIC) & 
+           E1000_EEPROM_SWDPIN0)
+            shared->low_profile = TRUE;
+    }
+
+    return (status);
+}
+
+/******************************************************************************
+ * Initializes receive address filters.
+ *
+ * shared - Struct containing variables accessed by shared code 
+ *
+ * Places the MAC address in receive address register 0 and clears the rest
+ * of the receive addresss registers. Clears the multicast table. Assumes
+ * the receiver is in reset when the routine is called.
+ *****************************************************************************/
+void
+e1000_init_rx_addrs(struct e1000_shared_adapter *shared)
+{
+    uint32_t i;
+    uint32_t addr_low;
+    uint32_t addr_high;
+
+    DEBUGFUNC("e1000_init_rx_addrs");
+
+    /* Setup the receive address. */
+    DEBUGOUT("Programming MAC Address into RAR[0]\n");
+    addr_low = (shared->mac_addr[0] |
+                (shared->mac_addr[1] << 8) |
+                (shared->mac_addr[2] << 16) | (shared->mac_addr[3] << 24));
+
+    addr_high = (shared->mac_addr[4] |
+                 (shared->mac_addr[5] << 8) | E1000_RAH_AV);
+
+    E1000_WRITE_REG_ARRAY(shared, RA, 0, addr_low);
+    E1000_WRITE_REG_ARRAY(shared, RA, 1, addr_high);
+
+    /* Zero out the other 15 receive addresses. */
+    DEBUGOUT("Clearing RAR[1-15]\n");
+    for(i = 1; i < E1000_RAR_ENTRIES; i++) {
+        E1000_WRITE_REG_ARRAY(shared, RA, (i << 1), 0);
+        E1000_WRITE_REG_ARRAY(shared, RA, ((i << 1) + 1), 0);
+    }
+
+    return;
+}
+
+/******************************************************************************
+ * Updates the MAC's list of multicast addresses.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * mc_addr_list - the list of new multicast addresses
+ * mc_addr_count - number of addresses
+ * pad - number of bytes between addresses in the list
+ *
+ * The given list replaces any existing list. Clears the last 15 receive
+ * address registers and the multicast table. Uses receive address registers
+ * for the first 15 multicast addresses, and hashes the rest into the 
+ * multicast table.
+ *****************************************************************************/
+void
+e1000_mc_addr_list_update(struct e1000_shared_adapter *shared,
+                          uint8_t *mc_addr_list,
+                          uint32_t mc_addr_count,
+                          uint32_t pad)
+{
+    uint32_t hash_value;
+    uint32_t i;
+    uint32_t rar_used_count = 1;        /* RAR[0] is used for our MAC address */
+
+    DEBUGFUNC("e1000_mc_addr_list_update");
+
+    /* Set the new number of MC addresses that we are being requested to use. */
+    shared->num_mc_addrs = mc_addr_count;
+
+    /* Clear RAR[1-15] */
+    DEBUGOUT(" Clearing RAR[1-15]\n");
+    for(i = rar_used_count; i < E1000_RAR_ENTRIES; i++) {
+        E1000_WRITE_REG_ARRAY(shared, RA, (i << 1), 0);
+        E1000_WRITE_REG_ARRAY(shared, RA, ((i << 1) + 1), 0);
+    }
+
+    /* Clear the MTA */
+    DEBUGOUT(" Clearing MTA\n");
+    for(i = 0; i < E1000_NUM_MTA_REGISTERS; i++) {
+        E1000_WRITE_REG_ARRAY(shared, MTA, i, 0);
+    }
+
+    /* Add the new addresses */
+    for(i = 0; i < mc_addr_count; i++) {
+        DEBUGOUT(" Adding the multicast addresses:\n");
+        DEBUGOUT7(" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n", i,
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad)],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 1],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 2],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 3],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 4],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 5]);
+
+        hash_value = e1000_hash_mc_addr(shared,
+                                        mc_addr_list +
+                                        (i * (ETH_LENGTH_OF_ADDRESS + pad)));
+
+        DEBUGOUT1(" Hash value = 0x%03X\n", hash_value);
+
+        /* Place this multicast address in the RAR if there is room, *
+         * else put it in the MTA            
+         */
+        if(rar_used_count < E1000_RAR_ENTRIES) {
+            e1000_rar_set(shared,
+                          mc_addr_list + (i * (ETH_LENGTH_OF_ADDRESS + pad)),
+                          rar_used_count);
+            rar_used_count++;
+        } else {
+            e1000_mta_set(shared, hash_value);
+        }
+    }
+
+    DEBUGOUT("MC Update Complete\n");
+    return;
+}
+
+/******************************************************************************
+ * Hashes an address to determine its location in the multicast table
+ *
+ * shared - Struct containing variables accessed by shared code
+ * mc_addr - the multicast address to hash 
+ *****************************************************************************/
+uint32_t
+e1000_hash_mc_addr(struct e1000_shared_adapter *shared,
+                   uint8_t *mc_addr)
+{
+    uint32_t hash_value = 0;
+
+    /* The portion of the address that is used for the hash table is
+     * determined by the mc_filter_type setting.  
+     */
+    switch (shared->mc_filter_type) {
+        /* [0] [1] [2] [3] [4] [5]
+            * 01  AA  00  12  34  56
+            * LSB                 MSB - According to H/W docs */
+    case 0:
+        /* [47:36] i.e. 0x563 for above example address */
+        hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
+        break;
+    case 1:                   /* [46:35] i.e. 0xAC6 for above example address */
+        hash_value = ((mc_addr[4] >> 3) | (((uint16_t) mc_addr[5]) << 5));
+        break;
+    case 2:                   /* [45:34] i.e. 0x5D8 for above example address */
+        hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
+        break;
+    case 3:                   /* [43:32] i.e. 0x634 for above example address */
+        hash_value = ((mc_addr[4]) | (((uint16_t) mc_addr[5]) << 8));
+        break;
+    }
+
+    hash_value &= 0xFFF;
+    return (hash_value);
+}
+
+/******************************************************************************
+ * Sets the bit in the multicast table corresponding to the hash value.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * hash_value - Multicast address hash value
+ *****************************************************************************/
+void
+e1000_mta_set(struct e1000_shared_adapter *shared,
+              uint32_t hash_value)
+{
+    uint32_t hash_bit, hash_reg;
+    uint32_t mta_reg;
+    uint32_t temp;
+
+    /* The MTA is a register array of 128 32-bit registers.  
+     * It is treated like an array of 4096 bits.  We want to set 
+     * bit BitArray[hash_value]. So we figure out what register
+     * the bit is in, read it, OR in the new bit, then write
+     * back the new value.  The register is determined by the 
+     * upper 7 bits of the hash value and the bit within that 
+     * register are determined by the lower 5 bits of the value.
+     */
+    hash_reg = (hash_value >> 5) & 0x7F;
+    hash_bit = hash_value & 0x1F;
+
+    mta_reg = E1000_READ_REG_ARRAY(shared, MTA, hash_reg);
+
+    mta_reg |= (1 << hash_bit);
+
+    /* If we are on an 82544 and we are trying to write an odd offset
+     * in the MTA, save off the previous entry before writing and
+     * restore the old value after writing.
+     */
+    if((shared->mac_type == e1000_82544) && ((hash_reg & 0x1) == 1)) {
+        temp = E1000_READ_REG_ARRAY(shared, MTA, (hash_reg - 1));
+        E1000_WRITE_REG_ARRAY(shared, MTA, hash_reg, mta_reg);
+        E1000_WRITE_REG_ARRAY(shared, MTA, (hash_reg - 1), temp);
+    } else {
+        E1000_WRITE_REG_ARRAY(shared, MTA, hash_reg, mta_reg);
+    }
+    return;
+}
+
+/******************************************************************************
+ * Puts an ethernet address into a receive address register.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * addr - Address to put into receive address register
+ * index - Receive address register to write
+ *****************************************************************************/
+void
+e1000_rar_set(struct e1000_shared_adapter *shared,
+              uint8_t *addr,
+              uint32_t index)
+{
+    uint32_t rar_low, rar_high;
+
+    /* HW expects these in little endian so we reverse the byte order
+     * from network order (big endian) to little endian              
+     */
+    rar_low = ((uint32_t) addr[0] |
+               ((uint32_t) addr[1] << 8) |
+               ((uint32_t) addr[2] << 16) | ((uint32_t) addr[3] << 24));
+
+    rar_high = ((uint32_t) addr[4] | ((uint32_t) addr[5] << 8) | E1000_RAH_AV);
+
+    E1000_WRITE_REG_ARRAY(shared, RA, (index << 1), rar_low);
+    E1000_WRITE_REG_ARRAY(shared, RA, ((index << 1) + 1), rar_high);
+    return;
+}
+
+/******************************************************************************
+ * Writes a value to the specified offset in the VLAN filter table.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * offset - Offset in VLAN filer table to write
+ * value - Value to write into VLAN filter table
+ *****************************************************************************/
+void
+e1000_write_vfta(struct e1000_shared_adapter *shared,
+                 uint32_t offset,
+                 uint32_t value)
+{
+    uint32_t temp;
+
+    if((shared->mac_type == e1000_82544) && ((offset & 0x1) == 1)) {
+        temp = E1000_READ_REG_ARRAY(shared, VFTA, (offset - 1));
+        E1000_WRITE_REG_ARRAY(shared, VFTA, offset, value);
+        E1000_WRITE_REG_ARRAY(shared, VFTA, (offset - 1), temp);
+    } else {
+        E1000_WRITE_REG_ARRAY(shared, VFTA, offset, value);
+    }
+    return;
+}
+
+/******************************************************************************
+ * Clears the VLAN filer table
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_clear_vfta(struct e1000_shared_adapter *shared)
+{
+    uint32_t offset;
+
+    for(offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++)
+        E1000_WRITE_REG_ARRAY(shared, VFTA, offset, 0);
+    return;
+}
+
+/******************************************************************************
+ * Configures flow control and link settings.
+ * 
+ * shared - Struct containing variables accessed by shared code
+ * 
+ * Determines which flow control settings to use. Calls the apropriate media-
+ * specific link configuration function. Configures the flow control settings.
+ * Assuming the adapter has a valid link partner, a valid link should be
+ * established. Assumes the hardware has previously been reset and the 
+ * transmitter and receiver are not enabled.
+ *****************************************************************************/
+boolean_t
+e1000_setup_fc_and_link(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+    uint32_t eecd_reg;
+    uint32_t ctrl_ext_reg;
+    boolean_t status = TRUE;
+
+    DEBUGFUNC("e1000_setup_fc_and_link");
+
+    /* Read the SWDPIO bits and the ILOS bit out of word 0x0A in the
+     * EEPROM.  Store these bits in a variable that we will later write
+     * to the Device Control Register (CTRL).
+     */
+    eecd_reg = e1000_read_eeprom(shared, EEPROM_INIT_CONTROL1_REG);
+
+    ctrl_reg =
+        (((eecd_reg & EEPROM_WORD0A_SWDPIO) << SWDPIO_SHIFT) |
+         ((eecd_reg & EEPROM_WORD0A_ILOS) << ILOS_SHIFT));
+
+    /* Set the PCI priority bit correctly in the CTRL register.  This
+     * determines if the adapter gives priority to receives, or if it
+     * gives equal priority to transmits and receives.
+     */
+    if(shared->dma_fairness)
+        ctrl_reg |= E1000_CTRL_PRIOR;
+
+    /* Read and store word 0x0F of the EEPROM. This word contains bits
+     * that determine the hardware's default PAUSE (flow control) mode,
+     * a bit that determines whether the HW defaults to enabling or
+     * disabling auto-negotiation, and the direction of the
+     * SW defined pins. If there is no SW over-ride of the flow
+     * control setting, then the variable shared->fc will
+     * be initialized based on a value in the EEPROM.
+     */
+    eecd_reg = e1000_read_eeprom(shared, EEPROM_INIT_CONTROL2_REG);
+
+    if(shared->fc > e1000_fc_full) {
+        if((eecd_reg & EEPROM_WORD0F_PAUSE_MASK) == 0)
+            shared->fc = e1000_fc_none;
+        else if((eecd_reg & EEPROM_WORD0F_PAUSE_MASK) == EEPROM_WORD0F_ASM_DIR)
+            shared->fc = e1000_fc_tx_pause;
+        else
+            shared->fc = e1000_fc_full;
+    }
+
+    /* We want to save off the original Flow Control configuration just
+     * in case we get disconnected and then reconnected into a different
+     * hub or switch with different Flow Control capabilities.
+     */
+    shared->original_fc = shared->fc;
+
+    if(shared->mac_type == e1000_82542_rev2_0)
+        shared->fc &= (~e1000_fc_tx_pause);
+
+    if((shared->mac_type < e1000_82543) && (shared->report_tx_early == 1))
+        shared->fc &= (~e1000_fc_rx_pause);
+
+    DEBUGOUT1("After fix-ups FlowControl is now = %x\n", shared->fc);
+
+    /* Take the 4 bits from EEPROM word 0x0F that determine the initial
+     * polarity value for the SW controlled pins, and setup the
+     * Extended Device Control reg with that info.
+     * This is needed because one of the SW controlled pins is used for
+     * signal detection.  So this should be done before e1000_setup_pcs_link()
+     * or e1000_phy_setup() is called.
+     */
+    if(shared->mac_type == e1000_82543) {
+        ctrl_ext_reg = ((eecd_reg & EEPROM_WORD0F_SWPDIO_EXT)
+                        << SWDPIO__EXT_SHIFT);
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+    }
+
+    /* Call the necessary subroutine to configure the link. */
+    if(shared->media_type == e1000_media_type_fiber)
+        status = e1000_setup_pcs_link(shared, ctrl_reg);
+    else
+        status = e1000_phy_setup(shared, ctrl_reg);
+
+    /* Initialize the flow control address, type, and PAUSE timer
+     * registers to their default values.  This is done even if flow
+     * control is disabled, because it does not hurt anything to
+     * initialize these registers.
+     */
+    DEBUGOUT("Initializing the Flow Control address, type and timer regs\n");
+
+    E1000_WRITE_REG(shared, FCAL, FLOW_CONTROL_ADDRESS_LOW);
+    E1000_WRITE_REG(shared, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
+    E1000_WRITE_REG(shared, FCT, FLOW_CONTROL_TYPE);
+    E1000_WRITE_REG(shared, FCTTV, shared->fc_pause_time);
+
+    /* Set the flow control receive threshold registers.  Normally,
+     * these registers will be set to a default threshold that may be
+     * adjusted later by the driver's runtime code.  However, if the
+     * ability to transmit pause frames in not enabled, then these
+     * registers will be set to 0. 
+     */
+    if(!(shared->fc & e1000_fc_tx_pause)) {
+        E1000_WRITE_REG(shared, FCRTL, 0);
+        E1000_WRITE_REG(shared, FCRTH, 0);
+    } else {
+        /* We need to set up the Receive Threshold high and low water marks
+         * as well as (optionally) enabling the transmission of XON frames.
+         */
+        if(shared->fc_send_xon) {
+            E1000_WRITE_REG(shared, FCRTL,
+                            (shared->fc_low_water | E1000_FCRTL_XONE));
+            E1000_WRITE_REG(shared, FCRTH, shared->fc_high_water);
+        } else {
+            E1000_WRITE_REG(shared, FCRTL, shared->fc_low_water);
+            E1000_WRITE_REG(shared, FCRTH, shared->fc_high_water);
+        }
+    }
+    return (status);
+}
+
+/******************************************************************************
+ * Sets up link for a fiber based adapter
+ *
+ * shared - Struct containing variables accessed by shared code
+ * ctrl_reg - Current value of the device control register
+ *
+ * Manipulates Physical Coding Sublayer functions in order to configure
+ * link. Assumes the hardware has been previously reset and the transmitter
+ * and receiver are not enabled.
+ *****************************************************************************/
+boolean_t
+e1000_setup_pcs_link(struct e1000_shared_adapter *shared,
+                     uint32_t ctrl_reg)
+{
+    uint32_t status_reg;
+    uint32_t tctl_reg;
+    uint32_t txcw_reg = 0;
+    uint32_t i;
+
+    DEBUGFUNC("e1000_setup_pcs_link");
+
+    /* Setup the collsion distance.  Since this is configuring the
+     * TBI it is assumed that we are in Full Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    i = E1000_FDX_COLLISION_DISTANCE;
+    i <<= E1000_COLD_SHIFT;
+    tctl_reg |= i;
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    /* Check for a software override of the flow control settings, and
+     * setup the device accordingly.  If auto-negotiation is enabled,
+     * then software will have to set the "PAUSE" bits to the correct
+     * value in the Tranmsit Config Word Register (TXCW) and re-start
+     * auto-negotiation.  However, if auto-negotiation is disabled,
+     * then software will have to manually configure the two flow
+     * control enable bits in the CTRL register.
+     *
+     * The possible values of the "fc" parameter are:
+     *      0:  Flow control is completely disabled
+     *      1:  Rx flow control is enabled (we can receive pause frames
+     *          but not send pause frames).
+     *      2:  Tx flow control is enabled (we can send pause frames
+     *          but we do not support receiving pause frames).
+     *      3:  Both Rx and TX flow control (symmetric) are enabled.
+     *  other:  No software override.  The flow control configuration
+     *          in the EEPROM is used.
+     */
+    switch (shared->fc) {
+    case e1000_fc_none:        /* 0 */
+        /* Flow control (RX & TX) is completely disabled by a
+         * software over-ride.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD);
+        break;
+    case e1000_fc_rx_pause:    /* 1 */
+        /* RX Flow control is enabled, and TX Flow control is
+         * disabled, by a software over-ride.
+         */
+        /* Since there really isn't a way to advertise that we are
+         * capable of RX Pause ONLY, we will advertise that we
+         * support both symmetric and asymmetric RX PAUSE.  Later
+         * we will disable the adapter's ability to send PAUSE
+         * frames.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+        break;
+    case e1000_fc_tx_pause:    /* 2 */
+        /* TX Flow control is enabled, and RX Flow control is
+         * disabled, by a software over-ride.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
+        break;
+    case e1000_fc_full:        /* 3 */
+        /* Flow control (both RX and TX) is enabled by a software
+         * over-ride.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+        break;
+    default:
+        /* We should never get here.  The value should be 0-3. */
+        DEBUGOUT("Flow control param set incorrectly\n");
+        ASSERT(0);
+        break;
+    }
+
+    /* Since auto-negotiation is enabled, take the link out of reset.
+     * (the link will be in reset, because we previously reset the
+     * chip). This will restart auto-negotiation.  If auto-neogtiation
+     * is successful then the link-up status bit will be set and the
+     * flow control enable bits (RFCE and TFCE) will be set according
+     * to their negotiated value.
+     */
+    DEBUGOUT("Auto-negotiation enabled\n");
+
+    E1000_WRITE_REG(shared, TXCW, txcw_reg);
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    shared->txcw_reg = txcw_reg;
+    msec_delay(1);
+
+    /* If we have a signal then poll for a "Link-Up" indication in the
+     * Device Status Register.   Time-out if a link isn't seen in 500
+     * milliseconds seconds (Auto-negotiation should complete in less
+     * than 500 milliseconds even if the other end is doing it in SW).
+     */
+    if(!(E1000_READ_REG(shared, CTRL) & E1000_CTRL_SWDPIN1)) {
+
+        DEBUGOUT("Looking for Link\n");
+        for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
+            msec_delay(10);
+            status_reg = E1000_READ_REG(shared, STATUS);
+            if(status_reg & E1000_STATUS_LU)
+                break;
+        }
+
+        if(i == (LINK_UP_TIMEOUT / 10)) {
+            /* AutoNeg failed to achieve a link, so we'll call the
+             * "CheckForLink" routine.  This routine will force the link
+             * up if we have "signal-detect".  This will allow us to
+             * communicate with non-autonegotiating link partners.
+             */
+            DEBUGOUT("Never got a valid link from auto-neg!!!\n");
+
+            shared->autoneg_failed = 1;
+            e1000_check_for_link(shared);
+            shared->autoneg_failed = 0;
+        } else {
+            shared->autoneg_failed = 0;
+            DEBUGOUT("Valid Link Found\n");
+        }
+    } else {
+        DEBUGOUT("No Signal Detected\n");
+    }
+
+    return (TRUE);
+}
+
+/******************************************************************************
+ * Configures flow control settings after link is established
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Should be called immediately after a valid link has been established.
+ * Forces MAC flow control settings if link was forced. When in MII/GMII mode
+ * and autonegotiation is enabled, the MAC flow control settings will be set
+ * based on the flow control negotiated by the PHY. In TBI mode, the TFCE
+ * and RFCE bits will be automaticaly set to the negotiated flow control mode.
+ *****************************************************************************/
+void
+e1000_config_fc_after_link_up(struct e1000_shared_adapter *shared)
+{
+    uint16_t mii_status_reg;
+    uint16_t mii_nway_adv_reg;
+    uint16_t mii_nway_lp_ability_reg;
+    uint16_t speed;
+    uint16_t duplex;
+
+    DEBUGFUNC("e1000_config_fc_after_link_up");
+
+    /* Check for the case where we have fiber media and auto-neg failed
+     * so we had to force link.  In this case, we need to force the
+     * configuration of the MAC to match the "fc" parameter.
+     */
+    if(((shared->media_type == e1000_media_type_fiber)
+        && (shared->autoneg_failed))
+       || ((shared->media_type == e1000_media_type_copper)
+           && (!shared->autoneg))) {
+        e1000_force_mac_fc(shared);
+    }
+
+    /* Check for the case where we have copper media and auto-neg is
+     * enabled.  In this case, we need to check and see if Auto-Neg
+     * has completed, and if so, how the PHY and link partner has
+     * flow control configured.
+     */
+    if((shared->media_type == e1000_media_type_copper) && shared->autoneg) {
+        /* Read the MII Status Register and check to see if AutoNeg
+         * has completed.  We read this twice because this reg has
+         * some "sticky" (latched) bits.
+         */
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
+            /* The AutoNeg process has completed, so we now need to
+             * read both the Auto Negotiation Advertisement Register
+             * (Address 4) and the Auto_Negotiation Base Page Ability
+             * Register (Address 5) to determine how flow control was
+             * negotiated.
+             */
+            mii_nway_adv_reg = e1000_read_phy_reg(shared,
+                                                  PHY_AUTONEG_ADV);
+            mii_nway_lp_ability_reg = e1000_read_phy_reg(shared,
+                                                         PHY_LP_ABILITY);
+
+            /* Two bits in the Auto Negotiation Advertisement Register
+             * (Address 4) and two bits in the Auto Negotiation Base
+             * Page Ability Register (Address 5) determine flow control
+             * for both the PHY and the link partner.  The following
+             * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,
+             * 1999, describes these PAUSE resolution bits and how flow
+             * control is determined based upon these settings.
+             * NOTE:  DC = Don't Care
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution
+             *-------|---------|-------|---------|--------------------
+             *   0   |    0    |  DC   |   DC    | e1000_fc_none
+             *   0   |    1    |   0   |   DC    | e1000_fc_none
+             *   0   |    1    |   1   |    0    | e1000_fc_none
+             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+             *   1   |    0    |   0   |   DC    | e1000_fc_none
+             *   1   |   DC    |   1   |   DC    | e1000_fc_full
+             *   1   |    1    |   0   |    0    | e1000_fc_none
+             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+             *
+             */
+            /* Are both PAUSE bits set to 1?  If so, this implies
+             * Symmetric Flow Control is enabled at both ends.  The
+             * ASM_DIR bits are irrelevant per the spec.
+             *
+             * For Symmetric Flow Control:
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+             *-------|---------|-------|---------|--------------------
+             *   1   |   DC    |   1   |   DC    | e1000_fc_full
+             *
+             */
+            if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+               (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
+                /* Now we need to check if the user selected RX ONLY
+                 * of pause frames.  In this case, we had to advertise
+                 * FULL flow control because we could not advertise RX
+                 * ONLY. Hence, we must now check to see if we need to
+                 * turn OFF  the TRANSMISSION of PAUSE frames.
+                 */
+                if(shared->original_fc == e1000_fc_full) {
+                    shared->fc = e1000_fc_full;
+                    DEBUGOUT("Flow Control = FULL.\r\n");
+                } else {
+                    shared->fc = e1000_fc_rx_pause;
+                    DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+                }
+            }
+            /* For receiving PAUSE frames ONLY.
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+             *-------|---------|-------|---------|--------------------
+             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+             *
+             */
+            else if(!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+                    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+                shared->fc = e1000_fc_tx_pause;
+                DEBUGOUT("Flow Control = TX PAUSE frames only.\r\n");
+            }
+            /* For transmitting PAUSE frames ONLY.
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+             *-------|---------|-------|---------|--------------------
+             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+             *
+             */
+            else if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+                    !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+                shared->fc = e1000_fc_rx_pause;
+                DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+            }
+            /* Per the IEEE spec, at this point flow control should be
+             * disabled.  However, we want to consider that we could
+             * be connected to a legacy switch that doesn't advertise
+             * desired flow control, but can be forced on the link
+             * partner.  So if we advertised no flow control, that is
+             * what we will resolve to.  If we advertised some kind of
+             * receive capability (Rx Pause Only or Full Flow Control)
+             * and the link partner advertised none, we will configure
+             * ourselves to enable Rx Flow Control only.  We can do
+             * this safely for two reasons:  If the link partner really
+             * didn't want flow control enabled, and we enable Rx, no
+             * harm done since we won't be receiving any PAUSE frames
+             * anyway.  If the intent on the link partner was to have
+             * flow control enabled, then by us enabling RX only, we
+             * can at least receive pause frames and process them.
+             * This is a good idea because in most cases, since we are
+             * predominantly a server NIC, more times than not we will
+             * be asked to delay transmission of packets than asking
+             * our link partner to pause transmission of frames.
+             */
+            else if(shared->original_fc == e1000_fc_none ||
+                    shared->original_fc == e1000_fc_tx_pause) {
+                shared->fc = e1000_fc_none;
+                DEBUGOUT("Flow Control = NONE.\r\n");
+            } else {
+                shared->fc = e1000_fc_rx_pause;
+                DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+            }
+
+            /* Now we need to do one last check...  If we auto-
+             * negotiated to HALF DUPLEX, flow control should not be
+             * enabled per IEEE 802.3 spec.
+             */
+            e1000_get_speed_and_duplex(shared, &speed, &duplex);
+
+            if(duplex == HALF_DUPLEX)
+                shared->fc = e1000_fc_none;
+
+            /* Now we call a subroutine to actually force the MAC
+             * controller to use the correct flow control settings.
+             */
+            e1000_force_mac_fc(shared);
+        } else {
+            DEBUGOUT("Copper PHY and Auto Neg has not completed.\r\n");
+        }
+    }
+    return;  
+}
+
+/******************************************************************************
+ * Checks to see if the link status of the hardware has changed.
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Called by any function that needs to check the link status of the adapter.
+ *****************************************************************************/
+void
+e1000_check_for_link(struct e1000_shared_adapter *shared)
+{
+    uint32_t rxcw_reg;
+    uint32_t ctrl_reg;
+    uint32_t status_reg;
+    uint32_t rctl_reg;
+    uint16_t phy_data;
+    uint16_t lp_capability;
+
+    DEBUGFUNC("e1000_check_for_link");
+
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+    status_reg = E1000_READ_REG(shared, STATUS);
+    rxcw_reg = E1000_READ_REG(shared, RXCW);
+
+    /* If we have a copper PHY then we only want to go out to the PHY
+     * registers to see if Auto-Neg has completed and/or if our link
+     * status has changed.  The get_link_status flag will be set if we
+     * receive a Link Status Change interrupt or we have Rx Sequence
+     * Errors.
+     */
+    if(shared->media_type == e1000_media_type_copper
+       && shared->get_link_status) {
+        /* First we want to see if the MII Status Register reports
+         * link.  If so, then we want to get the current speed/duplex
+         * of the PHY.
+         * Read the register twice since the link bit is sticky.
+         */
+        phy_data = e1000_read_phy_reg(shared, PHY_STATUS);
+        phy_data = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        if(phy_data & MII_SR_LINK_STATUS) {
+            shared->get_link_status = FALSE;
+        } else {
+            DEBUGOUT("**** CFL - No link detected. ****\r\n");
+            return;
+        }
+
+        /* If we are forcing speed/duplex, then we simply return since
+         * we have already determined whether we have link or not.
+         */
+        if(!shared->autoneg) {
+            return;
+        }
+
+        switch (shared->phy_id) {
+        case M88E1000_12_PHY_ID:
+        case M88E1000_14_PHY_ID:
+        case M88E1000_I_PHY_ID:
+        case M88E1011_I_PHY_ID:
+            /* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
+             * have Si on board that is 82544 or newer, Auto
+             * Speed Detection takes care of MAC speed/duplex
+             * configuration.  So we only need to configure Collision
+             * Distance in the MAC.  Otherwise, we need to force
+             * speed/duplex on the MAC to the current PHY speed/duplex
+             * settings.
+             */
+            if(shared->mac_type >= e1000_82544) {
+                DEBUGOUT("CFL - Auto-Neg complete.");
+                DEBUGOUT("Configuring Collision Distance.");
+                e1000_config_collision_dist(shared);
+            } else {
+                /* Read the Phy Specific Status register to get the
+                 * resolved speed/duplex settings.  Then call
+                 * e1000_config_mac_to_phy which will retrieve
+                 * PHY register information and configure the MAC to
+                 * equal the negotiated speed/duplex.
+                 */
+                phy_data = e1000_read_phy_reg(shared, 
+                                              M88E1000_PHY_SPEC_STATUS);
+
+                DEBUGOUT1("CFL - Auto-Neg complete.  phy_data = %x\r\n",
+                          phy_data);
+                e1000_config_mac_to_phy(shared, phy_data);
+            }
+
+            /* Configure Flow Control now that Auto-Neg has completed.
+             * We need to first restore the users desired Flow
+             * Control setting since we may have had to re-autoneg
+             * with a different link partner.
+             */
+            e1000_config_fc_after_link_up(shared);
+            break;
+
+        default:
+            DEBUGOUT("CFL - Invalid PHY detected.\r\n");
+
+        } /* end switch statement */
+
+        /* At this point we know that we are on copper, link is up, 
+         * and we are auto-neg'd.  These are pre-conditions for checking
+         * the link parter capabilities register.  We use the link partner
+         * capabilities to determine if TBI Compatibility needs to be turned on
+         * or turned off.  If the link partner advertises any speed in addition
+         * to Gigabit, then we assume that they are GMII-based and TBI 
+         * compatibility is not needed.
+         * If no other speeds are advertised, then we assume the link partner
+         * is TBI-based and we turn on TBI Compatibility.
+         */
+        if(shared->tbi_compatibility_en) {
+            lp_capability = e1000_read_phy_reg(shared, PHY_LP_ABILITY);
+            if(lp_capability & (NWAY_LPAR_10T_HD_CAPS |
+                                NWAY_LPAR_10T_FD_CAPS |
+                                NWAY_LPAR_100TX_HD_CAPS |
+                                NWAY_LPAR_100TX_FD_CAPS |
+                                NWAY_LPAR_100T4_CAPS)) {
+                /* If our link partner advertises below Gig, then they do not
+                 * need the special Tbi Compatibility mode. 
+                 */
+                if(shared->tbi_compatibility_on) {
+                    /* If we previously were in the mode, turn it off, now. */
+                    rctl_reg = E1000_READ_REG(shared, RCTL);
+                    rctl_reg &= ~E1000_RCTL_SBP;
+                    E1000_WRITE_REG(shared, RCTL, rctl_reg);
+                    shared->tbi_compatibility_on = FALSE;
+                }
+            } else {
+                /* If the mode is was previously off, turn it on. 
+                 * For compatibility with a suspected Tbi link partners, 
+                 * we will store bad packets.
+                 * (Certain frames have an additional byte on the end and will 
+                 * look like CRC errors to to the hardware).
+                 */
+                if(!shared->tbi_compatibility_on) {
+                    shared->tbi_compatibility_on = TRUE;
+                    rctl_reg = E1000_READ_REG(shared, RCTL);
+                    rctl_reg |= E1000_RCTL_SBP;
+                    E1000_WRITE_REG(shared, RCTL, rctl_reg);
+                }
+            }
+        }
+    } /* end if e1000_media_type_copper statement */
+    /* If we don't have link (auto-negotiation failed or link partner
+     * cannot auto-negotiate) and the cable is plugged in since we don't
+     * have Loss-Of-Signal (we HAVE a signal) and our link partner is
+     * not trying to AutoNeg with us (we are receiving idles/data
+     * then we need to force our link to connect to a non
+     * auto-negotiating link partner.  We also need to give
+     * auto-negotiation time to complete in case the cable was just
+     * plugged in.  The autoneg_failed flag does this.
+     */
+    else if((shared->media_type == e1000_media_type_fiber) &&  /* Fiber PHY */
+            (!(status_reg & E1000_STATUS_LU)) &&        /* no link and    */
+            (!(ctrl_reg & E1000_CTRL_SWDPIN1)) &&       /* we have signal */
+            (!(rxcw_reg & E1000_RXCW_C))) {     /* and rxing idle/data */
+        if(shared->autoneg_failed == 0) {      /* given AutoNeg time */
+            shared->autoneg_failed = 1;
+            return;
+        }
+
+        DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\r\n");
+
+        /* Disable auto-negotiation in the TXCW register */
+        E1000_WRITE_REG(shared, TXCW, (shared->txcw_reg & ~E1000_TXCW_ANE));
+
+        /* Force link-up and also force full-duplex. */
+        ctrl_reg = E1000_READ_REG(shared, CTRL);
+        ctrl_reg |= (E1000_CTRL_SLU | E1000_CTRL_FD);
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        /* Configure Flow Control after forcing link up. */
+        e1000_config_fc_after_link_up(shared);
+
+    } else if((shared->media_type == e1000_media_type_fiber) && /* Fiber */
+              (ctrl_reg & E1000_CTRL_SLU) &&    /* we have forced link */
+              (rxcw_reg & E1000_RXCW_C)) {      /* and Rxing /C/ ordered sets */
+        /* If we are forcing link and we are receiving /C/ ordered sets,
+         * then re-enable auto-negotiation in the RXCW register and
+         * disable forced link in the Device Control register in an attempt
+         * to AutoNeg with our link partner.
+         */
+        DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\r\n");
+
+        /* Enable auto-negotiation in the TXCW register and stop
+         * forcing link.
+         */
+        E1000_WRITE_REG(shared, TXCW, shared->txcw_reg);
+
+        E1000_WRITE_REG(shared, CTRL, (ctrl_reg & ~E1000_CTRL_SLU));
+    }
+
+    return;
+}
+
+/******************************************************************************
+ * Clears all hardware statistics counters. 
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_clear_hw_cntrs(struct e1000_shared_adapter *shared)
+{
+    volatile uint32_t temp_reg;
+
+    DEBUGFUNC("e1000_clear_hw_cntrs");
+
+    /* if we are stopped or resetting exit gracefully */
+    if(shared->adapter_stopped) {
+        DEBUGOUT("Exiting because the adapter is stopped!!!\n");
+        return;
+    }
+
+    temp_reg = E1000_READ_REG(shared, CRCERRS);
+    temp_reg = E1000_READ_REG(shared, SYMERRS);
+    temp_reg = E1000_READ_REG(shared, MPC);
+    temp_reg = E1000_READ_REG(shared, SCC);
+    temp_reg = E1000_READ_REG(shared, ECOL);
+    temp_reg = E1000_READ_REG(shared, MCC);
+    temp_reg = E1000_READ_REG(shared, LATECOL);
+    temp_reg = E1000_READ_REG(shared, COLC);
+    temp_reg = E1000_READ_REG(shared, DC);
+    temp_reg = E1000_READ_REG(shared, SEC);
+    temp_reg = E1000_READ_REG(shared, RLEC);
+    temp_reg = E1000_READ_REG(shared, XONRXC);
+    temp_reg = E1000_READ_REG(shared, XONTXC);
+    temp_reg = E1000_READ_REG(shared, XOFFRXC);
+    temp_reg = E1000_READ_REG(shared, XOFFTXC);
+    temp_reg = E1000_READ_REG(shared, FCRUC);
+    temp_reg = E1000_READ_REG(shared, PRC64);
+    temp_reg = E1000_READ_REG(shared, PRC127);
+    temp_reg = E1000_READ_REG(shared, PRC255);
+    temp_reg = E1000_READ_REG(shared, PRC511);
+    temp_reg = E1000_READ_REG(shared, PRC1023);
+    temp_reg = E1000_READ_REG(shared, PRC1522);
+    temp_reg = E1000_READ_REG(shared, GPRC);
+    temp_reg = E1000_READ_REG(shared, BPRC);
+    temp_reg = E1000_READ_REG(shared, MPRC);
+    temp_reg = E1000_READ_REG(shared, GPTC);
+    temp_reg = E1000_READ_REG(shared, GORCL);
+    temp_reg = E1000_READ_REG(shared, GORCH);
+    temp_reg = E1000_READ_REG(shared, GOTCL);
+    temp_reg = E1000_READ_REG(shared, GOTCH);
+    temp_reg = E1000_READ_REG(shared, RNBC);
+    temp_reg = E1000_READ_REG(shared, RUC);
+    temp_reg = E1000_READ_REG(shared, RFC);
+    temp_reg = E1000_READ_REG(shared, ROC);
+    temp_reg = E1000_READ_REG(shared, RJC);
+    temp_reg = E1000_READ_REG(shared, TORL);
+    temp_reg = E1000_READ_REG(shared, TORH);
+    temp_reg = E1000_READ_REG(shared, TOTL);
+    temp_reg = E1000_READ_REG(shared, TOTH);
+    temp_reg = E1000_READ_REG(shared, TPR);
+    temp_reg = E1000_READ_REG(shared, TPT);
+    temp_reg = E1000_READ_REG(shared, PTC64);
+    temp_reg = E1000_READ_REG(shared, PTC127);
+    temp_reg = E1000_READ_REG(shared, PTC255);
+    temp_reg = E1000_READ_REG(shared, PTC511);
+    temp_reg = E1000_READ_REG(shared, PTC1023);
+    temp_reg = E1000_READ_REG(shared, PTC1522);
+    temp_reg = E1000_READ_REG(shared, MPTC);
+    temp_reg = E1000_READ_REG(shared, BPTC);
+
+    if(shared->mac_type < e1000_82543)
+        return;
+
+    temp_reg = E1000_READ_REG(shared, ALGNERRC);
+    temp_reg = E1000_READ_REG(shared, RXERRC);
+    temp_reg = E1000_READ_REG(shared, TNCRS);
+    temp_reg = E1000_READ_REG(shared, CEXTERR);
+    temp_reg = E1000_READ_REG(shared, TSCTC);
+    temp_reg = E1000_READ_REG(shared, TSCTFC);
+    return;
+}
+
+/******************************************************************************
+ * Detects the current speed and duplex settings of the hardware.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * speed - Speed of the connection
+ * duplex - Duplex setting of the connection
+ *****************************************************************************/
+void
+e1000_get_speed_and_duplex(struct e1000_shared_adapter *shared,
+                           uint16_t *speed,
+                           uint16_t *duplex)
+{
+    uint32_t status_reg;
+#if DBG
+    uint16_t phy_data;
+#endif
+
+    DEBUGFUNC("e1000_get_speed_and_duplex");
+
+    /* If the adapter is stopped we don't have a speed or duplex */
+    if(shared->adapter_stopped) {
+        *speed = 0;
+        *duplex = 0;
+        return;
+    }
+
+    if(shared->mac_type >= e1000_82543) {
+        status_reg = E1000_READ_REG(shared, STATUS);
+        if(status_reg & E1000_STATUS_SPEED_1000) {
+            *speed = SPEED_1000;
+            DEBUGOUT("1000 Mbs, ");
+        } else if(status_reg & E1000_STATUS_SPEED_100) {
+            *speed = SPEED_100;
+            DEBUGOUT("100 Mbs, ");
+        } else {
+            *speed = SPEED_10;
+            DEBUGOUT("10 Mbs, ");
+        }
+
+        if(status_reg & E1000_STATUS_FD) {
+            *duplex = FULL_DUPLEX;
+            DEBUGOUT("Full Duplex\r\n");
+        } else {
+            *duplex = HALF_DUPLEX;
+            DEBUGOUT(" Half Duplex\r\n");
+        }
+    } else {
+        DEBUGOUT("1000 Mbs, Full Duplex\r\n");
+        *speed = SPEED_1000;
+        *duplex = FULL_DUPLEX;
+    }
+
+#if DBG
+    if(shared->phy_id == M88E1000_12_PHY_ID ||
+       shared->phy_id == M88E1000_14_PHY_ID ||
+       shared->phy_id == M88E1000_I_PHY_ID  ||
+       shared->phy_id == M88E1011_I_PHY_ID) {
+        /* read the phy specific status register */
+        phy_data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+        DEBUGOUT1("M88E1000 Phy Specific Status Reg contents = %x\n", phy_data);
+        phy_data = e1000_read_phy_reg(shared, PHY_STATUS);
+        DEBUGOUT1("Phy MII Status Reg contents = %x\n", phy_data);
+        DEBUGOUT1("Device Status Reg contents = %x\n", 
+                  E1000_READ_REG(shared, STATUS));
+    }
+#endif
+    return;
+}
+
+/******************************************************************************
+ * Reads a 16 bit word from the EEPROM.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * offset - offset of 16 bit word in the EEPROM to read
+ *****************************************************************************/
+uint16_t
+e1000_read_eeprom(struct e1000_shared_adapter *shared,
+                  uint16_t offset)
+{
+    boolean_t large_eeprom = FALSE;
+    uint16_t data;
+    uint32_t eecd_reg;
+    uint32_t tmp = 0;
+
+    if((shared->mac_type > e1000_82544) &&
+       (E1000_READ_REG(shared, EECD) & E1000_EECD_SIZE)) large_eeprom = TRUE;
+    
+    /* Request EEPROM Access */
+    if(shared->mac_type > e1000_82544) {
+        E1000_WRITE_REG(shared, EECD, (uint32_t) E1000_EECD_REQ);
+        eecd_reg = E1000_READ_REG(shared, EECD);
+        while((!(eecd_reg & E1000_EECD_GNT)) && (tmp < 100)) {
+            tmp++;
+            usec_delay(5);
+            eecd_reg = E1000_READ_REG(shared, EECD);
+        }
+        if(!(eecd_reg & E1000_EECD_GNT)) return(FALSE);
+    }
+
+    /*  Prepare the EEPROM for reading  */
+    e1000_setup_eeprom(shared);
+
+    /*  Send the READ command (opcode + addr)  */
+    e1000_shift_out_bits(shared, EEPROM_READ_OPCODE, 3);
+    /* If we have a 256 word EEPROM, there are 8 address bits
+     * if we have a 64 word EEPROM, there are 6 address bits
+     */
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, offset, 8);
+    else
+        e1000_shift_out_bits(shared, offset, 6);
+
+    /* Read the data */
+    data = e1000_shift_in_bits(shared);
+
+    /* End this read operation */
+    e1000_standby_eeprom(shared);
+
+    /* Stop requestiong EEPROM access */
+    if(shared->mac_type > e1000_82544)
+        E1000_WRITE_REG(shared, EECD, (uint32_t) 0);
+
+    return (data);
+}
+
+/******************************************************************************
+ * Verifies that the EEPROM has a valid checksum
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Reads the first 64 16 bit words of the EEPROM and sums the values read.
+ * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
+ * valid.
+ *****************************************************************************/
+boolean_t
+e1000_validate_eeprom_checksum(struct e1000_shared_adapter *shared)
+{
+    uint16_t checksum = 0;
+    uint16_t i;
+
+    for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++)
+        checksum += e1000_read_eeprom(shared, i);
+
+    if(checksum == (uint16_t) EEPROM_SUM)
+        return (TRUE);
+    else
+        return (FALSE);
+}
+
+/******************************************************************************
+ * Calculates the EEPROM checksum and writes it to the EEPROM
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.
+ * Writes the difference to word offset 63 of the EEPROM.
+ *****************************************************************************/
+void
+e1000_update_eeprom_checksum(struct e1000_shared_adapter *shared)
+{
+    uint16_t checksum = 0;
+    uint16_t i;
+
+    for(i = 0; i < EEPROM_CHECKSUM_REG; i++)
+        checksum += e1000_read_eeprom(shared, i);
+
+    checksum = (uint16_t) EEPROM_SUM - checksum;
+
+    e1000_write_eeprom(shared, EEPROM_CHECKSUM_REG, checksum);
+    return;
+}
+
+/******************************************************************************
+ * Writes a 16 bit word to a given offset in the EEPROM.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * offset - offset within the EEPROM to be written to
+ * data - 16 bit word to be writen to the EEPROM
+ *
+ * If e1000_update_eeprom_checksum is not called after this function, the 
+ * EEPROM will most likely contain an invalid checksum.
+ *****************************************************************************/
+boolean_t
+e1000_write_eeprom(struct e1000_shared_adapter *shared,
+                   uint16_t offset,
+                   uint16_t data)
+{
+    boolean_t large_eeprom = FALSE;
+    uint32_t eecd_reg;
+    uint32_t tmp = 0;
+
+    if((shared->mac_type > e1000_82544) &&
+       (E1000_READ_REG(shared, EECD) & E1000_EECD_SIZE)) large_eeprom = TRUE;
+    
+    /* Request EEPROM Access */
+    if(shared->mac_type > e1000_82544) {
+        E1000_WRITE_REG(shared, EECD, (uint32_t) E1000_EECD_REQ);
+        eecd_reg = E1000_READ_REG(shared, EECD);
+        while((!(eecd_reg & E1000_EECD_GNT)) && (tmp < 100)) {
+            tmp++;
+            usec_delay(5);
+            eecd_reg = E1000_READ_REG(shared, EECD);
+        }
+        if(!(eecd_reg & E1000_EECD_GNT)) return(FALSE);
+    }
+
+    /* Prepare the EEPROM for writing  */
+    e1000_setup_eeprom(shared);
+
+    /* Send the 9-bit (or 11-bit on large EEPROM) EWEN (write enable) 
+     * command to the EEPROM (5-bit opcode plus 4/6-bit dummy).
+     * This puts the EEPROM into write/erase mode. 
+     */
+    e1000_shift_out_bits(shared, EEPROM_EWEN_OPCODE, 5);
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, 0, 6);
+    else
+        e1000_shift_out_bits(shared, 0, 4);
+
+    /* Prepare the EEPROM */
+    e1000_standby_eeprom(shared);
+
+    /* Send the Write command (3-bit opcode + addr) */
+    e1000_shift_out_bits(shared, EEPROM_WRITE_OPCODE, 3);
+    /* If we have a 256 word EEPROM, there are 8 address bits
+     * if we have a 64 word EEPROM, there are 6 address bits
+     */
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, offset, 8);
+    else
+        e1000_shift_out_bits(shared, offset, 6);
+
+    /* Send the data */
+    e1000_shift_out_bits(shared, data, 16);
+    e1000_wait_eeprom_command(shared);
+
+    /* Recover from write */
+    e1000_standby_eeprom(shared);
+
+    /* Send the 9-bit  (or 11-bit on large EEPROM) EWDS (write disable) 
+     * command to the EEPROM (5-bit opcode plus 4/6-bit dummy).
+     * This takes the EEPROM out of write/erase mode.
+     */
+    e1000_shift_out_bits(shared, EEPROM_EWDS_OPCODE, 5);
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, 0, 6);
+    else
+        e1000_shift_out_bits(shared, 0, 4);
+
+    /* Done with writing */
+    e1000_cleanup_eeprom(shared);
+
+    /* Stop requestiong EEPROM access */
+    if(shared->mac_type > e1000_82544)
+        E1000_WRITE_REG(shared, EECD, (uint32_t) 0);
+
+    return (TRUE);
+}
+
+/******************************************************************************
+ * Reads the adapter's part number from the EEPROM
+ *
+ * shared - Struct containing variables accessed by shared code
+ * part_num - Adapter's part number
+ *****************************************************************************/
+boolean_t
+e1000_read_part_num(struct e1000_shared_adapter *shared,
+                    uint32_t *part_num)
+{
+    uint16_t eeprom_word;
+
+    DEBUGFUNC("e1000_read_part_num");
+
+    /* Don't read the EEPROM if we are stopped */
+    if(shared->adapter_stopped) {
+        *part_num = 0;
+        return (FALSE);
+    }
+
+    /* Get word 0 from EEPROM */
+    eeprom_word = e1000_read_eeprom(shared, (uint16_t) (EEPROM_PBA_BYTE_1));
+
+    DEBUGOUT("Read first part number word\n");
+
+    /* Save word 0 in upper half is PartNumber */
+    *part_num = (uint32_t) eeprom_word;
+    *part_num = *part_num << 16;
+
+    /* Get word 1 from EEPROM */
+    eeprom_word =
+        e1000_read_eeprom(shared, (uint16_t) (EEPROM_PBA_BYTE_1 + 1));
+
+    DEBUGOUT("Read second part number word\n");
+
+    /* Save word 1 in lower half of PartNumber */
+    *part_num |= eeprom_word;
+
+    /* read a valid part number */
+    return (TRUE);
+}
+
+/******************************************************************************
+ * Turns on the software controllable LED
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_led_on(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+
+    /* if we're stopped don't touch the hardware */
+    if(shared->adapter_stopped)
+        return;
+
+    /* Read the content of the device control reg */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set the LED control pin to an output */
+    ctrl_reg |= E1000_CTRL_SWDPIO0;
+
+    /* Drive it high on normal boards, low on low profile boards */
+    if(shared->low_profile)
+        ctrl_reg &= ~E1000_CTRL_SWDPIN0;
+    else
+        ctrl_reg |= E1000_CTRL_SWDPIN0;
+
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    return;
+}
+
+/******************************************************************************
+ * Turns off the software controllable LED
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_led_off(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+
+    /* if we're stopped don't touch the hardware */
+    if(shared->adapter_stopped)
+        return;
+
+    /* Read the content of the device control reg */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set the LED control pin to an output */
+    ctrl_reg |= E1000_CTRL_SWDPIO0;
+
+    /* Drive it low on normal boards, high on low profile boards */
+    if(shared->low_profile)
+        ctrl_reg |= E1000_CTRL_SWDPIN0;
+    else
+        ctrl_reg &= ~E1000_CTRL_SWDPIN0;
+
+    /* Write the device control reg. back  */
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    return;
+}
+
+/******************************************************************************
+ * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT
+ * 
+ * shared - Struct containing variables accessed by shared code
+ * frame_len - The length of the frame in question
+ * mac_addr - The Ethernet destination address of the frame in question
+ *****************************************************************************/
+uint32_t
+e1000_tbi_adjust_stats(struct e1000_shared_adapter *shared,
+                       struct e1000_shared_stats *stats,
+                       uint32_t frame_len,
+                       uint8_t *mac_addr)
+{
+    uint64_t carry_bit;
+
+    /* First adjust the frame length. */
+    frame_len--;
+    /* We need to adjust the statistics counters, since the hardware
+     * counters overcount this packet as a CRC error and undercount
+     * the packet as a good packet
+     */
+    /* This packet should not be counted as a CRC error.    */
+    stats->crcerrs--;
+    /* This packet does count as a Good Packet Received.    */
+    stats->gprc++;
+
+    /* Adjust the Good Octets received counters             */
+    carry_bit = 0x80000000 & stats->gorcl;
+    stats->gorcl += frame_len;
+    /* If the high bit of Gorcl (the low 32 bits of the Good Octets
+     * Received Count) was one before the addition, 
+     * AND it is zero after, then we lost the carry out, 
+     * need to add one to Gorch (Good Octets Received Count High).
+     * This could be simplified if all environments supported 
+     * 64-bit integers.
+     */
+    if(carry_bit && ((stats->gorcl & 0x80000000) == 0))
+        stats->gorch++;
+    /* Is this a broadcast or multicast?  Check broadcast first,
+     * since the test for a multicast frame will test positive on 
+     * a broadcast frame.
+     */
+    if((mac_addr[0] == (uint8_t) 0xff) && (mac_addr[1] == (uint8_t) 0xff))
+        /* Broadcast packet */
+        stats->bprc++;
+    else if(*mac_addr & 0x01)
+        /* Multicast packet */
+        stats->mprc++;
+
+    if(frame_len == shared->max_frame_size) {
+        /* In this case, the hardware has overcounted the number of
+         * oversize frames.
+         */
+        if(stats->roc > 0)
+            stats->roc--;
+    }
+
+    /* Adjust the bin counters when the extra byte put the frame in the
+     * wrong bin. Remember that the frame_len was adjusted above.
+     */
+    if(frame_len == 64) {
+        stats->prc64++;
+        stats->prc127--;
+    } else if(frame_len == 127) {
+        stats->prc127++;
+        stats->prc255--;
+    } else if(frame_len == 255) {
+        stats->prc255++;
+        stats->prc511--;
+    } else if(frame_len == 511) {
+        stats->prc511++;
+        stats->prc1023--;
+    } else if(frame_len == 1023) {
+        stats->prc1023++;
+        stats->prc1522--;
+    } else if(frame_len == 1522) {
+        stats->prc1522++;
+    }
+    return frame_len;
+}
+
+/******************************************************************************
+ * Gets the current PCI bus type, speed, and width of the hardware
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_get_bus_info(struct e1000_shared_adapter *shared)
+{
+    uint32_t status_reg;
+
+    if(shared->mac_type < e1000_82543) {
+        shared->bus_type = e1000_bus_type_unknown;
+        shared->bus_speed = e1000_bus_speed_unknown;
+        shared->bus_width = e1000_bus_width_unknown;
+        return;
+    }
+
+    status_reg = E1000_READ_REG(shared, STATUS);
+
+    shared->bus_type = (status_reg & E1000_STATUS_PCIX_MODE) ?
+        e1000_bus_type_pcix : e1000_bus_type_pci;
+
+    if(shared->bus_type == e1000_bus_type_pci) {
+        shared->bus_speed = (status_reg & E1000_STATUS_PCI66) ?
+            e1000_bus_speed_66 : e1000_bus_speed_33;
+    } else {
+        switch (status_reg & E1000_STATUS_PCIX_SPEED) {
+        case E1000_STATUS_PCIX_SPEED_66:
+            shared->bus_speed = e1000_bus_speed_66;
+            break;
+        case E1000_STATUS_PCIX_SPEED_100:
+            shared->bus_speed = e1000_bus_speed_100;
+            break;
+        case E1000_STATUS_PCIX_SPEED_133:
+            shared->bus_speed = e1000_bus_speed_133;
+            break;
+        default:
+            shared->bus_speed = e1000_bus_speed_reserved;
+            break;
+        }
+    }
+
+    shared->bus_width = (status_reg & E1000_STATUS_BUS64) ?
+        e1000_bus_width_64 : e1000_bus_width_32;
+
+    return;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_mac.h linux/drivers/net/e1000/e1000_mac.h
--- ../prev/linux/drivers/net/e1000/e1000_mac.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_mac.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,1381 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_mac.h
+ * Structures, enums, and macros for the MAC
+ */
+
+#ifndef _E1000_MAC_H_
+#define _E1000_MAC_H_
+
+#include "e1000_osdep.h"
+
+/* Forward declarations of structures used by the shared code */
+struct e1000_shared_adapter;
+struct e1000_shared_stats;
+
+/* Enumerated types specific to the e1000 hardware */
+/* Media Access Controlers */
+typedef enum {
+    e1000_82542_rev2_0 = 0,
+    e1000_82542_rev2_1,
+    e1000_82543,
+    e1000_82544,
+    e1000_82540,
+    e1000_num_macs
+} e1000_mac_type;
+
+/* Media Types */
+typedef enum {
+    e1000_media_type_copper = 0,
+    e1000_media_type_fiber = 1,
+    e1000_num_media_types
+} e1000_media_type;
+
+typedef enum {
+    e1000_10_half = 0,
+    e1000_10_full = 1,
+    e1000_100_half = 2,
+    e1000_100_full = 3
+} e1000_speed_duplex_type;
+
+/* Flow Control Settings */
+typedef enum {
+    e1000_fc_none = 0,
+    e1000_fc_rx_pause = 1,
+    e1000_fc_tx_pause = 2,
+    e1000_fc_full = 3,
+    e1000_fc_default = 0xFF
+} e1000_fc_type;
+
+/* PCI bus types */
+typedef enum {
+    e1000_bus_type_unknown = 0,
+    e1000_bus_type_pci,
+    e1000_bus_type_pcix
+} e1000_bus_type;
+
+/* PCI bus speeds */
+typedef enum {
+    e1000_bus_speed_unknown = 0,
+    e1000_bus_speed_33,
+    e1000_bus_speed_66,
+    e1000_bus_speed_100,
+    e1000_bus_speed_133,
+    e1000_bus_speed_reserved
+} e1000_bus_speed;
+
+/* PCI bus widths */
+typedef enum {
+    e1000_bus_width_unknown = 0,
+    e1000_bus_width_32,
+    e1000_bus_width_64
+} e1000_bus_width;
+
+
+
+/* Function prototypes */
+/* Setup */
+void e1000_adapter_stop(struct e1000_shared_adapter *shared);
+boolean_t e1000_init_hw(struct e1000_shared_adapter *shared);
+void e1000_init_rx_addrs(struct e1000_shared_adapter *shared);
+
+/* Filters (multicast, vlan, receive) */
+void e1000_mc_addr_list_update(struct e1000_shared_adapter *shared, uint8_t * mc_addr_list, uint32_t mc_addr_count, uint32_t pad);
+uint32_t e1000_hash_mc_addr(struct e1000_shared_adapter *shared, uint8_t * mc_addr);
+void e1000_mta_set(struct e1000_shared_adapter *shared, uint32_t hash_value);
+void e1000_rar_set(struct e1000_shared_adapter *shared, uint8_t * mc_addr, uint32_t rar_index);
+void e1000_write_vfta(struct e1000_shared_adapter *shared, uint32_t offset, uint32_t value);
+void e1000_clear_vfta(struct e1000_shared_adapter *shared);
+
+/* Link layer setup functions */
+boolean_t e1000_setup_fc_and_link(struct e1000_shared_adapter *shared);
+boolean_t e1000_setup_pcs_link(struct e1000_shared_adapter *shared, uint32_t dev_ctrl_reg);
+void e1000_config_fc_after_link_up(struct e1000_shared_adapter *shared);
+void e1000_check_for_link(struct e1000_shared_adapter *shared);
+void e1000_get_speed_and_duplex(struct e1000_shared_adapter *shared, uint16_t * speed, uint16_t * duplex);
+
+/* EEPROM Functions */
+uint16_t e1000_read_eeprom(struct e1000_shared_adapter *shared, uint16_t reg);
+boolean_t e1000_validate_eeprom_checksum(struct e1000_shared_adapter *shared);
+void e1000_update_eeprom_checksum(struct e1000_shared_adapter *shared);
+boolean_t e1000_write_eeprom(struct e1000_shared_adapter *shared, uint16_t reg, uint16_t data);
+
+/* Everything else */
+void e1000_clear_hw_cntrs(struct e1000_shared_adapter *shared);
+boolean_t e1000_read_part_num(struct e1000_shared_adapter *shared, uint32_t * part_num);
+void e1000_led_on(struct e1000_shared_adapter *shared);
+void e1000_led_off(struct e1000_shared_adapter *shared);
+void e1000_get_bus_info(struct e1000_shared_adapter *shared);
+uint32_t e1000_tbi_adjust_stats(struct e1000_shared_adapter *shared, struct e1000_shared_stats *stats, uint32_t frame_len, uint8_t * mac_addr);
+void e1000_write_pci_cfg(struct e1000_shared_adapter *shared, uint32_t reg, uint16_t * value);
+
+/* PCI Device IDs */
+#define E1000_DEV_ID_82542          0x1000
+#define E1000_DEV_ID_82543GC_FIBER  0x1001
+#define E1000_DEV_ID_82543GC_COPPER 0x1004
+#define E1000_DEV_ID_82544EI_COPPER 0x1008
+#define E1000_DEV_ID_82544EI_FIBER  0x1009
+#define E1000_DEV_ID_82544GC_COPPER 0x100C
+#define E1000_DEV_ID_82544GC_LOM    0x100D
+#define E1000_DEV_ID_82540EM        0x100E
+#define NUM_DEV_IDS 8
+
+#define NODE_ADDRESS_SIZE 6
+#define ETH_LENGTH_OF_ADDRESS 6
+
+/* MAC decode size is 128K - This is the size of BAR0 */
+#define MAC_DECODE_SIZE (128 * 1024)
+
+#define E1000_82542_2_0_REV_ID 2
+#define E1000_82542_2_1_REV_ID 3
+
+#define SPEED_10    10
+#define SPEED_100   100
+#define SPEED_1000  1000
+#define HALF_DUPLEX 1
+#define FULL_DUPLEX 2
+
+/* The sizes (in bytes) of a ethernet packet */
+#define ENET_HEADER_SIZE             14
+#define MAXIMUM_ETHERNET_PACKET_SIZE 1514 /* Without FCS */
+#define MINIMUM_ETHERNET_PACKET_SIZE 60   /* Without FCS */
+#define CRC_LENGTH                   4
+#define MAX_JUMBO_FRAME_SIZE         0x3F00
+
+
+/* 802.1q VLAN Packet Sizes */
+#define VLAN_TAG_SIZE                     4     /* 802.3ac tag (not DMAed) */
+
+/* Ethertype field values */
+#define ETHERNET_IEEE_VLAN_TYPE 0x8100  /* 802.3ac packet */
+#define ETHERNET_IP_TYPE        0x0800  /* IP packets */
+#define ETHERNET_ARP_TYPE       0x0806  /* Address Resolution Protocol (ARP) */
+
+/* Packet Header defines */
+#define IP_PROTOCOL_TCP    6
+#define IP_PROTOCOL_UDP    0x11
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error 
+ */
+#define POLL_IMS_ENABLE_MASK ( \
+    E1000_IMS_RXDMT0 |         \
+    E1000_IMS_RXSEQ)
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXT0   = Receiver Timer Interrupt (ring 0)
+ *   o TXDW   = Transmit Descriptor Written Back
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error
+ *   o LSC    = Link Status Change
+ */
+#define IMS_ENABLE_MASK ( \
+    E1000_IMS_RXT0   |    \
+    E1000_IMS_TXDW   |    \
+    E1000_IMS_RXDMT0 |    \
+    E1000_IMS_RXSEQ  |    \
+    E1000_IMS_LSC)
+
+/* The number of high/low register pairs in the RAR. The RAR (Receive Address
+ * Registers) holds the directed and multicast addresses that we monitor. We
+ * reserve one of these spots for our directed address, allowing us room for
+ * E1000_RAR_ENTRIES - 1 multicast addresses. 
+ */
+#define E1000_RAR_ENTRIES 16
+
+#define MIN_NUMBER_OF_DESCRIPTORS 8
+#define MAX_NUMBER_OF_DESCRIPTORS 0xFFF8
+
+/* Receive Descriptor */
+struct e1000_rx_desc {
+    uint64_t buffer_addr; /* Address of the descriptor's data buffer */
+    uint16_t length;     /* Length of data DMAed into data buffer */
+    uint16_t csum;       /* Packet checksum */
+    uint8_t status;      /* Descriptor status */
+    uint8_t errors;      /* Descriptor Errors */
+    uint16_t special;
+};
+
+/* Receive Decriptor bit definitions */
+#define E1000_RXD_STAT_DD       0x01    /* Descriptor Done */
+#define E1000_RXD_STAT_EOP      0x02    /* End of Packet */
+#define E1000_RXD_STAT_IXSM     0x04    /* Ignore checksum */
+#define E1000_RXD_STAT_VP       0x08    /* IEEE VLAN Packet */
+#define E1000_RXD_STAT_TCPCS    0x20    /* TCP xsum calculated */
+#define E1000_RXD_STAT_IPCS     0x40    /* IP xsum calculated */
+#define E1000_RXD_STAT_PIF      0x80    /* passed in-exact filter */
+#define E1000_RXD_ERR_CE        0x01    /* CRC Error */
+#define E1000_RXD_ERR_SE        0x02    /* Symbol Error */
+#define E1000_RXD_ERR_SEQ       0x04    /* Sequence Error */
+#define E1000_RXD_ERR_CXE       0x10    /* Carrier Extension Error */
+#define E1000_RXD_ERR_TCPE      0x20    /* TCP/UDP Checksum Error */
+#define E1000_RXD_ERR_IPE       0x40    /* IP Checksum Error */
+#define E1000_RXD_ERR_RXE       0x80    /* Rx Data Error */
+#define E1000_RXD_SPC_VLAN_MASK 0x0FFF  /* VLAN ID is in lower 12 bits */
+#define E1000_RXD_SPC_PRI_MASK  0xE000  /* Priority is in upper 3 bits */
+#define E1000_RXD_SPC_PRI_SHIFT 0x000D  /* Priority is in upper 3 of 16 */
+#define E1000_RXD_SPC_CFI_MASK  0x1000  /* CFI is bit 12 */
+#define E1000_RXD_SPC_CFI_SHIFT 0x000C  /* CFI is bit 12 */
+
+/* mask to determine if packets should be dropped due to frame errors */
+#define E1000_RXD_ERR_FRAME_ERR_MASK ( \
+    E1000_RXD_ERR_CE  |                \
+    E1000_RXD_ERR_SE  |                \
+    E1000_RXD_ERR_SEQ |                \
+    E1000_RXD_ERR_CXE |                \
+    E1000_RXD_ERR_RXE)
+
+/* Transmit Descriptor */
+struct e1000_tx_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's data buffer */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t cso;        /* Checksum offset */
+            uint8_t cmd;        /* Descriptor control */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t css;        /* Checksum start */
+            uint16_t special;
+        } fields;
+    } upper;
+};
+
+/* Transmit Descriptor bit definitions */
+#define E1000_TXD_DTYP_D     0x00100000 /* Data Descriptor */
+#define E1000_TXD_DTYP_C     0x00000000 /* Context Descriptor */
+#define E1000_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
+#define E1000_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
+#define E1000_TXD_CMD_EOP    0x01000000 /* End of Packet */
+#define E1000_TXD_CMD_IFCS   0x02000000 /* Insert FCS (Ethernet CRC) */
+#define E1000_TXD_CMD_IC     0x04000000 /* Insert Checksum */
+#define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+#define E1000_TXD_CMD_RPS    0x10000000 /* Report Packet Sent */
+#define E1000_TXD_CMD_DEXT   0x20000000 /* Descriptor extension (0 = legacy) */
+#define E1000_TXD_CMD_VLE    0x40000000 /* Add VLAN tag */
+#define E1000_TXD_CMD_IDE    0x80000000 /* Enable Tidv register */
+#define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+#define E1000_TXD_STAT_EC    0x00000002 /* Excess Collisions */
+#define E1000_TXD_STAT_LC    0x00000004 /* Late Collisions */
+#define E1000_TXD_STAT_TU    0x00000008 /* Transmit underrun */
+#define E1000_TXD_CMD_TCP    0x01000000 /* TCP packet */
+#define E1000_TXD_CMD_IP     0x02000000 /* IP packet */
+#define E1000_TXD_CMD_TSE    0x04000000 /* TCP Seg enable */
+#define E1000_TXD_STAT_TC    0x00000004 /* Tx Underrun */
+
+/* Offload Context Descriptor */
+struct e1000_context_desc {
+    union {
+        uint32_t ip_config;
+        struct {
+            uint8_t ipcss;      /* IP checksum start */
+            uint8_t ipcso;      /* IP checksum offset */
+            uint16_t ipcse;     /* IP checksum end */
+        } ip_fields;
+    } lower_setup;
+    union {
+        uint32_t tcp_config;
+        struct {
+            uint8_t tucss;      /* TCP checksum start */
+            uint8_t tucso;      /* TCP checksum offset */
+            uint16_t tucse;     /* TCP checksum end */
+        } tcp_fields;
+    } upper_setup;
+    uint32_t cmd_and_length;    /* */
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t hdr_len;    /* Header length */
+            uint16_t mss;       /* Maximum segment size */
+        } fields;
+    } tcp_seg_setup;
+};
+
+/* Offload data descriptor */
+struct e1000_data_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's buffer address */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t typ_len_ext;        /* */
+            uint8_t cmd;        /* */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t popts;      /* Packet Options */
+            uint16_t special;   /* */
+        } fields;
+    } upper;
+};
+
+/* Filters */
+#define E1000_NUM_UNICAST          16   /* Unicast filter entries */
+#define E1000_MC_TBL_SIZE          128  /* Multicast Filter Table (4096 bits) */
+#define E1000_VLAN_FILTER_TBL_SIZE 128  /* VLAN Filter Table (4096 bits) */
+
+
+/* Receive Address Register */
+struct e1000_rar {
+    volatile uint32_t low;      /* receive address low */
+    volatile uint32_t high;     /* receive address high */
+};
+
+/* The number of entries in the Multicast Table Array (MTA). */
+#define E1000_NUM_MTA_REGISTERS 128
+
+/* IPv4 Address Table Entry */
+struct e1000_ipv4_at_entry {
+    volatile uint32_t ipv4_addr;        /* IP Address (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four wakeup IP addresses are supported */
+#define E1000_WAKEUP_IP_ADDRESS_COUNT_MAX 4
+#define E1000_IP4AT_SIZE                  E1000_WAKEUP_IP_ADDRESS_COUNT_MAX
+#define E1000_IP6AT_SIZE                  1
+
+/* IPv6 Address Table Entry */
+struct e1000_ipv6_at_entry {
+    volatile uint8_t ipv6_addr[16];
+};
+
+/* Flexible Filter Length Table Entry */
+struct e1000_fflt_entry {
+    volatile uint32_t length;   /* Flexible Filter Length (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Mask Table Entry */
+struct e1000_ffmt_entry {
+    volatile uint32_t mask;     /* Flexible Filter Mask (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Value Table Entry */
+struct e1000_ffvt_entry {
+    volatile uint32_t value;    /* Flexible Filter Value (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four Flexible Filters are supported */
+#define E1000_FLEXIBLE_FILTER_COUNT_MAX 4
+
+/* Each Flexible Filter is at most 128 (0x80) bytes in length */
+#define E1000_FLEXIBLE_FILTER_SIZE_MAX  128
+
+#define E1000_FFLT_SIZE E1000_FLEXIBLE_FILTER_COUNT_MAX
+#define E1000_FFMT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+#define E1000_FFVT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+
+/* Register Set. (82543, 82544)
+ *
+ * Registers are defined to be 32 bits and  should be accessed as 32 bit values.
+ * These registers are physically located on the NIC, but are mapped into the 
+ * host memory address space.
+ *
+ * RW - register is both readable and writable
+ * RO - register is read only
+ * WO - register is write only
+ * R/clr - register is read only and is cleared when read
+ * A - register array
+ */
+#define E1000_CTRL     0x00000  /* Device Control - RW */
+#define E1000_STATUS   0x00008  /* Device Status - RO */
+#define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
+#define E1000_EERD     0x00014  /* EEPROM Read - RW */
+#define E1000_CTRL_EXT 0x00018  /* Extended Device Control - RW */
+#define E1000_MDIC     0x00020  /* MDI Control - RW */
+#define E1000_FCAL     0x00028  /* Flow Control Address Low - RW */
+#define E1000_FCAH     0x0002C  /* Flow Control Address High -RW */
+#define E1000_FCT      0x00030  /* Flow Control Type - RW */
+#define E1000_VET      0x00038  /* VLAN Ether Type - RW */
+#define E1000_ICR      0x000C0  /* Interrupt Cause Read - R/clr */
+#define E1000_ITR      0x000C4  /* Interrupt Throttling Rate - RW */
+#define E1000_ICS      0x000C8  /* Interrupt Cause Set - WO */
+#define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
+#define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
+#define E1000_RCTL     0x00100  /* RX Control - RW */
+#define E1000_FCTTV    0x00170  /* Flow Control Transmit Timer Value - RW */
+#define E1000_TXCW     0x00178  /* TX Configuration Word - RW */
+#define E1000_RXCW     0x00180  /* RX Configuration Word - RO */
+#define E1000_TCTL     0x00400  /* TX Control - RW */
+#define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
+#define E1000_TBT      0x00448  /* TX Burst Timer - RW */
+#define E1000_LEDCTL   0x00E00  /* LED Control - RW */
+#define E1000_PBA      0x01000  /* Packet Buffer Allocation - RW */
+#define E1000_FCRTL    0x02160  /* Flow Control Receive Threshold Low - RW */
+#define E1000_FCRTH    0x02168  /* Flow Control Receive Threshold High - RW */
+#define E1000_RDBAL    0x02800  /* RX Descriptor Base Address Low - RW */
+#define E1000_RDBAH    0x02804  /* RX Descriptor Base Address High - RW */
+#define E1000_RDLEN    0x02808  /* RX Descriptor Length - RW */
+#define E1000_RDH      0x02810  /* RX Descriptor Head - RW */
+#define E1000_RDT      0x02818  /* RX Descriptor Tail - RW */
+#define E1000_RDTR     0x02820  /* RX Delay Timer - RW */
+#define E1000_RXDCTL   0x02828  /* RX Descriptor Control - RW */
+#define E1000_RADV     0x0282C  /* RX Interrupt Absolute Delay Timer - RW */
+#define E1000_RSRPD    0x02C00  /* RX Small Packet Detect - RW */
+#define E1000_TXDMAC   0x03000  /* TX DMA Control - RW */
+#define E1000_TDBAL    0x03800  /* TX Descriptor Base Address Low - RW */
+#define E1000_TDBAH    0x03804  /* TX Descriptor Base Address High - RW */
+#define E1000_TDLEN    0x03808  /* TX Descriptor Length - RW */
+#define E1000_TDH      0x03810  /* TX Descriptor Head - RW */
+#define E1000_TDT      0x03818  /* TX Descripotr Tail - RW */
+#define E1000_TIDV     0x03820  /* TX Interrupt Delay Value - RW */
+#define E1000_TXDCTL   0x03828  /* TX Descriptor Control - RW */
+#define E1000_TADV     0x0382C  /* TX Interrupt Absolute Delay Val - RW */
+#define E1000_TSPMT    0x03830  /* TCP Segmentation PAD & Min Threshold - RW */
+#define E1000_CRCERRS  0x04000  /* CRC Error Count - R/clr */
+#define E1000_ALGNERRC 0x04004  /* Alignment Error Count - R/clr */
+#define E1000_SYMERRS  0x04008  /* Symbol Error Count - R/clr */
+#define E1000_RXERRC   0x0400C  /* Receive Error Count - R/clr */
+#define E1000_MPC      0x04010  /* Missed Packet Count - R/clr */
+#define E1000_SCC      0x04014  /* Single Collision Count - R/clr */
+#define E1000_ECOL     0x04018  /* Excessive Collision Count - R/clr */
+#define E1000_MCC      0x0401C  /* Multiple Collision Count - R/clr */
+#define E1000_LATECOL  0x04020  /* Late Collision Count - R/clr */
+#define E1000_COLC     0x04028  /* Collision Count - R/clr */
+#define E1000_DC       0x04030  /* Defer Count - R/clr */
+#define E1000_TNCRS    0x04034  /* TX-No CRS - R/clr */
+#define E1000_SEC      0x04038  /* Sequence Error Count - R/clr */
+#define E1000_CEXTERR  0x0403C  /* Carrier Extension Error Count - R/clr */
+#define E1000_RLEC     0x04040  /* Receive Length Error Count - R/clr */
+#define E1000_XONRXC   0x04048  /* XON RX Count - R/clr */
+#define E1000_XONTXC   0x0404C  /* XON TX Count - R/clr */
+#define E1000_XOFFRXC  0x04050  /* XOFF RX Count - R/clr */
+#define E1000_XOFFTXC  0x04054  /* XOFF TX Count - R/clr */
+#define E1000_FCRUC    0x04058  /* Flow Control RX Unsupported Count- R/clr */
+#define E1000_PRC64    0x0405C  /* Packets RX (64 bytes) - R/clr */
+#define E1000_PRC127   0x04060  /* Packets RX (65-127 bytes) - R/clr */
+#define E1000_PRC255   0x04064  /* Packets RX (128-255 bytes) - R/clr */
+#define E1000_PRC511   0x04068  /* Packets RX (255-511 bytes) - R/clr */
+#define E1000_PRC1023  0x0406C  /* Packets RX (512-1023 bytes) - R/clr */
+#define E1000_PRC1522  0x04070  /* Packets RX (1024-1522 bytes) - R/clr */
+#define E1000_GPRC     0x04074  /* Good Packets RX Count - R/clr */
+#define E1000_BPRC     0x04078  /* Broadcast Packets RX Count - R/clr */
+#define E1000_MPRC     0x0407C  /* Multicast Packets RX Count - R/clr */
+#define E1000_GPTC     0x04080  /* Good Packets TX Count - R/clr */
+#define E1000_GORCL    0x04088  /* Good Octets RX Count Low - R/clr */
+#define E1000_GORCH    0x0408C  /* Good Octets RX Count High - R/clr */
+#define E1000_GOTCL    0x04090  /* Good Octets TX Count Low - R/clr */
+#define E1000_GOTCH    0x04094  /* Good Octets TX Count High - R/clr */
+#define E1000_RNBC     0x040A0  /* RX No Buffers Count - R/clr */
+#define E1000_RUC      0x040A4  /* RX Undersize Count - R/clr */
+#define E1000_RFC      0x040A8  /* RX Fragment Count - R/clr */
+#define E1000_ROC      0x040AC  /* RX Oversize Count - R/clr */
+#define E1000_RJC      0x040B0  /* RX Jabber Count - R/clr */
+#define E1000_MGTPRC   0x040B4  /* Management Packets RX Count - R/clr */
+#define E1000_MGTPDC   0x040B8  /* Management Packets Dropped Count - R/clr */
+#define E1000_MGTPTC   0x040BC  /* Management Packets TX Count - R/clr */
+#define E1000_TORL     0x040C0  /* Total Octets RX Low - R/clr */
+#define E1000_TORH     0x040C4  /* Total Octets RX High - R/clr */
+#define E1000_TOTL     0x040C8  /* Total Octets TX Low - R/clr */
+#define E1000_TOTH     0x040CC  /* Total Octets TX High - R/clr */
+#define E1000_TPR      0x040D0  /* Total Packets RX - R/clr */
+#define E1000_TPT      0x040D4  /* Total Packets TX - R/clr */
+#define E1000_PTC64    0x040D8  /* Packets TX (64 bytes) - R/clr */
+#define E1000_PTC127   0x040DC  /* Packets TX (65-127 bytes) - R/clr */
+#define E1000_PTC255   0x040E0  /* Packets TX (128-255 bytes) - R/clr */
+#define E1000_PTC511   0x040E4  /* Packets TX (256-511 bytes) - R/clr */
+#define E1000_PTC1023  0x040E8  /* Packets TX (512-1023 bytes) - R/clr */
+#define E1000_PTC1522  0x040EC  /* Packets TX (1024-1522 Bytes) - R/clr */
+#define E1000_MPTC     0x040F0  /* Multicast Packets TX Count - R/clr */
+#define E1000_BPTC     0x040F4  /* Broadcast Packets TX Count - R/clr */
+#define E1000_TSCTC    0x040F8  /* TCP Segmentation Context TX - R/clr */
+#define E1000_TSCTFC   0x040FC  /* TCP Segmentation Context TX Fail - R/clr */
+#define E1000_RXCSUM   0x05000  /* RX Checksum Control - RW */
+#define E1000_MTA      0x05200  /* Multicast Table Array - RW Array */
+#define E1000_RA       0x05400  /* Receive Address - RW Array */
+#define E1000_VFTA     0x05600  /* VLAN Filter Table Array - RW Array */
+#define E1000_WUC      0x05800  /* Wakeup Control - RW */
+#define E1000_WUFC     0x05808  /* Wakeup Filter Control - RW */
+#define E1000_WUS      0x05810  /* Wakeup Status - RO */
+#define E1000_MANC     0x05820  /* Management Control - RW */
+#define E1000_IPAV     0x05838  /* IP Address Valid - RW */
+#define E1000_IP4AT    0x05840  /* IPv4 Address Table - RW Array */
+#define E1000_IP6AT    0x05880  /* IPv6 Address Table - RW Array */
+#define E1000_WUPL     0x05900  /* Wakeup Packet Length - RW */
+#define E1000_WUPM     0x05A00  /* Wakeup Packet Memory - RO A */
+#define E1000_FFLT     0x05F00  /* Flexible Filter Length Table - RW Array */
+#define E1000_FFMT     0x09000  /* Flexible Filter Mask Table - RW Array */
+#define E1000_FFVT     0x09800  /* Flexible Filter Value Table - RW Array */
+
+/* Register Set (82542)
+ *
+ * Some of the 82542 registers are located at different offsets than they are
+ * in more current versions of the 8254x. Despite the difference in location,
+ * the registers function in the same manner.
+ */
+#define E1000_82542_CTRL     E1000_CTRL
+#define E1000_82542_STATUS   E1000_STATUS
+#define E1000_82542_EECD     E1000_EECD
+#define E1000_82542_EERD     E1000_EERD
+#define E1000_82542_CTRL_EXT E1000_CTRL_EXT
+#define E1000_82542_MDIC     E1000_MDIC
+#define E1000_82542_FCAL     E1000_FCAL
+#define E1000_82542_FCAH     E1000_FCAH
+#define E1000_82542_FCT      E1000_FCT
+#define E1000_82542_VET      E1000_VET
+#define E1000_82542_RA       0x00040
+#define E1000_82542_ICR      E1000_ICR
+#define E1000_82542_ITR      E1000_ITR
+#define E1000_82542_ICS      E1000_ICS
+#define E1000_82542_IMS      E1000_IMS
+#define E1000_82542_IMC      E1000_IMC
+#define E1000_82542_RCTL     E1000_RCTL
+#define E1000_82542_RDTR     0x00108
+#define E1000_82542_RDBAL    0x00110
+#define E1000_82542_RDBAH    0x00114
+#define E1000_82542_RDLEN    0x00118
+#define E1000_82542_RDH      0x00120
+#define E1000_82542_RDT      0x00128
+#define E1000_82542_FCRTH    0x00160
+#define E1000_82542_FCRTL    0x00168
+#define E1000_82542_FCTTV    E1000_FCTTV
+#define E1000_82542_TXCW     E1000_TXCW
+#define E1000_82542_RXCW     E1000_RXCW
+#define E1000_82542_MTA      0x00200
+#define E1000_82542_TCTL     E1000_TCTL
+#define E1000_82542_TIPG     E1000_TIPG
+#define E1000_82542_TDBAL    0x00420
+#define E1000_82542_TDBAH    0x00424
+#define E1000_82542_TDLEN    0x00428
+#define E1000_82542_TDH      0x00430
+#define E1000_82542_TDT      0x00438
+#define E1000_82542_TIDV     0x00440
+#define E1000_82542_TBT      E1000_TBT
+#define E1000_82542_VFTA     0x00600
+#define E1000_82542_LEDCTL   E1000_LEDCTL
+#define E1000_82542_PBA      E1000_PBA
+#define E1000_82542_RXDCTL   E1000_RXDCTL
+#define E1000_82542_RADV     E1000_RADV
+#define E1000_82542_RSRPD    E1000_RSRPD
+#define E1000_82542_TXDMAC   E1000_TXDMAC
+#define E1000_82542_TXDCTL   E1000_TXDCTL
+#define E1000_82542_TADV     E1000_TADV
+#define E1000_82542_TSPMT    E1000_TSPMT
+#define E1000_82542_CRCERRS  E1000_CRCERRS
+#define E1000_82542_ALGNERRC E1000_ALGNERRC
+#define E1000_82542_SYMERRS  E1000_SYMERRS
+#define E1000_82542_RXERRC   E1000_RXERRC
+#define E1000_82542_MPC      E1000_MPC
+#define E1000_82542_SCC      E1000_SCC
+#define E1000_82542_ECOL     E1000_ECOL
+#define E1000_82542_MCC      E1000_MCC
+#define E1000_82542_LATECOL  E1000_LATECOL
+#define E1000_82542_COLC     E1000_COLC
+#define E1000_82542_DC       E1000_DC
+#define E1000_82542_TNCRS    E1000_TNCRS
+#define E1000_82542_SEC      E1000_SEC
+#define E1000_82542_CEXTERR  E1000_CEXTERR
+#define E1000_82542_RLEC     E1000_RLEC
+#define E1000_82542_XONRXC   E1000_XONRXC
+#define E1000_82542_XONTXC   E1000_XONTXC
+#define E1000_82542_XOFFRXC  E1000_XOFFRXC
+#define E1000_82542_XOFFTXC  E1000_XOFFTXC
+#define E1000_82542_FCRUC    E1000_FCRUC
+#define E1000_82542_PRC64    E1000_PRC64
+#define E1000_82542_PRC127   E1000_PRC127
+#define E1000_82542_PRC255   E1000_PRC255
+#define E1000_82542_PRC511   E1000_PRC511
+#define E1000_82542_PRC1023  E1000_PRC1023
+#define E1000_82542_PRC1522  E1000_PRC1522
+#define E1000_82542_GPRC     E1000_GPRC
+#define E1000_82542_BPRC     E1000_BPRC
+#define E1000_82542_MPRC     E1000_MPRC
+#define E1000_82542_GPTC     E1000_GPTC
+#define E1000_82542_GORCL    E1000_GORCL
+#define E1000_82542_GORCH    E1000_GORCH
+#define E1000_82542_GOTCL    E1000_GOTCL
+#define E1000_82542_GOTCH    E1000_GOTCH
+#define E1000_82542_RNBC     E1000_RNBC
+#define E1000_82542_RUC      E1000_RUC
+#define E1000_82542_RFC      E1000_RFC
+#define E1000_82542_ROC      E1000_ROC
+#define E1000_82542_RJC      E1000_RJC
+#define E1000_82542_MGTPRC   E1000_MGTPRC
+#define E1000_82542_MGTPDC   E1000_MGTPDC
+#define E1000_82542_MGTPTC   E1000_MGTPTC
+#define E1000_82542_TORL     E1000_TORL
+#define E1000_82542_TORH     E1000_TORH
+#define E1000_82542_TOTL     E1000_TOTL
+#define E1000_82542_TOTH     E1000_TOTH
+#define E1000_82542_TPR      E1000_TPR
+#define E1000_82542_TPT      E1000_TPT
+#define E1000_82542_PTC64    E1000_PTC64
+#define E1000_82542_PTC127   E1000_PTC127
+#define E1000_82542_PTC255   E1000_PTC255
+#define E1000_82542_PTC511   E1000_PTC511
+#define E1000_82542_PTC1023  E1000_PTC1023
+#define E1000_82542_PTC1522  E1000_PTC1522
+#define E1000_82542_MPTC     E1000_MPTC
+#define E1000_82542_BPTC     E1000_BPTC
+#define E1000_82542_TSCTC    E1000_TSCTC
+#define E1000_82542_TSCTFC   E1000_TSCTFC
+#define E1000_82542_RXCSUM   E1000_RXCSUM
+#define E1000_82542_WUC      E1000_WUC
+#define E1000_82542_WUFC     E1000_WUFC
+#define E1000_82542_WUS      E1000_WUS
+#define E1000_82542_MANC     E1000_MANC
+#define E1000_82542_IPAV     E1000_IPAV
+#define E1000_82542_IP4AT    E1000_IP4AT
+#define E1000_82542_IP6AT    E1000_IP6AT
+#define E1000_82542_WUPL     E1000_WUPL
+#define E1000_82542_WUPM     E1000_WUPM
+#define E1000_82542_FFLT     E1000_FFLT
+#define E1000_82542_FFMT     E1000_FFMT
+#define E1000_82542_FFVT     E1000_FFVT
+
+/* Statistics counters collected by the MAC */
+struct e1000_shared_stats {
+    uint64_t crcerrs;
+    uint64_t algnerrc;
+    uint64_t symerrs;
+    uint64_t rxerrc;
+    uint64_t mpc;
+    uint64_t scc;
+    uint64_t ecol;
+    uint64_t mcc;
+    uint64_t latecol;
+    uint64_t colc;
+    uint64_t dc;
+    uint64_t tncrs;
+    uint64_t sec;
+    uint64_t cexterr;
+    uint64_t rlec;
+    uint64_t xonrxc;
+    uint64_t xontxc;
+    uint64_t xoffrxc;
+    uint64_t xofftxc;
+    uint64_t fcruc;
+    uint64_t prc64;
+    uint64_t prc127;
+    uint64_t prc255;
+    uint64_t prc511;
+    uint64_t prc1023;
+    uint64_t prc1522;
+    uint64_t gprc;
+    uint64_t bprc;
+    uint64_t mprc;
+    uint64_t gptc;
+    uint64_t gorcl;
+    uint64_t gorch;
+    uint64_t gotcl;
+    uint64_t gotch;
+    uint64_t rnbc;
+    uint64_t ruc;
+    uint64_t rfc;
+    uint64_t roc;
+    uint64_t rjc;
+    uint64_t mgprc;
+    uint64_t mgpdc;
+    uint64_t mgptc;
+    uint64_t torl;
+    uint64_t torh;
+    uint64_t totl;
+    uint64_t toth;
+    uint64_t tpr;
+    uint64_t tpt;
+    uint64_t ptc64;
+    uint64_t ptc127;
+    uint64_t ptc255;
+    uint64_t ptc511;
+    uint64_t ptc1023;
+    uint64_t ptc1522;
+    uint64_t mptc;
+    uint64_t bptc;
+    uint64_t tsctc;
+    uint64_t tsctfc;
+};
+
+/* Structure containing variables used by the shared code (e1000_mac.c and 
+ * e1000_phy.c)
+ */
+struct e1000_shared_adapter {
+    uint8_t *hw_addr;
+    e1000_mac_type mac_type;
+    e1000_media_type media_type;
+    void *back;
+    e1000_fc_type fc;
+    e1000_bus_speed bus_speed;
+    e1000_bus_width bus_width;
+    e1000_bus_type bus_type;
+    uint32_t phy_id;
+    uint32_t phy_addr;
+    uint32_t original_fc;
+    uint32_t txcw_reg;
+    uint32_t autoneg_failed;
+    uint32_t max_frame_size;
+    uint32_t min_frame_size;
+    uint32_t mc_filter_type;
+    uint32_t num_mc_addrs;
+    uint16_t autoneg_advertised;
+    uint16_t pci_cmd_word;
+    uint16_t fc_high_water;
+    uint16_t fc_low_water;
+    uint16_t fc_pause_time;
+    uint16_t device_id;
+    uint16_t vendor_id;
+    uint16_t subsystem_id;
+    uint16_t subsystem_vendor_id;
+    uint8_t revision_id;
+    boolean_t disable_polarity_correction;
+    boolean_t get_link_status;
+    boolean_t tbi_compatibility_en;
+    boolean_t tbi_compatibility_on;
+    boolean_t adapter_stopped;
+    boolean_t fc_send_xon;
+    boolean_t report_tx_early;
+    boolean_t low_profile;
+    uint8_t autoneg;
+    uint8_t mdix;
+    uint8_t forced_speed_duplex;
+    uint8_t wait_autoneg_complete;
+    uint8_t dma_fairness;
+    uint8_t mac_addr[NODE_ADDRESS_SIZE];
+};
+
+
+#define E1000_EEPROM_SWDPIN0   0x0001   /* SWDPIN 0 EEPROM Value */
+#define E1000_EEPROM_LED_LOGIC 0x0020   /* Led Logic Word */
+
+/* Register Bit Masks */
+/* Device Control */
+#define E1000_CTRL_FD       0x00000001  /* Full duplex.0=half; 1=full */
+#define E1000_CTRL_BEM      0x00000002  /* Endian Mode.0=little,1=big */
+#define E1000_CTRL_PRIOR    0x00000004  /* Priority on PCI. 0=rx,1=fair */
+#define E1000_CTRL_LRST     0x00000008  /* Link reset. 0=normal,1=reset */
+#define E1000_CTRL_TME      0x00000010  /* Test mode. 0=normal,1=test */
+#define E1000_CTRL_SLE      0x00000020  /* Serial Link on 0=dis,1=en */
+#define E1000_CTRL_ASDE     0x00000020  /* Auto-speed detect enable */
+#define E1000_CTRL_SLU      0x00000040  /* Set link up (Force Link) */
+#define E1000_CTRL_ILOS     0x00000080  /* Invert Loss-Of Signal */
+#define E1000_CTRL_SPD_SEL  0x00000300  /* Speed Select Mask */
+#define E1000_CTRL_SPD_10   0x00000000  /* Force 10Mb */
+#define E1000_CTRL_SPD_100  0x00000100  /* Force 100Mb */
+#define E1000_CTRL_SPD_1000 0x00000200  /* Force 1Gb */
+#define E1000_CTRL_BEM32    0x00000400  /* Big Endian 32 mode */
+#define E1000_CTRL_FRCSPD   0x00000800  /* Force Speed */
+#define E1000_CTRL_FRCDPX   0x00001000  /* Force Duplex */
+#define E1000_CTRL_SWDPIN0  0x00040000  /* SWDPIN 0 value */
+#define E1000_CTRL_SWDPIN1  0x00080000  /* SWDPIN 1 value */
+#define E1000_CTRL_SWDPIN2  0x00100000  /* SWDPIN 2 value */
+#define E1000_CTRL_SWDPIN3  0x00200000  /* SWDPIN 3 value */
+#define E1000_CTRL_SWDPIO0  0x00400000  /* SWDPIN 0 Input or output */
+#define E1000_CTRL_SWDPIO1  0x00800000  /* SWDPIN 1 input or output */
+#define E1000_CTRL_SWDPIO2  0x01000000  /* SWDPIN 2 input or output */
+#define E1000_CTRL_SWDPIO3  0x02000000  /* SWDPIN 3 input or output */
+#define E1000_CTRL_RST      0x04000000  /* Global reset */
+#define E1000_CTRL_RFCE     0x08000000  /* Receive Flow Control enable */
+#define E1000_CTRL_TFCE     0x10000000  /* Transmit flow control enable */
+#define E1000_CTRL_RTE      0x20000000  /* Routing tag enable */
+#define E1000_CTRL_VME      0x40000000  /* IEEE VLAN mode enable */
+#define E1000_CTRL_PHY_RST  0x80000000  /* PHY Reset */
+
+/* Device Status */
+#define E1000_STATUS_FD         0x00000001      /* Full duplex.0=half,1=full */
+#define E1000_STATUS_LU         0x00000002      /* Link up.0=no,1=link */
+#define E1000_STATUS_FUNC_MASK  0x0000000C      /* PCI Function Mask */
+#define E1000_STATUS_FUNC_0     0x00000000      /* Function 0 */
+#define E1000_STATUS_FUNC_1     0x00000004      /* Function 1 */
+#define E1000_STATUS_TXOFF      0x00000010      /* transmission paused */
+#define E1000_STATUS_TBIMODE    0x00000020      /* TBI mode */
+#define E1000_STATUS_SPEED_MASK 0x000000C0
+#define E1000_STATUS_SPEED_10   0x00000000      /* Speed 10Mb/s */
+#define E1000_STATUS_SPEED_100  0x00000040      /* Speed 100Mb/s */
+#define E1000_STATUS_SPEED_1000 0x00000080      /* Speed 1000Mb/s */
+#define E1000_STATUS_ASDV       0x00000300      /* Auto speed detect value */
+#define E1000_STATUS_MTXCKOK    0x00000400      /* MTX clock running OK */
+#define E1000_STATUS_PCI66      0x00000800      /* In 66Mhz slot */
+#define E1000_STATUS_BUS64      0x00001000      /* In 64 bit slot */
+#define E1000_STATUS_PCIX_MODE  0x00002000      /* PCI-X mode */
+#define E1000_STATUS_PCIX_SPEED 0x0000C000      /* PCI-X bus speed */
+
+/* Constants used to intrepret the masked PCI-X bus speed. */
+#define E1000_STATUS_PCIX_SPEED_66  0x00000000 /* PCI-X bus speed  50-66 MHz */
+#define E1000_STATUS_PCIX_SPEED_100 0x00004000 /* PCI-X bus speed  66-100 MHz */
+#define E1000_STATUS_PCIX_SPEED_133 0x00008000 /* PCI-X bus speed 100-133 MHz */
+
+/* EEPROM/Flash Control */
+#define E1000_EECD_SK        0x00000001 /* EEPROM Clock */
+#define E1000_EECD_CS        0x00000002 /* EEPROM Chip Select */
+#define E1000_EECD_DI        0x00000004 /* EEPROM Data In */
+#define E1000_EECD_DO        0x00000008 /* EEPROM Data Out */
+#define E1000_EECD_FWE_MASK  0x00000030 
+#define E1000_EECD_FWE_DIS   0x00000010 /* Disable FLASH writes */
+#define E1000_EECD_FWE_EN    0x00000020 /* Enable FLASH writes */
+#define E1000_EECD_FWE_SHIFT 4
+#define E1000_EECD_SIZE      0x00000200 /* EEPROM Size (0=64 word 1=256 word) */
+#define E1000_EECD_REQ       0x00000040 /* EEPROM Access Request */
+#define E1000_EECD_GNT       0x00000080 /* EEPROM Access Grant */
+#define E1000_EECD_PRES      0x00000100 /* EEPROM Present */
+
+/* EEPROM Read */
+#define E1000_EERD_START      0x00000001 /* Start Read */
+#define E1000_EERD_DONE       0x00000010 /* Read Done */
+#define E1000_EERD_ADDR_SHIFT 8
+#define E1000_EERD_ADDR_MASK  0x0000FF00 /* Read Address */
+#define E1000_EERD_DATA_SHIFT 16
+#define E1000_EERD_DATA_MASK  0xFFFF0000 /* Read Data */
+
+/* Extended Device Control */
+#define E1000_CTRL_EXT_GPI0_EN   0x00000001 /* Maps SDP4 to GPI0 */ 
+#define E1000_CTRL_EXT_GPI1_EN   0x00000002 /* Maps SDP5 to GPI1 */
+#define E1000_CTRL_EXT_PHYINT_EN E1000_CTRL_EXT_GPI1_EN
+#define E1000_CTRL_EXT_GPI2_EN   0x00000004 /* Maps SDP6 to GPI2 */
+#define E1000_CTRL_EXT_GPI3_EN   0x00000008 /* Maps SDP7 to GPI3 */
+#define E1000_CTRL_EXT_SDP4_DATA 0x00000010 /* Value of SW Defineable Pin 4 */
+#define E1000_CTRL_EXT_SDP5_DATA 0x00000020 /* Value of SW Defineable Pin 5 */
+#define E1000_CTRL_EXT_PHY_INT   E1000_CTRL_EXT_SDP5_DATA
+#define E1000_CTRL_EXT_SDP6_DATA 0x00000040 /* Value of SW Defineable Pin 6 */
+#define E1000_CTRL_EXT_SDP7_DATA 0x00000080 /* Value of SW Defineable Pin 7 */
+#define E1000_CTRL_EXT_SDP4_DIR  0x00000100 /* Direction of SDP4 0=in 1=out */
+#define E1000_CTRL_EXT_SDP5_DIR  0x00000200 /* Direction of SDP5 0=in 1=out */
+#define E1000_CTRL_EXT_SDP6_DIR  0x00000400 /* Direction of SDP6 0=in 1=out */
+#define E1000_CTRL_EXT_SDP7_DIR  0x00000800 /* Direction of SDP7 0=in 1=out */
+#define E1000_CTRL_EXT_ASDCHK    0x00001000 /* Initiate an ASD sequence */
+#define E1000_CTRL_EXT_EE_RST    0x00002000 /* Reinitialize from EEPROM */
+#define E1000_CTRL_EXT_IPS       0x00004000 /* Invert Power State */
+#define E1000_CTRL_EXT_SPD_BYPS  0x00008000 /* Speed Select Bypass */
+#define E1000_CTRL_EXT_LINK_MODE_MASK 0x00C00000
+#define E1000_CTRL_EXT_LINK_MODE_GMII 0x00000000
+#define E1000_CTRL_EXT_LINK_MODE_TBI  0x00C00000
+#define E1000_CTRL_EXT_WR_WMARK_MASK  0x03000000
+#define E1000_CTRL_EXT_WR_WMARK_256   0x00000000
+#define E1000_CTRL_EXT_WR_WMARK_320   0x01000000
+#define E1000_CTRL_EXT_WR_WMARK_384   0x02000000
+#define E1000_CTRL_EXT_WR_WMARK_448   0x03000000
+
+/* MDI Control */
+#define E1000_MDIC_DATA_MASK 0x0000FFFF
+#define E1000_MDIC_REG_MASK  0x001F0000
+#define E1000_MDIC_REG_SHIFT 16
+#define E1000_MDIC_PHY_MASK  0x03E00000
+#define E1000_MDIC_PHY_SHIFT 21
+#define E1000_MDIC_OP_WRITE  0x04000000
+#define E1000_MDIC_OP_READ   0x08000000
+#define E1000_MDIC_READY     0x10000000
+#define E1000_MDIC_INT_EN    0x20000000
+#define E1000_MDIC_ERROR     0x40000000
+
+/* LED Control */
+#define E1000_LEDCTL_LED0_MODE_MASK  0x0000000F
+#define E1000_LEDCTL_LED0_MODE_SHIFT 0
+#define E1000_LEDCTL_LED0_IVRT       0x00000040
+#define E1000_LEDCTL_LED0_BLINK      0x00000080
+#define E1000_LEDCTL_LED1_MODE_MASK  0x00000F00
+#define E1000_LEDCTL_LED1_MODE_SHIFT 8
+#define E1000_LEDCTL_LED1_IVRT       0x00004000
+#define E1000_LEDCTL_LED1_BLINK      0x00008000
+#define E1000_LEDCTL_LED2_MODE_MASK  0x000F0000
+#define E1000_LEDCTL_LED2_MODE_SHIFT 16
+#define E1000_LEDCTL_LED2_IVRT       0x00400000
+#define E1000_LEDCTL_LED2_BLINK      0x00800000
+#define E1000_LEDCTL_LED3_MODE_MASK  0x0F000000
+#define E1000_LEDCTL_LED3_MODE_SHIFT 24
+#define E1000_LEDCTL_LED3_IVRT       0x40000000
+#define E1000_LEDCTL_LED3_BLINK      0x80000000
+
+#define E1000_LEDCTL_MODE_LINK_10_1000  0x0
+#define E1000_LEDCTL_MODE_LINK_100_1000 0x1
+#define E1000_LEDCTL_MODE_LINK_UP       0x2
+#define E1000_LEDCTL_MODE_ACTIVITY      0x3
+#define E1000_LEDCTL_MODE_LINK_ACTIVITY 0x4
+#define E1000_LEDCTL_MODE_LINK_10       0x5
+#define E1000_LEDCTL_MODE_LINK_100      0x6
+#define E1000_LEDCTL_MODE_LINK_1000     0x7
+#define E1000_LEDCTL_MODE_PCIX_MODE     0x8
+#define E1000_LEDCTL_MODE_FULL_DUPLEX   0x9
+#define E1000_LEDCTL_MODE_COLLISION     0xA
+#define E1000_LEDCTL_MODE_BUS_SPEED     0xB
+#define E1000_LEDCTL_MODE_BUS_SIZE      0xC
+#define E1000_LEDCTL_MODE_PAUSED        0xD
+#define E1000_LEDCTL_MODE_LED_ON        0xE
+#define E1000_LEDCTL_MODE_LED_OFF       0xF
+
+/* Receive Address */
+#define E1000_RAH_AV  0x80000000        /* Receive descriptor valid */
+
+/* Interrupt Cause Read */
+#define E1000_ICR_TXDW    0x00000001    /* Transmit desc written back */
+#define E1000_ICR_TXQE    0x00000002    /* Transmit Queue empty */
+#define E1000_ICR_LSC     0x00000004    /* Link Status Change */
+#define E1000_ICR_RXSEQ   0x00000008    /* rx sequence error */
+#define E1000_ICR_RXDMT0  0x00000010    /* rx desc min. threshold (0) */
+#define E1000_ICR_RXO     0x00000040    /* rx overrun */
+#define E1000_ICR_RXT0    0x00000080    /* rx timer intr (ring 0) */
+#define E1000_ICR_MDAC    0x00000200    /* MDIO access complete */
+#define E1000_ICR_RXCFG   0x00000400    /* RX /c/ ordered set */
+#define E1000_ICR_GPI_EN0 0x00000800    /* GP Int 0 */
+#define E1000_ICR_GPI_EN1 0x00001000    /* GP Int 1 */
+#define E1000_ICR_GPI_EN2 0x00002000    /* GP Int 2 */
+#define E1000_ICR_GPI_EN3 0x00004000    /* GP Int 3 */
+#define E1000_ICR_TXD_LOW 0x00008000
+#define E1000_ICR_SRPD    0x00010000
+
+/* Interrupt Cause Set */
+#define E1000_ICS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_ICS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_ICS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_ICS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_ICS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_ICS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_ICS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_ICS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_ICS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_ICS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_ICS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_ICS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_ICS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_ICS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_ICS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Set */
+#define E1000_IMS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Clear */
+#define E1000_IMC_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMC_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMC_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMC_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMC_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMC_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMC_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMC_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMC_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMC_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMC_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMC_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMC_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMC_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMC_SRPD    E1000_ICR_SRPD
+
+/* Receive Control */
+#define E1000_RCTL_RST          0x00000001      /* Software reset */
+#define E1000_RCTL_EN           0x00000002      /* enable */
+#define E1000_RCTL_SBP          0x00000004      /* store bad packet */
+#define E1000_RCTL_UPE          0x00000008      /* unicast promiscuous enable */
+#define E1000_RCTL_MPE          0x00000010      /* multicast promiscuous enab */
+#define E1000_RCTL_LPE          0x00000020      /* long packet enable */
+#define E1000_RCTL_LBM_NO       0x00000000      /* no loopback mode */
+#define E1000_RCTL_LBM_MAC      0x00000040      /* MAC loopback mode */
+#define E1000_RCTL_LBM_SLP      0x00000080      /* serial link loopback mode */
+#define E1000_RCTL_LBM_TCVR     0x000000C0      /* tcvr loopback mode */
+#define E1000_RCTL_RDMTS_HALF   0x00000000      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_QUAT   0x00000100      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_EIGTH  0x00000200      /* rx desc min threshold size */
+#define E1000_RCTL_MO_SHIFT     12              /* multicast offset shift */
+#define E1000_RCTL_MO_0         0x00000000      /* multicast offset 11:0 */
+#define E1000_RCTL_MO_1         0x00001000      /* multicast offset 12:1 */
+#define E1000_RCTL_MO_2         0x00002000      /* multicast offset 13:2 */
+#define E1000_RCTL_MO_3         0x00003000      /* multicast offset 15:4 */
+#define E1000_RCTL_MDR          0x00004000      /* multicast desc ring 0 */
+#define E1000_RCTL_BAM          0x00008000      /* broadcast enable */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
+#define E1000_RCTL_SZ_2048      0x00000000      /* rx buffer size 2048 */
+#define E1000_RCTL_SZ_1024      0x00010000      /* rx buffer size 1024 */
+#define E1000_RCTL_SZ_512       0x00020000      /* rx buffer size 512 */
+#define E1000_RCTL_SZ_256       0x00030000      /* rx buffer size 256 */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 1 */
+#define E1000_RCTL_SZ_16384     0x00010000      /* rx buffer size 16384 */
+#define E1000_RCTL_SZ_8192      0x00020000      /* rx buffer size 8192 */
+#define E1000_RCTL_SZ_4096      0x00030000      /* rx buffer size 4096 */
+#define E1000_RCTL_VFE          0x00040000      /* vlan filter enable */
+#define E1000_RCTL_CFIEN        0x00080000      /* canonical form enable */
+#define E1000_RCTL_CFI          0x00100000      /* canonical form indicator */
+#define E1000_RCTL_DPF          0x00400000      /* discard pause frames */
+#define E1000_RCTL_PMCF         0x00800000      /* pass MAC control frames */
+#define E1000_RCTL_BSEX         0x02000000      /* Buffer size extension */
+
+/* Receive Descriptor */
+#define E1000_RDT_DELAY 0x0000ffff      /* Delay timer (1=1024us) */
+#define E1000_RDT_FPDB  0x80000000      /* Flush descriptor block */
+#define E1000_RDLEN_LEN 0x0007ff80      /* descriptor length */
+#define E1000_RDH_RDH   0x0000ffff      /* receive descriptor head */
+#define E1000_RDT_RDT   0x0000ffff      /* receive descriptor tail */
+
+/* Flow Control */
+#define E1000_FCRTH_RTH  0x0000FFF8     /* Mask Bits[15:3] for RTH */
+#define E1000_FCRTH_XFCE 0x80000000     /* External Flow Control Enable */
+#define E1000_FCRTL_RTL  0x0000FFF8     /* Mask Bits[15:3] for RTL */
+#define E1000_FCRTL_XONE 0x80000000     /* Enable XON frame transmission */
+
+/* Receive Descriptor Control */
+#define E1000_RXDCTL_PTHRESH 0x0000003F /* RXDCTL Prefetch Threshold */
+#define E1000_RXDCTL_HTHRESH 0x00003F00 /* RXDCTL Host Threshold */
+#define E1000_RXDCTL_WTHRESH 0x003F0000 /* RXDCTL Writeback Threshold */
+#define E1000_RXDCTL_GRAN    0x01000000 /* RXDCTL Granularity */
+
+/* Transmit Descriptor Control */
+#define E1000_TXDCTL_PTHRESH 0x000000FF /* TXDCTL Prefetch Threshold */
+#define E1000_TXDCTL_HTHRESH 0x0000FF00 /* TXDCTL Host Threshold */
+#define E1000_TXDCTL_WTHRESH 0x00FF0000 /* TXDCTL Writeback Threshold */
+#define E1000_TXDCTL_GRAN    0x01000000 /* TXDCTL Granularity */
+#define E1000_TXDCTL_LWTHRESH 0xFE000000 /* TXDCTL Low Threshold */
+
+/* Transmit Configuration Word */
+#define E1000_TXCW_FD         0x00000020        /* TXCW full duplex */
+#define E1000_TXCW_HD         0x00000040        /* TXCW half duplex */
+#define E1000_TXCW_PAUSE      0x00000080        /* TXCW sym pause request */
+#define E1000_TXCW_ASM_DIR    0x00000100        /* TXCW astm pause direction */
+#define E1000_TXCW_PAUSE_MASK 0x00000180        /* TXCW pause request mask */
+#define E1000_TXCW_RF         0x00003000        /* TXCW remote fault */
+#define E1000_TXCW_NP         0x00008000        /* TXCW next page */
+#define E1000_TXCW_CW         0x0000ffff        /* TxConfigWord mask */
+#define E1000_TXCW_TXC        0x40000000        /* Transmit Config control */
+#define E1000_TXCW_ANE        0x80000000        /* Auto-neg enable */
+
+/* Receive Configuration Word */
+#define E1000_RXCW_CW    0x0000ffff     /* RxConfigWord mask */
+#define E1000_RXCW_NC    0x04000000     /* Receive config no carrier */
+#define E1000_RXCW_IV    0x08000000     /* Receive config invalid */
+#define E1000_RXCW_CC    0x10000000     /* Receive config change */
+#define E1000_RXCW_C     0x20000000     /* Receive config */
+#define E1000_RXCW_SYNCH 0x40000000     /* Receive config synch */
+#define E1000_RXCW_ANC   0x80000000     /* Auto-neg complete */
+
+/* Transmit Control */
+#define E1000_TCTL_RST    0x00000001    /* software reset */
+#define E1000_TCTL_EN     0x00000002    /* enable tx */
+#define E1000_TCTL_BCE    0x00000004    /* busy check enable */
+#define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+#define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+#define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+#define E1000_TCTL_SWXOFF 0x00400000    /* SW Xoff transmission */
+#define E1000_TCTL_PBE    0x00800000    /* Packet Burst Enable */
+#define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+#define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
+
+/* Receive Checksum Control */
+#define E1000_RXCSUM_PCSS_MASK 0x000000FF   /* Packet Checksum Start */
+#define E1000_RXCSUM_IPOFL     0x00000100   /* IPv4 checksum offload */
+#define E1000_RXCSUM_TUOFL     0x00000200   /* TCP / UDP checksum offload */
+#define E1000_RXCSUM_IPV6OFL   0x00000400   /* IPv6 checksum offload */
+
+/* Definitions for power management and wakeup registers */
+/* Wake Up Control */
+#define E1000_WUC_APME       0x00000001 /* APM Enable */
+#define E1000_WUC_PME_EN     0x00000002 /* PME Enable */
+#define E1000_WUC_PME_STATUS 0x00000004 /* PME Status */
+#define E1000_WUC_APMPME     0x00000008 /* Assert PME on APM Wakeup */
+
+/* Wake Up Filter Control */
+#define E1000_WUFC_LNKC 0x00000001 /* Link Status Change Wakeup Enable */
+#define E1000_WUFC_MAG  0x00000002 /* Magic Packet Wakeup Enable */
+#define E1000_WUFC_EX   0x00000004 /* Directed Exact Wakeup Enable */
+#define E1000_WUFC_MC   0x00000008 /* Directed Multicast Wakeup Enable */
+#define E1000_WUFC_BC   0x00000010 /* Broadcast Wakeup Enable */
+#define E1000_WUFC_ARP  0x00000020 /* ARP Request Packet Wakeup Enable */
+#define E1000_WUFC_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Enable */
+#define E1000_WUFC_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Enable */
+#define E1000_WUFC_FLX0 0x00010000 /* Flexible Filter 0 Enable */
+#define E1000_WUFC_FLX1 0x00020000 /* Flexible Filter 1 Enable */
+#define E1000_WUFC_FLX2 0x00040000 /* Flexible Filter 2 Enable */
+#define E1000_WUFC_FLX3 0x00080000 /* Flexible Filter 3 Enable */
+#define E1000_WUFC_ALL_FILTERS 0x000F00FF /* Mask for all wakeup filters */
+#define E1000_WUFC_FLX_OFFSET 16       /* Offset to the Flexible Filters bits */
+#define E1000_WUFC_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Wake Up Status */
+#define E1000_WUS_LNKC 0x00000001 /* Link Status Changed */
+#define E1000_WUS_MAG  0x00000002 /* Magic Packet Received */
+#define E1000_WUS_EX   0x00000004 /* Directed Exact Received */
+#define E1000_WUS_MC   0x00000008 /* Directed Multicast Received */
+#define E1000_WUS_BC   0x00000010 /* Broadcast Received */
+#define E1000_WUS_ARP  0x00000020 /* ARP Request Packet Received */
+#define E1000_WUS_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Received */
+#define E1000_WUS_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Received */
+#define E1000_WUS_FLX0 0x00010000 /* Flexible Filter 0 Match */
+#define E1000_WUS_FLX1 0x00020000 /* Flexible Filter 1 Match */
+#define E1000_WUS_FLX2 0x00040000 /* Flexible Filter 2 Match */
+#define E1000_WUS_FLX3 0x00080000 /* Flexible Filter 3 Match */
+#define E1000_WUS_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Management Control */
+#define E1000_MANC_SMBUS_EN      0x00000001 /* SMBus Enabled - RO */
+#define E1000_MANC_ASF_EN        0x00000002 /* ASF Enabled - RO */
+#define E1000_MANC_R_ON_FORCE    0x00000004 /* Reset on Force TCO - RO */
+#define E1000_MANC_RMCP_EN       0x00000100 /* Enable RCMP 026Fh Filtering */
+#define E1000_MANC_0298_EN       0x00000200 /* Enable RCMP 0298h Filtering */
+#define E1000_MANC_IPV4_EN       0x00000400 /* Enable IPv4 */
+#define E1000_MANC_IPV6_EN       0x00000800 /* Enable IPv6 */
+#define E1000_MANC_SNAP_EN       0x00001000 /* Accept LLC/SNAP */
+#define E1000_MANC_ARP_EN        0x00002000 /* Enable ARP Request Filtering */
+#define E1000_MANC_NEIGHBOR_EN   0x00004000 /* Enable Neighbor Discovery 
+                                             * Filtering */
+#define E1000_MANC_TCO_RESET     0x00010000 /* TCO Reset Occurred */
+#define E1000_MANC_RCV_TCO_EN    0x00020000 /* Receive TCO Packets Enabled */
+#define E1000_MANC_REPORT_STATUS 0x00040000 /* Status Reporting Enabled */
+#define E1000_MANC_SMB_REQ       0x01000000 /* SMBus Request */
+#define E1000_MANC_SMB_GNT       0x02000000 /* SMBus Grant */
+#define E1000_MANC_SMB_CLK_IN    0x04000000 /* SMBus Clock In */
+#define E1000_MANC_SMB_DATA_IN   0x08000000 /* SMBus Data In */
+#define E1000_MANC_SMB_DATA_OUT  0x10000000 /* SMBus Data Out */
+#define E1000_MANC_SMB_CLK_OUT   0x20000000 /* SMBus Clock Out */
+
+#define E1000_MANC_SMB_DATA_OUT_SHIFT  28 /* SMBus Data Out Shift */
+#define E1000_MANC_SMB_CLK_OUT_SHIFT   29 /* SMBus Clock Out Shift */
+
+/* Wake Up Packet Length */
+#define E1000_WUPL_LENGTH_MASK 0x0FFF   /* Only the lower 12 bits are valid */
+
+#define E1000_MDALIGN          4096
+
+/* EEPROM Commands */
+#define EEPROM_READ_OPCODE  0x6  /* EERPOM read opcode */
+#define EEPROM_WRITE_OPCODE 0x5  /* EERPOM write opcode */
+#define EEPROM_ERASE_OPCODE 0x7  /* EERPOM erase opcode */
+#define EEPROM_EWEN_OPCODE  0x13 /* EERPOM erase/write enable */
+#define EEPROM_EWDS_OPCODE  0x10 /* EERPOM erast/write disable */
+
+/* EEPROM Word Offsets */
+#define EEPROM_INIT_CONTROL1_REG 0x000A
+#define EEPROM_INIT_CONTROL2_REG 0x000F
+#define EEPROM_FLASH_VERSION     0x0032
+#define EEPROM_CHECKSUM_REG      0x003F
+
+/* Mask bits for fields in Word 0x0a of the EEPROM */
+#define EEPROM_WORD0A_ILOS   0x0010
+#define EEPROM_WORD0A_SWDPIO 0x01E0
+#define EEPROM_WORD0A_LRST   0x0200
+#define EEPROM_WORD0A_FD     0x0400
+#define EEPROM_WORD0A_66MHZ  0x0800
+
+/* Mask bits for fields in Word 0x0f of the EEPROM */
+#define EEPROM_WORD0F_PAUSE_MASK 0x3000
+#define EEPROM_WORD0F_PAUSE      0x1000
+#define EEPROM_WORD0F_ASM_DIR    0x2000
+#define EEPROM_WORD0F_ANE        0x0800
+#define EEPROM_WORD0F_SWPDIO_EXT 0x00F0
+
+/* For checksumming, the sum of all words in the EEPROM should equal 0xBABA. */
+#define EEPROM_SUM 0xBABA
+
+/* EEPROM Map defines (WORD OFFSETS)*/
+#define EEPROM_NODE_ADDRESS_BYTE_0 0
+#define EEPROM_PBA_BYTE_1          8
+
+/* EEPROM Map Sizes (Byte Counts) */
+#define PBA_SIZE 4
+
+/* Collision related configuration parameters */
+#define E1000_COLLISION_THRESHOLD       16
+#define E1000_CT_SHIFT                  4
+#define E1000_FDX_COLLISION_DISTANCE    64
+#define E1000_HDX_COLLISION_DISTANCE    64
+#define E1000_GB_HDX_COLLISION_DISTANCE 512
+#define E1000_COLD_SHIFT                12
+
+/* The number of Transmit and Receive Descriptors must be a multiple of 8 */
+#define REQ_TX_DESCRIPTOR_MULTIPLE  8
+#define REQ_RX_DESCRIPTOR_MULTIPLE  8
+
+/* Default values for the transmit IPG register */
+#define DEFAULT_82542_TIPG_IPGT        10
+#define DEFAULT_82543_TIPG_IPGT_FIBER  9
+#define DEFAULT_82543_TIPG_IPGT_COPPER 8
+
+#define E1000_TIPG_IPGT_MASK  0x000003FF
+#define E1000_TIPG_IPGR1_MASK 0x000FFC00
+#define E1000_TIPG_IPGR2_MASK 0x3FF00000
+
+#define DEFAULT_82542_TIPG_IPGR1 2
+#define DEFAULT_82543_TIPG_IPGR1 8
+#define E1000_TIPG_IPGR1_SHIFT  10
+
+#define DEFAULT_82542_TIPG_IPGR2 10
+#define DEFAULT_82543_TIPG_IPGR2 6
+#define E1000_TIPG_IPGR2_SHIFT  20
+
+#define E1000_TXDMAC_DPP 0x00000001
+
+/* PBA constants */
+#define E1000_PBA_16K 0x0010    /* 16KB, default TX allocation */
+#define E1000_PBA_24K 0x0018
+#define E1000_PBA_40K 0x0028
+#define E1000_PBA_48K 0x0030    /* 48KB, default RX allocation */
+
+/* Flow Control Constants */
+#define FLOW_CONTROL_ADDRESS_LOW  0x00C28001
+#define FLOW_CONTROL_ADDRESS_HIGH 0x00000100
+#define FLOW_CONTROL_TYPE         0x8808
+
+/* The historical defaults for the flow control values are given below. */
+#define FC_DEFAULT_HI_THRESH        (0x8000)    /* 32KB */
+#define FC_DEFAULT_LO_THRESH        (0x4000)    /* 16KB */
+#define FC_DEFAULT_TX_TIMER         (0x100)     /* ~130 us */
+
+
+/* The number of bits that we need to shift right to move the "pause"
+ * bits from the EEPROM (bits 13:12) to the "pause" (bits 8:7) field
+ * in the TXCW register 
+ */
+#define PAUSE_SHIFT 5
+
+/* The number of bits that we need to shift left to move the "SWDPIO"
+ * bits from the EEPROM (bits 8:5) to the "SWDPIO" (bits 25:22) field
+ * in the CTRL register 
+ */
+#define SWDPIO_SHIFT 17
+
+/* The number of bits that we need to shift left to move the "SWDPIO_EXT"
+ * bits from the EEPROM word F (bits 7:4) to the bits 11:8 of The
+ * Extended CTRL register.
+ * in the CTRL register 
+ */
+#define SWDPIO__EXT_SHIFT 4
+
+/* The number of bits that we need to shift left to move the "ILOS"
+ * bit from the EEPROM (bit 4) to the "ILOS" (bit 7) field
+ * in the CTRL register 
+ */
+#define ILOS_SHIFT  3
+
+
+#define RECEIVE_BUFFER_ALIGN_SIZE  (256)
+
+/* The number of milliseconds we wait for auto-negotiation to complete */
+#define LINK_UP_TIMEOUT             500
+
+#define E1000_TX_BUFFER_SIZE ((uint32_t)1514)
+
+/* The carrier extension symbol, as received by the NIC. */
+#define CARRIER_EXTENSION   0x0F
+
+/* TBI_ACCEPT macro definition:
+ *
+ * This macro requires:
+ *      adapter = a pointer to struct e1000_shared_adapter 
+ *      status = the 8 bit status field of the RX descriptor with EOP set
+ *      error = the 8 bit error field of the RX descriptor with EOP set
+ *      length = the sum of all the length fields of the RX descriptors that
+ *               make up the current frame
+ *      last_byte = the last byte of the frame DMAed by the hardware
+ *      max_frame_length = the maximum frame length we want to accept.
+ *      min_frame_length = the minimum frame length we want to accept.
+ *
+ * This macro is a conditional that should be used in the interrupt 
+ * handler's Rx processing routine when RxErrors have been detected.
+ *
+ * Typical use:
+ *  ...
+ *  if (TBI_ACCEPT) {
+ *      accept_frame = TRUE;
+ *      e1000_tbi_adjust_stats(adapter, MacAddress);
+ *      frame_length--;
+ *  } else {
+ *      accept_frame = FALSE;
+ *  }
+ *  ...
+ */
+
+#define TBI_ACCEPT(adapter, status, errors, length, last_byte) \
+    ((adapter)->tbi_compatibility_on && \
+     (((errors) & E1000_RXD_ERR_FRAME_ERR_MASK) == E1000_RXD_ERR_CE) && \
+     ((last_byte) == CARRIER_EXTENSION) && \
+     (((status) & E1000_RXD_STAT_VP) ? \
+          (((length) > ((adapter)->min_frame_size - VLAN_TAG_SIZE)) && \
+           ((length) <= ((adapter)->max_frame_size + 1))) : \
+          (((length) > (adapter)->min_frame_size) && \
+           ((length) <= ((adapter)->max_frame_size + VLAN_TAG_SIZE + 1)))))
+
+
+#endif /* _E1000_MAC_H_ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_main.c linux/drivers/net/e1000/e1000_main.c
--- ../prev/linux/drivers/net/e1000/e1000_main.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_main.c	Wed May 29 13:00:02 2002
@@ -0,0 +1,3780 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#define __E1000_MAIN__
+#ifdef IANS
+#define _IANS_MAIN_MODULE_C_
+#endif
+#include "e1000.h"
+
+/* Driver name string */
+char e1000_driver_name[] = "e1000";
+
+/* Driver ID string, displayed when loading */
+char e1000_driver_string[] = "Intel(R) PRO/1000 Network Driver";
+
+/* Driver version */
+char e1000_driver_version[] = "4.1.7";
+
+/* Copyright string, displayed when loading */
+char e1000_copyright[] = "Copyright (c) 1999-2002 Intel Corporation.";
+
+/* Linked list of board private structures for all NICs found */
+struct e1000_adapter *e1000_adapter_list = NULL;
+
+/* e1000_strings - PCI Device ID Table
+ *
+ * for selecting devices to load on
+ * private driver_data field (last one) stores an index
+ * into e1000_strings
+ * Wildcard entries (PCI_ANY_ID) should come last
+ * Last entry must be all 0s
+ *
+ * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,
+ *   Class, Class Mask, String Index }
+ */
+static struct pci_device_id e1000_pci_table[] = {
+    /* Intel(R) PRO/1000 Network Connection */
+    {0x8086, 0x1000, 0x8086, 0x1000, 0, 0, 0},
+    {0x8086, 0x1001, 0x8086, 0x1003, 0, 0, 0},
+    {0x8086, 0x1004, 0x8086, 0x1004, 0, 0, 0},
+    {0x8086, 0x1008, 0x8086, 0x1107, 0, 0, 0},
+    {0x8086, 0x1009, 0x8086, 0x1109, 0, 0, 0},
+    {0x8086, 0x100C, 0x8086, 0x1112, 0, 0, 0},
+    {0x8086, 0x100E, 0x8086, 0x001E, 0, 0, 0},
+    /* Compaq Gigabit Ethernet Server Adapter */
+    {0x8086, 0x1000, 0x0E11, PCI_ANY_ID, 0, 0, 1},
+    {0x8086, 0x1001, 0x0E11, PCI_ANY_ID, 0, 0, 1},
+    {0x8086, 0x1004, 0x0E11, PCI_ANY_ID, 0, 0, 1},
+    /* IBM Mobile, Desktop & Server Adapters */
+    {0x8086, 0x1000, 0x1014, PCI_ANY_ID, 0, 0, 2},
+    {0x8086, 0x1001, 0x1014, PCI_ANY_ID, 0, 0, 2},
+    {0x8086, 0x1004, 0x1014, PCI_ANY_ID, 0, 0, 2},
+    /* Generic */
+    {0x8086, 0x1000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x100C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x100D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x100E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    /* required last entry */
+    {0,}
+};
+
+MODULE_DEVICE_TABLE(pci, e1000_pci_table);
+
+/* e1000_pci_table - Table of branding strings for all supported NICs. */
+
+static char *e1000_strings[] = {
+    "Intel(R) PRO/1000 Network Connection",
+    "Compaq Gigabit Ethernet Server Adapter",
+    "IBM Mobile, Desktop & Server Adapters"
+};
+
+/* PCI driver information (Linux 2.4 driver API) */
+static struct pci_driver e1000_driver = {
+    name:     e1000_driver_name,
+    id_table: e1000_pci_table,
+    probe:    e1000_probe,
+    remove:   e1000_remove,
+    /* Power Managment Hooks */
+    suspend:  NULL,
+    resume:   NULL
+};
+
+/* Module Parameters are always initialized to -1, so that the driver
+ * can tell the difference between no user specified value or the
+ * user asking for the default value.
+ * The true default values are loaded in when e1000_check_options is called.
+ */
+
+/* This is the only thing that needs to be changed to adjust the
+ * maximum number of ports that the driver can manage.
+ */
+
+#define E1000_MAX_NIC 8
+
+/* This is a GCC extension to ANSI C.
+ * See the item "Labeled Elements in Initializers" in the section
+ * "Extensions to the C Language Family" of the GCC documentation.
+ */
+
+#define E1000_OPTION_INIT { [0 ... E1000_MAX_NIC] = OPTION_UNSET }
+
+/* Transmit Descriptor Count
+ *
+ * Valid Range: 80-256 for 82542 and 82543 gigabit ethernet controllers
+ * Valid Range: 80-4096 for 82544
+ *
+ * Default Value: 256
+ */
+
+static int TxDescriptors[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Receive Descriptor Count
+ *
+ * Valid Range: 80-256 for 82542 and 82543 gigabit ethernet controllers
+ * Valid Range: 80-4096 for 82544
+ *
+ * Default Value: 256
+ */
+
+static int RxDescriptors[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* User Specified Speed Override
+ *
+ * Valid Range: 0, 10, 100, 1000
+ *  - 0    - auto-negotiate at all supported speeds
+ *  - 10   - only link at 10 Mbps
+ *  - 100  - only link at 100 Mbps
+ *  - 1000 - only link at 1000 Mbps
+ *
+ * Default Value: 0
+ */
+
+static int Speed[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* User Specified Duplex Override
+ *
+ * Valid Range: 0-2
+ *  - 0 - auto-negotiate for duplex
+ *  - 1 - only link at half duplex
+ *  - 2 - only link at full duplex
+ *
+ * Default Value: 0
+ */
+
+static int Duplex[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Auto-negotiation Advertisement Override
+ *
+ * Valid Range: 0x00-0x0F, 0x20-0x2F
+ *
+ * The AutoNeg value is a bit mask describing which speed and duplex
+ * combinations should be advertised during auto-negotiation.
+ * The supported speed and duplex modes are listed below
+ *
+ * Bit           7     6     5      4      3     2     1      0
+ * Speed (Mbps)  N/A   N/A   1000   N/A    100   100   10     10
+ * Duplex                    Full          Full  Half  Full   Half
+ *
+ * Default Value: 0x2F
+ */
+
+static int AutoNeg[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* User Specified Flow Control Override
+ *
+ * Valid Range: 0-3
+ *  - 0 - No Flow Control
+ *  - 1 - Rx only, respond to PAUSE frames but do not generate them
+ *  - 2 - Tx only, generate PAUSE frames but ignore them on receive
+ *  - 3 - Full Flow Control Support
+ *
+ * Default Value: Read flow control settings from the EEPROM
+ */
+
+static int FlowControl[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* XsumRX - Receive Checksum Offload Enable/Disable
+ *
+ * Valid Range: 0, 1
+ *  - 0 - disables all checksum offload
+ *  - 1 - enables receive IP/TCP/UDP checksum offload
+ *        on 82543 based NICs
+ *
+ * Default Value: 1
+ */
+
+static int XsumRX[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Transmit Interrupt Delay in units of 1.024 microseconds
+ *
+ * Valid Range: 0-65535
+ *
+ * Default Value: 64
+ */
+
+static int TxIntDelay[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Receive Interrupt Delay in units of 1.024 microseconds
+ *
+ * Valid Range: 0-65535
+ *
+ * Default Value: 64
+ */
+
+static int RxIntDelay[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* MDI-X Support Enable/Disable - Applies only to Copper PHY
+ *
+ * Valid Range: 0, 3
+ *  - 0 - Auto in all modes
+ *  - 1 - MDI
+ *  - 2 - MDI-X
+ *  - 3 - Auto in 1000 Base-T mode (MDI in 10 Base-T and 100 Base-T)
+ *
+ * Default Value: 0 (Auto)
+ */
+
+static int MdiX[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Automatic Correction of Reversed Cable Polarity Enable/Disable
+ * This setting applies only to Copper PHY
+ *
+ * Valid Range: 0, 1
+ *  - 0 - Disabled
+ *  - 1 - Enabled
+ *
+ * Default Value: 1 (Enabled)
+ */
+
+static int DisablePolarityCorrection[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+#ifdef MODULE
+
+MODULE_AUTHOR("Intel Corporation, <linux.nics@intel.com>");
+MODULE_DESCRIPTION("Intel(R) PRO/1000 Network Driver");
+
+#if defined(MODULE_LICENSE)
+MODULE_LICENSE("BSD with patent grant");
+#endif
+
+MODULE_PARM(TxDescriptors, "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(RxDescriptors, "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(Speed,         "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(Duplex,        "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(AutoNeg,       "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(XsumRX,        "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(FlowControl,   "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(TxIntDelay,    "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(RxIntDelay,    "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(MdiX,          "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(DisablePolarityCorrection, "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+
+MODULE_PARM_DESC(TxDescriptors, "Number of transmit descriptors");
+MODULE_PARM_DESC(RxDescriptors, "Number of receive descriptors");
+MODULE_PARM_DESC(Speed,         "Speed setting");
+MODULE_PARM_DESC(Duplex,        "Duplex setting");
+MODULE_PARM_DESC(AutoNeg,       "Advertised auto-negotiation setting");
+MODULE_PARM_DESC(XsumRX,        "Disable or enable Receive Checksum offload");
+MODULE_PARM_DESC(FlowControl,   "Flow Control setting");
+MODULE_PARM_DESC(TxIntDelay,    "Transmit Interrupt Delay");
+MODULE_PARM_DESC(RxIntDelay,    "Receive Interrupt Delay");
+MODULE_PARM_DESC(MdiX,          "Set MDI/MDI-X Mode");
+MODULE_PARM_DESC(DisablePolarityCorrection,
+                 "Disable or enable Automatic Correction for Reversed Cable Polarity");
+
+#ifdef EXPORT_SYMTAB
+/*EXPORT_SYMBOL(e1000_init_module);
+EXPORT_SYMBOL(e1000_exit_module);
+EXPORT_SYMBOL(e1000_probe);
+EXPORT_SYMBOL(e1000_remove);
+EXPORT_SYMBOL(e1000_open);
+EXPORT_SYMBOL(e1000_close);
+EXPORT_SYMBOL(e1000_xmit_frame);
+EXPORT_SYMBOL(e1000_intr);
+EXPORT_SYMBOL(e1000_set_multi);
+EXPORT_SYMBOL(e1000_change_mtu);
+EXPORT_SYMBOL(e1000_set_mac);
+EXPORT_SYMBOL(e1000_get_stats);
+EXPORT_SYMBOL(e1000_watchdog);
+EXPORT_SYMBOL(e1000_ioctl);
+EXPORT_SYMBOL(e1000_adapter_list);*/
+#endif
+
+#endif
+
+/* Local Function Prototypes */
+
+static void e1000_check_options(struct e1000_adapter *adapter);
+static void e1000_check_fiber_options(struct e1000_adapter *adapter);
+static void e1000_check_copper_options(struct e1000_adapter *adapter);
+static int e1000_sw_init(struct e1000_adapter *adapter);
+static int e1000_hw_init(struct e1000_adapter *adapter);
+static void e1000_read_address(struct e1000_adapter *adapter,
+                               uint8_t *addr);
+static int e1000_setup_tx_resources(struct e1000_adapter *adapter);
+static int e1000_setup_rx_resources(struct e1000_adapter *adapter);
+static void e1000_setup_rctl(struct e1000_adapter *adapter);
+static void e1000_configure_rx(struct e1000_adapter *adapter);
+static void e1000_configure_tx(struct e1000_adapter *adapter);
+static void e1000_free_tx_resources(struct e1000_adapter *adapter);
+static void e1000_free_rx_resources(struct e1000_adapter *adapter);
+static void e1000_update_stats(struct e1000_adapter *adapter);
+static inline void e1000_irq_disable(struct e1000_adapter *adapter);
+static inline void e1000_irq_enable(struct e1000_adapter *adapter);
+static void e1000_clean_tx_irq(struct e1000_adapter *adapter);
+static void e1000_clean_rx_irq(struct e1000_adapter *adapter);
+static inline void e1000_rx_checksum(struct e1000_adapter *adapter,
+                                     struct e1000_rx_desc *rx_desc,
+                                     struct sk_buff *skb);
+static void e1000_alloc_rx_buffers(unsigned long data);
+static void e1000_clean_tx_ring(struct e1000_adapter *adapter);
+static void e1000_clean_rx_ring(struct e1000_adapter *adapter);
+void e1000_hibernate_adapter(struct net_device *netdev);
+void e1000_wakeup_adapter(struct net_device *netdev);
+static void e1000_enable_WOL(struct e1000_adapter *adapter);
+
+#ifdef SIOCETHTOOL
+static int e1000_ethtool_ioctl(struct net_device *netdev,
+                               struct ifreq *ifr);
+#endif
+#ifdef IDIAG
+static int e1000_check_lbtest_frame(struct sk_buff *skb,
+                                    unsigned int frame_size);
+#endif
+
+/**
+ * e1000_init_module - Driver Registration Routine
+ *
+ * e1000_init_module is the first routine called when the driver is
+ * loaded. All it does is register with the PCI subsystem.
+ **/
+
+int
+e1000_init_module()
+{
+    E1000_DBG("e1000_init_module\n");
+
+    /* Print the driver ID string and copyright notice */
+
+    printk("%s - version %s\n%s\n", e1000_driver_string, e1000_driver_version,
+           e1000_copyright);
+
+    /* register the driver with the PCI subsystem */
+
+    return pci_module_init(&e1000_driver);
+}
+
+/* this macro creates a special symbol in the object file that
+ * identifies the driver initialization routine
+ */
+module_init(e1000_init_module);
+
+/**
+ * e1000_exit_module - Driver Exit Cleanup Routine
+ *
+ * e1000_exit_module is called just before the driver is removed
+ * from memory.
+ **/
+
+void
+e1000_exit_module()
+{
+#ifdef CONFIG_PROC_FS
+    struct proc_dir_entry *de;
+#endif
+
+    E1000_DBG("e1000_exit_module\n");
+
+    pci_unregister_driver(&e1000_driver);
+
+#ifdef CONFIG_PROC_FS
+    /* if there is no e1000_proc_dir (proc creation failure on load)
+     * then we're done
+     */
+    if(e1000_proc_dir == NULL)
+        return;
+
+    /* If ADAPTERS_PROC_DIR (/proc/net/PRO_LAN_Adapters) is empty
+     * it can be removed now (might still be in use by e100)
+     */
+    for(de = e1000_proc_dir->subdir; de; de = de->next) {
+
+        /* ignore . and .. */
+
+        if(*(de->name) == '.')
+            continue;
+        break;
+    }
+    if(de)
+        return;
+    remove_proc_entry(ADAPTERS_PROC_DIR, proc_net);
+#endif
+
+    return;
+}
+
+/* this macro creates a special symbol in the object file that
+ * identifies the driver cleanup routine
+ */
+module_exit(e1000_exit_module);
+
+/**
+ * e1000_probe - Device Initialization Routine
+ * @pdev: PCI device information struct
+ * @ent: entry in e1000_pci_table
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * e1000_probe initializes an adapter identified by a pci_dev
+ * structure.  The OS initialization is handled here, and
+ * e1000_sw_init and e1000_hw_init are called to handle the driver
+ * specific software structures and hardware initialization
+ * respectively.
+ **/
+
+int
+e1000_probe(struct pci_dev *pdev,
+            const struct pci_device_id *ent)
+{
+    struct net_device *netdev = NULL;
+    struct e1000_adapter *adapter;
+    static int cards_found = 0;
+
+#ifdef CONFIG_PROC_FS
+    int len;
+#endif
+
+    E1000_DBG("e1000_probe\n");
+
+    /* Make sure the PCI device has the proper resources available */
+
+    if(pci_enable_device(pdev) != 0) {
+        E1000_ERR("pci_enable_device failed\n");
+        return -ENODEV;
+    }
+
+    /* Make sure we are enabled as a bus mastering device */
+
+    pci_set_master(pdev);
+
+    /* Check to see if our PCI addressing needs are supported */
+    if(pci_set_dma_mask(pdev, E1000_DMA_MASK) < 0) {
+        E1000_ERR("PCI DMA not supported by the system\n");
+        return -ENODEV;
+    }
+
+    /* Allocate private data structure (struct e1000_adapter)
+     */
+    netdev = alloc_etherdev(sizeof(struct e1000_adapter));
+
+    if(netdev == NULL) {
+        E1000_ERR("Unable to allocate net_device struct\n");
+        return -ENOMEM;
+    }
+
+    /* Calling alloc_etherdev with sizeof(struct e1000_adapter) allocates
+     * a single buffer of size net_device + struct e1000_adapter +
+     * alignment. If this is not done then the struct e1000_adapter needs
+     * to be allocated and freed separately.
+     */
+    adapter = (struct e1000_adapter *) netdev->priv;
+    memset(adapter, 0, sizeof(struct e1000_adapter));
+    adapter->netdev = netdev;
+    adapter->pdev = pdev;
+
+    /* link the struct e1000_adapter into the list */
+
+    if(e1000_adapter_list != NULL)
+        e1000_adapter_list->prev = adapter;
+    adapter->next = e1000_adapter_list;
+    e1000_adapter_list = adapter;
+    adapter->shared.back = (void *) adapter;
+
+    /* reserve the MMIO region as ours */
+
+    if(!request_mem_region
+       (pci_resource_start(pdev, BAR_0), pci_resource_len(pdev, BAR_0),
+        e1000_driver_name)) {
+        E1000_ERR("request_mem_region failed\n");
+        e1000_remove(pdev);
+        return -ENODEV;
+    }
+
+    /* map the MMIO region into the kernel virtual address space */
+
+    adapter->shared.hw_addr =
+        ioremap(pci_resource_start(pdev, BAR_0), pci_resource_len(pdev, BAR_0));
+
+    if(adapter->shared.hw_addr == NULL) {
+        E1000_ERR("ioremap failed\n");
+        release_mem_region(pci_resource_start(pdev, BAR_0),
+                           pci_resource_len(pdev, BAR_0));
+        e1000_remove(pdev);
+        return -ENOMEM;
+    }
+
+    /* don't actually register the interrupt handler until e1000_open */
+
+    netdev->irq = pdev->irq;
+
+    /* Set the MMIO base address for the NIC */
+
+#ifdef IANS
+    netdev->base_addr = pci_resource_start(pdev, BAR_0);
+#endif
+    netdev->mem_start = pci_resource_start(pdev, BAR_0);
+    netdev->mem_end = netdev->mem_start + pci_resource_len(pdev, BAR_0);
+
+    /* set up function pointers to driver entry points */
+
+    netdev->open = &e1000_open;
+    netdev->stop = &e1000_close;
+    netdev->hard_start_xmit = &e1000_xmit_frame;
+    netdev->get_stats = &e1000_get_stats;
+    netdev->set_multicast_list = &e1000_set_multi;
+    netdev->set_mac_address = &e1000_set_mac;
+    netdev->change_mtu = &e1000_change_mtu;
+    netdev->do_ioctl = &e1000_ioctl;
+
+    /* set up the struct e1000_adapter */
+
+    adapter->bd_number = cards_found;
+    adapter->id_string = e1000_strings[ent->driver_data];
+    printk("\n%s\n", adapter->id_string);
+
+    /* Order is important here.  e1000_sw_init also identifies the
+     * hardware, so that e1000_check_options can treat command line parameters
+     * differently depending on the hardware.
+     */
+    e1000_sw_init(adapter);
+    e1000_check_options(adapter);
+
+#ifdef MAX_SKB_FRAGS
+    if(adapter->shared.mac_type >= e1000_82543) {
+        netdev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_HIGHDMA;
+    } else {
+        netdev->features = NETIF_F_SG | NETIF_F_HIGHDMA;
+    }
+#endif
+
+#ifdef IANS
+    adapter->iANSdata = kmalloc(sizeof(iANSsupport_t), GFP_KERNEL);
+    if(adapter->iANSdata == NULL) {
+        e1000_remove(pdev);
+        return -ENOMEM;
+    }
+    memset(adapter->iANSdata, 0, sizeof(iANSsupport_t));
+    bd_ans_drv_InitANS(adapter, adapter->iANSdata);
+#endif
+
+    /* finally, we get around to setting up the hardware */
+
+    if(e1000_hw_init(adapter) < 0) {
+        e1000_remove(pdev);
+        return -ENODEV;
+    }
+    cards_found++;
+
+    /* reset stats */
+
+    e1000_clear_hw_cntrs(&adapter->shared);
+    e1000_phy_get_info(&adapter->shared, &adapter->phy_info);
+
+    /* Then register the net device once everything initializes
+     */
+    register_netdev(netdev);
+
+#ifdef CONFIG_PROC_FS
+    /* set up the proc fs entry */
+
+    len = strlen(ADAPTERS_PROC_DIR);
+
+    for(e1000_proc_dir = proc_net->subdir; e1000_proc_dir;
+        e1000_proc_dir = e1000_proc_dir->next) {
+        if((e1000_proc_dir->namelen == len) &&
+           (memcmp(e1000_proc_dir->name, ADAPTERS_PROC_DIR, len) == 0))
+            break;
+    }
+
+    if(e1000_proc_dir == NULL)
+        e1000_proc_dir =
+            create_proc_entry(ADAPTERS_PROC_DIR, S_IFDIR, proc_net);
+
+    if(e1000_proc_dir != NULL)
+        if(e1000_create_proc_dev(adapter) < 0) {
+            e1000_remove_proc_dev(adapter->netdev);
+        }
+#endif
+
+    /* print the link status */
+
+    if(adapter->link_active == 1)
+        printk("%s:  Mem:0x%p  IRQ:%d  Speed:%d Mbps  Duplex:%s\n",
+               netdev->name, (void *) netdev->mem_start, netdev->irq,
+               adapter->link_speed,
+               adapter->link_duplex == FULL_DUPLEX ? "Full" : "Half");
+    else
+        printk("%s:  Mem:0x%p  IRQ:%d  Speed:N/A  Duplex:N/A\n", netdev->name,
+               (void *) netdev->mem_start, netdev->irq);
+
+    return 0;
+}
+
+/**
+ * e1000_remove - Device Removal Routine
+ * @pdev: PCI device information struct
+ *
+ * e1000_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.  The could be caused by a
+ * Hot-Plug event, or because the driver is going to be removed from
+ * memory.
+ *
+ * This routine is also called to clean up from a failure in
+ * e1000_probe.  The Adapter struct and netdev will always exist,
+ * all other pointers must be checked for NULL before freeing.
+ **/
+
+void
+e1000_remove(struct pci_dev *pdev)
+{
+    struct net_device *netdev;
+    struct e1000_adapter *adapter;
+
+    /* find the Adapter struct that matches this PCI device */
+
+    for(adapter = e1000_adapter_list; adapter != NULL; adapter = adapter->next) {
+        if(adapter->pdev == pdev)
+            break;
+    }
+    if(adapter == NULL)
+        return;
+
+    netdev = adapter->netdev;
+
+    /* this must be called before freeing anything,
+     * otherwise there is a case where the open entry point can be
+     * running at the same time as remove. Calling unregister_netdev on an
+     * open interface results in a call to dev_close, which locks
+     * properly against the other netdev entry points, so this takes
+     * care of the hotplug issue of removing an active interface as well.
+     */
+    unregister_netdev(netdev);
+
+    e1000_phy_hw_reset(&adapter->shared);
+
+#ifdef CONFIG_PROC_FS
+    /* remove the proc nodes */
+
+    if(e1000_proc_dir != NULL)
+        e1000_remove_proc_dev(adapter->netdev);
+#endif
+
+    /* remove from the adapter list */
+
+    if(e1000_adapter_list == adapter)
+        e1000_adapter_list = adapter->next;
+    if(adapter->next != NULL)
+        adapter->next->prev = adapter->prev;
+    if(adapter->prev != NULL)
+        adapter->prev->next = adapter->next;
+
+    /* free system resources */
+
+#ifdef IANS
+    if(adapter->iANSdata != NULL)
+        kfree(adapter->iANSdata);
+#endif
+
+    if(adapter->shared.hw_addr != NULL) {
+        iounmap((void *) adapter->shared.hw_addr);
+        release_mem_region(pci_resource_start(pdev, BAR_0),
+                           pci_resource_len(pdev, BAR_0));
+    }
+
+    /* free the net_device _and_ struct e1000_adapter memory */
+
+    kfree(netdev);
+
+    return;
+}
+
+/**
+ * e1000_check_options - Range Checking for Command Line Parameters
+ * @adapter: board private structure
+ *
+ * This routine checks all command line paramters for valid user
+ * input.  If an invalid value is given, or if no user specified
+ * value exists, a default value is used.  The final value is stored
+ * in a variable in the Adapter structure.
+ **/
+
+static void
+e1000_check_options(struct e1000_adapter *adapter)
+{
+    int board = adapter->bd_number;
+
+    if(board >= E1000_MAX_NIC) {
+        printk("Warning: no configuration for board #%i\n", board);
+        printk("Using defaults for all values\n");
+        board = E1000_MAX_NIC;
+    }
+
+    E1000_DBG("e1000_check_options\n");
+
+    /* Transmit Descriptor Count */
+
+    if(TxDescriptors[board] == OPTION_UNSET) {
+        adapter->tx_ring.count = DEFAULT_TXD;
+        TxDescriptors[board] = DEFAULT_TXD;
+    } else
+        if(((TxDescriptors[board] > MAX_TXD) ||
+            (TxDescriptors[board] < MIN_TXD)) &&
+           (adapter->shared.mac_type <= e1000_82543)) {
+        printk("Invalid TxDescriptors specified (%i), using default %i\n",
+               TxDescriptors[board], DEFAULT_TXD);
+        adapter->tx_ring.count = DEFAULT_TXD;
+    } else
+        if(((TxDescriptors[board] > MAX_82544_TXD) ||
+            (TxDescriptors[board] < MIN_TXD)) &&
+           (adapter->shared.mac_type > e1000_82543)) {
+        printk("Invalid TxDescriptors specified (%i), using default %i\n",
+               TxDescriptors[board], DEFAULT_TXD);
+        adapter->tx_ring.count = DEFAULT_TXD;
+    } else {
+        printk("Using specified value of %i TxDescriptors\n",
+               TxDescriptors[board]);
+        adapter->tx_ring.count = TxDescriptors[board];
+    }
+
+    /* tx_ring.count must be a multiple of 8 */
+
+    adapter->tx_ring.count = E1000_ROUNDUP2(adapter->tx_ring.count,
+                                            REQ_TX_DESCRIPTOR_MULTIPLE);
+
+    /* Receive Descriptor Count */
+
+    if(RxDescriptors[board] == OPTION_UNSET) {
+        adapter->rx_ring.count = DEFAULT_RXD;
+        RxDescriptors[board] = DEFAULT_RXD;
+    } else
+        if(((RxDescriptors[board] > MAX_RXD) ||
+            (RxDescriptors[board] < MIN_RXD)) &&
+           (adapter->shared.mac_type <= e1000_82543)) {
+        printk("Invalid RxDescriptors specified (%i), using default %i\n",
+               RxDescriptors[board], DEFAULT_RXD);
+        adapter->rx_ring.count = DEFAULT_RXD;
+    } else
+        if(((RxDescriptors[board] > MAX_82544_RXD) ||
+            (RxDescriptors[board] < MIN_RXD)) &&
+           (adapter->shared.mac_type > e1000_82543)) {
+        printk("Invalid RxDescriptors specified (%i), using default %i\n",
+               RxDescriptors[board], DEFAULT_RXD);
+        adapter->rx_ring.count = DEFAULT_RXD;
+    } else {
+        printk("Using specified value of %i RxDescriptors\n",
+               RxDescriptors[board]);
+        adapter->rx_ring.count = RxDescriptors[board];
+    }
+
+    /* rx_ring.count must be a multiple of 8 */
+
+    adapter->rx_ring.count =
+        E1000_ROUNDUP2(adapter->rx_ring.count, REQ_RX_DESCRIPTOR_MULTIPLE);
+
+    /* Receive Checksum Offload Enable */
+
+    if(XsumRX[board] == OPTION_UNSET) {
+        adapter->RxChecksum = XSUMRX_DEFAULT;
+        XsumRX[board] = XSUMRX_DEFAULT;
+    } else if((XsumRX[board] != OPTION_ENABLED) &&
+              (XsumRX[board] != OPTION_DISABLED)) {
+        printk("Invalid XsumRX specified (%i), using default of %i\n",
+               XsumRX[board], XSUMRX_DEFAULT);
+        adapter->RxChecksum = XSUMRX_DEFAULT;
+    } else {
+        printk("Receive Checksum Offload %s\n",
+               XsumRX[board] == OPTION_ENABLED ? "Enabled" : "Disabled");
+        adapter->RxChecksum = XsumRX[board];
+    }
+
+    /* Flow Control */
+
+    if(FlowControl[board] == OPTION_UNSET) {
+        adapter->shared.fc = e1000_fc_default;
+        FlowControl[board] = e1000_fc_default;
+    } else if((FlowControl[board] > e1000_fc_full) ||
+              (FlowControl[board] < e1000_fc_none)) {
+        printk("Invalid FlowControl specified (%i), "
+               "reading default settings from the EEPROM\n",
+               FlowControl[board]);
+        adapter->shared.fc = e1000_fc_default;
+    } else {
+        adapter->shared.fc = FlowControl[board];
+        switch (adapter->shared.fc) {
+        case e1000_fc_none:
+            printk("Flow Control Disabled\n");
+            break;
+        case e1000_fc_rx_pause:
+            printk("Flow Control Receive Only\n");
+            break;
+        case e1000_fc_tx_pause:
+            printk("Flow Control Transmit Only\n");
+            break;
+        case e1000_fc_full:
+            printk("Flow Control Enabled\n");
+        case e1000_fc_default:
+            printk("Flow Control Hardware Default\n");
+        }
+    }
+
+    /* Transmit Interrupt Delay */
+
+    if(TxIntDelay[board] == OPTION_UNSET) {
+        adapter->tx_int_delay = DEFAULT_TIDV;
+        TxIntDelay[board] = DEFAULT_TIDV;
+    } else if((TxIntDelay[board] > MAX_TIDV) || (TxIntDelay[board] < MIN_TIDV)) {
+        printk("Invalid TxIntDelay specified (%i), using default %i\n",
+               TxIntDelay[board], DEFAULT_TIDV);
+        adapter->tx_int_delay = DEFAULT_TIDV;
+    } else {
+        printk("Using specified TxIntDelay of %i\n", TxIntDelay[board]);
+        adapter->tx_int_delay = TxIntDelay[board];
+    }
+
+    /* Receive Interrupt Delay */
+
+    if(RxIntDelay[board] == OPTION_UNSET) {
+        adapter->rx_int_delay = DEFAULT_RIDV;
+        RxIntDelay[board] = DEFAULT_RIDV;
+    } else if((RxIntDelay[board] > MAX_RIDV) || (RxIntDelay[board] < MIN_RIDV)) {
+        printk("Invalid RxIntDelay specified (%i), using default %i\n",
+               RxIntDelay[board], DEFAULT_RIDV);
+        adapter->rx_int_delay = DEFAULT_RIDV;
+    } else {
+        printk("Using specified RxIntDelay of %i\n", RxIntDelay[board]);
+        adapter->rx_int_delay = RxIntDelay[board];
+    }
+
+    if(adapter->shared.media_type == e1000_media_type_copper) {
+        /* MDI/MDI-X Support */
+
+        if(MdiX[board] == OPTION_UNSET) {
+            adapter->shared.mdix = DEFAULT_MDIX;
+            MdiX[board] = DEFAULT_MDIX;
+        } else if((MdiX[board] > MAX_MDIX) || (MdiX[board] < MIN_MDIX)) {
+            printk("Invalid MDI/MDI-X specified (%i), using default %i\n",
+                   MdiX[board], DEFAULT_MDIX);
+            adapter->shared.mdix = DEFAULT_MDIX;
+        } else {
+            printk("Using specified MDI/MDI-X of %i\n", MdiX[board]);
+            adapter->shared.mdix = MdiX[board];
+        }
+
+        /* Automatic Correction for Reverse Cable Polarity */
+
+        if(DisablePolarityCorrection[board] == OPTION_UNSET) {
+            adapter->shared.disable_polarity_correction = OPTION_DISABLED;
+            DisablePolarityCorrection[board] = OPTION_DISABLED;
+        } else if((DisablePolarityCorrection[board] != OPTION_ENABLED) &&
+                  (DisablePolarityCorrection[board] != OPTION_DISABLED)) {
+            printk("Invalid polarity correction specified (%i),"
+                   "    using default %i\n", DisablePolarityCorrection[board],
+                   OPTION_DISABLED);
+            adapter->shared.disable_polarity_correction = OPTION_DISABLED;
+        } else {
+            printk("Using specified polarity correction of %i\n",
+                   DisablePolarityCorrection[board]);
+            adapter->shared.disable_polarity_correction =
+                DisablePolarityCorrection[board];
+        }
+    }
+
+    /* Speed, Duplex, and AutoNeg */
+
+    switch (adapter->shared.media_type) {
+
+    case e1000_media_type_fiber:
+        e1000_check_fiber_options(adapter);
+        break;
+
+    case e1000_media_type_copper:
+        e1000_check_copper_options(adapter);
+        break;
+
+    default:
+        printk("Unknown Media Type\n");
+        break;
+    }
+
+    return;
+}
+
+/**
+ * e1000_check_fiber_options - Range Checking for Link Options, Fiber Version
+ * @adapter: board private structure
+ *
+ * Handles speed and duplex options on fiber based adapters
+ **/
+
+static void
+e1000_check_fiber_options(struct e1000_adapter *adapter)
+{
+    int board =
+        adapter->bd_number > E1000_MAX_NIC ? E1000_MAX_NIC : adapter->bd_number;
+
+    E1000_DBG("CheckSpeedDuplexFiber\n");
+
+    /* Speed, Duplex, and AutoNeg are not valid on fiber NICs */
+
+    if((Speed[board] != OPTION_UNSET)) {
+        Speed[board] = 0;
+        printk("Warning: Speed not valid for fiber adapters\n");
+        printk("Speed Parameter Ignored\n");
+    }
+    if((Duplex[board] != OPTION_UNSET)) {
+        Duplex[board] = 0;
+        printk("Warning: Duplex not valid for fiber adapters\n");
+        printk("Duplex Parameter Ignored\n");
+    }
+    if((AutoNeg[board] != OPTION_UNSET)) {
+        AutoNeg[board] = AUTONEG_ADV_DEFAULT;
+        printk("Warning: AutoNeg not valid for fiber adapters\n");
+        printk("AutoNeg Parameter Ignored\n");
+    }
+
+    return;
+}
+
+/**
+ * e1000_check_copper_options - Range Checking for Link Options, Copper Version
+ * @adapter: board private structure
+ *
+ * Handles speed and duplex options on copper based adapters
+ **/
+
+static void
+e1000_check_copper_options(struct e1000_adapter *adapter)
+{
+    int board =
+        adapter->bd_number > E1000_MAX_NIC ? E1000_MAX_NIC : adapter->bd_number;
+    int speed, duplex;
+    boolean_t all_default = TRUE;
+
+    E1000_DBG("CheckSpeedDuplexCopper\n");
+
+    /* User Specified Auto-negotiation Settings */
+
+    if(AutoNeg[board] == OPTION_UNSET) {
+
+        adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+        AutoNeg[board] = AUTONEG_ADV_DEFAULT;
+
+    } else if((Speed[board] != 0 && Speed[board] != OPTION_UNSET) ||
+              (Duplex[board] != 0 && Duplex[board] != OPTION_UNSET)) {
+
+        printk("Warning: AutoNeg specified along with Speed or Duplex\n");
+        printk("AutoNeg Parameter Ignored\n");
+
+        adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+
+    } else {
+
+        if(AutoNeg[board] & ~AUTONEG_ADV_MASK) {
+
+            printk("Invalid AutoNeg Specified (0x%X), Parameter Ignored\n",
+                   AutoNeg[board]);
+
+            adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+
+        } else {
+
+            adapter->shared.autoneg_advertised = AutoNeg[board];
+        }
+
+        printk("AutoNeg Advertising ");
+        if(adapter->shared.autoneg_advertised & ADVERTISE_1000_FULL) {
+            printk("1000/FD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_1000_FULL - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_1000_HALF) {
+            printk("1000/HD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_1000_HALF - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_100_FULL) {
+            printk("100/FD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_100_FULL - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_100_HALF) {
+            printk("100/HD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_100_HALF - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_10_FULL) {
+            printk("10/FD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_10_FULL - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_10_HALF)
+            printk("10/HD");
+        printk("\n");
+    }
+
+    /* Forced Speed and Duplex */
+
+    switch (Speed[board]) {
+    default:
+        printk("Invalid Speed Specified (%i), Parameter Ignored\n",
+               Speed[board]);
+        all_default = FALSE;
+    case OPTION_UNSET:
+        speed = 0;
+        Speed[board] = 0;
+        break;
+    case 0:
+    case 10:
+    case 100:
+    case 1000:
+        speed = Speed[board];
+        all_default = FALSE;
+        break;
+    }
+
+    switch (Duplex[board]) {
+    default:
+        printk("Invalid Duplex Specified (%i), Parameter Ignored\n",
+               Duplex[board]);
+        all_default = FALSE;
+    case OPTION_UNSET:
+        duplex = 0;
+        Duplex[board] = 0;
+        break;
+    case 0:
+    case 1:
+    case 2:
+        duplex = Duplex[board];
+        all_default = FALSE;
+        break;
+    }
+
+    switch (speed + duplex) {
+    case 0:
+        if(all_default == FALSE)
+            printk("Speed and Duplex Auto-negotiation Enabled\n");
+        adapter->shared.autoneg = 1;
+        break;
+    case 1:
+        printk("Warning: Half Duplex specified without Speed\n");
+        printk("Using Auto-negotiation at Half Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_10_HALF | ADVERTISE_100_HALF;
+        break;
+    case 2:
+        printk("Warning: Full Duplex specified without Speed\n");
+        printk("Using Auto-negotiation at Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_10_FULL | ADVERTISE_100_FULL | ADVERTISE_1000_FULL;
+        break;
+    case 10:
+        printk("Warning: 10 Mbps Speed specified without Duplex\n");
+        printk("Using Auto-negotiation at 10 Mbps only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_10_HALF | ADVERTISE_10_FULL;
+        break;
+    case 11:
+        printk("Forcing to 10 Mbps Half Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_10_half;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 12:
+        printk("Forcing to 10 Mbps Full Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_10_full;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 100:
+        printk("Warning: 100 Mbps Speed specified without Duplex\n");
+        printk("Using Auto-negotiation at 100 Mbps only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_100_HALF | ADVERTISE_100_FULL;
+        break;
+    case 101:
+        printk("Forcing to 100 Mbps Half Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_100_half;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 102:
+        printk("Forcing to 100 Mbps Full Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_100_full;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 1000:
+        printk("Warning: 1000 Mbps Speed specified without Duplex\n");
+        printk("Using Auto-negotiation at 1000 Mbps Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+        break;
+    case 1001:
+        printk("Warning: Half Duplex is not supported at 1000 Mbps\n");
+        printk("Using Auto-negotiation at 1000 Mbps Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+        break;
+    case 1002:
+        printk("Using Auto-negotiation at 1000 Mbps Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+        break;
+    default:
+        panic("something is wrong in e1000_check_copper_options");
+    }
+
+    /* Speed, AutoNeg and MDI/MDI-X */
+    if (!e1000_validate_mdi_setting(&(adapter->shared))) {
+        printk ("Speed, AutoNeg and MDI-X specifications are incompatible."
+                " Setting MDI-X to a compatible value.\n");
+    }
+
+    return;
+}
+
+/**
+ * e1000_sw_init - Initialize general software structures (struct e1000_adapter)
+ * @adapter: board private structure to initialize
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * e1000_sw_init initializes the Adapter private data structure.
+ * Fields are initialized based on PCI device information and
+ * OS network device settings (MTU size).
+ **/
+
+static int
+e1000_sw_init(struct e1000_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+    uint32_t status;
+
+    E1000_DBG("e1000_sw_init\n");
+
+    /* PCI config space info */
+
+    pci_read_config_word(pdev, PCI_VENDOR_ID, &adapter->vendor_id);
+    pci_read_config_word(pdev, PCI_DEVICE_ID, &adapter->device_id);
+    pci_read_config_byte(pdev, PCI_REVISION_ID, &adapter->rev_id);
+    pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &adapter->subven_id);
+    pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &adapter->subsys_id);
+    pci_read_config_word(pdev, PCI_COMMAND, &adapter->shared.pci_cmd_word);
+    adapter->shared.vendor_id = adapter->vendor_id;
+    adapter->shared.device_id = adapter->device_id;
+    adapter->shared.revision_id = adapter->rev_id;
+    adapter->shared.subsystem_vendor_id = adapter->subven_id;
+    adapter->shared.subsystem_id = adapter->subsys_id;
+
+    /* Initial Receive Buffer Length */
+
+    if((netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH) < E1000_RXBUFFER_2048)
+        adapter->rx_buffer_len = E1000_RXBUFFER_2048;
+    else if((netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH) < E1000_RXBUFFER_4096)
+        adapter->rx_buffer_len = E1000_RXBUFFER_4096;
+    else if((netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH) < E1000_RXBUFFER_8192)
+        adapter->rx_buffer_len = E1000_RXBUFFER_8192;
+    else
+        adapter->rx_buffer_len = E1000_RXBUFFER_16384;
+
+    adapter->shared.max_frame_size =
+        netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH;
+    adapter->shared.min_frame_size = MINIMUM_ETHERNET_PACKET_SIZE + CRC_LENGTH;
+
+    /* MAC and Phy settings */
+
+    switch (adapter->device_id) {
+    case E1000_DEV_ID_82542:
+        switch (adapter->rev_id) {
+        case E1000_82542_2_0_REV_ID:
+            adapter->shared.mac_type = e1000_82542_rev2_0;
+            break;
+        case E1000_82542_2_1_REV_ID:
+            adapter->shared.mac_type = e1000_82542_rev2_1;
+            break;
+        default:
+            adapter->shared.mac_type = e1000_82542_rev2_0;
+            E1000_ERR("Could not identify 82542 revision\n");
+        }
+        break;
+    case E1000_DEV_ID_82543GC_FIBER:
+    case E1000_DEV_ID_82543GC_COPPER:
+        adapter->shared.mac_type = e1000_82543;
+        break;
+    case E1000_DEV_ID_82544EI_COPPER:
+    case E1000_DEV_ID_82544EI_FIBER:
+    case E1000_DEV_ID_82544GC_COPPER:
+    case E1000_DEV_ID_82544GC_LOM:
+        adapter->shared.mac_type = e1000_82544;
+        break;
+    case E1000_DEV_ID_82540EM:
+        adapter->shared.mac_type = e1000_82540;
+        break;
+    default:
+        E1000_ERR("Could not identify hardware\n");
+        return -ENODEV;
+    }
+
+    adapter->shared.fc_high_water = FC_DEFAULT_HI_THRESH;
+    adapter->shared.fc_low_water = FC_DEFAULT_LO_THRESH;
+    adapter->shared.fc_pause_time = FC_DEFAULT_TX_TIMER;
+    adapter->shared.fc_send_xon = 1;
+
+    /* Identify the Hardware - this is done by the gigabit shared code
+     * in e1000_init_hw, but it would help to identify the NIC
+     * before bringing the hardware online for use in e1000_check_options.
+     */
+    if(adapter->shared.mac_type >= e1000_82543) {
+        status = E1000_READ_REG(&adapter->shared, STATUS);
+        if(status & E1000_STATUS_TBIMODE) {
+            adapter->shared.media_type = e1000_media_type_fiber;
+        } else {
+            adapter->shared.media_type = e1000_media_type_copper;
+        }
+    } else {
+        adapter->shared.media_type = e1000_media_type_fiber;
+    }
+
+    if((E1000_REPORT_TX_EARLY == 0) || (E1000_REPORT_TX_EARLY == 1)) {
+        adapter->shared.report_tx_early = E1000_REPORT_TX_EARLY;
+    } else {
+        if(adapter->shared.mac_type < e1000_82543) {
+
+            adapter->shared.report_tx_early = 0;
+        } else {
+            adapter->shared.report_tx_early = 1;
+        }
+    }
+
+    adapter->shared.wait_autoneg_complete = WAITFORLINK_DEFAULT;
+
+    adapter->shared.tbi_compatibility_en = 1;
+
+    atomic_set(&adapter->tx_timeout, 0);
+
+    spin_lock_init(&adapter->stats_lock);
+    spin_lock_init(&adapter->rx_fill_lock);
+
+    return 0;
+}
+
+/**
+ * e1000_hw_init - prepare the hardware
+ * @adapter: board private struct containing configuration
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * Initialize the hardware to a configuration as specified by the
+ * Adapter structure.  The controler is reset, the EEPROM is
+ * verified, the MAC address is set, then the shared initilization
+ * routines are called.
+ **/
+
+static int
+e1000_hw_init(struct e1000_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+
+    E1000_DBG("e1000_hw_init\n");
+
+    /* Repartition Pba for greater than 9k mtu
+     * To take effect Ctrl_Rst is required.
+     */
+    if(adapter->rx_buffer_len > E1000_RXBUFFER_8192)
+        E1000_WRITE_REG(&adapter->shared, PBA, E1000_JUMBO_PBA);
+    else
+        E1000_WRITE_REG(&adapter->shared, PBA, E1000_DEFAULT_PBA);
+
+    /* Issue a global reset */
+
+    adapter->shared.adapter_stopped = 0;
+    e1000_adapter_stop(&adapter->shared);
+    adapter->shared.adapter_stopped = 0;
+
+    /* make sure the EEPROM is good */
+
+    if(!e1000_validate_eeprom_checksum(&adapter->shared)) {
+        E1000_ERR("The EEPROM Checksum Is Not Valid\n");
+        return -1;
+    }
+
+    /* copy the MAC address out of the EEPROM */
+
+    e1000_read_address(adapter, adapter->perm_net_addr);
+    memcpy(netdev->dev_addr, adapter->perm_net_addr, netdev->addr_len);
+    memcpy(adapter->shared.mac_addr, netdev->dev_addr, netdev->addr_len);
+
+    e1000_read_part_num(&adapter->shared, &(adapter->part_num));
+
+    if(!e1000_init_hw(&adapter->shared)) {
+        E1000_ERR("Hardware Initialization Failed\n");
+        return -1;
+    }
+
+    e1000_enable_WOL(adapter);
+
+    adapter->shared.get_link_status = 1;
+    e1000_check_for_link(&adapter->shared);
+
+    if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_LU)
+        adapter->link_active = TRUE;
+    else
+        adapter->link_active = FALSE;
+
+    if(adapter->link_active == TRUE) {
+        e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                   &adapter->link_duplex);
+    } else {
+        adapter->link_speed = 0;
+        adapter->link_duplex = 0;
+    }
+
+    e1000_get_bus_info(&adapter->shared);
+
+    return 0;
+}
+
+/**
+ * e1000_read_address - Reads the MAC address from the EEPROM
+ * @adapter: board private structure
+ * @addr: pointer to an array of bytes
+ **/
+
+static void
+e1000_read_address(struct e1000_adapter *adapter,
+                   uint8_t *addr)
+{
+    uint16_t eeprom_word;
+    int i;
+
+    E1000_DBG("e1000_read_address\n");
+
+    for(i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
+        eeprom_word =
+            e1000_read_eeprom(&adapter->shared,
+                              EEPROM_NODE_ADDRESS_BYTE_0 + (i / 2));
+        addr[i] = (uint8_t) (eeprom_word & 0x00FF);
+        addr[i + 1] = (uint8_t) (eeprom_word >> 8);
+    }
+
+    return;
+}
+
+/**
+ * e1000_open - Called when a network interface is made active
+ * @netdev: network interface device structure
+ *
+ * Returns 0 on success, negative value on failure
+ *
+ * The open entry point is called when a network interface is made
+ * active by the system (IFF_UP).  At this point all resources needed
+ * for transmit and receive operations are allocated, the interrupt
+ * handler is registered with the OS, the watchdog timer is started,
+ * and the stack is notified that the interface is ready.
+ **/
+
+int
+e1000_open(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+
+    E1000_DBG("e1000_open\n");
+
+    /* prevent multiple opens when dealing with iANS */
+
+    if(test_and_set_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+        return -EBUSY;
+    }
+
+    adapter->shared.fc = adapter->shared.original_fc;
+
+    /* e1000_close issues a global reset (e1000_adapter_stop)
+     * so e1000_hw_init must be called again or the hardware
+     * will resume in it's default state
+     */
+    if(e1000_hw_init(adapter) < 0) {
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -EBUSY;
+    }
+#ifdef IANS
+    /* restore VLAN settings */
+    if((IANS_BD_TAGGING_MODE) (ANS_PRIVATE_DATA_FIELD(adapter)->tag_mode) !=
+       IANS_BD_TAGGING_NONE)
+        bd_ans_hw_EnableVLAN(adapter);
+#endif
+
+    adapter->shared.adapter_stopped = 0;
+
+    /* allocate transmit descriptors */
+
+    if(e1000_setup_tx_resources(adapter) != 0) {
+        e1000_adapter_stop(&adapter->shared);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -ENOMEM;
+    }
+    e1000_configure_tx(adapter);
+
+    /* allocate receive descriptors and buffers */
+
+    if(e1000_setup_rx_resources(adapter) != 0) {
+        e1000_adapter_stop(&adapter->shared);
+        e1000_free_tx_resources(adapter);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -ENOMEM;
+    }
+    e1000_setup_rctl(adapter);
+    e1000_configure_rx(adapter);
+
+    /* hook the interrupt */
+
+    if(request_irq(netdev->irq, &e1000_intr,
+                   SA_SHIRQ, e1000_driver_name, netdev) != 0) {
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        e1000_adapter_stop(&adapter->shared);
+        e1000_free_tx_resources(adapter);
+        e1000_free_rx_resources(adapter);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -EBUSY;
+    }
+
+    /* fill Rx ring with sk_buffs */
+
+    tasklet_init(&adapter->rx_fill_tasklet, e1000_alloc_rx_buffers,
+                 (unsigned long) adapter);
+
+    tasklet_schedule(&adapter->rx_fill_tasklet);
+
+    /* Set the watchdog timer for 2 seconds */
+
+    init_timer(&adapter->timer_id);
+    adapter->timer_id.function = &e1000_watchdog;
+    adapter->timer_id.data = (unsigned long) netdev;
+    mod_timer(&adapter->timer_id, (jiffies + 2 * HZ));
+
+    /* stats accumulated while down are dropped
+     * this does not clear the running total
+     */
+
+    e1000_clear_hw_cntrs(&adapter->shared);
+
+    adapter->int_mask = IMS_ENABLE_MASK;
+    e1000_irq_enable(adapter);
+    netif_start_queue(netdev);
+
+#ifdef MODULE
+
+    /* Incrementing the module use count prevents a driver from being
+     * unloaded while an active network interface is using it.
+     */
+    MOD_INC_USE_COUNT;
+
+#endif
+
+    return 0;
+}
+
+/**
+ * e1000_close - Disables a network interface
+ * @netdev: network interface device structure
+ *
+ * Returns 0, this is not allowed to fail
+ *
+ * The close entry point is called when an interface is de-activated
+ * by the OS.  The hardware is still under the drivers control, but
+ * needs to be disabled.  A global MAC reset is issued to stop the
+ * hardware, and all transmit and receive resources are freed.
+ **/
+
+int
+e1000_close(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+
+    E1000_DBG("e1000_close\n");
+
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags))
+        return 0;
+
+    /* Issue a global reset */
+
+    e1000_adapter_stop((&adapter->shared));
+
+    /* Enable receiver unit after Global reset
+     * for WOL, so that receiver can still recive
+     * wake up packet and will not drop it.
+     */
+    if(adapter->shared.mac_type > e1000_82543)
+        E1000_WRITE_REG(&adapter->shared, RCTL, E1000_RCTL_EN);
+
+    /* free OS resources */
+
+    netif_stop_queue(netdev);
+    free_irq(netdev->irq, netdev);
+    del_timer_sync(&adapter->timer_id);
+
+    /* Make sure the tasklet won't be left after ifconfig down */
+
+    /*
+     * Assumption: tasklet is ALREADY enabled, ie, t->count == 0.
+     * Otherwise, tasklet is still left in the tasklet list, and,
+     * tasklet_kill will not be able to return (hang).
+     */
+    tasklet_kill(&adapter->rx_fill_tasklet);
+
+    /* free software resources */
+
+    e1000_free_tx_resources(adapter);
+    e1000_free_rx_resources(adapter);
+
+#ifdef MODULE
+
+    /* decrement the module usage count
+     * so that the driver can be unloaded
+     */
+    MOD_DEC_USE_COUNT;
+
+#endif
+
+    clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+    return 0;
+}
+
+/**
+ * e1000_setup_tx_resources - allocate Tx resources (Descriptors)
+ * @adapter: board private structure
+ *
+ * Return 0 on success, negative on failure
+ *
+ * e1000_setup_tx_resources allocates all software transmit resources
+ * and enabled the Tx unit of the MAC.
+ **/
+
+static int
+e1000_setup_tx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    int size;
+
+    E1000_DBG("e1000_setup_tx_resources\n");
+
+    size = sizeof(struct e1000_buffer) * adapter->tx_ring.count;
+    adapter->tx_ring.buffer_info = kmalloc(size, GFP_KERNEL);
+    if(adapter->tx_ring.buffer_info == NULL) {
+        return -ENOMEM;
+    }
+    memset(adapter->tx_ring.buffer_info, 0, size);
+
+    /* round up to nearest 4K */
+
+    adapter->tx_ring.size = E1000_ROUNDUP2(adapter->tx_ring.count *
+                                           sizeof(struct e1000_tx_desc),
+                                           4096);
+
+    adapter->tx_ring.desc = pci_alloc_consistent(pdev, adapter->tx_ring.size,
+                                                 &adapter->tx_ring.dma);
+    if(adapter->tx_ring.desc == NULL) {
+        kfree(adapter->tx_ring.buffer_info);
+        return -ENOMEM;
+    }
+    memset(adapter->tx_ring.desc, 0, adapter->tx_ring.size);
+
+    atomic_set(&adapter->tx_ring.unused, adapter->tx_ring.count);
+    adapter->tx_ring.next_to_use = 0;
+    adapter->tx_ring.next_to_clean = 0;
+
+    return 0;
+}
+
+/**
+ * e1000_configure_tx - Configure 8254x Transmit Unit after Reset
+ * @adapter: board private structure
+ *
+ * Configure the Tx unit of the MAC after a reset.
+ **/
+
+static void
+e1000_configure_tx(struct e1000_adapter *adapter)
+{
+    uint32_t tctl, tipg;
+
+    /* Setup the Base and Length of the Rx Descriptor Ring */
+    /* tx_ring.dma can be either a 32 or 64 bit value */
+
+#if (BITS_PER_LONG == 32)
+    E1000_WRITE_REG(&adapter->shared, TDBAL, adapter->tx_ring.dma);
+    E1000_WRITE_REG(&adapter->shared, TDBAH, 0);
+#elif ( BITS_PER_LONG == 64)
+    E1000_WRITE_REG(&adapter->shared, TDBAL,
+                    (uint32_t) (adapter->tx_ring.dma & 0x00000000FFFFFFFF));
+    E1000_WRITE_REG(&adapter->shared, TDBAH,
+                    (uint32_t) (adapter->tx_ring.dma >> 32));
+#else
+#error "Unsupported System - does not use 32 or 64 bit pointers!"
+#endif
+
+    E1000_WRITE_REG(&adapter->shared, TDLEN,
+                    adapter->tx_ring.count * sizeof(struct e1000_tx_desc));
+
+    /* Setup the HW Tx Head and Tail descriptor pointers */
+
+    E1000_WRITE_REG(&adapter->shared, TDH, 0);
+    E1000_WRITE_REG(&adapter->shared, TDT, 0);
+
+    /* Set the default values for the Tx Inter Packet Gap timer */
+
+    switch (adapter->shared.mac_type) {
+    case e1000_82543:
+    case e1000_82544:
+    case e1000_82540:
+        if(adapter->shared.media_type == e1000_media_type_fiber)
+            tipg = DEFAULT_82543_TIPG_IPGT_FIBER;
+        else
+            tipg = DEFAULT_82543_TIPG_IPGT_COPPER;
+        tipg |= DEFAULT_82543_TIPG_IPGR1 << E1000_TIPG_IPGR1_SHIFT;
+        tipg |= DEFAULT_82543_TIPG_IPGR2 << E1000_TIPG_IPGR2_SHIFT;
+        break;
+    case e1000_82542_rev2_0:
+    case e1000_82542_rev2_1:
+    default:
+        tipg = DEFAULT_82542_TIPG_IPGT;
+        tipg |= DEFAULT_82542_TIPG_IPGR1 << E1000_TIPG_IPGR1_SHIFT;
+        tipg |= DEFAULT_82542_TIPG_IPGR2 << E1000_TIPG_IPGR2_SHIFT;
+        break;
+    }
+    E1000_WRITE_REG(&adapter->shared, TIPG, tipg);
+
+    /* Set the Tx Interrupt Delay register */
+
+    E1000_WRITE_REG(&adapter->shared, TIDV, adapter->tx_int_delay);
+
+    /* Program the Transmit Control Register */
+
+    tctl =
+        E1000_TCTL_PSP | E1000_TCTL_EN | (E1000_COLLISION_THRESHOLD <<
+                                          E1000_CT_SHIFT);
+    if(adapter->link_duplex == FULL_DUPLEX) {
+        tctl |= E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT;
+    } else {
+        tctl |= E1000_HDX_COLLISION_DISTANCE << E1000_COLD_SHIFT;
+    }
+    E1000_WRITE_REG(&adapter->shared, TCTL, tctl);
+
+#ifdef CONFIG_PPC
+    if(adapter->shared.mac_type >= e1000_82543) {
+        E1000_WRITE_REG(&adapter->shared, TXDCTL, 0x00020000);
+    }
+#endif
+
+    /* Setup Transmit Descriptor Settings for this adapter */
+    adapter->TxdCmd = E1000_TXD_CMD_IFCS;
+
+    if(adapter->tx_int_delay > 0)
+        adapter->TxdCmd |= E1000_TXD_CMD_IDE;
+    if(adapter->shared.report_tx_early == 1)
+        adapter->TxdCmd |= E1000_TXD_CMD_RS;
+    else
+        adapter->TxdCmd |= E1000_TXD_CMD_RPS;
+
+    adapter->ActiveChecksumContext = OFFLOAD_NONE;
+
+    return;
+}
+
+/**
+ * e1000_setup_rx_resources - allocate Rx resources (Descriptors, receive SKBs)
+ * @adapter: board private structure
+ * 
+ * Returns 0 on success, negative on failure
+ *
+ * e1000_setup_rx_resources allocates all software receive resources
+ * and network buffers, and enables the Rx unit of the MAC.
+ **/
+
+static int
+e1000_setup_rx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    int size;
+
+    E1000_DBG("e1000_setup_rx_resources\n");
+
+    size = sizeof(struct e1000_buffer) * adapter->rx_ring.count;
+    adapter->rx_ring.buffer_info = kmalloc(size, GFP_KERNEL);
+    if(adapter->rx_ring.buffer_info == NULL) {
+        return -ENOMEM;
+    }
+    memset(adapter->rx_ring.buffer_info, 0, size);
+
+    /* Round up to nearest 4K */
+
+    adapter->rx_ring.size = E1000_ROUNDUP2(adapter->rx_ring.count *
+                                           sizeof(struct e1000_rx_desc),
+                                           4096);
+
+    adapter->rx_ring.desc = pci_alloc_consistent(pdev, adapter->rx_ring.size, 
+                                                 &adapter->rx_ring.dma);
+
+    if(adapter->rx_ring.desc == NULL) {
+        kfree(adapter->rx_ring.buffer_info);
+        return -ENOMEM;
+    }
+    memset(adapter->rx_ring.desc, 0, adapter->rx_ring.size);
+
+    adapter->rx_ring.next_to_clean = 0;
+    atomic_set(&adapter->rx_ring.unused, adapter->rx_ring.count);
+
+    adapter->rx_ring.next_to_use = 0;
+
+    return 0;
+}
+
+/**
+ * e1000_setup_rctl - configure the receive control register
+ * @adapter: Board private structure
+ **/
+
+static void
+e1000_setup_rctl(struct e1000_adapter *adapter)
+{
+    uint32_t rctl;
+
+    /* Setup the Receive Control Register */
+    rctl =
+        E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_LBM_NO |
+        E1000_RCTL_RDMTS_HALF | (adapter->shared.
+                                 mc_filter_type << E1000_RCTL_MO_SHIFT);
+
+    if(adapter->shared.tbi_compatibility_on == 1)
+        rctl |= E1000_RCTL_SBP;
+
+    switch (adapter->rx_buffer_len) {
+    case E1000_RXBUFFER_2048:
+    default:
+        rctl |= E1000_RCTL_SZ_2048;
+        break;
+    case E1000_RXBUFFER_4096:
+        rctl |= E1000_RCTL_SZ_4096 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
+        break;
+    case E1000_RXBUFFER_8192:
+        rctl |= E1000_RCTL_SZ_8192 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
+        break;
+    case E1000_RXBUFFER_16384:
+        rctl |= E1000_RCTL_SZ_16384 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
+        break;
+    }
+
+    E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+}
+
+/**
+ * e1000_configure_rx - Configure 8254x Receive Unit after Reset
+ * @adapter: board private structure
+ *
+ * Configure the Rx unit of the MAC after a reset.
+ **/
+
+static void
+e1000_configure_rx(struct e1000_adapter *adapter)
+{
+    uint32_t rctl;
+    uint32_t rxcsum;
+
+    /* make sure receives are disabled while setting up the descriptor ring */
+    rctl = E1000_READ_REG(&adapter->shared, RCTL);
+    E1000_WRITE_REG(&adapter->shared, RCTL, rctl & ~E1000_RCTL_EN);
+
+    /* set the Receive Delay Timer Register */
+    E1000_WRITE_REG(&adapter->shared, RDTR,
+                    adapter->rx_int_delay | E1000_RDT_FPDB);
+
+    /* Setup the Base and Length of the Rx Descriptor Ring */
+    /* rx_ring.dma can be either a 32 or 64 bit value */
+
+#if (BITS_PER_LONG == 32)
+    E1000_WRITE_REG(&adapter->shared, RDBAL, adapter->rx_ring.dma);
+    E1000_WRITE_REG(&adapter->shared, RDBAH, 0);
+#elif ( BITS_PER_LONG == 64)
+    E1000_WRITE_REG(&adapter->shared, RDBAL,
+                    (uint32_t) (adapter->rx_ring.dma & 0x00000000FFFFFFFF));
+    E1000_WRITE_REG(&adapter->shared, RDBAH,
+                    (uint32_t) (adapter->rx_ring.dma >> 32));
+#else
+#error "Unsupported System - does not use 32 or 64 bit pointers!"
+#endif
+
+    E1000_WRITE_REG(&adapter->shared, RDLEN,
+                    adapter->rx_ring.count * sizeof(struct e1000_rx_desc));
+
+    /* Setup the HW Rx Head and Tail Descriptor Pointers */
+    E1000_WRITE_REG(&adapter->shared, RDH, 0);
+    E1000_WRITE_REG(&adapter->shared, RDT, 0);
+
+    /* Enable 82543 Receive Checksum Offload for TCP and UDP */
+    if((adapter->shared.mac_type >= e1000_82543) &&
+       (adapter->RxChecksum == TRUE)) {
+        rxcsum = E1000_READ_REG(&adapter->shared, RXCSUM);
+        rxcsum |= E1000_RXCSUM_TUOFL;
+        E1000_WRITE_REG(&adapter->shared, RXCSUM, rxcsum);
+    }
+#ifdef CONFIG_PPC
+    if(adapter->shared.mac_type >= e1000_82543) {
+        E1000_WRITE_REG(&adapter->shared, RXDCTL, 0x00020000);
+    }
+#endif
+
+    /* Enable Receives */
+    E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+
+    return;
+}
+
+/**
+ * e1000_free_tx_resources - Free Tx Resources
+ * @adapter: board private structure
+ *
+ * Free all transmit software resources
+ **/
+
+static void
+e1000_free_tx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+
+    E1000_DBG("e1000_free_tx_resources\n");
+
+    e1000_clean_tx_ring(adapter);
+
+    kfree(adapter->tx_ring.buffer_info);
+    adapter->tx_ring.buffer_info = NULL;
+
+    pci_free_consistent(pdev, adapter->tx_ring.size, adapter->tx_ring.desc,
+                        adapter->tx_ring.dma);
+
+    adapter->tx_ring.desc = NULL;
+
+    return;
+}
+
+/**
+ * e1000_clean_tx_ring - Free Tx Buffers
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_tx_ring(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    unsigned long size;
+    int i;
+
+    /* Free all the Tx ring sk_buffs */
+
+    for(i = 0; i < adapter->tx_ring.count; i++) {
+        if(adapter->tx_ring.buffer_info[i].skb != NULL) {
+
+            pci_unmap_page(pdev, adapter->tx_ring.buffer_info[i].dma,
+                           adapter->tx_ring.buffer_info[i].length,
+                           PCI_DMA_TODEVICE);
+
+            dev_kfree_skb(adapter->tx_ring.buffer_info[i].skb);
+
+            adapter->tx_ring.buffer_info[i].skb = NULL;
+        }
+    }
+
+    size = sizeof(struct e1000_buffer) * adapter->tx_ring.count;
+    memset(adapter->tx_ring.buffer_info, 0, size);
+
+    /* Zero out the descriptor ring */
+
+    memset(adapter->tx_ring.desc, 0, adapter->tx_ring.size);
+
+    atomic_set(&adapter->tx_ring.unused, adapter->tx_ring.count);
+    adapter->tx_ring.next_to_use = 0;
+    adapter->tx_ring.next_to_clean = 0;
+
+    return;
+}
+
+/**
+ * e1000_free_rx_resources - Free Rx Resources
+ * @adapter: board private structure
+ *
+ * Free all receive software resources
+ **/
+
+static void
+e1000_free_rx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+
+    E1000_DBG("e1000_free_rx_resources\n");
+
+    tasklet_disable(&adapter->rx_fill_tasklet);
+
+    e1000_clean_rx_ring(adapter);
+
+    kfree(adapter->rx_ring.buffer_info);
+    adapter->rx_ring.buffer_info = NULL;
+
+    pci_free_consistent(pdev, adapter->rx_ring.size, adapter->rx_ring.desc,
+                        adapter->rx_ring.dma);
+
+    adapter->rx_ring.desc = NULL;
+
+    return;
+}
+
+/**
+ * e1000_clean_rx_ring - Free Rx Buffers
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_rx_ring(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    unsigned long size;
+    int i;
+
+    /* Free all the Rx ring sk_buffs */
+
+    for(i = 0; i < adapter->rx_ring.count; i++) {
+        if(adapter->rx_ring.buffer_info[i].skb != NULL) {
+
+            pci_unmap_single(pdev, adapter->rx_ring.buffer_info[i].dma,
+                             adapter->rx_ring.buffer_info[i].length,
+                             PCI_DMA_FROMDEVICE);
+
+            dev_kfree_skb(adapter->rx_ring.buffer_info[i].skb);
+
+            adapter->rx_ring.buffer_info[i].skb = NULL;
+        }
+    }
+
+    size = sizeof(struct e1000_buffer) * adapter->rx_ring.count;
+    memset(adapter->rx_ring.buffer_info, 0, size);
+
+    /* Zero out the descriptor ring */
+
+    memset(adapter->rx_ring.desc, 0, adapter->rx_ring.size);
+
+    atomic_set(&adapter->rx_ring.unused, adapter->rx_ring.count);
+    adapter->rx_ring.next_to_clean = 0;
+    adapter->rx_ring.next_to_use = 0;
+
+    return;
+}
+
+/**
+ * e1000_set_multi - Multicast and Promiscuous mode set
+ * @netdev: network interface device structure
+ *
+ * The set_multi entry point is called whenever the multicast address
+ * list or the network interface flags are updated.  This routine is
+ * resposible for configuring the hardware for proper multicast,
+ * promiscuous mode, and all-multi behavior.
+ **/
+
+void
+e1000_set_multi(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    struct pci_dev *pdev = adapter->pdev;
+    uint32_t rctl;
+    uint8_t mta[MAX_NUM_MULTICAST_ADDRESSES * ETH_LENGTH_OF_ADDRESS];
+    uint16_t pci_command_word;
+    struct dev_mc_list *mc_ptr;
+    int i;
+
+    E1000_DBG("e1000_set_multi\n");
+
+    rctl = E1000_READ_REG(&adapter->shared, RCTL);
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_command_word =
+                adapter->shared.pci_cmd_word & ~PCI_COMMAND_INVALIDATE;
+            pci_write_config_word(pdev, PCI_COMMAND, pci_command_word);
+        }
+        rctl |= E1000_RCTL_RST;
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        mdelay(5);
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            tasklet_disable(&adapter->rx_fill_tasklet);
+            e1000_clean_rx_ring(adapter);
+        }
+    }
+
+    /* Check for Promiscuous and All Multicast modes */
+
+    if(netdev->flags & IFF_PROMISC) {
+        rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
+    } else if(netdev->flags & IFF_ALLMULTI) {
+        rctl |= E1000_RCTL_MPE;
+        rctl &= ~E1000_RCTL_UPE;
+    } else {
+        rctl &= ~(E1000_RCTL_UPE | E1000_RCTL_MPE);
+    }
+
+    if(netdev->mc_count > MAX_NUM_MULTICAST_ADDRESSES) {
+        rctl |= E1000_RCTL_MPE;
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+    } else {
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        for(i = 0, mc_ptr = netdev->mc_list; mc_ptr; i++, mc_ptr = mc_ptr->next)
+            memcpy(&mta[i * ETH_LENGTH_OF_ADDRESS], mc_ptr->dmi_addr,
+                   ETH_LENGTH_OF_ADDRESS);
+        e1000_mc_addr_list_update(&adapter->shared, mta, netdev->mc_count, 0);
+    }
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        rctl = E1000_READ_REG(&adapter->shared, RCTL);
+        rctl &= ~E1000_RCTL_RST;
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        mdelay(5);
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_write_config_word(pdev, PCI_COMMAND,
+                                  adapter->shared.pci_cmd_word);
+        }
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            e1000_configure_rx(adapter);
+            tasklet_enable(&adapter->rx_fill_tasklet);
+        }
+    }
+
+    return;
+}
+
+#ifdef IANS
+
+/* flush Tx queue without link */
+static void
+e1000_tx_flush(struct e1000_adapter *adapter)
+{
+    uint32_t ctrl, txcw, icr;
+
+    adapter->int_mask = 0;
+    e1000_irq_disable(adapter);
+    synchronize_irq();
+
+    if(adapter->shared.mac_type < e1000_82543) {
+        /* Transmit Unit Reset */
+        E1000_WRITE_REG(&adapter->shared, TCTL, E1000_TCTL_RST);
+        E1000_WRITE_REG(&adapter->shared, TCTL, 0);
+        e1000_clean_tx_ring(adapter);
+        e1000_configure_tx(adapter);
+    } else {
+        /* turn off autoneg, set link up, and invert loss of signal */
+        txcw = E1000_READ_REG(&adapter->shared, TXCW);
+        ctrl = E1000_READ_REG(&adapter->shared, CTRL);
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw & ~E1000_TXCW_ANE);
+        E1000_WRITE_REG(&adapter->shared, CTRL,
+                        (ctrl | E1000_CTRL_SLU | E1000_CTRL_ILOS));
+        /* delay to flush queue, then clean up */
+        mdelay(20);
+        e1000_clean_tx_irq(adapter);
+        E1000_WRITE_REG(&adapter->shared, CTRL, ctrl);
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw);
+        /* clear the link status change interrupts this caused */
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+    }
+
+    adapter->int_mask = IMS_ENABLE_MASK;
+    e1000_irq_enable(adapter);
+    return;
+}
+#endif
+
+/**
+ * e1000_watchdog - Timer Call-back
+ * @data: pointer to netdev cast into an unsigned long
+ **/
+
+void
+e1000_watchdog(unsigned long data)
+{
+    struct net_device *netdev = (struct net_device *) data;
+    struct e1000_adapter *adapter = netdev->priv;
+
+#ifdef IANS
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+    int flags;
+#endif
+#endif
+
+    e1000_check_for_link(&adapter->shared);
+
+    if (test_and_clear_bit(E1000_LINK_STATUS_CHANGED, &adapter->flags))
+        e1000_phy_get_info(&adapter->shared, &adapter->phy_info);
+
+    if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_LU) {
+        if(adapter->link_active != TRUE) {
+
+#ifdef IANS
+            if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+               (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+                if(ans_notify)
+                    ans_notify(netdev, IANS_IND_XMIT_QUEUE_READY);
+#endif
+            netif_wake_queue(netdev);
+
+            e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                       &adapter->link_duplex);
+            printk(KERN_ERR "e1000: %s NIC Link is Up %d Mbps %s\n",
+                   netdev->name, adapter->link_speed,
+                   adapter->link_duplex ==
+                   FULL_DUPLEX ? "Full Duplex" : "Half Duplex");
+
+            adapter->link_active = TRUE;
+            set_bit(E1000_LINK_STATUS_CHANGED, &adapter->flags);
+        }
+    } else {
+        if(adapter->link_active != FALSE) {
+            adapter->link_speed = 0;
+            adapter->link_duplex = 0;
+            printk(KERN_ERR "e1000: %s NIC Link is Down\n", netdev->name);
+            adapter->link_active = FALSE;
+            atomic_set(&adapter->tx_timeout, 0);
+        }
+    }
+
+    e1000_update_stats(adapter);
+
+    if(atomic_read(&adapter->tx_timeout) > 1)
+        atomic_dec(&adapter->tx_timeout);
+
+    if((adapter->link_active == TRUE) && 
+       (atomic_read(&adapter->tx_timeout) == 1)) {
+
+        if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_TXOFF) {
+            atomic_set(&adapter->tx_timeout, 3);
+        } else {
+
+            e1000_hibernate_adapter(netdev);
+
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON)) {
+                adapter->link_active = FALSE;
+                bd_ans_os_Watchdog(netdev, adapter);
+                adapter->link_active = TRUE;
+            }
+#endif
+            atomic_set(&adapter->tx_timeout, 0);
+            e1000_wakeup_adapter(netdev);
+        }
+    }
+#ifdef IANS
+    if(adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
+
+        if(adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON)
+            bd_ans_os_Watchdog(netdev, adapter);
+
+        if(adapter->link_active == FALSE) {
+            /* don't sit on SKBs while link is down */
+
+            if(atomic_read(&adapter->tx_ring.unused) < adapter->tx_ring.count) {
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+                spin_lock_irqsave(&netdev->xmit_lock, flags);
+                e1000_tx_flush(adapter);
+                spin_unlock_irqrestore(&netdev->xmit_lock, flags);
+#else
+                e1000_tx_flush(adapter);
+#endif
+            }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+            spin_lock_irqsave(&netdev->queue_lock, flags);
+            qdisc_reset(netdev->qdisc);
+            spin_unlock_irqrestore(&netdev->queue_lock, flags);
+#else
+            qdisc_reset(netdev->qdisc);
+#endif
+        }
+    }
+#endif
+
+    if(test_bit(E1000_RX_REFILL, &adapter->flags)) {
+        tasklet_schedule(&adapter->rx_fill_tasklet);
+    }
+
+    /* Reset the timer */
+    mod_timer(&adapter->timer_id, jiffies + 2 * HZ);
+
+    return;
+}
+
+/**
+ * e1000_tx_checksum_setup
+ * @adapter:
+ * @skb:
+ * @txd_upper:
+ * @txd_lower:
+ **/
+
+static inline void
+e1000_tx_checksum_setup(struct e1000_adapter *adapter,
+                        struct sk_buff *skb,
+                        uint32_t *txd_upper,
+                        uint32_t *txd_lower)
+{
+
+    struct e1000_context_desc *desc;
+    int i;
+
+    if(skb->protocol != __constant_htons(ETH_P_IP)) {
+        *txd_upper = 0;
+        *txd_lower = adapter->TxdCmd;
+        return;
+    }
+
+    switch (skb->nh.iph->protocol) {
+    case IPPROTO_TCP:
+        /* Offload TCP checksum */
+        *txd_upper = E1000_TXD_POPTS_TXSM << 8;
+        *txd_lower = adapter->TxdCmd | E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
+        if(adapter->ActiveChecksumContext == OFFLOAD_TCP_IP)
+            return;
+        else
+            adapter->ActiveChecksumContext = OFFLOAD_TCP_IP;
+        break;
+    case IPPROTO_UDP:
+        /* Offload UDP checksum */
+        *txd_upper = E1000_TXD_POPTS_TXSM << 8;
+        *txd_lower = adapter->TxdCmd | E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
+        if(adapter->ActiveChecksumContext == OFFLOAD_UDP_IP)
+            return;
+        else
+            adapter->ActiveChecksumContext = OFFLOAD_UDP_IP;
+        break;
+    default:
+        /* no checksum to offload */
+        *txd_upper = 0;
+        *txd_lower = adapter->TxdCmd;
+        return;
+    }
+
+    /* If we reach this point, the checksum offload context
+     * needs to be reset
+     */
+
+    i = adapter->tx_ring.next_to_use;
+    desc = E1000_CONTEXT_DESC(adapter->tx_ring, i);
+
+    desc->lower_setup.ip_fields.ipcss = skb->nh.raw - skb->data;
+    desc->lower_setup.ip_fields.ipcso =
+        ((skb->nh.raw + offsetof(struct iphdr, check)) - skb->data);
+    desc->lower_setup.ip_fields.ipcse = cpu_to_le16(skb->h.raw - skb->data - 1);
+
+    desc->upper_setup.tcp_fields.tucss = (skb->h.raw - skb->data);
+    desc->upper_setup.tcp_fields.tucso = ((skb->h.raw + skb->csum) - skb->data);
+    desc->upper_setup.tcp_fields.tucse = 0;
+
+    desc->tcp_seg_setup.data = 0;
+    desc->cmd_and_length = cpu_to_le32(E1000_TXD_CMD_DEXT) | adapter->TxdCmd;
+
+    i = (i + 1) % adapter->tx_ring.count;
+    atomic_dec(&adapter->tx_ring.unused);
+    adapter->tx_ring.next_to_use = i;
+    E1000_WRITE_REG(&adapter->shared, TDT, adapter->tx_ring.next_to_use);
+    return;
+}
+
+/**
+ * e1000_xmit_frame - Transmit entry point
+ * @skb: buffer with frame data to transmit
+ * @netdev: network interface device structure
+ *
+ * Returns 0 on success, negative on error
+ *
+ * e1000_xmit_frame is called by the stack to initiate a transmit.
+ * The out of resource condition is checked after each successful Tx
+ * so that the stack can be notified, preventing the driver from
+ * ever needing to drop a frame.  The atomic operations on
+ * tx_ring.unused are used to syncronize with the transmit
+ * interrupt processing code without the need for a spinlock.
+ **/
+
+int
+e1000_xmit_frame(struct sk_buff *skb,
+                 struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_tx_desc *tx_desc;
+    int i, len, offset, txd_needed;
+    uint32_t txd_upper, txd_lower;
+
+#define TXD_USE_COUNT(x) (((x) >> 12) + ((x) & 0x0fff ? 1 : 0))
+
+#ifdef MAX_SKB_FRAGS
+    int f;
+    skb_frag_t *frag;
+#endif
+
+    E1000_DBG("e1000_xmit_frame\n");
+
+    if(adapter->link_active == FALSE) {
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+            if(ans_notify)
+                ans_notify(netdev, IANS_IND_XMIT_QUEUE_FULL);
+#endif
+        netif_stop_queue(netdev);
+        return 1;
+    }
+
+#ifdef MAX_SKB_FRAGS
+    txd_needed = TXD_USE_COUNT(skb->len - skb->data_len);
+    for(f = 0; f < skb_shinfo(skb)->nr_frags; f++) {
+        frag = &skb_shinfo(skb)->frags[f];
+        txd_needed += TXD_USE_COUNT(frag->size);
+    }
+#else
+    txd_needed = TXD_USE_COUNT(skb->len);
+#endif
+
+    /* make sure there are enough Tx descriptors available in the ring */
+    if(atomic_read(&adapter->tx_ring.unused) <= (txd_needed + 1)) {
+        adapter->net_stats.tx_dropped++;
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+            if(ans_notify)
+                ans_notify(netdev, IANS_IND_XMIT_QUEUE_FULL);
+#endif
+        netif_stop_queue(netdev);
+
+        return 1;
+    }
+
+    if(skb->ip_summed == CHECKSUM_HW) {
+        e1000_tx_checksum_setup(adapter, skb, &txd_upper, &txd_lower);
+    } else {
+        txd_upper = 0;
+        txd_lower = adapter->TxdCmd;
+    }
+
+    i = adapter->tx_ring.next_to_use;
+    tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+#ifdef IANS
+    if(adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
+        tx_desc->lower.data = cpu_to_le32(txd_lower);
+        tx_desc->upper.data = cpu_to_le32(txd_upper);
+        if(bd_ans_os_Transmit(adapter, tx_desc, &skb) == BD_ANS_FAILURE) {
+            return 1;
+        }
+        txd_lower = le32_to_cpu(tx_desc->lower.data);
+        txd_upper = le32_to_cpu(tx_desc->upper.data);
+    }
+#endif
+
+#ifdef MAX_SKB_FRAGS
+    len = skb->len - skb->data_len;
+#else
+    len = skb->len;
+#endif
+    offset = 0;
+
+    while(len > 4096) {
+        adapter->tx_ring.buffer_info[i].length = 4096;
+        adapter->tx_ring.buffer_info[i].dma =
+            pci_map_page(pdev, virt_to_page(skb->data + offset),
+                         (unsigned long) (skb->data + offset) & ~PAGE_MASK,
+                         4096, PCI_DMA_TODEVICE);
+
+        tx_desc->buffer_addr = cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+        tx_desc->lower.data = cpu_to_le32(txd_lower | 4096);
+        tx_desc->upper.data = cpu_to_le32(txd_upper);
+
+        len -= 4096;
+        offset += 4096;
+        i = (i + 1) % adapter->tx_ring.count;
+        atomic_dec(&adapter->tx_ring.unused);
+        tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+    }
+    adapter->tx_ring.buffer_info[i].length = len;
+    adapter->tx_ring.buffer_info[i].dma =
+        pci_map_page(pdev, virt_to_page(skb->data + offset),
+                     (unsigned long) (skb->data + offset) & ~PAGE_MASK, len,
+                     PCI_DMA_TODEVICE);
+
+    tx_desc->buffer_addr = cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+    tx_desc->lower.data = cpu_to_le32(txd_lower | len);
+    tx_desc->upper.data = cpu_to_le32(txd_upper);
+
+#ifdef MAX_SKB_FRAGS
+    for(f = 0; f < skb_shinfo(skb)->nr_frags; f++) {
+        frag = &skb_shinfo(skb)->frags[f];
+        i = (i + 1) % adapter->tx_ring.count;
+        atomic_dec(&adapter->tx_ring.unused);
+        tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+        len = frag->size;
+        offset = 0;
+
+        while(len > 4096) {
+            adapter->tx_ring.buffer_info[i].length = 4096;
+            adapter->tx_ring.buffer_info[i].dma =
+                pci_map_page(pdev, frag->page, frag->page_offset + offset,
+                             4096, PCI_DMA_TODEVICE);
+
+            tx_desc->buffer_addr =
+                cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+            tx_desc->lower.data = cpu_to_le32(txd_lower | 4096);
+            tx_desc->upper.data = cpu_to_le32(txd_upper);
+
+            len -= 4096;
+            offset += 4096;
+            i = (i + 1) % adapter->tx_ring.count;
+            atomic_dec(&adapter->tx_ring.unused);
+            tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+        }
+        adapter->tx_ring.buffer_info[i].length = len;
+        adapter->tx_ring.buffer_info[i].dma =
+            pci_map_page(pdev, frag->page, frag->page_offset + offset, len,
+                         PCI_DMA_TODEVICE);
+        tx_desc->buffer_addr =
+            cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+
+        tx_desc->lower.data = cpu_to_le32(txd_lower | len);
+        tx_desc->upper.data = cpu_to_le32(txd_upper);
+    }
+#endif
+    
+    /* EOP and SKB pointer go with the last fragment */
+    tx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP);
+    adapter->tx_ring.buffer_info[i].skb = skb;
+
+    i = (i + 1) % adapter->tx_ring.count;
+    atomic_dec(&adapter->tx_ring.unused);
+
+    /* Move the HW Tx Tail Pointer */
+    adapter->tx_ring.next_to_use = i;
+
+    E1000_WRITE_REG(&adapter->shared, TDT, adapter->tx_ring.next_to_use);
+
+    if(atomic_read(&adapter->tx_timeout) == 0)
+        atomic_set(&adapter->tx_timeout, 3);
+
+    netdev->trans_start = jiffies;
+
+    return 0;
+}
+
+/**
+ * e1000_get_stats - Get System Network Statistics
+ * @netdev: network interface device structure
+ *
+ * Returns the address of the device statistics structure.
+ * The statistics are actually updated from the timer callback.
+ **/
+
+struct net_device_stats *
+e1000_get_stats(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+
+    E1000_DBG("e1000_get_stats\n");
+
+    return &adapter->net_stats;
+}
+
+/**
+ * e1000_change_mtu - Change the Maximum Transfer Unit
+ * @netdev: network interface device structure
+ * @new_mtu: new value for maximum frame size
+ *
+ * Returns 0 on success, negative on failure
+ **/
+
+int
+e1000_change_mtu(struct net_device *netdev,
+                 int new_mtu)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t old_mtu = adapter->rx_buffer_len;
+
+    E1000_DBG("e1000_change_mtu\n");
+    if((new_mtu < MINIMUM_ETHERNET_PACKET_SIZE - ENET_HEADER_SIZE) ||
+       (new_mtu > MAX_JUMBO_FRAME_SIZE - ENET_HEADER_SIZE)) {
+        E1000_ERR("Invalid MTU setting\n");
+        return -EINVAL;
+    }
+
+    if(new_mtu <= MAXIMUM_ETHERNET_PACKET_SIZE - ENET_HEADER_SIZE) {
+        /* 2k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_2048;
+
+    } else if(adapter->shared.mac_type < e1000_82543) {
+        E1000_ERR("Jumbo Frames not supported on 82542\n");
+        return -EINVAL;
+
+    } else if(new_mtu <= E1000_RXBUFFER_4096 - ENET_HEADER_SIZE - CRC_LENGTH) {
+        /* 4k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_4096;
+
+    } else if(new_mtu <= E1000_RXBUFFER_8192 - ENET_HEADER_SIZE - CRC_LENGTH) {
+        /* 8k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_8192;
+
+    } else {
+        /* 16k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_16384;
+    }
+
+    if(old_mtu != adapter->rx_buffer_len &&
+       test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+
+        /* stop */
+        tasklet_disable(&adapter->rx_fill_tasklet);
+        netif_stop_queue(netdev);
+        adapter->shared.adapter_stopped = 0;
+        e1000_adapter_stop(&adapter->shared);
+
+        /* clean out old buffers */
+        e1000_clean_rx_ring(adapter);
+        e1000_clean_tx_ring(adapter);
+
+        /* reset hardware */
+        adapter->shared.adapter_stopped = 0;
+        e1000_hw_init(adapter);
+
+        /* go */
+        e1000_setup_rctl(adapter);
+        e1000_configure_rx(adapter);
+        e1000_configure_tx(adapter);
+#ifdef IANS
+        /* restore VLAN settings */
+        if((IANS_BD_TAGGING_MODE) (ANS_PRIVATE_DATA_FIELD(adapter)->tag_mode)
+           != IANS_BD_TAGGING_NONE)
+            bd_ans_hw_EnableVLAN(adapter);
+#endif
+        tasklet_enable(&adapter->rx_fill_tasklet);
+        tasklet_schedule(&adapter->rx_fill_tasklet);
+        e1000_irq_enable(adapter);
+        netif_start_queue(netdev);
+    }
+
+    netdev->mtu = new_mtu;
+    adapter->shared.max_frame_size = new_mtu + ENET_HEADER_SIZE + CRC_LENGTH;
+
+    return 0;
+}
+
+/**
+ * e1000_set_mac - Change the Ethernet Address of the NIC
+ * @netdev: network interface device structure
+ * @p: pointer to an address structure
+ * 
+ * Returns 0 on success, negative on failure
+ **/
+
+int
+e1000_set_mac(struct net_device *netdev,
+              void *p)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    struct pci_dev *pdev = adapter->pdev;
+    struct sockaddr *addr = (struct sockaddr *) p;
+    uint32_t pci_command;
+    uint32_t rctl;
+
+    E1000_DBG("e1000_set_mac\n");
+
+    rctl = E1000_READ_REG(&adapter->shared, RCTL);
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_command =
+                adapter->shared.pci_cmd_word & ~PCI_COMMAND_INVALIDATE;
+            pci_write_config_word(pdev, PCI_COMMAND, pci_command);
+        }
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl | E1000_RCTL_RST);
+        mdelay(5);
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            tasklet_disable(&adapter->rx_fill_tasklet);
+            e1000_clean_rx_ring(adapter);
+        }
+    }
+
+    memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
+    memcpy(adapter->shared.mac_addr, addr->sa_data, netdev->addr_len);
+
+    e1000_rar_set(&adapter->shared, adapter->shared.mac_addr, 0);
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        mdelay(5);
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_write_config_word(pdev, PCI_COMMAND,
+                                  adapter->shared.pci_cmd_word);
+        }
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            e1000_configure_rx(adapter);
+            tasklet_enable(&adapter->rx_fill_tasklet);
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * e1000_update_stats - Update the board statistics counters
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_update_stats(struct e1000_adapter *adapter)
+{
+    unsigned long flags;
+
+#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF
+
+    spin_lock_irqsave(&adapter->stats_lock, flags);
+
+    adapter->stats.crcerrs += E1000_READ_REG(&adapter->shared, CRCERRS);
+    adapter->stats.symerrs += E1000_READ_REG(&adapter->shared, SYMERRS);
+    adapter->stats.mpc += E1000_READ_REG(&adapter->shared, MPC);
+    adapter->stats.scc += E1000_READ_REG(&adapter->shared, SCC);
+    adapter->stats.ecol += E1000_READ_REG(&adapter->shared, ECOL);
+    adapter->stats.mcc += E1000_READ_REG(&adapter->shared, MCC);
+    adapter->stats.latecol += E1000_READ_REG(&adapter->shared, LATECOL);
+    adapter->stats.colc += E1000_READ_REG(&adapter->shared, COLC);
+    adapter->stats.dc += E1000_READ_REG(&adapter->shared, DC);
+    adapter->stats.sec += E1000_READ_REG(&adapter->shared, SEC);
+    adapter->stats.rlec += E1000_READ_REG(&adapter->shared, RLEC);
+    adapter->stats.xonrxc += E1000_READ_REG(&adapter->shared, XONRXC);
+    adapter->stats.xontxc += E1000_READ_REG(&adapter->shared, XONTXC);
+    adapter->stats.xoffrxc += E1000_READ_REG(&adapter->shared, XOFFRXC);
+    adapter->stats.xofftxc += E1000_READ_REG(&adapter->shared, XOFFTXC);
+    adapter->stats.fcruc += E1000_READ_REG(&adapter->shared, FCRUC);
+    adapter->stats.prc64 += E1000_READ_REG(&adapter->shared, PRC64);
+    adapter->stats.prc127 += E1000_READ_REG(&adapter->shared, PRC127);
+    adapter->stats.prc255 += E1000_READ_REG(&adapter->shared, PRC255);
+    adapter->stats.prc511 += E1000_READ_REG(&adapter->shared, PRC511);
+    adapter->stats.prc1023 += E1000_READ_REG(&adapter->shared, PRC1023);
+    adapter->stats.prc1522 += E1000_READ_REG(&adapter->shared, PRC1522);
+    adapter->stats.gprc += E1000_READ_REG(&adapter->shared, GPRC);
+    adapter->stats.bprc += E1000_READ_REG(&adapter->shared, BPRC);
+    adapter->stats.mprc += E1000_READ_REG(&adapter->shared, MPRC);
+    adapter->stats.gptc += E1000_READ_REG(&adapter->shared, GPTC);
+
+    /* for the 64-bit byte counters the low dword must be read first */
+    /* both registers clear on the read of the high dword */
+
+    adapter->stats.gorcl += E1000_READ_REG(&adapter->shared, GORCL);
+    adapter->stats.gorch += E1000_READ_REG(&adapter->shared, GORCH);
+    adapter->stats.gotcl += E1000_READ_REG(&adapter->shared, GOTCL);
+    adapter->stats.gotch += E1000_READ_REG(&adapter->shared, GOTCH);
+
+    adapter->stats.rnbc += E1000_READ_REG(&adapter->shared, RNBC);
+    adapter->stats.ruc += E1000_READ_REG(&adapter->shared, RUC);
+    adapter->stats.rfc += E1000_READ_REG(&adapter->shared, RFC);
+    adapter->stats.roc += E1000_READ_REG(&adapter->shared, ROC);
+    adapter->stats.rjc += E1000_READ_REG(&adapter->shared, RJC);
+
+    adapter->stats.torl += E1000_READ_REG(&adapter->shared, TORL);
+    adapter->stats.torh += E1000_READ_REG(&adapter->shared, TORH);
+    adapter->stats.totl += E1000_READ_REG(&adapter->shared, TOTL);
+    adapter->stats.toth += E1000_READ_REG(&adapter->shared, TOTH);
+
+    adapter->stats.tpr += E1000_READ_REG(&adapter->shared, TPR);
+    adapter->stats.tpt += E1000_READ_REG(&adapter->shared, TPT);
+    adapter->stats.ptc64 += E1000_READ_REG(&adapter->shared, PTC64);
+    adapter->stats.ptc127 += E1000_READ_REG(&adapter->shared, PTC127);
+    adapter->stats.ptc255 += E1000_READ_REG(&adapter->shared, PTC255);
+    adapter->stats.ptc511 += E1000_READ_REG(&adapter->shared, PTC511);
+    adapter->stats.ptc1023 += E1000_READ_REG(&adapter->shared, PTC1023);
+    adapter->stats.ptc1522 += E1000_READ_REG(&adapter->shared, PTC1522);
+    adapter->stats.mptc += E1000_READ_REG(&adapter->shared, MPTC);
+    adapter->stats.bptc += E1000_READ_REG(&adapter->shared, BPTC);
+
+    if(adapter->shared.mac_type >= e1000_82543) {
+        adapter->stats.algnerrc += E1000_READ_REG(&adapter->shared, ALGNERRC);
+        adapter->stats.rxerrc += E1000_READ_REG(&adapter->shared, RXERRC);
+        adapter->stats.tncrs += E1000_READ_REG(&adapter->shared, TNCRS);
+        adapter->stats.cexterr += E1000_READ_REG(&adapter->shared, CEXTERR);
+        adapter->stats.tsctc += E1000_READ_REG(&adapter->shared, TSCTC);
+        adapter->stats.tsctfc += E1000_READ_REG(&adapter->shared, TSCTFC);
+    }
+
+    /* Fill out the OS statistics structure */
+
+    adapter->net_stats.rx_packets = adapter->stats.gprc;
+    adapter->net_stats.tx_packets = adapter->stats.gptc;
+    adapter->net_stats.rx_bytes = adapter->stats.gorcl;
+    adapter->net_stats.tx_bytes = adapter->stats.gotcl;
+    adapter->net_stats.multicast = adapter->stats.mprc;
+    adapter->net_stats.collisions = adapter->stats.colc;
+
+    /* Rx Errors */
+
+    adapter->net_stats.rx_errors =
+        adapter->stats.rxerrc + adapter->stats.crcerrs +
+        adapter->stats.algnerrc + adapter->stats.rlec + adapter->stats.rnbc +
+        adapter->stats.mpc + adapter->stats.cexterr;
+    adapter->net_stats.rx_dropped = adapter->stats.rnbc;
+    adapter->net_stats.rx_length_errors = adapter->stats.rlec;
+    adapter->net_stats.rx_crc_errors = adapter->stats.crcerrs;
+    adapter->net_stats.rx_frame_errors = adapter->stats.algnerrc;
+    adapter->net_stats.rx_fifo_errors = adapter->stats.mpc;
+    adapter->net_stats.rx_missed_errors = adapter->stats.mpc;
+
+    /* Tx Errors */
+
+    adapter->net_stats.tx_errors = adapter->stats.ecol + adapter->stats.latecol;
+    adapter->net_stats.tx_aborted_errors = adapter->stats.ecol;
+    adapter->net_stats.tx_window_errors = adapter->stats.latecol;
+
+    /* Tx Dropped needs to be maintained elsewhere */
+
+    if(adapter->shared.media_type == e1000_media_type_copper) {
+        adapter->phy_stats.idle_errors +=
+            (e1000_read_phy_reg(&adapter->shared, PHY_1000T_STATUS)
+             & PHY_IDLE_ERROR_COUNT_MASK);
+        adapter->phy_stats.receive_errors +=
+            e1000_read_phy_reg(&adapter->shared, M88E1000_RX_ERR_CNTR);
+    }
+
+    spin_unlock_irqrestore(&adapter->stats_lock, flags);
+    return;
+}
+
+/**
+ * e1000_irq_disable - Mask off interrupt generation on the NIC
+ * @adapter: board private structure
+ **/
+
+static inline void
+e1000_irq_disable(struct e1000_adapter *adapter)
+{
+    E1000_DBG("e1000_irq_disable\n");
+
+    /* Mask off all interrupts */
+
+    E1000_WRITE_REG(&adapter->shared, IMC, ~0);
+    return;
+}
+
+/**
+ * e1000_irq_enable - Enable default interrupt generation settings
+ * @adapter: board private structure
+ **/
+
+static inline void
+e1000_irq_enable(struct e1000_adapter *adapter)
+{
+    E1000_DBG("e1000_irq_enable\n");
+
+    E1000_WRITE_REG(&adapter->shared, IMS, adapter->int_mask);
+    return;
+}
+
+/**
+ * e1000_intr - Interrupt Handler
+ * @irq: interrupt number
+ * @data: pointer to a network interface device structure
+ * @pt_regs: CPU registers structure
+ **/
+
+void
+e1000_intr(int irq,
+           void *data,
+           struct pt_regs *regs)
+{
+    struct net_device *netdev = (struct net_device *) data;
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t icr;
+    uint loop_count = E1000_MAX_INTR;
+
+    E1000_DBG("e1000_intr\n");
+
+    e1000_irq_disable(adapter);
+
+    while(loop_count > 0 && (icr = E1000_READ_REG(&adapter->shared, ICR)) != 0) {
+
+        if(icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
+            adapter->shared.get_link_status = 1;
+            set_bit(E1000_LINK_STATUS_CHANGED, &adapter->flags);
+            /* run the watchdog ASAP */
+            mod_timer(&adapter->timer_id, jiffies);
+        }
+
+        e1000_clean_rx_irq(adapter);
+        e1000_clean_tx_irq(adapter);
+        loop_count--;
+    }
+
+    e1000_irq_enable(adapter);
+
+    return;
+}
+
+/**
+ * e1000_clean_tx_irq - Reclaim resources after transmit completes
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_tx_irq(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    int i;
+
+    struct e1000_tx_desc *tx_desc;
+    struct net_device *netdev = adapter->netdev;
+
+    E1000_DBG("e1000_clean_tx_irq\n");
+
+    i = adapter->tx_ring.next_to_clean;
+    tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+    while(tx_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) {
+
+        if(adapter->tx_ring.buffer_info[i].dma != 0) {
+            pci_unmap_page(pdev, adapter->tx_ring.buffer_info[i].dma,
+                           adapter->tx_ring.buffer_info[i].length,
+                           PCI_DMA_TODEVICE);
+            adapter->tx_ring.buffer_info[i].dma = 0;
+        }
+
+        if(adapter->tx_ring.buffer_info[i].skb != NULL) {
+            dev_kfree_skb_irq(adapter->tx_ring.buffer_info[i].skb);
+            adapter->tx_ring.buffer_info[i].skb = NULL;
+        }
+
+        atomic_inc(&adapter->tx_ring.unused);
+        i = (i + 1) % adapter->tx_ring.count;
+
+        tx_desc->upper.data = 0;
+        tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+    }
+
+    adapter->tx_ring.next_to_clean = i;
+
+    if(adapter->tx_ring.next_to_clean == adapter->tx_ring.next_to_use)
+        atomic_set(&adapter->tx_timeout, 0);
+    else
+        atomic_set(&adapter->tx_timeout, 3);
+
+    if(netif_queue_stopped(netdev) &&
+       (atomic_read(&adapter->tx_ring.unused) >
+        (adapter->tx_ring.count * 3 / 4))) {
+
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+            if(ans_notify)
+                ans_notify(netdev, IANS_IND_XMIT_QUEUE_READY);
+#endif
+        netif_wake_queue(netdev);
+    }
+
+    return;
+}
+
+/**
+ * e1000_clean_rx_irq - Send received data up the network stack,
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_rx_irq(struct e1000_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_rx_desc *rx_desc;
+    int i;
+    uint32_t length;
+    struct sk_buff *skb;
+    uint8_t last_byte;
+    unsigned long flags;
+
+    E1000_DBG("e1000_clean_rx_irq\n");
+
+    i = adapter->rx_ring.next_to_clean;
+    rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+    while(rx_desc->status & E1000_RXD_STAT_DD) {
+        pci_unmap_single(pdev, adapter->rx_ring.buffer_info[i].dma,
+                         adapter->rx_ring.buffer_info[i].length,
+                         PCI_DMA_FROMDEVICE);
+
+        skb = adapter->rx_ring.buffer_info[i].skb;
+        length = le16_to_cpu(rx_desc->length);
+
+        if(!(rx_desc->status & E1000_RXD_STAT_EOP)) {
+
+            /* All receives must fit into a single buffer */
+
+            E1000_DBG("Receive packet consumed multiple buffers\n");
+
+            dev_kfree_skb_irq(skb);
+            memset(rx_desc, 0, 16);
+            mb();
+            adapter->rx_ring.buffer_info[i].skb = NULL;
+
+            atomic_inc(&adapter->rx_ring.unused);
+
+            i = (i + 1) % adapter->rx_ring.count;
+
+            rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+            continue;
+        }
+
+        if(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK) {
+
+            last_byte = *(skb->data + length - 1);
+
+            if(TBI_ACCEPT
+               (&adapter->shared, rx_desc->status, rx_desc->errors, length,
+                last_byte)) {
+                spin_lock_irqsave(&adapter->stats_lock, flags);
+                e1000_tbi_adjust_stats(&adapter->shared, &adapter->stats,
+                                       length, skb->data);
+                spin_unlock_irqrestore(&adapter->stats_lock, flags);
+                length--;
+            } else {
+
+                E1000_DBG("Receive Errors Reported by Hardware\n");
+
+                dev_kfree_skb_irq(skb);
+                memset(rx_desc, 0, 16);
+                mb();
+                adapter->rx_ring.buffer_info[i].skb = NULL;
+
+                atomic_inc(&adapter->rx_ring.unused);
+                i = (i + 1) % adapter->rx_ring.count;
+
+                rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+                continue;
+            }
+        }
+
+        /* Good Receive */
+        skb_put(skb, length - CRC_LENGTH);
+
+        /* Adjust socket buffer accounting to only cover the ethernet frame
+         * Not what the stack intends, but there exist TCP problems that
+         * break NFS for network interfaces that need 2k receive buffers
+         */
+        skb->truesize = skb->len;
+
+        /* Receive Checksum Offload */
+        e1000_rx_checksum(adapter, rx_desc, skb);
+
+#ifdef IANS
+        if(adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
+            if(bd_ans_os_Receive(adapter, rx_desc, skb) == BD_ANS_FAILURE)
+                dev_kfree_skb_irq(skb);
+            else
+                netif_rx(skb);
+        } else {
+            skb->protocol = eth_type_trans(skb, netdev);
+            netif_rx(skb);
+        }
+#else
+        skb->protocol = eth_type_trans(skb, netdev);
+        netif_rx(skb);
+#endif
+        memset(rx_desc, 0, 16);
+        mb();
+        adapter->rx_ring.buffer_info[i].skb = NULL;
+
+        atomic_inc(&adapter->rx_ring.unused);
+
+        i = (i + 1) % adapter->rx_ring.count;
+
+        rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+    }
+
+    /* if the Rx ring is less than 3/4 full, allocate more sk_buffs */
+
+    if(atomic_read(&adapter->rx_ring.unused) > (adapter->rx_ring.count / 4)) {
+        tasklet_schedule(&adapter->rx_fill_tasklet);
+    }
+    adapter->rx_ring.next_to_clean = i;
+
+    return;
+}
+
+/**
+ * e1000_alloc_rx_buffers - Replace used receive buffers
+ * @data: address of board private structure
+ **/
+
+static void
+e1000_alloc_rx_buffers(unsigned long data)
+{
+    struct e1000_adapter *adapter = (struct e1000_adapter *) data;
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_rx_desc *rx_desc;
+    struct sk_buff *skb;
+    int i;
+    int reserve_len;
+
+    E1000_DBG("e1000_alloc_rx_buffers\n");
+
+    /* kernel 2.4.7 seems to be broken with respect to tasklet locking */
+    if(!spin_trylock(&adapter->rx_fill_lock))
+        return;
+
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+        spin_unlock(&adapter->rx_fill_lock);
+        return;
+    }
+
+#ifdef IANS
+    reserve_len = E1000_ROUNDUP2(BD_ANS_INFO_SIZE, 16) + 2;
+#else
+    reserve_len = 2;
+#endif
+
+    i = adapter->rx_ring.next_to_use;
+
+    while(adapter->rx_ring.buffer_info[i].skb == NULL) {
+        rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+        skb = alloc_skb(adapter->rx_buffer_len + reserve_len, GFP_ATOMIC);
+
+        if(skb == NULL) {
+            /* Alloc Failed; If we could not allocate a
+             *  skb during this schedule. Wait for a while before
+             *  tasklet to allocate skb is called again.
+             */
+            set_bit(E1000_RX_REFILL, &adapter->flags);
+            break;
+        }
+
+        /* Make buffer alignment 2 beyond a 16 byte boundary
+         * this will result in a 16 byte aligned IP header after
+         * the 14 byte MAC header is removed
+         */
+        skb_reserve(skb, reserve_len);
+
+        skb->dev = netdev;
+
+        adapter->rx_ring.buffer_info[i].skb = skb;
+        adapter->rx_ring.buffer_info[i].length = adapter->rx_buffer_len;
+        adapter->rx_ring.buffer_info[i].dma =
+            pci_map_single(pdev, skb->data, adapter->rx_buffer_len,
+                           PCI_DMA_FROMDEVICE);
+
+        rx_desc->buffer_addr = cpu_to_le64(adapter->rx_ring.buffer_info[i].dma);
+
+        /* move tail */
+        E1000_WRITE_REG(&adapter->shared, RDT, i);
+
+        atomic_dec(&adapter->rx_ring.unused);
+
+        i = (i + 1) % adapter->rx_ring.count;
+
+        if(test_and_clear_bit(E1000_RX_REFILL, &adapter->flags)) {
+            /* Trigger Soft Interrupt */
+            E1000_WRITE_REG(&adapter->shared, ICS, E1000_ICS_RXT0);
+        }
+    }
+
+    adapter->rx_ring.next_to_use = i;
+
+    spin_unlock(&adapter->rx_fill_lock);
+    return;
+}
+
+/**
+ * e1000_ioctl - 
+ * @netdev:
+ * @ifreq:
+ * @cmd:
+ **/
+
+int
+e1000_ioctl(struct net_device *netdev,
+            struct ifreq *ifr,
+            int cmd)
+{
+#ifdef IANS
+    IANS_BD_PARAM_HEADER *header;
+#endif
+
+    E1000_DBG("e1000_do_ioctl\n");
+
+    switch (cmd) {
+
+#ifdef IANS
+    case IANS_BASE_SIOC:
+        header = (IANS_BD_PARAM_HEADER *) ifr->ifr_data;
+        if((header->Opcode != IANS_OP_EXT_GET_STATUS) &&
+           (!capable(CAP_NET_ADMIN)))
+            return -EPERM;
+        return bd_ans_os_Ioctl(netdev, ifr, cmd);
+        break;
+#endif
+
+#ifdef IDIAG
+    case IDIAG_PRO_BASE_SIOC:
+        if(!capable(CAP_NET_ADMIN))
+            return -EPERM;
+
+#ifdef DIAG_DEBUG
+        printk("Entering diagnostics\n");
+#endif
+        e1000_diag_ioctl(netdev, ifr);
+        break;
+#endif /* IDIAG */
+
+#ifdef SIOCETHTOOL
+    case SIOCETHTOOL:
+
+        return e1000_ethtool_ioctl(netdev, ifr);
+
+        break;
+#endif
+
+    default:
+        return -EOPNOTSUPP;
+    }
+
+    return 0;
+}
+
+/**
+ * e1000_rx_checksum - Receive Checksum Offload for 82543
+ * @adapter: board private structure
+ * @rx_desc: receive descriptor
+ * @sk_buff: socket buffer with received data
+ **/
+
+static inline void
+e1000_rx_checksum(struct e1000_adapter *adapter,
+                  struct e1000_rx_desc *rx_desc,
+                  struct sk_buff *skb)
+{
+    /* 82543 or newer only */
+    if((adapter->shared.mac_type < e1000_82543) ||
+       /* Ignore Checksum bit is set */
+       (rx_desc->status & E1000_RXD_STAT_IXSM) ||
+       /* TCP Checksum has not been calculated */
+       (!(rx_desc->status & E1000_RXD_STAT_TCPCS))) {
+
+        skb->ip_summed = CHECKSUM_NONE;
+        return;
+    }
+
+    /* At this point we know the hardware did the TCP checksum */
+    /* now look at the TCP checksum error bit */
+    if(rx_desc->errors & E1000_RXD_ERR_TCPE) {
+        /* let the stack verify checksum errors */
+        skb->ip_summed = CHECKSUM_NONE;
+        adapter->XsumRXError++;
+    } else {
+        /* TCP checksum is good */
+        skb->ip_summed = CHECKSUM_UNNECESSARY;
+        adapter->XsumRXGood++;
+    }
+
+    return;
+}
+
+void
+e1000_hibernate_adapter(struct net_device *netdev)
+{
+    uint32_t icr;
+    struct e1000_adapter *adapter = netdev->priv;
+
+    e1000_irq_disable(adapter);
+    netif_stop_queue(netdev);
+    adapter->shared.adapter_stopped = 0;
+    e1000_adapter_stop(&adapter->shared);
+
+    if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+
+        /* Disable tasklet only when interface is opened. */
+        tasklet_disable(&adapter->rx_fill_tasklet);
+
+        /* clean out old buffers */
+        e1000_clean_rx_ring(adapter);
+        e1000_clean_tx_ring(adapter);
+
+        /* Delete watchdog timer */
+        del_timer(&adapter->timer_id);
+
+        /* Unhook irq */
+        e1000_irq_disable(adapter);
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+        free_irq(netdev->irq, netdev);
+    }
+}
+
+void
+e1000_wakeup_adapter(struct net_device *netdev)
+{
+    uint32_t icr;
+    struct e1000_adapter *adapter = netdev->priv;
+
+    adapter->shared.adapter_stopped = 0;
+    e1000_adapter_stop(&adapter->shared);
+    adapter->shared.adapter_stopped = 0;
+    adapter->shared.fc = adapter->shared.original_fc;
+
+    if(!e1000_init_hw(&adapter->shared))
+        printk("Hardware Init Failed at wakeup\n");
+
+    if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+
+        /* Setup Rctl */
+        e1000_setup_rctl(adapter);
+        e1000_configure_rx(adapter);
+        e1000_alloc_rx_buffers((unsigned long) adapter);
+        e1000_set_multi(netdev);
+        e1000_configure_tx(adapter);
+
+#ifdef IANS
+        if((IANS_BD_TAGGING_MODE) (ANS_PRIVATE_DATA_FIELD(adapter)->tag_mode)
+           != IANS_BD_TAGGING_NONE)
+            bd_ans_hw_EnableVLAN(adapter);
+#endif
+
+        /* Set the watchdog timer for 2 seconds */
+        init_timer(&adapter->timer_id);
+        adapter->timer_id.function = &e1000_watchdog;
+        adapter->timer_id.data = (unsigned long) netdev;
+        mod_timer(&adapter->timer_id, (jiffies + 2 * HZ));
+
+        tasklet_enable(&adapter->rx_fill_tasklet);
+
+        /* Hook irq */
+        e1000_irq_disable(adapter);
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+        if(request_irq
+           (netdev->irq, &e1000_intr, SA_SHIRQ, e1000_driver_name, netdev) != 0)
+            printk(KERN_ERR "e1000: Unable to hook irq.\n");
+
+        e1000_irq_enable(adapter);
+        netif_start_queue(netdev);
+    }
+}
+
+#ifdef IDIAG
+int
+e1000_xmit_lbtest_frame(struct sk_buff *skb,
+                        struct e1000_adapter *adapter)
+{
+    /*struct e1000_adapter *adapter = netdev->priv; */
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_tx_desc *tx_desc;
+    int i;
+
+    i = adapter->tx_ring.next_to_use;
+    tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+    adapter->tx_ring.buffer_info[i].skb = skb;
+    adapter->tx_ring.buffer_info[i].length = skb->len;
+    adapter->tx_ring.buffer_info[i].dma =
+        pci_map_page(pdev, virt_to_page(skb->data),
+                     (unsigned long) skb->data & ~PAGE_MASK, skb->len,
+                     PCI_DMA_TODEVICE);
+
+    tx_desc->buffer_addr = cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+    tx_desc->lower.data = cpu_to_le32(skb->len);
+
+    /* zero out the status field in the descriptor */
+
+    tx_desc->upper.data = 0;
+
+    tx_desc->lower.data |= E1000_TXD_CMD_EOP;
+    tx_desc->lower.data |= E1000_TXD_CMD_IFCS;
+    tx_desc->lower.data |= E1000_TXD_CMD_IDE;
+
+    if(adapter->shared.report_tx_early == 1)
+        tx_desc->lower.data |= E1000_TXD_CMD_RS;
+    else
+        tx_desc->lower.data |= E1000_TXD_CMD_RPS;
+
+    /* Move the HW Tx Tail Pointer */
+
+    adapter->tx_ring.next_to_use++;
+    adapter->tx_ring.next_to_use %= adapter->tx_ring.count;
+
+    E1000_WRITE_REG(&adapter->shared, TDT, adapter->tx_ring.next_to_use);
+    mdelay(10);
+
+    atomic_dec(&adapter->tx_ring.unused);
+
+    if(atomic_read(&adapter->tx_ring.unused) <= 1) {
+
+        /* this driver never actually drops transmits,
+         * so use tx_dropped count to indicate the number of times
+         * netif_stop_queue is called due to no available descriptors
+         */
+
+        adapter->net_stats.tx_dropped++;
+        return (0);
+    }
+    return (1);
+}
+
+int
+e1000_rcv_lbtest_frame(struct e1000_adapter *adapter,
+                       unsigned int frame_size)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_rx_desc *rx_desc;
+    int i, j = 0, rcved_pkt = 0;
+    uint32_t Length;
+    struct sk_buff *skb;
+
+    mdelay(500);
+    i = adapter->rx_ring.next_to_clean;
+    rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+    while(rx_desc->status & E1000_RXD_STAT_DD) {
+        Length = le16_to_cpu(rx_desc->length) - CRC_LENGTH;
+        skb = adapter->rx_ring.buffer_info[i].skb;
+
+        /* Snoop the packet for pattern */
+        rcved_pkt = e1000_check_lbtest_frame(skb, frame_size);
+
+        pci_unmap_single(pdev, adapter->rx_ring.buffer_info[i].dma,
+                         adapter->rx_ring.buffer_info[i].length,
+                         PCI_DMA_FROMDEVICE);
+
+        dev_kfree_skb_irq(skb);
+        adapter->rx_ring.buffer_info[i].skb = NULL;
+
+        rx_desc->status = 0;
+        atomic_inc(&adapter->rx_ring.unused);
+
+        i++;
+        i %= adapter->rx_ring.count;
+        rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+        if(rcved_pkt)
+            break;
+
+        /* waited enough */
+        if(j++ >= adapter->rx_ring.count)
+            return 0;
+
+        mdelay(5);
+
+    }
+
+    adapter->rx_ring.next_to_clean = i;
+
+    return (rcved_pkt);
+
+}
+
+void
+e1000_selective_wakeup_adapter(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t ctrl, txcw;
+
+    e1000_init_hw(&adapter->shared);
+
+    if((adapter->link_active == FALSE) &&
+       (adapter->shared.mac_type == e1000_82543)) {
+
+        txcw = E1000_READ_REG(&adapter->shared, TXCW);
+        ctrl = E1000_READ_REG(&adapter->shared, CTRL);
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw & ~E1000_TXCW_ANE);
+        E1000_WRITE_REG(&adapter->shared, CTRL,
+                        (ctrl | E1000_CTRL_SLU | E1000_CTRL_ILOS |
+                         E1000_CTRL_FD));
+        mdelay(20);
+    }
+
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+        set_bit(E1000_BOARD_OPEN, &adapter->flags);
+        set_bit(E1000_DIAG_OPEN, &adapter->flags);
+        e1000_setup_tx_resources(adapter);
+        e1000_setup_rx_resources(adapter);
+    }
+    e1000_setup_rctl(adapter);
+    e1000_configure_rx(adapter);
+    e1000_alloc_rx_buffers((unsigned long) adapter);
+    e1000_configure_tx(adapter);
+}
+
+void
+e1000_selective_hibernate_adapter(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t ctrl, txcw;
+
+    if((adapter->link_active == FALSE) &&
+       (adapter->shared.mac_type == e1000_82543)) {
+
+        txcw = E1000_READ_REG(&adapter->shared, TXCW);
+        ctrl = E1000_READ_REG(&adapter->shared, CTRL);
+        ctrl &= ~E1000_CTRL_SLU & ~E1000_CTRL_ILOS;
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw | E1000_TXCW_ANE);
+        E1000_WRITE_REG(&adapter->shared, CTRL, ctrl);
+        mdelay(20);
+    }
+    /* clean out old buffers */
+    e1000_clean_rx_ring(adapter);
+    e1000_clean_tx_ring(adapter);
+    if(test_and_clear_bit(E1000_DIAG_OPEN, &adapter->flags)) {
+        e1000_free_tx_resources(adapter);
+        e1000_free_rx_resources(adapter);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+    }
+}
+
+static int
+e1000_check_lbtest_frame(struct sk_buff *skb,
+                         unsigned int frame_size)
+{
+    frame_size = (frame_size % 2) ? (frame_size - 1) : frame_size;
+    if(*(skb->data + 3) == 0xFF) {
+        if((*(skb->data + frame_size / 2 + 10) == 0xBE) &&
+           (*(skb->data + frame_size / 2 + 12) == 0xAF)) {
+            return 1;
+        }
+    }
+    return 0;
+}
+#endif /* IDIAG */
+
+#ifdef SIOCETHTOOL
+/**
+ * e1000_ethtool_ioctl - Ethtool Ioctl Support 
+ * @netdev: net device structure 
+ * @ifr: interface request structure 
+ **/
+
+static int
+e1000_ethtool_ioctl(struct net_device *netdev,
+                    struct ifreq *ifr)
+{
+    struct ethtool_cmd eth_cmd;
+    struct e1000_adapter *adapter = netdev->priv;
+    boolean_t re_initiate = FALSE;
+
+#ifdef ETHTOOL_GLINK
+    struct ethtool_value eth_e1000_linkinfo;
+#endif
+#ifdef ETHTOOL_GDRVINFO
+    struct ethtool_drvinfo eth_e1000_info;
+#endif
+#ifdef ETHTOOL_GWOL
+    struct ethtool_wolinfo eth_e1000_wolinfo;
+#endif
+
+    /* Get the data structure */
+    if(copy_from_user(&eth_cmd, ifr->ifr_data, sizeof(eth_cmd)))
+        return -EFAULT;
+
+    switch (eth_cmd.cmd) {
+        /* Get the information */
+    case ETHTOOL_GSET:
+        if(adapter->shared.media_type == e1000_media_type_copper) {
+            eth_cmd.supported = E1000_ETHTOOL_COPPER_INTERFACE_SUPPORTS;
+            eth_cmd.advertising = E1000_ETHTOOL_COPPER_INTERFACE_ADVERTISE;
+            eth_cmd.port = PORT_MII;
+            eth_cmd.phy_address = adapter->shared.phy_addr;
+            eth_cmd.transceiver =
+                (adapter->shared.mac_type >
+                 e1000_82543) ? XCVR_INTERNAL : XCVR_EXTERNAL;
+        } else {
+            eth_cmd.supported = E1000_ETHTOOL_FIBER_INTERFACE_SUPPORTS;
+            eth_cmd.advertising = E1000_ETHTOOL_FIBER_INTERFACE_ADVERTISE;
+            eth_cmd.port = PORT_FIBRE;
+        }
+
+        if(adapter->link_active == TRUE) {
+            e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                       &adapter->link_duplex);
+            eth_cmd.speed = adapter->link_speed;
+            eth_cmd.duplex =
+                (adapter->link_duplex ==
+                 FULL_DUPLEX) ? DUPLEX_FULL : DUPLEX_HALF;
+        } else {
+            eth_cmd.speed = 0;
+            eth_cmd.duplex = 0;
+        }
+
+        if(adapter->shared.autoneg)
+            eth_cmd.autoneg = AUTONEG_ENABLE;
+        else
+            eth_cmd.autoneg = AUTONEG_DISABLE;
+
+        if(copy_to_user(ifr->ifr_data, &eth_cmd, sizeof(eth_cmd)))
+            return -EFAULT;
+
+        break;
+
+        /* set information */
+    case ETHTOOL_SSET:
+        /* need proper permission to do set */
+        if(!capable(CAP_NET_ADMIN))
+            return -EPERM;
+
+        /* Cannot Force speed/duplex and at the same time autoneg.
+         * Autoneg will override forcing. 
+         * For example to force speed/duplex pass in 
+         *  'speed 100 duplex half autoneg off'
+         * pass in 'autoneg on' to start autoneg.
+         */
+        printk("e1000: Requested link to be forced to %d Speed, %s Duplex "
+               "%s\n", eth_cmd.speed, (eth_cmd.duplex ? "Full" : "Half"),
+               (eth_cmd.autoneg ? "and Autonegotiate" : "."));
+
+        if(eth_cmd.autoneg && eth_cmd.speed)
+            printk("e1000: Autoneg request will over-ride speed forcing\n");
+
+        /* if not in autoneg mode and have been asked to enable autoneg */
+        if(eth_cmd.autoneg) {
+            if(adapter->shared.autoneg &&
+               adapter->shared.autoneg_advertised == AUTONEG_ADV_DEFAULT)
+                /* If already in Autoneg */
+                return 0;
+            else {
+                adapter->shared.autoneg = 1;
+                adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+                re_initiate = TRUE;
+            }
+        }
+        /* Force link to whatever speed and duplex */
+        /* Also turning off Autoneg in case of non-gig speeds */
+        else if(eth_cmd.speed) {
+            /* Check for invalid request */
+            if(((eth_cmd.speed != SPEED_10) && (eth_cmd.speed != SPEED_100) &&
+                (eth_cmd.speed != SPEED_1000)) ||
+               ((eth_cmd.duplex != DUPLEX_HALF) &&
+                (eth_cmd.duplex != DUPLEX_FULL)) ||
+               (adapter->shared.media_type == e1000_media_type_fiber))
+                return -EINVAL;
+
+            e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                       &adapter->link_duplex);
+            /* If we are already forced to requested speed and duplex
+             * Donot do anything, just return
+             */
+            if(!adapter->shared.autoneg &&
+               (adapter->link_speed == eth_cmd.speed) &&
+               (adapter->link_duplex == (eth_cmd.duplex + 1)))
+
+                return 0;
+
+            adapter->shared.autoneg = 0;
+            adapter->shared.autoneg_advertised = 0;
+            re_initiate = TRUE;
+            switch (eth_cmd.speed + eth_cmd.duplex) {
+            case (SPEED_10 + DUPLEX_HALF):
+                adapter->shared.forced_speed_duplex = e1000_10_half;
+                break;
+            case (SPEED_100 + DUPLEX_HALF):
+                adapter->shared.forced_speed_duplex = e1000_100_half;
+                break;
+            case (SPEED_10 + DUPLEX_FULL):
+                adapter->shared.forced_speed_duplex = e1000_10_full;
+                break;
+            case (SPEED_100 + DUPLEX_FULL):
+                adapter->shared.forced_speed_duplex = e1000_100_full;
+                break;
+            case (SPEED_1000 + DUPLEX_HALF):
+                printk("Half Duplex is not supported at 1000 Mbps\n");
+            case (SPEED_1000 + DUPLEX_FULL):
+                printk("Using Auto-neg at 1000 Mbps Full Duplex\n");
+            default:
+                adapter->shared.autoneg = 1;
+                adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+                break;
+            }
+        }
+
+        /* End of force */
+        /* Put the adapter to new settings */
+        if(re_initiate == TRUE) {
+            e1000_hibernate_adapter(netdev);
+            e1000_wakeup_adapter(netdev);
+        } else if(!eth_cmd.autoneg && !eth_cmd.speed) {
+            printk("Cannot turn off autoneg without "
+                   "knowing what speed to force the link\n");
+            printk("Speed specified was %dMbps\n", eth_cmd.speed);
+            return -EINVAL;
+        }
+        /* We donot support setting of 
+         * whatever else that was requested */
+        else
+            return -EOPNOTSUPP;
+
+        break;
+
+#ifdef ETHTOOL_NWAY_RST
+    case ETHTOOL_NWAY_RST:
+        /* need proper permission to restart auto-negotiation */
+        if(!capable(CAP_NET_ADMIN))
+            return -EPERM;
+
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+        e1000_hibernate_adapter(netdev);
+        e1000_wakeup_adapter(netdev);
+
+        break;
+#endif
+
+#ifdef ETHTOOL_GLINK
+    case ETHTOOL_GLINK:
+        eth_e1000_linkinfo.data = adapter->link_active;
+        if(copy_to_user(ifr->ifr_data, &eth_e1000_linkinfo, sizeof(eth_e1000_linkinfo)))
+            return -EFAULT;
+        break;
+#endif
+
+#ifdef ETHTOOL_GDRVINFO
+    case ETHTOOL_GDRVINFO:
+        strcpy(eth_e1000_info.driver, e1000_driver_name);
+        strcpy(eth_e1000_info.version, e1000_driver_version);
+        strcpy(eth_e1000_info.fw_version, "None");
+        strcpy(eth_e1000_info.bus_info, adapter->pdev->slot_name);
+        if(copy_to_user(ifr->ifr_data, &eth_e1000_info, sizeof(eth_e1000_info)))
+            return -EFAULT;
+        break;
+#endif
+
+#ifdef ETHTOOL_GWOL
+    case ETHTOOL_GWOL:
+        eth_e1000_wolinfo.supported = eth_e1000_wolinfo.wolopts = WAKE_MAGIC;
+        if(copy_to_user
+           (ifr->ifr_data, &eth_e1000_wolinfo, sizeof(eth_e1000_wolinfo)))
+            return -EFAULT;
+        break;
+#endif
+
+    default:
+        return -EOPNOTSUPP;
+    }
+
+    return 0;
+
+}
+#endif /* SIOCETHTOOL */
+
+/**
+ * e1000_enable_WOL - Wake On Lan Support (Magic Pkt)
+ * @adapter: Adapter structure 
+ **/
+
+static void
+e1000_enable_WOL(struct e1000_adapter *adapter)
+{
+    uint32_t wuc_val;
+
+    if(adapter->shared.mac_type <= e1000_82543)
+        return;
+
+    /* Set up Wake-Up Ctrl reg */
+    wuc_val = E1000_READ_REG(&adapter->shared, WUC);
+    wuc_val &= ~(E1000_WUC_APME | E1000_WUC_APMPME);
+    wuc_val |= (E1000_WUC_PME_STATUS | E1000_WUC_PME_EN);
+
+    E1000_WRITE_REG(&adapter->shared, WUC, wuc_val);
+
+    /* Set up Wake-up Filter */
+    E1000_WRITE_REG(&adapter->shared, WUFC, E1000_WUFC_MAG);
+
+    return;
+}
+
+/**
+ * e1000_write_pci_cg -
+ * @shared:
+ * @reg:
+ * @value:
+ **/
+
+void
+e1000_write_pci_cfg(struct e1000_shared_adapter *shared,
+                    uint32_t reg,
+                    uint16_t *value)
+{
+    struct e1000_adapter *adapter = (struct e1000_adapter *) shared->back;
+
+    pci_write_config_word(adapter->pdev, reg, *value);
+    return;
+}
+
+/* e1000_main.c */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_osdep.h linux/drivers/net/e1000/e1000_osdep.h
--- ../prev/linux/drivers/net/e1000/e1000_osdep.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_osdep.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,138 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+/* glue for the OS independant part of e1000 
+ * includes register access macros
+ */
+
+#ifndef _E1000_OSDEP_H_
+#define _E1000_OSDEP_H_
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+#define usec_delay(x) udelay(x)
+#define msec_delay(x) mdelay(x)
+
+#define PCI_COMMAND_REGISTER   PCI_COMMAND
+#define CMD_MEM_WRT_INVALIDATE PCI_COMMAND_INVALIDATE
+
+typedef enum {
+    FALSE = 0,
+    TRUE = 1
+} boolean_t;
+
+#if DBG
+#define ASSERT(x) if(!(x)) panic("E1000: x")
+#define DEBUGOUT(S)         printk(S "\n")
+#define DEBUGOUT1(S,A)      printk(S "\n",A)
+#define DEBUGOUT2(S,A,B)    printk(S "\n",A,B)
+#define DEBUGOUT3(S,A,B,C)  printk(S "\n",A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G)  printk(S "\n",A,B,C,D,E,F,G)
+#else
+#define ASSERT(x)
+#define DEBUGOUT(S)
+#define DEBUGOUT1(S,A)
+#define DEBUGOUT2(S,A,B)
+#define DEBUGOUT3(S,A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G)
+#endif
+
+#define MSGOUT(S, A, B)     printk(S "\n", A, B)
+#define DEBUGFUNC(F)        DEBUGOUT(F)
+
+#define E1000_WRITE_REG(a, reg, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        (writel((value), ((a)->hw_addr + E1000_##reg))) : \
+        (writel((value), ((a)->hw_addr + E1000_82542_##reg))))
+
+#define E1000_READ_REG(a, reg) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg) : \
+        readl((a)->hw_addr + E1000_82542_##reg))
+
+#define E1000_WRITE_REG_ARRAY(a, reg, offset, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        writel((value), ((a)->hw_addr + E1000_##reg + ((offset) << 2))) : \
+        writel((value), ((a)->hw_addr + E1000_82542_##reg + ((offset) << 2))))
+
+#define E1000_READ_REG_ARRAY(a, reg, offset) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg + ((offset) << 2)) : \
+        readl((a)->hw_addr + E1000_82542_##reg + ((offset) << 2)))
+
+#endif /* _E1000_OSDEP_H_ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_phy.c linux/drivers/net/e1000/e1000_phy.c
--- ../prev/linux/drivers/net/e1000/e1000_phy.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_phy.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,1576 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_phy.c
+ * Shared functions for accessing and configuring the PHY
+ */
+
+#include "e1000_mac.h"
+#include "e1000_phy.h"
+
+/******************************************************************************
+* Raises the Management Data Clock
+*
+* shared - Struct containing variables accessed by shared code
+* ctrl_reg - Device control register's current value
+******************************************************************************/
+static void
+e1000_raise_mdc(struct e1000_shared_adapter *shared,
+                uint32_t *ctrl_reg)
+{
+    /* Raise the clock input to the Management Data Clock (by setting
+     * the MDC bit), and then delay 2 microseconds.
+     */
+    E1000_WRITE_REG(shared, CTRL, (*ctrl_reg | E1000_CTRL_MDC));
+    usec_delay(2);
+    return;
+}
+
+/******************************************************************************
+* Lowers the Management Data Clock
+*
+* shared - Struct containing variables accessed by shared code
+* ctrl_reg - Device control register's current value
+******************************************************************************/
+static void
+e1000_lower_mdc(struct e1000_shared_adapter *shared,
+                uint32_t *ctrl_reg)
+{
+    /* Lower the clock input to the Management Data Clock (by clearing
+     * the MDC bit), and then delay 2 microseconds.
+     */
+    E1000_WRITE_REG(shared, CTRL, (*ctrl_reg & ~E1000_CTRL_MDC));
+    usec_delay(2);
+    return;
+}
+
+/******************************************************************************
+* Shifts data bits out to the PHY
+*
+* shared - Struct containing variables accessed by shared code
+* data - Data to send out to the PHY
+* count - Number of bits to shift out
+*
+* Bits are shifted out in MSB to LSB order.
+******************************************************************************/
+static void
+e1000_phy_shift_out(struct e1000_shared_adapter *shared,
+                    uint32_t data,
+                    uint16_t count)
+{
+    uint32_t ctrl_reg;
+    uint32_t mask;
+
+    ASSERT(count <= 32);
+
+    /* We need to shift "count" number of bits out to the PHY.  So, the
+     * value in the "Data" parameter will be shifted out to the PHY
+     * one bit at a time.  In order to do this, "Data" must be broken
+     * down into bits, which is what the "while" logic does below.
+     */
+    mask = 0x01;
+    mask <<= (count - 1);
+
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set MDIO_DIR (SWDPIO1) and MDC_DIR (SWDPIO2) direction bits to
+     * be used as output pins.
+     */
+    ctrl_reg |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
+
+    while(mask) {
+        /* A "1" is shifted out to the PHY by setting the MDIO bit to
+         * "1" and then raising and lowering the Management Data Clock
+         * (MDC).  A "0" is shifted out to the PHY by setting the MDIO
+         * bit to "0" and then raising and lowering the clock.
+         */
+        if(data & mask)
+            ctrl_reg |= E1000_CTRL_MDIO;
+        else
+            ctrl_reg &= ~E1000_CTRL_MDIO;
+
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        usec_delay(2);
+
+        e1000_raise_mdc(shared, &ctrl_reg);
+        e1000_lower_mdc(shared, &ctrl_reg);
+
+        mask = mask >> 1;
+    }
+
+    /* Clear the data bit just before leaving this routine. */
+    ctrl_reg &= ~E1000_CTRL_MDIO;
+    return;
+}
+
+/******************************************************************************
+* Shifts data bits in from the PHY
+*
+* shared - Struct containing variables accessed by shared code
+*
+* Bits are shifted in in MSB to LSB order. 
+******************************************************************************/
+static uint16_t
+e1000_phy_shift_in(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+    uint16_t data = 0;
+    uint8_t i;
+
+    /* In order to read a register from the PHY, we need to shift in a
+     * total of 18 bits from the PHY.  The first two bit (TurnAround)
+     * times are used to avoid contention on the MDIO pin when a read
+     * operation is performed.  These two bits are ignored by us and
+     * thrown away.  Bits are "shifted in" by raising the clock input
+     * to the Management Data Clock (setting the MDC bit), and then
+     * reading the value of the MDIO bit.
+     */ 
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as
+     * input.
+     */ 
+    ctrl_reg &= ~E1000_CTRL_MDIO_DIR;
+    ctrl_reg &= ~E1000_CTRL_MDIO;
+
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    /* Raise and Lower the clock before reading in the data.  This
+     * accounts for the TurnAround bits.  The first clock occurred
+     * when we clocked out the last bit of the Register Address.
+     */
+    e1000_raise_mdc(shared, &ctrl_reg);
+    e1000_lower_mdc(shared, &ctrl_reg);
+
+    for(data = 0, i = 0; i < 16; i++) {
+        data = data << 1;
+        e1000_raise_mdc(shared, &ctrl_reg);
+
+        ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+        /* Check to see if we shifted in a "1". */
+        if(ctrl_reg & E1000_CTRL_MDIO)
+            data |= 1;
+
+        e1000_lower_mdc(shared, &ctrl_reg);
+    }
+
+    e1000_raise_mdc(shared, &ctrl_reg);
+    e1000_lower_mdc(shared, &ctrl_reg);
+
+    /* Clear the MDIO bit just before leaving this routine. */
+    ctrl_reg &= ~E1000_CTRL_MDIO;
+
+    return (data);
+}
+
+/******************************************************************************
+* Force PHY speed and duplex settings to shared->forced_speed_duplex
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+static void
+e1000_phy_force_speed_duplex(struct e1000_shared_adapter *shared)
+{
+    uint32_t tctl_reg;
+    uint32_t ctrl_reg;
+    uint32_t shift;
+    uint16_t mii_ctrl_reg;
+    uint16_t mii_status_reg;
+    uint16_t phy_data;
+    uint16_t i;
+
+    DEBUGFUNC("e1000_phy_force_speed_duplex");
+
+    /* Turn off Flow control if we are forcing speed and duplex. */
+    shared->fc = e1000_fc_none;
+
+    DEBUGOUT1("shared->fc = %d\n", shared->fc);
+
+    /* Read the Device Control Register. */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
+    ctrl_reg |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+    ctrl_reg &= ~(DEVICE_SPEED_MASK);
+
+    /* Clear the Auto Speed Detect Enable bit. */
+    ctrl_reg &= ~E1000_CTRL_ASDE;
+
+    /* Read the MII Control Register. */
+    mii_ctrl_reg = e1000_read_phy_reg(shared, PHY_CTRL);
+
+    /* We need to disable autoneg in order to force link and duplex. */
+
+    mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;
+
+    /* Are we forcing Full or Half Duplex? */
+    if(shared->forced_speed_duplex == e1000_100_full ||
+       shared->forced_speed_duplex == e1000_10_full) {
+
+        /* We want to force full duplex so we SET the full duplex bits
+         * in the Device and MII Control Registers.
+         */
+        ctrl_reg |= E1000_CTRL_FD;
+        mii_ctrl_reg |= MII_CR_FULL_DUPLEX;
+
+        DEBUGOUT("Full Duplex\n");
+    } else {
+
+        /* We want to force half duplex so we CLEAR the full duplex
+         * bits in the Device and MII Control Registers.
+         */
+        ctrl_reg &= ~E1000_CTRL_FD;
+        mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;    /* Do this implies HALF */
+
+        DEBUGOUT("Half Duplex\n");
+    }
+
+    /* Are we forcing 100Mbps??? */
+    if(shared->forced_speed_duplex == e1000_100_full ||
+       shared->forced_speed_duplex == e1000_100_half) {
+
+        /* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
+        ctrl_reg |= E1000_CTRL_SPD_100;
+        mii_ctrl_reg |= MII_CR_SPEED_100;
+        mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
+
+        DEBUGOUT("Forcing 100mb ");
+    } else {                    /* Force 10MB Full or Half */
+
+        /* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
+        ctrl_reg &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
+        mii_ctrl_reg |= MII_CR_SPEED_10;
+        mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
+
+        DEBUGOUT("Forcing 10mb ");
+    }
+
+    /* Now we need to configure the Collision Distance.  We need to read
+     * the Transmit Control Register to do this.
+     * Note: This must be done for both Half or Full Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    DEBUGOUT1("tctl_reg = %x\n", tctl_reg);
+
+    if(!(mii_ctrl_reg & MII_CR_FULL_DUPLEX)) {
+
+       /* We are in Half Duplex mode so we need to set up our collision
+        * distance for 10/100.
+        */
+        tctl_reg &= ~E1000_TCTL_COLD;
+        shift = E1000_HDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    } else {
+        /* We are in Full Duplex mode.  We have the same collision
+         * distance regardless of speed.
+         */
+        tctl_reg &= ~E1000_TCTL_COLD;
+        shift = E1000_FDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    }
+
+    /* Write the configured values back to the Transmit Control Reg. */
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    /* Write the configured values back to the Device Control Reg. */
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    /* Write the MII Control Register with the new PHY configuration. */
+    phy_data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    /* Clear Auto-Crossover to force MDI manually.
+     * M88E1000 requires MDI forced whenever speed/duplex is forced
+     */
+    phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_data);
+
+    DEBUGOUT1("M88E1000 PSCR: %x \n", phy_data);
+
+    /* Need to reset the PHY or these bits will get ignored. */
+    mii_ctrl_reg |= MII_CR_RESET;
+
+    e1000_write_phy_reg(shared, PHY_CTRL, mii_ctrl_reg);
+
+    /* The wait_autoneg_complete flag may be a little misleading here.
+     * Since we are forcing speed and duplex, Auto-Neg is not enabled.
+     * But we do want to delay for a period while forcing only so we
+     * don't generate false No Link messages.  So we will wait here
+     * only if the user has set wait_autoneg_complete to 1, which is
+     * the default.
+     */
+    if(shared->wait_autoneg_complete) {
+        /* We will wait for autoneg to complete. */
+        DEBUGOUT("Waiting for forced speed/duplex link.\n");
+        mii_status_reg = 0;
+
+        /* We will wait for autoneg to complete or 4.5 seconds to expire. */
+        for(i = PHY_FORCE_TIME; i > 0; i--) {
+            /* Read the MII Status Register and wait for Auto-Neg
+             * Complete bit to be set.
+             */
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+            if(mii_status_reg & MII_SR_LINK_STATUS)
+                break;
+
+            msec_delay(100);
+        }                       /* end for loop */
+
+        if(i == 0) {            /* We didn't get link   */
+
+            /* Reset the DSP and wait again for link.   */
+            e1000_phy_reset_dsp(shared);
+        }
+
+        /* This loop will early-out if the link condition has been met.  */
+        for(i = PHY_FORCE_TIME; i > 0; i--) {
+            if(mii_status_reg & MII_SR_LINK_STATUS)
+                break;
+
+            msec_delay(100);
+            /* Read the MII Status Register and wait for Auto-Neg
+             * Complete bit to be set.
+             */
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        }                       /* end for loop */
+    }    /* end if wait_autoneg_complete */
+    /*
+     * Because we reset the PHY above, we need to re-force TX_CLK in the
+     * Extended PHY Specific Control Register to 25MHz clock.  This
+     * value defaults back to a 2.5MHz clock when the PHY is reset.
+     */
+    phy_data = e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+
+    phy_data |= M88E1000_EPSCR_TX_CLK_25;
+
+    e1000_write_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
+
+    /* In addition, because of the s/w reset above, we need to enable
+     * CRS on TX.  This must be set for both full and half duplex
+     * operation.
+     */
+    phy_data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_data);
+    DEBUGOUT1("M88E1000 Phy Specific Ctrl Reg = %4x\r\n", phy_data);
+
+    return;
+}
+
+/*****************************************************************************
+* Reads the value from a PHY register
+*
+* shared - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to read
+******************************************************************************/
+uint16_t
+e1000_read_phy_reg(struct e1000_shared_adapter *shared,
+                   uint32_t reg_addr)
+{
+    uint32_t i;
+    uint32_t data = 0;
+    uint32_t command = 0;
+
+    ASSERT(reg_addr <= MAX_PHY_REG_ADDRESS);
+
+    if(shared->mac_type > e1000_82543) {
+        /* Set up Op-code, Phy Address, and
+         * register address in the MDI Control register.  The MAC will
+         * take care of interfacing with the PHY to retrieve the
+         * desired data.
+         */
+        command = ((reg_addr << E1000_MDIC_REG_SHIFT) |
+                   (shared->phy_addr << E1000_MDIC_PHY_SHIFT) | 
+                   (E1000_MDIC_OP_READ));
+
+        E1000_WRITE_REG(shared, MDIC, command);
+
+        /* Check every 10 usec to see if the read completed.  The read
+         * may take as long as 64 usecs (we'll wait 100 usecs max)
+         * from the CPU Write to the Ready bit assertion.
+         */
+        for(i = 0; i < 64; i++) {
+            usec_delay(10);
+
+            data = E1000_READ_REG(shared, MDIC);
+
+            if(data & E1000_MDIC_READY)
+                break;
+        }
+    } else {
+        /* We must first send a preamble through the MDIO pin to signal the
+         * beginning of an MII instruction.  This is done by sending 32
+         * consecutive "1" bits.
+         */
+        e1000_phy_shift_out(shared, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+
+        /* Now combine the next few fields that are required for a read
+         * operation.  We use this method instead of calling the
+         * e1000_phy_shift_out routine five different times.  The format of
+         * a MII read instruction consists of a shift out of 14 bits and is
+         * defined as follows:
+         *    <Preamble><SOF><Op Code><Phy Addr><Reg Addr>
+         * followed by a shift in of 18 bits.  This first two bits shifted
+         * in are TurnAround bits used to avoid contention on the MDIO pin
+         * when a READ operation is performed.  These two bits are thrown
+         * away followed by a shift in of 16 bits which contains the
+         * desired data.
+         */
+        command = ((reg_addr) |
+                   (shared->phy_addr << 5) |
+                   (PHY_OP_READ << 10) | (PHY_SOF << 12));
+
+        e1000_phy_shift_out(shared, command, 14);
+
+        /* Now that we've shifted out the read command to the MII, we need
+         * to "shift in" the 16-bit value (18 total bits) of the requested
+         * PHY register address.
+         */
+        data = (uint32_t) e1000_phy_shift_in(shared);
+    }
+
+    ASSERT(!(data & E1000_MDIC_ERROR));
+
+    return ((uint16_t) data);
+}
+
+/******************************************************************************
+* Writes a value to a PHY register
+*
+* shared - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to write
+* data - data to write to the PHY
+******************************************************************************/
+void
+e1000_write_phy_reg(struct e1000_shared_adapter *shared,
+                    uint32_t reg_addr,
+                    uint16_t data)
+{
+    uint32_t i;
+    uint32_t command = 0;
+    uint32_t mdic_reg;
+
+    ASSERT(reg_addr <= MAX_PHY_REG_ADDRESS);
+
+    if(shared->mac_type > e1000_82543) {
+        /* Set up Op-code, Phy Address, register
+         * address, and data intended for the PHY register in the MDI
+         * Control register.  The MAC will take care of interfacing
+         * with the PHY to send the desired data.
+         */
+        command = (((uint32_t) data) |
+                   (reg_addr << E1000_MDIC_REG_SHIFT) |
+                   (shared->phy_addr << E1000_MDIC_PHY_SHIFT) | 
+                   (E1000_MDIC_OP_WRITE));
+
+        E1000_WRITE_REG(shared, MDIC, command);
+
+        /* Check every 10 usec to see if the read completed.  The read
+         * may take as long as 64 usecs (we'll wait 100 usecs max)
+         * from the CPU Write to the Ready bit assertion.
+         */
+        for(i = 0; i < 10; i++) {
+            usec_delay(10);
+
+            mdic_reg = E1000_READ_REG(shared, MDIC);
+
+            if(mdic_reg & E1000_MDIC_READY)
+                break;
+        }
+    } else {
+        /* We'll need to use the SW defined pins to shift the write command
+         *  out to the PHY. We first send a preamble to the PHY to signal the
+         * beginning of the MII instruction.  This is done by sending 32 
+         * consecutive "1" bits.
+         */
+        e1000_phy_shift_out(shared, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+
+        /* Now combine the remaining required fields that will indicate
+         * a write operation.  We use this method instead of calling the
+         * e1000_phy_shift_out routine for each field in the command.  The
+         * format of a MII write instruction is as follows:
+         * <Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.
+         */
+        command = ((PHY_TURNAROUND) |
+                   (reg_addr << 2) |
+                   (shared->phy_addr << 7) |
+                   (PHY_OP_WRITE << 12) | (PHY_SOF << 14));
+        command <<= 16;
+        command |= ((uint32_t) data);
+
+        e1000_phy_shift_out(shared, command, 32);
+    }
+    return;
+}
+
+/******************************************************************************
+* Returns the PHY to the power-on reset state
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+void
+e1000_phy_hw_reset(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+    uint32_t ctrl_ext_reg;
+
+    DEBUGFUNC("e1000_phy_hw_reset");
+
+    DEBUGOUT("Resetting Phy...\n");
+
+    if(shared->mac_type > e1000_82543) {
+        /* Read the device control register and assert the
+         * E1000_CTRL_PHY_RST bit.  Hold for 20ms and then take it out
+         * of reset.
+         */
+        ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+        ctrl_reg |= E1000_CTRL_PHY_RST;
+
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        msec_delay(20);
+
+        ctrl_reg &= ~E1000_CTRL_PHY_RST;
+
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        msec_delay(20);
+    } else {
+        /* Read the Extended Device Control Register, assert the
+         * PHY_RESET_DIR bit.  Then clock it out to the PHY.
+         */
+        ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+
+        ctrl_ext_reg |= E1000_CTRL_PHY_RESET_DIR4;
+
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+
+        msec_delay(20);
+
+        /* Set the reset bit in the device control register and clock
+         * it out to the PHY.
+         */
+        ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+
+        ctrl_ext_reg &= ~E1000_CTRL_PHY_RESET4;
+
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+
+        msec_delay(20);
+
+        ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+
+        ctrl_ext_reg |= E1000_CTRL_PHY_RESET4;
+
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+
+        msec_delay(20);
+    }
+    return;
+}
+
+/******************************************************************************
+* Resets the PHY
+*
+* shared - Struct containing variables accessed by shared code
+*
+* Sets bit 15 of the MII Control regiser
+******************************************************************************/
+boolean_t
+e1000_phy_reset(struct e1000_shared_adapter *shared)
+{
+    uint16_t reg_data;
+    uint16_t i;
+
+    DEBUGFUNC("e1000_phy_reset");
+
+    /* Read the MII control register, set the reset bit and write the
+     * value back by clocking it out to the PHY.
+     */
+    reg_data = e1000_read_phy_reg(shared, PHY_CTRL);
+
+    reg_data |= MII_CR_RESET;
+
+    e1000_write_phy_reg(shared, PHY_CTRL, reg_data);
+
+    /* Wait for bit 15 of the MII Control Register to be cleared
+     * indicating the PHY has been reset.
+     */
+    i = 0;
+    while((reg_data & MII_CR_RESET) && i++ < 500) {
+        reg_data = e1000_read_phy_reg(shared, PHY_CTRL);
+        usec_delay(1);
+    }
+
+    if(i >= 500) {
+        DEBUGOUT("Timeout waiting for PHY to reset.\n");
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/******************************************************************************
+* Detects which PHY is present and the speed and duplex
+*
+* shared - Struct containing variables accessed by shared code
+* ctrl_reg - current value of the device control register
+******************************************************************************/
+boolean_t
+e1000_phy_setup(struct e1000_shared_adapter *shared,
+                uint32_t ctrl_reg)
+{
+    uint16_t mii_ctrl_reg;
+    uint16_t mii_status_reg;
+    uint16_t phy_specific_ctrl_reg;
+    uint16_t mii_autoneg_adv_reg;
+    uint16_t mii_1000t_ctrl_reg;
+    uint16_t i;
+    uint16_t data;
+    uint16_t autoneg_hw_setting;
+    uint16_t autoneg_fc_setting;
+    boolean_t restart_autoneg = FALSE;
+    boolean_t force_autoneg_restart = FALSE;
+
+    DEBUGFUNC("e1000_phy_setup");
+
+    /* We want to enable the Auto-Speed Detection bit in the Device
+     * Control Register.  When set to 1, the MAC automatically detects
+     * the resolved speed of the link and self-configures appropriately.
+     * The Set Link Up bit must also be set for this behavior work
+     * properly.
+     */
+    /* Nothing but 82543 and newer */
+    ASSERT(shared->mac_type >= e1000_82543);
+
+    /* With 82543, we need to force speed/duplex
+     * on the MAC equal to what the PHY speed/duplex configuration is.
+     * In addition, on 82543, we need to perform a hardware reset
+     * on the PHY to take it out of reset.
+     */
+    if(shared->mac_type >= e1000_82544) {
+        ctrl_reg |= E1000_CTRL_SLU;
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    } else {
+        ctrl_reg |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        if(shared->mac_type == e1000_82543)
+            e1000_phy_hw_reset(shared);
+    }
+
+    if(!e1000_detect_gig_phy(shared)) {
+        /* No PHY detected, return FALSE */
+        DEBUGOUT("PhySetup failure, did not detect valid phy.\n");
+        return (FALSE);
+    }
+
+    DEBUGOUT1("Phy ID = %x \n", shared->phy_id);
+
+    /* Read the MII Control Register. */
+    mii_ctrl_reg = e1000_read_phy_reg(shared, PHY_CTRL);
+
+    DEBUGOUT1("MII Ctrl Reg contents = %x\n", mii_ctrl_reg);
+
+    /* Check to see if the Auto Neg Enable bit is set in the MII Control
+     * Register.  If not, we could be in a situation where a driver was
+     * loaded previously and was forcing speed and duplex.  Then the
+     * driver was unloaded but a e1000_phy_hw_reset was not performed, so
+     * link was still being forced and link was still achieved.  Then
+     * the driver was reloaded with the intention to auto-negotiate, but
+     * since link is already established we end up not restarting
+     * auto-neg.  So if the auto-neg bit is not enabled and the driver
+     * is being loaded with the desire to auto-neg, we set this flag to
+     * to ensure the restart of the auto-neg engine later in the logic.
+     */
+    if(!(mii_ctrl_reg & MII_CR_AUTO_NEG_EN))
+        force_autoneg_restart = TRUE;
+
+    /* Clear the isolate bit for normal operation and write it back to
+     * the MII Control Reg.  Although the spec says this doesn't need
+     * to be done when the PHY address is not equal to zero, we do it
+     * anyway just to be safe.
+     */
+    mii_ctrl_reg &= ~(MII_CR_ISOLATE);
+
+    e1000_write_phy_reg(shared, PHY_CTRL, mii_ctrl_reg);
+
+    data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    /* Enable CRS on TX.  This must be set for half-duplex operation. */
+    data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+
+    DEBUGOUT1("M88E1000 PSCR: %x \n", data);
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+
+    /* Force TX_CLK in the Extended PHY Specific Control Register
+     * to 25MHz clock.
+     */
+    data |= M88E1000_EPSCR_TX_CLK_25;
+
+    e1000_write_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL, data);
+
+    /* Certain PHYs will set the default of MII register 4 differently.
+     * We need to check this against our fc value.  If it is
+     * different, we need to setup up register 4 correctly and restart
+     * autonegotiation.
+     */
+    /* Read the MII Auto-Neg Advertisement Register (Address 4). */
+    mii_autoneg_adv_reg = e1000_read_phy_reg(shared, PHY_AUTONEG_ADV);
+
+    /* Shift right to put 10T-Half bit in bit 0
+     * Isolate the four bits for 100/10 Full/Half.
+     */ 
+    autoneg_hw_setting = (mii_autoneg_adv_reg >> 5) & 0xF;
+
+    /* Get the 1000T settings. */
+    mii_1000t_ctrl_reg = e1000_read_phy_reg(shared, PHY_1000T_CTRL);
+
+    /* Isolate and OR in the 1000T settings. */
+    autoneg_hw_setting |= ((mii_1000t_ctrl_reg & 0x0300) >> 4);
+
+    /* mask all bits in the MII Auto-Neg Advertisement Register
+     * except for ASM_DIR and PAUSE and shift.  This value
+     * will be used later to see if we need to restart Auto-Negotiation.
+     */
+    autoneg_fc_setting = ((mii_autoneg_adv_reg & 0x0C00) >> 10);
+
+    /* Perform some bounds checking on the shared->autoneg_advertised
+     * parameter.  If this variable is zero, then set it to the default.
+     */
+    shared->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
+
+    /* If autoneg_advertised is zero, we assume it was not defaulted
+     * by the calling code so we set to advertise full capability.
+     */
+    if(shared->autoneg_advertised == 0)
+        shared->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+
+    /* We could be in the situation where Auto-Neg has already completed
+     * and the user has not indicated any overrides.  In this case we
+     * simply need to call e1000_get_speed_and_duplex to obtain the Auto-
+     * Negotiated speed and duplex, then return.
+     */
+    if(!force_autoneg_restart && shared->autoneg &&
+       (shared->autoneg_advertised == autoneg_hw_setting) &&
+       (shared->fc == autoneg_fc_setting)) {
+
+        DEBUGOUT("No overrides - Reading MII Status Reg..\n");
+
+        /* Read the MII Status Register.  We read this twice because
+         * certain bits are "sticky" and need to be read twice.
+         */
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        DEBUGOUT1("MII Status Reg contents = %x\n", mii_status_reg);
+
+        /* Do we have link now? (if so, auto-neg has completed) */
+        if(mii_status_reg & MII_SR_LINK_STATUS) {
+            data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+            DEBUGOUT1("M88E1000 Phy Specific Status Reg contents = %x\n", data);
+
+            /* We have link, so we need to finish the config process:
+             *   1) Set up the MAC to the current PHY speed/duplex
+             *      if we are on 82543.  If we
+             *      are on newer silicon, we only need to configure
+             *      collision distance in the Transmit Control Register.
+             *   2) Set up flow control on the MAC to that established
+             *      with the link partner.
+             */
+            if(shared->mac_type >= e1000_82544)
+                e1000_config_collision_dist(shared);
+            else
+                e1000_config_mac_to_phy(shared, data);
+
+            e1000_config_fc_after_link_up(shared);
+
+            return (TRUE);
+        }
+    }
+
+    /* Options:
+     *   MDI/MDI-X = 0 (default)
+     *   0 - Auto for all speeds
+     *   1 - MDI mode
+     *   2 - MDI-X mode
+     *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
+     */
+    phy_specific_ctrl_reg = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    phy_specific_ctrl_reg &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+    switch (shared->mdix) {
+    case 1:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_MDI_MANUAL_MODE;
+        break;
+    case 2:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_MDIX_MANUAL_MODE;
+        break;
+    case 3:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_AUTO_X_1000T;
+        break;
+    case 0:
+    default:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_AUTO_X_MODE;
+        break;
+    }
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_specific_ctrl_reg);
+
+    /* Options:
+     *   disable_polarity_correction = 0 (default)
+     *       Automatic Correction for Reversed Cable Polarity
+     *   0 - Disabled
+     *   1 - Enabled
+     */
+    phy_specific_ctrl_reg = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    phy_specific_ctrl_reg &= ~M88E1000_PSCR_POLARITY_REVERSAL;
+
+    if(shared->disable_polarity_correction == 1)
+        phy_specific_ctrl_reg |= M88E1000_PSCR_POLARITY_REVERSAL;
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_specific_ctrl_reg);
+
+    /* Options:
+     *   autoneg = 1 (default)
+     *      PHY will advertise value(s) parsed from
+     *      autoneg_advertised and fc
+     *   autoneg = 0
+     *      PHY will be set to 10H, 10F, 100H, or 100F
+     *      depending on value parsed from forced_speed_duplex.
+     */
+
+    /* Is autoneg enabled?  This is enabled by default or by software override.
+     * If so, call e1000_phy_setup_autoneg routine to parse the
+     * autoneg_advertised and fc options. If autoneg is NOT enabled, then the
+     * user should have provided a speed/duplex override.  If so, then call
+     * e1000_phy_force_speed_duplex to parse and set this up.  Otherwise,
+     * we are in an error situation and need to bail.
+     */
+    if(shared->autoneg) {
+        DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
+        restart_autoneg = e1000_phy_setup_autoneg(shared);
+    } else {
+        DEBUGOUT("Forcing speed and duplex\n");
+        e1000_phy_force_speed_duplex(shared);
+    }
+
+    /* Based on information parsed above, check the flag to indicate
+     * whether we need to restart Auto-Neg.
+     */
+    if(restart_autoneg) {
+        DEBUGOUT("Restarting Auto-Neg\n");
+
+        /* Read the MII Control Register. */
+        mii_ctrl_reg = e1000_read_phy_reg(shared, PHY_CTRL);
+
+        /* Restart auto-negotiation by setting the Auto Neg Enable bit and
+         * the Auto Neg Restart bit.
+         */
+        mii_ctrl_reg |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
+
+        e1000_write_phy_reg(shared, PHY_CTRL, mii_ctrl_reg);
+
+        /* Does the user want to wait for Auto-Neg to complete here, or
+         * check at a later time (for example, callback routine).
+         */
+        if(shared->wait_autoneg_complete)
+            e1000_wait_autoneg(shared);
+    } /* end if restart_autoneg */
+
+    /* Read the MII Status Register. */
+    mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+    DEBUGOUT1("Checking for link status - MII Status Reg contents = %x\n",
+              mii_status_reg);
+
+    /* Check link status.  Wait up to 100 microseconds for link to
+     * become valid.
+     */
+    for(i = 0; i < 10; i++) {
+        if(mii_status_reg & MII_SR_LINK_STATUS)
+            break;
+        usec_delay(10);
+        DEBUGOUT(". ");
+
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    }
+
+    if(mii_status_reg & MII_SR_LINK_STATUS) {
+        /* Yes, so configure MAC to PHY settings as well as flow control
+         * registers.
+         */
+        data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+
+        DEBUGOUT1("M88E1000 Phy Specific Status Reg contents = %x\n", data);
+
+        /* We have link, so we need to finish the config process:
+         *   1) Set up the MAC to the current PHY speed/duplex
+         *      if we are on 82543.  If we
+         *      are on newer silicon, we only need to configure
+         *      collision distance in the Transmit Control Register.
+         *   2) Set up flow control on the MAC to that established with
+         *      the link partner.
+         */
+        if(shared->mac_type >= e1000_82544)
+            e1000_config_collision_dist(shared);
+        else
+            e1000_config_mac_to_phy(shared, data);
+
+        e1000_config_fc_after_link_up(shared);
+
+        DEBUGOUT("Valid link established!!!\n");
+    } else {
+        DEBUGOUT("Unable to establish link!!!\n");
+    }
+
+    return (TRUE);
+}
+
+/******************************************************************************
+* Configures PHY autoneg and flow control advertisement settings
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+boolean_t
+e1000_phy_setup_autoneg(struct e1000_shared_adapter *shared)
+{
+    uint16_t mii_autoneg_adv_reg;
+    uint16_t mii_1000t_ctrl_reg;
+
+    DEBUGFUNC("e1000_phy_setup_autoneg");
+
+    /* Read the MII Auto-Neg Advertisement Register (Address 4). */
+    mii_autoneg_adv_reg = e1000_read_phy_reg(shared, PHY_AUTONEG_ADV);
+
+    /* Read the MII 1000Base-T Control Register (Address 9). */
+    mii_1000t_ctrl_reg = e1000_read_phy_reg(shared, PHY_1000T_CTRL);
+
+    /* Need to parse both autoneg_advertised and fc and set up
+     * the appropriate PHY registers.  First we will parse for
+     * autoneg_advertised software override.  Since we can advertise
+     * a plethora of combinations, we need to check each bit
+     * individually.
+     */
+
+    /* First we clear all the 10/100 mb speed bits in the Auto-Neg
+     * Advertisement Register (Address 4) and the 1000 mb speed bits in
+     * the  1000Base-T Control Register (Address 9).
+     */
+    mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
+    mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
+
+    DEBUGOUT1("autoneg_advertised %x\n", shared->autoneg_advertised);
+
+    /* Do we want to advertise 10 Mb Half Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_10_HALF) {
+        DEBUGOUT("Advertise 10mb Half duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
+    }
+
+    /* Do we want to advertise 10 Mb Full Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_10_FULL) {
+        DEBUGOUT("Advertise 10mb Full duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
+    }
+
+    /* Do we want to advertise 100 Mb Half Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_100_HALF) {
+        DEBUGOUT("Advertise 100mb Half duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
+    }
+
+    /* Do we want to advertise 100 Mb Full Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_100_FULL) {
+        DEBUGOUT("Advertise 100mb Full duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
+    }
+
+    /* We do not allow the Phy to advertise 1000 Mb Half Duplex */
+    if(shared->autoneg_advertised & ADVERTISE_1000_HALF) {
+        DEBUGOUT("Advertise 1000mb Half duplex requested, request denied!\n");
+    }
+
+    /* Do we want to advertise 1000 Mb Full Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_1000_FULL) {
+        DEBUGOUT("Advertise 1000mb Full duplex\n");
+        mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
+    }
+
+    /* Check for a software override of the flow control settings, and
+     * setup the PHY advertisement registers accordingly.  If
+     * auto-negotiation is enabled, then software will have to set the
+     * "PAUSE" bits to the correct value in the Auto-Negotiation
+     * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.
+     *
+     * The possible values of the "fc" parameter are:
+     *      0:  Flow control is completely disabled
+     *      1:  Rx flow control is enabled (we can receive pause frames
+     *          but not send pause frames).
+     *      2:  Tx flow control is enabled (we can send pause frames
+     *          but we do not support receiving pause frames).
+     *      3:  Both Rx and TX flow control (symmetric) are enabled.
+     *  other:  No software override.  The flow control configuration
+     *          in the EEPROM is used.
+     */
+    switch (shared->fc) {
+    case e1000_fc_none:        /* 0 */
+            /* Flow control (RX & TX) is completely disabled by a
+             * software over-ride.
+             */
+        mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+        break;
+    case e1000_fc_rx_pause:    /* 1 */
+            /* RX Flow control is enabled, and TX Flow control is
+             * disabled, by a software over-ride.
+             */
+
+            /* Since there really isn't a way to advertise that we are
+             * capable of RX Pause ONLY, we will advertise that we
+             * support both symmetric and asymmetric RX PAUSE.  Later
+             * (in e1000_config_fc_after_link_up) we will disable the
+             *shared's ability to send PAUSE frames.
+             */
+        mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+        break;
+    case e1000_fc_tx_pause:    /* 2 */
+            /* TX Flow control is enabled, and RX Flow control is
+             * disabled, by a software over-ride.
+             */
+        mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
+        mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
+        break;
+    case e1000_fc_full:        /* 3 */
+            /* Flow control (both RX and TX) is enabled by a software
+             * over-ride.
+             */
+        mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+        break;
+    default:
+            /* We should never get here.  The value should be 0-3. */
+        DEBUGOUT("Flow control param set incorrectly\n");
+        ASSERT(0);
+        break;
+    }
+
+    /* Write the MII Auto-Neg Advertisement Register (Address 4). */
+    e1000_write_phy_reg(shared, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);
+
+    DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
+
+    /* Write the MII 1000Base-T Control Register (Address 9). */
+    e1000_write_phy_reg(shared, PHY_1000T_CTRL, mii_1000t_ctrl_reg);
+    return (TRUE);
+}
+
+/******************************************************************************
+* Sets MAC speed and duplex settings to reflect the those in the PHY
+*
+* shared - Struct containing variables accessed by shared code
+* mii_reg - data to write to the MII control register
+*
+* The contents of the PHY register containing the needed information need to
+* be passed in.
+******************************************************************************/
+void
+e1000_config_mac_to_phy(struct e1000_shared_adapter *shared,
+                        uint16_t mii_reg)
+{
+    uint32_t ctrl_reg;
+    uint32_t tctl_reg;
+    uint32_t shift;
+
+    DEBUGFUNC("e1000_config_mac_to_phy");
+
+    /* We need to read the Transmit Control register to configure the
+     * collision distance.
+     * Note: This must be done for both Half or Full Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    DEBUGOUT1("tctl_reg = %x\n", tctl_reg);
+
+    /* Read the Device Control Register and set the bits to Force Speed
+     * and Duplex.
+     */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    ctrl_reg |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+    ctrl_reg &= ~(DEVICE_SPEED_MASK);
+
+    DEBUGOUT1("MII Register Data = %x\r\n", mii_reg);
+
+    /* Clear the ILOS bit. */
+    ctrl_reg &= ~E1000_CTRL_ILOS;
+
+    /* Set up duplex in the Device Control and Transmit Control
+     * registers depending on negotiated values.
+     */
+    if(mii_reg & M88E1000_PSSR_DPLX) {
+        ctrl_reg |= E1000_CTRL_FD;
+
+        /* We are in Full Duplex mode.  We have the same collision
+         * distance regardless of speed.
+         */
+        tctl_reg &= ~E1000_TCTL_COLD;
+        shift = E1000_FDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    } else {
+        ctrl_reg &= ~E1000_CTRL_FD;
+
+        /* We are in Half Duplex mode.  Our Half Duplex collision
+         * distance is different for Gigabit than for 10/100 so we will
+         * set accordingly.
+         */
+        if((mii_reg & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) { 
+            /* 1000Mbs HDX */
+            tctl_reg &= ~E1000_TCTL_COLD;
+            shift = E1000_GB_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+            tctl_reg |= E1000_TCTL_PBE; /* Enable Packet Bursting */
+        } else {
+            /* 10/100Mbs HDX */
+            tctl_reg &= ~E1000_TCTL_COLD;
+            shift = E1000_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+        }
+    }
+
+    /* Set up speed in the Device Control register depending on
+     * negotiated values.
+     */
+    if((mii_reg & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
+        ctrl_reg |= E1000_CTRL_SPD_1000;
+    else if((mii_reg & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
+        ctrl_reg |= E1000_CTRL_SPD_100;
+    else
+        ctrl_reg &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
+
+    /* Write the configured values back to the Transmit Control Reg. */
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    /* Write the configured values back to the Device Control Reg. */
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    return;
+}
+
+/******************************************************************************
+* Sets the collision distance in the Transmit Control register
+*
+* shared - Struct containing variables accessed by shared code
+*
+* Link should have been established previously. Reads the speed and duplex
+* information from the Device Status register.
+******************************************************************************/
+void
+e1000_config_collision_dist(struct e1000_shared_adapter *shared)
+{
+    uint32_t tctl_reg;
+    uint16_t speed;
+    uint16_t duplex;
+    uint32_t shift;
+
+    DEBUGFUNC("e1000_config_collision_dist");
+
+    /* Get our current speed and duplex from the Device Status Register. */
+    e1000_get_speed_and_duplex(shared, &speed, &duplex);
+
+    /* We need to configure the Collision Distance for both Full or
+     * Half Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    DEBUGOUT1("tctl_reg = %x\n", tctl_reg);
+
+    /* mask the Collision Distance bits in the Transmit Control Reg. */
+    tctl_reg &= ~E1000_TCTL_COLD;
+
+    if(duplex == FULL_DUPLEX) {
+        /* We are in Full Duplex mode.  Therefore, the collision distance
+         * is the same regardless of speed.
+         */
+        shift = E1000_FDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    } else {
+        /* We are in Half Duplex mode.  Half Duplex collision distance is
+         * different for Gigabit vs. 10/100, so we will set accordingly.
+         */
+        if(speed == SPEED_1000) {       /* 1000Mbs HDX */
+            shift = E1000_GB_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+            tctl_reg |= E1000_TCTL_PBE; /* Enable Packet Bursting */
+        } else {                /* 10/100Mbs HDX */
+            shift = E1000_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+        }
+    }
+
+    /* Write the configured values back to the Transmit Control Reg. */
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    return;
+}
+
+#if DBG
+/******************************************************************************
+* Displays the contents of all of the MII registers
+*
+* shared - Struct containing variables accessed by shared code
+*
+* For debugging.
+******************************************************************************/
+void
+e1000_display_mii(struct e1000_shared_adapter *shared)
+{
+    uint16_t data;
+    uint16_t phy_id_high;
+    uint16_t phy_id_low;
+    uint32_t phy_id;
+
+    DEBUGFUNC("e1000_display_mii");
+
+    DEBUGOUT1("adapter Base Address = %x\n", shared->hw_addr);
+
+    /* This will read each PHY Reg address and display its contents. */
+
+    data = e1000_read_phy_reg(shared, PHY_CTRL);
+    DEBUGOUT1("MII Ctrl Reg contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_STATUS);
+    data = e1000_read_phy_reg(shared, PHY_STATUS);
+    DEBUGOUT1("MII Status Reg contents = %x\n", data);
+
+    phy_id_high = e1000_read_phy_reg(shared, PHY_ID1);
+    usec_delay(2);
+    phy_id_low = e1000_read_phy_reg(shared, PHY_ID2);
+    phy_id = (phy_id_low | (phy_id_high << 16)) & PHY_REVISION_MASK;
+    DEBUGOUT1("Phy ID = %x \n", phy_id);
+
+    data = e1000_read_phy_reg(shared, PHY_AUTONEG_ADV);
+    DEBUGOUT1("Reg 4 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_LP_ABILITY);
+    DEBUGOUT1("Reg 5 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_AUTONEG_EXP);
+    DEBUGOUT1("Reg 6 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_NEXT_PAGE_TX);
+    DEBUGOUT1("Reg 7 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_LP_NEXT_PAGE);
+    DEBUGOUT1("Reg 8 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_1000T_CTRL);
+    DEBUGOUT1("Reg 9 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_1000T_STATUS);
+    DEBUGOUT1("Reg A contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_EXT_STATUS);
+    DEBUGOUT1("Reg F contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+    DEBUGOUT1("M88E1000 Specific Control Reg (0x10) = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+    DEBUGOUT1("M88E1000 Specific Status Reg (0x11) = %x\n", data);
+
+    /*
+     * data = e1000_read_phy_reg(shared, M88E1000_INT_ENABLE_REG);
+     * DEBUGOUT1("M88E1000 Interrupt Enable Reg (0x12) = %x\n", data);
+     */
+
+    /*
+     * data = e1000_read_phy_reg(shared, M88E1000_INT_STATUS_REG);
+     * DEBUGOUT1("M88E1000 Interrupt Status Reg (0x13) = %x\n", data);
+     */
+     
+    data = e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+    DEBUGOUT1("M88E1000 Ext. Phy Specific Control (0x14) = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_RX_ERR_CNTR);
+    DEBUGOUT1("M88E1000 Receive Error Counter (0x15) = %x\n", data);
+
+    /*
+     * data = e1000_read_phy_reg(shared, M88E1000_LED_CTRL_REG);
+     * DEBUGOUT1("M88E1000 LED control reg (0x18) = %x\n", data);
+     */
+
+    return;
+}
+#endif // DBG
+
+/******************************************************************************
+* Probes the expected PHY address for known PHY IDs
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+boolean_t
+e1000_detect_gig_phy(struct e1000_shared_adapter *shared)
+{
+    uint32_t phy_id_high;
+    uint16_t phy_id_low;
+
+    DEBUGFUNC("e1000_detect_gig_phy");
+
+    /* Read the PHY ID Registers to identify which PHY is onboard. */
+    shared->phy_addr = 1;
+
+    phy_id_high = e1000_read_phy_reg(shared, PHY_ID1);
+
+    usec_delay(2);
+
+    phy_id_low = e1000_read_phy_reg(shared, PHY_ID2);
+
+    shared->phy_id = (phy_id_low | (phy_id_high << 16)) & PHY_REVISION_MASK;
+
+    if(shared->phy_id == M88E1000_12_PHY_ID ||
+       shared->phy_id == M88E1000_14_PHY_ID ||
+       shared->phy_id == M88E1000_I_PHY_ID  ||
+       shared->phy_id == M88E1011_I_PHY_ID) {
+
+        DEBUGOUT2("phy_id 0x%x detected at address 0x%x\n",
+                  shared->phy_id, shared->phy_addr);
+        return (TRUE);
+    } else {
+        DEBUGOUT("Could not auto-detect Phy!\n");
+        return (FALSE);
+    }
+}
+
+/******************************************************************************
+* Resets the PHY's DSP
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+void
+e1000_phy_reset_dsp(struct e1000_shared_adapter *shared)
+{
+    e1000_write_phy_reg(shared, 29, 0x1d);
+    e1000_write_phy_reg(shared, 30, 0xc1);
+    e1000_write_phy_reg(shared, 30, 0x00);
+    return;
+}
+
+/******************************************************************************
+* Blocks until autoneg completes or times out (~4.5 seconds)
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+boolean_t
+e1000_wait_autoneg(struct e1000_shared_adapter *shared)
+{
+    uint16_t i;
+    uint16_t mii_status_reg;
+    boolean_t autoneg_complete = FALSE;
+
+    DEBUGFUNC("e1000_wait_autoneg");
+
+    /* We will wait for autoneg to complete. */
+    DEBUGOUT("Waiting for Auto-Neg to complete.\n");
+    mii_status_reg = 0;
+
+    /* We will wait for autoneg to complete or 4.5 seconds to expire. */
+
+    for(i = PHY_AUTO_NEG_TIME; i > 0; i--) {
+        /* Read the MII Status Register and wait for Auto-Neg
+         * Complete bit to be set.
+         */
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
+            autoneg_complete = TRUE;
+            break;
+        }
+
+        msec_delay(100);
+    }
+
+    return (autoneg_complete);
+}
+
+/******************************************************************************
+* Get PHY information from various PHY registers
+*
+* shared - Struct containing variables accessed by shared code
+* phy_status_info - PHY information structure
+******************************************************************************/
+boolean_t
+e1000_phy_get_info(struct e1000_shared_adapter *shared,
+                   struct e1000_phy_info *phy_status_info)
+{
+    uint16_t phy_mii_status_reg;
+    uint16_t phy_specific_ctrl_reg;
+    uint16_t phy_specific_status_reg;
+    uint16_t phy_specific_ext_ctrl_reg;
+    uint16_t phy_1000t_stat_reg;
+
+    phy_status_info->cable_length = e1000_cable_length_undefined;
+    phy_status_info->extended_10bt_distance =
+        e1000_10bt_ext_dist_enable_undefined;
+    phy_status_info->cable_polarity = e1000_rev_polarity_undefined;
+    phy_status_info->polarity_correction = e1000_polarity_reversal_undefined;
+    phy_status_info->link_reset = e1000_down_no_idle_undefined;
+    phy_status_info->mdix_mode = e1000_auto_x_mode_undefined;
+    phy_status_info->local_rx = e1000_1000t_rx_status_undefined;
+    phy_status_info->remote_rx = e1000_1000t_rx_status_undefined;
+
+    /* PHY info only valid for copper media. */
+    if(shared == NULL || shared->media_type != e1000_media_type_copper)
+        return FALSE;
+
+    /* PHY info only valid for LINK UP.  Read MII status reg 
+     * back-to-back to get link status.
+     */
+    phy_mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    phy_mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    if((phy_mii_status_reg & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS)
+        return FALSE;
+
+    /* Read various PHY registers to get the PHY info. */
+    phy_specific_ctrl_reg = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+    phy_specific_status_reg =
+        e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+    phy_specific_ext_ctrl_reg =
+        e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+    phy_1000t_stat_reg = e1000_read_phy_reg(shared, PHY_1000T_STATUS);
+
+    phy_status_info->cable_length =
+        ((phy_specific_status_reg & M88E1000_PSSR_CABLE_LENGTH) >>
+         M88E1000_PSSR_CABLE_LENGTH_SHIFT);
+
+    phy_status_info->extended_10bt_distance =
+        (phy_specific_ctrl_reg & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
+        M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT;
+
+    phy_status_info->cable_polarity =
+        (phy_specific_status_reg & M88E1000_PSSR_REV_POLARITY) >>
+        M88E1000_PSSR_REV_POLARITY_SHIFT;
+
+    phy_status_info->polarity_correction =
+        (phy_specific_ctrl_reg & M88E1000_PSCR_POLARITY_REVERSAL) >>
+        M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;
+
+    phy_status_info->link_reset =
+        (phy_specific_ext_ctrl_reg & M88E1000_EPSCR_DOWN_NO_IDLE) >>
+        M88E1000_EPSCR_DOWN_NO_IDLE_SHIFT;
+
+    phy_status_info->mdix_mode =
+        (phy_specific_status_reg & M88E1000_PSSR_MDIX) >>
+        M88E1000_PSSR_MDIX_SHIFT;
+
+    phy_status_info->local_rx =
+        (phy_1000t_stat_reg & SR_1000T_LOCAL_RX_STATUS) >>
+        SR_1000T_LOCAL_RX_STATUS_SHIFT;
+
+    phy_status_info->remote_rx =
+        (phy_1000t_stat_reg & SR_1000T_REMOTE_RX_STATUS) >>
+        SR_1000T_REMOTE_RX_STATUS_SHIFT;
+
+    return TRUE;
+}
+
+boolean_t
+e1000_validate_mdi_setting(struct e1000_shared_adapter *shared)
+{
+    if(!shared->autoneg && (shared->mdix == 0 || shared->mdix == 3)) {
+        shared->mdix = 1;
+        return FALSE;
+    }
+    return TRUE;
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_phy.h linux/drivers/net/e1000/e1000_phy.h
--- ../prev/linux/drivers/net/e1000/e1000_phy.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_phy.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,424 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_phy.h
+ * Structures, enums, and macros for the PHY
+ */
+
+#ifndef _E1000_PHY_H_
+#define _E1000_PHY_H_
+
+#include "e1000_osdep.h"
+
+/* PHY status info structure and supporting enums */
+typedef enum {
+    e1000_cable_length_50 = 0,
+    e1000_cable_length_50_80,
+    e1000_cable_length_80_110,
+    e1000_cable_length_110_140,
+    e1000_cable_length_140,
+    e1000_cable_length_undefined = 0xFF
+} e1000_cable_length;
+
+typedef enum {
+    e1000_10bt_ext_dist_enable_normal = 0,
+    e1000_10bt_ext_dist_enable_lower,
+    e1000_10bt_ext_dist_enable_undefined = 0xFF
+} e1000_10bt_ext_dist_enable;
+
+typedef enum {
+    e1000_rev_polarity_normal = 0,
+    e1000_rev_polarity_reversed,
+    e1000_rev_polarity_undefined = 0xFF
+} e1000_rev_polarity;
+
+typedef enum {
+    e1000_polarity_reversal_enabled = 0,
+    e1000_polarity_reversal_disabled,
+    e1000_polarity_reversal_undefined = 0xFF
+} e1000_polarity_reversal;
+
+typedef enum {
+    e1000_down_no_idle_no_detect = 0,
+    e1000_down_no_idle_detect,
+    e1000_down_no_idle_undefined = 0xFF
+} e1000_down_no_idle;
+
+typedef enum {
+    e1000_auto_x_mode_manual_mdi = 0,
+    e1000_auto_x_mode_manual_mdix,
+    e1000_auto_x_mode_auto1,
+    e1000_auto_x_mode_auto2,
+    e1000_auto_x_mode_undefined = 0xFF
+} e1000_auto_x_mode;
+
+typedef enum {
+    e1000_1000t_rx_status_not_ok = 0,
+    e1000_1000t_rx_status_ok,
+    e1000_1000t_rx_status_undefined = 0xFF
+} e1000_1000t_rx_status;
+
+struct e1000_phy_info {
+    e1000_cable_length cable_length;
+    e1000_10bt_ext_dist_enable extended_10bt_distance;
+    e1000_rev_polarity cable_polarity;
+    e1000_polarity_reversal polarity_correction;
+    e1000_down_no_idle link_reset;
+    e1000_auto_x_mode mdix_mode;
+    e1000_1000t_rx_status local_rx;
+    e1000_1000t_rx_status remote_rx;
+};
+
+struct e1000_phy_stats {
+    uint32_t idle_errors;
+    uint32_t receive_errors;
+};
+
+/* Function Prototypes */
+uint16_t e1000_read_phy_reg(struct e1000_shared_adapter *shared, uint32_t reg_addr);
+void e1000_write_phy_reg(struct e1000_shared_adapter *shared, uint32_t reg_addr, uint16_t data);
+void e1000_phy_hw_reset(struct e1000_shared_adapter *shared);
+boolean_t e1000_phy_reset(struct e1000_shared_adapter *shared);
+boolean_t e1000_phy_setup(struct e1000_shared_adapter *shared, uint32_t ctrl_reg);
+boolean_t e1000_phy_setup_autoneg(struct e1000_shared_adapter *shared);
+void e1000_config_mac_to_phy(struct e1000_shared_adapter *shared, uint16_t mii_reg);
+void e1000_config_collision_dist(struct e1000_shared_adapter *shared);
+void e1000_display_mii(struct e1000_shared_adapter *shared);
+boolean_t e1000_detect_gig_phy(struct e1000_shared_adapter *shared);
+void e1000_phy_reset_dsp(struct e1000_shared_adapter *shared);
+boolean_t e1000_wait_autoneg(struct e1000_shared_adapter *shared);
+boolean_t e1000_phy_get_info(struct e1000_shared_adapter *shared, struct e1000_phy_info *phy_status_info);
+boolean_t e1000_validate_mdi_setting(struct e1000_shared_adapter *shared);
+
+/* Bit definitions for the Management Data IO (MDIO) and Management Data
+ * Clock (MDC) pins in the Device Control Register.
+ */
+#define E1000_CTRL_PHY_RESET_DIR  E1000_CTRL_SWDPIO0
+#define E1000_CTRL_PHY_RESET      E1000_CTRL_SWDPIN0
+#define E1000_CTRL_MDIO_DIR       E1000_CTRL_SWDPIO2
+#define E1000_CTRL_MDIO           E1000_CTRL_SWDPIN2
+#define E1000_CTRL_MDC_DIR        E1000_CTRL_SWDPIO3
+#define E1000_CTRL_MDC            E1000_CTRL_SWDPIN3
+#define E1000_CTRL_PHY_RESET_DIR4 E1000_CTRL_EXT_SDP4_DIR
+#define E1000_CTRL_PHY_RESET4     E1000_CTRL_EXT_SDP4_DATA
+
+/* PHY 1000 MII Register/Bit Definitions */
+/* PHY Registers defined by IEEE */
+#define PHY_CTRL         0x00 /* Control Register */
+#define PHY_STATUS       0x01 /* Status Regiser */
+#define PHY_ID1          0x02 /* Phy Id Reg (word 1) */
+#define PHY_ID2          0x03 /* Phy Id Reg (word 2) */
+#define PHY_AUTONEG_ADV  0x04 /* Autoneg Advertisement */
+#define PHY_LP_ABILITY   0x05 /* Link Partner Ability (Base Page) */
+#define PHY_AUTONEG_EXP  0x06 /* Autoneg Expansion Reg */
+#define PHY_NEXT_PAGE_TX 0x07 /* Next Page TX */
+#define PHY_LP_NEXT_PAGE 0x08 /* Link Partner Next Page */
+#define PHY_1000T_CTRL   0x09 /* 1000Base-T Control Reg */
+#define PHY_1000T_STATUS 0x0A /* 1000Base-T Status Reg */
+#define PHY_EXT_STATUS   0x0F /* Extended Status Reg */
+
+/* M88E1000 Specific Registers */
+#define M88E1000_PHY_SPEC_CTRL     0x10  /* PHY Specific Control Register */
+#define M88E1000_PHY_SPEC_STATUS   0x11  /* PHY Specific Status Register */
+#define M88E1000_INT_ENABLE        0x12  /* Interrupt Enable Register */
+#define M88E1000_INT_STATUS        0x13  /* Interrupt Status Register */
+#define M88E1000_EXT_PHY_SPEC_CTRL 0x14  /* Extended PHY Specific Control */
+#define M88E1000_RX_ERR_CNTR       0x15  /* Receive Error Counter */
+
+#define MAX_PHY_REG_ADDRESS 0x1F        /* 5 bit address bus (0-0x1F) */
+
+/* PHY Control Register */
+#define MII_CR_SPEED_SELECT_MSB 0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_COLL_TEST_ENABLE 0x0080  /* Collision test enable */
+#define MII_CR_FULL_DUPLEX      0x0100  /* FDX =1, half duplex =0 */
+#define MII_CR_RESTART_AUTO_NEG 0x0200  /* Restart auto negotiation */
+#define MII_CR_ISOLATE          0x0400  /* Isolate PHY from MII */
+#define MII_CR_POWER_DOWN       0x0800  /* Power down */
+#define MII_CR_AUTO_NEG_EN      0x1000  /* Auto Neg Enable */
+#define MII_CR_SPEED_SELECT_LSB 0x2000  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_LOOPBACK         0x4000  /* 0 = normal, 1 = loopback */
+#define MII_CR_RESET            0x8000  /* 0 = normal, 1 = PHY reset */
+
+/* PHY Status Register */
+#define MII_SR_EXTENDED_CAPS     0x0001 /* Extended register capabilities */
+#define MII_SR_JABBER_DETECT     0x0002 /* Jabber Detected */
+#define MII_SR_LINK_STATUS       0x0004 /* Link Status 1 = link */
+#define MII_SR_AUTONEG_CAPS      0x0008 /* Auto Neg Capable */
+#define MII_SR_REMOTE_FAULT      0x0010 /* Remote Fault Detect */
+#define MII_SR_AUTONEG_COMPLETE  0x0020 /* Auto Neg Complete */
+#define MII_SR_PREAMBLE_SUPPRESS 0x0040 /* Preamble may be suppressed */
+#define MII_SR_EXTENDED_STATUS   0x0100 /* Ext. status info in Reg 0x0F */
+#define MII_SR_100T2_HD_CAPS     0x0200 /* 100T2 Half Duplex Capable */
+#define MII_SR_100T2_FD_CAPS     0x0400 /* 100T2 Full Duplex Capable */
+#define MII_SR_10T_HD_CAPS       0x0800 /* 10T   Half Duplex Capable */
+#define MII_SR_10T_FD_CAPS       0x1000 /* 10T   Full Duplex Capable */
+#define MII_SR_100X_HD_CAPS      0x2000 /* 100X  Half Duplex Capable */
+#define MII_SR_100X_FD_CAPS      0x4000 /* 100X  Full Duplex Capable */
+#define MII_SR_100T4_CAPS        0x8000 /* 100T4 Capable */
+
+/* Autoneg Advertisement Register */
+#define NWAY_AR_SELECTOR_FIELD 0x0001   /* indicates IEEE 802.3 CSMA/CD */
+#define NWAY_AR_10T_HD_CAPS    0x0020   /* 10T   Half Duplex Capable */
+#define NWAY_AR_10T_FD_CAPS    0x0040   /* 10T   Full Duplex Capable */
+#define NWAY_AR_100TX_HD_CAPS  0x0080   /* 100TX Half Duplex Capable */
+#define NWAY_AR_100TX_FD_CAPS  0x0100   /* 100TX Full Duplex Capable */
+#define NWAY_AR_100T4_CAPS     0x0200   /* 100T4 Capable */
+#define NWAY_AR_PAUSE          0x0400   /* Pause operation desired */
+#define NWAY_AR_ASM_DIR        0x0800   /* Asymmetric Pause Direction bit */
+#define NWAY_AR_REMOTE_FAULT   0x2000   /* Remote Fault detected */
+#define NWAY_AR_NEXT_PAGE      0x8000   /* Next Page ability supported */
+
+/* Link Partner Ability Register (Base Page) */
+#define NWAY_LPAR_SELECTOR_FIELD 0x0000 /* LP protocol selector field */
+#define NWAY_LPAR_10T_HD_CAPS    0x0020 /* LP is 10T   Half Duplex Capable */
+#define NWAY_LPAR_10T_FD_CAPS    0x0040 /* LP is 10T   Full Duplex Capable */
+#define NWAY_LPAR_100TX_HD_CAPS  0x0080 /* LP is 100TX Half Duplex Capable */
+#define NWAY_LPAR_100TX_FD_CAPS  0x0100 /* LP is 100TX Full Duplex Capable */
+#define NWAY_LPAR_100T4_CAPS     0x0200 /* LP is 100T4 Capable */
+#define NWAY_LPAR_PAUSE          0x0400 /* LP Pause operation desired */
+#define NWAY_LPAR_ASM_DIR        0x0800 /* LP Asymmetric Pause Direction bit */
+#define NWAY_LPAR_REMOTE_FAULT   0x2000 /* LP has detected Remote Fault */
+#define NWAY_LPAR_ACKNOWLEDGE    0x4000 /* LP has rx'd link code word */
+#define NWAY_LPAR_NEXT_PAGE      0x8000 /* Next Page ability supported */
+
+/* Autoneg Expansion Register */
+#define NWAY_ER_LP_NWAY_CAPS      0x0001 /* LP has Auto Neg Capability */
+#define NWAY_ER_PAGE_RXD          0x0002 /* LP is 10T   Half Duplex Capable */
+#define NWAY_ER_NEXT_PAGE_CAPS    0x0004 /* LP is 10T   Full Duplex Capable */
+#define NWAY_ER_LP_NEXT_PAGE_CAPS 0x0008 /* LP is 100TX Half Duplex Capable */
+#define NWAY_ER_PAR_DETECT_FAULT  0x0100 /* LP is 100TX Full Duplex Capable */
+
+/* Next Page TX Register */
+#define NPTX_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define NPTX_TOGGLE         0x0800 /* Toggles between exchanges
+                                    * of different NP
+                                    */
+#define NPTX_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg
+                                    * 0 = cannot comply with msg
+                                    */
+#define NPTX_MSG_PAGE       0x2000 /* formatted(1)/unformatted(0) pg */
+#define NPTX_NEXT_PAGE      0x8000 /* 1 = addition NP will follow 
+                                    * 0 = sending last NP
+                                    */
+
+/* Link Partner Next Page Register */
+#define LP_RNPR_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define LP_RNPR_TOGGLE         0x0800 /* Toggles between exchanges
+                                       * of different NP
+                                       */
+#define LP_RNPR_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg 
+                                       * 0 = cannot comply with msg
+                                       */
+#define LP_RNPR_MSG_PAGE       0x2000  /* formatted(1)/unformatted(0) pg */
+#define LP_RNPR_ACKNOWLDGE     0x4000  /* 1 = ACK / 0 = NO ACK */
+#define LP_RNPR_NEXT_PAGE      0x8000  /* 1 = addition NP will follow
+                                        * 0 = sending last NP 
+                                        */
+
+/* 1000BASE-T Control Register */
+#define CR_1000T_ASYM_PAUSE      0x0080 /* Advertise asymmetric pause bit */
+#define CR_1000T_HD_CAPS         0x0100 /* Advertise 1000T HD capability */
+#define CR_1000T_FD_CAPS         0x0200 /* Advertise 1000T FD capability  */
+#define CR_1000T_REPEATER_DTE    0x0400 /* 1=Repeater/switch device port */
+                                        /* 0=DTE device */
+#define CR_1000T_MS_VALUE        0x0800 /* 1=Configure PHY as Master */
+                                        /* 0=Configure PHY as Slave */
+#define CR_1000T_MS_ENABLE       0x1000 /* 1=Master/Slave manual config value */
+                                        /* 0=Automatic Master/Slave config */
+#define CR_1000T_TEST_MODE_NORMAL 0x0000 /* Normal Operation */
+#define CR_1000T_TEST_MODE_1     0x2000 /* Transmit Waveform test */
+#define CR_1000T_TEST_MODE_2     0x4000 /* Master Transmit Jitter test */
+#define CR_1000T_TEST_MODE_3     0x6000 /* Slave Transmit Jitter test */
+#define CR_1000T_TEST_MODE_4     0x8000 /* Transmitter Distortion test */
+
+/* 1000BASE-T Status Register */
+#define SR_1000T_IDLE_ERROR_CNT   0x00FF /* Num idle errors since last read */
+#define SR_1000T_ASYM_PAUSE_DIR   0x0100 /* LP asymmetric pause direction bit */
+#define SR_1000T_LP_HD_CAPS       0x0400 /* LP is 1000T HD capable */
+#define SR_1000T_LP_FD_CAPS       0x0800 /* LP is 1000T FD capable */
+#define SR_1000T_REMOTE_RX_STATUS 0x1000 /* Remote receiver OK */
+#define SR_1000T_LOCAL_RX_STATUS  0x2000 /* Local receiver OK */
+#define SR_1000T_MS_CONFIG_RES    0x4000 /* 1=Local TX is Master, 0=Slave */
+#define SR_1000T_MS_CONFIG_FAULT  0x8000 /* Master/Slave config fault */
+#define SR_1000T_REMOTE_RX_STATUS_SHIFT 12
+#define SR_1000T_LOCAL_RX_STATUS_SHIFT  13
+
+/* Extended Status Register */
+#define IEEE_ESR_1000T_HD_CAPS 0x1000 /* 1000T HD capable */
+#define IEEE_ESR_1000T_FD_CAPS 0x2000 /* 1000T FD capable */
+#define IEEE_ESR_1000X_HD_CAPS 0x4000 /* 1000X HD capable */
+#define IEEE_ESR_1000X_FD_CAPS 0x8000 /* 1000X FD capable */
+
+#define PHY_TX_POLARITY_MASK   0x0100 /* register 10h bit 8 (polarity bit) */
+#define PHY_TX_NORMAL_POLARITY 0      /* register 10h bit 8 (normal polarity) */
+
+#define AUTO_POLARITY_DISABLE  0x0010 /* register 11h bit 4 */
+                                      /* (0=enable, 1=disable) */
+
+/* M88E1000 PHY Specific Control Register */
+#define M88E1000_PSCR_JABBER_DISABLE    0x0001 /* 1=Jabber Function disabled */
+#define M88E1000_PSCR_POLARITY_REVERSAL 0x0002 /* 1=Polarity Reversal enabled */
+#define M88E1000_PSCR_SQE_TEST          0x0004 /* 1=SQE Test enabled */
+#define M88E1000_PSCR_CLK125_DISABLE    0x0010 /* 1=CLK125 low, 
+                                                * 0=CLK125 toggling
+                                                */
+#define M88E1000_PSCR_MDI_MANUAL_MODE  0x0000  /* MDI Crossover Mode bits 6:5 */
+                                               /* Manual MDI configuration */
+#define M88E1000_PSCR_MDIX_MANUAL_MODE 0x0020  /* Manual MDIX configuration */
+#define M88E1000_PSCR_AUTO_X_1000T     0x0040  /* 1000BASE-T: Auto crossover,
+                                                *  100BASE-TX/10BASE-T: 
+                                                *  MDI Mode
+                                                */
+#define M88E1000_PSCR_AUTO_X_MODE      0x0060  /* Auto crossover enabled 
+                                                * all speeds. 
+                                                */
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE 0x0080 
+                                        /* 1=Enable Extended 10BASE-T distance
+                                         * (Lower 10BASE-T RX Threshold)
+                                         * 0=Normal 10BASE-T RX Threshold */
+#define M88E1000_PSCR_MII_5BIT_ENABLE      0x0100
+                                        /* 1=5-Bit interface in 100BASE-TX
+                                         * 0=MII interface in 100BASE-TX */
+#define M88E1000_PSCR_SCRAMBLER_DISABLE    0x0200 /* 1=Scrambler disable */
+#define M88E1000_PSCR_FORCE_LINK_GOOD      0x0400 /* 1=Force link good */
+#define M88E1000_PSCR_ASSERT_CRS_ON_TX     0x0800 /* 1=Assert CRS on Transmit */
+
+#define M88E1000_PSCR_POLARITY_REVERSAL_SHIFT    1
+#define M88E1000_PSCR_AUTO_X_MODE_SHIFT          5
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT 7
+
+/* M88E1000 PHY Specific Status Register */
+#define M88E1000_PSSR_JABBER             0x0001 /* 1=Jabber */
+#define M88E1000_PSSR_REV_POLARITY       0x0002 /* 1=Polarity reversed */
+#define M88E1000_PSSR_MDIX               0x0040 /* 1=MDIX; 0=MDI */
+#define M88E1000_PSSR_CABLE_LENGTH       0x0380 /* 0=<50M;1=50-80M;2=80-110M;
+                                            * 3=110-140M;4=>140M */
+#define M88E1000_PSSR_LINK               0x0400 /* 1=Link up, 0=Link down */
+#define M88E1000_PSSR_SPD_DPLX_RESOLVED  0x0800 /* 1=Speed & Duplex resolved */
+#define M88E1000_PSSR_PAGE_RCVD          0x1000 /* 1=Page received */
+#define M88E1000_PSSR_DPLX               0x2000 /* 1=Duplex 0=Half Duplex */
+#define M88E1000_PSSR_SPEED              0xC000 /* Speed, bits 14:15 */
+#define M88E1000_PSSR_10MBS              0x0000 /* 00=10Mbs */
+#define M88E1000_PSSR_100MBS             0x4000 /* 01=100Mbs */
+#define M88E1000_PSSR_1000MBS            0x8000 /* 10=1000Mbs */
+
+#define M88E1000_PSSR_REV_POLARITY_SHIFT 1
+#define M88E1000_PSSR_MDIX_SHIFT         6
+#define M88E1000_PSSR_CABLE_LENGTH_SHIFT 7
+
+/* M88E1000 Extended PHY Specific Control Register */
+#define M88E1000_EPSCR_FIBER_LOOPBACK 0x4000 /* 1=Fiber loopback */
+#define M88E1000_EPSCR_DOWN_NO_IDLE   0x8000 /* 1=Lost lock detect enabled.
+                                              * Will assert lost lock and bring
+                                              * link down if idle not seen
+                                              * within 1ms in 1000BASE-T 
+                                              */
+#define M88E1000_EPSCR_TX_CLK_2_5     0x0060 /* 2.5 MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_25      0x0070 /* 25  MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_0       0x0000 /* NO  TX_CLK */
+
+#define M88E1000_EPSCR_DOWN_NO_IDLE_SHIFT 15
+
+/* Bit definitions for valid PHY IDs. */
+#define M88E1000_12_PHY_ID 0x01410C50
+#define M88E1000_14_PHY_ID 0x01410C40
+#define M88E1000_I_PHY_ID  0x01410C30
+#define M88E1011_I_PHY_ID  0x01410C20
+
+/* Miscellaneous PHY bit definitions. */
+#define PHY_PREAMBLE        0xFFFFFFFF
+#define PHY_SOF             0x01
+#define PHY_OP_READ         0x02
+#define PHY_OP_WRITE        0x01
+#define PHY_TURNAROUND      0x02
+#define PHY_PREAMBLE_SIZE   32
+#define MII_CR_SPEED_1000   0x0040
+#define MII_CR_SPEED_100    0x2000
+#define MII_CR_SPEED_10     0x0000
+#define E1000_PHY_ADDRESS   0x01
+#define PHY_AUTO_NEG_TIME   45  /* 4.5 Seconds */
+#define PHY_FORCE_TIME      20  /* 2.0 Seconds */
+#define PHY_REVISION_MASK   0xFFFFFFF0
+#define DEVICE_SPEED_MASK   0x00000300  /* Device Ctrl Reg Speed Mask */
+#define REG4_SPEED_MASK     0x01E0
+#define REG9_SPEED_MASK     0x0300
+#define ADVERTISE_10_HALF   0x0001
+#define ADVERTISE_10_FULL   0x0002
+#define ADVERTISE_100_HALF  0x0004
+#define ADVERTISE_100_FULL  0x0008
+#define ADVERTISE_1000_HALF 0x0010
+#define ADVERTISE_1000_FULL 0x0020
+#define AUTONEG_ADVERTISE_SPEED_DEFAULT 0x002F  /* Everything but 1000-Half */
+
+#endif /* _E1000_PHY_H_ */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_proc.c linux/drivers/net/e1000/e1000_proc.c
--- ../prev/linux/drivers/net/e1000/e1000_proc.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_proc.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,1437 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/***************************************************************************/
+/*       /proc File System Interaface Support Functions                    */
+/***************************************************************************/
+
+#include "e1000.h"
+extern char e1000_driver_name[];
+extern char e1000_driver_version[];
+#include "e1000_proc.h"
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry *e1000_proc_dir;
+
+#define CABLE_LENGTH_TO_STRING() \
+   msg = \
+   (adapter->phy_info.cable_length == e1000_cable_length_50)      ? "0-50 Meters (+/- 20 Meters)"  : \
+   (adapter->phy_info.cable_length == e1000_cable_length_50_80)   ? "50-80 Meters (+/- 20 Meters)"  : \
+   (adapter->phy_info.cable_length == e1000_cable_length_80_110)  ? "80-110 Meters (+/- 20 Meters)" : \
+   (adapter->phy_info.cable_length == e1000_cable_length_110_140) ? "110-140 Meters (+/- 20 Meters)" : \
+   (adapter->phy_info.cable_length == e1000_cable_length_140)     ? "> 140 Meters (+/- 20 Meters)" : \
+   "Unknown";
+
+#define EXTENDED_10BASE_T_DISTANCE_TO_STRING() \
+    msg = \
+    (adapter->phy_info.extended_10bt_distance == \
+            e1000_10bt_ext_dist_enable_normal) ? "Disabled" : \
+    (adapter->phy_info.extended_10bt_distance == \
+                    e1000_10bt_ext_dist_enable_lower) ? "Enabled" : "Unknown"; 
+
+#define CABLE_POLARITY_TO_STRING() \
+    msg = \
+    (adapter->phy_info.cable_polarity == e1000_rev_polarity_normal) ? "Normal" : \
+    (adapter->phy_info.cable_polarity == e1000_rev_polarity_reversed) ? \
+                                        "Reversed" : "Unknown";
+
+#define POLARITY_CORRECTION_TO_STRING() \
+    msg = \
+    (adapter->phy_info.polarity_correction == \
+                    e1000_polarity_reversal_enabled) ? "Disabled" : \
+    (adapter->phy_info.polarity_correction == \
+                    e1000_polarity_reversal_disabled) ? "Enabled" : "Undefined";
+
+#define LINK_RESET_TO_STRING() \
+    msg = \
+    (adapter->phy_info.link_reset == e1000_down_no_idle_no_detect) ? "Disabled" : \
+    (adapter->phy_info.link_reset == e1000_down_no_idle_detect) ? "Enabled" : \
+    "Unknown"; 
+
+#define MDI_X_MODE_TO_STRING() \
+    msg = (adapter->phy_info.mdix_mode == 0) ? "MDI" :  "MDI-X";
+
+#define LOCAL_RECEIVER_STATUS_TO_STRING() \
+    msg = \
+    (adapter->phy_info.local_rx == e1000_1000t_rx_status_not_ok) ? "NOT_OK" : \
+    (adapter->phy_info.local_rx == e1000_1000t_rx_status_ok) ? "OK" : \
+    "Unknown";
+
+#define REMOTE_RECEIVER_STATUS_TO_STRING() \
+    msg = \
+    (adapter->phy_info.remote_rx == e1000_1000t_rx_status_not_ok) ? "NOT_OK" : \
+    (adapter->phy_info.remote_rx == e1000_1000t_rx_status_ok) ? "OK" : \
+    "Unknown";
+
+static void e1000_link_update(struct e1000_adapter * adapter) {
+
+    e1000_check_for_link(&adapter->shared);
+    if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_LU)
+        adapter->link_active = 1;
+    else
+        adapter->link_active = 0;
+
+    if (adapter->link_active) {
+        e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed, &adapter->link_duplex);
+    } else {
+        adapter->link_speed = 0;
+        adapter->link_duplex = 0;
+    }
+    return;
+}
+
+static int e1000_generic_read(char *page, char **start, off_t off,
+                              int count, int *eof)
+{
+    int len;
+
+    len = strlen(page);
+    page[len++] = '\n';
+
+    if (len <= off + count)
+        *eof = 1;
+    *start = page + off;
+    len -= off;
+    if (len > count)
+        len = count;
+    if (len < 0)
+        len = 0;
+    return len;
+}
+
+static int e1000_read_ulong(char *page, char **start, off_t off,
+               int count, int *eof, unsigned long l)
+{
+    sprintf(page, "%lu", l);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_ulong_hex(char *page, char **start, off_t off,
+                   int count, int *eof, unsigned long l)
+{
+    sprintf(page, "0x%04lx", l);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_ullong(char *page, char **start, off_t off,
+               int count, int *eof, unsigned long long l)
+{
+    sprintf(page, "%Lu", l);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_hwaddr(char *page, char **start, off_t off,
+                int count, int *eof, unsigned char *hwaddr)
+{
+    sprintf(page, "%02X:%02X:%02X:%02X:%02X:%02X",
+            hwaddr[0], hwaddr[1], hwaddr[2],
+            hwaddr[3], hwaddr[4], hwaddr[5]);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+/* need to check page boundaries !!! */
+static int e1000_read_info(char *page, char **start, off_t off,
+              int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    struct net_device_stats *stats = &adapter->net_stats;
+    unsigned char *hwaddr;
+    char *pagep = page;
+    char *msg;
+
+    page += sprintf(page, "%-32s %s\n", DESCRIPTION_TAG, adapter->id_string);
+    page += sprintf(page, "%-32s %06lx-%03x\n",
+                    PART_NUMBER_TAG, 
+                    (unsigned long )adapter->part_num >> 8, 
+                    adapter->part_num & 0x000000FF);
+
+    page += sprintf(page, "%-32s %s\n", DRVR_NAME_TAG, e1000_driver_name);
+
+    page += sprintf(page, "%-32s %s\n", DRVR_VERSION_TAG, e1000_driver_version);
+
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_VENDOR_TAG, (unsigned long) adapter->vendor_id);
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_DEVICE_ID_TAG, (unsigned long) adapter->device_id);
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_SUBSYSTEM_VENDOR_TAG,
+                    (unsigned long) adapter->subven_id);
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_SUBSYSTEM_ID_TAG,
+                    (unsigned long) adapter->subsys_id);
+    page += sprintf(page, "%-32s 0x%02lx\n",
+                    PCI_REVISION_ID_TAG,
+                    (unsigned long) adapter->rev_id);
+    
+    page += sprintf(page, "%-32s %lu\n",
+                    PCI_BUS_TAG,
+                    (unsigned long) (adapter->pdev->bus->number));
+    page += sprintf(page, "%-32s %lu\n",
+                    PCI_SLOT_TAG,
+                    (unsigned
+                     long) (PCI_SLOT((adapter->pdev->devfn))));
+       
+    if(adapter->shared.mac_type >= e1000_82543) {
+        page += sprintf(page, "%-32s %s\n",
+                PCI_BUS_TYPE_TAG,
+                (adapter->shared.bus_type == e1000_bus_type_pci)  ? "PCI"   :
+                (adapter->shared.bus_type == e1000_bus_type_pcix) ? "PCI-X" :
+                "UNKNOWN");
+    
+        page += sprintf(page, "%-32s %s\n",
+            PCI_BUS_SPEED_TAG,
+            (adapter->shared.bus_speed == e1000_bus_speed_33)  ? "33MHz"  :
+            (adapter->shared.bus_speed == e1000_bus_speed_66)  ? "66MHz"  :
+            (adapter->shared.bus_speed == e1000_bus_speed_100) ? "100MHz" :
+            (adapter->shared.bus_speed == e1000_bus_speed_133) ? "133MHz" :
+                "UNKNOWN");
+    
+        page += sprintf(page, "%-32s %s\n",
+                PCI_BUS_WIDTH_TAG,
+                (adapter->shared.bus_width == e1000_bus_width_32) ? "32-bit" :
+                (adapter->shared.bus_width == e1000_bus_width_64) ? "64-bit" :
+                "UNKNOWN");
+    }
+    
+    page +=
+        sprintf(page, "%-32s %lu\n", IRQ_TAG,
+                (unsigned long) (adapter->pdev->irq));
+    page +=
+        sprintf(page, "%-32s %s\n", SYSTEM_DEVICE_NAME_TAG,
+                adapter->netdev->name);
+
+    hwaddr = adapter->netdev->dev_addr;
+    page += sprintf(page, "%-32s %02X:%02X:%02X:%02X:%02X:%02X\n",
+                    CURRENT_HWADDR_TAG,
+                    hwaddr[0], hwaddr[1], hwaddr[2],
+                    hwaddr[3], hwaddr[4], hwaddr[5]);
+
+    hwaddr = adapter->perm_net_addr;
+    page += sprintf(page, "%-32s %02X:%02X:%02X:%02X:%02X:%02X\n",
+                    PERMANENT_HWADDR_TAG,
+                    hwaddr[0], hwaddr[1], hwaddr[2],
+                    hwaddr[3], hwaddr[4], hwaddr[5]);
+
+    page += sprintf(page, "\n");
+    
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    if (adapter->link_active == 1)
+        msg = "up";
+    else
+        msg = "down";
+    page += sprintf(page, "%-32s %s\n", LINK_TAG, msg);
+
+    if (adapter->link_speed)
+        page += sprintf(page, "%-32s %lu\n",
+                        SPEED_TAG,
+                        (unsigned long) (adapter->link_speed));
+    else
+        page += sprintf(page, "%-32s %s\n", SPEED_TAG, "N/A");
+
+    msg = adapter->link_duplex == FULL_DUPLEX ? "full" :
+        ((adapter->link_duplex == 0) ? "N/A" : "half");
+    page += sprintf(page, "%-32s %s\n", DUPLEX_TAG, msg);
+
+    if (adapter->netdev->flags & IFF_UP)
+        msg = "up";
+    else
+        msg = "down";
+    page += sprintf(page, "%-32s %s\n", STATE_TAG, msg);
+
+    page += sprintf(page, "\n");
+
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_PACKETS_TAG, (unsigned long) stats->rx_packets);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_PACKETS_TAG, (unsigned long) stats->tx_packets);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_BYTES_TAG, (unsigned long) stats->rx_bytes);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_BYTES_TAG, (unsigned long) stats->tx_bytes);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_ERRORS_TAG, (unsigned long) stats->rx_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_ERRORS_TAG, (unsigned long) stats->tx_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_DROPPED_TAG, (unsigned long) stats->rx_dropped);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_DROPPED_TAG, (unsigned long) stats->tx_dropped);
+    page += sprintf(page, "%-32s %lu\n",
+                    MULTICAST_TAG, (unsigned long) stats->multicast);
+    page += sprintf(page, "%-32s %lu\n",
+                    COLLISIONS_TAG, (unsigned long) stats->collisions);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_LENGTH_ERRORS_TAG,
+                    (unsigned long) stats->rx_length_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_OVER_ERRORS_TAG,
+                    (unsigned long) stats->rx_over_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_CRC_ERRORS_TAG,
+                    (unsigned long) stats->rx_crc_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_FRAME_ERRORS_TAG,
+                    (unsigned long) stats->rx_frame_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_FIFO_ERRORS_TAG,
+                    (unsigned long) stats->rx_fifo_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_MISSED_ERRORS_TAG,
+                    (unsigned long) stats->rx_missed_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_ABORTED_ERRORS_TAG,
+                    (unsigned long) stats->tx_aborted_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_CARRIER_ERRORS_TAG,
+                    (unsigned long) stats->tx_carrier_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_FIFO_ERRORS_TAG,
+                    (unsigned long) stats->tx_fifo_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_HEARTBEAT_ERRORS_TAG,
+                    (unsigned long) stats->tx_heartbeat_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_WINDOW_ERRORS_TAG,
+                    (unsigned long) stats->tx_window_errors);
+
+    page += sprintf(page, "\n");
+
+    /* 8254x specific stats */
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_LATE_COLL_TAG,
+                    (unsigned long long)adapter->stats.latecol);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_DEFERRED_TAG,
+                    (unsigned long long)adapter->stats.dc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_SINGLE_COLL_TAG,
+                    (unsigned long long)adapter->stats.scc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_MULTI_COLL_TAG,
+                    (unsigned long long)adapter->stats.mcc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_LONG_ERRORS_TAG,
+                    (unsigned long long)adapter->stats.roc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_SHORT_ERRORS_TAG,
+                    (unsigned long long)adapter->stats.ruc);
+    /* The 82542 does not have an alignment error count register */
+    /* ALGNERRC is only valid in MII mode at 10 or 100 Mbps */
+    if(adapter->shared.mac_type >= e1000_82543)
+        page += sprintf(page, "%-32s %Lu\n",
+                        RX_ALIGN_ERRORS_TAG,
+                        (unsigned long long)adapter->stats.algnerrc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_XON_TAG,
+                    (unsigned long long)adapter->stats.xonrxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_XOFF_TAG,
+                    (unsigned long long)adapter->stats.xoffrxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_XON_TAG,
+                    (unsigned long long)adapter->stats.xontxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_XOFF_TAG,
+                    (unsigned long long)adapter->stats.xofftxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_CSUM_GOOD_TAG,
+                    (unsigned long long)adapter->XsumRXGood);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_CSUM_ERROR_TAG,
+                    (unsigned long long)adapter->XsumRXError);
+
+    if (adapter->shared.media_type == e1000_media_type_copper)
+        msg = "Copper";
+    else
+        msg = "Fiber";
+    page += sprintf(page, "\n%-32s %s\n", MEDIA_TYPE_TAG, msg);
+    
+    if (adapter->shared.media_type == e1000_media_type_copper) {
+       CABLE_LENGTH_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", CABLE_LENGTH_TAG, msg);
+
+       EXTENDED_10BASE_T_DISTANCE_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", EXTENDED_10BASE_T_DISTANCE_TAG, msg);
+ 
+       CABLE_POLARITY_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", CABLE_POLARITY_TAG, msg);
+
+       POLARITY_CORRECTION_TO_STRING();
+       page += sprintf(page, "%-32s %s\n",  CABLE_POLARITY_CORRECTION_TAG, msg);
+
+       page += sprintf(page, "%-32s %lu\n", IDLE_ERRORS_TAG, (unsigned long)adapter->phy_stats.idle_errors );
+
+       LINK_RESET_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", LINK_RESET_ENABLED_TAG, msg);
+
+       page += sprintf(page, "%-32s %lu\n", RECEIVE_ERRORS_TAG, (unsigned long)adapter->phy_stats.receive_errors);
+
+       MDI_X_MODE_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", MDI_X_ENABLED_TAG, msg);
+
+       LOCAL_RECEIVER_STATUS_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", LOCAL_RECEIVER_STATUS_TAG, msg);
+
+       REMOTE_RECEIVER_STATUS_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", REMOTE_RECEIVER_STATUS_TAG, msg);
+    }
+
+    *page = 0;
+    return e1000_generic_read(pagep, start, off, count, eof);
+}
+
+static int e1000_read_descr(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    
+    strncpy(page, adapter->id_string, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_partnum(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    sprintf(page, "%06lx-%03x",
+            (unsigned long)adapter->part_num >> 8,
+            adapter->part_num & 0x000000FF);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_drvr_name(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    strncpy(page, e1000_driver_name, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_drvr_ver(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    strncpy(page, e1000_driver_version, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_vendor(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->vendor_id);
+}
+
+static int e1000_read_pci_device(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->device_id);
+}
+
+static int e1000_read_pci_sub_vendor(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->subven_id);
+}
+
+static int e1000_read_pci_sub_device(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->subsys_id);
+}
+
+static int e1000_read_pci_revision(char *page, char **start, off_t off,
+                      int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->rev_id);
+}
+
+static int e1000_read_dev_name(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page, adapter->netdev->name, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_bus(char *page, char **start, off_t off,
+                 int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) (adapter->pdev->bus->number));
+}
+
+static int e1000_read_pci_slot(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned
+                       long) (PCI_SLOT((adapter->pdev->devfn))));
+}
+
+static int e1000_read_pci_bus_type(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page,
+        (adapter->shared.bus_type == e1000_bus_type_pci)  ? "PCI"   :
+        (adapter->shared.bus_type == e1000_bus_type_pcix) ? "PCI-X" :
+        "UNKNOWN", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_bus_speed(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page, 
+        (adapter->shared.bus_speed == e1000_bus_speed_33)  ? "33MHz"  :
+        (adapter->shared.bus_speed == e1000_bus_speed_66)  ? "66MHz"  :
+        (adapter->shared.bus_speed == e1000_bus_speed_100) ? "100MHz" :
+        (adapter->shared.bus_speed == e1000_bus_speed_133) ? "133MHz" :
+        "UNKNOWN", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_bus_width(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page, 
+        (adapter->shared.bus_width == e1000_bus_width_32) ? "32-bit" :
+        (adapter->shared.bus_width == e1000_bus_width_64) ? "64-bit" :
+        "UNKNOWN", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_irq(char *page, char **start, off_t off,
+             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) (adapter->pdev->irq));
+}
+
+static int e1000_read_current_hwaddr(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    unsigned char *hwaddr = adapter->netdev->dev_addr;
+
+    return e1000_read_hwaddr(page, start, off, count, eof, hwaddr);
+}
+
+static int e1000_read_permanent_hwaddr(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    unsigned char *hwaddr = adapter->perm_net_addr;
+
+    return e1000_read_hwaddr(page, start, off, count, eof, hwaddr);
+}
+
+static int e1000_read_link_status(char *page, char **start, off_t off,
+                     int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    if (adapter->link_active == 1)
+        strncpy(page, "up", PAGE_SIZE);
+    else
+        strncpy(page, "down", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_speed(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    if (adapter->link_speed)
+        return e1000_read_ulong(page, start, off, count, eof,
+                          (unsigned long) (adapter->link_speed));
+    strncpy(page, "N/A", PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_dplx_mode(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    char *dplx_mode;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    dplx_mode = adapter->link_duplex == FULL_DUPLEX ? "full" :
+        ((adapter->link_duplex == 0) ? "N/A" : "half");
+    strncpy(page, dplx_mode, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_state(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    if (adapter->netdev->flags & IFF_UP)
+        strncpy(page, "up", PAGE_SIZE);
+    else
+        strncpy(page, "down", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_rx_packets(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_packets);
+}
+
+static int e1000_read_tx_packets(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_packets);
+}
+
+static int e1000_read_rx_bytes(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_bytes);
+}
+
+static int e1000_read_tx_bytes(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_bytes);
+}
+
+static int e1000_read_rx_errors(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_errors);
+}
+
+static int e1000_read_tx_errors(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_errors);
+}
+
+static int e1000_read_rx_dropped(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_dropped);
+}
+
+static int e1000_read_tx_dropped(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_dropped);
+}
+
+static int e1000_read_rx_multicast_packets(char *page, char **start, off_t off,
+                              int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.multicast);
+}
+
+static int e1000_read_collisions(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.collisions);
+}
+
+static int e1000_read_rx_length_errors(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_length_errors);
+}
+
+static int e1000_read_rx_over_errors(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_over_errors);
+}
+
+static int e1000_read_rx_crc_errors(char *page, char **start, off_t off,
+                       int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_crc_errors);
+}
+
+static int e1000_read_rx_frame_errors(char *page, char **start, off_t off,
+                         int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_frame_errors);
+}
+
+static int e1000_read_rx_fifo_errors(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_fifo_errors);
+}
+
+static int e1000_read_rx_missed_errors(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_missed_errors);
+}
+
+static int e1000_read_tx_aborted_errors(char *page, char **start, off_t off,
+                           int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_aborted_errors);
+}
+
+static int e1000_read_tx_carrier_errors(char *page, char **start, off_t off,
+                           int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_carrier_errors);
+}
+
+static int e1000_read_tx_fifo_errors(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_fifo_errors);
+}
+
+static int e1000_read_tx_heartbeat_errors(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_heartbeat_errors);
+}
+
+static int e1000_read_tx_window_errors(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_window_errors);
+}
+
+/* 8254x specific stats */
+static int e1000_read_tx_late_coll(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.latecol);
+}
+
+static int e1000_read_tx_defer_events(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.dc);
+}
+static int e1000_read_tx_single_coll(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.scc);
+}
+static int e1000_read_tx_multi_coll(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.mcc);
+}
+static int e1000_read_rx_oversize(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.roc);
+}
+static int e1000_read_rx_undersize(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.ruc);
+}
+static int e1000_read_rx_align_err(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.algnerrc);
+}
+static int e1000_read_rx_xon(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xonrxc);
+}
+static int e1000_read_rx_xoff(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xoffrxc);
+}
+static int e1000_read_tx_xon(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xontxc);
+}
+static int e1000_read_tx_xoff(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xofftxc);
+}
+
+static struct proc_dir_entry *e1000_create_proc_read(char *name,
+    struct e1000_adapter * adapter,
+    struct proc_dir_entry *parent,
+    read_proc_t * read_proc)
+{
+    struct proc_dir_entry *pdep;
+
+    if (!(pdep = create_proc_entry(name, S_IFREG, parent)))
+        return NULL;
+    pdep->read_proc = read_proc;
+    pdep->data = adapter;
+    return pdep;
+}
+
+static int e1000_read_cable_length (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    CABLE_LENGTH_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_media_type (char *page, char **start,
+                   off_t off, int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    switch (adapter->shared.media_type) {
+        case e1000_media_type_copper: strncpy(page,"Copper", PAGE_SIZE); break;
+        case e1000_media_type_fiber: strncpy(page, "Fiber", PAGE_SIZE); break;
+        default: strncpy(page, "Unknown", PAGE_SIZE);    
+    }
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_extended_10base_t_distance (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    EXTENDED_10BASE_T_DISTANCE_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_cable_polarity (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    CABLE_POLARITY_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_cable_polarity_correction (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    POLARITY_CORRECTION_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_idle_errors (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    return e1000_read_ulong(page, start, off, count, eof, adapter->phy_stats.idle_errors);
+}
+
+static int e1000_read_link_reset_enabled (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    LINK_RESET_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_receive_errors (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    return e1000_read_ulong(page, start, off, count, eof, adapter->phy_stats.receive_errors);
+}
+
+static int e1000_read_mdi_x_enabled (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    MDI_X_MODE_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_local_receiver_status (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    LOCAL_RECEIVER_STATUS_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_remote_receiver_status (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+    
+    REMOTE_RECEIVER_STATUS_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+int e1000_create_proc_dev(struct e1000_adapter * adapter)
+{
+    struct proc_dir_entry *dev_dir;
+    char info[256];
+    int len;
+
+    dev_dir = create_proc_entry(adapter->netdev->name, S_IFDIR, e1000_proc_dir);
+
+    strncpy(info, adapter->netdev->name, sizeof(info));
+    len = strlen(info);
+    strncat(info + len, ".info", sizeof(info) - len);
+
+    /* info */
+    if (!(e1000_create_proc_read(info, adapter, e1000_proc_dir, e1000_read_info)))
+        return -1;
+
+    /* description */
+    if (!(e1000_create_proc_read(DESCRIPTION_TAG, adapter, dev_dir, e1000_read_descr)))
+        return -1;
+    /* part number */
+    if (!(e1000_create_proc_read(PART_NUMBER_TAG, adapter, dev_dir, e1000_read_partnum)))
+        return -1;
+    /* driver name */
+    if (!(e1000_create_proc_read(DRVR_NAME_TAG, adapter, dev_dir, e1000_read_drvr_name)))
+        return -1;
+    /* driver version */
+    if (!(e1000_create_proc_read(DRVR_VERSION_TAG, adapter, dev_dir, e1000_read_drvr_ver)))
+        return -1;
+    /* pci vendor */
+    if (!(e1000_create_proc_read(PCI_VENDOR_TAG, adapter, dev_dir, e1000_read_pci_vendor)))
+        return -1;
+    /* pci device id */
+    if (!(e1000_create_proc_read(PCI_DEVICE_ID_TAG, adapter, dev_dir,
+                           e1000_read_pci_device))) return -1;
+    /* pci sub vendor */
+    if (!(e1000_create_proc_read(PCI_SUBSYSTEM_VENDOR_TAG, adapter, dev_dir,
+                           e1000_read_pci_sub_vendor))) return -1;
+    /* pci sub device id */
+    if (!(e1000_create_proc_read(PCI_SUBSYSTEM_ID_TAG, adapter, dev_dir,
+                           e1000_read_pci_sub_device))) return -1;
+    /* pci revision id */
+    if (!(e1000_create_proc_read(PCI_REVISION_ID_TAG, adapter, dev_dir,
+                           e1000_read_pci_revision))) return -1;
+    /* device name */
+    if (!(e1000_create_proc_read(SYSTEM_DEVICE_NAME_TAG, adapter, dev_dir,
+                           e1000_read_dev_name))) return -1;
+    /* pci bus */
+    if (!(e1000_create_proc_read(PCI_BUS_TAG, adapter, dev_dir, e1000_read_pci_bus)))
+        return -1;
+    /* pci slot */
+    if (!(e1000_create_proc_read(PCI_SLOT_TAG, adapter, dev_dir, e1000_read_pci_slot)))
+        return -1;
+    /* pci bus type */
+    if (!(e1000_create_proc_read(PCI_BUS_TYPE_TAG, adapter, dev_dir, 
+                               e1000_read_pci_bus_type))) return -1;
+    /* pci bus speed */
+    if (!(e1000_create_proc_read(PCI_BUS_SPEED_TAG, adapter, dev_dir, 
+                               e1000_read_pci_bus_speed))) return -1;
+    /* pci bus width */
+    if (!(e1000_create_proc_read(PCI_BUS_WIDTH_TAG, adapter, dev_dir, 
+                               e1000_read_pci_bus_width))) return -1;
+    /* irq */
+    if (!(e1000_create_proc_read(IRQ_TAG, adapter, dev_dir, e1000_read_irq)))
+        return -1;
+    /* current hwaddr */
+    if (!(e1000_create_proc_read(CURRENT_HWADDR_TAG, adapter, dev_dir,
+                           e1000_read_current_hwaddr))) return -1;
+    /* permanent hwaddr */
+    if (!(e1000_create_proc_read(PERMANENT_HWADDR_TAG, adapter, dev_dir,
+                           e1000_read_permanent_hwaddr))) return -1;
+
+    /* link status */
+    if (!(e1000_create_proc_read(LINK_TAG, adapter, dev_dir, e1000_read_link_status)))
+        return -1;
+    /* speed */
+    if (!(e1000_create_proc_read(SPEED_TAG, adapter, dev_dir, e1000_read_speed)))
+        return -1;
+    /* duplex mode */
+    if (!(e1000_create_proc_read(DUPLEX_TAG, adapter, dev_dir, e1000_read_dplx_mode)))
+        return -1;
+    /* state */
+    if (!(e1000_create_proc_read(STATE_TAG, adapter, dev_dir, e1000_read_state)))
+        return -1;
+    /* rx packets */
+    if (!(e1000_create_proc_read(RX_PACKETS_TAG, adapter, dev_dir, e1000_read_rx_packets)))
+        return -1;
+    /* tx packets */
+    if (!(e1000_create_proc_read(TX_PACKETS_TAG, adapter, dev_dir, e1000_read_tx_packets)))
+        return -1;
+    /* rx bytes */
+    if (!(e1000_create_proc_read(RX_BYTES_TAG, adapter, dev_dir, e1000_read_rx_bytes)))
+        return -1;
+    /* tx bytes */
+    if (!(e1000_create_proc_read(TX_BYTES_TAG, adapter, dev_dir, e1000_read_tx_bytes)))
+        return -1;
+    /* rx errors */
+    if (!(e1000_create_proc_read(RX_ERRORS_TAG, adapter, dev_dir, e1000_read_rx_errors)))
+        return -1;
+    /* tx errors */
+    if (!(e1000_create_proc_read(TX_ERRORS_TAG, adapter, dev_dir, e1000_read_tx_errors)))
+        return -1;
+    /* rx dropped */
+    if (!(e1000_create_proc_read(RX_DROPPED_TAG, adapter, dev_dir, e1000_read_rx_dropped)))
+        return -1;
+    /* tx dropped */
+    if (!(e1000_create_proc_read(TX_DROPPED_TAG, adapter, dev_dir, e1000_read_tx_dropped)))
+        return -1;
+    /* multicast packets */
+    if (!(e1000_create_proc_read(MULTICAST_TAG, adapter, dev_dir, 
+                                    e1000_read_rx_multicast_packets)))
+        return -1;
+
+    /* collisions */
+    if (!(e1000_create_proc_read (COLLISIONS_TAG, adapter, dev_dir, e1000_read_collisions))) 
+        return -1;
+             
+    /* rx length errors */
+    if (!(e1000_create_proc_read(RX_LENGTH_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_length_errors))) return -1;
+    /* rx over errors */
+    if (!(e1000_create_proc_read(RX_OVER_ERRORS_TAG, adapter, dev_dir,
+                               e1000_read_rx_over_errors))) return -1;
+    /* rx crc errors */
+    if (!(e1000_create_proc_read(RX_CRC_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_crc_errors))) return -1;
+    /* rx frame errors */
+    if (!(e1000_create_proc_read(RX_FRAME_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_frame_errors))) return -1;
+    /* rx fifo errors */
+    if (!(e1000_create_proc_read(RX_FIFO_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_fifo_errors))) return -1;
+    /* rx missed errors */
+    if (!(e1000_create_proc_read(RX_MISSED_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_missed_errors))) return -1;
+    /* tx aborted errors */
+    if (!(e1000_create_proc_read(TX_ABORTED_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_aborted_errors))) return -1;
+    /* tx carrier errors */
+    if (!(e1000_create_proc_read(TX_CARRIER_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_carrier_errors))) return -1;
+    /* tx fifo errors */
+    if (!(e1000_create_proc_read(TX_FIFO_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_fifo_errors))) return -1;
+    /* tx heartbeat errors */
+    if (!(e1000_create_proc_read(TX_HEARTBEAT_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_heartbeat_errors))) return -1;
+    /* tx window errors */
+    if (!(e1000_create_proc_read(TX_WINDOW_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_window_errors))) return -1;
+
+    if (!(e1000_create_proc_read(TX_LATE_COLL_TAG, adapter, dev_dir,
+                           e1000_read_tx_late_coll))) return -1;
+    if (!(e1000_create_proc_read(TX_DEFERRED_TAG, adapter, dev_dir,
+                           e1000_read_tx_defer_events))) return -1;
+    if (!(e1000_create_proc_read(TX_SINGLE_COLL_TAG, adapter, dev_dir,
+                           e1000_read_tx_single_coll))) return -1;
+    if (!(e1000_create_proc_read(TX_MULTI_COLL_TAG, adapter, dev_dir,
+                           e1000_read_tx_multi_coll))) return -1;
+    if (!(e1000_create_proc_read(RX_LONG_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_oversize))) return -1;
+    if (!(e1000_create_proc_read(RX_SHORT_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_undersize))) return -1;
+    if(adapter->shared.mac_type >= e1000_82543)
+        if (!(e1000_create_proc_read(RX_ALIGN_ERRORS_TAG, adapter, dev_dir,
+                               e1000_read_rx_align_err))) return -1;
+    if (!(e1000_create_proc_read(RX_XON_TAG, adapter, dev_dir,
+                           e1000_read_rx_xon))) return -1;
+    if (!(e1000_create_proc_read(RX_XOFF_TAG, adapter, dev_dir,
+                           e1000_read_rx_xoff))) return -1;
+    if (!(e1000_create_proc_read(TX_XON_TAG, adapter, dev_dir,
+                           e1000_read_tx_xon))) return -1;
+    if (!(e1000_create_proc_read(TX_XOFF_TAG, adapter, dev_dir,
+                           e1000_read_tx_xoff))) return -1;
+
+    if (!(e1000_create_proc_read(MEDIA_TYPE_TAG, adapter, dev_dir,
+                    e1000_read_media_type))) return -1;
+    
+    if (adapter->shared.media_type == e1000_media_type_copper) {
+       if (!(e1000_create_proc_read(CABLE_LENGTH_TAG, adapter, dev_dir,
+                    e1000_read_cable_length))) return -1;
+   
+       if (!(e1000_create_proc_read(EXTENDED_10BASE_T_DISTANCE_TAG, 
+                   adapter, dev_dir,
+                   e1000_read_extended_10base_t_distance))) return -1;
+        
+       if (!(e1000_create_proc_read(CABLE_POLARITY_TAG, adapter, dev_dir,
+                    e1000_read_cable_polarity))) return -1;
+   
+       if (!(e1000_create_proc_read(CABLE_POLARITY_CORRECTION_TAG, adapter, dev_dir,
+                   e1000_read_cable_polarity_correction))) return -1;
+   
+       if (!(e1000_create_proc_read(IDLE_ERRORS_TAG, adapter, dev_dir,
+                    e1000_read_idle_errors))) return -1;
+   
+       if (!(e1000_create_proc_read(LINK_RESET_ENABLED_TAG, adapter, dev_dir,
+                   e1000_read_link_reset_enabled))) return -1;
+   
+       if (!(e1000_create_proc_read(RECEIVE_ERRORS_TAG, adapter, dev_dir,
+                    e1000_read_receive_errors))) return -1;
+   
+       if (!(e1000_create_proc_read(MDI_X_ENABLED_TAG, adapter, dev_dir,
+                   e1000_read_mdi_x_enabled))) return -1;
+  
+       if (!(e1000_create_proc_read(LOCAL_RECEIVER_STATUS_TAG, adapter, dev_dir,
+                   e1000_read_local_receiver_status))) return -1;
+   
+       if (!(e1000_create_proc_read(REMOTE_RECEIVER_STATUS_TAG, adapter, dev_dir,
+                   e1000_read_remote_receiver_status))) return -1;
+    }
+    
+    return 0;
+}
+
+void e1000_remove_proc_dev(struct net_device *dev)
+{
+    struct proc_dir_entry *de;
+    struct e1000_adapter * adapter = dev->priv;
+    char info[256];
+    int len;
+
+    len = strlen(dev->name);
+    strncpy(info, dev->name, sizeof(info));
+    strncat(info + len, ".info", sizeof(info) - len);
+
+    for (de = e1000_proc_dir->subdir; de; de = de->next) {
+        if ((de->namelen == len) && (!memcmp(de->name, dev->name, len)))
+            break;
+    }
+    if (de) {
+        remove_proc_entry(DESCRIPTION_TAG, de);
+        remove_proc_entry(PART_NUMBER_TAG, de);
+        remove_proc_entry(DRVR_NAME_TAG, de);
+        remove_proc_entry(DRVR_VERSION_TAG, de);
+        remove_proc_entry(PCI_VENDOR_TAG, de);
+        remove_proc_entry(PCI_DEVICE_ID_TAG, de);
+        remove_proc_entry(PCI_SUBSYSTEM_VENDOR_TAG, de);
+        remove_proc_entry(PCI_SUBSYSTEM_ID_TAG, de);
+        remove_proc_entry(PCI_REVISION_ID_TAG, de);
+        remove_proc_entry(SYSTEM_DEVICE_NAME_TAG, de);
+        remove_proc_entry(PCI_BUS_TAG, de);
+        remove_proc_entry(PCI_SLOT_TAG, de);
+        remove_proc_entry(PCI_BUS_TYPE_TAG, de);
+        remove_proc_entry(PCI_BUS_SPEED_TAG, de);
+        remove_proc_entry(PCI_BUS_WIDTH_TAG, de);
+        remove_proc_entry(IRQ_TAG, de);
+        remove_proc_entry(CURRENT_HWADDR_TAG, de);
+        remove_proc_entry(PERMANENT_HWADDR_TAG, de);
+
+        remove_proc_entry(LINK_TAG, de);
+        remove_proc_entry(SPEED_TAG, de);
+        remove_proc_entry(DUPLEX_TAG, de);
+        remove_proc_entry(STATE_TAG, de);
+
+        remove_proc_entry(RX_PACKETS_TAG, de);
+        remove_proc_entry(TX_PACKETS_TAG, de);
+        remove_proc_entry(RX_BYTES_TAG, de);
+        remove_proc_entry(TX_BYTES_TAG, de);
+        remove_proc_entry(RX_ERRORS_TAG, de);
+        remove_proc_entry(TX_ERRORS_TAG, de);
+        remove_proc_entry(RX_DROPPED_TAG, de);
+        remove_proc_entry(TX_DROPPED_TAG, de);
+        remove_proc_entry(MULTICAST_TAG, de);
+        remove_proc_entry(COLLISIONS_TAG, de);
+        remove_proc_entry(RX_LENGTH_ERRORS_TAG, de);
+        remove_proc_entry(RX_OVER_ERRORS_TAG, de);
+        remove_proc_entry(RX_CRC_ERRORS_TAG, de);
+        remove_proc_entry(RX_FRAME_ERRORS_TAG, de);
+        remove_proc_entry(RX_FIFO_ERRORS_TAG, de);
+        remove_proc_entry(RX_MISSED_ERRORS_TAG, de);
+        remove_proc_entry(TX_ABORTED_ERRORS_TAG, de);
+        remove_proc_entry(TX_CARRIER_ERRORS_TAG, de);
+        remove_proc_entry(TX_FIFO_ERRORS_TAG, de);
+        remove_proc_entry(TX_HEARTBEAT_ERRORS_TAG, de);
+        remove_proc_entry(TX_WINDOW_ERRORS_TAG, de);
+        remove_proc_entry(TX_LATE_COLL_TAG, de);
+        remove_proc_entry(TX_DEFERRED_TAG, de);
+        remove_proc_entry(TX_SINGLE_COLL_TAG, de);
+        remove_proc_entry(TX_MULTI_COLL_TAG, de);
+        remove_proc_entry(RX_LONG_ERRORS_TAG, de);
+        remove_proc_entry(RX_SHORT_ERRORS_TAG, de);
+        remove_proc_entry(RX_XON_TAG, de);
+        remove_proc_entry(RX_XOFF_TAG, de);
+        remove_proc_entry(TX_XON_TAG, de);
+        remove_proc_entry(TX_XOFF_TAG, de);
+
+        remove_proc_entry(MEDIA_TYPE_TAG, de);
+        if (adapter->shared.media_type == e1000_media_type_copper) {
+           remove_proc_entry(CABLE_LENGTH_TAG, de);
+           remove_proc_entry(EXTENDED_10BASE_T_DISTANCE_TAG, de);
+           remove_proc_entry(CABLE_POLARITY_TAG, de);
+           remove_proc_entry(CABLE_POLARITY_CORRECTION_TAG, de);
+           remove_proc_entry(IDLE_ERRORS_TAG, de);
+           remove_proc_entry(LINK_RESET_ENABLED_TAG, de);
+           remove_proc_entry(RECEIVE_ERRORS_TAG, de);
+           remove_proc_entry(MDI_X_ENABLED_TAG, de);
+           remove_proc_entry(LOCAL_RECEIVER_STATUS_TAG, de);
+           remove_proc_entry(REMOTE_RECEIVER_STATUS_TAG, de);
+        }
+    }
+
+    remove_proc_entry(info, e1000_proc_dir);
+    remove_proc_entry(dev->name, e1000_proc_dir);
+}
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/e1000/e1000_proc.h linux/drivers/net/e1000/e1000_proc.h
--- ../prev/linux/drivers/net/e1000/e1000_proc.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_proc.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,181 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* /proc definitions */
+#include <linux/proc_fs.h>
+
+#define ADAPTERS_PROC_DIR           "PRO_LAN_Adapters"
+
+#define DESCRIPTION_TAG             "Description"
+#define PART_NUMBER_TAG             "Part_Number"
+#define DRVR_NAME_TAG               "Driver_Name"
+#define DRVR_VERSION_TAG            "Driver_Version"
+#define PCI_VENDOR_TAG              "PCI_Vendor"
+#define PCI_DEVICE_ID_TAG           "PCI_Device_ID"
+#define PCI_SUBSYSTEM_VENDOR_TAG    "PCI_Subsystem_Vendor"
+#define PCI_SUBSYSTEM_ID_TAG        "PCI_Subsystem_ID"
+#define PCI_REVISION_ID_TAG         "PCI_Revision_ID"
+#define PCI_BUS_TAG                 "PCI_Bus"
+#define PCI_SLOT_TAG                "PCI_Slot"
+#define PCI_BUS_TYPE_TAG            "PCI_Bus_Type"
+#define PCI_BUS_SPEED_TAG           "PCI_Bus_Speed"
+#define PCI_BUS_WIDTH_TAG           "PCI_Bus_Width"
+#define IRQ_TAG                     "IRQ"
+#define SYSTEM_DEVICE_NAME_TAG      "System_Device_Name"
+#define CURRENT_HWADDR_TAG          "Current_HWaddr"
+#define PERMANENT_HWADDR_TAG        "Permanent_HWaddr"
+
+#define LINK_TAG                    "Link"
+#define SPEED_TAG                   "Speed"
+#define DUPLEX_TAG                  "Duplex"
+#define STATE_TAG                   "State"
+
+#define RX_PACKETS_TAG              "Rx_Packets"
+#define TX_PACKETS_TAG              "Tx_Packets"
+#define RX_BYTES_TAG                "Rx_Bytes"
+#define TX_BYTES_TAG                "Tx_Bytes"
+#define RX_ERRORS_TAG               "Rx_Errors"
+#define TX_ERRORS_TAG               "Tx_Errors"
+#define RX_DROPPED_TAG              "Rx_Dropped"
+#define TX_DROPPED_TAG              "Tx_Dropped"
+#define MULTICAST_TAG               "Multicast"
+#define COLLISIONS_TAG              "Collisions"
+#define RX_LENGTH_ERRORS_TAG        "Rx_Length_Errors"
+#define RX_OVER_ERRORS_TAG          "Rx_Over_Errors"
+#define RX_CRC_ERRORS_TAG           "Rx_CRC_Errors"
+#define RX_FRAME_ERRORS_TAG         "Rx_Frame_Errors"
+#define RX_FIFO_ERRORS_TAG          "Rx_FIFO_Errors"
+#define RX_MISSED_ERRORS_TAG        "Rx_Missed_Errors"
+#define TX_ABORTED_ERRORS_TAG       "Tx_Aborted_Errors"
+#define TX_CARRIER_ERRORS_TAG       "Tx_Carrier_Errors"
+#define TX_FIFO_ERRORS_TAG          "Tx_FIFO_Errors"
+#define TX_HEARTBEAT_ERRORS_TAG     "Tx_Heartbeat_Errors"
+#define TX_WINDOW_ERRORS_TAG        "Tx_Window_Errors"
+
+#define RX_TCP_CHECKSUM_GOOD_TAG    "Rx_TCP_Checksum_Good"
+#define RX_TCP_CHECKSUM_BAD_TAG     "Rx_TCP_Checksum_Bad"
+#define TX_TCP_CHECKSUM_GOOD_TAG    "Tx_TCP_Checksum_Good"
+#define TX_TCP_CHECKSUM_BAD_TAG     "Tx_TCP_Checksum_Bad"
+
+#define TX_LATE_COLL_TAG            "Tx_Abort_Late_Coll"
+#define TX_DEFERRED_TAG             "Tx_Deferred_Ok"
+#define TX_SINGLE_COLL_TAG          "Tx_Single_Coll_Ok"
+#define TX_MULTI_COLL_TAG           "Tx_Multi_Coll_Ok"
+#define RX_LONG_ERRORS_TAG          "Rx_Long_Length_Errors"
+#define RX_SHORT_ERRORS_TAG         "Rx_Short_Length_Errors"
+#define RX_ALIGN_ERRORS_TAG         "Rx_Align_Errors"
+#define RX_XON_TAG                  "Rx_Flow_Control_XON"
+#define RX_XOFF_TAG                 "Rx_Flow_Control_XOFF"
+#define TX_XON_TAG                  "Tx_Flow_Control_XON"
+#define TX_XOFF_TAG                 "Tx_Flow_Control_XOFF"
+#define RX_CSUM_GOOD_TAG            "Rx_Csum_Offload_Good"
+#define RX_CSUM_ERROR_TAG           "Rx_Csum_Offload_Errors"
+
+/* what is the cable length (only for 100/1000 modes)? - 50, 50-80, 80-110, 110-140 and > 140 meters */
+#define CABLE_LENGTH_TAG                 "PHY_Cable_Length"
+
+/* Media Type Copper/Fiber */
+#define MEDIA_TYPE_TAG                   "PHY_Media_Type"
+
+/* Is extended 10 Base-T distance feature enabled? This is done by lowering the receive threshold - enabled/disabled */
+#define EXTENDED_10BASE_T_DISTANCE_TAG   "PHY_Extended_10Base_T_Distance"
+
+/* Cable polarity Normal/Reversed */
+#define CABLE_POLARITY_TAG               "PHY_Cable_Polarity"
+
+/* Is Polarity reversal enabled? Enabled/Disabled */
+#define CABLE_POLARITY_CORRECTION_TAG    "PHY_Disable_Polarity_Correction"
+
+/* Number of IDLE Errors */
+#define IDLE_ERRORS_TAG                  "PHY_Idle_Errors"
+
+/* Should the link be brought down if an IDLE is not seen within 1 msec while in 1000mbps mode? Enabled/Disabled */
+#define LINK_RESET_ENABLED_TAG           "PHY_Link_Reset_Enabled"
+
+/* Number of receive errors */
+#define RECEIVE_ERRORS_TAG               "PHY_Receive_Errors"
+
+/* MDI-X Support Enabled? Auto, Manual(MDI) or Manual(MDI-X) */
+#define MDI_X_ENABLED_TAG                "PHY_MDI_X_Enabled"
+
+/* Local Receiver OK? OK/NOT_OK */
+#define LOCAL_RECEIVER_STATUS_TAG        "PHY_Local_Receiver_Status"
+
+/* Remote Receiver OK? OK/NOT_OK */
+#define REMOTE_RECEIVER_STATUS_TAG       "PHY_Remote_Receiver_Status"
+
+/* symbols exported to e1000_main */
+extern struct proc_dir_entry *e1000_proc_dir;
+extern int e1000_create_proc_dev(struct e1000_adapter * Adapter);
+extern void e1000_remove_proc_dev(struct net_device *dev);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/eepro100.c linux/drivers/net/eepro100.c
--- ../prev/linux/drivers/net/eepro100.c	Tue Jul  9 18:04:15 2002
+++ linux/drivers/net/eepro100.c	Wed May 15 10:15:10 2002
@@ -70,8 +70,8 @@
 
 /* A few values that may be tweaked. */
 /* The ring sizes should be a power of two for efficiency. */
-#define TX_RING_SIZE	32
-#define RX_RING_SIZE	32
+#define TX_RING_SIZE	64
+#define RX_RING_SIZE	1024
 /* How much slots multicast filter setup may take.
    Do not descrease without changing set_rx_mode() implementaion. */
 #define TX_MULTICAST_SIZE   2
@@ -1080,6 +1080,50 @@
 	outw(CUStart | SCBMaskEarlyRx | SCBMaskFlowCtl, ioaddr + SCBCmd);
 }
 
+/*
+ * Sometimes the receiver stops making progress.  This routine knows how to
+ * get it going again, without losing packets or being otherwise nasty like
+ * a chip reset would be.  Previously the driver had a whole sequence
+ * of if RxSuspended, if it's no buffers do one thing, if it's no resources,
+ * do another, etc.  But those things don't really matter.  Separate logic
+ * in the ISR provides for allocating buffers--the other half of operation
+ * is just making sure the receiver is active.  speedo_rx_soft_reset does that.
+ * This problem with the old, more involved algorithm is shown up under
+ * ping floods on the order of 60K packets/second on a 100Mbps fdx network.
+ */
+static void
+speedo_rx_soft_reset(struct net_device *dev)
+{
+	struct speedo_private *sp = dev->priv;
+	struct RxFD *rfd;
+	long ioaddr;
+
+	ioaddr = dev->base_addr;
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	if (inb(ioaddr + SCBCmd) != 0) {
+		printk("%s: previous command stalled\n", dev->name);
+		return;
+	}
+	/*
+	* Put the hardware into a known state.
+	*/
+	outb(RxAbort, ioaddr + SCBCmd);
+
+	rfd = sp->rx_ringp[sp->cur_rx % RX_RING_SIZE];
+
+	rfd->rx_buf_addr = 0xffffffff;
+
+	wait_for_cmd_done(ioaddr + SCBCmd);
+
+	if (inb(ioaddr + SCBCmd) != 0) {
+		printk("%s: RxAbort command stalled\n", dev->name);
+		return;
+	}
+	outl(sp->rx_ring_dma[sp->cur_rx % RX_RING_SIZE],
+		ioaddr + SCBPointer);
+	outb(RxStart, ioaddr + SCBCmd);
+}
+
 /* Media monitoring and control. */
 static void speedo_timer(unsigned long data)
 {
@@ -1516,82 +1560,37 @@
 		if ((status & 0xfc00) == 0)
 			break;
 
-		/* Always check if all rx buffers are allocated.  --SAW */
-		speedo_refill_rx_buffers(dev, 0);
-
 		if ((status & 0x5000) ||	/* Packet received, or Rx error. */
 			(sp->rx_ring_state&(RrNoMem|RrPostponed)) == RrPostponed)
 									/* Need to gather the postponed packet. */
 			speedo_rx(dev);
 
-		if (status & 0x1000) {
-			spin_lock(&sp->lock);
-			if ((status & 0x003c) == 0x0028) {		/* No more Rx buffers. */
-				struct RxFD *rxf;
-				printk(KERN_WARNING "%s: card reports no RX buffers.\n",
-						dev->name);
-				rxf = sp->rx_ringp[sp->cur_rx % RX_RING_SIZE];
-				if (rxf == NULL) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: NULL cur_rx in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else if (rxf == sp->last_rxf) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: cur_rx is last in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else
-					outb(RxResumeNoResources, ioaddr + SCBCmd);
-			} else if ((status & 0x003c) == 0x0008) { /* No resources. */
-				struct RxFD *rxf;
-				printk(KERN_WARNING "%s: card reports no resources.\n",
-						dev->name);
-				rxf = sp->rx_ringp[sp->cur_rx % RX_RING_SIZE];
-				if (rxf == NULL) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: NULL cur_rx in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else if (rxf == sp->last_rxf) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: cur_rx is last in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else {
-					/* Restart the receiver. */
-					outl(sp->rx_ring_dma[sp->cur_rx % RX_RING_SIZE],
-						 ioaddr + SCBPointer);
-					outb(RxStart, ioaddr + SCBCmd);
-				}
-			}
-			sp->stats.rx_errors++;
-			spin_unlock(&sp->lock);
-		}
+		/* Always check if all rx buffers are allocated.  --SAW */
+		speedo_refill_rx_buffers(dev, 0);
 
-		if ((sp->rx_ring_state&(RrNoMem|RrNoResources)) == RrNoResources) {
-			printk(KERN_WARNING
-					"%s: restart the receiver after a possible hang.\n",
-					dev->name);
-			spin_lock(&sp->lock);
-			/* Restart the receiver.
-			   I'm not sure if it's always right to restart the receiver
-			   here but I don't know another way to prevent receiver hangs.
-			   1999/12/25 SAW */
-			outl(sp->rx_ring_dma[sp->cur_rx % RX_RING_SIZE],
-				 ioaddr + SCBPointer);
-			outb(RxStart, ioaddr + SCBCmd);
-			sp->rx_ring_state &= ~RrNoResources;
-			spin_unlock(&sp->lock);
+		spin_lock(&sp->lock);
+		/*
+		 * The chip may have suspended reception for various reasons.
+		 * Check for that, and re-prime it should this be the case.
+		 */
+		switch ((status >> 2) & 0xf) {
+		case 0: /* Idle */
+			break;
+		case 1:	/* Suspended */
+		case 2:	/* No resources (RxFDs) */
+		case 9:	/* Suspended with no more RBDs */
+		case 10: /* No resources due to no RBDs */
+		case 12: /* Ready with no RBDs */
+			speedo_rx_soft_reset(dev);
+			break;
+		case 3:  case 5:  case 6:  case 7:  case 8:
+		case 11:  case 13:  case 14:  case 15:
+			/* these are all reserved values */
+			break;
 		}
 
 		/* User interrupt, Command/Tx unit interrupt or CU not active. */
 		if (status & 0xA400) {
-			spin_lock(&sp->lock);
 			speedo_tx_buffer_gc(dev);
 			if (sp->tx_full
 				&& (int)(sp->cur_tx - sp->dirty_tx) < TX_QUEUE_UNFULL) {
@@ -1599,8 +1598,8 @@
 				sp->tx_full = 0;
 				netif_wake_queue(dev); /* Attention: under a spinlock.  --SAW */
 			}
-			spin_unlock(&sp->lock);
 		}
+		spin_unlock(&sp->lock);
 
 		if (--boguscnt < 0) {
 			printk(KERN_ERR "%s: Too much work at interrupt, status=0x%4.4x.\n",
@@ -1721,6 +1720,7 @@
 	int entry = sp->cur_rx % RX_RING_SIZE;
 	int rx_work_limit = sp->dirty_rx + RX_RING_SIZE - sp->cur_rx;
 	int alloc_ok = 1;
+	int npkts = 0;
 
 	if (speedo_debug > 4)
 		printk(KERN_DEBUG " In speedo_rx().\n");
@@ -1787,6 +1787,7 @@
 				memcpy(skb_put(skb, pkt_len), sp->rx_skbuff[entry]->tail,
 					   pkt_len);
 #endif
+				npkts++;
 			} else {
 				/* Pass up the already-filled skbuff. */
 				skb = sp->rx_skbuff[entry];
@@ -1797,6 +1798,7 @@
 				}
 				sp->rx_skbuff[entry] = NULL;
 				skb_put(skb, pkt_len);
+				npkts++;
 				sp->rx_ringp[entry] = NULL;
 				pci_unmap_single(sp->pdev, sp->rx_ring_dma[entry],
 						PKT_BUF_SZ + sizeof(struct RxFD), PCI_DMA_FROMDEVICE);
@@ -1817,7 +1819,8 @@
 	/* Try hard to refill the recently taken buffers. */
 	speedo_refill_rx_buffers(dev, 1);
 
-	sp->last_rx_time = jiffies;
+	if (npkts)
+		sp->last_rx_time = jiffies;
 
 	return 0;
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/tg3.c linux/drivers/net/tg3.c
--- ../prev/linux/drivers/net/tg3.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/tg3.c	Fri Jun 28 06:13:09 2002
@@ -0,0 +1,6448 @@
+/* $Id: tg3.c,v 1.3 2002/04/16 19:19:48 willy Exp $
+ * tg3.c: Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001, 2002 Jeff Garzik (jgarzik@mandrakesoft.com)
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/compiler.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+
+#ifndef PCI_DMA_BUS_IS_PHYS
+#define PCI_DMA_BUS_IS_PHYS 1
+#endif
+
+/* Either I can't figure out how they secretly implemented it (ie. RXD flags
+ * for mini ring, where it should go in NIC sram, and how many entries the NIC
+ * firmware expects) or it isn't really fully implemented.  Perhaps Broadcom
+ * wants people to pay for a "performance enhanced" version of their firmware +
+ * binary-only driver that has the mini ring actually implemented.
+ * These kids today... -DaveM
+ */
+#define TG3_MINI_RING_WORKS 0
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#define TG3_VLAN_TAG_USED 1
+#else
+#define TG3_VLAN_TAG_USED 0
+#endif
+
+#include "tg3.h"
+
+#define DRV_MODULE_NAME		"tg3"
+#define PFX DRV_MODULE_NAME	": "
+#define DRV_MODULE_VERSION	"0.98"
+#define DRV_MODULE_RELDATE	"Mar 28, 2002"
+
+#define TG3_DEF_MAC_MODE	0
+#define TG3_DEF_RX_MODE		0
+#define TG3_DEF_TX_MODE		0
+#define TG3_DEF_MSG_ENABLE	  \
+	(NETIF_MSG_DRV		| \
+	 NETIF_MSG_PROBE	| \
+	 NETIF_MSG_LINK		| \
+	 NETIF_MSG_TIMER	| \
+	 NETIF_MSG_IFDOWN	| \
+	 NETIF_MSG_IFUP		| \
+	 NETIF_MSG_RX_ERR	| \
+	 NETIF_MSG_TX_ERR)
+
+/* length of time before we decide the hardware is borked,
+ * and dev->tx_timeout() should be called to fix the problem
+ */
+#define TG3_TX_TIMEOUT			(5 * HZ)
+
+/* hardware minimum and maximum for a single frame's data payload */
+#define TG3_MIN_MTU			60
+#define TG3_MAX_MTU			9000
+
+/* These numbers seem to be hard coded in the NIC firmware somehow.
+ * You can't change the ring sizes, but you can change where you place
+ * them in the NIC onboard memory.
+ */
+#define TG3_RX_RING_SIZE		512
+#define TG3_DEF_RX_RING_PENDING		200
+#if TG3_MINI_RING_WORKS
+#define TG3_RX_MINI_RING_SIZE		256 /* ??? */
+#define TG3_DEF_RX_MINI_RING_PENDING	100
+#endif
+#define TG3_RX_JUMBO_RING_SIZE		256
+#define TG3_DEF_RX_JUMBO_RING_PENDING	100
+#define TG3_RX_RCB_RING_SIZE		1024
+#define TG3_TX_RING_SIZE		512
+#define TG3_DEF_TX_RING_PENDING		(TG3_TX_RING_SIZE - 1)
+
+#define TG3_RX_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+				 TG3_RX_RING_SIZE)
+#if TG3_MINI_RING_WORKS
+#define TG3_RX_MINI_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+				 TG3_RX_MINI_RING_SIZE)
+#endif
+#define TG3_RX_JUMBO_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+			         TG3_RX_JUMBO_RING_SIZE)
+#define TG3_RX_RCB_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+			         TG3_RX_RCB_RING_SIZE)
+#define TG3_TX_RING_BYTES	(sizeof(struct tg3_tx_buffer_desc) * \
+				 TG3_TX_RING_SIZE)
+#define TX_RING_GAP(TP)	\
+	(TG3_TX_RING_SIZE - (TP)->tx_pending)
+#define TX_BUFFS_AVAIL(TP)						\
+	(((TP)->tx_cons <= (TP)->tx_prod) ?				\
+	  (TP)->tx_cons + (TP)->tx_pending - (TP)->tx_prod :		\
+	  (TP)->tx_cons - (TP)->tx_prod - TX_RING_GAP(TP))
+#define NEXT_TX(N)		(((N) + 1) & (TG3_TX_RING_SIZE - 1))
+
+#define RX_PKT_BUF_SZ		(1536 + tp->rx_offset + 64)
+#if TG3_MINI_RING_WORKS
+#define RX_MINI_PKT_BUF_SZ	(256 + tp->rx_offset + 64)
+#endif
+#define RX_JUMBO_PKT_BUF_SZ	(9046 + tp->rx_offset + 64)
+
+/* minimum number of free TX descriptors required to wake up TX process */
+#define TG3_TX_WAKEUP_THRESH		(TG3_TX_RING_SIZE / 4)
+
+static char version[] __devinitdata =
+	DRV_MODULE_NAME ".c:v" DRV_MODULE_VERSION " (" DRV_MODULE_RELDATE ")\n";
+
+MODULE_AUTHOR("David S. Miller (davem@redhat.com) and Jeff Garzik (jgarzik@mandrakesoft.com)");
+MODULE_DESCRIPTION("Broadcom Tigon3 ethernet driver");
+MODULE_LICENSE("GPL");
+MODULE_PARM(tg3_debug, "i");
+MODULE_PARM_DESC(tg3_debug, "Tigon3 bitmapped debugging message enable value");
+
+static int tg3_debug = -1;	/* -1 == use TG3_DEF_MSG_ENABLE as value */
+
+static struct pci_device_id tg3_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5700,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5701,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5703,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702FE,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702X,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5703X,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_SYSKONNECT, 0x4400,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_ALTIMA, PCI_DEVICE_ID_ALTIMA_AC1000,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, tg3_pci_tbl);
+
+static void tg3_write_indirect_reg32(struct tg3 *tp, u32 off, u32 val)
+{
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_TARGET_HWBUG) != 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&tp->indirect_lock, flags);
+		pci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off);
+		pci_write_config_dword(tp->pdev, TG3PCI_REG_DATA, val);
+		spin_unlock_irqrestore(&tp->indirect_lock, flags);
+	} else {
+		writel(val, tp->regs + off);
+	}
+}
+
+#define tw32(reg,val)		tg3_write_indirect_reg32(tp,(reg),(val))
+#define tw32_mailbox(reg, val)	writel(((val) & 0xffffffff), tp->regs + (reg))
+#define tw16(reg,val)		writew(((val) & 0xffff), tp->regs + (reg))
+#define tw8(reg,val)		writeb(((val) & 0xff), tp->regs + (reg))
+#define tr32(reg)		readl(tp->regs + (reg))
+#define tr16(reg)		readw(tp->regs + (reg))
+#define tr8(reg)		readb(tp->regs + (reg))
+
+static void tg3_write_mem(struct tg3 *tp, u32 off, u32 val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->indirect_lock, flags);
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+	spin_unlock_irqrestore(&tp->indirect_lock, flags);
+}
+
+static void tg3_read_mem(struct tg3 *tp, u32 off, u32 *val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->indirect_lock, flags);
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_read_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+	spin_unlock_irqrestore(&tp->indirect_lock, flags);
+}
+
+static void tg3_disable_ints(struct tg3 *tp)
+{
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     (tp->misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT));
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);
+}
+
+static void tg3_enable_ints(struct tg3 *tp)
+{
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     (tp->misc_host_ctrl & ~MISC_HOST_CTRL_MASK_PCI_INT));
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000000);
+
+	if (tp->hw_status->status & SD_STATUS_UPDATED)
+		tw32(GRC_LOCAL_CTRL,
+		     tp->grc_local_ctrl | GRC_LCLCTRL_SETINT);
+}
+
+#define PHY_BUSY_LOOPS	5000
+
+static int tg3_readphy(struct tg3 *tp, int reg, u32 *val)
+{
+	u32 frame_val;
+	int loops, ret;
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE,
+		     (tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));
+		udelay(40);
+	}
+
+	*val = 0xffffffff;
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (MI_COM_CMD_READ | MI_COM_START);
+	
+	tw32(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		frame_val = tr32(MAC_MI_COM);
+
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+		udelay(10);
+	}
+
+	ret = -EBUSY;
+	if (loops > 0) {
+		*val = frame_val & MI_COM_DATA_MASK;
+		ret = 0;
+	}
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE, tp->mi_mode);
+		udelay(40);
+	}
+
+	return ret;
+}
+
+static int tg3_writephy(struct tg3 *tp, int reg, u32 val)
+{
+	u32 frame_val;
+	int loops, ret;
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE,
+		     (tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));
+		udelay(40);
+	}
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (val & MI_COM_DATA_MASK);
+	frame_val |= (MI_COM_CMD_WRITE | MI_COM_START);
+	
+	tw32(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		frame_val = tr32(MAC_MI_COM);
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+		udelay(10);
+	}
+
+	ret = -EBUSY;
+	if (loops > 0)
+		ret = 0;
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE, tp->mi_mode);
+		udelay(40);
+	}
+
+	return ret;
+}
+
+/* This will reset the tigon3 PHY if there is no valid
+ * link unless the FORCE argument is non-zero.
+ */
+static int tg3_phy_reset(struct tg3 *tp, int force)
+{
+	u32 phy_status, phy_control;
+	int err, limit;
+
+	err  = tg3_readphy(tp, MII_BMSR, &phy_status);
+	err |= tg3_readphy(tp, MII_BMSR, &phy_status);
+	if (err != 0)
+		return -EBUSY;
+
+	/* If we have link, and not forcing a reset, then nothing
+	 * to do.
+	 */
+	if ((phy_status & BMSR_LSTATUS) != 0 && (force == 0))
+		return 0;
+
+	/* OK, reset it, and poll the BMCR_RESET bit until it
+	 * clears or we time out.
+	 */
+	phy_control = BMCR_RESET;
+	err = tg3_writephy(tp, MII_BMCR, phy_control);
+	if (err != 0)
+		return -EBUSY;
+
+	limit = 5000;
+	while (limit--) {
+		err = tg3_readphy(tp, MII_BMCR, &phy_control);
+		if (err != 0)
+			return -EBUSY;
+
+		if ((phy_control & BMCR_RESET) == 0) {
+			udelay(40);
+			return 0;
+		}
+		udelay(10);
+	}
+
+	return -EBUSY;
+}
+
+static int tg3_setup_phy(struct tg3 *);
+static int tg3_halt(struct tg3 *);
+
+static int tg3_set_power_state(struct tg3 *tp, int state)
+{
+	u32 misc_host_ctrl;
+	u16 power_control, power_caps;
+	int pm = tp->pm_cap;
+
+	/* Make sure register accesses (indirect or otherwise)
+	 * will function correctly.
+	 */
+	pci_write_config_dword(tp->pdev,
+			       TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	pci_read_config_word(tp->pdev,
+			     pm + PCI_PM_CTRL,
+			     &power_control);
+	power_control |= PCI_PM_CTRL_PME_STATUS;
+	power_control &= ~(PCI_PM_CTRL_STATE_MASK);
+	switch (state) {
+	case 0:
+		power_control |= 0;
+		pci_write_config_word(tp->pdev,
+				      pm + PCI_PM_CTRL,
+				      power_control);
+		tw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x02);
+		return 0;
+
+	case 1:
+		power_control |= 1;
+		break;
+
+	case 2:
+		power_control |= 2;
+		break;
+
+	case 3:
+		power_control |= 3;
+		break;
+
+	default:
+		printk(KERN_WARNING "%s: Invalid power state (%d) requested.\n",
+		       tp->dev->name, state);
+		return -EINVAL;
+	};
+
+	power_control |= PCI_PM_CTRL_PME_ENABLE;
+
+	misc_host_ctrl = tr32(TG3PCI_MISC_HOST_CTRL);
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT);
+
+	if (tp->link_config.phy_is_low_power == 0) {
+		tp->link_config.phy_is_low_power = 1;
+		tp->link_config.orig_speed = tp->link_config.speed;
+		tp->link_config.orig_duplex = tp->link_config.duplex;
+		tp->link_config.orig_autoneg = tp->link_config.autoneg;
+	}
+
+	tp->link_config.speed = SPEED_10;
+	tp->link_config.autoneg = AUTONEG_ENABLE;
+	tg3_setup_phy(tp);
+
+	tg3_halt(tp);
+
+	pci_read_config_word(tp->pdev, pm + PCI_PM_PMC, &power_caps);
+
+	if (tp->tg3_flags & TG3_FLAG_WOL_ENABLE) {
+		u32 mac_mode;
+
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x5a);
+
+		mac_mode = MAC_MODE_PORT_MODE_MII |
+			MAC_MODE_LINK_POLARITY;
+
+		if (((power_caps & PCI_PM_CAP_PME_D3cold) &&
+		     (tp->tg3_flags & TG3_FLAG_WOL_ENABLE)))
+			mac_mode |= MAC_MODE_MAGIC_PKT_ENABLE;
+
+		tw32(MAC_MODE, mac_mode);
+		tw32(MAC_RX_MODE, RX_MODE_ENABLE);
+	}
+
+	if (tp->tg3_flags & TG3_FLAG_WOL_SPEED_100MB) {
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_ALTCLK));
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_44MHZ_CORE));
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_ALTCLK |
+		      CLOCK_CTRL_44MHZ_CORE));
+	} else {
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_ALTCLK |
+		      CLOCK_CTRL_PWRDOWN_PLL133));
+	}
+
+	udelay(40);
+
+	if ((power_caps & PCI_PM_CAP_PME_D3cold) &&
+	    (tp->tg3_flags & TG3_FLAG_WOL_ENABLE)) {
+		/* Move to auxilliary power. */
+		tw32(GRC_LOCAL_CTRL,
+		     (GRC_LCLCTRL_GPIO_OE0 |
+		      GRC_LCLCTRL_GPIO_OE1 |
+		      GRC_LCLCTRL_GPIO_OE2 |
+		      GRC_LCLCTRL_GPIO_OUTPUT0 |
+		      GRC_LCLCTRL_GPIO_OUTPUT1));
+	}
+
+	/* Finally, set the new power state. */
+	pci_write_config_word(tp->pdev, pm + PCI_PM_CTRL, power_control);
+
+	return 0;
+}
+
+static void tg3_link_report(struct tg3 *tp)
+{
+	if (!netif_carrier_ok(tp->dev)) {
+		printk("%s: Link is down.\n", tp->dev->name);
+	} else {
+		printk("%s: Link is up at %d Mbps, %s duplex.\n",
+		       tp->dev->name,
+		       (tp->link_config.active_speed == SPEED_1000 ?
+			1000 :
+			(tp->link_config.active_speed == SPEED_100 ?
+			 100 : 10)),
+		       (tp->link_config.active_duplex == DUPLEX_FULL ?
+			"full" : "half"));
+
+		printk("%s: Flow control is %s for TX and %s for RX.\n",
+		       tp->dev->name,
+		       (tp->tg3_flags & TG3_FLAG_TX_PAUSE) ? "on" : "off",
+		       (tp->tg3_flags & TG3_FLAG_RX_PAUSE) ? "on" : "off");
+	}
+}
+
+static void tg3_setup_flow_control(struct tg3 *tp, u32 local_adv, u32 remote_adv)
+{
+	u32 new_tg3_flags = 0;
+
+	if (local_adv & ADVERTISE_PAUSE_CAP) {
+		if (local_adv & ADVERTISE_PAUSE_ASYM) {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+			else if (remote_adv & LPA_PAUSE_ASYM)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE);
+		} else {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+		}
+	} else if (local_adv & ADVERTISE_PAUSE_ASYM) {
+		if ((remote_adv & LPA_PAUSE_CAP) &&
+		    (remote_adv & LPA_PAUSE_ASYM))
+			new_tg3_flags |= TG3_FLAG_TX_PAUSE;
+	}
+
+	tp->tg3_flags &= ~(TG3_FLAG_RX_PAUSE | TG3_FLAG_TX_PAUSE);
+	tp->tg3_flags |= new_tg3_flags;
+
+	if (new_tg3_flags & TG3_FLAG_RX_PAUSE)
+		tp->rx_mode |= RX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->rx_mode &= ~RX_MODE_FLOW_CTRL_ENABLE;
+
+	if (new_tg3_flags & TG3_FLAG_TX_PAUSE)
+		tp->tx_mode |= TX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->tx_mode &= ~TX_MODE_FLOW_CTRL_ENABLE;
+}
+
+static void tg3_aux_stat_to_speed_duplex(struct tg3 *tp, u32 val, u16 *speed, u8 *duplex)
+{
+	switch (val & MII_TG3_AUX_STAT_SPDMASK) {
+	case MII_TG3_AUX_STAT_10HALF:
+		*speed = SPEED_10;
+		*duplex = DUPLEX_HALF;
+		break;
+
+	case MII_TG3_AUX_STAT_10FULL:
+		*speed = SPEED_10;
+		*duplex = DUPLEX_FULL;
+		break;
+
+	case MII_TG3_AUX_STAT_100HALF:
+		*speed = SPEED_100;
+		*duplex = DUPLEX_HALF;
+		break;
+
+	case MII_TG3_AUX_STAT_100FULL:
+		*speed = SPEED_100;
+		*duplex = DUPLEX_FULL;
+		break;
+
+	case MII_TG3_AUX_STAT_1000HALF:
+		*speed = SPEED_1000;
+		*duplex = DUPLEX_HALF;
+		break;
+
+	case MII_TG3_AUX_STAT_1000FULL:
+		*speed = SPEED_1000;
+		*duplex = DUPLEX_FULL;
+		break;
+
+	default:
+		*speed = SPEED_INVALID;
+		*duplex = DUPLEX_INVALID;
+		break;
+	};
+}
+
+static int tg3_phy_copper_begin(struct tg3 *tp, int wait_for_link)
+{
+	u32 new_adv;
+	int i;
+
+	if (tp->link_config.phy_is_low_power) {
+		/* Entering low power mode.  Disable gigabit and
+		 * 100baseT advertisements.
+		 */
+		tg3_writephy(tp, MII_TG3_CTRL, 0);
+
+		new_adv = (ADVERTISE_10HALF | ADVERTISE_10FULL |
+			   ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+		if (tp->tg3_flags & TG3_FLAG_WOL_SPEED_100MB)
+			new_adv |= (ADVERTISE_100HALF | ADVERTISE_100FULL);
+
+		tg3_writephy(tp, MII_ADVERTISE, new_adv);
+	} else if (tp->link_config.speed == SPEED_INVALID) {
+		tp->link_config.advertising =
+			(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+			 ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+			 ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+			 ADVERTISED_Autoneg | ADVERTISED_MII);
+
+		if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+			tp->link_config.advertising &=
+				~(ADVERTISED_1000baseT_Half |
+				  ADVERTISED_1000baseT_Full);
+
+		new_adv = (ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+		if (tp->link_config.advertising & ADVERTISED_10baseT_Half)
+			new_adv |= ADVERTISE_10HALF;
+		if (tp->link_config.advertising & ADVERTISED_10baseT_Full)
+			new_adv |= ADVERTISE_10FULL;
+		if (tp->link_config.advertising & ADVERTISED_100baseT_Half)
+			new_adv |= ADVERTISE_100HALF;
+		if (tp->link_config.advertising & ADVERTISED_100baseT_Full)
+			new_adv |= ADVERTISE_100FULL;
+		tg3_writephy(tp, MII_ADVERTISE, new_adv);
+
+		if (tp->link_config.advertising &
+		    (ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full)) {
+			new_adv = 0;
+			if (tp->link_config.advertising & ADVERTISED_1000baseT_Half)
+				new_adv |= MII_TG3_CTRL_ADV_1000_HALF;
+			if (tp->link_config.advertising & ADVERTISED_1000baseT_Full)
+				new_adv |= MII_TG3_CTRL_ADV_1000_FULL;
+			if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+			    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)
+				new_adv |= (MII_TG3_CTRL_AS_MASTER |
+					    MII_TG3_CTRL_ENABLE_AS_MASTER);
+			tg3_writephy(tp, MII_TG3_CTRL, new_adv);
+		} else {
+			tg3_writephy(tp, MII_TG3_CTRL, 0);
+		}
+	} else {
+		/* Asking for a specific link mode. */
+		if (tp->link_config.speed == SPEED_1000) {
+			new_adv = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP;
+			tg3_writephy(tp, MII_ADVERTISE, new_adv);
+
+			if (tp->link_config.duplex == DUPLEX_FULL)
+				new_adv = MII_TG3_CTRL_ADV_1000_FULL;
+			else
+				new_adv = MII_TG3_CTRL_ADV_1000_HALF;
+			if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+			    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)
+				new_adv |= (MII_TG3_CTRL_AS_MASTER |
+					    MII_TG3_CTRL_ENABLE_AS_MASTER);
+			tg3_writephy(tp, MII_TG3_CTRL, new_adv);
+		} else {
+			tg3_writephy(tp, MII_TG3_CTRL, 0);
+
+			new_adv = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP;
+			if (tp->link_config.speed == SPEED_100) {
+				if (tp->link_config.duplex == DUPLEX_FULL)
+					new_adv |= ADVERTISE_100FULL;
+				else
+					new_adv |= ADVERTISE_100HALF;
+			} else {
+				if (tp->link_config.duplex == DUPLEX_FULL)
+					new_adv |= ADVERTISE_10FULL;
+				else
+					new_adv |= ADVERTISE_10HALF;
+			}
+			tg3_writephy(tp, MII_ADVERTISE, new_adv);
+		}
+	}
+
+	if (tp->link_config.autoneg == AUTONEG_DISABLE &&
+	    tp->link_config.speed != SPEED_INVALID) {
+		u32 bmcr, orig_bmcr;
+
+		tp->link_config.active_speed = tp->link_config.speed;
+		tp->link_config.active_duplex = tp->link_config.duplex;
+
+		bmcr = 0;
+		switch (tp->link_config.speed) {
+		default:
+		case SPEED_10:
+			break;
+
+		case SPEED_100:
+			bmcr |= BMCR_SPEED100;
+			break;
+
+		case SPEED_1000:
+			bmcr |= TG3_BMCR_SPEED1000;
+			break;
+		};
+
+		if (tp->link_config.duplex == DUPLEX_FULL)
+			bmcr |= BMCR_FULLDPLX;
+
+		tg3_readphy(tp, MII_BMCR, &orig_bmcr);
+		if (bmcr != orig_bmcr) {
+			tg3_writephy(tp, MII_BMCR, BMCR_LOOPBACK);
+			for (i = 0; i < 15000; i++) {
+				u32 tmp;
+
+				udelay(10);
+				tg3_readphy(tp, MII_BMSR, &tmp);
+				tg3_readphy(tp, MII_BMSR, &tmp);
+				if (!(tmp & BMSR_LSTATUS)) {
+					udelay(40);
+					break;
+				}
+			}
+			tg3_writephy(tp, MII_BMCR, bmcr);
+			udelay(40);
+		}
+	} else {
+		tg3_writephy(tp, MII_BMCR,
+			     BMCR_ANENABLE | BMCR_ANRESTART);
+	}
+
+	if (wait_for_link) {
+		tp->link_config.active_speed = SPEED_INVALID;
+		tp->link_config.active_duplex = DUPLEX_INVALID;
+		for (i = 0; i < 300000; i++) {
+			u32 tmp;
+
+			udelay(10);
+			tg3_readphy(tp, MII_BMSR, &tmp);
+			tg3_readphy(tp, MII_BMSR, &tmp);
+			if (!(tmp & BMSR_LSTATUS))
+				continue;
+
+			tg3_readphy(tp, MII_TG3_AUX_STAT, &tmp);
+			tg3_aux_stat_to_speed_duplex(tp, tmp,
+						     &tp->link_config.active_speed,
+						     &tp->link_config.active_duplex);
+		}
+		if (tp->link_config.active_speed == SPEED_INVALID)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int tg3_init_5401phy_dsp(struct tg3 *tp)
+{
+	int err;
+
+	/* Turn off tap power management. */
+	err  = tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c20);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x0012);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x1804);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x0013);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x1204);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8006);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0132);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8006);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0232);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x201f);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0a20);
+
+	udelay(40);
+
+	return err;
+}
+
+static int tg3_setup_copper_phy(struct tg3 *tp)
+{
+	int current_link_up;
+	u32 bmsr, dummy;
+	u16 current_speed;
+	u8 current_duplex;
+	int i, err;
+
+	tw32(MAC_STATUS,
+	     (MAC_STATUS_SYNC_CHANGED |
+	      MAC_STATUS_CFG_CHANGED));
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32(MAC_MI_MODE, tp->mi_mode);
+	udelay(40);
+
+	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401) {
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE))
+			bmsr = 0;
+
+		if (!(bmsr & BMSR_LSTATUS)) {
+			err = tg3_init_5401phy_dsp(tp);
+			if (err)
+				return err;
+
+			tg3_readphy(tp, MII_BMSR, &bmsr);
+			for (i = 0; i < 1000; i++) {
+				udelay(10);
+				tg3_readphy(tp, MII_BMSR, &bmsr);
+				if (bmsr & BMSR_LSTATUS) {
+					udelay(40);
+					break;
+				}
+			}
+
+			if ((tp->phy_id & PHY_ID_REV_MASK) == PHY_REV_BCM5401_B0 &&
+			    !(bmsr & BMSR_LSTATUS) &&
+			    tp->link_config.active_speed == SPEED_1000) {
+				err = tg3_phy_reset(tp, 1);
+				if (!err)
+					err = tg3_init_5401phy_dsp(tp);
+				if (err)
+					return err;
+			}
+		}
+	} else if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+		   tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+		/* 5701 {A0,B0} CRC bug workaround */
+		tg3_writephy(tp, 0x15, 0x0a75);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+		tg3_writephy(tp, 0x1c, 0x8d68);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+	}
+
+	/* Clear pending interrupts... */
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+
+	if (tp->tg3_flags & TG3_FLAG_USE_MI_INTERRUPT)
+		tg3_writephy(tp, MII_TG3_IMASK, ~MII_TG3_INT_LINKCHG);
+	else
+		tg3_writephy(tp, MII_TG3_IMASK, ~0);
+
+	if (tp->led_mode == led_mode_three_link)
+		tg3_writephy(tp, MII_TG3_EXT_CTRL,
+			     MII_TG3_EXT_CTRL_LNK3_LED_MODE);
+	else
+		tg3_writephy(tp, MII_TG3_EXT_CTRL, 0);
+
+	current_link_up = 0;
+	current_speed = SPEED_INVALID;
+	current_duplex = DUPLEX_INVALID;
+
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+
+	if (bmsr & BMSR_LSTATUS) {
+		u32 aux_stat, bmcr;
+
+		tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+		for (i = 0; i < 2000; i++) {
+			udelay(10);
+			tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+			if (aux_stat)
+				break;
+		}
+
+		tg3_aux_stat_to_speed_duplex(tp, aux_stat,
+					     &current_speed,
+					     &current_duplex);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		if (tp->link_config.autoneg == AUTONEG_ENABLE) {
+			if (bmcr & BMCR_ANENABLE) {
+				u32 gig_ctrl;
+
+				current_link_up = 1;
+
+				/* Force autoneg restart if we are exiting
+				 * low power mode.
+				 */
+				tg3_readphy(tp, MII_TG3_CTRL, &gig_ctrl);
+				if (!(gig_ctrl & (MII_TG3_CTRL_ADV_1000_HALF |
+						  MII_TG3_CTRL_ADV_1000_FULL))) {
+					current_link_up = 0;
+				}
+			} else {
+				current_link_up = 0;
+			}
+		} else {
+			if (!(bmcr & BMCR_ANENABLE) &&
+			    tp->link_config.speed == current_speed &&
+			    tp->link_config.duplex == current_duplex) {
+				current_link_up = 1;
+			} else {
+				current_link_up = 0;
+			}
+		}
+
+		tp->link_config.active_speed = current_speed;
+		tp->link_config.active_duplex = current_duplex;
+	}
+
+	if (current_link_up == 1 &&
+	    (tp->link_config.active_duplex == DUPLEX_FULL) &&
+	    (tp->link_config.autoneg == AUTONEG_ENABLE)) {
+		u32 local_adv, remote_adv;
+
+		tg3_readphy(tp, MII_ADVERTISE, &local_adv);
+		local_adv &= (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+		tg3_readphy(tp, MII_LPA, &remote_adv);
+		remote_adv &= (LPA_PAUSE_CAP | LPA_PAUSE_ASYM);
+
+		/* If we are not advertising full pause capability,
+		 * something is wrong.  Bring the link down and reconfigure.
+		 */
+		if (local_adv != ADVERTISE_PAUSE_CAP) {
+			current_link_up = 0;
+		} else {
+			tg3_setup_flow_control(tp, local_adv, remote_adv);
+		}
+	}
+
+	if (current_link_up == 0) {
+		u32 tmp;
+
+		tg3_phy_copper_begin(tp, 0);
+
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		if (tmp & BMSR_LSTATUS)
+			current_link_up = 1;
+	}
+
+	tp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;
+	if (current_link_up == 1) {
+		if (tp->link_config.active_speed == SPEED_100 ||
+		    tp->link_config.active_speed == SPEED_10)
+			tp->mac_mode |= MAC_MODE_PORT_MODE_MII;
+		else
+			tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+	} else
+		tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+
+	tp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;
+	if (tp->link_config.active_duplex == DUPLEX_HALF)
+		tp->mac_mode |= MAC_MODE_HALF_DUPLEX;
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701 ||
+	    GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+		if (current_link_up == 1)
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+		tw32(MAC_LED_CTRL, LED_CTRL_PHY_MODE_1);
+	} else {
+		if ((tp->led_mode == led_mode_link10) ||
+		    (current_link_up == 1 &&
+		     tp->link_config.active_speed == SPEED_10))
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+	}
+	tw32(MAC_MODE, tp->mac_mode);
+
+	if (tp->tg3_flags & TG3_FLAG_USE_LINKCHG_REG) {
+		/* Polled via timer. */
+		tw32(MAC_EVENT, 0);
+	} else {
+		tw32(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 &&
+	    current_link_up == 1 &&
+	    tp->link_config.active_speed == SPEED_1000 &&
+	    ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ||
+	     (tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED))) {
+		udelay(120);
+		tw32(MAC_STATUS,
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED));
+		tg3_write_mem(tp,
+			      NIC_SRAM_FIRMWARE_MBOX,
+			      NIC_SRAM_FIRMWARE_MBOX_MAGIC2);
+	}
+
+	if (current_link_up != netif_carrier_ok(tp->dev)) {
+		if (current_link_up)
+			netif_carrier_on(tp->dev);
+		else
+			netif_carrier_off(tp->dev);
+		tg3_link_report(tp);
+	}
+
+	return 0;
+}
+
+struct tg3_fiber_aneginfo {
+	int state;
+#define ANEG_STATE_UNKNOWN		0
+#define ANEG_STATE_AN_ENABLE		1
+#define ANEG_STATE_RESTART_INIT		2
+#define ANEG_STATE_RESTART		3
+#define ANEG_STATE_DISABLE_LINK_OK	4
+#define ANEG_STATE_ABILITY_DETECT_INIT	5
+#define ANEG_STATE_ABILITY_DETECT	6
+#define ANEG_STATE_ACK_DETECT_INIT	7
+#define ANEG_STATE_ACK_DETECT		8
+#define ANEG_STATE_COMPLETE_ACK_INIT	9
+#define ANEG_STATE_COMPLETE_ACK		10
+#define ANEG_STATE_IDLE_DETECT_INIT	11
+#define ANEG_STATE_IDLE_DETECT		12
+#define ANEG_STATE_LINK_OK		13
+#define ANEG_STATE_NEXT_PAGE_WAIT_INIT	14
+#define ANEG_STATE_NEXT_PAGE_WAIT	15
+
+	u32 flags;
+#define MR_AN_ENABLE		0x00000001
+#define MR_RESTART_AN		0x00000002
+#define MR_AN_COMPLETE		0x00000004
+#define MR_PAGE_RX		0x00000008
+#define MR_NP_LOADED		0x00000010
+#define MR_TOGGLE_TX		0x00000020
+#define MR_LP_ADV_FULL_DUPLEX	0x00000040
+#define MR_LP_ADV_HALF_DUPLEX	0x00000080
+#define MR_LP_ADV_SYM_PAUSE	0x00000100
+#define MR_LP_ADV_ASYM_PAUSE	0x00000200
+#define MR_LP_ADV_REMOTE_FAULT1	0x00000400
+#define MR_LP_ADV_REMOTE_FAULT2	0x00000800
+#define MR_LP_ADV_NEXT_PAGE	0x00001000
+#define MR_TOGGLE_RX		0x00002000
+#define MR_NP_RX		0x00004000
+
+#define MR_LINK_OK		0x80000000
+
+	unsigned long link_time, cur_time;
+
+	u32 ability_match_cfg;
+	int ability_match_count;
+
+	char ability_match, idle_match, ack_match;
+
+	u32 txconfig, rxconfig;
+#define ANEG_CFG_NP		0x00000080
+#define ANEG_CFG_ACK		0x00000040
+#define ANEG_CFG_RF2		0x00000020
+#define ANEG_CFG_RF1		0x00000010
+#define ANEG_CFG_PS2		0x00000001
+#define ANEG_CFG_PS1		0x00008000
+#define ANEG_CFG_HD		0x00004000
+#define ANEG_CFG_FD		0x00002000
+#define ANEG_CFG_INVAL		0x00001f06
+
+};
+#define ANEG_OK		0
+#define ANEG_DONE	1
+#define ANEG_TIMER_ENAB	2
+#define ANEG_FAILED	-1
+
+
+static int tg3_fiber_aneg_smachine(struct tg3 *tp,
+				   struct tg3_fiber_aneginfo *ap)
+{
+	unsigned long delta;
+	u32 rx_cfg_reg;
+	int ret;
+
+	if (ap->state == ANEG_STATE_UNKNOWN) {
+		ap->rxconfig = 0;
+		ap->link_time = 0;
+		ap->cur_time = 0;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->idle_match = 0;
+		ap->ack_match = 0;
+	}
+	ap->cur_time++;
+
+	if (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {
+		rx_cfg_reg = tr32(MAC_RX_AUTO_NEG);
+
+		if (rx_cfg_reg != ap->ability_match_cfg) {
+			ap->ability_match_cfg = rx_cfg_reg;
+			ap->ability_match = 0;
+			ap->ability_match_count = 0;
+		} else {
+			if (++ap->ability_match_count > 1)
+				ap->ability_match = 1;
+		}
+		if (rx_cfg_reg & ANEG_CFG_ACK)
+			ap->ack_match = 1;
+		else
+			ap->ack_match = 0;
+
+		ap->idle_match = 0;
+	} else {
+		ap->idle_match = 1;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->ack_match = 0;
+
+		rx_cfg_reg = 0;
+	}
+
+	ap->rxconfig = rx_cfg_reg;
+	ret = ANEG_OK;
+
+	switch(ap->state) {
+	case ANEG_STATE_UNKNOWN:
+		if (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))
+			ap->state = ANEG_STATE_AN_ENABLE;
+
+		/* fallthru */
+	case ANEG_STATE_AN_ENABLE:
+		ap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);
+		if (ap->flags & MR_AN_ENABLE) {
+			ap->link_time = 0;
+			ap->cur_time = 0;
+			ap->ability_match_cfg = 0;
+			ap->ability_match_count = 0;
+			ap->ability_match = 0;
+			ap->idle_match = 0;
+			ap->ack_match = 0;
+
+			ap->state = ANEG_STATE_RESTART_INIT;
+		} else {
+			ap->state = ANEG_STATE_DISABLE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_RESTART_INIT:
+		ap->link_time = ap->cur_time;
+		ap->flags &= ~(MR_NP_LOADED);
+		ap->txconfig = 0;
+		tw32(MAC_TX_AUTO_NEG, 0);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ret = ANEG_TIMER_ENAB;
+		ap->state = ANEG_STATE_RESTART;
+
+		/* fallthru */
+	case ANEG_STATE_RESTART:
+		delta = ap->cur_time - ap->link_time;
+		if (delta > 100000)
+			ap->state = ANEG_STATE_ABILITY_DETECT_INIT;
+		else
+			ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_DISABLE_LINK_OK:
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT_INIT:
+		ap->flags &= ~(MR_TOGGLE_TX);
+		ap->txconfig = (ANEG_CFG_FD | ANEG_CFG_PS1);
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ap->state = ANEG_STATE_ABILITY_DETECT;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT:
+		if (ap->ability_match != 0 && ap->rxconfig != 0)
+			ap->state = ANEG_STATE_ACK_DETECT_INIT;
+		break;
+
+	case ANEG_STATE_ACK_DETECT_INIT:
+		ap->txconfig |= ANEG_CFG_ACK;
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ap->state = ANEG_STATE_ACK_DETECT;
+
+		/* fallthru */
+	case ANEG_STATE_ACK_DETECT:
+		if (ap->ack_match != 0) {
+			if ((ap->rxconfig & ~ANEG_CFG_ACK) ==
+			    (ap->ability_match_cfg & ~ANEG_CFG_ACK))
+				ap->state = ANEG_STATE_COMPLETE_ACK_INIT;
+			else
+				ap->state = ANEG_STATE_AN_ENABLE;
+		} else if (ap->ability_match != 0 &&
+			   ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+		}
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK_INIT:
+		if (ap->rxconfig & ANEG_CFG_INVAL) {
+			ret = ANEG_FAILED;
+			break;
+		}
+		ap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |
+			       MR_LP_ADV_HALF_DUPLEX |
+			       MR_LP_ADV_SYM_PAUSE |
+			       MR_LP_ADV_ASYM_PAUSE |
+			       MR_LP_ADV_REMOTE_FAULT1 |
+			       MR_LP_ADV_REMOTE_FAULT2 |
+			       MR_LP_ADV_NEXT_PAGE |
+			       MR_TOGGLE_RX |
+			       MR_NP_RX);
+		if (ap->rxconfig & ANEG_CFG_FD)
+			ap->flags |= MR_LP_ADV_FULL_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_HD)
+			ap->flags |= MR_LP_ADV_FULL_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_PS1)
+			ap->flags |= MR_LP_ADV_SYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_PS2)
+			ap->flags |= MR_LP_ADV_ASYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_RF1)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT1;
+		if (ap->rxconfig & ANEG_CFG_RF2)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT2;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_LP_ADV_NEXT_PAGE;
+
+		ap->link_time = ap->cur_time;
+
+		ap->flags ^= (MR_TOGGLE_TX);
+		if (ap->rxconfig & 0x0008)
+			ap->flags |= MR_TOGGLE_RX;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_NP_RX;
+		ap->flags |= MR_PAGE_RX;
+
+		ap->state = ANEG_STATE_COMPLETE_ACK;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > 100000) {
+			if (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {
+				ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+			} else {
+				if ((ap->txconfig & 0x0080) == 0 &&
+				    !(ap->flags & MR_NP_RX))
+					ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+				else
+					ret = ANEG_FAILED;
+			}
+		}
+		break;
+
+	case ANEG_STATE_IDLE_DETECT_INIT:
+		ap->link_time = ap->cur_time;
+		tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ap->state = ANEG_STATE_IDLE_DETECT;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_IDLE_DETECT:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > 100000) {
+			/* XXX another gem from the Broadcom driver :( */
+			ap->state = ANEG_STATE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_LINK_OK:
+		ap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT_INIT:
+		/* ??? unimplemented */
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT:
+		/* ??? unimplemented */
+		break;
+
+	default:
+		ret = ANEG_FAILED;
+		break;
+	};
+
+	return ret;
+}
+
+static int tg3_setup_fiber_phy(struct tg3 *tp)
+{
+	int current_link_up;
+	int i;
+
+	tp->mac_mode &= ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);
+	tp->mac_mode |= MAC_MODE_PORT_MODE_TBI;
+	tw32(MAC_MODE, tp->mac_mode);
+	udelay(40);
+
+	/* Reset when initting first time or we have a link. */
+	if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+	    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+		/* Set PLL lock range. */
+		tg3_writephy(tp, 0x16, 0x8007);
+
+		/* SW reset */
+		tg3_writephy(tp, 0x00, 0x8000);
+
+		/* Wait for reset to complete. */
+		/* XXX schedule_timeout() ... */
+		for (i = 0; i < 500; i++)
+			udelay(10);
+
+		/* Config mode; select PMA/Ch 1 regs. */
+		tg3_writephy(tp, 0x10, 0x8411);
+
+		/* Enable auto-lock and comdet, select txclk for tx. */
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		tg3_writephy(tp, 0x18, 0x00a0);
+		tg3_writephy(tp, 0x16, 0x41ff);
+
+		/* Assert and deassert POR. */
+		tg3_writephy(tp, 0x13, 0x0400);
+		udelay(40);
+		tg3_writephy(tp, 0x13, 0x0000);
+
+		tg3_writephy(tp, 0x11, 0x0a50);
+		udelay(40);
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		/* Wait for signal to stabilize */
+		/* XXX schedule_timeout() ... */
+		for (i = 0; i < 15000; i++)
+			udelay(10);
+
+		/* Deselect the channel register so we can read the PHYID
+		 * later.
+		 */
+		tg3_writephy(tp, 0x10, 0x8011);
+	}
+
+	/* Enable link change interrupt. */
+	tw32(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);
+
+	current_link_up = 0;
+	if (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) {
+		if (tp->link_config.autoneg == AUTONEG_ENABLE) {
+			struct tg3_fiber_aneginfo aninfo;
+			int status = ANEG_FAILED;
+
+			memset(&aninfo, 0, sizeof(aninfo));
+			aninfo.flags |= (MR_AN_ENABLE);
+
+			for (i = 0; i < 6; i++) {
+				unsigned int tick;
+				u32 tmp;
+
+				tw32(MAC_TX_AUTO_NEG, 0);
+
+				tmp = tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK;
+				tw32(MAC_MODE, tmp | MAC_MODE_PORT_MODE_GMII);
+				udelay(20);
+
+				tw32(MAC_MODE, tp->mac_mode | MAC_MODE_SEND_CONFIGS);
+
+				aninfo.state = ANEG_STATE_UNKNOWN;
+				aninfo.cur_time = 0;
+				tick = 0;
+				while (++tick < 95000) {
+					status = tg3_fiber_aneg_smachine(tp, &aninfo);
+					if (status == ANEG_DONE ||
+					    status == ANEG_FAILED)
+						break;
+
+					udelay(1);
+				}
+				if (status == ANEG_DONE ||
+				    status == ANEG_FAILED)
+					break;
+			}
+
+			tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+			tw32(MAC_MODE, tp->mac_mode);
+
+			if (status == ANEG_DONE &&
+			    (aninfo.flags & MR_AN_COMPLETE) &&
+			    (aninfo.flags & MR_LINK_OK) &&
+			    (aninfo.flags & MR_LP_ADV_FULL_DUPLEX)) {
+				u32 local_adv, remote_adv;
+
+				local_adv = ADVERTISE_PAUSE_CAP;
+				remote_adv = 0;
+				if (aninfo.flags & MR_LP_ADV_SYM_PAUSE)
+					remote_adv |= LPA_PAUSE_CAP;
+				if (aninfo.flags & MR_LP_ADV_ASYM_PAUSE)
+					remote_adv |= LPA_PAUSE_ASYM;
+
+				tg3_setup_flow_control(tp, local_adv, remote_adv);
+
+				current_link_up = 1;
+			}
+			for (i = 0; i < 60; i++) {
+				udelay(20);
+				tw32(MAC_STATUS,
+				     (MAC_STATUS_SYNC_CHANGED |
+				      MAC_STATUS_CFG_CHANGED));
+
+				udelay(20);
+				if ((tr32(MAC_STATUS) &
+				     (MAC_STATUS_SYNC_CHANGED |
+				      MAC_STATUS_CFG_CHANGED)) == 0)
+					break;
+			}
+		} else {
+			/* Forcing 1000FD link up. */
+			current_link_up = 1;
+		}
+	}
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	tw32(MAC_MODE, tp->mac_mode);
+
+	tp->hw_status->status =
+		(SD_STATUS_UPDATED |
+		 (tp->hw_status->status & ~SD_STATUS_LINK_CHG));
+
+	for (i = 0; i < 100; i++) {
+		tw32(MAC_STATUS,
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED));
+		udelay(5);
+
+		if ((tr32(MAC_STATUS) &
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED)) == 0)
+			break;
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0)
+		current_link_up = 0;
+
+	if (current_link_up == 1) {
+		tp->link_config.active_speed = SPEED_1000;
+		tp->link_config.active_duplex = DUPLEX_FULL;
+	} else {
+		tp->link_config.active_speed = SPEED_INVALID;
+		tp->link_config.active_duplex = DUPLEX_INVALID;
+	}
+
+	if (current_link_up != netif_carrier_ok(tp->dev)) {
+		if (current_link_up)
+			netif_carrier_on(tp->dev);
+		else
+			netif_carrier_off(tp->dev);
+		tg3_link_report(tp);
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0) {
+		tw32(MAC_MODE, tp->mac_mode | MAC_MODE_LINK_POLARITY);
+		if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) {
+			udelay(1);
+			tw32(MAC_MODE, tp->mac_mode);
+		}
+	}
+
+	return 0;
+}
+
+static int tg3_setup_phy(struct tg3 *tp)
+{
+	int err;
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		err = tg3_setup_fiber_phy(tp);
+	} else {
+		err = tg3_setup_copper_phy(tp);
+	}
+
+	if (tp->link_config.active_speed == SPEED_1000 &&
+	    tp->link_config.active_duplex == DUPLEX_HALF)
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (0xff << TX_LENGTHS_SLOT_TIME_SHIFT)));
+	else
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (32 << TX_LENGTHS_SLOT_TIME_SHIFT)));
+
+	return err;
+}
+
+/* Tigon3 never reports partial packet sends.  So we do not
+ * need special logic to handle SKBs that have not had all
+ * of their frags sent yet, like SunGEM does.
+ */
+static void tg3_tx(struct tg3 *tp)
+{
+	u32 hw_idx = tp->hw_status->idx[0].tx_consumer;
+	u32 sw_idx = tp->tx_cons;
+
+	while (sw_idx != hw_idx) {
+		struct ring_info *ri = &tp->tx_buffers[sw_idx];
+		struct sk_buff *skb = ri->skb;
+		int i;
+
+		if (unlikely(skb == NULL))
+			BUG();
+
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(ri, mapping),
+				 (skb->len - skb->data_len),
+				 PCI_DMA_TODEVICE);
+
+		ri->skb = NULL;
+
+		sw_idx = NEXT_TX(sw_idx);
+
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			if (unlikely(sw_idx == hw_idx))
+				BUG();
+
+			ri = &tp->tx_buffers[sw_idx];
+			if (unlikely(ri->skb != NULL))
+				BUG();
+
+			pci_unmap_page(tp->pdev,
+				       pci_unmap_addr(ri, mapping),
+				       skb_shinfo(skb)->frags[i].size,
+				       PCI_DMA_TODEVICE);
+
+			sw_idx = NEXT_TX(sw_idx);
+		}
+
+		dev_kfree_skb_irq(skb);
+	}
+
+	tp->tx_cons = sw_idx;
+
+	if (netif_queue_stopped(tp->dev) &&
+	    (TX_BUFFS_AVAIL(tp) > TG3_TX_WAKEUP_THRESH))
+		netif_wake_queue(tp->dev);
+}
+
+/* Returns size of skb allocated or < 0 on error.
+ *
+ * We only need to fill in the address because the other members
+ * of the RX descriptor are invariant, see tg3_init_rings.
+ *
+ * Note the purposeful assymetry of cpu vs. chip accesses.  For
+ * posting buffers we only dirty the first cache line of the RX
+ * descriptor (containing the address).  Whereas for the RX status
+ * buffers the cpu only reads the last cacheline of the RX descriptor
+ * (to fetch the error flags, vlan tag, checksum, and opaque cookie).
+ */
+static int tg3_alloc_rx_skb(struct tg3 *tp, u32 opaque_key,
+			    int src_idx, u32 dest_idx_unmasked)
+{
+	struct tg3_rx_buffer_desc *desc;
+	struct ring_info *map, *src_map;
+	struct sk_buff *skb;
+	dma_addr_t mapping;
+	int skb_size, dest_idx;
+
+	src_map = NULL;
+	switch (opaque_key) {
+	case RXD_OPAQUE_RING_STD:
+		dest_idx = dest_idx_unmasked % TG3_RX_RING_SIZE;
+		desc = &tp->rx_std[dest_idx];
+		map = &tp->rx_std_buffers[dest_idx];
+		if (src_idx >= 0)
+			src_map = &tp->rx_std_buffers[src_idx];
+		skb_size = RX_PKT_BUF_SZ;
+		break;
+
+	case RXD_OPAQUE_RING_JUMBO:
+		dest_idx = dest_idx_unmasked % TG3_RX_JUMBO_RING_SIZE;
+		desc = &tp->rx_jumbo[dest_idx];
+		map = &tp->rx_jumbo_buffers[dest_idx];
+		if (src_idx >= 0)
+			src_map = &tp->rx_jumbo_buffers[src_idx];
+		skb_size = RX_JUMBO_PKT_BUF_SZ;
+		break;
+#if TG3_MINI_RING_WORKS
+	case RXD_OPAQUE_RING_MINI:
+		dest_idx = dest_idx_unmasked % TG3_RX_MINI_RING_SIZE;
+		desc = &tp->rx_mini[dest_idx];
+		map = &tp->rx_mini_buffers[dest_idx];
+		if (src_idx >= 0)
+			src_map = &tp->rx_mini_buffers[src_idx];
+		skb_size = RX_MINI_PKT_BUF_SZ;
+		break;
+#endif
+	default:
+		return -EINVAL;
+	};
+
+	/* Do not overwrite any of the map or rp information
+	 * until we are sure we can commit to a new buffer.
+	 *
+	 * Callers depend upon this behavior and assume that
+	 * we leave everything unchanged if we fail.
+	 */
+	skb = dev_alloc_skb(skb_size);
+	if (skb == NULL)
+		return -ENOMEM;
+
+	skb->dev = tp->dev;
+	skb_reserve(skb, tp->rx_offset);
+
+	mapping = pci_map_single(tp->pdev, skb->data,
+				 skb_size - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+
+	map->skb = skb;
+	pci_unmap_addr_set(map, mapping, mapping);
+
+	if (src_map != NULL)
+		src_map->skb = NULL;
+
+	desc->addr_hi = ((u64)mapping >> 32);
+	desc->addr_lo = ((u64)mapping & 0xffffffff);
+
+	return skb_size;
+}
+
+/* We only need to move over in the address because the other
+ * members of the RX descriptor are invariant.  See notes above
+ * tg3_alloc_rx_skb for full details.
+ */
+static void tg3_recycle_rx(struct tg3 *tp, u32 opaque_key,
+			   int src_idx, u32 dest_idx_unmasked)
+{
+	struct tg3_rx_buffer_desc *src_desc, *dest_desc;
+	struct ring_info *src_map, *dest_map;
+	int dest_idx;
+
+	switch (opaque_key) {
+	case RXD_OPAQUE_RING_STD:
+		dest_idx = dest_idx_unmasked % TG3_RX_RING_SIZE;
+		dest_desc = &tp->rx_std[dest_idx];
+		dest_map = &tp->rx_std_buffers[dest_idx];
+		src_desc = &tp->rx_std[src_idx];
+		src_map = &tp->rx_std_buffers[src_idx];
+		break;
+
+	case RXD_OPAQUE_RING_JUMBO:
+		dest_idx = dest_idx_unmasked % TG3_RX_JUMBO_RING_SIZE;
+		dest_desc = &tp->rx_jumbo[dest_idx];
+		dest_map = &tp->rx_jumbo_buffers[dest_idx];
+		src_desc = &tp->rx_jumbo[src_idx];
+		src_map = &tp->rx_jumbo_buffers[src_idx];
+		break;
+#if TG3_MINI_RING_WORKS
+	case RXD_OPAQUE_RING_MINI:
+		dest_idx = dest_idx_unmasked % TG3_RX_MINI_RING_SIZE;
+		dest_desc = &tp->rx_mini[dest_idx];
+		dest_map = &tp->rx_mini_buffers[dest_idx];
+		src_desc = &tp->rx_mini[src_idx];
+		src_map = &tp->rx_mini_buffers[src_idx];
+		break;
+#endif
+	default:
+		return;
+	};
+
+	dest_map->skb = src_map->skb;
+	pci_unmap_addr_set(dest_map, mapping,
+			   pci_unmap_addr(src_map, mapping));
+	dest_desc->addr_hi = src_desc->addr_hi;
+	dest_desc->addr_lo = src_desc->addr_lo;
+
+	src_map->skb = NULL;
+}
+
+#if TG3_VLAN_TAG_USED
+static int tg3_vlan_rx(struct tg3 *tp, struct sk_buff *skb, u16 vlan_tag)
+{
+	return vlan_hwaccel_rx(skb, tp->vlgrp, vlan_tag);
+}
+#endif
+
+/* The RX ring scheme is composed of multiple rings which post fresh
+ * buffers to the chip, and one special ring the chip uses to report
+ * status back to the host.
+ *
+ * The special ring reports the status of received packets to the
+ * host.  The chip does not write into the original descriptor the
+ * RX buffer was obtained from.  The chip simply takes the original
+ * descriptor as provided by the host, updates the status and length
+ * field, then writes this into the next status ring entry.
+ *
+ * Each ring the host uses to post buffers to the chip is described
+ * by a TG3_BDINFO entry in the chips SRAM area.  When a packet arrives,
+ * it is first placed into the on-chip ram.  When the packet's length
+ * is known, it walks down the TG3_BDINFO entries to select the ring.
+ * Each TG3_BDINFO specifies a MAXLEN field and the first TG3_BDINFO
+ * which is within the range of the new packet's length is chosen.
+ *
+ * The "seperate ring for rx status" scheme may sound queer, but it makes
+ * sense from a cache coherency perspective.  If only the host writes
+ * to the buffer post rings, and only the chip writes to the rx status
+ * rings, then cache lines never move beyond shared-modified state.
+ * If both the host and chip were to write into the same ring, cache line
+ * eviction could occur since both entities want it in an exclusive state.
+ */
+static void tg3_rx(struct tg3 *tp)
+{
+	u32 work_mask;
+	u32 rx_rcb_ptr = tp->rx_rcb_ptr;
+	u16 hw_idx, sw_idx;
+
+	hw_idx = tp->hw_status->idx[0].rx_producer;
+	sw_idx = rx_rcb_ptr % TG3_RX_RCB_RING_SIZE;
+	work_mask = 0;
+	while (sw_idx != hw_idx) {
+		struct tg3_rx_buffer_desc *desc = &tp->rx_rcb[sw_idx];
+		unsigned int len;
+		struct sk_buff *skb;
+		dma_addr_t dma_addr;
+		u32 opaque_key, desc_idx, *post_ptr;
+
+		desc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;
+		opaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;
+		if (opaque_key == RXD_OPAQUE_RING_STD) {
+			dma_addr = pci_unmap_addr(&tp->rx_std_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_std_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_std_ptr;
+		} else if (opaque_key == RXD_OPAQUE_RING_JUMBO) {
+			dma_addr = pci_unmap_addr(&tp->rx_jumbo_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_jumbo_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_jumbo_ptr;
+		}
+#if TG3_MINI_RING_WORKS
+		else if (opaque_key == RXD_OPAQUE_RING_MINI) {
+			dma_addr = pci_unmap_addr(&tp->rx_mini_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_mini_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_mini_ptr;
+		}
+#endif
+		else {
+			goto next_pkt_nopost;
+		}
+
+		work_mask |= opaque_key;
+
+		if ((desc->err_vlan & RXD_ERR_MASK) != 0 &&
+		    (desc->err_vlan != RXD_ERR_ODD_NIBBLE_RCVD_MII)) {
+		drop_it:
+			tg3_recycle_rx(tp, opaque_key,
+				       desc_idx, *post_ptr);
+		drop_it_no_recycle:
+			/* Other statistics kept track of by card. */
+			tp->net_stats.rx_dropped++;
+			goto next_pkt;
+		}
+
+		len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) - 4; /* omit crc */
+
+		/* Kill the copy case if we ever get the mini ring working. */
+		if (len > RX_COPY_THRESHOLD) {
+			int skb_size;
+
+			skb_size = tg3_alloc_rx_skb(tp, opaque_key,
+						    desc_idx, *post_ptr);
+			if (skb_size < 0)
+				goto drop_it;
+
+			pci_unmap_single(tp->pdev, dma_addr,
+					 skb_size - tp->rx_offset,
+					 PCI_DMA_FROMDEVICE);
+
+			skb_put(skb, len);
+		} else {
+			struct sk_buff *copy_skb;
+
+			tg3_recycle_rx(tp, opaque_key,
+				       desc_idx, *post_ptr);
+
+			copy_skb = dev_alloc_skb(len + 2);
+			if (copy_skb == NULL)
+				goto drop_it_no_recycle;
+
+			copy_skb->dev = tp->dev;
+			skb_reserve(copy_skb, 2);
+			skb_put(copy_skb, len);
+			pci_dma_sync_single(tp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);
+			memcpy(copy_skb->data, skb->data, len);
+
+			/* We'll reuse the original ring buffer. */
+			skb = copy_skb;
+		}
+
+		if ((tp->tg3_flags & TG3_FLAG_RX_CHECKSUMS) &&
+		    (desc->type_flags & RXD_FLAG_TCPUDP_CSUM)) {
+			skb->csum = htons((desc->ip_tcp_csum & RXD_TCPCSUM_MASK)
+					  >> RXD_TCPCSUM_SHIFT);
+			skb->ip_summed = CHECKSUM_HW;
+		} else {
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+
+		skb->protocol = eth_type_trans(skb, tp->dev);
+#if TG3_VLAN_TAG_USED
+		if (tp->vlgrp != NULL &&
+		    desc->type_flags & RXD_FLAG_VLAN) {
+			tg3_vlan_rx(tp, skb,
+				    desc->err_vlan & RXD_VLAN_MASK);
+		} else
+#endif
+			netif_rx(skb);
+
+		tp->dev->last_rx = jiffies;
+
+next_pkt:
+		(*post_ptr)++;
+next_pkt_nopost:
+		rx_rcb_ptr++;
+		sw_idx = rx_rcb_ptr % TG3_RX_RCB_RING_SIZE;
+	}
+
+	/* ACK the status ring. */
+	tp->rx_rcb_ptr = rx_rcb_ptr;
+	tw32_mailbox(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW,
+		     (rx_rcb_ptr % TG3_RX_RCB_RING_SIZE));
+
+	/* Refill RX ring(s). */
+	if (work_mask & RXD_OPAQUE_RING_STD) {
+		sw_idx = tp->rx_std_ptr % TG3_RX_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+	}
+	if (work_mask & RXD_OPAQUE_RING_JUMBO) {
+		sw_idx = tp->rx_jumbo_ptr % TG3_RX_JUMBO_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+	}
+#if TG3_MINI_RING_WORKS
+	if (work_mask & RXD_OPAQUE_RING_MINI) {
+		sw_idx = tp->rx_mini_ptr % TG3_RX_MINI_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_MINI_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+	}
+#endif
+}
+
+#define PKT_RATE_LOW		22000
+#define PKT_RATE_HIGH		61000
+
+static void tg3_rate_sample(struct tg3 *tp, unsigned long ticks)
+{
+	u32 delta, rx_now, tx_now;
+	int new_vals, do_tx, do_rx;
+
+	rx_now = tp->hw_stats->rx_ucast_packets.low;
+	tx_now = tp->hw_stats->COS_out_packets[0].low;
+
+	delta  = (rx_now - tp->last_rx_count);
+	delta += (tx_now - tp->last_tx_count);
+	delta /= (ticks / tp->coalesce_config.rate_sample_jiffies);
+
+	tp->last_rx_count = rx_now;
+	tp->last_tx_count = tx_now;
+
+	new_vals = 0;
+	do_tx = (tp->tg3_flags & TG3_FLAG_ADAPTIVE_TX) != 0;
+	do_rx = (tp->tg3_flags & TG3_FLAG_ADAPTIVE_RX) != 0;
+	if (delta < tp->coalesce_config.pkt_rate_low) {
+		if (do_rx &&
+		    tp->coalesce_config.rx_max_coalesced_frames !=
+		    tp->coalesce_config.rx_max_coalesced_frames_low) {
+			tp->coalesce_config.rx_max_coalesced_frames =
+				LOW_RXMAX_FRAMES;
+			tp->coalesce_config.rx_coalesce_ticks =
+				LOW_RXCOL_TICKS;
+			new_vals = 1;
+		}
+		if (do_tx &&
+		    tp->coalesce_config.tx_max_coalesced_frames !=
+		    tp->coalesce_config.tx_max_coalesced_frames_low) {
+			tp->coalesce_config.tx_max_coalesced_frames =
+				tp->coalesce_config.tx_max_coalesced_frames_low;
+			tp->coalesce_config.tx_coalesce_ticks =
+				tp->coalesce_config.tx_coalesce_ticks_low;
+			new_vals = 1;
+		}
+	} else if (delta < tp->coalesce_config.pkt_rate_high) {
+		if (do_rx &&
+		    tp->coalesce_config.rx_max_coalesced_frames !=
+		    tp->coalesce_config.rx_max_coalesced_frames_def) {
+			tp->coalesce_config.rx_max_coalesced_frames =
+				tp->coalesce_config.rx_max_coalesced_frames_def;
+			tp->coalesce_config.rx_coalesce_ticks =
+				tp->coalesce_config.rx_coalesce_ticks_def;
+			new_vals = 1;
+		}
+		if (do_tx &&
+		    tp->coalesce_config.tx_max_coalesced_frames !=
+		    tp->coalesce_config.tx_max_coalesced_frames_def) {
+			tp->coalesce_config.tx_max_coalesced_frames =
+				tp->coalesce_config.tx_max_coalesced_frames_def;
+			tp->coalesce_config.tx_coalesce_ticks =
+				tp->coalesce_config.tx_coalesce_ticks_def;
+			new_vals = 1;
+		}
+	} else {
+		if (do_rx &&
+		    tp->coalesce_config.rx_max_coalesced_frames !=
+		    tp->coalesce_config.rx_max_coalesced_frames_high) {
+			tp->coalesce_config.rx_max_coalesced_frames =
+				tp->coalesce_config.rx_max_coalesced_frames_high;
+			tp->coalesce_config.rx_coalesce_ticks =
+				tp->coalesce_config.rx_coalesce_ticks_high;
+			new_vals = 1;
+		}
+		if (do_tx &&
+		    tp->coalesce_config.tx_max_coalesced_frames !=
+		    tp->coalesce_config.tx_max_coalesced_frames_high) {
+			tp->coalesce_config.tx_max_coalesced_frames =
+				tp->coalesce_config.tx_max_coalesced_frames_high;
+			tp->coalesce_config.tx_coalesce_ticks =
+				tp->coalesce_config.tx_coalesce_ticks_high;
+			new_vals = 1;
+		}
+	}
+
+	if (new_vals) {
+		if (do_rx) {
+			tw32(HOSTCC_RXCOL_TICKS,
+			     tp->coalesce_config.rx_coalesce_ticks);
+			tw32(HOSTCC_RXMAX_FRAMES,
+			     tp->coalesce_config.rx_max_coalesced_frames);
+		}
+		if (do_tx) {
+			tw32(HOSTCC_TXCOL_TICKS,
+			     tp->coalesce_config.tx_coalesce_ticks);
+			tw32(HOSTCC_TXMAX_FRAMES,
+			     tp->coalesce_config.tx_max_coalesced_frames);
+		}
+	}
+
+	tp->last_rate_sample = jiffies;
+}
+
+static void tg3_interrupt_main_work(struct tg3 *tp)
+{
+	struct tg3_hw_status *sblk = tp->hw_status;
+	int did_pkts;
+
+	if (!(tp->tg3_flags & TG3_FLAG_USE_LINKCHG_REG)) {
+		if (sblk->status & SD_STATUS_LINK_CHG) {
+			sblk->status = SD_STATUS_UPDATED |
+				(sblk->status & ~SD_STATUS_LINK_CHG);
+			tg3_setup_phy(tp);
+		}
+	}
+
+	did_pkts = 0;
+	if (sblk->idx[0].rx_producer != tp->rx_rcb_ptr) {
+		tg3_rx(tp);
+		did_pkts = 1;
+	}
+
+	if (sblk->idx[0].tx_consumer != tp->tx_cons) {
+		tg3_tx(tp);
+		did_pkts = 1;
+	}
+
+	if (did_pkts &&
+	    (tp->tg3_flags & (TG3_FLAG_ADAPTIVE_RX | TG3_FLAG_ADAPTIVE_TX))) {
+		unsigned long ticks = jiffies - tp->last_rate_sample;
+
+		if (ticks >= tp->coalesce_config.rate_sample_jiffies)
+			tg3_rate_sample(tp, ticks);
+	}
+}
+
+static void tg3_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	struct tg3 *tp = dev->priv;
+	struct tg3_hw_status *sblk = tp->hw_status;
+
+	spin_lock(&tp->lock);
+
+	while (sblk->status & SD_STATUS_UPDATED) {
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,
+			     0x00000001);
+		sblk->status &= ~SD_STATUS_UPDATED;
+
+		tg3_interrupt_main_work(tp);
+
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,
+			     0x00000000);
+		tr32(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW);
+	}
+
+	spin_unlock(&tp->lock);
+}
+
+static void tg3_interrupt_tagged(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	struct tg3 *tp = dev->priv;
+	struct tg3_hw_status *sblk = tp->hw_status;
+
+	spin_lock(&tp->lock);
+
+	if (sblk->status & SD_STATUS_UPDATED) {
+		u32 oldtag;
+
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,
+			     0x00000001);
+		oldtag = sblk->status_tag;
+
+		while (1) {
+			u32 newtag;
+
+			sblk->status &= ~SD_STATUS_UPDATED;
+			barrier();
+
+			tg3_interrupt_main_work(tp);
+
+			newtag = sblk->status_tag;
+			if (newtag == oldtag) {
+				tw32_mailbox(MAILBOX_INTERRUPT_0 +
+					     TG3_64BIT_REG_LOW,
+					     newtag << 24);
+				break;
+			}
+			oldtag = newtag;
+		}
+	}
+
+	spin_unlock(&tp->lock);
+}
+
+static void tg3_init_rings(struct tg3 *);
+static int tg3_init_hw(struct tg3 *);
+
+static void tg3_tx_timeout(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+
+	printk(KERN_ERR "%s: transmit timed out, resetting\n",
+	       dev->name);
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_halt(tp);
+	tg3_init_rings(tp);
+	tg3_init_hw(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	netif_wake_queue(dev);
+}
+
+#if !PCI_DMA_BUS_IS_PHYS
+static void tg3_set_txd_addr(struct tg3 *tp, int entry, dma_addr_t mapping)
+{
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		struct tg3_tx_buffer_desc *txd = &tp->tx_ring[entry];
+
+		txd->addr_hi = ((u64) mapping >> 32);
+		txd->addr_lo = ((u64) mapping & 0xffffffff);
+	} else {
+		unsigned long txd;
+
+		txd = (tp->regs +
+		       NIC_SRAM_WIN_BASE +
+		       NIC_SRAM_TX_BUFFER_DESC);
+		txd += (entry * TXD_SIZE);
+
+		if (sizeof(dma_addr_t) != sizeof(u32))
+			writel(((u64) mapping >> 32),
+			       txd + TXD_ADDR + TG3_64BIT_REG_HIGH);
+
+		writel(((u64) mapping & 0xffffffff),
+		       txd + TXD_ADDR + TG3_64BIT_REG_LOW);
+	}
+}
+#endif
+
+static void tg3_set_txd(struct tg3 *, int, dma_addr_t, int, u32, int);
+
+static int tigon3_4gb_hwbug_workaround(struct tg3 *tp, struct sk_buff *skb,
+				       u32 guilty_entry, int guilty_len,
+				       u32 last_plus_one, u32 *start)
+{
+	dma_addr_t new_addr;
+	u32 entry = *start;
+	int i;
+
+#if !PCI_DMA_BUS_IS_PHYS
+	/* IOMMU, just map the guilty area again which is guarenteed to
+	 * use different addresses.
+	 */
+
+	i = 0;
+	while (entry != guilty_entry) {
+		entry = NEXT_TX(entry);
+		i++;
+	}
+	if (i == 0) {
+		new_addr = pci_map_single(tp->pdev, skb->data, guilty_len,
+					  PCI_DMA_TODEVICE);
+	} else {
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i - 1];
+
+		new_addr = pci_map_page(tp->pdev,
+					frag->page, frag->page_offset,
+					guilty_len, PCI_DMA_TODEVICE);
+	}
+	pci_unmap_single(tp->pdev, pci_unmap_addr(&tp->tx_buffers[guilty_entry],
+						  mapping),
+			 guilty_len, PCI_DMA_TODEVICE);
+	tg3_set_txd_addr(tp, guilty_entry, new_addr);
+	pci_unmap_addr_set(&tp->tx_buffers[guilty_entry], mapping,
+			   new_addr);
+	*start = last_plus_one;
+#else
+	/* Oh well, no IOMMU, have to allocate a whole new SKB. */
+	struct sk_buff *new_skb = skb_copy(skb, GFP_ATOMIC);
+
+	if (!new_skb) {
+		dev_kfree_skb(skb);
+		return -1;
+	}
+
+	/* NOTE: Broadcom's driver botches this case up really bad.
+	 *       This is especially true if any of the frag pages
+	 *       are in highmem.  It will instantly oops in that case.
+	 */
+
+	/* New SKB is guarenteed to be linear. */
+	entry = *start;
+	new_addr = pci_map_single(tp->pdev, new_skb->data, new_skb->len,
+				  PCI_DMA_TODEVICE);
+	tg3_set_txd(tp, entry, new_addr, new_skb->len,
+		    (skb->ip_summed == CHECKSUM_HW) ?
+		    TXD_FLAG_TCPUDP_CSUM : 0, 1);
+	*start = NEXT_TX(entry);
+
+	/* Now clean up the sw ring entries. */
+	i = 0;
+	while (entry != last_plus_one) {
+		int len;
+
+		if (i == 0)
+			len = skb->len - skb->data_len;
+		else
+			len = skb_shinfo(skb)->frags[i-1].size;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(&tp->tx_buffers[entry], mapping),
+				 len, PCI_DMA_TODEVICE);
+		if (i == 0) {
+			tp->tx_buffers[entry].skb = new_skb;
+			pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, new_addr);
+		} else {
+			tp->tx_buffers[entry].skb = NULL;
+		}
+		entry = NEXT_TX(entry);
+	}
+
+	dev_kfree_skb(skb);
+#endif
+
+	return 0;
+}
+
+static void tg3_set_txd(struct tg3 *tp, int entry,
+			dma_addr_t mapping, int len, u32 flags,
+			int is_end)
+{
+#if TG3_VLAN_TAG_USED
+	u16 vlan_tag = 0;
+#endif
+
+	if (is_end)
+		flags |= TXD_FLAG_END;
+#if TG3_VLAN_TAG_USED
+	if (flags & TXD_FLAG_VLAN) {
+		vlan_tag = flags >> 16;
+		flags &= 0xffff;
+	}
+#endif
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		struct tg3_tx_buffer_desc *txd = &tp->tx_ring[entry];
+
+		txd->addr_hi = ((u64) mapping >> 32);
+		txd->addr_lo = ((u64) mapping & 0xffffffff);
+		txd->len_flags = (len << TXD_LEN_SHIFT) | flags;
+#if TG3_VLAN_TAG_USED
+		txd->vlan_tag = vlan_tag << TXD_VLAN_TAG_SHIFT;
+#endif
+	} else {
+		unsigned long txd;
+
+		txd = (tp->regs +
+		       NIC_SRAM_WIN_BASE +
+		       NIC_SRAM_TX_BUFFER_DESC);
+		txd += (entry * TXD_SIZE);
+
+		/* Save some PIOs */
+		if (sizeof(dma_addr_t) != sizeof(u32))
+			writel(((u64) mapping >> 32),
+			       txd + TXD_ADDR + TG3_64BIT_REG_HIGH);
+
+		writel(((u64) mapping & 0xffffffff),
+		       txd + TXD_ADDR + TG3_64BIT_REG_LOW);
+		writel(len << TXD_LEN_SHIFT | flags, txd + TXD_LEN_FLAGS);
+#if TG3_VLAN_TAG_USED
+		writel(vlan_tag << TXD_VLAN_TAG_SHIFT, txd + TXD_VLAN_TAG);
+#endif
+	}
+}
+
+static inline int tg3_4g_overflow_test(dma_addr_t mapping, int len)
+{
+	u32 base = (u32) mapping & 0xffffffff;
+
+	return ((base > 0xffffdcc0) &&
+		((u64) mapping >> 32) == 0 &&
+		(base + len + 8 < base));
+}
+
+static int tg3_start_xmit_4gbug(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	dma_addr_t mapping;
+	unsigned int i;
+	u32 len, entry, base_flags;
+	int would_hit_hwbug;
+
+	len = (skb->len - skb->data_len);
+
+	spin_lock_irq(&tp->lock);
+
+	/* This is a hard error, log it. */
+	if (unlikely(TX_BUFFS_AVAIL(tp) <= (skb_shinfo(skb)->nr_frags + 1))) {
+		netif_stop_queue(dev);
+		spin_unlock_irq(&tp->lock);
+		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
+		       dev->name);
+		return 1;
+	}
+
+	entry = tp->tx_prod;
+	base_flags = 0;
+	if (skb->ip_summed == CHECKSUM_HW)
+		base_flags |= TXD_FLAG_TCPUDP_CSUM;
+#if TG3_VLAN_TAG_USED
+	if (tp->vlgrp != NULL && vlan_tx_tag_present(skb))
+		base_flags |= (TXD_FLAG_VLAN |
+			       (vlan_tx_tag_get(skb) << 16));
+#endif
+
+	/* Queue skb data, a.k.a. the main skb fragment. */
+	mapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);
+
+	tp->tx_buffers[entry].skb = skb;
+	pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+	would_hit_hwbug = 0;
+
+	if (tg3_4g_overflow_test(mapping, len))
+		would_hit_hwbug = entry + 1;
+
+	tg3_set_txd(tp, entry, mapping, len, base_flags,
+		    (skb_shinfo(skb)->nr_frags == 0));
+
+	entry = NEXT_TX(entry);
+
+	/* Now loop through additional data fragments, and queue them. */
+	if (skb_shinfo(skb)->nr_frags > 0) {
+		unsigned int i, last;
+
+		last = skb_shinfo(skb)->nr_frags - 1;
+		for (i = 0; i <= last; i++) {
+			skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+
+			len = frag->size;
+			mapping = pci_map_page(tp->pdev,
+					       frag->page,
+					       frag->page_offset,
+					       len, PCI_DMA_TODEVICE);
+
+			tp->tx_buffers[entry].skb = NULL;
+			pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+			if (tg3_4g_overflow_test(mapping, len)) {
+				/* Only one should match. */
+				if (would_hit_hwbug)
+					BUG();
+				would_hit_hwbug = entry + 1;
+			}
+
+			tg3_set_txd(tp, entry, mapping, len,
+				    base_flags, (i == last));
+
+			entry = NEXT_TX(entry);
+		}
+	}
+
+	if (would_hit_hwbug) {
+		u32 last_plus_one = entry;
+		u32 start;
+		unsigned int len = 0;
+
+		would_hit_hwbug -= 1;
+		entry = entry - 1 - skb_shinfo(skb)->nr_frags;
+		entry &= (TG3_TX_RING_SIZE - 1);
+		start = entry;
+		i = 0;
+		while (entry != last_plus_one) {
+			if (i == 0)
+				len = skb->len - skb->data_len;
+			else
+				len = skb_shinfo(skb)->frags[i-1].size;
+
+			if (entry == would_hit_hwbug)
+				break;
+
+			i++;
+			entry = NEXT_TX(entry);
+
+		}
+
+		/* If the workaround fails due to memory/mapping
+		 * failure, silently drop this packet.
+		 */
+		if (tigon3_4gb_hwbug_workaround(tp, skb,
+						entry, len,
+						last_plus_one,
+						&start))
+			goto out_unlock;
+
+		entry = start;
+	}
+
+	/* Packets are ready, update Tx producer idx local and on card. */
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+		if (tp->tg3_flags & TG3_FLAG_TXD_MBOX_HWBUG)
+			tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 +
+				      TG3_64BIT_REG_LOW), entry);
+	} else {
+		tw32_mailbox((MAILBOX_SNDNIC_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+		if (tp->tg3_flags & TG3_FLAG_TXD_MBOX_HWBUG)
+			tw32_mailbox((MAILBOX_SNDNIC_PROD_IDX_0 +
+				      TG3_64BIT_REG_LOW), entry);
+	}
+
+	tp->tx_prod = entry;
+	if (TX_BUFFS_AVAIL(tp) <= (MAX_SKB_FRAGS + 1))
+		netif_stop_queue(dev);
+
+out_unlock:
+	spin_unlock_irq(&tp->lock);
+
+	dev->trans_start = jiffies;
+
+	return 0;
+}
+
+static int tg3_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	dma_addr_t mapping;
+	u32 len, entry, base_flags;
+
+	len = (skb->len - skb->data_len);
+
+	spin_lock_irq(&tp->lock);
+
+	/* This is a hard error, log it. */
+	if (unlikely(TX_BUFFS_AVAIL(tp) <= (skb_shinfo(skb)->nr_frags + 1))) {
+		netif_stop_queue(dev);
+		spin_unlock_irq(&tp->lock);
+		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
+		       dev->name);
+		return 1;
+	}
+
+	entry = tp->tx_prod;
+	base_flags = 0;
+	if (skb->ip_summed == CHECKSUM_HW)
+		base_flags |= TXD_FLAG_TCPUDP_CSUM;
+#if TG3_VLAN_TAG_USED
+	if (tp->vlgrp != NULL && vlan_tx_tag_present(skb))
+		base_flags |= (TXD_FLAG_VLAN |
+			       (vlan_tx_tag_get(skb) << 16));
+#endif
+
+	/* Queue skb data, a.k.a. the main skb fragment. */
+	mapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);
+
+	tp->tx_buffers[entry].skb = skb;
+	pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+	tg3_set_txd(tp, entry, mapping, len, base_flags,
+		    (skb_shinfo(skb)->nr_frags == 0));
+
+	entry = NEXT_TX(entry);
+
+	/* Now loop through additional data fragments, and queue them. */
+	if (skb_shinfo(skb)->nr_frags > 0) {
+		unsigned int i, last;
+
+		last = skb_shinfo(skb)->nr_frags - 1;
+		for (i = 0; i <= last; i++) {
+			skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+
+
+			len = frag->size;
+			mapping = pci_map_page(tp->pdev,
+					       frag->page,
+					       frag->page_offset,
+					       len, PCI_DMA_TODEVICE);
+
+			tp->tx_buffers[entry].skb = NULL;
+			pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+			tg3_set_txd(tp, entry, mapping, len,
+				    base_flags, (i == last));
+
+			entry = NEXT_TX(entry);
+		}
+	}
+
+	/* Packets are ready, update Tx producer idx local and on card.
+	 * We know this is not a 5700 (by virtue of not being a chip
+	 * requiring the 4GB overflow workaround) so we can safely omit
+	 * the double-write bug tests.
+	 */
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+	} else {
+		tw32_mailbox((MAILBOX_SNDNIC_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+	}
+
+	tp->tx_prod = entry;
+	if (TX_BUFFS_AVAIL(tp) <= (MAX_SKB_FRAGS + 1))
+		netif_stop_queue(dev);
+
+	spin_unlock_irq(&tp->lock);
+
+	dev->trans_start = jiffies;
+
+	return 0;
+}
+
+static int tg3_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct tg3 *tp = dev->priv;
+
+	if (new_mtu < TG3_MIN_MTU || new_mtu > TG3_MAX_MTU)
+		return -EINVAL;
+
+	if (!netif_running(dev)) {
+		/* We'll just catch it later when the
+		 * device is up'd.
+		 */
+		dev->mtu = new_mtu;
+		return 0;
+	}
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_halt(tp);
+
+	dev->mtu = new_mtu;
+
+	if (new_mtu > ETH_DATA_LEN)
+		tp->tg3_flags |= TG3_FLAG_JUMBO_ENABLE;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_JUMBO_ENABLE;
+
+	tg3_init_rings(tp);
+	tg3_init_hw(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+/* Free up pending packets in all rx/tx rings.
+ *
+ * The chip has been shut down and the driver detached from
+ * the networking, so no interrupts or new tx packets will
+ * end up in the driver.  tp->lock is not held and we are not
+ * in an interrupt context and thus may sleep.
+ */
+static void tg3_free_rings(struct tg3 *tp)
+{
+	struct ring_info *rxp;
+	int i;
+
+	for (i = 0; i < TG3_RX_RING_SIZE; i++) {
+		rxp = &tp->rx_std_buffers[i];
+
+		if (rxp->skb == NULL)
+			continue;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(rxp, mapping),
+				 RX_PKT_BUF_SZ - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(rxp->skb);
+		rxp->skb = NULL;
+	}
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < TG3_RX_MINI_RING_SIZE; i++) {
+		rxp = &tp->rx_mini_buffers[i];
+
+		if (rxp->skb == NULL)
+			continue;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(rxp, mapping),
+				 RX_MINI_PKT_BUF_SZ - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(rxp->skb);
+		rxp->skb = NULL;
+	}
+#endif
+	for (i = 0; i < TG3_RX_JUMBO_RING_SIZE; i++) {
+		rxp = &tp->rx_jumbo_buffers[i];
+
+		if (rxp->skb == NULL)
+			continue;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(rxp, mapping),
+				 RX_JUMBO_PKT_BUF_SZ - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(rxp->skb);
+		rxp->skb = NULL;
+	}
+
+	for (i = 0; i < TG3_TX_RING_SIZE; ) {
+		struct ring_info *txp;
+		struct sk_buff *skb;
+		int j;
+
+		txp = &tp->tx_buffers[i];
+		skb = txp->skb;
+
+		if (skb == NULL) {
+			i++;
+			continue;
+		}
+
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(txp, mapping),
+				 (skb->len - skb->data_len),
+				 PCI_DMA_TODEVICE);
+		txp->skb = NULL;
+
+		i++;
+
+		for (j = 0; j < skb_shinfo(skb)->nr_frags; j++) {
+			txp = &tp->tx_buffers[i & (TG3_TX_RING_SIZE - 1)];
+			pci_unmap_page(tp->pdev,
+				       pci_unmap_addr(txp, mapping),
+				       skb_shinfo(skb)->frags[j].size,
+				       PCI_DMA_TODEVICE);
+			i++;
+		}
+
+		dev_kfree_skb_any(skb);
+	}
+}
+
+/* Initialize tx/rx rings for packet processing.
+ *
+ * The chip has been shut down and the driver detached from
+ * the networking, so no interrupts or new tx packets will
+ * end up in the driver.  tp->lock is not held and we are not
+ * in an interrupt context and thus may sleep.
+ */
+static void tg3_init_rings(struct tg3 *tp)
+{
+	unsigned long start, end;
+	u32 i;
+
+	/* Free up all the SKBs. */
+	tg3_free_rings(tp);
+
+	/* Zero out all descriptors. */
+	memset(tp->rx_std, 0, TG3_RX_RING_BYTES);
+#if TG3_MINI_RING_WORKS
+	memset(tp->rx_mini, 0, TG3_RX_MINI_RING_BYTES);
+#endif
+	memset(tp->rx_jumbo, 0, TG3_RX_JUMBO_RING_BYTES);
+	memset(tp->rx_rcb, 0, TG3_RX_RCB_RING_BYTES);
+
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		memset(tp->tx_ring, 0, TG3_TX_RING_BYTES);
+	} else {
+		start = (tp->regs +
+			 NIC_SRAM_WIN_BASE +
+			 NIC_SRAM_TX_BUFFER_DESC);
+		end = start + TG3_TX_RING_BYTES;
+		while (start < end) {
+			writel(0, start);
+			start += 4;
+		}
+	}
+
+	/* Initialize invariants of the rings, we only set this
+	 * stuff once.  This works because the card does not
+	 * write into the rx buffer posting rings.
+	 */
+	for (i = 0; i < TG3_RX_RING_SIZE; i++) {
+		struct tg3_rx_buffer_desc *rxd;
+
+		rxd = &tp->rx_std[i];
+		rxd->idx_len = (RX_PKT_BUF_SZ - tp->rx_offset - 64)
+			<< RXD_LEN_SHIFT;
+		rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT);
+		rxd->opaque = (RXD_OPAQUE_RING_STD |
+			       (i << RXD_OPAQUE_INDEX_SHIFT));
+	}
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < TG3_RX_MINI_RING_SIZE; i++) {
+		struct tg3_rx_buffer_desc *rxd;
+
+		rxd = &tp->rx_mini[i];
+		rxd->idx_len = (RX_MINI_PKT_BUF_SZ - tp->rx_offset - 64)
+			<< RXD_LEN_SHIFT;
+		rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT) |
+			RXD_FLAG_MINI;
+		rxd->opaque = (RXD_OPAQUE_RING_MINI |
+			       (i << RXD_OPAQUE_INDEX_SHIFT));
+	}
+#endif
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE) {
+		for (i = 0; i < TG3_RX_JUMBO_RING_SIZE; i++) {
+			struct tg3_rx_buffer_desc *rxd;
+
+			rxd = &tp->rx_jumbo[i];
+			rxd->idx_len = (RX_JUMBO_PKT_BUF_SZ - tp->rx_offset - 64)
+				<< RXD_LEN_SHIFT;
+			rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT) |
+				RXD_FLAG_JUMBO;
+			rxd->opaque = (RXD_OPAQUE_RING_JUMBO |
+			       (i << RXD_OPAQUE_INDEX_SHIFT));
+		}
+	}
+
+	/* Now allocate fresh SKBs for each rx ring. */
+	for (i = 0; i < tp->rx_pending; i++) {
+		if (tg3_alloc_rx_skb(tp, RXD_OPAQUE_RING_STD,
+				     -1, i) < 0)
+			break;
+	}
+
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < tp->rx_mini_pending; i++) {
+		if (tg3_alloc_rx_skb(tp, RXD_OPAQUE_RING_MINI,
+				     -1, i) < 0)
+			break;
+	}
+#endif
+
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE) {
+		for (i = 0; i < tp->rx_jumbo_pending; i++) {
+			if (tg3_alloc_rx_skb(tp, RXD_OPAQUE_RING_JUMBO,
+					     -1, i) < 0)
+				break;
+		}
+	}
+}
+
+/*
+ * Must not be invoked with interrupt sources disabled and
+ * the hardware shutdown down.
+ */
+static void tg3_free_consistent(struct tg3 *tp)
+{
+	if (tp->rx_std_buffers) {
+		kfree(tp->rx_std_buffers);
+		tp->rx_std_buffers = NULL;
+	}
+	if (tp->rx_std) {
+		pci_free_consistent(tp->pdev, TG3_RX_RING_BYTES,
+				    tp->rx_std, tp->rx_std_mapping);
+		tp->rx_std = NULL;
+	}
+#if TG3_MINI_RING_WORKS
+	if (tp->rx_mini) {
+		pci_free_consistent(tp->pdev, TG3_RX_MINI_RING_BYTES,
+				    tp->rx_mini, tp->rx_mini_mapping);
+		tp->rx_mini = NULL;
+	}
+#endif
+	if (tp->rx_jumbo) {
+		pci_free_consistent(tp->pdev, TG3_RX_JUMBO_RING_BYTES,
+				    tp->rx_jumbo, tp->rx_jumbo_mapping);
+		tp->rx_jumbo = NULL;
+	}
+	if (tp->rx_rcb) {
+		pci_free_consistent(tp->pdev, TG3_RX_RCB_RING_BYTES,
+				    tp->rx_rcb, tp->rx_rcb_mapping);
+		tp->rx_rcb = NULL;
+	}
+	if (tp->tx_ring) {
+		pci_free_consistent(tp->pdev, TG3_TX_RING_BYTES,
+			tp->tx_ring, tp->tx_desc_mapping);
+		tp->tx_ring = NULL;
+	}
+	if (tp->hw_status) {
+		pci_free_consistent(tp->pdev, TG3_HW_STATUS_SIZE,
+				    tp->hw_status, tp->status_mapping);
+		tp->hw_status = NULL;
+	}
+	if (tp->hw_stats) {
+		pci_free_consistent(tp->pdev, sizeof(struct tg3_hw_stats),
+				    tp->hw_stats, tp->stats_mapping);
+		tp->hw_stats = NULL;
+	}
+}
+
+/*
+ * Must not be invoked with interrupt sources disabled and
+ * the hardware shutdown down.  Can sleep.
+ */
+static int tg3_alloc_consistent(struct tg3 *tp)
+{
+	tp->rx_std_buffers = kmalloc(sizeof(struct ring_info) *
+				     (TG3_RX_RING_SIZE +
+#if TG3_MINI_RING_WORKS
+				      TG3_RX_MINI_RING_SIZE +
+#endif
+				      TG3_RX_JUMBO_RING_SIZE +
+				      TG3_TX_RING_SIZE),
+				     GFP_KERNEL);
+	if (!tp->rx_std_buffers)
+		return -ENOMEM;
+
+#if TG3_MINI_RING_WORKS
+	memset(tp->rx_std_buffers, 0,
+	       (sizeof(struct ring_info) *
+		(TG3_RX_RING_SIZE +
+		 TG3_RX_MINI_RING_SIZE +
+		 TG3_RX_JUMBO_RING_SIZE +
+		 TG3_TX_RING_SIZE)));
+#else
+	memset(tp->rx_std_buffers, 0,
+	       (sizeof(struct ring_info) *
+		(TG3_RX_RING_SIZE +
+		 TG3_RX_JUMBO_RING_SIZE +
+		 TG3_TX_RING_SIZE)));
+#endif
+
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini_buffers = &tp->rx_std_buffers[TG3_RX_RING_SIZE];
+	tp->rx_jumbo_buffers = &tp->rx_mini_buffers[TG3_RX_MINI_RING_SIZE];
+#else
+	tp->rx_jumbo_buffers = &tp->rx_std_buffers[TG3_RX_RING_SIZE];
+#endif
+	tp->tx_buffers = &tp->rx_jumbo_buffers[TG3_RX_JUMBO_RING_SIZE];
+
+	tp->rx_std = pci_alloc_consistent(tp->pdev, TG3_RX_RING_BYTES,
+					  &tp->rx_std_mapping);
+	if (!tp->rx_std)
+		goto err_out;
+
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini = pci_alloc_consistent(tp->pdev, TG3_RX_MINI_RING_BYTES,
+					   &tp->rx_mini_mapping);
+
+	if (!tp->rx_mini)
+		goto err_out;
+#endif
+
+	tp->rx_jumbo = pci_alloc_consistent(tp->pdev, TG3_RX_JUMBO_RING_BYTES,
+					    &tp->rx_jumbo_mapping);
+
+	if (!tp->rx_jumbo)
+		goto err_out;
+
+	tp->rx_rcb = pci_alloc_consistent(tp->pdev, TG3_RX_RCB_RING_BYTES,
+					  &tp->rx_rcb_mapping);
+	if (!tp->rx_rcb)
+		goto err_out;
+
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tp->tx_ring = pci_alloc_consistent(tp->pdev, TG3_TX_RING_BYTES,
+						   &tp->tx_desc_mapping);
+		if (!tp->tx_ring)
+			goto err_out;
+	} else {
+		tp->tx_ring = NULL;
+		tp->tx_desc_mapping = 0;
+	}
+
+	tp->hw_status = pci_alloc_consistent(tp->pdev,
+					     TG3_HW_STATUS_SIZE,
+					     &tp->status_mapping);
+	if (!tp->hw_status)
+		goto err_out;
+
+	tp->hw_stats = pci_alloc_consistent(tp->pdev,
+					    sizeof(struct tg3_hw_stats),
+					    &tp->stats_mapping);
+	if (!tp->hw_stats)
+		goto err_out;
+
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+	memset(tp->hw_stats, 0, sizeof(struct tg3_hw_stats));
+
+	return 0;
+
+err_out:
+	tg3_free_consistent(tp);
+	return -ENOMEM;
+}
+
+#define MAX_WAIT_CNT 10000
+
+/* To stop a block, clear the enable bit and poll till it
+ * clears.  tp->lock is held.
+ */
+static int tg3_stop_block(struct tg3 *tp, unsigned long ofs, u32 enable_bit)
+{
+	unsigned int i;
+	u32 val;
+
+	val = tr32(ofs);
+	val &= ~enable_bit;
+	tw32(ofs, val);
+
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		val = tr32(ofs);
+
+		if ((val & enable_bit) == 0)
+			break;
+		udelay(100);
+	}
+
+	if (i == MAX_WAIT_CNT) {
+		printk(KERN_ERR PFX "tg3_stop_block timed out, "
+		       "ofs=%lx enable_bit=%x\n",
+		       ofs, enable_bit);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static int tg3_abort_hw(struct tg3 *tp)
+{
+	int i, err;
+
+	tg3_disable_ints(tp);
+
+	tp->rx_mode &= ~RX_MODE_ENABLE;
+	tw32(MAC_RX_MODE, tp->rx_mode);
+
+	err  = tg3_stop_block(tp, RCVBDI_MODE, RCVBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLPC_MODE, RCVLPC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLSC_MODE, RCVLSC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDBDI_MODE, RCVDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDCC_MODE, RCVDCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVCC_MODE, RCVCC_MODE_ENABLE);
+
+	err |= tg3_stop_block(tp, SNDBDS_MODE, SNDBDS_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDI_MODE, SNDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RDMAC_MODE, RDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDC_MODE, SNDBDC_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	tp->mac_mode &= ~MAC_MODE_TDE_ENABLE;
+	tw32(MAC_MODE, tp->mac_mode);
+
+	tp->tx_mode &= ~TX_MODE_ENABLE;
+	tw32(MAC_TX_MODE, tp->tx_mode);
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		udelay(100);
+		if (!(tr32(MAC_TX_MODE) & TX_MODE_ENABLE))
+			break;
+	}
+	if (i >= MAX_WAIT_CNT) {
+		printk(KERN_ERR PFX "tg3_abort_hw timed out for %s, "
+		       "TX_MODE_ENABLE will not clear MAC_TX_MODE=%08x\n",
+		       tp->dev->name, tr32(MAC_TX_MODE));
+		return -ENODEV;
+	}
+
+	err  = tg3_stop_block(tp, HOSTCC_MODE, HOSTCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, WDMAC_MODE, WDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MBFREE_MODE, MBFREE_MODE_ENABLE);
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+
+	err |= tg3_stop_block(tp, BUFMGR_MODE, BUFMGR_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MEMARB_MODE, MEMARB_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+
+out:
+	return err;
+}
+
+/* tp->lock is held. */
+static void tg3_chip_reset(struct tg3 *tp)
+{
+	u32 val;
+
+	/* Force NVRAM to settle.
+	 * This deals with a chip bug which can result in EEPROM
+	 * corruption.
+	 */
+	if (tp->tg3_flags & TG3_FLAG_NVRAM) {
+		int i;
+
+		tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+		for (i = 0; i < 100000; i++) {
+			if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+				break;
+			udelay(10);
+		}
+	}
+
+	tw32(GRC_MISC_CFG, GRC_MISC_CFG_CORECLK_RESET);
+	udelay(40);
+	udelay(40);
+	udelay(40);
+
+	/* Re-enable indirect register accesses. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	/* Set MAX PCI retry to zero. */
+	pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE,
+			       (PCISTATE_ROM_ENABLE |
+				PCISTATE_ROM_RETRY_ENABLE));
+
+	pci_restore_state(tp->pdev, tp->pci_cfg_state);
+
+	/* Make sure PCI-X relaxed ordering bit is clear. */
+	pci_read_config_dword(tp->pdev, TG3PCI_X_CAPS, &val);
+	val &= ~PCIX_CAPS_RELAXED_ORDERING;
+	pci_write_config_dword(tp->pdev, TG3PCI_X_CAPS, val);
+
+	tw32(MEMARB_MODE, MEMARB_MODE_ENABLE);
+
+	tw32(TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+}
+
+/* tp->lock is held. */
+static int tg3_halt(struct tg3 *tp)
+{
+	u32 val;
+	int i;
+
+	tg3_abort_hw(tp);
+	tg3_chip_reset(tp);
+	tg3_write_mem(tp,
+		      NIC_SRAM_FIRMWARE_MBOX,
+		      NIC_SRAM_FIRMWARE_MBOX_MAGIC1);
+	for (i = 0; i < 100000; i++) {
+		tg3_read_mem(tp, NIC_SRAM_FIRMWARE_MBOX, &val);
+		if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+			break;
+		udelay(10);
+	}
+
+	if (i >= 100000) {
+		printk(KERN_ERR PFX "tg3_halt timed out for %s, "
+		       "firmware will not restart magic=%08x\n",
+		       tp->dev->name, val);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+#define TG3_FW_RELEASE_MAJOR	0x0
+#define TG3_FW_RELASE_MINOR	0x0
+#define TG3_FW_RELEASE_FIX	0x0
+#define TG3_FW_START_ADDR	0x08000000
+#define TG3_FW_TEXT_ADDR	0x08000000
+#define TG3_FW_TEXT_LEN		0x9c0
+#define TG3_FW_RODATA_ADDR	0x080009c0
+#define TG3_FW_RODATA_LEN	0x60
+#define TG3_FW_DATA_ADDR	0x08000a40
+#define TG3_FW_DATA_LEN		0x20
+#define TG3_FW_SBSS_ADDR	0x08000a60
+#define TG3_FW_SBSS_LEN		0xc
+#define TG3_FW_BSS_ADDR		0x08000a70
+#define TG3_FW_BSS_LEN		0x10
+
+static u32 t3FwText[(TG3_FW_TEXT_LEN / sizeof(u32)) + 1] = {
+	0x00000000, 0x10000003, 0x00000000, 0x0000000d, 0x0000000d, 0x3c1d0800,
+	0x37bd3ffc, 0x03a0f021, 0x3c100800, 0x26100000, 0x0e000018, 0x00000000,
+	0x0000000d, 0x3c1d0800, 0x37bd3ffc, 0x03a0f021, 0x3c100800, 0x26100034,
+	0x0e00021c, 0x00000000, 0x0000000d, 0x00000000, 0x00000000, 0x00000000,
+	0x27bdffe0, 0x3c1cc000, 0xafbf0018, 0xaf80680c, 0x0e00004c, 0x241b2105,
+	0x97850000, 0x97870002, 0x9782002c, 0x9783002e, 0x3c040800, 0x248409c0,
+	0xafa00014, 0x00021400, 0x00621825, 0x00052c00, 0xafa30010, 0x8f860010,
+	0x00e52825, 0x0e000060, 0x24070102, 0x3c02ac00, 0x34420100, 0x3c03ac01,
+	0x34630100, 0xaf820490, 0x3c02ffff, 0xaf820494, 0xaf830498, 0xaf82049c,
+	0x24020001, 0xaf825ce0, 0x0e00003f, 0xaf825d00, 0x0e000140, 0x00000000,
+	0x8fbf0018, 0x03e00008, 0x27bd0020, 0x2402ffff, 0xaf825404, 0x8f835400,
+	0x34630400, 0xaf835400, 0xaf825404, 0x3c020800, 0x24420034, 0xaf82541c,
+	0x03e00008, 0xaf805400, 0x00000000, 0x00000000, 0x3c020800, 0x34423000,
+	0x3c030800, 0x34633000, 0x3c040800, 0x348437ff, 0x3c010800, 0xac220a64,
+	0x24020040, 0x3c010800, 0xac220a68, 0x3c010800, 0xac200a60, 0xac600000,
+	0x24630004, 0x0083102b, 0x5040fffd, 0xac600000, 0x03e00008, 0x00000000,
+	0x00804821, 0x8faa0010, 0x3c020800, 0x8c420a60, 0x3c040800, 0x8c840a68,
+	0x8fab0014, 0x24430001, 0x0044102b, 0x3c010800, 0xac230a60, 0x14400003,
+	0x00004021, 0x3c010800, 0xac200a60, 0x3c020800, 0x8c420a60, 0x3c030800,
+	0x8c630a64, 0x91240000, 0x00021140, 0x00431021, 0x00481021, 0x25080001,
+	0xa0440000, 0x29020008, 0x1440fff4, 0x25290001, 0x3c020800, 0x8c420a60,
+	0x3c030800, 0x8c630a64, 0x8f84680c, 0x00021140, 0x00431021, 0xac440008,
+	0xac45000c, 0xac460010, 0xac470014, 0xac4a0018, 0x03e00008, 0xac4b001c,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0,
+	0x02000008, 0x00000000, 0x0a0001e3, 0x3c0a0001, 0x0a0001e3, 0x3c0a0002,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x3c0a0007, 0x0a0001e3, 0x3c0a0008, 0x0a0001e3, 0x3c0a0009,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x3c0a000b,
+	0x0a0001e3, 0x3c0a000c, 0x0a0001e3, 0x3c0a000d, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x3c0a000e, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x3c0a0013, 0x0a0001e3, 0x3c0a0014,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0x27bdffe0, 0x00001821, 0x00001021, 0xafbf0018, 0xafb10014, 0xafb00010,
+	0x3c010800, 0x00220821, 0xac200a70, 0x3c010800, 0x00220821, 0xac200a74,
+	0x3c010800, 0x00220821, 0xac200a78, 0x24630001, 0x1860fff5, 0x2442000c,
+	0x24110001, 0x8f906810, 0x32020004, 0x14400005, 0x24040001, 0x3c020800,
+	0x8c420a78, 0x18400003, 0x00002021, 0x0e000182, 0x00000000, 0x32020001,
+	0x10400003, 0x00000000, 0x0e000169, 0x00000000, 0x0a000153, 0xaf915028,
+	0x8fbf0018, 0x8fb10014, 0x8fb00010, 0x03e00008, 0x27bd0020, 0x3c050800,
+	0x8ca50a70, 0x3c060800, 0x8cc60a80, 0x3c070800, 0x8ce70a78, 0x27bdffe0,
+	0x3c040800, 0x248409d0, 0xafbf0018, 0xafa00010, 0x0e000060, 0xafa00014,
+	0x0e00017b, 0x00002021, 0x8fbf0018, 0x03e00008, 0x27bd0020, 0x24020001,
+	0x8f836810, 0x00821004, 0x00021027, 0x00621824, 0x03e00008, 0xaf836810,
+	0x27bdffd8, 0xafbf0024, 0x1080002e, 0xafb00020, 0x8f825cec, 0xafa20018,
+	0x8f825cec, 0x3c100800, 0x26100a78, 0xafa2001c, 0x34028000, 0xaf825cec,
+	0x8e020000, 0x18400016, 0x00000000, 0x3c020800, 0x94420a74, 0x8fa3001c,
+	0x000221c0, 0xac830004, 0x8fa2001c, 0x3c010800, 0x0e000201, 0xac220a74,
+	0x10400005, 0x00000000, 0x8e020000, 0x24420001, 0x0a0001df, 0xae020000,
+	0x3c020800, 0x8c420a70, 0x00021c02, 0x000321c0, 0x0a0001c5, 0xafa2001c,
+	0x0e000201, 0x00000000, 0x1040001f, 0x00000000, 0x8e020000, 0x8fa3001c,
+	0x24420001, 0x3c010800, 0xac230a70, 0x3c010800, 0xac230a74, 0x0a0001df,
+	0xae020000, 0x3c100800, 0x26100a78, 0x8e020000, 0x18400028, 0x00000000,
+	0x0e000201, 0x00000000, 0x14400024, 0x00000000, 0x8e020000, 0x3c030800,
+	0x8c630a70, 0x2442ffff, 0xafa3001c, 0x18400006, 0xae020000, 0x00031402,
+	0x000221c0, 0x8c820004, 0x3c010800, 0xac220a70, 0x97a2001e, 0x2442ff00,
+	0x2c420300, 0x1440000b, 0x24024000, 0x3c040800, 0x248409dc, 0xafa00010,
+	0xafa00014, 0x8fa6001c, 0x24050008, 0x0e000060, 0x00003821, 0x0a0001df,
+	0x00000000, 0xaf825cf8, 0x3c020800, 0x8c420a40, 0x8fa3001c, 0x24420001,
+	0xaf835cf8, 0x3c010800, 0xac220a40, 0x8fbf0024, 0x8fb00020, 0x03e00008,
+	0x27bd0028, 0x27bdffe0, 0x3c040800, 0x248409e8, 0x00002821, 0x00003021,
+	0x00003821, 0xafbf0018, 0xafa00010, 0x0e000060, 0xafa00014, 0x8fbf0018,
+	0x03e00008, 0x27bd0020, 0x8f82680c, 0x8f85680c, 0x00021827, 0x0003182b,
+	0x00031823, 0x00431024, 0x00441021, 0x00a2282b, 0x10a00006, 0x00000000,
+	0x00401821, 0x8f82680c, 0x0043102b, 0x1440fffd, 0x00000000, 0x03e00008,
+	0x00000000, 0x3c040800, 0x8c840000, 0x3c030800, 0x8c630a40, 0x0064102b,
+	0x54400002, 0x00831023, 0x00641023, 0x2c420008, 0x03e00008, 0x38420001,
+	0x27bdffe0, 0x00802821, 0x3c040800, 0x24840a00, 0x00003021, 0x00003821,
+	0xafbf0018, 0xafa00010, 0x0e000060, 0xafa00014, 0x0a000216, 0x00000000,
+	0x8fbf0018, 0x03e00008, 0x27bd0020, 0x00000000, 0x27bdffe0, 0x3c1cc000,
+	0xafbf0018, 0x0e00004c, 0xaf80680c, 0x3c040800, 0x24840a10, 0x03802821,
+	0x00003021, 0x00003821, 0xafa00010, 0x0e000060, 0xafa00014, 0x2402ffff,
+	0xaf825404, 0x3c0200aa, 0x0e000234, 0xaf825434, 0x8fbf0018, 0x03e00008,
+	0x27bd0020, 0x00000000, 0x00000000, 0x00000000, 0x27bdffe8, 0xafb00010,
+	0x24100001, 0xafbf0014, 0x3c01c003, 0xac200000, 0x8f826810, 0x30422000,
+	0x10400003, 0x00000000, 0x0e000246, 0x00000000, 0x0a00023a, 0xaf905428,
+	0x8fbf0014, 0x8fb00010, 0x03e00008, 0x27bd0018, 0x27bdfff8, 0x8f845d0c,
+	0x3c0200ff, 0x3c030800, 0x8c630a50, 0x3442fff8, 0x00821024, 0x1043001e,
+	0x3c0500ff, 0x34a5fff8, 0x3c06c003, 0x3c074000, 0x00851824, 0x8c620010,
+	0x3c010800, 0xac230a50, 0x30420008, 0x10400005, 0x00871025, 0x8cc20000,
+	0x24420001, 0xacc20000, 0x00871025, 0xaf825d0c, 0x8fa20000, 0x24420001,
+	0xafa20000, 0x8fa20000, 0x8fa20000, 0x24420001, 0xafa20000, 0x8fa20000,
+	0x8f845d0c, 0x3c030800, 0x8c630a50, 0x00851024, 0x1443ffe8, 0x00851824,
+	0x27bd0008, 0x03e00008, 0x00000000, 0x00000000, 0x00000000
+};
+
+static u32 t3FwRodata[(TG3_FW_RODATA_LEN / sizeof(u32)) + 1] = {
+	0x35373031, 0x726c7341, 0x00000000, 0x00000000, 0x53774576, 0x656e7430,
+	0x00000000, 0x726c7045, 0x76656e74, 0x31000000, 0x556e6b6e, 0x45766e74,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x66617461, 0x6c457272,
+	0x00000000, 0x00000000, 0x4d61696e, 0x43707542, 0x00000000, 0x00000000,
+	0x00000000
+};
+
+#if 0 /* All zeros, dont eat up space with it. */
+u32 t3FwData[(TG3_FW_DATA_LEN / sizeof(u32)) + 1] = {
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
+#endif
+
+#define RX_CPU_SCRATCH_BASE	0x30000
+#define RX_CPU_SCRATCH_SIZE	0x04000
+#define TX_CPU_SCRATCH_BASE	0x34000
+#define TX_CPU_SCRATCH_SIZE	0x04000
+
+/* tp->lock is held. */
+static int tg3_reset_cpu(struct tg3 *tp, u32 offset)
+{
+	int i;
+
+	tw32(offset + CPU_STATE, 0xffffffff);
+	tw32(offset + CPU_MODE,  CPU_MODE_RESET);
+	if (offset == RX_CPU_BASE) {
+		for (i = 0; i < 10000; i++)
+			if (!(tr32(offset + CPU_MODE) & CPU_MODE_RESET))
+				break;
+		tw32(offset + CPU_STATE, 0xffffffff);
+		tw32(offset + CPU_MODE,  CPU_MODE_RESET);
+		udelay(10);
+	} else {
+		for (i = 0; i < 10000; i++) {
+			if (!(tr32(offset + CPU_MODE) & CPU_MODE_RESET))
+				break;
+			tw32(offset + CPU_STATE, 0xffffffff);
+			tw32(offset + CPU_MODE,  CPU_MODE_RESET);
+			udelay(10);
+		}
+	}
+
+	if (i >= 10000) {
+		printk(KERN_ERR PFX "tg3_reset_cpu timed out for %s, "
+		       "and %s CPU\n",
+		       tp->dev->name,
+		       (offset == RX_CPU_BASE ? "RX" : "TX"));
+		return -ENODEV;
+	}
+	return 0;
+}
+
+/* tp->lock is held. */
+static int tg3_load_firmware_cpu(struct tg3 *tp, u32 cpu_base, u32 cpu_scratch_base,
+				 int cpu_scratch_size)
+{
+	int err, i;
+
+	err = tg3_reset_cpu(tp, cpu_base);
+	if (err)
+		return err;
+
+	for (i = 0; i < cpu_scratch_size; i += sizeof(u32))
+		tg3_write_indirect_reg32(tp, cpu_scratch_base + i, 0);
+	tw32(cpu_base + CPU_STATE, 0xffffffff);
+	tw32(cpu_base + CPU_MODE, tr32(cpu_base+CPU_MODE)|CPU_MODE_HALT);
+	for (i = 0; i < (TG3_FW_TEXT_LEN / sizeof(u32)); i++)
+		tg3_write_indirect_reg32(tp, (cpu_scratch_base +
+					      (TG3_FW_TEXT_ADDR & 0xffff) +
+					      (i * sizeof(u32))),
+					 t3FwText[i]);
+	for (i = 0; i < (TG3_FW_RODATA_LEN / sizeof(u32)); i++)
+		tg3_write_indirect_reg32(tp, (cpu_scratch_base +
+					      (TG3_FW_RODATA_ADDR & 0xffff) +
+					      (i * sizeof(u32))),
+					 t3FwRodata[i]);
+	for (i = 0; i < (TG3_FW_DATA_LEN / sizeof(u32)); i++)
+		tg3_write_indirect_reg32(tp, (cpu_scratch_base +
+					      (TG3_FW_DATA_ADDR & 0xffff) +
+					      (i * sizeof(u32))),
+					 0);
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static int tg3_load_5701_a0_firmware_fix(struct tg3 *tp)
+{
+	int err, i;
+
+	err = tg3_load_firmware_cpu(tp, RX_CPU_BASE,
+				    RX_CPU_SCRATCH_BASE, RX_CPU_SCRATCH_SIZE);
+	if (err)
+		return err;
+
+	err = tg3_load_firmware_cpu(tp, TX_CPU_BASE,
+				    TX_CPU_SCRATCH_BASE, TX_CPU_SCRATCH_SIZE);
+	if (err)
+		return err;
+
+	/* Now startup only the RX cpu. */
+	for (i = 0; i < 5; i++) {
+		tw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);
+		tw32(RX_CPU_BASE + CPU_MODE,  CPU_MODE_HALT);
+		tw32(RX_CPU_BASE + CPU_PC,    TG3_FW_TEXT_ADDR);
+		tr32(RX_CPU_BASE + CPU_PC);	/* flush writes -ggg */
+		udelay(1000);
+		if (tr32(RX_CPU_BASE + CPU_PC) == TG3_FW_TEXT_ADDR)
+			break;
+	}
+	if (i >= 5) {
+		printk(KERN_ERR PFX "tg3_load_firmware fails for %s "
+		       "to set RX CPU PC, is %08x should be %08x\n",
+		       tp->dev->name, tr32(RX_CPU_BASE + CPU_PC),
+		       TG3_FW_TEXT_ADDR);
+		return -ENODEV;
+	}
+	tw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);
+	tw32(RX_CPU_BASE + CPU_MODE,  0x00000000);
+	tr32(RX_CPU_BASE + CPU_MODE);	/* flush writes -ggg */
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static void __tg3_set_mac_addr(struct tg3 *tp)
+{
+	u32 addr_high, addr_low;
+	int i;
+
+	addr_high = ((tp->dev->dev_addr[0] << 8) |
+		     tp->dev->dev_addr[1]);
+	addr_low = ((tp->dev->dev_addr[2] << 24) |
+		    (tp->dev->dev_addr[3] << 16) |
+		    (tp->dev->dev_addr[4] <<  8) |
+		    (tp->dev->dev_addr[5] <<  0));
+	for (i = 0; i < 4; i++) {
+		tw32(MAC_ADDR_0_HIGH + (i * 8), addr_high);
+		tw32(MAC_ADDR_0_LOW + (i * 8), addr_low);
+	}
+
+	addr_high = (tp->dev->dev_addr[0] +
+		     tp->dev->dev_addr[1] +
+		     tp->dev->dev_addr[2] +
+		     tp->dev->dev_addr[3] +
+		     tp->dev->dev_addr[4] +
+		     tp->dev->dev_addr[5]) &
+		TX_BACKOFF_SEED_MASK;
+	tw32(MAC_TX_BACKOFF_SEED, addr_high);
+}
+
+static int tg3_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct tg3 *tp = dev->priv;
+	struct sockaddr *addr = p;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	spin_lock_irq(&tp->lock);
+	__tg3_set_mac_addr(tp);
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static void tg3_set_bdinfo(struct tg3 *tp, u32 bdinfo_addr,
+			   dma_addr_t mapping, u32 maxlen_flags,
+			   u32 nic_addr)
+{
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR +
+		       TG3_64BIT_REG_HIGH),
+		      ((u64) mapping >> 32));
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR +
+		       TG3_64BIT_REG_LOW),
+		      ((u64) mapping & 0xffffffff));
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_MAXLEN_FLAGS),
+		       maxlen_flags);
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_NIC_ADDR),
+		      nic_addr);
+}
+
+static void __tg3_set_rx_mode(struct net_device *);
+
+/* tp->lock is held. */
+static int tg3_reset_hw(struct tg3 *tp)
+{
+	u32 val;
+	int i, err;
+
+	tg3_disable_ints(tp);
+
+	if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) {
+		err = tg3_abort_hw(tp);
+		if (err)
+			return err;
+	}
+
+	tg3_chip_reset(tp);
+
+	tw32(GRC_MODE, tp->grc_mode);
+	tg3_write_mem(tp,
+		      NIC_SRAM_FIRMWARE_MBOX,
+		      NIC_SRAM_FIRMWARE_MBOX_MAGIC1);
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->mac_mode = MAC_MODE_PORT_MODE_TBI;
+		tw32(MAC_MODE, tp->mac_mode);
+	} else
+		tw32(MAC_MODE, 0);
+
+	/* Wait for firmware initialization to complete. */
+	for (i = 0; i < 100000; i++) {
+		tg3_read_mem(tp, NIC_SRAM_FIRMWARE_MBOX, &val);
+		if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+			break;
+		udelay(10);
+	}
+	if (i >= 100000) {
+		printk(KERN_ERR PFX "tg3_reset_hw timed out for %s, "
+		       "firmware will not restart magic=%08x\n",
+		       tp->dev->name, val);
+		return -ENODEV;
+	}
+
+	/* This works around an issue with Athlon chipsets on
+	 * B3 tigon3 silicon.  This bit has no effect on any
+	 * other revision.
+	 */
+	val = tr32(TG3PCI_CLOCK_CTRL);
+	val |= CLOCK_CTRL_DELAY_PCI_GRANT;
+	tw32(TG3PCI_CLOCK_CTRL, val);
+
+	/* Clear statistics/status block in chip, and status block in ram. */
+	for (i = NIC_SRAM_STATS_BLK;
+	     i < NIC_SRAM_STATUS_BLK + TG3_HW_STATUS_SIZE;
+	     i += sizeof(u32))
+		tg3_write_mem(tp, i, 0);
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+
+	/* This value is determined during the probe time DMA
+	 * engine test, tg3_test_dma.
+	 */
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	tp->grc_mode &= ~(GRC_MODE_HOST_SENDBDS |
+			  GRC_MODE_4X_NIC_SEND_RINGS |
+			  GRC_MODE_NO_TX_PHDR_CSUM |
+			  GRC_MODE_NO_RX_PHDR_CSUM);
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS)
+		tp->grc_mode |= GRC_MODE_HOST_SENDBDS;
+	else
+		tp->grc_mode |= GRC_MODE_4X_NIC_SEND_RINGS;
+	if (tp->tg3_flags & TG3_FLAG_NO_TX_PSEUDO_CSUM)
+		tp->grc_mode |= GRC_MODE_NO_TX_PHDR_CSUM;
+	if (tp->tg3_flags & TG3_FLAG_NO_RX_PSEUDO_CSUM)
+		tp->grc_mode |= GRC_MODE_NO_RX_PHDR_CSUM;
+
+	tw32(GRC_MODE,
+	     tp->grc_mode |
+	     (GRC_MODE_IRQ_ON_MAC_ATTN | GRC_MODE_HOST_STACKUP));
+
+	/* Setup the timer prescalar register.  Clock is always 66Mhz. */
+	tw32(GRC_MISC_CFG,
+	     (65 << GRC_MISC_CFG_PRESCALAR_SHIFT));
+
+	/* Initialize MBUF/DESC pool. */
+	tw32(BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE);
+	tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE);
+	tw32(BUFMGR_DMA_DESC_POOL_ADDR, NIC_SRAM_DMA_DESC_POOL_BASE);
+	tw32(BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE);
+
+	if (!(tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE)) {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water);
+	} else {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water_jumbo);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water_jumbo);
+	}
+	tw32(BUFMGR_DMA_LOW_WATER,
+	     tp->bufmgr_config.dma_low_water);
+	tw32(BUFMGR_DMA_HIGH_WATER,
+	     tp->bufmgr_config.dma_high_water);
+
+	tw32(BUFMGR_MODE, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(BUFMGR_MODE) & BUFMGR_MODE_ENABLE)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printk(KERN_ERR PFX "tg3_reset_hw cannot enable BUFMGR for %s.\n",
+		       tp->dev->name);
+		return -ENODEV;
+	}
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(FTQ_RESET) == 0x00000000)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printk(KERN_ERR PFX "tg3_reset_hw cannot reset FTQ for %s.\n",
+		       tp->dev->name);
+		return -ENODEV;
+	}
+
+	/* Initialize TG3_BDINFO's at:
+	 *  RCVDBDI_STD_BD:	standard eth size rx ring
+	 *  RCVDBDI_JUMBO_BD:	jumbo frame rx ring
+	 *  RCVDBDI_MINI_BD:	small frame rx ring (??? does not work)
+	 *
+	 * like so:
+	 *  TG3_BDINFO_HOST_ADDR:	high/low parts of DMA address of ring
+	 *  TG3_BDINFO_MAXLEN_FLAGS:	(rx max buffer size << 16) |
+	 *                              ring attribute flags
+	 *  TG3_BDINFO_NIC_ADDR:	location of descriptors in nic SRAM
+	 *
+	 * Standard receive ring @ NIC_SRAM_RX_BUFFER_DESC, 512 entries.
+	 * Jumbo receive ring @ NIC_SRAM_RX_JUMBO_BUFFER_DESC, 256 entries.
+	 *
+	 * ??? No space allocated for mini receive ring? :(
+	 *
+	 * The size of each ring is fixed in the firmware, but the location is
+	 * configurable.
+	 */
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->rx_std_mapping >> 32));
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->rx_std_mapping & 0xffffffff));
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS,
+	     RX_STD_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT);
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_NIC_ADDR,
+	     NIC_SRAM_RX_BUFFER_DESC);
+
+#if TG3_MINI_RING_WORKS
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->rx_mini_mapping >> 32));
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->rx_mini_mapping & 0xffffffff));
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,
+	     RX_MINI_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT);
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_NIC_ADDR,
+	     NIC_SRAM_RX_MINI_BUFFER_DESC);
+#else
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,
+	     BDINFO_FLAGS_DISABLED);
+#endif
+
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE) {
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,
+		     ((u64) tp->rx_jumbo_mapping >> 32));
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,
+		     ((u64) tp->rx_jumbo_mapping & 0xffffffff));
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,
+		     RX_JUMBO_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT);
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_NIC_ADDR,
+		     NIC_SRAM_RX_JUMBO_BUFFER_DESC);
+	} else {
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,
+		     BDINFO_FLAGS_DISABLED);
+	}
+
+	/* Setup replenish thresholds. */
+	tw32(RCVBDI_STD_THRESH, tp->rx_pending / 8);
+#if TG3_MINI_RING_WORKS
+	tw32(RCVBDI_MINI_THRESH, tp->rx_mini_pending / 8);
+#endif
+	tw32(RCVBDI_JUMBO_THRESH, tp->rx_jumbo_pending / 8);
+
+	/* Clear out send RCB ring in SRAM. */
+	for (i = NIC_SRAM_SEND_RCB; i < NIC_SRAM_RCV_RET_RCB; i += TG3_BDINFO_SIZE)
+		tg3_write_mem(tp, i + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED);
+
+	tp->tx_prod = 0;
+	tp->tx_cons = 0;
+	tw32_mailbox(MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+	tw32_mailbox(MAILBOX_SNDNIC_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tg3_set_bdinfo(tp, NIC_SRAM_SEND_RCB,
+			       tp->tx_desc_mapping,
+			       (TG3_TX_RING_SIZE <<
+				BDINFO_FLAGS_MAXLEN_SHIFT),
+			       NIC_SRAM_TX_BUFFER_DESC);
+	} else {
+		tg3_set_bdinfo(tp, NIC_SRAM_SEND_RCB,
+			       0,
+			       BDINFO_FLAGS_DISABLED,
+			       NIC_SRAM_TX_BUFFER_DESC);
+	}
+
+	for (i = NIC_SRAM_RCV_RET_RCB; i < NIC_SRAM_STATS_BLK; i += TG3_BDINFO_SIZE) {
+		tg3_write_mem(tp, i + TG3_BDINFO_MAXLEN_FLAGS,
+			      BDINFO_FLAGS_DISABLED);
+	}
+
+	tp->rx_rcb_ptr = 0;
+	tw32_mailbox(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	tg3_set_bdinfo(tp, NIC_SRAM_RCV_RET_RCB,
+		       tp->rx_rcb_mapping,
+		       (TG3_RX_RCB_RING_SIZE <<
+			BDINFO_FLAGS_MAXLEN_SHIFT),
+		       0);
+
+	tp->rx_std_ptr = tp->rx_pending;
+	tw32_mailbox(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_std_ptr);
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini_ptr = tp->rx_mini_pending;
+	tw32_mailbox(MAILBOX_RCV_MINI_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_mini_ptr);
+#endif
+
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE)
+		tp->rx_jumbo_ptr = tp->rx_jumbo_pending;
+	else
+		tp->rx_jumbo_ptr = 0;
+	tw32_mailbox(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_jumbo_ptr);
+
+	/* Initialize MAC address and backoff seed. */
+	__tg3_set_mac_addr(tp);
+
+	/* MTU + ethernet header + FCS + optional VLAN tag */
+	tw32(MAC_RX_MTU_SIZE, tp->dev->mtu + ETH_HLEN + 8);
+
+	/* The slot time is changed by tg3_setup_phy if we
+	 * run at gigabit with half duplex.
+	 */
+	tw32(MAC_TX_LENGTHS,
+	     (2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+	     (6 << TX_LENGTHS_IPG_SHIFT) |
+	     (32 << TX_LENGTHS_SLOT_TIME_SHIFT));
+
+	/* Receive rules. */
+	tw32(MAC_RCV_RULE_CFG, RCV_RULE_CFG_DEFAULT_CLASS);
+	tw32(RCVLPC_CONFIG, 0x0181);
+
+	/* Receive/send statistics. */
+	tw32(RCVLPC_STATS_ENABLE, 0xffffff);
+	tw32(RCVLPC_STATSCTRL, RCVLPC_STATSCTRL_ENABLE);
+	tw32(SNDDATAI_STATSENAB, 0xffffff);
+	tw32(SNDDATAI_STATSCTRL,
+	     (SNDDATAI_SCTRL_ENABLE |
+	      SNDDATAI_SCTRL_FASTUPD));
+
+	/* Setup host coalescing engine. */
+	tw32(HOSTCC_MODE, 0);
+	for (i = 0; i < 2000; i++) {
+		if (!(tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE))
+			break;
+		udelay(10);
+	}
+
+	tw32(HOSTCC_RXCOL_TICKS,
+	     tp->coalesce_config.rx_coalesce_ticks);
+	tw32(HOSTCC_RXMAX_FRAMES,
+	     tp->coalesce_config.rx_max_coalesced_frames);
+	tw32(HOSTCC_RXCOAL_TICK_INT,
+	     tp->coalesce_config.rx_coalesce_ticks_during_int);
+	tw32(HOSTCC_RXCOAL_MAXF_INT,
+	     tp->coalesce_config.rx_max_coalesced_frames_during_int);
+	tw32(HOSTCC_TXCOL_TICKS,
+	     tp->coalesce_config.tx_coalesce_ticks);
+	tw32(HOSTCC_TXMAX_FRAMES,
+	     tp->coalesce_config.tx_max_coalesced_frames);
+	tw32(HOSTCC_TXCOAL_TICK_INT,
+	     tp->coalesce_config.tx_coalesce_ticks_during_int);
+	tw32(HOSTCC_TXCOAL_MAXF_INT,
+	     tp->coalesce_config.tx_max_coalesced_frames_during_int);
+	tw32(HOSTCC_STAT_COAL_TICKS,
+	     tp->coalesce_config.stats_coalesce_ticks);
+
+	/* Status/statistics block address. */
+	tw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->stats_mapping >> 32));
+	tw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->stats_mapping & 0xffffffff));
+	tw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->status_mapping >> 32));
+	tw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->status_mapping & 0xffffffff));
+	tw32(HOSTCC_STATS_BLK_NIC_ADDR, NIC_SRAM_STATS_BLK);
+	tw32(HOSTCC_STATUS_BLK_NIC_ADDR, NIC_SRAM_STATUS_BLK);
+
+	tw32(HOSTCC_MODE, HOSTCC_MODE_ENABLE | tp->coalesce_mode);
+
+	tw32(RCVCC_MODE, RCVCC_MODE_ENABLE | RCVCC_MODE_ATTN_ENABLE);
+	tw32(RCVLPC_MODE, RCVLPC_MODE_ENABLE);
+	tw32(RCVLSC_MODE, RCVLSC_MODE_ENABLE | RCVLSC_MODE_ATTN_ENABLE);
+
+	tp->mac_mode = MAC_MODE_TXSTAT_ENABLE | MAC_MODE_RXSTAT_ENABLE |
+		MAC_MODE_TDE_ENABLE | MAC_MODE_RDE_ENABLE | MAC_MODE_FHDE_ENABLE;
+	tw32(MAC_MODE, tp->mac_mode | MAC_MODE_RXSTAT_CLEAR | MAC_MODE_TXSTAT_CLEAR);
+
+	tp->grc_local_ctrl = GRC_LCLCTRL_INT_ON_ATTN | GRC_LCLCTRL_GPIO_OE1 |
+		GRC_LCLCTRL_GPIO_OUTPUT1 | GRC_LCLCTRL_AUTO_SEEPROM;
+	tw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0);
+
+	tw32(DMAC_MODE, DMAC_MODE_ENABLE);
+
+	tw32(WDMAC_MODE, (WDMAC_MODE_ENABLE | WDMAC_MODE_TGTABORT_ENAB |
+			  WDMAC_MODE_MSTABORT_ENAB | WDMAC_MODE_PARITYERR_ENAB |
+			  WDMAC_MODE_ADDROFLOW_ENAB | WDMAC_MODE_FIFOOFLOW_ENAB |
+			  WDMAC_MODE_FIFOURUN_ENAB | WDMAC_MODE_FIFOOREAD_ENAB |
+			  WDMAC_MODE_LNGREAD_ENAB));
+	tw32(RDMAC_MODE, (RDMAC_MODE_ENABLE | RDMAC_MODE_TGTABORT_ENAB |
+			  RDMAC_MODE_MSTABORT_ENAB | RDMAC_MODE_PARITYERR_ENAB |
+			  RDMAC_MODE_ADDROFLOW_ENAB | RDMAC_MODE_FIFOOFLOW_ENAB |
+			  RDMAC_MODE_FIFOURUN_ENAB | RDMAC_MODE_FIFOOREAD_ENAB |
+			  RDMAC_MODE_LNGREAD_ENAB));
+
+	tw32(RCVDCC_MODE, RCVDCC_MODE_ENABLE | RCVDCC_MODE_ATTN_ENABLE);
+	tw32(MBFREE_MODE, MBFREE_MODE_ENABLE);
+	tw32(SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);
+	tw32(SNDBDC_MODE, SNDBDC_MODE_ENABLE | SNDBDC_MODE_ATTN_ENABLE);
+	tw32(RCVBDI_MODE, RCVBDI_MODE_ENABLE | RCVBDI_MODE_RCB_ATTN_ENAB);
+	tw32(RCVDBDI_MODE, RCVDBDI_MODE_ENABLE | RCVDBDI_MODE_INV_RING_SZ);
+	tw32(SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);
+	tw32(SNDBDI_MODE, SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE);
+	tw32(SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0) {
+		err = tg3_load_5701_a0_firmware_fix(tp);
+		if (err)
+			return err;
+	}
+
+	tp->tx_mode = TX_MODE_ENABLE;
+	tw32(MAC_TX_MODE, tp->tx_mode);
+	tp->rx_mode = RX_MODE_ENABLE;
+	tw32(MAC_RX_MODE, tp->rx_mode);
+
+	if (tp->link_config.phy_is_low_power) {
+		tp->link_config.phy_is_low_power = 0;
+		tp->link_config.speed = tp->link_config.orig_speed;
+		tp->link_config.duplex = tp->link_config.orig_duplex;
+		tp->link_config.autoneg = tp->link_config.orig_autoneg;
+	}
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32(MAC_MI_MODE, tp->mi_mode);
+	tw32(MAC_LED_CTRL, 0);
+	tw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);
+	tw32(MAC_RX_MODE, RX_MODE_RESET);
+	udelay(10);
+	tw32(MAC_RX_MODE, tp->rx_mode);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5703_A1)
+		tw32(MAC_SERDES_CFG, 0x616000);
+
+	err = tg3_setup_phy(tp);
+	if (err)
+		return err;
+
+	if (tp->phy_id != PHY_ID_SERDES) {
+		u32 tmp;
+
+		/* Clear CRC stats. */
+		tg3_readphy(tp, 0x1e, &tmp);
+		tg3_writephy(tp, 0x1e, tmp | 0x8000);
+		tg3_readphy(tp, 0x14, &tmp);
+	}
+
+	__tg3_set_rx_mode(tp->dev);
+
+	/* Initialize receive rules. */
+	tw32(MAC_RCV_RULE_0,  0xc2000000 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_0, 0xffffffff & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_RULE_1,  0x86000004 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_1, 0xffffffff & RCV_RULE_DISABLE_MASK);
+#if 0
+	tw32(MAC_RCV_RULE_2,  0); tw32(MAC_RCV_VALUE_2,  0);
+	tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0);
+#endif
+	tw32(MAC_RCV_RULE_4,  0); tw32(MAC_RCV_VALUE_4,  0);
+	tw32(MAC_RCV_RULE_5,  0); tw32(MAC_RCV_VALUE_5,  0);
+	tw32(MAC_RCV_RULE_6,  0); tw32(MAC_RCV_VALUE_6,  0);
+	tw32(MAC_RCV_RULE_7,  0); tw32(MAC_RCV_VALUE_7,  0);
+	tw32(MAC_RCV_RULE_8,  0); tw32(MAC_RCV_VALUE_8,  0);
+	tw32(MAC_RCV_RULE_9,  0); tw32(MAC_RCV_VALUE_9,  0);
+	tw32(MAC_RCV_RULE_10,  0); tw32(MAC_RCV_VALUE_10,  0);
+	tw32(MAC_RCV_RULE_11,  0); tw32(MAC_RCV_VALUE_11,  0);
+	tw32(MAC_RCV_RULE_12,  0); tw32(MAC_RCV_VALUE_12,  0);
+	tw32(MAC_RCV_RULE_13,  0); tw32(MAC_RCV_VALUE_13,  0);
+	tw32(MAC_RCV_RULE_14,  0); tw32(MAC_RCV_VALUE_14,  0);
+	tw32(MAC_RCV_RULE_15,  0); tw32(MAC_RCV_VALUE_15,  0);
+
+	if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE)
+		tg3_enable_ints(tp);
+
+	return 0;
+}
+
+/* Called at device open time to get the chip ready for
+ * packet processing.  Invoked with tp->lock held.
+ */
+static int tg3_init_hw(struct tg3 *tp)
+{
+	int err;
+
+	/* Force the chip into D0. */
+	err = tg3_set_power_state(tp, 0);
+	if (err)
+		goto out;
+
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	err = tg3_reset_hw(tp);
+
+out:
+	return err;
+}
+
+static void tg3_timer(unsigned long __opaque)
+{
+	struct tg3 *tp = (struct tg3 *) __opaque;
+
+	spin_lock_irq(&tp->lock);
+
+	if (!(tp->tg3_flags & TG3_FLAG_TAGGED_IRQ_STATUS)) {
+		/* All of this garbage is because on the 5700 the
+		 * mailbox/status_block protocol the chip uses with
+		 * the cpu is race prone.
+		 */
+		if (tp->hw_status->status & SD_STATUS_UPDATED) {
+			tw32(GRC_LOCAL_CTRL,
+			     tp->grc_local_ctrl | GRC_LCLCTRL_SETINT);
+		} else {
+			tw32(HOSTCC_MODE,
+			     (HOSTCC_MODE_ENABLE | HOSTCC_MODE_NOW));
+		}
+
+		if (!(tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {
+			tg3_halt(tp);
+			tg3_init_rings(tp);
+			tg3_init_hw(tp);
+		}
+	}
+
+	/* This part only runs once per second. */
+	if (!--tp->timer_counter) {
+		if (tp->tg3_flags & TG3_FLAG_USE_LINKCHG_REG) {
+			u32 mac_stat;
+			int phy_event;
+
+			mac_stat = tr32(MAC_STATUS);
+
+			phy_event = 0;
+			if (tp->tg3_flags & TG3_FLAG_USE_MI_INTERRUPT) {
+				if (mac_stat & MAC_STATUS_MI_INTERRUPT)
+					phy_event = 1;
+			} else if (mac_stat & MAC_STATUS_LNKSTATE_CHANGED)
+				phy_event = 1;
+
+			if (phy_event)
+				tg3_setup_phy(tp);
+		}
+
+		tp->timer_counter = tp->timer_multiplier;
+	}
+
+	spin_unlock_irq(&tp->lock);
+
+	tp->timer.expires = jiffies + tp->timer_offset;
+	add_timer(&tp->timer);
+}
+
+static int tg3_open(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_disable_ints(tp);
+	tp->tg3_flags &= ~TG3_FLAG_INIT_COMPLETE;
+
+	spin_unlock_irq(&tp->lock);
+
+	/* If you move this call, make sure TG3_FLAG_HOST_TXDS in
+	 * tp->tg3_flags is accurate at that new place.
+	 */
+	err = tg3_alloc_consistent(tp);
+	if (err)
+		return err;
+
+	if (tp->tg3_flags & TG3_FLAG_TAGGED_IRQ_STATUS)
+		err = request_irq(dev->irq, tg3_interrupt_tagged,
+				  SA_SHIRQ, dev->name, dev);
+	else
+		err = request_irq(dev->irq, tg3_interrupt,
+				  SA_SHIRQ, dev->name, dev);
+
+	if (err) {
+		tg3_free_consistent(tp);
+		return err;
+	}
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_init_rings(tp);
+
+	err = tg3_init_hw(tp);
+	if (err) {
+		tg3_halt(tp);
+		tg3_free_rings(tp);
+	} else {
+		if (tp->tg3_flags & TG3_FLAG_TAGGED_IRQ_STATUS) {
+			tp->timer_offset = HZ;
+			tp->timer_counter = tp->timer_multiplier = 1;
+		} else {
+			tp->timer_offset = HZ / 10;
+			tp->timer_counter = tp->timer_multiplier = 10;
+		}
+
+		init_timer(&tp->timer);
+		tp->timer.expires = jiffies + tp->timer_offset;
+		tp->timer.data = (unsigned long) tp;
+		tp->timer.function = tg3_timer;
+		add_timer(&tp->timer);
+
+		tp->last_rate_sample = jiffies;
+		tp->last_rx_count = 0;
+		tp->last_tx_count = 0;
+
+		tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
+	}
+
+	spin_unlock_irq(&tp->lock);
+
+	if (err) {
+		free_irq(dev->irq, dev);
+		tg3_free_consistent(tp);
+		return err;
+	}
+
+	netif_start_queue(dev);
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_enable_ints(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+#if 0
+/*static*/ void tg3_dump_state(struct tg3 *tp)
+{
+	u32 val32, val32_2, val32_3, val32_4, val32_5;
+	u16 val16;
+	int i;
+
+	pci_read_config_word(tp->pdev, PCI_STATUS, &val16);
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE, &val32);
+	printk("DEBUG: PCI status [%04x] TG3PCI state[%08x]\n",
+	       val16, val32);
+
+	/* MAC block */
+	printk("DEBUG: MAC_MODE[%08x] MAC_STATUS[%08x]\n",
+	       tr32(MAC_MODE), tr32(MAC_STATUS));
+	printk("       MAC_EVENT[%08x] MAC_LED_CTRL[%08x]\n",
+	       tr32(MAC_EVENT), tr32(MAC_LED_CTRL));
+	printk("DEBUG: MAC_TX_MODE[%08x] MAC_TX_STATUS[%08x]\n",
+	       tr32(MAC_TX_MODE), tr32(MAC_TX_STATUS));
+	printk("       MAC_RX_MODE[%08x] MAC_RX_STATUS[%08x]\n",
+	       tr32(MAC_RX_MODE), tr32(MAC_RX_STATUS));
+
+	/* Send data initiator control block */
+	printk("DEBUG: SNDDATAI_MODE[%08x] SNDDATAI_STATUS[%08x]\n",
+	       tr32(SNDDATAI_MODE), tr32(SNDDATAI_STATUS));
+	printk("       SNDDATAI_STATSCTRL[%08x]\n",
+	       tr32(SNDDATAI_STATSCTRL));
+
+	/* Send data completion control block */
+	printk("DEBUG: SNDDATAC_MODE[%08x]\n", tr32(SNDDATAC_MODE));
+
+	/* Send BD ring selector block */
+	printk("DEBUG: SNDBDS_MODE[%08x] SNDBDS_STATUS[%08x]\n",
+	       tr32(SNDBDS_MODE), tr32(SNDBDS_STATUS));
+
+	/* Send BD initiator control block */
+	printk("DEBUG: SNDBDI_MODE[%08x] SNDBDI_STATUS[%08x]\n",
+	       tr32(SNDBDI_MODE), tr32(SNDBDI_STATUS));
+
+	/* Send BD completion control block */
+	printk("DEBUG: SNDBDC_MODE[%08x]\n", tr32(SNDBDC_MODE));
+
+	/* Receive list placement control block */
+	printk("DEBUG: RCVLPC_MODE[%08x] RCVLPC_STATUS[%08x]\n",
+	       tr32(RCVLPC_MODE), tr32(RCVLPC_STATUS));
+	printk("       RCVLPC_STATSCTRL[%08x]\n",
+	       tr32(RCVLPC_STATSCTRL));
+
+	/* Receive data and receive BD initiator control block */
+	printk("DEBUG: RCVDBDI_MODE[%08x] RCVDBDI_STATUS[%08x]\n",
+	       tr32(RCVDBDI_MODE), tr32(RCVDBDI_STATUS));
+
+	/* Receive data completion control block */
+	printk("DEBUG: RCVDCC_MODE[%08x]\n",
+	       tr32(RCVDCC_MODE));
+
+	/* Receive BD initiator control block */
+	printk("DEBUG: RCVBDI_MODE[%08x] RCVBDI_STATUS[%08x]\n",
+	       tr32(RCVBDI_MODE), tr32(RCVBDI_STATUS));
+
+	/* Receive BD completion control block */
+	printk("DEBUG: RCVCC_MODE[%08x] RCVCC_STATUS[%08x]\n",
+	       tr32(RCVCC_MODE), tr32(RCVCC_STATUS));
+
+	/* Receive list selector control block */
+	printk("DEBUG: RCVLSC_MODE[%08x] RCVLSC_STATUS[%08x]\n",
+	       tr32(RCVLSC_MODE), tr32(RCVLSC_STATUS));
+
+	/* Mbuf cluster free block */
+	printk("DEBUG: MBFREE_MODE[%08x] MBFREE_STATUS[%08x]\n",
+	       tr32(MBFREE_MODE), tr32(MBFREE_STATUS));
+
+	/* Host coalescing control block */
+	printk("DEBUG: HOSTCC_MODE[%08x] HOSTCC_STATUS[%08x]\n",
+	       tr32(HOSTCC_MODE), tr32(HOSTCC_STATUS));
+	printk("DEBUG: HOSTCC_STATS_BLK_HOST_ADDR[%08x%08x]\n",
+	       tr32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH),
+	       tr32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW));
+	printk("DEBUG: HOSTCC_STATUS_BLK_HOST_ADDR[%08x%08x]\n",
+	       tr32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH),
+	       tr32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW));
+	printk("DEBUG: HOSTCC_STATS_BLK_NIC_ADDR[%08x]\n",
+	       tr32(HOSTCC_STATS_BLK_NIC_ADDR));
+	printk("DEBUG: HOSTCC_STATUS_BLK_NIC_ADDR[%08x]\n",
+	       tr32(HOSTCC_STATUS_BLK_NIC_ADDR));
+
+	/* Memory arbiter control block */
+	printk("DEBUG: MEMARB_MODE[%08x] MEMARB_STATUS[%08x]\n",
+	       tr32(MEMARB_MODE), tr32(MEMARB_STATUS));
+
+	/* Buffer manager control block */
+	printk("DEBUG: BUFMGR_MODE[%08x] BUFMGR_STATUS[%08x]\n",
+	       tr32(BUFMGR_MODE), tr32(BUFMGR_STATUS));
+	printk("DEBUG: BUFMGR_MB_POOL_ADDR[%08x] BUFMGR_MB_POOL_SIZE[%08x]\n",
+	       tr32(BUFMGR_MB_POOL_ADDR), tr32(BUFMGR_MB_POOL_SIZE));
+	printk("DEBUG: BUFMGR_DMA_DESC_POOL_ADDR[%08x] "
+	       "BUFMGR_DMA_DESC_POOL_SIZE[%08x]\n",
+	       tr32(BUFMGR_DMA_DESC_POOL_ADDR),
+	       tr32(BUFMGR_DMA_DESC_POOL_SIZE));
+
+	/* Read DMA control block */
+	printk("DEBUG: RDMAC_MODE[%08x] RDMAC_STATUS[%08x]\n",
+	       tr32(RDMAC_MODE), tr32(RDMAC_STATUS));
+
+	/* Write DMA control block */
+	printk("DEBUG: WDMAC_MODE[%08x] WDMAC_STATUS[%08x]\n",
+	       tr32(WDMAC_MODE), tr32(WDMAC_STATUS));
+
+	/* DMA completion block */
+	printk("DEBUG: DMAC_MODE[%08x]\n",
+	       tr32(DMAC_MODE));
+
+	/* GRC block */
+	printk("DEBUG: GRC_MODE[%08x] GRC_MISC_CFG[%08x]\n",
+	       tr32(GRC_MODE), tr32(GRC_MISC_CFG));
+	printk("DEBUG: GRC_LOCAL_CTRL[%08x]\n",
+	       tr32(GRC_LOCAL_CTRL));
+
+	/* TG3_BDINFOs */
+	printk("DEBUG: RCVDBDI_JUMBO_BD[%08x%08x:%08x:%08x]\n",
+	       tr32(RCVDBDI_JUMBO_BD + 0x0),
+	       tr32(RCVDBDI_JUMBO_BD + 0x4),
+	       tr32(RCVDBDI_JUMBO_BD + 0x8),
+	       tr32(RCVDBDI_JUMBO_BD + 0xc));
+	printk("DEBUG: RCVDBDI_STD_BD[%08x%08x:%08x:%08x]\n",
+	       tr32(RCVDBDI_STD_BD + 0x0),
+	       tr32(RCVDBDI_STD_BD + 0x4),
+	       tr32(RCVDBDI_STD_BD + 0x8),
+	       tr32(RCVDBDI_STD_BD + 0xc));
+	printk("DEBUG: RCVDBDI_MINI_BD[%08x%08x:%08x:%08x]\n",
+	       tr32(RCVDBDI_MINI_BD + 0x0),
+	       tr32(RCVDBDI_MINI_BD + 0x4),
+	       tr32(RCVDBDI_MINI_BD + 0x8),
+	       tr32(RCVDBDI_MINI_BD + 0xc));
+
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0x0, &val32);
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0x4, &val32_2);
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0x8, &val32_3);
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0xc, &val32_4);
+	printk("DEBUG: SRAM_SEND_RCB_0[%08x%08x:%08x:%08x]\n",
+	       val32, val32_2, val32_3, val32_4);
+
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0x0, &val32);
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0x4, &val32_2);
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0x8, &val32_3);
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0xc, &val32_4);
+	printk("DEBUG: SRAM_RCV_RET_RCB_0[%08x%08x:%08x:%08x]\n",
+	       val32, val32_2, val32_3, val32_4);
+
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x0, &val32);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x4, &val32_2);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x8, &val32_3);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0xc, &val32_4);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x10, &val32_5);
+	printk("DEBUG: SRAM_STATUS_BLK[%08x:%08x:%08x:%08x:%08x]\n",
+	       val32, val32_2, val32_3, val32_4, val32_5);
+
+	/* SW status block */
+	printk("DEBUG: Host status block [%08x:%08x:(%04x:%04x:%04x):(%04x:%04x)]\n",
+	       tp->hw_status->status,
+	       tp->hw_status->status_tag,
+	       tp->hw_status->rx_jumbo_consumer,
+	       tp->hw_status->rx_consumer,
+	       tp->hw_status->rx_mini_consumer,
+	       tp->hw_status->idx[0].rx_producer,
+	       tp->hw_status->idx[0].tx_consumer);
+
+	/* SW statistics block */
+	printk("DEBUG: Host statistics block [%08x:%08x:%08x:%08x]\n",
+	       ((u32 *)tp->hw_stats)[0],
+	       ((u32 *)tp->hw_stats)[1],
+	       ((u32 *)tp->hw_stats)[2],
+	       ((u32 *)tp->hw_stats)[3]);
+
+	/* Mailboxes */
+	printk("DEBUG: SNDHOST_PROD[%08x%08x] SNDNIC_PROD[%08x%08x]\n",
+	       tr32(MAILBOX_SNDHOST_PROD_IDX_0 + 0x0),
+	       tr32(MAILBOX_SNDHOST_PROD_IDX_0 + 0x4),
+	       tr32(MAILBOX_SNDNIC_PROD_IDX_0 + 0x0),
+	       tr32(MAILBOX_SNDNIC_PROD_IDX_0 + 0x4));
+
+	/* NIC side send descriptors. */
+	for (i = 0; i < 6; i++) {
+		unsigned long txd;
+
+		txd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_TX_BUFFER_DESC
+			+ (i * sizeof(struct tg3_tx_buffer_desc));
+		printk("DEBUG: NIC TXD(%d)[%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(txd + 0x0), readl(txd + 0x4),
+		       readl(txd + 0x8), readl(txd + 0xc));
+	}
+
+	/* NIC side RX descriptors. */
+	for (i = 0; i < 6; i++) {
+		unsigned long rxd;
+
+		rxd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_RX_BUFFER_DESC
+			+ (i * sizeof(struct tg3_rx_buffer_desc));
+		printk("DEBUG: NIC RXD_STD(%d)[0][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+		rxd += (4 * sizeof(u32));
+		printk("DEBUG: NIC RXD_STD(%d)[1][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+	}
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < 6; i++) {
+		unsigned long rxd;
+
+		rxd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_RX_MINI_BUFFER_DESC
+			+ (i * sizeof(struct tg3_rx_buffer_desc));
+		printk("DEBUG: NIC RXD_MINI(%d)[0][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+		rxd += (4 * sizeof(u32));
+		printk("DEBUG: NIC RXD_MINI(%d)[1][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+	}
+#endif
+
+	for (i = 0; i < 6; i++) {
+		unsigned long rxd;
+
+		rxd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_RX_JUMBO_BUFFER_DESC
+			+ (i * sizeof(struct tg3_rx_buffer_desc));
+		printk("DEBUG: NIC RXD_JUMBO(%d)[0][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+		rxd += (4 * sizeof(u32));
+		printk("DEBUG: NIC RXD_JUMBO(%d)[1][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+	}
+}
+#endif
+
+static struct net_device_stats *tg3_get_stats(struct net_device *);
+
+static int tg3_close(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+
+	netif_stop_queue(dev);
+
+	del_timer_sync(&tp->timer);
+
+	spin_lock_irq(&tp->lock);
+#if 0
+	tg3_dump_state(tp);
+#endif
+
+	tg3_disable_ints(tp);
+
+	tg3_halt(tp);
+	tg3_free_rings(tp);
+	tp->tg3_flags &= ~TG3_FLAG_INIT_COMPLETE;
+
+	spin_unlock_irq(&tp->lock);
+
+	free_irq(dev->irq, dev);
+
+	memcpy(&tp->net_stats_prev, tg3_get_stats(tp->dev),
+	       sizeof(tp->net_stats_prev));
+
+	tg3_free_consistent(tp);
+
+	return 0;
+}
+
+static inline unsigned long get_stat64(tg3_stat64_t *val)
+{
+	unsigned long ret;
+
+#if (BITS_PER_LONG == 32)
+	if (val->high != 0)
+		ret = ~0UL;
+	else
+		ret = val->low;
+#else
+	ret = ((u64)val->high << 32) | ((u64)val->low);
+#endif
+	return ret;
+}
+
+static unsigned long calc_crc_errors(struct tg3 *tp)
+{
+	struct tg3_hw_stats *hw_stats = tp->hw_stats;
+
+	if (tp->phy_id != PHY_ID_SERDES &&
+	    (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 ||
+	     GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701)) {
+		unsigned long flags;
+		u32 val;
+
+		spin_lock_irqsave(&tp->lock, flags);
+		tg3_readphy(tp, 0x1e, &val);
+		tg3_writephy(tp, 0x1e, val | 0x8000);
+		tg3_readphy(tp, 0x14, &val);
+		spin_unlock_irqrestore(&tp->lock, flags);
+
+		tp->phy_crc_errors += val;
+
+		return tp->phy_crc_errors;
+	}
+
+	return get_stat64(&hw_stats->rx_fcs_errors);
+}
+
+static struct net_device_stats *tg3_get_stats(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	struct net_device_stats *stats = &tp->net_stats;
+	struct net_device_stats *old_stats = &tp->net_stats_prev;
+	struct tg3_hw_stats *hw_stats = tp->hw_stats;
+
+	if (!hw_stats)
+		return old_stats;
+
+	stats->rx_packets = old_stats->rx_packets +
+		get_stat64(&hw_stats->rx_ucast_packets) +
+		get_stat64(&hw_stats->rx_mcast_packets) +
+		get_stat64(&hw_stats->rx_bcast_packets);
+		
+	stats->tx_packets = old_stats->tx_packets +
+		get_stat64(&hw_stats->COS_out_packets[0]);
+
+	stats->rx_bytes = old_stats->rx_bytes +
+		get_stat64(&hw_stats->rx_octets);
+	stats->tx_bytes = old_stats->tx_bytes +
+		get_stat64(&hw_stats->tx_octets);
+
+	stats->rx_errors = old_stats->rx_errors +
+		get_stat64(&hw_stats->rx_errors);
+	stats->tx_errors = old_stats->tx_errors +
+		get_stat64(&hw_stats->tx_errors) +
+		get_stat64(&hw_stats->tx_mac_errors) +
+		get_stat64(&hw_stats->tx_carrier_sense_errors) +
+		get_stat64(&hw_stats->tx_discards);
+
+	stats->multicast = old_stats->multicast +
+		get_stat64(&hw_stats->rx_mcast_packets);
+	stats->collisions = old_stats->collisions +
+		get_stat64(&hw_stats->tx_collisions);
+
+	stats->rx_length_errors = old_stats->rx_length_errors +
+		get_stat64(&hw_stats->rx_frame_too_long_errors) +
+		get_stat64(&hw_stats->rx_undersize_packets);
+
+	stats->rx_over_errors = old_stats->rx_over_errors +
+		get_stat64(&hw_stats->rxbds_empty);
+	stats->rx_frame_errors = old_stats->rx_frame_errors +
+		get_stat64(&hw_stats->rx_align_errors);
+	stats->tx_aborted_errors = old_stats->tx_aborted_errors +
+		get_stat64(&hw_stats->tx_discards);
+	stats->tx_carrier_errors = old_stats->tx_carrier_errors +
+		get_stat64(&hw_stats->tx_carrier_sense_errors);
+
+	stats->rx_crc_errors = old_stats->rx_crc_errors +
+		calc_crc_errors(tp);
+
+	return stats;
+}
+
+static inline u32 calc_crc(unsigned char *buf, int len)
+{
+	u32 reg;
+	u32 tmp;
+	int j, k;
+
+	reg = 0xffffffff;
+
+	for (j = 0; j < len; j++) {
+		reg ^= buf[j];
+
+		for (k = 0; k < 8; k++) {
+			tmp = reg & 0x01;
+
+			reg >>= 1;
+
+			if (tmp) {
+				reg ^= 0xedb88320;
+			}
+		}
+	}
+
+	return ~reg;
+}
+
+static void tg3_set_multi(struct tg3 *tp, unsigned int accept_all)
+{
+	/* accept or reject all multicast frames */
+	tw32 (MAC_HASH_REG_0, accept_all ? 0xffffffff : 0);
+	tw32 (MAC_HASH_REG_1, accept_all ? 0xffffffff : 0);
+	tw32 (MAC_HASH_REG_2, accept_all ? 0xffffffff : 0);
+	tw32 (MAC_HASH_REG_3, accept_all ? 0xffffffff : 0);
+}
+
+static void __tg3_set_rx_mode(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	u32 rx_mode;
+
+	rx_mode = tp->rx_mode & ~RX_MODE_PROMISC;
+
+	if (dev->flags & IFF_PROMISC) {
+		/* Promiscuous mode. */
+		rx_mode |= RX_MODE_PROMISC;
+	} else if (dev->flags & IFF_ALLMULTI) {
+		/* Accept all multicast. */
+		tg3_set_multi (tp, 1);
+	} else if (dev->mc_count < 1) {
+		/* Reject all multicast. */
+		tg3_set_multi (tp, 0);
+	} else {
+		/* Accept one or more multicast(s). */
+		struct dev_mc_list *mclist;
+		unsigned int i;
+		u32 mc_filter[4] = { 0, };
+		u32 regidx;
+		u32 bit;
+		u32 crc;
+
+		for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+		     i++, mclist = mclist->next) {
+
+			crc = calc_crc (mclist->dmi_addr, ETH_ALEN);
+			bit = ~crc & 0x7f;
+			regidx = (bit & 0x60) >> 5;
+			bit &= 0x1f;
+			mc_filter[regidx] |= (1 << bit);
+		}
+
+		tw32 (MAC_HASH_REG_0, mc_filter[0]);
+		tw32 (MAC_HASH_REG_1, mc_filter[1]);
+		tw32 (MAC_HASH_REG_2, mc_filter[2]);
+		tw32 (MAC_HASH_REG_3, mc_filter[3]);
+	}
+
+	if (rx_mode != tp->rx_mode) {
+		tp->rx_mode = rx_mode;
+		tw32 (MAC_RX_MODE, rx_mode);
+	}
+}
+
+static void tg3_set_rx_mode(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+
+	spin_lock_irq(&tp->lock);
+	__tg3_set_rx_mode(dev);
+	spin_unlock_irq(&tp->lock);
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,18))
+#define TG3_REGDUMP_LEN		(32 * 1024)
+
+static u8 *tg3_get_regs(struct tg3 *tp)
+{
+	u8 *orig_p = kmalloc(TG3_REGDUMP_LEN, GFP_KERNEL);
+	u8 *p;
+	int i;
+
+	if (orig_p == NULL)
+		return NULL;
+
+	memset(orig_p, 0, TG3_REGDUMP_LEN);
+
+	spin_lock_irq(&tp->lock);
+
+#define __GET_REG32(reg)	(*((u32 *)(p))++ = tr32(reg))
+#define GET_REG32_LOOP(base,len)		\
+do {	p = orig_p + (base);			\
+	for (i = 0; i < len; i += 4)		\
+		__GET_REG32((base) + i);	\
+} while (0)
+#define GET_REG32_1(reg)	\
+do {	p = orig_p + (reg);	\
+	__GET_REG32((reg));	\
+} while (0)
+
+	GET_REG32_LOOP(TG3PCI_VENDOR, 0xb0);
+	GET_REG32_LOOP(MAILBOX_INTERRUPT_0, 0x200);
+	GET_REG32_LOOP(MAC_MODE, 0x4f0);
+	GET_REG32_LOOP(SNDDATAI_MODE, 0xe0);
+	GET_REG32_1(SNDDATAC_MODE);
+	GET_REG32_LOOP(SNDBDS_MODE, 0x80);
+	GET_REG32_LOOP(SNDBDI_MODE, 0x48);
+	GET_REG32_1(SNDBDC_MODE);
+	GET_REG32_LOOP(RCVLPC_MODE, 0x20);
+	GET_REG32_LOOP(RCVLPC_SELLST_BASE, 0x15c);
+	GET_REG32_LOOP(RCVDBDI_MODE, 0x0c);
+	GET_REG32_LOOP(RCVDBDI_JUMBO_BD, 0x3c);
+	GET_REG32_LOOP(RCVDBDI_BD_PROD_IDX_0, 0x44);
+	GET_REG32_1(RCVDCC_MODE);
+	GET_REG32_LOOP(RCVBDI_MODE, 0x20);
+	GET_REG32_LOOP(RCVCC_MODE, 0x14);
+	GET_REG32_LOOP(RCVLSC_MODE, 0x08);
+	GET_REG32_1(MBFREE_MODE);
+	GET_REG32_LOOP(HOSTCC_MODE, 0x100);
+	GET_REG32_LOOP(MEMARB_MODE, 0x10);
+	GET_REG32_LOOP(BUFMGR_MODE, 0x58);
+	GET_REG32_LOOP(RDMAC_MODE, 0x08);
+	GET_REG32_LOOP(WDMAC_MODE, 0x08);
+	GET_REG32_LOOP(RX_CPU_BASE, 0x280);
+	GET_REG32_LOOP(TX_CPU_BASE, 0x280);
+	GET_REG32_LOOP(GRCMBOX_INTERRUPT_0, 0x110);
+	GET_REG32_LOOP(FTQ_RESET, 0x120);
+	GET_REG32_LOOP(MSGINT_MODE, 0x0c);
+	GET_REG32_1(DMAC_MODE);
+	GET_REG32_LOOP(GRC_MODE, 0x4c);
+	GET_REG32_LOOP(NVRAM_CMD, 0x24);
+
+#undef __GET_REG32
+#undef GET_REG32_LOOP
+#undef GET_REG32_1
+
+	spin_unlock_irq(&tp->lock);
+
+	return orig_p;
+}
+
+static void tg3_to_ethtool_coal(struct tg3 *tp,
+				struct ethtool_coalesce *ecoal)
+{
+	ecoal->rx_coalesce_usecs =
+		tp->coalesce_config.rx_coalesce_ticks_def;
+	ecoal->rx_max_coalesced_frames =
+		tp->coalesce_config.rx_max_coalesced_frames_def;
+	ecoal->rx_coalesce_usecs_irq =
+		tp->coalesce_config.rx_coalesce_ticks_during_int_def;
+	ecoal->rx_max_coalesced_frames_irq =
+		tp->coalesce_config.rx_max_coalesced_frames_during_int_def;
+
+	ecoal->tx_coalesce_usecs =
+		tp->coalesce_config.tx_coalesce_ticks_def;
+	ecoal->tx_max_coalesced_frames =
+		tp->coalesce_config.tx_max_coalesced_frames_def;
+	ecoal->tx_coalesce_usecs_irq =
+		tp->coalesce_config.tx_coalesce_ticks_during_int_def;
+	ecoal->tx_max_coalesced_frames_irq =
+		tp->coalesce_config.tx_max_coalesced_frames_during_int_def;
+
+	ecoal->stats_block_coalesce_usecs =
+		tp->coalesce_config.stats_coalesce_ticks_def;
+
+	ecoal->use_adaptive_rx_coalesce =
+		(tp->tg3_flags & TG3_FLAG_ADAPTIVE_RX) != 0;
+	ecoal->use_adaptive_tx_coalesce =
+		(tp->tg3_flags & TG3_FLAG_ADAPTIVE_TX) != 0;
+
+	ecoal->pkt_rate_low =
+		tp->coalesce_config.pkt_rate_low;
+	ecoal->rx_coalesce_usecs_low =
+		tp->coalesce_config.rx_coalesce_ticks_low;
+	ecoal->rx_max_coalesced_frames_low =
+		tp->coalesce_config.rx_max_coalesced_frames_low;
+	ecoal->tx_coalesce_usecs_low =
+		tp->coalesce_config.tx_coalesce_ticks_low;
+	ecoal->tx_max_coalesced_frames_low =
+		tp->coalesce_config.tx_max_coalesced_frames_low;
+
+	ecoal->pkt_rate_high =
+		tp->coalesce_config.pkt_rate_high;
+	ecoal->rx_coalesce_usecs_high =
+		tp->coalesce_config.rx_coalesce_ticks_high;
+	ecoal->rx_max_coalesced_frames_high =
+		tp->coalesce_config.rx_max_coalesced_frames_high;
+	ecoal->tx_coalesce_usecs_high =
+		tp->coalesce_config.tx_coalesce_ticks_high;
+	ecoal->tx_max_coalesced_frames_high =
+		tp->coalesce_config.tx_max_coalesced_frames_high;
+
+	ecoal->rate_sample_interval =
+		tp->coalesce_config.rate_sample_jiffies / HZ;
+}
+
+static int tg3_from_ethtool_coal(struct tg3 *tp,
+				 struct ethtool_coalesce *ecoal)
+{
+	/* Make sure we are not getting garbage. */
+	if ((ecoal->rx_coalesce_usecs == 0 &&
+	     ecoal->rx_max_coalesced_frames == 0) ||
+	    (ecoal->tx_coalesce_usecs == 0 &&
+	     ecoal->tx_max_coalesced_frames == 0) ||
+	    ecoal->stats_block_coalesce_usecs == 0)
+		return -EINVAL;
+	if (ecoal->use_adaptive_rx_coalesce ||
+	    ecoal->use_adaptive_tx_coalesce) {
+		if (ecoal->pkt_rate_low > ecoal->pkt_rate_high)
+			return -EINVAL;
+		if (ecoal->rate_sample_interval == 0)
+			return -EINVAL;
+		if (ecoal->use_adaptive_rx_coalesce &&
+		    ((ecoal->rx_coalesce_usecs_low == 0 &&
+		      ecoal->rx_max_coalesced_frames_low == 0) ||
+		     (ecoal->rx_coalesce_usecs_high == 0 &&
+		      ecoal->rx_max_coalesced_frames_high == 0)))
+			return -EINVAL;
+		if (ecoal->use_adaptive_tx_coalesce &&
+		    ((ecoal->tx_coalesce_usecs_low == 0 &&
+		      ecoal->tx_max_coalesced_frames_low == 0) ||
+		     (ecoal->tx_coalesce_usecs_high == 0 &&
+		      ecoal->tx_max_coalesced_frames_high == 0)))
+			return -EINVAL;
+	}
+
+	/* Looks good, let it rip. */
+	spin_lock_irq(&tp->lock);
+	tp->coalesce_config.rx_coalesce_ticks =
+		tp->coalesce_config.rx_coalesce_ticks_def =
+		ecoal->rx_coalesce_usecs;
+	tp->coalesce_config.rx_max_coalesced_frames =
+		tp->coalesce_config.rx_max_coalesced_frames_def =
+		ecoal->rx_max_coalesced_frames;
+	tp->coalesce_config.rx_coalesce_ticks_during_int =
+		tp->coalesce_config.rx_coalesce_ticks_during_int_def =
+		ecoal->rx_coalesce_usecs_irq;
+	tp->coalesce_config.rx_max_coalesced_frames_during_int =
+		tp->coalesce_config.rx_max_coalesced_frames_during_int_def =
+		ecoal->rx_max_coalesced_frames_irq;
+	tp->coalesce_config.tx_coalesce_ticks =
+		tp->coalesce_config.tx_coalesce_ticks_def =
+		ecoal->tx_coalesce_usecs;
+	tp->coalesce_config.tx_max_coalesced_frames =
+		tp->coalesce_config.tx_max_coalesced_frames_def =
+		ecoal->tx_max_coalesced_frames;
+	tp->coalesce_config.tx_coalesce_ticks_during_int =
+		tp->coalesce_config.tx_coalesce_ticks_during_int_def =
+		ecoal->tx_coalesce_usecs_irq;
+	tp->coalesce_config.tx_max_coalesced_frames_during_int =
+		tp->coalesce_config.tx_max_coalesced_frames_during_int_def =
+		ecoal->tx_max_coalesced_frames_irq;
+	tp->coalesce_config.stats_coalesce_ticks =
+		tp->coalesce_config.stats_coalesce_ticks_def =
+		ecoal->stats_block_coalesce_usecs;
+
+	if (ecoal->use_adaptive_rx_coalesce)
+		tp->tg3_flags |= TG3_FLAG_ADAPTIVE_RX;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_ADAPTIVE_RX;
+	if (ecoal->use_adaptive_tx_coalesce)
+		tp->tg3_flags |= TG3_FLAG_ADAPTIVE_TX;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_ADAPTIVE_TX;
+
+	tp->coalesce_config.pkt_rate_low = ecoal->pkt_rate_low;
+	tp->coalesce_config.pkt_rate_high = ecoal->pkt_rate_high;
+	tp->coalesce_config.rate_sample_jiffies =
+		ecoal->rate_sample_interval * HZ;
+
+	tp->coalesce_config.rx_coalesce_ticks_low =
+		ecoal->rx_coalesce_usecs_low;
+	tp->coalesce_config.rx_max_coalesced_frames_low =
+		ecoal->rx_max_coalesced_frames_low;
+	tp->coalesce_config.tx_coalesce_ticks_low =
+		ecoal->tx_coalesce_usecs_low;
+	tp->coalesce_config.tx_max_coalesced_frames_low =
+		ecoal->tx_max_coalesced_frames_low;
+
+	tp->coalesce_config.rx_coalesce_ticks_high =
+		ecoal->rx_coalesce_usecs_high;
+	tp->coalesce_config.rx_max_coalesced_frames_high =
+		ecoal->rx_max_coalesced_frames_high;
+	tp->coalesce_config.tx_coalesce_ticks_high =
+		ecoal->tx_coalesce_usecs_high;
+	tp->coalesce_config.tx_max_coalesced_frames_high =
+		ecoal->tx_max_coalesced_frames_high;
+
+	tw32(HOSTCC_RXCOL_TICKS,
+	     tp->coalesce_config.rx_coalesce_ticks_def);
+	tw32(HOSTCC_RXMAX_FRAMES,
+	     tp->coalesce_config.rx_max_coalesced_frames_def);
+	tw32(HOSTCC_RXCOAL_TICK_INT,
+	     tp->coalesce_config.rx_coalesce_ticks_during_int_def);
+	tw32(HOSTCC_RXCOAL_MAXF_INT,
+	     tp->coalesce_config.rx_max_coalesced_frames_during_int_def);
+	tw32(HOSTCC_TXCOL_TICKS,
+	     tp->coalesce_config.tx_coalesce_ticks_def);
+	tw32(HOSTCC_TXMAX_FRAMES,
+	     tp->coalesce_config.tx_max_coalesced_frames_def);
+	tw32(HOSTCC_TXCOAL_TICK_INT,
+	     tp->coalesce_config.tx_coalesce_ticks_during_int_def);
+	tw32(HOSTCC_TXCOAL_MAXF_INT,
+	     tp->coalesce_config.tx_max_coalesced_frames_during_int_def);
+	tw32(HOSTCC_STAT_COAL_TICKS,
+	     tp->coalesce_config.stats_coalesce_ticks_def);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+static int tg3_ethtool_ioctl (struct net_device *dev, void *useraddr)
+{
+	struct tg3 *tp = dev->priv;
+	struct pci_dev *pci_dev = tp->pdev;
+	u32 ethcmd;
+
+	if (copy_from_user (&ethcmd, useraddr, sizeof (ethcmd)))
+		return -EFAULT;
+
+	switch (ethcmd) {
+	case ETHTOOL_GDRVINFO:{
+		struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+		strcpy (info.driver, DRV_MODULE_NAME);
+		strcpy (info.version, DRV_MODULE_VERSION);
+		memset(&info.fw_version, 0, sizeof(info.fw_version));
+		strcpy (info.bus_info, pci_dev->slot_name);
+		info.eedump_len = 0;
+		info.regdump_len = TG3_REGDUMP_LEN;
+		if (copy_to_user (useraddr, &info, sizeof (info)))
+			return -EFAULT;
+		return 0;
+	}
+
+	case ETHTOOL_GSET: {
+		struct ethtool_cmd cmd = { ETHTOOL_GSET };
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+		    tp->link_config.phy_is_low_power)
+			return -EAGAIN;
+		cmd.supported = (SUPPORTED_Autoneg);
+
+		if (!(tp->tg3_flags & TG3_FLAG_10_100_ONLY))
+			cmd.supported |= (SUPPORTED_1000baseT_Half |
+					  SUPPORTED_1000baseT_Full);
+
+		if (tp->phy_id != PHY_ID_SERDES)
+			cmd.supported |= (SUPPORTED_100baseT_Half |
+					  SUPPORTED_100baseT_Full |
+					  SUPPORTED_10baseT_Half |
+					  SUPPORTED_10baseT_Full |
+					  SUPPORTED_MII);
+		else
+			cmd.supported |= SUPPORTED_FIBRE;
+
+		cmd.advertising = tp->link_config.advertising;
+		cmd.speed = tp->link_config.active_speed;
+		cmd.duplex = tp->link_config.active_duplex;
+		cmd.port = 0;
+		cmd.phy_address = PHY_ADDR;
+		cmd.transceiver = 0;
+		cmd.autoneg = tp->link_config.autoneg;
+		cmd.maxtxpkt = tp->coalesce_config.tx_max_coalesced_frames_def;
+		cmd.maxrxpkt = tp->coalesce_config.rx_max_coalesced_frames_def;
+		if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SSET: {
+		struct ethtool_cmd cmd;
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+		    tp->link_config.phy_is_low_power)
+			return -EAGAIN;
+
+		if (copy_from_user(&cmd, useraddr, sizeof(cmd)))
+			return -EFAULT;
+
+		/* Fiber PHY only supports 1000 full/half */
+		if (cmd.autoneg == AUTONEG_ENABLE) {
+			if (tp->phy_id == PHY_ID_SERDES &&
+			    (cmd.advertising &
+			     (ADVERTISED_10baseT_Half |
+			      ADVERTISED_10baseT_Full |
+			      ADVERTISED_100baseT_Half |
+			      ADVERTISED_100baseT_Full)))
+				return -EINVAL;
+			if ((tp->tg3_flags & TG3_FLAG_10_100_ONLY) &&
+			    (cmd.advertising &
+			     (ADVERTISED_1000baseT_Half |
+			      ADVERTISED_1000baseT_Full)))
+				return -EINVAL;
+		} else {
+			if (tp->phy_id == PHY_ID_SERDES &&
+			    (cmd.speed == SPEED_10 ||
+			     cmd.speed == SPEED_100))
+				return -EINVAL;
+			if ((tp->tg3_flags & TG3_FLAG_10_100_ONLY) &&
+			    (cmd.speed == SPEED_10 ||
+			     cmd.speed == SPEED_100))
+				return -EINVAL;
+		}
+
+		spin_lock_irq(&tp->lock);
+
+		tp->link_config.autoneg = cmd.autoneg;
+		if (cmd.autoneg == AUTONEG_ENABLE) {
+			tp->link_config.advertising = cmd.advertising;
+			tp->link_config.speed = SPEED_INVALID;
+			tp->link_config.duplex = DUPLEX_INVALID;
+		} else {
+			tp->link_config.speed = cmd.speed;
+			tp->link_config.duplex = cmd.duplex;
+		}
+
+		if (cmd.maxtxpkt || cmd.maxrxpkt) {
+			tp->coalesce_config.tx_max_coalesced_frames_def =
+				tp->coalesce_config.tx_max_coalesced_frames =
+				cmd.maxtxpkt;
+			tp->coalesce_config.rx_max_coalesced_frames_def =
+				tp->coalesce_config.rx_max_coalesced_frames =
+				cmd.maxrxpkt;
+
+			/* Coalescing config bits can be updated without
+			 * a full chip reset.
+			 */
+			tw32(HOSTCC_TXMAX_FRAMES,
+			     tp->coalesce_config.tx_max_coalesced_frames);
+			tw32(HOSTCC_RXMAX_FRAMES,
+			     tp->coalesce_config.rx_max_coalesced_frames);
+		}
+		tg3_setup_phy(tp);
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+
+	case ETHTOOL_GREGS: {
+		struct ethtool_regs regs;
+		u8 *regbuf;
+		int ret;
+
+		if (copy_from_user(&regs, useraddr, sizeof(regs)))
+			return -EFAULT;
+		if (regs.len > TG3_REGDUMP_LEN)
+			regs.len = TG3_REGDUMP_LEN;
+		regs.version = 0;
+		if (copy_to_user(useraddr, &regs, sizeof(regs)))
+			return -EFAULT;
+
+		regbuf = tg3_get_regs(tp);
+		if (!regbuf)
+			return -ENOMEM;
+
+		useraddr += offsetof(struct ethtool_regs, data);
+		ret = 0;
+		if (copy_to_user(useraddr, regbuf, regs.len))
+			ret = -EFAULT;
+		kfree(regbuf);
+		return ret;
+	}
+	case ETHTOOL_GWOL: {
+		struct ethtool_wolinfo wol = { ETHTOOL_GWOL };
+
+		wol.supported = WAKE_MAGIC;
+		wol.wolopts = 0;
+		if (tp->tg3_flags & TG3_FLAG_WOL_ENABLE)
+			wol.wolopts = WAKE_MAGIC;
+		memset(&wol.sopass, 0, sizeof(wol.sopass));
+		if (copy_to_user(useraddr, &wol, sizeof(wol)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SWOL: {
+		struct ethtool_wolinfo wol;
+
+		if (copy_from_user(&wol, useraddr, sizeof(wol)))
+			return -EFAULT;
+		if (wol.wolopts & ~WAKE_MAGIC)
+			return -EINVAL;
+		spin_lock_irq(&tp->lock);
+		if (wol.wolopts & WAKE_MAGIC)
+			tp->tg3_flags |= TG3_FLAG_WOL_ENABLE;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_WOL_ENABLE;
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GMSGLVL: {
+		struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+		edata.data = tp->msg_enable;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SMSGLVL: {
+		struct ethtool_value edata;
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+		tp->msg_enable = edata.data;
+		return 0;
+	}
+	case ETHTOOL_NWAY_RST: {
+		u32 bmcr;
+		int r;
+
+		spin_lock_irq(&tp->lock);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		r = -EINVAL;
+		if (bmcr & BMCR_ANENABLE) {
+			tg3_writephy(tp, MII_BMCR,
+				     bmcr | BMCR_ANRESTART);
+			r = 0;
+		}
+		spin_unlock_irq(&tp->lock);
+
+		return r;
+	}
+	case ETHTOOL_GLINK: {
+		struct ethtool_value edata = { ETHTOOL_GLINK };
+		edata.data = netif_carrier_ok(tp->dev) ? 1 : 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	case ETHTOOL_GCOALESCE: {
+		struct ethtool_coalesce ecoal = { ETHTOOL_GCOALESCE };
+
+		tg3_to_ethtool_coal(tp, &ecoal);
+		if (copy_to_user(useraddr, &ecoal, sizeof(ecoal)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SCOALESCE: {
+		struct ethtool_coalesce ecoal;
+
+		if (copy_from_user(&ecoal, useraddr, sizeof(ecoal)))
+			return -EINVAL;
+
+		return tg3_from_ethtool_coal(tp, &ecoal);
+	}
+	case ETHTOOL_GRINGPARAM: {
+		struct ethtool_ringparam ering = { ETHTOOL_GRINGPARAM };
+
+		ering.rx_max_pending = TG3_RX_RING_SIZE - 1;
+#if TG3_MINI_RING_WORKS
+		ering.rx_mini_max_pending = TG3_RX_MINI_RING_SIZE - 1;
+#else
+		ering.rx_mini_max_pending = 0;
+#endif
+		ering.rx_jumbo_max_pending = TG3_RX_JUMBO_RING_SIZE - 1;
+
+		ering.rx_pending = tp->rx_pending;
+#if TG3_MINI_RING_WORKS
+		ering.rx_mini_pending = tp->rx_mini_pending;
+#else
+		ering.rx_mini_pending = 0;
+#endif
+		ering.rx_jumbo_pending = tp->rx_jumbo_pending;
+		ering.tx_pending = tp->tx_pending;
+
+		if (copy_to_user(useraddr, &ering, sizeof(ering)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SRINGPARAM: {
+		struct ethtool_ringparam ering;
+
+		if (copy_from_user(&ering, useraddr, sizeof(ering)))
+			return -EFAULT;
+
+		if ((ering.rx_pending > TG3_RX_RING_SIZE - 1) ||
+#if TG3_MINI_RING_WORKS
+		    (ering.rx_mini_pending > TG3_RX_MINI_RING_SIZE - 1) ||
+#endif
+		    (ering.rx_jumbo_pending > TG3_RX_JUMBO_RING_SIZE - 1) ||
+		    (ering.tx_pending > TG3_TX_RING_SIZE - 1))
+			return -EINVAL;
+
+		spin_lock_irq(&tp->lock);
+
+		tp->rx_pending = ering.rx_pending;
+#if TG3_MINI_RING_WORKS
+		tp->rx_mini_pending = ering.rx_mini_pending;
+#endif
+		tp->rx_jumbo_pending = ering.rx_jumbo_pending;
+		tp->tx_pending = ering.tx_pending;
+
+		tg3_halt(tp);
+		tg3_init_rings(tp);
+		tg3_init_hw(tp);
+		netif_wake_queue(tp->dev);
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GPAUSEPARAM: {
+		struct ethtool_pauseparam epause = { ETHTOOL_GPAUSEPARAM };
+
+		epause.autoneg =
+			(tp->tg3_flags & TG3_FLAG_PAUSE_AUTONEG) != 0;
+		epause.rx_pause =
+			(tp->tg3_flags & TG3_FLAG_PAUSE_RX) != 0;
+		epause.tx_pause =
+			(tp->tg3_flags & TG3_FLAG_PAUSE_TX) != 0;
+		if (copy_to_user(useraddr, &epause, sizeof(epause)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SPAUSEPARAM: {
+		struct ethtool_pauseparam epause;
+
+		if (copy_from_user(&epause, useraddr, sizeof(epause)))
+			return -EFAULT;
+
+		spin_lock_irq(&tp->lock);
+		if (epause.autoneg)
+			tp->tg3_flags |= TG3_FLAG_PAUSE_AUTONEG;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_PAUSE_AUTONEG;
+		if (epause.rx_pause)
+			tp->tg3_flags |= TG3_FLAG_PAUSE_RX;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_PAUSE_RX;
+		if (epause.tx_pause)
+			tp->tg3_flags |= TG3_FLAG_PAUSE_TX;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_PAUSE_TX;
+		tg3_halt(tp);
+		tg3_init_rings(tp);
+		tg3_init_hw(tp);
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GRXCSUM: {
+		struct ethtool_value edata = { ETHTOOL_GRXCSUM };
+
+		edata.data =
+			(tp->tg3_flags & TG3_FLAG_RX_CHECKSUMS) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SRXCSUM: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+
+		if (tp->tg3_flags & TG3_FLAG_BROKEN_CHECKSUMS) {
+			if (edata.data != 0)
+				return -EINVAL;
+			return 0;
+		}
+
+		spin_lock_irq(&tp->lock);
+		if (edata.data)
+			tp->tg3_flags |= TG3_FLAG_RX_CHECKSUMS;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_RX_CHECKSUMS;
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GTXCSUM: {
+		struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+		edata.data =
+			(tp->dev->features & NETIF_F_IP_CSUM) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_STXCSUM: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+
+		if (tp->tg3_flags & TG3_FLAG_BROKEN_CHECKSUMS) {
+			if (edata.data != 0)
+				return -EINVAL;
+			return 0;
+		}
+
+		if (edata.data)
+			tp->dev->features |= NETIF_F_IP_CSUM;
+		else
+			tp->dev->features &= ~NETIF_F_IP_CSUM;
+
+		return 0;
+	}
+	case ETHTOOL_GSG: {
+		struct ethtool_value edata = { ETHTOOL_GSG };
+
+		edata.data =
+			(tp->dev->features & NETIF_F_SG) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SSG: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+
+		if (edata.data)
+			tp->dev->features |= NETIF_F_SG;
+		else
+			tp->dev->features &= ~NETIF_F_SG;
+
+		return 0;
+	}
+	};
+
+	return -EOPNOTSUPP;
+}
+#endif /* KERNEL_VERSION > 2.4.18 */
+
+
+static int tg3_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	switch(cmd) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,18))
+	case SIOCETHTOOL:
+		return tg3_ethtool_ioctl(dev, (void *) ifr->ifr_data);
+#endif
+	case SIOCGMIIPHY:
+		data->phy_id = PHY_ADDR;
+
+		/* fallthru */
+	case SIOCGMIIREG: {
+		u32 mii_regval;
+
+		spin_lock_irq(&tp->lock);
+		err = tg3_readphy(tp, data->reg_num & 0x1f, &mii_regval);
+		spin_unlock_irq(&tp->lock);
+
+		data->val_out = mii_regval;
+
+		return err;
+	}
+
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		spin_lock_irq(&tp->lock);
+		err = tg3_writephy(tp, data->reg_num & 0x1f, data->val_in);
+		spin_unlock_irq(&tp->lock);
+
+		return err;
+
+	default:
+		/* do nothing */
+		break;
+	}
+	return -EOPNOTSUPP;
+}
+
+#if TG3_VLAN_TAG_USED
+static void tg3_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+	struct tg3 *tp = dev->priv;
+
+	spin_lock_irq(&tp->lock);
+	tp->vlgrp = grp;
+	spin_unlock_irq(&tp->lock);
+}
+
+static void tg3_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	struct tg3 *tp = dev->priv;
+
+	spin_lock_irq(&tp->lock);
+	if (tp->vlgrp)
+		tp->vlgrp->vlan_devices[vid] = NULL;
+	spin_unlock_irq(&tp->lock);
+}
+#endif
+
+/* Chips other than 5700/5701 use the NVRAM for fetching info. */
+static void __devinit tg3_nvram_init(struct tg3 *tp)
+{
+	int j;
+
+	tw32(GRC_EEPROM_ADDR,
+	     (EEPROM_ADDR_FSM_RESET |
+	      (EEPROM_DEFAULT_CLOCK_PERIOD <<
+	       EEPROM_ADDR_CLKPERD_SHIFT)));
+
+	/* XXX schedule_timeout() ... */
+	for (j = 0; j < 100; j++)
+		udelay(10);
+
+	/* Enable seeprom accesses. */
+	tw32(GRC_LOCAL_CTRL,
+	     tr32(GRC_LOCAL_CTRL) | GRC_LCLCTRL_AUTO_SEEPROM);
+	udelay(100);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700 &&
+	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) {
+		u32 nvcfg1 = tr32(NVRAM_CFG1);
+
+		tp->tg3_flags |= TG3_FLAG_NVRAM;
+		if (nvcfg1 & NVRAM_CFG1_FLASHIF_ENAB) {
+			if (nvcfg1 & NVRAM_CFG1_BUFFERED_MODE)
+				tp->tg3_flags |= TG3_FLAG_NVRAM_BUFFERED;
+		} else {
+			nvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;
+			tw32(NVRAM_CFG1, nvcfg1);
+		}
+
+	} else {
+		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
+	}
+}
+
+static int __devinit tg3_nvram_read_using_eeprom(struct tg3 *tp,
+						 u32 offset, u32 *val)
+{
+	u32 tmp;
+	int i;
+
+	if (offset > EEPROM_ADDR_ADDR_MASK ||
+	    (offset % 4) != 0)
+		return -EINVAL;
+
+	tmp = tr32(GRC_EEPROM_ADDR) & ~(EEPROM_ADDR_ADDR_MASK |
+					EEPROM_ADDR_DEVID_MASK |
+					EEPROM_ADDR_READ);
+	tw32(GRC_EEPROM_ADDR,
+	     tmp |
+	     (0 << EEPROM_ADDR_DEVID_SHIFT) |
+	     ((offset << EEPROM_ADDR_ADDR_SHIFT) &
+	      EEPROM_ADDR_ADDR_MASK) |
+	     EEPROM_ADDR_READ | EEPROM_ADDR_START);
+
+	for (i = 0; i < 10000; i++) {
+		tmp = tr32(GRC_EEPROM_ADDR);
+
+		if (tmp & EEPROM_ADDR_COMPLETE)
+			break;
+		udelay(100);
+	}
+	if (!(tmp & EEPROM_ADDR_COMPLETE))
+		return -EBUSY;
+
+	*val = tr32(GRC_EEPROM_DATA);
+	return 0;
+}
+
+static int __devinit tg3_nvram_read(struct tg3 *tp,
+				    u32 offset, u32 *val)
+{
+	int i, saw_done_clear;
+
+	if (!(tp->tg3_flags & TG3_FLAG_NVRAM))
+		return tg3_nvram_read_using_eeprom(tp, offset, val);
+
+	if (tp->tg3_flags & TG3_FLAG_NVRAM_BUFFERED)
+		offset = ((offset / NVRAM_BUFFERED_PAGE_SIZE) <<
+			  NVRAM_BUFFERED_PAGE_POS) +
+			(offset % NVRAM_BUFFERED_PAGE_SIZE);
+
+	if (offset > NVRAM_ADDR_MSK)
+		return -EINVAL;
+
+	tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+	for (i = 0; i < 1000; i++) {
+		if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+			break;
+		udelay(20);
+	}
+
+	tw32(NVRAM_ADDR, offset);
+	tw32(NVRAM_CMD,
+	     NVRAM_CMD_RD | NVRAM_CMD_GO |
+	     NVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);
+
+	/* Wait for done bit to clear then set again. */
+	saw_done_clear = 0;
+	for (i = 0; i < 1000; i++) {
+		udelay(10);
+		if (!saw_done_clear &&
+		    !(tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			saw_done_clear = 1;
+		else if (saw_done_clear &&
+			 (tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			break;
+	}
+	if (i >= 1000) {
+		tw32(NVRAM_SWARB, SWARB_REQ_CLR1);
+		return -EBUSY;
+	}
+
+	*val = swab32(tr32(NVRAM_RDDATA));
+	tw32(NVRAM_SWARB, 0x20);
+
+	return 0;
+}
+
+struct subsys_tbl_ent {
+	u16 subsys_vendor, subsys_devid;
+	u32 phy_id;
+};
+
+static struct subsys_tbl_ent subsys_id_to_phy_id[] = {
+	/* Broadcom boards. */
+	{ 0x14e4, 0x1644, PHY_ID_BCM5401 }, /* BCM95700A6 */
+	{ 0x14e4, 0x0001, PHY_ID_BCM5701 }, /* BCM95701A5 */
+	{ 0x14e4, 0x0002, PHY_ID_BCM8002 }, /* BCM95700T6 */
+	{ 0x14e4, 0x0003, PHY_ID_SERDES  }, /* BCM95700A9 */
+	{ 0x14e4, 0x0005, PHY_ID_BCM5701 }, /* BCM95701T1 */
+	{ 0x14e4, 0x0006, PHY_ID_BCM5701 }, /* BCM95701T8 */
+	{ 0x14e4, 0x0007, PHY_ID_SERDES  }, /* BCM95701A7 */
+	{ 0x14e4, 0x0008, PHY_ID_BCM5701 }, /* BCM95701A10 */
+	{ 0x14e4, 0x8008, PHY_ID_BCM5701 }, /* BCM95701A12 */
+	{ 0x14e4, 0x0009, PHY_ID_BCM5701 }, /* BCM95703Ax1 */
+	{ 0x14e4, 0x8009, PHY_ID_BCM5701 }, /* BCM95703Ax2 */
+
+	/* 3com boards. */
+	{ PCI_VENDOR_ID_3COM, 0x1000, PHY_ID_BCM5401 }, /* 3C996T */
+	{ PCI_VENDOR_ID_3COM, 0x1006, PHY_ID_BCM5701 }, /* 3C996BT */
+	/* { PCI_VENDOR_ID_3COM, 0x1002, PHY_ID_XXX },     3C996CT */
+	/* { PCI_VENDOR_ID_3COM, 0x1003, PHY_ID_XXX },     3C997T */
+	{ PCI_VENDOR_ID_3COM, 0x1004, PHY_ID_SERDES  }, /* 3C996SX */
+	/* { PCI_VENDOR_ID_3COM, 0x1005, PHY_ID_XXX },     3C997SZ */
+	{ PCI_VENDOR_ID_3COM, 0x1007, PHY_ID_BCM5701 }, /* 3C1000T */
+	{ PCI_VENDOR_ID_3COM, 0x1008, PHY_ID_BCM5701 }, /* 3C940BR01 */
+
+	/* DELL boards. */
+	{ PCI_VENDOR_ID_DELL, 0x00d1, PHY_ID_BCM5401 }, /* VIPER */
+	{ PCI_VENDOR_ID_DELL, 0x0106, PHY_ID_BCM5401 }, /* JAGUAR */
+	{ PCI_VENDOR_ID_DELL, 0x0109, PHY_ID_BCM5411 }, /* MERLOT */
+	{ PCI_VENDOR_ID_DELL, 0x010a, PHY_ID_BCM5411 }, /* SLIM_MERLOT */
+
+	/* Compaq boards. */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007c, PHY_ID_BCM5701 }, /* BANSHEE */
+	{ PCI_VENDOR_ID_COMPAQ, 0x009a, PHY_ID_BCM5701 }, /* BANSHEE_2 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007d, PHY_ID_SERDES  }, /* CHANGELING */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0085, PHY_ID_BCM5701 }, /* NC7780 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0099, PHY_ID_BCM5701 }  /* NC7780_2 */
+};
+
+static int __devinit tg3_phy_probe(struct tg3 *tp)
+{
+	u32 eeprom_phy_id, hw_phy_id_1, hw_phy_id_2;
+	u32 hw_phy_id, hw_phy_id_masked;
+	enum phy_led_mode eeprom_led_mode;
+	u32 val;
+	int i, eeprom_signature_found, err;
+
+	tp->phy_id = PHY_ID_INVALID;
+	for (i = 0; i < ARRAY_SIZE(subsys_id_to_phy_id); i++) {
+		if ((subsys_id_to_phy_id[i].subsys_vendor ==
+		     tp->pdev->subsystem_vendor) &&
+		    (subsys_id_to_phy_id[i].subsys_devid ==
+		     tp->pdev->subsystem_device)) {
+			tp->phy_id = subsys_id_to_phy_id[i].phy_id;
+			break;
+		}
+	}
+
+	eeprom_phy_id = PHY_ID_INVALID;
+	eeprom_led_mode = led_mode_auto;
+	eeprom_signature_found = 0;
+	tg3_read_mem(tp, NIC_SRAM_DATA_SIG, &val);
+	if (val == NIC_SRAM_DATA_SIG_MAGIC) {
+		u32 nic_cfg;
+
+		tg3_read_mem(tp, NIC_SRAM_DATA_CFG, &nic_cfg);
+
+		eeprom_signature_found = 1;
+
+		if ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==
+		    NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER) {
+			eeprom_phy_id = PHY_ID_SERDES;
+		} else {
+			u32 nic_phy_id;
+
+			tg3_read_mem(tp, NIC_SRAM_DATA_PHY_ID, &nic_phy_id);
+			if (nic_phy_id != 0) {
+				u32 id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;
+				u32 id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;
+
+				eeprom_phy_id  = (id1 >> 16) << 10;
+				eeprom_phy_id |= (id2 & 0xfc00) << 16;
+				eeprom_phy_id |= (id2 & 0x03ff) <<  0;
+			}
+		}
+
+		switch (nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK) {
+		case NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD:
+			eeprom_led_mode = led_mode_three_link;
+			break;
+
+		case NIC_SRAM_DATA_CFG_LED_LINK_SPD:
+			eeprom_led_mode = led_mode_link10;
+			break;
+
+		default:
+			eeprom_led_mode = led_mode_auto;
+			break;
+		};
+	}
+
+	err = tg3_phy_reset(tp, 0);
+	if (err)
+		return err;
+
+	/* Now read the physical PHY_ID from the chip and verify
+	 * that it is sane.  If it doesn't look good, we fall back
+	 * to either the hard-coded table based PHY_ID and failing
+	 * that the value found in the eeprom area.
+	 */
+	err  = tg3_readphy(tp, MII_PHYSID1, &hw_phy_id_1);
+	err |= tg3_readphy(tp, MII_PHYSID2, &hw_phy_id_2);
+
+	hw_phy_id  = (hw_phy_id_1 & 0xffff) << 10;
+	hw_phy_id |= (hw_phy_id_2 & 0xfc00) << 16;
+	hw_phy_id |= (hw_phy_id_2 & 0x03ff) <<  0;
+
+	hw_phy_id_masked = hw_phy_id & PHY_ID_MASK;
+
+	if (!err && KNOWN_PHY_ID(hw_phy_id_masked)) {
+		tp->phy_id = hw_phy_id;
+	} else {
+		/* phy_id currently holds the value found in the
+		 * subsys_id_to_phy_id[] table or PHY_ID_INVALID
+		 * if a match was not found there.
+		 */
+		if (tp->phy_id == PHY_ID_INVALID) {
+			if (!eeprom_signature_found ||
+			    !KNOWN_PHY_ID(eeprom_phy_id & PHY_ID_MASK))
+				return -ENODEV;
+			tp->phy_id = eeprom_phy_id;
+		}
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x201f);
+		tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x2aaa);
+	}
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)
+		tp->tg3_flags |= TG3_FLAG_PHY_RESET_ON_INIT;
+
+	if (tp->tg3_flags & TG3_FLAG_PHY_RESET_ON_INIT) {
+		u32 mii_tg3_ctrl;
+
+		err = tg3_phy_reset(tp, 1);
+		if (err)
+			return err;
+
+		/* These chips, when reset, only advertise 10Mb capabilities.
+		 * Fix that.
+		 */
+		err  = tg3_writephy(tp, MII_ADVERTISE,
+				    (ADVERTISE_CSMA |
+				     ADVERTISE_10HALF | ADVERTISE_10FULL |
+				     ADVERTISE_100HALF | ADVERTISE_100FULL));
+		mii_tg3_ctrl = (MII_TG3_CTRL_ADV_1000_HALF |
+				MII_TG3_CTRL_ADV_1000_FULL |
+				MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER);
+		if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+			mii_tg3_ctrl = 0;
+
+		err |= tg3_writephy(tp, MII_TG3_CTRL, mii_tg3_ctrl);
+		err |= tg3_writephy(tp, MII_BMCR,
+				    (BMCR_ANRESTART | BMCR_ANENABLE));
+	}
+
+	if (!err && ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401)) {
+		err = tg3_init_5401phy_dsp(tp);
+	}
+
+	/* Determine the PHY led mode. */
+	if (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL) {
+		tp->led_mode = led_mode_link10;
+	} else {
+		tp->led_mode = led_mode_three_link;
+		if (eeprom_signature_found &&
+		    eeprom_led_mode != led_mode_auto)
+			tp->led_mode = eeprom_led_mode;
+	}
+
+	if (tp->phy_id == PHY_ID_SERDES)
+		tp->link_config.advertising =
+			(ADVERTISED_1000baseT_Half |
+			 ADVERTISED_1000baseT_Full |
+			 ADVERTISED_Autoneg |
+			 ADVERTISED_FIBRE);
+	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+		tp->link_config.advertising &=
+			~(ADVERTISED_1000baseT_Half |
+			  ADVERTISED_1000baseT_Full);
+
+	return err;
+}
+
+static void __devinit tg3_read_partno(struct tg3 *tp)
+{
+	unsigned char vpd_data[256];
+	int i;
+
+	for (i = 0; i < 256; i += 4) {
+		u32 tmp;
+
+		if (tg3_nvram_read(tp, 0x100 + i, &tmp))
+			goto out_not_found;
+
+		vpd_data[i + 0] = ((tmp >>  0) & 0xff);
+		vpd_data[i + 1] = ((tmp >>  8) & 0xff);
+		vpd_data[i + 2] = ((tmp >> 16) & 0xff);
+		vpd_data[i + 3] = ((tmp >> 24) & 0xff);
+	}
+
+	/* Now parse and find the part number. */
+	for (i = 0; i < 256; ) {
+		unsigned char val = vpd_data[i];
+		int block_end;
+
+		if (val == 0x82 || val == 0x91) {
+			i = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+			continue;
+		}
+
+		if (val != 0x90)
+			goto out_not_found;
+
+		block_end = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+		i += 3;
+		while (i < block_end) {
+			if (vpd_data[i + 0] == 'P' &&
+			    vpd_data[i + 1] == 'N') {
+				int partno_len = vpd_data[i + 2];
+
+				if (partno_len > 24)
+					goto out_not_found;
+
+				memcpy(tp->board_part_number,
+				       &vpd_data[i + 3],
+				       partno_len);
+
+				/* Success. */
+				return;
+			}
+		}
+
+		/* Part number not found. */
+		goto out_not_found;
+	}
+
+out_not_found:
+	strcpy(tp->board_part_number, "none");
+}
+
+static int __devinit tg3_get_invariants(struct tg3 *tp)
+{
+	u32 misc_ctrl_reg;
+	u32 cacheline_sz_reg;
+	u32 pci_state_reg, grc_misc_cfg;
+	u16 pci_cmd;
+	int err;
+
+	/* Force memory write invalidate off.  If we leave it on,
+	 * then on 5700_BX chips we have to enable a workaround.
+	 * The workaround is to set the TG3PCI_DMA_RW_CTRL boundry
+	 * to match the cacheline size.  The Broadcom driver have this
+	 * workaround but turns MWI off all the times so never uses
+	 * it.  This seems to suggest that the workaround is insufficient.
+	 */
+	pci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);
+	pci_cmd &= ~PCI_COMMAND_INVALIDATE;
+	pci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);
+
+	pci_read_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			      &misc_ctrl_reg);
+
+	tp->pci_chip_rev_id = (misc_ctrl_reg >>
+			       MISC_HOST_CTRL_CHIPREV_SHIFT);
+
+	pci_read_config_dword(tp->pdev, TG3PCI_CACHELINESZ,
+			      &cacheline_sz_reg);
+
+	tp->pci_cacheline_sz = (cacheline_sz_reg >>  0) & 0xff;
+	tp->pci_lat_timer    = (cacheline_sz_reg >>  8) & 0xff;
+	tp->pci_hdr_type     = (cacheline_sz_reg >> 16) & 0xff;
+	tp->pci_bist         = (cacheline_sz_reg >> 24) & 0xff;
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703 &&
+	    tp->pci_lat_timer < 64) {
+		tp->pci_lat_timer = 64;
+
+		cacheline_sz_reg  = ((tp->pci_cacheline_sz & 0xff) <<  0);
+		cacheline_sz_reg |= ((tp->pci_lat_timer    & 0xff) <<  8);
+		cacheline_sz_reg |= ((tp->pci_hdr_type     & 0xff) << 16);
+		cacheline_sz_reg |= ((tp->pci_bist         & 0xff) << 24);
+
+		pci_write_config_dword(tp->pdev, TG3PCI_CACHELINESZ,
+				       cacheline_sz_reg);
+	}
+
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,
+			      &pci_state_reg);
+
+	if ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0) {
+		tp->tg3_flags |= TG3_FLAG_PCIX_MODE;
+
+		/* If this is a 5700 BX chipset, and we are in PCI-X
+		 * mode, enable register write workaround.
+		 *
+		 * The workaround is to use indirect register accesses
+		 * for all chip writes not to mailbox registers.
+		 */
+		if (GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5700_BX) {
+			u32 pm_reg;
+			u16 pci_cmd;
+
+			tp->tg3_flags |= TG3_FLAG_PCIX_TARGET_HWBUG;
+
+			/* The chip can have it's power management PCI config
+			 * space registers clobbered due to this bug.
+			 * So explicitly force the chip into D0 here.
+			 */
+			pci_read_config_dword(tp->pdev, TG3PCI_PM_CTRL_STAT,
+					      &pm_reg);
+			pm_reg &= ~PCI_PM_CTRL_STATE_MASK;
+			pm_reg |= PCI_PM_CTRL_PME_ENABLE | 0 /* D0 */;
+			pci_write_config_dword(tp->pdev, TG3PCI_PM_CTRL_STAT,
+					       pm_reg);
+
+			/* Also, force SERR#/PERR# in PCI command. */
+			pci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);
+			pci_cmd |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+			pci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);
+		}
+	}
+	if ((pci_state_reg & PCISTATE_BUS_SPEED_HIGH) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_HIGH_SPEED;
+	if ((pci_state_reg & PCISTATE_BUS_32BIT) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_32BIT;
+
+	/* Force the chip into D0. */
+	err = tg3_set_power_state(tp, 0);
+	if (err)
+		return err;
+
+	/* 5700 B0 chips do not support checksumming correctly due
+	 * to hardware bugs.
+	 */
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5700_B0)
+		tp->tg3_flags |= TG3_FLAG_BROKEN_CHECKSUMS;
+
+	/* Regardless of whether checksums work or not, we configure
+	 * the StrongARM chips to not compute the pseudo header checksums
+	 * in either direction.  Because of the way Linux checksum support
+	 * works we do not need the chips to do this, and taking the load
+	 * off of the TX/RX onboard StrongARM cpus means that they will not be
+	 * the bottleneck.  Whoever wrote Broadcom's driver did not
+	 * understand the situation at all.  He could have bothered
+	 * to read Jes's Acenic driver because the logic (and this part of
+	 * the Tigon2 hardware/firmware) is pretty much identical.
+	 */
+	tp->tg3_flags |= TG3_FLAG_NO_TX_PSEUDO_CSUM;
+	tp->tg3_flags |= TG3_FLAG_NO_RX_PSEUDO_CSUM;
+
+	/* Derive initial jumbo mode from MTU assigned in
+	 * ether_setup() via the alloc_etherdev() call
+	 */
+	if (tp->dev->mtu > ETH_DATA_LEN)
+		tp->tg3_flags |= TG3_FLAG_JUMBO_ENABLE;
+
+	/* Determine WakeOnLan speed to use. */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B2) {
+		tp->tg3_flags &= ~(TG3_FLAG_WOL_SPEED_100MB);
+	} else {
+		tp->tg3_flags |= TG3_FLAG_WOL_SPEED_100MB;
+	}
+
+	/* Only 5701 and later support tagged irq status mode. */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700) {
+		tp->tg3_flags |= TG3_FLAG_TAGGED_IRQ_STATUS;
+		tp->misc_host_ctrl |= MISC_HOST_CTRL_TAGGED_STATUS;
+
+		/* ??? Due to a glitch Broadcom's driver ALWAYS sets
+		 * ??? these bits in coalesce_mode.  Because MM_GetConfig
+		 * ??? always sets pDevice->UseTaggedStatus correctly
+		 * ??? the following test at tigon3.c:LM_GetAdapterInfo()
+		 * ???
+		 * ???   pDevice->UseTaggedStatus &&
+		 * ???   (pDevice->ChipRevId == T3_CHIP_ID_5700_C0 ||
+		 * ???    T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_AX ||
+		 * ???    T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+		 * ???
+		 * ??? will never pass and thus pDevice->CoalesceMode will never
+		 * ??? get set to zero.  For now I'll mirror what I believe is
+		 * ??? the intention of their driver.
+		 * ???
+		 * ??? Update: This is fixed in Broadcom's 2.2.3 and later
+		 * ???         drivers.  All the current 2.0.x drivers still
+		 * ???         have the bug.
+		 */
+		tp->coalesce_mode = (HOSTCC_MODE_CLRTICK_RXBD |
+				     HOSTCC_MODE_CLRTICK_TXBD);
+	} else {
+		tp->coalesce_mode = 0;
+
+		/* If not using tagged status, set the *_during_int
+		 * coalesce default config values to zero.
+		 */
+		tp->coalesce_config.rx_coalesce_ticks_during_int_def = 0;
+		tp->coalesce_config.rx_max_coalesced_frames_during_int_def = 0;
+		tp->coalesce_config.tx_coalesce_ticks_during_int_def = 0;
+		tp->coalesce_config.tx_max_coalesced_frames_during_int_def = 0;
+	}
+
+	if (GET_CHIP_REV(tp->pci_chip_rev_id) != CHIPREV_5700_AX &&
+	    GET_CHIP_REV(tp->pci_chip_rev_id) != CHIPREV_5700_BX)
+		tp->coalesce_mode |= HOSTCC_MODE_32BYTE;
+
+	/* Initialize misc host control in PCI block. */
+	tp->misc_host_ctrl |= (misc_ctrl_reg &
+			       MISC_HOST_CTRL_CHIPREV);
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	/* Initialize MAC MI mode, polling disabled. */
+	tw32(MAC_MI_MODE, tp->mi_mode);
+	udelay(40);
+
+	/* Initialize data/descriptor byte/word swapping. */
+	tw32(GRC_MODE, tp->grc_mode);
+
+	/* Clear these out for sanity. */
+	tw32(TG3PCI_CLOCK_CTRL, 0);
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,
+			      &pci_state_reg);
+	if ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_TARGET_HWBUG) == 0) {
+		u32 chiprevid = GET_CHIP_REV_ID(tp->misc_host_ctrl);
+
+		if (chiprevid == CHIPREV_ID_5701_A0 ||
+		    chiprevid == CHIPREV_ID_5701_B0 ||
+		    chiprevid == CHIPREV_ID_5701_B2 ||
+		    chiprevid == CHIPREV_ID_5701_B5) {
+			unsigned long sram_base;
+
+			/* Write some dummy words into the SRAM status block
+			 * area, see if it reads back correctly.  If the return
+			 * value is bad, force enable the PCIX workaround.
+			 */
+			sram_base = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_STATS_BLK;
+
+			writel(0x00000000, sram_base);
+			writel(0x00000000, sram_base + 4);
+			writel(0xffffffff, sram_base + 4);
+			if (readl(sram_base) != 0x00000000)
+				tp->tg3_flags |= TG3_FLAG_PCIX_TARGET_HWBUG;
+		}
+	}
+
+	udelay(50);
+	tg3_nvram_init(tp);
+
+	/* Determine if TX descriptors will reside in
+	 * main memory or in the chip SRAM.
+	 */
+	if (tp->tg3_flags & TG3_FLAG_PCIX_TARGET_HWBUG)
+		tp->tg3_flags |= TG3_FLAG_HOST_TXDS;
+
+	/* Quick sanity check.  Make sure we see an expected
+	 * value here.
+	 */
+	grc_misc_cfg = tr32(GRC_MISC_CFG);
+	grc_misc_cfg &= GRC_MISC_CFG_BOARD_ID_MASK;
+	if (grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5700 &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5701 &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5702FE &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5703 &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5703S)
+		return -ENODEV;
+
+	/* ROFL, you should see Broadcom's driver code implementing
+	 * this, stuff like "if (a || b)" where a and b are always
+	 * mutually exclusive.  DaveM finds like 6 bugs today, hello!
+	 */
+	if (grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5702FE)
+		tp->tg3_flags |= TG3_FLAG_10_100_ONLY;
+
+	err = tg3_phy_probe(tp);
+
+	tg3_read_partno(tp);
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->tg3_flags &= ~TG3_FLAG_USE_MI_INTERRUPT;
+
+		/* And override led_mode in case Dell ever makes
+		 * a fibre board.
+		 */
+		tp->led_mode = led_mode_three_link;
+	} else {
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700)
+			tp->tg3_flags |= TG3_FLAG_USE_MI_INTERRUPT;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_USE_MI_INTERRUPT;
+	}
+
+	/* 5700 {AX,BX} chips have a broken status block link
+	 * change bit implementation, so we must use the
+	 * status register in those cases.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700)
+		tp->tg3_flags |= TG3_FLAG_USE_LINKCHG_REG;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_USE_LINKCHG_REG;
+
+	/* The led_mode is set during tg3_phy_probe, here we might
+	 * have to force the link status polling mechanism based
+	 * upon subsystem IDs.
+	 */
+	if (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&
+	    tp->phy_id != PHY_ID_SERDES) {
+		tp->tg3_flags |= (TG3_FLAG_USE_MI_INTERRUPT |
+				  TG3_FLAG_USE_LINKCHG_REG);
+	}
+
+	/* 5700 BX chips need to have their TX producer index mailboxes
+	 * written twice to workaround a bug.
+	 */
+	if (GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5700_BX)
+		tp->tg3_flags |= TG3_FLAG_TXD_MBOX_HWBUG;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_TXD_MBOX_HWBUG;
+
+	/* 5700 chips can get confused if TX buffers straddle the
+	 * 4GB address boundary in some cases.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) {
+		/* ROFL!  Latest Broadcom driver disables NETIF_F_HIGHDMA
+		 * in this case instead of fixing their workaround code.
+		 *
+		 * Like, hey, there is this skb_copy() thing guys,
+		 * use it.  Oh I can't stop laughing...
+		 */
+		tp->dev->hard_start_xmit = tg3_start_xmit_4gbug;
+	} else {
+		tp->dev->hard_start_xmit = tg3_start_xmit;
+	}
+
+	tp->rx_offset = 2;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE) != 0)
+		tp->rx_offset = 0;
+
+	return err;
+}
+
+static int __devinit tg3_get_device_address(struct tg3 *tp)
+{
+	struct net_device *dev = tp->dev;
+	u32 hi, lo;
+
+	/* First try to get it from MAC address mailbox. */
+	tg3_read_mem(tp, NIC_SRAM_MAC_ADDR_HIGH_MBOX, &hi);
+	if ((hi >> 16) == 0x484b) {
+		dev->dev_addr[0] = (hi >>  8) & 0xff;
+		dev->dev_addr[1] = (hi >>  0) & 0xff;
+
+		tg3_read_mem(tp, NIC_SRAM_MAC_ADDR_LOW_MBOX, &lo);
+		dev->dev_addr[2] = (lo >> 24) & 0xff;
+		dev->dev_addr[3] = (lo >> 16) & 0xff;
+		dev->dev_addr[4] = (lo >>  8) & 0xff;
+		dev->dev_addr[5] = (lo >>  0) & 0xff;
+	}
+	/* Next, try NVRAM. */
+	else if (!tg3_nvram_read(tp, 0x7c, &hi) &&
+		 !tg3_nvram_read(tp, 0x80, &lo)) {
+		dev->dev_addr[0] = ((hi >> 16) & 0xff);
+		dev->dev_addr[1] = ((hi >> 24) & 0xff);
+		dev->dev_addr[2] = ((lo >>  0) & 0xff);
+		dev->dev_addr[3] = ((lo >>  8) & 0xff);
+		dev->dev_addr[4] = ((lo >> 16) & 0xff);
+		dev->dev_addr[5] = ((lo >> 24) & 0xff);
+	}
+	/* Finally just fetch it out of the MAC control regs. */
+	else {
+		hi = tr32(MAC_ADDR_0_HIGH);
+		lo = tr32(MAC_ADDR_0_LOW);
+
+		dev->dev_addr[5] = lo & 0xff;
+		dev->dev_addr[4] = (lo >> 8) & 0xff;
+		dev->dev_addr[3] = (lo >> 16) & 0xff;
+		dev->dev_addr[2] = (lo >> 24) & 0xff;
+		dev->dev_addr[1] = hi & 0xff;
+		dev->dev_addr[0] = (hi >> 8) & 0xff;
+	}
+
+	if (!is_valid_ether_addr(&dev->dev_addr[0]))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int __devinit tg3_do_test_dma(struct tg3 *tp, u32 *buf, dma_addr_t buf_dma, int size, int to_device)
+{
+	struct tg3_internal_buffer_desc test_desc;
+	u32 sram_dma_descs;
+	int i, ret;
+
+	sram_dma_descs = NIC_SRAM_DMA_DESC_POOL_BASE;
+
+	tw32(FTQ_RCVBD_COMP_FIFO_ENQDEQ, 0);
+	tw32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ, 0);
+	tw32(RDMAC_STATUS, 0);
+	tw32(WDMAC_STATUS, 0);
+
+	tw32(BUFMGR_MODE, 0);
+	tw32(FTQ_RESET, 0);
+
+	/* pci_alloc_consistent gives only non-DAC addresses */
+	test_desc.addr_hi = 0;
+	test_desc.addr_lo = buf_dma & 0xffffffff;
+	test_desc.nic_mbuf = 0x00002100;
+	test_desc.len = size;
+	if (to_device) {
+		test_desc.cqid_sqid = (13 << 8) | 2;
+		tw32(RDMAC_MODE, RDMAC_MODE_RESET);
+		tw32(RDMAC_MODE, RDMAC_MODE_ENABLE);
+	} else {
+		test_desc.cqid_sqid = (16 << 8) | 7;
+		tw32(WDMAC_MODE, WDMAC_MODE_RESET);
+		tw32(WDMAC_MODE, WDMAC_MODE_ENABLE);
+	}
+	test_desc.flags = 0x00000004;
+
+	for (i = 0; i < (sizeof(test_desc) / sizeof(u32)); i++) {
+		u32 val;
+
+		val = *(((u32 *)&test_desc) + i);
+		pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR,
+				       sram_dma_descs + (i * sizeof(u32)));
+		pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);
+	}
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	if (to_device) {
+		tw32(FTQ_DMA_HIGH_READ_FIFO_ENQDEQ, sram_dma_descs);
+	} else {
+		tw32(FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ, sram_dma_descs);
+	}
+
+	ret = -ENODEV;
+	for (i = 0; i < 40; i++) {
+		u32 val;
+
+		if (to_device)
+			val = tr32(FTQ_RCVBD_COMP_FIFO_ENQDEQ);
+		else
+			val = tr32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ);
+		if ((val & 0xffff) == sram_dma_descs) {
+			ret = 0;
+			break;
+		}
+
+		udelay(100);
+	}
+
+	return ret;
+}
+
+#define TEST_BUFFER_SIZE	0x400
+
+static int __devinit tg3_test_dma(struct tg3 *tp)
+{
+	dma_addr_t buf_dma;
+	u32 *buf;
+	int ret;
+
+	buf = pci_alloc_consistent(tp->pdev, TEST_BUFFER_SIZE, &buf_dma);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto out_nofree;
+	}
+
+	tw32(TG3PCI_CLOCK_CTRL, 0);
+
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) == 0) {
+		tp->dma_rwctrl =
+			(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+			(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+			(0x7 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+			(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+			(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+	} else {
+		tp->dma_rwctrl =
+			(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+			(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+			(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+			(0x3 << DMA_RWCTRL_READ_WATER_SHIFT) |
+			(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+
+		/* Wheee, some more chip bugs... */
+		if (tp->pci_chip_rev_id == CHIPREV_ID_5703_A1 ||
+		    tp->pci_chip_rev_id == CHIPREV_ID_5703_A2)
+			tp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;
+	}
+
+	/* We don't do this on x86 because it seems to hurt performace.
+	 * It does help things on other platforms though.
+	 */
+#ifndef CONFIG_X86
+	{
+		u8 byte;
+		int cacheline_size;
+		pci_read_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE, &byte);
+
+		if (byte == 0)
+			cacheline_size = 1024;
+		else
+			cacheline_size = (int) byte * 4;
+
+		tp->dma_rwctrl &= ~(DMA_RWCTRL_READ_BNDRY_MASK |
+				    DMA_RWCTRL_WRITE_BNDRY_MASK);
+
+		switch (cacheline_size) {
+		case 16:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_16 |
+				 DMA_RWCTRL_WRITE_BNDRY_16);
+			break;
+
+		case 32:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_32 |
+				 DMA_RWCTRL_WRITE_BNDRY_32);
+			break;
+
+		case 64:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_64 |
+				 DMA_RWCTRL_WRITE_BNDRY_64);
+			break;
+
+		case 128:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_128 |
+				 DMA_RWCTRL_WRITE_BNDRY_128);
+			break;
+
+		case 256:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_256 |
+				 DMA_RWCTRL_WRITE_BNDRY_256);
+			break;
+
+		case 512:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_512 |
+				 DMA_RWCTRL_WRITE_BNDRY_512);
+			break;
+
+		case 1024:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_1024 |
+				 DMA_RWCTRL_WRITE_BNDRY_1024);
+			break;
+		};
+	}
+#endif
+
+	/* Remove this if it causes problems for some boards. */
+	tp->dma_rwctrl |= DMA_RWCTRL_USE_MEM_READ_MULT;
+
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700 &&
+	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701)
+		return 0;
+
+	ret = 0;
+	while (1) {
+		u32 *p, i;
+
+		p = buf;
+		for (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++)
+			p[i] = i;
+
+		/* Send the buffer to the chip. */
+		ret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, 1);
+		if (ret)
+			break;
+
+		p = buf;
+		for (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++)
+			p[i] = 0;
+
+		/* Now read it back. */
+		ret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, 0);
+		if (ret)
+			break;
+
+		/* Verify it. */
+		p = buf;
+		for (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++) {
+			if (p[i] == i)
+				continue;
+
+			if ((tp->dma_rwctrl & DMA_RWCTRL_WRITE_BNDRY_MASK) ==
+			    DMA_RWCTRL_WRITE_BNDRY_DISAB) {
+				tp->dma_rwctrl |= DMA_RWCTRL_WRITE_BNDRY_16;
+				tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+				break;
+			} else {
+				ret = -ENODEV;
+				goto out;
+			}
+		}
+
+		if (i == (TEST_BUFFER_SIZE / sizeof(u32))) {
+			/* Success. */
+			ret = 0;
+			break;
+		}
+	}
+
+out:
+	pci_free_consistent(tp->pdev, TEST_BUFFER_SIZE, buf, buf_dma);
+out_nofree:
+	return ret;
+}
+
+static void __devinit tg3_init_link_config(struct tg3 *tp)
+{
+	tp->link_config.advertising =
+		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+		 ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+		 ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+		 ADVERTISED_Autoneg | ADVERTISED_MII);
+	tp->link_config.speed = SPEED_INVALID;
+	tp->link_config.duplex = DUPLEX_INVALID;
+	tp->link_config.autoneg = AUTONEG_ENABLE;
+	netif_carrier_off(tp->dev);
+	tp->link_config.active_speed = SPEED_INVALID;
+	tp->link_config.active_duplex = DUPLEX_INVALID;
+	tp->link_config.phy_is_low_power = 0;
+	tp->link_config.orig_speed = SPEED_INVALID;
+	tp->link_config.orig_duplex = DUPLEX_INVALID;
+	tp->link_config.orig_autoneg = AUTONEG_INVALID;
+}
+
+static void __devinit tg3_init_coalesce_config(struct tg3 *tp)
+{
+	tp->coalesce_config.rx_coalesce_ticks_def = DEFAULT_RXCOL_TICKS;
+	tp->coalesce_config.rx_max_coalesced_frames_def = DEFAULT_RXMAX_FRAMES;
+	tp->coalesce_config.rx_coalesce_ticks_during_int_def =
+		DEFAULT_RXCOAL_TICK_INT;
+	tp->coalesce_config.rx_max_coalesced_frames_during_int_def =
+		DEFAULT_RXCOAL_MAXF_INT;
+	tp->coalesce_config.tx_coalesce_ticks_def = DEFAULT_TXCOL_TICKS;
+	tp->coalesce_config.tx_max_coalesced_frames_def = DEFAULT_TXMAX_FRAMES;
+	tp->coalesce_config.tx_coalesce_ticks_during_int_def =
+		DEFAULT_TXCOAL_TICK_INT;
+	tp->coalesce_config.tx_max_coalesced_frames_during_int_def =
+		DEFAULT_TXCOAL_MAXF_INT;
+	tp->coalesce_config.stats_coalesce_ticks_def =
+		DEFAULT_STAT_COAL_TICKS;
+
+	tp->coalesce_config.rx_coalesce_ticks_low =
+		LOW_RXCOL_TICKS;
+	tp->coalesce_config.rx_max_coalesced_frames_low =
+		LOW_RXMAX_FRAMES;
+	tp->coalesce_config.tx_coalesce_ticks_low =
+		LOW_TXCOL_TICKS;
+	tp->coalesce_config.tx_max_coalesced_frames_low =
+		LOW_TXMAX_FRAMES;
+
+	tp->coalesce_config.rx_coalesce_ticks_high =
+		HIGH_RXCOL_TICKS;
+	tp->coalesce_config.rx_max_coalesced_frames_high =
+		HIGH_RXMAX_FRAMES;
+	tp->coalesce_config.tx_coalesce_ticks_high =
+		HIGH_TXCOL_TICKS;
+	tp->coalesce_config.tx_max_coalesced_frames_high =
+		HIGH_TXMAX_FRAMES;
+
+	/* Active == default */
+	tp->coalesce_config.rx_coalesce_ticks =
+		tp->coalesce_config.rx_coalesce_ticks_def;
+	tp->coalesce_config.rx_max_coalesced_frames =
+		tp->coalesce_config.rx_max_coalesced_frames_def;
+	tp->coalesce_config.tx_coalesce_ticks =
+		tp->coalesce_config.tx_coalesce_ticks_def;
+	tp->coalesce_config.tx_max_coalesced_frames =
+		tp->coalesce_config.tx_max_coalesced_frames_def;
+	tp->coalesce_config.stats_coalesce_ticks =
+		tp->coalesce_config.stats_coalesce_ticks_def;
+
+	tp->coalesce_config.rate_sample_jiffies = (1 * HZ);
+	tp->coalesce_config.pkt_rate_low = 22000;
+	tp->coalesce_config.pkt_rate_high = 61000;
+
+	tp->tg3_flags |= TG3_FLAG_ADAPTIVE_RX;
+	tp->tg3_flags &= ~(TG3_FLAG_ADAPTIVE_TX);
+}
+
+static void __devinit tg3_init_bufmgr_config(struct tg3 *tp)
+{
+	tp->bufmgr_config.mbuf_read_dma_low_water =
+		DEFAULT_MB_RDMA_LOW_WATER;
+	tp->bufmgr_config.mbuf_mac_rx_low_water =
+		DEFAULT_MB_MACRX_LOW_WATER;
+	tp->bufmgr_config.mbuf_high_water =
+		DEFAULT_MB_HIGH_WATER;
+
+	tp->bufmgr_config.mbuf_read_dma_low_water_jumbo =
+		DEFAULT_MB_RDMA_LOW_WATER_JUMBO;
+	tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =
+		DEFAULT_MB_MACRX_LOW_WATER_JUMBO;
+	tp->bufmgr_config.mbuf_high_water_jumbo =
+		DEFAULT_MB_HIGH_WATER_JUMBO;
+
+	tp->bufmgr_config.dma_low_water = DEFAULT_DMA_LOW_WATER;
+	tp->bufmgr_config.dma_high_water = DEFAULT_DMA_HIGH_WATER;
+}
+
+static char * __devinit tg3_phy_string(struct tg3 *tp)
+{
+	switch (tp->phy_id & PHY_ID_MASK) {
+	case PHY_ID_BCM5400:	return "5400";
+	case PHY_ID_BCM5401:	return "5401";
+	case PHY_ID_BCM5411:	return "5411";
+	case PHY_ID_BCM5701:	return "5701";
+	case PHY_ID_BCM5703:	return "5703";
+	case PHY_ID_BCM8002:	return "8002";
+	case PHY_ID_SERDES:	return "serdes";
+	default:		return "unknown";
+	};
+}
+
+static int __devinit tg3_init_one(struct pci_dev *pdev,
+				  const struct pci_device_id *ent)
+{
+	static int tg3_version_printed = 0;
+	unsigned long tg3reg_base, tg3reg_len;
+	struct net_device *dev;
+	struct tg3 *tp;
+	int i, err, pci_using_dac, pm_cap;
+
+	if (tg3_version_printed++ == 0)
+		printk(KERN_INFO "%s", version);
+
+	err = pci_enable_device(pdev);
+	if (err) {
+		printk(KERN_ERR PFX "Cannot enable PCI device, "
+		       "aborting.\n");
+		return err;
+	}
+
+	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
+		printk(KERN_ERR PFX "Cannot find proper PCI device "
+		       "base address, aborting.\n");
+		err = -ENODEV;
+		goto err_out_disable_pdev;
+	}
+
+	err = pci_request_regions(pdev, DRV_MODULE_NAME);
+	if (err) {
+		printk(KERN_ERR PFX "Cannot obtain PCI resources, "
+		       "aborting.\n");
+		goto err_out_disable_pdev;
+	}
+
+	pci_set_master(pdev);
+
+	/* Find power-management capability. */
+	pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+	if (pm_cap == 0) {
+		printk(KERN_ERR PFX "Cannot find PowerManagement capability, "
+		       "aborting.\n");
+		goto err_out_free_res;
+	}
+
+	/* Configure DMA attributes. */
+	if (!pci_set_dma_mask(pdev, (u64) 0xffffffffffffffff)) {
+		pci_using_dac = 1;
+	} else
+	{
+		err = pci_set_dma_mask(pdev, (u64) 0xffffffff);
+		if (err) {
+			printk(KERN_ERR PFX "No usable DMA configuration, "
+			       "aborting.\n");
+			goto err_out_free_res;
+		}
+		pci_using_dac = 0;
+	}
+
+	tg3reg_base = pci_resource_start(pdev, 0);
+	tg3reg_len = pci_resource_len(pdev, 0);
+
+	dev = alloc_etherdev(sizeof(*tp));
+	if (!dev) {
+		printk(KERN_ERR PFX "Etherdev alloc failed, aborting.\n");
+		err = -ENOMEM;
+		goto err_out_free_res;
+	}
+
+	SET_MODULE_OWNER(dev);
+
+	if (pci_using_dac)
+		dev->features |= NETIF_F_HIGHDMA;
+#if TG3_VLAN_TAG_USED
+	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+	dev->vlan_rx_register = tg3_vlan_rx_register;
+	dev->vlan_rx_kill_vid = tg3_vlan_rx_kill_vid;
+#endif
+
+	tp = dev->priv;
+	tp->pdev = pdev;
+	tp->dev = dev;
+	tp->pm_cap = pm_cap;
+	tp->mac_mode = TG3_DEF_MAC_MODE;
+	tp->rx_mode = TG3_DEF_RX_MODE;
+	tp->tx_mode = TG3_DEF_TX_MODE;
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	if (tg3_debug > 0)
+		tp->msg_enable = tg3_debug;
+	else
+		tp->msg_enable = TG3_DEF_MSG_ENABLE;
+
+	/* The word/byte swap controls here control register access byte
+	 * swapping.  DMA data byte swapping is controlled in the GRC_MODE
+	 * setting below.
+	 */
+	tp->misc_host_ctrl =
+		MISC_HOST_CTRL_MASK_PCI_INT |
+		MISC_HOST_CTRL_WORD_SWAP |
+		MISC_HOST_CTRL_INDIR_ACCESS |
+		MISC_HOST_CTRL_PCISTATE_RW;
+
+	/* The NONFRM (non-frame) byte/word swap controls take effect
+	 * on descriptor entries, anything which isn't packet data.
+	 *
+	 * The StrongARM chips on the board (one for tx, one for rx)
+	 * are running in big-endian mode.
+	 */
+	tp->grc_mode = (GRC_MODE_WSWAP_DATA | GRC_MODE_BSWAP_DATA |
+			GRC_MODE_WSWAP_NONFRM_DATA);
+#ifdef __BIG_ENDIAN
+	tp->grc_mode |= GRC_MODE_BSWAP_NONFRM_DATA;
+#endif
+	spin_lock_init(&tp->lock);
+	spin_lock_init(&tp->indirect_lock);
+
+	tp->regs = (unsigned long) ioremap(tg3reg_base, tg3reg_len);
+	if (tp->regs == 0UL) {
+		printk(KERN_ERR PFX "Cannot map device registers, "
+		       "aborting.\n");
+		err = -ENOMEM;
+		goto err_out_free_dev;
+	}
+
+	tg3_init_link_config(tp);
+
+	tg3_init_coalesce_config(tp);
+
+	tg3_init_bufmgr_config(tp);
+
+	tp->rx_pending = TG3_DEF_RX_RING_PENDING;
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini_pending = TG3_DEF_RX_MINI_RING_PENDING;
+#endif
+	tp->rx_jumbo_pending = TG3_DEF_RX_JUMBO_RING_PENDING;
+	tp->tx_pending = TG3_DEF_TX_RING_PENDING;
+
+	dev->open = tg3_open;
+	dev->stop = tg3_close;
+	dev->get_stats = tg3_get_stats;
+	dev->set_multicast_list = tg3_set_rx_mode;
+	dev->set_mac_address = tg3_set_mac_addr;
+	dev->do_ioctl = tg3_ioctl;
+	dev->tx_timeout = tg3_tx_timeout;
+	dev->watchdog_timeo = TG3_TX_TIMEOUT;
+	dev->change_mtu = tg3_change_mtu;
+	dev->irq = pdev->irq;
+
+	err = tg3_get_invariants(tp);
+	if (err) {
+		printk(KERN_ERR PFX "Problem fetching invariants of chip, "
+		       "aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	err = tg3_get_device_address(tp);
+	if (err) {
+		printk(KERN_ERR PFX "Could not obtain valid ethernet address, "
+		       "aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	err = tg3_test_dma(tp);
+	if (err) {
+		printk(KERN_ERR PFX "DMA engine test failed, aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	/* Tigon3 can do ipv4 only... and some chips have buggy
+	 * checksumming.
+	 */
+	if ((tp->tg3_flags & TG3_FLAG_BROKEN_CHECKSUMS) == 0) {
+		dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+		tp->tg3_flags |= TG3_FLAG_RX_CHECKSUMS;
+	} else
+		tp->tg3_flags &= ~TG3_FLAG_RX_CHECKSUMS;
+
+	err = register_netdev(dev);
+	if (err) {
+		printk(KERN_ERR PFX "Cannot register net device, "
+		       "aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	pci_set_drvdata(pdev, dev);
+
+	/* Now that we have fully setup the chip, save away a snapshot
+	 * of the PCI config space.  We need to restore this after
+	 * GRC_MISC_CFG core clock resets and some resume events.
+	 */
+	pci_save_state(tp->pdev, tp->pci_cfg_state);
+
+	printk(KERN_INFO "%s: Tigon3 [partno(%s) rev %04x PHY(%s)] (PCI%s:%s:%s) %sBaseT Ethernet ",
+	       dev->name,
+	       tp->board_part_number,
+	       tp->pci_chip_rev_id,
+	       tg3_phy_string(tp),
+	       ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "X" : ""),
+	       ((tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED) ?
+		((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "133MHz" : "66MHz") :
+		((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "100MHz" : "33MHz")),
+	       ((tp->tg3_flags & TG3_FLAG_PCI_32BIT) ? "32-bit" : "64-bit"),
+	       (tp->tg3_flags & TG3_FLAG_10_100_ONLY) ? "10/100" : "10/100/1000");
+
+	for (i = 0; i < 6; i++)
+		printk("%2.2x%c", dev->dev_addr[i],
+		       i == 5 ? '\n' : ':');
+
+	return 0;
+
+err_out_iounmap:
+	iounmap((void *) tp->regs);
+
+err_out_free_dev:
+	kfree(dev);
+
+err_out_free_res:
+	pci_release_regions(pdev);
+
+err_out_disable_pdev:
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	return err;
+}
+
+static void __devexit tg3_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+
+	if (dev) {
+		unregister_netdev(dev);
+		iounmap((void *) ((struct tg3 *)(dev->priv))->regs);
+		kfree(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
+}
+
+static int tg3_suspend(struct pci_dev *pdev, u32 state)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	if (!netif_running(dev))
+		return 0;
+
+	spin_lock_irq(&tp->lock);
+	tg3_disable_ints(tp);
+	spin_unlock_irq(&tp->lock);
+
+	netif_device_detach(dev);
+
+	spin_lock_irq(&tp->lock);
+	tg3_halt(tp);
+	spin_unlock_irq(&tp->lock);
+
+	err = tg3_set_power_state(tp, state);
+	if (err) {
+		spin_lock_irq(&tp->lock);
+
+		tg3_init_rings(tp);
+		tg3_init_hw(tp);
+
+		spin_unlock_irq(&tp->lock);
+
+		netif_device_attach(dev);
+	}
+
+	return err;
+}
+
+static int tg3_resume(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	if (!netif_running(dev))
+		return 0;
+
+	err = tg3_set_power_state(tp, 0);
+	if (err)
+		return err;
+
+	netif_device_attach(dev);
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_init_rings(tp);
+	tg3_init_hw(tp);
+	tg3_enable_ints(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+static struct pci_driver tg3_driver = {
+	name:		DRV_MODULE_NAME,
+	id_table:	tg3_pci_tbl,
+	probe:		tg3_init_one,
+	remove:		__devexit_p(tg3_remove_one),
+	suspend:	tg3_suspend,
+	resume:		tg3_resume
+};
+
+static int __init tg3_init(void)
+{
+	return pci_module_init(&tg3_driver);
+}
+
+static void __exit tg3_cleanup(void)
+{
+	pci_unregister_driver(&tg3_driver);
+}
+
+module_init(tg3_init);
+module_exit(tg3_cleanup);
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/tg3.h linux/drivers/net/tg3.h
--- ../prev/linux/drivers/net/tg3.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/tg3.h	Thu Apr 11 17:37:03 2002
@@ -0,0 +1,1905 @@
+/* $Id: tg3.h,v 1.37.2.32 2002/03/11 12:18:18 davem Exp $
+ * tg3.h: Definitions for Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001 Jeff Garzik (jgarzik@mandrakesoft.com)
+ */
+
+#ifndef _T3_H
+#define _T3_H
+
+#if (LINUX_VERSION_CODE < 0x020412)
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME) dma_addr_t ADDR_NAME;
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME) __u32 LEN_NAME;
+#define pci_unmap_addr(PTR, ADDR_NAME)  ((PTR)->ADDR_NAME)
+#define pci_unmap_len(PTR, LEN_NAME)    ((PTR)->LEN_NAME)
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL) (((PTR)->ADDR_NAME) = (VAL))
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL) (((PTR)->LEN_NAME) = (VAL))
+#endif
+
+
+#define TG3_64BIT_REG_HIGH		0x00UL
+#define TG3_64BIT_REG_LOW		0x04UL
+
+/* Descriptor block info. */
+#define TG3_BDINFO_HOST_ADDR		0x0UL /* 64-bit */
+#define TG3_BDINFO_MAXLEN_FLAGS		0x8UL /* 32-bit */
+#define  BDINFO_FLAGS_USE_EXT_RECV	 0x00000001 /* ext rx_buffer_desc */
+#define  BDINFO_FLAGS_DISABLED		 0x00000002
+#define  BDINFO_FLAGS_MAXLEN_MASK	 0xffff0000
+#define  BDINFO_FLAGS_MAXLEN_SHIFT	 16
+#define TG3_BDINFO_NIC_ADDR		0xcUL /* 32-bit */
+#define TG3_BDINFO_SIZE			0x10UL
+
+#define RX_COPY_THRESHOLD  		256
+
+#define RX_STD_MAX_SIZE			1536
+#define RX_JUMBO_MAX_SIZE		0xdeadbeef /* XXX */
+#if TG3_MINI_RING_WORKS
+#define RX_MINI_MAX_SIZE		256
+#endif
+
+/* First 256 bytes are a mirror of PCI config space. */
+#define TG3PCI_VENDOR			0x00000000
+#define  TG3PCI_VENDOR_BROADCOM		 0x14e4
+#define TG3PCI_DEVICE			0x00000002
+#define  TG3PCI_DEVICE_TIGON3_1		 0x1644 /* BCM5700 */
+#define  TG3PCI_DEVICE_TIGON3_2		 0x1645 /* BCM5701 */
+#define  TG3PCI_DEVICE_TIGON3_3		 0x1646 /* BCM5702 */
+#define  TG3PCI_DEVICE_TIGON3_4		 0x1647 /* BCM5703 */
+#define TG3PCI_COMMAND			0x00000004
+#define TG3PCI_STATUS			0x00000006
+#define TG3PCI_CCREVID			0x00000008
+#define TG3PCI_CACHELINESZ		0x0000000c
+#define TG3PCI_LATTIMER			0x0000000d
+#define TG3PCI_HEADERTYPE		0x0000000e
+#define TG3PCI_BIST			0x0000000f
+#define TG3PCI_BASE0_LOW		0x00000010
+#define TG3PCI_BASE0_HIGH		0x00000014
+/* 0x18 --> 0x2c unused */
+#define TG3PCI_SUBSYSVENID		0x0000002c
+#define TG3PCI_SUBSYSID			0x0000002e
+#define TG3PCI_ROMADDR			0x00000030
+#define TG3PCI_CAPLIST			0x00000034
+/* 0x35 --> 0x3c unused */
+#define TG3PCI_IRQ_LINE			0x0000003c
+#define TG3PCI_IRQ_PIN			0x0000003d
+#define TG3PCI_MIN_GNT			0x0000003e
+#define TG3PCI_MAX_LAT			0x0000003f
+#define TG3PCI_X_CAPS			0x00000040
+#define  PCIX_CAPS_RELAXED_ORDERING	 0x00020000
+#define TG3PCI_PM_CAP_PTR		0x00000041
+#define TG3PCI_X_COMMAND		0x00000042
+#define TG3PCI_X_STATUS			0x00000044
+#define TG3PCI_PM_CAP_ID		0x00000048
+#define TG3PCI_VPD_CAP_PTR		0x00000049
+#define TG3PCI_PM_CAPS			0x0000004a
+#define TG3PCI_PM_CTRL_STAT		0x0000004c
+#define TG3PCI_BR_SUPP_EXT		0x0000004e
+#define TG3PCI_PM_DATA			0x0000004f
+#define TG3PCI_VPD_CAP_ID		0x00000050
+#define TG3PCI_MSI_CAP_PTR		0x00000051
+#define TG3PCI_VPD_ADDR_FLAG		0x00000052
+#define  VPD_ADDR_FLAG_WRITE		0x00008000
+#define TG3PCI_VPD_DATA			0x00000054
+#define TG3PCI_MSI_CAP_ID		0x00000058
+#define TG3PCI_NXT_CAP_PTR		0x00000059
+#define TG3PCI_MSI_CTRL			0x0000005a
+#define TG3PCI_MSI_ADDR_LOW		0x0000005c
+#define TG3PCI_MSI_ADDR_HIGH		0x00000060
+#define TG3PCI_MSI_DATA			0x00000064
+/* 0x66 --> 0x68 unused */
+#define TG3PCI_MISC_HOST_CTRL		0x00000068
+#define  MISC_HOST_CTRL_CLEAR_INT	 0x00000001
+#define  MISC_HOST_CTRL_MASK_PCI_INT	 0x00000002
+#define  MISC_HOST_CTRL_BYTE_SWAP	 0x00000004
+#define  MISC_HOST_CTRL_WORD_SWAP	 0x00000008
+#define  MISC_HOST_CTRL_PCISTATE_RW	 0x00000010
+#define  MISC_HOST_CTRL_CLKREG_RW	 0x00000020
+#define  MISC_HOST_CTRL_REGWORD_SWAP	 0x00000040
+#define  MISC_HOST_CTRL_INDIR_ACCESS	 0x00000080
+#define  MISC_HOST_CTRL_IRQ_MASK_MODE	 0x00000100
+#define  MISC_HOST_CTRL_TAGGED_STATUS	 0x00000200
+#define  MISC_HOST_CTRL_CHIPREV		 0xffff0000
+#define  MISC_HOST_CTRL_CHIPREV_SHIFT	 16
+#define  GET_CHIP_REV_ID(MISC_HOST_CTRL) \
+	 (((MISC_HOST_CTRL) & MISC_HOST_CTRL_CHIPREV) >> \
+	  MISC_HOST_CTRL_CHIPREV_SHIFT)
+#define  CHIPREV_ID_5700_A0		 0x7000
+#define  CHIPREV_ID_5700_A1		 0x7001
+#define  CHIPREV_ID_5700_B0		 0x7100
+#define  CHIPREV_ID_5700_B1		 0x7101
+#define  CHIPREV_ID_5700_B3		 0x7102
+#define  CHIPREV_ID_5700_C0		 0x7200
+#define  CHIPREV_ID_5701_A0		 0x0000
+#define  CHIPREV_ID_5701_B0		 0x0100
+#define  CHIPREV_ID_5701_B2		 0x0102
+#define  CHIPREV_ID_5701_B5		 0x0105
+#define  CHIPREV_ID_5703_A0		 0x1000
+#define  CHIPREV_ID_5703_A1		 0x1001
+#define  CHIPREV_ID_5703_A2		 0x1002
+#define  GET_ASIC_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 12)
+#define   ASIC_REV_5700			 0x07
+#define   ASIC_REV_5701			 0x00
+#define   ASIC_REV_5703			 0x01
+#define  GET_CHIP_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 8)
+#define   CHIPREV_5700_AX		 0x70
+#define   CHIPREV_5700_BX		 0x71
+#define   CHIPREV_5700_CX		 0x72
+#define   CHIPREV_5701_AX		 0x00
+#define  GET_METAL_REV(CHIP_REV_ID)	((CHIP_REV_ID) & 0xff)
+#define   METAL_REV_A0			 0x00
+#define   METAL_REV_A1			 0x01
+#define   METAL_REV_B0			 0x00
+#define   METAL_REV_B1			 0x01
+#define   METAL_REV_B2			 0x02
+#define TG3PCI_DMA_RW_CTRL		0x0000006c
+#define  DMA_RWCTRL_MIN_DMA		 0x000000ff
+#define  DMA_RWCTRL_MIN_DMA_SHIFT	 0
+#define  DMA_RWCTRL_READ_BNDRY_MASK	 0x00000700
+#define  DMA_RWCTRL_READ_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_READ_BNDRY_16	 0x00000100
+#define  DMA_RWCTRL_READ_BNDRY_32	 0x00000200
+#define  DMA_RWCTRL_READ_BNDRY_64	 0x00000300
+#define  DMA_RWCTRL_READ_BNDRY_128	 0x00000400
+#define  DMA_RWCTRL_READ_BNDRY_256	 0x00000500
+#define  DMA_RWCTRL_READ_BNDRY_512	 0x00000600
+#define  DMA_RWCTRL_READ_BNDRY_1024	 0x00000700
+#define  DMA_RWCTRL_WRITE_BNDRY_MASK	 0x00003800
+#define  DMA_RWCTRL_WRITE_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_WRITE_BNDRY_16	 0x00000800
+#define  DMA_RWCTRL_WRITE_BNDRY_32	 0x00001000
+#define  DMA_RWCTRL_WRITE_BNDRY_64	 0x00001800
+#define  DMA_RWCTRL_WRITE_BNDRY_128	 0x00002000
+#define  DMA_RWCTRL_WRITE_BNDRY_256	 0x00002800
+#define  DMA_RWCTRL_WRITE_BNDRY_512	 0x00003000
+#define  DMA_RWCTRL_WRITE_BNDRY_1024	 0x00003800
+#define  DMA_RWCTRL_ONE_DMA		 0x00004000
+#define  DMA_RWCTRL_READ_WATER		 0x00070000
+#define  DMA_RWCTRL_READ_WATER_SHIFT	 16
+#define  DMA_RWCTRL_WRITE_WATER		 0x00380000
+#define  DMA_RWCTRL_WRITE_WATER_SHIFT	 19
+#define  DMA_RWCTRL_USE_MEM_READ_MULT	 0x00400000
+#define  DMA_RWCTRL_ASSERT_ALL_BE	 0x00800000
+#define  DMA_RWCTRL_PCI_READ_CMD	 0x0f000000
+#define  DMA_RWCTRL_PCI_READ_CMD_SHIFT	 24
+#define  DMA_RWCTRL_PCI_WRITE_CMD	 0xf0000000
+#define  DMA_RWCTRL_PCI_WRITE_CMD_SHIFT	 28
+#define TG3PCI_PCISTATE			0x00000070
+#define  PCISTATE_FORCE_RESET		 0x00000001
+#define  PCISTATE_INT_NOT_ACTIVE	 0x00000002
+#define  PCISTATE_CONV_PCI_MODE		 0x00000004
+#define  PCISTATE_BUS_SPEED_HIGH	 0x00000008
+#define  PCISTATE_BUS_32BIT		 0x00000010
+#define  PCISTATE_ROM_ENABLE		 0x00000020
+#define  PCISTATE_ROM_RETRY_ENABLE	 0x00000040
+#define  PCISTATE_FLAT_VIEW		 0x00000100
+#define TG3PCI_CLOCK_CTRL		0x00000074
+#define  CLOCK_CTRL_CORECLK_DISABLE	 0x00000200
+#define  CLOCK_CTRL_RXCLK_DISABLE	 0x00000400
+#define  CLOCK_CTRL_TXCLK_DISABLE	 0x00000800
+#define  CLOCK_CTRL_ALTCLK		 0x00001000
+#define  CLOCK_CTRL_PWRDOWN_PLL133	 0x00008000
+#define  CLOCK_CTRL_44MHZ_CORE		 0x00040000
+#define  CLOCK_CTRL_DELAY_PCI_GRANT	 0x80000000
+#define TG3PCI_REG_BASE_ADDR		0x00000078
+#define TG3PCI_MEM_WIN_BASE_ADDR	0x0000007c
+#define TG3PCI_REG_DATA			0x00000080
+#define TG3PCI_MEM_WIN_DATA		0x00000084
+#define TG3PCI_MODE_CTRL		0x00000088
+#define TG3PCI_MISC_CFG			0x0000008c
+#define TG3PCI_MISC_LOCAL_CTRL		0x00000090
+/* 0x94 --> 0x98 unused */
+#define TG3PCI_STD_RING_PROD_IDX	0x00000098 /* 64-bit */
+#define TG3PCI_RCV_RET_RING_CON_IDX	0x000000a0 /* 64-bit */
+#define TG3PCI_SND_PROD_IDX		0x000000a8 /* 64-bit */
+/* 0xb0 --> 0x100 unused */
+
+/* 0x100 --> 0x200 unused */
+
+/* Mailbox registers */
+#define MAILBOX_INTERRUPT_0		0x00000200 /* 64-bit */
+#define MAILBOX_INTERRUPT_1		0x00000208 /* 64-bit */
+#define MAILBOX_INTERRUPT_2		0x00000210 /* 64-bit */
+#define MAILBOX_INTERRUPT_3		0x00000218 /* 64-bit */
+#define MAILBOX_GENERAL_0		0x00000220 /* 64-bit */
+#define MAILBOX_GENERAL_1		0x00000228 /* 64-bit */
+#define MAILBOX_GENERAL_2		0x00000230 /* 64-bit */
+#define MAILBOX_GENERAL_3		0x00000238 /* 64-bit */
+#define MAILBOX_GENERAL_4		0x00000240 /* 64-bit */
+#define MAILBOX_GENERAL_5		0x00000248 /* 64-bit */
+#define MAILBOX_GENERAL_6		0x00000250 /* 64-bit */
+#define MAILBOX_GENERAL_7		0x00000258 /* 64-bit */
+#define MAILBOX_RELOAD_STAT		0x00000260 /* 64-bit */
+#define MAILBOX_RCV_STD_PROD_IDX	0x00000268 /* 64-bit */
+#define MAILBOX_RCV_JUMBO_PROD_IDX	0x00000270 /* 64-bit */
+#define MAILBOX_RCV_MINI_PROD_IDX	0x00000278 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_0	0x00000280 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_1	0x00000288 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_2	0x00000290 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_3	0x00000298 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_4	0x000002a0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_5	0x000002a8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_6	0x000002b0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_7	0x000002b8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_8	0x000002c0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_9	0x000002c8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_10	0x000002d0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_11	0x000002d8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_12	0x000002e0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_13	0x000002e8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_14	0x000002f0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_15	0x000002f8 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_0	0x00000300 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_1	0x00000308 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_2	0x00000310 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_3	0x00000318 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_4	0x00000320 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_5	0x00000328 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_6	0x00000330 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_7	0x00000338 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_8	0x00000340 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_9	0x00000348 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_10	0x00000350 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_11	0x00000358 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_12	0x00000360 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_13	0x00000368 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_14	0x00000370 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_15	0x00000378 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_0	0x00000380 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_1	0x00000388 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_2	0x00000390 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_3	0x00000398 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_4	0x000003a0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_5	0x000003a8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_6	0x000003b0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_7	0x000003b8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_8	0x000003c0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_9	0x000003c8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_10	0x000003d0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_11	0x000003d8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_12	0x000003e0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_13	0x000003e8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_14	0x000003f0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_15	0x000003f8 /* 64-bit */
+
+/* MAC control registers */
+#define MAC_MODE			0x00000400
+#define  MAC_MODE_RESET			 0x00000001
+#define  MAC_MODE_HALF_DUPLEX		 0x00000002
+#define  MAC_MODE_PORT_MODE_MASK	 0x0000000c
+#define  MAC_MODE_PORT_MODE_TBI		 0x0000000c
+#define  MAC_MODE_PORT_MODE_GMII	 0x00000008
+#define  MAC_MODE_PORT_MODE_MII		 0x00000004
+#define  MAC_MODE_PORT_MODE_NONE	 0x00000000
+#define  MAC_MODE_PORT_INT_LPBACK	 0x00000010
+#define  MAC_MODE_TAGGED_MAC_CTRL	 0x00000080
+#define  MAC_MODE_TX_BURSTING		 0x00000100
+#define  MAC_MODE_MAX_DEFER		 0x00000200
+#define  MAC_MODE_LINK_POLARITY		 0x00000400
+#define  MAC_MODE_RXSTAT_ENABLE		 0x00000800
+#define  MAC_MODE_RXSTAT_CLEAR		 0x00001000
+#define  MAC_MODE_RXSTAT_FLUSH		 0x00002000
+#define  MAC_MODE_TXSTAT_ENABLE		 0x00004000
+#define  MAC_MODE_TXSTAT_CLEAR		 0x00008000
+#define  MAC_MODE_TXSTAT_FLUSH		 0x00010000
+#define  MAC_MODE_SEND_CONFIGS		 0x00020000
+#define  MAC_MODE_MAGIC_PKT_ENABLE	 0x00040000
+#define  MAC_MODE_ACPI_ENABLE		 0x00080000
+#define  MAC_MODE_MIP_ENABLE		 0x00100000
+#define  MAC_MODE_TDE_ENABLE		 0x00200000
+#define  MAC_MODE_RDE_ENABLE		 0x00400000
+#define  MAC_MODE_FHDE_ENABLE		 0x00800000
+#define MAC_STATUS			0x00000404
+#define  MAC_STATUS_PCS_SYNCED		 0x00000001
+#define  MAC_STATUS_SIGNAL_DET		 0x00000002
+#define  MAC_STATUS_RCVD_CFG		 0x00000004
+#define  MAC_STATUS_CFG_CHANGED		 0x00000008
+#define  MAC_STATUS_SYNC_CHANGED	 0x00000010
+#define  MAC_STATUS_PORT_DEC_ERR	 0x00000400
+#define  MAC_STATUS_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_STATUS_MI_COMPLETION	 0x00400000
+#define  MAC_STATUS_MI_INTERRUPT	 0x00800000
+#define  MAC_STATUS_AP_ERROR		 0x01000000
+#define  MAC_STATUS_ODI_ERROR		 0x02000000
+#define  MAC_STATUS_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_STATUS_TXSTAT_OVERRUN	 0x08000000
+#define MAC_EVENT			0x00000408
+#define  MAC_EVENT_PORT_DECODE_ERR	 0x00000400
+#define  MAC_EVENT_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_EVENT_MI_COMPLETION	 0x00400000
+#define  MAC_EVENT_MI_INTERRUPT		 0x00800000
+#define  MAC_EVENT_AP_ERROR		 0x01000000
+#define  MAC_EVENT_ODI_ERROR		 0x02000000
+#define  MAC_EVENT_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_EVENT_TXSTAT_OVERRUN	 0x08000000
+#define MAC_LED_CTRL			0x0000040c
+#define  LED_CTRL_LNKLED_OVERRIDE	 0x00000001
+#define  LED_CTRL_1000MBPS_ON		 0x00000002
+#define  LED_CTRL_100MBPS_ON		 0x00000004
+#define  LED_CTRL_10MBPS_ON		 0x00000008
+#define  LED_CTRL_TRAFFIC_OVERRIDE	 0x00000010
+#define  LED_CTRL_TRAFFIC_BLINK		 0x00000020
+#define  LED_CTRL_TRAFFIC_LED		 0x00000040
+#define  LED_CTRL_1000MBPS_STATUS	 0x00000080
+#define  LED_CTRL_100MBPS_STATUS	 0x00000100
+#define  LED_CTRL_10MBPS_STATUS		 0x00000200
+#define  LED_CTRL_TRAFFIC_STATUS	 0x00000400
+#define  LED_CTRL_MAC_MODE		 0x00000000
+#define  LED_CTRL_PHY_MODE_1		 0x00000800
+#define  LED_CTRL_PHY_MODE_2		 0x00001000
+#define  LED_CTRL_BLINK_RATE_MASK	 0x7ff80000
+#define  LED_CTRL_BLINK_RATE_SHIFT	 19
+#define  LED_CTRL_BLINK_PER_OVERRIDE	 0x00080000
+#define  LED_CTRL_BLINK_RATE_OVERRIDE	 0x80000000
+#define MAC_ADDR_0_HIGH			0x00000410 /* upper 2 bytes */
+#define MAC_ADDR_0_LOW			0x00000414 /* lower 4 bytes */
+#define MAC_ADDR_1_HIGH			0x00000418 /* upper 2 bytes */
+#define MAC_ADDR_1_LOW			0x0000041c /* lower 4 bytes */
+#define MAC_ADDR_2_HIGH			0x00000420 /* upper 2 bytes */
+#define MAC_ADDR_2_LOW			0x00000424 /* lower 4 bytes */
+#define MAC_ADDR_3_HIGH			0x00000428 /* upper 2 bytes */
+#define MAC_ADDR_3_LOW			0x0000042c /* lower 4 bytes */
+#define MAC_ACPI_MBUF_PTR		0x00000430
+#define MAC_ACPI_LEN_OFFSET		0x00000434
+#define  ACPI_LENOFF_LEN_MASK		 0x0000ffff
+#define  ACPI_LENOFF_LEN_SHIFT		 0
+#define  ACPI_LENOFF_OFF_MASK		 0x0fff0000
+#define  ACPI_LENOFF_OFF_SHIFT		 16
+#define MAC_TX_BACKOFF_SEED		0x00000438
+#define  TX_BACKOFF_SEED_MASK		 0x000003ff
+#define MAC_RX_MTU_SIZE			0x0000043c
+#define  RX_MTU_SIZE_MASK		 0x0000ffff
+#define MAC_PCS_TEST			0x00000440
+#define  PCS_TEST_PATTERN_MASK		 0x000fffff
+#define  PCS_TEST_PATTERN_SHIFT		 0
+#define  PCS_TEST_ENABLE		 0x00100000
+#define MAC_TX_AUTO_NEG			0x00000444
+#define  TX_AUTO_NEG_MASK		 0x0000ffff
+#define  TX_AUTO_NEG_SHIFT		 0
+#define MAC_RX_AUTO_NEG			0x00000448
+#define  RX_AUTO_NEG_MASK		 0x0000ffff
+#define  RX_AUTO_NEG_SHIFT		 0
+#define MAC_MI_COM			0x0000044c
+#define  MI_COM_CMD_MASK		 0x0c000000
+#define  MI_COM_CMD_WRITE		 0x04000000
+#define  MI_COM_CMD_READ		 0x08000000
+#define  MI_COM_READ_FAILED		 0x10000000
+#define  MI_COM_START			 0x20000000
+#define  MI_COM_BUSY			 0x20000000
+#define  MI_COM_PHY_ADDR_MASK		 0x03e00000
+#define  MI_COM_PHY_ADDR_SHIFT		 21
+#define  MI_COM_REG_ADDR_MASK		 0x001f0000
+#define  MI_COM_REG_ADDR_SHIFT		 16
+#define  MI_COM_DATA_MASK		 0x0000ffff
+#define MAC_MI_STAT			0x00000450
+#define  MAC_MI_STAT_LNKSTAT_ATTN_ENAB	 0x00000001
+#define MAC_MI_MODE			0x00000454
+#define  MAC_MI_MODE_CLK_10MHZ		 0x00000001
+#define  MAC_MI_MODE_SHORT_PREAMBLE	 0x00000002
+#define  MAC_MI_MODE_AUTO_POLL		 0x00000010
+#define  MAC_MI_MODE_CORE_CLK_62MHZ	 0x00008000
+#define  MAC_MI_MODE_BASE		 0x000c0000 /* XXX magic values XXX */
+#define MAC_AUTO_POLL_STATUS		0x00000458
+#define  MAC_AUTO_POLL_ERROR		 0x00000001
+#define MAC_TX_MODE			0x0000045c
+#define  TX_MODE_RESET			 0x00000001
+#define  TX_MODE_ENABLE			 0x00000002
+#define  TX_MODE_FLOW_CTRL_ENABLE	 0x00000010
+#define  TX_MODE_BIG_BCKOFF_ENABLE	 0x00000020
+#define  TX_MODE_LONG_PAUSE_ENABLE	 0x00000040
+#define MAC_TX_STATUS			0x00000460
+#define  TX_STATUS_XOFFED		 0x00000001
+#define  TX_STATUS_SENT_XOFF		 0x00000002
+#define  TX_STATUS_SENT_XON		 0x00000004
+#define  TX_STATUS_LINK_UP		 0x00000008
+#define  TX_STATUS_ODI_UNDERRUN		 0x00000010
+#define  TX_STATUS_ODI_OVERRUN		 0x00000020
+#define MAC_TX_LENGTHS			0x00000464
+#define  TX_LENGTHS_SLOT_TIME_MASK	 0x000000ff
+#define  TX_LENGTHS_SLOT_TIME_SHIFT	 0
+#define  TX_LENGTHS_IPG_MASK		 0x00000f00
+#define  TX_LENGTHS_IPG_SHIFT		 8
+#define  TX_LENGTHS_IPG_CRS_MASK	 0x00003000
+#define  TX_LENGTHS_IPG_CRS_SHIFT	 12
+#define MAC_RX_MODE			0x00000468
+#define  RX_MODE_RESET			 0x00000001
+#define  RX_MODE_ENABLE			 0x00000002
+#define  RX_MODE_FLOW_CTRL_ENABLE	 0x00000004
+#define  RX_MODE_KEEP_MAC_CTRL		 0x00000008
+#define  RX_MODE_KEEP_PAUSE		 0x00000010
+#define  RX_MODE_ACCEPT_OVERSIZED	 0x00000020
+#define  RX_MODE_ACCEPT_RUNTS		 0x00000040
+#define  RX_MODE_LEN_CHECK		 0x00000080
+#define  RX_MODE_PROMISC		 0x00000100
+#define  RX_MODE_NO_CRC_CHECK		 0x00000200
+#define  RX_MODE_KEEP_VLAN_TAG		 0x00000400
+#define MAC_RX_STATUS			0x0000046c
+#define  RX_STATUS_REMOTE_TX_XOFFED	 0x00000001
+#define  RX_STATUS_XOFF_RCVD		 0x00000002
+#define  RX_STATUS_XON_RCVD		 0x00000004
+#define MAC_HASH_REG_0			0x00000470
+#define MAC_HASH_REG_1			0x00000474
+#define MAC_HASH_REG_2			0x00000478
+#define MAC_HASH_REG_3			0x0000047c
+#define MAC_RCV_RULE_0			0x00000480
+#define MAC_RCV_VALUE_0			0x00000484
+#define MAC_RCV_RULE_1			0x00000488
+#define MAC_RCV_VALUE_1			0x0000048c
+#define MAC_RCV_RULE_2			0x00000490
+#define MAC_RCV_VALUE_2			0x00000494
+#define MAC_RCV_RULE_3			0x00000498
+#define MAC_RCV_VALUE_3			0x0000049c
+#define MAC_RCV_RULE_4			0x000004a0
+#define MAC_RCV_VALUE_4			0x000004a4
+#define MAC_RCV_RULE_5			0x000004a8
+#define MAC_RCV_VALUE_5			0x000004ac
+#define MAC_RCV_RULE_6			0x000004b0
+#define MAC_RCV_VALUE_6			0x000004b4
+#define MAC_RCV_RULE_7			0x000004b8
+#define MAC_RCV_VALUE_7			0x000004bc
+#define MAC_RCV_RULE_8			0x000004c0
+#define MAC_RCV_VALUE_8			0x000004c4
+#define MAC_RCV_RULE_9			0x000004c8
+#define MAC_RCV_VALUE_9			0x000004cc
+#define MAC_RCV_RULE_10			0x000004d0
+#define MAC_RCV_VALUE_10		0x000004d4
+#define MAC_RCV_RULE_11			0x000004d8
+#define MAC_RCV_VALUE_11		0x000004dc
+#define MAC_RCV_RULE_12			0x000004e0
+#define MAC_RCV_VALUE_12		0x000004e4
+#define MAC_RCV_RULE_13			0x000004e8
+#define MAC_RCV_VALUE_13		0x000004ec
+#define MAC_RCV_RULE_14			0x000004f0
+#define MAC_RCV_VALUE_14		0x000004f4
+#define MAC_RCV_RULE_15			0x000004f8
+#define MAC_RCV_VALUE_15		0x000004fc
+#define  RCV_RULE_DISABLE_MASK		 0x7fffffff
+#define MAC_RCV_RULE_CFG		0x00000500
+#define  RCV_RULE_CFG_DEFAULT_CLASS	0x00000008
+/* 0x504 --> 0x590 unused */
+#define MAC_SERDES_CFG			0x00000590
+#define MAC_SERDES_STAT			0x00000594
+/* 0x598 --> 0x600 unused */
+#define MAC_TX_MAC_STATE_BASE		0x00000600 /* 16 bytes */
+#define MAC_RX_MAC_STATE_BASE		0x00000610 /* 20 bytes */
+/* 0x624 --> 0x800 unused */
+#define MAC_RX_STATS_BASE		0x00000800 /* 26 32-bit words */
+/* 0x868 --> 0x880 unused */
+#define MAC_TX_STATS_BASE		0x00000880 /* 28 32-bit words */
+/* 0x8f0 --> 0xc00 unused */
+
+/* Send data initiator control registers */
+#define SNDDATAI_MODE			0x00000c00
+#define  SNDDATAI_MODE_RESET		 0x00000001
+#define  SNDDATAI_MODE_ENABLE		 0x00000002
+#define  SNDDATAI_MODE_STAT_OFLOW_ENAB	 0x00000004
+#define SNDDATAI_STATUS			0x00000c04
+#define  SNDDATAI_STATUS_STAT_OFLOW	 0x00000004
+#define SNDDATAI_STATSCTRL		0x00000c08
+#define  SNDDATAI_SCTRL_ENABLE		 0x00000001
+#define  SNDDATAI_SCTRL_FASTUPD		 0x00000002
+#define  SNDDATAI_SCTRL_CLEAR		 0x00000004
+#define  SNDDATAI_SCTRL_FLUSH		 0x00000008
+#define  SNDDATAI_SCTRL_FORCE_ZERO	 0x00000010
+#define SNDDATAI_STATSENAB		0x00000c0c
+#define SNDDATAI_STATSINCMASK		0x00000c10
+/* 0xc14 --> 0xc80 unused */
+#define SNDDATAI_COS_CNT_0		0x00000c80
+#define SNDDATAI_COS_CNT_1		0x00000c84
+#define SNDDATAI_COS_CNT_2		0x00000c88
+#define SNDDATAI_COS_CNT_3		0x00000c8c
+#define SNDDATAI_COS_CNT_4		0x00000c90
+#define SNDDATAI_COS_CNT_5		0x00000c94
+#define SNDDATAI_COS_CNT_6		0x00000c98
+#define SNDDATAI_COS_CNT_7		0x00000c9c
+#define SNDDATAI_COS_CNT_8		0x00000ca0
+#define SNDDATAI_COS_CNT_9		0x00000ca4
+#define SNDDATAI_COS_CNT_10		0x00000ca8
+#define SNDDATAI_COS_CNT_11		0x00000cac
+#define SNDDATAI_COS_CNT_12		0x00000cb0
+#define SNDDATAI_COS_CNT_13		0x00000cb4
+#define SNDDATAI_COS_CNT_14		0x00000cb8
+#define SNDDATAI_COS_CNT_15		0x00000cbc
+#define SNDDATAI_DMA_RDQ_FULL_CNT	0x00000cc0
+#define SNDDATAI_DMA_PRIO_RDQ_FULL_CNT	0x00000cc4
+#define SNDDATAI_SDCQ_FULL_CNT		0x00000cc8
+#define SNDDATAI_NICRNG_SSND_PIDX_CNT	0x00000ccc
+#define SNDDATAI_STATS_UPDATED_CNT	0x00000cd0
+#define SNDDATAI_INTERRUPTS_CNT		0x00000cd4
+#define SNDDATAI_AVOID_INTERRUPTS_CNT	0x00000cd8
+#define SNDDATAI_SND_THRESH_HIT_CNT	0x00000cdc
+/* 0xce0 --> 0x1000 unused */
+
+/* Send data completion control registers */
+#define SNDDATAC_MODE			0x00001000
+#define  SNDDATAC_MODE_RESET		 0x00000001
+#define  SNDDATAC_MODE_ENABLE		 0x00000002
+/* 0x1004 --> 0x1400 unused */
+
+/* Send BD ring selector */
+#define SNDBDS_MODE			0x00001400
+#define  SNDBDS_MODE_RESET		 0x00000001
+#define  SNDBDS_MODE_ENABLE		 0x00000002
+#define  SNDBDS_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDS_STATUS			0x00001404
+#define  SNDBDS_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDS_HWDIAG			0x00001408
+/* 0x140c --> 0x1440 */
+#define SNDBDS_SEL_CON_IDX_0		0x00001440
+#define SNDBDS_SEL_CON_IDX_1		0x00001444
+#define SNDBDS_SEL_CON_IDX_2		0x00001448
+#define SNDBDS_SEL_CON_IDX_3		0x0000144c
+#define SNDBDS_SEL_CON_IDX_4		0x00001450
+#define SNDBDS_SEL_CON_IDX_5		0x00001454
+#define SNDBDS_SEL_CON_IDX_6		0x00001458
+#define SNDBDS_SEL_CON_IDX_7		0x0000145c
+#define SNDBDS_SEL_CON_IDX_8		0x00001460
+#define SNDBDS_SEL_CON_IDX_9		0x00001464
+#define SNDBDS_SEL_CON_IDX_10		0x00001468
+#define SNDBDS_SEL_CON_IDX_11		0x0000146c
+#define SNDBDS_SEL_CON_IDX_12		0x00001470
+#define SNDBDS_SEL_CON_IDX_13		0x00001474
+#define SNDBDS_SEL_CON_IDX_14		0x00001478
+#define SNDBDS_SEL_CON_IDX_15		0x0000147c
+/* 0x1480 --> 0x1800 unused */
+
+/* Send BD initiator control registers */
+#define SNDBDI_MODE			0x00001800
+#define  SNDBDI_MODE_RESET		 0x00000001
+#define  SNDBDI_MODE_ENABLE		 0x00000002
+#define  SNDBDI_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDI_STATUS			0x00001804
+#define  SNDBDI_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDI_IN_PROD_IDX_0		0x00001808
+#define SNDBDI_IN_PROD_IDX_1		0x0000180c
+#define SNDBDI_IN_PROD_IDX_2		0x00001810
+#define SNDBDI_IN_PROD_IDX_3		0x00001814
+#define SNDBDI_IN_PROD_IDX_4		0x00001818
+#define SNDBDI_IN_PROD_IDX_5		0x0000181c
+#define SNDBDI_IN_PROD_IDX_6		0x00001820
+#define SNDBDI_IN_PROD_IDX_7		0x00001824
+#define SNDBDI_IN_PROD_IDX_8		0x00001828
+#define SNDBDI_IN_PROD_IDX_9		0x0000182c
+#define SNDBDI_IN_PROD_IDX_10		0x00001830
+#define SNDBDI_IN_PROD_IDX_11		0x00001834
+#define SNDBDI_IN_PROD_IDX_12		0x00001838
+#define SNDBDI_IN_PROD_IDX_13		0x0000183c
+#define SNDBDI_IN_PROD_IDX_14		0x00001840
+#define SNDBDI_IN_PROD_IDX_15		0x00001844
+/* 0x1848 --> 0x1c00 unused */
+
+/* Send BD completion control registers */
+#define SNDBDC_MODE			0x00001c00
+#define SNDBDC_MODE_RESET		 0x00000001
+#define SNDBDC_MODE_ENABLE		 0x00000002
+#define SNDBDC_MODE_ATTN_ENABLE		 0x00000004
+/* 0x1c04 --> 0x2000 unused */
+
+/* Receive list placement control registers */
+#define RCVLPC_MODE			0x00002000
+#define  RCVLPC_MODE_RESET		 0x00000001
+#define  RCVLPC_MODE_ENABLE		 0x00000002
+#define  RCVLPC_MODE_CLASS0_ATTN_ENAB	 0x00000004
+#define  RCVLPC_MODE_MAPOOR_AATTN_ENAB	 0x00000008
+#define  RCVLPC_MODE_STAT_OFLOW_ENAB	 0x00000010
+#define RCVLPC_STATUS			0x00002004
+#define  RCVLPC_STATUS_CLASS0		 0x00000004
+#define  RCVLPC_STATUS_MAPOOR		 0x00000008
+#define  RCVLPC_STATUS_STAT_OFLOW	 0x00000010
+#define RCVLPC_LOCK			0x00002008
+#define  RCVLPC_LOCK_REQ_MASK		 0x0000ffff
+#define  RCVLPC_LOCK_REQ_SHIFT		 0
+#define  RCVLPC_LOCK_GRANT_MASK		 0xffff0000
+#define  RCVLPC_LOCK_GRANT_SHIFT	 16
+#define RCVLPC_NON_EMPTY_BITS		0x0000200c
+#define  RCVLPC_NON_EMPTY_BITS_MASK	 0x0000ffff
+#define RCVLPC_CONFIG			0x00002010
+#define RCVLPC_STATSCTRL		0x00002014
+#define  RCVLPC_STATSCTRL_ENABLE	 0x00000001
+#define  RCVLPC_STATSCTRL_FASTUPD	 0x00000002
+#define RCVLPC_STATS_ENABLE		0x00002018
+#define RCVLPC_STATS_INCMASK		0x0000201c
+/* 0x2020 --> 0x2100 unused */
+#define RCVLPC_SELLST_BASE		0x00002100 /* 16 16-byte entries */
+#define  SELLST_TAIL			0x00000004
+#define  SELLST_CONT			0x00000008
+#define  SELLST_UNUSED			0x0000000c
+#define RCVLPC_COS_CNTL_BASE		0x00002200 /* 16 4-byte entries */
+#define RCVLPC_DROP_FILTER_CNT		0x00002240
+#define RCVLPC_DMA_WQ_FULL_CNT		0x00002244
+#define RCVLPC_DMA_HIPRIO_WQ_FULL_CNT	0x00002248
+#define RCVLPC_NO_RCV_BD_CNT		0x0000224c
+#define RCVLPC_IN_DISCARDS_CNT		0x00002250
+#define RCVLPC_IN_ERRORS_CNT		0x00002254
+#define RCVLPC_RCV_THRESH_HIT_CNT	0x00002258
+/* 0x225c --> 0x2400 unused */
+
+/* Receive Data and Receive BD Initiator Control */
+#define RCVDBDI_MODE			0x00002400
+#define  RCVDBDI_MODE_RESET		 0x00000001
+#define  RCVDBDI_MODE_ENABLE		 0x00000002
+#define  RCVDBDI_MODE_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_MODE_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_MODE_INV_RING_SZ	 0x00000010
+#define RCVDBDI_STATUS			0x00002404
+#define  RCVDBDI_STATUS_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_STATUS_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_STATUS_INV_RING_SZ	 0x00000010
+#define RCVDBDI_SPLIT_FRAME_MINSZ	0x00002408
+/* 0x240c --> 0x2440 unused */
+#define RCVDBDI_JUMBO_BD		0x00002440 /* TG3_BDINFO_... */
+#define RCVDBDI_STD_BD			0x00002450 /* TG3_BDINFO_... */
+#define RCVDBDI_MINI_BD			0x00002460 /* TG3_BDINFO_... */
+#define RCVDBDI_JUMBO_CON_IDX		0x00002470
+#define RCVDBDI_STD_CON_IDX		0x00002474
+#define RCVDBDI_MINI_CON_IDX		0x00002478
+/* 0x247c --> 0x2480 unused */
+#define RCVDBDI_BD_PROD_IDX_0		0x00002480
+#define RCVDBDI_BD_PROD_IDX_1		0x00002484
+#define RCVDBDI_BD_PROD_IDX_2		0x00002488
+#define RCVDBDI_BD_PROD_IDX_3		0x0000248c
+#define RCVDBDI_BD_PROD_IDX_4		0x00002490
+#define RCVDBDI_BD_PROD_IDX_5		0x00002494
+#define RCVDBDI_BD_PROD_IDX_6		0x00002498
+#define RCVDBDI_BD_PROD_IDX_7		0x0000249c
+#define RCVDBDI_BD_PROD_IDX_8		0x000024a0
+#define RCVDBDI_BD_PROD_IDX_9		0x000024a4
+#define RCVDBDI_BD_PROD_IDX_10		0x000024a8
+#define RCVDBDI_BD_PROD_IDX_11		0x000024ac
+#define RCVDBDI_BD_PROD_IDX_12		0x000024b0
+#define RCVDBDI_BD_PROD_IDX_13		0x000024b4
+#define RCVDBDI_BD_PROD_IDX_14		0x000024b8
+#define RCVDBDI_BD_PROD_IDX_15		0x000024bc
+#define RCVDBDI_HWDIAG			0x000024c0
+/* 0x24c4 --> 0x2800 unused */
+
+/* Receive Data Completion Control */
+#define RCVDCC_MODE			0x00002800
+#define  RCVDCC_MODE_RESET		 0x00000001
+#define  RCVDCC_MODE_ENABLE		 0x00000002
+#define  RCVDCC_MODE_ATTN_ENABLE	 0x00000004
+/* 0x2804 --> 0x2c00 unused */
+
+/* Receive BD Initiator Control Registers */
+#define RCVBDI_MODE			0x00002c00
+#define  RCVBDI_MODE_RESET		 0x00000001
+#define  RCVBDI_MODE_ENABLE		 0x00000002
+#define  RCVBDI_MODE_RCB_ATTN_ENAB	 0x00000004
+#define RCVBDI_STATUS			0x00002c04
+#define  RCVBDI_STATUS_RCB_ATTN		 0x00000004
+#define RCVBDI_JUMBO_PROD_IDX		0x00002c08
+#define RCVBDI_STD_PROD_IDX		0x00002c0c
+#define RCVBDI_MINI_PROD_IDX		0x00002c10
+#define RCVBDI_MINI_THRESH		0x00002c14
+#define RCVBDI_STD_THRESH		0x00002c18
+#define RCVBDI_JUMBO_THRESH		0x00002c1c
+/* 0x2c20 --> 0x3000 unused */
+
+/* Receive BD Completion Control Registers */
+#define RCVCC_MODE			0x00003000
+#define  RCVCC_MODE_RESET		 0x00000001
+#define  RCVCC_MODE_ENABLE		 0x00000002
+#define  RCVCC_MODE_ATTN_ENABLE		 0x00000004
+#define RCVCC_STATUS			0x00003004
+#define  RCVCC_STATUS_ERROR_ATTN	 0x00000004
+#define RCVCC_JUMP_PROD_IDX		0x00003008
+#define RCVCC_STD_PROD_IDX		0x0000300c
+#define RCVCC_MINI_PROD_IDX		0x00003010
+/* 0x3014 --> 0x3400 unused */
+
+/* Receive list selector control registers */
+#define RCVLSC_MODE			0x00003400
+#define  RCVLSC_MODE_RESET		 0x00000001
+#define  RCVLSC_MODE_ENABLE		 0x00000002
+#define  RCVLSC_MODE_ATTN_ENABLE	 0x00000004
+#define RCVLSC_STATUS			0x00003404
+#define  RCVLSC_STATUS_ERROR_ATTN	 0x00000004
+/* 0x3408 --> 0x3800 unused */
+
+/* Mbuf cluster free registers */
+#define MBFREE_MODE			0x00003800
+#define  MBFREE_MODE_RESET		 0x00000001
+#define  MBFREE_MODE_ENABLE		 0x00000002
+#define MBFREE_STATUS			0x00003804
+/* 0x3808 --> 0x3c00 unused */
+
+/* Host coalescing control registers */
+#define HOSTCC_MODE			0x00003c00
+#define  HOSTCC_MODE_RESET		 0x00000001
+#define  HOSTCC_MODE_ENABLE		 0x00000002
+#define  HOSTCC_MODE_ATTN		 0x00000004
+#define  HOSTCC_MODE_NOW		 0x00000008
+#define  HOSTCC_MODE_FULL_STATUS	 0x00000000
+#define  HOSTCC_MODE_64BYTE		 0x00000080
+#define  HOSTCC_MODE_32BYTE		 0x00000100
+#define  HOSTCC_MODE_CLRTICK_RXBD	 0x00000200
+#define  HOSTCC_MODE_CLRTICK_TXBD	 0x00000400
+#define  HOSTCC_MODE_NOINT_ON_NOW	 0x00000800
+#define  HOSTCC_MODE_NOINT_ON_FORCE	 0x00001000
+#define HOSTCC_STATUS			0x00003c04
+#define  HOSTCC_STATUS_ERROR_ATTN	 0x00000004
+#define HOSTCC_RXCOL_TICKS		0x00003c08
+#define  LOW_RXCOL_TICKS		 0x00000032
+#define  DEFAULT_RXCOL_TICKS		 0x00000048
+#define  HIGH_RXCOL_TICKS		 0x00000096
+#define HOSTCC_TXCOL_TICKS		0x00003c0c
+#define  LOW_TXCOL_TICKS		 0x00000096
+#define  DEFAULT_TXCOL_TICKS		 0x0000012c
+#define  HIGH_TXCOL_TICKS		 0x00000145
+#define HOSTCC_RXMAX_FRAMES		0x00003c10
+#define  LOW_RXMAX_FRAMES		 0x00000005
+#define  DEFAULT_RXMAX_FRAMES		 0x00000008
+#define  HIGH_RXMAX_FRAMES		 0x00000012
+#define HOSTCC_TXMAX_FRAMES		0x00003c14
+#define  LOW_TXMAX_FRAMES		 0x00000035
+#define  DEFAULT_TXMAX_FRAMES		 0x0000004b
+#define  HIGH_TXMAX_FRAMES		 0x00000052
+#define HOSTCC_RXCOAL_TICK_INT		0x00003c18
+#define  DEFAULT_RXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_TXCOAL_TICK_INT		0x00003c1c
+#define  DEFAULT_TXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_RXCOAL_MAXF_INT		0x00003c20
+#define  DEFAULT_RXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_TXCOAL_MAXF_INT		0x00003c24
+#define  DEFAULT_TXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_STAT_COAL_TICKS		0x00003c28
+#define  DEFAULT_STAT_COAL_TICKS	 0x000f4240
+/* 0x3c2c --> 0x3c30 unused */
+#define HOSTCC_STATS_BLK_HOST_ADDR	0x00003c30 /* 64-bit */
+#define HOSTCC_STATUS_BLK_HOST_ADDR	0x00003c38 /* 64-bit */
+#define HOSTCC_STATS_BLK_NIC_ADDR	0x00003c40
+#define HOSTCC_STATUS_BLK_NIC_ADDR	0x00003c44
+#define HOSTCC_FLOW_ATTN		0x00003c48
+/* 0x3c4c --> 0x3c50 unused */
+#define HOSTCC_JUMBO_CON_IDX		0x00003c50
+#define HOSTCC_STD_CON_IDX		0x00003c54
+#define HOSTCC_MINI_CON_IDX		0x00003c58
+/* 0x3c5c --> 0x3c80 unused */
+#define HOSTCC_RET_PROD_IDX_0		0x00003c80
+#define HOSTCC_RET_PROD_IDX_1		0x00003c84
+#define HOSTCC_RET_PROD_IDX_2		0x00003c88
+#define HOSTCC_RET_PROD_IDX_3		0x00003c8c
+#define HOSTCC_RET_PROD_IDX_4		0x00003c90
+#define HOSTCC_RET_PROD_IDX_5		0x00003c94
+#define HOSTCC_RET_PROD_IDX_6		0x00003c98
+#define HOSTCC_RET_PROD_IDX_7		0x00003c9c
+#define HOSTCC_RET_PROD_IDX_8		0x00003ca0
+#define HOSTCC_RET_PROD_IDX_9		0x00003ca4
+#define HOSTCC_RET_PROD_IDX_10		0x00003ca8
+#define HOSTCC_RET_PROD_IDX_11		0x00003cac
+#define HOSTCC_RET_PROD_IDX_12		0x00003cb0
+#define HOSTCC_RET_PROD_IDX_13		0x00003cb4
+#define HOSTCC_RET_PROD_IDX_14		0x00003cb8
+#define HOSTCC_RET_PROD_IDX_15		0x00003cbc
+#define HOSTCC_SND_CON_IDX_0		0x00003cc0
+#define HOSTCC_SND_CON_IDX_1		0x00003cc4
+#define HOSTCC_SND_CON_IDX_2		0x00003cc8
+#define HOSTCC_SND_CON_IDX_3		0x00003ccc
+#define HOSTCC_SND_CON_IDX_4		0x00003cd0
+#define HOSTCC_SND_CON_IDX_5		0x00003cd4
+#define HOSTCC_SND_CON_IDX_6		0x00003cd8
+#define HOSTCC_SND_CON_IDX_7		0x00003cdc
+#define HOSTCC_SND_CON_IDX_8		0x00003ce0
+#define HOSTCC_SND_CON_IDX_9		0x00003ce4
+#define HOSTCC_SND_CON_IDX_10		0x00003ce8
+#define HOSTCC_SND_CON_IDX_11		0x00003cec
+#define HOSTCC_SND_CON_IDX_12		0x00003cf0
+#define HOSTCC_SND_CON_IDX_13		0x00003cf4
+#define HOSTCC_SND_CON_IDX_14		0x00003cf8
+#define HOSTCC_SND_CON_IDX_15		0x00003cfc
+/* 0x3d00 --> 0x4000 unused */
+
+/* Memory arbiter control registers */
+#define MEMARB_MODE			0x00004000
+#define  MEMARB_MODE_RESET		 0x00000001
+#define  MEMARB_MODE_ENABLE		 0x00000002
+#define MEMARB_STATUS			0x00004004
+#define MEMARB_TRAP_ADDR_LOW		0x00004008
+#define MEMARB_TRAP_ADDR_HIGH		0x0000400c
+/* 0x4010 --> 0x4400 unused */
+
+/* Buffer manager control registers */
+#define BUFMGR_MODE			0x00004400
+#define  BUFMGR_MODE_RESET		 0x00000001
+#define  BUFMGR_MODE_ENABLE		 0x00000002
+#define  BUFMGR_MODE_ATTN_ENABLE	 0x00000004
+#define  BUFMGR_MODE_BM_TEST		 0x00000008
+#define  BUFMGR_MODE_MBLOW_ATTN_ENAB	 0x00000010
+#define BUFMGR_STATUS			0x00004404
+#define  BUFMGR_STATUS_ERROR		 0x00000004
+#define  BUFMGR_STATUS_MBLOW		 0x00000010
+#define BUFMGR_MB_POOL_ADDR		0x00004408
+#define BUFMGR_MB_POOL_SIZE		0x0000440c
+#define BUFMGR_MB_RDMA_LOW_WATER	0x00004410
+#define  DEFAULT_MB_RDMA_LOW_WATER	 0x00000040
+#define  DEFAULT_MB_RDMA_LOW_WATER_JUMBO 0x00000130
+#define BUFMGR_MB_MACRX_LOW_WATER	0x00004414
+#define  DEFAULT_MB_MACRX_LOW_WATER	  0x00000020
+#define  DEFAULT_MB_MACRX_LOW_WATER_JUMBO 0x00000098
+#define BUFMGR_MB_HIGH_WATER		0x00004418
+#define  DEFAULT_MB_HIGH_WATER		 0x00000060
+#define  DEFAULT_MB_HIGH_WATER_JUMBO	 0x0000017c
+#define BUFMGR_RX_MB_ALLOC_REQ		0x0000441c
+#define  BUFMGR_MB_ALLOC_BIT		 0x10000000
+#define BUFMGR_RX_MB_ALLOC_RESP		0x00004420
+#define BUFMGR_TX_MB_ALLOC_REQ		0x00004424
+#define BUFMGR_TX_MB_ALLOC_RESP		0x00004428
+#define BUFMGR_DMA_DESC_POOL_ADDR	0x0000442c
+#define BUFMGR_DMA_DESC_POOL_SIZE	0x00004430
+#define BUFMGR_DMA_LOW_WATER		0x00004434
+#define  DEFAULT_DMA_LOW_WATER		 0x00000005
+#define BUFMGR_DMA_HIGH_WATER		0x00004438
+#define  DEFAULT_DMA_HIGH_WATER		 0x0000000a
+#define BUFMGR_RX_DMA_ALLOC_REQ		0x0000443c
+#define BUFMGR_RX_DMA_ALLOC_RESP	0x00004440
+#define BUFMGR_TX_DMA_ALLOC_REQ		0x00004444
+#define BUFMGR_TX_DMA_ALLOC_RESP	0x00004448
+#define BUFMGR_HWDIAG_0			0x0000444c
+#define BUFMGR_HWDIAG_1			0x00004450
+#define BUFMGR_HWDIAG_2			0x00004454
+/* 0x4458 --> 0x4800 unused */
+
+/* Read DMA control registers */
+#define RDMAC_MODE			0x00004800
+#define  RDMAC_MODE_RESET		 0x00000001
+#define  RDMAC_MODE_ENABLE		 0x00000002
+#define  RDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  RDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  RDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  RDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  RDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  RDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  RDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  RDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define RDMAC_STATUS			0x00004804
+#define  RDMAC_STATUS_TGTABORT		 0x00000004
+#define  RDMAC_STATUS_MSTABORT		 0x00000008
+#define  RDMAC_STATUS_PARITYERR		 0x00000010
+#define  RDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  RDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  RDMAC_STATUS_FIFOURUN		 0x00000080
+#define  RDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  RDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4808 --> 0x4c00 unused */
+
+/* Write DMA control registers */
+#define WDMAC_MODE			0x00004c00
+#define  WDMAC_MODE_RESET		 0x00000001
+#define  WDMAC_MODE_ENABLE		 0x00000002
+#define  WDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  WDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  WDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  WDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  WDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  WDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  WDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  WDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define WDMAC_STATUS			0x00004c04
+#define  WDMAC_STATUS_TGTABORT		 0x00000004
+#define  WDMAC_STATUS_MSTABORT		 0x00000008
+#define  WDMAC_STATUS_PARITYERR		 0x00000010
+#define  WDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  WDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  WDMAC_STATUS_FIFOURUN		 0x00000080
+#define  WDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  WDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4c08 --> 0x5000 unused */
+
+/* Per-cpu register offsets (arm9) */
+#define CPU_MODE			0x00000000
+#define  CPU_MODE_RESET			 0x00000001
+#define  CPU_MODE_HALT			 0x00000400
+#define CPU_STATE			0x00000004
+#define CPU_EVTMASK			0x00000008
+/* 0xc --> 0x1c reserved */
+#define CPU_PC				0x0000001c
+#define CPU_INSN			0x00000020
+#define CPU_SPAD_UFLOW			0x00000024
+#define CPU_WDOG_CLEAR			0x00000028
+#define CPU_WDOG_VECTOR			0x0000002c
+#define CPU_WDOG_PC			0x00000030
+#define CPU_HW_BP			0x00000034
+/* 0x38 --> 0x44 unused */
+#define CPU_WDOG_SAVED_STATE		0x00000044
+#define CPU_LAST_BRANCH_ADDR		0x00000048
+#define CPU_SPAD_UFLOW_SET		0x0000004c
+/* 0x50 --> 0x200 unused */
+#define CPU_R0				0x00000200
+#define CPU_R1				0x00000204
+#define CPU_R2				0x00000208
+#define CPU_R3				0x0000020c
+#define CPU_R4				0x00000210
+#define CPU_R5				0x00000214
+#define CPU_R6				0x00000218
+#define CPU_R7				0x0000021c
+#define CPU_R8				0x00000220
+#define CPU_R9				0x00000224
+#define CPU_R10				0x00000228
+#define CPU_R11				0x0000022c
+#define CPU_R12				0x00000230
+#define CPU_R13				0x00000234
+#define CPU_R14				0x00000238
+#define CPU_R15				0x0000023c
+#define CPU_R16				0x00000240
+#define CPU_R17				0x00000244
+#define CPU_R18				0x00000248
+#define CPU_R19				0x0000024c
+#define CPU_R20				0x00000250
+#define CPU_R21				0x00000254
+#define CPU_R22				0x00000258
+#define CPU_R23				0x0000025c
+#define CPU_R24				0x00000260
+#define CPU_R25				0x00000264
+#define CPU_R26				0x00000268
+#define CPU_R27				0x0000026c
+#define CPU_R28				0x00000270
+#define CPU_R29				0x00000274
+#define CPU_R30				0x00000278
+#define CPU_R31				0x0000027c
+/* 0x280 --> 0x400 unused */
+
+#define RX_CPU_BASE			0x00005000
+#define TX_CPU_BASE			0x00005400
+
+/* Mailboxes */
+#define GRCMBOX_INTERRUPT_0		0x00005800 /* 64-bit */
+#define GRCMBOX_INTERRUPT_1		0x00005808 /* 64-bit */
+#define GRCMBOX_INTERRUPT_2		0x00005810 /* 64-bit */
+#define GRCMBOX_INTERRUPT_3		0x00005818 /* 64-bit */
+#define GRCMBOX_GENERAL_0		0x00005820 /* 64-bit */
+#define GRCMBOX_GENERAL_1		0x00005828 /* 64-bit */
+#define GRCMBOX_GENERAL_2		0x00005830 /* 64-bit */
+#define GRCMBOX_GENERAL_3		0x00005838 /* 64-bit */
+#define GRCMBOX_GENERAL_4		0x00005840 /* 64-bit */
+#define GRCMBOX_GENERAL_5		0x00005848 /* 64-bit */
+#define GRCMBOX_GENERAL_6		0x00005850 /* 64-bit */
+#define GRCMBOX_GENERAL_7		0x00005858 /* 64-bit */
+#define GRCMBOX_RELOAD_STAT		0x00005860 /* 64-bit */
+#define GRCMBOX_RCVSTD_PROD_IDX		0x00005868 /* 64-bit */
+#define GRCMBOX_RCVJUMBO_PROD_IDX	0x00005870 /* 64-bit */
+#define GRCMBOX_RCVMINI_PROD_IDX	0x00005878 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_0	0x00005880 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_1	0x00005888 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_2	0x00005890 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_3	0x00005898 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_4	0x000058a0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_5	0x000058a8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_6	0x000058b0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_7	0x000058b8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_8	0x000058c0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_9	0x000058c8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_10	0x000058d0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_11	0x000058d8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_12	0x000058e0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_13	0x000058e8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_14	0x000058f0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_15	0x000058f8 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_0	0x00005900 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_1	0x00005908 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_2	0x00005910 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_3	0x00005918 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_4	0x00005920 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_5	0x00005928 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_6	0x00005930 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_7	0x00005938 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_8	0x00005940 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_9	0x00005948 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_10	0x00005950 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_11	0x00005958 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_12	0x00005960 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_13	0x00005968 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_14	0x00005970 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_15	0x00005978 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_0	0x00005980 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_1	0x00005988 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_2	0x00005990 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_3	0x00005998 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_4	0x000059a0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_5	0x000059a8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_6	0x000059b0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_7	0x000059b8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_8	0x000059c0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_9	0x000059c8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_10	0x000059d0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_11	0x000059d8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_12	0x000059e0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_13	0x000059e8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_14	0x000059f0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_15	0x000059f8 /* 64-bit */
+#define GRCMBOX_HIGH_PRIO_EV_VECTOR	0x00005a00
+#define GRCMBOX_HIGH_PRIO_EV_MASK	0x00005a04
+#define GRCMBOX_LOW_PRIO_EV_VEC		0x00005a08
+#define GRCMBOX_LOW_PRIO_EV_MASK	0x00005a0c
+/* 0x5a10 --> 0x5c00 */
+
+/* Flow Through queues */
+#define FTQ_RESET			0x00005c00
+/* 0x5c04 --> 0x5c10 unused */
+#define FTQ_DMA_NORM_READ_CTL		0x00005c10
+#define FTQ_DMA_NORM_READ_FULL_CNT	0x00005c14
+#define FTQ_DMA_NORM_READ_FIFO_ENQDEQ	0x00005c18
+#define FTQ_DMA_NORM_READ_WRITE_PEEK	0x00005c1c
+#define FTQ_DMA_HIGH_READ_CTL		0x00005c20
+#define FTQ_DMA_HIGH_READ_FULL_CNT	0x00005c24
+#define FTQ_DMA_HIGH_READ_FIFO_ENQDEQ	0x00005c28
+#define FTQ_DMA_HIGH_READ_WRITE_PEEK	0x00005c2c
+#define FTQ_DMA_COMP_DISC_CTL		0x00005c30
+#define FTQ_DMA_COMP_DISC_FULL_CNT	0x00005c34
+#define FTQ_DMA_COMP_DISC_FIFO_ENQDEQ	0x00005c38
+#define FTQ_DMA_COMP_DISC_WRITE_PEEK	0x00005c3c
+#define FTQ_SEND_BD_COMP_CTL		0x00005c40
+#define FTQ_SEND_BD_COMP_FULL_CNT	0x00005c44
+#define FTQ_SEND_BD_COMP_FIFO_ENQDEQ	0x00005c48
+#define FTQ_SEND_BD_COMP_WRITE_PEEK	0x00005c4c
+#define FTQ_SEND_DATA_INIT_CTL		0x00005c50
+#define FTQ_SEND_DATA_INIT_FULL_CNT	0x00005c54
+#define FTQ_SEND_DATA_INIT_FIFO_ENQDEQ	0x00005c58
+#define FTQ_SEND_DATA_INIT_WRITE_PEEK	0x00005c5c
+#define FTQ_DMA_NORM_WRITE_CTL		0x00005c60
+#define FTQ_DMA_NORM_WRITE_FULL_CNT	0x00005c64
+#define FTQ_DMA_NORM_WRITE_FIFO_ENQDEQ	0x00005c68
+#define FTQ_DMA_NORM_WRITE_WRITE_PEEK	0x00005c6c
+#define FTQ_DMA_HIGH_WRITE_CTL		0x00005c70
+#define FTQ_DMA_HIGH_WRITE_FULL_CNT	0x00005c74
+#define FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ	0x00005c78
+#define FTQ_DMA_HIGH_WRITE_WRITE_PEEK	0x00005c7c
+#define FTQ_SWTYPE1_CTL			0x00005c80
+#define FTQ_SWTYPE1_FULL_CNT		0x00005c84
+#define FTQ_SWTYPE1_FIFO_ENQDEQ		0x00005c88
+#define FTQ_SWTYPE1_WRITE_PEEK		0x00005c8c
+#define FTQ_SEND_DATA_COMP_CTL		0x00005c90
+#define FTQ_SEND_DATA_COMP_FULL_CNT	0x00005c94
+#define FTQ_SEND_DATA_COMP_FIFO_ENQDEQ	0x00005c98
+#define FTQ_SEND_DATA_COMP_WRITE_PEEK	0x00005c9c
+#define FTQ_HOST_COAL_CTL		0x00005ca0
+#define FTQ_HOST_COAL_FULL_CNT		0x00005ca4
+#define FTQ_HOST_COAL_FIFO_ENQDEQ	0x00005ca8
+#define FTQ_HOST_COAL_WRITE_PEEK	0x00005cac
+#define FTQ_MAC_TX_CTL			0x00005cb0
+#define FTQ_MAC_TX_FULL_CNT		0x00005cb4
+#define FTQ_MAC_TX_FIFO_ENQDEQ		0x00005cb8
+#define FTQ_MAC_TX_WRITE_PEEK		0x00005cbc
+#define FTQ_MB_FREE_CTL			0x00005cc0
+#define FTQ_MB_FREE_FULL_CNT		0x00005cc4
+#define FTQ_MB_FREE_FIFO_ENQDEQ		0x00005cc8
+#define FTQ_MB_FREE_WRITE_PEEK		0x00005ccc
+#define FTQ_RCVBD_COMP_CTL		0x00005cd0
+#define FTQ_RCVBD_COMP_FULL_CNT		0x00005cd4
+#define FTQ_RCVBD_COMP_FIFO_ENQDEQ	0x00005cd8
+#define FTQ_RCVBD_COMP_WRITE_PEEK	0x00005cdc
+#define FTQ_RCVLST_PLMT_CTL		0x00005ce0
+#define FTQ_RCVLST_PLMT_FULL_CNT	0x00005ce4
+#define FTQ_RCVLST_PLMT_FIFO_ENQDEQ	0x00005ce8
+#define FTQ_RCVLST_PLMT_WRITE_PEEK	0x00005cec
+#define FTQ_RCVDATA_INI_CTL		0x00005cf0
+#define FTQ_RCVDATA_INI_FULL_CNT	0x00005cf4
+#define FTQ_RCVDATA_INI_FIFO_ENQDEQ	0x00005cf8
+#define FTQ_RCVDATA_INI_WRITE_PEEK	0x00005cfc
+#define FTQ_RCVDATA_COMP_CTL		0x00005d00
+#define FTQ_RCVDATA_COMP_FULL_CNT	0x00005d04
+#define FTQ_RCVDATA_COMP_FIFO_ENQDEQ	0x00005d08
+#define FTQ_RCVDATA_COMP_WRITE_PEEK	0x00005d0c
+#define FTQ_SWTYPE2_CTL			0x00005d10
+#define FTQ_SWTYPE2_FULL_CNT		0x00005d14
+#define FTQ_SWTYPE2_FIFO_ENQDEQ		0x00005d18
+#define FTQ_SWTYPE2_WRITE_PEEK		0x00005d1c
+/* 0x5d20 --> 0x6000 unused */
+
+/* Message signaled interrupt registers */
+#define MSGINT_MODE			0x00006000
+#define  MSGINT_MODE_RESET		 0x00000001
+#define  MSGINT_MODE_ENABLE		 0x00000002
+#define MSGINT_STATUS			0x00006004
+#define MSGINT_FIFO			0x00006008
+/* 0x600c --> 0x6400 unused */
+
+/* DMA completion registers */
+#define DMAC_MODE			0x00006400
+#define  DMAC_MODE_RESET		 0x00000001
+#define  DMAC_MODE_ENABLE		 0x00000002
+/* 0x6404 --> 0x6800 unused */
+
+/* GRC registers */
+#define GRC_MODE			0x00006800
+#define  GRC_MODE_UPD_ON_COAL		0x00000001
+#define  GRC_MODE_BSWAP_NONFRM_DATA	0x00000002
+#define  GRC_MODE_WSWAP_NONFRM_DATA	0x00000004
+#define  GRC_MODE_BSWAP_DATA		0x00000010
+#define  GRC_MODE_WSWAP_DATA		0x00000020
+#define  GRC_MODE_SPLITHDR		0x00000100
+#define  GRC_MODE_NOFRM_CRACKING	0x00000200
+#define  GRC_MODE_INCL_CRC		0x00000400
+#define  GRC_MODE_ALLOW_BAD_FRMS	0x00000800
+#define  GRC_MODE_NOIRQ_ON_SENDS	0x00002000
+#define  GRC_MODE_NOIRQ_ON_RCV		0x00004000
+#define  GRC_MODE_FORCE_PCI32BIT	0x00008000
+#define  GRC_MODE_HOST_STACKUP		0x00010000
+#define  GRC_MODE_HOST_SENDBDS		0x00020000
+#define  GRC_MODE_NO_TX_PHDR_CSUM	0x00100000
+#define  GRC_MODE_NO_RX_PHDR_CSUM	0x00800000
+#define  GRC_MODE_IRQ_ON_TX_CPU_ATTN	0x01000000
+#define  GRC_MODE_IRQ_ON_RX_CPU_ATTN	0x02000000
+#define  GRC_MODE_IRQ_ON_MAC_ATTN	0x04000000
+#define  GRC_MODE_IRQ_ON_DMA_ATTN	0x08000000
+#define  GRC_MODE_IRQ_ON_FLOW_ATTN	0x10000000
+#define  GRC_MODE_4X_NIC_SEND_RINGS	0x20000000
+#define  GRC_MODE_MCAST_FRM_ENABLE	0x40000000
+#define GRC_MISC_CFG			0x00006804
+#define  GRC_MISC_CFG_CORECLK_RESET	0x00000001
+#define  GRC_MISC_CFG_PRESCALAR_MASK	0x000000fe
+#define  GRC_MISC_CFG_PRESCALAR_SHIFT	1
+#define  GRC_MISC_CFG_BOARD_ID_MASK	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5700	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5701	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5702FE	0x00004000
+#define  GRC_MISC_CFG_BOARD_ID_5703	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5703S	0x00002000
+#define GRC_LOCAL_CTRL			0x00006808
+#define  GRC_LCLCTRL_INT_ACTIVE		0x00000001
+#define  GRC_LCLCTRL_CLEARINT		0x00000002
+#define  GRC_LCLCTRL_SETINT		0x00000004
+#define  GRC_LCLCTRL_INT_ON_ATTN	0x00000008
+#define  GRC_LCLCTRL_GPIO_INPUT0	0x00000100
+#define  GRC_LCLCTRL_GPIO_INPUT1	0x00000200
+#define  GRC_LCLCTRL_GPIO_INPUT2	0x00000400
+#define  GRC_LCLCTRL_GPIO_OE0		0x00000800
+#define  GRC_LCLCTRL_GPIO_OE1		0x00001000
+#define  GRC_LCLCTRL_GPIO_OE2		0x00002000
+#define  GRC_LCLCTRL_GPIO_OUTPUT0	0x00004000
+#define  GRC_LCLCTRL_GPIO_OUTPUT1	0x00008000
+#define  GRC_LCLCTRL_GPIO_OUTPUT2	0x00010000
+#define  GRC_LCLCTRL_EXTMEM_ENABLE	0x00020000
+#define  GRC_LCLCTRL_MEMSZ_MASK		0x001c0000
+#define  GRC_LCLCTRL_MEMSZ_256K		0x00000000
+#define  GRC_LCLCTRL_MEMSZ_512K		0x00040000
+#define  GRC_LCLCTRL_MEMSZ_1M		0x00080000
+#define  GRC_LCLCTRL_MEMSZ_2M		0x000c0000
+#define  GRC_LCLCTRL_MEMSZ_4M		0x00100000
+#define  GRC_LCLCTRL_MEMSZ_8M		0x00140000
+#define  GRC_LCLCTRL_MEMSZ_16M		0x00180000
+#define  GRC_LCLCTRL_BANK_SELECT	0x00200000
+#define  GRC_LCLCTRL_SSRAM_TYPE		0x00400000
+#define  GRC_LCLCTRL_AUTO_SEEPROM	0x01000000
+#define GRC_TIMER			0x0000680c
+#define GRC_RX_CPU_EVENT		0x00006810
+#define GRC_RX_TIMER_REF		0x00006814
+#define GRC_RX_CPU_SEM			0x00006818
+#define GRC_REMOTE_RX_CPU_ATTN		0x0000681c
+#define GRC_TX_CPU_EVENT		0x00006820
+#define GRC_TX_TIMER_REF		0x00006824
+#define GRC_TX_CPU_SEM			0x00006828
+#define GRC_REMOTE_TX_CPU_ATTN		0x0000682c
+#define GRC_MEM_POWER_UP		0x00006830 /* 64-bit */
+#define GRC_EEPROM_ADDR			0x00006838
+#define  EEPROM_ADDR_WRITE		0x00000000
+#define  EEPROM_ADDR_READ		0x80000000
+#define  EEPROM_ADDR_COMPLETE		0x40000000
+#define  EEPROM_ADDR_FSM_RESET		0x20000000
+#define  EEPROM_ADDR_DEVID_MASK		0x1c000000
+#define  EEPROM_ADDR_DEVID_SHIFT	26
+#define  EEPROM_ADDR_START		0x02000000
+#define  EEPROM_ADDR_CLKPERD_SHIFT	16
+#define  EEPROM_ADDR_ADDR_MASK		0x0000ffff
+#define  EEPROM_ADDR_ADDR_SHIFT		0
+#define  EEPROM_DEFAULT_CLOCK_PERIOD	0x60
+#define  EEPROM_CHIP_SIZE		(64 * 1024)
+#define GRC_EEPROM_DATA			0x0000683c
+#define GRC_EEPROM_CTRL			0x00006840
+#define GRC_MDI_CTRL			0x00006844
+#define GRC_SEEPROM_DELAY		0x00006848
+/* 0x684c --> 0x6c00 unused */
+
+/* 0x6c00 --> 0x7000 unused */
+
+/* NVRAM Control registers */
+#define NVRAM_CMD			0x00007000
+#define  NVRAM_CMD_RESET		 0x00000001
+#define  NVRAM_CMD_DONE			 0x00000008
+#define  NVRAM_CMD_GO			 0x00000010
+#define  NVRAM_CMD_WR			 0x00000020
+#define  NVRAM_CMD_RD			 0x00000000
+#define  NVRAM_CMD_ERASE		 0x00000040
+#define  NVRAM_CMD_FIRST		 0x00000080
+#define  NVRAM_CMD_LAST			 0x00000100
+#define NVRAM_STAT			0x00007004
+#define NVRAM_WRDATA			0x00007008
+#define NVRAM_ADDR			0x0000700c
+#define  NVRAM_ADDR_MSK			0x00ffffff
+#define NVRAM_RDDATA			0x00007010
+#define NVRAM_CFG1			0x00007014
+#define  NVRAM_CFG1_FLASHIF_ENAB	 0x00000001
+#define  NVRAM_CFG1_BUFFERED_MODE	 0x00000002
+#define  NVRAM_CFG1_PASS_THRU		 0x00000004
+#define  NVRAM_CFG1_BIT_BANG		 0x00000008
+#define  NVRAM_CFG1_COMPAT_BYPASS	 0x80000000
+#define NVRAM_CFG2			0x00007018
+#define NVRAM_CFG3			0x0000701c
+#define NVRAM_SWARB			0x00007020
+#define  SWARB_REQ_SET0			 0x00000001
+#define  SWARB_REQ_SET1			 0x00000002
+#define  SWARB_REQ_SET2			 0x00000004
+#define  SWARB_REQ_SET3			 0x00000008
+#define  SWARB_REQ_CLR0			 0x00000010
+#define  SWARB_REQ_CLR1			 0x00000020
+#define  SWARB_REQ_CLR2			 0x00000040
+#define  SWARB_REQ_CLR3			 0x00000080
+#define  SWARB_GNT0			 0x00000100
+#define  SWARB_GNT1			 0x00000200
+#define  SWARB_GNT2			 0x00000400
+#define  SWARB_GNT3			 0x00000800
+#define  SWARB_REQ0			 0x00001000
+#define  SWARB_REQ1			 0x00002000
+#define  SWARB_REQ2			 0x00004000
+#define  SWARB_REQ3			 0x00008000
+#define    NVRAM_BUFFERED_PAGE_SIZE	   264
+#define    NVRAM_BUFFERED_PAGE_POS	   9
+/* 0x7024 --> 0x7400 unused */
+
+/* 0x7400 --> 0x8000 unused */
+
+/* 32K Window into NIC internal memory */
+#define NIC_SRAM_WIN_BASE		0x00008000
+
+/* Offsets into first 32k of NIC internal memory. */
+#define NIC_SRAM_PAGE_ZERO		0x00000000
+#define NIC_SRAM_SEND_RCB		0x00000100 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_RCV_RET_RCB		0x00000200 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_STATS_BLK		0x00000300
+#define NIC_SRAM_STATUS_BLK		0x00000b00
+
+#define NIC_SRAM_FIRMWARE_MBOX		0x00000b50
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC1	 0x4B657654
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC2	 0x4861764b /* !dma on linkchg */
+
+#define NIC_SRAM_DATA_SIG		0x00000b54
+#define  NIC_SRAM_DATA_SIG_MAGIC	 0x4b657654 /* ascii for 'KevT' */
+
+#define NIC_SRAM_DATA_CFG			0x00000b58
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_MASK	 0x0000000c
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_COPPER	 0x00000004
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER	 0x00000008
+#define  NIC_SRAM_DATA_CFG_LED_MODE_MASK	 0x00000030
+#define  NIC_SRAM_DATA_CFG_LED_MODE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD	 0x00000010
+#define  NIC_SRAM_DATA_CFG_LED_LINK_SPD		 0x00000020
+
+#define NIC_SRAM_DATA_PHY_ID		0x00000b74
+#define  NIC_SRAM_DATA_PHY_ID1_MASK	 0xffff0000
+#define  NIC_SRAM_DATA_PHY_ID2_MASK	 0x0000ffff
+
+#define NIC_SRAM_FW_CMD_MBOX		0x00000b78
+#define  FWCMD_NICDRV_ALIVE		 0x00000001
+#define  FWCMD_NICDRV_PAUSE_FW		 0x00000002
+#define  FWCMD_NICDRV_IPV4ADDR_CHG	 0x00000003
+#define  FWCMD_NICDRV_IPV6ADDR_CHG	 0x00000004
+#define  FWCMD_NICDRV_FIX_DMAR		 0x00000005
+#define  FWCMD_NICDRV_FIX_DMAW		 0x00000006
+#define NIC_SRAM_FW_CMD_LEN_MBOX	0x00000b7c
+#define NIC_SRAM_FW_CMD_DATA_MBOX	0x00000b80
+#define NIC_SRAM_FW_ASF_STATUS_MBOX	0x00000c00
+#define NIC_SRAM_FW_DRV_STATE_MBOX	0x00000c04
+#define  DRV_STATE_START		 0x00000001
+#define  DRV_STATE_UNLOAD		 0x00000002
+#define  DRV_STATE_WOL			 0x00000003
+#define  DRV_STATE_SUSPEND		 0x00000004
+
+#define NIC_SRAM_FW_RESET_TYPE_MBOX	0x00000c08
+
+#define NIC_SRAM_MAC_ADDR_HIGH_MBOX	0x00000c14
+#define NIC_SRAM_MAC_ADDR_LOW_MBOX	0x00000c18
+
+#if TG3_MINI_RING_WORKS
+#define NIC_SRAM_RX_MINI_BUFFER_DESC	0x00001000
+#endif
+
+#define NIC_SRAM_DMA_DESC_POOL_BASE	0x00002000
+#define  NIC_SRAM_DMA_DESC_POOL_SIZE	 0x00002000
+#define NIC_SRAM_TX_BUFFER_DESC		0x00004000 /* 512 entries */
+#define NIC_SRAM_RX_BUFFER_DESC		0x00006000 /* 256 entries */
+#define NIC_SRAM_RX_JUMBO_BUFFER_DESC	0x00007000 /* 256 entries */
+#define NIC_SRAM_MBUF_POOL_BASE		0x00008000
+#define  NIC_SRAM_MBUF_POOL_SIZE	 0x00018000
+
+/* Currently this is fixed. */
+#define PHY_ADDR		0x01
+
+/* Tigon3 specific PHY MII registers. */
+#define  TG3_BMCR_SPEED1000		0x0040
+
+#define MII_TG3_CTRL			0x09 /* 1000-baseT control register */
+#define  MII_TG3_CTRL_ADV_1000_HALF	0x0100
+#define  MII_TG3_CTRL_ADV_1000_FULL	0x0200
+#define  MII_TG3_CTRL_AS_MASTER		0x0800
+#define  MII_TG3_CTRL_ENABLE_AS_MASTER	0x1000
+
+#define MII_TG3_EXT_CTRL		0x10 /* Extended control register */
+#define  MII_TG3_EXT_CTRL_LNK3_LED_MODE	0x0002
+#define  MII_TG3_EXT_CTRL_TBI		0x8000
+
+#define MII_TG3_EXT_STAT		0x11 /* Extended status register */
+#define  MII_TG3_EXT_STAT_LPASS		0x0100
+
+#define MII_TG3_DSP_RW_PORT		0x15 /* DSP coefficient read/write port */
+
+#define MII_TG3_DSP_ADDRESS		0x17 /* DSP address register */
+
+#define MII_TG3_AUX_CTRL		0x18 /* auxilliary control register */
+
+#define MII_TG3_AUX_STAT		0x19 /* auxilliary status register */
+#define MII_TG3_AUX_STAT_LPASS		0x0004
+#define MII_TG3_AUX_STAT_SPDMASK	0x0700
+#define MII_TG3_AUX_STAT_10HALF		0x0100
+#define MII_TG3_AUX_STAT_10FULL		0x0200
+#define MII_TG3_AUX_STAT_100HALF	0x0300
+#define MII_TG3_AUX_STAT_100_4		0x0400
+#define MII_TG3_AUX_STAT_100FULL	0x0500
+#define MII_TG3_AUX_STAT_1000HALF	0x0600
+#define MII_TG3_AUX_STAT_1000FULL	0x0700
+
+#define MII_TG3_ISTAT			0x1a /* IRQ status register */
+#define MII_TG3_IMASK			0x1b /* IRQ mask register */
+
+/* ISTAT/IMASK event bits */
+#define MII_TG3_INT_LINKCHG		0x0002
+#define MII_TG3_INT_SPEEDCHG		0x0004
+#define MII_TG3_INT_DUPLEXCHG		0x0008
+#define MII_TG3_INT_ANEG_PAGE_RX	0x0400
+
+/* XXX Add this to mii.h */
+#ifndef ADVERTISE_PAUSE
+#define ADVERTISE_PAUSE_CAP		0x0400
+#endif
+#ifndef ADVERTISE_PAUSE_ASYM
+#define ADVERTISE_PAUSE_ASYM		0x0800
+#endif
+#ifndef LPA_PAUSE
+#define LPA_PAUSE_CAP			0x0400
+#endif
+#ifndef LPA_PAUSE_ASYM
+#define LPA_PAUSE_ASYM			0x0800
+#endif
+
+/* There are two ways to manage the TX descriptors on the tigon3.
+ * Either the descriptors are in host DMA'able memory, or they
+ * exist only in the cards on-chip SRAM.  All 16 send bds are under
+ * the same mode, they may not be configured individually.
+ *
+ * The mode we use is controlled by TG3_FLAG_HOST_TXDS in tp->tg3_flags.
+ *
+ * To use host memory TX descriptors:
+ *	1) Set GRC_MODE_HOST_SENDBDS in GRC_MODE register.
+ *	   Make sure GRC_MODE_4X_NIC_SEND_RINGS is clear.
+ *	2) Allocate DMA'able memory.
+ *	3) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to DMA address of memory
+ *	      obtained in step 2
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC.
+ *	   c) Set len field of TG3_BDINFO_MAXLEN_FLAGS to number
+ *            of TX descriptors.  Leave flags field clear.
+ *	4) Access TX descriptors via host memory.  The chip
+ *	   will refetch into local SRAM as needed when producer
+ *	   index mailboxes are updated.
+ *
+ * To use on-chip TX descriptors:
+ *	1) Set GRC_MODE_4X_NIC_SEND_RINGS in GRC_MODE register.
+ *	   Make sure GRC_MODE_HOST_SENDBDS is clear.
+ *	2) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to zero.
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC
+ *	   c) TG3_BDINFO_MAXLEN_FLAGS is don't care.
+ *	3) Access TX descriptors directly in on-chip SRAM
+ *	   using normal {read,write}l().  (and not using
+ *         pointer dereferencing of ioremap()'d memory like
+ *	   the broken Broadcom driver does)
+ *
+ * Note that BDINFO_FLAGS_DISABLED should be set in the flags field of
+ * TG3_BDINFO_MAXLEN_FLAGS of all unused SEND_RCB indices.
+ */
+struct tg3_tx_buffer_desc {
+	u32				addr_hi;
+	u32				addr_lo;
+
+	u32				len_flags;
+#define TXD_FLAG_TCPUDP_CSUM		0x0001
+#define TXD_FLAG_IP_CSUM		0x0002
+#define TXD_FLAG_END			0x0004
+#define TXD_FLAG_IP_FRAG		0x0008
+#define TXD_FLAG_IP_FRAG_END		0x0010
+#define TXD_FLAG_VLAN			0x0040
+#define TXD_FLAG_COAL_NOW		0x0080
+#define TXD_FLAG_CPU_PRE_DMA		0x0100
+#define TXD_FLAG_CPU_POST_DMA		0x0200
+#define TXD_FLAG_ADD_SRC_ADDR		0x1000
+#define TXD_FLAG_CHOOSE_SRC_ADDR	0x6000
+#define TXD_FLAG_NO_CRC			0x8000
+#define TXD_LEN_SHIFT			16
+
+	u32				vlan_tag;
+#define TXD_VLAN_TAG_SHIFT		0
+};
+
+#define TXD_ADDR			0x00UL /* 64-bit */
+#define TXD_LEN_FLAGS			0x08UL /* 32-bit (upper 16-bits are len) */
+#define TXD_VLAN_TAG			0x0cUL /* 32-bit (upper 16-bits are tag) */
+#define TXD_SIZE			0x10UL
+
+struct tg3_rx_buffer_desc {
+	u32				addr_hi;
+	u32				addr_lo;
+
+	u32				idx_len;
+#define RXD_IDX_MASK	0xffff0000
+#define RXD_IDX_SHIFT	16
+#define RXD_LEN_MASK	0x0000ffff
+#define RXD_LEN_SHIFT	0
+
+	u32				type_flags;
+#define RXD_TYPE_SHIFT	16
+#define RXD_FLAGS_SHIFT	0
+
+#define RXD_FLAG_END			0x0004
+#if TG3_MINI_RING_WORKS
+#define RXD_FLAG_MINI			0x0800
+#endif
+#define RXD_FLAG_JUMBO			0x0020
+#define RXD_FLAG_VLAN			0x0040
+#define RXD_FLAG_ERROR			0x0400
+#define RXD_FLAG_IP_CSUM		0x1000
+#define RXD_FLAG_TCPUDP_CSUM		0x2000
+#define RXD_FLAG_IS_TCP			0x4000
+
+	u32				ip_tcp_csum;
+#define RXD_IPCSUM_MASK		0xffff0000
+#define RXD_IPCSUM_SHIFT	16
+#define RXD_TCPCSUM_MASK	0x0000ffff
+#define RXD_TCPCSUM_SHIFT	0
+
+	u32				err_vlan;
+
+#define RXD_VLAN_MASK			0x0000ffff
+
+#define RXD_ERR_BAD_CRC			0x00010000
+#define RXD_ERR_COLLISION		0x00020000
+#define RXD_ERR_LINK_LOST		0x00040000
+#define RXD_ERR_PHY_DECODE		0x00080000
+#define RXD_ERR_ODD_NIBBLE_RCVD_MII	0x00100000
+#define RXD_ERR_MAC_ABRT		0x00200000
+#define RXD_ERR_TOO_SMALL		0x00400000
+#define RXD_ERR_NO_RESOURCES		0x00800000
+#define RXD_ERR_HUGE_FRAME		0x01000000
+#define RXD_ERR_MASK			0xffff0000
+
+	u32				reserved;
+	u32				opaque;
+#define RXD_OPAQUE_INDEX_MASK		0x0000ffff
+#define RXD_OPAQUE_INDEX_SHIFT		0
+#define RXD_OPAQUE_RING_STD		0x00010000
+#define RXD_OPAQUE_RING_JUMBO		0x00020000
+#if TG3_MINI_RING_WORKS
+#define RXD_OPAQUE_RING_MINI		0x00040000
+#endif
+#define RXD_OPAQUE_RING_MASK		0x00070000
+};
+
+struct tg3_ext_rx_buffer_desc {
+	struct {
+		u32			addr_hi;
+		u32			addr_lo;
+	}				addrlist[3];
+	u32				len2_len1;
+	u32				resv_len3;
+	struct tg3_rx_buffer_desc	std;
+};
+
+/* We only use this when testing out the DMA engine
+ * at probe time.  This is the internal format of buffer
+ * descriptors used by the chip at NIC_SRAM_DMA_DESCS.
+ */
+struct tg3_internal_buffer_desc {
+	u32				addr_hi;
+	u32				addr_lo;
+	u32				nic_mbuf;
+	/* XXX FIX THIS */
+#ifdef __BIG_ENDIAN
+	u16				cqid_sqid;
+	u16				len;
+#else
+	u16				len;
+	u16				cqid_sqid;
+#endif
+	u32				flags;
+	u32				__cookie1;
+	u32				__cookie2;
+	u32				__cookie3;
+};
+
+#define TG3_HW_STATUS_SIZE		0x80
+struct tg3_hw_status {
+	u32				status;
+#define SD_STATUS_UPDATED		0x00000001
+#define SD_STATUS_LINK_CHG		0x00000002
+#define SD_STATUS_ERROR			0x00000004
+
+	u32				status_tag;
+
+#ifdef __BIG_ENDIAN
+	u16				rx_consumer;
+	u16				rx_jumbo_consumer;
+#else
+	u16				rx_jumbo_consumer;
+	u16				rx_consumer;
+#endif
+
+#ifdef __BIG_ENDIAN
+	u16				reserved;
+	u16				rx_mini_consumer;
+#else
+	u16				rx_mini_consumer;
+	u16				reserved;
+#endif
+	struct {
+#ifdef __BIG_ENDIAN
+		u16			tx_consumer;
+		u16			rx_producer;
+#else
+		u16			rx_producer;
+		u16			tx_consumer;
+#endif
+	}				idx[16];
+};
+
+typedef struct {
+	u32 high, low;
+} tg3_stat64_t;
+
+struct tg3_hw_stats {
+	u8				__reserved0[0x400-0x300];
+
+	/* Statistics maintained by Receive MAC. */
+	tg3_stat64_t			rx_octets;
+	u64				__reserved1;
+	tg3_stat64_t			rx_fragments;
+	tg3_stat64_t			rx_ucast_packets;
+	tg3_stat64_t			rx_mcast_packets;
+	tg3_stat64_t			rx_bcast_packets;
+	tg3_stat64_t			rx_fcs_errors;
+	tg3_stat64_t			rx_align_errors;
+	tg3_stat64_t			rx_xon_pause_rcvd;
+	tg3_stat64_t			rx_xoff_pause_rcvd;
+	tg3_stat64_t			rx_mac_ctrl_rcvd;
+	tg3_stat64_t			rx_xoff_entered;
+	tg3_stat64_t			rx_frame_too_long_errors;
+	tg3_stat64_t			rx_jabbers;
+	tg3_stat64_t			rx_undersize_packets;
+	tg3_stat64_t			rx_in_length_errors;
+	tg3_stat64_t			rx_out_length_errors;
+	tg3_stat64_t			rx_64_or_less_octet_packets;
+	tg3_stat64_t			rx_65_to_127_octet_packets;
+	tg3_stat64_t			rx_128_to_255_octet_packets;
+	tg3_stat64_t			rx_256_to_511_octet_packets;
+	tg3_stat64_t			rx_512_to_1023_octet_packets;
+	tg3_stat64_t			rx_1024_to_1522_octet_packets;
+	tg3_stat64_t			rx_1523_to_2047_octet_packets;
+	tg3_stat64_t			rx_2048_to_4095_octet_packets;
+	tg3_stat64_t			rx_4096_to_8191_octet_packets;
+	tg3_stat64_t			rx_8192_to_9022_octet_packets;
+
+	u64				__unused0[37];
+
+	/* Statistics maintained by Transmit MAC. */
+	tg3_stat64_t			tx_octets;
+	u64				__reserved2;
+	tg3_stat64_t			tx_collisions;
+	tg3_stat64_t			tx_xon_sent;
+	tg3_stat64_t			tx_xoff_sent;
+	tg3_stat64_t			tx_flow_control;
+	tg3_stat64_t			tx_mac_errors;
+	tg3_stat64_t			tx_single_collisions;
+	tg3_stat64_t			tx_mult_collisions;
+	tg3_stat64_t			tx_deferred;
+	u64				__reserved3;
+	tg3_stat64_t			tx_excessive_collisions;
+	tg3_stat64_t			tx_late_collisions;
+	tg3_stat64_t			tx_collide_2times;
+	tg3_stat64_t			tx_collide_3times;
+	tg3_stat64_t			tx_collide_4times;
+	tg3_stat64_t			tx_collide_5times;
+	tg3_stat64_t			tx_collide_6times;
+	tg3_stat64_t			tx_collide_7times;
+	tg3_stat64_t			tx_collide_8times;
+	tg3_stat64_t			tx_collide_9times;
+	tg3_stat64_t			tx_collide_10times;
+	tg3_stat64_t			tx_collide_11times;
+	tg3_stat64_t			tx_collide_12times;
+	tg3_stat64_t			tx_collide_13times;
+	tg3_stat64_t			tx_collide_14times;
+	tg3_stat64_t			tx_collide_15times;
+	tg3_stat64_t			tx_ucast_packets;
+	tg3_stat64_t			tx_mcast_packets;
+	tg3_stat64_t			tx_bcast_packets;
+	tg3_stat64_t			tx_carrier_sense_errors;
+	tg3_stat64_t			tx_discards;
+	tg3_stat64_t			tx_errors;
+
+	u64				__unused1[31];
+
+	/* Statistics maintained by Receive List Placement. */
+	tg3_stat64_t			COS_rx_packets[16];
+	tg3_stat64_t			COS_rx_filter_dropped;
+	tg3_stat64_t			dma_writeq_full;
+	tg3_stat64_t			dma_write_prioq_full;
+	tg3_stat64_t			rxbds_empty;
+	tg3_stat64_t			rx_discards;
+	tg3_stat64_t			rx_errors;
+	tg3_stat64_t			rx_threshold_hit;
+
+	u64				__unused2[9];
+
+	/* Statistics maintained by Send Data Initiator. */
+	tg3_stat64_t			COS_out_packets[16];
+	tg3_stat64_t			dma_readq_full;
+	tg3_stat64_t			dma_read_prioq_full;
+	tg3_stat64_t			tx_comp_queue_full;
+
+	/* Statistics maintained by Host Coalescing. */
+	tg3_stat64_t			ring_set_send_prod_index;
+	tg3_stat64_t			ring_status_update;
+	tg3_stat64_t			nic_irqs;
+	tg3_stat64_t			nic_avoided_irqs;
+	tg3_stat64_t			nic_tx_threshold_hit;
+
+	u8				__reserved4[0xb00-0x9c0];
+};
+
+enum phy_led_mode {
+	led_mode_auto,
+	led_mode_three_link,
+	led_mode_link10
+};
+
+/* 'mapping' is superfluous as the chip does not write into
+ * the tx/rx post rings so we could just fetch it from there.
+ * But the cache behavior is better how we are doing it now.
+ */
+struct ring_info {
+	struct sk_buff			*skb;
+	DECLARE_PCI_UNMAP_ADDR(mapping)
+};
+
+struct tg3_config_info {
+	u32				flags;
+};
+
+struct tg3_link_config {
+	/* Describes what we're trying to get. */
+	u32				advertising;
+	u16				speed;
+	u8				duplex;
+	u8				autoneg;
+
+	/* Describes what we actually have. */
+	u16				active_speed;
+	u8				active_duplex;
+#define SPEED_INVALID		0xffff
+#define DUPLEX_INVALID		0xff
+#define AUTONEG_INVALID		0xff
+
+	/* When we go in and out of low power mode we need
+	 * to swap with this state.
+	 */
+	int				phy_is_low_power;
+	u16				orig_speed;
+	u8				orig_duplex;
+	u8				orig_autoneg;
+};
+
+struct tg3_coalesce_config {
+	/* Current settings. */
+	u32		rx_coalesce_ticks;
+	u32		rx_max_coalesced_frames;
+	u32		rx_coalesce_ticks_during_int;
+	u32		rx_max_coalesced_frames_during_int;
+	u32		tx_coalesce_ticks;
+	u32		tx_max_coalesced_frames;
+	u32		tx_coalesce_ticks_during_int;
+	u32		tx_max_coalesced_frames_during_int;
+	u32		stats_coalesce_ticks;
+
+	/* Default settings. */
+	u32		rx_coalesce_ticks_def;
+	u32		rx_max_coalesced_frames_def;
+	u32		rx_coalesce_ticks_during_int_def;
+	u32		rx_max_coalesced_frames_during_int_def;
+	u32		tx_coalesce_ticks_def;
+	u32		tx_max_coalesced_frames_def;
+	u32		tx_coalesce_ticks_during_int_def;
+	u32		tx_max_coalesced_frames_during_int_def;
+	u32		stats_coalesce_ticks_def;
+
+	/* Adaptive RX/TX coalescing parameters. */
+	u32		rate_sample_jiffies;
+	u32		pkt_rate_low;
+	u32		pkt_rate_high;
+
+	u32		rx_coalesce_ticks_low;
+	u32		rx_max_coalesced_frames_low;
+	u32		tx_coalesce_ticks_low;
+	u32		tx_max_coalesced_frames_low;
+
+	u32		rx_coalesce_ticks_high;
+	u32		rx_max_coalesced_frames_high;
+	u32		tx_coalesce_ticks_high;
+	u32		tx_max_coalesced_frames_high;
+};
+
+struct tg3_bufmgr_config {
+	u32		mbuf_read_dma_low_water;
+	u32		mbuf_mac_rx_low_water;
+	u32		mbuf_high_water;
+
+	u32		mbuf_read_dma_low_water_jumbo;
+	u32		mbuf_mac_rx_low_water_jumbo;
+	u32		mbuf_high_water_jumbo;
+
+	u32		dma_low_water;
+	u32		dma_high_water;
+};
+
+struct tg3 {
+	spinlock_t			lock;
+	u32				tx_prod;
+	u32				tx_cons;
+	u32				rx_rcb_ptr;
+	u32				rx_std_ptr;
+	u32				rx_jumbo_ptr;
+#if TG3_MINI_RING_WORKS
+	u32				rx_mini_ptr;
+#endif
+	spinlock_t			indirect_lock;
+
+	struct net_device_stats		net_stats;
+	struct net_device_stats		net_stats_prev;
+	unsigned long			phy_crc_errors;
+
+	/* Adaptive coalescing engine. */
+	unsigned long			last_rate_sample;
+	u32				last_rx_count;
+	u32				last_tx_count;
+
+	u32				rx_offset;
+	u32				tg3_flags;
+#define TG3_FLAG_HOST_TXDS		0x00000001
+#define TG3_FLAG_TXD_MBOX_HWBUG		0x00000002
+#define TG3_FLAG_RX_CHECKSUMS		0x00000004
+#define TG3_FLAG_USE_LINKCHG_REG	0x00000008
+#define TG3_FLAG_USE_MI_INTERRUPT	0x00000010
+#define TG3_FLAG_ADAPTIVE_RX		0x00000020
+#define TG3_FLAG_ADAPTIVE_TX		0x00000040
+#define TG3_FLAG_PHY_RESET_ON_INIT	0x00000100
+#define TG3_FLAG_PCIX_TARGET_HWBUG	0x00000200
+#define TG3_FLAG_TAGGED_IRQ_STATUS	0x00000400
+#define TG3_FLAG_WOL_SPEED_100MB	0x00000800
+#define TG3_FLAG_WOL_ENABLE		0x00001000
+#define TG3_FLAG_NVRAM			0x00002000
+#define TG3_FLAG_NVRAM_BUFFERED		0x00004000
+#define TG3_FLAG_RX_PAUSE		0x00008000
+#define TG3_FLAG_TX_PAUSE		0x00010000
+#define TG3_FLAG_PCIX_MODE		0x00020000
+#define TG3_FLAG_PCI_HIGH_SPEED		0x00040000
+#define TG3_FLAG_PCI_32BIT		0x00080000
+#define TG3_FLAG_NO_TX_PSEUDO_CSUM	0x00100000
+#define TG3_FLAG_NO_RX_PSEUDO_CSUM	0x00200000
+#define TG3_FLAG_AUTONEG_DISABLE	0x00400000
+#define TG3_FLAG_JUMBO_ENABLE		0x00800000
+#define TG3_FLAG_10_100_ONLY		0x01000000
+#define TG3_FLAG_PAUSE_AUTONEG		0x02000000
+#define TG3_FLAG_PAUSE_RX		0x04000000
+#define TG3_FLAG_PAUSE_TX		0x08000000
+#define TG3_FLAG_BROKEN_CHECKSUMS	0x10000000
+#define TG3_FLAG_INIT_COMPLETE		0x80000000
+
+	u32				msg_enable;
+
+	struct timer_list		timer;
+	u16				timer_counter;
+	u16				timer_multiplier;
+	u32				timer_offset;
+
+	struct tg3_link_config		link_config;
+	struct tg3_coalesce_config	coalesce_config;
+	struct tg3_bufmgr_config	bufmgr_config;
+
+	u32				rx_pending;
+#if TG3_MINI_RING_WORKS
+	u32				rx_mini_pending;
+#endif
+	u32				rx_jumbo_pending;
+	u32				tx_pending;
+
+	/* cache h/w values, often passed straight to h/w */
+	u32				rx_mode;
+	u32				tx_mode;
+	u32				mac_mode;
+	u32				mi_mode;
+	u32				misc_host_ctrl;
+	u32				grc_mode;
+	u32				grc_local_ctrl;
+	u32				dma_rwctrl;
+	u32				coalesce_mode;
+
+	/* PCI block */
+	u16				pci_chip_rev_id;
+	u8				pci_cacheline_sz;
+	u8				pci_lat_timer;
+	u8				pci_hdr_type;
+	u8				pci_bist;
+	u32				pci_cfg_state[64 / sizeof(u32)];
+
+	int				pm_cap;
+
+	/* PHY info */
+	u32				phy_id;
+#define PHY_ID_MASK			0xfffffff0
+#define PHY_ID_BCM5400			0x60008040
+#define PHY_ID_BCM5401			0x60008050
+#define PHY_ID_BCM5411			0x60008070
+#define PHY_ID_BCM5701			0x60008110
+#define PHY_ID_BCM5703			0x60008160
+#define PHY_ID_BCM8002			0x60010140
+#define PHY_ID_SERDES			0xfeedbee0
+#define PHY_ID_INVALID			0xffffffff
+#define PHY_ID_REV_MASK			0x0000000f
+#define PHY_REV_BCM5401_B0		0x1
+#define PHY_REV_BCM5401_B2		0x3
+#define PHY_REV_BCM5401_C0		0x6
+
+	enum phy_led_mode		led_mode;
+
+	char				board_part_number[24];
+
+	/* This macro assumes the passed PHY ID is already masked
+	 * with PHY_ID_MASK.
+	 */
+#define KNOWN_PHY_ID(X)		\
+	((X) == PHY_ID_BCM5400 || (X) == PHY_ID_BCM5401 || \
+	 (X) == PHY_ID_BCM5411 || (X) == PHY_ID_BCM5701 || \
+	 (X) == PHY_ID_BCM5703 ||			   \
+	 (X) == PHY_ID_BCM8002 || (X) == PHY_ID_SERDES)
+
+	unsigned long			regs;
+	struct pci_dev			*pdev;
+	struct net_device		*dev;
+#if TG3_VLAN_TAG_USED
+	struct vlan_group		*vlgrp;
+#endif
+
+	struct tg3_rx_buffer_desc	*rx_std;
+	struct ring_info		*rx_std_buffers;
+	dma_addr_t			rx_std_mapping;
+#if TG3_MINI_RING_WORKS
+	struct tg3_rx_buffer_desc	*rx_mini;
+	struct ring_info		*rx_mini_buffers;
+	dma_addr_t			rx_mini_mapping;
+#endif
+	struct tg3_rx_buffer_desc	*rx_jumbo;
+	struct ring_info		*rx_jumbo_buffers;
+	dma_addr_t			rx_jumbo_mapping;
+
+	struct tg3_rx_buffer_desc	*rx_rcb;
+	dma_addr_t			rx_rcb_mapping;
+
+	/* TX descs are only used if TG3_FLAG_HOST_TXDS is set. */
+	struct tg3_tx_buffer_desc	*tx_ring;
+	struct ring_info		*tx_buffers;
+	dma_addr_t			tx_desc_mapping;
+
+	struct tg3_hw_status		*hw_status;
+	dma_addr_t			status_mapping;
+
+	struct tg3_hw_stats		*hw_stats;
+	dma_addr_t			stats_mapping;
+};
+
+#endif /* !(_T3_H) */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/net/tulip/media.c linux/drivers/net/tulip/media.c
--- ../prev/linux/drivers/net/tulip/media.c	Tue Jul  9 18:04:28 2002
+++ linux/drivers/net/tulip/media.c	Wed May  8 14:10:00 2002
@@ -284,6 +284,10 @@
 				for (i = 0; i < init_length; i++)
 					outl(init_sequence[i], ioaddr + CSR12);
 			}
+
+			(void) inl(ioaddr + CSR6); /* flush CSR12 writes */
+			udelay(500);		/* Give MII time to recover */
+
 			tmp_info = get_u16(&misc_info[1]);
 			if (tmp_info)
 				tp->advertising[phy_num] = tmp_info | 1;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/scsi/megaraid.c linux/drivers/scsi/megaraid.c
--- ../prev/linux/drivers/scsi/megaraid.c	Tue Jul  9 18:04:34 2002
+++ linux/drivers/scsi/megaraid.c	Wed May 15 10:15:13 2002
@@ -2032,9 +2032,6 @@
 
 
 #if DEBUG
-static unsigned int cum_time = 0;
-static unsigned int cum_time_cnt = 0;
-
 static void showMbox (mega_scb * pScb)
 {
 	mega_mailbox *mbox;
@@ -2043,7 +2040,7 @@
 		return;
 
 	mbox = (mega_mailbox *) pScb->mboxData;
-	printk ("%u cmd:%x id:%x #scts:%x lba:%x addr:%x logdrv:%x #sg:%x\n",
+	printk ("%lu cmd:%x id:%x #scts:%x lba:%x addr:%x logdrv:%x #sg:%x\n",
 		pScb->SCpnt->pid,
 		mbox->cmd, mbox->cmdid, mbox->numsectors,
 		mbox->lba, mbox->xferaddr, mbox->logdrv, mbox->numsgelements);
@@ -2288,10 +2285,6 @@
 	phys_mbox = virt_to_bus (megaCfg->mbox);
 #endif
 
-#if DEBUG
-	ShowMbox (pScb);
-#endif
-
 	/* Wait until mailbox is free */
 	if (mega_busyWaitMbox (megaCfg)) {
 		printk ("Blocked mailbox......!!\n");
@@ -3032,9 +3025,7 @@
 					    sizeof (mega_mailbox64),
 					    &(megaCfg->dma_handle64));
 
-		mega_register_mailbox (megaCfg,
-				       virt_to_bus ((void *) megaCfg->
-						    mailbox64ptr));
+		mega_register_mailbox (megaCfg, megaCfg->dma_handle64);
 #else
 		mega_register_mailbox (megaCfg,
 				       virt_to_bus ((void *) &megaCfg->
@@ -3355,9 +3346,13 @@
 	mbox[0] = IS_BIOS_ENABLED;
 	mbox[2] = GET_BIOS;
 
-	mboxpnt->xferaddr = virt_to_bus ((void *) megacfg->mega_buffer);
+	mboxpnt->xferaddr = pci_map_single(megacfg->dev,
+				(void *) megacfg->mega_buffer, (2 * 1024L),
+				PCI_DMA_FROMDEVICE);
 
 	ret = megaIssueCmd (megacfg, mbox, NULL, 0);
+
+	pci_unmap_single(megacfg->dev, mboxpnt->xferaddr, 2 * 1024L, PCI_DMA_FROMDEVICE);
 
 	return (*(char *) megacfg->mega_buffer);
 }
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/drivers/scsi/sym53c8xx.c linux/drivers/scsi/sym53c8xx.c
--- ../prev/linux/drivers/scsi/sym53c8xx.c	Tue Jul  9 18:04:36 2002
+++ linux/drivers/scsi/sym53c8xx.c	Fri Apr 12 09:09:37 2002
@@ -12951,10 +12951,16 @@
 	j = 0;
 	count = 0;
 	pcidev = PCIDEV_NULL;
-	while (1) {
+#if 0
+	while (1)
+#else
+	pci_for_each_dev(pcidev)
+#endif
+	{
 		char *msg = "";
 		if (count >= hosts)
 			break;
+#if 0
 		if (j >= chips)
 			break;
 		i = driver_setup.reverse_probe ? chips - 1 - j : j;
@@ -12964,6 +12970,19 @@
 			++j;
 			continue;
 		}
+#else
+		if (pcidev->vendor != PCI_VENDOR_ID_NCR)
+			continue;
+
+		for (i=0; i < chips; i++) {
+			if (pcidev->device == ncr_chip_ids[i])
+				break;
+		}
+
+		if (i >= chips)
+			continue;
+#endif
+
 		if (pci_enable_device(pcidev)) /* @!*!$&*!%-*#;! */
 			continue;
 		/* Some HW as the HP LH4 may report twice PCI devices */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-i386/serial.h linux/include/asm-i386/serial.h
--- ../prev/linux/include/asm-i386/serial.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-i386/serial.h	Wed May 29 13:45:32 2002
@@ -57,6 +57,20 @@
 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
 	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
 
+/*
+ * HCDP_SERIAL_PORT_DEFNS should be placed in exactly the same slot 
+ * in rs_table as defined by HCDP_SERIAL_CONSOLE_PORT in 
+ * include/linux/serial.h
+ */
+#define HCDP_SERIAL_PORT_DEFNS	\
+	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS},		/* ttySx device
+							   in comments sucks.
+							   You add an entry
+							   and you get to edit 
+							   boatloads of these 
+							   comments. Not worth
+							   it */
+
 
 #ifdef CONFIG_SERIAL_MANY_PORTS
 #define EXTRA_SERIAL_PORT_DEFNS			\
@@ -126,6 +140,7 @@
 #endif
 
 #define SERIAL_PORT_DFNS		\
+	HCDP_SERIAL_PORT_DEFNS		\
 	STD_SERIAL_PORT_DEFNS		\
 	EXTRA_SERIAL_PORT_DEFNS		\
 	HUB6_SERIAL_PORT_DFNS		\
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/acpi.h linux/include/asm-ia64/acpi.h
--- ../prev/linux/include/asm-ia64/acpi.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/acpi.h	Fri May 31 11:41:58 2002
@@ -30,14 +30,78 @@
 
 #ifdef __KERNEL__
 
-#define __acpi_map_table(phys_addr, size) __va(phys_addr)
+#define COMPILER_DEPENDENT_INT64	long
+#define COMPILER_DEPENDENT_UINT64	unsigned long
+
+/*
+ * Calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#define ACPI_SYSTEM_XFACE
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+
+/* Asm macros */
+
+#define ACPI_ASM_MACROS
+#define BREAKPOINT3
+#define ACPI_DISABLE_IRQS() __cli()
+#define ACPI_ENABLE_IRQS()  __sti()
+#define ACPI_FLUSH_CPU_CACHE()
+
+#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
+	do { \
+	__asm__ volatile ("1:  ld4      r29=%1\n"  \
+		";;\n"                  \
+		"mov    ar.ccv=r29\n"   \
+		"mov    r2=r29\n"       \
+		"shr.u  r30=r29,1\n"    \
+		"and    r29=-4,r29\n"   \
+		";;\n"                  \
+		"add    r29=2,r29\n"    \
+		"and    r30=1,r30\n"    \
+		";;\n"                  \
+		"add    r29=r29,r30\n"  \
+		";;\n"                  \
+		"cmpxchg4.acq   r30=%1,r29,ar.ccv\n" \
+		";;\n"                  \
+		"cmp.eq p6,p7=r2,r30\n" \
+		"(p7) br.dpnt.few 1b\n" \
+		"cmp.gt p8,p9=3,r29\n"  \
+		";;\n"                  \
+		"(p8) mov %0=-1\n"      \
+		"(p9) mov %0=r0\n"      \
+		:"=r"(Acq):"m"(GLptr):"r2","r29","r30","memory"); \
+	} while (0)
+
+#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
+	do { \
+	__asm__ volatile ("1:  ld4      r29=%1\n" \
+		";;\n"                  \
+		"mov    ar.ccv=r29\n"   \
+		"mov    r2=r29\n"       \
+		"and    r29=-4,r29\n"   \
+		";;\n"                  \
+		"cmpxchg4.acq   r30=%1,r29,ar.ccv\n" \
+		";;\n"                  \
+		"cmp.eq p6,p7=r2,r30\n" \
+		"(p7) br.dpnt.few 1b\n" \
+		"and    %0=1,r2\n"      \
+		";;\n"                  \
+		:"=r"(Acq):"m"(GLptr):"r2","r29","r30","memory"); \
+	} while (0)
 
 const char *acpi_get_sysname (void);
 int acpi_boot_init (char *cdline);
-int acpi_find_rsdp (unsigned long *phys_addr);
 int acpi_request_vector (u32 int_type);
 int acpi_get_prt (struct pci_vector_struct **vectors, int *count);
 int acpi_get_interrupt_model(int *type);
+int acpi_register_irq(u32 gsi, u32 polarity, u32 trigger);
 
 #ifdef CONFIG_DISCONTIGMEM
 #define NODE_ARRAY_INDEX(x)	((x) / 8)	/* 8 bits/char */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/efi.h linux/include/asm-ia64/efi.h
--- ../prev/linux/include/asm-ia64/efi.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/efi.h	Thu May 23 11:19:25 2002
@@ -190,6 +190,10 @@
 #define SAL_SYSTEM_TABLE_GUID    \
     EFI_GUID(  0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
 
+#define HCDP_TABLE_GUID	\
+    EFI_GUID(  0xf951938d, 0x620b, 0x42ef, 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98 )
+
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
@@ -224,6 +228,7 @@
 	void *acpi20;			/* ACPI table  (ACPI 2.0) */
 	void *smbios;			/* SM BIOS table */
 	void *sal_systab;		/* SAL system table */
+	void *hcdp;			/* HCDP table */
 	void *boot_info;		/* boot info table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/hw_irq.h linux/include/asm-ia64/hw_irq.h
--- ../prev/linux/include/asm-ia64/hw_irq.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/hw_irq.h	Tue Jun 11 21:36:14 2002
@@ -67,6 +67,8 @@
 
 extern __u8 isa_irq_to_vector_map[16];
 #define isa_irq_to_vector(x)	isa_irq_to_vector_map[(x)]
+extern __u8 gsi_to_vector_map[255];
+#define gsi_to_vector(x)	gsi_to_vector_map[(x)]
 
 extern unsigned long ipi_base_addr;
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/machvec.h linux/include/asm-ia64/machvec.h
--- ../prev/linux/include/asm-ia64/machvec.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/machvec.h	Wed May 15 10:15:18 2002
@@ -206,6 +206,7 @@
 extern ia64_mv_pci_dma_sync_single swiotlb_sync_single;
 extern ia64_mv_pci_dma_sync_sg swiotlb_sync_sg;
 extern ia64_mv_pci_dma_address swiotlb_dma_address;
+extern ia64_mv_pci_dma_supported swiotlb_pci_dma_supported;
 
 /*
  * Define default versions so we can extend machvec for new platforms without having
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/offsets.h linux/include/asm-ia64/offsets.h
--- ../prev/linux/include/asm-ia64/offsets.h	Tue May 14 17:24:51 2002
+++ linux/include/asm-ia64/offsets.h	Wed Dec 31 17:00:00 1969
@@ -1,142 +0,0 @@
-#ifndef _ASM_IA64_OFFSETS_H
-#define _ASM_IA64_OFFSETS_H
-/*
- * DO NOT MODIFY
- *
- * This file was generated by arch/ia64/tools/print_offsets.awk.
- *
- */
-#define PT_PTRACED_BIT		0
-#define PT_TRACESYS_BIT		1
-#define IA64_TASK_SIZE			3936	/* 0xf60 */
-#define IA64_PT_REGS_SIZE		400	/* 0x190 */
-#define IA64_SWITCH_STACK_SIZE		560	/* 0x230 */
-#define IA64_SIGINFO_SIZE		128	/* 0x80 */
-#define IA64_CPU_SIZE			16384	/* 0x4000 */
-#define SIGFRAME_SIZE			2816	/* 0xb00 */
-#define UNW_FRAME_INFO_SIZE		448	/* 0x1c0 */
-
-#define IA64_TASK_PTRACE_OFFSET		48	/* 0x30 */
-#define IA64_TASK_SIGPENDING_OFFSET	16	/* 0x10 */
-#define IA64_TASK_NEED_RESCHED_OFFSET	40	/* 0x28 */
-#define IA64_TASK_PROCESSOR_OFFSET	96	/* 0x60 */
-#define IA64_TASK_THREAD_OFFSET		1488	/* 0x5d0 */
-#define IA64_TASK_THREAD_KSP_OFFSET	1488	/* 0x5d0 */
-#define IA64_TASK_PFM_OVFL_BLOCK_RESET_OFFSET 2112	/* 0x840 */
-#define IA64_TASK_PID_OFFSET		228	/* 0xe4 */
-#define IA64_TASK_MM_OFFSET		88	/* 0x58 */
-#define IA64_PT_REGS_CR_IPSR_OFFSET	0	/* 0x0 */
-#define IA64_PT_REGS_CR_IIP_OFFSET	8	/* 0x8 */
-#define IA64_PT_REGS_CR_IFS_OFFSET	16	/* 0x10 */
-#define IA64_PT_REGS_AR_UNAT_OFFSET	24	/* 0x18 */
-#define IA64_PT_REGS_AR_PFS_OFFSET	32	/* 0x20 */
-#define IA64_PT_REGS_AR_RSC_OFFSET	40	/* 0x28 */
-#define IA64_PT_REGS_AR_RNAT_OFFSET	48	/* 0x30 */
-#define IA64_PT_REGS_AR_BSPSTORE_OFFSET	56	/* 0x38 */
-#define IA64_PT_REGS_PR_OFFSET		64	/* 0x40 */
-#define IA64_PT_REGS_B6_OFFSET		72	/* 0x48 */
-#define IA64_PT_REGS_LOADRS_OFFSET	80	/* 0x50 */
-#define IA64_PT_REGS_R1_OFFSET		88	/* 0x58 */
-#define IA64_PT_REGS_R2_OFFSET		96	/* 0x60 */
-#define IA64_PT_REGS_R3_OFFSET		104	/* 0x68 */
-#define IA64_PT_REGS_R12_OFFSET		112	/* 0x70 */
-#define IA64_PT_REGS_R13_OFFSET		120	/* 0x78 */
-#define IA64_PT_REGS_R14_OFFSET		128	/* 0x80 */
-#define IA64_PT_REGS_R15_OFFSET		136	/* 0x88 */
-#define IA64_PT_REGS_R8_OFFSET		144	/* 0x90 */
-#define IA64_PT_REGS_R9_OFFSET		152	/* 0x98 */
-#define IA64_PT_REGS_R10_OFFSET		160	/* 0xa0 */
-#define IA64_PT_REGS_R11_OFFSET		168	/* 0xa8 */
-#define IA64_PT_REGS_R16_OFFSET		176	/* 0xb0 */
-#define IA64_PT_REGS_R17_OFFSET		184	/* 0xb8 */
-#define IA64_PT_REGS_R18_OFFSET		192	/* 0xc0 */
-#define IA64_PT_REGS_R19_OFFSET		200	/* 0xc8 */
-#define IA64_PT_REGS_R20_OFFSET		208	/* 0xd0 */
-#define IA64_PT_REGS_R21_OFFSET		216	/* 0xd8 */
-#define IA64_PT_REGS_R22_OFFSET		224	/* 0xe0 */
-#define IA64_PT_REGS_R23_OFFSET		232	/* 0xe8 */
-#define IA64_PT_REGS_R24_OFFSET		240	/* 0xf0 */
-#define IA64_PT_REGS_R25_OFFSET		248	/* 0xf8 */
-#define IA64_PT_REGS_R26_OFFSET		256	/* 0x100 */
-#define IA64_PT_REGS_R27_OFFSET		264	/* 0x108 */
-#define IA64_PT_REGS_R28_OFFSET		272	/* 0x110 */
-#define IA64_PT_REGS_R29_OFFSET		280	/* 0x118 */
-#define IA64_PT_REGS_R30_OFFSET		288	/* 0x120 */
-#define IA64_PT_REGS_R31_OFFSET		296	/* 0x128 */
-#define IA64_PT_REGS_AR_CCV_OFFSET	304	/* 0x130 */
-#define IA64_PT_REGS_AR_FPSR_OFFSET	312	/* 0x138 */
-#define IA64_PT_REGS_B0_OFFSET		320	/* 0x140 */
-#define IA64_PT_REGS_B7_OFFSET		328	/* 0x148 */
-#define IA64_PT_REGS_F6_OFFSET		336	/* 0x150 */
-#define IA64_PT_REGS_F7_OFFSET		352	/* 0x160 */
-#define IA64_PT_REGS_F8_OFFSET		368	/* 0x170 */
-#define IA64_PT_REGS_F9_OFFSET		384	/* 0x180 */
-#define IA64_SWITCH_STACK_CALLER_UNAT_OFFSET 0	/* 0x0 */
-#define IA64_SWITCH_STACK_AR_FPSR_OFFSET 8	/* 0x8 */
-#define IA64_SWITCH_STACK_F2_OFFSET	16	/* 0x10 */
-#define IA64_SWITCH_STACK_F3_OFFSET	32	/* 0x20 */
-#define IA64_SWITCH_STACK_F4_OFFSET	48	/* 0x30 */
-#define IA64_SWITCH_STACK_F5_OFFSET	64	/* 0x40 */
-#define IA64_SWITCH_STACK_F10_OFFSET	80	/* 0x50 */
-#define IA64_SWITCH_STACK_F11_OFFSET	96	/* 0x60 */
-#define IA64_SWITCH_STACK_F12_OFFSET	112	/* 0x70 */
-#define IA64_SWITCH_STACK_F13_OFFSET	128	/* 0x80 */
-#define IA64_SWITCH_STACK_F14_OFFSET	144	/* 0x90 */
-#define IA64_SWITCH_STACK_F15_OFFSET	160	/* 0xa0 */
-#define IA64_SWITCH_STACK_F16_OFFSET	176	/* 0xb0 */
-#define IA64_SWITCH_STACK_F17_OFFSET	192	/* 0xc0 */
-#define IA64_SWITCH_STACK_F18_OFFSET	208	/* 0xd0 */
-#define IA64_SWITCH_STACK_F19_OFFSET	224	/* 0xe0 */
-#define IA64_SWITCH_STACK_F20_OFFSET	240	/* 0xf0 */
-#define IA64_SWITCH_STACK_F21_OFFSET	256	/* 0x100 */
-#define IA64_SWITCH_STACK_F22_OFFSET	272	/* 0x110 */
-#define IA64_SWITCH_STACK_F23_OFFSET	288	/* 0x120 */
-#define IA64_SWITCH_STACK_F24_OFFSET	304	/* 0x130 */
-#define IA64_SWITCH_STACK_F25_OFFSET	320	/* 0x140 */
-#define IA64_SWITCH_STACK_F26_OFFSET	336	/* 0x150 */
-#define IA64_SWITCH_STACK_F27_OFFSET	352	/* 0x160 */
-#define IA64_SWITCH_STACK_F28_OFFSET	368	/* 0x170 */
-#define IA64_SWITCH_STACK_F29_OFFSET	384	/* 0x180 */
-#define IA64_SWITCH_STACK_F30_OFFSET	400	/* 0x190 */
-#define IA64_SWITCH_STACK_F31_OFFSET	416	/* 0x1a0 */
-#define IA64_SWITCH_STACK_R4_OFFSET	432	/* 0x1b0 */
-#define IA64_SWITCH_STACK_R5_OFFSET	440	/* 0x1b8 */
-#define IA64_SWITCH_STACK_R6_OFFSET	448	/* 0x1c0 */
-#define IA64_SWITCH_STACK_R7_OFFSET	456	/* 0x1c8 */
-#define IA64_SWITCH_STACK_B0_OFFSET	464	/* 0x1d0 */
-#define IA64_SWITCH_STACK_B1_OFFSET	472	/* 0x1d8 */
-#define IA64_SWITCH_STACK_B2_OFFSET	480	/* 0x1e0 */
-#define IA64_SWITCH_STACK_B3_OFFSET	488	/* 0x1e8 */
-#define IA64_SWITCH_STACK_B4_OFFSET	496	/* 0x1f0 */
-#define IA64_SWITCH_STACK_B5_OFFSET	504	/* 0x1f8 */
-#define IA64_SWITCH_STACK_AR_PFS_OFFSET	512	/* 0x200 */
-#define IA64_SWITCH_STACK_AR_LC_OFFSET	520	/* 0x208 */
-#define IA64_SWITCH_STACK_AR_UNAT_OFFSET 528	/* 0x210 */
-#define IA64_SWITCH_STACK_AR_RNAT_OFFSET 536	/* 0x218 */
-#define IA64_SWITCH_STACK_AR_BSPSTORE_OFFSET 544	/* 0x220 */
-#define IA64_SWITCH_STACK_PR_OFFSET	552	/* 0x228 */
-#define IA64_SIGCONTEXT_IP_OFFSET	40	/* 0x28 */
-#define IA64_SIGCONTEXT_AR_BSP_OFFSET	72	/* 0x48 */
-#define IA64_SIGCONTEXT_AR_FPSR_OFFSET	104	/* 0x68 */
-#define IA64_SIGCONTEXT_AR_RNAT_OFFSET	80	/* 0x50 */
-#define IA64_SIGCONTEXT_AR_UNAT_OFFSET	96	/* 0x60 */
-#define IA64_SIGCONTEXT_B0_OFFSET	136	/* 0x88 */
-#define IA64_SIGCONTEXT_CFM_OFFSET	48	/* 0x30 */
-#define IA64_SIGCONTEXT_FLAGS_OFFSET	0	/* 0x0 */
-#define IA64_SIGCONTEXT_FR6_OFFSET	560	/* 0x230 */
-#define IA64_SIGCONTEXT_PR_OFFSET	128	/* 0x80 */
-#define IA64_SIGCONTEXT_R12_OFFSET	296	/* 0x128 */
-#define IA64_SIGCONTEXT_RBS_BASE_OFFSET	2512	/* 0x9d0 */
-#define IA64_SIGCONTEXT_LOADRS_OFFSET	2520	/* 0x9d8 */
-#define IA64_SIGFRAME_ARG0_OFFSET	0	/* 0x0 */
-#define IA64_SIGFRAME_ARG1_OFFSET	8	/* 0x8 */
-#define IA64_SIGFRAME_ARG2_OFFSET	16	/* 0x10 */
-#define IA64_SIGFRAME_HANDLER_OFFSET	24	/* 0x18 */
-#define IA64_SIGFRAME_SIGCONTEXT_OFFSET	160	/* 0xa0 */
-#define IA64_CLONE_VFORK		16384	/* 0x4000 */
-#define IA64_CLONE_VM			256	/* 0x100 */
-#define IA64_CPU_IRQ_COUNT_OFFSET	0	/* 0x0 */
-#define IA64_CPU_BH_COUNT_OFFSET	4	/* 0x4 */
-#define IA64_CPU_PHYS_STACKED_SIZE_P8_OFFSET 12	/* 0xc */
-
-#endif /* _ASM_IA64_OFFSETS_H */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/page.h linux/include/asm-ia64/page.h
--- ../prev/linux/include/asm-ia64/page.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/page.h	Wed May 15 10:15:18 2002
@@ -65,13 +65,9 @@
 # define virt_to_page(kaddr)	(mem_map + MAP_NR_DENSE(kaddr))
 # define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
 #endif
-#ifdef CONFIG_VIRTUAL_MEM_MAP
-  struct page;
-  extern int ia64_page_valid (struct page *);
-# define VALID_PAGE(page)	(((page - mem_map) < max_mapnr) && ia64_page_valid(page))
-#else
-# define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
-#endif
+
+#define VALID_PAGE(page)	(((page - mem_map) < max_mapnr) \
+				&& ia64_page_valid(page))
 
 typedef union ia64_va {
 	struct {
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/pci.h linux/include/asm-ia64/pci.h
--- ../prev/linux/include/asm-ia64/pci.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/pci.h	Fri May 31 11:41:58 2002
@@ -20,7 +20,7 @@
 #define PCIBIOS_MIN_MEM		0x10000000
 
 void pcibios_config_init(void);
-struct pci_bus * pcibios_scan_root(int seg, int bus);
+struct pci_bus * pcibios_scan_root(int bus);
 extern int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *value);
 extern int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 value);
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/pgtable.h linux/include/asm-ia64/pgtable.h
--- ../prev/linux/include/asm-ia64/pgtable.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/pgtable.h	Wed May 15 10:15:18 2002
@@ -209,13 +209,10 @@
 
 #define VMALLOC_START		(0xa000000000000000 + 3*PAGE_SIZE)
 #define VMALLOC_VMADDR(x)	((unsigned long)(x))
-#ifdef CONFIG_VIRTUAL_MEM_MAP
-# define VMALLOC_END_INIT        (0xa000000000000000 + (1UL << (4*PAGE_SHIFT - 9))) 
-# define VMALLOC_END             vmalloc_end
-  extern unsigned long vmalloc_end;
-#else
-# define VMALLOC_END		(0xa000000000000000 + (1UL << (4*PAGE_SHIFT - 9)))
-#endif
+#define VMALLOC_END_INIT        (0xa000000000000000 + (1UL << (4*PAGE_SHIFT - 9))) 
+#define VMALLOC_END             vmalloc_end
+
+extern unsigned long vmalloc_end;
 
 /*
  * Conversion functions: convert a page and protection to a page entry,
@@ -459,32 +456,25 @@
  */
 #define pgtable_cache_init()	do { } while (0)
 
-/*
- * No page table caches to initialise
- */
-#define pgtable_cache_init()	do { } while (0)
+extern int ia64_page_valid(struct page *page);
 
-#ifdef CONFIG_VIRTUAL_MEM_MAP
-
-/* arch mem_map init routines are needed due to holes in a virtual mem_map */
-#define HAVE_ARCH_MEMMAP_INIT
+#define HAVE_ARCH_MEMMAP_INIT 
 
 #include <linux/mmzone.h>
 
 typedef void memmap_init_callback_t (struct page *start, struct page *end);
 
-extern void arch_memmap_init (memmap_init_callback_t *callback,
-			      struct page *start, struct page *end);
+extern void arch_memmap_init(memmap_init_callback_t *callback,
+                                struct page *start, struct page *end);
 
 typedef void memmap_zone_callback_t (struct page *start, struct page *end,
-				     zone_t *zone,unsigned long start_paddr,
-				     int highmem_flag);
-
-extern void arch_memmap_zone_init (memmap_zone_callback_t *callback,
-				   struct page *start, struct page *end, zone_t *zone,
-				   unsigned long start_paddr, int highmem_flag);
-#endif /* CONFIG_VIRTUAL_MEM_MAP */
+                                zone_t *zone,unsigned long start_paddr,
+                                int highmem_flag);
 
+extern void arch_memmap_zone_init(memmap_zone_callback_t *callback,
+                                struct page *start, struct page *end,
+                                zone_t *zone,unsigned long start_paddr,
+                                int highmem_flag);
 # endif /* !__ASSEMBLY__ */
 
 /*
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/serial.h linux/include/asm-ia64/serial.h
--- ../prev/linux/include/asm-ia64/serial.h	Tue Jul  9 18:04:50 2002
+++ linux/include/asm-ia64/serial.h	Wed May 29 13:45:32 2002
@@ -59,6 +59,20 @@
 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
 	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
 
+/*
+ * HCDP_SERIAL_PORT_DEFNS should be placed in exactly the same slot
+ * in rs_table as defined by HCDP_SERIAL_CONSOLE_PORT in
+ * include/linux/serial.h
+ */
+#define HCDP_SERIAL_PORT_DEFNS			\
+	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS},		/* ttySx device
+							   in comments sucks.
+							   You add an entry
+							   and you get to edit
+							   boatloads of these
+							   comments. Not worth
+							   it */
+
 
 #ifdef CONFIG_SERIAL_MANY_PORTS
 #define EXTRA_SERIAL_PORT_DEFNS			\
@@ -129,6 +143,7 @@
 
 #define SERIAL_PORT_DFNS		\
 	STD_SERIAL_PORT_DEFNS		\
+	HCDP_SERIAL_PORT_DEFNS		\
 	EXTRA_SERIAL_PORT_DEFNS		\
 	HUB6_SERIAL_PORT_DFNS		\
 	MCA_SERIAL_PORT_DFNS
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/asm-ia64/system.h linux/include/asm-ia64/system.h
--- ../prev/linux/include/asm-ia64/system.h	Tue Jul  9 18:04:51 2002
+++ linux/include/asm-ia64/system.h	Fri May 31 11:41:58 2002
@@ -15,6 +15,7 @@
 #include <linux/config.h>
 
 #include <asm/page.h>
+#include <asm/pal.h>
 
 #define KERNEL_START		(PAGE_OFFSET + 68*1024*1024)
 
@@ -100,6 +101,8 @@
  */
 #define set_mb(var, value)	do { (var) = (value); mb(); } while (0)
 #define set_wmb(var, value)	do { (var) = (value); mb(); } while (0)
+
+#define safe_halt()         ia64_pal_halt(1)                /* PAL_HALT */
 
 /*
  * The group barrier in front of the rsm & ssm are necessary to ensure
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/linux/acpi.h linux/include/linux/acpi.h
--- ../prev/linux/include/linux/acpi.h	Tue Jul  9 18:05:29 2002
+++ linux/include/linux/acpi.h	Fri May 31 11:41:59 2002
@@ -32,21 +32,25 @@
 #include <linux/list.h>
 
 /*
- * YES this is ugly.
- * But, moving all of ACPI's private headers to include/acpi isn't the right
- * answer either.
- * Please just ignore it for now.
+ * Yes this is ugly, but moving all of ACPI's private headers to include/acpi 
+ * isn't the right answer either.  Please just ignore it for now.
  */
 #include "../../drivers/acpi/include/acpi.h"
 #include <asm/acpi.h>
 
 
-/* --------------------------------------------------------------------------
-                             Boot-Time Table Parsing
-   -------------------------------------------------------------------------- */
-
 #ifdef CONFIG_ACPI_BOOT
 
+enum acpi_irq_model_id {
+	ACPI_IRQ_MODEL_PIC = 0,
+	ACPI_IRQ_MODEL_IOAPIC,
+	ACPI_IRQ_MODEL_IOSAPIC,
+	ACPI_IRQ_MODEL_COUNT
+};
+
+extern enum acpi_irq_model_id	acpi_irq_model;
+
+
 /* Root System Description Pointer (RSDP) */
 
 struct acpi_table_rsdp {
@@ -329,10 +333,9 @@
 
 typedef int (*acpi_madt_entry_handler) (acpi_table_entry_header *header);
 
-struct acpi_boot_flags {
-	u8		madt:1;
-	u8		reserved:7;
-};
+char * __acpi_map_table (unsigned long phys_addr, unsigned long size);
+unsigned long acpi_find_rsdp (void);
+int acpi_boot_init (char *cmdline);
 
 int acpi_table_init (char *cmdline);
 int acpi_table_parse (enum acpi_table_id, acpi_table_handler);
@@ -343,28 +346,17 @@
 #endif /*CONFIG_ACPI_BOOT*/
 
 
-/* --------------------------------------------------------------------------
-                           PCI Interrupt Routing (PRT)
-   -------------------------------------------------------------------------- */
-
 #ifdef CONFIG_ACPI_PCI
 
-#define ACPI_INT_MODEL_PIC	0
-#define ACPI_INT_MODEL_IOAPIC	1
-#define ACPI_INT_MODEL_IOSAPIC	2
-
 struct acpi_prt_entry {
 	struct list_head	node;
-	struct {
-		u8			seg;
-		u8			bus;
-		u8			dev;
-		u8			pin;
-	}			id;
+	acpi_pci_id		id;
+	u8			pin;
 	struct {
 		acpi_handle		handle;
 		u32			index;
-	}			source;
+	}			link;
+	u32			irq;
 };
 
 struct acpi_prt_list {
@@ -372,25 +364,21 @@
 	struct list_head	entries;
 };
 
-extern struct acpi_prt_list	acpi_prts;
+extern struct acpi_prt_list	acpi_prt;
 
 struct pci_dev;
 
-int acpi_prt_get_irq (struct pci_dev *dev, u8 pin, int *irq);
-int acpi_prt_set_irq (struct pci_dev *dev, u8 pin, int irq);
+int acpi_pci_irq_enable (struct pci_dev *dev);
+int acpi_pci_irq_init (void);
 
 #endif /*CONFIG_ACPI_PCI*/
 
 
-/* --------------------------------------------------------------------------
-                            ACPI Interpreter (Core)
-   -------------------------------------------------------------------------- */
-
-#ifdef CONFIG_ACPI_INTERPRETER
+#ifdef CONFIG_ACPI
 
 int acpi_init(void);
 
-#endif /*CONFIG_ACPI_INTERPRETER*/
+#endif /*CONFIG_ACPI*/
 
 
 #endif /*_LINUX_ACPI_H*/
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/linux/acpi_serial.h linux/include/linux/acpi_serial.h
--- ../prev/linux/include/linux/acpi_serial.h	Tue May 14 17:24:55 2002
+++ linux/include/linux/acpi_serial.h	Wed Dec 31 17:00:00 1969
@@ -1,105 +0,0 @@
-/*
- *  linux/include/linux/acpi_serial.h
- *
- *  Copyright (C) 2000  Hewlett-Packard Co.
- *  Copyright (C) 2000  Khalid Aziz <khalid_aziz@hp.com>
- *
- *  Definitions for ACPI defined serial ports (headless console and 
- *  debug ports)
- *
- */
-
-extern void setup_serial_acpi(void *);
-
-#define ACPI_SIG_LEN		4
-
-/* ACPI table signatures */
-#define ACPI_SPCRT_SIGNATURE	"SPCR"
-#define ACPI_DBGPT_SIGNATURE	"DBGP"
-
-/* Interface type as defined in ACPI serial port tables */
-#define ACPI_SERIAL_INTFC_16550	0
-#define ACPI_SERIAL_INTFC_16450	1
-
-/* Interrupt types for ACPI serial port tables */
-#define ACPI_SERIAL_INT_PCAT	0x01
-#define ACPI_SERIAL_INT_APIC	0x02
-#define ACPI_SERIAL_INT_SAPIC	0x04
-
-/* Baud rates as defined in ACPI serial port tables */
-#define ACPI_SERIAL_BAUD_9600		3
-#define ACPI_SERIAL_BAUD_19200		4
-#define ACPI_SERIAL_BAUD_57600		6
-#define ACPI_SERIAL_BAUD_115200		7
-
-/* Parity as defined in ACPI serial port tables */
-#define ACPI_SERIAL_PARITY_NONE		0
-
-/* Flow control methods as defined in ACPI serial port tables */
-#define ACPI_SERIAL_FLOW_DCD	0x01
-#define ACPI_SERIAL_FLOW_RTS	0x02
-#define ACPI_SERIAL_FLOW_XON	0x04
-
-/* Terminal types as defined in ACPI serial port tables */
-#define ACPI_SERIAL_TERM_VT100		0
-#define ACPI_SERIAL_TERM_VT100X	1
-
-/* PCI Flags as defined by SPCR table */
-#define ACPI_SERIAL_PCIFLAG_PNP	0x00000001
-
-/* Space ID as defined in base address structure in ACPI serial port tables */
-#define ACPI_SERIAL_MEM_SPACE		0
-#define ACPI_SERIAL_IO_SPACE		1
-#define ACPI_SERIAL_PCICONF_SPACE	2
-
-/* 
- * Generic Register Address Structure - as defined by Microsoft 
- * in http://www.microsoft.com/hwdev/onnow/download/LFreeACPI.doc
- *
-*/
-typedef struct {
-	u8  space_id;
-	u8  bit_width;
-	u8  bit_offset;
-	u8  resv;
-	u32 addrl;
-	u32 addrh;
-} gen_regaddr;
-
-/* Space ID for generic register address structure */
-#define REGADDR_SPACE_SYSMEM	0
-#define REGADDR_SPACE_SYSIO	1
-#define REGADDR_SPACE_PCICONFIG	2
-
-/* Serial Port Console Redirection and Debug Port Table formats */
-typedef struct {
-	u8 signature[4];
-	u32 length;
-	u8  rev;
-	u8  chksum;
-	u8  oemid[6];
-	u8  oem_tabid[8];
-	u32 oem_rev;
-	u8  creator_id[4];
-	u32 creator_rev;
-	u8  intfc_type;
-	u8  resv1[3];
-	gen_regaddr base_addr;
-	u8  int_type;
-	u8  irq;
-	u8  global_int[4];
-	u8  baud;
-	u8  parity;
-	u8  stop_bits;
-	u8  flow_ctrl;
-	u8  termtype;
-	u8  language;
-	u16 pci_dev_id;
-	u16 pci_vendor_id;
-	u8  pci_bus;
-	u8  pci_dev;
-	u8  pci_func;
-	u8  pci_flags[4];
-	u8  pci_seg;
-	u32 resv2;
-} acpi_ser_t;
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/linux/hcdp_serial.h linux/include/linux/hcdp_serial.h
--- ../prev/linux/include/linux/hcdp_serial.h	Wed Dec 31 17:00:00 1969
+++ linux/include/linux/hcdp_serial.h	Wed May 29 13:45:32 2002
@@ -0,0 +1,84 @@
+/*
+ *  linux/include/asm-ia64/hcdp_serial.h
+ *
+ *  Copyright (C) 2002  Hewlett-Packard Co.
+ *  Copyright (C) 2002  Khalid Aziz <khalid_aziz@hp.com>
+ *
+ *  Definitions for HCDP defined serial ports (Serial console and 
+ *  debug ports)
+ *
+ */
+#ifndef _ASM_IA64_HCDP_SERIAL_H
+#define _ASM_IA64_HCDP_SERIAL_H
+
+/* ACPI table signatures */
+#define HCDP_SIG_LEN		4
+#define HCDP_SIGNATURE		"HCDP"
+
+/* Space ID as defined in ACPI generic address structure */
+#define ACPI_MEM_SPACE		0
+#define ACPI_IO_SPACE		1
+#define ACPI_PCICONF_SPACE	2
+
+/* 
+ * Maximum number of HCDP devices we want to read in
+ */
+#define MAX_HCDP_DEVICES	6
+
+/*
+ * Default base baud rate if clock rate is 0 in HCDP table.
+ */
+#define DEFAULT_BAUD_BASE	115200
+
+/* 
+ * ACPI Generic Address Structure 
+ */
+typedef struct {
+	u8  space_id;
+	u8  bit_width;
+	u8  bit_offset;
+	u8  resv;
+	u32 addrlo;
+	u32 addrhi;
+} acpi_gen_addr;
+
+/* HCDP Device descriptor entry types */
+#define HCDP_DEV_CONSOLE	0
+#define HCDP_DEV_DEBUG		1
+
+/* HCDP Device descriptor type */
+typedef struct {
+	u8	type;
+	u8	bits;
+	u8	parity;
+	u8	stop_bits;
+	u8	pci_seg;
+	u8	pci_bus;
+	u8	pci_dev;
+	u8	pci_func;
+	u64	baud;
+	acpi_gen_addr	base_addr;
+	u16	pci_dev_id;
+	u16	pci_vendor_id;
+	u32	global_int;
+	u32	clock_rate;
+	u8	pci_prog_intfc;
+	u8	resv;
+} hcdp_dev_t;
+
+/* HCDP Table format */
+typedef struct {
+	u8	signature[4];
+	u32	len;
+	u8	rev;
+	u8	chksum;
+	u8	oemid[6];
+	u8	oem_tabid[8];
+	u32	oem_rev;
+	u8	creator_id[4];
+	u32	creator_rev;
+	u32	num_entries;
+	hcdp_dev_t	hcdp_dev[MAX_HCDP_DEVICES];
+} hcdp_t;
+
+#endif	/* _ASM_IA64_HCDP_SERIAL_H */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/linux/pci_ids.h linux/include/linux/pci_ids.h
--- ../prev/linux/include/linux/pci_ids.h	Tue Jul  9 18:05:30 2002
+++ linux/include/linux/pci_ids.h	Wed May 15 10:15:20 2002
@@ -1509,7 +1509,11 @@
 #define PCI_VENDOR_ID_BROADCOM		0x14e4
 #define PCI_DEVICE_ID_TIGON3_5700	0x1644
 #define PCI_DEVICE_ID_TIGON3_5701	0x1645
+#define PCI_DEVICE_ID_TIGON3_5702	0x1646
 #define PCI_DEVICE_ID_TIGON3_5703	0x1647
+#define PCI_DEVICE_ID_TIGON3_5702FE	0x164d
+#define PCI_DEVICE_ID_TIGON3_5702X	0x16a6
+#define PCI_DEVICE_ID_TIGON3_5703X	0x16a7
 
 #define PCI_VENDOR_ID_SYBA		0x1592
 #define PCI_DEVICE_ID_SYBA_2P_EPP	0x0782
@@ -1523,6 +1527,9 @@
 
 #define PCI_VENDOR_ID_PDC		0x15e9
 #define PCI_DEVICE_ID_PDC_1841		0x1841
+
+#define PCI_VENDOR_ID_ALTIMA		0x173b
+#define PCI_DEVICE_ID_ALTIMA_AC1000	0x03e8
 
 #define PCI_VENDOR_ID_SYMPHONY		0x1c1c
 #define PCI_DEVICE_ID_SYMPHONY_101	0x0001
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/include/linux/serial.h linux/include/linux/serial.h
--- ../prev/linux/include/linux/serial.h	Tue Jul  9 18:05:30 2002
+++ linux/include/linux/serial.h	Wed May 29 13:45:32 2002
@@ -182,11 +182,8 @@
 /* Allow complicated architectures to specify rs_table[] at run time */
 extern int early_serial_setup(struct serial_struct *req);
 
-#ifdef CONFIG_ACPI
-/* tty ports reserved for the ACPI serial console port and debug port */
-#define ACPI_SERIAL_CONSOLE_PORT        4
-#define ACPI_SERIAL_DEBUG_PORT          5
-#endif
+/* tty ports reserved for the HCDP serial console port */
+#define HCDP_SERIAL_CONSOLE_PORT        4
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SERIAL_H */
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/init/main.c linux/init/main.c
--- ../prev/linux/init/main.c	Tue Jul  9 18:05:31 2002
+++ linux/init/main.c	Fri May 31 11:41:59 2002
@@ -697,7 +697,7 @@
 #if defined(CONFIG_ARCH_S390)
 	s390_init_machine_check();
 #endif
-#ifdef CONFIG_ACPI
+#ifdef CONFIG_ACPI_INTERPRETER
 	acpi_init();
 #endif
 #ifdef CONFIG_PCI
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/kernel/printk.c linux/kernel/printk.c
--- ../prev/linux/kernel/printk.c	Tue Jul  9 18:05:32 2002
+++ linux/kernel/printk.c	Wed May 15 10:15:20 2002
@@ -700,6 +700,9 @@
 #define VGALINES	24
 #define VGACOLS		80
 
+#define UART_BASE       ((char *)0xc0000000FF5E0000)
+#include <linux/serial_reg.h>
+
 static int current_ypos = VGALINES, current_xpos = 0;
 
 void
@@ -710,6 +713,16 @@
 
 	while (len-- > 0) {
 		c = *str++;
+#ifdef CONFIG_IA64_HP_PROTO
+		while (!(UART_LSR_TEMT & readb((char *)(UART_BASE + UART_LSR))))
+			; /* spin */
+
+		writeb(c, (char *)UART_BASE + UART_TX);
+
+		if (c == '\n')
+			writeb('\r', (char *)UART_BASE + UART_TX);
+#else
+
 		if (current_ypos >= VGALINES) {
 			/* scroll 1 line up */
 			for (k = 1, j = 0; k < VGALINES; k++, j++) {
@@ -734,6 +747,7 @@
 				current_ypos++;
 			}
 		}
+#endif
 	}
 }
 
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/mm/mmap.c linux/mm/mmap.c
--- ../prev/linux/mm/mmap.c	Tue Jul  9 18:05:32 2002
+++ linux/mm/mmap.c	Thu Jun 20 11:28:29 2002
@@ -883,6 +883,8 @@
 		break;
 	}
 no_mmaps:
+	if (last < first)
+		return;
 	/*
 	 * If the PGD bits are not consecutive in the virtual address, the
 	 * old method of shifting the VA >> by PGDIR_SHIFT doesn't work.
diff -urN --exclude-from=/var/cache/bats/src/lso-ia64-patch/20020709_180001/obuild/lso-ia64-patch/dontdiff ../prev/linux/mm/page_alloc.c linux/mm/page_alloc.c
--- ../prev/linux/mm/page_alloc.c	Tue Jul  9 18:05:32 2002
+++ linux/mm/page_alloc.c	Wed May 15 10:15:20 2002
@@ -623,6 +623,38 @@
 	} 
 }
 
+#ifdef HAVE_ARCH_MEMMAP_INIT
+#define MMI_INLINE 
+#else
+#define MMI_INLINE inline
+#endif
+
+static MMI_INLINE void memmap_init(struct page *start, struct page *end) 
+{
+	struct page *p;
+
+	for (p = start; p < end; p++) {
+		set_page_count(p, 0);
+		SetPageReserved(p);
+		init_waitqueue_head(&p->wait);
+		memlist_init(&p->list);
+	}
+}
+
+static MMI_INLINE void memmap_zone_init(struct page *start, struct page *end,
+					zone_t *zone,unsigned long start_paddr,
+					int highmem_flag)
+{
+	struct page *p;
+	
+	for (p = start; p < end; p++) {
+		p->zone = zone;
+		if (!highmem_flag)
+			p->virtual = __va(start_paddr);
+		start_paddr += PAGE_SIZE;
+	}
+}
+
 #define LONG_ALIGN(x) (((x)+(sizeof(long))-1)&~((sizeof(long))-1))
 
 /*
@@ -635,7 +667,6 @@
 	unsigned long *zones_size, unsigned long zone_start_paddr, 
 	unsigned long *zholes_size, struct page *lmem_map)
 {
-	struct page *p;
 	unsigned long i, j;
 	unsigned long map_size;
 	unsigned long totalpages, offset, realtotalpages;
@@ -683,12 +714,11 @@
 	 * up by free_all_bootmem() once the early boot process is
 	 * done.
 	 */
-	for (p = lmem_map; p < lmem_map + totalpages; p++) {
-		set_page_count(p, 0);
-		SetPageReserved(p);
-		init_waitqueue_head(&p->wait);
-		memlist_init(&p->list);
-	}
+#ifdef HAVE_ARCH_MEMMAP_INIT
+	arch_memmap_init(memmap_init,lmem_map,lmem_map + totalpages);
+#else
+	memmap_init(lmem_map,lmem_map + totalpages);
+#endif
 
 	offset = lmem_map - mem_map;	
 	for (j = 0; j < MAX_NR_ZONES; j++) {
@@ -728,12 +758,19 @@
 		if ((zone_start_paddr >> PAGE_SHIFT) & (zone_required_alignment-1))
 			printk("BUG: wrong zone alignment, it will crash\n");
 
-		for (i = 0; i < size; i++) {
-			struct page *page = mem_map + offset + i;
-			page->zone = zone;
-			if (j != ZONE_HIGHMEM)
-				page->virtual = __va(zone_start_paddr);
-			zone_start_paddr += PAGE_SIZE;
+		{
+			struct page *page = mem_map + offset;
+
+#ifdef HAVE_ARCH_MEMMAP_INIT
+			arch_memmap_zone_init(memmap_zone_init,page,page+size,
+						zone,zone_start_paddr,
+						(j == ZONE_HIGHMEM ? 1 : 0));
+#else	
+			memmap_zone_init(page,page+size,zone,
+				zone_start_paddr,(j == ZONE_HIGHMEM ? 1 : 0));
+#endif
+
+			zone_start_paddr += (size << PAGE_SHIFT);
 		}
 
 		offset += size;
