##############################################################################
# this patch was taken from the kernel-image-2.4.17-ia64-011226.16 Debian    #
# source package, where it was named hplso-CVS-2002-05-14.diff               #
# it adds support for various HP McKinley-based hardware, and other          #
# devices that are not supported via the vanilla ia64 kernel                 #
##############################################################################
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/Documentation/Configure.help linux/Documentation/Configure.help
--- ../ia64/linux/Documentation/Configure.help	Fri Jan 25 13:11:01 2002
+++ linux/Documentation/Configure.help	Wed Apr 10 10:48:49 2002
@@ -3269,6 +3269,11 @@
   You should say Y here if you use XFree86 3.3.6 or 4.x and want to
   use GLX or DRI.  If unsure, say N.
 
+HP ZX1 chipset AGP GART support
+CONFIG_AGP_HP_ZX1
+  This option gives you AGP GART support for the HP ZX1 chipset
+  for IA64 processors.
+
 Support for ISA-bus hardware
 CONFIG_ISA
   Find out whether you have ISA slots on your motherboard.  ISA is the
@@ -23650,12 +23655,18 @@
 
   HP-simulator   For the HP simulator
                  (<http://software.hp.com/ia64linux/>).
+  HP-zx1         For HP zx1 Platforms.
   SN1            For SGI SN1 Platforms.
   SN2            For SGI SN2 Platforms.
   DIG-compliant  For DIG ("Developer's Interface Guide") compliant
-                 system.
+                 systems.
 
   If you don't know what to do, choose "generic".
+
+CONFIG_IA64_HP_ZX1
+  Build a kernel that runs on HP zx1-based systems.  This adds support
+  for the zx1 IOMMU and makes root bus bridges appear in PCI config space
+  (required for zx1 agpgart support).
 
 CONFIG_IA64_SGI_SN_SIM
   Build a kernel that runs on both the SGI simulator AND on hardware.
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/Makefile linux/arch/ia64/Makefile
--- ../ia64/linux/arch/ia64/Makefile	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/Makefile	Mon Mar 11 20:19:40 2002
@@ -33,16 +33,13 @@
 endif
 
 ifdef CONFIG_IA64_GENERIC
-	CORE_FILES      :=      arch/$(ARCH)/hp/hp.a	\
-				arch/$(ARCH)/sn/sn.o	\
-				arch/$(ARCH)/dig/dig.a	\
-				arch/$(ARCH)/sn/io/sgiio.o \
+	CORE_FILES      :=      arch/$(ARCH)/hp/hp.o			\
+				arch/$(ARCH)/dig/dig.a			\
 				$(CORE_FILES)
+#				arch/$(ARCH)/sn/sn.o
+#				arch/$(ARCH)/sn/io/sgiio.o
 	SUBDIRS		:=	arch/$(ARCH)/hp		\
-				arch/$(ARCH)/sn/sn1	\
-				arch/$(ARCH)/sn		\
 				arch/$(ARCH)/dig	\
-				arch/$(ARCH)/sn/io	\
 				$(SUBDIRS)
 
 else # !GENERIC
@@ -50,7 +47,16 @@
 ifdef CONFIG_IA64_HP_SIM
         SUBDIRS         :=      arch/$(ARCH)/hp		\
                                 $(SUBDIRS)
-        CORE_FILES      :=      arch/$(ARCH)/hp/hp.a	\
+        CORE_FILES      :=      arch/$(ARCH)/hp/hp.o	\
+                                $(CORE_FILES)
+endif
+
+ifdef CONFIG_IA64_HP_ZX1
+        SUBDIRS         :=      arch/$(ARCH)/hp				\
+				arch/$(ARCH)/dig			\
+                                $(SUBDIRS)
+        CORE_FILES      :=      arch/$(ARCH)/hp/hp.o			\
+				arch/$(ARCH)/dig/dig.a			\
                                 $(CORE_FILES)
 endif
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/config.in linux/arch/ia64/config.in
--- ../ia64/linux/arch/ia64/config.in	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/config.in	Tue Apr  9 05:01:45 2002
@@ -41,6 +41,7 @@
 	"generic		CONFIG_IA64_GENERIC		\
 	 DIG-compliant		CONFIG_IA64_DIG			\
 	 HP-simulator		CONFIG_IA64_HP_SIM		\
+	 HP-zx1			CONFIG_IA64_HP_ZX1		\
 	 SGI-SN1		CONFIG_IA64_SGI_SN1		\
 	 SGI-SN2		CONFIG_IA64_SGI_SN2" generic
 
@@ -62,17 +63,17 @@
 
 if [ "$CONFIG_MCKINLEY" = "y" ]; then
 	define_int CONFIG_IA64_L1_CACHE_SHIFT 7
-	bool '  Enable McKinley A-step specific code' CONFIG_MCKINLEY_ASTEP_SPECIFIC
-	if [ "$CONFIG_MCKINLEY_ASTEP_SPECIFIC" = "y" ]; then
-	  bool '   Enable McKinley A0/A1-step specific code' CONFIG_MCKINLEY_A0_SPECIFIC
-	fi
 fi
 
-if [ "$CONFIG_IA64_DIG" = "y" ]; then
+if [ "$CONFIG_IA64_GENERIC" = "y" ] || [ "$CONFIG_IA64_DIG" = "y" ] || [ "$CONFIG_IA64_HP_ZX1" = "y" ]; then
 	bool '  Enable IA-64 Machine Check Abort' CONFIG_IA64_MCA
 	define_bool CONFIG_PM y
 fi
 
+if [ "$CONFIG_IA64_GENERIC" = "y" ] || [ "$CONFIG_IA64_HP_ZX1" = "y" ]; then
+	bool '  Enable Hewlett-Packard prototype suport' CONFIG_IA64_HP_PROTO
+fi
+
 if [ "$CONFIG_IA64_SGI_SN1" = "y" ] || [ "$CONFIG_IA64_SGI_SN2" = "y" ]; then
 	define_bool CONFIG_IA64_SGI_SN y
 	bool '  Enable extra debugging code' CONFIG_IA64_SGI_SN_DEBUG n
@@ -137,6 +138,7 @@
 source drivers/block/Config.in
 source drivers/message/i2o/Config.in
 source drivers/md/Config.in
+source drivers/message/fusion/Config.in
 
 mainmenu_option next_comment
 comment 'ATA/IDE/MFM/RLL support'
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/defconfig linux/arch/ia64/defconfig
--- ../ia64/linux/arch/ia64/defconfig	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/defconfig	Thu May  2 01:30:37 2002
@@ -12,7 +12,7 @@
 #
 CONFIG_MODULES=y
 CONFIG_MODVERSIONS=y
-# CONFIG_KMOD is not set
+CONFIG_KMOD=y
 
 #
 # General setup
@@ -28,22 +28,22 @@
 CONFIG_ACPI_EFI=y
 CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_KERNEL_CONFIG=y
-CONFIG_ITANIUM=y
-# CONFIG_MCKINLEY is not set
-# CONFIG_IA64_GENERIC is not set
-CONFIG_IA64_DIG=y
+# CONFIG_ITANIUM is not set
+CONFIG_MCKINLEY=y
+CONFIG_IA64_GENERIC=y
+# CONFIG_IA64_DIG is not set
 # CONFIG_IA64_HP_SIM is not set
+# CONFIG_IA64_HP_ZX1 is not set
 # CONFIG_IA64_SGI_SN1 is not set
 # CONFIG_IA64_SGI_SN2 is not set
 # CONFIG_IA64_PAGE_SIZE_4KB is not set
 # CONFIG_IA64_PAGE_SIZE_8KB is not set
 CONFIG_IA64_PAGE_SIZE_16KB=y
 # CONFIG_IA64_PAGE_SIZE_64KB is not set
-CONFIG_IA64_BRL_EMU=y
-# CONFIG_ITANIUM_BSTEP_SPECIFIC is not set
-CONFIG_IA64_L1_CACHE_SHIFT=6
+CONFIG_IA64_L1_CACHE_SHIFT=7
 CONFIG_IA64_MCA=y
 CONFIG_PM=y
+# CONFIG_IA64_HP_PROTO is not set
 CONFIG_KCORE_ELF=y
 CONFIG_SMP=y
 CONFIG_IA32_SUPPORT=y
@@ -52,46 +52,109 @@
 CONFIG_EFI_VARS=y
 CONFIG_NET=y
 CONFIG_SYSVIPC=y
-# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_BSD_PROCESS_ACCT=y
 CONFIG_SYSCTL=y
 CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
+CONFIG_BINFMT_MISC=m
 # CONFIG_ACPI_DEBUG is not set
-# CONFIG_ACPI_BUSMGR is not set
-# CONFIG_ACPI_SYS is not set
+CONFIG_ACPI_BUSMGR=y
+CONFIG_ACPI_SYS=y
 # CONFIG_ACPI_CPU is not set
-# CONFIG_ACPI_BUTTON is not set
+CONFIG_ACPI_BUTTON=y
 # CONFIG_ACPI_AC is not set
 # CONFIG_ACPI_EC is not set
 # CONFIG_ACPI_CMBATT is not set
 # CONFIG_ACPI_THERMAL is not set
 CONFIG_PCI=y
 CONFIG_PCI_NAMES=y
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
 # CONFIG_PCMCIA is not set
 
 #
 # Parallel port support
 #
-# CONFIG_PARPORT is not set
+CONFIG_PARPORT=m
+CONFIG_PARPORT_PC=m
+CONFIG_PARPORT_PC_CML1=m
+CONFIG_PARPORT_SERIAL=m
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+# CONFIG_PARPORT_AMIGA is not set
+# CONFIG_PARPORT_MFC3 is not set
+# CONFIG_PARPORT_ATARI is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_SUNBPP is not set
+# CONFIG_PARPORT_OTHER is not set
+CONFIG_PARPORT_1284=y
 
 #
 # Networking options
 #
 CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-# CONFIG_NETLINK is not set
-# CONFIG_NETFILTER is not set
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=m
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
 CONFIG_FILTER=y
 CONFIG_UNIX=y
 CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_FWMARK=y
+CONFIG_IP_ROUTE_NAT=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_TOS=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_ROUTE_LARGE_TABLES=y
 # CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
+CONFIG_NET_IPIP=m
 # CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
 # CONFIG_INET_ECN is not set
-# CONFIG_SYN_COOKIES is not set
+CONFIG_SYN_COOKIES=y
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_UNCLEAN=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_MIRROR=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 # CONFIG_IPV6 is not set
 # CONFIG_KHTTPD is not set
 # CONFIG_ATM is not set
@@ -134,14 +197,45 @@
 #
 # CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_XD is not set
-# CONFIG_PARIDE is not set
+CONFIG_PARIDE=m
+CONFIG_PARIDE_PARPORT=m
+
+#
+# Parallel IDE high-level drivers
+#
+CONFIG_PARIDE_PD=m
+CONFIG_PARIDE_PCD=m
+CONFIG_PARIDE_PF=m
+CONFIG_PARIDE_PT=m
+CONFIG_PARIDE_PG=m
+
+#
+# Parallel IDE protocol modules
+#
+CONFIG_PARIDE_ATEN=m
+CONFIG_PARIDE_BPCK=m
+CONFIG_PARIDE_BPCK6=m
+CONFIG_PARIDE_COMM=m
+CONFIG_PARIDE_DSTR=m
+CONFIG_PARIDE_FIT2=m
+CONFIG_PARIDE_FIT3=m
+CONFIG_PARIDE_EPAT=m
+CONFIG_PARIDE_EPATC8=y
+CONFIG_PARIDE_EPIA=m
+CONFIG_PARIDE_FRIQ=m
+CONFIG_PARIDE_FRPW=m
+CONFIG_PARIDE_KBIC=m
+CONFIG_PARIDE_KTTI=m
+CONFIG_PARIDE_ON20=m
+CONFIG_PARIDE_ON26=m
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_INITRD=y
 
 #
 # I2O device support
@@ -156,14 +250,24 @@
 #
 # Multi-device support (RAID and LVM)
 #
-# CONFIG_MD is not set
-# CONFIG_BLK_DEV_MD is not set
-# CONFIG_MD_LINEAR is not set
-# CONFIG_MD_RAID0 is not set
-# CONFIG_MD_RAID1 is not set
-# CONFIG_MD_RAID5 is not set
-# CONFIG_MD_MULTIPATH is not set
-# CONFIG_BLK_DEV_LVM is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID5=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_BLK_DEV_LVM=m
+
+#
+# Fusion MPT device support
+#
+CONFIG_FUSION=y
+CONFIG_FUSION_BOOT=y
+CONFIG_FUSION_ISENSE=m
+CONFIG_FUSION_CTL=m
+CONFIG_FUSION_LAN=m
+CONFIG_NET_FC=y
 
 #
 # ATA/IDE/MFM/RLL support
@@ -181,7 +285,7 @@
 # CONFIG_BLK_DEV_HD_IDE is not set
 # CONFIG_BLK_DEV_HD is not set
 CONFIG_BLK_DEV_IDEDISK=y
-CONFIG_IDEDISK_MULTI_MODE=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
 # CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
 # CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
 # CONFIG_BLK_DEV_IDEDISK_IBM is not set
@@ -209,7 +313,7 @@
 CONFIG_BLK_DEV_IDEDMA_PCI=y
 CONFIG_BLK_DEV_ADMA=y
 # CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_IDEDMA_PCI_AUTO is not set
+CONFIG_IDEDMA_PCI_AUTO=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_PCI_WIP is not set
 # CONFIG_IDEDMA_NEW_DRIVE_LISTINGS is not set
@@ -219,14 +323,14 @@
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
-# CONFIG_BLK_DEV_CMD64X is not set
+CONFIG_BLK_DEV_CMD64X=y
 # CONFIG_BLK_DEV_CY82C693 is not set
 # CONFIG_BLK_DEV_CS5530 is not set
 # CONFIG_BLK_DEV_HPT34X is not set
 # CONFIG_HPT34X_AUTODMA is not set
 # CONFIG_BLK_DEV_HPT366 is not set
 CONFIG_BLK_DEV_PIIX=y
-# CONFIG_PIIX_TUNING is not set
+CONFIG_PIIX_TUNING=y
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_OPTI621 is not set
 # CONFIG_BLK_DEV_PDC202XX is not set
@@ -238,7 +342,7 @@
 # CONFIG_BLK_DEV_TRM290 is not set
 # CONFIG_BLK_DEV_VIA82CXXX is not set
 # CONFIG_IDE_CHIPSETS is not set
-# CONFIG_IDEDMA_AUTO is not set
+CONFIG_IDEDMA_AUTO=y
 # CONFIG_IDEDMA_IVB is not set
 # CONFIG_DMA_NONPCI is not set
 CONFIG_BLK_DEV_IDE_MODES=y
@@ -256,16 +360,18 @@
 #
 CONFIG_BLK_DEV_SD=y
 CONFIG_SD_EXTRA_DEVS=40
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_ST=y
+CONFIG_CHR_DEV_OSST=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=2
+CONFIG_CHR_DEV_SG=y
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
-CONFIG_SCSI_DEBUG_QUEUES=y
-# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+CONFIG_SCSI_MULTI_LUN=y
 CONFIG_SCSI_CONSTANTS=y
 CONFIG_SCSI_LOGGING=y
 
@@ -278,13 +384,16 @@
 # CONFIG_SCSI_AHA152X is not set
 # CONFIG_SCSI_AHA1542 is not set
 # CONFIG_SCSI_AHA1740 is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=y
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=253
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_BUILD_FIRMWARE is not set
 # CONFIG_SCSI_DPT_I2O is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_IN2000 is not set
 # CONFIG_SCSI_AM53C974 is not set
-# CONFIG_SCSI_MEGARAID is not set
+CONFIG_SCSI_MEGARAID=y
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -297,11 +406,20 @@
 # CONFIG_SCSI_GENERIC_NCR5380 is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_PPA is not set
+# CONFIG_SCSI_IMM is not set
 # CONFIG_SCSI_NCR53C406A is not set
 # CONFIG_SCSI_NCR53C7xx is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_NCR53C8XX is not set
-# CONFIG_SCSI_SYM53C8XX is not set
+CONFIG_SCSI_SYM53C8XX=y
+CONFIG_SCSI_NCR53C8XX_DEFAULT_TAGS=8
+CONFIG_SCSI_NCR53C8XX_MAX_TAGS=32
+CONFIG_SCSI_NCR53C8XX_SYNC=80
+# CONFIG_SCSI_NCR53C8XX_PROFILE is not set
+# CONFIG_SCSI_NCR53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_NCR53C8XX_PQS_PDS is not set
+# CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT is not set
 # CONFIG_SCSI_PAS16 is not set
 # CONFIG_SCSI_PCI2000 is not set
 # CONFIG_SCSI_PCI2220I is not set
@@ -327,10 +445,11 @@
 # ARCnet devices
 #
 # CONFIG_ARCNET is not set
-CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
+CONFIG_DUMMY=m
+CONFIG_BONDING=m
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
 
 #
 # Ethernet (10 or 100Mbit)
@@ -342,75 +461,138 @@
 # CONFIG_SUNQE is not set
 # CONFIG_SUNLANCE is not set
 # CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_EL1 is not set
+# CONFIG_EL2 is not set
+# CONFIG_ELPLUS is not set
+# CONFIG_EL16 is not set
+# CONFIG_ELMC is not set
+# CONFIG_ELMC_II is not set
+CONFIG_VORTEX=m
 # CONFIG_LANCE is not set
-# CONFIG_NET_VENDOR_SMC is not set
-# CONFIG_NET_VENDOR_RACAL is not set
+CONFIG_NET_VENDOR_SMC=y
+# CONFIG_WD80x3 is not set
+# CONFIG_ULTRAMCA is not set
+# CONFIG_ULTRA is not set
+# CONFIG_ULTRA32 is not set
+# CONFIG_SMC9194 is not set
+CONFIG_NET_VENDOR_RACAL=y
+# CONFIG_NI5010 is not set
+# CONFIG_NI52 is not set
+# CONFIG_NI65 is not set
 # CONFIG_HP100 is not set
 # CONFIG_NET_ISA is not set
 CONFIG_NET_PCI=y
-# CONFIG_PCNET32 is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_PCNET32=m
+CONFIG_ADAPTEC_STARFIRE=m
 # CONFIG_APRICOT is not set
 # CONFIG_CS89x0 is not set
-# CONFIG_TULIP is not set
-# CONFIG_DE4X5 is not set
-# CONFIG_DGRS is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+CONFIG_DE4X5=m
+CONFIG_DGRS=m
 # CONFIG_DM9102 is not set
 CONFIG_EEPRO100=y
 # CONFIG_LNE390 is not set
 # CONFIG_FEALNX is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NE2K_PCI is not set
+CONFIG_NATSEMI=m
+CONFIG_NE2K_PCI=m
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
+CONFIG_8139TOO=m
 # CONFIG_8139TOO_PIO is not set
 # CONFIG_8139TOO_TUNE_TWISTER is not set
 # CONFIG_8139TOO_8129 is not set
-# CONFIG_SIS900 is not set
-# CONFIG_EPIC100 is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
-# CONFIG_VIA_RHINE is not set
+CONFIG_SIS900=m
+CONFIG_EPIC100=m
+CONFIG_SUNDANCE=m
+CONFIG_TLAN=m
+CONFIG_VIA_RHINE=m
 # CONFIG_VIA_RHINE_MMIO is not set
-# CONFIG_WINBOND_840 is not set
+CONFIG_WINBOND_840=m
 # CONFIG_NET_POCKET is not set
 
 #
 # Ethernet (1000 Mbit)
 #
-# CONFIG_ACENIC is not set
-# CONFIG_DL2K is not set
+CONFIG_ACENIC=m
+CONFIG_ACENIC_OMIT_TIGON_I=y
+CONFIG_NET_BROADCOM=m
+CONFIG_DL2K=m
+CONFIG_E1000=y
 # CONFIG_MYRI_SBUS is not set
 # CONFIG_NS83820 is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_SK98LIN is not set
-# CONFIG_FDDI is not set
+CONFIG_HAMACHI=m
+CONFIG_YELLOWFIN=m
+CONFIG_SK98LIN=m
+CONFIG_TIGON3=m
+CONFIG_FDDI=y
+CONFIG_DEFXX=m
+CONFIG_SKFP=m
 # CONFIG_HIPPI is not set
-# CONFIG_PLIP is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
+CONFIG_PLIP=m
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPPOE=m
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_SLIP_MODE_SLIP6=y
 
 #
 # Wireless LAN (non-hamradio)
 #
-# CONFIG_NET_RADIO is not set
+CONFIG_NET_RADIO=y
+CONFIG_STRIP=m
+CONFIG_WAVELAN=m
+# CONFIG_ARLAN is not set
+CONFIG_AIRONET4500=m
+CONFIG_AIRONET4500_NONCS=m
+# CONFIG_AIRONET4500_PNP is not set
+CONFIG_AIRONET4500_PCI=y
+# CONFIG_AIRONET4500_ISA is not set
+# CONFIG_AIRONET4500_I365 is not set
+CONFIG_AIRONET4500_PROC=m
+CONFIG_AIRO=m
+# CONFIG_HERMES is not set
+# CONFIG_PLX_HERMES is not set
+CONFIG_NET_WIRELESS=y
 
 #
 # Token Ring devices
 #
 # CONFIG_TR is not set
-# CONFIG_NET_FC is not set
+CONFIG_NET_FC=y
+CONFIG_IPHASE5526=m
 # CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 
 #
 # Wan interfaces
 #
-# CONFIG_WAN is not set
+CONFIG_WAN=y
+# CONFIG_HOSTESS_SV11 is not set
+# CONFIG_COSA is not set
+# CONFIG_COMX is not set
+# CONFIG_DSCC4 is not set
+CONFIG_FARSYNC=m
+# CONFIG_LANMEDIA is not set
+# CONFIG_SEALEVEL_4021 is not set
+# CONFIG_SYNCLINK_SYNCPPP is not set
+# CONFIG_HDLC is not set
+CONFIG_DLCI=m
+CONFIG_DLCI_COUNT=24
+CONFIG_DLCI_MAX=8
+CONFIG_SDLA=m
+# CONFIG_LAPBETHER is not set
+# CONFIG_X25_ASY is not set
 
 #
 # Amateur Radio support
@@ -420,7 +602,89 @@
 #
 # ISDN subsystem
 #
-# CONFIG_ISDN is not set
+CONFIG_ISDN=m
+CONFIG_ISDN_PPP=y
+CONFIG_ISDN_PPP_VJ=y
+CONFIG_ISDN_MPP=y
+CONFIG_ISDN_PPP_BSDCOMP=m
+CONFIG_ISDN_AUDIO=y
+CONFIG_ISDN_TTY_FAX=y
+
+#
+# ISDN feature submodules
+#
+CONFIG_ISDN_DRV_LOOP=m
+# CONFIG_ISDN_DIVERSION is not set
+
+#
+# low-level hardware drivers
+#
+
+#
+# Passive ISDN cards
+#
+CONFIG_ISDN_DRV_HISAX=m
+
+#
+#   D-channel protocol features
+#
+CONFIG_HISAX_EURO=y
+CONFIG_DE_AOC=y
+# CONFIG_HISAX_NO_SENDCOMPLETE is not set
+# CONFIG_HISAX_NO_LLC is not set
+# CONFIG_HISAX_NO_KEYPAD is not set
+CONFIG_HISAX_1TR6=y
+CONFIG_HISAX_NI1=y
+CONFIG_HISAX_MAX_CARDS=8
+
+#
+#   HiSax supported cards
+#
+CONFIG_HISAX_16_0=y
+CONFIG_HISAX_16_3=y
+CONFIG_HISAX_TELESPCI=y
+CONFIG_HISAX_S0BOX=y
+CONFIG_HISAX_AVM_A1=y
+CONFIG_HISAX_FRITZPCI=y
+CONFIG_HISAX_AVM_A1_PCMCIA=y
+# CONFIG_HISAX_ELSA is not set
+CONFIG_HISAX_IX1MICROR2=y
+CONFIG_HISAX_DIEHLDIVA=y
+CONFIG_HISAX_ASUSCOM=y
+CONFIG_HISAX_TELEINT=y
+CONFIG_HISAX_HFCS=y
+# CONFIG_HISAX_SEDLBAUER is not set
+CONFIG_HISAX_SPORTSTER=y
+CONFIG_HISAX_MIC=y
+CONFIG_HISAX_NETJET=y
+CONFIG_HISAX_NETJET_U=y
+CONFIG_HISAX_NICCY=y
+CONFIG_HISAX_ISURF=y
+CONFIG_HISAX_HSTSAPHIR=y
+CONFIG_HISAX_BKM_A4T=y
+CONFIG_HISAX_SCT_QUADRO=y
+CONFIG_HISAX_GAZEL=y
+CONFIG_HISAX_HFC_PCI=y
+CONFIG_HISAX_W6692=y
+CONFIG_HISAX_HFC_SX=y
+CONFIG_HISAX_DEBUG=y
+# CONFIG_HISAX_SEDLBAUER_CS is not set
+# CONFIG_HISAX_ELSA_CS is not set
+# CONFIG_HISAX_ST5481 is not set
+# CONFIG_HISAX_FRITZ_PCIPNP is not set
+
+#
+# Active ISDN cards
+#
+CONFIG_ISDN_DRV_ICN=m
+CONFIG_ISDN_DRV_PCBIT=m
+# CONFIG_ISDN_DRV_SC is not set
+# CONFIG_ISDN_DRV_ACT2000 is not set
+# CONFIG_ISDN_DRV_EICON is not set
+CONFIG_ISDN_DRV_TPAM=m
+# CONFIG_ISDN_CAPI is not set
+CONFIG_HYSDN=m
+# CONFIG_HYSDN_CAPI is not set
 
 #
 # CD-ROM drivers (not for SCSI or IDE/ATAPI drives)
@@ -435,8 +699,8 @@
 CONFIG_INPUT_MOUSEDEV=y
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=m
 
 #
 # Character devices
@@ -445,16 +709,32 @@
 CONFIG_VT_CONSOLE=y
 CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
-# CONFIG_SERIAL_ACPI is not set
-# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_ACPI=y
+# CONFIG_SERIAL_ACPI_CONSOLE_DETECT is not set
+CONFIG_SERIAL_EXTENDED=y
+CONFIG_SERIAL_MANY_PORTS=y
+CONFIG_SERIAL_SHARE_IRQ=y
+# CONFIG_SERIAL_DETECT_IRQ is not set
+CONFIG_SERIAL_MULTIPORT=y
+# CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
+CONFIG_PRINTER=m
+# CONFIG_LP_CONSOLE is not set
+# CONFIG_PPDEV is not set
 
 #
 # I2C support
 #
-# CONFIG_I2C is not set
+CONFIG_I2C=m
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_PHILIPSPAR is not set
+# CONFIG_I2C_ELV is not set
+# CONFIG_I2C_VELLEMAN is not set
+# CONFIG_I2C_ALGOPCF is not set
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_PROC=m
 
 #
 # Mice
@@ -468,14 +748,14 @@
 #
 # Joysticks
 #
-# CONFIG_INPUT_GAMEPORT is not set
+CONFIG_INPUT_GAMEPORT=m
 # CONFIG_INPUT_NS558 is not set
-# CONFIG_INPUT_LIGHTNING is not set
-# CONFIG_INPUT_PCIGAME is not set
-# CONFIG_INPUT_CS461X is not set
-# CONFIG_INPUT_EMU10K1 is not set
-CONFIG_INPUT_SERIO=y
-CONFIG_INPUT_SERPORT=y
+CONFIG_INPUT_LIGHTNING=m
+CONFIG_INPUT_PCIGAME=m
+CONFIG_INPUT_CS461X=m
+CONFIG_INPUT_EMU10K1=m
+CONFIG_INPUT_SERIO=m
+# CONFIG_INPUT_SERPORT is not set
 
 #
 # Joysticks
@@ -518,8 +798,9 @@
 #
 # CONFIG_FTAPE is not set
 CONFIG_AGP=y
-# CONFIG_AGP_INTEL is not set
+CONFIG_AGP_INTEL=y
 CONFIG_AGP_I460=y
+CONFIG_AGP_HP_ZX1=y
 # CONFIG_AGP_I810 is not set
 # CONFIG_AGP_VIA is not set
 # CONFIG_AGP_AMD is not set
@@ -527,35 +808,41 @@
 # CONFIG_AGP_ALI is not set
 # CONFIG_AGP_SWORKS is not set
 CONFIG_DRM=y
-# CONFIG_DRM_NEW is not set
-CONFIG_DRM_OLD=y
-CONFIG_DRM40_TDFX=y
-# CONFIG_DRM40_GAMMA is not set
-# CONFIG_DRM40_R128 is not set
-# CONFIG_DRM40_RADEON is not set
-# CONFIG_DRM40_I810 is not set
-# CONFIG_DRM40_MGA is not set
+CONFIG_DRM_NEW=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_GAMMA is not set
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
 
 #
 # Multimedia devices
 #
-CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_DEV=m
 
 #
 # Video For Linux
 #
 CONFIG_VIDEO_PROC_FS=y
-# CONFIG_I2C_PARPORT is not set
+CONFIG_I2C_PARPORT=m
 
 #
 # Video Adapters
 #
+CONFIG_VIDEO_BT848=m
 # CONFIG_VIDEO_PMS is not set
-# CONFIG_VIDEO_CPIA is not set
-# CONFIG_VIDEO_SAA5249 is not set
-# CONFIG_TUNER_3036 is not set
-# CONFIG_VIDEO_STRADIS is not set
-# CONFIG_VIDEO_ZORAN is not set
+CONFIG_VIDEO_BWQCAM=m
+CONFIG_VIDEO_CQCAM=m
+CONFIG_VIDEO_W9966=m
+CONFIG_VIDEO_CPIA=m
+# CONFIG_VIDEO_CPIA_PP is not set
+CONFIG_VIDEO_CPIA_USB=m
+CONFIG_VIDEO_SAA5249=m
+CONFIG_TUNER_3036=m
+CONFIG_VIDEO_STRADIS=m
+CONFIG_VIDEO_ZORAN=m
 # CONFIG_VIDEO_ZORAN_BUZ is not set
 # CONFIG_VIDEO_ZORAN_DC10 is not set
 # CONFIG_VIDEO_ZORAN_LML33 is not set
@@ -565,28 +852,29 @@
 #
 # Radio Adapters
 #
-# CONFIG_RADIO_CADET is not set
-# CONFIG_RADIO_RTRACK is not set
-# CONFIG_RADIO_RTRACK2 is not set
-# CONFIG_RADIO_AZTECH is not set
-# CONFIG_RADIO_GEMTEK is not set
-# CONFIG_RADIO_GEMTEK_PCI is not set
-# CONFIG_RADIO_MAXIRADIO is not set
-# CONFIG_RADIO_MAESTRO is not set
+CONFIG_RADIO_CADET=m
+CONFIG_RADIO_RTRACK=m
+CONFIG_RADIO_RTRACK2=m
+CONFIG_RADIO_AZTECH=m
+CONFIG_RADIO_GEMTEK=m
+CONFIG_RADIO_GEMTEK_PCI=m
+CONFIG_RADIO_MAXIRADIO=m
+CONFIG_RADIO_MAESTRO=m
 # CONFIG_RADIO_MIROPCM20 is not set
 # CONFIG_RADIO_MIROPCM20_RDS is not set
-# CONFIG_RADIO_SF16FMI is not set
-# CONFIG_RADIO_TERRATEC is not set
-# CONFIG_RADIO_TRUST is not set
-# CONFIG_RADIO_TYPHOON is not set
-# CONFIG_RADIO_ZOLTRIX is not set
+CONFIG_RADIO_SF16FMI=m
+CONFIG_RADIO_TERRATEC=m
+CONFIG_RADIO_TRUST=m
+CONFIG_RADIO_TYPHOON=m
+CONFIG_RADIO_TYPHOON_PROC_FS=y
+CONFIG_RADIO_ZOLTRIX=m
 
 #
 # File systems
 #
 # CONFIG_QUOTA is not set
 CONFIG_AUTOFS_FS=y
-# CONFIG_AUTOFS4_FS is not set
+CONFIG_AUTOFS4_FS=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
@@ -595,9 +883,9 @@
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
 # CONFIG_BFS_FS is not set
-CONFIG_EXT3_FS=m
-CONFIG_JBD=m
-CONFIG_JBD_DEBUG=y
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
 CONFIG_FAT_FS=y
 CONFIG_MSDOS_FS=y
 # CONFIG_UMSDOS_FS is not set
@@ -605,13 +893,13 @@
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
 # CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 # CONFIG_TMPFS is not set
-# CONFIG_RAMFS is not set
+CONFIG_RAMFS=m
 CONFIG_ISO9660_FS=y
-# CONFIG_JOLIET is not set
+CONFIG_JOLIET=y
 # CONFIG_ZISOFS is not set
-# CONFIG_MINIX_FS is not set
+CONFIG_MINIX_FS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_NTFS_FS is not set
 # CONFIG_NTFS_RW is not set
@@ -626,9 +914,9 @@
 # CONFIG_ROMFS_FS is not set
 CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_UDF_FS=m
 # CONFIG_UDF_RW is not set
-# CONFIG_UFS_FS is not set
+CONFIG_UFS_FS=m
 # CONFIG_UFS_FS_WRITE is not set
 
 #
@@ -644,7 +932,9 @@
 CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_SMB_FS is not set
+CONFIG_SMB_FS=m
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="cp437"
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
 # CONFIG_NCPFS_IOCTL_LOCKING is not set
@@ -655,7 +945,7 @@
 # CONFIG_NCPFS_NLS is not set
 # CONFIG_NCPFS_EXTRAS is not set
 # CONFIG_ZISOFS_FS is not set
-# CONFIG_ZLIB_FS_INFLATE is not set
+CONFIG_ZLIB_FS_INFLATE=m
 
 #
 # Partition Types
@@ -677,49 +967,49 @@
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
-# CONFIG_SMB_NLS is not set
+CONFIG_SMB_NLS=y
 CONFIG_NLS=y
 
 #
 # Native Language Support
 #
 CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
 
 #
 # Console drivers
@@ -729,33 +1019,65 @@
 #
 # Frame-buffer support
 #
-# CONFIG_FB is not set
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FB_RIVA=y
+# CONFIG_FB_CLGEN is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+CONFIG_FB_MATROX=y
+CONFIG_FB_MATROX_MILLENIUM=y
+# CONFIG_FB_MATROX_MYSTIQUE is not set
+CONFIG_FB_MATROX_G100=y
+CONFIG_FB_MATROX_I2C=m
+CONFIG_FB_MATROX_MAVEN=m
+CONFIG_FB_MATROX_G450=m
+CONFIG_FB_MATROX_MULTIHEAD=y
+CONFIG_FB_ATY=m
+# CONFIG_FB_ATY_GX is not set
+# CONFIG_FB_ATY_CT is not set
+# CONFIG_FB_RADEON is not set
+CONFIG_FB_ATY128=y
+# CONFIG_FB_SIS is not set
+CONFIG_FB_3DFX=m
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FBCON_ADVANCED is not set
+CONFIG_FBCON_CFB8=y
+CONFIG_FBCON_CFB16=y
+CONFIG_FBCON_CFB24=y
+CONFIG_FBCON_CFB32=y
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+# CONFIG_FBCON_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_PCI_CONSOLE=y
 
 #
 # Sound
 #
 CONFIG_SOUND=y
-# CONFIG_SOUND_BT878 is not set
+CONFIG_SOUND_BT878=m
 # CONFIG_SOUND_CMPCI is not set
 # CONFIG_SOUND_EMU10K1 is not set
 # CONFIG_MIDI_EMU10K1 is not set
-# CONFIG_SOUND_FUSION is not set
-CONFIG_SOUND_CS4281=y
+CONFIG_SOUND_FUSION=m
+CONFIG_SOUND_CS4281=m
 # CONFIG_SOUND_ES1370 is not set
 # CONFIG_SOUND_ES1371 is not set
 # CONFIG_SOUND_ESSSOLO1 is not set
-# CONFIG_SOUND_MAESTRO is not set
-# CONFIG_SOUND_MAESTRO3 is not set
-# CONFIG_SOUND_ICH is not set
-# CONFIG_SOUND_RME96XX is not set
-# CONFIG_SOUND_SONICVIBES is not set
-# CONFIG_SOUND_TRIDENT is not set
+CONFIG_SOUND_MAESTRO=m
+CONFIG_SOUND_MAESTRO3=m
+CONFIG_SOUND_ICH=m
+CONFIG_SOUND_RME96XX=m
+CONFIG_SOUND_SONICVIBES=m
+CONFIG_SOUND_TRIDENT=m
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
 # CONFIG_MIDI_VIA82CXXX is not set
 # CONFIG_SOUND_OSS is not set
-# CONFIG_SOUND_TVMIXER is not set
+CONFIG_SOUND_TVMIXER=m
 
 #
 # USB support
@@ -767,108 +1089,105 @@
 # Miscellaneous USB options
 #
 CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_BANDWIDTH is not set
+CONFIG_USB_BANDWIDTH=y
 # CONFIG_USB_LONG_TIMEOUT is not set
 
 #
 # USB Controllers
 #
-CONFIG_USB_UHCI=m
-# CONFIG_USB_UHCI_ALT is not set
-# CONFIG_USB_OHCI is not set
+CONFIG_USB_UHCI_ALT=y
+CONFIG_USB_OHCI=y
 
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_AUDIO is not set
-# CONFIG_USB_BLUETOOTH is not set
-# CONFIG_USB_STORAGE is not set
+CONFIG_USB_AUDIO=m
+CONFIG_USB_BLUETOOTH=m
+CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
 # CONFIG_USB_STORAGE_DATAFAB is not set
 # CONFIG_USB_STORAGE_FREECOM is not set
 # CONFIG_USB_STORAGE_ISD200 is not set
 # CONFIG_USB_STORAGE_DPCM is not set
-# CONFIG_USB_STORAGE_HP8200e is not set
+CONFIG_USB_STORAGE_HP8200e=y
 # CONFIG_USB_STORAGE_SDDR09 is not set
 # CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
 
 #
 # USB Human Interface Devices (HID)
 #
-CONFIG_USB_HID=m
-CONFIG_USB_HIDDEV=y
-CONFIG_USB_KBD=m
-CONFIG_USB_MOUSE=m
-# CONFIG_USB_WACOM is not set
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_WACOM=m
 
 #
 # USB Imaging devices
 #
-# CONFIG_USB_DC2XX is not set
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_SCANNER is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_HPUSBSCSI is not set
+CONFIG_USB_DC2XX=m
+CONFIG_USB_MDC800=m
+CONFIG_USB_SCANNER=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_HPUSBSCSI=m
 
 #
 # USB Multimedia devices
 #
-# CONFIG_USB_IBMCAM is not set
-# CONFIG_USB_OV511 is not set
-# CONFIG_USB_PWC is not set
-# CONFIG_USB_SE401 is not set
-# CONFIG_USB_DSBR is not set
-# CONFIG_USB_DABUSB is not set
+CONFIG_USB_IBMCAM=m
+CONFIG_USB_OV511=m
+CONFIG_USB_PWC=m
+CONFIG_USB_SE401=m
+CONFIG_USB_DSBR=m
+CONFIG_USB_DABUSB=m
 
 #
 # USB Network adaptors
 #
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_CDCETHER is not set
-# CONFIG_USB_USBNET is not set
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_CATC=m
+CONFIG_USB_CDCETHER=m
+CONFIG_USB_USBNET=m
 
 #
 # USB port drivers
 #
-# CONFIG_USB_USS720 is not set
+CONFIG_USB_USS720=m
 
 #
 # USB Serial Converter support
 #
-# CONFIG_USB_SERIAL is not set
-# CONFIG_USB_SERIAL_GENERIC is not set
-# CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_WHITEHEAT is not set
-# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
-# CONFIG_USB_SERIAL_VISOR is not set
-# CONFIG_USB_SERIAL_IR is not set
-# CONFIG_USB_SERIAL_EDGEPORT is not set
-# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
-# CONFIG_USB_SERIAL_KEYSPAN is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28 is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28X is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA19 is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA18X is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA19W is not set
-# CONFIG_USB_SERIAL_KEYSPAN_USA49W is not set
-# CONFIG_USB_SERIAL_MCT_U232 is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
-# CONFIG_USB_SERIAL_CYBERJACK is not set
-# CONFIG_USB_SERIAL_XIRCOM is not set
-# CONFIG_USB_SERIAL_OMNINET is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OMNINET=m
 
 #
 # USB Miscellaneous drivers
 #
-# CONFIG_USB_RIO500 is not set
+CONFIG_USB_RIO500=m
 
 #
 # Bluetooth support
@@ -876,16 +1195,15 @@
 # CONFIG_BLUEZ is not set
 
 #
+# Simulated drivers
+#
+# CONFIG_SIMETH is not set
+# CONFIG_SIM_SERIAL is not set
+# CONFIG_SCSI_SIM is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_IA64_GRANULE_16MB is not set
 CONFIG_IA64_GRANULE_64MB=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_IA64_PRINT_HAZARDS=y
-# CONFIG_DISABLE_VHPT is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_IA64_EARLY_PRINTK=y
-# CONFIG_DEBUG_SLAB is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_IA64_DEBUG_CMPXCHG is not set
-# CONFIG_IA64_DEBUG_IRQ is not set
+# CONFIG_DEBUG_KERNEL is not set
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/Makefile linux/arch/ia64/hp/Makefile
--- ../ia64/linux/arch/ia64/hp/Makefile	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/hp/Makefile	Mon Mar 11 20:19:41 2002
@@ -1,17 +1,15 @@
-#
-# ia64/platform/hp/Makefile
-#
-# Copyright (C) 1999 Silicon Graphics, Inc.
-# Copyright (C) Srinivasa Thirumalachar (sprasad@engr.sgi.com)
-#
+# arch/ia64/hp/Makefile
+# Copyright (c) 2002 Matthew Wilcox for Hewlett Packard
 
-all: hp.a
+ALL_SUB_DIRS := sim zx1 common
 
-O_TARGET := hp.a
+O_TARGET := hp.o
 
-obj-y := hpsim_console.o hpsim_irq.o hpsim_setup.o
-obj-$(CONFIG_IA64_GENERIC) += hpsim_machvec.o
+subdir-$(CONFIG_IA64_GENERIC) += $(ALL_SUB_DIRS)
+subdir-$(CONFIG_IA64_HP_SIM) += sim
+subdir-$(CONFIG_IA64_HP_ZX1) += zx1 common
 
-clean::
+SUB_DIRS := $(subdir-y)
+obj-y += $(join $(subdir-y),$(subdir-y:%=/%.o))
 
 include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/common/Makefile linux/arch/ia64/hp/common/Makefile
--- ../ia64/linux/arch/ia64/hp/common/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/common/Makefile	Mon Mar 11 20:19:41 2002
@@ -0,0 +1,14 @@
+#
+# ia64/platform/hp/common/Makefile
+#
+# Copyright (C) 2002 Hewlett Packard
+# Copyright (C) Alex Williamson (alex_williamson@hp.com)
+#
+
+O_TARGET := common.o
+
+export-objs := sba_iommu.o
+
+obj-y := sba_iommu.o
+
+include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/common/sba_iommu.c linux/arch/ia64/hp/common/sba_iommu.c
--- ../ia64/linux/arch/ia64/hp/common/sba_iommu.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/common/sba_iommu.c	Fri Apr 12 09:06:01 2002
@@ -0,0 +1,1862 @@
+/*
+**  IA64 System Bus Adapter (SBA) I/O MMU manager
+**
+**	(c) Copyright 2002 Alex Williamson
+**	(c) Copyright 2002 Hewlett-Packard Company
+**
+**	Portions (c) 2000 Grant Grundler (from parisc I/O MMU code)
+**	Portions (c) 1999 Dave S. Miller (from sparc64 I/O MMU code)
+**
+**	This program is free software; you can redistribute it and/or modify
+**	it under the terms of the GNU General Public License as published by
+**      the Free Software Foundation; either version 2 of the License, or
+**      (at your option) any later version.
+**
+**
+** This module initializes the IOC (I/O Controller) found on HP
+** McKinley machines and their successors.
+**
+*/
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+
+#include <asm/delay.h>		/* ia64_get_itc() */
+#include <asm/io.h>
+#include <asm/page.h>		/* PAGE_OFFSET */
+#include <asm/efi.h>
+
+
+#define DRIVER_NAME "SBA"
+
+#ifndef CONFIG_IA64_HP_PROTO
+#define ALLOW_IOV_BYPASS
+#endif
+#define ENABLE_MARK_CLEAN
+/*
+** The number of debug flags is a clue - this code is fragile.
+*/
+#undef DEBUG_SBA_INIT
+#undef DEBUG_SBA_RUN
+#undef DEBUG_SBA_RUN_SG
+#undef DEBUG_SBA_RESOURCE
+#undef ASSERT_PDIR_SANITY
+#undef DEBUG_LARGE_SG_ENTRIES
+#undef DEBUG_BYPASS
+
+#define SBA_INLINE	__inline__
+/* #define SBA_INLINE */
+
+#ifdef DEBUG_SBA_INIT
+#define DBG_INIT(x...)	printk(x)
+#else
+#define DBG_INIT(x...)
+#endif
+
+#ifdef DEBUG_SBA_RUN
+#define DBG_RUN(x...)	printk(x)
+#else
+#define DBG_RUN(x...)
+#endif
+
+#ifdef DEBUG_SBA_RUN_SG
+#define DBG_RUN_SG(x...)	printk(x)
+#else
+#define DBG_RUN_SG(x...)
+#endif
+
+
+#ifdef DEBUG_SBA_RESOURCE
+#define DBG_RES(x...)	printk(x)
+#else
+#define DBG_RES(x...)
+#endif
+
+#ifdef DEBUG_BYPASS
+#define DBG_BYPASS(x...)	printk(x)
+#else
+#define DBG_BYPASS(x...)
+#endif
+
+#ifdef ASSERT_PDIR_SANITY
+#define ASSERT(expr) \
+        if(!(expr)) { \
+                printk( "\n" __FILE__ ":%d: Assertion " #expr " failed!\n",__LINE__); \
+                panic(#expr); \
+        }
+#else
+#define ASSERT(expr)
+#endif
+
+#define KB(x) ((x) * 1024)
+#define MB(x) (KB (KB (x)))
+#define GB(x) (MB (KB (x)))
+
+/*
+** The number of pdir entries to "free" before issueing
+** a read to PCOM register to flush out PCOM writes.
+** Interacts with allocation granularity (ie 4 or 8 entries
+** allocated and free'd/purged at a time might make this
+** less interesting).
+*/
+#define DELAYED_RESOURCE_CNT	16
+
+#define DEFAULT_DMA_HINT_REG	0
+
+#define ZX1_FUNC_ID_VALUE    ((PCI_DEVICE_ID_HP_ZX1_SBA << 16) | PCI_VENDOR_ID_HP)
+#define ZX1_MC_ID    ((PCI_DEVICE_ID_HP_ZX1_MC << 16) | PCI_VENDOR_ID_HP)
+
+#define SBA_FUNC_ID	0x0000	/* function id */
+#define SBA_FCLASS	0x0008	/* function class, bist, header, rev... */
+
+#define SBA_FUNC_SIZE	0x10000   /* SBA configuration function reg set */
+
+unsigned int __initdata zx1_func_offsets[] = {0x1000, 0x4000, 0x8000,
+                                              0x9000, 0xa000, -1};
+
+#define SBA_IOC_OFFSET	0x1000
+
+#define MAX_IOC		1	/* we only have 1 for now*/
+
+#define IOC_IBASE	0x300	/* IO TLB */
+#define IOC_IMASK	0x308
+#define IOC_PCOM	0x310
+#define IOC_TCNFG	0x318
+#define IOC_PDIR_BASE	0x320
+
+#define IOC_IOVA_SPACE_BASE	0x40000000 /* IOVA ranges start at 1GB */
+
+/*
+** IOC supports 4/8/16/64KB page sizes (see TCNFG register)
+** It's safer (avoid memory corruption) to keep DMA page mappings
+** equivalently sized to VM PAGE_SIZE.
+**
+** We really can't avoid generating a new mapping for each
+** page since the Virtual Coherence Index has to be generated
+** and updated for each page.
+**
+** IOVP_SIZE could only be greater than PAGE_SIZE if we are
+** confident the drivers really only touch the next physical
+** page iff that driver instance owns it.
+*/
+#define IOVP_SIZE	PAGE_SIZE
+#define IOVP_SHIFT	PAGE_SHIFT
+#define IOVP_MASK	PAGE_MASK
+
+struct ioc {
+	unsigned long	ioc_hpa;	/* I/O MMU base address */
+	char		*res_map;	/* resource map, bit == pdir entry */
+	u64		*pdir_base;	/* physical base address */
+	unsigned long	ibase;		/* pdir IOV Space base */
+	unsigned long	imask;		/* pdir IOV Space mask */
+
+	unsigned long	*res_hint;	/* next avail IOVP - circular search */
+	spinlock_t	res_lock;
+	unsigned long	hint_mask_pdir;	/* bits used for DMA hints */
+	unsigned int	res_bitshift;	/* from the RIGHT! */
+	unsigned int	res_size;	/* size of resource map in bytes */
+	unsigned int	hint_shift_pdir;
+	unsigned long	dma_mask;
+#if DELAYED_RESOURCE_CNT > 0
+	int saved_cnt;
+	struct sba_dma_pair {
+		dma_addr_t	iova;
+		size_t		size;
+	} saved[DELAYED_RESOURCE_CNT];
+#endif
+
+#ifdef CONFIG_PROC_FS
+#define SBA_SEARCH_SAMPLE	0x100
+	unsigned long avg_search[SBA_SEARCH_SAMPLE];
+	unsigned long avg_idx;	/* current index into avg_search */
+	unsigned long used_pages;
+	unsigned long msingle_calls;
+	unsigned long msingle_pages;
+	unsigned long msg_calls;
+	unsigned long msg_pages;
+	unsigned long usingle_calls;
+	unsigned long usingle_pages;
+	unsigned long usg_calls;
+	unsigned long usg_pages;
+#ifdef ALLOW_IOV_BYPASS
+	unsigned long msingle_bypass;
+	unsigned long usingle_bypass;
+	unsigned long msg_bypass;
+#endif
+#endif
+
+	/* STUFF We don't need in performance path */
+	unsigned int	pdir_size;	/* in bytes, determined by IOV Space size */
+};
+
+struct sba_device {
+	struct sba_device	*next;	/* list of SBA's in system */
+	const char 		*name;
+	unsigned long		sba_hpa; /* base address */
+	spinlock_t		sba_lock;
+	unsigned int		flags;  /* state/functionality enabled */
+	unsigned int		hw_rev;  /* HW revision of chip */
+
+	unsigned int		num_ioc;  /* number of on-board IOC's */
+	struct ioc		ioc[MAX_IOC];
+};
+
+
+static struct sba_device *sba_list;
+static int sba_count;
+static int reserve_sba_gart = 1;
+static struct pci_dev sac_only_dev;
+
+#define sba_sg_iova(sg) (sg->address)
+#define sba_sg_len(sg) (sg->length)
+#define sba_sg_buffer(sg) (sg->orig_address)
+
+/* REVISIT - fix me for multiple SBAs/IOCs */
+#define GET_IOC(dev) (sba_list->ioc)
+#define SBA_SET_AGP(sba_dev) (sba_dev->flags |= 0x1)
+#define SBA_GET_AGP(sba_dev) (sba_dev->flags & 0x1)
+
+/*
+** DMA_CHUNK_SIZE is used by the SCSI mid-layer to break up
+** (or rather not merge) DMA's into managable chunks.
+** On parisc, this is more of the software/tuning constraint
+** rather than the HW. I/O MMU allocation alogorithms can be
+** faster with smaller size is (to some degree).
+*/
+#define DMA_CHUNK_SIZE  (BITS_PER_LONG*PAGE_SIZE)
+
+/* Looks nice and keeps the compiler happy */
+#define SBA_DEV(d) ((struct sba_device *) (d))
+
+#define ROUNDUP(x,y) ((x + ((y)-1)) & ~((y)-1))
+
+/************************************
+** SBA register read and write support
+**
+** BE WARNED: register writes are posted.
+**  (ie follow writes which must reach HW with a read)
+**
+*/
+#define READ_REG(addr)       __raw_readq(addr)
+#define WRITE_REG(val, addr) __raw_writeq(val, addr)
+
+#ifdef DEBUG_SBA_INIT
+
+/**
+ * sba_dump_tlb - debugging only - print IOMMU operating parameters
+ * @hpa: base address of the IOMMU
+ *
+ * Print the size/location of the IO MMU PDIR.
+ */
+static void
+sba_dump_tlb(char *hpa)
+{
+	DBG_INIT("IO TLB at 0x%p\n", (void *)hpa);
+	DBG_INIT("IOC_IBASE    : %016lx\n", READ_REG(hpa+IOC_IBASE));
+	DBG_INIT("IOC_IMASK    : %016lx\n", READ_REG(hpa+IOC_IMASK));
+	DBG_INIT("IOC_TCNFG    : %016lx\n", READ_REG(hpa+IOC_TCNFG));
+	DBG_INIT("IOC_PDIR_BASE: %016lx\n", READ_REG(hpa+IOC_PDIR_BASE));
+	DBG_INIT("\n");
+}
+#endif
+
+
+#ifdef ASSERT_PDIR_SANITY
+
+/**
+ * sba_dump_pdir_entry - debugging only - print one IOMMU PDIR entry
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @msg: text to print ont the output line.
+ * @pide: pdir index.
+ *
+ * Print one entry of the IO MMU PDIR in human readable form.
+ */
+static void
+sba_dump_pdir_entry(struct ioc *ioc, char *msg, uint pide)
+{
+	/* start printing from lowest pde in rval */
+	u64 *ptr = &(ioc->pdir_base[pide  & ~(BITS_PER_LONG - 1)]);
+	unsigned long *rptr = (unsigned long *) &(ioc->res_map[(pide >>3) & ~(sizeof(unsigned long) - 1)]);
+	uint rcnt;
+
+	/* printk(KERN_DEBUG "SBA: %s rp %p bit %d rval 0x%lx\n", */
+	printk("SBA: %s rp %p bit %d rval 0x%lx\n",
+		 msg, rptr, pide & (BITS_PER_LONG - 1), *rptr);
+
+	rcnt = 0;
+	while (rcnt < BITS_PER_LONG) {
+		printk("%s %2d %p %016Lx\n",
+			(rcnt == (pide & (BITS_PER_LONG - 1)))
+				? "    -->" : "       ",
+			rcnt, ptr, *ptr );
+		rcnt++;
+		ptr++;
+	}
+	printk("%s", msg);
+}
+
+
+/**
+ * sba_check_pdir - debugging only - consistency checker
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @msg: text to print ont the output line.
+ *
+ * Verify the resource map and pdir state is consistent
+ */
+static int
+sba_check_pdir(struct ioc *ioc, char *msg)
+{
+	u64 *rptr_end = (u64 *) &(ioc->res_map[ioc->res_size]);
+	u64 *rptr = (u64 *) ioc->res_map;	/* resource map ptr */
+	u64 *pptr = ioc->pdir_base;	/* pdir ptr */
+	uint pide = 0;
+
+	while (rptr < rptr_end) {
+		u64 rval;
+		int rcnt; /* number of bits we might check */
+
+		rval = *rptr;
+		rcnt = 64;
+
+		while (rcnt) {
+			/* Get last byte and highest bit from that */
+			u32 pde = ((u32)((*pptr >> (63)) & 0x1));
+			if ((rval & 0x1) ^ pde)
+			{
+				/*
+				** BUMMER!  -- res_map != pdir --
+				** Dump rval and matching pdir entries
+				*/
+				sba_dump_pdir_entry(ioc, msg, pide);
+				return(1);
+			}
+			rcnt--;
+			rval >>= 1;	/* try the next bit */
+			pptr++;
+			pide++;
+		}
+		rptr++;	/* look at next word of res_map */
+	}
+	/* It'd be nice if we always got here :^) */
+	return 0;
+}
+
+
+/**
+ * sba_dump_sg - debugging only - print Scatter-Gather list
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @startsg: head of the SG list
+ * @nents: number of entries in SG list
+ *
+ * print the SG list so we can verify it's correct by hand.
+ */
+static void
+sba_dump_sg( struct ioc *ioc, struct scatterlist *startsg, int nents)
+{
+	while (nents-- > 0) {
+		printk(" %d : %08lx/%05x %p\n",
+				nents,
+				(unsigned long) sba_sg_iova(startsg),
+				sba_sg_len(startsg),
+				sba_sg_buffer(startsg));
+		startsg++;
+	}
+}
+static void
+sba_check_sg( struct ioc *ioc, struct scatterlist *startsg, int nents)
+{
+	struct scatterlist *the_sg = startsg;
+	int the_nents = nents;
+
+	while (the_nents-- > 0) {
+		if (sba_sg_buffer(the_sg) == 0x0UL)
+			sba_dump_sg(NULL, startsg, nents);
+		the_sg++;
+	}
+}
+
+#endif /* ASSERT_PDIR_SANITY */
+
+
+
+
+/**************************************************************
+*
+*   I/O Pdir Resource Management
+*
+*   Bits set in the resource map are in use.
+*   Each bit can represent a number of pages.
+*   LSbs represent lower addresses (IOVA's).
+*
+***************************************************************/
+#define PAGES_PER_RANGE 1	/* could increase this to 4 or 8 if needed */
+
+/* Convert from IOVP to IOVA and vice versa. */
+#define SBA_IOVA(ioc,iovp,offset,hint_reg) ((ioc->ibase) | (iovp) | (offset) | ((hint_reg)<<(ioc->hint_shift_pdir)))
+#define SBA_IOVP(ioc,iova) (((iova) & ioc->hint_mask_pdir) & ~(ioc->ibase))
+
+/* FIXME : review these macros to verify correctness and usage */
+#define PDIR_INDEX(iovp)   ((iovp)>>IOVP_SHIFT)
+
+#define RESMAP_MASK(n)    ~(~0UL << (n))
+#define RESMAP_IDX_MASK   (sizeof(unsigned long) - 1)
+
+
+/**
+ * sba_search_bitmap - find free space in IO PDIR resource bitmap
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @bits_wanted: number of entries we need.
+ *
+ * Find consecutive free bits in resource bitmap.
+ * Each bit represents one entry in the IO Pdir.
+ * Cool perf optimization: search for log2(size) bits at a time.
+ */
+static SBA_INLINE unsigned long
+sba_search_bitmap(struct ioc *ioc, unsigned long bits_wanted)
+{
+	unsigned long *res_ptr = ioc->res_hint;
+	unsigned long *res_end = (unsigned long *) &(ioc->res_map[ioc->res_size]);
+	unsigned long pide = ~0UL;
+
+	ASSERT(((unsigned long) ioc->res_hint & (sizeof(unsigned long) - 1UL)) == 0);
+	ASSERT(res_ptr < res_end);
+	if (bits_wanted > (BITS_PER_LONG/2)) {
+		/* Search word at a time - no mask needed */
+		for(; res_ptr < res_end; ++res_ptr) {
+			if (*res_ptr == 0) {
+				*res_ptr = RESMAP_MASK(bits_wanted);
+				pide = ((unsigned long)res_ptr - (unsigned long)ioc->res_map);
+				pide <<= 3;	/* convert to bit address */
+				break;
+			}
+		}
+		/* point to the next word on next pass */
+		res_ptr++;
+		ioc->res_bitshift = 0;
+	} else {
+		/*
+		** Search the resource bit map on well-aligned values.
+		** "o" is the alignment.
+		** We need the alignment to invalidate I/O TLB using
+		** SBA HW features in the unmap path.
+		*/
+		unsigned long o = 1 << get_order(bits_wanted << PAGE_SHIFT);
+		uint bitshiftcnt = ROUNDUP(ioc->res_bitshift, o);
+		unsigned long mask;
+
+		if (bitshiftcnt >= BITS_PER_LONG) {
+			bitshiftcnt = 0;
+			res_ptr++;
+		}
+		mask = RESMAP_MASK(bits_wanted) << bitshiftcnt;
+
+		DBG_RES("%s() o %ld %p", __FUNCTION__, o, res_ptr);
+		while(res_ptr < res_end)
+		{ 
+			DBG_RES("    %p %lx %lx\n", res_ptr, mask, *res_ptr);
+			ASSERT(0 != mask);
+			if(0 == ((*res_ptr) & mask)) {
+				*res_ptr |= mask;     /* mark resources busy! */
+				pide = ((unsigned long)res_ptr - (unsigned long)ioc->res_map);
+				pide <<= 3;	/* convert to bit address */
+				pide += bitshiftcnt;
+				break;
+			}
+			mask <<= o;
+			bitshiftcnt += o;
+			if (0 == mask) {
+				mask = RESMAP_MASK(bits_wanted);
+				bitshiftcnt=0;
+				res_ptr++;
+			}
+		}
+		/* look in the same word on the next pass */
+		ioc->res_bitshift = bitshiftcnt + bits_wanted;
+	}
+
+	/* wrapped ? */
+	if (res_end <= res_ptr) {
+		ioc->res_hint = (unsigned long *) ioc->res_map;
+		ioc->res_bitshift = 0;
+	} else {
+		ioc->res_hint = res_ptr;
+	}
+	return (pide);
+}
+
+
+/**
+ * sba_alloc_range - find free bits and mark them in IO PDIR resource bitmap
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @size: number of bytes to create a mapping for
+ *
+ * Given a size, find consecutive unmarked and then mark those bits in the
+ * resource bit map.
+ */
+static int
+sba_alloc_range(struct ioc *ioc, size_t size)
+{
+	unsigned int pages_needed = size >> IOVP_SHIFT;
+#ifdef CONFIG_PROC_FS
+	unsigned long itc_start = ia64_get_itc();
+#endif
+	unsigned long pide;
+
+	ASSERT(pages_needed);
+	ASSERT((pages_needed * IOVP_SIZE) <= DMA_CHUNK_SIZE);
+	ASSERT(pages_needed <= BITS_PER_LONG);
+	ASSERT(0 == (size & ~IOVP_MASK));
+
+	/*
+	** "seek and ye shall find"...praying never hurts either...
+	*/
+
+	pide = sba_search_bitmap(ioc, pages_needed);
+	if (pide >= (ioc->res_size << 3)) {
+		pide = sba_search_bitmap(ioc, pages_needed);
+		if (pide >= (ioc->res_size << 3))
+			panic(__FILE__ ": I/O MMU @ %lx is out of mapping resources\n", ioc->ioc_hpa);
+	}
+
+#ifdef ASSERT_PDIR_SANITY
+	/* verify the first enable bit is clear */
+	if(0x00 != ((u8 *) ioc->pdir_base)[pide*sizeof(u64) + 7]) {
+		sba_dump_pdir_entry(ioc, "sba_search_bitmap() botched it?", pide);
+	}
+#endif
+
+	DBG_RES("%s(%x) %d -> %lx hint %x/%x\n",
+		__FUNCTION__, size, pages_needed, pide,
+		(uint) ((unsigned long) ioc->res_hint - (unsigned long) ioc->res_map),
+		ioc->res_bitshift );
+
+#ifdef CONFIG_PROC_FS
+	{
+		unsigned long itc_end = ia64_get_itc();
+		unsigned long tmp = itc_end - itc_start;
+		/* check for roll over */
+		itc_start = (itc_end < itc_start) ?  -(tmp) : (tmp);
+	}
+	ioc->avg_search[ioc->avg_idx++] = itc_start;
+	ioc->avg_idx &= SBA_SEARCH_SAMPLE - 1;
+
+	ioc->used_pages += pages_needed;
+#endif
+
+	return (pide);
+}
+
+
+/**
+ * sba_free_range - unmark bits in IO PDIR resource bitmap
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @iova: IO virtual address which was previously allocated.
+ * @size: number of bytes to create a mapping for
+ *
+ * clear bits in the ioc's resource map
+ */
+static SBA_INLINE void
+sba_free_range(struct ioc *ioc, dma_addr_t iova, size_t size)
+{
+	unsigned long iovp = SBA_IOVP(ioc, iova);
+	unsigned int pide = PDIR_INDEX(iovp);
+	unsigned int ridx = pide >> 3;	/* convert bit to byte address */
+	unsigned long *res_ptr = (unsigned long *) &((ioc)->res_map[ridx & ~RESMAP_IDX_MASK]);
+
+	int bits_not_wanted = size >> IOVP_SHIFT;
+
+	/* 3-bits "bit" address plus 2 (or 3) bits for "byte" == bit in word */
+	unsigned long m = RESMAP_MASK(bits_not_wanted) << (pide & (BITS_PER_LONG - 1));
+
+	DBG_RES("%s( ,%x,%x) %x/%lx %x %p %lx\n",
+		__FUNCTION__, (uint) iova, size,
+		bits_not_wanted, m, pide, res_ptr, *res_ptr);
+
+#ifdef CONFIG_PROC_FS
+	ioc->used_pages -= bits_not_wanted;
+#endif
+
+	ASSERT(m != 0);
+	ASSERT(bits_not_wanted);
+	ASSERT((bits_not_wanted * IOVP_SIZE) <= DMA_CHUNK_SIZE);
+	ASSERT(bits_not_wanted <= BITS_PER_LONG);
+	ASSERT((*res_ptr & m) == m); /* verify same bits are set */
+	*res_ptr &= ~m;
+}
+
+
+/**************************************************************
+*
+*   "Dynamic DMA Mapping" support (aka "Coherent I/O")
+*
+***************************************************************/
+
+#define SBA_DMA_HINT(ioc, val) ((val) << (ioc)->hint_shift_pdir)
+
+
+/**
+ * sba_io_pdir_entry - fill in one IO PDIR entry
+ * @pdir_ptr:  pointer to IO PDIR entry
+ * @vba: Virtual CPU address of buffer to map
+ *
+ * SBA Mapping Routine
+ *
+ * Given a virtual address (vba, arg1) sba_io_pdir_entry()
+ * loads the I/O PDIR entry pointed to by pdir_ptr (arg0).
+ * Each IO Pdir entry consists of 8 bytes as shown below
+ * (LSB == bit 0):
+ *
+ *  63                    40                                 11    7        0
+ * +-+---------------------+----------------------------------+----+--------+
+ * |V|        U            |            PPN[39:12]            | U  |   FF   |
+ * +-+---------------------+----------------------------------+----+--------+
+ *
+ *  V  == Valid Bit
+ *  U  == Unused
+ * PPN == Physical Page Number
+ *
+ * The physical address fields are filled with the results of virt_to_phys()
+ * on the vba.
+ */
+
+#if 1
+#define sba_io_pdir_entry(pdir_ptr, vba) *pdir_ptr = ((vba & ~0xE000000000000FFFULL) | 0x80000000000000FFULL)
+#else
+void SBA_INLINE
+sba_io_pdir_entry(u64 *pdir_ptr, unsigned long vba)
+{
+	*pdir_ptr = ((vba & ~0xE000000000000FFFULL) | 0x80000000000000FFULL);
+}
+#endif
+
+#ifdef ENABLE_MARK_CLEAN
+/**
+ * Since DMA is i-cache coherent, any (complete) pages that were written via
+ * DMA can be marked as "clean" so that update_mmu_cache() doesn't have to
+ * flush them when they get mapped into an executable vm-area.
+ */
+static void
+mark_clean (void *addr, size_t size)
+{
+	unsigned long pg_addr, end;
+
+	pg_addr = PAGE_ALIGN((unsigned long) addr);
+	end = (unsigned long) addr + size;
+	while (pg_addr + PAGE_SIZE <= end) {
+		struct page *page = virt_to_page(pg_addr);
+		set_bit(PG_arch_1, &page->flags);
+		pg_addr += PAGE_SIZE;
+	}
+}
+#endif
+
+/**
+ * sba_mark_invalid - invalidate one or more IO PDIR entries
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @iova:  IO Virtual Address mapped earlier
+ * @byte_cnt:  number of bytes this mapping covers.
+ *
+ * Marking the IO PDIR entry(ies) as Invalid and invalidate
+ * corresponding IO TLB entry. The PCOM (Purge Command Register)
+ * is to purge stale entries in the IO TLB when unmapping entries.
+ *
+ * The PCOM register supports purging of multiple pages, with a minium
+ * of 1 page and a maximum of 2GB. Hardware requires the address be
+ * aligned to the size of the range being purged. The size of the range
+ * must be a power of 2. The "Cool perf optimization" in the
+ * allocation routine helps keep that true.
+ */
+static SBA_INLINE void
+sba_mark_invalid(struct ioc *ioc, dma_addr_t iova, size_t byte_cnt)
+{
+	u32 iovp = (u32) SBA_IOVP(ioc,iova);
+
+	int off = PDIR_INDEX(iovp);
+
+	/* Must be non-zero and rounded up */
+	ASSERT(byte_cnt > 0);
+	ASSERT(0 == (byte_cnt & ~IOVP_MASK));
+
+#ifdef ASSERT_PDIR_SANITY
+	/* Assert first pdir entry is set */
+	if (!(ioc->pdir_base[off] >> 60)) {
+		sba_dump_pdir_entry(ioc,"sba_mark_invalid()", PDIR_INDEX(iovp));
+	}
+#endif
+
+	if (byte_cnt <= IOVP_SIZE)
+	{
+		ASSERT(off < ioc->pdir_size);
+
+		iovp |= IOVP_SHIFT;     /* set "size" field for PCOM */
+
+		/*
+		** clear I/O PDIR entry "valid" bit
+		** Do NOT clear the rest - save it for debugging.
+		** We should only clear bits that have previously
+		** been enabled.
+		*/
+		ioc->pdir_base[off] &= ~(0x80000000000000FFULL);
+	} else {
+		u32 t = get_order(byte_cnt) + PAGE_SHIFT;
+
+		iovp |= t;
+		ASSERT(t <= 31);   /* 2GB! Max value of "size" field */
+
+		do {
+			/* verify this pdir entry is enabled */
+			ASSERT(ioc->pdir_base[off]  >> 63);
+			/* clear I/O Pdir entry "valid" bit first */
+			ioc->pdir_base[off] &= ~(0x80000000000000FFULL);
+			off++;
+			byte_cnt -= IOVP_SIZE;
+		} while (byte_cnt > 0);
+	}
+
+	WRITE_REG(iovp, ioc->ioc_hpa+IOC_PCOM);
+}
+
+/**
+ * sba_map_single - map one buffer and return IOVA for DMA
+ * @dev: instance of PCI owned by the driver that's asking.
+ * @addr:  driver buffer to map.
+ * @size:  number of bytes to map in driver buffer.
+ * @direction:  R/W or both.
+ *
+ * See Documentation/DMA-mapping.txt
+ */
+dma_addr_t
+sba_map_single(struct pci_dev *dev, void *addr, size_t size, int direction)
+{
+	struct ioc *ioc;
+	unsigned long flags; 
+	dma_addr_t iovp;
+	dma_addr_t offset;
+	u64 *pdir_start;
+	int pide;
+#ifdef ALLOW_IOV_BYPASS
+	unsigned long pci_addr = virt_to_phys(addr);
+#endif
+
+	ioc = GET_IOC(dev);
+	ASSERT(ioc);
+
+#ifdef ALLOW_IOV_BYPASS
+	/*
+ 	** Check if the PCI device can DMA to ptr... if so, just return ptr
+ 	*/
+	if ((pci_addr & ~dev->dma_mask) == 0) {
+		/*
+ 		** Device is bit capable of DMA'ing to the buffer...
+		** just return the PCI address of ptr
+ 		*/
+#ifdef CONFIG_PROC_FS
+		spin_lock_irqsave(&ioc->res_lock, flags);
+		ioc->msingle_bypass++;
+		spin_unlock_irqrestore(&ioc->res_lock, flags);
+#endif
+		DBG_BYPASS("sba_map_single() bypass mask/addr: 0x%lx/0x%lx\n",
+		           dev->dma_mask, pci_addr);
+		return pci_addr;
+	}
+#endif
+
+	ASSERT(size > 0);
+	ASSERT(size <= DMA_CHUNK_SIZE);
+
+	/* save offset bits */
+	offset = ((dma_addr_t) (long) addr) & ~IOVP_MASK;
+
+	/* round up to nearest IOVP_SIZE */
+	size = (size + offset + ~IOVP_MASK) & IOVP_MASK;
+
+	spin_lock_irqsave(&ioc->res_lock, flags);
+#ifdef ASSERT_PDIR_SANITY
+	if (sba_check_pdir(ioc,"Check before sba_map_single()"))
+		panic("Sanity check failed");
+#endif
+
+#ifdef CONFIG_PROC_FS
+	ioc->msingle_calls++;
+	ioc->msingle_pages += size >> IOVP_SHIFT;
+#endif
+	pide = sba_alloc_range(ioc, size);
+	iovp = (dma_addr_t) pide << IOVP_SHIFT;
+
+	DBG_RUN("%s() 0x%p -> 0x%lx\n",
+		__FUNCTION__, addr, (long) iovp | offset);
+
+	pdir_start = &(ioc->pdir_base[pide]);
+
+	while (size > 0) {
+		ASSERT(((u8 *)pdir_start)[7] == 0); /* verify availability */
+		sba_io_pdir_entry(pdir_start, (unsigned long) addr);
+
+		DBG_RUN("     pdir 0x%p %lx\n", pdir_start, *pdir_start);
+
+		addr += IOVP_SIZE;
+		size -= IOVP_SIZE;
+		pdir_start++;
+	}
+	/* form complete address */
+#ifdef ASSERT_PDIR_SANITY
+	sba_check_pdir(ioc,"Check after sba_map_single()");
+#endif
+	spin_unlock_irqrestore(&ioc->res_lock, flags);
+	return SBA_IOVA(ioc, iovp, offset, DEFAULT_DMA_HINT_REG);
+}
+
+/**
+ * sba_unmap_single - unmap one IOVA and free resources
+ * @dev: instance of PCI owned by the driver that's asking.
+ * @iova:  IOVA of driver buffer previously mapped.
+ * @size:  number of bytes mapped in driver buffer.
+ * @direction:  R/W or both.
+ *
+ * See Documentation/DMA-mapping.txt
+ */
+void sba_unmap_single(struct pci_dev *dev, dma_addr_t iova, size_t size,
+		int direction)
+{
+	struct ioc *ioc;
+#if DELAYED_RESOURCE_CNT > 0
+	struct sba_dma_pair *d;
+#endif
+	unsigned long flags; 
+	dma_addr_t offset;
+
+	ioc = GET_IOC(dev);
+	ASSERT(ioc);
+
+#ifdef ALLOW_IOV_BYPASS
+	if ((iova & ioc->imask) != ioc->ibase) {
+		/*
+		** Address does not fall w/in IOVA, must be bypassing
+		*/
+#ifdef CONFIG_PROC_FS
+		spin_lock_irqsave(&ioc->res_lock, flags);
+		ioc->usingle_bypass++;
+		spin_unlock_irqrestore(&ioc->res_lock, flags);
+#endif
+		DBG_BYPASS("sba_unmap_single() bypass addr: 0x%lx\n", iova);
+
+#ifdef ENABLE_MARK_CLEAN
+		if (direction == PCI_DMA_FROMDEVICE) {
+			mark_clean(phys_to_virt(iova), size);
+		}
+#endif
+		return;
+	}
+#endif
+	offset = iova & ~IOVP_MASK;
+
+	DBG_RUN("%s() iovp 0x%lx/%x\n",
+		__FUNCTION__, (long) iova, size);
+
+	iova ^= offset;        /* clear offset bits */
+	size += offset;
+	size = ROUNDUP(size, IOVP_SIZE);
+
+	spin_lock_irqsave(&ioc->res_lock, flags);
+#ifdef CONFIG_PROC_FS
+	ioc->usingle_calls++;
+	ioc->usingle_pages += size >> IOVP_SHIFT;
+#endif
+
+#if DELAYED_RESOURCE_CNT > 0
+	d = &(ioc->saved[ioc->saved_cnt]);
+	d->iova = iova;
+	d->size = size;
+	if (++(ioc->saved_cnt) >= DELAYED_RESOURCE_CNT) {
+		int cnt = ioc->saved_cnt;
+		while (cnt--) {
+			sba_mark_invalid(ioc, d->iova, d->size);
+			sba_free_range(ioc, d->iova, d->size);
+			d--;
+		}
+		ioc->saved_cnt = 0;
+		READ_REG(ioc->ioc_hpa+IOC_PCOM);	/* flush purges */
+	}
+#else /* DELAYED_RESOURCE_CNT == 0 */
+	sba_mark_invalid(ioc, iova, size);
+	sba_free_range(ioc, iova, size);
+	READ_REG(ioc->ioc_hpa+IOC_PCOM);	/* flush purges */
+#endif /* DELAYED_RESOURCE_CNT == 0 */
+#ifdef ENABLE_MARK_CLEAN
+	if (direction == PCI_DMA_FROMDEVICE) {
+		u32 iovp = (u32) SBA_IOVP(ioc,iova);
+		int off = PDIR_INDEX(iovp);
+		void *addr;
+
+		if (size <= IOVP_SIZE) {
+			addr = phys_to_virt(ioc->pdir_base[off] &
+					    ~0xE000000000000FFFULL);
+			mark_clean(addr, size);
+		} else {
+			size_t byte_cnt = size;
+
+			do {
+				addr = phys_to_virt(ioc->pdir_base[off] &
+				                    ~0xE000000000000FFFULL);
+				mark_clean(addr, min(byte_cnt, IOVP_SIZE));
+				off++;
+				byte_cnt -= IOVP_SIZE;
+
+			   } while (byte_cnt > 0);
+		}
+	}
+#endif
+	spin_unlock_irqrestore(&ioc->res_lock, flags);
+
+	/* XXX REVISIT for 2.5 Linux - need syncdma for zero-copy support.
+	** For Astro based systems this isn't a big deal WRT performance.
+	** As long as 2.4 kernels copyin/copyout data from/to userspace,
+	** we don't need the syncdma. The issue here is I/O MMU cachelines
+	** are *not* coherent in all cases.  May be hwrev dependent.
+	** Need to investigate more.
+	asm volatile("syncdma");	
+	*/
+}
+
+
+/**
+ * sba_alloc_consistent - allocate/map shared mem for DMA
+ * @hwdev: instance of PCI owned by the driver that's asking.
+ * @size:  number of bytes mapped in driver buffer.
+ * @dma_handle:  IOVA of new buffer.
+ *
+ * See Documentation/DMA-mapping.txt
+ */
+void *
+sba_alloc_consistent(struct pci_dev *hwdev, size_t size, dma_addr_t *dma_handle)
+{
+	void *ret;
+
+	if (!hwdev) {
+		/* only support PCI */
+		*dma_handle = 0;
+		return 0;
+	}
+
+        ret = (void *) __get_free_pages(GFP_ATOMIC, get_order(size));
+
+	if (ret) {
+		memset(ret, 0, size);
+		/*
+		 * REVISIT: if sba_map_single starts needing more
+		 * than dma_mask from the device, this needs to be
+		 * updated.
+		 */
+		*dma_handle = sba_map_single(&sac_only_dev, ret, size, 0);
+	}
+
+	return ret;
+}
+
+
+/**
+ * sba_free_consistent - free/unmap shared mem for DMA
+ * @hwdev: instance of PCI owned by the driver that's asking.
+ * @size:  number of bytes mapped in driver buffer.
+ * @vaddr:  virtual address IOVA of "consistent" buffer.
+ * @dma_handler:  IO virtual address of "consistent" buffer.
+ *
+ * See Documentation/DMA-mapping.txt
+ */
+void sba_free_consistent(struct pci_dev *hwdev, size_t size, void *vaddr,
+		dma_addr_t dma_handle)
+{
+	sba_unmap_single(hwdev, dma_handle, size, 0);
+	free_pages((unsigned long) vaddr, get_order(size));
+}
+
+
+/*
+** Since 0 is a valid pdir_base index value, can't use that
+** to determine if a value is valid or not. Use a flag to indicate
+** the SG list entry contains a valid pdir index.
+*/
+#define PIDE_FLAG 0x1UL
+
+#ifdef DEBUG_LARGE_SG_ENTRIES
+int dump_run_sg = 0;
+#endif
+
+
+/**
+ * sba_fill_pdir - write allocated SG entries into IO PDIR
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @startsg:  list of IOVA/size pairs
+ * @nents: number of entries in startsg list
+ *
+ * Take preprocessed SG list and write corresponding entries
+ * in the IO PDIR.
+ */
+
+static SBA_INLINE int
+sba_fill_pdir(
+	struct ioc *ioc,
+	struct scatterlist *startsg,
+	int nents)
+{
+	struct scatterlist *dma_sg = startsg;	/* pointer to current DMA */
+	int n_mappings = 0;
+	u64 *pdirp = 0;
+	unsigned long dma_offset = 0;
+
+	dma_sg--;
+	while (nents-- > 0) {
+		int     cnt = sba_sg_len(startsg);
+		sba_sg_len(startsg) = 0;
+
+#ifdef DEBUG_LARGE_SG_ENTRIES
+		if (dump_run_sg)
+			printk(" %2d : %08lx/%05x %p\n",
+				nents,
+				(unsigned long) sba_sg_iova(startsg), cnt,
+				sba_sg_buffer(startsg)
+		);
+#else
+		DBG_RUN_SG(" %d : %08lx/%05x %p\n",
+				nents,
+				(unsigned long) sba_sg_iova(startsg), cnt,
+				sba_sg_buffer(startsg)
+		);
+#endif
+		/*
+		** Look for the start of a new DMA stream
+		*/
+		if ((u64)sba_sg_iova(startsg) & PIDE_FLAG) {
+			u32 pide = (u64)sba_sg_iova(startsg) & ~PIDE_FLAG;
+			dma_offset = (unsigned long) pide & ~IOVP_MASK;
+			sba_sg_iova(startsg) = 0;
+			dma_sg++;
+			sba_sg_iova(dma_sg) = (char *)(pide | ioc->ibase);
+			pdirp = &(ioc->pdir_base[pide >> IOVP_SHIFT]);
+			n_mappings++;
+		}
+
+		/*
+		** Look for a VCONTIG chunk
+		*/
+		if (cnt) {
+			unsigned long vaddr = (unsigned long) sba_sg_buffer(startsg);
+			ASSERT(pdirp);
+
+			/* Since multiple Vcontig blocks could make up
+			** one DMA stream, *add* cnt to dma_len.
+			*/
+			sba_sg_len(dma_sg) += cnt;
+			cnt += dma_offset;
+			dma_offset=0;	/* only want offset on first chunk */
+			cnt = ROUNDUP(cnt, IOVP_SIZE);
+#ifdef CONFIG_PROC_FS
+			ioc->msg_pages += cnt >> IOVP_SHIFT;
+#endif
+			do {
+				sba_io_pdir_entry(pdirp, vaddr);
+				vaddr += IOVP_SIZE;
+				cnt -= IOVP_SIZE;
+				pdirp++;
+			} while (cnt > 0);
+		}
+		startsg++;
+	}
+#ifdef DEBUG_LARGE_SG_ENTRIES
+	dump_run_sg = 0;
+#endif
+	return(n_mappings);
+}
+
+
+/*
+** Two address ranges are DMA contiguous *iff* "end of prev" and
+** "start of next" are both on a page boundry.
+**
+** (shift left is a quick trick to mask off upper bits)
+*/
+#define DMA_CONTIG(__X, __Y) \
+	(((((unsigned long) __X) | ((unsigned long) __Y)) << (BITS_PER_LONG - PAGE_SHIFT)) == 0UL)
+
+
+/**
+ * sba_coalesce_chunks - preprocess the SG list
+ * @ioc: IO MMU structure which owns the pdir we are interested in.
+ * @startsg:  list of IOVA/size pairs
+ * @nents: number of entries in startsg list
+ *
+ * First pass is to walk the SG list and determine where the breaks are
+ * in the DMA stream. Allocates PDIR entries but does not fill them.
+ * Returns the number of DMA chunks.
+ *
+ * Doing the fill seperate from the coalescing/allocation keeps the
+ * code simpler. Future enhancement could make one pass through
+ * the sglist do both.
+ */
+static SBA_INLINE int
+sba_coalesce_chunks( struct ioc *ioc,
+	struct scatterlist *startsg,
+	int nents)
+{
+	struct scatterlist *vcontig_sg;    /* VCONTIG chunk head */
+	unsigned long vcontig_len;         /* len of VCONTIG chunk */
+	unsigned long vcontig_end;
+	struct scatterlist *dma_sg;        /* next DMA stream head */
+	unsigned long dma_offset, dma_len; /* start/len of DMA stream */
+	int n_mappings = 0;
+
+	while (nents > 0) {
+		unsigned long vaddr = (unsigned long) (startsg->address); 
+
+		/*
+		** Prepare for first/next DMA stream
+		*/
+		dma_sg = vcontig_sg = startsg;
+		dma_len = vcontig_len = vcontig_end = sba_sg_len(startsg);
+		vcontig_end +=  vaddr;
+		dma_offset = vaddr & ~IOVP_MASK;
+
+		/* PARANOID: clear entries */
+		sba_sg_buffer(startsg) = sba_sg_iova(startsg);
+		sba_sg_iova(startsg) = 0;
+		sba_sg_len(startsg) = 0;
+
+		/*
+		** This loop terminates one iteration "early" since
+		** it's always looking one "ahead".
+		*/
+		while (--nents > 0) {
+			unsigned long vaddr;	/* tmp */
+
+			startsg++;
+
+			/* catch brokenness in SCSI layer */
+			ASSERT(startsg->length <= DMA_CHUNK_SIZE);
+
+			/*
+			** First make sure current dma stream won't
+			** exceed DMA_CHUNK_SIZE if we coalesce the
+			** next entry.
+			*/
+			if (((dma_len + dma_offset + startsg->length + ~IOVP_MASK) & IOVP_MASK) > DMA_CHUNK_SIZE)
+				break;
+
+			/*
+			** Then look for virtually contiguous blocks.
+			**
+			** append the next transaction?
+			*/
+			vaddr = (unsigned long) sba_sg_iova(startsg);
+			if  (vcontig_end == vaddr)
+			{
+				vcontig_len += sba_sg_len(startsg);
+				vcontig_end += sba_sg_len(startsg);
+				dma_len     += sba_sg_len(startsg);
+				sba_sg_buffer(startsg) = (char *)vaddr;
+				sba_sg_iova(startsg) = 0;
+				sba_sg_len(startsg) = 0;
+				continue;
+			}
+
+#ifdef DEBUG_LARGE_SG_ENTRIES
+			dump_run_sg = (vcontig_len > IOVP_SIZE);
+#endif
+
+			/*
+			** Not virtually contigous.
+			** Terminate prev chunk.
+			** Start a new chunk.
+			**
+			** Once we start a new VCONTIG chunk, dma_offset
+			** can't change. And we need the offset from the first
+			** chunk - not the last one. Ergo Successive chunks
+			** must start on page boundaries and dove tail
+			** with it's predecessor.
+			*/
+			sba_sg_len(vcontig_sg) = vcontig_len;
+
+			vcontig_sg = startsg;
+			vcontig_len = sba_sg_len(startsg);
+
+			/*
+			** 3) do the entries end/start on page boundaries?
+			**    Don't update vcontig_end until we've checked.
+			*/
+			if (DMA_CONTIG(vcontig_end, vaddr))
+			{
+				vcontig_end = vcontig_len + vaddr;
+				dma_len += vcontig_len;
+				sba_sg_buffer(startsg) = (char *)vaddr;
+				sba_sg_iova(startsg) = 0;
+				continue;
+			} else {
+				break;
+			}
+		}
+
+		/*
+		** End of DMA Stream
+		** Terminate last VCONTIG block.
+		** Allocate space for DMA stream.
+		*/
+		sba_sg_len(vcontig_sg) = vcontig_len;
+		dma_len = (dma_len + dma_offset + ~IOVP_MASK) & IOVP_MASK;
+		ASSERT(dma_len <= DMA_CHUNK_SIZE);
+		sba_sg_iova(dma_sg) = (char *) (PIDE_FLAG 
+			| (sba_alloc_range(ioc, dma_len) << IOVP_SHIFT)
+			| dma_offset);
+		n_mappings++;
+	}
+
+	return n_mappings;
+}
+
+
+/**
+ * sba_map_sg - map Scatter/Gather list
+ * @dev: instance of PCI owned by the driver that's asking.
+ * @sglist:  array of buffer/length pairs
+ * @nents:  number of entries in list
+ * @direction:  R/W or both.
+ *
+ * See Documentation/DMA-mapping.txt
+ */
+int sba_map_sg(struct pci_dev *dev, struct scatterlist *sglist, int nents,
+		int direction)
+{
+	struct ioc *ioc;
+	int coalesced, filled = 0;
+	unsigned long flags;
+#ifdef ALLOW_IOV_BYPASS
+	struct scatterlist *sg;
+#endif
+
+	DBG_RUN_SG("%s() START %d entries\n", __FUNCTION__, nents);
+	ioc = GET_IOC(dev);
+	ASSERT(ioc);
+
+#ifdef ALLOW_IOV_BYPASS
+	if (dev->dma_mask >= ioc->dma_mask) {
+		for (sg = sglist ; filled < nents ; filled++, sg++){
+			sba_sg_buffer(sg) = sba_sg_iova(sg);
+			sba_sg_iova(sg) = (char *)virt_to_phys(sba_sg_buffer(sg));
+		}
+#ifdef CONFIG_PROC_FS
+		spin_lock_irqsave(&ioc->res_lock, flags);
+		ioc->msg_bypass++;
+		spin_unlock_irqrestore(&ioc->res_lock, flags);
+#endif
+		return filled;
+	}
+#endif
+	/* Fast path single entry scatterlists. */
+	if (nents == 1) {
+		sba_sg_buffer(sglist) = sba_sg_iova(sglist);
+		sba_sg_iova(sglist) = (char *)sba_map_single(dev,
+						sba_sg_buffer(sglist),
+						sba_sg_len(sglist), direction);
+#ifdef CONFIG_PROC_FS
+		/*
+		** Should probably do some stats counting, but trying to
+		** be precise quickly starts wasting CPU time.
+		*/
+#endif
+		return 1;
+	}
+
+	spin_lock_irqsave(&ioc->res_lock, flags);
+
+#ifdef ASSERT_PDIR_SANITY
+	if (sba_check_pdir(ioc,"Check before sba_map_sg()"))
+	{
+		sba_dump_sg(ioc, sglist, nents);
+		panic("Check before sba_map_sg()");
+	}
+#endif
+
+#ifdef CONFIG_PROC_FS
+	ioc->msg_calls++;
+#endif
+
+	/*
+	** First coalesce the chunks and allocate I/O pdir space
+	**
+	** If this is one DMA stream, we can properly map using the
+	** correct virtual address associated with each DMA page.
+	** w/o this association, we wouldn't have coherent DMA!
+	** Access to the virtual address is what forces a two pass algorithm.
+	*/
+	coalesced = sba_coalesce_chunks(ioc, sglist, nents);
+ 
+	/*
+	** Program the I/O Pdir
+	**
+	** map the virtual addresses to the I/O Pdir
+	** o dma_address will contain the pdir index
+	** o dma_len will contain the number of bytes to map 
+	** o address contains the virtual address.
+	*/
+	filled = sba_fill_pdir(ioc, sglist, nents);
+
+#ifdef ASSERT_PDIR_SANITY
+	if (sba_check_pdir(ioc,"Check after sba_map_sg()"))
+	{
+		sba_dump_sg(ioc, sglist, nents);
+		panic("Check after sba_map_sg()\n");
+	}
+#endif
+
+	spin_unlock_irqrestore(&ioc->res_lock, flags);
+
+	ASSERT(coalesced == filled);
+	DBG_RUN_SG("%s() DONE %d mappings\n", __FUNCTION__, filled);
+
+	return filled;
+}
+
+
+/**
+ * sba_unmap_sg - unmap Scatter/Gather list
+ * @dev: instance of PCI owned by the driver that's asking.
+ * @sglist:  array of buffer/length pairs
+ * @nents:  number of entries in list
+ * @direction:  R/W or both.
+ *
+ * See Documentation/DMA-mapping.txt
+ */
+void sba_unmap_sg(struct pci_dev *dev, struct scatterlist *sglist, int nents,
+		int direction)
+{
+	struct ioc *ioc;
+#ifdef ASSERT_PDIR_SANITY
+	unsigned long flags;
+#endif
+
+	DBG_RUN_SG("%s() START %d entries,  %p,%x\n",
+		__FUNCTION__, nents, sba_sg_buffer(sglist), sglist->length);
+
+	ioc = GET_IOC(dev);
+	ASSERT(ioc);
+
+#ifdef CONFIG_PROC_FS
+	ioc->usg_calls++;
+#endif
+
+#ifdef ASSERT_PDIR_SANITY
+	spin_lock_irqsave(&ioc->res_lock, flags);
+	sba_check_pdir(ioc,"Check before sba_unmap_sg()");
+	spin_unlock_irqrestore(&ioc->res_lock, flags);
+#endif
+
+	while (sba_sg_len(sglist) && nents--) {
+
+		sba_unmap_single(dev, (dma_addr_t)sba_sg_iova(sglist),
+		                 sba_sg_len(sglist), direction);
+#ifdef CONFIG_PROC_FS
+		/*
+		** This leaves inconsistent data in the stats, but we can't
+		** tell which sg lists were mapped by map_single and which
+		** were coalesced to a single entry.  The stats are fun,
+		** but speed is more important.
+		*/
+		ioc->usg_pages += (((u64)sba_sg_iova(sglist) & ~IOVP_MASK) + sba_sg_len(sglist) + IOVP_SIZE - 1) >> PAGE_SHIFT;
+#endif
+		++sglist;
+	}
+
+	DBG_RUN_SG("%s() DONE (nents %d)\n", __FUNCTION__,  nents);
+
+#ifdef ASSERT_PDIR_SANITY
+	spin_lock_irqsave(&ioc->res_lock, flags);
+	sba_check_pdir(ioc,"Check after sba_unmap_sg()");
+	spin_unlock_irqrestore(&ioc->res_lock, flags);
+#endif
+
+}
+
+unsigned long
+sba_dma_address (struct scatterlist *sg)
+{
+	return ((unsigned long)sba_sg_iova(sg));
+}
+
+/**************************************************************
+*
+*   Initialization and claim
+*
+***************************************************************/
+
+
+static void
+sba_ioc_init(struct sba_device *sba_dev, struct ioc *ioc, int ioc_num)
+{
+	u32 iova_space_size, iova_space_mask;
+	void * pdir_base;
+	int pdir_size, iov_order, tcnfg;
+
+	/*
+	** Firmware programs the maximum IOV space size into the imask reg
+	*/
+	iova_space_size = ~(READ_REG(ioc->ioc_hpa + IOC_IMASK) & 0xFFFFFFFFUL) + 1;
+#ifdef CONFIG_IA64_HP_PROTO
+	if (!iova_space_size)
+		iova_space_size = GB(1);
+#endif
+
+	/*
+	** iov_order is always based on a 1GB IOVA space since we want to
+	** turn on the other half for AGP GART.
+	*/
+	iov_order = get_order(iova_space_size >> (IOVP_SHIFT-PAGE_SHIFT));
+	ioc->pdir_size = pdir_size = (iova_space_size/IOVP_SIZE) * sizeof(u64);
+
+	DBG_INIT("%s() hpa 0x%lx IOV %dMB (%d bits) PDIR size 0x%0x\n",
+		__FUNCTION__, ioc->ioc_hpa, iova_space_size>>20,
+		iov_order + PAGE_SHIFT, ioc->pdir_size);
+
+	/* FIXME : DMA HINTs not used */
+	ioc->hint_shift_pdir = iov_order + PAGE_SHIFT;
+	ioc->hint_mask_pdir = ~(0x3 << (iov_order + PAGE_SHIFT));
+
+	ioc->pdir_base =
+	pdir_base = (void *) __get_free_pages(GFP_KERNEL, get_order(pdir_size));
+	if (NULL == pdir_base)
+	{
+		panic(__FILE__ ":%s() could not allocate I/O Page Table\n", __FUNCTION__);
+	}
+	memset(pdir_base, 0, pdir_size);
+
+	DBG_INIT("%s() pdir %p size %x hint_shift_pdir %x hint_mask_pdir %lx\n",
+		__FUNCTION__, pdir_base, pdir_size,
+		ioc->hint_shift_pdir, ioc->hint_mask_pdir);
+
+	ASSERT((((unsigned long) pdir_base) & PAGE_MASK) == (unsigned long) pdir_base);
+	WRITE_REG(virt_to_phys(pdir_base), ioc->ioc_hpa + IOC_PDIR_BASE);
+
+	DBG_INIT(" base %p\n", pdir_base);
+
+	/* build IMASK for IOC and Elroy */
+	iova_space_mask =  0xffffffff;
+	iova_space_mask <<= (iov_order + PAGE_SHIFT);
+
+#ifdef CONFIG_IA64_HP_PROTO
+	/*
+	** REVISIT - this is a kludge, but we won't be supporting anything but
+	** zx1 2.0 or greater for real.  When fw is in shape, ibase will
+	** be preprogrammed w/ the IOVA hole base and imask will give us
+	** the size.
+	*/
+	if ((sba_dev->hw_rev & 0xFF) < 0x20) {
+		DBG_INIT("%s() Found SBA rev < 2.0, setting IOVA base to 0.  This device will not be supported in the future.\n", __FUNCTION__);
+		ioc->ibase = 0x0;
+	} else
+#endif
+	ioc->ibase = READ_REG(ioc->ioc_hpa + IOC_IBASE) & 0xFFFFFFFEUL;
+
+	ioc->imask = iova_space_mask;	/* save it */
+
+	DBG_INIT("%s() IOV base 0x%lx mask 0x%0lx\n",
+		__FUNCTION__, ioc->ibase, ioc->imask);
+
+	/*
+	** FIXME: Hint registers are programmed with default hint
+	** values during boot, so hints should be sane even if we
+	** can't reprogram them the way drivers want.
+	*/
+
+	WRITE_REG(ioc->imask, ioc->ioc_hpa+IOC_IMASK);
+
+	/*
+	** Setting the upper bits makes checking for bypass addresses
+	** a little faster later on.
+	*/
+	ioc->imask |= 0xFFFFFFFF00000000UL;
+
+	/* Set I/O PDIR Page size to system page size */
+	switch (PAGE_SHIFT) {
+		case 12: /* 4K */
+			tcnfg = 0;
+			break;
+		case 13: /* 8K */
+			tcnfg = 1;
+			break;
+		case 14: /* 16K */
+			tcnfg = 2;
+			break;
+		case 16: /* 64K */
+			tcnfg = 3;
+			break;
+	}
+	WRITE_REG(tcnfg, ioc->ioc_hpa+IOC_TCNFG);
+
+	/*
+	** Program the IOC's ibase and enable IOVA translation
+	** Bit zero == enable bit.
+	*/
+	WRITE_REG(ioc->ibase | 1, ioc->ioc_hpa+IOC_IBASE);
+
+	/*
+	** Clear I/O TLB of any possible entries.
+	** (Yes. This is a bit paranoid...but so what)
+	*/
+	WRITE_REG(0 | 31, ioc->ioc_hpa+IOC_PCOM);
+
+	/*
+	** If an AGP device is present, only use half of the IOV space
+	** for PCI DMA.  Unfortunately we can't know ahead of time
+	** whether GART support will actually be used, for now we
+	** can just key on an AGP device found in the system.
+	** We program the next pdir index after we stop w/ a key for
+	** the GART code to handshake on.
+	*/
+	if (SBA_GET_AGP(sba_dev)) {
+		DBG_INIT("%s() AGP Device found, reserving 512MB for GART support\n", __FUNCTION__);
+		ioc->pdir_size /= 2;
+		((u64 *)pdir_base)[PDIR_INDEX(iova_space_size/2)] = 0x0000badbadc0ffeeULL;
+	}
+
+	DBG_INIT("%s() DONE\n", __FUNCTION__);
+}
+
+
+
+/**************************************************************************
+**
+**   SBA initialization code (HW and SW)
+**
+**   o identify SBA chip itself
+**   o FIXME: initialize DMA hints for reasonable defaults
+**
+**************************************************************************/
+
+static void
+sba_hw_init(struct sba_device *sba_dev)
+{ 
+	int i;
+	int num_ioc;
+	u64 dma_mask;
+	u32 func_id;
+
+	/*
+	** Identify the SBA so we can set the dma_mask.  We can make a virtual
+	** dma_mask of the memory subsystem such that devices not implmenting
+	** a full 64bit mask might still be able to bypass efficiently.
+	*/
+	func_id = READ_REG(sba_dev->sba_hpa + SBA_FUNC_ID);
+
+	if (func_id == ZX1_FUNC_ID_VALUE) {
+		dma_mask = 0xFFFFFFFFFFUL;
+	} else {
+		dma_mask = 0xFFFFFFFFFFFFFFFFUL;
+	}
+
+	DBG_INIT("%s(): ioc->dma_mask == 0x%lx\n", __FUNCTION__, dma_mask);
+	
+	/*
+	** Leaving in the multiple ioc code from parisc for the future,
+	** currently there are no muli-ioc mckinley sbas
+	*/
+	sba_dev->ioc[0].ioc_hpa = SBA_IOC_OFFSET;
+	num_ioc = 1;
+
+	sba_dev->num_ioc = num_ioc;
+	for (i = 0; i < num_ioc; i++) {
+		sba_dev->ioc[i].dma_mask = dma_mask;
+		sba_dev->ioc[i].ioc_hpa += sba_dev->sba_hpa;
+		sba_ioc_init(sba_dev, &(sba_dev->ioc[i]), i);
+	}
+}
+
+static void
+sba_common_init(struct sba_device *sba_dev)
+{
+	int i;
+
+	/* add this one to the head of the list (order doesn't matter)
+	** This will be useful for debugging - especially if we get coredumps
+	*/
+	sba_dev->next = sba_list;
+	sba_list = sba_dev;
+	sba_count++;
+
+	for(i=0; i< sba_dev->num_ioc; i++) {
+		int res_size;
+
+		/* resource map size dictated by pdir_size */
+		res_size = sba_dev->ioc[i].pdir_size/sizeof(u64); /* entries */
+		res_size >>= 3;  /* convert bit count to byte count */
+		DBG_INIT("%s() res_size 0x%x\n",
+			__FUNCTION__, res_size);
+
+		sba_dev->ioc[i].res_size = res_size;
+		sba_dev->ioc[i].res_map = (char *) __get_free_pages(GFP_KERNEL, get_order(res_size));
+
+		if (NULL == sba_dev->ioc[i].res_map)
+		{
+			panic(__FILE__ ":%s() could not allocate resource map\n", __FUNCTION__ );
+		}
+
+		memset(sba_dev->ioc[i].res_map, 0, res_size);
+		/* next available IOVP - circular search */
+		if ((sba_dev->hw_rev & 0xFF) >= 0x20) {
+			sba_dev->ioc[i].res_hint = (unsigned long *)
+			    sba_dev->ioc[i].res_map;
+		} else {
+			u64 reserved_iov;
+			
+			/* Yet another 1.x hack */
+			printk("zx1 1.x: Starting resource hint offset into IOV space to avoid initial zero value IOVA\n");
+			sba_dev->ioc[i].res_hint = (unsigned long *)
+			    &(sba_dev->ioc[i].res_map[L1_CACHE_BYTES]);
+
+			sba_dev->ioc[i].res_map[0] = 0x1;
+			sba_dev->ioc[i].pdir_base[0] = 0x8000badbadc0ffeeULL;
+
+			for (reserved_iov = 0xA0000 ; reserved_iov < 0xC0000 ; reserved_iov += IOVP_SIZE) {
+				u64 *res_ptr = sba_dev->ioc[i].res_map;
+				int index = PDIR_INDEX(reserved_iov);
+				int res_word;
+				u64 mask;
+
+				res_word = (int)(index / BITS_PER_LONG);
+				mask =  0x1UL << (index - (res_word * BITS_PER_LONG));
+				res_ptr[res_word] |= mask;
+				sba_dev->ioc[i].pdir_base[PDIR_INDEX(reserved_iov)] = (0x80000000000000FFULL | reserved_iov);
+
+			}
+		}
+
+#ifdef ASSERT_PDIR_SANITY
+		/* Mark first bit busy - ie no IOVA 0 */
+		sba_dev->ioc[i].res_map[0] = 0x1;
+		sba_dev->ioc[i].pdir_base[0] = 0x8000badbadc0ffeeULL;
+#endif
+
+		DBG_INIT("%s() %d res_map %x %p\n", __FUNCTION__,
+		         i, res_size, (void *)sba_dev->ioc[i].res_map);
+	}
+
+	sba_dev->sba_lock = SPIN_LOCK_UNLOCKED;
+}
+
+#ifdef CONFIG_PROC_FS
+static int sba_proc_info(char *buf, char **start, off_t offset, int len)
+{
+	struct sba_device *sba_dev = sba_list;
+	struct ioc *ioc = &sba_dev->ioc[0];	/* FIXME: Multi-IOC support! */
+	int total_pages = (int) (ioc->res_size << 3); /* 8 bits per byte */
+	unsigned long i = 0, avg = 0, min, max;
+
+	sprintf(buf, "%s rev %d.%d\n",
+		"Hewlett Packard zx1 SBA",
+		((sba_dev->hw_rev >> 4) & 0xF),
+		(sba_dev->hw_rev & 0xF)
+		);
+	sprintf(buf, "%sIO PDIR size    : %d bytes (%d entries)\n",
+		buf,
+		(int) ((ioc->res_size << 3) * sizeof(u64)), /* 8 bits/byte */
+		total_pages);
+
+	sprintf(buf, "%sIO PDIR entries : %ld free  %ld used (%d%%)\n", buf,
+		total_pages - ioc->used_pages, ioc->used_pages,
+		(int) (ioc->used_pages * 100 / total_pages));
+	
+	sprintf(buf, "%sResource bitmap : %d bytes (%d pages)\n", 
+		buf, ioc->res_size, ioc->res_size << 3);   /* 8 bits per byte */
+
+	min = max = ioc->avg_search[0];
+	for (i = 0; i < SBA_SEARCH_SAMPLE; i++) {
+		avg += ioc->avg_search[i];
+		if (ioc->avg_search[i] > max) max = ioc->avg_search[i];
+		if (ioc->avg_search[i] < min) min = ioc->avg_search[i];
+	}
+	avg /= SBA_SEARCH_SAMPLE;
+	sprintf(buf, "%s  Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles)\n",
+		buf, min, avg, max);
+
+	sprintf(buf, "%spci_map_single(): %12ld calls  %12ld pages (avg %d/1000)\n",
+		buf, ioc->msingle_calls, ioc->msingle_pages,
+		(int) ((ioc->msingle_pages * 1000)/ioc->msingle_calls));
+#ifdef ALLOW_IOV_BYPASS
+	sprintf(buf, "%spci_map_single(): %12ld bypasses\n",
+	        buf, ioc->msingle_bypass);
+#endif
+
+	sprintf(buf, "%spci_unmap_single: %12ld calls  %12ld pages (avg %d/1000)\n",
+		buf, ioc->usingle_calls, ioc->usingle_pages,
+		(int) ((ioc->usingle_pages * 1000)/ioc->usingle_calls));
+#ifdef ALLOW_IOV_BYPASS
+	sprintf(buf, "%spci_unmap_single: %12ld bypasses\n",
+	        buf, ioc->usingle_bypass);
+#endif
+
+	sprintf(buf, "%spci_map_sg()    : %12ld calls  %12ld pages (avg %d/1000)\n",
+		buf, ioc->msg_calls, ioc->msg_pages,
+		(int) ((ioc->msg_pages * 1000)/ioc->msg_calls));
+#ifdef ALLOW_IOV_BYPASS
+	sprintf(buf, "%spci_map_sg()    : %12ld bypasses\n",
+	        buf, ioc->msg_bypass);
+#endif
+
+	sprintf(buf, "%spci_unmap_sg()  : %12ld calls  %12ld pages (avg %d/1000)\n",
+		buf, ioc->usg_calls, ioc->usg_pages,
+		(int) ((ioc->usg_pages * 1000)/ioc->usg_calls));
+
+	return strlen(buf);
+}
+
+static int
+sba_resource_map(char *buf, char **start, off_t offset, int len)
+{
+	struct ioc *ioc = sba_list->ioc;	/* FIXME: Multi-IOC support! */
+	unsigned int *res_ptr = (unsigned int *)ioc->res_map;
+	int i;
+
+	buf[0] = '\0';
+	for(i = 0; i < (ioc->res_size / sizeof(unsigned int)); ++i, ++res_ptr) {
+		if ((i & 7) == 0)
+		    strcat(buf,"\n   ");
+		sprintf(buf, "%s %08x", buf, *res_ptr);
+	}
+	strcat(buf, "\n");
+
+	return strlen(buf);
+}
+#endif
+
+/*
+** Determine if sba should claim this chip (return 0) or not (return 1).
+** If so, initialize the chip and tell other partners in crime they
+** have work to do.
+*/
+void __init sba_init(void)
+{
+	struct sba_device *sba_dev;
+	u32 func_id, hw_rev;
+	u32 *func_offset = NULL;
+	int i, agp_found = 0;
+	static char sba_rev[6];
+	struct pci_dev *device = NULL;
+	u64 hpa = 0;
+
+	if (!(device = pci_find_device(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_ZX1_SBA, NULL)))
+		return;
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		if (pci_resource_flags(device, i) == IORESOURCE_MEM) {
+			hpa = ioremap(pci_resource_start(device, i),
+				pci_resource_len(device, i));
+			break;
+		}
+	}
+
+	func_id = READ_REG(hpa + SBA_FUNC_ID);
+
+	if (func_id == ZX1_FUNC_ID_VALUE) {
+		(void)strcpy(sba_rev, "zx1");
+		func_offset = zx1_func_offsets;
+	} else {
+		return;
+	}
+
+	/* Read HW Rev First */
+	hw_rev = READ_REG(hpa + SBA_FCLASS) & 0xFFUL;
+
+	/*
+	 * Not all revision registers of the chipset are updated on every
+	 * turn.  Must scan through all functions looking for the highest rev
+	 */
+	if (func_offset) {
+		for (i = 0 ; func_offset[i] != -1 ; i++) {
+			u32 func_rev;
+
+			func_rev = READ_REG(hpa + SBA_FCLASS + func_offset[i]) & 0xFFUL;
+			DBG_INIT("%s() func offset: 0x%x rev: 0x%x\n",
+			         __FUNCTION__, func_offset[i], func_rev);
+			if (func_rev > hw_rev)
+				hw_rev = func_rev;
+		}
+	}
+
+	printk(KERN_INFO "%s found %s %d.%d at %s, HPA 0x%lx\n", DRIVER_NAME,
+	       sba_rev, ((hw_rev >> 4) & 0xF), (hw_rev & 0xF),
+	       device->slot_name, hpa);
+
+	if ((hw_rev & 0xFF) < 0x20) {
+		printk(KERN_INFO "%s WARNING rev 2.0 or greater will be required for IO MMU support in the future\n", DRIVER_NAME);
+#ifndef CONFIG_IA64_HP_PROTO
+		panic("%s: CONFIG_IA64_HP_PROTO MUST be enabled to support SBA rev less than 2.0", DRIVER_NAME);
+#endif
+	}
+
+	sba_dev = kmalloc(sizeof(struct sba_device), GFP_KERNEL);
+	if (NULL == sba_dev) {
+		printk(KERN_ERR DRIVER_NAME " - couldn't alloc sba_device\n");
+		return;
+	}
+
+	memset(sba_dev, 0, sizeof(struct sba_device));
+
+	for(i=0; i<MAX_IOC; i++)
+		spin_lock_init(&(sba_dev->ioc[i].res_lock));
+
+	sba_dev->hw_rev = hw_rev;
+	sba_dev->sba_hpa = hpa;
+
+	/*
+	 * We pass this fake device from alloc_consistent to ensure
+	 * we only use SAC for alloc_consistent mappings.
+	 */
+	sac_only_dev.dma_mask = 0xFFFFFFFFUL;
+
+	/*
+	 * We need to check for an AGP device, if we find one, then only
+	 * use part of the IOVA space for PCI DMA, the rest is for GART.
+	 * REVISIT for multiple IOC.
+	 */
+	pci_for_each_dev(device)
+		agp_found |= pci_find_capability(device, PCI_CAP_ID_AGP);
+
+	if (agp_found && reserve_sba_gart)
+		SBA_SET_AGP(sba_dev);
+
+	sba_hw_init(sba_dev);
+	sba_common_init(sba_dev);
+
+#ifdef CONFIG_PROC_FS
+	{
+		struct proc_dir_entry * proc_mckinley_root;
+
+		proc_mckinley_root = proc_mkdir("bus/mckinley",0);
+		create_proc_info_entry(sba_rev, 0, proc_mckinley_root, sba_proc_info);
+		create_proc_info_entry("bitmap", 0, proc_mckinley_root, sba_resource_map);
+	}
+#endif
+}
+
+static int __init
+nosbagart (char *str)
+{
+	reserve_sba_gart = 0;
+	return 1;
+}
+
+__setup("nosbagart",nosbagart);
+
+EXPORT_SYMBOL(sba_init);
+EXPORT_SYMBOL(sba_map_single);
+EXPORT_SYMBOL(sba_unmap_single);
+EXPORT_SYMBOL(sba_map_sg);
+EXPORT_SYMBOL(sba_unmap_sg);
+EXPORT_SYMBOL(sba_dma_address);
+EXPORT_SYMBOL(sba_alloc_consistent);
+EXPORT_SYMBOL(sba_free_consistent);
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/hpsim_console.c linux/arch/ia64/hp/hpsim_console.c
--- ../ia64/linux/arch/ia64/hp/hpsim_console.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/hp/hpsim_console.c	Wed Dec 31 17:00:00 1969
@@ -1,74 +0,0 @@
-/*
- * Platform dependent support for HP simulator.
- *
- * Copyright (C) 1998, 1999 Hewlett-Packard Co
- * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
- * Copyright (C) 1999 Vijay Chander <vijay@engr.sgi.com>
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/kdev_t.h>
-#include <linux/console.h>
-
-#include <asm/delay.h>
-#include <asm/irq.h>
-#include <asm/pal.h>
-#include <asm/machvec.h>
-#include <asm/pgtable.h>
-#include <asm/sal.h>
-
-#include "hpsim_ssc.h"
-
-static int simcons_init (struct console *, char *);
-static void simcons_write (struct console *, const char *, unsigned);
-static int simcons_wait_key (struct console *);
-static kdev_t simcons_console_device (struct console *);
-
-struct console hpsim_cons = {
-	name:		"simcons",
-	write:		simcons_write,
-	device:		simcons_console_device,
-	wait_key:	simcons_wait_key,
-	setup:		simcons_init,
-	flags:		CON_PRINTBUFFER,
-	index:		-1,
-};
-
-static int
-simcons_init (struct console *cons, char *options)
-{
-	return 0;
-}
-
-static void
-simcons_write (struct console *cons, const char *buf, unsigned count)
-{
-	unsigned long ch;
-
-	while (count-- > 0) {
-		ch = *buf++;
-		ia64_ssc(ch, 0, 0, 0, SSC_PUTCHAR);
-		if (ch == '\n')
-		  ia64_ssc('\r', 0, 0, 0, SSC_PUTCHAR);
-	}
-}
-
-static int
-simcons_wait_key (struct console *cons)
-{
-	char ch;
-
-	do {
-		ch = ia64_ssc(0, 0, 0, 0, SSC_GETCHAR);
-	} while (ch == '\0');
-	return ch;
-}
-
-static kdev_t
-simcons_console_device (struct console *c)
-{
-	return MKDEV(TTY_MAJOR, 64 + c->index);
-}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/hpsim_irq.c linux/arch/ia64/hp/hpsim_irq.c
--- ../ia64/linux/arch/ia64/hp/hpsim_irq.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/hp/hpsim_irq.c	Wed Dec 31 17:00:00 1969
@@ -1,46 +0,0 @@
-/*
- * Platform dependent support for HP simulator.
- *
- * Copyright (C) 1998-2001 Hewlett-Packard Co
- * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/irq.h>
-
-static unsigned int
-hpsim_irq_startup (unsigned int irq)
-{
-	return 0;
-}
-
-static void
-hpsim_irq_noop (unsigned int irq)
-{
-}
-
-static struct hw_interrupt_type irq_type_hp_sim = {
-	typename:	"hpsim",
-	startup:	hpsim_irq_startup,
-	shutdown:	hpsim_irq_noop,
-	enable:		hpsim_irq_noop,
-	disable:	hpsim_irq_noop,
-	ack:		hpsim_irq_noop,
-	end:		hpsim_irq_noop,
-	set_affinity:	(void (*)(unsigned int, unsigned long)) hpsim_irq_noop,
-};
-
-void __init
-hpsim_irq_init (void)
-{
-	irq_desc_t *idesc;
-	int i;
-
-	for (i = 0; i < NR_IRQS; ++i) {
-		idesc = irq_desc(i);
-		if (idesc->handler == &no_irq_type)
-			idesc->handler = &irq_type_hp_sim;
-	}
-}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/hpsim_machvec.c linux/arch/ia64/hp/hpsim_machvec.c
--- ../ia64/linux/arch/ia64/hp/hpsim_machvec.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/hp/hpsim_machvec.c	Wed Dec 31 17:00:00 1969
@@ -1,2 +0,0 @@
-#define MACHVEC_PLATFORM_NAME	hpsim
-#include <asm/machvec_init.h>
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/hpsim_setup.c linux/arch/ia64/hp/hpsim_setup.c
--- ../ia64/linux/arch/ia64/hp/hpsim_setup.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/hp/hpsim_setup.c	Wed Dec 31 17:00:00 1969
@@ -1,58 +0,0 @@
-/*
- * Platform dependent support for HP simulator.
- *
- * Copyright (C) 1998, 1999 Hewlett-Packard Co
- * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
- * Copyright (C) 1999 Vijay Chander <vijay@engr.sgi.com>
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/kdev_t.h>
-#include <linux/console.h>
-
-#include <asm/delay.h>
-#include <asm/irq.h>
-#include <asm/pal.h>
-#include <asm/machvec.h>
-#include <asm/pgtable.h>
-#include <asm/sal.h>
-
-#include "hpsim_ssc.h"
-
-extern struct console hpsim_cons;
-
-/*
- * Simulator system call.
- */
-asm (".text\n"
-     ".align 32\n"
-     ".global ia64_ssc\n"
-     ".proc ia64_ssc\n"
-     "ia64_ssc:\n"
-     "mov r15=r36\n"
-     "break 0x80001\n"
-     "br.ret.sptk.many rp\n"
-     ".endp\n");
-
-void
-ia64_ssc_connect_irq (long intr, long irq)
-{
-	ia64_ssc(intr, irq, 0, 0, SSC_CONNECT_INTERRUPT);
-}
-
-void
-ia64_ctl_trace (long on)
-{
-	ia64_ssc(on, 0, 0, 0, SSC_CTL_TRACE);
-}
-
-void __init
-hpsim_setup (char **cmdline_p)
-{
-	ROOT_DEV = to_kdev_t(0x0801);		/* default to first SCSI drive */
-
-	register_console (&hpsim_cons);
-}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/hpsim_ssc.h linux/arch/ia64/hp/hpsim_ssc.h
--- ../ia64/linux/arch/ia64/hp/hpsim_ssc.h	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/hp/hpsim_ssc.h	Wed Dec 31 17:00:00 1969
@@ -1,36 +0,0 @@
-/*
- * Platform dependent support for HP simulator.
- *
- * Copyright (C) 1998, 1999 Hewlett-Packard Co
- * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
- * Copyright (C) 1999 Vijay Chander <vijay@engr.sgi.com>
- */
-#ifndef _IA64_PLATFORM_HPSIM_SSC_H
-#define _IA64_PLATFORM_HPSIM_SSC_H
-
-/* Simulator system calls: */
-
-#define SSC_CONSOLE_INIT		20
-#define SSC_GETCHAR			21
-#define SSC_PUTCHAR			31
-#define SSC_CONNECT_INTERRUPT		58
-#define SSC_GENERATE_INTERRUPT		59
-#define SSC_SET_PERIODIC_INTERRUPT	60
-#define SSC_GET_RTC			65
-#define SSC_EXIT			66
-#define SSC_LOAD_SYMBOLS		69
-#define SSC_GET_TOD			74
-#define SSC_CTL_TRACE			76
-
-#define SSC_NETDEV_PROBE		100
-#define SSC_NETDEV_SEND			101
-#define SSC_NETDEV_RECV			102
-#define SSC_NETDEV_ATTACH		103
-#define SSC_NETDEV_DETACH		104
-
-/*
- * Simulator system call.
- */
-extern long ia64_ssc (long arg0, long arg1, long arg2, long arg3, int nr);
-
-#endif /* _IA64_PLATFORM_HPSIM_SSC_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/sim/Makefile linux/arch/ia64/hp/sim/Makefile
--- ../ia64/linux/arch/ia64/hp/sim/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/sim/Makefile	Mon Mar 11 20:19:41 2002
@@ -0,0 +1,13 @@
+#
+# ia64/platform/hp/sim/Makefile
+#
+# Copyright (C) 1999 Silicon Graphics, Inc.
+# Copyright (C) Srinivasa Thirumalachar (sprasad@engr.sgi.com)
+#
+
+O_TARGET := sim.o
+
+obj-y := hpsim_console.o hpsim_irq.o hpsim_setup.o
+obj-$(CONFIG_IA64_GENERIC) += hpsim_machvec.o
+
+include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/sim/hpsim_console.c linux/arch/ia64/hp/sim/hpsim_console.c
--- ../ia64/linux/arch/ia64/hp/sim/hpsim_console.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/sim/hpsim_console.c	Mon Mar 11 20:11:50 2002
@@ -0,0 +1,74 @@
+/*
+ * Platform dependent support for HP simulator.
+ *
+ * Copyright (C) 1998, 1999 Hewlett-Packard Co
+ * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1999 Vijay Chander <vijay@engr.sgi.com>
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/console.h>
+
+#include <asm/delay.h>
+#include <asm/irq.h>
+#include <asm/pal.h>
+#include <asm/machvec.h>
+#include <asm/pgtable.h>
+#include <asm/sal.h>
+
+#include "hpsim_ssc.h"
+
+static int simcons_init (struct console *, char *);
+static void simcons_write (struct console *, const char *, unsigned);
+static int simcons_wait_key (struct console *);
+static kdev_t simcons_console_device (struct console *);
+
+struct console hpsim_cons = {
+	name:		"simcons",
+	write:		simcons_write,
+	device:		simcons_console_device,
+	wait_key:	simcons_wait_key,
+	setup:		simcons_init,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+static int
+simcons_init (struct console *cons, char *options)
+{
+	return 0;
+}
+
+static void
+simcons_write (struct console *cons, const char *buf, unsigned count)
+{
+	unsigned long ch;
+
+	while (count-- > 0) {
+		ch = *buf++;
+		ia64_ssc(ch, 0, 0, 0, SSC_PUTCHAR);
+		if (ch == '\n')
+		  ia64_ssc('\r', 0, 0, 0, SSC_PUTCHAR);
+	}
+}
+
+static int
+simcons_wait_key (struct console *cons)
+{
+	char ch;
+
+	do {
+		ch = ia64_ssc(0, 0, 0, 0, SSC_GETCHAR);
+	} while (ch == '\0');
+	return ch;
+}
+
+static kdev_t
+simcons_console_device (struct console *c)
+{
+	return MKDEV(TTY_MAJOR, 64 + c->index);
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/sim/hpsim_irq.c linux/arch/ia64/hp/sim/hpsim_irq.c
--- ../ia64/linux/arch/ia64/hp/sim/hpsim_irq.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/sim/hpsim_irq.c	Mon Mar 11 20:11:50 2002
@@ -0,0 +1,46 @@
+/*
+ * Platform dependent support for HP simulator.
+ *
+ * Copyright (C) 1998-2001 Hewlett-Packard Co
+ * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/irq.h>
+
+static unsigned int
+hpsim_irq_startup (unsigned int irq)
+{
+	return 0;
+}
+
+static void
+hpsim_irq_noop (unsigned int irq)
+{
+}
+
+static struct hw_interrupt_type irq_type_hp_sim = {
+	typename:	"hpsim",
+	startup:	hpsim_irq_startup,
+	shutdown:	hpsim_irq_noop,
+	enable:		hpsim_irq_noop,
+	disable:	hpsim_irq_noop,
+	ack:		hpsim_irq_noop,
+	end:		hpsim_irq_noop,
+	set_affinity:	(void (*)(unsigned int, unsigned long)) hpsim_irq_noop,
+};
+
+void __init
+hpsim_irq_init (void)
+{
+	irq_desc_t *idesc;
+	int i;
+
+	for (i = 0; i < NR_IRQS; ++i) {
+		idesc = irq_desc(i);
+		if (idesc->handler == &no_irq_type)
+			idesc->handler = &irq_type_hp_sim;
+	}
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/sim/hpsim_machvec.c linux/arch/ia64/hp/sim/hpsim_machvec.c
--- ../ia64/linux/arch/ia64/hp/sim/hpsim_machvec.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/sim/hpsim_machvec.c	Mon Mar 11 20:11:50 2002
@@ -0,0 +1,2 @@
+#define MACHVEC_PLATFORM_NAME	hpsim
+#include <asm/machvec_init.h>
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/sim/hpsim_setup.c linux/arch/ia64/hp/sim/hpsim_setup.c
--- ../ia64/linux/arch/ia64/hp/sim/hpsim_setup.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/sim/hpsim_setup.c	Mon Mar 11 20:11:50 2002
@@ -0,0 +1,58 @@
+/*
+ * Platform dependent support for HP simulator.
+ *
+ * Copyright (C) 1998, 1999 Hewlett-Packard Co
+ * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1999 Vijay Chander <vijay@engr.sgi.com>
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/console.h>
+
+#include <asm/delay.h>
+#include <asm/irq.h>
+#include <asm/pal.h>
+#include <asm/machvec.h>
+#include <asm/pgtable.h>
+#include <asm/sal.h>
+
+#include "hpsim_ssc.h"
+
+extern struct console hpsim_cons;
+
+/*
+ * Simulator system call.
+ */
+asm (".text\n"
+     ".align 32\n"
+     ".global ia64_ssc\n"
+     ".proc ia64_ssc\n"
+     "ia64_ssc:\n"
+     "mov r15=r36\n"
+     "break 0x80001\n"
+     "br.ret.sptk.many rp\n"
+     ".endp\n");
+
+void
+ia64_ssc_connect_irq (long intr, long irq)
+{
+	ia64_ssc(intr, irq, 0, 0, SSC_CONNECT_INTERRUPT);
+}
+
+void
+ia64_ctl_trace (long on)
+{
+	ia64_ssc(on, 0, 0, 0, SSC_CTL_TRACE);
+}
+
+void __init
+hpsim_setup (char **cmdline_p)
+{
+	ROOT_DEV = to_kdev_t(0x0801);		/* default to first SCSI drive */
+
+	register_console (&hpsim_cons);
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/sim/hpsim_ssc.h linux/arch/ia64/hp/sim/hpsim_ssc.h
--- ../ia64/linux/arch/ia64/hp/sim/hpsim_ssc.h	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/sim/hpsim_ssc.h	Mon Mar 11 20:11:50 2002
@@ -0,0 +1,36 @@
+/*
+ * Platform dependent support for HP simulator.
+ *
+ * Copyright (C) 1998, 1999 Hewlett-Packard Co
+ * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 1999 Vijay Chander <vijay@engr.sgi.com>
+ */
+#ifndef _IA64_PLATFORM_HPSIM_SSC_H
+#define _IA64_PLATFORM_HPSIM_SSC_H
+
+/* Simulator system calls: */
+
+#define SSC_CONSOLE_INIT		20
+#define SSC_GETCHAR			21
+#define SSC_PUTCHAR			31
+#define SSC_CONNECT_INTERRUPT		58
+#define SSC_GENERATE_INTERRUPT		59
+#define SSC_SET_PERIODIC_INTERRUPT	60
+#define SSC_GET_RTC			65
+#define SSC_EXIT			66
+#define SSC_LOAD_SYMBOLS		69
+#define SSC_GET_TOD			74
+#define SSC_CTL_TRACE			76
+
+#define SSC_NETDEV_PROBE		100
+#define SSC_NETDEV_SEND			101
+#define SSC_NETDEV_RECV			102
+#define SSC_NETDEV_ATTACH		103
+#define SSC_NETDEV_DETACH		104
+
+/*
+ * Simulator system call.
+ */
+extern long ia64_ssc (long arg0, long arg1, long arg2, long arg3, int nr);
+
+#endif /* _IA64_PLATFORM_HPSIM_SSC_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/zx1/Makefile linux/arch/ia64/hp/zx1/Makefile
--- ../ia64/linux/arch/ia64/hp/zx1/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/zx1/Makefile	Mon Mar 11 20:19:41 2002
@@ -0,0 +1,13 @@
+#
+# ia64/platform/hp/zx1/Makefile
+#
+# Copyright (C) 2002 Hewlett Packard
+# Copyright (C) Alex Williamson (alex_williamson@hp.com)
+#
+
+O_TARGET := zx1.o
+
+obj-y := hpzx1_misc.o
+obj-$(CONFIG_IA64_GENERIC) += hpzx1_machvec.o
+
+include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/zx1/hpzx1_machvec.c linux/arch/ia64/hp/zx1/hpzx1_machvec.c
--- ../ia64/linux/arch/ia64/hp/zx1/hpzx1_machvec.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/zx1/hpzx1_machvec.c	Sun Mar 10 18:38:22 2002
@@ -0,0 +1,2 @@
+#define MACHVEC_PLATFORM_NAME	hpzx1
+#include <asm/machvec_init.h>
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/hp/zx1/hpzx1_misc.c linux/arch/ia64/hp/zx1/hpzx1_misc.c
--- ../ia64/linux/arch/ia64/hp/zx1/hpzx1_misc.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/hp/zx1/hpzx1_misc.c	Mon Apr  1 08:30:24 2002
@@ -0,0 +1,387 @@
+/*
+ * Misc. support for HP zx1 chipset support
+ *
+ * Copyright (C) 2002 Hewlett-Packard Co
+ * Copyright (C) 2002 Alex Williamson <alex_williamson@hp.com>
+ * Copyright (C) 2002 Bjorn Helgaas <bjorn_helgaas@hp.com>
+ */
+
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include <asm/iosapic.h>
+#include <asm/efi.h>
+
+#define PFX "hpzx1: "
+
+struct fake_pci_dev {
+	struct fake_pci_dev *next;
+	unsigned char bus;
+	unsigned int devfn;
+	int sizing;		// in middle of BAR sizing operation?
+	unsigned long csr_base;
+	unsigned int csr_size;
+	unsigned long mapped_csrs;	// ioremapped
+};
+
+static struct fake_pci_dev *fake_pci_head, **fake_pci_tail = &fake_pci_head;
+
+static struct pci_ops orig_pci_ops;
+
+static inline struct fake_pci_dev *
+fake_pci_find_slot(unsigned char bus, unsigned int devfn)
+{
+	struct fake_pci_dev *dev;
+
+	for (dev = fake_pci_head; dev; dev = dev->next)
+		if (dev->bus == bus && dev->devfn == devfn)
+			return dev;
+	return NULL;
+}
+
+static struct fake_pci_dev *
+alloc_fake_pci_dev(void)
+{
+        struct fake_pci_dev *dev;
+
+        dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	memset(dev, 0, sizeof(*dev));
+
+        *fake_pci_tail = dev;
+        fake_pci_tail = &dev->next;
+
+        return dev;
+}
+
+#define HP_CFG_RD(sz, bits, name) \
+static int hp_cfg_read##sz (struct pci_dev *dev, int where, u##bits *value) \
+{ \
+	struct fake_pci_dev *fake_dev; \
+	if (!(fake_dev = fake_pci_find_slot(dev->bus->number, dev->devfn))) \
+		return orig_pci_ops.name(dev, where, value); \
+	\
+	switch (where) { \
+	case PCI_COMMAND: \
+		*value = read##sz(fake_dev->mapped_csrs + where); \
+		*value |= PCI_COMMAND_MEMORY; /* SBA omits this */ \
+		break; \
+	case PCI_BASE_ADDRESS_0: \
+		if (fake_dev->sizing) \
+			*value = ~(fake_dev->csr_size - 1); \
+		else \
+			*value = (fake_dev->csr_base & \
+				    PCI_BASE_ADDRESS_MEM_MASK) | \
+				PCI_BASE_ADDRESS_SPACE_MEMORY; \
+		fake_dev->sizing = 0; \
+		break; \
+	default: \
+		*value = read##sz(fake_dev->mapped_csrs + where); \
+		break; \
+	} \
+	return PCIBIOS_SUCCESSFUL; \
+}
+
+#define HP_CFG_WR(sz, bits, name) \
+static int hp_cfg_write##sz (struct pci_dev *dev, int where, u##bits value) \
+{ \
+	struct fake_pci_dev *fake_dev; \
+	if (!(fake_dev = fake_pci_find_slot(dev->bus->number, dev->devfn))) \
+		return orig_pci_ops.name(dev, where, value); \
+	\
+	switch (where) { \
+	case PCI_BASE_ADDRESS_0: \
+		if (value == ~0) \
+			fake_dev->sizing = 1; \
+		break; \
+	default: \
+		write##sz(value, fake_dev->mapped_csrs + where); \
+		break; \
+	} \
+	return PCIBIOS_SUCCESSFUL; \
+}
+
+HP_CFG_RD(b,  8, read_byte)
+HP_CFG_RD(w, 16, read_word)
+HP_CFG_RD(l, 32, read_dword)
+HP_CFG_WR(b,  8, write_byte)
+HP_CFG_WR(w, 16, write_word)
+HP_CFG_WR(l, 32, write_dword)
+
+static struct pci_ops hp_pci_conf = {
+	hp_cfg_readb,
+	hp_cfg_readw,
+	hp_cfg_readl,
+	hp_cfg_writeb,
+	hp_cfg_writew,
+	hp_cfg_writel,
+};
+
+/*
+ * Assume we'll never have a physical slot higher than 0x10, so we can
+ * use slots above that for "fake" PCI devices to represent things
+ * that only show up in the ACPI namespace.
+ */
+#define HP_MAX_SLOT	0x10
+
+static struct fake_pci_dev *
+hpzx1_fake_pci_dev(unsigned long addr, unsigned int bus, unsigned int size)
+{
+	struct fake_pci_dev *dev;
+	int slot;
+
+	// Note: lspci thinks 0x1f is invalid
+	for (slot = 0x1e; slot > HP_MAX_SLOT; slot--) {
+		if (!fake_pci_find_slot(bus, PCI_DEVFN(slot, 0)))
+			break;
+	}
+	if (slot == HP_MAX_SLOT) {
+		printk(KERN_ERR PFX
+			"no slot space for device (0x%p) on bus 0x%02x\n",
+			(void *) addr, bus);
+		return NULL;
+	}
+
+	dev = alloc_fake_pci_dev();
+	if (!dev) {
+		printk(KERN_ERR PFX
+			"no memory for device (0x%p) on bus 0x%02x\n",
+			(void *) addr, bus);
+		return NULL;
+	}
+
+	dev->bus = bus;
+	dev->devfn = PCI_DEVFN(slot, 0);
+	dev->csr_base = addr;
+	dev->csr_size = size;
+
+	/*
+	 * Drivers should ioremap what they need, but we have to do
+	 * it here, too, so PCI config accesses work.
+	 */
+	dev->mapped_csrs = ioremap(dev->csr_base, dev->csr_size);
+
+	return dev;
+}
+
+typedef struct {
+	u8	guid_id;
+	u8	guid[16];
+	u8	csr_base[8];
+	u8	csr_length[8];
+} acpi_hp_vendor_long;
+
+#define HP_CCSR_LENGTH 0x21
+#define HP_CCSR_TYPE 0x2
+#define HP_CCSR_GUID \
+    ((efi_guid_t) { 0x69e9adf9, 0x924f, 0xab5f, { 0xf6, 0x4a, 0x24, 0xd2, 0x01, 0x37, 0x0e, 0xad }})
+
+extern acpi_status acpi_get_crs(acpi_handle, acpi_buffer *);
+extern acpi_resource *acpi_get_crs_next(acpi_buffer *, int *);
+extern acpi_resource_data *acpi_get_crs_type(acpi_buffer *, int *, int);
+extern void acpi_dispose_crs(acpi_buffer *);
+extern acpi_status acpi_cf_evaluate_method(acpi_handle, UINT8 *, NATIVE_UINT *);
+
+static acpi_status
+hp_csr_space(acpi_handle obj, u64 *csr_base, u64 *csr_length)
+{
+	int i, offset = 0;
+	acpi_status status;
+	acpi_buffer buf;
+	acpi_resource_vendor *res;
+	acpi_hp_vendor_long *hp_res;
+	efi_guid_t vendor_guid;
+
+	*csr_base = 0;
+	*csr_length = 0;
+
+	status = acpi_get_crs(obj, &buf);
+	if (status != AE_OK) {
+		printk(KERN_ERR PFX "Unable to get _CRS data on object\n");
+		return status;
+	}
+
+	res = (acpi_resource_vendor *)acpi_get_crs_type(&buf, &offset, ACPI_RSTYPE_VENDOR);
+	if (!res) {
+		printk(KERN_ERR PFX "Failed to find config space for device\n");
+		acpi_dispose_crs(&buf);
+		return AE_NOT_FOUND;
+	}
+
+	hp_res = (acpi_hp_vendor_long *)(res->reserved);
+
+	if (res->length != HP_CCSR_LENGTH || hp_res->guid_id != HP_CCSR_TYPE) {
+		printk(KERN_ERR PFX "Unknown Vendor data\n");
+		acpi_dispose_crs(&buf);
+		return AE_TYPE; /* Revisit error? */
+	}
+
+	memcpy(&vendor_guid, hp_res->guid, sizeof(efi_guid_t));
+	if (efi_guidcmp(vendor_guid, HP_CCSR_GUID) != 0) {
+		printk(KERN_ERR PFX "Vendor GUID does not match\n");
+		acpi_dispose_crs(&buf);
+		return AE_TYPE; /* Revisit error? */
+	}
+
+	for (i = 0 ; i < 8 ; i++) {
+		*csr_base |= ((u64)(hp_res->csr_base[i]) << (i * 8));
+		*csr_length |= ((u64)(hp_res->csr_length[i]) << (i * 8));
+	}
+
+	acpi_dispose_crs(&buf);
+
+	return AE_OK;
+}
+
+static acpi_status
+hpzx1_sba_probe(acpi_handle obj, u32 depth, void *context, void **ret)
+{
+	u64 csr_base = 0, csr_length = 0;
+	char *name = context;
+	struct fake_pci_dev *dev;
+	acpi_status status;
+
+	status = hp_csr_space(obj, &csr_base, &csr_length);
+
+	if (status != AE_OK)
+		return status;
+
+	/*
+	 * Only SBA shows up in ACPI namespace, so its CSR space
+	 * includes both SBA and IOC.  Make SBA and IOC show up
+	 * separately in PCI space.
+	 */
+	if ((dev = hpzx1_fake_pci_dev(csr_base, 0, 0x1000)))
+		printk(KERN_INFO PFX "%s SBA at 0x%lx; pci dev %02x:%02x.%d\n",
+			name, csr_base, dev->bus,
+			PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+	if ((dev = hpzx1_fake_pci_dev(csr_base + 0x1000, 0, 0x1000)))
+		printk(KERN_INFO PFX "%s IOC at 0x%lx; pci dev %02x:%02x.%d\n",
+			name, csr_base + 0x1000, dev->bus,
+			PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+
+	return AE_OK;
+}
+
+static acpi_status
+hpzx1_lba_probe(acpi_handle obj, u32 depth, void *context, void **ret)
+{
+	acpi_status status;
+	u64 csr_base = 0, csr_length = 0;
+	char *name = context;
+	NATIVE_UINT busnum = 0;
+	struct fake_pci_dev *dev;
+
+	status = hp_csr_space(obj, &csr_base, &csr_length);
+
+	if (status != AE_OK)
+		return status;
+
+	status = acpi_cf_evaluate_method(obj, METHOD_NAME__BBN, &busnum);
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR PFX "evaluate _BBN fail=0x%x\n", status);
+		busnum = 0;	// no _BBN; stick it on bus 0
+	}
+
+	if ((dev = hpzx1_fake_pci_dev(csr_base, busnum, csr_length)))
+		printk(KERN_INFO PFX "%s LBA at 0x%lx, _BBN 0x%02x; "
+			"pci dev %02x:%02x.%d\n",
+			name, csr_base, busnum, dev->bus,
+			PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+
+	return AE_OK;
+}
+
+static void
+hpzx1_acpi_dev_init(void)
+{
+	extern struct pci_ops pci_conf;
+
+	/*
+	 * Make fake PCI devices for the following hardware in the
+	 * ACPI namespace.  This makes it more convenient for drivers
+	 * because they can claim these devices based on PCI
+	 * information, rather than needing to know about ACPI.  The
+	 * 64-bit "HPA" space for this hardware is available as BAR
+	 * 0/1.
+	 *
+	 * HWP0001: Single IOC SBA w/o IOC in namespace
+	 * HWP0002: LBA device
+	 * HWP0003: AGP LBA device
+	 */
+	acpi_get_devices("HWP0001", hpzx1_sba_probe, "HWP0001", NULL);
+#ifdef CONFIG_IA64_HP_PROTO
+	if (fake_pci_tail != &fake_pci_head) {
+#endif
+	acpi_get_devices("HWP0002", hpzx1_lba_probe, "HWP0002", NULL);
+	acpi_get_devices("HWP0003", hpzx1_lba_probe, "HWP0003", NULL);
+
+#ifdef CONFIG_IA64_HP_PROTO
+	}
+
+#define ZX1_FUNC_ID_VALUE    (PCI_DEVICE_ID_HP_ZX1_SBA << 16) | PCI_VENDOR_ID_HP
+	/*
+	 * Early protos don't have bridges in the ACPI namespace, so
+	 * if we didn't find anything, add the things we know are
+	 * there.
+	 */
+	if (fake_pci_tail == &fake_pci_head) {
+		u64 hpa, csr_base;
+		struct fake_pci_dev *dev;
+
+		csr_base = 0xfed00000UL;
+		hpa = (u64) ioremap(csr_base, 0x1000);
+		if (__raw_readl(hpa) == ZX1_FUNC_ID_VALUE) {
+			if ((dev = hpzx1_fake_pci_dev(csr_base, 0, 0x1000)))
+				printk(KERN_INFO PFX "HWP0001 SBA at 0x%lx; "
+					"pci dev %02x:%02x.%d\n", csr_base,
+					dev->bus, PCI_SLOT(dev->devfn),
+					PCI_FUNC(dev->devfn));
+			if ((dev = hpzx1_fake_pci_dev(csr_base + 0x1000, 0,
+					0x1000)))
+				printk(KERN_INFO PFX "HWP0001 IOC at 0x%lx; "
+					"pci dev %02x:%02x.%d\n",
+					csr_base + 0x1000,
+					dev->bus, PCI_SLOT(dev->devfn),
+					PCI_FUNC(dev->devfn));
+
+			csr_base = 0xfed24000UL;
+			iounmap(hpa);
+			hpa = (u64) ioremap(csr_base, 0x1000);
+			if ((dev = hpzx1_fake_pci_dev(csr_base, 0x40, 0x1000)))
+				printk(KERN_INFO PFX "HWP0003 AGP LBA at "
+					"0x%lx; pci dev %02x:%02x.%d\n",
+					csr_base,
+					dev->bus, PCI_SLOT(dev->devfn),
+					PCI_FUNC(dev->devfn));
+		}
+		iounmap(hpa);
+	}
+#endif
+
+	if (fake_pci_tail == &fake_pci_head)
+		return;
+
+	/*
+	 * Replace PCI ops, but only if we made fake devices.
+	 */
+	orig_pci_ops = pci_conf;
+	pci_conf = hp_pci_conf;
+}
+
+extern void sba_init(void);
+	
+void
+hpzx1_pci_fixup (int phase)
+{
+	if (phase == 0)
+		hpzx1_acpi_dev_init();
+	iosapic_pci_fixup(phase);
+        if (phase == 1)
+		sba_init();
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/Makefile linux/arch/ia64/kernel/Makefile
--- ../ia64/linux/arch/ia64/kernel/Makefile	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/Makefile	Fri Mar 22 16:38:40 2002
@@ -15,8 +15,9 @@
 
 obj-y := acpi.o entry.o gate.o efi.o efi_stub.o ia64_ksyms.o irq.o irq_ia64.o irq_lsapic.o ivt.o \
 	 machvec.o pal.o process.o perfmon.o ptrace.o sal.o salinfo.o semaphore.o setup.o	 \
-	 signal.o sys_ia64.o traps.o time.o unaligned.o unwind.o
+	 signal.o sys_ia64.o traps.o time.o unaligned.o unwind.o hcdp_serial.o
 obj-$(CONFIG_IA64_GENERIC) += iosapic.o
+obj-$(CONFIG_IA64_HP_ZX1) += iosapic.o
 obj-$(CONFIG_IA64_DIG) += iosapic.o
 obj-$(CONFIG_IA64_PALINFO) += palinfo.o
 obj-$(CONFIG_EFI_VARS) += efivars.o
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/acpi.c linux/arch/ia64/kernel/acpi.c
--- ../ia64/linux/arch/ia64/kernel/acpi.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/acpi.c	Sun Apr 28 22:52:32 2002
@@ -23,6 +23,8 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/irq.h>
+#include <linux/acpi.h>
+#include <linux/bootmem.h>
 #ifdef CONFIG_SERIAL_ACPI
 #include <linux/acpi_serial.h>
 #endif
@@ -56,9 +58,38 @@
 const char *
 acpi_get_sysname (void)
 {
-	/* the following should go away once we have an ACPI parser: */
 #ifdef CONFIG_IA64_GENERIC
-	return "hpsim";
+	if (efi.acpi20) {
+		acpi20_rsdp_t *rsdp20;
+		acpi_xsdt_t *xsdt;
+		acpi_desc_table_hdr_t *hdrp;
+
+		rsdp20 = efi.acpi20;
+		if (strncmp(rsdp20->signature,
+		            ACPI_RSDP_SIG, ACPI_RSDP_SIG_LEN)) {
+			printk("ACPI 2.0 RSDP signature incorrect, default to DIG compatible\n");
+			return "dig";
+		}
+
+		xsdt = __va(rsdp20->xsdt);
+		hdrp = &xsdt->header;
+		if (strncmp(hdrp->signature,
+		            ACPI_XSDT_SIG, ACPI_XSDT_SIG_LEN)) {
+			printk("ACPI 2.0 XSDT signature incorrect, default to DIG compatible\n");
+			return "dig";
+		}
+
+		if (!strcmp(hdrp->oem_id, "HP")) {
+
+			/*
+			 * This is perhaps a weak test, but we don't have
+			 * much else to work with.
+			 */
+			return "hpzx1";
+		}
+	}
+
+	return "dig";
 #else
 # if defined (CONFIG_IA64_HP_SIM)
 	return "hpsim";
@@ -68,8 +99,10 @@
 	return "sn2";
 # elif defined (CONFIG_IA64_DIG)
 	return "dig";
+# elif defined (CONFIG_IA64_HP_ZX1)
+	return "hpzx1";
 # else
-#	error Unknown platform.  Fix acpi.c.
+#       error Unknown platform.  Fix acpi.c.
 # endif
 #endif
 
@@ -395,6 +428,100 @@
 		available_cpus, total_cpus);
 }
 
+/*
+ * Setup any IRQs defined in ACPI namespace.  This enables type irq and
+ * extended irq in the _CRS method data.
+ */
+static acpi_status __init
+acpi_irq_probe(acpi_handle obj, u32 depth, void *context, void **ret)
+{
+	acpi_status status;
+	acpi_buffer buffer;
+	acpi_madt_t *madt = context;
+	int offset = 0;
+
+	if (!iosapic_register_irq)
+		return AE_OK;
+
+	buffer.length = 0;
+	buffer.pointer = NULL;
+
+	status = acpi_get_current_resources(obj, &buffer);
+	if (status != AE_BUFFER_OVERFLOW)
+		return status;
+	buffer.pointer = alloc_bootmem(buffer.length);
+	if (!buffer.pointer)
+		return AE_NO_MEMORY;
+	status = acpi_get_current_resources(obj, &buffer);
+	if (status != AE_OK) {
+		free_bootmem(__pa((unsigned long)buffer.pointer), (u32)buffer.length);
+		return status;
+	}
+
+	while (offset <= buffer.length) {
+		acpi_resource *res = buffer.pointer + offset;
+		if (res->length == 0)
+			break;
+
+		offset += res->length;
+
+		if (res->id == ACPI_RSTYPE_EXT_IRQ) {
+			u32 irq_base;
+			char *iosapic_address;
+			acpi_resource_ext_irq *ext_irq = &res->data.extended_irq;
+			int i;
+
+			if (ext_irq->producer_consumer != CONSUMER)
+				continue;
+
+			for (i = 0 ; i < ext_irq->number_of_interrupts ; i++) {
+
+				/* Don't setup legacy IRQs, they'll work anyway */
+				if((madt->flags & MADT_PCAT_COMPAT) &&
+				   (ext_irq->interrupts[i] < 16))
+					continue;
+
+				/* which iosapic does this IRQ belong to? */
+				if (acpi20_which_iosapic(ext_irq->interrupts[i], madt,
+								    &irq_base, &iosapic_address) == 0) {
+
+					/* Turn it on */
+					(void)iosapic_register_irq(ext_irq->interrupts[i],
+					              (ext_irq->active_high_low == ACTIVE_HIGH),
+					              (ext_irq->edge_level == EDGE_SENSITIVE),
+					              irq_base, iosapic_address);
+				}
+			}
+		} else if (res->id == ACPI_RSTYPE_IRQ) {
+			u32 irq_base;
+			char *iosapic_address;
+			acpi_resource_irq *irq = &res->data.irq;
+			int i;
+
+			for (i = 0 ; i < irq->number_of_interrupts ; i++) {
+
+				/* Don't setup legacy IRQs, they'll work anyway */
+				if((madt->flags & MADT_PCAT_COMPAT) &&
+				   (irq->interrupts[i] < 16))
+					continue;
+
+				/* which iosapic does this IRQ belong to? */
+				if (acpi20_which_iosapic(irq->interrupts[i], madt,
+								    &irq_base, &iosapic_address) == 0) {
+
+					/* Turn it on */
+					(void)iosapic_register_irq(irq->interrupts[i],
+					              (irq->active_high_low == ACTIVE_HIGH),
+					              (irq->edge_level == EDGE_SENSITIVE),
+					              irq_base, iosapic_address);
+				}
+			}
+		}
+	}
+	free_bootmem(__pa((unsigned long)buffer.pointer), (u32)buffer.length);
+	return status;
+}
+
 int __init
 acpi20_parse (acpi20_rsdp_t *rsdp20)
 {
@@ -448,24 +575,24 @@
 		acpi20_parse_madt(madt);
 	}
 
-#ifdef CONFIG_SERIAL_ACPI
 	/*
 	 * Now we're interested in other tables.  We want the iosapics already
 	 * initialized, so we do it in a separate loop.
 	 */
 	for (i = 0; i < tables; i++) {
 		hdrp = (acpi_desc_table_hdr_t *) __va(readl_unaligned(&xsdt->entry_ptrs[i]));
+#ifdef CONFIG_SERIAL_ACPI
 		/*
 		 * search for SPCR and DBGP table entries so we can enable
 		 * non-pci interrupts to IO-SAPICs.
 		 */
-		if (!strncmp(hdrp->signature, ACPI_SPCRT_SIG, ACPI_SPCRT_SIG_LEN) ||
-		    !strncmp(hdrp->signature, ACPI_DBGPT_SIG, ACPI_DBGPT_SIG_LEN))
+		if (!strncmp(hdrp->signature, ACPI_SPCRT_SIG, ACPI_SPCRT_SIG_LEN))
 		{
 			acpi_ser_t *spcr = (void *)hdrp;
 			unsigned long global_int;
 
 			setup_serial_acpi(hdrp);
+#if 0
 
 			/*
 			 * ACPI is able to describe serial ports that live at non-standard
@@ -510,8 +637,35 @@
 					                              iosapic_address);
 				}
 			}
+#endif
+		}
+#endif
+		if (!strncmp(hdrp->signature, ACPI_FADT_SIG, ACPI_FADT_SIG_LEN)) {
+			acpi20_fadt_t *fadt = (void *)hdrp;
+
+			if(!(madt->flags & MADT_PCAT_COMPAT) ||
+			    (fadt->sci_int >= 16)) {
+
+				u32 irq_base;
+				char *iosapic_address;
+				int vector;
+
+				/* which iosapic does this IRQ belong to? */
+				if (acpi20_which_iosapic(fadt->sci_int, madt, &irq_base,
+							 &iosapic_address) == 0)
+				{
+					vector = iosapic_register_irq(fadt->sci_int,
+					                              /* Pol/trig defined in ACPI */
+					                              0, /* active low polarity */
+					                              0, /* level triggered */
+					                              irq_base,
+					                              iosapic_address);
+				}
+			}
 		}
 	}
+#ifndef CONFIG_IA64_HP_PROTO
+	(void)acpi_get_devices(NULL, acpi_irq_probe, madt, NULL);
 #endif
 	acpi_cf_terminate();
 
@@ -676,4 +830,59 @@
 #  endif
 # endif /* CONFIG_ACPI */
 	return 1;
+}
+
+/**
+ * acpi_get_crs - Return the current resource settings for a device
+ * obj: A handle for this device
+ * buf: A buffer to be populated by this call.
+ *
+ * Pass a valid handle, typically obtained by walking the namespace and a
+ * pointer to an allocated buffer, and this function will fill in the buffer
+ * with a list of acpi_resource structures.
+ */
+acpi_status acpi_get_crs(acpi_handle obj, acpi_buffer *buf)
+{
+	acpi_status result;
+	buf->length = 0;
+	buf->pointer = NULL;
+
+	result = acpi_get_current_resources(obj, buf);
+	if (result != AE_BUFFER_OVERFLOW)
+		return result;
+	buf->pointer = kmalloc(buf->length, GFP_KERNEL);
+	if (!buf->pointer)
+		return -ENOMEM;
+
+	result = acpi_get_current_resources(obj, buf);
+
+	return result;
+}
+
+acpi_resource *acpi_get_crs_next(acpi_buffer *buf, int *offset)
+{
+	acpi_resource *res;
+
+	if (*offset >= buf->length)
+		return NULL;
+
+	res = buf->pointer + *offset;
+	*offset += res->length;
+	return res;
+}
+
+acpi_resource_data *acpi_get_crs_type(acpi_buffer *buf, int *offset, int type)
+{
+	for (;;) {
+		acpi_resource *res = acpi_get_crs_next(buf, offset);
+		if (!res)
+			return NULL;
+		if (res->id == type)
+			return &res->data;
+	}
+}
+
+void acpi_dispose_crs(acpi_buffer *buf)
+{
+	kfree(buf->pointer);
 }
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/efi.c linux/arch/ia64/kernel/efi.c
--- ../ia64/linux/arch/ia64/kernel/efi.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/efi.c	Tue May 14 08:52:56 2002
@@ -137,7 +137,7 @@
 		u64 start;
 		u64 end;
 	} prev, curr;
-	void *efi_map_start, *efi_map_end, *p;
+	void *efi_map_start, *efi_map_end, *p, *p_next;
 	efi_memory_desc_t *md;
 	u64 efi_desc_size, start, end;
 
@@ -166,6 +166,36 @@
 				continue;
 			}
 
+			/*
+			 * Check if we're going to get into an attibute aliasing problem
+			 * with a WB entry bumping into a ~WB entry within a granule.
+			 */
+			p_next = (p + efi_desc_size);
+
+			if (p_next < efi_map_end) {
+				efi_memory_desc_t *md_next = p_next;
+
+				if ((md_next->attribute & EFI_MEMORY_WB) == 0) {
+
+					/*
+					 * If the entries meet and it's not a granule
+					 * boundary, they're mapped by the same TR and
+					 * we should try to prevent casual collisions
+					 * by making a gap.
+					 */
+					if (md_next->phys_addr ==
+					    (md->phys_addr + (md->num_pages << 12)) &&
+					    (md_next->phys_addr & (IA64_GRANULE_SIZE - 1)) != 0) {
+
+						printk("Ignoring last page of region [0x%lx-0x%lx) " \
+						       "to avoid attribute aliasing\n", md->phys_addr,
+							   md->phys_addr + (md->num_pages << 12) - 1);
+
+						md->num_pages--;
+					}
+				}
+			}
+
 			curr.start = PAGE_OFFSET + md->phys_addr;
 			curr.end   = curr.start + (md->num_pages << 12);
 
@@ -292,6 +322,23 @@
 			if (end != cp)
 				break;
 			cp = end;
+#ifdef CONFIG_IA64_HP_PROTO
+		} else if (memcmp(cp, "baud=", 4) == 0) {
+			extern int acpi_base_baud;
+
+			cp +=5;
+
+			acpi_base_baud = simple_strtoul(cp, NULL, 10);
+			printk("Using manual ACPI UART baud rate (%dMHz)\n",acpi_base_baud);
+			acpi_base_baud *= 1000000;
+			acpi_base_baud /= 16;
+		} else if (memcmp(cp, "noautoconf", 10) == 0) {
+			extern int acpi_autoconf_flag;
+
+			cp +=10;
+			printk("Autoconfig disabled for ACPI UARTs\n");
+			acpi_autoconf_flag = 0x0;
+#endif
 		} else {
 			while (*cp != ' ' && *cp)
 				++cp;
@@ -346,6 +393,9 @@
 		} else if (efi_guidcmp(config_tables[i].guid, SAL_SYSTEM_TABLE_GUID) == 0) {
 			efi.sal_systab = __va(config_tables[i].table);
 			printk(" SALsystab=0x%lx", config_tables[i].table);
+		} else if (efi_guidcmp(config_tables[i].guid, HCDP_TABLE_GUID) == 0) {
+			efi.hcdp = __va(config_tables[i].table);
+			printk(" HCDP=0x%lx", config_tables[i].table);
 		}
 	}
 	printk("\n");
@@ -477,6 +527,69 @@
 			/* paranoia attribute checking */
 			if (md->attribute == (EFI_MEMORY_UC | EFI_MEMORY_RUNTIME))
 				return md->phys_addr;
+		}
+	}
+	return 0;
+}
+
+u32
+efi_mem_type (u64 phys_addr)
+{
+	void *efi_map_start, *efi_map_end, *p;
+	efi_memory_desc_t *md;
+	u64 efi_desc_size;
+
+#ifdef CONFIG_IA64_HP_PROTO
+	if (phys_addr & 0x8000000000000000UL) {
+		printk("WARNING: %s called with 0x%lx, clearing MSB\n",
+			__FUNCTION__, phys_addr);
+		phys_addr &= ~0x8000000000000000UL;
+	}
+#endif
+
+	efi_map_start = __va(ia64_boot_param->efi_memmap);
+	efi_map_end   = efi_map_start + ia64_boot_param->efi_memmap_size;
+	efi_desc_size = ia64_boot_param->efi_memdesc_size;
+
+	for (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {
+		md = p;
+
+		if ((md->phys_addr <= phys_addr) && (phys_addr <=
+		    (md->phys_addr + (md->num_pages << 12) - 1))) {
+
+			 return md->type;
+		}
+	}
+	return 0;
+}
+
+u64
+efi_mem_attributes (u64 phys_addr)
+{
+	void *efi_map_start, *efi_map_end, *p;
+	efi_memory_desc_t *md;
+	u64 efi_desc_size;
+
+#ifdef CONFIG_IA64_HP_PROTO
+	if (phys_addr & 0x8000000000000000UL) {
+		printk("WARNING: %s called with 0x%lx, clearing MSB\n",
+			__FUNCTION__, phys_addr);
+		phys_addr &= ~0x8000000000000000UL;
+	}
+#endif
+
+	efi_map_start = __va(ia64_boot_param->efi_memmap);
+	efi_map_end   = efi_map_start + ia64_boot_param->efi_memmap_size;
+	efi_desc_size = ia64_boot_param->efi_memdesc_size;
+
+	for (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {
+		md = p;
+
+		if ((md->phys_addr <= phys_addr) && (phys_addr <=
+		    (md->phys_addr + (md->num_pages << 12) - 1))) {
+
+			return md->attribute;
+
 		}
 	}
 	return 0;
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/hcdp_serial.c linux/arch/ia64/kernel/hcdp_serial.c
--- ../ia64/linux/arch/ia64/kernel/hcdp_serial.c	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/kernel/hcdp_serial.c	Mon Mar 25 15:04:35 2002
@@ -0,0 +1,372 @@
+/*
+ *  linux/arch/ia64/kernel/hcdp_serial.c
+ *
+ *  Copyright (C) 2002  Hewlett-Packard Co.
+ *  Copyright (C) 2002  Khalid Aziz <khalid_aziz@hp.com>
+ *
+ *  Parse the EFI HCDP table to locate serial console and debug ports
+ *  and initialize them
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+#include <asm/serial.h>
+#include <asm/io.h>
+#include <asm/efi.h>
+#include <asm/hcdp_serial.h>
+
+extern char saved_command_line[];
+
+#undef SERIAL_DEBUG_HCDP
+#ifdef CONFIG_IA64_HP_PROTO
+static int acpi_autoconf_flag = ASYNC_BOOT_AUTOCONF;
+#endif
+
+/* compiled in serial ports */
+extern struct serial_state rs_table[];
+extern int serial_nr_ports;
+
+static inline unsigned int serial_in(struct async_struct *info, int offset)
+{
+	switch (info->io_type) {
+#ifdef CONFIG_HUB6
+	case SERIAL_IO_HUB6:
+		outb(info->hub6 - 1 + offset, info->port);
+		return inb(info->port+1);
+#endif
+	case SERIAL_IO_MEM:
+		return readb((unsigned long) info->iomem_base +
+			     (offset<<info->iomem_reg_shift));
+#ifdef CONFIG_SERIAL_GSC
+	case SERIAL_IO_GSC:
+		return gsc_readb(info->iomem_base + offset);
+#endif
+	default:
+		return inb(info->port + offset);
+	}
+}
+
+static inline void serial_out(struct async_struct *info, int offset,
+				int value)
+{
+	switch (info->io_type) {
+#ifdef CONFIG_HUB6
+	case SERIAL_IO_HUB6:
+		outb(info->hub6 - 1 + offset, info->port);
+		outb(value, info->port+1);
+		break;
+#endif
+	case SERIAL_IO_MEM:
+		writeb(value, (unsigned long) info->iomem_base +
+			      (offset<<info->iomem_reg_shift));
+		break;
+#ifdef CONFIG_SERIAL_GSC
+	case SERIAL_IO_GSC:
+		gsc_writeb(value, info->iomem_base + offset);
+		break;
+#endif
+	default:
+		outb(value, info->port+offset);
+	}
+}
+
+#define serial_inp(info, offset)		serial_in(info, offset)
+#define serial_outp(info, offset, value)	serial_out(info, offset, value)
+
+static int detect_port(struct serial_state * state)
+{
+	unsigned char scratch, scratch2, scratch3;
+	struct async_struct *info, scr_info;
+	unsigned long flags;
+
+	state->type = PORT_UNKNOWN;
+
+#ifdef SERIAL_DEBUG_HCDP
+	printk("hcdp_serial: Testing ttyS%d (0x%04lx, 0x%04x)...\n", state->line,
+	       state->port, (unsigned) state->iomem_base);
+#endif
+	
+	if (!CONFIGURED_SERIAL_PORT(state))
+		return 0;
+		
+	info = &scr_info;	/* This is just for serial_{in,out} */
+
+	info->magic = SERIAL_MAGIC;
+	info->state = state;
+	info->port = state->port;
+	info->flags = state->flags;
+#ifdef CONFIG_HUB6
+	info->hub6 = state->hub6;
+#endif
+	info->io_type = state->io_type;
+	info->iomem_base = state->iomem_base;
+	info->iomem_reg_shift = state->iomem_reg_shift;
+
+	save_flags(flags); cli();
+	
+	if (!(state->flags & ASYNC_BUGGY_UART) &&
+	    !state->iomem_base) {
+		/*
+		 * Do a simple existence test first; if we fail this,
+		 * there's no point trying anything else.
+		 * 
+		 * 0x80 is used as a nonsense port to prevent against
+		 * false positives due to ISA bus float.  The
+		 * assumption is that 0x80 is a non-existent port;
+		 * which should be safe since include/asm/io.h also
+		 * makes this assumption.
+		 */
+		scratch = serial_inp(info, UART_IER);
+		serial_outp(info, UART_IER, 0);
+#ifdef __i386__
+		outb(0xff, 0x080);
+#endif
+		scratch2 = serial_inp(info, UART_IER);
+		serial_outp(info, UART_IER, 0x0F);
+#ifdef __i386__
+		outb(0, 0x080);
+#endif
+		scratch3 = serial_inp(info, UART_IER);
+		serial_outp(info, UART_IER, scratch);
+		if (scratch2 || scratch3 != 0x0F) {
+#ifdef SERIAL_DEBUG_HCDP
+			printk("hcdp_serial: ttyS%d: simple detection failed "
+			       "(%02x, %02x)\n", state->line, 
+			       scratch2, scratch3);
+#endif
+			restore_flags(flags);
+			return 0;		/* We failed; there's nothing here */
+		}
+	}
+	return 1;
+}
+
+
+/*
+ * Parse the HCDP table to find descriptions for headless console and 
+ * debug serial ports and add them to rs_table[]. A pointer to HCDP
+ * table is passed as parameter. This function should be called 
+ * before serial_console_init() is called to make sure the HCDP serial 
+ * console will be available for use. IA-64 kernel calls this function
+ * from setup_arch() after the EFI and ACPI tables have been parsed.
+ */
+void __init setup_serial_hcdp(void *tablep) 
+{
+	hcdp_t hcdp;
+	hcdp_dev_t *hcdp_dev;
+	struct serial_struct serial_req;
+	unsigned long iobase;
+	int global_sys_irq;
+	int i, nr;
+	struct serial_state * state;
+
+
+#ifdef SERIAL_DEBUG_HCDP
+	printk("Entering setup_serial_hcdp()\n");
+#endif
+
+	/* Verify we have a valid table pointer */
+	if (tablep == NULL) {
+		return;
+	}
+
+	/*
+	 * We do not trust firmware to give us a table starting at an
+	 * aligned address. Make a local copy of the HCDP table with 
+	 * aligned structures.
+	 */
+	memcpy(&hcdp, tablep, sizeof(hcdp));
+
+	/*
+	 * Perform a sanity check on the table. Table should have a 
+	 * signature of "HCDP" and it should be atleast 82 bytes
+	 * long to have any useful information.
+	 */
+	if ((strncmp(hcdp.signature, HCDP_SIGNATURE, 
+					HCDP_SIG_LEN) != 0)) {
+		return;
+	}
+	if (hcdp.len < 82) {
+		return;
+	}
+
+#ifdef SERIAL_DEBUG_HCDP
+	printk("setup_serial_hcdp(): table pointer = 0x%p\n", tablep);
+	printk("                     sig = '%c%c%c%c'\n",
+			hcdp.signature[0],
+			hcdp.signature[1],
+			hcdp.signature[2],
+			hcdp.signature[3]);
+	printk("                     length = %d\n", hcdp.len);
+	printk("                     Rev = %d\n", hcdp.rev);
+	printk("                     OEM ID = %c%c%c%c%c%c\n", 
+			hcdp.oemid[0], hcdp.oemid[1], hcdp.oemid[2],
+			hcdp.oemid[3], hcdp.oemid[4], hcdp.oemid[5]);
+	printk("                     Number of entries = %d\n", hcdp.num_entries);
+#endif
+
+	/*
+	 * Parse each device entry
+	 */
+	for (nr=0; nr<hcdp.num_entries; nr++) {
+		hcdp_dev = &(hcdp.hcdp_dev[nr]);
+
+		/*
+		 * We will parse only the primary console and debug devices
+		 * which are the first entries for these devices. We will
+		 * ignore rest of the entries for the same type device that
+		 * has already been parsed and initialized
+		 */
+		if (hcdp_dev->type != HCDP_DEV_CONSOLE)
+			continue;
+
+		iobase = hcdp_dev->base_addr.addrhi<<32 | hcdp_dev->base_addr.addrlo;
+		global_sys_irq = hcdp_dev->global_int;
+#ifdef SERIAL_DEBUG_HCDP
+		printk("                 type = %s\n", 
+			((hcdp_dev->type == HCDP_DEV_CONSOLE)?"Headless Console":((hcdp_dev->type == HCDP_DEV_DEBUG)?"Debug port":"Huh????")));
+		printk("                 Base address space = %s\n", ((hcdp_dev->base_addr.space_id == ACPI_MEM_SPACE)?"Memory Space":((hcdp_dev->base_addr.space_id == ACPI_IO_SPACE)?"I/O space":"PCI space")));
+		printk("                 Base address = 0x%p\n", iobase);
+		printk("                 Global System Int = %d\n", global_sys_irq);
+		printk("                 Baud rate = %d\n", hcdp_dev->baud);
+		printk("                 Bits = %d\n", hcdp_dev->bits);
+		printk("                 Clock rate = %d\n", hcdp_dev->clock_rate);
+		if (hcdp_dev->base_addr.space_id == ACPI_PCICONF_SPACE) {
+			printk("                     PCI serial port:\n");
+			printk("                         Bus %d, Device %d, Vendor ID 0x%x, Dev ID 0x%x\n",
+			hcdp_dev->pci_bus, hcdp_dev->pci_dev,
+			hcdp_dev->pci_vendor_id, hcdp_dev->pci_dev_id);
+		}
+#endif
+
+
+		/* 
+	 	* Now build a serial_req structure to update the entry in
+	 	* rs_table for the headless console port.
+	 	*/
+		if (hcdp_dev->clock_rate)
+			serial_req.baud_base = hcdp_dev->clock_rate;
+		else
+			serial_req.baud_base = DEFAULT_BAUD_BASE;
+		/*
+	 	* Check if this is an I/O mapped address or a memory mapped address
+	 	*/
+		if (hcdp_dev->base_addr.space_id == ACPI_MEM_SPACE) {
+			serial_req.port = 0;
+			serial_req.port_high = 0;
+			serial_req.iomem_base = (void *)ioremap(iobase, 64);
+			serial_req.io_type = SERIAL_IO_MEM;
+		}
+		else if (hcdp_dev->base_addr.space_id == ACPI_IO_SPACE) {
+			serial_req.port = (unsigned long) iobase & 0xffffffff;
+			serial_req.port_high = (unsigned long)(((u64)iobase) >> 32);
+			serial_req.iomem_base = NULL;
+			serial_req.io_type = SERIAL_IO_PORT;
+		}
+		else if (hcdp_dev->base_addr.space_id == ACPI_PCICONF_SPACE) {
+			printk("WARNING: No support for PCI serial console\n");
+			return;
+		}
+
+		/*
+	 	* Check if HCDP defines a port already in rs_table
+	 	*/
+		for (i = 0; i < serial_nr_ports; i++) {
+			if ((rs_table[i].port == serial_req.port) &&
+				(rs_table[i].iomem_base == serial_req.iomem_base))
+				break;
+		}
+		if (i == serial_nr_ports) {
+			if (hcdp_dev->type == HCDP_DEV_CONSOLE) {
+				/*
+			 	* Check if there is a legacy COM1 port on this
+			 	* machine. If there is, it has been statically
+			 	* compiled in the rs_table at slot 0. We need to
+			 	* move it out so we can make HCDP port ttyS0.
+			 	*/
+				state = (struct serial_state *)rs_table;
+				state->magic = SSTATE_MAGIC;
+				state->line = 0;
+				state->type = PORT_UNKNOWN;
+				if (detect_port(state)) {
+					int j;
+	
+					for (j=HCDP_SERIAL_CONSOLE_PORT; j>0; j--)
+						memcpy(rs_table+j, rs_table+j-1, sizeof(struct serial_state));
+				}
+
+				serial_req.line = 0;
+			}
+#if 0
+			else if (hcdp_dev->type == HCDP_DEV_DEBUG) {
+				/*
+			 	* Check if there is a legacy COM2 port on this
+			 	* machine. If there is, it has been statically
+			 	* compiled in the rs_table at slot 1. We need to
+			 	* move it out so we can make HCDP port ttyS1.
+			 	*/
+				state = (struct serial_state *)(rs_table+1);
+				state->magic = SSTATE_MAGIC;
+				state->line = 1;
+				state->type = PORT_UNKNOWN;
+				if (detect_port(state)) {
+					int j;
+
+					for (j=ACPI_SERIAL_DEBUG_PORT; j>1; j--)
+						memcpy(rs_table+j, rs_table+j-1, sizeof(struct serial_state));
+				}
+				serial_req.line = 1;
+			}
+#endif
+		}
+		else {
+			serial_req.line = i;
+		}
+
+		/*
+	 	* If the table does not have IRQ information, use 0 for IRQ. 
+	 	* This will force rs_init() to probe for IRQ. 
+	 	*/
+		serial_req.irq = global_sys_irq;
+		if (global_sys_irq == 0) {
+#ifdef CONFIG_IA64_HP_PROTO
+			serial_req.flags = ASYNC_SKIP_TEST|acpi_autoconf_flag;
+#else
+			serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF;
+#endif
+		}
+		else {
+#ifdef CONFIG_IA64_HP_PROTO
+			serial_req.flags = ASYNC_SKIP_TEST|acpi_autoconf_flag |
+						ASYNC_AUTO_IRQ;
+#else
+			serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF|
+						ASYNC_AUTO_IRQ;
+#endif
+		}
+
+		serial_req.xmit_fifo_size = serial_req.custom_divisor = 0;
+		serial_req.close_delay = serial_req.hub6 = serial_req.closing_wait = 0;
+		serial_req.iomem_reg_shift = 0;
+		if (early_serial_setup(&serial_req) < 0) {
+			printk("early_serial_setup() for HCDP serial console port failed\n");
+			continue;
+		}
+		else
+			if (hcdp_dev->type == HCDP_DEV_CONSOLE)
+				break;
+#ifdef SERIAL_DEBUG_HCDP
+		printk("\n");
+#endif
+	}
+
+#ifdef SERIAL_DEBUG_HCDP
+	printk("Leaving setup_serial_hcdp()\n");
+#endif
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/ia64_ksyms.c linux/arch/ia64/kernel/ia64_ksyms.c
--- ../ia64/linux/arch/ia64/kernel/ia64_ksyms.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/ia64_ksyms.c	Tue Apr  9 05:01:45 2002
@@ -24,9 +24,11 @@
 EXPORT_SYMBOL(strrchr);
 EXPORT_SYMBOL(strstr);
 EXPORT_SYMBOL(strtok);
+EXPORT_SYMBOL(strpbrk);
 
 #include <linux/irq.h>
 EXPORT_SYMBOL(isa_irq_to_vector_map);
+EXPORT_SYMBOL(gsi_irq_to_vector_map);
 EXPORT_SYMBOL(enable_irq);
 EXPORT_SYMBOL(disable_irq);
 EXPORT_SYMBOL(disable_irq_nosync);
@@ -56,6 +58,10 @@
 #include <asm/page.h>
 EXPORT_SYMBOL(clear_page);
 
+#include <asm/pgtable.h>
+EXPORT_SYMBOL(vmalloc_end);
+EXPORT_SYMBOL(ia64_page_valid);
+
 #include <asm/processor.h>
 # ifndef CONFIG_NUMA
 EXPORT_SYMBOL(_cpu_data);
@@ -147,3 +153,10 @@
 #include <linux/proc_fs.h>
 extern struct proc_dir_entry *efi_dir;
 EXPORT_SYMBOL(efi_dir);
+
+#include <asm/machvec.h>
+#ifdef CONFIG_IA64_GENERIC
+EXPORT_SYMBOL(ia64_mv);
+#endif
+EXPORT_SYMBOL(machvec_noop);
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/iosapic.c linux/arch/ia64/kernel/iosapic.c
--- ../ia64/linux/arch/ia64/kernel/iosapic.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/iosapic.c	Mon Apr  8 19:09:55 2002
@@ -359,6 +359,8 @@
 	if (vector < 0)
 		vector = ia64_alloc_irq();
 
+	gsi_irq_to_vector(global_vector) = vector;
+
 	/* fill in information from this vector's IOSAPIC */
 	iosapic_irq[vector].addr = iosapic_address;
 	iosapic_irq[vector].base_irq = base_irq;
@@ -417,6 +419,8 @@
 		return -1;
 	}
 
+	gsi_irq_to_vector(global_vector) = vector;
+
 	/* fill in information from this vector's IOSAPIC */
 	iosapic_irq[vector].addr = iosapic_address;
 	iosapic_irq[vector].base_irq = base_irq;
@@ -467,6 +471,8 @@
 	       vector);
 #endif
 
+	gsi_irq_to_vector(irq) = vector;
+
 	iosapic_irq[vector].pin = pin;
 	iosapic_irq[vector].dmode = IOSAPIC_LOWEST_PRIORITY;
 	iosapic_irq[vector].polarity = polarity ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW;
@@ -515,6 +521,8 @@
 			iosapic_irq[vector].base_irq = 0;
 			if (iosapic_irq[vector].pin == -1)
 				iosapic_irq[vector].pin = irq;
+
+			gsi_irq_to_vector(irq) = vector;
 			iosapic_irq[vector].dmode = IOSAPIC_LOWEST_PRIORITY;
 			iosapic_irq[vector].trigger  = IOSAPIC_EDGE;
 			iosapic_irq[vector].polarity = IOSAPIC_POL_HIGH;
@@ -553,6 +561,7 @@
 				vector = ia64_alloc_irq();
 		}
 
+		gsi_irq_to_vector(irq) = vector;
 		iosapic_irq[vector].addr     = addr;
 		iosapic_irq[vector].base_irq = base_irq;
 		iosapic_irq[vector].pin	     = (irq - base_irq);
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/irq.c linux/arch/ia64/kernel/irq.c
--- ../ia64/linux/arch/ia64/kernel/irq.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/irq.c	Sun Mar 10 18:55:41 2002
@@ -67,6 +67,23 @@
 irq_desc_t _irq_desc[NR_IRQS] __cacheline_aligned =
 	{ [0 ... NR_IRQS-1] = { IRQ_DISABLED, &no_irq_type, NULL, 0, SPIN_LOCK_UNLOCKED}};
 
+#ifdef CONFIG_IA64_GENERIC
+struct irq_desc * __ia64_irq_desc (unsigned int irq)
+{
+	return _irq_desc + irq;
+}
+
+ia64_vector __ia64_irq_to_vector (unsigned int irq)
+{
+	return (ia64_vector) irq;
+}
+
+unsigned int __ia64_local_vector_to_irq (ia64_vector vec)
+{
+	return (unsigned int) vec;
+}
+#endif
+
 static void register_irq_proc (unsigned int irq);
 
 /*
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/irq_ia64.c linux/arch/ia64/kernel/irq_ia64.c
--- ../ia64/linux/arch/ia64/kernel/irq_ia64.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/irq_ia64.c	Mon Apr  8 23:15:40 2002
@@ -50,6 +50,11 @@
 	0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21
 };
 
+/*
+ * GSI IRQ to IA-64 vector translation table.
+ */
+__u8 gsi_irq_to_vector_map[255] = { [0 ... 254] = {0x0}};
+
 int
 ia64_alloc_irq (void)
 {
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/setup.c linux/arch/ia64/kernel/setup.c
--- ../ia64/linux/arch/ia64/kernel/setup.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/setup.c	Tue Apr  9 05:01:45 2002
@@ -65,6 +65,9 @@
 
 unsigned long ia64_iobase;	/* virtual address for I/O accesses */
 
+unsigned long MAX_DMA_ADDRESS;
+#define MAX_DMA_BASE_ADDR (PAGE_OFFSET + 0x100000000UL)
+
 #define COMMAND_LINE_SIZE	512
 
 char saved_command_line[COMMAND_LINE_SIZE]; /* used in proc filesystem */
@@ -105,6 +108,22 @@
 	return 0;
 }
 
+static int
+find_max_dma_addr (unsigned long start, unsigned long end, void *arg)
+{
+	unsigned long *max_dma = arg; 
+
+	if (start >= MAX_DMA_BASE_ADDR) {
+		if (start < *max_dma)
+			*max_dma = start;
+	}
+	else {
+		if (end > MAX_DMA_BASE_ADDR)
+			*max_dma = MAX_DMA_BASE_ADDR;
+	}
+	return 0;
+}
+
 #define IGNORE_PFN0	1	/* XXX fix me: ignore pfn 0 until TLB miss handler is updated... */
 
 /*
@@ -253,6 +272,10 @@
 	max_pfn = 0;
 	efi_memmap_walk(find_max_pfn, &max_pfn);
 
+	/* Set MAX_DMA_ADDRESS */
+	MAX_DMA_ADDRESS = ~0UL;
+	efi_memmap_walk(find_max_dma_addr, &MAX_DMA_ADDRESS);
+
 	/* how many bytes to cover all the pages */
 	bootmap_size = bootmem_bootmap_pages(max_pfn) << PAGE_SHIFT;
 
@@ -332,7 +355,7 @@
 		printk("No I/O port range found in EFI memory map, falling back to AR.KR0\n");
 		printk("I/O port base = 0x%lx\n", ia64_iobase);
 	}
-	ia64_iobase = __IA64_UNCACHED_OFFSET | (ia64_iobase & ~PAGE_OFFSET);
+	ia64_iobase = ioremap(__pa(ia64_iobase), 0x4000000UL /* 64MB */);
 
 #ifdef CONFIG_SMP
 	cpu_physical_id(0) = hard_smp_processor_id();
@@ -347,14 +370,28 @@
 		/* Parse the ACPI tables */
 		acpi_parse(efi.acpi);
 	}
+#if !(defined CONFIG_SERIAL_ACPI)
+	if (efi.hcdp) {
+		/* Setup the serial ports described by HCDP */
+		setup_serial_hcdp(efi.hcdp);
+	}
+#endif
 
 #ifdef CONFIG_VT
-# if defined(CONFIG_VGA_CONSOLE)
-	conswitchp = &vga_con;
-# elif defined(CONFIG_DUMMY_CONSOLE)
+# if defined(CONFIG_DUMMY_CONSOLE)
 	conswitchp = &dummy_con;
 # endif
-#endif
+# if defined(CONFIG_VGA_CONSOLE)
+	/*
+	 * Non-legacy systems may route legacy VGA MMIO range to system
+	 * memory.  vga_con probes the MMIO hole, so memory looks like
+	 * a VGA device to it.  The EFI memory map can tell us if it's
+	 * memory so we can avoid this problem.
+	 */
+	if (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)
+		conswitchp = &vga_con;
+# endif
+#endif /* CONFIG_VT */
 
 #ifdef CONFIG_IA64_MCA
 	/* enable IA-64 Machine Check Abort Handling */
@@ -488,7 +525,9 @@
 		cpuid.bits[i] = ia64_get_cpuid(i);
 
 	memcpy(c->vendor, cpuid.field.vendor, 16);
+#ifdef CONFIG_SMP
 	c->processor = smp_processor_id();
+#endif
 	c->ppn = cpuid.field.ppn;
 	c->number = cpuid.field.number;
 	c->revision = cpuid.field.revision;
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/kernel/smpboot.c linux/arch/ia64/kernel/smpboot.c
--- ../ia64/linux/arch/ia64/kernel/smpboot.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/kernel/smpboot.c	Mon Apr  8 19:04:46 2002
@@ -344,6 +344,11 @@
 	 */
 	ia64_init_itm();
 
+	/*
+	 * Set I/O port base per CPU
+	 */
+	ia64_set_kr(IA64_KR_IO_BASE, __pa(__ia64_get_io_port_base()));
+
 #ifdef CONFIG_IA64_MCA
 	ia64_mca_cmc_vector_setup();	/* Setup vector on AP & enable */
 	ia64_mca_check_errors();	/* For post-failure MCA error logging */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/lib/Makefile linux/arch/ia64/lib/Makefile
--- ../ia64/linux/arch/ia64/lib/Makefile	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/lib/Makefile	Fri Feb  8 07:42:53 2002
@@ -14,7 +14,7 @@
 	checksum.o clear_page.o csum_partial_copy.o copy_page.o				\
 	copy_user.o clear_user.o strncpy_from_user.o strlen_user.o strnlen_user.o	\
 	flush.o io.o do_csum.o								\
-	memcpy.o memset.o strlen.o swiotlb.o
+	memcpy.o memset.o strlen.o swiotlb.o page_valid.o
 
 IGNORE_FLAGS_OBJS =	__divsi3.o __udivsi3.o __modsi3.o __umodsi3.o \
 			__divdi3.o __udivdi3.o __moddi3.o __umoddi3.o
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/lib/clear_page.S linux/arch/ia64/lib/clear_page.S
--- ../ia64/linux/arch/ia64/lib/clear_page.S	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/lib/clear_page.S	Tue May 14 08:52:56 2002
@@ -23,15 +23,18 @@
 #define dst2		r9
 #define dst3		r10
 #define dst_fetch	r11
+#define dst_last	r14
 
 GLOBAL_ENTRY(clear_page)
 	.prologue
 	.regstk 1,0,0,0
 	mov r16 = PAGE_SIZE/64-1	// -1 = repeat/until
+	mov r17 = PAGE_SIZE
 	;;
 	.save ar.lc, saved_lc
 	mov saved_lc = ar.lc
 	.body
+	add dst_last = r17, dst0
 	mov ar.lc = r16
 	adds dst1 = 16, dst0
 	adds dst2 = 32, dst0
@@ -40,10 +43,12 @@
 	;;
 1:	stf.spill.nta [dst0] = f0, 64
 	stf.spill.nta [dst1] = f0, 64
+	cmp.ltu p6,p0 = dst_fetch, dst_last
 	stf.spill.nta [dst2] = f0, 64
 	stf.spill.nta [dst3] = f0, 64
+	;;
 
-	lfetch [dst_fetch], 64
+(p6)	lfetch [dst_fetch], 64
 	br.cloop.dptk.few 1b
 	;;
 	mov ar.lc = r2		// restore lc
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/lib/copy_page.S linux/arch/ia64/lib/copy_page.S
--- ../ia64/linux/arch/ia64/lib/copy_page.S	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/lib/copy_page.S	Tue May 14 08:52:56 2002
@@ -30,6 +30,7 @@
 #define tgt2		r23
 #define srcf		r24
 #define tgtf		r25
+#define tgt_last	r26
 
 #define Nrot		((8*PIPE_DEPTH+7)&~7)
 
@@ -55,18 +56,21 @@
 
 	mov src1=in1
 	adds src2=8,in1
+	mov tgt_last = PAGE_SIZE
 	;;
 	adds tgt2=8,in0
 	add srcf=512,in1
 	mov ar.lc=lcount
 	mov tgt1=in0
 	add tgtf=512,in0
+	add tgt_last = tgt_last, in0
 	;;
 1:
 (p[0])	ld8 t1[0]=[src1],16
 (EPI)	st8 [tgt1]=t1[PIPE_DEPTH-1],16
 (p[0])	ld8 t2[0]=[src2],16
 (EPI)	st8 [tgt2]=t2[PIPE_DEPTH-1],16
+	cmp.ltu p6,p0 = tgtf, tgt_last
 	;;
 (p[0])	ld8 t3[0]=[src1],16
 (EPI)	st8 [tgt1]=t3[PIPE_DEPTH-1],16
@@ -83,8 +87,8 @@
 (p[0])	ld8 t8[0]=[src2],16
 (EPI)	st8 [tgt2]=t8[PIPE_DEPTH-1],16
 
-	lfetch [srcf], 64
-	lfetch [tgtf], 64
+(p6)	lfetch [srcf], 64
+(p6)	lfetch [tgtf], 64
 	br.ctop.sptk.few 1b
 	;;
 	mov pr=saved_pr,0xffffffffffff0000	// restore predicates
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/lib/page_valid.S linux/arch/ia64/lib/page_valid.S
--- ../ia64/linux/arch/ia64/lib/page_valid.S	Wed Dec 31 17:00:00 1969
+++ linux/arch/ia64/lib/page_valid.S	Fri Feb  8 07:42:53 2002
@@ -0,0 +1,33 @@
+/*
+ * Simple routine to check if an address is valid or not. Currently
+ * used for validating struct page pointers.
+ *
+ * Inputs:
+ * 	in0:	address to validate
+ * Output:
+ *	1 if address valid, 0 if not
+ *
+ * Copyright (C) 2000-2001 Hewlett-Packard Co
+ *	John Marvin <jsm@fc.hp.com>
+ */
+#include <linux/config.h>
+
+#include <asm/asmmacro.h>
+
+#define saved_pfs r11
+
+GLOBAL_ENTRY(ia64_page_valid)
+	.prologue
+	.save ar.pfs, saved_pfs
+	alloc	saved_pfs=ar.pfs,2,0,0,0
+	.body
+
+	EX(.Laddr_invalid, ld8 r14 = [in0])
+	;;
+	addl r8 = 1, r0
+	br.ret.sptk.many rp
+	;;
+.Laddr_invalid:
+	mov r8 = r0
+	br.ret.sptk.many rp
+END(ia64_page_valid)
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/mm/extable.c linux/arch/ia64/mm/extable.c
--- ../ia64/linux/arch/ia64/mm/extable.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/mm/extable.c	Thu Mar  7 15:43:13 2002
@@ -59,6 +59,8 @@
 		if (!mp->ex_table_start)
 			continue;
 		archdata = (struct archdata *) mp->archdata_start;
+		if (!archdata)
+			continue;
 		entry = search_one_table(mp->ex_table_start, mp->ex_table_end - 1,
 					 addr, (unsigned long) archdata->gp);
 		if (entry) {
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/mm/fault.c linux/arch/ia64/mm/fault.c
--- ../ia64/linux/arch/ia64/mm/fault.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/mm/fault.c	Fri Feb  8 07:42:53 2002
@@ -59,6 +59,15 @@
 	if (in_interrupt() || !mm)
 		goto no_context;
 
+	/* If fault is in region 5 and we are in the kernel, we may already 
+         * have the mmap_sem (VALID_PAGE macro is called during mmap). There
+	 * should be no vma for region 5 addr's anyway, so skip getting the
+	 * semaphore and go directly to the code that handles a bad area.
+  	 */
+	
+	if ((REGION_NUMBER(address) == 5) && !user_mode(regs))
+		goto bad_area_no_up;
+
 	down_read(&mm->mmap_sem);
 
 	vma = find_vma_prev(mm, address, &prev_vma);
@@ -138,6 +147,8 @@
 
   bad_area:
 	up_read(&mm->mmap_sem);
+
+  bad_area_no_up:
 	if (isr & IA64_ISR_SP) {
 		/*
 		 * This fault was due to a speculative load set the "ed" bit in the psr to
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/mm/init.c linux/arch/ia64/mm/init.c
--- ../ia64/linux/arch/ia64/mm/init.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/mm/init.c	Tue Apr  9 05:01:45 2002
@@ -33,10 +33,16 @@
 
 extern void ia64_tlb_init (void);
 
-unsigned long MAX_DMA_ADDRESS = PAGE_OFFSET + 0x100000000UL;
+#define LARGE_GAP 0x40000000 /* Use virtual mem map if a hole is > than this */
+
+static unsigned long num_dma_physpages;
 
 static unsigned long totalram_pages;
 
+unsigned long vmalloc_end = VMALLOC_END_INIT;
+
+static struct page *vmem_map;
+
 int
 do_check_pgt_cache (int low, int high)
 {
@@ -335,37 +341,254 @@
 	ia64_tlb_init();
 }
 
+static int
+create_mem_map_page_table (u64 start, u64 end, void *arg)
+{
+	unsigned long address, start_page, end_page;
+	struct page *map_start, *map_end;
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *pte;
+	void *page;
+ 
+	/* should we use platform_map_nr here? */
+
+	map_start = vmem_map + MAP_NR_DENSE(start);
+	map_end   = vmem_map + MAP_NR_DENSE(end);
+ 
+	start_page = (unsigned long) map_start & PAGE_MASK;
+	end_page = PAGE_ALIGN((unsigned long) map_end);
+
+	for (address = start_page; address < end_page; address += PAGE_SIZE) {
+		pgd = pgd_offset_k(address);
+		if (pgd_none(*pgd)) {
+			pmd = alloc_bootmem_pages(PAGE_SIZE);
+			pgd_val(*pgd) = __pa(pmd);
+			pmd += (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
+		} else
+			pmd = pmd_offset(pgd, address);
+		if (pmd_none(*pmd)) {
+			pte = alloc_bootmem_pages(PAGE_SIZE);
+			pmd_val(*pmd) = __pa(pte);
+			pte += (address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);
+		} else
+			pte = pte_offset(pmd, address);
+
+		if (pte_none(*pte)) {
+			page = alloc_bootmem_pages(PAGE_SIZE);
+			set_pte(pte, mk_pte_phys(__pa(page), PAGE_KERNEL));
+		}
+ 	}
+ 	return 0;
+}
+
+struct vmmi_callback_data {
+	memmap_init_callback_t *callback;
+	struct page *min_start;
+	struct page *max_end;
+};
+
+static int
+virtual_memmap_init (u64 start, u64 end, void *arg)
+{
+	struct page *map_start, *map_end;
+	struct vmmi_callback_data *vmmi_datap 
+                = (struct vmmi_callback_data *)arg;
+
+	/* Should we use platform_map_nr here? */
+
+	map_start = mem_map + MAP_NR_DENSE(start);
+	map_end   = mem_map + MAP_NR_DENSE(end);
+
+	/* We initialize "out of bounds" struct page elements that
+	 * fit completely on the same pages that were allocated for
+	 * the "in bounds" struct page elements. 
+	 */ 
+
+	map_start -= ((unsigned long) map_start & (PAGE_SIZE - 1)) 
+			/ sizeof(struct page);
+	map_end += (PAGE_ALIGN((unsigned long) map_end)
+			- (unsigned long) map_end) / sizeof(struct page);
+
+	if (map_start < vmmi_datap->min_start)
+		map_start = vmmi_datap->min_start;
+	
+	if (map_end > vmmi_datap->max_end)
+		map_end = vmmi_datap->max_end;
+
+	(*(vmmi_datap->callback))(map_start,map_end);
+	return 0;
+}
+
+void 
+arch_memmap_init(memmap_init_callback_t *callback,
+			struct page *start, struct page *end)
+{
+	struct vmmi_callback_data vmmi_data;
+
+	vmmi_data.callback = callback;
+	vmmi_data.min_start = start;
+	vmmi_data.max_end = end;
+	efi_memmap_walk(virtual_memmap_init,(void *)&vmmi_data);
+}
+
+struct zone_callback_data {
+	memmap_zone_callback_t *callback;
+	struct page *start;
+	struct page *end;
+	zone_t *zone;
+	unsigned long start_paddr;
+	int highmem_flag;
+};
+
+static int
+zone_init(u64 start, u64 end, void *arg)
+{
+	struct page *map_start, *map_end;
+	struct zone_callback_data *cb_datap = (struct zone_callback_data *)arg;
+	unsigned long start_paddr;
+
+	/* Should we use platform_map_nr here? */
+
+	map_start = mem_map + MAP_NR_DENSE(start);
+	map_end   = mem_map + MAP_NR_DENSE(end);
+
+	start_paddr = cb_datap->start_paddr;
+	if (map_start < cb_datap->start) 
+		map_start = cb_datap->start;
+	else 
+		start_paddr += ((map_start - cb_datap->start) << PAGE_SHIFT);
+
+	if (map_end > cb_datap->end)
+		map_end = cb_datap->end;
+
+	if (map_start < map_end) {
+		(*(cb_datap->callback))(map_start,map_end,cb_datap->zone,
+					start_paddr,cb_datap->highmem_flag);
+	}
+
+	return 0;
+}
+
+void 
+arch_memmap_zone_init(memmap_zone_callback_t *callback,
+			struct page *start, struct page *end,
+			zone_t *zone, unsigned long start_paddr,
+			int highmem_flag)
+{
+	struct zone_callback_data cb_data;
+
+	cb_data.callback = callback;
+	cb_data.start = start;
+	cb_data.end = end;
+	cb_data.zone = zone;
+	cb_data.start_paddr = start_paddr;
+	cb_data.highmem_flag = highmem_flag;
+
+	efi_memmap_walk(zone_init,(void *)&cb_data);
+}
+
+static int
+count_pages (u64 start, u64 end, void *arg)
+{
+	unsigned long *count = arg;
+
+	*count += (end - start) >> PAGE_SHIFT;
+	return 0;
+}
+
+static int
+count_dma_pages (u64 start, u64 end, void *arg)
+{
+	unsigned long *count = arg;
+
+	if (end <= MAX_DMA_ADDRESS)
+		*count += (end - start) >> PAGE_SHIFT;
+	return 0;
+}
+
+#ifndef CONFIG_DISCONTIGMEM
+static int
+find_largest_hole(u64 start, u64 end, void *arg)
+{
+	u64 *max_gap = arg;
+	static u64 last_end = PAGE_OFFSET;
+
+	if (start < last_end)
+		printk("Oops! efi memmap table not ordered!\n");
+	else {
+		if (*max_gap < (start - last_end))
+			*max_gap = start - last_end;
+	}
+
+	last_end = end;
+	return 0;
+}
+#endif
+
 /*
  * Set up the page tables.
  */
 void
 paging_init (void)
 {
-	unsigned long max_dma, zones_size[MAX_NR_ZONES];
+	unsigned long max_dma; 
+	unsigned long zones_size[MAX_NR_ZONES];
+	unsigned long zholes_size[MAX_NR_ZONES];
+#ifndef CONFIG_DISCONTIGMEM
+	unsigned long max_gap;
+#endif
 
 	clear_page((void *) ZERO_PAGE_ADDR);
 
 	/* initialize mem_map[] */
 
 	memset(zones_size, 0, sizeof(zones_size));
+	memset(zholes_size, 0, sizeof(zholes_size));
+
+	num_physpages = 0;
+	efi_memmap_walk(count_pages, &num_physpages);
+
+	num_dma_physpages = 0;
+	efi_memmap_walk(count_dma_pages, &num_dma_physpages);
 
 	max_dma = virt_to_phys((void *) MAX_DMA_ADDRESS) >> PAGE_SHIFT;
-	if (max_low_pfn < max_dma)
+
+	if (max_low_pfn < max_dma) {
 		zones_size[ZONE_DMA] = max_low_pfn;
+		zholes_size[ZONE_DMA] = max_low_pfn - num_dma_physpages;
+	}
 	else {
 		zones_size[ZONE_DMA] = max_dma;
-		zones_size[ZONE_NORMAL] = max_low_pfn - max_dma;
+		zholes_size[ZONE_DMA] = max_dma - num_dma_physpages;
+		if (num_physpages > num_dma_physpages) {
+			zones_size[ZONE_NORMAL] = max_low_pfn - max_dma;
+			zholes_size[ZONE_NORMAL] = (max_low_pfn - max_dma)
+					- (num_physpages - num_dma_physpages);
+		}
 	}
-	free_area_init(zones_size);
-}
 
-static int
-count_pages (u64 start, u64 end, void *arg)
-{
-	unsigned long *count = arg;
+#ifdef CONFIG_DISCONTIGMEM
+	free_area_init_node(0,NULL,NULL,zones_size,0,zholes_size);
+#else
+	max_gap = 0;
+	efi_memmap_walk(find_largest_hole, (u64 *)&max_gap);
 
-	*count += (end - start) >> PAGE_SHIFT;
-	return 0;
+	if (max_gap < LARGE_GAP)
+	    	free_area_init_node(0,NULL,NULL,zones_size,0,zholes_size);
+	else {
+		unsigned long map_size;
+
+		/* allocate virtual mem_map */
+	
+		map_size = PAGE_ALIGN(max_low_pfn*sizeof(struct page));
+		vmalloc_end -= map_size;
+		vmem_map = (struct page *) vmalloc_end;
+		efi_memmap_walk(create_mem_map_page_table, 0);
+		free_area_init_node(0,NULL,vmem_map,zones_size,0,zholes_size);
+		printk("Virtual mem_map starts at %p\n",mem_map);
+ 	}
+#endif
 }
 
 static int
@@ -401,9 +624,6 @@
 	if (!mem_map)
 		BUG();
 
-	num_physpages = 0;
-	efi_memmap_walk(count_pages, &num_physpages);
-
 	max_mapnr = max_low_pfn;
 	high_memory = __va(max_low_pfn * PAGE_SIZE);
 
@@ -418,7 +638,7 @@
 
 	printk("Memory: %luk/%luk available (%luk code, %luk reserved, %luk data, %luk init)\n",
 	       (unsigned long) nr_free_pages() << (PAGE_SHIFT - 10),
-	       max_mapnr << (PAGE_SHIFT - 10), codesize >> 10, reserved_pages << (PAGE_SHIFT - 10),
+	       num_physpages << (PAGE_SHIFT - 10), codesize >> 10, reserved_pages << (PAGE_SHIFT - 10),
 	       datasize >> 10, initsize >> 10);
 
 	/*
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/mm/tlb.c linux/arch/ia64/mm/tlb.c
--- ../ia64/linux/arch/ia64/mm/tlb.c	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/mm/tlb.c	Sun Mar 10 18:57:50 2002
@@ -79,7 +79,7 @@
 	flush_tlb_all();
 }
 
-static inline void
+void
 ia64_global_tlb_purge (unsigned long start, unsigned long end, unsigned long nbits)
 {
 	static spinlock_t ptcg_lock = SPIN_LOCK_UNLOCKED;
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/arch/ia64/vmlinux.lds.S linux/arch/ia64/vmlinux.lds.S
--- ../ia64/linux/arch/ia64/vmlinux.lds.S	Fri Jan 25 13:11:06 2002
+++ linux/arch/ia64/vmlinux.lds.S	Fri Jan 25 14:48:14 2002
@@ -12,6 +12,8 @@
   /DISCARD/ : {
 	*(.text.exit)
 	*(.data.exit)
+	*(*.text.exit)
+	*(*.data.exit)
 	*(.exitcall.exit)
 	}
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/Makefile linux/drivers/acpi/Makefile
--- ../ia64/linux/drivers/acpi/Makefile	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/Makefile	Sat Apr  6 08:32:49 2002
@@ -36,7 +36,7 @@
 subdir-$(CONFIG_ACPI) 		+= $(acpi-subdirs)
 subdir-$(CONFIG_ACPI_BUSMGR)	+= ospm
 
-obj-$(CONFIG_ACPI)	+= driver.o os.o acpi_ksyms.o
+obj-$(CONFIG_ACPI)	+= driver.o os.o acpi_ksyms.o acpi_bus.o
 obj-$(CONFIG_ACPI)	+= $(foreach dir,$(acpi-subdirs),$(dir)/$(dir).o) 
 ifdef CONFIG_ACPI_KERNEL_CONFIG
    obj-$(CONFIG_ACPI) 	+= acpiconf.o osconf.o
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/acpi_bus.c linux/drivers/acpi/acpi_bus.c
--- ../ia64/linux/drivers/acpi/acpi_bus.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/acpi_bus.c	Sat Apr  6 08:32:49 2002
@@ -0,0 +1,14 @@
+
+#include <linux/acpi.h>
+#include "acpi_bus.h"
+
+acpi_status acpi_add_callback(acpi_handle obj_handle, u32 nesting_level,
+		void *context, void **return_value)
+{
+	acpi_op_add add = (acpi_op_add) context;
+	struct acpi_device device;
+	device.handle = obj_handle;
+
+	add(&device);
+	return AE_OK;
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/acpi_bus.h linux/drivers/acpi/acpi_bus.h
--- ../ia64/linux/drivers/acpi/acpi_bus.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/acpi/acpi_bus.h	Sat Apr  6 08:32:49 2002
@@ -0,0 +1,44 @@
+struct acpi_device {
+	acpi_handle	handle;
+};
+
+typedef int (*acpi_op_add)	(struct acpi_device *device);
+typedef int (*acpi_op_remove)	(struct acpi_device *device, int type);
+typedef int (*acpi_op_lock)	(struct acpi_device *device, int type);
+typedef int (*acpi_op_start)	(struct acpi_device *device);
+typedef int (*acpi_op_stop)	(struct acpi_device *device, int type);
+typedef int (*acpi_op_suspend)	(struct acpi_device *device, int state);
+typedef int (*acpi_op_resume)	(struct acpi_device *device, int state);
+typedef int (*acpi_op_scan)	(struct acpi_device *device);
+typedef int (*acpi_op_bind)	(struct acpi_device *device);
+
+struct acpi_device_ops {
+	acpi_op_add		add;
+	acpi_op_remove		remove;
+	acpi_op_lock		lock;
+	acpi_op_start		start;
+	acpi_op_stop		stop;
+	acpi_op_suspend		suspend;
+	acpi_op_resume		resume;
+	acpi_op_scan		scan;
+	acpi_op_bind		bind;
+};
+
+struct acpi_driver {
+	struct list_head	node;
+	char			name[80];
+	char			class[80];
+	int			references;
+	char *			ids;
+	struct acpi_device_ops	ops;
+};
+
+extern acpi_status acpi_add_callback(acpi_handle obj_handle,
+		u32 nesting_level, void *context, void **return_value);
+
+static inline int acpi_bus_register_driver(struct acpi_driver *driver)
+{
+	return acpi_get_devices(driver->ids, acpi_add_callback,
+			driver->ops.add, NULL);
+}
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/acpiconf.c linux/drivers/acpi/acpiconf.c
--- ../ia64/linux/drivers/acpi/acpiconf.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/acpiconf.c	Sat Mar 23 10:23:14 2002
@@ -109,7 +109,10 @@
 	void		*prts;
 
 	if (! ACPI_CF_INITIALIZED()) {
-		status = acpi_cf_init((void *)efi.acpi);
+		if (efi.acpi20)
+			status = acpi_cf_init((void *)efi.acpi20);
+		else
+			status = acpi_cf_init((void *)efi.acpi);
 		if (ACPI_FAILURE (status))
 			return status;
 	}
@@ -146,7 +149,7 @@
 } acpi_rpb_t;
 
 
-static acpi_status	__init
+acpi_status	__init
 acpi_cf_evaluate_method (
 	acpi_handle	handle,
 	UINT8		*method_name,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/events/evevent.c linux/drivers/acpi/events/evevent.c
--- ../ia64/linux/drivers/acpi/events/evevent.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/events/evevent.c	Thu May  9 01:30:42 2002
@@ -378,6 +378,20 @@
 
 	MEMSET (acpi_gbl_gpe_valid, (int) ACPI_GPE_INVALID, ACPI_NUM_GPE);
 
+	if (MUL_8 (gpe0register_count) != acpi_gbl_FADT->gpe1_base) {
+		printk("ACPI: GPE1 events not contiguous with GPE0 events\n");
+		printk("ACPI: %d GPE0 events, GPE1 base %d\n",
+			MUL_8 (gpe0register_count), acpi_gbl_FADT->gpe1_base);
+		printk("ACPI: All GPEs being ignored\n");
+		/*
+		 * Returning error causes MCA, so return success but
+		 * leave all events marked GPE_INVALID.  ACPI 20020419
+		 * handles non-contiguous GPE1 events correctly, so
+		 * this hack won't be needed in the future.
+		 */
+		return_ACPI_STATUS (AE_OK);
+	}
+
 	/*
 	 * Initialize the Gpe information and validation blocks.  A goal of these
 	 * blocks is to hide the fact that there are two separate GPE register sets
@@ -390,11 +404,15 @@
 	register_index = 0;
 
 	for (i = 0; i < gpe0register_count; i++) {
-		acpi_gbl_gpe_registers[register_index].status_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) + i);
+		MEMCPY(&acpi_gbl_gpe_registers[register_index].status_addr,
+		       &acpi_gbl_FADT->Xgpe0blk, sizeof(acpi_generic_address));
 
-		acpi_gbl_gpe_registers[register_index].enable_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) + i + gpe0register_count);
+		acpi_gbl_gpe_registers[register_index].status_addr.address += i;
+
+		MEMCPY(&acpi_gbl_gpe_registers[register_index].enable_addr,
+		       &acpi_gbl_FADT->Xgpe0blk, sizeof(acpi_generic_address));
+
+		acpi_gbl_gpe_registers[register_index].enable_addr.address += (i + gpe0register_count);
 
 		acpi_gbl_gpe_registers[register_index].gpe_base = (u8) MUL_8 (i);
 
@@ -408,8 +426,8 @@
 		 * are cleared by writing a '1', while enable registers are cleared
 		 * by writing a '0'.
 		 */
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr, 0x00, 8);
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].status_addr, 0xFF, 8);
+		acpi_hw_low_level_write (8, 0x00, &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
+		acpi_hw_low_level_write (8, 0xFF, &acpi_gbl_gpe_registers[register_index].status_addr, 0);
 
 		register_index++;
 	}
@@ -417,11 +435,15 @@
 	/* GPE Block 1 */
 
 	for (i = 0; i < gpe1_register_count; i++) {
-		acpi_gbl_gpe_registers[register_index].status_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) + i);
+		MEMCPY(&acpi_gbl_gpe_registers[register_index].status_addr,
+		       &acpi_gbl_FADT->Xgpe1_blk, sizeof(acpi_generic_address));
+
+		acpi_gbl_gpe_registers[register_index].status_addr.address += i;
+
+		MEMCPY(&acpi_gbl_gpe_registers[register_index].enable_addr,
+		       &acpi_gbl_FADT->Xgpe1_blk, sizeof(acpi_generic_address));
 
-		acpi_gbl_gpe_registers[register_index].enable_addr =
-				 (u16) (ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) + i + gpe1_register_count);
+		acpi_gbl_gpe_registers[register_index].enable_addr.address += (i + gpe1_register_count);
 
 		acpi_gbl_gpe_registers[register_index].gpe_base =
 				 (u8) (acpi_gbl_FADT->gpe1_base + MUL_8 (i));
@@ -436,8 +458,8 @@
 		 * are cleared by writing a '1', while enable registers are cleared
 		 * by writing a '0'.
 		 */
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr, 0x00, 8);
-		acpi_os_write_port (acpi_gbl_gpe_registers[register_index].status_addr, 0xFF, 8);
+		acpi_hw_low_level_write (8, 0x00, &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
+		acpi_hw_low_level_write (8, 0xFF, &acpi_gbl_gpe_registers[register_index].status_addr, 0);
 
 		register_index++;
 	}
@@ -620,11 +642,11 @@
 	 * Find all currently active GP events.
 	 */
 	for (i = 0; i < acpi_gbl_gpe_register_count; i++) {
-		acpi_os_read_port (acpi_gbl_gpe_registers[i].status_addr,
-				&acpi_gbl_gpe_registers[i].status, 8);
+		acpi_gbl_gpe_registers[i].status = acpi_hw_low_level_read (8,
+				&acpi_gbl_gpe_registers[i].status_addr, 0);
 
-		acpi_os_read_port (acpi_gbl_gpe_registers[i].enable_addr,
-				&acpi_gbl_gpe_registers[i].enable, 8);
+		acpi_gbl_gpe_registers[i].enable = acpi_hw_low_level_read (8,
+				&acpi_gbl_gpe_registers[i].enable_addr, 0);
 
 		ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
 			"GPE block at %X - Enable %08X Status %08X\n",
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/events/evrgnini.c linux/drivers/acpi/events/evrgnini.c
--- ../ia64/linux/drivers/acpi/events/evrgnini.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/events/evrgnini.c	Fri Jan 25 14:35:05 2002
@@ -222,15 +222,13 @@
 		 * Node is currently the parent object
 		 */
 		while (node != acpi_gbl_root_node) {
-			status = acpi_ut_execute_HID (node, &object_hID);
-			if (ACPI_SUCCESS (status)) {
-				if (!(STRNCMP (object_hID.buffer, PCI_ROOT_HID_STRING,
-						   sizeof (PCI_ROOT_HID_STRING)))) {
-					acpi_install_address_space_handler (node,
-							   ACPI_ADR_SPACE_PCI_CONFIG,
-							   ACPI_DEFAULT_HANDLER, NULL, NULL);
-					break;
-				}
+			STRNCPY(object_hID.buffer, PCI_ROOT_HID_STRING, sizeof(acpi_device_id));
+			status = acpi_ut_match_PNP_ID (node, &object_hID);
+			if (status == AE_OK) {
+				acpi_install_address_space_handler (node,
+						   ACPI_ADR_SPACE_PCI_CONFIG,
+						   ACPI_DEFAULT_HANDLER, NULL, NULL);
+				break;
 			}
 
 			node = acpi_ns_get_parent_object (node);
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/hardware/hwacpi.c linux/drivers/acpi/hardware/hwacpi.c
--- ../ia64/linux/drivers/acpi/hardware/hwacpi.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/hardware/hwacpi.c	Fri Jan 25 14:35:05 2002
@@ -202,6 +202,13 @@
 	FUNCTION_TRACE ("Hw_set_mode");
 
 
+	if (mode == acpi_hw_get_mode())
+		return_ACPI_STATUS (AE_OK);
+
+	/* If no SMI_CMD, system does not support SMI */
+	if (!acpi_gbl_FADT->smi_cmd)
+		return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+
 	if (mode == SYS_MODE_ACPI) {
 		/* BIOS should have disabled ALL fixed and GP events */
 
@@ -210,6 +217,11 @@
 	}
 
 	else if (mode == SYS_MODE_LEGACY) {
+
+		/* If both enable/disable are zero, legacy mode is not supported */
+		if (!acpi_gbl_FADT->acpi_enable && !acpi_gbl_FADT->acpi_disable)
+			return_ACPI_STATUS (AE_NO_HARDWARE_RESPONSE);
+			
 		/*
 		 * BIOS should clear all fixed status bits and restore fixed event
 		 * enable bits to default
@@ -259,6 +271,18 @@
 		return_VALUE (SYS_MODE_ACPI);
 	}
 	else {
+#ifdef CONFIG_IA64_HP_PROTO
+		/*
+ 		 * If enable/disable are zero, the system doesn't support
+		 * legacy mode, so the SCI_EN is wrong.
+ 		 */
+		if (!acpi_gbl_FADT->acpi_enable &&
+		    !acpi_gbl_FADT->acpi_disable) {
+			printk("Warning: Ignoring bogus SCI_EN value\n");
+			return_VALUE (SYS_MODE_ACPI);
+		}
+#endif
+
 		return_VALUE (SYS_MODE_LEGACY);
 	}
 }
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/hardware/hwgpe.c linux/drivers/acpi/hardware/hwgpe.c
--- ../ia64/linux/drivers/acpi/hardware/hwgpe.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/hardware/hwgpe.c	Fri Jan 25 14:35:05 2002
@@ -72,9 +72,8 @@
 	 * to enable the GPE, and write out the new register.
 	 */
 	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].enable_addr, &in_byte, 8);
-	acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr,
-			   (in_byte | bit_mask), 8);
+	in_byte = acpi_hw_low_level_read (8, &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
+	acpi_hw_low_level_write (8, (in_byte | bit_mask), &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
 }
 
 /******************************************************************************
@@ -156,9 +155,8 @@
 	 * and write out the new register value to disable the GPE.
 	 */
 	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].enable_addr, &in_byte, 8);
-	acpi_os_write_port (acpi_gbl_gpe_registers[register_index].enable_addr,
-			 (in_byte & ~bit_mask), 8);
+	in_byte = acpi_hw_low_level_read (8, &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
+	acpi_hw_low_level_write (8, (in_byte & ~bit_mask), &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
 
 	acpi_hw_disable_gpe_for_wakeup(gpe_number);
 }
@@ -240,7 +238,7 @@
 	 * Write a one to the appropriate bit in the status register to
 	 * clear this GPE.
 	 */
-	acpi_os_write_port (acpi_gbl_gpe_registers[register_index].status_addr, bit_mask, 8);
+	acpi_hw_low_level_write (8, bit_mask, &acpi_gbl_gpe_registers[register_index].status_addr, 0);
 }
 
 
@@ -289,7 +287,7 @@
 	 * Enabled?:
 	 */
 	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].enable_addr, &in_byte, 8);
+	in_byte = acpi_hw_low_level_read (8, &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
 	if (bit_mask & in_byte) {
 		(*event_status) |= ACPI_EVENT_FLAG_ENABLED;
 	}
@@ -305,7 +303,7 @@
 	 * Set?
 	 */
 	in_byte = 0;
-	acpi_os_read_port (acpi_gbl_gpe_registers[register_index].status_addr, &in_byte, 8);
+	in_byte = acpi_hw_low_level_read (8, &acpi_gbl_gpe_registers[register_index].enable_addr, 0);
 	if (bit_mask & in_byte) {
 		(*event_status) |= ACPI_EVENT_FLAG_SET;
 	}
@@ -340,14 +338,12 @@
 		 * Read the enabled status of all GPEs. We
 		 * will be using it to restore all the GPEs later.
 		 */
-		acpi_os_read_port (acpi_gbl_gpe_registers[i].enable_addr,
-				&acpi_gbl_gpe_registers[i].enable, 8);
+		acpi_gbl_gpe_registers[i].enable = acpi_hw_low_level_read (8, &acpi_gbl_gpe_registers[i].enable_addr, 0);
 
 		/*
 		 * Disable all GPEs but wakeup GPEs.
 		 */
-		acpi_os_write_port(acpi_gbl_gpe_registers[i].enable_addr,
-				acpi_gbl_gpe_registers[i].wake_enable, 8);
+		acpi_hw_low_level_write (8, acpi_gbl_gpe_registers[i].wake_enable, &acpi_gbl_gpe_registers[i].enable_addr, 0);
 	}
 }
 
@@ -376,7 +372,6 @@
 		 * We previously stored the enabled status of all GPEs.
 		 * Blast them back in.
 		 */
-		acpi_os_write_port(acpi_gbl_gpe_registers[i].enable_addr,
-				acpi_gbl_gpe_registers[i].enable, 8);
+		acpi_hw_low_level_write(8, acpi_gbl_gpe_registers[i].enable, &acpi_gbl_gpe_registers[i].enable_addr, 0);
 	}
 }
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/hardware/hwregs.c linux/drivers/acpi/hardware/hwregs.c
--- ../ia64/linux/drivers/acpi/hardware/hwregs.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/hardware/hwregs.c	Fri Jan 25 14:35:05 2002
@@ -80,6 +80,7 @@
 {
 	u16                     gpe_length;
 	u16                     index;
+	acpi_generic_address    reg;
 
 
 	FUNCTION_TRACE ("Hw_clear_acpi_status");
@@ -96,30 +97,29 @@
 
 
 	if (ACPI_VALID_ADDRESS (acpi_gbl_FADT->Xpm1b_evt_blk.address)) {
-		acpi_os_write_port ((ACPI_IO_ADDRESS)
-			ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm1b_evt_blk.address),
-			ALL_FIXED_STS_BITS, 16);
+		acpi_hw_low_level_write (16, ALL_FIXED_STS_BITS,
+		                         &acpi_gbl_FADT->Xpm1b_evt_blk, 0);
 	}
 
 	/* now clear the GPE Bits */
 
 	if (acpi_gbl_FADT->gpe0blk_len) {
 		gpe_length = (u16) DIV_2 (acpi_gbl_FADT->gpe0blk_len);
+		MEMCPY(&reg, &acpi_gbl_FADT->Xgpe0blk, sizeof(acpi_generic_address));
 
 		for (index = 0; index < gpe_length; index++) {
-			acpi_os_write_port ((ACPI_IO_ADDRESS) (
-				ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe0blk.address) + index),
-					0xFF, 8);
+			reg.address = acpi_gbl_FADT->Xgpe0blk.address + index;
+			acpi_hw_low_level_write (8, 0xFF, &reg, 0);
 		}
 	}
 
 	if (acpi_gbl_FADT->gpe1_blk_len) {
 		gpe_length = (u16) DIV_2 (acpi_gbl_FADT->gpe1_blk_len);
+		MEMCPY(&reg, &acpi_gbl_FADT->Xgpe1_blk, sizeof(acpi_generic_address));
 
 		for (index = 0; index < gpe_length; index++) {
-			acpi_os_write_port ((ACPI_IO_ADDRESS) (
-				ACPI_GET_ADDRESS (acpi_gbl_FADT->Xgpe1_blk.address) + index),
-				0xFF, 8);
+			reg.address = acpi_gbl_FADT->Xgpe1_blk.address + index;
+			acpi_hw_low_level_write (8, 0xFF, &reg, 0);
 		}
 	}
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/hardware/hwtimer.c linux/drivers/acpi/hardware/hwtimer.c
--- ../ia64/linux/drivers/acpi/hardware/hwtimer.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/hardware/hwtimer.c	Fri Jan 25 14:35:05 2002
@@ -89,8 +89,7 @@
 		return_ACPI_STATUS (AE_BAD_PARAMETER);
 	}
 
-	acpi_os_read_port ((ACPI_IO_ADDRESS)
-		ACPI_GET_ADDRESS (acpi_gbl_FADT->Xpm_tmr_blk.address), ticks, 32);
+	*ticks = acpi_hw_low_level_read (32, &acpi_gbl_FADT->Xpm_tmr_blk, 0);
 
 	return_ACPI_STATUS (AE_OK);
 }
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/include/aclocal.h linux/drivers/acpi/include/aclocal.h
--- ../ia64/linux/drivers/acpi/include/aclocal.h	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/include/aclocal.h	Fri Jan 25 14:35:05 2002
@@ -353,8 +353,8 @@
 
 typedef struct
 {
-	u16                     status_addr;    /* Address of status reg */
-	u16                     enable_addr;    /* Address of enable reg */
+	acpi_generic_address    status_addr;    /* Address of status reg */
+	acpi_generic_address    enable_addr;    /* Address of enable reg */
 	u8                      status;         /* Current value of status reg */
 	u8                      enable;         /* Current value of enable reg */
 	u8                      wake_enable;    /* Mask of bits to keep enabled when sleeping */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/include/acutils.h linux/drivers/acpi/include/acutils.h
--- ../ia64/linux/drivers/acpi/include/acutils.h	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/include/acutils.h	Fri Jan 25 14:35:05 2002
@@ -410,6 +410,11 @@
 	acpi_device_id          *hid);
 
 acpi_status
+acpi_ut_match_PNP_ID (
+	acpi_namespace_node     *device_node,
+	acpi_device_id          *pnpid);
+
+acpi_status
 acpi_ut_execute_STA (
 	acpi_namespace_node     *device_node,
 	u32                     *status_flags);
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/namespace/nsxfobj.c linux/drivers/acpi/namespace/nsxfobj.c
--- ../ia64/linux/drivers/acpi/namespace/nsxfobj.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/namespace/nsxfobj.c	Fri Jan 25 14:35:05 2002
@@ -576,10 +576,13 @@
 	}
 
 	/*
-	 * Filter based on device HID
+	 * Filter based on device HID/CID
 	 */
 	if (info->hid != NULL) {
-		status = acpi_ut_execute_HID (node, &device_id);
+
+		STRNCPY(device_id.buffer, info->hid, sizeof(acpi_device_id));
+
+		status = acpi_ut_match_PNP_ID (node, &device_id);
 		if (status == AE_NOT_FOUND) {
 			return (AE_OK);
 		}
@@ -587,23 +590,10 @@
 		else if (ACPI_FAILURE (status)) {
 			return (AE_CTRL_DEPTH);
 		}
-
-		if (STRNCMP (device_id.buffer, info->hid, sizeof (device_id.buffer)) != 0) {
-			status = acpi_ut_execute_CID (node, &compatible_id);
-			if (status == AE_NOT_FOUND) {
-				return (AE_OK);
-			}
-			else if (ACPI_FAILURE (status)) {
-				return (AE_CTRL_DEPTH);
-			}
-
-			if (STRNCMP (compatible_id.buffer, info->hid, sizeof (compatible_id.buffer)) != 0) {
-				return (AE_OK);
-			}
-		}
 	}
 
 	info->user_function (obj_handle, nesting_level, info->context, return_value);
+
 	return (AE_OK);
 }
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/os.c linux/drivers/acpi/os.c
--- ../ia64/linux/drivers/acpi/os.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/os.c	Fri May  3 01:30:42 2002
@@ -168,7 +168,7 @@
 void *
 acpi_os_allocate_rt(u32 size)
 {
-	return kmalloc(size, GFP_KERNEL);
+	return kmalloc(size, in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
 }
 
 void *
@@ -198,9 +198,9 @@
 	}
 #else /*CONFIG_ACPI_EFI*/
 	if (efi.acpi20)
-		*phys_addr = (ACPI_PHYSICAL_ADDRESS) efi.acpi20;
+		*phys_addr = (ACPI_PHYSICAL_ADDRESS) virt_to_phys(efi.acpi20);
 	else if (efi.acpi)
-		*phys_addr = (ACPI_PHYSICAL_ADDRESS) efi.acpi;
+		*phys_addr = (ACPI_PHYSICAL_ADDRESS) virt_to_phys(efi.acpi);
 	else {
 		printk(KERN_ERR "ACPI: System description tables not found\n");
 		*phys_addr = NULL;
@@ -214,12 +214,20 @@
 acpi_status
 acpi_os_map_memory(ACPI_PHYSICAL_ADDRESS phys, u32 size, void **virt)
 {
+#ifdef CONFIG_ACPI_EFI
+	if ((EFI_MEMORY_WB & efi_mem_attributes(phys)) == 0) {
+		*virt = ioremap(phys, size);
+	} else {
+		*virt = phys_to_virt(phys);
+	}
+#else
 	if (phys > ULONG_MAX) {
 		printk(KERN_ERR "ACPI: Cannot map memory that high\n");
 		return AE_ERROR;
 	}
 
 	*virt = ioremap((unsigned long) phys, size);
+#endif
 	if (!*virt)
 		return AE_ERROR;
 
@@ -272,7 +280,15 @@
 
 	act = & acpiirqaction;
 
-	irq = isa_irq_to_vector(irq);
+	irq = gsi_irq_to_vector(irq);
+	if (!irq) {
+		/*
+		 * This return value probably needs revisited, this makes
+		 * things coninue to work.
+		 */
+		return AE_OK;
+	}
+
 	acpi_irq_irq = irq;
 	acpi_irq_handler = handler;
 	acpi_irq_context = context;
@@ -305,7 +321,7 @@
 	if (!acpi_irq_handler)
 		return AE_OK;
 
-	irq = isa_irq_to_vector(irq);
+	irq = gsi_irq_to_vector(irq);
 	if (irq != acpi_irq_irq) return AE_ERROR;
 
 	acpi_irq_handler = NULL;
@@ -460,6 +476,17 @@
 	u32			width)
 {
 	u32 dummy;
+	void* addr;
+
+#ifndef CONFIG_ACPI_EFI
+	addr = phys_to_virt(phys_addr);
+#else
+	if (EFI_MEMORY_UC & efi_mem_attributes(phys_addr)) {
+		addr = ioremap(phys_addr,width);
+	} else {
+		addr = phys_to_virt(phys_addr);
+	}
+#endif /* CONFIG_ACPI_EFI */
 
 	if (!value)
 		value = &dummy;
@@ -467,13 +494,13 @@
 	switch (width)
 	{
 	case 8:
-		*(u8*) value = *(u8*) phys_to_virt(phys_addr);
+		*(u8*) value = *(u8*) addr;
 		break;
 	case 16:
-		*(u16*) value = *(u16*) phys_to_virt(phys_addr);
+		*(u16*) value = *(u16*) addr;
 		break;
 	case 32:
-		*(u32*) value = *(u32*) phys_to_virt(phys_addr);
+		*(u32*) value = *(u32*) addr;
 		break;
 	default:
 		BUG();
@@ -488,16 +515,29 @@
 	NATIVE_UINT		value,
 	u32			width)
 {
+
+	void* addr;
+
+#ifndef CONFIG_ACPI_EFI
+	addr = phys_to_virt(phys_addr);
+#else
+	if (EFI_MEMORY_UC & efi_mem_attributes(phys_addr)) {
+		addr = ioremap(phys_addr,width);
+	} else {
+		addr = phys_to_virt(phys_addr);
+	}
+#endif /* CONFIG_ACPI_EFI */
+
 	switch (width)
 	{
 	case 8:
-		*(u8*) phys_to_virt(phys_addr) = value;
+		*(u8*) (addr) = value;
 		break;
 	case 16:
-		*(u16*) phys_to_virt(phys_addr) = value;
+		*(u16*) (addr) = value;
 		break;
 	case 32:
-		*(u32*) phys_to_virt(phys_addr) = value;
+		*(u32*) (addr) = value;
 		break;
 	default:
 		BUG();
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/ospm/button/bn.c linux/drivers/acpi/ospm/button/bn.c
--- ../ia64/linux/drivers/acpi/ospm/button/bn.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/ospm/button/bn.c	Mon Apr  8 19:31:18 2002
@@ -391,7 +391,7 @@
  *
  ****************************************************************************/
 
-acpi_status
+u32
 bn_notify_fixed (
 	void			*context)
 {
@@ -408,7 +408,7 @@
 	status = bn_osl_generate_event(BN_NOTIFY_STATUS_CHANGE,
 		((BN_CONTEXT*)context));
 
-	return_ACPI_STATUS(status);
+	return (status == AE_OK ? INTERRUPT_HANDLED : INTERRUPT_NOT_HANDLED);
 }
 
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/ospm/include/bn.h linux/drivers/acpi/ospm/include/bn.h
--- ../ia64/linux/drivers/acpi/ospm/include/bn.h	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/ospm/include/bn.h	Mon Apr  8 19:31:19 2002
@@ -88,7 +88,7 @@
 acpi_status
 bn_terminate (void);
 
-acpi_status
+u32
 bn_notify_fixed (
 	void			*context);
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/resources/rsirq.c linux/drivers/acpi/resources/rsirq.c
--- ../ia64/linux/drivers/acpi/resources/rsirq.c	Fri Jan 25 13:11:14 2002
+++ linux/drivers/acpi/resources/rsirq.c	Fri Jan 25 14:35:05 2002
@@ -316,28 +316,16 @@
 	output_struct->data.extended_irq.producer_consumer = temp8 & 0x01;
 
 	/*
-	 * Check for HE, LL or HL
+	 * Check interrupt mode
+	 *  - Edge/Level are defined opposite in the table vs the headers
 	 */
-	if(temp8 & 0x02) {
-		output_struct->data.extended_irq.edge_level = EDGE_SENSITIVE;
-		output_struct->data.extended_irq.active_high_low = ACTIVE_HIGH;
-	}
+	output_struct->data.extended_irq.edge_level =
+	                      (temp8 & 0x2) ? EDGE_SENSITIVE : LEVEL_SENSITIVE;
 
-	else {
-		if(temp8 & 0x4) {
-			output_struct->data.extended_irq.edge_level = LEVEL_SENSITIVE;
-			output_struct->data.extended_irq.active_high_low = ACTIVE_LOW;
-		}
-
-		else {
-			/*
-			 * Only _LL and _HE polarity/trigger interrupts
-			 * are allowed (ACPI spec v1.0b ection 6.4.2.1),
-			 * so an error will occur if we reach this point
-			 */
-			return_ACPI_STATUS (AE_BAD_DATA);
-		}
-	}
+	/*
+	 * Check interrupt polarity
+	 */
+	output_struct->data.extended_irq.active_high_low = (temp8 >> 2) & 0x1;
 
 	/*
 	 * Check for sharable
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/acpi/utilities/uteval.c linux/drivers/acpi/utilities/uteval.c
--- ../ia64/linux/drivers/acpi/utilities/uteval.c	Fri Jan 25 13:11:15 2002
+++ linux/drivers/acpi/utilities/uteval.c	Fri Jan 25 14:35:05 2002
@@ -376,6 +376,90 @@
 	return (status);
 }
 
+/*******************************************************************************
+ *
+ * FUNCTION:    Acpi_ut_match_PNP_ID
+ *
+ * PARAMETERS:  Device_node         - Node for the device
+ *              *PNPID              - Device ID to match
+ *
+ * RETURN:      AE_OK = node matches id
+ *
+ * DESCRIPTION: Matches PNP ID to node based on _HID and _CID method data
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+acpi_status
+acpi_ut_match_PNP_ID (
+	acpi_namespace_node     *device_node,
+	acpi_device_id		*pnpid)
+{
+	acpi_device_id		device_id;
+	acpi_status		status;
+	acpi_operand_object     *obj_desc, *obj_ptr;
+	u32						i;
+	
+	FUNCTION_TRACE ("Ut_match_PNP_ID");
+
+	status = acpi_ut_execute_HID(device_node, &device_id);
+
+	if (ACPI_SUCCESS(status)) {
+		if (!STRNCMP(device_id.buffer, pnpid->buffer, sizeof(acpi_device_id)))
+			return AE_OK;
+	}
+
+	status = acpi_ns_evaluate_relative (device_node, METHOD_NAME__CID, NULL, &obj_desc);
+
+	if (ACPI_FAILURE (status) || (obj_desc == NULL)) {
+		return AE_NOT_FOUND;
+	}
+			
+	status = AE_NOT_FOUND;
+
+	switch (obj_desc->common.type) {
+		
+		case ACPI_TYPE_INTEGER:
+			acpi_ex_eisa_id_to_string ((u32) obj_desc->integer.value, device_id.buffer);
+			if (!STRNCMP(device_id.buffer, pnpid->buffer, sizeof(acpi_device_id)))
+				status = AE_OK;
+			break;
+		
+		case ACPI_TYPE_STRING:
+			if (!STRNCMP(obj_desc->string.pointer, pnpid->buffer, sizeof(acpi_device_id)))
+				status = AE_OK;
+			break;
+		
+		case ACPI_TYPE_PACKAGE:
+			for (i = 0 ; i < obj_desc->package.count ; i++) {
+				obj_ptr = obj_desc->package.elements[i];
+				
+				switch (obj_ptr->common.type) {
+					case ACPI_TYPE_INTEGER:
+						acpi_ex_eisa_id_to_string ((u32) obj_ptr->integer.value, device_id.buffer);
+						if (!STRNCMP(device_id.buffer, pnpid->buffer, sizeof(acpi_device_id)))
+							status = AE_OK;
+						break;
+		
+					case ACPI_TYPE_STRING:
+						if (!STRNCMP(obj_ptr->string.pointer, pnpid->buffer, sizeof(acpi_device_id)))
+							status = AE_OK;
+						break;
+						
+					default:
+						break;
+				}
+			}
+		
+		default:
+			break;
+	}
+
+	acpi_ut_remove_reference (obj_desc);	
+	return (status);
+		
+}
+
 
 /*******************************************************************************
  *
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/Config.in linux/drivers/char/Config.in
--- ../ia64/linux/drivers/char/Config.in	Fri Jan 25 13:11:15 2002
+++ linux/drivers/char/Config.in	Tue Mar 26 01:02:39 2002
@@ -17,7 +17,10 @@
    fi
 fi
 if [ "$CONFIG_ACPI" = "y" ]; then
-   bool '  Support for serial ports defined by ACPI tables' CONFIG_SERIAL_ACPI
+   tristate '  Support for serial ports defined by ACPI tables' CONFIG_SERIAL_ACPI
+   if [ "$CONFIG_SERIAL_ACPI" != "n" ]; then
+	bool '    Enable Auto serial console detection using EFI console variables' CONFIG_SERIAL_ACPI_CONSOLE_DETECT
+   fi
 fi
 dep_mbool 'Extended dumb serial driver options' CONFIG_SERIAL_EXTENDED $CONFIG_SERIAL
 if [ "$CONFIG_SERIAL_EXTENDED" = "y" ]; then
@@ -211,9 +214,8 @@
 dep_tristate '/dev/agpgart (AGP Support)' CONFIG_AGP $CONFIG_DRM_AGP
 if [ "$CONFIG_AGP" != "n" ]; then
    bool '  Intel 440LX/BX/GX and I815/I830M/I840/I850 support' CONFIG_AGP_INTEL
-   if [ "$CONFIG_IA64" != "n" ]; then
-   	bool '  Intel 460GX support' CONFIG_AGP_I460
-   fi
+   dep_bool '  Intel 460GX support' CONFIG_AGP_I460 $CONFIG_IA64
+   dep_bool '  HP ZX1 AGP support' CONFIG_AGP_HP_ZX1 $CONFIG_IA64
    bool '  Intel I810/I815/I830M (on-board) support' CONFIG_AGP_I810
    bool '  VIA chipset support' CONFIG_AGP_VIA
    bool '  AMD Irongate, 761, and 762 support' CONFIG_AGP_AMD
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/acpi_serial.c linux/drivers/char/acpi_serial.c
--- ../ia64/linux/drivers/char/acpi_serial.c	Fri Jan 25 13:11:15 2002
+++ linux/drivers/char/acpi_serial.c	Wed Feb 27 16:54:50 2002
@@ -12,15 +12,204 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/pm.h>
-#include <linux/acpi.h>
 #include <linux/init.h>
 #include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
 #include <asm/serial.h>
 #include <asm/io.h>
+#include <asm/efi.h>
 #include <linux/acpi_serial.h>
-/*#include <asm/acpi-ext.h>*/
+
+extern char saved_command_line[];
 
 #undef SERIAL_DEBUG_ACPI
+#ifdef CONFIG_IA64_HP_PROTO
+int acpi_base_baud = 0;
+int acpi_autoconf_flag = ASYNC_BOOT_AUTOCONF;
+#endif
+
+static int efi_cons_in = -1;
+static int efi_cons_out = -1;
+
+static unsigned char efi_data[1024];
+static efi_char16_t variable_name[128];
+static unsigned char varname[sizeof(variable_name)/sizeof(variable_name[0])];
+
+/* compiled in serial ports */
+extern struct serial_state rs_table[];
+extern int serial_nr_ports;
+
+static inline unsigned int serial_in(struct async_struct *info, int offset)
+{
+	switch (info->io_type) {
+#ifdef CONFIG_HUB6
+	case SERIAL_IO_HUB6:
+		outb(info->hub6 - 1 + offset, info->port);
+		return inb(info->port+1);
+#endif
+	case SERIAL_IO_MEM:
+		return readb((unsigned long) info->iomem_base +
+			     (offset<<info->iomem_reg_shift));
+#ifdef CONFIG_SERIAL_GSC
+	case SERIAL_IO_GSC:
+		return gsc_readb(info->iomem_base + offset);
+#endif
+	default:
+		return inb(info->port + offset);
+	}
+}
+
+static inline void serial_out(struct async_struct *info, int offset,
+				int value)
+{
+	switch (info->io_type) {
+#ifdef CONFIG_HUB6
+	case SERIAL_IO_HUB6:
+		outb(info->hub6 - 1 + offset, info->port);
+		outb(value, info->port+1);
+		break;
+#endif
+	case SERIAL_IO_MEM:
+		writeb(value, (unsigned long) info->iomem_base +
+			      (offset<<info->iomem_reg_shift));
+		break;
+#ifdef CONFIG_SERIAL_GSC
+	case SERIAL_IO_GSC:
+		gsc_writeb(value, info->iomem_base + offset);
+		break;
+#endif
+	default:
+		outb(value, info->port+offset);
+	}
+}
+
+#define serial_inp(info, offset)		serial_in(info, offset)
+#define serial_outp(info, offset, value)	serial_out(info, offset, value)
+
+static int detect_port(struct serial_state * state)
+{
+	unsigned char scratch, scratch2, scratch3;
+	struct async_struct *info, scr_info;
+	unsigned long flags;
+
+	state->type = PORT_UNKNOWN;
+
+#ifdef SERIAL_DEBUG_ACPI
+	printk("acpi_serial: Testing ttyS%d (0x%04lx, 0x%04x)...\n", state->line,
+	       state->port, (unsigned) state->iomem_base);
+#endif
+	
+	if (!CONFIGURED_SERIAL_PORT(state))
+		return 0;
+		
+	info = &scr_info;	/* This is just for serial_{in,out} */
+
+	info->magic = SERIAL_MAGIC;
+	info->state = state;
+	info->port = state->port;
+	info->flags = state->flags;
+#ifdef CONFIG_HUB6
+	info->hub6 = state->hub6;
+#endif
+	info->io_type = state->io_type;
+	info->iomem_base = state->iomem_base;
+	info->iomem_reg_shift = state->iomem_reg_shift;
+
+	save_flags(flags); cli();
+	
+	if (!(state->flags & ASYNC_BUGGY_UART) &&
+	    !state->iomem_base) {
+		/*
+		 * Do a simple existence test first; if we fail this,
+		 * there's no point trying anything else.
+		 * 
+		 * 0x80 is used as a nonsense port to prevent against
+		 * false positives due to ISA bus float.  The
+		 * assumption is that 0x80 is a non-existent port;
+		 * which should be safe since include/asm/io.h also
+		 * makes this assumption.
+		 */
+		scratch = serial_inp(info, UART_IER);
+		serial_outp(info, UART_IER, 0);
+#ifdef __i386__
+		outb(0xff, 0x080);
+#endif
+		scratch2 = serial_inp(info, UART_IER);
+		serial_outp(info, UART_IER, 0x0F);
+#ifdef __i386__
+		outb(0, 0x080);
+#endif
+		scratch3 = serial_inp(info, UART_IER);
+		serial_outp(info, UART_IER, scratch);
+		if (scratch2 || scratch3 != 0x0F) {
+#ifdef SERIAL_DEBUG_ACPI
+			printk("acpi_serial: ttyS%d: simple detection failed "
+			       "(%02x, %02x)\n", state->line, 
+			       scratch2, scratch3);
+#endif
+			restore_flags(flags);
+			return 0;		/* We failed; there's nothing here */
+		}
+	}
+	return 1;
+}
+
+/*
+ * Parse an EFI device path
+ */
+static __init efi_uart_path_t *parse_efi_path(int size, unsigned char *data)
+{
+	efi_device_path_t *efi_dev;
+	efi_uart_path_t *uart_path = (efi_uart_path_t *) NULL;
+#ifdef SERIAL_DEBUG_ACPI
+	int i, j;
+#endif
+
+#ifdef SERIAL_DEBUG_ACPI
+	printk("    Size=       %d\n", size);
+#endif
+	/* Check for bogus data */
+	if (size > 200) {
+		return uart_path;
+	}
+
+	while (size) {
+		efi_dev = (efi_device_path_t *) data;
+#ifdef SERIAL_DEBUG_ACPI
+		printk("    Type =	0x%x\n", efi_dev->type);
+		printk("    Subtype =	0x%x\n", efi_dev->subtype);
+		printk("    Len =	%d\n", efi_dev->len);
+#endif
+		if (efi_dev->len > size)
+			return uart_path;
+#ifdef SERIAL_DEBUG_ACPI
+		printk("    Data = ");
+		for (i=4; i<efi_dev->len; i +=8) {
+			for (j=i; j<(i+8) && j<efi_dev->len; j++) {
+				printk("0x%x ", data[j]);
+			}
+			printk("\n       ");
+		}
+		printk("\n");
+#endif
+
+		/* Is it a UART path? */
+		if ((efi_dev->type == 3) && (efi_dev->subtype == 14)) {
+			uart_path = (efi_uart_path_t *)data;
+#ifdef SERIAL_DEBUG_ACPI
+			printk("    Port setting = %d, %x, %x, %x\n", 
+					uart_path->baud, uart_path->bits,
+					uart_path->parity, uart_path->stop);
+#endif
+		}
+
+		/* Move to the next path */
+		size -= efi_dev->len;
+		data += efi_dev->len;
+	}
+	return uart_path;
+}
 
 /*
  * Query ACPI tables for a debug and a headless console serial
@@ -38,6 +227,15 @@
 	struct serial_struct serial_req;
 	unsigned long iobase;
 	int global_sys_irq;
+	unsigned long variable_name_size;
+	efi_guid_t vendor_guid;
+	efi_status_t status;
+	__u32 attributes;
+	unsigned long size;
+	int i;
+	efi_uart_path_t *uart_path = NULL;
+	struct serial_state * state;
+
 
 #ifdef SERIAL_DEBUG_ACPI
 	printk("Entering setup_serial_acpi()\n");
@@ -81,7 +279,7 @@
 	printk("                     length = %d\n", acpi_ser_p->length);
 	printk("                     Rev = %d\n", acpi_ser_p->rev);
 	printk("                     Interface type = %d\n", acpi_ser_p->intfc_type);
-	printk("                     Base address = 0x%lX\n", iobase);
+	printk("                     Base address = 0x%p\n", iobase);
 	printk("                     IRQ = %d\n", acpi_ser_p->irq);
 	printk("                     Global System Int = %d\n", global_sys_irq);
 	printk("                     Baud rate = ");
@@ -123,25 +321,25 @@
  		case ACPI_SERIAL_INTFC_16550:
 			serial_req.type = PORT_16550;
 			serial_req.baud_base = BASE_BAUD;
+#ifdef CONFIG_IA64_HP_PROTO
+			if (acpi_base_baud)
+				serial_req.baud_base = acpi_base_baud;
+#endif
 			break;
 
  		case ACPI_SERIAL_INTFC_16450:
 			serial_req.type = PORT_16450;
 			serial_req.baud_base = BASE_BAUD;
+#ifdef CONFIG_IA64_HP_PROTO
+			if (acpi_base_baud)
+				serial_req.baud_base = acpi_base_baud;
+#endif
 			break;
 
 		default:
 			serial_req.type = PORT_UNKNOWN;
 			break;
 	}
-	if (strncmp(acpi_ser_p->signature, ACPI_SPCRT_SIGNATURE,
-					ACPI_SIG_LEN) == 0) {
-		serial_req.line = ACPI_SERIAL_CONSOLE_PORT;
-	}
-	else if (strncmp(acpi_ser_p->signature, ACPI_DBGPT_SIGNATURE, 
-					ACPI_SIG_LEN) == 0) {
-		serial_req.line = ACPI_SERIAL_DEBUG_PORT;
-	}
 	/*
 	 * Check if this is an I/O mapped address or a memory mapped address
 	 */
@@ -163,15 +361,80 @@
 	}
 
 	/*
+	 * Check if SPCR/DBGP define a port already in rs_table
+	 */
+	for (i = 0; i < serial_nr_ports; i++) {
+		if ((rs_table[i].port == serial_req.port) &&
+			(rs_table[i].iomem_base == serial_req.iomem_base))
+			break;
+	}
+	if (i == serial_nr_ports) {
+		if (strncmp(acpi_ser_p->signature, ACPI_SPCRT_SIGNATURE,
+						ACPI_SIG_LEN) == 0) {
+			/*
+			 * Check if there is a legacy COM1 port on this
+			 * machine. If there is, it has been statically
+			 * compiled in the rs_table at slot 0. We need to
+			 * move it out so we can make SPCR port ttyS0.
+			 */
+			state = (struct serial_state *)rs_table;
+			state->magic = SSTATE_MAGIC;
+			state->line = 0;
+			state->type = PORT_UNKNOWN;
+			if (detect_port(state)) {
+				int j;
+
+				for (j=ACPI_SERIAL_CONSOLE_PORT; j>0; j--)
+					memcpy(rs_table+j, rs_table+j-1, sizeof(struct serial_state));
+			}
+
+			serial_req.line = 0;
+		}
+		else if (strncmp(acpi_ser_p->signature, ACPI_DBGPT_SIGNATURE, 
+						ACPI_SIG_LEN) == 0) {
+			/*
+			 * Check if there is a legacy COM2 port on this
+			 * machine. If there is, it has been statically
+			 * compiled in the rs_table at slot 1. We need to
+			 * move it out so we can make SPCR port ttyS1.
+			 */
+			state = (struct serial_state *)(rs_table+1);
+			state->magic = SSTATE_MAGIC;
+			state->line = 1;
+			state->type = PORT_UNKNOWN;
+			if (detect_port(state)) {
+				int j;
+
+				for (j=ACPI_SERIAL_DEBUG_PORT; j>1; j--)
+					memcpy(rs_table+j, rs_table+j-1, sizeof(struct serial_state));
+			}
+			serial_req.line = 1;
+		}
+	}
+	else {
+		serial_req.line = i;
+	}
+
+	/*
 	 * If the table does not have IRQ information, use 0 for IRQ. 
 	 * This will force rs_init() to probe for IRQ. 
 	 */
 	if (acpi_ser_p->length < 53) {
 		serial_req.irq = 0;
+#ifdef CONFIG_IA64_HP_PROTO
+		serial_req.flags = ASYNC_SKIP_TEST|acpi_autoconf_flag;
+#else
+		serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF;
+#endif
 	}
 	else {
+#ifdef CONFIG_IA64_HP_PROTO
+		serial_req.flags = ASYNC_SKIP_TEST | acpi_autoconf_flag | 
+					ASYNC_AUTO_IRQ;
+#else
 		serial_req.flags = ASYNC_SKIP_TEST | ASYNC_BOOT_AUTOCONF | 
 					ASYNC_AUTO_IRQ;
+#endif
 		if (acpi_ser_p->int_type & 
 			(ACPI_SERIAL_INT_APIC | ACPI_SERIAL_INT_SAPIC)) {
 			serial_req.irq = global_sys_irq;
@@ -185,7 +448,11 @@
 			 * run in polling mode. Do not probe for IRQ in
 			 * that case.
 			 */
+#ifdef CONFIG_IA64_HP_PROTO
+			serial_req.flags = ASYNC_SKIP_TEST|acpi_autoconf_flag;
+#else
 			serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF;
+#endif
 		}
 	}
 
@@ -196,6 +463,105 @@
 		printk("early_serial_setup() for ACPI serial console port failed\n");
 		return;
 	}
+
+#ifdef CONFIG_SERIAL_ACPI_CONSOLE_DETECT
+	/*
+	 * If we are parsing SPCR, check if EFI has chosen a serial console.
+	 */
+	if ((!strncmp(acpi_ser_p->signature,ACPI_SPCRT_SIGNATURE,ACPI_SIG_LEN))
+		&& ((efi_cons_in == -1) || (efi_cons_out == -1))) {
+		memset(variable_name, 0, sizeof(variable_name));
+		do {
+			variable_name_size=sizeof(variable_name);
+			status = efi.get_next_variable(&variable_name_size,
+							variable_name,
+							&vendor_guid);
+
+			switch (status) {
+			case EFI_SUCCESS:
+				/* Convert Unicode to normal chars (assume
+				 * top bits are 0), ala UTF-8 
+				 */
+				for (i=0; i<(variable_name_size/sizeof(efi_char16_t)); i++) {
+					varname[i] = variable_name[i] & 0xFF;
+				}
+				varname[i] = 0;
+				if (strcmp(varname, "ConIn") == 0) {
+					size = sizeof(efi_data);
+					status = efi.get_variable(variable_name,
+							&vendor_guid,
+							&attributes,
+							&size,
+							efi_data);
+					efi_cons_in = 1;
+#ifdef SERIAL_DEBUG_ACPI
+					printk("EFI Console in:\n");
+#endif
+					uart_path=parse_efi_path(size,efi_data);
+				}
+				if (strcmp(varname, "ConOut") == 0) {
+					size = sizeof(efi_data);
+					status = efi.get_variable(variable_name,
+							&vendor_guid,
+							&attributes,
+							&size,
+							efi_data);
+					efi_cons_out = 1;
+#ifdef SERIAL_DEBUG_ACPI
+					printk("EFI Console out:\n");
+#endif
+					uart_path=parse_efi_path(size,efi_data);
+				}
+
+				break;
+
+			case EFI_NOT_FOUND:
+				break;
+
+			default:
+				status = EFI_NOT_FOUND;
+				break;
+			}
+		} while (status != EFI_NOT_FOUND);
+	}
+
+	if (uart_path != NULL) {
+		unsigned char str[24];
+		struct kernel_param *p;
+
+		sprintf(str, "ttyS%d,%d%c%d", serial_req.line, 
+				uart_path->baud, ((uart_path->parity == 0x01) ? 
+				'n': ((uart_path->parity == 0x02) ? 'e': 
+				((uart_path->parity == 0x03) ? 'o': 'n'))), 
+				uart_path->bits);
+#ifdef SERIAL_DEBUG_ACPI
+		printk("   setup_acpi_serial: setting console to %s\n\n", str);
+#endif
+
+#if 0
+		/*
+		 * Append a "console=..." string to saved_command_line so
+		 * /proc/cmdline would show the serial console in use
+		 */
+		strcat(saved_command_line, " console=");
+		strcat(saved_command_line, str);
+#endif
+
+		/*
+		 * Find and call console_setup routine
+		 */
+		p = &__setup_start;
+		do {
+			int n = strlen(p->str);
+			if (!strncmp("console=",p->str,n)) {
+				p->setup_func(str);
+				break;
+			}
+			p++;
+		} while (p < &__setup_end);
+	}
+#endif
+
 
 #ifdef SERIAL_DEBUG_ACPI
 	printk("Leaving setup_serial_acpi()\n");
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/agp/agp.h linux/drivers/char/agp/agp.h
--- ../ia64/linux/drivers/char/agp/agp.h	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/agp/agp.h	Sat Mar 23 10:23:14 2002
@@ -126,10 +126,12 @@
 	
 };
 
+#define OUTREG64(mmap, addr, val)   __raw_writeq((val), (mmap)+(addr))
 #define OUTREG32(mmap, addr, val)   __raw_writel((val), (mmap)+(addr))
 #define OUTREG16(mmap, addr, val)   __raw_writew((val), (mmap)+(addr))
 #define OUTREG8(mmap, addr, val)   __raw_writeb((val), (mmap)+(addr))
 
+#define INREG64(mmap, addr)         __raw_readq((mmap)+(addr))
 #define INREG32(mmap, addr)         __raw_readl((mmap)+(addr))
 #define INREG16(mmap, addr)         __raw_readw((mmap)+(addr))
 #define INREG8(mmap, addr)         __raw_readb((mmap)+(addr))
@@ -385,5 +387,14 @@
 #define SVWRKS_TLBFLUSH   0x10
 #define SVWRKS_POSTFLUSH  0x14
 #define SVWRKS_DIRFLUSH   0x0c
+
+/* HP ZX1 SBA registers */
+#define HP_ZX1_CTRL		0x200
+#define HP_ZX1_IBASE		0x300
+#define HP_ZX1_IMASK		0x308
+#define HP_ZX1_PCOM		0x310
+#define HP_ZX1_TCNFG		0x318
+#define HP_ZX1_PDIR_BASE	0x320
+#define HP_ZX1_CACHE_FLUSH	0x428
 
 #endif				/* _AGP_BACKEND_PRIV_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/agp/agpgart_be.c linux/drivers/char/agp/agpgart_be.c
--- ../ia64/linux/drivers/char/agp/agpgart_be.c	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/agp/agpgart_be.c	Tue Apr 30 09:19:49 2002
@@ -212,8 +212,6 @@
 	if(agp_bridge.cant_use_aperture == 0) {
 		if (curr->page_count != 0) {
 			for (i = 0; i < curr->page_count; i++) {
-				curr->memory[i] = agp_bridge.unmask_memory(
-					                     curr->memory[i]);
 				agp_bridge.agp_destroy_page((unsigned long)
 						 phys_to_virt(curr->memory[i]));
 			}
@@ -302,10 +300,7 @@
 				agp_free_memory(new);
 				return NULL;
 			}
-			new->memory[i] =
-			    agp_bridge.mask_memory(
-					  virt_to_phys((void *) new->memory[i]),
-							  type);
+			new->memory[i] = virt_to_phys((void *) new->memory[i]);
 			new->page_count++;
 		}
 	} else {
@@ -314,11 +309,7 @@
 		pte_t *pte;
 
 		vmblock = __vmalloc(page_count << PAGE_SHIFT, GFP_KERNEL,
-#ifdef __ia64__
-					pgprot_writecombine(PAGE_KERNEL));
-#else
 					PAGE_KERNEL);
-#endif
 		if(vmblock == NULL) {
 			MOD_DEC_USE_COUNT;
 			return NULL;
@@ -338,7 +329,7 @@
 #else
 			paddr = pte_val(*pte) & PAGE_MASK;
 #endif
-			new->memory[i] = agp_bridge.mask_memory(paddr, type);
+			new->memory[i] = paddr;
 		}
 
 		new->page_count = page_count;
@@ -384,9 +375,6 @@
 
 void agp_copy_info(agp_kern_info * info)
 {
-	unsigned long page_mask = 0;
-	int i;
-
 	memset(info, 0, sizeof(agp_kern_info));
 	if (agp_bridge.type == NOT_SUPPORTED) {
 		info->chipset = agp_bridge.type;
@@ -402,11 +390,7 @@
 	info->max_memory = agp_bridge.max_memory_agp;
 	info->current_memory = atomic_read(&agp_bridge.current_memory_agp);
 	info->cant_use_aperture = agp_bridge.cant_use_aperture;
-
-	for(i = 0; i < agp_bridge.num_of_masks; i++)
-		page_mask |= agp_bridge.mask_memory(page_mask, i);
-
-	info->page_mask = ~page_mask;
+	info->page_mask = ~0UL;
 }
 
 /* End - Routine to copy over information structure */
@@ -585,8 +569,18 @@
 	 *        command registers.
 	 */
 
-	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
-					device)) != NULL) {
+
+	pci_for_each_dev(device)
+	{
+		/*
+		 *	Enable AGP devices. Most will be VGA display but
+		 *	some may be coprocessors on non VGA devices too
+		 */
+		 
+		if((((device->class >> 16) & 0xFF) != PCI_BASE_CLASS_DISPLAY) &&
+			(device->class != (PCI_CLASS_PROCESSOR_CO << 8)))
+			continue;
+
 		pci_read_config_dword(device, 0x04, &scratch);
 
 		if (!(scratch & 0x00100000))
@@ -835,7 +829,8 @@
 		mem->is_flushed = TRUE;
 	}
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
-		agp_bridge.gatt_table[j] = mem->memory[i];
+		agp_bridge.gatt_table[j] =
+			agp_bridge.mask_memory(mem->memory[i], mem->type);
 	}
 
 	agp_bridge.tlb_flush(mem);
@@ -1077,7 +1072,8 @@
    	CACHE_FLUSH();
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
 		OUTREG32(intel_i810_private.registers,
-			 I810_PTE_BASE + (j * 4), mem->memory[i]);
+			 I810_PTE_BASE + (j * 4),
+			 agp_bridge.mask_memory(mem->memory[i], mem->type));
 	}
 	CACHE_FLUSH();
 
@@ -1143,10 +1139,7 @@
 			agp_free_memory(new);
 			return NULL;
 		}
-		new->memory[0] =
-		    agp_bridge.mask_memory(
-				   virt_to_phys((void *) new->memory[0]),
-						  type);
+		new->memory[0] = virt_to_phys((void *) new->memory[0]);
 		new->page_count = 1;
 	   	new->num_scratch_pages = 1;
 	   	new->type = AGP_PHYS_MEMORY;
@@ -1180,7 +1173,6 @@
 	intel_i810_private.i810_dev = i810_dev;
 
 	agp_bridge.masks = intel_i810_masks;
-	agp_bridge.num_of_masks = 2;
 	agp_bridge.aperture_sizes = (void *) intel_i810_sizes;
 	agp_bridge.size_type = FIXED_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 2;
@@ -1383,7 +1375,8 @@
 	CACHE_FLUSH();
 
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++)
-		OUTREG32(intel_i830_private.registers,I810_PTE_BASE + (j * 4),mem->memory[i]);
+		OUTREG32(intel_i830_private.registers,I810_PTE_BASE + (j * 4),
+			 agp_bridge.mask_memory(mem->memory[i], mem->type));
 
 	CACHE_FLUSH();
 
@@ -1444,7 +1437,7 @@
 			return(NULL);
 		}
 
-		nw->memory[0] = agp_bridge.mask_memory(virt_to_phys((void *) nw->memory[0]),type);
+		nw->memory[0] = virt_to_phys((void *) nw->memory[0]);
 		nw->page_count = 1;
 		nw->num_scratch_pages = 1;
 		nw->type = AGP_PHYS_MEMORY;
@@ -1460,7 +1453,6 @@
 	intel_i830_private.i830_dev = i830_dev;
 
 	agp_bridge.masks = intel_i810_masks;
-	agp_bridge.num_of_masks = 3;
 	agp_bridge.aperture_sizes = (void *) intel_i830_sizes;
 	agp_bridge.size_type = FIXED_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 2;
@@ -1495,10 +1487,6 @@
 
 #endif /* CONFIG_AGP_I810 */
  
- #ifdef CONFIG_AGP_INTEL
-
-#endif /* CONFIG_AGP_I810 */
-
 #ifdef CONFIG_AGP_I460
 
 /* BIOS configures the chipset so that one of two apbase registers are used */
@@ -1506,6 +1494,7 @@
 
 /* 460 supports multiple GART page sizes, so GART pageshift is dynamic */ 
 static u8 intel_i460_pageshift = 12;
+static u32 intel_i460_pagesize;
 
 /* Keep track of which is larger, chipset or kernel page size. */
 static u32 intel_i460_cpk = 1;
@@ -1533,6 +1522,7 @@
 	/* Determine the GART page size */
 	pci_read_config_byte(agp_bridge.dev, INTEL_I460_GXBCTL, &temp);
 	intel_i460_pageshift = (temp & I460_4M_PS) ? 22 : 12;
+	intel_i460_pagesize = 1UL << intel_i460_pageshift;
 
 	values = A_SIZE_8(agp_bridge.aperture_sizes);
 
@@ -1747,7 +1737,7 @@
 {
 	int i, j, k, num_entries;
 	void *temp;
-	unsigned int hold;
+	unsigned long paddr;
 	unsigned int read_back;
 
 	/* 
@@ -1772,17 +1762,22 @@
 		j++;
 	}
 
+#if 0
+	/* not necessary since 460 GART is operated in coherent mode... */
+
 	if (mem->is_flushed == FALSE) {
 		CACHE_FLUSH();
 		mem->is_flushed = TRUE;
 	}
+#endif
 
 	for (i = 0, j = pg_start; i < mem->page_count; i++) {
 
-		hold = (unsigned int) (mem->memory[i]);
+		paddr = mem->memory[i];
 
-		for (k = 0; k < I460_CPAGES_PER_KPAGE; k++, j++, hold++)
-			agp_bridge.gatt_table[j] = hold;
+		for (k = 0; k < I460_CPAGES_PER_KPAGE; k++, j++, paddr += intel_i460_pagesize)
+			agp_bridge.gatt_table[j] = (unsigned int)
+			    agp_bridge.mask_memory(paddr, mem->type);
 	}
 
 	/* 
@@ -1896,6 +1891,7 @@
 	int num_entries;	
 	void *temp;
 	unsigned int read_back;
+	unsigned long paddr;
 
 	temp = agp_bridge.current_size;
 	num_entries = A_SIZE_8(temp)->num_entries;
@@ -1937,25 +1933,27 @@
 		}
 	}
 		
+#if 0
+	/* not necessary since 460 GART is operated in coherent mode... */
 	if (mem->is_flushed == FALSE) {
 		CACHE_FLUSH();
 		mem->is_flushed = TRUE;
 	}
+#endif
 
 	for(pg = start_pg, i = 0; pg <= end_pg; pg++)
 	{
+		paddr = agp_bridge.unmask_memory(agp_bridge.gatt_table[pg]);
 		for(idx = ((pg == start_pg) ? start_offset : 0);
 		    idx < ((pg == end_pg) ? (end_offset + 1)
 				       : I460_KPAGES_PER_CPAGE);
 		    idx++, i++)
 		{
-			i460_pg_detail[pg][idx] = agp_bridge.gatt_table[pg] + 
-						      ((idx * PAGE_SIZE) >> 12);
+			mem->memory[i] = paddr + (idx * PAGE_SIZE);
+			i460_pg_detail[pg][idx] =
+			    agp_bridge.mask_memory(mem->memory[i], mem->type);
+			    
 			i460_pg_count[pg]++;
-
-			/* Finally we fill in mem->memory... */
-			mem->memory[i] = ((unsigned long) (0xffffff & 
-						i460_pg_detail[pg][idx])) << 12;
 		}
 	}
 
@@ -1969,7 +1967,7 @@
 	int num_entries;
 	void *temp;
 	unsigned int read_back;
-	unsigned long addr;
+	unsigned long paddr;
 
 	temp = agp_bridge.current_size;
 	num_entries = A_SIZE_8(temp)->num_entries;
@@ -1996,13 +1994,11 @@
 
 		/* Free GART pages if they are unused */
 		if(i460_pg_count[pg] == 0) {
-			addr = (0xffffffUL & (unsigned long) 
-					     (agp_bridge.gatt_table[pg])) << 12;
-
-			agp_bridge.gatt_table[pg] = 0;
+			paddr = agp_bridge.unmask_memory(agp_bridge.gatt_table[pg]);
+			agp_bridge.gatt_table[pg] = agp_bridge.scratch_page;
 			read_back = agp_bridge.gatt_table[pg];
 
-			intel_i460_free_large_page(pg, addr);
+			intel_i460_free_large_page(pg, paddr);
 		}
 	}
 		
@@ -2057,7 +2053,7 @@
 static gatt_mask intel_i460_masks[] =
 {
 	{ 
-	  INTEL_I460_GATT_VALID, 
+	  INTEL_I460_GATT_VALID | INTEL_I460_GATT_COHERENT,
 	  0
 	}
 };
@@ -2091,7 +2087,6 @@
 {
 
         agp_bridge.masks = intel_i460_masks;
-        agp_bridge.num_of_masks = 1;
         agp_bridge.aperture_sizes = (void *) intel_i460_sizes;
         agp_bridge.size_type = U8_APER_SIZE;
         agp_bridge.num_aperture_sizes = 3;
@@ -2470,7 +2465,6 @@
 static int __init intel_generic_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = intel_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) intel_generic_sizes;
 	agp_bridge.size_type = U16_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -2505,7 +2499,6 @@
 static int __init intel_820_setup (struct pci_dev *pdev)
 {
        agp_bridge.masks = intel_generic_masks;
-       agp_bridge.num_of_masks = 1;
        agp_bridge.aperture_sizes = (void *) intel_8xx_sizes;
        agp_bridge.size_type = U8_APER_SIZE;
        agp_bridge.num_aperture_sizes = 7;
@@ -2536,7 +2529,6 @@
 static int __init intel_840_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = intel_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) intel_8xx_sizes;
 	agp_bridge.size_type = U8_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -2569,7 +2561,6 @@
 static int __init intel_845_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = intel_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) intel_8xx_sizes;
 	agp_bridge.size_type = U8_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -2603,7 +2594,6 @@
 static int __init intel_850_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = intel_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) intel_8xx_sizes;
 	agp_bridge.size_type = U8_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -2637,7 +2627,6 @@
 static int __init intel_860_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = intel_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) intel_8xx_sizes;
 	agp_bridge.size_type = U8_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -2757,7 +2746,6 @@
 static int __init via_generic_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = via_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) via_generic_sizes;
 	agp_bridge.size_type = U8_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -2872,7 +2860,6 @@
 static int __init sis_generic_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = sis_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) sis_generic_sizes;
 	agp_bridge.size_type = U8_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -3205,7 +3192,8 @@
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
 		addr = (j * PAGE_SIZE) + agp_bridge.gart_bus_addr;
 		cur_gatt = GET_GATT(addr);
-		cur_gatt[GET_GATT_OFF(addr)] = mem->memory[i];
+		cur_gatt[GET_GATT_OFF(addr)] =
+			agp_bridge.mask_memory(mem->memory[i], mem->type);
 	}
 	agp_bridge.tlb_flush(mem);
 	return 0;
@@ -3251,7 +3239,6 @@
 static int __init amd_irongate_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = amd_irongate_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) amd_irongate_sizes;
 	agp_bridge.size_type = LVL2_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -3500,7 +3487,6 @@
 static int __init ali_generic_setup (struct pci_dev *pdev)
 {
 	agp_bridge.masks = ali_generic_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) ali_generic_sizes;
 	agp_bridge.size_type = U32_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -3909,7 +3895,8 @@
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
 		addr = (j * PAGE_SIZE) + agp_bridge.gart_bus_addr;
 		cur_gatt = SVRWRKS_GET_GATT(addr);
-		cur_gatt[GET_GATT_OFF(addr)] = mem->memory[i];
+		cur_gatt[GET_GATT_OFF(addr)] =
+			agp_bridge.mask_memory(mem->memory[i], mem->type);
 	}
 	agp_bridge.tlb_flush(mem);
 	return 0;
@@ -4067,8 +4054,18 @@
 	 *        command registers.
 	 */
 
-	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
-					device)) != NULL) {
+
+	pci_for_each_dev(device)
+	{
+		/*
+		 *	Enable AGP devices. Most will be VGA display but
+		 *	some may be coprocessors on non VGA devices too
+		 */
+		 
+		if((((device->class >> 16) & 0xFF) != PCI_BASE_CLASS_DISPLAY) &&
+			(device->class != (PCI_CLASS_PROCESSOR_CO << 8)))
+			continue;
+
 		pci_read_config_dword(device, 0x04, &scratch);
 
 		if (!(scratch & 0x00100000))
@@ -4099,7 +4096,6 @@
 	serverworks_private.svrwrks_dev = pdev;
 
 	agp_bridge.masks = serverworks_masks;
-	agp_bridge.num_of_masks = 1;
 	agp_bridge.aperture_sizes = (void *) serverworks_sizes;
 	agp_bridge.size_type = LVL2_APER_SIZE;
 	agp_bridge.num_aperture_sizes = 7;
@@ -4163,6 +4159,412 @@
 
 #endif /* CONFIG_AGP_SWORKS */
 
+#ifdef CONFIG_AGP_HP_ZX1
+
+#ifdef CONFIG_IA64_HP_PROTO
+#include <asm/efi.h>
+#endif
+
+#ifndef log2
+#define log2(x)		ffz(~(x))
+#endif
+
+#define HP_ZX1_IOVA_BASE	GB(1UL)
+#define HP_ZX1_IOVA_SIZE	GB(1UL)
+#define HP_ZX1_GART_SIZE	(HP_ZX1_IOVA_SIZE / 2)
+#define HP_ZX1_SBA_IOMMU_COOKIE	0x0000badbadc0ffeeUL
+
+#define HP_ZX1_PDIR_VALID_BIT	0x8000000000000000UL
+#define HP_ZX1_IOVA_TO_PDIR(va)	((va - hp_private.iova_base) >> \
+					hp_private.io_tlb_shift)
+
+static aper_size_info_fixed hp_zx1_sizes[] =
+{
+	{0, 0, 0},		/* filled in by hp_zx1_fetch_size() */
+};
+
+static struct _hp_private {
+	struct pci_dev *ioc;
+	volatile u8 *registers;
+	u64 *io_pdir;		// PDIR for entire IOVA
+	u64 *gatt;		// PDIR just for GART (subset of above)
+	u64 gatt_entries;
+	u64 iova_base;
+	u64 gart_base;
+	u64 gart_size;
+	u64 io_pdir_size;
+	int io_pdir_owner;	// do we own it, or share it with sba_iommu?
+	int io_page_size;
+	int io_tlb_shift;
+	int io_tlb_ps;		// IOC ps config
+	int io_pages_per_kpage;
+	u8 ioc_rev;
+} hp_private;
+
+static int __init hp_zx1_ioc_shared(void)
+{
+	struct _hp_private *hp = &hp_private;
+
+	printk(KERN_INFO PFX "HP ZX1 IOC: IOPDIR shared with sba_iommu\n");
+
+	/*
+	 * IOC already configured by sba_iommu module; just use
+	 * its setup.  We assume:
+	 * 	- IOVA space is 1Gb in size
+	 * 	- first 512Mb is IOMMU, second 512Mb is GART
+	 */
+	hp->io_tlb_ps = INREG64(hp->registers, HP_ZX1_TCNFG);
+	switch (hp->io_tlb_ps) {
+		case 0: hp->io_tlb_shift = 12; break;
+		case 1: hp->io_tlb_shift = 13; break;
+		case 2: hp->io_tlb_shift = 14; break;
+		case 3: hp->io_tlb_shift = 16; break;
+		default:
+			printk(KERN_ERR PFX "Invalid IOTLB page size "
+			       "configuration 0x%x\n", hp->io_tlb_ps);
+			hp->gatt = 0;
+			hp->gatt_entries = 0;
+			return -ENODEV;
+	}
+	hp->io_page_size = 1 << hp->io_tlb_shift;
+	hp->io_pages_per_kpage = PAGE_SIZE / hp->io_page_size;
+
+	hp->iova_base = INREG64(hp->registers, HP_ZX1_IBASE) & ~0x1;
+	hp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - HP_ZX1_GART_SIZE;
+
+	hp->gart_size = HP_ZX1_GART_SIZE;
+	hp->gatt_entries = hp->gart_size / hp->io_page_size;
+
+	hp->io_pdir = phys_to_virt(INREG64(hp->registers, HP_ZX1_PDIR_BASE));
+	hp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];
+
+	if (hp->gatt[0] != HP_ZX1_SBA_IOMMU_COOKIE) {
+	    	hp->gatt = 0;
+		hp->gatt_entries = 0;
+		printk(KERN_ERR PFX "No reserved IO PDIR entry found; "
+		       "GART disabled\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int __init hp_zx1_ioc_owner(void)
+{
+	struct _hp_private *hp = &hp_private;
+
+	printk(KERN_INFO PFX "HP ZX1 IOC: IOPDIR dedicated to GART\n");
+
+	/*
+	 * Select an IOV page size no larger than system page size.
+	 */
+	if (PAGE_SIZE >= KB(64)) {
+		hp->io_tlb_shift = 16;
+		hp->io_tlb_ps = 3;
+	} else if (PAGE_SIZE >= KB(16)) {
+		hp->io_tlb_shift = 14;
+		hp->io_tlb_ps = 2;
+	} else if (PAGE_SIZE >= KB(8)) {
+		hp->io_tlb_shift = 13;
+		hp->io_tlb_ps = 1;
+	} else {
+		hp->io_tlb_shift = 12;
+		hp->io_tlb_ps = 0;
+	}
+	hp->io_page_size = 1 << hp->io_tlb_shift;
+	hp->io_pages_per_kpage = PAGE_SIZE / hp->io_page_size;
+
+	hp->iova_base = HP_ZX1_IOVA_BASE;
+	hp->gart_size = HP_ZX1_GART_SIZE;
+#ifdef CONFIG_IA64_HP_PROTO
+	if (hp->ioc_rev < 0x20) {
+		printk(KERN_WARNING PFX "WARNING: SBA rev 2.x or newer will "
+			"be required for GART support in the future\n");
+		hp->iova_base = 0;
+		hp->gart_size = HP_ZX1_GART_SIZE / 2;
+	}
+#endif
+
+	hp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - hp->gart_size;
+
+	hp->gatt_entries = hp->gart_size / hp->io_page_size;
+	hp->io_pdir_size = (HP_ZX1_IOVA_SIZE / hp->io_page_size) * sizeof(u64);
+
+	return 0;
+}
+
+static int __init hp_zx1_ioc_init(void)
+{
+	struct _hp_private *hp = &hp_private;
+	struct pci_dev *ioc;
+	int i;
+
+	ioc = pci_find_device(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_ZX1_IOC, NULL);
+	if (!ioc) {
+		printk(KERN_ERR PFX "Detected HP ZX1 AGP bridge but no IOC\n");
+		return -ENODEV;
+	}
+	hp->ioc = ioc;
+
+	pci_read_config_byte(ioc, PCI_REVISION_ID, &hp->ioc_rev);
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		if (pci_resource_flags(ioc, i) == IORESOURCE_MEM) {
+			hp->registers = (u8 *) ioremap(pci_resource_start(ioc,
+									    i),
+						    pci_resource_len(ioc, i));
+			break;
+		}
+	}
+	if (!hp->registers) {
+		printk(KERN_ERR PFX "Detected HP ZX1 AGP bridge but no CSRs\n");
+
+		return -ENODEV;
+	}
+
+	/*
+	 * If the IOTLB is currently disabled, we can take it over.
+	 * Otherwise, we have to share with sba_iommu.
+	 */
+	hp->io_pdir_owner = (INREG64(hp->registers, HP_ZX1_IBASE) & 0x1) == 0;
+
+#ifdef CONFIG_IA64_HP_PROTO
+	if (hp->ioc_rev < 0x20) {
+		if (hp->io_pdir_owner) {
+			printk(KERN_ERR PFX "SBA 1.x without sba_iommu; "
+				"GART disabled\n");
+			return -ENODEV;
+		}
+	} else {
+		printk(KERN_INFO PFX "SBA 2.x or newer\n");
+		if (hp->io_pdir_owner &&
+		    efi_mem_type(HP_ZX1_IOVA_BASE) == EFI_CONVENTIONAL_MEMORY) {
+			printk(KERN_ERR PFX "SBA 2.x without sba_iommu "
+				"and memory at 0x%lx; GART disabled\n",
+				HP_ZX1_IOVA_BASE);
+			return -ENODEV;
+		}
+	}
+#endif
+
+	if (hp->io_pdir_owner)
+		return hp_zx1_ioc_owner();
+
+	return hp_zx1_ioc_shared();
+}
+
+static int hp_zx1_fetch_size(void)
+{
+	int size;
+
+	size = hp_private.gart_size / MB(1);
+	hp_zx1_sizes[0].size = size;
+	agp_bridge.current_size = (void *) &hp_zx1_sizes[0];
+	return size;
+}
+
+static int hp_zx1_configure(void)
+{
+	struct _hp_private *hp = &hp_private;
+
+	agp_bridge.gart_bus_addr = hp->gart_base;
+	agp_bridge.capndx = pci_find_capability(agp_bridge.dev, PCI_CAP_ID_AGP);
+	pci_read_config_dword(agp_bridge.dev,
+		agp_bridge.capndx + PCI_AGP_STATUS, &agp_bridge.mode);
+
+	if (hp->io_pdir_owner) {
+		OUTREG64(hp->registers, HP_ZX1_PDIR_BASE,
+			virt_to_phys(hp->io_pdir));
+		OUTREG64(hp->registers, HP_ZX1_TCNFG, hp->io_tlb_ps);
+		OUTREG64(hp->registers, HP_ZX1_IMASK, ~(HP_ZX1_IOVA_SIZE - 1));
+		OUTREG64(hp->registers, HP_ZX1_IBASE, hp->iova_base | 0x1);
+		OUTREG64(hp->registers, HP_ZX1_PCOM,
+			hp->iova_base | log2(HP_ZX1_IOVA_SIZE));
+		INREG64(hp->registers, HP_ZX1_PCOM);
+	}
+
+	return 0;
+}
+
+static void hp_zx1_cleanup(void)
+{
+	struct _hp_private *hp = &hp_private;
+
+	if (hp->io_pdir_owner)
+		OUTREG64(hp->registers, HP_ZX1_IBASE, 0);
+	iounmap((void *) hp->registers);
+}
+
+static void hp_zx1_tlbflush(agp_memory * mem)
+{
+	struct _hp_private *hp = &hp_private;
+
+	OUTREG64(hp->registers, HP_ZX1_PCOM, 
+		hp->gart_base | log2(hp->gart_size));
+	INREG64(hp->registers, HP_ZX1_PCOM);
+}
+
+static int hp_zx1_create_gatt_table(void)
+{
+	struct _hp_private *hp = &hp_private;
+	int i;
+
+	if (hp->io_pdir_owner) {
+		hp->io_pdir = (u64 *) __get_free_pages(GFP_KERNEL,
+						get_order(hp->io_pdir_size));
+		if (!hp->io_pdir) {
+			printk(KERN_ERR PFX "Couldn't allocate contiguous "
+				"memory for I/O PDIR\n");
+			hp->gatt = 0;
+			hp->gatt_entries = 0;
+			return -ENOMEM;
+		}
+		memset(hp->io_pdir, 0, hp->io_pdir_size);
+
+		hp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];
+
+#ifdef CONFIG_IA64_HP_PROTO
+		if (hp->ioc_rev < 0x20) {
+			int i, entries;
+			u64 *pdir, io_addr;
+
+			printk(KERN_INFO PFX "identity-mapping IOVA space "
+				"(1.x SBA)\n");
+			pdir = hp->io_pdir;
+			entries = HP_ZX1_IOVA_SIZE / hp->io_page_size;
+			io_addr = hp->iova_base;
+			for (i = 0; i < entries; i++, io_addr += hp->io_page_size) {
+				*pdir++ = HP_ZX1_PDIR_VALID_BIT | io_addr;
+			}
+		}
+#endif
+	}
+
+	for (i = 0; i < hp->gatt_entries; i++) {
+		hp->gatt[i] = (unsigned long) agp_bridge.scratch_page;
+	}
+
+	return 0;
+}
+
+static int hp_zx1_free_gatt_table(void)
+{
+	struct _hp_private *hp = &hp_private;
+	
+	if (hp->io_pdir_owner)
+		free_pages((unsigned long) hp->io_pdir,
+			    get_order(hp->io_pdir_size));
+	else
+		hp->gatt[0] = HP_ZX1_SBA_IOMMU_COOKIE;
+	return 0;
+}
+
+static int hp_zx1_insert_memory(agp_memory * mem, off_t pg_start, int type)
+{
+	struct _hp_private *hp = &hp_private;
+	int i, k;
+	off_t j, io_pg_start;
+	int io_pg_count;
+
+	if (type != 0 || mem->type != 0) {
+		return -EINVAL;
+	}
+
+	io_pg_start = hp->io_pages_per_kpage * pg_start;
+	io_pg_count = hp->io_pages_per_kpage * mem->page_count;
+	if ((io_pg_start + io_pg_count) > hp->gatt_entries) {
+		return -EINVAL;
+	}
+
+	j = io_pg_start;
+	while (j < (io_pg_start + io_pg_count)) {
+		if (hp->gatt[j]) {
+			return -EBUSY;
+		}
+		j++;
+	}
+
+#if 0
+	/* Not necessary since zx1 agp is coherent */
+	if (mem->is_flushed == FALSE) {
+		CACHE_FLUSH();
+		mem->is_flushed = TRUE;
+	}
+#endif
+
+	for (i = 0, j = io_pg_start; i < mem->page_count; i++) {
+		unsigned long paddr;
+
+		paddr = mem->memory[i];
+		for (k = 0;
+		     k < hp->io_pages_per_kpage;
+		     k++, j++, paddr += hp->io_page_size) {
+			hp->gatt[j] = agp_bridge.mask_memory(paddr, type);
+		}
+	}
+
+	agp_bridge.tlb_flush(mem);
+	return 0;
+}
+
+static int hp_zx1_remove_memory(agp_memory * mem, off_t pg_start, int type)
+{
+	struct _hp_private *hp = &hp_private;
+	int i, io_pg_start, io_pg_count;
+
+	if (type != 0 || mem->type != 0) {
+		return -EINVAL;
+	}
+
+	io_pg_start = hp->io_pages_per_kpage * pg_start;
+	io_pg_count = hp->io_pages_per_kpage * mem->page_count;
+	for (i = io_pg_start; i < io_pg_count + io_pg_start; i++) {
+		hp->gatt[i] = agp_bridge.scratch_page;
+	}
+
+	agp_bridge.tlb_flush(mem);
+	return 0;
+}
+
+static unsigned long hp_zx1_mask_memory(unsigned long addr, int type)
+{
+	return HP_ZX1_PDIR_VALID_BIT | addr;
+}
+
+static unsigned long hp_zx1_unmask_memory(unsigned long addr)
+{
+	return addr & ~(HP_ZX1_PDIR_VALID_BIT);
+}
+
+static int __init hp_zx1_setup (struct pci_dev *pdev)
+{
+	agp_bridge.dev_private_data = NULL;
+	agp_bridge.size_type = FIXED_APER_SIZE;
+	agp_bridge.needs_scratch_page = FALSE;
+	agp_bridge.configure = hp_zx1_configure;
+	agp_bridge.fetch_size = hp_zx1_fetch_size;
+	agp_bridge.cleanup = hp_zx1_cleanup;
+	agp_bridge.tlb_flush = hp_zx1_tlbflush;
+	agp_bridge.mask_memory = hp_zx1_mask_memory;
+	agp_bridge.unmask_memory = hp_zx1_unmask_memory;
+	agp_bridge.agp_enable = agp_generic_agp_enable;
+	agp_bridge.cache_flush = global_cache_flush;
+	agp_bridge.create_gatt_table = hp_zx1_create_gatt_table;
+	agp_bridge.free_gatt_table = hp_zx1_free_gatt_table;
+	agp_bridge.insert_memory = hp_zx1_insert_memory;
+	agp_bridge.remove_memory = hp_zx1_remove_memory;
+	agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
+	agp_bridge.free_by_type = agp_generic_free_by_type;
+	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
+	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.cant_use_aperture = 1;
+
+	return hp_zx1_ioc_init();
+
+	(void) pdev; /* unused */
+}
+
+#endif /* CONFIG_AGP_HP_ZX1 */
 
 /* per-chipset initialization data.
  * note -- all chipsets for a single vendor MUST be grouped together
@@ -4459,6 +4861,15 @@
 		via_generic_setup },
 #endif /* CONFIG_AGP_VIA */
 
+#ifdef CONFIG_AGP_HP_ZX1
+	{ PCI_DEVICE_ID_HP_ZX1_LBA,
+		PCI_VENDOR_ID_HP,
+		HP_ZX1,
+		"HP",
+		"ZX1",
+		hp_zx1_setup },
+#endif
+
 	{ 0, }, /* dummy final entry, always present */
 };
 
@@ -4701,6 +5112,23 @@
 
 #endif	/* CONFIG_AGP_SWORKS */
 
+#ifdef CONFIG_AGP_HP_ZX1
+	if (dev->vendor == PCI_VENDOR_ID_HP) {
+		do {
+			/* ZX1 LBAs can be either PCI or AGP bridges */
+			if (pci_find_capability(dev, PCI_CAP_ID_AGP)) {
+				printk(KERN_INFO PFX "Detected HP ZX1 AGP "
+				       "chipset at %s\n", dev->slot_name);
+				agp_bridge.type = HP_ZX1;
+				agp_bridge.dev = dev;
+				return hp_zx1_setup(dev);
+			}
+			dev = pci_find_class(PCI_CLASS_BRIDGE_HOST << 8, dev);
+		} while (dev);
+		return -ENODEV;
+	}
+#endif	/* CONFIG_AGP_HP_ZX1 */
+
 	/* find capndx */
 	pci_read_config_dword(dev, 0x04, &scratch);
 	if (!(scratch & 0x00100000))
@@ -4751,7 +5179,7 @@
 {
 	long memory, index, result;
 
-	memory = virt_to_phys(high_memory) >> 20;
+	memory = (num_physpages << PAGE_SHIFT) >> 20;
 	index = 1;
 
 	while ((memory > maxes_table[index].mem) &&
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/drm/drm_agpsupport.h linux/drivers/char/drm/drm_agpsupport.h
--- ../ia64/linux/drivers/char/drm/drm_agpsupport.h	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/drm/drm_agpsupport.h	Sat Mar 23 10:23:14 2002
@@ -317,6 +317,8 @@
 			break;
 #endif
 
+		case HP_ZX1:		head->chipset = "HP ZX1";	 break;
+
 		default:		head->chipset = "Unknown";       break;
 		}
 #if LINUX_VERSION_CODE <= 0x020408
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/drm/drm_memory.h linux/drivers/char/drm/drm_memory.h
--- ../ia64/linux/drivers/char/drm/drm_memory.h	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/drm/drm_memory.h	Mon Jan 28 12:19:08 2002
@@ -322,7 +322,7 @@
 	}
 
 #if __REALLY_HAVE_AGP
-	if(dev->agp->cant_use_aperture == 0)
+	if(!dev->agp || dev->agp->cant_use_aperture == 0)
 		goto standard_ioremap;
 
 	list_for_each(list, &dev->maplist->head) {
@@ -382,7 +382,7 @@
 		DRM_MEM_ERROR(DRM_MEM_MAPPINGS,
 			      "Attempt to free NULL pointer\n");
 #if __REALLY_HAVE_AGP
-	else if(dev->agp->cant_use_aperture == 0)
+	else if(!dev->agp || dev->agp->cant_use_aperture == 0)
 #else
 	else
 #endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/drm/drm_vm.h linux/drivers/char/drm/drm_vm.h
--- ../ia64/linux/drivers/char/drm/drm_vm.h	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/drm/drm_vm.h	Tue Apr 30 09:19:49 2002
@@ -78,7 +78,7 @@
          * Find the right map
          */
 
-	if(!dev->agp->cant_use_aperture) goto vm_nopage_error;
+	if(!dev->agp || !dev->agp->cant_use_aperture) goto vm_nopage_error;
 
 	list_for_each(list, &dev->maplist->head) {
 		r_list = (drm_map_list_t *)list;
@@ -89,7 +89,7 @@
 
 	if (map && map->type == _DRM_AGP) {
 		unsigned long offset = address - vma->vm_start;
-		unsigned long baddr = VM_OFFSET(vma) + offset, paddr;
+		unsigned long baddr = VM_OFFSET(vma) + offset;
 		struct drm_agp_mem *agpmem;
 		struct page *page;
 
@@ -115,19 +115,8 @@
                  * Get the page, inc the use count, and return it
                  */
 		offset = (baddr - agpmem->bound) >> PAGE_SHIFT;
-
-		/*
-		 * This is bad.  What we really want to do here is unmask
-		 * the GART table entry held in the agp_memory structure.
-		 * There isn't a convenient way to call agp_bridge.unmask_
-		 * memory from here, so hard code it for now.
-		 */
-#if defined(__ia64__)
-		paddr = (agpmem->memory->memory[offset] & 0xffffff) << 12;
-#else
-		paddr = agpmem->memory->memory[offset] & dev->agp->page_mask;
-#endif
-		page = virt_to_page(__va(paddr));
+		agpmem->memory->memory[offset] &= dev->agp->page_mask;
+		page = virt_to_page(__va(agpmem->memory->memory[offset]));
 		get_page(page);
 
 		DRM_DEBUG("baddr = 0x%lx page = 0x%p, offset = 0x%lx\n",
@@ -467,6 +456,7 @@
 	drm_map_list_t  *r_list;
 	unsigned long   offset  = 0;
 	struct list_head *list;
+	struct page 	*page;
 
 	DRM_DEBUG("start = 0x%lx, end = 0x%lx, offset = 0x%lx\n",
 		  vma->vm_start, vma->vm_end, VM_OFFSET(vma));
@@ -522,17 +512,14 @@
                 	 * in nopage()
                 	 */
                 	vma->vm_ops = &DRM(vm_ops);
-#if defined(__ia64__)
-			vma->vm_page_prot =
-			                pgprot_writecombine(vma->vm_page_prot);
-#endif
 			goto mapswitch_out;
 		}
 #endif
                 /* fall through to _DRM_FRAME_BUFFER... */        
 	case _DRM_FRAME_BUFFER:
 	case _DRM_REGISTERS:
-		if (VM_OFFSET(vma) >= __pa(high_memory)) {
+		page = virt_to_page(__va(VM_OFFSET(vma)));
+		if (!VALID_PAGE(page) || PageReserved(page)) {
 #if defined(__i386__)
 			if (boot_cpu_data.x86 > 3 && map->type != _DRM_AGP) {
 				pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/drm-4.0/vm.c linux/drivers/char/drm-4.0/vm.c
--- ../ia64/linux/drivers/char/drm-4.0/vm.c	Fri Jan 25 13:11:17 2002
+++ linux/drivers/char/drm-4.0/vm.c	Tue Apr 30 09:19:49 2002
@@ -391,7 +391,6 @@
                  * in nopage()
                  */
                 vma->vm_ops = &drm_vm_ops;
-		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
                 break;
 #endif
 	case _DRM_FRAME_BUFFER:
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/mem.c linux/drivers/char/mem.c
--- ../ia64/linux/drivers/char/mem.c	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/mem.c	Fri Feb  8 07:42:53 2002
@@ -177,6 +177,11 @@
 		  test_bit(X86_FEATURE_CYRIX_ARR, &boot_cpu_data.x86_capability) ||
 		  test_bit(X86_FEATURE_CENTAUR_MCR, &boot_cpu_data.x86_capability) )
 	  && addr >= __pa(high_memory);
+#elif defined(__ia64__)
+	struct page *page;
+
+	page = virt_to_page(__va(addr));
+	return (!VALID_PAGE(page) || PageReserved(page));
 #else
 	return addr >= __pa(high_memory);
 #endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/pc_keyb.c linux/drivers/char/pc_keyb.c
--- ../ia64/linux/drivers/char/pc_keyb.c	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/pc_keyb.c	Fri Jan 25 14:35:05 2002
@@ -802,6 +802,13 @@
 {
 	int status;
 
+#ifdef __ia64__
+	if (kbd_read_status() == 0xff && kbd_read_input() == 0xff) {
+		kbd_exists = 0;
+		return "No keyboard controller preset";
+	}
+#endif
+
 	/*
 	 * Test the keyboard interface.
 	 * This seems to be the only way to get it going.
@@ -904,6 +911,10 @@
 		char *msg = initialize_kbd();
 		if (msg)
 			printk(KERN_WARNING "initialize_kbd: %s\n", msg);
+#ifdef __ia64__
+		if (!kbd_exists)
+			return;
+#endif
 	}
 
 #if defined CONFIG_PSMOUSE
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/char/serial.c linux/drivers/char/serial.c
--- ../ia64/linux/drivers/char/serial.c	Fri Jan 25 13:11:16 2002
+++ linux/drivers/char/serial.c	Tue Apr 23 15:46:42 2002
@@ -87,9 +87,8 @@
  * 		ever possible.
  *
  * CONFIG_SERIAL_ACPI
- *		Enable support for serial console port and serial 
- *		debug port as defined by the SPCR and DBGP tables in 
- *		ACPI 2.0.
+ *		Enable support for serial ports found in the ACPI
+ *		namespace.
  */
 
 #include <linux/config.h>
@@ -217,6 +216,10 @@
 #ifdef CONFIG_MAGIC_SYSRQ
 #include <linux/sysrq.h>
 #endif
+#ifdef ENABLE_SERIAL_ACPI
+#include <linux/acpi.h>
+#include "../acpi/acpi_bus.h"
+#endif
 
 /*
  * All of the compatibilty code so we can compile serial.c against
@@ -321,11 +324,12 @@
 MODULE_PARM_DESC(force_rsa, "Force I/O ports for RSA");
 #endif /* CONFIG_SERIAL_RSA  */
 
-static struct serial_state rs_table[RS_TABLE_SIZE] = {
+struct serial_state rs_table[RS_TABLE_SIZE] = {
 	SERIAL_PORT_DFNS	/* Defined in serial.h */
 };
 
 #define NR_PORTS	(sizeof(rs_table)/sizeof(struct serial_state))
+int serial_nr_ports = NR_PORTS;
 
 #if (defined(ENABLE_SERIAL_PCI) || defined(ENABLE_SERIAL_PNP))
 #define NR_PCI_BOARDS	8
@@ -2133,6 +2137,7 @@
 	if (new_serial.type) {
 		for (i = 0 ; i < NR_PORTS; i++)
 			if ((state != &rs_table[i]) &&
+			    (rs_table[i].io_type == SERIAL_IO_PORT) &&
 			    (rs_table[i].port == new_port) &&
 			    rs_table[i].type)
 				return -EADDRINUSE;
@@ -2195,7 +2200,7 @@
 
 	
 check_and_exit:
-	if (!state->port || !state->type)
+	if ((!state->port && !state->iomem_base) || !state->type)
 		return 0;
 	if (info->flags & ASYNC_INITIALIZED) {
 		if (((old_state.flags & ASYNC_SPD_MASK) !=
@@ -3251,7 +3256,9 @@
 		      state->line, uart_config[state->type].name, 
 		      state->port, state->irq);
 
-	if (!state->port || (state->type == PORT_UNKNOWN)) {
+	if ((state->type == PORT_UNKNOWN) ||
+	    (state->io_type == SERIAL_IO_PORT && !state->port) ||
+	    (state->io_type == SERIAL_IO_MEM && !state->iomem_base)) {
 		ret += sprintf(buf+ret, "\n");
 		return ret;
 	}
@@ -3912,6 +3919,25 @@
 		
 	}
   
+	/* HP's Diva chip puts the 4th/5th serial port further out, and
+	 * some serial ports are supposed to be hidden on certain models.
+	 */
+	if (dev->vendor == PCI_VENDOR_ID_HP &&
+			dev->device == PCI_DEVICE_ID_HP_SAS) {
+		switch (dev->subsystem_device) {
+		case 0x104B: /* Maestro */
+			if (idx == 3) idx++;
+			break;
+		case 0x1282: /* Everest / Longs Peak */
+			if (idx > 0) idx++;
+			if (idx > 2) idx++;
+			break;
+		}
+		if (idx > 2) {
+			offset = 0x18;
+		}
+	}
+
 	port =  pci_resource_start(dev, base_idx) + offset;
 
 	if ((board->flags & SPCI_FL_BASE_TABLE) == 0)
@@ -4215,6 +4241,39 @@
 	return 0;
 }
 
+/*
+ * HP's Remote Management Console.  The Diva chip came in several
+ * different versions.  N-class, L2000 and A500 have two Diva chips, each
+ * with 3 UARTs (the third UART on the second chip is unused).  Superdome
+ * and Keystone have one Diva chip with 3 UARTs.  Some later machines have
+ * one Diva chip, but it has been expanded to 5 UARTs.
+ */
+static int __devinit
+pci_hp_diva(struct pci_dev *dev, struct pci_board *board, int enable)
+{
+	if (!enable)
+		return 0;
+
+	switch (dev->subsystem_device) {
+	case 0x1049: /* Prelude Diva 1 */
+	case 0x1223: /* Superdome */
+	case 0x1226: /* Keystone */
+	case 0x1282: /* Everest / Longs Peak */
+		board->num_ports = 3;
+		break;
+	case 0x104A: /* Prelude Diva 2 */
+		board->num_ports = 2;
+		break;
+	case 0x104B: /* Maestro */
+		board->num_ports = 4;
+	case 0x1227: /* Powerbar */
+		board->num_ports = 1;
+		break;
+	}
+
+	return 0;
+}
+
 static int __devinit
 pci_xircom_fn(struct pci_dev *dev, struct pci_board *board, int enable)
 {
@@ -4258,6 +4317,7 @@
 	pbn_b1_4_1382400,
 	pbn_b1_8_1382400,
 
+	pbn_b2_1_115200,
 	pbn_b2_8_115200,
 	pbn_b2_4_460800,
 	pbn_b2_8_460800,
@@ -4278,6 +4338,7 @@
 	pbn_timedia,
 	pbn_intel_i960,
 	pbn_sgi_ioc3,
+	pbn_hp_diva,
 #ifdef CONFIG_DDB5074
 	pbn_nec_nile4,
 #endif
@@ -4336,6 +4397,7 @@
 	{ SPCI_FL_BASE1, 4, 1382400 },		/* pbn_b1_4_1382400 */
 	{ SPCI_FL_BASE1, 8, 1382400 },		/* pbn_b1_8_1382400 */
 
+	{ SPCI_FL_BASE2, 1, 115200 },		/* pbn_b2_1_115200 */
 	{ SPCI_FL_BASE2, 8, 115200 },		/* pbn_b2_8_115200 */
 	{ SPCI_FL_BASE2, 4, 460800 },		/* pbn_b2_4_460800 */
 	{ SPCI_FL_BASE2, 8, 460800 },		/* pbn_b2_8_460800 */
@@ -4366,6 +4428,7 @@
 		8<<2, 2, pci_inteli960ni_fn, 0x10000},
 	{ SPCI_FL_BASE0 | SPCI_FL_IRQRESOURCE,		   /* pbn_sgi_ioc3 */
 		1, 458333, 0, 0, 0, 0x20178 },
+	{ SPCI_FL_BASE0, 5, 115200, 8, 0, pci_hp_diva, 0},   /* pbn_hp_diva */
 #ifdef CONFIG_DDB5074
 	/*
 	 * NEC Vrc-5074 (Nile 4) builtin UART.
@@ -4507,6 +4570,85 @@
 	}
 }
 
+#ifdef ENABLE_SERIAL_ACPI
+#include <asm/hw_irq.h>
+static int acpi_serial_add(struct acpi_device *device)
+{
+	acpi_status result;
+	acpi_buffer buffer;
+	struct serial_struct serial_req;
+	int line, offset = 0;
+
+	memset(&serial_req, 0, sizeof(serial_req));
+	buffer.length = 0;
+	buffer.pointer = NULL;
+	result = acpi_get_current_resources(device->handle, &buffer);
+	if (result != AE_BUFFER_OVERFLOW)
+		return -ENODEV;
+	buffer.pointer = kmalloc(buffer.length, GFP_KERNEL);
+	if (!buffer.pointer)
+		return -ENOMEM;
+	result = acpi_get_current_resources(device->handle, &buffer);
+	if (result != AE_OK)
+		return -ENODEV;
+
+	while (offset <= buffer.length) {
+		acpi_resource *res = buffer.pointer + offset;
+		if (res->length == 0)
+			break;
+		offset += res->length;
+		if (res->id == ACPI_RSTYPE_ADDRESS32) {
+			acpi_resource_address32 *addr32 = &res->data.address32;
+			serial_req.iomem_base = ioremap(addr32->min_address_range, addr32->max_address_range - addr32->min_address_range + 1);
+			serial_req.io_type = SERIAL_IO_MEM;
+			serial_req.port = 0;
+			serial_req.port_high = 0;
+		} else if (res->id == ACPI_RSTYPE_EXT_IRQ) {
+			acpi_resource_ext_irq *ext_irq = &res->data.extended_irq;
+			if (ext_irq->number_of_interrupts > 0)
+				serial_req.irq = gsi_irq_to_vector(ext_irq->interrupts[0]);
+		}
+	}
+
+	serial_req.baud_base = BASE_BAUD;
+	serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF|ASYNC_AUTO_IRQ;
+	serial_req.xmit_fifo_size = serial_req.custom_divisor = 0;
+	serial_req.close_delay = serial_req.hub6 = serial_req.closing_wait = 0;
+	serial_req.iomem_reg_shift = 0;
+
+	line = register_serial(&serial_req);
+	if (line < 0)
+		return -ENODEV;
+//	rs_table[line].baud_base = base_baud;
+//	rs_table[line].dev = dev;
+
+	kfree(buffer.pointer);
+	return 0;
+}
+
+static int acpi_serial_remove(struct acpi_device *device, int type)
+{
+	return 0;
+}
+
+static struct acpi_driver acpi_serial_driver = {
+	name:	"serial",
+	class:	"",
+	ids:	"PNP0501",
+	ops:	{
+			add:	acpi_serial_add,
+			remove:	acpi_serial_remove,
+		},
+};
+
+/*
+ * Look for serial ports in the ACPI namespace.
+ */
+static void __devinit probe_serial_acpi(void)
+{
+	acpi_bus_register_driver(&acpi_serial_driver);
+}
+#endif /* ENABLE_SERIAL_ACPI */
 
 static struct pci_device_id serial_pci_tbl[] __devinitdata = {
 	{	PCI_VENDOR_ID_V3, PCI_DEVICE_ID_V3_V960,
@@ -4864,6 +5006,14 @@
 		0xFF00, 0, 0, 0,
 		pbn_sgi_ioc3 },
 
+	/* HP Diva card */
+	{	PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_SAS,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		pbn_hp_diva },
+	{	PCI_VENDOR_ID_HP, 0x1290,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		pbn_b2_1_115200 },
+
 #ifdef CONFIG_DDB5074
 	/*
 	 * NEC Vrc-5074 (Nile 4) builtin UART.
@@ -5454,7 +5604,17 @@
 	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
 		state->magic = SSTATE_MAGIC;
 		state->line = i;
+#if defined(CONFIG_IA64_HP_PROTO) && defined(CONFIG_SERIAL_ACPI)
+		{
+			extern int acpi_autoconf_flag;
+			if (acpi_autoconf_flag)
+				state->type = PORT_UNKNOWN;
+			else
+				state->irq = 0;
+		}
+#else
 		state->type = PORT_UNKNOWN;
+#endif
 		state->custom_divisor = 0;
 		state->close_delay = 5*HZ/10;
 		state->closing_wait = 30*HZ;
@@ -5485,7 +5645,7 @@
 		    && (state->port != 0 || state->iomem_base != 0))
 			state->irq = detect_uart_irq(state);
 		if (state->io_type == SERIAL_IO_MEM) {
-			printk(KERN_INFO"ttyS%02d%s at 0x%px (irq = %d) is a %s\n",
+			printk(KERN_INFO"ttyS%02d%s at 0x%p (irq = %d) is a %s\n",
 	 		       state->line + SERIAL_DEV_OFFSET,
 			       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
 			       state->iomem_base, state->irq,
@@ -5503,11 +5663,14 @@
 		tty_register_devfs(&callout_driver, 0,
 				   callout_driver.minor_start + state->line);
 	}
+#ifdef ENABLE_SERIAL_ACPI
+	probe_serial_acpi();
+#endif
 #ifdef ENABLE_SERIAL_PCI
 	probe_serial_pci();
 #endif
 #ifdef ENABLE_SERIAL_PNP
-       probe_serial_pnp();
+	probe_serial_pnp();
 #endif
 	return 0;
 }
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/Config.in linux/drivers/message/fusion/Config.in
--- ../ia64/linux/drivers/message/fusion/Config.in	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/Config.in	Wed Feb 27 15:25:30 2002
@@ -7,10 +7,8 @@
 
   if [ "$CONFIG_BLK_DEV_SD" = "y" -a "$CONFIG_FUSION" = "y" ]; then
     define_bool CONFIG_FUSION_BOOT y
-    comment "(ability to boot linux kernel from Fusion device is ENABLED!)"
   else
     define_bool CONFIG_FUSION_BOOT n
-    comment "(ability to boot linux kernel from Fusion device is DISABLED!)"
   fi
 
   if [ "$CONFIG_MODULES" = "y" ]; then
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/Makefile linux/drivers/message/fusion/Makefile
--- ../ia64/linux/drivers/message/fusion/Makefile	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/Makefile	Wed Feb 27 15:25:30 2002
@@ -27,6 +27,7 @@
 #EXTRA_CFLAGS += -DDEBUG
 #EXTRA_CFLAGS += -DMPT_DEBUG
 #EXTRA_CFLAGS += -DMPT_DEBUG_MSG_FRAME
+#EXTRA_CFLAGS += -DMPT_DEBUG_SG
 #
 # driver/module specifics...
 #
@@ -34,11 +35,13 @@
 #CFLAGS_mptbase.o += -DMPT_DEBUG_HANDSHAKE
 #CFLAGS_mptbase.o += -DMPT_DEBUG_IRQ
 #
-#  For {mptscsih, mptctl}:
+#  For mptscsih:
 #CFLAGS_mptscsih.o += -DMPT_SCSI_USE_NEW_EH
 #CFLAGS_mptscsih.o += -DMPT_DEBUG_SCANDV
-#CFLAGS_mptscsih.o += -DMPT_DEBUG_SG
-#CFLAGS_mptctl.o += -DMPT_DEBUG_SG
+#CFLAGS_mptscsih.o += -DMPT_DEBUG_RESET
+#
+#  For mptctl:
+#CFLAGS_mptctl.o += -DMPT_DEBUG_IOCTL
 #
 #  For mptlan:
 #CFLAGS_mptlan.o += -DMPT_LAN_IO_DEBUG
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/isense.c linux/drivers/message/fusion/isense.c
--- ../ia64/linux/drivers/message/fusion/isense.c	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/isense.c	Tue Mar 19 16:05:36 2002
@@ -5,12 +5,13 @@
  *      Error Report logging output.  This module implements SCSI-3
  *      Opcode lookup and a sorted table of SCSI-3 ASC/ASCQ strings.
  *
- *  Copyright (c) 1991-2001 Steven J. Ralston
+ *  Copyright (c) 1991-2002 Steven J. Ralston
  *  Written By: Steven J. Ralston
  *  (yes I wrote some of the orig. code back in 1991!)
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: isense.c,v 1.28.14.1 2001/08/24 20:07:04 sralston Exp $
+ *  $Id: isense.c,v 1.33 2002/02/27 18:44:19 sralston Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -49,11 +50,15 @@
 */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-#include <linux/module.h>
+#include <linux/version.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/init.h>
-#include <linux/version.h>
+#include <asm/io.h>
+#if defined (__sparc__)
+#include <linux/timer.h>
+#endif
 
 /* Hmmm, avoid undefined spinlock_t on lk-2.2.14-5.0 */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
@@ -61,7 +66,7 @@
 #endif
 
 #define MODULEAUTHOR "Steven J. Ralston"
-#define COPYRIGHT "Copyright (c) 2001 " MODULEAUTHOR
+#define COPYRIGHT "Copyright (c) 2001-2002 " MODULEAUTHOR
 #include "mptbase.h"
 
 #include "isense.h"
@@ -87,7 +92,6 @@
 EXPORT_NO_SYMBOLS;
 MODULE_AUTHOR(MODULEAUTHOR);
 MODULE_DESCRIPTION(my_NAME);
-MODULE_LICENSE("GPL");
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 int __init isense_init(void)
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/linux_compat.h linux/drivers/message/fusion/linux_compat.h
--- ../ia64/linux/drivers/message/fusion/linux_compat.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/linux_compat.h	Tue Mar 19 16:05:36 2002
@@ -11,6 +11,16 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
+#ifndef rwlock_init
+#define rwlock_init(x) do { *(x) = RW_LOCK_UNLOCKED; } while(0)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#define SET_NICE(current,x)	do {(current)->nice = (x);} while (0)
+#else
+#define SET_NICE(current,x)
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 #	if LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18)
 		typedef unsigned int dma_addr_t;
@@ -58,12 +68,33 @@
 	extern inline __cleanup_module_func_t __cleanup_module_inline(void) \
 	{ return x; }
 
-#else 
+#else
 #define module_init(x)	__initcall(x);
 #define module_exit(x)	__exitcall(x);
 #endif
 /* } block snipped from lk-2.2.18/include/linux/init.h */
 
+/* This block snipped from lk-2.2.18/include/linux/sched.h { */
+/*
+ * Used prior to schedule_timeout calls..
+ */
+#define __set_current_state(state_value)	do { current->state = state_value; } while (0)
+#ifdef __SMP__
+#define set_current_state(state_value)		do { __set_current_state(state_value); mb(); } while (0)
+#else
+#define set_current_state(state_value)		__set_current_state(state_value)
+#endif
+/* } block snipped from lk-2.2.18/include/linux/sched.h */
+
+/* procfs compat stuff... */
+#define proc_mkdir(x,y)			create_proc_entry(x, S_IFDIR, y)
+
+/* MUTEX compat stuff... */
+#define DECLARE_MUTEX(name)		struct semaphore name=MUTEX
+#define DECLARE_MUTEX_LOCKED(name)	struct semaphore name=MUTEX_LOCKED
+#define init_MUTEX(x)			*(x)=MUTEX
+#define init_MUTEX_LOCKED(x)		*(x)=MUTEX_LOCKED
+
 /* Wait queues. */
 #define DECLARE_WAIT_QUEUE_HEAD(name)	\
 	struct wait_queue * (name) = NULL
@@ -90,6 +121,17 @@
 #endif		/* LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18) */
 
 
+/*
+ * Inclined to use:
+ *   #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+ * here, but MODULE_LICENSE defined in 2.4.9-6 and 2.4.9-13
+ * breaks the rule:-(
+ */
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(license)
+#endif
+
+
 /* PCI/driver subsystem { */
 #ifndef pci_for_each_dev
 #define pci_for_each_dev(dev)		for((dev)=pci_devices; (dev)!=NULL; (dev)=(dev)->next)
@@ -120,26 +162,6 @@
 #endif		/* } ifndef pci_for_each_dev */
 
 
-/* procfs compat stuff... */
-#ifdef CONFIG_PROC_FS
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,28)
-#define CREATE_PROCDIR_ENTRY(x,y)  create_proc_entry(x, S_IFDIR, y)
-/* This is a macro so we don't need to pull all the procfs
- * headers into this file. -DaveM
- */
-#define create_proc_read_entry(name, mode, base, __read_proc, __data) \
-({      struct proc_dir_entry *__res=create_proc_entry(name,mode,base); \
-        if (__res) { \
-                __res->read_proc=(__read_proc); \
-                __res->data=(__data); \
-        } \
-        __res; \
-})
-#else
-#define CREATE_PROCDIR_ENTRY(x,y)  proc_mkdir(x, y)
-#endif
-#endif
-
 /* Compatability for the 2.3.x PCI DMA API. */
 #ifndef PCI_DMA_BIDIRECTIONAL
 /*{-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -193,6 +215,7 @@
 
 /*}-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif /* PCI_DMA_BIDIRECTIONAL */
+
 
 /*}-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif /* _LINUX_COMPAT_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/fc_log.h linux/drivers/message/fusion/lsi/fc_log.h
--- ../ia64/linux/drivers/message/fusion/lsi/fc_log.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/fc_log.h	Wed Feb 27 15:25:30 2002
@@ -7,7 +7,7 @@
  *                  in the IOCLogInfo field of a MPI Default Reply Message.
  *
  *  CREATION DATE:  6/02/2000
- *  ID:             $Id: fc_log.h,v 4.5 2001/06/07 19:18:00 sschremm Exp $
+ *  ID:             $Id: fc_log.h,v 4.6 2001/07/26 14:41:33 sschremm Exp $
  */
 
 
@@ -62,7 +62,7 @@
     MPI_IOCLOGINFO_FC_TARGET_MRSP_KILLED_BY_LIP     = 0x2100000a, /* Manual Response not sent due to a LIP */
     MPI_IOCLOGINFO_FC_TARGET_NO_CLASS_3             = 0x2100000b, /* not sent because remote node does not support Class 3 */
     MPI_IOCLOGINFO_FC_TARGET_LOGIN_NOT_VALID        = 0x2100000c, /* not sent because login to remote node not validated */
-    MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND          = 0x2100000e, /* cleared from the outbound after a logout */
+    MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND          = 0x2100000e, /* cleared from the outbound queue after a logout */
     MPI_IOCLOGINFO_FC_TARGET_WAITING_FOR_DATA_IN    = 0x2100000f, /* cleared waiting for data after a logout */
 
     MPI_IOCLOGINFO_FC_LAN_BASE                      = 0x22000000,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi.h linux/drivers/message/fusion/lsi/mpi.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Message independent structures and definitions
  *  Creation Date:  July 27, 2000
  *
- *    MPI Version:  01.01.07
+ *    MPI Version:  01.02.03
  *
  *  Version History
  *  ---------------
@@ -39,6 +39,11 @@
  *                      Added function codes for RAID.
  *  04-09-01  01.01.07  Added alternate define for MPI_DOORBELL_ACTIVE,
  *                      MPI_DOORBELL_USED, to better match the spec.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *                      Changed MPI_VERSION_MINOR from 0x01 to 0x02.
+ *                      Added define MPI_FUNCTION_TOOLBOX.
+ *  09-28-01  01.02.02  New function code MPI_SCSI_ENCLOSURE_PROCESSOR.
+ *  11-01-01  01.02.03  Changed name to MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR.
  *  --------------------------------------------------------------------------
  */
 
@@ -53,7 +58,7 @@
 *****************************************************************************/
 
 #define MPI_VERSION_MAJOR                   (0x01)
-#define MPI_VERSION_MINOR                   (0x01)
+#define MPI_VERSION_MINOR                   (0x02)
 #define MPI_VERSION            ((MPI_VERSION_MAJOR << 8) | MPI_VERSION_MINOR)
 
 /* Note: The major versions of 0xe0 through 0xff are reserved */
@@ -216,8 +221,12 @@
 #define MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND       (0x13)
 #define MPI_FUNCTION_FC_PRIMITIVE_SEND              (0x14)
 
-#define MPI_FUNCTION_RAID_VOLUME                    (0x15)
+#define MPI_FUNCTION_RAID_ACTION                    (0x15)
 #define MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH       (0x16)
+
+#define MPI_FUNCTION_TOOLBOX                        (0x17)
+
+#define MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR       (0x18)
 
 #define MPI_FUNCTION_LAN_SEND                       (0x20)
 #define MPI_FUNCTION_LAN_RECEIVE                    (0x21)
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_cnfg.h linux/drivers/message/fusion/lsi/mpi_cnfg.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_cnfg.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi_cnfg.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Config message, structures, and Pages
  *  Creation Date:  July 27, 2000
  *
- *    MPI Version:  01.01.11
+ *    MPI Version:  01.02.05
  *
  *  Version History
  *  ---------------
@@ -72,6 +72,42 @@
  *                      Added IO Unit Page 3.
  *                      Modified defines for Scsi Port Page 2.
  *                      Modified RAID Volume Pages.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *                      Added SepID and SepBus to RVP2 IMPhysicalDisk struct.
+ *                      Added defines for the SEP bits in RVP2 VolumeSettings.
+ *                      Modified the DeviceSettings field in RVP2 to use the
+ *                      proper structure.
+ *                      Added defines for SES, SAF-TE, and cross channel for
+ *                      IOCPage2 CapabilitiesFlags.
+ *                      Removed define for MPI_IOUNITPAGE2_FLAGS_RAID_DISABLE.
+ *                      Removed define for
+ *                      MPI_SCSIPORTPAGE2_PORT_FLAGS_PARITY_ENABLE.
+ *                      Added define for MPI_CONFIG_PAGEATTR_RO_PERSISTENT.
+ *  08-29-01 01.02.02   Fixed value for MPI_MANUFACTPAGE_DEVID_53C1035.
+ *                      Added defines for MPI_FCPORTPAGE1_FLAGS_HARD_ALPA_ONLY
+ *                      and MPI_FCPORTPAGE1_FLAGS_IMMEDIATE_ERROR_REPLY.
+ *                      Removed MPI_SCSIPORTPAGE0_CAP_PACING_TRANSFERS,
+ *                      MPI_SCSIDEVPAGE0_NP_PACING_TRANSFERS, and
+ *                      MPI_SCSIDEVPAGE1_RP_PACING_TRANSFERS, and
+ *                      MPI_SCSIDEVPAGE1_CONF_PPR_ALLOWED.
+ *                      Added defines for MPI_SCSIDEVPAGE1_CONF_WDTR_DISALLOWED
+ *                      and MPI_SCSIDEVPAGE1_CONF_SDTR_DISALLOWED.
+ *                      Added OnBusTimerValue to CONFIG_PAGE_SCSI_PORT_1.
+ *                      Added rejected bits to SCSI Device Page 0 Information.
+ *                      Increased size of ALPA array in FC Port Page 2 by one
+ *                      and removed a one byte reserved field.
+ *  09-28-01 01.02.03   Swapped NegWireSpeedLow and NegWireSpeedLow in
+ *                      CONFIG_PAGE_LAN_1 to match preferred 64-bit ordering.
+ *                      Added structures for Manufacturing Page 4, IO Unit
+ *                      Page 3, IOC Page 3, IOC Page 4, RAID Volume Page 0, and
+ *                      RAID PhysDisk Page 0.
+ *  10-04-01 01.02.04   Added define for MPI_CONFIG_PAGETYPE_RAID_PHYSDISK.
+ *                      Modified some of the new defines to make them 32
+ *                      character unique.
+ *                      Modified how variable length pages (arrays) are defined.
+ *                      Added generic defines for hot spare pools and RAID
+ *                      volume types.
+ *  11-01-01 01.02.05   Added define for MPI_IOUNITPAGE1_DISABLE_IR.
  *  --------------------------------------------------------------------------
  */
 
@@ -104,12 +140,13 @@
   fCONFIG_PAGE_HEADER_UNION, MPI_POINTER PTR_CONFIG_PAGE_HEADER_UNION;
 
 
-/****************************************************************************/
-/*  PageType field values                                                   */
-/****************************************************************************/
+/****************************************************************************
+*   PageType field values
+****************************************************************************/
 #define MPI_CONFIG_PAGEATTR_READ_ONLY               (0x00)
 #define MPI_CONFIG_PAGEATTR_CHANGEABLE              (0x10)
 #define MPI_CONFIG_PAGEATTR_PERSISTENT              (0x20)
+#define MPI_CONFIG_PAGEATTR_RO_PERSISTENT           (0x30)
 #define MPI_CONFIG_PAGEATTR_MASK                    (0xF0)
 
 #define MPI_CONFIG_PAGETYPE_IO_UNIT                 (0x00)
@@ -122,29 +159,21 @@
 #define MPI_CONFIG_PAGETYPE_LAN                     (0x07)
 #define MPI_CONFIG_PAGETYPE_RAID_VOLUME             (0x08)
 #define MPI_CONFIG_PAGETYPE_MANUFACTURING           (0x09)
+#define MPI_CONFIG_PAGETYPE_RAID_PHYSDISK           (0x0A)
 #define MPI_CONFIG_PAGETYPE_MASK                    (0x0F)
 
 #define MPI_CONFIG_TYPENUM_MASK                     (0x0FFF)
 
 
 /****************************************************************************
- *  PageAddres field values
- ****************************************************************************/
+*   PageAddress field values
+****************************************************************************/
 #define MPI_SCSI_PORT_PGAD_PORT_MASK                (0x000000FF)
 
-#define MPI_SCSI_DEVICE_FORM_MASK                   (0xF0000000)
-#define MPI_SCSI_DEVICE_FORM_TARGETID               (0x00000000)
-#define MPI_SCSI_DEVICE_FORM_RAID_PHYS_DEV_NUM      (0x10000000)
 #define MPI_SCSI_DEVICE_TARGET_ID_MASK              (0x000000FF)
 #define MPI_SCSI_DEVICE_TARGET_ID_SHIFT             (0)
 #define MPI_SCSI_DEVICE_BUS_MASK                    (0x0000FF00)
 #define MPI_SCSI_DEVICE_BUS_SHIFT                   (8)
-#define MPI_SCSI_DEVICE_VOLUME_TARG_ID_MASK         (0x000000FF)
-#define MPI_SCSI_DEVICE_VOLUME_TARG_ID_SHIFT        (0)
-#define MPI_SCSI_DEVICE_VOLUME_BUS_MASK             (0x0000FF00)
-#define MPI_SCSI_DEVICE_VOLUME_BUS_SHIFT            (8)
-#define MPI_SCSI_DEVICE_PHYS_DISK_NUM_MASK          (0x00FF0000)
-#define MPI_SCSI_DEVICE_PHYS_DISK_NUM_SHIFT         (16)
 
 #define MPI_FC_PORT_PGAD_PORT_MASK                  (0xF0000000)
 #define MPI_FC_PORT_PGAD_PORT_SHIFT                 (28)
@@ -167,10 +196,14 @@
 #define MPI_FC_DEVICE_PGAD_BT_TID_MASK              (0x000000FF)
 #define MPI_FC_DEVICE_PGAD_BT_TID_SHIFT             (0)
 
+#define MPI_PHYSDISK_PGAD_PHYSDISKNUM_MASK          (0x000000FF)
+#define MPI_PHYSDISK_PGAD_PHYSDISKNUM_SHIFT         (0)
+
 
-/****************************************************************************/
-/*  Config Request Message                                                          */
-/****************************************************************************/
+
+/****************************************************************************
+*   Config Request Message
+****************************************************************************/
 typedef struct _MSG_CONFIG
 {
     U8                      Action;                     /* 00h */
@@ -181,16 +214,16 @@
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
     U8                      Reserved2[8];               /* 0Ch */
-   fCONFIG_PAGE_HEADER      Header;                     /* 14h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 14h */
     U32                     PageAddress;                /* 18h */
     SGE_IO_UNION            PageBufferSGE;              /* 1Ch */
 } MSG_CONFIG, MPI_POINTER PTR_MSG_CONFIG,
   Config_t, MPI_POINTER pConfig_t;
 
 
-/****************************************************************************/
-/*  Action field values                                                     */
-/****************************************************************************/
+/****************************************************************************
+*   Action field values
+****************************************************************************/
 #define MPI_CONFIG_ACTION_PAGE_HEADER               (0x00)
 #define MPI_CONFIG_ACTION_PAGE_READ_CURRENT         (0x01)
 #define MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT        (0x02)
@@ -213,7 +246,7 @@
     U8                      Reserved2[2];               /* 0Ch */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
-   fCONFIG_PAGE_HEADER      Header;                     /* 14h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 14h */
 } MSG_CONFIG_REPLY, MPI_POINTER PTR_MSG_CONFIG_REPLY,
   ConfigReply_t, MPI_POINTER pConfigReply_t;
 
@@ -225,19 +258,24 @@
 *
 *****************************************************************************/
 
-/****************************************************************************/
-/*  Manufacturing Config pages                                              */
-/****************************************************************************/
+/****************************************************************************
+*   Manufacturing Config pages
+****************************************************************************/
 #define MPI_MANUFACTPAGE_DEVICEID_FC909             (0x0621)
 #define MPI_MANUFACTPAGE_DEVICEID_FC919             (0x0624)
 #define MPI_MANUFACTPAGE_DEVICEID_FC929             (0x0622)
+#define MPI_MANUFACTPAGE_DEVICEID_FC919X            (0x0628)
+#define MPI_MANUFACTPAGE_DEVICEID_FC929X            (0x0626)
 #define MPI_MANUFACTPAGE_DEVID_53C1030              (0x0030)
 #define MPI_MANUFACTPAGE_DEVID_53C1030ZC            (0x0031)
-#define MPI_MANUFACTPAGE_DEVID_53C1035              (0x0035)
+#define MPI_MANUFACTPAGE_DEVID_1030_53C1035         (0x0032)
+#define MPI_MANUFACTPAGE_DEVID_1030ZC_53C1035       (0x0033)
+#define MPI_MANUFACTPAGE_DEVID_53C1035              (0x0040)
+#define MPI_MANUFACTPAGE_DEVID_53C1035ZC            (0x0041)
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      ChipName[16];               /* 04h */
     U8                      ChipRevision[8];            /* 14h */
     U8                      BoardName[16];              /* 1Ch */
@@ -252,7 +290,7 @@
 
 typedef struct _CONFIG_PAGE_MANUFACTURING_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      VPD[256];                   /* 04h */
 } fCONFIG_PAGE_MANUFACTURING_1, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_1,
   ManufacturingPage1_t, MPI_POINTER pManufacturingPage1_t;
@@ -269,35 +307,72 @@
   MpiChipRevisionId_t, MPI_POINTER pMpiChipRevisionId_t;
 
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_MAN_PAGE_2_HW_SETTINGS_WORDS
+#define MPI_MAN_PAGE_2_HW_SETTINGS_WORDS    (1)
+#endif
+
 typedef struct _CONFIG_PAGE_MANUFACTURING_2
 {
-   fCONFIG_PAGE_HEADER                  Header;         /* 00h */
-    MPI_CHIP_REVISION_ID                ChipId;         /* 04h */
-    U32                                 HwSettings[1];  /* 08h */
+    fCONFIG_PAGE_HEADER      Header;                                 /* 00h */
+    MPI_CHIP_REVISION_ID    ChipId;                                 /* 04h */
+    U32                     HwSettings[MPI_MAN_PAGE_2_HW_SETTINGS_WORDS];/* 08h */
 } fCONFIG_PAGE_MANUFACTURING_2, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_2,
   ManufacturingPage2_t, MPI_POINTER pManufacturingPage2_t;
 
 #define MPI_MANUFACTURING2_PAGEVERSION                  (0x00)
 
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_MAN_PAGE_3_INFO_WORDS
+#define MPI_MAN_PAGE_3_INFO_WORDS           (1)
+#endif
+
 typedef struct _CONFIG_PAGE_MANUFACTURING_3
 {
-   fCONFIG_PAGE_HEADER                  Header;         /* 00h */
-    MPI_CHIP_REVISION_ID                ChipId;         /* 04h */
-    U32                                 Info[1];        /* 08h */
+    fCONFIG_PAGE_HEADER                  Header;                     /* 00h */
+    MPI_CHIP_REVISION_ID                ChipId;                     /* 04h */
+    U32                                 Info[MPI_MAN_PAGE_3_INFO_WORDS];/* 08h */
 } fCONFIG_PAGE_MANUFACTURING_3, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_3,
   ManufacturingPage3_t, MPI_POINTER pManufacturingPage3_t;
 
 #define MPI_MANUFACTURING3_PAGEVERSION                  (0x00)
 
 
-/****************************************************************************/
-/*  IO Unit Config Pages                                                    */
-/****************************************************************************/
+typedef struct _CONFIG_PAGE_MANUFACTURING_4
+{
+    fCONFIG_PAGE_HEADER              Header;             /* 00h */
+    U32                             Reserved1;          /* 04h */
+    U8                              InfoOffset0;        /* 08h */
+    U8                              InfoSize0;          /* 09h */
+    U8                              InfoOffset1;        /* 0Ah */
+    U8                              InfoSize1;          /* 0Bh */
+    U8                              InquirySize;        /* 0Ch */
+    U8                              Reserved2;          /* 0Dh */
+    U16                             Reserved3;          /* 0Eh */
+    U8                              InquiryData[56];    /* 10h */
+    U32                             ISVolumeSettings;   /* 48h */
+    U32                             IMEVolumeSettings;  /* 4Ch */
+    U32                             IMVolumeSettings;   /* 50h */
+} fCONFIG_PAGE_MANUFACTURING_4, MPI_POINTER PTR_CONFIG_PAGE_MANUFACTURING_4,
+  ManufacturingPage4_t, MPI_POINTER pManufacturingPage4_t;
+
+#define MPI_MANUFACTURING4_PAGEVERSION                  (0x00)
+
+
+/****************************************************************************
+*   IO Unit Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_IO_UNIT_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U64                     UniqueValue;                /* 04h */
 } fCONFIG_PAGE_IO_UNIT_0, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_0,
   IOUnitPage0_t, MPI_POINTER pIOUnitPage0_t;
@@ -307,18 +382,20 @@
 
 typedef struct _CONFIG_PAGE_IO_UNIT_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
 } fCONFIG_PAGE_IO_UNIT_1, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_1,
   IOUnitPage1_t, MPI_POINTER pIOUnitPage1_t;
 
 #define MPI_IOUNITPAGE1_PAGEVERSION                     (0x00)
 
+/* IO Unit Page 1 Flags defines */
+
 #define MPI_IOUNITPAGE1_MULTI_FUNCTION                  (0x00000000)
 #define MPI_IOUNITPAGE1_SINGLE_FUNCTION                 (0x00000001)
 #define MPI_IOUNITPAGE1_MULTI_PATHING                   (0x00000002)
 #define MPI_IOUNITPAGE1_SINGLE_PATHING                  (0x00000000)
-
+#define MPI_IOUNITPAGE1_DISABLE_IR                      (0x00000040)
 #define MPI_IOUNITPAGE1_FORCE_32                        (0x00000080)
 
 
@@ -335,7 +412,7 @@
 
 typedef struct _CONFIG_PAGE_IO_UNIT_2
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U32                     BiosVersion;                /* 08h */
     MPI_ADAPTER_INFO        AdapterOrder[4];            /* 0Ch */
@@ -344,38 +421,45 @@
 
 #define MPI_IOUNITPAGE2_PAGEVERSION                     (0x00)
 
-#define MPI_IOUNITPAGE2_FLAGS_RAID_DISABLE              (0x00000001)
 #define MPI_IOUNITPAGE2_FLAGS_PAUSE_ON_ERROR            (0x00000002)
 #define MPI_IOUNITPAGE2_FLAGS_VERBOSE_ENABLE            (0x00000004)
 #define MPI_IOUNITPAGE2_FLAGS_COLOR_VIDEO_DISABLE       (0x00000008)
 #define MPI_IOUNITPAGE2_FLAGS_DONT_HOOK_INT_40          (0x00000010)
 
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IO_UNIT_PAGE_3_GPIO_VAL_MAX
+#define MPI_IO_UNIT_PAGE_3_GPIO_VAL_MAX     (1)
+#endif
+
 typedef struct _CONFIG_PAGE_IO_UNIT_3
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
-    U32                     VolumeSettings;             /* 04h */
-    U8                      InfoOffset0;                /* 08h */
-    U8                      InfoSize0;                  /* 09h */
-    U8                      InfoOffset1;                /* 0Ah */
-    U8                      InfoSize1;                  /* 0Bh */
-    U8                      InquirySize;                /* 0Ch */
-    U8                      Reserved;                   /* 0Dh */
-    U16                     Reserved2;                  /* 0Eh */
-    U8                      InquiryData[56];            /* 10h */
+    fCONFIG_PAGE_HEADER      Header;                                   /* 00h */
+    U8                      GPIOCount;                                /* 04h */
+    U8                      Reserved1;                                /* 05h */
+    U16                     Reserved2;                                /* 06h */
+    U16                     GPIOVal[MPI_IO_UNIT_PAGE_3_GPIO_VAL_MAX]; /* 08h */
 } fCONFIG_PAGE_IO_UNIT_3, MPI_POINTER PTR_CONFIG_PAGE_IO_UNIT_3,
   IOUnitPage3_t, MPI_POINTER pIOUnitPage3_t;
 
-#define MPI_IOUNITPAGE3_PAGEVERSION                     (0x00)
+#define MPI_IOUNITPAGE3_PAGEVERSION                     (0x01)
+
+#define MPI_IOUNITPAGE3_GPIO_FUNCTION_MASK              (0xFC)
+#define MPI_IOUNITPAGE3_GPIO_FUNCTION_SHIFT             (2)
+#define MPI_IOUNITPAGE3_GPIO_SETTING_OFF                (0x00)
+#define MPI_IOUNITPAGE3_GPIO_SETTING_ON                 (0x01)
 
 
-/****************************************************************************/
-/*  IOC Config Pages                                                        */
-/****************************************************************************/
+/****************************************************************************
+*   IOC Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_IOC_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     TotalNVStore;               /* 04h */
     U32                     FreeNVStore;                /* 08h */
     U16                     VendorID;                   /* 0Ch */
@@ -393,7 +477,7 @@
 
 typedef struct _CONFIG_PAGE_IOC_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U32                     CoalescingTimeout;          /* 08h */
     U8                      CoalescingDepth;            /* 0Ch */
@@ -408,53 +492,120 @@
 
 typedef struct _CONFIG_PAGE_IOC_2_RAID_VOL
 {
-    U8                      VolumeTargetID;             /* 00h */
-    U8                      VolumeBus;                  /* 01h */
-    U16                     Reserved;                   /* 02h */
-    U8                      VolumeVersionMinor;         /* 04h */
-    U8                      VolumeVersionMajor;         /* 05h */
-    U8                      VolumeRaidType;             /* 06h */
-    U8                      Reserved1;                  /* 07h */
+    U8                          VolumeID;               /* 00h */
+    U8                          VolumeBus;              /* 01h */
+    U8                          VolumeIOC;              /* 02h */
+    U8                          VolumePageNumber;       /* 03h */
+    U8                          VolumeType;             /* 04h */
+    U8                          Reserved2;              /* 05h */
+    U16                         Reserved3;              /* 06h */
 } fCONFIG_PAGE_IOC_2_RAID_VOL, MPI_POINTER PTR_CONFIG_PAGE_IOC_2_RAID_VOL,
   ConfigPageIoc2RaidVol_t, MPI_POINTER pConfigPageIoc2RaidVol_t;
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IOC_PAGE_2_RAID_VOLUME_MAX
+#define MPI_IOC_PAGE_2_RAID_VOLUME_MAX      (1)
+#endif
+
 typedef struct _CONFIG_PAGE_IOC_2
 {
-   fCONFIG_PAGE_HEADER          Header;                 /* 00h */
-    U32                         CapabilitiesFlags;      /* 04h */
-    U8                          NumActiveVolumes;       /* 08h */
-    U8                          MaxVolumes;             /* 09h */
-    U16                         Reserved;               /* 0Ah */
-   fCONFIG_PAGE_IOC_2_RAID_VOL  RaidVolume[1];          /* 0Ch */
+    fCONFIG_PAGE_HEADER          Header;                              /* 00h */
+    U32                         CapabilitiesFlags;                   /* 04h */
+    U8                          NumActiveVolumes;                    /* 08h */
+    U8                          MaxVolumes;                          /* 09h */
+    U8                          NumActivePhysDisks;                  /* 0Ah */
+    U8                          MaxPhysDisks;                        /* 0Bh */
+    fCONFIG_PAGE_IOC_2_RAID_VOL  RaidVolume[MPI_IOC_PAGE_2_RAID_VOLUME_MAX];/* 0Ch */
 } fCONFIG_PAGE_IOC_2, MPI_POINTER PTR_CONFIG_PAGE_IOC_2,
   IOCPage2_t, MPI_POINTER pIOCPage2_t;
 
-#define MPI_IOCPAGE2_PAGEVERSION                        (0x00)
+#define MPI_IOCPAGE2_PAGEVERSION                        (0x01)
 
 /* IOC Page 2 Capabilities flags */
 
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_0_SUPPORT           (0x00000001)
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_1_SUPPORT           (0x00000002)
-#define MPI_IOCPAGE2_CAP_FLAGS_LSI_MIRROR_SUPPORT       (0x00000004)
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_5_SUPPORT           (0x00000008)
-#define MPI_IOCPAGE2_CAP_FLAGS_RAID_10_SUPPORT          (0x00000010)
-
-/* IOC Page 2 Volume RAID Type values */
-
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_0                    (0x00)
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_1                    (0x01)
-#define MPI_IOCPAGE2_VOL_TYPE_LSI_MIRROR                (0x02)
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_5                    (0x05)
-#define MPI_IOCPAGE2_VOL_TYPE_RAID_10                   (0x0A)
-
-
-/****************************************************************************/
-/*  SCSI Port Config Pages                                                  */
-/****************************************************************************/
+#define MPI_IOCPAGE2_CAP_FLAGS_IS_SUPPORT               (0x00000001)
+#define MPI_IOCPAGE2_CAP_FLAGS_IME_SUPPORT              (0x00000002)
+#define MPI_IOCPAGE2_CAP_FLAGS_IM_SUPPORT               (0x00000004)
+#define MPI_IOCPAGE2_CAP_FLAGS_SES_SUPPORT              (0x20000000)
+#define MPI_IOCPAGE2_CAP_FLAGS_SAFTE_SUPPORT            (0x40000000)
+#define MPI_IOCPAGE2_CAP_FLAGS_CROSS_CHANNEL_SUPPORT    (0x80000000)
+
+/* IOC Page 2 Volume RAID Type values, also used in RAID Volume pages */
+
+#define MPI_RAID_VOL_TYPE_IS                        (0x00)
+#define MPI_RAID_VOL_TYPE_IME                       (0x01)
+#define MPI_RAID_VOL_TYPE_IM                        (0x02)
+
+
+typedef struct _IOC_3_PHYS_DISK
+{
+    U8                          PhysDiskID;             /* 00h */
+    U8                          PhysDiskBus;            /* 01h */
+    U8                          PhysDiskIOC;            /* 02h */
+    U8                          PhysDiskNum;            /* 03h */
+} IOC_3_PHYS_DISK, MPI_POINTER PTR_IOC_3_PHYS_DISK,
+  Ioc3PhysDisk_t, MPI_POINTER pIoc3PhysDisk_t;
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IOC_PAGE_3_PHYSDISK_MAX
+#define MPI_IOC_PAGE_3_PHYSDISK_MAX         (1)
+#endif
+
+typedef struct _CONFIG_PAGE_IOC_3
+{
+    fCONFIG_PAGE_HEADER          Header;                                /* 00h */
+    U8                          NumPhysDisks;                          /* 04h */
+    U8                          Reserved1;                             /* 05h */
+    U16                         Reserved2;                             /* 06h */
+    IOC_3_PHYS_DISK             PhysDisk[MPI_IOC_PAGE_3_PHYSDISK_MAX]; /* 08h */
+} fCONFIG_PAGE_IOC_3, MPI_POINTER PTR_CONFIG_PAGE_IOC_3,
+  IOCPage3_t, MPI_POINTER pIOCPage3_t;
+
+#define MPI_IOCPAGE3_PAGEVERSION                        (0x00)
+
+
+typedef struct _IOC_4_SEP
+{
+    U8                          SEPTargetID;            /* 00h */
+    U8                          SEPBus;                 /* 01h */
+    U16                         Reserved;               /* 02h */
+} IOC_4_SEP, MPI_POINTER PTR_IOC_4_SEP,
+  Ioc4Sep_t, MPI_POINTER pIoc4Sep_t;
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_IOC_PAGE_4_SEP_MAX
+#define MPI_IOC_PAGE_4_SEP_MAX              (1)
+#endif
+
+typedef struct _CONFIG_PAGE_IOC_4
+{
+    fCONFIG_PAGE_HEADER          Header;                         /* 00h */
+    U8                          ActiveSEP;                      /* 04h */
+    U8                          MaxSEP;                         /* 05h */
+    U16                         Reserved1;                      /* 06h */
+    IOC_4_SEP                   SEP[MPI_IOC_PAGE_4_SEP_MAX];    /* 08h */
+} fCONFIG_PAGE_IOC_4, MPI_POINTER PTR_CONFIG_PAGE_IOC_4,
+  IOCPage4_t, MPI_POINTER pIOCPage4_t;
+
+#define MPI_IOCPAGE4_PAGEVERSION                        (0x00)
+
+
+/****************************************************************************
+*   SCSI Port Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Capabilities;               /* 04h */
     U32                     PhysicalInterface;          /* 08h */
 } fCONFIG_PAGE_SCSI_PORT_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_0,
@@ -465,7 +616,6 @@
 #define MPI_SCSIPORTPAGE0_CAP_IU                        (0x00000001)
 #define MPI_SCSIPORTPAGE0_CAP_DT                        (0x00000002)
 #define MPI_SCSIPORTPAGE0_CAP_QAS                       (0x00000004)
-#define MPI_SCSIPORTPAGE0_CAP_PACING_TRANSFERS          (0x00000008)
 #define MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK      (0x0000FF00)
 #define MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK      (0x00FF0000)
 #define MPI_SCSIPORTPAGE0_CAP_WIDE                      (0x20000000)
@@ -479,12 +629,13 @@
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Configuration;              /* 04h */
+    U32                     OnBusTimerValue;            /* 08h */
 } fCONFIG_PAGE_SCSI_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_PORT_1,
   SCSIPortPage1_t, MPI_POINTER pSCSIPortPage1_t;
 
-#define MPI_SCSIPORTPAGE1_PAGEVERSION                   (0x01)
+#define MPI_SCSIPORTPAGE1_PAGEVERSION                   (0x02)
 
 #define MPI_SCSIPORTPAGE1_CFG_PORT_SCSI_ID_MASK         (0x000000FF)
 #define MPI_SCSIPORTPAGE1_CFG_PORT_RESPONSE_ID_MASK     (0xFFFF0000)
@@ -500,7 +651,7 @@
 
 typedef struct _CONFIG_PAGE_SCSI_PORT_2
 {
-   fCONFIG_PAGE_HEADER  Header;                         /* 00h */
+    fCONFIG_PAGE_HEADER  Header;                         /* 00h */
     U32                 PortFlags;                      /* 04h */
     U32                 PortSettings;                   /* 08h */
     MPI_DEVICE_INFO     DeviceSettings[16];             /* 0Ch */
@@ -510,7 +661,6 @@
 #define MPI_SCSIPORTPAGE2_PAGEVERSION                       (0x01)
 
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_SCAN_HIGH_TO_LOW       (0x00000001)
-#define MPI_SCSIPORTPAGE2_PORT_FLAGS_PARITY_ENABLE          (0x00000002)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_AVOID_SCSI_RESET       (0x00000004)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_ALTERNATE_CHS          (0x00000008)
 #define MPI_SCSIPORTPAGE2_PORT_FLAGS_TERMINATION_DISABLE    (0x00000010)
@@ -536,47 +686,48 @@
 #define MPI_SCSIPORTPAGE2_DEVICE_BOOT_CHOICE                (0x0020)
 
 
-/****************************************************************************/
-/*  SCSI Target Device Config Pages                                         */
-/****************************************************************************/
+/****************************************************************************
+*   SCSI Target Device Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     NegotiatedParameters;       /* 04h */
     U32                     Information;                /* 08h */
 } fCONFIG_PAGE_SCSI_DEVICE_0, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_0,
   SCSIDevicePage0_t, MPI_POINTER pSCSIDevicePage0_t;
 
-#define MPI_SCSIDEVPAGE0_PAGEVERSION                    (0x01)
+#define MPI_SCSIDEVPAGE0_PAGEVERSION                    (0x02)
 
 #define MPI_SCSIDEVPAGE0_NP_IU                          (0x00000001)
 #define MPI_SCSIDEVPAGE0_NP_DT                          (0x00000002)
 #define MPI_SCSIDEVPAGE0_NP_QAS                         (0x00000004)
-#define MPI_SCSIDEVPAGE0_NP_PACING_TRANSFERS            (0x00000008)
 #define MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK        (0x0000FF00)
 #define MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK        (0x00FF0000)
 #define MPI_SCSIDEVPAGE0_NP_WIDE                        (0x20000000)
 #define MPI_SCSIDEVPAGE0_NP_AIP                         (0x80000000)
 
 #define MPI_SCSIDEVPAGE0_INFO_PARAMS_NEGOTIATED         (0x00000001)
+#define MPI_SCSIDEVPAGE0_INFO_SDTR_REJECTED             (0x00000002)
+#define MPI_SCSIDEVPAGE0_INFO_WDTR_REJECTED             (0x00000004)
+#define MPI_SCSIDEVPAGE0_INFO_PPR_REJECTED              (0x00000008)
 
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     RequestedParameters;        /* 04h */
     U32                     Reserved;                   /* 08h */
     U32                     Configuration;              /* 0Ch */
 } fCONFIG_PAGE_SCSI_DEVICE_1, MPI_POINTER PTR_CONFIG_PAGE_SCSI_DEVICE_1,
   SCSIDevicePage1_t, MPI_POINTER pSCSIDevicePage1_t;
 
-#define MPI_SCSIDEVPAGE1_PAGEVERSION                    (0x02)
+#define MPI_SCSIDEVPAGE1_PAGEVERSION                    (0x03)
 
 #define MPI_SCSIDEVPAGE1_RP_IU                          (0x00000001)
 #define MPI_SCSIDEVPAGE1_RP_DT                          (0x00000002)
 #define MPI_SCSIDEVPAGE1_RP_QAS                         (0x00000004)
-#define MPI_SCSIDEVPAGE1_RP_PACING_TRANSFERS            (0x00000008)
 #define MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK        (0x0000FF00)
 #define MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK        (0x00FF0000)
 #define MPI_SCSIDEVPAGE1_RP_WIDE                        (0x20000000)
@@ -585,12 +736,13 @@
 #define MPI_SCSIDEVPAGE1_DV_LVD_DRIVE_STRENGTH_MASK     (0x00000003)
 #define MPI_SCSIDEVPAGE1_DV_SE_SLEW_RATE_MASK           (0x00000300)
 
-#define MPI_SCSIDEVPAGE1_CONF_PPR_ALLOWED               (0x00000001)
+#define MPI_SCSIDEVPAGE1_CONF_WDTR_DISALLOWED           (0x00000002)
+#define MPI_SCSIDEVPAGE1_CONF_SDTR_DISALLOWED           (0x00000004)
 
 
 typedef struct _CONFIG_PAGE_SCSI_DEVICE_2
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     DomainValidation;           /* 04h */
     U32                     ParityPipeSelect;           /* 08h */
     U32                     DataPipeSelect;             /* 0Ch */
@@ -629,13 +781,13 @@
 #define MPI_SCSIDEVPAGE2_DPS_BIT_15_PL_SELECT_MASK      (0xC0000000)
 
 
-/****************************************************************************/
-/*  FC Port Config Pages                                                    */
-/****************************************************************************/
+/****************************************************************************
+*   FC Port Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_FC_PORT_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U8                      MPIPortNumber;              /* 08h */
     U8                      LinkType;                   /* 09h */
@@ -715,7 +867,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_1
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Flags;                      /* 04h */
     U64                     NoSEEPROMWWNN;              /* 08h */
     U64                     NoSEEPROMWWPN;              /* 10h */
@@ -726,8 +878,10 @@
 } fCONFIG_PAGE_FC_PORT_1, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_1,
   FCPortPage1_t, MPI_POINTER pFCPortPage1_t;
 
-#define MPI_FCPORTPAGE1_PAGEVERSION                     (0x01)
+#define MPI_FCPORTPAGE1_PAGEVERSION                     (0x02)
 
+#define MPI_FCPORTPAGE1_FLAGS_EXT_FCP_STATUS_EN         (0x08000000)
+#define MPI_FCPORTPAGE1_FLAGS_IMMEDIATE_ERROR_REPLY     (0x04000000)
 #define MPI_FCPORTPAGE1_FLAGS_SORT_BY_DID               (0x00000001)
 #define MPI_FCPORTPAGE1_FLAGS_SORT_BY_WWN               (0x00000000)
 
@@ -747,22 +901,21 @@
 #define MPI_FCPORTPAGE1_LCONFIG_SPEED_10GIG             (0x03)
 #define MPI_FCPORTPAGE1_LCONFIG_SPEED_AUTO              (0x0F)
 
-#define MPI_FCPORTPAGE1_TOPOLGY_MASK                    (0x0F)
-#define MPI_FCPORTPAGE1_TOPOLGY_NLPORT                  (0x01)
-#define MPI_FCPORTPAGE1_TOPOLGY_NPORT                   (0x02)
-#define MPI_FCPORTPAGE1_TOPOLGY_AUTO                    (0x0F)
+#define MPI_FCPORTPAGE1_TOPOLOGY_MASK                   (0x0F)
+#define MPI_FCPORTPAGE1_TOPOLOGY_NLPORT                 (0x01)
+#define MPI_FCPORTPAGE1_TOPOLOGY_NPORT                  (0x02)
+#define MPI_FCPORTPAGE1_TOPOLOGY_AUTO                   (0x0F)
 
 
 typedef struct _CONFIG_PAGE_FC_PORT_2
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U8                      NumberActive;               /* 04h */
-    U8                      ALPA[126];                  /* 05h */
-    U8                      Reserved;                   /* 83h */
+    U8                      ALPA[127];                  /* 05h */
 } fCONFIG_PAGE_FC_PORT_2, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_2,
   FCPortPage2_t, MPI_POINTER pFCPortPage2_t;
 
-#define MPI_FCPORTPAGE2_PAGEVERSION                     (0x00)
+#define MPI_FCPORTPAGE2_PAGEVERSION                     (0x01)
 
 
 typedef struct _WWN_FORMAT
@@ -795,10 +948,18 @@
 #define MPI_PERSISTENT_FLAGS_BOOT_DEVICE                (0x0008)
 #define MPI_PERSISTENT_FLAGS_BY_DID                     (0x0080)
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_FC_PORT_PAGE_3_ENTRY_MAX
+#define MPI_FC_PORT_PAGE_3_ENTRY_MAX        (1)
+#endif
+
 typedef struct _CONFIG_PAGE_FC_PORT_3
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
-    FC_PORT_PERSISTENT      Entry[1];                   /* 04h */
+    fCONFIG_PAGE_HEADER      Header;                                 /* 00h */
+    FC_PORT_PERSISTENT      Entry[MPI_FC_PORT_PAGE_3_ENTRY_MAX];    /* 04h */
 } fCONFIG_PAGE_FC_PORT_3, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_3,
   FCPortPage3_t, MPI_POINTER pFCPortPage3_t;
 
@@ -807,7 +968,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_4
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     PortFlags;                  /* 04h */
     U32                     PortSettings;               /* 08h */
 } fCONFIG_PAGE_FC_PORT_4, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_4,
@@ -833,13 +994,22 @@
     U16     Reserved;                                   /* 02h */
     U64     AliasWWNN;                                  /* 04h */
     U64     AliasWWPN;                                  /* 0Ch */
-} fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
+} fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
+  MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5_ALIAS_INFO,
   FcPortPage5AliasInfo_t, MPI_POINTER pFcPortPage5AliasInfo_t;
 
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_FC_PORT_PAGE_5_ALIAS_MAX
+#define MPI_FC_PORT_PAGE_5_ALIAS_MAX        (1)
+#endif
+
 typedef struct _CONFIG_PAGE_FC_PORT_5
 {
-   fCONFIG_PAGE_HEADER                  Header;         /* 00h */
-   fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO    AliasInfo[1];   /* 04h */
+    fCONFIG_PAGE_HEADER                  Header;                     /* 00h */
+    fCONFIG_PAGE_FC_PORT_5_ALIAS_INFO    AliasInfo[MPI_FC_PORT_PAGE_5_ALIAS_MAX];/* 04h */
 } fCONFIG_PAGE_FC_PORT_5, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_5,
   FCPortPage5_t, MPI_POINTER pFCPortPage5_t;
 
@@ -851,7 +1021,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_6
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U64                     TimeSinceReset;             /* 08h */
     U64                     TxFrames;                   /* 10h */
@@ -877,7 +1047,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_7
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U8                      PortSymbolicName[256];      /* 08h */
 } fCONFIG_PAGE_FC_PORT_7, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_7,
@@ -888,7 +1058,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_8
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     BitVector[8];               /* 04h */
 } fCONFIG_PAGE_FC_PORT_8, MPI_POINTER PTR_CONFIG_PAGE_FC_PORT_8,
   FCPortPage8_t, MPI_POINTER pFCPortPage8_t;
@@ -898,7 +1068,7 @@
 
 typedef struct _CONFIG_PAGE_FC_PORT_9
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U32                     Reserved;                   /* 04h */
     U64                     GlobalWWPN;                 /* 08h */
     U64                     GlobalWWNN;                 /* 10h */
@@ -916,13 +1086,13 @@
 #define MPI_FCPORTPAGE9_PAGEVERSION                     (0x00)
 
 
-/****************************************************************************/
-/*  FC Device Config Pages                                                  */
-/****************************************************************************/
+/****************************************************************************
+*   FC Device Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_FC_DEVICE_0
 {
-   fCONFIG_PAGE_HEADER      Header;                     /* 00h */
+    fCONFIG_PAGE_HEADER      Header;                     /* 00h */
     U64                     WWNN;                       /* 04h */
     U64                     WWPN;                       /* 0Ch */
     U32                     PortIdentifier;             /* 14h */
@@ -947,112 +1117,191 @@
 #define MPI_FC_DEVICE_PAGE0_PROT_FCP_TARGET             (0x02)
 #define MPI_FC_DEVICE_PAGE0_PROT_FCP_INITIATOR          (0x04)
 
-#define MPI_FC_DEVICE_PAGE0_PGAD_PORT_MASK              (MPI_FC_DEVICE_PGAD_PORT_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_MASK              (MPI_FC_DEVICE_PGAD_FORM_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_NEXT_DID          (MPI_FC_DEVICE_PGAD_FORM_NEXT_DID)
-#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_BUS_TID           (MPI_FC_DEVICE_PGAD_FORM_BUS_TID)
-#define MPI_FC_DEVICE_PAGE0_PGAD_DID_MASK               (MPI_FC_DEVICE_PGAD_ND_DID_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_MASK               (MPI_FC_DEVICE_PGAD_BT_BUS_MASK)
-#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_SHIFT              (MPI_FC_DEVICE_PGAD_BT_BUS_SHIFT)
-#define MPI_FC_DEVICE_PAGE0_PGAD_TID_MASK               (MPI_FC_DEVICE_PGAD_BT_TID_MASK)
-
-
-/****************************************************************************/
-/*  RAID Volume Config Pages                                                  */
-/****************************************************************************/
-
-typedef struct _RAIDVOL2_IM_PHYS_ID
-{
-    U8                      TargetID;                   /* 00h */
-    U8                      Bus;                        /* 01h */
-    U8                      IocNumber;                  /* 02h */
-    U8                      PhysDiskNumber;             /* 03h */
-    U8                      Reserved[8];                /* 04h */
-    U8                      PhysicalDiskIdentifier[16]; /* 0Ch */
-    U8                      VendorId[8];                /* 1Ch */
-    U8                      ProductId[16];              /* 24h */
-    U8                      ProductRevLevel[4];         /* 34h */
-    U32                     Reserved1;                  /* 38h */
-    U8                      Info[32];                   /* 3Ch */
-} RAIDVOL2_IM_PHYS_ID, MPI_POINTER PTR_RAIDVOL2_IM_PHYS_ID,
-  RaidVol2ImPhysicalID_t, MPI_POINTER pRaidVol2ImPhysicalID_t;
-
-typedef struct _RAIDVOL2_IM_DISK_INFO
-{
-    U32                     DiskStatus;                 /* 00h */
-    U32                     DeviceSettings;             /* 04h */
-    U16                     ErrorCount;                 /* 08h */
-    U16                     Reserved;                   /* 0Ah */
-    U8                      ErrorCdbByte;               /* 0Ch */
-    U8                      ErrorSenseKey;              /* 0Dh */
-    U8                      ErrorASC;                   /* 0Eh */
-    U8                      ErrorASCQ;                  /* 0Fh */
-    U16                     SmartCount;                 /* 10h */
-    U8                      SmartASC;                   /* 12h */
-    U8                      SmartASCQ;                  /* 13h */
-} RAIDVOL2_IM_DISK_INFO, MPI_POINTER PTR_RAIDVOL2_IM_DISK_INFO,
-  RaidVol2ImDiskInfo_t, MPI_POINTER pRaidVol2ImDiskInfo_t;
+#define MPI_FC_DEVICE_PAGE0_PGAD_PORT_MASK      (MPI_FC_DEVICE_PGAD_PORT_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_MASK      (MPI_FC_DEVICE_PGAD_FORM_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_NEXT_DID  (MPI_FC_DEVICE_PGAD_FORM_NEXT_DID)
+#define MPI_FC_DEVICE_PAGE0_PGAD_FORM_BUS_TID   (MPI_FC_DEVICE_PGAD_FORM_BUS_TID)
+#define MPI_FC_DEVICE_PAGE0_PGAD_DID_MASK       (MPI_FC_DEVICE_PGAD_ND_DID_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_MASK       (MPI_FC_DEVICE_PGAD_BT_BUS_MASK)
+#define MPI_FC_DEVICE_PAGE0_PGAD_BUS_SHIFT      (MPI_FC_DEVICE_PGAD_BT_BUS_SHIFT)
+#define MPI_FC_DEVICE_PAGE0_PGAD_TID_MASK       (MPI_FC_DEVICE_PGAD_BT_TID_MASK)
+
+
+/****************************************************************************
+*   RAID Volume Config Pages
+****************************************************************************/
+
+typedef struct _RAID_VOL0_PHYS_DISK
+{
+    U16                         Reserved;               /* 00h */
+    U8                          PhysDiskMap;            /* 02h */
+    U8                          PhysDiskNum;            /* 03h */
+} RAID_VOL0_PHYS_DISK, MPI_POINTER PTR_RAID_VOL0_PHYS_DISK,
+  RaidVol0PhysDisk_t, MPI_POINTER pRaidVol0PhysDisk_t;
+
+#define MPI_RAIDVOL0_PHYSDISK_PRIMARY                   (0x01)
+#define MPI_RAIDVOL0_PHYSDISK_SECONDARY                 (0x02)
+
+typedef struct _RAID_VOL0_STATUS
+{
+    U8                          Flags;                  /* 00h */
+    U8                          State;                  /* 01h */
+    U16                         Reserved;               /* 02h */
+} RAID_VOL0_STATUS, MPI_POINTER PTR_RAID_VOL0_STATUS,
+  RaidVol0Status_t, MPI_POINTER pRaidVol0Status_t;
+
+/* RAID Volume Page 0 VolumeStatus defines */
+
+#define MPI_RAIDVOL0_STATUS_FLAG_ENABLED                (0x01)
+#define MPI_RAIDVOL0_STATUS_FLAG_QUIESCED               (0x02)
+#define MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS     (0x04)
+
+#define MPI_RAIDVOL0_STATUS_STATE_OPTIMAL               (0x00)
+#define MPI_RAIDVOL0_STATUS_STATE_DEGRADED              (0x01)
+#define MPI_RAIDVOL0_STATUS_STATE_FAILED                (0x02)
+
+typedef struct _RAID_VOL0_SETTINGS
+{
+    U16                         Settings;       /* 00h */
+    U8                          HotSparePool;   /* 01h */ /* MPI_RAID_HOT_SPARE_POOL_ */
+    U8                          Reserved;       /* 02h */
+} RAID_VOL0_SETTINGS, MPI_POINTER PTR_RAID_VOL0_SETTINGS,
+  RaidVol0Settings, MPI_POINTER pRaidVol0Settings;
+
+/* RAID Volume Page 0 VolumeSettings defines */
+
+#define MPI_RAIDVOL0_SETTING_WRITE_CACHING_ENABLE       (0x0001)
+#define MPI_RAIDVOL0_SETTING_OFFLINE_ON_SMART           (0x0002)
+#define MPI_RAIDVOL0_SETTING_AUTO_CONFIGURE             (0x0004)
+#define MPI_RAIDVOL0_SETTING_PRIORITY_RESYNC            (0x0008)
+#define MPI_RAIDVOL0_SETTING_USE_PRODUCT_ID_SUFFIX      (0x0010)
+#define MPI_RAIDVOL0_SETTING_USE_DEFAULTS               (0x8000)
+
+/* RAID Volume Page 0 HotSparePool defines, also used in RAID Physical Disk */
+#define MPI_RAID_HOT_SPARE_POOL_0                       (0x01)
+#define MPI_RAID_HOT_SPARE_POOL_1                       (0x02)
+#define MPI_RAID_HOT_SPARE_POOL_2                       (0x04)
+#define MPI_RAID_HOT_SPARE_POOL_3                       (0x08)
+#define MPI_RAID_HOT_SPARE_POOL_4                       (0x10)
+#define MPI_RAID_HOT_SPARE_POOL_5                       (0x20)
+#define MPI_RAID_HOT_SPARE_POOL_6                       (0x40)
+#define MPI_RAID_HOT_SPARE_POOL_7                       (0x80)
+
+/*
+ * Host code (drivers, BIOS, utilities, etc.) should leave this define set to
+ * one and check Header.PageLength at runtime.
+ */
+#ifndef MPI_RAID_VOL_PAGE_0_PHYSDISK_MAX
+#define MPI_RAID_VOL_PAGE_0_PHYSDISK_MAX        (1)
+#endif
+
+typedef struct _CONFIG_PAGE_RAID_VOL_0
+{
+    fCONFIG_PAGE_HEADER      Header;         /* 00h */
+    U8                      VolumeID;       /* 04h */
+    U8                      VolumeBus;      /* 05h */
+    U8                      VolumeIOC;      /* 06h */
+    U8                      VolumeType;     /* 07h */ /* MPI_RAID_VOL_TYPE_ */
+    RAID_VOL0_STATUS        VolumeStatus;   /* 08h */
+    RAID_VOL0_SETTINGS      VolumeSettings; /* 0Ch */
+    U32                     MaxLBA;         /* 10h */
+    U32                     Reserved1;      /* 14h */
+    U32                     StripeSize;     /* 18h */
+    U32                     Reserved2;      /* 1Ch */
+    U32                     Reserved3;      /* 20h */
+    U8                      NumPhysDisks;   /* 24h */
+    U8                      Reserved4;      /* 25h */
+    U16                     Reserved5;      /* 26h */
+    RAID_VOL0_PHYS_DISK     PhysDisk[MPI_RAID_VOL_PAGE_0_PHYSDISK_MAX];/* 28h */
+} fCONFIG_PAGE_RAID_VOL_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_VOL_0,
+  RaidVolumePage0_t, MPI_POINTER pRaidVolumePage0_t;
+
+#define MPI_RAIDVOLPAGE0_PAGEVERSION                    (0x00)
+
+
+/****************************************************************************
+*   RAID Physical Disk Config Pages
+****************************************************************************/
+
+typedef struct _RAID_PHYS_DISK0_ERROR_DATA
+{
+    U8                      ErrorCdbByte;               /* 00h */
+    U8                      ErrorSenseKey;              /* 01h */
+    U16                     Reserved;                   /* 02h */
+    U16                     ErrorCount;                 /* 04h */
+    U8                      ErrorASC;                   /* 06h */
+    U8                      ErrorASCQ;                  /* 07h */
+    U16                     SmartCount;                 /* 08h */
+    U8                      SmartASC;                   /* 0Ah */
+    U8                      SmartASCQ;                  /* 0Bh */
+} RAID_PHYS_DISK0_ERROR_DATA, MPI_POINTER PTR_RAID_PHYS_DISK0_ERROR_DATA,
+  RaidPhysDisk0ErrorData_t, MPI_POINTER pRaidPhysDisk0ErrorData_t;
+
+typedef struct _RAID_PHYS_DISK_INQUIRY_DATA
+{
+    U8                          VendorID[8];            /* 00h */
+    U8                          ProductID[16];          /* 08h */
+    U8                          ProductRevLevel[4];     /* 18h */
+    U8                          Info[32];               /* 1Ch */
+} RAID_PHYS_DISK0_INQUIRY_DATA, MPI_POINTER PTR_RAID_PHYS_DISK0_INQUIRY_DATA,
+  RaidPhysDisk0InquiryData, MPI_POINTER pRaidPhysDisk0InquiryData;
+
+typedef struct _RAID_PHYS_DISK0_SETTINGS
+{
+    U8              SepID;              /* 00h */
+    U8              SepBus;             /* 01h */
+    U8              HotSparePool;       /* 02h */ /* MPI_RAID_HOT_SPARE_POOL_ */
+    U8              PhysDiskSettings;   /* 03h */
+} RAID_PHYS_DISK0_SETTINGS, MPI_POINTER PTR_RAID_PHYS_DISK0_SETTINGS,
+  RaidPhysDiskSettings_t, MPI_POINTER pRaidPhysDiskSettings_t;
+
+typedef struct _RAID_PHYS_DISK0_STATUS
+{
+    U8                              Flags;              /* 00h */
+    U8                              State;              /* 01h */
+    U16                             Reserved;           /* 02h */
+} RAID_PHYS_DISK0_STATUS, MPI_POINTER PTR_RAID_PHYS_DISK0_STATUS,
+  RaidPhysDiskStatus_t, MPI_POINTER pRaidPhysDiskStatus_t;
 
 /* RAID Volume 2 IM Physical Disk DiskStatus flags */
 
-#define MPI_RVP2_PHYS_DISK_PRIMARY                      (0x00000001)
-#define MPI_RVP2_PHYS_DISK_SECONDARY                    (0x00000002)
-#define MPI_RVP2_PHYS_DISK_HOT_SPARE                    (0x00000004)
-#define MPI_RVP2_PHYS_DISK_OUT_OF_SYNC                  (0x00000008)
-#define MPI_RVP2_PHYS_DISK_STATUS_MASK                  (0x00000F00)
-#define MPI_RVP2_PHYS_DISK_STATUS_ONLINE                (0x00000000)
-#define MPI_RVP2_PHYS_DISK_STATUS_MISSING               (0x00000100)
-#define MPI_RVP2_PHYS_DISK_STATUS_NOT_COMPATIBLE        (0x00000200)
-#define MPI_RVP2_PHYS_DISK_STATUS_FAILED                (0x00000300)
-#define MPI_RVP2_PHYS_DISK_STATUS_INITIALIZING          (0x00000400)
-#define MPI_RVP2_PHYS_DISK_STATUS_OFFLINE_REQUESTED     (0x00000500)
-#define MPI_RVP2_PHYS_DISK_STATUS_OTHER_OFFLINE         (0x00000F00)
-
-
-typedef struct _RAIDVOL2_IM_PHYSICAL_DISK
-{
-    RAIDVOL2_IM_PHYS_ID     Id;                         /* 00h */
-    RAIDVOL2_IM_DISK_INFO   Info;                       /* 5Ch */
-} RAIDVOL2_IM_PHYSICAL_DISK, MPI_POINTER PTR_RAIDVOL2_IM_PHYSICAL_DISK,
-  RaidVol2ImPhysicalDisk_t, MPI_POINTER pRaidVol2ImPhysicalDisk_t;
-
-#define MPI_RAIDVOLPAGE2_MAX_DISKS                      (3)
-
-typedef struct _CONFIG_PAGE_RAID_VOL_2
-{
-   fCONFIG_PAGE_HEADER          Header;                 /* 00h */
-    U32                         VolumeStatus;           /* 04h */
-    U32                         VolumeSettings;         /* 08h */
-    U32                         Reserved;               /* 0Ch */
-    U64                         MaxLba;                 /* 10h */
-    U32                         BlockSize;              /* 18h */
-    U8                          Reserved1;              /* 1Ch */
-    U8                          NumPhysicalDisks;       /* 1Dh */
-    U16                         Reserved2;              /* 1Eh */
-    RAIDVOL2_IM_PHYSICAL_DISK   IMPhysicalDisk[MPI_RAIDVOLPAGE2_MAX_DISKS];
-} fCONFIG_PAGE_RAID_VOL_2, MPI_POINTER PTR_CONFIG_PAGE_RAID_VOL_2,
-  RaidVolumePage2_t, MPI_POINTER pRaidVolumePage2_t;
-
-#define MPI_RAIDVOLPAGE2_PAGEVERSION                    (0x00)
-
-/* RAID Volume Page 2 VolumeStatus defines */
-
-#define MPI_RAIDVOLPAGE2_STATUS_ENABLED                 (0x00000001)
-#define MPI_RAIDVOLPAGE2_STATUS_QUIESCED                (0x00000002)
-#define MPI_RAIDVOLPAGE2_STATUS_RESYNC_IN_PROGRESS      (0x00000004)
-#define MPI_RAIDVOLPAGE2_STATUS_DEGRADED                (0x00000008)
-
-/* RAID Volume Page 2 VolumeSettings defines */
-
-#define MPI_RAIDVOLPAGE2_SETTING_WRITE_CACHING_ENABLE   (0x00000001)
-#define MPI_RAIDVOLPAGE2_SETTING_OFFLINE_ON_SMART       (0x00000002)
-#define MPI_RAIDVOLPAGE2_SETTING_AUTO_CONFIGURE         (0x00000004)
-#define MPI_RAIDVOLPAGE2_SETTING_USE_DEFAULTS           (0x80000000)
-
-
-/****************************************************************************/
-/* LAN Config Pages                                                         */
-/****************************************************************************/
+#define MPI_PHYSDISK0_STATUS_FLAG_OUT_OF_SYNC           (0x01)
+#define MPI_PHYSDISK0_STATUS_FLAG_QUIESCED              (0x02)
+
+#define MPI_PHYSDISK0_STATUS_ONLINE                     (0x00)
+#define MPI_PHYSDISK0_STATUS_MISSING                    (0x01)
+#define MPI_PHYSDISK0_STATUS_NOT_COMPATIBLE             (0x02)
+#define MPI_PHYSDISK0_STATUS_FAILED                     (0x03)
+#define MPI_PHYSDISK0_STATUS_INITIALIZING               (0x04)
+#define MPI_PHYSDISK0_STATUS_OFFLINE_REQUESTED          (0x05)
+#define MPI_PHYSDISK0_STATUS_FAILED_REQUESTED           (0x06)
+#define MPI_PHYSDISK0_STATUS_OTHER_OFFLINE              (0xFF)
+
+typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_0
+{
+    fCONFIG_PAGE_HEADER              Header;             /* 00h */
+    U8                              PhysDiskID;         /* 04h */
+    U8                              PhysDiskBus;        /* 05h */
+    U8                              PhysDiskIOC;        /* 06h */
+    U8                              PhysDiskNum;        /* 07h */
+    RAID_PHYS_DISK0_SETTINGS        PhysDiskSettings;   /* 08h */
+    U32                             Reserved1;          /* 0Ch */
+    U32                             Reserved2;          /* 10h */
+    U32                             Reserved3;          /* 14h */
+    U8                              DiskIdentifier[16]; /* 18h */
+    RAID_PHYS_DISK0_INQUIRY_DATA    InquiryData;        /* 28h */
+    RAID_PHYS_DISK0_STATUS          PhysDiskStatus;     /* 64h */
+    U32                             MaxLBA;             /* 68h */
+    RAID_PHYS_DISK0_ERROR_DATA      ErrorData;          /* 6Ch */
+} fCONFIG_PAGE_RAID_PHYS_DISK_0, MPI_POINTER PTR_CONFIG_PAGE_RAID_PHYS_DISK_0,
+  RaidPhysDiskPage0_t, MPI_POINTER pRaidPhysDiskPage0_t;
+
+#define MPI_RAIDPHYSDISKPAGE0_PAGEVERSION           (0x00)
+
+
+/****************************************************************************
+*   LAN Config Pages
+****************************************************************************/
 
 typedef struct _CONFIG_PAGE_LAN_0
 {
@@ -1083,8 +1332,8 @@
     U32                     MaxWireSpeedHigh;           /* 1Ch */
     U32                     BucketsRemaining;           /* 20h */
     U32                     MaxReplySize;               /* 24h */
-    U32                     NegWireSpeedHigh;           /* 28h */
-    U32                     NegWireSpeedLow;            /* 2Ch */
+    U32                     NegWireSpeedLow;            /* 28h */
+    U32                     NegWireSpeedHigh;           /* 2Ch */
 } fCONFIG_PAGE_LAN_1, MPI_POINTER PTR_CONFIG_PAGE_LAN_1,
   LANPage1_t, MPI_POINTER pLANPage1_t;
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_fc.h linux/drivers/message/fusion/lsi/mpi_fc.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_fc.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi_fc.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Fibre Channel messages and structures
  *  Creation Date:  June 12, 2000
  *
- *    MPI Version:  01.01.07
+ *    MPI Version:  01.02.02
  *
  *  Version History
  *  ---------------
@@ -32,6 +32,9 @@
  *                      Added MPI_FC_PRIM_SEND_FLAGS_RESET_LINK define.
  *                      Added structure offset comments.
  *  04-09-01  01.01.07  Added RspLength field to MSG_LINK_SERVICE_RSP_REQUEST.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  09-28-01  01.02.02  Change name of reserved field in
+ *                      MSG_LINK_SERVICE_RSP_REPLY.
  *  --------------------------------------------------------------------------
  */
 
@@ -172,7 +175,7 @@
     U8                      MsgLength;          /* 02h */
     U8                      Function;           /* 03h */
     U16                     Reserved1;          /* 04h */
-    U8                      Reserved2;          /* 06h */
+    U8                      Reserved_0100_InitiatorIndex; /* 06h */ /* obsolete InitiatorIndex */
     U8                      MsgFlags;           /* 07h */
     U32                     MsgContext;         /* 08h */
     U16                     Reserved3;          /* 0Ch */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_init.h linux/drivers/message/fusion/lsi/mpi_init.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_init.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi_init.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI initiator mode messages and structures
  *  Creation Date:  June 8, 2000
  *
- *    MPI Version:  01.01.05
+ *    MPI Version:  01.02.04
  *
  *  Version History
  *  ---------------
@@ -22,6 +22,13 @@
  *  02-20-01  01.01.03  Started using MPI_POINTER.
  *  03-27-01  01.01.04  Added structure offset comments.
  *  04-10-01  01.01.05  Added new MsgFlag for MSG_SCSI_TASK_MGMT.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  08-29-01  01.02.02  Added MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET.
+ *                      Added MPI_SCSI_STATE_QUEUE_TAG_REJECTED for
+ *                      MSG_SCSI_IO_REPLY.
+ *  09-28-01  01.02.03  Added structures and defines for SCSI Enclosure
+ *                      Processor messages.
+ *  10-04-01  01.02.04  Added defines for SEP request Action field.
  *  --------------------------------------------------------------------------
  */
 
@@ -151,6 +158,7 @@
 #define MPI_SCSI_STATE_NO_SCSI_STATUS           (0x04)
 #define MPI_SCSI_STATE_TERMINATED               (0x08)
 #define MPI_SCSI_STATE_RESPONSE_INFO_VALID      (0x10)
+#define MPI_SCSI_STATE_QUEUE_TAG_REJECTED       (0x20)
 
 /* SCSIIO Reply ResponseInfo values */
 /* (FCP-1 RSP_CODE values and SPI-3 Packetized Failure codes) */
@@ -191,6 +199,7 @@
 #define MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET         (0x02)
 #define MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET          (0x03)
 #define MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS             (0x04)
+#define MPI_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET    (0x05)
 
 /* MsgFlags bits */
 #define MPI_SCSITASKMGMT_MSGFLAGS_TARGET_RESET_OPTION   (0x00)
@@ -215,5 +224,92 @@
     U32                     TerminationCount;   /* 14h */
 } MSG_SCSI_TASK_MGMT_REPLY, MPI_POINTER PTR_MSG_SCSI_TASK_MGMT_REPLY,
   SCSITaskMgmtReply_t, MPI_POINTER pSCSITaskMgmtReply_t;
+
+
+/****************************************************************************/
+/*  SCSI Enclosure Processor messages                                       */
+/****************************************************************************/
+
+typedef struct _MSG_SEP_REQUEST
+{
+    U8                      TargetID;           /* 00h */
+    U8                      Bus;                /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      Action;             /* 04h */
+    U8                      Reserved1;          /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     SlotStatus;         /* 0Ch */
+} MSG_SEP_REQUEST, MPI_POINTER PTR_MSG_SEP_REQUEST,
+  SEPRequest_t, MPI_POINTER pSEPRequest_t;
+
+/* Action defines */
+#define MPI_SEP_REQ_ACTION_WRITE_STATUS                 (0x00)
+#define MPI_SEP_REQ_ACTION_READ_STATUS                  (0x01)
+
+/* SlotStatus bits for MSG_SEP_REQUEST */
+#define MPI_SEP_REQ_SLOTSTATUS_NO_ERROR                 (0x00000001)
+#define MPI_SEP_REQ_SLOTSTATUS_DEV_FAULTY               (0x00000002)
+#define MPI_SEP_REQ_SLOTSTATUS_DEV_REBUILDING           (0x00000004)
+#define MPI_SEP_REQ_SLOTSTATUS_IN_FAILED_ARRAY          (0x00000008)
+#define MPI_SEP_REQ_SLOTSTATUS_IN_CRITICAL_ARRAY        (0x00000010)
+#define MPI_SEP_REQ_SLOTSTATUS_PARITY_CHECK             (0x00000020)
+#define MPI_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT          (0x00000040)
+#define MPI_SEP_REQ_SLOTSTATUS_UNCONFIGURED             (0x00000080)
+#define MPI_SEP_REQ_SLOTSTATUS_HOT_SPARE                (0x00000100)
+#define MPI_SEP_REQ_SLOTSTATUS_REBUILD_STOPPED          (0x00000200)
+#define MPI_SEP_REQ_SLOTSTATUS_IDENTIFY_REQUEST         (0x00020000)
+#define MPI_SEP_REQ_SLOTSTATUS_REQUEST_REMOVE           (0x00040000)
+#define MPI_SEP_REQ_SLOTSTATUS_REQUEST_INSERT           (0x00080000)
+#define MPI_SEP_REQ_SLOTSTATUS_DO_NOT_MOVE              (0x00400000)
+#define MPI_SEP_REQ_SLOTSTATUS_B_ENABLE_BYPASS          (0x04000000)
+#define MPI_SEP_REQ_SLOTSTATUS_A_ENABLE_BYPASS          (0x08000000)
+#define MPI_SEP_REQ_SLOTSTATUS_DEV_OFF                  (0x10000000)
+#define MPI_SEP_REQ_SLOTSTATUS_SWAP_RESET               (0x80000000)
+
+
+typedef struct _MSG_SEP_REPLY
+{
+    U8                      TargetID;           /* 00h */
+    U8                      Bus;                /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      Action;             /* 04h */
+    U8                      Reserved1;          /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     Reserved3;          /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     SlotStatus;         /* 14h */
+} MSG_SEP_REPLY, MPI_POINTER PTR_MSG_SEP_REPLY,
+  SEPReply_t, MPI_POINTER pSEPReply_t;
+
+/* SlotStatus bits for MSG_SEP_REPLY */
+#define MPI_SEP_REPLY_SLOTSTATUS_NO_ERROR               (0x00000001)
+#define MPI_SEP_REPLY_SLOTSTATUS_DEV_FAULTY             (0x00000002)
+#define MPI_SEP_REPLY_SLOTSTATUS_DEV_REBUILDING         (0x00000004)
+#define MPI_SEP_REPLY_SLOTSTATUS_IN_FAILED_ARRAY        (0x00000008)
+#define MPI_SEP_REPLY_SLOTSTATUS_IN_CRITICAL_ARRAY      (0x00000010)
+#define MPI_SEP_REPLY_SLOTSTATUS_PARITY_CHECK           (0x00000020)
+#define MPI_SEP_REPLY_SLOTSTATUS_PREDICTED_FAULT        (0x00000040)
+#define MPI_SEP_REPLY_SLOTSTATUS_UNCONFIGURED           (0x00000080)
+#define MPI_SEP_REPLY_SLOTSTATUS_HOT_SPARE              (0x00000100)
+#define MPI_SEP_REPLY_SLOTSTATUS_REBUILD_STOPPED        (0x00000200)
+#define MPI_SEP_REPLY_SLOTSTATUS_REPORT                 (0x00010000)
+#define MPI_SEP_REPLY_SLOTSTATUS_IDENTIFY_REQUEST       (0x00020000)
+#define MPI_SEP_REPLY_SLOTSTATUS_REMOVE_READY           (0x00040000)
+#define MPI_SEP_REPLY_SLOTSTATUS_INSERT_READY           (0x00080000)
+#define MPI_SEP_REPLY_SLOTSTATUS_DO_NOT_REMOVE          (0x00400000)
+#define MPI_SEP_REPLY_SLOTSTATUS_B_BYPASS_ENABLED       (0x01000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_A_BYPASS_ENABLED       (0x02000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_B_ENABLE_BYPASS        (0x04000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_A_ENABLE_BYPASS        (0x08000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_DEV_OFF                (0x10000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_FAULT_SENSED           (0x40000000)
+#define MPI_SEP_REPLY_SLOTSTATUS_SWAPPED                (0x80000000)
 
 #endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_ioc.h linux/drivers/message/fusion/lsi/mpi_ioc.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_ioc.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi_ioc.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI IOC, Port, Event, FW Download, and FW Upload messages
  *  Creation Date:  August 11, 2000
  *
- *    MPI Version:  01.01.07
+ *    MPI Version:  01.02.04
  *
  *  Version History
  *  ---------------
@@ -38,6 +38,19 @@
  *  03-27-01  01.01.06  Added defines for ProductId field of MPI_FW_HEADER.
  *                      Added structure offset comments.
  *  04-09-01  01.01.07  Added structure EVENT_DATA_EVENT_CHANGE.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *                      New format for FWVersion and ProductId in
+ *                      MSG_IOC_FACTS_REPLY and MPI_FW_HEADER.
+ *  08-31-01  01.02.02  Addded event MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE and
+ *                      related structure and defines.
+ *                      Added event MPI_EVENT_ON_BUS_TIMER_EXPIRED.
+ *                      Added MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE.
+ *                      Replaced a reserved field in MSG_IOC_FACTS_REPLY with
+ *                      IOCExceptions and changed DataImageSize to reserved.
+ *                      Added MPI_FW_DOWNLOAD_ITYPE_NVSTORE_DATA and
+ *                      MPI_FW_UPLOAD_ITYPE_NVDATA.
+ *  09-28-01  01.02.03  Modified Event Data for Integrated RAID.
+ *  11-01-01  01.02.04  Added defines for MPI_EXT_IMAGE_HEADER ImageType field.
  *  --------------------------------------------------------------------------
  */
 
@@ -73,6 +86,17 @@
 } MSG_IOC_INIT, MPI_POINTER PTR_MSG_IOC_INIT,
   IOCInit_t, MPI_POINTER pIOCInit_t;
 
+/* WhoInit values */
+#define MPI_WHOINIT_NO_ONE                      (0x00)
+#define MPI_WHOINIT_SYSTEM_BIOS                 (0x01)
+#define MPI_WHOINIT_ROM_BIOS                    (0x02)
+#define MPI_WHOINIT_PCI_PEER                    (0x03)
+#define MPI_WHOINIT_HOST_DRIVER                 (0x04)
+#define MPI_WHOINIT_MANUFACTURER                (0x05)
+
+/* Flags values */
+#define MPI_IOCINIT_FLAGS_DISCARD_FW_IMAGE      (0x01)
+
 typedef struct _MSG_IOC_INIT_REPLY
 {
     U8                      WhoInit;                    /* 00h */
@@ -90,14 +114,6 @@
 } MSG_IOC_INIT_REPLY, MPI_POINTER PTR_MSG_IOC_INIT_REPLY,
   IOCInitReply_t, MPI_POINTER pIOCInitReply_t;
 
-/* WhoInit values */
-
-#define MPI_WHOINIT_NO_ONE                      (0x00)
-#define MPI_WHOINIT_SYSTEM_BIOS                 (0x01)
-#define MPI_WHOINIT_ROM_BIOS                    (0x02)
-#define MPI_WHOINIT_PCI_PEER                    (0x03)
-#define MPI_WHOINIT_HOST_DRIVER                 (0x04)
-#define MPI_WHOINIT_MANUFACTURER                (0x05)
 
 
 /****************************************************************************/
@@ -115,8 +131,21 @@
 } MSG_IOC_FACTS, MPI_POINTER PTR_IOC_FACTS,
   IOCFacts_t, MPI_POINTER pIOCFacts_t;
 
-/* IOC Facts Reply */
+typedef struct _MPI_FW_VERSION_STRUCT
+{
+    U8                      Dev;                        /* 00h */
+    U8                      Unit;                       /* 01h */
+    U8                      Minor;                      /* 02h */
+    U8                      Major;                      /* 03h */
+} MPI_FW_VERSION_STRUCT;
+
+typedef union _MPI_FW_VERSION
+{
+    MPI_FW_VERSION_STRUCT   Struct;
+    U32                     Word;
+} MPI_FW_VERSION;
 
+/* IOC Facts Reply */
 typedef struct _MSG_IOC_FACTS_REPLY
 {
     U16                     MsgVersion;                 /* 00h */
@@ -126,7 +155,7 @@
     U8                      IOCNumber;                  /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
-    U16                     Reserved2;                  /* 0Ch */
+    U16                     IOCExceptions;              /* 0Ch */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
     U8                      MaxChainDepth;              /* 14h */
@@ -135,7 +164,7 @@
     U8                      Flags;                      /* 17h */
     U16                     ReplyQueueDepth;            /* 18h */
     U16                     RequestFrameSize;           /* 1Ah */
-    U16                     FWVersion;                  /* 1Ch */
+    U16                     Reserved_0101_FWVersion;    /* 1Ch */ /* obsolete 16-bit FWVersion */
     U16                     ProductID;                  /* 1Eh */
     U32                     CurrentHostMfaHighAddr;     /* 20h */
     U16                     GlobalCredits;              /* 24h */
@@ -146,18 +175,20 @@
     U8                      MaxDevices;                 /* 2Eh */
     U8                      MaxBuses;                   /* 2Fh */
     U32                     FWImageSize;                /* 30h */
-    U32                     DataImageSize;              /* 34h */
+    U32                     Reserved4;                  /* 34h */
+    MPI_FW_VERSION          FWVersion;                  /* 38h */
 } MSG_IOC_FACTS_REPLY, MPI_POINTER PTR_MSG_IOC_FACTS_REPLY,
   IOCFactsReply_t, MPI_POINTER pIOCFactsReply_t;
 
-#define MPI_IOCFACTS_MSGVERSION_MAJOR_MASK      (0xFF00)
-#define MPI_IOCFACTS_MSGVERSION_MINOR_MASK      (0x00FF)
+#define MPI_IOCFACTS_MSGVERSION_MAJOR_MASK          (0xFF00)
+#define MPI_IOCFACTS_MSGVERSION_MINOR_MASK          (0x00FF)
+
+#define MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL    (0x0001)
 
-#define MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT     (0x01)
-#define MPI_IOCFACTS_FLAGS_DATA_IMAGE_UPLOAD    (0x02)
+#define MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT         (0x01)
 
-#define MPI_IOCFACTS_EVENTSTATE_DISABLED        (0x00)
-#define MPI_IOCFACTS_EVENTSTATE_ENABLED         (0x01)
+#define MPI_IOCFACTS_EVENTSTATE_DISABLED            (0x00)
+#define MPI_IOCFACTS_EVENTSTATE_ENABLED             (0x01)
 
 
 
@@ -326,7 +357,6 @@
 } MSG_EVENT_ACK_REPLY, MPI_POINTER PTR_MSG_EVENT_ACK_REPLY,
   EventAckReply_t, MPI_POINTER pEventAckReply_t;
 
-
 /* Switch */
 
 #define MPI_EVENT_NOTIFICATION_SWITCH_OFF   (0x00)
@@ -345,7 +375,9 @@
 #define MPI_EVENT_LOOP_STATE_CHANGE         (0x00000008)
 #define MPI_EVENT_LOGOUT                    (0x00000009)
 #define MPI_EVENT_EVENT_CHANGE              (0x0000000A)
-#define MPI_EVENT_RAID_STATUS_CHANGE        (0x0000000B)
+#define MPI_EVENT_INTEGRATED_RAID           (0x0000000B)
+#define MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE (0x0000000C)
+#define MPI_EVENT_ON_BUS_TIMER_EXPIRED      (0x0000000D)
 
 /* AckRequired field values */
 
@@ -372,6 +404,27 @@
 } EVENT_DATA_SCSI, MPI_POINTER PTR_EVENT_DATA_SCSI,
   EventDataScsi_t, MPI_POINTER pEventDataScsi_t;
 
+/* SCSI Device Status Change Event data */
+
+typedef struct _EVENT_DATA_SCSI_DEVICE_STATUS_CHANGE
+{
+    U8                      TargetID;                   /* 00h */
+    U8                      Bus;                        /* 01h */
+    U8                      ReasonCode;                 /* 02h */
+    U8                      LUN;                        /* 03h */
+    U8                      ASC;                        /* 04h */
+    U8                      ASCQ;                       /* 05h */
+    U16                     Reserved;                   /* 06h */
+} EVENT_DATA_SCSI_DEVICE_STATUS_CHANGE,
+  MPI_POINTER PTR_EVENT_DATA_SCSI_DEVICE_STATUS_CHANGE,
+  MpiEventDataScsiDeviceStatusChange_t,
+  MPI_POINTER pMpiEventDataScsiDeviceStatusChange_t;
+
+/* MPI SCSI Device Status Change Event data ReasonCode values */
+#define MPI_EVENT_SCSI_DEV_STAT_RC_ADDED                (0x03)
+#define MPI_EVENT_SCSI_DEV_STAT_RC_NOT_RESPONDING       (0x04)
+#define MPI_EVENT_SCSI_DEV_STAT_RC_SMART_DATA           (0x05)
+
 /* MPI Link Status Change Event data */
 
 typedef struct _EVENT_DATA_LINK_STATUS
@@ -417,29 +470,34 @@
 } EVENT_DATA_LOGOUT, MPI_POINTER PTR_EVENT_DATA_LOGOUT,
   EventDataLogout_t, MPI_POINTER pEventDataLogout_t;
 
-/* MPI RAID Status Change Event data */
+/* MPI Integrated RAID Event data */
 
-typedef struct _EVENT_DATA_RAID_STATUS_CHANGE
+typedef struct _EVENT_DATA_RAID
 {
-    U8                      VolumeTargetID;             /* 00h */
+    U8                      VolumeID;                   /* 00h */
     U8                      VolumeBus;                  /* 01h */
     U8                      ReasonCode;                 /* 02h */
     U8                      PhysDiskNum;                /* 03h */
     U8                      ASC;                        /* 04h */
     U8                      ASCQ;                       /* 05h */
     U16                     Reserved;                   /* 06h */
-} EVENT_DATA_RAID_STATUS_CHANGE, MPI_POINTER PTR_EVENT_DATA_RAID_STATUS_CHANGE,
-  MpiEventDataRaidStatusChange_t, MPI_POINTER pMpiEventDataRaidStatusChange_t;
-
-
-/* MPI RAID Status Change Event data ReasonCode values */
-
-#define MPI_EVENT_RAID_DATA_RC_VOLUME_OPTIMAL       (0x00)
-#define MPI_EVENT_RAID_DATA_RC_VOLUME_DEGRADED      (0x01)
-#define MPI_EVENT_RAID_DATA_RC_STARTED_RESYNC       (0x02)
-#define MPI_EVENT_RAID_DATA_RC_DISK_ADDED           (0x03)
-#define MPI_EVENT_RAID_DATA_RC_DISK_NOT_RESPONDING  (0x04)
-#define MPI_EVENT_RAID_DATA_RC_SMART_DATA           (0x05)
+    U32                     SettingsStatus;             /* 08h */
+} EVENT_DATA_RAID, MPI_POINTER PTR_EVENT_DATA_RAID,
+  MpiEventDataRaid_t, MPI_POINTER pMpiEventDataRaid_t;
+
+/* MPI Integrated RAID Event data ReasonCode values */
+#define MPI_EVENT_RAID_RC_VOLUME_CREATED                (0x00)
+#define MPI_EVENT_RAID_RC_VOLUME_DELETED                (0x01)
+#define MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED       (0x02)
+#define MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED         (0x03)
+#define MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED       (0x04)
+#define MPI_EVENT_RAID_RC_PHYSDISK_CREATED              (0x05)
+#define MPI_EVENT_RAID_RC_PHYSDISK_DELETED              (0x06)
+#define MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED     (0x07)
+#define MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED       (0x08)
+#define MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED             (0x09)
+#define MPI_EVENT_RAID_RC_SMART_DATA                    (0x0A)
+#define MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED        (0x0B)
 
 
 /*****************************************************************************
@@ -468,6 +526,7 @@
 #define MPI_FW_DOWNLOAD_ITYPE_RESERVED      (0x00)
 #define MPI_FW_DOWNLOAD_ITYPE_FW            (0x01)
 #define MPI_FW_DOWNLOAD_ITYPE_BIOS          (0x02)
+#define MPI_FW_DOWNLOAD_ITYPE_NVDATA        (0x03)
 
 
 typedef struct _FWDownloadTCSGE
@@ -476,7 +535,7 @@
     U8                      ContextSize;                /* 01h */
     U8                      DetailsLength;              /* 02h */
     U8                      Flags;                      /* 03h */
-    U32                     Reserved1;                  /* 04h */
+    U32                     Reserved_0100_Checksum;     /* 04h */ /* obsolete Checksum */
     U32                     ImageOffset;                /* 08h */
     U32                     ImageSize;                  /* 0Ch */
 } FW_DOWNLOAD_TCSGE, MPI_POINTER PTR_FW_DOWNLOAD_TCSGE,
@@ -519,7 +578,7 @@
 #define MPI_FW_UPLOAD_ITYPE_FW_IOC_MEM      (0x00)
 #define MPI_FW_UPLOAD_ITYPE_FW_FLASH        (0x01)
 #define MPI_FW_UPLOAD_ITYPE_BIOS_FLASH      (0x02)
-#define MPI_FW_UPLOAD_ITYPE_DATA_IOC_MEM    (0x03)
+#define MPI_FW_UPLOAD_ITYPE_NVDATA          (0x03)
 
 typedef struct _FWUploadTCSGE
 {
@@ -563,11 +622,10 @@
     U32                     Checksum;                   /* 1Ch */
     U16                     VendorId;                   /* 20h */
     U16                     ProductId;                  /* 22h */
-    U16                     FwVersion;                  /* 24h */
-    U16                     Reserved1;                  /* 26h */
+    MPI_FW_VERSION          FWVersion;                  /* 24h */
     U32                     SeqCodeVersion;             /* 28h */
     U32                     ImageSize;                  /* 2Ch */
-    U32                     Reserved2;                  /* 30h */
+    U32                     NextImageHeaderOffset;      /* 30h */
     U32                     LoadStartAddress;           /* 34h */
     U32                     IopResetVectorValue;        /* 38h */
     U32                     IopResetRegAddr;            /* 3Ch */
@@ -581,30 +639,49 @@
 #define MPI_FW_HEADER_WHAT_SIGNATURE        (0x29232840)
 
 /* defines for using the ProductId field */
-#define MPI_FW_HEADER_PID_TYPE_MASK         (0xF000)
-#define MPI_FW_HEADER_PID_TYPE_SCSI         (0x0000)
-#define MPI_FW_HEADER_PID_TYPE_FC           (0x1000)
-
-#define MPI_FW_HEADER_PID_FW_VENDOR_MASK    (0x0F00)
-#define MPI_FW_HEADER_PID_FW_VENDOR_LSI     (0x0000)
-
-#define MPI_FW_HEADER_PID_FAMILY_MASK       (0x000F)
-#define MPI_FW_HEADER_PID_FAMILY_1030_SCSI  (0x0000)
-#define MPI_FW_HEADER_PID_FAMILY_909_FC     (0x0000)
-#define MPI_FW_HEADER_PID_FAMILY_919_FC     (0x0001)
-#define MPI_FW_HEADER_PID_FAMILY_919X_FC    (0x0002)
-
-
-typedef struct _MPI_DATA_HEADER
-{
-    U32                     Signature;                  /* 00h */
-    U16                     FunctionNumber;             /* 04h */
-    U16                     Length;                     /* 06h */
-    U32                     Checksum;                   /* 08h */
-    U32                     LoadStartAddress;           /* 0Ch */
-} MPI_DATA_HEADER, MPI_POINTER PTR_MPI_DATA_HEADER,
-  MpiDataHeader_t, MPI_POINTER pMpiDataHeader_t;
+#define MPI_FW_HEADER_PID_TYPE_MASK             (0xF000)
+#define MPI_FW_HEADER_PID_TYPE_SCSI             (0x0000)
+#define MPI_FW_HEADER_PID_TYPE_FC               (0x1000)
+
+#define MPI_FW_HEADER_PID_PROD_MASK                     (0x0F00)
+#define MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI           (0x0100)
+#define MPI_FW_HEADER_PID_PROD_TARGET_INITIATOR_SCSI    (0x0200)
+#define MPI_FW_HEADER_PID_PROD_TARGET_SCSI              (0x0300)
+#define MPI_FW_HEADER_PID_PROD_IM_SCSI                  (0x0400)
+#define MPI_FW_HEADER_PID_PROD_IS_SCSI                  (0x0500)
+#define MPI_FW_HEADER_PID_PROD_CTX_SCSI                 (0x0600)
+
+#define MPI_FW_HEADER_PID_FAMILY_MASK           (0x00FF)
+#define MPI_FW_HEADER_PID_FAMILY_1030A0_SCSI    (0x0001)
+#define MPI_FW_HEADER_PID_FAMILY_1030B0_SCSI    (0x0002)
+#define MPI_FW_HEADER_PID_FAMILY_1030B1_SCSI    (0x0003)
+#define MPI_FW_HEADER_PID_FAMILY_1030C0_SCSI    (0x0004)
+#define MPI_FW_HEADER_PID_FAMILY_1020A0_SCSI    (0x0005)
+#define MPI_FW_HEADER_PID_FAMILY_1020B0_SCSI    (0x0006)
+#define MPI_FW_HEADER_PID_FAMILY_1020B1_SCSI    (0x0007)
+#define MPI_FW_HEADER_PID_FAMILY_1020C0_SCSI    (0x0008)
+#define MPI_FW_HEADER_PID_FAMILY_1035A0_SCSI    (0x0009)
+#define MPI_FW_HEADER_PID_FAMILY_1035B0_SCSI    (0x000A)
+#define MPI_FW_HEADER_PID_FAMILY_909_FC         (0x0000)
+#define MPI_FW_HEADER_PID_FAMILY_919_FC         (0x0001)
+#define MPI_FW_HEADER_PID_FAMILY_919X_FC        (0x0002)
 
-#define MPI_DATA_HEADER_SIGNATURE           (0x43504147)
+typedef struct _MPI_EXT_IMAGE_HEADER
+{
+    U8                      ImageType;                  /* 00h */
+    U8                      Reserved;                   /* 01h */
+    U16                     Reserved1;                  /* 02h */
+    U32                     Checksum;                   /* 04h */
+    U32                     ImageSize;                  /* 08h */
+    U32                     NextImageHeaderOffset;      /* 0Ch */
+    U32                     LoadStartAddress;           /* 10h */
+    U32                     Reserved2;                  /* 14h */
+} MPI_EXT_IMAGE_HEADER, MPI_POINTER PTR_MPI_EXT_IMAGE_HEADER,
+  MpiExtImageHeader_t, MPI_POINTER pMpiExtImageHeader_t;
+
+/* defines for the ImageType field */
+#define MPI_EXT_IMAGE_TYPE_UNSPECIFIED          (0x00)
+#define MPI_EXT_IMAGE_TYPE_FW                   (0x01)
+#define MPI_EXT_IMAGE_TYPE_NVDATA               (0x03)
 
 #endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_lan.h linux/drivers/message/fusion/lsi/mpi_lan.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_lan.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi_lan.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI LAN messages and structures
  *  Creation Date:  June 30, 2000
  *
- *    MPI Version:  01.01.03
+ *    MPI Version:  01.02.01
  *
  *  Version History
  *  ---------------
@@ -27,6 +27,7 @@
  *  11-02-00  01.01.01  Original release for post 1.0 work
  *  02-20-01  01.01.02  Started using MPI_POINTER.
  *  03-27-01  01.01.03  Added structure offset comments.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
  *  --------------------------------------------------------------------------
  */
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_raid.h linux/drivers/message/fusion/lsi/mpi_raid.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_raid.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/lsi/mpi_raid.h	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,178 @@
+/*
+ *  Copyright (c) 2001 LSI Logic Corporation.
+ *
+ *
+ *           Name:  MPI_RAID.H
+ *          Title:  MPI RAID message and structures
+ *  Creation Date:  February 27, 2001
+ *
+ *    MPI Version:  01.02.04
+ *
+ *  Version History
+ *  ---------------
+ *
+ *  Date      Version   Description
+ *  --------  --------  ------------------------------------------------------
+ *  02-27-01  01.01.01  Original release for this file.
+ *  03-27-01  01.01.02  Added structure offset comments.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  09-28-01  01.02.02  Major rework for MPI v1.2 Integrated RAID changes.
+ *  10-04-01  01.02.03  Added ActionData defines for
+ *                      MPI_RAID_ACTION_DELETE_VOLUME action.
+ *  11-01-01  01.02.04  Added define for MPI_RAID_ACTION_ADATA_DO_NOT_SYNC.
+ *  --------------------------------------------------------------------------
+ */
+
+#ifndef MPI_RAID_H
+#define MPI_RAID_H
+
+
+/******************************************************************************
+*
+*        R A I D    M e s s a g e s
+*
+*******************************************************************************/
+
+
+/****************************************************************************/
+/* RAID Volume Request                                                      */
+/****************************************************************************/
+
+typedef struct _MSG_RAID_ACTION
+{
+    U8                      Action;             /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      VolumeID;           /* 04h */
+    U8                      VolumeBus;          /* 05h */
+    U8                      PhysDiskNum;        /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U32                     Reserved2;          /* 0Ch */
+    U32                     ActionDataWord;     /* 10h */
+    SGE_SIMPLE_UNION        ActionDataSGE;      /* 14h */
+} MSG_RAID_ACTION_REQUEST, MPI_POINTER PTR_MSG_RAID_ACTION_REQUEST,
+  MpiRaidActionRequest_t , MPI_POINTER pMpiRaidActionRequest_t;
+
+
+/* RAID Action request Action values */
+
+#define MPI_RAID_ACTION_STATUS                      (0x00)
+#define MPI_RAID_ACTION_INDICATOR_STRUCT            (0x01)
+#define MPI_RAID_ACTION_CREATE_VOLUME               (0x02)
+#define MPI_RAID_ACTION_DELETE_VOLUME               (0x03)
+#define MPI_RAID_ACTION_DISABLE_VOLUME              (0x04)
+#define MPI_RAID_ACTION_ENABLE_VOLUME               (0x05)
+#define MPI_RAID_ACTION_QUIESCE_PHYS_IO             (0x06)
+#define MPI_RAID_ACTION_ENABLE_PHYS_IO              (0x07)
+#define MPI_RAID_ACTION_CHANGE_VOLUME_SETTINGS      (0x08)
+#define MPI_RAID_ACTION_PHYSDISK_OFFLINE            (0x0A)
+#define MPI_RAID_ACTION_PHYSDISK_ONLINE             (0x0B)
+#define MPI_RAID_ACTION_CHANGE_PHYSDISK_SETTINGS    (0x0C)
+#define MPI_RAID_ACTION_CREATE_PHYSDISK             (0x0D)
+#define MPI_RAID_ACTION_DELETE_PHYSDISK             (0x0E)
+#define MPI_RAID_ACTION_FAIL_PHYSDISK               (0x0F)
+#define MPI_RAID_ACTION_REPLACE_PHYSDISK            (0x10)
+
+/* ActionDataWord defines for use with MPI_RAID_ACTION_CREATE_VOLUME action */
+#define MPI_RAID_ACTION_ADATA_DO_NOT_SYNC           (0x00000001)
+
+/* ActionDataWord defines for use with MPI_RAID_ACTION_DELETE_VOLUME action */
+#define MPI_RAID_ACTION_ADATA_KEEP_PHYS_DISKS       (0x00000000)
+#define MPI_RAID_ACTION_ADATA_DEL_PHYS_DISKS        (0x00000001)
+
+
+/* RAID Action reply message */
+
+typedef struct _MSG_RAID_ACTION_REPLY
+{
+    U8                      Action;             /* 00h */
+    U8                      Reserved;           /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      VolumeID;           /* 04h */
+    U8                      VolumeBus;          /* 05h */
+    U8                      PhysDiskNum;        /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U16                     ActionStatus;       /* 0Ch */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     VolumeStatus;       /* 14h */
+    U32                     ActionData;         /* 18h */
+} MSG_RAID_ACTION_REPLY, MPI_POINTER PTR_MSG_RAID_ACTION_REPLY,
+  MpiRaidActionReply_t, MPI_POINTER pMpiRaidActionReply_t;
+
+
+/* RAID Volume reply ActionStatus values */
+
+#define MPI_RAID_ACTION_ASTATUS_SUCCESS             (0x0000)
+#define MPI_RAID_ACTION_ASTATUS_INVALID_ACTION      (0x0001)
+#define MPI_RAID_ACTION_ASTATUS_FAILURE             (0x0002)
+#define MPI_RAID_ACTION_ASTATUS_IN_PROGRESS         (0x0003)
+
+
+/* RAID Volume reply RAID Volume Indicator structure */
+
+typedef struct _MPI_RAID_VOL_INDICATOR
+{
+    U64                     TotalBlocks;        /* 00h */
+    U64                     BlocksRemaining;    /* 08h */
+} MPI_RAID_VOL_INDICATOR, MPI_POINTER PTR_MPI_RAID_VOL_INDICATOR,
+  MpiRaidVolIndicator_t, MPI_POINTER pMpiRaidVolIndicator_t;
+
+
+/****************************************************************************/
+/* SCSI IO RAID Passthrough Request                                         */
+/****************************************************************************/
+
+typedef struct _MSG_SCSI_IO_RAID_PT_REQUEST
+{
+    U8                      PhysDiskNum;        /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      ChainOffset;        /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      CDBLength;          /* 04h */
+    U8                      SenseBufferLength;  /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U8                      LUN[8];             /* 0Ch */
+    U32                     Control;            /* 14h */
+    U8                      CDB[16];            /* 18h */
+    U32                     DataLength;         /* 28h */
+    U32                     SenseBufferLowAddr; /* 2Ch */
+    SGE_IO_UNION            SGL;                /* 30h */
+} MSG_SCSI_IO_RAID_PT_REQUEST, MPI_POINTER PTR_MSG_SCSI_IO_RAID_PT_REQUEST,
+  SCSIIORaidPassthroughRequest_t, MPI_POINTER pSCSIIORaidPassthroughRequest_t;
+
+
+/* SCSI IO RAID Passthrough reply structure */
+
+typedef struct _MSG_SCSI_IO_RAID_PT_REPLY
+{
+    U8                      PhysDiskNum;        /* 00h */
+    U8                      Reserved1;          /* 01h */
+    U8                      MsgLength;          /* 02h */
+    U8                      Function;           /* 03h */
+    U8                      CDBLength;          /* 04h */
+    U8                      SenseBufferLength;  /* 05h */
+    U8                      Reserved2;          /* 06h */
+    U8                      MsgFlags;           /* 07h */
+    U32                     MsgContext;         /* 08h */
+    U8                      SCSIStatus;         /* 0Ch */
+    U8                      SCSIState;          /* 0Dh */
+    U16                     IOCStatus;          /* 0Eh */
+    U32                     IOCLogInfo;         /* 10h */
+    U32                     TransferCount;      /* 14h */
+    U32                     SenseCount;         /* 18h */
+    U32                     ResponseInfo;       /* 1Ch */
+} MSG_SCSI_IO_RAID_PT_REPLY, MPI_POINTER PTR_MSG_SCSI_IO_RAID_PT_REPLY,
+  SCSIIORaidPassthroughReply_t, MPI_POINTER pSCSIIORaidPassthroughReply_t;
+
+
+#endif
+
+
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_targ.h linux/drivers/message/fusion/lsi/mpi_targ.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_targ.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi_targ.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Target mode messages and structures
  *  Creation Date:  June 22, 2000
  *
- *    MPI Version:  01.01.04
+ *    MPI Version:  01.02.04
  *
  *  Version History
  *  ---------------
@@ -26,6 +26,14 @@
  *                      Added structures for MPI_TARGET_SCSI_SPI_CMD_BUFFER and
  *                      MPI_TARGET_FCP_CMD_BUFFER.
  *  03-27-01  01.01.04  Added structure offset comments.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
+ *  09-28-01  01.02.02  Added structure for MPI_TARGET_SCSI_SPI_STATUS_IU.
+ *                      Added PriorityReason field to some replies and
+ *                      defined more PriorityReason codes.
+ *                      Added some defines for to support previous version
+ *                      of MPI.
+ *  10-04-01  01.02.03  Added PriorityReason to MSG_TARGET_ERROR_REPLY.
+ *  11-01-01  01.02.04  Added define for TARGET_STATUS_SEND_FLAGS_HIGH_PRIORITY.
  *  --------------------------------------------------------------------------
  */
 
@@ -78,6 +86,7 @@
 #define CMD_BUFFER_POST_FLAGS_64_BIT_ADDR       (0x80)
 
 #define CMD_BUFFER_POST_IO_INDEX_MASK           (0x00003FFF)
+#define CMD_BUFFER_POST_IO_INDEX_MASK_0100      (0x000003FF) /* obsolete */
 
 
 typedef struct _MSG_TARGET_CMD_BUFFER_POST_REPLY
@@ -97,7 +106,7 @@
 } MSG_TARGET_CMD_BUFFER_POST_REPLY, MPI_POINTER PTR_MSG_TARGET_CMD_BUFFER_POST_REPLY,
   TargetCmdBufferPostReply_t, MPI_POINTER pTargetCmdBufferPostReply_t;
 
-
+/* the following structure is obsolete as of MPI v1.2 */
 typedef struct _MSG_PRIORITY_CMD_RECEIVED_REPLY
 {
     U16                     Reserved;                   /* 00h */
@@ -117,6 +126,13 @@
 
 #define PRIORITY_REASON_NO_DISCONNECT           (0x00)
 #define PRIORITY_REASON_SCSI_TASK_MANAGEMENT    (0x01)
+#define PRIORITY_REASON_CMD_PARITY_ERR          (0x02)
+#define PRIORITY_REASON_MSG_OUT_PARITY_ERR      (0x03)
+#define PRIORITY_REASON_LQ_CRC_ERR              (0x04)
+#define PRIORITY_REASON_CMD_CRC_ERR             (0x05)
+#define PRIORITY_REASON_PROTOCOL_ERR            (0x06)
+#define PRIORITY_REASON_DATA_OUT_PARITY_ERR     (0x07)
+#define PRIORITY_REASON_DATA_OUT_CRC_ERR        (0x08)
 #define PRIORITY_REASON_UNKNOWN                 (0xFF)
 
 
@@ -129,7 +145,8 @@
     U8                      Reserved2;                  /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
-    U16                     Reserved3;                  /* 0Ch */
+    U8                      PriorityReason;             /* 0Ch */
+    U8                      Reserved3;                  /* 0Dh */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
     U32                     ReplyWord;                  /* 14h */
@@ -204,7 +221,8 @@
     U8                      Reserved2;                  /* 06h */
     U8                      MsgFlags;                   /* 07h */
     U32                     MsgContext;                 /* 08h */
-    U16                     Reserved3;                  /* 0Ch */
+    U8                      PriorityReason;             /* 0Ch */
+    U8                      Reserved3;                  /* 0Dh */
     U16                     IOCStatus;                  /* 0Eh */
     U32                     IOCLogInfo;                 /* 10h */
     U32                     ReplyWord;                  /* 14h */
@@ -234,8 +252,34 @@
   TargetStatusSendRequest_t, MPI_POINTER pTargetStatusSendRequest_t;
 
 #define TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS   (0x01)
+#define TARGET_STATUS_SEND_FLAGS_HIGH_PRIORITY      (0x04)
 #define TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER  (0x80)
 
+typedef struct _MPI_TARGET_FCP_RSP_BUFFER
+{
+    U8      Reserved0[8];                               /* 00h */
+    U8      FcpStatus;                                  /* 08h */
+    U8      FcpFlags;                                   /* 09h */
+    U8      Reserved1[2];                               /* 0Ah */
+    U32     FcpResid;                                   /* 0Ch */
+    U32     FcpSenseLength;                             /* 10h */
+    U32     FcpResponseLength;                          /* 14h */
+    U8      FcpResponseData[8];                         /* 18h */
+    U8      FcpSenseData[32]; /* Pad to 64 bytes */     /* 20h */
+} MPI_TARGET_FCP_RSP_BUFFER, MPI_POINTER PTR_MPI_TARGET_FCP_RSP_BUFFER,
+  MpiTargetFcpRspBuffer, MPI_POINTER pMpiTargetFcpRspBuffer;
+
+typedef struct _MPI_TARGET_SCSI_SPI_STATUS_IU
+{
+    U8      Reserved0;                                  /* 00h */
+    U8      Reserved1;                                  /* 01h */
+    U8      Valid;                                      /* 02h */
+    U8      Status;                                     /* 03h */
+    U32     SenseDataListLength;                        /* 04h */
+    U32     PktFailuresListLength;                      /* 08h */
+    U8      SenseData[52]; /* Pad the IU to 64 bytes */ /* 0Ch */
+} MPI_TARGET_SCSI_SPI_STATUS_IU, MPI_POINTER PTR_MPI_TARGET_SCSI_SPI_STATUS_IU,
+  TargetScsiSpiStatusIU_t, MPI_POINTER pTargetScsiSpiStatusIU_t;
 
 /****************************************************************************/
 /* Target Mode Abort Request                                                */
@@ -323,6 +367,41 @@
 #define SET_PORT(t, p)  ((t) = ((t) & ~TARGET_MODE_REPLY_PORT_MASK) |          \
                                     (((p) << TARGET_MODE_REPLY_PORT_SHIFT) &   \
                                                   TARGET_MODE_REPLY_PORT_MASK))
+
+/* the following obsolete values are for MPI v1.0 support */
+#define TARGET_MODE_REPLY_0100_MASK_HOST_INDEX       (0x000003FF)
+#define TARGET_MODE_REPLY_0100_SHIFT_HOST_INDEX      (0)
+#define TARGET_MODE_REPLY_0100_MASK_IOC_INDEX        (0x001FF800)
+#define TARGET_MODE_REPLY_0100_SHIFT_IOC_INDEX       (11)
+#define TARGET_MODE_REPLY_0100_PORT_MASK             (0x00400000)
+#define TARGET_MODE_REPLY_0100_PORT_SHIFT            (22)
+#define TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX  (0x1F800000)
+#define TARGET_MODE_REPLY_0100_SHIFT_INITIATOR_INDEX (23)
+
+#define GET_HOST_INDEX_0100(x) (((x) & TARGET_MODE_REPLY_0100_MASK_HOST_INDEX) \
+                                  >> TARGET_MODE_REPLY_0100_SHIFT_HOST_INDEX)
+
+#define SET_HOST_INDEX_0100(t, hi)                                             \
+            ((t) = ((t) & ~TARGET_MODE_REPLY_0100_MASK_HOST_INDEX) |           \
+                         (((hi) << TARGET_MODE_REPLY_0100_SHIFT_HOST_INDEX) &  \
+                                      TARGET_MODE_REPLY_0100_MASK_HOST_INDEX))
+
+#define GET_IOC_INDEX_0100(x)   (((x) & TARGET_MODE_REPLY_0100_MASK_IOC_INDEX) \
+                                  >> TARGET_MODE_REPLY_0100_SHIFT_IOC_INDEX)
+
+#define SET_IOC_INDEX_0100(t, ii)                                              \
+            ((t) = ((t) & ~TARGET_MODE_REPLY_0100_MASK_IOC_INDEX) |            \
+                        (((ii) << TARGET_MODE_REPLY_0100_SHIFT_IOC_INDEX) &    \
+                                     TARGET_MODE_REPLY_0100_MASK_IOC_INDEX))
+
+#define GET_INITIATOR_INDEX_0100(x)                                            \
+            (((x) & TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX)               \
+                              >> TARGET_MODE_REPLY_0100_SHIFT_INITIATOR_INDEX)
+
+#define SET_INITIATOR_INDEX_0100(t, ii)                                        \
+        ((t) = ((t) & ~TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX) |          \
+                   (((ii) << TARGET_MODE_REPLY_0100_SHIFT_INITIATOR_INDEX) &   \
+                                TARGET_MODE_REPLY_0100_MASK_INITIATOR_INDEX))
 
 
 #endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/lsi/mpi_type.h linux/drivers/message/fusion/lsi/mpi_type.h
--- ../ia64/linux/drivers/message/fusion/lsi/mpi_type.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/lsi/mpi_type.h	Wed Feb 27 15:25:30 2002
@@ -6,7 +6,7 @@
  *          Title:  MPI Basic type definitions
  *  Creation Date:  June 6, 2000
  *
- *    MPI Version:  01.01.02
+ *    MPI Version:  01.02.01
  *
  *  Version History
  *  ---------------
@@ -17,6 +17,7 @@
  *  06-06-00  01.00.01  Update version number for 1.0 release.
  *  11-02-00  01.01.01  Original release for post 1.0 work
  *  02-20-01  01.01.02  Added define and ifdef for MPI_POINTER.
+ *  08-08-01  01.02.01  Original release for v1.2 work.
  *  --------------------------------------------------------------------------
  */
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptbase.c linux/drivers/message/fusion/mptbase.c
--- ../ia64/linux/drivers/message/fusion/mptbase.c	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/mptbase.c	Tue Mar 19 16:05:36 2002
@@ -20,6 +20,12 @@
  *      And to Roger Hickerson (LSI Logic) for tirelessly supporting
  *      this driver project.
  *
+ *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
+ *      and countless enhancements while adding support for the 1030
+ *      chip family.  Pam has been instrumental in the development of
+ *      of the 2.xx.xx series fusion drivers, and her contributions are
+ *      far too numerous to hope to list in one place.
+ *
  *      All manner of help from Stephen Shirron (LSI Logic):
  *      low-level FC analysis, debug + various fixes in FCxx firmware,
  *      initial port to alpha platform, various driver code optimizations,
@@ -38,11 +44,12 @@
  *      for gobs of hard work fixing and optimizing LAN code.
  *      THANK YOU!
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptbase.c,v 1.53.4.3 2001/09/18 03:54:54 sralston Exp $
+ *  $Id: mptbase.c,v 1.110 2002/02/27 18:44:20 sralston Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -93,11 +100,14 @@
 #include <linux/kdev_t.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
-#include <linux/proc_fs.h>
+#include <linux/interrupt.h>		/* needed for in_interrupt() proto */
 #include <asm/io.h>
 #ifdef CONFIG_MTRR
 #include <asm/mtrr.h>
 #endif
+#ifdef __sparc__
+#include <asm/irq.h>			/* needed for __irq_itoa() proto */
+#endif
 
 #include "mptbase.h"
 
@@ -110,27 +120,33 @@
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
-
 /*
  *  cmd line parameters
  */
 MODULE_PARM(PortIo, "0-1i");
 MODULE_PARM_DESC(PortIo, "[0]=Use mmap, 1=Use port io");
-MODULE_PARM(HardReset, "0-1i");
-MODULE_PARM_DESC(HardReset, "0=Disable HardReset, [1]=Enable HardReset");
 static int PortIo = 0;
-static int HardReset = 1;
+
+#ifdef MFCNT
+static int mfcounter = 0;
+#define PRINT_MF_COUNT 20000
+#endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Public data...
  */
-int mpt_lan_index = 0;
-int mpt_stm_index = 0;
+int mpt_lan_index = -1;
+int mpt_stm_index = -1;
+
+struct proc_dir_entry *mpt_proc_root_dir;
+
+DmpServices_t *DmpService;
+
+void *mpt_v_ASCQ_TablePtr;
+const char **mpt_ScsiOpcodesPtr;
+int mpt_ASCQ_TableSz;
 
-void *mpt_v_ASCQ_TablePtr = NULL;
-const char **mpt_ScsiOpcodesPtr = NULL;
-int mpt_ASCQ_TableSz = 0;
 
 #define WHOINIT_UNKNOWN		0xAA
 
@@ -139,12 +155,12 @@
  *  Private data...
  */
 					/* Adapter lookup table */
-static MPT_ADAPTER		*mpt_adapters[MPT_MAX_ADAPTERS] = {0};
+       MPT_ADAPTER		*mpt_adapters[MPT_MAX_ADAPTERS];
 static MPT_ADAPTER_TRACKER	 MptAdapters;
 					/* Callback lookup table */
 static MPT_CALLBACK		 MptCallbacks[MPT_MAX_PROTOCOL_DRIVERS];
 					/* Protocol driver class lookup table */
-static int	 		 MptDriverClass[MPT_MAX_PROTOCOL_DRIVERS];
+static int			 MptDriverClass[MPT_MAX_PROTOCOL_DRIVERS];
 					/* Event handler lookup table */
 static MPT_EVHANDLER		 MptEvHandlers[MPT_MAX_PROTOCOL_DRIVERS];
 					/* Reset handler lookup table */
@@ -152,6 +168,10 @@
 
 static int	FusionInitCalled = 0;
 static int	mpt_base_index = -1;
+static int	last_drv_idx = -1;
+static int	isense_idx = -1;
+
+static DECLARE_WAIT_QUEUE_HEAD(mpt_waitq);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -160,49 +180,84 @@
 static void	mpt_interrupt(int irq, void *bus_id, struct pt_regs *r);
 static int	mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);
 
-static int 	mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason);
-static int 	mpt_adapter_install(struct pci_dev *pdev);
-static void	mpt_detect_929_bound_ports(MPT_ADAPTER *this, struct pci_dev *pdev);
+static int	mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag);
+static int	mpt_adapter_install(struct pci_dev *pdev);
+static void	mpt_detect_bound_ports(MPT_ADAPTER *this, struct pci_dev *pdev);
 static void	mpt_adapter_disable(MPT_ADAPTER *ioc, int freeup);
 static void	mpt_adapter_dispose(MPT_ADAPTER *ioc);
 
 static void	MptDisplayIocCapabilities(MPT_ADAPTER *ioc);
-static int	MakeIocReady(MPT_ADAPTER *ioc, int force);
-static u32	GetIocState(MPT_ADAPTER *ioc, int cooked);
-static int	GetIocFacts(MPT_ADAPTER *ioc);
-static int	GetPortFacts(MPT_ADAPTER *ioc, int portnum);
-static int	SendIocInit(MPT_ADAPTER *ioc);
-static int	SendPortEnable(MPT_ADAPTER *ioc, int portnum);
-static int	mpt_fc9x9_reset(MPT_ADAPTER *ioc, int ignore);
-static int	KickStart(MPT_ADAPTER *ioc, int ignore);
-static int	SendIocReset(MPT_ADAPTER *ioc, u8 reset_type);
+static int	MakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag);
+//static u32	mpt_GetIocState(MPT_ADAPTER *ioc, int cooked);
+static int	GetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason);
+static int	GetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag);
+static int	SendIocInit(MPT_ADAPTER *ioc, int sleepFlag);
+static int	SendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag);
+static int	mpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag);
+static int	mpt_downloadboot(MPT_ADAPTER *ioc, int sleepFlag);
+static int	mpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag);
+static int	KickStart(MPT_ADAPTER *ioc, int ignore, int sleepFlag);
+static int	SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag);
 static int	PrimeIocFifos(MPT_ADAPTER *ioc);
-static int	HandShakeReqAndReply(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait);
-static int	WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong);
-static int	WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong);
-static int	WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong);
+static int	WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag);
+static int	WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag);
+static int	WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag);
 static int	GetLanConfigPages(MPT_ADAPTER *ioc);
+static int	GetFcPortPage0(MPT_ADAPTER *ioc, int portnum);
+static int	GetIoUnitPage2(MPT_ADAPTER *ioc);
+static int	mpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum);
+static int	mpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum);
+static int	mpt_findImVolumes(MPT_ADAPTER *ioc);
+static void	mpt_timer_expired(unsigned long data);
 static int	SendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch);
 static int	SendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp);
 
-static int	procmpt_create(void);
 #ifdef CONFIG_PROC_FS
+static int	procmpt_create(void);
 static int	procmpt_destroy(void);
+static int	procmpt_summary_read(char *buf, char **start, off_t offset,
+				int request, int *eof, void *data);
+static int	procmpt_version_read(char *buf, char **start, off_t offset,
+				int request, int *eof, void *data);
+static int	procmpt_iocinfo_read(char *buf, char **start, off_t offset,
+				int request, int *eof, void *data);
 #endif
-static int	procmpt_read_summary(char *page, char **start, off_t off, int count, int *eof, void *data);
-static int	procmpt_read_dbg(char *page, char **start, off_t off, int count, int *eof, void *data);
-/*static int	procmpt_info(char *buf, char **start, off_t offset, int len);*/
+static void	mpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc);
 
+//int		mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag);
 static int	ProcessEventNotification(MPT_ADAPTER *ioc, EventNotificationReply_t *evReply, int *evHandlers);
 static void	mpt_fc_log_info(MPT_ADAPTER *ioc, u32 log_info);
 static void	mpt_sp_log_info(MPT_ADAPTER *ioc, u32 log_info);
 
-static struct proc_dir_entry	*procmpt_root_dir = NULL;
-
 int		fusion_init(void);
 static void	fusion_exit(void);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  more Private data...
+ */
+#ifdef CONFIG_PROC_FS
+struct _mpt_proc_list {
+	const char	*name;
+	int		(*f)(char *, char **, off_t, int, int *, void *);
+} mpt_proc_list[] = {
+	{ "summary", procmpt_summary_read},
+	{ "version", procmpt_version_read},
+};
+#define MPT_PROC_ENTRIES (sizeof(mpt_proc_list)/sizeof(mpt_proc_list[0]))
+
+struct _mpt_ioc_proc_list {
+	const char	*name;
+	int		(*f)(char *, char **, off_t, int, int *, void *);
+} mpt_ioc_proc_list[] = {
+	{ "info", procmpt_iocinfo_read},
+	{ "summary", procmpt_summary_read},
+};
+#define MPT_IOC_PROC_ENTRIES (sizeof(mpt_ioc_proc_list)/sizeof(mpt_ioc_proc_list[0]))
+
+#endif
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /* 20000207 -sralston
  *  GRRRRR...  IOSpace (port i/o) register access (for the 909) is back!
  * 20000517 -sralston
@@ -225,9 +280,18 @@
 		writel(v, a);
 }
 
+static inline void CHIPREG_PIO_WRITE32(volatile u32 *a, u32 v)
+{
+	outl(v, (unsigned long)a);
+}
+
+static inline u32 CHIPREG_PIO_READ32(volatile u32 *a)
+{
+	return inl((unsigned long)a);
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_interrupt - MPT adapter (IOC) specific interrupt handler.
  *	@irq: irq number (not used)
  *	@bus_id: bus identifier cookie == pointer to MPT_ADAPTER structure
@@ -252,8 +316,7 @@
 	MPT_FRAME_HDR	*mf;
 	MPT_FRAME_HDR	*mr;
 	u32		 pa;
-	u32		*m;
-	int		 req_idx;
+	int		 req_idx = -1;
 	int		 cb_idx;
 	int		 type;
 	int		 freeme;
@@ -262,6 +325,21 @@
 	ioc = bus_id;
 
 	/*
+	 * Verify ioc pointer is ok
+	 */
+	{
+		MPT_ADAPTER	*iocCmp;
+		iocCmp = mpt_adapter_find_first();
+		while ((ioc != iocCmp)  && iocCmp)
+			iocCmp = mpt_adapter_find_next(iocCmp);
+
+		if (!iocCmp) {
+			printk(KERN_WARNING "mpt_interrupt: Invalid ioc!\n");
+			return;
+		}
+	}
+
+	/*
 	 *  Drain the reply FIFO!
 	 *
 	 * NOTES: I've seen up to 10 replies processed in this loop, so far...
@@ -281,25 +359,27 @@
 		 *  Check for non-TURBO reply!
 		 */
 		if (pa & MPI_ADDRESS_REPLY_A_BIT) {
-			dma_addr_t reply_dma_addr;
+			u32 reply_dma_low;
 			u16 ioc_stat;
 
 			/* non-TURBO reply!  Hmmm, something may be up...
 			 *  Newest turbo reply mechanism; get address
 			 *  via left shift 1 (get rid of MPI_ADDRESS_REPLY_A_BIT)!
 			 */
-			reply_dma_addr = (pa = (pa << 1));
 
-			/* Map DMA address of reply header to cpu address. */
-			m = (u32 *) ((u8 *)ioc->reply_frames +
-					(reply_dma_addr - ioc->reply_frames_dma));
+			/* Map DMA address of reply header to cpu address.
+			 * pa is 32 bits - but the dma address may be 32 or 64 bits
+			 * get offset based only only the low addresses
+			 */
+			reply_dma_low = (pa = (pa << 1));
+			mr = (MPT_FRAME_HDR *)((u8 *)ioc->reply_frames +
+					 (reply_dma_low - ioc->reply_frames_low_dma));
 
-			mr = (MPT_FRAME_HDR *) m;
 			req_idx = le16_to_cpu(mr->u.frame.hwhdr.msgctxu.fld.req_idx);
 			cb_idx = mr->u.frame.hwhdr.msgctxu.fld.cb_idx;
 			mf = MPT_INDEX_2_MFPTR(ioc, req_idx);
 
-			dprintk((KERN_INFO MYNAM ": %s: Got non-TURBO reply=%p\n",
+			dprintk((MYIOC_s_INFO_FMT "Got non-TURBO reply=%p\n",
 					ioc->name, mr));
 			DBG_DUMP_REPLY_FRAME(mr)
 
@@ -307,7 +387,7 @@
 			 *  Check/log IOC log info
 			 */
 			ioc_stat = le16_to_cpu(mr->u.reply.IOCStatus);
-	 		if (ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
+			if (ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
 				u32	 log_info = le32_to_cpu(mr->u.reply.IOCLogInfo);
 				if ((int)ioc->chip_type <= (int)FC929)
 					mpt_fc_log_info(ioc, log_info);
@@ -318,7 +398,7 @@
 			/*
 			 *  Process turbo (context) reply...
 			 */
-			dirqprintk((KERN_INFO MYNAM ": %s: Got TURBO reply(=%08x)\n", ioc->name, pa));
+			dirqprintk((MYIOC_s_INFO_FMT "Got TURBO reply(=%08x)\n", ioc->name, pa));
 			type = (pa >> MPI_CONTEXT_REPLY_TYPE_SHIFT);
 			if (type == MPI_CONTEXT_REPLY_TYPE_SCSI_TARGET) {
 				cb_idx = mpt_stm_index;
@@ -357,6 +437,34 @@
 			pa = 0;					/* No reply flush! */
 		}
 
+		if ((int)ioc->chip_type > (int)FC929) {
+			/* Verify mf, mf are reasonable.
+			 */
+			if ((mf) && ((mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))
+				|| (mf < ioc->req_frames)) ) {
+				printk(MYIOC_s_WARN_FMT 
+					"mpt_interrupt: Invalid mf (%p) req_idx (%d)!\n", ioc->name, mf, req_idx);
+				cb_idx = 0;
+				pa = 0;
+				freeme = 0;
+			}
+			if ((pa) && (mr) && ((mr >= MPT_INDEX_2_RFPTR(ioc, ioc->req_depth))
+				|| (mr < ioc->reply_frames)) ) {
+				printk(MYIOC_s_WARN_FMT 
+					"mpt_interrupt: Invalid rf (%p)!\n", ioc->name, mr);
+				cb_idx = 0;
+				pa = 0;
+				freeme = 0;
+			}
+			if (cb_idx > (MPT_MAX_PROTOCOL_DRIVERS-1)) {
+				printk(MYIOC_s_WARN_FMT 
+					"mpt_interrupt: Invalid cb_idx (%d)!\n", ioc->name, cb_idx);
+				cb_idx = 0;
+				pa = 0;
+				freeme = 0;
+			}
+		}
+
 		/*  Check for (valid) IO callback!  */
 		if (cb_idx) {
 			/*  Do the callback!  */
@@ -374,15 +482,18 @@
 			/*  Put Request back on FreeQ!  */
 			spin_lock_irqsave(&ioc->FreeQlock, flags);
 			Q_ADD_TAIL(&ioc->FreeQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+#ifdef MFCNT
+			ioc->mfcnt--;
+#endif
 			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 		}
 
 		count++;
-		dirqprintk((KERN_INFO MYNAM ": %s: ISR processed frame #%d\n", ioc->name, count));
+		dirqprintk((MYIOC_s_INFO_FMT "ISR processed frame #%d\n", ioc->name, count));
 		mb();
 
 		if (count >= MPT_MAX_REPLIES_PER_ISR) {
-			dirqprintk((KERN_INFO MYNAM ": %s: ISR processed %d replies.",
+			dirqprintk((MYIOC_s_INFO_FMT "ISR processed %d replies.",
 					ioc->name, count));
 			dirqprintk((" Giving this ISR a break!\n"));
 			return;
@@ -409,17 +520,17 @@
 	int freereq = 1;
 	u8 func;
 
-	dprintk((KERN_INFO MYNAM ": %s: mpt_base_reply() called\n", ioc->name));
+	dprintk((MYIOC_s_INFO_FMT "mpt_base_reply() called\n", ioc->name));
 
 	if ((mf == NULL) ||
 	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(KERN_ERR MYNAM ": %s: ERROR - NULL or BAD request frame ptr! (=%p)\n",
+		printk(MYIOC_s_ERR_FMT "NULL or BAD request frame ptr! (=%p)\n",
 				ioc->name, mf);
 		return 1;
 	}
 
 	if (reply == NULL) {
-		dprintk((KERN_ERR MYNAM ": %s: ERROR - Unexpected NULL Event (turbo?) reply!\n",
+		dprintk((MYIOC_s_ERR_FMT "Unexpected NULL Event (turbo?) reply!\n",
 				ioc->name));
 		return 1;
 	}
@@ -430,7 +541,7 @@
 	}
 
 	func = reply->u.hdr.Function;
-	dprintk((KERN_INFO MYNAM ": %s: mpt_base_reply, Function=%02Xh\n",
+	dprintk((MYIOC_s_INFO_FMT "mpt_base_reply, Function=%02Xh\n",
 			ioc->name, func));
 
 	if (func == MPI_FUNCTION_EVENT_NOTIFICATION) {
@@ -441,30 +552,77 @@
 		results = ProcessEventNotification(ioc, pEvReply, &evHandlers);
 		if (results != evHandlers) {
 			/* CHECKME! Any special handling needed here? */
-			dprintk((KERN_WARNING MYNAM ": %s: Hmmm... Called %d event handlers, sum results = %d\n",
+			dprintk((MYIOC_s_WARN_FMT "Called %d event handlers, sum results = %d\n",
 					ioc->name, evHandlers, results));
 		}
 
 		/*
-		 *  Hmmm...  It seems that EventNotificationReply is an exception
-		 *  to the rule of one reply per request.
+		 *	Hmmm...  It seems that EventNotificationReply is an exception
+		 *	to the rule of one reply per request.
 		 */
 		if (pEvReply->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY)
 			freereq = 0;
+
 #ifdef CONFIG_PROC_FS
 //		LogEvent(ioc, pEvReply);
 #endif
+
 	} else if (func == MPI_FUNCTION_EVENT_ACK) {
-		dprintk((KERN_INFO MYNAM ": %s: mpt_base_reply, EventAck reply received\n",
+		dprintk((MYIOC_s_INFO_FMT "mpt_base_reply, EventAck reply received\n",
 				ioc->name));
+	} else if (func == MPI_FUNCTION_CONFIG) {
+		CONFIGPARMS *pCfg;
+		unsigned long flags;
+
+		dprintk((MYIOC_s_INFO_FMT "config_complete (mf=%p,mr=%p)\n",
+				ioc->name, mf, reply));
+
+		pCfg = * ((CONFIGPARMS **)((u8 *) mf + ioc->req_sz - sizeof(void *)));
+
+		if (pCfg) {
+			/* disable timer and remove from linked list */
+			del_timer(&pCfg->timer);
+
+			spin_lock_irqsave(&ioc->FreeQlock, flags);
+			Q_DEL_ITEM(&pCfg->linkage);
+			spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+			/*
+			 *	If IOC Status is SUCCESS, save the header
+			 *	and set the status code to GOOD.
+			 */
+			pCfg->status = MPT_CONFIG_ERROR;
+			if (reply) {
+				ConfigReply_t	*pReply = (ConfigReply_t *)reply;
+				u16		 status;
+
+				status = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+				dprintk((KERN_NOTICE "  IOCStatus=%04xh, IOCLogInfo=%08xh\n",
+				     status, le32_to_cpu(pReply->IOCLogInfo)));
+
+				pCfg->status = status;
+				if (status == MPI_IOCSTATUS_SUCCESS) {
+					pCfg->hdr->PageVersion = pReply->Header.PageVersion;
+					pCfg->hdr->PageLength = pReply->Header.PageLength;
+					pCfg->hdr->PageNumber = pReply->Header.PageNumber;
+					pCfg->hdr->PageType = pReply->Header.PageType;
+				}
+			}
+
+			/*
+			 *	Wake up the original calling thread
+			 */
+			pCfg->wait_done = 1;
+			wake_up(&mpt_waitq);
+		}
 	} else {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Unexpected msg function (=%02Xh) reply received!\n",
+		printk(MYIOC_s_ERR_FMT "Unexpected msg function (=%02Xh) reply received!\n",
 				ioc->name, func);
 	}
 
 	/*
-	 *  Conditionally tell caller to free the original
-	 *  EventNotification/EventAck/unexpected request frame!
+	 *	Conditionally tell caller to free the original
+	 *	EventNotification/EventAck/unexpected request frame!
 	 */
 	return freereq;
 }
@@ -480,21 +638,22 @@
  *	protocol-specific driver must do this before it will be able to
  *	use any IOC resources, such as obtaining request frames.
  *
- *	NOTES: The SCSI protocol driver currently calls this routine twice
- *	in order to register separate callbacks; one for "normal" SCSI IO
- *	and another for MptScsiTaskMgmt requests.
+ *	NOTES: The SCSI protocol driver currently calls this routine thrice
+ *	in order to register separate callbacks; one for "normal" SCSI IO;
+ *	one for MptScsiTaskMgmt requests; one for Scan/DV requests.
  *
  *	Returns a positive integer valued "handle" in the
- *	range (and S.O.D. order) {7,6,...,1} if successful.
+ *	range (and S.O.D. order) {N,...,7,6,5,...,1} if successful.
  *	Any non-positive return value (including zero!) should be considered
  *	an error by the caller.
  */
 int
 mpt_register(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass)
 {
-	int r = -1;
 	int i;
 
+	last_drv_idx = -1;
+
 #ifndef MODULE
 	/*
 	 *  Handle possibility of the mptscsih_detect() routine getting
@@ -512,7 +671,7 @@
 #endif
 
 	/*
-	 *  Search for empty callback slot in this order: {7,6,...,1}
+	 *  Search for empty callback slot in this order: {N,...,7,6,5,...,1}
 	 *  (slot/handle 0 is reserved!)
 	 */
 	for (i = MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
@@ -520,7 +679,7 @@
 			MptCallbacks[i] = cbfunc;
 			MptDriverClass[i] = dclass;
 			MptEvHandlers[i] = NULL;
-			r = i;
+			last_drv_idx = i;
 			if (cbfunc != mpt_base_reply) {
 				MOD_INC_USE_COUNT;
 			}
@@ -528,7 +687,7 @@
 		}
 	}
 
-	return r;
+	return last_drv_idx;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -546,6 +705,11 @@
 		MptCallbacks[cb_idx] = NULL;
 		MptDriverClass[cb_idx] = MPTUNKNOWN_DRIVER;
 		MptEvHandlers[cb_idx] = NULL;
+
+		last_drv_idx++;
+		if (isense_idx != -1 && isense_idx <= cb_idx)
+			isense_idx++;
+
 		if (cb_idx != mpt_base_index) {
 			MOD_DEC_USE_COUNT;
 		}
@@ -639,7 +803,8 @@
  *	@handle: Handle of registered MPT protocol driver
  *	@iocid: IOC unique identifier (integer)
  *
- *	Returns pointer to a MPT request frame or %NULL if none are available.
+ *	Returns pointer to a MPT request frame or %NULL if none are available
+ *	or IOC is not active.
  */
 MPT_FRAME_HDR*
 mpt_get_msg_frame(int handle, int iocid)
@@ -650,6 +815,16 @@
 
 	/* validate handle and ioc identifier */
 	iocp = mpt_adapters[iocid];
+
+#ifdef MFCNT
+	if (!iocp->active)
+		printk(KERN_WARNING "IOC Not Active! mpt_get_msg_frame returning NULL!\n");
+#endif
+
+	/* If interrupts are not attached, do not return a request frame */
+	if (!iocp->active)
+		return NULL;
+
 	spin_lock_irqsave(&iocp->FreeQlock, flags);
 	if (! Q_IS_EMPTY(&iocp->FreeQ)) {
 		int req_offset;
@@ -662,8 +837,20 @@
 		mf->u.frame.hwhdr.msgctxu.fld.req_idx =
 				cpu_to_le16(req_offset / iocp->req_sz);
 		mf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;
+#ifdef MFCNT
+		iocp->mfcnt++;
+#endif
 	}
 	spin_unlock_irqrestore(&iocp->FreeQlock, flags);
+
+#ifdef MFCNT
+	if (mf == NULL)
+		printk(KERN_WARNING "IOC Active. No free Msg Frames! Count 0x%x Max 0x%x\n", iocp->mfcnt, iocp->req_depth);
+	mfcounter++;
+	if (mfcounter == PRINT_MF_COUNT)
+		printk(KERN_INFO "MF Count 0x%x Max 0x%x \n", iocp->mfcnt, iocp->req_depth);
+#endif
+
 	dmfprintk((KERN_INFO MYNAM ": %s: mpt_get_msg_frame(%d,%d), got mf=%p\n",
 			iocp->name, handle, iocid, mf));
 	return mf;
@@ -687,7 +874,7 @@
 
 	iocp = mpt_adapters[iocid];
 	if (iocp != NULL) {
-		dma_addr_t mf_dma_addr;
+		u32 mf_dma_addr;
 		int req_offset;
 
 		/* ensure values are reset properly! */
@@ -700,23 +887,23 @@
 #ifdef MPT_DEBUG_MSG_FRAME
 		{
 			u32	*m = mf->u.frame.hwhdr.__hdr;
-			int	 i, n;
+			int	 ii, n;
 
 			printk(KERN_INFO MYNAM ": %s: About to Put msg frame @ %p:\n" KERN_INFO " ",
 					iocp->name, m);
 			n = iocp->req_sz/4 - 1;
 			while (m[n] == 0)
 				n--;
-			for (i=0; i<=n; i++) {
-				if (i && ((i%8)==0))
+			for (ii=0; ii<=n; ii++) {
+				if (ii && ((ii%8)==0))
 					printk("\n" KERN_INFO " ");
-				printk(" %08x", le32_to_cpu(m[i]));
+				printk(" %08x", le32_to_cpu(m[ii]));
 			}
 			printk("\n");
 		}
 #endif
 
-		mf_dma_addr = iocp->req_frames_dma + req_offset;
+		mf_dma_addr = iocp->req_frames_low_dma + req_offset;
 		CHIPREG_WRITE32(&iocp->chip->RequestFifo, mf_dma_addr);
 	}
 }
@@ -742,6 +929,9 @@
 		/*  Put Request back on FreeQ!  */
 		spin_lock_irqsave(&iocp->FreeQlock, flags);
 		Q_ADD_TAIL(&iocp->FreeQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+#ifdef MFCNT
+		iocp->mfcnt--;
+#endif
 		spin_unlock_irqrestore(&iocp->FreeQlock, flags);
 	}
 }
@@ -754,8 +944,9 @@
  *	@iocid: IOC unique identifier (integer)
  *	@reqBytes: Size of the request in bytes
  *	@req: Pointer to MPT request frame
+ *	@sleepFlag: Use schedule if CAN_SLEEP else use udelay.
  *
- *	This routine is used exclusively by mptscsih to send MptScsiTaskMgmt
+ *	This routine is used exclusively to send MptScsiTaskMgmt
  *	requests since they are required to be sent via doorbell handshake.
  *
  *	NOTE: It is the callers responsibility to byte-swap fields in the
@@ -764,41 +955,30 @@
  *	Returns 0 for success, non-zero for failure.
  */
 int
-mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req)
+mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req, int sleepFlag)
 {
 	MPT_ADAPTER	*iocp;
 	int		 r = 0;
 
 	iocp = mpt_adapters[iocid];
 	if (iocp != NULL) {
-		u8		*req_as_bytes;
-		u32		 ioc_raw_state;
-		int		 i;
-
-		/* YIKES!  We already know something is amiss.
-		 * Do upfront check on IOC state.
-		 */
-		ioc_raw_state = GetIocState(iocp, 0);
-		if ((ioc_raw_state & MPI_DOORBELL_ACTIVE) ||
-		    ((ioc_raw_state & MPI_IOC_STATE_MASK) != MPI_IOC_STATE_OPERATIONAL)) {
-			printk(KERN_WARNING MYNAM ": %s: Bad IOC state (%08x) WARNING!\n",
-					iocp->name, ioc_raw_state);
-			if ((r = mpt_do_ioc_recovery(iocp, MPT_HOSTEVENT_IOC_RECOVER)) != 0) {
-				printk(KERN_WARNING MYNAM ": WARNING - (%d) Cannot recover %s\n",
-						r, iocp->name);
-				return r;
-			}
-		}
+		u8	*req_as_bytes;
+		int	 ii;
+
+		/* State is known to be good upon entering
+		 * this function so issue the bus reset
+		 * request.
+		 */
 
 		/*
 		 * Emulate what mpt_put_msg_frame() does /wrt to sanity
 		 * setting cb_idx/req_idx.  But ONLY if this request
 		 * is in proper (pre-alloc'd) request buffer range...
 		 */
-		i = MFPTR_2_MPT_INDEX(iocp,(MPT_FRAME_HDR*)req);
-		if (reqBytes >= 12 && i >= 0 && i < iocp->req_depth) {
+		ii = MFPTR_2_MPT_INDEX(iocp,(MPT_FRAME_HDR*)req);
+		if (reqBytes >= 12 && ii >= 0 && ii < iocp->req_depth) {
 			MPT_FRAME_HDR *mf = (MPT_FRAME_HDR*)req;
-			mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(i);
+			mf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(ii);
 			mf->u.frame.hwhdr.msgctxu.fld.cb_idx = handle;
 		}
 
@@ -810,36 +990,40 @@
 				 ((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));
 
 		/* Wait for IOC doorbell int */
-		if ((i = WaitForDoorbellInt(iocp, 2)) < 0) {
-			return i;
+		if ((ii = WaitForDoorbellInt(iocp, 2, sleepFlag)) < 0) {
+			return ii;
 		}
 
+		/* Read doorbell and check for active bit */
+		if (!(CHIPREG_READ32(&iocp->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
+				return -5;
+
 		dhsprintk((KERN_INFO MYNAM ": %s: mpt_send_handshake_request start, WaitCnt=%d\n",
-				iocp->name, i));
+				iocp->name, ii));
 
 		CHIPREG_WRITE32(&iocp->chip->IntStatus, 0);
 
-		if ((r = WaitForDoorbellAck(iocp, 1)) < 0) {
+		if ((r = WaitForDoorbellAck(iocp, 1, sleepFlag)) < 0) {
 			return -2;
 		}
 
 		/* Send request via doorbell handshake */
 		req_as_bytes = (u8 *) req;
-		for (i = 0; i < reqBytes/4; i++) {
+		for (ii = 0; ii < reqBytes/4; ii++) {
 			u32 word;
 
-			word = ((req_as_bytes[(i*4) + 0] <<  0) |
-				(req_as_bytes[(i*4) + 1] <<  8) |
-				(req_as_bytes[(i*4) + 2] << 16) |
-				(req_as_bytes[(i*4) + 3] << 24));
+			word = ((req_as_bytes[(ii*4) + 0] <<  0) |
+				(req_as_bytes[(ii*4) + 1] <<  8) |
+				(req_as_bytes[(ii*4) + 2] << 16) |
+				(req_as_bytes[(ii*4) + 3] << 24));
 			CHIPREG_WRITE32(&iocp->chip->Doorbell, word);
-			if ((r = WaitForDoorbellAck(iocp, 1)) < 0) {
+			if ((r = WaitForDoorbellAck(iocp, 1, sleepFlag)) < 0) {
 				r = -3;
 				break;
 			}
 		}
 
-		if ((r = WaitForDoorbellInt(iocp, 2)) >= 0)
+		if ((r = WaitForDoorbellInt(iocp, 10, sleepFlag)) >= 0)
 			r = 0;
 		else
 			r = -4;
@@ -871,8 +1055,8 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- * 	mpt_adapter_find_next - Find next MPT adapter pointer.
- * 	@prev: Pointer to previous MPT adapter
+ *	mpt_adapter_find_next - Find next MPT adapter pointer.
+ *	@prev: Pointer to previous MPT adapter
  *
  *	Returns next MPT adapter pointer or %NULL if there are no more.
  */
@@ -888,13 +1072,13 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_pci_scan - Scan PCI devices for MPT adapters.
  *
  *	Returns count of MPT adapters found, keying off of PCI vendor and
  *	device_id's.
  */
-int __init
+static int __init
 mpt_pci_scan(void)
 {
 	struct pci_dev *pdev;
@@ -906,7 +1090,7 @@
 	dprintk((KERN_INFO MYNAM ": Checking for MPT adapters...\n"));
 
 	/*
-	 *  NOTE: The 929 (I believe) will appear as 2 separate PCI devices,
+	 *  NOTE: The 929 and 1030 will appear as 2 separate PCI devices,
 	 *  one for each channel.
 	 */
 	pci_for_each_dev(pdev) {
@@ -917,9 +1101,9 @@
 		if ((pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC909) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC929) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVICEID_FC919) &&
+		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030) &&
 #if 0
 		    /* FIXME! C103x family */
-		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1030_ZC) &&
 		    (pdev->device != MPI_MANUFACTPAGE_DEVID_53C1035) &&
 #endif
@@ -929,7 +1113,7 @@
 		}
 
 		/* GRRRRR
-		 * 929 dual function devices may be presented in Func 1,0 order,
+		 * dual function devices (929, 1030) may be presented in Func 1,0 order,
 		 * but we'd really really rather have them in Func 0,1 order.
 		 * Do some kind of look ahead here...
 		 */
@@ -937,11 +1121,11 @@
 			pdev2 = pci_peek_next_dev(pdev);
 			if (pdev2 && (pdev2->vendor == 0x1000) &&
 			    (PCI_SLOT(pdev2->devfn) == PCI_SLOT(pdev->devfn)) &&
-			    (pdev2->device == MPI_MANUFACTPAGE_DEVICEID_FC929) &&
+			    (pdev2->device == pdev->device) &&
 			    (pdev2->bus->number == pdev->bus->number) &&
 			    !(pdev2->devfn & 1)) {
 				dprintk((KERN_INFO MYNAM ": MPT adapter found: PCI bus/dfn=%02x/%02xh, class=%08x, id=%xh\n",
-			 		pdev2->bus->number, pdev2->devfn, pdev2->class, pdev2->device));
+					pdev2->bus->number, pdev2->devfn, pdev2->class, pdev2->device));
 				found++;
 				if ((r = mpt_adapter_install(pdev2)) == 0)
 					count++;
@@ -969,9 +1153,7 @@
 	}
 
 #ifdef CONFIG_PROC_FS
-	if (procmpt_create() != 0)
-		printk(KERN_WARNING MYNAM ": WARNING! - %s creation failed!\n",
-				MPT_PROCFS_MPTBASEDIR);
+	(void) procmpt_create();
 #endif
 
 	return count;
@@ -1004,7 +1186,7 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_adapter_install - Install a PCI intelligent MPT adapter.
  *	@pdev: Pointer to pci_dev structure
  *
@@ -1030,7 +1212,7 @@
 	unsigned long	 port;
 	u32		 msize;
 	u32		 psize;
-	int		 i;
+	int		 ii;
 	int		 r = -ENODEV;
 	int		 len;
 
@@ -1040,41 +1222,68 @@
 		return -ENOMEM;
 	}
 	memset(ioc, 0, sizeof(*ioc));
-	ioc->req_sz = MPT_REQ_SIZE;			/* avoid div by zero! */
 	ioc->alloc_total = sizeof(MPT_ADAPTER);
+	ioc->req_sz = MPT_DEFAULT_FRAME_SIZE;		/* avoid div by zero! */
+	ioc->reply_sz = ioc->req_sz;
 
 	ioc->pcidev = pdev;
+	ioc->diagPending = 0;
+	spin_lock_init(&ioc->diagLock);
+
+	/* Initialize the event logging.
+	 */
+	ioc->eventTypes = 0;	/* None */
+	ioc->eventContext = 0;
+	ioc->eventLogSize = 0;
+	ioc->events = NULL;
+
+#ifdef MFCNT
+	ioc->mfcnt = 0;
+#endif
+
+	/* Initialize the FW and Data image pointers.
+	 */
+	ioc->FWImage = NULL;
+	ioc->FWImage_dma = 0;
+
+	/* Initilize SCSI Config Data structure
+	 */
+	memset(&ioc->spi_data, 0, sizeof(ScsiCfgData));
+
+	/* Initialize the running configQ head.
+	 */
+	Q_INIT(&ioc->configQ, Q_ITEM);
 
 	/* Find lookup slot. */
-	for (i=0; i < MPT_MAX_ADAPTERS; i++) {
-		if (mpt_adapters[i] == NULL) {
-			ioc->id = i;		/* Assign adapter unique id (lookup) */
+	for (ii=0; ii < MPT_MAX_ADAPTERS; ii++) {
+		if (mpt_adapters[ii] == NULL) {
+			ioc->id = ii;		/* Assign adapter unique id (lookup) */
 			break;
 		}
 	}
-	if (i == MPT_MAX_ADAPTERS) {
-		printk(KERN_ERR MYNAM ": ERROR - mpt_adapters[%d] table overflow!\n", i);
+	if (ii == MPT_MAX_ADAPTERS) {
+		printk(KERN_ERR MYNAM ": ERROR - mpt_adapters[%d] table overflow!\n", ii);
 		kfree(ioc);
 		return -ENFILE;
 	}
 
 	mem_phys = msize = 0;
 	port = psize = 0;
-	for (i=0; i < DEVICE_COUNT_RESOURCE; i++) {
-		if (pdev->PCI_BASEADDR_FLAGS(i) & PCI_BASE_ADDRESS_SPACE_IO) {
+	for (ii=0; ii < DEVICE_COUNT_RESOURCE; ii++) {
+		if (pdev->PCI_BASEADDR_FLAGS(ii) & PCI_BASE_ADDRESS_SPACE_IO) {
 			/* Get I/O space! */
-			port = pdev->PCI_BASEADDR_START(i);
-			psize = PCI_BASEADDR_SIZE(pdev,i);
+			port = pdev->PCI_BASEADDR_START(ii);
+			psize = PCI_BASEADDR_SIZE(pdev,ii);
 		} else {
 			/* Get memmap */
-			mem_phys = pdev->PCI_BASEADDR_START(i);
-			msize = PCI_BASEADDR_SIZE(pdev,i);
+			mem_phys = pdev->PCI_BASEADDR_START(ii);
+			msize = PCI_BASEADDR_SIZE(pdev,ii);
 			break;
 		}
 	}
 	ioc->mem_size = msize;
 
-	if (i == DEVICE_COUNT_RESOURCE) {
+	if (ii == DEVICE_COUNT_RESOURCE) {
 		printk(KERN_ERR MYNAM ": ERROR - MPT adapter has no memory regions defined!\n");
 		kfree(ioc);
 		return -EINVAL;
@@ -1098,6 +1307,8 @@
 	}
 	dprintk((KERN_INFO MYNAM ": mem = %p, mem_phys = %lx\n", mem, mem_phys));
 
+	dprintk((KERN_INFO MYNAM ": facts @ %p, pfacts[0] @ %p\n",
+			&ioc->facts, &ioc->pfacts[0]));
 	if (PortIo) {
 		u8 *pmem = (u8*)port;
 		ioc->mem_phys = port;
@@ -1107,6 +1318,13 @@
 		ioc->chip = (SYSIF_REGS*)mem;
 	}
 
+	/* Save Port IO values incase we need to do downloadboot */
+	{
+		u8 *pmem = (u8*)port;
+		ioc->pio_mem_phys = port;
+		ioc->pio_chip = (SYSIF_REGS*)pmem;
+	}
+
 	ioc->chip_type = FCUNK;
 	if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_FC909) {
 		ioc->chip_type = FC909;
@@ -1120,12 +1338,19 @@
 		ioc->chip_type = FC919;
 		ioc->prod_name = "LSIFC919";
 	}
-#if 0
-	else if (pdev->device == MPI_MANUFACTPAGE_DEVICEID_53C1030) {
+	else if (pdev->device == MPI_MANUFACTPAGE_DEVID_53C1030) {
 		ioc->chip_type = C1030;
 		ioc->prod_name = "LSI53C1030";
+		{
+			/* 1030 Chip Fix. Disable Split transactions
+			 * for PCIX. Set bits 4 - 6 to zero.
+			 */
+			u16 pcixcmd = 0;
+			pci_read_config_word(pdev, 0x6a, &pcixcmd);
+			pcixcmd &= 0xFF8F;
+			pci_write_config_word(pdev, 0x6a, pcixcmd);
+		}
 	}
-#endif
 
 	myname = "iocN";
 	len = strlen(myname);
@@ -1145,8 +1370,13 @@
 		r = request_irq(pdev->irq, mpt_interrupt, SA_SHIRQ, ioc->name, ioc);
 
 		if (r < 0) {
-			printk(KERN_ERR MYNAM ": %s: ERROR - Unable to allocate interrupt %d!\n",
+#ifndef __sparc__
+			printk(MYIOC_s_ERR_FMT "Unable to allocate interrupt %d!\n",
 					ioc->name, pdev->irq);
+#else
+			printk(MYIOC_s_ERR_FMT "Unable to allocate interrupt %s!\n",
+					ioc->name, __irq_itoa(pdev->irq));
+#endif
 			iounmap(mem);
 			kfree(ioc);
 			return -EBUSY;
@@ -1156,7 +1386,11 @@
 
 		pci_set_master(pdev);			/* ?? */
 
+#ifndef __sparc__
 		dprintk((KERN_INFO MYNAM ": %s installed at interrupt %d\n", ioc->name, pdev->irq));
+#else
+		dprintk((KERN_INFO MYNAM ": %s installed at interrupt %s\n", ioc->name, __irq_itoa(pdev->irq)));
+#endif
 	}
 
 	/* tack onto tail of our MPT adapter list */
@@ -1166,12 +1400,12 @@
 	mpt_adapters[ioc->id] = ioc;
 
 	/* NEW!  20010220 -sralston
-	 * Check for "929 bound ports" to reduce redundant resets.
+	 * Check for "bound ports" (929, 1030) to reduce redundant resets.
 	 */
-	if (ioc->chip_type == FC929)
-		mpt_detect_929_bound_ports(ioc, pdev);
+	if ((ioc->chip_type == FC929) || (ioc->chip_type == C1030))
+		mpt_detect_bound_ports(ioc, pdev);
 
-	if ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP)) != 0) {
+	if ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP, CAN_SLEEP)) != 0) {
 		printk(KERN_WARNING MYNAM ": WARNING - %s did not initialize properly! (%d)\n",
 				ioc->name, r);
 	}
@@ -1180,10 +1414,11 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	mpt_do_ioc_recovery - Initialize or recover MPT adapter.
  *	@ioc: Pointer to MPT adapter structure
  *	@reason: Event word / reason
+ *	@sleepFlag: Use schedule if CAN_SLEEP else use udelay.
  *
  *	This routine performs all the steps necessary to bring the IOC
  *	to a OPERATIONAL state.
@@ -1191,16 +1426,21 @@
  *	This routine also pre-fetches the LAN MAC address of a Fibre Channel
  *	MPT adapter.
  *
- *	Returns 0 for success.
+ *	Returns:
+ *		 0 for success
+ *		-1 if failed to get board READY
+ *		-2 if READY but IOCFacts Failed
+ *		-3 if READY but PrimeIOCFifos Failed
+ *		-4 if READY but IOCInit Failed
  */
 static int
-mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason)
+mpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag)
 {
 	int	 hard_reset_done = 0;
 	int	 alt_ioc_ready = 0;
 	int	 hard;
 	int	 r;
-	int	 i;
+	int	 ii;
 	int	 handlers;
 
 	printk(KERN_INFO MYNAM ": Initiating %s %s\n",
@@ -1211,156 +1451,106 @@
 	ioc->active = 0;
 	/* NOTE: Access to IOC's request FreeQ is now blocked! */
 
-// FIXME? Cleanup all IOC requests here! (or below?)
-// But watch out for event associated request?
+	if (ioc->alt_ioc) {
+		/* Disable alt-IOC's reply interrupts for a bit ... */
+		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, 0xFFFFFFFF);
+		ioc->alt_ioc->active = 0;
+		/* NOTE: Access to alt-IOC's request FreeQ is now blocked! */
+	}
 
-	hard = HardReset;
-	if (ioc->alt_ioc && (reason == MPT_HOSTEVENT_IOC_BRINGUP))
+	hard = 1;
+	if (reason == MPT_HOSTEVENT_IOC_BRINGUP)
 		hard = 0;
 
-	if ((hard_reset_done = MakeIocReady(ioc, hard)) < 0) {
+	if ((hard_reset_done = MakeIocReady(ioc, hard, sleepFlag)) < 0) {
 		printk(KERN_WARNING MYNAM ": %s NOT READY WARNING!\n",
 				ioc->name);
 		return -1;
 	}
 
-// NEW!
-#if 0						// Kiss-of-death!?!
-	if (ioc->alt_ioc) {
-// Grrr... Hold off any alt-IOC interrupts (and events) while
-// handshaking to <this> IOC, needed because?
-		/* Disable alt-IOC's reply interrupts for a bit ... */
-		alt_ioc_intmask = CHIPREG_READ32(&ioc->alt_ioc->chip->IntMask);
-		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, 0xFFFFFFFF);
-		ioc->alt_ioc->active = 0;
-		/* NOTE: Access to alt-IOC's request FreeQ is now blocked! */
-	}
-#endif
-
+	/* hard_reset_done = 0 if a soft reset was performed
+	 * and 1 if a hard reset was performed.
+	 */
 	if (hard_reset_done && ioc->alt_ioc) {
-		if ((r = MakeIocReady(ioc->alt_ioc, 0)) == 0)
+		if ((r = MakeIocReady(ioc->alt_ioc, 0, sleepFlag)) == 0)
 			alt_ioc_ready = 1;
 		else
-			printk(KERN_WARNING MYNAM ": alt-%s: (%d) Not ready WARNING!\n",
+			printk(KERN_WARNING MYNAM
+					": alt-%s: (%d) Not ready WARNING!\n",
 					ioc->alt_ioc->name, r);
 	}
 
+	/* Get IOC facts! */
+	if ((r = GetIocFacts(ioc, sleepFlag, reason)) != 0)
+		return -2;
 	if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
-		/* Get IOC facts! */
-		if ((r = GetIocFacts(ioc)) != 0)
-			return -2;
 		MptDisplayIocCapabilities(ioc);
 	}
 
-	/*
-	 * Call each currently registered protocol IOC reset handler
-	 * with pre-reset indication.
-	 * NOTE: If we're doing _IOC_BRINGUP, there can be no
-	 * MptResetHandlers[] registered yet.
-	 */
-	if (hard_reset_done) {
-		r = handlers = 0;
-		for (i=MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
-			if (MptResetHandlers[i]) {
-				dprintk((KERN_INFO MYNAM ": %s: Calling IOC pre_reset handler #%d\n",
-						ioc->name, i));
-				r += (*(MptResetHandlers[i]))(ioc, MPT_IOC_PRE_RESET);
-				handlers++;
-
-				if (alt_ioc_ready) {
-					dprintk((KERN_INFO MYNAM ": %s: Calling alt-IOC pre_reset handler #%d\n",
-							ioc->alt_ioc->name, i));
-					r += (*(MptResetHandlers[i]))(ioc->alt_ioc, MPT_IOC_PRE_RESET);
-					handlers++;
-				}
-			}
-		}
-		/* FIXME?  Examine results here? */
-	}
-
-	// May need to check/upload firmware & data here!
-
-	if ((r = SendIocInit(ioc)) != 0)
-		return -3;
-// NEW!
 	if (alt_ioc_ready) {
-		if ((r = SendIocInit(ioc->alt_ioc)) != 0) {
-			alt_ioc_ready = 0;
-			printk(KERN_WARNING MYNAM ": alt-%s: (%d) init failure WARNING!\n",
-					ioc->alt_ioc->name, r);
-		}
-	}
-
-	/*
-	 * Call each currently registered protocol IOC reset handler
-	 * with post-reset indication.
-	 * NOTE: If we're doing _IOC_BRINGUP, there can be no
-	 * MptResetHandlers[] registered yet.
-	 */
-	if (hard_reset_done) {
-		r = handlers = 0;
-		for (i=MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
-			if (MptResetHandlers[i]) {
-				dprintk((KERN_INFO MYNAM ": %s: Calling IOC post_reset handler #%d\n",
-						ioc->name, i));
-				r += (*(MptResetHandlers[i]))(ioc, MPT_IOC_POST_RESET);
-				handlers++;
-
-				if (alt_ioc_ready) {
-					dprintk((KERN_INFO MYNAM ": %s: Calling alt-IOC post_reset handler #%d\n",
-							ioc->alt_ioc->name, i));
-					r += (*(MptResetHandlers[i]))(ioc->alt_ioc, MPT_IOC_POST_RESET);
-					handlers++;
-				}
-			}
+		if ((r = GetIocFacts(ioc->alt_ioc, sleepFlag, reason)) != 0)
+			return -2;
+		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+			MptDisplayIocCapabilities(ioc->alt_ioc);
 		}
-		/* FIXME?  Examine results here? */
 	}
 
 	/*
 	 * Prime reply & request queues!
-	 * (mucho alloc's)
+	 * (mucho alloc's) Must be done prior to
+	 * init as upper addresses are needed for init.
 	 */
 	if ((r = PrimeIocFifos(ioc)) != 0)
+		return -3;
+
+	// May need to check/upload firmware & data here!
+	if ((r = SendIocInit(ioc, sleepFlag)) != 0)
 		return -4;
 // NEW!
 	if (alt_ioc_ready && ((r = PrimeIocFifos(ioc->alt_ioc)) != 0)) {
 		printk(KERN_WARNING MYNAM ": alt-%s: (%d) FIFO mgmt alloc WARNING!\n",
 				ioc->alt_ioc->name, r);
+		alt_ioc_ready = 0;
 	}
 
-// FIXME! Cleanup all IOC (and alt-IOC?) requests here!
+	if (alt_ioc_ready) {
+		if ((r = SendIocInit(ioc->alt_ioc, sleepFlag)) != 0) {
+			alt_ioc_ready = 0;
+			printk(KERN_WARNING MYNAM
+				": alt-%s: (%d) init failure WARNING!\n",
+					ioc->alt_ioc->name, r);
+		}
+	}
 
-	if ((ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) &&
-	    (ioc->lan_cnfg_page0.Header.PageLength == 0)) {
-		/*
-		 *  Pre-fetch the ports LAN MAC address!
-		 *  (LANPage1_t stuff)
-		 */
-		(void) GetLanConfigPages(ioc);
-#ifdef MPT_DEBUG
-		{
-			u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
-			dprintk((KERN_INFO MYNAM ": %s: LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
-					ioc->name, a[5], a[4], a[3], a[2], a[1], a[0] ));
+	if (reason == MPT_HOSTEVENT_IOC_BRINGUP){
+		if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT) {
+			dprintk((MYIOC_s_INFO_FMT
+				"firmware upload required!\n", ioc->name));
+
+			r = mpt_do_upload(ioc, sleepFlag);
+			if (r != 0)
+				printk(KERN_WARNING MYNAM ": firmware upload failure!\n");
+			/* Handle the alt IOC too */
+			if (alt_ioc_ready){
+				r = mpt_do_upload(ioc->alt_ioc, sleepFlag);
+				if (r != 0)
+					printk(KERN_WARNING MYNAM ": firmware upload failure!\n");
+			}
 		}
-#endif
 	}
 
+
 	/* Enable! (reply interrupt) */
 	CHIPREG_WRITE32(&ioc->chip->IntMask, ~(MPI_HIM_RIM));
 	ioc->active = 1;
 
-// NEW!
-#if 0						// Kiss-of-death!?!
-	if (alt_ioc_ready && (r==0)) {
+	if (ioc->alt_ioc) {
 		/* (re)Enable alt-IOC! (reply interrupt) */
 		dprintk((KERN_INFO MYNAM ": alt-%s reply irq re-enabled\n",
 				ioc->alt_ioc->name));
 		CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, ~(MPI_HIM_RIM));
 		ioc->alt_ioc->active = 1;
 	}
-#endif
 
 	/* NEW!  20010120 -sralston
 	 *  Enable MPT base driver management of EventNotification
@@ -1368,19 +1558,95 @@
 	 */
 	if (!ioc->facts.EventState)
 		(void) SendEventNotification(ioc, 1);	/* 1=Enable EventNotification */
-// NEW!
-// FIXME!?!
-//	if (ioc->alt_ioc && alt_ioc_ready && !ioc->alt_ioc->facts.EventState) {
-//		(void) SendEventNotification(ioc->alt_ioc, 1);	/* 1=Enable EventNotification */
-//	}
+
+	if (ioc->alt_ioc && alt_ioc_ready && !ioc->alt_ioc->facts.EventState)
+		(void) SendEventNotification(ioc->alt_ioc, 1);	/* 1=Enable EventNotification */
+
+	/* (Bugzilla:fibrebugs, #513)
+	 * Bug fix (part 2)!  20010905 -sralston
+	 *	Add additional "reason" check before call to GetLanConfigPages
+	 *	(combined with GetIoUnitPage2 call).  This prevents a somewhat
+	 *	recursive scenario; GetLanConfigPages times out, timer expired
+	 *	routine calls HardResetHandler, which calls into here again,
+	 *	and we try GetLanConfigPages again...
+	 */
+	if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+		if ((int)ioc->chip_type <= (int)FC929) {
+			/*
+			 *  Pre-fetch FC port WWN and stuff...
+			 *  (FCPortPage0_t stuff)
+			 */
+			for (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {
+				(void) GetFcPortPage0(ioc, ii);
+			}
+
+			if ((ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) &&
+			    (ioc->lan_cnfg_page0.Header.PageLength == 0)) {
+				/*
+				 *  Pre-fetch the ports LAN MAC address!
+				 *  (LANPage1_t stuff)
+				 */
+				(void) GetLanConfigPages(ioc);
+#ifdef MPT_DEBUG
+				{
+					u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
+					dprintk((MYIOC_s_INFO_FMT "LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
+							ioc->name, a[5], a[4], a[3], a[2], a[1], a[0] ));
+				}
+#endif
+			}
+		} else {
+			/* Get NVRAM and adapter maximums from SPP 0 and 2
+			 */
+			mpt_GetScsiPortSettings(ioc, 0);
+
+			/* Get version and length of SDP 1 
+			 */
+			mpt_readScsiDevicePageHeaders(ioc, 0);
+
+			/* Find IM volumes 
+			 */
+			if (ioc->facts.MsgVersion >= 0x0102)
+				mpt_findImVolumes(ioc);
+		}
+
+		GetIoUnitPage2(ioc);
+	}
+
+	/*
+	 * Call each currently registered protocol IOC reset handler
+	 * with post-reset indication.
+	 * NOTE: If we're doing _IOC_BRINGUP, there can be no
+	 * MptResetHandlers[] registered yet.
+	 */
+	if (hard_reset_done) {
+		r = handlers = 0;
+		for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+			if (MptResetHandlers[ii]) {
+				dprintk((MYIOC_s_INFO_FMT "Calling IOC post_reset handler #%d\n",
+						ioc->name, ii));
+				r += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_POST_RESET);
+				handlers++;
+
+				if (alt_ioc_ready) {
+					dprintk((MYIOC_s_INFO_FMT "Calling alt-%s post_reset handler #%d\n",
+							ioc->name, ioc->alt_ioc->name, ii));
+					r += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_POST_RESET);
+					handlers++;
+				}
+			}
+		}
+		/* FIXME?  Examine results here? */
+	}
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	mpt_detect_929_bound_ports - Search for PCI bus/dev_function
- *	which matches PCI bus/dev_function (+/-1) for newly discovered 929.
+ *	mpt_detect_bound_ports - Search for PCI bus/dev_function
+ *	which matches PCI bus/dev_function (+/-1) for newly discovered 929
+ *	or 1030.
  *	@ioc: Pointer to MPT adapter structure
  *	@pdev: Pointer to (struct pci_dev) structure
  *
@@ -1388,22 +1654,22 @@
  *	using alt_ioc pointer fields in their %MPT_ADAPTER structures.
  */
 static void
-mpt_detect_929_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)
+mpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)
 {
 	MPT_ADAPTER *ioc_srch = mpt_adapter_find_first();
 	unsigned int match_lo, match_hi;
 
 	match_lo = pdev->devfn-1;
 	match_hi = pdev->devfn+1;
-	dprintk((KERN_INFO MYNAM ": %s: PCI bus/devfn=%x/%x, searching for devfn match on %x or %x\n",
+	dprintk((MYIOC_s_INFO_FMT "PCI bus/devfn=%x/%x, searching for devfn match on %x or %x\n",
 			ioc->name, pdev->bus->number, pdev->devfn, match_lo, match_hi));
 
 	while (ioc_srch != NULL) {
 		struct pci_dev *_pcidev = ioc_srch->pcidev;
 
-		if ( (_pcidev->device == MPI_MANUFACTPAGE_DEVICEID_FC929) &&
-		     (_pcidev->bus->number == pdev->bus->number) &&
-		     (_pcidev->devfn == match_lo || _pcidev->devfn == match_hi) ) {
+		if ((_pcidev->device == pdev->device) &&
+		    (_pcidev->bus->number == pdev->bus->number) &&
+		    (_pcidev->devfn == match_lo || _pcidev->devfn == match_hi) ) {
 			/* Paranoia checks */
 			if (ioc->alt_ioc != NULL) {
 				printk(KERN_WARNING MYNAM ": Oops, already bound (%s <==> %s)!\n",
@@ -1418,8 +1684,6 @@
 					ioc->name, ioc_srch->name));
 			ioc_srch->alt_ioc = ioc;
 			ioc->alt_ioc = ioc_srch;
-			ioc->sod_reset = ioc->alt_ioc->sod_reset;
-			ioc->last_kickstart = ioc->alt_ioc->last_kickstart;
 			break;
 		}
 		ioc_srch = mpt_adapter_find_next(ioc_srch);
@@ -1440,10 +1704,10 @@
 		u32 state;
 
 		/* Disable the FW */
-		state = GetIocState(this, 1);
+		state = mpt_GetIocState(this, 1);
 		if (state == MPI_IOC_STATE_OPERATIONAL) {
-			if (SendIocReset(this, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET) != 0)
-				(void) KickStart(this, 1);
+			if (SendIocReset(this, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, NO_SLEEP) != 0)
+				(void) KickStart(this, 1, NO_SLEEP);
 		}
 
 		/* Disable adapter interrupts! */
@@ -1475,12 +1739,37 @@
 		}
 
 		if (freeup && this->sense_buf_pool != NULL) {
-			sz = (this->req_depth * 256);
+			sz = (this->req_depth * MPT_SENSE_BUFFER_ALLOC);
 			pci_free_consistent(this->pcidev, sz,
 					this->sense_buf_pool, this->sense_buf_pool_dma);
 			this->sense_buf_pool = NULL;
 			this->alloc_total -= sz;
 		}
+
+		if (freeup && this->events != NULL){
+			sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
+			kfree(this->events);
+			this->events = NULL;
+			this->alloc_total -= sz;
+		}
+
+		if (freeup && this->FWImage != NULL) {
+			sz = this->facts.FWImageSize;
+			pci_free_consistent(this->pcidev, sz,
+					this->FWImage, this->FWImage_dma);
+			this->FWImage = NULL;
+			this->alloc_total -= sz;
+		}
+
+		if (freeup && this->spi_data.nvram != NULL) {
+			kfree(this->spi_data.nvram);
+			this->spi_data.nvram = NULL;
+		}
+
+		if (freeup && this->spi_data.pIocPg3 != NULL) {
+			kfree(this->spi_data.pIocPg3);
+			this->spi_data.pIocPg3 = NULL;
+		}
 	}
 }
 
@@ -1575,23 +1864,30 @@
 /*
  *	MakeIocReady - Get IOC to a READY state, using KickStart if needed.
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@kick: Force hard KickStart of IOC
+ *	@force: Force hard KickStart of IOC
+ *	@sleepFlag: Specifies whether the process can sleep
  *
- *	Returns 0 for already-READY, 1 for hard reset success,
- *	else negative for failure.
+ *	Returns:
+ *		 1 - DIAG reset and READY
+ *		 0 - READY initially OR soft reset and READY 
+ *		-1 - Any failure on KickStart 
+ *		-2 - Msg Unit Reset Failed
+ *		-3 - IO Unit Reset Failed
+ *		-4 - IOC owned by a PEER
  */
 static int
-MakeIocReady(MPT_ADAPTER *ioc, int force)
+MakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag)
 {
 	u32	 ioc_state;
 	int	 statefault = 0;
-	int 	 cntdn;
+	int	 cntdn;
 	int	 hard_reset_done = 0;
 	int	 r;
-	int	 i;
+	int	 ii;
+	int	 whoinit;
 
 	/* Get current [raw] IOC state  */
-	ioc_state = GetIocState(ioc, 0);
+	ioc_state = mpt_GetIocState(ioc, 0);
 	dhsprintk((KERN_INFO MYNAM "::MakeIocReady, %s [raw] state=%08x\n", ioc->name, ioc_state));
 
 	/*
@@ -1600,7 +1896,7 @@
 	 */
 	if (ioc_state & MPI_DOORBELL_ACTIVE) {
 		statefault = 1;
-		printk(KERN_WARNING MYNAM ": %s: Uh-oh, unexpected doorbell active!\n",
+		printk(MYIOC_s_WARN_FMT "Unexpected doorbell active!\n",
 				ioc->name);
 	}
 
@@ -1613,7 +1909,7 @@
 	 */
 	if ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT) {
 		statefault = 2;
-		printk(KERN_WARNING MYNAM ": %s: Uh-oh, IOC is in FAULT state!!!\n",
+		printk(MYIOC_s_WARN_FMT "IOC is in FAULT state!!!\n",
 				ioc->name);
 		printk(KERN_WARNING "           FAULT code = %04xh\n",
 				ioc_state & MPI_DOORBELL_DATA_MASK);
@@ -1623,28 +1919,49 @@
 	 *	Hmmm...  Did it get left operational?
 	 */
 	if ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_OPERATIONAL) {
-		statefault = 3;
-		dprintk((KERN_WARNING MYNAM ": %s: Hmmm... IOC operational unexpected\n",
+		dprintk((MYIOC_s_WARN_FMT "IOC operational unexpected\n",
 				ioc->name));
+
+		/* Check WhoInit.
+		 * If PCI Peer, exit.
+		 * Else, if no fault conditions are present, issue a MessageUnitReset
+		 * Else, fall through to KickStart case
+		 */
+		whoinit = (ioc_state & MPI_DOORBELL_WHO_INIT_MASK) >> MPI_DOORBELL_WHO_INIT_SHIFT;
+		dprintk((KERN_WARNING MYNAM
+			": whoinit 0x%x\n statefault %d force %d\n",
+			whoinit, statefault, force));
+		if (whoinit == MPI_WHOINIT_PCI_PEER)
+			return -4;
+		else {
+			if ((statefault == 0 ) && (force == 0)) {
+				if ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) == 0)
+					return 0;
+			}
+			statefault = 3;
+		}
 	}
 
-	hard_reset_done = KickStart(ioc, statefault||force);
+	hard_reset_done = KickStart(ioc, statefault||force, sleepFlag);
 	if (hard_reset_done < 0)
 		return -1;
 
 	/*
 	 *  Loop here waiting for IOC to come READY.
 	 */
-	i = 0;
+	ii = 0;
 	cntdn = HZ * 15;
-	while ((ioc_state = GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
+	if (sleepFlag != CAN_SLEEP)
+		cntdn *= 10;	/* 1500 iterations @ 1msec per */
+
+	while ((ioc_state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
 		if (ioc_state == MPI_IOC_STATE_OPERATIONAL) {
 			/*
 			 *  BIOS or previous driver load left IOC in OP state.
 			 *  Reset messaging FIFOs.
 			 */
-			if ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET)) != 0) {
-				printk(KERN_ERR MYNAM ": %s: ERROR - IOC msg unit reset failed!\n", ioc->name);
+			if ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) != 0) {
+				printk(MYIOC_s_ERR_FMT "IOC msg unit reset failed!\n", ioc->name);
 				return -2;
 			}
 		} else if (ioc_state == MPI_IOC_STATE_RESET) {
@@ -1652,25 +1969,30 @@
 			 *  Something is wrong.  Try to get IOC back
 			 *  to a known state.
 			 */
-			if ((r = SendIocReset(ioc, MPI_FUNCTION_IO_UNIT_RESET)) != 0) {
-				printk(KERN_ERR MYNAM ": %s: ERROR - IO unit reset failed!\n", ioc->name);
+			if ((r = SendIocReset(ioc, MPI_FUNCTION_IO_UNIT_RESET, sleepFlag)) != 0) {
+				printk(MYIOC_s_ERR_FMT "IO unit reset failed!\n", ioc->name);
 				return -3;
 			}
 		}
 
-		i++; cntdn--;
+		ii++; cntdn--;
 		if (!cntdn) {
-			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_READY state timeout(%d)!\n",
-					ioc->name, (i+5)/HZ);
+			printk(MYIOC_s_ERR_FMT "Wait IOC_READY state timeout(%d)!\n",
+					ioc->name, (ii+5)/HZ);
 			return -ETIME;
 		}
 
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay (1);	/* 1 msec delay */
+		}
+
 	}
 
 	if (statefault < 3) {
-		printk(KERN_WARNING MYNAM ": %s: Whew!  Recovered from %s\n",
+		printk(MYIOC_s_INFO_FMT "Recovered from %s\n",
 				ioc->name,
 				statefault==1 ? "stuck handshake" : "IOC FAULT");
 	}
@@ -1680,21 +2002,21 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	GetIocState - Get the current state of a MPT adapter.
+ *	mpt_GetIocState - Get the current state of a MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@cooked: Request raw or cooked IOC state
  *
  *	Returns all IOC Doorbell register bits if cooked==0, else just the
  *	Doorbell bits in MPI_IOC_STATE_MASK.
  */
-static u32
-GetIocState(MPT_ADAPTER *ioc, int cooked)
+u32
+mpt_GetIocState(MPT_ADAPTER *ioc, int cooked)
 {
 	u32 s, sc;
 
 	/*  Get!  */
 	s = CHIPREG_READ32(&ioc->chip->Doorbell);
-	dprintk((KERN_INFO MYNAM ": %s: raw state = %08x\n", ioc->name, s));
+//	dprintk((MYIOC_s_INFO_FMT "raw state = %08x\n", ioc->name, s));
 	sc = s & MPI_IOC_STATE_MASK;
 
 	/*  Save!  */
@@ -1707,11 +2029,13 @@
 /*
  *	GetIocFacts - Send IOCFacts request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@sleepFlag: Specifies whether the process can sleep
+ *	@reason: If recovery, only update facts.
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-GetIocFacts(MPT_ADAPTER *ioc)
+GetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason)
 {
 	IOCFacts_t		 get_facts;
 	IOCFactsReply_t		*facts;
@@ -1741,14 +2065,13 @@
 	get_facts.Function = MPI_FUNCTION_IOC_FACTS;
 	/* Assert: All other get_facts fields are zero! */
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending get IocFacts request\n", ioc->name));
+	dprintk((MYIOC_s_INFO_FMT "Sending get IocFacts request\n", ioc->name));
 
 	/* No non-zero fields in the get_facts request are greater than
 	 * 1 byte in size, so we can just fire it off as is.
 	 */
-	r = HandShakeReqAndReply(ioc,
-			req_sz, (u32*)&get_facts,
-			reply_sz, (u16*)facts, 3);
+	r = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_facts,
+			reply_sz, (u16*)facts, 3 /*seconds*/, sleepFlag);
 	if (r != 0)
 		return r;
 
@@ -1761,14 +2084,17 @@
 	 */
 	/* Did we get a valid reply? */
 	if (facts->MsgLength > offsetof(IOCFactsReply_t, RequestFrameSize)/sizeof(u32)) {
-		/*
-		 * If not been here, done that, save off first WhoInit value
-		 */
-		if (ioc->FirstWhoInit == WHOINIT_UNKNOWN)
-			ioc->FirstWhoInit = facts->WhoInit;
+		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+			/*
+			 * If not been here, done that, save off first WhoInit value
+			 */
+			if (ioc->FirstWhoInit == WHOINIT_UNKNOWN)
+				ioc->FirstWhoInit = facts->WhoInit;
+		}
 
 		facts->MsgVersion = le16_to_cpu(facts->MsgVersion);
 		facts->MsgContext = le32_to_cpu(facts->MsgContext);
+		facts->IOCExceptions = le16_to_cpu(facts->IOCExceptions);
 		facts->IOCStatus = le16_to_cpu(facts->IOCStatus);
 		facts->IOCLogInfo = le32_to_cpu(facts->IOCLogInfo);
 		status = facts->IOCStatus & MPI_IOCSTATUS_MASK;
@@ -1776,7 +2102,23 @@
 
 		facts->ReplyQueueDepth = le16_to_cpu(facts->ReplyQueueDepth);
 		facts->RequestFrameSize = le16_to_cpu(facts->RequestFrameSize);
-		facts->FWVersion = le16_to_cpu(facts->FWVersion);
+
+		/*
+		 * FC f/w version changed between 1.1 and 1.2 
+		 *	Old: u16{Major(4),Minor(4),SubMinor(8)}
+		 *	New: u32{Major(8),Minor(8),Unit(8),Dev(8)}
+		 */
+		if (facts->MsgVersion < 0x0102) {
+			/*
+			 *	Handle old FC f/w style, convert to new...
+			 */
+			u16	 oldv = le16_to_cpu(facts->Reserved_0101_FWVersion);
+			facts->FWVersion.Word =
+					((oldv<<12) & 0xFF000000) |
+					((oldv<<8)  & 0x000FFF00);
+		} else
+			facts->FWVersion.Word = le32_to_cpu(facts->FWVersion.Word);
+
 		facts->ProductID = le16_to_cpu(facts->ProductID);
 		facts->CurrentHostMfaHighAddr =
 				le32_to_cpu(facts->CurrentHostMfaHighAddr);
@@ -1791,52 +2133,42 @@
 		 * Older MPI-1.00.xx struct had 13 dwords, and enlarged
 		 * to 14 in MPI-1.01.0x.
 		 */
-		if (facts->MsgLength >= sizeof(IOCFactsReply_t)/sizeof(u32) && facts->MsgVersion > 0x0100) {
+		if (facts->MsgLength >= (offsetof(IOCFactsReply_t,FWImageSize) + 7)/4 &&
+		    facts->MsgVersion > 0x0100) {
 			facts->FWImageSize = le32_to_cpu(facts->FWImageSize);
-			facts->DataImageSize = le32_to_cpu(facts->DataImageSize);
 		}
 
-		if (facts->RequestFrameSize) {
-			/*
-			 * Set values for this IOC's REQUEST queue size & depth...
-			 */
-			ioc->req_sz = MIN(MPT_REQ_SIZE, facts->RequestFrameSize * 4);
-
-			/*
-			 *  Set values for this IOC's REPLY queue size & depth...
-			 *
-			 * BUG? FIX?  20000516 -nromer & sralston 
-			 *  GRRR...  The following did not translate well from MPI v0.09:
-			 *	ioc->reply_sz = MIN(MPT_REPLY_SIZE, facts->ReplySize * 4);
-			 *  to 0.10:
-			 *	ioc->reply_sz = MIN(MPT_REPLY_SIZE, facts->BlockSize * 4);
-			 *  Was trying to minimally optimize to smallest possible reply size
-			 *  (and greatly reduce kmalloc size).  But LAN may need larger reply?
-			 *
-			 *  So for now, just set reply size to request size.  FIXME?
-			 */
-			ioc->reply_sz = ioc->req_sz;
-		} else {
+		if (!facts->RequestFrameSize) {
 			/*  Something is wrong!  */
-			printk(KERN_ERR MYNAM ": %s: ERROR - IOC reported invalid 0 request size!\n",
+			printk(MYIOC_s_ERR_FMT "IOC reported invalid 0 request size!\n",
 					ioc->name);
-			ioc->req_sz = MPT_REQ_SIZE;
-			ioc->reply_sz = MPT_REPLY_SIZE;
 			return -55;
 		}
-		ioc->req_depth = MIN(MPT_REQ_DEPTH, facts->GlobalCredits);
-		ioc->reply_depth = MIN(MPT_REPLY_DEPTH, facts->ReplyQueueDepth);
 
-		dprintk((KERN_INFO MYNAM ": %s: reply_sz=%3d, reply_depth=%4d\n",
+		if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {
+			/*
+			 * Set values for this IOC's request & reply frame sizes,
+			 * and request & reply queue depths...
+			 */
+			ioc->req_sz = MIN(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);
+			ioc->req_depth = MIN(MPT_DEFAULT_REQ_DEPTH, facts->GlobalCredits);
+			ioc->reply_sz = ioc->req_sz;
+			ioc->reply_depth = MIN(MPT_DEFAULT_REPLY_DEPTH, facts->ReplyQueueDepth);
+
+			/* 1030 - should we use a smaller DEFAULT_REPLY_DEPTH?
+			 * FIX
+			 */
+			dprintk((MYIOC_s_INFO_FMT "reply_sz=%3d, reply_depth=%4d\n",
 				ioc->name, ioc->reply_sz, ioc->reply_depth));
-		dprintk((KERN_INFO MYNAM ": %s: req_sz  =%3d, req_depth  =%4d\n",
+			dprintk((MYIOC_s_INFO_FMT "req_sz  =%3d, req_depth  =%4d\n",
 				ioc->name, ioc->req_sz, ioc->req_depth));
 
-		/* Get port facts! */
-		if ( (r = GetPortFacts(ioc, 0)) != 0 )
-			return r;
+			/* Get port facts! */
+			if ( (r = GetPortFacts(ioc, 0, sleepFlag)) != 0 )
+				return r;
+		}
 	} else {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Invalid IOC facts reply!\n",
+		printk(MYIOC_s_ERR_FMT "Invalid IOC facts reply!\n",
 				ioc->name);
 		return -66;
 	}
@@ -1849,15 +2181,16 @@
  *	GetPortFacts - Send PortFacts request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@portnum: Port number
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-GetPortFacts(MPT_ADAPTER *ioc, int portnum)
+GetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag)
 {
 	PortFacts_t		 get_pfacts;
 	PortFactsReply_t	*pfacts;
-	int			 i;
+	int			 ii;
 	int			 req_sz;
 	int			 reply_sz;
 
@@ -1883,16 +2216,16 @@
 	get_pfacts.PortNumber = portnum;
 	/* Assert: All other get_pfacts fields are zero! */
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending get PortFacts(%d) request\n",
+	dprintk((MYIOC_s_INFO_FMT "Sending get PortFacts(%d) request\n",
 			ioc->name, portnum));
 
 	/* No non-zero fields in the get_pfacts request are greater than
 	 * 1 byte in size, so we can just fire it off as is.
 	 */
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&get_pfacts,
-				reply_sz, (u16*)pfacts, 3);
-	if (i != 0)
-		return i;
+	ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_pfacts,
+				reply_sz, (u16*)pfacts, 3 /*seconds*/, sleepFlag);
+	if (ii != 0)
+		return ii;
 
 	/* Did we get a valid reply? */
 
@@ -1914,13 +2247,14 @@
 /*
  *	SendIocInit - Send IOCInit request to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	Send IOCInit followed by PortEnable to bring IOC to OPERATIONAL state.
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-SendIocInit(MPT_ADAPTER *ioc)
+SendIocInit(MPT_ADAPTER *ioc, int sleepFlag)
 {
 	IOCInit_t		 ioc_init;
 	MPIDefaultReply_t	 init_reply;
@@ -1937,20 +2271,35 @@
 	ioc_init.Function = MPI_FUNCTION_IOC_INIT;
 /*	ioc_init.Flags = 0;				*/
 
-	/*ioc_init.MaxDevices = 16;*/
-	ioc_init.MaxDevices = 255;
-/*	ioc_init.MaxBuses = 16;				*/
-	ioc_init.MaxBuses = 1;
+	if ((int)ioc->chip_type <= (int)FC929) {
+		ioc_init.MaxDevices = MPT_MAX_FC_DEVICES;
+	}
+	else {
+		ioc_init.MaxDevices = MPT_MAX_SCSI_DEVICES;
+	}
+	ioc_init.MaxBuses = MPT_MAX_BUS;
 
 /*	ioc_init.MsgFlags = 0;				*/
 /*	ioc_init.MsgContext = cpu_to_le32(0x00000000);	*/
 	ioc_init.ReplyFrameSize = cpu_to_le16(ioc->reply_sz);	/* in BYTES */
-	ioc_init.HostMfaHighAddr = cpu_to_le32(0);	/* Say we 32-bit! for now */
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending IOCInit (req @ %p)\n", ioc->name, &ioc_init));
+#ifdef __ia64__
+	/* Save the upper 32-bits of the request
+	 * (reply) and sense buffers.
+	 */
+	ioc_init.HostMfaHighAddr = cpu_to_le32((u32)(ioc->req_frames_dma >> 32));
+	ioc_init.SenseBufferHighAddr = cpu_to_le32((u32)(ioc->sense_buf_pool_dma >> 32));
+#else
+	/* Force 32-bit addressing */
+	ioc_init.HostMfaHighAddr = cpu_to_le32(0);
+	ioc_init.SenseBufferHighAddr = cpu_to_le32(0);
+#endif
 
-	r = HandShakeReqAndReply(ioc, sizeof(IOCInit_t), (u32*)&ioc_init,
-			sizeof(MPIDefaultReply_t), (u16*)&init_reply, 10);
+	dprintk((MYIOC_s_INFO_FMT "Sending IOCInit (req @ %p)\n",
+			ioc->name, &ioc_init));
+
+	r = mpt_handshake_req_reply_wait(ioc, sizeof(IOCInit_t), (u32*)&ioc_init,
+				sizeof(MPIDefaultReply_t), (u16*)&init_reply, 10 /*seconds*/, sleepFlag);
 	if (r != 0)
 		return r;
 
@@ -1958,7 +2307,7 @@
 	 * since we don't even look at it's contents.
 	 */
 
-	if ((r = SendPortEnable(ioc, 0)) != 0)
+	if ((r = SendPortEnable(ioc, 0, sleepFlag)) != 0)
 		return r;
 
 	/* YIKES!  SUPER IMPORTANT!!!
@@ -1967,21 +2316,27 @@
 	 */
 	count = 0;
 	cntdn = HZ * 60;					/* chg'd from 30 to 60 seconds */
-	state = GetIocState(ioc, 1);
+	if (sleepFlag != CAN_SLEEP)
+		cntdn *= 10;					/* scale for 1msec delays */
+	state = mpt_GetIocState(ioc, 1);
 	while (state != MPI_IOC_STATE_OPERATIONAL && --cntdn) {
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay(1);
+		}
 
 		if (!cntdn) {
-			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_OP state timeout(%d)!\n",
+			printk(MYIOC_s_ERR_FMT "Wait IOC_OP state timeout(%d)!\n",
 					ioc->name, (count+5)/HZ);
 			return -9;
 		}
 
-		state = GetIocState(ioc, 1);
+		state = mpt_GetIocState(ioc, 1);
 		count++;
 	}
-	dhsprintk((KERN_INFO MYNAM ": %s: INFO - Wait IOC_OPERATIONAL state (cnt=%d)\n",
+	dhsprintk((MYIOC_s_INFO_FMT "INFO - Wait IOC_OPERATIONAL state (cnt=%d)\n",
 			ioc->name, count));
 
 	return r;
@@ -1992,17 +2347,18 @@
  *	SendPortEnable - Send PortEnable request to MPT adapter port.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@portnum: Port number to enable
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	Send PortEnable to bring IOC to OPERATIONAL state.
  *
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-SendPortEnable(MPT_ADAPTER *ioc, int portnum)
+SendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag)
 {
 	PortEnable_t		 port_enable;
 	MPIDefaultReply_t	 reply_buf;
-	int	 i;
+	int	 ii;
 	int	 req_sz;
 	int	 reply_sz;
 
@@ -2019,13 +2375,21 @@
 /*	port_enable.MsgFlags = 0;		*/
 /*	port_enable.MsgContext = 0;		*/
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending Port(%d)Enable (req @ %p)\n",
+	dprintk((MYIOC_s_INFO_FMT "Sending Port(%d)Enable (req @ %p)\n",
 			ioc->name, portnum, &port_enable));
 
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&port_enable,
-			reply_sz, (u16*)&reply_buf, 65);
-	if (i != 0)
-		return i;
+	/* RAID FW may take a long time to enable
+	 */
+	if ((int)ioc->chip_type <= (int)FC929) {
+		ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
+				reply_sz, (u16*)&reply_buf, 65 /*seconds*/, sleepFlag);
+	} else {
+		ii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&port_enable,
+				reply_sz, (u16*)&reply_buf, 300 /*seconds*/, sleepFlag);
+	}
+
+	if (ii != 0)
+		return ii;
 
 	/* We do not even look at the reply, so we need not
 	 * swap the multi-byte fields.
@@ -2036,19 +2400,341 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
+ *	mpt_do_upload - Construct and Send FWUpload request to MPT adapter port.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@sleepFlag: Specifies whether the process can sleep
+ *
+ *	Returns 0 for success, >0 for handshake failure
+ *		<0 for fw upload failure.
+ *
+ *	Remark: If bound IOC and a successful FWUpload was performed
+ *	on the bound IOC, the second image is discarded
+ *	and memory is free'd. Both channels must upload to prevent
+ *	IOC from running in degraded mode.
+ */
+static int
+mpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag)
+{
+	u8			 request[sizeof(FWUpload_t) +  24];
+	u8			 reply[sizeof(FWUploadReply_t)];
+	FWUpload_t		*prequest;
+	FWUploadReply_t		*preply;
+	FWUploadTCSGE_t		*ptcsge = NULL;
+	MptSge_t		*psge;
+	u8			*mem;
+	dma_addr_t		 dma_addr;
+	int			 sgeoffset;
+	int			 i, sz, req_sz, reply_sz;
+	int			 cmdStatus, freeMem = 0;
+
+	/* If the image size is 0 or if the pointer is
+	 * not NULL (error), we are done.
+	 */
+	if (((sz = ioc->facts.FWImageSize) == 0) || ioc->FWImage)
+		return 0;
+
+	/* Allocate memory
+	 */
+	mem = pci_alloc_consistent(ioc->pcidev, sz, &ioc->FWImage_dma);
+	if (mem == NULL)
+		return -1;
+
+	memset(mem, 0, sz);
+	ioc->alloc_total += sz;
+	ioc->FWImage = mem;
+	dprintk((KERN_INFO MYNAM ": FW Image  @ %p[%p], sz=%d bytes\n",
+			mem, (void *)(ulong)ioc->FWImage_dma, sz));
+
+	dma_addr = ioc->FWImage_dma;
+
+	prequest = (FWUpload_t *)&request;
+	preply = (FWUploadReply_t *)&reply;
+
+	/*  Destination...  */
+	req_sz = sizeof(FWUpload_t) - sizeof(SGE_MPI_UNION)
+			+ sizeof(FWUploadTCSGE_t) + sizeof(MptSge_t);
+	memset(prequest, 0, req_sz);
+
+	reply_sz = sizeof(reply);
+	memset(preply, 0, reply_sz);
+
+	prequest->ImageType = MPI_FW_UPLOAD_ITYPE_FW_IOC_MEM;
+	prequest->Function = MPI_FUNCTION_FW_UPLOAD;
+	prequest->MsgContext = 0;		/* anything */
+
+	ptcsge = (FWUploadTCSGE_t *) &prequest->SGL;
+	ptcsge->Reserved = 0;
+	ptcsge->ContextSize = 0;
+	ptcsge->DetailsLength = 12;
+	ptcsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
+	ptcsge->Reserved1 = 0;
+	ptcsge->ImageOffset = 0;
+	ptcsge->ImageSize = cpu_to_le32(sz);
+
+	sgeoffset = sizeof(FWUpload_t) - sizeof(SGE_MPI_UNION) + sizeof(FWUploadTCSGE_t);
+	psge = (MptSge_t *) &request[sgeoffset];
+	psge->FlagsLength = cpu_to_le32(MPT_SGE_FLAGS_SSIMPLE_READ | (u32) sz);
+
+	cpu_to_leXX(dma_addr, psge->Address);
+
+	dprintk((MYIOC_s_INFO_FMT "Sending FW Upload (req @ %p)\n",
+			ioc->name, prequest));
+
+	i = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)prequest,
+				reply_sz, (u16*)preply, 65 /*seconds*/, sleepFlag);
+
+	cmdStatus = -EFAULT;
+	if (i == 0) {
+		/* Handshake transfer was complete and successful.
+		 * Check the Reply Frame.
+		 */
+		int status, transfer_sz;
+		status = le16_to_cpu(preply->IOCStatus);
+		if (status == MPI_IOCSTATUS_SUCCESS) {
+			transfer_sz = le32_to_cpu(preply->ActualImageSize);
+			if (transfer_sz == sz)
+				cmdStatus = 0;
+		}
+	}
+	dprintk((MYIOC_s_INFO_FMT ": do_upload status %d \n",
+			ioc->name, cmdStatus));
+
+	/* Check to see if we have a copy of this image in
+	 * host memory already.
+	 */
+	if (cmdStatus == 0) {
+		if (ioc->alt_ioc && ioc->alt_ioc->FWImage)
+			freeMem = 1;
+	}
+
+	/* We already have a copy of this image or
+	 * we had some type of an error  - either the handshake
+	 * failed (i != 0) or the command did not complete successfully.
+	 */
+	if (cmdStatus || freeMem) {
+		dprintk((MYIOC_s_INFO_FMT ": do_upload freeing %s image \n",
+			ioc->name, cmdStatus ? "incomplete" : "duplicate"));
+
+		pci_free_consistent(ioc->pcidev, sz,
+					ioc->FWImage, ioc->FWImage_dma);
+		ioc->FWImage = NULL;
+		ioc->alloc_total -= sz;
+	}
+
+	return cmdStatus;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mpt_downloadboot - DownloadBoot code
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@flag: Specify which part of IOC memory is to be uploaded.
+ *	@sleepFlag: Specifies whether the process can sleep
+ *
+ *	FwDownloadBoot requires Programmed IO access.
+ *
+ *	Returns 0 for success
+ *		-1 FW Image size is 0
+ *		-2 No valid FWImage Pointer
+ *		<0 for fw upload failure.
+ */
+static int
+mpt_downloadboot(MPT_ADAPTER *ioc, int sleepFlag)
+{
+	MpiFwHeader_t		*FwHdr = NULL;
+	MpiExtImageHeader_t 	*ExtHdr;
+	int			 fw_sz;
+	u32			 diag0val;
+#ifdef MPT_DEBUG
+	u32			 diag1val = 0;
+#endif
+	int			 count = 0;
+	u32			*ptru32 = NULL;
+	u32			 diagRwData;
+	u32			 nextImage;
+
+	dprintk((MYIOC_s_INFO_FMT "DbGb0: downloadboot entered.\n",
+				ioc->name));
+#ifdef MPT_DEBUG
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	if (ioc->alt_ioc)
+		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+	dprintk((MYIOC_s_INFO_FMT "DbGb1: diag0=%08x, diag1=%08x\n",
+				ioc->name, diag0val, diag1val));
+#endif
+
+	dprintk((MYIOC_s_INFO_FMT "fw size 0x%x, ioc FW Ptr %p\n",
+				ioc->name, ioc->facts.FWImageSize, ioc->FWImage));
+	if (ioc->alt_ioc)
+		dprintk((MYIOC_s_INFO_FMT "alt ioc FW Ptr %p\n",
+				ioc->name, ioc->alt_ioc->FWImage));
+
+	/* Get dma_addr and data transfer size.
+	 */
+	if ((fw_sz = ioc->facts.FWImageSize) == 0)
+		return -1;
+
+	/* Get the DMA from ioc or ioc->alt_ioc */
+	if (ioc->FWImage)
+		FwHdr = (MpiFwHeader_t *)ioc->FWImage;
+	else if (ioc->alt_ioc && ioc->alt_ioc->FWImage)
+		FwHdr = (MpiFwHeader_t *)ioc->alt_ioc->FWImage;
+
+	dprintk((MYIOC_s_INFO_FMT "DbGb2: FW Image @ %p\n",
+			ioc->name, FwHdr));
+
+	if (!FwHdr)
+		return -2;
+
+	/* Write magic sequence to WriteSequence register
+	 * until enter diagnostic mode
+	 */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	while ((diag0val & MPI_DIAG_DRWE) == 0) {
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
+		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
+
+		/* wait 100 msec */
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(100 * HZ / 1000);
+		} else {
+			mdelay (100);
+		}
+
+		count++;
+		if (count > 20) {
+			printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
+					ioc->name, diag0val);
+			return -EFAULT;
+
+		}
+
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+#ifdef MPT_DEBUG
+		if (ioc->alt_ioc)
+			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+		dprintk((MYIOC_s_INFO_FMT "DbGb3: diag0=%08x, diag1=%08x\n",
+				ioc->name, diag0val, diag1val));
+#endif
+		dprintk((MYIOC_s_INFO_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
+				ioc->name, diag0val));
+	}
+
+	/* Set the DiagRwEn and Disable ARM bits */
+	diag0val |= (MPI_DIAG_RW_ENABLE | MPI_DIAG_DISABLE_ARM);
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+
+#ifdef MPT_DEBUG
+	if (ioc->alt_ioc)
+		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+	dprintk((MYIOC_s_INFO_FMT "DbGb3: diag0=%08x, diag1=%08x\n",
+			ioc->name, diag0val, diag1val));
+#endif
+
+	/* Write the LoadStartAddress to the DiagRw Address Register
+	 * using Programmed IO
+	 */
+
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, FwHdr->LoadStartAddress);
+	dprintk((MYIOC_s_INFO_FMT "LoadStart addr written 0x%x \n",
+		ioc->name, FwHdr->LoadStartAddress));
+
+	nextImage = FwHdr->NextImageHeaderOffset;
+
+	/* round up count to a 32bit alignment */
+	ptru32 = (u32 *) FwHdr;
+	count = (FwHdr->ImageSize + 3)/4;
+
+	dprintk((MYIOC_s_INFO_FMT "Write FW Image: 0x%x u32's @ %p\n",
+				ioc->name, count, ptru32));
+	while (count-- ) {
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptru32);
+		ptru32++;
+	}
+
+	dprintk((MYIOC_s_INFO_FMT "FW Image done! \n", ioc->name));
+		
+	while (nextImage) {
+
+		/* Set the pointer to the extended image
+		 */
+		ExtHdr = (MpiExtImageHeader_t *) ((char *) FwHdr + nextImage);
+
+		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, ExtHdr->LoadStartAddress);
+
+		count = (ExtHdr->ImageSize + 3 )/4;
+
+		ptru32 = (u32 *) ExtHdr;
+		dprintk((MYIOC_s_INFO_FMT "Write Ext Image: 0x%x u32's @ %p\n",
+				ioc->name, count, ptru32));
+		while (count-- ) {
+			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptru32);
+			ptru32++;
+		}
+		nextImage = ExtHdr->NextImageHeaderOffset;
+	}
+
+
+	/* Write the IopResetVectorRegAddr */
+	dprintk((MYIOC_s_INFO_FMT "Write IopResetVector Addr! \n", ioc->name));
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, FwHdr->IopResetRegAddr);
+
+	/* Write the IopResetVectorValue */
+	dprintk((MYIOC_s_INFO_FMT "Write IopResetVector Value! \n", ioc->name));
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, FwHdr->IopResetVectorValue);
+
+	/* Clear the internal flash bad bit - autoincrementing register,
+	 * so must do two writes.
+	 */
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
+	diagRwData = CHIPREG_PIO_READ32(&ioc->pio_chip->DiagRwData);
+	diagRwData |= 0x4000000;
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
+	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, diagRwData);
+
+	/* clear the RW enable and DISARM bits */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	diag0val &= ~(MPI_DIAG_DISABLE_ARM | MPI_DIAG_RW_ENABLE | MPI_DIAG_FLASH_BAD_SIG);
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+
+	/* Write 0xFF to reset the sequencer */
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
  *	KickStart - Perform hard reset of MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@force: Force hard reset
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine places MPT adapter in diagnostic mode via the
  *	WriteSequence register, and then performs a hard reset of adapter
  *	via the Diagnostic register.
  *
- *	Returns 0 for soft reset success, 1 for hard reset success,
- *	else a negative value for failure.
+ *	Inputs:   sleepflag - CAN_SLEEP (non-interrupt thread)
+ *			or NO_SLEEP (interrupt thread, use mdelay)
+ *		  force - 1 if doorbell active, board fault state
+ *				board operational, IOC_RECOVERY or
+ *				IOC_BRINGUP and there is an alt_ioc.
+ *			  0 else
+ *
+ *	Returns:
+ *		 1 - hard reset, READY	
+ *		 0 - no reset due to History bit, READY	
+ *		-1 - no reset due to History bit but not READY	
+ *		     OR reset but failed to come READY
+ *		-2 - no reset, could not enter DIAG mode 
+ *		-3 - reset but bad FW bit 
  */
 static int
-KickStart(MPT_ADAPTER *ioc, int force)
+KickStart(MPT_ADAPTER *ioc, int force, int sleepFlag)
 {
 	int hard_reset_done = 0;
 	u32 ioc_state;
@@ -2056,183 +2742,295 @@
 
 	dprintk((KERN_WARNING MYNAM ": KickStarting %s!\n", ioc->name));
 
-	hard_reset_done = mpt_fc9x9_reset(ioc, force);
-#if 0
-	if (ioc->chip_type == FC909 || ioc->chip-type == FC919) {
-		hard_reset_done = mpt_fc9x9_reset(ioc, force);
-	} else if (ioc->chip_type == FC929) {
-		unsigned long delta;
-
-		delta = jiffies - ioc->last_kickstart;
-		dprintk((KERN_INFO MYNAM ": %s: 929 KickStart, last=%ld, delta = %ld\n",
-				ioc->name, ioc->last_kickstart, delta));
-		if ((ioc->sod_reset == 0) || (delta >= 10*HZ))
-			hard_reset_done = mpt_fc9x9_reset(ioc, ignore);
-		else {
-			dprintk((KERN_INFO MYNAM ": %s: Skipping KickStart (delta=%ld)!\n",
-					ioc->name, delta));
-			return 0;
-		}
-	/* TODO! Add C1030!
-	} else if (ioc->chip_type == C1030) {
-	 */
-	} else {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Bad chip_type (0x%x)\n",
-				ioc->name, ioc->chip_type);
-		return -5;
-	}
-#endif
-
+	hard_reset_done = mpt_diag_reset(ioc, force, sleepFlag);
 	if (hard_reset_done < 0)
 		return hard_reset_done;
 
-	dprintk((KERN_INFO MYNAM ": %s: Diagnostic reset successful\n",
+	dprintk((MYIOC_s_INFO_FMT "Diagnostic reset successful!\n",
 			ioc->name));
 
 	for (cnt=0; cnt<HZ*20; cnt++) {
-		if ((ioc_state = GetIocState(ioc, 1)) == MPI_IOC_STATE_READY) {
-			dprintk((KERN_INFO MYNAM ": %s: KickStart successful! (cnt=%d)\n",
+		if ((ioc_state = mpt_GetIocState(ioc, 1)) == MPI_IOC_STATE_READY) {
+			dprintk((MYIOC_s_INFO_FMT "KickStart successful! (cnt=%d)\n",
 					ioc->name, cnt));
 			return hard_reset_done;
 		}
-		/* udelay(10000) ? */
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay (10);
+		}
 	}
 
-	printk(KERN_ERR MYNAM ": %s: ERROR - Failed to come READY after reset!\n",
+	printk(MYIOC_s_ERR_FMT "Failed to come READY after reset!\n",
 			ioc->name);
 	return -1;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	mpt_fc9x9_reset - Perform hard reset of FC9x9 adapter.
+ *	mpt_diag_reset - Perform hard reset of the adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
- *
- *	This routine places FC9x9 adapter in diagnostic mode via the
- *	WriteSequence register, and then performs a hard reset of adapter
- *	via the Diagnostic register.
- *
- *	Returns 0 for success, non-zero for failure.
+ *	@ignore: Set if to honor and clear to ignore
+ *		the reset history bit
+ *	@sleepflag: CAN_SLEEP if called in a non-interrupt thread,
+ *		else set to NO_SLEEP (use mdelay instead)
+ *
+ *	This routine places the adapter in diagnostic mode via the
+ *	WriteSequence register and then performs a hard reset of adapter
+ *	via the Diagnostic register. Adapter should be in ready state
+ *	upon successful completion.
+ *
+ *	Returns:  1  hard reset successful
+ *		  0  no reset performed because reset history bit set
+ *		 -2  enabling diagnostic mode failed
+ *		 -3  diagnostic reset failed
  */
 static int
-mpt_fc9x9_reset(MPT_ADAPTER *ioc, int ignore)
+mpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag)
 {
 	u32 diag0val;
+	u32 doorbell;
 	int hard_reset_done = 0;
+	int count = 0;
+#ifdef MPT_DEBUG
+	u32 diag1val = 0;
+#endif
 
-	/* Use "Diagnostic reset" method! (only thing available!) */
+	/* Clear any existing interrupts */
+	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
+	/* Use "Diagnostic reset" method! (only thing available!) */
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+
 #ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
 	if (ioc->alt_ioc)
 		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DBG1: diag0=%08x, diag1=%08x\n",
+	dprintk((MYIOC_s_INFO_FMT "DbG1: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
-}
 #endif
-	if (diag0val & MPI_DIAG_DRWE) {
-		dprintk((KERN_INFO MYNAM ": %s: DiagWriteEn bit already set\n",
-				ioc->name));
-	} else {
-		/* Write magic sequence to WriteSequence register */
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
-		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
-		dprintk((KERN_INFO MYNAM ": %s: Wrote magic DiagWriteEn sequence [spot#1]\n",
-				ioc->name));
-	}
 
-	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	/* Do the reset if we are told to ignore the reset history
+	 * or if the reset history is 0
+	 */
+	if (ignore || !(diag0val & MPI_DIAG_RESET_HISTORY)) {
+		while ((diag0val & MPI_DIAG_DRWE) == 0) {
+			/* Write magic sequence to WriteSequence register
+			 * Loop until in diagnostic mode
+			 */
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
+			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
+
+			/* wait 100 msec */
+			if (sleepFlag == CAN_SLEEP) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(100 * HZ / 1000);
+			} else {
+				mdelay (100);
+			}
+
+			count++;
+			if (count > 20) {
+				printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
+						ioc->name, diag0val);
+				return -2;
+
+			}
+
+			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+
+			dprintk((MYIOC_s_INFO_FMT "Wrote magic DiagWriteEn sequence (%x)\n",
+					ioc->name, diag0val));
+		}
+
 #ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
-	if (ioc->alt_ioc)
-		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DbG2: diag0=%08x, diag1=%08x\n",
-			ioc->name, diag0val, diag1val));
-}
+		if (ioc->alt_ioc)
+			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+		dprintk((MYIOC_s_INFO_FMT "DbG2: diag0=%08x, diag1=%08x\n",
+				ioc->name, diag0val, diag1val));
 #endif
-	if (!ignore && (diag0val & MPI_DIAG_RESET_HISTORY)) {
-		dprintk((KERN_INFO MYNAM ": %s: Skipping due to ResetHistory bit set!\n",
-				ioc->name));
-	} else {
+		/* Write the PreventIocBoot bit */
+		if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT) {
+			diag0val |= MPI_DIAG_PREVENT_IOC_BOOT;
+			CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
+		}
+
+		/*
+		 * Disable the ARM (Bug fix)
+		 * 
+		 */
+		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);
+		mdelay (1);
+
 		/*
 		 * Now hit the reset bit in the Diagnostic register
-		 * (THE BIG HAMMER!)
+		 * (THE BIG HAMMER!) (Clears DRWE bit).
 		 */
-		CHIPREG_WRITE32(&ioc->chip->Diagnostic, MPI_DIAG_RESET_ADAPTER);
+		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
 		hard_reset_done = 1;
-		dprintk((KERN_INFO MYNAM ": %s: Diagnostic reset performed\n",
+		dprintk((MYIOC_s_INFO_FMT "Diagnostic reset performed\n",
 				ioc->name));
 
-		/* want udelay(100) */
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		/*
+		 * Call each currently registered protocol IOC reset handler
+		 * with pre-reset indication.
+		 * NOTE: If we're doing _IOC_BRINGUP, there can be no
+		 * MptResetHandlers[] registered yet.
+		 */
+		{
+			int	 ii;
+			int	 r = 0;
+
+			for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+				if (MptResetHandlers[ii]) {
+					dprintk((MYIOC_s_INFO_FMT "Calling IOC pre_reset handler #%d\n",
+							ioc->name, ii));
+					r += (*(MptResetHandlers[ii]))(ioc, MPT_IOC_PRE_RESET);
+					if (ioc->alt_ioc) {
+						dprintk((MYIOC_s_INFO_FMT "Calling alt-%s pre_reset handler #%d\n",
+								ioc->name, ioc->alt_ioc->name, ii));
+						r += (*(MptResetHandlers[ii]))(ioc->alt_ioc, MPT_IOC_PRE_RESET);
+					}
+				}
+			}
+			/* FIXME?  Examine results here? */
+		}
+
+		if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT) {
+			/* If the DownloadBoot operation fails, the
+			 * IOC will be left unusable. This is a fatal error
+			 * case.  _diag_reset will return < 0
+			 */
+			for (count = 0; count < 30; count ++) {
+				diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+#ifdef MPT_DEBUG
+				if (ioc->alt_ioc)
+					diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+				dprintk((MYIOC_s_INFO_FMT 
+					"DbG2b: diag0=%08x, diag1=%08x\n",
+					ioc->name, diag0val, diag1val));
+#endif
+				if (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {
+					break;
+				}
+
+				/* wait 1 sec */
+				if (sleepFlag == CAN_SLEEP) {
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(HZ);
+				} else {
+					mdelay (1000);
+				}
+			}
+			if ((count = mpt_downloadboot(ioc, sleepFlag)) < 0) {
+				printk(KERN_WARNING MYNAM 
+					": firmware downloadboot failure (%d)!\n", count);
+			}
+
+		} else {
+			/* Wait for FW to reload and for board
+			 * to go to the READY state.
+			 * Maximum wait is 30 seconds.
+			 * If fail, no error will check again
+			 * with calling program.
+			 */
+			for (count = 0; count < 30; count ++) {
+				doorbell = CHIPREG_READ32(&ioc->chip->Doorbell);
+				doorbell &= MPI_IOC_STATE_MASK;
+
+				if (doorbell == MPI_IOC_STATE_READY) {
+					break;
+				}
+
+				/* wait 1 sec */
+				if (sleepFlag == CAN_SLEEP) {
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(HZ);
+				} else {
+					mdelay (1000);
+				}
+			}
+		}
+	}
 
-		/* Write magic sequence to WriteSequence register */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+#ifdef MPT_DEBUG
+	if (ioc->alt_ioc)
+		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
+	dprintk((MYIOC_s_INFO_FMT "DbG3: diag0=%08x, diag1=%08x\n",
+		ioc->name, diag0val, diag1val));
+#endif
+
+	/* Clear RESET_HISTORY bit!  Place board in the
+	 * diagnostic mode to update the diag register.
+	 */
+	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	count = 0;
+	while ((diag0val & MPI_DIAG_DRWE) == 0) {
+		/* Write magic sequence to WriteSequence register
+		 * Loop until in diagnostic mode
+		 */
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
 		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
-		dprintk((KERN_INFO MYNAM ": %s: Wrote magic DiagWriteEn sequence [spot#2]\n",
-				ioc->name));
-	}
 
-	/* Clear RESET_HISTORY bit! */
-	CHIPREG_WRITE32(&ioc->chip->Diagnostic, 0x0);
+		/* wait 100 msec */
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(100 * HZ / 1000);
+		} else {
+			mdelay (100);
+		}
 
+		count++;
+		if (count > 20) {
+			printk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",
+					ioc->name, diag0val);
+			break;
+		}
+		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	}
+	diag0val &= ~MPI_DIAG_RESET_HISTORY;
+	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
-#ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
-	if (ioc->alt_ioc)
-		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DbG3: diag0=%08x, diag1=%08x\n",
-			ioc->name, diag0val, diag1val));
-}
-#endif
 	if (diag0val & MPI_DIAG_RESET_HISTORY) {
-		printk(KERN_WARNING MYNAM ": %s: WARNING - ResetHistory bit failed to clear!\n",
+		printk(MYIOC_s_WARN_FMT "ResetHistory bit failed to clear!\n",
 				ioc->name);
 	}
 
+	/* Disable Diagnostic Mode
+	 */
+	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFFFFFFFF);
+
+	/* Check FW reload status flags.
+	 */
 	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
+	if (diag0val & (MPI_DIAG_FLASH_BAD_SIG | MPI_DIAG_RESET_ADAPTER | MPI_DIAG_DISABLE_ARM)) {
+		printk(MYIOC_s_ERR_FMT "Diagnostic reset FAILED! (%02xh)\n",
+				ioc->name, diag0val);
+		return -3;
+	}
+
 #ifdef MPT_DEBUG
-{
-	u32 diag1val = 0;
 	if (ioc->alt_ioc)
 		diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
-	dprintk((KERN_INFO MYNAM ": %s: DbG4: diag0=%08x, diag1=%08x\n",
+	dprintk((MYIOC_s_INFO_FMT "DbG4: diag0=%08x, diag1=%08x\n",
 			ioc->name, diag0val, diag1val));
-}
 #endif
-	if (diag0val & (MPI_DIAG_FLASH_BAD_SIG | MPI_DIAG_RESET_ADAPTER | MPI_DIAG_DISABLE_ARM)) {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Diagnostic reset FAILED! (%02xh)\n",
-				ioc->name, diag0val);
-		return -3;
-	}
 
 	/*
 	 * Reset flag that says we've enabled event notification
 	 */
 	ioc->facts.EventState = 0;
 
-	/* NEW!  20010220 -sralston
-	 * Try to avoid redundant resets of the 929.
-	 */
-	ioc->sod_reset++;
-	ioc->last_kickstart = jiffies;
-	if (ioc->alt_ioc) {
-		ioc->alt_ioc->sod_reset = ioc->sod_reset;
-		ioc->alt_ioc->last_kickstart = ioc->last_kickstart;
-	}
+	if (ioc->alt_ioc)
+		ioc->alt_ioc->facts.EventState = 0;
 
 	return hard_reset_done;
 }
@@ -2249,16 +3047,45 @@
  *	Returns 0 for success, non-zero for failure.
  */
 static int
-SendIocReset(MPT_ADAPTER *ioc, u8 reset_type)
+SendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag)
 {
 	int r;
+	u32 state;
+	int cntdn, count;
 
 	dprintk((KERN_WARNING MYNAM ": %s: Sending IOC reset(0x%02x)!\n",
 			ioc->name, reset_type));
 	CHIPREG_WRITE32(&ioc->chip->Doorbell, reset_type<<MPI_DOORBELL_FUNCTION_SHIFT);
-	if ((r = WaitForDoorbellAck(ioc, 2)) < 0)
+	if ((r = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
 		return r;
 
+	/* FW ACK'd request, wait for READY state 
+	 */
+	cntdn = HZ * 15;
+	count = 0;
+	if (sleepFlag != CAN_SLEEP)
+		cntdn *= 10;	/* 1500 iterations @ 1msec per */
+
+	while ((state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {
+		cntdn--;
+		count++;
+		if (!cntdn) {
+			if (sleepFlag != CAN_SLEEP)
+				count *= 10;
+
+			printk(KERN_ERR MYNAM ": %s: ERROR - Wait IOC_READY state timeout(%d)!\n",
+					ioc->name, (count+5)/HZ);
+			return -ETIME;
+		}
+
+		if (sleepFlag == CAN_SLEEP) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		} else {
+			mdelay (1);	/* 1 msec delay */
+		}
+	}
+
 	/* TODO!
 	 *  Cleanup all event stuff for this IOC; re-issue EventNotification
 	 *  request if needed.
@@ -2275,7 +3102,8 @@
  *	@ioc: Pointer to MPT_ADAPTER structure
  *
  *	This routine allocates memory for the MPT reply and request frame
- *	pools, and primes the IOC reply FIFO with reply frames.
+ *	pools (if necessary), and primes the IOC reply FIFO with
+ *	reply frames.
  *
  *	Returns 0 for success, non-zero for failure.
  */
@@ -2284,6 +3112,7 @@
 {
 	MPT_FRAME_HDR *mf;
 	unsigned long b;
+	unsigned long flags;
 	dma_addr_t aligned_mem_dma;
 	u8 *mem, *aligned_mem;
 	int i, sz;
@@ -2299,8 +3128,8 @@
 		memset(mem, 0, sz);
 		ioc->alloc_total += sz;
 		ioc->reply_alloc = mem;
-		dprintk((KERN_INFO MYNAM ": %s.reply_alloc  @ %p[%08x], sz=%d bytes\n",
-			 ioc->name, mem, ioc->reply_alloc_dma, sz));
+		dprintk((KERN_INFO MYNAM ": %s.reply_alloc  @ %p[%p], sz=%d bytes\n",
+			 	ioc->name, mem, (void *)(ulong)ioc->reply_alloc_dma, sz));
 
 		b = (unsigned long) mem;
 		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
@@ -2308,15 +3137,20 @@
 		ioc->reply_frames = (MPT_FRAME_HDR *) aligned_mem;
 		ioc->reply_frames_dma =
 			(ioc->reply_alloc_dma + (aligned_mem - mem));
-		aligned_mem_dma = ioc->reply_frames_dma;
-		dprintk((KERN_INFO MYNAM ": %s.reply_frames @ %p[%08x]\n",
-			 ioc->name, aligned_mem, aligned_mem_dma));
-
-		for (i = 0; i < ioc->reply_depth; i++) {
-			/*  Write each address to the IOC!  */
-			CHIPREG_WRITE32(&ioc->chip->ReplyFifo, aligned_mem_dma);
-			aligned_mem_dma += ioc->reply_sz;
-		}
+
+		ioc->reply_frames_low_dma = (u32) (ioc->reply_frames_dma & 0xFFFFFFFF);
+	}
+
+	/* Post Reply frames to FIFO
+	 */
+	aligned_mem_dma = ioc->reply_frames_dma;
+	dprintk((KERN_INFO MYNAM ": %s.reply_frames @ %p[%p]\n",
+		 	ioc->name, ioc->reply_frames, (void *)(ulong)aligned_mem_dma));
+
+	for (i = 0; i < ioc->reply_depth; i++) {
+		/*  Write each address to the IOC!  */
+		CHIPREG_WRITE32(&ioc->chip->ReplyFifo, aligned_mem_dma);
+		aligned_mem_dma += ioc->reply_sz;
 	}
 
 
@@ -2336,8 +3170,8 @@
 		memset(mem, 0, sz);
 		ioc->alloc_total += sz;
 		ioc->req_alloc = mem;
-		dprintk((KERN_INFO MYNAM ": %s.req_alloc    @ %p[%08x], sz=%d bytes\n",
-			 ioc->name, mem, ioc->req_alloc_dma, sz));
+		dprintk((KERN_INFO MYNAM ": %s.req_alloc    @ %p[%p], sz=%d bytes\n",
+			 	ioc->name, mem, (void *)(ulong)ioc->req_alloc_dma, sz));
 
 		b = (unsigned long) mem;
 		b = (b + (0x80UL - 1UL)) & ~(0x80UL - 1UL); /* round up to 128-byte boundary */
@@ -2345,18 +3179,18 @@
 		ioc->req_frames = (MPT_FRAME_HDR *) aligned_mem;
 		ioc->req_frames_dma =
 			(ioc->req_alloc_dma + (aligned_mem - mem));
-		aligned_mem_dma = ioc->req_frames_dma;
 
-		dprintk((KERN_INFO MYNAM ": %s.req_frames   @ %p[%08x]\n",
-			 ioc->name, aligned_mem, aligned_mem_dma));
+		ioc->req_frames_low_dma = (u32) (ioc->req_frames_dma & 0xFFFFFFFF);
 
-		for (i = 0; i < ioc->req_depth; i++) {
-			mf = (MPT_FRAME_HDR *) aligned_mem;
-
-			/*  Queue REQUESTs *internally*!  */
-			Q_ADD_TAIL(&ioc->FreeQ.head, &mf->u.frame.linkage, MPT_FRAME_HDR);
-			aligned_mem += ioc->req_sz;
+#ifdef __ia64__
+		/* Check: upper 32-bits of the request and reply frame
+		 * physical addresses must be the same.
+		 * ia64 check only
+		 */
+		if ((ioc->req_frames_dma >> 32) != (ioc->reply_frames_dma >> 32)){
+			goto out_fail;
 		}
+#endif
 
 #if defined(CONFIG_MTRR) && 0
 		/*
@@ -2367,20 +3201,38 @@
 		ioc->mtrr_reg = mtrr_add(ioc->req_alloc_dma,
 					 sz,
 					 MTRR_TYPE_WRCOMB, 1);
-		dprintk((KERN_INFO MYNAM ": %s: MTRR region registered (base:size=%08x:%x)\n",
-				ioc->name, ioc->req_alloc_dma,
-				sz ));
+		dprintk((MYIOC_s_INFO_FMT "MTRR region registered (base:size=%08x:%x)\n",
+				ioc->name, ioc->req_alloc_dma, sz));
 #endif
+	}
+
+	/* Initialize Request frames linked list
+	 */
+	aligned_mem_dma = ioc->req_frames_dma;
+	aligned_mem = (u8 *) ioc->req_frames;
+	dprintk((KERN_INFO MYNAM ": %s.req_frames   @ %p[%p]\n",
+		 	ioc->name, aligned_mem, (void *)(ulong)aligned_mem_dma));
 
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	Q_INIT(&ioc->FreeQ, MPT_FRAME_HDR);
+	for (i = 0; i < ioc->req_depth; i++) {
+		mf = (MPT_FRAME_HDR *) aligned_mem;
+
+		/*  Queue REQUESTs *internally*!  */
+		Q_ADD_TAIL(&ioc->FreeQ.head, &mf->u.frame.linkage, MPT_FRAME_HDR);
+		aligned_mem += ioc->req_sz;
 	}
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
 
 	if (ioc->sense_buf_pool == NULL) {
-		sz = (ioc->req_depth * 256);
+		sz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);
 		ioc->sense_buf_pool =
 				pci_alloc_consistent(ioc->pcidev, sz, &ioc->sense_buf_pool_dma);
 		if (ioc->sense_buf_pool == NULL)
 			goto out_fail;
 
+		ioc->sense_buf_low_dma = (u32) (ioc->sense_buf_pool_dma & 0xFFFFFFFF);
 		ioc->alloc_total += sz;
 	}
 
@@ -2408,7 +3260,7 @@
 #if defined(CONFIG_MTRR) && 0
 		if (ioc->mtrr_reg > 0) {
 			mtrr_del(ioc->mtrr_reg, 0, 0);
-			dprintk((KERN_INFO MYNAM ": %s: MTRR region de-registered\n",
+			dprintk((MYIOC_s_INFO_FMT "MTRR region de-registered\n",
 					ioc->name));
 		}
 #endif
@@ -2417,7 +3269,7 @@
 		ioc->alloc_total -= sz;
 	}
 	if (ioc->sense_buf_pool != NULL) {
-		sz = (ioc->req_depth * 256);
+		sz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);
 		pci_free_consistent(ioc->pcidev,
 				sz,
 				ioc->sense_buf_pool, ioc->sense_buf_pool_dma);
@@ -2427,8 +3279,8 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	HandShakeReqAndReply - Send MPT request to and receive reply from
+/**
+ *	mpt_handshake_req_reply_wait - Send MPT request to and receive reply from
  *	IOC via doorbell handshake method.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@reqBytes: Size of the request in bytes
@@ -2436,6 +3288,7 @@
  *	@replyBytes: Expected size of the reply in bytes
  *	@u16reply: Pointer to area where reply should be written
  *	@maxwait: Max wait time for a reply (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	NOTES: It is the callers responsibility to byte-swap fields in the
  *	request which are greater than 1 byte in size.  It is also the
@@ -2444,8 +3297,9 @@
  *
  *	Returns 0 for success, non-zero for failure.
  */
-static int
-HandShakeReqAndReply(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait)
+int
+mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req,
+				int replyBytes, u16 *u16reply, int maxwait, int sleepFlag)
 {
 	MPIDefaultReply_t *mptReply;
 	int failcnt = 0;
@@ -2471,57 +3325,61 @@
 	/*
 	 * Wait for IOC's doorbell handshake int
 	 */
-	if ((t = WaitForDoorbellInt(ioc, 2)) < 0)
+	if ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)
 		failcnt++;
 
-	dhsprintk((KERN_INFO MYNAM ": %s: HandShake request start, WaitCnt=%d%s\n",
+	dhsprintk((MYIOC_s_INFO_FMT "HandShake request start, WaitCnt=%d%s\n",
 			ioc->name, t, failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));
 
+	/* Read doorbell and check for active bit */
+	if (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
+			return -1;
+
 	/*
 	 * Clear doorbell int (WRITE 0 to IntStatus reg),
 	 * then wait for IOC to ACKnowledge that it's ready for
 	 * our handshake request.
 	 */
 	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
-	if (!failcnt && (t = WaitForDoorbellAck(ioc, 2)) < 0)
+	if (!failcnt && (t = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
 		failcnt++;
 
 	if (!failcnt) {
-		int	 i;
+		int	 ii;
 		u8	*req_as_bytes = (u8 *) req;
 
 		/*
 		 * Stuff request words via doorbell handshake,
 		 * with ACK from IOC for each.
 		 */
-		for (i = 0; !failcnt && i < reqBytes/4; i++) {
-			u32 word = ((req_as_bytes[(i*4) + 0] <<  0) |
-				    (req_as_bytes[(i*4) + 1] <<  8) |
-				    (req_as_bytes[(i*4) + 2] << 16) |
-				    (req_as_bytes[(i*4) + 3] << 24));
+		for (ii = 0; !failcnt && ii < reqBytes/4; ii++) {
+			u32 word = ((req_as_bytes[(ii*4) + 0] <<  0) |
+				    (req_as_bytes[(ii*4) + 1] <<  8) |
+				    (req_as_bytes[(ii*4) + 2] << 16) |
+				    (req_as_bytes[(ii*4) + 3] << 24));
 
 			CHIPREG_WRITE32(&ioc->chip->Doorbell, word);
-			if ((t = WaitForDoorbellAck(ioc, 2)) < 0)
+			if ((t = WaitForDoorbellAck(ioc, 2, sleepFlag)) < 0)
 				failcnt++;
 		}
 
 		dmfprintk((KERN_INFO MYNAM ": Handshake request frame (@%p) header\n", req));
 		DBG_DUMP_REQUEST_FRAME_HDR(req)
 
-		dhsprintk((KERN_INFO MYNAM ": %s: HandShake request post done, WaitCnt=%d%s\n",
+		dhsprintk((MYIOC_s_INFO_FMT "HandShake request post done, WaitCnt=%d%s\n",
 				ioc->name, t, failcnt ? " - MISSING DOORBELL ACK!" : ""));
 
 		/*
 		 * Wait for completion of doorbell handshake reply from the IOC
 		 */
-		if (!failcnt && (t = WaitForDoorbellReply(ioc, maxwait)) < 0)
+		if (!failcnt && (t = WaitForDoorbellReply(ioc, maxwait, sleepFlag)) < 0)
 			failcnt++;
 
 		/*
 		 * Copy out the cached reply...
 		 */
-		for(i=0; i < MIN(replyBytes/2,mptReply->MsgLength*2); i++)
-			u16reply[i] = ioc->hs_reply[i];
+		for (ii=0; ii < MIN(replyBytes/2,mptReply->MsgLength*2); ii++)
+			u16reply[ii] = ioc->hs_reply[ii];
 	} else {
 		return -99;
 	}
@@ -2535,6 +3393,7 @@
  *	in it's IntStatus register.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@howlong: How long to wait (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine waits (up to ~2 seconds max) for IOC doorbell
  *	handshake ACKnowledge.
@@ -2542,28 +3401,40 @@
  *	Returns a negative value on failure, else wait loop count.
  */
 static int
-WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong)
+WaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
 	int cntdn = HZ * howlong;
 	int count = 0;
 	u32 intstat;
 
-	while (--cntdn) {
-		intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
-		if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
-			break;
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
-		count++;
+	if (sleepFlag == CAN_SLEEP) {
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
+				break;
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+			count++;
+		}
+	} else {
+		cntdn *= 10; /* convert to msec */
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))
+				break;
+			mdelay (1);
+			count++;
+		}
+		count /= 10;
 	}
 
 	if (cntdn) {
-		dhsprintk((KERN_INFO MYNAM ": %s: WaitForDoorbell ACK (cnt=%d)\n",
+		dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell ACK (cnt=%d)\n",
 				ioc->name, count));
 		return count;
 	}
 
-	printk(KERN_ERR MYNAM ": %s: ERROR - Doorbell ACK timeout(%d)!\n",
+	printk(MYIOC_s_ERR_FMT "Doorbell ACK timeout(%d)!\n",
 			ioc->name, (count+5)/HZ);
 	return -1;
 }
@@ -2574,34 +3445,47 @@
  *	in it's IntStatus register.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@howlong: How long to wait (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine waits (up to ~2 seconds max) for IOC doorbell interrupt.
  *
  *	Returns a negative value on failure, else wait loop count.
  */
 static int
-WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong)
+WaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
 	int cntdn = HZ * howlong;
 	int count = 0;
 	u32 intstat;
 
-	while (--cntdn) {
-		intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
-		if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
-			break;
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
-		count++;
+	if (sleepFlag == CAN_SLEEP) {
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
+				break;
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+			count++;
+		}
+	} else {
+		cntdn *= 10; /* convert to msec */
+		while (--cntdn) {
+			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+			if (intstat & MPI_HIS_DOORBELL_INTERRUPT)
+				break;
+			mdelay(1);
+			count++;
+		}
+		count /= 10;
 	}
 
 	if (cntdn) {
-		dhsprintk((KERN_INFO MYNAM ": %s: WaitForDoorbell INT (cnt=%d)\n",
+		dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell INT (cnt=%d)\n",
 				ioc->name, count));
 		return count;
 	}
 
-	printk(KERN_ERR MYNAM ": %s: ERROR - Doorbell INT timeout(%d)!\n",
+	printk(MYIOC_s_ERR_FMT "Doorbell INT timeout(%d)!\n",
 			ioc->name, (count+5)/HZ);
 	return -1;
 }
@@ -2611,6 +3495,7 @@
  *	WaitForDoorbellReply - Wait for and capture a IOC handshake reply.
  *	@ioc: Pointer to MPT_ADAPTER structure
  *	@howlong: How long to wait (in seconds)
+ *	@sleepFlag: Specifies whether the process can sleep
  *
  *	This routine polls the IOC for a handshake reply, 16 bits at a time.
  *	Reply is cached to IOC private area large enough to hold a maximum
@@ -2619,13 +3504,13 @@
  *	Returns a negative value on failure, else size of reply in WORDS.
  */
 static int
-WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong)
+WaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag)
 {
 	int u16cnt = 0;
 	int failcnt = 0;
 	int t;
 	u16 *hs_reply = ioc->hs_reply;
- 	volatile MPIDefaultReply_t *mptReply = (MPIDefaultReply_t *) ioc->hs_reply;
+	volatile MPIDefaultReply_t *mptReply = (MPIDefaultReply_t *) ioc->hs_reply;
 	u16 hword;
 
 	hs_reply[0] = hs_reply[1] = hs_reply[7] = 0;
@@ -2634,12 +3519,12 @@
 	 * Get first two u16's so we can look at IOC's intended reply MsgLength
 	 */
 	u16cnt=0;
-	if ((t = WaitForDoorbellInt(ioc, howlong)) < 0) {
+	if ((t = WaitForDoorbellInt(ioc, howlong, sleepFlag)) < 0) {
 		failcnt++;
 	} else {
 		hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
 		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
-		if ((t = WaitForDoorbellInt(ioc, 2)) < 0)
+		if ((t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
 			failcnt++;
 		else {
 			hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
@@ -2647,7 +3532,7 @@
 		}
 	}
 
-	dhsprintk((KERN_INFO MYNAM ": %s: First handshake reply word=%08x%s\n",
+	dhsprintk((MYIOC_s_INFO_FMT "First handshake reply word=%08x%s\n",
 			ioc->name, le32_to_cpu(*(u32 *)hs_reply),
 			failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));
 
@@ -2656,7 +3541,7 @@
 	 * reply 16 bits at a time.
 	 */
 	for (u16cnt=2; !failcnt && u16cnt < (2 * mptReply->MsgLength); u16cnt++) {
-		if ((t = WaitForDoorbellInt(ioc, 2)) < 0)
+		if ((t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
 			failcnt++;
 		hword = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
 		/* don't overflow our IOC hs_reply[] buffer! */
@@ -2665,12 +3550,12 @@
 		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 	}
 
-	if (!failcnt && (t = WaitForDoorbellInt(ioc, 2)) < 0)
+	if (!failcnt && (t = WaitForDoorbellInt(ioc, 2, sleepFlag)) < 0)
 		failcnt++;
 	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
 
 	if (failcnt) {
-		printk(KERN_ERR MYNAM ": %s: ERROR - Handshake reply failure!\n",
+		printk(MYIOC_s_ERR_FMT "Handshake reply failure!\n",
 				ioc->name);
 		return -failcnt;
 	}
@@ -2681,130 +3566,631 @@
 	else if ((mptReply->IOCStatus & MPI_IOCSTATUS_MASK) != MPI_IOCSTATUS_SUCCESS) {
 		return -102;
 	}
-#endif
+#endif
+
+	dmfprintk((MYIOC_s_INFO_FMT "Got Handshake reply:\n", ioc->name));
+	DBG_DUMP_REPLY_FRAME(mptReply)
+
+	dhsprintk((MYIOC_s_INFO_FMT "WaitForDoorbell REPLY (sz=%d)\n",
+			ioc->name, u16cnt/2));
+	return u16cnt/2;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetLanConfigPages - Fetch LANConfig pages.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetLanConfigPages(MPT_ADAPTER *ioc)
+{
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	LANPage0_t		*ppage0_alloc;
+	dma_addr_t		 page0_dma;
+	LANPage1_t		*ppage1_alloc;
+	dma_addr_t		 page1_dma;
+	int			 rc = 0;
+	int			 data_sz;
+	int			 copy_sz;
+
+	/* Get LAN Page 0 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength > 0) {
+		data_sz = hdr.PageLength * 4;
+		ppage0_alloc = (LANPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
+		rc = -ENOMEM;
+		if (ppage0_alloc) {
+			memset((u8 *)ppage0_alloc, 0, data_sz);
+			cfg.physAddr = page0_dma;
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+			if ((rc = mpt_config(ioc, &cfg)) == 0) {
+				/* save the data */
+				copy_sz = MIN(sizeof(LANPage0_t), data_sz);
+				memcpy(&ioc->lan_cnfg_page0, ppage0_alloc, copy_sz);
+
+			}
+
+			pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
+
+			/* FIXME!
+			 *	Normalize endianness of structure data,
+			 *	by byte-swapping all > 1 byte fields!
+			 */
+
+		}
+
+		if (rc)
+			return rc;
+	}
+
+	/* Get LAN Page 1 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 1;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_LAN;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage1_alloc = (LANPage1_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page1_dma);
+	if (ppage1_alloc) {
+		memset((u8 *)ppage1_alloc, 0, data_sz);
+		cfg.physAddr = page1_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		if ((rc = mpt_config(ioc, &cfg)) == 0) {
+			/* save the data */
+			copy_sz = MIN(sizeof(LANPage1_t), data_sz);
+			memcpy(&ioc->lan_cnfg_page1, ppage1_alloc, copy_sz);
+		}
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage1_alloc, page1_dma);
+
+		/* FIXME!
+		 *	Normalize endianness of structure data,
+		 *	by byte-swapping all > 1 byte fields!
+		 */
+
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetFcPortPage0 - Fetch FCPort config Page0.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@portnum: IOC Port number
+ *
+ *	Return: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetFcPortPage0(MPT_ADAPTER *ioc, int portnum)
+{
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	FCPortPage0_t		*ppage0_alloc;
+	FCPortPage0_t		*pp0dest;
+	dma_addr_t		 page0_dma;
+	int			 data_sz;
+	int			 copy_sz;
+	int			 rc;
+
+	/* Get FCPort Page 0 header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = portnum;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage0_alloc = (FCPortPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);
+	if (ppage0_alloc) {
+		memset((u8 *)ppage0_alloc, 0, data_sz);
+		cfg.physAddr = page0_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		if ((rc = mpt_config(ioc, &cfg)) == 0) {
+			/* save the data */
+			pp0dest = &ioc->fc_port_page0[portnum];
+			copy_sz = MIN(sizeof(FCPortPage0_t), data_sz);
+			memcpy(pp0dest, ppage0_alloc, copy_sz);
+
+			/*
+			 *	Normalize endianness of structure data,
+			 *	by byte-swapping all > 1 byte fields!
+			 */
+			pp0dest->Flags = le32_to_cpu(pp0dest->Flags);
+			pp0dest->PortIdentifier = le32_to_cpu(pp0dest->PortIdentifier);
+			pp0dest->WWNN.Low = le32_to_cpu(pp0dest->WWNN.Low);
+			pp0dest->WWNN.High = le32_to_cpu(pp0dest->WWNN.High);
+			pp0dest->WWPN.Low = le32_to_cpu(pp0dest->WWPN.Low);
+			pp0dest->WWPN.High = le32_to_cpu(pp0dest->WWPN.High);
+			pp0dest->SupportedServiceClass = le32_to_cpu(pp0dest->SupportedServiceClass);
+			pp0dest->SupportedSpeeds = le32_to_cpu(pp0dest->SupportedSpeeds);
+			pp0dest->CurrentSpeed = le32_to_cpu(pp0dest->CurrentSpeed);
+			pp0dest->MaxFrameSize = le32_to_cpu(pp0dest->MaxFrameSize);
+			pp0dest->FabricWWNN.Low = le32_to_cpu(pp0dest->FabricWWNN.Low);
+			pp0dest->FabricWWNN.High = le32_to_cpu(pp0dest->FabricWWNN.High);
+			pp0dest->FabricWWPN.Low = le32_to_cpu(pp0dest->FabricWWPN.Low);
+			pp0dest->FabricWWPN.High = le32_to_cpu(pp0dest->FabricWWPN.High);
+			pp0dest->DiscoveredPortsCount = le32_to_cpu(pp0dest->DiscoveredPortsCount);
+			pp0dest->MaxInitiators = le32_to_cpu(pp0dest->MaxInitiators);
+
+		}
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	GetIoUnitPage2 - Retrieve BIOS version and boot order information.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *
+ *	Returns: 0 for success
+ *	-ENOMEM if no memory available
+ *		-EPERM if not allowed due to ISR context
+ *		-EAGAIN if no msg frames currently available
+ *		-EFAULT for non-successful reply or no reply (timeout)
+ */
+static int
+GetIoUnitPage2(MPT_ADAPTER *ioc)
+{
+	ConfigPageHeader_t	 hdr;
+	CONFIGPARMS		 cfg;
+	IOUnitPage2_t		*ppage_alloc;
+	dma_addr_t		 page_dma;
+	int			 data_sz;
+	int			 rc;
+
+	/* Get the page header */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 2;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_IO_UNIT;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.pageAddr = 0;
+	cfg.timeout = 0;
+
+	if ((rc = mpt_config(ioc, &cfg)) != 0)
+		return rc;
+
+	if (hdr.PageLength == 0)
+		return 0;
+
+	/* Read the config page */
+	data_sz = hdr.PageLength * 4;
+	rc = -ENOMEM;
+	ppage_alloc = (IOUnitPage2_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);
+	if (ppage_alloc) {
+		memset((u8 *)ppage_alloc, 0, data_sz);
+		cfg.physAddr = page_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+		/* If Good, save data */
+		if ((rc = mpt_config(ioc, &cfg)) == 0)
+			ioc->biosVersion = le32_to_cpu(ppage_alloc->BiosVersion);
+
+		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage_alloc, page_dma);
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mpt_GetScsiPortSettings - read SCSI Port Page 0 and 2
+ *	@ioc: Pointer to a Adapter Strucutre
+ *	@portnum: IOC port number
+ *
+ *	Return: -EFAULT if read of config page header fails
+ *			or if no nvram
+ *	If read of SCSI Port Page 0 fails,
+ *		NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)
+ *		Adapter settings: async, narrow
+ *		Return 1
+ *	If read of SCSI Port Page 2 fails,
+ *		Adapter settings valid
+ *		NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)
+ *		Return 1
+ *	Else
+ *		Both valid
+ *		Return 0
+ *	CHECK - what type of locking mechanisms should be used????
+ */
+static int
+mpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum)
+{
+	u8			*pbuf = NULL;
+	dma_addr_t		 buf_dma;
+	CONFIGPARMS		 cfg;
+	ConfigPageHeader_t	 header;
+	int			 ii;
+	int			 data, rc = 0;
+
+	/* Allocate memory 
+	 */
+	if (!ioc->spi_data.nvram) {
+		int	 sz;
+		u8	*mem;
+		sz = MPT_MAX_SCSI_DEVICES * sizeof(int);
+		mem = kmalloc(sz, GFP_KERNEL);
+		if (mem == NULL)
+			return -EFAULT;
+
+		ioc->spi_data.nvram = (int *) mem;
+
+		dprintk((MYIOC_s_INFO_FMT "SCSI device NVRAM settings @ %p, sz=%d\n",
+			ioc->name, ioc->spi_data.nvram, sz));
+	}
+
+	/* Invalidate NVRAM information
+	 */
+	for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+		ioc->spi_data.nvram[ii] = MPT_HOST_NVRAM_INVALID;
+	}
+
+	/* Read SPP0 header, allocate memory, then read page.
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 0;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = portnum;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;	/* use default */
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
+
+	if (header.PageLength > 0) {
+		pbuf = pci_alloc_consistent(ioc->pcidev, header.PageLength * 4, &buf_dma);
+		if (pbuf) {
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+			cfg.physAddr = buf_dma;
+			if (mpt_config(ioc, &cfg) != 0) {
+				ioc->spi_data.maxBusWidth = MPT_NARROW;
+				ioc->spi_data.maxSyncOffset = 0;
+				ioc->spi_data.minSyncFactor = MPT_ASYNC;
+				ioc->spi_data.busType = MPT_HOST_BUS_UNKNOWN;
+				rc = 1;
+			} else {
+				/* Save the Port Page 0 data
+				 */
+				SCSIPortPage0_t  *pPP0 = (SCSIPortPage0_t  *) pbuf;
+				pPP0->Capabilities = le32_to_cpu(pPP0->Capabilities);
+				pPP0->PhysicalInterface = le32_to_cpu(pPP0->PhysicalInterface);
+
+				ioc->spi_data.maxBusWidth = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_WIDE ? 1 : 0;
+				data = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK;
+				if (data) {
+					ioc->spi_data.maxSyncOffset = (u8) (data >> 16);
+					data = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
+					ioc->spi_data.minSyncFactor = (u8) (data >> 8);
+				} else {
+					ioc->spi_data.maxSyncOffset = 0;
+					ioc->spi_data.minSyncFactor = MPT_ASYNC;
+				}
+
+				ioc->spi_data.busType = pPP0->PhysicalInterface & MPI_SCSIPORTPAGE0_PHY_SIGNAL_TYPE_MASK;
+
+				/* Update the minSyncFactor based on bus type.
+				 */
+				if ((ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_HVD) ||
+					(ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_SE))  {
+
+					if (ioc->spi_data.minSyncFactor < MPT_ULTRA)
+						ioc->spi_data.minSyncFactor = MPT_ULTRA;
+				}
+			}
+			if (pbuf) {
+				pci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);
+				pbuf = NULL;
+			}
+		}
+	}
+
+	/* SCSI Port Page 2 - Read the header then the page.
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 2;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = portnum;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	if (mpt_config(ioc, &cfg) != 0)
+		return -EFAULT;
+
+	if (header.PageLength > 0) {
+		/* Allocate memory and read SCSI Port Page 2
+		 */
+		pbuf = pci_alloc_consistent(ioc->pcidev, header.PageLength * 4, &buf_dma);
+		if (pbuf) {
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_NVRAM;
+			cfg.physAddr = buf_dma;
+			if (mpt_config(ioc, &cfg) != 0) {
+				/* Nvram data is left with INVALID mark
+				 */
+				rc = 1;
+			} else {
+				SCSIPortPage2_t *pPP2 = (SCSIPortPage2_t  *) pbuf;
+				MpiDeviceInfo_t	*pdevice = NULL;
+
+				/* Save the Port Page 2 data
+				 * (reformat into a 32bit quantity)
+				 */
+				for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+					pdevice = &pPP2->DeviceSettings[ii];
+					data = (le16_to_cpu(pdevice->DeviceFlags) << 16) |
+						(pdevice->SyncFactor << 8) | pdevice->Timeout;
+					ioc->spi_data.nvram[ii] = data;
+				}
+			}
+
+			pci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);
+			pbuf = NULL;
+		}
+	}
 
-	dmfprintk((KERN_INFO MYNAM ": %s: Got Handshake reply:\n", ioc->name));
-	DBG_DUMP_REPLY_FRAME(mptReply)
+	/* Update Adapter limits with those from NVRAM
+	 * Comment: Don't need to do this. Target performance
+	 * parameters will never exceed the adapters limits.
+	 */
 
-	dhsprintk((KERN_INFO MYNAM ": %s: WaitForDoorbell REPLY (sz=%d)\n",
-			ioc->name, u16cnt/2));
-	return u16cnt/2;
+	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	GetLanConfigPages - Fetch LANConfig pages.
- *	@ioc: Pointer to MPT_ADAPTER structure
+/*	mpt_readScsiDevicePageHeaders - save version and length of SDP1
+ *	@ioc: Pointer to a Adapter Strucutre
+ *	@portnum: IOC port number
  *
- *	Returns 0 for success, non-zero for failure.
+ *	Return: -EFAULT if read of config page header fails
+ *		or 0 if success.
  */
 static int
-GetLanConfigPages(MPT_ADAPTER *ioc)
+mpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum)
 {
-	Config_t		 config_req;
-	ConfigReply_t		 config_reply;
-	LANPage0_t		*page0;
-	dma_addr_t		 page0_dma;
-	LANPage1_t		*page1;
-	dma_addr_t		 page1_dma;
-	int			 i;
-	int			 req_sz;
-	int			 reply_sz;
-	int			 data_sz;
+	CONFIGPARMS		 cfg;
+	ConfigPageHeader_t	 header;
 
-/* LANPage0 */
-	/*  Immediate destination (reply area)...  */
-	reply_sz = sizeof(config_reply);
-	memset(&config_reply, 0, reply_sz);
-
-	/*  Ultimate destination...  */
-	page0 = &ioc->lan_cnfg_page0;
-	data_sz = sizeof(*page0);
-	memset(page0, 0, data_sz);
-
-	/*  Request area (config_req on the stack right now!)  */
-	req_sz = sizeof(config_req);
-	memset(&config_req, 0, req_sz);
-	config_req.Function = MPI_FUNCTION_CONFIG;
-	config_req.Action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
-	/*	config_req.Header.PageVersion = 0;	*/
-	/*	config_req.Header.PageLength = 0;	*/
-	config_req.Header.PageNumber = 0;
-	config_req.Header.PageType = MPI_CONFIG_PAGETYPE_LAN;
-	/*	config_req.PageAddress = 0;		*/
-	config_req.PageBufferSGE.u.Simple.FlagsLength = cpu_to_le32(
-			((MPI_SGE_FLAGS_LAST_ELEMENT |
-			  MPI_SGE_FLAGS_END_OF_BUFFER |
-			  MPI_SGE_FLAGS_END_OF_LIST |
-			  MPI_SGE_FLAGS_SIMPLE_ELEMENT |
-			  MPI_SGE_FLAGS_SYSTEM_ADDRESS |
-			  MPI_SGE_FLAGS_32_BIT_ADDRESSING |
-			  MPI_SGE_FLAGS_32_BIT_CONTEXT) << MPI_SGE_FLAGS_SHIFT) |
-			(u32)data_sz
-	);
-	page0_dma = pci_map_single(ioc->pcidev, page0, data_sz, PCI_DMA_FROMDEVICE);
-	config_req.PageBufferSGE.u.Simple.u.Address32 = cpu_to_le32(page0_dma);
+	/* Read the SCSI Device Page 1 header
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 1;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = portnum;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
+
+	ioc->spi_data.sdp1version = cfg.hdr->PageVersion;
+	ioc->spi_data.sdp1length = cfg.hdr->PageLength;
+
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 0;
+	header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending Config request LAN_PAGE_0\n",
-			ioc->name));
+	ioc->spi_data.sdp0version = cfg.hdr->PageVersion;
+	ioc->spi_data.sdp0length = cfg.hdr->PageLength;
 
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&config_req,
-				reply_sz, (u16*)&config_reply, 3);
-	pci_unmap_single(ioc->pcidev, page0_dma, data_sz, PCI_DMA_FROMDEVICE);
-	if (i != 0)
-		return i;
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mpt_findImVolumes - Identify IDs of hidden disks and RAID Volumes 
+ *	@ioc: Pointer to a Adapter Strucutre
+ *	@portnum: IOC port number
+ *
+ *	Return:
+ *	0 on success
+ *	-EFAULT if read of config page header fails or data pointer not NULL
+ *	-ENOMEM if pci_alloc failed
+ */
+static int
+mpt_findImVolumes(MPT_ADAPTER *ioc)
+{
+	IOCPage2_t		*pIoc2 = NULL;
+	IOCPage3_t		*pIoc3 = NULL;
+	ConfigPageIoc2RaidVol_t	*pIocRv = NULL;
+	u8			*mem;
+	dma_addr_t		 ioc2_dma;
+	dma_addr_t		 ioc3_dma;
+	CONFIGPARMS		 cfg;
+	ConfigPageHeader_t	 header;
+	int			 jj;
+	int			 rc = 0;
+	int			 iocpage2sz;
+	int			 iocpage3sz = 0;
+	u8			 nVols, nPhys;
+	u8			 vid, vbus, vioc;
+
+	if (ioc->spi_data.pIocPg3)
+		return -EFAULT;	
+
+	/* Read IOCP2 header then the page.
+	 */
+	header.PageVersion = 0;
+	header.PageLength = 0;
+	header.PageNumber = 2;
+	header.PageType = MPI_CONFIG_PAGETYPE_IOC;
+	cfg.hdr = &header;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;
+	cfg.timeout = 0;
+	if (mpt_config(ioc, &cfg) != 0)
+		 return -EFAULT;
+
+	if (header.PageLength == 0)
+		return -EFAULT;
+
+	iocpage2sz = header.PageLength * 4;
+	pIoc2 = pci_alloc_consistent(ioc->pcidev, iocpage2sz, &ioc2_dma);
+	if (!pIoc2)
+		return -ENOMEM;
+
+	cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+	cfg.physAddr = ioc2_dma;
+	if (mpt_config(ioc, &cfg) != 0)
+		goto done_and_free;
+
+	/* Identify RAID Volume Id's */
+	nVols = pIoc2->NumActiveVolumes;
+	if ( nVols == 0) {
+		/* No RAID Volumes.  Done.
+		 */
+	} else {
+		/* At least 1 RAID Volume
+		 */
+		pIocRv = pIoc2->RaidVolume;
+		ioc->spi_data.isRaid = 0;
+		for (jj = 0; jj < nVols; jj++, pIocRv++) {
+			vid = pIocRv->VolumeID;
+			vbus = pIocRv->VolumeBus;
+			vioc = pIocRv->VolumeIOC;
+
+			/* find the match
+			 */
+			if (vbus == 0) {
+				ioc->spi_data.isRaid |= (1 << vid);
+			} else {
+				/* Error! Always bus 0
+				 */
+			}
+		}
+	}
 
-	/*  Now byte swap the necessary LANPage0 fields  */
+	/* Identify Hidden Physical Disk Id's */
+	nPhys = pIoc2->NumActivePhysDisks;
+	if (nPhys == 0) {
+		/* No physical disks. Done.
+		 */
+	} else {
+		/* There is at least one physical disk.
+		 * Read and save IOC Page 3
+		 */
+		header.PageVersion = 0;
+		header.PageLength = 0;
+		header.PageNumber = 3;
+		header.PageType = MPI_CONFIG_PAGETYPE_IOC;
+		cfg.hdr = &header;
+		cfg.physAddr = -1;
+		cfg.pageAddr = 0;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+		cfg.dir = 0;
+		cfg.timeout = 0;
+		if (mpt_config(ioc, &cfg) != 0)
+			goto done_and_free;
 
-/* LANPage1 */
-	/*  Immediate destination (reply area)...  */
-	reply_sz = sizeof(config_reply);
-	memset(&config_reply, 0, reply_sz);
-
-	/*  Ultimate destination...  */
-	page1 = &ioc->lan_cnfg_page1;
-	data_sz = sizeof(*page1);
-	memset(page1, 0, data_sz);
-
-	/*  Request area (config_req on the stack right now!)  */
-	req_sz = sizeof(config_req);
-	memset(&config_req, 0, req_sz);
-	config_req.Function = MPI_FUNCTION_CONFIG;
-	config_req.Action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
-	/*	config_req.Header.PageVersion = 0;	*/
-	/*	config_req.Header.PageLength = 0;	*/
-	config_req.Header.PageNumber = 1;
-	config_req.Header.PageType = MPI_CONFIG_PAGETYPE_LAN;
-	/*	config_req.PageAddress = 0;		*/
-	config_req.PageBufferSGE.u.Simple.FlagsLength = cpu_to_le32(
-			((MPI_SGE_FLAGS_LAST_ELEMENT |
-			  MPI_SGE_FLAGS_END_OF_BUFFER |
-			  MPI_SGE_FLAGS_END_OF_LIST |
-			  MPI_SGE_FLAGS_SIMPLE_ELEMENT |
-			  MPI_SGE_FLAGS_SYSTEM_ADDRESS |
-			  MPI_SGE_FLAGS_32_BIT_ADDRESSING |
-			  MPI_SGE_FLAGS_32_BIT_CONTEXT) << MPI_SGE_FLAGS_SHIFT) |
-			(u32)data_sz
-	);
-	page1_dma = pci_map_single(ioc->pcidev, page1, data_sz, PCI_DMA_FROMDEVICE);
-	config_req.PageBufferSGE.u.Simple.u.Address32 = cpu_to_le32(page1_dma);
+		if (header.PageLength == 0)
+			goto done_and_free;
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending Config request LAN_PAGE_1\n",
-			ioc->name));
+		/* Read Header good, alloc memory
+		 */
+		iocpage3sz = header.PageLength * 4;
+		pIoc3 = pci_alloc_consistent(ioc->pcidev, iocpage3sz, &ioc3_dma);
+		if (!pIoc3)
+			goto done_and_free;
 
-	i = HandShakeReqAndReply(ioc, req_sz, (u32*)&config_req,
-				reply_sz, (u16*)&config_reply, 3);
-	pci_unmap_single(ioc->pcidev, page1_dma, data_sz, PCI_DMA_FROMDEVICE);
-	if (i != 0)
-		return i;
+		/* Read the Page and save the data
+		 * into malloc'd memory.
+		 */
+		cfg.physAddr = ioc3_dma;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+		if (mpt_config(ioc, &cfg) == 0) {
+			mem = kmalloc(iocpage3sz, GFP_KERNEL);
+			if (mem) {
+				memcpy(mem, (u8 *)pIoc3, iocpage3sz);
+				ioc->spi_data.pIocPg3 = (IOCPage3_t *) mem;
+			}
+		}
+	}
 
-	/*  Now byte swap the necessary LANPage1 fields  */
+done_and_free:
+	if (pIoc2) {
+		pci_free_consistent(ioc->pcidev, iocpage2sz, pIoc2, ioc2_dma);
+		pIoc2 = NULL;
+	}
 
-	return 0;
+	if (pIoc3) {
+		pci_free_consistent(ioc->pcidev, iocpage3sz, pIoc3, ioc3_dma);
+		pIoc3 = NULL;
+	}
+
+	return rc;
 }
 
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	SendEventNotification - Send EventNotification (on or off) request
  *	to MPT adapter.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -2817,13 +4203,13 @@
 
 	evnp = (EventNotification_t *) mpt_get_msg_frame(mpt_base_index, ioc->id);
 	if (evnp == NULL) {
-		dprintk((KERN_WARNING MYNAM ": %s: WARNING - Unable to allocate a event request frame!\n",
+		dprintk((MYIOC_s_WARN_FMT "Unable to allocate event request frame!\n",
 				ioc->name));
 		return 0;
 	}
 	memset(evnp, 0, sizeof(*evnp));
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending EventNotification(%d)\n", ioc->name, EvSwitch));
+	dprintk((MYIOC_s_INFO_FMT "Sending EventNotification(%d)\n", ioc->name, EvSwitch));
 
 	evnp->Function = MPI_FUNCTION_EVENT_NOTIFICATION;
 	evnp->ChainOffset = 0;
@@ -2847,13 +4233,13 @@
 	EventAck_t	*pAck;
 
 	if ((pAck = (EventAck_t *) mpt_get_msg_frame(mpt_base_index, ioc->id)) == NULL) {
-		printk(KERN_WARNING MYNAM ": %s: WARNING - Unable to allocate event ACK request frame!\n",
+		printk(MYIOC_s_WARN_FMT "Unable to allocate event ACK request frame!\n",
 				ioc->name);
 		return -1;
 	}
 	memset(pAck, 0, sizeof(*pAck));
 
-	dprintk((KERN_INFO MYNAM ": %s: Sending EventAck\n", ioc->name));
+	dprintk((MYIOC_s_INFO_FMT "Sending EventAck\n", ioc->name));
 
 	pAck->Function     = MPI_FUNCTION_EVENT_ACK;
 	pAck->ChainOffset  = 0;
@@ -2866,25 +4252,212 @@
 	return 0;
 }
 
-#ifdef CONFIG_PROC_FS		/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mpt_config - Generic function to issue config message
+ *	@ioc - Pointer to an adapter structure
+ *	@cfg - Pointer to a configuration structure. Struct contains
+ *		action, page address, direction, physical address
+ *		and pointer to a configuration page header
+ *		Page header is updated.
+ *
+ *	Returns 0 for success
+ *	-EPERM if not allowed due to ISR context
+ *	-EAGAIN if no msg frames currently available
+ *	-EFAULT for non-successful reply or no reply (timeout)
+ */
+int
+mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *pCfg)
+{
+	Config_t	*pReq;
+	MPT_FRAME_HDR	*mf;
+	MptSge_t	*psge;
+	unsigned long	 flags;
+	int		 ii, rc;
+	int		 flagsLength;
+	int		 in_isr;
+
+	/* (Bugzilla:fibrebugs, #513)
+	 * Bug fix (part 1)!  20010905 -sralston
+	 *	Prevent calling wait_event() (below), if caller happens
+	 *	to be in ISR context, because that is fatal!
+	 */
+	in_isr = in_interrupt();
+	if (in_isr) {
+		dprintk((MYIOC_s_WARN_FMT "Config request not allowed in ISR context!\n",
+				ioc->name));
+		return -EPERM;
+	}
+
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(mpt_base_index, ioc->id)) == NULL) {
+		dprintk((MYIOC_s_WARN_FMT "mpt_config: no msg frames!\n",
+				ioc->name));
+		return -EAGAIN;
+	}
+	pReq = (Config_t *)mf;
+	pReq->Action = pCfg->action;
+	pReq->Reserved = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_CONFIG;
+	pReq->Reserved1[0] = 0;
+	pReq->Reserved1[1] = 0;
+	pReq->Reserved1[2] = 0;
+	pReq->MsgFlags = 0;
+	for (ii=0; ii < 8; ii++)
+		pReq->Reserved2[ii] = 0;
+
+	pReq->Header.PageVersion = pCfg->hdr->PageVersion;
+	pReq->Header.PageLength = pCfg->hdr->PageLength;
+	pReq->Header.PageNumber = pCfg->hdr->PageNumber;
+	pReq->Header.PageType = (pCfg->hdr->PageType & MPI_CONFIG_PAGETYPE_MASK);
+	pReq->PageAddress = cpu_to_le32(pCfg->pageAddr);
+
+	/* Add a SGE to the config request.
+	 */
+	flagsLength = ((MPI_SGE_FLAGS_LAST_ELEMENT |
+			MPI_SGE_FLAGS_END_OF_BUFFER |
+			MPI_SGE_FLAGS_END_OF_LIST |
+			MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+			MPT_SGE_ADDRESS_SIZE ) << MPI_SGE_FLAGS_SHIFT) |
+			pCfg->hdr->PageLength * 4;
+
+	if (pCfg->dir)
+		flagsLength |= (MPI_SGE_FLAGS_DIRECTION << MPI_SGE_FLAGS_SHIFT);
+
+	psge = (MptSge_t *) &pReq->PageBufferSGE;
+	psge->FlagsLength = cpu_to_le32(flagsLength);
+	cpu_to_leXX(pCfg->physAddr, psge->Address);
+
+	dprintk((MYIOC_s_INFO_FMT "Sending Config request type %d, page %d and action %d\n",
+		ioc->name, pReq->Header.PageType, pReq->Header.PageNumber, pReq->Action));
+
+	/* Append pCfg pointer to end of mf
+	 */
+	*((void **) (((u8 *) mf) + (ioc->req_sz - sizeof(void *)))) =  (void *) pCfg;
+
+	/* Initalize the timer
+	 */
+	init_timer(&pCfg->timer);
+	pCfg->timer.data = (unsigned long) ioc;
+	pCfg->timer.function = mpt_timer_expired;
+	pCfg->wait_done = 0;
+
+	/* Set the timer; ensure 10 second minimum */
+	if (pCfg->timeout < 10)
+		pCfg->timer.expires = jiffies + HZ*10;
+	else
+		pCfg->timer.expires = jiffies + HZ*pCfg->timeout;
+
+	/* Add to end of Q, set timer and then issue this command */
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	Q_ADD_TAIL(&ioc->configQ.head, &pCfg->linkage, Q_ITEM);
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+	add_timer(&pCfg->timer);
+	mpt_put_msg_frame(mpt_base_index, ioc->id, mf);
+	wait_event(mpt_waitq, pCfg->wait_done);
+
+	/* mf has been freed - do not access */
+
+	rc = pCfg->status;
+
+	return rc;
+}
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	procfs (%MPT_PROCFS_MPTBASEDIR/...) support stuff...
+ *	mpt_timer_expired - Call back for timer process.
+ *	Used only internal config functionality.
+ *	@data: Pointer to MPT_SCSI_HOST recast as an unsigned long
+ */
+static void
+mpt_timer_expired(unsigned long data)
+{
+	MPT_ADAPTER *ioc = (MPT_ADAPTER *) data;
+
+	dprintk((MYIOC_s_WARN_FMT "mpt_timer_expired! \n", ioc->name));
+
+	/* Perform a FW reload */
+	if (mpt_HardResetHandler(ioc, NO_SLEEP) < 0)
+		printk(MYIOC_s_WARN_FMT "Firmware Reload FAILED!\n", ioc->name);
+
+	/* No more processing.
+	 * Hard reset clean-up will wake up
+	 * process and free all resources.
+	 */
+	dprintk((MYIOC_s_WARN_FMT "mpt_timer_expired complete!\n", ioc->name));
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mpt_ioc_reset - Base cleanup for hard reset
+ *	@ioc: Pointer to the adapter structure
+ *	@reset_phase: Indicates pre- or post-reset functionality
+ *
+ *	Remark: Free's resources with internally generated commands.
  */
+static int
+mpt_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
+{
+	CONFIGPARMS *pCfg;
+	unsigned long flags;
+
+	dprintk((KERN_WARNING MYNAM
+			": IOC %s_reset routed to MPT base driver!\n",
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+
+	if (reset_phase == MPT_IOC_PRE_RESET) {
+		/* If the internal config Q is not empty -
+		 * delete timer. MF resources will be freed when
+		 * the FIFO's are primed.
+		 */
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		if (! Q_IS_EMPTY(&ioc->configQ)){
+			pCfg = (CONFIGPARMS *)ioc->configQ.head;
+			do {
+				del_timer(&pCfg->timer);
+				pCfg = (CONFIGPARMS *) (pCfg->linkage.forw);
+			} while (pCfg != (CONFIGPARMS *)&ioc->configQ);
+		}
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+	} else {
+		CONFIGPARMS *pNext;
+
+		/* Search the configQ for internal commands. 
+		 * Flush the Q, and wake up all suspended threads.
+		 */
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		if (! Q_IS_EMPTY(&ioc->configQ)){
+			pCfg = (CONFIGPARMS *)ioc->configQ.head;
+			do {
+				pNext = (CONFIGPARMS *) pCfg->linkage.forw;
 
-#define PROC_MPT_READ_RETURN(page,start,off,count,eof,len) \
-{ \
-	len -= off;			\
-	if (len < count) {		\
-		*eof = 1;		\
-		if (len <= 0)		\
-			return 0;	\
-	} else				\
-		len = count;		\
-	*start = page + off;		\
-	return len;			\
+				Q_DEL_ITEM(&pCfg->linkage);
+
+				pCfg->status = MPT_CONFIG_ERROR;
+				pCfg->wait_done = 1;
+				wake_up(&mpt_waitq);
+
+				pCfg = pNext;
+			} while (pCfg != (CONFIGPARMS *)&ioc->configQ);
+		}
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+	}
+
+	return 1;		/* currently means nothing really */
 }
 
+
+#ifdef CONFIG_PROC_FS		/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	procfs (%MPT_PROCFS_MPTBASEDIR/...) support stuff...
+ */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	procmpt_create - Create %MPT_PROCFS_MPTBASEDIR entries.
@@ -2894,71 +4467,62 @@
 static int
 procmpt_create(void)
 {
-	MPT_ADAPTER *ioc;
-	struct proc_dir_entry *ent;
-	int errcnt = 0;
+	MPT_ADAPTER		*ioc;
+	struct proc_dir_entry	*ent;
+	int	 ii;
 
 	/*
-	 * 	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
-	 * 	(single level) to multi level (e.g. "driver/message/fusion")
-	 * 	something here needs to change.  -sralston
+	 *	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
+	 *	(single level) to multi level (e.g. "driver/message/fusion")
+	 *	something here needs to change.  -sralston
 	 */
-	procmpt_root_dir = CREATE_PROCDIR_ENTRY(MPT_PROCFS_MPTBASEDIR, NULL);
-	if (procmpt_root_dir == NULL)
+	mpt_proc_root_dir = proc_mkdir(MPT_PROCFS_MPTBASEDIR, NULL);
+	if (mpt_proc_root_dir == NULL)
 		return -ENOTDIR;
 
-	if ((ioc = mpt_adapter_find_first()) != NULL) {
-		ent = create_proc_read_entry(MPT_PROCFS_SUMMARY_NODE, 0, NULL, procmpt_read_summary, NULL);
-		if (ent == NULL) {
-			printk(KERN_WARNING MYNAM ": WARNING - Could not create %s entry!\n",
-					MPT_PROCFS_SUMMARY_PATHNAME);
-			errcnt++;
+	for (ii=0; ii < MPT_PROC_ENTRIES; ii++) {
+		ent = create_proc_entry(mpt_proc_list[ii].name,
+				S_IFREG|S_IRUGO, mpt_proc_root_dir);
+		if (!ent) {
+			printk(KERN_WARNING MYNAM
+					": WARNING - Could not create /proc/mpt/%s entry\n",
+					mpt_proc_list[ii].name);
+			continue;
 		}
+		ent->read_proc = mpt_proc_list[ii].f;
+		ent->data      = NULL;
 	}
 
+	ioc = mpt_adapter_find_first();
 	while (ioc != NULL) {
-		char pname[32];
-		int namelen;
+		struct proc_dir_entry	*dent;
 		/*
 		 *  Create "/proc/mpt/iocN" subdirectory entry for each MPT adapter.
 		 */
-		namelen = sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
-		if ((ent = CREATE_PROCDIR_ENTRY(pname, NULL)) != NULL) {
+		if ((dent = proc_mkdir(ioc->name, mpt_proc_root_dir)) != NULL) {
 			/*
-			 *  And populate it with: "summary" and "dbg" file entries.
+			 *  And populate it with mpt_ioc_proc_list[] entries.
 			 */
-			(void) sprintf(pname+namelen, "/summary");
-			ent = create_proc_read_entry(pname, 0, NULL, procmpt_read_summary, ioc);
-			if (ent == NULL) {
-				errcnt++;
-				printk(KERN_WARNING MYNAM ": %s: WARNING - Could not create /proc/%s entry!\n",
-						ioc->name, pname);
-			}
-//#ifdef MPT_DEBUG
-			/* DEBUG aid! */
-			(void) sprintf(pname+namelen, "/dbg");
-			ent = create_proc_read_entry(pname, 0, NULL, procmpt_read_dbg, ioc);
-			if (ent == NULL) {
-				errcnt++;
-				printk(KERN_WARNING MYNAM ": %s: WARNING - Could not create /proc/%s entry!\n",
-						ioc->name, pname);
+			for (ii=0; ii < MPT_IOC_PROC_ENTRIES; ii++) {
+				ent = create_proc_entry(mpt_ioc_proc_list[ii].name,
+						S_IFREG|S_IRUGO, dent);
+				if (!ent) {
+					printk(KERN_WARNING MYNAM
+							": WARNING - Could not create /proc/mpt/%s/%s entry!\n",
+							ioc->name,
+							mpt_ioc_proc_list[ii].name);
+					continue;
+				}
+				ent->read_proc = mpt_ioc_proc_list[ii].f;
+				ent->data      = ioc;
 			}
-//#endif
 		} else {
-			errcnt++;
-			printk(KERN_WARNING MYNAM ": %s: WARNING - Could not create /proc/%s entry!\n",
-					ioc->name, pname);
-
+			printk(MYIOC_s_WARN_FMT "Could not create /proc/mpt/%s subdir entry!\n",
+					ioc->name, mpt_ioc_proc_list[ii].name);
 		}
-
 		ioc = mpt_adapter_find_next(ioc);
 	}
 
-	if (errcnt) {
-//		remove_proc_entry("mpt", 0);
-		return -ENOTDIR;
-	}
-
 	return 0;
 }
 
@@ -2971,44 +4535,44 @@
 static int
 procmpt_destroy(void)
 {
-	MPT_ADAPTER *ioc;
+	MPT_ADAPTER	*ioc;
+	int		 ii;
 
-	if (!procmpt_root_dir)
+	if (!mpt_proc_root_dir)
 		return 0;
 
 	/*
-	 * 	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
-	 * 	(single level) to multi level (e.g. "driver/message/fusion")
-	 * 	something here needs to change.  -sralston
+	 *	BEWARE: If/when MPT_PROCFS_MPTBASEDIR changes from "mpt"
+	 *	(single level) to multi level (e.g. "driver/message/fusion")
+	 *	something here needs to change.  -sralston
 	 */
 
 	ioc = mpt_adapter_find_first();
-	if (ioc != NULL) {
-		remove_proc_entry(MPT_PROCFS_SUMMARY_NODE, 0);
-	}
-
 	while (ioc != NULL) {
 		char pname[32];
 		int namelen;
+
+		namelen = sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
+
 		/*
 		 *  Tear down each "/proc/mpt/iocN" subdirectory.
 		 */
-		namelen = sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
-		(void) sprintf(pname+namelen, "/summary");
-		remove_proc_entry(pname, 0);
-//#ifdef MPT_DEBUG
-		(void) sprintf(pname+namelen, "/dbg");
-		remove_proc_entry(pname, 0);
-//#endif
-		(void) sprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);
-		remove_proc_entry(pname, 0);
+		for (ii=0; ii < MPT_IOC_PROC_ENTRIES; ii++) {
+			(void) sprintf(pname+namelen, "/%s", mpt_ioc_proc_list[ii].name);
+			remove_proc_entry(pname, NULL);
+		}
+
+		remove_proc_entry(ioc->name, mpt_proc_root_dir);
 
 		ioc = mpt_adapter_find_next(ioc);
 	}
 
-	if (atomic_read((atomic_t *)&procmpt_root_dir->count) == 0) {
-		remove_proc_entry(MPT_PROCFS_MPTBASEDIR, 0);
-		procmpt_root_dir = NULL;
+	for (ii=0; ii < MPT_PROC_ENTRIES; ii++)
+		remove_proc_entry(mpt_proc_list[ii].name, mpt_proc_root_dir);
+
+	if (atomic_read((atomic_t *)&mpt_proc_root_dir->count) == 0) {
+		remove_proc_entry(MPT_PROCFS_MPTBASEDIR, NULL);
+		mpt_proc_root_dir = NULL;
 		return 0;
 	}
 
@@ -3016,23 +4580,23 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	procmpt_read_summary - Handle read request from /proc/mpt/summary
+/*
+ *	procmpt_summary_read - Handle read request from /proc/mpt/summary
  *	or from /proc/mpt/iocN/summary.
- *	@page: Pointer to area to write information
+ *	@buf: Pointer to area to write information
  *	@start: Pointer to start pointer
- *	@off: Offset to start writing
- *	@count: 
+ *	@offset: Offset to start writing
+ *	@request:
  *	@eof: Pointer to EOF integer
- *	@data: Pointer 
+ *	@data: Pointer
  *
- *	Returns numbers of characters written to process performing the read.
+ *	Returns number of characters written to process performing the read.
  */
 static int
-procmpt_read_summary(char *page, char **start, off_t off, int count, int *eof, void *data)
+procmpt_summary_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
 {
 	MPT_ADAPTER *ioc;
-	char *out = page;
+	char *out = buf;
 	int len;
 
 	if (data == NULL)
@@ -3040,84 +4604,196 @@
 	else
 		ioc = data;
 
-// Too verbose!
-//	out += sprintf(out, "Attached Fusion MPT I/O Controllers:%s\n", ioc ? "" : " none");
-
 	while (ioc) {
 		int	more = 0;
 
-// Too verbose!
-//		mpt_print_ioc_facts(ioc, out, &more, 0);
 		mpt_print_ioc_summary(ioc, out, &more, 0, 1);
 
 		out += more;
-		if ((out-page) >= count) {
+		if ((out-buf) >= request) {
 			break;
 		}
 
 		if (data == NULL)
 			ioc = mpt_adapter_find_next(ioc);
 		else
-			ioc = NULL;				/* force exit for iocN */
+			ioc = NULL;		/* force exit for iocN */
 	}
-	len = out - page;
+	len = out - buf;
 
-	PROC_MPT_READ_RETURN(page,start,off,count,eof,len);
+	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
 }
 
-// debug aid!
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	procmpt_read_dbg - Handle read request from /proc/mpt/iocN/dbg.
- *	@page: Pointer to area to write information
+/*
+ *	procmpt_version_read - Handle read request from /proc/mpt/version.
+ *	@buf: Pointer to area to write information
  *	@start: Pointer to start pointer
- *	@off: Offset to start writing
- *	@count: 
+ *	@offset: Offset to start writing
+ *	@request:
  *	@eof: Pointer to EOF integer
- *	@data: Pointer 
+ *	@data: Pointer
  *
- *	Returns numbers of characters written to process performing the read.
+ *	Returns number of characters written to process performing the read.
  */
 static int
-procmpt_read_dbg(char *page, char **start, off_t off, int count, int *eof, void *data)
+procmpt_version_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
 {
-	MPT_ADAPTER *ioc;
-	char *out = page;
-	int len;
+	int	 ii;
+	int	 scsi, lan, ctl, targ, dmp;
+	char	*drvname;
+	int	 len;
+
+	len = sprintf(buf, "%s-%s\n", "mptlinux", MPT_LINUX_VERSION_COMMON);
+	len += sprintf(buf+len, "  Fusion MPT base driver\n");
+
+	scsi = lan = ctl = targ = dmp = 0;
+	for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+		drvname = NULL;
+		if (MptCallbacks[ii]) {
+			switch (MptDriverClass[ii]) {
+			case MPTSCSIH_DRIVER:
+				if (!scsi++) drvname = "SCSI host";
+				break;
+			case MPTLAN_DRIVER:
+				if (!lan++) drvname = "LAN";
+				break;
+			case MPTSTM_DRIVER:
+				if (!targ++) drvname = "SCSI target";
+				break;
+			case MPTCTL_DRIVER:
+				if (!ctl++) drvname = "ioctl";
+				break;
+			case MPTDMP_DRIVER:
+				if (!dmp++) drvname = "DMP";
+				break;
+			}
+
+			if (drvname)
+				len += sprintf(buf+len, "  Fusion MPT %s driver\n", drvname);
+			/*
+			 *	Handle isense special case, because it
+			 *	doesn't do a formal mpt_register call.
+			 */
+			if (isense_idx == ii)
+				len += sprintf(buf+len, "  Fusion MPT isense driver\n");
+		} else
+			break;
+	}
 
-	ioc = data;
+	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
+}
 
-	while (ioc) {
-		int	more = 0;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	procmpt_iocinfo_read - Handle read request from /proc/mpt/iocN/info.
+ *	@buf: Pointer to area to write information
+ *	@start: Pointer to start pointer
+ *	@offset: Offset to start writing
+ *	@request:
+ *	@eof: Pointer to EOF integer
+ *	@data: Pointer
+ *
+ *	Returns number of characters written to process performing the read.
+ */
+static int
+procmpt_iocinfo_read(char *buf, char **start, off_t offset, int request, int *eof, void *data)
+{
+	MPT_ADAPTER	*ioc = data;
+	int		 len;
+	char		 expVer[32];
+	int		 sz;
+	int		 p;
 
-		mpt_print_ioc_facts(ioc, out, &more, 0);
+	mpt_get_fw_exp_ver(expVer, ioc);
 
-		out += more;
-		if ((out-page) >= count) {
-			break;
+	len = sprintf(buf, "%s:", ioc->name);
+	if (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)
+		len += sprintf(buf+len, "  (f/w download boot flag set)");
+//	if (ioc->facts.IOCExceptions & MPI_IOCFACTS_EXCEPT_CONFIG_CHECKSUM_FAIL)
+//		len += sprintf(buf+len, "  CONFIG_CHECKSUM_FAIL!");
+
+	len += sprintf(buf+len, "\n  ProductID = 0x%04x (%s)\n",
+			ioc->facts.ProductID,
+			ioc->prod_name);
+	len += sprintf(buf+len, "  FWVersion = 0x%08x%s", ioc->facts.FWVersion.Word, expVer);
+	if (ioc->facts.FWImageSize)
+		len += sprintf(buf+len, " (fw_size=%d)", ioc->facts.FWImageSize);
+	len += sprintf(buf+len, "\n  MsgVersion = 0x%04x\n", ioc->facts.MsgVersion);
+	len += sprintf(buf+len, "  FirstWhoInit = 0x%02x\n", ioc->FirstWhoInit);
+	len += sprintf(buf+len, "  EventState = 0x%02x\n", ioc->facts.EventState);
+
+	len += sprintf(buf+len, "  CurrentHostMfaHighAddr = 0x%08x\n",
+			ioc->facts.CurrentHostMfaHighAddr);
+	len += sprintf(buf+len, "  CurrentSenseBufferHighAddr = 0x%08x\n",
+			ioc->facts.CurrentSenseBufferHighAddr);
+
+	len += sprintf(buf+len, "  MaxChainDepth = 0x%02x frames\n", ioc->facts.MaxChainDepth);
+	len += sprintf(buf+len, "  MinBlockSize = 0x%02x bytes\n", 4*ioc->facts.BlockSize);
+
+	len += sprintf(buf+len, "  RequestFrames @ 0x%p (Dma @ 0x%p)\n",
+					ioc->req_alloc, (void *)(ulong)ioc->req_alloc_dma);
+	/*
+	 *  Rounding UP to nearest 4-kB boundary here...
+	 */
+	sz = (ioc->req_sz * ioc->req_depth) + 128;
+	sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
+	len += sprintf(buf+len, "    {CurReqSz=%d} x {CurReqDepth=%d} = %d bytes ^= 0x%x\n",
+					ioc->req_sz, ioc->req_depth, ioc->req_sz*ioc->req_depth, sz);
+	len += sprintf(buf+len, "    {MaxReqSz=%d}   {MaxReqDepth=%d}\n",
+					4*ioc->facts.RequestFrameSize,
+					ioc->facts.GlobalCredits);
+
+	len += sprintf(buf+len, "  ReplyFrames   @ 0x%p (Dma @ 0x%p)\n",
+					ioc->reply_alloc, (void *)(ulong)ioc->reply_alloc_dma);
+	sz = (ioc->reply_sz * ioc->reply_depth) + 128;
+	len += sprintf(buf+len, "    {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\n",
+					ioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);
+	len += sprintf(buf+len, "    {MaxRepSz=%d}   {MaxRepDepth=%d}\n",
+					ioc->facts.CurReplyFrameSize,
+					ioc->facts.ReplyQueueDepth);
+
+	len += sprintf(buf+len, "  MaxDevices = %d\n",
+			(ioc->facts.MaxDevices==0) ? 255 : ioc->facts.MaxDevices);
+	len += sprintf(buf+len, "  MaxBuses = %d\n", ioc->facts.MaxBuses);
+
+	/* per-port info */
+	for (p=0; p < ioc->facts.NumberOfPorts; p++) {
+		len += sprintf(buf+len, "  PortNumber = %d (of %d)\n",
+				p+1,
+				ioc->facts.NumberOfPorts);
+		if ((int)ioc->chip_type <= (int)FC929) {
+			if (ioc->pfacts[p].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {
+				u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
+				len += sprintf(buf+len, "    LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
+						a[5], a[4], a[3], a[2], a[1], a[0]);
+			}
+			len += sprintf(buf+len, "    WWN = %08X%08X:%08X%08X\n",
+					ioc->fc_port_page0[p].WWNN.High,
+					ioc->fc_port_page0[p].WWNN.Low,
+					ioc->fc_port_page0[p].WWPN.High,
+					ioc->fc_port_page0[p].WWPN.Low);
 		}
-		ioc = NULL;
 	}
-	len = out - page;
 
-	PROC_MPT_READ_RETURN(page,start,off,count,eof,len);
+	MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len);
 }
+
 #endif		/* CONFIG_PROC_FS } */
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static void
 mpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc)
 {
-	if ((ioc->facts.FWVersion & 0xF000) == 0xE000)
+	buf[0] ='\0';
+	if ((ioc->facts.FWVersion.Word >> 24) == 0x0E) {
 		sprintf(buf, " (Exp %02d%02d)",
-			(ioc->facts.FWVersion & 0x0F00) >> 8,	/* Month */
-			ioc->facts.FWVersion & 0x001F);		/* Day */
-	else
-		buf[0] ='\0';
+			(ioc->facts.FWVersion.Word >> 16) & 0x00FF,	/* Month */
+			(ioc->facts.FWVersion.Word >> 8) & 0x1F);	/* Day */
 
-	/* insider hack! */
-	if (ioc->facts.FWVersion & 0x0080) {
-		strcat(buf, " [MDBG]");
+		/* insider hack! */
+		if ((ioc->facts.FWVersion.Word >> 8) & 0x80)
+			strcat(buf, " [MDBG]");
 	}
 }
 
@@ -3130,8 +4806,8 @@
  *	@len: Offset at which to start writing in buffer
  *	@showlan: Display LAN stuff?
  *
- * 	This routine writes (english readable) ASCII text, which represents
- * 	a summary of IOC information, to a buffer.
+ *	This routine writes (english readable) ASCII text, which represents
+ *	a summary of IOC information, to a buffer.
  */
 void
 mpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buffer, int *size, int len, int showlan)
@@ -3144,11 +4820,11 @@
 	/*
 	 *  Shorter summary of attached ioc's...
 	 */
-	y = sprintf(buffer+len, "%s: %s, %s%04xh%s, Ports=%d, MaxQ=%d",
+	y = sprintf(buffer+len, "%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d",
 			ioc->name,
 			ioc->prod_name,
 			MPT_FW_REV_MAGIC_ID_STRING,	/* "FwRev=" or somesuch */
-			ioc->facts.FWVersion,
+			ioc->facts.FWVersion.Word,
 			expVer,
 			ioc->facts.NumberOfPorts,
 			ioc->req_depth);
@@ -3159,8 +4835,11 @@
 			a[5], a[4], a[3], a[2], a[1], a[0]);
 	}
 
-	if (ioc->pci_irq < 100)
-		y += sprintf(buffer+len+y, ", IRQ=%d", ioc->pci_irq);
+#ifndef __sparc__
+	y += sprintf(buffer+len+y, ", IRQ=%d", ioc->pci_irq);
+#else
+	y += sprintf(buffer+len+y, ", IRQ=%s", __irq_itoa(ioc->pci_irq));
+#endif
 
 	if (!ioc->active)
 		y += sprintf(buffer+len+y, " (disabled)");
@@ -3171,75 +4850,66 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	Reset Handling
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mpt_print_ioc_facts - Write ASCII summary of IOC facts to a buffer.
+ *	mpt_HardResetHandler - Generic reset handler, issue SCSI Task
+ *	Management call based on input arg values.  If TaskMgmt fails,
+ *	return associated SCSI request.
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@buffer: Pointer to buffer where IOC facts should be written
- *	@size: Pointer to number of bytes we wrote (set by this routine)
- *	@len: Offset at which to start writing in buffer
+ *	@sleepFlag: Indicates if sleep or schedule must be called.
+ *
+ *	Remark: _HardResetHandler can be invoked from an interrupt thread (timer)
+ *	or a non-interrupt thread.  In the former, must not call schedule().
  *
- * 	This routine writes (english readable) ASCII text, which represents
- * 	a summary of the IOC facts, to a buffer.
+ *	Remark: A return of -1 is a FATAL error case, as it means a
+ *	FW reload/initialization failed.
+ *
+ *	Returns 0 for SUCCESS or -1 if FAILED.
  */
-void
-mpt_print_ioc_facts(MPT_ADAPTER *ioc, char *buffer, int *size, int len)
+int
+mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag)
 {
-	char expVer[32];
-	char iocName[16];
-	int sz;
-	int y;
-	int p;
-
-	mpt_get_fw_exp_ver(expVer, ioc);
+	int		 rc;
+	unsigned long	 flags;
 
-	strcpy(iocName, ioc->name);
-	y = sprintf(buffer+len, "%s:\n", iocName);
+	dprintk((MYIOC_s_INFO_FMT "HardResetHandler Entered!\n", ioc->name));
+#ifdef MFCNT
+	printk(MYIOC_s_INFO_FMT "HardResetHandler Entered!\n", ioc->name);
+	printk("MF count 0x%x !\n", ioc->mfcnt);
+#endif
 
-	y += sprintf(buffer+len+y, "  ProductID = 0x%04x\n", ioc->facts.ProductID);
-	for (p=0; p < ioc->facts.NumberOfPorts; p++) {
-		y += sprintf(buffer+len+y, "  PortNumber = %d (of %d)\n",
-			p+1,
-			ioc->facts.NumberOfPorts);
-		if (ioc->pfacts[p].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {
-			u8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;
-			y += sprintf(buffer+len+y, "  LanAddr = 0x%02x:%02x:%02x:%02x:%02x:%02x\n",
-				a[5], a[4], a[3], a[2], a[1], a[0]);
-		}
-	}
-	y += sprintf(buffer+len+y, "  FWVersion = 0x%04x%s\n", ioc->facts.FWVersion, expVer);
-	y += sprintf(buffer+len+y, "  MsgVersion = 0x%04x\n", ioc->facts.MsgVersion);
-	y += sprintf(buffer+len+y, "  FirstWhoInit = 0x%02x\n", ioc->FirstWhoInit);
-	y += sprintf(buffer+len+y, "  EventState = 0x%02x\n", ioc->facts.EventState);
-	y += sprintf(buffer+len+y, "  CurrentHostMfaHighAddr = 0x%08x\n",
-		 	ioc->facts.CurrentHostMfaHighAddr);
-	y += sprintf(buffer+len+y, "  CurrentSenseBufferHighAddr = 0x%08x\n",
-			ioc->facts.CurrentSenseBufferHighAddr);
-	y += sprintf(buffer+len+y, "  MaxChainDepth = 0x%02x frames\n", ioc->facts.MaxChainDepth);
-	y += sprintf(buffer+len+y, "  MinBlockSize = 0x%02x bytes\n", 4*ioc->facts.BlockSize);
+	/* Reset the adapter. Prevent more than 1 call to
+	 * mpt_do_ioc_recovery at any instant in time.
+	 */
+	spin_lock_irqsave(&ioc->diagLock, flags);
+	if ((ioc->diagPending) || (ioc->alt_ioc && ioc->alt_ioc->diagPending)){
+		spin_unlock_irqrestore(&ioc->diagLock, flags);
+		return 0;
+	} else {
+		ioc->diagPending = 1;
+	}
+	spin_unlock_irqrestore(&ioc->diagLock, flags);
 
-	y += sprintf(buffer+len+y, "  RequestFrames @ 0x%p (Dma @ 0x%08x)\n",
-					ioc->req_alloc, ioc->req_alloc_dma);
-	/*
-	 *  Rounding UP to nearest 4-kB boundary here...
+	/* FIXME: If do_ioc_recovery fails, repeat....
 	 */
-	sz = (ioc->req_sz * ioc->req_depth) + 128;
-	sz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;
-	y += sprintf(buffer+len+y, "    {CurReqSz=%d} x {CurReqDepth=%d} = %d bytes ^= 0x%x\n",
-					ioc->req_sz, ioc->req_depth, ioc->req_sz*ioc->req_depth, sz);
-	y += sprintf(buffer+len+y, "    {MaxReqSz=%d}   {MaxReqDepth=%d}\n",
-					4*ioc->facts.RequestFrameSize,
-					ioc->facts.GlobalCredits);
 
-	y += sprintf(buffer+len+y, "  ReplyFrames   @ 0x%p (Dma @ 0x%08x)\n",
-					ioc->reply_alloc, ioc->reply_alloc_dma);
-	sz = (ioc->reply_sz * ioc->reply_depth) + 128;
-	y += sprintf(buffer+len+y, "    {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\n",
-					ioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);
-	y += sprintf(buffer+len+y, "    {MaxRepSz=%d}   {MaxRepDepth=%d}\n",
-					ioc->facts.CurReplyFrameSize,
-					ioc->facts.ReplyQueueDepth);
+	if ((rc = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_RECOVER, sleepFlag)) != 0) {
+		printk(KERN_WARNING MYNAM ": WARNING - (%d) Cannot recover %s\n",
+			rc, ioc->name);
+	}
 
-	*size = y;
+	spin_lock_irqsave(&ioc->diagLock, flags);
+	ioc->diagPending = 0;
+	if (ioc->alt_ioc)
+		ioc->alt_ioc->diagPending = 0;
+	spin_unlock_irqrestore(&ioc->diagLock, flags);
+
+	dprintk((MYIOC_s_INFO_FMT "HardResetHandler rc = %d!\n", ioc->name, rc));
+
+	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -3268,7 +4938,7 @@
 		ds = "External Bus Reset";
 		break;
 	case MPI_EVENT_RESCAN:
-		ds = "Bus Rescan Event"; 
+		ds = "Bus Rescan Event";
 		/* Ok, do we need to do anything here? As far as
 		   I can tell, this is when a new device gets added
 		   to the loop. */
@@ -3296,6 +4966,9 @@
 		else
 			ds = "Events(OFF) Change";
 		break;
+	case MPI_EVENT_INTEGRATED_RAID:
+		ds = "Integrated Raid";
+		break;
 	/*
 	 *  MPT base "custom" events may be added here...
 	 */
@@ -3307,7 +4980,7 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	ProcessEventNotification - Route a received EventNotificationReply to
  *	all currently regeistered event handlers.
  *	@ioc: Pointer to MPT_ADAPTER structure
@@ -3322,7 +4995,7 @@
 	u16 evDataLen;
 	u32 evData0 = 0;
 //	u32 evCtx;
-	int i;
+	int ii;
 	int r = 0;
 	int handlers = 0;
 	char *evStr;
@@ -3339,15 +5012,15 @@
 	}
 
 	evStr = EventDescriptionStr(event, evData0);
-	dprintk((KERN_INFO MYNAM ": %s: MPT event (%s=%02Xh) detected!\n",
+	dprintk((MYIOC_s_INFO_FMT "MPT event (%s=%02Xh) detected!\n",
 			ioc->name,
 			evStr,
 			event));
 
 #if defined(MPT_DEBUG) || defined(MPT_DEBUG_EVENTS)
 	printk(KERN_INFO MYNAM ": Event data:\n" KERN_INFO);
-	for (i = 0; i < evDataLen; i++)
-		printk(" %08x", le32_to_cpu(pEventReply->Data[i]));
+	for (ii = 0; ii < evDataLen; ii++)
+		printk(" %08x", le32_to_cpu(pEventReply->Data[ii]));
 	printk("\n");
 #endif
 
@@ -3365,6 +5038,8 @@
 	case MPI_EVENT_LINK_STATUS_CHANGE:	/* 07 */
 	case MPI_EVENT_LOOP_STATE_CHANGE:	/* 08 */
 	case MPI_EVENT_LOGOUT:			/* 09 */
+	case MPI_EVENT_INTEGRATED_RAID:		/* 0B */
+	case MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE:	/* 0C */
 	default:
 		break;
 	case MPI_EVENT_EVENT_CHANGE:		/* 0A */
@@ -3382,13 +5057,36 @@
 	}
 
 	/*
+	 * Should this event be logged? Events are written sequentially.
+	 * When buffer is full, start again at the top.
+	 */
+	if (ioc->events && (ioc->eventTypes & ( 1 << event))) {
+		int idx;
+
+		idx = ioc->eventContext % ioc->eventLogSize;
+
+		ioc->events[idx].event = event;
+		ioc->events[idx].eventContext = ioc->eventContext;
+
+		for (ii = 0; ii < 2; ii++) {
+			if (ii < evDataLen)
+				ioc->events[idx].data[ii] = le32_to_cpu(pEventReply->Data[ii]);
+			else
+				ioc->events[idx].data[ii] =  0;
+		}
+
+		ioc->eventContext++;
+	}
+
+
+	/*
 	 *  Call each currently registered protocol event handler.
 	 */
-	for (i=MPT_MAX_PROTOCOL_DRIVERS-1; i; i--) {
-		if (MptEvHandlers[i]) {
-			dprintk((KERN_INFO MYNAM ": %s: Routing Event to event handler #%d\n",
-					ioc->name, i));
-			r += (*(MptEvHandlers[i]))(ioc, pEventReply);
+	for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
+		if (MptEvHandlers[ii]) {
+			dprintk((MYIOC_s_INFO_FMT "Routing Event to event handler #%d\n",
+					ioc->name, ii));
+			r += (*(MptEvHandlers[ii]))(ioc, pEventReply);
 			handlers++;
 		}
 	}
@@ -3398,7 +5096,9 @@
 	 *  If needed, send (a single) EventAck.
 	 */
 	if (pEventReply->AckRequired == MPI_EVENT_NOTIFICATION_ACK_REQUIRED) {
-		if ((i = SendEventAck(ioc, pEventReply)) != 0) {
+		if ((ii = SendEventAck(ioc, pEventReply)) != 0) {
+			printk(MYIOC_s_WARN_FMT "SendEventAck returned %d\n",
+					ioc->name, ii);
 		}
 	}
 
@@ -3427,7 +5127,7 @@
 
 	switch(log_info) {
 /* FCP Initiator */
-    	case MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME:
+	case MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME:
 		desc = "Received an out of order frame - unsupported";
 		break;
 	case MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_START_OF_FRAME:
@@ -3483,7 +5183,7 @@
 		desc = "Not sent because login to remote node not validated";
 		break;
 	case MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND:
-		desc = "Cleared from the outbound after a logout";
+		desc = "Cleared from the outbound queue after a logout";
 		break;
 	case MPI_IOCLOGINFO_FC_TARGET_WAITING_FOR_DATA_IN:
 		desc = "Cleared waiting for data after a logout";
@@ -3516,7 +5216,7 @@
 		break;
 	}
 
-	printk(KERN_INFO MYNAM ": %s: LogInfo(0x%08x): SubCl={%s}",
+	printk(MYIOC_s_INFO_FMT "LogInfo(0x%08x): SubCl={%s}",
 			ioc->name, log_info, subcl_str[subcl]);
 	if (SubCl == MPI_IOCLOGINFO_FC_INVALID_FIELD_BYTE_OFFSET)
 		printk(", byte_offset=%d\n", log_info & MPI_IOCLOGINFO_FC_INVALID_FIELD_MAX_OFFSET);
@@ -3539,7 +5239,7 @@
 mpt_sp_log_info(MPT_ADAPTER *ioc, u32 log_info)
 {
 	/* FIXME! */
-	printk(KERN_INFO MYNAM ": %s: LogInfo(0x%08x)\n", ioc->name, log_info);
+	printk(MYIOC_s_INFO_FMT "LogInfo(0x%08x)\n", ioc->name, log_info);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -3553,7 +5253,7 @@
  *	Specialized driver registration routine for the isense driver.
  */
 int
-mpt_register_ascqops_strings(/*ASCQ_Table_t*/void *ascqTable, int ascqtbl_sz, const char **opsTable)
+mpt_register_ascqops_strings(void *ascqTable, int ascqtbl_sz, const char **opsTable)
 {
 	int r = 0;
 
@@ -3562,6 +5262,7 @@
 		mpt_ASCQ_TableSz = ascqtbl_sz;
 		mpt_ScsiOpcodesPtr = opsTable;
 		printk(KERN_INFO MYNAM ": English readable SCSI-3 strings enabled:-)\n");
+		isense_idx = last_drv_idx;
 		r = 1;
 	}
 	MOD_INC_USE_COUNT;
@@ -3582,11 +5283,15 @@
 	mpt_ASCQ_TableSz = 0;
 	mpt_ScsiOpcodesPtr = NULL;
 	printk(KERN_INFO MYNAM ": English readable SCSI-3 strings disabled)-:\n");
+	isense_idx = -1;
 	MOD_DEC_USE_COUNT;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
+EXPORT_SYMBOL(mpt_adapters);
+EXPORT_SYMBOL(mpt_proc_root_dir);
+EXPORT_SYMBOL(DmpService);
 EXPORT_SYMBOL(mpt_register);
 EXPORT_SYMBOL(mpt_deregister);
 EXPORT_SYMBOL(mpt_event_register);
@@ -3597,12 +5302,16 @@
 EXPORT_SYMBOL(mpt_put_msg_frame);
 EXPORT_SYMBOL(mpt_free_msg_frame);
 EXPORT_SYMBOL(mpt_send_handshake_request);
+EXPORT_SYMBOL(mpt_handshake_req_reply_wait);
 EXPORT_SYMBOL(mpt_adapter_find_first);
 EXPORT_SYMBOL(mpt_adapter_find_next);
 EXPORT_SYMBOL(mpt_verify_adapter);
+EXPORT_SYMBOL(mpt_GetIocState);
 EXPORT_SYMBOL(mpt_print_ioc_summary);
 EXPORT_SYMBOL(mpt_lan_index);
 EXPORT_SYMBOL(mpt_stm_index);
+EXPORT_SYMBOL(mpt_HardResetHandler);
+EXPORT_SYMBOL(mpt_config);
 
 EXPORT_SYMBOL(mpt_register_ascqops_strings);
 EXPORT_SYMBOL(mpt_deregister_ascqops_strings);
@@ -3611,12 +5320,13 @@
 EXPORT_SYMBOL(mpt_ScsiOpcodesPtr);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	fusion_init - Fusion MPT base driver initialization routine.
  *
  *	Returns 0 for success, non-zero for failure.
  */
-int __init fusion_init(void)
+int __init
+fusion_init(void)
 {
 	int i;
 
@@ -3636,12 +5346,22 @@
 		MptResetHandlers[i] = NULL;
 	}
 
+	DmpService = NULL;
+
 	/* NEW!  20010120 -sralston
 	 *  Register ourselves (mptbase) in order to facilitate
 	 *  EventNotification handling.
 	 */
 	mpt_base_index = mpt_register(mpt_base_reply, MPTBASE_DRIVER);
 
+	/* Register for hard reset handling callbacks.
+	 */
+	if (mpt_reset_register(mpt_base_index, mpt_ioc_reset) == 0) {
+		dprintk((KERN_INFO MYNAM ": Register for IOC reset notification\n"));
+	} else {
+		/* FIXME! */
+	}
+
 	if ((i = mpt_pci_scan()) < 0)
 		return i;
 
@@ -3649,13 +5369,14 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
+/*
  *	fusion_exit - Perform driver unload cleanup.
  *
  *	This routine frees all resources associated with each MPT adapter
  *	and removes all %MPT_PROCFS_MPTBASEDIR entries.
  */
-static void fusion_exit(void)
+static void
+fusion_exit(void)
 {
 	MPT_ADAPTER *this;
 
@@ -3665,7 +5386,7 @@
 	 *  Moved this *above* removal of all MptAdapters!
 	 */
 #ifdef CONFIG_PROC_FS
-	procmpt_destroy();
+	(void) procmpt_destroy();
 #endif
 
 	while (! Q_IS_EMPTY(&MptAdapters)) {
@@ -3673,6 +5394,8 @@
 		Q_DEL_ITEM(this);
 		mpt_adapter_dispose(this);
 	}
+
+	mpt_reset_deregister(mpt_base_index);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptbase.h linux/drivers/message/fusion/mptbase.h
--- ../ia64/linux/drivers/message/fusion/mptbase.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/mptbase.h	Tue Mar 19 16:05:36 2002
@@ -8,11 +8,12 @@
  *  Credits:
  *     (see mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptbase.h,v 1.46.2.2.2.2 2001/09/18 03:22:29 sralston Exp $
+ *  $Id: mptbase.h,v 1.103 2002/02/27 20:24:38 pdelaney Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -55,6 +56,7 @@
 /*{-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 #include "linux_compat.h"	/* linux-2.2.x (vs. -2.4.x) tweaks */
+#include "scsi3.h"		/* SCSI defines */
 
 #include "lsi/mpi_type.h"
 #include "lsi/mpi.h"		/* Fusion MPI(nterface) basic defs */
@@ -62,6 +64,7 @@
 #include "lsi/mpi_cnfg.h"	/* IOC configuration support */
 #include "lsi/mpi_init.h"	/* SCSI Host (initiator) protocol support */
 #include "lsi/mpi_lan.h"	/* LAN over FC protocol support */
+#include "lsi/mpi_raid.h"	/* Integrated Mirroring support */
 
 #include "lsi/mpi_fc.h"		/* Fibre Channel (lowlevel) support */
 #include "lsi/mpi_targ.h"	/* SCSI/FCP Target protcol support */
@@ -74,11 +77,11 @@
 #endif
 
 #ifndef COPYRIGHT
-#define COPYRIGHT	"Copyright (c) 1999-2001 " MODULEAUTHOR
+#define COPYRIGHT	"Copyright (c) 1999-2002 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"1.02.02"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-1.02.02"
+#define MPT_LINUX_VERSION_COMMON	"2.00.11"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-2.00.11"
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 
 #define show_mptmod_ver(s,ver)  \
@@ -89,39 +92,77 @@
  *  Fusion MPT(linux) driver configurable stuff...
  */
 #define MPT_MAX_ADAPTERS		16
-#define MPT_MAX_PROTOCOL_DRIVERS	8
+#define MPT_MAX_PROTOCOL_DRIVERS	16
+#define MPT_MAX_BUS			1
 #define MPT_MAX_FC_DEVICES		255
+#define MPT_MAX_SCSI_DEVICES		16
+#define MPT_LAST_LUN			31
+#define MPT_SENSE_BUFFER_ALLOC		64
+	/* allow for 256 max sense alloc, but only 255 max request */
+#if MPT_SENSE_BUFFER_ALLOC >= 256
+#	undef MPT_SENSE_BUFFER_ALLOC
+#	define MPT_SENSE_BUFFER_ALLOC	256
+#	define MPT_SENSE_BUFFER_SIZE	255
+#else
+#	define MPT_SENSE_BUFFER_SIZE	MPT_SENSE_BUFFER_ALLOC
+#endif
 
-#define MPT_MISCDEV_BASENAME		"mptctl"
-#define MPT_MISCDEV_PATHNAME		"/dev/" MPT_MISCDEV_BASENAME
+#define MPT_NAME_LENGTH			32
 
 #define MPT_PROCFS_MPTBASEDIR		"mpt"
 						/* chg it to "driver/fusion" ? */
-#define MPT_PROCFS_SUMMARY_NODE		MPT_PROCFS_MPTBASEDIR "/summary"
-#define MPT_PROCFS_SUMMARY_PATHNAME	"/proc/" MPT_PROCFS_SUMMARY_NODE
-#define MPT_FW_REV_MAGIC_ID_STRING	"FwRev="
+#define MPT_PROCFS_SUMMARY_ALL_NODE		MPT_PROCFS_MPTBASEDIR "/summary"
+#define MPT_PROCFS_SUMMARY_ALL_PATHNAME		"/proc/" MPT_PROCFS_SUMMARY_ALL_NODE
+#define MPT_FW_REV_MAGIC_ID_STRING		"FwRev="
 
-#ifdef __KERNEL__	/* { */
 #define  MPT_MAX_REQ_DEPTH		1023
-#define  MPT_REQ_DEPTH			256
+#define  MPT_DEFAULT_REQ_DEPTH		256
 #define  MPT_MIN_REQ_DEPTH		128
 
 #define  MPT_MAX_REPLY_DEPTH		MPT_MAX_REQ_DEPTH
-#define  MPT_REPLY_DEPTH		128
+#define  MPT_DEFAULT_REPLY_DEPTH	128
 #define  MPT_MIN_REPLY_DEPTH		8
 #define  MPT_MAX_REPLIES_PER_ISR	32
 
 #define  MPT_MAX_FRAME_SIZE		128
-#define  MPT_REQ_SIZE			128
-#define  MPT_REPLY_SIZE			128
+#define  MPT_DEFAULT_FRAME_SIZE		128
 
-#define  MPT_SG_BUCKETS_PER_HUNK	1
+#define  MPT_SG_REQ_128_SCALE		1
+#define  MPT_SG_REQ_96_SCALE		2
+#define  MPT_SG_REQ_64_SCALE		4
 
-#ifdef MODULE
-#define  MPT_REQ_DEPTH_RANGE_STR	__MODULE_STRING(MPT_MIN_REQ_DEPTH) "-" __MODULE_STRING(MPT_MAX_REQ_DEPTH)
-#define  MPT_REPLY_DEPTH_RANGE_STR	__MODULE_STRING(MPT_MIN_REPLY_DEPTH) "-" __MODULE_STRING(MPT_MAX_REPLY_DEPTH)
-#define  MPT_REPLY_SIZE_RANGE_STR	__MODULE_STRING(MPT_MIN_REPLY_SIZE) "-" __MODULE_STRING(MPT_MAX_FRAME_SIZE)
-#endif
+#define	 CAN_SLEEP			1
+#define  NO_SLEEP			0
+
+/* 
+ * SCSI transfer rate defines. 
+ */
+#define MPT_ULTRA320			0x08
+#define MPT_ULTRA160			0x09
+#define MPT_ULTRA2			0x0A
+#define MPT_ULTRA			0x0C
+#define MPT_FAST			0x19
+#define MPT_SCSI			0x32
+#define MPT_ASYNC			0xFF
+
+#define MPT_NARROW			0
+#define MPT_WIDE			1
+
+#ifdef __KERNEL__	/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#include <linux/proc_fs.h>
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Attempt semi-consistent error & warning msgs across
+ * MPT drivers.  NOTE: Users of these macro defs must
+ * themselves define their own MYNAM.
+ */
+#define MYIOC_s_INFO_FMT		KERN_INFO MYNAM ": %s: "
+#define MYIOC_s_NOTE_FMT		KERN_NOTICE MYNAM ": %s: "
+#define MYIOC_s_WARN_FMT		KERN_WARNING MYNAM ": %s: WARNING - "
+#define MYIOC_s_ERR_FMT			KERN_ERR MYNAM ": %s: ERROR - "
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -133,6 +174,7 @@
 	MPTSCSIH_DRIVER,	/* MPT SCSI host (initiator) class */
 	MPTLAN_DRIVER,		/* MPT LAN class */
 	MPTSTM_DRIVER,		/* MPT SCSI target mode class */
+	MPTDMP_DRIVER,		/* MPT Dynamic Multi-pathing class */
 	MPTUNKNOWN_DRIVER
 } MPT_DRIVER_CLASS;
 
@@ -145,10 +187,21 @@
 		struct _MPT_FRAME_HDR	*forw;
 		struct _MPT_FRAME_HDR	*back;
 		u32			 arg1;
+		u32			 pad;
 		void			*argp1;
+#ifndef MPT_SCSI_USE_NEW_EH
+		void			*argp2;
+#endif
 	} linkage;
 	/*
-	 * NOTE: On non-32-bit systems, where pointers are LARGE,
+	 * NOTE: When request frames are free, on the linkage structure
+	 * contets are valid.  All other values are invalid.
+	 * In particular, do NOT reply on offset [2]
+	 * (in words) being the * message context.
+	 * The message context must be reset (computed via base address
+	 * + an offset) prior to issuing any command.
+	 *
+	 * NOTE2: On non-32-bit systems, where pointers are LARGE,
 	 * using the linkage pointers destroys our sacred MsgContext
 	 * field contents.  But we don't care anymore because these
 	 * are now reset in mpt_put_msg_frame() just prior to sending
@@ -169,6 +222,12 @@
 			} fld;
 		} msgctxu;
 	} hwhdr;
+	/*
+	 * Remark: 32 bit identifier:
+	 *  31-24: reserved
+	 *  23-16: call back index
+	 *  15-0 : request index
+	 */
 } MPT_FRAME_TRACKER;
 
 /*
@@ -189,6 +248,11 @@
 	} u;
 } MPT_FRAME_HDR;
 
+#define MPT_REQ_MSGFLAGS_DROPME		0x80
+
+/* Used for tracking the free request frames
+ * and free reply frames.
+ */
 typedef struct _MPT_Q_TRACKER {
 	MPT_FRAME_HDR	*head;
 	MPT_FRAME_HDR	*tail;
@@ -214,9 +278,20 @@
 	struct _Q_ITEM	*tail;
 } Q_TRACKER;
 
+typedef struct _MPT_DONE_Q {
+	struct _MPT_DONE_Q	*forw;
+	struct _MPT_DONE_Q	*back;
+	void			*argp;
+} MPT_DONE_Q;
+
+typedef struct _DONE_Q_TRACKER {
+	MPT_DONE_Q	*head;
+	MPT_DONE_Q	*tail;
+} DONE_Q_TRACKER;
 
 /*
- *  Chip-specific stuff...
+ *  Chip-specific stuff... FC929 delineates break between
+ *  FC and Parallel SCSI parts. Do NOT re-order.
  */
 
 typedef enum {
@@ -237,7 +312,9 @@
 	u32	WriteSequence;	/* 04     Write Sequence register    */
 	u32	Diagnostic;	/* 08     Diagnostic register        */
 	u32	TestBase;	/* 0C     Test Base Address          */
-	u32	Reserved1[8];	/* 10-2F  reserved for future use    */
+	u32	DiagRwData;	/* 10     Read Write Data (fw download)   */
+	u32	DiagRwAddress;	/* 14     Read Write Address (fw download)*/
+	u32	Reserved1[6];	/* 18-2F  reserved for future use    */
 	u32	IntStatus;	/* 30     Interrupt Status           */
 	u32	IntMask;	/* 34     Interrupt Mask             */
 	u32	Reserved2[2];	/* 38-3F  reserved for future use    */
@@ -256,60 +333,271 @@
  */
 
 
+/*
+ *	Dynamic Multi-Pathing specific stuff...
+ */
+#define DMP_MAX_PATHS	8
+
+typedef struct _PathInfo {
+	u8		 ioc;
+	u8		 target;
+	u8		 pad;
+	u8		 pflags;
+} PathInfo;
+
+#define PATHINFO_FLAGS_OWNED		0x01
+#define PATHINFO_FLAGS_EXISTS		0x02
+#define PATHINFO_FLAGS_AVAILABLE	0x04
+#define PATHINFO_FLAGS_SECONDARY	0x08
+
+#define PFLAGS_EXISTS_AND_AVAIL		(PATHINFO_FLAGS_EXISTS|PATHINFO_FLAGS_AVAILABLE)
+#define PFLAGS_AVAIL_AND_OWNED		(PATHINFO_FLAGS_AVAILABLE|PATHINFO_FLAGS_OWNED)
+
+typedef struct _ScsiCmndTracker {
+	void			*head;
+	void			*tail;
+} ScsiCmndTracker;
+
+
+/*
+ *	VirtDevice - FC LUN device or SCSI target device
+ *	(used to be FCSCSI_TARGET)
+ */
+typedef struct _VirtDevice {
+	struct _VirtDevice	*forw;
+	struct _VirtDevice	*back;
+	rwlock_t		 VdevLock;
+	int			 ref_cnt;
+	u8			 tflags;
+	u8			 ioc_id;
+	u8			 target_id;
+	u8			 bus_id;
+	u8			 minSyncFactor;	/* 0xFF is async */
+	u8			 maxOffset;	/* 0 if async */
+	u8			 maxWidth;	/* 0 if narrow, 1 if wide*/
+	u8			 negoFlags;	/* 0 if WDTR/SDTR allowed */
+	u8			 raidVolume;	/* set, if RAID Volume */
+	u8			 rsvd;		/* alignment */
+	u16			 rsvd1raid;
+	int			 npaths;
+	u16			 fc_phys_lun;
+	u16			 fc_xlat_lun;
+	int			 stall_detected;
+	PathInfo		 path[DMP_MAX_PATHS];
+	struct timer_list	 stall_timer;
+	struct timer_list	 retry_timer;
+	struct timer_list	 gone_timer;
+	ScsiCmndTracker		 WaitQ;
+	ScsiCmndTracker		 SentQ;
+	ScsiCmndTracker		 DoneQ;
+//--- LUN split here?
+	u8			 sense[SCSI_STD_SENSE_BYTES];		/* 18 */
+	u8			 rsvd2[2];	/* alignment */
+	u32			 luns;		/* Max LUNs is 32 */
+	u8			 inq_data[SCSI_STD_INQUIRY_BYTES];	/* 36 */
+	u8			 pad0[4];
+	u8			 uniq_prepad[8];
+	u8			 inq00_data[20];
+	u8			 pad1[4];
+		/* IEEE Registered Extended Identifier
+		   obtained via INQUIRY VPD page 0x83 */
+	u8			 uniq_data[20];
+	u8			 pad2[4];
+	u8			 inqC3_data[12];
+	u8			 pad3[4];
+	u8			 inqC9_data[12];
+	u8			 pad4[4];
+	u8			 dev_vol_name[64];
+} VirtDevice;
+
+/*
+ *  Fibre Channel (SCSI) target device and associated defines...
+ */
+#define MPT_TARGET_DEFAULT_DV_STATUS	0
+#define MPT_TARGET_FLAGS_VALID_NEGO	0x01
+#define MPT_TARGET_FLAGS_VALID_INQUIRY	0x02
+#define MPT_TARGET_FLAGS_VALID_SENSE	0x04
+#define MPT_TARGET_FLAGS_Q_YES		0x08
+
+#define MPT_TARGET_NO_NEGO_WIDE		0x01
+#define MPT_TARGET_NO_NEGO_SYNC		0x02
+
+typedef struct _VirtDevTracker {
+	struct _VirtDevice	*head;
+	struct _VirtDevice	*tail;
+	rwlock_t		 VlistLock;
+	int			 pad;
+} VirtDevTracker;
+
+
+/*
+ *	/proc/mpt interface
+ */
+typedef struct {
+	const char	*name;
+	mode_t		 mode;
+	int		 pad;
+	read_proc_t	*read_proc;
+	write_proc_t	*write_proc;
+} mpt_proc_entry_t;
+
+#define MPT_PROC_READ_RETURN(buf,start,offset,request,eof,len) \
+do { \
+	len -= offset;			\
+	if (len < request) {		\
+		*eof = 1;		\
+		if (len <= 0)		\
+			return 0;	\
+	} else				\
+		len = request;		\
+	*start = buf + offset;		\
+	return len;			\
+} while (0)
+
+
+/*
+ *	IOCTL structure and associated defines
+ */
+
+#define MPT_IOCTL_STATUS_DID_TIMEOUT	0x01	/* The current IOCTL timed out */
+#define MPT_IOCTL_STATUS_RF_VALID	0x02	/* The Reply Frame is VALID */
+#define MPT_IOCTL_STATUS_TIMER_ACTIVE	0x04	/* The timer is running */
+#define MPT_IOCTL_STATUS_SENSE_VALID	0x08	/* Sense data is valid */
+#define MPT_IOCTL_STATUS_COMMAND_GOOD	0x10	/* Command Status GOOD */
+
+typedef struct _MPT_IOCTL {
+	struct _MPT_ADAPTER	*ioc;
+	struct timer_list	 timer;		/* timer function for this adapter */
+	u8			 ReplyFrame[MPT_DEFAULT_FRAME_SIZE];	/* reply frame data */
+	u8			 sense[MPT_SENSE_BUFFER_ALLOC];
+	int			 wait_done;	/* wake-up value for this ioc */
+	u8			 cmd;		/* current command */
+	u8			 status;	/* current command status */
+	u8			 pad[2];
+} MPT_IOCTL;
+
+/*
+ *  Event Structure and define
+ */
+#define MPTCTL_EVENT_LOG_SIZE		(0x0000000A)
+typedef struct _mpt_ioctl_events {
+	u32	event;		/* Specified by define above */
+	u32	eventContext;	/* Index or counter */
+	int	data[2];	/* First 8 bytes of Event Data */
+} MPT_IOCTL_EVENTS;
+
+/*
+ * CONFIGPARM status  defines
+ */
+#define MPT_CONFIG_GOOD		MPI_IOCSTATUS_SUCCESS
+#define MPT_CONFIG_ERROR	0x002F
+
+/*
+ *	Substructure to store SCSI specific configuration page data
+ */
+#define MPT_SCSICFG_NEGOTIATE		0x01	/* Negotiate on next IO */
+#define MPT_SCSICFG_NEED_DV		0x02	/* Schedule DV */
+#define MPT_SCSICFG_DV_PENDING		0x04	/* DV on this physical id pending */
+#define MPT_SCSICFG_DV_DONE		0x08	/* DV on this physical id complete */
+
+#define MPT_SCSICFG_USE_NVRAM		0x01	/* WriteSDP1 using NVRAM */
+#define MPT_SCSICFG_ALL_IDS		0x02	/* WriteSDP1 to all IDS */
+
+typedef	struct _ScsiCfgData {
+	int		*nvram;			/* table of device NVRAM values */
+	IOCPage3_t	*pIocPg3;		/* table of physical disks */
+	u8		 dvStatus[MPT_MAX_SCSI_DEVICES];
+	int		 isRaid;		/* bit field, 1 if RAID */
+	u8		 minSyncFactor;		/* 0xFF if async */
+	u8		 maxSyncOffset;		/* 0 if async */
+	u8		 maxBusWidth;		/* 0 if narrow, 1 if wide */
+	u8		 busType;		/* SE, LVD, HD */
+	u8		 sdp1version;		/* SDP1 version */
+	u8		 sdp1length;		/* SDP1 length  */
+	u8		 sdp0version;		/* SDP0 version */
+	u8		 sdp0length;		/* SDP0 length  */
+	u8		 dvScheduled;		/* 1 if scheduled */
+	u8		 forceDv;		/* 1 to force DV scheduling */
+	u8		 rsvd[2];
+} ScsiCfgData;
+
+/*
+ *  Adapter Structure - pci_dev specific. Maximum: MPT_MAX_ADAPTERS
+ */
 typedef struct _MPT_ADAPTER
 {
 	struct _MPT_ADAPTER	*forw;
 	struct _MPT_ADAPTER	*back;
-	int			 id;		/* Unique adapter id {0,1,2,...} */
-	int			 pci_irq;
-	char			 name[32];	/* "iocN"             */
+	int			 id;		/* Unique adapter id N {0,1,2,...} */
+	int			 pci_irq;	/* This irq           */
+	char			 name[MPT_NAME_LENGTH];	/* "iocN"             */
 	char			*prod_name;	/* "LSIFC9x9"         */
-	u32			 mem_phys;	/* == f4020000 (mmap) */
 	volatile SYSIF_REGS	*chip;		/* == c8817000 (mmap) */
-	CHIP_TYPE		 chip_type;
-	int			 mem_size;
+	volatile SYSIF_REGS	*pio_chip;	/* Programmed IO (downloadboot) */
+	u32			 mem_phys;	/* == f4020000 (mmap) */
+	u32			 pio_mem_phys;	/* Programmed IO (downloadboot) */
+	int			 mem_size;	/* mmap memory size */
 	int			 alloc_total;
 	u32			 last_state;
 	int			 active;
-	int			 sod_reset;
-	unsigned long		 last_kickstart;
-	u8			*reply_alloc;		/* Reply frames alloc ptr */
+	u8			*reply_alloc;	/* Reply frames alloc ptr */
 	dma_addr_t		 reply_alloc_dma;
-	MPT_FRAME_HDR		*reply_frames;		/* Reply frames - rounded up! */
+	MPT_FRAME_HDR		*reply_frames;	/* Reply msg frames - rounded up! */
 	dma_addr_t		 reply_frames_dma;
-	int			 reply_depth;
-	int			 reply_sz;
+	u32			 reply_frames_low_dma;
+	int			 reply_depth;	/* Num Allocated reply frames */
+	int			 reply_sz;	/* Reply frame size */
+	CHIP_TYPE		 chip_type;
 		/* We (host driver) get to manage our own RequestQueue! */
-	u8			*req_alloc;		/* Request frames alloc ptr */
+	u8			*req_alloc;	/* Request frames alloc ptr */
 	dma_addr_t		 req_alloc_dma;
-	MPT_FRAME_HDR		*req_frames;		/* Request msg frames for PULL mode! */
+	MPT_FRAME_HDR		*req_frames;	/* Request msg frames - rounded up! */
 	dma_addr_t		 req_frames_dma;
-	int			 req_depth;
-	int			 req_sz;
-	MPT_Q_TRACKER		 FreeQ;
+	u32			 req_frames_low_dma;
+	int			 req_depth;	/* Number of request frames */
+	int			 req_sz;	/* Request frame size (bytes) */
 	spinlock_t		 FreeQlock;
+	MPT_Q_TRACKER		 FreeQ;
 		/* Pool of SCSI sense buffers for commands coming from
 		 * the SCSI mid-layer.  We have one 256 byte sense buffer
 		 * for each REQ entry.
 		 */
 	u8			*sense_buf_pool;
 	dma_addr_t		 sense_buf_pool_dma;
-	struct pci_dev		*pcidev;
-/*	atomic_t		 userCnt;	*/
-	u8			*memmap;
+	u32			 sense_buf_low_dma;
 	int			 mtrr_reg;
-	struct Scsi_Host	*sh;
+	void			*pcidev;	/* struct pci_dev pointer */
+	u8			*memmap;	/* mmap address */
+	struct Scsi_Host	*sh;		/* Scsi Host pointer */
+	ScsiCfgData		spi_data;	/* Scsi config. data */
+	MPT_IOCTL		*ioctl;		/* ioctl data pointer */
 	struct proc_dir_entry	*ioc_dentry;
-	struct _MPT_ADAPTER	*alt_ioc;
+	struct _MPT_ADAPTER	*alt_ioc;	/* ptr to 929 bound adapter port */
+	spinlock_t		 diagLock;	/* diagnostic reset lock */
+	int			 diagPending;
+	u32			 biosVersion;	/* BIOS version from IO Unit Page 2 */
+	int			 eventTypes;	/* Event logging parameters */
+	int			 eventContext;	/* Next event context */
+	int			 eventLogSize;	/* Max number of cached events */
+	struct _mpt_ioctl_events *events;	/* pointer to event log */
+	u8			*FWImage;	/* Pointer to FW */
+	dma_addr_t		 FWImage_dma;
+	Q_TRACKER		 configQ;	/* linked list of config. requests */
 	int			 hs_reply_idx;
+#ifndef MFCNT
+	u32			 pad0;
+#else
+	u32			 mfcnt;
+#endif
 	u32			 hs_req[MPT_MAX_FRAME_SIZE/sizeof(u32)];
 	u16			 hs_reply[MPT_MAX_FRAME_SIZE/sizeof(u16)];
 	IOCFactsReply_t		 facts;
 	PortFactsReply_t	 pfacts[2];
+	FCPortPage0_t		 fc_port_page0[2];
 	LANPage0_t		 lan_cnfg_page0;
 	LANPage1_t		 lan_cnfg_page1;
 	u8			 FirstWhoInit;
-	u8			 pad1[3];
+	u8			 pad1[7];
 } MPT_ADAPTER;
 
 
@@ -324,7 +612,6 @@
  *    0 = not Ok ...
  */
 typedef int (*MPT_CALLBACK)(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply);
-
 typedef int (*MPT_EVHANDLER)(MPT_ADAPTER *ioc, EventNotificationReply_t *evReply);
 typedef int (*MPT_RESETHANDLER)(MPT_ADAPTER *ioc, int reset_phase);
 /* reset_phase defs */
@@ -344,6 +631,47 @@
 #define MPT_HOSTEVENT_IOC_BRINGUP	0x91
 #define MPT_HOSTEVENT_IOC_RECOVER	0x92
 
+/* 32 vs 64 bit SGL code.
+ *
+ */
+#if defined(__ia64__)
+typedef SGESimple64_t	MptSge_t;
+typedef SGEChain64_t	MptChain_t;
+
+#define cpu_to_leXX(y, p) { \
+	u32 low = (u32) (y & 0xFFFFFFFF); \
+	u32 high = (u32) (y >> 32); \
+	p.Low = cpu_to_le32(low); \
+	p.High = cpu_to_le32(high); \
+}
+
+#define leXX_to_cpu(y, p) { \
+	y = (dma_addr_t) le32_to_cpu(p.High); \
+	y = (y << 32); \
+	y |= le32_to_cpu(p.Low); \
+}
+
+#define MPT_SGE_ADDRESS_SIZE		MPI_SGE_FLAGS_64_BIT_ADDRESSING
+#define MPT_SCSIIO_MSG_FLAGS		MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_64
+
+
+#else
+
+typedef SGESimple32_t	MptSge_t;
+typedef SGEChain32_t	MptChain_t;
+#define cpu_to_leXX(y,p) { \
+	p = cpu_to_le32(y); \
+}
+
+#define leXX_to_cpu(y,p) { \
+	y = le32_to_cpu(p); \
+}
+
+#define MPT_SGE_ADDRESS_SIZE		MPI_SGE_FLAGS_32_BIT_ADDRESSING
+#define MPT_SCSIIO_MSG_FLAGS		MPI_SCSIIO_MSGFLGS_SENSE_WIDTH_32
+
+#endif
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Funky (private) macros...
@@ -360,7 +688,8 @@
 #define dhsprintk(x)
 #endif
 
-#if defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME)
+//#if defined(MPT_DEBUG) || defined(MPT_DEBUG_MSG_FRAME)
+#if defined(MPT_DEBUG_MSG_FRAME)
 #define dmfprintk(x)  printk x
 #else
 #define dmfprintk(x)
@@ -372,24 +701,35 @@
 #define dirqprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_EVENTS
-#define deventprintk(x)  printk x
+#ifdef MPT_DEBUG_SG
+#define dsgprintk(x)  printk x
 #else
-#define deventprintk(x)
+#define dsgprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_SPINLOCK
-#define dslprintk(x)  printk x
+#ifdef MPT_DEBUG_DV
+#define ddvprintk(x)  printk x
 #else
-#define dslprintk(x)
+#define ddvprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_SG
-#define dsgprintk(x)  printk x
+#if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
+#define ddvtprintk(x)  printk x
 #else
-#define dsgprintk(x)
+#define ddvtprintk(x)
 #endif
 
+#ifdef MPT_DEBUG_IOCTL
+#define dctlprintk(x) printk x
+#else
+#define dctlprintk(x)
+#endif
+
+#ifdef MPT_DEBUG_RESET
+#define dtmprintk(x) printk x
+#else
+#define dtmprintk(x)
+#endif
 
 #define MPT_INDEX_2_MFPTR(ioc,idx) \
 	(MPT_FRAME_HDR*)( (u8*)(ioc)->req_frames + (ioc)->req_sz * (idx) )
@@ -397,6 +737,9 @@
 #define MFPTR_2_MPT_INDEX(ioc,mf) \
 	(int)( ((u8*)mf - (u8*)(ioc)->req_frames) / (ioc)->req_sz )
 
+#define MPT_INDEX_2_RFPTR(ioc,idx) \
+	(MPT_FRAME_HDR*)( (u8*)(ioc)->reply_frames + (ioc)->req_sz * (idx) )
+
 #define Q_INIT(q,type)  (q)->head = (q)->tail = (type*)(q)
 #define Q_IS_EMPTY(q)   ((Q_ITEM*)(q)->head == (Q_ITEM*)(q))
 
@@ -425,7 +768,6 @@
 	_forw->back = _back; \
 }
 
-
 #define SWAB4(value) \
 	(u32)(   (((value) & 0x000000ff) << 24) \
 	       | (((value) & 0x0000ff00) << 8)  \
@@ -457,64 +799,143 @@
 
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-#endif		/* } __KERNEL__ */
 
+/*
+ * MPT_SCSI_HOST defines - Used by the IOCTL and the SCSI drivers
+ * Private to the driver.
+ */
+/* LOCAL structure and fields used when processing
+ * internally generated commands. These include:
+ * bus scan, dv and config requests.
+ */
+typedef struct _MPT_LOCAL_REPLY {
+	ConfigPageHeader_t header;
+	int	completion;
+	u8	sense[SCSI_STD_SENSE_BYTES];
+	u8	scsiStatus;
+	u8	skip;
+	u32	pad;
+} MPT_LOCAL_REPLY;
+
+#define MPT_HOST_BUS_UNKNOWN		(0xFF)
+#define MPT_HOST_TOO_MANY_TM		(0x05)
+#define MPT_HOST_NVRAM_INVALID		(0xFFFFFFFF)
+#define MPT_HOST_NO_CHAIN		(0xFFFFFFFF)
+#define MPT_NVRAM_MASK_TIMEOUT		(0x000000FF)
+#define MPT_NVRAM_SYNC_MASK		(0x0000FF00)
+#define MPT_NVRAM_SYNC_SHIFT		(8)
+#define MPT_NVRAM_DISCONNECT_ENABLE	(0x00010000)
+#define MPT_NVRAM_ID_SCAN_ENABLE	(0x00020000)
+#define MPT_NVRAM_LUN_SCAN_ENABLE	(0x00040000)
+#define MPT_NVRAM_TAG_QUEUE_ENABLE	(0x00080000)
+#define MPT_NVRAM_WIDE_DISABLE		(0x00100000)
+#define MPT_NVRAM_BOOT_CHOICE		(0x00200000)
+
+typedef struct _MPT_SCSI_HOST {
+	MPT_ADAPTER		 *ioc;
+	int			  port;
+	u32			  pad0;
+	struct scsi_cmnd	**ScsiLookup;
+		/* Pool of buffers for chaining. ReqToChain
+		 * and ChainToChain track index of chain buffers.
+		 * ChainBuffer (DMA) virt/phys addresses.
+		 * FreeChainQ (lock) locking mechanisms.
+		 */
+	int			 *ReqToChain;
+	int			 *ChainToChain;
+	u8			 *ChainBuffer;
+	dma_addr_t		  ChainBufferDMA;
+	MPT_Q_TRACKER		  FreeChainQ;
+	spinlock_t		  FreeChainQlock;
+	u32			  qtag_tick;
+	VirtDevice		**Targets;
+	MPT_LOCAL_REPLY		 *pLocal;		/* used for internal commands */
+	struct timer_list	  timer;
+	struct timer_list	  TMtimer;		/* Timer for TM commands ONLY */
+		/* Pool of memory for holding SCpnts before doing
+		 * OS callbacks. freeQ is the free pool.
+		 */
+	u8			 *memQ;
+	DONE_Q_TRACKER		  freeQ;
+	DONE_Q_TRACKER		  doneQ;		/* Holds Linux formmatted requests */
+	DONE_Q_TRACKER		  pendingQ;		/* Holds MPI formmatted requests */
+	MPT_Q_TRACKER		  taskQ;		/* TM request Q */
+	spinlock_t		  freedoneQlock;
+	int			  taskQcnt;
+	u8			  numTMrequests;
+	u8			  tmPending;
+	u8			  resetPending;
+	u8			  is_spi;		/* Parallel SCSI i/f */
+	u8			  negoNvram;		/* DV disabled, nego NVRAM */
+	u8			  is_multipath;		/* Multi-path compatible */
+	u8			  rsvd[2];
+	MPT_FRAME_HDR		 *tmPtr;		/* Ptr to TM request*/
+	MPT_FRAME_HDR		 *cmdPtr;		/* Ptr to nonOS request */
+	struct scsi_cmnd	 *abortSCpnt;
+	MPT_LOCAL_REPLY		  localReply;		/* internal cmd reply struct */
+} MPT_SCSI_HOST;
+
+/*
+ *	Structure for overlaying onto scsi_cmnd->SCp area
+ *	NOTE: SCp area is 36 bytes min, 44 bytes max?
+ */
+typedef struct _scPrivate {
+	struct scsi_cmnd	*forw;
+	struct scsi_cmnd	*back;
+	void			*p1;
+	void			*p2;
+	u8			 io_path_id;	/* DMP */
+	u8			 pad[7];
+} scPrivate;
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	More Dynamic Multi-Pathing stuff...
+ */
+
+/* Forward decl, a strange C thing, to prevent gcc compiler warnings */
+struct scsi_cmnd;
 
 /*
- *  MPT Control IOCTLs and structures
+ *	DMP service layer structure / API interface
  */
-#define MPT_MAGIC_NUMBER	'm'
-#define MPTRWPERF		_IOWR(MPT_MAGIC_NUMBER,0,struct mpt_raw_r_w)
-#define MPTRWPERF_CHK		_IOR(MPT_MAGIC_NUMBER,13,struct mpt_raw_r_w)
-#define MPTRWPERF_RESET		_IOR(MPT_MAGIC_NUMBER,14,struct mpt_raw_r_w)
-#define MPTFWDOWNLOAD		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer)
-#define MPTSCSICMD		_IOWR(MPT_MAGIC_NUMBER,16,struct mpt_scsi_cmd)
-
-/*
- *  Define something *vague* enough that caller doesn't
- *  really need to know anything about device parameters
- *  (blk_size, capacity, etc.)
- */
-struct mpt_raw_r_w {
-	unsigned int	 iocnum;	/* IOC unit number */
-	unsigned int	 port;		/* IOC port number */
-	unsigned int	 target;	/* SCSI Target */
-	unsigned int	 lun;		/* SCSI LUN */
-	unsigned int	 iters;		/* N iterations */
-	unsigned short	 nblks;		/* number of blocks per IO */
-	unsigned short	 qdepth;	/* max Q depth on this device */
-	unsigned char	 range;		/* 0-100% of FULL disk capacity, 0=use (nblks X iters) */
-	unsigned char	 skip;		/* % of disk to skip */
-	unsigned char	 rdwr;		/* 0-100%, 0=pure ReaDs, 100=pure WRites */
-	unsigned char	 seqran;	/* 0-100%, 0=pure SEQential, 100=pure RANdom */
-	unsigned int	 cache_sz;	/* In Kb!  Optimize hits to N Kb cache size */
-};
-
-struct mpt_fw_xfer {
-	unsigned int	 iocnum;	/* IOC unit number */
-/*	u8		 flags;*/	/* Message flags - bit field */
-	unsigned int	 fwlen;
-	void		*bufp;		/* Pointer to firmware buffer */
-};
-
-struct mpt_scsi_cmd {
-	unsigned int	 iocnum;	/* IOC unit number */
-	unsigned int	 port;		/* IOC port number */
-	unsigned int	 target;	/* SCSI Target */
-	unsigned int	 lun;		/* SCSI LUN */
-	SCSIIORequest_t	 scsi_req;
-	SCSIIOReply_t	 scsi_reply;
-};
-
-struct mpt_ioctl_sanity {
-	unsigned int	 iocnum;
-};
+typedef struct _DmpServices {
+	VirtDevTracker	  VdevList;
+	struct semaphore *Daemon;
+	int		(*ScsiPathSelect)
+				(struct scsi_cmnd *, MPT_SCSI_HOST **hd, int *target, int *lun);
+	int		(*DmpIoDoneChk)
+				(MPT_SCSI_HOST *, struct scsi_cmnd *,
+				 SCSIIORequest_t *,
+				 SCSIIOReply_t *);
+	void		(*mptscsih_scanVlist)
+				(MPT_SCSI_HOST *, int portnum);
+	int		(*ScsiAbort)
+				(struct scsi_cmnd *);
+	int		(*ScsiBusReset)
+				(struct scsi_cmnd *);
+} DmpServices_t;
 
-#ifdef __KERNEL__	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Generic structure passed to the base mpt_config function.
+ */
+typedef struct _x_config_parms {
+	Q_ITEM			 linkage;	/* linked list */
+	struct timer_list	 timer;		/* timer function for this request  */
+	ConfigPageHeader_t	*hdr;
+	dma_addr_t		 physAddr;
+	int			 wait_done;	/* wait for this request */
+	u32			 pageAddr;	/* properly formatted */
+	u8			 action;
+	u8			 dir;
+	u8			 timeout;	/* seconds */
+	u8			 pad1;
+	u16			 status;
+	u16			 pad2;
+} CONFIGPARMS;
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  Public entry points...
  */
@@ -524,21 +945,28 @@
 extern void	 mpt_event_deregister(int cb_idx);
 extern int	 mpt_reset_register(int cb_idx, MPT_RESETHANDLER reset_func);
 extern void	 mpt_reset_deregister(int cb_idx);
-extern int	 mpt_register_ascqops_strings(/*ASCQ_Table_t*/void *ascqTable, int ascqtbl_sz, const char **opsTable);
+extern int	 mpt_register_ascqops_strings(void *ascqTable, int ascqtbl_sz, const char **opsTable);
 extern void	 mpt_deregister_ascqops_strings(void);
 extern MPT_FRAME_HDR	*mpt_get_msg_frame(int handle, int iocid);
 extern void	 mpt_free_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf);
 extern void	 mpt_put_msg_frame(int handle, int iocid, MPT_FRAME_HDR *mf);
-extern int	 mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req);
+extern int	 mpt_send_handshake_request(int handle, int iocid, int reqBytes, u32 *req, int sleepFlag);
+extern int	 mpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req, int replyBytes, u16 *u16reply, int maxwait, int sleepFlag);
 extern int	 mpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp);
 extern MPT_ADAPTER	*mpt_adapter_find_first(void);
 extern MPT_ADAPTER	*mpt_adapter_find_next(MPT_ADAPTER *prev);
+extern u32	 mpt_GetIocState(MPT_ADAPTER *ioc, int cooked);
 extern void	 mpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buf, int *size, int len, int showlan);
-extern void	 mpt_print_ioc_facts(MPT_ADAPTER *ioc, char *buf, int *size, int len);
+extern int	 mpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag);
+extern int	 mpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *cfg);
 
 /*
  *  Public data decl's...
  */
+extern MPT_ADAPTER	 	*mpt_adapters[MPT_MAX_ADAPTERS];
+extern struct proc_dir_entry	*mpt_proc_root_dir;
+extern DmpServices_t		*DmpService;
+
 extern int		  mpt_lan_index;	/* needed by mptlan.c */
 extern int		  mpt_stm_index;	/* needed by mptstm.c */
 
@@ -563,7 +991,7 @@
 #define offsetof(t, m)	((size_t) (&((t *)0)->m))
 #endif
 
-#if defined(__alpha__) || defined(__sparc_v9__)
+#if defined(__alpha__) || defined(__sparc_v9__) || defined(__ia64__)
 #define CAST_U32_TO_PTR(x)	((void *)(u64)x)
 #define CAST_PTR_TO_U32(x)	((u32)(u64)x)
 #else
@@ -576,6 +1004,40 @@
 	((pflags) & MPI_PORTFACTS_PROTOCOL_TARGET)	? 'T' : 't',	\
 	((pflags) & MPI_PORTFACTS_PROTOCOL_LAN)		? 'L' : 'l',	\
 	((pflags) & MPI_PORTFACTS_PROTOCOL_LOGBUSADDR)	? 'B' : 'b'
+
+/*
+ *  Shifted SGE Defines - Use in SGE with FlagsLength member.
+ *  Otherwise, use MPI_xxx defines (refer to "lsi/mpi.h" header).
+ *  Defaults: 32 bit SGE, SYSTEM_ADDRESS if direction bit is 0, read
+ */
+#define MPT_TRANSFER_IOC_TO_HOST		(0x00000000)
+#define MPT_TRANSFER_HOST_TO_IOC		(0x04000000)
+#define MPT_SGE_FLAGS_LAST_ELEMENT		(0x80000000)
+#define MPT_SGE_FLAGS_END_OF_BUFFER		(0x40000000)
+#define MPT_SGE_FLAGS_LOCAL_ADDRESS		(0x08000000)
+#define MPT_SGE_FLAGS_DIRECTION			(0x04000000)
+#define MPT_SGE_FLAGS_ADDRESSING		(MPT_SGE_ADDRESS_SIZE << MPI_SGE_FLAGS_SHIFT)
+#define MPT_SGE_FLAGS_END_OF_LIST		(0x01000000)
+
+#define MPT_SGE_FLAGS_TRANSACTION_ELEMENT	(0x00000000)
+#define MPT_SGE_FLAGS_SIMPLE_ELEMENT		(0x10000000)
+#define MPT_SGE_FLAGS_CHAIN_ELEMENT		(0x30000000)
+#define MPT_SGE_FLAGS_ELEMENT_MASK		(0x30000000)
+
+#define MPT_SGE_FLAGS_SSIMPLE_READ \
+	(MPT_SGE_FLAGS_LAST_ELEMENT |	\
+	 MPT_SGE_FLAGS_END_OF_BUFFER |	\
+	 MPT_SGE_FLAGS_END_OF_LIST |	\
+	 MPT_SGE_FLAGS_SIMPLE_ELEMENT |	\
+	 MPT_SGE_FLAGS_ADDRESSING |	\
+	 MPT_TRANSFER_IOC_TO_HOST)
+#define MPT_SGE_FLAGS_SSIMPLE_WRITE \
+	(MPT_SGE_FLAGS_LAST_ELEMENT |	\
+	 MPT_SGE_FLAGS_END_OF_BUFFER |	\
+	 MPT_SGE_FLAGS_END_OF_LIST |	\
+	 MPT_SGE_FLAGS_SIMPLE_ELEMENT |	\
+	 MPT_SGE_FLAGS_ADDRESSING |	\
+	 MPT_TRANSFER_HOST_TO_IOC)
 
 /*}-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptctl.c linux/drivers/message/fusion/mptctl.c
--- ../ia64/linux/drivers/message/fusion/mptctl.c	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/mptctl.c	Tue Mar 19 16:05:36 2002
@@ -9,6 +9,12 @@
  *      This driver would not exist if not for Alan Cox's development
  *      of the linux i2o driver.
  *
+ *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
+ *      and countless enhancements while adding support for the 1030
+ *      chip family.  Pam has been instrumental in the development of
+ *      of the 2.xx.xx series fusion drivers, and her contributions are
+ *      far too numerous to hope to list in one place.
+ *
  *      A huge debt of gratitude is owed to David S. Miller (DaveM)
  *      for fixing much of the stupid and broken stuff in the early
  *      driver while porting to sparc64 platform.  THANK YOU!
@@ -18,16 +24,17 @@
  *      (plus Eddie's other helpful hints and insights)
  *
  *      Thanks to Arnaldo Carvalho de Melo for finding and patching
- *      a potential memory leak in mpt_ioctl_do_fw_download(),
+ *      a potential memory leak in mptctl_do_fw_download(),
  *      and for some kmalloc insight:-)
  *
  *      (see also mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston, Noah Romer
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptctl.c,v 1.25.4.1 2001/08/24 20:07:06 sralston Exp $
+ *  $Id: mptctl.c,v 1.52 2002/02/27 18:44:24 sralston Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -79,11 +86,16 @@
 #include <asm/io.h>
 #include <asm/uaccess.h>
 
-#include <linux/proc_fs.h>
+#include <linux/kdev_t.h>	/* needed for access to Scsi_Host struct */
+#include <linux/blkdev.h>
+#include <linux/blk.h>          /* for io_request_lock (spinlock) decl */
+#include "../../scsi/scsi.h"
+#include "../../scsi/hosts.h"
 
 #define COPYRIGHT	"Copyright (c) 1999-2001 LSI Logic Corporation"
-#define MODULEAUTHOR	"Steven J. Ralston, Noah Romer"
+#define MODULEAUTHOR	"Steven J. Ralston, Noah Romer, Pamela Delaney"
 #include "mptbase.h"
+#include "mptctl.h"
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #define my_NAME		"Fusion MPT misc device (ioctl) driver"
@@ -95,21 +107,59 @@
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 static int mptctl_id = -1;
-static int rwperf_reset = 0;
 static struct semaphore mptctl_syscall_sem_ioc[MPT_MAX_ADAPTERS];
 
+static DECLARE_WAIT_QUEUE_HEAD ( mptctl_wait );
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
-static int mpt_ioctl_rwperf(unsigned long arg);
-static int mpt_ioctl_rwperf_status(unsigned long arg);
-static int mpt_ioctl_rwperf_reset(unsigned long arg);
-static int mpt_ioctl_fw_download(unsigned long arg);
-static int mpt_ioctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen);
-static int mpt_ioctl_scsi_cmd(unsigned long arg);
+struct buflist {
+	u8	*kptr;
+	int	 len;
+};
+
+/*
+ * Function prototypes. Called from OS entry point mptctl_ioctl.
+ * arg contents specific to function.
+ */
+static int mptctl_fw_download(unsigned long arg);
+static int mptctl_getiocinfo (unsigned long arg);
+static int mptctl_gettargetinfo (unsigned long arg);
+static int mptctl_readtest (unsigned long arg);
+static int mptctl_mpt_command (unsigned long arg);
+static int mptctl_eventquery (unsigned long arg);
+static int mptctl_eventenable (unsigned long arg);
+static int mptctl_eventreport (unsigned long arg);
+static int mptctl_replace_fw (unsigned long arg);
+
+static int mptctl_do_reset(unsigned long arg);
+
+static int mptctl_compaq_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+static int mptctl_cpq_getpciinfo(unsigned long arg);
+static int mptctl_cpq_getdriver(unsigned long arg);
+static int mptctl_cpq_ctlr_status(unsigned long arg);
+static int mptctl_cpq_target_address(unsigned long arg);
+static int mptctl_cpq_passthru(unsigned long arg);
+static int mptctl_compaq_scsiio(VENDOR_IOCTL_REQ *pVenReq, cpqfc_passthru_t *pPass);
+
+/*
+ * Private function calls.
+ */
+static int mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr, int local);
+static int mptctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen);
+static MptSge_t *kbuf_alloc_2_sgl( int bytes, u32 dir, int sge_offset, int *frags,
+		struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);
+static void kfree_sgl( MptSge_t *sgl, dma_addr_t sgl_dma,
+		struct buflist *buflist, MPT_ADAPTER *ioc);
+static void mptctl_timer_expired (unsigned long data);
+
+/*
+ * Reset Handler cleanup function
+ */
+static int  mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -132,26 +182,27 @@
 /* linux only seems to ever give 128kB MAX contiguous (GFP_USER) mem bytes */
 #define MAX_KMALLOC_SZ		(128*1024)
 
-struct buflist {
-	u8	*kptr;
-	int	 len;
-};
-
-#define myMAX_TARGETS	(1<<4)
-#define myMAX_LUNS	(1<<3)
-#define myMAX_T_MASK	(myMAX_TARGETS-1)
-#define myMAX_L_MASK	(myMAX_LUNS-1)
-static u8  DevInUse[myMAX_TARGETS][myMAX_LUNS] = {{0,0}};
-static u32 DevIosCount[myMAX_TARGETS][myMAX_LUNS] = {{0,0}};
+#define MPT_IOCTL_DEFAULT_TIMEOUT 10	/* Default timeout value (seconds) */
 
 static u32 fwReplyBuffer[16];
 static pMPIDefaultReply_t ReplyMsg = NULL;
 
-/* some private forw protos */
-static SGESimple32_t *kbuf_alloc_2_sgl( int bytes, u32 dir, int *frags,
-		struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc);
-static void kfree_sgl( SGESimple32_t *sgl, dma_addr_t sgl_dma,
-		struct buflist *buflist, MPT_ADAPTER *ioc);
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	Function to return 0 if the sge Address member is 0 and
+ *	non-zero else.  Used in the mpt_do_fw_download routines.
+ */
+static inline int
+mptctl_test_address(MptSge_t *sge)
+{
+#ifdef __ia64__
+	if ((sge->Address.Low) || (sge->Address.High))
+		return 1;
+	else
+		return 0;
+#else
+	return sge->Address;
+#endif
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
@@ -159,7 +210,7 @@
  *	@ioc: Pointer to MPT adapter
  *	@nonblock: boolean, non-zero if O_NONBLOCK is set
  *
- *	All of the mptctl commands can potentially sleep, which is illegal
+ *	All of the ioctl commands can potentially sleep, which is illegal
  *	with a spinlock held, thus we perform mutual exclusion here.
  *
  *	Returns negative errno on error, or zero for success.
@@ -167,16 +218,27 @@
 static inline int
 mptctl_syscall_down(MPT_ADAPTER *ioc, int nonblock)
 {
-	dprintk((KERN_INFO MYNAM "::mpt_syscall_down(%p,%d) called\n", ioc, nonblock));
+	int rc = 0;
+	dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down(%p,%d) called\n", ioc, nonblock));
 
+#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+	if (!nonblock) {
+		if (down_interruptible(&mptctl_syscall_sem_ioc[ioc->id]))
+			rc = -ERESTARTSYS;
+	} else {
+		rc = -EPERM;
+	}
+#else
 	if (nonblock) {
 		if (down_trylock(&mptctl_syscall_sem_ioc[ioc->id]))
-			return -EAGAIN;
+			rc = -EAGAIN;
 	} else {
 		if (down_interruptible(&mptctl_syscall_sem_ioc[ioc->id]))
-			return -ERESTARTSYS;
+			rc = -ERESTARTSYS;
 	}
-	return 0;
+#endif
+	dctlprintk((KERN_INFO MYNAM "::mptctl_syscall_down return %d\n", rc));
+	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -189,18 +251,150 @@
 static int
 mptctl_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)
 {
-	u8 targ;
+	char *sense_data;
+	int sz, req_index;
+	u16 iocStatus;
+	u8 cmd;
+
+	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_reply()!\n", ioc->name));
+	if (req)
+		 cmd = req->u.hdr.Function;
+	else
+		return 1;
+
+	if (ioc->ioctl) {
+		/* If timer is not running, then an error occurred.
+		 * A timeout will call the reset routine to reload the messaging
+		 * queues.
+		 * Main callback will free message and reply frames.
+		 */
+		if (ioc->ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE) {
+			/* Delete this timer
+			 */
+			del_timer (&ioc->ioctl->timer);
+			ioc->ioctl->status &= ~MPT_IOCTL_STATUS_TIMER_ACTIVE;
+
+			/* Set the overall status byte.  Good if:
+			 * IOC status is good OR if no reply and a SCSI IO request
+			 */
+			if (reply) {
+				/* Copy the reply frame (which much exist
+				 * for non-SCSI I/O) to the IOC structure.
+				 */
+				dctlprintk((MYIOC_s_INFO_FMT ": Copying Reply Frame @%p to IOC!\n",
+						ioc->name, reply));
+				memcpy(ioc->ioctl->ReplyFrame, reply,
+					MIN(ioc->reply_sz, 4*reply->u.reply.MsgLength));
+				ioc->ioctl->status |= MPT_IOCTL_STATUS_RF_VALID;
+
+				/* Set the command status to GOOD if IOC Status is GOOD
+				 * OR if SCSI I/O cmd and data underrun or recovered error.
+				 */
+				iocStatus = reply->u.reply.IOCStatus & MPI_IOCSTATUS_MASK;
+				if (iocStatus  == MPI_IOCSTATUS_SUCCESS)
+					ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+
+				if ((iocStatus  == MPI_IOCSTATUS_SCSI_DATA_UNDERRUN) || 
+						(iocStatus  == MPI_IOCSTATUS_SCSI_RECOVERED_ERROR)) {
+					if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||
+						(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
+						ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+					}
+				}
+
+				/* Copy the sense data - if present
+				 */
+				if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) &&
+					(reply->u.sreply.SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID)){
+
+					sz = req->u.scsireq.SenseBufferLength;
+					req_index = le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);
+					sense_data = ((u8 *)ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));
+					memcpy(ioc->ioctl->sense, sense_data, sz);
+					ioc->ioctl->status |= MPT_IOCTL_STATUS_SENSE_VALID;
+				}
+			} else if ((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||
+					(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {
+				ioc->ioctl->status |= MPT_IOCTL_STATUS_COMMAND_GOOD;
+			}
+
+			/* We are done, issue wake up
+			 */
+			ioc->ioctl->wait_done = 1;
+			wake_up (&mptctl_wait);
+		} else if (reply && cmd == MPI_FUNCTION_FW_DOWNLOAD) {
+			/* Two paths to FW DOWNLOAD! */
+			// NOTE: Expects/requires non-Turbo reply!
+			dctlprintk((MYIOC_s_INFO_FMT ":Caching MPI_FUNCTION_FW_DOWNLOAD reply!\n",
+				ioc->name));
+			memcpy(fwReplyBuffer, reply, MIN(sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
+			ReplyMsg = (pMPIDefaultReply_t) fwReplyBuffer;
+		}
+	}
+	return 1;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_timer_expired
+ *
+ * Call back for timer process. Used only for ioctl functionality.
+ *
+ */
+static void mptctl_timer_expired (unsigned long data)
+{
+	MPT_IOCTL *ioctl = (MPT_IOCTL *) data;
+
+	dctlprintk((KERN_NOTICE MYNAM ": Timer Expired! Host %d\n",
+				ioctl->ioc->id));
 
-	//dprintk((KERN_DEBUG MYNAM ": Got mptctl_reply()!\n"));
+	/* Issue a reset for this device.
+	 * The IOC is not responding.
+	 */
+	mpt_HardResetHandler(ioctl->ioc, NO_SLEEP);
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_ioc_reset
+ *
+ * Clean-up functionality. Used only if there has been a
+ * reload of the FW due.
+ *
+ */
+static int
+mptctl_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
+{
+	MPT_IOCTL *ioctl = ioc->ioctl;
+	dctlprintk((KERN_INFO MYNAM ": IOC %s_reset routed to IOCTL driver!\n",
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+
+	if (reset_phase == MPT_IOC_PRE_RESET){
+
+		/* Someone has called the reset handler to
+		 * do a hard reset. No more replies from the FW.
+		 * Delete the timer.
+		 */
+		if (ioctl && (ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE)){
+
+			/* Delete this timer
+			 */
+			del_timer(&ioctl->timer);
+		}
 
-	if (req && req->u.hdr.Function == MPI_FUNCTION_SCSI_IO_REQUEST) {
-		targ = req->u.scsireq.TargetID & myMAX_T_MASK;
-		DevIosCount[targ][0]--;
-	} else if (reply && req && req->u.hdr.Function == MPI_FUNCTION_FW_DOWNLOAD) {
-		// NOTE: Expects/requires non-Turbo reply!
-		dprintk((KERN_INFO MYNAM ": Caching MPI_FUNCTION_FW_DOWNLOAD reply!\n"));
-		memcpy(fwReplyBuffer, reply, MIN(sizeof(fwReplyBuffer), 4*reply->u.reply.MsgLength));
-		ReplyMsg = (pMPIDefaultReply_t) fwReplyBuffer;
+	} else {
+		/* Set the status and continue IOCTL
+		 * processing. All memory will be free'd
+		 * by originating thread after wake_up is
+		 * called.
+		 */
+		if (ioctl && (ioctl->status & MPT_IOCTL_STATUS_TIMER_ACTIVE)){
+			ioctl->status = MPT_IOCTL_STATUS_DID_TIMEOUT;
+
+			/* Wake up the calling process
+			 */
+			ioctl->wait_done = 1;
+			wake_up(&mptctl_wait);
+		}
 	}
 
 	return 1;
@@ -208,7 +402,7 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *  struct file_operations functionality. 
+ *  struct file_operations functionality.
  *  Members:
  *	llseek, write, read, ioctl, open, release
  */
@@ -234,63 +428,93 @@
 static ssize_t
 mptctl_read(struct file *file, char *buf, size_t count, loff_t *ptr)
 {
+	printk(KERN_ERR MYNAM ": ioctl READ not yet supported\n");
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *  MPT ioctl handler
+ *  cmd - specify the particular IOCTL command to be issued
+ *  arg - data specific to the command. Must not be null.
  */
 static int
-mpt_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+mptctl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct mpt_ioctl_sanity	*usanity = (struct mpt_ioctl_sanity *) arg;
-	struct mpt_ioctl_sanity	 ksanity;
+	mpt_ioctl_header	*uhdr = (mpt_ioctl_header *) arg;
+	mpt_ioctl_header	 khdr;
 	int iocnum;
 	unsigned iocnumX;
 	int nonblock = (file->f_flags & O_NONBLOCK);
 	int ret;
 	MPT_ADAPTER *iocp = NULL;
 
-	dprintk((KERN_INFO MYNAM "::mpt_ioctl() called\n"));
+	dctlprintk(("mptctl_ioctl() called\n"));
 
-	if (copy_from_user(&ksanity, usanity, sizeof(ksanity))) {
-		printk(KERN_ERR "%s::mpt_ioctl() @%d - "
-				"Unable to copy mpt_ioctl_sanity data @ %p\n",
-				__FILE__, __LINE__, (void*)usanity);
+	if (copy_from_user(&khdr, uhdr, sizeof(khdr))) {
+		printk(KERN_ERR "%s::mptctl_ioctl() @%d - "
+				"Unable to copy mpt_ioctl_header data @ %p\n",
+				__FILE__, __LINE__, (void*)uhdr);
 		return -EFAULT;
 	}
 	ret = -ENXIO;				/* (-6) No such device or address */
 
-	/* Verify intended MPT adapter */
-	iocnumX = ksanity.iocnum & 0xFF;
+	/* Test for Compaq-specific IOCTL's.
+	 */
+	if ((cmd == CPQFCTS_GETPCIINFO) || (cmd == CPQFCTS_CTLR_STATUS) ||
+		(cmd == CPQFCTS_GETDRIVER) || (cmd == CPQFCTS_SCSI_PASSTHRU) ||
+		(cmd == CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS))
+		return mptctl_compaq_ioctl(file, cmd, arg);
+
+	/* Verify intended MPT adapter - set iocnum and the adapter
+	 * pointer (iocp)
+	 */
+	iocnumX = khdr.iocnum & 0xFF;
 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
 	    (iocp == NULL)) {
-		printk(KERN_ERR "%s::mpt_ioctl() @%d - ioc%d not found!\n",
+		printk(KERN_ERR "%s::mptctl_ioctl() @%d - ioc%d not found!\n",
 				__FILE__, __LINE__, iocnumX);
 		return -ENODEV;
 	}
 
+	/* Handle those commands that are just returning
+	 * information stored in the driver.
+	 * These commands should never time out and are unaffected
+	 * by TM and FW reloads.
+	 */
+	if (cmd == MPTIOCINFO) {
+		return mptctl_getiocinfo(arg);
+	} else if (cmd == MPTTARGETINFO) {
+		return mptctl_gettargetinfo(arg);
+	} else if (cmd == MPTTEST) {
+		return mptctl_readtest(arg);
+	} else if (cmd == MPTEVENTQUERY) {
+		return mptctl_eventquery(arg);
+	} else if (cmd == MPTEVENTENABLE) {
+		return mptctl_eventenable(arg);
+	} else if (cmd == MPTEVENTREPORT) {
+		return mptctl_eventreport(arg);
+	} else if (cmd == MPTFWREPLACE) {
+		return mptctl_replace_fw(arg);
+	}
+
+	/* All of these commands require an interrupt or
+	 * are unknown/illegal.
+	 */
 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
 		return ret;
 
-	dprintk((KERN_INFO MYNAM "::mpt_ioctl() - Using %s\n", iocp->name));
+	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_ioctl()\n", iocp->name));
 
 	switch(cmd) {
-	case MPTRWPERF:
-		ret = mpt_ioctl_rwperf(arg);
-		break;
-	case MPTRWPERF_CHK:
-		ret = mpt_ioctl_rwperf_status(arg);
-		break;
-	case MPTRWPERF_RESET:
-		ret = mpt_ioctl_rwperf_reset(arg);
-		break;
 	case MPTFWDOWNLOAD:
-		ret = mpt_ioctl_fw_download(arg);
+		ret = mptctl_fw_download(arg);
+		break;
+	case MPTCOMMAND:
+		ret = mptctl_mpt_command(arg);
 		break;
-	case MPTSCSICMD:
-		ret = mpt_ioctl_scsi_cmd(arg);
+	case MPTHARDRESET:
+		ret = mptctl_do_reset(arg);
 		break;
 	default:
 		ret = -EINVAL;
@@ -301,6 +525,36 @@
 	return ret;
 }
 
+static int mptctl_do_reset(unsigned long arg)
+{
+	struct mpt_ioctl_diag_reset *urinfo = (struct mpt_ioctl_diag_reset *) arg;
+	struct mpt_ioctl_diag_reset krinfo;
+	MPT_ADAPTER		*iocp;
+
+	dctlprintk((KERN_INFO "mptctl_do_reset called.\n"));
+
+	if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {
+		printk(KERN_ERR "%s@%d::mptctl_do_reset - "
+				"Unable to copy mpt_ioctl_diag_reset struct @ %p\n",
+				__FILE__, __LINE__, (void*)urinfo);
+		return -EFAULT;
+	}
+
+	if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
+		printk(KERN_ERR "%s@%d::mptctl_do_reset - ioc%d not found!\n",
+				__FILE__, __LINE__, krinfo.hdr.iocnum);
+		return -ENXIO; /* (-6) No such device or address */
+	}
+
+	if (mpt_HardResetHandler(iocp, NO_SLEEP) != 0) {
+		printk (KERN_ERR "%s@%d::mptctl_do_reset - reset failed.\n",
+			__FILE__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static int mptctl_open(struct inode *inode, struct file *file)
 {
@@ -317,13 +571,29 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * MPT FW download function.  Cast the arg into the mpt_fw_xfer structure.
+ * This structure contains: iocnum, firmware length (bytes),
+ *      pointer to user space memory where the fw image is stored.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENXIO  if no such device
+ *		-EAGAIN if resource problem
+ *		-ENOMEM if no memory for SGE
+ *		-EMLINK if too many chain buffers required
+ *		-EBADRQC if adapter does not support FW download
+ *		-EBUSY if adapter is busy
+ *		-ENOMSG if FW upload returned bad status
+ */
 static int
-mpt_ioctl_fw_download(unsigned long arg)
+mptctl_fw_download(unsigned long arg)
 {
 	struct mpt_fw_xfer	*ufwdl = (struct mpt_fw_xfer *) arg;
 	struct mpt_fw_xfer	 kfwdl;
 
-	dprintk((KERN_INFO "mpt_ioctl_fwdl called. mptctl_id = %xh\n", mptctl_id)); //tc
+	dctlprintk((KERN_INFO "mptctl_fwdl called. mptctl_id = %xh\n", mptctl_id)); //tc
 	if (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {
 		printk(KERN_ERR "%s@%d::_ioctl_fwdl - "
 				"Unable to copy mpt_fw_xfer struct @ %p\n",
@@ -331,44 +601,52 @@
 		return -EFAULT;
 	}
 
-	return mpt_ioctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);
+	return mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- * MPT FW Download
+ * FW Download engine.
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENXIO  if no such device
+ *		-EAGAIN if resource problem
+ *		-ENOMEM if no memory for SGE
+ *		-EMLINK if too many chain buffers required
+ *		-EBADRQC if adapter does not support FW download
+ *		-EBUSY if adapter is busy
+ *		-ENOMSG if FW upload returned bad status
  */
 static int
-mpt_ioctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen)
+mptctl_do_fw_download(int ioc, char *ufwbuf, size_t fwlen)
 {
 	FWDownload_t		*dlmsg;
 	MPT_FRAME_HDR		*mf;
 	MPT_ADAPTER		*iocp;
-//	char			*fwbuf;
-//	dma_addr_t		 fwbuf_dma;
-	FWDownloadTCSGE_t	*fwVoodoo;
-//	SGEAllUnion_t		*fwSgl;
+	FWDownloadTCSGE_t	*ptsge;
+	MptSge_t		*sgl;
+	MptSge_t		*sgOut, *sgIn;
+	struct buflist		*buflist;
+	struct buflist		*bl;
+	dma_addr_t		 sgl_dma;
 	int			 ret;
-
-	SGESimple32_t	*sgl;
-	SGESimple32_t	*sgOut, *sgIn;
-	dma_addr_t	 sgl_dma;
-	struct buflist	*buflist = NULL;
-	struct buflist	*bl = NULL;
-	int		 numfrags = 0;
-	int		 maxfrags;
-	int		 n = 0;
-	u32		 sgdir;
-	u32		 nib;
-	int		 fw_bytes_copied = 0;
-	u16		 iocstat;
-	int		 i;
-
-	dprintk((KERN_INFO "mpt_ioctl_do_fwdl called. mptctl_id = %xh.\n", mptctl_id));
-
-	dprintk((KERN_INFO "DbG: kfwdl.bufp  = %p\n", ufwbuf));
-	dprintk((KERN_INFO "DbG: kfwdl.fwlen = %d\n", (int)fwlen));
-	dprintk((KERN_INFO "DbG: kfwdl.ioc   = %04xh\n", ioc));
+	int			 numfrags = 0;
+	int			 maxfrags;
+	int			 n = 0;
+	u32			 sgdir;
+	u32			 nib;
+	int			 fw_bytes_copied = 0;
+	int			 i;
+	int			 cntdn;
+	int			 sge_offset = 0;
+	u16			 iocstat;
+
+	dctlprintk((KERN_INFO "mptctl_do_fwdl called. mptctl_id = %xh.\n", mptctl_id));
+
+	dctlprintk((KERN_INFO "DbG: kfwdl.bufp  = %p\n", ufwbuf));
+	dctlprintk((KERN_INFO "DbG: kfwdl.fwlen = %d\n", (int)fwlen));
+	dctlprintk((KERN_INFO "DbG: kfwdl.ioc   = %04xh\n", ioc));
 
 	if ((ioc = mpt_verify_adapter(ioc, &iocp)) < 0) {
 		printk("%s@%d::_ioctl_fwdl - ioc%d not found!\n",
@@ -376,11 +654,13 @@
 		return -ENXIO; /* (-6) No such device or address */
 	}
 
+	/*  Valid device. Get a message frame and construct the FW download message.
+	 */
 	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
 		return -EAGAIN;
 	dlmsg = (FWDownload_t*) mf;
-	fwVoodoo = (FWDownloadTCSGE_t *) &dlmsg->SGL;
-	sgOut = (SGESimple32_t *) (fwVoodoo + 1);
+	ptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;
+	sgOut = (MptSge_t *) (ptsge + 1);
 
 	/*
 	 * Construct f/w download request
@@ -392,27 +672,36 @@
 	dlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;
 	dlmsg->MsgFlags = 0;
 
-	fwVoodoo->Reserved = 0;
-	fwVoodoo->ContextSize = 0;
-	fwVoodoo->DetailsLength = 12;
-	fwVoodoo->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
-	fwVoodoo->Reserved1 = 0;
-	fwVoodoo->ImageOffset = 0;
-	fwVoodoo->ImageSize = cpu_to_le32(fwlen);
+	/* Set up the Transaction SGE.
+	 */
+	ptsge->Reserved = 0;
+	ptsge->ContextSize = 0;
+	ptsge->DetailsLength = 12;
+	ptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
+	ptsge->Reserved_0100_Checksum = 0;
+	ptsge->ImageOffset = 0;
+	ptsge->ImageSize = cpu_to_le32(fwlen);
+
+	/* Add the SGL
+	 */
 
 	/*
 	 * Need to kmalloc area(s) for holding firmware image bytes.
 	 * But we need to do it piece meal, using a proper
 	 * scatter gather list (with 128kB MAX hunks).
-	 * 
+	 *
 	 * A practical limit here might be # of sg hunks that fit into
 	 * a single IOC request frame; 12 or 8 (see below), so:
 	 * For FC9xx: 12 x 128kB == 1.5 mB (max)
 	 * For C1030:  8 x 128kB == 1   mB (max)
 	 * We could support chaining, but things get ugly(ier:)
+	 *
+	 * Set the sge_offset to the start of the sgl (bytes).
 	 */
 	sgdir = 0x04000000;		/* IOC will READ from sys mem */
-	if ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
+	sge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);
+	if ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,
+				    &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
 		return -ENOMEM;
 
 	/*
@@ -420,16 +709,19 @@
 	 * for FC9xx f/w image, but calculate max number of sge hunks
 	 * we can fit into a request frame, and limit ourselves to that.
 	 * (currently no chain support)
-	 * For FC9xx: (128-12-16)/8 = 12.5 = 12
-	 * For C1030:  (96-12-16)/8 =  8.5 =  8
+	 * maxfrags = (Request Size - FWdownload Size ) / Size of 32 bit SGE
+	 *	Request		maxfrags
+	 *	128		12
+	 *	96		8
+	 *	64		4
 	 */
-	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t)) / sizeof(SGESimple32_t);
+	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t)) / sizeof(MptSge_t);
 	if (numfrags > maxfrags) {
 		ret = -EMLINK;
 		goto fwdl_out;
 	}
 
-	dprintk((KERN_INFO "DbG: sgl buffer  = %p, sgfrags = %d\n", sgl, numfrags));
+	dctlprintk((KERN_INFO "DbG: sgl buffer  = %p, sgfrags = %d\n", sgl, numfrags));
 
 	/*
 	 * Parse SG list, copying sgl itself,
@@ -439,11 +731,17 @@
 	sgIn = sgl;
 	bl = buflist;
 	for (i=0; i < numfrags; i++) {
-		nib = (le32_to_cpu(sgIn->FlagsLength) & 0xF0000000) >> 28;
-		/* skip ignore/chain. */
+
+		/* Get the SGE type: 0 - TCSGE, 3 - Chain, 1 - Simple SGE
+		 * Skip everything but Simple. If simple, copy from
+		 *	user space into kernel space.
+		 * Note: we should not have anything but Simple as
+		 *	Chain SGE are illegal.
+		 */
+		nib = (le32_to_cpu(sgIn->FlagsLength) & 0x30000000) >> 28;
 		if (nib == 0 || nib == 3) {
 			;
-		} else if (sgIn->Address) {
+		} else if (mptctl_test_address(sgIn)) {
 			*sgOut = *sgIn;
 			n++;
 			if (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {
@@ -478,26 +776,24 @@
 	/*
 	 *  Wait until the reply has been received
 	 */
-	{
-		int	 foo = 0;
-
-		while (ReplyMsg == NULL) {
-			if (!(foo%1000000)) {
-				dprintk((KERN_INFO "DbG::_do_fwdl: "
-					   "In ReplyMsg loop - iteration %d\n",
-					   foo)); //tc
-			}
+	for (cntdn=HZ*60, i=1; ReplyMsg == NULL; cntdn--, i++) {
+		if (!cntdn) {
 			ret = -ETIME;
-			if (++foo > 60000000)
-				goto fwdl_out;
-			mb();
-			schedule();
-			barrier();
+			goto fwdl_out;
 		}
+
+		if (!(i%HZ)) {
+			dctlprintk((KERN_INFO "DbG::_do_fwdl: "
+				   "In ReplyMsg loop - iteration %d\n",
+				   i));
+		}
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
 	}
 
 	if (sgl)
-        	kfree_sgl(sgl, sgl_dma, buflist, iocp);
+		kfree_sgl(sgl, sgl_dma, buflist, iocp);
 
 	iocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;
 	if (iocstat == MPI_IOCSTATUS_SUCCESS) {
@@ -527,32 +823,46 @@
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *  NEW rwperf (read/write performance) stuff starts here...
+ * SGE Allocation routine
+ *
+ * Inputs:	bytes - number of bytes to be transferred
+ *		sgdir - data direction
+ *		sge_offset - offset (in bytes) from the start of the request
+ *			frame to the first SGE
+ *		ioc - pointer to the mptadapter
+ * Outputs:	frags - number of scatter gather elements
+ *		blp - point to the buflist pointer
+ *		sglbuf_dma - pointer to the (dma) sgl
+ * Returns:	Null if failes
+ *		pointer to the (virtual) sgl if successful.
  */
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static SGESimple32_t *
-kbuf_alloc_2_sgl(int bytes, u32 sgdir, int *frags,
+static MptSge_t *
+kbuf_alloc_2_sgl(int bytes, u32 sgdir, int sge_offset, int *frags,
 		 struct buflist **blp, dma_addr_t *sglbuf_dma, MPT_ADAPTER *ioc)
 {
-	SGESimple32_t	*sglbuf = NULL;
-	struct buflist	*buflist = NULL;
+	MptSge_t	*sglbuf = NULL;		/* pointer to array of SGE
+						 * and chain buffers */
+	struct buflist	*buflist = NULL;	/* kernel routine */
+	MptSge_t	*sgl;
+	MptChain_t	*last_chain = NULL;
 	int		 numfrags = 0;
 	int		 fragcnt = 0;
 	int		 alloc_sz = MIN(bytes,MAX_KMALLOC_SZ);	// avoid kernel warning msg!
 	int		 bytes_allocd = 0;
 	int		 this_alloc;
-	SGESimple32_t	*sgl;
-	u32		 pa;					// phys addr
-	SGEChain32_t	*last_chain = NULL;
-	SGEChain32_t	*old_chain = NULL;
+	dma_addr_t	 pa;					// phys addr
 	int		 chaincnt = 0;
 	int		 i, buflist_ent;
 	int		 sg_spill = MAX_FRAGS_SPILL1;
 	int		 dir;
 
+	/* initialization */
 	*frags = 0;
 	*blp = NULL;
+
+	/* Allocate and initialize an array of kernel
+	 * structures for the SG elements.
+	 */
 	i = MAX_SGL_BYTES / 8;
 	buflist = kmalloc(i, GFP_USER);
 	if (buflist == NULL)
@@ -560,6 +870,11 @@
 	memset(buflist, 0, i);
 	buflist_ent = 0;
 
+	/* Allocate a single block of memory to store the sg elements and
+	 * the chain buffers.  The calling routine is responsible for
+	 * copying the data in this array into the correct place in the
+	 * request and chain buffers.
+	 */
 	sglbuf = pci_alloc_consistent(ioc->pcidev, MAX_SGL_BYTES, sglbuf_dma);
 	if (sglbuf == NULL)
 		goto free_and_fail;
@@ -569,7 +884,15 @@
 	else
 		dir = PCI_DMA_FROMDEVICE;
 
+	/* At start:
+	 *	sgl = sglbuf = point to beginning of sg buffer
+	 *	buflist_ent = 0 = first kernel structure
+	 *	sg_spill = number of SGE that can be written before the first
+	 *		chain element.
+	 *
+	 */
 	sgl = sglbuf;
+	sg_spill = ((ioc->req_sz  - sge_offset)/ sizeof(MptSge_t)) - 1;
 	while (bytes_allocd < bytes) {
 		this_alloc = MIN(alloc_sz, bytes-bytes_allocd);
 		buflist[buflist_ent].len = this_alloc;
@@ -594,7 +917,7 @@
 			/* Write one SIMPLE sge */
 			sgl->FlagsLength = cpu_to_le32(0x10000000|sgdir|this_alloc);
 			dma_addr = pci_map_single(ioc->pcidev, buflist[buflist_ent].kptr, this_alloc, dir);
-			sgl->Address = cpu_to_le32(dma_addr);
+			cpu_to_leXX(dma_addr, sgl->Address);
 
 			fragcnt++;
 			numfrags++;
@@ -609,24 +932,43 @@
 		if (fragcnt == sg_spill) {
 			dma_addr_t chain_link;
 
-			if (last_chain != NULL)
-				last_chain->NextChainOffset = 0x1E;
-
-			fragcnt = 0;
-			sg_spill = MAX_FRAGS_SPILL2;
+			/* If there is a chain element, set the offset
+			 * (in 32 bit words) to the next chain element.
+			 * fragcnt = # sge = 8 bytes = 2 words
+			 *
+			 * Set the length of the chain element (bytes)
+			 * This includes the size of the next chain element.
+			 *
+			 * We are now done with last_chain and the previous
+			 * buffer.
+			 */
+			if (last_chain != NULL) {
+				last_chain->NextChainOffset = fragcnt * 2;
+				last_chain->Length = cpu_to_le16((fragcnt+1) * 8);
+			}
 
-			/* fixup previous SIMPLE sge */
+			/* Finish the current buffer:
+			 * - add the LE bit to last sge
+			 * - add the chain element
+			*/
 			sgl[-1].FlagsLength |= cpu_to_le32(0x80000000);
 
 			chain_link = (*sglbuf_dma) +
 				((u8 *)(sgl+1) - (u8 *)sglbuf);
 
 			/* Write one CHAIN sge */
-			sgl->FlagsLength = cpu_to_le32(0x30000080);
-			sgl->Address = cpu_to_le32(chain_link);
+//			sgl->FlagsLength = cpu_to_le32(0x30000080);
+			sgl->FlagsLength = cpu_to_le32(0x30000000);
+			cpu_to_leXX(chain_link, sgl->Address);
+
+			/* Reset everything for the next SGE series,
+			 * save a ptr to the chain element in last_chain
+			 */
+			fragcnt = 0;
+//			sg_spill = MAX_FRAGS_SPILL2;
+			sg_spill = (ioc->req_sz / sizeof(MptSge_t)) - 1;
 
-			old_chain = last_chain;
-			last_chain = (SGEChain32_t*)sgl;
+			last_chain = (MptChain_t*)sgl;
 			chaincnt++;
 			numfrags++;
 			sgl++;
@@ -646,18 +988,19 @@
 	/* Last sge fixup: set LE+eol+eob bits */
 	sgl[-1].FlagsLength |= cpu_to_le32(0xC1000000);
 
-	/* Chain fixup needed? */
-	if (last_chain != NULL && fragcnt < 16)
+	/* Chain fixup needed? */	/* SteveR CHECKME!!! */
+//	if (last_chain != NULL && fragcnt < 16)
+	if (last_chain != NULL)
 		last_chain->Length = cpu_to_le16(fragcnt * 8);
 
 	*frags = numfrags;
 	*blp = buflist;
 
-	dprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
+	dctlprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
 			   "%d SG frags generated!  (%d CHAIN%s)\n",
 			   numfrags, chaincnt, chaincnt>1?"s":""));
 
-	dprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
+	dctlprintk((KERN_INFO MYNAM "-SG: kbuf_alloc_2_sgl() - "
 			   "last (big) alloc_sz=%d\n",
 			   alloc_sz));
 
@@ -675,7 +1018,7 @@
 			if ((le32_to_cpu(sglbuf[i].FlagsLength) >> 24) == 0x30)
 				continue;
 
-			dma_addr = le32_to_cpu(sglbuf[i].Address);
+			leXX_to_cpu(dma_addr, sglbuf[i].Address);
 			kptr = buflist[i].kptr;
 			len = buflist[i].len;
 
@@ -688,16 +1031,19 @@
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Routine to free the SGL elements.
+ */
 static void
-kfree_sgl(SGESimple32_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)
+kfree_sgl(MptSge_t *sgl, dma_addr_t sgl_dma, struct buflist *buflist, MPT_ADAPTER *ioc)
 {
-	SGESimple32_t	*sg = sgl;
+	MptSge_t	*sg = sgl;
 	struct buflist	*bl = buflist;
 	u32		 nib;
 	int		 dir;
 	int		 n = 0;
 
-	if (le32_to_cpu(sg->FlagsLength) & 0x04000000)
+	if ((le32_to_cpu(sg->FlagsLength) & 0x04000000))
 		dir = PCI_DMA_TODEVICE;
 	else
 		dir = PCI_DMA_FROMDEVICE;
@@ -707,12 +1053,12 @@
 		/* skip ignore/chain. */
 		if (nib == 0 || nib == 3) {
 			;
-		} else if (sg->Address) {
+		} else if (mptctl_test_address(sg)) {
 			dma_addr_t dma_addr;
 			void *kptr;
 			int len;
 
-			dma_addr = le32_to_cpu(sg->Address);
+			leXX_to_cpu(dma_addr, sg->Address);
 			kptr = bl->kptr;
 			len = bl->len;
 			pci_unmap_single(ioc->pcidev, dma_addr, len, dir);
@@ -725,12 +1071,12 @@
 	}
 
 	/* we're at eob! */
-	if (sg->Address) {
+	if (mptctl_test_address(sg)) {
 		dma_addr_t dma_addr;
 		void *kptr;
 		int len;
 
-		dma_addr = le32_to_cpu(sg->Address);
+		leXX_to_cpu(dma_addr, sg->Address);
 		kptr = bl->kptr;
 		len = bl->len;
 		pci_unmap_single(ioc->pcidev, dma_addr, len, dir);
@@ -740,392 +1086,1686 @@
 
 	pci_free_consistent(ioc->pcidev, MAX_SGL_BYTES, sgl, sgl_dma);
 	kfree(buflist);
-	dprintk((KERN_INFO MYNAM "-SG: Free'd 1 SGL buf + %d kbufs!\n", n));
+	dctlprintk((KERN_INFO MYNAM "-SG: Free'd 1 SGL buf + %d kbufs!\n", n));
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_getiocinfo - Query the host adapter for IOC information.
+ *	@arg: User space argument
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
 static int
-mpt_ioctl_rwperf_init(struct mpt_raw_r_w *dest, unsigned long src,
-		      char *caller, MPT_ADAPTER **iocpp)
+mptctl_getiocinfo (unsigned long arg)
 {
-	char	*myname = "_rwperf_init()";
-	int	 ioc;
+	struct mpt_ioctl_iocinfo *uarg = (struct mpt_ioctl_iocinfo *) arg;
+	struct mpt_ioctl_iocinfo karg;
+	MPT_ADAPTER		*ioc;
+	struct pci_dev		*pdev;
+	struct Scsi_Host	*sh;
+	MPT_SCSI_HOST		*hd;
+	int			iocnum;
+	int			numDevices = 0;
+	unsigned int		max_id;
+	int			ii;
+	int			port;
+	u8			revision;
+
+	dctlprintk((": mptctl_getiocinfo called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_iocinfo))) {
+		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
+			"Unable to read in mpt_ioctl_iocinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-	/* get copy of structure passed from user space */
-	if (copy_from_user(dest, (void*)src, sizeof(*dest))) {
-		printk(KERN_ERR MYNAM "::%s() @%d - Can't copy mpt_raw_r_w data @ %p\n",
-				myname, __LINE__, (void*)src);
-		return -EFAULT;				/* (-14) Bad address */
-	} else {
-		dprintk((KERN_INFO MYNAM "-perf: PerfInfo.{ioc,targ,qd,iters,nblks}"
-				   ": %d %d %d %d %d\n",
-				   dest->iocnum, dest->target,
-				   (int)dest->qdepth, dest->iters, dest->nblks ));
-		dprintk((KERN_INFO MYNAM "-perf: PerfInfo.{cache,skip,range,rdwr,seqran}"
-				   ": %d %d %d %d %d\n",
-				   dest->cache_sz, dest->skip, dest->range,
-				   dest->rdwr, dest->seqran ));
-
-		/* Get the MPT adapter id. */
-		if ((ioc = mpt_verify_adapter(dest->iocnum, iocpp)) < 0) {
-			printk(KERN_ERR MYNAM "::%s() @%d - ioc%d not found!\n",
-					myname, __LINE__, dest->iocnum);
-			return -ENXIO;			/* (-6) No such device or address */
-		} else {
-			dprintk((MYNAM "-perf: %s using mpt/ioc%x, target %02xh\n",
-					caller, dest->iocnum, dest->target));
-		}
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_getiocinfo() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
 	}
 
-	return ioc;
-}
+	/* Verify the data transfer size is correct.
+	 * Ignore the port setting.
+	 */
+	if (karg.hdr.maxDataSize != sizeof(struct mpt_ioctl_iocinfo)) {
+		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
+			"Structure size mismatch. Command not completed.\n",
+				__FILE__, __LINE__);
+		return -EFAULT;
+	}
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
+	if (ioc->chip_type == C1030)
+		karg.adapterType = MPT_IOCTL_INTERFACE_SCSI;
+	else
+		karg.adapterType = MPT_IOCTL_INTERFACE_FC;
 
-/*  Treat first N blocks of disk as sacred!  */
-#define SACRED_BLOCKS	100
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int
-mpt_ioctl_rwperf(unsigned long arg)
-{
-	struct mpt_raw_r_w	 kPerfInfo;
-				/* NOTE: local copy, on stack==KERNEL_SPACE! */
-	u8		 target, targetM;
-	u8		 lun, lunM;
-	u8		 scsiop;
-	int		 qdepth;
-	int		 iters;
-	int		 cache_sz;
-	u32		 xferbytes;
-	u32		 scsidir;
-	u32		 qtag;
-	u32		 scsictl;
-	u32		 sgdir;
-	u32		 blkno;
-	u32		 sbphys;
-	SGESimple32_t	*sgl;
-	dma_addr_t	 sgl_dma;
-	struct buflist	*buflist;
-	SGESimple32_t	*sgOut, *sgIn;
-	int		 numfrags;
-	u32		*msg;
-	int		 i;
-	int		 ioc;
-	MPT_FRAME_HDR	*mf;
-	MPT_ADAPTER	*iocp;
-	int		 sgfragcpycnt;
-	int		 blklo, blkhi;
-	u8		 nextchainoffset;
-	u8		*SenseBuf;
-	dma_addr_t	 SenseBufDMA;
-	char		*myname = "_rwperf()";
-
-    dprintk((KERN_INFO "%s - starting...\n", myname));
-
-    /* Validate target device */
-    if ((ioc = mpt_ioctl_rwperf_init(&kPerfInfo, arg, myname, &iocp)) < 0)
-        return ioc;
-
-    /* Allocate DMA'able memory for the sense buffer. */
-    SenseBuf = pci_alloc_consistent(iocp->pcidev, 256, &SenseBufDMA);
-
-    /* set perf parameters from input */
-    target = kPerfInfo.target & 0x0FF;
-    targetM = target & myMAX_T_MASK;
-    lun = kPerfInfo.lun & 0x1F;			// LUN=31 max
-    lunM = lun & myMAX_L_MASK;
-    qdepth = kPerfInfo.qdepth;
-    iters = kPerfInfo.iters;
-    xferbytes = ((u32)kPerfInfo.nblks)<<9;
-
-    DevInUse[targetM][lunM] = 1;
-    DevIosCount[targetM][lunM] = 0;
-
-    cache_sz = kPerfInfo.cache_sz * 1024;	// CacheSz in kB!
-
-    /* ToDo: */
-    /* get capacity (?) */
-
-
-    // pre-build, one time, everything we can for speed in the loops below...
-
-    scsiop = 0x28;				// default to SCSI READ!
-    scsidir = MPI_SCSIIO_CONTROL_READ;		// DATA IN  (host<--ioc<--dev)
-						// 02000000
-    qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;		// 00000000
-
-    if (xferbytes == 0) {
-        // Do 0-byte READ!!!
-        //  IMPORTANT!  Need to set no SCSI DIR for this!
-        scsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
-    }
-
-    scsictl = scsidir | qtag;
-
-    /*
-     *  Set sgdir for DMA transfer.
-     */
-//    sgdir   = 0x04000000;		// SCSI WRITE
-    sgdir = 0x00000000;			// SCSI READ
-
-    if ((sgl = kbuf_alloc_2_sgl(MAX(512,xferbytes), sgdir, &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
-        return -ENOMEM;
-
-    sgfragcpycnt = MIN(10,numfrags);
-    nextchainoffset = 0;
-    if (numfrags > 10)
-        nextchainoffset = 0x1E;
-
-    sbphys = SenseBufDMA;
-
-    rwperf_reset = 0;
-
-//    do {	// target-loop
-
-        blkno = SACRED_BLOCKS;		// Treat first N blocks as sacred!
-					// FIXME!  Skip option
-        blklo = blkno;
-        blkhi = blkno;
-
-        do {    // inner-loop
-
-            while ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
-                mb();
-                schedule();
-                barrier();
-            }
-            msg = (u32*)mf;
-
-            /* Start piecing the SCSIIORequest together */
-            msg[0] = 0x00000000 | nextchainoffset<<16 | target;
-            msg[1] = 0x0000FF0A;				// 255 sense bytes, 10-byte CDB!
-            msg[3] = lun << 8;
-            msg[4] = 0;
-            msg[5] = scsictl;
-
-            // 16 bytes of CDB @ msg[6,7,8,9] are below...
-
-            msg[6] = (   ((blkno & 0xFF000000) >> 8)
-                       | ((blkno & 0x00FF0000) << 8)
-                       | scsiop );
-            msg[7] = (   (((u32)kPerfInfo.nblks & 0x0000FF00) << 16)
-                       | ((blkno & 0x000000FF) << 8)
-                       | ((blkno & 0x0000FF00) >> 8) );
-            msg[8] = (kPerfInfo.nblks & 0x00FF);
-            msg[9] = 0;
-
-            msg[10] = xferbytes;
-
-//            msg[11] = 0xD0000100;
-//            msg[12] = sbphys;
-//            msg[13] = 0;
-            msg[11] = sbphys;
-
-            // Copy the SGL...
-            if (xferbytes) {
-                sgOut = (SGESimple32_t*)&msg[12];
-                sgIn  = sgl;
-                for (i=0; i < sgfragcpycnt; i++)
-                    *sgOut++ = *sgIn++;
-            }
-
-            // fubar!  QueueDepth issue!!!
-            while (    !rwperf_reset
-                    && (DevIosCount[targetM][lunM] >= MIN(qdepth,64)) )
-            {
-                mb();
-                schedule();
-                barrier();
-            }
-
-//            blkno += kPerfInfo.nblks;
-// EXP Stuff!
-// Try optimizing to certain cache size for the target!
-// by keeping blkno within cache range if at all possible
-#if 0
-            if (    cache_sz
-                 && ((2 * kPerfInfo.nblks) <= (cache_sz>>9))
-                 && ((blkno + kPerfInfo.nblks) > ((cache_sz>>9) + SACRED_BLOCKS)) )
-                blkno = SACRED_BLOCKS;
-            else
-                blkno += kPerfInfo.nblks;
-#endif
-// Ok, cheat!
-            if (cache_sz && ((blkno + kPerfInfo.nblks) > ((cache_sz>>9) + SACRED_BLOCKS)) )
-                   blkno = SACRED_BLOCKS;
-            else
-                blkno += kPerfInfo.nblks;
+	port = karg.hdr.port;
+
+	karg.port = port;
+	pdev = (struct pci_dev *) ioc->pcidev;
 
-            if (blkno > blkhi)
-                blkhi = blkno;
+	karg.pciId = pdev->device;
+	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
+	karg.hwRev = revision;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	karg.subSystemDevice = pdev->subsystem_device;
+	karg.subSystemVendor = pdev->subsystem_vendor;
+#endif
 
-            DevIosCount[targetM][lunM]++;
+	/* Get number of devices
+         */
+	if ( (sh = ioc->sh) != NULL) {
+
+		 /* sh->max_id = maximum target ID + 1
+		 */
+		max_id = sh->max_id - 1;
+		hd = (MPT_SCSI_HOST *) sh->hostdata;
+
+		/* Check all of the target structures and
+		 * keep a counter.
+		 */
+		if (hd && hd->Targets) {
+			for (ii = 0; ii <= max_id; ii++) {
+				if (hd->Targets[ii])
+					numDevices++;
+			}
+		}
+	}
+	karg.numDevices = numDevices;
 
-            /*
-             *  Finally, post the request
-             */
-            mpt_put_msg_frame(mptctl_id, ioc, mf);
+	/* Set the BIOS and FW Version
+	 */
+	karg.FWVersion = ioc->facts.FWVersion.Word;
+	karg.BIOSVersion = ioc->biosVersion;
 
+	/* Set the Version Strings.
+	 */
+	strncpy (karg.driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);
 
-            /* let linux breath! */
-            mb();
-            schedule();
-            barrier();
+	karg.busChangeEvent = 0;
+	karg.hostId = ioc->pfacts[port].PortSCSIID;
+	karg.rsvd[0] = karg.rsvd[1] = 0;
 
-            //dprintk((KERN_DEBUG MYNAM "-perf: inner-loop, cnt=%d\n", iters));
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(struct mpt_ioctl_iocinfo))) {
+		printk(KERN_ERR "%s@%d::mptctl_getiocinfo - "
+			"Unable to write out mpt_ioctl_iocinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-        } while ((--iters > 0) && !rwperf_reset);
+	return 0;
+}
 
-        dprintk((KERN_INFO MYNAM "-perf: DbG: blklo=%d, blkhi=%d\n", blklo, blkhi));
-        dprintk((KERN_INFO MYNAM "-perf: target-loop, thisTarget=%d\n", target));
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_gettargetinfo - Query the host adapter for target information.
+ *	@arg: User space argument
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
+static int
+mptctl_gettargetinfo (unsigned long arg)
+{
+	struct mpt_ioctl_targetinfo *uarg = (struct mpt_ioctl_targetinfo *) arg;
+	struct mpt_ioctl_targetinfo karg;
+	MPT_ADAPTER		*ioc;
+	struct Scsi_Host	*sh;
+	MPT_SCSI_HOST		*hd;
+	char			*pmem;
+	int			*pdata;
+	int			iocnum;
+	int			numDevices = 0;
+	unsigned int		max_id;
+	int			ii, jj, lun;
+	int			maxWordsLeft;
+	int			numBytes;
+	u8			port;
+
+	dctlprintk(("mptctl_gettargetinfo called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {
+		printk(KERN_ERR "%s@%d::mptctl_gettargetinfo - "
+			"Unable to read in mpt_ioctl_targetinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-//        //  TEMPORARY!
-//        target = 0;
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
-//    } while (target);
+	/* Get the port number and set the maximum number of bytes
+	 * in the returned structure.
+	 * Ignore the port setting.
+	 */
+	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
+	maxWordsLeft = numBytes/sizeof(int);
+	port = karg.hdr.port;
+
+	if (maxWordsLeft <= 0) {
+		printk(KERN_ERR "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
+				__FILE__, __LINE__);
+		return -ENOMEM;
+	}
 
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
 
-    if (DevIosCount[targetM][lunM]) {
-        dprintk((KERN_INFO "  DbG: DevIosCount[%d][%d]=%d\n",
-                targetM, lunM, DevIosCount[targetM][lunM]));
-    }
+	/* struct mpt_ioctl_targetinfo does not contain sufficient space
+	 * for the target structures so when the IOCTL is called, there is
+	 * not sufficient stack space for the structure. Allocate memory,
+	 * populate the memory, copy back to the user, then free memory.
+	 * targetInfo format:
+	 * bits 31-24: reserved
+	 *      23-16: LUN
+	 *      15- 8: Bus Number
+	 *       7- 0: Target ID
+	 */
+	pmem = kmalloc(numBytes, GFP_KERNEL);
+	if (pmem == NULL) {
+		printk(KERN_ERR "%s::mptctl_gettargetinfo() @%d - no memory available!\n",
+				__FILE__, __LINE__);
+		return -ENOMEM;
+	}
+	memset(pmem, 0, numBytes);
+	pdata =  (int *) pmem;
 
-    while (DevIosCount[targetM][lunM]) {
-        //dprintk((KERN_DEBUG "  DbG: Waiting... DevIosCount[%d][%d]=%d\n",
-        //        targetM, lunM, DevIosCount[targetM][lunM]));
-        mb();
-        schedule();
-        barrier();
-    }
-    DevInUse[targetM][lunM] = 0;
+	/* Get number of devices
+         */
+	if ( (sh = ioc->sh) != NULL) {
+
+		max_id = sh->max_id - 1;
+		hd = (MPT_SCSI_HOST *) sh->hostdata;
+
+		/* Check all of the target structures.
+		 * Save the Id and increment the counter,
+		 * if ptr non-null.
+		 * sh->max_id = maximum target ID + 1
+		 */
+		if (hd && hd->Targets) {
+			ii = 0;
+			while (ii <= max_id) {
+				if (hd->Targets[ii]) {
+					for (jj = 0; jj <= MPT_LAST_LUN; jj++) {
+						lun = (1 << jj);
+						if (hd->Targets[ii]->luns & lun) {
+							numDevices++;
+							*pdata = (jj << 16) | ii;
+							--maxWordsLeft;
+
+							pdata++;
+
+							if (maxWordsLeft <= 0) {
+								break;
+							}
+						}
+					}
+				}
+				ii++;
+			}
+		}
+	}
+	karg.numDevices = numDevices;
 
-    pci_free_consistent(iocp->pcidev, 256, SenseBuf, SenseBufDMA);
+	/* Copy part of the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(struct mpt_ioctl_targetinfo))) {
+		printk(KERN_ERR "%s@%d::mptctl_gettargetinfo - "
+			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		kfree(pmem);
+		return -EFAULT;
+	}
 
-    if (sgl)
-        kfree_sgl(sgl, sgl_dma, buflist, iocp);
+	/* Copy the remaining data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *) uarg->targetInfo, pmem, numBytes)) {
+		printk(KERN_ERR "%s@%d::mptctl_gettargetinfo - "
+			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
+				__FILE__, __LINE__, (void*)pdata);
+		kfree(pmem);
+		return -EFAULT;
+	}
 
-    dprintk((KERN_INFO "  *** done ***\n"));
+	kfree(pmem);
 
-    return 0;
+	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* MPT IOCTL Test function.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
 static int
-mpt_ioctl_rwperf_status(unsigned long arg)
+mptctl_readtest (unsigned long arg)
 {
-	struct mpt_raw_r_w	 kPerfInfo;
-				/* NOTE: local copy, on stack==KERNEL_SPACE! */
-	MPT_ADAPTER	*iocp;
-	int		 ioc;
-//	u8		 targ;
-//	u8		 lun;
-	int		 T, L;
-	char		*myname = "_rwperf_status()";
+	struct mpt_ioctl_test	*uarg = (struct mpt_ioctl_test *) arg;
+	struct mpt_ioctl_test	 karg;
+	MPT_ADAPTER *ioc;
+	int iocnum;
 
+	dctlprintk(("mptctl_readtest called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {
+		printk(KERN_ERR "%s@%d::mptctl_readtest - "
+			"Unable to read in mpt_ioctl_test struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-	dprintk((KERN_INFO "%s - starting...\n", myname));
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_readtest() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
-	/* Get a pointer to the MPT adapter. */
-	if ((ioc = mpt_ioctl_rwperf_init(&kPerfInfo, arg, myname, &iocp)) < 0)
-		return ioc;
+	/* Fill in the data and return the structure to the calling
+	 * program
+	 */
 
-	/* set perf parameters from input */
-//	targ = kPerfInfo.target & 0xFF;
-//	lun = kPerfInfo.lun & 0x1F;
+#ifdef MFCNT
+	karg.chip_type = ioc->mfcnt;
+#else
+	karg.chip_type = ioc->chip_type;
+#endif
+	strncpy (karg.name, ioc->name, MPT_MAX_NAME);
+	strncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);
 
-	for (T=0; T < myMAX_TARGETS; T++)
-		for (L=0; L < myMAX_LUNS; L++)
-			if (DevIosCount[T][L]) {
-				printk(KERN_INFO "%s: ioc%d->00:%02x:%02x"
-						 ", IosCnt=%d\n",
-						 myname, ioc, T, L, DevIosCount[T][L] );
-			}
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg, sizeof(struct mpt_ioctl_test))) {
+		printk(KERN_ERR "%s@%d::mptctl_readtest - "
+			"Unable to write out mpt_ioctl_test struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptctl_eventquery - Query the host adapter for the event types
+ *	that are being logged.
+ *	@arg: User space argument
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV  if no such device/adapter
+ */
 static int
-mpt_ioctl_rwperf_reset(unsigned long arg)
+mptctl_eventquery (unsigned long arg)
 {
-	struct mpt_raw_r_w	 kPerfInfo;
-				/* NOTE: local copy, on stack==KERNEL_SPACE! */
-	MPT_ADAPTER	*iocp;
-	int		 ioc;
-//	u8		 targ;
-//	u8		 lun;
-	int		 T, L;
-	int		 i;
-	char		*myname = "_rwperf_reset()";
-
-	dprintk((KERN_INFO "%s - starting...\n", myname));
-
-	/* Get MPT adapter id. */
-	if ((ioc = mpt_ioctl_rwperf_init(&kPerfInfo, arg, myname, &iocp)) < 0)
-		return ioc;
-
-	/* set perf parameters from input */
-//	targ = kPerfInfo.target & 0xFF;
-//	lun = kPerfInfo.lun & 0x1F;
-
-	rwperf_reset = 1;
-	for (i=0; i < 1000000; i++) {
-		mb();
-		schedule();
-		barrier();
-	}
-	rwperf_reset = 0;
-
-	for (T=0; T < myMAX_TARGETS; T++)
-		for (L=0; L < myMAX_LUNS; L++)
-			if (DevIosCount[T][L]) {
-				printk(KERN_INFO "%s: ioc%d->00:%02x:%02x, "
-						 "IosCnt RESET! (from %d to 0)\n",
-						 myname, ioc, T, L, DevIosCount[T][L] );
-				DevIosCount[T][L] = 0;
-				DevInUse[T][L] = 0;
-			}
+	struct mpt_ioctl_eventquery	*uarg = (struct mpt_ioctl_eventquery *) arg;
+	struct mpt_ioctl_eventquery	 karg;
+	MPT_ADAPTER *ioc;
+	int iocnum;
+
+	dctlprintk(("mptctl_eventquery called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventquery - "
+			"Unable to read in mpt_ioctl_eventquery struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_eventquery() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
+	karg.eventEntries = ioc->eventLogSize;
+	karg.eventTypes = ioc->eventTypes;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventquery - "
+			"Unable to write out mpt_ioctl_eventquery struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static int
-mpt_ioctl_scsi_cmd(unsigned long arg)
+mptctl_eventenable (unsigned long arg)
 {
-	return -ENOSYS;
+	struct mpt_ioctl_eventenable	*uarg = (struct mpt_ioctl_eventenable *) arg;
+	struct mpt_ioctl_eventenable	 karg;
+	MPT_ADAPTER *ioc;
+	int iocnum;
+
+	dctlprintk(("mptctl_eventenable called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventenable - "
+			"Unable to read in mpt_ioctl_eventenable struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_eventenable() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	if (ioc->events == NULL) {
+		/* Have not yet allocated memory - do so now.
+		 */
+		int sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
+		ioc->events = kmalloc(sz, GFP_KERNEL);
+		if (ioc->events == NULL) {
+			printk(KERN_ERR MYNAM ": ERROR - Insufficient memory to add adapter!\n");
+			return -ENOMEM;
+		}
+		memset(ioc->events, 0, sz);
+		ioc->alloc_total += sz;
+
+		ioc->eventLogSize = MPTCTL_EVENT_LOG_SIZE;
+		ioc->eventContext = 0;
+        }
+
+	/* Update the IOC event logging flag.
+	 */
+	ioc->eventTypes = karg.eventTypes;
+
+	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+mptctl_eventreport (unsigned long arg)
+{
+	struct mpt_ioctl_eventreport	*uarg = (struct mpt_ioctl_eventreport *) arg;
+	struct mpt_ioctl_eventreport	 karg;
+	MPT_ADAPTER		 *ioc;
+	int			 iocnum;
+	int			 numBytes, maxEvents, max;
+
+	dctlprintk(("mptctl_eventreport called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {
+		printk(KERN_ERR "%s@%d::mptctl_eventreport - "
+			"Unable to read in mpt_ioctl_eventreport struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,51)
-#define	owner_THIS_MODULE  owner:		THIS_MODULE,
-#else
-#define	owner_THIS_MODULE
-#endif
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_eventreport() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
 
-static struct file_operations mptctl_fops = {
-	owner_THIS_MODULE
-	llseek:		no_llseek,
-	read:		mptctl_read,
-	write:		mptctl_write,
-	ioctl:		mpt_ioctl,
-	open:		mptctl_open,
-	release:	mptctl_release,
-};
+	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
+	maxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);
 
-static struct miscdevice mptctl_miscdev = {
-	MPT_MINOR,
-	MYNAM,
-	&mptctl_fops
-};
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+	max = ioc->eventLogSize < maxEvents ? ioc->eventLogSize : maxEvents;
 
-#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+	/* If fewer than 1 event is requested, there must have
+	 * been some type of error.
+	 */
+	if ((max < 1) || !ioc->events)
+		return -ENODATA;
 
-/* The dynamic ioctl32 compat. registry only exists in >2.3.x sparc64 kernels */
+	/* Copy the data from kernel memory to user memory
+	 */
+	numBytes = max * sizeof(MPT_IOCTL_EVENTS);
+	if (copy_to_user((char *) uarg->eventData, ioc->events, numBytes)) {
+		printk(KERN_ERR "%s@%d::mptctl_eventreport - "
+			"Unable to write out mpt_ioctl_eventreport struct @ %p\n",
+				__FILE__, __LINE__, (void*)ioc->events);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+mptctl_replace_fw (unsigned long arg)
+{
+	struct mpt_ioctl_replace_fw	*uarg = (struct mpt_ioctl_replace_fw *) arg;
+	struct mpt_ioctl_replace_fw	 karg;
+	MPT_ADAPTER		 *ioc;
+	int			 iocnum;
+	u8			 *mem = NULL;
+	dma_addr_t		 mem_dma;
+	int			 oldFwSize, newFwSize;
+
+	dctlprintk(("mptctl_replace_fw called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {
+		printk(KERN_ERR "%s@%d::mptctl_replace_fw - "
+			"Unable to read in mpt_ioctl_replace_fw struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_replace_fw() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	/* If not caching FW, return 0
+	 */
+	if ((ioc->FWImage == NULL) && (ioc->alt_ioc) && (ioc->alt_ioc->FWImage == NULL)) {
+		return 0;
+	}
+
+
+	/* Allocate memory for the new FW image
+	 */
+	newFwSize = karg.newImageSize;
+	mem = pci_alloc_consistent(ioc->pcidev, newFwSize, &mem_dma);
+	if (mem == NULL)
+		return -ENOMEM;
+
+	ioc->alloc_total += newFwSize;	
+
+	/* Copy the data from user memory to kernel space
+	 */
+	if (copy_from_user(mem, uarg->newImage, newFwSize)) {
+		printk(KERN_ERR "%s@%d::mptctl_replace_fw - "
+			"Unable to read in mpt_ioctl_replace_fw image @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		pci_free_consistent(ioc->pcidev, newFwSize, mem, mem_dma);
+		ioc->alloc_total -= newFwSize;	
+		return -EFAULT;
+	}
+
+	/* Free the old FW image 
+	 */
+	oldFwSize = ioc->facts.FWImageSize;
+	if (ioc->FWImage) {
+		pci_free_consistent(ioc->pcidev, oldFwSize, ioc->FWImage, ioc->FWImage_dma);
+		ioc->alloc_total -= oldFwSize;	
+		ioc->FWImage = mem;
+		ioc->FWImage_dma = mem_dma;
+		
+	} else if ((ioc->alt_ioc) && (ioc->alt_ioc->FWImage)) {
+		pci_free_consistent(ioc->pcidev, oldFwSize, ioc->alt_ioc->FWImage, ioc->alt_ioc->FWImage_dma);
+		ioc->alloc_total -= oldFwSize;	
+		ioc->alt_ioc->FWImage = mem;
+		ioc->alt_ioc->FWImage_dma = mem_dma;
+	}
+
+	/* Update IOCFactsReply
+	 */
+	ioc->facts.FWImageSize = newFwSize;
+	if (ioc->alt_ioc)
+		ioc->alt_ioc->facts.FWImageSize = newFwSize;
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* MPT IOCTL MPTCOMMAND function.
+ * Cast the arg into the mpt_ioctl_mpt_command structure.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_mpt_command (unsigned long arg)
+{
+	struct mpt_ioctl_command *uarg = (struct mpt_ioctl_command *) arg;
+	struct mpt_ioctl_command  karg;
+	MPT_ADAPTER	*ioc;
+	int		iocnum;
+	int		rc;
+
+	dctlprintk(("mptctl_command called.\n"));
+
+	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {
+		printk(KERN_ERR "%s@%d::mptctl_mpt_command - "
+			"Unable to read in mpt_ioctl_command struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_mpt_command() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	rc = mptctl_do_mpt_command (karg, (char *) &uarg->MF, 0);
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Worker routine for the IOCTL MPTCOMMAND and MPTCOMMAND32 (sparc) commands.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_do_mpt_command (struct mpt_ioctl_command karg, char *mfPtr, int local)
+{
+	MPT_ADAPTER	*ioc;
+	MPT_FRAME_HDR	*mf = NULL;
+	MPIHeader_t	*hdr;
+	MptSge_t	*psge;
+	MptSge_t	*this_sge = NULL;
+	MptSge_t	*sglbuf = NULL;
+	struct buflist	bufIn;	/* data In buffer */
+	struct buflist	bufOut; /* data Out buffer */
+	dma_addr_t	sglbuf_dma;
+	dma_addr_t	dma_addr;
+	int		dir;	/* PCI data direction */
+	int		sgSize = 0;	/* Num SG elements */
+	int		this_alloc;
+	int iocnum, flagsLength;
+	int sz, rc = 0;
+	int msgContext;
+	u16		req_idx;
+
+	dctlprintk(("mptctl_do_mpt_command called.\n"));
+
+	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_do_mpt_command() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+	if (!ioc->ioctl) {
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"No memory available during driver init.\n",
+				__FILE__, __LINE__);
+		return -ENOMEM;
+	} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_TIMEOUT) {
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"Busy with IOC Reset \n", __FILE__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Verify that the final request frame will not be too large.
+	 */
+	sz = karg.dataSgeOffset * 4;
+	if (karg.dataInSize > 0)
+		sz += sizeof (MptSge_t);
+	if (karg.dataOutSize > 0)
+		sz += sizeof (MptSge_t);
+
+	if ( sz > ioc->req_sz) {
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"Request frame too large (%d) maximum (%d)\n",
+				__FILE__, __LINE__, sz, ioc->req_sz);
+		return -EFAULT;
+	}
+
+	/* Get a free request frame and save the message context.
+	 */
+        if ((mf = mpt_get_msg_frame(mptctl_id, ioc->id)) == NULL)
+                return -EAGAIN;
+
+	hdr = (MPIHeader_t *) mf;
+	msgContext = le32_to_cpu(hdr->MsgContext);
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+
+	/* Copy the request frame
+	 * Reset the saved message context.
+	 */
+        if (local) {
+		/* Request frame in kernel space
+		 */
+		memcpy((char *)mf, (char *) mfPtr, karg.dataSgeOffset * 4);
+        } else {
+		/* Request frame in user space
+		 */
+		if (copy_from_user((char *)mf, (char *) mfPtr,
+					karg.dataSgeOffset * 4)){
+			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+				"Unable to read MF from mpt_ioctl_command struct @ %p\n",
+				__FILE__, __LINE__, (void*)mfPtr);
+			rc = -EFAULT;
+			goto done_free_mem;
+		}
+        }
+	hdr->MsgContext = cpu_to_le32(msgContext);
+
+
+	/* Verify that this request is allowed.
+	 */
+	switch (hdr->Function) {
+	case MPI_FUNCTION_IOC_FACTS:
+	case MPI_FUNCTION_PORT_FACTS:
+	case MPI_FUNCTION_CONFIG:
+	case MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:
+	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
+	case MPI_FUNCTION_FW_UPLOAD:
+	case MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:
+	case MPI_FUNCTION_FW_DOWNLOAD:
+		break;
+
+	case MPI_FUNCTION_SCSI_IO_REQUEST:
+		if (ioc->sh) {
+			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
+			VirtDevice	*pTarget = NULL;
+			MPT_SCSI_HOST	*hd = NULL;
+			int qtag = MPI_SCSIIO_CONTROL_UNTAGGED;
+			int scsidir = 0;
+			int target = (int) pScsiReq->TargetID;
+			int dataSize;
+
+			pScsiReq->MsgFlags = MPT_SCSIIO_MSG_FLAGS;
+
+			/* verify that app has not requested
+			 *	more sense data than driver
+			 *	can provide, if so, reset this parameter
+			 * set the sense buffer pointer low address
+			 * update the control field to specify Q type
+			 */
+			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
+				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+
+			pScsiReq->SenseBufferLowAddr =
+				cpu_to_le32(ioc->sense_buf_low_dma
+				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
+
+			if ( (hd = (MPT_SCSI_HOST *) ioc->sh->hostdata)) {
+				if (hd->Targets)
+					pTarget = hd->Targets[target];
+			}
+
+			if (pTarget &&(pTarget->tflags & MPT_TARGET_FLAGS_Q_YES))
+				qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
+
+			/* Have the IOCTL driver set the direction based
+			 * on the dataOutSize (ordering issue with Sparc).
+			 */
+			if (karg.dataOutSize > 0 ) {
+				scsidir = MPI_SCSIIO_CONTROL_WRITE;
+				dataSize = karg.dataOutSize;
+			}
+			else {
+				scsidir = MPI_SCSIIO_CONTROL_READ;
+				dataSize = karg.dataInSize;
+			}
+
+			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
+			pScsiReq->DataLength = cpu_to_le32(dataSize);
+
+		} else {
+			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+				"SCSI driver is not loaded. \n",
+					__FILE__, __LINE__);
+			rc = -EFAULT;
+			goto done_free_mem;
+		}
+		break;
+
+	case MPI_FUNCTION_RAID_ACTION:
+		/* Just add a SGE
+		 */
+		break;
+
+	case MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:
+		if (ioc->sh) {
+			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
+			int qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
+			int scsidir = MPI_SCSIIO_CONTROL_READ;
+			int dataSize;
+
+			pScsiReq->MsgFlags = MPT_SCSIIO_MSG_FLAGS;
+
+			/* verify that app has not requested
+			 *	more sense data than driver
+			 *	can provide, if so, reset this parameter
+			 * set the sense buffer pointer low address
+			 * update the control field to specify Q type
+			 */
+			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
+				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+
+			pScsiReq->SenseBufferLowAddr =
+				cpu_to_le32(ioc->sense_buf_low_dma
+				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
+
+			/* All commands to physical devices are tagged
+			 */
+
+			/* Have the IOCTL driver set the direction based
+			 * on the dataOutSize (ordering issue with Sparc).
+			 */
+			if (karg.dataOutSize > 0 ) {
+				scsidir = MPI_SCSIIO_CONTROL_WRITE;
+				dataSize = karg.dataOutSize;
+			}
+			else {
+				scsidir = MPI_SCSIIO_CONTROL_READ;
+				dataSize = karg.dataInSize;
+			}
+
+			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
+			pScsiReq->DataLength = cpu_to_le32(dataSize);
+
+		} else {
+			printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+				"SCSI driver is not loaded. \n",
+					__FILE__, __LINE__);
+			rc = -EFAULT;
+			goto done_free_mem;
+		}
+		break;
+
+	default:
+		/*
+		 * MPI_FUNCTION_IOC_INIT
+		 * MPI_FUNCTION_PORT_ENABLE
+		 * MPI_FUNCTION_TARGET_CMD_BUFFER_POST
+		 * MPI_FUNCTION_TARGET_ASSIST
+		 * MPI_FUNCTION_TARGET_STATUS_SEND
+		 * MPI_FUNCTION_TARGET_MODE_ABORT
+		 * MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET
+		 * MPI_FUNCTION_IO_UNIT_RESET
+		 * MPI_FUNCTION_HANDSHAKE
+		 * MPI_FUNCTION_REPLY_FRAME_REMOVAL
+		 * MPI_FUNCTION_EVENT_NOTIFICATION
+		 *  (driver handles event notification)
+		 * MPI_FUNCTION_EVENT_ACK
+		 * MPI_FUNCTION_SCSI_TASK_MGMT
+		 */
+
+		/*  What to do with these???  CHECK ME!!!
+			MPI_FUNCTION_FC_LINK_SRVC_BUF_POST
+			MPI_FUNCTION_FC_LINK_SRVC_RSP
+			MPI_FUNCTION_FC_ABORT
+			MPI_FUNCTION_FC_PRIMITIVE_SEND
+			MPI_FUNCTION_LAN_SEND
+			MPI_FUNCTION_LAN_RECEIVE
+		 	MPI_FUNCTION_LAN_RESET
+		*/
+
+		printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+			"Illegal request (function 0x%x) \n",
+			__FILE__, __LINE__, hdr->Function);
+		rc = -EFAULT;
+		goto done_free_mem;
+	}
+
+	/* Add the SGL ( at most one data in SGE and one data out SGE )
+	 * In the case of two SGE's - the data out (write) will always
+	 * preceede the data in (read) SGE. psgList is used to free the
+	 * allocated memory.
+	 */
+	psge = (MptSge_t *) ( ((int *) mf) + karg.dataSgeOffset);
+	flagsLength = 0;
+
+	/* bufIn and bufOut are used for user to kernel space transfers
+	 */
+	bufIn.kptr = bufOut.kptr = NULL;
+	bufIn.len = bufOut.len = 0;
+
+	if (karg.dataOutSize > 0 )
+		sgSize ++;
+
+	if (karg.dataInSize > 0 )
+		sgSize ++;
+
+	if (sgSize > 0) {
+
+		/* Allocate memory for the SGL.
+		 * Used to free kernel memory once
+		 * the MF is freed.
+		 */
+		sglbuf = pci_alloc_consistent (ioc->pcidev,
+			sgSize*sizeof(MptSge_t), &sglbuf_dma);
+		if (sglbuf == NULL) {
+			rc = -ENOMEM;
+			goto done_free_mem;
+		}
+		this_sge = sglbuf;
+
+		/* Set up the dataOut memory allocation */
+		if (karg.dataOutSize > 0) {
+			dir = PCI_DMA_TODEVICE;
+			if (karg.dataInSize > 0 ) {
+				flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
+						MPI_SGE_FLAGS_DIRECTION |
+						MPT_SGE_ADDRESS_SIZE )
+						<< MPI_SGE_FLAGS_SHIFT;
+			} else {
+				flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
+			}
+			flagsLength |= karg.dataOutSize;
+
+			this_alloc = karg.dataOutSize;
+			bufOut.len = this_alloc;
+			bufOut.kptr = pci_alloc_consistent(
+					ioc->pcidev, this_alloc, &dma_addr);
+
+			if (bufOut.kptr == NULL) {
+				rc = -ENOMEM;
+				goto done_free_mem;
+			} else {
+				/* Copy user data to kernel space.
+				 */
+				if (copy_from_user(bufOut.kptr,
+						karg.dataOutBufPtr,
+						bufOut.len)) {
+
+					printk(KERN_ERR
+						"%s@%d::mptctl_do_mpt_command - Unable "
+						"to read user data "
+						"struct @ %p\n",
+						__FILE__, __LINE__,(void*)karg.dataOutBufPtr);
+					rc =  -EFAULT;
+					goto done_free_mem;
+				}
+
+				/* Set up this SGE.
+				 * Copy to MF and to sglbuf
+				 */
+
+				psge->FlagsLength = cpu_to_le32 (flagsLength);
+				cpu_to_leXX(dma_addr, psge->Address);
+				psge++;
+
+				this_sge->FlagsLength=cpu_to_le32(flagsLength);
+				cpu_to_leXX(dma_addr, this_sge->Address);
+				this_sge++;
+			}
+		}
+
+		if (karg.dataInSize > 0) {
+			dir = PCI_DMA_FROMDEVICE;
+			flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+			flagsLength |= karg.dataInSize;
+
+			this_alloc = karg.dataInSize;
+			bufIn.len = this_alloc;
+			bufIn.kptr = pci_alloc_consistent(ioc->pcidev,
+							this_alloc, &dma_addr);
+			if (bufIn.kptr == NULL) {
+				rc = -ENOMEM;
+				goto done_free_mem;
+			} else {
+				/* Set up this SGE
+				 * Copy to MF and to sglbuf
+				 */
+				psge->FlagsLength = cpu_to_le32 (flagsLength);
+				cpu_to_leXX(dma_addr, psge->Address);
+
+				this_sge->FlagsLength=cpu_to_le32(flagsLength);
+				cpu_to_leXX(dma_addr, this_sge->Address);
+				this_sge++;
+			}
+		}
+	} else  {
+		/* Add a NULL SGE
+		 */
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
+		psge->FlagsLength = cpu_to_le32 (flagsLength);
+		cpu_to_leXX( (dma_addr_t) -1, psge->Address);
+	}
+
+	/* The request is complete. Set the timer parameters
+	 * and issue the request.
+	 */
+	if (karg.timeout > 0) {
+		ioc->ioctl->timer.expires = jiffies + HZ*karg.timeout;
+	} else {
+		ioc->ioctl->timer.expires = jiffies + HZ*MPT_IOCTL_DEFAULT_TIMEOUT;
+	}
+
+	ioc->ioctl->wait_done = 0;
+	ioc->ioctl->status |= MPT_IOCTL_STATUS_TIMER_ACTIVE;
+	add_timer(&ioc->ioctl->timer);
+
+	mpt_put_msg_frame(mptctl_id, ioc->id, mf);
+	wait_event(mptctl_wait, ioc->ioctl->wait_done);
+
+	/* The command is complete.  * Return data to the user.
+	 *
+	 * If command completed,  mf has been freed so cannot
+	 * use this memory.
+	 *
+	 * If timeout, a recovery  mechanism has been called.
+	 * Need to free the mf.
+	 */
+	if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_TIMEOUT) {
+
+		/* A timeout - there is no data to return to the
+		 * the user other than an error.
+		 * The timer callback deleted the
+		 * timer and reset the adapter queues.
+		 */
+		printk(KERN_WARNING "%s@%d::mptctl_do_mpt_command - "
+			"Timeout Occurred on IOCTL! Resetting IOC.\n", __FILE__, __LINE__);
+		rc = -ETIME;
+
+		/* Free memory and return to the calling function
+		 */
+		goto done_free_mem;
+
+	} else {
+		/* Callback freed request frame.
+		 */
+		mf = NULL;
+
+		/* If a valid reply frame, copy to the user.
+		 * Offset 2: reply length in U32's
+		 */
+		if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
+			if (karg.maxReplyBytes < ioc->reply_sz) {
+				 sz = MIN(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
+			} else {
+				 sz = MIN(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
+			}
+
+			if (sz > 0) {
+				if (copy_to_user((char *)karg.replyFrameBufPtr,
+					 &ioc->ioctl->ReplyFrame, sz)){
+
+					 printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					 "Unable to write out reply frame %p\n",
+					 __FILE__, __LINE__, (void*)karg.replyFrameBufPtr);
+					 rc =  -ENODATA;
+					 goto done_free_mem;
+				}
+			}
+		}
+
+		/* If valid sense data, copy to user.
+		 */
+		if (ioc->ioctl->status & MPT_IOCTL_STATUS_SENSE_VALID) {
+			sz = MIN(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
+			if (sz > 0) {
+				if (copy_to_user((char *)karg.senseDataPtr, ioc->ioctl->sense, sz)) {
+					printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					"Unable to write sense data to user %p\n",
+					__FILE__, __LINE__,
+					(void*)karg.senseDataPtr);
+					rc =  -ENODATA;
+					goto done_free_mem;
+				}
+			}
+		}
+
+		/* If the overall status is _GOOD and data in, copy data
+		 * to user.
+		 */
+		if ((ioc->ioctl->status & MPT_IOCTL_STATUS_COMMAND_GOOD) &&
+					(karg.dataInSize > 0) && (bufIn.kptr)) {
+
+			if (copy_to_user((char *)karg.dataInBufPtr,
+					 bufIn.kptr, karg.dataInSize)) {
+				printk(KERN_ERR "%s@%d::mptctl_do_mpt_command - "
+					"Unable to write data to user %p\n",
+					__FILE__, __LINE__,
+					(void*)karg.dataInBufPtr);
+				rc =  -ENODATA;
+			}
+		}
+	}
+
+done_free_mem:
+	/* Clear status bits.
+	 */
+	ioc->ioctl->status = 0;
+
+	if (sglbuf) {
+		this_sge = sglbuf;
+
+		/* Free the allocated memory.
+		 */
+		 if (bufOut.kptr != NULL ) {
+
+			leXX_to_cpu (dma_addr, this_sge->Address);
+
+			this_sge++;	/* go to next structure */
+			this_alloc = bufOut.len;
+			pci_free_consistent(ioc->pcidev,
+				this_alloc, (void *) &bufOut, dma_addr);
+		}
+
+		if (bufIn.kptr != NULL ) {
+			leXX_to_cpu (dma_addr, this_sge->Address);
+			this_alloc = bufIn.len;
+
+			pci_free_consistent(ioc->pcidev,
+					this_alloc, (void *) &bufIn, dma_addr);
+		}
+
+		this_alloc = sgSize * sizeof(MptSge_t);
+		pci_free_consistent(ioc->pcidev,
+				this_alloc, (void *) sglbuf, sglbuf_dma);
+
+	}
+
+	/* mf will be null if allocation failed OR
+	 * if command completed OK (callback freed)
+	 */
+	if (mf)
+		mpt_free_msg_frame(mptctl_id, ioc->id, mf);
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Routine for the Compaq IOCTL commands.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ *		-ENOMEM if memory allocation error
+ */
+static int
+mptctl_compaq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int iocnum = 0;
+	unsigned iocnumX = 0;
+	int ret;
+	int nonblock = (file->f_flags & O_NONBLOCK);
+	MPT_ADAPTER *iocp = NULL;
+
+	if (cmd == CPQFCTS_SCSI_PASSTHRU) {
+		/* Update the iocnum */
+		if (copy_from_user(&iocnumX, (int *)arg, sizeof(int))) {
+			printk(KERN_ERR "%s::mptctl_compaq_ioctl() @%d - "
+				"Unable to read controller number @ %p\n",
+				__FILE__, __LINE__, (void*)arg);
+			return -EFAULT;
+		}
+		iocnumX &= 0xFF;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
+	    (iocp == NULL)) {
+		printk(KERN_ERR "%s::mptctl_compaq_ioctl() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnumX);
+		return -ENODEV;
+	}
+
+	/* All of these commands require an interrupt or
+	 * are unknown/illegal.
+	 */
+	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
+		return ret;
+
+	dctlprintk((MYIOC_s_INFO_FMT ": mptctl_compaq_ioctl()\n", iocp->name));
+
+	switch(cmd) {
+	case CPQFCTS_GETPCIINFO:
+		ret = mptctl_cpq_getpciinfo(arg);
+		break;
+	case CPQFCTS_GETDRIVER:
+		ret = mptctl_cpq_getdriver(arg);
+		break;
+	case CPQFCTS_CTLR_STATUS:
+		ret = mptctl_cpq_ctlr_status(arg);
+		break;
+	case CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS:
+		ret = mptctl_cpq_target_address(arg);
+		break;
+	case CPQFCTS_SCSI_PASSTHRU:
+		ret = mptctl_cpq_passthru(arg);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	up(&mptctl_syscall_sem_ioc[iocp->id]);
+
+	return ret;
+
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_getpciinfo - Get PCI Information in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
+static int
+mptctl_cpq_getpciinfo(unsigned long arg)
+{
+	cpqfc_pci_info_struct *uarg = (cpqfc_pci_info_struct *) arg;
+	cpqfc_pci_info_struct karg;
+	MPT_ADAPTER		*ioc;
+	struct pci_dev		*pdev;
+	CONFIGPARMS		cfg;
+	ConfigPageHeader_t	hdr;
+	int			iocnum = 0, iocnumX = 0;
+	dma_addr_t		buf_dma;
+	u8			*pbuf = NULL;
+	int			failed;
+
+	dctlprintk((": mptctl_cpq_pciinfo called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(cpqfc_pci_info_struct))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_pciinfo - "
+			"Unable to read in cpqfc_pci_info_struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_pciinfo() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	pdev = (struct pci_dev *) ioc->pcidev;
+
+	/* Populate the structure. */
+	karg.bus = pdev->bus->number;
+	karg.bus_type = 1;	/* 1 = PCI; 4 = unknown */
+	karg.device_fn = PCI_FUNC(pdev->devfn);
+	karg.slot_number = PCI_SLOT(pdev->devfn);
+	karg.vendor_id = pdev->vendor;
+	karg.device_id = pdev->device;
+	karg.board_id = (karg.device_id | (karg.vendor_id << 16));
+	karg.class_code = pdev->class;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	karg.sub_vendor_id = pdev->subsystem_vendor;
+	karg.sub_device_id = pdev->subsystem_device;
+#endif
+
+	/* Issue a config request to get the device serial number
+	 */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	failed = 1;
+
+	if (mpt_config(ioc, &cfg) == 0) {
+		if (cfg.hdr->PageLength > 0) {
+			/* Issue the second config page request */
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+			pbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);
+			if (pbuf) {
+				cfg.physAddr = buf_dma;
+				if (mpt_config(ioc, &cfg) == 0) {
+					ManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;
+					strncpy(karg.serial_number, pdata->BoardTracerNumber, 17);
+					failed = 0;
+				}
+				pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
+				pbuf = NULL;
+			}
+		}
+	}
+	if (failed)
+		strncpy(karg.serial_number, " ", 17);
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(cpqfc_pci_info_struct))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_pciinfo - "
+			"Unable to write out cpqfc_pci_info_struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_getdriver - Get Driver Version in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_cpq_getdriver(unsigned long arg)
+{
+	int		*uarg = (int *)arg;
+	int		karg;
+	MPT_ADAPTER	*ioc = NULL;
+	int		iocnum = 0, iocnumX = 0;
+	int		ii, jj;
+	char		version[10];
+	char		val;
+	char		*vptr = NULL;
+	char		*pptr = NULL;
+
+	dctlprintk((": mptctl_cpq_getdriver called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(int))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_getdriver - "
+			"Unable to read in struct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_getdriver() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	strncpy(version, MPT_LINUX_VERSION_COMMON, 8);
+
+	karg = 0;
+	vptr = version;
+	ii = 3;
+	while (ii > 0) {
+		pptr = strchr(vptr, '.');
+		if (pptr) {
+			*pptr = '\0';
+			val = 0;
+			for (jj=0; vptr[jj]>='0' && vptr[jj]<='9'; jj++)
+				val = 10 * val + (vptr[jj] - '0');
+			karg |= (val << (8*ii));
+			pptr++;
+			vptr = pptr;
+		} else
+			break;
+		ii--;
+	}
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(int))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_getdriver - "
+			"Unable to write out stuct @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_ctlr_status - Get controller status in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ */
+static int
+mptctl_cpq_ctlr_status(unsigned long arg)
+{
+	cpqfc_ctlr_status *uarg = (cpqfc_ctlr_status *) arg;
+	cpqfc_ctlr_status karg;
+	MPT_ADAPTER		*ioc;
+	int			iocnum = 0, iocnumX = 0;
+
+	dctlprintk((": mptctl_cpq_pciinfo called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(cpqfc_ctlr_status))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_ctlr_status - "
+			"Unable to read in cpqfc_ctlr_status @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_ctlr_status() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	karg.status = ioc->last_state;
+	karg.offline_reason = 0;
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(cpqfc_ctlr_status))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_ctlr_status - "
+			"Unable to write out cpqfc_ctlr_status @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_target_address - Get WWN Information in format desired by Compaq
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
+static int
+mptctl_cpq_target_address(unsigned long arg)
+{
+	Scsi_FCTargAddress *uarg = (Scsi_FCTargAddress *) arg;
+	Scsi_FCTargAddress karg;
+	MPT_ADAPTER		*ioc;
+	int			iocnum = 0, iocnumX = 0;
+	CONFIGPARMS		cfg;
+	ConfigPageHeader_t	hdr;
+	dma_addr_t		buf_dma;
+	u8			*pbuf = NULL;
+	FCPortPage0_t		*ppp0;
+	int			ii, failed;
+	u32			low, high;
+
+	dctlprintk((": mptctl_cpq_target_address called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(Scsi_FCTargAddress))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_target_address - "
+			"Unable to read in Scsi_FCTargAddress @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_target_address() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	karg.host_port_id = 0;
+
+	/* Issue a config request to get the device wwn
+	 */
+	hdr.PageVersion = 0;
+	hdr.PageLength = 0;
+	hdr.PageNumber = 0;
+	hdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;
+	cfg.hdr = &hdr;
+	cfg.physAddr = -1;
+	cfg.pageAddr = 0;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
+	cfg.dir = 0;	/* read */
+	cfg.timeout = 10;
+
+	failed = 1;
+
+	if (mpt_config(ioc, &cfg) == 0) {
+		if (cfg.hdr->PageLength > 0) {
+			/* Issue the second config page request */
+			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+
+			pbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);
+			if (pbuf) {
+				cfg.physAddr = buf_dma;
+				if (mpt_config(ioc, &cfg) == 0) {
+					ppp0 = (FCPortPage0_t *) pbuf;
+
+					low = le32_to_cpu(ppp0->WWNN.Low);
+					high = le32_to_cpu(ppp0->WWNN.High);
+
+					for (ii = 0; ii < 4; ii++) {
+						karg.host_wwn[7-ii] = low & 0xFF;
+						karg.host_wwn[3-ii] = high & 0xFF;
+						low = (low >> 8);
+						high = (high >> 8);
+					}
+					failed = 0;
+				}
+				pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
+				pbuf = NULL;
+			}
+		}
+	}
+
+	if (failed) {
+		for (ii = 7; ii >= 0; ii--)
+			karg.host_wwn[ii] = 0;
+	}
+
+	/* Copy the data from kernel memory to user memory
+	 */
+	if (copy_to_user((char *)arg, &karg,
+				sizeof(Scsi_FCTargAddress))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_target_address - "
+			"Unable to write out Scsi_FCTargAddress @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_cpq_passthru - Construct and issue a SCSI IO Passthru
+ *
+ * Requires the SCSI host driver to be loaded.
+ * I386 version.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
+static int
+mptctl_cpq_passthru(unsigned long arg)
+{
+	VENDOR_IOCTL_REQ	*uarg = (VENDOR_IOCTL_REQ *) arg;
+	VENDOR_IOCTL_REQ	karg;
+	cpqfc_passthru_t	kpass;
+	MPT_ADAPTER		*ioc;
+	int			iocnum = 0, iocnumX = 0;
+	int			rc;
+
+	dctlprintk((": mptctl_cpq_passthru called.\n"));
+	if (copy_from_user(&karg, uarg, sizeof(VENDOR_IOCTL_REQ))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_passthru - "
+			"Unable to read in VENDOR_IOCTL_REQ @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	/* Set the IOC number */
+	iocnumX = karg.lc & 0xFF;
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR "%s::mptctl_cpq_passthru() @%d - ioc%d not found!\n",
+				__FILE__, __LINE__, iocnum);
+		return -ENODEV;
+	}
+
+	if (ioc->sh == NULL) {
+		printk(KERN_ERR "%s::mptctl_cpq_passthru() @%d - SCSI Host driver not loaded!\n",
+				__FILE__, __LINE__);
+		return -EFAULT;
+	}
+
+	/* Read in the second buffer */
+	if (copy_from_user(&kpass, uarg->argp, sizeof(cpqfc_passthru_t))) {
+		printk(KERN_ERR "%s@%d::mptctl_cpq_passthru - "
+			"Unable to read in cpqfc_passthru_t @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+
+	/* Generate the SCSI IO command and issue */
+	rc = mptctl_compaq_scsiio(&karg, &kpass);
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* mptctl_compaq_scsiio - Reformat Compaq structures into driver structures
+ * Call the generic _do_mpt_command function.
+ *
+ * Requires the SCSI host driver to be loaded.
+ * I386 version.
+ *
+ * Outputs:	None.
+ * Return:	0 if successful
+ *		-EBUSY  if previous command timout and IOC reset is not complete.
+ *		-EFAULT if data unavailable
+ *		-ENODEV if no such device/adapter
+ *		-ETIME	if timer expires
+ */
+static int
+mptctl_compaq_scsiio(VENDOR_IOCTL_REQ *pVenReq, cpqfc_passthru_t *pPass)
+{
+	struct mpt_ioctl_command karg;
+	SCSIIORequest_t		 request ;
+	SCSIIORequest_t		 *pMf;
+	int			 ii, rc;
+	u8			 opcode;
+
+	/* Fill in parameters to karg */
+	karg.hdr.iocnum = pVenReq->lc;
+	karg.hdr.port = 0;
+	karg.hdr.maxDataSize = 0;	/* not used */
+	karg.timeout = 0;		/* use default */
+
+	karg.replyFrameBufPtr = NULL;	/* no reply data */
+	karg.maxReplyBytes = 0;
+
+	karg.senseDataPtr = pPass->sense_data;
+	karg.maxSenseBytes = pPass->sense_len;	/* max is 40 */
+
+	if (pPass->rw_flag == MPT_COMPAQ_WRITE) {
+		karg.dataOutBufPtr = pPass->bufp;
+		karg.dataOutSize = pPass->len;
+		karg.dataInBufPtr = NULL;
+		karg.dataInSize = 0;
+	} else {
+		karg.dataInBufPtr = pPass->bufp;
+		karg.dataInSize = pPass->len;
+		karg.dataOutBufPtr = NULL;
+		karg.dataOutSize = 0;
+	}
+
+	karg.dataSgeOffset = (sizeof(SCSIIORequest_t) - sizeof(SGE_IO_UNION))/4;
+
+	/* Construct the Message frame */
+	pMf = &request;
+
+	pMf->TargetID =	(u8) pVenReq->ld;			/* ???? FIXME */
+	pMf->Bus = (u8) pPass->bus;
+	pMf->ChainOffset = 0;
+	pMf->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
+
+	/* May need some tweaking here */
+	opcode = (u8) pPass->cdb[0];
+	if (opcode < 0x20)
+		pMf->CDBLength = 6;
+	else if (opcode < 0x60)
+		pMf->CDBLength = 10;
+	else if ((opcode < 0xC0) && (opcode >= 0xA0))
+		pMf->CDBLength = 12;
+	else
+		pMf->CDBLength = 16;
+
+	pMf->SenseBufferLength = karg.maxSenseBytes;	/* max is 40 */
+	pMf->Reserved = 0;
+	pMf->MsgFlags = 0;				/* set later */
+	pMf->MsgContext = 0;				/* set later */
+
+	for (ii = 0; ii < 8; ii++)
+		pMf->LUN[ii] = 0;
+	pMf->LUN[1] = 0;				/* ???? FIXME */
+
+	/* Tag values set by _do_mpt_command */
+	if (pPass->rw_flag == MPT_COMPAQ_WRITE)
+		pMf->Control = MPI_SCSIIO_CONTROL_WRITE;
+	else
+		pMf->Control = MPI_SCSIIO_CONTROL_READ;
+
+	for (ii = 0; ii < 16; ii++)
+		pMf->CDB[ii] = pPass->cdb[ii];
+
+	pMf->DataLength = pPass->len;
+
+	/* All remaining fields are set by the next function
+	 */
+	rc = mptctl_do_mpt_command (karg, (char *)pMf, 1);
+	return rc;
+}
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,51)
+#define	owner_THIS_MODULE  owner:		THIS_MODULE,
+#else
+#define	owner_THIS_MODULE
+#endif
+
+static struct file_operations mptctl_fops = {
+	owner_THIS_MODULE
+	llseek:		no_llseek,
+	read:		mptctl_read,
+	write:		mptctl_write,
+	ioctl:		mptctl_ioctl,
+	open:		mptctl_open,
+	release:	mptctl_release,
+};
+
+static struct miscdevice mptctl_miscdev = {
+	MPT_MINOR,
+	MYNAM,
+	&mptctl_fops
+};
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+
+/* The dynamic ioctl32 compat. registry only exists in >2.3.x sparc64 kernels */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
 extern int register_ioctl32_conversion(unsigned int cmd,
 				       int (*handler)(unsigned int,
@@ -1133,18 +2773,15 @@
 						      unsigned long,
 						      struct file *));
 int unregister_ioctl32_conversion(unsigned int cmd);
-
-struct mpt_fw_xfer32 {
-	unsigned int iocnum;
-	unsigned int fwlen;
-	u32 bufp;
-};
-
-#define MPTFWDOWNLOAD32     _IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer32)
-
 extern asmlinkage int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* sparc32_XXX functions are used to provide a conversion between
+ * pointers and u32's. If the arg does not contain any pointers, then
+ * a specialized function (sparc32_XXX) is not needed. If the arg
+ * does contain pointer(s), then the specialized function is used
+ * to ensure the structure contents is properly processed by mptctl.
+ */
 static int
 sparc32_mptfwxfer_ioctl(unsigned int fd, unsigned int cmd,
 			unsigned long arg, struct file *filp)
@@ -1156,7 +2793,7 @@
 	int nonblock = (filp->f_flags & O_NONBLOCK);
 	int ret;
 
-	dprintk((KERN_INFO MYNAM "::sparc32_mptfwxfer_ioctl() called\n"));
+	dctlprintk((KERN_INFO MYNAM "::sparc32_mptfwxfer_ioctl() called\n"));
 
 	if (copy_from_user(&kfw32, (char *)arg, sizeof(kfw32)))
 		return -EFAULT;
@@ -1177,13 +2814,131 @@
 	kfw.fwlen = kfw32.fwlen;
 	kfw.bufp = (void *)(unsigned long)kfw32.bufp;
 
-	ret = mpt_ioctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
+	ret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
+
+	up(&mptctl_syscall_sem_ioc[iocp->id]);
+
+	return ret;
+}
+
+static int
+sparc32_mpt_command(unsigned int fd, unsigned int cmd,
+			unsigned long arg, struct file *filp)
+{
+	struct mpt_ioctl_command32 karg32;
+	struct mpt_ioctl_command32 *uarg = (struct mpt_ioctl_command32 *) arg;
+	struct mpt_ioctl_command karg;
+	MPT_ADAPTER *iocp = NULL;
+	int iocnum, iocnumX;
+	int nonblock = (filp->f_flags & O_NONBLOCK);
+	int ret;
+
+	dctlprintk((KERN_INFO MYNAM "::sparc32_mpt_command() called\n"));
+
+	if (copy_from_user(&karg32, (char *)arg, sizeof(karg32)))
+		return -EFAULT;
+
+	/* Verify intended MPT adapter */
+	iocnumX = karg32.hdr.iocnum & 0xFF;
+	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
+	    (iocp == NULL)) {
+		printk(KERN_ERR MYNAM "::sparc32_mpt_command @%d - ioc%d not found!\n",
+				__LINE__, iocnumX);
+		return -ENODEV;
+	}
+
+	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
+		return ret;
+
+	/* Copy data to karg */
+	karg.hdr.iocnum = karg32.hdr.iocnum;
+	karg.hdr.port = karg32.hdr.port;
+	karg.timeout = karg32.timeout;
+	karg.maxReplyBytes = karg32.maxReplyBytes;
+
+	karg.dataInSize = karg32.dataInSize;
+	karg.dataOutSize = karg32.dataOutSize;
+	karg.maxSenseBytes = karg32.maxSenseBytes;
+	karg.dataSgeOffset = karg32.dataSgeOffset;
+
+	karg.replyFrameBufPtr = (char *)(unsigned long)karg32.replyFrameBufPtr;
+	karg.dataInBufPtr = (char *)(unsigned long)karg32.dataInBufPtr;
+	karg.dataOutBufPtr = (char *)(unsigned long)karg32.dataOutBufPtr;
+	karg.senseDataPtr = (char *)(unsigned long)karg32.senseDataPtr;
+
+	/* Pass new structure to do_mpt_command
+	 */
+	ret = mptctl_do_mpt_command (karg, (char *) &uarg->MF, 0);
 
 	up(&mptctl_syscall_sem_ioc[iocp->id]);
 
 	return ret;
 }
 
+static int
+sparc32_mptctl_cpq_passthru(unsigned int fd, unsigned int cmd,
+			unsigned long arg, struct file *filp)
+{
+	VENDOR_IOCTL_REQ32	*uarg = (VENDOR_IOCTL_REQ32 *) arg;
+	VENDOR_IOCTL_REQ32	karg32;
+	VENDOR_IOCTL_REQ	karg;
+	cpqfc_passthru32_t	kpass32;
+	cpqfc_passthru_t	kpass;
+	MPT_ADAPTER		*ioc;
+	int			nonblock = (filp->f_flags & O_NONBLOCK);
+	int			iocnum = 0, iocnumX = 0;
+	int			rc;
+	int			ii;
+
+	dctlprintk((KERN_INFO MYNAM "::sparc32_mptctl_cpq_passthru() called\n"));
+
+	if (copy_from_user(&karg32, (char *)arg, sizeof(karg32)))
+		return -EFAULT;
+
+	/* Verify intended MPT adapter */
+	iocnumX = karg32.lc & 0xFF;
+	if (((iocnum = mpt_verify_adapter(iocnumX, &ioc)) < 0) ||
+	    (ioc == NULL)) {
+		printk(KERN_ERR MYNAM "::sparc32_mpt_command @%d - ioc%d not found!\n",
+				__LINE__, iocnumX);
+		return -ENODEV;
+	}
+
+	if ((rc = mptctl_syscall_down(ioc, nonblock)) != 0)
+		return rc;
+
+	/* Copy data to karg */
+	karg.ld = karg32.ld;
+	karg.node = karg32.node;
+	karg.lc = karg32.lc;
+	karg.nexus = karg32.nexus;
+	karg.argp = (void *)(unsigned long)karg32.argp;
+
+	/* Read in the second buffer */
+	if (copy_from_user(&kpass32, karg.argp, sizeof(cpqfc_passthru32_t))) {
+		printk(KERN_ERR "%s@%d::sparc32_mptctl_cpq_passthru - "
+			"Unable to read in cpqfc_passthru_t @ %p\n",
+				__FILE__, __LINE__, (void*)uarg);
+		return -EFAULT;
+	}
+
+	/* Copy the 32bit buffer to kpass */
+	for (ii = 0; ii < 16; ii++)
+		kpass.cdb[ii] = kpass32.cdb[ii];
+	kpass.bus = kpass32.bus;
+	kpass.pdrive = kpass32.pdrive;
+	kpass.len = kpass32.len;
+	kpass.sense_len = kpass32.sense_len;
+	kpass.bufp = (void *)(unsigned long)kpass32.bufp;
+	kpass.rw_flag = kpass32.rw_flag;
+
+	/* Generate the SCSI IO command and issue */
+	rc = mptctl_compaq_scsiio(&karg, &kpass);
+
+	up(&mptctl_syscall_sem_ioc[ioc->id]);
+	return rc;
+}
+
 #endif		/*} linux >= 2.3.x */
 #endif		/*} sparc */
 
@@ -1193,26 +2948,76 @@
 	int err;
 	int i;
 	int where = 1;
+	int sz;
+	u8 *mem;
+	MPT_ADAPTER *ioc = NULL;
+	int iocnum;
 
 	show_mptmod_ver(my_NAME, my_VERSION);
 
 	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
 		sema_init(&mptctl_syscall_sem_ioc[i], 1);
+
+		ioc = NULL;
+		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
+		    (ioc == NULL)) {
+			continue;
+		}
+		else {
+			/* This adapter instance is found.
+			 * Allocate and inite a MPT_IOCTL structure
+			 */
+			sz = sizeof (MPT_IOCTL);
+			mem = kmalloc(sz, GFP_KERNEL);
+			if (mem == NULL) {
+				err = -ENOMEM;
+				goto out_fail;
+			}
+
+			memset(mem, 0, sz);
+			ioc->ioctl = (MPT_IOCTL *) mem;
+			ioc->ioctl->ioc = ioc;
+			init_timer (&ioc->ioctl->timer);
+			ioc->ioctl->timer.data = (unsigned long) ioc->ioctl;
+			ioc->ioctl->timer.function = mptctl_timer_expired;
+		}
 	}
 
 #if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
-	err = register_ioctl32_conversion(MPTRWPERF, NULL);
+	err = register_ioctl32_conversion(MPTIOCINFO, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTTARGETINFO, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTTEST, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTEVENTQUERY, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTEVENTENABLE, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTEVENTREPORT, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTHARDRESET, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTCOMMAND32, sparc32_mpt_command);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(MPTFWDOWNLOAD32,
+					  sparc32_mptfwxfer_ioctl);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CPQFCTS_GETPCIINFO, NULL);
+	if (++where && err) goto out_fail;
+	err = register_ioctl32_conversion(CPQFCTS_CTLR_STATUS, NULL);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTRWPERF_CHK, NULL);
+	err = register_ioctl32_conversion(CPQFCTS_GETDRIVER, NULL);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTRWPERF_RESET, NULL);
+	err = register_ioctl32_conversion(CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS, NULL);
 	if (++where && err) goto out_fail;
-	err = register_ioctl32_conversion(MPTFWDOWNLOAD32, sparc32_mptfwxfer_ioctl);
+	err = register_ioctl32_conversion(CPQFCTS_SCSI_PASSTHRU32, sparc32_mptctl_cpq_passthru);
 	if (++where && err) goto out_fail;
 #endif		/*} linux >= 2.3.x */
 #endif		/*} sparc */
 
+	/* Register this device */
 	if (misc_register(&mptctl_miscdev) == -1) {
 		printk(KERN_ERR MYNAM ": Can't register misc device [minor=%d].\n", MPT_MINOR);
 		err = -EBUSY;
@@ -1226,13 +3031,19 @@
 	 *  Install our handler
 	 */
 	++where;
-	if ((mptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER)) <= 0) {
+	if ((mptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER)) < 0) {
 		printk(KERN_ERR MYNAM ": ERROR: Failed to register with Fusion MPT base driver\n");
 		misc_deregister(&mptctl_miscdev);
 		err = -EBUSY;
 		goto out_fail;
 	}
 
+	if (mpt_reset_register(mptctl_id, mptctl_ioc_reset) == 0) {
+		dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
+	} else {
+		/* FIXME! */
+	}
+
 	return 0;
 
 out_fail:
@@ -1241,35 +3052,72 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
 	printk(KERN_ERR MYNAM ": ERROR: Failed to register ioctl32_conversion!"
 			" (%d:err=%d)\n", where, err);
-	unregister_ioctl32_conversion(MPTRWPERF);
-	unregister_ioctl32_conversion(MPTRWPERF_CHK);
-	unregister_ioctl32_conversion(MPTRWPERF_RESET);
+	unregister_ioctl32_conversion(MPTIOCINFO);
+	unregister_ioctl32_conversion(MPTTARGETINFO);
+	unregister_ioctl32_conversion(MPTTEST);
+	unregister_ioctl32_conversion(MPTEVENTQUERY);
+	unregister_ioctl32_conversion(MPTEVENTENABLE);
+	unregister_ioctl32_conversion(MPTEVENTREPORT);
+	unregister_ioctl32_conversion(MPTHARDRESET);
+	unregister_ioctl32_conversion(MPTCOMMAND32);
 	unregister_ioctl32_conversion(MPTFWDOWNLOAD32);
+	unregister_ioctl32_conversion(CPQFCTS_GETPCIINFO);
+	unregister_ioctl32_conversion(CPQFCTS_GETDRIVER);
+	unregister_ioctl32_conversion(CPQFCTS_CTLR_STATUS);
+	unregister_ioctl32_conversion(CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS);
+	unregister_ioctl32_conversion(CPQFCTS_SCSI_PASSTHRU32);
 #endif		/*} linux >= 2.3.x */
 #endif		/*} sparc */
 
+	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
+		ioc = NULL;
+		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
+		    (ioc == NULL)) {
+			continue;
+		}
+		else {
+			if (ioc->ioctl) {
+				kfree ( ioc->ioctl );
+				ioc->ioctl = NULL;
+			}
+		}
+	}
 	return err;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 void mptctl_exit(void)
 {
-
-#if defined(__sparc__) && defined(__sparc_v9__)		/*{*/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)		/*{*/
-	unregister_ioctl32_conversion(MPTRWPERF);
-	unregister_ioctl32_conversion(MPTRWPERF_CHK);
-	unregister_ioctl32_conversion(MPTRWPERF_RESET);
-	unregister_ioctl32_conversion(MPTFWDOWNLOAD32);
-#endif		/*} linux >= 2.3.x */
-#endif		/*} sparc */
+	int i;
+	MPT_ADAPTER *ioc;
+	int iocnum;
 
 	misc_deregister(&mptctl_miscdev);
-	printk(KERN_INFO MYNAM ": /dev/%s @ (major,minor=%d,%d)\n",
+	printk(KERN_INFO MYNAM ": Deregistered /dev/%s @ (major,minor=%d,%d)\n",
 			 mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);
-	printk(KERN_INFO MYNAM ": Deregistered from Fusion MPT base driver\n");
 
+	/* De-register reset handler from base module */
+	mpt_reset_deregister(mptctl_id);
+	dprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
+
+	/* De-register callback handler from base module */
 	mpt_deregister(mptctl_id);
+	printk(KERN_INFO MYNAM ": Deregistered from Fusion MPT base driver\n");
+
+	/* Free allocated memory */
+	for (i=0; i<MPT_MAX_ADAPTERS; i++) {
+		ioc = NULL;
+		if (((iocnum = mpt_verify_adapter(i, &ioc)) < 0) ||
+		    (ioc == NULL)) {
+			continue;
+		}
+		else {
+			if (ioc->ioctl) {
+				kfree ( ioc->ioctl );
+				ioc->ioctl = NULL;
+			}
+		}
+	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptctl.h linux/drivers/message/fusion/mptctl.h
--- ../ia64/linux/drivers/message/fusion/mptctl.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/mptctl.h	Tue Mar 19 16:05:36 2002
@@ -0,0 +1,395 @@
+/*
+ *  linux/drivers/message/fusion/mptioctl.h
+ *      Fusion MPT misc device (ioctl) driver.
+ *      For use with PCI chip/adapter(s):
+ *          LSIFC9xx/LSI409xx Fibre Channel
+ *      running LSI Logic Fusion MPT (Message Passing Technology) firmware.
+ *
+ *  Credits:
+ *      This driver would not exist if not for Alan Cox's development
+ *      of the linux i2o driver.
+ *
+ *      A huge debt of gratitude is owed to David S. Miller (DaveM)
+ *      for fixing much of the stupid and broken stuff in the early
+ *      driver while porting to sparc64 platform.  THANK YOU!
+ *
+ *      (see also mptbase.c)
+ *
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
+ *  Originally By: Steven J. Ralston
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
+ *
+ *  $Id: mptctl.h,v 1.2 2002/03/19 23:05:36 awilliam Exp $
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    NO WARRANTY
+    THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
+    CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
+    LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
+    solely responsible for determining the appropriateness of using and
+    distributing the Program and assumes all risks associated with its
+    exercise of rights under this Agreement, including but not limited to
+    the risks and costs of program errors, damage to or loss of data,
+    programs or equipment, and unavailability or interruption of operations.
+
+    DISCLAIMER OF LIABILITY
+    NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
+    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+    DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
+    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+    USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+    HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef MPTCTL_H_INCLUDED
+#define MPTCTL_H_INCLUDED
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#include "linux/version.h"
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *
+ */
+#define MPT_MISCDEV_BASENAME            "mptctl"
+#define MPT_MISCDEV_PATHNAME            "/dev/" MPT_MISCDEV_BASENAME
+
+#define MPT_PRODUCT_LENGTH              12
+
+/*
+ *  Generic MPT Control IOCTLs and structures
+ */
+#define MPT_MAGIC_NUMBER	'm'
+
+#define MPTRWPERF		_IOWR(MPT_MAGIC_NUMBER,0,struct mpt_raw_r_w)
+
+#define MPTFWDOWNLOAD		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer)
+#define MPTCOMMAND		_IOWR(MPT_MAGIC_NUMBER,20,struct mpt_ioctl_command)
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+#define MPTFWDOWNLOAD32		_IOWR(MPT_MAGIC_NUMBER,15,struct mpt_fw_xfer32)
+#define MPTCOMMAND32		_IOWR(MPT_MAGIC_NUMBER,20,struct mpt_ioctl_command32)
+#endif	/*}*/
+
+#define MPTIOCINFO		_IOWR(MPT_MAGIC_NUMBER,17,struct mpt_ioctl_iocinfo)
+#define MPTTARGETINFO		_IOWR(MPT_MAGIC_NUMBER,18,struct mpt_ioctl_targetinfo)
+#define MPTTEST			_IOWR(MPT_MAGIC_NUMBER,19,struct mpt_ioctl_test)
+#define MPTEVENTQUERY		_IOWR(MPT_MAGIC_NUMBER,21,struct mpt_ioctl_eventquery)
+#define MPTEVENTENABLE		_IOWR(MPT_MAGIC_NUMBER,22,struct mpt_ioctl_eventenable)
+#define MPTEVENTREPORT		_IOWR(MPT_MAGIC_NUMBER,23,struct mpt_ioctl_eventreport)
+#define MPTHARDRESET		_IOWR(MPT_MAGIC_NUMBER,24,struct mpt_ioctl_diag_reset)
+#define MPTFWREPLACE		_IOWR(MPT_MAGIC_NUMBER,25,struct mpt_ioctl_replace_fw)
+
+/*
+ * SPARC PLATFORM REMARK:
+ * IOCTL data structures that contain pointers
+ * will have different sizes in the driver and applications
+ * (as the app. will not use 8-byte pointers).
+ * Apps should use MPTFWDOWNLOAD and MPTCOMMAND.
+ * The driver will convert data from
+ * mpt_fw_xfer32 (mpt_ioctl_command32) to mpt_fw_xfer (mpt_ioctl_command)
+ * internally.
+ */
+struct mpt_fw_xfer {
+	unsigned int	 iocnum;	/* IOC unit number */
+	unsigned int	 fwlen;
+	void		*bufp;		/* Pointer to firmware buffer */
+};
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+struct mpt_fw_xfer32 {
+	unsigned int iocnum;
+	unsigned int fwlen;
+	u32 bufp;
+};
+#endif	/*}*/
+
+
+/*
+ *  IOCTL header structure.
+ *  iocnum - must be defined.
+ *  port - must be defined for all IOCTL commands other than MPTIOCINFO
+ *  maxDataSize - ignored on MPTCOMMAND commands
+ *		- ignored on MPTFWREPLACE commands
+ *		- on query commands, reports the maximum number of bytes to be returned
+ *		  to the host driver (count includes the header).
+ *		  That is, set to sizeof(struct mpt_ioctl_iocinfo) for fixed sized commands.
+ *		  Set to sizeof(struct mpt_ioctl_targetinfo) + datasize for variable
+ *			sized commands. (MPTTARGETINFO, MPTEVENTREPORT)
+ */
+typedef struct _mpt_ioctl_header {
+	unsigned int	 iocnum;	/* IOC unit number */
+	unsigned int	 port;		/* IOC port number */
+	int		 maxDataSize;	/* Maximum Num. bytes to transfer on read */
+} mpt_ioctl_header;
+
+/*
+ * Issue a diagnostic reset
+ */
+struct mpt_ioctl_diag_reset {
+	mpt_ioctl_header hdr;
+};
+
+
+/*
+ *  Adapter Information Page
+ *  Read only.
+ *  Data starts at offset 0xC
+ */
+#define MPT_IOCTL_INTERFACE_FC		(0x01)
+#define MPT_IOCTL_INTERFACE_SCSI	(0x00)
+#define MPT_IOCTL_VERSION_LENGTH	(32)
+
+struct mpt_ioctl_iocinfo {
+	mpt_ioctl_header hdr;
+	int		 adapterType;	/* SCSI or FCP */
+	int		 port;		/* port number */
+	int		 pciId;		/* PCI Id. */
+	int		 hwRev;		/* hardware revision */
+	int		 subSystemDevice;	/* PCI subsystem Device ID */
+	int		 subSystemVendor;	/* PCI subsystem Vendor ID */
+	int		 numDevices;		/* number of devices */
+	int		 FWVersion;		/* FW Version (integer) */
+	int		 BIOSVersion;		/* BIOS Version (integer) */
+	char		 driverVersion[MPT_IOCTL_VERSION_LENGTH];	/* Driver Version (string) */
+	char		 busChangeEvent;
+	char		 hostId;
+	char		 rsvd[2];
+};
+
+/*
+ * Device Information Page
+ * Report the number of, and ids of, all targets
+ * on this IOC.  The ids array is a packed structure
+ * of the known targetInfo.
+ * bits 31-24: reserved
+ *      23-16: LUN
+ *      15- 8: Bus Number
+ *       7- 0: Target ID
+ */
+struct mpt_ioctl_targetinfo {
+	mpt_ioctl_header hdr;
+	int		 numDevices;	/* Num targets on this ioc */
+	int		 targetInfo[1];
+};
+
+
+/*
+ * Event reporting IOCTL's.  These IOCTL's will
+ * use the following defines:
+ */
+struct mpt_ioctl_eventquery {
+	mpt_ioctl_header hdr;
+	unsigned short	 eventEntries;
+	unsigned short	 reserved;
+	unsigned int	 eventTypes;
+};
+
+struct mpt_ioctl_eventenable {
+	mpt_ioctl_header hdr;
+	unsigned int	 eventTypes;
+};
+
+#ifndef __KERNEL__
+typedef struct {
+	uint	event;
+	uint	eventContext;
+	uint	data[2];
+} MPT_IOCTL_EVENTS;
+#endif
+
+struct mpt_ioctl_eventreport {
+	mpt_ioctl_header	hdr;
+	MPT_IOCTL_EVENTS	eventData[1];
+};
+
+#define MPT_MAX_NAME	32
+struct mpt_ioctl_test {
+	mpt_ioctl_header hdr;
+	u8		 name[MPT_MAX_NAME];
+	int		 chip_type;
+	u8		 product [MPT_PRODUCT_LENGTH];
+};
+
+/* Replace the FW image cached in host driver memory
+ * newImageSize - image size in bytes
+ * newImage - first byte of the new image
+ */
+typedef struct mpt_ioctl_replace_fw {
+	mpt_ioctl_header hdr;
+	int		 newImageSize;
+	u8		 newImage[1];
+} mpt_ioctl_replace_fw_t;
+
+/* General MPT Pass through data strucutre
+ *
+ * iocnum
+ * timeout - in seconds, command timeout. If 0, set by driver to
+ *		default value.
+ * replyFrameBufPtr - reply location
+ * dataInBufPtr - destination for read
+ * dataOutBufPtr - data source for write
+ * senseDataPtr - sense data location
+ * maxReplyBytes - maximum number of reply bytes to be sent to app.
+ * dataInSize - num bytes for data transfer in (read)
+ * dataOutSize - num bytes for data transfer out (write)
+ * dataSgeOffset - offset in words from the start of the request message
+ *		to the first SGL
+ * MF[1];
+ *
+ * Remark:  Some config pages have bi-directional transfer,
+ * both a read and a write. The basic structure allows for
+ * a bidirectional set up. Normal messages will have one or
+ * both of these buffers NULL.
+ */
+struct mpt_ioctl_command {
+	mpt_ioctl_header hdr;
+	int		timeout;	/* optional (seconds) */
+	char		*replyFrameBufPtr;
+	char		*dataInBufPtr;
+	char		*dataOutBufPtr;
+	char		*senseDataPtr;
+	int		maxReplyBytes;
+	int		dataInSize;
+	int		dataOutSize;
+	int		maxSenseBytes;
+	int		dataSgeOffset;
+	char		MF[1];
+};
+
+/*
+ * SPARC PLATFORM: See earlier remark.
+ */
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+struct mpt_ioctl_command32 {
+	mpt_ioctl_header hdr;
+	int	timeout;
+	u32	replyFrameBufPtr;
+	u32	dataInBufPtr;
+	u32	dataOutBufPtr;
+	u32	senseDataPtr;
+	int	maxReplyBytes;
+	int	dataInSize;
+	int	dataOutSize;
+	int	maxSenseBytes;
+	int	dataSgeOffset;
+	char	MF[1];
+};
+#endif	/*}*/
+
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+ /*
+  *	COMPAQ Specific IOCTL Defines and Structures
+  */
+
+#define CPQFCTS_IOC_MAGIC 'Z'
+
+#define CPQFCTS_GETPCIINFO		_IOR(CPQFCTS_IOC_MAGIC, 1, cpqfc_pci_info_struct)
+#define CPQFCTS_GETDRIVER		_IOR(CPQFCTS_IOC_MAGIC, 2, int)
+#define CPQFCTS_CTLR_STATUS		_IOR(CPQFCTS_IOC_MAGIC, 3, struct _cpqfc_ctlr_status)
+#define CPQFCTS_SCSI_IOCTL_FC_TARGET_ADDRESS	_IOR(CPQFCTS_IOC_MAGIC, 4, struct scsi_fctargaddress)
+#define CPQFCTS_SCSI_PASSTHRU		_IOWR(CPQFCTS_IOC_MAGIC, 5, VENDOR_IOCTL_REQ)
+#if defined(__sparc__) && defined(__sparc_v9__)
+#define CPQFCTS_SCSI_PASSTHRU32		_IOWR(CPQFCTS_IOC_MAGIC, 5, VENDOR_IOCTL_REQ32)
+#endif
+
+typedef struct {
+	unsigned short bus;
+	unsigned short bus_type;
+	unsigned short device_fn;
+	u32 board_id;
+	u32 slot_number;
+	unsigned short vendor_id;
+	unsigned short device_id;
+	unsigned short class_code;
+	unsigned short sub_vendor_id;
+	unsigned short sub_device_id;
+	u8 serial_number[81];
+} cpqfc_pci_info_struct;
+
+
+typedef struct scsi_fctargaddress {
+	unsigned int host_port_id;
+	u8 host_wwn[8];	/* WW Network Name */
+} Scsi_FCTargAddress;
+
+typedef struct _cpqfc_ctlr_status {
+	u32 status;
+	u32 offline_reason;
+} cpqfc_ctlr_status;
+
+
+/* Compaq SCSI I/O Passthru structures.
+ */
+#define MPT_COMPAQ_READ		0x26
+#define MPT_COMPAQ_WRITE	0x27
+
+typedef struct {
+	int lc;		/* controller number */
+	int node;	/* node number */
+	int ld;		/* target logical id */
+	u32 nexus;
+	void *argp;
+} VENDOR_IOCTL_REQ;
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+typedef struct {
+	int lc;		/* controller number */
+	int node;	/* node number */
+	int ld;		/* target logical id */
+	u32 nexus;
+	u32 argp;
+} VENDOR_IOCTL_REQ32;
+#endif
+
+typedef struct {
+	char cdb[16];		/* cdb */
+	unsigned short bus;	/* bus number */
+	unsigned short pdrive;	/* physical drive */
+	int len;		/* data area size */
+	int sense_len;		/* sense size */
+	char sense_data[40];	/* sense buffer */
+	void *bufp;		/* data buffer pointer */
+	char rw_flag;
+} cpqfc_passthru_t;
+
+#if defined(__KERNEL__) && defined(__sparc__) && defined(__sparc_v9__)		/*{*/
+typedef struct {
+	char cdb[16];		/* cdb */
+	unsigned short bus;	/* bus number */
+	unsigned short pdrive;	/* physical drive */
+	int len;		/* data area size */
+	int sense_len;		/* sense size */
+	char sense_data[40];	/* sense buffer */
+	u32 bufp;		/* data buffer pointer */
+	char rw_flag;
+} cpqfc_passthru32_t;
+#endif
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+#endif
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptlan.c linux/drivers/message/fusion/mptlan.c
--- ../ia64/linux/drivers/message/fusion/mptlan.c	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/mptlan.c	Tue Mar 19 16:05:36 2002
@@ -23,10 +23,10 @@
  *
  *      (see also mptbase.c)
  *
- *  Copyright (c) 2000-2001 LSI Logic Corporation
+ *  Copyright (c) 2000-2002 LSI Logic Corporation
  *  Originally By: Noah Romer
  *
- *  $Id: mptlan.c,v 1.32.2.2 2001/07/12 19:43:33 nromer Exp $
+ *  $Id: mptlan.c,v 1.51 2002/02/11 14:40:55 sralston Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -79,6 +79,8 @@
 
 #define MYNAM		"mptlan"
 
+MODULE_LICENSE("GPL");
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  * MPT LAN message sizes without variable part.
@@ -109,8 +111,8 @@
 	MPT_ADAPTER *mpt_dev;
 	u8 pnum; /* Port number in the IOC. This is not a Unix network port! */
 
-	atomic_t buckets_out;	  	/* number of unused buckets on IOC */
-	int bucketthresh;		/* Send more when this many used */
+	atomic_t buckets_out;		/* number of unused buckets on IOC */
+	int bucketthresh;		/* Send more when this many left */
 
 	int *mpt_txfidx; /* Free Tx Context list */
 	int mpt_txfidx_tail;
@@ -123,8 +125,8 @@
 	struct BufferControl *RcvCtl;	/* Receive BufferControl structs */
 	struct BufferControl *SendCtl;	/* Send BufferControl structs */
 
-	int max_buckets_out;	   	/* Max buckets to send to IOC */
-	int tx_max_out;		   	/* IOC's Tx queue len */
+	int max_buckets_out;		/* Max buckets to send to IOC */
+	int tx_max_out;			/* IOC's Tx queue len */
 
 	u32 total_posted;
 	u32 total_received;
@@ -152,7 +154,8 @@
 static int  mpt_lan_reset(struct net_device *dev);
 static int  mpt_lan_close(struct net_device *dev);
 static void mpt_lan_post_receive_buckets(void *dev_id);
-static void mpt_lan_wake_post_buckets_task(struct net_device *dev);
+static void mpt_lan_wake_post_buckets_task(struct net_device *dev, 
+					   int priority);
 static int  mpt_lan_receive_post_turbo(struct net_device *dev, u32 tmsg);
 static int  mpt_lan_receive_post_reply(struct net_device *dev,
 				       LANReceivePostReply_t *pRecvRep);
@@ -175,8 +178,10 @@
 
 static struct net_device *mpt_landev[MPT_MAX_ADAPTERS+1];
 
+#ifdef QLOGIC_NAA_WORKAROUND
 static struct NAA_Hosed *mpt_bad_naa = NULL;
 rwlock_t bad_naa_lock;
+#endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -229,7 +234,7 @@
 		case LAN_REPLY_FORM_SEND_SINGLE:
 //			dioprintk((MYNAM "/lan_reply: "
 //				  "calling mpt_lan_send_reply (turbo)\n"));
-  
+
 			// Potential BUG here?  -sralston
 			//	FreeReqFrame = mpt_lan_send_turbo(dev, tmsg);
 			//  If/when mpt_lan_send_turbo would return 1 here,
@@ -333,7 +338,7 @@
 	struct net_device *dev = mpt_landev[ioc->id];
 	struct mpt_lan_priv *priv = (struct mpt_lan_priv *) dev->priv;
 
-	dprintk((KERN_INFO MYNAM ": IOC %s_reset routed to LAN driver!\n",
+	dlprintk((KERN_INFO MYNAM ": IOC %s_reset routed to LAN driver!\n",
 			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
 
 	if (priv->mpt_rxfidx == NULL)
@@ -342,9 +347,11 @@
 	if (reset_phase == MPT_IOC_PRE_RESET) {
 		int i;
 		unsigned long flags;
-		
+
 		netif_stop_queue(dev);
 
+		dlprintk ((KERN_INFO "mptlan/ioc_reset: called netif_stop_queue for %s.\n", dev->name));
+
 		atomic_set(&priv->buckets_out, 0);
 
 		/* Reset Rx Free Tail index and re-populate the queue. */
@@ -365,7 +372,7 @@
 static int
 mpt_lan_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)
 {
-	dprintk((KERN_INFO MYNAM ": MPT event routed to LAN driver!\n"));
+	dlprintk((KERN_INFO MYNAM ": MPT event routed to LAN driver!\n"));
 
 	switch (le32_to_cpu(pEvReply->Event)) {
 	case MPI_EVENT_NONE:				/* 00 */
@@ -403,9 +410,9 @@
 
 	if (mpt_lan_reset(dev) != 0) {
 		MPT_ADAPTER *mpt_dev = priv->mpt_dev;
-		
+
 		printk (KERN_WARNING MYNAM "/lan_open: lan_reset failed.");
-		
+
 		if (mpt_dev->active)
 			printk ("The ioc is active. Perhaps it needs to be"
 				" reset?\n");
@@ -429,7 +436,7 @@
 		priv->mpt_txfidx[++priv->mpt_txfidx_tail] = i;
 	}
 
-	dprintk((KERN_INFO MYNAM "@lo: Finished initializing SendCtl\n"));
+	dlprintk((KERN_INFO MYNAM "@lo: Finished initializing SendCtl\n"));
 
 	priv->mpt_rxfidx = kmalloc(priv->max_buckets_out * sizeof(int),
 				   GFP_KERNEL);
@@ -447,12 +454,12 @@
 		priv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = i;
 	}
 
-/**/	dprintk((KERN_INFO MYNAM "/lo: txfidx contains - "));
+/**/	dlprintk((KERN_INFO MYNAM "/lo: txfidx contains - "));
 /**/	for (i = 0; i < priv->tx_max_out; i++)
-/**/		dprintk((" %xh", priv->mpt_txfidx[i]));
-/**/	dprintk(("\n"));
+/**/		dlprintk((" %xh", priv->mpt_txfidx[i]));
+/**/	dlprintk(("\n"));
 
-	dprintk((KERN_INFO MYNAM "/lo: Finished initializing RcvCtl\n"));
+	dlprintk((KERN_INFO MYNAM "/lo: Finished initializing RcvCtl\n"));
 
 	mpt_lan_post_receive_buckets(dev);
 	printk(KERN_INFO MYNAM ": %s/%s: interface up & active\n",
@@ -466,7 +473,7 @@
 	}
 
 	netif_start_queue(dev);
-	dprintk((KERN_INFO MYNAM "/lo: Done.\n"));
+	dlprintk((KERN_INFO MYNAM "/lo: Done.\n"));
 
 	return 0;
 out_mpt_rxfidx:
@@ -494,7 +501,7 @@
 	mf = mpt_get_msg_frame(LanCtx, priv->mpt_dev->id);
 
 	if (mf == NULL) {
-/*		dprintk((KERN_ERR MYNAM "/reset: Evil funkiness abounds! "
+/*		dlprintk((KERN_ERR MYNAM "/reset: Evil funkiness abounds! "
 		"Unable to allocate a request frame.\n"));
 */
 		return -1;
@@ -523,11 +530,11 @@
 	unsigned int timeout;
 	int i;
 
-	dprintk((KERN_INFO MYNAM ": mpt_lan_close called\n"));
+	dlprintk((KERN_INFO MYNAM ": mpt_lan_close called\n"));
 
 	mpt_event_deregister(LanCtx);
 
-	dprintk((KERN_INFO MYNAM ":lan_close: Posted %d buckets "
+	dlprintk((KERN_INFO MYNAM ":lan_close: Posted %d buckets "
 		  "since driver was loaded, %d still out\n",
 		  priv->total_posted,atomic_read(&priv->buckets_out)));
 
@@ -537,18 +544,18 @@
 
 	timeout = 2 * HZ;
 	while (atomic_read(&priv->buckets_out) && --timeout) {
-		current->state = TASK_INTERRUPTIBLE;
+		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(1);
 	}
 
 	for (i = 0; i < priv->max_buckets_out; i++) {
 		if (priv->RcvCtl[i].skb != NULL) {
-/**/			dprintk((KERN_INFO MYNAM "/lan_close: bucket %05x "
+/**/			dlprintk((KERN_INFO MYNAM "/lan_close: bucket %05x "
 /**/				  "is still out\n", i));
 			pci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[i].dma,
-				 	 priv->RcvCtl[i].len,
+					 priv->RcvCtl[i].len,
 					 PCI_DMA_FROMDEVICE);
- 			dev_kfree_skb(priv->RcvCtl[i].skb);
+			dev_kfree_skb(priv->RcvCtl[i].skb);
 		}
 	}
 
@@ -556,11 +563,11 @@
 	kfree (priv->mpt_rxfidx);
 
 	for (i = 0; i < priv->tx_max_out; i++) {
- 		if (priv->SendCtl[i].skb != NULL) {
+		if (priv->SendCtl[i].skb != NULL) {
 			pci_unmap_single(mpt_dev->pcidev, priv->SendCtl[i].dma,
 					 priv->SendCtl[i].len,
 					 PCI_DMA_TODEVICE);
- 			dev_kfree_skb(priv->SendCtl[i].skb);
+			dev_kfree_skb(priv->SendCtl[i].skb);
 		}
 	}
 
@@ -599,7 +606,13 @@
 static void
 mpt_lan_tx_timeout(struct net_device *dev)
 {
-	netif_wake_queue(dev);  
+	struct mpt_lan_priv *priv = (struct mpt_lan_priv *) dev->priv;
+	MPT_ADAPTER *mpt_dev = priv->mpt_dev;
+
+	if (mpt_dev->active) {
+		dlprintk (("mptlan/tx_timeout: calling netif_wake_queue for %s.\n", dev->name));
+		netif_wake_queue(dev);
+	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
@@ -722,7 +735,6 @@
 	dma_addr_t dma;
 	unsigned long flags;
 	int ctx;
-	struct NAA_Hosed *nh;
 	u16 cur_naa = 0x1000;
 
 	dioprintk((KERN_INFO MYNAM ": %s called, skb_addr = %p\n",
@@ -741,7 +753,6 @@
 	mf = mpt_get_msg_frame(LanCtx, mpt_dev->id);
 	if (mf == NULL) {
 		netif_stop_queue(dev);
-		dev_kfree_skb(skb);
 		spin_unlock_irqrestore(&priv->txfidx_lock, flags);
 
 		printk (KERN_ERR "%s: Unable to alloc request frame\n",
@@ -791,6 +802,10 @@
 //			IOC_AND_NETDEV_NAMES_s_s(dev),
 //			ctx, skb, skb->data));
 
+#ifdef QLOGIC_NAA_WORKAROUND
+{
+	struct NAA_Hosed *nh;
+
 	/* Munge the NAA for Tx packets to QLogic boards, which don't follow
 	   RFC 2625. The longer I look at this, the more my opinion of Qlogic
 	   drops. */
@@ -803,12 +818,14 @@
 		    (nh->ieee[4] == skb->mac.raw[4]) &&
 		    (nh->ieee[5] == skb->mac.raw[5])) {
 			cur_naa = nh->NAA;
-			dprintk ((KERN_INFO "mptlan/sdu_send: using NAA value "
+			dlprintk ((KERN_INFO "mptlan/sdu_send: using NAA value "
 				  "= %04x.\n", cur_naa));
 			break;
 		}
 	}
 	read_unlock_irq(&bad_naa_lock);
+}
+#endif
 
 	pTrans->TransactionDetails[0] = cpu_to_le32((cur_naa         << 16) |
 						    (skb->mac.raw[0] <<  8) |
@@ -821,10 +838,10 @@
 	pSimple = (SGESimple64_t *) &pTrans->TransactionDetails[2];
 
 	/* If we ever decide to send more than one Simple SGE per LANSend, then
-	   we will need to make sure that LAST_ELEMENT only gets set on the 
+	   we will need to make sure that LAST_ELEMENT only gets set on the
 	   last one. Otherwise, bad voodoo and evil funkiness will commence. */
 	pSimple->FlagsLength = cpu_to_le32(
-			((MPI_SGE_FLAGS_LAST_ELEMENT | 
+			((MPI_SGE_FLAGS_LAST_ELEMENT |
 			  MPI_SGE_FLAGS_END_OF_BUFFER |
 			  MPI_SGE_FLAGS_SIMPLE_ELEMENT |
 			  MPI_SGE_FLAGS_SYSTEM_ADDRESS |
@@ -842,23 +859,32 @@
 	dev->trans_start = jiffies;
 
 	dioprintk((KERN_INFO MYNAM ": %s/%s: Sending packet. FlagsLength = %08x.\n",
-		 	IOC_AND_NETDEV_NAMES_s_s(dev),
-		       	le32_to_cpu(pSimple->FlagsLength)));
+			IOC_AND_NETDEV_NAMES_s_s(dev),
+			le32_to_cpu(pSimple->FlagsLength)));
 
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static inline void
-mpt_lan_wake_post_buckets_task(struct net_device *dev)
+mpt_lan_wake_post_buckets_task(struct net_device *dev, int priority)
+/* 
+ * @priority: 0 = put it on the timer queue, 1 = put it on the immediate queue
+ */
 {
 	struct mpt_lan_priv *priv = dev->priv;
-
+	
 	if (test_and_set_bit(0, &priv->post_buckets_active) == 0) {
-		queue_task(&priv->post_buckets_task, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
-		dioprintk((KERN_INFO MYNAM ": %s/%s: Queued post_buckets task.\n",
-				IOC_AND_NETDEV_NAMES_s_s(dev) ));
+		if (priority) {
+			queue_task(&priv->post_buckets_task, &tq_immediate);
+			mark_bh(IMMEDIATE_BH);
+		} else {
+			queue_task(&priv->post_buckets_task, &tq_timer);
+			dioprintk((KERN_INFO MYNAM ": post_buckets queued on "
+				   "timer.\n"));
+		}
+	        dioprintk((KERN_INFO MYNAM ": %s/%s: Queued post_buckets task.\n",
+			   IOC_AND_NETDEV_NAMES_s_s(dev) ));
 	}
 }
 
@@ -870,7 +896,7 @@
 
 	skb->protocol = mpt_lan_type_trans(skb, dev);
 
-	dioprintk((KERN_INFO MYNAM ": %s/%s: Incoming packet (%d bytes) " 
+	dioprintk((KERN_INFO MYNAM ": %s/%s: Incoming packet (%d bytes) "
 		 "delivered to upper level.\n",
 			IOC_AND_NETDEV_NAMES_s_s(dev), skb->len));
 
@@ -884,7 +910,7 @@
 		 atomic_read(&priv->buckets_out)));
 
 	if (atomic_read(&priv->buckets_out) < priv->bucketthresh)
-		mpt_lan_wake_post_buckets_task(dev);
+		mpt_lan_wake_post_buckets_task(dev, 1);
 
 	dioprintk((KERN_INFO MYNAM "/receive_post_reply: %d buckets "
 		  "remaining, %d received back since sod\n",
@@ -956,12 +982,12 @@
 	unsigned long flags;
 	struct sk_buff *skb;
 	u32 ctx;
-	u8 count;
+	int count;
 	int i;
 
 	count = pRecvRep->NumberOfContexts;
 
-/**/	dprintk((KERN_INFO MYNAM "/receive_post_reply: "
+/**/	dlprintk((KERN_INFO MYNAM "/receive_post_reply: "
 		  "IOC returned %d buckets, freeing them...\n", count));
 
 	spin_lock_irqsave(&priv->rxfidx_lock, flags);
@@ -970,11 +996,11 @@
 
 		skb = priv->RcvCtl[ctx].skb;
 
-//		dprintk((KERN_INFO MYNAM ": %s: dev_name = %s\n",
+//		dlprintk((KERN_INFO MYNAM ": %s: dev_name = %s\n",
 //				IOC_AND_NETDEV_NAMES_s_s(dev)));
-//		dprintk((KERN_INFO MYNAM "@rpr[2], priv = %p, buckets_out addr = %p",
-//			  	priv, &(priv->buckets_out)));
-//		dprintk((KERN_INFO MYNAM "@rpr[2] TC + 3\n"));
+//		dlprintk((KERN_INFO MYNAM "@rpr[2], priv = %p, buckets_out addr = %p",
+//				priv, &(priv->buckets_out)));
+//		dlprintk((KERN_INFO MYNAM "@rpr[2] TC + 3\n"));
 
 		priv->RcvCtl[ctx].skb = NULL;
 		pci_unmap_single(mpt_dev->pcidev, priv->RcvCtl[ctx].dma,
@@ -989,13 +1015,13 @@
 
 //	for (i = 0; i < priv->max_buckets_out; i++)
 //		if (priv->RcvCtl[i].skb != NULL)
-//			dprintk((KERN_INFO MYNAM "@rpr: bucket %03x "
+//			dlprintk((KERN_INFO MYNAM "@rpr: bucket %03x "
 //				  "is still out\n", i));
 
-/*	dprintk((KERN_INFO MYNAM "/receive_post_reply: freed %d buckets\n",
+/*	dlprintk((KERN_INFO MYNAM "/receive_post_reply: freed %d buckets\n",
 		  count));
 */
-/**/	dprintk((KERN_INFO MYNAM "@receive_post_reply: %d buckets "
+/**/	dlprintk((KERN_INFO MYNAM "@receive_post_reply: %d buckets "
 /**/		  "remaining, %d received back since sod.\n",
 /**/		  atomic_read(&priv->buckets_out), priv->total_received));
 	return 0;
@@ -1010,9 +1036,9 @@
 	MPT_ADAPTER *mpt_dev = priv->mpt_dev;
 	struct sk_buff *skb, *old_skb;
 	unsigned long flags;
-	u32 len, ctx;
-	u32 offset;
-	u8 count;
+	u32 len, ctx, offset;
+	u32 remaining = le32_to_cpu(pRecvRep->BucketsRemaining);
+	int count;
 	int i, l;
 
 	dioprintk((KERN_INFO MYNAM ": mpt_lan_receive_post_reply called\n"));
@@ -1059,7 +1085,7 @@
 		if (!skb) {
 			printk (KERN_ERR MYNAM ": %s/%s: ERROR - Can't allocate skb! (%s@%d)\n",
 					IOC_AND_NETDEV_NAMES_s_s(dev),
-			       		__FILE__, __LINE__);
+					__FILE__, __LINE__);
 			return -ENOMEM;
 		}
 
@@ -1096,7 +1122,7 @@
 		if (!skb) {
 			printk (KERN_ERR MYNAM ": %s/%s: ERROR - Can't allocate skb! (%s@%d)\n",
 					IOC_AND_NETDEV_NAMES_s_s(dev),
-			       		__FILE__, __LINE__);
+					__FILE__, __LINE__);
 			return -ENOMEM;
 		}
 
@@ -1140,25 +1166,32 @@
 				"Arrgghh! We've done it again!\n");
 	}
 
-#if 0
-	{
-		u32 remaining = le32_to_cpu(pRecvRep->BucketsRemaining);
-		if (remaining < priv->bucketthresh)
-			mpt_lan_wake_post_buckets_task(dev);
-
-		if (remaining == 0)
-			printk (KERN_WARNING MYNAM ": %s/%s: WARNING - IOC out of buckets! "
-				"(priv->buckets_out = %d)\n",
-					IOC_AND_NETDEV_NAMES_s_s(dev),
-					atomic_read(&priv->buckets_out));
-		else
-			printk (KERN_INFO MYNAM ": %s/%s: IOC says %d buckets left. "
-				"(priv->buckets_out = %d)\n",
-					IOC_AND_NETDEV_NAMES_s_s(dev),
-					remaining, atomic_read(&priv->buckets_out));
+	if (remaining == 0)
+		printk (KERN_WARNING MYNAM ": %s/%s: WARNING - IOC out of buckets! "
+			"(priv->buckets_out = %d)\n",
+			IOC_AND_NETDEV_NAMES_s_s(dev),
+			atomic_read(&priv->buckets_out));
+	else if (remaining < 10)
+		printk (KERN_INFO MYNAM ": %s/%s: IOC says %d buckets left. "
+			"(priv->buckets_out = %d)\n",
+			IOC_AND_NETDEV_NAMES_s_s(dev),
+			remaining, atomic_read(&priv->buckets_out));
+	
+	if ((remaining < priv->bucketthresh) &&
+	    ((atomic_read(&priv->buckets_out) - remaining) > 
+	     MPT_LAN_BUCKETS_REMAIN_MISMATCH_THRESH)) {
+		
+		printk (KERN_WARNING MYNAM " Mismatch between driver's "
+			"buckets_out count and fw's BucketsRemaining "
+			"count has crossed the threshold, issuing a "
+			"LanReset to clear the fw's hashtable. You may "
+			"want to check your /var/log/messages for \"CRC "
+			"error\" event notifications.\n");
+		
+		mpt_lan_reset(dev);
+		mpt_lan_wake_post_buckets_task(dev, 0);
 	}
-#endif
-
+	
 	return mpt_lan_receive_skb(dev, skb);
 }
 
@@ -1242,15 +1275,15 @@
 			if (skb == NULL) {
 				skb = dev_alloc_skb(len);
 				if (skb == NULL) {
-/**/					printk (KERN_WARNING
-/**/						MYNAM "/%s: Can't alloc skb\n",
-/**/						__FUNCTION__);
+					printk (KERN_WARNING
+						MYNAM "/%s: Can't alloc skb\n",
+						__FUNCTION__);
 					priv->mpt_rxfidx[++priv->mpt_rxfidx_tail] = ctx;
 					spin_unlock_irqrestore(&priv->rxfidx_lock, flags);
 					break;
 				}
 
-		    		dma = pci_map_single(mpt_dev->pcidev, skb->data,
+				dma = pci_map_single(mpt_dev->pcidev, skb->data,
 						     len, PCI_DMA_FROMDEVICE);
 
 				priv->RcvCtl[ctx].skb = skb;
@@ -1308,7 +1341,7 @@
 	dioprintk((KERN_INFO MYNAM "/%s: End_buckets = %u, priv->buckets_out = %u\n",
 		  __FUNCTION__, buckets, atomic_read(&priv->buckets_out)));
 	dioprintk((KERN_INFO MYNAM "/%s: Posted %u buckets and received %u back\n",
-	__FUNCTION__, priv->total_posted, priv->total_received)); 
+	__FUNCTION__, priv->total_posted, priv->total_received));
 
 	clear_bit(0, &priv->post_buckets_active);
 }
@@ -1336,7 +1369,7 @@
 	priv->post_buckets_task.data = dev;
 	priv->post_buckets_active = 0;
 
-	dprintk((KERN_INFO MYNAM "@%d: bucketlen = %d\n",
+	dlprintk((KERN_INFO MYNAM "@%d: bucketlen = %d\n",
 			__LINE__, dev->mtu + dev->hard_header_len + 4));
 
 	atomic_set(&priv->buckets_out, 0);
@@ -1346,7 +1379,7 @@
 	if (mpt_dev->pfacts[0].MaxLanBuckets < max_buckets_out)
 		priv->max_buckets_out = mpt_dev->pfacts[0].MaxLanBuckets;
 
-	dprintk((KERN_INFO MYNAM "@%d: MaxLanBuckets=%d, max_buckets_out/priv=%d/%d\n",
+	dlprintk((KERN_INFO MYNAM "@%d: MaxLanBuckets=%d, max_buckets_out/priv=%d/%d\n",
 			__LINE__,
 			mpt_dev->pfacts[0].MaxLanBuckets,
 			max_buckets_out,
@@ -1389,7 +1422,7 @@
 	dev->tx_timeout = mpt_lan_tx_timeout;
 	dev->watchdog_timeo = MPT_LAN_TX_TIMEOUT;
 
-	dprintk((KERN_INFO MYNAM ": Finished registering dev "
+	dlprintk((KERN_INFO MYNAM ": Finished registering dev "
 		"and setting initial values\n"));
 
 	SET_MODULE_OWNER(dev);
@@ -1407,9 +1440,11 @@
 
 	show_mptmod_ver(LANAME, LANVER);
 
-	/* Init the global r/w lock for the bad_naa list. We want to do this 
+#ifdef QLOGIC_NAA_WORKAROUND
+	/* Init the global r/w lock for the bad_naa list. We want to do this
 	   before any boards are initialized and may be used. */
 	rwlock_init(&bad_naa_lock);
+#endif
 
 	if ((LanCtx = mpt_register(lan_reply, MPTLAN_DRIVER)) <= 0) {
 		printk (KERN_ERR MYNAM ": Failed to register with MPT base driver\n");
@@ -1419,10 +1454,10 @@
 	/* Set the callback index to be used by driver core for turbo replies */
 	mpt_lan_index = LanCtx;
 
-	dprintk((KERN_INFO MYNAM ": assigned context of %d\n", LanCtx));
+	dlprintk((KERN_INFO MYNAM ": assigned context of %d\n", LanCtx));
 
 	if (mpt_reset_register(LanCtx, mpt_lan_ioc_reset) == 0) {
-		dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
+		dlprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
 	} else {
 		printk(KERN_ERR MYNAM ": Eieee! unable to register a reset "
 		       "handler with mptbase! The world is at an end! "
@@ -1458,7 +1493,7 @@
 //							IOC_AND_NETDEV_NAMES_s_s(dev),
 //							NETDEV_TO_LANPRIV_PTR(dev)->tx_max_out);
 					mpt_landev[j] = dev;
-					dprintk((KERN_INFO MYNAM "/init: dev_addr=%p, mpt_landev[%d]=%p\n",
+					dlprintk((KERN_INFO MYNAM "/init: dev_addr=%p, mpt_landev[%d]=%p\n",
 							dev, j,  mpt_landev[j]));
 
 					j++;
@@ -1508,18 +1543,15 @@
 MODULE_PARM(tx_max_out_p, "i");
 MODULE_PARM(max_buckets_out, "i"); // Debug stuff. FIXME!
 
-MODULE_LICENSE("GPL");
-
 module_init(mpt_lan_init);
 module_exit(mpt_lan_exit);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 static unsigned short
-mpt_lan_type_trans(struct sk_buff *skb, struct net_device *dev) 
+mpt_lan_type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	struct mpt_lan_ohdr *fch = (struct mpt_lan_ohdr *)skb->data;
 	struct fcllc *fcllc;
-	u16 source_naa = fch->stype, found = 0;
 
 	skb->mac.raw = skb->data;
 	skb_pull(skb, sizeof(struct mpt_lan_ohdr));
@@ -1535,7 +1567,7 @@
 		printk (KERN_WARNING MYNAM ": %s: WARNING - Broadcast swap F/W bug detected!\n",
 				NETDEV_PTR_TO_IOC_NAME_s(dev));
 		printk (KERN_WARNING MYNAM ": Please update sender @ MAC_addr = %02x:%02x:%02x:%02x:%02x:%02x\n",
-		       		fch->saddr[0], fch->saddr[1], fch->saddr[2],
+				fch->saddr[0], fch->saddr[1], fch->saddr[2],
 				fch->saddr[3], fch->saddr[4], fch->saddr[5]);
 	}
 
@@ -1555,6 +1587,10 @@
 
 	fcllc = (struct fcllc *)skb->data;
 
+#ifdef QLOGIC_NAA_WORKAROUND
+{
+	u16 source_naa = fch->stype, found = 0;
+
 	/* Workaround for QLogic not following RFC 2625 in regards to the NAA
 	   value. */
 
@@ -1562,15 +1598,15 @@
 		source_naa = swab16(source_naa);
 
 	if (fcllc->ethertype == htons(ETH_P_ARP))
-	    dprintk ((KERN_INFO "mptlan/type_trans: got arp req/rep w/ naa of "
+	    dlprintk ((KERN_INFO "mptlan/type_trans: got arp req/rep w/ naa of "
 		      "%04x.\n", source_naa));
 
-	if ((fcllc->ethertype == htons(ETH_P_ARP)) && 
+	if ((fcllc->ethertype == htons(ETH_P_ARP)) &&
 	   ((source_naa >> 12) !=  MPT_LAN_NAA_RFC2625)){
 		struct NAA_Hosed *nh, *prevnh;
 		int i;
 
-		dprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep from "
+		dlprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep from "
 			  "system with non-RFC 2625 NAA value (%04x).\n",
 			  source_naa));
 
@@ -1584,17 +1620,17 @@
 			    (nh->ieee[4] == fch->saddr[4]) &&
 			    (nh->ieee[5] == fch->saddr[5])) {
 				found = 1;
-				dprintk ((KERN_INFO "mptlan/type_trans: ARP Re"
+				dlprintk ((KERN_INFO "mptlan/type_trans: ARP Re"
 					 "q/Rep w/ bad NAA from system already"
 					 " in DB.\n"));
 				break;
 			}
 		}
-		
+
 		if ((!found) && (nh == NULL)) {
 
 			nh = kmalloc(sizeof(struct NAA_Hosed), GFP_KERNEL);
-			dprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep w/"
+			dlprintk ((KERN_INFO "mptlan/type_trans: ARP Req/Rep w/"
 				 " bad NAA from system not yet in DB.\n"));
 
 			if (nh != NULL) {
@@ -1603,11 +1639,11 @@
 					mpt_bad_naa = nh;
 				if (prevnh)
 					prevnh->next = nh;
-				
+
 				nh->NAA = source_naa; /* Set the S_NAA value. */
 				for (i = 0; i < FC_ALEN; i++)
 					nh->ieee[i] = fch->saddr[i];
-				dprintk ((KERN_INFO "Got ARP from %02x:%02x:%02x:%02x:"
+				dlprintk ((KERN_INFO "Got ARP from %02x:%02x:%02x:%02x:"
 					  "%02x:%02x with non-compliant S_NAA value.\n",
 					  fch->saddr[0], fch->saddr[1], fch->saddr[2],
 					  fch->saddr[3], fch->saddr[4],fch->saddr[5]));
@@ -1622,9 +1658,10 @@
 		}
 		write_unlock_irq(&bad_naa_lock);
 	}
-		
+}
+#endif
 
-	/* Strip the SNAP header from ARP packets since we don't 
+	/* Strip the SNAP header from ARP packets since we don't
 	 * pass them through to the 802.2/SNAP layers.
 	 */
 	if (fcllc->dsap == EXTENDED_SAP &&
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptlan.h linux/drivers/message/fusion/mptlan.h
--- ../ia64/linux/drivers/message/fusion/mptlan.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/mptlan.h	Wed Feb 27 15:25:30 2002
@@ -21,6 +21,7 @@
 #include <linux/miscdevice.h>
 #include <linux/spinlock.h>
 #include <linux/tqueue.h>
+#include <linux/delay.h>
 // #include <linux/trdevice.h>
 
 #include <asm/uaccess.h>
@@ -43,13 +44,15 @@
 
 #define MPT_LAN_MAX_BUCKETS_OUT 256
 #define MPT_LAN_BUCKET_THRESH	18 /* 9 buckets in one message */
+#define MPT_LAN_BUCKETS_REMAIN_MISMATCH_THRESH 10
 #define MPT_LAN_RX_COPYBREAK	200
-#define MPT_LAN_TX_TIMEOUT 	(1*HZ)
+#define MPT_LAN_TX_TIMEOUT	(1*HZ)
 #define MPT_TX_MAX_OUT_LIM      127
 
 #define MPT_LAN_MIN_MTU		96		/* RFC2625 */
 #define MPT_LAN_MAX_MTU		65280		/* RFC2625 */
-#define MPT_LAN_MTU             16128		/* be nice to slab allocator */
+#define MPT_LAN_MTU             13312		/* Max perf range + lower mem
+						   usage than 16128 */
 
 #define MPT_LAN_NAA_RFC2625     0x1
 #define MPT_LAN_NAA_QLOGIC      0x2
@@ -64,6 +67,12 @@
 #define dioprintk(x)  printk x
 #else
 #define dioprintk(x)
+#endif
+
+#ifdef MPT_LAN_DEBUG
+#define dlprintk(x)  printk x
+#else
+#define dlprintk(x)
 #endif
 
 #define NETDEV_TO_LANPRIV_PTR(d)	((struct mpt_lan_priv *)(d)->priv)
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptlinux.txt linux/drivers/message/fusion/mptlinux.txt
--- ../ia64/linux/drivers/message/fusion/mptlinux.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/mptlinux.txt	Tue Mar 19 16:05:36 2002
@@ -0,0 +1,470 @@
+******************************************************************************
+                                 mptlinux.txt
+******************************************************************************
+
+This file presents general information about the LSI Logic Fusion MPT(TM)
+(Message Passing Technology) device drivers for Linux(TM).
+It also describes the features and use of the device drivers for the
+Linux operating system environment.
+
+This file is divided into the following sections:
+   Introduction
+       Features
+       LSI Logic Devices Supported
+   Installing the Fusion MPT Linux Drivers
+       Custom Linux Kernel Installation Instructions
+            Adding Fusion MPT support to the Kernel 
+            Updating Bundled Fusion MPT Driver
+       Kernel Patch Instructions
+            General Information 
+            IA64 Details
+       Driver Build Instructions
+       Loading the Drivers As Modules
+       Boot Setup Commands
+            Syntax
+            Available Arguments
+       Configuring Network Interfaces for MPT LAN Support
+   Troubleshooting
+
+******************************** Introduction ********************************
+
+The mptlinux drivers are free software and are supported in source form.
+These drivers are distributed in the hope that they will be useful, but
+without any warranty and without even the implied warranty of merchantability
+or fitness for a particular purpose. You can redistribute them and/or modify
+them under the terms of version 2 or later of the GNU Public License as
+published by the Free Software Foundation. You should have received a copy
+of this license with your Linux kernel source tree (/usr/src/linux/COPYING).
+For detailed information on the GNU Public License, contact the Free Software
+Foundation, Inc at 59 Temple Place - Suite 330, Boston, MA 02111-1307 or at
+URL http://www.gnu.org/copyleft/gpl.html.
+
+=== Features ===
+
+o  Supports SCSI and IETF-compliant LAN protocols concurrently over FC
+o  Supports 1Gbit/s Fibre Channel transfer rates (LSIFC909)
+o  Supports 1Gbit/s and 2Gbit/s Fibre Channel transfer rates (LSIFC919,
+   LSIFC929)
+o  Supports Ultra320 transfer rates (LSI53C1030)
+o  Supports LSI Logic Fusion MPT Architecture and common software interface
+o  Low host CPU utilization with one, or less than one, interrupt per I/O
+
+=== LSI Logic Devices Supported ===
+
+o LSIFC909 chips and LSI40909 adapters
+o LSIFC919 chips and LSI40919 adapters
+o LSIFC929 chips and LSI44929 adapters
+o LSI53C1030 chips and LSI22320 adapters
+
+****************** Installing the Fusion MPT Linux Drivers *******************
+
+=== Custom Linux Kernel Installation Instructions ===
+
+The mptlinux drivers are provided in source form so that the drivers can
+be compiled and installed on any system running Linux.  You must have the
+linux kernel source tree available to perform the procedures below.
+
+------ Adding Fusion MPT support to the Kernel 
+
+For Red Hat 7.0, all 2.2 and 2.4.0 through 2.4.6 kernels, Fusion MPT support
+must be added to the kernel source.
+
+The mptlinux driver source tar archive should be unpacked from the root of
+your linux kernel source tree (normally /usr/src/linux).
+  Example:
+    $ cd /usr/src/linux
+    $ zcat /tmp/mptlinux-2.00.11-src.tar.gz | tar xvf -
+
+------ Updating Bundled Fusion MPT Driver
+
+A version of the mptlinux driver is bundled in Red Hat 7.1 and 7.2 
+and official kernels starting with version 2.4.7.
+
+Before updating the bundled source, save the original driver tree
+in a compressed tar file.
+  Example:
+  # cd /usr/src/linux/drivers/message
+  # tar czvf fusion.orig.tar.gz fusion
+
+Delete the original driver tree and unpack the new driver files
+  Example:
+  # rm -rf fusion
+  # cd /usr/src/linux
+  # zcat /tmp/mptlinux-2.00.11-src.tar.gz | tar xvf -
+
+(Deletion of the original driver tree is necessary to remove obsolete files.)
+
+=== Kernel Patch Instructions ===
+
+------ General Information 
+
+The mptlinux host drivers may require a small set of patches to your linux kernel
+source tree.  Patch sets for stock and "well known" kernel versions have been
+included with the packed source tar archive. Patches may be required even if
+the mptlinux driver is currently bundled. 
+  Fusion patch files available for linux 2.2.x kernel versions:
+    2.2.5-15, 2.2.5-16,                (Red Hat 6.0)
+    2.2.12,
+    2.2.12-20,                         (Red Hat 6.1)
+    2.2.13,
+    2.2.14,
+    2.2.14-5.0, 2.2.14-6.0,            (Red Hat 6.2)
+    2.2.14-caldera,                    (Caldera 2.3.1)
+    2.2.15,
+    2.2.16,
+    2.2.16-22,                         (Red Hat 7.0)
+    2.2.17,
+    2.2.18,
+    2.2.18-2,                          (TurboLinux 6.5)
+    2.2.19,
+    2.2.20
+  Fusion patch files available for linux 2.4.x kernel versions:
+    2.4.0,
+    2.4.1,
+    2.4.2,
+    2.4.2-2,                           (Red Hat 7.1)
+    <not needed>,                      (Caldera 3.1)		
+    2.4.3,
+    2.4.3-12,                          (Red Hat 7.1, upd#1)
+    2.4.4,
+    2.4.4-4GB,                         (SuSE 7.2)
+    2.4.5,
+    2.4.6,
+    2.4.7,
+    2.4.7-10,                          (Red Hat 7.2) 
+    2.4.8,
+    2.4.9,
+    2.4.9-6,   <zero patches>          (Red Hat 7.1, upd#2)
+    2.4.9-13,  <zero patches>          (Red Hat 7.2, upd#1)
+    2.4.9-18,                          (Red Hat 7.2 IA64)
+    2.4.9-21,  <zero patches>          (Red Hat 7.2, upd#2)
+    2.4.10,
+    2.4.11 (broken kernel, do not use),
+    2.4.12,
+    2.4.13,
+    2.4.14,
+    2.4.15,
+    2.4.16,
+    2.4.17,
+    2.4.18
+
+  NOTES:
+    o  The Fusion MPT LAN driver is NOT supported in any of the 2.2.x
+       kernels listed here.  You MUST be working with a linux-2.4.x
+       kernel for Fusion MPT LAN support!
+    o  For module support under 2.3.x and 2.4.x kernels you must have
+       modutils v2.3.15 or newer installed.
+    o  IA64 support requires a linux-2.4.x kernel.
+
+To identify which kernel version you have, examine your
+/usr/src/linux/Makefile as follows:
+  Example (on a RedHat(TM) 6.2 system):
+        VERSION = 2
+        PATCHLEVEL = 2
+        SUBLEVEL = 14
+        EXTRAVERSION = -5.0
+
+Then apply the closest patch set you can find.
+
+  Example (on a Red Hat 6.2 system):
+    $ patch -p0 < drivers/message/fusion/patch/linux-2.2.14-5.0.txt
+
+These patches will apply small changes to the following files:
+    Makefile
+    arch/alpha/config.in
+    arch/i386/config.in
+    arch/sparc64/config.in
+    drivers/Makefile
+    include/linux/miscdevice.h
+    include/linux/proc_fs.h
+
+NOTE 1: If the driver is bundled in your kernel and no patch is 
+listed for your kernel, no patch set is required. Proceed to 
+the Driver Build Instructions.
+
+NOTE 2: You may not find an exact match for your kernel, however, applying
+the closest patch set *should* work, in general, but may require that you
+manually fixup any files for which the patch procedure might produce *.rej
+file sections.  You might optionally choose to hand-apply the small set of
+required kernel patches by examining one or more of the kernel patch files.
+
+=== Driver Build Instructions ===
+
+The following examples illustrate configuring and building
+the LSI Logic Fusion MPT driver(s) as kernel modules, however,
+please note that the MPT base and ScsiHost drivers can alternatively
+be compiled into the linux kernel instead of built as modules.
+
+1.  From the /usr/src/linux directory, ensure a clean kernel source
+    tree by executing the following command:
+        $ make mrproper
+
+2.  From the /usr/src/linux directory, run your normal kernel
+    configuration routine:
+        $ make oldconfig
+      or:
+        $ make config
+      or:
+        $ make menuconfig
+      or:
+        $ make xconfig
+
+3.  Look for the new top-level "Fusion MPT device support" entry:
+        Fusion MPT device support  --->
+      and select it to access the Fusion MPT drivers submenu entries:
+        <M> Fusion MPT (base + ScsiHost) drivers
+        <M>   Enhanced SCSI error reporting
+        < >   Fusion MPT misc device (ioctl) driver
+        < >   Fusion MPT LAN driver
+
+      On the submenu, select the "Fusion MPT (base + ScsiHost) drivers" line,
+      and then enter "m" to configure for building this support as a module.
+      (Alternatively, you can enter "y" here to have this support built
+      into the kernel.)
+
+      NOTES:
+       o  Enhanced SCSI error reporting and ioctl drivers are optional,
+          and it is recommended they only be built as modules,
+          due to kernel size considerations.
+       o  DO NOT answer "y" for Fusion MPT LAN driver option as support
+          for this driver is currently restricted to module use only.
+
+4.  For LAN support, make sure that "Fibre Channel driver support" is turned
+    on in the "Network device support" section.
+
+5.  Save your kernel config changes.  Follow any post config instructions
+      and do everything needed on your platform to rebuild the kernel.
+      This will typically include:
+        $ make dep
+      and:
+        $ make bzImage			# varies on non-intel platforms
+
+6.  Rebuild the kernel modules:
+        $ make modules
+
+NOTE: These last steps shown here will certainly require root permission.
+
+7.  Optionally, (and potentially dangerous!), do everything needed
+      on your platform to install a newly built kernel.
+      (possibly temporarily, for sanity testing)
+
+      Take care with this step and make sure you know what you're doing
+      as it's easy to wipe out a good/stable kernel from here on out!
+
+8.  (Re)Install newly compiled kernel modules:
+        # make modules_install
+
+      The output from the last step should look something like this:
+        Installing modules under /lib/modules/2.2.14-5.0/block
+        Installing modules under /lib/modules/2.2.14-5.0/net
+        Installing modules under /lib/modules/2.2.14-5.0/ipv4
+        Installing modules under /lib/modules/2.2.14-5.0/scsi
+        Installing modules under /lib/modules/2.2.14-5.0/fs
+        Installing modules under /lib/modules/2.2.14-5.0/fs
+        Installing modules under /lib/modules/2.2.14-5.0/cdrom
+        Installing modules under /lib/modules/2.2.14-5.0/video
+        Installing modules under /lib/modules/2.2.14-5.0/net
+        Installing modules under /lib/modules/2.2.14-5.0/misc
+
+9.  Shut down the system:
+      Example:
+        # shutdown -r now
+      and then reboot with the newly built linux kernel.
+
+=== Loading the Drivers As Modules ===
+
+After building the driver modules, as described in the previous section,
+the newly compiled kernel and modules are ready to be loaded.
+
+1.  Load the Fusion MPT base driver.
+        # insmod mptbase
+        Fusion MPT base driver 2.00.11
+        Copyright (c) 1999-2002 LSI Logic Corporation
+        mptbase: Initiating ioc0 bringup
+        ioc0: FC919: Capabilities={Initiator,Target,LAN}
+        mptbase: 1 MPT adapter found, 1 installed.
+
+2.  Load the isense driver (optional but highly recommended),
+    to enable enhanced SCSI error reporting.
+        # insmod isense
+        SCSI-3 Opcodes & ASC/ASCQ Strings 2.00.11
+        mptbase: English readable SCSI-3 OPs & ASC/ASCQ strings enabled:-)
+
+3.  Load the Fusion MPT SCSI host driver.
+        # insmod mptscsih
+        Fusion MPT SCSI Host driver 2.00.11
+
+      Depending on what FC devices you have attached to your FC link,
+      you should see something like the following on the console and
+      in the system log:
+        scsi0 : ioc0: LSIFC919, FwRev=1000h, Ports=1, MaxQ=256, IRQ=9
+        scsi : 1 host.
+          Vendor: SEAGATE   Model: ST39102FC         Rev: 0007
+          Type:   Direct-Access                      ANSI SCSI revision: 02
+        Detected scsi disk sda at scsi0, channel 0, id 0, lun 0
+          Vendor: SEAGATE   Model: ST19171FC         Rev: 0017
+          Type:   Direct-Access                      ANSI SCSI revision: 02
+        Detected scsi disk sdb at scsi0, channel 0, id 1, lun 0
+        SCSI device sda: hdwr sector= 512 bytes. Sectors= 17783240 [8683 MB] [8.7 GB]
+         sda: sda1
+        SCSI device sdb: hdwr sector= 512 bytes. Sectors= 17783112 [8683 MB] [8.7 GB]
+         sdb: sdb1
+
+    All Fibre Channel target devices should be detected and mapped to linux
+    SCSI devices, /dev/sd{a,b,c,...} when the mptscsih module is loaded.
+
+    All linux commands pertaining to SCSI disk storage management
+    (fdisk, mke2fs, mount, etc.) using the /dev/sdX[N] notation
+    should now be functional.
+
+    FCP (SCSI) Device Access Example:
+        # fdisk /dev/sdb
+        # mke2fs /dev/sdb1
+        # mount /dev/sdb1 /mnt/s1
+
+=== Boot Setup Commands ===
+
+1. Syntax
+
+Setup commands can be passed to the SCSI host driver mptscsih
+as a string variable using 'insmod'.  The following command 
+will install driver module with the bus width set to narrow
+and Domain Validation disabled.
+
+    insmod mptscsih.o mptscsih="dv:n width:0"
+
+Each string argument must be specified as "keyword:value". Only lower-case
+characters and digits are allowed.
+
+2.  Available Arguments
+
+2.1 Domain Validation
+        dv:n    disabled
+        dv:y    enabled [default]
+
+    The SCSI host driver will perform a sequence of write, read and compare
+    commands to each target device during driver initialization. If data 
+    corruption or bus hangs are detected during this sequence, the driver 
+    will automatically slow the transfer rate until reliable transmission is
+    achieved.  
+
+    Warning! These tests use a devices internal buffer.  Some
+    older SCSI devices behave badly, that is, freeze, when they receive a
+    Read or Write Buffer command. 
+
+    DV may be disabled on a per-device basis by setting the transfer 
+    characterists to ASYNC and NARROW in the adapter BIOS.  Alternatively,
+    DV may be disabled for the driver by passing in dv:n as a command
+    line argument.
+
+    This option is has no effect for FC9XX parts.
+
+2.2 Maximum SCSI Bus Width
+        width:0      wide SCSI disabled
+        width:1      wide SCSI enabled
+
+    The maximum allowed SCSI bus data transfer width is set to the
+    minimum of the command line options, adapter capabilities, and 
+    NVRAM settings.  
+
+    This option is has no effect for FC9XX parts.
+
+2.3 Minimum SCSI Synchronous Factor
+        factor:0x08   Ultra320 (160 Mega-transfers / second)
+        factor:0x09   Ultra160 ( 80 Mega-transfers / second)
+        factor:0x0A   Ultra2   ( 40 Mega-transfers / second)
+        factor:0x0C   Ultra    ( 20 Mega-transfers / second)
+        factor:0x19   FAST     ( 10 Mega-transfers / second)
+        factor:0x32   SCSI     (  5 Mega-transfers / second)
+        factor:0xFF   5 Mega-trasfers/second and asynchronous 
+
+    The minimum allowed SCSI synchronous factor is set to the 
+    maximum of the command line input, adapters capabilities and 
+    NVRAM setting.  If the minimum synchronous factor is 0xFF, the
+    synchronous offset will be set to 0 (asynchronous).
+
+    This option is has no effect for FC9XX parts.
+
+=== Configuring Network Interfaces for MPT LAN Support ===
+
+You can use either linuxconf, netcfg (only runs under X), or your own superb
+knowledge of network configuration files and vi/emacs to setup the needed
+info so that you can use your MPT LAN connection. The instructions below are
+specifically for linuxconf, but they should be easily adapted to netcfg.
+Instructions for manually adding the needed config files is beyond the scope
+of this document.
+
+1.  In linuxconf, go to Config->Networking->Client tasks->Basic host 
+    information. 
+
+2.  Select an unused adaptor (i.e. 2)
+
+3.  Set "Config mode" to "Manual"
+
+4.  Set "Primary name" to whatever you want.
+
+5.  Set "IP Address" to whatever you're using (I use the private class C
+    range, 192.168.0.x, for testing purposes).
+
+6.  Set your netmask to whatever is used on your network. The default is 
+    255.255.255.0, and should be used unless your network admin says 
+    otherwise.
+
+7.  Set "Net device" to fc? (fc0 for the first LAN port, fc1 for the 
+    second, . . .)
+
+8.  If you want the interface to be activated automatically at boot, select
+    "Enabled" and then type "mptlan" on the "Kernel module" line. 
+
+****************************** Troubleshooting *******************************
+
+1.  The SCSI driver error reporting has been nicely enhanced, making it much
+    more readable. Also, there's an (optional) isense driver/shim which
+    provides SCSI-3 opcode string lookup and a LARGE sorted table of 463
+    unique SCSI-3 Additional Sense Code & Qualifier (ASC/ASCQ) strings,
+    translated directly from a text file off the SCSI T10.org's ftp site:
+
+        ftp://ftp.t10.org/t10/drafts/spc2/asc-num.txt
+
+    If the isense driver is (optionally) loaded, whenever a SCSI check
+    condition is generated[1], an english readable ASC/ASCQ string for the
+    SCSI error.
+
+    Here's an example:
+    -----
+    SCSI Error Report =-=-= (ioc0,scsi5:0)
+      SCSI_Status=02h (CHECK_CONDITION)
+      Original_CDB[]: 2A 00 00 00 00 41 00 00 02 00 - "WRITE(10)"
+      SenseData[12h]: 70 00 02 00 00 00 00 0A 00 00 00 00 04 02 02 00 00 00
+      SenseKey=2h (NOT READY); FRU=02h
+      ASC/ASCQ=29h/00h "LOGICAL UNIT NOT READY, INITIALIZING CMD. REQUIRED"
+    -----
+
+    If the isense driver is NOT installed, neither the SCSI opcode string
+    nor the last ASC/ASCQ string will be displayed.
+
+2.  If you have compiled your linux kernel with /proc file system support,
+    you can examine SCSI devices using this command:
+      $ cat /proc/scsi/scsi
+
+    A summary of attached/recognized MPT adapters can be examined with the
+    following command:
+      $ cat /proc/mpt/summary
+
+3.  If you have a LSI Fibre Channel RAID subsystem attached, some of the
+    standard linux SCSI devices that show up will not be accessible,
+    depending on the exact configuration of the RAID controller(s).
+    For example, if you have dual active controllers in one subsystem with
+    8 active LUNs configured for each controller, all 16 LUNs will be visible
+    through each controller (32 SCSI devices total), although only 8 LUNs
+    will actually be accessible from each controller.  There is currently
+    no filtering out of the "visible but not accessible" entries.
+
+******************************************************************************
+
+Fusion MPT is a trademark of LSI Logic Corporation
+Linux is a registered trademark of Linus Torvalds
+Red Hat is a registered trademark of Red Hat Software, Inc.
+
+******************************************************************************
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptscsih.c linux/drivers/message/fusion/mptscsih.c
--- ../ia64/linux/drivers/message/fusion/mptscsih.c	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/mptscsih.c	Tue Mar 19 16:05:36 2002
@@ -9,17 +9,24 @@
  *      This driver would not exist if not for Alan Cox's development
  *      of the linux i2o driver.
  *
+ *      A special thanks to Pamela Delaney (LSI Logic) for tons of work
+ *      and countless enhancements while adding support for the 1030
+ *      chip family.  Pam has been instrumental in the development of
+ *      of the 2.xx.xx series fusion drivers, and her contributions are
+ *      far too numerous to hope to list in one place.
+ *
  *      A huge debt of gratitude is owed to David S. Miller (DaveM)
  *      for fixing much of the stupid and broken stuff in the early
  *      driver while porting to sparc64 platform.  THANK YOU!
  *
  *      (see mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Original author: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptscsih.c,v 1.29.4.1 2001/09/18 03:22:30 sralston Exp $
+ *  $Id: mptscsih.c,v 1.80 2002/02/27 18:44:27 sralston Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -66,6 +73,9 @@
 #include <linux/kdev_t.h>
 #include <linux/blkdev.h>
 #include <linux/blk.h>		/* for io_request_lock (spinlock) decl */
+#include <linux/delay.h>	/* for mdelay */
+#include <linux/interrupt.h>	/* needed for in_interrupt() proto */
+#include <linux/reboot.h>	/* notifier code */
 #include "../../scsi/scsi.h"
 #include "../../scsi/hosts.h"
 #include "../../scsi/sd.h"
@@ -83,52 +93,131 @@
 MODULE_DESCRIPTION(my_NAME);
 MODULE_LICENSE("GPL");
 
+/* Set string for command line args from insmod */
+#ifdef MODULE
+char *mptscsih = 0;
+MODULE_PARM(mptscsih, "s");
+#endif
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 
 typedef struct _BIG_SENSE_BUF {
-	u8		data[256];
+	u8		data[MPT_SENSE_BUFFER_ALLOC];
 } BIG_SENSE_BUF;
 
-typedef struct _MPT_SCSI_HOST {
-	MPT_ADAPTER		 *ioc;
-	int			  port;
-	struct scsi_cmnd	**ScsiLookup;
-	u8			 *SgHunks;
-	dma_addr_t		  SgHunksDMA;
-	u32			  qtag_tick;
-} MPT_SCSI_HOST;
-
-typedef struct _MPT_SCSI_DEV {
-	struct _MPT_SCSI_DEV	 *forw;
-	struct _MPT_SCSI_DEV	 *back;
-	MPT_ADAPTER		 *ioc;
-	int			  sense_sz;
-	BIG_SENSE_BUF		  CachedSense;
-	unsigned long		  io_cnt;
-	unsigned long		  read_cnt;
-} MPT_SCSI_DEV;
+#define MPT_SCANDV_GOOD			(0x00000000) /* must be 0 */
+#define MPT_SCANDV_DID_RESET		(0x00000001)
+#define MPT_SCANDV_SENSE		(0x00000002)
+#define MPT_SCANDV_SOME_ERROR		(0x00000004)
+#define MPT_SCANDV_SELECTION_TIMEOUT	(0x00000008)
+
+#define MPT_SCANDV_MAX_RETRIES		(10)
+
+#define MPT_ICFLAG_BUF_CAP	0x01	/* ReadBuffer Read Capacity format */
+#define MPT_ICFLAG_ECHO		0x02	/* ReadBuffer Echo buffer format */
+#define MPT_ICFLAG_PHYS_DISK	0x04	/* Any SCSI IO but do Phys Disk Format */
+#define MPT_ICFLAG_TAGGED_CMD	0x08	/* Do tagged IO */
+#define MPT_ICFLAG_DID_RESET	0x20	/* Bus Reset occured with this command */
+#define MPT_ICFLAG_RESERVED	0x40	/* Reserved has been issued */
+
+typedef struct _internal_cmd {
+	char		*data;		/* data pointer */
+	dma_addr_t	data_dma;	/* data dma address */
+	int		size;		/* transfer size */
+	u8		cmd;		/* SCSI Op Code */
+	u8		bus;		/* bus number */
+	u8		id;		/* SCSI ID (virtual) */
+	u8		lun;
+	u8		flags;		/* Bit Field - See above */
+	u8		physDiskNum;	/* Phys disk number, -1 else */
+	u8		rsvd2;
+	u8		rsvd;
+} INTERNAL_CMD;
+
+typedef struct _negoparms {
+	u8 width;
+	u8 offset;
+	u8 factor;
+	u8 flags;
+} NEGOPARMS;
+
+typedef struct _dv_parameters {
+	NEGOPARMS	 max;
+	NEGOPARMS	 now;
+	u8		 cmd;
+	u8		 id;
+	u16		 pad1;
+} DVPARAMETERS;
+
 
 /*
  *  Other private/forward protos...
  */
-
 static int	mptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
 static void	mptscsih_report_queue_full(Scsi_Cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq);
 static int	mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
 static int	mptscsih_io_direction(Scsi_Cmnd *cmd);
+
+static int	mptscsih_Add32BitSGE(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt,
+				 SCSIIORequest_t *pReq, int req_idx);
+static void	mptscsih_AddNullSGE(SCSIIORequest_t *pReq);
+static int	mptscsih_getFreeChainBuffer(MPT_SCSI_HOST *hd, int *retIndex);
+static void	mptscsih_freeChainBuffers(MPT_SCSI_HOST *hd, int req_idx);
+static int	mptscsih_initChainBuffers (MPT_SCSI_HOST *hd, int init);
+
 static void	copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply);
-static u32	SCPNT_TO_MSGCTX(Scsi_Cmnd *sc);
+#ifndef MPT_SCSI_USE_NEW_EH
+static void	search_taskQ_for_cmd(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd);
+#endif
+static u32	SCPNT_TO_LOOKUP_IDX(Scsi_Cmnd *sc);
+static MPT_FRAME_HDR *mptscsih_search_pendingQ(MPT_SCSI_HOST *hd, int scpnt_idx);
+static void	post_pendingQ_commands(MPT_SCSI_HOST *hd);
+
+static int	mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag);
+static int	mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag);
 
 static int	mptscsih_ioc_reset(MPT_ADAPTER *ioc, int post_reset);
 static int	mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);
 
+static VirtDevice	*mptscsih_initTarget(MPT_SCSI_HOST *hd, int bus_id, int target_id, u8 lun, char *data, int dlen);
+void		mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target);
+static void	clear_sense_flag(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq);
+static void	mptscsih_set_dvflags(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq, char *data);
+static void	mptscsih_setDevicePage1Flags (u8 width, u8 factor, u8 offset, int *requestedPtr, int *configurationPtr, u8 flags);
+static int	mptscsih_writeSDP1(MPT_SCSI_HOST *hd, int portnum, int target, int flags);
+static int	mptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r);
+static void	mptscsih_timer_expired(unsigned long data);
+static void	mptscsih_taskmgmt_timeout(unsigned long data);
+static int	mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *iocmd);
+static int	mptscsih_synchronize_cache(MPT_SCSI_HOST *hd, int portnum);
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+static int	mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 action, INTERNAL_CMD *io);
+static void	mptscsih_domainValidation(void *hd);
+static void	mptscsih_doDv(MPT_SCSI_HOST *hd, int portnum, int target);
+static void	mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVPARAMETERS *dv,void *pPage);
+static void	mptscsih_fillbuf(char *buffer, int size, int index, int width);
+#endif
+static int	mptscsih_setup(char *str);
+static int	mptscsih_halt(struct notifier_block *nb, ulong event, void *buf);
+
+/*
+ *	Reboot Notification
+ */
+static struct notifier_block mptscsih_notifier = {
+	mptscsih_halt, NULL, 0
+};
+
+/*
+ *	Private data...
+ */
 
 static int	mpt_scsi_hosts = 0;
 static atomic_t	queue_depth;
 
 static int	ScsiDoneCtx = -1;
 static int	ScsiTaskCtx = -1;
+static int	ScsiScanDvCtx = -1; /* Used only for bus scan and dv */
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,28)
 static struct proc_dir_entry proc_mpt_scsihost =
@@ -141,23 +230,40 @@
 };
 #endif
 
-#define SNS_LEN(scp)  sizeof((scp)->sense_buffer)
+#define SNS_LEN(scp)	sizeof((scp)->sense_buffer)
 
 #ifndef MPT_SCSI_USE_NEW_EH
 /*
  *  Stuff to handle single-threading SCSI TaskMgmt
  *  (abort/reset) requests...
  */
-static spinlock_t mpt_scsih_taskQ_lock = SPIN_LOCK_UNLOCKED;
-static MPT_Q_TRACKER mpt_scsih_taskQ = {
-	(MPT_FRAME_HDR*) &mpt_scsih_taskQ,
-	(MPT_FRAME_HDR*) &mpt_scsih_taskQ
-};
-static int mpt_scsih_taskQ_cnt = 0;
-static int mpt_scsih_taskQ_bh_active = 0;
-static MPT_FRAME_HDR *mpt_scsih_active_taskmgmt_mf = NULL;
+static spinlock_t mytaskQ_lock = SPIN_LOCK_UNLOCKED;
+static int mytaskQ_bh_active = 0;
+static struct tq_struct	mptscsih_ptaskfoo;
+static atomic_t	mpt_taskQdepth;
+#endif
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+/*
+ * Domain Validation task structure
+ */
+static spinlock_t dvtaskQ_lock = SPIN_LOCK_UNLOCKED;
+static int dvtaskQ_active = 0;
+static int dvtaskQ_release = 0;
+static struct tq_struct	mptscsih_dvTask;
 #endif
 
+/*
+ * Wait Queue setup
+ */
+static DECLARE_WAIT_QUEUE_HEAD (scandv_waitq);
+static int scandv_wait_done = 1;
+
+/* Driver default setup
+ */
+static struct mptscsih_driver_setup
+	driver_setup = MPTSCSIH_DRIVER_SETUP;
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	mptscsih_io_done - Main SCSI IO callback routine registered to
@@ -174,123 +280,109 @@
  *	Returns 1 indicating alloc'd request frame ptr should be freed.
  */
 static int
-mptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r)
+mptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
 {
 	Scsi_Cmnd	*sc;
 	MPT_SCSI_HOST	*hd;
-	MPT_SCSI_DEV	*mpt_sdev = NULL;
+	SCSIIORequest_t	*pScsiReq;
+	SCSIIOReply_t	*pScsiReply;
+	unsigned long	 flags;
 	u16		 req_idx;
 
+	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+
 	if ((mf == NULL) ||
 	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(KERN_ERR MYNAM ": ERROR! NULL or BAD req frame ptr (=%p)!\n", mf);
-		return 1;
+		printk(MYIOC_s_ERR_FMT "%s req frame ptr! (=%p)!\n",
+				ioc->name, mf?"BAD":"NULL", mf);
+		/* return 1; CHECKME SteveR. Don't free. */
+		return 0;
 	}
 
-	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
 	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 	sc = hd->ScsiLookup[req_idx];
-	hd->ScsiLookup[req_idx] = NULL;
+	if (sc == NULL) {
+		MPIHeader_t *hdr = (MPIHeader_t *)mf;
 
-	dmfprintk((KERN_INFO MYNAM ": ScsiDone (req:sc:reply=%p:%p:%p)\n", mf, sc, r));
+		atomic_dec(&queue_depth);
 
-	atomic_dec(&queue_depth);
+		/* writeSDP1 will use the ScsiDoneCtx
+		 * There is no processing for the reply.
+		 * Just return to the calling function.
+		 */
+		if (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST)
+			printk(MYIOC_s_ERR_FMT "NULL ScsiCmd ptr!\n", ioc->name);
 
-	/*
-	 *  Check for {1st} {IO} completion to "new" device.
-	 *  How do we know it's a new device?
-	 *  If we haven't set SDpnt->hostdata I guess...
-	 */
-	if (sc && sc->device) {
-		mpt_sdev = (MPT_SCSI_DEV*)sc->device->hostdata;
-		if (!mpt_sdev) {
-			dprintk((KERN_INFO MYNAM ": *NEW* SCSI device (%d:%d:%d)!\n",
-					   sc->device->id, sc->device->lun, sc->device->channel));
-			if ((sc->device->hostdata = kmalloc(sizeof(MPT_SCSI_DEV), GFP_ATOMIC)) == NULL) {
-				printk(KERN_ERR MYNAM ": ERROR - kmalloc(%d) FAILED!\n", (int)sizeof(MPT_SCSI_DEV));
-			} else {
-				memset(sc->device->hostdata, 0, sizeof(MPT_SCSI_DEV));
-				mpt_sdev = (MPT_SCSI_DEV *) sc->device->hostdata;
-				mpt_sdev->ioc = ioc;
-			}
-		} else {
-			if (++mpt_sdev->io_cnt && mptscsih_io_direction(sc) < 0) {
-				if (++mpt_sdev->read_cnt == 3) {
-					dprintk((KERN_INFO MYNAM ": 3rd DATA_IN, CDB[0]=%02x\n",
-							sc->cmnd[0]));
-				}
-			}
-#if 0
-			if (mpt_sdev->sense_sz) {
-				/*
-				 *  Completion of first IO down this path
-				 *  *should* invalidate device SenseData...
-				 */
-				mpt_sdev->sense_sz = 0;
-			}
-#endif
-		}
+		mptscsih_freeChainBuffers(hd, req_idx);
+		return 1;
 	}
 
-#if 0
-{
-	MPT_FRAME_HDR	*mf_chk;
+	dmfprintk((MYIOC_s_INFO_FMT "ScsiDone (mf=%p,mr=%p,sc=%p)\n",
+			ioc->name, mf, mr, sc));
 
-	/* This, I imagine, is a costly check, but...
-	 *  If abort/reset active, check to see if this is a IO
-	 *  that completed while ABORT/RESET for it is waiting
-	 *  on our taskQ!
-	 */
-	if (! Q_IS_EMPTY(&mpt_scsih_taskQ)) {
-		/* If ABORT for this IO is queued, zap it! */
-		mf_chk = search_taskQ(1,sc,MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
-		if (mf_chk != NULL) {
-			sc->result = DID_ABORT << 16;
-			spin_lock_irqsave(&io_request_lock, flags);
-			sc->scsi_done(sc);
-			spin_unlock_irqrestore(&io_request_lock, flags);
-			return 1;
-		}
-	}
-}
-#endif
+	atomic_dec(&queue_depth);
 
-	if (r != NULL && sc != NULL) {
-		SCSIIOReply_t	*pScsiReply;
-		SCSIIORequest_t *pScsiReq;
-		u16		 status;
+	sc->result = DID_OK << 16;		/* Set default reply as OK */
+	pScsiReq = (SCSIIORequest_t *) mf;
+	pScsiReply = (SCSIIOReply_t *) mr;
+
+	if (pScsiReply == NULL) {
+		/* special context reply handling */
+
+		/* If regular Inquiry cmd - save inquiry data
+		 */
+		if (pScsiReq->CDB[0] == INQUIRY && !(pScsiReq->CDB[1] & 0x3)) {
+			int	 dlen;
 
-		pScsiReply = (SCSIIOReply_t *) r;
-		pScsiReq = (SCSIIORequest_t *) mf;
+			dlen = le32_to_cpu(pScsiReq->DataLength);
+			if (dlen >= SCSI_STD_INQUIRY_BYTES) {
+				mptscsih_initTarget(hd,
+						hd->port,
+						sc->target,
+						pScsiReq->LUN[1],
+						sc->buffer,
+						dlen);
+			}
+		}
+		clear_sense_flag(hd, pScsiReq);
+
+		if (hd->is_spi)
+			mptscsih_set_dvflags(hd, pScsiReq, sc->buffer);
+	} else {
+		u32	 xfer_cnt;
+		u16	 status;
+		u8	 scsi_state;
 
 		status = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+		scsi_state = pScsiReply->SCSIState;
 
-		dprintk((KERN_NOTICE MYNAM ": Uh-Oh!  (req:sc:reply=%p:%p:%p)\n", mf, sc, r));
+		dprintk((KERN_NOTICE "  Uh-Oh! (%d:%d:%d) mf=%p, mr=%p, sc=%p\n",
+				ioc->id, pScsiReq->TargetID, pScsiReq->LUN[1],
+				mf, mr, sc));
 		dprintk((KERN_NOTICE "  IOCStatus=%04xh, SCSIState=%02xh"
-				     ", SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
-				     status, pScsiReply->SCSIState, pScsiReply->SCSIStatus,
-				     le32_to_cpu(pScsiReply->IOCLogInfo)));
+				", SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
+				status, scsi_state, pScsiReply->SCSIStatus,
+				le32_to_cpu(pScsiReply->IOCLogInfo)));
+
+		if (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID)
+			copy_sense_data(sc, hd, mf, pScsiReply);
 
 		/*
 		 *  Look for + dump FCP ResponseInfo[]!
 		 */
-		if (pScsiReply->SCSIState & MPI_SCSI_STATE_RESPONSE_INFO_VALID) {
+		if (scsi_state & MPI_SCSI_STATE_RESPONSE_INFO_VALID) {
 			dprintk((KERN_NOTICE "  FCP_ResponseInfo=%08xh\n",
 					     le32_to_cpu(pScsiReply->ResponseInfo)));
 		}
 
 		switch(status) {
 		case MPI_IOCSTATUS_BUSY:			/* 0x0002 */
-			/*sc->result = DID_BUS_BUSY << 16;*/		/* YIKES! - Seems to
-									 * kill linux interrupt
-									 * handler
-									 */
-			sc->result = STS_BUSY;				/* Try SCSI BUSY! */
-			break;
-
-		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
-			/*  Not real sure here...  */
-			sc->result = DID_OK << 16;
+			/* CHECKME!
+			 * Maybe: DRIVER_BUSY | SUGGEST_RETRY | DID_SOFT_ERROR (retry)
+			 * But not: DID_BUS_BUSY lest one risk
+			 * killing interrupt handler:-(
+			 */
+			sc->result = STS_BUSY;
 			break;
 
 		case MPI_IOCSTATUS_SCSI_INVALID_BUS:		/* 0x0041 */
@@ -299,10 +391,29 @@
 			break;
 
 		case MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:	/* 0x0043 */
-			/*  Spoof to SCSI Selection Timeout!  */
+			/* Spoof to SCSI Selection Timeout! */
 			sc->result = DID_NO_CONNECT << 16;
 			break;
 
+		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
+#ifndef MPT_SCSI_USE_NEW_EH
+			search_taskQ_for_cmd(sc, hd);
+#endif
+			/* Linux handles an unsolicited DID_RESET better 
+			 * than an unsolicited DID_ABORT.
+			 */
+			sc->result = DID_RESET << 16;
+			break;
+
+		case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:		/* 0x004B */
+		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
+#ifndef MPT_SCSI_USE_NEW_EH
+			search_taskQ_for_cmd(sc, hd);
+#endif
+			sc->result = DID_RESET << 16;
+			break;
+
+		case MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:	/* 0x0049 */
 		case MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:		/* 0x0045 */
 			/*
 			 *  YIKES!  I just discovered that SCSI IO which
@@ -312,78 +423,148 @@
 			 *  Do upfront check for valid SenseData and give it
 			 *  precedence!
 			 */
+			sc->result = (DID_OK << 16) | pScsiReply->SCSIStatus;
+			clear_sense_flag(hd, pScsiReq);
 			if (pScsiReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
-				copy_sense_data(sc, hd, mf, pScsiReply);
-				sc->result = pScsiReply->SCSIStatus;
-				break;
+				/* Have already saved the status and sense data
+				 */
+				;
+			} else if (pScsiReply->SCSIState & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {
+				/* What to do?
+				 */
+				sc->result = DID_SOFT_ERROR << 16;
+			}
+			else if (pScsiReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
+				/*  Not real sure here either...  */
+				sc->result = DID_RESET << 16;
 			}
 
-			dprintk((KERN_NOTICE MYNAM ": sc->underflow={report ERR if < %02xh bytes xfer'd}\n", sc->underflow));
-			dprintk((KERN_NOTICE MYNAM ": ActBytesXferd=%02xh\n", le32_to_cpu(pScsiReply->TransferCount)));
+			/* Give report and update residual count.
+			 */
+			xfer_cnt = le32_to_cpu(pScsiReply->TransferCount);
+			dprintk((KERN_NOTICE "  sc->underflow={report ERR if < %02xh bytes xfer'd}\n",
+					sc->underflow));
+			dprintk((KERN_NOTICE "  ActBytesXferd=%02xh\n", xfer_cnt));
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-			sc->resid = sc->request_bufflen - le32_to_cpu(pScsiReply->TransferCount);
-			dprintk((KERN_NOTICE MYNAM ": SET sc->resid=%02xh\n", sc->resid));
+			sc->resid = sc->request_bufflen - xfer_cnt;
+			dprintk((KERN_NOTICE "  SET sc->resid=%02xh\n", sc->resid));
 #endif
 
-			if (pScsiReq->CDB[0] == INQUIRY) {
-				sc->result = (DID_OK << 16);
-				break;
-			}
+			/* Report Queue Full
+			 */
+			if (sc->result == MPI_SCSI_STATUS_TASK_SET_FULL)
+				mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
 
-			/* workaround attempts... */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-			if (sc->resid >= 0x200) {
-				/* GRRRRR...
-				 *   //sc->result = DID_SOFT_ERROR << 16;
-				 * Try spoofing to BUSY
-				 */
-				sc->result = STS_BUSY;
-			} else {
-				sc->result = 0;
+			/* If regular Inquiry cmd and some data was transferred,
+			 * save inquiry data
+			 */
+			if (    pScsiReq->CDB[0] == INQUIRY
+			     && !(pScsiReq->CDB[1] & 0x3)
+			     && xfer_cnt >= SCSI_STD_INQUIRY_BYTES
+			   ) {
+				mptscsih_initTarget(hd,
+						hd->port,
+						sc->target,
+						pScsiReq->LUN[1],
+						sc->buffer,
+						xfer_cnt);
 			}
-#else
-			sc->result = 0;
-#endif
-			break;
 
-		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
-			sc->result = DID_ABORT << 16;
-			break;
-
-		case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:		/* 0x004B */
-		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
-			sc->result = DID_RESET << 16;
+			if (hd->is_spi)
+				mptscsih_set_dvflags(hd, pScsiReq, sc->buffer);
 			break;
 
+		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
 		case MPI_IOCSTATUS_SUCCESS:			/* 0x0000 */
-			sc->result = pScsiReply->SCSIStatus;
+			sc->result = (DID_OK << 16) | pScsiReply->SCSIStatus;
+			clear_sense_flag(hd, pScsiReq);
 
 			if (pScsiReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
-				copy_sense_data(sc, hd, mf, pScsiReply);
-
-				/*  If running agains circa 200003dd 909 MPT f/w,
-				 *  may get this (AUTOSENSE_VALID) for actual TASK_SET_FULL
-				 *  (QUEUE_FULL) returned from device!	--> get 0x0000?128
-				 *  and with SenseBytes set to 0.
+				/*
+				 * If running agains circa 200003dd 909 MPT f/w,
+				 * may get this (AUTOSENSE_VALID) for actual TASK_SET_FULL
+				 * (QUEUE_FULL) returned from device! --> get 0x0000?128
+				 * and with SenseBytes set to 0.
 				 */
 				if (pScsiReply->SCSIStatus == MPI_SCSI_STATUS_TASK_SET_FULL)
 					mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
+
+#ifndef MPT_SCSI_USE_NEW_EH
+				/* ADDED 20011120 -sralston
+				 * Scsi mid-layer (old_eh) doesn't seem to like it
+				 * when RAID returns SCSIStatus=02 (CHECK CONDITION),
+				 * SenseKey=01 (RECOVERED ERROR), ASC/ASCQ=95/01.
+				 * Seems to be * treating this as a IO error:-(
+				 *
+				 * So just lie about it altogether here.
+				 *
+				 * NOTE: It still gets reported to syslog via
+				 * mpt_ScsiHost_ErrorReport from copy_sense_data
+				 * call far above.
+				 */
+				if (    pScsiReply->SCSIStatus == STS_CHECK_CONDITION
+				     && SD_Sense_Key(sc->sense_buffer) == SK_RECOVERED_ERROR
+				   ) {
+					sc->result = 0;
+				}
+#endif
+
 			}
-			else if (pScsiReply->SCSIState & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {
+			else if (pScsiReply->SCSIState &
+			         (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)
+			   ) {
 				/*
-				 *  What to do?
+				 * What to do?
 				 */
 				sc->result = DID_SOFT_ERROR << 16;
 			}
 			else if (pScsiReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
 				/*  Not real sure here either...  */
-				sc->result = DID_ABORT << 16;
+				sc->result = DID_RESET << 16;
+			}
+			else if (pScsiReply->SCSIState & MPI_SCSI_STATE_QUEUE_TAG_REJECTED) {
+				/* Device Inq. data indicates that it supports
+				 * QTags, but rejects QTag messages.
+				 * This command completed OK.
+				 *
+				 * Not real sure here either so do nothing...  */
 			}
 
 			if (sc->result == MPI_SCSI_STATUS_TASK_SET_FULL)
 				mptscsih_report_queue_full(sc, pScsiReply, pScsiReq);
 
+			/* Add handling of:
+			 * Reservation Conflict, Busy,
+			 * Command Terminated, CHECK
+			 */
+
+			/* If regular Inquiry cmd - save inquiry data
+			 */
+			xfer_cnt = le32_to_cpu(pScsiReply->TransferCount);
+			if (    sc->result == (DID_OK << 16)
+			     && pScsiReq->CDB[0] == INQUIRY
+			     && !(pScsiReq->CDB[1] & 0x3)
+			     && xfer_cnt >= SCSI_STD_INQUIRY_BYTES
+			   ) {
+				mptscsih_initTarget(hd,
+						hd->port,
+						sc->target,
+						pScsiReq->LUN[1],
+						sc->buffer,
+						xfer_cnt);
+			}
+
+			if (hd->is_spi)
+				mptscsih_set_dvflags(hd, pScsiReq, sc->buffer);
+			break;
+
+		case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:		/* 0x0047 */
+			if (pScsiReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
+				/*  Not real sure here either...  */
+				sc->result = DID_RESET << 16;
+			} else
+				sc->result = DID_SOFT_ERROR << 16;
 			break;
 
 		case MPI_IOCSTATUS_INVALID_FUNCTION:		/* 0x0001 */
@@ -395,50 +576,50 @@
 		case MPI_IOCSTATUS_INVALID_STATE:		/* 0x0008 */
 		case MPI_IOCSTATUS_SCSI_DATA_OVERRUN:		/* 0x0044 */
 		case MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:		/* 0x0046 */
-		case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:		/* 0x0047 */
-		case MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:	/* 0x0049 */
 		case MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:	/* 0x004A */
 		default:
 			/*
-			 *  What to do?
+			 * What to do?
 			 */
 			sc->result = DID_SOFT_ERROR << 16;
 			break;
 
 		}	/* switch(status) */
 
-		dprintk((KERN_NOTICE MYNAM ": sc->result set to %08xh\n", sc->result));
+		dprintk((KERN_NOTICE "  sc->result set to %08xh\n", sc->result));
+	} /* end of address reply case */
+
+	/* Unmap the DMA buffers, if any. */
+	if (sc->use_sg) {
+		pci_unmap_sg(ioc->pcidev, (struct scatterlist *) sc->request_buffer,
+			    sc->use_sg, scsi_to_pci_dma_dir(sc->sc_data_direction));
+	} else if (sc->request_bufflen) {
+		scPrivate	*my_priv;
+
+		my_priv = (scPrivate *) &sc->SCp;
+		pci_unmap_single(ioc->pcidev, (dma_addr_t)(ulong)my_priv->p1,
+			   sc->request_bufflen,
+			   scsi_to_pci_dma_dir(sc->sc_data_direction));
 	}
 
-	if (sc != NULL) {
-		unsigned long flags;
+	hd->ScsiLookup[req_idx] = NULL;
 
-		/* Unmap the DMA buffers, if any. */
-		if (sc->use_sg) {
-			pci_unmap_sg(ioc->pcidev,
-				     (struct scatterlist *) sc->request_buffer,
-				     sc->use_sg,
-				     scsi_to_pci_dma_dir(sc->sc_data_direction));
-		} else if (sc->request_bufflen) {
-			pci_unmap_single(ioc->pcidev,
-					 (dma_addr_t)((long)sc->SCp.ptr),
-					 sc->request_bufflen,
-					 scsi_to_pci_dma_dir(sc->sc_data_direction));
-		}
+	sc->host_scribble = NULL;	/* CHECKME! - Do we need to clear this??? */
 
-		spin_lock_irqsave(&io_request_lock, flags);
-		sc->scsi_done(sc);
-		spin_unlock_irqrestore(&io_request_lock, flags);
-	}
+	spin_lock_irqsave(&io_request_lock, flags);
+	sc->scsi_done(sc);		/* Issue the command callback */
+	spin_unlock_irqrestore(&io_request_lock, flags);
 
+	/* Free Chain buffers */
+	mptscsih_freeChainBuffers(hd, req_idx);
 	return 1;
 }
 
-#ifndef MPT_SCSI_USE_NEW_EH
+#ifndef MPT_SCSI_USE_NEW_EH	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	search_taskQ - Search SCSI task mgmt request queue for specific
- *			request type
+ *	request type.
  *	@remove: (Boolean) Should request be removed if found?
  *	@sc: Pointer to Scsi_Cmnd structure
  *	@task_type: Task type to search for
@@ -447,42 +628,55 @@
  *	was not found.
  */
 static MPT_FRAME_HDR *
-search_taskQ(int remove, Scsi_Cmnd *sc, u8 task_type)
+search_taskQ(int remove, Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, u8 task_type)
 {
 	MPT_FRAME_HDR *mf = NULL;
 	unsigned long flags;
 	int count = 0;
 	int list_sz;
 
-	dslprintk((KERN_INFO MYNAM ": spinlock#1\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	list_sz = mpt_scsih_taskQ_cnt;
-	if (! Q_IS_EMPTY(&mpt_scsih_taskQ)) {
-		mf = mpt_scsih_taskQ.head;
+	dprintk((KERN_INFO MYNAM ": search_taskQ(%d,sc=%p,%d) called\n",
+			remove, sc, task_type));
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	list_sz = hd->taskQcnt;
+	if (! Q_IS_EMPTY(&hd->taskQ)) {
+		mf = hd->taskQ.head;
 		do {
 			count++;
 			if (mf->u.frame.linkage.argp1 == sc &&
 			    mf->u.frame.linkage.arg1 == task_type) {
 				if (remove) {
 					Q_DEL_ITEM(&mf->u.frame.linkage);
-					mpt_scsih_taskQ_cnt--;
+					hd->taskQcnt--;
+					atomic_dec(&mpt_taskQdepth);
+
+					/* Don't save mf into nextmf because
+					 * exit after command has been deleted.
+					 */
+
+					/* Place the MF back on the FreeQ */
+					Q_ADD_TAIL(&hd->ioc->FreeQ,
+						&mf->u.frame.linkage,
+						MPT_FRAME_HDR);
+#ifdef MFCNT
+					hd->ioc->mfcnt--;
+#endif
 				}
 				break;
 			}
-		} while ((mf = mf->u.frame.linkage.forw) != (MPT_FRAME_HDR*)&mpt_scsih_taskQ);
-		if (mf == (MPT_FRAME_HDR*)&mpt_scsih_taskQ) {
+		} while ((mf = mf->u.frame.linkage.forw) != (MPT_FRAME_HDR*)&hd->taskQ);
+		if (mf == (MPT_FRAME_HDR*)&hd->taskQ) {
 			mf = NULL;
 		}
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
 	if (list_sz) {
-		dprintk((KERN_INFO MYNAM ": search_taskQ(%d,%p,%d) results=%p (%sFOUND%s)!\n",
-				   remove, sc, task_type,
+		dprintk((KERN_INFO "  Results=%p (%sFOUND%s)!\n",
 				   mf,
 				   mf ? "" : "NOT_",
 				   (mf && remove) ? "+REMOVED" : "" ));
-		dprintk((KERN_INFO MYNAM ": (searched thru %d of %d items on taskQ)\n",
+		dprintk((KERN_INFO "  (searched thru %d of %d items on taskQ)\n",
 				   count,
 				   list_sz ));
 	}
@@ -490,2107 +684,6547 @@
 	return mf;
 }
 
-#endif
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-
-/*
- *  Hack!  I'd like to report if a device is returning QUEUE_FULL
- *  but maybe not each and every time...
- */
-static long last_queue_full = 0;
-
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	mptscsih_report_queue_full - Report QUEUE_FULL status returned
- *	from a SCSI target device.
- *	@sc: Pointer to Scsi_Cmnd structure
- *	@pScsiReply: Pointer to SCSIIOReply_t
- *	@pScsiReq: Pointer to original SCSI request
+ *	clean_taskQ - Clean the  SCSI task mgmt request for
+ *			this SCSI host instance.
+ *	@hd: MPT_SCSI_HOST pointer
  *
- *	This routine periodically reports QUEUE_FULL status returned from a
- *	SCSI target device.  It reports this to the console via kernel
- *	printk() API call, not more than once every 10 seconds.
+ *	Returns: None.
  */
 static void
-mptscsih_report_queue_full(Scsi_Cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq)
+clean_taskQ(MPT_SCSI_HOST *hd)
 {
-	long time = jiffies;
+	MPT_FRAME_HDR *mf = NULL;
+	MPT_FRAME_HDR *nextmf = NULL;
+	MPT_ADAPTER *ioc = hd->ioc;
+	unsigned long flags;
 
-	if (time - last_queue_full > 10 * HZ) {
-		printk(KERN_WARNING MYNAM ": Device reported QUEUE_FULL!  SCSI bus:target:lun = %d:%d:%d\n",
-				0, sc->target, sc->lun);
-		last_queue_full = time;
+	dprintk((KERN_INFO MYNAM ": clean_taskQ called\n"));
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	if (! Q_IS_EMPTY(&hd->taskQ)) {
+		mf = hd->taskQ.head;
+		do {
+			Q_DEL_ITEM(&mf->u.frame.linkage);
+			hd->taskQcnt--;
+			atomic_dec(&mpt_taskQdepth);
+
+			nextmf = mf->u.frame.linkage.forw;
+
+			/* Place the MF back on the FreeQ */
+			Q_ADD_TAIL(&ioc->FreeQ, &mf->u.frame.linkage,
+				MPT_FRAME_HDR);
+#ifdef MFCNT
+			hd->ioc->mfcnt--;
+#endif
+		} while ((mf = nextmf) != (MPT_FRAME_HDR*)&hd->taskQ);
 	}
-}
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int BeenHereDoneThat = 0;
+	return;
+}
 
-/*  SCSI fops start here...  */
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	mptscsih_detect - Register MPT adapter(s) as SCSI host(s) with
- *	linux scsi mid-layer.
- *	@tpnt: Pointer to Scsi_Host_Template structure
- *
- *	(linux Scsi_Host_Template.detect routine)
+/*
+ *	search_taskQ_for_cmd - Search the  SCSI task mgmt request queue for
+ *			the specified command. If found, delete
+ *	@hd: MPT_SCSI_HOST pointer
  *
- *	Returns number of SCSI host adapters that were successfully
- *	registered with the linux scsi mid-layer via the scsi_register()
- *	API call.
+ *	Returns: None.
  */
-int
-mptscsih_detect(Scsi_Host_Template *tpnt)
+static void
+search_taskQ_for_cmd(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd)
 {
-	struct Scsi_Host	*sh = NULL;
-	MPT_SCSI_HOST		*hd = NULL;
-	MPT_ADAPTER		*this;
-	unsigned long		 flags;
-	int			 sz;
-	u8			*mem;
+	MPT_FRAME_HDR *mf = NULL;
+	unsigned long flags;
+	int count = 0;
 
-	if (! BeenHereDoneThat++) {
-		show_mptmod_ver(my_NAME, my_VERSION);
+	dprintk((KERN_INFO MYNAM ": search_taskQ_for_cmd(sc=%p) called\n", sc));
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	if (! Q_IS_EMPTY(&hd->taskQ)) {
+		mf = hd->taskQ.head;
+		do {
+			count++;
+			if (mf->u.frame.linkage.argp1 == sc) {
+				Q_DEL_ITEM(&mf->u.frame.linkage);
+				hd->taskQcnt--;
+				atomic_dec(&mpt_taskQdepth);
+				dprintk((KERN_INFO MYNAM
+					": Cmd %p found! Deleting.\n", sc));
 
-		if ((ScsiDoneCtx = mpt_register(mptscsih_io_done, MPTSCSIH_DRIVER)) <= 0) {
-			printk(KERN_ERR MYNAM ": Failed to register callback1 with MPT base driver\n");
-			return mpt_scsi_hosts;
-		}
-		if ((ScsiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSCSIH_DRIVER)) <= 0) {
-			printk(KERN_ERR MYNAM ": Failed to register callback2 with MPT base driver\n");
-			return mpt_scsi_hosts;
-		}
+				/* Don't save mf into nextmf because
+				 * exit after command has been deleted.
+				 */
 
-#ifndef MPT_SCSI_USE_NEW_EH
-		Q_INIT(&mpt_scsih_taskQ, MPT_FRAME_HDR);
-		spin_lock_init(&mpt_scsih_taskQ_lock);
+				/* Place the MF back on the FreeQ */
+				Q_ADD_TAIL(&hd->ioc->FreeQ,
+					&mf->u.frame.linkage,
+					MPT_FRAME_HDR);
+#ifdef MFCNT
+				hd->ioc->mfcnt--;
 #endif
+				break;
+			}
+		} while ((mf = mf->u.frame.linkage.forw) != (MPT_FRAME_HDR*)&hd->taskQ);
+	}
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
-		if (mpt_event_register(ScsiDoneCtx, mptscsih_event_process) == 0) {
-			dprintk((KERN_INFO MYNAM ": Registered for IOC event notifications\n"));
-		} else {
-			/* FIXME! */
-		}
+	return;
+}
 
-		if (mpt_reset_register(ScsiDoneCtx, mptscsih_ioc_reset) == 0) {
-			dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
-		} else {
-			/* FIXME! */
-		}
-	}
+#endif		/* } MPT_SCSI_USE_NEW_EH */
 
-	dprintk((KERN_INFO MYNAM ": mpt_scsih_detect()\n"));
 
-	this = mpt_adapter_find_first();
-	while (this != NULL) {
-		/* FIXME!  Multi-port (aka FC929) support...
-		 * for (i = 0; i < this->facts.NumberOfPorts; i++)
-		 */
+/*
+ * Flush all commands on the doneQ.
+ * Lock Q when deleting/adding members
+ * Lock io_request_lock for OS callback.
+ */
+static void
+flush_doneQ(MPT_SCSI_HOST *hd)
+{
+	MPT_DONE_Q	*buffer;
+	Scsi_Cmnd	*SCpnt;
+	unsigned long	 flags;
 
-		/* 20010215 -sralston
-		 *  Added sanity check on SCSI Initiator-mode enabled
-		 *  for this MPT adapter.
-		 */
-		if (!(this->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR)) {
-			printk(KERN_ERR MYNAM ": Skipping %s because SCSI Initiator mode is NOT enabled!\n",
-					this->name);
-			this = mpt_adapter_find_next(this);
-			continue;
+	/* Flush the doneQ.
+	 */
+	dprintk((KERN_INFO MYNAM ": flush_doneQ called\n"));
+	while (1) {
+		spin_lock_irqsave(&hd->freedoneQlock, flags);
+		if (Q_IS_EMPTY(&hd->doneQ)) {
+			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			break;
 		}
 
-		/* 20010202 -sralston
-		 *  Added sanity check on readiness of the MPT adapter.
+		buffer = hd->doneQ.head;
+		/* Delete from Q
 		 */
-		if (this->last_state != MPI_IOC_STATE_OPERATIONAL) {
-			printk(KERN_ERR MYNAM ": ERROR - Skipping %s because it's not operational!\n",
-					this->name);
-			this = mpt_adapter_find_next(this);
-			continue;
-		}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-		tpnt->proc_dir = &proc_mpt_scsihost;
-#endif
-		sh = scsi_register(tpnt, sizeof(MPT_SCSI_HOST));
-		if (sh != NULL) {
-			save_flags(flags);
-			cli();
-			sh->io_port = 0;
-			sh->n_io_port = 0;
-			sh->irq = 0;
-
-			/* Yikes!  This is important!
-			 * Otherwise, by default, linux only scans target IDs 0-7!
-			 *
-			 * BUG FIX!  20010618 -sralston & pdelaney
-			 * FC919 testing was encountering "duplicate" FC devices,
-			 * as it turns out because the 919 was returning 512
-			 * for PortFacts.MaxDevices, causing a wraparound effect
-			 * in SCSI IO requests.  So instead of using:
-			 *     sh->max_id = this->pfacts[0].MaxDevices - 1
-			 * we'll use a definitive max here.
-			 */
-			sh->max_id = MPT_MAX_FC_DEVICES;
-
-			sh->this_id = this->pfacts[0].PortSCSIID;
-
-			restore_flags(flags);
-
-			hd = (MPT_SCSI_HOST *) sh->hostdata;
-			hd->ioc = this;
-			hd->port = 0;		/* FIXME! */
-
-			/* SCSI needs Scsi_Cmnd lookup table!
-			 * (with size equal to req_depth*PtrSz!)
-			 */
-			sz = hd->ioc->req_depth * sizeof(void *);
-			mem = kmalloc(sz, GFP_KERNEL);
-			if (mem == NULL)
-				return mpt_scsi_hosts;
-
-			memset(mem, 0, sz);
-			hd->ScsiLookup = (struct scsi_cmnd **) mem;
-
-			dprintk((KERN_INFO MYNAM ": ScsiLookup @ %p, sz=%d\n",
-				 hd->ScsiLookup, sz));
-
-			/* SCSI also needs SG buckets/hunk management!
-			 * (with size equal to N * req_sz * req_depth!)
-			 * (where N is number of SG buckets per hunk)
-			 */
-			sz = MPT_SG_BUCKETS_PER_HUNK * hd->ioc->req_sz * hd->ioc->req_depth;
-			mem = pci_alloc_consistent(hd->ioc->pcidev, sz,
-						   &hd->SgHunksDMA);
-			if (mem == NULL)
-				return mpt_scsi_hosts;
+		Q_DEL_ITEM(buffer);
 
-			memset(mem, 0, sz);
-			hd->SgHunks = (u8*)mem;
-
-			dprintk((KERN_INFO MYNAM ": SgHunks    @ %p(%08x), sz=%d\n",
-				 hd->SgHunks, hd->SgHunksDMA, sz));
+		/* Set the Scsi_Cmnd pointer
+		 */
+		SCpnt = (Scsi_Cmnd *) buffer->argp;
+		buffer->argp = NULL;
 
-			hd->qtag_tick = jiffies;
+		/* Add to the freeQ
+		 */
+		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
 
-			this->sh = sh;
-			mpt_scsi_hosts++;
-		}
-		this = mpt_adapter_find_next(this);
+		/* Do the OS callback.
+		 */
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
 	}
 
-	return mpt_scsi_hosts;
+	return;
 }
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-    static char *info_kbuf = NULL;
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	mptscsih_release - Unregister SCSI host from linux scsi mid-layer
- *	@host: Pointer to Scsi_Host structure
+/*
+ * Search the doneQ for a specific command. If found, delete from Q.
+ * Calling function will finish processing.
+ */
+static void
+search_doneQ_for_cmd(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt)
+{
+	unsigned long	 flags;
+	MPT_DONE_Q	*buffer;
+
+	spin_lock_irqsave(&hd->freedoneQlock, flags);
+	if (!Q_IS_EMPTY(&hd->doneQ)) {
+		buffer = hd->doneQ.head;
+		do {
+			Scsi_Cmnd *sc = (Scsi_Cmnd *) buffer->argp;
+			if (SCpnt == sc) {
+				Q_DEL_ITEM(buffer);
+				SCpnt->result = sc->result;
+
+				/* Set the Scsi_Cmnd pointer
+				 */
+				buffer->argp = NULL;
+
+				/* Add to the freeQ
+				 */
+				Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+				break;
+			}
+		} while ((buffer = buffer->forw) != (MPT_DONE_Q *) &hd->doneQ);
+	}
+	spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+	return;
+}
+
+/*
+ *	mptscsih_flush_running_cmds - For each command found, search
+ *		Scsi_Host instance taskQ and reply to OS.
+ *		Called only if recovering from a FW reload.
+ *	@hd: Pointer to a SCSI HOST structure
  *
- *	(linux Scsi_Host_Template.release routine)
- *	This routine releases all resources associated with the SCSI host
- *	adapter.
+ *	Returns: None.
  *
- *	Returns 0 for success.
+ *	Must be called while new I/Os are being queued.
  */
-int
-mptscsih_release(struct Scsi_Host *host)
+static void
+mptscsih_flush_running_cmds(MPT_SCSI_HOST *hd)
 {
-	MPT_SCSI_HOST	*hd;
-#ifndef MPT_SCSI_USE_NEW_EH
+	Scsi_Cmnd	*SCpnt = NULL;
+	MPT_FRAME_HDR	*mf = NULL;
+	int		 ii;
+	int		 max = hd->ioc->req_depth;
 	unsigned long	 flags;
 
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	if (mpt_scsih_taskQ_bh_active) {
-		int count = 10 * HZ;
+	dprintk((KERN_INFO MYNAM ": flush_ScsiLookup called\n"));
+	for (ii= 0; ii < max; ii++) {
+		if ((SCpnt = hd->ScsiLookup[ii]) != NULL) {
 
-		dprintk((KERN_INFO MYNAM ": Info: Zapping TaskMgmt thread!\n"));
+			/* Command found.
+			 */
+
+#ifndef MPT_SCSI_USE_NEW_EH
+			/* Search taskQ, if found, delete.
+			 */
+			search_taskQ_for_cmd(SCpnt, hd);
+#endif
+
+			/* Search pendingQ, if found, 
+			 * delete from Q. If found, do not decrement
+			 * queue_depth, command never posted.
+			 */
+			if (mptscsih_search_pendingQ(hd, ii) == NULL)
+				atomic_dec(&queue_depth);
 
-		/* Zap the taskQ! */
-		Q_INIT(&mpt_scsih_taskQ, MPT_FRAME_HDR);
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+			/* Null ScsiLookup index
+			 */
+			hd->ScsiLookup[ii] = NULL;
 
-		while(mpt_scsih_taskQ_bh_active && --count) {
-			current->state = TASK_INTERRUPTIBLE;
-			schedule_timeout(1);
+			mf = MPT_INDEX_2_MFPTR(hd->ioc, ii);
+			dmfprintk(( "flush: ScsiDone (mf=%p,sc=%p)\n",
+					mf, SCpnt));
+
+			/* Set status
+			 * Do OS callback
+			 * Free chain buffers
+			 * Free message frame
+			 */
+			SCpnt->result = DID_RESET << 16;
+			SCpnt->host_scribble = NULL;
+			spin_lock_irqsave(&io_request_lock, flags);
+			SCpnt->scsi_done(SCpnt);	/* Issue the command callback */
+			spin_unlock_irqrestore(&io_request_lock, flags);
+
+			/* Free Chain buffers */
+			mptscsih_freeChainBuffers(hd, ii);
+
+			/* Free Message frames */
+			mpt_free_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
 		}
-		if (!count)
-			printk(KERN_ERR MYNAM ": ERROR! TaskMgmt thread still active!\n");
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-#endif
+	return;
+}
 
-	hd = (MPT_SCSI_HOST *) host->hostdata;
-	if (hd != NULL) {
-		int sz1, sz2;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_initChainBuffers - Allocate memory for and initialize
+ *	chain buffers, chain buffer control arrays and spinlock.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@init: If set, initialize the spin lock.
+ */
+static int
+mptscsih_initChainBuffers (MPT_SCSI_HOST *hd, int init)
+{
+	MPT_FRAME_HDR	*chain;
+	u8		*mem;
+	unsigned long	flags;
+	int		sz, ii, numChain;
 
-		sz1 = sz2 = 0;
-		if (hd->ScsiLookup != NULL) {
-			sz1 = hd->ioc->req_depth * sizeof(void *);
-			kfree(hd->ScsiLookup);
-			hd->ScsiLookup = NULL;
-		}
 
-		if (hd->SgHunks != NULL) {
+        /* Chain buffer allocations
+	 * Allocate and initialize tracker structures
+	 */
+	if (hd->ioc->req_sz <= 64)
+		numChain = MPT_SG_REQ_64_SCALE * hd->ioc->req_depth;
+	else if (hd->ioc->req_sz <= 96)
+		numChain = MPT_SG_REQ_96_SCALE * hd->ioc->req_depth;
+	else
+		numChain = MPT_SG_REQ_128_SCALE * hd->ioc->req_depth;
 
-			sz2 = MPT_SG_BUCKETS_PER_HUNK * hd->ioc->req_sz * hd->ioc->req_depth;
-			pci_free_consistent(hd->ioc->pcidev, sz2,
-					    hd->SgHunks, hd->SgHunksDMA);
-			hd->SgHunks = NULL;
-		}
-		dprintk((KERN_INFO MYNAM ": Free'd ScsiLookup (%d) and SgHunks (%d) memory\n", sz1, sz2));
+	sz = numChain * sizeof(int);
+
+	if (hd->ReqToChain == NULL) {
+		mem = kmalloc(sz, GFP_KERNEL);
+		if (mem == NULL)
+			return -1;
+
+		hd->ReqToChain = (int *) mem;
+	} else {
+		mem = (u8 *) hd->ReqToChain;
 	}
+	memset(mem, 0xFF, sz);
 
-	if (mpt_scsi_hosts) {
-		if (--mpt_scsi_hosts == 0) {
-#if 0
-			mptscsih_flush_pending();
-#endif
-			mpt_reset_deregister(ScsiDoneCtx);
-			dprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
+	if (hd->ChainToChain == NULL) {
+		mem = kmalloc(sz, GFP_KERNEL);
+		if (mem == NULL)
+			return -1;
 
-			mpt_event_deregister(ScsiDoneCtx);
-			dprintk((KERN_INFO MYNAM ": Deregistered for IOC event notifications\n"));
+		hd->ChainToChain = (int *) mem;
+	} else {
+		mem = (u8 *) hd->ChainToChain;
+	}
+	memset(mem, 0xFF, sz);
 
-			mpt_deregister(ScsiDoneCtx);
-			mpt_deregister(ScsiTaskCtx);
+	if (hd->ChainBuffer == NULL) {
+		/* Allocate free chain buffer pool
+		 */
+		sz = numChain * hd->ioc->req_sz;
+		mem = pci_alloc_consistent(hd->ioc->pcidev, sz, &hd->ChainBufferDMA);
+		if (mem == NULL)
+			return -1;
 
-			if (info_kbuf != NULL)
-				kfree(info_kbuf);
-		}
+		hd->ChainBuffer = (u8*)mem;
+	} else {
+		mem = (u8 *) hd->ChainBuffer;
+	}
+	memset(mem, 0, sz);
+
+	dprintk((KERN_INFO "  ChainBuffer    @ %p(%p), sz=%d\n",
+		 hd->ChainBuffer, (void *)(ulong)hd->ChainBufferDMA, sz));
+
+	/* Initialize the free chain Q.
+	 */
+	if (init) {
+		spin_lock_init(&hd->FreeChainQlock);
 	}
 
+	spin_lock_irqsave (&hd->FreeChainQlock, flags);
+	Q_INIT(&hd->FreeChainQ, MPT_FRAME_HDR);
+
+	/* Post the chain buffers to the FreeChainQ.
+	 */
+	mem = (u8 *)hd->ChainBuffer;
+	for (ii=0; ii < numChain; ii++) {
+		chain = (MPT_FRAME_HDR *) mem;
+		Q_ADD_TAIL(&hd->FreeChainQ.head, &chain->u.frame.linkage, MPT_FRAME_HDR);
+		mem += hd->ioc->req_sz;
+	}
+	spin_unlock_irqrestore(&hd->FreeChainQlock, flags);
+
 	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	mptscsih_info - Return information about MPT adapter
- *	@SChost: Pointer to Scsi_Host structure
- *
- *	(linux Scsi_Host_Template.info routine)
+/*
+ *  Hack! It might be nice to report if a device is returning QUEUE_FULL
+ *  but maybe not each and every time...
+ */
+static long last_queue_full = 0;
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_report_queue_full - Report QUEUE_FULL status returned
+ *	from a SCSI target device.
+ *	@sc: Pointer to Scsi_Cmnd structure
+ *	@pScsiReply: Pointer to SCSIIOReply_t
+ *	@pScsiReq: Pointer to original SCSI request
  *
- *	Returns pointer to buffer where information was written.
+ *	This routine periodically reports QUEUE_FULL status returned from a
+ *	SCSI target device.  It reports this to the console via kernel
+ *	printk() API call, not more than once every 10 seconds.
  */
-const char *
-mptscsih_info(struct Scsi_Host *SChost)
+static void
+mptscsih_report_queue_full(Scsi_Cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq)
 {
-	MPT_SCSI_HOST *h;
-	int size = 0;
-
-	if (info_kbuf == NULL)
-		if ((info_kbuf = kmalloc(0x1000 /* 4Kb */, GFP_KERNEL)) == NULL)
-			return info_kbuf;
+	long time = jiffies;
 
-	h = (MPT_SCSI_HOST *)SChost->hostdata;
-	info_kbuf[0] = '\0';
-	mpt_print_ioc_summary(h->ioc, info_kbuf, &size, 0, 0);
-	info_kbuf[size-1] = '\0';
+	if (time - last_queue_full > 10 * HZ) {
+		char *ioc_str = "ioc?";
 
-	return info_kbuf;
+		if (sc->host && sc->host->hostdata)
+			ioc_str = ((MPT_SCSI_HOST *)sc->host->hostdata)->ioc->name;
+		printk(MYIOC_s_WARN_FMT "Device (%d:%d:%d) reported QUEUE_FULL!\n",
+				ioc_str, 0, sc->target, sc->lun);
+		last_queue_full = time;
+	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-	static int max_qd = 1;
-#ifdef MPT_DEBUG
-	static int max_sges = 0;
-	static int max_xfer = 0;
-#endif
-#if 0
-	static int max_num_sges = 0;
-	static int max_sgent_len = 0;
-#endif
-#if 0
-static int index_log[128];
-static int index_ent = 0;
-static __inline__ void ADD_INDEX_LOG(int req_ent)
-{
-	int i = index_ent++;
+static int BeenHereDoneThat = 0;
 
-	index_log[i & (128 - 1)] = req_ent;
-}
-#else
-#define ADD_INDEX_LOG(req_ent)	do { } while(0)
-#endif
+/*  SCSI host fops start here...  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mptscsih_qcmd - Primary Fusion MPT SCSI initiator IO start routine.
- *	@SCpnt: Pointer to Scsi_Cmnd structure
- *	@done: Pointer SCSI mid-layer IO completion function
+ *	mptscsih_detect - Register MPT adapter(s) as SCSI host(s) with
+ *	linux scsi mid-layer.
+ *	@tpnt: Pointer to Scsi_Host_Template structure
  *
- *	(linux Scsi_Host_Template.queuecommand routine)
- *	This is the primary SCSI IO start routine.  Create a MPI SCSIIORequest
- *	from a linux Scsi_Cmnd request and send it to the IOC.
+ *	(linux Scsi_Host_Template.detect routine)
  *
- *	Returns 0. (rtn value discarded by linux scsi mid-layer)
+ *	Returns number of SCSI host adapters that were successfully
+ *	registered with the linux scsi mid-layer via the scsi_register()
+ *	API call.
  */
 int
-mptscsih_qcmd(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
+mptscsih_detect(Scsi_Host_Template *tpnt)
 {
-	struct Scsi_Host	*host;
-	MPT_SCSI_HOST		*hd;
-	MPT_FRAME_HDR		*mf;
-	SCSIIORequest_t		*pScsiReq;
-	int	 datadir;
-	u32	 len;
-	u32	 sgdir;
-	u32	 scsictl;
-	u32	 scsidir;
-	u32	 qtag;
-	u32	*mptr;
-	int	 sge_spill1;
-	int	 frm_sz;
-	int	 sges_left;
-	u32	 chain_offset;
-	int	 my_idx;
-	int	 i;
+	struct Scsi_Host	*sh = NULL;
+	MPT_SCSI_HOST		*hd = NULL;
+	MPT_ADAPTER		*this;
+	MPT_DONE_Q		*freedoneQ;
+	unsigned long		 flags;
+	int			 sz, ii;
+	int			 numSGE = 0;
+	int			 scale;
+	u8			*mem;
 
-	dmfprintk((KERN_INFO MYNAM "_qcmd: SCpnt=%p, done()=%p\n",
-		    SCpnt, done));
+	if (! BeenHereDoneThat++) {
+		show_mptmod_ver(my_NAME, my_VERSION);
 
-	host = SCpnt->host;
-	hd = (MPT_SCSI_HOST *) host->hostdata;
-	
-#if 0
-	if (host->host_busy >= 60) {
-		MPT_ADAPTER *ioc = hd->ioc;
-		u16 pci_command, pci_status;
-
-		/* The IOC is probably hung, investigate status. */
-		printk("MPI: IOC probably hung IOCSTAT[%08x] INTSTAT[%08x] REPLYFIFO[%08x]\n",
-		       readl(&ioc->chip.fc9xx->DoorbellValue),
-		       readl(&ioc->chip.fc9xx->IntStatus),
-		       readl(&ioc->chip.fc9xx->ReplyFifo));
-		pci_read_config_word(ioc->pcidev, PCI_COMMAND, &pci_command);
-		pci_read_config_word(ioc->pcidev, PCI_STATUS, &pci_status);
-		printk("MPI: PCI command[%04x] status[%04x]\n", pci_command, pci_status);
-		{
-			/* DUMP req index logger. */
-			int begin, end;
+		ScsiDoneCtx = mpt_register(mptscsih_io_done, MPTSCSIH_DRIVER);
+		ScsiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSCSIH_DRIVER);
+		ScsiScanDvCtx = mpt_register(mptscsih_scandv_complete, MPTSCSIH_DRIVER);
 
-			begin = (index_ent - 65) & (128 - 1);
-			end = index_ent & (128 - 1);
-			printk("MPI: REQ_INDEX_HIST[");
-			while (begin != end) {
-				printk("(%04x)", index_log[begin]);
-				begin = (begin + 1) & (128 - 1);
-			}
-			printk("\n");
-		}
-		sti();
-		while(1)
-			barrier();
-	}
+#ifndef MPT_SCSI_USE_NEW_EH
+		spin_lock_init(&mytaskQ_lock);
 #endif
 
-	SCpnt->scsi_done = done;
+		if (mpt_event_register(ScsiDoneCtx, mptscsih_event_process) == 0) {
+			dprintk((KERN_INFO MYNAM ": Registered for IOC event notifications\n"));
+		} else {
+			/* FIXME! */
+		}
 
-	/* 20000617 -sralston
-	 *  GRRRRR...  Shouldn't have to do this but...
-	 *  Do explicit check for REQUEST_SENSE and cached SenseData.
-	 *  If yes, return cached SenseData.
-	 */
-#ifdef MPT_SCSI_CACHE_AUTOSENSE
-	{
-		MPT_SCSI_DEV	*mpt_sdev;
+		if (mpt_reset_register(ScsiDoneCtx, mptscsih_ioc_reset) == 0) {
+			dprintk((KERN_INFO MYNAM ": Registered for IOC reset notifications\n"));
+		} else {
+			/* FIXME! */
+		}
+	}
+	dprintk((KERN_INFO MYNAM ": mpt_scsih_detect()\n"));
 
-		mpt_sdev = (MPT_SCSI_DEV *) SCpnt->device->hostdata;
-		if (mpt_sdev && SCpnt->cmnd[0] == REQUEST_SENSE) {
-			u8 *dest = NULL;
+#ifdef MODULE
+	/* Evaluate the command line arguments, if any */
+	if (mptscsih)
+		mptscsih_setup(mptscsih);
+#endif
+#ifndef MPT_SCSI_USE_NEW_EH
+	atomic_set(&mpt_taskQdepth, 0);
+#endif
 
-			if (!SCpnt->use_sg)
-				dest = SCpnt->request_buffer;
-			else {
-				struct scatterlist *sg = (struct scatterlist *) SCpnt->request_buffer;
-				if (sg)
-					dest = (u8 *) (unsigned long)sg_dma_address(sg);
+	this = mpt_adapter_find_first();
+	while (this != NULL) {
+		int	 portnum;
+		for (portnum=0; portnum < this->facts.NumberOfPorts; portnum++) {
+
+			/* 20010215 -sralston
+			 *  Added sanity check on SCSI Initiator-mode enabled
+			 *  for this MPT adapter.
+			 */
+			if (!(this->pfacts[portnum].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR)) {
+				printk(MYIOC_s_WARN_FMT "Skipping because SCSI Initiator mode is NOT enabled!\n",
+						this->name);
+				continue;
 			}
 
-			if (dest && mpt_sdev->sense_sz) {
-				memcpy(dest, mpt_sdev->CachedSense.data, mpt_sdev->sense_sz);
-#ifdef MPT_DEBUG
-				{
-					int  i;
-					u8  *sb;
-
-					sb = mpt_sdev->CachedSense.data;
-					if (sb && ((sb[0] & 0x70) == 0x70)) {
-						printk(KERN_WARNING MYNAM ": Returning last cached SCSI (hex) SenseData:\n");
-						printk(KERN_WARNING " ");
-						for (i = 0; i < (8 + sb[7]); i++)
-							printk("%s%02x", i == 13 ? "-" : " ", sb[i]);
-						printk("\n");
-					}
-				}
-#endif
+			/* 20010202 -sralston
+			 *  Added sanity check on readiness of the MPT adapter.
+			 */
+			if (this->last_state != MPI_IOC_STATE_OPERATIONAL) {
+				printk(MYIOC_s_WARN_FMT "Skipping because it's not operational!\n",
+						this->name);
+				continue;
 			}
-			SCpnt->resid = SCpnt->request_bufflen - mpt_sdev->sense_sz;
-			SCpnt->result = 0;
-/*			spin_lock(&io_request_lock);	*/
-			SCpnt->scsi_done(SCpnt);
-/*			spin_unlock(&io_request_lock);	*/
-			return 0;
-		}
-	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+			tpnt->proc_dir = &proc_mpt_scsihost;
 #endif
+			sh = scsi_register(tpnt, sizeof(MPT_SCSI_HOST));
+			if (sh != NULL) {
+				save_flags(flags);
+				cli();
+				sh->io_port = 0;
+				sh->n_io_port = 0;
+				sh->irq = 0;
+
+				/* Yikes!  This is important!
+				 * Otherwise, by default, linux
+				 * only scans target IDs 0-7!
+				 * pfactsN->MaxDevices unreliable
+				 * (not supported in early
+				 *	versions of the FW).
+				 * max_id = 1 + actual max id,
+				 * max_lun = 1 + actual last lun,
+				 *	see hosts.h :o(
+				 */
+				if ((int)this->chip_type > (int)FC929)
+					sh->max_id = MPT_MAX_SCSI_DEVICES;
+				else {
+					/* For FC, increase the queue depth
+					 * from MPT_SCSI_CAN_QUEUE (31)
+					 * to MPT_FC_CAN_QUEUE (63).
+					 */
+					sh->can_queue = MPT_FC_CAN_QUEUE;
+					sh->max_id = MPT_MAX_FC_DEVICES<256 ? MPT_MAX_FC_DEVICES : 255;
+				}
+				sh->max_lun = MPT_LAST_LUN + 1;
 
-	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-/*		return 1;				*/
-		return 0;
-	}
-	pScsiReq = (SCSIIORequest_t *) mf;
+				sh->this_id = this->pfacts[portnum].PortSCSIID;
 
-	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+				/* OS entry to allow host drivers to force
+				 * a queue depth on a per device basis.
+				 */
+				sh->select_queue_depths = mptscsih_select_queue_depths;
 
-	ADD_INDEX_LOG(my_idx);
+				/* Verify that we won't exceed the maximum
+				 * number of chain buffers
+				 * We can optimize:  ZZ = req_sz/sizeof(MptSge_t)
+				 * For 32bit SGE's:
+				 *  numSGE = 1 + (ZZ-1)*(maxChain -1) + ZZ
+				 *               + (req_sz - 64)/sizeof(MptSge_t)
+				 * A slightly different algorithm is required for
+				 * 64bit SGEs.
+				 */
+				scale = this->req_sz/sizeof(MptSge_t);
+				if (sizeof(MptSge_t) == sizeof(SGESimple32_t)) {
+					numSGE = 1 + (scale - 1) * (this->facts.MaxChainDepth-1) + scale +
+						(this->req_sz - 64) / (sizeof(MptSge_t));
+				} else if (sizeof(MptSge_t) == sizeof(SGESimple64_t)) {
+					numSGE = (scale - 1) * (this->facts.MaxChainDepth-1) + scale +
+						(this->req_sz - 60) / (sizeof(MptSge_t));
+				}
 
-	/* Map the data portion, if any. */
-	sges_left = SCpnt->use_sg;
-	if (sges_left) {
-		sges_left = pci_map_sg(hd->ioc->pcidev,
-				       (struct scatterlist *) SCpnt->request_buffer,
-				       sges_left,
-				       scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
-	} else if (SCpnt->request_bufflen) {
-		dma_addr_t buf_dma_addr;
+				if (numSGE < sh->sg_tablesize) {
+					/* Reset this value */
+					dprintk((MYIOC_s_INFO_FMT
+						 "Resetting sg_tablesize to %d from %d\n",
+						 this->name, numSGE, sh->sg_tablesize));
+					sh->sg_tablesize = numSGE;
+				}
 
-		buf_dma_addr = pci_map_single(hd->ioc->pcidev,
-					      SCpnt->request_buffer,
-					      SCpnt->request_bufflen,
-					      scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+				restore_flags(flags);
 
-		/* We hide it here for later unmap. */
-		SCpnt->SCp.ptr = (char *)(unsigned long) buf_dma_addr;
-	}
+				hd = (MPT_SCSI_HOST *) sh->hostdata;
+				hd->ioc = this;
 
-	/*
-	 *  Put together a MPT SCSI request...
-	 */
+				if ((int)this->chip_type > (int)FC929)
+					hd->is_spi = 1;
 
-	/* Assume SimpleQ, NO DATA XFER for now */
+				if (DmpService &&
+				    (this->chip_type == FC919 || this->chip_type == FC929))
+					hd->is_multipath = 1;
 
-	len = SCpnt->request_bufflen;
-	sgdir = 0x00000000;		/* SGL IN  (host<--ioc) */
-	scsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
+				hd->port = 0;		/* FIXME! */
 
-	/*
-	 *  The scsi layer should be handling this stuff
-	 *  (In 2.3.x it does -DaveM)
-	 */
-
-	/*  BUG FIX!  19991030 -sralston
-	 *    TUR's being issued with scsictl=0x02000000 (DATA_IN)!
-	 *    Seems we may receive a buffer (len>0) even when there
-	 *    will be no data transfer!  GRRRRR...
-	 */
-	datadir = mptscsih_io_direction(SCpnt);
-	if (datadir < 0) {
-		scsidir = MPI_SCSIIO_CONTROL_READ;	/* DATA IN  (host<--ioc<--dev) */
-	} else if (datadir > 0) {
-		sgdir	= 0x04000000;			/* SGL OUT  (host-->ioc) */
-		scsidir = MPI_SCSIIO_CONTROL_WRITE;	/* DATA OUT (host-->ioc-->dev) */
-	} else {
-		len = 0;
-	}
-
-	qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
-
-	/*
-	 *  Attach tags to the devices
-	 */
-	if (SCpnt->device->tagged_supported) {
-		/*
-		 *  Some drives are too stupid to handle fairness issues
-		 *  with tagged queueing. We throw in the odd ordered
-		 *  tag to stop them starving themselves.
-		 */
-		if ((jiffies - hd->qtag_tick) > (5*HZ)) {
-			qtag = MPI_SCSIIO_CONTROL_ORDEREDQ;
-			hd->qtag_tick = jiffies;
+				/* SCSI needs Scsi_Cmnd lookup table!
+				 * (with size equal to req_depth*PtrSz!)
+				 */
+				sz = hd->ioc->req_depth * sizeof(void *);
+				mem = kmalloc(sz, GFP_KERNEL);
+				if (mem == NULL)
+					goto done;
 
-#if 0
-			/* These are ALWAYS zero!
-			 * (Because this is a place for the device driver to dynamically
-			 *  assign tag numbers any way it sees fit.  That's why -DaveM)
-			 */
-			dprintk((KERN_DEBUG MYNAM ": sc->device->current_tag = %08x\n",
-					SCpnt->device->current_tag));
-			dprintk((KERN_DEBUG MYNAM ": sc->tag                 = %08x\n",
-					SCpnt->tag));
-#endif
-		}
-#if 0
-		else {
-			/* Hmmm...  I always see value of 0 here,
-			 *  of which {HEAD_OF, ORDERED, SIMPLE} are NOT!  -sralston
-			 * (Because this is a place for the device driver to dynamically
-			 *  assign tag numbers any way it sees fit.  That's why -DaveM)
-			 *
-			 * if (SCpnt->tag == HEAD_OF_QUEUE_TAG)
-			 */
-			if (SCpnt->device->current_tag == HEAD_OF_QUEUE_TAG)
-				qtag = MPI_SCSIIO_CONTROL_HEADOFQ;
-			else if (SCpnt->tag == ORDERED_QUEUE_TAG)
-				qtag = MPI_SCSIIO_CONTROL_ORDEREDQ;
-		}
-#endif
-	}
+				memset(mem, 0, sz);
+				hd->ScsiLookup = (struct scsi_cmnd **) mem;
 
-	scsictl = scsidir | qtag;
+				dprintk((MYIOC_s_INFO_FMT "ScsiLookup @ %p, sz=%d\n",
+					 this->name, hd->ScsiLookup, sz));
 
-	frm_sz = hd->ioc->req_sz;
+				if (mptscsih_initChainBuffers(hd, 1) < 0)
+					goto done;
 
-	/* Ack!
-	 * sge_spill1 = 9;
-	 */
-	sge_spill1 = (frm_sz - (sizeof(SCSIIORequest_t) - sizeof(SGEIOUnion_t) + sizeof(SGEChain32_t))) / 8;
-	/*  spill1: for req_sz == 128 (128-48==80, 80/8==10 SGEs max, first time!), --> use 9
-	 *  spill1: for req_sz ==  96 ( 96-48==48, 48/8== 6 SGEs max, first time!), --> use 5
-	 */
-	dsgprintk((KERN_INFO MYNAM ": SG: %x     spill1 = %d\n",
-		   my_idx, sge_spill1));
-
-#ifdef MPT_DEBUG
-	if (sges_left > max_sges) {
-		max_sges = sges_left;
-		dprintk((KERN_INFO MYNAM ": MPT_MaxSges = %d\n", max_sges));
-	}
-#endif
-#if 0
-	if (sges_left > max_num_sges) {
-		max_num_sges = sges_left;
-		printk(KERN_INFO MYNAM ": MPT_MaxNumSges = %d\n", max_num_sges);
-	}
-#endif
+				/* Allocate memory for free and doneQ's
+				 */
+				sz = sh->can_queue * sizeof(MPT_DONE_Q);
+				mem = kmalloc(sz, GFP_KERNEL);
+				if (mem == NULL)
+					goto done;
 
-	dsgprintk((KERN_INFO MYNAM ": SG: %x     sges_left = %d (initially)\n",
-		   my_idx, sges_left));
+				memset(mem, 0xFF, sz);
+				hd->memQ = mem;
 
-	chain_offset = 0;
-	if (sges_left > (sge_spill1+1)) {
-#if 0
-		chain_offset = 0x1E;
-#endif
-		chain_offset = (frm_sz - 8) / 4;
-	}
+				/* Initialize the free, done and pending Qs.
+				 */
+				Q_INIT(&hd->freeQ, MPT_DONE_Q);
+				Q_INIT(&hd->doneQ, MPT_DONE_Q);
+				Q_INIT(&hd->pendingQ, MPT_DONE_Q);
+				spin_lock_init(&hd->freedoneQlock);
+
+				mem = hd->memQ;
+				for (ii=0; ii < sh->can_queue; ii++) {
+					freedoneQ = (MPT_DONE_Q *) mem;
+					Q_ADD_TAIL(&hd->freeQ.head, freedoneQ, MPT_DONE_Q);
+					mem += sizeof(MPT_DONE_Q);
+				}
 
-	pScsiReq->TargetID = SCpnt->target;
-	pScsiReq->Bus = hd->port;
-	pScsiReq->ChainOffset = chain_offset;
-	pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
-	pScsiReq->CDBLength = SCpnt->cmd_len;
+				/* Initialize this Scsi_Host
+				 * internal task Q.
+				 */
+				Q_INIT(&hd->taskQ, MPT_FRAME_HDR);
+				hd->taskQcnt = 0;
 
-/* We have 256 bytes alloc'd per IO; let's use it. */
-/*	pScsiReq->SenseBufferLength = SNS_LEN(SCpnt);	*/
-	pScsiReq->SenseBufferLength = 255;
+				/* Allocate memory for the device structures.
+				 * A non-Null pointer at an offset
+				 * indicates a device exists.
+				 * max_id = 1 + maximum id (hosts.h)
+				 */
+				sz = sh->max_id * sizeof(void *);
+				mem = kmalloc(sz, GFP_KERNEL);
+				if (mem == NULL)
+					goto done;
 
-	pScsiReq->Reserved = 0;
-	pScsiReq->MsgFlags = 0;
-	pScsiReq->LUN[0] = 0;
-	pScsiReq->LUN[1] = SCpnt->lun;
-	pScsiReq->LUN[2] = 0;
-	pScsiReq->LUN[3] = 0;
-	pScsiReq->LUN[4] = 0;
-	pScsiReq->LUN[5] = 0;
-	pScsiReq->LUN[6] = 0;
-	pScsiReq->LUN[7] = 0;
-	pScsiReq->Control = cpu_to_le32(scsictl);
+				memset(mem, 0, sz);
+				hd->Targets = (VirtDevice **) mem;
 
-	/*
-	 *  Write SCSI CDB into the message
-	 */
-	for (i = 0; i < 12; i++)
-		pScsiReq->CDB[i] = SCpnt->cmnd[i];
-	for (i = 12; i < 16; i++)
-		pScsiReq->CDB[i] = 0;
+				dprintk((KERN_INFO "  Targets @ %p, sz=%d\n", hd->Targets, sz));
 
-	/* DataLength */
-	pScsiReq->DataLength = cpu_to_le32(len);
 
-	/* SenseBuffer low address */
-	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_pool_dma + (my_idx * 256));
+				/* Clear the TM flags
+				 */
+				hd->tmPending = 0;
+				hd->resetPending = 0;
+				hd->abortSCpnt = NULL;
+				hd->tmPtr = NULL;
+				hd->numTMrequests = 0;
+
+				/* Clear the pointer used to store
+				 * single-threaded commands, i.e., those
+				 * issued during a bus scan, dv and
+				 * configuration pages.
+				 */
+				hd->cmdPtr = NULL;
 
-	mptr = (u32 *) &pScsiReq->SGL;
+				/* Attach the SCSI Host to the IOC structure
+				 */
+				this->sh = sh;
 
-	/*
-	 *  Now fill in the SGList...
-	 *  NOTES: For 128 byte req_sz, we can hold up to 10 simple SGE's
-	 *  in the remaining request frame.  We -could- do unlimited chains
-	 *  but each chain buffer can only be req_sz bytes in size, and
-	 *  we lose one SGE whenever we chain.
-	 *  For 128 req_sz, we can hold up to 16 SGE's per chain buffer.
-	 *  For practical reasons, limit ourselves to 1 overflow chain buffer;
-	 *  giving us 9 + 16 == 25 SGE's max.
-	 *  At 4 Kb per SGE, that yields 100 Kb max transfer.
-	 *
-	 *  (This code needs to be completely changed when/if 64-bit DMA
-	 *   addressing is used, since we will be able to fit much less than
-	 *   10 embedded SG entries. -DaveM)
-	 */
-	if (sges_left) {
-		struct scatterlist *sg = (struct scatterlist *) SCpnt->request_buffer;
-		u32  v1, v2;
-		int  sge_spill2;
-		int  sge_cur_spill;
-		int  sgCnt;
-		u8  *pSgBucket;
-		int  chain_sz;
-
-		len = 0;
-
-		/*	sge_spill2 = 15;
-		 *  spill2: for req_sz == 128 (128/8==16 SGEs max, first time!), --> use 15
-		 *  spill2: for req_sz ==  96 ( 96/8==12 SGEs max, first time!), --> use 11
-		 */
-		sge_spill2 = frm_sz / 8 - 1;
-		dsgprintk((KERN_INFO MYNAM ": SG: %x     spill2 = %d\n",
-			   my_idx, sge_spill2));
-
-		pSgBucket = NULL;
-		sgCnt = 0;
-		sge_cur_spill = sge_spill1;
-		while (sges_left) {
-#if 0
-			if (sg_dma_len(sg) > max_sgent_len) {
-				max_sgent_len = sg_dma_len(sg);
-				printk(KERN_INFO MYNAM ": MPT_MaxSgentLen = %d\n", max_sgent_len);
-			}
-#endif
-			/* Write one simple SGE */
-			v1 = sgdir | 0x10000000 | sg_dma_len(sg);
-			len += sg_dma_len(sg);
-			v2 = sg_dma_address(sg);
-			dsgprintk((KERN_INFO MYNAM ": SG: %x     Writing SGE @%p: %08x %08x, sges_left=%d\n",
-				   my_idx, mptr, v1, v2, sges_left));
-			*mptr++ = cpu_to_le32(v1);
-			*mptr++ = cpu_to_le32(v2);
-			sg++;
-			sgCnt++;
-
-			if (--sges_left == 0) {
-				/* re-write 1st word of previous SGE with SIMPLE,
-				 * LE, EOB, and EOL bits!
-				 */
-				v1 = 0xD1000000 | sgdir | sg_dma_len(sg-1);
-				dsgprintk((KERN_INFO MYNAM ": SG: %x (re)Writing SGE @%p: %08x (VERY LAST SGE!)\n",
-					   my_idx, mptr-2, v1));
-				*(mptr - 2) = cpu_to_le32(v1);
-			} else {
-				if ((sges_left > 1) && ((sgCnt % sge_cur_spill) == 0)) {
-					dsgprintk((KERN_INFO MYNAM ": SG: %x     SG spill at modulo 0!\n",
-						   my_idx));
-
-					/* Fixup previous SGE with LE bit! */
-					v1 = sgdir | 0x90000000 | sg_dma_len(sg-1);
-					dsgprintk((KERN_INFO MYNAM ": SG: %x (re)Writing SGE @%p: %08x (LAST BUCKET SGE!)\n",
-						   my_idx, mptr-2, v1));
-					*(mptr - 2) = cpu_to_le32(v1);
-
-					chain_offset = 0;
-					/* Going to need another chain? */
-					if (sges_left > (sge_spill2+1)) {
-#if 0
-						chain_offset = 0x1E;
+				/* Initialize this SCSI Hosts' timers
+				 * To use, set the timer expires field
+				 * and add_timer
+				 */
+				init_timer(&hd->timer);
+				hd->timer.data = (unsigned long) hd;
+				hd->timer.function = mptscsih_timer_expired;
+
+				init_timer(&hd->TMtimer);
+				hd->TMtimer.data = (unsigned long) hd;
+				hd->TMtimer.function = mptscsih_taskmgmt_timeout;
+				hd->qtag_tick = jiffies;
+
+				/* Moved Earlier Pam D */
+				/* this->sh = sh;	*/
+
+				if (hd->is_spi) {
+					/* Update with the driver setup
+					 * values.
+					 */
+					if (hd->ioc->spi_data.maxBusWidth > driver_setup.max_width)
+						hd->ioc->spi_data.maxBusWidth = driver_setup.max_width;
+					if (hd->ioc->spi_data.minSyncFactor < driver_setup.min_sync_fac)
+						hd->ioc->spi_data.minSyncFactor = driver_setup.min_sync_fac;
+
+					if (hd->ioc->spi_data.minSyncFactor == MPT_ASYNC)
+						hd->ioc->spi_data.maxSyncOffset = 0;
+
+					hd->negoNvram = 0;
+#ifdef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+					hd->negoNvram = MPT_SCSICFG_USE_NVRAM;
 #endif
-						chain_offset = (frm_sz - 8) / 4;
-						chain_sz = frm_sz;
-					} else {
-						chain_sz = sges_left * 8;
-					}
-
-					/* write chain SGE at mptr. */
-					v1 = 0x30000000 | chain_offset<<16 | chain_sz;
-					if (pSgBucket == NULL) {
-						pSgBucket = hd->SgHunks
-							+ (my_idx * frm_sz * MPT_SG_BUCKETS_PER_HUNK);
-					} else {
-						pSgBucket += frm_sz;
-					}
-					v2 = (hd->SgHunksDMA +
-					      ((u8 *)pSgBucket - (u8 *)hd->SgHunks));
-					dsgprintk((KERN_INFO MYNAM ": SG: %x     Writing SGE @%p: %08x %08x (CHAIN!)\n",
-						   my_idx, mptr, v1, v2));
-					*(mptr++) = cpu_to_le32(v1);
-					*(mptr) = cpu_to_le32(v2);
+					if (driver_setup.dv == 0)
+						hd->negoNvram = MPT_SCSICFG_USE_NVRAM;
 
-					mptr = (u32 *) pSgBucket;
-					sgCnt = 0;
-					sge_cur_spill = sge_spill2;
-				}
-			}
-		}
-	} else {
-		dsgprintk((KERN_INFO MYNAM ": SG: non-SG for %p, len=%d\n",
-			   SCpnt, SCpnt->request_bufflen));
+					hd->ioc->spi_data.forceDv = 0;
+					for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++)
+						hd->ioc->spi_data.dvStatus[ii] = MPT_SCSICFG_NEGOTIATE;
 
-		if (len > 0) {
-			dma_addr_t buf_dma_addr;
 
-			buf_dma_addr = (dma_addr_t) (unsigned long)SCpnt->SCp.ptr;
-			*(mptr++) = cpu_to_le32(0xD1000000|sgdir|SCpnt->request_bufflen);
-			*(mptr++) = cpu_to_le32(buf_dma_addr);
-		}
-	}
+					ddvprintk((MYIOC_s_INFO_FMT
+						"dv %x width %x factor %x \n",
+						hd->ioc->name, driver_setup.dv,
+						driver_setup.max_width,
+						driver_setup.min_sync_fac));
 
-#ifdef MPT_DEBUG
-	/* if (SCpnt->request_bufflen > max_xfer) */
-	if (len > max_xfer) {
-		max_xfer = len;
-		dprintk((KERN_INFO MYNAM ": MPT_MaxXfer = %d\n", max_xfer));
-	}
-#endif
+				}
 
-	hd->ScsiLookup[my_idx] = SCpnt;
+				mpt_scsi_hosts++;
+			}
 
-	/* Main banana... */
-	mpt_put_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
+		}	/* for each adapter port */
 
-	atomic_inc(&queue_depth);
-	if (atomic_read(&queue_depth) > max_qd) {
-		max_qd = atomic_read(&queue_depth);
-		dprintk((KERN_INFO MYNAM ": Queue depth now %d.\n", max_qd));
+		this = mpt_adapter_find_next(this);
 	}
 
-	dmfprintk((KERN_INFO MYNAM ": Issued SCSI cmd (%p)\n", SCpnt));
+done:
+	if (mpt_scsi_hosts > 0)
+		register_reboot_notifier(&mptscsih_notifier);
 
-	return 0;
+	return mpt_scsi_hosts;
 }
 
-#ifdef MPT_SCSI_USE_NEW_EH		/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
-    mptscsih_abort
-    Returns: 0=SUCCESS, else FAILED
-*/
+    static char *info_kbuf = NULL;
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mptscsih_abort - Abort linux Scsi_Cmnd routine, new_eh variant
- *	@SCpnt: Pointer to Scsi_Cmnd structure, IO to be aborted
+ *	mptscsih_release - Unregister SCSI host from linux scsi mid-layer
+ *	@host: Pointer to Scsi_Host structure
  *
- *	(linux Scsi_Host_Template.eh_abort_handler routine)
+ *	(linux Scsi_Host_Template.release routine)
+ *	This routine releases all resources associated with the SCSI host
+ *	adapter.
  *
- *	Returns SUCCESS or FAILED.  
+ *	Returns 0 for success.
  */
 int
-mptscsih_abort(Scsi_Cmnd * SCpnt)
+mptscsih_release(struct Scsi_Host *host)
 {
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
 	MPT_SCSI_HOST	*hd;
-	u32		*msg;
-	u32		 ctx2abort;
-	int		 i;
+	int 		 count;
 	unsigned long	 flags;
 
-	printk(KERN_WARNING MYNAM ": Attempting _ABORT SCSI IO (=%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+	hd = (MPT_SCSI_HOST *) host->hostdata;
 
-	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
+#ifndef MPT_SCSI_USE_NEW_EH
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	dvtaskQ_release = 1;
+	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+#endif
 
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-		return FAILED;
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+	if (mytaskQ_bh_active) {
+		count = 10 * HZ;
+
+		spin_unlock_irqrestore(&mytaskQ_lock, flags);
+		dprintk((KERN_INFO MYNAM ": Info: Zapping TaskMgmt thread!\n"));
+		clean_taskQ(hd);
+
+		while(mytaskQ_bh_active && --count) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		}
+		if (!count)
+			printk(KERN_ERR MYNAM ": ERROR - TaskMgmt thread still active!\n");
 	}
+	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+#endif
 
-	pScsiTm = (SCSITaskMgmt_t *) mf;
-	msg = (u32 *) mf;
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+	/* Check DV thread active */
+	count = 10 * HZ;
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	while(dvtaskQ_active && --count) {
+		spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+		spin_lock_irqsave(&dvtaskQ_lock, flags);
+	}
+	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+	if (!count)
+		printk(KERN_ERR MYNAM ": ERROR - DV thread still active!\n");
+#if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
+	else
+		printk(KERN_ERR MYNAM ": DV thread orig %d, count %d\n", 10 * HZ, count);
+#endif
+#endif
 
-	pScsiTm->TargetID = SCpnt->target;
-	pScsiTm->Bus = hd->port;
-	pScsiTm->ChainOffset = 0;
-	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+	unregister_reboot_notifier(&mptscsih_notifier);
 
-	pScsiTm->Reserved = 0;
-	pScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
-	pScsiTm->Reserved1 = 0;
-	pScsiTm->MsgFlags = 0;
+	if (hd != NULL) {
+		int sz1, sz2, sz3, sztarget=0;
+		int szchain = 0;
+		int szQ = 0;
+		int scale;
 
-	for (i = 0; i < 8; i++) {
-		u8 val = 0;
-		if (i == 1)
-			val = SCpnt->lun;
-		pScsiTm->LUN[i] = val;
-	}
+		/* Synchronize disk caches
+		 */
+		(void) mptscsih_synchronize_cache(hd, 0);
 
-	for (i = 0; i < 7; i++)
-		pScsiTm->Reserved2[i] = 0;
+		sz1 = sz2 = sz3 = 0;
 
-	/* Most important!  Set TaskMsgContext to SCpnt's MsgContext!
-	 * (the IO to be ABORT'd)
-	 *
-	 * NOTE: Since we do not byteswap MsgContext, we do not
-	 *	 swap it here either.  It is an opaque cookie to
-	 *	 the controller, so it does not matter. -DaveM
-	 */
-	ctx2abort = SCPNT_TO_MSGCTX(SCpnt);
-	if (ctx2abort == -1) {
-		printk(KERN_ERR MYNAM ": ERROR - ScsiLookup fail(#2) for SCpnt=%p\n", SCpnt);
-		SCpnt->result = DID_SOFT_ERROR << 16;
-		spin_lock_irqsave(&io_request_lock, flags);
-		SCpnt->scsi_done(SCpnt);
-		spin_unlock_irqrestore(&io_request_lock, flags);
-		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-	} else {
-		dprintk((KERN_INFO MYNAM ":DbG: ctx2abort = %08x\n", ctx2abort));
-		pScsiTm->TaskMsgContext = ctx2abort;
+		if (hd->ioc->req_sz <= 64)
+			scale = MPT_SG_REQ_64_SCALE;
+		else if (hd->ioc->req_sz <= 96)
+			scale = MPT_SG_REQ_96_SCALE;
+		else
+			scale = MPT_SG_REQ_128_SCALE;
 
+		if (hd->ScsiLookup != NULL) {
+			sz1 = hd->ioc->req_depth * sizeof(void *);
+			kfree(hd->ScsiLookup);
+			hd->ScsiLookup = NULL;
+		}
 
-		/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
-			mpt_put_msg_frame(hd->ioc->id, mf);
-		*/
-		if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-					sizeof(SCSITaskMgmt_t), msg))
-		    != 0) {
-			printk(KERN_WARNING MYNAM
-					": WARNING[2] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n",
-					i, mf, SCpnt);
-			SCpnt->result = DID_SOFT_ERROR << 16;
-			spin_lock_irqsave(&io_request_lock, flags);
-			SCpnt->scsi_done(SCpnt);
-			spin_unlock_irqrestore(&io_request_lock, flags);
-			mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+		if (hd->ReqToChain != NULL) {
+			szchain += scale * hd->ioc->req_depth * sizeof(int);
+			kfree(hd->ReqToChain);
+			hd->ReqToChain = NULL;
 		}
-	}
 
-	//return SUCCESS;
-	return FAILED;
-}
+		if (hd->ChainToChain != NULL) {
+			szchain += scale * hd->ioc->req_depth * sizeof(int);
+			kfree(hd->ChainToChain);
+			hd->ChainToChain = NULL;
+		}
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	mptscsih_dev_reset - Perform a SCSI TARGET_RESET!  new_eh variant
- *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
- *
- *	(linux Scsi_Host_Template.eh_dev_reset_handler routine)
- *
- *	Returns SUCCESS or FAILED.
- */
-int
-mptscsih_dev_reset(Scsi_Cmnd * SCpnt)
-{
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
-	MPT_SCSI_HOST	*hd;
-	u32		*msg;
-	int		 i;
-	unsigned long	 flags;
+		if (hd->ChainBuffer != NULL) {
+			sz2 = scale * hd->ioc->req_depth * hd->ioc->req_sz;
+			szchain += sz2;
 
-	printk(KERN_WARNING MYNAM ": Attempting _TARGET_RESET (%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+			pci_free_consistent(hd->ioc->pcidev, sz2,
+				    hd->ChainBuffer, hd->ChainBufferDMA);
+			hd->ChainBuffer = NULL;
+		}
 
-	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
+		if (hd->memQ != NULL) {
+			szQ = host->can_queue * sizeof(MPT_DONE_Q);
+			kfree(hd->memQ);
+			hd->memQ = NULL;
+		}
 
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-		return FAILED;
-	}
+		if (hd->Targets != NULL) {
+			int max, ii;
 
-	pScsiTm = (SCSITaskMgmt_t *) mf;
-	msg = (u32*)mf;
+			/*
+			 * Free any target structures that were allocated.
+			 */
+			if (hd->is_spi) {
+				max = MPT_MAX_SCSI_DEVICES;
+			} else {
+				max = MPT_MAX_FC_DEVICES;
+			}
+			for (ii=0; ii < max; ii++) {
+				if (hd->Targets[ii]) {
+					kfree(hd->Targets[ii]);
+					hd->Targets[ii] = NULL;
+					sztarget += sizeof(VirtDevice);
+				}
+			}
 
-	pScsiTm->TargetID = SCpnt->target;
-	pScsiTm->Bus = hd->port;
-	pScsiTm->ChainOffset = 0;
-	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+			/*
+			 * Free pointer array.
+			 */
+			sz3 = max * sizeof(void *);
+			kfree(hd->Targets);
+			hd->Targets = NULL;
+		}
 
-	pScsiTm->Reserved = 0;
-	pScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET;
-	pScsiTm->Reserved1 = 0;
-	pScsiTm->MsgFlags = 0;
+		dprintk((MYIOC_s_INFO_FMT "Free'd ScsiLookup (%d), chain (%d) and Target (%d+%d) memory\n",
+				hd->ioc->name, sz1, szchain, sz3, sztarget));
+		dprintk(("Free'd done and free Q (%d) memory\n", szQ));
+	}
+	/* NULL the Scsi_Host pointer
+	 */
+	hd->ioc->sh = NULL;
+	scsi_unregister(host);
+
+	if (mpt_scsi_hosts) {
+		if (--mpt_scsi_hosts == 0) {
+			mpt_reset_deregister(ScsiDoneCtx);
+			dprintk((KERN_INFO MYNAM ": Deregistered for IOC reset notifications\n"));
 
-	/* _TARGET_RESET goes to LUN 0 always! */
-	for (i = 0; i < 8; i++)
-		pScsiTm->LUN[i] = 0;
-
-	/* Control: No data direction, set task mgmt bit? */
-	for (i = 0; i < 7; i++)
-		pScsiTm->Reserved2[i] = 0;
+			mpt_event_deregister(ScsiDoneCtx);
+			dprintk((KERN_INFO MYNAM ": Deregistered for IOC event notifications\n"));
 
-	pScsiTm->TaskMsgContext = cpu_to_le32(0);
+			mpt_deregister(ScsiScanDvCtx);
+			mpt_deregister(ScsiTaskCtx);
+			mpt_deregister(ScsiDoneCtx);
 
-/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
-	mpt_put_msg_frame(hd->ioc->id, mf);
-*/
-/* FIXME!  Check return status! */
-	if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-				sizeof(SCSITaskMgmt_t), msg))
-	    != 0) {
-		printk(KERN_WARNING MYNAM
-				": WARNING[3] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n",
-				i, mf, SCpnt);
-		SCpnt->result = DID_SOFT_ERROR << 16;
-		spin_lock_irqsave(&io_request_lock, flags);
-		SCpnt->scsi_done(SCpnt);
-		spin_unlock_irqrestore(&io_request_lock, flags);
-		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+			if (info_kbuf != NULL)
+				kfree(info_kbuf);
+		}
 	}
 
-	//return SUCCESS;
-	return FAILED;
+	return 0;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mptscsih_bus_reset - Perform a SCSI BUS_RESET!	new_eh variant
- *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
+ *	mptscsih_halt - Process the reboot notification
+ *	@nb: Pointer to a struct notifier_block (ignored)
+ *	@event: event (SYS_HALT, SYS_RESTART, SYS_POWER_OFF)
+ *	@buf: Pointer to a data buffer (ignored)
  *
- *	(linux Scsi_Host_Template.eh_bus_reset_handler routine)
+ *	This routine called if a system shutdown or reboot is to occur.
  *
- *	Returns SUCCESS or FAILED.
+ *	Return NOTIFY_DONE if this is something other than a reboot message.
+ *		NOTIFY_OK if this is a reboot message.
  */
-int
-mptscsih_bus_reset(Scsi_Cmnd * SCpnt)
+static int
+mptscsih_halt(struct notifier_block *nb, ulong event, void *buf)
 {
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
-	MPT_SCSI_HOST	*hd;
-	u32		*msg;
-	int		 i;
-	unsigned long	 flags;
-
-	printk(KERN_WARNING MYNAM ": Attempting _BUS_RESET (%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+	MPT_ADAPTER *ioc = NULL;
+	MPT_SCSI_HOST *hd = NULL;
 
-	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
+	/* Ignore all messages other than reboot message
+	 */
+	if ((event != SYS_RESTART) && (event != SYS_HALT)
+		&& (event != SYS_POWER_OFF))
+		return (NOTIFY_DONE);
 
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-		return FAILED;
+	for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc =	mpt_adapter_find_next(ioc)) {
+		/* Flush the cache of this adapter
+		 */
+		if (ioc->sh) {
+			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+			if (hd) {
+				mptscsih_synchronize_cache(hd, 0);
+			}
+		}
 	}
 
-	pScsiTm = (SCSITaskMgmt_t *) mf;
-	msg = (u32 *) mf;
-
-	pScsiTm->TargetID = SCpnt->target;
-	pScsiTm->Bus = hd->port;
-	pScsiTm->ChainOffset = 0;
-	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+	unregister_reboot_notifier(&mptscsih_notifier);
+	return NOTIFY_OK;
+}
 
-	pScsiTm->Reserved = 0;
-	pScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
-	pScsiTm->Reserved1 = 0;
-	pScsiTm->MsgFlags = 0;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_info - Return information about MPT adapter
+ *	@SChost: Pointer to Scsi_Host structure
+ *
+ *	(linux Scsi_Host_Template.info routine)
+ *
+ *	Returns pointer to buffer where information was written.
+ */
+const char *
+mptscsih_info(struct Scsi_Host *SChost)
+{
+	MPT_SCSI_HOST *h;
+	int size = 0;
 
-	for (i = 0; i < 8; i++)
-		pScsiTm->LUN[i] = 0;
+	if (info_kbuf == NULL)
+		if ((info_kbuf = kmalloc(0x1000 /* 4Kb */, GFP_KERNEL)) == NULL)
+			return info_kbuf;
 
-	/* Control: No data direction, set task mgmt bit? */
-	for (i = 0; i < 7; i++)
-		pScsiTm->Reserved2[i] = 0;
+	h = (MPT_SCSI_HOST *)SChost->hostdata;
+	info_kbuf[0] = '\0';
+	mpt_print_ioc_summary(h->ioc, info_kbuf, &size, 0, 0);
+	info_kbuf[size-1] = '\0';
 
-	pScsiTm->TaskMsgContext = cpu_to_le32(0);
+	return info_kbuf;
+}
 
-/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
-	mpt_put_msg_frame(hd->ioc->id, mf);
-*/
-/* FIXME!  Check return status! */
-	if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-				sizeof(SCSITaskMgmt_t), msg))
-	    != 0) {
-		printk(KERN_WARNING MYNAM
-				": WARNING[4] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n",
-				i, mf, SCpnt);
-		SCpnt->result = DID_SOFT_ERROR << 16;
-		spin_lock_irqsave(&io_request_lock, flags);
-		SCpnt->scsi_done(SCpnt);
-		spin_unlock_irqrestore(&io_request_lock, flags);
-		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-	}
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+	static int max_qd = 1;
+#if 0
+static int index_log[128];
+static int index_ent = 0;
+static __inline__ void ADD_INDEX_LOG(int req_ent)
+{
+	int i = index_ent++;
 
-	return SUCCESS;
+	index_log[i & (128 - 1)] = req_ent;
 }
+#else
+#define ADD_INDEX_LOG(req_ent)	do { } while(0)
+#endif
+
+#ifdef	DROP_TEST
+#define DROP_IOC	1	/* IOC to force failures */
+#define DROP_TARGET	3	/* Target ID to force failures */
+#define	DROP_THIS_CMD	10000	/* iteration to drop command */
+static int dropCounter = 0;
+static int dropTestOK = 0;	/* num did good */
+static int dropTestBad = 0;	/* num did bad */
+static int dropTestNum = 0;	/* total = good + bad + incomplete */
+static int numTotCmds = 0;
+static MPT_FRAME_HDR *dropMfPtr = NULL;
+static int numTMrequested = 0;
+#endif
 
-#if 0	/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	mptscsih_host_reset - Perform a SCSI host adapter RESET!
- *	new_eh variant
- *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
+/*
+ *	mptscsih_put_msgframe - Wrapper routine to post message frame to F/W.
+ *	@context: Call back context (ScsiDoneCtx, ScsiScanDvCtx) 
+ *	@id: IOC id number 
+ *	@mf: Pointer to message frame 
  *
- *	(linux Scsi_Host_Template.eh_host_reset_handler routine)
+ *	Handles the call to mptbase for posting request and queue depth 
+ *	tracking.
  *
- *	Returns SUCCESS or FAILED.
+ *	Returns none.
  */
-int
-mptscsih_host_reset(Scsi_Cmnd * SCpnt)
+static void
+mptscsih_put_msgframe(int context, int id, MPT_FRAME_HDR *mf)
 {
-	return FAILED;
+	/* Main banana... */
+	atomic_inc(&queue_depth);
+	if (atomic_read(&queue_depth) > max_qd) {
+		max_qd = atomic_read(&queue_depth);
+		dprintk((KERN_INFO MYNAM ": Queue depth now %d.\n", max_qd));
+	}
+
+	mpt_put_msg_frame(context, id, mf);
+
+	return;
 }
-#endif	/* } */
 
-#else		/* MPT_SCSI old EH stuff... */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /**
- *	mptscsih_old_abort - Abort linux Scsi_Cmnd routine
- *	@SCpnt: Pointer to Scsi_Cmnd structure, IO to be aborted
+ *	mptscsih_qcmd - Primary Fusion MPT SCSI initiator IO start routine.
+ *	@SCpnt: Pointer to Scsi_Cmnd structure
+ *	@done: Pointer SCSI mid-layer IO completion function
  *
- *	(linux Scsi_Host_Template.abort routine)
+ *	(linux Scsi_Host_Template.queuecommand routine)
+ *	This is the primary SCSI IO start routine.  Create a MPI SCSIIORequest
+ *	from a linux Scsi_Cmnd request and send it to the IOC.
  *
- *	Returns SCSI_ABORT_{SUCCESS,BUSY,PENDING}.
+ *	Returns 0. (rtn value discarded by linux scsi mid-layer)
  */
 int
-mptscsih_old_abort(Scsi_Cmnd *SCpnt)
+mptscsih_qcmd(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))
 {
 	MPT_SCSI_HOST		*hd;
 	MPT_FRAME_HDR		*mf;
-	struct tq_struct	*ptaskfoo;
+	SCSIIORequest_t		*pScsiReq;
+	VirtDevice		*pTarget;
+	MPT_DONE_Q		*buffer = NULL;
 	unsigned long		 flags;
+	int	 target;
+	int	 lun;
+	int	 datadir;
+	u32	 datalen;
+	u32	 scsictl;
+	u32	 scsidir;
+	u32	 qtag;
+	u32	 cmd_len;
+	int	 my_idx;
+	int	 ii;
+	int	 rc;
+	int	 did_errcode;
+	int	 issueCmd;
 
-	printk(KERN_WARNING MYNAM ": Scheduling _ABORT SCSI IO (=%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+	did_errcode = 0;
+	hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
+	target = SCpnt->target;
+	lun = SCpnt->lun;
+	SCpnt->scsi_done = done;
 
-	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
-		SCpnt->result = DID_ABORT << 16;
-		SCpnt->scsi_done(SCpnt);
-		return SCSI_ABORT_SUCCESS;
-	}
+	pTarget = hd->Targets[target];
 
-	/*
-	 *  Check to see if there's already an ABORT queued for this guy.
+	dmfprintk((MYIOC_s_INFO_FMT "qcmd: SCpnt=%p, done()=%p\n",
+			(hd && hd->ioc) ? hd->ioc->name : "ioc?", SCpnt, done));
+
+	/* 20000617 -sralston
+	 *  GRRRRR...  Shouldn't have to do this but...
+	 *  Do explicit check for REQUEST_SENSE and cached SenseData.
+	 *  If yes, return cached SenseData.
 	 */
-	mf = search_taskQ(0,SCpnt,MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
-	if (mf != NULL) {
-		return SCSI_ABORT_PENDING;
+	if (SCpnt->cmnd[0] == REQUEST_SENSE) {
+		u8 *dest = NULL;
+		int sz;
+
+		if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_VALID_SENSE)) {
+			pTarget->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;	//sjr-moved-here
+			if (!SCpnt->use_sg) {
+				dest = SCpnt->request_buffer;
+			} else {
+				struct scatterlist *sg = (struct scatterlist *) SCpnt->request_buffer;
+				if (sg)
+					dest = (u8 *)(ulong)sg_dma_address(sg);
+			}
+
+			if (dest) {
+				sz = MIN (SCSI_STD_SENSE_BYTES, SCpnt->request_bufflen);
+				memcpy(dest, pTarget->sense, sz);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+				SCpnt->resid = SCpnt->request_bufflen - sz;
+#endif
+				SCpnt->result = 0;
+				SCpnt->scsi_done(SCpnt);
+
+				//sjr-moved-up//pTarget->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;
+
+				return 0;
+			}
+		}
 	}
 
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-		return SCSI_ABORT_BUSY;
+	if (hd->resetPending) {
+		/* Prevent new commands from being issued
+		 * while reloading the FW.
+		 */
+		did_errcode = 1;
+		goto did_error;
 	}
 
 	/*
-	 *  Add ourselves to (end of) mpt_scsih_taskQ.
-	 *  Check to see if our _bh is running.  If NOT, schedule it.
+	 *  Put together a MPT SCSI request...
 	 */
-	dslprintk((KERN_INFO MYNAM ": spinlock#2\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	Q_ADD_TAIL(&mpt_scsih_taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
-	mpt_scsih_taskQ_cnt++;
-	/* Yikes - linkage! */
-/*	SCpnt->host_scribble = (unsigned char *)mf;	*/
-	mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
-	mf->u.frame.linkage.argp1 = SCpnt;
-	if (! mpt_scsih_taskQ_bh_active) {
-		mpt_scsih_taskQ_bh_active = 1;
-		/*
-		 *  Oh how cute, no alloc/free/mgmt needed if we use
-		 *  (bottom/unused portion of) MPT request frame.
-		 */
-		ptaskfoo = (struct tq_struct *) ((u8*)mf + hd->ioc->req_sz - sizeof(*ptaskfoo));
-		ptaskfoo->sync = 0;
-		ptaskfoo->routine = mptscsih_taskmgmt_bh;
-		ptaskfoo->data = SCpnt;
-
-		SCHEDULE_TASK(ptaskfoo);
+	if ((mf = mpt_get_msg_frame(ScsiDoneCtx, hd->ioc->id)) == NULL) {
+		dprintk((MYIOC_s_WARN_FMT "QueueCmd, no msg frames!!\n",
+				hd->ioc->name));
+		did_errcode = 2;
+		goto did_error;
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-
-	return SCSI_ABORT_PENDING;
-}
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	mptscsih_old_reset - Perform a SCSI BUS_RESET!
- *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
- *	@reset_flags: (not used?)
- *
- *	(linux Scsi_Host_Template.reset routine)
- *
- *	Returns SCSI_RESET_{SUCCESS,PUNT,PENDING}.
- */
-int
-mptscsih_old_reset(Scsi_Cmnd *SCpnt, unsigned int reset_flags)
-{
-	MPT_SCSI_HOST		*hd;
-	MPT_FRAME_HDR		*mf;
-	struct tq_struct	*ptaskfoo;
-	unsigned long		 flags;
+	pScsiReq = (SCSIIORequest_t *) mf;
 
-	printk(KERN_WARNING MYNAM ": Scheduling _BUS_RESET (=%p)\n", SCpnt);
-	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
 
-	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
-		SCpnt->result = DID_RESET << 16;
-		SCpnt->scsi_done(SCpnt);
-		return SCSI_RESET_SUCCESS;
-	}
+	ADD_INDEX_LOG(my_idx);
 
 	/*
-	 *  Check to see if there's already a BUS_RESET queued for this guy.
+	 *  The scsi layer should be handling this stuff
+	 *  (In 2.3.x it does -DaveM)
 	 */
-	mf = search_taskQ(0,SCpnt,MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS);
-	if (mf != NULL) {
-		return SCSI_RESET_PENDING;
-	}
 
-	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
-/*		SCpnt->result = DID_SOFT_ERROR << 16;	*/
-		SCpnt->result = STS_BUSY;
-		SCpnt->scsi_done(SCpnt);
-		return SCSI_RESET_PUNT;
+	/*  BUG FIX!  19991030 -sralston
+	 *    TUR's being issued with scsictl=0x02000000 (DATA_IN)!
+	 *    Seems we may receive a buffer (datalen>0) even when there
+	 *    will be no data transfer!  GRRRRR...
+	 */
+	datadir = mptscsih_io_direction(SCpnt);
+	if (datadir < 0) {
+		datalen = SCpnt->request_bufflen;
+		scsidir = MPI_SCSIIO_CONTROL_READ;	/* DATA IN  (host<--ioc<--dev) */
+	} else if (datadir > 0) {
+		datalen = SCpnt->request_bufflen;
+		scsidir = MPI_SCSIIO_CONTROL_WRITE;	/* DATA OUT (host-->ioc-->dev) */
+	} else {
+		datalen = 0;
+		scsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;
 	}
 
-	/*
-	 *  Add ourselves to (end of) mpt_scsih_taskQ.
-	 *  Check to see if our _bh is running.  If NOT, schedule it.
+	/* Default to untagged. Once a target structure has been allocated,
+	 * use the Inquiry data to determine if device supports tagged.
 	 */
-	dslprintk((KERN_INFO MYNAM ": spinlock#3\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	Q_ADD_TAIL(&mpt_scsih_taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
-	mpt_scsih_taskQ_cnt++;
-	/* Yikes - linkage! */
-/*	SCpnt->host_scribble = (unsigned char *)mf;	*/
-	mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
-	mf->u.frame.linkage.argp1 = SCpnt;
-	if (! mpt_scsih_taskQ_bh_active) {
-		mpt_scsih_taskQ_bh_active = 1;
+	qtag = MPI_SCSIIO_CONTROL_UNTAGGED;
+	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)
+			&& (SCpnt->device->tagged_supported)) {
 		/*
-		 *  Oh how cute, no alloc/free/mgmt needed if we use
-		 *  (bottom/unused portion of) MPT request frame.
+		 *  Some drives are too stupid to handle fairness issues
+		 *  with tagged queueing. We throw in the odd ordered
+		 *  tag to stop them starving themselves.
 		 */
-		ptaskfoo = (struct tq_struct *) ((u8*)mf + hd->ioc->req_sz - sizeof(*ptaskfoo));
-		ptaskfoo->sync = 0;
-		ptaskfoo->routine = mptscsih_taskmgmt_bh;
-		ptaskfoo->data = SCpnt;
-
-		SCHEDULE_TASK(ptaskfoo);
+		if ((jiffies - hd->qtag_tick) > (5*HZ)) {
+			qtag = MPI_SCSIIO_CONTROL_ORDEREDQ;
+			hd->qtag_tick = jiffies;
+		}
+		else
+			qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
 	}
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	scsictl = scsidir | qtag;
 
-	return SCSI_RESET_PENDING;
-}
+	/* Use the above information to set up the message frame
+	 */
+	pScsiReq->TargetID = target;
+	pScsiReq->Bus = hd->port;
+	pScsiReq->ChainOffset = 0;
+	pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
+	pScsiReq->CDBLength = SCpnt->cmd_len;
+	pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+	pScsiReq->Reserved = 0;
+	pScsiReq->MsgFlags = MPT_SCSIIO_MSG_FLAGS;
+	pScsiReq->LUN[0] = 0;
+	pScsiReq->LUN[1] = lun;
+	pScsiReq->LUN[2] = 0;
+	pScsiReq->LUN[3] = 0;
+	pScsiReq->LUN[4] = 0;
+	pScsiReq->LUN[5] = 0;
+	pScsiReq->LUN[6] = 0;
+	pScsiReq->LUN[7] = 0;
+	pScsiReq->Control = cpu_to_le32(scsictl);
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	mptscsih_taskmgmt_bh - SCSI task mgmt bottom half handler
- *	@sc: (unused)
- *
- *	This routine (thread) is active whenever there are any outstanding
- *	SCSI task management requests for a SCSI host adapter.
- *	IMPORTANT!  This routine is scheduled therefore should never be
- *	running in ISR context.  i.e., it's safe to sleep here.
- */
-void
-mptscsih_taskmgmt_bh(void *sc)
-{
-	Scsi_Cmnd	*SCpnt;
-	MPT_FRAME_HDR	*mf;
-	SCSITaskMgmt_t	*pScsiTm;
-	MPT_SCSI_HOST	*hd;
-	u32		 ctx2abort = 0;
-	int		 i;
-	unsigned long	 flags;
-	u8		 task_type;
+	/*
+	 *  Write SCSI CDB into the message
+	 */
+	cmd_len = SCpnt->cmd_len;
+	for (ii=0; ii < cmd_len; ii++)
+		pScsiReq->CDB[ii] = SCpnt->cmnd[ii];
+	for (ii=cmd_len; ii < 16; ii++)
+		pScsiReq->CDB[ii] = 0;
 
-	dslprintk((KERN_INFO MYNAM ": spinlock#4\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	mpt_scsih_taskQ_bh_active = 1;
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	/* DataLength */
+	pScsiReq->DataLength = cpu_to_le32(datalen);
 
-	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(HZ/4);
+	/* SenseBuffer low address */
+	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_low_dma
+					   + (my_idx * MPT_SENSE_BUFFER_ALLOC));
 
-		/*
-		 *  We MUST remove item from taskQ *before* we format the
-		 *  frame as a SCSITaskMgmt request and send it down to the IOC.
+	/* Now add the SG list
+	 * Always have a SGE even if null length.
+	 */
+	rc = SUCCESS;
+	if (datalen == 0) {
+		/* Add a NULL SGE */
+		mptscsih_AddNullSGE(pScsiReq);
+	} else {
+		/* Add a 32 or 64 bit SGE */
+		rc = mptscsih_Add32BitSGE(hd, SCpnt, pScsiReq, my_idx);
+	}
+
+
+	if (rc == SUCCESS) {
+		hd->ScsiLookup[my_idx] = SCpnt;
+		SCpnt->host_scribble = NULL;
+
+#ifdef	DROP_TEST
+		numTotCmds++;
+		/* If the IOC number and target match, increment
+		 * counter. If counter matches DROP_THIS, do not
+		 * issue command to FW to force a reset.
+		 * Save the MF pointer so we can free resources
+		 * when task mgmt completes.
 		 */
-		dslprintk((KERN_INFO MYNAM ": spinlock#5\n"));
-		spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-		if (Q_IS_EMPTY(&mpt_scsih_taskQ)) {
-			spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-			break;
-		}
-		mf = mpt_scsih_taskQ.head;
-		Q_DEL_ITEM(&mf->u.frame.linkage);
-		mpt_scsih_taskQ_cnt--;
-		mpt_scsih_active_taskmgmt_mf = mf;
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-
-		SCpnt = (Scsi_Cmnd*)mf->u.frame.linkage.argp1;
-		if (SCpnt == NULL) {
-			printk(KERN_ERR MYNAM ": ERROR - TaskMgmt has NULL SCpnt! (%p:%p)\n", mf, SCpnt);
-			continue;
-		}
-		hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata;
-		pScsiTm = (SCSITaskMgmt_t *) mf;
+		if ((hd->ioc->id == DROP_IOC) && (target == DROP_TARGET)) {
+			dropCounter++;
 
-		for (i = 0; i < 8; i++) {
-			pScsiTm->LUN[i] = 0;
-		}
+			if (dropCounter == DROP_THIS_CMD) {
+				dropCounter = 0;
 
-		task_type = mf->u.frame.linkage.arg1;
-		if (task_type == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {
-			printk(KERN_WARNING MYNAM ": Attempting _ABORT SCSI IO! (mf=%p:sc=%p)\n",
-					mf, SCpnt);
-
-			/* Most important!  Set TaskMsgContext to SCpnt's MsgContext!
-			 * (the IO to be ABORT'd)
-			 *
-			 * NOTE: Since we do not byteswap MsgContext, we do not
-			 *	 swap it here either.  It is an opaque cookie to
-			 *	 the controller, so it does not matter. -DaveM
-			 */
-			ctx2abort = SCPNT_TO_MSGCTX(SCpnt);
-			if (ctx2abort == -1) {
-				printk(KERN_ERR MYNAM ": ERROR - ScsiLookup fail(#1) for SCpnt=%p\n", SCpnt);
-				SCpnt->result = DID_SOFT_ERROR << 16;
-				spin_lock_irqsave(&io_request_lock, flags);
-				SCpnt->scsi_done(SCpnt);
-				spin_unlock_irqrestore(&io_request_lock, flags);
-				mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-				continue;
+				/* If global is set, then we are already
+				 * doing something - so keep issuing commands.
+				 */
+				if (dropMfPtr == NULL) {
+					dropTestNum++;
+					dropMfPtr = mf;
+					atomic_inc(&queue_depth);
+					printk(MYIOC_s_INFO_FMT
+						"Dropped SCSI cmd (%p)\n",
+						hd->ioc->name, SCpnt);
+					printk("mf (%p) req (%4x) tot cmds (%d)\n",
+						mf, my_idx, numTotCmds);
+
+					return 0;
+				}
 			}
-			pScsiTm->LUN[1] = SCpnt->lun;
 		}
-		else if (task_type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)
-		{
-			printk(KERN_WARNING MYNAM ": Attempting _BUS_RESET! (against SCSI IO mf=%p:sc=%p)\n", mf, SCpnt);
-		}
-#if 0
-		else if (task_type == MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET) {}
-		else if (task_type == MPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET) {}
 #endif
 
-		printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
+		/* SCSI specific processing */
+		issueCmd = 1;
+		if (hd->is_spi) {
+			int dvStatus = hd->ioc->spi_data.dvStatus[target];
+
+			if (dvStatus || hd->ioc->spi_data.forceDv) {
+
+				/* Write SDP1 on 1st I/O to this target */
+				if (dvStatus & MPT_SCSICFG_NEGOTIATE) {
+					mptscsih_writeSDP1(hd, 0, target, hd->negoNvram);
+					dvStatus &= ~MPT_SCSICFG_NEGOTIATE;
+					hd->ioc->spi_data.dvStatus[target] =  dvStatus;
+				}
 
-		pScsiTm->TargetID = SCpnt->target;
-		pScsiTm->Bus = hd->port;
-		pScsiTm->ChainOffset = 0;
-		pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+				if ((dvStatus & MPT_SCSICFG_NEED_DV) || hd->ioc->spi_data.forceDv) {
+					unsigned long lflags;
+					/* Schedule DV if necessary */
+					spin_lock_irqsave(&dvtaskQ_lock, lflags);
+					if (!dvtaskQ_active) {
+						dvtaskQ_active = 1;
+						mptscsih_dvTask.sync = 0;
+						mptscsih_dvTask.routine = mptscsih_domainValidation;
+						mptscsih_dvTask.data = (void *) hd;
 
-		pScsiTm->Reserved = 0;
-		pScsiTm->TaskType = task_type;
-		pScsiTm->Reserved1 = 0;
-		pScsiTm->MsgFlags = 0;
+						SCHEDULE_TASK(&mptscsih_dvTask);
+					}
+					hd->ioc->spi_data.forceDv = 0;
+					spin_unlock_irqrestore(&dvtaskQ_lock, lflags);
+				}
 
-		for (i = 0; i < 7; i++)
-			pScsiTm->Reserved2[i] = 0;
+				/* Trying to do DV to this target, extend timeout.
+				 * Wait to issue intil flag is clear 
+				 */
+				if (dvStatus & MPT_SCSICFG_DV_PENDING) {
+					mod_timer(&SCpnt->eh_timeout, jiffies + 40 * HZ);
+					issueCmd = 0;
+				}
+#endif
+			}
+		}
 
-		dprintk((KERN_INFO MYNAM ":DbG: ctx2abort = %08x\n", ctx2abort));
-		pScsiTm->TaskMsgContext = ctx2abort;
+		if (issueCmd) {
+			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+			dmfprintk((MYIOC_s_INFO_FMT "Issued SCSI cmd (%p)\n",
+					hd->ioc->name, SCpnt));
+		} else {
+			ddvtprintk((MYIOC_s_INFO_FMT "Pending SCSI cmd (%p)\n",
+					hd->ioc->name, SCpnt));
+			/* Place this command on the pendingQ if possible */
+			spin_lock_irqsave(&hd->freedoneQlock, flags);
+			if (!Q_IS_EMPTY(&hd->freeQ)) {
+				buffer = hd->freeQ.head;
+				Q_DEL_ITEM(buffer);
 
-		/* Control: No data direction, set task mgmt bit? */
+				/* Save the mf pointer
+				 */
+				buffer->argp = (void *)mf;
 
-		/*
-		 *  As of MPI v0.10 this request can NOT be sent (normally)
-		 *  via FIFOs.	So we can't:
-		 *		mpt_put_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-		 *  SCSITaskMgmt requests MUST be sent ONLY via
-		 *  Doorbell/handshake now.   :-(
-		 */
-		if ((i = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
-					sizeof(SCSITaskMgmt_t), (u32*) mf))
-		    != 0) {
-			printk(KERN_WARNING MYNAM ": WARNING[1] - IOC error (%d) processing TaskMgmt request (mf=%p:sc=%p)\n", i, mf, SCpnt);
-			SCpnt->result = DID_SOFT_ERROR << 16;
-			spin_lock_irqsave(&io_request_lock, flags);
-			SCpnt->scsi_done(SCpnt);
-			spin_unlock_irqrestore(&io_request_lock, flags);
-			mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
-		} else {
-			/* Spin-Wait for TaskMgmt complete!!! */
-			while (mpt_scsih_active_taskmgmt_mf != NULL) {
-				current->state = TASK_INTERRUPTIBLE;
-				schedule_timeout(HZ/4);
+				/* Add to the pendingQ
+				 */
+				Q_ADD_TAIL(&hd->pendingQ.head, buffer, MPT_DONE_Q);
+				spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			} else {
+				spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+				SCpnt->result = (DID_BUS_BUSY << 16);
+				SCpnt->scsi_done(SCpnt);
 			}
 		}
+	} else {
+		mptscsih_freeChainBuffers(hd, my_idx);
+		mpt_free_msg_frame(ScsiDoneCtx, hd->ioc->id, mf);
+		did_errcode = 3;
+		goto did_error;
 	}
 
-	dslprintk((KERN_INFO MYNAM ": spinlock#6\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	mpt_scsih_taskQ_bh_active = 0;
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
+	return 0;
 
-	return;
-}
+did_error:
+	dprintk((MYIOC_s_WARN_FMT "_qcmd did_errcode=%d (sc=%p)\n",
+			hd->ioc->name, did_errcode, SCpnt));
+	/* Just wish OS to issue a retry */
+	SCpnt->result = (DID_BUS_BUSY << 16);
+	spin_lock_irqsave(&hd->freedoneQlock, flags);
+	if (!Q_IS_EMPTY(&hd->freeQ)) {
+		buffer = hd->freeQ.head;
+		Q_DEL_ITEM(buffer);
 
-#endif		/* } */
+		/* Set the Scsi_Cmnd pointer
+		 */
+		buffer->argp = (void *)SCpnt;
+
+		/* Add to the doneQ
+		 */
+		Q_ADD_TAIL(&hd->doneQ.head, buffer, MPT_DONE_Q);
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+	} else {
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+		SCpnt->scsi_done(SCpnt);
+	}
+
+	return 0;
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/**
- *	mptscsih_taskmgmt_complete - Callback routine, gets registered to
- *	Fusion MPT base	driver
- *	@ioc: Pointer to MPT_ADAPTER structure
- *	@mf: Pointer to SCSI task mgmt request frame
- *	@r: Pointer to SCSI task mgmt reply frame
- *
- *	This routine is called from mptbase.c::mpt_interrupt() at the completion
- *	of any SCSI task management request.
- *	This routine is registered with the MPT (base) driver at driver
- *	load/init time via the mpt_register() API call.
+/*
+ *	mptscsih_Add32BitSGE - Add a 32Bit SGE (plus chain buffers) to the
+ *	SCSIIORequest_t Message Frame.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@SCpnt: Pointer to Scsi_Cmnd structure
+ *	@pReq: Pointer to SCSIIORequest_t structure
  *
- *	Returns 1 indicating alloc'd request frame ptr should be freed.
+ *	Returns ...
  */
 static int
-mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *r)
+mptscsih_Add32BitSGE(MPT_SCSI_HOST *hd, Scsi_Cmnd *SCpnt,
+				 SCSIIORequest_t *pReq, int req_idx)
 {
-	SCSITaskMgmtReply_t	*pScsiTmReply;
-	SCSITaskMgmt_t		*pScsiTmReq;
-	u8			 tmType;
-#ifndef MPT_SCSI_USE_NEW_EH
-	unsigned long		 flags;
-#endif
+	MptSge_t *psge;
+	MptChain_t  *chainSge;
+	struct scatterlist *sg;
+	int	 frm_sz;
+	int	 sges_left, sg_done;
+	int	 chain_idx = MPT_HOST_NO_CHAIN;
+	int	 sgeOffset;
+	int	 numSgeSlots, numSgeThisFrame;
+	u32	 sgflags, sgdir, len, thisxfer = 0;
+	int	 offset;
+	int	 newIndex;
+	int	 ii;
+	dma_addr_t v2;
+
+	sgdir = le32_to_cpu(pReq->Control) & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK;
+	if (sgdir == MPI_SCSIIO_CONTROL_WRITE)  {
+		sgdir = MPT_TRANSFER_HOST_TO_IOC;
+	} else {
+		sgdir = MPT_TRANSFER_IOC_TO_HOST;
+	}
 
-	dprintk((KERN_INFO MYNAM ": SCSI TaskMgmt completed mf=%p, r=%p\n",
-		 mf, r));
+	psge = (MptSge_t *) &pReq->SGL;
+	frm_sz = hd->ioc->req_sz;
 
-#ifndef MPT_SCSI_USE_NEW_EH
-	dslprintk((KERN_INFO MYNAM ": spinlock#7\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	/* It better be the active one! */
-	if (mf != mpt_scsih_active_taskmgmt_mf) {
-		printk(KERN_ERR MYNAM ": ERROR! Non-active TaskMgmt (=%p) completed!\n", mf);
-		mpt_scsih_active_taskmgmt_mf = NULL;
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-		return 1;
+	/* Map the data portion, if any.
+	 * sges_left  = 0 if no data transfer.
+	 */
+	sges_left = SCpnt->use_sg;
+	if (SCpnt->use_sg) {
+		sges_left = pci_map_sg(hd->ioc->pcidev,
+			       (struct scatterlist *) SCpnt->request_buffer,
+			       SCpnt->use_sg,
+			       scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+	} else if (SCpnt->request_bufflen) {
+		dma_addr_t	 buf_dma_addr;
+		scPrivate	*my_priv;
+
+		buf_dma_addr = pci_map_single(hd->ioc->pcidev,
+				      SCpnt->request_buffer,
+				      SCpnt->request_bufflen,
+				      scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+
+		/* We hide it here for later unmap. */
+		my_priv = (scPrivate *) &SCpnt->SCp;
+		my_priv->p1 = (void *)(ulong) buf_dma_addr;
+
+		dsgprintk((MYIOC_s_INFO_FMT "SG: non-SG for %p, len=%d\n",
+				hd->ioc->name, SCpnt, SCpnt->request_bufflen));
+
+		/* 0xD1000000 = LAST | EOB | SIMPLE | EOL */
+		psge->FlagsLength = cpu_to_le32(
+				0xD1000000|sgdir|SCpnt->request_bufflen);
+		cpu_to_leXX(buf_dma_addr, psge->Address);
+
+		return SUCCESS;
 	}
 
-#ifdef MPT_DEBUG
-	if ((mf == NULL) ||
-	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
-		printk(KERN_ERR MYNAM ": ERROR! NULL or BAD TaskMgmt ptr (=%p)!\n", mf);
-		mpt_scsih_active_taskmgmt_mf = NULL;
-		spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-		return 1;
+	/* Handle the SG case.
+	 */
+	sg = (struct scatterlist *) SCpnt->request_buffer;
+	sg_done  = 0;
+	sgeOffset = sizeof(SCSIIORequest_t) - sizeof(SGE_IO_UNION);
+	chainSge = NULL;
+
+	/* Prior to entering this loop - the following must be set
+	 * current MF:  sgeOffset (bytes)
+	 *              chainSge (Null if original MF is not a chain buffer)
+	 *              sg_done (num SGE done for this MF)
+	 */
+
+nextSGEset:
+	numSgeSlots = ((frm_sz - sgeOffset) / sizeof(MptSge_t));
+	numSgeThisFrame = (sges_left < numSgeSlots) ? sges_left : numSgeSlots;
+
+	sgflags = MPT_SGE_FLAGS_SIMPLE_ELEMENT | MPT_SGE_FLAGS_ADDRESSING | sgdir;
+
+	/* Get first (num - 1) SG elements
+	 * Skip any SG entries with a length of 0
+	 * NOTE: at finish, sg and psge pointed to NEXT data/location positions
+	 */
+	for (ii=0; ii < (numSgeThisFrame-1); ii++) {
+		thisxfer = sg_dma_len(sg);
+		if (thisxfer == 0) {
+			sg ++; /* Get next SG element from the OS */
+			sg_done++;
+			continue;
+		}
+
+		len += thisxfer;
+		psge->FlagsLength = cpu_to_le32( sgflags | thisxfer );
+		v2 = sg_dma_address(sg);
+		cpu_to_leXX(v2, psge->Address);
+
+		sg++;		/* Get next SG element from the OS */
+		psge++;		/* Point to next SG location in this MF */
+		sgeOffset += sizeof(MptSge_t);
+		sg_done++;
 	}
-#endif
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-#endif
 
-	if (r != NULL) {
-		pScsiTmReply = (SCSITaskMgmtReply_t*)r;
-		pScsiTmReq = (SCSITaskMgmt_t*)mf;
+	if (numSgeThisFrame == sges_left) {
+		/* Add last element, end of buffer and end of list flags.
+		 */
+		sgflags |= MPT_SGE_FLAGS_LAST_ELEMENT |
+				MPT_SGE_FLAGS_END_OF_BUFFER |
+				MPT_SGE_FLAGS_ADDRESSING |
+				MPT_SGE_FLAGS_END_OF_LIST;
 
-		/* Figure out if this was ABORT_TASK, TARGET_RESET, or BUS_RESET! */
-		tmType = pScsiTmReq->TaskType;
+		/* Add last SGE and set termination flags.
+		 * Note: Last SGE may have a length of 0 - which should be ok.
+		 */
+		thisxfer = sg_dma_len(sg);
+		len += thisxfer;
+
+		psge->FlagsLength = cpu_to_le32( sgflags | thisxfer );
+		v2 = sg_dma_address(sg);
+		cpu_to_leXX(v2, psge->Address);
+
+		sg_done++;
+
+		if (chainSge) {
+			/* The current buffer is a chain buffer,
+			 * but there is not another one.
+			 * Update the chain element
+			 * Offset and Length fields.
+			 */
+			chainSge->NextChainOffset = 0;
+			sgeOffset += sizeof(MptSge_t);
+			chainSge->Length = cpu_to_le16(sgeOffset);
+		} else {
+			/* The current buffer is the original MF
+			 * and there is no Chain buffer.
+			 */
+			pReq->ChainOffset = 0;
+		}
+	} else {
+		/* At least one chain buffer is needed.
+		 * Complete the first MF
+		 *  - last SGE element, set the LastElement bit
+		 *  - set ChainOffset (words) for orig MF
+		 *             (OR finish previous MF chain buffer)
+		 *  - update MFStructPtr ChainIndex
+		 *  - Populate chain element
+		 * Also
+		 * Loop until done.
+		 */
 
-		dprintk((KERN_INFO MYNAM ": TaskType = %d\n", tmType));
-		dprintk((KERN_INFO MYNAM ": TerminationCount = %d\n",
-			 le32_to_cpu(pScsiTmReply->TerminationCount)));
+		dsgprintk((MYIOC_s_INFO_FMT "SG: Chain Required! sg done %d\n",
+				hd->ioc->name, sg_done));
 
-		/* Error?  (anything non-zero?) */
-		if (*(u32 *)&pScsiTmReply->Reserved2[0]) {
-			dprintk((KERN_INFO MYNAM ": SCSI TaskMgmt (%d) - Oops!\n", tmType));
-			dprintk((KERN_INFO MYNAM ": IOCStatus = %04xh\n",
-				 le16_to_cpu(pScsiTmReply->IOCStatus)));
-			dprintk((KERN_INFO MYNAM ": IOCLogInfo = %08xh\n",
-				 le32_to_cpu(pScsiTmReply->IOCLogInfo)));
+		/* Set LAST_ELEMENT flag for last non-chain element
+		 * in the buffer. Since psge points at the NEXT
+		 * SGE element, go back one SGE element, update the flags
+		 * and reset the pointer. (Note: sgflags & thisxfer are already
+		 * set properly).
+		 */
+		if (sg_done) {
+			psge--;
+			sgflags = le32_to_cpu (psge->FlagsLength);
+			sgflags |= MPT_SGE_FLAGS_LAST_ELEMENT;
+			psge->FlagsLength = cpu_to_le32( sgflags );
+			psge++;
+		}
+
+		if (chainSge) {
+			/* The current buffer is a chain buffer.
+			 * chainSge points to the previous Chain Element.
+			 * Update its chain element Offset and Length (must
+			 * include chain element size) fields.
+			 * Old chain element is now complete.
+			 */
+			chainSge->NextChainOffset = (u8) (sgeOffset >> 2);
+			sgeOffset += sizeof(MptSge_t);
+			chainSge->Length = cpu_to_le16(sgeOffset);
 		} else {
-			dprintk((KERN_INFO MYNAM ": SCSI TaskMgmt (%d) SUCCESS!\n", tmType));
+			/* The original MF buffer requires a chain buffer -
+			 * set the offset.
+			 * Last element in this MF is a chain element.
+			 */
+			pReq->ChainOffset = (u8) (sgeOffset >> 2);
 		}
-	}
 
-#ifndef MPT_SCSI_USE_NEW_EH
-	/*
-	 *  Signal to _bh thread that we finished.
-	 */
-	dslprintk((KERN_INFO MYNAM ": spinlock#8\n"));
-	spin_lock_irqsave(&mpt_scsih_taskQ_lock, flags);
-	mpt_scsih_active_taskmgmt_mf = NULL;
-	spin_unlock_irqrestore(&mpt_scsih_taskQ_lock, flags);
-#endif
+		sges_left -= sg_done;
 
-	return 1;
+
+		/* NOTE: psge points to the beginning of the chain element
+		 * in current buffer. Get a chain buffer.
+		 */
+		if ((mptscsih_getFreeChainBuffer(hd, &newIndex)) == FAILED)
+			return FAILED;
+
+		/* Update the tracking arrays.
+		 * If chainSge == NULL, update ReqToChain, else ChainToChain
+		 */
+		if (chainSge) {
+			hd->ChainToChain[chain_idx] = newIndex;
+		} else {
+			hd->ReqToChain[req_idx] = newIndex;
+		}
+		chain_idx = newIndex;
+		offset = hd->ioc->req_sz * chain_idx;
+
+		/* Populate the chainSGE for the current buffer.
+		 * - Set chain buffer pointer to psge and fill
+		 *   out the Address and Flags fields.
+		 */
+		chainSge = (MptChain_t *) psge;
+		chainSge->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT;
+		cpu_to_leXX ((hd->ChainBufferDMA + offset), chainSge->Address);
+
+		dsgprintk((KERN_INFO "  Current buff @ %p (index 0x%x)",
+				psge, req_idx));
+
+		/* Start the SGE for the next buffer
+		 */
+		psge = (MptSge_t *) (hd->ChainBuffer + offset);
+		sgeOffset = 0;
+		sg_done = 0;
+
+		dsgprintk((KERN_INFO "  Chain buff @ %p (index 0x%x)\n",
+				psge, chain_idx));
+
+		/* Start the SGE for the next buffer
+		 */
+
+		goto nextSGEset;
+	}
+
+	return SUCCESS;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *	This is anyones guess quite frankly.
+ *	mptscsih_AddNullSGE - Add a NULL SGE to the SCSIIORequest_t
+ *	Message Frame.
+ *	@pReq: Pointer to SCSIIORequest_t structure
  */
-
-int
-mptscsih_bios_param(Disk * disk, kdev_t dev, int *ip)
+static void
+mptscsih_AddNullSGE(SCSIIORequest_t *pReq)
 {
-	int size;
+	MptSge_t *psge;
 
-	size = disk->capacity;
-	ip[0] = 64;				/* heads			*/
-	ip[1] = 32;				/* sectors			*/
-	if ((ip[2] = size >> 11) > 1024) {	/* cylinders, test for big disk */
-		ip[0] = 255;			/* heads			*/
-		ip[1] = 63;			/* sectors			*/
-		ip[2] = size / (255 * 63);	/* cylinders			*/
-	}
-	return 0;
+	psge = (MptSge_t *) &pReq->SGL;
+	psge->FlagsLength = cpu_to_le32(MPT_SGE_FLAGS_SSIMPLE_READ | 0);
+
+	cpu_to_leXX( (dma_addr_t) -1, psge->Address);
+
+	return;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
- *  Private routines...
- */
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* 19991030 -sralston
- *  Return absolute SCSI data direction:
- *     1 = _DATA_OUT
- *     0 = _DIR_NONE
- *    -1 = _DATA_IN
+ *	mptscsih_getFreeChainBuffes - Function to get a free chain
+ *	from the MPT_SCSI_HOST FreeChainQ.
+ *	@hd: Pointer to the MPT_SCSI_HOST instance
+ *	@req_idx: Index of the SCSI IO request frame. (output)
+ *
+ *	return SUCCESS or FAILED
  */
 static int
-mptscsih_io_direction(Scsi_Cmnd *cmd)
+mptscsih_getFreeChainBuffer(MPT_SCSI_HOST *hd, int *retIndex)
 {
-	switch (cmd->cmnd[0]) {
-	/*  _DATA_OUT commands	*/
-	case WRITE_6:		case WRITE_10:		case WRITE_12:
-	case WRITE_LONG:	case WRITE_SAME:	case WRITE_BUFFER:
-	case WRITE_VERIFY:	case WRITE_VERIFY_12:
-	case COMPARE:		case COPY:		case COPY_VERIFY:
-	case SEARCH_EQUAL:	case SEARCH_HIGH:	case SEARCH_LOW:
-	case SEARCH_EQUAL_12:	case SEARCH_HIGH_12:	case SEARCH_LOW_12:
-	case MODE_SELECT:	case MODE_SELECT_10:	case LOG_SELECT:
-	case SEND_DIAGNOSTIC:	case CHANGE_DEFINITION: case UPDATE_BLOCK:
-	case SET_WINDOW:	case MEDIUM_SCAN:	case SEND_VOLUME_TAG:
-	case REASSIGN_BLOCKS:
-	case PERSISTENT_RESERVE_OUT:
-	case 0xea:
-		return 1;
+	MPT_FRAME_HDR *chainBuf = NULL;
+	unsigned long flags;
+	int rc = FAILED;
+	int chain_idx = MPT_HOST_NO_CHAIN;
 
-	/*  No data transfer commands  */
-	case SEEK_6:		case SEEK_10:
-	case RESERVE:		case RELEASE:
-	case TEST_UNIT_READY:
-	case START_STOP:
-	case ALLOW_MEDIUM_REMOVAL:
-		return 0;
+	//spin_lock_irqsave(&hd->FreeChainQlock, flags);
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	if (!Q_IS_EMPTY(&hd->FreeChainQ)) {
 
-	/*  Conditional data transfer commands	*/
-	case FORMAT_UNIT:
-		if (cmd->cmnd[1] & 0x10)	/* FmtData (data out phase)? */
-			return 1;
-		else
-			return 0;
+		int offset;
 
-	case VERIFY:
-		if (cmd->cmnd[1] & 0x02)	/* VERIFY:BYTCHK (data out phase)? */
-			return 1;
-		else
-			return 0;
+		chainBuf = hd->FreeChainQ.head;
+		Q_DEL_ITEM(&chainBuf->u.frame.linkage);
+		offset = (u8 *)chainBuf - (u8 *)hd->ChainBuffer;
+		chain_idx = offset / hd->ioc->req_sz;
+		rc = SUCCESS;
+	}
+	//spin_unlock_irqrestore(&hd->FreeChainQlock, flags);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
-	case RESERVE_10:
-		if (cmd->cmnd[1] & 0x03)	/* RESERSE:{LongID|Extent} (data out phase)? */
-			return 1;
-		else
-			return 0;
 
-#if 0
-	case REZERO_UNIT:	/* (or REWIND) */
-	case SPACE:
-	case ERASE:		case ERASE_10:
-	case SYNCHRONIZE_CACHE:
-	case LOCK_UNLOCK_CACHE:
-#endif
+	*retIndex = chain_idx;
 
-	/*  Must be data _IN!  */
-	default:
-		return -1;
-	}
+	dsgprintk((MYIOC_s_INFO_FMT "getFreeChainBuffer (index %d), got buf=%p\n",
+			hd->ioc->name, *retIndex, chainBuf));
+
+	return rc;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_freeChainBuffers - Function to free chain buffers associated
+ *	with a SCSI IO request
+ *	@hd: Pointer to the MPT_SCSI_HOST instance
+ *	@req_idx: Index of the SCSI IO request frame.
+ *
+ *	Called if SG chain buffer allocation fails and mptscsih callbacks.
+ *	No return.
+ */
 static void
-copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply)
+mptscsih_freeChainBuffers(MPT_SCSI_HOST *hd, int req_idx)
 {
-	MPT_SCSI_DEV	*mpt_sdev = NULL;
-	u32		 sense_count = le32_to_cpu(pScsiReply->SenseCount);
-	char		 devFoo[32];
-	IO_Info_t	 thisIo;
-
-	if (sc && sc->device)
-		mpt_sdev = (MPT_SCSI_DEV*) sc->device->hostdata;
-
-	if (sense_count) {
-		u8 *sense_data;
-		int req_index;
+	MPT_FRAME_HDR *chain = NULL;
+	unsigned long flags;
+	int chain_idx;
+	int next;
 
-		/* Copy the sense received into the scsi command block. */
-		req_index = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
-		sense_data = ((u8 *)hd->ioc->sense_buf_pool + (req_index * 256));
-		memcpy(sc->sense_buffer, sense_data, SNS_LEN(sc));
-		/* Cache SenseData for this SCSI device! */
-		if (mpt_sdev) {
-			memcpy(mpt_sdev->CachedSense.data, sense_data, sense_count);
-			mpt_sdev->sense_sz = sense_count;
-		}
-	} else {
-		dprintk((KERN_INFO MYNAM ": Hmmm... SenseData len=0! (?)\n"));
-	}
+	/* Get the first chain index and reset
+	 * tracker state.
+	 */
+	chain_idx = hd->ReqToChain[req_idx];
+	hd->ReqToChain[req_idx] = MPT_HOST_NO_CHAIN;
 
+	while (chain_idx != MPT_HOST_NO_CHAIN) {
 
-	thisIo.cdbPtr = sc->cmnd;
-	thisIo.sensePtr = sc->sense_buffer;
-	thisIo.SCSIStatus = pScsiReply->SCSIStatus;
-	thisIo.DoDisplay = 1;
-	sprintf(devFoo, "ioc%d,scsi%d:%d", hd->ioc->id, sc->target, sc->lun);
-	thisIo.DevIDStr = devFoo;
-/* fubar */
-	thisIo.dataPtr = NULL;
-	thisIo.inqPtr = NULL;
-	if (sc->device) {
-		thisIo.inqPtr = sc->device->vendor-8;		/* FIXME!!! */
-	}
-	(void) mpt_ScsiHost_ErrorReport(&thisIo);
+		/* Save the next chain buffer index */
+		next = hd->ChainToChain[chain_idx];
 
-	return;
-}
+		/* Free this chain buffer and reset
+		 * tracker
+		 */
+		hd->ChainToChain[chain_idx] = MPT_HOST_NO_CHAIN;
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static u32
-SCPNT_TO_MSGCTX(Scsi_Cmnd *sc)
-{
-	MPT_SCSI_HOST *hd;
-	MPT_FRAME_HDR *mf;
-	int i;
+		chain = (MPT_FRAME_HDR *) (hd->ChainBuffer
+					+ (chain_idx * hd->ioc->req_sz));
+		//spin_lock_irqsave(&hd->FreeChainQlock, flags);
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		Q_ADD_TAIL(&hd->FreeChainQ.head,
+					&chain->u.frame.linkage, MPT_FRAME_HDR);
+		//spin_unlock_irqrestore(&hd->FreeChainQlock, flags);
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 
-	hd = (MPT_SCSI_HOST *) sc->host->hostdata;
+		dmfprintk((MYIOC_s_INFO_FMT "FreeChainBuffers (index %d)\n",
+				hd->ioc->name, chain_idx));
 
-	for (i = 0; i < hd->ioc->req_depth; i++) {
-		if (hd->ScsiLookup[i] == sc) {
-			mf = MPT_INDEX_2_MFPTR(hd->ioc, i);
-			return mf->u.frame.hwhdr.msgctxu.MsgContext;
-		}
+		/* handle next */
+		chain_idx = next;
 	}
-
-	return -1;
+	return;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	Reset Handling
+ */
 
-/* see mptscsih.h */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_TMHandler - Generic handler for SCSI Task Management.
+ *	Fall through to mpt_HardResetHandler if: not operational, too many
+ *	failed TM requests or handshake failure.
+ *
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@type: Task Management type
+ *	@target: Logical Target ID for reset (if appropriate)
+ *	@lun: Logical Unit for reset (if appropriate)
+ *	@ctx2abort: Context for the task to be aborted (if appropriate)
+ *	@sleepFlag: If set, use udelay instead of schedule in handshake code.
+ *
+ *	Remark: Currently invoked from a non-interrupt thread (_bh).
+ *
+ *	Remark: With old EH code, at most 1 SCSI TaskMgmt function per IOC
+ *	will be active.
+ *
+ *	Returns 0 for SUCCESS or -1 if FAILED.
+ */
+static int
+mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag)
+{
+	MPT_ADAPTER	*ioc = NULL;
+	int		 rc = -1;
+	int		 doTask = 1;
+	u32		 ioc_raw_state;
+	unsigned long	 flags;
 
-#ifdef MPT_SCSIHOST_NEED_ENTRY_EXIT_HOOKUPS
-	static Scsi_Host_Template driver_template = MPT_SCSIHOST;
-#	include "../../scsi/scsi_module.c"
+	/* If FW is being reloaded currently, return success to
+	 * the calling function.
+	 */
+	if (!hd)
+		return 0;
+
+	ioc = hd->ioc;
+	dtmprintk((MYIOC_s_INFO_FMT "TMHandler Entered!\n", ioc->name));
+
+	if (ioc == NULL) {
+		printk(KERN_ERR MYNAM " TMHandler" " NULL ioc!\n");
+		return 0;
+	}
+
+	// SJR - CHECKME - Can we avoid this here?
+	// (mpt_HardResetHandler has this check...)
+	spin_lock_irqsave(&ioc->diagLock, flags);
+	if ((ioc->diagPending) || (ioc->alt_ioc && ioc->alt_ioc->diagPending)) {
+		spin_unlock_irqrestore(&ioc->diagLock, flags);
+		return 0;
+	}
+	spin_unlock_irqrestore(&ioc->diagLock, flags);
+
+	/* Do not do a Task Management if there are
+	 * too many failed TMs on this adapter.
+	 */
+	if (hd->numTMrequests > MPT_HOST_TOO_MANY_TM)
+		doTask = 0;
+
+	/* Is operational?
+	 */
+	ioc_raw_state = mpt_GetIocState(hd->ioc, 0);
+
+#ifdef MPT_DEBUG_RESET
+	if ((ioc_raw_state & MPI_IOC_STATE_MASK) != MPI_IOC_STATE_OPERATIONAL) {
+		printk(MYIOC_s_WARN_FMT 
+			"TM Handler: IOC Not operational! state 0x%x Calling HardResetHandler\n", 
+			hd->ioc->name, ioc_raw_state);
+	}
 #endif
 
+	if (doTask && ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_OPERATIONAL)
+				&& !(ioc_raw_state & MPI_DOORBELL_ACTIVE)) {
+
+		/* Isse the Task Mgmt request.
+		 */
+		rc = mptscsih_IssueTaskMgmt(hd, type, target, lun, ctx2abort, sleepFlag);
+		if (rc) {
+			printk(MYIOC_s_INFO_FMT "Issue of TaskMgmt failed!\n", hd->ioc->name);
+		} else {
+			printk(MYIOC_s_INFO_FMT "Issue of TaskMgmt Successful!\n", hd->ioc->name);
+		}
+	}
+#ifdef DROP_TEST
+	numTMrequested++;
+	if (numTMrequested > 5) {
+		rc = 0;		/* set to 1 to force a hard reset */
+		numTMrequested = 0;
+	}
+#endif
+
+	if (rc) {
+		dtmprintk((MYIOC_s_INFO_FMT "Falling through to HardReset! \n",
+			 hd->ioc->name));
+		rc = mpt_HardResetHandler(hd->ioc, sleepFlag);
+	}
+
+	dtmprintk((MYIOC_s_INFO_FMT "TMHandler rc = %d!\n", hd->ioc->name, rc));
+#ifndef MPT_SCSI_USE_NEW_EH
+	dtmprintk((MYIOC_s_INFO_FMT "TMHandler: _bh_handler state (%d) taskQ count (%d)\n",
+		ioc->name, mytaskQ_bh_active, hd->taskQcnt));
+#endif
+
+	return rc;
+}
+
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_IssueTaskMgmt - Generic send Task Management function.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@type: Task Management type
+ *	@target: Logical Target ID for reset (if appropriate)
+ *	@lun: Logical Unit for reset (if appropriate)
+ *	@ctx2abort: Context for the task to be aborted (if appropriate)
+ *	@sleepFlag: If set, use udelay instead of schedule in handshake code.
+ *
+ *	Remark: _HardResetHandler can be invoked from an interrupt thread (timer)
+ *	or a non-interrupt thread.  In the former, must not call schedule().
+ *
+ *	Not all fields are meaningfull for all task types.
+ *
+ *	Returns 0 for SUCCESS, -999 for "no msg frames",
+ *	else other non-zero value returned.
+ */
 static int
-mptscsih_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
+mptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 target, u8 lun, int ctx2abort, int sleepFlag)
 {
-	dprintk((KERN_INFO MYNAM ": IOC %s_reset routed to SCSI host driver!\n",
-			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+	MPT_FRAME_HDR	*mf;
+	SCSITaskMgmt_t	*pScsiTm;
+	int		 ii;
+	int		 retval = 0;
 
-	if (reset_phase == MPT_IOC_PRE_RESET) {
-		/* FIXME! Do pre-reset cleanup */
-	} else {
-		/* FIXME! Do post-reset cleanup */
+	/* Return Fail to calling function if no message frames available.
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
+		dtmprintk((MYIOC_s_WARN_FMT "IssueTaskMgmt, no msg frames!!\n",
+				hd->ioc->name));
+		//return FAILED;
+		return -999;
 	}
+	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt request @ %p\n",
+			hd->ioc->name, mf));
 
-	return 1;		/* currently means nothing really */
+	/* Format the Request
+	 */
+	pScsiTm = (SCSITaskMgmt_t *) mf;
+	pScsiTm->TargetID = target;
+	pScsiTm->Bus = hd->port;
+	pScsiTm->ChainOffset = 0;
+	pScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;
+
+	pScsiTm->Reserved = 0;
+	pScsiTm->TaskType = type;
+	pScsiTm->Reserved1 = 0;
+	pScsiTm->MsgFlags = 0;
+
+	for (ii= 0; ii < 8; ii++) {
+		pScsiTm->LUN[ii] = 0;
+	}
+	pScsiTm->LUN[1] = lun;
+
+	for (ii=0; ii < 7; ii++)
+		pScsiTm->Reserved2[ii] = 0;
+
+	pScsiTm->TaskMsgContext = ctx2abort;
+	dtmprintk((MYIOC_s_INFO_FMT "IssueTaskMgmt, ctx2abort (0x%08x), type (%d)\n",
+			hd->ioc->name, ctx2abort, type));
+
+	/* MPI v0.10 requires SCSITaskMgmt requests be sent via Doorbell/handshake
+		mpt_put_msg_frame(hd->ioc->id, mf);
+	* Save the MF pointer in case the request times out.
+	*/
+	hd->tmPtr = mf;
+	hd->numTMrequests++;
+	hd->TMtimer.expires = jiffies + HZ*20;  /* 20 seconds */
+	add_timer(&hd->TMtimer);
+
+	if ((retval = mpt_send_handshake_request(ScsiTaskCtx, hd->ioc->id,
+				sizeof(SCSITaskMgmt_t), (u32*)pScsiTm, sleepFlag))
+	!= 0) {
+		dtmprintk((MYIOC_s_WARN_FMT "_send_handshake FAILED!"
+			" (hd %p, ioc %p, mf %p) \n", hd->ioc->name, hd, hd->ioc, mf));
+		hd->numTMrequests--;
+		hd->tmPtr = NULL;
+		del_timer(&hd->TMtimer);
+		mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+		return ii;
+	}
+
+	return retval;
 }
 
+#ifdef MPT_SCSI_USE_NEW_EH		/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int
-mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)
+/**
+ *	mptscsih_abort - Abort linux Scsi_Cmnd routine, new_eh variant
+ *	@SCpnt: Pointer to Scsi_Cmnd structure, IO to be aborted
+ *
+ *	(linux Scsi_Host_Template.eh_abort_handler routine)
+ *
+ *	Returns SUCCESS or FAILED.
+ */
+int
+mptscsih_abort(Scsi_Cmnd * SCpnt)
 {
-	u8 event = le32_to_cpu(pEvReply->Event) & 0xFF;
+	MPT_SCSI_HOST	*hd;
+	MPT_FRAME_HDR	*mf;
+	unsigned long	 flags;
+	u32		 ctx2abort;
+	int		 scpnt_idx;
+	u8		 type;
 
-	dprintk((KERN_INFO MYNAM ": MPT event (=%02Xh) routed to SCSI host driver!\n", event));
+	printk(KERN_WARNING MYNAM ": Attempting ABORT SCSI IO (=%p)\n", SCpnt);
+	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
 
-	switch (event) {
-	case MPI_EVENT_UNIT_ATTENTION:			/* 03 */
-		/* FIXME! */
-		break;
-	case MPI_EVENT_IOC_BUS_RESET:			/* 04 */
-		/* FIXME! */
-		break;
-	case MPI_EVENT_EXT_BUS_RESET:			/* 05 */
-		/* FIXME! */
-		break;
-	case MPI_EVENT_LOGOUT:				/* 09 */
-		/* FIXME! */
-		break;
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
+		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return SUCCESS;
+	}
 
-		/*
-		 *  CHECKME! Don't think we need to do
-		 *  anything for these, but...
+	/* Find this command
+	 */
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup. If found in 
+		 * doneQ, delete from Q. Do OS callback.
 		 */
-	case MPI_EVENT_RESCAN:				/* 06 */
-	case MPI_EVENT_LINK_STATUS_CHANGE:		/* 07 */
-	case MPI_EVENT_LOOP_STATE_CHANGE:		/* 08 */
-		/*
-		 *  CHECKME!  Falling thru...
+		search_doneQ_for_cmd(hd, SCpnt);
+
+		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return SUCCESS;
+	}
+
+	/* If this command is pended, then timeout/hang occurred
+	 * during DV. Post command and flush pending Q 
+	 * and then following up with the reset request.
+	 */
+	if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		post_pendingQ_commands(hd);
+	}
+
+	/* Most important!  Set TaskMsgContext to SCpnt's MsgContext!
+	 * (the IO to be ABORT'd)
+	 *
+	 * NOTE: Since we do not byteswap MsgContext, we do not
+	 *	 swap it here either.  It is an opaque cookie to
+	 *	 the controller, so it does not matter. -DaveM
+	 */
+	mf = MPT_INDEX_2_MFPTR(hd->ioc, scpnt_idx);
+	ctx2abort = mf->u.frame.hwhdr.msgctxu.MsgContext;
+
+	/* This thread will not exit until tmPending is cleared
+	 * FIXME - must ensure single threaded....DV conflict possible
+	 */
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	hd->tmPending = 1;
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	if (hd->is_spi)
+		type = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
+	else {
+		type = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
+		hd->abortSCpnt = SCpnt;
+		printk(KERN_WARNING MYNAM ": Attempting ABORT SCSI IO! (sc=%p)\n", SCpnt);
+	}
+
+	if (mptscsih_TMHandler(hd, type,
+			SCpnt->target, SCpnt->lun, ctx2abort, CAN_SLEEP) < 0) {
+
+		/* The TM request failed and the subsequent FW-reload failed!
+		 * Fatal error case.
 		 */
+		printk(MYIOC_s_WARN_FMT "Error processing TaskMgmt request (sc=%p)\n",
+				hd->ioc->name, SCpnt);
 
-	case MPI_EVENT_NONE:				/* 00 */
-	case MPI_EVENT_LOG_DATA:			/* 01 */
-	case MPI_EVENT_STATE_CHANGE:			/* 02 */
-	case MPI_EVENT_EVENT_CHANGE:			/* 0A */
-	default:
-		dprintk((KERN_INFO MYNAM ": Ignoring event (=%02Xh)\n", event));
-		break;
+		/* If command not found, do not do callback,
+		 *  just return failed.  CHECKME 
+		 */
+		if (hd->ScsiLookup[scpnt_idx] != NULL) {
+			//atomic_dec(&queue_depth);
+			SCpnt->result = STS_BUSY;
+			spin_lock_irqsave(&io_request_lock, flags);
+			SCpnt->scsi_done(SCpnt);
+			spin_unlock_irqrestore(&io_request_lock, flags);
+		}
+
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		hd->tmPending = 0;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
 	}
 
-	return 1;		/* currently means nothing really */
+
+	/* Spin on tmPending until we get the interrupt for this TM request.
+	 */
+	while (1) {
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		if (!hd->tmPending) {
+			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+			break;
+		}
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+	}
+
+	return FAILED;
 }
 
-#if 0		/* { */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *	scsiherr.c - Fusion MPT SCSI Host driver error handling/reporting.
+/**
+ *	mptscsih_dev_reset - Perform a SCSI TARGET_RESET!  new_eh variant
+ *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
  *
- *	drivers/message/fusion/scsiherr.c
+ *	(linux Scsi_Host_Template.eh_dev_reset_handler routine)
+ *
+ *	Returns SUCCESS or FAILED.
  */
+int
+mptscsih_dev_reset(Scsi_Cmnd * SCpnt)
+{
+	MPT_SCSI_HOST	*hd;
+	MPT_FRAME_HDR	*mf;
+	unsigned long	 flags;
+	int		 scpnt_idx;
+	u8		 type;
 
-//extern const char	**mpt_ScsiOpcodesPtr;	/* needed by mptscsih.c */
-//extern ASCQ_Table_t	 *mpt_ASCQ_TablePtr;
-//extern int		  mpt_ASCQ_TableSz;
+	printk(KERN_WARNING MYNAM ": Attempting _TARGET_RESET (%p)\n", SCpnt);
+	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
 
-/*  Lie!  */
-#define MYNAM	"mptscsih"
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
+		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return SUCCESS;
+	}
 
-#endif		/* } */
+	/* Find this command
+	 */
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup. If found in 
+		 * doneQ, delete from Q. Do OS callback.
+		 */
+		search_doneQ_for_cmd(hd, SCpnt);
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *  Private data...
- */
-static ASCQ_Table_t *mptscsih_ASCQ_TablePtr;
+		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return SUCCESS;
+	}
+
+	/* If this command is pended, then timeout/hang occurred
+	 * during DV. Force bus reset by posting command to F/W
+	 * and then following up with the reset request.
+	 */
+	if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		post_pendingQ_commands(hd);
+	}
+
+	/* This thread will not exit until tmPending is cleared
+	 */
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	hd->tmPending = 1;
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	if (hd->is_spi)
+		type = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
+	else {
+		type = MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET;
+		printk(KERN_WARNING MYNAM ": Attempting Target Reset! (sc=%p)\n", SCpnt);
+	}
+
+	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,
+				SCpnt->target, 0, 0, CAN_SLEEP) < 0) {
+		/* The TM request failed and the subsequent FW-reload failed!
+		 * Fatal error case.
+		 */
+		printk(MYIOC_s_WARN_FMT "Error processing TaskMgmt request (sc=%p)\n",
+		 		hd->ioc->name, SCpnt);
+
+		/* If command not found, do not do callback,
+		 * just returned failed. CHECKME.
+		 */
+		if (hd->ScsiLookup[scpnt_idx] != NULL) {
+			//atomic_dec(&queue_depth);
+			SCpnt->result = STS_BUSY;
+			spin_lock_irqsave(&io_request_lock, flags);
+			SCpnt->scsi_done(SCpnt);
+			spin_unlock_irqrestore(&io_request_lock, flags);
+		}
+
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		hd->tmPending = 0;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+	}
+
+	/* Spin on tmPending until we get the interrupt for this TM request.
+	 */
+	while (1) {
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		if (!hd->tmPending) {
+			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+			break;
+		}
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+	}
+
+	//return SUCCESS;
+	return FAILED;
+}
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* old symsense.c stuff... */
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- * Private data...
- * To protect ourselves against those that would pass us bogus pointers
+/**
+ *	mptscsih_bus_reset - Perform a SCSI BUS_RESET!	new_eh variant
+ *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
+ *
+ *	(linux Scsi_Host_Template.eh_bus_reset_handler routine)
+ *
+ *	Returns SUCCESS or FAILED.
  */
-static u8 dummyInqData[SCSI_STD_INQUIRY_BYTES]
-    = { 0x1F, 0x00, 0x00, 0x00,
-	0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static u8 dummySenseData[SCSI_STD_SENSE_BYTES]
-    = { 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00 };
-static u8 dummyCDB[16]
-    = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-static u8 dummyScsiData[16]
-    = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+int
+mptscsih_bus_reset(Scsi_Cmnd * SCpnt)
+{
+	MPT_SCSI_HOST	*hd;
+	MPT_FRAME_HDR	*mf;
+	unsigned long	 flags;
+	int		 scpnt_idx;
 
-#if 0
-static const char *PeripheralDeviceTypeString[32] = {
-	"Direct-access",		/* 00h */
-	"Sequential-access",		/* 01h */
-	"Printer",			/* 02h */
-	"Processor",			/* 03h */
-			/*"Write-Once-Read-Multiple",*/	/* 04h */
-	"WORM",				/* 04h */
-	"CD-ROM",			/* 05h */
-	"Scanner",			/* 06h */
-	"Optical memory",		/* 07h */
-	"Media Changer",		/* 08h */
-	"Communications",		/* 09h */
-	"(Graphics arts pre-press)",	/* 0Ah */
-	"(Graphics arts pre-press)",	/* 0Bh */
-	"Array controller",		/* 0Ch */
-	"Enclosure services",		/* 0Dh */
-	"Simplified direct-access",	/* 0Eh */
-	"Reserved-0Fh",			/* 0Fh */
-	"Reserved-10h",			/* 10h */
-	"Reserved-11h",			/* 11h */
-	"Reserved-12h",			/* 12h */
-	"Reserved-13h",			/* 13h */
-	"Reserved-14h",			/* 14h */
-	"Reserved-15h",			/* 15h */
-	"Reserved-16h",			/* 16h */
-	"Reserved-17h",			/* 17h */
-	"Reserved-18h",			/* 18h */
-	"Reserved-19h",			/* 19h */
-	"Reserved-1Ah",			/* 1Ah */
-	"Reserved-1Bh",			/* 1Bh */
-	"Reserved-1Ch",			/* 1Ch */
-	"Reserved-1Dh",			/* 1Dh */
-	"Reserved-1Eh",			/* 1Eh */
-	"Unknown"			/* 1Fh */
-};
-#endif
+	printk(KERN_WARNING MYNAM ": Attempting _BUS_RESET (%p)\n", SCpnt);
+	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
 
-static char *ScsiStatusString[] = {
-	"GOOD",					/* 00h */
-	NULL,					/* 01h */
-	"CHECK CONDITION",			/* 02h */
-	NULL,					/* 03h */
-	"CONDITION MET",			/* 04h */
-	NULL,					/* 05h */
-	NULL,					/* 06h */
-	NULL,					/* 07h */
-	"BUSY",					/* 08h */
-	NULL,					/* 09h */
-	NULL,					/* 0Ah */
-	NULL,					/* 0Bh */
-	NULL,					/* 0Ch */
-	NULL,					/* 0Dh */
-	NULL,					/* 0Eh */
-	NULL,					/* 0Fh */
-	"INTERMEDIATE",				/* 10h */
-	NULL,					/* 11h */
-	NULL,					/* 12h */
-	NULL,					/* 13h */
-	"INTERMEDIATE-CONDITION MET",		/* 14h */
-	NULL,					/* 15h */
-	NULL,					/* 16h */
-	NULL,					/* 17h */
-	"RESERVATION CONFLICT",			/* 18h */
-	NULL,					/* 19h */
-	NULL,					/* 1Ah */
-	NULL,					/* 1Bh */
-	NULL,					/* 1Ch */
-	NULL,					/* 1Dh */
-	NULL,					/* 1Eh */
-	NULL,					/* 1Fh */
-	NULL,					/* 20h */
-	NULL,					/* 21h */
-	"COMMAND TERMINATED",			/* 22h */
-	NULL,					/* 23h */
-	NULL,					/* 24h */
-	NULL,					/* 25h */
-	NULL,					/* 26h */
-	NULL,					/* 27h */
-	"TASK SET FULL",			/* 28h */
-	NULL,					/* 29h */
-	NULL,					/* 2Ah */
-	NULL,					/* 2Bh */
-	NULL,					/* 2Ch */
-	NULL,					/* 2Dh */
-	NULL,					/* 2Eh */
-	NULL,					/* 2Fh */
-	"ACA ACTIVE",				/* 30h */
-	NULL
-};
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
+		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return SUCCESS;
+	}
 
-static const char *ScsiCommonOpString[] = {
-	"TEST UNIT READY",			/* 00h */
-	"REZERO UNIT (REWIND)",			/* 01h */
-	NULL,					/* 02h */
-	"REQUEST_SENSE",			/* 03h */
-	"FORMAT UNIT (MEDIUM)",			/* 04h */
-	"READ BLOCK LIMITS",			/* 05h */
-	NULL,					/* 06h */
-	"REASSIGN BLOCKS",			/* 07h */
-	"READ(6)",				/* 08h */
-	NULL,					/* 09h */
-	"WRITE(6)",				/* 0Ah */
-	"SEEK(6)",				/* 0Bh */
-	NULL,					/* 0Ch */
-	NULL,					/* 0Dh */
-	NULL,					/* 0Eh */
-	"READ REVERSE",				/* 0Fh */
-	"WRITE_FILEMARKS",			/* 10h */
-	"SPACE(6)",				/* 11h */
-	"INQUIRY",				/* 12h */
-	NULL
-};
+	/* Find this command
+	 */
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup. If found in 
+		 * doneQ, delete from Q. Do OS callback.
+		 */
+		search_doneQ_for_cmd(hd, SCpnt);
 
-static const char *SenseKeyString[] = {
-	"NO SENSE",				/* 0h */
-	"RECOVERED ERROR",			/* 1h */
-	"NOT READY",				/* 2h */
-	"MEDIUM ERROR",				/* 3h */
-	"HARDWARE ERROR",			/* 4h */
-	"ILLEGAL REQUEST",			/* 5h */
-	"UNIT ATTENTION",			/* 6h */
-	"DATA PROTECT",				/* 7h */
-	"BLANK CHECK",				/* 8h */
-	"VENDOR-SPECIFIC",			/* 9h */
-	"ABORTED COPY",				/* Ah */
-	"ABORTED COMMAND",			/* Bh */
-	"EQUAL (obsolete)",			/* Ch */
-	"VOLUME OVERFLOW",			/* Dh */
-	"MISCOMPARE",				/* Eh */
-	"RESERVED",				/* Fh */
-	NULL
-};
+		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return SUCCESS;
+	}
 
-#define SPECIAL_ASCQ(c,q) \
-	(((c) == 0x40 && (q) != 0x00) || ((c) == 0x4D) || ((c) == 0x70))
+	/* If this command is pended, then timeout/hang occurred
+	 * during DV. Force bus reset by posting command to F/W
+	 * and then following up with the reset request.
+	 */
+	if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		post_pendingQ_commands(hd);
+	}
+
+	/* This thread will not exit until tmPending is cleared
+	 */
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	hd->tmPending = 1;
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,
+						0, 0, 0, CAN_SLEEP) < 0) {
+
+		/* The TM request failed and the subsequent FW-reload failed!
+		 * Fatal error case.
+		 */
+		printk(MYIOC_s_WARN_FMT "Error processing TaskMgmt request (sc=%p)\n",
+		 		hd->ioc->name, SCpnt);
+
+		/* If command not found, do not do callback,
+		 * just returned failed. CHECKME.
+		 */
+		if (hd->ScsiLookup[scpnt_idx] != NULL) {
+			//atomic_dec(&queue_depth);
+			SCpnt->result = STS_BUSY;
+			spin_lock_irqsave(&io_request_lock, flags);
+			SCpnt->scsi_done(SCpnt);
+			spin_unlock_irqrestore(&io_request_lock, flags);
+		}
+
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		hd->tmPending = 0;
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+		return FAILED;
+	}
+
+	/* Spin on tmPending until we get the interrupt for this TM request.
+	 */
+	while (1) {
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		if (!hd->tmPending) {
+			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+			break;
+		}
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+	}
+
+	return SUCCESS;
+}
 
 #if 0
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *  Sense_Key_Specific() - If Sense_Key_Specific_Valid bit is set,
- *			   then print additional information via
- *			   a call to SDMS_SystemAlert().
+/**
+ *	mptscsih_host_reset - Perform a SCSI host adapter RESET!
+ *	new_eh variant
+ *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
  *
- *  Return: nothing
+ *	(linux Scsi_Host_Template.eh_host_reset_handler routine)
+ *
+ *	Returns SUCCESS or FAILED.
  */
-static void Sense_Key_Specific(IO_Info_t *ioop, char *msg1)
+int
+mptscsih_host_reset(Scsi_Cmnd *SCpnt)
 {
-	u8	*sd;
-	u8	 BadValue;
-	u8	 SenseKey;
-	int	 Offset;
-	int	 len = strlen(msg1);
+	MPT_SCSI_HOST	*hd;
+	MPT_FRAME_HDR	*mf;
 
-	sd = ioop->sensePtr;
-	if (SD_Additional_Sense_Length(sd) < 8)
-		return;
+	printk(KERN_WARNING MYNAM ": Attempting HOST_RESET (%p)\n", SCpnt);
+	printk(KERN_WARNING MYNAM ": IOs outstanding = %d\n", atomic_read(&queue_depth));
 
-	SenseKey = SD_Sense_Key(sd);
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
+		SCpnt->result = DID_RESET << 16;
+		spin_lock_irqsave(&io_request_lock, flags);
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);
+		return SUCCESS;
+	}
+
+	/* If this command is pended, then timeout/hang occurred
+	 * during DV. Force bus reset by posting command to F/W
+	 * and then following up with the reset request.
+	 */
+	if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		post_pendingQ_commands(hd);
+	}
+
+	/* This thread will not exit until tmPending is cleared
+	 */
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	hd->tmPending = 1;
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	if (mpt_HardResetHandler(hd->ioc, CAN_SLEEP) < 0) {
+		SCpnt->result = STS_BUSY;
+		spin_lock_irqsave(&io_request_lock, flags);		// sjr-added
+		SCpnt->scsi_done(SCpnt);
+		spin_unlock_irqrestore(&io_request_lock, flags);	// sjr-added
+		return FAILED;
+	}
+
+	/* Spin on tmPending until we get the interrupt for this TM request.
+	 */
+	while (1) {
+		spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+		if (!hd->tmPending) {
+			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+			break;
+		}
+		spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+	}
+
+	return SUCCESS;
+}
+#endif
+
+#else		/* MPT_SCSI old EH stuff... */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_old_abort - Abort linux Scsi_Cmnd routine
+ *	@SCpnt: Pointer to Scsi_Cmnd structure, IO to be aborted
+ *
+ *	(linux Scsi_Host_Template.abort routine)
+ *
+ *	Returns SCSI_ABORT_{SUCCESS,BUSY,PENDING}.
+ */
+int
+mptscsih_old_abort(Scsi_Cmnd *SCpnt)
+{
+	MPT_SCSI_HOST		*hd;
+	MPT_FRAME_HDR		*mf;
+	struct tq_struct	*ptaskfoo;
+	unsigned long		 flags;
+	int			 scpnt_idx;
+
+	printk(KERN_WARNING MYNAM ": OldAbort scheduling ABORT SCSI IO (sc=%p)\n", SCpnt);
+	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
+
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
+		printk(KERN_WARNING "  WARNING - OldAbort, NULL hostdata ptr!!\n");
+		SCpnt->result = DID_ERROR << 16;
+		SCpnt->scsi_done(SCpnt);
+		return SCSI_ABORT_NOT_RUNNING;
+	}
+
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup.
+		 * If found in doneQ, delete from Q.
+		 * Do OS callback.
+		 */
+		search_doneQ_for_cmd(hd, SCpnt);
+
+		SCpnt->result = DID_RESET << 16;
+		SCpnt->scsi_done(SCpnt);
+		return SCSI_ABORT_SUCCESS;
+	} else {
+		/* If this command is pended, then timeout/hang occurred
+		 * during DV. Force bus reset by posting command to F/W
+		 * and then following up with the reset request.
+		 */
+		if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+			post_pendingQ_commands(hd);
+		}
+	}
+
+	/*
+	 *  Check to see if there's already an ABORT queued for this guy.
+	 */
+	mf = search_taskQ(0, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
+	if (mf != NULL) {
+		dtmprintk((MYIOC_s_INFO_FMT "OldAbort:Abort Task PENDING cmd (%p) taskQ depth (%d)\n",
+			hd->ioc->name, SCpnt, hd->taskQcnt));
+		return SCSI_ABORT_PENDING;
+	}
+
+	// SJR - CHECKME - Can we avoid this here?
+	// (mpt_HardResetHandler has this check...)
+	/* If IOC is reloading FW, return PENDING.
+	 */
+	spin_lock_irqsave(&hd->ioc->diagLock, flags);
+	if (hd->ioc->diagPending) {
+		spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
+		return SCSI_ABORT_PENDING;
+	}
+	spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
+
+	/* If there are no message frames what should we do?
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
+		printk((KERN_WARNING "  WARNING - OldAbort, no msg frames!!\n"));
+		/* We are out of message frames!
+		 * Call the reset handler to do a FW reload.
+		 */
+		printk((KERN_WARNING " Reloading Firmware!!\n"));
+		if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+			printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
+		}
+		return SCSI_ABORT_PENDING;
+	}
+
+	/*
+	 *  Add ourselves to (end of) taskQ .
+	 *  Check to see if our _bh is running.  If NOT, schedule it.
+	 */
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	Q_ADD_TAIL(&hd->taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+	hd->taskQcnt++;
+	atomic_inc(&mpt_taskQdepth);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+
+	/* Save the original SCpnt mf pointer
+	 */
+	SCpnt->host_scribble = (u8 *) MPT_INDEX_2_MFPTR (hd->ioc, scpnt_idx);
+
+	/* For the time being, force bus reset on any abort
+	 * requests for the 1030 FW.
+	 */
+	if (hd->is_spi)
+		mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
+	else
+		mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK;
+
+	mf->u.frame.linkage.argp1 = SCpnt;
+	mf->u.frame.linkage.argp2 = (void *) hd;
+
+	dtmprintk((MYIOC_s_INFO_FMT "OldAbort:_bh_handler state (%d) taskQ count (%d)\n",
+		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
+
+	if (! mytaskQ_bh_active) {
+		mytaskQ_bh_active = 1;
+		/*
+		 *  Oh how cute, no alloc/free/mgmt needed if we use
+		 *  (bottom/unused portion of) MPT request frame.
+		 */
+		ptaskfoo = (struct tq_struct *) &mptscsih_ptaskfoo;
+		ptaskfoo->sync = 0;
+		ptaskfoo->routine = mptscsih_taskmgmt_bh;
+		ptaskfoo->data = SCpnt;
+
+		SCHEDULE_TASK(ptaskfoo);
+	}
+	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+
+	return SCSI_ABORT_PENDING;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_old_reset - Perform a SCSI BUS_RESET!
+ *	@SCpnt: Pointer to Scsi_Cmnd structure, IO which reset is due to
+ *	@reset_flags: (not used?)
+ *
+ *	(linux Scsi_Host_Template.reset routine)
+ *
+ *	Returns SCSI_RESET_{SUCCESS,PUNT,PENDING}.
+ */
+int
+mptscsih_old_reset(Scsi_Cmnd *SCpnt, unsigned int reset_flags)
+{
+	MPT_SCSI_HOST		*hd;
+	MPT_FRAME_HDR		*mf;
+	struct tq_struct	*ptaskfoo;
+	unsigned long		 flags;
+	int			 scpnt_idx;
+
+	printk(KERN_WARNING MYNAM ": OldReset scheduling BUS_RESET (sc=%p)\n", SCpnt);
+	printk(KERN_WARNING "  IOs outstanding = %d\n", atomic_read(&queue_depth));
+
+	if ((hd = (MPT_SCSI_HOST *) SCpnt->host->hostdata) == NULL) {
+		SCpnt->result = DID_RESET << 16;
+		SCpnt->scsi_done(SCpnt);
+		return SCSI_RESET_SUCCESS;
+	}
+
+	if ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(SCpnt)) < 0) {
+		/* Cmd not found in ScsiLookup.
+		 * If found in doneQ, delete from Q.
+		 * Do OS callback.
+		 */
+		search_doneQ_for_cmd(hd, SCpnt);
+
+		SCpnt->result = DID_RESET << 16;
+		SCpnt->scsi_done(SCpnt);
+		return SCSI_RESET_SUCCESS;
+	} else {
+		/* If this command is pended, then timeout/hang occurred
+		 * during DV. Force bus reset by posting command to F/W
+		 * and then following up with the reset request.
+		 */
+		if ((mf = mptscsih_search_pendingQ(hd, scpnt_idx)) != NULL) {
+			mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+			post_pendingQ_commands(hd);
+		}
+	}
+
+	/*
+	 *  Check to see if there's an ABORT_TASK queued for this guy.
+	 *  If so, delete.
+	 */
+	search_taskQ(1, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK);
+
+	/*
+	 *  Check to see if there's already a BUS_RESET queued for this guy.
+	 */
+	mf = search_taskQ(0, SCpnt, hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS);
+	if (mf != NULL) {
+		dtmprintk((MYIOC_s_INFO_FMT "OldReset:Reset Task PENDING cmd (%p) taskQ depth (%d)\n",
+			hd->ioc->name, SCpnt, hd->taskQcnt));
+		return SCSI_RESET_PENDING;
+	}
+
+	// SJR - CHECKME - Can we avoid this here?
+	// (mpt_HardResetHandler has this check...)
+	/* If IOC is reloading FW, return PENDING.
+	 */
+	spin_lock_irqsave(&hd->ioc->diagLock, flags);
+	if (hd->ioc->diagPending) {
+		spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
+		return SCSI_RESET_PENDING;
+	}
+	spin_unlock_irqrestore(&hd->ioc->diagLock, flags);
+
+	if ((mf = mpt_get_msg_frame(ScsiTaskCtx, hd->ioc->id)) == NULL) {
+		/* We are out of message frames!
+		 * Call the reset handler to do a FW reload.
+		 */
+		printk((KERN_WARNING " Reloading Firmware!!\n"));
+		if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+			printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
+		}
+		return SCSI_RESET_PENDING;
+	}
+
+	/*
+	 *  Add ourselves to (end of) taskQ.
+	 *  Check to see if our _bh is running.  If NOT, schedule it.
+	 */
+	spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+	Q_ADD_TAIL(&hd->taskQ, &mf->u.frame.linkage, MPT_FRAME_HDR);
+	hd->taskQcnt++;
+	atomic_inc(&mpt_taskQdepth);
+	spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+
+	/* Save the original SCpnt mf pointer
+	 */
+	SCpnt->host_scribble = (u8 *) MPT_INDEX_2_MFPTR (hd->ioc, scpnt_idx);
+
+	mf->u.frame.linkage.arg1 = MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS;
+	mf->u.frame.linkage.argp1 = SCpnt;
+	mf->u.frame.linkage.argp2 = (void *) hd;
+
+	dtmprintk((MYIOC_s_INFO_FMT "OldReset: _bh_handler state (%d) taskQ count (%d)\n",
+		hd->ioc->name, mytaskQ_bh_active, hd->taskQcnt));
+
+	if (! mytaskQ_bh_active) {
+		mytaskQ_bh_active = 1;
+		/*
+		 *  Oh how cute, no alloc/free/mgmt needed if we use
+		 *  (bottom/unused portion of) MPT request frame.
+		 */
+		ptaskfoo = (struct tq_struct *) &mptscsih_ptaskfoo;
+		ptaskfoo->sync = 0;
+		ptaskfoo->routine = mptscsih_taskmgmt_bh;
+		ptaskfoo->data = SCpnt;
+
+		SCHEDULE_TASK(ptaskfoo);
+	}
+	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+	return SCSI_RESET_PENDING;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_taskmgmt_bh - SCSI task mgmt bottom half handler
+ *	@sc: (unused)
+ *
+ *	This routine (thread) is active whenever there are any outstanding
+ *	SCSI task management requests for a SCSI host adapter.
+ *	IMPORTANT!  This routine is scheduled therefore should never be
+ *	running in ISR context.  i.e., it's safe to sleep here.
+ */
+void
+mptscsih_taskmgmt_bh(void *sc)
+{
+	MPT_ADAPTER	*ioc;
+	Scsi_Cmnd	*SCpnt;
+	MPT_FRAME_HDR	*mf = NULL;
+	MPT_SCSI_HOST	*hd;
+	u32		 ctx2abort = 0;
+	unsigned long	 flags;
+	int		 scpnt_idx;
+	int		 did;
+	u8		 task_type;
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+	mytaskQ_bh_active = 1;
+	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ/4);
+		did = 0;
+
+		for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc = mpt_adapter_find_next(ioc)) {
+			if (ioc->sh) {
+				hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+				if (hd == NULL) {
+					printk(KERN_ERR MYNAM
+							": ERROR - TaskMgmt NULL SCSI Host!"
+							"(ioc=%p, sh=%p hd=%p)\n",
+							ioc, ioc->sh, hd);
+					continue;
+				}
+
+				spin_lock_irqsave(&ioc->FreeQlock, flags);
+				if (Q_IS_EMPTY(&hd->taskQ)) {
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
+
+				/* If we ever find a non-empty queue,
+				 * keep the handler alive
+				 */
+				did++;
+
+				/* tmPending is SMP lock-protected */
+				if (hd->tmPending || hd->tmPtr) {
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
+				hd->tmPending = 1;
+
+				/* Process this request
+				 */
+                                mf = hd->taskQ.head;
+				Q_DEL_ITEM(&mf->u.frame.linkage);
+				hd->taskQcnt--;
+				atomic_dec(&mpt_taskQdepth);
+				spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+				SCpnt = (Scsi_Cmnd*)mf->u.frame.linkage.argp1;
+				if (SCpnt == NULL) {
+					printk(KERN_ERR MYNAM ": ERROR - TaskMgmt has NULL SCpnt! (mf=%p:sc=%p)\n",
+							mf, SCpnt);
+					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
+
+				/* Get the ScsiLookup index pointer
+				 * from the SC pointer.
+				 */
+				if (!SCpnt->host_scribble || ((MPT_SCSI_HOST *)SCpnt->host->hostdata != hd)) {
+					/* The command associated with the
+					 * abort/reset request must have
+					 * completed and this is a stale
+					 * request. We are done.
+					 * Free the current MF and continue.
+					 */
+					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
+
+				scpnt_idx = MFPTR_2_MPT_INDEX(hd->ioc, SCpnt->host_scribble);
+				if (scpnt_idx != SCPNT_TO_LOOKUP_IDX(SCpnt)) {
+					/* Error! this should never happen!!
+					 */
+					mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					continue;
+				}
+
+				task_type = mf->u.frame.linkage.arg1;
+				ctx2abort = 0;
+				if (task_type == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {
+					MPT_FRAME_HDR	*SCpntMf;
+
+					/*
+					 * Most important!  Set TaskMsgContext to SCpnt's MsgContext!
+					 * (the IO to be ABORT'd)
+					 *
+					 * NOTE: Since we do not byteswap MsgContext, we do not
+					 *	 swap it here either.  It is an opaque cookie to
+					 *	 the controller, so it does not matter. -DaveM
+					 */
+					SCpntMf = (MPT_FRAME_HDR *) SCpnt->host_scribble;
+					ctx2abort = SCpntMf->u.frame.hwhdr.msgctxu.MsgContext;
+
+					hd->abortSCpnt = SCpnt;
+					printk(KERN_WARNING MYNAM ": Attempting ABORT SCSI IO! (mf=%p:sc=%p)\n",
+							mf, SCpnt);
+				}
+
+				/* The TM handler will allocate a new mf,
+				 * so free the current mf.
+				 */
+				mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+				mf = NULL;
+
+				if (mptscsih_TMHandler(hd, task_type, SCpnt->target, SCpnt->lun, ctx2abort, NO_SLEEP) < 0) {
+
+					/* The TM request failed and the subsequent FW-reload failed!
+					 * Fatal error case.
+					 */
+					printk(KERN_WARNING MYNAM
+						": WARNING[1] - IOC error processing TaskMgmt request (sc=%p)\n", SCpnt);
+
+					if (hd->ScsiLookup[scpnt_idx] != NULL) {
+						atomic_dec(&queue_depth);
+						SCpnt->result = DID_SOFT_ERROR << 16;
+						spin_lock_irqsave(&io_request_lock, flags);
+						SCpnt->scsi_done(SCpnt);
+						spin_unlock_irqrestore(&io_request_lock, flags);
+						mpt_free_msg_frame(ScsiTaskCtx, hd->ioc->id, mf);
+					}
+					spin_lock_irqsave(&ioc->FreeQlock, flags);
+					hd->tmPending = 0;
+					spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+					hd->abortSCpnt = NULL;
+				}
+			}
+		}
+		if (atomic_read(&mpt_taskQdepth) > 0)
+			did++;
+
+	} while ( did );
+
+	spin_lock_irqsave(&mytaskQ_lock, flags);
+	mytaskQ_bh_active = 0;
+	spin_unlock_irqrestore(&mytaskQ_lock, flags);
+
+	return;
+}
+#endif		/* } */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_taskmgmt_complete - Registered with Fusion MPT base driver
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@mf: Pointer to SCSI task mgmt request frame
+ *	@mr: Pointer to SCSI task mgmt reply frame
+ *
+ *	This routine is called from mptbase.c::mpt_interrupt() at the completion
+ *	of any SCSI task management request.
+ *	This routine is registered with the MPT (base) driver at driver
+ *	load/init time via the mpt_register() API call.
+ *
+ *	Returns 1 indicating alloc'd request frame ptr should be freed.
+ */
+static int
+mptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
+{
+	SCSITaskMgmtReply_t	*pScsiTmReply;
+	SCSITaskMgmt_t		*pScsiTmReq;
+	MPT_SCSI_HOST		*hd = NULL;
+	unsigned long		 flags;
+	u8			 tmType = 0;
+
+	dtmprintk((MYIOC_s_INFO_FMT "SCSI TaskMgmt completed (mf=%p,r=%p)\n",
+			ioc->name, mf, mr));
+	if (ioc->sh) {
+		/* Depending on the thread, a timer is activated for
+		 * the TM request.  Delete this timer on completion of TM.
+		 * Decrement count of outstanding TM requests.
+		 */
+		hd = (MPT_SCSI_HOST *)ioc->sh->hostdata;
+		if (hd->tmPtr) {
+			del_timer(&hd->TMtimer);
+		}
+		dtmprintk((MYIOC_s_INFO_FMT "taskQcnt (%d)\n",
+			ioc->name, hd->taskQcnt));
+	} else {
+		dtmprintk((MYIOC_s_WARN_FMT "TaskMgmt Complete: NULL Scsi Host Ptr\n",
+			ioc->name));
+		return 1;
+	}
+
+	if (mr == NULL) {
+		dtmprintk((MYIOC_s_WARN_FMT "ERROR! TaskMgmt Reply: NULL Request %p\n",
+			ioc->name, mf));
+		return 1;
+	} else {
+		pScsiTmReply = (SCSITaskMgmtReply_t*)mr;
+		pScsiTmReq = (SCSITaskMgmt_t*)mf;
+
+		/* Figure out if this was ABORT_TASK, TARGET_RESET, or BUS_RESET! */
+		tmType = pScsiTmReq->TaskType;
+
+		dtmprintk((KERN_INFO "  TaskType = %d, TerminationCount=%d\n",
+				tmType, le32_to_cpu(pScsiTmReply->TerminationCount)));
+
+		/* Error?  (anything non-zero?) */
+		if (*(u32 *)&pScsiTmReply->Reserved2[0]) {
+			u16	 iocstatus;
+
+			iocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+			dtmprintk((KERN_INFO "  SCSI TaskMgmt (%d) - Oops!\n", tmType));
+			dtmprintk((KERN_INFO "  IOCStatus = %04xh\n", iocstatus));
+			dtmprintk((KERN_INFO "  IOCLogInfo = %08xh\n",
+				 le32_to_cpu(pScsiTmReply->IOCLogInfo)));
+
+			/* clear flags and continue.
+			 */
+			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK)
+				hd->abortSCpnt = NULL;
+#ifdef	DROP_TEST
+			if (dropMfPtr)
+				dropTestBad++;
+#endif
+			/* If an internal command is present
+			 * or the TM failed - reload the FW.
+			 * FC FW may respond FAILED to an ABORT
+			 */
+			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) {
+				if ((hd->cmdPtr) ||
+				    (iocstatus == MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED)) {
+					if (mpt_HardResetHandler(ioc, NO_SLEEP) < 0) {
+						printk((KERN_WARNING
+							" Firmware Reload FAILED!!\n"));
+					}
+				}
+			}
+		} else {
+			dtmprintk((KERN_INFO "  SCSI TaskMgmt SUCCESS!\n"));
+
+#ifndef MPT_SCSI_USE_NEW_EH
+			if (tmType == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS) {
+				/* clean taskQ - remove tasks associated with
+				 * completed commands.
+				 */
+				clean_taskQ(hd);
+			} else if (tmType == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {
+				/* If taskQ contains another request
+				 * for this SCpnt, delete this request.
+				 */
+				search_taskQ_for_cmd(hd->abortSCpnt, hd);
+			}
+#endif
+			hd->numTMrequests--;
+			hd->abortSCpnt = NULL;
+			flush_doneQ(hd);
+
+#ifdef	DROP_TEST
+			if (dropMfPtr)
+				dropTestOK++;
+#endif
+		}
+	}
+
+#ifdef	DROP_TEST
+	{
+		Scsi_Cmnd	*sc;
+		unsigned long	 flags;
+		u16		 req_idx;
+
+		/* Free resources for the drop test MF and chain buffers.
+		 */
+		if (dropMfPtr) {
+			req_idx = le16_to_cpu(dropMfPtr->u.frame.hwhdr.msgctxu.fld.req_idx);
+			sc = hd->ScsiLookup[req_idx];
+			if (sc == NULL) {
+				printk(MYIOC_s_ERR_FMT
+					"Drop Test: NULL ScsiCmd ptr!\n",
+					ioc->name);
+			} else {
+				sc->host_scribble = NULL;
+				if (tmType == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)
+					sc->result = DID_RESET << 16;
+				else
+					sc->result = DID_ABORT << 16;
+
+				hd->ScsiLookup[req_idx] = NULL;
+				atomic_dec(&queue_depth);
+				spin_lock_irqsave(&io_request_lock, flags);
+				sc->scsi_done(sc);	/* Issue callback */
+				spin_unlock_irqrestore(&io_request_lock, flags);
+
+				mptscsih_freeChainBuffers(hd, req_idx);
+				mpt_free_msg_frame(ScsiDoneCtx, ioc->id, dropMfPtr);
+
+				printk(MYIOC_s_INFO_FMT
+						"Free'd Dropped cmd (%p)\n",
+						hd->ioc->name, sc);
+				printk(MYIOC_s_INFO_FMT
+						"mf (%p) reqidx (%4x)\n",
+						hd->ioc->name, dropMfPtr,
+						req_idx);
+				printk(MYIOC_s_INFO_FMT
+					"Num Tot (%d) Good (%d) Bad (%d) \n",
+					hd->ioc->name, dropTestNum,
+					dropTestOK, dropTestBad);
+			}
+			dropMfPtr = NULL;
+		}
+	}
+#endif
+
+#ifndef MPT_SCSI_USE_NEW_EH
+	/*
+	 *  Signal to _bh thread that we finished.
+	 *  This IOC can now process another TM command.
+	 */
+	dtmprintk((MYIOC_s_INFO_FMT "taskmgmt_complete: (=%p) done! Num Failed(%d) Task Count (%d)\n",
+			ioc->name, mf, hd->numTMrequests, hd->taskQcnt));
+#endif
+	hd->tmPtr = NULL;
+	spin_lock_irqsave(&ioc->FreeQlock, flags);
+	hd->tmPending = 0;
+	spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+
+	return 1;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	This is anyones guess quite frankly.
+ */
+
+int
+mptscsih_bios_param(Disk * disk, kdev_t dev, int *ip)
+{
+	int size;
+
+	size = disk->capacity;
+	ip[0] = 64;				/* heads			*/
+	ip[1] = 32;				/* sectors			*/
+	if ((ip[2] = size >> 11) > 1024) {	/* cylinders, test for big disk */
+		ip[0] = 255;			/* heads			*/
+		ip[1] = 63;			/* sectors			*/
+		ip[2] = size / (255 * 63);	/* cylinders			*/
+	}
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	OS entry point to adjust the queue_depths on a per-device basis.
+ *	Called once per device the bus scan. Use it to force the queue_depth
+ *	member to 1 if a device does not support Q tags.
+ */
+void
+mptscsih_select_queue_depths(struct Scsi_Host *sh, Scsi_Device *sdList)
+{
+	struct scsi_device	*device;
+	VirtDevice		*pTarget;
+	MPT_SCSI_HOST		*hd;
+	int			 ii, max;
+
+	for (device = sdList; device; device = device->next) {
+
+		if (device->host != sh)
+			continue;
+
+		hd = (MPT_SCSI_HOST *) sh->hostdata;
+		if (!hd)
+			continue;
+
+		if (hd->Targets) {
+			if (hd->is_spi)
+				max = MPT_MAX_SCSI_DEVICES;
+			else
+				max = MPT_MAX_FC_DEVICES;
+
+			for (ii=0; ii < max; ii++) {
+				pTarget = hd->Targets[ii];
+				if (pTarget && !(pTarget->tflags & MPT_TARGET_FLAGS_Q_YES)) {
+					device->queue_depth = 1;
+				}
+			}
+		}
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Private routines...
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* 19991030 -sralston
+ *  Return absolute SCSI data direction:
+ *     1 = _DATA_OUT
+ *     0 = _DIR_NONE
+ *    -1 = _DATA_IN
+ */
+static int
+mptscsih_io_direction(Scsi_Cmnd *cmd)
+{
+	switch (cmd->cmnd[0]) {
+	/*  _DATA_OUT commands	*/
+	case WRITE_6:		case WRITE_10:		case WRITE_12:
+	case WRITE_LONG:	case WRITE_SAME:	case WRITE_BUFFER:
+	case WRITE_VERIFY:	case WRITE_VERIFY_12:
+	case COMPARE:		case COPY:		case COPY_VERIFY:
+	case SEARCH_EQUAL:	case SEARCH_HIGH:	case SEARCH_LOW:
+	case SEARCH_EQUAL_12:	case SEARCH_HIGH_12:	case SEARCH_LOW_12:
+	case MODE_SELECT:	case MODE_SELECT_10:	case LOG_SELECT:
+	case SEND_DIAGNOSTIC:	case CHANGE_DEFINITION: case UPDATE_BLOCK:
+	case SET_WINDOW:	case MEDIUM_SCAN:	case SEND_VOLUME_TAG:
+	case REASSIGN_BLOCKS:
+	case PERSISTENT_RESERVE_OUT:
+	case 0xea:
+	case 0xa3:
+		return 1;
+
+	/*  No data transfer commands  */
+	case SEEK_6:		case SEEK_10:
+	case RESERVE:		case RELEASE:
+	case TEST_UNIT_READY:
+	case START_STOP:
+	case ALLOW_MEDIUM_REMOVAL:
+		return 0;
+
+	/*  Conditional data transfer commands	*/
+	case FORMAT_UNIT:
+		if (cmd->cmnd[1] & 0x10)	/* FmtData (data out phase)? */
+			return 1;
+		else
+			return 0;
+
+	case VERIFY:
+		if (cmd->cmnd[1] & 0x02)	/* VERIFY:BYTCHK (data out phase)? */
+			return 1;
+		else
+			return 0;
+
+	case RESERVE_10:
+		if (cmd->cmnd[1] & 0x03)	/* RESERVE:{LongID|Extent} (data out phase)? */
+			return 1;
+		else
+			return 0;
+
+#if 0
+	case REZERO_UNIT:	/* (or REWIND) */
+	case SPACE:
+	case ERASE:		case ERASE_10:
+	case SYNCHRONIZE_CACHE:
+	case LOCK_UNLOCK_CACHE:
+#endif
+
+	/*  Must be data _IN!  */
+	default:
+		return -1;
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Utility function to copy sense data from the scsi_cmnd buffer
+ * to the FC and SCSI target structures.
+ *
+ */
+static void
+copy_sense_data(Scsi_Cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply)
+{
+	VirtDevice	*target;
+	SCSIIORequest_t	*pReq;
+	u32		 sense_count = le32_to_cpu(pScsiReply->SenseCount);
+	int		 index;
+	char		 devFoo[96];
+	IO_Info_t	 thisIo;
+
+	/* Get target structure
+	 */
+	pReq = (SCSIIORequest_t *) mf;
+	index = (int) pReq->TargetID;
+	target = hd->Targets[index];
+	if (hd->is_multipath && sc->device->hostdata)
+		target = (VirtDevice *) sc->device->hostdata;
+
+	if (sense_count) {
+		u8 *sense_data;
+		int req_index;
+
+		/* Copy the sense received into the scsi command block. */
+		req_index = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+		sense_data = ((u8 *)hd->ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));
+		memcpy(sc->sense_buffer, sense_data, SNS_LEN(sc));
+
+		/* save sense data to the target device
+		 */
+		if (target) {
+			int sz;
+
+			sz = MIN(pReq->SenseBufferLength, sense_count);
+			if (sz > SCSI_STD_SENSE_BYTES)
+				sz =  SCSI_STD_SENSE_BYTES;
+			memcpy(target->sense, sense_data, sz);
+			target->tflags |= MPT_TARGET_FLAGS_VALID_SENSE;
+		}
+
+		/* Log SMART data (asc = 0x5D, non-IM case only) if required.
+		 */
+		if ((hd->ioc->events) && (hd->ioc->eventTypes & (1 << MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE))) {
+			if ((sense_data[12] == 0x5D) && (target->raidVolume == 0)) {
+				int idx;
+				MPT_ADAPTER *ioc = hd->ioc;
+
+				idx = ioc->eventContext % ioc->eventLogSize;
+				ioc->events[idx].event = MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE;
+				ioc->events[idx].eventContext = ioc->eventContext;
+
+				ioc->events[idx].data[0] = (pReq->LUN[1] << 24) ||
+					(MPI_EVENT_SCSI_DEV_STAT_RC_SMART_DATA << 16) ||
+					(pReq->Bus << 8) || pReq->TargetID;
+
+				ioc->events[idx].data[1] = (sense_data[13] << 8) || sense_data[12];
+
+				ioc->eventContext++;
+			}
+		}
+
+		/* Print an error report for the user.
+		 */
+		thisIo.cdbPtr = sc->cmnd;
+		thisIo.sensePtr = sc->sense_buffer;
+		thisIo.SCSIStatus = pScsiReply->SCSIStatus;
+		thisIo.DoDisplay = 1;
+		if (hd->is_multipath)
+			sprintf(devFoo, "%d:%d:%d \"%s\"",
+					hd->ioc->id,
+					pReq->TargetID,
+					pReq->LUN[1],
+					target->dev_vol_name);
+		else
+			sprintf(devFoo, "%d:%d:%d", hd->ioc->id, sc->target, sc->lun);
+		thisIo.DevIDStr = devFoo;
+/* fubar */
+		thisIo.dataPtr = NULL;
+		thisIo.inqPtr = NULL;
+		if (sc->device) {
+			thisIo.inqPtr = sc->device->vendor-8;	/* FIXME!!! */
+		}
+		(void) mpt_ScsiHost_ErrorReport(&thisIo);
+
+	} else {
+		dprintk((MYIOC_s_INFO_FMT "Hmmm... SenseData len=0! (?)\n",
+				hd->ioc->name));
+	}
+
+	return;
+}
+
+static u32
+SCPNT_TO_LOOKUP_IDX(Scsi_Cmnd *sc)
+{
+	MPT_SCSI_HOST *hd;
+	int i;
+
+	hd = (MPT_SCSI_HOST *) sc->host->hostdata;
+
+	for (i = 0; i < hd->ioc->req_depth; i++) {
+		if (hd->ScsiLookup[i] == sc) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+/* see mptscsih.h */
+
+#ifdef MPT_SCSIHOST_NEED_ENTRY_EXIT_HOOKUPS
+	static Scsi_Host_Template driver_template = MPT_SCSIHOST;
+#	include "../../scsi/scsi_module.c"
+#endif
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* Search the pendingQ for a command with specific index.
+ * If found, delete and return mf pointer  
+ * If not found, return NULL
+ */
+static MPT_FRAME_HDR *
+mptscsih_search_pendingQ(MPT_SCSI_HOST *hd, int scpnt_idx)
+{
+	unsigned long	 flags;
+	MPT_DONE_Q	*buffer;
+	MPT_FRAME_HDR	*mf = NULL;
+	MPT_FRAME_HDR	*cmdMfPtr = NULL;
+
+	ddvtprintk((MYIOC_s_INFO_FMT ": search_pendingQ called...", hd->ioc->name));
+	cmdMfPtr = MPT_INDEX_2_MFPTR(hd->ioc, scpnt_idx);
+	spin_lock_irqsave(&hd->freedoneQlock, flags);
+	if (!Q_IS_EMPTY(&hd->pendingQ)) {
+		buffer = hd->pendingQ.head;
+		do {
+			mf = (MPT_FRAME_HDR *) buffer->argp;
+			if (mf == cmdMfPtr) {
+				Q_DEL_ITEM(buffer);
+
+				/* clear the arg pointer
+				 */
+				buffer->argp = NULL;
+
+				/* Add to the freeQ
+				 */
+				Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+				break;
+			}
+			mf = NULL;
+		} while ((buffer = buffer->forw) != (MPT_DONE_Q *) &hd->pendingQ);
+	}
+	spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+	ddvtprintk((" ...return %p\n", mf));
+	return mf;
+}
+
+/* Post all commands on the pendingQ to the FW.
+ * Lock Q when deleting/adding members
+ * Lock io_request_lock for OS callback.
+ */
+static void
+post_pendingQ_commands(MPT_SCSI_HOST *hd)
+{
+	MPT_FRAME_HDR	*mf;
+	MPT_DONE_Q	*buffer;
+	unsigned long	 flags;
+
+	/* Flush the pendingQ.
+	 */
+	ddvtprintk((MYIOC_s_INFO_FMT ": post_pendingQ_commands called\n", hd->ioc->name));
+	while (1) {
+		spin_lock_irqsave(&hd->freedoneQlock, flags);
+		if (Q_IS_EMPTY(&hd->pendingQ)) {
+			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			break;
+		}
+
+		buffer = hd->pendingQ.head;
+		/* Delete from Q
+		 */
+		Q_DEL_ITEM(buffer);
+
+		mf = (MPT_FRAME_HDR *) buffer->argp;
+		if (!mf) {
+			/* This should never happen */
+			printk(MYIOC_s_WARN_FMT "post_pendingQ_commands: mf %p\n", hd->ioc->name, mf);
+			spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+			continue;
+		}
+
+		mptscsih_put_msgframe(ScsiDoneCtx, hd->ioc->id, mf);
+		ddvtprintk((MYIOC_s_INFO_FMT "Issued SCSI cmd (mf=%p)\n",
+				hd->ioc->name, mf));
+
+		buffer->argp = NULL;
+
+		/* Add to the freeQ
+		 */
+		Q_ADD_TAIL(&hd->freeQ.head, buffer, MPT_DONE_Q);
+		spin_unlock_irqrestore(&hd->freedoneQlock, flags);
+	}
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+mptscsih_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)
+{
+	MPT_SCSI_HOST	*hd = NULL;
+	unsigned long	 flags;
+
+	dtmprintk((KERN_WARNING MYNAM
+			": IOC %s_reset routed to SCSI host driver!\n",
+			reset_phase==MPT_IOC_PRE_RESET ? "pre" : "post"));
+
+	/* If a FW reload request arrives after base installed but
+	 * before all scsi hosts have been attached, then an alt_ioc
+	 * may have a NULL sh pointer.
+	 */
+	if ((ioc->sh == NULL) || (ioc->sh->hostdata == NULL))
+		return 0;
+	else
+		hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+
+	if (reset_phase == MPT_IOC_PRE_RESET) {
+		dtmprintk((MYIOC_s_WARN_FMT "Do Pre-Diag Reset handling\n",
+			ioc->name));
+
+		/* Clean Up:
+		 * 1. Set Hard Reset Pending Flag
+		 * All new commands go to doneQ
+		 */
+		hd->resetPending = 1;
+
+		/* 2. Flush running commands
+		 *	Clean drop test code - if compiled
+		 *	Clean ScsiLookup (and associated memory)
+		 *	AND clean mytaskQ
+		 */
+
+		/* 2a. Drop Test Command.
+		 */
+#ifdef	DROP_TEST
+		{
+			Scsi_Cmnd	*sc;
+			unsigned long	 flags;
+			u16		 req_idx;
+
+			/* Free resources for the drop test MF
+			 * and chain buffers.
+			 */
+			if (dropMfPtr) {
+				req_idx = le16_to_cpu(dropMfPtr->u.frame.hwhdr.msgctxu.fld.req_idx);
+				sc = hd->ScsiLookup[req_idx];
+				if (sc == NULL) {
+					printk(MYIOC_s_ERR_FMT
+					"Drop Test: NULL ScsiCmd ptr!\n",
+					ioc->name);
+				} else {
+					sc->host_scribble = NULL;
+					sc->result = DID_RESET << 16;
+					hd->ScsiLookup[req_idx] = NULL;
+					atomic_dec(&queue_depth);
+					spin_lock_irqsave(&io_request_lock, flags);
+					sc->scsi_done(sc);	/* Issue callback */
+					spin_unlock_irqrestore(&io_request_lock, flags);
+				}
+
+				mptscsih_freeChainBuffers(hd, req_idx);
+				mpt_free_msg_frame(ScsiDoneCtx, ioc->id, dropMfPtr);
+				printk(MYIOC_s_INFO_FMT
+						"Free'd: mf (%p) reqidx (%4x)\n",
+						hd->ioc->name, dropMfPtr,
+						req_idx);
+			}
+			dropMfPtr = NULL;
+		}
+#endif
+
+		/* 2b. Reply to OS all known outstanding I/O commands.
+		 */
+		mptscsih_flush_running_cmds(hd);
+
+		/* 2c. If there was an internal command that
+		 * has not completed, configuration or io request,
+		 * free these resources.
+		 */
+		if (hd->cmdPtr) {
+			del_timer(&hd->timer);
+			mpt_free_msg_frame(ScsiScanDvCtx, ioc->id, hd->cmdPtr);
+			atomic_dec(&queue_depth);
+		}
+
+		/* 2d. If a task management has not completed,
+		 * free resources associated with this request.
+		 */
+		if (hd->tmPtr) {
+			del_timer(&hd->TMtimer);
+			mpt_free_msg_frame(ScsiTaskCtx, ioc->id, hd->tmPtr);
+		}
+
+#ifndef MPT_SCSI_USE_NEW_EH
+		/* 2e. Delete all commands on taskQ
+		 * Should be superfluous - as this taskQ should
+		 * be empty.
+		 */
+		clean_taskQ(hd);
+#endif
+		dtmprintk((MYIOC_s_WARN_FMT "Pre-Reset handling complete.\n",
+			ioc->name));
+
+	} else {
+		dtmprintk((MYIOC_s_WARN_FMT "Do Post-Diag Reset handling\n",
+			ioc->name));
+
+		/* Once a FW reload begins, all new OS commands are
+		 * redirected to the doneQ w/ a reset status.
+		 * Init all control structures.
+		 */
+
+		/* ScsiLookup initialization
+		 */
+		{
+			int ii;
+			for (ii=0; ii < hd->ioc->req_depth; ii++)
+				hd->ScsiLookup[ii] = NULL;
+		}
+
+		/* 2. Chain Buffer initialization
+		 */
+		mptscsih_initChainBuffers(hd, 0);
+
+		/* 3. tmPtr clear
+		 */
+		if (hd->tmPtr) {
+			hd->tmPtr = NULL;
+		}
+
+		/* 4. Renegotiate to all devices, if SCSI
+		 */
+		if (hd->is_spi)
+			mptscsih_writeSDP1(hd, 0, 0, MPT_SCSICFG_ALL_IDS | MPT_SCSICFG_USE_NVRAM);
+
+		/* 5. Enable new commands to be posted
+		 */
+		spin_lock_irqsave(&ioc->FreeQlock, flags);
+		hd->tmPending = 0;
+		spin_unlock_irqrestore(&ioc->FreeQlock, flags);
+		hd->resetPending = 0;
+		hd->numTMrequests = 0;
+
+		/* 6. If there was an internal command,
+		 * wake this process up.
+		 */
+		if (hd->cmdPtr) {
+			/*
+			 * Wake up the original calling thread
+			 */
+			hd->pLocal = &hd->localReply;
+			hd->pLocal->completion = MPT_SCANDV_DID_RESET;
+			scandv_wait_done = 1;
+			wake_up(&scandv_waitq);
+			hd->cmdPtr = NULL;
+		}
+
+		/* 7. Flush doneQ
+		 */
+		flush_doneQ(hd);
+
+		dtmprintk((MYIOC_s_WARN_FMT "Post-Reset handling complete.\n",
+			ioc->name));
+	}
+
+	return 1;		/* currently means nothing really */
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+mptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)
+{
+	MPT_SCSI_HOST *hd;
+	u8 event = le32_to_cpu(pEvReply->Event) & 0xFF;
+
+	dprintk((MYIOC_s_INFO_FMT "MPT event (=%02Xh) routed to SCSI host driver!\n",
+			ioc->name, event));
+
+	switch (event) {
+	case MPI_EVENT_UNIT_ATTENTION:			/* 03 */
+		/* FIXME! */
+		break;
+	case MPI_EVENT_IOC_BUS_RESET:			/* 04 */
+		/* FIXME! */
+		break;
+	case MPI_EVENT_EXT_BUS_RESET:			/* 05 */
+		/* FIXME! */
+		break;
+	case MPI_EVENT_LOGOUT:				/* 09 */
+		/* FIXME! */
+		break;
+
+		/*
+		 *  CHECKME! Don't think we need to do
+		 *  anything for these, but...
+		 */
+	case MPI_EVENT_RESCAN:				/* 06 */
+	case MPI_EVENT_LINK_STATUS_CHANGE:		/* 07 */
+	case MPI_EVENT_LOOP_STATE_CHANGE:		/* 08 */
+		/*
+		 *  CHECKME!  Falling thru...
+		 */
+
+	case MPI_EVENT_INTEGRATED_RAID:			/* 0B */
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+		/* negoNvram set to 0 if DV enabled and to USE_NVRAM if 
+		 * if DV disabled
+		 */
+		hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+		if (hd->negoNvram == 0) {
+			ScsiCfgData	*pSpi;
+			Ioc3PhysDisk_t	*pPDisk;
+			int		 numPDisk;
+			u8		 reason;
+			u8		 physDiskNum;
+			
+			reason = (le32_to_cpu(pEvReply->Data[0]) & 0x00FF0000) >> 16;
+			if (reason == MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED) {
+				/* New or replaced disk. 
+				 * Set DV flag and schedule DV.
+				 */
+				pSpi = &ioc->spi_data;
+				physDiskNum = (le32_to_cpu(pEvReply->Data[0]) & 0xFF000000) >> 24;
+				if (pSpi->pIocPg3) {
+					pPDisk =  pSpi->pIocPg3->PhysDisk;
+					numPDisk =pSpi->pIocPg3->NumPhysDisks;
+
+					while (numPDisk) {
+						if (physDiskNum == pPDisk->PhysDiskNum) {
+							pSpi->dvStatus[pPDisk->PhysDiskID] = MPT_SCSICFG_NEED_DV;
+							pSpi->forceDv = MPT_SCSICFG_NEED_DV;
+							ddvtprintk(("NEED_DV set for phys disk id %d\n", pPDisk->PhysDiskID));
+							break;
+						}
+						pPDisk++;
+						numPDisk--;
+					}
+				}
+			}
+		}
+#endif
+
+#if defined(MPT_DEBUG_DV) || defined(MPT_DEBUG_DV_TINY)
+		printk("Raid Event RF: ");
+		{
+			u32 *m = (u32 *)pEvReply;
+			int ii;
+			int n = (int)pEvReply->MsgLength;
+			for (ii=6; ii < n; ii++)
+				printk(" %08x", le32_to_cpu(m[ii]));
+			printk("\n");
+		}
+#endif
+		break;
+
+	case MPI_EVENT_NONE:				/* 00 */
+	case MPI_EVENT_LOG_DATA:			/* 01 */
+	case MPI_EVENT_STATE_CHANGE:			/* 02 */
+	case MPI_EVENT_EVENT_CHANGE:			/* 0A */
+	default:
+		dprintk((KERN_INFO "  Ignoring event (=%02Xh)\n", event));
+		break;
+	}
+
+	return 1;		/* currently means nothing really */
+}
+
+#if 0		/* { */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	scsiherr.c - Fusion MPT SCSI Host driver error handling/reporting.
+ *
+ *	drivers/message/fusion/scsiherr.c
+ */
+
+//extern const char	**mpt_ScsiOpcodesPtr;	/* needed by mptscsih.c */
+//extern ASCQ_Table_t	 *mpt_ASCQ_TablePtr;
+//extern int		  mpt_ASCQ_TableSz;
+
+#define MYNAM	"mptscsih"
+
+#endif		/* } */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Private data...
+ */
+static ASCQ_Table_t *mptscsih_ASCQ_TablePtr;
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/* old symsense.c stuff... */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Private data...
+ * To protect ourselves against those that would pass us bogus pointers
+ */
+static u8 dummyInqData[SCSI_STD_INQUIRY_BYTES]
+    = { 0x1F, 0x00, 0x00, 0x00,
+	0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static u8 dummySenseData[SCSI_STD_SENSE_BYTES]
+    = { 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00 };
+static u8 dummyCDB[16]
+    = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static u8 dummyScsiData[16]
+    = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+#if 0
+static const char *PeripheralDeviceTypeString[32] = {
+	"Direct-access",		/* 00h */
+	"Sequential-access",		/* 01h */
+	"Printer",			/* 02h */
+	"Processor",			/* 03h */
+			/*"Write-Once-Read-Multiple",*/	/* 04h */
+	"WORM",				/* 04h */
+	"CD-ROM",			/* 05h */
+	"Scanner",			/* 06h */
+	"Optical memory",		/* 07h */
+	"Media Changer",		/* 08h */
+	"Communications",		/* 09h */
+	"(Graphics arts pre-press)",	/* 0Ah */
+	"(Graphics arts pre-press)",	/* 0Bh */
+	"Array controller",		/* 0Ch */
+	"Enclosure services",		/* 0Dh */
+	"Simplified direct-access",	/* 0Eh */
+	"Reserved-0Fh",			/* 0Fh */
+	"Reserved-10h",			/* 10h */
+	"Reserved-11h",			/* 11h */
+	"Reserved-12h",			/* 12h */
+	"Reserved-13h",			/* 13h */
+	"Reserved-14h",			/* 14h */
+	"Reserved-15h",			/* 15h */
+	"Reserved-16h",			/* 16h */
+	"Reserved-17h",			/* 17h */
+	"Reserved-18h",			/* 18h */
+	"Reserved-19h",			/* 19h */
+	"Reserved-1Ah",			/* 1Ah */
+	"Reserved-1Bh",			/* 1Bh */
+	"Reserved-1Ch",			/* 1Ch */
+	"Reserved-1Dh",			/* 1Dh */
+	"Reserved-1Eh",			/* 1Eh */
+	"Unknown"			/* 1Fh */
+};
+#endif
+
+static char *ScsiStatusString[] = {
+	"GOOD",					/* 00h */
+	NULL,					/* 01h */
+	"CHECK CONDITION",			/* 02h */
+	NULL,					/* 03h */
+	"CONDITION MET",			/* 04h */
+	NULL,					/* 05h */
+	NULL,					/* 06h */
+	NULL,					/* 07h */
+	"BUSY",					/* 08h */
+	NULL,					/* 09h */
+	NULL,					/* 0Ah */
+	NULL,					/* 0Bh */
+	NULL,					/* 0Ch */
+	NULL,					/* 0Dh */
+	NULL,					/* 0Eh */
+	NULL,					/* 0Fh */
+	"INTERMEDIATE",				/* 10h */
+	NULL,					/* 11h */
+	NULL,					/* 12h */
+	NULL,					/* 13h */
+	"INTERMEDIATE-CONDITION MET",		/* 14h */
+	NULL,					/* 15h */
+	NULL,					/* 16h */
+	NULL,					/* 17h */
+	"RESERVATION CONFLICT",			/* 18h */
+	NULL,					/* 19h */
+	NULL,					/* 1Ah */
+	NULL,					/* 1Bh */
+	NULL,					/* 1Ch */
+	NULL,					/* 1Dh */
+	NULL,					/* 1Eh */
+	NULL,					/* 1Fh */
+	NULL,					/* 20h */
+	NULL,					/* 21h */
+	"COMMAND TERMINATED",			/* 22h */
+	NULL,					/* 23h */
+	NULL,					/* 24h */
+	NULL,					/* 25h */
+	NULL,					/* 26h */
+	NULL,					/* 27h */
+	"TASK SET FULL",			/* 28h */
+	NULL,					/* 29h */
+	NULL,					/* 2Ah */
+	NULL,					/* 2Bh */
+	NULL,					/* 2Ch */
+	NULL,					/* 2Dh */
+	NULL,					/* 2Eh */
+	NULL,					/* 2Fh */
+	"ACA ACTIVE",				/* 30h */
+	NULL
+};
+
+static const char *ScsiCommonOpString[] = {
+	"TEST UNIT READY",			/* 00h */
+	"REZERO UNIT (REWIND)",			/* 01h */
+	NULL,					/* 02h */
+	"REQUEST_SENSE",			/* 03h */
+	"FORMAT UNIT (MEDIUM)",			/* 04h */
+	"READ BLOCK LIMITS",			/* 05h */
+	NULL,					/* 06h */
+	"REASSIGN BLOCKS",			/* 07h */
+	"READ(6)",				/* 08h */
+	NULL,					/* 09h */
+	"WRITE(6)",				/* 0Ah */
+	"SEEK(6)",				/* 0Bh */
+	NULL,					/* 0Ch */
+	NULL,					/* 0Dh */
+	NULL,					/* 0Eh */
+	"READ REVERSE",				/* 0Fh */
+	"WRITE_FILEMARKS",			/* 10h */
+	"SPACE(6)",				/* 11h */
+	"INQUIRY",				/* 12h */
+	NULL
+};
+
+static const char *SenseKeyString[] = {
+	"NO SENSE",				/* 0h */
+	"RECOVERED ERROR",			/* 1h */
+	"NOT READY",				/* 2h */
+	"MEDIUM ERROR",				/* 3h */
+	"HARDWARE ERROR",			/* 4h */
+	"ILLEGAL REQUEST",			/* 5h */
+	"UNIT ATTENTION",			/* 6h */
+	"DATA PROTECT",				/* 7h */
+	"BLANK CHECK",				/* 8h */
+	"VENDOR-SPECIFIC",			/* 9h */
+	"ABORTED COPY",				/* Ah */
+	"ABORTED COMMAND",			/* Bh */
+	"EQUAL (obsolete)",			/* Ch */
+	"VOLUME OVERFLOW",			/* Dh */
+	"MISCOMPARE",				/* Eh */
+	"RESERVED",				/* Fh */
+	NULL
+};
+
+#define SPECIAL_ASCQ(c,q) \
+	(((c) == 0x40 && (q) != 0x00) || ((c) == 0x4D) || ((c) == 0x70))
+
+#if 0
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Sense_Key_Specific() - If Sense_Key_Specific_Valid bit is set,
+ *			   then print additional information via
+ *			   a call to SDMS_SystemAlert().
+ */
+static void Sense_Key_Specific(IO_Info_t *ioop, char *msg1)
+{
+	u8	*sd;
+	u8	 BadValue;
+	u8	 SenseKey;
+	int	 Offset;
+	int	 len = strlen(msg1);
+
+	sd = ioop->sensePtr;
+	if (SD_Additional_Sense_Length(sd) < 8)
+		return;
+
+	SenseKey = SD_Sense_Key(sd);
+
+	if (SD_Sense_Key_Specific_Valid(sd)) {
+		if (SenseKey == SK_ILLEGAL_REQUEST) {
+			Offset = SD_Bad_Byte(sd);
+			if (SD_Was_Illegal_Request(sd)) {
+				BadValue = ioop->cdbPtr[Offset];
+				len += sprintf(msg1+len, "\n  Illegal CDB value=%02Xh found at CDB ",
+						BadValue);
+		} else {
+			BadValue = ioop->dataPtr[Offset];
+			len += sprintf(msg1+len, "\n  Illegal DATA value=%02Xh found at DATA ",
+					BadValue);
+		}
+		len += sprintf(msg1+len, "byte=%02Xh", Offset);
+		if (SD_SKS_Bit_Pointer_Valid(sd))
+			len += sprintf(msg1+len, "/bit=%1Xh", SD_SKS_Bit_Pointer(sd));
+		} else if ((SenseKey == SK_RECOVERED_ERROR) ||
+			   (SenseKey == SK_HARDWARE_ERROR) ||
+			   (SenseKey == SK_MEDIUM_ERROR)) {
+			len += sprintf(msg1+len, "\n  Recovery algorithm Actual_Retry_Count=%02Xh",
+			SD_Actual_Retry_Count(sd));
+		}
+	}
+}
+#endif
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int dump_cdb(char *foo, unsigned char *cdb)
+{
+	int i, grpCode, cdbLen;
+	int l = 0;
+
+	grpCode = cdb[0] >> 5;
+	if (grpCode < 1)
+		cdbLen = 6;
+	else if (grpCode < 3)
+		cdbLen = 10;
+	else if (grpCode == 5)
+		cdbLen = 12;
+	else
+		cdbLen = 16;
+
+	for (i=0; i < cdbLen; i++)
+		l += sprintf(foo+l, " %02X", cdb[i]);
+
+	return l;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int dump_sd(char *foo, unsigned char *sd)
+{
+	int snsLen = 8 + SD_Additional_Sense_Length(sd);
+	int l = 0;
+	int i;
+
+	for (i=0; i < MIN(snsLen,18); i++)
+		l += sprintf(foo+l, " %02X", sd[i]);
+	l += sprintf(foo+l, "%s", snsLen>18 ? " ..." : "");
+
+	return l;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*  Do ASC/ASCQ lookup/grindage to English readable string(s)  */
+static const char * ascq_set_strings_4max(
+		u8 ASC, u8 ASCQ,
+		const char **s1, const char **s2, const char **s3, const char **s4)
+{
+	static const char *asc_04_part1_string = "LOGICAL UNIT ";
+	static const char *asc_04_part2a_string = "NOT READY, ";
+	static const char *asc_04_part2b_string = "IS ";
+	static const char *asc_04_ascq_NN_part3_strings[] = {	/* ASC ASCQ (hex) */
+	  "CAUSE NOT REPORTABLE",				/* 04 00 */
+	  "IN PROCESS OF BECOMING READY",			/* 04 01 */
+	  "INITIALIZING CMD. REQUIRED",				/* 04 02 */
+	  "MANUAL INTERVENTION REQUIRED",			/* 04 03 */
+	  /* Add	" IN PROGRESS" to all the following... */
+	  "FORMAT",						/* 04 04 */
+	  "REBUILD",						/* 04 05 */
+	  "RECALCULATION",					/* 04 06 */
+	  "OPERATION",						/* 04 07 */
+	  "LONG WRITE",						/* 04 08 */
+	  "SELF-TEST",						/* 04 09 */
+	  NULL
+	};
+	static char *asc_04_part4_string = " IN PROGRESS";
+
+	static char *asc_29_ascq_NN_strings[] = {		/* ASC ASCQ (hex) */
+	  "POWER ON, RESET, OR BUS DEVICE RESET OCCURRED",	/* 29 00 */
+	  "POWER ON OCCURRED",					/* 29 01 */
+	  "SCSI BUS RESET OCCURRED",				/* 29 02 */
+	  "BUS DEVICE RESET FUNCTION OCCURRED",			/* 29 03 */
+	  "DEVICE INTERNAL RESET",				/* 29 04 */
+	  "TRANSCEIVER MODE CHANGED TO SINGLE-ENDED",		/* 29 05 */
+	  "TRANSCEIVER MODE CHANGED TO LVD",			/* 29 06 */
+	  NULL
+	};
+	static char *ascq_vendor_uniq = "(Vendor Unique)";
+	static char *ascq_noone = "(no matching ASC/ASCQ description found)";
+	int idx;
+
+	*s1 = *s2 = *s3 = *s4 = "";		/* set'em all to the empty "" string */
+
+	/* CHECKME! Need lock/sem?
+	 *  Update and examine for isense module presense.
+	 */
+	mptscsih_ASCQ_TablePtr = (ASCQ_Table_t *)mpt_v_ASCQ_TablePtr;
+
+	if (mptscsih_ASCQ_TablePtr == NULL) {
+		/* 2nd chances... */
+		if (ASC == 0x04 && (ASCQ < sizeof(asc_04_ascq_NN_part3_strings)/sizeof(char*)-1)) {
+			*s1 = asc_04_part1_string;
+			*s2 = (ASCQ == 0x01) ? asc_04_part2b_string : asc_04_part2a_string;
+			*s3 = asc_04_ascq_NN_part3_strings[ASCQ];
+			/* check for " IN PROGRESS" ones */
+			if (ASCQ >= 0x04)
+				*s4 = asc_04_part4_string;
+		} else if (ASC == 0x29 && (ASCQ < sizeof(asc_29_ascq_NN_strings)/sizeof(char*)-1))
+			*s1 = asc_29_ascq_NN_strings[ASCQ];
+		/*
+		 *	Else { leave all *s[1-4] values pointing to the empty "" string }
+		 */
+		return *s1;
+	}
+
+	/*
+	 * Need to check ASC here; if it is "special," then
+	 * the ASCQ is variable, and indicates failed component number.
+	 * We must treat the ASCQ as a "dont care" while searching the
+	 * mptscsih_ASCQ_Table[] by masking it off, and then restoring it later
+	 * on when we actually need to identify the failed component.
+	 */
+	if (SPECIAL_ASCQ(ASC,ASCQ))
+		ASCQ = 0xFF;
+
+	/* OK, now search mptscsih_ASCQ_Table[] for a matching entry */
+	for (idx = 0; mptscsih_ASCQ_TablePtr && idx < mpt_ASCQ_TableSz; idx++)
+		if ((ASC == mptscsih_ASCQ_TablePtr[idx].ASC) && (ASCQ == mptscsih_ASCQ_TablePtr[idx].ASCQ)) {
+			*s1 = mptscsih_ASCQ_TablePtr[idx].Description;
+			return *s1;
+		}
+
+	if ((ASC >= 0x80) || (ASCQ >= 0x80))
+		*s1 = ascq_vendor_uniq;
+	else
+		*s1 = ascq_noone;
+
+	return *s1;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  SCSI Error Report; desired output format...
+ *---
+SCSI Error Report =-=-=-=-=-=-=-=-=-=-=-=-=-= (ioc0,scsi0:0)
+  SCSI_Status=02h (CHECK CONDITION)
+  Original_CDB[]: 00 00 00 00 00 00 - TestUnitReady
+  SenseData[12h]: 70 00 06 00 00 00 00 0A 00 00 00 00 29 00 03 00 00 00
+  SenseKey=6h (UNIT ATTENTION); FRU=03h
+  ASC/ASCQ=29h/00h, "POWER ON, RESET, OR BUS DEVICE RESET OCCURRED"
+ *---
+ */
+
+int mpt_ScsiHost_ErrorReport(IO_Info_t *ioop)
+{
+	char		 foo[512];
+	char		 buf2[32];
+	char		*statstr;
+	const char	*opstr;
+	int		 sk		= SD_Sense_Key(ioop->sensePtr);
+	const char	*skstr		= SenseKeyString[sk];
+	unsigned char	 asc		= SD_ASC(ioop->sensePtr);
+	unsigned char	 ascq		= SD_ASCQ(ioop->sensePtr);
+	int		 l;
+
+	/*
+	 *  More quiet mode.
+	 *  Filter out common, repetitive, warning-type errors...  like:
+	 *    POWER ON (06,29/00 or 06,29/01),
+	 *    SPINNING UP (02,04/01),
+	 *    LOGICAL UNIT NOT SUPPORTED (05,25/00), etc.
+	 */
+	if (sk == SK_NO_SENSE) {
+		return 0;
+	}
+	if (	(sk==SK_UNIT_ATTENTION	&& asc==0x29 && (ascq==0x00 || ascq==0x01))
+	     || (sk==SK_NOT_READY	&& asc==0x04 && ascq==0x01)
+	     || (sk==SK_ILLEGAL_REQUEST && asc==0x25 && ascq==0x00)
+	   )
+	{
+		/* Do nothing! */
+		return 0;
+	}
+
+	/*
+	 *  Protect ourselves...
+	 */
+	if (ioop->cdbPtr == NULL)
+		ioop->cdbPtr = dummyCDB;
+	if (ioop->sensePtr == NULL)
+		ioop->sensePtr = dummySenseData;
+	if (ioop->inqPtr == NULL)
+		ioop->inqPtr = dummyInqData;
+	if (ioop->dataPtr == NULL)
+		ioop->dataPtr = dummyScsiData;
+
+	statstr = NULL;
+	if ((ioop->SCSIStatus >= sizeof(ScsiStatusString)/sizeof(char*)-1) ||
+	    ((statstr = (char*)ScsiStatusString[ioop->SCSIStatus]) == NULL)) {
+		(void) sprintf(buf2, "Bad-Reserved-%02Xh", ioop->SCSIStatus);
+		statstr = buf2;
+	}
+
+	opstr = NULL;
+	if (1+ioop->cdbPtr[0] <= sizeof(ScsiCommonOpString)/sizeof(char*))
+		opstr = ScsiCommonOpString[ioop->cdbPtr[0]];
+	else if (mpt_ScsiOpcodesPtr)
+		opstr = mpt_ScsiOpcodesPtr[ioop->cdbPtr[0]];
+
+	l = sprintf(foo, "SCSI Error Report =-=-= (%s)\n"
+	  "  SCSI_Status=%02Xh (%s)\n"
+	  "  Original_CDB[]:",
+			ioop->DevIDStr,
+			ioop->SCSIStatus,
+			statstr);
+	l += dump_cdb(foo+l, ioop->cdbPtr);
+	if (opstr)
+		l += sprintf(foo+l, " - \"%s\"", opstr);
+	l += sprintf(foo+l, "\n  SenseData[%02Xh]:", 8+SD_Additional_Sense_Length(ioop->sensePtr));
+	l += dump_sd(foo+l, ioop->sensePtr);
+	l += sprintf(foo+l, "\n  SenseKey=%Xh (%s); FRU=%02Xh\n  ASC/ASCQ=%02Xh/%02Xh",
+			sk, skstr, SD_FRU(ioop->sensePtr), asc, ascq );
+
+	{
+		const char	*x1, *x2, *x3, *x4;
+		x1 = x2 = x3 = x4 = "";
+		x1 = ascq_set_strings_4max(asc, ascq, &x1, &x2, &x3, &x4);
+		if (x1 != NULL) {
+			if (x1[0] != '(')
+				l += sprintf(foo+l, " \"%s%s%s%s\"", x1,x2,x3,x4);
+			else
+				l += sprintf(foo+l, " %s%s%s%s", x1,x2,x3,x4);
+		}
+	}
+
+#if 0
+	if (SPECIAL_ASCQ(asc,ascq))
+		l += sprintf(foo+l, " (%02Xh)", ascq);
+#endif
+
+	PrintF(("%s\n", foo));
+
+	return l;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_initTarget - Target, LUN alloc/free functionality.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@bus_id: Bus number (?)
+ *	@target_id: SCSI target id
+ *	@lun: SCSI LUN id
+ *	@data: Pointer to data
+ *	@dlen: Number of INQUIRY bytes
+ *
+ *	NOTE: It's only SAFE to call this routine if data points to
+ *	sane & valid STANDARD INQUIRY data!
+ *
+ *	Allocate and initialize memory for this target.
+ *	Save inquiry data.
+ *
+ *	Returns pointer to VirtDevice structure.
+ */
+static VirtDevice *
+mptscsih_initTarget(MPT_SCSI_HOST *hd, int bus_id, int target_id, u8 lun, char *data, int dlen)
+{
+	VirtDevice	*vdev;
+	int		 sz;
+
+	dprintk((MYIOC_s_INFO_FMT "initTarget (%d,%d,%d) called, hd=%p\n",
+			hd->ioc->name, bus_id, target_id, lun, hd));
+
+	if ((vdev = hd->Targets[target_id]) == NULL) {
+		if ((vdev = kmalloc(sizeof(VirtDevice), GFP_ATOMIC)) == NULL) {
+			printk(MYIOC_s_ERR_FMT "initTarget kmalloc(%d) FAILED!\n",
+					hd->ioc->name, (int)sizeof(VirtDevice));
+		} else {
+			memset(vdev, 0, sizeof(VirtDevice));
+			rwlock_init(&vdev->VdevLock);
+			Q_INIT(&vdev->WaitQ, void);
+			Q_INIT(&vdev->SentQ, void);
+			Q_INIT(&vdev->DoneQ, void);
+			vdev->tflags = 0;
+			vdev->ioc_id = hd->ioc->id;
+			vdev->target_id = target_id;
+			vdev->bus_id = bus_id;
+
+			hd->Targets[target_id] = vdev;
+			dprintk((KERN_INFO "  *NEW* Target structure (id %d) @ %p\n",
+					target_id, vdev));
+		}
+	}
+
+	if (vdev && data) {
+		if (!(vdev->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY)) {
+
+			/* Copy the inquiry data  - if we haven't yet.
+			*/
+			sz = MIN(dlen, SCSI_STD_INQUIRY_BYTES);
+
+			memcpy (vdev->inq_data, data, sz);
+			vdev->tflags |= MPT_TARGET_FLAGS_VALID_INQUIRY;
+
+			/* Update the target capabilities
+			 */
+			mptscsih_setTargetNegoParms(hd, vdev);
+		}
+
+		/* Is LUN supported? If so, upper 3 bits will be 0
+		 * in first byte of inquiry data.
+		 */
+		if ((*data & 0xe0) == 0)
+			vdev->luns |= (1 << lun);
+	}
+
+	if (vdev) {
+		if (hd->ioc->spi_data.isRaid & (1 << target_id))
+			vdev->raidVolume = 1;
+		else
+			vdev->raidVolume = 0;
+	}
+
+	dprintk((KERN_INFO "  target = %p\n", vdev));
+	return vdev;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Update the target negotiation parameters based on the
+ *  the Inquiry data, adapter capabilities, and NVRAM settings.
+ *
+ */
+void mptscsih_setTargetNegoParms(MPT_SCSI_HOST *hd, VirtDevice *target)
+{
+	int  id = (int) target->target_id;
+	int  nvram;
+	char canQ = 0;
+	u8 width = MPT_NARROW;
+	u8 factor = MPT_ASYNC;
+	u8 offset = 0;
+	u8 version, nfactor;
+	ScsiCfgData *pspi_data = &hd->ioc->spi_data;
+
+	/* Set flags based on Inquiry data
+	 */
+	if (target->tflags & MPT_TARGET_FLAGS_VALID_INQUIRY) {
+		version = target->inq_data[2] & 0x03;
+		if (version < 2) {
+			width = 0;
+			factor = MPT_ULTRA2;
+			offset = pspi_data->maxSyncOffset;
+		} else {
+			if (target->inq_data[7] & 0x20) {
+				width = 1;
+			}
+
+			if (target->inq_data[7] & 0x10) {
+				if (version == 2)
+					factor = MPT_ULTRA2;
+				else
+					factor = MPT_ULTRA320;
+
+				offset = pspi_data->maxSyncOffset;
+			} else {
+				factor = MPT_ASYNC;
+				offset = 0;
+			}
+		}
+
+		if (target->inq_data[7] & 0x02) {
+			canQ = 1;
+		}
+
+		/* Update tflags based on NVRAM settings. (SCSI only)
+		 */
+		if (pspi_data->nvram && (pspi_data->nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+			nvram = pspi_data->nvram[id];
+			nfactor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;
+
+			if (width)
+				width = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
+
+			if (offset > 0) {
+				/* Ensure factor is set to the
+				 * maximum of: adapter, nvram, inquiry
+				 */
+				if (nfactor) {
+					if (nfactor < pspi_data->minSyncFactor )
+						nfactor = pspi_data->minSyncFactor;
+
+					factor = MAX (factor, nfactor);
+					if (factor == MPT_ASYNC)
+						offset = 0;
+				} else {
+					offset = 0;
+					factor = MPT_ASYNC;
+				}
+			} else {
+				factor = MPT_ASYNC;
+			}
+		}
+
+		/* Make sure data is consistent
+		 */
+		if ((!width) && (factor < MPT_ULTRA2)) {
+			factor = MPT_ULTRA2;
+		}
+
+		/* Save the data to the target structure.
+		 */
+		target->minSyncFactor = factor;
+		target->maxOffset = offset;
+		target->maxWidth = width;
+		if (canQ) {
+			target->tflags |= MPT_TARGET_FLAGS_Q_YES;
+		}
+
+		target->tflags |= MPT_TARGET_FLAGS_VALID_NEGO;
+
+		/* Disable all wide (sync) extended messages
+		 * if device is narrow (async).
+		 */
+		target->negoFlags = 0;
+		if (!width)
+			target->negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+
+		if (!offset)
+			target->negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+	}
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Clear sense valid flag.
+ */
+static void clear_sense_flag(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq)
+{
+	VirtDevice	*target;
+	int		 index = (int) pReq->TargetID;
+
+	if ((target = hd->Targets[index])) {
+		target->tflags &= ~MPT_TARGET_FLAGS_VALID_SENSE;
+	}
+
+	return;
+}
+
+/* 
+ * If DV disabled (negoNvram set to USE_NVARM) or if not LUN 0, return.
+ * Else set the NEED_DV flag after Read Capacity Issued (disks) 
+ * or Mode Sense (cdroms). Tapes, key off of Inquiry command.
+ */
+static void mptscsih_set_dvflags(MPT_SCSI_HOST *hd, SCSIIORequest_t *pReq, char *data)
+{
+	u8 cmd = pReq->CDB[0];
+	
+	if (pReq->LUN[1] != 0)
+		return;
+
+	if (hd->negoNvram != 0)
+		return;
+
+	if ((cmd == READ_CAPACITY) || (cmd == MODE_SENSE) || 
+		((cmd == INQUIRY) && ((data[0] & 0x1F) == 0x01))) {
+		u8 dvStatus = hd->ioc->spi_data.dvStatus[pReq->TargetID];
+		if (!(dvStatus & MPT_SCSICFG_DV_DONE)) {
+			ScsiCfgData *pSpi = &hd->ioc->spi_data;
+			if ((pSpi->isRaid & (1 << pReq->TargetID)) && pSpi->pIocPg3) {
+				/* Set NEED_DV for all hidden disks
+				 */
+				Ioc3PhysDisk_t *pPDisk =  pSpi->pIocPg3->PhysDisk;
+				int		numPDisk = pSpi->pIocPg3->NumPhysDisks;
+				
+				while (numPDisk) {
+					pSpi->dvStatus[pPDisk->PhysDiskID] |= MPT_SCSICFG_NEED_DV;
+					ddvtprintk(("NEED_DV set for phys disk id %d\n", pPDisk->PhysDiskID));
+					pPDisk++;
+					numPDisk--;
+				}
+			}
+			pSpi->dvStatus[pReq->TargetID] |= MPT_SCSICFG_NEED_DV;
+			ddvtprintk(("NEED_DV set for visible disk id %d\n", 
+					pReq->TargetID));
+		};
+	}
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  SCSI Config Page functionality ...
+ */
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_setDevicePage1Flags  - add Requested and Configuration fields flags
+ *	based on width, factor and offset parameters.
+ *	@width: bus width
+ *	@factor: sync factor
+ *	@offset: sync offset
+ *	@requestedPtr: pointer to requested values (updated)
+ *	@configurationPtr: pointer to configuration values (updated)
+ *	@flags: flags to block WDTR or SDTR negotiation
+ *
+ *	Return: None.
+ *
+ *	Remark: Called by writeSDP1 and _dv_params
+ */
+static void
+mptscsih_setDevicePage1Flags (u8 width, u8 factor, u8 offset, int *requestedPtr, int *configurationPtr, u8 flags)
+{
+	u8 nowide = flags & MPT_TARGET_NO_NEGO_WIDE;
+	u8 nosync = flags & MPT_TARGET_NO_NEGO_SYNC;
+
+	*configurationPtr = 0;
+	*requestedPtr = width ? MPI_SCSIDEVPAGE1_RP_WIDE : 0;
+	*requestedPtr |= (offset << 16) | (factor << 8);
+
+	if (width && offset && !nowide && !nosync) {
+		if (factor < MPT_ULTRA160) {
+			*requestedPtr |= (MPI_SCSIDEVPAGE1_RP_IU + MPI_SCSIDEVPAGE1_RP_DT +
+						MPI_SCSIDEVPAGE1_RP_QAS);
+		} else if (factor < MPT_ULTRA2) {
+			*requestedPtr |= MPI_SCSIDEVPAGE1_RP_DT;
+		}
+	}
+
+	if (nowide)
+		*configurationPtr |= MPI_SCSIDEVPAGE1_CONF_WDTR_DISALLOWED;
+
+	if (nosync)
+		*configurationPtr |= MPI_SCSIDEVPAGE1_CONF_SDTR_DISALLOWED;
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_writeSDP1  - write SCSI Device Page 1
+ *	@hd: Pointer to a SCSI Host Strucutre
+ *	@portnum: IOC port number
+ *	@target_id: writeSDP1 for single ID
+ *	@flags: MPT_SCSICFG_ALL_IDS, MPT_SCSICFG_USE_NVRAM
+ *
+ *	Return: -EFAULT if read of config page header fails
+ *		or 0 if success.
+ *
+ *	Remark: If a target has been found, the settings from the
+ *		target structure are used, else the device is set
+ *		to async/narrow.
+ *
+ *	Remark: Called during init and after a FW reload.
+ *	Remark: We do not wait for a return, write pages sequentially.
+ */
+static int
+mptscsih_writeSDP1(MPT_SCSI_HOST *hd, int portnum, int target_id, int flags)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	Config_t		*pReq = NULL;
+	SCSIDevicePage1_t	*pData = NULL;
+	VirtDevice		*pTarget = NULL;
+	MPT_FRAME_HDR		*mf;
+	MptSge_t		*psge;
+	dma_addr_t		 dataDma;
+	u16			 req_idx;
+	u32			 frameOffset;
+	u32			 requested, configuration, flagsLength;
+	int			 ii, nvram;
+	int			 id = 0, maxid = 0;
+	u8			 width;
+	u8			 factor;
+	u8			 offset;
+	u8			 bus = 0;
+	u8			 negoFlags;
+
+	if (ioc->spi_data.sdp1length == 0)
+		return 0;
+
+	if (flags & MPT_SCSICFG_ALL_IDS) {
+		id = 0;
+		maxid = ioc->sh->max_id - 1;
+	} else if (ioc->sh) {
+		id = target_id;
+		maxid = MIN(id, ioc->sh->max_id - 1);
+	}
+
+	for (; id <= maxid; id++) {
+		if (id == ioc->pfacts[portnum].PortSCSIID)
+			continue;
+
+		if (flags & MPT_SCSICFG_USE_NVRAM) {
+			/* Use NVRAM, adapter maximums and target settings.
+			 * Data over-riden by target structure information, if present
+			 */
+			width = ioc->spi_data.maxBusWidth;
+			offset = ioc->spi_data.maxSyncOffset;
+			factor = ioc->spi_data.minSyncFactor;
+			if (ioc->spi_data.nvram && (ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+				nvram = ioc->spi_data.nvram[id];
+
+				if (width)
+					width = nvram & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
+
+				if (offset > 0) {
+					factor = (nvram & MPT_NVRAM_SYNC_MASK) >> 8;
+					if (factor == 0) {
+						/* Key for async */
+						factor = MPT_ASYNC;
+						offset = 0;
+					} else if (factor < ioc->spi_data.minSyncFactor) {
+						factor = ioc->spi_data.minSyncFactor;
+					}
+				} else
+					factor = MPT_ASYNC;
+			}
+
+			/* Set the negotiation flags.
+			 */
+			negoFlags = 0;
+			if (!width)
+				negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+	
+			if (!offset)
+				negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+		} else {
+			width = 0;
+			factor = MPT_ASYNC;
+			offset = 0;
+			negoFlags = MPT_TARGET_NO_NEGO_SYNC;
+		}
+
+		/* If id is not a raid volume, get the updated
+		 * transmission settings from the target structure.
+		 */
+		if (hd->Targets && (pTarget = hd->Targets[id]) && !pTarget->raidVolume) {
+			width = pTarget->maxWidth;
+			factor = pTarget->minSyncFactor;
+			offset = pTarget->maxOffset;
+			negoFlags = pTarget->negoFlags;
+			pTarget = NULL;
+		}
+		mptscsih_setDevicePage1Flags(width, factor, offset,
+					&requested, &configuration, negoFlags);
+
+
+		if (negoFlags == (MPT_TARGET_NO_NEGO_WIDE | MPT_TARGET_NO_NEGO_SYNC))
+			continue;
+
+		/* Get a MF for this command.
+		 */
+		if ((mf = mpt_get_msg_frame(ScsiDoneCtx, ioc->id)) == NULL) {
+			dprintk((MYIOC_s_WARN_FMT "write SDP1: no msg frames!\n",
+						ioc->name));
+			return -EAGAIN;
+		}
+
+		/* Set the request and the data pointers.
+		 * Request takes: 36 bytes (32 bit SGE)
+		 * SCSI Device Page 1 requires 16 bytes
+		 * 40 + 16 <= size of SCSI IO Request = 56 bytes
+		 * and MF size >= 64 bytes.
+		 * Place data at end of MF.
+		 */
+		pReq = (Config_t *)mf;
+
+		req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+		frameOffset = ioc->req_sz - sizeof(SCSIDevicePage1_t);
+
+		pData = (SCSIDevicePage1_t *)((u8 *) mf + frameOffset);
+		dataDma = ioc->req_frames_dma + (req_idx * ioc->req_sz) + frameOffset;
+
+		/* Complete the request frame (same for all requests).
+		 */
+		pReq->Action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+		pReq->Reserved = 0;
+		pReq->ChainOffset = 0;
+		pReq->Function = MPI_FUNCTION_CONFIG;
+		pReq->Reserved1[0] = 0;
+		pReq->Reserved1[1] = 0;
+		pReq->Reserved1[2] = 0;
+		pReq->MsgFlags = 0;
+		for (ii=0; ii < 8; ii++) {
+			pReq->Reserved2[ii] = 0;
+		}
+		pReq->Header.PageVersion = ioc->spi_data.sdp1version;
+		pReq->Header.PageLength = ioc->spi_data.sdp1length;
+		pReq->Header.PageNumber = 1;
+		pReq->Header.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+		pReq->PageAddress = cpu_to_le32(id | (bus << 8 ));
+
+		/* Add a SGE to the config request.
+		 */
+		flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE | ioc->spi_data.sdp1length * 4;
+
+		psge = (MptSge_t *) &pReq->PageBufferSGE;
+		psge->FlagsLength = cpu_to_le32(flagsLength);
+		cpu_to_leXX(dataDma, psge->Address);
+
+		/* Set up the common data portion
+		 */
+		pData->Header.PageVersion = pReq->Header.PageVersion;
+		pData->Header.PageLength = pReq->Header.PageLength;
+		pData->Header.PageNumber = pReq->Header.PageNumber;
+		pData->Header.PageType = pReq->Header.PageType;
+		pData->RequestedParameters = cpu_to_le32(requested);
+		pData->Reserved = 0;
+		pData->Configuration = cpu_to_le32(configuration);
+
+		dprintk((MYIOC_s_INFO_FMT 
+			"write SDP1: id %d pgaddr 0x%x req 0x%x config 0x%x\n",
+				ioc->name, id, (id | (bus<<8)), 
+				requested, configuration));
+
+		mptscsih_put_msgframe(ScsiDoneCtx, ioc->id, mf);
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_taskmgmt_timeout - Call back for timeout on a
+ *	task management request.
+ *	@data: Pointer to MPT_SCSI_HOST recast as an unsigned long
+ *
+ */
+static void mptscsih_taskmgmt_timeout(unsigned long data)
+{
+	MPT_SCSI_HOST *hd = (MPT_SCSI_HOST *) data;
+
+	dprintk((MYIOC_s_WARN_FMT "TM request timed out!\n", hd->ioc->name));
+	/* Delete the timer that triggered this callback.
+	 * Remark: del_timer checks to make sure timer is active
+	 * before deleting.
+	 */
+	del_timer(&hd->TMtimer);
+
+	/* Call the reset handler. Already had a TM request
+	 * timeout - so issue a diagnostic reset
+	 */
+	if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+		printk((KERN_WARNING " Firmware Reload FAILED!!\n"));
+	}
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  Bus Scan and Domain Validation functionality ...
+ */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	mptscsih_scandv_complete - Scan and DV callback routine registered
+ *	to Fustion MPT (base) driver.
+ *
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ *	@mf: Pointer to original MPT request frame
+ *	@mr: Pointer to MPT reply frame (NULL if TurboReply)
+ *
+ *	This routine is called from mpt.c::mpt_interrupt() at the completion
+ *	of any SCSI IO request.
+ *	This routine is registered with the Fusion MPT (base) driver at driver
+ *	load/init time via the mpt_register() API call.
+ *
+ *	Returns 1 indicating alloc'd request frame ptr should be freed.
+ *
+ *	Remark: Sets a completion code and (possibly) saves sense data
+ *	in the IOC member localReply structure.
+ *	Used ONLY for bus scan, DV and other internal commands.
+ */
+static int
+mptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)
+{
+	MPT_SCSI_HOST	*hd;
+	SCSIIORequest_t *pReq;
+	int		 completionCode;
+	u16		 req_idx;
+
+	if ((mf == NULL) ||
+	    (mf >= MPT_INDEX_2_MFPTR(ioc, ioc->req_depth))) {
+		printk(MYIOC_s_ERR_FMT
+			"ScanDvComplete, %s req frame ptr! (=%p)\n",
+				ioc->name, mf?"BAD":"NULL", mf);
+		goto wakeup;
+	}
+
+	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+	del_timer(&hd->timer);
+	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	hd->ScsiLookup[req_idx] = NULL;
+	pReq = (SCSIIORequest_t *) mf;
+
+	if (mf != hd->cmdPtr) {
+		printk(MYIOC_s_WARN_FMT "ScanDvComplete (mf=%p, cmdPtr=%p)\n",
+				hd->ioc->name, mf, hd->cmdPtr);
+	}
+	hd->cmdPtr = NULL;
+
+	ddvprintk((MYIOC_s_INFO_FMT "ScanDvComplete (mf=%p,mr=%p)\n",
+			hd->ioc->name, mf, mr));
+
+	atomic_dec(&queue_depth);
+
+	hd->pLocal = &hd->localReply;
+
+	/* If target struct exists, clear sense valid flag.
+	 */
+	clear_sense_flag(hd, pReq);
+
+	if (mr == NULL) {
+		completionCode = MPT_SCANDV_GOOD;
+	} else {
+		SCSIIOReply_t	*pReply;
+		u16		 status;
+
+		pReply = (SCSIIOReply_t *) mr;
+
+		status = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;
+
+		ddvprintk((KERN_NOTICE "  IOCStatus=%04xh, SCSIState=%02xh, SCSIStatus=%02xh, IOCLogInfo=%08xh\n",
+			     status, pReply->SCSIState, pReply->SCSIStatus,
+			     le32_to_cpu(pReply->IOCLogInfo)));
+
+		switch(status) {
+
+		case MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:	/* 0x0043 */
+			completionCode = MPT_SCANDV_SELECTION_TIMEOUT;
+			break;
+
+		case MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:		/* 0x0046 */
+		case MPI_IOCSTATUS_SCSI_TASK_TERMINATED:	/* 0x0048 */
+		case MPI_IOCSTATUS_SCSI_IOC_TERMINATED:		/* 0x004B */
+		case MPI_IOCSTATUS_SCSI_EXT_TERMINATED:		/* 0x004C */
+			completionCode = MPT_SCANDV_DID_RESET;
+			break;
+
+		case MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:		/* 0x0045 */
+		case MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:	/* 0x0040 */
+		case MPI_IOCSTATUS_SUCCESS:			/* 0x0000 */
+			if (pReply->Function == MPI_FUNCTION_CONFIG) {
+				ConfigReply_t *pr = (ConfigReply_t *)mr;
+				completionCode = MPT_SCANDV_GOOD;
+				hd->pLocal->header.PageVersion = pr->Header.PageVersion;
+				hd->pLocal->header.PageLength = pr->Header.PageLength;
+				hd->pLocal->header.PageNumber = pr->Header.PageNumber;
+				hd->pLocal->header.PageType = pr->Header.PageType;
+
+			} else if (pReply->Function == MPI_FUNCTION_RAID_ACTION) {
+				/* If the RAID Volume request is successful,
+				 * return GOOD, else indicate that
+				 * some type of error occurred.
+				 */
+				MpiRaidActionReply_t	*pr = (MpiRaidActionReply_t *)mr;
+				if (pr->ActionStatus == MPI_RAID_ACTION_ASTATUS_SUCCESS)
+					completionCode = MPT_SCANDV_GOOD;
+				else
+					completionCode = MPT_SCANDV_SOME_ERROR;
+
+			} else if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {
+				VirtDevice	*target;
+				u8		*sense_data;
+				int		 sz;
+
+				/* save sense data in global & target structure
+				 */
+				completionCode = MPT_SCANDV_SENSE;
+				hd->pLocal->scsiStatus = pReply->SCSIStatus;
+				sense_data = ((u8 *)hd->ioc->sense_buf_pool +
+					(req_idx * MPT_SENSE_BUFFER_ALLOC));
+
+				sz = MIN (pReq->SenseBufferLength,
+							SCSI_STD_SENSE_BYTES);
+				memcpy(hd->pLocal->sense, sense_data, sz);
+
+				target = hd->Targets[pReq->TargetID];
+				if (target) {
+					memcpy(target->sense, sense_data, sz);
+					target->tflags
+						|= MPT_TARGET_FLAGS_VALID_SENSE;
+				}
+
+				ddvprintk((KERN_NOTICE "  Check Condition, sense ptr %p\n",
+						sense_data));
+			} else if (pReply->SCSIState & (MPI_SCSI_STATE_AUTOSENSE_FAILED |
+							MPI_SCSI_STATE_NO_SCSI_STATUS)) {
+				completionCode = MPT_SCANDV_DID_RESET;
+			} else if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED) {
+				completionCode = MPT_SCANDV_DID_RESET;
+			} else {
+				/* If no error, this will be equivalent
+				 * to MPT_SCANDV_GOOD
+				 */
+				completionCode = (int) pReply->SCSIStatus;
+			}
+			break;
+
+		case MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:		/* 0x0047 */
+			if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)
+				completionCode = MPT_SCANDV_DID_RESET;
+			else
+				completionCode = MPT_SCANDV_SOME_ERROR;
+			break;
+
+		default:
+			completionCode = MPT_SCANDV_SOME_ERROR;
+			break;
+
+		}	/* switch(status) */
+
+		ddvprintk((KERN_NOTICE "  completionCode set to %08xh\n",
+				completionCode));
+	} /* end of address reply case */
+
+	hd->pLocal->completion = completionCode;
+
+	/* MF and RF are freed in mpt_interrupt
+	 */
+wakeup:
+	/* Free Chain buffers (will never chain) in scan or dv */
+	//mptscsih_freeChainBuffers(hd, req_idx);
+
+	/*
+	 * Wake up the original calling thread
+	 */
+	scandv_wait_done = 1;
+	wake_up(&scandv_waitq);
+
+	return 1;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_timer_expired - Call back for timer process.
+ *	Used only for dv functionality.
+ *	@data: Pointer to MPT_SCSI_HOST recast as an unsigned long
+ *
+ */
+static void mptscsih_timer_expired(unsigned long data)
+{
+	MPT_SCSI_HOST *hd = (MPT_SCSI_HOST *) data;
+#ifndef MPT_SCSI_USE_NEW_EH
+	unsigned long  flags;
+#endif
+
+
+	ddvprintk((MYIOC_s_WARN_FMT "Timer Expired! Cmd %p\n", hd->ioc->name, hd->cmdPtr));
+
+	if (hd->cmdPtr) {
+		MPIHeader_t *cmd = (MPIHeader_t *)hd->cmdPtr;
+
+		if (cmd->Function == MPI_FUNCTION_SCSI_IO_REQUEST) {
+			/* Desire to issue a task management request here.
+			 * TM requests MUST be single threaded.
+			 * If old eh code and no TM current, issue request.
+			 * If new eh code, do nothing. Wait for OS cmd timeout
+			 *	for bus reset.
+			 */
+#ifndef MPT_SCSI_USE_NEW_EH
+			spin_lock_irqsave(&hd->ioc->FreeQlock, flags);
+			if (hd->tmPending) {
+				spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+				return;
+			} else 
+				hd->tmPending = 1;
+			spin_unlock_irqrestore(&hd->ioc->FreeQlock, flags);
+
+			if (mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,
+							0, 0, 0, NO_SLEEP) < 0) {
+				printk(MYIOC_s_WARN_FMT "TM FAILED!\n", hd->ioc->name);
+			}
+#else
+			ddvtprintk((MYIOC_s_NOTE_FMT "DV Cmd Timeout: NoOp\n", hd->ioc->name));
+#endif
+		} else {
+			/* Perform a FW reload */
+			if (mpt_HardResetHandler(hd->ioc, NO_SLEEP) < 0) {
+				printk(MYIOC_s_WARN_FMT "Firmware Reload FAILED!\n", hd->ioc->name);
+			}
+		}
+	} else {
+		/* This should NEVER happen */
+		printk(MYIOC_s_WARN_FMT "Null cmdPtr!!!!\n", hd->ioc->name);
+	}
+
+	/* No more processing.
+	 * TM call will generate an interrupt for SCSI TM Management.
+	 * The FW will reply to all outstanding commands, callback will finish cleanup.
+	 * Hard reset clean-up will free all resources.
+	 */
+	ddvprintk((MYIOC_s_WARN_FMT "Timer Expired Complete!\n", hd->ioc->name));
+
+	return;
+}
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_do_raid - Format and Issue a RAID volume request message.
+ *	@hd: Pointer to scsi host structure
+ *	@action: What do be done.
+ *	@id: Logical target id.
+ *	@bus: Target locations bus.
+ *
+ *	Returns: < 0 on a fatal error
+ *		0 on success
+ *
+ *	Remark: Wait to return until reply processed by the ISR.
+ */
+static int
+mptscsih_do_raid(MPT_SCSI_HOST *hd, u8 action, INTERNAL_CMD *io)
+{
+	MpiRaidActionRequest_t	*pReq;
+	MPT_FRAME_HDR		*mf;
+	MptSge_t		*psge;
+	int			flagsLength;
+	int			in_isr;
+
+	in_isr = in_interrupt();
+	if (in_isr) {
+		dprintk((MYIOC_s_WARN_FMT "Internal raid request not allowed in ISR context!\n",
+       				hd->ioc->name));
+		return -EPERM;
+	}
+
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc->id)) == NULL) {
+		ddvprintk((MYIOC_s_WARN_FMT "_do_raid: no msg frames!\n",
+					hd->ioc->name));
+		return -EAGAIN;
+	}
+	pReq = (MpiRaidActionRequest_t *)mf;
+	pReq->Action = action;
+	pReq->Reserved1 = 0;
+	pReq->ChainOffset = 0;
+	pReq->Function = MPI_FUNCTION_RAID_ACTION;
+	pReq->VolumeID = io->id;
+	pReq->VolumeBus = io->bus;
+	pReq->PhysDiskNum = io->physDiskNum;
+	pReq->MsgFlags = 0;
+	pReq->Reserved2 = 0;
+	pReq->ActionDataWord = 0; /* Reserved for this action */
+	//pReq->ActionDataSGE = 0;
+
+	psge = (MptSge_t *) &pReq->ActionDataSGE;
+
+	/* Add a SGE to the config request.
+	 */
+	flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ | 0;
+
+	psge->FlagsLength = cpu_to_le32(flagsLength);
+	cpu_to_leXX( (dma_addr_t) -1, psge->Address);
+
+	ddvprintk((MYIOC_s_INFO_FMT "RAID Volume action %x id %d\n",
+			hd->ioc->name, action, io->id));
+
+	hd->pLocal = NULL;
+	hd->timer.expires = jiffies + HZ*2; /* 2 second timeout */
+	scandv_wait_done = 0;
+
+	/* Save cmd pointer, for resource free if timeout or
+	 * FW reload occurs
+	 */
+	hd->cmdPtr = mf;
+
+	add_timer(&hd->timer);
+	mptscsih_put_msgframe(ScsiScanDvCtx, hd->ioc->id, mf);
+	wait_event(scandv_waitq, scandv_wait_done);
+
+	if ((hd->pLocal == NULL) || (hd->pLocal->completion != MPT_SCANDV_GOOD))
+		return -1;
+
+	return 0;
+}
+#endif /* ~MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_do_cmd - Do internal command.
+ *	@hd: MPT_SCSI_HOST pointer
+ *	@io: INTERNAL_CMD pointer.
+ *
+ *	Issue the specified internally generated command and do command
+ *	specific cleanup. For bus scan / DV only.
+ *	NOTES: If command is Inquiry and status is good,
+ *	initialize a target structure, save the data
+ *
+ *	Remark: Single threaded access only.
+ *
+ *	Return:
+ *		< 0 if an illegal command or no resources
+ *
+ *		   0 if good
+ *
+ *		 > 0 if command complete but some type of completion error.
+ */
+static int
+mptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *io)
+{
+	MPT_FRAME_HDR	*mf;
+	MptSge_t	*mpisge;
+	SCSIIORequest_t	*pScsiReq;
+	SCSIIORequest_t	 ReqCopy;
+	int		 my_idx, ii, dir;
+	int		 rc, cmdTimeout;
+	int		in_isr;
+	char		 cmdLen;
+	char		 CDB[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+	char		 cmd = io->cmd;
+
+	in_isr = in_interrupt();
+	if (in_isr) {
+		dprintk((MYIOC_s_WARN_FMT "Internal SCSI IO request not allowed in ISR context!\n",
+       				hd->ioc->name));
+		return -EPERM;
+	}
+
+
+	/* Set command specific information
+	 */
+	switch (cmd) {
+	case CMD_Inquiry:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		CDB[4] = io->size;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_TestUnitReady:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_StartStopUnit:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		CDB[4] = 1;	/*Spin up the disk */
+		cmdTimeout = 15;
+		break;
+
+	case CMD_ReadBuffer:
+		cmdLen = 10;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		if (io->flags & MPT_ICFLAG_ECHO) {
+			CDB[1] = 0x0A;
+		} else {
+			CDB[1] = 0x02;
+		}
+
+		if (io->flags & MPT_ICFLAG_BUF_CAP) {
+			CDB[1] |= 0x01;
+		}
+		CDB[6] = (io->size >> 16) & 0xFF;
+		CDB[7] = (io->size >>  8) & 0xFF;
+		CDB[8] = io->size & 0xFF;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_WriteBuffer:
+		cmdLen = 10;
+		dir = MPI_SCSIIO_CONTROL_WRITE;
+		CDB[0] = cmd;
+		if (io->flags & MPT_ICFLAG_ECHO) {
+			CDB[1] = 0x0A;
+		} else {
+			CDB[1] = 0x02;
+		}
+		CDB[6] = (io->size >> 16) & 0xFF;
+		CDB[7] = (io->size >>  8) & 0xFF;
+		CDB[8] = io->size & 0xFF;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_Reserve6:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_Release6:
+		cmdLen = 6;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+		cmdTimeout = 10;
+		break;
+
+	case CMD_SynchronizeCache:
+		cmdLen = 10;
+		dir = MPI_SCSIIO_CONTROL_READ;
+		CDB[0] = cmd;
+//		CDB[1] = 0x02;	/* set immediate bit */
+		cmdTimeout = 10;
+		break;
+
+	default:
+		/* Error Case */
+		return -EFAULT;
+	}
+
+	/* Get and Populate a free Frame
+	 */
+	if ((mf = mpt_get_msg_frame(ScsiScanDvCtx, hd->ioc->id)) == NULL) {
+		ddvprintk((MYIOC_s_WARN_FMT "No msg frames!\n",
+					hd->ioc->name));
+		return -EBUSY;
+	}
+
+	pScsiReq = (SCSIIORequest_t *) mf;
+
+	/* Get the request index */
+	my_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
+	ADD_INDEX_LOG(my_idx); /* for debug */
+
+	if (io->flags & MPT_ICFLAG_PHYS_DISK) {
+		pScsiReq->TargetID = io->physDiskNum;
+		pScsiReq->Bus = 0;
+		pScsiReq->ChainOffset = 0;
+		pScsiReq->Function = MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;
+	} else {
+		pScsiReq->TargetID = io->id;
+		pScsiReq->Bus = io->bus;
+		pScsiReq->ChainOffset = 0;
+		pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
+	}
+
+	pScsiReq->CDBLength = cmdLen;
+	pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
+
+	pScsiReq->Reserved = 0;
+
+	pScsiReq->MsgFlags = MPT_SCSIIO_MSG_FLAGS;
+	/* MsgContext set in mpt_get_msg_fram call  */
+
+	for (ii=0; ii < 8; ii++)
+		pScsiReq->LUN[ii] = 0;
+	pScsiReq->LUN[1] = io->lun;
+
+	if (io->flags & MPT_ICFLAG_TAGGED_CMD)
+		pScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_SIMPLEQ);
+	else
+		pScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);
+
+	for (ii=0; ii < 16; ii++)
+		pScsiReq->CDB[ii] = CDB[ii];
+
+	pScsiReq->DataLength = cpu_to_le32(io->size);
+	pScsiReq->SenseBufferLowAddr = cpu_to_le32(hd->ioc->sense_buf_low_dma
+					   + (my_idx * MPT_SENSE_BUFFER_ALLOC));
+
+	ddvprintk((MYIOC_s_INFO_FMT "Sending Command 0x%x for (%d:%d:%d)\n",
+			hd->ioc->name, cmd, io->bus, io->id, io->lun));
+
+	/* 32 bit SG only */
+	mpisge = (MptSge_t *) &pScsiReq->SGL;
+
+	if (dir == MPI_SCSIIO_CONTROL_READ) {
+		mpisge->FlagsLength = cpu_to_le32(
+			MPT_SGE_FLAGS_SSIMPLE_READ | io->size);
+	} else {
+		mpisge->FlagsLength = cpu_to_le32(
+			MPT_SGE_FLAGS_SSIMPLE_WRITE | io->size);
+	}
+
+	/* data_dma defaults to -1
+	 */
+	cpu_to_leXX(io->data_dma, mpisge->Address);
+
+	/* The ISR will free the request frame, but we need
+	 * the information to initialize the target. Duplicate.
+	 */
+	memcpy(&ReqCopy, pScsiReq, sizeof(SCSIIORequest_t));
+
+	/* Issue this command after:
+	 *	finish init
+	 *	add timer
+	 * Wait until the reply has been received
+	 *  ScsiScanDvCtx callback function will
+	 *	set hd->pLocal;
+	 *	set scandv_wait_done and call wake_up
+	 */
+	hd->pLocal = NULL;
+	hd->timer.expires = jiffies + HZ*cmdTimeout;
+	scandv_wait_done = 0;
+
+	/* Save cmd pointer, for resource free if timeout or
+	 * FW reload occurs
+	 */
+	hd->cmdPtr = mf;
+
+	add_timer(&hd->timer);
+	mptscsih_put_msgframe(ScsiScanDvCtx, hd->ioc->id, mf);
+	wait_event(scandv_waitq, scandv_wait_done);
+
+	if (hd->pLocal) {
+		rc = hd->pLocal->completion;
+		hd->pLocal->skip = 0;
+
+		/* Always set fatal error codes in some cases.
+		 */
+		if (rc == MPT_SCANDV_SELECTION_TIMEOUT)
+			rc = -ENXIO;
+		else if (rc == MPT_SCANDV_SOME_ERROR)
+			rc =  -rc;
+	} else {
+		rc = -EFAULT;
+		/* This should never happen. */
+		ddvprintk((MYIOC_s_INFO_FMT "_do_cmd: Null pLocal!!!\n",
+				hd->ioc->name));
+	}
+
+	return rc;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_synchronize_cache - Send SYNCHRONIZE_CACHE to all disks.
+ *	@hd: Pointer to MPT_SCSI_HOST structure
+ *	@portnum: IOC port number
+ *
+ *	Uses the ISR, but with special processing.
+ *	MUST be single-threaded.
+ *
+ *	Return: 0 on completion
+ */
+static int
+mptscsih_synchronize_cache(MPT_SCSI_HOST *hd, int portnum)
+{
+	MPT_ADAPTER		*ioc= hd->ioc;
+	VirtDevice		*pTarget = NULL;
+	SCSIDevicePage1_t	*pcfg1Data = NULL;
+	INTERNAL_CMD		 iocmd;
+	CONFIGPARMS		 cfg;
+	dma_addr_t		 cfg1_dma_addr = -1;
+	ConfigPageHeader_t	 header1;
+	int			 bus = 0;
+	int			 id = 0;
+	int			 lun = 0;
+	int			 hostId = ioc->pfacts[portnum].PortSCSIID;
+	int			 max_id;
+	int			 requested, configuration, data;
+	int			 doConfig = 0;
+	u8			 flags, factor;
+
+	max_id = ioc->sh->max_id - 1;
+
+	/* Following parameters will not change
+	 * in this routine.
+	 */
+	iocmd.cmd = CMD_SynchronizeCache;
+	iocmd.flags = 0;
+	iocmd.physDiskNum = -1;
+	iocmd.data = NULL;
+	iocmd.data_dma = -1;
+	iocmd.size = 0;
+	iocmd.rsvd = iocmd.rsvd2 = 0;
+
+	/* No SCSI hosts
+	 */
+	if (hd->Targets == NULL)
+		return 0;
+
+	/* Skip the host
+	 */
+	if (id == hostId)
+		id++;
+
+	/* Write SDP1 for all SCSI devices 
+	 * Alloc memory and set up config buffer
+	 */
+	if (hd->is_spi) {
+		if (ioc->spi_data.sdp1length > 0) {
+			pcfg1Data = (SCSIDevicePage1_t *)pci_alloc_consistent(ioc->pcidev,
+					 ioc->spi_data.sdp1length * 4, &cfg1_dma_addr);
+	
+			if (pcfg1Data != NULL) {
+				doConfig = 1;
+				header1.PageVersion = ioc->spi_data.sdp1version;
+				header1.PageLength = ioc->spi_data.sdp1length;
+				header1.PageNumber = 1;
+				header1.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+				cfg.hdr = &header1;
+				cfg.physAddr = cfg1_dma_addr;
+				cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+				cfg.dir = 1;
+				cfg.timeout = 0;
+			}
+		}
+	}
+
+	/* loop through all devices on this port
+	 */
+	while (bus < MPT_MAX_BUS) {
+		iocmd.bus = bus;
+		iocmd.id = id;
+		pTarget = hd->Targets[(int)id];
+
+		if (doConfig) {
+
+			/* Set the negotiation flags */
+			if (pTarget && (pTarget = hd->Targets[id]) && !pTarget->raidVolume) {
+				flags = pTarget->negoFlags;
+			} else {
+				flags = 0;
+				if (hd->ioc->spi_data.nvram && (hd->ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+					data = hd->ioc->spi_data.nvram[id];
+	
+					if (data & MPT_NVRAM_WIDE_DISABLE)
+						flags |= MPT_TARGET_NO_NEGO_WIDE;
+
+					factor = (data & MPT_NVRAM_SYNC_MASK) >> MPT_NVRAM_SYNC_SHIFT;
+					if ((factor == 0) || (factor == MPT_ASYNC))
+						flags |= MPT_TARGET_NO_NEGO_SYNC;
+				}
+			}
+	
+			/* Force to async, narrow */
+			mptscsih_setDevicePage1Flags(0, MPT_ASYNC, 0, &requested,
+					&configuration, flags);
+			pcfg1Data->RequestedParameters = le32_to_cpu(requested);
+			pcfg1Data->Reserved = 0;
+			pcfg1Data->Configuration = le32_to_cpu(configuration);
+			cfg.pageAddr = (bus<<8) | id;
+			mpt_config(hd->ioc, &cfg);
+		}
+
+		/* If target Ptr NULL or if this target is NOT a disk, skip.
+		 */
+	//	if (pTarget && ((pTarget->inq_data[0] & 0x1F) == 0)) {
+		if (pTarget) {
+			for (lun=0; lun <= MPT_LAST_LUN; lun++) {
+				/* If LUN present, issue the command
+				 */
+				if (pTarget->luns & (1<<lun)) {
+					iocmd.lun = lun;
+					(void) mptscsih_do_cmd(hd, &iocmd);
+				}
+			}
+		}
+
+		/* get next relevant device */
+		id++;
+
+		if (id == hostId)
+			id++;
+
+		if (id > max_id) {
+			id = 0;
+			bus++;
+		}
+	}
+
+	if (pcfg1Data) {
+		pci_free_consistent(ioc->pcidev, header1.PageLength * 4, pcfg1Data, cfg1_dma_addr);
+	}
+
+	return 0;
+}
+
+#ifndef MPTSCSIH_DISABLE_DOMAIN_VALIDATION
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_domainValidation - Top level handler for domain validation.
+ *	@hd: Pointer to MPT_SCSI_HOST structure.
+ *
+ *	Uses the ISR, but with special processing.
+ *	Called from schedule, should not be in interrupt mode.
+ *	While thread alive, do dv for all devices needing dv
+ *
+ *	Return: None.
+ */
+static void
+mptscsih_domainValidation(void *arg)
+{
+	MPT_SCSI_HOST		*hd = NULL;
+	MPT_ADAPTER		*ioc = NULL;
+	unsigned long		 flags;
+	int 			 id, maxid, dvStatus, did;
+	int			 ii, isPhysDisk;
+
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	dvtaskQ_active = 1;
+	if (dvtaskQ_release) {
+		dvtaskQ_active = 0;
+		spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+		return;
+	}
+	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+
+	/* For this ioc, loop through all devices and do dv to each device.
+	 * When complete with this ioc, search through the ioc list, and 
+	 * for each scsi ioc found, do dv for all devices. Exit when no
+	 * device needs dv.
+	 */
+	did = 1;
+	while (did) {
+		did = 0;
+		for (ioc = mpt_adapter_find_first(); ioc != NULL; ioc = mpt_adapter_find_next(ioc)) {
+			spin_lock_irqsave(&dvtaskQ_lock, flags);
+			if (dvtaskQ_release) {
+				dvtaskQ_active = 0;
+				spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+				return;
+			}
+			spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/4);
+
+			/* DV only to SCSI adapters */
+			if ((int)ioc->chip_type <= (int)FC929)
+				continue;
+			
+			/* Make sure everything looks ok */
+			if (ioc->sh == NULL)
+				continue;
+
+			hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
+			if (hd == NULL)
+				continue;
+
+			maxid = MIN (ioc->sh->max_id, MPT_MAX_SCSI_DEVICES);
+
+			for (id = 0; id < maxid; id++) {
+				spin_lock_irqsave(&dvtaskQ_lock, flags);
+				if (dvtaskQ_release) {
+					dvtaskQ_active = 0;
+					spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+					return;
+				}
+				spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+				dvStatus = hd->ioc->spi_data.dvStatus[id];
+
+				if (dvStatus & MPT_SCSICFG_NEED_DV) {
+
+					hd->ioc->spi_data.dvStatus[id] |= MPT_SCSICFG_DV_PENDING;
+					hd->ioc->spi_data.dvStatus[id] &= ~MPT_SCSICFG_NEED_DV;
+
+					set_current_state(TASK_INTERRUPTIBLE);
+					schedule_timeout(HZ/4);
+
+					/* If hidden phys disk, block IO's to all
+					 *	raid volumes
+					 * else, process normally
+					 */
+					isPhysDisk = 0;
+					if (ioc->spi_data.pIocPg3) {
+						/* Search IOC page 3 to determine if
+						 * this is hidden physical disk
+						 */
+						Ioc3PhysDisk_t *pPDisk =  ioc->spi_data.pIocPg3->PhysDisk;
+						int		numPDisk = ioc->spi_data.pIocPg3->NumPhysDisks;
+						
+						while (numPDisk) {
+							if (pPDisk->PhysDiskID == id) {
+								isPhysDisk = 1;
+								break;
+							}
+							pPDisk++;
+							numPDisk--;
+						}
+					}
+
+					if (isPhysDisk) {
+						for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+							if (hd->ioc->spi_data.isRaid & (1 << ii)) {
+								hd->ioc->spi_data.dvStatus[ii] |= MPT_SCSICFG_DV_PENDING;
+							}
+						}
+					}
+
+					mptscsih_doDv(hd, 0, id);
+					did++;
+					hd->ioc->spi_data.dvStatus[id] |= MPT_SCSICFG_DV_DONE;
+					hd->ioc->spi_data.dvStatus[id] &= ~MPT_SCSICFG_DV_PENDING;
+
+					if (isPhysDisk) {
+						for (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {
+							if (hd->ioc->spi_data.isRaid & (1 << ii)) {
+								hd->ioc->spi_data.dvStatus[ii] &= ~MPT_SCSICFG_DV_PENDING;
+							}
+						}
+					}
+
+					/* Post OS IOs that were pended while
+					 * DV running.
+					 */
+					post_pendingQ_commands(hd);
+				}
+			}
+		}
+	}
+
+	spin_lock_irqsave(&dvtaskQ_lock, flags);
+	dvtaskQ_active = 0;
+	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
+
+	return;
+}
+
+
+#define MPT_GET_NVRAM_VALS	0x01
+#define MPT_UPDATE_MAX		0x02
+#define MPT_SET_MAX		0x04
+#define MPT_SET_MIN		0x08
+#define MPT_FALLBACK		0x10
+#define MPT_SAVE		0x20
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mptscsih_doDv - Perform domain validation to a target.
+ *	@hd: Pointer to MPT_SCSI_HOST structure.
+ *	@portnum: IOC port number.
+ *	@target: Physical ID of this target
+ *
+ *	Uses the ISR, but with special processing.
+ *	MUST be single-threaded.
+ *	Test will exit if target is at async & narrow.
+ *
+ *	Return: None.
+ */
+static void
+mptscsih_doDv(MPT_SCSI_HOST *hd, int portnum, int id)
+{
+	MPT_ADAPTER		*ioc = hd->ioc;
+	VirtDevice		*pTarget = NULL;
+	u8			*pbuf1 = NULL;
+	u8			*pbuf2 = NULL;
+	dma_addr_t		 buf1_dma = -1;
+	dma_addr_t		 buf2_dma = -1;
+	ConfigPageHeader_t	 header1;
+	SCSIDevicePage1_t	*pcfg1Data = NULL;
+	dma_addr_t		 cfg1_dma_addr = -1;
+	ConfigPageHeader_t	 header0;
+	SCSIDevicePage0_t	*pcfg0Data = NULL;
+	dma_addr_t		 cfg0_dma_addr = -1;
+	DVPARAMETERS		 dv;
+	INTERNAL_CMD		 iocmd;
+	CONFIGPARMS		 cfg;
+	int			 rc, sz = 0;
+	int			 bufsize = 0;
+	int			 dataBufSize = 0;
+	int			 echoBufSize = 0;
+	int			 notDone;
+	int			 patt;
+	int			 repeat;
+	char			 firstPass = 1;
+	char			 doFallback = 0;
+	char			 readPage0;
+	char			 bus, lun;
+
+	if (ioc->spi_data.sdp1length == 0)
+		return;
+
+	if (ioc->spi_data.sdp0length == 0)
+		return;
+
+	if (id == ioc->pfacts[portnum].PortSCSIID)
+		return;
+
+	lun = 0;
+	bus = 0;
+	ddvtprintk((MYIOC_s_NOTE_FMT 
+			"DV started: numIOs %d bus=%d, id %d dv @ %p\n",
+			ioc->name, atomic_read(&queue_depth), bus, id, &dv));
+
+	/* Prep DV structure
+	 */
+	memset (&dv, 0, sizeof(DVPARAMETERS));
+	dv.id = id;
+
+	/* Populate tmax with the current maximum
+	 * transfer parameters for this target.
+	 * Exit if narrow and async.
+	 */
+	dv.cmd = MPT_GET_NVRAM_VALS;
+	mptscsih_dv_parms(hd, &dv, NULL);
+	if ((!dv.max.width) && (!dv.max.offset))
+		return;
+
+	/* Prep SCSI IO structure
+	 */
+	iocmd.id = id;
+	iocmd.bus = bus;
+	iocmd.lun = lun;
+	iocmd.flags = 0;
+	iocmd.physDiskNum = -1;
+	iocmd.rsvd = iocmd.rsvd2 = 0;
+
+	/* Use tagged commands if possible.
+	 */
+	pTarget = hd->Targets[id];
+	if (pTarget && (pTarget->tflags & MPT_TARGET_FLAGS_Q_YES))
+		iocmd.flags |= MPT_ICFLAG_TAGGED_CMD;
+
+	/* Prep cfg structure
+	 */
+	cfg.pageAddr = (bus<<8) | id;
+	cfg.hdr = NULL;
+
+	/* Prep SDP0 header
+	 */
+	header0.PageVersion = ioc->spi_data.sdp0version;
+	header0.PageLength = ioc->spi_data.sdp0length;
+	header0.PageNumber = 0;
+	header0.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+	pcfg0Data = (SCSIDevicePage0_t *)pci_alloc_consistent(ioc->pcidev,
+				 header0.PageLength * 4, &cfg0_dma_addr);
+	if (!pcfg0Data)
+		return;
+
+	/* Prep SDP1 header
+	 */
+	header1.PageVersion = ioc->spi_data.sdp1version;
+	header1.PageLength = ioc->spi_data.sdp1length;
+	header1.PageNumber = 1;
+	header1.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
+	pcfg1Data = (SCSIDevicePage1_t *)pci_alloc_consistent(ioc->pcidev,
+				 header1.PageLength * 4, &cfg1_dma_addr);
+	if (!pcfg1Data)
+		goto target_done;
+
+	/* Skip this ID? Set cfg.hdr to force config page write
+	 */
+	if ((ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID) &&
+			(!(ioc->spi_data.nvram[id] & MPT_NVRAM_ID_SCAN_ENABLE))) { 
+
+		ddvprintk((MYIOC_s_NOTE_FMT "DV Skipped: bus, id, lun (%d, %d, %d)\n",
+			ioc->name, bus, id, lun));
+
+		dv.cmd = MPT_SET_MAX;
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+		cfg.hdr = &header1;
+		goto target_done;
+	}
+
+	/* Finish iocmd inititialization - hidden or visible disk? */
+	if (ioc->spi_data.pIocPg3) {
+		/* Searc IOC page 3 for matching id
+		 */
+		Ioc3PhysDisk_t *pPDisk =  ioc->spi_data.pIocPg3->PhysDisk;
+		int		numPDisk = ioc->spi_data.pIocPg3->NumPhysDisks;
+
+		while (numPDisk) {
+			if (pPDisk->PhysDiskID == id) {
+				/* match */
+				iocmd.flags |= MPT_ICFLAG_PHYS_DISK;
+				iocmd.physDiskNum = pPDisk->PhysDiskNum;
+
+				/* Quiesce the IM
+				 */
+				if (mptscsih_do_raid(hd, MPI_RAID_ACTION_QUIESCE_PHYS_IO, &iocmd) < 0) {
+					ddvprintk((MYIOC_s_ERR_FMT "RAID Queisce FAILED!\n", ioc->name));
+					goto target_done;
+				}
+				break;
+			}
+			pPDisk++;
+			numPDisk--;
+		}
+	}
+
+	/* RAID Volume ID's may double for a physical device. If RAID but
+	 * not a physical ID as well, skip DV.
+	 */
+	if ((hd->ioc->spi_data.isRaid & (1 << id)) && !(iocmd.flags & MPT_ICFLAG_PHYS_DISK))
+		goto target_done;
+
+
+	/* Basic Test.
+	 * Async & Narrow - Inquiry
+	 * Async & Narrow - Inquiry
+	 * Maximum transfer rate - Inquiry
+	 * Compare buffers:
+	 *	If compare, test complete.
+	 *	If miscompare and first pass, repeat
+	 *	If miscompare and not first pass, fall back and repeat
+	 */
+	hd->pLocal = NULL;
+	readPage0 = 0;
+	sz = SCSI_STD_INQUIRY_BYTES;
+	pbuf1 = pci_alloc_consistent(ioc->pcidev, sz, &buf1_dma);
+	pbuf2 = pci_alloc_consistent(ioc->pcidev, sz, &buf2_dma);
+	if (!pbuf1 || !pbuf2)
+		goto target_done;
+
+	while (1) {
+		ddvprintk((MYIOC_s_NOTE_FMT "DV: Start Basic test.\n", ioc->name));
+		dv.cmd = MPT_SET_MIN;
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+		cfg.hdr = &header1;
+		cfg.physAddr = cfg1_dma_addr;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+		cfg.dir = 1;
+		if (mpt_config(hd->ioc, &cfg) != 0)
+			goto target_done;
+
+		iocmd.cmd = CMD_Inquiry;
+		iocmd.data_dma = buf1_dma;
+		iocmd.data = pbuf1;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+
+		/* Another GEM workaround. Check peripheral device type,
+		 * if PROCESSOR, quit DV.
+		 */
+		if (((pbuf1[0] & 0x1F) == 0x03) || ((pbuf1[0] & 0x1F) > 0x08))
+			goto target_done;
+
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+
+		if (doFallback)
+			dv.cmd = MPT_FALLBACK;
+		else
+			dv.cmd = MPT_SET_MAX;
+
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+		if (mpt_config(hd->ioc, &cfg) != 0)
+			goto target_done;
+
+		if ((!dv.now.width) && (!dv.now.offset))
+			goto target_done;
+
+		iocmd.cmd = CMD_Inquiry;
+		iocmd.data_dma = buf2_dma;
+		iocmd.data = pbuf2;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+		else if (hd->pLocal == NULL)
+			goto target_done;
+		else {
+			/* Save the return code.
+			 * If this is the first pass,
+			 * read SCSI Device Page 0
+			 * and update the target max parameters.
+			 */
+			rc = hd->pLocal->completion;
+			doFallback = 0;
+			if (rc == MPT_SCANDV_GOOD) {
+				if (!readPage0) {
+					u32 sdp0_info;
+					u32 sdp0_nego;
+
+					cfg.hdr = &header0;
+					cfg.physAddr = cfg0_dma_addr;
+					cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
+					cfg.dir = 0;
+					if (mpt_config(hd->ioc, &cfg) != 0)
+						goto target_done;
+
+					sdp0_info = le32_to_cpu(pcfg0Data->Information) & 0x0E;
+					sdp0_nego = (le32_to_cpu(pcfg0Data->NegotiatedParameters) & 0xFF00 ) >> 8;
+
+					/* Quantum and Fujitsu workarounds.
+					 * Quantum: PPR U320 -> PPR reply with Ultra2 and wide
+					 * Fujitsu: PPR U320 -> Msg Reject and Ultra2 and wide
+					 * Resetart with a request for U160.
+					 */
+					if ((dv.now.factor == MPT_ULTRA320) && (sdp0_nego == MPT_ULTRA2)) { 
+							doFallback = 1;
+					} else {
+						dv.cmd = MPT_UPDATE_MAX;
+						mptscsih_dv_parms(hd, &dv, (void *)pcfg0Data);
+						/* Update the SCSI device page 1 area
+						 */
+						pcfg1Data->RequestedParameters = pcfg0Data->NegotiatedParameters;
+						readPage0 = 1;
+					}
+				}
+
+				/* Quantum workaround. Restart this test will the fallback
+				 * flag set.
+				 */
+				if (doFallback == 0) {
+					if (memcmp(pbuf1, pbuf2, sz) != 0) {
+						if (!firstPass)
+							doFallback = 1;
+					} else
+						break;	/* test complete */
+				}
+
+
+			} else if ((rc == MPT_SCANDV_DID_RESET) || (rc == MPT_SCANDV_SENSE))
+				doFallback = 1;	/* set fallback flag */
+			else
+				goto target_done;
+
+			firstPass = 0;
+		}
+	}
+	/* Free pbuf2, but use pbuf1 for
+	 * acquiring the (echo) buffer size.
+	 */
+	pci_free_consistent(ioc->pcidev, sz, pbuf2, buf2_dma);
+	pbuf2 = NULL;
+	ddvprintk((MYIOC_s_NOTE_FMT "DV: Basic test completed OK.\n", ioc->name));
+
+	/* Start the Enhanced Test.
+	 * 0) issue TUR to clear out check conditions
+	 * 1) read capacity of echo (regular) buffer
+	 * 2) reserve device
+	 * 3) do write-read-compare data pattern test
+	 * 4) release
+	 * 5) update nego parms to target struct
+	 */
+	cfg.hdr = &header1;
+	cfg.physAddr = cfg1_dma_addr;
+	cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+	cfg.dir = 1;
+
+	iocmd.cmd = CMD_TestUnitReady;
+	iocmd.data_dma = -1;
+	iocmd.data = NULL;
+	iocmd.size = 0;
+	notDone = 1;
+	while (notDone) {
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+
+		if (hd->pLocal == NULL)
+			goto target_done;
+
+		rc = hd->pLocal->completion;
+		if (rc == MPT_SCANDV_GOOD)
+			notDone = 0;
+		else if (rc == MPT_SCANDV_SENSE) {
+			u8 skey = hd->pLocal->sense[2] & 0x0F;
+			u8 asc = hd->pLocal->sense[12];
+			u8 ascq = hd->pLocal->sense[13];
+			ddvprintk((MYIOC_s_INFO_FMT
+				"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
+				ioc->name, skey, asc, ascq));
+
+			if (skey == SK_UNIT_ATTENTION)
+				notDone++; /* repeat */
+			else if ((skey == SK_NOT_READY) &&
+					(asc == 0x04)&&(ascq == 0x01)) {
+				/* wait then repeat */
+				mdelay (2000);
+				notDone++;
+			} else if ((skey == SK_NOT_READY) && (asc == 0x3A)) {
+				/* no medium, try read test anyway */
+				notDone = 0;
+			} else {
+				/* All other errors are fatal.
+				 */
+				ddvprintk((MYIOC_s_INFO_FMT "DV: fatal error.",
+						ioc->name));
+				goto target_done;
+			}
+		} else
+			goto target_done;
+	}
+
+	iocmd.cmd = CMD_ReadBuffer;
+	iocmd.data_dma = buf1_dma;
+	iocmd.data = pbuf1;
+	iocmd.size = 4;
+	iocmd.flags |= MPT_ICFLAG_BUF_CAP;
+
+	dataBufSize = 0;
+	echoBufSize = 0;
+	for (patt = 0; patt < 2; patt++) {
+		if (patt == 0)
+			iocmd.flags |= MPT_ICFLAG_ECHO;
+		else
+			iocmd.flags &= ~MPT_ICFLAG_ECHO;
+
+		notDone = 1;
+		while (notDone) {
+			bufsize = 0;
+
+			/* If not ready after 8 trials,
+			 * give up on this device.
+			 */
+			if (notDone > 8)
+				goto target_done;
+
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+			else if (hd->pLocal == NULL)
+				goto target_done;
+			else {
+				rc = hd->pLocal->completion;
+				ddvprintk(("ReadBuffer Comp Code %d", rc));
+				ddvprintk(("  buff: %0x %0x %0x %0x\n",
+					pbuf1[0], pbuf1[1], pbuf1[2], pbuf1[3]));
+
+				if (rc == MPT_SCANDV_GOOD) {
+					notDone = 0;
+					if (iocmd.flags & MPT_ICFLAG_ECHO) {
+						bufsize =  ((pbuf1[2] & 0x1F) <<8) | pbuf1[3];
+					} else {
+						bufsize =  pbuf1[1]<<16 | pbuf1[2]<<8 | pbuf1[3];
+					}
+				} else if (rc == MPT_SCANDV_SENSE) {
+					u8 skey = hd->pLocal->sense[2] & 0x0F;
+					u8 asc = hd->pLocal->sense[12];
+					u8 ascq = hd->pLocal->sense[13];
+					ddvprintk((MYIOC_s_INFO_FMT
+						"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
+						ioc->name, skey, asc, ascq));
+					if (skey == SK_ILLEGAL_REQUEST) {
+						notDone = 0;
+					} else if (skey == SK_UNIT_ATTENTION) {
+						notDone++; /* repeat */
+					} else if ((skey == SK_NOT_READY) &&
+						(asc == 0x04)&&(ascq == 0x01)) {
+						/* wait then repeat */
+						mdelay (2000);
+						notDone++;
+					} else {
+						/* All other errors are fatal.
+						 */
+						ddvprintk((MYIOC_s_INFO_FMT "DV: fatal error.",
+							ioc->name));
+						goto target_done;
+					}
+				} else {
+					/* All other errors are fatal
+					 */
+					goto target_done;
+				}
+			}
+		}
+
+		if (iocmd.flags & MPT_ICFLAG_ECHO)
+			echoBufSize = bufsize;
+		else
+			dataBufSize = bufsize;
+	}
+	pci_free_consistent(ioc->pcidev, sz, pbuf1, buf1_dma);
+	pbuf1 = NULL;
+	sz = 0;
+	iocmd.flags &= ~MPT_ICFLAG_BUF_CAP;
+
+	/* Use echo buffers if possible,
+	 * Exit if both buffers are 0.
+	 */
+	if (echoBufSize > 0) {
+		iocmd.flags |= MPT_ICFLAG_ECHO;
+		if (dataBufSize > 0)
+			bufsize = MIN(echoBufSize, dataBufSize);
+		else
+			bufsize = echoBufSize;
+	} else if (dataBufSize == 0)
+		goto target_done;
+
+	ddvprintk((MYIOC_s_INFO_FMT "%s Buffer Capacity %d\n", ioc->name,
+		(iocmd.flags & MPT_ICFLAG_ECHO) ? "Echo" : " ", bufsize));
+
+	/* Allocate data buffers for write-read-compare test.
+	 */
+	sz = MIN(bufsize, 1024);
+	pbuf1 = pci_alloc_consistent(ioc->pcidev, sz, &buf1_dma);
+	pbuf2 = pci_alloc_consistent(ioc->pcidev, sz, &buf2_dma);
+	if (!pbuf1 || !pbuf2)
+		goto target_done;
+
+	/* --- loop ----
+	 * On first pass, always issue a reserve.
+	 * On additional loops, only if a reset has occurred.
+	 * iocmd.flags indicates if echo or regular buffer
+	 */
+	for (patt = 0; patt < 4; patt++) {
+		ddvprintk(("Pattern %d\n", patt));
+		if ((iocmd.flags & MPT_ICFLAG_RESERVED) && (iocmd.flags & MPT_ICFLAG_DID_RESET)) {
+			iocmd.cmd = CMD_TestUnitReady;
+			iocmd.data_dma = -1;
+			iocmd.data = NULL;
+			iocmd.size = 0;
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+
+			iocmd.cmd = CMD_Release6;
+			iocmd.data_dma = -1;
+			iocmd.data = NULL;
+			iocmd.size = 0;
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+			else if (hd->pLocal == NULL)
+				goto target_done;
+			else {
+				rc = hd->pLocal->completion;
+				ddvprintk(("Release rc %d\n", rc));
+				if (rc == MPT_SCANDV_GOOD)
+					iocmd.flags &= ~MPT_ICFLAG_RESERVED;
+				else
+					goto target_done;
+			}
+			iocmd.flags &= ~MPT_ICFLAG_RESERVED;
+		}
+		iocmd.flags &= ~MPT_ICFLAG_DID_RESET;
+
+		repeat = 5;
+		while (repeat && (!(iocmd.flags & MPT_ICFLAG_RESERVED))) {
+			iocmd.cmd = CMD_Reserve6;
+			iocmd.data_dma = -1;
+			iocmd.data = NULL;
+			iocmd.size = 0;
+			if (mptscsih_do_cmd(hd, &iocmd) < 0)
+				goto target_done;
+			else if (hd->pLocal == NULL)
+				goto target_done;
+			else {
+				rc = hd->pLocal->completion;
+				if (rc == MPT_SCANDV_GOOD) {
+					iocmd.flags |= MPT_ICFLAG_RESERVED;
+				} else if (rc == MPT_SCANDV_SENSE) {
+					/* Wait if coming ready
+					 */
+					u8 skey = hd->pLocal->sense[2] & 0x0F;
+					u8 asc = hd->pLocal->sense[12];
+					u8 ascq = hd->pLocal->sense[13];
+					ddvprintk((MYIOC_s_INFO_FMT
+						"DV: Reserve Failed: ", ioc->name));
+					ddvprintk(("SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n",
+							skey, asc, ascq));
+
+					if ((skey == SK_NOT_READY) && (asc == 0x04)&&
+									(ascq == 0x01)) {
+						/* wait then repeat */
+						mdelay (2000);
+						notDone++;
+					} else {
+						ddvprintk((MYIOC_s_INFO_FMT 
+							"DV: Reserved Failed.", ioc->name));
+						goto target_done;
+					}
+				} else {
+					ddvprintk((MYIOC_s_INFO_FMT "DV: Reserved Failed.",
+							 ioc->name));
+					goto target_done;
+				}
+			}
+		}
+
+		mptscsih_fillbuf(pbuf1, sz, patt, 1);
+		iocmd.cmd = CMD_WriteBuffer;
+		iocmd.data_dma = buf1_dma;
+		iocmd.data = pbuf1;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+		else if (hd->pLocal == NULL)
+			goto target_done;
+		else {
+			rc = hd->pLocal->completion;
+			if (rc == MPT_SCANDV_GOOD)
+				;		/* Issue read buffer */
+			else if (rc == MPT_SCANDV_DID_RESET) {
+				/* If using echo buffers, reset to data buffers.
+				 * Else do Fallback and restart
+				 * this test (re-issue reserve
+				 * because of bus reset).
+				 */
+				if ((iocmd.flags & MPT_ICFLAG_ECHO) && (dataBufSize >= bufsize)) {
+					iocmd.flags &= ~MPT_ICFLAG_ECHO;
+				} else {
+					dv.cmd = MPT_FALLBACK;
+					mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+					if (mpt_config(hd->ioc, &cfg) != 0)
+						goto target_done;
+
+					if ((!dv.now.width) && (!dv.now.offset))
+						goto target_done;
+				}
+
+				iocmd.flags |= MPT_ICFLAG_DID_RESET;
+				patt = -1;
+				continue;
+			} else if (rc == MPT_SCANDV_SENSE) {
+				/* Restart data test if UA, else quit.
+				 */
+				u8 skey = hd->pLocal->sense[2] & 0x0F;
+				ddvprintk((MYIOC_s_INFO_FMT
+					"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n", ioc->name, skey,
+					hd->pLocal->sense[12], hd->pLocal->sense[13]));
+				if (skey == SK_UNIT_ATTENTION) {
+					patt = -1;
+					continue;
+				} else if (skey == SK_ILLEGAL_REQUEST) {
+					if (iocmd.flags & MPT_ICFLAG_ECHO) {
+						if (dataBufSize >= bufsize) {
+							iocmd.flags &= ~MPT_ICFLAG_ECHO;
+							patt = -1;
+							continue;
+						}
+					} 
+					goto target_done;
+				}
+				else
+					goto target_done;
+			} else {
+				/* fatal error */
+				goto target_done;
+			}
+		}
+
+		iocmd.cmd = CMD_ReadBuffer;
+		iocmd.data_dma = buf2_dma;
+		iocmd.data = pbuf2;
+		iocmd.size = sz;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			goto target_done;
+		else if (hd->pLocal == NULL)
+			goto target_done;
+		else {
+			rc = hd->pLocal->completion;
+			if (rc == MPT_SCANDV_GOOD) {
+				 /* If buffers compare,
+				  * go to next pattern,
+				  * else, do a fallback and restart
+				  * data transfer test.
+				  */
+				if (memcmp (pbuf1, pbuf2, sz) == 0) {
+					; /* goto next pattern */
+				} else {
+					/* Miscompare with Echo buffer, go to data buffer,
+					 * if that buffer exists.
+					 * Miscompare with Data buffer, check first 4 bytes,
+					 * some devices return capacity. Exit in this case.
+					 */
+					if (iocmd.flags & MPT_ICFLAG_ECHO) {
+						if (dataBufSize >= bufsize)
+							iocmd.flags &= ~MPT_ICFLAG_ECHO;
+						else
+							goto target_done;
+					} else {
+						if (dataBufSize == (pbuf2[1]<<16 | pbuf2[2]<<8 | pbuf2[3])) {
+							/* Argh. Device returning wrong data.
+							 * Quit DV for this device.
+							 */
+							goto target_done;
+						}
+
+						/* Had an actual miscompare. Slow down.*/
+						dv.cmd = MPT_FALLBACK;
+						mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+						if (mpt_config(hd->ioc, &cfg) != 0)
+							goto target_done;
+
+						if ((!dv.now.width) && (!dv.now.offset))
+							goto target_done;
+					}
+
+					patt = -1;
+					continue;
+				}
+			} else if (rc == MPT_SCANDV_DID_RESET) {
+				/* Do Fallback and restart
+				 * this test (re-issue reserve
+				 * because of bus reset).
+				 */
+				dv.cmd = MPT_FALLBACK;
+				mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+				if (mpt_config(hd->ioc, &cfg) != 0)
+					 goto target_done;
+
+				if ((!dv.now.width) && (!dv.now.offset))
+					goto target_done;
+
+				iocmd.flags |= MPT_ICFLAG_DID_RESET;
+				patt = -1;
+				continue;
+			} else if (rc == MPT_SCANDV_SENSE) {
+				/* Restart data test if UA, else quit.
+				 */
+				u8 skey = hd->pLocal->sense[2] & 0x0F;
+				ddvprintk((MYIOC_s_INFO_FMT
+					"SenseKey:ASC:ASCQ = (%x:%02x:%02x)\n", ioc->name, skey,
+					hd->pLocal->sense[12], hd->pLocal->sense[13]));
+				if (skey == SK_UNIT_ATTENTION) {
+					patt = -1;
+					continue;
+				}
+				else
+					goto target_done;
+			} else {
+				/* fatal error */
+				goto target_done;
+			}
+		}
+
+	} /* --- end of patt loop ---- */
+
+target_done:
+	if (iocmd.flags & MPT_ICFLAG_RESERVED) {
+		iocmd.cmd = CMD_Release6;
+		iocmd.data_dma = -1;
+		iocmd.data = NULL;
+		iocmd.size = 0;
+		if (mptscsih_do_cmd(hd, &iocmd) < 0)
+			printk(MYIOC_s_INFO_FMT "DV: Release failed. id %d",
+					ioc->name, id);
+		else if (hd->pLocal) {
+			if (hd->pLocal->completion == MPT_SCANDV_GOOD)
+				iocmd.flags &= ~MPT_ICFLAG_RESERVED;
+		} else {
+			printk(MYIOC_s_INFO_FMT "DV: Release failed. id %d", 
+						ioc->name, id);
+		}
+	}
+
+
+	/* Set if cfg1_dma_addr contents is valid
+	 */
+	if (cfg.hdr != NULL) {
+		dv.cmd = MPT_SAVE;
+		mptscsih_dv_parms(hd, &dv, (void *)pcfg1Data);
+
+		/* Save the final negotiated settings to
+		 * SCSI device page 1.
+		 */
+		cfg.hdr = &header1;
+		cfg.physAddr = cfg1_dma_addr;
+		cfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;
+		cfg.dir = 1;
+		mpt_config(hd->ioc, &cfg);
+	}
+
+	/* If this is a RAID Passthrough, enable internal IOs
+	 */
+	if (iocmd.flags & MPT_ICFLAG_PHYS_DISK) {
+		if (mptscsih_do_raid(hd, MPI_RAID_ACTION_ENABLE_PHYS_IO, &iocmd) < 0)
+			ddvprintk((MYIOC_s_ERR_FMT "RAID Queisce FAILED!\n", ioc->name));
+	}
+
+	/* Done with the DV scan of the current target
+	 */
+	if (pcfg0Data) {
+		pci_free_consistent(ioc->pcidev, header0.PageLength * 4,
+						pcfg0Data, cfg0_dma_addr);
+	}
+
+	if (pcfg1Data) {
+		pci_free_consistent(ioc->pcidev, header1.PageLength * 4,
+						pcfg1Data, cfg1_dma_addr);
+	}
+
+	if (pbuf1) {
+		pci_free_consistent(ioc->pcidev, sz, pbuf1, buf1_dma);
+		pbuf1 = NULL;
+	}
+
+	if (pbuf2) {
+		pci_free_consistent(ioc->pcidev, sz, pbuf2, buf2_dma);
+		pbuf2 = NULL;
+	}
+
+	ddvtprintk((MYIOC_s_INFO_FMT "DV Done. IOs outstanding = %d\n",
+			ioc->name, atomic_read(&queue_depth)));
+
+	return;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*	mptscsih_dv_parms - perform a variety of operations on the
+ *	parameters used for negotiation.
+ *	@hd: Pointer to a SCSI host.
+ *	@dv: Pointer to a structure that contains the maximum and current
+ *		negotiated parameters.
+ */
+static void
+mptscsih_dv_parms(MPT_SCSI_HOST *hd, DVPARAMETERS *dv,void *pPage)
+{
+	VirtDevice		*pTarget = NULL;
+	SCSIDevicePage0_t	*pPage0 = NULL;
+	SCSIDevicePage1_t	*pPage1 = NULL;
+	int			val = 0, data, configuration;
+	u8			width = 0;
+	u8			offset = 0;
+	u8			factor = 0;
+	u8			negoFlags = 0;
+	u8			cmd = dv->cmd;
+	u8			id = dv->id;
+
+	switch (cmd) {
+	case MPT_GET_NVRAM_VALS:
+		ddvprintk((MYIOC_s_NOTE_FMT "Getting NVRAM: ",
+							 hd->ioc->name));
+		/* Get the NVRAM values and save in tmax
+		 * If not an LVD bus, the adapter minSyncFactor has been
+		 * already throttled back.
+		 */
+		if ((hd->Targets)&&((pTarget = hd->Targets[(int)id]) != NULL) && !pTarget->raidVolume) {
+			width = pTarget->maxWidth;
+			offset = pTarget->maxOffset;
+			factor = pTarget->minSyncFactor;
+			negoFlags = pTarget->negoFlags;
+		} else {
+			if (hd->ioc->spi_data.nvram && (hd->ioc->spi_data.nvram[id] != MPT_HOST_NVRAM_INVALID)) {
+				data = hd->ioc->spi_data.nvram[id];
+				width = data & MPT_NVRAM_WIDE_DISABLE ? 0 : 1;
+				if ((offset = hd->ioc->spi_data.maxSyncOffset) == 0)
+					factor = MPT_ASYNC;
+				else {
+					factor = (data & MPT_NVRAM_SYNC_MASK) >> MPT_NVRAM_SYNC_SHIFT;
+					if ((factor == 0) || (factor == MPT_ASYNC)){
+						factor = MPT_ASYNC;
+						offset = 0;
+					}
+				}
+			} else {
+				width = MPT_NARROW;
+				offset = 0;
+				factor = MPT_ASYNC;
+			}
+
+			/* Set the negotiation flags */
+			negoFlags = 0;
+			if (!width)
+				negoFlags |= MPT_TARGET_NO_NEGO_WIDE;
+
+			if (!offset)
+				negoFlags |= MPT_TARGET_NO_NEGO_SYNC;
+		}
+
+		/* limit by adapter capabilities */
+		width = MIN(width, hd->ioc->spi_data.maxBusWidth);
+		offset = MIN(offset, hd->ioc->spi_data.maxSyncOffset);
+		factor = MAX(factor, hd->ioc->spi_data.minSyncFactor);
+
+		/* Check Consistency */
+		if (offset && (factor < MPT_ULTRA2) && !width)
+			factor = MPT_ULTRA2;
+
+		dv->max.width = width;
+		dv->max.offset = offset;
+		dv->max.factor = factor;
+		dv->max.flags = negoFlags;
+		ddvprintk((" width %d, factor %x, offset %x flags %x\n",
+				width, factor, offset, negoFlags));
+		break;
+
+	case MPT_UPDATE_MAX:
+		ddvprintk((MYIOC_s_NOTE_FMT
+			"Updating with SDP0 Data: ", hd->ioc->name));
+		/* Update tmax values with those from Device Page 0.*/
+		pPage0 = (SCSIDevicePage0_t *) pPage;
+		if (pPage0) {
+			val = cpu_to_le32(pPage0->NegotiatedParameters);
+			dv->max.width = val & MPI_SCSIDEVPAGE0_NP_WIDE ? 1 : 0;
+			dv->max.offset = (val&MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) >> 16;
+			dv->max.factor = (val&MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;
+		}
+
+		dv->now.width = dv->max.width;
+		dv->now.offset = dv->max.offset;
+		dv->now.factor = dv->max.factor;
+		ddvprintk(("width %d, factor %x, offset %x, flags %x\n",
+				dv->now.width, dv->now.factor, dv->now.offset, dv->now.flags));
+		break;
+
+	case MPT_SET_MAX:
+		ddvprintk((MYIOC_s_NOTE_FMT "Setting Max: ",
+								hd->ioc->name));
+		/* Set current to the max values. Update the config page.*/
+		dv->now.width = dv->max.width;
+		dv->now.offset = dv->max.offset;
+		dv->now.factor = dv->max.factor;
+		dv->now.flags = dv->max.flags;
+
+		pPage1 = (SCSIDevicePage1_t *)pPage;
+		if (pPage1) {
+			mptscsih_setDevicePage1Flags (dv->now.width, dv->now.factor,
+				dv->now.offset, &val, &configuration, dv->now.flags);
+			pPage1->RequestedParameters = le32_to_cpu(val);
+			pPage1->Reserved = 0;
+			pPage1->Configuration = le32_to_cpu(configuration);
+
+		}
+
+		ddvprintk(("width %d, factor %x, offset %x request %x, config %x\n",
+				dv->now.width, dv->now.factor, dv->now.offset, val, configuration));
+		break;
+
+	case MPT_SET_MIN:
+		ddvprintk((MYIOC_s_NOTE_FMT "Setting Min: ",
+								hd->ioc->name));
+		/* Set page to asynchronous and narrow 
+		 * Do not update now, breaks fallback routine. */
+		width = MPT_NARROW;
+		offset = 0;
+		factor = MPT_ASYNC;
+		negoFlags = dv->max.flags;
+
+		pPage1 = (SCSIDevicePage1_t *)pPage;
+		if (pPage1) {
+			mptscsih_setDevicePage1Flags (width, factor,
+				offset, &val, &configuration, negoFlags);
+			pPage1->RequestedParameters = le32_to_cpu(val);
+			pPage1->Reserved = 0;
+			pPage1->Configuration = le32_to_cpu(configuration);
+		}
+		ddvprintk(("width %d, factor %x, offset %x request %x config %x\n",
+				dv->now.width, dv->now.factor,
+				dv->now.offset, val, configuration));
+		break;
+
+	case MPT_FALLBACK:
+		ddvprintk((MYIOC_s_NOTE_FMT
+			"Fallback: Start: offset %d, factor %x, width %d \n",
+				hd->ioc->name, dv->now.offset, 
+				dv->now.factor, dv->now.width));
+		width = dv->now.width;
+		offset = dv->now.offset;
+		factor = dv->now.factor;
+		if ((offset) && (dv->max.width)) {
+			if (factor < MPT_ULTRA160)
+				factor = MPT_ULTRA160;
+			else if (factor < MPT_ULTRA2) {
+				factor = MPT_ULTRA2;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_ULTRA2) && width) {
+				factor = MPT_ULTRA2;
+				width = MPT_NARROW;
+			} else if (factor < MPT_ULTRA) {
+				factor = MPT_ULTRA;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_ULTRA) && width) {
+				factor = MPT_ULTRA;
+				width = MPT_NARROW;
+			} else if (factor < MPT_FAST) {
+				factor = MPT_FAST;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_FAST) && width) {
+				factor = MPT_FAST;
+				width = MPT_NARROW;
+			} else if (factor < MPT_SCSI) {
+				factor = MPT_SCSI;
+				width = MPT_WIDE;
+			} else if ((factor == MPT_SCSI) && width) {
+				factor = MPT_SCSI;
+				width = MPT_NARROW;
+			} else {
+				factor = MPT_ASYNC;
+				offset = 0;
+			}
+
+		} else if (offset) {
+			width = MPT_NARROW;
+			if (factor < MPT_ULTRA)
+				factor = MPT_ULTRA;
+			else if (factor < MPT_FAST)
+				factor = MPT_FAST;
+			else if (factor < MPT_SCSI)
+				factor = MPT_SCSI;
+			else {
+				factor = MPT_ASYNC;
+				offset = 0;
+			}
 
-	if (SD_Sense_Key_Specific_Valid(sd)) {
-		if (SenseKey == SK_ILLEGAL_REQUEST) {
-			Offset = SD_Bad_Byte(sd);
-			if (SD_Was_Illegal_Request(sd)) {
-				BadValue = ioop->cdbPtr[Offset];
-				len += sprintf(msg1+len, "\n  Illegal CDB value=%02Xh found at CDB ",
-						BadValue);
 		} else {
-			BadValue = ioop->dataPtr[Offset];
-			len += sprintf(msg1+len, "\n  Illegal DATA value=%02Xh found at DATA ",
-					BadValue);
+			width = MPT_NARROW;
+			factor = MPT_ASYNC;
 		}
-		len += sprintf(msg1+len, "byte=%02Xh", Offset);
-		if (SD_SKS_Bit_Pointer_Valid(sd))
-			len += sprintf(msg1+len, "/bit=%1Xh", SD_SKS_Bit_Pointer(sd));
-		} else if ((SenseKey == SK_RECOVERED_ERROR) ||
-			   (SenseKey == SK_HARDWARE_ERROR) ||
-			   (SenseKey == SK_MEDIUM_ERROR)) {
-			len += sprintf(msg1+len, "\n  Recovery algorithm Actual_Retry_Count=%02Xh",
-			SD_Actual_Retry_Count(sd));
+
+		dv->now.width = width;
+		dv->now.offset = offset;
+		dv->now.factor = factor;
+		dv->now.flags = dv->max.flags;
+
+		pPage1 = (SCSIDevicePage1_t *)pPage;
+		if (pPage1) {
+			mptscsih_setDevicePage1Flags (width, factor, offset, &val,
+						&configuration, dv->now.flags);
+
+			pPage1->RequestedParameters = le32_to_cpu(val);
+			pPage1->Reserved = 0;
+			pPage1->Configuration = le32_to_cpu(configuration);
 		}
-	}
-}
-#endif
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int dump_cdb(char *foo, unsigned char *cdb)
-{
-	int i, grpCode, cdbLen;
-	int l = 0;
+		ddvprintk(("Finish: offset %d, factor %x, width %d, request %x config %x\n",
+			     dv->now.offset, dv->now.factor, dv->now.width, val, configuration));
+		break;
 
-	grpCode = cdb[0] >> 5;
-	if (grpCode < 1)
-		cdbLen = 6;
-	else if (grpCode < 3)
-		cdbLen = 10;
-	else if (grpCode == 5)
-		cdbLen = 12;
-	else
-		cdbLen = 16;
+	case MPT_SAVE:
+		ddvprintk((MYIOC_s_NOTE_FMT
+			"Saving to Target structure: ", hd->ioc->name));
+		ddvprintk(("offset %d, factor %x, width %d \n",
+			     dv->now.offset, dv->now.factor, dv->now.width));
 
-	for (i=0; i < cdbLen; i++)
-		l += sprintf(foo+l, " %02X", cdb[i]);
+		/* Save these values to target structures
+		 * or overwrite nvram (phys disks only).
+		 */
 
-	return l;
-}
+		if ((hd->Targets)&&((pTarget = hd->Targets[(int)id]) != NULL) && !pTarget->raidVolume ) {
+			pTarget->maxWidth = dv->now.width;
+			pTarget->maxOffset = dv->now.offset;
+			pTarget->minSyncFactor = dv->now.factor;
+		} else {
+			/* Preserv all flags, use
+			 * read-modify-write algorithm
+			 */
+			data = hd->ioc->spi_data.nvram[id];
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int dump_sd(char *foo, unsigned char *sd)
-{
-	int snsLen = 8 + SD_Additional_Sense_Length(sd);
-	int l = 0;
-	int i;
+			if (dv->now.width)
+				data &= ~MPT_NVRAM_WIDE_DISABLE;
+			else
+				data |= MPT_NVRAM_WIDE_DISABLE;
 
-	for (i=0; i < MIN(snsLen,18); i++)
-		l += sprintf(foo+l, " %02X", sd[i]);
-	l += sprintf(foo+l, "%s", snsLen>18 ? " ..." : "");
+			if (!dv->now.offset)
+				factor = MPT_ASYNC;
 
-	return l;
+			data &= ~MPT_NVRAM_SYNC_MASK;
+			data |= (dv->now.factor << MPT_NVRAM_SYNC_SHIFT) & MPT_NVRAM_SYNC_MASK;
+
+			hd->ioc->spi_data.nvram[id] = data;
+		}
+		break;
+	}
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*  Do ASC/ASCQ lookup/grindage to English readable string(s)  */
-static const char * ascq_set_strings_4max(
-		u8 ASC, u8 ASCQ,
-		const char **s1, const char **s2, const char **s3, const char **s4)
+/*	mptscsih_fillbuf - fill a buffer with a special data pattern
+ *		cleanup. For bus scan only.
+ *
+ *	@buffer: Pointer to data buffer to be filled.
+ *	@size: Number of bytes to fill
+ *	@index: Pattern index
+ *	@width: bus width, 0 (8 bits) or 1 (16 bits)
+ */
+static void
+mptscsih_fillbuf(char *buffer, int size, int index, int width)
 {
-	static const char *asc_04_part1_string = "LOGICAL UNIT ";
-	static const char *asc_04_part2a_string = "NOT READY, ";
-	static const char *asc_04_part2b_string = "IS ";
-	static const char *asc_04_ascq_NN_part3_strings[] = {	/* ASC ASCQ (hex) */
-	  "CAUSE NOT REPORTABLE",				/* 04 00 */
-	  "IN PROCESS OF BECOMING READY",			/* 04 01 */
-	  "INITIALIZING CMD. REQUIRED",				/* 04 02 */
-	  "MANUAL INTERVENTION REQUIRED",			/* 04 03 */
-	  /* Add	" IN PROGRESS" to all the following... */
-	  "FORMAT",						/* 04 04 */
-	  "REBUILD",						/* 04 05 */
-	  "RECALCULATION",					/* 04 06 */
-	  "OPERATION",						/* 04 07 */
-	  "LONG WRITE",						/* 04 08 */
-	  "SELF-TEST",						/* 04 09 */
-	  NULL
-	};
-	static char *asc_04_part4_string = " IN PROGRESS";
+	char *ptr = buffer;
+	int ii;
+	char byte;
+	short val;
 
-	static char *asc_29_ascq_NN_strings[] = {		/* ASC ASCQ (hex) */
-	  "POWER ON, RESET, OR BUS DEVICE RESET OCCURRED",	/* 29 00 */
-	  "POWER ON OCCURRED",					/* 29 01 */
-	  "SCSI BUS RESET OCCURRED",				/* 29 02 */
-	  "BUS DEVICE RESET FUNCTION OCCURRED",			/* 29 03 */
-	  "DEVICE INTERNAL RESET",				/* 29 04 */
-	  "TRANSCEIVER MODE CHANGED TO SINGLE-ENDED",		/* 29 05 */
-	  "TRANSCEIVER MODE CHANGED TO LVD",			/* 29 06 */
-	  NULL
-	};
-	static char *ascq_vendor_uniq = "(Vendor Unique)";
-	static char *ascq_noone = "(no matching ASC/ASCQ description found)";
-	int idx;
+	switch (index) {
+	case 0:
 
-	*s1 = *s2 = *s3 = *s4 = "";		/* set'em all to the empty "" string */
+		if (width) {
+			/* Pattern:  0000 FFFF 0000 FFFF
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x02)
+					*ptr = 0xFF;
+				else
+					*ptr = 0x00;
+			}
+		} else {
+			/* Pattern:  00 FF 00 FF
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x01)
+					*ptr = 0xFF;
+				else
+					*ptr = 0x00;
+			}
+		}
+		break;
 
-	/* CHECKME! Need lock/sem?
-	 *  Update and examine for isense module presense.
-	 */
-	mptscsih_ASCQ_TablePtr = (ASCQ_Table_t *)mpt_v_ASCQ_TablePtr;
+	case 1:
+		if (width) {
+			/* Pattern:  5555 AAAA 5555 AAAA 5555
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x02)
+					*ptr = 0xAA;
+				else
+					*ptr = 0x55;
+			}
+		} else {
+			/* Pattern:  55 AA 55 AA 55
+			 */
+			for (ii=0; ii < size; ii++, ptr++) {
+				if (ii & 0x01)
+					*ptr = 0xAA;
+				else
+					*ptr = 0x55;
+			}
+		}
+		break;
 
-	if (mptscsih_ASCQ_TablePtr == NULL) {
-		/* 2nd chances... */
-		if (ASC == 0x04 && (ASCQ < sizeof(asc_04_ascq_NN_part3_strings)/sizeof(char*)-1)) {
-			*s1 = asc_04_part1_string;
-			*s2 = (ASCQ == 0x01) ? asc_04_part2b_string : asc_04_part2a_string;
-			*s3 = asc_04_ascq_NN_part3_strings[ASCQ];
-			/* check for " IN PROGRESS" ones */
-			if (ASCQ >= 0x04)
-				*s4 = asc_04_part4_string;
-		} else if (ASC == 0x29 && (ASCQ < sizeof(asc_29_ascq_NN_strings)/sizeof(char*)-1))
-			*s1 = asc_29_ascq_NN_strings[ASCQ];
-		/*
-		 *	else { leave all *s[1-4] values pointing to the empty "" string }
+	case 2:
+		/* Pattern:  00 01 02 03 04 05
+		 * ... FE FF 00 01..
 		 */
-		return *s1;
-	}
+		for (ii=0; ii < size; ii++, ptr++)
+			*ptr = (char) ii;
+		break;
 
-	/*
-	 *  Need to check ASC here; if it is "special," then
-	 *  the ASCQ is variable, and indicates failed component number.
-	 *  We must treat the ASCQ as a "don't care" while searching the
-	 *  mptscsih_ASCQ_Table[] by masking it off, and then restoring it later
-	 *  on when we actually need to identify the failed component.
-	 */
-	if (SPECIAL_ASCQ(ASC,ASCQ))
-		ASCQ = 0xFF;
+	case 3:
+		if (width) {
+			/* Wide Pattern:  FFFE 0001 FFFD 0002
+			 * ...  4000 DFFF 8000 EFFF
+			 */
+			byte = 0;
+			for (ii=0; ii < size/2; ii++) {
+				/* Create the base pattern
+				 */
+				val = (1 << byte);
+				/* every 64 (0x40) bytes flip the pattern
+				 * since we fill 2 bytes / iteration,
+				 * test for ii = 0x20
+				 */
+				if (ii & 0x20)
+					val = ~(val);
 
-	/*  OK, now search mptscsih_ASCQ_Table[] for a matching entry  */
-	for (idx = 0; mptscsih_ASCQ_TablePtr && idx < mpt_ASCQ_TableSz; idx++)
-		if ((ASC == mptscsih_ASCQ_TablePtr[idx].ASC) && (ASCQ == mptscsih_ASCQ_TablePtr[idx].ASCQ))
-			return (*s1 = mptscsih_ASCQ_TablePtr[idx].Description);
+				if (ii & 0x01) {
+					*ptr = (char)( (val & 0xFF00) >> 8);
+					ptr++;
+					*ptr = (char)(val & 0xFF);
+					byte++;
+					byte &= 0x0F;
+				} else {
+					val = ~val;
+					*ptr = (char)( (val & 0xFF00) >> 8);
+					ptr++;
+					*ptr = (char)(val & 0xFF);
+				}
 
-	if ((ASC >= 0x80) || (ASCQ >= 0x80))
-		*s1 = ascq_vendor_uniq;
-	else
-		*s1 = ascq_noone;
+				ptr++;
+			}
+		} else {
+			/* Narrow Pattern:  FE 01 FD 02 FB 04
+			 * .. 7F 80 01 FE 02 FD ...  80 7F
+			 */
+			byte = 0;
+			for (ii=0; ii < size; ii++, ptr++) {
+				/* Base pattern - first 32 bytes
+				 */
+				if (ii & 0x01) {
+					*ptr = (1 << byte);
+					byte++;
+					byte &= 0x07;
+				} else {
+					*ptr = (char) (~(1 << byte));
+				}
 
-	return *s1;
+				/* Flip the pattern every 32 bytes
+				 */
+				if (ii & 0x20)
+					*ptr = ~(*ptr);
+			}
+		}
+		break;
+	}
 }
+#endif /* ~MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/*
- *  SCSI Error Report; desired output format...
- *---
-SCSI Error Report =-=-=-=-=-=-=-=-=-=-=-=-=-= (ioc0,scsi0:0)
-  SCSI_Status=02h (CHECK CONDITION)
-  Original_CDB[]: 00 00 00 00 00 00 - TestUnitReady
-  SenseData[12h]: 70 00 06 00 00 00 00 0A 00 00 00 00 29 00 03 00 00 00
-  SenseKey=6h (UNIT ATTENTION); FRU=03h
-  ASC/ASCQ=29h/00h, "POWER ON, RESET, OR BUS DEVICE RESET OCCURRED"
- *---
+/* Commandline Parsing routines and defines.
+ *
+ * insmod format:
+ *	insmod mptscsih mptscsih="width:1 dv:n factor:0x09"
+ *  boot format:
+ *	mptscsih=width:1,dv:n,factor:0x8
+ *
  */
+#ifdef MODULE
+#define	ARG_SEP	' '
+#else
+#define	ARG_SEP	','
+#endif
 
-int mpt_ScsiHost_ErrorReport(IO_Info_t *ioop)
-{
-	char		 foo[512];
-	char		 buf2[32];
-	char		*statstr;
-	const char	*opstr;
-	int		 sk		= SD_Sense_Key(ioop->sensePtr);
-	const char	*skstr		= SenseKeyString[sk];
-	unsigned char	 asc		= SD_ASC(ioop->sensePtr);
-	unsigned char	 ascq		= SD_ASCQ(ioop->sensePtr);
-	int		 l;
+static char setup_token[] __initdata =
+	"dv:"
+	"width:"
+	"factor:"
+       ;	/* DONNOT REMOVE THIS ';' */
+
+#define OPT_DV			1
+#define OPT_MAX_WIDTH		2
+#define OPT_MIN_SYNC_FACTOR	3
 
-	/*
-	 *  More quiet mode.
-	 *  Filter out common, repetitive, warning-type errors...  like:
-	 *    POWER ON (06,29/00 or 06,29/01),
-	 *    SPINNING UP (02,04/01),
-	 *    LOGICAL UNIT NOT SUPPORTED (05,25/00), etc.
-	 */
-	if (	(sk==SK_UNIT_ATTENTION	&& asc==0x29 && (ascq==0x00 || ascq==0x01))
-	     || (sk==SK_NOT_READY	&& asc==0x04 && ascq==0x01)
-	     || (sk==SK_ILLEGAL_REQUEST && asc==0x25 && ascq==0x00)
-	   )
-	{
-		/* Do nothing! */
-		return 0;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+__init get_setup_token(char *p)
+{
+	char *cur = setup_token;
+	char *pc;
+	int i = 0;
+
+	while (cur != NULL && (pc = strchr(cur, ':')) != NULL) {
+		++pc;
+		++i;
+		if (!strncmp(p, cur, pc - cur))
+			return i;
+		cur = pc;
 	}
+	return 0;
+}
 
-	/*
-	 *  Protect ourselves...
-	 */
-	if (ioop->cdbPtr == NULL)
-		ioop->cdbPtr = dummyCDB;
-	if (ioop->sensePtr == NULL)
-		ioop->sensePtr = dummySenseData;
-	if (ioop->inqPtr == NULL)
-		ioop->inqPtr = dummyInqData;
-	if (ioop->dataPtr == NULL)
-		ioop->dataPtr = dummyScsiData;
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static int
+__init mptscsih_setup(char *str)
+{
+	char *cur = str;
+	char *pc, *pv;
+	unsigned long val;
+	int  c;
+
+	printk("KERN_WARNING: mptscsih_setup arg %s\n", str);
+
+	while (cur != NULL && (pc = strchr(cur, ':')) != NULL) {
+		char *pe;
+
+		val = 0;
+		pv = pc;
+		c = *++pv;
+
+		if	(c == 'n')
+			val = 0;
+		else if	(c == 'y')
+			val = 1;
+		else
+			val = (int) simple_strtoul(pv, &pe, 0);
 
-	statstr = NULL;
-	if ((ioop->SCSIStatus >= sizeof(ScsiStatusString)/sizeof(char*)-1) ||
-	    ((statstr = (char*)ScsiStatusString[ioop->SCSIStatus]) == NULL)) {
-		(void) sprintf(buf2, "Bad-Reserved-%02Xh", ioop->SCSIStatus);
-		statstr = buf2;
-	}
+		printk("Found Token: %s, value %x\n", cur, (int)val);
+		switch (get_setup_token(cur)) {
+		case OPT_DV:
+			driver_setup.dv = val;
+			break;
 
-	opstr = NULL;
-	if (1+ioop->cdbPtr[0] <= sizeof(ScsiCommonOpString)/sizeof(char*))
-		opstr = ScsiCommonOpString[ioop->cdbPtr[0]];
-	else if (mpt_ScsiOpcodesPtr)
-		opstr = mpt_ScsiOpcodesPtr[ioop->cdbPtr[0]];
+		case OPT_MAX_WIDTH:
+			driver_setup.max_width = val;
+			break;
 
-	l = sprintf(foo, "SCSI Error Report =-=-= (%s)\n"
-	  "  SCSI_Status=%02Xh (%s)\n"
-	  "  Original_CDB[]:",
-			ioop->DevIDStr,
-			ioop->SCSIStatus,
-			statstr);
-	l += dump_cdb(foo+l, ioop->cdbPtr);
-	if (opstr)
-		l += sprintf(foo+l, " - \"%s\"", opstr);
-	l += sprintf(foo+l, "\n  SenseData[%02Xh]:", 8+SD_Additional_Sense_Length(ioop->sensePtr));
-	l += dump_sd(foo+l, ioop->sensePtr);
-	l += sprintf(foo+l, "\n  SenseKey=%Xh (%s); FRU=%02Xh\n  ASC/ASCQ=%02Xh/%02Xh",
-			sk, skstr, SD_FRU(ioop->sensePtr), asc, ascq );
+		case OPT_MIN_SYNC_FACTOR:
+			driver_setup.min_sync_fac = val;
+			break;
 
-	{
-		const char	*x1, *x2, *x3, *x4;
-		x1 = x2 = x3 = x4 = "";
-		x1 = ascq_set_strings_4max(asc, ascq, &x1, &x2, &x3, &x4);
-		if (x1 != NULL) {
-			if (x1[0] != '(')
-				l += sprintf(foo+l, " \"%s%s%s%s\"", x1,x2,x3,x4);
-			else
-				l += sprintf(foo+l, " %s%s%s%s", x1,x2,x3,x4);
+		default:
+			printk("mptscsih_setup: unexpected boot option '%.*s' ignored\n", (int)(pc-cur+1), cur);
+			break;
 		}
-	}
-
-#if 0
-	if (SPECIAL_ASCQ(asc,ascq))
-		l += sprintf(foo+l, " (%02Xh)", ascq);
-#endif
-
-	PrintF(("%s\n", foo));
 
-	return l;
+		if ((cur = strchr(cur, ARG_SEP)) != NULL)
+			++cur;
+	}
+	return 1;
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/mptscsih.h linux/drivers/message/fusion/mptscsih.h
--- ../ia64/linux/drivers/message/fusion/mptscsih.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/mptscsih.h	Tue Mar 19 16:05:36 2002
@@ -15,11 +15,12 @@
  *
  *      (see also mptbase.c)
  *
- *  Copyright (c) 1999-2001 LSI Logic Corporation
+ *  Copyright (c) 1999-2002 LSI Logic Corporation
  *  Originally By: Steven J. Ralston
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: mptscsih.h,v 1.7 2001/01/11 16:56:43 sralston Exp $
+ *  $Id: mptscsih.h,v 1.16 2002/02/27 18:44:30 sralston Exp $
  */
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -68,14 +69,47 @@
  *	SCSI Public stuff...
  */
 
-#ifdef __sparc__
-#define MPT_SCSI_CAN_QUEUE	63
-#define MPT_SCSI_CMD_PER_LUN	63
-	/* FIXME!  Still investigating qd=64 hang on sparc64... */
-#else
-#define MPT_SCSI_CAN_QUEUE	64
-#define MPT_SCSI_CMD_PER_LUN	64
-#endif
+/*
+ *	Try to keep these at 2^N-1
+ */
+#define MPT_FC_CAN_QUEUE	63
+#define MPT_SCSI_CAN_QUEUE	31
+#define MPT_SCSI_CMD_PER_LUN	 7
+
+#define MPT_SCSI_SG_DEPTH	40
+
+/* To disable domain validation, uncomment the
+ * following line. No effect for FC devices.
+ * For SCSI devices, driver will negotiate to
+ * NVRAM settings (if available) or to maximum adapter
+ * capabilities.
+ */
+/* #define MPTSCSIH_DISABLE_DOMAIN_VALIDATION */
+
+
+/* SCSI driver setup structure. Settings can be overridden
+ * by command line options.
+ */
+#define MPTSCSIH_DOMAIN_VALIDATION      1
+#define MPTSCSIH_MAX_WIDTH              1
+#define MPTSCSIH_MIN_SYNC               0x08
+
+struct mptscsih_driver_setup
+{
+        u8      dv;
+        u8      max_width;
+        u8      min_sync_fac;
+};
+
+
+#define MPTSCSIH_DRIVER_SETUP                   \
+{                                               \
+        MPTSCSIH_DOMAIN_VALIDATION,             \
+        MPTSCSIH_MAX_WIDTH,                     \
+        MPTSCSIH_MIN_SYNC,                      \
+}
+
+
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -143,6 +177,7 @@
 #define x_scsi_dev_reset	mptscsih_dev_reset
 #define x_scsi_host_reset	mptscsih_host_reset
 #define x_scsi_bios_param	mptscsih_bios_param
+#define x_scsi_select_queue_depths	mptscsih_select_queue_depths
 
 #define x_scsi_taskmgmt_bh	mptscsih_taskmgmt_bh
 #define x_scsi_old_abort	mptscsih_old_abort
@@ -155,7 +190,6 @@
 extern	int		 x_scsi_detect(Scsi_Host_Template *);
 extern	int		 x_scsi_release(struct Scsi_Host *host);
 extern	const char	*x_scsi_info(struct Scsi_Host *);
-/*extern	int		 x_scsi_command(Scsi_Cmnd *);*/
 extern	int		 x_scsi_queuecommand(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
 #ifdef MPT_SCSI_USE_NEW_EH
 extern	int		 x_scsi_abort(Scsi_Cmnd *);
@@ -167,6 +201,7 @@
 extern	int		 x_scsi_old_reset(Scsi_Cmnd *, unsigned int);
 #endif
 extern	int		 x_scsi_bios_param(Disk *, kdev_t, int *);
+extern	void		 x_scsi_select_queue_depths(struct Scsi_Host *, Scsi_Device *);
 extern	void		 x_scsi_taskmgmt_bh(void *);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
@@ -194,7 +229,7 @@
 	bios_param:			x_scsi_bios_param,	\
 	can_queue:			MPT_SCSI_CAN_QUEUE,	\
 	this_id:			-1,			\
-	sg_tablesize:			25,			\
+	sg_tablesize:			MPT_SCSI_SG_DEPTH,	\
 	cmd_per_lun:			MPT_SCSI_CMD_PER_LUN,	\
 	unchecked_isa_dma:		0,			\
 	use_clustering:			ENABLE_CLUSTERING,	\
@@ -217,7 +252,7 @@
 	bios_param:			x_scsi_bios_param,	\
 	can_queue:			MPT_SCSI_CAN_QUEUE,	\
 	this_id:			-1,			\
-	sg_tablesize:			25,			\
+	sg_tablesize:			MPT_SCSI_SG_DEPTH,	\
 	cmd_per_lun:			MPT_SCSI_CMD_PER_LUN,	\
 	unchecked_isa_dma:		0,			\
 	use_clustering:			ENABLE_CLUSTERING	\
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.12-20.txt linux/drivers/message/fusion/patch/linux-2.2.12-20.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.12-20.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.12-20.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,147 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.4
+retrieving revision 1.2.2.17
+diff -u -r1.1.1.1.2.4 -r1.2.2.17
+--- Makefile	2000/02/23 22:30:15	1.1.1.1.2.4
++++ Makefile	2000/12/14 18:10:42	1.2.2.17
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.2
+retrieving revision 1.1.6.3
+diff -u -r1.1.2.2 -r1.1.6.3
+--- arch/alpha/config.in	2000/12/13 11:24:47	1.1.2.2
++++ arch/alpha/config.in	2000/12/14 05:04:12	1.1.6.3
+@@ -218,6 +218,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.2
+retrieving revision 1.1.2.2
+diff -u -r1.1.1.5.2.2 -r1.1.2.2
+--- arch/i386/config.in	2000/02/23 22:26:27	1.1.1.5.2.2
++++ arch/i386/config.in	2000/10/01 18:46:38	1.1.2.2
+@@ -126,6 +126,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ mainmenu_option next_comment
+ comment 'SCSI support'
+ 
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.2
+retrieving revision 1.1.2.2.6.1
+diff -u -r1.1.1.2.6.2 -r1.1.2.2.6.1
+--- drivers/Makefile	2000/02/23 22:26:29	1.1.1.2.6.2
++++ drivers/Makefile	2000/12/02 07:07:04	1.1.2.2.6.1
+@@ -10,7 +10,7 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb
++				macintosh video dio zorro fc4 usb message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -107,6 +107,15 @@
+ else
+   ifeq ($(CONFIG_FC4),m)
+   MOD_SUB_DIRS += fc4
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.2
+retrieving revision 1.1.2.4
+diff -u -r1.1.1.1.2.2 -r1.1.2.4
+--- drivers/scsi/hosts.c	2000/09/26 15:44:57	1.1.1.1.2.2
++++ drivers/scsi/hosts.c	2000/12/15 01:55:04	1.1.2.4
+@@ -171,6 +171,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -492,6 +496,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.2
+retrieving revision 1.1.2.4
+diff -u -r1.1.1.2.2.2 -r1.1.2.4
+--- include/linux/proc_fs.h	2000/02/23 22:26:37	1.1.1.2.2.2
++++ include/linux/proc_fs.h	2000/12/19 23:54:15	1.1.2.4
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.12.txt linux/drivers/message/fusion/patch/linux-2.2.12.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.12.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.12.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,164 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.3
+retrieving revision 1.2.2.16
+diff -u -r1.1.1.1.2.3 -r1.2.2.16
+--- Makefile	2000/02/23 22:26:22	1.1.1.1.2.3
++++ Makefile	2000/12/14 18:06:00	1.2.2.16
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.2
+retrieving revision 1.1.6.3
+diff -u -r1.1.2.2 -r1.1.6.3
+--- arch/alpha/config.in	2000/12/13 11:24:47	1.1.2.2
++++ arch/alpha/config.in	2000/12/14 05:04:12	1.1.6.3
+@@ -218,6 +218,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.2
+retrieving revision 1.1.2.2
+diff -u -r1.1.1.5.2.2 -r1.1.2.2
+--- arch/i386/config.in	2000/02/23 22:26:27	1.1.1.5.2.2
++++ arch/i386/config.in	2000/10/01 18:46:38	1.1.2.2
+@@ -126,6 +126,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ mainmenu_option next_comment
+ comment 'SCSI support'
+ 
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.2 -r1.1.4.2
+--- arch/sparc64/config.in	2000/05/05 16:56:05	1.1.1.2
++++ arch/sparc64/config.in	2000/10/01 19:03:40	1.1.4.2
+@@ -192,6 +192,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.2
+retrieving revision 1.1.2.2.4.1
+diff -u -r1.1.1.2.6.2 -r1.1.2.2.4.1
+--- drivers/Makefile	2000/02/23 22:26:29	1.1.1.2.6.2
++++ drivers/Makefile	2000/12/02 07:05:20	1.1.2.2.4.1
+@@ -10,7 +10,7 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb
++				macintosh video dio zorro fc4 usb message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -107,6 +107,15 @@
+ else
+   ifeq ($(CONFIG_FC4),m)
+   MOD_SUB_DIRS += fc4
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.1
+retrieving revision 1.1.2.3
+diff -u -r1.1.1.1.2.1 -r1.1.2.3
+--- drivers/scsi/hosts.c	2000/09/26 15:40:59	1.1.1.1.2.1
++++ drivers/scsi/hosts.c	2000/12/15 01:53:56	1.1.2.3
+@@ -167,6 +167,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -485,6 +489,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.2
+retrieving revision 1.1.2.4
+diff -u -r1.1.1.2.2.2 -r1.1.2.4
+--- include/linux/proc_fs.h	2000/02/23 22:26:37	1.1.1.2.2.2
++++ include/linux/proc_fs.h	2000/12/19 23:54:15	1.1.2.4
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.13.txt linux/drivers/message/fusion/patch/linux-2.2.13.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.13.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.13.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,164 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.5
+retrieving revision 1.2.2.18
+diff -u -r1.1.1.1.2.5 -r1.2.2.18
+--- Makefile	2000/02/23 22:34:47	1.1.1.1.2.5
++++ Makefile	2000/12/14 18:12:02	1.2.2.18
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.2
+retrieving revision 1.1.6.3
+diff -u -r1.1.2.2 -r1.1.6.3
+--- arch/alpha/config.in	2000/12/13 11:24:47	1.1.2.2
++++ arch/alpha/config.in	2000/12/14 05:04:12	1.1.6.3
+@@ -218,6 +218,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.2
+retrieving revision 1.1.2.2
+diff -u -r1.1.1.5.2.2 -r1.1.2.2
+--- arch/i386/config.in	2000/02/23 22:26:27	1.1.1.5.2.2
++++ arch/i386/config.in	2000/10/01 18:46:38	1.1.2.2
+@@ -126,6 +126,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ mainmenu_option next_comment
+ comment 'SCSI support'
+ 
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.4
+retrieving revision 1.1.4.4
+diff -u -r1.1.1.4 -r1.1.4.4
+--- arch/sparc64/config.in	2000/05/05 16:59:18	1.1.1.4
++++ arch/sparc64/config.in	2000/10/01 19:08:32	1.1.4.4
+@@ -189,6 +189,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.2
+retrieving revision 1.1.2.2.2.1
+diff -u -r1.1.1.2.6.2 -r1.1.2.2.2.1
+--- drivers/Makefile	2000/02/23 22:26:29	1.1.1.2.6.2
++++ drivers/Makefile	2000/12/02 07:02:16	1.1.2.2.2.1
+@@ -10,7 +10,7 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb
++				macintosh video dio zorro fc4 usb message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -107,6 +107,15 @@
+ else
+   ifeq ($(CONFIG_FC4),m)
+   MOD_SUB_DIRS += fc4
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.3
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.1.2.3 -r1.1.2.5
+--- drivers/scsi/hosts.c	2000/09/26 15:47:14	1.1.1.1.2.3
++++ drivers/scsi/hosts.c	2000/12/15 01:55:48	1.1.2.5
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -499,6 +503,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.3
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.2.2.3 -r1.1.2.5
+--- include/linux/proc_fs.h	2000/02/23 22:35:00	1.1.1.2.2.3
++++ include/linux/proc_fs.h	2000/12/19 23:57:58	1.1.2.5
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14-5.0.txt linux/drivers/message/fusion/patch/linux-2.2.14-5.0.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14-5.0.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.14-5.0.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,131 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.6.2.1
+retrieving revision 1.2.2.20
+diff -u -r1.1.1.1.2.6.2.1 -r1.2.2.20
+--- Makefile	2000/12/02 06:09:12	1.1.1.1.2.6.2.1
++++ Makefile	2000/12/14 18:13:59	1.2.2.20
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.3.2.1
+retrieving revision 1.1.2.3.4.2
+diff -u -r1.1.1.5.2.3.2.1 -r1.1.2.3.4.2
+--- arch/i386/config.in	2000/12/02 06:09:21	1.1.1.5.2.3.2.1
++++ arch/i386/config.in	2000/12/15 16:39:21	1.1.2.3.4.2
+@@ -144,6 +144,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.3
+retrieving revision 1.1.2.3.4.1
+diff -u -r1.1.1.2.6.3 -r1.1.2.3.4.1
+--- drivers/Makefile	2000/02/23 22:37:13	1.1.1.2.6.3
++++ drivers/Makefile	2000/12/02 06:54:04	1.1.2.3.4.1
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb telephony
++				macintosh video dio zorro fc4 usb telephony \
++				message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -116,6 +117,15 @@
+ else
+   ifeq ($(CONFIG_PHONE),m)
+   MOD_SUB_DIRS += telephony
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.3
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.1.2.3 -r1.1.2.5
+--- drivers/scsi/hosts.c	2000/09/26 15:47:14	1.1.1.1.2.3
++++ drivers/scsi/hosts.c	2000/12/15 01:55:48	1.1.2.5
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -499,6 +503,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.2.1
+retrieving revision 1.1.4.2
+diff -u -r1.1.2.1 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/12/04 19:42:31	1.1.2.1
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.2.1
+retrieving revision 1.1.2.6
+diff -u -r1.1.2.1 -r1.1.2.6
+--- include/linux/proc_fs.h	2000/12/04 18:57:08	1.1.2.1
++++ include/linux/proc_fs.h	2000/12/19 23:59:18	1.1.2.6
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14-6.0.txt linux/drivers/message/fusion/patch/linux-2.2.14-6.0.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14-6.0.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.14-6.0.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,131 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.6.2.1.2.1
+retrieving revision 1.2.2.21
+diff -u -r1.1.1.1.2.6.2.1.2.1 -r1.2.2.21
+--- Makefile	2000/12/08 17:51:23	1.1.1.1.2.6.2.1.2.1
++++ Makefile	2000/12/14 18:14:49	1.2.2.21
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1
+retrieving revision 1.1.6.5
+diff -u -r1.1 -r1.1.6.5
+--- arch/alpha/config.in	2000/12/08 17:48:03	1.1
++++ arch/alpha/config.in	2000/12/14 05:07:39	1.1.6.5
+@@ -228,6 +228,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.3
+retrieving revision 1.1.2.3.4.1
+diff -u -r1.1.1.2.6.3 -r1.1.2.3.4.1
+--- drivers/Makefile	2000/02/23 22:37:13	1.1.1.2.6.3
++++ drivers/Makefile	2000/12/02 06:54:04	1.1.2.3.4.1
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb telephony
++				macintosh video dio zorro fc4 usb telephony \
++				message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -116,6 +117,15 @@
+ else
+   ifeq ($(CONFIG_PHONE),m)
+   MOD_SUB_DIRS += telephony
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.3
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.1.2.3 -r1.1.2.5
+--- drivers/scsi/hosts.c	2000/09/26 15:47:14	1.1.1.1.2.3
++++ drivers/scsi/hosts.c	2000/12/15 01:55:48	1.1.2.5
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -499,6 +503,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.2.1
+retrieving revision 1.1.4.2
+diff -u -r1.1.2.1 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/12/04 19:42:31	1.1.2.1
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.2.1
+retrieving revision 1.1.2.6
+diff -u -r1.1.2.1 -r1.1.2.6
+--- include/linux/proc_fs.h	2000/12/04 18:57:08	1.1.2.1
++++ include/linux/proc_fs.h	2000/12/19 23:59:18	1.1.2.6
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14-caldera.txt linux/drivers/message/fusion/patch/linux-2.2.14-caldera.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14-caldera.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.14-caldera.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,131 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.6
+retrieving revision 1.2.2.19
+diff -u -r1.1.1.1.2.6 -r1.2.2.19
+--- Makefile	2000/02/23 22:37:04	1.1.1.1.2.6
++++ Makefile	2000/12/14 18:12:58	1.2.2.19
+@@ -130,6 +130,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.3
+retrieving revision 1.1.2.3
+diff -u -r1.1.1.5.2.3 -r1.1.2.3
+--- arch/i386/config.in	2000/02/23 22:37:08	1.1.1.5.2.3
++++ arch/i386/config.in	2000/10/01 18:55:04	1.1.2.3
+@@ -154,6 +154,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ mainmenu_option next_comment
+ comment 'SCSI support'
+
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.3
+retrieving revision 1.1.2.3.4.1
+diff -u -r1.1.1.2.6.3 -r1.1.2.3.4.1
+--- drivers/Makefile	2000/02/23 22:37:13	1.1.1.2.6.3
++++ drivers/Makefile	2000/12/02 06:54:04	1.1.2.3.4.1
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb
++				macintosh video dio zorro fc4 usb \
++				message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -112,6 +113,15 @@
+ else
+   ifeq ($(CONFIG_FC4),m)
+   MOD_SUB_DIRS += fc4
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.3
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.1.2.3 -r1.1.2.5
+--- drivers/scsi/hosts.c	2000/09/26 15:47:14	1.1.1.1.2.3
++++ drivers/scsi/hosts.c	2000/12/15 01:55:48	1.1.2.5
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -499,6 +503,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.4
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.2.2.4 -r1.1.2.6
+--- include/linux/proc_fs.h	2000/02/23 22:37:24	1.1.1.2.2.4
++++ include/linux/proc_fs.h	2000/12/19 23:59:18	1.1.2.6
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14.txt linux/drivers/message/fusion/patch/linux-2.2.14.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.14.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.14.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,165 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.6
+retrieving revision 1.2.2.19
+diff -u -r1.1.1.1.2.6 -r1.2.2.19
+--- Makefile	2000/02/23 22:37:04	1.1.1.1.2.6
++++ Makefile	2000/12/14 18:12:58	1.2.2.19
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.3
+retrieving revision 1.1.6.4
+diff -u -r1.1.2.3 -r1.1.6.4
+--- arch/alpha/config.in	2000/12/13 11:26:40	1.1.2.3
++++ arch/alpha/config.in	2000/12/14 05:06:19	1.1.6.4
+@@ -228,6 +228,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.3
+retrieving revision 1.1.2.3
+diff -u -r1.1.1.5.2.3 -r1.1.2.3
+--- arch/i386/config.in	2000/02/23 22:37:08	1.1.1.5.2.3
++++ arch/i386/config.in	2000/10/01 18:55:04	1.1.2.3
+@@ -126,6 +126,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/telephony/Config.in
+ 
+ mainmenu_option next_comment
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.5
+retrieving revision 1.1.4.5
+diff -u -r1.1.1.5 -r1.1.4.5
+--- arch/sparc64/config.in	2000/05/05 17:00:32	1.1.1.5
++++ arch/sparc64/config.in	2000/10/01 19:09:36	1.1.4.5
+@@ -189,6 +189,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.3
+retrieving revision 1.1.2.3.4.1
+diff -u -r1.1.1.2.6.3 -r1.1.2.3.4.1
+--- drivers/Makefile	2000/02/23 22:37:13	1.1.1.2.6.3
++++ drivers/Makefile	2000/12/02 06:54:04	1.1.2.3.4.1
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb telephony
++				macintosh video dio zorro fc4 usb telephony \
++				message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -116,6 +117,15 @@
+ else
+   ifeq ($(CONFIG_PHONE),m)
+   MOD_SUB_DIRS += telephony
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.3
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.1.2.3 -r1.1.2.5
+--- drivers/scsi/hosts.c	2000/09/26 15:47:14	1.1.1.1.2.3
++++ drivers/scsi/hosts.c	2000/12/15 01:55:48	1.1.2.5
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -499,6 +503,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.4
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.2.2.4 -r1.1.2.6
+--- include/linux/proc_fs.h	2000/02/23 22:37:24	1.1.1.2.2.4
++++ include/linux/proc_fs.h	2000/12/19 23:59:18	1.1.2.6
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.15.txt linux/drivers/message/fusion/patch/linux-2.2.15.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.15.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.15.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,165 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.7
+retrieving revision 1.2.2.22
+diff -u -r1.1.1.1.2.7 -r1.2.2.22
+--- Makefile	2000/05/18 05:32:27	1.1.1.1.2.7
++++ Makefile	2000/12/14 18:15:44	1.2.2.22
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.4
+retrieving revision 1.1.6.5
+diff -u -r1.1.2.4 -r1.1.6.5
+--- arch/alpha/config.in	2000/12/13 11:29:06	1.1.2.4
++++ arch/alpha/config.in	2000/12/14 05:07:39	1.1.6.5
+@@ -228,6 +228,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.4
+retrieving revision 1.1.2.4
+diff -u -r1.1.1.5.2.4 -r1.1.2.4
+--- arch/i386/config.in	2000/05/18 05:32:32	1.1.1.5.2.4
++++ arch/i386/config.in	2000/10/01 18:56:53	1.1.2.4
+@@ -126,6 +126,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/telephony/Config.in
+ 
+ mainmenu_option next_comment
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.5.4.1
+retrieving revision 1.1.4.6
+diff -u -r1.1.1.5.4.1 -r1.1.4.6
+--- arch/sparc64/config.in	2000/05/18 05:32:33	1.1.1.5.4.1
++++ arch/sparc64/config.in	2000/10/01 19:10:23	1.1.4.6
+@@ -208,6 +208,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.4
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.2.6.4 -r1.1.2.5
+--- drivers/Makefile	2000/05/18 05:32:35	1.1.1.2.6.4
++++ drivers/Makefile	2000/11/21 10:42:21	1.1.2.5
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb telephony i2o
++				macintosh video dio zorro fc4 usb telephony \
++				i2o message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -125,6 +126,15 @@
+ else
+   ifeq ($(CONFIG_I2O),m)
+   MOD_SUB_DIRS += i2o
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.4
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.1.2.4 -r1.1.2.6
+--- drivers/scsi/hosts.c	2000/09/26 15:50:10	1.1.1.1.2.4
++++ drivers/scsi/hosts.c	2000/12/15 02:03:38	1.1.2.6
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -503,6 +507,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.5
+retrieving revision 1.1.2.7
+diff -u -r1.1.1.2.2.5 -r1.1.2.7
+--- include/linux/proc_fs.h	2000/05/18 05:32:58	1.1.1.2.2.5
++++ include/linux/proc_fs.h	2000/12/20 00:01:20	1.1.2.7
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.16-22.txt linux/drivers/message/fusion/patch/linux-2.2.16-22.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.16-22.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.16-22.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,131 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.8.2.1
+retrieving revision 1.2.2.24
+diff -u -r1.1.1.1.2.8.2.1 -r1.2.2.24
+--- Makefile	2000/11/21 13:24:05	1.1.1.1.2.8.2.1
++++ Makefile	2000/12/14 18:17:36	1.2.2.24
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.5.2.1
+retrieving revision 1.1.2.5.2.1
+diff -u -r1.1.1.5.2.5.2.1 -r1.1.2.5.2.1
+--- arch/i386/config.in	2000/11/21 13:24:14	1.1.1.5.2.5.2.1
++++ arch/i386/config.in	2000/11/21 13:33:42	1.1.2.5.2.1
+@@ -126,6 +126,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/telephony/Config.in
+ 
+ mainmenu_option next_comment
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.4.2.1
+retrieving revision 1.1.2.5.2.1
+diff -u -r1.1.1.2.6.4.2.1 -r1.1.2.5.2.1
+--- drivers/Makefile	2000/11/21 13:24:15	1.1.1.2.6.4.2.1
++++ drivers/Makefile	2000/11/21 13:33:43	1.1.2.5.2.1
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb telephony i2o i2c sensors
++				macintosh video dio zorro fc4 usb telephony \
++				i2o message/fusion i2c sensors
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -125,6 +126,15 @@
+ else
+   ifeq ($(CONFIG_I2O),m)
+   MOD_SUB_DIRS += i2o
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.4.2.1
+retrieving revision 1.1.2.7
+diff -u -r1.1.1.1.2.4.2.1 -r1.1.2.7
+--- drivers/scsi/hosts.c	2000/11/21 13:24:22	1.1.1.1.2.4.2.1
++++ drivers/scsi/hosts.c	2000/12/15 02:06:03	1.1.2.7
+@@ -179,6 +179,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -523,6 +527,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.6.2.1
+retrieving revision 1.1.2.9
+diff -u -r1.1.1.2.2.6.2.1 -r1.1.2.9
+--- include/linux/proc_fs.h	2000/11/21 13:24:26	1.1.1.2.2.6.2.1
++++ include/linux/proc_fs.h	2000/12/20 00:03:00	1.1.2.9
+@@ -168,6 +168,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.16.txt linux/drivers/message/fusion/patch/linux-2.2.16.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.16.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.16.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,165 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.8
+retrieving revision 1.2.2.23
+diff -u -r1.1.1.1.2.8 -r1.2.2.23
+--- Makefile	2000/08/16 19:44:52	1.1.1.1.2.8
++++ Makefile	2000/12/14 18:16:40	1.2.2.23
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.5
+retrieving revision 1.1.6.6
+diff -u -r1.1.2.5 -r1.1.6.6
+--- arch/alpha/config.in	2000/12/13 11:29:53	1.1.2.5
++++ arch/alpha/config.in	2000/12/14 05:10:08	1.1.6.6
+@@ -228,6 +228,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.5
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.5.2.5 -r1.1.2.5
+--- arch/i386/config.in	2000/08/16 19:44:59	1.1.1.5.2.5
++++ arch/i386/config.in	2000/10/01 18:57:41	1.1.2.5
+@@ -125,6 +125,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/telephony/Config.in
+ 
+ mainmenu_option next_comment
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.5.4.2
+retrieving revision 1.1.4.7
+diff -u -r1.1.1.5.4.2 -r1.1.4.7
+--- arch/sparc64/config.in	2000/08/16 19:45:05	1.1.1.5.4.2
++++ arch/sparc64/config.in	2000/10/01 19:11:02	1.1.4.7
+@@ -211,6 +211,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.4
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.2.6.4 -r1.1.2.5
+--- drivers/Makefile	2000/05/18 05:32:35	1.1.1.2.6.4
++++ drivers/Makefile	2000/11/21 10:42:21	1.1.2.5
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb telephony i2o
++				macintosh video dio zorro fc4 usb telephony \
++				i2o message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -125,6 +126,15 @@
+ else
+   ifeq ($(CONFIG_I2O),m)
+   MOD_SUB_DIRS += i2o
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.4
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.1.2.4 -r1.1.2.6
+--- drivers/scsi/hosts.c	2000/09/26 15:50:10	1.1.1.1.2.4
++++ drivers/scsi/hosts.c	2000/12/15 02:03:38	1.1.2.6
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -503,6 +507,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.6
+retrieving revision 1.1.2.8
+diff -u -r1.1.1.2.2.6 -r1.1.2.8
+--- include/linux/proc_fs.h	2000/08/16 19:45:23	1.1.1.2.2.6
++++ include/linux/proc_fs.h	2000/12/20 00:02:08	1.1.2.8
+@@ -168,6 +168,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.17.txt linux/drivers/message/fusion/patch/linux-2.2.17.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.17.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.17.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,165 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.9
+retrieving revision 1.2.2.25
+diff -u -r1.1.1.1.2.9 -r1.2.2.25
+--- Makefile	2000/10/25 14:47:35	1.1.1.1.2.9
++++ Makefile	2000/12/14 18:18:32	1.2.2.25
+@@ -126,6 +126,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.6
+retrieving revision 1.1.6.7
+diff -u -r1.1.2.6 -r1.1.6.7
+--- arch/alpha/config.in	2000/12/13 11:30:46	1.1.2.6
++++ arch/alpha/config.in	2000/12/14 05:12:34	1.1.6.7
+@@ -236,6 +236,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.6
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.5.2.6 -r1.1.2.6
+--- arch/i386/config.in	2000/10/25 14:47:43	1.1.1.5.2.6
++++ arch/i386/config.in	2000/10/25 14:57:12	1.1.2.6
+@@ -126,6 +126,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/telephony/Config.in
+ 
+ mainmenu_option next_comment
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.5.4.3
+retrieving revision 1.1.4.8
+diff -u -r1.1.1.5.4.3 -r1.1.4.8
+--- arch/sparc64/config.in	2000/10/25 14:47:43	1.1.1.5.4.3
++++ arch/sparc64/config.in	2000/10/25 14:57:13	1.1.4.8
+@@ -212,6 +212,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.4
+retrieving revision 1.1.2.5
+diff -u -r1.1.1.2.6.4 -r1.1.2.5
+--- drivers/Makefile	2000/05/18 05:32:35	1.1.1.2.6.4
++++ drivers/Makefile	2000/11/21 10:42:21	1.1.2.5
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 usb telephony i2o
++				macintosh video dio zorro fc4 usb telephony \
++				i2o message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -125,6 +126,15 @@
+ else
+   ifeq ($(CONFIG_I2O),m)
+   MOD_SUB_DIRS += i2o
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.5
+retrieving revision 1.1.2.8
+diff -u -r1.1.1.1.2.5 -r1.1.2.8
+--- drivers/scsi/hosts.c	2000/10/25 14:47:47	1.1.1.1.2.5
++++ drivers/scsi/hosts.c	2000/12/15 02:06:49	1.1.2.8
+@@ -175,6 +175,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -507,6 +511,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.6
+retrieving revision 1.1.2.10
+diff -u -r1.1.1.2.2.6 -r1.1.2.10
+--- include/linux/proc_fs.h	2000/08/16 19:45:23	1.1.1.2.2.6
++++ include/linux/proc_fs.h	2000/12/20 00:03:52	1.1.2.10
+@@ -168,6 +168,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.18-2.txt linux/drivers/message/fusion/patch/linux-2.2.18-2.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.18-2.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.18-2.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,131 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.10
+retrieving revision 1.2.2.26
+diff -u -r1.1.1.1.2.10 -r1.2.2.26
+--- Makefile	2000/12/14 00:19:55	1.1.1.1.2.10
++++ Makefile	2000/12/14 18:19:19	1.2.2.26
+@@ -134,6 +134,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.7
+retrieving revision 1.1.2.8
+diff -u -r1.1.1.5.2.7 -r1.1.2.8
+--- arch/i386/config.in	2000/12/14 00:20:06	1.1.1.5.2.7
++++ arch/i386/config.in	2000/12/14 00:32:30	1.1.2.8
+@@ -141,6 +141,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/i2o/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.5
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.2.6.5 -r1.1.2.6
+--- drivers/Makefile	Tue Mar 13 20:53:02 2001
++++ drivers/Makefile	Wed Sep 19 13:19:32 2001
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi ieee1394 sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 nubus usb telephony i2o
++				macintosh video dio zorro fc4 nubus usb \
++				telephony i2o message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -134,6 +135,15 @@
+ else
+   ifeq ($(CONFIG_I2O),m)
+   MOD_SUB_DIRS += i2o
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.6
+retrieving revision 1.1.2.9
+diff -u -r1.1.1.1.2.6 -r1.1.2.9
+--- drivers/scsi/hosts.c	2000/12/14 00:20:13	1.1.1.1.2.6
++++ drivers/scsi/hosts.c	2000/12/15 02:07:31	1.1.2.9
+@@ -179,6 +179,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -519,6 +523,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.7
+retrieving revision 1.1.2.11
+diff -u -r1.1.1.2.2.7 -r1.1.2.11
+--- include/linux/proc_fs.h	2000/12/14 00:20:18	1.1.1.2.2.7
++++ include/linux/proc_fs.h	2000/12/20 00:04:45	1.1.2.11
+@@ -168,6 +168,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.18.txt linux/drivers/message/fusion/patch/linux-2.2.18.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.18.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.18.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,165 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.10
+retrieving revision 1.2.2.26
+diff -u -r1.1.1.1.2.10 -r1.2.2.26
+--- Makefile	2000/12/14 00:19:55	1.1.1.1.2.10
++++ Makefile	2000/12/14 18:19:19	1.2.2.26
+@@ -134,6 +134,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.7
+retrieving revision 1.1.6.8
+diff -u -r1.1.2.7 -r1.1.6.8
+--- arch/alpha/config.in	2000/12/14 00:20:05	1.1.2.7
++++ arch/alpha/config.in	2000/12/14 05:13:23	1.1.6.8
+@@ -236,6 +236,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.7
+retrieving revision 1.1.2.8
+diff -u -r1.1.1.5.2.7 -r1.1.2.8
+--- arch/i386/config.in	2000/12/14 00:20:06	1.1.1.5.2.7
++++ arch/i386/config.in	2000/12/14 00:32:30	1.1.2.8
+@@ -141,6 +141,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/i2o/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.5.4.4
+retrieving revision 1.1.4.9
+diff -u -r1.1.1.5.4.4 -r1.1.4.9
+--- arch/sparc64/config.in	2000/12/14 00:20:07	1.1.1.5.4.4
++++ arch/sparc64/config.in	2000/12/14 00:32:31	1.1.4.9
+@@ -216,6 +216,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.5
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.2.6.5 -r1.1.2.6
+--- drivers/Makefile	2000/12/14 00:20:09	1.1.1.2.6.5
++++ drivers/Makefile	2000/12/14 00:32:33	1.1.2.6
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 nubus usb telephony i2o
++				macintosh video dio zorro fc4 \
++				nubus usb telephony i2o message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -125,6 +126,15 @@
+ else
+   ifeq ($(CONFIG_I2O),m)
+   MOD_SUB_DIRS += i2o
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.6
+retrieving revision 1.1.2.9
+diff -u -r1.1.1.1.2.6 -r1.1.2.9
+--- drivers/scsi/hosts.c	2000/12/14 00:20:13	1.1.1.1.2.6
++++ drivers/scsi/hosts.c	2000/12/15 02:07:31	1.1.2.9
+@@ -179,6 +179,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -519,6 +523,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.7
+retrieving revision 1.1.2.11
+diff -u -r1.1.1.2.2.7 -r1.1.2.11
+--- include/linux/proc_fs.h	2000/12/14 00:20:18	1.1.1.2.2.7
++++ include/linux/proc_fs.h	2000/12/20 00:04:45	1.1.2.11
+@@ -168,6 +168,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.19.txt linux/drivers/message/fusion/patch/linux-2.2.19.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.19.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.19.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,165 @@
+Index: Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/Makefile,v
+retrieving revision 1.1.1.1.2.10
+retrieving revision 1.2.2.26
+diff -u -r1.1.1.1.2.10 -r1.2.2.26
+--- Makefile	2000/12/14 00:19:55	1.1.1.1.2.10
++++ Makefile	2000/12/14 18:19:19	1.2.2.26
+@@ -134,6 +134,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+Index: arch/alpha/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/alpha/config.in,v
+retrieving revision 1.1.2.7
+retrieving revision 1.1.6.8
+diff -u -r1.1.2.7 -r1.1.6.8
+--- arch/alpha/config.in	2000/12/14 00:20:05	1.1.2.7
++++ arch/alpha/config.in	2000/12/14 05:13:23	1.1.6.8
+@@ -236,6 +236,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+Index: arch/i386/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/i386/config.in,v
+retrieving revision 1.1.1.5.2.7
+retrieving revision 1.1.2.8
+diff -u -r1.1.1.5.2.7 -r1.1.2.8
+--- arch/i386/config.in	2000/12/14 00:20:06	1.1.1.5.2.7
++++ arch/i386/config.in	2000/12/14 00:32:30	1.1.2.8
+@@ -141,6 +141,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/i2o/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: arch/sparc64/config.in
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/arch/sparc64/config.in,v
+retrieving revision 1.1.1.5.4.4
+retrieving revision 1.1.4.9
+diff -u -r1.1.1.5.4.4 -r1.1.4.9
+--- arch/sparc64/config.in	2000/12/14 00:20:07	1.1.1.5.4.4
++++ arch/sparc64/config.in	2000/12/14 00:32:31	1.1.4.9
+@@ -217,6 +217,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+Index: drivers/Makefile
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/Makefile,v
+retrieving revision 1.1.1.2.6.5
+retrieving revision 1.1.2.6
+diff -u -r1.1.1.2.6.5 -r1.1.2.6
+--- drivers/Makefile	2000/12/14 00:20:09	1.1.1.2.6.5
++++ drivers/Makefile	2000/12/14 00:32:33	1.1.2.6
+@@ -10,7 +10,8 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci sgi scsi sbus cdrom isdn pnp \
+-				macintosh video dio zorro fc4 nubus usb telephony i2o
++				macintosh video dio zorro fc4 \
++				nubus usb telephony i2o message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -125,6 +126,15 @@
+ else
+   ifeq ($(CONFIG_I2O),m)
+   MOD_SUB_DIRS += i2o
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+Index: drivers/scsi/hosts.c
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/drivers/scsi/hosts.c,v
+retrieving revision 1.1.1.1.2.6
+retrieving revision 1.1.2.9
+diff -u -r1.1.1.1.2.6 -r1.1.2.9
+--- drivers/scsi/hosts.c	2000/12/14 00:20:13	1.1.1.1.2.6
++++ drivers/scsi/hosts.c	2000/12/15 02:07:31	1.1.2.9
+@@ -179,6 +179,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -519,6 +523,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+Index: include/linux/miscdevice.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/miscdevice.h,v
+retrieving revision 1.1.1.3.2.2
+retrieving revision 1.1.4.2
+diff -u -r1.1.1.3.2.2 -r1.1.4.2
+--- include/linux/miscdevice.h	2000/03/15 19:23:47	1.1.1.3.2.2
++++ include/linux/miscdevice.h	2000/12/14 13:47:50	1.1.4.2
+@@ -18,6 +18,7 @@
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
+ #define MICROCODE_MINOR 184
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
+Index: include/linux/proc_fs.h
+===================================================================
+RCS file: /home/fibre/cvs_master/mptlinux/include/linux/proc_fs.h,v
+retrieving revision 1.1.1.2.2.7
+retrieving revision 1.1.2.11
+diff -u -r1.1.1.2.2.7 -r1.1.2.11
+--- include/linux/proc_fs.h	2000/12/14 00:20:18	1.1.1.2.2.7
++++ include/linux/proc_fs.h	2000/12/20 00:04:45	1.1.2.11
+@@ -168,6 +168,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.5-15.txt linux/drivers/message/fusion/patch/linux-2.2.5-15.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.5-15.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.5-15.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,100 @@
+diff -Naur Makefile Makefile
+--- Makefile	2000/02/23 21:02:03
++++ Makefile	2000/12/14 18:03:07
+@@ -122,6 +122,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	2000/02/23 21:02:09
++++ arch/i386/config.in	2000/10/01 18:39:13
+@@ -122,6 +122,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ mainmenu_option next_comment
+ comment 'SCSI support'
+ 
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	2000/02/23 21:02:13
++++ drivers/Makefile	2000/12/02 09:52:51
+@@ -10,7 +10,7 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci scsi sbus cdrom isdn pnp \
+-				 macintosh video dio zorro fc4
++				 macintosh video dio zorro fc4 message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -89,6 +89,15 @@
+ else
+   ifeq ($(CONFIG_FC4),m)
+   MOD_SUB_DIRS += fc4
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+diff -Naur drivers/scsi/hosts.c drivers/scsi/hosts.c
+--- drivers/scsi/hosts.c	2000/09/25 17:55:25
++++ drivers/scsi/hosts.c	2000/12/15 01:51:37
+@@ -167,6 +167,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -477,6 +481,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+diff -Naur include/linux/miscdevice.h include/linux/miscdevice.h
+--- include/linux/miscdevice.h	2000/03/15 19:22:00
++++ include/linux/miscdevice.h	2000/12/14 13:45:12
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ extern int misc_init(void);
+diff -Naur include/linux/proc_fs.h include/linux/proc_fs.h
+--- include/linux/proc_fs.h	2000/02/23 21:02:27
++++ include/linux/proc_fs.h	2000/12/19 23:52:21
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.2.5-16.txt linux/drivers/message/fusion/patch/linux-2.2.5-16.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.2.5-16.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.2.5-16.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,126 @@
+diff -Naur Makefile Makefile
+--- Makefile	Wed Mar 15 12:46:20 2000
++++ Makefile	Mon Sep 17 09:38:14 2001
+@@ -122,6 +122,10 @@
+ 
+ DRIVERS := $(DRIVERS) drivers/net/net.a
+ 
++ifdef CONFIG_FUSION_BOOT
++DRIVERS := $(DRIVERS) drivers/message/fusion/fusion.o
++endif
++
+ ifeq ($(CONFIG_SCSI),y)
+ DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+ endif
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Wed Mar 15 12:45:23 2000
++++ arch/alpha/config.in	Mon Sep 17 09:38:14 2001
+@@ -225,6 +225,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Fri Mar 12 19:39:50 1999
++++ arch/i386/config.in	Mon Sep 17 09:38:14 2001
+@@ -122,6 +122,8 @@
+   source net/Config.in
+ fi
+ 
++source drivers/message/fusion/Config.in
++
+ mainmenu_option next_comment
+ comment 'SCSI support'
+ 
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Wed Mar 15 12:45:18 2000
++++ arch/sparc64/config.in	Mon Sep 17 09:39:11 2001
+@@ -188,6 +188,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++source drivers/message/fusion/Config.in
++fi
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Fri Nov 20 10:59:01 1998
++++ drivers/Makefile	Mon Sep 17 09:38:14 2001
+@@ -10,7 +10,7 @@
+ SUB_DIRS     := block char net misc sound
+ MOD_SUB_DIRS := $(SUB_DIRS)
+ ALL_SUB_DIRS := $(SUB_DIRS) pci scsi sbus cdrom isdn pnp \
+-				 macintosh video dio zorro fc4
++				 macintosh video dio zorro fc4 message/fusion
+ 
+ ifdef CONFIG_DIO
+ SUB_DIRS += dio
+@@ -89,6 +89,15 @@
+ else
+   ifeq ($(CONFIG_FC4),m)
+   MOD_SUB_DIRS += fc4
++  endif
++endif
++
++ifeq ($(CONFIG_FUSION),y)
++SUB_DIRS += message/fusion
++MOD_SUB_DIRS += message/fusion
++else
++  ifeq ($(CONFIG_FUSION),m)
++  MOD_SUB_DIRS += message/fusion
+   endif
+ endif
+ 
+diff -Naur drivers/scsi/hosts.c drivers/scsi/hosts.c
+--- drivers/scsi/hosts.c	Wed Feb 24 18:27:54 1999
++++ drivers/scsi/hosts.c	Mon Sep 17 09:38:14 2001
+@@ -167,6 +167,10 @@
+ #include "pas16.h"
+ #endif
+ 
++#ifdef CONFIG_FUSION_BOOT
++#include "../message/fusion/mptscsih.h"
++#endif
++
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+ #include "qlogicfas.h"
+ #endif
+@@ -477,6 +481,9 @@
+ #endif
+ #ifdef CONFIG_SCSI_SYM53C416 
+     SYM53C416, 
++#endif
++#ifdef CONFIG_FUSION_BOOT
++    MPT_SCSIHOST,
+ #endif
+ #ifdef CONFIG_SCSI_QLOGIC_FAS
+     QLOGICFAS,
+diff -Naur include/linux/miscdevice.h include/linux/miscdevice.h
+--- include/linux/miscdevice.h	Sun Mar  7 17:25:23 1999
++++ include/linux/miscdevice.h	Mon Sep 17 09:38:14 2001
+@@ -17,6 +17,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ extern int misc_init(void);
+diff -Naur include/linux/proc_fs.h include/linux/proc_fs.h
+--- include/linux/proc_fs.h	Sun Mar 28 12:03:58 1999
++++ include/linux/proc_fs.h	Mon Sep 17 09:38:14 2001
+@@ -167,6 +167,7 @@
+ 	PROC_SCSI_GDTH,
+ 	PROC_SCSI_GENERIC_NCR5380,
+ 	PROC_SCSI_IN2000,
++	PROC_SCSI_MPT,
+ 	PROC_SCSI_PAS16,
+ 	PROC_SCSI_QLOGICFAS,
+ 	PROC_SCSI_QLOGICISP,
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.0.txt linux/drivers/message/fusion/patch/linux-2.4.0.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.0.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.0.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,89 @@
+diff -Naur Makefile Makefile
+--- Makefile	Thu Jan  4 15:48:13 2001
++++ Makefile	Mon Jan  8 01:38:33 2001
+@@ -145,6 +145,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+ ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Fri Dec 29 16:07:19 2000
++++ arch/alpha/config.in	Sat Jan  6 12:35:18 2001
+@@ -278,6 +278,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Fri Dec 29 16:35:47 2000
++++ arch/i386/config.in	Mon Jan  8 18:02:54 2001
+@@ -293,6 +293,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Thu Nov 16 14:51:28 2000
++++ arch/sparc64/config.in	Sat Jan  6 12:35:28 2001
+@@ -193,6 +193,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -125,6 +125,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Fri Dec 29 16:07:21 2000
++++ drivers/Makefile	Sat Jan  6 13:01:57 2001
+@@ -7,7 +7,8 @@
+ 
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+-		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi
++		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi \
++		message/fusion
+ 
+ subdir-y :=	block char net parport sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -31,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
+diff -Naur include/linux/miscdevice.h include/linux/miscdevice.h
+--- include/linux/miscdevice.h	Thu Jan  4 16:50:49 2001
++++ include/linux/miscdevice.h	Fri Dec 22 02:13:39 2000
+@@ -20,6 +20,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MICROCODE_MINOR		184
+ #define MISC_DYNAMIC_MINOR 255
+ 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.1.txt linux/drivers/message/fusion/patch/linux-2.4.1.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.1.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.1.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,89 @@
+diff -Naur Makefile Makefile
+--- Makefile	Thu Jan  4 15:48:13 2001
++++ Makefile	Mon Jan  8 01:38:33 2001
+@@ -144,6 +144,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+ ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Fri Dec 29 16:07:19 2000
++++ arch/alpha/config.in	Sat Jan  6 12:35:18 2001
+@@ -278,6 +278,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Fri Dec 29 16:35:47 2000
++++ arch/i386/config.in	Mon Jan  8 18:02:54 2001
+@@ -285,6 +285,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Thu Nov 16 14:51:28 2000
++++ arch/sparc64/config.in	Sat Jan  6 12:35:28 2001
+@@ -197,6 +197,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -125,6 +125,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Fri Dec 29 16:07:21 2000
++++ drivers/Makefile	Sat Jan  6 13:01:57 2001
+@@ -7,7 +7,8 @@
+ 
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+-		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi
++		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi \
++		message/fusion
+ 
+ subdir-y :=	block char net parport sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -31,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
+diff -Naur include/linux/miscdevice.h include/linux/miscdevice.h
+--- include/linux/miscdevice.h	Thu Jan  4 16:50:49 2001
++++ include/linux/miscdevice.h	Fri Dec 22 02:13:39 2000
+@@ -20,6 +20,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MICROCODE_MINOR		184
+ #define MISC_DYNAMIC_MINOR 255
+ 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.10-4GB.txt linux/drivers/message/fusion/patch/linux-2.4.10-4GB.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.10-4GB.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.10-4GB.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,23 @@
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Sun Sep  9 14:00:55 2001
++++ drivers/block/genhd.c	Mon Sep 24 11:06:44 2001
+@@ -146,9 +146,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -166,9 +163,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.10.txt linux/drivers/message/fusion/patch/linux-2.4.10.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.10.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.10.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,95 @@
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Sun Aug 12 12:51:41 2001
++++ arch/alpha/config.in	Mon Sep 24 11:03:45 2001
+@@ -288,6 +288,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Tue Jul 31 12:30:08 2001
++++ arch/ia64/config.in	Mon Sep 24 11:05:11 2001
+@@ -177,6 +177,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Thu Sep 20 16:11:57 2001
++++ arch/sparc64/config.in	Mon Sep 24 11:05:49 2001
+@@ -209,9 +209,11 @@
+ fi
+ endmenu
+ 
+-source drivers/fc4/Config.in
++if [ "$CONFIG_PCI" = "y" ]; then
++   source drivers/message/fusion/Config.in
++fi
+ 
+-source drivers/message/fusion/Config.in
++source drivers/fc4/Config.in
+ 
+ source drivers/ieee1394/Config.in
+ 
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Sun Sep  9 14:00:55 2001
++++ drivers/block/genhd.c	Mon Sep 24 11:06:44 2001
+@@ -146,9 +146,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -166,9 +163,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
+diff -Naur drivers/scsi/scsi_scan.c drivers/scsi/scsi_scan.c
+--- drivers/scsi/scsi_scan.c	Tue Nov 13 19:35:16 2001
++++ drivers/scsi/scsi_scan.c	Fri Dec 21 11:41:55 2001
+@@ -496,6 +496,7 @@
+ 	Scsi_Request * SRpnt;
+ 	int bflags, type = -1;
+ 	extern devfs_handle_t scsi_devfs_handle;
++	int scsi_level;
+ 
+ 	SDpnt->host = shpnt;
+ 	SDpnt->id = dev;
+@@ -668,6 +669,7 @@
+ 	    (SDpnt->scsi_level == 1 &&
+ 	     (scsi_result[3] & 0x0f) == 1))
+ 		SDpnt->scsi_level++;
++	scsi_level = SDpnt->scsi_level;
+ 
+ 	/*
+ 	 * Accommodate drivers that want to sleep when they should be in a polling
+@@ -745,6 +747,7 @@
+ 	SDpnt->queue_depth = 1;
+ 	SDpnt->host = shpnt;
+ 	SDpnt->online = TRUE;
++	SDpnt->scsi_level = scsi_level;
+ 
+ 	/*
+ 	 * Register the queue for the device.  All I/O requests will come
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.12.txt linux/drivers/message/fusion/patch/linux-2.4.12.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.12.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.12.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,95 @@
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Sun Aug 12 12:51:41 2001
++++ arch/alpha/config.in	Mon Sep 24 11:03:45 2001
+@@ -292,6 +292,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Tue Jul 31 12:30:08 2001
++++ arch/ia64/config.in	Mon Sep 24 11:05:11 2001
+@@ -177,6 +177,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Thu Sep 20 16:11:57 2001
++++ arch/sparc64/config.in	Mon Sep 24 11:05:49 2001
+@@ -209,9 +209,11 @@
+ fi
+ endmenu
+ 
+-source drivers/fc4/Config.in
++if [ "$CONFIG_PCI" = "y" ]; then
++   source drivers/message/fusion/Config.in
++fi
+ 
+-source drivers/message/fusion/Config.in
++source drivers/fc4/Config.in
+ 
+ source drivers/ieee1394/Config.in
+ 
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Sun Sep  9 14:00:55 2001
++++ drivers/block/genhd.c	Mon Sep 24 11:06:44 2001
+@@ -164,9 +164,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -184,9 +181,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
+diff -Naur drivers/scsi/scsi_scan.c drivers/scsi/scsi_scan.c
+--- drivers/scsi/scsi_scan.c	Tue Nov 13 19:35:16 2001
++++ drivers/scsi/scsi_scan.c	Fri Dec 21 11:41:55 2001
+@@ -496,6 +496,7 @@
+ 	Scsi_Request * SRpnt;
+ 	int bflags, type = -1;
+ 	extern devfs_handle_t scsi_devfs_handle;
++	int scsi_level;
+ 
+ 	SDpnt->host = shpnt;
+ 	SDpnt->id = dev;
+@@ -668,6 +669,7 @@
+ 	    (SDpnt->scsi_level == 1 &&
+ 	     (scsi_result[3] & 0x0f) == 1))
+ 		SDpnt->scsi_level++;
++	scsi_level = SDpnt->scsi_level;
+ 
+ 	/*
+ 	 * Accommodate drivers that want to sleep when they should be in a polling
+@@ -745,6 +747,7 @@
+ 	SDpnt->queue_depth = 1;
+ 	SDpnt->host = shpnt;
+ 	SDpnt->online = TRUE;
++	SDpnt->scsi_level = scsi_level;
+ 
+ 	/*
+ 	 * Register the queue for the device.  All I/O requests will come
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.13.txt linux/drivers/message/fusion/patch/linux-2.4.13.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.13.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.13.txt	Wed Feb 27 15:25:30 2002
@@ -0,0 +1,95 @@
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Sun Aug 12 12:51:41 2001
++++ arch/alpha/config.in	Mon Sep 24 11:03:45 2001
+@@ -292,6 +292,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Tue Jul 31 12:30:08 2001
++++ arch/ia64/config.in	Mon Sep 24 11:05:11 2001
+@@ -177,6 +177,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Thu Sep 20 16:11:57 2001
++++ arch/sparc64/config.in	Mon Sep 24 11:05:49 2001
+@@ -209,9 +209,11 @@
+ fi
+ endmenu
+ 
+-source drivers/fc4/Config.in
++if [ "$CONFIG_PCI" = "y" ]; then
++   source drivers/message/fusion/Config.in
++fi
+ 
+-source drivers/message/fusion/Config.in
++source drivers/fc4/Config.in
+ 
+ source drivers/ieee1394/Config.in
+ 
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Wed Oct 17 16:46:29 2001
++++ drivers/block/genhd.c	Thu Nov  1 22:04:12 2001
+@@ -161,9 +161,6 @@
+ 
+ 
+ extern int blk_dev_init(void);
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -178,9 +175,6 @@
+ 	sti();
+ #ifdef CONFIG_I2O
+ 	i2o_init();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
+diff -Naur drivers/scsi/scsi_scan.c drivers/scsi/scsi_scan.c
+--- drivers/scsi/scsi_scan.c	Tue Nov 13 19:35:16 2001
++++ drivers/scsi/scsi_scan.c	Fri Dec 21 11:41:55 2001
+@@ -500,6 +500,7 @@
+ 	Scsi_Request * SRpnt;
+ 	int bflags, type = -1;
+ 	extern devfs_handle_t scsi_devfs_handle;
++	int scsi_level;
+ 
+ 	SDpnt->host = shpnt;
+ 	SDpnt->id = dev;
+@@ -672,6 +673,7 @@
+ 	    (SDpnt->scsi_level == 1 &&
+ 	     (scsi_result[3] & 0x0f) == 1))
+ 		SDpnt->scsi_level++;
++	scsi_level = SDpnt->scsi_level;
+ 
+ 	/*
+ 	 * Accommodate drivers that want to sleep when they should be in a polling
+@@ -749,6 +751,7 @@
+ 	SDpnt->queue_depth = 1;
+ 	SDpnt->host = shpnt;
+ 	SDpnt->online = TRUE;
++	SDpnt->scsi_level = scsi_level;
+ 
+ 	/*
+ 	 * Register the queue for the device.  All I/O requests will come
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.14.txt linux/drivers/message/fusion/patch/linux-2.4.14.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.14.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.14.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,95 @@
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Mon Nov  5 11:47:41 2001
++++ arch/alpha/config.in	Mon Nov 19 14:33:54 2001
+@@ -296,6 +296,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Tue Jul 31 12:30:08 2001
++++ arch/ia64/config.in	Mon Sep 24 11:05:11 2001
+@@ -177,6 +177,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Thu Sep 20 16:11:57 2001
++++ arch/sparc64/config.in	Mon Sep 24 11:05:49 2001
+@@ -209,9 +209,11 @@
+ fi
+ endmenu
+ 
+-source drivers/fc4/Config.in
++if [ "$CONFIG_PCI" = "y" ]; then
++   source drivers/message/fusion/Config.in
++fi
+ 
+-source drivers/message/fusion/Config.in
++source drivers/fc4/Config.in
+ 
+ source drivers/ieee1394/Config.in
+ 
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Wed Oct 17 16:46:29 2001
++++ drivers/block/genhd.c	Thu Nov  1 22:04:12 2001
+@@ -161,9 +161,6 @@
+ 
+ 
+ extern int blk_dev_init(void);
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -178,9 +175,6 @@
+ 	sti();
+ #ifdef CONFIG_I2O
+ 	i2o_init();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
+diff -Naur drivers/scsi/scsi_scan.c drivers/scsi/scsi_scan.c
+--- drivers/scsi/scsi_scan.c	Tue Nov 13 19:35:16 2001
++++ drivers/scsi/scsi_scan.c	Fri Dec 21 11:41:55 2001
+@@ -500,6 +500,7 @@
+ 	Scsi_Request * SRpnt;
+ 	int bflags, type = -1;
+ 	extern devfs_handle_t scsi_devfs_handle;
++	int scsi_level;
+ 
+ 	SDpnt->host = shpnt;
+ 	SDpnt->id = dev;
+@@ -672,6 +673,7 @@
+ 	    (SDpnt->scsi_level == 1 &&
+ 	     (scsi_result[3] & 0x0f) == 1))
+ 		SDpnt->scsi_level++;
++	scsi_level = SDpnt->scsi_level;
+ 
+ 	/*
+ 	 * Accommodate drivers that want to sleep when they should be in a polling
+@@ -749,6 +751,7 @@
+ 	SDpnt->queue_depth = 1;
+ 	SDpnt->host = shpnt;
+ 	SDpnt->online = TRUE;
++	SDpnt->scsi_level = scsi_level;
+ 
+ 	/*
+ 	 * Register the queue for the device.  All I/O requests will come
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.15.txt linux/drivers/message/fusion/patch/linux-2.4.15.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.15.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.15.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,64 @@
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Fri Nov  9 16:26:17 2001
++++ arch/ia64/config.in	Mon Nov 26 09:43:02 2001
+@@ -163,6 +163,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Wed Oct 17 16:46:29 2001
++++ drivers/block/genhd.c	Thu Nov  1 22:04:12 2001
+@@ -161,9 +161,6 @@
+ 
+ 
+ extern int blk_dev_init(void);
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -178,9 +175,6 @@
+ 	sti();
+ #ifdef CONFIG_I2O
+ 	i2o_init();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
+diff -Naur drivers/scsi/scsi_scan.c drivers/scsi/scsi_scan.c
+--- drivers/scsi/scsi_scan.c	Tue Nov 13 19:35:16 2001
++++ drivers/scsi/scsi_scan.c	Fri Dec 21 11:41:55 2001
+@@ -500,6 +500,7 @@
+ 	Scsi_Request * SRpnt;
+ 	int bflags, type = -1;
+ 	extern devfs_handle_t scsi_devfs_handle;
++	int scsi_level;
+ 
+ 	SDpnt->host = shpnt;
+ 	SDpnt->id = dev;
+@@ -672,6 +673,7 @@
+ 	    (SDpnt->scsi_level == 1 &&
+ 	     (scsi_result[3] & 0x0f) == 1))
+ 		SDpnt->scsi_level++;
++	scsi_level = SDpnt->scsi_level;
+ 
+ 	/*
+ 	 * Accommodate drivers that want to sleep when they should be in a polling
+@@ -749,6 +751,7 @@
+ 	SDpnt->queue_depth = 1;
+ 	SDpnt->host = shpnt;
+ 	SDpnt->online = TRUE;
++	SDpnt->scsi_level = scsi_level;
+ 
+ 	/*
+ 	 * Register the queue for the device.  All I/O requests will come
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.16.txt linux/drivers/message/fusion/patch/linux-2.4.16.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.16.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.16.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,64 @@
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Fri Nov  9 16:26:17 2001
++++ arch/ia64/config.in	Mon Nov 26 09:43:02 2001
+@@ -163,6 +163,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Wed Oct 17 16:46:29 2001
++++ drivers/block/genhd.c	Thu Nov  1 22:04:12 2001
+@@ -161,9 +161,6 @@
+ 
+ 
+ extern int blk_dev_init(void);
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -178,9 +175,6 @@
+ 	sti();
+ #ifdef CONFIG_I2O
+ 	i2o_init();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
+diff -Naur drivers/scsi/scsi_scan.c drivers/scsi/scsi_scan.c
+--- drivers/scsi/scsi_scan.c	Tue Nov 13 19:35:16 2001
++++ drivers/scsi/scsi_scan.c	Fri Dec 21 11:41:55 2001
+@@ -500,6 +500,7 @@
+ 	Scsi_Request * SRpnt;
+ 	int bflags, type = -1;
+ 	extern devfs_handle_t scsi_devfs_handle;
++	int scsi_level;
+ 
+ 	SDpnt->host = shpnt;
+ 	SDpnt->id = dev;
+@@ -672,6 +673,7 @@
+ 	    (SDpnt->scsi_level == 1 &&
+ 	     (scsi_result[3] & 0x0f) == 1))
+ 		SDpnt->scsi_level++;
++	scsi_level = SDpnt->scsi_level;
+ 
+ 	/*
+ 	 * Accommodate drivers that want to sleep when they should be in a polling
+@@ -749,6 +751,7 @@
+ 	SDpnt->queue_depth = 1;
+ 	SDpnt->host = shpnt;
+ 	SDpnt->online = TRUE;
++	SDpnt->scsi_level = scsi_level;
+ 
+ 	/*
+ 	 * Register the queue for the device.  All I/O requests will come
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.17.txt linux/drivers/message/fusion/patch/linux-2.4.17.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.17.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.17.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,37 @@
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Fri Nov  9 16:26:17 2001
++++ arch/ia64/config.in	Mon Nov 26 09:43:02 2001
+@@ -163,6 +163,10 @@
+ fi
+ endmenu
+ 
++if [ "$CONFIG_PCI" = "y" ]; then
++  source drivers/message/fusion/Config.in
++fi
++
+ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
+ 
+ if [ "$CONFIG_NET" = "y" ]; then
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Wed Oct 17 16:46:29 2001
++++ drivers/block/genhd.c	Thu Nov  1 22:04:12 2001
+@@ -161,9 +161,6 @@
+ 
+ 
+ extern int blk_dev_init(void);
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -178,9 +175,6 @@
+ 	sti();
+ #ifdef CONFIG_I2O
+ 	i2o_init();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.2-2.txt linux/drivers/message/fusion/patch/linux-2.4.2-2.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.2-2.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.2-2.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,35 @@
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Fri Jun  8 12:04:35 2001
++++ drivers/block/genhd.c	Fri Nov  9 22:06:28 2001
+@@ -23,9 +23,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -47,9 +44,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
+diff -Naur include/linux/miscdevice.h include/linux/miscdevice.h
+--- include/linux/miscdevice.h	Sun Apr  8 17:47:26 2001
++++ include/linux/miscdevice.h	Wed Jun 13 02:32:09 2001
+@@ -21,7 +21,7 @@
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
+ #define MICROCODE_MINOR		184
+-#define MPT_MINOR 240		/* WILL CHANGE - ALLOC PENDING */
++#define MPT_MINOR 220
+ #define MISC_DYNAMIC_MINOR 255
+ 
+ #define SGI_GRAPHICS_MINOR   146
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.2.txt linux/drivers/message/fusion/patch/linux-2.4.2.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.2.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.2.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,77 @@
+diff -Naur Makefile Makefile
+--- Makefile	Thu Jan  4 15:48:13 2001
++++ Makefile	Mon Jan  8 01:38:33 2001
+@@ -144,6 +144,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+ ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Fri Dec 29 16:07:19 2000
++++ arch/alpha/config.in	Sat Jan  6 12:35:18 2001
+@@ -278,6 +278,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Fri Dec 29 16:35:47 2000
++++ arch/i386/config.in	Mon Jan  8 18:02:54 2001
+@@ -285,6 +285,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -125,6 +125,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Fri Dec 29 16:07:21 2000
++++ drivers/Makefile	Sat Jan  6 13:01:57 2001
+@@ -7,7 +7,8 @@
+ 
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+-		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi
++		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi \
++		message/fusion
+ 
+ subdir-y :=	block char net parport sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -31,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
+diff -Naur include/linux/miscdevice.h include/linux/miscdevice.h
+--- include/linux/miscdevice.h	Thu Jan  4 16:50:49 2001
++++ include/linux/miscdevice.h	Fri Dec 22 02:13:39 2000
+@@ -20,6 +20,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MICROCODE_MINOR		184
+ #define MISC_DYNAMIC_MINOR 255
+ 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.3-12.txt linux/drivers/message/fusion/patch/linux-2.4.3-12.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.3-12.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.3-12.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,23 @@
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Fri Jun  8 12:04:35 2001
++++ drivers/block/genhd.c	Fri Nov  9 22:06:28 2001
+@@ -23,9 +23,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -47,9 +44,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.3.txt linux/drivers/message/fusion/patch/linux-2.4.3.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.3.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.3.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,89 @@
+diff -Naur Makefile Makefile
+--- Makefile	Thu Jan  4 15:48:13 2001
++++ Makefile	Mon Jan  8 01:38:33 2001
+@@ -144,6 +144,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_SCSI_AIC7XXX) += drivers/scsi/aic7xxx/aic7xxx_drv.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Fri Dec 29 16:07:19 2000
++++ arch/alpha/config.in	Sat Jan  6 12:35:18 2001
+@@ -278,6 +278,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Fri Dec 29 16:35:47 2000
++++ arch/i386/config.in	Mon Jan  8 18:02:54 2001
+@@ -285,6 +285,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Mon Apr  2 09:20:05 2001
++++ arch/sparc64/config.in	Mon Apr  2 09:47:36 2001
+@@ -203,6 +203,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -125,6 +125,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Fri Dec 29 16:07:21 2000
++++ drivers/Makefile	Sat Jan  6 13:01:57 2001
+@@ -7,7 +7,8 @@
+ 
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+-		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi
++		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi \
++		message/fusion
+ 
+ subdir-y :=	block char net parport sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -31,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
+diff -Naur include/linux/miscdevice.h include/linux/miscdevice.h
+--- include/linux/miscdevice.h	Thu Jan  4 16:50:49 2001
++++ include/linux/miscdevice.h	Fri Dec 22 02:13:39 2000
+@@ -20,6 +20,7 @@
+ #define SUN_OPENPROM_MINOR 139
+ #define NVRAM_MINOR 144
+ #define I2O_MINOR 166
++#define MPT_MINOR 220
+ #define MICROCODE_MINOR		184
+ #define MISC_DYNAMIC_MINOR 255
+ 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.4-4GB.txt linux/drivers/message/fusion/patch/linux-2.4.4-4GB.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.4-4GB.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.4-4GB.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,78 @@
+diff -Naur Makefile Makefile
+--- Makefile	Thu Jan  4 15:48:13 2001
++++ Makefile	Mon Jan  8 01:38:33 2001
+@@ -172,6 +172,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+ ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Fri Dec 29 16:07:19 2000
++++ arch/alpha/config.in	Sat Jan  6 12:35:18 2001
+@@ -280,6 +280,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Fri Dec 29 16:35:47 2000
++++ arch/i386/config.in	Mon Jan  8 18:02:54 2001
+@@ -299,6 +299,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Mon Apr  2 09:20:05 2001
++++ arch/sparc64/config.in	Mon Apr  2 09:47:36 2001
+@@ -207,6 +207,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -150,6 +150,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Fri Dec 29 16:07:21 2000
++++ drivers/Makefile	Sat Jan  6 13:01:57 2001
+@@ -7,7 +7,8 @@
+ 
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+-		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi sensors
++		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi sensors\
++		message/fusion
+ 
+ subdir-y :=	block char net parport sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -31,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.4.txt linux/drivers/message/fusion/patch/linux-2.4.4.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.4.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.4.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,78 @@
+diff -Naur Makefile Makefile
+--- Makefile	Thu Jan  4 15:48:13 2001
++++ Makefile	Mon Jan  8 01:38:33 2001
+@@ -144,6 +144,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_SCSI_AIC7XXX) += drivers/scsi/aic7xxx/aic7xxx_drv.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Fri Dec 29 16:07:19 2000
++++ arch/alpha/config.in	Sat Jan  6 12:35:18 2001
+@@ -280,6 +280,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Fri Dec 29 16:35:47 2000
++++ arch/i386/config.in	Mon Jan  8 18:02:54 2001
+@@ -299,6 +299,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Mon Apr  2 09:20:05 2001
++++ arch/sparc64/config.in	Mon Apr  2 09:47:36 2001
+@@ -207,6 +207,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -150,6 +150,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Fri Dec 29 16:07:21 2000
++++ drivers/Makefile	Sat Jan  6 13:01:57 2001
+@@ -7,7 +7,8 @@
+ 
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+-		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi
++		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi \
++		message/fusion
+ 
+ subdir-y :=	block char net parport sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -31,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.5.txt linux/drivers/message/fusion/patch/linux-2.4.5.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.5.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.5.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,78 @@
+diff -Naur Makefile Makefile
+--- Makefile	Fri May 25 11:51:33 2001
++++ Makefile	Wed Jun 13 02:53:22 2001
+@@ -145,6 +145,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+ ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Fri May 25 11:55:36 2001
++++ arch/alpha/config.in	Wed Jun 13 02:52:11 2001
+@@ -277,6 +277,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Thu May 24 17:14:08 2001
++++ arch/i386/config.in	Wed Jun 13 02:52:11 2001
+@@ -299,6 +299,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -150,6 +150,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Sun May 20 13:32:07 2001
++++ arch/sparc64/config.in	Wed Jun 13 02:52:11 2001
+@@ -205,6 +205,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Wed May 16 12:27:02 2001
++++ drivers/Makefile	Wed Jun 13 02:52:11 2001
+@@ -7,7 +7,8 @@
+ 
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+-		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi
++		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi \
++		message/fusion
+ 
+ subdir-y :=	parport char block net sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -31,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.6.txt linux/drivers/message/fusion/patch/linux-2.4.6.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.6.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.6.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,77 @@
+diff -Naur Makefile Makefile
+--- Makefile	Mon Jul  2 19:46:42 2001
++++ Makefile	Fri Jul  6 08:11:28 2001
+@@ -147,6 +147,7 @@
+ DRIVERS-$(CONFIG_ATM) += drivers/atm/atm.o
+ DRIVERS-$(CONFIG_IDE) += drivers/ide/idedriver.o
+ DRIVERS-$(CONFIG_SCSI) += drivers/scsi/scsidrv.o
++DRIVERS-$(CONFIG_FUSION_BOOT) += drivers/message/fusion/fusion.o
+ DRIVERS-$(CONFIG_IEEE1394) += drivers/ieee1394/ieee1394drv.o
+ 
+ ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Mon Jun 11 21:15:27 2001
++++ arch/alpha/config.in	Fri Jul  6 08:11:28 2001
+@@ -277,6 +277,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/i386/config.in arch/i386/config.in
+--- arch/i386/config.in	Wed Jun 20 19:47:39 2001
++++ arch/i386/config.in	Fri Jul  6 08:11:28 2001
+@@ -303,6 +303,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/ieee1394/Config.in
+ 
+ source drivers/i2o/Config.in
+diff -Naur arch/sparc64/config.in arch/sparc64/config.in
+--- arch/sparc64/config.in	Thu Jun 21 16:27:40 2001
++++ arch/sparc64/config.in	Fri Jul  6 08:11:28 2001
+@@ -206,6 +206,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/Config.in
++
+ source drivers/fc4/Config.in
+ 
+ if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -150,6 +150,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/Makefile drivers/Makefile
+--- drivers/Makefile	Mon Jun 11 21:15:27 2001
++++ drivers/Makefile	Fri Jul  6 08:26:18 2001
+@@ -8,7 +8,7 @@
+ 
+ mod-subdirs :=	dio mtd sbus video macintosh usb input telephony sgi i2o ide \
+ 		scsi md ieee1394 pnp isdn atm fc4 net/hamradio i2c acpi \
+-		bluetooth
++		bluetooth message/fusion
+ 
+ subdir-y :=	parport char block net sound misc media cdrom
+ subdir-m :=	$(subdir-y)
+@@ -32,6 +32,7 @@
+ subdir-$(CONFIG_IDE)		+= ide
+ subdir-$(CONFIG_SCSI)		+= scsi
+ subdir-$(CONFIG_I2O)		+= i2o
++subdir-$(CONFIG_FUSION)		+= message/fusion
+ subdir-$(CONFIG_MD)		+= md
+ subdir-$(CONFIG_IEEE1394)	+= ieee1394
+ subdir-$(CONFIG_PNP)		+= pnp
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.7-10.txt linux/drivers/message/fusion/patch/linux-2.4.7-10.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.7-10.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.7-10.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,23 @@
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Thu Jul 19 19:48:15 2001
++++ drivers/block/genhd.c	Tue Nov 13 03:18:31 2001
+@@ -21,9 +21,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -40,9 +37,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.7.txt linux/drivers/message/fusion/patch/linux-2.4.7.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.7.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.7.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,46 @@
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Tue Jul 10 22:08:51 2001
++++ arch/alpha/config.in	Thu Aug 30 18:45:37 2001
+@@ -277,6 +277,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -150,6 +150,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Thu Jul 19 19:48:15 2001
++++ drivers/block/genhd.c	Tue Nov 13 03:02:35 2001
+@@ -21,9 +21,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -40,9 +37,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.8.txt linux/drivers/message/fusion/patch/linux-2.4.8.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.8.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.8.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,46 @@
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Tue Jul 10 22:08:51 2001
++++ arch/alpha/config.in	Thu Aug 30 18:45:50 2001
+@@ -277,6 +277,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -151,6 +151,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Thu Jul 19 19:48:15 2001
++++ drivers/block/genhd.c	Tue Nov 13 03:05:58 2001
+@@ -21,9 +21,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -40,9 +37,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/patch/linux-2.4.9.txt linux/drivers/message/fusion/patch/linux-2.4.9.txt
--- ../ia64/linux/drivers/message/fusion/patch/linux-2.4.9.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/patch/linux-2.4.9.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,46 @@
+diff -Naur arch/alpha/config.in arch/alpha/config.in
+--- arch/alpha/config.in	Sun Aug 12 12:51:41 2001
++++ arch/alpha/config.in	Thu Aug 30 18:46:02 2001
+@@ -288,6 +288,8 @@
+ fi
+ endmenu
+ 
++source drivers/message/fusion/config.in
++
+ if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+diff -Naur arch/ia64/config.in arch/ia64/config.in
+--- arch/ia64/config.in	Tue Aug  7 13:50:57 2001
++++ arch/ia64/config.in	Tue Aug  7 13:53:25 2001
+@@ -151,6 +151,7 @@
+ source drivers/block/Config.in
+ source drivers/i2o/Config.in
+ source drivers/md/Config.in
++source drivers/message/fusion/Config.in
+ 
+ mainmenu_option next_comment
+ comment 'ATA/IDE/MFM/RLL support'
+diff -Naur drivers/block/genhd.c drivers/block/genhd.c
+--- drivers/block/genhd.c	Thu Jul 19 19:48:15 2001
++++ drivers/block/genhd.c	Tue Nov 13 03:08:43 2001
+@@ -21,9 +21,6 @@
+ #ifdef CONFIG_BLK_DEV_DAC960
+ extern void DAC960_Initialize(void);
+ #endif
+-#ifdef CONFIG_FUSION_BOOT
+-extern int fusion_init(void);
+-#endif
+ extern int net_dev_init(void);
+ extern void console_map_init(void);
+ extern int soc_probe(void);
+@@ -40,9 +37,6 @@
+ #endif
+ #ifdef CONFIG_BLK_DEV_DAC960
+ 	DAC960_Initialize();
+-#endif
+-#ifdef CONFIG_FUSION_BOOT
+-	fusion_init();
+ #endif
+ #ifdef CONFIG_FC4_SOC
+ 	/* This has to be done before scsi_dev_init */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/scsi3.h linux/drivers/message/fusion/scsi3.h
--- ../ia64/linux/drivers/message/fusion/scsi3.h	Fri Jan 25 13:11:20 2002
+++ linux/drivers/message/fusion/scsi3.h	Tue Mar 19 16:05:36 2002
@@ -4,11 +4,12 @@
  *      (Ultimately) SCSI-3 definitions; for now, inheriting
  *      SCSI-2 definitions.
  *
- *  Copyright (c) 1996-2001 Steven J. Ralston
+ *  Copyright (c) 1996-2002 Steven J. Ralston
  *  Written By: Steven J. Ralston (19960517)
- *  (mailto:Steve.Ralston@lsil.com)
+ *  (mailto:sjralston1@netscape.net)
+ *  (mailto:Pam.Delaney@lsil.com)
  *
- *  $Id: scsi3.h,v 1.5 2001/04/06 14:31:32 sralston Exp $
+ *  $Id: scsi3.h,v 1.9 2002/02/27 18:45:02 sralston Exp $
  */
 
 #ifndef SCSI3_H_INCLUDED
@@ -63,7 +64,10 @@
 #define CMD_Write10            0x2A
 #define CMD_WriteVerify        0x2E
 #define CMD_Verify             0x2F
+#define CMD_SynchronizeCache   0x35
 #define CMD_ReadDefectData     0x37
+#define CMD_WriteBuffer        0x3B
+#define CMD_ReadBuffer         0x3C
 #define CMD_ReadLong           0x3E
 #define CMD_LogSelect          0x4C
 #define CMD_LogSense           0x4D
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/t10.org/asc-num.txt linux/drivers/message/fusion/t10.org/asc-num.txt
--- ../ia64/linux/drivers/message/fusion/t10.org/asc-num.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/t10.org/asc-num.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,505 @@
+File: ASC-NUM.TXT
+
+SCSI ASC/ASCQ Assignments
+Numeric Sorted Listing
+as of  5/18/00
+
+         D - DIRECT ACCESS DEVICE (SBC-2)                   device column key
+         .T - SEQUENTIAL ACCESS DEVICE (SSC)               -------------------
+         . L - PRINTER DEVICE (SSC)                           blank = reserved
+         .  P - PROCESSOR DEVICE (SPC)                     not blank = allowed
+         .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC-2)
+         .  . R - CD DEVICE (MMC)
+         .  .  S - SCANNER DEVICE (SCSI-2)
+         .  .  .O - OPTICAL MEMORY DEVICE (SBC-2)
+         .  .  . M - MEDIA CHANGER DEVICE (SMC)
+         .  .  .  C - COMMUNICATION DEVICE (SCSI-2)
+         .  .  .  .A - STORAGE ARRAY DEVICE (SCC)
+         .  .  .  . E - ENCLOSURE SERVICES DEVICE (SES)
+         .  .  .  .  B - SIMPLIFIED DIRECT-ACCESS DEVICE (RBC)
+         .  .  .  .  .K - OPTICAL CARD READER/WRITER DEVICE (OCRW)
+ASC/ASCQ DTLPWRSOMCAEBK  Description
+-------  --------------  ----------------------------------------------------
+00h/00h  DTLPWRSOMCAEBK  NO ADDITIONAL SENSE INFORMATION
+00h/01h   T              FILEMARK DETECTED
+00h/02h   T    S         END-OF-PARTITION/MEDIUM DETECTED
+00h/03h   T              SETMARK DETECTED
+00h/04h   T    S         BEGINNING-OF-PARTITION/MEDIUM DETECTED
+00h/05h   TL   S         END-OF-DATA DETECTED
+00h/06h  DTLPWRSOMCAEBK  I/O PROCESS TERMINATED
+00h/11h       R          AUDIO PLAY OPERATION IN PROGRESS
+00h/12h       R          AUDIO PLAY OPERATION PAUSED
+00h/13h       R          AUDIO PLAY OPERATION SUCCESSFULLY COMPLETED
+00h/14h       R          AUDIO PLAY OPERATION STOPPED DUE TO ERROR
+00h/15h       R          NO CURRENT AUDIO STATUS TO RETURN
+00h/16h  DTLPWRSOMCAEBK  OPERATION IN PROGRESS
+00h/17h  DTL WRSOM AEBK  CLEANING REQUESTED
+01h/00h  D   W  O    BK  NO INDEX/SECTOR SIGNAL
+02h/00h  D   WR OM   BK  NO SEEK COMPLETE
+03h/00h  DTL W SO    BK  PERIPHERAL DEVICE WRITE FAULT
+03h/01h   T              NO WRITE CURRENT
+03h/02h   T              EXCESSIVE WRITE ERRORS
+04h/00h  DTLPWRSOMCAEBK  LOGICAL UNIT NOT READY, CAUSE NOT REPORTABLE
+04h/01h  DTLPWRSOMCAEBK  LOGICAL UNIT IS IN PROCESS OF BECOMING READY
+04h/02h  DTLPWRSOMCAEBK  LOGICAL UNIT NOT READY, INITIALIZING CMD. REQUIRED
+04h/03h  DTLPWRSOMCAEBK  LOGICAL UNIT NOT READY, MANUAL INTERVENTION REQUIRED
+04h/04h  DTL  R O    B   LOGICAL UNIT NOT READY, FORMAT IN PROGRESS
+04h/05h  DT  W  OMCA BK  LOGICAL UNIT NOT READY, REBUILD IN PROGRESS
+04h/06h  DT  W  OMCA BK  LOGICAL UNIT NOT READY, RECALCULATION IN PROGRESS
+04h/07h  DTLPWRSOMCAEBK  LOGICAL UNIT NOT READY, OPERATION IN PROGRESS
+04h/08h       R          LOGICAL UNIT NOT READY, LONG WRITE IN PROGRESS
+04h/09h  DTLPWRSOMCAEBK  LOGICAL UNIT NOT READY, SELF-TEST IN PROGRESS
+04h/10h                  auxiliary memory code 2 (99-148) [proposed]
+05h/00h  DTL WRSOMCAEBK  LOGICAL UNIT DOES NOT RESPOND TO SELECTION
+06h/00h  D   WR OM   BK  NO REFERENCE POSITION FOUND
+07h/00h  DTL WRSOM   BK  MULTIPLE PERIPHERAL DEVICES SELECTED
+08h/00h  DTL WRSOMCAEBK  LOGICAL UNIT COMMUNICATION FAILURE
+08h/01h  DTL WRSOMCAEBK  LOGICAL UNIT COMMUNICATION TIME-OUT
+08h/02h  DTL WRSOMCAEBK  LOGICAL UNIT COMMUNICATION PARITY ERROR
+08h/03h  DT   R OM   BK  LOGICAL UNIT COMMUNICATION CRC ERROR (ULTRA-DMA/32)
+08h/04h  DTLPWRSO C   K  UNREACHABLE COPY TARGET
+09h/00h  DT  WR O    B   TRACK FOLLOWING ERROR
+09h/01h      WR O     K  TRACKING SERVO FAILURE
+09h/02h      WR O     K  FOCUS SERVO FAILURE
+09h/03h      WR O        SPINDLE SERVO FAILURE
+09h/04h  DT  WR O    B   HEAD SELECT FAULT
+0Ah/00h  DTLPWRSOMCAEBK  ERROR LOG OVERFLOW
+0Bh/00h  DTLPWRSOMCAEBK  WARNING
+0Bh/01h  DTLPWRSOMCAEBK  WARNING - SPECIFIED TEMPERATURE EXCEEDED
+0Bh/02h  DTLPWRSOMCAEBK  WARNING - ENCLOSURE DEGRADED
+0Ch/00h   T   RS         WRITE ERROR
+0Ch/01h               K  WRITE ERROR - RECOVERED WITH AUTO REALLOCATION
+0Ch/02h  D   W  O    BK  WRITE ERROR - AUTO REALLOCATION FAILED
+0Ch/03h  D   W  O    BK  WRITE ERROR - RECOMMEND REASSIGNMENT
+0Ch/04h  DT  W  O    B   COMPRESSION CHECK MISCOMPARE ERROR
+0Ch/05h  DT  W  O    B   DATA EXPANSION OCCURRED DURING COMPRESSION
+0Ch/06h  DT  W  O    B   BLOCK NOT COMPRESSIBLE
+0Ch/07h       R          WRITE ERROR - RECOVERY NEEDED
+0Ch/08h       R          WRITE ERROR - RECOVERY FAILED
+0Ch/09h       R          WRITE ERROR - LOSS OF STREAMING
+0Ch/0Ah       R          WRITE ERROR - PADDING BLOCKS ADDED
+0Ch/0Bh                  auxiliary memory code 4 (99-148) [proposed]
+0Dh/00h
+0Eh/00h
+0Fh/00h
+10h/00h  D   W  O    BK  ID CRC OR ECC ERROR
+11h/00h  DT  WRSO    BK  UNRECOVERED READ ERROR
+11h/01h  DT  WRSO    BK  READ RETRIES EXHAUSTED
+11h/02h  DT  WRSO    BK  ERROR TOO LONG TO CORRECT
+11h/03h  DT  W SO    BK  MULTIPLE READ ERRORS
+11h/04h  D   W  O    BK  UNRECOVERED READ ERROR - AUTO REALLOCATE FAILED
+11h/05h      WR O    B   L-EC UNCORRECTABLE ERROR
+11h/06h      WR O    B   CIRC UNRECOVERED ERROR
+11h/07h      W  O    B   DATA RE-SYNCHRONIZATION ERROR
+11h/08h   T              INCOMPLETE BLOCK READ
+11h/09h   T              NO GAP FOUND
+11h/0Ah  DT     O    BK  MISCORRECTED ERROR
+11h/0Bh  D   W  O    BK  UNRECOVERED READ ERROR - RECOMMEND REASSIGNMENT
+11h/0Ch  D   W  O    BK  UNRECOVERED READ ERROR - RECOMMEND REWRITE THE DATA
+11h/0Dh  DT  WR O    B   DE-COMPRESSION CRC ERROR
+11h/0Eh  DT  WR O    B   CANNOT DECOMPRESS USING DECLARED ALGORITHM
+11h/0Fh       R          ERROR READING UPC/EAN NUMBER
+11h/10h       R          ERROR READING ISRC NUMBER
+11h/11h       R          READ ERROR - LOSS OF STREAMING
+11h/12h                  auxiliary memory code 3 (99-148) [proposed]
+12h/00h  D   W  O    BK  ADDRESS MARK NOT FOUND FOR ID FIELD
+13h/00h  D   W  O    BK  ADDRESS MARK NOT FOUND FOR DATA FIELD
+14h/00h  DTL WRSO    BK  RECORDED ENTITY NOT FOUND
+14h/01h  DT  WR O    BK  RECORD NOT FOUND
+14h/02h   T              FILEMARK OR SETMARK NOT FOUND
+14h/03h   T              END-OF-DATA NOT FOUND
+14h/04h   T              BLOCK SEQUENCE ERROR
+14h/05h  DT  W  O    BK  RECORD NOT FOUND - RECOMMEND REASSIGNMENT
+14h/06h  DT  W  O    BK  RECORD NOT FOUND - DATA AUTO-REALLOCATED
+15h/00h  DTL WRSOM   BK  RANDOM POSITIONING ERROR
+15h/01h  DTL WRSOM   BK  MECHANICAL POSITIONING ERROR
+15h/02h  DT  WR O    BK  POSITIONING ERROR DETECTED BY READ OF MEDIUM
+16h/00h  D   W  O    BK  DATA SYNCHRONIZATION MARK ERROR
+16h/01h  D   W  O    BK  DATA SYNC ERROR - DATA REWRITTEN
+16h/02h  D   W  O    BK  DATA SYNC ERROR - RECOMMEND REWRITE
+16h/03h  D   W  O    BK  DATA SYNC ERROR - DATA AUTO-REALLOCATED
+16h/04h  D   W  O    BK  DATA SYNC ERROR - RECOMMEND REASSIGNMENT
+17h/00h  DT  WRSO    BK  RECOVERED DATA WITH NO ERROR CORRECTION APPLIED
+17h/01h  DT  WRSO    BK  RECOVERED DATA WITH RETRIES
+17h/02h  DT  WR O    BK  RECOVERED DATA WITH POSITIVE HEAD OFFSET
+17h/03h  DT  WR O    BK  RECOVERED DATA WITH NEGATIVE HEAD OFFSET
+17h/04h      WR O    B   RECOVERED DATA WITH RETRIES AND/OR CIRC APPLIED
+17h/05h  D   WR O    BK  RECOVERED DATA USING PREVIOUS SECTOR ID
+17h/06h  D   W  O    BK  RECOVERED DATA WITHOUT ECC - DATA AUTO-REALLOCATED
+17h/07h  D   WR O    BK  RECOVERED DATA WITHOUT ECC - RECOMMEND REASSIGNMENT
+17h/08h  D   WR O    BK  RECOVERED DATA WITHOUT ECC - RECOMMEND REWRITE
+17h/09h  D   WR O    BK  RECOVERED DATA WITHOUT ECC - DATA REWRITTEN
+18h/00h  DT  WR O    BK  RECOVERED DATA WITH ERROR CORRECTION APPLIED
+18h/01h  D   WR O    BK  RECOVERED DATA WITH ERROR CORR. & RETRIES APPLIED
+18h/02h  D   WR O    BK  RECOVERED DATA - DATA AUTO-REALLOCATED
+18h/03h       R          RECOVERED DATA WITH CIRC
+18h/04h       R          RECOVERED DATA WITH L-EC
+18h/05h  D   WR O    BK  RECOVERED DATA - RECOMMEND REASSIGNMENT
+18h/06h  D   WR O    BK  RECOVERED DATA - RECOMMEND REWRITE
+18h/07h  D   W  O    BK  RECOVERED DATA WITH ECC - DATA REWRITTEN
+19h/00h  D      O     K  DEFECT LIST ERROR
+19h/01h  D      O     K  DEFECT LIST NOT AVAILABLE
+19h/02h  D      O     K  DEFECT LIST ERROR IN PRIMARY LIST
+19h/03h  D      O     K  DEFECT LIST ERROR IN GROWN LIST
+1Ah/00h  DTLPWRSOMCAEBK  PARAMETER LIST LENGTH ERROR
+1Bh/00h  DTLPWRSOMCAEBK  SYNCHRONOUS DATA TRANSFER ERROR
+1Ch/00h  D      O    BK  DEFECT LIST NOT FOUND
+1Ch/01h  D      O    BK  PRIMARY DEFECT LIST NOT FOUND
+1Ch/02h  D      O    BK  GROWN DEFECT LIST NOT FOUND
+1Dh/00h  DT  WR O    BK  MISCOMPARE DURING VERIFY OPERATION
+1Eh/00h  D   W  O    BK  RECOVERED ID WITH ECC CORRECTION
+1Fh/00h  D      O     K  PARTIAL DEFECT LIST TRANSFER
+20h/00h  DTLPWRSOMCAEBK  INVALID COMMAND OPERATION CODE
+20h/01h                  access controls code 1 (99-314) [proposed]
+20h/02h                  access controls code 2 (99-314) [proposed]
+20h/03h                  access controls code 3 (99-314) [proposed]
+21h/00h  DT  WR OM   BK  LOGICAL BLOCK ADDRESS OUT OF RANGE
+21h/01h  DT  WR OM   BK  INVALID ELEMENT ADDRESS
+22h/00h  D               ILLEGAL FUNCTION (USE 20 00, 24 00, OR 26 00)
+23h/00h
+24h/00h  DTLPWRSOMCAEBK  INVALID FIELD IN CDB
+24h/01h  DTLPWRSOMCAEBK  CDB DECRYPTION ERROR
+25h/00h  DTLPWRSOMCAEBK  LOGICAL UNIT NOT SUPPORTED
+26h/00h  DTLPWRSOMCAEBK  INVALID FIELD IN PARAMETER LIST
+26h/01h  DTLPWRSOMCAEBK  PARAMETER NOT SUPPORTED
+26h/02h  DTLPWRSOMCAEBK  PARAMETER VALUE INVALID
+26h/03h  DTLPWRSOMCAE K  THRESHOLD PARAMETERS NOT SUPPORTED
+26h/04h  DTLPWRSOMCAEBK  INVALID RELEASE OF PERSISTENT RESERVATION
+26h/05h  DTLPWRSOMCA BK  DATA DECRYPTION ERROR
+26h/06h  DTLPWRSO C   K  TOO MANY TARGET DESCRIPTORS
+26h/07h  DTLPWRSO C   K  UNSUPPORTED TARGET DESCRIPTOR TYPE CODE
+26h/08h  DTLPWRSO C   K  TOO MANY SEGMENT DESCRIPTORS
+26h/09h  DTLPWRSO C   K  UNSUPPORTED SEGMENT DESCRIPTOR TYPE CODE
+26h/0Ah  DTLPWRSO C   K  UNEXPECTED INEXACT SEGMENT
+26h/0Bh  DTLPWRSO C   K  INLINE DATA LENGTH EXCEEDED
+26h/0Ch  DTLPWRSO C   K  INVALID OPERATION FOR COPY SOURCE OR DESTINATION
+26h/0Dh  DTLPWRSO C   K  COPY SEGMENT GRANULARITY VIOLATION
+27h/00h  DT  WR O    BK  WRITE PROTECTED
+27h/01h  DT  WR O    BK  HARDWARE WRITE PROTECTED
+27h/02h  DT  WR O    BK  LOGICAL UNIT SOFTWARE WRITE PROTECTED
+27h/03h   T   R          ASSOCIATED WRITE PROTECT
+27h/04h   T   R          PERSISTENT WRITE PROTECT
+27h/05h   T   R          PERMANENT WRITE PROTECT
+28h/00h  DTLPWRSOMCAEBK  NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED
+28h/01h  DT  WR OM   B   IMPORT OR EXPORT ELEMENT ACCESSED
+29h/00h  DTLPWRSOMCAEBK  POWER ON, RESET, OR BUS DEVICE RESET OCCURRED
+29h/01h  DTLPWRSOMCAEBK  POWER ON OCCURRED
+29h/02h  DTLPWRSOMCAEBK  SCSI BUS RESET OCCURRED
+29h/03h  DTLPWRSOMCAEBK  BUS DEVICE RESET FUNCTION OCCURRED
+29h/04h  DTLPWRSOMCAEBK  DEVICE INTERNAL RESET
+29h/05h  DTLPWRSOMCAEBK  TRANSCEIVER MODE CHANGED TO SINGLE-ENDED
+29h/06h  DTLPWRSOMCAEBK  TRANSCEIVER MODE CHANGED TO LVD
+2Ah/00h  DTL WRSOMCAEBK  PARAMETERS CHANGED
+2Ah/01h  DTL WRSOMCAEBK  MODE PARAMETERS CHANGED
+2Ah/02h  DTL WRSOMCAE K  LOG PARAMETERS CHANGED
+2Ah/03h  DTLPWRSOMCAE K  RESERVATIONS PREEMPTED
+2Ah/04h  DTLPWRSOMCAE    RESERVATIONS RELEASED
+2Ah/05h  DTLPWRSOMCAE    REGISTRATIONS PREEMPTED
+2Bh/00h  DTLPWRSO C   K  COPY CANNOT EXECUTE SINCE HOST CANNOT DISCONNECT
+2Ch/00h  DTLPWRSOMCAEBK  COMMAND SEQUENCE ERROR
+2Ch/01h        S         TOO MANY WINDOWS SPECIFIED
+2Ch/02h        S         INVALID COMBINATION OF WINDOWS SPECIFIED
+2Ch/03h       R          CURRENT PROGRAM AREA IS NOT EMPTY
+2Ch/04h       R          CURRENT PROGRAM AREA IS EMPTY
+2Ch/05h              B   ILLEGAL POWER CONDITION REQUEST
+2Dh/00h   T              OVERWRITE ERROR ON UPDATE IN PLACE
+2Eh/00h  DTLPWRSO CA  K  ERROR DETECTED BY THIRD PARTY TEMPORARY INITIATOR
+2Eh/01h  DTLPWRSO CA  K  THIRD PARTY DEVICE FAILURE
+2Eh/02h  DTLPWRSO CA  K  COPY TARGET DEVICE NOT REACHABLE
+2Eh/03h  DTLPWRSO CA  K  INCORRECT COPY TARGET DEVICE TYPE
+2Eh/04h  DTLPWRSO CA  K  COPY TARGET DEVICE DATA UNDERRUN
+2Eh/05h  DTLPWRSO CA  K  COPY TARGET DEVICE DATA OVERRUN
+2Fh/00h  DTLPWRSOMCAEBK  COMMANDS CLEARED BY ANOTHER INITIATOR
+30h/00h  DT  WR OM   BK  INCOMPATIBLE MEDIUM INSTALLED
+30h/01h  DT  WR O    BK  CANNOT READ MEDIUM - UNKNOWN FORMAT
+30h/02h  DT  WR O    BK  CANNOT READ MEDIUM - INCOMPATIBLE FORMAT
+30h/03h  DT   R       K  CLEANING CARTRIDGE INSTALLED
+30h/04h  DT  WR O    BK  CANNOT WRITE MEDIUM - UNKNOWN FORMAT
+30h/05h  DT  WR O    BK  CANNOT WRITE MEDIUM - INCOMPATIBLE FORMAT
+30h/06h  DT  WR O    B   CANNOT FORMAT MEDIUM - INCOMPATIBLE MEDIUM
+30h/07h  DTL WRSOM AEBK  CLEANING FAILURE
+30h/08h       R          CANNOT WRITE - APPLICATION CODE MISMATCH
+30h/09h       R          CURRENT SESSION NOT FIXATED FOR APPEND
+31h/00h  DT  WR O    BK  MEDIUM FORMAT CORRUPTED
+31h/01h  D L  R O    B   FORMAT COMMAND FAILED
+32h/00h  D   W  O    BK  NO DEFECT SPARE LOCATION AVAILABLE
+32h/01h  D   W  O    BK  DEFECT LIST UPDATE FAILURE
+33h/00h   T              TAPE LENGTH ERROR
+34h/00h  DTLPWRSOMCAEBK  ENCLOSURE FAILURE
+35h/00h  DTLPWRSOMCAEBK  ENCLOSURE SERVICES FAILURE
+35h/01h  DTLPWRSOMCAEBK  UNSUPPORTED ENCLOSURE FUNCTION
+35h/02h  DTLPWRSOMCAEBK  ENCLOSURE SERVICES UNAVAILABLE
+35h/03h  DTLPWRSOMCAEBK  ENCLOSURE SERVICES TRANSFER FAILURE
+35h/04h  DTLPWRSOMCAEBK  ENCLOSURE SERVICES TRANSFER REFUSED
+36h/00h    L             RIBBON, INK, OR TONER FAILURE
+37h/00h  DTL WRSOMCAEBK  ROUNDED PARAMETER
+38h/00h              B   EVENT STATUS NOTIFICATION
+38h/02h              B   ESN - POWER MANAGEMENT CLASS EVENT
+38h/04h              B   ESN - MEDIA CLASS EVENT
+38h/06h              B   ESN - DEVICE BUSY CLASS EVENT
+39h/00h  DTL WRSOMCAE K  SAVING PARAMETERS NOT SUPPORTED
+3Ah/00h  DTL WRSOM   BK  MEDIUM NOT PRESENT
+3Ah/01h  DT  WR OM   BK  MEDIUM NOT PRESENT - TRAY CLOSED
+3Ah/02h  DT  WR OM   BK  MEDIUM NOT PRESENT - TRAY OPEN
+3Ah/03h  DT  WR OM   B   MEDIUM NOT PRESENT - LOADABLE
+3Ah/04h  DT  WR OM   B   MEDIUM NOT PRESENT - MEDIUM AUXILIARY MEMORY ACCESSIBLE
+3Bh/00h   TL             SEQUENTIAL POSITIONING ERROR
+3Bh/01h   T              TAPE POSITION ERROR AT BEGINNING-OF-MEDIUM
+3Bh/02h   T              TAPE POSITION ERROR AT END-OF-MEDIUM
+3Bh/03h    L             TAPE OR ELECTRONIC VERTICAL FORMS UNIT NOT READY
+3Bh/04h    L             SLEW FAILURE
+3Bh/05h    L             PAPER JAM
+3Bh/06h    L             FAILED TO SENSE TOP-OF-FORM
+3Bh/07h    L             FAILED TO SENSE BOTTOM-OF-FORM
+3Bh/08h   T              REPOSITION ERROR
+3Bh/09h        S         READ PAST END OF MEDIUM
+3Bh/0Ah        S         READ PAST BEGINNING OF MEDIUM
+3Bh/0Bh        S         POSITION PAST END OF MEDIUM
+3Bh/0Ch   T    S         POSITION PAST BEGINNING OF MEDIUM
+3Bh/0Dh  DT  WR OM   BK  MEDIUM DESTINATION ELEMENT FULL
+3Bh/0Eh  DT  WR OM   BK  MEDIUM SOURCE ELEMENT EMPTY
+3Bh/0Fh       R          END OF MEDIUM REACHED
+3Bh/11h  DT  WR OM   BK  MEDIUM MAGAZINE NOT ACCESSIBLE
+3Bh/12h  DT  WR OM   BK  MEDIUM MAGAZINE REMOVED
+3Bh/13h  DT  WR OM   BK  MEDIUM MAGAZINE INSERTED
+3Bh/14h  DT  WR OM   BK  MEDIUM MAGAZINE LOCKED
+3Bh/15h  DT  WR OM   BK  MEDIUM MAGAZINE UNLOCKED
+3Bh/16h       R          MECHANICAL POSITIONING OR CHANGER ERROR
+3Ch/00h
+3Dh/00h  DTLPWRSOMCAE K  INVALID BITS IN IDENTIFY MESSAGE
+3Eh/00h  DTLPWRSOMCAEBK  LOGICAL UNIT HAS NOT SELF-CONFIGURED YET
+3Eh/01h  DTLPWRSOMCAEBK  LOGICAL UNIT FAILURE
+3Eh/02h  DTLPWRSOMCAEBK  TIMEOUT ON LOGICAL UNIT
+3Eh/03h  DTLPWRSOMCAEBK  LOGICAL UNIT FAILED SELF-TEST
+3Eh/04h  DTLPWRSOMCAEBK  LOGICAL UNIT UNABLE TO UPDATE SELF-TEST LOG
+3Fh/00h  DTLPWRSOMCAEBK  TARGET OPERATING CONDITIONS HAVE CHANGED
+3Fh/01h  DTLPWRSOMCAEBK  MICROCODE HAS BEEN CHANGED
+3Fh/02h  DTLPWRSOMC  BK  CHANGED OPERATING DEFINITION
+3Fh/03h  DTLPWRSOMCAEBK  INQUIRY DATA HAS CHANGED
+3Fh/04h  DT  WR OMCAEBK  COMPONENT DEVICE ATTACHED
+3Fh/05h  DT  WR OMCAEBK  DEVICE IDENTIFIER CHANGED
+3Fh/06h  DT  WR OMCAEB   REDUNDANCY GROUP CREATED OR MODIFIED
+3Fh/07h  DT  WR OMCAEB   REDUNDANCY GROUP DELETED
+3Fh/08h  DT  WR OMCAEB   SPARE CREATED OR MODIFIED
+3Fh/09h  DT  WR OMCAEB   SPARE DELETED
+3Fh/0Ah  DT  WR OMCAEBK  VOLUME SET CREATED OR MODIFIED
+3Fh/0Bh  DT  WR OMCAEBK  VOLUME SET DELETED
+3Fh/0Ch  DT  WR OMCAEBK  VOLUME SET DEASSIGNED
+3Fh/0Dh  DT  WR OMCAEBK  VOLUME SET REASSIGNED
+3Fh/0Eh  DTLPWRSOMCAE    REPORTED LUNS DATA HAS CHANGED
+3Fh/0Fh  DTLPWRSOMCAEBK  ECHO BUFFER OVERWRITTEN
+3Fh/10h  DT  WR OM   B   MEDIUM LOADABLE
+3Fh/11h  DT  WR OM   B   MEDIUM AUXILIARY MEMORY ACCESSIBLE
+40h/00h  D               RAM FAILURE (SHOULD USE 40 NN)
+40h/NNh  DTLPWRSOMCAEBK  DIAGNOSTIC FAILURE ON COMPONENT NN (80H-FFH)
+41h/00h  D               DATA PATH FAILURE (SHOULD USE 40 NN)
+42h/00h  D               POWER-ON OR SELF-TEST FAILURE (SHOULD USE 40 NN)
+43h/00h  DTLPWRSOMCAEBK  MESSAGE ERROR
+44h/00h  DTLPWRSOMCAEBK  INTERNAL TARGET FAILURE
+45h/00h  DTLPWRSOMCAEBK  SELECT OR RESELECT FAILURE
+46h/00h  DTLPWRSOMC  BK  UNSUCCESSFUL SOFT RESET
+47h/00h  DTLPWRSOMCAEBK  SCSI PARITY ERROR
+47h/01h  DTLPWRSOMCAEBK  DATA PHASE CRC ERROR DETECTED
+47h/02h  DTLPWRSOMCAEBK  SCSI PARITY ERROR DETECTED DURING ST DATA PHASE
+47h/03h  DTLPWRSOMCAEBK  INFORMATION UNIT CRC ERROR DETECTED
+47h/04h  DTLPWRSOMCAEBK  ASYNCHRONOUS INFORMATION PROTECTION ERROR DETECTED
+48h/00h  DTLPWRSOMCAEBK  INITIATOR DETECTED ERROR MESSAGE RECEIVED
+49h/00h  DTLPWRSOMCAEBK  INVALID MESSAGE ERROR
+4Ah/00h  DTLPWRSOMCAEBK  COMMAND PHASE ERROR
+4Bh/00h  DTLPWRSOMCAEBK  DATA PHASE ERROR
+4Ch/00h  DTLPWRSOMCAEBK  LOGICAL UNIT FAILED SELF-CONFIGURATION
+4Dh/NNh  DTLPWRSOMCAEBK  TAGGED OVERLAPPED COMMANDS (NN = QUEUE TAG)
+4Eh/00h  DTLPWRSOMCAEBK  OVERLAPPED COMMANDS ATTEMPTED
+4Fh/00h
+50h/00h   T              WRITE APPEND ERROR
+50h/01h   T              WRITE APPEND POSITION ERROR
+50h/02h   T              POSITION ERROR RELATED TO TIMING
+51h/00h   T   R O        ERASE FAILURE
+52h/00h   T              CARTRIDGE FAULT
+53h/00h  DTL WRSOM   BK  MEDIA LOAD OR EJECT FAILED
+53h/01h   T              UNLOAD TAPE FAILURE
+53h/02h  DT  WR OM   BK  MEDIUM REMOVAL PREVENTED
+54h/00h     P            SCSI TO HOST SYSTEM INTERFACE FAILURE
+55h/00h     P            SYSTEM RESOURCE FAILURE
+55h/01h  D      O    BK  SYSTEM BUFFER FULL
+55h/02h  DTLPWRSOM AE K  INSUFFICIENT RESERVATION RESOURCES
+55h/03h  DTLPWRSOMCAE    INSUFFICIENT RESOURCES
+55h/04h  DTLPWRSOM AE    INSUFFICIENT REGISTRATION RESOURCES
+55h/05h                  access controls code 4 (99-314) [proposed]
+55h/06h                  auxiliary memory code 1 (99-148) [proposed]
+56h/00h
+57h/00h       R          UNABLE TO RECOVER TABLE-OF-CONTENTS
+58h/00h         O        GENERATION DOES NOT EXIST
+59h/00h         O        UPDATED BLOCK READ
+5Ah/00h  DTLPWRSOM   BK  OPERATOR REQUEST OR STATE CHANGE INPUT
+5Ah/01h  DT  WR OM   BK  OPERATOR MEDIUM REMOVAL REQUEST
+5Ah/02h  DT  WR O  A BK  OPERATOR SELECTED WRITE PROTECT
+5Ah/03h  DT  WR O  A BK  OPERATOR SELECTED WRITE PERMIT
+5Bh/00h  DTLPWRSOM    K  LOG EXCEPTION
+5Bh/01h  DTLPWRSOM    K  THRESHOLD CONDITION MET
+5Bh/02h  DTLPWRSOM    K  LOG COUNTER AT MAXIMUM
+5Bh/03h  DTLPWRSOM    K  LOG LIST CODES EXHAUSTED
+5Ch/00h  D      O        RPL STATUS CHANGE
+5Ch/01h  D      O        SPINDLES SYNCHRONIZED
+5Ch/02h  D      O        SPINDLES NOT SYNCHRONIZED
+5Dh/00h  DTLPWRSOMCAEBK  FAILURE PREDICTION THRESHOLD EXCEEDED
+5Dh/01h       R      B   MEDIA FAILURE PREDICTION THRESHOLD EXCEEDED
+5Dh/02h       R          LOGICAL UNIT FAILURE PREDICTION THRESHOLD EXCEEDED
+5Dh/10h  D           B   HARDWARE IMPENDING FAILURE GENERAL HARD DRIVE FAILURE
+5Dh/11h  D           B   HARDWARE IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH
+5Dh/12h  D           B   HARDWARE IMPENDING FAILURE DATA ERROR RATE TOO HIGH
+5Dh/13h  D           B   HARDWARE IMPENDING FAILURE SEEK ERROR RATE TOO HIGH
+5Dh/14h  D           B   HARDWARE IMPENDING FAILURE TOO MANY BLOCK REASSIGNS
+5Dh/15h  D           B   HARDWARE IMPENDING FAILURE ACCESS TIMES TOO HIGH
+5Dh/16h  D           B   HARDWARE IMPENDING FAILURE START UNIT TIMES TOO HIGH
+5Dh/17h  D           B   HARDWARE IMPENDING FAILURE CHANNEL PARAMETRICS
+5Dh/18h  D           B   HARDWARE IMPENDING FAILURE CONTROLLER DETECTED
+5Dh/19h  D           B   HARDWARE IMPENDING FAILURE THROUGHPUT PERFORMANCE
+5Dh/1Ah  D           B   HARDWARE IMPENDING FAILURE SEEK TIME PERFORMANCE
+5Dh/1Bh  D           B   HARDWARE IMPENDING FAILURE SPIN-UP RETRY COUNT
+5Dh/1Ch  D           B   HARDWARE IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT
+5Dh/20h  D           B   CONTROLLER IMPENDING FAILURE GENERAL HARD DRIVE FAILURE
+5Dh/21h  D           B   CONTROLLER IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH
+5Dh/22h  D           B   CONTROLLER IMPENDING FAILURE DATA ERROR RATE TOO HIGH
+5Dh/23h  D           B   CONTROLLER IMPENDING FAILURE SEEK ERROR RATE TOO HIGH
+5Dh/24h  D           B   CONTROLLER IMPENDING FAILURE TOO MANY BLOCK REASSIGNS
+5Dh/25h  D           B   CONTROLLER IMPENDING FAILURE ACCESS TIMES TOO HIGH
+5Dh/26h  D           B   CONTROLLER IMPENDING FAILURE START UNIT TIMES TOO HIGH
+5Dh/27h  D           B   CONTROLLER IMPENDING FAILURE CHANNEL PARAMETRICS
+5Dh/28h  D           B   CONTROLLER IMPENDING FAILURE CONTROLLER DETECTED
+5Dh/29h  D           B   CONTROLLER IMPENDING FAILURE THROUGHPUT PERFORMANCE
+5Dh/2Ah  D           B   CONTROLLER IMPENDING FAILURE SEEK TIME PERFORMANCE
+5Dh/2Bh  D           B   CONTROLLER IMPENDING FAILURE SPIN-UP RETRY COUNT
+5Dh/2Ch  D           B   CONTROLLER IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT
+5Dh/30h  D           B   DATA CHANNEL IMPENDING FAILURE GENERAL HARD DRIVE FAILURE
+5Dh/31h  D           B   DATA CHANNEL IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH
+5Dh/32h  D           B   DATA CHANNEL IMPENDING FAILURE DATA ERROR RATE TOO HIGH
+5Dh/33h  D           B   DATA CHANNEL IMPENDING FAILURE SEEK ERROR RATE TOO HIGH
+5Dh/34h  D           B   DATA CHANNEL IMPENDING FAILURE TOO MANY BLOCK REASSIGNS
+5Dh/35h  D           B   DATA CHANNEL IMPENDING FAILURE ACCESS TIMES TOO HIGH
+5Dh/36h  D           B   DATA CHANNEL IMPENDING FAILURE START UNIT TIMES TOO HIGH
+5Dh/37h  D           B   DATA CHANNEL IMPENDING FAILURE CHANNEL PARAMETRICS
+5Dh/38h  D           B   DATA CHANNEL IMPENDING FAILURE CONTROLLER DETECTED
+5Dh/39h  D           B   DATA CHANNEL IMPENDING FAILURE THROUGHPUT PERFORMANCE
+5Dh/3Ah  D           B   DATA CHANNEL IMPENDING FAILURE SEEK TIME PERFORMANCE
+5Dh/3Bh  D           B   DATA CHANNEL IMPENDING FAILURE SPIN-UP RETRY COUNT
+5Dh/3Ch  D           B   DATA CHANNEL IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT
+5Dh/40h  D           B   SERVO IMPENDING FAILURE GENERAL HARD DRIVE FAILURE
+5Dh/41h  D           B   SERVO IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH
+5Dh/42h  D           B   SERVO IMPENDING FAILURE DATA ERROR RATE TOO HIGH
+5Dh/43h  D           B   SERVO IMPENDING FAILURE SEEK ERROR RATE TOO HIGH
+5Dh/44h  D           B   SERVO IMPENDING FAILURE TOO MANY BLOCK REASSIGNS
+5Dh/45h  D           B   SERVO IMPENDING FAILURE ACCESS TIMES TOO HIGH
+5Dh/46h  D           B   SERVO IMPENDING FAILURE START UNIT TIMES TOO HIGH
+5Dh/47h  D           B   SERVO IMPENDING FAILURE CHANNEL PARAMETRICS
+5Dh/48h  D           B   SERVO IMPENDING FAILURE CONTROLLER DETECTED
+5Dh/49h  D           B   SERVO IMPENDING FAILURE THROUGHPUT PERFORMANCE
+5Dh/4Ah  D           B   SERVO IMPENDING FAILURE SEEK TIME PERFORMANCE
+5Dh/4Bh  D           B   SERVO IMPENDING FAILURE SPIN-UP RETRY COUNT
+5Dh/4Ch  D           B   SERVO IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT
+5Dh/50h  D           B   SPINDLE IMPENDING FAILURE GENERAL HARD DRIVE FAILURE
+5Dh/51h  D           B   SPINDLE IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH
+5Dh/52h  D           B   SPINDLE IMPENDING FAILURE DATA ERROR RATE TOO HIGH
+5Dh/53h  D           B   SPINDLE IMPENDING FAILURE SEEK ERROR RATE TOO HIGH
+5Dh/54h  D           B   SPINDLE IMPENDING FAILURE TOO MANY BLOCK REASSIGNS
+5Dh/55h  D           B   SPINDLE IMPENDING FAILURE ACCESS TIMES TOO HIGH
+5Dh/56h  D           B   SPINDLE IMPENDING FAILURE START UNIT TIMES TOO HIGH
+5Dh/57h  D           B   SPINDLE IMPENDING FAILURE CHANNEL PARAMETRICS
+5Dh/58h  D           B   SPINDLE IMPENDING FAILURE CONTROLLER DETECTED
+5Dh/59h  D           B   SPINDLE IMPENDING FAILURE THROUGHPUT PERFORMANCE
+5Dh/5Ah  D           B   SPINDLE IMPENDING FAILURE SEEK TIME PERFORMANCE
+5Dh/5Bh  D           B   SPINDLE IMPENDING FAILURE SPIN-UP RETRY COUNT
+5Dh/5Ch  D           B   SPINDLE IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT
+5Dh/60h  D           B   FIRMWARE IMPENDING FAILURE GENERAL HARD DRIVE FAILURE
+5Dh/61h  D           B   FIRMWARE IMPENDING FAILURE DRIVE ERROR RATE TOO HIGH
+5Dh/62h  D           B   FIRMWARE IMPENDING FAILURE DATA ERROR RATE TOO HIGH
+5Dh/63h  D           B   FIRMWARE IMPENDING FAILURE SEEK ERROR RATE TOO HIGH
+5Dh/64h  D           B   FIRMWARE IMPENDING FAILURE TOO MANY BLOCK REASSIGNS
+5Dh/65h  D           B   FIRMWARE IMPENDING FAILURE ACCESS TIMES TOO HIGH
+5Dh/66h  D           B   FIRMWARE IMPENDING FAILURE START UNIT TIMES TOO HIGH
+5Dh/67h  D           B   FIRMWARE IMPENDING FAILURE CHANNEL PARAMETRICS
+5Dh/68h  D           B   FIRMWARE IMPENDING FAILURE CONTROLLER DETECTED
+5Dh/69h  D           B   FIRMWARE IMPENDING FAILURE THROUGHPUT PERFORMANCE
+5Dh/6Ah  D           B   FIRMWARE IMPENDING FAILURE SEEK TIME PERFORMANCE
+5Dh/6Bh  D           B   FIRMWARE IMPENDING FAILURE SPIN-UP RETRY COUNT
+5Dh/6Ch  D           B   FIRMWARE IMPENDING FAILURE DRIVE CALIBRATION RETRY COUNT
+5Dh/FFh  DTLPWRSOMCAEBK  FAILURE PREDICTION THRESHOLD EXCEEDED (FALSE)
+5Eh/00h  DTLPWRSO CA  K  LOW POWER CONDITION ON
+5Eh/01h  DTLPWRSO CA  K  IDLE CONDITION ACTIVATED BY TIMER
+5Eh/02h  DTLPWRSO CA  K  STANDBY CONDITION ACTIVATED BY TIMER
+5Eh/03h  DTLPWRSO CA  K  IDLE CONDITION ACTIVATED BY COMMAND
+5Eh/04h  DTLPWRSO CA  K  STANDBY CONDITION ACTIVATED BY COMMAND
+5Eh/41h              B   POWER STATE CHANGE TO ACTIVE
+5Eh/42h              B   POWER STATE CHANGE TO IDLE
+5Eh/43h              B   POWER STATE CHANGE TO STANDBY
+5Eh/45h              B   POWER STATE CHANGE TO SLEEP
+5Eh/47h              BK  POWER STATE CHANGE TO DEVICE CONTROL
+5Fh/00h
+60h/00h        S         LAMP FAILURE
+61h/00h        S         VIDEO ACQUISITION ERROR
+61h/01h        S         UNABLE TO ACQUIRE VIDEO
+61h/02h        S         OUT OF FOCUS
+62h/00h        S         SCAN HEAD POSITIONING ERROR
+63h/00h       R          END OF USER AREA ENCOUNTERED ON THIS TRACK
+63h/01h       R          PACKET DOES NOT FIT IN AVAILABLE SPACE
+64h/00h       R          ILLEGAL MODE FOR THIS TRACK
+64h/01h       R          INVALID PACKET SIZE
+65h/00h  DTLPWRSOMCAEBK  VOLTAGE FAULT
+66h/00h        S         AUTOMATIC DOCUMENT FEEDER COVER UP
+66h/01h        S         AUTOMATIC DOCUMENT FEEDER LIFT UP
+66h/02h        S         DOCUMENT JAM IN AUTOMATIC DOCUMENT FEEDER
+66h/03h        S         DOCUMENT MISS FEED AUTOMATIC IN DOCUMENT FEEDER
+67h/00h            A     CONFIGURATION FAILURE
+67h/01h            A     CONFIGURATION OF INCAPABLE LOGICAL UNITS FAILED
+67h/02h            A     ADD LOGICAL UNIT FAILED
+67h/03h            A     MODIFICATION OF LOGICAL UNIT FAILED
+67h/04h            A     EXCHANGE OF LOGICAL UNIT FAILED
+67h/05h            A     REMOVE OF LOGICAL UNIT FAILED
+67h/06h            A     ATTACHMENT OF LOGICAL UNIT FAILED
+67h/07h            A     CREATION OF LOGICAL UNIT FAILED
+67h/08h            A     ASSIGN FAILURE OCCURRED
+67h/09h            A     MULTIPLY ASSIGNED LOGICAL UNIT
+68h/00h            A     LOGICAL UNIT NOT CONFIGURED
+69h/00h            A     DATA LOSS ON LOGICAL UNIT
+69h/01h            A     MULTIPLE LOGICAL UNIT FAILURES
+69h/02h            A     PARITY/DATA MISMATCH
+6Ah/00h            A     INFORMATIONAL, REFER TO LOG
+6Bh/00h            A     STATE CHANGE HAS OCCURRED
+6Bh/01h            A     REDUNDANCY LEVEL GOT BETTER
+6Bh/02h            A     REDUNDANCY LEVEL GOT WORSE
+6Ch/00h            A     REBUILD FAILURE OCCURRED
+6Dh/00h            A     RECALCULATE FAILURE OCCURRED
+6Eh/00h            A     COMMAND TO LOGICAL UNIT FAILED
+6Fh/00h       R          COPY PROTECTION KEY EXCHANGE FAILURE - AUTHENTICATION FAILURE
+6Fh/01h       R          COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT PRESENT
+6Fh/02h       R          COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT ESTABLISHED
+6Fh/03h       R          READ OF SCRAMBLED SECTOR WITHOUT AUTHENTICATION
+6Fh/04h       R          MEDIA REGION CODE IS MISMATCHED TO LOGICAL UNIT REGION
+6Fh/05h       R          DRIVE REGION MUST BE PERMANENT/REGION RESET COUNT ERROR
+70h/NNh   T              DECOMPRESSION EXCEPTION SHORT ALGORITHM ID OF NN
+71h/00h   T              DECOMPRESSION EXCEPTION LONG ALGORITHM ID
+72h/00h       R          SESSION FIXATION ERROR
+72h/01h       R          SESSION FIXATION ERROR WRITING LEAD-IN
+72h/02h       R          SESSION FIXATION ERROR WRITING LEAD-OUT
+72h/03h       R          SESSION FIXATION ERROR - INCOMPLETE TRACK IN SESSION
+72h/04h       R          EMPTY OR PARTIALLY WRITTEN RESERVED TRACK
+72h/05h       R          NO MORE TRACK RESERVATIONS ALLOWED
+73h/00h       R          CD CONTROL ERROR
+73h/01h       R          POWER CALIBRATION AREA ALMOST FULL
+73h/02h       R          POWER CALIBRATION AREA IS FULL
+73h/03h       R          POWER CALIBRATION AREA ERROR
+73h/04h       R          PROGRAM MEMORY AREA UPDATE FAILURE
+73h/05h       R          PROGRAM MEMORY AREA IS FULL
+73h/06h       R          RMA/PMA IS FULL
+74h/00h
+75h/00h
+76h/00h
+77h/00h
+78h/00h
+79h/00h
+7Ah/00h
+7Bh/00h
+7Ch/00h
+7Dh/00h
+7Eh/00h
+7Fh/00h
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/t10.org/op-num.txt linux/drivers/message/fusion/t10.org/op-num.txt
--- ../ia64/linux/drivers/message/fusion/t10.org/op-num.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/t10.org/op-num.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,234 @@
+File: OP-NUM.TXT
+
+SCSI Operation Codes
+Numeric Sorted Listing
+as of  3/21/00
+
+    D - DIRECT ACCESS DEVICE (SBC)                     device column key
+    .T - SEQUENTIAL ACCESS DEVICE (SSC)               -------------------
+    . L - PRINTER DEVICE (SSC)                        M = Mandatory
+    .  P - PROCESSOR DEVICE (SPC)                     O = Optional
+    .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC)     V = Vendor specific
+    .  . R - CD DEVICE (MMC)                          Z = Obsolete
+    .  .  S - SCANNER DEVICE (SCSI-2)
+    .  .  .O - OPTICAL MEMORY DEVICE (SBC)
+    .  .  . M - MEDIA CHANGER DEVICE (SMC)
+    .  .  .  C - COMMUNICATION DEVICE (SCSI-2)
+    .  .  .  .A - STORAGE ARRAY DEVICE (SCC)
+    .  .  .  . E - ENCLOSURE SERVICES DEVICE (SES)
+    .  .  .  .  B - SIMPLIFIED DIRECT-ACCESS DEVICE (RBC)
+    .  .  .  .  .K - OPTICAL CARD READER/WRITER DEVICE (OCRW)
+OP  DTLPWRSOMCAEBK  Description
+--  --------------  ----------------------------------------------------
+00  MMMMMMMMMMMMMM  TEST UNIT READY
+01   M              REWIND
+01  Z V ZZ ZO       REZERO UNIT
+02  VVVVVV  V
+03  MMMMMMMMMMMM M  REQUEST SENSE
+04  M    O O        FORMAT UNIT
+04   O              FORMAT MEDIUM
+04    O             FORMAT
+05  VMVVVV  V       READ BLOCK LIMITS
+06  VVVVVV  V
+07  OVV O  OV       REASSIGN BLOCKS
+07          O       INITIALIZE ELEMENT STATUS
+08  O V OO OV       READ(06)
+08   M              READ
+08     O            RECEIVE
+08           M      GET MESSAGE(06)
+09  VVVVVV  V
+0A  O   O  OV       WRITE(06)
+0A   M              WRITE
+0A     M            SEND(06)
+0A           M      SEND MESSAGE(06)
+0A    M             PRINT
+0B  Z   ZO ZV       SEEK(06)
+0B    O             SLEW AND PRINT
+0C  VVVVVV  V
+0D  VVVVVV  V
+0E  VVVVVV  V
+0F  VOVVVV  V       READ REVERSE
+10  VM VVV          WRITE FILEMARKS
+10    O O           SYNCHRONIZE BUFFER
+11  VMVVVV          SPACE(6)
+12  MMMMMMMMMMMMMM  INQUIRY
+13  V VVVV
+13   O              VERIFY
+14  VOOVVV          RECOVER BUFFERED DATA
+15  OMO OOOOOOOO O  MODE SELECT(06)
+16  MMMOMOMM  OO O  RESERVE(06)
+16          M       RESERVE ELEMENT(06)
+17  MMMOMOMM  OO O  RELEASE(06)
+17          M       RELEASE ELEMENT(06)
+18  OOOOOOOO     O  COPY
+19  VMVVVV          ERASE
+1A  OMO OOOOOOOO O  MODE SENSE(06)
+1B  O   OM O  O MO  STOP START UNIT
+1B   O              LOAD UNLOAD
+1B        O         SCAN
+1B    O             STOP PRINT
+1C  OOOOOOOOOOOM O  RECEIVE DIAGNOSTIC RESULTS
+1D  MMMMMMMMMMOM M  SEND DIAGNOSTIC
+1E  OO  OM OO    O  PREVENT ALLOW MEDIUM REMOVAL
+1F
+20  V   VV V     V
+21  V   VV V     V
+22  V   VV V     V
+23  V   V  V     V
+23       O          READ FORMAT CAPACITIES
+24  V   VVM         SET WINDOW
+25  M   MM M        READ CAPACITY
+25               M  READ CARD CAPACITY
+25        O         GET WINDOW
+26  V   VV
+27  V   VV
+28  M   MMMM    MM  READ(10)
+28           O      GET MESSAGE(10)
+29  V   VV O        READ GENERATION
+2A  M   MM M    MO  WRITE(10)
+2A        O         SEND(10)
+2A           O      SEND MESSAGE(10)
+2B  O   OM O     O  SEEK(10)
+2B   O              LOCATE(10)
+2B          O       POSITION TO ELEMENT
+2C  V    O O        ERASE(10)
+2D  V   O  O        READ UPDATED BLOCK
+2E  O   OO O    MO  WRITE AND VERIFY(10)
+2F  O   OO O        VERIFY(10)
+30  Z   ZZ Z        SEARCH DATA HIGH(10)
+31  Z   ZZ Z        SEARCH DATA EQUAL(10)
+31        O         OBJECT POSITION
+32  Z   ZZ Z        SEARCH DATA LOW(10)
+33  O   OO O        SET LIMITS(10)
+34  O   OO O     O  PRE-FETCH(10)
+34   M              READ POSITION
+34        O         GET DATA BUFFER STATUS
+35  O   OM O    MO  SYNCHRONIZE CACHE(10)
+36  O   OO O     O  LOCK UNLOCK CACHE(10)
+37  O      O        READ DEFECT DATA(10)
+38      O  O     O  MEDIUM SCAN
+39  OOOOOOOO     O  COMPARE
+3A  OOOOOOOO     O  COPY AND VERIFY
+3B  OOOOOOOOOOOOMO  WRITE BUFFER
+3C  OOOOOOOOOOO  O  READ BUFFER
+3D      O  O        UPDATE BLOCK
+3E  O   OO O        READ LONG
+3F  O   O  O        WRITE LONG
+40  ZZZZZZZZZZ      CHANGE DEFINITION
+41  O               WRITE SAME(10)
+42       M          READ SUB-CHANNEL
+43       M          READ TOC/PMA/ATIP
+44   M              REPORT DENSITY SUPPORT
+44       M          READ HEADER
+45       O          PLAY AUDIO(10)
+46       O          GET CONFIGURATION
+47       O          PLAY AUDIO MSF
+48       Z          PLAY AUDIO TRACK INDEX
+49       Z          PLAY TRACK RELATIVE(10)
+4A       O          GET EVENT STATUS NOTIFICATION
+4B       O          PAUSE/RESUME
+4C  OOOOOOOOOOO  O  LOG SELECT
+4D  OOOOOOOOOOO  O  LOG SENSE
+4E       O          STOP PLAY/SCAN
+4F
+50  O               XDWRITE(10)
+51  O               XPWRITE(10)
+51       M          READ DISC INFORMATION
+52  O               XDREAD(10)
+52       M          READ TRACK INFORMATION
+53       M          RESERVE TRACK
+54       O          SEND OPC INFORMATION
+55  OOO OOOOOOOOMO  MODE SELECT(10)
+56  MMMOMMMM  OO    RESERVE(10)
+56          M       RESERVE ELEMENT(10)
+57  MMMOMMMM  OO    RELEASE(10)
+57          M       RELEASE ELEMENT(10)
+58       O          REPAIR TRACK
+59       O          READ MASTER CUE
+5A  OOO OOOOOOOOMO  MODE SENSE(10)
+5B       M          CLOSE TRACK/SESSION
+5C       O          READ BUFFER CAPACITY
+5D       O          SEND CUE SHEET
+5E  OOOOOOOOO OO    PERSISTENT RESERVE IN
+5F  OOOOOOOOO OO    PERSISTENT RESERVE OUT
+80  O               XDWRITE EXTENDED(16)
+81  O               REBUILD(16)
+82  O               REGENERATE(16)
+83  OOOOOOOO     O  EXTENDED COPY
+84  OOOOOOOO     O  RECEIVE COPY RESULTS
+85
+86                  ACCESS CONTROL IN  [proposed]
+87                  ACCESS CONTROL OUT  [proposed]
+88  O   OO O    O   READ(16)
+89                  DEVICE LOCKS  [proposed]
+8A  O   O  O    O   WRITE(16)
+8B
+8C                  READ ATTRIBUTES [proposed]
+8D                  WRITE ATTRIBUTES [proposed]
+8E  O   O  O    O   WRITE AND VERIFY(16)
+8F  O   OO O    O   VERIFY(16)
+90  O   OO O    O   PRE-FETCH(16)
+91  O   OO O    O   SYNCHRONIZE CACHE(16)
+91   O              SPACE(16) [1]
+92  O   OO O        LOCK UNLOCK CACHE(16)
+92   O              LOCATE(16) [1]
+93  O               WRITE SAME(16)
+94                  [usage proposed by SCSI Socket Services project]
+95                  [usage proposed by SCSI Socket Services project]
+96                  [usage proposed by SCSI Socket Services project]
+97                  [usage proposed by SCSI Socket Services project]
+98                  MARGIN CONTROL [proposed]
+99
+9A
+9B
+9C
+9D
+9E                  SERVICE ACTION IN [proposed]
+9F                  SERVICE ACTION OUT [proposed]
+A0  OOOOOOOOOOMO O  REPORT LUNS
+A1       O          BLANK
+A2       O          SEND EVENT
+A3  OOO O  OOOMO    MAINTENANCE (IN)
+A3       O          SEND KEY
+A4  OOO O  OOOOO    MAINTENANCE (OUT)
+A4       O          REPORT KEY
+A5   O      M       MOVE MEDIUM
+A5       O          PLAY AUDIO(12)
+A6          O       EXCHANGE MEDIUM
+A6       O          LOAD/UNLOAD C/DVD
+A7  OO  O  OO       MOVE MEDIUM ATTACHED
+A7       O          SET READ AHEAD
+A8      OM O        READ(12)
+A8           O      GET MESSAGE(12)
+A9       Z          PLAY TRACK RELATIVE(12)
+AA      O  O        WRITE(12)
+AA           O      SEND MESSAGE(12)
+AB
+AC         O        ERASE(12)
+AC       O          GET PERFORMANCE
+AD         O        READ DVD STRUCTURE
+AE      O  O        WRITE AND VERIFY(12)
+AF      OZ O        VERIFY(12)
+B0      ZZ Z        SEARCH DATA HIGH(12)
+B1      ZZ Z        SEARCH DATA EQUAL(12)
+B2      ZZ Z        SEARCH DATA LOW(12)
+B3      OO O        SET LIMITS(12)
+B4  OO  OZ OO       READ ELEMENT STATUS ATTACHED
+B5          O       REQUEST VOLUME ELEMENT ADDRESS
+B6          O       SEND VOLUME TAG
+B6       O          SET STREAMING
+B7         O        READ DEFECT DATA(12)
+B8   O   Z  M       READ ELEMENT STATUS
+B9       M          READ CD MSF
+BA  O   O  OO MO    REDUNDANCY GROUP (IN)
+BA       O          SCAN
+BB  O   O  OO OO    REDUNDANCY GROUP (OUT)
+BB       O          SET CD-ROM SPEED
+BC  O   O  OO MO    SPARE (IN)
+BC       O          PLAY CD
+BD  O   O  OO OO    SPARE (OUT)
+BD       M          MECHANISM STATUS
+BE  O   O  OO MO    VOLUME SET (IN)
+BE       O          READ CD
+BF  O   O  OO OO    VOLUME SET (OUT)
+BF       O          SEND DVD STRUCTURE
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/t10.org/stds.txt linux/drivers/message/fusion/t10.org/stds.txt
--- ../ia64/linux/drivers/message/fusion/t10.org/stds.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/t10.org/stds.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,120 @@
+File: STDS.TXT
+
+SCSI Standards Version Descriptor Value Assignments
+as of  3/29/00
+
+Code  Standard
+----- ----------------------------------------------------------------
+14BDh ANSI IEEE 1394:1995
+0B20h EPI (no version claimed)
+0B3Ch EPI ANSI NCITS TR-23:1999
+0B3Bh EPI T10/1134 revision 16
+0D40h FC-AL (no version claimed)
+0D5Ch FC-AL ANSI X3.272:1996
+0D60h FC-AL-2 (no version claimed)
+0D61h FC-AL-2 T11/1133 revision 7.0
+1320h FC-FLA (no version claimed)
+133Ch FC-FLA ANSI NCITS TR-20:1998
+133Bh FC-FLA T11/1235 revision 7
+0DA0h FC-FS (no version claimed)
+0D20h FC-PH (no version claimed)
+0D3Bh FC-PH ANSI X3.230:1994
+0D3Ch FC-PH ANSI X3.230:1994 with Amnd 1 ANSI X3.230/AM1:1996
+0D80h FC-PH-3 (no version claimed)
+0D9Ch FC-PH-3 ANSI X3.303-1998
+1340h FC-PLDA (no version claimed)
+135Ch FC-PLDA ANSI NCITS TR-19:1998
+135Bh FC-PLDA T11/1162 revision 2.1
+1300h FC-Tape (no version claimed)
+1301h FC-Tape T11/1315 revision 1.16
+08C0h FCP (no version claimed)
+08DCh FCP ANSI X3.269:1996
+08DBh FCP T10/0993 revision 12
+0900h FCP-2 (no version claimed)
+0901h FCP-2 T10/1144 revision 4
+0AC0h Fast-20 (no version claimed)
+0ADCh Fast-20 ANSI X3.277:1996
+0ADBh Fast-20 T10/1071 revision 06
+14A0h IEEE 1394 (no version claimed)
+14C0h IEEE 1394a (no version claimed)
+14E0h IEEE 1394b (no version claimed)
+0140h MMC (no version claimed)
+015Ch MMC ANSI X3.304:1997
+015Bh MMC T10/1048 revision 10a
+0240h MMC-2 (no version claimed)
+0255h MMC-2 T10/1228 revision 11
+02A0h MMC-3 (no version claimed)
+0280h OCRW (no version claimed)
+029Eh OCRW ISO/IEC 14776-381
+0220h RBC (no version claimed)
+0238h RBC T10/1240 revision 10a
+02C0h RMC (no version claimed)
+0020h SAM (no version claimed)
+003Ch SAM ANSI X3.270:1996
+003Bh SAM T10/0994 revision 18
+0040h SAM-2 (no version claimed)
+0180h SBC (no version claimed)
+019Ch SBC ANSI NCITS.306:1998
+019Bh SBC T10/0996 revision 08c
+0320h SBC-2 (no version claimed)
+08E0h SBP-2 (no version claimed)
+08FCh SBP-2 ANSI NCITS.325:1999
+08FBh SBP-2 T10/1155 revision 04
+0160h SCC (no version claimed)
+017Ch SCC ANSI X3.276:1997
+017Bh SCC T10/1047 revision 06c
+01E0h SCC-2 (no version claimed)
+01FCh SCC-2 ANSI NCITS.318:1998
+01FBh SCC-2 T10/1125 revision 04
+01C0h SES (no version claimed)
+01DCh SES ANSI NCITS.305:1998
+01DBh SES T10/1212 revision 08b
+08A0h SIP (no version claimed)
+08BCh SIP ANSI X3.292:1997
+08BBh SIP T10/0856 revision 10
+01A0h SMC (no version claimed)
+01BCh SMC ANSI NCITS.314:1998
+01BBh SMC T10/0999 revision 10a
+02E0h SMC-2 (no version claimed)
+0120h SPC (no version claimed)
+013Ch SPC ANSI X3.301:1997
+013Bh SPC T10/0995 revision 11a
+0260h SPC-2 (no version claimed)
+0267h SPC-2 T10/1236 revision 12
+0300h SPC-3 (no version claimed)
+0AA0h SPI (no version claimed)
+0ABAh SPI ANSI X3.253:1995
+0ABCh SPI ANSI X3.253:1995 with SPI Amnd ANSI X3.253/AM1:1998
+0AB9h SPI T10/0855 revision 15a
+0ABBh SPI T10/0855 revision 15a with SPI Amnd revision 3a
+0AE0h SPI-2 (no version claimed)
+0AFCh SPI-2 ANSI X3.302:1999
+0AFBh SPI-2 T10/1142 revision 20b
+0B00h SPI-3 (no version claimed)
+0B18h SPI-3 T10/1302-D revision 10
+0B19h SPI-3 T10/1302-D revision 13a
+0B40h SPI-4 (no version claimed)
+1360h SSA-PH2 (no version claimed)
+137Ch SSA-PH2 ANSI X3.293:1996
+137Bh SSA-PH2 T10.1/1145 revision 09c
+1380h SSA-PH3 (no version claimed)
+139Ch SSA-PH3 ANSI NCITS.307:1998
+139Bh SSA-PH3 T10.1/1146 revision 05b
+0880h SSA-S2P (no version claimed)
+089Ch SSA-S2P ANSI X3.294:1996
+089Bh SSA-S2P T10.1/1121 revision 07b
+0860h SSA-S3P (no version claimed)
+087Ch SSA-S3P ANSI NCITS.309:1998
+087Bh SSA-S3P T10.1/1051 revision 05b
+0840h SSA-TL1 (no version claimed)
+085Ch SSA-TL1 ANSI X3.295:1996
+085Bh SSA-TL1 T10.1/0989 revision 10b
+0820h SSA-TL2 (no version claimed)
+083Ch SSA-TL2 ANSI NCITS.308:1998
+083Bh SSA-TL2 T10.1/1147 revision 05b
+0200h SSC (no version claimed)
+0201h SSC T10/0997 revision 17
+0207h SSC T10/0997 revision 22
+0920h SST (no version claimed)
+0940h SVP (no version claimed)
+0000h Version Descriptor Not Supported or No Standard Identified
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/t10.org/vendorid.txt linux/drivers/message/fusion/t10.org/vendorid.txt
--- ../ia64/linux/drivers/message/fusion/t10.org/vendorid.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/t10.org/vendorid.txt	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,340 @@
+This file contains the list of T10 Technical Committee vendor identifications 
+as of 2000/06/16 at 16:03:08.  The purpose of this list is to help avoid redundant
+usage of vendor identifications.   T10, a subcommittee of the National
+Committee on Information Technology Standards (NCITS), maintains an 
+informal list of vendor identifications currently in use.  Please contact 
+the chairman of T10 prior to using a new vendor identification to avoid 
+conflicts.
+
+        John Lohmeyer, Chair T10 Technical Committee
+        LSI Logic Corp.
+        4420 ArrowsWest Dr.
+        Colorado Springs, CO 80907
+        Tel: 719-533-7560
+        Fax: 719-533-7183
+        Email: lohmeyer@t10.org
+
+When requesting a new vendor ID, please specify your preferred vendor ID 
+code and your organization name EXACTLY as you would like it to appear in
+this list.  There are a few simple rules to follow:
+
+   1.   The Vendor ID code shall be 8 or fewer ASCII graphic characters
+        (codes 21h through 7Eh).  Spaces (20h) are added to the right to
+        make exactly 8 characters.
+
+   2.   The Organization Name shall be 68 or fewer ASCII graphic characters
+        (codes 20h through 7Eh).
+
+   3.   Please avoid requesting previously assigned vendor IDs.  While the
+        committee list includes both upper and lowercase characters, 
+        vendor IDs that are the same as an existing ID except for case 
+        will not be accepted.
+
+ Vendor ID                          Organization
+ --------- ---------------------------------------------------------------
+ 3M        3M Company
+ ACL       Automated Cartridge Librarys, Inc.
+ AcuLab    AcuLab, Inc. (Tulsa, OK)
+ ADAPTEC   Adaptec
+ ADIC      Advanced Digital Information Corporation
+ ADSI      Adaptive Data Systems, Inc. (a Western Digital subsidiary)
+ ADTX      ADTX Co., Ltd.
+ AERONICS  Aeronics, Inc.
+ AGFA      AGFA
+ AMCODYNE  Amcodyne
+ ANAMATIC  Anamartic Limited (England)
+ Ancor     Ancor Communications, Inc.
+ ANCOT     ANCOT Corp.
+ ANDATACO  Andataco  (now nStor)
+ ANRITSU   Anritsu Corporation
+ APPLE     Apple Computer, Inc.
+ ARCHIVE   Archive
+ ARK       ARK Research Corporation
+ ARTECON   Artecon Inc.  (Obs. - now Dot Hill)
+ ASACA     ASACA Corp.
+ ASC       Advanced Storage Concepts, Inc.
+ ASPEN     Aspen Peripherals
+ AST       AST Research
+ ASTK      Alcatel STK A/S
+ AT&T      AT&T
+ ATARI     Atari Corporation
+ ATG CYG   ATG Cygnet Inc.
+ ATTO      ATTO Technology Inc.
+ ATX       Alphatronix
+ AVR       Advanced Vision Research
+ BALLARD   Ballard Synergy Corp.
+ BERGSWD   Berg Software Design
+ BEZIER    Bezier Systems, Inc.
+ BHTi      Breece Hill Technologies
+ BiT       BiT Microsystems (obsolete, new ID: BITMICRO)
+ BITMICRO  BiT Microsystems, Inc.
+ BNCHMARK  Benchmark Tape Systems Corporation
+ BoxHill   Box Hill Systems Corporation  (Obs. - now Dot Hill)
+ BREA      BREA Technologies, Inc.
+ BULL      Bull Peripherals Corp.
+ BUSLOGIC  BusLogic Inc.
+ CalComp   CalComp, A Lockheed Company
+ CALIPER   Caliper (California Peripheral Corp.)
+ CAST      Advanced Storage Tech
+ CDC       Control Data or MPI
+ CDP       Columbia Data Products
+ CenData   Central Data Corporation
+ Cereva    Cereva Networks Inc.
+ CHEROKEE  Cherokee Data Systems
+ CHINON    Chinon
+ CIE&YED   YE Data, C.Itoh Electric Corp.
+ CIPHER    Cipher Data Products
+ Ciprico   Ciprico, Inc.
+ CIRRUSL   Cirrus Logic Inc.
+ CMD       CMD Technology Inc.
+ CNGR SFW  Congruent Software, Inc.
+ CNSi      Chaparral Network Storage, Inc.
+ COGITO    Cogito
+ COMPAQ    Compaq Computer Corporation
+ COMPORT   Comport Corp.
+ COMPSIG   Computer Signal Corporation
+ COMPTEX   Comptex Pty Limited
+ CONNER    Conner Peripherals
+ CORE      Core International, Inc.
+ CPL       Cross Products Ltd
+ CPU TECH  CPU Technology, Inc.
+ CREO      Creo Products Inc.
+ CROSFLD   Crosfield Electronics (now FujiFilm Electonic Imaging Ltd)
+ CROSSRDS  Crossroads Systems, Inc.
+ CSM, INC  Computer SM, Inc.
+ Data Com  Data Com Information Systems Pty. Ltd.
+ DATABOOK  Databook, Inc.
+ DATACOPY  Datacopy Corp.
+ DataCore  DataCore Software Corporation
+ DATAPT    Datapoint Corp.
+ DEC       Digital Equipment (Obsolete: New products use 'COMPAQ')
+ DEI       Digital Engineering, Inc.
+ DELL      Dell Computer Corporation
+ DELPHI    Delphi Data Div. of Sparks Industries, Inc.
+ DENON     Denon/Nippon Columbia
+ DenOptix  DenOptix, Inc.
+ DEST      DEST Corp.
+ DGC       Data General Corp.
+ DIGIDATA  Digi-Data Corporation
+ DigiIntl  Digi International
+ Digital   Digital Equipment Corporation (Obs: New products use 'COMPAQ')
+ DILOG     Distributed Logic Corp.
+ DISC      Document Imaging Systems Corp.
+ DotHill   Dot Hill Systems Corp.
+ DPT       Distributed Processing Technology
+ DSI       Data Spectrum, Inc.
+ DSM       Deterner Steuerungs- und Maschinenbau GmbH & Co.
+ DTC QUME  Data Technology Qume
+ DXIMAGIN  DX Imaging
+ ECCS      ECCS, Inc.
+ ECMA      European Computer Manufacturers Association
+ Elms      Elms Systems Corporation
+ EMASS     EMASS, Inc.
+ EMC       EMC Corp.
+ EMTEC     EMTEC Magnetics
+ EMULEX    Emulex
+ EPSON     Epson
+ Eris/RSI  RSI Systems, Inc.
+ EuroLogc  Eurologic Systems Limited
+ EXABYTE   Exabyte Corp.
+ FFEILTD   FujiFilm Electonic Imaging Ltd
+ FILENET   FileNet Corp.
+ FRAMDRV   FRAMEDRIVE Corp.
+ FUJI      Fuji Electric Co., Ltd. (Japan)
+ FUJIFILM  Fuji Photo Film, Co., Ltd.
+ FUJITSU   Fujitsu
+ FUNAI     Funai Electric Co., Ltd.
+ FUTURED   Future Domain Corp.
+ G&D       Giesecke & Devrient GmbH
+ GENSIG    General Signal Networks
+ Gen_Dyn   General Dynamics
+ GIGATAPE  GIGATAPE GmbH
+ GIGATRND  GigaTrend Incorporated
+ Global    Global Memory Test Consortium
+ Goidelic  Goidelic Precision, Inc.
+ GoldStar  LG Electronics Inc.
+ GOULD     Gould
+ HAGIWARA  Hagiwara Sys-Com Co., Ltd.
+ HITACHI   Hitachi America Ltd or Nissei Sangyo America Ltd
+ HONEYWEL  Honeywell Inc.
+ HP        Hewlett Packard
+ i-cubed   i-cubed ltd.
+ IBM       International Business Machines
+ ICL       ICL
+ ICP       ICP vortex Computersysteme GmbH
+ IDE       International Data Engineering, Inc.
+ IGR       Intergraph Corp.
+ IMATION   Imation
+ IMPLTD    Integrated Micro Products Ltd.
+ IMPRIMIS  Imprimis Technology Inc.
+ Indigita  Indigita Corporation
+ INITIO    Initio Corporation
+ INSITE    Insite Peripherals
+ INTEL     Intel Corporation
+ IOC       I/O Concepts, Inc.
+ IOMEGA    Iomega
+ ISi       Information Storage inc.
+ ISO       International Standards Organization
+ ITC       International Tapetronics Corporation
+ JPC Inc.  JPC Inc.
+ JVC       JVC Information Products Co.
+ KENNEDY   Kennedy Company
+ KENWOOD   KENWOOD Corporation
+ KODAK     Eastman Kodak
+ KONAN     Konan
+ KONICA    Konica Japan
+ Kyocera   Kyocera Corporation
+ LAPINE    Lapine Technology
+ LASERDRV  LaserDrive Limited
+ LASERGR   Lasergraphics, Inc.
+ LG        LG Electronics Inc.
+ LGE       LG Electronics Inc.
+ LION      Lion Optics Corporation
+ LMS       Laser Magnetic Storage International Company
+ LSI       LSI Logic Corp.
+ LSILOGIC  LSI Logic Storage Systems, Inc.
+ LTO-CVE   Linear Tape - Open, Compliance Verification Entity
+ MATSHITA  Matsushita
+ MAXELL    Hitachi Maxell, Ltd.
+ MaxOptix  Maxoptix Corp.
+ MAXSTRAT  Maximum Strategy, Inc.
+ MAXTOR    Maxtor Corp.
+ McDATA    McDATA Corporation
+ MDI       Micro Design International, Inc.
+ MEADE     Meade Instruments Corporation
+ MEII      Mountain Engineering II, Inc.
+ MELA      Mitsubishi Electronics America
+ MELCO     Mitsubishi Electric (Japan)
+ MEMREL    Memrel Corporation
+ MEMTECH   MemTech Technology
+ MERIDATA  Oy Meridata Finland Ltd
+ METRUM    Metrum, Inc.
+ MICROBTX  Microbotics Inc.
+ MICROP    Micropolis
+ MICROTEK  Microtek Storage Corp
+ Minitech  Minitech (UK) Limited
+ Minolta   Minolta Corporation
+ MINSCRIB  Miniscribe
+ MITSUMI   Mitsumi Electric Co., Ltd.
+ MOSAID    Mosaid Technologies Inc.
+ MOTOROLA  Motorola
+ MPM       Mitsubishi Paper Mills, Ltd.
+ MST       Morning Star Technologies, Inc.
+ MTNGATE   MountainGate Data Systems
+ NAI       North Atlantic Industries
+ NAKAMICH  Nakamichi Corporation
+ NatInst   National Instruments
+ NatSemi   National Semiconductor Corp.
+ NCITS     National Committee for Information Technology Standards
+ NCL       NCL America
+ NCR       NCR Corporation
+ NEC       NEC
+ NEXSAN    Nexsan Technologies, Ltd.
+ NISCA     NISCA Inc.
+ NKK       NKK Corp.
+ NRC       Nakamichi Research Corporation
+ NSD       Nippon Systems Development Co.,Ltd.
+ NSM       NSM Jukebox GmbH
+ nStor     nStor Technologies, Inc.
+ NT        Northern Telecom
+ OAI       Optical Access International
+ OCE       Oce Graphics
+ OKI       OKI Electric Industry Co.,Ltd (Japan)
+ OMI       Optical Media International
+ OMNIS     OMNIS Company (FRANCE)
+ OPTIMEM   Cipher/Optimem
+ OPTOTECH  Optotech
+ ORANGE    Orange Micro, Inc.
+ ORCA      Orca Technology
+ OSI       Optical Storage International
+ OTL       OTL Engineering
+ PASCOsci  Pasco Scientific
+ PATHLGHT  Pathlight Technology, Inc.
+ PERTEC    Pertec Peripherals Corporation
+ PFTI      Performance Technology Inc.
+ PFU       PFU Limited
+ PICO      Packard Instrument Company
+ PIONEER   Pioneer Electronic Corp.
+ PLASMON   Plasmon Data
+ PRAIRIE   PrairieTek
+ PREPRESS  PrePRESS Solutions
+ PRESOFT   PreSoft Architects
+ PRESTON   Preston Scientific
+ PRIAM     Priam
+ PRIMAGFX  Primagraphics Ltd
+ PROCOM    Procom Technology
+ PTI       Peripheral Technology Inc.
+ QIC       Quarter-Inch Cartridge Drive Standards, Inc.
+ QUALSTAR  Qualstar
+ QUANTEL   Quantel Ltd.
+ QUANTUM   Quantum Corp.
+ R-BYTE    R-Byte, Inc.
+ RACALREC  Racal Recorders
+ RADSTONE  Radstone Technology
+ RGI       Raster Graphics, Inc.
+ RHS       Racal-Heim Systems GmbH
+ RICOH     Ricoh
+ RODIME    Rodime
+ RTI       Reference Technology
+ SAMSUNG   Samsung Electronics Co., Ltd.
+ SAN       Storage Area Networks, Ltd.
+ SANKYO    Sankyo Seiki
+ SANYO     SANYO Electric Co., Ltd.
+ SCInc.    Storage Concepts, Inc.
+ SCREEN    Dainippon Screen Mfg. Co., Ltd.
+ SDI       Storage Dimensions, Inc.
+ SDS       Solid Data Systems
+ SEAGATE   Seagate
+ SEQUOIA   Sequoia Advanced Technologies, Inc.
+ Shinko    Shinko Electric Co., Ltd.
+ SIEMENS   Siemens
+ SII       Seiko Instruments Inc.
+ SMS       Scientific Micro Systems/OMTI
+ SNYSIDE   Sunnyside Computing Inc.
+ SONIC     Sonic Solutions
+ SONY      Sony Corporation Japan
+ SPD       Storage Products Distribution, Inc.
+ SPECIAL   Special Computing Co.
+ SPECTRA   Spectra Logic, a Division of Western Automation Labs, Inc.
+ SPERRY    Sperry (now Unisys Corp.)
+ Sterling  Sterling Diagnostic Imaging, Inc.
+ STK       Storage Technology Corporation
+ STORAPP   StorageApps, Inc.
+ STORM     Storm Technology, Inc.
+ StrmLgc   StreamLogic Corp.
+ SUMITOMO  Sumitomo Electric Industries, Ltd.
+ SUN       Sun Microsystems, Inc.
+ SYMBIOS   Symbios Logic Inc.
+ SyQuest   SyQuest Technology, Inc.
+ SYSGEN    Sysgen
+ T-MITTON  Transmitton England
+ TALARIS   Talaris Systems, Inc.
+ TALLGRAS  Tallgrass Technologies
+ TANDBERG  Tandberg Data A/S
+ TANDON    Tandon
+ TDK       TDK Corporation
+ TEAC      TEAC Japan
+ TECOLOTE  Tecolote Designs
+ TEGRA     Tegra Varityper
+ Tek       Tektronix
+ TENTIME   Laura Technologies, Inc.
+ TI-DSG    Texas Instruments
+ TMS       Texas Memory Systems, Inc.
+ TOSHIBA   Toshiba Japan
+ TRIPACE   Tripace
+ ULTRA     UltraStor Corporation
+ UNISYS    Unisys
+ USCORE    Underscore, Inc.
+ USDC      US Design Corp.
+ VDS       Victor Data Systems Co., Ltd.
+ VERBATIM  Verbatim Corporation
+ VEXCEL    VEXCEL IMAGING GmbH
+ VICOMSL1  Vicom Systems, Inc.
+ VRC       Vermont Research Corp.
+ WangDAT   WangDAT
+ WANGTEK   Wangtek
+ WDIGTL    Western Digital
+ WEARNES   Wearnes Technology Corporation
+ WSC0001   Wisecom, Inc.
+ X3        National Committee for Information Technology Standards (NCITS)
+ XEBEC     Xebec Corporation
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/utils/Config.help linux/drivers/message/fusion/utils/Config.help
--- ../ia64/linux/drivers/message/fusion/utils/Config.help	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/utils/Config.help	Tue Mar 19 16:05:36 2002
@@ -0,0 +1,112 @@
+
+Fusion MPT device support
+CONFIG_FUSION
+  LSI Logic Fusion(TM) Message Passing Technology (MPT) device support
+  provides high performance SCSI host initiator, and LAN [1] interface
+  services to a host system.  The Fusion architecture is capable of
+  duplexing these protocols on high-speed Fibre Channel
+  (up to 2 GHz x 2 ports = 4 GHz) and parallel SCSI (up to Ultra-320)
+  physical medium.
+
+          [1] LAN is not supported on parallel SCSI medium.
+
+  These drivers require a Fusion MPT compatible PCI adapter installed in
+  the host system.  MPT adapters contain specialized I/O processors
+  to handle I/O workload, and more importantly to offload this work
+  from the host CPU(s).
+
+  If you have Fusion MPT hardware and want to use it, you can say
+  Y or M here to add MPT (base + ScsiHost) drivers.
+    <Y> = build lib (fusion.o), and link [static] into the kernel [2] proper
+    <M> = compiled as [dynamic] modules [3] named: (mptbase.o, mptscsih.o)
+
+          [2] In order enable capability to boot the linux kernel natively
+              from a Fusion MPT target device, you MUST answer Y here!
+              (currently requires CONFIG_BLK_DEV_SD)
+          [3] This support is also available as a module
+              ( = code which can be inserted in and removed
+              from the running kernel whenever you want).
+              If you want to compile as modules, say M here and read
+              Documentation/modules.txt.
+
+  If unsure, say N.
+
+  If you say Y or M here you will get a choice of these
+  additional protocol and support module options:           Module Name:
+    <M>   Enhanced SCSI error reporting                       (isense.o)
+    <M>   Fusion MPT misc device (ioctl) driver               (mptctl.o)
+    <M>   Fusion MPT LAN driver                               (mptlan.o)
+
+  ---
+  Fusion MPT is trademark of LSI Logic Corporation, and it's architecture
+  is based on LSI Logic's Message Passing Interface (MPI) specification.
+
+Fusion MPT enhanced SCSI error reporting [optional] module
+CONFIG_FUSION_ISENSE
+  The isense module (roughly stands for Interpret SENSE data) is
+  completely optional.  It simply provides extra English readable
+  strings in SCSI Error Report(s) that might be generated from the
+  Fusion MPT SCSI Host driver, for example when a target device
+  returns a SCSI check condition on a I/O.  Without this module
+  loaded you might see:
+
+    SCSI Error Report =-=-= (ioc0,scsi5:0)
+      SCSI_Status=02h (CHECK_CONDITION)
+      Original_CDB[]: 2A 00 00 00 00 41 00 00 02 00
+      SenseData[12h]: 70 00 02 00 00 00 00 0A 00 00 00 00 04 02 02 00 00 00
+      SenseKey=2h (NOT READY); FRU=02h
+      ASC/ASCQ=29h/00h
+
+  Where otherwise, if this module had been loaded, you would see:
+
+    SCSI Error Report =-=-= (ioc0,scsi5:0)
+      SCSI_Status=02h (CHECK_CONDITION)
+      Original_CDB[]: 2A 00 00 00 00 41 00 00 02 00 - "WRITE(10)"
+      SenseData[12h]: 70 00 02 00 00 00 00 0A 00 00 00 00 04 02 02 00 00 00
+      SenseKey=2h (NOT READY); FRU=02h
+      ASC/ASCQ=29h/00h "LOGICAL UNIT NOT READY, INITIALIZING CMD. REQUIRED"
+
+  Say M for "Enhanced SCSI error reporting" to compile this optional module,
+  creating a driver named: isense.o
+
+  NOTE: Support for building this feature into the kernel is not
+  available, due to kernel size considerations.
+
+Fusion MPT misc device (ioctl) driver [optional] module
+CONFIG_FUSION_CTL
+  The Fusion MPT misc device driver provides specialized control
+  of MPT adapters via system ioctl calls.  Use of ioctl calls to
+  the MPT driver requires that you create and use a misc device
+  node ala:
+    mknod /dev/mptctl c 10 220
+
+  One use of this ioctl interface is to perform an upgrade (reflash)
+  of the MPT adapter firmware.  Refer to readme file(s) distributed
+  with the Fusion MPT linux driver for additional details.
+
+  If enabled by saying M to this, a driver named: mptctl.o
+  will be compiled.
+
+  If unsure whether you really want or need this, say no.
+
+Fusion MPT LAN driver [optional]
+CONFIG_FUSION_LAN
+  This module supports LAN IP traffic over Fibre Channel port(s)
+  on Fusion MPT compatible hardware (LSIFC9xx chips).
+  The physical interface used is defined in RFC 2625.
+  Please refer to that document for details.
+
+  Installing this driver requires the knowledge to configure and
+  activate a new network interface, "fc0", using standard Linux tools.
+
+  If enabled by saying M to this, a driver named: mptlan.o
+  will be compiled.
+
+  If unsure whether you really want or need this, say no.
+
+  NOTES: This feature is NOT available nor supported for linux-2.2.x
+  kernels.  You must be building a linux-2.3.x or linux-2.4.x kernel
+  in order to configure this option.
+  Support for building this feature into the linux kernel is not
+  yet available.
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/utils/makefile linux/drivers/message/fusion/utils/makefile
--- ../ia64/linux/drivers/message/fusion/utils/makefile	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/utils/makefile	Tue Mar 19 16:05:36 2002
@@ -0,0 +1,42 @@
+# drivers/message/fusion/utils/makefile
+
+ifndef $(TOPDIR)
+	TOPDIR = ../../../..
+endif
+ifndef $(HOSTCC)
+	CC = gcc
+endif
+
+BIG_CONFIG_HELP = $(TOPDIR)/Documentation/Configure.help
+
+CFLAGS = -g -O -Wall -I. -I.. -I$(TOPDIR)/include
+
+default all: check_fusion_help mptflash what mptfdu
+
+check_fusion_help: $(TOPDIR)/Documentation/Configure.help FRC
+	@ if ! grep '^Fusion MPT device support$$' $< >/dev/null 2>&1; then\
+		cat Config.help >> $<;\
+		echo "$@: Appended Fusion MPT help sections to ${<F}";\
+	else\
+		echo "$@: Check of ${<F} for Fusion MPT help sections: OK";\
+	fi
+
+$(TOPDIR)/Documentation/Configure.help: Config.help FRC
+
+
+clean:
+	rm -f *.o mptflash what mptfdu
+
+FRC:
+
+# Dependencies...
+mptflash.o: mptflash.c ../mptbase.h makefile
+what.o: what.c makefile
+mptfdu.o: mptfdu.c makefile\
+  ../mptbase.h ../linux_compat.h ../scsi3.h \
+  ../lsi/mpi_type.h ../lsi/mpi.h ../lsi/mpi_ioc.h \
+  ../lsi/mpi_cnfg.h ../lsi/mpi_init.h ../lsi/mpi_lan.h \
+  ../lsi/mpi_raid.h ../lsi/mpi_fc.h ../lsi/mpi_targ.h \
+  ../lsi/fc_log.h ../mptctl.h
+
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/utils/mptflash.c linux/drivers/message/fusion/utils/mptflash.c
--- ../ia64/linux/drivers/message/fusion/utils/mptflash.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/utils/mptflash.c	Tue Mar 19 16:05:36 2002
@@ -0,0 +1,533 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include "mptbase.h"
+#include "mptctl.h"
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+static char *mptflash_name_ver	= WHAT_MAGIC_STRING "MptFlash-" MPT_LINUX_VERSION_COMMON;
+
+/*
+ *	Special/reserved names...
+ */
+static char *ctlname	= MPT_MISCDEV_PATHNAME;
+static char *versearch	= MPT_FW_REV_MAGIC_ID_STRING;
+static int step = 0;
+
+/*
+ *  Forward protos...
+ */
+static char *get_oldver(char *results_buf, int iocnum);
+static char *what_search(const char *buf, int size_in, int *size_out);
+int verify_pid(char *fwbuf, struct mpt_fw_xfer *fwdata);
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+int
+main (int argc, char **argv)
+{
+	char userinp[128];
+	char newver[64];
+	char oldver[64];
+	char what2[64];
+	char *oldverp;
+	struct mpt_fw_xfer fwdata;
+	unsigned long ctlnum = MPTFWDOWNLOAD;
+	char *fwbuf;
+	int fwfd;
+	int ctlfd;
+	int size;
+	struct stat fwstat;
+	char *myname;
+	char *fwfname = NULL;
+	char *arg2 = NULL;
+	char *whatstr;
+	int whatsz;
+	int i, j;
+	u32 checksum;
+
+	if ( (myname = strrchr(argv[0], '/')) == NULL ) {
+		myname = argv[0];
+	} else {
+		myname++;
+		argv[0] = myname;
+	}
+	if (argc > 1)
+		fwfname = argv[1];
+	if (argc > 2)
+		arg2 = argv[2];
+	else
+		arg2 = "0";
+
+	step = 1;				/* step #1 */
+
+	if (!fwfname || strlen(fwfname)<1 || !arg2 || !isdigit(arg2[0]))
+	{
+		fprintf(stderr, "%s\n", mptflash_name_ver+4);
+		fprintf(stderr, "Usage: %s fwfname.rom [0|1|2|...|7 for ioc# ]\n", myname);
+		return step;
+	}
+	fprintf(stderr, "  step%d: Cmd line check: Ok\n", step);
+
+	fwdata.iocnum = atoi(arg2);
+	if (fwdata.iocnum > MPT_MAX_ADAPTERS || fwdata.iocnum < 0) {
+		fprintf(stderr, "  step%db: Cmd line Oops, resetting ioc from %d to 0\n", step, fwdata.iocnum);
+		fwdata.iocnum = 0;
+	}
+
+	++step;
+	if ((oldverp = get_oldver(oldver, fwdata.iocnum)) == NULL) {
+		oldverp = "unknown";
+	}
+	fprintf(stderr, "  step%d: get_oldver() results: \"%s\"\n",
+			step, oldverp);
+
+	/*
+	 *  Open f/w image file
+	 */
+	++step;
+	if ((fwfd = open(fwfname, O_RDONLY)) < 0) {
+		fprintf(stderr, "ERROR: open(\"%s\") FAILED: %s\n", fwfname, strerror(errno));
+		return step;
+	}
+	fprintf(stderr, "  step%d: open(\"%s\"): Ok, fwfd=%d\n", step, fwfname, fwfd);
+
+	/*
+	 *  Stat the f/w image file to get size
+	 */
+	++step;
+	if (fstat(fwfd, &fwstat) < 0) {
+		fprintf(stderr, "ERROR: fstat(%d) FAILED: %s\n",
+				fwfd, strerror(errno));
+		return step;
+	}
+	size = (int)fwstat.st_size;
+	fprintf(stderr, "  step%d: stat(\"%s\"): Ok, size=%d bytes\n",
+			step, fwfname, size);
+
+	/*
+	 *  Malloc big enough buffer for entire f/w image
+	 */
+	++step;
+	if ((fwbuf = malloc(size)) == NULL) {
+		fprintf(stderr, "ERROR: Firmware buffer malloc %d bytes FAILED: %s\n",
+				size, strerror(errno));
+		return step;
+	}
+	fprintf(stderr, "  step%d: malloc(%d): Ok\n", step, size);
+
+	bzero(fwbuf, size);
+
+	fwdata.fwlen = size;
+	fwdata.bufp = fwbuf;
+
+	/*
+	 *  Read all bytes from f/w image file to malloc'd buffer
+	 */
+	++step;
+	if ((j = read(fwfd, fwbuf, size)) < 0) {
+		fprintf(stderr, "ERROR: Firmware read from \"%s\" FAILED: %s\n",
+				fwfname, strerror(errno));
+		return step;
+	}
+	fprintf(stderr, "  step%d: read(%d,,%d): Ok\n", step, fwfd, size);
+
+	if (verify_pid(fwbuf, &fwdata) != 0)
+		exit(1);
+
+	/*
+	 * Checksum algorithm pulled from Stephen's lsiupdate utility
+	 * for Solaris. This should work for both little and big endian
+	 * systems.
+	 */
+
+	checksum = 0;
+	for (i = 0; i < j; i++)
+		checksum += ((U32)((U8)fwbuf[i])) << (8 * (i & 3));
+	if (checksum != 0) {
+		fprintf (stderr, "ERROR: Bad checksum for specified firmwware"
+			 " image (%s).\n", fwfname);
+		exit (1);
+	}
+
+	/*
+	 *  Scan file for new version (magic what string identifier)
+	 */
+	newver[0] = what2[0] = '\0';
+	if ((whatstr = what_search(fwbuf, size, &whatsz)) != NULL && whatsz) {
+		strncpy(newver, whatstr, MIN(sizeof(newver)-1, whatsz));
+		newver[MIN(sizeof(newver)-1, whatsz)] = '\0';
+		if ((whatstr = what_search(whatstr, size-(whatstr-fwbuf+whatsz), &whatsz)) != NULL && whatsz) {
+			strncpy(what2, whatstr, MIN(sizeof(what2)-1, whatsz));
+			what2[MIN(sizeof(what2)-1, whatsz)] = '\0';
+		}
+	}
+	fprintf(stderr, "         Current F/W Version = \"%s\"\n", oldverp);
+	fprintf(stderr, "             New F/W Version = \"%s\"\n", newver);
+
+	/*
+	 *  Open /dev/mptctl for ioctl() call
+	 */
+	++step;
+	if ((ctlfd = open(ctlname, O_RDWR)) < 0) {
+		fprintf(stderr, "ERROR: open(\"%s\") FAILED: %s\n", ctlname, strerror(errno));
+		return step;
+	}
+	fprintf(stderr, "  step%d: open(\"%s\"): Ok, ctlfd=%d\n", step, ctlname, ctlfd);
+
+	++step;
+	fprintf(stderr, "  pre-step%d: ioctl(%d,MPTFWDOWNLOAD,)\n", step, ctlfd);
+
+	fprintf(stdout, "\n  You are at irreversible step %d of %d in this process.\n",
+			step, step);
+	fprintf(stdout, "  Are you absolutely sure you want to proceed with download? (y/[n]) ");
+	fgets(userinp, sizeof(userinp), stdin);
+
+	if (userinp[0] == 'y') {
+//fprintf(stderr, "DbG: fwdata.iocnum = %02xh\n", fwdata.iocnum);
+//fprintf(stderr, "DbG: fwdata.bufp   = %p\n", fwdata.bufp);
+//fprintf(stderr, "DbG: fwdata.fwlen  = %d\n", fwdata.fwlen);
+		if (ioctl(ctlfd, ctlnum, (char *) &fwdata) < 0) {
+			fprintf(stderr, "ERROR: Firmware transfer to ioc%d FAILED: %s\n",
+					fwdata.iocnum, strerror(errno));
+			return step;
+		} else {
+			fprintf(stdout, "\n  !!! MPT firmware transfer to ioc%d SUCCEEDED !!!\n", fwdata.iocnum);
+			fprintf(stdout, "  (%d of %d f/w update steps were successful)\n\n",
+					step, step);
+			fprintf(stdout, "  CHANGE EFFECTIVE ONLY AFTER NEXT RESET / POWER CYCLE!\n\n");
+		}
+	} else {
+		fprintf(stderr, "User Aborted Download.\n");
+	}
+
+	return 0;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ * Verify that the ProductID in the FW matches the board we're
+ * sending the image to. ProductID format:
+ * 4 bits - type { FC, SCSI, Unknown }
+ * 4 bits - Product { Initiator, Target, ...}
+ * 8 bits - Family { 1030 A0, 1030 B0, ...}
+ *
+ * Return: 
+ *	-1 	unable to open proc file system
+ *	-2	mismatch in type field
+ *	-3	mismatch in family field
+ *	-4	mismatch in product field or user aborts
+ */
+int verify_pid(char *fwbuf, struct mpt_fw_xfer *fwdata)
+{
+	u16 fwpid, iocpid;
+	FILE *iocinfofp;
+	char iipath[256], fwpidbuf[256], *fpbptr;
+	char userinp[128];
+	int i;
+
+	snprintf(iipath, 256, "/proc/mpt/ioc%d/info", fwdata->iocnum);
+
+	if ((iocinfofp = fopen(iipath, "r")) == NULL) {
+		fprintf(stderr, "ERROR: unable to open %s to get ProductID of"
+			" ioc%d.\n", iipath, fwdata->iocnum);
+		return (-1);
+	}
+
+	while (1) {
+		if (fgets(fwpidbuf, 256, iocinfofp) == NULL) {
+			fprintf (stderr, "ERROR: unable to find ProductID "
+				 "string in %s.\n", iipath);
+			return (-1);
+		}
+		if (strstr(fwpidbuf, "ProductID") != NULL) {
+			fpbptr = strchr(fwpidbuf, '=');
+			fpbptr = &fpbptr[2];
+			iocpid = (u16) strtol(fpbptr, NULL, 16);
+			break;
+		}
+	}
+
+	if (iocpid == MPI_MANUFACTPAGE_DEVICEID_FC909) {
+		u8 *fwptr = (u8 *) fwbuf;
+
+		for (i = 0x017000; (i+7) < fwdata->fwlen; i++) {
+			if ((((fwptr[i+1] << 8)| fwptr[i]) == MPI_MANUFACTPAGE_DEVICEID_FC909)
+			    && (fwptr[i+2] == 0x00) && (fwptr[i+3] == 0x00)
+			    && (fwptr[i+4] == 0x00) && (fwptr[i+5] == 0x00)
+			    && (fwptr[i+6] == 0xff) && (fwptr[i+7] == 0x03)) {
+				return (0);
+			}
+		}
+		fwpid = 0xdead;
+	} else {
+		fwpid = (((u16)((u8)fwbuf[35])) << 8) | ((u16)((u8)fwbuf[34]));
+	}
+
+	/*
+	 * Check the Type (FC vs SCSI), upper nibble of pid. MUST Match
+	 */
+	if ((fwpid & MPI_FW_HEADER_PID_TYPE_MASK) != (iocpid & MPI_FW_HEADER_PID_TYPE_MASK)){
+		uint fwtype = fwpid & MPI_FW_HEADER_PID_TYPE_MASK;
+		uint ioctype = iocpid & MPI_FW_HEADER_PID_TYPE_MASK;
+
+		fprintf(stderr, "ERROR: This fw image is for %s product \n"
+			"and the specified board/ioc type is %s.\n",
+			fwtype==0?"a SCSI":(fwtype == 1?"a FC":"an unknown"),
+			ioctype==0?"SCSI":(ioctype == 1?"FC":"unknown"));
+
+		return (-2);
+	}
+
+	/*
+	 * Check the Family, lower byte. MUST Match
+	 */
+	if ((fwpid & MPI_FW_HEADER_PID_FAMILY_MASK) != (iocpid & MPI_FW_HEADER_PID_FAMILY_MASK)){
+		uint fwfam = fwpid & MPI_FW_HEADER_PID_FAMILY_MASK;
+		uint iocfam = iocpid & MPI_FW_HEADER_PID_FAMILY_MASK;
+
+		fprintf(stderr, "ERROR: This fw image is for revision %d\n"
+			" product and the specified board/ioc chip "
+			" revision is %d.\n",
+			fwfam & MPI_FW_HEADER_PID_FAMILY_MASK,
+			iocfam & MPI_FW_HEADER_PID_FAMILY_MASK);
+
+		return (-3);
+	}
+
+
+	/*
+	 * Check the Product
+	 */
+	if ((fwpid & MPI_FW_HEADER_PID_PROD_MASK) != (iocpid & MPI_FW_HEADER_PID_PROD_MASK)){
+		uint fwprod = fwpid & MPI_FW_HEADER_PID_PROD_MASK;
+		uint iocprod = iocpid & MPI_FW_HEADER_PID_PROD_MASK;
+		char *fwProdString;
+		char *iocProdString;
+
+		if ((fwpid & MPI_FW_HEADER_PID_TYPE_MASK) == MPI_FW_HEADER_PID_TYPE_SCSI) {
+			switch(fwprod) {
+			case MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI:
+				fwProdString="Initiator";
+				break;
+			case MPI_FW_HEADER_PID_PROD_TARGET_INITIATOR_SCSI:
+				fwProdString="Initiator-Target";
+				break;
+			case MPI_FW_HEADER_PID_PROD_TARGET_SCSI:
+				fwProdString="Target";
+				break;
+			case MPI_FW_HEADER_PID_PROD_IM_SCSI:
+				fwProdString="Integrated Mirroring";
+				break;
+			case MPI_FW_HEADER_PID_PROD_IS_SCSI:
+				fwProdString="Integrated Striping";
+				break;
+			case MPI_FW_HEADER_PID_PROD_CTX_SCSI:
+				fwProdString="Context";
+				break;
+			default:
+				fwProdString="Unknown";
+				break;
+			}
+
+			switch(iocprod) {
+			case MPI_FW_HEADER_PID_PROD_INITIATOR_SCSI:
+				iocProdString="Initiator";
+				break;
+			case MPI_FW_HEADER_PID_PROD_TARGET_INITIATOR_SCSI:
+				iocProdString="Initiator-Target";
+				break;
+			case MPI_FW_HEADER_PID_PROD_TARGET_SCSI:
+				iocProdString="Target";
+				break;
+			case MPI_FW_HEADER_PID_PROD_IM_SCSI:
+				iocProdString="Integrated Mirroring";
+				break;
+			case MPI_FW_HEADER_PID_PROD_IS_SCSI:
+				iocProdString="Integrated Striping";
+				break;
+			case MPI_FW_HEADER_PID_PROD_CTX_SCSI:
+				iocProdString="Context";
+				break;
+			default:
+				iocProdString="Unknown";
+				break;
+			}
+		} else  {
+			fwProdString="Unknown";
+			iocProdString="Unknown";
+		}
+
+		fprintf(stderr, "WARNING! The fw image contains %s firmware. \n"
+			" The specified board/ioc contains %s firmware. \n"
+			" Removing Integrated Mirroring or Striping firmware \n"
+			" may leave your system unable to boot.  \n",
+			fwProdString, iocProdString);
+		fprintf(stdout, "  Are you absolutely sure you want to update \n"
+			" the firwmare? (y/[n]) ");
+		fgets(userinp, sizeof(userinp), stdin);
+		if (userinp[0] == 'y')
+			;
+		else
+			return (-4);
+	}
+
+	return (0);
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *  See if we can open "/proc/mpt/iocN/summary" to obtain
+ *  current f/w version.
+ */
+static char *
+get_oldver(char *results_buf, int iocnum)
+{
+	char pname[32];
+	char oldver_scratch[256];
+	int procfd;
+	unsigned int oldver_value = 0;
+	char *str = NULL;
+	char isscsi = 0;
+
+	(void) sprintf(pname, "/proc/mpt/ioc%d/summary", iocnum);
+	if ((procfd = open(pname, O_RDONLY)) >= 0) {
+		char *found;
+		/*
+		 *  Dependency: Current format of /proc/mpt/iocN/summary output:
+		 *    iocN: ... FwRev=0e0c1800h (Exp 1218), ...\n
+		 *  or
+		 *    iocN: ... FwRev=01010100h, ...\n
+		 *
+		 *                     ^^^^^^---- What we want!
+		 */
+		if (read(procfd, oldver_scratch, sizeof(oldver_scratch)) < 0) {
+			fprintf(stderr, "         OldVer-read-fail-WARNING\n");
+		} else {
+			str = oldver_scratch;
+			if ((found = strstr(str, versearch)) != NULL) {
+				if (strstr(str, "LSI53C") != NULL)
+					isscsi = 1;
+				str = found + strlen(versearch);
+				if (sscanf(str, "%x", &oldver_value) == 1) {
+					;	// done!
+				} else {
+					fprintf(stderr, "         OldVer-sscanf-fail-WARNING\n");
+					str = NULL;
+				}
+			} else {
+				fprintf(stderr, "         OldVer-search-fail-WARNING\n");
+			}
+		}
+		close(procfd);
+	}
+
+	/*
+	 *	Changes to handle both old and new-style FWVersion encoding
+	 */
+	if ((isscsi == 0) && (oldver_value < 0x00010000)) {
+		int mdbg = 0;
+
+		if (oldver_value & 0x0080) {
+			oldver_value &= ~0x0080;
+			mdbg++;
+		}
+
+		if ((oldver_value & 0xE000) == 0xE000) {
+			oldver_value &= 0x0FFFF;
+			(void) sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d%s",
+					2001,
+					(oldver_value & 0x0F00) >> 8,
+					oldver_value & 0x00FF,
+					mdbg ? " (MDBG)" : "" );
+		} else {
+			(void) sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d%s",
+					(oldver_value & 0xF000) >> 12,
+					(oldver_value & 0x0F00) >> 8,
+					oldver_value & 0x00FF,
+					mdbg ? " (MDBG)" : "" );
+		}
+		str = results_buf;
+	} else {
+		int mdbg = 0;
+
+		if (isscsi == 0) {
+			if (oldver_value & 0x00008000) {
+				oldver_value &= ~0x00008000;
+				mdbg++;
+			}
+
+			if ((oldver_value & 0x0E000000) == 0x0E000000) {
+				oldver_value &= 0x0FFFFFF;
+				sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d%s",
+					2001,
+					(oldver_value >> 16) & 0x00FF,
+					(oldver_value >> 8) & 0x00FF,
+					mdbg ? " (MDBG)" : "" );
+			} else {
+				int	 len;
+				len = sprintf(results_buf, "LSIFC9x9-%d.%02d.%02d",
+					oldver_value >> 24,
+					(oldver_value >> 16) & 0x00FF,
+					(oldver_value >> 8) & 0x00FF);
+				if ((oldver_value & 0x0FF) != 0)
+					(void) sprintf(results_buf+len, ".%02d",
+						oldver_value & 0x0FF);
+				if (mdbg)
+					strcat(results_buf, " (MDBG)");
+			}
+		} else {
+			int	 len;
+			len = sprintf(results_buf, "LSI53Cxx-%02x.%02x.%02x",
+					oldver_value >> 24,
+					(oldver_value >> 16) & 0x00FF,
+					(oldver_value >> 8) & 0x00FF);
+			if ((oldver_value & 0x0FF) != 0)
+				(void) sprintf(results_buf+len, ".%02d",
+						oldver_value & 0x0FF);
+		}
+		str = results_buf;
+	}
+
+	return str;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+static char *
+what_search(const char *buf, int size_in, int *size_out)
+{
+	register char c;
+	register char *found = NULL;
+
+	*size_out = 0;
+	while (--size_in) {
+		c = *buf++;
+loop:
+		if (size_in < 5)
+			return NULL;
+		if (c != '@')
+			continue;
+		if (--size_in && (c = *buf++) != '(')
+			goto loop;
+		if (--size_in && (c = *buf++) != '#')
+			goto loop;
+		if (--size_in && (c = *buf++) != ')')
+			goto loop;
+		found = (char*)buf;
+		while (--size_in && (c = *buf++) && c != '"' && c != '>' && c != '\n')
+			(*size_out)++;
+//		fprintf(stderr, "\nDbG: offset=%d, size_out=%d\n", found-fwbuf, *size_out);
+		return found;
+	}
+	return NULL;
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/utils/mptflash.txt linux/drivers/message/fusion/utils/mptflash.txt
--- ../ia64/linux/drivers/message/fusion/utils/mptflash.txt	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/utils/mptflash.txt	Tue Mar 19 16:05:36 2002
@@ -0,0 +1,172 @@
+******************************************************************************
+                                 mptflash.txt
+******************************************************************************
+
+This document provides the information required to update the LSI Logic
+Fusion MPT(TM) firmware for LSIFC909, LSIFC919, LSIFC929 Fibre Channel
+and the LSI53C1020 and LSI53C1030 SCSI chips when running from a
+Linux(TM) operating system.
+
+Adapter boards: LSI40909, LSI40919, LSI44929, LSIXXXX
+
+This text file is divided into these sections:
+   MPT Flash Utility Description
+   Updating the Firmware
+   Troubleshooting
+
+*********************** MPT Flash Utility Description ************************
+
+The MPT flash utility is used to update the Fusion MPT firmware on LSIFC909,
+LSIFC919, and LSIFC929 Fibre Channel and the firmware on the 
+LSI53C1020 and LSI53C1030 SCSI chips / HABs.
+
+This utility uses the MPI FwDownload command to update the firmware image in
+flash, while the current firmare is running.  The firmware update becomes
+effective after a subsequent reboot or diagnostic reset.
+
+IMPORTANT NOTES:
+ o  Dual channel devices will appear as two separate IO controllers, from
+    the system point of view.  You only need to perform this update 
+    procedure to one of the two visible IO controllers.
+    Chips:  LSIFC929, LSI53C1030
+ o  Typically, each chip and each revisionl requires a unique firmware image. 
+    That is, the firmware for the LSIFC909 is different that that for the 
+    LSIFC929 or the LSI53C1030.  Likewise, the firmware for the LSI53C1030 
+    A0 revision and LSI53C1030 B0 revision is different.
+
+    Exceptions:  
+       o The LSIFC929 and the LSIFC919 can use the same firmware image.
+
+    WARNING! There are currently no checks to ensure that you are
+             using the proper firmware image for a given IO Controller.
+
+             USE EXTREME CAUTION WHEN USING THIS UTILITY!
+ o  The /proc filesystem MUST be enabled for this utility to be able
+    to verify the adapter.
+
+*************************** Updating the Firmware ****************************
+
+The following examples show procedures for updating a single LCIFC929 when
+a single LSIFC919, a single LSIFC929 and a single LSI53C1030 are present 
+in a system.
+
+To update the Fusion MPT firmware, complete the following steps:
+
+1. Make sure that the LSI Fibre Channel and SCSI adapters 
+   are properly installed in a system PCI slot, boot the system 
+   into Linux, and then log in as root.
+
+2. Verify that the Fusion MPT base driver is properly installed.
+      # insmod mptbase
+        Fusion MPT base driver 2.00.08
+        mptbase: Initiating ioc0 bringup
+        ioc0: FC919: Capabilities={Initiator,Target,LAN}
+        mptbase: Initiating ioc1 bringup
+        ioc1: FC929: Capabilities={Initiator,Target,LAN}
+        mptbase: Initiating ioc2 bringup
+        ioc2: FC929: Capabilities={Initiator,Target,LAN}
+        mptbase: Initiating ioc3 bringup
+        ioc3: C1030: Capabilities={Initiator}
+        mptbase: Initiating ioc4 bringup
+        ioc4: C1030: Capabilities={Initiator}
+        mptbase: 5 MPT adapters found, 5 installed.
+
+3. Verify and the current layout and version of existing MPT I/O controllers.
+      # cat /proc/mpt/summary
+        ioc0: LSIFC919, FwRev=01000000h, Ports=1, MaxQ=256, \
+                                        LanAddr=00:A0:B8:04:78:55, IRQ=9
+        ioc1: LSIFC929, FwRev=00090000h, Ports=1, MaxQ=256, \
+                                        LanAddr=00:A0:B8:04:0B:32, IRQ=10
+        ioc2: LSIFC929, FwRev=00090000h, Ports=1, MaxQ=256, \
+                                        LanAddr=00:A0:B8:04:0B:33, IRQ=5
+        ioc3: LSI53C1030, FwRev=00000700h, Ports=1, MaxQ=256, IRQ=17
+        ioc4: LSI53C1030, FwRev=00000700h, Ports=1, MaxQ=256, IRQ=19
+
+   NOTE: The ioc1 and ioc2 entries in the listing above represent a 
+   single LSIFC929, ioc3 and ioc4 entries represent a single LSI53C1030.
+
+4. Verify that the Fusion MPT misc device (ioctl) driver is loaded.
+      # insmod mptctl
+        Fusion MPT misc device (ioctl) driver 2.00.08
+        mptctl: Registered with Fusion MPT base driver
+        mptctl: /dev/mptctl @ (major,minor=10,220)
+
+5. Make sure that a proper /dev/mptctl character special device node exists.
+   It should look something like this:
+      # ls -l /dev/mptctl
+        crw-r--r--   1 root     root      10, 220 Dec 27 16:32 /dev/mptctl
+
+   If you don't have one, create it with this command:
+      # mknod /dev/mptctl c 10 220
+
+6. Create the mptflash utility program, by changing to the
+   drivers/message/fusion/utils subdirectory:
+      # cd /usr/src/linux/drivers/message/fusion/utils
+
+   and then execute this command:
+      # make mptflash
+        gcc -g -O -Wall -I. -I.. -I../../../../include   -c mptflash.c \
+                                        -o mptflash.o
+        gcc   mptflash.o   -o mptflash
+
+   Now move the resulting mptflash program to a useful place:
+      # mv mptflash /sbin
+
+7. Find the appropriate IOC firmware image file you want to update to,
+   for example:
+      # cd /tmp
+      # ls -l fc929-100.rom
+        -rw-rw-r--   1 fibre    fibre      195876 Jul 19 01:00 fc929-100.rom
+
+8. Now execute the mptflash utility program, specifying which IOC you will
+   be updating.  For our example we want to update the single LSIFC929
+   which is represented as ioc1 (and ioc2) for this example:
+      # mptflash fc929-100.rom 1
+          step1: Cmd line check: Ok
+          step2: get_oldver() results: "LSIFC9x9-0.09.00"
+          step3: open("fc929-100.rom"): Ok, fwfd=3
+          step4: stat("fc929-100.rom"): Ok, size=195876 bytes
+          step5: malloc(195876): Ok
+          step6: read(3,,195876): Ok
+                 Current F/W Version = "LSIFC9x9-0.09.00"
+                     New F/W Version = "LSIFC929-1.00.00  (2001.07.19)"
+          step7: open("/dev/mptctl"): Ok, ctlfd=4
+          pre-step8: ioctl(4,MPTFWDOWNLOAD,)
+
+          Okay, this is like, a *really* DANGEROUS procedure.
+
+          You are at irreversible step 8 of 8 in this process.
+          Are you absolutely sure you want to do this? (y/[n]) _
+
+   Press "y" followed by <Enter> to begin the process.
+   It should only take about 10-25 seconds and you should see:
+
+          !!! MPT firmware transfer to ioc1 SUCCEEDED !!!
+          (8 of 8 f/w update steps were successful)
+
+          CHANGE EFFECTIVE ONLY AFTER NEXT RESET / POWER CYCLE!
+
+9. Reboot your system!
+
+****************************** Troubleshooting *******************************
+
+If firmware download using mptflash fails, the only recourse is to reinstall
+the firmware using the DOS-based utility. 
+    Chip Name         Utility
+    --------------------------
+    FC909               FcProm
+    FC919               FcUtil
+    FC929               FcUtil
+    53C1020             flsh1030
+    53C1030             flsh1030
+
+These utilities are available from:  XXXX
+
+
+******************************************************************************
+
+Fusion MPT is a trademark of LSI Logic Corporation
+Linux is a registered trademark of Linus Torvalds
+
+*****************************************************************************
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/message/fusion/utils/what.c linux/drivers/message/fusion/utils/what.c
--- ../ia64/linux/drivers/message/fusion/utils/what.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/message/fusion/utils/what.c	Wed Feb 27 15:25:31 2002
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 1980, 1988 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef lint
+char copyright[] =
+"@(#) Copyright (c) 1980, 1988 Regents of the University of California.\n All rights reserved.\n";
+#endif /* not lint */
+
+#ifndef lint
+static char sccsid[] = "@(#)what.c	5.5 (Berkeley) 3/2/91";
+#endif /* not lint */
+
+int search(int stop);
+
+#include <stdio.h>
+#include <string.h>
+
+/*
+ * what
+ */
+/* ARGSUSED */
+int
+main(int argc, char **argv)
+{
+	 int stop = 0;
+
+	if (argc > 1) {
+		if (strcmp(*++argv, "-s") == 0)
+			stop++;
+		else
+			argv--;
+	}
+
+	if (!*++argv)
+		search(stop);
+	else do {
+		if (!freopen(*argv, "rb", stdin)) {
+			perror(*argv);
+			return 1;
+		}
+		printf("%s:\n", *argv);
+		search(stop);
+	} while(*++argv);
+	return 0;
+}
+
+int
+search(int stop)
+{
+	register int c;
+
+	while ((c = getchar()) != EOF) {
+loop:		if (c != '@')
+			continue;
+		if ((c = getchar()) != '(')
+			goto loop;
+		if ((c = getchar()) != '#')
+			goto loop;
+		if ((c = getchar()) != ')')
+			goto loop;
+		putchar('\t');
+		while ((c = getchar()) != EOF && c && c != '"' &&
+		    c != '>' && c != '\n')
+			putchar(c);
+		putchar('\n');
+        if (stop)
+            return 0;
+	}
+    return 0;
+}
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/Config.in linux/drivers/net/Config.in
--- ../ia64/linux/drivers/net/Config.in	Fri Jan 25 13:11:21 2002
+++ linux/drivers/net/Config.in	Mon Apr  8 15:34:15 2002
@@ -227,12 +227,15 @@
 if [ "$CONFIG_ACENIC" != "n" ]; then
    bool '  Omit support for old Tigon I based AceNICs' CONFIG_ACENIC_OMIT_TIGON_I
 fi
+dep_tristate 'Broadcom BCM5700 support' CONFIG_NET_BROADCOM $CONFIG_PCI
 dep_tristate 'D-Link DL2000-based Gigabit Ethernet support' CONFIG_DL2K $CONFIG_PCI
+dep_tristate 'Intel Pro/1000 Gigabit Ethernet support' CONFIG_E1000 $CONFIG_PCI
 dep_tristate 'MyriCOM Gigabit Ethernet support' CONFIG_MYRI_SBUS $CONFIG_SBUS
 dep_tristate 'National Semiconduct DP83820 support' CONFIG_NS83820 $CONFIG_PCI
 dep_tristate 'Packet Engines Hamachi GNIC-II support' CONFIG_HAMACHI $CONFIG_PCI
 dep_tristate 'Packet Engines Yellowfin Gigabit-NIC support (EXPERIMENTAL)' CONFIG_YELLOWFIN $CONFIG_PCI $CONFIG_EXPERIMENTAL
 dep_tristate 'SysKonnect SK-98xx support' CONFIG_SK98LIN $CONFIG_PCI
+dep_tristate 'Broadcom Tigon3 support' CONFIG_TIGON3 $CONFIG_PCI
 
 endmenu
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/Makefile linux/drivers/net/Makefile
--- ../ia64/linux/drivers/net/Makefile	Fri Jan 25 13:11:21 2002
+++ linux/drivers/net/Makefile	Mon Apr  8 15:34:15 2002
@@ -29,6 +29,14 @@
   obj-$(CONFIG_ISDN) += slhc.o
 endif
 
+ifeq ($(CONFIG_NET_BROADCOM),y)
+  obj-y += bcm/bcm5700.o
+endif
+
+ifeq ($(CONFIG_E1000),y)
+  obj-y += e1000/e1000.o
+endif
+
 subdir-$(CONFIG_NET_PCMCIA) += pcmcia
 subdir-$(CONFIG_NET_WIRELESS) += wireless
 subdir-$(CONFIG_TULIP) += tulip
@@ -40,6 +48,9 @@
 subdir-$(CONFIG_APPLETALK) += appletalk
 subdir-$(CONFIG_SK98LIN) += sk98lin
 subdir-$(CONFIG_SKFP) += skfp
+subdir-$(CONFIG_NET_BROADCOM) += bcm
+
+subdir-$(CONFIG_E1000) += e1000
 
 #
 # link order important here
@@ -78,6 +89,7 @@
 obj-$(CONFIG_NS83820) += ns83820.o
 obj-$(CONFIG_STNIC) += stnic.o 8390.o
 obj-$(CONFIG_FEALNX) += fealnx.o
+obj-$(CONFIG_TIGON3) += tg3.o
 
 ifeq ($(CONFIG_SK98LIN),y)
 obj-y += sk98lin/sk98lin.o
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/acenic.c linux/drivers/net/acenic.c
--- ../ia64/linux/drivers/net/acenic.c	Fri Jan 25 13:11:21 2002
+++ linux/drivers/net/acenic.c	Mon Apr  8 12:57:44 2002
@@ -819,10 +819,13 @@
 		if (ap->version >= 2)
 			writel(readl(&regs->CpuBCtrl) | CPU_HALT,
 			       &regs->CpuBCtrl);
+		readl(&regs->CpuCtrl);	/* GGG flush write */
+
 		/*
 		 * This clears any pending interrupts
 		 */
 		writel(1, &regs->Mb0Lo);
+		readl(&regs->Mb0Lo);	/* GGG flush write */
 
 		/*
 		 * Make sure no other CPUs are processing interrupts
@@ -1094,35 +1097,28 @@
 	 * to any crashes involving the NIC
 	 */
 	writel(HW_RESET | (HW_RESET << 24), &regs->HostCtrl);
-	wmb();
+	wmb(); readl(&regs->HostCtrl);	/* GGG flush write */
+	mdelay(1);
 
 	/*
-	 * Don't access any other registes before this point!
+	 * Don't access any other registers before this point!
 	 */
-#ifdef __BIG_ENDIAN
 	/*
 	 * This will most likely need BYTE_SWAP once we switch
 	 * to using __raw_writel()
 	 */
-#ifdef __parisc__
-	writel((WORD_SWAP | BYTE_SWAP | CLR_INT |
-		((WORD_SWAP | BYTE_SWAP | CLR_INT) << 24)),
-	       &regs->HostCtrl);
-#else
-	writel((WORD_SWAP | CLR_INT | ((WORD_SWAP | CLR_INT) << 24)),
-	       &regs->HostCtrl);
-#endif
-#else
 	writel((CLR_INT | WORD_SWAP | ((CLR_INT | WORD_SWAP) << 24)),
 	       &regs->HostCtrl);
-#endif
-	mb();
+	mb();	readl(&regs->HostCtrl);	/* GGG flush write */
 
 	/*
 	 * Stop the NIC CPU and clear pending interrupts
 	 */
 	writel(readl(&regs->CpuCtrl) | CPU_HALT, &regs->CpuCtrl);
+	readl(&regs->CpuCtrl);	/* GGG flush write */
+
 	writel(0, &regs->Mb0Lo);
+	readl(&regs->Mb0Lo);	/* GGG flush write */
 
 	tig_ver = readl(&regs->HostCtrl) >> 28;
 
@@ -1141,6 +1137,7 @@
 		       tig_ver, tigon2FwReleaseMajor, tigon2FwReleaseMinor,
 		       tigon2FwReleaseFix);
 		writel(readl(&regs->CpuBCtrl) | CPU_HALT, &regs->CpuBCtrl);
+		readl(&regs->CpuBCtrl); /* GGG flush write */
 		/*
 		 * The SRAM bank size does _not_ indicate the amount
 		 * of memory on the card, it controls the _bank_ size!
@@ -1171,7 +1168,7 @@
 	writel(ACE_BYTE_SWAP_DMA | ACE_WARN | ACE_FATAL |
 	       ACE_WORD_SWAP_BD | ACE_NO_JUMBO_FRAG, &regs->ModeStat);
 #endif
-	mb();
+	mb(); readl(&regs->ModeStat); 	/* GGG flush write */
 
 	mac1 = 0;
 	for(i = 0; i < 4; i++) {
@@ -1308,7 +1305,7 @@
 	tmp &= ~DMA_READ_WRITE_MASK;
 	tmp |= DMA_READ_MAX_128;
 	/*
-	 * All the docs sy MUST NOT. Well, I did.
+	 * All the docs say MUST NOT. Well, I did.
 	 * Nothing terrible happens, if we load wrong size.
 	 * Bit w&i still works better!
 	 */
@@ -1317,6 +1314,12 @@
 	writel(tmp, &regs->PciState);
 
 #if 0
+/* The Host PCI bus controller driver has to set FBB.
+ * If all devices on that PCI bus support FBB, then the controller
+ * can enable FBB support in the Host PCI Bus controller (or on
+ * the PCI-PCI bridge if that applies).
+ * -ggg
+ */
 	/*
 	 * I have received reports from people having problems when this
 	 * bit is enabled.
@@ -1385,6 +1388,7 @@
 	memset(ap->skb, 0, sizeof(struct ace_skb));
 
 	ace_load_firmware(dev);
+
 	ap->fw_running = 0;
 
 	tmp_ptr = ap->info_dma;
@@ -1396,9 +1400,9 @@
 	set_aceaddr(&info->evt_ctrl.rngptr, ap->evt_ring_dma);
 	info->evt_ctrl.flags = 0;
 
-	set_aceaddr(&info->evt_prd_ptr, ap->evt_prd_dma);
 	*(ap->evt_prd) = 0;
-	wmb();
+	set_aceaddr(&info->evt_prd_ptr, ap->evt_prd_dma);
+
 	writel(0, &regs->EvtCsm);
 
 	set_aceaddr(&info->cmd_ctrl.rngptr, 0x100);
@@ -1508,9 +1512,9 @@
 	writel(DMA_THRESH_8W, &regs->DmaWriteCfg);
 #endif
 
-	writel(0, &regs->MaskInt);
 	writel(1, &regs->IfIdx);
-	writel(1, &regs->AssistState);
+	writel(0, &regs->MaskInt);
+	readl(&regs->MaskInt);	/* GGG flush write */
 
 	writel(DEF_STAT, &regs->TuneStatTicks);
 	writel(DEF_TRACE, &regs->TuneTrace);
@@ -1601,6 +1605,7 @@
 		writel(tigon2FwStartAddr, &regs->Pc);
 
 	writel(0, &regs->Mb0Lo);
+	readl(&regs->Mb0Lo);	/* GGG flush write */
 
 	/*
 	 * Set tx_csm before we start receiving interrupts, otherwise
@@ -1620,10 +1625,21 @@
 	 */
 	memset(&ap->stats, 0, sizeof(ap->stats));
 
+        /*
+	 * Enable DMA engine now.
+	 * If we do this sooner, Mckinley box pukes.
+	 * I assume it's because Tigon II DMA engine wants to check
+	 * *something* even before the CPU is started.
+	 */
+	writel(1, &regs->AssistState);	/* enable DMA */
+	readl(&regs->AssistState);	/* GGG flush write */
+	mdelay(1);
+
 	/*
 	 * Start the NIC CPU
 	 */
 	writel(readl(&regs->CpuCtrl) & ~(CPU_HALT|CPU_TRACE), &regs->CpuCtrl);
+	readl(&regs->CpuCtrl);	/* GGG flush write */
 
 	/*
 	 * Wait for the firmware to spin up - max 3 seconds.
@@ -1636,6 +1652,7 @@
 
 		ace_dump_trace(ap);
 		writel(readl(&regs->CpuCtrl) | CPU_HALT, &regs->CpuCtrl);
+		readl(&regs->CpuCtrl);	/* GGG flush write */
 
 		/* aman@sgi.com - account for badly behaving firmware/NIC:
 		 * - have observed that the NIC may continue to generate
@@ -1650,6 +1667,7 @@
 			writel(readl(&regs->CpuBCtrl) | CPU_HALT,
 			       &regs->CpuBCtrl);
 		writel(0, &regs->Mb0Lo);
+		readl(&regs->Mb0Lo);	/* GGG flush write */
 
 		ecode = -EBUSY;
 		goto init_error;
@@ -2312,6 +2330,7 @@
 	 * threads and it is wrong even for that case.
 	 */
 	writel(0, &regs->Mb0Lo);
+	readl(&regs->Mb0Lo);	/* GGG flush write */
 
 	/*
 	 * There is no conflict between transmit handling in
@@ -3072,6 +3091,7 @@
 			 tigon2FwRodataLen);
 		ace_copy(regs, tigon2FwData, tigon2FwDataAddr,tigon2FwDataLen);
 	}
+	readl(&regs->CpuCtrl);	/* GGG flush write */
 
 	return 0;
 }
@@ -3096,23 +3116,24 @@
 {
 	u32 local;
 
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local = readl(&regs->LocalCtrl);
 	local |= EEPROM_DATA_OUT | EEPROM_WRITE_ENABLE;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local |= EEPROM_CLK_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local &= ~EEPROM_DATA_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	local &= ~EEPROM_CLK_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);	/* GGG flush write */
 }
 
 
@@ -3126,7 +3147,7 @@
 	local &= ~EEPROM_DATA_OUT;
 	local |= EEPROM_WRITE_ENABLE;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 
 	for (i = 0; i < 8; i++, magic <<= 1) {
 		udelay(ACE_SHORT_DELAY);
@@ -3135,16 +3156,16 @@
 		else
 			local &= ~EEPROM_DATA_OUT;
 		writel(local, &regs->LocalCtrl);
-		mb();
+		mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 
 		udelay(ACE_SHORT_DELAY);
 		local |= EEPROM_CLK_OUT;
 		writel(local, &regs->LocalCtrl);
-		mb();
+		mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 		udelay(ACE_SHORT_DELAY);
 		local &= ~(EEPROM_CLK_OUT | EEPROM_DATA_OUT);
 		writel(local, &regs->LocalCtrl);
-		mb();
+		mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	}
 }
 
@@ -3157,18 +3178,18 @@
 	local = readl(&regs->LocalCtrl);
 	local &= ~EEPROM_WRITE_ENABLE;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	udelay(ACE_LONG_DELAY);
 	local |= EEPROM_CLK_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	udelay(ACE_SHORT_DELAY);
 	/* sample data in middle of high clk */
 	state = (readl(&regs->LocalCtrl) & EEPROM_DATA_IN) != 0;
 	udelay(ACE_SHORT_DELAY);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 	writel(readl(&regs->LocalCtrl) & ~EEPROM_CLK_OUT, &regs->LocalCtrl);
-	mb();
+	mb(); readl(&regs->LocalCtrl);  /* GGG flush write */
 
 	return state;
 }
@@ -3223,7 +3244,7 @@
 	regs = ((struct ace_private *)dev->priv)->regs;
 
 	/*
-	 * Don't take interrupts on this CPU will bit banging
+	 * Don't take interrupts on this CPU while bit banging
 	 * the %#%#@$ I2C device
 	 */
 	__save_flags(flags);
@@ -3271,12 +3292,14 @@
 		local = readl(&regs->LocalCtrl);
 		local &= ~EEPROM_WRITE_ENABLE;
 		writel(local, &regs->LocalCtrl);
+		readl(&regs->LocalCtrl);	/* GGG flush write */
 		udelay(ACE_LONG_DELAY);
 		mb();
 		local |= EEPROM_CLK_OUT;
 		writel(local, &regs->LocalCtrl);
-		mb();
+		readl(&regs->LocalCtrl);	/* GGG flush write */
 		udelay(ACE_SHORT_DELAY);
+		mb();
 		/* sample data mid high clk */
 		result = (result << 1) |
 			((readl(&regs->LocalCtrl) & EEPROM_DATA_IN) != 0);
@@ -3285,11 +3308,13 @@
 		local = readl(&regs->LocalCtrl);
 		local &= ~EEPROM_CLK_OUT;
 		writel(local, &regs->LocalCtrl);
+		readl(&regs->LocalCtrl);	/* GGG flush write */
 		udelay(ACE_SHORT_DELAY);
 		mb();
 		if (i == 7) {
 			local |= EEPROM_WRITE_ENABLE;
 			writel(local, &regs->LocalCtrl);
+			readl(&regs->LocalCtrl);	/* GGG flush write */
 			mb();
 			udelay(ACE_SHORT_DELAY);
 		}
@@ -3297,12 +3322,12 @@
 
 	local |= EEPROM_DATA_OUT;
 	writel(local, &regs->LocalCtrl);
-	mb();
+	mb();	readl(&regs->LocalCtrl);	/* GGG Flush write */
 	udelay(ACE_SHORT_DELAY);
 	writel(readl(&regs->LocalCtrl) | EEPROM_CLK_OUT, &regs->LocalCtrl);
 	udelay(ACE_LONG_DELAY);
 	writel(readl(&regs->LocalCtrl) & ~EEPROM_CLK_OUT, &regs->LocalCtrl);
-	mb();
+	mb();	readl(&regs->LocalCtrl);	/* GGG Flush write */
 	udelay(ACE_SHORT_DELAY);
 	eeprom_stop(regs);
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/5701rls.c linux/drivers/net/bcm/5701rls.c
--- ../ia64/linux/drivers/net/bcm/5701rls.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/5701rls.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,48 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*                                                                            */
+/******************************************************************************/
+
+#if INCLUDE_5701_AX_FIX
+
+#include "mm.h"
+#include "5701rls.h"
+
+LM_STATUS LM_LoadRlsFirmware(PLM_DEVICE_BLOCK pDevice)
+{
+  T3_FWIMG_INFO FwImgInfo;
+
+  FwImgInfo.StartAddress = t3FwStartAddr;
+  FwImgInfo.Text.Buffer = (PLM_UINT8)t3FwText;
+  FwImgInfo.Text.Offset  = t3FwTextAddr;
+  FwImgInfo.Text.Length  = t3FwTextLen;
+  FwImgInfo.ROnlyData.Buffer = (PLM_UINT8)t3FwRodata;
+  FwImgInfo.ROnlyData.Offset  = t3FwRodataAddr;
+  FwImgInfo.ROnlyData.Length  = t3FwRodataLen;
+  FwImgInfo.Data.Buffer = (PLM_UINT8)t3FwData;
+  FwImgInfo.Data.Offset  = t3FwDataAddr;
+  FwImgInfo.Data.Length  = t3FwDataLen;
+
+  if (LM_LoadFirmware(pDevice,
+                      &FwImgInfo,
+                      T3_RX_CPU_ID | T3_TX_CPU_ID,
+                      T3_RX_CPU_ID) != LM_STATUS_SUCCESS)
+    {
+      DbgMessage(FATAL, ("Failed loading firmware.\n"));
+      DbgBreak();
+      return LM_STATUS_FAILURE;
+    }
+  
+  return LM_STATUS_SUCCESS;
+}
+
+#endif /* INCLUDE_5701_AX_FIX */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/5701rls.h linux/drivers/net/bcm/5701rls.h
--- ../ia64/linux/drivers/net/bcm/5701rls.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/5701rls.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,198 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+typedef unsigned long U32;
+int t3FwReleaseMajor = 0x0;
+int t3FwReleaseMinor = 0x0;
+int t3FwReleaseFix = 0x0;
+U32 t3FwStartAddr = 0x08000000;
+U32 t3FwTextAddr = 0x08000000;
+int t3FwTextLen = 0x9c0;
+U32 t3FwRodataAddr = 0x080009c0;
+int t3FwRodataLen = 0x60;
+U32 t3FwDataAddr = 0x08000a40;
+int t3FwDataLen = 0x20;
+U32 t3FwSbssAddr = 0x08000a60;
+int t3FwSbssLen = 0xc;
+U32 t3FwBssAddr = 0x08000a70;
+int t3FwBssLen = 0x10;
+U32 t3FwText[(0x9c0/4) + 1] = {
+0x0, 
+0x10000003, 0x0, 0xd, 0xd, 
+0x3c1d0800, 0x37bd3ffc, 0x3a0f021, 0x3c100800, 
+0x26100000, 0xe000018, 0x0, 0xd, 
+0x3c1d0800, 0x37bd3ffc, 0x3a0f021, 0x3c100800, 
+0x26100034, 0xe00021c, 0x0, 0xd, 
+0x0, 0x0, 0x0, 0x27bdffe0, 
+0x3c1cc000, 0xafbf0018, 0xaf80680c, 0xe00004c, 
+0x241b2105, 0x97850000, 0x97870002, 0x9782002c, 
+0x9783002e, 0x3c040800, 0x248409c0, 0xafa00014, 
+0x21400, 0x621825, 0x52c00, 0xafa30010, 
+0x8f860010, 0xe52825, 0xe000060, 0x24070102, 
+0x3c02ac00, 0x34420100, 0x3c03ac01, 0x34630100, 
+0xaf820490, 0x3c02ffff, 0xaf820494, 0xaf830498, 
+0xaf82049c, 0x24020001, 0xaf825ce0, 0xe00003f, 
+0xaf825d00, 0xe000140, 0x0, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x2402ffff, 0xaf825404, 
+0x8f835400, 0x34630400, 0xaf835400, 0xaf825404, 
+0x3c020800, 0x24420034, 0xaf82541c, 0x3e00008, 
+0xaf805400, 0x0, 0x0, 0x3c020800, 
+0x34423000, 0x3c030800, 0x34633000, 0x3c040800, 
+0x348437ff, 0x3c010800, 0xac220a64, 0x24020040, 
+0x3c010800, 0xac220a68, 0x3c010800, 0xac200a60, 
+0xac600000, 0x24630004, 0x83102b, 0x5040fffd, 
+0xac600000, 0x3e00008, 0x0, 0x804821, 
+0x8faa0010, 0x3c020800, 0x8c420a60, 0x3c040800, 
+0x8c840a68, 0x8fab0014, 0x24430001, 0x44102b, 
+0x3c010800, 0xac230a60, 0x14400003, 0x4021, 
+0x3c010800, 0xac200a60, 0x3c020800, 0x8c420a60, 
+0x3c030800, 0x8c630a64, 0x91240000, 0x21140, 
+0x431021, 0x481021, 0x25080001, 0xa0440000, 
+0x29020008, 0x1440fff4, 0x25290001, 0x3c020800, 
+0x8c420a60, 0x3c030800, 0x8c630a64, 0x8f84680c, 
+0x21140, 0x431021, 0xac440008, 0xac45000c, 
+0xac460010, 0xac470014, 0xac4a0018, 0x3e00008, 
+0xac4b001c, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x2000008, 
+0x0, 0xa0001e3, 0x3c0a0001, 0xa0001e3, 
+0x3c0a0002, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x3c0a0007, 0xa0001e3, 0x3c0a0008, 0xa0001e3, 
+0x3c0a0009, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x3c0a000b, 0xa0001e3, 
+0x3c0a000c, 0xa0001e3, 0x3c0a000d, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x3c0a000e, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x0, 0xa0001e3, 
+0x0, 0xa0001e3, 0x3c0a0013, 0xa0001e3, 
+0x3c0a0014, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x27bdffe0, 
+0x1821, 0x1021, 0xafbf0018, 0xafb10014, 
+0xafb00010, 0x3c010800, 0x220821, 0xac200a70, 
+0x3c010800, 0x220821, 0xac200a74, 0x3c010800, 
+0x220821, 0xac200a78, 0x24630001, 0x1860fff5, 
+0x2442000c, 0x24110001, 0x8f906810, 0x32020004, 
+0x14400005, 0x24040001, 0x3c020800, 0x8c420a78, 
+0x18400003, 0x2021, 0xe000182, 0x0, 
+0x32020001, 0x10400003, 0x0, 0xe000169, 
+0x0, 0xa000153, 0xaf915028, 0x8fbf0018, 
+0x8fb10014, 0x8fb00010, 0x3e00008, 0x27bd0020, 
+0x3c050800, 0x8ca50a70, 0x3c060800, 0x8cc60a80, 
+0x3c070800, 0x8ce70a78, 0x27bdffe0, 0x3c040800, 
+0x248409d0, 0xafbf0018, 0xafa00010, 0xe000060, 
+0xafa00014, 0xe00017b, 0x2021, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x24020001, 0x8f836810, 
+0x821004, 0x21027, 0x621824, 0x3e00008, 
+0xaf836810, 0x27bdffd8, 0xafbf0024, 0x1080002e, 
+0xafb00020, 0x8f825cec, 0xafa20018, 0x8f825cec, 
+0x3c100800, 0x26100a78, 0xafa2001c, 0x34028000, 
+0xaf825cec, 0x8e020000, 0x18400016, 0x0, 
+0x3c020800, 0x94420a74, 0x8fa3001c, 0x221c0, 
+0xac830004, 0x8fa2001c, 0x3c010800, 0xe000201, 
+0xac220a74, 0x10400005, 0x0, 0x8e020000, 
+0x24420001, 0xa0001df, 0xae020000, 0x3c020800, 
+0x8c420a70, 0x21c02, 0x321c0, 0xa0001c5, 
+0xafa2001c, 0xe000201, 0x0, 0x1040001f, 
+0x0, 0x8e020000, 0x8fa3001c, 0x24420001, 
+0x3c010800, 0xac230a70, 0x3c010800, 0xac230a74, 
+0xa0001df, 0xae020000, 0x3c100800, 0x26100a78, 
+0x8e020000, 0x18400028, 0x0, 0xe000201, 
+0x0, 0x14400024, 0x0, 0x8e020000, 
+0x3c030800, 0x8c630a70, 0x2442ffff, 0xafa3001c, 
+0x18400006, 0xae020000, 0x31402, 0x221c0, 
+0x8c820004, 0x3c010800, 0xac220a70, 0x97a2001e, 
+0x2442ff00, 0x2c420300, 0x1440000b, 0x24024000, 
+0x3c040800, 0x248409dc, 0xafa00010, 0xafa00014, 
+0x8fa6001c, 0x24050008, 0xe000060, 0x3821, 
+0xa0001df, 0x0, 0xaf825cf8, 0x3c020800, 
+0x8c420a40, 0x8fa3001c, 0x24420001, 0xaf835cf8, 
+0x3c010800, 0xac220a40, 0x8fbf0024, 0x8fb00020, 
+0x3e00008, 0x27bd0028, 0x27bdffe0, 0x3c040800, 
+0x248409e8, 0x2821, 0x3021, 0x3821, 
+0xafbf0018, 0xafa00010, 0xe000060, 0xafa00014, 
+0x8fbf0018, 0x3e00008, 0x27bd0020, 0x8f82680c, 
+0x8f85680c, 0x21827, 0x3182b, 0x31823, 
+0x431024, 0x441021, 0xa2282b, 0x10a00006, 
+0x0, 0x401821, 0x8f82680c, 0x43102b, 
+0x1440fffd, 0x0, 0x3e00008, 0x0, 
+0x3c040800, 0x8c840000, 0x3c030800, 0x8c630a40, 
+0x64102b, 0x54400002, 0x831023, 0x641023, 
+0x2c420008, 0x3e00008, 0x38420001, 0x27bdffe0, 
+0x802821, 0x3c040800, 0x24840a00, 0x3021, 
+0x3821, 0xafbf0018, 0xafa00010, 0xe000060, 
+0xafa00014, 0xa000216, 0x0, 0x8fbf0018, 
+0x3e00008, 0x27bd0020, 0x0, 0x27bdffe0, 
+0x3c1cc000, 0xafbf0018, 0xe00004c, 0xaf80680c, 
+0x3c040800, 0x24840a10, 0x3802821, 0x3021, 
+0x3821, 0xafa00010, 0xe000060, 0xafa00014, 
+0x2402ffff, 0xaf825404, 0x3c0200aa, 0xe000234, 
+0xaf825434, 0x8fbf0018, 0x3e00008, 0x27bd0020, 
+0x0, 0x0, 0x0, 0x27bdffe8, 
+0xafb00010, 0x24100001, 0xafbf0014, 0x3c01c003, 
+0xac200000, 0x8f826810, 0x30422000, 0x10400003, 
+0x0, 0xe000246, 0x0, 0xa00023a, 
+0xaf905428, 0x8fbf0014, 0x8fb00010, 0x3e00008, 
+0x27bd0018, 0x27bdfff8, 0x8f845d0c, 0x3c0200ff, 
+0x3c030800, 0x8c630a50, 0x3442fff8, 0x821024, 
+0x1043001e, 0x3c0500ff, 0x34a5fff8, 0x3c06c003, 
+0x3c074000, 0x851824, 0x8c620010, 0x3c010800, 
+0xac230a50, 0x30420008, 0x10400005, 0x871025, 
+0x8cc20000, 0x24420001, 0xacc20000, 0x871025, 
+0xaf825d0c, 0x8fa20000, 0x24420001, 0xafa20000, 
+0x8fa20000, 0x8fa20000, 0x24420001, 0xafa20000, 
+0x8fa20000, 0x8f845d0c, 0x3c030800, 0x8c630a50, 
+0x851024, 0x1443ffe8, 0x851824, 0x27bd0008, 
+0x3e00008, 0x0, 0x0, 0x0 };
+U32 t3FwRodata[(0x60/4) + 1] = {
+0x35373031, 0x726c7341, 0x0, 
+0x0, 0x53774576, 0x656e7430, 0x0, 
+0x726c7045, 0x76656e74, 0x31000000, 0x556e6b6e, 
+0x45766e74, 0x0, 0x0, 0x0, 
+0x0, 0x66617461, 0x6c457272, 0x0, 
+0x0, 0x4d61696e, 0x43707542, 0x0, 
+0x0, 0x0 };
+U32 t3FwData[(0x20/4) + 1] = {
+0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0 };
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/Makefile linux/drivers/net/bcm/Makefile
--- ../ia64/linux/drivers/net/bcm/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/Makefile	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,13 @@
+
+#
+# Makefile for linux/drivers/net/bcm
+#
+
+O_TARGET := bcm5700.o
+obj-y    := b57um.o b57proc.o tigon3.o autoneg.o 5701rls.o
+obj-m    := $(O_TARGET)
+
+EXTRA_CFLAGS = -DDBG=0 -DT3_JUMBO_RCV_RCB_ENTRY_COUNT=256 -DNICE_SUPPORT -DPCIX_TARGET_WORKAROUND=1 -DINCLUDE_TBI_SUPPORT -DINCLUDE_5701_AX_FIX=1
+
+include $(TOPDIR)/Rules.make
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/autoneg.c linux/drivers/net/bcm/autoneg.c
--- ../ia64/linux/drivers/net/bcm/autoneg.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/autoneg.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,535 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+#if INCLUDE_TBI_SUPPORT
+#include "autoneg.h"
+#include "mm.h"
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+MM_AnTxConfig(
+    PAN_STATE_INFO pAnInfo)
+{
+    PLM_DEVICE_BLOCK pDevice;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    REG_WR(pDevice, MacCtrl.TxAutoNeg, (LM_UINT32) pAnInfo->TxConfig.AsUSHORT);
+
+    pDevice->MacMode |= MAC_MODE_SEND_CONFIGS;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+MM_AnTxIdle(
+    PAN_STATE_INFO pAnInfo)
+{
+    PLM_DEVICE_BLOCK pDevice;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    pDevice->MacMode &= ~MAC_MODE_SEND_CONFIGS;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+char
+MM_AnRxConfig(
+    PAN_STATE_INFO pAnInfo,
+    unsigned short *pRxConfig)
+{
+    PLM_DEVICE_BLOCK pDevice;
+    LM_UINT32 Value32;
+    char Retcode;
+
+    Retcode = AN_FALSE;
+
+    pDevice = (PLM_DEVICE_BLOCK) pAnInfo->pContext;
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if(Value32 & MAC_STATUS_RECEIVING_CFG)
+    {
+        Value32 = REG_RD(pDevice, MacCtrl.RxAutoNeg);
+        *pRxConfig = (unsigned short) Value32;
+
+        Retcode = AN_TRUE;
+    }
+
+    return Retcode;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+void
+AutonegInit(
+    PAN_STATE_INFO pAnInfo)
+{
+    unsigned long j;
+
+    for(j = 0; j < sizeof(AN_STATE_INFO); j++)
+    {
+        ((unsigned char *) pAnInfo)[j] = 0;
+    }
+
+    /* Initialize the default advertisement register. */
+    pAnInfo->mr_adv_full_duplex = 1;
+    pAnInfo->mr_adv_sym_pause = 1;
+    pAnInfo->mr_adv_asym_pause = 1;
+    pAnInfo->mr_an_enable = 1;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+AUTONEG_STATUS
+Autoneg8023z(
+    PAN_STATE_INFO pAnInfo)
+{
+    unsigned short RxConfig;
+    unsigned long Delta_us;
+    AUTONEG_STATUS AnRet;
+
+    /* Get the current time. */
+    if(pAnInfo->State == AN_STATE_UNKNOWN)
+    {
+        pAnInfo->RxConfig.AsUSHORT = 0;
+        pAnInfo->CurrentTime_us = 0;
+        pAnInfo->LinkTime_us = 0;
+        pAnInfo->AbilityMatchCfg = 0;
+        pAnInfo->AbilityMatchCnt = 0;
+        pAnInfo->AbilityMatch = AN_FALSE;
+        pAnInfo->IdleMatch = AN_FALSE;
+        pAnInfo->AckMatch = AN_FALSE;
+    }
+
+    /* Increment the timer tick.  This function is called every microsecon. */
+//    pAnInfo->CurrentTime_us++;
+
+    /* Set the AbilityMatch, IdleMatch, and AckMatch flags if their */
+    /* corresponding conditions are satisfied. */
+    if(MM_AnRxConfig(pAnInfo, &RxConfig))
+    {
+        if(RxConfig != pAnInfo->AbilityMatchCfg)
+        {
+            pAnInfo->AbilityMatchCfg = RxConfig;
+            pAnInfo->AbilityMatch = AN_FALSE;
+            pAnInfo->AbilityMatchCnt = 0;
+        }
+        else
+        {
+            pAnInfo->AbilityMatchCnt++;
+            if(pAnInfo->AbilityMatchCnt > 1)
+            {
+                pAnInfo->AbilityMatch = AN_TRUE;
+                pAnInfo->AbilityMatchCfg = RxConfig;
+            }
+        }
+
+        if(RxConfig & AN_CONFIG_ACK)
+        {
+            pAnInfo->AckMatch = AN_TRUE;
+        }
+        else
+        {
+            pAnInfo->AckMatch = AN_FALSE;
+        }
+
+        pAnInfo->IdleMatch = AN_FALSE;
+    }
+    else
+    {
+        pAnInfo->IdleMatch = AN_TRUE;
+
+        pAnInfo->AbilityMatchCfg = 0;
+        pAnInfo->AbilityMatchCnt = 0;
+        pAnInfo->AbilityMatch = AN_FALSE;
+        pAnInfo->AckMatch = AN_FALSE;
+
+        RxConfig = 0;
+    }
+
+    /* Save the last Config. */
+    pAnInfo->RxConfig.AsUSHORT = RxConfig;
+
+    /* Default return code. */
+    AnRet = AUTONEG_STATUS_OK;
+
+    /* Autoneg state machine as defined in 802.3z section 37.3.1.5. */
+    switch(pAnInfo->State)
+    {
+        case AN_STATE_UNKNOWN:
+            if(pAnInfo->mr_an_enable || pAnInfo->mr_restart_an)
+            {
+                pAnInfo->CurrentTime_us = 0;
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+            }
+
+            /* Fall through.*/
+
+        case AN_STATE_AN_ENABLE:
+            pAnInfo->mr_an_complete = AN_FALSE;
+            pAnInfo->mr_page_rx = AN_FALSE;
+
+            if(pAnInfo->mr_an_enable)
+            {
+                pAnInfo->LinkTime_us = 0;
+                pAnInfo->AbilityMatchCfg = 0;
+                pAnInfo->AbilityMatchCnt = 0;
+                pAnInfo->AbilityMatch = AN_FALSE;
+                pAnInfo->IdleMatch = AN_FALSE;
+                pAnInfo->AckMatch = AN_FALSE;
+
+                pAnInfo->State = AN_STATE_AN_RESTART_INIT;
+            }
+            else
+            {
+                pAnInfo->State = AN_STATE_DISABLE_LINK_OK;
+            }
+            break;
+
+        case AN_STATE_AN_RESTART_INIT:
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+            pAnInfo->mr_np_loaded = AN_FALSE;
+
+            pAnInfo->TxConfig.AsUSHORT = 0;
+            MM_AnTxConfig(pAnInfo);
+
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            pAnInfo->State = AN_STATE_AN_RESTART;
+
+            /* Fall through.*/
+
+        case AN_STATE_AN_RESTART:
+            /* Get the current time and compute the delta with the saved */
+            /* link timer. */
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+                pAnInfo->State = AN_STATE_ABILITY_DETECT_INIT;
+            }
+            else
+            {
+                AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+            }
+            break;
+
+        case AN_STATE_DISABLE_LINK_OK:
+            AnRet = AUTONEG_STATUS_DONE;
+            break;
+
+        case AN_STATE_ABILITY_DETECT_INIT:
+            /* Note: in the state diagram, this variable is set to */
+            /* mr_adv_ability<12>.  Is this right?. */
+            pAnInfo->mr_toggle_tx = AN_FALSE;
+
+#if DBG
+            DbgMessage(INFORM, ("TxConfig: "));
+
+            if(pAnInfo->mr_adv_full_duplex)
+            {
+                DbgMessage(INFORM, ("FD "));
+            }
+
+            if(pAnInfo->mr_adv_half_duplex)
+            {
+                DbgMessage(INFORM, ("HD "));
+            }
+
+            if(pAnInfo->mr_adv_sym_pause)
+            {
+                DbgMessage(INFORM, ("PS1 "));
+            }
+
+            if(pAnInfo->mr_adv_asym_pause)
+            {
+                DbgMessage(INFORM, ("PS2 "));
+            }
+
+            if(pAnInfo->mr_adv_remote_fault1)
+            {
+                DbgMessage(INFORM, ("RF1 "));
+            }
+
+            if(pAnInfo->mr_adv_remote_fault2)
+            {
+                DbgMessage(INFORM, ("RF2 "));
+            }
+
+            if(pAnInfo->mr_adv_next_page)
+            {
+                DbgMessage(INFORM, ("NP "));
+            }
+
+            DbgMessage(INFORM, ("\n"));
+#endif
+
+            /* Send the config as advertised in the advertisement register. */
+            pAnInfo->TxConfig.AsUSHORT = 0;
+            pAnInfo->TxConfig.D5_FD = pAnInfo->mr_adv_full_duplex;
+            pAnInfo->TxConfig.D6_HD = pAnInfo->mr_adv_half_duplex;
+            pAnInfo->TxConfig.D7_PS1 = pAnInfo->mr_adv_sym_pause;
+            pAnInfo->TxConfig.D8_PS2 = pAnInfo->mr_adv_asym_pause;
+            pAnInfo->TxConfig.D12_RF1 = pAnInfo->mr_adv_remote_fault1;
+            pAnInfo->TxConfig.D13_RF2 = pAnInfo->mr_adv_remote_fault2;
+            pAnInfo->TxConfig.D15_NP = pAnInfo->mr_adv_next_page;
+
+            MM_AnTxConfig(pAnInfo);
+
+            pAnInfo->State = AN_STATE_ABILITY_DETECT;
+
+            break;
+
+        case AN_STATE_ABILITY_DETECT:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT != 0)
+            {
+                pAnInfo->State = AN_STATE_ACK_DETECT_INIT;
+            }
+
+            break;
+
+        case AN_STATE_ACK_DETECT_INIT:
+            pAnInfo->TxConfig.D14_ACK = 1;
+            MM_AnTxConfig(pAnInfo);
+
+            pAnInfo->State = AN_STATE_ACK_DETECT;
+
+            /* Fall through. */
+
+        case AN_STATE_ACK_DETECT:
+            if(pAnInfo->AckMatch == AN_TRUE)
+            {
+                if((pAnInfo->RxConfig.AsUSHORT & ~AN_CONFIG_ACK) ==
+                    (pAnInfo->AbilityMatchCfg & ~AN_CONFIG_ACK))
+                {
+                    pAnInfo->State = AN_STATE_COMPLETE_ACK_INIT;
+                }
+                else
+                {
+                    DbgMessage(FATAL, ("1 ACK_DETECT ===> AN_ENABLE.\n"));
+                    pAnInfo->State = AN_STATE_AN_ENABLE;
+                }
+            }
+            else if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("2 ACK_DETECT ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+            }
+
+            break;
+
+        case AN_STATE_COMPLETE_ACK_INIT:
+            /* Make sure invalid bits are not set. */
+            if(pAnInfo->RxConfig.bits.D0 || pAnInfo->RxConfig.bits.D1 ||
+                pAnInfo->RxConfig.bits.D2 || pAnInfo->RxConfig.bits.D3 ||
+                pAnInfo->RxConfig.bits.D4 || pAnInfo->RxConfig.bits.D9 ||
+                pAnInfo->RxConfig.bits.D10 || pAnInfo->RxConfig.bits.D11)
+            {
+                DbgMessage(FATAL, ("Received an invalid Config.\n"));
+                DbgBreak();
+                AnRet = AUTONEG_STATUS_FAILED;
+                break;
+            }
+
+            /* Set up the link partner advertisement register. */
+            pAnInfo->mr_lp_adv_full_duplex = pAnInfo->RxConfig.D5_FD;
+            pAnInfo->mr_lp_adv_half_duplex = pAnInfo->RxConfig.D6_HD;
+            pAnInfo->mr_lp_adv_sym_pause = pAnInfo->RxConfig.D7_PS1;
+            pAnInfo->mr_lp_adv_asym_pause = pAnInfo->RxConfig.D8_PS2;
+            pAnInfo->mr_lp_adv_remote_fault1 = pAnInfo->RxConfig.D12_RF1;
+            pAnInfo->mr_lp_adv_remote_fault2 = pAnInfo->RxConfig.D13_RF2;
+            pAnInfo->mr_lp_adv_next_page = pAnInfo->RxConfig.D15_NP;
+#if DBG
+            DbgMessage(INFORM, ("RxConfig: "));
+
+            if(pAnInfo->mr_lp_adv_full_duplex)
+            {
+                DbgMessage(INFORM, ("FD "));
+            }
+
+            if(pAnInfo->mr_lp_adv_half_duplex)
+            {
+                DbgMessage(INFORM, ("HD "));
+            }
+
+            if(pAnInfo->mr_lp_adv_sym_pause)
+            {
+                DbgMessage(INFORM, ("PS1 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_asym_pause)
+            {
+                DbgMessage(INFORM, ("PS2 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_remote_fault1)
+            {
+                DbgMessage(INFORM, ("RF1 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_remote_fault2)
+            {
+                DbgMessage(INFORM, ("RF2 "));
+            }
+
+            if(pAnInfo->mr_lp_adv_next_page)
+            {
+                DbgMessage(INFORM, ("NP "));
+            }
+
+            DbgMessage(INFORM, ("\n"));
+#endif
+
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+
+            pAnInfo->mr_toggle_tx = !pAnInfo->mr_toggle_tx;
+            pAnInfo->mr_toggle_rx = pAnInfo->RxConfig.bits.D11;
+            pAnInfo->mr_np_rx = pAnInfo->RxConfig.D15_NP;
+            pAnInfo->mr_page_rx = AN_TRUE;
+
+            pAnInfo->State = AN_STATE_COMPLETE_ACK;
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            break;
+
+        case AN_STATE_COMPLETE_ACK:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("COMPLETE_ACK ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+                break;
+            }
+
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+                if(pAnInfo->mr_adv_next_page == 0 ||
+                    pAnInfo->mr_lp_adv_next_page == 0)
+                {
+                    pAnInfo->State = AN_STATE_IDLE_DETECT_INIT;
+                }
+                else
+                {
+                    if(pAnInfo->TxConfig.bits.D15 == 0 &&
+                        pAnInfo->mr_np_rx == 0)
+                    {
+                        pAnInfo->State = AN_STATE_IDLE_DETECT_INIT;
+                    }
+                    else
+                    {
+                        DbgMessage(FATAL, ("Next page not implemented.\n"));
+                        DbgBreak();
+                        AnRet = AUTONEG_STATUS_FAILED;
+                    }
+                }
+            }
+
+            break;
+
+        case AN_STATE_IDLE_DETECT_INIT:
+            pAnInfo->LinkTime_us = pAnInfo->CurrentTime_us;
+
+            MM_AnTxIdle(pAnInfo);
+
+            pAnInfo->State = AN_STATE_IDLE_DETECT;
+
+            AnRet = AUTONEG_STATUS_TIMER_ENABLED;
+
+            break;
+
+        case AN_STATE_IDLE_DETECT:
+            if(pAnInfo->AbilityMatch == AN_TRUE &&
+                pAnInfo->RxConfig.AsUSHORT == 0)
+            {
+                DbgMessage(FATAL, ("IDLE_DETECT ===> AN_ENABLE.\n"));
+                pAnInfo->State = AN_STATE_AN_ENABLE;
+                break;
+            }
+
+            Delta_us = pAnInfo->CurrentTime_us - pAnInfo->LinkTime_us;
+            if(Delta_us > AN_LINK_TIMER_INTERVAL_US)
+            {
+//                if(pAnInfo->IdleMatch == AN_TRUE)
+//                {
+                    pAnInfo->State = AN_STATE_LINK_OK;
+//                }
+//                else
+//                {
+//                    DbgMessage(FATAL, ("Autoneg failed in IDLE_DETECT.\n"));
+//                    AnRet = AUTONEG_STATUS_FAILED;
+//                    break;
+//                }
+            }
+
+            break;
+
+        case AN_STATE_LINK_OK:
+            pAnInfo->mr_an_complete = AN_TRUE;
+            pAnInfo->mr_link_ok = AN_TRUE;
+            AnRet = AUTONEG_STATUS_DONE;
+
+            break;
+
+        case AN_STATE_NEXT_PAGE_WAIT_INIT:
+            DbgMessage(FATAL, ("Not implemented.\n"));
+            DbgBreak();
+            break;
+
+        case AN_STATE_NEXT_PAGE_WAIT:
+            DbgMessage(FATAL, ("Not implemented.\n"));
+            DbgBreak();
+            break;
+
+        default:
+            DbgMessage(FATAL, ("Invalid AN state.\n"));
+            DbgBreak();
+            AnRet = AUTONEG_STATUS_FAILED;
+            break;
+    }
+
+    return AnRet;
+}
+#endif /* INCLUDE_TBI_SUPPORT */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/autoneg.h linux/drivers/net/bcm/autoneg.h
--- ../ia64/linux/drivers/net/bcm/autoneg.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/autoneg.h	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,416 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+
+#ifndef AUTONEG_H
+#define AUTONEG_H
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+#define AN_LINK_TIMER_INTERVAL_US           9000       /* 10ms */
+
+/* TRUE, FALSE */
+#define AN_TRUE                             1
+#define AN_FALSE                            0
+
+
+
+/******************************************************************************/
+/* Main data structure for keeping track of 802.3z auto-negotation state */
+/* variables as shown in Figure 37-6 of the IEEE 802.3z specification. */
+/******************************************************************************/
+
+typedef struct
+{
+    /* Current auto-negotiation state. */
+    unsigned long State;
+    #define AN_STATE_UNKNOWN                        0
+    #define AN_STATE_AN_ENABLE                      1
+    #define AN_STATE_AN_RESTART_INIT                2
+    #define AN_STATE_AN_RESTART                     3
+    #define AN_STATE_DISABLE_LINK_OK                4
+    #define AN_STATE_ABILITY_DETECT_INIT            5
+    #define AN_STATE_ABILITY_DETECT                 6
+    #define AN_STATE_ACK_DETECT_INIT                7
+    #define AN_STATE_ACK_DETECT                     8
+    #define AN_STATE_COMPLETE_ACK_INIT              9
+    #define AN_STATE_COMPLETE_ACK                   10
+    #define AN_STATE_IDLE_DETECT_INIT               11
+    #define AN_STATE_IDLE_DETECT                    12
+    #define AN_STATE_LINK_OK                        13
+    #define AN_STATE_NEXT_PAGE_WAIT_INIT            14
+    #define AN_STATE_NEXT_PAGE_WAIT                 16
+
+    /* Link timer. */
+    unsigned long LinkTime_us;
+
+    /* Current time. */
+    unsigned long CurrentTime_us;
+
+    /* Need these values for consistency check. */
+    unsigned short AbilityMatchCfg;
+
+    /* Ability, idle, and ack match functions. */
+    unsigned long AbilityMatchCnt;
+    char AbilityMatch;
+    char IdleMatch;
+    char AckMatch;
+
+    /* Tx config data */
+    union
+    {
+        /* The TxConfig register is arranged as follows:                      */
+        /*                                                                    */
+        /* MSB                                                           LSB  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        /* | D7| D6| D5| D4| D3| D2| D1| D0|D15|D14|D13|D12|D11|D10| D9| D8|  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        struct
+        {
+#ifdef BIG_ENDIAN_HOST
+            unsigned short D7:1;        /* PS1 */
+            unsigned short D6:1;        /* HD */
+            unsigned short D5:1;        /* FD */
+            unsigned short D4:1;
+            unsigned short D3:1;
+            unsigned short D2:1;
+            unsigned short D1:1;
+            unsigned short D0:1;
+            unsigned short D15:1;       /* NP */
+            unsigned short D14:1;       /* ACK */
+            unsigned short D13:1;       /* RF2 */
+            unsigned short D12:1;       /* RF1 */
+            unsigned short D11:1;
+            unsigned short D10:1;
+            unsigned short D9:1;
+            unsigned short D8:1;        /* PS2 */
+#else /* BIG_ENDIAN_HOST */
+            unsigned int D8:1;        /* PS2 */
+            unsigned int D9:1;
+            unsigned int D10:1;
+            unsigned int D11:1;
+            unsigned int D12:1;       /* RF1 */
+            unsigned int D13:1;       /* RF2 */
+            unsigned int D14:1;       /* ACK */
+            unsigned int D15:1;       /* NP */
+            unsigned int D0:1;
+            unsigned int D1:1;
+            unsigned int D2:1;
+            unsigned int D3:1;
+            unsigned int D4:1;
+            unsigned int D5:1;        /* FD */
+            unsigned int D6:1;        /* HD */
+            unsigned int D7:1;        /* PS1 */
+#endif
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define D8_PS2                      bits.D8
+        #define D12_RF1                     bits.D12
+        #define D13_RF2                     bits.D13
+        #define D14_ACK                     bits.D14
+        #define D15_NP                      bits.D15
+        #define D5_FD                       bits.D5
+        #define D6_HD                       bits.D6
+        #define D7_PS1                      bits.D7
+    } TxConfig;
+
+    /* Rx config data */
+    union
+    {
+        /* The RxConfig register is arranged as follows:                      */
+        /*                                                                    */
+        /* MSB                                                           LSB  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        /* | D7| D6| D5| D4| D3| D2| D1| D0|D15|D14|D13|D12|D11|D10| D9| D8|  */
+        /* +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+  */
+        struct
+        {
+#ifdef BIG_ENDIAN_HOST
+	    unsigned short D7:1;        /* PS1 */
+            unsigned short D6:1;        /* HD */
+	    unsigned short D5:1;        /* FD */
+            unsigned short D4:1;
+            unsigned short D3:1;
+            unsigned short D2:1;
+            unsigned short D1:1;
+            unsigned short D0:1;
+  	    unsigned short D15:1;       /* NP */
+            unsigned short D14:1;       /* ACK */
+            unsigned short D13:1;       /* RF2 */    
+            unsigned short D12:1;       /* RF1 */
+            unsigned short D11:1;
+            unsigned short D10:1;
+            unsigned short D9:1;
+            unsigned short D8:1;        /* PS2 */
+#else /* BIG_ENDIAN_HOST */
+            unsigned int D8:1;        /* PS2 */
+            unsigned int D9:1;
+            unsigned int D10:1;
+            unsigned int D11:1;
+            unsigned int D12:1;       /* RF1 */
+            unsigned int D13:1;       /* RF2 */
+            unsigned int D14:1;       /* ACK */
+            unsigned int D15:1;       /* NP */
+            unsigned int D0:1;
+            unsigned int D1:1;
+            unsigned int D2:1;
+            unsigned int D3:1;
+            unsigned int D4:1;
+            unsigned int D5:1;        /* FD */
+            unsigned int D6:1;        /* HD */
+            unsigned int D7:1;        /* PS1 */
+#endif
+        } bits;
+
+        unsigned short AsUSHORT;
+    } RxConfig;
+
+    #define AN_CONFIG_NP                            0x0080
+    #define AN_CONFIG_ACK                           0x0040
+    #define AN_CONFIG_RF2                           0x0020
+    #define AN_CONFIG_RF1                           0x0010
+    #define AN_CONFIG_PS2                           0x0001
+    #define AN_CONFIG_PS1                           0x8000
+    #define AN_CONFIG_HD                            0x4000
+    #define AN_CONFIG_FD                            0x2000
+
+
+    /* Management registers. */
+
+    /* Control register. */
+    union
+    {
+        struct
+        {
+            unsigned int an_enable:1;
+            unsigned int loopback:1;
+            unsigned int reset:1;
+            unsigned int restart_an:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_an_enable                Mr0.bits.an_enable
+        #define mr_loopback                 Mr0.bits.loopback
+        #define mr_main_reset               Mr0.bits.reset
+        #define mr_restart_an               Mr0.bits.restart_an
+    } Mr0;
+
+    /* Status register. */
+    union
+    {
+        struct
+        {
+            unsigned int an_complete:1;
+            unsigned int link_ok:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_an_complete              Mr1.bits.an_complete
+        #define mr_link_ok                  Mr1.bits.link_ok
+    } Mr1;
+
+    /* Advertisement register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_4:5;
+            unsigned int full_duplex:1;
+            unsigned int half_duplex:1;
+            unsigned int sym_pause:1;
+            unsigned int asym_pause:1;
+            unsigned int reserved_11:3;
+            unsigned int remote_fault1:1;
+            unsigned int remote_fault2:1;
+            unsigned int reserved_14:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_adv_full_duplex          Mr4.bits.full_duplex
+        #define mr_adv_half_duplex          Mr4.bits.half_duplex
+        #define mr_adv_sym_pause            Mr4.bits.sym_pause
+        #define mr_adv_asym_pause           Mr4.bits.asym_pause
+        #define mr_adv_remote_fault1        Mr4.bits.remote_fault1
+        #define mr_adv_remote_fault2        Mr4.bits.remote_fault2
+        #define mr_adv_next_page            Mr4.bits.next_page
+    } Mr4;
+
+    /* Link partner advertisement register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_4:5;
+            unsigned int lp_full_duplex:1;
+            unsigned int lp_half_duplex:1;
+            unsigned int lp_sym_pause:1;
+            unsigned int lp_asym_pause:1;
+            unsigned int reserved_11:3;
+            unsigned int lp_remote_fault1:1;
+            unsigned int lp_remote_fault2:1;
+            unsigned int lp_ack:1;
+            unsigned int lp_next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_lp_adv_full_duplex       Mr5.bits.lp_full_duplex
+        #define mr_lp_adv_half_duplex       Mr5.bits.lp_half_duplex
+        #define mr_lp_adv_sym_pause         Mr5.bits.lp_sym_pause
+        #define mr_lp_adv_asym_pause        Mr5.bits.lp_asym_pause
+        #define mr_lp_adv_remote_fault1     Mr5.bits.lp_remote_fault1
+        #define mr_lp_adv_remote_fault2     Mr5.bits.lp_remote_fault2
+        #define mr_lp_adv_next_page         Mr5.bits.lp_next_page
+    } Mr5;
+
+    /* Auto-negotiation expansion register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_0:1;
+            unsigned int page_received:1;
+            unsigned int next_pageable:1;
+            unsigned int reserved_15:13;
+        } bits;
+
+        unsigned short AsUSHORT;
+    } Mr6;
+
+    /* Auto-negotiation next page transmit register. */
+    union
+    {
+        struct
+        {
+            unsigned int code_field:11;
+            unsigned int toggle:1;
+            unsigned int ack2:1;
+            unsigned int message_page:1;
+            unsigned int reserved_14:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_np_tx                    Mr7.AsUSHORT
+    } Mr7;
+
+    /* Auto-negotiation link partner ability register. */
+    union
+    {
+        struct
+        {
+            unsigned int code_field:11;
+            unsigned int toggle:1;
+            unsigned int ack2:1;
+            unsigned int message_page:1;
+            unsigned int ack:1;
+            unsigned int next_page:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+        
+        #define mr_lp_np_rx                 Mr8.AsUSHORT
+    } Mr8;
+
+    /* Extended status register. */
+    union
+    {
+        struct
+        {
+            unsigned int reserved_11:12;
+            unsigned int base1000_t_hd:1;
+            unsigned int base1000_t_fd:1;
+            unsigned int base1000_x_hd:1;
+            unsigned int base1000_x_fd:1;
+        } bits;      
+
+        unsigned short AsUSHORT;
+    } Mr15;
+
+    /* Miscellaneous state variables. */
+    union
+    {
+        struct
+        {
+            unsigned int toggle_tx:1;
+            unsigned int toggle_rx:1;
+            unsigned int np_rx:1;
+            unsigned int page_rx:1;
+            unsigned int np_loaded:1;
+        } bits;
+
+        unsigned short AsUSHORT;
+
+        #define mr_toggle_tx                MrMisc.bits.toggle_tx
+        #define mr_toggle_rx                MrMisc.bits.toggle_rx
+        #define mr_np_rx                    MrMisc.bits.np_rx
+        #define mr_page_rx                  MrMisc.bits.page_rx
+        #define mr_np_loaded                MrMisc.bits.np_loaded
+    } MrMisc;
+
+
+    /* Implement specifics */
+
+    /* Pointer to the operating system specific data structure. */
+    void *pContext;
+} AN_STATE_INFO, *PAN_STATE_INFO;
+
+
+
+/******************************************************************************/
+/* Return code of Autoneg8023z. */
+/******************************************************************************/
+
+typedef enum
+{
+    AUTONEG_STATUS_OK               = 0,
+    AUTONEG_STATUS_DONE             = 1,
+    AUTONEG_STATUS_TIMER_ENABLED    = 2,
+//    AUTONEG_STATUS_FAILED           = 0xffffffff,
+    AUTONEG_STATUS_FAILED           = 0xfffffff
+} AUTONEG_STATUS, *PAUTONEG_STATUS;
+
+
+
+/******************************************************************************/
+/* Function prototypes. */
+/******************************************************************************/
+
+AUTONEG_STATUS Autoneg8023z(PAN_STATE_INFO pAnInfo);
+void AutonegInit(PAN_STATE_INFO pAnInfo);
+
+
+
+/******************************************************************************/
+/* The following functions are defined in the os-dependent module. */
+/******************************************************************************/
+
+void MM_AnTxConfig(PAN_STATE_INFO pAnInfo);
+void MM_AnTxIdle(PAN_STATE_INFO pAnInfo);
+char MM_AnRxConfig(PAN_STATE_INFO pAnInfo, unsigned short *pRxConfig);
+
+
+
+#endif /* AUTONEG_H */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/b57proc.c linux/drivers/net/bcm/b57proc.c
--- ../ia64/linux/drivers/net/bcm/b57proc.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/b57proc.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,341 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* /proc file system handling code.                                           */
+/*                                                                            */
+/******************************************************************************/
+
+#include "mm.h"
+#ifdef CONFIG_PROC_FS
+
+#define NICINFO_PROC_DIR "nicinfo"
+
+static struct proc_dir_entry *bcm5700_procfs_dir;
+
+extern char bcm5700_driver[], bcm5700_version[];
+
+extern LM_UINT32 bcm5700_crc_count(PUM_DEVICE_BLOCK pUmDevice);
+
+static struct proc_dir_entry *
+proc_getdir(char *name, struct proc_dir_entry *proc_dir)
+{
+	struct proc_dir_entry *pde = proc_dir;
+
+	lock_kernel();
+	for (pde=pde->subdir; pde; pde = pde->next) {
+		if (pde->namelen && (strcmp(name, pde->name) == 0)) {
+			/* directory exists */
+			break;
+		}
+	}
+	if (pde == (struct proc_dir_entry *) 0)
+	{
+		/* create the directory */
+#if (LINUX_VERSION_CODE > 0x20300)
+		pde = proc_mkdir(name, proc_dir);
+#else
+		pde = create_proc_entry(name, S_IFDIR, proc_dir);
+#endif
+		if (pde == (struct proc_dir_entry *) 0) {
+			unlock_kernel();
+			return (pde);
+		}
+	}
+	unlock_kernel();
+	return (pde);
+}
+
+int
+bcm5700_proc_create(void)
+{
+	bcm5700_procfs_dir = proc_getdir(NICINFO_PROC_DIR, proc_net);
+
+	if (bcm5700_procfs_dir == (struct proc_dir_entry *) 0) {
+		printk(KERN_DEBUG "Could not create procfs nicinfo directory %s\n", NICINFO_PROC_DIR);
+		return -1;
+	}
+	return 0;
+}
+
+int
+bcm5700_read_pfs(char *page, char **start, off_t off, int count,
+	int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	int len = 0;
+	LM_UINT32 value32, rx_mac_errors, rx_crc_errors, rx_align_errors;
+	LM_UINT32 rx_runt_errors, rx_frag_errors, rx_long_errors;
+	LM_UINT32 rx_overrun_errors, rx_jabber_errors;
+
+	if (pUmDevice->opened == 0)
+		pStats = 0;
+
+	len += sprintf(page+len, "Description\t\t\t%s\n", pUmDevice->name);
+	len += sprintf(page+len, "Driver_Name\t\t\t%s\n", bcm5700_driver);
+	len += sprintf(page+len, "Driver_Version\t\t\t%s\n", bcm5700_version);
+	len += sprintf(page+len, "Bootcode_Version\t\t%s\n", pDevice->BootCodeVer);
+	len += sprintf(page+len, "PCI_Vendor\t\t\t0x%04x\n", pDevice->PciVendorId);
+	len += sprintf(page+len, "PCI_Device_ID\t\t\t0x%04x\n",
+		pDevice->PciDeviceId);
+	len += sprintf(page+len, "PCI_Subsystem_Vendor\t\t0x%04x\n",
+		pDevice->SubsystemVendorId);
+	len += sprintf(page+len, "PCI_Subsystem_ID\t\t0x%04x\n",
+		pDevice->SubsystemId);
+	len += sprintf(page+len, "PCI_Revision_ID\t\t\t0x%02x\n",
+		pDevice->PciRevId);
+	len += sprintf(page+len, "PCI_Slot\t\t\t%d\n",
+		PCI_SLOT(pUmDevice->pdev->devfn));
+	len += sprintf(page+len, "PCI_Bus\t\t\t\t%d\n",
+		pUmDevice->pdev->bus->number);
+
+	value32 = pDevice->PciState & (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED);
+	len += sprintf(page+len, "PCI_Bus_Speed\t\t\t%s\n",
+		(value32 == (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS)) ? "32-bit PCI 33MHz" : 
+		((value32 == (T3_PCI_STATE_32BIT_PCI_BUS |
+			T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED)) ? "32-bit PCI 66MHz" : 
+		((value32 == T3_PCI_STATE_NOT_PCI_X_BUS) ? "64-bit PCI 33MHz" : 
+		((value32 == (T3_PCI_STATE_NOT_PCI_X_BUS |
+			T3_PCI_STATE_HIGH_BUS_SPEED)) ? "64-bit PCI 66MHz" : 
+		((value32 == 0) ? "64-bit PCIX 100MHz" : 
+		(value32 == T3_PCI_STATE_HIGH_BUS_SPEED) ? "64-bit PCIX 133MHz":
+			"N/A")))));
+	len += sprintf(page+len, "Memory\t\t\t\t0x%lx\n", pUmDevice->dev->base_addr);
+	len += sprintf(page+len, "IRQ\t\t\t\t%d\n", dev->irq);
+	len += sprintf(page+len, "System_Device_Name\t\t%s\n", dev->name);
+	len += sprintf(page+len, "Current_HWaddr\t\t\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+	len += sprintf(page+len,
+		"Permanent_HWaddr\t\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+		pDevice->NodeAddress[0], pDevice->NodeAddress[1],
+		pDevice->NodeAddress[2], pDevice->NodeAddress[3],
+		pDevice->NodeAddress[4], pDevice->NodeAddress[5]);
+	len += sprintf(page+len, "Part_Number\t\t\t%s\n\n", pDevice->PartNo);
+
+	len += sprintf(page+len, "Link\t\t\t\t%s\n", 
+		(pUmDevice->opened == 0) ? "unknown" :
+    		((pDevice->LinkStatus == LM_STATUS_LINK_ACTIVE) ? "up" :
+		"down"));
+	len += sprintf(page+len, "Speed\t\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+    		((pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) ? "1000" :
+    		((pDevice->LineSpeed == LM_LINE_SPEED_100MBPS) ? "100" :
+    		(pDevice->LineSpeed == LM_LINE_SPEED_10MBPS) ? "10" : "N/A")));
+	len += sprintf(page+len, "Duplex\t\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+		((pDevice->DuplexMode == LM_DUPLEX_MODE_FULL) ? "full" :
+			"half"));
+	len += sprintf(page+len, "Flow_Control\t\t\t%s\n", 
+    		(pDevice->LinkStatus == LM_STATUS_LINK_DOWN) ? "N/A" :
+		((pDevice->FlowControl == LM_FLOW_CONTROL_NONE) ? "off" :
+		(((pDevice->FlowControl & LM_FLOW_CONTROL_RX_TX_PAUSE) ==
+			LM_FLOW_CONTROL_RX_TX_PAUSE) ? "receive/transmit" :
+		(pDevice->FlowControl & LM_FLOW_CONTROL_RECEIVE_PAUSE) ?
+			"receive" : "transmit")));
+	len += sprintf(page+len, "State\t\t\t\t%s\n", 
+    		(dev->flags & IFF_UP) ? "up" : "down");
+	len += sprintf(page+len, "MTU_Size\t\t\t%d\n\n", dev->mtu);
+	len += sprintf(page+len, "Rx_Packets\t\t\t%u\n", 
+			((pStats == 0) ? 0 :
+			pStats->ifHCInUcastPkts.Low +
+			pStats->ifHCInMulticastPkts.Low +
+			pStats->ifHCInBroadcastPkts.Low));
+	if (dev->mtu > 1500) {
+		len += sprintf(page+len, "Rx_Jumbo_Packets\t\t%u\n", 
+			((pStats == 0) ? 0 :
+			pStats->etherStatsPkts1523Octetsto2047Octets.Low +
+			pStats->etherStatsPkts2048Octetsto4095Octets.Low +
+			pStats->etherStatsPkts4096Octetsto8191Octets.Low +
+			pStats->etherStatsPkts8192Octetsto9022Octets.Low));
+	}
+	len += sprintf(page+len, "Tx_Packets\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->COSIfHCOutPkts[0].Low));
+	len += sprintf(page+len, "Rx_Bytes\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifHCInOctets.Low));
+	len += sprintf(page+len, "Tx_Bytes\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifHCOutOctets.Low));
+	if (pStats == 0) {
+		rx_crc_errors = 0;
+		rx_align_errors = 0;
+		rx_runt_errors = 0;
+		rx_frag_errors = 0;
+		rx_long_errors = 0;
+		rx_overrun_errors = 0;
+		rx_jabber_errors = 0;
+	}
+	else {
+		rx_crc_errors = bcm5700_crc_count(pUmDevice);
+		rx_align_errors = pStats->dot3StatsAlignmentErrors.Low;
+		rx_runt_errors = pStats->etherStatsUndersizePkts.Low;
+		rx_frag_errors = pStats->etherStatsFragments.Low;
+		rx_long_errors = pStats->dot3StatsFramesTooLong.Low;
+		rx_overrun_errors = pStats->nicNoMoreRxBDs.Low;
+		rx_jabber_errors = pStats->etherStatsJabbers.Low;
+	}
+	rx_mac_errors = rx_crc_errors + rx_align_errors + rx_runt_errors +
+		rx_frag_errors + rx_long_errors + rx_jabber_errors;
+	len += sprintf(page+len, "Rx_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		rx_mac_errors + rx_overrun_errors + pUmDevice->rx_misc_errors));
+	len += sprintf(page+len, "Tx_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->ifOutErrors.Low));
+	len += sprintf(page+len, "\nTx_Carrier_Errors\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->dot3StatsCarrierSenseErrors.Low));
+	len += sprintf(page+len, "Tx_Abort_Excess_Coll\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsExcessiveCollisions.Low));
+	len += sprintf(page+len, "Tx_Abort_Late_Coll\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsLateCollisions.Low));
+	len += sprintf(page+len, "Tx_Deferred_Ok\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsDeferredTransmissions.Low));
+	len += sprintf(page+len, "Tx_Single_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsSingleCollisionFrames.Low));
+	len += sprintf(page+len, "Tx_Multi_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+    		pStats->dot3StatsMultipleCollisionFrames.Low));
+	len += sprintf(page+len, "Tx_Total_Coll_Ok\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->etherStatsCollisions.Low));
+	len += sprintf(page+len, "\nRx_CRC_Errors\t\t\t%u\n", rx_crc_errors);
+	len += sprintf(page+len, "Rx_Short_Fragment_Errors\t%u\n",
+		rx_frag_errors);
+	len += sprintf(page+len, "Rx_Short_Length_Errors\t\t%u\n",
+		rx_runt_errors);
+	len += sprintf(page+len, "Rx_Long_Length_Errors\t\t%u\n",
+		rx_long_errors);
+	len += sprintf(page+len, "Rx_Align_Errors\t\t\t%u\n",
+		rx_align_errors);
+	len += sprintf(page+len, "Rx_Overrun_Errors\t\t%u\n",
+		rx_overrun_errors);
+	len += sprintf(page+len, "\nTx_MAC_Errors\t\t\t%u\n",
+		((pStats == 0) ? 0 :
+		pStats->dot3StatsInternalMacTransmitErrors.Low));
+	len += sprintf(page+len, "Rx_MAC_Errors\t\t\t%u\n\n",
+		rx_mac_errors);
+
+	len += sprintf(page+len, "Tx_Checksum\t\t\t%s\n",
+		((pDevice->TaskToOffload & LM_TASK_OFFLOAD_TX_TCP_CHECKSUM) ?
+		"ON" : "OFF"));
+	len += sprintf(page+len, "Rx_Checksum\t\t\t%s\n",
+		((pDevice->TaskToOffload & LM_TASK_OFFLOAD_RX_TCP_CHECKSUM) ?
+		"ON" : "OFF"));
+	len += sprintf(page+len, "Scatter_Gather\t\t\t%s\n",
+#if (LINUX_VERSION_CODE >= 0x20400)
+		((dev->features & NETIF_F_SG) ? "ON" : "OFF"));
+#else
+		"OFF");
+#endif
+	len += sprintf(page+len, "Tx_Desc_Count\t\t\t%u\n",
+		pDevice->TxPacketDescCnt);
+	len += sprintf(page+len, "Rx_Desc_Count\t\t\t%u\n",
+		pDevice->RxStdDescCnt);
+	len += sprintf(page+len, "Rx_Jumbo_Desc_Count\t\t%u\n",
+		pDevice->RxJumboDescCnt);
+	len += sprintf(page+len, "Adaptive_Coalescing\t\t%s\n",
+		(pUmDevice->adaptive_coalesce ? "ON" : "OFF"));
+	len += sprintf(page+len, "Rx_Coalescing_Ticks\t\t%u\n",
+		pUmDevice->rx_curr_coalesce_ticks);
+	len += sprintf(page+len, "Rx_Coalesced_Frames\t\t%u\n",
+		pUmDevice->rx_curr_coalesce_frames);
+	len += sprintf(page+len, "Tx_Coalescing_Ticks\t\t%u\n",
+		pDevice->TxCoalescingTicks);
+	len += sprintf(page+len, "Tx_Coalesced_Frames\t\t%u\n",
+		pUmDevice->tx_curr_coalesce_frames);
+	len += sprintf(page+len, "Stats_Coalescing_Ticks\t\t%u\n",
+		pDevice->StatsCoalescingTicks);
+	len += sprintf(page+len, "Wake_On_LAN\t\t\t%s\n",
+        	((pDevice->WakeUpMode & LM_WAKE_UP_MODE_MAGIC_PACKET) ?
+		"ON" : "OFF"));
+#if TIGON3_DEBUG
+	len += sprintf(page+len, "\nDmaReadWriteCtrl\t\t%x\n",
+		pDevice->DmaReadWriteCtrl);
+	len += sprintf(page+len, "\nTx_Zero_Copy_Packets\t\t%u\n",
+		pUmDevice->tx_zc_count);
+	len += sprintf(page+len, "Tx_Chksum_Packets\t\t%u\n",
+		pUmDevice->tx_chksum_count);
+	len += sprintf(page+len, "Tx_Highmem_Fragments\t\t%u\n",
+		pUmDevice->tx_himem_count);
+	len += sprintf(page+len, "Rx_Good_Chksum_Packets\t\t%u\n",
+		pUmDevice->rx_good_chksum_count);
+	len += sprintf(page+len, "Rx_Bad_Chksum_Packets\t\t%u\n",
+		pUmDevice->rx_bad_chksum_count);
+	if (!pDevice->EnableTbi) {
+        	LM_ReadPhy(pDevice, 0, &value32);
+		len += sprintf(page+len, "\nPhy_Register_0x00\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 1, &value32);
+		len += sprintf(page+len, "Phy_Register_0x01\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 2, &value32);
+		len += sprintf(page+len, "Phy_Register_0x02\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 3, &value32);
+		len += sprintf(page+len, "Phy_Register_0x03\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 4, &value32);
+		len += sprintf(page+len, "Phy_Register_0x04\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 5, &value32);
+		len += sprintf(page+len, "Phy_Register_0x05\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 9, &value32);
+		len += sprintf(page+len, "Phy_Register_0x09\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0xa, &value32);
+		len += sprintf(page+len, "Phy_Register_0x0A\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0xf, &value32);
+		len += sprintf(page+len, "Phy_Register_0x0F\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0x10, &value32);
+		len += sprintf(page+len, "Phy_Register_0x10\t\t0x%x\n", value32);
+        	LM_ReadPhy(pDevice, 0x19, &value32);
+		len += sprintf(page+len, "Phy_Register_0x19\t\t0x%x\n", value32);
+	}
+#endif
+
+	*eof = 1;
+	return len;
+}
+
+int
+bcm5700_proc_create_dev(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	if (!bcm5700_procfs_dir)
+		return -1;
+
+	sprintf(pUmDevice->pfs_name, "%s.info", dev->name);
+	pUmDevice->pfs_entry = create_proc_entry(pUmDevice->pfs_name,
+		S_IFREG, bcm5700_procfs_dir);
+	if (pUmDevice->pfs_entry == 0)
+		return -1;
+	pUmDevice->pfs_entry->read_proc = bcm5700_read_pfs;
+	pUmDevice->pfs_entry->data = dev;
+	return 0;
+}
+int
+bcm5700_proc_remove_dev(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	remove_proc_entry(pUmDevice->pfs_name, bcm5700_procfs_dir);
+	return 0;
+}
+
+#endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/b57um.c linux/drivers/net/bcm/b57um.c
--- ../ia64/linux/drivers/net/bcm/b57um.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/b57um.c	Thu Apr 11 17:38:50 2002
@@ -0,0 +1,2922 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2001 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/******************************************************************************/
+
+
+char bcm5700_driver[] = "bcm5700";
+char bcm5700_version[] = "2.2.19";
+char bcm5700_date[] = "(04/10/02)";
+
+#define B57UM
+#include "mm.h"
+
+#define TASKLET
+
+/* A few user-configurable values. */
+
+#define MAX_UNITS 16
+/* Used to pass the full-duplex flag, etc. */
+static int line_speed[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int auto_speed[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int full_duplex[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int rx_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int tx_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int auto_flow_control[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+static int mtu[MAX_UNITS] = {1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500,1500};	/* Jumbo MTU for interfaces. */
+static int tx_checksum[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int rx_checksum[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+static int scatter_gather[MAX_UNITS] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+
+#define TX_DESC_CNT DEFAULT_TX_PACKET_DESC_COUNT
+static unsigned int tx_pkt_desc_cnt[MAX_UNITS] =
+	{TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,TX_DESC_CNT,
+	TX_DESC_CNT};
+
+#define RX_DESC_CNT DEFAULT_STD_RCV_DESC_COUNT
+static unsigned int rx_std_desc_cnt[MAX_UNITS] =
+	{RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,RX_DESC_CNT,
+	RX_DESC_CNT };
+
+#define JBO_DESC_CNT DEFAULT_JUMBO_RCV_DESC_COUNT
+static unsigned int rx_jumbo_desc_cnt[MAX_UNITS] =
+	{JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,JBO_DESC_CNT,
+	JBO_DESC_CNT };
+
+#if INCLUDE_EXT_MEMORY_SUPPORT
+#define MIN_DESC_CNT DEFAULT_MINI_RCV_DESC_COUNT
+static unsigned int rx_mini_desc_cnt[MAX_UNITS] =
+	{MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,
+	MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,
+	MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,MIN_DESC_CNT,
+	MIN_DESC_CNT };
+
+#endif
+static unsigned int adaptive_coalesce[MAX_UNITS] =
+	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
+
+#define RX_COAL_TK DEFAULT_RX_COALESCING_TICKS
+static unsigned int rx_coalesce_ticks[MAX_UNITS] =
+	{RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK, RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK,RX_COAL_TK, RX_COAL_TK,RX_COAL_TK,RX_COAL_TK,
+	RX_COAL_TK};
+
+#define RX_COAL_FM DEFAULT_RX_MAX_COALESCED_FRAMES
+static unsigned int rx_max_coalesce_frames[MAX_UNITS] =
+	{RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,RX_COAL_FM,
+	RX_COAL_FM};
+
+#define TX_COAL_TK DEFAULT_TX_COALESCING_TICKS
+static unsigned int tx_coalesce_ticks[MAX_UNITS] =
+	{TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK, TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK,TX_COAL_TK, TX_COAL_TK,TX_COAL_TK,TX_COAL_TK,
+	TX_COAL_TK};
+
+#define TX_COAL_FM DEFAULT_TX_MAX_COALESCED_FRAMES
+static unsigned int tx_max_coalesce_frames[MAX_UNITS] =
+	{TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,TX_COAL_FM,
+	TX_COAL_FM};
+
+#define ST_COAL_TK DEFAULT_STATS_COALESCING_TICKS
+static unsigned int stats_coalesce_ticks[MAX_UNITS] =
+	{ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,ST_COAL_TK,
+	ST_COAL_TK,};
+
+static int enable_wol[MAX_UNITS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+/* Operational parameters that usually are not changed. */
+/* Time in jiffies before concluding the transmitter is hung. */
+#define TX_TIMEOUT  (2*HZ)
+
+#if (LINUX_VERSION_CODE < 0x02030d)
+#define pci_resource_start(dev, bar)	(dev->base_address[bar] & PCI_BASE_ADDRESS_MEM_MASK)
+#elif (LINUX_VERSION_CODE < 0x02032b)
+#define pci_resource_start(dev, bar)	(dev->resource[bar] & PCI_BASE_ADDRESS_MEM_MASK)
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+#define dev_kfree_skb_irq(skb)  dev_kfree_skb(skb)
+#define netif_wake_queue(dev)	clear_bit(0, &dev->tbusy); mark_bh(NET_BH)
+#define netif_stop_queue(dev)	set_bit(0, &dev->tbusy)
+
+static inline void netif_start_queue(struct net_device *dev)
+{
+	dev->tbusy = 0;
+	dev->interrupt = 0;
+	dev->start = 1;
+}
+
+#define netif_queue_stopped(dev)	dev->tbusy
+#define netif_running(dev)		dev->start
+
+static inline void tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	queue_task(tasklet, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static inline void tasklet_init(struct tasklet_struct *tasklet,
+				void (*func)(unsigned long),
+				unsigned long data)
+{
+        tasklet->next = NULL;
+        tasklet->sync = 0;
+        tasklet->routine = (void (*)(void *))func;
+        tasklet->data = (void *)data;
+}
+
+#define tasklet_kill(tasklet)
+
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020300)
+struct pci_device_id {
+	unsigned int vendor, device;		/* Vendor and device ID or PCI_ANY_ID */
+	unsigned int subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
+	unsigned int class, class_mask;		/* (class,subclass,prog-if) triplet */
+	unsigned long driver_data;		/* Data private to the driver */
+};
+
+#define PCI_ANY_ID		0
+
+#define pci_set_drvdata(pdev, dev)
+#define pci_get_drvdata(pdev) 0
+
+#define pci_enable_device(pdev) 0
+
+#define __devinit		__init
+#define __devinitdata		__initdata
+#define __devexit
+
+#define SET_MODULE_OWNER(dev)
+#define MODULE_DEVICE_TABLE(pci, pci_tbl)
+
+#endif
+
+#ifndef MODULE_LICENSE
+#define MODULE_LICENSE(license)
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032a)
+static inline void *pci_alloc_consistent(struct pci_dev *pdev, size_t size,
+					 dma_addr_t *dma_handle)
+{
+	void *virt_ptr;
+
+	/* Maximum in slab.c */
+	if (size > 131072)
+		return 0;
+
+	virt_ptr = kmalloc(size, GFP_KERNEL);
+	*dma_handle = virt_to_bus(virt_ptr);
+	return virt_ptr;
+}
+#define pci_free_consistent(dev, size, ptr, dma_ptr)	kfree(ptr)
+
+#define pci_map_single(dev, address, size, dir) virt_to_bus(address)
+#define pci_unmap_single(dev, dma_addr, size, dir)
+
+#endif /*#if (LINUX_VERSION_CODE < 0x02032a) */
+
+#if MAX_SKB_FRAGS
+#if (LINUX_VERSION_CODE >= 0x02040d)
+
+typedef dma_addr_t dmaaddr_high_t;
+
+#else
+
+#if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)
+
+typedef unsigned long long dmaaddr_high_t;
+
+#ifndef pci_map_page
+#define pci_map_page bcm_pci_map_page
+#endif
+
+static inline dmaaddr_high_t
+bcm_pci_map_page(struct pci_dev *dev, struct page *page,
+		    int offset, size_t size, int dir)
+{
+	dmaaddr_high_t phys;
+
+	phys = (page-mem_map) *	(dmaaddr_high_t) PAGE_SIZE + offset;
+
+	return phys;
+}
+
+#define pci_unmap_page(dev, map, size, dir)
+
+#else
+
+typedef dma_addr_t dmaaddr_high_t;
+
+/* Warning - This may not work for all architectures if HIGHMEM is defined */
+
+#ifndef pci_map_page
+#define pci_map_page(dev, page, offset, size, dir) \
+	pci_map_single(dev, page_address(page) + (offset), size, dir)
+#endif
+#ifndef pci_unmap_page
+#define pci_unmap_page(dev, map, size, dir) \
+	pci_unmap_single(dev, map, size, dir)
+#endif
+
+#endif /* #if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)*/
+
+#endif /* #if (LINUX_VERSION_CODE >= 0x02040d)*/
+#endif /* #if MAX_SKB_FRAGS*/
+
+#if (LINUX_VERSION_CODE < 0x020329)
+#define pci_set_dma_mask(pdev, mask) (0)
+#else
+#if (LINUX_VERSION_CODE < 0x020403)
+int
+pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask)
+{
+    if(! pci_dma_supported(dev, mask))
+        return -EIO;
+
+    dev->dma_mask = mask;
+
+    return 0;
+}
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020402)
+#define pci_request_regions(pdev, name) (0)
+#define pci_release_regions(pdev)
+#endif
+
+#define set_64bit_addr(paddr, low, high) \
+	(paddr)->Low = low;		\
+	(paddr)->High = high;
+
+static inline void bcm_set_addr(LM_PHYSICAL_ADDRESS *paddr, dma_addr_t addr)
+{
+	unsigned long baddr = (unsigned long) addr;
+#if (BITS_PER_LONG == 64)
+	set_64bit_addr(paddr, baddr & 0xffffffff, baddr >> 32);
+#else
+	set_64bit_addr(paddr, baddr, 0);
+#endif
+}
+
+#if defined (CONFIG_X86)
+#define NO_PCI_UNMAP 1
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020412)
+#if ! defined (NO_PCI_UNMAP)
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME) dma_addr_t ADDR_NAME;
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME) __u32 LEN_NAME;
+
+#define pci_unmap_addr(PTR, ADDR_NAME)	\
+	((PTR)->ADDR_NAME)
+
+#define pci_unmap_len(PTR, LEN_NAME)	\
+	((PTR)->LEN_NAME)
+
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL)	\
+	(((PTR)->ADDR_NAME) = (VAL))
+
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL)	\
+	(((PTR)->LEN_NAME) = (VAL))
+#else
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME)
+#define DECLARE_PCI_UNMAP_LEN(ADDR_NAME)
+
+#define pci_unmap_addr(PTR, ADDR_NAME)	0
+#define pci_unmap_len(PTR, LEN_NAME)	0
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL) do { } while (0)
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL) do { } while (0)
+#endif
+#endif
+
+#if MAX_SKB_FRAGS
+static inline void bcm_set_addr_high(LM_PHYSICAL_ADDRESS *paddr, dmaaddr_high_t addr)
+{
+#if defined(CONFIG_HIGHMEM) && defined(CONFIG_X86)
+	set_64bit_addr(paddr, (unsigned long) (addr & 0xffffffff),
+		(unsigned long) (addr >> 32));
+#else
+	bcm_set_addr(paddr, (dma_addr_t) addr);
+#endif
+}
+#endif
+
+#if ! defined(spin_is_locked)
+#define spin_is_locked(lock)    (test_bit(0,(lock)))
+#endif
+
+inline long
+bcm5700_lock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	long flags;
+	
+	if (pUmDevice->do_global_lock) {
+		spin_lock_irqsave(&pUmDevice->global_lock, flags);
+		return flags;
+	}
+	return 0;
+}
+
+inline void
+bcm5700_unlock(PUM_DEVICE_BLOCK pUmDevice, long flags)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_unlock_irqrestore(&pUmDevice->global_lock, flags);
+	}
+}
+
+inline int
+bcm5700_trylock(PUM_DEVICE_BLOCK pUmDevice, long *flags)
+{
+	if (pUmDevice->do_global_lock) {
+		if (spin_is_locked(&pUmDevice->global_lock))
+			return 0;
+		spin_lock_irqsave(&pUmDevice->global_lock, *flags);
+		return 1;
+	}
+	return 1;
+}
+
+inline void
+bcm5700_intr_lock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_lock(&pUmDevice->global_lock);
+	}
+}
+
+inline void
+bcm5700_intr_unlock(PUM_DEVICE_BLOCK pUmDevice)
+{
+	if (pUmDevice->do_global_lock) {
+		spin_unlock(&pUmDevice->global_lock);
+	}
+}
+
+/*
+ * Broadcom NIC Extension support
+ * -ffan
+ */
+#ifdef NICE_SUPPORT
+#include "nicext.h"
+
+typedef struct {
+	ushort  tag;
+	ushort  signature;
+} vlan_tag_t;
+
+#endif /* NICE_SUPPORT */
+
+typedef struct _UM_PACKET {
+	LM_PACKET lm_packet;
+	struct sk_buff *skbuff;
+#if MAX_SKB_FRAGS
+	DECLARE_PCI_UNMAP_ADDR(map[MAX_SKB_FRAGS + 1])
+	DECLARE_PCI_UNMAP_LEN(map_len[MAX_SKB_FRAGS + 1])
+#else
+	DECLARE_PCI_UNMAP_ADDR(map[1])
+	DECLARE_PCI_UNMAP_LEN(map_len[1])
+#endif
+	LM_FRAG_LIST frag_list;
+#if MAX_SKB_FRAGS
+        LM_FRAG frag_list_bufs[MAX_SKB_FRAGS];
+#endif
+} UM_PACKET, *PUM_PACKET;
+
+int MM_Packet_Desc_Size = sizeof(UM_PACKET);
+
+#if defined(MODULE)
+MODULE_AUTHOR("Michael Chan <mchan@broadcom.com>");
+MODULE_DESCRIPTION("BCM5700 Driver");
+MODULE_LICENSE("GPL");
+MODULE_PARM(debug, "i");
+MODULE_PARM(line_speed, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(auto_speed, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(full_duplex, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(auto_flow_control, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(mtu, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_checksum, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_checksum, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(scatter_gather, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_pkt_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_std_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_jumbo_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+#if INCLUDE_EXT_MEMORY_SUPPORT
+MODULE_PARM(rx_mini_desc_cnt, "1-" __MODULE_STRING(MAX_UNITS) "i");
+#endif
+MODULE_PARM(adaptive_coalesce, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(rx_max_coalesce_frames, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(tx_max_coalesce_frames, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(stats_coalesce_ticks, "1-" __MODULE_STRING(MAX_UNITS) "i");
+MODULE_PARM(enable_wol, "1-" __MODULE_STRING(MAX_UNITS) "i");
+#endif
+
+#define RUN_AT(x) (jiffies + (x))
+
+char kernel_version[] = UTS_RELEASE;
+
+#define PCI_SUPPORT_VER2
+
+#if ! defined(CAP_NET_ADMIN)
+#define capable(CAP_XXX) (suser())
+#endif
+
+#define tigon3_debug debug
+#if TIGON3_DEBUG
+static int tigon3_debug = TIGON3_DEBUG;
+#else
+static int tigon3_debug = 0;
+#endif
+
+
+#if DBG
+#define STATIC
+#else
+#define STATIC static
+#endif
+
+STATIC int bcm5700_open(struct net_device *dev);
+STATIC void bcm5700_timer(unsigned long data);
+STATIC void bcm5700_tx_timeout(struct net_device *dev);
+STATIC int bcm5700_start_xmit(struct sk_buff *skb, struct net_device *dev);
+STATIC void bcm5700_interrupt(int irq, void *dev_instance, struct pt_regs *regs);
+STATIC void bcm5700_tasklet(unsigned long data);
+STATIC int bcm5700_close(struct net_device *dev);
+STATIC struct net_device_stats *bcm5700_get_stats(struct net_device *dev);
+STATIC int bcm5700_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+STATIC void bcm5700_set_rx_mode(struct net_device *dev);
+STATIC int bcm5700_set_mac_addr(struct net_device *dev, void *p);
+STATIC int replenish_rx_buffers(PUM_DEVICE_BLOCK pUmDevice);
+STATIC int check_4G_boundary(PUM_DEVICE_BLOCK pUmDevice, PUM_PACKET pUmPacket);
+STATIC int bcm5700_freemem(struct net_device *dev);
+STATIC int bcm5700_adapt_coalesce(PUM_DEVICE_BLOCK pUmDevice);
+
+
+/* A list of all installed bcm5700 devices. */
+static struct net_device *root_tigon3_dev = NULL;
+
+typedef enum {
+	BCM5700VIGIL = 0,
+	BCM5700A6,
+	BCM5700T6,
+	BCM5700A9,
+	BCM5700T9,
+	BCM5700,
+	BCM5701A5,
+	BCM5701T1,
+	BCM5701T8,
+	BCM5701A7,
+	BCM5701A10,
+	BCM5701A12,
+	BCM5701,
+	BCM5702,
+	BCM5703,
+	BCM5703A31,
+	TC996T,
+	TC996ST,
+	TC996SSX,
+	TC996SX,
+	TC996BT,
+	TC997T,
+	TC997SX,
+	TC1000T,
+	TC940BR01,
+	TC942BR01,
+	NC6770,
+	NC7760,
+	NC7770,
+	NC7771,
+	NC7780,
+	NC7781,
+} board_t;
+
+
+/* indexed by board_t, above */
+static struct {
+	char *name;
+} board_info[] __devinitdata = {
+	{ "Broadcom Vigil B5700 1000Base-T" },
+	{ "Broadcom BCM5700 1000Base-T" },
+	{ "Broadcom BCM5700 1000Base-SX" },
+	{ "Broadcom BCM5700 1000Base-SX" },
+	{ "Broadcom BCM5700 1000Base-T" },
+	{ "Broadcom BCM5700" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-SX" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701 1000Base-T" },
+	{ "Broadcom BCM5701" },
+	{ "Broadcom BCM5702 1000Base-T" },
+	{ "Broadcom BCM5703 1000Base-T" },
+	{ "Broadcom BCM5703 1000Base-SX" },
+	{ "3Com 3C996 10/100/1000 Server NIC" },
+	{ "3Com 3C996 10/100/1000 Server NIC" },
+	{ "3Com 3C996 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C996 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C996B Gigabit Server NIC" },
+	{ "3Com 3C997 Gigabit Server NIC" },
+	{ "3Com 3C997 Gigabit Fiber-SX Server NIC" },
+	{ "3Com 3C1000 Gigabit NIC" },
+	{ "3Com 3C940 Gigabit LOM (21X21)" },
+	{ "3Com 3C942 Gigabit LOM (31X31)" },
+	{ "Compaq NC6770 Gigabit Server Adapter" },
+	{ "Compaq NC7760 Gigabit Server Adapter" },
+	{ "Compaq NC7770 Gigabit Server Adapter" },
+	{ "Compaq NC7771 Gigabit Server Adapter" },
+	{ "Compaq NC7780 Gigabit Server Adapter" },
+	{ "Compaq NC7781 Gigabit Server Adapter" },
+	{ 0 },
+	};
+
+static struct pci_device_id bcm5700_pci_tbl[] __devinitdata = {
+	{0x14e4, 0x1644, 0x1014, 0x0277, 0, 0, BCM5700VIGIL },
+	{0x14e4, 0x1644, 0x14e4, 0x1644, 0, 0, BCM5700A6 },
+	{0x14e4, 0x1644, 0x14e4, 0x2, 0, 0, BCM5700T6 },
+	{0x14e4, 0x1644, 0x14e4, 0x3, 0, 0, BCM5700A9 },
+	{0x14e4, 0x1644, 0x14e4, 0x4, 0, 0, BCM5700T9 },
+	{0x14e4, 0x1644, 0x1028, 0xd1, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x0106, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x0109, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x1028, 0x010a, 0, 0, BCM5700 },
+	{0x14e4, 0x1644, 0x10b7, 0x1000, 0, 0, TC996T },
+	{0x14e4, 0x1644, 0x10b7, 0x1001, 0, 0, TC996ST },
+	{0x14e4, 0x1644, 0x10b7, 0x1002, 0, 0, TC996SSX },
+	{0x14e4, 0x1644, 0x10b7, 0x1003, 0, 0, TC997T },
+	{0x14e4, 0x1644, 0x10b7, 0x1005, 0, 0, TC997SX },
+	{0x14e4, 0x1644, 0x10b7, 0x1008, 0, 0, TC942BR01 },
+	{0x14e4, 0x1644, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5700 },
+	{0x14e4, 0x1645, 0x14e4, 1, 0, 0, BCM5701A5 },
+	{0x14e4, 0x1645, 0x14e4, 5, 0, 0, BCM5701T1 },
+	{0x14e4, 0x1645, 0x14e4, 6, 0, 0, BCM5701T8 },
+	{0x14e4, 0x1645, 0x14e4, 7, 0, 0, BCM5701A7 },
+	{0x14e4, 0x1645, 0x14e4, 8, 0, 0, BCM5701A10 },
+	{0x14e4, 0x1645, 0x14e4, 0x8008, 0, 0, BCM5701A12 },
+	{0x14e4, 0x1645, 0x0e11, 0xc1, 0, 0, NC6770 },
+	{0x14e4, 0x1645, 0x0e11, 0x7c, 0, 0, NC7770 },
+	{0x14e4, 0x1645, 0x0e11, 0x85, 0, 0, NC7780 },
+	{0x14e4, 0x1645, 0x1028, 0x0121, 0, 0, BCM5701 },
+	{0x14e4, 0x1645, 0x10b7, 0x1004, 0, 0, TC996SX },
+	{0x14e4, 0x1645, 0x10b7, 0x1006, 0, 0, TC996BT },
+	{0x14e4, 0x1645, 0x10b7, 0x1007, 0, 0, TC1000T },
+	{0x14e4, 0x1645, 0x10b7, 0x1008, 0, 0, TC940BR01 },
+	{0x14e4, 0x1645, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5701 },
+	{0x14e4, 0x1646, 0x14e4, 0x8009, 0, 0, BCM5702 },
+	{0x14e4, 0x1646, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5702 },
+	{0x14e4, 0x16a6, 0x14e4, 0x8009, 0, 0, BCM5702 },
+	{0x14e4, 0x16a6, 0x14e4, 0x000c, 0, 0, BCM5702 },
+	{0x14e4, 0x16a6, 0x0e11, 0xbb, 0, 0, NC7760 },
+	{0x14e4, 0x16a6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5702 },
+	{0x14e4, 0x1647, 0x14e4, 0x0009, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, 0x14e4, 0x000a, 0, 0, BCM5703A31 },
+	{0x14e4, 0x1647, 0x14e4, 0x000b, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, 0x14e4, 0x800a, 0, 0, BCM5703 },
+	{0x14e4, 0x1647, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x14e4, 0x0009, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x14e4, 0x000a, 0, 0, BCM5703A31 },
+	{0x14e4, 0x16a7, 0x14e4, 0x000b, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x14e4, 0x800a, 0, 0, BCM5703 },
+	{0x14e4, 0x16a7, 0x0e11, 0xca, 0, 0, NC7771 },
+	{0x14e4, 0x16a7, 0x0e11, 0xcb, 0, 0, NC7781 },
+	{0x14e4, 0x16a7, PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5703 },
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, bcm5700_pci_tbl);
+
+#ifdef CONFIG_PROC_FS
+extern int bcm5700_proc_create(void);
+extern int bcm5700_proc_create_dev(struct net_device *dev);
+extern int bcm5700_proc_remove_dev(struct net_device *dev);
+#endif
+
+static int __devinit bcm5700_init_board(struct pci_dev *pdev,
+					struct net_device **dev_out,
+					int board_idx)
+{
+	struct net_device *dev;
+	PUM_DEVICE_BLOCK pUmDevice;
+	PLM_DEVICE_BLOCK pDevice;
+	int rc;
+
+	*dev_out = NULL;
+
+	/* dev zeroed in init_etherdev */
+	dev = init_etherdev(NULL, sizeof(*pUmDevice));
+	if (dev == NULL) {
+		printk (KERN_ERR "%s: unable to alloc new ethernet\n",
+			bcm5700_driver);
+		return -ENOMEM;
+	}
+	SET_MODULE_OWNER(dev);
+	pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+
+	/* enable device (incl. PCI PM wakeup), and bus-mastering */
+	rc = pci_enable_device (pdev);
+	if (rc)
+		goto err_out;
+
+	rc = pci_request_regions(pdev, bcm5700_driver);
+	if (rc)
+		goto err_out;
+
+	pci_set_master(pdev);
+
+	if (pci_set_dma_mask(pdev, ~(0UL)) != 0) {
+		printk(KERN_ERR "System does not support DMA\n");
+		pci_release_regions(pdev);
+		goto err_out;
+	}
+
+	pUmDevice->dev = dev;
+	pUmDevice->pdev = pdev;
+	pUmDevice->mem_list_num = 0;
+	pUmDevice->next_module = root_tigon3_dev;
+	pUmDevice->index = board_idx;
+	root_tigon3_dev = dev;
+
+	spin_lock_init(&pUmDevice->global_lock);
+
+	spin_lock_init(&pUmDevice->undi_lock);
+
+
+	pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	if (mtu[board_idx] > 1500) {
+		if (mtu[board_idx] > 9000) {
+			dev->mtu = 9000;
+			printk(KERN_WARNING "%s: Invalid mtu parameter (%d), using 9000\n", dev->name, mtu[board_idx]);
+		}
+		else
+			dev->mtu = mtu[board_idx];
+	}
+	else if (mtu[board_idx] < 1500) {
+		printk(KERN_WARNING "%s: Invalid mtu parameter (%d), using 1500\n", dev->name, mtu[board_idx]);
+	}
+
+	if (LM_GetAdapterInfo(pDevice) != LM_STATUS_SUCCESS) {
+		printk(KERN_ERR "Get Adapter info failed\n");
+		rc = -ENODEV;
+		goto err_out_unmap;
+	}
+
+	pUmDevice->do_global_lock = 0;
+	if (T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5700) {
+		/* The 5700 chip works best without interleaved register */
+		/* accesses on certain machines. */
+		pUmDevice->do_global_lock = 1;
+	}
+	if ((T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5701) &&
+		((pDevice->PciState & T3_PCI_STATE_NOT_PCI_X_BUS) == 0)) {
+
+		pUmDevice->rx_buf_align = 0;
+	}
+	else {
+		pUmDevice->rx_buf_align = 2;
+	}
+/*	dev->base_addr = pci_resource_start(pdev, 0);*/
+	dev->mem_start = pci_resource_start(pdev, 0);
+	dev->mem_end = dev->mem_start + pDevice->MemBaseSize;
+	dev->irq = pDevice->Irq = pdev->irq;
+
+	*dev_out = dev;
+	return 0;
+
+err_out_unmap:
+	pci_release_regions(pdev);
+	bcm5700_freemem(dev);
+
+err_out:
+	unregister_netdev(dev);
+	kfree (dev);
+	return rc;
+}
+
+static int __devinit
+bcm5700_print_ver(void)
+{
+	printk(KERN_INFO "Broadcom Gigabit Ethernet Driver %s ",
+		bcm5700_driver);
+#ifdef NICE_SUPPORT
+	printk("with Broadcom NIC Extension (NICE) ");
+#endif
+	printk("ver. %s %s\n", bcm5700_version, bcm5700_date);
+	return 0;
+}
+
+static int __devinit
+bcm5700_init_one(struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	struct net_device *dev = NULL;
+	PUM_DEVICE_BLOCK pUmDevice;
+	PLM_DEVICE_BLOCK pDevice;
+	int i;
+	static int board_idx = -1;
+	static int printed_version = 0;
+	struct pci_dev *amd_dev;
+
+	board_idx++;
+
+	if (!printed_version) {
+		bcm5700_print_ver();
+#ifdef CONFIG_PROC_FS
+		bcm5700_proc_create();
+#endif
+		printed_version = 1;
+	}
+
+	i = bcm5700_init_board(pdev, &dev, board_idx);
+	if (i < 0) {
+		return i;
+	}
+
+	if (dev == NULL)
+		return -ENOMEM;
+
+	dev->open = bcm5700_open;
+	dev->hard_start_xmit = bcm5700_start_xmit;
+	dev->stop = bcm5700_close;
+	dev->get_stats = bcm5700_get_stats;
+	dev->set_multicast_list = bcm5700_set_rx_mode;
+	dev->do_ioctl = bcm5700_ioctl;
+	dev->set_mac_address = &bcm5700_set_mac_addr;
+#if (LINUX_VERSION_CODE >= 0x20400)
+	dev->tx_timeout = bcm5700_tx_timeout;
+	dev->watchdog_timeo = TX_TIMEOUT;
+#endif
+
+	pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	dev->base_addr = pci_resource_start(pdev, 0);
+	dev->irq = pdev->irq;
+
+	pci_set_drvdata(pdev, dev);
+
+	memcpy(dev->dev_addr, pDevice->NodeAddress, 6);
+	pUmDevice->name = board_info[ent->driver_data].name,
+	printk(KERN_INFO "%s: %s found at mem %lx, IRQ %d, ",
+		dev->name, pUmDevice->name, dev->base_addr,
+		dev->irq);
+	printk("node addr ");
+	for (i = 0; i < 6; i++) {
+		printk("%2.2x", dev->dev_addr[i]);
+	}
+	printk("\n");
+
+	printk(KERN_INFO "%s: ", dev->name);
+	if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5400_PHY_ID)
+		printk("Broadcom BCM5400 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+		printk("Broadcom BCM5401 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5411_PHY_ID)
+		printk("Broadcom BCM5411 Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5701_PHY_ID)
+		printk("Broadcom BCM5701 Integrated Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5703_PHY_ID)
+		printk("Broadcom BCM5703 Integrated Copper ");
+	else if ((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM8002_PHY_ID)
+		printk("Broadcom BCM8002 SerDes ");
+	else if (pDevice->EnableTbi)
+		printk("Agilent HDMP-1636 SerDes ");
+	else
+		printk("Unknown ");
+	printk("transceiver found\n");
+
+	printk(KERN_INFO "%s: ", dev->name);
+#if (LINUX_VERSION_CODE >= 0x20400)
+	if (scatter_gather[board_idx]) {
+		dev->features |= NETIF_F_SG | NETIF_F_HIGHDMA;
+	}
+	if ((pDevice->ChipRevId != T3_CHIP_ID_5700_B0) &&
+		tx_checksum[board_idx]) {
+		dev->features |= NETIF_F_IP_CSUM;
+	}
+
+	printk("Scatter-gather %s, 64-bit DMA %s, Tx Checksum %s, ",
+		(char *) ((dev->features & NETIF_F_SG) ? "ON" : "OFF"),
+		(char *) ((dev->features & NETIF_F_HIGHDMA) ? "ON" : "OFF"),
+		(char *) ((dev->features & NETIF_F_IP_CSUM) ? "ON" : "OFF"));
+#endif
+	if ((pDevice->ChipRevId != T3_CHIP_ID_5700_B0) &&
+		rx_checksum[board_idx])
+		printk("Rx Checksum ON\n");
+	else
+		printk("Rx Checksum OFF\n");
+
+#ifdef CONFIG_PROC_FS
+	bcm5700_proc_create_dev(dev);
+#endif
+#ifdef TASKLET
+	tasklet_init(&pUmDevice->tasklet, bcm5700_tasklet,
+		(unsigned long) pUmDevice);
+#endif
+	if ((amd_dev = pci_find_device(0x1022, 0x700c, NULL))) {
+		u32 val;
+
+		/* Found AMD 762 North bridge */
+		pci_read_config_dword(amd_dev, 0x4c, &val);
+		if ((val & 0x02) == 0) {
+			pci_write_config_dword(amd_dev, 0x4c, val | 0x02);
+			printk(KERN_INFO "%s: Setting AMD762 Northbridge to enable PCI ordering compliance\n", bcm5700_driver);
+		}
+	}
+	return 0;
+
+}
+
+
+static void __devexit
+bcm5700_remove_one (struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata (pdev);
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+
+#ifdef CONFIG_PROC_FS
+	bcm5700_proc_remove_dev(dev); 
+#endif
+	unregister_netdev(dev);
+
+	if (pUmDevice->lm_dev.pMappedMemBase)
+		iounmap(pUmDevice->lm_dev.pMappedMemBase);
+
+	pci_release_regions(pdev);
+
+	kfree(dev);
+
+	pci_set_drvdata(pdev, NULL);
+
+/*	pci_power_off(pdev, -1);*/
+
+}
+
+int __devinit
+bcm5700_probe(struct net_device *dev)
+{
+	int cards_found = 0;
+	struct pci_dev *pdev = NULL;
+	struct pci_device_id *pci_tbl;
+	u16 ssvid, ssid;
+
+	if ( ! pci_present())
+		return -ENODEV;
+
+	pci_tbl = bcm5700_pci_tbl;
+	while ((pdev = pci_find_class(PCI_CLASS_NETWORK_ETHERNET << 8, pdev))) {
+		int idx;
+
+		pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &ssvid);
+		pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &ssid);
+		for (idx = 0; pci_tbl[idx].vendor; idx++) {
+			if ((pci_tbl[idx].vendor == PCI_ANY_ID ||
+				pci_tbl[idx].vendor == pdev->vendor) &&
+				(pci_tbl[idx].device == PCI_ANY_ID ||
+				pci_tbl[idx].device == pdev->device) &&
+				(pci_tbl[idx].subvendor == PCI_ANY_ID ||
+				pci_tbl[idx].subvendor == ssvid) &&
+				(pci_tbl[idx].subdevice == PCI_ANY_ID ||
+				pci_tbl[idx].subdevice == ssid))
+			{
+
+				break;
+			}
+		}
+		if (pci_tbl[idx].vendor == 0)
+			continue;
+
+
+		if (bcm5700_init_one(pdev, &pci_tbl[idx]) == 0)
+			cards_found++;
+	}
+
+	return cards_found ? 0 : -ENODEV;
+}
+
+
+
+STATIC int
+bcm5700_open(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	int index;
+
+	index = pUmDevice->index;
+	if (pDevice->ChipRevId == T3_CHIP_ID_5700_B0) {
+		pDevice->TaskToOffload = LM_TASK_OFFLOAD_NONE; 
+	}
+	else {
+		if (rx_checksum[index]) {
+			pDevice->TaskToOffload |=
+				LM_TASK_OFFLOAD_RX_TCP_CHECKSUM |
+				LM_TASK_OFFLOAD_RX_UDP_CHECKSUM;
+		}
+		if (tx_checksum[index]) {
+			pDevice->TaskToOffload |=
+				LM_TASK_OFFLOAD_TX_TCP_CHECKSUM |
+				LM_TASK_OFFLOAD_TX_UDP_CHECKSUM;
+			pDevice->NoTxPseudoHdrChksum = TRUE;
+		}
+	}
+	/* delay for 4 seconds */
+	pUmDevice->delayed_link_ind = (4 * HZ) / pUmDevice->timer_interval;
+
+	pUmDevice->adaptive_expiry = HZ / pUmDevice->timer_interval;
+
+#if INCLUDE_TBI_SUPPORT
+	if(pDevice->PollTbiLink)
+		pUmDevice->poll_tbi_expiry = HZ / pUmDevice->timer_interval;
+#endif
+
+	/* Sometimes we get spurious ints. after reset when link is down. */
+	/* This field tells the isr to service the int. even if there is */
+	/* no status block update. */
+	if (pDevice->LedMode != LED_MODE_LINK10) {
+		pUmDevice->adapter_just_inited = (3 * HZ) /
+			pUmDevice->timer_interval;
+	}
+	else {
+		pUmDevice->adapter_just_inited = 0;
+	}
+
+	if (request_irq(dev->irq, &bcm5700_interrupt, SA_SHIRQ, dev->name, dev)) {
+		return -EAGAIN;
+	}
+
+	pUmDevice->opened = 1;
+#if TIGON3_DEBUG
+	pUmDevice->tx_zc_count = 0;
+	pUmDevice->tx_chksum_count = 0;
+	pUmDevice->tx_himem_count = 0;
+	pUmDevice->rx_good_chksum_count = 0;
+	pUmDevice->rx_bad_chksum_count = 0;
+#endif
+	if (LM_InitializeAdapter(pDevice) != LM_STATUS_SUCCESS) {
+		free_irq(dev->irq, dev);
+		bcm5700_freemem(dev);
+		return -EAGAIN;
+	}
+
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+
+	if (tigon3_debug > 1)
+		printk(KERN_DEBUG "%s: tigon3_open() irq %d.\n", dev->name, dev->irq);
+
+	QQ_InitQueue(&pUmDevice->rx_out_of_buf_q.Container,
+        MAX_RX_PACKET_DESC_COUNT);
+	netif_start_queue(dev);
+
+#if (LINUX_VERSION_CODE < 0x020300)
+	MOD_INC_USE_COUNT;
+#endif
+
+	init_timer(&pUmDevice->timer);
+	pUmDevice->timer.expires = RUN_AT(pUmDevice->timer_interval);
+	pUmDevice->timer.data = (unsigned long)dev;
+	pUmDevice->timer.function = &bcm5700_timer;
+	add_timer(&pUmDevice->timer);
+
+	LM_EnableInterrupt(pDevice);
+
+	return 0;
+}
+
+STATIC void
+bcm5700_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	long flags;
+	LM_UINT32 value32;
+
+	if (!pUmDevice->opened)
+		return;
+
+#if INCLUDE_TBI_SUPPORT
+	if(pDevice->PollTbiLink && (--pUmDevice->poll_tbi_expiry == 0)) {
+		value32 = REG_RD(pDevice, MacCtrl.Status);
+		if (((pDevice->LinkStatus == LM_STATUS_LINK_ACTIVE) &&
+			((value32 & MAC_STATUS_LINK_STATE_CHANGED) ||
+			!(value32 & MAC_STATUS_PCS_SYNCED)))
+			||
+			((pDevice->LinkStatus != LM_STATUS_LINK_ACTIVE) &&
+			(value32 & MAC_STATUS_PCS_SYNCED)))
+		{
+			LM_SetupPhy(pDevice);
+		}
+		pUmDevice->poll_tbi_expiry = HZ / pUmDevice->timer_interval;
+		
+        }
+#endif
+
+	if (pUmDevice->delayed_link_ind > 0) {
+		if (pUmDevice->delayed_link_ind == 1)
+			MM_IndicateStatus(pDevice, pDevice->LinkStatus);
+		else
+			pUmDevice->delayed_link_ind--;
+	}
+	if (pUmDevice->adapter_just_inited > 0) {
+		pUmDevice->adapter_just_inited--;
+		if (pDevice->EnableTbi && !pUmDevice->adapter_just_inited &&
+			!pUmDevice->interrupt) {
+			LM_EnableInterrupt(pDevice);
+		}
+	}
+
+	if (pUmDevice->crc_counter_expiry > 0)
+		pUmDevice->crc_counter_expiry--;
+
+	if (!pUmDevice->interrupt) {
+		if (!pDevice->UseTaggedStatus) {
+			flags = bcm5700_lock(pUmDevice);
+			if (pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) {
+				/* This will generate an interrupt */
+				REG_WR(pDevice, Grc.LocalCtrl,
+					pDevice->GrcLocalCtrl |
+					GRC_MISC_LOCAL_CTRL_SET_INT);
+			}
+			else {
+				REG_WR(pDevice, HostCoalesce.Mode,
+					HOST_COALESCE_ENABLE |
+					HOST_COALESCE_NOW);
+			}
+			if (!(REG_RD(pDevice, DmaWrite.Mode) &
+				DMA_WRITE_MODE_ENABLE)) {
+				bcm5700_tx_timeout(dev);
+			}
+			bcm5700_unlock(pUmDevice, flags);
+			if (pUmDevice->tx_queued) {
+				pUmDevice->tx_queued = 0;
+				netif_wake_queue(dev);
+			}
+		}
+#if (LINUX_VERSION_CODE < 0x02032b)
+		if ((QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) !=
+			pDevice->TxPacketDescCnt) &&
+			((jiffies - dev->trans_start) > TX_TIMEOUT)) {
+
+			printk(KERN_WARNING "%s: Tx hung\n", dev->name);
+			bcm5700_tx_timeout(dev);
+		}
+#endif
+	}
+	if (pUmDevice->adaptive_coalesce) {
+		pUmDevice->adaptive_expiry--;
+		if (pUmDevice->adaptive_expiry == 0) {	
+			pUmDevice->adaptive_expiry = HZ /
+				pUmDevice->timer_interval;
+			bcm5700_adapt_coalesce(pUmDevice);
+		}
+	}
+	if (QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container) >=
+		pUmDevice->rx_buf_repl_panic_thresh) {
+		/* Generate interrupt and let isr allocate buffers */
+		REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+			GRC_MISC_LOCAL_CTRL_SET_INT);
+	}
+
+	pUmDevice->timer.expires = RUN_AT(pUmDevice->timer_interval);
+	add_timer(&pUmDevice->timer);
+	pUmDevice->spurious_int = 0;
+}
+
+STATIC int
+bcm5700_adapt_coalesce(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	uint rx_curr_cnt, tx_curr_cnt, rx_delta, tx_delta, total_delta;
+	int adapt = 0;
+	long flags;
+
+	rx_curr_cnt = pDevice->pStatsBlkVirt->ifHCInUcastPkts.Low;
+	tx_curr_cnt = pDevice->pStatsBlkVirt->COSIfHCOutPkts[0].Low;
+	if ((rx_curr_cnt <= pUmDevice->rx_last_cnt) ||
+		(tx_curr_cnt <= pUmDevice->tx_last_cnt)) {
+
+		/* skip if there is counter rollover */
+		pUmDevice->rx_last_cnt = rx_curr_cnt;
+		pUmDevice->tx_last_cnt = tx_curr_cnt;
+		return 0;
+	}
+
+	rx_delta = rx_curr_cnt - pUmDevice->rx_last_cnt;
+	tx_delta = tx_curr_cnt - pUmDevice->tx_last_cnt;
+	total_delta = rx_delta + tx_delta;
+
+	pUmDevice->rx_last_cnt = rx_curr_cnt;
+	pUmDevice->tx_last_cnt = tx_curr_cnt;
+
+	if (total_delta < rx_delta)
+		return 0;
+
+	if (total_delta < ADAPTIVE_LO_PKT_THRESH) {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+
+			adapt = 1;
+
+			pUmDevice->rx_curr_coalesce_frames =
+				ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				ADAPTIVE_LO_RX_COALESCING_TICKS;
+			pUmDevice->tx_curr_coalesce_frames =
+				ADAPTIVE_LO_TX_MAX_COALESCED_FRAMES;
+
+		}
+	}
+	else if (total_delta < ADAPTIVE_HI_PKT_THRESH) {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			DEFAULT_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+
+			adapt = 1;
+
+			pUmDevice->rx_curr_coalesce_frames = 
+				DEFAULT_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				DEFAULT_RX_COALESCING_TICKS;
+			pUmDevice->tx_curr_coalesce_frames = 
+				DEFAULT_TX_MAX_COALESCED_FRAMES;
+
+		}
+	}
+	else {
+		if (pUmDevice->rx_curr_coalesce_frames !=
+			ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES) {
+
+			if (!bcm5700_trylock(pUmDevice, &flags))
+				return 0;
+
+			adapt = 1;
+
+			pUmDevice->rx_curr_coalesce_frames = 
+				ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES;
+			pUmDevice->rx_curr_coalesce_ticks =
+				ADAPTIVE_HI_RX_COALESCING_TICKS;
+			pUmDevice->tx_curr_coalesce_frames = 
+				ADAPTIVE_HI_TX_MAX_COALESCED_FRAMES;
+
+		}
+	}
+	if (adapt) {
+    		REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+			pUmDevice->rx_curr_coalesce_frames); 
+
+		REG_WR(pDevice, HostCoalesce.RxCoalescingTicks,
+			pUmDevice->rx_curr_coalesce_ticks);
+
+		REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFrames,
+			pUmDevice->tx_curr_coalesce_frames); 
+		bcm5700_unlock(pUmDevice, flags);
+	}
+	return 0;
+}
+
+STATIC void
+bcm5700_tx_timeout(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	netif_stop_queue(dev);
+	LM_DisableInterrupt(pDevice);
+	LM_ResetAdapter(pDevice);	
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+	LM_EnableInterrupt(pDevice);
+	netif_wake_queue(dev);
+}
+
+
+STATIC int
+bcm5700_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	PLM_FRAG_LIST pfrag_list;
+	long flags;
+	unsigned int len;
+	dma_addr_t map;
+#if MAX_SKB_FRAGS
+	skb_frag_t *frag;
+	int i;
+	int frag_no;
+	dmaaddr_high_t hi_map;
+#endif
+#ifdef NICE_SUPPORT
+	vlan_tag_t *vlan_tag;
+#endif
+
+	if ((pDevice->LinkStatus == LM_STATUS_LINK_DOWN) || !pDevice->InitDone)
+	{
+		dev_kfree_skb(skb);
+		return 0;
+	}
+	
+#if (LINUX_VERSION_CODE < 0x02032b)
+	if (test_and_set_bit(0, &dev->tbusy)) {
+		return 1;
+	}
+#endif
+
+	if (pUmDevice->do_global_lock && pUmDevice->interrupt) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_queued = 1;
+		if (!pUmDevice->interrupt) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_queued = 0;
+		}
+		return 1;
+	}
+
+	pPacket = (PLM_PACKET)
+		QQ_PopHead(&pDevice->TxPacketFreeQ.Container);
+	if (pPacket == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+	pUmPacket = (PUM_PACKET) pPacket;
+	pUmPacket->skbuff = skb;
+	pfrag_list = &pUmPacket->frag_list;
+	pPacket->u.Tx.pFraglist = pfrag_list;
+	if (skb->ip_summed == CHECKSUM_HW) {
+		pPacket->Flags = SND_BD_FLAG_TCP_UDP_CKSUM;
+#if TIGON3_DEBUG
+		pUmDevice->tx_chksum_count++;
+#endif
+	}
+	else {
+		pPacket->Flags = 0;
+	}
+#if MAX_SKB_FRAGS
+	if ((frag_no = skb_shinfo(skb)->nr_frags))
+		len = skb->len - skb->data_len;
+	else
+		len = skb->len;
+	if (atomic_read(&pDevice->SendBdLeft) < (frag_no + 1)) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+		if (atomic_read(&pDevice->SendBdLeft) >= (frag_no + 1)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+#else
+	len = skb->len;
+	if (atomic_read(&pDevice->SendBdLeft) == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+		if (atomic_read(&pDevice->SendBdLeft)) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+		return 1;
+	}
+#endif
+
+	pfrag_list->Fragments[0].FragSize = len;
+	map = pci_map_single(pUmDevice->pdev, skb->data, len, PCI_DMA_TODEVICE);
+	bcm_set_addr(&pfrag_list->Fragments[0].FragBuf, map);
+	pci_unmap_addr_set(pUmPacket, map[0], map);
+	pci_unmap_len_set(pUmPacket, map_len[0], len);
+
+#if MAX_SKB_FRAGS
+	pPacket->u.Tx.FragCount = frag_no + 1;
+#if TIGON3_DEBUG
+	if (pPacket->u.Tx.FragCount > 1)
+		pUmDevice->tx_zc_count++;
+#endif
+	for (i = 1; i < pPacket->u.Tx.FragCount; i++) {
+		frag = &skb_shinfo(skb)->frags[i - 1];
+			
+		hi_map = pci_map_page(pUmDevice->pdev,
+				frag->page,
+				frag->page_offset,
+				frag->size, PCI_DMA_TODEVICE);
+
+		pci_unmap_addr_set(pUmPacket, map[i], hi_map);
+		pci_unmap_len_set(pUmPacket, map_len[i], frag->size);
+		bcm_set_addr_high(&pfrag_list->Fragments[i].FragBuf, hi_map);
+#if TIGON3_DEBUG
+		if (pfrag_list->Fragments[i].FragBuf.High)
+			pUmDevice->tx_himem_count++;
+#endif
+		pfrag_list->Fragments[i].FragSize = frag->size;
+	}
+#else
+	pPacket->u.Tx.FragCount = 1;
+#endif
+
+	/* Work around 4GB dma problem */
+	if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700) {
+		if (check_4G_boundary(pUmDevice, pUmPacket) == 0) {
+			QQ_PushHead(&pDevice->TxPacketFreeQ.Container, pPacket);
+#if (LINUX_VERSION_CODE < 0x02032b)
+			netif_wake_queue(dev);
+#endif
+			return 0;
+		}
+		skb = pUmPacket->skbuff;
+	}
+
+#ifdef NICE_SUPPORT
+	vlan_tag = (vlan_tag_t *) &skb->cb[0];
+	if (vlan_tag->signature == 0x5555) {
+		pPacket->VlanTag = vlan_tag->tag;
+		pPacket->Flags |= SND_BD_FLAG_VLAN_TAG;
+		vlan_tag->signature = 0;
+	}
+#endif
+	flags = bcm5700_lock(pUmDevice);
+	LM_SendPacket(pDevice, pPacket);
+	bcm5700_unlock(pUmDevice, flags);
+	if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) == 0) {
+		netif_stop_queue(dev);
+		pUmDevice->tx_full = 1;
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) != 0) {
+			netif_wake_queue(dev);
+			pUmDevice->tx_full = 0;
+		}
+	}
+#if (LINUX_VERSION_CODE < 0x02032b)
+	else {
+		netif_wake_queue(dev);
+	}
+#endif
+	dev->trans_start = jiffies;
+	return 0;
+}
+
+STATIC
+int
+check_4G_boundary(PUM_DEVICE_BLOCK pUmDevice, PUM_PACKET pUmPacket)
+{
+	u32 base;
+	int i;
+	PLM_FRAG_LIST pfrag_list = &pUmPacket->frag_list;
+	PLM_FRAG pfrag;
+	struct sk_buff *skb, *nskb;
+	dma_addr_t map;
+	int do_copy = 0;
+
+	/* Work around 4GB dma problem */
+	for (i = 0; i < pUmPacket->lm_packet.u.Tx.FragCount; i++) {
+		pfrag = &pfrag_list->Fragments[i];
+
+		if (((base = pfrag->FragBuf.Low) > 0xffffdcc0) &&
+			(pfrag->FragBuf.High == 0) &&
+			((base + 8 + pfrag->FragSize) < base)) {
+
+			do_copy = 1;
+			break;
+		}
+	}
+	if (do_copy) {
+		skb = pUmPacket->skbuff;
+#if ! defined(NO_PCI_UNMAP)
+		pci_unmap_single(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[0]),
+				pci_unmap_len(pUmPacket, map_len[0]),
+				PCI_DMA_TODEVICE);
+#if MAX_SKB_FRAGS
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			pci_unmap_page(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[i + 1]),
+				pci_unmap_len(pUmPacket, map_len[i + 1]),
+				PCI_DMA_TODEVICE);
+		}
+#endif
+#endif
+		if ((nskb = skb_copy(skb, GFP_ATOMIC))) {
+			pfrag_list->Fragments[0].FragSize = nskb->len;
+			map = pci_map_single(pUmDevice->pdev, nskb->data,
+				nskb->len, PCI_DMA_TODEVICE);
+			bcm_set_addr(&pfrag_list->Fragments[0].FragBuf, map);
+			pci_unmap_addr_set(pUmPacket, map[0], map);
+			pci_unmap_len_set(pUmPacket, map_len[0], nskb->len);
+			pUmPacket->lm_packet.u.Tx.FragCount = 1;
+		}
+		dev_kfree_skb(skb);
+		pUmPacket->skbuff = nskb;
+		if (nskb == 0) {
+			return 0;
+		}
+	}
+	return 1;
+}
+
+STATIC void
+bcm5700_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *)dev_instance;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	LM_UINT32 oldtag, newtag;
+	int repl_buf_count, i;
+
+	if (!pDevice->InitDone)
+		return;
+
+	bcm5700_intr_lock(pUmDevice);
+	if (test_and_set_bit(0, (void*)&pUmDevice->interrupt)) {
+		printk(KERN_ERR "%s: Duplicate entry of the interrupt handler by "
+			   "processor %d.\n",
+			   dev->name, hard_smp_processor_id());
+		bcm5700_intr_unlock(pUmDevice);
+		return;
+	}
+
+	if (pDevice->UseTaggedStatus) {
+		if ((pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) ||
+			pUmDevice->adapter_just_inited) {
+			RAW_REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+			oldtag = pDevice->pStatusBlkVirt->StatusTag;
+
+			for (i = 0; ; i++) {
+   				pDevice->pStatusBlkVirt->Status &=
+					~STATUS_BLOCK_UPDATED;
+
+				LM_ServiceInterrupts(pDevice);
+				newtag = pDevice->pStatusBlkVirt->StatusTag;
+				if ((newtag == oldtag) || (i > 50)) {
+					RAW_REG_WR(pDevice,
+						Mailbox.Interrupt[0].Low,
+						newtag << 24);
+					break;
+				}
+				oldtag = newtag;
+			}
+		}
+	}
+	else if ((pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED) ||
+			pUmDevice->adapter_just_inited) {
+		do {
+			uint dummy;
+
+			RAW_REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+   			pDevice->pStatusBlkVirt->Status &= ~STATUS_BLOCK_UPDATED;
+			LM_ServiceInterrupts(pDevice);
+			RAW_REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+			dummy = REG_RD(pDevice, Mailbox.Interrupt[0].Low);
+		}
+		while (pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED);
+	}
+	if (pUmDevice->adapter_just_inited && pDevice->EnableTbi) {
+		if (pDevice->LinkStatus != LM_STATUS_LINK_ACTIVE) {
+			pUmDevice->spurious_int++;
+			if (pUmDevice->spurious_int > 25) {
+				LM_DisableInterrupt(pDevice);
+    				REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+					MAC_MODE_LINK_POLARITY);
+				MM_Wait(1);
+				pUmDevice->spurious_int = 0;
+    				REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+				if (pUmDevice->adapter_just_inited == 0)
+					LM_EnableInterrupt(pDevice);
+			}
+		}
+	}
+#ifdef TASKLET
+	repl_buf_count = QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container);
+	if (repl_buf_count >= pUmDevice->rx_buf_repl_thresh) {
+		if ((repl_buf_count >= pUmDevice->rx_buf_repl_panic_thresh) &&
+			(!test_and_set_bit(0, &pUmDevice->tasklet_busy))) {
+			replenish_rx_buffers(pUmDevice);
+			clear_bit(0, (void*)&pUmDevice->tasklet_busy);
+		}
+		else if (!pUmDevice->tasklet_pending) {
+			pUmDevice->tasklet_pending = 1;
+			tasklet_schedule(&pUmDevice->tasklet);
+		}
+	}
+#else
+	if (QQ_GetEntryCnt(&pUmDevice->rx_out_of_buf_q.Container)) {
+		replenish_rx_buffers(pUmDevice);
+	}
+
+	if (QQ_GetEntryCnt(&pDevice->RxPacketFreeQ.Container)) {
+		LM_QueueRxPackets(pDevice);
+	}
+#endif
+
+	clear_bit(0, (void*)&pUmDevice->interrupt);
+	bcm5700_intr_unlock(pUmDevice);
+	if (pUmDevice->tx_queued) {
+		pUmDevice->tx_queued = 0;
+		netif_wake_queue(dev);
+	}
+	return;
+}
+
+
+STATIC void
+bcm5700_tasklet(unsigned long data)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)data;
+
+	/* RH 7.2 Beta 3 tasklets are reentrant */
+	if (test_and_set_bit(0, &pUmDevice->tasklet_busy)) {
+		pUmDevice->tasklet_pending = 0;
+		return;
+	}
+
+	pUmDevice->tasklet_pending = 0;
+	replenish_rx_buffers(pUmDevice);
+	clear_bit(0, &pUmDevice->tasklet_busy);
+}
+
+STATIC int
+bcm5700_close(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+	dev->start = 0;
+#endif
+	netif_stop_queue(dev);
+	pUmDevice->opened = 0;
+
+	if (tigon3_debug > 1)
+		printk(KERN_DEBUG "%s: Shutting down Tigon3\n",
+			   dev->name);
+
+	LM_DisableInterrupt(pDevice);
+#ifdef TASKLET
+//	tasklet_disable(&pUmDevice->tasklet);
+	tasklet_kill(&pUmDevice->tasklet);
+#endif
+	LM_Halt(pDevice);
+	pDevice->InitDone = 0;
+	del_timer(&pUmDevice->timer);
+
+	free_irq(dev->irq, dev);
+#if (LINUX_VERSION_CODE < 0x020300)
+	MOD_DEC_USE_COUNT;
+#endif
+	LM_SetPowerState(pDevice, LM_POWER_STATE_D3);
+	bcm5700_freemem(dev);
+
+	return 0;
+}
+
+STATIC int
+bcm5700_freemem(struct net_device *dev)
+{
+	int i;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+
+	for (i = 0; i < pUmDevice->mem_list_num; i++) {
+		if (pUmDevice->mem_size_list[i] == 0) {
+			kfree(pUmDevice->mem_list[i]);
+		}
+		else {
+			pci_free_consistent(pUmDevice->pdev,
+				(size_t) pUmDevice->mem_size_list[i],
+				pUmDevice->mem_list[i],
+				pUmDevice->dma_list[i]);
+		}
+	}
+	pUmDevice->mem_list_num = 0;
+	return 0;
+}
+
+LM_UINT32
+bcm5700_crc_count(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_DEVICE_BLOCK pDevice = &pUmDevice->lm_dev;
+	LM_UINT32 Value32;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	unsigned long flags;
+
+#if INCLUDE_TBI_SUPPORT
+	if(pDevice->EnableTbi)
+		return (pStats->dot3StatsFCSErrors.Low);
+#endif
+	if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+		T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701) {
+
+		if (!pUmDevice->opened || pUmDevice->adapter_just_inited)
+			return 0;
+
+		/* regulate MDIO access during run time */
+		if (pUmDevice->crc_counter_expiry > 0)
+			return pDevice->PhyCrcCount;
+
+		pUmDevice->crc_counter_expiry = (5 * HZ) /
+			pUmDevice->timer_interval;
+
+		flags = bcm5700_lock(pUmDevice);
+		LM_ReadPhy(pDevice, 0x1e, &Value32);
+		if ((Value32 & 0x8000) == 0)
+			LM_WritePhy(pDevice, 0x1e, Value32 | 0x8000);
+		LM_ReadPhy(pDevice, 0x14, &Value32);
+		bcm5700_unlock(pUmDevice, flags);
+		/* Sometimes data on the MDIO bus can be corrupted */
+		if (Value32 != 0xffff)
+			pDevice->PhyCrcCount += Value32;
+		return pDevice->PhyCrcCount;
+	}
+	else if (pStats == 0) {
+		return 0;
+	}
+	else {
+		return (pStats->dot3StatsFCSErrors.Low);
+	}
+}
+
+STATIC struct net_device_stats *
+bcm5700_get_stats(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	PT3_STATS_BLOCK pStats = (PT3_STATS_BLOCK) pDevice->pStatsBlkVirt;
+	struct net_device_stats *p_netstats = &pUmDevice->stats;
+
+	if (pStats == 0)
+		return p_netstats;
+
+	/* Get stats from LM */
+	p_netstats->rx_packets = pStats->ifHCInUcastPkts.Low +
+			pStats->ifHCInMulticastPkts.Low +
+			pStats->ifHCInBroadcastPkts.Low;
+	p_netstats->tx_packets = pStats->COSIfHCOutPkts[0].Low;
+	p_netstats->rx_bytes = pStats->ifHCInOctets.Low;
+	p_netstats->tx_bytes = pStats->ifHCOutOctets.Low;
+	p_netstats->tx_errors = pStats->dot3StatsInternalMacTransmitErrors.Low +
+			pStats->dot3StatsCarrierSenseErrors.Low +
+			pStats->ifOutDiscards.Low +
+			pStats->ifOutErrors.Low;
+	p_netstats->multicast = pStats->ifHCInMulticastPkts.Low;
+	p_netstats->collisions = pStats->etherStatsCollisions.Low;
+	p_netstats->rx_length_errors = pStats->dot3StatsFramesTooLong.Low +
+			pStats->etherStatsUndersizePkts.Low;
+	p_netstats->rx_over_errors = pStats->nicNoMoreRxBDs.Low;
+	p_netstats->rx_frame_errors = pStats->dot3StatsAlignmentErrors.Low;
+	p_netstats->rx_crc_errors = bcm5700_crc_count(pUmDevice);
+	p_netstats->rx_errors = p_netstats->rx_length_errors +
+				p_netstats->rx_over_errors +
+				p_netstats->rx_frame_errors +
+				p_netstats->rx_crc_errors +
+				pStats->etherStatsFragments.Low +
+				pStats->etherStatsJabbers.Low;
+	
+	p_netstats->tx_aborted_errors = pStats->ifOutDiscards.Low;
+	p_netstats->tx_carrier_errors = pStats->dot3StatsCarrierSenseErrors.Low;
+
+	return p_netstats;
+}
+
+#ifdef SIOCETHTOOL
+static int netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_cmd ethcmd;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+		
+	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
+		return -EFAULT;
+
+        switch (ethcmd.cmd) {
+#ifdef ETHTOOL_GDRVINFO
+        case ETHTOOL_GDRVINFO: {
+		struct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};
+
+		strcpy(info.driver,  bcm5700_driver);
+#if INCLUDE_5701_AX_FIX
+		if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0) {
+			extern int t3FwReleaseMajor;
+			extern int t3FwReleaseMinor;
+			extern int t3FwReleaseFix;
+
+			sprintf(info.fw_version, "%i.%i.%i",
+				t3FwReleaseMajor, t3FwReleaseMinor, 
+				t3FwReleaseFix);
+		}
+#endif
+		strcpy(info.version, bcm5700_version);
+		strcpy(info.bus_info, pUmDevice->pdev->slot_name);
+		if (copy_to_user(useraddr, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+#endif
+        case ETHTOOL_GSET: {
+		if (pDevice->EnableTbi) {
+			ethcmd.supported =
+				(SUPPORTED_1000baseT_Full |
+				SUPPORTED_Autoneg);
+			ethcmd.supported |= SUPPORTED_FIBRE;
+			ethcmd.port = PORT_FIBRE;
+		}
+		else {
+			ethcmd.supported =
+				(SUPPORTED_10baseT_Half |
+				SUPPORTED_10baseT_Full |
+				SUPPORTED_100baseT_Half |
+				SUPPORTED_100baseT_Full |
+				SUPPORTED_1000baseT_Half |
+				SUPPORTED_1000baseT_Full |
+				SUPPORTED_Autoneg);
+			ethcmd.supported |= SUPPORTED_TP;
+			ethcmd.port = PORT_TP;
+		}
+
+		ethcmd.transceiver = XCVR_INTERNAL;
+		ethcmd.phy_address = 0;
+
+		if (pUmDevice->line_speed == 1000)
+			ethcmd.speed = SPEED_1000;
+		else if (pUmDevice->line_speed == 100)
+			ethcmd.speed = SPEED_100;
+		else if (pUmDevice->line_speed == 10)
+			ethcmd.speed = SPEED_10;
+		else
+			ethcmd.speed = 0;
+
+		if (pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+			ethcmd.duplex = DUPLEX_FULL;
+		else
+			ethcmd.duplex = DUPLEX_HALF;
+
+		if (pDevice->DisableAutoNeg == FALSE) {
+			ethcmd.autoneg = AUTONEG_ENABLE;
+			ethcmd.advertising = ADVERTISED_Autoneg;
+			if (pDevice->EnableTbi) {
+				ethcmd.advertising |=
+					ADVERTISED_1000baseT_Full |
+					ADVERTISED_FIBRE;
+			}
+			else {
+				ethcmd.advertising |=
+					ADVERTISED_TP;
+				if (pDevice->advertising &
+					PHY_AN_AD_10BASET_HALF) {
+
+					ethcmd.advertising |=
+						ADVERTISED_10baseT_Half;
+				}
+				if (pDevice->advertising &
+					PHY_AN_AD_10BASET_FULL) {
+
+					ethcmd.advertising |=
+						ADVERTISED_10baseT_Full;
+				}
+				if (pDevice->advertising &
+					PHY_AN_AD_100BASETX_HALF) {
+
+					ethcmd.advertising |=
+						ADVERTISED_100baseT_Half;
+				}
+				if (pDevice->advertising &
+					PHY_AN_AD_100BASETX_FULL) {
+
+					ethcmd.advertising |=
+						ADVERTISED_100baseT_Full;
+				}
+				if (pDevice->advertising1000 &
+					BCM540X_AN_AD_1000BASET_HALF) {
+
+					ethcmd.advertising |=
+						ADVERTISED_1000baseT_Half;
+				}
+				if (pDevice->advertising1000 &
+					BCM540X_AN_AD_1000BASET_FULL) {
+
+					ethcmd.advertising |=
+						ADVERTISED_1000baseT_Full;
+				}
+			}
+		}
+		else {
+			ethcmd.autoneg = AUTONEG_DISABLE;
+			ethcmd.advertising = 0;
+		}
+
+		ethcmd.maxtxpkt = pDevice->TxMaxCoalescedFrames;
+		ethcmd.maxrxpkt = pDevice->RxMaxCoalescedFrames;
+
+		if(copy_to_user(useraddr, &ethcmd, sizeof(ethcmd)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SSET: {
+		if(!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if (ethcmd.autoneg == AUTONEG_ENABLE) {
+			if (pDevice->EnableTbi) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_AUTO;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_AUTO;
+			}
+			pDevice->DisableAutoNeg = FALSE;
+		}
+		else if (ethcmd.speed == SPEED_1000) {
+			if (!pDevice->EnableTbi)
+				return -EINVAL;
+			pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX;
+			pDevice->DisableAutoNeg = TRUE;
+		}
+		else if (ethcmd.speed == SPEED_100) {
+			if (ethcmd.duplex == DUPLEX_FULL) {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS;
+			}
+			pDevice->DisableAutoNeg = TRUE;
+		}
+		else if (ethcmd.speed == SPEED_10) {
+			if (ethcmd.duplex == DUPLEX_FULL) {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+			}
+			pDevice->DisableAutoNeg = TRUE;
+		}
+		else {
+			return -EINVAL;
+		}
+		LM_SetupPhy(pDevice);
+		return 0;
+	}
+#ifdef ETHTOOL_GWOL
+	case ETHTOOL_GWOL: {
+		struct ethtool_wolinfo wol = {ETHTOOL_GWOL};
+
+		if (pDevice->EnableTbi) {
+			wol.supported = 0;
+			wol.wolopts = 0;
+		}
+		else {
+			wol.supported = WAKE_MAGIC;
+			if (pDevice->WakeUpMode == LM_WAKE_UP_MODE_MAGIC_PACKET)
+			{
+				wol.wolopts = WAKE_MAGIC;
+			}
+			else {
+				wol.wolopts = 0;
+			}
+		}
+		if (copy_to_user(useraddr, &wol, sizeof(wol)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SWOL: {
+		struct ethtool_wolinfo wol;
+
+		if(!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if (copy_from_user(&wol, useraddr, sizeof(wol)))
+			return -EFAULT;
+		if (pDevice->EnableTbi && wol.wolopts)
+			return -EINVAL;
+		
+		if ((wol.wolopts & ~WAKE_MAGIC) != 0) {
+			return -EINVAL;
+		}
+		if (wol.wolopts & WAKE_MAGIC) {
+			pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_MAGIC_PACKET;
+			pDevice->WakeUpMode = LM_WAKE_UP_MODE_MAGIC_PACKET;
+		}
+		else {
+			pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_NONE;
+			pDevice->WakeUpMode = LM_WAKE_UP_MODE_NONE;
+		}
+		return 0;
+        }
+#endif
+#ifdef ETHTOOL_GLINK
+	case ETHTOOL_GLINK: {
+		struct ethtool_value edata = {ETHTOOL_GLINK};
+
+		if (pDevice->LinkStatus == LM_STATUS_LINK_ACTIVE)
+			edata.data =  1;
+		else
+			edata.data =  0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+#endif
+#ifdef ETHTOOL_NWAY_RST
+	case ETHTOOL_NWAY_RST: {
+		LM_UINT32 phyctrl;
+
+		if (pDevice->DisableAutoNeg) {
+			return -EINVAL;
+		}
+		if (pDevice->EnableTbi) {
+			LM_SetupPhy(pDevice);
+		}
+		else {
+			LM_ReadPhy(pDevice, PHY_CTRL_REG, &phyctrl);
+			LM_WritePhy(pDevice, PHY_CTRL_REG, phyctrl |
+				PHY_CTRL_AUTO_NEG_ENABLE |
+				PHY_CTRL_RESTART_AUTO_NEG);
+		}
+		return 0;
+	}
+#endif
+	}
+	
+	return -EOPNOTSUPP;
+}
+#endif
+
+/* Provide ioctl() calls to examine the MII xcvr state. */
+STATIC int bcm5700_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	u16 *data = (u16 *)&rq->ifr_data;
+	u32 value;
+	unsigned long flags;
+
+	switch(cmd) {
+	case SIOCDEVPRIVATE:		/* Get the address of the PHY in use. */
+		data[0] = pDevice->PhyAddr;
+	case SIOCDEVPRIVATE+1:		/* Read the specified MII register. */
+		flags = bcm5700_lock(pUmDevice);
+		LM_ReadPhy(pDevice, data[1] & 0x1f, (LM_UINT32 *) &value);
+		bcm5700_unlock(pUmDevice, flags);
+		data[3] = value & 0xffff;
+		return 0;
+	case SIOCDEVPRIVATE+2:		/* Write the specified MII register */
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		flags = bcm5700_lock(pUmDevice);
+		LM_WritePhy(pDevice, data[1] & 0x1f, data[2]);
+		bcm5700_unlock(pUmDevice, flags);
+		return 0;
+#ifdef NICE_SUPPORT
+	case SIOCNICE:
+		{
+			struct nice_req* nrq;
+
+			if (!capable(CAP_NET_ADMIN))
+				return -EPERM;
+
+			nrq = (struct nice_req*)&rq->ifr_ifru;
+			if( nrq->cmd == NICE_CMD_QUERY_SUPPORT ) {
+				nrq->nrq_magic = NICE_DEVICE_MAGIC;
+				nrq->nrq_support_rx = 1;
+				nrq->nrq_support_vlan = 1;
+				nrq->nrq_support_get_speed = 1;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_SET_RX ) {
+				pUmDevice->nice_rx = nrq->nrq_rx;
+				pUmDevice->nice_ctx = nrq->nrq_ctx;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_GET_RX ) {
+				nrq->nrq_rx = pUmDevice->nice_rx;
+				nrq->nrq_ctx = pUmDevice->nice_ctx;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_GET_SPEED ) {
+				nrq->nrq_speed = pUmDevice->line_speed;
+				return 0;
+			}
+			else if( nrq->cmd == NICE_CMD_BLINK_LED ) {
+				return LM_BlinkLED(pDevice, nrq->nrq_blink_time);
+			}
+			break;
+		}
+#endif /* NICE_SUPPORT */
+#ifdef SIOCETHTOOL
+	case SIOCETHTOOL:
+		return netdev_ethtool_ioctl(dev, (void *) rq->ifr_data);
+#endif
+	default:
+		return -EOPNOTSUPP;
+	}
+	return -EOPNOTSUPP;
+}
+
+STATIC void bcm5700_set_rx_mode(struct net_device *dev)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK)dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	int i;
+	struct dev_mc_list *mclist;
+
+	LM_MulticastClear(pDevice);
+	for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+			 i++, mclist = mclist->next) {
+		LM_MulticastAdd(pDevice, (PLM_UINT8) &mclist->dmi_addr);
+	}
+	if (dev->flags & IFF_ALLMULTI) {
+		if (!(pDevice->ReceiveMask & LM_ACCEPT_ALL_MULTICAST)) {
+			LM_SetReceiveMask(pDevice,
+				pDevice->ReceiveMask | LM_ACCEPT_ALL_MULTICAST);
+		}
+	}
+	else if (pDevice->ReceiveMask & LM_ACCEPT_ALL_MULTICAST) {
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask & ~LM_ACCEPT_ALL_MULTICAST);
+	}
+	if (dev->flags & IFF_PROMISC) {
+		if (!(pDevice->RxMode & RX_MODE_PROMISCUOUS_MODE)) {
+			LM_SetReceiveMask(pDevice,
+				pDevice->ReceiveMask | LM_PROMISCUOUS_MODE);
+		}
+	}
+	else if (pDevice->RxMode & RX_MODE_PROMISCUOUS_MODE) {
+		LM_SetReceiveMask(pDevice,
+			pDevice->ReceiveMask & ~LM_PROMISCUOUS_MODE);
+	}
+}
+
+/*
+ * Set the hardware MAC address.
+ */
+STATIC int bcm5700_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr=p;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) dev->priv;
+
+	if (netif_running(dev))
+		return -EBUSY;
+	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
+	LM_SetMacAddress(pDevice, dev->dev_addr);
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE < 0x020300)
+#ifdef MODULE
+int init_module(void)
+{
+	return bcm5700_probe(NULL);
+}
+
+void cleanup_module(void)
+{
+	struct net_device *next_dev;
+	PUM_DEVICE_BLOCK pUmDevice;
+
+	/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
+	while (root_tigon3_dev) {
+		pUmDevice = (PUM_DEVICE_BLOCK)root_tigon3_dev->priv;
+#ifdef CONFIG_PROC_FS
+		bcm5700_proc_remove_dev(root_tigon3_dev); 
+#endif
+		next_dev = pUmDevice->next_module;
+		unregister_netdev(root_tigon3_dev);
+		if (pUmDevice->lm_dev.pMappedMemBase)
+			iounmap(pUmDevice->lm_dev.pMappedMemBase);
+		kfree(root_tigon3_dev);
+		root_tigon3_dev = next_dev;
+	}
+}
+
+#endif  /* MODULE */
+#else	/* LINUX_VERSION_CODE < 0x020300 */
+
+#if (LINUX_VERSION_CODE >= 0x020406)
+static int bcm5700_suspend (struct pci_dev *pdev, u32 state)
+#else
+static void bcm5700_suspend (struct pci_dev *pdev)
+#endif
+{
+	struct net_device *dev = (struct net_device *) pci_get_drvdata(pdev);
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) dev->priv;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+
+	if (!netif_running(dev))
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#else
+		return;
+#endif
+
+	LM_DisableInterrupt(pDevice);
+	netif_device_detach (dev);
+
+	/* Disable interrupts, stop Tx and Rx. */
+	LM_Halt(pDevice);
+	LM_SetPowerState(pDevice, LM_POWER_STATE_D3);
+
+/*	pci_power_off(pdev, -1);*/
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE >= 0x020406)
+static int bcm5700_resume(struct pci_dev *pdev)
+#else
+static void bcm5700_resume(struct pci_dev *pdev)
+#endif
+{
+	struct net_device *dev = (struct net_device *) pci_get_drvdata(pdev);
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) dev->priv;
+
+	if (!netif_running(dev))
+#if (LINUX_VERSION_CODE >= 0x020406)
+		return 0;
+#else
+		return;
+#endif
+/*	pci_power_on(pdev);*/
+	netif_device_attach(dev);
+	LM_InitializeAdapter(pDevice);
+	if (memcmp(dev->dev_addr, pDevice->NodeAddress, 6)) {
+		LM_SetMacAddress(pDevice, dev->dev_addr);
+	}
+	LM_EnableInterrupt(pDevice);
+#if (LINUX_VERSION_CODE >= 0x020406)
+	return 0;
+#endif
+}
+
+
+static struct pci_driver bcm5700_pci_driver = {
+	name:		bcm5700_driver,
+	id_table:	bcm5700_pci_tbl,
+	probe:		bcm5700_init_one,
+	remove:		bcm5700_remove_one,
+	suspend:	bcm5700_suspend,
+	resume:		bcm5700_resume,
+};
+
+
+static int __init bcm5700_init_module (void)
+{
+	return pci_module_init(&bcm5700_pci_driver);
+}
+
+
+static void __exit bcm5700_cleanup_module (void)
+{
+	pci_unregister_driver(&bcm5700_pci_driver);
+}
+
+
+module_init(bcm5700_init_module);
+module_exit(bcm5700_cleanup_module);
+#endif
+
+/*
+ * Middle Module
+ *
+ */
+
+
+LM_STATUS
+MM_ReadConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT16 *pValue16)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_read_config_word(pUmDevice->pdev, Offset, (u16 *) pValue16);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_ReadConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT32 *pValue32)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_read_config_dword(pUmDevice->pdev, Offset, (u32 *) pValue32);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_WriteConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT16 Value16)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_write_config_word(pUmDevice->pdev, Offset, Value16);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_WriteConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+	LM_UINT32 Value32)
+{
+	UM_DEVICE_BLOCK *pUmDevice;
+
+	pUmDevice = (UM_DEVICE_BLOCK *) pDevice;
+	pci_write_config_dword(pUmDevice->pdev, Offset, Value32);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_AllocateSharedMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+	PLM_VOID *pMemoryBlockVirt, PLM_PHYSICAL_ADDRESS pMemoryBlockPhy,
+	LM_BOOL Cached)
+{
+	PLM_VOID pvirt;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	dma_addr_t mapping;
+
+	pvirt = pci_alloc_consistent(pUmDevice->pdev, BlockSize,
+					       &mapping);
+	if (!pvirt) {
+		return LM_STATUS_FAILURE;
+	}
+	pUmDevice->mem_list[pUmDevice->mem_list_num] = pvirt;
+	pUmDevice->dma_list[pUmDevice->mem_list_num] = mapping;
+	pUmDevice->mem_size_list[pUmDevice->mem_list_num++] = BlockSize;
+	memset(pvirt, 0, BlockSize);
+	*pMemoryBlockVirt = (PLM_VOID) pvirt;
+	bcm_set_addr(pMemoryBlockPhy, mapping);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_AllocateMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+	PLM_VOID *pMemoryBlockVirt)
+{
+	PLM_VOID pvirt;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+
+
+	/* Maximum in slab.c */
+	if (BlockSize > 131072) {
+		goto MM_Alloc_error;
+	}
+
+	pvirt = kmalloc(BlockSize, GFP_KERNEL);
+	if (!pvirt) {
+		goto MM_Alloc_error;
+	}
+	pUmDevice->mem_list[pUmDevice->mem_list_num] = pvirt;
+	pUmDevice->dma_list[pUmDevice->mem_list_num] = 0;
+	pUmDevice->mem_size_list[pUmDevice->mem_list_num++] = 0;
+	/* mem_size_list[i] == 0 indicates that the memory should be freed */
+	/* using kfree */
+	memset(pvirt, 0, BlockSize);
+	*pMemoryBlockVirt = pvirt;
+	return LM_STATUS_SUCCESS;
+
+MM_Alloc_error:
+	printk(KERN_WARNING "%s: Memory allocation failed - buffer parameters may be set too high\n", pUmDevice->dev->name);
+	return LM_STATUS_FAILURE;
+}
+
+LM_STATUS
+MM_MapMemBase(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+
+	pDevice->pMappedMemBase = ioremap_nocache(
+		pci_resource_start(pUmDevice->pdev, 0), pDevice->MemBaseSize);
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_InitializeUmPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	int i;
+	struct sk_buff *skb;
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PUM_PACKET pUmPacket;
+	PLM_PACKET pPacket;
+	dma_addr_t map;
+
+	for (i = 0; i < pDevice->RxPacketDescCnt; i++) {
+		pPacket = QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+		pUmPacket = (PUM_PACKET) pPacket;
+		if (pPacket == 0) {
+			printk(KERN_DEBUG "Bad RxPacketFreeQ\n");
+		}
+		skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2);
+		if (skb == 0) {
+			pUmPacket->skbuff = 0;
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+			continue;
+		}
+		pUmPacket->skbuff = skb;
+		skb->dev = pUmDevice->dev;
+		skb_reserve(skb, pUmDevice->rx_buf_align);
+		map = pci_map_single(pUmDevice->pdev, skb->tail,
+			pPacket->u.Rx.RxBufferSize, PCI_DMA_FROMDEVICE);
+		pci_unmap_addr_set(pUmPacket, map[0], map);
+		bcm_set_addr(&pPacket->u.Rx.RxBufferPhy, map);
+		QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+	}
+	if (T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5700) {
+		/* reallocate buffers in the ISR */
+		pUmDevice->rx_buf_repl_thresh = 0;
+		pUmDevice->rx_buf_repl_panic_thresh = 0;
+	}
+	else if (T3_ASIC_REV(pUmDevice->lm_dev.ChipRevId) == T3_ASIC_REV_5703) {
+		pUmDevice->rx_buf_repl_thresh = pDevice->RxPacketDescCnt / 10;
+		pUmDevice->rx_buf_repl_panic_thresh =
+			pDevice->RxPacketDescCnt / 3;
+	}
+	else {
+		pUmDevice->rx_buf_repl_thresh = pDevice->RxPacketDescCnt / 8;
+		pUmDevice->rx_buf_repl_panic_thresh =
+			pDevice->RxPacketDescCnt / 2;
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_GetConfig(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	int index = pUmDevice->index;
+
+	if (auto_speed[index] == 0)
+		pDevice->DisableAutoNeg = TRUE;
+	else
+		pDevice->DisableAutoNeg = FALSE;
+
+	if (line_speed[index] == 0) {
+		pDevice->RequestedMediaType =
+				LM_REQUESTED_MEDIA_TYPE_AUTO;
+		pDevice->DisableAutoNeg = FALSE;
+	}
+	else {
+		if (line_speed[index] == 1000) {
+			if (pDevice->EnableTbi) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX;
+			}
+			else if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS;
+			}
+			if (!pDevice->EnableTbi)
+				pDevice->DisableAutoNeg = FALSE;
+		}
+		else if (line_speed[index] == 100) {
+			if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS;
+			}
+		}
+		else if (line_speed[index] == 10) {
+			if (full_duplex[index]) {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX;
+			}
+			else {
+				pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+			}
+		}
+		else {
+			pDevice->RequestedMediaType =
+					LM_REQUESTED_MEDIA_TYPE_AUTO;
+			pDevice->DisableAutoNeg = FALSE;
+			printk(KERN_WARNING "%s: Invalid line_speed parameter (%d), using 0\n", pUmDevice->dev->name, line_speed[index]);
+		}
+
+	}
+	pDevice->FlowControlCap = 0;
+	if (rx_flow_control[index] != 0) {
+		pDevice->FlowControlCap |= LM_FLOW_CONTROL_RECEIVE_PAUSE;
+	}
+	if (tx_flow_control[index] != 0) {
+		pDevice->FlowControlCap |= LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+	}
+	if (auto_flow_control[index] != 0) {
+		if (pDevice->DisableAutoNeg == FALSE) {
+
+			pDevice->FlowControlCap |= LM_FLOW_CONTROL_AUTO_PAUSE;
+			if ((tx_flow_control[index] == 0) &&
+				(rx_flow_control[index] == 0)) {
+
+				pDevice->FlowControlCap |=
+					LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+					LM_FLOW_CONTROL_RECEIVE_PAUSE;
+			}
+		}
+		else {
+			printk(KERN_WARNING "%s: Conflicting auto_flow_control parameter (%d), using 0\n",
+				pUmDevice->dev->name, auto_flow_control[index]);
+		}
+
+	}
+
+	if (pUmDevice->dev->mtu > 1500) {
+		pDevice->RxMtu = pUmDevice->dev->mtu + 14;
+	}
+
+	if (T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700) {
+		pDevice->UseTaggedStatus = TRUE;
+		pUmDevice->timer_interval = HZ;
+	}
+	else {
+		pUmDevice->timer_interval = HZ/10;
+	}
+
+	if ((tx_pkt_desc_cnt[index] == 0) ||
+		(tx_pkt_desc_cnt[index] > MAX_TX_PACKET_DESC_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid tx_pkt_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, tx_pkt_desc_cnt[index],
+			DEFAULT_TX_PACKET_DESC_COUNT);
+
+		tx_pkt_desc_cnt[index] = DEFAULT_TX_PACKET_DESC_COUNT;
+	}
+	pDevice->TxPacketDescCnt = tx_pkt_desc_cnt[index];
+	if ((rx_std_desc_cnt[index] == 0) ||
+		(rx_std_desc_cnt[index] >= T3_STD_RCV_RCB_ENTRY_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid rx_std_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, rx_std_desc_cnt[index],
+			DEFAULT_RX_PACKET_DESC_COUNT);
+
+		rx_std_desc_cnt[index] = DEFAULT_RX_PACKET_DESC_COUNT;
+	}
+	pDevice->RxStdDescCnt = rx_std_desc_cnt[index];
+
+	if (mtu[index] <= 1514) {
+		rx_jumbo_desc_cnt[index] = 0;
+	}
+	else if ((rx_jumbo_desc_cnt[index] == 0) ||
+		(rx_jumbo_desc_cnt[index] >= T3_JUMBO_RCV_RCB_ENTRY_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid rx_jumbo_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, rx_jumbo_desc_cnt[index],
+			DEFAULT_JUMBO_RCV_DESC_COUNT);
+
+		rx_jumbo_desc_cnt[index] = DEFAULT_JUMBO_RCV_DESC_COUNT;
+	}
+	pDevice->RxJumboDescCnt = rx_jumbo_desc_cnt[index];
+
+#if INCLUDE_EXT_MEMORY_SUPPORT
+	if ((rx_mini_desc_cnt[index] == 0) ||
+		(rx_mini_desc_cnt[index] >= T3_MINI_RCV_RCB_ENTRY_COUNT)) {
+
+		printk(KERN_WARNING "%s: Invalid rx_mini_desc_cnt parameter (%d), using %d\n",
+			pUmDevice->dev->name, rx_mini_desc_cnt[index],
+			DEFAULT_MINI_RCV_DESC_COUNT);
+
+		rx_mini_desc_cnt[index] = DEFAULT_MINI_RCV_DESC_COUNT;
+	}
+	pDevice->RxMiniDescCnt = rx_mini_desc_cnt[index];
+#endif
+
+	pUmDevice->adaptive_coalesce = adaptive_coalesce[index];
+	if (!pUmDevice->adaptive_coalesce) {
+		if (rx_coalesce_ticks[index] > MAX_RX_COALESCING_TICKS) {
+
+			printk(KERN_WARNING "%s: Invalid rx_coalesce_ticks parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				rx_coalesce_ticks[index],
+				MAX_RX_COALESCING_TICKS);
+
+			rx_coalesce_ticks[index] = MAX_RX_COALESCING_TICKS;
+		}
+		else if ((rx_coalesce_ticks[index] == 0) &&
+			(rx_max_coalesce_frames[index] == 0)) {
+
+			printk(KERN_WARNING "%s: Conflicting rx_coalesce_ticks (0) and rx_max_coalesce_frames (0) parameters, using %d and %d respectively\n",
+				pUmDevice->dev->name,
+				DEFAULT_RX_COALESCING_TICKS,
+				DEFAULT_RX_MAX_COALESCED_FRAMES);
+
+			rx_coalesce_ticks[index] = DEFAULT_RX_COALESCING_TICKS;
+			rx_max_coalesce_frames[index] =
+				DEFAULT_RX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->RxCoalescingTicks = rx_coalesce_ticks[index];
+		pUmDevice->rx_curr_coalesce_ticks = pDevice->RxCoalescingTicks;
+
+		if (rx_max_coalesce_frames[index] > MAX_RX_MAX_COALESCED_FRAMES)
+		{
+			printk(KERN_WARNING "%s: Invalid rx_max_coalesce_frames parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				rx_max_coalesce_frames[index],
+				MAX_RX_MAX_COALESCED_FRAMES);
+
+			rx_max_coalesce_frames[index] =
+				MAX_RX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->RxMaxCoalescedFrames = rx_max_coalesce_frames[index];
+		pUmDevice->rx_curr_coalesce_frames =
+			pDevice->RxMaxCoalescedFrames;
+
+		if (tx_coalesce_ticks[index] > MAX_TX_COALESCING_TICKS) {
+			printk(KERN_WARNING "%s: Invalid tx_coalesce_ticks parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				tx_coalesce_ticks[index],
+				MAX_TX_COALESCING_TICKS);
+
+			tx_coalesce_ticks[index] = MAX_TX_COALESCING_TICKS;
+		}
+		else if ((tx_coalesce_ticks[index] == 0) &&
+			(tx_max_coalesce_frames[index] == 0)) {
+
+			printk(KERN_WARNING "%s: Conflicting tx_coalesce_ticks (0) and tx_max_coalesce_frames (0) parameters, using %d and %d respectively\n",
+				pUmDevice->dev->name,
+				DEFAULT_TX_COALESCING_TICKS,
+				DEFAULT_TX_MAX_COALESCED_FRAMES);
+
+			tx_coalesce_ticks[index] = DEFAULT_TX_COALESCING_TICKS;
+			tx_max_coalesce_frames[index] =
+				DEFAULT_TX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->TxCoalescingTicks = tx_coalesce_ticks[index];
+		if (tx_max_coalesce_frames[index] > MAX_TX_MAX_COALESCED_FRAMES) {
+			printk(KERN_WARNING "%s: Invalid tx_max_coalesce_frames parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				tx_max_coalesce_frames[index],
+				MAX_TX_MAX_COALESCED_FRAMES);
+
+			tx_max_coalesce_frames[index] = MAX_TX_MAX_COALESCED_FRAMES;
+		}
+		pDevice->TxMaxCoalescedFrames = tx_max_coalesce_frames[index];
+		pUmDevice->tx_curr_coalesce_frames =
+			pDevice->TxMaxCoalescedFrames;
+
+		if (stats_coalesce_ticks[index] > MAX_STATS_COALESCING_TICKS) {
+			printk(KERN_WARNING "%s: Invalid stats_coalesce_ticks parameter (%d), using %d\n",
+				pUmDevice->dev->name,
+				stats_coalesce_ticks[index],
+				MAX_STATS_COALESCING_TICKS);
+
+			stats_coalesce_ticks[index] =
+				MAX_STATS_COALESCING_TICKS;
+		}
+		pDevice->StatsCoalescingTicks = stats_coalesce_ticks[index];
+	}
+	else {
+		pUmDevice->rx_curr_coalesce_frames =
+			DEFAULT_RX_MAX_COALESCED_FRAMES;
+		pUmDevice->rx_curr_coalesce_ticks =
+			DEFAULT_RX_COALESCING_TICKS;
+		pUmDevice->tx_curr_coalesce_frames =
+			DEFAULT_TX_MAX_COALESCED_FRAMES;
+	}
+
+	if (enable_wol[index]) {
+		pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_MAGIC_PACKET;
+		pDevice->WakeUpMode = LM_WAKE_UP_MODE_MAGIC_PACKET;
+	}
+	if (pDevice->EnablePciXFix)
+		pDevice->NicSendBd = FALSE;
+	else
+		pDevice->NicSendBd = TRUE;
+#if INCLUDE_TBI_SUPPORT
+	pDevice->PollTbiLink = TRUE;
+#endif
+#if INCLUDE_EXT_MEMORY_SUPPORT
+	pDevice->EnableExtMemory = TRUE;
+#endif
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_StartTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_CompleteTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_IndicateRxPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+	int size;
+
+	while (1) {
+		pPacket = (PLM_PACKET)
+			QQ_PopHead(&pDevice->RxPacketReceivedQ.Container);
+		if (pPacket == 0)
+			break;
+		pUmPacket = (PUM_PACKET) pPacket;
+#if ! defined(NO_PCI_UNMAP)
+		pci_unmap_single(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[0]),
+				pPacket->u.Rx.RxBufferSize,
+				PCI_DMA_FROMDEVICE);
+#endif
+		if ((pPacket->PacketStatus != LM_STATUS_SUCCESS) ||
+			((size = pPacket->PacketSize) > pDevice->RxMtu)) {
+
+			/* reuse skb */
+#ifdef TASKLET
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+#else
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+#endif
+			pUmDevice->rx_misc_errors++;
+			continue;
+		}
+		skb = pUmPacket->skbuff;
+		skb_put(skb, size);
+		skb->pkt_type = 0;
+		skb->protocol = eth_type_trans(skb, skb->dev);
+		if ((pPacket->Flags & RCV_BD_FLAG_TCP_UDP_CHKSUM_FIELD) &&
+			(pDevice->TaskToOffload &
+				LM_TASK_OFFLOAD_RX_TCP_CHECKSUM)) {
+			if (pPacket->u.Rx.TcpUdpChecksum == 0xffff) {
+
+				skb->ip_summed = CHECKSUM_UNNECESSARY;
+#if TIGON3_DEBUG
+				pUmDevice->rx_good_chksum_count++;
+#endif
+			}
+			else {
+				skb->ip_summed = CHECKSUM_NONE;
+				pUmDevice->rx_bad_chksum_count++;
+			}
+		}
+		else {
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+#ifdef NICE_SUPPORT
+		if( pUmDevice->nice_rx ) {
+			vlan_tag_t *vlan_tag;
+
+			vlan_tag = (vlan_tag_t *) &skb->cb[0];
+			if (pPacket->Flags & RCV_BD_FLAG_VLAN_TAG) {
+				vlan_tag->signature = 0x7777;
+				vlan_tag->tag = pPacket->VlanTag;
+			}
+			else {
+				vlan_tag->signature = 0;
+			}
+			pUmDevice->nice_rx(skb, pUmDevice->nice_ctx);
+		}
+		else {
+			netif_rx(skb);
+		}
+#else
+		netif_rx(skb);
+#endif
+
+#ifdef TASKLET
+		pUmPacket->skbuff = 0;
+		QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+#else
+		skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2);
+		if (skb == 0) {
+			pUmPacket->skbuff = 0;
+			QQ_PushTail(&pUmDevice->rx_out_of_buf_q.Container, pPacket);
+		}
+		else {
+			pUmPacket->skbuff = skb;
+			skb->dev = pUmDevice->dev;
+			skb_reserve(skb, pUmDevice->rx_buf_align);
+			map = pci_map_single(pUmDevice->pdev, skb->tail,
+				pPacket->u.Rx.RxBufferSize, PCI_DMA_FROMDEVICE);
+			pci_unmap_addr_set(pUmPacket, map[0], map);
+			bcm_set_addr(&pPacket->u.Rx.RxBufferPhy, map);
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+		}
+#endif
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+/* Returns 1 if not all buffers are allocated */
+STATIC int
+replenish_rx_buffers(PUM_DEVICE_BLOCK pUmDevice)
+{
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	PLM_DEVICE_BLOCK pDevice = (PLM_DEVICE_BLOCK) pUmDevice;
+	struct sk_buff *skb;
+	int queue_rx = 0;
+	int ret = 0;
+	dma_addr_t map;
+
+	while ((pUmPacket = (PUM_PACKET)
+		QQ_PopHead(&pUmDevice->rx_out_of_buf_q.Container)) != 0) {
+		pPacket = (PLM_PACKET) pUmPacket;
+		if (pUmPacket->skbuff) {
+			/* reuse an old skb */
+			QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+			queue_rx = 1;
+			continue;
+		}
+		if ((skb = dev_alloc_skb(pPacket->u.Rx.RxBufferSize + 2)) == 0) {
+			QQ_PushHead(&pUmDevice->rx_out_of_buf_q.Container,
+				pPacket);
+			ret = 1;
+			break;
+		}
+		pUmPacket->skbuff = skb;
+		skb->dev = pUmDevice->dev;
+		skb_reserve(skb, pUmDevice->rx_buf_align);
+		map = pci_map_single(pUmDevice->pdev, skb->tail,
+			pPacket->u.Rx.RxBufferSize, PCI_DMA_FROMDEVICE);
+		pci_unmap_addr_set(pUmPacket, map[0], map);
+		bcm_set_addr(&pPacket->u.Rx.RxBufferPhy, map);
+		QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+		queue_rx = 1;
+	}
+	if (queue_rx) {
+		LM_QueueRxPackets(pDevice);
+	}
+	return ret;
+}
+
+LM_STATUS
+MM_IndicateTxPackets(PLM_DEVICE_BLOCK pDevice)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	PLM_PACKET pPacket;
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+#if ! defined(NO_PCI_UNMAP) && MAX_SKB_FRAGS
+	int i;
+#endif
+
+	while (1) {
+		pPacket = (PLM_PACKET)
+			QQ_PopHead(&pDevice->TxPacketXmittedQ.Container);
+		if (pPacket == 0)
+			break;
+		pUmPacket = (PUM_PACKET) pPacket;
+		skb = pUmPacket->skbuff;
+#if ! defined(NO_PCI_UNMAP)
+		pci_unmap_single(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[0]),
+				pci_unmap_len(pUmPacket, map_len[0]),
+				PCI_DMA_TODEVICE);
+#if MAX_SKB_FRAGS
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			pci_unmap_page(pUmDevice->pdev,
+				pci_unmap_addr(pUmPacket, map[i + 1]),
+				pci_unmap_len(pUmPacket, map_len[i + 1]),
+				PCI_DMA_TODEVICE);
+		}
+#endif
+#endif
+		dev_kfree_skb_irq(skb);
+		pUmPacket->skbuff = 0;
+		QQ_PushTail(&pDevice->TxPacketFreeQ.Container, pPacket);
+	}
+	if (pUmDevice->tx_full) {
+		if (QQ_GetEntryCnt(&pDevice->TxPacketFreeQ.Container) >=
+			(pDevice->TxPacketDescCnt >> 1)) {
+
+			pUmDevice->tx_full = 0;
+			netif_wake_queue(pUmDevice->dev);
+		}
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_IndicateStatus(PLM_DEVICE_BLOCK pDevice, LM_STATUS Status)
+{
+	PUM_DEVICE_BLOCK pUmDevice = (PUM_DEVICE_BLOCK) pDevice;
+	struct net_device *dev = pUmDevice->dev;
+	LM_FLOW_CONTROL flow_control;
+
+	if (!pUmDevice->opened)
+		return LM_STATUS_SUCCESS;
+
+	if (pUmDevice->delayed_link_ind > 0) {
+		pUmDevice->delayed_link_ind = 0;
+		if (Status == LM_STATUS_LINK_DOWN) {
+			printk(KERN_ERR "%s: %s NIC Link is DOWN\n", bcm5700_driver, dev->name);
+		}
+		else if (Status == LM_STATUS_LINK_ACTIVE) {
+			printk(KERN_INFO "%s: %s NIC Link is UP, ", bcm5700_driver, dev->name);
+		}
+	}
+	else {
+		if (Status == LM_STATUS_LINK_DOWN) {
+			pUmDevice->line_speed = 0;
+			printk(KERN_ERR "%s: %s NIC Link is Down\n", bcm5700_driver, dev->name);
+		}
+		else if (Status == LM_STATUS_LINK_ACTIVE) {
+			printk(KERN_INFO "%s: %s NIC Link is Up, ", bcm5700_driver, dev->name);
+		}
+	}
+
+	if (Status == LM_STATUS_LINK_ACTIVE) {
+		if (pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS)
+			pUmDevice->line_speed = 1000;
+		else if (pDevice->LineSpeed == LM_LINE_SPEED_100MBPS)
+			pUmDevice->line_speed = 100;
+		else if (pDevice->LineSpeed == LM_LINE_SPEED_10MBPS)
+			pUmDevice->line_speed = 10;
+
+		printk("%d Mbps ", pUmDevice->line_speed);
+
+		if (pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+			printk("full duplex");
+		else
+			printk("half duplex");
+
+		flow_control = pDevice->FlowControl &
+			(LM_FLOW_CONTROL_RECEIVE_PAUSE |
+			LM_FLOW_CONTROL_TRANSMIT_PAUSE);
+		if (flow_control) {
+			if (flow_control & LM_FLOW_CONTROL_RECEIVE_PAUSE) {
+				printk(", receive ");
+				if (flow_control & LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+					printk("& transmit ");
+			}
+			else {
+				printk(", transmit ");
+			}
+			printk("flow control ON");
+		}
+		printk("\n");
+	}
+	return LM_STATUS_SUCCESS;
+}
+
+LM_STATUS
+MM_FreeRxBuffer(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+	PUM_PACKET pUmPacket;
+	struct sk_buff *skb;
+
+	if (pPacket == 0)
+		return LM_STATUS_SUCCESS;
+	pUmPacket = (PUM_PACKET) pPacket;
+	if ((skb = pUmPacket->skbuff))
+		dev_kfree_skb(skb);
+	pUmPacket->skbuff = 0;
+	return LM_STATUS_SUCCESS;
+}
+
+
Binary files ../ia64/linux/drivers/net/bcm/bcm5700.4.gz and linux/drivers/net/bcm/bcm5700.4.gz differ
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/bits.h linux/drivers/net/bcm/bits.h
--- ../ia64/linux/drivers/net/bcm/bits.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/bits.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,62 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef BITS_H
+#define BITS_H
+
+
+
+/******************************************************************************/
+/* Bit Mask definitions */
+/******************************************************************************/
+
+#define BIT_NONE            0x00
+#define BIT_0               0x01
+#define BIT_1               0x02
+#define BIT_2               0x04
+#define BIT_3               0x08
+#define BIT_4               0x10
+#define BIT_5               0x20
+#define BIT_6               0x40
+#define BIT_7               0x80
+#define BIT_8               0x0100
+#define BIT_9               0x0200
+#define BIT_10              0x0400
+#define BIT_11              0x0800
+#define BIT_12              0x1000
+#define BIT_13              0x2000
+#define BIT_14              0x4000
+#define BIT_15              0x8000
+#define BIT_16              0x010000
+#define BIT_17              0x020000
+#define BIT_18              0x040000
+#define BIT_19              0x080000
+#define BIT_20              0x100000
+#define BIT_21              0x200000
+#define BIT_22              0x400000
+#define BIT_23              0x800000
+#define BIT_24              0x01000000
+#define BIT_25              0x02000000
+#define BIT_26              0x04000000
+#define BIT_27              0x08000000
+#define BIT_28              0x10000000
+#define BIT_29              0x20000000
+#define BIT_30              0x40000000
+#define BIT_31              0x80000000
+
+
+
+#endif /* BITS_H */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/debug.h linux/drivers/net/bcm/debug.h
--- ../ia64/linux/drivers/net/bcm/debug.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/debug.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,108 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef DEBUG_H 
+#define DEBUG_H 
+
+
+
+/******************************************************************************/
+/* Debug macros                                                               */
+/******************************************************************************/
+
+/* Code path for controlling output debug messages. */
+/* Define your code path here. */
+#define CP_INIT                     0x010000
+#define CP_SEND                     0x020000
+#define CP_RCV                      0x040000
+#define CP_INT                      0x080000
+#define CP_UINIT                    0x100000
+#define CP_RESET                    0x200000
+
+#define CP_ALL                      (CP_INIT | CP_SEND | CP_RCV | CP_INT | \
+                                    CP_RESET | CP_UINIT)
+
+#define CP_MASK                     0xffff0000
+
+
+/* Debug message levels. */
+#define LV_VERBOSE                  0x03
+#define LV_INFORM                   0x02
+#define LV_WARN                     0x01
+#define LV_FATAL                    0x00
+
+#define LV_MASK                     0xffff
+
+
+/* Code path and messsage level combined.  These are the first argument of */
+/* the DbgMessage macro. */
+#define INIT_V                      (CP_INIT | LV_VERBOSE)
+#define INIT_I                      (CP_INIT | LV_INFORM)
+#define INIT_W                      (CP_INIT | LV_WARN)
+#define SEND_V                      (CP_SEND | LV_VERBOSE)
+#define SEND_I                      (CP_SEND | LV_INFORM)
+#define SEND_W                      (CP_SEND | LV_WARN)
+#define RCV_V                       (CP_RCV | LV_VERBOSE)
+#define RCV_I                       (CP_RCV | LV_INFORM)
+#define RCV_W                       (CP_RCV | LV_WARN)
+#define INT_V                       (CP_INT | LV_VERBOSE)
+#define INT_I                       (CP_INT | LV_INFORM)
+#define INT_W                       (CP_INT | LV_WARN)
+#define UINIT_V                     (CP_UINIT | LV_VERBOSE)
+#define UINIT_I                     (CP_UINIT | LV_INFORM)
+#define UINIT_W                     (CP_UINIT | LV_WARN)
+#define RESET_V                     (CP_RESET | LV_VERBOSE)
+#define RESET_I                     (CP_RESET | LV_INFORM)
+#define RESET_W                     (CP_RESET | LV_WARN)
+#define CPALL_V                     (CP_ALL | LV_VERBOSE)
+#define CPALL_I                     (CP_ALL | LV_INFORM)
+#define CPALL_W                     (CP_ALL | LV_WARN)
+
+
+/* All code path message levels. */
+#define FATAL                       (CP_ALL | LV_FATAL)
+#define WARN                        (CP_ALL | LV_WARN)
+#define INFORM                      (CP_ALL | LV_INFORM)
+#define VERBOSE                     (CP_ALL | LV_VERBOSE)
+
+
+/* These constants control the message output. */
+/* Set your debug message output level and code path here. */
+#ifndef DBG_MSG_CP
+#define DBG_MSG_CP                  CP_ALL      /* Where to output messages. */
+#endif
+
+#ifndef DBG_MSG_LV
+#define DBG_MSG_LV                  LV_VERBOSE  /* Level of message output. */
+#endif
+
+
+/* DbgMessage macro. */
+#if DBG
+#define DbgMessage(CNTRL, MESSAGE)  \
+    if((CNTRL & DBG_MSG_CP) && ((CNTRL & LV_MASK) <= DBG_MSG_LV)) \
+        DbgPrint MESSAGE
+#define DbgBreak()                 DbgBreakPoint() 
+#define STATIC
+#else
+#define DbgMessage(CNTRL, MESSAGE)
+#define DbgBreak()
+#define STATIC static
+#endif /* DBG */
+
+
+
+#endif /* DEBUG_H */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/lm.h linux/drivers/net/bcm/lm.h
--- ../ia64/linux/drivers/net/bcm/lm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/lm.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,478 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef LM_H
+#define LM_H
+
+#include "debug.h"
+#include "queue.h"
+#include "bits.h"
+#include "lmcfg.h"
+
+
+
+/******************************************************************************/
+/* Basic types. */
+/******************************************************************************/
+
+typedef char           LM_CHAR,    *PLM_CHAR;
+typedef unsigned int   LM_UINT,    *PLM_UINT;
+typedef unsigned char  LM_UINT8,   *PLM_UINT8;
+typedef unsigned short LM_UINT16,  *PLM_UINT16;
+typedef unsigned int   LM_UINT32,  *PLM_UINT32;
+typedef unsigned int   LM_COUNTER, *PLM_COUNTER;
+typedef void           LM_VOID,    *PLM_VOID;
+typedef char           LM_BOOL,    *PLM_BOOL;
+
+/* 64bit value. */
+typedef struct {
+#ifdef BIG_ENDIAN_HOST
+    LM_UINT32 High;
+    LM_UINT32 Low;
+#else /* BIG_ENDIAN_HOST */
+    LM_UINT32 Low;
+    LM_UINT32 High;
+#endif /* !BIG_ENDIAN_HOST */
+} LM_UINT64, *PLM_UINT64;
+
+typedef LM_UINT64 LM_PHYSICAL_ADDRESS, *PLM_PHYSICAL_ADDRESS;
+
+/* void LM_INC_PHYSICAL_ADDRESS(PLM_PHYSICAL_ADDRESS pAddr,LM_UINT32 IncSize) */
+#define LM_INC_PHYSICAL_ADDRESS(pAddr, IncSize)             \
+    {                                                       \
+        LM_UINT32 OrgLow;                                   \
+                                                            \
+        OrgLow = (pAddr)->Low;                              \
+        (pAddr)->Low += IncSize;                            \
+        if((pAddr)->Low < OrgLow) {                         \
+            (pAddr)->High++; /* Wrap around. */             \
+        }                                                   \
+    }
+    
+
+#ifndef TRUE
+#define TRUE           1
+#endif /* TRUE */
+
+#ifndef FALSE
+#define FALSE          0
+#endif /* FALSE */
+
+#ifndef NULL
+#define NULL                ((void *) 0)
+#endif /* NULL */
+
+#ifndef OFFSETOF
+#define OFFSETOF(_s, _m)    (MM_UINT_PTR(&(((_s *) 0)->_m)))
+#endif /* OFFSETOF */
+
+
+
+/******************************************************************************/
+/* Simple macros. */
+/******************************************************************************/
+
+#define IS_ETH_BROADCAST(_pEthAddr)                                         \
+    (((unsigned char *) (_pEthAddr))[0] == ((unsigned char) 0xff))
+
+#define IS_ETH_MULTICAST(_pEthAddr)                                         \
+    (((unsigned char *) (_pEthAddr))[0] & ((unsigned char) 0x01))
+
+#define IS_ETH_ADDRESS_EQUAL(_pEtherAddr1, _pEtherAddr2)                    \
+    ((((unsigned char *) (_pEtherAddr1))[0] ==                              \
+    ((unsigned char *) (_pEtherAddr2))[0]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[1] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[1]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[2] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[2]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[3] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[3]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[4] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[4]) &&                               \
+    (((unsigned char *) (_pEtherAddr1))[5] ==                               \
+    ((unsigned char *) (_pEtherAddr2))[5]))
+
+#define COPY_ETH_ADDRESS(_Src, _Dst)                                        \
+    ((unsigned char *) (_Dst))[0] = ((unsigned char *) (_Src))[0];          \
+    ((unsigned char *) (_Dst))[1] = ((unsigned char *) (_Src))[1];          \
+    ((unsigned char *) (_Dst))[2] = ((unsigned char *) (_Src))[2];          \
+    ((unsigned char *) (_Dst))[3] = ((unsigned char *) (_Src))[3];          \
+    ((unsigned char *) (_Dst))[4] = ((unsigned char *) (_Src))[4];          \
+    ((unsigned char *) (_Dst))[5] = ((unsigned char *) (_Src))[5];
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+#define ETHERNET_ADDRESS_SIZE           6
+#define ETHERNET_PACKET_HEADER_SIZE     14
+#define MIN_ETHERNET_PACKET_SIZE        64      /* with 4 byte crc. */
+#define MAX_ETHERNET_PACKET_SIZE        1518    /* with 4 byte crc. */
+#define MIN_ETHERNET_PACKET_SIZE_NO_CRC 60
+#define MAX_ETHERNET_PACKET_SIZE_NO_CRC 1514
+#define MAX_ETHERNET_PACKET_BUFFER_SIZE 1536    /* A nice even number. */
+
+#ifndef LM_MAX_MC_TABLE_SIZE
+#define LM_MAX_MC_TABLE_SIZE            32
+#endif /* LM_MAX_MC_TABLE_SIZE */
+#define LM_MC_ENTRY_SIZE                (ETHERNET_ADDRESS_SIZE+1)
+#define LM_MC_INSTANCE_COUNT_INDEX      (LM_MC_ENTRY_SIZE-1)
+
+
+/* Receive filter masks. */
+#define LM_ACCEPT_UNICAST               0x0001
+#define LM_ACCEPT_MULTICAST             0x0002
+#define LM_ACCEPT_ALL_MULTICAST         0x0004
+#define LM_ACCEPT_BROADCAST             0x0008
+#define LM_ACCEPT_ERROR_PACKET          0x0010
+
+#define LM_PROMISCUOUS_MODE             0x10000
+
+
+
+/******************************************************************************/
+/* PCI registers. */
+/******************************************************************************/
+
+#define PCI_VENDOR_ID_REG               0x00
+#define PCI_DEVICE_ID_REG               0x02
+
+#define PCI_COMMAND_REG                 0x04
+#define PCI_IO_SPACE_ENABLE             0x0001
+#define PCI_MEM_SPACE_ENABLE            0x0002
+#define PCI_BUSMASTER_ENABLE            0x0004
+#define PCI_MEMORY_WRITE_INVALIDATE     0x0010
+#define PCI_PARITY_ERROR_ENABLE         0x0040
+#define PCI_SYSTEM_ERROR_ENABLE         0x0100
+#define PCI_FAST_BACK_TO_BACK_ENABLE    0x0200
+
+#define PCI_STATUS_REG                  0x06
+#define PCI_REV_ID_REG                  0x08
+
+#define PCI_CACHE_LINE_SIZE_REG         0x0c
+
+#define PCI_IO_BASE_ADDR_REG            0x10
+#define PCI_IO_BASE_ADDR_MASK           0xfffffff0
+
+#define PCI_MEM_BASE_ADDR_LOW           0x10
+#define PCI_MEM_BASE_ADDR_HIGH          0x14
+
+#define PCI_SUBSYSTEM_VENDOR_ID_REG     0x2c
+#define PCI_SUBSYSTEM_ID_REG            0x2e
+#define PCI_INT_LINE_REG                0x3c
+
+#define PCIX_CAP_REG                    0x40
+#define PCIX_ENABLE_RELAXED_ORDERING    BIT_17
+
+/******************************************************************************/
+/* Fragment structure. */
+/******************************************************************************/
+
+typedef struct {
+    LM_UINT32 FragSize;
+    LM_PHYSICAL_ADDRESS FragBuf;
+} LM_FRAG, *PLM_FRAG;
+
+typedef struct {
+    /* FragCount is initialized for the caller to the maximum array size, on */
+    /* return FragCount is the number of the actual fragments in the array. */
+    LM_UINT32 FragCount;
+
+    /* Total buffer size. */
+    LM_UINT32 TotalSize;
+
+    /* Fragment array buffer. */
+    LM_FRAG Fragments[1];
+} LM_FRAG_LIST, *PLM_FRAG_LIST;
+
+#define DECLARE_FRAG_LIST_BUFFER_TYPE(_FRAG_LIST_TYPE_NAME, _MAX_FRAG_COUNT) \
+    typedef struct {                                                         \
+        LM_FRAG_LIST FragList;                                               \
+        LM_FRAG FragListBuffer[_MAX_FRAG_COUNT-1];                           \
+    } _FRAG_LIST_TYPE_NAME, *P##_FRAG_LIST_TYPE_NAME
+
+
+
+/******************************************************************************/
+/* Status codes. */
+/******************************************************************************/
+
+#define LM_STATUS_SUCCESS                                       0
+#define LM_STATUS_FAILURE                                       1
+
+#define LM_STATUS_INTERRUPT_ACTIVE                              2
+#define LM_STATUS_INTERRUPT_NOT_ACTIVE                          3
+
+#define LM_STATUS_LINK_ACTIVE                                   4
+#define LM_STATUS_LINK_DOWN                                     5
+#define LM_STATUS_LINK_SETTING_MISMATCH                         6
+
+#define LM_STATUS_TOO_MANY_FRAGMENTS                            7
+#define LM_STATUS_TRANSMIT_ABORTED                              8
+#define LM_STATUS_TRANSMIT_ERROR                                9
+#define LM_STATUS_RECEIVE_ABORTED                               10
+#define LM_STATUS_RECEIVE_ERROR                                 11
+#define LM_STATUS_INVALID_PACKET_SIZE                           12
+#define LM_STATUS_OUT_OF_MAP_REGISTERS                          13
+#define LM_STATUS_UNKNOWN_ADAPTER                               14
+
+typedef LM_UINT LM_STATUS, *PLM_STATUS;
+
+
+
+/******************************************************************************/
+/* Requested media type. */
+/******************************************************************************/
+
+#define LM_REQUESTED_MEDIA_TYPE_AUTO                            0
+#define LM_REQUESTED_MEDIA_TYPE_BNC                             1
+#define LM_REQUESTED_MEDIA_TYPE_UTP_AUTO                        2
+#define LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS                      3
+#define LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX          4
+#define LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS                     5
+#define LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX         6
+#define LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS                    7
+#define LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX        8
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS                   9
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS_FULL_DUPLEX       10
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS                  11
+#define LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX      12
+#define LM_REQUESTED_MEDIA_TYPE_MAC_LOOPBACK                    0xfffe
+#define LM_REQUESTED_MEDIA_TYPE_PHY_LOOPBACK                    0xffff
+
+typedef LM_UINT32 LM_REQUESTED_MEDIA_TYPE, *PLM_REQUESTED_MEDIA_TYPE;
+
+
+
+/******************************************************************************/
+/* Media type. */
+/******************************************************************************/
+
+#define LM_MEDIA_TYPE_UNKNOWN                                   -1
+#define LM_MEDIA_TYPE_AUTO                                      0
+#define LM_MEDIA_TYPE_UTP                                       1
+#define LM_MEDIA_TYPE_BNC                                       2
+#define LM_MEDIA_TYPE_AUI                                       3
+#define LM_MEDIA_TYPE_FIBER                                     4
+
+typedef LM_UINT32 LM_MEDIA_TYPE, *PLM_MEDIA_TYPE;
+
+
+
+/******************************************************************************/
+/* Line speed. */
+/******************************************************************************/
+
+#define LM_LINE_SPEED_UNKNOWN                                   0
+#define LM_LINE_SPEED_10MBPS                                    1
+#define LM_LINE_SPEED_100MBPS                                   2
+#define LM_LINE_SPEED_1000MBPS                                  3
+
+typedef LM_UINT32 LM_LINE_SPEED, *PLM_LINE_SPEED;
+
+
+
+/******************************************************************************/
+/* Duplex mode. */
+/******************************************************************************/
+
+#define LM_DUPLEX_MODE_UNKNOWN                                  0
+#define LM_DUPLEX_MODE_HALF                                     1
+#define LM_DUPLEX_MODE_FULL                                     2
+
+typedef LM_UINT32 LM_DUPLEX_MODE, *PLM_DUPLEX_MODE;
+
+
+
+/******************************************************************************/
+/* Power state. */
+/******************************************************************************/
+
+#define LM_POWER_STATE_D0       0
+#define LM_POWER_STATE_D1       1
+#define LM_POWER_STATE_D2       2
+#define LM_POWER_STATE_D3       3
+
+typedef LM_UINT32 LM_POWER_STATE, *PLM_POWER_STATE;
+
+
+
+/******************************************************************************/
+/* Task offloading. */
+/******************************************************************************/
+
+#define LM_TASK_OFFLOAD_NONE                    0x0000
+#define LM_TASK_OFFLOAD_TX_IP_CHECKSUM          0x0001
+#define LM_TASK_OFFLOAD_RX_IP_CHECKSUM          0x0002
+#define LM_TASK_OFFLOAD_TX_TCP_CHECKSUM         0x0004
+#define LM_TASK_OFFLOAD_RX_TCP_CHECKSUM         0x0008
+#define LM_TASK_OFFLOAD_TX_UDP_CHECKSUM         0x0010
+#define LM_TASK_OFFLOAD_RX_UDP_CHECKSUM         0x0020
+#define LM_TASK_OFFLOAD_TCP_SEGMENTATION        0x0040
+
+typedef LM_UINT32 LM_TASK_OFFLOAD, *PLM_TASK_OFFLOAD;
+
+
+
+/******************************************************************************/
+/* Flow control. */
+/******************************************************************************/
+
+#define LM_FLOW_CONTROL_NONE                    0x00
+#define LM_FLOW_CONTROL_RECEIVE_PAUSE           0x01
+#define LM_FLOW_CONTROL_TRANSMIT_PAUSE          0x02
+#define LM_FLOW_CONTROL_RX_TX_PAUSE (LM_FLOW_CONTROL_RECEIVE_PAUSE | \
+    LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+
+/* This value can be or-ed with RECEIVE_PAUSE and TRANSMIT_PAUSE.  If the */
+/* auto-negotiation is disabled and the RECEIVE_PAUSE and TRANSMIT_PAUSE */
+/* bits are set, then flow control is enabled regardless of link partner's */
+/* flow control capability. */
+#define LM_FLOW_CONTROL_AUTO_PAUSE              0x80000000
+
+typedef LM_UINT32 LM_FLOW_CONTROL, *PLM_FLOW_CONTROL;
+
+
+
+/******************************************************************************/
+/* Wake up mode. */
+/******************************************************************************/
+
+#define LM_WAKE_UP_MODE_NONE                    0
+#define LM_WAKE_UP_MODE_MAGIC_PACKET            1
+#define LM_WAKE_UP_MODE_NWUF                    2
+#define LM_WAKE_UP_MODE_LINK_CHANGE             4
+
+typedef LM_UINT32 LM_WAKE_UP_MODE, *PLM_WAKE_UP_MODE;
+
+
+
+/******************************************************************************/
+/* Counters. */
+/******************************************************************************/
+
+#define LM_COUNTER_FRAMES_XMITTED_OK                            0
+#define LM_COUNTER_FRAMES_RECEIVED_OK                           1
+#define LM_COUNTER_ERRORED_TRANSMIT_COUNT                       2
+#define LM_COUNTER_ERRORED_RECEIVE_COUNT                        3
+#define LM_COUNTER_RCV_CRC_ERROR                                4
+#define LM_COUNTER_ALIGNMENT_ERROR                              5
+#define LM_COUNTER_SINGLE_COLLISION_FRAMES                      6
+#define LM_COUNTER_MULTIPLE_COLLISION_FRAMES                    7
+#define LM_COUNTER_FRAMES_DEFERRED                              8
+#define LM_COUNTER_MAX_COLLISIONS                               9
+#define LM_COUNTER_RCV_OVERRUN                                  10
+#define LM_COUNTER_XMIT_UNDERRUN                                11
+#define LM_COUNTER_UNICAST_FRAMES_XMIT                          12
+#define LM_COUNTER_MULTICAST_FRAMES_XMIT                        13
+#define LM_COUNTER_BROADCAST_FRAMES_XMIT                        14
+#define LM_COUNTER_UNICAST_FRAMES_RCV                           15
+#define LM_COUNTER_MULTICAST_FRAMES_RCV                         16
+#define LM_COUNTER_BROADCAST_FRAMES_RCV                         17
+
+typedef LM_UINT32 LM_COUNTER_TYPE, *PLM_COUNTER_TYPE;
+
+
+
+/******************************************************************************/
+/* Forward definition. */
+/******************************************************************************/
+
+typedef struct _LM_DEVICE_BLOCK *PLM_DEVICE_BLOCK;
+typedef struct _LM_PACKET *PLM_PACKET;
+
+
+
+/******************************************************************************/
+/* Function prototypes. */
+/******************************************************************************/
+
+LM_STATUS LM_GetAdapterInfo(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_InitializeAdapter(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_ResetAdapter(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_DisableInterrupt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_EnableInterrupt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SendPacket(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS LM_ServiceInterrupts(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_QueueRxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetReceiveMask(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Mask);
+LM_STATUS LM_Halt(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_Abort(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_MulticastAdd(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMcAddress);
+LM_STATUS LM_MulticastDel(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMcAddress);
+LM_STATUS LM_MulticastClear(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetMacAddress(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pMacAddress);
+LM_STATUS LM_LoopbackAddress(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pAddress);
+
+LM_UINT32 LM_GetCrcCounter(PLM_DEVICE_BLOCK pDevice);
+
+LM_WAKE_UP_MODE LM_PMCapabilities(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_NwufAdd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 ByteMaskSize,
+    LM_UINT8 *pByteMask, LM_UINT8 *pPattern);
+LM_STATUS LM_NwufRemove(PLM_DEVICE_BLOCK pDevice, LM_UINT32 ByteMaskSize,
+    LM_UINT8 *pByteMask, LM_UINT8 *pPattern);
+LM_STATUS LM_SetPowerState(PLM_DEVICE_BLOCK pDevice, LM_POWER_STATE PowerLevel);
+
+LM_VOID LM_ReadPhy(PLM_DEVICE_BLOCK pDevice, LM_UINT32 PhyReg,
+    PLM_UINT32 pData32);
+LM_VOID LM_WritePhy(PLM_DEVICE_BLOCK pDevice, LM_UINT32 PhyReg,
+    LM_UINT32 Data32);
+
+LM_STATUS LM_ControlLoopBack(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Control);
+LM_STATUS LM_SetupPhy(PLM_DEVICE_BLOCK pDevice);
+int LM_BlinkLED(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlinkDuration);
+
+
+
+/******************************************************************************/
+/* These are the OS specific functions called by LMAC. */
+/******************************************************************************/
+
+LM_STATUS MM_ReadConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT16 *pValue16);
+LM_STATUS MM_WriteConfig16(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT16 Value16);
+LM_STATUS MM_ReadConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT32 *pValue32);
+LM_STATUS MM_WriteConfig32(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Offset,
+    LM_UINT32 Value32);
+LM_STATUS MM_MapMemBase(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_MapIoBase(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateRxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateTxPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_StartTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS MM_CompleteTxDma(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS MM_AllocateMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize, 
+    PLM_VOID *pMemoryBlockVirt);
+LM_STATUS MM_AllocateSharedMemory(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlockSize,
+    PLM_VOID *pMemoryBlockVirt, PLM_PHYSICAL_ADDRESS pMemoryBlockPhy,
+    LM_BOOL Cached);
+LM_STATUS MM_GetConfig(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_IndicateStatus(PLM_DEVICE_BLOCK pDevice, LM_STATUS Status);
+LM_STATUS MM_InitializeUmPackets(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS MM_FreeRxBuffer(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket);
+LM_STATUS LM_MbufWorkAround(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_SetLinkSpeed(PLM_DEVICE_BLOCK pDevice,
+			  LM_REQUESTED_MEDIA_TYPE RequestedMediaType);
+
+#if INCLUDE_5703_A0_FIX
+LM_STATUS LM_Load5703DmaWFirmware(PLM_DEVICE_BLOCK pDevice);
+#endif
+
+
+#endif /* LM_H */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/lmcfg.h linux/drivers/net/bcm/lmcfg.h
--- ../ia64/linux/drivers/net/bcm/lmcfg.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/lmcfg.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,39 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef LMCFG_H
+#define LMCFG_H
+
+
+
+/******************************************************************************/
+/* Configurable constants */
+/******************************************************************************/
+
+#define LM_MAJOR_VER                1
+#define LM_MINOR_VER                0
+
+#define LM_SHORT_COMPANY_NAME_STR   "Broadcom"
+#define LM_LONG_COMPANY_NAME_STR    "Broadcom Corporation"
+
+#define LM_LONG_COPYRIGHT_STR    "Copyright \251 2000 Broadcom Corporation.  All rights reserved."
+#define LM_SHORT_COPYRIGHT_STR   "Copyright \251 2000 Broadcom Corporation."
+
+#define LM_DRV_PRODUCT_NAME_STR  "Gigabit Ethernet Driver"
+
+
+
+#endif /* LMCFG_H */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/mm.h linux/drivers/net/bcm/mm.h
--- ../ia64/linux/drivers/net/bcm/mm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/mm.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,192 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/******************************************************************************/
+
+#ifndef MM_H
+#define MM_H
+
+#include <linux/config.h>
+#if defined(CONFIG_SMP) && ! defined(__SMP__)
+#define __SMP__
+#endif
+#if defined(CONFIG_MODVERSIONS) && defined(MODULE) && ! defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+
+#ifndef B57UM
+#define __NO_VERSION__
+#endif
+#include <linux/version.h>
+#ifdef MODULE
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/module.h>
+#else
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#define SET_MODULE_OWNER(dev)
+#define MODULE_DEVICE_TABLE(pci, pci_tbl)
+#endif
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <asm/processor.h>		/* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+#include <linux/time.h>
+#if (LINUX_VERSION_CODE >= 0x020400)
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#endif
+#ifdef CONFIG_PROC_FS
+#include <linux/smp_lock.h>
+#include <linux/proc_fs.h>
+#endif
+
+#ifdef __BIG_ENDIAN
+#define BIG_ENDIAN_HOST 1
+#endif
+
+#if (LINUX_VERSION_CODE < 0x020327)
+#define __raw_readl readl
+#define __raw_writel writel
+#endif
+
+#include "lm.h"
+#include "queue.h"
+#include "tigon3.h"
+
+extern int MM_Packet_Desc_Size;
+
+#define MM_PACKET_DESC_SIZE MM_Packet_Desc_Size
+
+DECLARE_QUEUE_TYPE(UM_RX_PACKET_Q, MAX_RX_PACKET_DESC_COUNT+1);
+
+#define MAX_MEM 16
+
+#if (LINUX_VERSION_CODE < 0x020211)
+typedef u32 dma_addr_t;
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02030e)
+#define net_device device
+#endif
+
+#if (LINUX_VERSION_CODE < 0x02032b)
+#define tasklet_struct			tq_struct
+#endif
+
+typedef struct _UM_DEVICE_BLOCK {
+	LM_DEVICE_BLOCK lm_dev;
+	struct net_device *dev;
+	struct pci_dev *pdev;
+	struct net_device *next_module;
+	char *name;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *pfs_entry;
+	char pfs_name[32];
+#endif
+	void *mem_list[MAX_MEM];
+	dma_addr_t dma_list[MAX_MEM];
+	int mem_size_list[MAX_MEM];
+	int mem_list_num;
+	int index;
+	int opened;
+	int delayed_link_ind; /* Delay link status during initial load */
+	int adapter_just_inited; /* the first few seconds after init. */
+	int spurious_int;
+	int timer_interval;
+	int adaptive_expiry;
+	int crc_counter_expiry;
+	int poll_tbi_expiry;
+	int tx_full;
+	int tx_queued;
+	int line_speed;		/* in Mbps, 0 if link is down */
+	UM_RX_PACKET_Q rx_out_of_buf_q;
+	int rx_out_of_buf;
+	int rx_buf_repl_thresh;
+	int rx_buf_repl_panic_thresh;
+	int rx_buf_align;
+	struct timer_list timer;
+	int do_global_lock;
+	spinlock_t global_lock;
+	spinlock_t undi_lock;
+	long undi_flags;
+	volatile int interrupt;
+	int tasklet_pending;
+	int tasklet_busy;
+	struct tasklet_struct tasklet;
+	struct net_device_stats stats;
+#ifdef NICE_SUPPORT
+	void (*nice_rx)( struct sk_buff*, void* );
+	void* nice_ctx;
+#endif /* NICE_SUPPORT */
+	int adaptive_coalesce;
+	uint rx_last_cnt;
+	uint tx_last_cnt;
+	uint rx_curr_coalesce_frames;
+	uint rx_curr_coalesce_ticks;
+	uint tx_curr_coalesce_frames;
+#if TIGON3_DEBUG
+	uint tx_zc_count;
+	uint tx_chksum_count;
+	uint tx_himem_count;
+	uint rx_good_chksum_count;
+#endif
+	uint rx_bad_chksum_count;
+	uint rx_misc_errors;
+} UM_DEVICE_BLOCK, *PUM_DEVICE_BLOCK;
+
+#define MM_ACQUIRE_UNDI_LOCK(_pDevice) \
+	if (!(((PUM_DEVICE_BLOCK)(_pDevice))->do_global_lock)) {	\
+		long flags;						\
+		spin_lock_irqsave(&((PUM_DEVICE_BLOCK)(_pDevice))->undi_lock, flags);	\
+		((PUM_DEVICE_BLOCK)(_pDevice))->undi_flags = flags; \
+	}
+
+#define MM_RELEASE_UNDI_LOCK(_pDevice) \
+	if (!(((PUM_DEVICE_BLOCK)(_pDevice))->do_global_lock)) {	\
+		long flags = ((PUM_DEVICE_BLOCK) (_pDevice))->undi_flags; \
+		spin_unlock_irqrestore(&((PUM_DEVICE_BLOCK)(_pDevice))->undi_lock, flags); \
+	}
+
+#define MM_ACQUIRE_INT_LOCK(_pDevice) \
+	while (((PUM_DEVICE_BLOCK) _pDevice)->interrupt)
+
+#define MM_RELEASE_INT_LOCK(_pDevice)
+
+#define MM_UINT_PTR(_ptr)   ((unsigned long) (_ptr))
+
+#define DbgPrint(fmt, arg...) printk(KERN_WARNING fmt, ##arg)
+#if defined(CONFIG_X86)
+#define DbgBreakPoint() __asm__("int $129")
+#else
+#define DbgBreakPoint()
+#endif
+#define MM_Wait(time) udelay(time)
+
+#endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/nicext.h linux/drivers/net/bcm/nicext.h
--- ../ia64/linux/drivers/net/bcm/nicext.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/nicext.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,110 @@
+/****************************************************************************
+ * Copyright(c) 2000-2001 Broadcom Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.          
+ *
+ * Name:        nicext.h
+ *
+ * Description: Broadcom Network Interface Card Extension (NICE) is an 
+ *              extension to Linux NET device kernel mode drivers. 
+ *              NICE is designed to provide additional functionalities, 
+ *              such as receive packet intercept. To support Broadcom NICE, 
+ *              the network device driver can be modified by adding an 
+ *              device ioctl handler and by indicating receiving packets 
+ *              to the NICE receive handler. Broadcom NICE will only be 
+ *              enabled by a NICE-aware intermediate driver, such as 
+ *              Broadcom Advanced Server Program Driver (BASP). When NICE 
+ *              is not enabled, the modified network device drivers 
+ *              functions exactly as other non-NICE aware drivers.
+ *
+ * Author:      Frankie Fan
+ *
+ * Created:     September 17, 2000
+ *
+ ****************************************************************************/
+#ifndef _nicext_h_
+#define _nicext_h_
+
+/*
+ * ioctl for NICE
+ */
+#define SIOCNICE                   	SIOCDEVPRIVATE+7
+
+/*
+ * SIOCNICE: 
+ *
+ * The following structure needs to be less than IFNAMSIZ (16 bytes) because
+ * we're overloading ifreq.ifr_ifru.
+ *
+ * If 16 bytes is not enough, we should consider relaxing this because
+ * this is no field after ifr_ifru in the ifreq structure. But we may
+ * run into future compatiability problem in case of changing struct ifreq.
+ */
+struct nice_req
+{
+    __u32 cmd;
+    
+    union
+    {
+#ifdef __KERNEL__
+        /* cmd = NICE_CMD_SET_RX or NICE_CMD_GET_RX */
+        struct
+        {
+            void (*nrqus1_rx)( struct sk_buff*, void* );
+            void* nrqus1_ctx;
+        } nrqu_nrqus1;
+
+        /* cmd = NICE_CMD_QUERY_SUPPORT */
+        struct
+        {
+            __u32 nrqus2_magic;
+            __u32 nrqus2_support_rx:1;
+            __u32 nrqus2_support_vlan:1;
+            __u32 nrqus2_support_get_speed:1;
+        } nrqu_nrqus2;
+#endif
+
+        /* cmd = NICE_CMD_GET_SPEED */
+        struct
+        {
+            unsigned int nrqus3_speed; /* 0 if link is down, */
+                                       /* otherwise speed in Mbps */
+        } nrqu_nrqus3;
+
+        /* cmd = NICE_CMD_BLINK_LED */
+        struct
+        {
+            unsigned int nrqus4_blink_time; /* blink duration in seconds */
+        } nrqu_nrqus4;
+
+    } nrq_nrqu;
+};
+
+#define nrq_rx           nrq_nrqu.nrqu_nrqus1.nrqus1_rx
+#define nrq_ctx          nrq_nrqu.nrqu_nrqus1.nrqus1_ctx
+#define nrq_support_rx   nrq_nrqu.nrqu_nrqus2.nrqus2_support_rx
+#define nrq_magic        nrq_nrqu.nrqu_nrqus2.nrqus2_magic
+#define nrq_support_vlan nrq_nrqu.nrqu_nrqus2.nrqus2_support_vlan
+#define nrq_support_get_speed nrq_nrqu.nrqu_nrqus2.nrqus2_support_get_speed
+#define nrq_speed        nrq_nrqu.nrqu_nrqus3.nrqus3_speed
+#define nrq_blink_time   nrq_nrqu.nrqu_nrqus4.nrqus4_blink_time
+
+/*
+ * magic constants
+ */
+#define NICE_REQUESTOR_MAGIC            0x4543494E // NICE in ascii
+#define NICE_DEVICE_MAGIC               0x4E494345 // ECIN in ascii
+
+/*
+ * command field
+ */
+#define NICE_CMD_QUERY_SUPPORT          0x00000001
+#define NICE_CMD_SET_RX                 0x00000002
+#define NICE_CMD_GET_RX                 0x00000003
+#define NICE_CMD_GET_SPEED              0x00000004
+#define NICE_CMD_BLINK_LED              0x00000005
+
+#endif  // _nicext_h_ 
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/queue.h linux/drivers/net/bcm/queue.h
--- ../ia64/linux/drivers/net/bcm/queue.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/queue.h	Wed Feb 27 15:16:55 2002
@@ -0,0 +1,338 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* Queue functions.                                                           */
+/*    void          QQ_InitQueue(PQQ_CONTAINER pQueue)                        */
+/*    char          QQ_Full(PQQ_CONTAINER pQueue)                             */
+/*    char          QQ_Empty(PQQ_CONTAINER pQueue)                            */
+/*    unsigned int QQ_GetSize(PQQ_CONTAINER pQueue)                          */
+/*    unsigned int QQ_GetEntryCnt(PQQ_CONTAINER pQueue)                      */
+/*    char          QQ_PushHead(PQQ_CONTAINER pQueue, PQQ_ENTRY pEntry)       */
+/*    char          QQ_PushTail(PQQ_CONTAINER pQueue, PQQ_ENTRY pEntry)       */
+/*    PQQ_ENTRY     QQ_PopHead(PQQ_CONTAINER pQueue)                          */
+/*    PQQ_ENTRY     QQ_PopTail(PQQ_CONTAINER pQueue)                          */
+/*    PQQ_ENTRY     QQ_GetHead(PQQ_CONTAINER pQueue, unsigned int Idx)       */
+/*    PQQ_ENTRY     QQ_GetTail(PQQ_CONTAINER pQueue, unsigned int Idx)       */
+/*                                                                            */
+/*                                                                            */
+/* History:                                                                   */
+/*    02/25/00 Hav Khauv        Initial version.                              */
+/******************************************************************************/
+
+#ifndef BCM_QUEUE_H
+#define BCM_QUEUE_H
+
+
+
+/******************************************************************************/
+/* Queue definitions. */
+/******************************************************************************/
+
+/* Entry for queueing. */
+typedef void *PQQ_ENTRY;
+
+
+/* Queue header -- base type. */
+typedef struct {
+    unsigned int Head;
+    unsigned int Tail;
+    unsigned int Size;
+    atomic_t EntryCnt;
+    PQQ_ENTRY Array[1];
+} QQ_CONTAINER, *PQQ_CONTAINER;
+
+
+/* Declare queue type macro. */
+#define DECLARE_QUEUE_TYPE(_QUEUE_TYPE, _QUEUE_SIZE)            \
+                                                                \
+    typedef struct {                                            \
+        QQ_CONTAINER Container;                                 \
+        PQQ_ENTRY EntryBuffer[_QUEUE_SIZE];                     \
+    } _QUEUE_TYPE, *P##_QUEUE_TYPE
+
+
+
+/******************************************************************************/
+/* Compilation switches. */
+/******************************************************************************/
+
+#if DBG
+#undef QQ_NO_OVERFLOW_CHECK
+#undef QQ_NO_UNDERFLOW_CHECK
+#endif /* DBG */
+
+#ifdef QQ_USE_MACROS
+/* notdone */
+#else
+
+#ifdef QQ_NO_INLINE
+#define __inline
+#endif /* QQ_NO_INLINE */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void 
+QQ_InitQueue(
+PQQ_CONTAINER pQueue,
+unsigned int QueueSize) {
+    pQueue->Head = 0;
+    pQueue->Tail = 0;
+    pQueue->Size = QueueSize+1;
+    atomic_set(&pQueue->EntryCnt, 0);
+} /* QQ_InitQueue */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_Full(
+PQQ_CONTAINER pQueue) {
+    unsigned int NewHead;
+
+    NewHead = (pQueue->Head + 1) % pQueue->Size;
+
+    return(NewHead == pQueue->Tail);
+} /* QQ_Full */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_Empty(
+PQQ_CONTAINER pQueue) {
+    return(pQueue->Head == pQueue->Tail);
+} /* QQ_Empty */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned int 
+QQ_GetSize(
+PQQ_CONTAINER pQueue) {
+    return pQueue->Size;
+} /* QQ_GetSize */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned int 
+QQ_GetEntryCnt(
+PQQ_CONTAINER pQueue) {
+    return atomic_read(&pQueue->EntryCnt);
+} /* QQ_GetEntryCnt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    TRUE entry was added successfully.                                      */
+/*    FALSE queue is full.                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_PushHead(
+PQQ_CONTAINER pQueue, 
+PQQ_ENTRY pEntry) {
+    unsigned int Head;
+
+    Head = (pQueue->Head + 1) % pQueue->Size;
+
+#if !defined(QQ_NO_OVERFLOW_CHECK)
+    if(Head == pQueue->Tail) {
+        return 0;
+    } /* if */
+#endif /* QQ_NO_OVERFLOW_CHECK */
+
+    pQueue->Array[pQueue->Head] = pEntry;
+    pQueue->Head = Head;
+    atomic_inc(&pQueue->EntryCnt);
+
+    return -1;
+} /* QQ_PushHead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    TRUE entry was added successfully.                                      */
+/*    FALSE queue is full.                                                    */
+/******************************************************************************/
+__inline static char 
+QQ_PushTail(
+PQQ_CONTAINER pQueue,
+PQQ_ENTRY pEntry) {
+    unsigned int Tail;
+
+    Tail = pQueue->Tail;
+    if(Tail == 0) {
+        Tail = pQueue->Size;
+    } /* if */
+    Tail--;
+
+#if !defined(QQ_NO_OVERFLOW_CHECK)
+    if(Tail == pQueue->Head) {
+        return 0;
+    } /* if */
+#endif /* QQ_NO_OVERFLOW_CHECK */
+
+    pQueue->Array[Tail] = pEntry;
+    pQueue->Tail = Tail;
+    atomic_inc(&pQueue->EntryCnt);
+
+    return -1;
+} /* QQ_PushTail */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_PopHead(
+PQQ_CONTAINER pQueue) {
+    unsigned int Head;
+    PQQ_ENTRY Entry;
+
+    Head = pQueue->Head;
+
+#if !defined(QQ_NO_UNDERFLOW_CHECK)
+    if(Head == pQueue->Tail) {
+        return (PQQ_ENTRY) 0;
+    } /* if */
+#endif /* QQ_NO_UNDERFLOW_CHECK */
+
+    if(Head == 0) {
+        Head = pQueue->Size;
+    } /* if */
+    Head--;
+
+    Entry = pQueue->Array[Head];
+    pQueue->Head = Head;
+    atomic_dec(&pQueue->EntryCnt);
+
+    return Entry;
+} /* QQ_PopHead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_PopTail(
+PQQ_CONTAINER pQueue) {
+    unsigned int Tail;
+    PQQ_ENTRY Entry;
+
+    Tail = pQueue->Tail;
+
+#if !defined(QQ_NO_UNDERFLOW_CHECK)
+    if(Tail == pQueue->Head) {
+        return (PQQ_ENTRY) 0;
+    } /* if */
+#endif /* QQ_NO_UNDERFLOW_CHECK */
+
+    Entry = pQueue->Array[Tail];
+    pQueue->Tail = (Tail + 1) % pQueue->Size;
+    atomic_dec(&pQueue->EntryCnt);
+
+    return Entry;
+} /* QQ_PopTail */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_GetHead(
+    PQQ_CONTAINER pQueue,
+    unsigned int Idx)
+{
+    if(Idx >= atomic_read(&pQueue->EntryCnt))
+    {
+        return (PQQ_ENTRY) 0;
+    }
+
+    if(pQueue->Head > Idx)
+    {
+        Idx = pQueue->Head - Idx;
+    }
+    else
+    {
+        Idx = pQueue->Size - (Idx - pQueue->Head);
+    }
+    Idx--;
+
+    return pQueue->Array[Idx];
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static PQQ_ENTRY
+QQ_GetTail(
+    PQQ_CONTAINER pQueue,
+    unsigned int Idx)
+{
+    if(Idx >= atomic_read(&pQueue->EntryCnt))
+    {
+        return (PQQ_ENTRY) 0;
+    }
+
+    Idx += pQueue->Tail;
+    if(Idx >= pQueue->Size)
+    {
+        Idx = Idx - pQueue->Size;
+    }
+
+    return pQueue->Array[Idx];
+}
+
+#endif /* QQ_USE_MACROS */
+
+
+
+#endif /* QUEUE_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/tigon3.c linux/drivers/net/bcm/tigon3.c
--- ../ia64/linux/drivers/net/bcm/tigon3.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/tigon3.c	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,5929 @@
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/******************************************************************************/
+
+#include "mm.h"
+
+
+
+/******************************************************************************/
+/* Local functions. */
+/******************************************************************************/
+
+LM_STATUS LM_Abort(PLM_DEVICE_BLOCK pDevice);
+LM_STATUS LM_QueueRxPackets(PLM_DEVICE_BLOCK pDevice);
+
+static LM_STATUS LM_TranslateRequestedMediaType(
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+    PLM_MEDIA_TYPE pMediaType, PLM_LINE_SPEED pLineSpeed,
+    PLM_DUPLEX_MODE pDuplexMode);
+
+static LM_STATUS LM_InitBcm540xPhy(PLM_DEVICE_BLOCK pDevice);
+
+__inline static LM_VOID LM_ServiceRxInterrupt(PLM_DEVICE_BLOCK pDevice);
+__inline static LM_VOID LM_ServiceTxInterrupt(PLM_DEVICE_BLOCK pDevice);
+
+static LM_STATUS LM_ForceAutoNegBcm540xPhy(PLM_DEVICE_BLOCK pDevice, 
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType, LM_BOOL WaitForLink);
+static LM_STATUS LM_ForceAutoNeg(PLM_DEVICE_BLOCK pDevice, 
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType, LM_BOOL WaitForLink);
+static LM_UINT32 GetPhyAdFlowCntrlSettings(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_SetFlowControl(PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 LocalPhyAd, LM_UINT32 RemotePhyAd);
+STATIC LM_STATUS LM_SetupFiberPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_SetupCopperPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC LM_STATUS LM_InitBcm800xPhy(PLM_DEVICE_BLOCK pDevice);
+STATIC PLM_ADAPTER_INFO LM_GetAdapterInfoBySsid(LM_UINT16 Svid, LM_UINT16 Ssid);
+STATIC LM_STATUS LM_DmaTest(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pBufferVirt,
+           LM_PHYSICAL_ADDRESS BufferPhy, LM_UINT32 BufferSize);
+STATIC LM_STATUS LM_HaltCpu(PLM_DEVICE_BLOCK pDevice,LM_UINT32 cpu_number);
+STATIC LM_STATUS LM_ResetChip(PLM_DEVICE_BLOCK pDevice);
+
+
+/******************************************************************************/
+/* External functions. */
+/******************************************************************************/
+
+LM_STATUS LM_LoadRlsFirmware(PLM_DEVICE_BLOCK pDevice);
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_UINT32
+LM_RegRdInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Register) {
+    LM_UINT32 Value32;
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#endif
+    MM_WriteConfig32(pDevice, T3_PCI_REG_ADDR_REG, Register);
+    MM_ReadConfig32(pDevice, T3_PCI_REG_DATA_REG, &Value32);
+#if PCIX_TARGET_WORKAROUND
+    MM_RELEASE_UNDI_LOCK(pDevice);
+#endif
+
+    return Value32;
+} /* LM_RegRdInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_RegWrInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Register,
+LM_UINT32 Value32) {
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#endif
+    MM_WriteConfig32(pDevice, T3_PCI_REG_ADDR_REG, Register);
+    MM_WriteConfig32(pDevice, T3_PCI_REG_DATA_REG, Value32);
+#if PCIX_TARGET_WORKAROUND
+    MM_RELEASE_UNDI_LOCK(pDevice);
+#endif
+} /* LM_RegWrInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_UINT32
+LM_MemRdInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 MemAddr) {
+    LM_UINT32 Value32;
+
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#ifdef BIG_ENDIAN_HOST
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    Value32 = REG_RD(pDevice, PciCfg.MemWindowData);
+    /*    Value32 = REG_RD(pDevice,uIntMem.Mbuf[(MemAddr & 0x7fff)/4]); */
+#else
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    MM_ReadConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, &Value32);
+#endif
+    MM_RELEASE_UNDI_LOCK(pDevice);
+
+    return Value32;
+} /* LM_MemRdInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_MemWrInd(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 MemAddr,
+LM_UINT32 Value32) {
+    MM_ACQUIRE_UNDI_LOCK(pDevice);
+#ifdef BIG_ENDIAN_HOST
+    REG_WR(pDevice,PciCfg.MemWindowBaseAddr,MemAddr);
+    REG_WR(pDevice,uIntMem.Mbuf[(MemAddr & 0x7fff)/4],Value32);
+#else
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, MemAddr);
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, Value32);
+#endif
+    MM_RELEASE_UNDI_LOCK(pDevice);
+} /* LM_MemWrInd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_QueueRxPackets(
+PLM_DEVICE_BLOCK pDevice) {
+    LM_STATUS Lmstatus;
+    PLM_PACKET pPacket;
+    PT3_RCV_BD pRcvBd;
+    LM_UINT32 StdBdAdded = 0;
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    LM_UINT32 JumboBdAdded = 0;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    Lmstatus = LM_STATUS_SUCCESS;
+
+    pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+    while(pPacket) {
+        switch(pPacket->u.Rx.RcvProdRing) {
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+            case T3_JUMBO_RCV_PROD_RING:        /* Jumbo Receive Ring. */
+                /* Initialize the buffer descriptor. */
+                pRcvBd = 
+                    &pDevice->pRxJumboBdVirt[pDevice->RxJumboProdIdx];
+                pRcvBd->Flags = RCV_BD_FLAG_END | RCV_BD_FLAG_JUMBO_RING;
+                pRcvBd->Len = (LM_UINT16) pDevice->RxJumboBufferSize;
+
+                /* Initialize the receive buffer pointer */
+                pRcvBd->HostAddr.Low = pPacket->u.Rx.RxBufferPhy.Low;
+                pRcvBd->HostAddr.High = pPacket->u.Rx.RxBufferPhy.High;
+
+                /* The opaque field may point to an offset from a fix addr. */
+                pRcvBd->Opaque = (LM_UINT32) (MM_UINT_PTR(pPacket) - 
+                    MM_UINT_PTR(pDevice->pPacketDescBase));
+
+                /* Update the producer index. */
+                pDevice->RxJumboProdIdx = (pDevice->RxJumboProdIdx + 1) & 
+                    T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK;
+
+                JumboBdAdded++;
+                break;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+            case T3_STD_RCV_PROD_RING:      /* Standard Receive Ring. */
+                /* Initialize the buffer descriptor. */
+                pRcvBd = &pDevice->pRxStdBdVirt[pDevice->RxStdProdIdx];
+                pRcvBd->Flags = RCV_BD_FLAG_END;
+                pRcvBd->Len = MAX_STD_RCV_BUFFER_SIZE;
+
+                /* Initialize the receive buffer pointer */
+                pRcvBd->HostAddr.Low = pPacket->u.Rx.RxBufferPhy.Low;
+                pRcvBd->HostAddr.High = pPacket->u.Rx.RxBufferPhy.High;
+
+                /* The opaque field may point to an offset from a fix addr. */
+                pRcvBd->Opaque = (LM_UINT32) (MM_UINT_PTR(pPacket) - 
+                    MM_UINT_PTR(pDevice->pPacketDescBase));
+
+                /* Update the producer index. */
+                pDevice->RxStdProdIdx = (pDevice->RxStdProdIdx + 1) & 
+                    T3_STD_RCV_RCB_ENTRY_COUNT_MASK;
+
+                StdBdAdded++;
+                break;
+
+            case T3_UNKNOWN_RCV_PROD_RING:
+            default:
+                Lmstatus = LM_STATUS_FAILURE;
+                break;
+        } /* switch */
+
+        /* Bail out if there is any error. */
+        if(Lmstatus != LM_STATUS_SUCCESS)
+        {
+            break;
+        }
+
+        pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+    } /* while */
+
+    wmb();
+    /* Update the procedure index. */
+    if(StdBdAdded)
+    {
+        RAW_REG_WR(pDevice, Mailbox.RcvStdProdIdx.Low, pDevice->RxStdProdIdx);
+    }
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    if(JumboBdAdded)
+    {
+        RAW_REG_WR(pDevice, Mailbox.RcvJumboProdIdx.Low,
+            pDevice->RxJumboProdIdx);
+    }
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    return Lmstatus;
+} /* LM_QueueRxPackets */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_VOID
+LM_NvramInit(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    /* Intialize clock period and state machine. */
+    Value32 = SEEPROM_ADDR_CLK_PERD(SEEPROM_CLOCK_PERIOD) |
+        SEEPROM_ADDR_FSM_RESET;
+    REG_WR(pDevice, Grc.EepromAddr, Value32);
+
+    for(j = 0; j < 100; j++)
+    {
+        MM_Wait(10);
+    }
+
+    /* Serial eeprom access using the Grc.EepromAddr/EepromData registers. */
+    Value32 = REG_RD(pDevice, Grc.LocalCtrl);
+    REG_WR(pDevice, Grc.LocalCtrl, Value32 | GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM);
+
+    /* Set the 5701 compatibility mode if we are using EEPROM. */
+    if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+        T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5701)
+    {
+        Value32 = REG_RD(pDevice, Nvram.Config1);
+        if((Value32 & FLASH_INTERFACE_ENABLE) == 0)
+        {
+            /* Use the new interface to read EEPROM. */
+            Value32 &= ~FLASH_COMPAT_BYPASS;
+
+            REG_WR(pDevice, Nvram.Config1, Value32);
+        }
+    }
+} /* LM_NvRamInit */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_EepromRead(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 Offset,
+    LM_UINT32 *pData)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 Addr;
+    LM_UINT32 Dev;
+    LM_UINT32 j;
+
+    if(Offset > SEEPROM_CHIP_SIZE)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    Dev = Offset / SEEPROM_CHIP_SIZE;
+    Addr = Offset % SEEPROM_CHIP_SIZE;
+    
+    Value32 = REG_RD(pDevice, Grc.EepromAddr);
+    Value32 &= ~(SEEPROM_ADDR_ADDRESS_MASK | SEEPROM_ADDR_DEV_ID_MASK |
+        SEEPROM_ADDR_RW_MASK);
+    REG_WR(pDevice, Grc.EepromAddr, Value32 | SEEPROM_ADDR_DEV_ID(Dev) |
+        SEEPROM_ADDR_ADDRESS(Addr) | SEEPROM_ADDR_START | SEEPROM_ADDR_READ);
+
+    for(j = 0; j < 1000; j++)
+    {
+        Value32 = REG_RD(pDevice, Grc.EepromAddr);
+        if(Value32 & SEEPROM_ADDR_COMPLETE)
+        {
+            break;
+        }
+        MM_Wait(10);
+    }
+
+    if(Value32 & SEEPROM_ADDR_COMPLETE)
+    {
+        Value32 = REG_RD(pDevice, Grc.EepromData);
+        *pData = Value32;
+
+        return LM_STATUS_SUCCESS;
+    }
+
+    return LM_STATUS_FAILURE;
+} /* LM_EepromRead */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_NvramRead(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 Offset,
+    LM_UINT32 *pData)
+{
+    LM_UINT32 Value32;
+    LM_STATUS Status;
+    LM_UINT32 j;
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+        T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+    {
+        Status = LM_EepromRead(pDevice, Offset, pData);
+    }
+    else
+    {
+        /* Determine if we have flash or EEPROM. */
+        Value32 = REG_RD(pDevice, Nvram.Config1);
+        if(Value32 & FLASH_INTERFACE_ENABLE)
+        {
+            if(Value32 & FLASH_SSRAM_BUFFERRED_MODE)
+            {
+                Offset = ((Offset/BUFFERED_FLASH_PAGE_SIZE) <<
+                    BUFFERED_FLASH_PAGE_POS) +
+                    (Offset % BUFFERED_FLASH_PAGE_SIZE);
+            }
+        }
+
+        REG_WR(pDevice, Nvram.SwArb, SW_ARB_REQ_SET1);
+        for (j = 0; j < 1000; j++)
+        {
+            if (REG_RD(pDevice, Nvram.SwArb) & SW_ARB_GNT1)
+            {
+                break;
+            }
+            MM_Wait(20);
+        }
+        if (j == 1000)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        /* Read from flash or EEPROM with the new 5703/02 interface. */
+        REG_WR(pDevice, Nvram.Addr, Offset & NVRAM_ADDRESS_MASK);
+
+        REG_WR(pDevice, Nvram.Cmd, NVRAM_CMD_RD | NVRAM_CMD_DO_IT |
+            NVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);
+
+        /* Wait for the done bit to clear. */
+        for(j = 0; j < 500; j++)
+        {
+            MM_Wait(10);
+
+            Value32 = REG_RD(pDevice, Nvram.Cmd);
+            if(!(Value32 & NVRAM_CMD_DONE))
+            {
+                break;
+            }
+        }
+        
+        /* Wait for the done bit. */
+        if(!(Value32 & NVRAM_CMD_DONE))
+        {
+            for(j = 0; j < 500; j++)
+            {
+                MM_Wait(10);
+
+                Value32 = REG_RD(pDevice, Nvram.Cmd);
+                if(Value32 & NVRAM_CMD_DONE)
+                {
+                    MM_Wait(10);
+
+                    *pData = REG_RD(pDevice, Nvram.ReadData);
+
+                    /* Change the endianess. */
+                    *pData = ((*pData & 0xff) << 24)| ((*pData & 0xff00) << 8)|
+                        ((*pData & 0xff0000) >> 8) | ((*pData >> 24) & 0xff);
+
+                    break;
+                }
+            }
+        }
+
+        REG_WR(pDevice, Nvram.SwArb, SW_ARB_REQ_CLR1);
+        if(Value32 & NVRAM_CMD_DONE)
+        {
+            Status = LM_STATUS_SUCCESS;
+        }
+        else
+        {
+            Status = LM_STATUS_FAILURE;
+        }
+    }
+
+    return Status;
+} /* LM_NvramRead */
+
+
+
+STATIC void
+LM_ReadVPD(PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT8 Vpd[256];
+    LM_UINT32 *Vpd_dptr = (LM_UINT32 *) Vpd;
+    LM_UINT32 Value32;
+    unsigned int j;
+
+    /* Read PN from VPD */
+    for (j = 0; j < 256; j += 4, Vpd_dptr++ )
+    {
+        if (LM_NvramRead(pDevice, 0x100 + j, &Value32) != LM_STATUS_SUCCESS) {
+            printk(KERN_ERR "VPD read failed\n");
+            return;
+        }
+        *Vpd_dptr = cpu_to_le32(Value32);
+    }
+    for (j = 0; j < 256; )
+    {
+        unsigned int Vpd_r_len;
+        unsigned int Vpd_r_end;
+
+        if ((Vpd[j] == 0x82) || (Vpd[j] == 0x91))
+        {
+            j = j + 3 + Vpd[j + 1] + (Vpd[j + 2] << 8);
+        }
+        else if (Vpd[j] == 0x90)
+        {
+            Vpd_r_len =  Vpd[j + 1] + (Vpd[j + 2] << 8);
+            j += 3;
+            Vpd_r_end = Vpd_r_len + j;
+            while (j < Vpd_r_end)
+            {
+                if ((Vpd[j] == 'P') && (Vpd[j + 1] == 'N'))
+                {
+                    unsigned int len = Vpd[j + 2];
+
+                    if (len <= 24)
+                    {
+                        memcpy(pDevice->PartNo, &Vpd[j + 3], len);
+                    }
+                    break;
+                }
+                else
+                {
+                    if (Vpd[j + 2] == 0)
+                    {
+                        break;
+                    }
+                    j = j + Vpd[j + 2];
+                }
+            }
+            break;
+        }
+        else {
+            break;
+        }
+    }
+}
+
+STATIC void
+LM_ReadBootCodeVersion(PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32, offset, ver_offset;
+    int i;
+
+    if (LM_NvramRead(pDevice, 0x0, &Value32) != LM_STATUS_SUCCESS)
+        return;
+    if (Value32 != 0xaa559966)
+        return;
+    if (LM_NvramRead(pDevice, 0xc, &offset) != LM_STATUS_SUCCESS)
+        return;
+
+    offset = ((offset & 0xff) << 24)| ((offset & 0xff00) << 8)|
+        ((offset & 0xff0000) >> 8) | ((offset >> 24) & 0xff);
+    if (LM_NvramRead(pDevice, offset, &Value32) != LM_STATUS_SUCCESS)
+        return;
+    if ((Value32 == 0x0300000e) &&
+        (LM_NvramRead(pDevice, offset + 4, &Value32) == LM_STATUS_SUCCESS) &&
+        (Value32 == 0)) {
+
+        if (LM_NvramRead(pDevice, offset + 8, &ver_offset) != LM_STATUS_SUCCESS)
+            return;
+        ver_offset = ((ver_offset & 0xff0000) >> 8) |
+            ((ver_offset >> 24) & 0xff);
+        for (i = 0; i < 16; i += 4) {
+            if (LM_NvramRead(pDevice, offset + ver_offset + i, &Value32) !=
+                LM_STATUS_SUCCESS)
+            {
+                return;
+            }
+            *((LM_UINT32 *) &pDevice->BootCodeVer[i]) = cpu_to_le32(Value32);
+        }
+    }
+    else {
+        char c;
+
+        if (LM_NvramRead(pDevice, 0x94, &Value32) != LM_STATUS_SUCCESS)
+            return;
+
+        i = 0;
+        c = ((Value32 & 0xff0000) >> 16);
+
+        if (c < 10) {
+            pDevice->BootCodeVer[i++] = c + '0';
+        }
+        else {
+            pDevice->BootCodeVer[i++] = (c / 10) + '0';
+            pDevice->BootCodeVer[i++] = (c % 10) + '0';
+        }
+        pDevice->BootCodeVer[i++] = '.';
+        c = (Value32 & 0xff000000) >> 24;
+        if (c < 10) {
+            pDevice->BootCodeVer[i++] = c + '0';
+        }
+        else {
+            pDevice->BootCodeVer[i++] = (c / 10) + '0';
+            pDevice->BootCodeVer[i++] = (c % 10) + '0';
+        }
+        pDevice->BootCodeVer[i] = 0;
+    }
+}
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine initializes default parameters and reads the PCI           */
+/*    configurations.                                                         */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_GetAdapterInfo(
+PLM_DEVICE_BLOCK pDevice)
+{
+    PLM_ADAPTER_INFO pAdapterInfo;
+    LM_UINT32 Value32;
+    LM_STATUS Status;
+    LM_UINT32 j;
+    LM_UINT32 EeSigFound;
+    LM_UINT32 EePhyTypeSerdes = 0;
+    LM_UINT32 EePhyLedMode = 0;
+    LM_UINT32 EePhyId = 0;
+
+    /* Get Device Id and Vendor Id */
+    Status = MM_ReadConfig32(pDevice, PCI_VENDOR_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->PciVendorId = (LM_UINT16) Value32;
+    pDevice->PciDeviceId = (LM_UINT16) (Value32 >> 16);
+
+    /* If we are not getting the write adapter, exit. */
+    if((Value32 != T3_PCI_ID_BCM5700) && 
+       (Value32 != T3_PCI_ID_BCM5701) &&
+       (Value32 != T3_PCI_ID_BCM5702) &&
+       (Value32 != T3_PCI_ID_BCM5702x) &&
+       (Value32 != T3_PCI_ID_BCM5702FE) &&
+       (Value32 != T3_PCI_ID_BCM5703) &&
+       (Value32 != T3_PCI_ID_BCM5703x))
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    Status = MM_ReadConfig32(pDevice, PCI_REV_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->PciRevId = (LM_UINT8) Value32;
+
+    /* Get IRQ. */
+    Status = MM_ReadConfig32(pDevice, PCI_INT_LINE_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->Irq = (LM_UINT8) Value32;
+
+    /* Get interrupt pin. */
+    pDevice->IntPin = (LM_UINT8) (Value32 >> 8);
+
+    /* Get chip revision id. */
+    Status = MM_ReadConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, &Value32);
+    pDevice->ChipRevId = Value32 >> 16;
+
+    /* Get subsystem vendor. */
+    Status = MM_ReadConfig32(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, &Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->SubsystemVendorId = (LM_UINT16) Value32;
+
+    /* Get PCI subsystem id. */
+    pDevice->SubsystemId = (LM_UINT16) (Value32 >> 16);
+
+    /* Get the cache line size. */
+    MM_ReadConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG, &Value32);
+    pDevice->CacheLineSize = (LM_UINT8) Value32;
+    pDevice->SavedCacheLineReg = Value32;
+
+    /* Get PCI memory base. */
+    MM_ReadConfig32(pDevice, PCI_MEM_BASE_ADDR_HIGH, &Value32);
+    pDevice->MemBaseHigh = Value32;
+
+    MM_ReadConfig32(pDevice, PCI_MEM_BASE_ADDR_LOW, &Value32);
+    Value32 &= 0xfffffff0;
+    pDevice->MemBaseLow = Value32;
+
+    /* Initialize require MemBase Size */
+    pDevice->MemBaseSize = sizeof(T3_STD_MEM_MAP); 
+
+    /* Map the memory base to system address space. */
+    Status = MM_MapMemBase(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Initialize the memory view pointer. */
+    pDevice->pMemView = (PT3_STD_MEM_MAP) pDevice->pMappedMemBase;
+
+#if PCIX_TARGET_WORKAROUND
+    /* store whether we are in PCI are PCI-X mode */
+    pDevice->EnablePciXFix = FALSE;
+
+    MM_ReadConfig32(pDevice, T3_PCI_STATE_REG, &Value32);
+    if((Value32 & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) == 0)
+    {
+        /* Enable PCI-X workaround only if we are running on 5700 BX. */
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            pDevice->EnablePciXFix = TRUE;
+        }
+    }
+#endif
+    /* Bx bug: due to the "byte_enable bug" in PCI-X mode, the power */
+    /* management register may be clobbered which may cause the */
+    /* BCM5700 to go into D3 state.  While in this state, we will */
+    /* not have memory mapped register access.  As a workaround, we */
+    /* need to restore the device to D0 state. */
+    MM_ReadConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, &Value32);
+    Value32 |= T3_PM_PME_ASSERTED;
+    Value32 &= ~T3_PM_POWER_STATE_MASK;
+    Value32 |= T3_PM_POWER_STATE_D0;
+    MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, Value32);
+
+    /* read the current PCI command word */
+    MM_ReadConfig32(pDevice, PCI_COMMAND_REG, &Value32);
+
+    /* Make sure bus-mastering is enabled. */
+    Value32 |= PCI_BUSMASTER_ENABLE;
+
+#if PCIX_TARGET_WORKAROUND
+	/* if we are in PCI-X mode, also make sure mem-mapping and SERR#/PERR#
+	   are enabled */
+        if (pDevice->EnablePciXFix == TRUE) {
+            Value32 |= (PCI_MEM_SPACE_ENABLE | PCI_SYSTEM_ERROR_ENABLE | 
+                        PCI_PARITY_ERROR_ENABLE);
+        }
+#endif
+
+    if(pDevice->EnableMWI)
+    {
+        Value32 |= PCI_MEMORY_WRITE_INVALIDATE;
+    }
+    else {
+        Value32 &= (~PCI_MEMORY_WRITE_INVALIDATE);
+    }
+
+    /* Error out if mem-mapping is NOT enabled for PCI systems */
+    if (!(Value32 | PCI_MEM_SPACE_ENABLE))
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* save the value we are going to write into the PCI command word */	
+    pDevice->PciCommandStatusWords = Value32;	
+
+    Status = MM_WriteConfig32(pDevice, PCI_COMMAND_REG, Value32);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Set power state to D0. */
+    LM_SetPowerState(pDevice, LM_POWER_STATE_D0);
+
+    /* Setup the mode registers. */
+    pDevice->MiscHostCtrl = 
+        MISC_HOST_CTRL_MASK_PCI_INT | 
+        MISC_HOST_CTRL_ENABLE_ENDIAN_WORD_SWAP | 
+#ifdef BIG_ENDIAN_HOST
+        MISC_HOST_CTRL_ENABLE_ENDIAN_BYTE_SWAP |  
+#endif /* BIG_ENDIAN_HOST */
+        MISC_HOST_CTRL_ENABLE_INDIRECT_ACCESS |
+        MISC_HOST_CTRL_ENABLE_PCI_STATE_REG_RW;
+	/* write to PCI misc host ctr first in order to enable indirect accesses */
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, pDevice->MiscHostCtrl);
+
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl);
+
+#ifdef BIG_ENDIAN_HOST
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+              GRC_MODE_WORD_SWAP_NON_FRAME_DATA;
+#else
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | GRC_MODE_BYTE_SWAP_DATA;
+#endif
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        REG_WR(pDevice, Grc.LocalCtrl, GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1 |
+            GRC_MISC_LOCAL_CTRL_GPIO_OE1);
+    }
+    MM_Wait(40);
+
+    /* Enable indirect memory access */
+    REG_WR(pDevice, MemArbiter.Mode, T3_MEM_ARBITER_MODE_ENABLE);
+
+    if (REG_RD(pDevice, PciCfg.ClockCtrl) & T3_PCI_44MHZ_CORE_CLOCK)
+    {
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_44MHZ_CORE_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK);
+        REG_WR(pDevice, PciCfg.ClockCtrl, T3_PCI_SELECT_ALTERNATE_CLOCK);
+        MM_Wait(40);  /* required delay is 27usec */
+    }
+    REG_WR(pDevice, PciCfg.ClockCtrl, 0);
+    REG_WR(pDevice, PciCfg.MemWindowBaseAddr, 0);
+
+#if PCIX_TARGET_WORKAROUND
+    MM_ReadConfig32(pDevice, T3_PCI_STATE_REG, &Value32);
+    if ((pDevice->EnablePciXFix == FALSE) &&
+        ((Value32 & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) == 0))
+    {
+        if (pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B2 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B5)
+        {
+            __raw_writel(0, &(pDevice->pMemView->uIntMem.MemBlock32K[0x300]));
+            __raw_writel(0, &(pDevice->pMemView->uIntMem.MemBlock32K[0x301]));
+            __raw_writel(0xffffffff, &(pDevice->pMemView->uIntMem.MemBlock32K[0x301]));
+            if (__raw_readl(&(pDevice->pMemView->uIntMem.MemBlock32K[0x300])))
+            {
+                pDevice->EnablePciXFix = TRUE;
+            }
+        }
+    }
+#endif
+    /* Get the node address.  First try to get in from the shared memory. */
+    /* If the signature is not present, then get it from the NVRAM. */
+    Value32 = MEM_RD_OFFSET(pDevice, T3_MAC_ADDR_HIGH_MAILBOX);
+    if((Value32 >> 16) == 0x484b)
+    {
+
+        pDevice->NodeAddress[0] = (LM_UINT8) (Value32 >> 8);
+        pDevice->NodeAddress[1] = (LM_UINT8) Value32;
+
+        Value32 = MEM_RD_OFFSET(pDevice, T3_MAC_ADDR_LOW_MAILBOX);
+
+        pDevice->NodeAddress[2] = (LM_UINT8) (Value32 >> 24);
+        pDevice->NodeAddress[3] = (LM_UINT8) (Value32 >> 16);
+        pDevice->NodeAddress[4] = (LM_UINT8) (Value32 >> 8);
+        pDevice->NodeAddress[5] = (LM_UINT8) Value32;
+
+        Status = LM_STATUS_SUCCESS;
+    }
+    else
+    {
+
+        MM_Wait(50);
+        LM_NvramInit(pDevice);
+
+        Status = LM_NvramRead(pDevice, 0x7c, &Value32);
+        if(Status == LM_STATUS_SUCCESS)
+        {
+            pDevice->NodeAddress[0] = (LM_UINT8) (Value32 >> 16);
+            pDevice->NodeAddress[1] = (LM_UINT8) (Value32 >> 24);
+
+            Status = LM_NvramRead(pDevice, 0x80, &Value32);
+
+            pDevice->NodeAddress[2] = (LM_UINT8) Value32;
+            pDevice->NodeAddress[3] = (LM_UINT8) (Value32 >> 8);
+            pDevice->NodeAddress[4] = (LM_UINT8) (Value32 >> 16);
+            pDevice->NodeAddress[5] = (LM_UINT8) (Value32 >> 24);
+        }
+    }
+
+    /* Assign a default address. */
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        printk(KERN_ERR "Cannot get MAC addr from NVRAM. Using default.\n");
+
+        pDevice->NodeAddress[0] = 0x00; pDevice->NodeAddress[1] = 0x10;
+        pDevice->NodeAddress[2] = 0x18; pDevice->NodeAddress[3] = 0x68;
+        pDevice->NodeAddress[4] = 0x61; pDevice->NodeAddress[5] = 0x76;
+    }
+
+    pDevice->PermanentNodeAddress[0] = pDevice->NodeAddress[0];
+    pDevice->PermanentNodeAddress[1] = pDevice->NodeAddress[1];
+    pDevice->PermanentNodeAddress[2] = pDevice->NodeAddress[2];
+    pDevice->PermanentNodeAddress[3] = pDevice->NodeAddress[3];
+    pDevice->PermanentNodeAddress[4] = pDevice->NodeAddress[4];
+    pDevice->PermanentNodeAddress[5] = pDevice->NodeAddress[5];
+
+    /* Initialize the default values. */
+    pDevice->NoTxPseudoHdrChksum = FALSE;
+    pDevice->NoRxPseudoHdrChksum = FALSE;
+    pDevice->NicSendBd = FALSE;
+    pDevice->TxPacketDescCnt = DEFAULT_TX_PACKET_DESC_COUNT;
+    pDevice->RxStdDescCnt = DEFAULT_STD_RCV_DESC_COUNT;
+    pDevice->RxCoalescingTicks = DEFAULT_RX_COALESCING_TICKS;
+    pDevice->TxCoalescingTicks = DEFAULT_TX_COALESCING_TICKS;
+    pDevice->RxMaxCoalescedFrames = DEFAULT_RX_MAX_COALESCED_FRAMES;
+    pDevice->TxMaxCoalescedFrames = DEFAULT_TX_MAX_COALESCED_FRAMES;
+    pDevice->RxCoalescingTicksDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->TxCoalescingTicksDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->RxMaxCoalescedFramesDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->TxMaxCoalescedFramesDuringInt = BAD_DEFAULT_VALUE;
+    pDevice->StatsCoalescingTicks = DEFAULT_STATS_COALESCING_TICKS;
+    pDevice->EnableMWI = FALSE;
+    pDevice->TxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    pDevice->DisableAutoNeg = FALSE;
+    pDevice->PhyIntMode = T3_PHY_INT_MODE_AUTO;
+    pDevice->LinkChngMode = T3_LINK_CHNG_MODE_AUTO;
+    pDevice->LedMode = LED_MODE_AUTO;
+    pDevice->ResetPhyOnInit = TRUE;
+    pDevice->DelayPciGrant = TRUE;
+    pDevice->UseTaggedStatus = FALSE;
+    pDevice->OneDmaAtOnce = BAD_DEFAULT_VALUE;
+
+    pDevice->DmaMbufLowMark = T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO;
+    pDevice->RxMacMbufLowMark = T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO;
+    pDevice->MbufHighMark = T3_DEF_MBUF_HIGH_WMARK_JUMBO;
+
+    pDevice->RequestedMediaType = LM_REQUESTED_MEDIA_TYPE_AUTO;
+    pDevice->TaskOffloadCap = LM_TASK_OFFLOAD_NONE;
+    pDevice->FlowControlCap = LM_FLOW_CONTROL_AUTO_PAUSE;
+    pDevice->EnableTbi = FALSE;
+#if INCLUDE_TBI_SUPPORT
+    pDevice->PollTbiLink = BAD_DEFAULT_VALUE;
+#endif
+
+    pDevice->MbufBase = T3_NIC_MBUF_POOL_ADDR;
+    pDevice->MbufSize = T3_NIC_MBUF_POOL_SIZE;
+
+    pDevice->LinkStatus = LM_STATUS_LINK_DOWN;
+    pDevice->QueueRxPackets = TRUE;
+
+    pDevice->EnableWireSpeed = TRUE;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    pDevice->RxJumboDescCnt = DEFAULT_JUMBO_RCV_DESC_COUNT;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Make this is a known adapter. */
+    pAdapterInfo = LM_GetAdapterInfoBySsid(pDevice->SubsystemVendorId,
+        pDevice->SubsystemId);
+
+    pDevice->BondId = REG_RD(pDevice, Grc.MiscCfg) & GRC_MISC_BD_ID_MASK;
+    if (pDevice->BondId != GRC_MISC_BD_ID_5700 &&
+        pDevice->BondId != GRC_MISC_BD_ID_5701 &&
+        pDevice->BondId != GRC_MISC_BD_ID_5702FE &&
+        pDevice->BondId != GRC_MISC_BD_ID_5703 &&
+        pDevice->BondId != GRC_MISC_BD_ID_5703S)
+    {
+        return LM_STATUS_UNKNOWN_ADAPTER;
+    }
+
+    /* Get Eeprom info. */
+    Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_SIG_ADDR);
+    if (Value32 == T3_NIC_DATA_SIG)
+    {
+        EeSigFound = TRUE;
+        Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_NIC_CFG_ADDR);
+
+        /* Determine PHY type. */
+        switch (Value32 & T3_NIC_CFG_PHY_TYPE_MASK)
+        {
+            case T3_NIC_CFG_PHY_TYPE_COPPER:
+                EePhyTypeSerdes = FALSE;
+                break;
+
+            case T3_NIC_CFG_PHY_TYPE_FIBER:
+                EePhyTypeSerdes = TRUE;
+                break;
+
+            default:
+                EePhyTypeSerdes = FALSE;
+                break;
+        }
+
+        /* Determine PHY led mode. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            switch(Value32 & T3_NIC_CFG_LED_MODE_MASK)
+            {
+                case T3_NIC_CFG_LED_MODE_TRIPLE_SPEED:
+                    EePhyLedMode = LED_MODE_THREE_LINK;
+                    break;
+
+                case T3_NIC_CFG_LED_MODE_LINK_SPEED:
+                    EePhyLedMode = LED_MODE_LINK10;
+                    break;
+
+                default:
+                    EePhyLedMode = LED_MODE_AUTO;
+                    break;
+            }
+        }
+        else
+        {
+            switch(Value32 & T3_NIC_CFG_LED_MODE_MASK)
+            {
+                case T3_NIC_CFG_LED_MODE_OPEN_DRAIN:
+                    EePhyLedMode = LED_MODE_OPEN_DRAIN;
+                    break;
+
+                case T3_NIC_CFG_LED_MODE_OUTPUT:
+                    EePhyLedMode = LED_MODE_OUTPUT;
+                    break;
+
+                default:
+                    EePhyLedMode = LED_MODE_AUTO;
+                    break;
+            }
+        }
+        if(pDevice->ChipRevId == T3_CHIP_ID_5703_A1 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5703_A2)
+        {
+            /* Enable EEPROM write protection. */
+            if(Value32 & T3_NIC_EEPROM_WP)
+            {
+                pDevice->EepromWp = TRUE;
+            }
+        }
+
+        /* Get the PHY Id. */
+        Value32 = MEM_RD_OFFSET(pDevice, T3_NIC_DATA_PHY_ID_ADDR);
+        if (Value32)
+        {
+            EePhyId = (((Value32 & T3_NIC_PHY_ID1_MASK) >> 16) &
+                PHY_ID1_OUI_MASK) << 10;
+
+            Value32 = Value32 & T3_NIC_PHY_ID2_MASK;
+
+            EePhyId |= ((Value32 & PHY_ID2_OUI_MASK) << 16) |
+              (Value32 & PHY_ID2_MODEL_MASK) | (Value32 & PHY_ID2_REV_MASK);
+        }
+        else
+        {
+            EePhyId = 0;
+        }
+    }
+    else
+    {
+        EeSigFound = FALSE;
+    }
+
+    /* Set the PHY address. */
+    pDevice->PhyAddr = PHY_DEVICE_ID;
+
+    /* Disable auto polling. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    MM_Wait(40);
+
+    /* Get the PHY id. */
+    LM_ReadPhy(pDevice, PHY_ID1_REG, &Value32);
+    pDevice->PhyId = (Value32 & PHY_ID1_OUI_MASK) << 10;
+
+    LM_ReadPhy(pDevice, PHY_ID2_REG, &Value32);
+    pDevice->PhyId |= ((Value32 & PHY_ID2_OUI_MASK) << 16) |
+      (Value32 & PHY_ID2_MODEL_MASK) | (Value32 & PHY_ID2_REV_MASK);
+
+    /* Set the EnableTbi flag to false if we have a copper PHY. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5401_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5411_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5701_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM5703_PHY_ID:
+            pDevice->EnableTbi = FALSE;
+            break;
+
+        case PHY_BCM8002_PHY_ID:
+            pDevice->EnableTbi = TRUE;
+            break;
+
+        default:
+
+            if (pAdapterInfo)
+            {
+                pDevice->PhyId = pAdapterInfo->PhyId;
+                pDevice->EnableTbi = pAdapterInfo->Serdes;
+            }
+            else if (EeSigFound)
+            {
+                pDevice->PhyId = EePhyId;
+                pDevice->EnableTbi = EePhyTypeSerdes;
+            }
+            break;
+    }
+
+    /* Bail out if we don't know the copper PHY id. */
+    if(UNKNOWN_PHY_ID(pDevice->PhyId) && !pDevice->EnableTbi)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5703)
+    {
+        if((pDevice->SavedCacheLineReg & 0xff00) < 0x4000)
+        {
+            pDevice->SavedCacheLineReg &= 0xffff00ff;
+            pDevice->SavedCacheLineReg |= 0x4000;
+        }
+    }
+    /* Change driver parameters. */
+    Status = MM_GetConfig(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+#if INCLUDE_5701_AX_FIX
+    if (pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+    {
+        pDevice->ResetPhyOnInit = TRUE;
+    }
+#endif
+
+    /* Save the current phy link status. */
+    if(!pDevice->EnableTbi)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        /* If we don't have link reset the PHY. */
+        if(!(Value32 & PHY_STATUS_LINK_PASS) || pDevice->ResetPhyOnInit)
+        {
+
+            LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_PHY_RESET);
+
+            for(j = 0; j < 100; j++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+                if(Value32 && !(Value32 & PHY_CTRL_PHY_RESET))
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+
+#if INCLUDE_5701_AX_FIX
+            /* 5701_AX_BX bug:  only advertises 10mb speed. */
+            if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+                pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+            {
+
+                Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD |
+                    PHY_AN_AD_10BASET_HALF | PHY_AN_AD_10BASET_FULL |
+                    PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+                Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+                LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+                pDevice->advertising = Value32;
+
+                Value32 = BCM540X_AN_AD_1000BASET_HALF | 
+                    BCM540X_AN_AD_1000BASET_FULL | BCM540X_CONFIG_AS_MASTER |
+                    BCM540X_ENABLE_CONFIG_AS_MASTER;
+                LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+                pDevice->advertising1000 = Value32;
+
+                LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_AUTO_NEG_ENABLE |
+                    PHY_CTRL_RESTART_AUTO_NEG);
+            }
+#endif
+            if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5703)
+            {
+                LM_WritePhy(pDevice, 0x18, 0x0c00);
+                LM_WritePhy(pDevice, 0x17, 0x201f);
+                LM_WritePhy(pDevice, 0x15, 0x2aaa);
+            }
+            /* Enable Ethernet@WireSpeed. */
+            if(pDevice->EnableWireSpeed)
+            {
+                LM_WritePhy(pDevice, 0x18, 0x7007);
+                LM_ReadPhy(pDevice, 0x18, &Value32);
+                LM_WritePhy(pDevice, 0x18, Value32 | BIT_15 | BIT_4);
+            }
+        }
+    }
+
+    /* Turn off tap power management. */
+    if((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+    {
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x0c20);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+        LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+        LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+
+        MM_Wait(40);
+    }
+
+#if INCLUDE_TBI_SUPPORT
+    if(pDevice->EnableTbi)
+    {
+        pDevice->WakeUpModeCap = LM_WAKE_UP_MODE_NONE;
+        pDevice->PhyIntMode = T3_PHY_INT_MODE_LINK_READY;
+        if ((pDevice->PollTbiLink == BAD_DEFAULT_VALUE) ||
+            pDevice->DisableAutoNeg)
+        {
+            pDevice->PollTbiLink = FALSE;
+        }
+    }
+    else
+    {
+        pDevice->PollTbiLink = FALSE;
+    }
+#endif /* INCLUDE_TBI_SUPPORT */
+
+    /* UseTaggedStatus is only valid for 5701 and later. */
+    if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        pDevice->UseTaggedStatus = FALSE;
+
+        pDevice->CoalesceMode = 0;
+    }
+    else
+    {
+        pDevice->CoalesceMode = HOST_COALESCE_CLEAR_TICKS_ON_RX_BD_EVENT |
+            HOST_COALESCE_CLEAR_TICKS_ON_TX_BD_EVENT;
+    }
+
+    /* Set the status block size. */
+    if(T3_CHIP_REV(pDevice->ChipRevId) != T3_CHIP_REV_5700_AX &&
+        T3_CHIP_REV(pDevice->ChipRevId) != T3_CHIP_REV_5700_BX)
+    {
+        pDevice->CoalesceMode |= HOST_COALESCE_32_BYTE_STATUS_MODE;
+    }
+
+    /* Check the DURING_INT coalescing ticks parameters. */
+    if(pDevice->UseTaggedStatus)
+    {
+        if(pDevice->RxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxCoalescingTicksDuringInt =
+                DEFAULT_RX_COALESCING_TICKS_DURING_INT;
+        }
+
+        if(pDevice->TxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxCoalescingTicksDuringInt =
+                DEFAULT_TX_COALESCING_TICKS_DURING_INT;
+        }
+
+        if(pDevice->RxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxMaxCoalescedFramesDuringInt =
+                DEFAULT_RX_MAX_COALESCED_FRAMES_DURING_INT;
+        }
+
+        if(pDevice->TxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxMaxCoalescedFramesDuringInt =
+                DEFAULT_TX_MAX_COALESCED_FRAMES_DURING_INT;
+        }
+    }
+    else
+    {
+        if(pDevice->RxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxCoalescingTicksDuringInt = 0;
+        }
+
+        if(pDevice->TxCoalescingTicksDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxCoalescingTicksDuringInt = 0;
+        }
+
+        if(pDevice->RxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->RxMaxCoalescedFramesDuringInt = 0;
+        }
+
+        if(pDevice->TxMaxCoalescedFramesDuringInt == BAD_DEFAULT_VALUE)
+        {
+            pDevice->TxMaxCoalescedFramesDuringInt = 0;
+        }
+    }
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    if(pDevice->RxMtu <= (MAX_STD_RCV_BUFFER_SIZE - 8 /* CRC */))
+    {
+        pDevice->RxJumboDescCnt = 0;
+        if(pDevice->RxMtu <= MAX_ETHERNET_PACKET_SIZE_NO_CRC)
+        {
+            pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+        }
+    }
+    else
+    {
+        pDevice->RxJumboBufferSize = (pDevice->RxMtu + 8 /* CRC + VLAN */ +
+            COMMON_CACHE_LINE_SIZE-1) & ~COMMON_CACHE_LINE_MASK;
+
+        if(pDevice->RxJumboBufferSize > MAX_JUMBO_RCV_BUFFER_SIZE)
+        {
+            pDevice->RxJumboBufferSize = DEFAULT_JUMBO_RCV_BUFFER_SIZE;
+            pDevice->RxMtu = pDevice->RxJumboBufferSize - 8 /* CRC + VLAN */;
+        }
+        pDevice->TxMtu = pDevice->RxMtu;
+
+    }
+#else
+    pDevice->RxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    pDevice->RxPacketDescCnt = 
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+        pDevice->RxJumboDescCnt +
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+        pDevice->RxStdDescCnt;
+
+    if(pDevice->TxMtu < MAX_ETHERNET_PACKET_SIZE_NO_CRC)
+    {
+        pDevice->TxMtu = MAX_ETHERNET_PACKET_SIZE_NO_CRC;
+    }
+
+    if(pDevice->TxMtu > MAX_JUMBO_TX_BUFFER_SIZE)
+    {
+        pDevice->TxMtu = MAX_JUMBO_TX_BUFFER_SIZE;
+    }
+
+    /* Configure the proper ways to get link change interrupt. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO)
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+        }
+        else
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_LINK_READY;
+        }
+    }
+    else if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        /* Auto-polling does not work on 5700_AX and 5700_BX. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+        }
+    }
+
+    /* Determine the method to get link change status. */
+    if(pDevice->LinkChngMode == T3_LINK_CHNG_MODE_AUTO)
+    {
+        /* The link status bit in the status block does not work on 5700_AX */
+        /* and 5700_BX chips. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+        }
+        else
+        {
+            pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_BLOCK;
+        }
+    }
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT ||
+        T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+    }
+
+    /* Configure PHY led mode. */
+    if(pDevice->LedMode == LED_MODE_AUTO)
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            if(pDevice->SubsystemVendorId == T3_SVID_DELL)
+            {
+                pDevice->LedMode = LED_MODE_LINK10;
+            }
+            else
+            {
+                pDevice->LedMode = LED_MODE_THREE_LINK;
+
+                if(EeSigFound && EePhyLedMode != LED_MODE_AUTO)
+                {
+                    pDevice->LedMode = EePhyLedMode;
+                }
+            }
+
+            /* bug? 5701 in LINK10 mode does not seem to work when */
+            /* PhyIntMode is LINK_READY. */
+            if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+#if INCLUDE_TBI_SUPPORT
+                pDevice->EnableTbi == FALSE &&
+#endif
+                pDevice->LedMode == LED_MODE_LINK10)
+            {
+                pDevice->PhyIntMode = T3_PHY_INT_MODE_MI_INTERRUPT;
+                pDevice->LinkChngMode = T3_LINK_CHNG_MODE_USE_STATUS_REG;
+            }
+
+            if(pDevice->EnableTbi)
+            {
+                pDevice->LedMode = LED_MODE_THREE_LINK;
+            }
+        }
+        else
+        {
+            if(EeSigFound && EePhyLedMode != LED_MODE_AUTO)
+            {
+                pDevice->LedMode = EePhyLedMode;
+            }
+            else
+            {
+                pDevice->LedMode = LED_MODE_OPEN_DRAIN;
+            }
+        }
+    }
+
+    /* Enable OneDmaAtOnce. */
+    if(pDevice->OneDmaAtOnce == BAD_DEFAULT_VALUE)
+    {
+        pDevice->OneDmaAtOnce = FALSE;
+    }
+
+    if (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B2)
+    {
+        pDevice->WolSpeed = WOL_SPEED_10MB;
+    }
+    else
+    {
+        pDevice->WolSpeed = WOL_SPEED_100MB;
+    }
+
+    /* Offloadings. */
+    pDevice->TaskToOffload = LM_TASK_OFFLOAD_NONE;
+
+    /* Turn off task offloading on Ax. */
+    if(pDevice->ChipRevId == T3_CHIP_ID_5700_B0)
+    {
+        pDevice->TaskOffloadCap &= ~(LM_TASK_OFFLOAD_TX_TCP_CHECKSUM |
+            LM_TASK_OFFLOAD_TX_UDP_CHECKSUM);
+    }
+    pDevice->PciState = REG_RD(pDevice, PciCfg.PciState);
+    LM_ReadVPD(pDevice);
+    LM_ReadBootCodeVersion(pDevice);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_GetAdapterInfo */
+
+STATIC PLM_ADAPTER_INFO
+LM_GetAdapterInfoBySsid(
+    LM_UINT16 Svid,
+    LM_UINT16 Ssid)
+{
+    static LM_ADAPTER_INFO AdapterArr[] =
+    {
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700A6, PHY_BCM5401_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A5, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700T6, PHY_BCM8002_PHY_ID, 1},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95700A9, 0, 1 },
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701T1, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701T8, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A7, 0, 1},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A10, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95701A12, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95703Ax1, PHY_BCM5701_PHY_ID, 0},
+        { T3_SVID_BROADCOM, T3_SSID_BROADCOM_BCM95703Ax2, PHY_BCM5701_PHY_ID, 0},
+
+        { T3_SVID_3COM, T3_SSID_3COM_3C996T, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C996BT, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C996SX, 0, 1 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C1000T, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_3COM, T3_SSID_3COM_3C940BR01, PHY_BCM5701_PHY_ID, 0 },
+
+        { T3_SVID_DELL, T3_SSID_DELL_VIPER, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_JAGUAR, PHY_BCM5401_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_MERLOT, PHY_BCM5411_PHY_ID, 0 },
+        { T3_SVID_DELL, T3_SSID_DELL_SLIM_MERLOT, PHY_BCM5411_PHY_ID, 0 },
+
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_BANSHEE, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_BANSHEE_2, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_CHANGELING, 0, 1 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_NC7780, PHY_BCM5701_PHY_ID, 0 },
+        { T3_SVID_COMPAQ, T3_SSID_COMPAQ_NC7780_2, PHY_BCM5701_PHY_ID, 0 },
+
+    };
+    LM_UINT32 j;
+
+    for(j = 0; j < sizeof(AdapterArr)/sizeof(LM_ADAPTER_INFO); j++)
+    {
+        if(AdapterArr[j].Svid == Svid && AdapterArr[j].Ssid == Ssid)
+        {
+            return &AdapterArr[j];
+        }
+    }
+
+    return NULL;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine sets up receive/transmit buffer descriptions queues.       */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_InitializeAdapter(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_PHYSICAL_ADDRESS MemPhy;
+    PLM_UINT8 pMemVirt;
+    PLM_PACKET pPacket;
+    LM_STATUS Status;
+    LM_UINT32 Size;
+    LM_UINT32 j;
+
+    /* Set power state to D0. */
+    LM_SetPowerState(pDevice, LM_POWER_STATE_D0);
+
+    /* Intialize the queues. */
+    QQ_InitQueue(&pDevice->RxPacketReceivedQ.Container, 
+        MAX_RX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->RxPacketFreeQ.Container,
+        MAX_RX_PACKET_DESC_COUNT);
+
+    QQ_InitQueue(&pDevice->TxPacketFreeQ.Container,MAX_TX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->TxPacketActiveQ.Container,MAX_TX_PACKET_DESC_COUNT);
+    QQ_InitQueue(&pDevice->TxPacketXmittedQ.Container,MAX_TX_PACKET_DESC_COUNT);
+
+    /* Allocate shared memory for: status block, the buffers for receive */
+    /* rings -- standard, mini, jumbo, and return rings. */
+    Size = T3_STATUS_BLOCK_SIZE + sizeof(T3_STATS_BLOCK) +
+        T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD) +
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+        T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD) +
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+        T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+
+    /* Memory for host based Send BD. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        Size += sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT;
+    }
+
+    /* Allocate the memory block. */
+    Status = MM_AllocateSharedMemory(pDevice, Size, (PLM_VOID) &pMemVirt, &MemPhy, FALSE);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* Program DMA Read/Write */
+    if (pDevice->PciState & T3_PCI_STATE_NOT_PCI_X_BUS)
+    {
+        pDevice->DmaReadWriteCtrl = 0x763f000f;    
+    }
+    else
+    {
+        pDevice->DmaReadWriteCtrl = 0x761b000f;    
+        if(pDevice->ChipRevId == T3_CHIP_ID_5703_A1 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5703_A2)
+        {
+            pDevice->OneDmaAtOnce = TRUE;
+        }
+    }
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5703)
+    {
+        pDevice->DmaReadWriteCtrl &= 0xfffffff0;
+    }
+
+    if(pDevice->OneDmaAtOnce)
+    {
+        pDevice->DmaReadWriteCtrl |= DMA_CTRL_WRITE_ONE_DMA_AT_ONCE;
+    }
+    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl, pDevice->DmaReadWriteCtrl);
+
+    if (LM_DmaTest(pDevice, pMemVirt, MemPhy, 0x400) != LM_STATUS_SUCCESS)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Status block. */
+    pDevice->pStatusBlkVirt = (PT3_STATUS_BLOCK) pMemVirt;
+    pDevice->StatusBlkPhy = MemPhy;
+    pMemVirt += T3_STATUS_BLOCK_SIZE;
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, T3_STATUS_BLOCK_SIZE);
+
+    /* Statistics block. */
+    pDevice->pStatsBlkVirt = (PT3_STATS_BLOCK) pMemVirt;
+    pDevice->StatsBlkPhy = MemPhy;
+    pMemVirt += sizeof(T3_STATS_BLOCK);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, sizeof(T3_STATS_BLOCK));
+
+    /* Receive standard BD buffer. */
+    pDevice->pRxStdBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RxStdBdPhy = MemPhy;
+
+    pMemVirt += T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_STD_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Receive jumbo BD buffer. */
+    pDevice->pRxJumboBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RxJumboBdPhy = MemPhy;
+
+    pMemVirt += T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_JUMBO_RCV_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Receive return BD buffer. */
+    pDevice->pRcvRetBdVirt = (PT3_RCV_BD) pMemVirt;
+    pDevice->RcvRetBdPhy = MemPhy;
+
+    pMemVirt += T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD);
+    LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+        T3_RCV_RETURN_RCB_ENTRY_COUNT * sizeof(T3_RCV_BD));
+
+    /* Set up Send BD. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        pDevice->pSendBdVirt = (PT3_SND_BD) pMemVirt;
+        pDevice->SendBdPhy = MemPhy;
+
+        pMemVirt += sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT;
+        LM_INC_PHYSICAL_ADDRESS(&MemPhy, 
+            sizeof(T3_SND_BD) * T3_SEND_RCB_ENTRY_COUNT);
+    }
+    else
+    {
+        pDevice->pSendBdVirt = (PT3_SND_BD)
+            pDevice->pMemView->uIntMem.First32k.BufferDesc;
+        pDevice->SendBdPhy.High = 0;
+        pDevice->SendBdPhy.Low = T3_NIC_SND_BUFFER_DESC_ADDR;
+    }
+
+    /* Allocate memory for packet descriptors. */
+    Size = (pDevice->RxPacketDescCnt + 
+        pDevice->TxPacketDescCnt) * MM_PACKET_DESC_SIZE;
+    Status = MM_AllocateMemory(pDevice, Size, (PLM_VOID *) &pPacket);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+    pDevice->pPacketDescBase = (PLM_VOID) pPacket;
+
+    /* Create transmit packet descriptors from the memory block and add them */
+    /* to the TxPacketFreeQ for each send ring. */
+    for(j = 0; j < pDevice->TxPacketDescCnt; j++)
+    {
+        /* Ring index. */
+        pPacket->Flags = 0;
+
+        /* Queue the descriptor in the TxPacketFreeQ of the 'k' ring. */
+        QQ_PushTail(&pDevice->TxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for(j.. */
+
+    /* Create receive packet descriptors from the memory block and add them */
+    /* to the RxPacketFreeQ.  Create the Standard packet descriptors. */
+    for(j = 0; j < pDevice->RxStdDescCnt; j++)
+    {
+        /* Receive producer ring. */
+        pPacket->u.Rx.RcvProdRing = T3_STD_RCV_PROD_RING;
+
+        /* Receive buffer size. */
+        pPacket->u.Rx.RxBufferSize = MAX_STD_RCV_BUFFER_SIZE;
+
+        /* Add the descriptor to RxPacketFreeQ. */
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for */
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Create the Jumbo packet descriptors. */
+    for(j = 0; j < pDevice->RxJumboDescCnt; j++)
+    {
+        /* Receive producer ring. */
+        pPacket->u.Rx.RcvProdRing = T3_JUMBO_RCV_PROD_RING;
+
+        /* Receive buffer size. */
+        pPacket->u.Rx.RxBufferSize = pDevice->RxJumboBufferSize;
+
+        /* Add the descriptor to RxPacketFreeQ. */
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        /* Get the pointer to the next descriptor.  MM_PACKET_DESC_SIZE */
+        /* is the total size of the packet descriptor including the */
+        /* os-specific extensions in the UM_PACKET structure. */
+        pPacket = (PLM_PACKET) ((PLM_UINT8) pPacket + MM_PACKET_DESC_SIZE);
+    } /* for */
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Initialize the rest of the packet descriptors. */
+    Status = MM_InitializeUmPackets(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    } /* if */
+
+    /* Default receive mask. */
+    pDevice->ReceiveMask = LM_ACCEPT_MULTICAST | LM_ACCEPT_BROADCAST |
+        LM_ACCEPT_UNICAST;
+
+    /* Make sure we are in the first 32k memory window or NicSendBd. */
+    REG_WR(pDevice, PciCfg.MemWindowBaseAddr, 0);
+
+    /* Initialize the hardware. */
+    Status = LM_ResetAdapter(pDevice);
+    if(Status != LM_STATUS_SUCCESS)
+    {
+        return Status;
+    }
+
+    /* We are done with initialization. */
+    pDevice->InitDone = TRUE;
+
+    return LM_STATUS_SUCCESS;
+} /* LM_InitializeAdapter */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This function Enables/Disables a given block.                          */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_CntrlBlock(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 mask,LM_UINT32 cntrl)
+{
+    LM_UINT32 j,i,data;
+    LM_UINT32 MaxWaitCnt;
+
+    MaxWaitCnt = 2;
+    j = 0;
+
+    for(i = 0 ; i < 32; i++) 
+    {
+        if(!(mask & (1 << i)))
+            continue;     
+ 
+        switch (1 << i) 
+        {
+            case T3_BLOCK_DMA_RD:
+                data = REG_RD(pDevice, DmaRead.Mode);
+                if (cntrl == LM_DISABLE) 
+                {
+                    data &= ~DMA_READ_MODE_ENABLE;
+                    REG_WR(pDevice, DmaRead.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaRead.Mode) & DMA_READ_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else 
+                    REG_WR(pDevice, DmaRead.Mode, data | DMA_READ_MODE_ENABLE);
+                break;
+  
+            case T3_BLOCK_DMA_COMP:
+                data = REG_RD(pDevice,DmaComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~DMA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, DmaComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaComp.Mode) & DMA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, DmaComp.Mode, data | DMA_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_BD_INITIATOR:
+                data = REG_RD(pDevice, RcvBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, RcvBdIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvBdIn.Mode) & RCV_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }              
+                }
+                else
+                    REG_WR(pDevice, RcvBdIn.Mode,data | RCV_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_BD_COMP:
+                data = REG_RD(pDevice, RcvBdComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_BD_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, RcvBdComp.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvBdComp.Mode) & RCV_BD_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, RcvBdComp.Mode,data | RCV_BD_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_DMA_WR:
+                data = REG_RD(pDevice, DmaWrite.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~DMA_WRITE_MODE_ENABLE;
+                    REG_WR(pDevice, DmaWrite.Mode,data);
+
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, DmaWrite.Mode) & DMA_WRITE_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, DmaWrite.Mode,data | DMA_WRITE_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MSI_HANDLER:
+                data = REG_RD(pDevice, Msi.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~MSI_MODE_ENABLE;
+                    REG_WR(pDevice, Msi.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, Msi.Mode) & MSI_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, Msi.Mode, data |MSI_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_LIST_PLMT:
+                data = REG_RD(pDevice, RcvListPlmt.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_LIST_PLMT_MODE_ENABLE;
+                    REG_WR(pDevice, RcvListPlmt.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvListPlmt.Mode) & RCV_LIST_PLMT_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, RcvListPlmt.Mode,data | RCV_LIST_PLMT_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_LIST_SELECTOR:
+                data = REG_RD(pDevice, RcvListSel.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_LIST_SEL_MODE_ENABLE;
+                    REG_WR(pDevice, RcvListSel.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvListSel.Mode) & RCV_LIST_SEL_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, RcvListSel.Mode,data |RCV_LIST_SEL_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_DATA_INITIATOR:
+                data = REG_RD(pDevice, RcvDataBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_DATA_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, RcvDataBdIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvDataBdIn.Mode) & RCV_DATA_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }      
+                }
+                else
+                    REG_WR(pDevice, RcvDataBdIn.Mode, data | RCV_DATA_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_RX_DATA_COMP:
+                data = REG_RD(pDevice, RcvDataComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~RCV_DATA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, RcvDataComp.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, RcvDataBdIn.Mode) & RCV_DATA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }        
+                }
+                else
+                    REG_WR(pDevice, RcvDataComp.Mode,data | RCV_DATA_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_HOST_COALESING:
+                data = REG_RD(pDevice, HostCoalesce.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~HOST_COALESCE_ENABLE;
+                    REG_WR(pDevice, HostCoalesce.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdIn.Mode) & HOST_COALESCE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, HostCoalesce.Mode, data | HOST_COALESCE_ENABLE);
+                break;
+
+            case T3_BLOCK_MAC_RX_ENGINE:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->RxMode &= ~RX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MacCtrl.RxMode) & RX_MODE_ENABLE))
+                        {
+                            break;
+                        }
+                        MM_Wait(10);
+                    }
+                }
+                else
+                {
+                    pDevice->RxMode |= RX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+                }
+                break;
+
+            case T3_BLOCK_MBUF_CLUSTER_FREE:
+                data = REG_RD(pDevice, MbufClusterFree.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~MBUF_CLUSTER_FREE_MODE_ENABLE;
+                    REG_WR(pDevice, MbufClusterFree.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MbufClusterFree.Mode) & MBUF_CLUSTER_FREE_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }     
+                }
+                else
+                    REG_WR(pDevice, MbufClusterFree.Mode, data | MBUF_CLUSTER_FREE_MODE_ENABLE);         
+                break;
+
+            case T3_BLOCK_SEND_BD_INITIATOR:
+                data = REG_RD(pDevice, SndBdIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_IN_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdIn.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdIn.Mode) & SND_BD_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdIn.Mode, data  | SND_BD_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_BD_COMP:
+                data = REG_RD(pDevice, SndBdComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdComp.Mode) & SND_BD_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdComp.Mode, data | SND_BD_COMP_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_BD_SELECTOR:
+                data = REG_RD(pDevice, SndBdSel.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_BD_SEL_MODE_ENABLE;
+                    REG_WR(pDevice, SndBdSel.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndBdSel.Mode) & SND_BD_SEL_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndBdSel.Mode, data | SND_BD_SEL_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_DATA_INITIATOR:
+                data = REG_RD(pDevice, SndDataIn.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~T3_SND_DATA_IN_MODE_ENABLE;
+                    REG_WR(pDevice, SndDataIn.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndDataIn.Mode) & T3_SND_DATA_IN_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndDataIn.Mode,data | T3_SND_DATA_IN_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_SEND_DATA_COMP:
+                data = REG_RD(pDevice, SndDataComp.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~SND_DATA_COMP_MODE_ENABLE;
+                    REG_WR(pDevice, SndDataComp.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, SndDataComp.Mode) & SND_DATA_COMP_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, SndDataComp.Mode,data | SND_DATA_COMP_MODE_ENABLE);
+                break;
+               
+            case T3_BLOCK_MAC_TX_ENGINE:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->TxMode &= ~TX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MacCtrl.TxMode) & TX_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else  
+                {
+                    pDevice->TxMode |= TX_MODE_ENABLE;
+                    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+                }
+                break;
+
+            case T3_BLOCK_MEM_ARBITOR:
+                data = REG_RD(pDevice, MemArbiter.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~T3_MEM_ARBITER_MODE_ENABLE;
+                    REG_WR(pDevice, MemArbiter.Mode, data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, MemArbiter.Mode) & T3_MEM_ARBITER_MODE_ENABLE)) 
+                            break;
+                        MM_Wait(10);
+                    }       
+                }
+                else
+                    REG_WR(pDevice, MemArbiter.Mode,data|T3_MEM_ARBITER_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MBUF_MANAGER:
+                data = REG_RD(pDevice, BufMgr.Mode);
+                if (cntrl == LM_DISABLE)
+                {
+                    data &= ~BUFMGR_MODE_ENABLE;
+                    REG_WR(pDevice, BufMgr.Mode,data);
+                    for(j = 0; j < MaxWaitCnt; j++) 
+                    {
+                        if(!(REG_RD(pDevice, BufMgr.Mode) & BUFMGR_MODE_ENABLE))
+                            break;
+                        MM_Wait(10);
+                    }
+                }
+                else
+                    REG_WR(pDevice, BufMgr.Mode,data |  BUFMGR_MODE_ENABLE);
+                break;
+
+            case T3_BLOCK_MAC_GLOBAL:
+                if(cntrl == LM_DISABLE)
+                {
+                    pDevice->MacMode &= ~(MAC_MODE_ENABLE_TDE |
+                        MAC_MODE_ENABLE_RDE |
+                        MAC_MODE_ENABLE_FHDE);
+                }
+                else
+                {
+                    pDevice->MacMode |= (MAC_MODE_ENABLE_TDE |
+                        MAC_MODE_ENABLE_RDE |
+                        MAC_MODE_ENABLE_FHDE);
+                }
+                REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+                break;
+
+            default:
+                return LM_STATUS_FAILURE;
+        } /* switch */
+
+        if(j >= MaxWaitCnt) 
+        {
+            return LM_STATUS_FAILURE;
+        }
+    } 
+
+    return LM_STATUS_SUCCESS;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This function reinitializes the adapter.                                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_ResetAdapter(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j, k;
+
+    /* Disable interrupt. */
+    LM_DisableInterrupt(pDevice);
+
+    /* May get a spurious interrupt */
+    pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED;
+
+    /* Disable transmit and receive DMA engines.  Abort all pending requests. */
+    if(pDevice->InitDone)
+    {
+        LM_Abort(pDevice);
+    }
+
+    pDevice->ShuttingDown = FALSE;
+
+    LM_ResetChip(pDevice);
+
+    /* Bug: Athlon fix for B3 silicon only.  This bit does not do anything */
+    /* in other chip revisions. */
+    if(pDevice->DelayPciGrant)
+    {
+        Value32 = REG_RD(pDevice, PciCfg.ClockCtrl);
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32 | BIT_31);
+    }
+
+    /* Enable TaggedStatus mode. */
+    if(pDevice->UseTaggedStatus)
+    {
+        pDevice->MiscHostCtrl |= MISC_HOST_CTRL_ENABLE_TAGGED_STATUS_MODE;
+    }
+
+    /* Restore PCI configuration registers. */
+    MM_WriteConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG,
+        pDevice->SavedCacheLineReg);
+//    LM_RegWrInd(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+//        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+    MM_WriteConfig32(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+
+    /* Clear the statistics block. */
+    for(j = 0x0300; j < 0x0b00; j++)
+    {
+        MEM_WR_OFFSET(pDevice, j, 0);
+    }
+
+    /* Initialize the statistis Block */
+    pDevice->pStatusBlkVirt->Status = 0;
+    pDevice->pStatusBlkVirt->RcvStdConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvJumboConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvMiniConIdx = 0;
+
+    for(j = 0; j < 16; j++)
+    {
+       pDevice->pStatusBlkVirt->Idx[j].RcvProdIdx = 0;
+       pDevice->pStatusBlkVirt->Idx[j].SendConIdx = 0;
+    }
+
+    for(k = 0; k < T3_STD_RCV_RCB_ENTRY_COUNT ;k++)
+    {
+       pDevice->pRxStdBdVirt[k].HostAddr.High = 0;
+       pDevice->pRxStdBdVirt[k].HostAddr.Low = 0;
+    }
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Receive jumbo BD buffer. */
+    for(k = 0; k < T3_JUMBO_RCV_RCB_ENTRY_COUNT; k++)
+    {
+        pDevice->pRxJumboBdVirt[k].HostAddr.High = 0;
+        pDevice->pRxJumboBdVirt[k].HostAddr.Low = 0;
+    }
+#endif
+
+    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl, pDevice->DmaReadWriteCtrl);    
+
+    /* GRC mode control register. */
+    Value32 = 
+#ifdef BIG_ENDIAN_HOST
+        GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+        GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+        GRC_MODE_BYTE_SWAP_DATA |
+        GRC_MODE_WORD_SWAP_DATA |
+#else
+        GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+        GRC_MODE_BYTE_SWAP_DATA |
+        GRC_MODE_WORD_SWAP_DATA |
+#endif
+        GRC_MODE_INT_ON_MAC_ATTN |
+        GRC_MODE_HOST_STACK_UP;
+
+    /* Configure send BD mode. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        Value32 |= GRC_MODE_HOST_SEND_BDS;
+    }
+    else
+    {
+        Value32 |= GRC_MODE_4X_NIC_BASED_SEND_RINGS;
+    }
+
+    /* Configure pseudo checksum mode. */
+    if(pDevice->NoTxPseudoHdrChksum)
+    {
+        Value32 |= GRC_MODE_TX_NO_PSEUDO_HEADER_CHKSUM;
+    }
+
+    if(pDevice->NoRxPseudoHdrChksum)
+    {
+        Value32 |= GRC_MODE_RX_NO_PSEUDO_HEADER_CHKSUM;
+    }
+
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    /* Setup the timer prescalar register. */
+    REG_WR(pDevice, Grc.MiscCfg, 65 << 1);      /* Clock is alwasy 66Mhz. */
+
+    /* Set up the MBUF pool base address and size. */
+    REG_WR(pDevice, BufMgr.MbufPoolAddr, pDevice->MbufBase);
+    REG_WR(pDevice, BufMgr.MbufPoolSize, pDevice->MbufSize);
+
+    /* Set up the DMA descriptor pool base address and size. */
+    REG_WR(pDevice, BufMgr.DmaDescPoolAddr, T3_NIC_DMA_DESC_POOL_ADDR);
+    REG_WR(pDevice, BufMgr.DmaDescPoolSize, T3_NIC_DMA_DESC_POOL_SIZE);
+    
+    /* Configure MBUF and Threshold watermarks */
+    /* Configure the DMA read MBUF low water mark. */
+    if(pDevice->DmaMbufLowMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark, 
+            pDevice->DmaMbufLowMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark,
+                T3_DEF_DMA_MBUF_LOW_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufReadDmaLowWaterMark,
+                T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO);
+        }
+    }
+
+    /* Configure the MAC Rx MBUF low water mark. */
+    if(pDevice->RxMacMbufLowMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+            pDevice->RxMacMbufLowMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+                T3_DEF_RX_MAC_MBUF_LOW_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufMacRxLowWaterMark,
+                T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO);
+        }
+    }
+
+    /* Configure the MBUF high water mark. */
+    if(pDevice->MbufHighMark)
+    {
+        REG_WR(pDevice, BufMgr.MbufHighWaterMark, pDevice->MbufHighMark);
+    }
+    else
+    {
+        if(pDevice->TxMtu < MAX_ETHERNET_PACKET_BUFFER_SIZE)
+        {
+            REG_WR(pDevice, BufMgr.MbufHighWaterMark,
+                T3_DEF_MBUF_HIGH_WMARK);
+        }
+        else
+        {
+            REG_WR(pDevice, BufMgr.MbufHighWaterMark,
+                T3_DEF_MBUF_HIGH_WMARK_JUMBO);
+        }
+    }
+
+    REG_WR(pDevice, BufMgr.DmaLowWaterMark, T3_DEF_DMA_DESC_LOW_WMARK);
+    REG_WR(pDevice, BufMgr.DmaHighWaterMark, T3_DEF_DMA_DESC_HIGH_WMARK);
+
+    /* Enable buffer manager. */
+    REG_WR(pDevice, BufMgr.Mode, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE);
+
+    for(j = 0 ;j < 2000; j++)
+    {
+        if(REG_RD(pDevice, BufMgr.Mode) & BUFMGR_MODE_ENABLE)
+            break;
+        MM_Wait(10);
+    }
+
+    if(j >= 2000)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Enable the FTQs. */
+    REG_WR(pDevice, Ftq.Reset, 0xffffffff);
+    REG_WR(pDevice, Ftq.Reset, 0);
+
+    /* Wait until FTQ is ready */
+    for(j = 0; j < 2000; j++)
+    {
+        if(REG_RD(pDevice, Ftq.Reset) == 0)
+            break;
+        MM_Wait(10);
+    }
+
+    if(j >= 2000)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Initialize the Standard Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.HostRingAddr.High, 
+        pDevice->RxStdBdPhy.High);
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.HostRingAddr.Low, 
+        pDevice->RxStdBdPhy.Low);
+    REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.u.MaxLen_Flags,
+        MAX_STD_RCV_BUFFER_SIZE << 16);
+
+    /* Initialize the Jumbo Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.u.MaxLen_Flags,
+        T3_RCB_FLAG_RING_DISABLED);
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.HostRingAddr.High, 
+        pDevice->RxJumboBdPhy.High);
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.HostRingAddr.Low, 
+        pDevice->RxJumboBdPhy.Low);
+
+    REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.u.MaxLen_Flags, 0);
+
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Initialize the Mini Receive RCB. */
+    REG_WR(pDevice, RcvDataBdIn.MiniRcvRcb.u.MaxLen_Flags,
+        T3_RCB_FLAG_RING_DISABLED);
+
+    {
+        REG_WR(pDevice, RcvDataBdIn.StdRcvRcb.NicRingAddr,
+            (LM_UINT32) T3_NIC_STD_RCV_BUFFER_DESC_ADDR);
+        REG_WR(pDevice, RcvDataBdIn.JumboRcvRcb.NicRingAddr,
+            (LM_UINT32) T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR);
+    }
+
+    /* Receive BD Ring replenish threshold. */
+    REG_WR(pDevice, RcvBdIn.StdRcvThreshold, pDevice->RxStdDescCnt/8);
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    REG_WR(pDevice, RcvBdIn.JumboRcvThreshold, pDevice->RxJumboDescCnt/8);
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* Disable all the unused rings. */
+    for(j = 0; j < T3_MAX_SEND_RCB_COUNT; j++) {
+        MEM_WR(pDevice, SendRcb[j].u.MaxLen_Flags, T3_RCB_FLAG_RING_DISABLED);
+    } /* for */
+
+    /* Initialize the indices. */
+    pDevice->SendProdIdx = 0;
+    pDevice->SendConIdx = 0;
+
+    REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, 0); 
+    REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, 0);
+
+    /* Set up host or NIC based send RCB. */
+    if(pDevice->NicSendBd == FALSE)
+    {
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.High, 
+            pDevice->SendBdPhy.High);
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.Low, 
+            pDevice->SendBdPhy.Low);
+
+        /* Set up the NIC ring address in the RCB. */
+        MEM_WR(pDevice, SendRcb[0].NicRingAddr,T3_NIC_SND_BUFFER_DESC_ADDR);
+
+        /* Setup the RCB. */
+        MEM_WR(pDevice, SendRcb[0].u.MaxLen_Flags,
+            T3_SEND_RCB_ENTRY_COUNT << 16);
+
+        for(k = 0; k < T3_SEND_RCB_ENTRY_COUNT; k++)
+        {
+            pDevice->pSendBdVirt[k].HostAddr.High = 0;
+            pDevice->pSendBdVirt[k].HostAddr.Low = 0;
+        }
+    }
+    else
+    {
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.High, 0);
+        MEM_WR(pDevice, SendRcb[0].HostRingAddr.Low, 0);
+        MEM_WR(pDevice, SendRcb[0].NicRingAddr,
+            pDevice->SendBdPhy.Low);
+
+        for(k = 0; k < T3_SEND_RCB_ENTRY_COUNT; k++)
+        {
+            __raw_writel(0, &(pDevice->pSendBdVirt[k].HostAddr.High));
+            __raw_writel(0, &(pDevice->pSendBdVirt[k].HostAddr.Low));
+            __raw_writel(0, &(pDevice->pSendBdVirt[k].u1.Len_Flags));
+            pDevice->ShadowSendBd[k].HostAddr.High = 0;
+            pDevice->ShadowSendBd[k].u1.Len_Flags = 0;
+        }
+    }
+    atomic_set(&pDevice->SendBdLeft, T3_SEND_RCB_ENTRY_COUNT-1);
+
+    /* Configure the receive return rings. */
+    for(j = 0; j < T3_MAX_RCV_RETURN_RCB_COUNT; j++)
+    {
+        MEM_WR(pDevice, RcvRetRcb[j].u.MaxLen_Flags, T3_RCB_FLAG_RING_DISABLED);
+    }
+
+    pDevice->RcvRetConIdx = 0;
+
+    MEM_WR(pDevice, RcvRetRcb[0].HostRingAddr.High, 
+        pDevice->RcvRetBdPhy.High);
+    MEM_WR(pDevice, RcvRetRcb[0].HostRingAddr.Low,
+        pDevice->RcvRetBdPhy.Low);
+
+    /* Set up the NIC ring address in the RCB. */
+    /* Not very clear from the spec.  I am guessing that for Receive */
+    /* Return Ring, NicRingAddr is not used. */
+    MEM_WR(pDevice, RcvRetRcb[0].NicRingAddr, 0);
+
+    /* Setup the RCB. */
+    MEM_WR(pDevice, RcvRetRcb[0].u.MaxLen_Flags,
+        T3_RCV_RETURN_RCB_ENTRY_COUNT << 16);
+
+    /* Reinitialize RX ring producer index */
+    REG_WR(pDevice, Mailbox.RcvStdProdIdx.Low, 0);
+    REG_WR(pDevice, Mailbox.RcvJumboProdIdx.Low, 0);
+    REG_WR(pDevice, Mailbox.RcvMiniProdIdx.Low, 0);
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    pDevice->RxJumboProdIdx = 0;
+    pDevice->RxJumboQueuedCnt = 0;
+#endif
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxStdProdIdx = 0;
+    pDevice->RxStdQueuedCnt = 0;
+
+#if T3_JUMBO_RCV_ENTRY_COUNT
+    pDevice->RxJumboProdIdx = 0;
+#endif /* T3_JUMBO_RCV_ENTRY_COUNT */
+
+    /* Configure the MAC address. */
+    LM_SetMacAddress(pDevice, pDevice->NodeAddress);
+
+    /* Initialize the transmit random backoff seed. */
+    Value32 = (pDevice->NodeAddress[0] + pDevice->NodeAddress[1] + 
+        pDevice->NodeAddress[2] + pDevice->NodeAddress[3] + 
+        pDevice->NodeAddress[4] + pDevice->NodeAddress[5]) & 
+        MAC_TX_BACKOFF_SEED_MASK;
+    REG_WR(pDevice, MacCtrl.TxBackoffSeed, Value32);
+
+    /* Receive MTU.  Frames larger than the MTU is marked as oversized. */
+    REG_WR(pDevice, MacCtrl.MtuSize, pDevice->RxMtu + 8);   /* CRC + VLAN. */
+
+    /* Configure Time slot/IPG per 802.3 */
+    REG_WR(pDevice, MacCtrl.TxLengths, 0x2620);
+
+    /*
+     * Configure Receive Rules so that packets don't match 
+     * Programmble rule will be queued to Return Ring 1 
+     */
+    REG_WR(pDevice, MacCtrl.RcvRuleCfg, RX_RULE_DEFAULT_CLASS);
+
+    /* 
+     * Configure to have 16 Classes of Services (COS) and one
+     * queue per class.  Bad frames are queued to RRR#1.
+     * And frames don't match rules are also queued to COS#1.
+     */
+    REG_WR(pDevice, RcvListPlmt.Config, 0x181);
+    
+    /* Enable Receive Placement Statistics */
+    REG_WR(pDevice, RcvListPlmt.StatsEnableMask,0xffffff);
+    REG_WR(pDevice, RcvListPlmt.StatsCtrl, RCV_LIST_STATS_ENABLE);
+
+    /* Enable Send Data Initator Statistics */
+    REG_WR(pDevice, SndDataIn.StatsEnableMask,0xffffff);
+    REG_WR(pDevice, SndDataIn.StatsCtrl,
+        T3_SND_DATA_IN_STATS_CTRL_ENABLE | \
+        T3_SND_DATA_IN_STATS_CTRL_FASTER_UPDATE);
+
+    /* Disable the host coalescing state machine before configuring it's */
+    /* parameters. */
+    REG_WR(pDevice, HostCoalesce.Mode, 0); 
+    for(j = 0; j < 2000; j++)
+    {
+        Value32 = REG_RD(pDevice, HostCoalesce.Mode);
+        if(!(Value32 & HOST_COALESCE_ENABLE))
+        {
+            break;
+        }
+        MM_Wait(10);
+    }
+
+    /* Host coalescing configurations. */
+    REG_WR(pDevice, HostCoalesce.RxCoalescingTicks, pDevice->RxCoalescingTicks);
+    REG_WR(pDevice, HostCoalesce.TxCoalescingTicks, pDevice->TxCoalescingTicks);
+    REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFrames,
+        pDevice->RxMaxCoalescedFrames);
+    REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFrames,
+        pDevice->TxMaxCoalescedFrames);
+    REG_WR(pDevice, HostCoalesce.RxCoalescedTickDuringInt,
+        pDevice->RxCoalescingTicksDuringInt);
+    REG_WR(pDevice, HostCoalesce.TxCoalescedTickDuringInt,
+        pDevice->TxCoalescingTicksDuringInt);
+    REG_WR(pDevice, HostCoalesce.RxMaxCoalescedFramesDuringInt,
+        pDevice->RxMaxCoalescedFramesDuringInt);
+    REG_WR(pDevice, HostCoalesce.TxMaxCoalescedFramesDuringInt,
+        pDevice->TxMaxCoalescedFramesDuringInt);
+
+    /* Initialize the address of the status block.  The NIC will DMA */
+    /* the status block to this memory which resides on the host. */
+    REG_WR(pDevice, HostCoalesce.StatusBlkHostAddr.High, 
+        pDevice->StatusBlkPhy.High);
+    REG_WR(pDevice, HostCoalesce.StatusBlkHostAddr.Low,
+        pDevice->StatusBlkPhy.Low);
+
+    /* Initialize the address of the statistics block.  The NIC will DMA */
+    /* the statistics to this block of memory. */
+    REG_WR(pDevice, HostCoalesce.StatsBlkHostAddr.High, 
+        pDevice->StatsBlkPhy.High);
+    REG_WR(pDevice, HostCoalesce.StatsBlkHostAddr.Low,
+        pDevice->StatsBlkPhy.Low);
+
+    REG_WR(pDevice, HostCoalesce.StatsCoalescingTicks,
+        pDevice->StatsCoalescingTicks);
+
+    REG_WR(pDevice, HostCoalesce.StatsBlkNicAddr, 0x300);
+    REG_WR(pDevice, HostCoalesce.StatusBlkNicAddr,0xb00);
+
+    /* Enable Host Coalesing state machine */
+    REG_WR(pDevice, HostCoalesce.Mode, HOST_COALESCE_ENABLE |
+        pDevice->CoalesceMode);
+
+    /* Enable the Receive BD Completion state machine. */
+    REG_WR(pDevice, RcvBdComp.Mode, RCV_BD_COMP_MODE_ENABLE |
+        RCV_BD_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Receive List Placement state machine. */
+    REG_WR(pDevice, RcvListPlmt.Mode, RCV_LIST_PLMT_MODE_ENABLE);
+
+    /* Enable the Receive List Selector state machine. */
+    REG_WR(pDevice, RcvListSel.Mode, RCV_LIST_SEL_MODE_ENABLE |
+        RCV_LIST_SEL_MODE_ATTN_ENABLE);
+
+    /* Enable transmit DMA, clear statistics. */
+    pDevice->MacMode =  MAC_MODE_ENABLE_TX_STATISTICS |
+        MAC_MODE_ENABLE_RX_STATISTICS | MAC_MODE_ENABLE_TDE |
+        MAC_MODE_ENABLE_RDE | MAC_MODE_ENABLE_FHDE;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+        MAC_MODE_CLEAR_RX_STATISTICS | MAC_MODE_CLEAR_TX_STATISTICS);
+
+    /* GRC miscellaneous local control register. */
+    pDevice->GrcLocalCtrl = GRC_MISC_LOCAL_CTRL_INT_ON_ATTN |
+        GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM;
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        pDevice->GrcLocalCtrl |= GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+            GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1;
+    }
+
+    REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl);
+    MM_Wait(40);
+
+    /* Reset RX counters. */
+    for(j = 0; j < sizeof(LM_RX_COUNTERS); j++)
+    {
+        ((PLM_UINT8) &pDevice->RxCounters)[j] = 0;
+    }
+
+    /* Reset TX counters. */
+    for(j = 0; j < sizeof(LM_TX_COUNTERS); j++)
+    {
+        ((PLM_UINT8) &pDevice->TxCounters)[j] = 0;
+    }
+
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+
+    /* Enable the DMA Completion state machine. */
+    REG_WR(pDevice, DmaComp.Mode, DMA_COMP_MODE_ENABLE);
+
+    /* Enable the DMA Write state machine. */
+    Value32 = DMA_WRITE_MODE_ENABLE |
+        DMA_WRITE_MODE_TARGET_ABORT_ATTN_ENABLE |
+        DMA_WRITE_MODE_MASTER_ABORT_ATTN_ENABLE |
+        DMA_WRITE_MODE_PARITY_ERROR_ATTN_ENABLE |
+        DMA_WRITE_MODE_ADDR_OVERFLOW_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_OVERRUN_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_UNDERRUN_ATTN_ENABLE |
+        DMA_WRITE_MODE_FIFO_OVERREAD_ATTN_ENABLE |
+        DMA_WRITE_MODE_LONG_READ_ATTN_ENABLE;
+    REG_WR(pDevice, DmaWrite.Mode, Value32);
+
+    /* Enable the Read DMA state machine. */
+    Value32 = DMA_READ_MODE_ENABLE |
+        DMA_READ_MODE_TARGET_ABORT_ATTN_ENABLE |
+        DMA_READ_MODE_MASTER_ABORT_ATTN_ENABLE |
+        DMA_READ_MODE_PARITY_ERROR_ATTN_ENABLE |
+        DMA_READ_MODE_ADDR_OVERFLOW_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_OVERRUN_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_UNDERRUN_ATTN_ENABLE |
+        DMA_READ_MODE_FIFO_OVERREAD_ATTN_ENABLE |
+        DMA_READ_MODE_LONG_READ_ATTN_ENABLE;
+    REG_WR(pDevice, DmaRead.Mode, Value32);
+
+    /* Enable the Receive Data Completion state machine. */
+    REG_WR(pDevice, RcvDataComp.Mode, RCV_DATA_COMP_MODE_ENABLE |
+        RCV_DATA_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Mbuf Cluster Free state machine. */
+    REG_WR(pDevice, MbufClusterFree.Mode, MBUF_CLUSTER_FREE_MODE_ENABLE);
+
+    /* Enable the Send Data Completion state machine. */
+    REG_WR(pDevice, SndDataComp.Mode, SND_DATA_COMP_MODE_ENABLE);
+
+    /* Enable the Send BD Completion state machine. */
+    REG_WR(pDevice, SndBdComp.Mode, SND_BD_COMP_MODE_ENABLE |
+        SND_BD_COMP_MODE_ATTN_ENABLE);
+
+    /* Enable the Receive BD Initiator state machine. */
+    REG_WR(pDevice, RcvBdIn.Mode, RCV_BD_IN_MODE_ENABLE |
+        RCV_BD_IN_MODE_BD_IN_DIABLED_RCB_ATTN_ENABLE);
+
+    /* Enable the Receive Data and Receive BD Initiator state machine. */
+    REG_WR(pDevice, RcvDataBdIn.Mode, RCV_DATA_BD_IN_MODE_ENABLE |
+        RCV_DATA_BD_IN_MODE_INVALID_RING_SIZE);
+
+    /* Enable the Send Data Initiator state machine. */
+    REG_WR(pDevice, SndDataIn.Mode, T3_SND_DATA_IN_MODE_ENABLE);
+
+    /* Enable the Send BD Initiator state machine. */
+    REG_WR(pDevice, SndBdIn.Mode, SND_BD_IN_MODE_ENABLE |
+        SND_BD_IN_MODE_ATTN_ENABLE);
+
+    /* Enable the Send BD Selector state machine. */
+    REG_WR(pDevice, SndBdSel.Mode, SND_BD_SEL_MODE_ENABLE |
+        SND_BD_SEL_MODE_ATTN_ENABLE);
+
+#if INCLUDE_5701_AX_FIX
+    /* Load the firmware for the 5701_A0 workaround. */
+    if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0)
+    {
+        LM_LoadRlsFirmware(pDevice);
+    }
+#endif
+
+    /* Enable the transmitter. */
+    pDevice->TxMode = TX_MODE_ENABLE;
+    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+    
+    /* Enable the receiver. */
+    pDevice->RxMode = RX_MODE_ENABLE;
+    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+
+    if (pDevice->RestoreOnWakeUp)
+    {
+        pDevice->RestoreOnWakeUp = FALSE;
+        pDevice->DisableAutoNeg = pDevice->WakeUpDisableAutoNeg;
+        pDevice->RequestedMediaType = pDevice->WakeUpRequestedMediaType;
+    }
+
+    /* Disable auto polling. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+        T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+    {
+        Value32 = LED_CTRL_PHY_MODE_1;
+    }
+    else
+    {
+        if(pDevice->LedMode == LED_MODE_OUTPUT)
+        {
+            Value32 = LED_CTRL_PHY_MODE_2;
+        }
+        else
+        {
+            Value32 = LED_CTRL_PHY_MODE_1;
+        }
+    }
+    REG_WR(pDevice, MacCtrl.LedCtrl, Value32);
+    
+    /* Activate Link to enable MAC state machine */
+    REG_WR(pDevice, MacCtrl.MiStatus, MI_STATUS_ENABLE_LINK_STATUS_ATTN);
+
+    if (pDevice->EnableTbi)
+    {
+        REG_WR(pDevice, MacCtrl.RxMode, RX_MODE_RESET);
+        MM_Wait(10);
+        REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+        if (pDevice->ChipRevId == T3_CHIP_ID_5703_A1)
+        {
+            REG_WR(pDevice, MacCtrl.SerdesCfg, 0x616000);
+        }
+    }
+    /* Setup the phy chip. */
+    LM_SetupPhy(pDevice);
+
+    if (!pDevice->EnableTbi) {
+        /* Clear CRC stats */
+        LM_ReadPhy(pDevice, 0x1e, &Value32);
+        LM_WritePhy(pDevice, 0x1e, Value32 | 0x8000);
+        LM_ReadPhy(pDevice, 0x14, &Value32);
+    }
+
+    /* Set up the receive mask. */
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask);
+
+    /* Queue Rx packet buffers. */
+    if(pDevice->QueueRxPackets)
+    {
+        LM_QueueRxPackets(pDevice);
+    }
+
+    /* Enable interrupt to the host. */
+    if(pDevice->InitDone)
+    {
+        LM_EnableInterrupt(pDevice);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_ResetAdapter */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine disables the adapter from generating interrupts.           */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_DisableInterrupt(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl | 
+        MISC_HOST_CTRL_MASK_PCI_INT);
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 1);
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine enables the adapter to generate interrupts.                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_EnableInterrupt(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, pDevice->MiscHostCtrl &
+        ~MISC_HOST_CTRL_MASK_PCI_INT);
+    REG_WR(pDevice, Mailbox.Interrupt[0].Low, 0);
+
+    if(pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_UPDATED)
+    {
+        REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+            GRC_MISC_LOCAL_CTRL_SET_INT);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine puts a packet on the wire if there is a transmit DMA       */
+/*    descriptor available; otherwise the packet is queued for later          */
+/*    transmission.  If the second argue is NULL, this routine will put       */
+/*    the queued packet on the wire if possible.                              */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_SendPacket(PLM_DEVICE_BLOCK pDevice, PLM_PACKET pPacket)
+{
+    LM_UINT32 FragCount;
+    PT3_SND_BD pSendBd;
+    PT3_SND_BD pShadowSendBd;
+    LM_UINT32 Value32;
+    LM_UINT32 Idx;
+
+    /* Update the SendBdLeft count. */
+    atomic_sub(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+    /* Initalize the send buffer descriptors. */
+    Idx = pDevice->SendProdIdx;
+
+    pSendBd = &pDevice->pSendBdVirt[Idx];
+
+    /* Next producer index. */
+    if (pDevice->NicSendBd == TRUE)
+    {
+        pShadowSendBd = &pDevice->ShadowSendBd[Idx];
+        for(FragCount = 0; ; )
+        {
+            /* Initialize the pointer to the send buffer fragment. */
+            Value32 =
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.High;
+            if (Value32 != pShadowSendBd->HostAddr.High)
+            {
+                __raw_writel(Value32, &(pSendBd->HostAddr.High));
+                pShadowSendBd->HostAddr.High = Value32;
+            }
+            __raw_writel(pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.Low,
+                &(pSendBd->HostAddr.Low));
+
+            /* Setup the control flags and send buffer size. */
+            Value32 = (pPacket->u.Tx.pFraglist->Fragments[FragCount].
+                FragSize << 16) | pPacket->Flags;
+
+            Idx = (Idx + 1) & T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+            FragCount++;
+            if (FragCount >= pPacket->u.Tx.FragCount)
+            {
+                Value32 |= SND_BD_FLAG_END;
+                if (Value32 != pShadowSendBd->u1.Len_Flags)
+                {
+                    __raw_writel(Value32, &(pSendBd->u1.Len_Flags));
+                    pShadowSendBd->u1.Len_Flags = Value32;
+                }
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG) {
+                    __raw_writel(pPacket->VlanTag, &(pSendBd->u2.VlanTag));
+                }
+                break;
+            }
+            else
+            {
+                if (Value32 != pShadowSendBd->u1.Len_Flags)
+                {
+                    __raw_writel(Value32, &(pSendBd->u1.Len_Flags));
+                    pShadowSendBd->u1.Len_Flags = Value32;
+                }
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG) {
+                    __raw_writel(pPacket->VlanTag, &(pSendBd->u2.VlanTag));
+                }
+            }
+
+            pSendBd++;
+            pShadowSendBd++;
+            if (Idx == 0)
+            {
+                pSendBd = &pDevice->pSendBdVirt[0];
+                pShadowSendBd = &pDevice->ShadowSendBd[0];
+            }
+        } /* for */
+
+        /* Put the packet descriptor in the ActiveQ. */
+        QQ_PushTail(&pDevice->TxPacketActiveQ.Container, pPacket);
+
+        wmb();
+        RAW_REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, Idx);
+
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            RAW_REG_WR(pDevice, Mailbox.SendNicProdIdx[0].Low, Idx);
+        }
+    }
+    else
+    {
+        for(FragCount = 0; ; )
+        {
+            /* Initialize the pointer to the send buffer fragment. */
+            pSendBd->HostAddr.High = 
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.High;
+            pSendBd->HostAddr.Low = 
+                pPacket->u.Tx.pFraglist->Fragments[FragCount].FragBuf.Low;
+
+            /* Setup the control flags and send buffer size. */
+            Value32 = (pPacket->u.Tx.pFraglist->Fragments[FragCount].
+                FragSize << 16) | pPacket->Flags;
+
+            Idx = (Idx + 1) & T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+            FragCount++;
+            if (FragCount >= pPacket->u.Tx.FragCount)
+            {
+                pSendBd->u1.Len_Flags = Value32 | SND_BD_FLAG_END;
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+                break;
+            }
+            else
+            {
+                pSendBd->u1.Len_Flags = Value32;
+                if (pPacket->Flags & SND_BD_FLAG_VLAN_TAG)
+                    pSendBd->u2.VlanTag = pPacket->VlanTag;
+            }
+            pSendBd++;
+            if (Idx == 0)
+            {
+                pSendBd = &pDevice->pSendBdVirt[0];
+            }
+        } /* for */
+
+        /* Put the packet descriptor in the ActiveQ. */
+        QQ_PushTail(&pDevice->TxPacketActiveQ.Container, pPacket);
+
+        wmb();
+        RAW_REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, Idx);
+
+        if(T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+        {
+            RAW_REG_WR(pDevice, Mailbox.SendHostProdIdx[0].Low, Idx);
+        }
+    }
+
+    /* Update the producer index. */
+    pDevice->SendProdIdx = Idx;
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static unsigned long
+ComputeCrc32(
+unsigned char *pBuffer,
+unsigned long BufferSize) {
+    unsigned long Reg;
+    unsigned long Tmp;
+    unsigned long j, k;
+
+    Reg = 0xffffffff;
+
+    for(j = 0; j < BufferSize; j++)
+    {
+        Reg ^= pBuffer[j];
+
+        for(k = 0; k < 8; k++)
+        {
+            Tmp = Reg & 0x01;
+
+            Reg >>= 1;
+
+            if(Tmp)
+            {
+                Reg ^= 0xedb88320;
+            }
+        }
+    }
+
+    return ~Reg;
+} /* ComputeCrc32 */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This routine sets the receive control register according to ReceiveMask */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_SetReceiveMask(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 Mask) {
+    LM_UINT32 ReceiveMask;
+    LM_UINT32 RxMode;
+    LM_UINT32 j, k;
+
+    ReceiveMask = Mask;
+
+    RxMode = pDevice->RxMode;
+
+    if(Mask & LM_ACCEPT_UNICAST)
+    {
+        Mask &= ~LM_ACCEPT_UNICAST;
+    }
+
+    if(Mask & LM_ACCEPT_MULTICAST)
+    {
+        Mask &= ~LM_ACCEPT_MULTICAST;
+    }
+
+    if(Mask & LM_ACCEPT_ALL_MULTICAST)
+    {
+        Mask &= ~LM_ACCEPT_ALL_MULTICAST;
+    }
+
+    if(Mask & LM_ACCEPT_BROADCAST)
+    {
+        Mask &= ~LM_ACCEPT_BROADCAST;
+    }
+
+    RxMode &= ~RX_MODE_PROMISCUOUS_MODE;
+    if(Mask & LM_PROMISCUOUS_MODE)
+    {
+        RxMode |= RX_MODE_PROMISCUOUS_MODE;
+        Mask &= ~LM_PROMISCUOUS_MODE;
+    }
+
+    RxMode &= ~(RX_MODE_ACCEPT_RUNTS | RX_MODE_ACCEPT_OVERSIZED);
+    if(Mask & LM_ACCEPT_ERROR_PACKET)
+    {
+        RxMode |= RX_MODE_ACCEPT_RUNTS | RX_MODE_ACCEPT_OVERSIZED;
+        Mask &= ~LM_ACCEPT_ERROR_PACKET;
+    }
+
+    /* Make sure all the bits are valid before committing changes. */
+    if(Mask)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    /* Commit the new filter. */
+    pDevice->RxMode = RxMode;
+    REG_WR(pDevice, MacCtrl.RxMode, RxMode);
+
+    pDevice->ReceiveMask = ReceiveMask;
+
+    /* Set up the MC hash table. */
+    if(ReceiveMask & LM_ACCEPT_ALL_MULTICAST)
+    {
+        for(k = 0; k < 4; k++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[k], 0xffffffff);
+        }
+    }
+    else if(ReceiveMask & LM_ACCEPT_MULTICAST)
+    {
+        LM_UINT32 HashReg[4];
+
+        HashReg[0] = 0; HashReg[1] = 0; HashReg[2] = 0; HashReg[3] = 0;
+        for(j = 0; j < pDevice->McEntryCount; j++)
+        {
+            LM_UINT32 RegIndex;
+            LM_UINT32 Bitpos;
+            LM_UINT32 Crc32;
+
+            Crc32 = ComputeCrc32(pDevice->McTable[j], ETHERNET_ADDRESS_SIZE);
+
+            /* The most significant 7 bits of the CRC32 (no inversion), */
+            /* are used to index into one of the possible 128 bit positions. */
+            Bitpos = ~Crc32 & 0x7f;
+
+            /* Hash register index. */
+            RegIndex = (Bitpos & 0x60) >> 5;
+
+            /* Bit to turn on within a hash register. */
+            Bitpos &= 0x1f;
+
+            /* Enable the multicast bit. */
+            HashReg[RegIndex] |= (1 << Bitpos);
+        }
+
+        /* REV_AX has problem with multicast filtering where it uses both */
+        /* DA and SA to perform hashing. */
+        for(k = 0; k < 4; k++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[k], HashReg[k]);
+        }
+    }
+    else
+    {
+        /* Reject all multicast frames. */
+        for(j = 0; j < 4; j++)
+        {
+            REG_WR(pDevice, MacCtrl.HashReg[j], 0);
+        }
+    }
+
+    /* By default, Tigon3 will accept broadcast frames.  We need to setup */
+    if(ReceiveMask & LM_ACCEPT_BROADCAST)
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Rule,
+            REJECT_BROADCAST_RULE1_RULE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Value,
+            REJECT_BROADCAST_RULE1_VALUE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Rule,
+            REJECT_BROADCAST_RULE1_RULE & RCV_DISABLE_RULE_MASK);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Value,
+            REJECT_BROADCAST_RULE1_VALUE & RCV_DISABLE_RULE_MASK);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Rule, 
+            REJECT_BROADCAST_RULE1_RULE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE1_REJECT_BROADCAST_IDX].Value, 
+            REJECT_BROADCAST_RULE1_VALUE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Rule, 
+            REJECT_BROADCAST_RULE2_RULE);
+        REG_WR(pDevice, MacCtrl.RcvRules[RCV_RULE2_REJECT_BROADCAST_IDX].Value, 
+            REJECT_BROADCAST_RULE2_VALUE);
+    }
+
+    /* disable the rest of the rules. */
+    for(j = RCV_LAST_RULE_IDX; j < 16; j++)
+    {
+        REG_WR(pDevice, MacCtrl.RcvRules[j].Rule, 0);
+        REG_WR(pDevice, MacCtrl.RcvRules[j].Value, 0);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetReceiveMask */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Disable the interrupt and put the transmitter and receiver engines in   */
+/*    an idle state.  Also aborts all pending send requests and receive       */
+/*    buffers.                                                                */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_Abort(
+PLM_DEVICE_BLOCK pDevice)
+{
+    PLM_PACKET pPacket;
+    LM_UINT Idx;
+
+    LM_DisableInterrupt(pDevice);
+
+    /* Disable all the state machines. */
+    LM_CntrlBlock(pDevice,T3_BLOCK_MAC_RX_ENGINE,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_BD_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_LIST_PLMT,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_LIST_SELECTOR,LM_DISABLE);  
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_DATA_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_DATA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_RX_BD_COMP,LM_DISABLE);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_SELECTOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_DATA_INITIATOR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_RD,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_DATA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_COMP,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_SEND_BD_COMP,LM_DISABLE);
+
+    /* Clear TDE bit */
+    pDevice->MacMode &= ~MAC_MODE_ENABLE_TDE;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_MAC_TX_ENGINE,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_HOST_COALESING,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_DMA_WR,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_MBUF_CLUSTER_FREE,LM_DISABLE);
+
+    /* Reset all FTQs */
+    REG_WR(pDevice, Ftq.Reset, 0xffffffff);
+    REG_WR(pDevice, Ftq.Reset, 0x0);
+
+    LM_CntrlBlock(pDevice,T3_BLOCK_MBUF_MANAGER,LM_DISABLE);
+    LM_CntrlBlock(pDevice,T3_BLOCK_MEM_ARBITOR,LM_DISABLE);
+
+    MM_ACQUIRE_INT_LOCK(pDevice);
+
+    /* Abort packets that have already queued to go out. */
+    pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->TxPacketActiveQ.Container);
+    while(pPacket)
+    {
+//        MM_CompleteTxDma(pDevice, pPacket);
+
+        pPacket->PacketStatus = LM_STATUS_TRANSMIT_ABORTED;
+        pDevice->TxCounters.TxPacketAbortedCnt++;
+
+        atomic_add(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+        QQ_PushTail(&pDevice->TxPacketXmittedQ.Container, pPacket);
+
+        pPacket = (PLM_PACKET) 
+            QQ_PopHead(&pDevice->TxPacketActiveQ.Container);
+    }
+
+    /* Cleanup the receive return rings. */
+    LM_ServiceRxInterrupt(pDevice);
+
+    /* Don't want to indicate rx packets in Ndis miniport shutdown context. */
+    /* Doing so may cause system crash. */
+    if(!pDevice->ShuttingDown)
+    {
+        /* Indicate packets to the protocol. */
+        MM_IndicateTxPackets(pDevice);
+
+        /* Indicate received packets to the protocols. */
+        MM_IndicateRxPackets(pDevice);
+    }
+    else
+    {
+        /* Move the receive packet descriptors in the ReceivedQ to the */
+        /* free queue. */
+        for(; ;)
+        {
+            pPacket = (PLM_PACKET) QQ_PopHead(
+                &pDevice->RxPacketReceivedQ.Container);
+            if(pPacket == NULL)
+            {
+                break;
+            }
+            QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+        }
+    }
+
+    /* Clean up the Std Receive Producer ring. */
+    Idx = pDevice->pStatusBlkVirt->RcvStdConIdx;
+
+    while(Idx != pDevice->RxStdProdIdx) {
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pDevice->pRxStdBdVirt[Idx].Opaque));
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        Idx = (Idx + 1) & T3_STD_RCV_RCB_ENTRY_COUNT_MASK;
+    } /* while */
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxStdProdIdx = 0;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    /* Clean up the Jumbo Receive Producer ring. */
+    Idx = pDevice->pStatusBlkVirt->RcvJumboConIdx;
+
+    while(Idx != pDevice->RxJumboProdIdx) {
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pDevice->pRxJumboBdVirt[Idx].Opaque));
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+
+        Idx = (Idx + 1) & T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK;
+    } /* while */
+
+    /* Reinitialize our copy of the indices. */
+    pDevice->RxJumboProdIdx = 0;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    MM_RELEASE_INT_LOCK(pDevice);
+
+    /* Initialize the statistis Block */
+    pDevice->pStatusBlkVirt->Status = 0;
+    pDevice->pStatusBlkVirt->RcvStdConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvJumboConIdx = 0;
+    pDevice->pStatusBlkVirt->RcvMiniConIdx = 0;
+
+    return LM_STATUS_SUCCESS;
+} /* LM_Abort */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Disable the interrupt and put the transmitter and receiver engines in   */
+/*    an idle state.  Aborts all pending send requests and receive buffers.   */
+/*    Also free all the receive buffers.                                      */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_Halt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    LM_UINT32 EntryCnt;
+
+    LM_Abort(pDevice);
+
+    /* Get the number of entries in the queue. */
+    EntryCnt = QQ_GetEntryCnt(&pDevice->RxPacketFreeQ.Container);
+
+    /* Make sure all the packets have been accounted for. */
+    for(EntryCnt = 0; EntryCnt < pDevice->RxPacketDescCnt; EntryCnt++)
+    {
+        pPacket = (PLM_PACKET) QQ_PopHead(&pDevice->RxPacketFreeQ.Container);
+        if (pPacket == 0)
+            break;
+
+        MM_FreeRxBuffer(pDevice, pPacket);
+
+        QQ_PushTail(&pDevice->RxPacketFreeQ.Container, pPacket);
+    }
+
+    LM_ResetChip(pDevice);
+
+    /* Restore PCI configuration registers. */
+    MM_WriteConfig32(pDevice, PCI_CACHE_LINE_SIZE_REG,
+        pDevice->SavedCacheLineReg);
+    LM_RegWrInd(pDevice, PCI_SUBSYSTEM_VENDOR_ID_REG, 
+        (pDevice->SubsystemId << 16) | pDevice->SubsystemVendorId);
+
+    /* Reprogram the MAC address. */
+    LM_SetMacAddress(pDevice, pDevice->NodeAddress);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_Halt */
+
+
+STATIC LM_STATUS
+LM_ResetChip(PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    /* Wait for access to the nvram interface before resetting.  This is */
+    /* a workaround to prevent EEPROM corruption. */
+    if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+        T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5701)
+    {
+        /* Request access to the flash interface. */
+        REG_WR(pDevice, Nvram.SwArb, SW_ARB_REQ_SET1);
+
+        for(j = 0; j < 100000; j++)
+        {
+            Value32 = REG_RD(pDevice, Nvram.SwArb);
+            if(Value32 & SW_ARB_GNT1)
+            {
+                break;
+            }
+            MM_Wait(10);
+        }
+    }
+
+    /* Global reset. */
+    REG_WR(pDevice, Grc.MiscCfg, GRC_MISC_CFG_CORE_CLOCK_RESET);
+    MM_Wait(40); MM_Wait(40); MM_Wait(40);
+
+    /* make sure we re-enable indirect accesses */
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG,
+        pDevice->MiscHostCtrl);
+
+    /* Set MAX PCI retry to zero. */
+    MM_WriteConfig32(pDevice, T3_PCI_STATE_REG,
+        T3_PCI_STATE_PCI_ROM_ENABLE | T3_PCI_STATE_PCI_ROM_RETRY_ENABLE);
+
+    /* Restore PCI command register. */
+    MM_WriteConfig32(pDevice, PCI_COMMAND_REG,
+        pDevice->PciCommandStatusWords);
+
+    /* Disable PCI-X relaxed ordering bit. */
+    MM_ReadConfig32(pDevice, PCIX_CAP_REG, &Value32);
+    Value32 &= ~PCIX_ENABLE_RELAXED_ORDERING;
+    MM_WriteConfig32(pDevice, PCIX_CAP_REG, Value32);
+
+    /* Enable memory arbiter. */
+    REG_WR(pDevice, MemArbiter.Mode, T3_MEM_ARBITER_MODE_ENABLE);
+
+#ifdef BIG_ENDIAN_HOST
+    /* Reconfigure the mode register. */
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | 
+              GRC_MODE_WORD_SWAP_NON_FRAME_DATA |
+              GRC_MODE_BYTE_SWAP_DATA |
+              GRC_MODE_WORD_SWAP_DATA;
+#else
+    /* Reconfigure the mode register. */
+    Value32 = GRC_MODE_BYTE_SWAP_NON_FRAME_DATA | GRC_MODE_BYTE_SWAP_DATA;
+#endif
+    REG_WR(pDevice, Grc.Mode, Value32);
+
+    /* Prevent PXE from restarting. */
+    MEM_WR_OFFSET(pDevice, 0x0b50, T3_MAGIC_NUM);
+
+    if(pDevice->EnableTbi) {
+        pDevice->MacMode = MAC_MODE_PORT_MODE_TBI;
+        REG_WR(pDevice, MacCtrl.Mode, MAC_MODE_PORT_MODE_TBI);
+    }
+    else {
+        REG_WR(pDevice, MacCtrl.Mode, 0);
+    }
+
+    /* Wait for the firmware to finish initialization. */
+    for(j = 0; j < 100000; j++)
+    {
+        MM_Wait(10);
+
+        Value32 = MEM_RD_OFFSET(pDevice, 0x0b50);
+        if(Value32 == ~T3_MAGIC_NUM)
+        {
+            break;
+        }
+    }
+    return LM_STATUS_SUCCESS;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void
+LM_ServiceTxInterrupt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    LM_UINT32 HwConIdx;
+    LM_UINT32 SwConIdx;
+
+    HwConIdx = pDevice->pStatusBlkVirt->Idx[0].SendConIdx;
+
+    /* Get our copy of the consumer index.  The buffer descriptors */
+    /* that are in between the consumer indices are freed. */
+    SwConIdx = pDevice->SendConIdx;
+
+    /* Move the packets from the TxPacketActiveQ that are sent out to */
+    /* the TxPacketXmittedQ.  Packets that are sent use the */
+    /* descriptors that are between SwConIdx and HwConIdx. */
+    while(SwConIdx != HwConIdx)
+    {
+        /* Get the packet that was sent from the TxPacketActiveQ. */
+        pPacket = (PLM_PACKET) QQ_PopHead(
+            &pDevice->TxPacketActiveQ.Container);
+
+        /* Set the return status. */
+        pPacket->PacketStatus = LM_STATUS_SUCCESS;
+
+        /* Complete the transmit with a call to MM_CompleteTxDma. */
+//        MM_CompleteTxDma(pDevice, pPacket);
+
+        /* Put the packet in the TxPacketXmittedQ for indication later. */
+        QQ_PushTail(&pDevice->TxPacketXmittedQ.Container, pPacket);
+
+        /* Move to the next packet's BD. */
+        SwConIdx = (SwConIdx + pPacket->u.Tx.FragCount) & 
+            T3_SEND_RCB_ENTRY_COUNT_MASK;
+
+        /* Update the number of unused BDs. */
+        atomic_add(pPacket->u.Tx.FragCount, &pDevice->SendBdLeft);
+
+        /* Get the new updated HwConIdx. */
+        HwConIdx = pDevice->pStatusBlkVirt->Idx[0].SendConIdx;
+    } /* while */
+
+    /* Save the new SwConIdx. */
+    pDevice->SendConIdx = SwConIdx;
+
+} /* LM_ServiceTxInterrupt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+__inline static void
+LM_ServiceRxInterrupt(
+PLM_DEVICE_BLOCK pDevice) {
+    PLM_PACKET pPacket;
+    PT3_RCV_BD pRcvBd;
+    LM_UINT32 HwRcvRetProdIdx;
+    LM_UINT32 SwRcvRetConIdx;
+
+    /* Loop thru the receive return rings for received packets. */
+    HwRcvRetProdIdx = pDevice->pStatusBlkVirt->Idx[0].RcvProdIdx;
+
+    SwRcvRetConIdx = pDevice->RcvRetConIdx;
+    while(SwRcvRetConIdx != HwRcvRetProdIdx)
+    {
+        pRcvBd = &pDevice->pRcvRetBdVirt[SwRcvRetConIdx];
+
+        /* Get the received packet descriptor. */
+        pPacket = (PLM_PACKET) (MM_UINT_PTR(pDevice->pPacketDescBase) +
+            MM_UINT_PTR(pRcvBd->Opaque));
+
+        /* Check the error flag. */
+        if(pRcvBd->ErrorFlag &&
+            pRcvBd->ErrorFlag != RCV_BD_ERR_ODD_NIBBLED_RCVD_MII)
+        {
+            pPacket->PacketStatus = LM_STATUS_FAILURE;
+
+            pDevice->RxCounters.RxPacketErrCnt++;
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_BAD_CRC)
+            {
+                pDevice->RxCounters.RxErrCrcCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_COLL_DETECT)
+            {
+                pDevice->RxCounters.RxErrCollCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_LINK_LOST_DURING_PKT)
+            {
+                pDevice->RxCounters.RxErrLinkLostCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_PHY_DECODE_ERR)
+            {
+                pDevice->RxCounters.RxErrPhyDecodeCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_ODD_NIBBLED_RCVD_MII)
+            {
+                pDevice->RxCounters.RxErrOddNibbleCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_MAC_ABORT)
+            {
+                pDevice->RxCounters.RxErrMacAbortCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_LEN_LT_64)
+            {
+                pDevice->RxCounters.RxErrShortPacketCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_TRUNC_NO_RESOURCES)
+            {
+                pDevice->RxCounters.RxErrNoResourceCnt++;
+            }
+
+            if(pRcvBd->ErrorFlag & RCV_BD_ERR_GIANT_FRAME_RCVD)
+            {
+                pDevice->RxCounters.RxErrLargePacketCnt++;
+            }
+        }
+        else
+        {
+            pPacket->PacketStatus = LM_STATUS_SUCCESS;
+            pPacket->PacketSize = pRcvBd->Len - 4;
+
+            pPacket->Flags = pRcvBd->Flags;
+            if(pRcvBd->Flags & RCV_BD_FLAG_VLAN_TAG)
+            {
+                pPacket->VlanTag = pRcvBd->VlanTag;
+            }
+
+            pPacket->u.Rx.TcpUdpChecksum = pRcvBd->TcpUdpCksum;
+        }
+
+        /* Put the packet descriptor containing the received packet */
+        /* buffer in the RxPacketReceivedQ for indication later. */
+        QQ_PushTail(&pDevice->RxPacketReceivedQ.Container, pPacket);
+
+        /* Go to the next buffer descriptor. */
+        SwRcvRetConIdx = (SwRcvRetConIdx + 1) &
+            T3_RCV_RETURN_RCB_ENTRY_COUNT_MASK;
+
+        /* Get the updated HwRcvRetProdIdx. */
+        HwRcvRetProdIdx = pDevice->pStatusBlkVirt->Idx[0].RcvProdIdx;
+    } /* while */
+
+    pDevice->RcvRetConIdx = SwRcvRetConIdx;
+
+    /* Update the receive return ring consumer index. */
+    RAW_REG_WR(pDevice, Mailbox.RcvRetConIdx[0].Low, SwRcvRetConIdx);
+} /* LM_ServiceRxInterrupt */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    This is the interrupt event handler routine. It acknowledges all        */
+/*    pending interrupts and process all pending events.                      */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_SUCCESS                                                       */
+/******************************************************************************/
+LM_STATUS
+LM_ServiceInterrupts(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    int ServicePhyInt = FALSE;
+
+    /* Setup the phy chip whenever the link status changes. */
+    if(pDevice->LinkChngMode == T3_LINK_CHNG_MODE_USE_STATUS_REG)
+    {
+        Value32 = REG_RD(pDevice, MacCtrl.Status);
+        if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+        {
+            if (Value32 & MAC_STATUS_MI_INTERRUPT)
+            {
+                ServicePhyInt = TRUE;
+            }
+        }
+        else if(Value32 & MAC_STATUS_LINK_STATE_CHANGED)
+        {
+            ServicePhyInt = TRUE;
+        }
+    }
+    else
+    {
+        if(pDevice->pStatusBlkVirt->Status & STATUS_BLOCK_LINK_CHANGED_STATUS)
+        {
+            pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED |
+                (pDevice->pStatusBlkVirt->Status & ~STATUS_BLOCK_LINK_CHANGED_STATUS);
+            ServicePhyInt = TRUE;
+        }
+    }
+#if INCLUDE_TBI_SUPPORT
+    if (pDevice->IgnoreTbiLinkChange == TRUE)
+    {
+        ServicePhyInt = FALSE;
+    }
+#endif
+    if (ServicePhyInt == TRUE)
+    {
+        LM_SetupPhy(pDevice);
+    }
+
+    /* Service receive and transmit interrupts. */
+    LM_ServiceRxInterrupt(pDevice);
+    LM_ServiceTxInterrupt(pDevice);
+        
+    /* No spinlock for this queue since this routine is serialized. */
+    if(!QQ_Empty(&pDevice->RxPacketReceivedQ.Container))
+    {
+        /* Indicate receive packets. */
+        MM_IndicateRxPackets(pDevice);
+//        LM_QueueRxPackets(pDevice);
+    }
+
+    /* No spinlock for this queue since this routine is serialized. */
+    if(!QQ_Empty(&pDevice->TxPacketXmittedQ.Container))
+    {
+        MM_IndicateTxPackets(pDevice);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_ServiceInterrupts */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastAdd(
+PLM_DEVICE_BLOCK pDevice,
+PLM_UINT8 pMcAddress) {
+    PLM_UINT8 pEntry;
+    LM_UINT32 j;
+
+    pEntry = pDevice->McTable[0];
+    for(j = 0; j < pDevice->McEntryCount; j++)
+    {
+        if(IS_ETH_ADDRESS_EQUAL(pEntry, pMcAddress))
+        {
+            /* Found a match, increment the instance count. */
+            pEntry[LM_MC_INSTANCE_COUNT_INDEX] += 1;
+
+            return LM_STATUS_SUCCESS;
+        }
+
+        pEntry += LM_MC_ENTRY_SIZE;
+    }
+    
+    if(pDevice->McEntryCount >= LM_MAX_MC_TABLE_SIZE)
+    {
+        return LM_STATUS_FAILURE;
+    }
+
+    pEntry = pDevice->McTable[pDevice->McEntryCount];
+
+    COPY_ETH_ADDRESS(pMcAddress, pEntry);
+    pEntry[LM_MC_INSTANCE_COUNT_INDEX] = 1;
+
+    pDevice->McEntryCount++;
+
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask | LM_ACCEPT_MULTICAST);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_MulticastAdd */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastDel(
+PLM_DEVICE_BLOCK pDevice,
+PLM_UINT8 pMcAddress) {
+    PLM_UINT8 pEntry;
+    LM_UINT32 j;
+
+    pEntry = pDevice->McTable[0];
+    for(j = 0; j < pDevice->McEntryCount; j++)
+    {
+        if(IS_ETH_ADDRESS_EQUAL(pEntry, pMcAddress))
+        {
+            /* Found a match, decrement the instance count. */
+            pEntry[LM_MC_INSTANCE_COUNT_INDEX] -= 1;
+
+            /* No more instance left, remove the address from the table. */
+            /* Move the last entry in the table to the delete slot. */
+            if(pEntry[LM_MC_INSTANCE_COUNT_INDEX] == 0 &&
+                pDevice->McEntryCount > 1)
+            {
+
+                COPY_ETH_ADDRESS(
+                    pDevice->McTable[pDevice->McEntryCount-1], pEntry);
+                pEntry[LM_MC_INSTANCE_COUNT_INDEX] =
+                    pDevice->McTable[pDevice->McEntryCount-1]
+                    [LM_MC_INSTANCE_COUNT_INDEX];
+            }
+            pDevice->McEntryCount--;
+
+            /* Update the receive mask if the table is empty. */
+            if(pDevice->McEntryCount == 0)
+            {
+                LM_SetReceiveMask(pDevice, 
+                    pDevice->ReceiveMask & ~LM_ACCEPT_MULTICAST);
+            }
+
+            return LM_STATUS_SUCCESS;
+        }
+
+        pEntry += LM_MC_ENTRY_SIZE;
+    }
+
+    return LM_STATUS_FAILURE;
+} /* LM_MulticastDel */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_MulticastClear(
+PLM_DEVICE_BLOCK pDevice) {
+    pDevice->McEntryCount = 0;
+
+    LM_SetReceiveMask(pDevice, pDevice->ReceiveMask & ~LM_ACCEPT_MULTICAST);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_MulticastClear */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetMacAddress(
+    PLM_DEVICE_BLOCK pDevice,
+    PLM_UINT8 pMacAddress)
+{
+    LM_UINT32 j;
+
+    for(j = 0; j < 4; j++)
+    {
+        REG_WR(pDevice, MacCtrl.MacAddr[j].High,
+            (pMacAddress[0] << 8) | pMacAddress[1]);
+        REG_WR(pDevice, MacCtrl.MacAddr[j].Low,
+            (pMacAddress[2] << 24) | (pMacAddress[3] << 16) |
+            (pMacAddress[4] << 8) | pMacAddress[5]);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*    Sets up the default line speed, and duplex modes based on the requested */
+/*    media type.                                                             */
+/*                                                                            */
+/* Return:                                                                    */
+/*    None.                                                                   */
+/******************************************************************************/
+static LM_STATUS
+LM_TranslateRequestedMediaType(
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+PLM_MEDIA_TYPE pMediaType,
+PLM_LINE_SPEED pLineSpeed,
+PLM_DUPLEX_MODE pDuplexMode) {
+    *pMediaType = LM_MEDIA_TYPE_AUTO;
+    *pLineSpeed = LM_LINE_SPEED_UNKNOWN;
+    *pDuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+
+    /* determine media type */
+    switch(RequestedMediaType) {
+        case LM_REQUESTED_MEDIA_TYPE_BNC:
+            *pMediaType = LM_MEDIA_TYPE_BNC;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_AUTO:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_10MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_100MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_UTP_1000MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_UTP;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_100MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_100MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_HALF;
+            break;
+
+        case LM_REQUESTED_MEDIA_TYPE_FIBER_1000MBPS_FULL_DUPLEX:
+            *pMediaType = LM_MEDIA_TYPE_FIBER;
+            *pLineSpeed = LM_LINE_SPEED_1000MBPS;
+            *pDuplexMode = LM_DUPLEX_MODE_FULL;
+            break;
+
+        default:
+            break;
+    } /* switch */
+
+    return LM_STATUS_SUCCESS;
+} /* LM_TranslateRequestedMediaType */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_LINK_ACTIVE                                                   */
+/*    LM_STATUS_LINK_DOWN                                                     */
+/******************************************************************************/
+static LM_STATUS
+LM_InitBcm540xPhy(
+PLM_DEVICE_BLOCK pDevice)
+{
+    LM_LINE_SPEED CurrentLineSpeed;
+    LM_DUPLEX_MODE CurrentDuplexMode;
+    LM_STATUS CurrentLinkStatus;
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if((pDevice->PhyId & PHY_ID_MASK) == PHY_BCM5401_PHY_ID)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        if(!pDevice->InitDone)
+        {
+            Value32 = 0;
+        }
+
+        if(!(Value32 & PHY_STATUS_LINK_PASS))
+        {
+            LM_WritePhy(pDevice, BCM5401_AUX_CTRL,  0x0c20);
+
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+                
+            LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+            LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+            for(j = 0; j < 1000; j++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+                if(Value32 & PHY_STATUS_LINK_PASS)
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+            if((pDevice->PhyId & PHY_ID_REV_MASK) == PHY_BCM5401_B0_REV)
+            {
+                if(!(Value32 & PHY_STATUS_LINK_PASS) &&
+                    (pDevice->OldLineSpeed == LM_LINE_SPEED_1000MBPS))
+                {
+                    LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_PHY_RESET);
+                    for(j = 0; j < 100; j++)
+                    {
+                        MM_Wait(10);
+
+                        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+                        if(!(Value32 & PHY_CTRL_PHY_RESET))
+                        {
+                            MM_Wait(40);
+                            break;
+                        }
+                    }
+
+                    LM_WritePhy(pDevice, BCM5401_AUX_CTRL,  0x0c20);
+
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0012);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1804);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x0013);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x1204);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0132);
+
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x8006);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0232);
+                        
+                    LM_WritePhy(pDevice, BCM540X_DSP_ADDRESS_REG, 0x201f);
+                    LM_WritePhy(pDevice, BCM540X_DSP_RW_PORT, 0x0a20);
+                }
+            }
+        }
+    }
+    else if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+        pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+    {
+        /* Bug: 5701 A0, B0 TX CRC workaround. */
+        LM_WritePhy(pDevice, 0x15, 0x0a75);
+        LM_WritePhy(pDevice, 0x1c, 0x8c68);
+        LM_WritePhy(pDevice, 0x1c, 0x8d68);
+        LM_WritePhy(pDevice, 0x1c, 0x8c68);
+    }
+
+    /* Acknowledge interrupts. */
+    LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+    LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+
+    /* Configure the interrupt mask. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+    {
+        LM_WritePhy(pDevice, BCM540X_INT_MASK_REG, ~BCM540X_INT_LINK_CHANGE);
+    }
+
+    /* Configure PHY led mode. */
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701 ||
+        (T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700))
+    {
+        if(pDevice->LedMode == LED_MODE_THREE_LINK)
+        {
+            LM_WritePhy(pDevice, BCM540X_EXT_CTRL_REG, 
+                BCM540X_EXT_CTRL_LINK3_LED_MODE);
+        }
+        else
+        {
+            LM_WritePhy(pDevice, BCM540X_EXT_CTRL_REG, 0);
+        }
+    }
+
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Get current link and duplex mode. */
+    for(j = 0; j < 100; j++)
+    {
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+        if(Value32 & PHY_STATUS_LINK_PASS)
+        {
+            break;
+        }
+        MM_Wait(40);
+    }
+
+    if(Value32 & PHY_STATUS_LINK_PASS)
+    {
+
+        /* Determine the current line and duplex settings. */
+        LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+        for(j = 0; j < 2000; j++)
+        {
+            MM_Wait(10);
+
+            LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+            if(Value32)
+            {
+                break;
+            }
+        }
+
+        switch(Value32 & BCM540X_AUX_SPEED_MASK)
+        {
+            case BCM540X_AUX_10BASET_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_10MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_10BASET_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_10MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            case BCM540X_AUX_100BASETX_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_100MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_100BASETX_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_100MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            case BCM540X_AUX_100BASET_HD:
+                CurrentLineSpeed = LM_LINE_SPEED_1000MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_HALF;
+                break;
+
+            case BCM540X_AUX_100BASET_FD:
+                CurrentLineSpeed = LM_LINE_SPEED_1000MBPS;
+                CurrentDuplexMode = LM_DUPLEX_MODE_FULL;
+                break;
+
+            default:
+
+                CurrentLineSpeed = LM_LINE_SPEED_UNKNOWN;
+                CurrentDuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+                break;
+        }
+
+        /* Make sure we are in auto-neg mode. */
+        for (j = 0; j < 200; j++)
+        {
+            LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+            if(Value32 && Value32 != 0x7fff)
+            {
+                break;
+            }
+
+            if(Value32 == 0 && pDevice->RequestedMediaType == 
+                LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS)
+            {
+                break;
+            }
+
+            MM_Wait(10);
+        }
+
+        /* Use the current line settings for "auto" mode. */
+        if(pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+            pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+        {
+            if(Value32 & PHY_CTRL_AUTO_NEG_ENABLE)
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+
+                /* We may be exiting low power mode and the link is in */
+                /* 10mb.  In this case, we need to restart autoneg. */
+                LM_ReadPhy(pDevice, BCM540X_1000BASET_CTRL_REG, &Value32);
+                pDevice->advertising1000 = Value32;
+                /* 5702FE supports 10/100Mb only. */
+                if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5703 ||
+                    pDevice->BondId != GRC_MISC_BD_ID_5702FE)
+                {
+                    if(!(Value32 & (BCM540X_AN_AD_1000BASET_HALF |
+                        BCM540X_AN_AD_1000BASET_FULL)))
+                    {
+                        CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+                    }
+                }
+            }
+            else
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+            }
+        }
+        else
+        {
+            /* Force line settings. */
+            /* Use the current setting if it matches the user's requested */
+            /* setting. */
+            LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+            if((pDevice->LineSpeed == CurrentLineSpeed) &&
+                (pDevice->DuplexMode == CurrentDuplexMode))
+            {
+                if ((pDevice->DisableAutoNeg &&
+                    !(Value32 & PHY_CTRL_AUTO_NEG_ENABLE)) ||
+                    (!pDevice->DisableAutoNeg &&
+                    (Value32 & PHY_CTRL_AUTO_NEG_ENABLE)))
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+                }
+                else
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+                } 
+            }
+            else
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_SETTING_MISMATCH;
+            } 
+        }
+
+        /* Save line settings. */
+        pDevice->LineSpeed = CurrentLineSpeed;
+        pDevice->DuplexMode = CurrentDuplexMode;
+        pDevice->MediaType = LM_MEDIA_TYPE_UTP;
+    }
+
+    return CurrentLinkStatus;
+} /* LM_InitBcm540xPhy */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetFlowControl(
+    PLM_DEVICE_BLOCK pDevice,
+    LM_UINT32 LocalPhyAd,
+    LM_UINT32 RemotePhyAd)
+{
+    LM_FLOW_CONTROL FlowCap;
+
+    /* Resolve flow control. */
+    FlowCap = LM_FLOW_CONTROL_NONE;
+
+    /* See Table 28B-3 of 802.3ab-1999 spec. */
+    if(pDevice->FlowControlCap & LM_FLOW_CONTROL_AUTO_PAUSE)
+    {
+        if(LocalPhyAd & PHY_AN_AD_PAUSE_CAPABLE)
+        {
+            if(LocalPhyAd & PHY_AN_AD_ASYM_PAUSE)
+            {
+                if(RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE)
+                {
+                    FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+                        LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+                else if(RemotePhyAd & PHY_LINK_PARTNER_ASYM_PAUSE)
+                {
+                    FlowCap = LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+            }
+            else
+            {
+                if(RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE)
+                {
+                    FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE |
+                        LM_FLOW_CONTROL_RECEIVE_PAUSE;
+                }
+            }
+        }
+        else if(LocalPhyAd & PHY_AN_AD_ASYM_PAUSE)
+        {
+            if((RemotePhyAd & PHY_LINK_PARTNER_PAUSE_CAPABLE) &&
+                (RemotePhyAd & PHY_LINK_PARTNER_ASYM_PAUSE))
+            {
+                FlowCap = LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+            }
+        }
+    }
+    else
+    {
+        FlowCap = pDevice->FlowControlCap;
+    }
+
+    /* Enable/disable rx PAUSE. */
+    pDevice->RxMode &= ~RX_MODE_ENABLE_FLOW_CONTROL;
+    if(FlowCap & LM_FLOW_CONTROL_RECEIVE_PAUSE &&
+        (pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE ||
+        pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE))
+    {
+        pDevice->FlowControl |= LM_FLOW_CONTROL_RECEIVE_PAUSE;
+        pDevice->RxMode |= RX_MODE_ENABLE_FLOW_CONTROL;
+
+    }
+    REG_WR(pDevice, MacCtrl.RxMode, pDevice->RxMode);
+
+    /* Enable/disable tx PAUSE. */
+    pDevice->TxMode &= ~TX_MODE_ENABLE_FLOW_CONTROL;
+    if(FlowCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE &&
+        (pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE ||
+        pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE))
+    {
+        pDevice->FlowControl |= LM_FLOW_CONTROL_TRANSMIT_PAUSE;
+        pDevice->TxMode |= TX_MODE_ENABLE_FLOW_CONTROL;
+
+    }
+    REG_WR(pDevice, MacCtrl.TxMode, pDevice->TxMode);
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+#if INCLUDE_TBI_SUPPORT
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_InitBcm800xPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+
+    /* Reset the SERDES during init and when we have link. */
+    if(!pDevice->InitDone || Value32 & MAC_STATUS_PCS_SYNCED)
+    {
+        /* Set PLL lock range. */
+        LM_WritePhy(pDevice, 0x16, 0x8007);
+
+        /* Software reset. */
+        LM_WritePhy(pDevice, 0x00, 0x8000);
+
+        /* Wait for reset to complete. */
+        for(j = 0; j < 500; j++)
+        {
+            MM_Wait(10);
+        }
+
+#if DBG
+        /* Verify lock (if cable attached).  Should be 0x8001. */
+        LM_ReadPhy(pDevice, 0x10, &Value32);
+        DbgMessage(INFORM, ("FiberPhy 0x10 = 0x%x\n", Value32));
+#endif
+
+        /* Config mode; seletct PMA/Ch 1 regs. */
+        LM_WritePhy(pDevice, 0x10, 0x8411);
+
+        /* Enable auto-lock and comdet, select txclk for tx. */
+        LM_WritePhy(pDevice, 0x11, 0x0a10);
+
+        LM_WritePhy(pDevice, 0x18, 0x00a0);
+        LM_WritePhy(pDevice, 0x16, 0x41ff);
+
+        /* Assert and deassert POR. */
+        LM_WritePhy(pDevice, 0x13, 0x0400);
+        MM_Wait(40);
+        LM_WritePhy(pDevice, 0x13, 0x0000);
+
+        LM_WritePhy(pDevice, 0x11, 0x0a50);
+        MM_Wait(40);
+        LM_WritePhy(pDevice, 0x11, 0x0a10);
+
+        /* Delay for signal to stabilize. */
+        for(j = 0; j < 15000; j++)
+        {
+            MM_Wait(10);
+        }
+
+        /* Deselect the channel register so we can read the PHY id later. */
+        LM_WritePhy(pDevice, 0x10, 0x8011);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+STATIC LM_STATUS
+LM_SetupFiberPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS CurrentLinkStatus;
+    AUTONEG_STATUS AnStatus = 0;
+    LM_UINT32 Value32;
+    LM_UINT32 Cnt;
+    LM_UINT32 j, k;
+
+    pDevice->MacMode &= ~(MAC_MODE_HALF_DUPLEX | MAC_MODE_PORT_MODE_MASK);
+
+    /* Initialize the send_config register. */
+    REG_WR(pDevice, MacCtrl.TxAutoNeg, 0);
+
+    /* Enable TBI and full duplex mode. */
+    pDevice->MacMode |= MAC_MODE_PORT_MODE_TBI;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    /* Initialize the BCM8002 SERDES PHY. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM8002_PHY_ID:
+            LM_InitBcm800xPhy(pDevice);
+            break;
+
+        default:
+            break;
+    }
+
+    /* Enable link change interrupt. */
+    REG_WR(pDevice, MacCtrl.MacEvent, MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN);
+
+    /* Default to link down. */
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Get the link status. */
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if(Value32 & MAC_STATUS_PCS_SYNCED)
+    {
+        if((pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO) ||
+            (pDevice->DisableAutoNeg == FALSE))
+        {
+            /* auto-negotiation mode. */
+            /* Initialize the autoneg default capaiblities. */
+            AutonegInit(&pDevice->AnInfo);
+
+            /* Set the context pointer to point to the main device structure. */
+            pDevice->AnInfo.pContext = pDevice;
+
+            /* Setup flow control advertisement register. */
+            Value32 = GetPhyAdFlowCntrlSettings(pDevice);
+            if(Value32 & PHY_AN_AD_PAUSE_CAPABLE)
+            {
+                pDevice->AnInfo.mr_adv_sym_pause = 1;
+            }
+            else
+            {
+                pDevice->AnInfo.mr_adv_sym_pause = 0;
+            }
+
+            if(Value32 & PHY_AN_AD_ASYM_PAUSE)
+            {
+                pDevice->AnInfo.mr_adv_asym_pause = 1;
+            }
+            else
+            {
+                pDevice->AnInfo.mr_adv_asym_pause = 0;
+            }
+
+            /* Try to autoneg up to six times. */
+            if (pDevice->IgnoreTbiLinkChange)
+            {
+                Cnt = 1;
+            }
+            else
+            {
+                Cnt = 6;
+            }
+            for (j = 0; j < Cnt; j++)
+            {
+                REG_WR(pDevice, MacCtrl.TxAutoNeg, 0);
+
+                Value32 = pDevice->MacMode & ~MAC_MODE_PORT_MODE_MASK;
+                REG_WR(pDevice, MacCtrl.Mode, Value32);
+                MM_Wait(20);
+
+                REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+                    MAC_MODE_SEND_CONFIGS);
+
+                MM_Wait(20);
+
+                pDevice->AnInfo.State = AN_STATE_UNKNOWN;
+                pDevice->AnInfo.CurrentTime_us = 0;
+
+                REG_WR(pDevice, Grc.Timer, 0);
+                for(k = 0; (pDevice->AnInfo.CurrentTime_us < 75000) &&
+                    (k < 75000); k++)
+                {
+                    AnStatus = Autoneg8023z(&pDevice->AnInfo);
+
+                    if((AnStatus == AUTONEG_STATUS_DONE) || 
+                        (AnStatus == AUTONEG_STATUS_FAILED))
+                    {
+                        break;
+                    }
+
+                    pDevice->AnInfo.CurrentTime_us = REG_RD(pDevice, Grc.Timer);
+                
+                }
+                if((AnStatus == AUTONEG_STATUS_DONE) || 
+                    (AnStatus == AUTONEG_STATUS_FAILED))
+                {
+                    break;
+                }
+                if (j >= 1)
+                {
+                    if (!(REG_RD(pDevice, MacCtrl.Status) &
+                        MAC_STATUS_PCS_SYNCED)) {
+                        break;
+                    }
+                }
+            }
+
+            /* Stop sending configs. */
+            MM_AnTxIdle(&pDevice->AnInfo);
+
+            /* Resolve flow control settings. */
+            if((AnStatus == AUTONEG_STATUS_DONE) &&
+                pDevice->AnInfo.mr_an_complete && pDevice->AnInfo.mr_link_ok &&
+                pDevice->AnInfo.mr_lp_adv_full_duplex)
+                {
+                LM_UINT32 RemotePhyAd;
+                LM_UINT32 LocalPhyAd;
+
+                LocalPhyAd = 0;
+                if(pDevice->AnInfo.mr_adv_sym_pause)
+                {
+                    LocalPhyAd |= PHY_AN_AD_PAUSE_CAPABLE;
+                }
+
+                if(pDevice->AnInfo.mr_adv_asym_pause)
+                {
+                    LocalPhyAd |= PHY_AN_AD_ASYM_PAUSE;
+                }
+
+                RemotePhyAd = 0;
+                if(pDevice->AnInfo.mr_lp_adv_sym_pause)
+                {
+                    RemotePhyAd |= PHY_LINK_PARTNER_PAUSE_CAPABLE;
+                }
+
+                if(pDevice->AnInfo.mr_lp_adv_asym_pause)
+                {
+                    RemotePhyAd |= PHY_LINK_PARTNER_ASYM_PAUSE;
+                }
+
+                LM_SetFlowControl(pDevice, LocalPhyAd, RemotePhyAd);
+
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+            }
+            for (j = 0; j < 30; j++)
+            {
+                MM_Wait(20);
+                REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+                    MAC_STATUS_CFG_CHANGED);
+                MM_Wait(20);
+                if ((REG_RD(pDevice, MacCtrl.Status) &
+                    (MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED)) == 0)
+                    break;
+            }
+            if (pDevice->PollTbiLink)
+            {
+                Value32 = REG_RD(pDevice, MacCtrl.Status);
+                if (Value32 & MAC_STATUS_RECEIVING_CFG)
+                {
+                    pDevice->IgnoreTbiLinkChange = TRUE;
+                }
+                else
+                {
+                    pDevice->IgnoreTbiLinkChange = FALSE;
+                }
+            }
+            Value32 = REG_RD(pDevice, MacCtrl.Status);
+            if (CurrentLinkStatus == LM_STATUS_LINK_DOWN &&
+                 (Value32 & MAC_STATUS_PCS_SYNCED) &&
+                 ((Value32 & MAC_STATUS_RECEIVING_CFG) == 0))
+            {
+                CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+            }
+        }
+        else
+        {
+            /* We are forcing line speed. */
+            pDevice->FlowControlCap &= ~LM_FLOW_CONTROL_AUTO_PAUSE;
+            LM_SetFlowControl(pDevice, 0, 0);
+
+            CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+                MAC_MODE_SEND_CONFIGS);
+        }
+    }
+    /* Set the link polarity bit. */
+    pDevice->MacMode &= ~MAC_MODE_LINK_POLARITY;
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    pDevice->pStatusBlkVirt->Status = STATUS_BLOCK_UPDATED |
+        (pDevice->pStatusBlkVirt->Status & ~STATUS_BLOCK_LINK_CHANGED_STATUS);
+
+    for (j = 0; j < 100; j++)
+    {
+        REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+            MAC_STATUS_CFG_CHANGED);
+        MM_Wait(5);
+        if ((REG_RD(pDevice, MacCtrl.Status) &
+            (MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED)) == 0)
+            break;
+    }
+
+    Value32 = REG_RD(pDevice, MacCtrl.Status);
+    if((Value32 & MAC_STATUS_PCS_SYNCED) == 0)
+    {
+        CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+        if (pDevice->DisableAutoNeg == FALSE)
+        {
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode |
+                MAC_MODE_SEND_CONFIGS);
+            MM_Wait(1);
+            REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+        }
+    }
+
+    /* Initialize the current link status. */
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+        REG_WR(pDevice, MacCtrl.LedCtrl, LED_CTRL_OVERRIDE_LINK_LED |
+            LED_CTRL_1000MBPS_LED_ON);
+    }
+    else
+    {
+        pDevice->LineSpeed = LM_LINE_SPEED_UNKNOWN;
+        pDevice->DuplexMode = LM_DUPLEX_MODE_UNKNOWN;
+        REG_WR(pDevice, MacCtrl.LedCtrl, LED_CTRL_OVERRIDE_LINK_LED |
+            LED_CTRL_OVERRIDE_TRAFFIC_LED);
+    }
+
+    /* Indicate link status. */
+    if (pDevice->LinkStatus != CurrentLinkStatus) {
+        pDevice->LinkStatus = CurrentLinkStatus;
+        MM_IndicateStatus(pDevice, CurrentLinkStatus);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+#endif /* INCLUDE_TBI_SUPPORT */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetupCopperPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS CurrentLinkStatus;
+    LM_UINT32 Value32;
+
+    /* Assume there is not link first. */
+    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+
+    /* Disable phy link change attention. */
+    REG_WR(pDevice, MacCtrl.MacEvent, 0);
+
+    /* Clear link change attention. */
+    REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+        MAC_STATUS_CFG_CHANGED);
+
+    /* Disable auto-polling for the moment. */
+    pDevice->MiMode = 0xc0000;
+    REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    MM_Wait(40);
+
+    /* Determine the requested line speed and duplex. */
+    pDevice->OldLineSpeed = pDevice->LineSpeed;
+    LM_TranslateRequestedMediaType(pDevice->RequestedMediaType,
+        &pDevice->MediaType, &pDevice->LineSpeed, &pDevice->DuplexMode);
+
+    /* Initialize the phy chip. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+        case PHY_BCM5401_PHY_ID:
+        case PHY_BCM5411_PHY_ID:
+        case PHY_BCM5701_PHY_ID:
+        case PHY_BCM5703_PHY_ID:
+            CurrentLinkStatus = LM_InitBcm540xPhy(pDevice);
+            break;
+
+        default:
+            break;
+    }
+
+    if(CurrentLinkStatus == LM_STATUS_LINK_SETTING_MISMATCH)
+    {
+        CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+    }
+    
+    /* Setup flow control. */
+    pDevice->FlowControl = LM_FLOW_CONTROL_NONE;
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        LM_FLOW_CONTROL FlowCap;     /* Flow control capability. */
+
+        FlowCap = LM_FLOW_CONTROL_NONE;
+
+        if(pDevice->DuplexMode == LM_DUPLEX_MODE_FULL)
+        {
+            if(pDevice->DisableAutoNeg == FALSE ||
+                pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+                pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+            {
+                LM_UINT32 ExpectedPhyAd;
+                LM_UINT32 LocalPhyAd;
+                LM_UINT32 RemotePhyAd;
+
+                LM_ReadPhy(pDevice, PHY_AN_AD_REG, &LocalPhyAd);
+		pDevice->advertising = LocalPhyAd;
+                LocalPhyAd &= (PHY_AN_AD_ASYM_PAUSE | PHY_AN_AD_PAUSE_CAPABLE);
+
+                ExpectedPhyAd = GetPhyAdFlowCntrlSettings(pDevice);
+
+                if(LocalPhyAd != ExpectedPhyAd)
+                {
+                    CurrentLinkStatus = LM_STATUS_LINK_DOWN;
+                }
+                else
+                {
+                    LM_ReadPhy(pDevice, PHY_LINK_PARTNER_ABILITY_REG,
+                        &RemotePhyAd);
+
+                    LM_SetFlowControl(pDevice, LocalPhyAd, RemotePhyAd);
+                }
+            }
+            else
+            {
+                pDevice->FlowControlCap &= ~LM_FLOW_CONTROL_AUTO_PAUSE;
+                LM_SetFlowControl(pDevice, 0, 0);
+            }
+        }
+    }
+
+    if(CurrentLinkStatus == LM_STATUS_LINK_DOWN)
+    {
+        LM_ForceAutoNeg(pDevice, pDevice->RequestedMediaType, FALSE);
+
+        /* If we force line speed, we make get link right away. */
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+        if(Value32 & PHY_STATUS_LINK_PASS)
+        {
+            CurrentLinkStatus = LM_STATUS_LINK_ACTIVE;
+        }
+    }
+
+    /* GMII interface. */
+    pDevice->MacMode &= ~MAC_MODE_PORT_MODE_MASK;
+    if(CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+    {
+        if(pDevice->LineSpeed == LM_LINE_SPEED_100MBPS ||
+            pDevice->LineSpeed == LM_LINE_SPEED_10MBPS)
+        {
+            pDevice->MacMode |= MAC_MODE_PORT_MODE_MII;
+        }
+        else
+        {
+            pDevice->MacMode |= MAC_MODE_PORT_MODE_GMII;
+        }
+    }
+    else {
+        pDevice->MacMode |= MAC_MODE_PORT_MODE_GMII;
+    }
+
+    /* Set the MAC to operate in the appropriate duplex mode. */
+    pDevice->MacMode &= ~MAC_MODE_HALF_DUPLEX;
+    if(pDevice->DuplexMode == LM_DUPLEX_MODE_HALF)
+    {
+        pDevice->MacMode |= MAC_MODE_HALF_DUPLEX;
+    }
+
+    /* Set the link polarity bit. */
+    pDevice->MacMode &= ~MAC_MODE_LINK_POLARITY;
+    if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+    {
+        if((pDevice->LedMode == LED_MODE_LINK10) ||
+             (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE &&
+             pDevice->LineSpeed == LM_LINE_SPEED_10MBPS))
+        {
+            pDevice->MacMode |= MAC_MODE_LINK_POLARITY;
+        }
+    }
+    else
+    {
+        if (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE)
+        {
+            pDevice->MacMode |= MAC_MODE_LINK_POLARITY;
+        }
+
+        /* Set LED mode. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = LED_CTRL_PHY_MODE_1;
+        }
+        else
+        {
+            if(pDevice->LedMode == LED_MODE_OUTPUT)
+            {
+                Value32 = LED_CTRL_PHY_MODE_2;
+            }
+            else
+            {
+                Value32 = LED_CTRL_PHY_MODE_1;
+            }
+        }
+        REG_WR(pDevice, MacCtrl.LedCtrl, Value32);
+    }
+
+    REG_WR(pDevice, MacCtrl.Mode, pDevice->MacMode);
+
+    /* Enable auto polling. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        pDevice->MiMode |= MI_MODE_AUTO_POLLING_ENABLE;
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+    }
+
+    /* Enable phy link change attention. */
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_MI_INTERRUPT)
+    {
+        REG_WR(pDevice, MacCtrl.MacEvent, MAC_EVENT_ENABLE_MI_INTERRUPT);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.MacEvent, 
+            MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN);
+    }
+    if ((T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700) &&
+        (CurrentLinkStatus == LM_STATUS_LINK_ACTIVE) &&
+        (pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) &&
+        (((pDevice->PciState & T3_PCI_STATE_CONVENTIONAL_PCI_MODE) &&
+          (pDevice->PciState & T3_PCI_STATE_BUS_SPEED_HIGH)) ||
+         !(pDevice->PciState & T3_PCI_STATE_CONVENTIONAL_PCI_MODE)))
+    {
+        MM_Wait(120);
+        REG_WR(pDevice, MacCtrl.Status, MAC_STATUS_SYNC_CHANGED |
+            MAC_STATUS_CFG_CHANGED);
+        MEM_WR_OFFSET(pDevice, T3_FIRMWARE_MAILBOX,
+            T3_MAGIC_NUM_DISABLE_DMAW_ON_LINK_CHANGE);
+    }
+
+    /* Indicate link status. */
+    if (pDevice->LinkStatus != CurrentLinkStatus) {
+        pDevice->LinkStatus = CurrentLinkStatus;
+        MM_IndicateStatus(pDevice, CurrentLinkStatus);
+    }
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetupCopperPhy */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetupPhy(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_STATUS LmStatus;
+
+#if INCLUDE_TBI_SUPPORT
+    if(pDevice->EnableTbi)
+    {
+        LmStatus = LM_SetupFiberPhy(pDevice);
+    }
+    else
+#endif /* INCLUDE_TBI_SUPPORT */
+    {
+        LmStatus = LM_SetupCopperPhy(pDevice);
+    }
+    if ((pDevice->LineSpeed == LM_LINE_SPEED_1000MBPS) &&
+        (pDevice->DuplexMode == LM_DUPLEX_MODE_HALF))
+    {
+        REG_WR(pDevice, MacCtrl.TxLengths, 0x26ff);
+    }
+    else
+    {
+        REG_WR(pDevice, MacCtrl.TxLengths, 0x2620);
+    }
+
+    return LmStatus;
+}
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_ReadPhy(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 PhyReg,
+PLM_UINT32 pData32) {
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode &
+            ~MI_MODE_AUTO_POLLING_ENABLE);
+        MM_Wait(40);
+    }
+
+    Value32 = (pDevice->PhyAddr << MI_COM_FIRST_PHY_ADDR_BIT) |
+        ((PhyReg & MI_COM_PHY_REG_ADDR_MASK) << MI_COM_FIRST_PHY_REG_ADDR_BIT) |
+        MI_COM_CMD_READ | MI_COM_START;
+
+    REG_WR(pDevice, MacCtrl.MiCom, Value32);
+    
+    for(j = 0; j < 20; j++)
+    {
+        MM_Wait(25);
+
+        Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+
+        if(!(Value32 & MI_COM_BUSY))
+        {
+            MM_Wait(5);
+            Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+            Value32 &= MI_COM_PHY_DATA_MASK;
+            break;
+        }
+    }
+
+    if(Value32 & MI_COM_BUSY)
+    {
+        Value32 = 0;
+    }
+
+    *pData32 = Value32;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+        MM_Wait(40);
+    }
+} /* LM_ReadPhy */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_VOID
+LM_WritePhy(
+PLM_DEVICE_BLOCK pDevice,
+LM_UINT32 PhyReg,
+LM_UINT32 Data32) {
+    LM_UINT32 Value32;
+    LM_UINT32 j;
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode &
+            ~MI_MODE_AUTO_POLLING_ENABLE);
+        MM_Wait(40);
+    }
+
+    Value32 = (pDevice->PhyAddr << MI_COM_FIRST_PHY_ADDR_BIT) |
+        ((PhyReg & MI_COM_PHY_REG_ADDR_MASK) << MI_COM_FIRST_PHY_REG_ADDR_BIT) |
+        (Data32 & MI_COM_PHY_DATA_MASK) | MI_COM_CMD_WRITE | MI_COM_START;
+
+    REG_WR(pDevice, MacCtrl.MiCom, Value32);
+    
+    for(j = 0; j < 20; j++)
+    {
+        MM_Wait(25);
+
+        Value32 = REG_RD(pDevice, MacCtrl.MiCom);
+
+        if(!(Value32 & MI_COM_BUSY))
+        {
+            MM_Wait(5);
+            break;
+        }
+    }
+
+    if(pDevice->PhyIntMode == T3_PHY_INT_MODE_AUTO_POLLING)
+    {
+        REG_WR(pDevice, MacCtrl.MiMode, pDevice->MiMode);
+        MM_Wait(40);
+    }
+} /* LM_WritePhy */
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS
+LM_SetPowerState(
+PLM_DEVICE_BLOCK pDevice,
+LM_POWER_STATE PowerLevel) {
+    LM_UINT32 PmeSupport;
+    LM_UINT32 Value32;
+    LM_UINT32 PmCtrl;
+
+    /* make sureindirect accesses are enabled*/
+    MM_WriteConfig32(pDevice, T3_PCI_MISC_HOST_CTRL_REG, pDevice->MiscHostCtrl);
+
+    /* Clear the PME_ASSERT bit and the power state bits.  Also enable */
+    /* the PME bit. */
+    MM_ReadConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, &PmCtrl);
+
+    PmCtrl |= T3_PM_PME_ASSERTED;
+    PmCtrl &= ~T3_PM_POWER_STATE_MASK;
+
+    /* Set the appropriate power state. */
+    if(PowerLevel == LM_POWER_STATE_D0)
+    {
+
+        /* Bring the card out of low power mode. */
+        PmCtrl |= T3_PM_POWER_STATE_D0;
+        MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, PmCtrl);
+
+        REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl);
+	MM_Wait(40);	/* Required delay is about 20us. */
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x02);
+
+        return LM_STATUS_SUCCESS;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D1)
+    {
+        PmCtrl |= T3_PM_POWER_STATE_D1;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D2)
+    {
+        PmCtrl |= T3_PM_POWER_STATE_D2;
+    }
+    else if(PowerLevel == LM_POWER_STATE_D3)
+    {
+        PmCtrl |= T3_PM_POWER_STATE_D3;
+    }
+    else
+    {
+        return LM_STATUS_FAILURE;
+    }
+    PmCtrl |= T3_PM_PME_ENABLE;
+
+#if 0
+    /* No WOL. */
+    if(pDevice->WakeUpModeCap == LM_WAKE_UP_MODE_NONE)
+    {
+        DbgMessage(INFORM, ("No power capabilities.\n"));
+        return LM_STATUS_FAILURE;
+    }
+#endif
+
+    /* Mask out all interrupts so LM_SetupPhy won't be called while we are */
+    /* setting new line speed. */
+    Value32 = REG_RD(pDevice, PciCfg.MiscHostCtrl);
+    REG_WR(pDevice, PciCfg.MiscHostCtrl, Value32 | MISC_HOST_CTRL_MASK_PCI_INT);
+
+    if(!pDevice->RestoreOnWakeUp)
+    {
+        pDevice->RestoreOnWakeUp = TRUE;
+        pDevice->WakeUpDisableAutoNeg = pDevice->DisableAutoNeg;
+        pDevice->WakeUpRequestedMediaType = pDevice->RequestedMediaType;
+    }
+
+    /* Force auto-negotiation to 10 line speed. */
+    pDevice->DisableAutoNeg = FALSE;
+    pDevice->RequestedMediaType = LM_REQUESTED_MEDIA_TYPE_UTP_10MBPS;
+    LM_SetupPhy(pDevice);
+
+    /* Put the driver in the initial state, and go through the power down */
+    /* sequence. */
+    LM_Halt(pDevice);
+
+    MM_ReadConfig32(pDevice, T3_PCI_PM_CAP_REG, &PmeSupport);
+
+    if (pDevice->WakeUpModeCap != LM_WAKE_UP_MODE_NONE)
+    {
+
+        /* Enable WOL. */
+        LM_WritePhy(pDevice, BCM5401_AUX_CTRL, 0x5a);
+        MM_Wait(40);
+
+        /* Set LED mode. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = LED_CTRL_PHY_MODE_1;
+        }
+        else
+        {
+            if(pDevice->LedMode == LED_MODE_OUTPUT)
+            {
+                Value32 = LED_CTRL_PHY_MODE_2;
+            }
+            else
+            {
+                Value32 = LED_CTRL_PHY_MODE_1;
+            }
+        }
+
+        Value32 = MAC_MODE_PORT_MODE_MII;
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700)
+        {
+            if(pDevice->LedMode == LED_MODE_LINK10 ||
+                pDevice->WolSpeed == WOL_SPEED_10MB)
+            {
+                Value32 |= MAC_MODE_LINK_POLARITY;
+            }
+        }
+        else
+        {
+            Value32 |= MAC_MODE_LINK_POLARITY;
+        }
+
+        /* Always enable magic packet wake-up if we have vaux. */
+        if((PmeSupport & T3_PCI_PM_CAP_PME_D3COLD) && 
+            (pDevice->WakeUpModeCap & LM_WAKE_UP_MODE_MAGIC_PACKET))
+        {
+            Value32 |= MAC_MODE_DETECT_MAGIC_PACKET_ENABLE;
+        }
+
+        REG_WR(pDevice, MacCtrl.Mode, Value32);
+
+        /* Enable the receiver. */
+        REG_WR(pDevice, MacCtrl.RxMode, RX_MODE_ENABLE);
+    }
+
+    /* Disable tx/rx clocks, and seletect an alternate clock. */
+    if(pDevice->WolSpeed == WOL_SPEED_100MB)
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK;
+        }
+        else
+        {
+            Value32 = T3_PCI_SELECT_ALTERNATE_CLOCK;
+        }
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+
+        MM_Wait(40);
+
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK | T3_PCI_44MHZ_CORE_CLOCK;
+        }
+        else
+        {
+            Value32 = T3_PCI_SELECT_ALTERNATE_CLOCK |
+                T3_PCI_44MHZ_CORE_CLOCK;
+        }
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+
+        MM_Wait(40);
+
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_44MHZ_CORE_CLOCK;
+        }
+        else
+        {
+            Value32 = T3_PCI_44MHZ_CORE_CLOCK;
+        }
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+    }
+    else
+    {
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            Value32 = T3_PCI_DISABLE_RX_CLOCK | T3_PCI_DISABLE_TX_CLOCK |
+                T3_PCI_SELECT_ALTERNATE_CLOCK |
+                T3_PCI_POWER_DOWN_PCI_PLL133;
+        }
+        else
+        {
+            Value32 = T3_PCI_SELECT_ALTERNATE_CLOCK |
+                T3_PCI_POWER_DOWN_PCI_PLL133;
+        }
+
+        REG_WR(pDevice, PciCfg.ClockCtrl, Value32);
+    }
+
+    MM_Wait(40);
+
+    if(!pDevice->EepromWp && (pDevice->WakeUpModeCap != LM_WAKE_UP_MODE_NONE))
+    {
+        /* Switch adapter to auxilliary power. */
+        if(T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5700 ||
+            T3_ASIC_REV(pDevice->ChipRevId) == T3_ASIC_REV_5701)
+        {
+            /* GPIO0 = 1, GPIO1 = 1, GPIO2 = 0. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1);
+                MM_Wait(40);
+        }
+        else
+        {
+            /* GPIO0 = 0, GPIO1 = 1, GPIO2 = 1. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT2);
+                MM_Wait(40);
+
+            /* GPIO0 = 1, GPIO1 = 1, GPIO2 = 1. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT2);
+                MM_Wait(40);
+
+            /* GPIO0 = 1, GPIO1 = 1, GPIO2 = 0. */
+            REG_WR(pDevice, Grc.LocalCtrl, pDevice->GrcLocalCtrl |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE0 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OE1 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OE2 | 
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0 |
+                GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1);
+                MM_Wait(40);
+        }
+    }
+
+    /* Set the phy to low power mode. */
+    /* Put the the hardware in low power mode. */
+    MM_WriteConfig32(pDevice, T3_PCI_PM_STATUS_CTRL_REG, PmCtrl);
+
+    return LM_STATUS_SUCCESS;
+} /* LM_SetPowerState */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+static LM_UINT32
+GetPhyAdFlowCntrlSettings(
+    PLM_DEVICE_BLOCK pDevice)
+{
+    LM_UINT32 Value32;
+
+    Value32 = 0;
+
+    /* Auto negotiation flow control only when autonegotiation is enabled. */
+    if(pDevice->DisableAutoNeg == FALSE ||
+        pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_AUTO ||
+        pDevice->RequestedMediaType == LM_REQUESTED_MEDIA_TYPE_UTP_AUTO)
+    {
+        /* Please refer to Table 28B-3 of the 802.3ab-1999 spec. */
+        if((pDevice->FlowControlCap == LM_FLOW_CONTROL_AUTO_PAUSE) ||
+            ((pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE) &&
+            (pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE)))
+        {
+            Value32 |= PHY_AN_AD_PAUSE_CAPABLE;
+        }
+        else if(pDevice->FlowControlCap & LM_FLOW_CONTROL_TRANSMIT_PAUSE)
+        {
+            Value32 |= PHY_AN_AD_ASYM_PAUSE;
+        }
+        else if(pDevice->FlowControlCap & LM_FLOW_CONTROL_RECEIVE_PAUSE)
+        {
+            Value32 |= PHY_AN_AD_PAUSE_CAPABLE | PHY_AN_AD_ASYM_PAUSE;
+        }
+    }
+
+    return Value32;
+}
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/*    LM_STATUS_FAILURE                                                       */
+/*    LM_STATUS_SUCCESS                                                       */
+/*                                                                            */
+/*    If WaitForLink is TRUE, the return code is one of the following.        */
+/*       LM_STATUS_LINK_DOWN                                                  */
+/*       LM_STATUS_LINK_ACTIVE                                                */
+/******************************************************************************/
+static LM_STATUS
+LM_ForceAutoNegBcm540xPhy(
+PLM_DEVICE_BLOCK pDevice, 
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+LM_BOOL WaitForLink)
+{
+    LM_MEDIA_TYPE MediaType;
+    LM_LINE_SPEED LineSpeed;
+    LM_DUPLEX_MODE DuplexMode;
+    LM_UINT32 NewPhyCtrl;
+    LM_STATUS LmStatus;
+    LM_UINT32 Value32;
+    LM_UINT32 Cnt;
+
+    /* Get the interface type, line speed, and duplex mode. */
+    LM_TranslateRequestedMediaType(RequestedMediaType, &MediaType, &LineSpeed,
+        &DuplexMode);
+
+    if (pDevice->RestoreOnWakeUp)
+    {
+        LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+        pDevice->advertising1000 = 0;
+        Value32 = PHY_AN_AD_10BASET_FULL | PHY_AN_AD_10BASET_HALF;
+        if (pDevice->WolSpeed == WOL_SPEED_100MB)
+        {
+            Value32 |= PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+        }
+        Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+        Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+        LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+        pDevice->advertising = Value32;
+    }
+    /* Setup the auto-negotiation advertisement register. */
+    else if(LineSpeed == LM_LINE_SPEED_UNKNOWN)
+    {
+        /* Setup the 10/100 Mbps auto-negotiation advertisement register. */
+        Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD |
+            PHY_AN_AD_10BASET_HALF | PHY_AN_AD_10BASET_FULL |
+            PHY_AN_AD_100BASETX_FULL | PHY_AN_AD_100BASETX_HALF;
+        Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+        LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+        pDevice->advertising = Value32;
+
+        /* Advertise 1000Mbps */
+        Value32 = BCM540X_AN_AD_1000BASET_HALF | BCM540X_AN_AD_1000BASET_FULL;
+
+#if INCLUDE_5701_AX_FIX
+        /* Bug: workaround for CRC error in gigabit mode when we are in */
+        /* slave mode.  This will force the PHY to operate in */
+        /* master mode. */
+        if(pDevice->ChipRevId == T3_CHIP_ID_5701_A0 ||
+            pDevice->ChipRevId == T3_CHIP_ID_5701_B0)
+        {
+            Value32 |= BCM540X_CONFIG_AS_MASTER |
+                BCM540X_ENABLE_CONFIG_AS_MASTER;
+        }
+#endif
+
+        LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+        pDevice->advertising1000 = Value32;
+    }
+    else
+    {
+        if(LineSpeed == LM_LINE_SPEED_1000MBPS)
+        {
+            Value32 = PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+            pDevice->advertising = Value32;
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = BCM540X_AN_AD_1000BASET_HALF;
+            }
+            else
+            {
+                Value32 = BCM540X_AN_AD_1000BASET_FULL;
+            }
+
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, Value32);
+            pDevice->advertising1000 = Value32;
+        }
+        else if(LineSpeed == LM_LINE_SPEED_100MBPS)
+        {
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+            pDevice->advertising1000 = 0;
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = PHY_AN_AD_100BASETX_HALF;
+            }
+            else
+            {
+                Value32 = PHY_AN_AD_100BASETX_FULL;
+            }
+
+            Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+            pDevice->advertising = Value32;
+        }
+        else if(LineSpeed == LM_LINE_SPEED_10MBPS)
+        {
+            LM_WritePhy(pDevice, BCM540X_1000BASET_CTRL_REG, 0);
+            pDevice->advertising1000 = 0;
+
+            if(DuplexMode != LM_DUPLEX_MODE_FULL)
+            {
+                Value32 = PHY_AN_AD_10BASET_HALF;
+            }
+            else
+            {
+                Value32 = PHY_AN_AD_10BASET_FULL;
+            }
+
+            Value32 |= PHY_AN_AD_PROTOCOL_802_3_CSMA_CD;
+            Value32 |= GetPhyAdFlowCntrlSettings(pDevice);
+
+            LM_WritePhy(pDevice, PHY_AN_AD_REG, Value32);
+            pDevice->advertising = Value32;
+        }
+    }
+
+    /* Force line speed if auto-negotiation is disabled. */
+    if(pDevice->DisableAutoNeg && LineSpeed != LM_LINE_SPEED_UNKNOWN)
+    {
+        /* This code path is executed only when there is link. */
+        pDevice->MediaType = MediaType;
+        pDevice->LineSpeed = LineSpeed;
+        pDevice->DuplexMode = DuplexMode;
+
+        /* Force line seepd. */
+        NewPhyCtrl = 0;
+        switch(LineSpeed)
+        {
+            case LM_LINE_SPEED_10MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_10MBPS;
+                break;
+            case LM_LINE_SPEED_100MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_100MBPS;
+                break;
+            case LM_LINE_SPEED_1000MBPS:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_1000MBPS;
+                break;
+            default:
+                NewPhyCtrl |= PHY_CTRL_SPEED_SELECT_1000MBPS;
+                break;
+        }
+
+        if(DuplexMode == LM_DUPLEX_MODE_FULL)
+        {
+            NewPhyCtrl |= PHY_CTRL_FULL_DUPLEX_MODE;
+        }
+
+        /* Don't do anything if the PHY_CTRL is already what we wanted. */
+        LM_ReadPhy(pDevice, PHY_CTRL_REG, &Value32);
+        if(Value32 != NewPhyCtrl)
+        {
+            /* Temporary bring the link down before forcing line speed. */
+            LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_LOOPBACK_MODE);
+            
+            /* Wait for link to go down. */
+            for(Cnt = 0; Cnt < 15000; Cnt++)
+            {
+                MM_Wait(10);
+
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+                LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+                if(!(Value32 & PHY_STATUS_LINK_PASS))
+                {
+                    MM_Wait(40);
+                    break;
+                }
+            }
+
+            LM_WritePhy(pDevice, PHY_CTRL_REG, NewPhyCtrl);
+            MM_Wait(40);
+        }
+    }
+    else
+    {
+        LM_WritePhy(pDevice, PHY_CTRL_REG, PHY_CTRL_AUTO_NEG_ENABLE |
+            PHY_CTRL_RESTART_AUTO_NEG);
+    }
+
+    /* Wait for link. */
+    LmStatus = LM_STATUS_SUCCESS;
+    if(WaitForLink)
+    {
+        LmStatus = LM_STATUS_LINK_DOWN;
+
+        /* Wait for link up to 3 seconds. */
+        for(Cnt = 0; Cnt < 300000; Cnt++)
+        {
+            MM_Wait(10);
+
+            /* Get the current PHY status. */
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+            LM_ReadPhy(pDevice, PHY_STATUS_REG, &Value32);
+
+            /* Link ok? */
+            if(Value32 & PHY_STATUS_LINK_PASS)
+            {
+                LmStatus = LM_STATUS_LINK_ACTIVE;
+                pDevice->MediaType = LM_MEDIA_TYPE_UTP;
+
+                /* Determine the current line and duplex settings. */
+                LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+                LM_ReadPhy(pDevice, BCM540X_AUX_STATUS_REG, &Value32);
+
+                switch(Value32 & BCM540X_AUX_SPEED_MASK)
+                {
+                    case BCM540X_AUX_10BASET_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_10MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_10BASET_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_10MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    case BCM540X_AUX_100BASETX_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_100MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_100BASETX_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_100MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    case BCM540X_AUX_100BASET_HD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_HALF;
+                        break;
+
+                    case BCM540X_AUX_100BASET_FD:
+                        pDevice->LineSpeed = LM_LINE_SPEED_1000MBPS;
+                        pDevice->DuplexMode = LM_DUPLEX_MODE_FULL;
+                        break;
+
+                    default:
+                        LmStatus = LM_STATUS_LINK_DOWN;
+                        break;
+                }
+
+                break;
+            }
+        }
+
+        /* Acknowledge interrupts. */
+        LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+        LM_ReadPhy(pDevice, BCM540X_INT_STATUS_REG, &Value32);
+    }
+
+    return LmStatus;
+} /* LM_ForceAutoNegBcm540xPhy */
+
+
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+static LM_STATUS
+LM_ForceAutoNeg(
+PLM_DEVICE_BLOCK pDevice, 
+LM_REQUESTED_MEDIA_TYPE RequestedMediaType,
+LM_BOOL WaitForLink) {
+    LM_STATUS LmStatus;
+
+    /* Initialize the phy chip. */
+    switch(pDevice->PhyId & PHY_ID_MASK)
+    {
+        case PHY_BCM5400_PHY_ID:
+        case PHY_BCM5401_PHY_ID:
+        case PHY_BCM5411_PHY_ID:
+        case PHY_BCM5701_PHY_ID:
+        case PHY_BCM5703_PHY_ID:
+            LmStatus = LM_ForceAutoNegBcm540xPhy(pDevice, RequestedMediaType, 
+                WaitForLink);
+            break;
+
+        default:
+            LmStatus = LM_STATUS_FAILURE;
+            break;
+    }
+
+    return LmStatus;
+} /* LM_ForceAutoNeg */
+
+/******************************************************************************/
+/* Description:                                                               */
+/*                                                                            */
+/* Return:                                                                    */
+/******************************************************************************/
+LM_STATUS LM_LoadFirmware(PLM_DEVICE_BLOCK pDevice,
+                          PT3_FWIMG_INFO pFwImg,
+                          LM_UINT32 LoadCpu,
+                          LM_UINT32 StartCpu)
+{
+    LM_UINT32 i;
+    LM_UINT32 address;
+
+    if (LoadCpu & T3_RX_CPU_ID)
+    {
+        if (LM_HaltCpu(pDevice,T3_RX_CPU_ID) != LM_STATUS_SUCCESS)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        /* First of all clear scrach pad memory */
+        for (i = 0; i < T3_RX_CPU_SPAD_SIZE; i+=4)
+        { 
+            LM_RegWrInd(pDevice,T3_RX_CPU_SPAD_ADDR+i,0);
+        }
+
+        /* Copy code first */
+        address = T3_RX_CPU_SPAD_ADDR + (pFwImg->Text.Offset & 0xffff);
+        for (i = 0; i <= pFwImg->Text.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Text.Buffer)[i/4]);
+        }
+
+        address = T3_RX_CPU_SPAD_ADDR + (pFwImg->ROnlyData.Offset & 0xffff);
+        for (i = 0; i <= pFwImg->ROnlyData.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->ROnlyData.Buffer)[i/4]);
+        }
+
+        address = T3_RX_CPU_SPAD_ADDR + (pFwImg->Data.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->Data.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Data.Buffer)[i/4]);
+        }
+    }
+
+    if (LoadCpu & T3_TX_CPU_ID)
+    {
+        if (LM_HaltCpu(pDevice,T3_TX_CPU_ID) != LM_STATUS_SUCCESS)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        /* First of all clear scrach pad memory */
+        for (i = 0; i < T3_TX_CPU_SPAD_SIZE; i+=4)
+        { 
+            LM_RegWrInd(pDevice,T3_TX_CPU_SPAD_ADDR+i,0);
+        }
+
+        /* Copy code first */
+        address = T3_TX_CPU_SPAD_ADDR + (pFwImg->Text.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->Text.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Text.Buffer)[i/4]);
+        }
+
+        address = T3_TX_CPU_SPAD_ADDR + (pFwImg->ROnlyData.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->ROnlyData.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->ROnlyData.Buffer)[i/4]);
+        }
+
+        address = T3_TX_CPU_SPAD_ADDR + (pFwImg->Data.Offset & 0xffff);
+        for (i= 0; i <= pFwImg->Data.Length; i+=4)
+        {
+            LM_RegWrInd(pDevice,address+i,
+                        ((LM_UINT32 *)pFwImg->Data.Buffer)[i/4]);
+        }
+    }
+
+    if (StartCpu & T3_RX_CPU_ID)
+    {
+        /* Start Rx CPU */
+        REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,rxCpu.reg.PC,pFwImg->StartAddress);
+        for (i = 0 ; i < 5; i++)
+        {
+          if (pFwImg->StartAddress == REG_RD(pDevice,rxCpu.reg.PC))
+             break;
+
+          REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+          REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_HALT);
+          REG_WR(pDevice,rxCpu.reg.PC,pFwImg->StartAddress);
+          MM_Wait(1000);
+        }
+
+        REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,rxCpu.reg.mode, 0);
+    }
+
+    if (StartCpu & T3_TX_CPU_ID)
+    {
+        /* Start Tx CPU */
+        REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,txCpu.reg.PC,pFwImg->StartAddress);
+        for (i = 0 ; i < 5; i++)
+        {
+          if (pFwImg->StartAddress == REG_RD(pDevice,txCpu.reg.PC))
+             break;
+
+          REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+          REG_WR(pDevice,txCpu.reg.mode,CPU_MODE_HALT);
+          REG_WR(pDevice,txCpu.reg.PC,pFwImg->StartAddress);
+          MM_Wait(1000);
+        }
+        
+        REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,txCpu.reg.mode, 0);
+    }
+    
+    return LM_STATUS_SUCCESS;
+}
+
+STATIC LM_STATUS LM_HaltCpu(PLM_DEVICE_BLOCK pDevice,LM_UINT32 cpu_number)
+{
+    LM_UINT32 i;
+
+    if (cpu_number == T3_RX_CPU_ID)
+    {
+        for (i = 0 ; i < 10000; i++)
+        {
+            REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+            REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_HALT);
+
+            if (REG_RD(pDevice,rxCpu.reg.mode) & CPU_MODE_HALT)
+              break;
+        }
+
+        REG_WR(pDevice,rxCpu.reg.state, 0xffffffff);
+        REG_WR(pDevice,rxCpu.reg.mode,CPU_MODE_HALT);
+        MM_Wait(10);
+    }
+    else
+    {
+        for (i = 0 ; i < 10000; i++)
+        {
+            REG_WR(pDevice,txCpu.reg.state, 0xffffffff);
+            REG_WR(pDevice,txCpu.reg.mode,CPU_MODE_HALT);
+
+            if (REG_RD(pDevice,txCpu.reg.mode) & CPU_MODE_HALT)
+               break;
+        }
+    }
+
+  return (( i == 10000) ? LM_STATUS_FAILURE : LM_STATUS_SUCCESS);
+}
+
+
+int
+LM_BlinkLED(PLM_DEVICE_BLOCK pDevice, LM_UINT32 BlinkDurationSec)
+{
+	LM_UINT32 Oldcfg;
+	int j;
+	int ret = 0;
+
+	if(BlinkDurationSec == 0)
+	{
+		return 0;
+        }
+	if(BlinkDurationSec > 120)
+        {
+	        BlinkDurationSec = 120;
+	}
+
+	Oldcfg = REG_RD(pDevice, MacCtrl.LedCtrl);
+	for(j = 0; j < BlinkDurationSec * 2; j++)
+	{
+		if(j % 2)
+		{
+			// Turn on the LEDs.
+			REG_WR(pDevice, MacCtrl.LedCtrl,
+				LED_CTRL_OVERRIDE_LINK_LED |
+				LED_CTRL_1000MBPS_LED_ON |
+				LED_CTRL_100MBPS_LED_ON |
+				LED_CTRL_10MBPS_LED_ON |
+				LED_CTRL_OVERRIDE_TRAFFIC_LED |
+				LED_CTRL_BLINK_TRAFFIC_LED |
+				LED_CTRL_TRAFFIC_LED);
+		}
+		else
+		{
+			// Turn off the LEDs.
+			REG_WR(pDevice, MacCtrl.LedCtrl,
+				LED_CTRL_OVERRIDE_LINK_LED |
+				LED_CTRL_OVERRIDE_TRAFFIC_LED);
+		}
+		current->state = TASK_INTERRUPTIBLE;
+		if (schedule_timeout(HZ/2) != 0) {
+			ret = -EINTR;
+			break;
+		}
+	}
+	REG_WR(pDevice, MacCtrl.LedCtrl, Oldcfg);
+	return ret;
+}
+
+int t3_do_dma(PLM_DEVICE_BLOCK pDevice, 
+                   LM_PHYSICAL_ADDRESS host_addr_phy, int length,
+                   int dma_read)
+{
+    T3_DMA_DESC dma_desc;
+    int i;
+    LM_UINT32 dma_desc_addr;
+    LM_UINT32 value32;
+
+    REG_WR(pDevice, BufMgr.Mode, 0);
+    REG_WR(pDevice, Ftq.Reset, 0);
+
+    dma_desc.host_addr.High = host_addr_phy.High;
+    dma_desc.host_addr.Low = host_addr_phy.Low;
+    dma_desc.nic_mbuf = 0x2100;
+    dma_desc.len = length;
+    dma_desc.flags = 0x00000004; /* Generate Rx-CPU event */
+
+    if (dma_read)
+    {
+        dma_desc.cqid_sqid = (T3_QID_RX_BD_COMP << 8) |
+            T3_QID_DMA_HIGH_PRI_READ;
+        REG_WR(pDevice, DmaRead.Mode, DMA_READ_MODE_ENABLE);
+    }
+    else
+    {
+        dma_desc.cqid_sqid = (T3_QID_RX_DATA_COMP << 8) |
+            T3_QID_DMA_HIGH_PRI_WRITE;
+        REG_WR(pDevice, DmaWrite.Mode, DMA_WRITE_MODE_ENABLE);
+    }
+
+    dma_desc_addr = T3_NIC_DMA_DESC_POOL_ADDR;
+
+    /* Writing this DMA descriptor to DMA memory */
+    for (i = 0; i < sizeof(T3_DMA_DESC); i += 4)
+    {
+        value32 = *((PLM_UINT32) (((PLM_UINT8) &dma_desc) + i));
+        MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, dma_desc_addr+i);
+        MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_DATA_REG, cpu_to_le32(value32));
+    }
+    MM_WriteConfig32(pDevice, T3_PCI_MEM_WIN_ADDR_REG, 0);
+
+    if (dma_read)
+        REG_WR(pDevice, Ftq.DmaHighReadFtqFifoEnqueueDequeue, dma_desc_addr);
+    else
+        REG_WR(pDevice, Ftq.DmaHighWriteFtqFifoEnqueueDequeue, dma_desc_addr);
+
+    for (i = 0; i < 40; i++)
+    {
+        if (dma_read)
+            value32 = REG_RD(pDevice, Ftq.RcvBdCompFtqFifoEnqueueDequeue);
+        else
+            value32 = REG_RD(pDevice, Ftq.RcvDataCompFtqFifoEnqueueDequeue);
+
+        if ((value32 & 0xffff) == dma_desc_addr)
+            break;
+
+        MM_Wait(10);
+    }
+
+    return LM_STATUS_SUCCESS;
+}
+
+STATIC LM_STATUS
+LM_DmaTest(PLM_DEVICE_BLOCK pDevice, PLM_UINT8 pBufferVirt,
+           LM_PHYSICAL_ADDRESS BufferPhy, LM_UINT32 BufferSize)
+{
+    int j;
+    LM_UINT32 *ptr;
+    int dma_success = 0;
+
+    if(T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5700 &&
+        T3_ASIC_REV(pDevice->ChipRevId) != T3_ASIC_REV_5701)
+    {
+        return LM_STATUS_SUCCESS;
+    }
+    while (!dma_success)
+    {
+        /* Fill data with incremental patterns */
+        ptr = (LM_UINT32 *)pBufferVirt;
+        for (j = 0; j < BufferSize/4; j++)
+            *ptr++ = j;
+
+        if (t3_do_dma(pDevice,BufferPhy,BufferSize, 1) == LM_STATUS_FAILURE)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        MM_Wait(40);
+        ptr = (LM_UINT32 *)pBufferVirt;
+        /* Fill data with zero */
+        for (j = 0; j < BufferSize/4; j++)
+            *ptr++ = 0;
+
+        if (t3_do_dma(pDevice,BufferPhy,BufferSize, 0) == LM_STATUS_FAILURE)
+        {
+            return LM_STATUS_FAILURE;
+        }
+
+        MM_Wait(40);
+        /* Check for data */
+        ptr = (LM_UINT32 *)pBufferVirt;
+        for (j = 0; j < BufferSize/4; j++)
+        {
+            if (*ptr++ != j)
+            {
+                if ((pDevice->DmaReadWriteCtrl & DMA_CTRL_WRITE_BOUNDARY_MASK)
+                    == DMA_CTRL_WRITE_BOUNDARY_DISABLE)
+                {
+                    pDevice->DmaReadWriteCtrl = (pDevice->DmaReadWriteCtrl &
+                         ~DMA_CTRL_WRITE_BOUNDARY_MASK) |
+                          DMA_CTRL_WRITE_BOUNDARY_16;
+                    REG_WR(pDevice, PciCfg.DmaReadWriteCtrl,
+                           pDevice->DmaReadWriteCtrl);
+                    break;
+                 }
+                 else
+                 {
+                     return LM_STATUS_FAILURE;
+                 }
+            }
+        }
+        if (j == (BufferSize/4))
+            dma_success = 1;
+    }
+    return LM_STATUS_SUCCESS;
+}
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/bcm/tigon3.h linux/drivers/net/bcm/tigon3.h
--- ../ia64/linux/drivers/net/bcm/tigon3.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/bcm/tigon3.h	Thu Apr 11 17:38:51 2002
@@ -0,0 +1,3362 @@
+
+/******************************************************************************/
+/*                                                                            */
+/* Broadcom BCM5700 Linux Network Driver, Copyright (c) 2000 Broadcom         */
+/* Corporation.                                                               */
+/* All rights reserved.                                                       */
+/*                                                                            */
+/* This program is free software; you can redistribute it and/or modify       */
+/* it under the terms of the GNU General Public License as published by       */
+/* the Free Software Foundation, located in the file LICENSE.                 */
+/*                                                                            */
+/* History:                                                                   */
+/*                                                                            */
+/******************************************************************************/
+
+#ifndef TIGON3_H
+#define TIGON3_H
+
+#include "lm.h"
+#if INCLUDE_TBI_SUPPORT
+#include "autoneg.h"
+#endif
+
+
+
+/******************************************************************************/
+/* Constants. */
+/******************************************************************************/
+
+/* Maxim number of packet descriptors used for sending packets. */
+#define MAX_TX_PACKET_DESC_COUNT            600
+#define DEFAULT_TX_PACKET_DESC_COUNT        100
+
+/* Maximum number of packet descriptors used for receiving packets. */
+#if T3_JUMBO_RCB_ENTRY_COUNT
+#define MAX_RX_PACKET_DESC_COUNT                                            \
+    (T3_STD_RCV_RCB_ENTRY_COUNT + T3_JUMBO_RCV_RCB_ENTRY_COUNT)
+#else
+#define MAX_RX_PACKET_DESC_COUNT            800
+#endif
+#define DEFAULT_RX_PACKET_DESC_COUNT        200
+
+/* Threshhold for double copying small tx packets.  0 will disable double */
+/* copying of small Tx packets. */
+#define DEFAULT_TX_COPY_BUFFER_SIZE         0
+#define MIN_TX_COPY_BUFFER_SIZE             64 
+#define MAX_TX_COPY_BUFFER_SIZE             512
+
+/* Cache line. */
+#define COMMON_CACHE_LINE_SIZE              0x20
+#define COMMON_CACHE_LINE_MASK              (COMMON_CACHE_LINE_SIZE-1)
+
+/* Maximum number of fragment we can handle. */
+#ifndef MAX_FRAGMENT_COUNT
+#define MAX_FRAGMENT_COUNT                  32
+#endif
+
+/* B0 bug. */
+#define BCM5700_BX_MIN_FRAG_SIZE            10
+#define BCM5700_BX_MIN_FRAG_BUF_SIZE        16  /* nice aligned size. */
+#define BCM5700_BX_MIN_FRAG_BUF_SIZE_MASK   (BCM5700_BX_MIN_FRAG_BUF_SIZE-1)
+#define BCM5700_BX_TX_COPY_BUF_SIZE         (BCM5700_BX_MIN_FRAG_BUF_SIZE * \
+                                            MAX_FRAGMENT_COUNT)
+
+/* MAGIC number. */
+//#define T3_MAGIC_NUM                        'KevT'
+#define T3_FIRMWARE_MAILBOX                0x0b50
+#define T3_MAGIC_NUM                       0x4B657654 
+#define T3_MAGIC_NUM_DISABLE_DMAW_ON_LINK_CHANGE 0x4861764b
+
+#define T3_NIC_DATA_SIG_ADDR               0x0b54
+#define T3_NIC_DATA_SIG                    0x4b657654
+
+#define T3_NIC_DATA_NIC_CFG_ADDR           0x0b58
+#define T3_NIC_CFG_LED_MODE_UNKNOWN        BIT_NONE
+#define T3_NIC_CFG_LED_MODE_TRIPLE_SPEED   BIT_2
+#define T3_NIC_CFG_LED_MODE_LINK_SPEED     BIT_3
+#define T3_NIC_CFG_LED_MODE_OPEN_DRAIN     BIT_2
+#define T3_NIC_CFG_LED_MODE_OUTPUT         BIT_3
+#define T3_NIC_CFG_LED_MODE_MASK           (BIT_2 | BIT_3)
+#define T3_NIC_CFG_PHY_TYPE_UNKNOWN         BIT_NONE
+#define T3_NIC_CFG_PHY_TYPE_COPPER          BIT_4
+#define T3_NIC_CFG_PHY_TYPE_FIBER           BIT_5
+#define T3_NIC_CFG_PHY_TYPE_MASK            (BIT_4 | BIT_5)
+#define T3_NIC_CFG_ENABLE_WOL               BIT_6
+#define T3_NIC_CFG_ENABLE_ASF               BIT_7
+#define T3_NIC_EEPROM_WP                    BIT_8
+
+#define T3_NIC_DATA_PHY_ID_ADDR            0x0b74
+#define T3_NIC_PHY_ID1_MASK                0xffff0000
+#define T3_NIC_PHY_ID2_MASK                0x0000ffff
+
+#define T3_CMD_MAILBOX                      0x0b78
+#define T3_CMD_NICDRV_ALIVE                 0x01
+#define T3_CMD_NICDRV_PAUSE_FW              0x02
+#define T3_CMD_NICDRV_IPV4ADDR_CHANGE       0x03
+#define T3_CMD_NICDRV_IPV6ADDR_CHANGE       0x04
+#define T3_CMD_5703A0_FIX_DMAFW_DMAR        0x05
+#define T3_CMD_5703A0_FIX_DMAFW_DMAW        0x06
+
+#define T3_CMD_LENGTH_MAILBOX               0x0b7c
+#define T3_CMD_DATA_MAILBOX                 0x0b80
+
+#define T3_ASF_FW_STATUS_MAILBOX            0x0c00
+
+#define T3_DRV_STATE_MAILBOX                0x0c04
+#define T3_DRV_STATE_START                  0x01
+#define T3_DRV_STATE_UNLOAD                 0x02
+#define T3_DRV_STATE_WOL                    0x03
+#define T3_DRV_STATE_SUSPEND                0x04
+
+#define T3_FW_RESET_TYPE_MAILBOX            0x0c08
+
+#define T3_MAC_ADDR_HIGH_MAILBOX            0x0c14
+#define T3_MAC_ADDR_LOW_MAILBOX             0x0c18
+
+/******************************************************************************/
+/* Hardware constants. */
+/******************************************************************************/
+
+/* Number of entries in the send ring:  must be 512. */
+#define T3_SEND_RCB_ENTRY_COUNT             512     
+#define T3_SEND_RCB_ENTRY_COUNT_MASK        (T3_SEND_RCB_ENTRY_COUNT-1)
+
+/* Number of send RCBs.  May be 1-16 but for now, only support one. */
+#define T3_MAX_SEND_RCB_COUNT               16
+
+/* Number of entries in the Standard Receive RCB.  Must be 512 entries. */
+#define T3_STD_RCV_RCB_ENTRY_COUNT          512
+#define T3_STD_RCV_RCB_ENTRY_COUNT_MASK     (T3_STD_RCV_RCB_ENTRY_COUNT-1)
+#define DEFAULT_STD_RCV_DESC_COUNT          200    /* Must be < 512. */
+#define MAX_STD_RCV_BUFFER_SIZE             0x600
+
+/* Number of entries in the Mini Receive RCB.  This value can either be */
+/* 0, 1024.  Currently Mini Receive RCB is disabled. */
+#ifndef T3_MINI_RCV_RCB_ENTRY_COUNT
+#define T3_MINI_RCV_RCB_ENTRY_COUNT         0
+#endif /* T3_MINI_RCV_RCB_ENTRY_COUNT */
+#define T3_MINI_RCV_RCB_ENTRY_COUNT_MASK    (T3_MINI_RCV_RCB_ENTRY_COUNT-1)
+#define MAX_MINI_RCV_BUFFER_SIZE            512
+#define DEFAULT_MINI_RCV_BUFFER_SIZE        64
+#define DEFAULT_MINI_RCV_DESC_COUNT         100    /* Must be < 1024. */
+
+/* Number of entries in the Jumbo Receive RCB.  This value must 256 or 0. */
+/* Currently, Jumbo Receive RCB is disabled. */
+#ifndef T3_JUMBO_RCV_RCB_ENTRY_COUNT
+#define T3_JUMBO_RCV_RCB_ENTRY_COUNT        0
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+#define T3_JUMBO_RCV_RCB_ENTRY_COUNT_MASK   (T3_JUMBO_RCV_RCB_ENTRY_COUNT-1)
+
+#define MAX_JUMBO_RCV_BUFFER_SIZE           (10 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_RCV_BUFFER_SIZE       (4 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_RCV_DESC_COUNT        128     /* Must be < 256. */
+
+#define MAX_JUMBO_TX_BUFFER_SIZE            (8 * 1024) /* > 1514 */
+#define DEFAULT_JUMBO_TX_BUFFER_SIZE        (4 * 1024) /* > 1514 */
+
+/* Number of receive return RCBs.  Maybe 1-16 but for now, only support one. */
+#define T3_MAX_RCV_RETURN_RCB_COUNT         16
+
+/* Number of entries in a Receive Return ring.  This value is either 1024 */
+/* or 2048. */
+#ifndef T3_RCV_RETURN_RCB_ENTRY_COUNT 
+#define T3_RCV_RETURN_RCB_ENTRY_COUNT       1024
+#endif /* T3_RCV_RETURN_RCB_ENTRY_COUNT */
+#define T3_RCV_RETURN_RCB_ENTRY_COUNT_MASK  (T3_RCV_RETURN_RCB_ENTRY_COUNT-1)
+
+
+/* Default coalescing parameters. */
+#define DEFAULT_RX_COALESCING_TICKS         100
+#define MAX_RX_COALESCING_TICKS             500
+#define DEFAULT_TX_COALESCING_TICKS         400
+#define MAX_TX_COALESCING_TICKS             500
+#define DEFAULT_RX_MAX_COALESCED_FRAMES     10
+#define MAX_RX_MAX_COALESCED_FRAMES         100
+#define ADAPTIVE_LO_RX_MAX_COALESCED_FRAMES    5
+#define ADAPTIVE_HI_RX_MAX_COALESCED_FRAMES    42
+#define ADAPTIVE_LO_RX_COALESCING_TICKS         50
+#define ADAPTIVE_HI_RX_COALESCING_TICKS         300
+#define ADAPTIVE_LO_PKT_THRESH              30000
+#define ADAPTIVE_HI_PKT_THRESH              74000
+#define DEFAULT_TX_MAX_COALESCED_FRAMES     40
+#define ADAPTIVE_LO_TX_MAX_COALESCED_FRAMES    25
+#define ADAPTIVE_HI_TX_MAX_COALESCED_FRAMES    75
+#define MAX_TX_MAX_COALESCED_FRAMES         100
+
+#define DEFAULT_RX_COALESCING_TICKS_DURING_INT          25
+#define DEFAULT_TX_COALESCING_TICKS_DURING_INT          25
+#define DEFAULT_RX_MAX_COALESCED_FRAMES_DURING_INT      5
+#define DEFAULT_TX_MAX_COALESCED_FRAMES_DURING_INT      5
+
+#define BAD_DEFAULT_VALUE                               0xffffffff
+
+#define DEFAULT_STATS_COALESCING_TICKS      1000000
+#define MAX_STATS_COALESCING_TICKS          3600000000U
+
+
+/* Receive BD Replenish thresholds. */
+#define DEFAULT_RCV_STD_BD_REPLENISH_THRESHOLD      4
+#define DEFAULT_RCV_JUMBO_BD_REPLENISH_THRESHOLD    4
+
+
+/* Maximum physical fragment size. */
+#define MAX_FRAGMENT_SIZE                   (64 * 1024)
+
+
+/* Standard view. */
+#define T3_STD_VIEW_SIZE                    (64 * 1024)
+#define T3_FLAT_VIEW_SIZE                   (32 * 1024 * 1024)
+
+
+/* Buffer descriptor base address on the NIC's memory. */
+
+#define T3_NIC_SND_BUFFER_DESC_ADDR         0x4000
+#define T3_NIC_STD_RCV_BUFFER_DESC_ADDR     0x6000
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR   0x7000
+
+#define T3_NIC_STD_RCV_BUFFER_DESC_ADDR_EXT_MEM     0xc000
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_ADDR_EXT_MEM   0xd000
+#define T3_NIC_MINI_RCV_BUFFER_DESC_ADDR_EXT_MEM    0xe000
+
+#define T3_NIC_SND_BUFFER_DESC_SIZE         (T3_SEND_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_SND_BD) / 4)
+
+#define T3_NIC_STD_RCV_BUFFER_DESC_SIZE     (T3_STD_RCV_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_RCV_BD) / 4)
+
+#define T3_NIC_JUMBO_RCV_BUFFER_DESC_SIZE   (T3_JUMBO_RCV_RCB_ENTRY_COUNT * \
+                                            sizeof(T3_EXT_RCV_BD) / 4)
+
+
+/* MBUF pool. */
+#define T3_NIC_MBUF_POOL_ADDR               0x8000
+#define T3_NIC_MBUF_POOL_SIZE               0x18000
+
+#define T3_NIC_MBUF_POOL_ADDR_EXT_MEM       0x20000
+
+/* DMA descriptor pool */
+#define T3_NIC_DMA_DESC_POOL_ADDR           0x2000
+#define T3_NIC_DMA_DESC_POOL_SIZE           0x2000      /* 8KB. */
+
+#define T3_DEF_DMA_MBUF_LOW_WMARK           0x40
+#define T3_DEF_RX_MAC_MBUF_LOW_WMARK        0x20
+#define T3_DEF_MBUF_HIGH_WMARK              0x60
+
+#define T3_DEF_DMA_MBUF_LOW_WMARK_JUMBO     304
+#define T3_DEF_RX_MAC_MBUF_LOW_WMARK_JUMBO  152
+#define T3_DEF_MBUF_HIGH_WMARK_JUMBO        380
+
+#define T3_DEF_DMA_DESC_LOW_WMARK           5
+#define T3_DEF_DMA_DESC_HIGH_WMARK          10
+
+/* Maximum size of giant TCP packet can be sent */
+#define T3_TCP_SEG_MAX_OFFLOAD_SIZE         64*1000
+#define T3_TCP_SEG_MIN_NUM_SEG              20
+
+#define T3_RX_CPU_ID    0x1
+#define T3_TX_CPU_ID    0x2
+#define T3_RX_CPU_SPAD_ADDR  0x30000
+#define T3_RX_CPU_SPAD_SIZE  0x4000
+#define T3_TX_CPU_SPAD_ADDR  0x34000
+#define T3_TX_CPU_SPAD_SIZE  0x4000
+
+typedef struct T3_DIR_ENTRY
+{
+  PLM_UINT8 Buffer;
+  LM_UINT32 Offset;
+  LM_UINT32 Length;
+} T3_DIR_ENTRY,*PT3_DIR_ENTRY;
+
+typedef struct T3_FWIMG_INFO
+{
+  LM_UINT32 StartAddress;
+  T3_DIR_ENTRY Text;
+  T3_DIR_ENTRY ROnlyData;
+  T3_DIR_ENTRY Data;
+  T3_DIR_ENTRY Sbss;
+  T3_DIR_ENTRY Bss;
+} T3_FWIMG_INFO, *PT3_FWIMG_INFO;
+
+
+
+/******************************************************************************/
+/* Tigon3 PCI Registers. */
+/******************************************************************************/
+#define T3_PCI_ID_BCM5700                   0x164414e4
+#define T3_PCI_ID_BCM5701                   0x164514e4
+#define T3_PCI_ID_BCM5702                   0x164614e4
+#define T3_PCI_ID_BCM5702x                  0x16A614e4
+#define T3_PCI_ID_BCM5703                   0x164714e4
+#define T3_PCI_ID_BCM5703x                  0x16A714e4
+#define T3_PCI_ID_BCM5702FE                 0x164D14e4
+
+#define T3_PCI_VENDOR_ID                    (T3_PCI_ID & 0xffff)
+#define T3_PCI_DEVICE_ID                    (T3_PCI_ID >> 16)
+
+#define T3_PCI_MISC_HOST_CTRL_REG           0x68
+
+/* The most significant 16bit of register 0x68. */
+/* ChipId:4, ChipRev:4, MetalRev:8 */
+#define T3_CHIP_ID_5700_A0                  0x7000
+#define T3_CHIP_ID_5700_A1                  0x7001
+#define T3_CHIP_ID_5700_B0                  0x7100
+#define T3_CHIP_ID_5700_B1                  0x7101
+#define T3_CHIP_ID_5700_C0                  0x7200
+
+#define T3_CHIP_ID_5701_A0                  0x0000
+#define T3_CHIP_ID_5701_B0                  0x0100
+#define T3_CHIP_ID_5701_B2                  0x0102
+#define T3_CHIP_ID_5701_B5                  0x0105
+
+#define T3_CHIP_ID_5703_A0                  0x1000
+#define T3_CHIP_ID_5703_A1                  0x1001
+#define T3_CHIP_ID_5703_A2                  0x1002
+
+/* Chip Id. */
+#define T3_ASIC_REV(_ChipRevId)             ((_ChipRevId) >> 12)
+#define T3_ASIC_REV_5700                    0x07
+#define T3_ASIC_REV_5701                    0x00
+#define T3_ASIC_REV_5703                    0x01
+
+/* Chip id and revision. */
+#define T3_CHIP_REV(_ChipRevId)             ((_ChipRevId) >> 8)
+#define T3_CHIP_REV_5700_AX                 0x70
+#define T3_CHIP_REV_5700_BX                 0x71
+#define T3_CHIP_REV_5700_CX                 0x72
+#define T3_CHIP_REV_5701_AX                 0x00
+
+/* Metal revision. */
+#define T3_METAL_REV(_ChipRevId)            ((_ChipRevId) & 0xff)
+#define T3_METAL_REV_A0                     0x00
+#define T3_METAL_REV_A1                     0x01
+#define T3_METAL_REV_B0                     0x00
+#define T3_METAL_REV_B1                     0x01
+#define T3_METAL_REV_B2                     0x02
+
+#define T3_PCI_REG_CLOCK_CTRL               0x74
+
+#define T3_PCI_DISABLE_RX_CLOCK             BIT_10
+#define T3_PCI_DISABLE_TX_CLOCK             BIT_11
+#define T3_PCI_SELECT_ALTERNATE_CLOCK       BIT_12
+#define T3_PCI_POWER_DOWN_PCI_PLL133        BIT_15
+#define T3_PCI_44MHZ_CORE_CLOCK             BIT_18
+
+
+#define T3_PCI_REG_ADDR_REG                 0x78
+#define T3_PCI_REG_DATA_REG                 0x80
+
+#define T3_PCI_MEM_WIN_ADDR_REG             0x7c
+#define T3_PCI_MEM_WIN_DATA_REG             0x84
+
+#define T3_PCI_PM_CAP_REG                   0x48
+
+#define T3_PCI_PM_CAP_PME_D3COLD            BIT_31
+#define T3_PCI_PM_CAP_PME_D3HOT             BIT_30
+
+#define T3_PCI_PM_STATUS_CTRL_REG           0x4c
+
+#define T3_PM_POWER_STATE_MASK              (BIT_0 | BIT_1)
+#define T3_PM_POWER_STATE_D0                BIT_NONE
+#define T3_PM_POWER_STATE_D1                BIT_0
+#define T3_PM_POWER_STATE_D2                BIT_1
+#define T3_PM_POWER_STATE_D3                (BIT_0 | BIT_1)
+
+#define T3_PM_PME_ENABLE                    BIT_8
+#define T3_PM_PME_ASSERTED                  BIT_15
+
+
+/* PCI state register. */
+#define T3_PCI_STATE_REG                    0x70
+
+#define T3_PCI_STATE_FORCE_RESET            BIT_0
+#define T3_PCI_STATE_INT_NOT_ACTIVE         BIT_1
+#define T3_PCI_STATE_CONVENTIONAL_PCI_MODE  BIT_2
+#define T3_PCI_STATE_BUS_SPEED_HIGH         BIT_3
+#define T3_PCI_STATE_32BIT_PCI_BUS          BIT_4
+
+
+/* Broadcom subsystem/subvendor IDs. */
+#define T3_SVID_BROADCOM                            0x14e4
+
+#define T3_SSID_BROADCOM_BCM95700A6                 0x1644
+#define T3_SSID_BROADCOM_BCM95701A5                 0x0001
+#define T3_SSID_BROADCOM_BCM95700T6                 0x0002  /* BCM8002 */
+#define T3_SSID_BROADCOM_BCM95700A9                 0x0003  /* Agilent */
+#define T3_SSID_BROADCOM_BCM95701T1                 0x0005
+#define T3_SSID_BROADCOM_BCM95701T8                 0x0006
+#define T3_SSID_BROADCOM_BCM95701A7                 0x0007  /* Agilent */
+#define T3_SSID_BROADCOM_BCM95701A10                0x0008
+#define T3_SSID_BROADCOM_BCM95701A12                0x8008
+#define T3_SSID_BROADCOM_BCM95703Ax1                0x0009
+#define T3_SSID_BROADCOM_BCM95703Ax2                0x8009
+
+/* 3COM subsystem/subvendor IDs. */
+#define T3_SVID_3COM                                0x10b7
+
+#define T3_SSID_3COM_3C996T                         0x1000
+#define T3_SSID_3COM_3C996BT                        0x1006
+#define T3_SSID_3COM_3C996CT                        0x1002
+#define T3_SSID_3COM_3C997T                         0x1003
+#define T3_SSID_3COM_3C1000T                        0x1007
+#define T3_SSID_3COM_3C940BR01                      0x1008
+
+/* Fiber boards. */
+#define T3_SSID_3COM_3C996SX                        0x1004
+#define T3_SSID_3COM_3C997SX                        0x1005
+
+
+/* Dell subsystem/subvendor IDs. */
+
+#define T3_SVID_DELL                                0x1028
+
+#define T3_SSID_DELL_VIPER                          0x00d1
+#define T3_SSID_DELL_JAGUAR                         0x0106
+#define T3_SSID_DELL_MERLOT                         0x0109
+#define T3_SSID_DELL_SLIM_MERLOT                    0x010a
+
+/* Compaq subsystem/subvendor IDs */
+
+#define T3_SVID_COMPAQ                              0x0e11
+
+#define T3_SSID_COMPAQ_BANSHEE                      0x007c
+#define T3_SSID_COMPAQ_BANSHEE_2                    0x009a
+#define T3_SSID_COMPAQ_CHANGELING                   0x007d
+#define T3_SSID_COMPAQ_NC7780                       0x0085
+#define T3_SSID_COMPAQ_NC7780_2                     0x0099
+
+
+/******************************************************************************/
+/* MII registers. */
+/******************************************************************************/
+
+/* Control register. */
+#define PHY_CTRL_REG                                0x00
+
+#define PHY_CTRL_SPEED_MASK                         (BIT_6 | BIT_13)
+#define PHY_CTRL_SPEED_SELECT_10MBPS                BIT_NONE
+#define PHY_CTRL_SPEED_SELECT_100MBPS               BIT_13
+#define PHY_CTRL_SPEED_SELECT_1000MBPS              BIT_6
+#define PHY_CTRL_COLLISION_TEST_ENABLE              BIT_7
+#define PHY_CTRL_FULL_DUPLEX_MODE                   BIT_8
+#define PHY_CTRL_RESTART_AUTO_NEG                   BIT_9
+#define PHY_CTRL_ISOLATE_PHY                        BIT_10
+#define PHY_CTRL_LOWER_POWER_MODE                   BIT_11
+#define PHY_CTRL_AUTO_NEG_ENABLE                    BIT_12
+#define PHY_CTRL_LOOPBACK_MODE                      BIT_14
+#define PHY_CTRL_PHY_RESET                          BIT_15
+
+
+/* Status register. */
+#define PHY_STATUS_REG                              0x01
+
+#define PHY_STATUS_LINK_PASS                        BIT_2
+#define PHY_STATUS_AUTO_NEG_COMPLETE                BIT_5
+
+
+/* Phy Id registers. */
+#define PHY_ID1_REG                                 0x02
+#define PHY_ID1_OUI_MASK                            0xffff
+
+#define PHY_ID2_REG                                 0x03
+#define PHY_ID2_REV_MASK                            0x000f
+#define PHY_ID2_MODEL_MASK                          0x03f0
+#define PHY_ID2_OUI_MASK                            0xfc00
+
+
+/* Auto-negotiation advertisement register. */
+#define PHY_AN_AD_REG                               0x04
+
+#define PHY_AN_AD_ASYM_PAUSE                        BIT_11
+#define PHY_AN_AD_PAUSE_CAPABLE                     BIT_10
+#define PHY_AN_AD_10BASET_HALF                      BIT_5
+#define PHY_AN_AD_10BASET_FULL                      BIT_6
+#define PHY_AN_AD_100BASETX_HALF                    BIT_7
+#define PHY_AN_AD_100BASETX_FULL                    BIT_8
+#define PHY_AN_AD_PROTOCOL_802_3_CSMA_CD            0x01
+
+
+/* Auto-negotiation Link Partner Ability register. */
+#define PHY_LINK_PARTNER_ABILITY_REG                0x05
+
+#define PHY_LINK_PARTNER_ASYM_PAUSE                 BIT_11
+#define PHY_LINK_PARTNER_PAUSE_CAPABLE              BIT_10
+
+
+/* Auto-negotiation expansion register. */
+#define PHY_AN_EXPANSION_REG                        0x06
+
+
+
+/******************************************************************************/
+/* BCM5400 and BCM5401 phy info. */
+/******************************************************************************/
+
+#define PHY_DEVICE_ID           1
+
+/* OUI: bit 31-10;   Model#: bit 9-4;   Rev# bit 3-0. */
+#define PHY_UNKNOWN_PHY                             0x00000000
+#define PHY_BCM5400_PHY_ID                          0x60008040
+#define PHY_BCM5401_PHY_ID                          0x60008050
+#define PHY_BCM5411_PHY_ID                          0x60008070
+#define PHY_BCM5701_PHY_ID                          0x60008110
+#define PHY_BCM5703_PHY_ID                          0x60008160
+#define PHY_BCM8002_PHY_ID                          0x60010140
+
+#define PHY_BCM5401_B0_REV                          0x1
+#define PHY_BCM5401_B2_REV                          0x3
+#define PHY_BCM5401_C0_REV                          0x6
+
+#define PHY_ID_OUI_MASK                             0xfffffc00
+#define PHY_ID_MODEL_MASK                           0x000003f0
+#define PHY_ID_REV_MASK                             0x0000000f
+#define PHY_ID_MASK                                 (PHY_ID_OUI_MASK |      \
+                                                    PHY_ID_MODEL_MASK)
+
+
+#define UNKNOWN_PHY_ID(x)   ((((x) & PHY_ID_MASK) != PHY_BCM5400_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5401_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5411_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5701_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM5703_PHY_ID) && \
+                            (((x) & PHY_ID_MASK) != PHY_BCM8002_PHY_ID))
+
+
+
+/* 1000Base-T control register. */
+#define BCM540X_1000BASET_CTRL_REG                  0x09
+
+#define BCM540X_AN_AD_1000BASET_HALF                BIT_8
+#define BCM540X_AN_AD_1000BASET_FULL                BIT_9
+#define BCM540X_CONFIG_AS_MASTER                    BIT_11
+#define BCM540X_ENABLE_CONFIG_AS_MASTER             BIT_12
+
+
+/* Extended control register. */
+#define BCM540X_EXT_CTRL_REG                        0x10
+
+#define BCM540X_EXT_CTRL_LINK3_LED_MODE             BIT_1
+#define BCM540X_EXT_CTRL_TBI                        BIT_15
+
+/* PHY extended status register. */
+#define BCM540X_EXT_STATUS_REG                      0x11
+
+#define BCM540X_EXT_STATUS_LINK_PASS                BIT_8
+
+
+/* DSP Coefficient Read/Write Port. */
+#define BCM540X_DSP_RW_PORT                         0x15
+
+
+/* DSP Coeficient Address Register. */
+#define BCM540X_DSP_ADDRESS_REG                     0x17
+
+#define BCM540X_DSP_TAP_NUMBER_MASK                 0x00
+#define BCM540X_DSP_AGC_A                           0x00
+#define BCM540X_DSP_AGC_B                           0x01
+#define BCM540X_DSP_MSE_PAIR_STATUS                 0x02
+#define BCM540X_DSP_SOFT_DECISION                   0x03
+#define BCM540X_DSP_PHASE_REG                       0x04
+#define BCM540X_DSP_SKEW                            0x05
+#define BCM540X_DSP_POWER_SAVER_UPPER_BOUND         0x06
+#define BCM540X_DSP_POWER_SAVER_LOWER_BOUND         0x07
+#define BCM540X_DSP_LAST_ECHO                       0x08
+#define BCM540X_DSP_FREQUENCY                       0x09
+#define BCM540X_DSP_PLL_BANDWIDTH                   0x0a
+#define BCM540X_DSP_PLL_PHASE_OFFSET                0x0b
+
+#define BCM540X_DSP_FILTER_DCOFFSET                 (BIT_10 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT3                    (BIT_8 | BIT_9 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT2                    (BIT_9 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT1                    (BIT_8 | BIT_11)
+#define BCM540X_DSP_FILTER_FEXT0                    BIT_11
+#define BCM540X_DSP_FILTER_NEXT3                    (BIT_8 | BIT_9 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT2                    (BIT_9 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT1                    (BIT_8 | BIT_10)
+#define BCM540X_DSP_FILTER_NEXT0                    BIT_10
+#define BCM540X_DSP_FILTER_ECHO                     (BIT_8 | BIT_9)
+#define BCM540X_DSP_FILTER_DFE                      BIT_9
+#define BCM540X_DSP_FILTER_FFE                      BIT_8
+
+#define BCM540X_DSP_CONTROL_ALL_FILTERS             BIT_12
+
+#define BCM540X_DSP_SEL_CH_0                        BIT_NONE
+#define BCM540X_DSP_SEL_CH_1                        BIT_13
+#define BCM540X_DSP_SEL_CH_2                        BIT_14
+#define BCM540X_DSP_SEL_CH_3                        (BIT_13 | BIT_14)
+
+#define BCM540X_CONTROL_ALL_CHANNELS                BIT_15
+
+
+/* Auxilliary Control Register (Shadow Register) */
+#define BCM5401_AUX_CTRL                            0x18
+
+#define BCM5401_SHADOW_SEL_MASK                     0x7
+#define BCM5401_SHADOW_SEL_NORMAL                   0x00
+#define BCM5401_SHADOW_SEL_10BASET                  0x01
+#define BCM5401_SHADOW_SEL_POWER_CONTROL            0x02
+#define BCM5401_SHADOW_SEL_IP_PHONE                 0x03
+#define BCM5401_SHADOW_SEL_MISC_TEST1               0x04
+#define BCM5401_SHADOW_SEL_MISC_TEST2               0x05
+#define BCM5401_SHADOW_SEL_IP_PHONE_SEED            0x06
+
+
+/* Shadow register selector == '000' */
+#define BCM5401_SHDW_NORMAL_DIAG_MODE               BIT_3
+#define BCM5401_SHDW_NORMAL_DISABLE_MBP             BIT_4
+#define BCM5401_SHDW_NORMAL_DISABLE_LOW_PWR         BIT_5
+#define BCM5401_SHDW_NORMAL_DISABLE_INV_PRF         BIT_6
+#define BCM5401_SHDW_NORMAL_DISABLE_PRF             BIT_7
+#define BCM5401_SHDW_NORMAL_RX_SLICING_NORMAL       BIT_NONE
+#define BCM5401_SHDW_NORMAL_RX_SLICING_4D           BIT_8
+#define BCM5401_SHDW_NORMAL_RX_SLICING_3LVL_1D      BIT_9
+#define BCM5401_SHDW_NORMAL_RX_SLICING_5LVL_1D      (BIT_8 | BIT_9)
+#define BCM5401_SHDW_NORMAL_TX_6DB_CODING           BIT_10
+#define BCM5401_SHDW_NORMAL_ENABLE_SM_DSP_CLOCK     BIT_11
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_4NS       BIT_NONE
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_5NS       BIT_12
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_3NS       BIT_13
+#define BCM5401_SHDW_NORMAL_EDGERATE_CTRL_0NS       (BIT_12 | BIT_13)
+#define BCM5401_SHDW_NORMAL_EXT_PACKET_LENGTH       BIT_14
+#define BCM5401_SHDW_NORMAL_EXTERNAL_LOOPBACK       BIT_15
+
+
+/* Auxilliary status summary. */
+#define BCM540X_AUX_STATUS_REG                      0x19
+
+#define BCM540X_AUX_LINK_PASS                       BIT_2
+#define BCM540X_AUX_SPEED_MASK                      (BIT_8 | BIT_9 | BIT_10)
+#define BCM540X_AUX_10BASET_HD                      BIT_8
+#define BCM540X_AUX_10BASET_FD                      BIT_9
+#define BCM540X_AUX_100BASETX_HD                    (BIT_8 | BIT_9)
+#define BCM540X_AUX_100BASET4                       BIT_10
+#define BCM540X_AUX_100BASETX_FD                    (BIT_8 | BIT_10)
+#define BCM540X_AUX_100BASET_HD                     (BIT_9 | BIT_10)
+#define BCM540X_AUX_100BASET_FD                     (BIT_8 | BIT_9 | BIT_10)
+
+
+/* Interrupt status. */
+#define BCM540X_INT_STATUS_REG                      0x1a
+
+#define BCM540X_INT_LINK_CHANGE                     BIT_1
+#define BCM540X_INT_SPEED_CHANGE                    BIT_2
+#define BCM540X_INT_DUPLEX_CHANGE                   BIT_3
+#define BCM540X_INT_AUTO_NEG_PAGE_RX                BIT_10
+
+
+/* Interrupt mask register. */
+#define BCM540X_INT_MASK_REG                        0x1b
+
+
+
+/******************************************************************************/
+/* Register definitions. */
+/******************************************************************************/
+
+typedef volatile LM_UINT8 T3_8BIT_REGISTER, *PT3_8BIT_REGISTER;
+typedef volatile LM_UINT16 T3_16BIT_REGISTER, *PT3_16BIT_REGISTER;
+typedef volatile LM_UINT32 T3_32BIT_REGISTER, *PT3_32BIT_REGISTER;
+
+typedef struct {
+    /* Big endian format. */
+    T3_32BIT_REGISTER High;
+    T3_32BIT_REGISTER Low;
+} T3_64BIT_REGISTER, *PT3_64BIT_REGISTER;
+
+typedef T3_64BIT_REGISTER T3_64BIT_HOST_ADDR, *PT3_64BIT_HOST_ADDR;
+
+#define T3_NUM_OF_DMA_DESC    256
+#define T3_NUM_OF_MBUF        768
+
+typedef struct 
+{
+  T3_64BIT_REGISTER host_addr;
+  T3_32BIT_REGISTER nic_mbuf;
+  T3_16BIT_REGISTER len;
+  T3_16BIT_REGISTER cqid_sqid;
+  T3_32BIT_REGISTER flags;
+  T3_32BIT_REGISTER opaque1;
+  T3_32BIT_REGISTER opaque2;
+  T3_32BIT_REGISTER opaque3;
+}T3_DMA_DESC, *PT3_DMA_DESC;
+
+
+
+/******************************************************************************/
+/* Ring control block. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_REGISTER HostRingAddr;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            T3_16BIT_REGISTER MaxLen;
+            T3_16BIT_REGISTER Flags;
+#else /* BIG_ENDIAN_HOST */
+            T3_16BIT_REGISTER Flags;
+            T3_16BIT_REGISTER MaxLen;
+#endif
+        } s;
+
+        T3_32BIT_REGISTER MaxLen_Flags;
+    } u;
+
+    T3_32BIT_REGISTER NicRingAddr;
+} T3_RCB, *PT3_RCB;
+
+#define T3_RCB_FLAG_USE_EXT_RECV_BD                     BIT_0
+#define T3_RCB_FLAG_RING_DISABLED                       BIT_1
+
+
+
+/******************************************************************************/
+/* Status block. */
+/******************************************************************************/
+
+/* 
+ * Size of status block is actually 0x50 bytes.  Use 0x80 bytes for
+ * cache line alignment. 
+ */
+#define T3_STATUS_BLOCK_SIZE                                    0x80
+
+typedef struct {
+    volatile LM_UINT32 Status;
+    #define STATUS_BLOCK_UPDATED                                BIT_0
+    #define STATUS_BLOCK_LINK_CHANGED_STATUS                    BIT_1
+    #define STATUS_BLOCK_ERROR                                  BIT_2
+
+    volatile LM_UINT32 StatusTag;
+
+#ifdef BIG_ENDIAN_HOST
+    volatile LM_UINT16 RcvStdConIdx;
+    volatile LM_UINT16 RcvJumboConIdx;
+
+    volatile LM_UINT16 Reserved2;
+    volatile LM_UINT16 RcvMiniConIdx;
+
+    struct {
+        volatile LM_UINT16 SendConIdx;   /* Send consumer index. */
+        volatile LM_UINT16 RcvProdIdx;   /* Receive producer index. */
+    } Idx[16];
+#else /* BIG_ENDIAN_HOST */
+    volatile LM_UINT16 RcvJumboConIdx;
+    volatile LM_UINT16 RcvStdConIdx;
+
+    volatile LM_UINT16 RcvMiniConIdx;
+    volatile LM_UINT16 Reserved2;
+
+    struct {
+        volatile LM_UINT16 RcvProdIdx;   /* Receive producer index. */
+        volatile LM_UINT16 SendConIdx;   /* Send consumer index. */
+    } Idx[16];
+#endif
+} T3_STATUS_BLOCK, *PT3_STATUS_BLOCK;
+
+
+
+/******************************************************************************/
+/* Receive buffer descriptors. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr;
+
+#ifdef BIG_ENDIAN_HOST
+    volatile LM_UINT16 Index;
+    volatile LM_UINT16 Len;
+
+    volatile LM_UINT16 Type;
+    volatile LM_UINT16 Flags;
+
+    volatile LM_UINT16 IpCksum;
+    volatile LM_UINT16 TcpUdpCksum;
+
+    volatile LM_UINT16 ErrorFlag;
+    volatile LM_UINT16 VlanTag;
+#else /* BIG_ENDIAN_HOST */
+    volatile LM_UINT16 Len;
+    volatile LM_UINT16 Index;
+
+    volatile LM_UINT16 Flags;
+    volatile LM_UINT16 Type;
+
+    volatile LM_UINT16 TcpUdpCksum;
+    volatile LM_UINT16 IpCksum;
+
+    volatile LM_UINT16 VlanTag;
+    volatile LM_UINT16 ErrorFlag;
+#endif
+
+    volatile LM_UINT32 Reserved;
+    volatile LM_UINT32 Opaque;
+} T3_RCV_BD, *PT3_RCV_BD;
+
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr[3];
+
+#ifdef BIG_ENDIAN_HOST
+    LM_UINT16 Len1;
+    LM_UINT16 Len2;
+
+    LM_UINT16 Len3;
+    LM_UINT16 Reserved1;
+#else /* BIG_ENDIAN_HOST */
+    LM_UINT16 Len2;
+    LM_UINT16 Len1;
+
+    LM_UINT16 Reserved1;
+    LM_UINT16 Len3;
+#endif
+
+    T3_RCV_BD StdRcvBd;
+} T3_EXT_RCV_BD, *PT3_EXT_RCV_BD;
+
+
+/* Error flags. */
+#define RCV_BD_ERR_BAD_CRC                          0x0001
+#define RCV_BD_ERR_COLL_DETECT                      0x0002
+#define RCV_BD_ERR_LINK_LOST_DURING_PKT             0x0004
+#define RCV_BD_ERR_PHY_DECODE_ERR                   0x0008
+#define RCV_BD_ERR_ODD_NIBBLED_RCVD_MII             0x0010
+#define RCV_BD_ERR_MAC_ABORT                        0x0020
+#define RCV_BD_ERR_LEN_LT_64                        0x0040
+#define RCV_BD_ERR_TRUNC_NO_RESOURCES               0x0080
+#define RCV_BD_ERR_GIANT_FRAME_RCVD                 0x0100
+
+
+/* Buffer descriptor flags. */
+#define RCV_BD_FLAG_END                             0x0004
+#define RCV_BD_FLAG_JUMBO_RING                      0x0020
+#define RCV_BD_FLAG_VLAN_TAG                        0x0040
+#define RCV_BD_FLAG_FRAME_HAS_ERROR                 0x0400
+#define RCV_BD_FLAG_MINI_RING                       0x0800
+#define RCV_BD_FLAG_IP_CHKSUM_FIELD                 0x1000
+#define RCV_BD_FLAG_TCP_UDP_CHKSUM_FIELD            0x2000
+#define RCV_BD_FLAG_TCP_PACKET                      0x4000
+
+
+
+/******************************************************************************/
+/* Send buffer descriptor. */
+/******************************************************************************/
+
+typedef struct {
+    T3_64BIT_HOST_ADDR HostAddr;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            LM_UINT16 Len;
+            LM_UINT16 Flags;
+#else /* BIG_ENDIAN_HOST */
+            LM_UINT16 Flags;
+            LM_UINT16 Len;
+#endif
+        } s1;
+
+        LM_UINT32 Len_Flags;
+    } u1;
+
+    union {
+        struct {
+#ifdef BIG_ENDIAN_HOST
+            LM_UINT16 Reserved;
+            LM_UINT16 VlanTag;
+#else /* BIG_ENDIAN_HOST */
+            LM_UINT16 VlanTag;
+            LM_UINT16 Reserved;
+#endif
+        } s2;
+
+        LM_UINT32 VlanTag;
+    } u2;
+} T3_SND_BD, *PT3_SND_BD;
+
+
+/* Send buffer descriptor flags. */
+#define SND_BD_FLAG_TCP_UDP_CKSUM                   0x0001
+#define SND_BD_FLAG_IP_CKSUM                        0x0002
+#define SND_BD_FLAG_END                             0x0004
+#define SND_BD_FLAG_IP_FRAG                         0x0008
+#define SND_BD_FLAG_IP_FRAG_END                     0x0010
+#define SND_BD_FLAG_VLAN_TAG                        0x0040
+#define SND_BD_FLAG_COAL_NOW                        0x0080
+#define SND_BD_FLAG_CPU_PRE_DMA                     0x0100
+#define SND_BD_FLAG_CPU_POST_DMA                    0x0200
+#define SND_BD_FLAG_INSERT_SRC_ADDR                 0x1000
+#define SND_BD_FLAG_CHOOSE_SRC_ADDR                 0x6000
+#define SND_BD_FLAG_DONT_GEN_CRC                    0x8000
+
+/* MBUFs */
+typedef struct T3_MBUF_FRAME_DESC {
+#ifdef BIG_ENDIAN_HOST
+  LM_UINT32 status_control;
+  union {
+    struct {
+      LM_UINT8 cqid;
+      LM_UINT8 reserved1;
+      LM_UINT16 length;
+    }s1;
+    LM_UINT32 word;
+  }u1;
+  union {
+    struct 
+    {
+      LM_UINT16 ip_hdr_start;
+      LM_UINT16 tcp_udp_hdr_start;
+    }s2;
+
+    LM_UINT32 word;
+  }u2;
+
+  union {
+    struct {
+      LM_UINT16 data_start;
+      LM_UINT16 vlan_id;
+    }s3;
+    
+    LM_UINT32 word;
+  }u3;
+
+  union {
+    struct {
+      LM_UINT16 ip_checksum;
+      LM_UINT16 tcp_udp_checksum;
+    }s4;
+
+    LM_UINT32 word;
+  }u4;
+
+  union {
+    struct {
+      LM_UINT16 pseudo_checksum;
+      LM_UINT16 checksum_status;
+    }s5;
+
+    LM_UINT32 word;
+  }u5;
+  
+  union {
+    struct {
+      LM_UINT16 rule_match;
+      LM_UINT8 class;
+      LM_UINT8 rupt;
+    }s6;
+
+    LM_UINT32 word;
+  }u6;
+
+  union {
+    struct {
+      LM_UINT16 reserved2;
+      LM_UINT16 mbuf_num;
+    }s7;
+
+    LM_UINT32 word;
+  }u7;
+
+  LM_UINT32 reserved3;
+  LM_UINT32 reserved4;
+#else
+  LM_UINT32 status_control;
+  union {
+    struct {
+      LM_UINT16 length;
+      LM_UINT8  reserved1;
+      LM_UINT8  cqid;
+    }s1;
+    LM_UINT32 word;
+  }u1;
+  union {
+    struct 
+    {
+      LM_UINT16 tcp_udp_hdr_start;
+      LM_UINT16 ip_hdr_start;
+    }s2;
+
+    LM_UINT32 word;
+  }u2;
+
+  union {
+    struct {
+      LM_UINT16 vlan_id;
+      LM_UINT16 data_start;
+    }s3;
+    
+    LM_UINT32 word;
+  }u3;
+
+  union {
+    struct {
+      LM_UINT16 tcp_udp_checksum;
+      LM_UINT16 ip_checksum;
+    }s4;
+
+    LM_UINT32 word;
+  }u4;
+
+  union {
+    struct {
+      LM_UINT16 checksum_status;
+      LM_UINT16 pseudo_checksum;
+    }s5;
+
+    LM_UINT32 word;
+  }u5;
+  
+  union {
+    struct {
+      LM_UINT8 rupt;
+      LM_UINT8 class;
+      LM_UINT16 rule_match;
+    }s6;
+
+    LM_UINT32 word;
+  }u6;
+
+  union {
+    struct {
+      LM_UINT16 mbuf_num;
+      LM_UINT16 reserved2;
+    }s7;
+
+    LM_UINT32 word;
+  }u7;
+
+  LM_UINT32 reserved3;
+  LM_UINT32 reserved4;
+#endif
+}T3_MBUF_FRAME_DESC,*PT3_MBUF_FRAME_DESC;
+
+typedef struct T3_MBUF_HDR {
+  union {
+    struct {
+      unsigned int C:1;
+      unsigned int F:1;
+      unsigned int reserved1:7;
+      unsigned int next_mbuf:16;
+      unsigned int length:7;
+    }s1;
+    
+    LM_UINT32 word;
+  }u1;
+  
+  LM_UINT32 next_frame_ptr;
+}T3_MBUF_HDR, *PT3_MBUF_HDR;
+
+typedef struct T3_MBUF
+{
+  T3_MBUF_HDR hdr;
+  union
+  {
+    struct {
+      T3_MBUF_FRAME_DESC frame_hdr;
+      LM_UINT32 data[20];
+    }s1;
+
+    struct {
+      LM_UINT32 data[30];
+    }s2;
+  }body;
+}T3_MBUF, *PT3_MBUF;
+
+#define T3_MBUF_BASE   (T3_NIC_MBUF_POOL_ADDR >> 7)
+#define T3_MBUF_END    ((T3_NIC_MBUF_POOL_ADDR + T3_NIC_MBUF_POOL_SIZE) >> 7)
+
+
+
+/******************************************************************************/
+/* Statistics block. */
+/******************************************************************************/
+
+typedef struct {
+    LM_UINT8 Reserved0[0x400-0x300];
+
+    /* Statistics maintained by Receive MAC. */
+    T3_64BIT_REGISTER ifHCInOctets;
+    T3_64BIT_REGISTER Reserved1;
+    T3_64BIT_REGISTER etherStatsFragments;
+    T3_64BIT_REGISTER ifHCInUcastPkts;
+    T3_64BIT_REGISTER ifHCInMulticastPkts;
+    T3_64BIT_REGISTER ifHCInBroadcastPkts;
+    T3_64BIT_REGISTER dot3StatsFCSErrors;
+    T3_64BIT_REGISTER dot3StatsAlignmentErrors;
+    T3_64BIT_REGISTER xonPauseFramesReceived;
+    T3_64BIT_REGISTER xoffPauseFramesReceived;
+    T3_64BIT_REGISTER macControlFramesReceived;
+    T3_64BIT_REGISTER xoffStateEntered;
+    T3_64BIT_REGISTER dot3StatsFramesTooLong;
+    T3_64BIT_REGISTER etherStatsJabbers;
+    T3_64BIT_REGISTER etherStatsUndersizePkts;
+    T3_64BIT_REGISTER inRangeLengthError;
+    T3_64BIT_REGISTER outRangeLengthError;
+    T3_64BIT_REGISTER etherStatsPkts64Octets;
+    T3_64BIT_REGISTER etherStatsPkts65Octetsto127Octets;
+    T3_64BIT_REGISTER etherStatsPkts128Octetsto255Octets;
+    T3_64BIT_REGISTER etherStatsPkts256Octetsto511Octets;
+    T3_64BIT_REGISTER etherStatsPkts512Octetsto1023Octets;
+    T3_64BIT_REGISTER etherStatsPkts1024Octetsto1522Octets;
+    T3_64BIT_REGISTER etherStatsPkts1523Octetsto2047Octets;
+    T3_64BIT_REGISTER etherStatsPkts2048Octetsto4095Octets;
+    T3_64BIT_REGISTER etherStatsPkts4096Octetsto8191Octets;
+    T3_64BIT_REGISTER etherStatsPkts8192Octetsto9022Octets;
+
+    T3_64BIT_REGISTER Unused1[37];
+
+    /* Statistics maintained by Transmit MAC. */
+    T3_64BIT_REGISTER ifHCOutOctets;
+    T3_64BIT_REGISTER Reserved2;
+    T3_64BIT_REGISTER etherStatsCollisions;
+    T3_64BIT_REGISTER outXonSent;
+    T3_64BIT_REGISTER outXoffSent;
+    T3_64BIT_REGISTER flowControlDone;
+    T3_64BIT_REGISTER dot3StatsInternalMacTransmitErrors;
+    T3_64BIT_REGISTER dot3StatsSingleCollisionFrames;
+    T3_64BIT_REGISTER dot3StatsMultipleCollisionFrames;
+    T3_64BIT_REGISTER dot3StatsDeferredTransmissions;
+    T3_64BIT_REGISTER Reserved3;
+    T3_64BIT_REGISTER dot3StatsExcessiveCollisions;
+    T3_64BIT_REGISTER dot3StatsLateCollisions;
+    T3_64BIT_REGISTER dot3Collided2Times;
+    T3_64BIT_REGISTER dot3Collided3Times;
+    T3_64BIT_REGISTER dot3Collided4Times;
+    T3_64BIT_REGISTER dot3Collided5Times;
+    T3_64BIT_REGISTER dot3Collided6Times;
+    T3_64BIT_REGISTER dot3Collided7Times;
+    T3_64BIT_REGISTER dot3Collided8Times;
+    T3_64BIT_REGISTER dot3Collided9Times;
+    T3_64BIT_REGISTER dot3Collided10Times;
+    T3_64BIT_REGISTER dot3Collided11Times;
+    T3_64BIT_REGISTER dot3Collided12Times;
+    T3_64BIT_REGISTER dot3Collided13Times;
+    T3_64BIT_REGISTER dot3Collided14Times;
+    T3_64BIT_REGISTER dot3Collided15Times;
+    T3_64BIT_REGISTER ifHCOutUcastPkts;
+    T3_64BIT_REGISTER ifHCOutMulticastPkts;
+    T3_64BIT_REGISTER ifHCOutBroadcastPkts;
+    T3_64BIT_REGISTER dot3StatsCarrierSenseErrors;
+    T3_64BIT_REGISTER ifOutDiscards;
+    T3_64BIT_REGISTER ifOutErrors;
+
+    T3_64BIT_REGISTER Unused2[31];
+
+    /* Statistics maintained by Receive List Placement. */
+    T3_64BIT_REGISTER COSIfHCInPkts[16];
+    T3_64BIT_REGISTER COSFramesDroppedDueToFilters;
+    T3_64BIT_REGISTER nicDmaWriteQueueFull;
+    T3_64BIT_REGISTER nicDmaWriteHighPriQueueFull;
+    T3_64BIT_REGISTER nicNoMoreRxBDs;
+    T3_64BIT_REGISTER ifInDiscards;
+    T3_64BIT_REGISTER ifInErrors;
+    T3_64BIT_REGISTER nicRecvThresholdHit;
+
+    T3_64BIT_REGISTER Unused3[9];
+
+    /* Statistics maintained by Send Data Initiator. */
+    T3_64BIT_REGISTER COSIfHCOutPkts[16];
+    T3_64BIT_REGISTER nicDmaReadQueueFull;
+    T3_64BIT_REGISTER nicDmaReadHighPriQueueFull;
+    T3_64BIT_REGISTER nicSendDataCompQueueFull;
+
+    /* Statistics maintained by Host Coalescing. */
+    T3_64BIT_REGISTER nicRingSetSendProdIndex;
+    T3_64BIT_REGISTER nicRingStatusUpdate;
+    T3_64BIT_REGISTER nicInterrupts;
+    T3_64BIT_REGISTER nicAvoidedInterrupts;
+    T3_64BIT_REGISTER nicSendThresholdHit;
+
+    LM_UINT8 Reserved4[0xb00-0x9c0];
+} T3_STATS_BLOCK, *PT3_STATS_BLOCK;
+
+
+
+/******************************************************************************/
+/* PCI configuration registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_16BIT_REGISTER VendorId;
+    T3_16BIT_REGISTER DeviceId;
+
+    T3_16BIT_REGISTER Command;
+    T3_16BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER ClassCodeRevId;
+
+    T3_8BIT_REGISTER CacheLineSize;
+    T3_8BIT_REGISTER LatencyTimer;
+    T3_8BIT_REGISTER HeaderType;
+    T3_8BIT_REGISTER Bist;
+
+    T3_32BIT_REGISTER MemBaseAddrLow;
+    T3_32BIT_REGISTER MemBaseAddrHigh;
+
+    LM_UINT8 Unused1[20];
+
+    T3_16BIT_REGISTER SubsystemVendorId;
+    T3_16BIT_REGISTER SubsystemId;
+
+    T3_32BIT_REGISTER RomBaseAddr;
+
+    T3_8BIT_REGISTER PciXCapiblityPtr;
+    LM_UINT8 Unused2[7];
+
+    T3_8BIT_REGISTER IntLine;
+    T3_8BIT_REGISTER IntPin;
+    T3_8BIT_REGISTER MinGnt;
+    T3_8BIT_REGISTER MaxLat;
+
+    T3_8BIT_REGISTER PciXCapabilities;
+    T3_8BIT_REGISTER PmCapabilityPtr;
+    T3_16BIT_REGISTER PciXCommand;
+
+    T3_32BIT_REGISTER PciXStatus;
+
+    T3_8BIT_REGISTER PmCapabilityId;
+    T3_8BIT_REGISTER VpdCapabilityPtr;
+    T3_16BIT_REGISTER PmCapabilities;
+
+    T3_16BIT_REGISTER PmCtrlStatus;
+    #define PM_CTRL_PME_STATUS            BIT_15
+    #define PM_CTRL_PME_ENABLE            BIT_8
+    #define PM_CTRL_PME_POWER_STATE_D0    0
+    #define PM_CTRL_PME_POWER_STATE_D1    1
+    #define PM_CTRL_PME_POWER_STATE_D2    2
+    #define PM_CTRL_PME_POWER_STATE_D3H   3
+
+    T3_8BIT_REGISTER BridgeSupportExt;
+    T3_8BIT_REGISTER PmData;
+
+    T3_8BIT_REGISTER VpdCapabilityId;
+    T3_8BIT_REGISTER MsiCapabilityPtr;
+    T3_16BIT_REGISTER VpdAddrFlag;
+    #define VPD_FLAG_WRITE      (1 << 15)
+    #define VPD_FLAG_RW_MASK    (1 << 15)
+    #define VPD_FLAG_READ       0
+
+
+    T3_32BIT_REGISTER VpdData;
+
+    T3_8BIT_REGISTER MsiCapabilityId;
+    T3_8BIT_REGISTER NextCapabilityPtr;
+    T3_16BIT_REGISTER MsiCtrl;
+    #define MSI_CTRL_64BIT_CAP     (1 << 7)
+    #define MSI_CTRL_MSG_ENABLE(x) (x << 4)
+    #define MSI_CTRL_MSG_CAP(x)    (x << 1)
+    #define MSI_CTRL_ENABLE        (1 << 0)
+  
+
+    T3_32BIT_REGISTER MsiAddrLow;
+    T3_32BIT_REGISTER MsiAddrHigh;
+
+    T3_16BIT_REGISTER MsiData;
+    T3_16BIT_REGISTER Unused3;
+
+    T3_32BIT_REGISTER MiscHostCtrl;
+    #define MISC_HOST_CTRL_CLEAR_INT                        BIT_0
+    #define MISC_HOST_CTRL_MASK_PCI_INT                     BIT_1
+    #define MISC_HOST_CTRL_ENABLE_ENDIAN_BYTE_SWAP          BIT_2
+    #define MISC_HOST_CTRL_ENABLE_ENDIAN_WORD_SWAP          BIT_3
+    #define MISC_HOST_CTRL_ENABLE_PCI_STATE_REG_RW          BIT_4
+    #define MISC_HOST_CTRL_ENABLE_CLK_REG_RW                BIT_5
+    #define MISC_HOST_CTRL_ENABLE_REG_WORD_SWAP             BIT_6
+    #define MISC_HOST_CTRL_ENABLE_INDIRECT_ACCESS           BIT_7
+    #define MISC_HOST_CTRL_ENABLE_INT_MASK_MODE             BIT_8
+    #define MISC_HOST_CTRL_ENABLE_TAGGED_STATUS_MODE        BIT_9
+
+    T3_32BIT_REGISTER DmaReadWriteCtrl;
+    #define DMA_CTRL_WRITE_BOUNDARY_MASK            (BIT_11 | BIT_12 | BIT_13)
+    #define DMA_CTRL_WRITE_BOUNDARY_DISABLE         0
+    #define DMA_CTRL_WRITE_BOUNDARY_16              BIT_11
+    #define DMA_CTRL_WRITE_BOUNDARY_32              BIT_12
+    #define DMA_CTRL_WRITE_BOUNDARY_64              (BIT_12 | BIT_11)
+    #define DMA_CTRL_WRITE_BOUNDARY_128             BIT_13
+    #define DMA_CTRL_WRITE_BOUNDARY_256             (BIT_13 | BIT_11)
+    #define DMA_CTRL_WRITE_BOUNDARY_512             (BIT_13 | BIT_12)
+    #define DMA_CTRL_WRITE_BOUNDARY_1024            (BIT_13 | BIT_12 | BIT_11)
+    #define DMA_CTRL_WRITE_ONE_DMA_AT_ONCE          BIT_14
+
+
+    T3_32BIT_REGISTER PciState;
+    #define T3_PCI_STATE_FORCE_PCI_RESET                    BIT_0
+    #define T3_PCI_STATE_INTERRUPT_NOT_ACTIVE               BIT_1
+    #define T3_PCI_STATE_NOT_PCI_X_BUS                      BIT_2
+    #define T3_PCI_STATE_HIGH_BUS_SPEED                     BIT_3
+    #define T3_PCI_STATE_32BIT_PCI_BUS                      BIT_4
+    #define T3_PCI_STATE_PCI_ROM_ENABLE                     BIT_5
+    #define T3_PCI_STATE_PCI_ROM_RETRY_ENABLE               BIT_6
+    #define T3_PCI_STATE_FLAT_VIEW                          BIT_8
+
+    T3_32BIT_REGISTER ClockCtrl;
+    #define T3_PCI_CLKCTRL_TXCPU_CLK_DISABLE                BIT_11
+    #define T3_PCI_CLKCTRL_RXCPU_CLK_DISABLE                BIT_10
+    #define T3_PCI_CLKCTRL_CORE_CLK_DISABLE                 BIT_9
+
+    T3_32BIT_REGISTER RegBaseAddr;
+
+    T3_32BIT_REGISTER MemWindowBaseAddr;
+    
+#ifdef NIC_CPU_VIEW
+  /* These registers are ONLY visible to NIC CPU */
+    T3_32BIT_REGISTER PowerConsumed;
+    T3_32BIT_REGISTER PowerDissipated;
+#else /* NIC_CPU_VIEW */
+    T3_32BIT_REGISTER RegData;
+    T3_32BIT_REGISTER MemWindowData;
+#endif /* !NIC_CPU_VIEW */
+
+    T3_32BIT_REGISTER ModeCtrl;
+
+    T3_32BIT_REGISTER MiscCfg;
+
+    T3_32BIT_REGISTER MiscLocalCtrl;
+
+    T3_32BIT_REGISTER Unused4;
+
+    /* NOTE: Big/Little-endian clarification needed.  Are these register */
+    /* in big or little endian formate. */
+    T3_64BIT_REGISTER StdRingProdIdx;
+    T3_64BIT_REGISTER RcvRetRingConIdx;
+    T3_64BIT_REGISTER SndProdIdx;
+
+    LM_UINT8 Unused5[80];
+} T3_PCI_CONFIGURATION, *PT3_PCI_CONFIGURATION;
+
+
+
+/******************************************************************************/
+/* Mac control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* MAC mode control. */
+    T3_32BIT_REGISTER Mode;
+    #define MAC_MODE_GLOBAL_RESET                       BIT_0
+    #define MAC_MODE_HALF_DUPLEX                        BIT_1
+    #define MAC_MODE_PORT_MODE_MASK                     (BIT_2 | BIT_3)
+    #define MAC_MODE_PORT_MODE_TBI                      (BIT_2 | BIT_3)
+    #define MAC_MODE_PORT_MODE_GMII                     BIT_3
+    #define MAC_MODE_PORT_MODE_MII                      BIT_2
+    #define MAC_MODE_PORT_MODE_NONE                     BIT_NONE
+    #define MAC_MODE_PORT_INTERNAL_LOOPBACK             BIT_4
+    #define MAC_MODE_TAGGED_MAC_CONTROL                 BIT_7
+    #define MAC_MODE_TX_BURSTING                        BIT_8
+    #define MAC_MODE_MAX_DEFER                          BIT_9
+    #define MAC_MODE_LINK_POLARITY                      BIT_10
+    #define MAC_MODE_ENABLE_RX_STATISTICS               BIT_11
+    #define MAC_MODE_CLEAR_RX_STATISTICS                BIT_12
+    #define MAC_MODE_FLUSH_RX_STATISTICS                BIT_13
+    #define MAC_MODE_ENABLE_TX_STATISTICS               BIT_14
+    #define MAC_MODE_CLEAR_TX_STATISTICS                BIT_15
+    #define MAC_MODE_FLUSH_TX_STATISTICS                BIT_16
+    #define MAC_MODE_SEND_CONFIGS                       BIT_17
+    #define MAC_MODE_DETECT_MAGIC_PACKET_ENABLE         BIT_18
+    #define MAC_MODE_ACPI_POWER_ON_ENABLE               BIT_19
+    #define MAC_MODE_ENABLE_MIP                         BIT_20
+    #define MAC_MODE_ENABLE_TDE                         BIT_21
+    #define MAC_MODE_ENABLE_RDE                         BIT_22
+    #define MAC_MODE_ENABLE_FHDE                        BIT_23
+
+    /* MAC status */
+    T3_32BIT_REGISTER Status;
+    #define MAC_STATUS_PCS_SYNCED                       BIT_0
+    #define MAC_STATUS_SIGNAL_DETECTED                  BIT_1
+    #define MAC_STATUS_RECEIVING_CFG                    BIT_2
+    #define MAC_STATUS_CFG_CHANGED                      BIT_3
+    #define MAC_STATUS_SYNC_CHANGED                     BIT_4
+    #define MAC_STATUS_PORT_DECODE_ERROR                BIT_10
+    #define MAC_STATUS_LINK_STATE_CHANGED               BIT_12
+    #define MAC_STATUS_MI_COMPLETION                    BIT_22
+    #define MAC_STATUS_MI_INTERRUPT                     BIT_23
+    #define MAC_STATUS_AP_ERROR                         BIT_24
+    #define MAC_STATUS_ODI_ERROR                        BIT_25
+    #define MAC_STATUS_RX_STATS_OVERRUN                 BIT_26
+    #define MAC_STATUS_TX_STATS_OVERRUN                 BIT_27
+
+    /* Event Enable */
+    T3_32BIT_REGISTER MacEvent;
+    #define MAC_EVENT_ENABLE_PORT_DECODE_ERR            BIT_10
+    #define MAC_EVENT_ENABLE_LINK_STATE_CHANGED_ATTN    BIT_12
+    #define MAC_EVENT_ENABLE_MI_COMPLETION              BIT_22
+    #define MAC_EVENT_ENABLE_MI_INTERRUPT               BIT_23
+    #define MAC_EVENT_ENABLE_AP_ERROR                   BIT_24
+    #define MAC_EVENT_ENABLE_ODI_ERROR                  BIT_25
+    #define MAC_EVENT_ENABLE_RX_STATS_OVERRUN           BIT_26
+    #define MAC_EVENT_ENABLE_TX_STATS_OVERRUN           BIT_27
+
+    /* Led control. */
+    T3_32BIT_REGISTER LedCtrl;
+    #define LED_CTRL_OVERRIDE_LINK_LED                  BIT_0
+    #define LED_CTRL_1000MBPS_LED_ON                    BIT_1
+    #define LED_CTRL_100MBPS_LED_ON                     BIT_2
+    #define LED_CTRL_10MBPS_LED_ON                      BIT_3
+    #define LED_CTRL_OVERRIDE_TRAFFIC_LED               BIT_4
+    #define LED_CTRL_BLINK_TRAFFIC_LED                  BIT_5
+    #define LED_CTRL_TRAFFIC_LED                        BIT_6
+    #define LED_CTRL_1000MBPS_LED_STATUS                BIT_7
+    #define LED_CTRL_100MBPS_LED_STATUS                 BIT_8
+    #define LED_CTRL_10MBPS_LED_STATUS                  BIT_9
+    #define LED_CTRL_TRAFFIC_LED_STATUS                 BIT_10
+    #define LED_CTRL_MAC_MODE                           BIT_NONE
+    #define LED_CTRL_PHY_MODE_1                         BIT_11
+    #define LED_CTRL_PHY_MODE_2                         BIT_12
+    #define LED_CTRL_BLINK_RATE_MASK                    0x7ff80000
+    #define LED_CTRL_OVERRIDE_BLINK_PERIOD              BIT_19
+    #define LED_CTRL_OVERRIDE_BLINK_RATE                BIT_31
+
+    /* MAC addresses. */
+    struct {
+        T3_32BIT_REGISTER High;             /* Upper 2 bytes. */
+        T3_32BIT_REGISTER Low;              /* Lower 4 bytes. */
+    } MacAddr[4];
+
+    /* ACPI Mbuf pointer. */
+    T3_32BIT_REGISTER AcpiMbufPtr;
+
+    /* ACPI Length and Offset. */
+    T3_32BIT_REGISTER AcpiLengthOffset;
+    #define ACPI_LENGTH_MASK                            0xffff
+    #define ACPI_OFFSET_MASK                            0x0fff0000
+    #define ACPI_LENGTH(x)                              x
+    #define ACPI_OFFSET(x)                              ((x) << 16)
+
+    /* Transmit random backoff. */
+    T3_32BIT_REGISTER TxBackoffSeed;
+    #define MAC_TX_BACKOFF_SEED_MASK                    0x3ff
+
+    /* Receive MTU */
+    T3_32BIT_REGISTER MtuSize;
+    #define MAC_RX_MTU_MASK                             0xffff
+
+    /* Gigabit PCS Test. */
+    T3_32BIT_REGISTER PcsTest;
+    #define MAC_PCS_TEST_DATA_PATTERN_MASK              0x0fffff
+    #define MAC_PCS_TEST_ENABLE                         BIT_20
+
+    /* Transmit Gigabit Auto-Negotiation. */
+    T3_32BIT_REGISTER TxAutoNeg;
+    #define MAC_AN_TX_AN_DATA_MASK                      0xffff
+
+    /* Receive Gigabit Auto-Negotiation. */
+    T3_32BIT_REGISTER RxAutoNeg;
+    #define MAC_AN_RX_AN_DATA_MASK                      0xffff
+
+    /* MI Communication. */
+    T3_32BIT_REGISTER MiCom;
+    #define MI_COM_CMD_MASK                             (BIT_26 | BIT_27)
+    #define MI_COM_CMD_WRITE                            BIT_26
+    #define MI_COM_CMD_READ                             BIT_27
+    #define MI_COM_READ_FAILED                          BIT_28
+    #define MI_COM_START                                BIT_29
+    #define MI_COM_BUSY                                 BIT_29
+
+    #define MI_COM_PHY_ADDR_MASK                        0x1f
+    #define MI_COM_FIRST_PHY_ADDR_BIT                   21
+
+    #define MI_COM_PHY_REG_ADDR_MASK                    0x1f
+    #define MI_COM_FIRST_PHY_REG_ADDR_BIT               16
+
+    #define MI_COM_PHY_DATA_MASK                        0xffff
+
+    /* MI Status. */
+    T3_32BIT_REGISTER MiStatus;
+    #define MI_STATUS_ENABLE_LINK_STATUS_ATTN           BIT_0
+
+    /* MI Mode. */
+    T3_32BIT_REGISTER MiMode;
+    #define MI_MODE_CLOCK_SPEED_10MHZ                   BIT_0
+    #define MI_MODE_USE_SHORT_PREAMBLE                  BIT_1
+    #define MI_MODE_AUTO_POLLING_ENABLE                 BIT_4
+    #define MI_MODE_CORE_CLOCK_SPEED_62MHZ              BIT_15
+
+    /* Auto-polling status. */
+    T3_32BIT_REGISTER AutoPollStatus;
+    #define AUTO_POLL_ERROR                             BIT_0
+
+    /* Transmit MAC mode. */
+    T3_32BIT_REGISTER TxMode;
+    #define TX_MODE_RESET                               BIT_0
+    #define TX_MODE_ENABLE                              BIT_1
+    #define TX_MODE_ENABLE_FLOW_CONTROL                 BIT_4
+    #define TX_MODE_ENABLE_BIG_BACKOFF                  BIT_5
+    #define TX_MODE_ENABLE_LONG_PAUSE                   BIT_6
+
+    /* Transmit MAC status. */
+    T3_32BIT_REGISTER TxStatus;
+    #define TX_STATUS_RX_CURRENTLY_XOFFED               BIT_0
+    #define TX_STATUS_SENT_XOFF                         BIT_1
+    #define TX_STATUS_SENT_XON                          BIT_2
+    #define TX_STATUS_LINK_UP                           BIT_3
+    #define TX_STATUS_ODI_UNDERRUN                      BIT_4
+    #define TX_STATUS_ODI_OVERRUN                       BIT_5
+
+    /* Transmit MAC length. */
+    T3_32BIT_REGISTER TxLengths;
+    #define TX_LEN_SLOT_TIME_MASK                       0xff
+    #define TX_LEN_IPG_MASK                             0x0f00
+    #define TX_LEN_IPG_CRS_MASK                         (BIT_12 | BIT_13)
+
+    /* Receive MAC mode. */
+    T3_32BIT_REGISTER RxMode;
+    #define RX_MODE_RESET                               BIT_0
+    #define RX_MODE_ENABLE                              BIT_1
+    #define RX_MODE_ENABLE_FLOW_CONTROL                 BIT_2
+    #define RX_MODE_KEEP_MAC_CONTROL                    BIT_3
+    #define RX_MODE_KEEP_PAUSE                          BIT_4
+    #define RX_MODE_ACCEPT_OVERSIZED                    BIT_5
+    #define RX_MODE_ACCEPT_RUNTS                        BIT_6
+    #define RX_MODE_LENGTH_CHECK                        BIT_7
+    #define RX_MODE_PROMISCUOUS_MODE                    BIT_8
+    #define RX_MODE_NO_CRC_CHECK                        BIT_9
+    #define RX_MODE_KEEP_VLAN_TAG                       BIT_10
+
+    /* Receive MAC status. */
+    T3_32BIT_REGISTER RxStatus;
+    #define RX_STATUS_REMOTE_TRANSMITTER_XOFFED         BIT_0
+    #define RX_STATUS_XOFF_RECEIVED                     BIT_1
+    #define RX_STATUS_XON_RECEIVED                      BIT_2
+
+    /* Hash registers. */
+    T3_32BIT_REGISTER HashReg[4];
+
+    /* Receive placement rules registers. */
+    struct {
+        T3_32BIT_REGISTER Rule;
+        T3_32BIT_REGISTER Value;
+    } RcvRules[16];
+
+    #define RCV_DISABLE_RULE_MASK                       0x7fffffff
+
+    #define RCV_RULE1_REJECT_BROADCAST_IDX              0x00
+    #define REJECT_BROADCAST_RULE1_RULE                 0xc2000000
+    #define REJECT_BROADCAST_RULE1_VALUE                0xffffffff
+
+    #define RCV_RULE2_REJECT_BROADCAST_IDX              0x01
+    #define REJECT_BROADCAST_RULE2_RULE                 0x86000004
+    #define REJECT_BROADCAST_RULE2_VALUE                0xffffffff
+
+#if INCLUDE_5701_AX_FIX
+    #define RCV_LAST_RULE_IDX                           0x04
+#else
+    #define RCV_LAST_RULE_IDX                           0x02
+#endif
+
+    T3_32BIT_REGISTER RcvRuleCfg;
+    #define RX_RULE_DEFAULT_CLASS                       (1 << 3)
+
+    LM_UINT8 Reserved1[140];
+
+    T3_32BIT_REGISTER SerdesCfg;
+    T3_32BIT_REGISTER SerdesStatus;
+
+    LM_UINT8 Reserved2[104];
+
+    volatile LM_UINT8 TxMacState[16];
+    volatile LM_UINT8 RxMacState[20];
+
+    LM_UINT8 Reserved3[476];
+
+    T3_32BIT_REGISTER RxStats[26];
+
+    LM_UINT8 Reserved4[24];
+
+    T3_32BIT_REGISTER TxStats[28];
+
+    LM_UINT8 Reserved5[784];
+} T3_MAC_CONTROL, *PT3_MAC_CONTROL;
+
+
+
+/******************************************************************************/
+/* Send data initiator control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define T3_SND_DATA_IN_MODE_RESET                       BIT_0
+    #define T3_SND_DATA_IN_MODE_ENABLE                      BIT_1
+    #define T3_SND_DATA_IN_MODE_STATS_OFLW_ATTN_ENABLE      BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define T3_SND_DATA_IN_STATUS_STATS_OFLW_ATTN           BIT_2
+
+    T3_32BIT_REGISTER StatsCtrl;
+    #define T3_SND_DATA_IN_STATS_CTRL_ENABLE                BIT_0
+    #define T3_SND_DATA_IN_STATS_CTRL_FASTER_UPDATE         BIT_1
+    #define T3_SND_DATA_IN_STATS_CTRL_CLEAR                 BIT_2
+    #define T3_SND_DATA_IN_STATS_CTRL_FLUSH                 BIT_3
+    #define T3_SND_DATA_IN_STATS_CTRL_FORCE_ZERO            BIT_4
+
+    T3_32BIT_REGISTER StatsEnableMask;
+    T3_32BIT_REGISTER StatsIncMask;
+
+    LM_UINT8 Reserved[108];
+
+    T3_32BIT_REGISTER ClassOfServCnt[16];
+    T3_32BIT_REGISTER DmaReadQFullCnt;
+    T3_32BIT_REGISTER DmaPriorityReadQFullCnt;
+    T3_32BIT_REGISTER SdcQFullCnt;
+
+    T3_32BIT_REGISTER NicRingSetSendProdIdxCnt;
+    T3_32BIT_REGISTER StatusUpdatedCnt;
+    T3_32BIT_REGISTER InterruptsCnt;
+    T3_32BIT_REGISTER AvoidInterruptsCnt;
+    T3_32BIT_REGISTER SendThresholdHitCnt;
+
+    /* Unused space. */
+    LM_UINT8 Unused[800];
+} T3_SEND_DATA_INITIATOR, *PT3_SEND_DATA_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Send data completion control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_DATA_COMP_MODE_RESET                        BIT_0
+    #define SND_DATA_COMP_MODE_ENABLE                       BIT_1
+
+    /* Unused space. */
+    LM_UINT8 Unused[1020];
+} T3_SEND_DATA_COMPLETION, *PT3_SEND_DATA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Send BD Ring Selector Control Registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_SEL_MODE_RESET                           BIT_0
+    #define SND_BD_SEL_MODE_ENABLE                          BIT_1
+    #define SND_BD_SEL_MODE_ATTN_ENABLE                     BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define SND_BD_SEL_STATUS_ERROR_ATTN                    BIT_2
+
+    T3_32BIT_REGISTER HwDiag;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[52];
+
+    /* Send BD Ring Selector Local NIC Send BD Consumer Index. */
+    T3_32BIT_REGISTER NicSendBdSelConIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused2[896];
+} T3_SEND_BD_SELECTOR, *PT3_SEND_BD_SELECTOR;
+
+
+
+/******************************************************************************/
+/* Send BD initiator control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_IN_MODE_RESET                            BIT_0
+    #define SND_BD_IN_MODE_ENABLE                           BIT_1
+    #define SND_BD_IN_MODE_ATTN_ENABLE                      BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define SND_BD_IN_STATUS_ERROR_ATTN                     BIT_2
+
+    /* Send BD initiator local NIC send BD producer index. */
+    T3_32BIT_REGISTER NicSendBdInProdIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused2[952];
+} T3_SEND_BD_INITIATOR, *PT3_SEND_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Send BD Completion Control. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define SND_BD_COMP_MODE_RESET                          BIT_0
+    #define SND_BD_COMP_MODE_ENABLE                         BIT_1
+    #define SND_BD_COMP_MODE_ATTN_ENABLE                    BIT_2
+
+    /* Unused space. */
+    LM_UINT8 Unused2[1020];
+} T3_SEND_BD_COMPLETION, *PT3_SEND_BD_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive list placement control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define RCV_LIST_PLMT_MODE_RESET                        BIT_0
+    #define RCV_LIST_PLMT_MODE_ENABLE                       BIT_1
+    #define RCV_LIST_PLMT_MODE_CLASS0_ATTN_ENABLE           BIT_2
+    #define RCV_LIST_PLMT_MODE_MAPPING_OOR_ATTN_ENABLE      BIT_3
+    #define RCV_LIST_PLMT_MODE_STATS_OFLOW_ATTN_ENABLE      BIT_4
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define RCV_LIST_PLMT_STATUS_CLASS0_ATTN                BIT_2
+    #define RCV_LIST_PLMT_STATUS_MAPPING_ATTN               BIT_3
+    #define RCV_LIST_PLMT_STATUS_STATS_OFLOW_ATTN           BIT_4
+
+    /* Receive selector list lock register. */
+    T3_32BIT_REGISTER Lock;
+    #define RCV_LIST_SEL_LOCK_REQUEST_MASK                  0xffff
+    #define RCV_LIST_SEL_LOCK_GRANT_MASK                    0xffff0000
+
+    /* Selector non-empty bits. */
+    T3_32BIT_REGISTER NonEmptyBits;
+    #define RCV_LIST_SEL_NON_EMPTY_MASK                     0xffff
+
+    /* Receive list placement configuration register. */
+    T3_32BIT_REGISTER Config;
+
+    /* Receive List Placement statistics Control. */
+    T3_32BIT_REGISTER StatsCtrl;
+#define RCV_LIST_STATS_ENABLE                               BIT_0
+#define RCV_LIST_STATS_FAST_UPDATE                          BIT_1
+
+    /* Receive List Placement statistics Enable Mask. */
+    T3_32BIT_REGISTER StatsEnableMask;
+
+    /* Receive List Placement statistics Increment Mask. */
+    T3_32BIT_REGISTER StatsIncMask;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[224];
+
+    struct {
+        T3_32BIT_REGISTER Head;
+        T3_32BIT_REGISTER Tail;
+        T3_32BIT_REGISTER Count;
+
+        /* Unused space. */
+        LM_UINT8 Unused[4];
+    } RcvSelectorList[16];
+
+    /* Local statistics counter. */
+    T3_32BIT_REGISTER ClassOfServCnt[16];
+
+    T3_32BIT_REGISTER DropDueToFilterCnt;
+    T3_32BIT_REGISTER DmaWriteQFullCnt;
+    T3_32BIT_REGISTER DmaHighPriorityWriteQFullCnt;
+    T3_32BIT_REGISTER NoMoreReceiveBdCnt;
+    T3_32BIT_REGISTER IfInDiscardsCnt;
+    T3_32BIT_REGISTER IfInErrorsCnt;
+    T3_32BIT_REGISTER RcvThresholdHitCnt;
+
+    /* Another unused space. */
+    LM_UINT8 Unused2[420];
+} T3_RCV_LIST_PLACEMENT, *PT3_RCV_LIST_PLACEMENT;
+
+
+
+/******************************************************************************/
+/* Receive Data and Receive BD Initiator Control. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define RCV_DATA_BD_IN_MODE_RESET                   BIT_0
+    #define RCV_DATA_BD_IN_MODE_ENABLE                  BIT_1
+    #define RCV_DATA_BD_IN_MODE_JUMBO_BD_NEEDED         BIT_2
+    #define RCV_DATA_BD_IN_MODE_FRAME_TOO_BIG           BIT_3
+    #define RCV_DATA_BD_IN_MODE_INVALID_RING_SIZE       BIT_4
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define RCV_DATA_BD_IN_STATUS_JUMBO_BD_NEEDED       BIT_2
+    #define RCV_DATA_BD_IN_STATUS_FRAME_TOO_BIG         BIT_3
+    #define RCV_DATA_BD_IN_STATUS_INVALID_RING_SIZE     BIT_4
+
+    /* Split frame minium size. */
+    T3_32BIT_REGISTER SplitFrameMinSize;
+
+    /* Unused space. */
+    LM_UINT8 Unused1[0x2440-0x240c];
+
+    /* Receive RCBs. */
+    T3_RCB JumboRcvRcb;
+    T3_RCB StdRcvRcb;
+    T3_RCB MiniRcvRcb;
+
+    /* Receive Data and Receive BD Ring Initiator Local NIC Receive */
+    /* BD Consumber Index. */
+    T3_32BIT_REGISTER NicJumboConIdx;
+    T3_32BIT_REGISTER NicStdConIdx;
+    T3_32BIT_REGISTER NicMiniConIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[4];
+
+    /* Receive Data and Receive BD Initiator Local Receive Return ProdIdx. */
+    T3_32BIT_REGISTER RcvDataBdProdIdx[16];
+
+    /* Receive Data and Receive BD Initiator Hardware Diagnostic. */
+    T3_32BIT_REGISTER HwDiag;
+
+    /* Unused space. */
+    LM_UINT8 Unused3[828];
+} T3_RCV_DATA_BD_INITIATOR, *PT3_RCV_DATA_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Receive Data Completion Control Registes. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_DATA_COMP_MODE_RESET                        BIT_0
+    #define RCV_DATA_COMP_MODE_ENABLE                       BIT_1
+    #define RCV_DATA_COMP_MODE_ATTN_ENABLE                  BIT_2
+
+    /* Unused spaced. */
+    LM_UINT8 Unused[1020];
+} T3_RCV_DATA_COMPLETION, *PT3_RCV_DATA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive BD Initiator Control. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_BD_IN_MODE_RESET                            BIT_0
+    #define RCV_BD_IN_MODE_ENABLE                           BIT_1
+    #define RCV_BD_IN_MODE_BD_IN_DIABLED_RCB_ATTN_ENABLE    BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_BD_IN_STATUS_BD_IN_DIABLED_RCB_ATTN         BIT_2
+
+    T3_32BIT_REGISTER NicJumboRcvProdIdx;
+    T3_32BIT_REGISTER NicStdRcvProdIdx;
+    T3_32BIT_REGISTER NicMiniRcvProdIdx;
+
+    T3_32BIT_REGISTER MiniRcvThreshold;
+    T3_32BIT_REGISTER StdRcvThreshold;
+    T3_32BIT_REGISTER JumboRcvThreshold;
+
+    /* Unused space. */
+    LM_UINT8 Unused[992];
+} T3_RCV_BD_INITIATOR, *PT3_RCV_BD_INITIATOR;
+
+
+
+/******************************************************************************/
+/* Receive BD Completion Control Registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_BD_COMP_MODE_RESET                          BIT_0
+    #define RCV_BD_COMP_MODE_ENABLE                         BIT_1
+    #define RCV_BD_COMP_MODE_ATTN_ENABLE                    BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_BD_COMP_STATUS_ERROR_ATTN                   BIT_2
+
+    T3_32BIT_REGISTER  NicJumboRcvBdProdIdx;
+    T3_32BIT_REGISTER  NicStdRcvBdProdIdx;
+    T3_32BIT_REGISTER  NicMiniRcvBdProdIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1004];
+} T3_RCV_BD_COMPLETION, *PT3_RCV_BD_COMPLETION;
+
+
+
+/******************************************************************************/
+/* Receive list selector control register. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define RCV_LIST_SEL_MODE_RESET                         BIT_0
+    #define RCV_LIST_SEL_MODE_ENABLE                        BIT_1
+    #define RCV_LIST_SEL_MODE_ATTN_ENABLE                   BIT_2
+
+    T3_32BIT_REGISTER Status;
+    #define RCV_LIST_SEL_STATUS_ERROR_ATTN                  BIT_2
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_RCV_LIST_SELECTOR, *PT3_RCV_LIST_SELECTOR;
+
+
+
+/******************************************************************************/
+/* Mbuf cluster free registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define MBUF_CLUSTER_FREE_MODE_RESET    BIT_0
+#define MBUF_CLUSTER_FREE_MODE_ENABLE   BIT_1
+
+    T3_32BIT_REGISTER Status;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_MBUF_CLUSTER_FREE, *PT3_MBUF_CLUSTER_FREE;
+
+
+
+/******************************************************************************/
+/* Host coalescing control registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode. */
+    T3_32BIT_REGISTER Mode;
+    #define HOST_COALESCE_RESET                         BIT_0
+    #define HOST_COALESCE_ENABLE                        BIT_1
+    #define HOST_COALESCE_ATTN                          BIT_2
+    #define HOST_COALESCE_NOW                           BIT_3
+    #define HOST_COALESCE_FULL_STATUS_MODE              BIT_NONE
+    #define HOST_COALESCE_64_BYTE_STATUS_MODE           BIT_7
+    #define HOST_COALESCE_32_BYTE_STATUS_MODE           BIT_8
+    #define HOST_COALESCE_CLEAR_TICKS_ON_RX_BD_EVENT    BIT_9
+    #define HOST_COALESCE_CLEAR_TICKS_ON_TX_BD_EVENT    BIT_10
+    #define HOST_COALESCE_NO_INT_ON_COALESCE_NOW_MODE   BIT_11
+    #define HOST_COALESCE_NO_INT_ON_FORCE_DMAD_MODE     BIT_12
+
+    /* Status. */
+    T3_32BIT_REGISTER Status;
+    #define HOST_COALESCE_ERROR_ATTN                    BIT_2
+
+    /* Receive coalescing ticks. */
+    T3_32BIT_REGISTER RxCoalescingTicks;
+
+    /* Send coalescing ticks. */
+    T3_32BIT_REGISTER TxCoalescingTicks;
+
+    /* Receive max coalesced frames. */
+    T3_32BIT_REGISTER RxMaxCoalescedFrames;
+
+    /* Send max coalesced frames. */
+    T3_32BIT_REGISTER TxMaxCoalescedFrames;
+
+    /* Receive coalescing ticks during interrupt. */
+    T3_32BIT_REGISTER RxCoalescedTickDuringInt;
+
+    /* Send coalescing ticks during interrupt. */
+    T3_32BIT_REGISTER TxCoalescedTickDuringInt;
+
+    /* Receive max coalesced frames during interrupt. */
+    T3_32BIT_REGISTER RxMaxCoalescedFramesDuringInt;
+
+    /* Send max coalesced frames during interrupt. */
+    T3_32BIT_REGISTER TxMaxCoalescedFramesDuringInt;
+
+    /* Statistics tick. */
+    T3_32BIT_REGISTER StatsCoalescingTicks;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[4];
+
+    /* Statistics host address. */
+    T3_64BIT_REGISTER StatsBlkHostAddr;
+
+    /* Status block host address.*/
+    T3_64BIT_REGISTER StatusBlkHostAddr;
+
+    /* Statistics NIC address. */
+    T3_32BIT_REGISTER StatsBlkNicAddr;
+
+    /* Statust block NIC address. */
+    T3_32BIT_REGISTER StatusBlkNicAddr;
+
+    /* Flow attention registers. */
+    T3_32BIT_REGISTER FlowAttn;
+
+    /* Unused space. */
+    LM_UINT8 Unused3[4];
+
+    T3_32BIT_REGISTER NicJumboRcvBdConIdx;
+    T3_32BIT_REGISTER NicStdRcvBdConIdx;
+    T3_32BIT_REGISTER NicMiniRcvBdConIdx;
+
+    /* Unused space. */
+    LM_UINT8 Unused4[36];
+
+    T3_32BIT_REGISTER NicRetProdIdx[16];
+    T3_32BIT_REGISTER NicSndBdConIdx[16];
+
+    /* Unused space. */
+    LM_UINT8 Unused5[768];
+} T3_HOST_COALESCING, *PT3_HOST_COALESCING;
+
+
+
+/******************************************************************************/
+/* Memory arbiter registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define T3_MEM_ARBITER_MODE_RESET       BIT_0
+#define T3_MEM_ARBITER_MODE_ENABLE      BIT_1
+
+    T3_32BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER ArbTrapAddrLow;
+    T3_32BIT_REGISTER ArbTrapAddrHigh;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1008];
+} T3_MEM_ARBITER, *PT3_MEM_ARBITER;
+
+
+
+/******************************************************************************/
+/* Buffer manager control register. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define BUFMGR_MODE_RESET                           BIT_0
+    #define BUFMGR_MODE_ENABLE                          BIT_1
+    #define BUFMGR_MODE_ATTN_ENABLE                     BIT_2
+    #define BUFMGR_MODE_BM_TEST                         BIT_3
+    #define BUFMGR_MODE_MBUF_LOW_ATTN_ENABLE            BIT_4
+
+    T3_32BIT_REGISTER Status;
+    #define BUFMGR_STATUS_ERROR                         BIT_2
+    #define BUFMGR_STATUS_MBUF_LOW                      BIT_4
+
+    T3_32BIT_REGISTER MbufPoolAddr;
+    T3_32BIT_REGISTER MbufPoolSize;
+    T3_32BIT_REGISTER MbufReadDmaLowWaterMark;
+    T3_32BIT_REGISTER MbufMacRxLowWaterMark;
+    T3_32BIT_REGISTER MbufHighWaterMark;
+
+    T3_32BIT_REGISTER RxCpuMbufAllocReq;
+    #define BUFMGR_MBUF_ALLOC_BIT                     BIT_31
+    T3_32BIT_REGISTER RxCpuMbufAllocResp;
+    T3_32BIT_REGISTER TxCpuMbufAllocReq;
+    T3_32BIT_REGISTER TxCpuMbufAllocResp;
+
+    T3_32BIT_REGISTER DmaDescPoolAddr;
+    T3_32BIT_REGISTER DmaDescPoolSize;
+    T3_32BIT_REGISTER DmaLowWaterMark;
+    T3_32BIT_REGISTER DmaHighWaterMark;
+
+    T3_32BIT_REGISTER RxCpuDmaAllocReq;
+    T3_32BIT_REGISTER RxCpuDmaAllocResp;
+    T3_32BIT_REGISTER TxCpuDmaAllocReq;
+    T3_32BIT_REGISTER TxCpuDmaAllocResp;
+
+    T3_32BIT_REGISTER Hwdiag[3];
+
+    /* Unused space. */
+    LM_UINT8 Unused[936];
+} T3_BUFFER_MANAGER, *PT3_BUFFER_MANAGER;
+
+
+
+/******************************************************************************/
+/* Read DMA control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_READ_MODE_RESET                         BIT_0
+    #define DMA_READ_MODE_ENABLE                        BIT_1
+    #define DMA_READ_MODE_TARGET_ABORT_ATTN_ENABLE      BIT_2
+    #define DMA_READ_MODE_MASTER_ABORT_ATTN_ENABLE      BIT_3
+    #define DMA_READ_MODE_PARITY_ERROR_ATTN_ENABLE      BIT_4
+    #define DMA_READ_MODE_ADDR_OVERFLOW_ATTN_ENABLE     BIT_5
+    #define DMA_READ_MODE_FIFO_OVERRUN_ATTN_ENABLE      BIT_6
+    #define DMA_READ_MODE_FIFO_UNDERRUN_ATTN_ENABLE     BIT_7
+    #define DMA_READ_MODE_FIFO_OVERREAD_ATTN_ENABLE     BIT_8
+    #define DMA_READ_MODE_LONG_READ_ATTN_ENABLE         BIT_9
+
+    T3_32BIT_REGISTER Status;
+    #define DMA_READ_STATUS_TARGET_ABORT_ATTN           BIT_2
+    #define DMA_READ_STATUS_MASTER_ABORT_ATTN           BIT_3
+    #define DMA_READ_STATUS_PARITY_ERROR_ATTN           BIT_4
+    #define DMA_READ_STATUS_ADDR_OVERFLOW_ATTN          BIT_5
+    #define DMA_READ_STATUS_FIFO_OVERRUN_ATTN           BIT_6
+    #define DMA_READ_STATUS_FIFO_UNDERRUN_ATTN          BIT_7
+    #define DMA_READ_STATUS_FIFO_OVERREAD_ATTN          BIT_8
+    #define DMA_READ_STATUS_LONG_READ_ATTN              BIT_9
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_DMA_READ, *PT3_DMA_READ;
+
+typedef union T3_CPU 
+{
+  struct
+  {
+    T3_32BIT_REGISTER mode;
+    #define CPU_MODE_HALT   BIT_10
+    #define CPU_MODE_RESET  BIT_0 
+    T3_32BIT_REGISTER state;
+    T3_32BIT_REGISTER EventMask;
+    T3_32BIT_REGISTER reserved1[4];
+    T3_32BIT_REGISTER PC;
+    T3_32BIT_REGISTER Instruction;
+    T3_32BIT_REGISTER SpadUnderflow;
+    T3_32BIT_REGISTER WatchdogClear;
+    T3_32BIT_REGISTER WatchdogVector;
+    T3_32BIT_REGISTER WatchdogSavedPC;
+    T3_32BIT_REGISTER HardwareBp;
+    T3_32BIT_REGISTER reserved2[3];
+    T3_32BIT_REGISTER WatchdogSavedState;    
+    T3_32BIT_REGISTER LastBrchAddr;    
+    T3_32BIT_REGISTER SpadUnderflowSet;    
+    T3_32BIT_REGISTER reserved3[(0x200-0x50)/4];
+    T3_32BIT_REGISTER Regs[32];
+    T3_32BIT_REGISTER reserved4[(0x400-0x280)/4];
+  }reg;
+}T3_CPU, *PT3_CPU;
+
+/******************************************************************************/
+/* Write DMA control registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_WRITE_MODE_RESET                        BIT_0
+    #define DMA_WRITE_MODE_ENABLE                       BIT_1
+    #define DMA_WRITE_MODE_TARGET_ABORT_ATTN_ENABLE     BIT_2
+    #define DMA_WRITE_MODE_MASTER_ABORT_ATTN_ENABLE     BIT_3
+    #define DMA_WRITE_MODE_PARITY_ERROR_ATTN_ENABLE     BIT_4
+    #define DMA_WRITE_MODE_ADDR_OVERFLOW_ATTN_ENABLE    BIT_5
+    #define DMA_WRITE_MODE_FIFO_OVERRUN_ATTN_ENABLE     BIT_6
+    #define DMA_WRITE_MODE_FIFO_UNDERRUN_ATTN_ENABLE    BIT_7
+    #define DMA_WRITE_MODE_FIFO_OVERREAD_ATTN_ENABLE    BIT_8
+    #define DMA_WRITE_MODE_LONG_READ_ATTN_ENABLE        BIT_9
+
+    T3_32BIT_REGISTER Status;
+    #define DMA_WRITE_STATUS_TARGET_ABORT_ATTN          BIT_2
+    #define DMA_WRITE_STATUS_MASTER_ABORT_ATTN          BIT_3
+    #define DMA_WRITE_STATUS_PARITY_ERROR_ATTN          BIT_4
+    #define DMA_WRITE_STATUS_ADDR_OVERFLOW_ATTN         BIT_5
+    #define DMA_WRITE_STATUS_FIFO_OVERRUN_ATTN          BIT_6
+    #define DMA_WRITE_STATUS_FIFO_UNDERRUN_ATTN         BIT_7
+    #define DMA_WRITE_STATUS_FIFO_OVERREAD_ATTN         BIT_8
+    #define DMA_WRITE_STATUS_LONG_READ_ATTN             BIT_9
+
+    /* Unused space. */
+    LM_UINT8 Unused[1016];
+} T3_DMA_WRITE, *PT3_DMA_WRITE;
+
+
+
+/******************************************************************************/
+/* Mailbox registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Interrupt mailbox registers. */
+    T3_64BIT_REGISTER Interrupt[4];
+
+    /* General mailbox registers. */
+    T3_64BIT_REGISTER General[8];
+
+    /* Reload statistics mailbox. */
+    T3_64BIT_REGISTER ReloadStat;
+
+    /* Receive BD ring producer index registers. */
+    T3_64BIT_REGISTER RcvStdProdIdx;
+    T3_64BIT_REGISTER RcvJumboProdIdx;
+    T3_64BIT_REGISTER RcvMiniProdIdx;
+
+    /* Receive return ring consumer index registers. */
+    T3_64BIT_REGISTER RcvRetConIdx[16];
+
+    /* Send BD ring host producer index registers. */
+    T3_64BIT_REGISTER SendHostProdIdx[16];
+
+    /* Send BD ring nic producer index registers. */
+    T3_64BIT_REGISTER SendNicProdIdx[16];
+}T3_MAILBOX, *PT3_MAILBOX;
+
+typedef struct {
+    T3_MAILBOX Mailbox;
+
+    /* Priority mailbox registers. */
+    T3_32BIT_REGISTER HighPriorityEventVector;
+    T3_32BIT_REGISTER HighPriorityEventMask;
+    T3_32BIT_REGISTER LowPriorityEventVector;
+    T3_32BIT_REGISTER LowPriorityEventMask;
+
+    /* Unused space. */
+    LM_UINT8 Unused[496];
+} T3_GRC_MAILBOX, *PT3_GRC_MAILBOX;
+
+
+/******************************************************************************/
+/* Flow through queues. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Reset;
+    
+    LM_UINT8 Unused[12];
+
+    T3_32BIT_REGISTER DmaNormalReadFtqCtrl;
+    T3_32BIT_REGISTER DmaNormalReadFtqFullCnt;
+    T3_32BIT_REGISTER DmaNormalReadFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaNormalReadFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaHighReadFtqCtrl;
+    T3_32BIT_REGISTER DmaHighReadFtqFullCnt;
+    T3_32BIT_REGISTER DmaHighReadFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaHighReadFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaCompDiscardFtqCtrl;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFullCnt;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaCompDiscardFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendBdCompFtqCtrl;
+    T3_32BIT_REGISTER SendBdCompFtqFullCnt;
+    T3_32BIT_REGISTER SendBdCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendBdCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendDataInitiatorFtqCtrl;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFullCnt;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendDataInitiatorFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaNormalWriteFtqCtrl;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFullCnt;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaNormalWriteFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER DmaHighWriteFtqCtrl;
+    T3_32BIT_REGISTER DmaHighWriteFtqFullCnt;
+    T3_32BIT_REGISTER DmaHighWriteFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER DmaHighWriteFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SwType1FtqCtrl;
+    T3_32BIT_REGISTER SwType1FtqFullCnt;
+    T3_32BIT_REGISTER SwType1FtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SwType1FtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SendDataCompFtqCtrl;
+    T3_32BIT_REGISTER SendDataCompFtqFullCnt;
+    T3_32BIT_REGISTER SendDataCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SendDataCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER HostCoalesceFtqCtrl;
+    T3_32BIT_REGISTER HostCoalesceFtqFullCnt;
+    T3_32BIT_REGISTER HostCoalesceFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER HostCoalesceFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER MacTxFtqCtrl;
+    T3_32BIT_REGISTER MacTxFtqFullCnt;
+    T3_32BIT_REGISTER MacTxFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER MacTxFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER MbufClustFreeFtqCtrl;
+    T3_32BIT_REGISTER MbufClustFreeFtqFullCnt;
+    T3_32BIT_REGISTER MbufClustFreeFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER MbufClustFreeFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvBdCompFtqCtrl;
+    T3_32BIT_REGISTER RcvBdCompFtqFullCnt;
+    T3_32BIT_REGISTER RcvBdCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvBdCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvListPlmtFtqCtrl;
+    T3_32BIT_REGISTER RcvListPlmtFtqFullCnt;
+    T3_32BIT_REGISTER RcvListPlmtFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvListPlmtFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqCtrl;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFullCnt;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvDataBdInitiatorFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER RcvDataCompFtqCtrl;
+    T3_32BIT_REGISTER RcvDataCompFtqFullCnt;
+    T3_32BIT_REGISTER RcvDataCompFtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER RcvDataCompFtqFifoWritePeek;
+
+    T3_32BIT_REGISTER SwType2FtqCtrl;
+    T3_32BIT_REGISTER SwType2FtqFullCnt;
+    T3_32BIT_REGISTER SwType2FtqFifoEnqueueDequeue;
+    T3_32BIT_REGISTER SwType2FtqFifoWritePeek;
+
+    /* Unused space. */
+    LM_UINT8 Unused2[736];
+} T3_FTQ, *PT3_FTQ;
+
+
+
+/******************************************************************************/
+/* Message signaled interrupt registers. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+#define MSI_MODE_RESET       BIT_0
+#define MSI_MODE_ENABLE      BIT_1
+    T3_32BIT_REGISTER Status;
+
+    T3_32BIT_REGISTER MsiFifoAccess;
+
+    /* Unused space. */
+    LM_UINT8 Unused[1012];
+} T3_MSG_SIGNALED_INT, *PT3_MSG_SIGNALED_INT;
+
+
+
+/******************************************************************************/
+/* DMA Completion registes. */
+/******************************************************************************/
+
+typedef struct {
+    T3_32BIT_REGISTER Mode;
+    #define DMA_COMP_MODE_RESET                         BIT_0
+    #define DMA_COMP_MODE_ENABLE                        BIT_1
+
+    /* Unused space. */
+    LM_UINT8 Unused[1020];
+} T3_DMA_COMPLETION, *PT3_DMA_COMPLETION;
+
+
+
+/******************************************************************************/
+/* GRC registers. */
+/******************************************************************************/
+
+typedef struct {
+    /* Mode control register. */
+    T3_32BIT_REGISTER Mode;
+    #define GRC_MODE_UPDATE_ON_COALESCING               BIT_0
+    #define GRC_MODE_BYTE_SWAP_NON_FRAME_DATA           BIT_1
+    #define GRC_MODE_WORD_SWAP_NON_FRAME_DATA           BIT_2
+    #define GRC_MODE_BYTE_SWAP_DATA                     BIT_4
+    #define GRC_MODE_WORD_SWAP_DATA                     BIT_5
+    #define GRC_MODE_SPLIT_HEADER_MODE                  BIT_8
+    #define GRC_MODE_NO_FRAME_CRACKING                  BIT_9
+    #define GRC_MODE_INCLUDE_CRC                        BIT_10
+    #define GRC_MODE_ALLOW_BAD_FRAMES                   BIT_11
+    #define GRC_MODE_NO_INTERRUPT_ON_SENDS              BIT_13
+    #define GRC_MODE_NO_INTERRUPT_ON_RECEIVE            BIT_14
+    #define GRC_MODE_FORCE_32BIT_PCI_BUS_MODE           BIT_15
+    #define GRC_MODE_HOST_STACK_UP                      BIT_16
+    #define GRC_MODE_HOST_SEND_BDS                      BIT_17
+    #define GRC_MODE_TX_NO_PSEUDO_HEADER_CHKSUM         BIT_20
+    #define GRC_MODE_RX_NO_PSEUDO_HEADER_CHKSUM         BIT_23
+    #define GRC_MODE_INT_ON_TX_CPU_ATTN                 BIT_24
+    #define GRC_MODE_INT_ON_RX_CPU_ATTN                 BIT_25
+    #define GRC_MODE_INT_ON_MAC_ATTN                    BIT_26
+    #define GRC_MODE_INT_ON_DMA_ATTN                    BIT_27
+    #define GRC_MODE_INT_ON_FLOW_ATTN                   BIT_28
+    #define GRC_MODE_4X_NIC_BASED_SEND_RINGS            BIT_29
+    #define GRC_MODE_MULTICAST_FRAME_ENABLE             BIT_30
+
+    /* Misc configuration register. */
+    T3_32BIT_REGISTER MiscCfg;
+    #define GRC_MISC_CFG_CORE_CLOCK_RESET               BIT_0
+    #define GRC_MISC_PRESCALAR_TIMER_MASK               0xfe
+    #define GRC_MISC_BD_ID_MASK                         0x0001e000
+    #define GRC_MISC_BD_ID_5700                         0x0001e000
+    #define GRC_MISC_BD_ID_5701                         0x00000000
+    #define GRC_MISC_BD_ID_5703                         0x00000000
+    #define GRC_MISC_BD_ID_5703S                        0x00002000
+    #define GRC_MISC_BD_ID_5702FE                       0x00004000
+
+    /* Miscellaneous local control register. */
+    T3_32BIT_REGISTER LocalCtrl;
+    #define GRC_MISC_LOCAL_CTRL_INT_ACTIVE              BIT_0
+    #define GRC_MISC_LOCAL_CTRL_CLEAR_INT               BIT_1
+    #define GRC_MISC_LOCAL_CTRL_SET_INT                 BIT_2
+    #define GRC_MISC_LOCAL_CTRL_INT_ON_ATTN             BIT_3
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT0             BIT_8
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT1             BIT_9
+    #define GRC_MISC_LOCAL_CTRL_GPIO_INPUT2             BIT_10
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE0                BIT_11
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE1                BIT_12
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OE2                BIT_13
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT0            BIT_14
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT1            BIT_15
+    #define GRC_MISC_LOCAL_CTRL_GPIO_OUTPUT2            BIT_16
+    #define GRC_MISC_LOCAL_CTRL_ENABLE_EXT_MEMORY       BIT_17
+    #define GRC_MISC_LOCAL_CTRL_BANK_SELECT             BIT_21
+    #define GRC_MISC_LOCAL_CTRL_SSRAM_TYPE              BIT_22
+
+    #define GRC_MISC_MEMSIZE_256K     0
+    #define GRC_MISC_MEMSIZE_512K     (1 << 18)
+    #define GRC_MISC_MEMSIZE_1024K    (2 << 18)
+    #define GRC_MISC_MEMSIZE_2048K    (3 << 18)
+    #define GRC_MISC_MEMSIZE_4096K    (4 << 18)
+    #define GRC_MISC_MEMSIZE_8192K    (5 << 18)
+    #define GRC_MISC_MEMSIZE_16M      (6 << 18)
+    #define GRC_MISC_LOCAL_CTRL_AUTO_SEEPROM            BIT_24
+
+
+    T3_32BIT_REGISTER Timer;
+
+    T3_32BIT_REGISTER RxCpuEvent;
+    T3_32BIT_REGISTER RxTimerRef;
+    T3_32BIT_REGISTER RxCpuSemaphore;
+    T3_32BIT_REGISTER RemoteRxCpuAttn;
+
+    T3_32BIT_REGISTER TxCpuEvent;
+    T3_32BIT_REGISTER TxTimerRef;
+    T3_32BIT_REGISTER TxCpuSemaphore;
+    T3_32BIT_REGISTER RemoteTxCpuAttn;
+
+    T3_64BIT_REGISTER MemoryPowerUp;
+
+    T3_32BIT_REGISTER EepromAddr;
+    #define SEEPROM_ADDR_WRITE       0
+    #define SEEPROM_ADDR_READ        (1 << 31)
+    #define SEEPROM_ADDR_RW_MASK     0x80000000
+    #define SEEPROM_ADDR_COMPLETE    (1 << 30)
+    #define SEEPROM_ADDR_FSM_RESET   (1 << 29)
+    #define SEEPROM_ADDR_DEV_ID(x)   (x << 26)
+    #define SEEPROM_ADDR_DEV_ID_MASK 0x1c000000
+    #define SEEPROM_ADDR_START       (1 << 25)
+    #define SEEPROM_ADDR_CLK_PERD(x) (x << 16)
+    #define SEEPROM_ADDR_ADDRESS(x)  (x & 0xfffc)
+    #define SEEPROM_ADDR_ADDRESS_MASK 0x0000ffff
+
+    #define SEEPROM_CLOCK_PERIOD        60
+    #define SEEPROM_CHIP_SIZE           (64 * 1024)
+
+    T3_32BIT_REGISTER EepromData;
+    T3_32BIT_REGISTER EepromCtrl;
+
+    T3_32BIT_REGISTER MdiCtrl;
+    T3_32BIT_REGISTER SepromDelay;
+
+    /* Unused space. */
+    LM_UINT8 Unused[948];
+} T3_GRC, *PT3_GRC;
+
+
+/******************************************************************************/
+/* NVRAM control registers. */
+/******************************************************************************/
+
+typedef struct
+{
+    T3_32BIT_REGISTER Cmd;
+    #define NVRAM_CMD_RESET                             BIT_0
+    #define NVRAM_CMD_DONE                              BIT_3
+    #define NVRAM_CMD_DO_IT                             BIT_4
+    #define NVRAM_CMD_WR                                BIT_5
+    #define NVRAM_CMD_RD                                BIT_NONE
+    #define NVRAM_CMD_ERASE                             BIT_6
+    #define NVRAM_CMD_FIRST                             BIT_7
+    #define NVRAM_CMD_LAST                              BIT_8
+
+    T3_32BIT_REGISTER Status;
+    T3_32BIT_REGISTER WriteData;
+
+    T3_32BIT_REGISTER Addr;
+    #define NVRAM_ADDRESS_MASK                          0xffffff
+
+    T3_32BIT_REGISTER ReadData;
+
+    /* Flash config 1 register. */
+    T3_32BIT_REGISTER Config1;
+    #define FLASH_INTERFACE_ENABLE                      BIT_0
+    #define FLASH_SSRAM_BUFFERRED_MODE                  BIT_1
+    #define FLASH_PASS_THRU_MODE                        BIT_2
+    #define FLASH_BIT_BANG_MODE                         BIT_3
+    #define FLASH_COMPAT_BYPASS                         BIT_31
+
+    /* Buffered flash (Atmel: AT45DB011B) specific information */
+    #define BUFFERED_FLASH_PAGE_POS         9
+    #define BUFFERED_FLASH_BYTE_ADDR_MASK   ((1<<BUFFERED_FLASH_PAGE_POS) - 1)
+    #define BUFFERED_FLASH_PAGE_SIZE        264
+    #define BUFFERED_FLASH_PHY_PAGE_SIZE    512
+
+    T3_32BIT_REGISTER Config2;
+    T3_32BIT_REGISTER Config3;
+    T3_32BIT_REGISTER SwArb;
+    #define SW_ARB_REQ_SET0                             BIT_0
+    #define SW_ARB_REQ_SET1                             BIT_1
+    #define SW_ARB_REQ_SET2                             BIT_2
+    #define SW_ARB_REQ_SET3                             BIT_3
+    #define SW_ARB_REQ_CLR0                             BIT_4
+    #define SW_ARB_REQ_CLR1                             BIT_5
+    #define SW_ARB_REQ_CLR2                             BIT_6
+    #define SW_ARB_REQ_CLR3                             BIT_7
+    #define SW_ARB_GNT0                                 BIT_8
+    #define SW_ARB_GNT1                                 BIT_9
+    #define SW_ARB_GNT2                                 BIT_10
+    #define SW_ARB_GNT3                                 BIT_11
+    #define SW_ARB_REQ0                                 BIT_12
+    #define SW_ARB_REQ1                                 BIT_13
+    #define SW_ARB_REQ2                                 BIT_14
+    #define SW_ARB_REQ3                                 BIT_15
+
+    /* Unused space. */
+    LM_UINT8 Unused[988];
+} T3_NVRAM, *PT3_NVRAM;
+
+
+/******************************************************************************/
+/* NIC's internal memory. */
+/******************************************************************************/
+
+typedef struct {
+    /* Page zero for the internal CPUs. */
+    LM_UINT8 PageZero[0x100];               /* 0x0000 */
+
+    /* Send RCBs. */
+    T3_RCB SendRcb[16];                     /* 0x0100 */
+
+    /* Receive Return RCBs. */
+    T3_RCB RcvRetRcb[16];                   /* 0x0200 */
+
+    /* Statistics block. */
+    T3_STATS_BLOCK StatsBlk;                /* 0x0300 */
+
+    /* Status block. */
+    T3_STATUS_BLOCK StatusBlk;              /* 0x0b00 */
+
+    /* Reserved for software. */
+    LM_UINT8 Reserved[1200];                /* 0x0b50 */
+
+    /* Unmapped region. */
+    LM_UINT8 Unmapped[4096];                /* 0x1000 */
+
+    /* DMA descriptors. */
+    LM_UINT8 DmaDesc[8192];                 /* 0x2000 */
+
+    /* Buffer descriptors. */
+    LM_UINT8 BufferDesc[16384];             /* 0x4000 */
+} T3_FIRST_32K_SRAM, *PT3_FIRST_32K_SRAM;
+
+
+
+/******************************************************************************/
+/* Memory layout. */
+/******************************************************************************/
+
+typedef struct {
+    /* PCI configuration registers. */
+    T3_PCI_CONFIGURATION PciCfg;
+
+    /* Unused. */
+    LM_UINT8 Unused1[0x100];                            /* 0x0100 */
+
+    /* Mailbox . */
+    T3_MAILBOX Mailbox;                                 /* 0x0200 */
+
+    /* MAC control registers. */
+    T3_MAC_CONTROL MacCtrl;                             /* 0x0400 */
+
+    /* Send data initiator control registers. */
+    T3_SEND_DATA_INITIATOR SndDataIn;                   /* 0x0c00 */
+
+    /* Send data completion Control registers. */
+    T3_SEND_DATA_COMPLETION SndDataComp;                /* 0x1000 */
+
+    /* Send BD ring selector. */
+    T3_SEND_BD_SELECTOR SndBdSel;                       /* 0x1400 */
+
+    /* Send BD initiator control registers. */
+    T3_SEND_BD_INITIATOR SndBdIn;                       /* 0x1800 */
+
+    /* Send BD completion control registers. */
+    T3_SEND_BD_COMPLETION SndBdComp;                    /* 0x1c00 */
+
+    /* Receive list placement control registers. */
+    T3_RCV_LIST_PLACEMENT RcvListPlmt;                  /* 0x2000 */
+
+    /* Receive Data and Receive BD Initiator Control. */
+    T3_RCV_DATA_BD_INITIATOR RcvDataBdIn;               /* 0x2400 */
+
+    /* Receive Data Completion Control */
+    T3_RCV_DATA_COMPLETION RcvDataComp;                 /* 0x2800 */
+
+    /* Receive BD Initiator Control Registers. */
+    T3_RCV_BD_INITIATOR RcvBdIn;                        /* 0x2c00 */
+
+    /* Receive BD Completion Control Registers. */
+    T3_RCV_BD_COMPLETION RcvBdComp;                     /* 0x3000 */
+
+    /* Receive list selector control registers. */
+    T3_RCV_LIST_SELECTOR RcvListSel;                    /* 0x3400 */
+
+    /* Mbuf cluster free registers. */
+    T3_MBUF_CLUSTER_FREE MbufClusterFree;               /* 0x3800 */
+
+    /* Host coalescing control registers. */
+    T3_HOST_COALESCING HostCoalesce;                    /* 0x3c00 */
+
+    /* Memory arbiter control registers. */
+    T3_MEM_ARBITER MemArbiter;                          /* 0x4000 */
+    
+    /* Buffer manger control registers. */
+    T3_BUFFER_MANAGER BufMgr;                           /* 0x4400 */
+
+    /* Read DMA control registers. */
+    T3_DMA_READ DmaRead;                                /* 0x4800 */
+
+    /* Write DMA control registers. */
+    T3_DMA_WRITE DmaWrite;                              /* 0x4c00 */
+
+    T3_CPU rxCpu;                                       /* 0x5000 */
+    T3_CPU txCpu;                                       /* 0x5400 */
+
+    /* Mailboxes. */
+    T3_GRC_MAILBOX GrcMailbox;                          /* 0x5800 */
+
+    /* Flow Through queues. */
+    T3_FTQ Ftq;                                         /* 0x5c00 */
+
+    /* Message signaled interrupt registes. */
+    T3_MSG_SIGNALED_INT Msi;                            /* 0x6000 */
+
+    /* DMA completion registers. */
+    T3_DMA_COMPLETION DmaComp;                          /* 0x6400 */
+
+    /* GRC registers. */
+    T3_GRC Grc;                                         /* 0x6800 */
+
+    /* Unused space. */
+    LM_UINT8 Unused2[1024];                             /* 0x6c00 */
+
+    /* NVRAM registers. */
+    T3_NVRAM Nvram;                                     /* 0x7000 */
+
+    /* Unused space. */
+    LM_UINT8 Unused3[3072];                             /* 0x7400 */
+    
+    /* The 32k memory window into the NIC's */
+    /* internal memory.  The memory window is */
+    /* controlled by the Memory Window Base */
+    /* Address register.  This register is located */
+    /* in the PCI configuration space. */
+    union {                                             /* 0x8000 */
+        T3_FIRST_32K_SRAM First32k;
+
+        /* Use the memory window base address register to determine the */
+        /* MBUF segment. */
+        LM_UINT32 Mbuf[32768/4];
+        LM_UINT32 MemBlock32K[32768/4];
+    } uIntMem;
+} T3_STD_MEM_MAP, *PT3_STD_MEM_MAP;
+
+
+/******************************************************************************/
+/* Adapter info. */
+/******************************************************************************/
+
+typedef struct
+{
+    LM_UINT16 Svid;
+    LM_UINT16 Ssid;
+    LM_UINT32 PhyId;
+    LM_UINT32 Serdes;   /* 0 = copper PHY, 1 = Serdes */
+} LM_ADAPTER_INFO, *PLM_ADAPTER_INFO;
+
+
+/******************************************************************************/
+/* Packet queues. */
+/******************************************************************************/
+
+DECLARE_QUEUE_TYPE(LM_RX_PACKET_Q, MAX_RX_PACKET_DESC_COUNT);
+DECLARE_QUEUE_TYPE(LM_TX_PACKET_Q, MAX_TX_PACKET_DESC_COUNT);
+
+
+
+/******************************************************************************/
+/* Tx counters. */
+/******************************************************************************/
+
+typedef struct {
+    LM_COUNTER TxPacketGoodCnt;
+    LM_COUNTER TxBytesGoodCnt;
+    LM_COUNTER TxPacketAbortedCnt;
+    LM_COUNTER NoSendBdLeftCnt;
+    LM_COUNTER NoMapRegisterLeftCnt;
+    LM_COUNTER TooManyFragmentsCnt;
+    LM_COUNTER NoTxPacketDescCnt;
+} LM_TX_COUNTERS, *PLM_TX_COUNTERS;
+
+
+
+/******************************************************************************/
+/* Rx counters. */
+/******************************************************************************/
+
+typedef struct {
+    LM_COUNTER RxPacketGoodCnt;
+    LM_COUNTER RxBytesGoodCnt;
+    LM_COUNTER RxPacketErrCnt;
+    LM_COUNTER RxErrCrcCnt;
+    LM_COUNTER RxErrCollCnt;
+    LM_COUNTER RxErrLinkLostCnt;
+    LM_COUNTER RxErrPhyDecodeCnt;
+    LM_COUNTER RxErrOddNibbleCnt;
+    LM_COUNTER RxErrMacAbortCnt;
+    LM_COUNTER RxErrShortPacketCnt;
+    LM_COUNTER RxErrNoResourceCnt;
+    LM_COUNTER RxErrLargePacketCnt;
+} LM_RX_COUNTERS, *PLM_RX_COUNTERS;
+
+
+
+/******************************************************************************/
+/* Receive producer rings. */
+/******************************************************************************/
+
+typedef enum {
+    T3_UNKNOWN_RCV_PROD_RING    = 0,
+    T3_STD_RCV_PROD_RING        = 1,
+    T3_MINI_RCV_PROD_RING       = 2,
+    T3_JUMBO_RCV_PROD_RING      = 3
+} T3_RCV_PROD_RING, *PT3_RCV_PROD_RING;
+
+
+
+/******************************************************************************/
+/* Packet descriptor. */
+/******************************************************************************/
+
+#define LM_PACKET_SIGNATURE_TX              0x6861766b
+#define LM_PACKET_SIGNATURE_RX              0x6b766168
+
+typedef struct _LM_PACKET {
+    /* Set in LM. */
+    LM_STATUS PacketStatus;
+
+    /* Set in LM for Rx, in UM for Tx. */
+    LM_UINT32 PacketSize;
+
+    LM_UINT16 Flags;
+
+#define LM_VALID_VLAN_TAG                   (1 << 0)
+#define LM_VALID_IP_CHKSUM_FIELD            (1 << 1)
+#define LM_VALID_TCP_UDP_CHKSUM_FIELD       (1 << 2)
+#define LM_TCP_PACKET                       (1 << 3)
+#define LM_DONT_GEN_CRC                     (1 << 4)
+#define LM_TCP_SEGMENTATION                 (1 << 5)
+
+    LM_UINT16 VlanTag;
+
+    union {
+        /* Send info. */
+        struct {
+            /* Set up by UM. */
+            LM_UINT32 FragCount;
+
+            /* Checksum offload info. */
+            LM_TASK_OFFLOAD TaskOffload;
+
+            /* Fragment buffer for MM_StartTxDma to fill in. */
+            PLM_FRAG_LIST pFraglist;
+        } Tx;
+
+        /* Receive info. */
+        struct {
+            /* This descriptor belongs to either Std, Mini, or Jumbo ring. */
+            T3_RCV_PROD_RING RcvProdRing;
+
+            /* Receive buffer size */
+            LM_UINT32 RxBufferSize;
+
+            /* Virtual and physical address of the receive buffer. */
+            PLM_UINT8 pRxBufferVirt;
+            LM_PHYSICAL_ADDRESS RxBufferPhy;
+            
+            /* Checksum information. */
+            LM_UINT16 IpChecksum;
+            LM_UINT16 TcpUdpChecksum;
+
+        } Rx;
+    } u;
+} LM_PACKET;
+
+
+
+/******************************************************************************/
+/* Tigon3 device block. */
+/******************************************************************************/
+
+typedef struct _LM_DEVICE_BLOCK {
+    /* Memory view. */
+    PT3_STD_MEM_MAP pMemView;
+
+    /* Base address of the block of memory in which the LM_PACKET descriptors */
+    /* are allocated from. */
+    PLM_VOID pPacketDescBase;
+
+    LM_UINT32 MiscHostCtrl;
+    LM_UINT32 GrcLocalCtrl;
+    LM_UINT32 DmaReadWriteCtrl;
+    LM_UINT32 PciState;
+
+    /* Rx info */
+    LM_UINT32 RxStdDescCnt;
+    LM_UINT32 RxStdQueuedCnt;
+    LM_UINT32 RxStdProdIdx;
+
+    PT3_RCV_BD pRxStdBdVirt;
+    LM_PHYSICAL_ADDRESS RxStdBdPhy;
+
+    LM_UINT32 RxPacketDescCnt;
+    LM_RX_PACKET_Q RxPacketFreeQ;
+    LM_RX_PACKET_Q RxPacketReceivedQ;
+
+    /* Receive info. */
+    PT3_RCV_BD pRcvRetBdVirt;
+    LM_PHYSICAL_ADDRESS RcvRetBdPhy;
+    LM_UINT32 RcvRetConIdx;
+
+#if T3_JUMBO_RCV_RCB_ENTRY_COUNT
+    LM_UINT32 RxJumboDescCnt;
+    LM_UINT32 RxJumboBufferSize;
+    LM_UINT32 RxJumboQueuedCnt;
+
+    LM_UINT32 RxJumboProdIdx;
+
+    PT3_RCV_BD pRxJumboBdVirt;
+    LM_PHYSICAL_ADDRESS RxJumboBdPhy;
+#endif /* T3_JUMBO_RCV_RCB_ENTRY_COUNT */
+
+    /* These values are used by the upper module to inform the protocol */
+    /* of the maximum transmit/receive packet size. */
+    LM_UINT32 TxMtu;    /* Does not include CRC. */
+    LM_UINT32 RxMtu;    /* Does not include CRC. */
+
+    /* We need to shadow the EMAC, Rx, Tx mode registers.  With B0 silicon, */
+    /* we may have problems reading any MAC registers in 10mb mode. */
+    LM_UINT32 MacMode;
+    LM_UINT32 RxMode;
+    LM_UINT32 TxMode;
+
+    /* MiMode register. */
+    LM_UINT32 MiMode;
+
+    /* Host coalesce mode register. */
+    LM_UINT32 CoalesceMode;
+
+    /* Send info. */
+    LM_UINT32 TxPacketDescCnt;
+
+    /* Tx info. */
+    LM_TX_PACKET_Q TxPacketFreeQ;
+    LM_TX_PACKET_Q TxPacketActiveQ;
+    LM_TX_PACKET_Q TxPacketXmittedQ;
+
+    /* Pointers to SendBd. */
+    PT3_SND_BD pSendBdVirt;
+    LM_PHYSICAL_ADDRESS SendBdPhy;  /* Only valid for Host based Send BD. */
+
+    /* Send producer and consumer indices. */
+    LM_UINT32 SendProdIdx;
+    LM_UINT32 SendConIdx;
+
+    /* Number of BD left. */
+    atomic_t SendBdLeft;
+
+    T3_SND_BD ShadowSendBd[T3_SEND_RCB_ENTRY_COUNT];
+
+    /* Counters. */
+    LM_RX_COUNTERS RxCounters;
+    LM_TX_COUNTERS TxCounters;
+
+    /* Host coalescing parameters. */
+    LM_UINT32 RxCoalescingTicks;
+    LM_UINT32 TxCoalescingTicks;
+    LM_UINT32 RxMaxCoalescedFrames;
+    LM_UINT32 TxMaxCoalescedFrames;
+    LM_UINT32 StatsCoalescingTicks;
+    LM_UINT32 RxCoalescingTicksDuringInt;
+    LM_UINT32 TxCoalescingTicksDuringInt;
+    LM_UINT32 RxMaxCoalescedFramesDuringInt;
+    LM_UINT32 TxMaxCoalescedFramesDuringInt;
+
+    /* DMA water marks. */
+    LM_UINT32 DmaMbufLowMark;
+    LM_UINT32 RxMacMbufLowMark;
+    LM_UINT32 MbufHighMark;
+
+    /* Status block. */
+    PT3_STATUS_BLOCK pStatusBlkVirt;
+    LM_PHYSICAL_ADDRESS StatusBlkPhy;
+
+    /* Statistics block. */
+    PT3_STATS_BLOCK pStatsBlkVirt;
+    LM_PHYSICAL_ADDRESS StatsBlkPhy;
+
+    /* Current receive mask. */
+    LM_UINT32 ReceiveMask;
+
+    /* Task offload capabilities. */
+    LM_TASK_OFFLOAD TaskOffloadCap;
+
+    /* Task offload selected. */
+    LM_TASK_OFFLOAD TaskToOffload;
+
+    /* Wake up capability. */
+    LM_WAKE_UP_MODE WakeUpModeCap;
+
+    /* Wake up capability. */
+    LM_WAKE_UP_MODE WakeUpMode;
+
+    /* Flow control. */
+    LM_FLOW_CONTROL FlowControlCap;
+    LM_FLOW_CONTROL FlowControl;
+
+    /* Enable or disable PCI MWI. */
+    LM_UINT32 EnableMWI;
+
+    /* Enable 5701 tagged status mode. */
+    LM_UINT32 UseTaggedStatus;
+
+    /* NIC will not compute the pseudo header checksum.  The driver or OS */
+    /* must seed the checksum field with the pseudo checksum. */
+    LM_UINT32 NoTxPseudoHdrChksum;
+
+    /* The receive checksum in the BD does not include the pseudo checksum. */
+    /* The OS or the driver must calculate the pseudo checksum and add it to */
+    /* the checksum in the BD. */
+    LM_UINT32 NoRxPseudoHdrChksum;
+
+    /* Current node address. */
+    LM_UINT8 NodeAddress[8];
+
+    /* The adapter's node address. */
+    LM_UINT8 PermanentNodeAddress[8];
+
+    /* Adapter info. */
+    LM_UINT16 BusNum;               // Init by the upper module.
+    LM_UINT8 DevNum;                // Init by the upper module.
+    LM_UINT8 FunctNum;              // Init by the upper module.
+    LM_UINT16 PciVendorId;
+    LM_UINT16 PciDeviceId;
+    LM_UINT32 BondId;
+    LM_UINT8 Irq;
+    LM_UINT8 IntPin;
+    LM_UINT8 CacheLineSize;
+    LM_UINT8 PciRevId;
+#if PCIX_TARGET_WORKAROUND
+	LM_UINT32 EnablePciXFix;
+#endif
+	LM_UINT32 PciCommandStatusWords;
+    LM_UINT32 ChipRevId;
+    LM_UINT16 SubsystemVendorId;
+    LM_UINT16 SubsystemId;
+    LM_UINT32 MemBaseLow;
+    LM_UINT32 MemBaseHigh;
+    LM_UINT32 MemBaseSize;
+    PLM_UINT8 pMappedMemBase;
+
+    /* Saved PCI configuration registers for restoring after a reset. */
+    LM_UINT32 SavedCacheLineReg;
+
+    /* Phy info. */
+    LM_UINT32 PhyAddr;
+    LM_UINT32 PhyId;
+
+    /* Requested phy settings. */
+    LM_REQUESTED_MEDIA_TYPE RequestedMediaType;
+
+    /* Disable auto-negotiation. */
+    LM_UINT32 DisableAutoNeg;
+
+    /* Ways for the MAC to get link change interrupt. */
+    LM_UINT32 PhyIntMode;
+    #define T3_PHY_INT_MODE_AUTO                        0
+    #define T3_PHY_INT_MODE_MI_INTERRUPT                1
+    #define T3_PHY_INT_MODE_LINK_READY                  2
+    #define T3_PHY_INT_MODE_AUTO_POLLING                3
+
+    /* Ways to determine link change status. */
+    LM_UINT32 LinkChngMode;
+    #define T3_LINK_CHNG_MODE_AUTO                      0
+    #define T3_LINK_CHNG_MODE_USE_STATUS_REG            1
+    #define T3_LINK_CHNG_MODE_USE_STATUS_BLOCK          2
+
+    /* LED mode. */
+    LM_UINT32 LedMode;
+
+    #define LED_MODE_AUTO                               0
+
+    /* 5700/01 LED mode. */
+    #define LED_MODE_THREE_LINK                         1
+    #define LED_MODE_LINK10                             2
+
+    /* 5703/02/04 LED mode. */
+    #define LED_MODE_OPEN_DRAIN                         1
+    #define LED_MODE_OUTPUT                             2
+
+    /* WOL Speed */
+    LM_UINT32 WolSpeed;
+    #define WOL_SPEED_10MB                              1
+    #define WOL_SPEED_100MB                             2
+
+    /* Reset the PHY on initialization. */
+    LM_UINT32 ResetPhyOnInit;
+
+    LM_UINT32 RestoreOnWakeUp;
+    LM_REQUESTED_MEDIA_TYPE WakeUpRequestedMediaType;
+    LM_UINT32 WakeUpDisableAutoNeg;
+
+    /* Current phy settings. */
+    LM_MEDIA_TYPE MediaType;
+    LM_LINE_SPEED LineSpeed;
+    LM_LINE_SPEED OldLineSpeed;
+    LM_DUPLEX_MODE DuplexMode;
+    LM_STATUS LinkStatus;
+    LM_UINT32 advertising;
+    LM_UINT32 advertising1000;
+
+    /* Multicast address list. */
+    LM_UINT32 McEntryCount;
+    LM_UINT8 McTable[LM_MAX_MC_TABLE_SIZE][LM_MC_ENTRY_SIZE];
+
+    /* Use NIC or Host based send BD. */
+    LM_UINT32 NicSendBd;
+
+    /* Athlon fix. */
+    LM_UINT32 DelayPciGrant;
+
+    /* Enable OneDmaAtOnce */
+    LM_UINT32 OneDmaAtOnce;
+
+    /* Init flag. */
+    LM_BOOL InitDone;
+
+    /* Shutdown flag.  Set by the upper module. */
+    LM_BOOL ShuttingDown;
+
+    /* Flag to determine whether to call LM_QueueRxPackets or not in */
+    /* LM_ResetAdapter routine. */
+    LM_BOOL QueueRxPackets;
+
+    LM_UINT32 MbufBase;
+    LM_UINT32 MbufSize;
+
+    /* TRUE if we have a SERDES PHY. */
+    LM_UINT32 EnableTbi;
+
+    /* Ethernet@WireSpeed. */
+    LM_UINT32 EnableWireSpeed;
+
+    LM_UINT32 EepromWp;
+
+#if INCLUDE_TBI_SUPPORT
+    /* Autoneg state info. */
+    AN_STATE_INFO AnInfo;
+    LM_UINT32 PollTbiLink;
+    LM_UINT32 IgnoreTbiLinkChange;
+#endif
+    char PartNo[24];
+    char BootCodeVer[16];
+    LM_UINT32 PhyCrcCount;
+} LM_DEVICE_BLOCK;
+
+
+#define T3_REG_CPU_VIEW               0xc0000000
+
+#define T3_BLOCK_DMA_RD               (1 << 0)
+#define T3_BLOCK_DMA_COMP             (1 << 1)
+#define T3_BLOCK_RX_BD_INITIATOR      (1 << 2)
+#define T3_BLOCK_RX_BD_COMP           (1 << 3)
+#define T3_BLOCK_DMA_WR               (1 << 4)
+#define T3_BLOCK_MSI_HANDLER          (1 << 5)
+#define T3_BLOCK_RX_LIST_PLMT         (1 << 6)
+#define T3_BLOCK_RX_LIST_SELECTOR     (1 << 7)
+#define T3_BLOCK_RX_DATA_INITIATOR    (1 << 8)
+#define T3_BLOCK_RX_DATA_COMP         (1 << 9)
+#define T3_BLOCK_HOST_COALESING       (1 << 10)
+#define T3_BLOCK_MAC_RX_ENGINE        (1 << 11)
+#define T3_BLOCK_MBUF_CLUSTER_FREE    (1 << 12)
+#define T3_BLOCK_SEND_BD_INITIATOR    (1 << 13)
+#define T3_BLOCK_SEND_BD_COMP         (1 << 14)
+#define T3_BLOCK_SEND_BD_SELECTOR     (1 << 15)
+#define T3_BLOCK_SEND_DATA_INITIATOR  (1 << 16)
+#define T3_BLOCK_SEND_DATA_COMP       (1 << 17)
+#define T3_BLOCK_MAC_TX_ENGINE        (1 << 18)
+#define T3_BLOCK_MEM_ARBITOR          (1 << 19)
+#define T3_BLOCK_MBUF_MANAGER         (1 << 20)
+#define T3_BLOCK_MAC_GLOBAL           (1 << 21)
+
+#define LM_ENABLE               1
+#define LM_DISABLE              2
+
+#define RX_CPU_EVT_SW0              0
+#define RX_CPU_EVT_SW1              1
+#define RX_CPU_EVT_RLP              2
+#define RX_CPU_EVT_SW3              3
+#define RX_CPU_EVT_RLS              4
+#define RX_CPU_EVT_SW4              5
+#define RX_CPU_EVT_RX_BD_COMP       6
+#define RX_CPU_EVT_SW5              7
+#define RX_CPU_EVT_RDI              8
+#define RX_CPU_EVT_DMA_WR           9
+#define RX_CPU_EVT_DMA_RD           10
+#define RX_CPU_EVT_SWQ              11
+#define RX_CPU_EVT_SW6              12
+#define RX_CPU_EVT_RDC              13
+#define RX_CPU_EVT_SW7              14
+#define RX_CPU_EVT_HOST_COALES      15
+#define RX_CPU_EVT_SW8              16
+#define RX_CPU_EVT_HIGH_DMA_WR      17
+#define RX_CPU_EVT_HIGH_DMA_RD      18
+#define RX_CPU_EVT_SW9              19
+#define RX_CPU_EVT_DMA_ATTN         20
+#define RX_CPU_EVT_LOW_P_MBOX       21
+#define RX_CPU_EVT_HIGH_P_MBOX      22
+#define RX_CPU_EVT_SW10             23
+#define RX_CPU_EVT_TX_CPU_ATTN      24
+#define RX_CPU_EVT_MAC_ATTN         25
+#define RX_CPU_EVT_RX_CPU_ATTN      26
+#define RX_CPU_EVT_FLOW_ATTN        27
+#define RX_CPU_EVT_SW11             28
+#define RX_CPU_EVT_TIMER            29
+#define RX_CPU_EVT_SW12             30
+#define RX_CPU_EVT_SW13             31
+
+/* RX-CPU event */
+#define RX_CPU_EVENT_SW_EVENT0      (1 << RX_CPU_EVT_SW0)
+#define RX_CPU_EVENT_SW_EVENT1      (1 << RX_CPU_EVT_SW1)
+#define RX_CPU_EVENT_RLP            (1 << RX_CPU_EVT_RLP)
+#define RX_CPU_EVENT_SW_EVENT3      (1 << RX_CPU_EVT_SW3)
+#define RX_CPU_EVENT_RLS            (1 << RX_CPU_EVT_RLS)
+#define RX_CPU_EVENT_SW_EVENT4      (1 << RX_CPU_EVT_SW4)
+#define RX_CPU_EVENT_RX_BD_COMP     (1 << RX_CPU_EVT_RX_BD_COMP)
+#define RX_CPU_EVENT_SW_EVENT5      (1 << RX_CPU_EVT_SW5)
+#define RX_CPU_EVENT_RDI            (1 << RX_CPU_EVT_RDI)
+#define RX_CPU_EVENT_DMA_WR         (1 << RX_CPU_EVT_DMA_WR)
+#define RX_CPU_EVENT_DMA_RD         (1 << RX_CPU_EVT_DMA_RD)
+#define RX_CPU_EVENT_SWQ            (1 << RX_CPU_EVT_SWQ)
+#define RX_CPU_EVENT_SW_EVENT6      (1 << RX_CPU_EVT_SW6)
+#define RX_CPU_EVENT_RDC            (1 << RX_CPU_EVT_RDC)
+#define RX_CPU_EVENT_SW_EVENT7      (1 << RX_CPU_EVT_SW7)
+#define RX_CPU_EVENT_HOST_COALES    (1 << RX_CPU_EVT_HOST_COALES)
+#define RX_CPU_EVENT_SW_EVENT8      (1 << RX_CPU_EVT_SW8)
+#define RX_CPU_EVENT_HIGH_DMA_WR    (1 << RX_CPU_EVT_HIGH_DMA_WR)
+#define RX_CPU_EVENT_HIGH_DMA_RD    (1 << RX_CPU_EVT_HIGH_DMA_RD)
+#define RX_CPU_EVENT_SW_EVENT9      (1 << RX_CPU_EVT_SW9)
+#define RX_CPU_EVENT_DMA_ATTN       (1 << RX_CPU_EVT_DMA_ATTN)
+#define RX_CPU_EVENT_LOW_P_MBOX     (1 << RX_CPU_EVT_LOW_P_MBOX)
+#define RX_CPU_EVENT_HIGH_P_MBOX    (1 << RX_CPU_EVT_HIGH_P_MBOX)
+#define RX_CPU_EVENT_SW_EVENT10     (1 << RX_CPU_EVT_SW10)
+#define RX_CPU_EVENT_TX_CPU_ATTN    (1 << RX_CPU_EVT_TX_CPU_ATTN)
+#define RX_CPU_EVENT_MAC_ATTN       (1 << RX_CPU_EVT_MAC_ATTN)
+#define RX_CPU_EVENT_RX_CPU_ATTN    (1 << RX_CPU_EVT_RX_CPU_ATTN)
+#define RX_CPU_EVENT_FLOW_ATTN      (1 << RX_CPU_EVT_FLOW_ATTN)
+#define RX_CPU_EVENT_SW_EVENT11     (1 << RX_CPU_EVT_SW11)
+#define RX_CPU_EVENT_TIMER          (1 << RX_CPU_EVT_TIMER)
+#define RX_CPU_EVENT_SW_EVENT12     (1 << RX_CPU_EVT_SW12)
+#define RX_CPU_EVENT_SW_EVENT13     (1 << RX_CPU_EVT_SW13)
+
+#define RX_CPU_MASK (RX_CPU_EVENT_SW_EVENT0 | \
+		     RX_CPU_EVENT_RLP | \
+		     RX_CPU_EVENT_RDI | \
+		     RX_CPU_EVENT_RDC)
+
+#define TX_CPU_EVT_SW0              0
+#define TX_CPU_EVT_SW1              1
+#define TX_CPU_EVT_SW2              2
+#define TX_CPU_EVT_SW3              3
+#define TX_CPU_EVT_TX_MAC           4
+#define TX_CPU_EVT_SW4              5
+#define TX_CPU_EVT_SBDC             6
+#define TX_CPU_EVT_SW5              7
+#define TX_CPU_EVT_SDI              8
+#define TX_CPU_EVT_DMA_WR           9
+#define TX_CPU_EVT_DMA_RD           10
+#define TX_CPU_EVT_SWQ              11
+#define TX_CPU_EVT_SW6              12
+#define TX_CPU_EVT_SDC              13
+#define TX_CPU_EVT_SW7              14
+#define TX_CPU_EVT_HOST_COALES      15
+#define TX_CPU_EVT_SW8              16
+#define TX_CPU_EVT_HIGH_DMA_WR      17
+#define TX_CPU_EVT_HIGH_DMA_RD      18
+#define TX_CPU_EVT_SW9              19
+#define TX_CPU_EVT_DMA_ATTN         20
+#define TX_CPU_EVT_LOW_P_MBOX       21
+#define TX_CPU_EVT_HIGH_P_MBOX      22
+#define TX_CPU_EVT_SW10             23
+#define TX_CPU_EVT_RX_CPU_ATTN      24
+#define TX_CPU_EVT_MAC_ATTN         25
+#define TX_CPU_EVT_TX_CPU_ATTN      26
+#define TX_CPU_EVT_FLOW_ATTN        27
+#define TX_CPU_EVT_SW11             28
+#define TX_CPU_EVT_TIMER            29
+#define TX_CPU_EVT_SW12             30
+#define TX_CPU_EVT_SW13             31
+
+
+/* TX-CPU event */
+#define TX_CPU_EVENT_SW_EVENT0      (1 << TX_CPU_EVT_SW0)
+#define TX_CPU_EVENT_SW_EVENT1      (1 << TX_CPU_EVT_SW1)
+#define TX_CPU_EVENT_SW_EVENT2      (1 << TX_CPU_EVT_SW2)
+#define TX_CPU_EVENT_SW_EVENT3      (1 << TX_CPU_EVT_SW3)
+#define TX_CPU_EVENT_TX_MAC         (1 << TX_CPU_EVT_TX_MAC)
+#define TX_CPU_EVENT_SW_EVENT4      (1 << TX_CPU_EVT_SW4)
+#define TX_CPU_EVENT_SBDC           (1 << TX_CPU_EVT_SBDC)
+#define TX_CPU_EVENT_SW_EVENT5      (1 << TX_CPU_EVT_SW5)
+#define TX_CPU_EVENT_SDI            (1 << TX_CPU_EVT_SDI)
+#define TX_CPU_EVENT_DMA_WR         (1 << TX_CPU_EVT_DMA_WR)
+#define TX_CPU_EVENT_DMA_RD         (1 << TX_CPU_EVT_DMA_RD)
+#define TX_CPU_EVENT_SWQ            (1 << TX_CPU_EVT_SWQ)
+#define TX_CPU_EVENT_SW_EVENT6      (1 << TX_CPU_EVT_SW6)
+#define TX_CPU_EVENT_SDC            (1 << TX_CPU_EVT_SDC)
+#define TX_CPU_EVENT_SW_EVENT7      (1 << TX_CPU_EVT_SW7)
+#define TX_CPU_EVENT_HOST_COALES    (1 << TX_CPU_EVT_HOST_COALES)
+#define TX_CPU_EVENT_SW_EVENT8      (1 << TX_CPU_EVT_SW8)
+#define TX_CPU_EVENT_HIGH_DMA_WR    (1 << TX_CPU_EVT_HIGH_DMA_WR)
+#define TX_CPU_EVENT_HIGH_DMA_RD    (1 << TX_CPU_EVT_HIGH_DMA_RD)
+#define TX_CPU_EVENT_SW_EVENT9      (1 << TX_CPU_EVT_SW9)
+#define TX_CPU_EVENT_DMA_ATTN       (1 << TX_CPU_EVT_DMA_ATTN)
+#define TX_CPU_EVENT_LOW_P_MBOX     (1 << TX_CPU_EVT_LOW_P_MBOX)
+#define TX_CPU_EVENT_HIGH_P_MBOX    (1 << TX_CPU_EVT_HIGH_P_MBOX)
+#define TX_CPU_EVENT_SW_EVENT10     (1 << TX_CPU_EVT_SW10)
+#define TX_CPU_EVENT_RX_CPU_ATTN    (1 << TX_CPU_EVT_RX_CPU_ATTN)
+#define TX_CPU_EVENT_MAC_ATTN       (1 << TX_CPU_EVT_MAC_ATTN)
+#define TX_CPU_EVENT_TX_CPU_ATTN    (1 << TX_CPU_EVT_TX_CPU_ATTN)
+#define TX_CPU_EVENT_FLOW_ATTN      (1 << TX_CPU_EVT_FLOW_ATTN)
+#define TX_CPU_EVENT_SW_EVENT11     (1 << TX_CPU_EVT_SW11)
+#define TX_CPU_EVENT_TIMER          (1 << TX_CPU_EVT_TIMER)
+#define TX_CPU_EVENT_SW_EVENT12     (1 << TX_CPU_EVT_SW12)
+#define TX_CPU_EVENT_SW_EVENT13     (1 << TX_CPU_EVT_SW13)
+
+
+#define TX_CPU_MASK (TX_CPU_EVENT_SW_EVENT0 | \
+		     TX_CPU_EVENT_SDI  | \
+		     TX_CPU_EVENT_SDC)
+
+
+#define T3_FTQ_TYPE1_UNDERFLOW_BIT   (1 << 29)
+#define T3_FTQ_TYPE1_PASS_BIT        (1 << 30)
+#define T3_FTQ_TYPE1_SKIP_BIT        (1 << 31)
+
+#define T3_FTQ_TYPE2_UNDERFLOW_BIT   (1 << 13)
+#define T3_FTQ_TYPE2_PASS_BIT        (1 << 14)
+#define T3_FTQ_TYPE2_SKIP_BIT        (1 << 15)
+
+#define T3_QID_DMA_READ               1
+#define T3_QID_DMA_HIGH_PRI_READ      2
+#define T3_QID_DMA_COMP_DX            3
+#define T3_QID_SEND_BD_COMP           4
+#define T3_QID_SEND_DATA_INITIATOR    5
+#define T3_QID_DMA_WRITE              6
+#define T3_QID_DMA_HIGH_PRI_WRITE     7
+#define T3_QID_SW_TYPE_1              8
+#define T3_QID_SEND_DATA_COMP         9
+#define T3_QID_HOST_COALESCING        10
+#define T3_QID_MAC_TX                 11
+#define T3_QID_MBUF_CLUSTER_FREE      12
+#define T3_QID_RX_BD_COMP             13
+#define T3_QID_RX_LIST_PLM            14
+#define T3_QID_RX_DATA_BD_INITIATOR   15
+#define T3_QID_RX_DATA_COMP           16
+#define T3_QID_SW_TYPE2               17
+
+LM_STATUS LM_LoadFirmware(PLM_DEVICE_BLOCK pDevice,
+                          PT3_FWIMG_INFO pFwImg,
+                          LM_UINT32 LoadCpu,
+                          LM_UINT32 StartCpu);
+
+/******************************************************************************/
+/* NIC register read/write macros. */
+/******************************************************************************/
+
+/* MAC register access. */
+LM_UINT32 LM_RegRdInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Register);
+LM_VOID LM_RegWrInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 Register,
+    LM_UINT32 Value32);
+
+/* MAC memory access. */
+LM_UINT32 LM_MemRdInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 MemAddr);
+LM_VOID LM_MemWrInd(PLM_DEVICE_BLOCK pDevice, LM_UINT32 MemAddr,
+    LM_UINT32 Value32);
+
+#define RAW_REG_WR(pDevice, OffsetName, Value32)                            \
+    __raw_writel(Value32, &((pDevice)->pMemView->OffsetName))
+
+#if PCIX_TARGET_WORKAROUND
+
+/* use memor-mapped accesses for mailboxes and reads, UNDI accesses
+   for writes to all other registers */
+#define REG_RD(pDevice, OffsetName)                                         \
+    __raw_readl(&((pDevice)->pMemView->OffsetName))
+
+#define REG_WR(pDevice, OffsetName, Value32)                                \
+	(((OFFSETOF(T3_STD_MEM_MAP, OffsetName) >=0x200 ) &&					\
+	  (OFFSETOF(T3_STD_MEM_MAP, OffsetName) <0x400)) ||						\
+	 ((pDevice)->EnablePciXFix == FALSE)) ?	   								\
+    (void) __raw_writel(Value32, &((pDevice)->pMemView->OffsetName)) :							\
+    LM_RegWrInd(pDevice, OFFSETOF(T3_STD_MEM_MAP, OffsetName), Value32)
+
+#define MB_REG_RD(pDevice, OffsetName)                                      \
+    __raw_readl(&((pDevice)->pMemView->OffsetName))
+
+#define MB_REG_WR(pDevice, OffsetName, Value32)                             \
+    __raw_writel(Value32, &((pDevice)->pMemView->OffsetName))
+
+#define REG_RD_OFFSET(pDevice, Offset)                                      \
+    __raw_readl(&((LM_UINT8 *) (pDevice)->pMemView + Offset))
+
+#define REG_WR_OFFSET(pDevice, Offset, Value32)                             \
+	(((Offset >=0x200 ) && (Offset < 0x400)) ||								\
+	 ((pDevice)->EnablePciXFix == FALSE)) ?	   								\
+    (void) __raw_writel(Value32, ((LM_UINT8 *) (pDevice)->pMemView + Offset)) : \
+    LM_RegWrInd(pDevice, Offset, Value32)
+
+#define MEM_RD(pDevice, AddrName)                                           \
+    LM_MemRdInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName))
+#define MEM_WR(pDevice, AddrName, Value32)                                  \
+    LM_MemWrInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName), Value32)
+
+#define MEM_RD_OFFSET(pDevice, Offset)                                      \
+    LM_MemRdInd(pDevice, Offset)
+#define MEM_WR_OFFSET(pDevice, Offset, Value32)                             \
+    LM_MemWrInd(pDevice, Offset, Value32)
+				
+#else /* normal target access path below */
+
+/* Register access. */
+#define REG_RD(pDevice, OffsetName)                                         \
+    __raw_readl(&((pDevice)->pMemView->OffsetName))
+#define REG_WR(pDevice, OffsetName, Value32)                                \
+    __raw_writel(Value32, &((pDevice)->pMemView->OffsetName))
+
+#define REG_RD_OFFSET(pDevice, Offset)                                      \
+    __raw_readl(((LM_UINT8 *) (pDevice)->pMemView + Offset))
+#define REG_WR_OFFSET(pDevice, Offset, Value32)                             \
+    __raw_writel(Value32, ((LM_UINT8 *) (pDevice)->pMemView + Offset))
+
+
+/* There could be problem access the memory window directly.  For now, */
+/* we have to go through the PCI configuration register. */
+#define MEM_RD(pDevice, AddrName)                                           \
+    LM_MemRdInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName))
+#define MEM_WR(pDevice, AddrName, Value32)                                  \
+    LM_MemWrInd(pDevice, OFFSETOF(T3_FIRST_32K_SRAM, AddrName), Value32)
+
+#define MEM_RD_OFFSET(pDevice, Offset)                                      \
+    LM_MemRdInd(pDevice, Offset)
+#define MEM_WR_OFFSET(pDevice, Offset, Value32)                             \
+    LM_MemWrInd(pDevice, Offset, Value32)
+
+#endif  /* PCIX_TARGET_WORKAROUND */
+
+#endif /* TIGON3_H */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/LICENSE linux/drivers/net/e1000/LICENSE
--- ../ia64/linux/drivers/net/e1000/LICENSE	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/LICENSE	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,69 @@
+This software program is available to you under a choice of one of two 
+licenses. You may choose to be licensed under either the GNU General Public 
+License (GPL) Version 2, June 1991, available at 
+http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+text of which follows:
+
+Recipient has requested a license and Intel Corporation ("Intel") is willing
+to grant a license for the software entitled Linux Base Driver for the 
+Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+by Intel Corporation. The following definitions apply to this license:
+
+"Licensed Patents" means patent claims licensable by Intel Corporation which 
+are necessarily infringed by the use of sale of the Software alone or when 
+combined with the operating system referred to below.
+
+"Recipient" means the party to whom Intel delivers this Software.
+
+"Licensee" means Recipient and those third parties that receive a license to 
+any operating system available under the GNU Public License version 2.0 or 
+later.
+
+Copyright (c) 1999 - 2002 Intel Corporation.
+All rights reserved.
+
+The license is provided to Recipient and Recipient's Licensees under the 
+following terms.
+
+Redistribution and use in source and binary forms of the Software, with or 
+without modification, are permitted provided that the following conditions 
+are met:
+
+Redistributions of source code of the Software may retain the above 
+copyright notice, this list of conditions and the following disclaimer.
+
+Redistributions in binary form of the Software may reproduce the above 
+copyright notice, this list of conditions and the following disclaimer in 
+the documentation and/or materials provided with the distribution.
+
+Neither the name of Intel Corporation nor the names of its contributors 
+shall be used to endorse or promote products derived from this Software 
+without specific prior written permission.
+
+Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+royalty-free patent license under Licensed Patents to make, use, sell, offer 
+to sell, import and otherwise transfer the Software, if any, in source code 
+and object code form. This license shall include changes to the Software 
+that are error corrections or other minor changes to the Software that do 
+not add functionality or features when the Software is incorporated in any 
+version of an operating system that has been distributed under the GNU 
+General Public License 2.0 or later. This patent license shall apply to the 
+combination of the Software and any operating system licensed under the GNU 
+Public License version 2.0 or later if, at the time Intel provides the 
+Software to Recipient, such addition of the Software to the then publicly 
+available versions of such operating systems available under the GNU Public 
+License version 2.0 or later (whether in gold, beta or alpha form) causes 
+such combination to be covered by the Licensed Patents. The patent license 
+shall not apply to any other combinations which include the Software. NO 
+hardware per se is licensed hereunder.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/Makefile linux/drivers/net/e1000/Makefile
--- ../ia64/linux/drivers/net/e1000/Makefile	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/Makefile	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,18 @@
+#
+# Makefile for the Intel(R) PRO/1000 ethernet driver
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+
+O_TARGET := e1000.o
+EXTRA_CFLAGS = -DIANS -DIANS_BASE_VLAN_TAGGING -DIANS_BASE_ADAPTER_TEAMING -DIANS_BASE_VLAN_ID
+
+obj-y   := e1000_main.o e1000_mac.o e1000_phy.o e1000_proc.o \
+		ans.o ans_hw.o ans_os.o ans_driver.o
+
+obj-m   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/README linux/drivers/net/e1000/README
--- ../ia64/linux/drivers/net/e1000/README	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/README	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,352 @@
+Linux* Base Driver for the Intel(R) PRO/1000 Family of Adapters
+===============================================================
+
+February 5, 2002
+
+
+Contents
+========
+
+- In This Release
+- Supported Adapters
+- Building and Installation
+- Command Line Parameters
+- Speed and Duplex Configuration
+- Additional Configurations
+- Known Issues
+- Troubleshooting
+- Support
+
+
+In This Release
+===============
+
+This file describes the Linux* Base Driver for the Intel(R) PRO/1000 Family 
+of Adapters, version 4.1.x. This driver is intended for 2.2.x and 2.4.x 
+kernels; it is known to build properly on 2.2.x kernels through 2.2.20 and 
+on 2.4.x kernels through 2.4.17. Intel focused testing on Intel processor-
+based systems running kernels 2.4.7 and 2.2.16. This driver includes support 
+for Itanium(TM)-based systems.
+
+The Intel PRO/1000 driver is only supported as a loadable module at this time. 
+Intel is not supplying patches against the kernel source to allow for static 
+linking of the driver. For questions related to hardware requirements, refer 
+to the documentation supplied with your Intel PRO/1000 adapter. All hardware 
+requirements listed apply to use with Linux.
+
+This release version includes the following:
+
+   - hooks for Intel ANS, the Intel Advanced Networking Services driver. Some
+     base driver versions within specific distributions, including Red Hat*, 
+     do not include these hooks.
+
+   - support for the ethtool 1.4 interface. A third-party application can use 
+     the ethtool interface to get and set driver parameters.
+
+   - the zero copy feature. Zero copy provides faster information throughput.
+     By default, this feature is enabled if using a kernel that supports it. 
+     Zero copy is not supported on the original PWLA8490 (plain) adapter.
+
+New features include support for the Intel(R) PRO/1000 MT Desktop Adapter.
+
+Supported Adapters
+==================
+
+The following Intel network adapters are compatible with the drivers in this 
+release:
+
+   Controller  Adapter Name                     Board IDs
+   ----------  ------------                     ---------
+
+   82540       PRO/1000 MT Desktop Adapter      A78408-xxx
+
+   82542       PRO/1000 Gigabit Server Adapter  700262-xxx, 717037-xxx
+
+   82543       PRO/1000 F Server Adapter        738640-xxx, A38888-xxx,
+                                                A06512-xxx
+
+   82543       PRO/1000 T Server Adapter        A19845-xxx, A33948-xxx
+
+   82544       PRO/1000 XT Server Adapter       A51580-xxx
+
+   82544       PRO/1000 XF Server Adapter       A50484-xxx
+
+   82544       PRO/1000 T Desktop Adapter       A62947-xxx
+
+
+To verify your Intel adapter is supported, find the board ID number on the 
+adapter. Look for a label that has a barcode and a number in the format of 
+123456-001 (six digits hyphen three digits). Match this to the list of 
+numbers above.
+
+For more information on how to identify your adapter, go to the Adapter & 
+Driver ID Guide at:
+
+    http://support.intel.com/support/network/adapter/pro100/21397.htm
+
+For the latest Intel network drivers for Linux, go to:
+
+    http://appsr.intel.com/scripts-df/support_intel.asp
+
+
+Building and Installation
+=========================
+
+To build a binary RPM* package of this driver, run 'rpm -tb <filename.tar.gz>'. 
+Replace <filename.tar.gz> with the specific filename of the driver.
+
+NOTE: For the build to work properly, the currently running kernel MUST match 
+      the version and configuration of the installed kernel sources. If you 
+      have just recompiled the kernel reboot the system now.
+
+1. Move the base driver tar file to the directory of your choice. For example,
+   use /home/username/e1000 or /usr/local/src/e1000.
+
+2. Untar/unzip archive:
+
+     tar zxf e1000-x.x.x.tar.gz
+
+3. Change to the driver src directory:
+
+     cd e1000-x.x.x/src/
+
+4. Compile the driver module:
+
+     make install
+
+   The binary will be installed as:
+     For Linux 2.2.x systems:
+        /lib/modules/[KERNEL_VERSION]/net/e1000.o
+     For Linux 2.4.x systems:
+        /lib/modules/[KERNEL_VERSION]/kernel/drivers/net/e1000.o
+
+   NOTE: The install locations listed above are the default locations. They 
+         may not be correct for certain Linux distributions. For more 
+         information, see the ldistrib.txt file included in the driver tar.
+
+5. Install the module:
+
+     insmod e1000 <parameter>=<value>
+
+6. Assign an IP address to the interface by entering the following, where
+   x is interface number:
+
+     ifconfig ethx <IP_address>
+
+7. Verify that the interface works. Enter the following, where <IP_address>
+   is the IP address for another machine on the same subnet as the interface 
+   that is being tested:
+
+     ping  <IP_address>	
+
+
+Command Line Parameters
+=======================
+
+The following parameters are used by entering them on the command line with 
+the modprobe or insmod command. For example, with two PRO/1000 PCI adapters, 
+entering:
+
+    insmod e1000 TxDescriptors=80,128
+
+loads the e1000 driver with 80 TX resources for the first adapter and 128 TX 
+resources for the second adapter.
+
+For more information about the AutoNeg, Duplex, and Speed parameters, see the
+"Speed and Duplex Configuration" section in this document.
+
+
+AutoNeg (Intel PRO/1000 T and PRO/1000 XT server adapters only)
+Valid Range: 0-0x0F, 0x20-0x2F
+Default Value: 0x2F
+    This parameter is a bit mask that specifies which speed and duplex
+    settings the board advertises. When this parameter is used, the Speed and
+    Duplex parameters must not be specified.  
+
+Duplex (Intel PRO/1000 T and PRO/1000 XT server adapters only)
+Valid Range: 0-2 (0=auto-negotiate, 1=half, 2=full)
+Default Value: 0
+    Defines the direction in which data is allowed to flow. Can by either one 
+    or two-directional. If both Duplex and the link partner are set to auto-
+    negotiate, the board auto-detects the correct duplex. If the link partner
+    is forced (either full or half), Duplex defaults to half-duplex.
+
+FlowControl
+Valid Range: 0-3 (0=none, 1=Rx only, 2=Tx only, 3=Rx&Tx)
+Default: Read flow control settings from the EEPROM
+    This parameter controls the automatic generation(Tx) and response(Rx) to 
+    Ethernet PAUSE frames.
+
+RxDescriptors
+Valid Range: 80-256 for 82542 and 82543-based adapters
+             80-4096 for 82540 and 82544-based adapters
+Default Value: 256
+    This value is the number of receive descriptors allocated by the driver. 
+    Increasing this value allows the driver to buffer more incoming packets. 
+    Each descriptor is 16 bytes.  A receive buffer is also allocated for each
+    descriptor and can be either 2048, 4096, 8192, or 16384 bytes, depending 
+    on the MTU setting.
+
+RxIntDelay
+Valid Range: 0-65535 (0=off)
+Default Value: 64
+    This value delays the generation of receive interrupts in units of 1.024 
+    microseconds.  Receive interrupt reduction can improve CPU efficiency if 
+    properly tuned for specific network traffic. Increasing this value adds 
+    extra latency to frame reception and can end up decreasing the throughput 
+    of TCP traffic.  If the system is reporting dropped receives, this value 
+    may be set too high, causing the driver to run out of available receive 
+    descriptors.
+
+Speed (Intel PRO/1000 T and PRO/1000 XT server adapters only)
+Valid Settings: 0, 10, 100, 1000
+Default Value: 0 (auto-negotiate at all supported speeds)
+    Speed forces the line speed to the specified value in megabits per second
+    (Mbps). If this parameter is not specified or is set to 0 and the link 
+    partner is set to auto-negotiate, the board will auto-detect the correct 
+    speed. Duplex must also be set when Speed is set to either 10 or 100.
+
+TxDescriptors
+Valid Range: 80-256 for 82542 and 82543-based adapters
+             80-4096 for 82540 and 82544-based adapters
+Default Value: 256
+    This value is the number of transmit descriptors allocated by the driver.
+    Increasing this value allows the driver to queue more transmits. Each 
+    descriptor is 16 bytes.
+
+TxIntDelay
+Valid Range: 0-65535 (0=off)
+Default Value: 64
+    This value delays the generation of transmit interrupts in units of 1.024
+    microseconds.  Transmit interrupt reduction can improve CPU efficiency if 
+    properly tuned for specific network traffic.  If the system is reporting 
+    dropped transmits, this value may be set too high causing the driver to 
+    run out of available transmit descriptors.
+
+XsumRX (not available on the PRO/1000 Gigabit Server Adapter)
+Valid Range: 0-1
+Default Value: 1
+    A value of '1' indicates that the driver should enable IP checksum
+    offload for received packets (both UDP and TCP) to the adapter hardware.
+
+
+Speed and Duplex Configuration
+==============================
+
+Three keywords are used to control the speed and duplex configuration of the 
+PRO/1000 T and PRO/1000 XT server adapters. These keywords are Speed, Duplex,
+and AutoNeg.
+
+If the board uses a fiber interface, these keywords are ignored, and the 
+fiber interface board only links at 1000 Mbps full-duplex.
+
+For copper-based boards, the keywords interact as follows:
+
+  The default operation is auto-negotiate. The board advertises all supported
+  speed and duplex combinations, and it links at the highest common speed and
+  duplex mode IF the link partner is set to auto-negotiate.
+
+  If Speed = 1000, limited auto-negotiation is enabled and only 1000 Mbps is
+  advertised (The 1000BaseT spec requires auto-negotiation.)
+
+  If Speed = 10 or 100, then both Speed and Duplex must be set. Auto-
+  negotiation is disabled, and the AutoNeg parameter is ignored. Partner MUST
+  also be forced.
+
+The AutoNeg parameter is used when more control is required over the auto-
+negotiation process.  When this parameter is used, Speed and Duplex must not 
+be specified.  This parameter is a bitmap that specifies which speed and 
+duplex settings are advertised to the link partner.
+
+Bit            7      6      5       4       3      2      1       0
+Speed (Mbps)   N/A    N/A    1000    N/A     100    100    10      10
+Duplex                       Full            Full   Half   Full    Half
+
+Note that setting AutoNeg does not guarantee that the board will link at the 
+highest specified speed or duplex mode, but the board will link at the 
+highest possible speed/duplex of the link partner IF the link partner is also
+set to auto-negotiate. If the link partner is forced speed/duplex, the 
+adapter MUST be forced to the same speed/duplex.
+
+
+Additional Configurations
+=========================
+
+Configuring a network driver to load properly when the system is started is
+distribution dependent.  Typically, the configuration process involves adding
+an alias line to /etc/modules.conf as well as editing other system startup 
+scripts and/or configuration files.  Many popular Linux distributions ship 
+with tools to make these changes for you.  To learn the proper way to 
+configure a network device for your system, refer to your distribution 
+documentation. If during this process you are asked for the driver or module 
+name, the name for the Linux Base Driver for the Intel PRO/1000 Family of 
+Adapters is e1000.
+
+Link messages will not be displayed to the console if the distribution is 
+restricting system messages. In order to see network driver link messages on 
+your console, set dmesg to at least six by entering the following:
+
+     dmesg -n 6
+
+
+Known Issues
+============
+
+  Driver Hangs Under Heavy Traffic Loads
+  --------------------------------------
+
+  Intel is aware that previously released e1000 drivers may hang under very
+  specific types of heavy traffic loads. This version includes a workaround
+  that resets the adapter automatically if a hang condition is detected. This
+  workaround ensures network traffic flow is not affected when a hang occurs.
+
+  Jumbo Frames System Requirement
+  -------------------------------
+
+  Memory allocation failures have been observed on Linux systems with 64 MB 
+  of RAM or less that are running Jumbo Frames. If you are using Jumbo 
+  Frames, your system may require more than the advertised minimum 
+  requirement of 64 MB of system memory.
+
+
+Troubleshooting
+===============
+
+NOTE: For distribution-specific information, see the ldistrib.txt file 
+      included in the driver tar.
+
+When trying to compile the driver by running make install, the following
+error may occur: 
+
+    "Linux kernel source not configured - missing version.h"
+
+To solve this issue, create the version.h file by going to the Linux source 
+tree and entering:
+
+    make include/linux/version.h.
+
+
+Support
+=======
+
+For general information and support, go to the Intel support website at:
+
+    http://support.intel.com
+
+If an issue is identified with the released source code on the supported
+kernel with a supported adapter, email the specific information related to 
+the issue to linux.nics@intel.com.
+
+
+License
+=======
+
+This software program is released under the terms of a license agreement 
+between you ('Licensee') and Intel. Do not use or load this software or any 
+associated materials (collectively, the 'Software') until you have carefully 
+read the full terms and conditions of the LICENSE located in this software 
+package. By loading or using the Software, you agree to the terms of this 
+Agreement. If you do not agree with the terms of this Agreement, do not 
+install or use the Software.
+
+* Other names and brands may be claimed as the property of others.
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans.c linux/drivers/net/e1000/ans.c
--- ../ia64/linux/drivers/net/e1000/ans.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,1353 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  ans.c                                                 *
+*                                                                     *
+* Abstract:                                                           *
+*                                                                     *
+* Environment:  This file is intended to be shared among Linux and    *
+*               Unixware operating systems.                           *
+*                                                                     *
+**********************************************************************/
+
+#include "ans_driver.h"
+
+/* I meant to make these inline, but don't have time to figure out
+** compiler problems right now...
+*/
+BD_ANS_BOOLEAN BD_ANS_BCMP(u8 *s1, u8 *s2, u32 length)
+{
+    while (length) {
+        if (*s1 != *s2)
+            return BD_ANS_FALSE;
+        length--; s1++; s2++;
+    }
+    return BD_ANS_TRUE;
+}
+ 
+ 
+ 
+void BD_ANS_BCOPY(u8 *destination, u8 *source, u32 length)
+{
+    while (length--) {
+        *destination++ = *source++;
+    }
+}
+ 
+ 
+void BD_ANS_BZERO(u8 *s, u32 length)
+{
+    while (length--)
+        *s++ = 0;
+}                  
+
+
+/* bd_ans_ProcessRequest()
+**
+**  This routine is called if iANS has issued a command to the driver through
+**  the driver's private ioctl routine.  It will parse the header for the 
+**  opcode of the command to execute, and call the appropriate functions.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**              
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command is recognized and was 
+**                            processed successfully, FAILURE otherwise.
+*/ 
+BD_ANS_STATUS bd_ans_ProcessRequest(BOARD_PRIVATE_STRUCT *bps, 
+                                    iANSsupport_t *iANSdata,
+                                    IANS_BD_PARAM_HEADER *header)
+{
+    
+    DEBUGLOG("bd_ans_ProcessRequest: enter\n");
+
+    /* Only allow IANS_OP_BD_IDENTIFY if iANS comm is down */
+    if((iANSdata->iANS_status == IANS_COMMUNICATION_DOWN) && 
+       (header->Opcode!=IANS_OP_BD_IDENTIFY)) {
+      DEBUGLOG("bd_ans_ProcessRequest: ANS communication not up\n");
+      return BD_ANS_FAILURE;
+    }
+    
+    switch (header->Opcode) {
+    case IANS_OP_BD_IDENTIFY:
+        DEBUGLOG("bd_ans_ProcessRequest: Identify request\n");
+        return (bd_ans_Identify(bps, iANSdata, header));
+      
+    case IANS_OP_BD_DISCONNECT:
+        DEBUGLOG("bd_ans_ProcessRequest: Disconnect request\n");
+        return (bd_ans_Disconnect(bps, iANSdata, header));
+      
+    case IANS_OP_EXT_GET_CAPABILITY:
+        DEBUGLOG("bd_ans_ProcessRequeest: Ext Get Capabilities request\n");
+        return (bd_ans_ExtendedGetCapability(bps, iANSdata, header));
+      
+    case IANS_OP_EXT_SET_MODE:
+        DEBUGLOG("bd_ans_ProcessRequest: Ext Set mode request\n");
+        return (bd_ans_ExtendedSetMode(bps, iANSdata, header));
+      
+    case IANS_OP_EXT_GET_STATUS:
+        DEBUGLOG("bd_ans_ProcessRequest: Ext Get Status request\n");
+        return (bd_ans_ExtendedGetStatus(bps, iANSdata, header));
+#ifdef IANS_BASE_VLAN_TAGGING
+    case IANS_OP_ITAG_GET_CAPABILITY:
+        DEBUGLOG("bd_ans_ProcessRequest: get itag capability request\n");
+        return (bd_ans_TagGetCapability(bps, iANSdata, header));
+      
+    case IANS_OP_ITAG_SET_MODE:
+        DEBUGLOG("bd_ans_ProcessRequest: itag set mode request\n");
+        return (bd_ans_TagSetMode(bps, iANSdata, header));
+#endif
+#ifdef IANS_BASE_VLAN_ID        
+    case IANS_OP_IVLAN_ID_GET_CAPABILITY:
+        DEBUGLOG("bd_ans_ProcessRequest: get vlan capability request\n");
+        return (bd_ans_VlanGetCapability(bps, iANSdata, header));
+      
+    case IANS_OP_IVLAN_ID_SET_MODE:
+        DEBUGLOG("bd_ans_ProcessRequest: vlan set mode request\n");
+        return (bd_ans_VlanSetMode(bps, iANSdata, header));
+      
+    case IANS_OP_IVLAN_ID_SET_TABLE:
+        DEBUGLOG("bd_ans_ProcessRequest: vlan set table request\n");
+        return (bd_ans_VlanSetTable(bps, iANSdata, header));
+#endif       
+    default:
+        return (bd_ans_os_ProcessRequest(bps, iANSdata, header));
+    } 
+}
+                                    
+
+
+/* bd_ans_Identify()
+**
+**  This routine will identify the base driver to the ANS module by filling out
+**  the required structure.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_Identify(BOARD_PRIVATE_STRUCT *bps,
+                              iANSsupport_t *iANSdata,
+                              IANS_BD_PARAM_HEADER *header)
+
+{
+    IANS_BD_PARAM_IDENTIFY *iANSidentify;
+    u32 BDCommVersion;               /* base driver communication version */
+
+    /* Get our comm version from the #defines */
+    BDCommVersion = (IANS_BD_COMM_VERSION_MAJOR << 16) +  IANS_BD_COMM_VERSION_MINOR;
+    iANSidentify = (IANS_BD_PARAM_IDENTIFY *)header;
+
+    /* if copyright string doesnt match or iANS comm version is older return error */
+    if ((iANSidentify->iANSCommVersion < BDCommVersion)||
+        (BD_ANS_BCMP(iANSidentify->iANSSignature,
+                     (u8 *)IntelCopyrightString,
+                     IANS_SIGNATURE_LENGTH)) != BD_ANS_TRUE) {
+            return BD_ANS_FAILURE;
+    }
+   
+    BD_ANS_DRV_LOCK;
+        
+    /* else set communication to iANS as up */
+    iANSdata->iANS_status = IANS_COMMUNICATION_UP;
+    iANSidentify->BDCommVersion = BDCommVersion;
+    BD_ANS_BCOPY(iANSidentify->BDSignature,
+                 (u8 *)IntelCopyrightString,
+                 IANS_SIGNATURE_LENGTH);
+
+    
+    /* initialize the iANSsupport_t strucutre */
+    /* at this point, this is the only place where we initialize the
+     * support flags for the driver.  In may be that we should do this 
+     * someplace else as well - for example, if we ever support hot-add
+     * then the capabilities may change dynamically, in which case
+     * we will need to call GetAllCapabilities again
+     */
+    return (bd_ans_GetAllCapabilities(bps, iANSdata));    
+}                               
+
+
+
+/* bd_ans_Init()
+**
+**  This function initializes the communication flags.  It should be called
+**  at init time by the driver to initialize this part of the iANSsupport_t 
+**  structure.
+**
+**  Arguments:  iANSsupport_t *iANSdata - the ans related data
+**
+**  Returns:    void
+*/
+void
+bd_ans_Init(iANSsupport_t *iANSdata)
+{
+    /* set all the communication flags to initial values */
+    iANSdata->iANS_status = IANS_COMMUNICATION_DOWN;
+#ifdef IANS_BASE_VLAN_TAGGING
+    iANSdata->vlan_mode = IANS_VLAN_MODE_OFF;
+    iANSdata->vlan_filtering_mode = IANS_VLAN_FILTERING_OFF;
+    iANSdata->num_vlan_filter = 0;
+    iANSdata->tag_mode = IANS_BD_TAGGING_NONE;
+#endif
+    iANSdata->reporting_mode = IANS_STATUS_REPORTING_OFF;
+    iANSdata->timer_id = 0;
+    iANSdata->attributed_mode = BD_ANS_FALSE;
+    iANSdata->routing_mode = IANS_ROUTING_OFF;
+}
+
+
+
+
+/* bd_ans_Disconnect()
+**
+**  This request is sent by ANS when the ANS module is unloading or will
+**  no longer be bound to this particular board.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_Disconnect(BOARD_PRIVATE_STRUCT *bps,
+                                iANSsupport_t *iANSdata,
+                                IANS_BD_PARAM_HEADER *header)
+{
+    if (iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON)
+        bd_ans_DeActivateFastPolling(bps, iANSdata);
+
+        BD_ANS_DRV_UNLOCK;
+
+    return (bd_ans_ResetAllModes(bps, iANSdata));
+}
+                                 
+
+
+/* bd_ans_ExtendedGetCapability()
+**
+**  This function will fill out the structure required for the extended
+**  capabilities query.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_ExtendedGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                           iANSsupport_t *iANSdata,
+                                           IANS_BD_PARAM_HEADER *header)
+{   
+    bd_ans_os_ExtendedGetCapability(bps, iANSdata, header);
+
+    /* Report that base driver supports setting of MAC address */
+    ((IANS_BD_PARAM_EXT_CAP *)header)->BDCanSetMacAddress = 
+        ANS_BD_SUPPORTS(iANSdata->can_set_mac_addr);
+        
+    /* Report supported version of the status reporting structure */
+    ((IANS_BD_PARAM_EXT_CAP *)header)->BDIansStatusVersion = 
+                IANS_STATUS_VERSION;
+    ((IANS_BD_PARAM_EXT_CAP *)header)->BDAllAvailableSpeeds = 
+        iANSdata->available_speeds;
+    
+    return BD_ANS_SUCCESS;        
+}
+
+
+
+
+/* bd_ans_ExtendedSetMode()
+**
+**  This request is sent by ANS to enable either tx/rx of tlv's with
+**  packet data, or to enable routing of all rx packets to ANS.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_ExtendedSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                     iANSsupport_t *iANSdata,                                     
+                                     IANS_BD_PARAM_HEADER *header)
+{
+    BD_ANS_STATUS status;
+    IANS_BD_PARAM_EXT_SET_MODE *request = (IANS_BD_PARAM_EXT_SET_MODE *)header;
+    
+    /* this function call will enable/disable fast polling mode
+     * if it was requested here 
+     */
+    status = bd_ans_SetReportingMode(bps, iANSdata, header);
+
+    /* see if we are being configured to tx/rx tlv */
+    if (request->BDIansAttributedMode == IANS_REQUEST_SUPPORT)
+        iANSdata->attributed_mode = (u32) BD_ANS_TRUE;
+    else
+        iANSdata->attributed_mode = (u32) BD_ANS_FALSE;
+
+    /* see if we are being requested to send packets to the
+     * ANS protocol
+     */  
+    bd_ans_os_ExtendedSetMode(bps, iANSdata, header);
+    return (status);
+}
+                                      
+
+
+
+/* bd_ans_ExtendedStopPromiscuousMode()
+**
+**  This function will make the driver stop sending in promiscuous mode
+**  if it is requested by ANS.  It is only required for OSs which don't
+**  provide a native mechanism to do this (UnixWare).  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_ExtendedStopPromiscuousMode(BOARD_PRIVATE_STRUCT *bps,
+                                                 iANSsupport_t *iANSdata)
+{
+    /* if we don't support this, then just leave now. */
+    if (iANSdata->supports_stop_promiscuous == BD_ANS_FALSE)
+        return BD_ANS_FAILURE;
+        
+    if (bd_ans_drv_StopPromiscuousMode(bps))
+        return (BD_ANS_FAILURE);
+    return (BD_ANS_SUCCESS);
+}                                                  
+
+
+
+
+/* bd_ans_ExtendedGetStatus()
+**
+**  This function is called as part of an IOCTL request by ANS to get the 
+**  current status of the driver.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_ExtendedGetStatus(BOARD_PRIVATE_STRUCT *bps,
+                                       iANSsupport_t *iANSdata,
+                                       IANS_BD_PARAM_HEADER *header)
+{
+        DEBUGLOG("bd_ans_ExtendedGetStatus: enter\n");
+
+    /* make sure the driver's status fields are current */
+    bd_ans_drv_UpdateStatus(bps);    
+    
+    /* fill out the required status structure with the updated status */
+    return bd_ans_FillStatus(bps,
+            iANSdata,
+            (void *)&(((IANS_BD_IOC_PARAM_STATUS *)header)->Status));
+}
+                                       
+#ifdef IANS_BASE_VLAN_TAGGING                                       
+/* bd_ans_TagGetCapability()
+**
+**  This function is called as part of an IOCTL request by ANS to get the
+**  tagging capabilities of the driver.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_TagGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                      iANSsupport_t *iANSdata,
+                                      IANS_BD_PARAM_HEADER *header)
+{
+    /* these fields in the iANSdata structure have all been
+     * initialized by GetAllCapabilities during the Identify 
+     * request.
+     */
+    ((IANS_BD_PARAM_ITAG_CAP *)header)->IEEE802_3acTagMode = 
+        ANS_BD_SUPPORTS(iANSdata->IEEE_tag_support);
+    
+    return (BD_ANS_SUCCESS);
+}
+
+
+/* bd_ans_TagSetMode()
+**
+**  This function is called as part of an IOCTL request by ANS to 
+**  enable/disable tagging on the adapter.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_TagSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                iANSsupport_t *iANSdata,
+                                IANS_BD_PARAM_HEADER *header)
+{
+    DEBUGLOG("bd_ans_TagSetMode: enter\n");
+
+    /* filter off requests for unsupported modes */ 
+    switch(((IANS_BD_PARAM_ITAG_SET_MODE *)header)->SetTagMode){
+    case IANS_BD_TAGGING_802_3AC:
+        DEBUGLOG("bd_ans_TagSetMode: IEEE support requested\n");
+        if (iANSdata->IEEE_tag_support == BD_ANS_FALSE)
+            return BD_ANS_FAILURE;
+        break;
+        
+    case IANS_BD_TAGGING_NONE:
+        DEBUGLOG("bd_ans_TagSetMode: UNTAGGED mode requested\n");
+        /* it's ok to break here and not just return, because
+         * if we were previously in tagging mode, this is
+         * essentially telling the driver that we no longer
+         * want to be in tagging mode.  In this case, we do need
+         * to call the ConfigureTagging function to make sure
+         * that the driver disables tagging on the adapter.
+         */
+        break;
+        
+    default:
+        DEBUGLOG("bd_ans_TagSetMode: Failed\n");
+        return BD_ANS_FAILURE;
+        break;
+    }
+    /* configure driver/hw to run in supported mode */
+    iANSdata->tag_mode = ((IANS_BD_PARAM_ITAG_SET_MODE *)header)->SetTagMode; 
+    return (bd_ans_drv_ConfigureTagging(bps));
+}
+#endif                                      
+                                        
+#ifdef IANS_BASE_VLAN_ID
+/* bd_ans_VlanGetCapability()
+**
+**  This function gets the VLAN capabilities of the driver and is called
+**  as part of an IOCTL query by ANS.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_VlanGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                       iANSsupport_t *iANSdata,
+                                       IANS_BD_PARAM_HEADER *header)
+{
+    /* these support fields in the iANSdata were all initialized
+     * in GetAllCapabilities during the Identify query
+     */
+    ((IANS_BD_PARAM_IVLAN_CAP *)header)->VlanIDCapable = 
+        ANS_BD_SUPPORTS(iANSdata->vlan_support);
+    ((IANS_BD_PARAM_IVLAN_CAP *)header)->VlanIDFilteringAble = 
+        ANS_BD_SUPPORTS(iANSdata->vlan_filtering_support);
+    ((IANS_BD_PARAM_IVLAN_CAP *)header)->MaxVlanIDSupported =
+        iANSdata->max_vlan_ID_supported;
+    ((IANS_BD_PARAM_IVLAN_CAP *)header)->MaxVlanTableSize =
+        iANSdata->vlan_table_size;
+    
+    return (BD_ANS_SUCCESS);
+}
+
+
+
+
+/* bd_ans_VlanSetMode()
+**
+**  This function is called as part of an ANS ioctl to request that 
+**  the driver configure itself to run in vlan mode.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_VlanSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                 iANSsupport_t *iANSdata,
+                                 IANS_BD_PARAM_HEADER *header)
+{
+    int i;
+    IANS_BD_PARAM_IVLAN_SET_MODE *request = 
+      (IANS_BD_PARAM_IVLAN_SET_MODE *)header;
+
+    DEBUGLOG("bd_ans_VlanSetMode: enter\n");
+
+    /* all the support flags were initialized in GetAllCapabilities 
+     * as part of the Identify call
+     */
+    
+    /* check to see if we are requested to enable/disable vlan mode */
+    if (iANSdata->vlan_support == BD_ANS_FALSE) {
+        DEBUGLOG("bd_ans_VlanSetMode: driver does NOT support vlan\n");
+        return BD_ANS_FAILURE;
+    }
+    if (request->VlanIDRequest == IANS_REQUEST_SUPPORT)
+        iANSdata->vlan_mode = IANS_VLAN_MODE_ON;
+    else if (request->VlanIDRequest == IANS_DONT_SUPPORT)
+        iANSdata->vlan_mode = IANS_VLAN_MODE_OFF;
+    
+    /* check to see if we are being requested to do some hw filtering
+     * of vlan ids.
+     */
+    if(request->VlanIDFilteringRequest == IANS_REQUEST_SUPPORT) {
+        if (iANSdata->vlan_filtering_support == BD_ANS_FALSE) {
+            DEBUGLOG("bd_ans_VlanSetMode: driver does NOT support vlan filter\n");
+            return BD_ANS_FAILURE;
+        } else {
+            iANSdata->vlan_filtering_mode = IANS_VLAN_FILTERING_ON;         
+            /* initialize the vlan table structures */
+            iANSdata->num_vlan_filter = 0;
+            for (i = 0; i < MAX_NUM_VLAN; i++) 
+                iANSdata->VlanID[i] = 0;
+        }
+    }    
+    else 
+        iANSdata->vlan_filtering_mode = IANS_VLAN_FILTERING_OFF;
+        
+    /* don't assume that we don't need to reconfigure the adapter here.
+     * we also don't want to assume that the driver configures itself
+     * for vlan mode the same way it configures itself for tagging mode.
+     * (although chances are it does).
+     */
+    DEBUGLOG1("bd_ans_VlanSetMode:: vlan mode = %d\n", iANSdata->vlan_mode);
+    return (bd_ans_drv_ConfigureVlan(bps));
+}                                 
+
+
+
+/* bd_ans_VlanSetTable()
+**
+**  This function is called as part of an ANS ioctl request to add some
+**  vlan id's to the hardware vlan filter table.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_VlanSetTable(BOARD_PRIVATE_STRUCT *bps,
+                                  iANSsupport_t *iANSdata,
+                                  IANS_BD_PARAM_HEADER *header)
+{
+    IANS_BD_PARAM_IVLAN_TABLE *request = (IANS_BD_PARAM_IVLAN_TABLE *)header;
+    int i;
+
+    /* filtering mode cannot be ON unless the adapter supports 
+     * vlan filtering.  This was set in VlanSetMode.
+     */
+    if (iANSdata->vlan_filtering_mode == IANS_VLAN_FILTERING_ON) {
+      /* this function assumes that ANS sends us a complete 
+       * table - so we blow away the old one
+       */
+      iANSdata->num_vlan_filter = request->VLanIDNum;
+      for (i = 0; i < iANSdata->num_vlan_filter; i++) {
+          iANSdata->VlanID[i] = request->VLanIDTable[i];
+      }
+      /* let the driver call the hardware routine to configure
+       * the vlan table.
+       */
+      bd_ans_drv_ConfigureVlanTable(bps); 
+      return BD_ANS_SUCCESS; 
+    }
+    return BD_ANS_FAILURE;
+}                              
+                                 
+
+#endif
+
+/* bd_ans_ActivateFastPolling()
+**
+**  This function is called as part of an IOCTL sent by ANS to tell the 
+**  driver to periodically check it's status and send status indications
+**  if the status has changed.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_ActivateFastPolling(BOARD_PRIVATE_STRUCT *bps,
+                                         iANSsupport_t *iANSdata)
+{
+    /* see if timer already active */
+    if (iANSdata->timer_id != 0)
+        return BD_ANS_SUCCESS;
+    return (bd_ans_os_ActivateFastPolling(bps, iANSdata));
+}
+
+
+
+/* bd_ans_DeActivateFastPolling()
+**
+**  This function is called as part of an ANS IOCTL request to
+**  disable status reporting or as part of a disconnect IOCTL request.
+**  It will tell the driver that it no longer needs to keep updating
+**  its status in the Watchdog routine.   
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_DeActivateFastPolling(BOARD_PRIVATE_STRUCT *bps,
+                                           iANSsupport_t *iANSdata)
+{
+    /* if we have a non-zero timer_id, it means that we have
+     * a watchdog routine going.
+     */
+    if (iANSdata->timer_id) {
+       bd_ans_drv_StopWatchdog(bps);
+       iANSdata->timer_id = 0;
+    }    
+    return (BD_ANS_SUCCESS);
+}
+
+
+
+
+/* bd_ans_SetReportingMode()
+**
+**  This function is called as part of an ANS ioctl request to start/stop
+**  reporting status changes from the driver.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/
+BD_ANS_STATUS bd_ans_SetReportingMode(BOARD_PRIVATE_STRUCT *bps, 
+                                      iANSsupport_t *iANSdata,
+                                      void *ans_buffer)
+{
+    BD_ANS_STATUS status;
+    IANS_BD_PARAM_EXT_SET_MODE *iANSreport;
+    iANSreport = (IANS_BD_PARAM_EXT_SET_MODE *)ans_buffer;
+
+    DEBUGLOG1("bd_ans_SetReportingMode: %d\n",
+        (iANSreport->BDIansStatusReport == IANS_REQUEST_SUPPORT));
+
+    if (iANSreport->BDIansStatusReport == IANS_REQUEST_SUPPORT){
+        status = bd_ans_ActivateFastPolling(bps, iANSdata);
+        iANSdata->reporting_mode = IANS_STATUS_REPORTING_ON;
+    } else {
+        status = bd_ans_DeActivateFastPolling(bps, iANSdata);
+        iANSdata->reporting_mode = IANS_STATUS_REPORTING_OFF;
+    }
+
+    return status;
+}                                      
+
+
+/* bd_ans_FillStatus()
+**
+**  This function is called both as part of an IOCTL request to get the
+**  driver's current status, and as part of a Watchdog routine to compare
+**  the current status to the previous status.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**              IANS_BD_PARAM_HEADER *header - a pointer to the start of the
+**                                             ans command.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/                                      
+BD_ANS_STATUS bd_ans_FillStatus(BOARD_PRIVATE_STRUCT *bps,
+                                iANSsupport_t *iANSdata,
+                                void *ans_buffer)
+{
+    IANS_BD_PARAM_STATUS *iANSstatus = (IANS_BD_PARAM_STATUS *)ans_buffer;
+
+    DEBUGLOG("bd_ans_FillStatus: enter\n");
+
+    /* tell iANS the supported version of this structure */
+    iANSstatus->StatusVersion       = IANS_STATUS_VERSION;
+
+    /* all these support fields are initialized during the Identify request */
+    /* check for link status */ 
+    if (iANSdata->status_support_flags & BD_ANS_LINK_STATUS_SUPPORTED) {    
+        iANSstatus->LinkStatus = *(iANSdata->link_status);
+     
+        if (iANSstatus->LinkStatus == IANS_STATUS_LINK_FAIL) {
+            iANSstatus->LinkSpeed = IANS_STATUS_LINK_SPEED_NOT_SUPPORTED;
+            iANSstatus->Duplex = IANS_STATUS_DUPLEX_NOT_SUPPORTED;
+        } else {
+            if (iANSdata->status_support_flags & BD_ANS_SPEED_STATUS_SUPPORTED) {
+                switch(*(iANSdata->line_speed)) {
+                    case BD_ANS_10_MBPS:
+                        iANSstatus->LinkSpeed = IANS_STATUS_LINK_SPEED_10MBPS;
+                        break;
+                    case BD_ANS_100_MBPS:
+                        iANSstatus->LinkSpeed = IANS_STATUS_LINK_SPEED_100MBPS;
+                        break;
+                    case BD_ANS_1000_MBPS:
+                        iANSstatus->LinkSpeed = IANS_STATUS_LINK_SPEED_1000MBPS;
+                        break;
+                    default:
+                        iANSstatus->LinkSpeed = IANS_STATUS_LINK_SPEED_NOT_SUPPORTED;
+                        break;
+                }
+            } else {
+                iANSstatus->LinkSpeed = IANS_STATUS_LINK_SPEED_NOT_SUPPORTED;
+            }
+            
+            /* check for duplex status */   
+            if (iANSdata->status_support_flags & BD_ANS_DUPLEX_STATUS_SUPPORTED) {          
+                switch (*(iANSdata->duplex)) {
+                    case BD_ANS_DUPLEX_FULL:
+                        iANSstatus->Duplex = IANS_STATUS_DUPLEX_FULL;
+                        break;
+                    case BD_ANS_DUPLEX_HALF:
+                        iANSstatus->Duplex = IANS_STATUS_DUPLEX_HALF;
+                        break;
+                    default:
+                        iANSstatus->Duplex = IANS_STATUS_DUPLEX_NOT_SUPPORTED;
+                        break;
+                }
+            } else {
+                iANSstatus->Duplex = IANS_STATUS_DUPLEX_NOT_SUPPORTED;
+            }
+        }
+    
+    } else {
+        iANSstatus->LinkStatus = IANS_STATUS_LINK_NOT_SUPPORTED;
+        iANSstatus->Duplex = IANS_STATUS_LINK_NOT_SUPPORTED;
+        iANSstatus->LinkSpeed = IANS_STATUS_LINK_NOT_SUPPORTED;
+    }
+
+    /* check for hardware failure */
+    if (iANSdata->status_support_flags & BD_ANS_HW_FAIL_STATUS_SUPPORTED) {
+        iANSstatus->HardwareFailure =
+            (*(iANSdata->hw_fail))?IANS_STATUS_HARDWARE_FAILURE:IANS_STATUS_HARDWARE_OK;
+    } else {
+        iANSstatus->HardwareFailure = IANS_STATUS_HARDWARE_NOT_SUPPORTED;
+    }
+    
+    if (iANSdata->status_support_flags & BD_ANS_RESET_STATUS_SUPPORTED) {
+        iANSstatus->DuringResetProcess = 
+            (*(iANSdata->in_reset))?IANS_STATUS_DURING_RESET:IANS_STATUS_NOT_DURING_RESET;
+    } else {
+        iANSstatus->DuringResetProcess = IANS_STATUS_RESET_NOT_SUPPORTED;
+    }
+    
+    /* check for suspended state */ 
+    if (iANSdata->status_support_flags & BD_ANS_SUSPEND_STATUS_SUPPORTED) {
+        iANSstatus->Suspended = 
+            (*(iANSdata->suspended))?IANS_STATUS_SUSPENDED:IANS_STATUS_NOT_SUSPENDED; 
+    } else {
+        iANSstatus->Suspended = IANS_STATUS_SUSPENDED_NOT_SUPPORTED;
+    }
+    return (BD_ANS_SUCCESS);
+}                                                                      
+
+
+
+/* bd_ans_ResetAllModes()
+**
+**  This function is called as part of an ANS IOCTL request to disconnect  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/                                                                     
+BD_ANS_STATUS bd_ans_ResetAllModes(BOARD_PRIVATE_STRUCT *bps,
+                                   iANSsupport_t *iANSdata)
+{
+    int i;
+
+    DEBUGLOG("bd_ans_ResetAllModes: enter\n");
+        
+    /* in most cases I don't check the return values here because there isn't
+     * much I can do about it if it fails 
+     */
+    (void)bd_ans_DeActivateFastPolling(bps, iANSdata);
+    BD_ANS_BZERO((u8 *)&iANSdata->prev_status,sizeof(IANS_BD_PARAM_STATUS));
+    
+    /* set link to iANS as down  */
+    iANSdata->iANS_status          = IANS_COMMUNICATION_DOWN;
+    iANSdata->attributed_mode      = (u32) BD_ANS_FALSE;
+    iANSdata->routing_mode         = IANS_ROUTING_OFF;
+    
+#ifdef IANS_BASE_VLAN_TAGGING
+    /* need to reconfigure the adapter to disable tag mode */
+    iANSdata->tag_mode             = IANS_BD_TAGGING_NONE;
+    (void) bd_ans_drv_ConfigureTagging(bps);
+    
+    /* need to reconfigure the adapter to disable vlan mode */    
+    iANSdata->vlan_mode            = IANS_VLAN_MODE_OFF;
+    (void) bd_ans_drv_ConfigureVlan(bps);
+    
+    /* need to reset the vlan filter table and configure the
+     * adapter to disable vlan filtering 
+     */
+    iANSdata->vlan_filtering_mode = IANS_VLAN_FILTERING_OFF;
+        iANSdata->num_vlan_filter      = 0;
+    for (i = 0; i < MAX_NUM_VLAN; i++) {
+                iANSdata->VlanID[i] = 0;
+        }
+    (void) bd_ans_drv_ConfigureVlanTable(bps);
+#endif
+
+    return (BD_ANS_SUCCESS);
+}
+
+
+
+/* bd_ans_GetAllCapabilities()
+**
+**  This function is called as part of an ANS IOCTL request to get
+**  open communication with the base driver (Identify).  It will
+**  initialize all the support flags of the support structure.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSsupport_t *iANSdata   - pointer to the iANS required
+**                                          support structure
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/                                                                     
+
+BD_ANS_STATUS bd_ans_GetAllCapabilities(BOARD_PRIVATE_STRUCT *bps,
+                                        iANSsupport_t *iANSdata)
+{
+    /* get the OS specific capabilities */
+    iANSdata->can_set_mac_addr = BD_ANS_OS_MAC_ADDR_SUPPORT;
+    iANSdata->supports_stop_promiscuous = BD_ANS_OS_STOP_PROM_SUPPORT;
+    
+    /* get the Driver specific capabilities */
+    iANSdata->status_support_flags = BD_ANS_DRV_STATUS_SUPPORT_FLAGS;
+    iANSdata->max_vlan_ID_supported = BD_ANS_DRV_MAX_VLAN_ID(bps);
+    iANSdata->vlan_table_size = BD_ANS_DRV_MAX_VLAN_TABLE_SIZE(bps);
+    iANSdata->IEEE_tag_support = BD_ANS_DRV_IEEE_TAG_SUPPORT(bps);
+    iANSdata->vlan_support =   BD_ANS_DRV_VLAN_SUPPORT(bps);
+    iANSdata->vlan_filtering_support = BD_ANS_DRV_VLAN_FILTER_SUPPORT(bps);
+    iANSdata->vlan_offload_support = BD_ANS_DRV_VLAN_OFFLOAD_SUPPORT(bps);
+    
+    /* get the hardware specific capabilities */
+    iANSdata->available_speeds  = BD_ANS_HW_AVAILABLE_SPEEDS(bps);
+    return (bd_ans_os_GetAllCapabilities(bps, iANSdata));
+}                                        
+
+
+
+/* bd_ans_Receive()
+**
+**  This function is called when the driver has been configured to
+**  run in attributed mode (meaning we are attaching TLVs to each
+**  packet).  It will perform the neccessary operations to create
+**  the needed TLVs and attach them to the frame.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              iANSSupport_t *iANSdata - pointer to ANS data structure.
+**              HW_RX_DESCRIPTOR *rxd - pointer to hw dependent rx struct
+**              FRAME_DATA *frame - pointer to an ethernet frame
+**              OS_DATA *os_data - pointer to OS dependent frame data
+**              OS_DATA **os_tlv - pointer to a pointer to the os structure
+**                                 containing the tlv data.  This pointer is
+**                                 modified by this routine.
+**              u32 *tlv_list_length - pointer to the length of the
+**                                      new tlv list.  This is modified
+**                                      by this routine.  It is provided in 
+**                                      case some OS needs to adjust the
+**                                      length value in it's OS_DATA structure.
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/                                                                     
+BD_ANS_STATUS bd_ans_Receive(BOARD_PRIVATE_STRUCT *bps,
+                             iANSsupport_t *iANSdata,
+                             HW_RX_DESCRIPTOR *rxd,
+                             FRAME_DATA *frame,
+                             OS_DATA *os_frame_data,
+                             OS_DATA **os_tlv,
+                             u32 *tlv_list_length)
+{
+    BD_ANS_BOOLEAN Frame_is_tagged;
+    peth_vlan_header_t peth_vlan_header =  (peth_vlan_header_t )frame;
+    u16 tag;
+    u32 tlvlist_length = 0; /* Total length of all TLVs */
+
+    DEBUGLOG("bd_ans_Receive: enter\n");
+
+#ifdef IANS_BASE_VLAN_TAGGING
+    /* check to see if this is a qtag packet */
+    
+    Frame_is_tagged = bd_ans_IsQtagPacket(bps, iANSdata, rxd, peth_vlan_header);
+    DEBUGLOG1("bd_ans_Receive: fram_is_tagged=%d\n", Frame_is_tagged);
+    /* get the vlan id */
+    tag = bd_ans_GetVlanId(bps, iANSdata, rxd, peth_vlan_header);
+    
+    switch (iANSdata->tag_mode)
+    {
+        case IANS_BD_TAGGING_NONE:
+            /* the rules are as follows for this situation:
+             * vlan tagged - drop
+             * priority tagged - strip, and send w/o OOB
+             * untagged - receive and send w/o OOB
+             *
+             * As we are required to send attributed packets,
+             * we will fill out just the last attribute and send it
+             * if we accept the packet. 
+             */
+            DEBUGLOG("bd_ans_Receive: Tagging mode NONE\n");
+            if (Frame_is_tagged) {
+              if (tag) {
+                  DEBUGLOG("bd_ans_Receive: Invalid VLAN packet\n");
+                  return BD_ANS_FAILURE;
+              }
+              /* priority tagged */
+              if (iANSdata->vlan_offload_support == BD_ANS_FALSE)
+                  bd_ans_os_StripQtagSW(os_frame_data);
+            }
+            break;
+            
+        case IANS_BD_TAGGING_802_3AC:
+            /* here we have the following rules:
+             * VLAN-tagged: strip, report vlan id in tlv
+             * Priority-tagged: drop
+             * Untagged: receive with untagged tlv.
+             *
+             *  The Untagged rule is there for 802.3ad requirements.
+             *  The 802.3ad spec allows for sending protocol packets
+             *  to and from the switch that ANS must be able to
+             *  receive.
+             */
+            DEBUGLOG("bd_ans_Receive: Tagging mode 802.3ac\n");
+            if (Frame_is_tagged && !tag) {
+                DEBUGLOG("bd_ans_Receive: Invalid VLAN packet\n");
+                return BD_ANS_FAILURE;
+            }
+            if (tlvlist_length == 0) {
+              if (bd_ans_os_AllocateTLV(os_frame_data, os_tlv) == BD_ANS_FAILURE) {
+                  DEBUGLOG("bd_ans_Receive: Failed to allocated TLV\n");
+                  return BD_ANS_FAILURE;
+              }
+            }
+            if (Frame_is_tagged) {
+              /* VLAN_ID TLV */
+              tlvlist_length += bd_ans_os_AttributeFill(IANS_ATTR_VLAN_ID, 
+                                                        *os_tlv, 
+                                                        tlvlist_length,
+                                                        (void *)&tag);
+              if (iANSdata->vlan_offload_support == BD_ANS_FALSE)
+                  bd_ans_os_StripQtagSW(os_frame_data);
+            } 
+            else {
+              /* Send along, but untagged */
+              /* Untagged TLV */
+              tlvlist_length += bd_ans_os_AttributeFill(IANS_ATTR_TAGGING_UNTAGGED, 
+                                                        *os_tlv, 
+                                                        tlvlist_length,
+                                                        NULL);
+            }
+            break;
+    default:     
+      DEBUGLOG("bd_ans_Receive: Invalid tagging mode\n");
+      return BD_ANS_FAILURE;        
+    }
+#endif
+    /* allocate space for the last attribute TLV */
+    if (tlvlist_length == 0) {
+      if (bd_ans_os_AllocateTLV(os_frame_data, os_tlv) ==
+          BD_ANS_FAILURE) {
+          DEBUGLOG("bd_ans_Receive: failed to allocated TLV\n");
+          return BD_ANS_FAILURE;                 
+      }
+    }       
+    
+    /* Last Attribute TLV */
+    tlvlist_length += bd_ans_os_AttributeFill(IANS_ATTR_LAST_ATTR, 
+                                              *os_tlv, 
+                                              tlvlist_length,
+                                              NULL);
+    *tlv_list_length = tlvlist_length;
+    return BD_ANS_SUCCESS;
+}
+                             
+
+
+
+/* bd_ans_Transmit()
+**
+**  This function is called when the driver has been configured to be
+**  run in attributed mode (meaning we are receiving TLVs along with
+**  the frame from ANS).  It will perform the necessary operations 
+**  according to what TLVs it finds.  Note that it does NOT remove the
+**  TLV list from the frame, it is up to the OS routines to do that 
+**  if it is needed.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - a pointer to the adapters hw 
+**                                          specific data structure.
+**              HW_RX_DESCRIPTOR *rxd - pointer to hw dependent rx struct
+**              FRAME_DATA *frame - pointer to an ethernet frame
+**              OS_DATA *os_data - pointer to OS dependent frame data
+**
+**  Returns:    BD_ANS_STATUS -  SUCCESS if command was processed 
+**                               successfully, FAILURE otherwise.
+*/                                                                     
+BD_ANS_STATUS bd_ans_Transmit(BOARD_PRIVATE_STRUCT *bps,
+                              iANSsupport_t *iANSdata,
+                              pPer_Frame_Attribute_Header pTLV,
+                              HW_TX_DESCRIPTOR *txd,
+                              OS_DATA **frame_ptr,
+                              u16 *vlanid)
+{
+    DEBUGLOG("bd_ans_Transmit: enter\n");
+ 
+#ifdef IANS_BASE_VLAN_TAGGING
+   *vlanid = INVALID_VLAN_ID;
+   
+    /* if we are not in tagging mode, we have nothing to do */
+    if ( iANSdata->tag_mode == IANS_BD_TAGGING_NONE ) {
+        return BD_ANS_SUCCESS;
+    }
+    /* traverse the list of TLVs until we get to the Last TLV. */
+    while (pTLV->AttributeID != IANS_ATTR_LAST_ATTR) { 
+      switch( pTLV->AttributeID ) {
+      case IANS_ATTR_VLAN_ID:
+        *vlanid = (u16) bd_ans_ExtractValue(pTLV);
+        break;
+      default:
+        break;
+      } /* switch AttributeID */
+
+      pTLV = GET_NEXT_TLV(pTLV);
+    }
+
+    DEBUGLOG1("bd_ans_Transmit: vlanid=%d\n", *vlanid);
+    if (*vlanid != INVALID_VLAN_ID) {
+      /* we can insert the qtag here.  Doing this here instead of
+       * within the while loop insures that the TLV list is no longer
+       * needed, and we can recycle that extra memory (if needed)
+       */
+      if (iANSdata->vlan_offload_support == BD_ANS_FALSE) {
+        if (bd_ans_os_InsertQtagSW(bps, frame_ptr, vlanid) == BD_ANS_FAILURE) { 
+            DEBUGLOG("bd_ans_Transmit: Failed to insert qtag sw\n");
+            return BD_ANS_FAILURE; 
+        }              
+      }
+      else {
+        if (bd_ans_hw_InsertQtagHW(bps, txd, vlanid) == BD_ANS_FAILURE) { 
+            DEBUGLOG("bd_ans_Transmit: Failed to insert qtag hw\n");
+            return BD_ANS_FAILURE;
+        }
+      }
+    }
+#endif
+    return (BD_ANS_SUCCESS);
+}
+
+#ifdef IANS_BASE_VLAN_TAGGING
+
+/* bd_ans_IsQtagPacket()
+**
+**  This function will determine whether or not a given packet has a
+**  Qtag in it.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - pointer to the driver's private
+**                                          data structure
+**              iANSsupport_t *iANSdata   - pointer to the required ANS
+**                                          support structure.
+**              HW_RX_DESCRIPTOR *rxd     - pointer to hw specific rx frame
+**                                          descriptor
+**              eth_vlan_header_t *header - pointer to the head of the actual
+**                                          frame data.
+**
+**  Returns:    BD_ANS_BOOLEAN      BD_ANS_TRUE if it is a qtag packet
+**                                  BD_ANS_FALSE if it is not.
+*/
+BD_ANS_BOOLEAN
+bd_ans_IsQtagPacket(BOARD_PRIVATE_STRUCT *bps,
+                    iANSsupport_t *iANSdata, 
+                    HW_RX_DESCRIPTOR *rxd,
+                    peth_vlan_header_t header)
+{
+    /* if vlan_offload_support flag is set, then the driver has already 
+     * stripped the packet and will have a proprietary means of indicating 
+     * that it found a qtag packet.  If so, call the hw module routine to 
+     * check it. 
+     */
+    DEBUGLOG("bd_ans_IsQtagPacket: enter\n");
+
+    if (iANSdata->vlan_offload_support) {
+        return (bd_ans_hw_IsQtagPacket(bps, rxd));
+    }
+    /* print the packet for debugging */
+    DEBUGLOG1("bd_ans_IsQtagPacket: type is 0x%x\n",
+              ntohs(header->Qtag.EtherType));
+    return (ntohs(header->Qtag.EtherType) == QTAG_TYPE);
+}                                                 
+
+
+
+
+/* bd_ans_GetVlanId()
+**
+**  This function will call the hw proprietary function to get the
+**  vlan id if the driver supports vlan offloading, otherwise, it
+**  will get the IEEE vlan id from the packet.
+**
+**  TBD - what about ISL...
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - pointer to the driver's private
+**                                          data structure.
+**              iANSsupport_t *iANSdata   - pointer to the ans required
+**                                          support structure.
+**              HW_RX_DESCRIPTOR *rxd     - pointer to the hw specific
+**                                          rx frame descriptor
+**              eth_vlan_header_t *header - pointer to the actual frame data
+**
+**  Returns:    u16      - the IEEE vlan id.
+*/
+u16
+bd_ans_GetVlanId(BOARD_PRIVATE_STRUCT *bps,
+                 iANSsupport_t *iANSdata, 
+                 HW_RX_DESCRIPTOR *rxd,
+                 peth_vlan_header_t header)    
+{
+    if (iANSdata->vlan_offload_support) {
+        return (bd_ans_hw_GetVlanId(bps, rxd));
+    }
+    return (ntohs(header->Qtag.VLAN_ID) & VLAN_ID_MASK);
+}                     
+#endif
+
+
+/* bd_ans_AttributeFill()
+**
+**  This routine will fill out a TLV based on a given attribute ID
+**
+**  Arguments:   iANS_Attribute_ID attr_id - id which identifies which 
+**                                           TLV this is.
+**               void *pTLV                - pointer to where the TLV should
+**                                           be copied.
+**               void *data                - optional data to be added to the
+**                                           TLV (the V part)
+**
+** Returns:      u32                    - the length of the new TLV
+*/
+u32
+bd_ans_AttributeFill(iANS_Attribute_ID attr_id, 
+                     void *pTLV, 
+                     void *data)
+{
+#ifdef IANS_BASE_VLAN_TAGGING
+    VLAN_ID_Per_Frame_Info *vlan_pfi;
+    Untagged_Attribute *untagged;
+#endif
+    Last_Attribute *last;    
+    int tlv_length = 0;
+    
+    DEBUGLOG("bd_ans_AttributeFill: enter\n");
+    
+    switch(attr_id) 
+    {
+#ifdef IANS_BASE_VLAN_TAGGING
+    case IANS_ATTR_VLAN_ID:
+        DEBUGLOG("bd_ans_AttributeFill: filling vlan id attr\n");
+        tlv_length = sizeof(VLAN_ID_Per_Frame_Info);
+        vlan_pfi = (VLAN_ID_Per_Frame_Info *)pTLV;
+        vlan_pfi->AttrHeader.AttributeID = IANS_ATTR_VLAN_ID;
+        vlan_pfi->AttrHeader.AttributeLength = 
+          tlv_length - sizeof(Per_Frame_Attribute_Header);
+        vlan_pfi->VLanID = *((u16 *)data);
+        break;
+      
+    case IANS_ATTR_TAGGING_UNTAGGED: 
+        DEBUGLOG("bd_ans_AttributeFill: filling untagged attr\n");
+        tlv_length = sizeof(Untagged_Attribute);
+        untagged = (Untagged_Attribute *)pTLV;
+        untagged->AttrHeader.AttributeID = IANS_ATTR_TAGGING_UNTAGGED;
+        untagged->AttrHeader.AttributeLength = 
+          tlv_length - sizeof(Per_Frame_Attribute_Header);
+        break;
+#endif            
+    case IANS_ATTR_LAST_ATTR:
+        DEBUGLOG("bd_ans_AttributeFill: filling last attr\n");
+        tlv_length = sizeof(Last_Attribute);
+        last = (Last_Attribute *)pTLV;
+        last->LastHeader.AttributeID = IANS_ATTR_LAST_ATTR; 
+        last->LastHeader.AttributeLength = 0;   
+        break;
+
+    default:
+	break;
+    }
+    return tlv_length;
+}    
+
+
+
+
+/* bd_ans_ExtractValue()
+**
+**  This function will extract the value from a TLV
+**
+**  Arguments:  Per_Frame_Attribute_Header *pTLV - pointer to the TLV
+**
+**  Returns:    u32 - dword value from the TLV.  Smaller values
+**                       should be cast correctly by the caller.
+*/
+u32
+bd_ans_ExtractValue(Per_Frame_Attribute_Header *pTLV)
+{
+    u32 ret_val;
+    u8 *p;
+    p = (u8 *) &(pTLV->AttributeLength);
+    p += sizeof(pTLV->AttributeLength);
+    ret_val = *((u32 *)p);
+    return (ret_val); 
+}                     
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans.h linux/drivers/net/e1000/ans.h
--- ../ia64/linux/drivers/net/e1000/ans.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,283 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  ans.h                                                 *
+*                                                                     *
+* Abstract:                                                           *
+*                                                                     *
+* Environment:  This file is intended to be shared among Linux and    *
+*               Unixware operating systems.                           *
+*                                                                     *
+**********************************************************************/
+#ifndef _ANS_H
+#define _ANS_H
+
+#include "ans_interface.h"
+
+typedef enum  { BD_ANS_SUCCESS, BD_ANS_FAILURE } BD_ANS_STATUS;
+typedef enum { BD_ANS_FALSE, BD_ANS_TRUE } BD_ANS_BOOLEAN;
+
+/*#include "ans_hw.h"*/
+
+#define BD_ANS_LINK_STATUS_SUPPORTED    0x00000001
+#define BD_ANS_SPEED_STATUS_SUPPORTED   0x00000002
+#define BD_ANS_DUPLEX_STATUS_SUPPORTED  0x00000004
+#define BD_ANS_HW_FAIL_STATUS_SUPPORTED 0x00000008
+#define BD_ANS_SUSPEND_STATUS_SUPPORTED 0x00000010
+#define BD_ANS_RESET_STATUS_SUPPORTED   0x00000020
+
+/* communication status flags */
+#define IANS_COMMUNICATION_DOWN 0
+#define IANS_COMMUNICATION_UP 1
+#define IANS_STATUS_REPORTING_OFF 0
+#define IANS_STATUS_REPORTING_ON 1
+#define IANS_VLAN_FILTERING_OFF 0
+#define IANS_VLAN_FILTERING_ON 1
+#define IANS_VLAN_MODE_OFF 0
+#define IANS_VLAN_MODE_ON 1
+#define IANS_ROUTING_OFF    0
+#define IANS_ROUTING_ON     1
+
+/* vlan related stuff */
+#define QTAG_TYPE          0x8100 
+#define VLAN_PRIORITY_MASK 0xE000
+#define VLAN_TR_FLAG_MASK  0x1000
+#define VLAN_ID_MASK       0x0FFF
+#define QTAG_SIZE 4
+#ifndef ETHERNET_ADDRESS_LENGTH
+#define ETHERNET_ADDRESS_LENGTH	6
+#endif
+#define MAX_NUM_VLAN            128
+#define INVALID_VLAN_ID         0xffff
+
+typedef struct _x8021Q_tag_t {
+    u16 EtherType;
+    u16 VLAN_ID;
+} x8021Q_tag_t, *p8021Q_tag_t;
+
+/*- Ethernet over VLAN Header */
+typedef struct _eth_vlan_header_t 
+{
+    u8     eth_dest[ETHERNET_ADDRESS_LENGTH];
+    u8     eth_src[ETHERNET_ADDRESS_LENGTH];
+    x8021Q_tag_t        Qtag;
+    u16      eth_typelen;
+} eth_vlan_header_t, *peth_vlan_header_t;
+
+typedef struct _iANSsupport_t{
+    /* base driver/ans comm status fields */
+    u32 iANS_status;         /* communication to iANS UP/DOWN*/
+    u32 vlan_mode;           /* VLan mode switch         */
+    u32 vlan_filtering_mode; /* VLan filtering on/off   */
+    u32 num_vlan_filter;     /* number of vlans to filter */
+    u32 tag_mode;            /* see IANS_BD_TAGGING_MODE */
+    u32 reporting_mode;      /* status reporting switch  */
+    u32 timer_id;            /* iANS watchdog timer ID */
+    u32 attributed_mode;     /* sending TLVs with our packets */
+    u32 routing_mode;        /* sending rx packets to ans proto. */
+    
+    /* general driver status fields */
+    u32 *link_status;            
+    u32 *line_speed;
+    u32 *duplex;
+    u32 *hw_fail;
+    u32 *suspended;
+    u32 *in_reset;
+    IANS_BD_PARAM_STATUS prev_status; /* status struct to be compared with current */
+  
+    /* base driver capabilities */
+    u32 status_support_flags;     /* flags to indicate which status is supported */
+    u32 max_vlan_ID_supported;    /* max Vlan ID supported by base-driver*/
+    u32 vlan_table_size;          /* size of VlanID filtering table */
+    BD_ANS_BOOLEAN IEEE_tag_support; /* base driver supports 802.3ac */
+    BD_ANS_BOOLEAN vlan_support;     /* base driver supports VLan */
+    BD_ANS_BOOLEAN vlan_filtering_support; /* base driver supports Vlan filtering*/    
+    BD_ANS_BOOLEAN can_set_mac_addr; /* can the adapter change it's mac addr */
+    BD_ANS_BOOLEAN supports_stop_promiscuous; 
+    union {
+	u32 is_server_adapter;
+	u32 bd_flags;
+    } flags;
+    BD_ANS_BOOLEAN vlan_offload_support;         
+    u32 available_speeds;
+  
+    /* the vlan table */
+    u16 VlanID[MAX_NUM_VLAN];
+} iANSsupport_t, *piANSsupport_t;
+
+#include "ans_os.h"
+#include "ans_hw.h"
+
+#define ANS_BD_SUPPORTS(bool_val) \
+    ((bool_val) == BD_ANS_TRUE)?IANS_BD_SUPPORTS:IANS_BD_DOES_NOT_SUPPORT;
+
+#define GET_NEXT_TLV(tlv) \
+    (Per_Frame_Attribute_Header *)((u8 *)(&(tlv->AttributeLength)) + \
+        sizeof(tlv->AttributeLength) + (tlv)->AttributeLength)
+
+/* function prototypes */
+extern void bd_ans_Init(iANSsupport_t *iANSdata);
+extern BD_ANS_STATUS bd_ans_Identify(BOARD_PRIVATE_STRUCT *bps,
+                                     iANSsupport_t *iANSdata,
+                                     IANS_BD_PARAM_HEADER *header);      
+extern BD_ANS_STATUS bd_ans_Disconnect(BOARD_PRIVATE_STRUCT *bps,
+                                       iANSsupport_t *iANSdata,
+                                       IANS_BD_PARAM_HEADER *header);
+extern BD_ANS_STATUS bd_ans_ExtendedGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                                  iANSsupport_t *iANSdata,
+                                                  IANS_BD_PARAM_HEADER *header); 
+extern BD_ANS_STATUS bd_ans_ExtendedSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                            iANSsupport_t *iANSdata,
+                                            IANS_BD_PARAM_HEADER *header);   
+extern BD_ANS_STATUS bd_ans_ExtendedStopPromiscuousMode(BOARD_PRIVATE_STRUCT *bps,
+                                                        iANSsupport_t *iANSdata);
+extern BD_ANS_STATUS bd_ans_ExtendedGetStatus(BOARD_PRIVATE_STRUCT *bps,
+                                              iANSsupport_t *iANSdata,
+                                              IANS_BD_PARAM_HEADER *header);
+#ifdef IANS_BASE_VLAN_TAGGING
+extern BD_ANS_STATUS bd_ans_TagGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                             iANSsupport_t *iANSdata,
+                                             IANS_BD_PARAM_HEADER *header);
+extern BD_ANS_STATUS bd_ans_TagSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                       iANSsupport_t *iANSdata,
+                                       IANS_BD_PARAM_HEADER *header);
+#endif
+#ifdef IANS_BASE_VLAN_ID
+extern BD_ANS_STATUS bd_ans_VlanGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                              iANSsupport_t *iANSdata,
+                                              IANS_BD_PARAM_HEADER *header);
+extern BD_ANS_STATUS bd_ans_VlanSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                        iANSsupport_t *iANSdata,
+                                        IANS_BD_PARAM_HEADER *header);
+extern BD_ANS_STATUS bd_ans_VlanSetTable(BOARD_PRIVATE_STRUCT *bps,
+                                         iANSsupport_t *iANSdata,
+                                         IANS_BD_PARAM_HEADER *header);
+#endif
+extern BD_ANS_STATUS bd_ans_ActivateFastPolling(BOARD_PRIVATE_STRUCT *bps,
+                                                iANSsupport_t *iANSdata);
+extern BD_ANS_STATUS bd_ans_DeActivateFastPolling(BOARD_PRIVATE_STRUCT *bps,
+                                                  iANSsupport_t *iANSdata);
+extern BD_ANS_STATUS bd_ans_SetReportingMode(BOARD_PRIVATE_STRUCT *bps,
+                                             iANSsupport_t *iANSdata,
+                                             void *ans_buffer);
+extern BD_ANS_STATUS bd_ans_FillStatus(BOARD_PRIVATE_STRUCT *bps,
+                                       iANSsupport_t *iANSdata,
+                                       void *ans_buffer);
+extern BD_ANS_STATUS bd_ans_ResetAllModes(BOARD_PRIVATE_STRUCT *bps,
+                                          iANSsupport_t *iANSdata);
+extern BD_ANS_STATUS bd_ans_GetAllCapabilities(BOARD_PRIVATE_STRUCT *bps,
+                                               iANSsupport_t *iANSdata);
+extern BD_ANS_STATUS bd_ans_Receive(BOARD_PRIVATE_STRUCT *bps,
+                                    iANSsupport_t *iANSdata,
+                                    HW_RX_DESCRIPTOR *rxd,
+                                    FRAME_DATA *frame,
+                                    OS_DATA *os_frame_data,
+                                    OS_DATA **os_tlv,
+                                    u32 *tlv_list_length);
+extern BD_ANS_STATUS bd_ans_Transmit(BOARD_PRIVATE_STRUCT *bps,
+                                     iANSsupport_t *iANSdata,
+                                     pPer_Frame_Attribute_Header pTLV,
+                                     HW_TX_DESCRIPTOR *txd,
+                                     OS_DATA **frame,
+                                     u16 *vlanid);
+extern BD_ANS_BOOLEAN bd_ans_IsQtagPacket(BOARD_PRIVATE_STRUCT *bps,
+                                          iANSsupport_t *iANSdata,
+                                          HW_RX_DESCRIPTOR *rxd,
+                                          peth_vlan_header_t header);
+extern u16 bd_ans_GetVlanId(BOARD_PRIVATE_STRUCT *bps,
+                               iANSsupport_t *iANSdata,
+                               HW_RX_DESCRIPTOR *rxd,
+                               peth_vlan_header_t header);
+extern u32 bd_ans_AttributeFill(iANS_Attribute_ID attr_id,
+                                   void *pTLV,
+                                   void *data);
+extern u32 bd_ans_ExtractValue(Per_Frame_Attribute_Header *pTLV);
+
+
+extern BD_ANS_STATUS bd_ans_ProcessRequest(BOARD_PRIVATE_STRUCT *bps, 
+                                    iANSsupport_t *iANSdata,
+                                    IANS_BD_PARAM_HEADER *header);
+
+extern void BD_ANS_BCOPY(u8 *destination, u8 *source, u32 length);
+extern BD_ANS_BOOLEAN BD_ANS_BCMP(u8 *s1, u8 *s2, u32 length);
+
+#endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans_driver.c linux/drivers/net/e1000/ans_driver.c
--- ../ia64/linux/drivers/net/e1000/ans_driver.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans_driver.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,290 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* driver specific routines for the linux gigabit driver */
+#include "ans_driver.h"
+#include "base_comm.h"
+
+/* bd_ans_drv_InitANS()
+**
+**  This function should be called at driver Init time to set the pointers
+**  in the iANSsupport_t structure to the driver's current pointers.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - private data struct
+**              iANSsupport_t *iANSdata - iANS support structure.
+**
+**  Returns:  void
+**
+*/
+void
+bd_ans_drv_InitANS(BOARD_PRIVATE_STRUCT *bps, 
+		   iANSsupport_t *iANSdata)
+{
+    bd_ans_Init(iANSdata);
+    
+    /* set all the required status fields to this driver's 
+     * status fields.  remove these comments when you are done.
+     */
+    iANSdata->link_status = &(bps->ans_link);
+    iANSdata->line_speed  = &(bps->ans_speed);
+    iANSdata->duplex      = &(bps->ans_duplex);
+    iANSdata->hw_fail   = NULL;
+    iANSdata->suspended = &(bps->ans_suspend);
+    iANSdata->in_reset  = &(bps->ans_suspend);
+}                            
+
+
+
+/* bd_ans_drv_UpdateStatus()
+**
+**  This function should update the driver board status in the iANSsupport
+**  structure for this adapter
+**
+**  Arguments: BOARD_PRIVATE_STRUCT *bps - board private structure
+**
+**  Returns:  void
+*/
+void
+bd_ans_drv_UpdateStatus(BOARD_PRIVATE_STRUCT *bps)
+{
+	bps->ans_link = bps->link_active == 1 ? IANS_STATUS_LINK_OK :
+			                                    IANS_STATUS_LINK_FAIL;
+	bps->ans_speed   = bps->link_speed;
+	bps->ans_duplex  = bps->link_duplex;
+	bps->ans_suspend = bps->shared.adapter_stopped;
+	return;	
+}
+
+
+#ifdef IANS_BASE_VLAN_TAGGING
+/* bd_ans_drv_ConfigureTagging()
+**
+**  This function will call the HW specific functions to configure
+**  the adapter to operate in tagging mode.  This function can also
+**  be called to disable tagging support.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - the driver's private data struct
+**
+**  Returns:    BD_ANS_STATUS - BD_ANS_SUCCESS if the adapter was configured
+**                              BD_ANS_FAILURE if the adapter was not  
+*/
+BD_ANS_STATUS 
+bd_ans_drv_ConfigureTagging(BOARD_PRIVATE_STRUCT *bps)
+{
+	/* this routine should call the hardware specific routines for
+	 * configuring tagging.  Note that this could be the same 
+	 * routine as the vlan configure routine (bd_ans_hw_EnableVlan)
+	 * or bd_ans_hw_DisableTagging depending on how the 
+     * tag_mode flags are set.  The driver should not modify
+     * the flag
+     */
+	struct e1000_adapter * adapter = GIGABIT_ADAPTER_STRUCT(bps);
+	piANSsupport_t iANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+	
+	/* Check the requested mode, and if the NIC is not already operating in
+	 * that mode then call either EnableVLAN or DisableTagging */	
+	switch ((IANS_BD_TAGGING_MODE)iANSdata->tag_mode) {
+	case IANS_BD_TAGGING_NONE:
+		if(adapter->tag_mode != IANS_BD_TAGGING_NONE) {
+			bd_ans_hw_DisableTagging(bps);
+			adapter->tag_mode = IANS_BD_TAGGING_NONE;
+		}
+		break;
+	case IANS_BD_TAGGING_802_3AC:
+		if(adapter->tag_mode != IANS_BD_TAGGING_802_3AC &&
+		   adapter->shared.mac_type >= e1000_82543) {
+			bd_ans_hw_EnableVLAN(bps);
+			adapter->tag_mode = IANS_BD_TAGGING_802_3AC;
+		}
+		break;
+	default:
+		return BD_ANS_FAILURE;
+	}
+	return BD_ANS_SUCCESS;
+}
+
+
+/* bd_ans_drv_ConfigureVlanTable()
+**
+**  This function will call the HW specific functions to configure the
+**  adapter to do vlan filtering in hardware.  This function call also
+**  be called to disable vlan filtering support
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - the driver's private data struct
+**                 
+**  Returns:    BD_ANS_STATUS - BD_ANS_SUCCESS if the adapter was configured
+**                              BD_ANS_FAILURE otherwise
+*/ 
+BD_ANS_STATUS
+bd_ans_drv_ConfigureVlanTable(BOARD_PRIVATE_STRUCT *bps)
+{
+	/* this function should call the hardware specific routines 
+	 * for configuring the vlan table - note that this can be
+	 * the same routines for configuring plain ole vlan (bd_ans_hw_EnableVlan)
+     * or bd_ans_hw_DisableTagging depending on how the vlan_mode
+     * and tag_mode flags are set.  The driver should not modify
+     * the flag
+	 */
+	/* Similar to ConfigureVlan, but always call EnableVlan even if the NIC is
+	 * already in VLAN tagging mode in order to rebuild the VLAN Table */ 
+	piANSsupport_t iANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+
+	return BD_ANS_FAILURE;
+	
+	if(iANSdata->vlan_filtering_mode == IANS_VLAN_FILTERING_ON) {
+			return bd_ans_hw_EnableVLAN(bps);
+	} else {
+			return bd_ans_hw_DisableTagging(bps);
+	}
+}
+
+
+/* bd_ans_drv_ConfigureVlan()
+**
+**  This function will call the HW specific functions to configure the
+**  adapter to operate in vlan mode. This function can also be called
+**  to disable vlan mode.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - the driver's private data struct
+**                 
+**  Returns:    BD_ANS_STATUS - BD_ANS_SUCCESS if the adapter was configured
+**                              BD_ANS_FAILURE otherwise
+*/ 
+BD_ANS_STATUS
+bd_ans_drv_ConfigureVlan(BOARD_PRIVATE_STRUCT *bps)
+{
+	/* this function should call the hardware specific routines
+	 * to configure the adapter in vlan mode (bd_ans_hw_EnableVlan)
+	 * or bd_ans_hw_DisableTagging depending on how the vlan_mode
+     * and tag_mode flags are set.  The driver should not modify
+     * the flag
+     */
+	/* seems the same to me as ConfigureTagging (for 8254x hw at least) CL */
+	return bd_ans_drv_ConfigureTagging(bps);
+}
+#endif
+
+/* bd_ans_drv_StopWatchdog()
+**
+**  Since the linux driver already has a watchdog routine, we just need to
+**  set a flag to change the code path in the watchdog routine to not call
+**  the bd_ans_os_Watchdog() procedure.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - adapter private data
+**
+**  Returns:  void
+*/
+void
+bd_ans_drv_StopWatchdog(BOARD_PRIVATE_STRUCT *bps)
+{
+    /* set a flag to indicate that we no longer need to call
+    ** the bd_ans_os_Watchdog routine.
+    */
+	bps->iANSdata->reporting_mode = IANS_STATUS_REPORTING_OFF;
+}
+
+
+/* bd_ans_drv_StopPromiscuousMode()
+**
+**  The linux driver does not support this.
+*/
+BD_ANS_STATUS
+bd_ans_drv_StopPromiscuousMode(BOARD_PRIVATE_STRUCT *bps)
+{
+    return BD_ANS_FAILURE;
+}
+
+
+/* bd_ans_drv_StartWatchdog()
+**
+**  Since the linux driver already has a watchdog routine started,
+**  we just need to set a flag to change the code path to call the
+**  bd_ans_os_Watchdog routine from the current watchdog routine.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - private data structure.
+** 
+**  Returns:  u32 - non-zero indicates success.
+*/
+u32 
+bd_ans_drv_StartWatchdog(BOARD_PRIVATE_STRUCT *bps)
+{
+    /* set your flag to indicate that the watchdog routine should
+    ** call ans_bd_os_Watchdog().
+    */
+	bps->iANSdata->reporting_mode = IANS_STATUS_REPORTING_ON;
+    
+    /* return a non-zero value */
+    return (1);
+}
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans_driver.h linux/drivers/net/e1000/ans_driver.h
--- ../ia64/linux/drivers/net/e1000/ans_driver.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans_driver.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,130 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* driver defines specific to the linux gigabit driver */
+#ifndef _ANS_DRIVER_H
+#define _ANS_DRIVER_H
+
+/* hardware specfic defines */
+#define BOARD_PRIVATE_STRUCT struct e1000_adapter
+#define HW_RX_DESCRIPTOR struct e1000_rx_desc
+#define HW_TX_DESCRIPTOR struct e1000_tx_desc
+#define FRAME_DATA unsigned char
+#include "e1000.h"
+
+/* you must include this after you define above stuff */
+#include "ans.h"
+
+#define ANS_PRIVATE_DATA_FIELD(bps) ((bps)->iANSdata)
+#define GIGABIT_ADAPTER_STRUCT(bps) (bps)
+#define DRIVER_DEV_FIELD(bps) ((bps)->netdev)
+#define BD_ANS_HW_FLAGS(bps) \
+        (BD_ANS_HW_IS_SERVER(bps) == BD_ANS_TRUE ? IANS_BD_FLAG4 : 0)
+#define BD_ANS_DRV_STATUS_SUPPORT_FLAGS (BD_ANS_LINK_STATUS_SUPPORTED | BD_ANS_SPEED_STATUS_SUPPORTED |BD_ANS_DUPLEX_STATUS_SUPPORTED |BD_ANS_SUSPEND_STATUS_SUPPORTED)
+#define BD_ANS_DRV_MAX_VLAN_ID(bps) 4096 
+#define BD_ANS_DRV_MAX_VLAN_TABLE_SIZE(bps) 4096
+#define BD_ANS_DRV_IEEE_TAG_SUPPORT(bps) \
+		(((bps)->shared.mac_type < e1000_82543) ? \
+		BD_ANS_FALSE : BD_ANS_TRUE)
+#define BD_ANS_DRV_VLAN_SUPPORT(bps) \
+		(BD_ANS_DRV_IEEE_TAG_SUPPORT(bps))
+#define BD_ANS_DRV_VLAN_FILTER_SUPPORT(bps) BD_ANS_TRUE
+#define BD_ANS_DRV_VLAN_OFFLOAD_SUPPORT(bps) BD_ANS_TRUE
+#ifndef MAX_ETHERNET_PACKET_SIZE
+#define MAX_ETHERNET_PACKET_SIZE 1514
+#endif
+
+#define BD_ANS_DRV_PHY_ID(bps)    ((bps)->shared.phy_id)
+#define BD_ANS_DRV_REV_ID(bps)    ((bps)->RevId)
+#define BD_ANS_DRV_SUBSYS_ID(bps) ((bps)->SubSystemId)
+#define WISEMAN_FIRST_REV	WISEMAN_2_0_REV_ID
+
+#ifndef BYTE_SWAP_WORD
+#define BYTE_SWAP_WORD(word) ((((word) & 0x00ff) << 8) \
+								| (((word) & 0xff00) >> 8))
+#endif
+/* function prototypes */
+extern void bd_ans_drv_InitANS(BOARD_PRIVATE_STRUCT *bps, iANSsupport_t *iANSdata);
+extern void bd_ans_drv_UpdateStatus(BOARD_PRIVATE_STRUCT *bps);
+extern BD_ANS_STATUS bd_ans_drv_ConfigureTagging(BOARD_PRIVATE_STRUCT *bdp);
+extern BD_ANS_STATUS bd_ans_drv_ConfigureVlanTable(BOARD_PRIVATE_STRUCT *bps);
+extern BD_ANS_STATUS bd_ans_drv_ConfigureVlan(BOARD_PRIVATE_STRUCT *bps);
+extern void bd_ans_drv_StopWatchdog(BOARD_PRIVATE_STRUCT *bps);
+extern BD_ANS_STATUS bd_ans_drv_StopPromiscuousMode(BOARD_PRIVATE_STRUCT *bps);
+extern u32 bd_ans_drv_StartWatchdog(BOARD_PRIVATE_STRUCT *bps);
+extern void bd_ans_drv_ReturnOSFrameDescriptors(BOARD_PRIVATE_STRUCT *bps);
+extern void bd_ans_drv_SetupHWRxStructures(BOARD_PRIVATE_STRUCT *bps);
+extern void bd_ans_drv_AllocateOSFrameDescriptors(BOARD_PRIVATE_STRUCT *bps);
+
+#endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans_hw.c linux/drivers/net/e1000/ans_hw.c
--- ../ia64/linux/drivers/net/e1000/ans_hw.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans_hw.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,465 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* hardware specific routines for the gigabit adapter */
+
+#include "ans_driver.h"
+
+
+/* bd_ans_hw_available_speeds()
+**
+**  This function will determine the speed capabilities of this adapter
+**  based on the phy type.
+**
+**  Arguments:  u32 phy - the phy id of the adapter
+**
+**  Returns:    u32     - the available speeds of the driver.
+*/
+u32
+bd_ans_hw_available_speeds(u32 phy)
+{
+    u32 speeds;
+    
+    DEBUGLOG("bd_ans_hw_available_speeds: enter\n");
+    
+    /* all gig's support 1000 at least */
+    speeds = IANS_STATUS_LINK_SPEED_1000MBPS;
+    
+    /* check to see if we support 10/100 mbps */
+    if (phy > 0) {
+       speeds |= IANS_STATUS_LINK_SPEED_100MBPS;
+       speeds |= IANS_STATUS_LINK_SPEED_10MBPS;
+    }
+    
+    return (speeds);
+}          
+
+
+#ifdef IANS_BASE_VLAN_TAGGING
+/* bd_ans_hw_IsQtagPacket
+**  
+**  This function will check the receive descriptor to see if we 
+**  have received and 802.1q tagged packet
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - the driver's private
+**                                          data structure 
+**              HW_RX_DESCRIPTOR *rxd - the receive descriptor
+**
+**  Returns:    BD_ANS_BOOLEAN - BD_ANS_TRUE if it is a qtagged packet
+**                               BD_ANS_FALSE otherwise
+*/
+BD_ANS_BOOLEAN
+bd_ans_hw_IsQtagPacket(BOARD_PRIVATE_STRUCT *bps, HW_RX_DESCRIPTOR *rxd)
+{
+    DEBUGLOG("bd_ans_hw_IsQtagPacket: enter\n");
+    /* since gigabit is already cool and shares hardware structures
+     * between OS's, we know we can use this field name without
+     * using a macro.
+     */
+    return ((rxd->status & E1000_RXD_STAT_VP)?BD_ANS_TRUE:BD_ANS_FALSE);
+}
+
+
+/* bd_ans_hw_InsertQtagHW()
+**
+**  This function will insert a 802.1q tag into the correct field in the
+**  transmit descriptor.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - the driver's private data structure
+**              HW_TX_DESCRIPTOR *txd     - the adapter's transmit descriptor
+**              UNIT16 *vlanid            - pointer to the vlan id to insert
+**
+**  Returns:    BD_ANS_STATUS - BD_ANS_SUCCESS always at this point.
+*/
+BD_ANS_STATUS
+bd_ans_hw_InsertQtagHW(BOARD_PRIVATE_STRUCT *bps, HW_TX_DESCRIPTOR *txd, u16
+*vlanid)
+{
+    iANSsupport_t *iANSdata;
+
+    iANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+
+    DEBUGLOG("bd_ans_hw_InsertQtagHW: enter\n");
+
+    /* tell hardware to add tag */
+    txd->lower.data |= E1000_TXD_CMD_VLE;
+
+    /* set the vlan id */
+    txd->upper.fields.special = *vlanid;
+
+    return BD_ANS_SUCCESS;
+}
+
+
+
+/* bd_ans_hw_GetVlanId()
+**
+**  This function will retrieve the vlan id from the receive descriptor
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - the driver's private data structure
+**              HW_RX_DESCRIPTOR *rxd     - the adapter's receive descriptor
+**
+**  Returns:    u16 - the vlan id (masked off priority)
+*/
+u16
+bd_ans_hw_GetVlanId(BOARD_PRIVATE_STRUCT *bps,
+                                HW_RX_DESCRIPTOR *rxd)
+{
+    u16 VlanId;
+    struct e1000_adapter *adapter = GIGABIT_ADAPTER_STRUCT(bps);
+    
+    DEBUGLOG("bd_ans_hw_GetVlanId: enter\n");
+    
+    // The packet has a tag, so extract it.
+    // the first rev had the special field byte swapped
+    if (adapter->shared.mac_type < e1000_82543)
+    {
+                DEBUGLOG("bd_ans_hw_GetVlanId: getting vlanid on WiseMan\n");
+        VlanId = (BYTE_SWAP_WORD(rxd->special) & 
+                 E1000_RXD_SPC_VLAN_MASK);
+    }
+    else
+    {
+        VlanId = (rxd->special & 
+                 E1000_RXD_SPC_VLAN_MASK);
+    }
+        DEBUGLOG1("bd_ans_hw_GetVlanId: found vlan id %d\n", VlanId); 
+    return VlanId;
+}     
+   
+
+//*********************************************************************
+// Name:         bd_ans_hw_EnableVLAN
+//
+// Description:  Enables IEEE VLAN tagging on the adapter.  Turns on 
+//               VLAN filtering and tag stripping on receive, and enables
+//               tagging on send.
+//               This routine is based on Pat Connor's NDIS code.
+//
+// Author:       Mitch Williams
+//
+// Born on Date: 4/13/1999
+//
+// Arguments:    adapter - Pointer to HSM's adapter Data Space
+//
+// Returns:      ODISTAT    
+//
+// Modification log:
+// Date       Who      Description
+// --------   ---      ------------------------------------------------
+// 3/21/00  kcarlson    Modified for generic ans_hw.c file to share amongst
+//                      all OS who support ANS.
+//*********************************************************************
+BD_ANS_STATUS
+bd_ans_hw_EnableVLAN(BOARD_PRIVATE_STRUCT *bps)
+{
+   u32   DeviceControlReg;
+   u32   VftaReg;
+   u32   VftaIndex;
+   u32   BitInReg;
+   u32   i;
+   u32   TempRctlReg;
+   iANSsupport_t *iANSdata;
+   struct e1000_adapter *adapter = GIGABIT_ADAPTER_STRUCT(bps);
+   iANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+
+   DEBUGLOG("bd_ans_hw_EnableVLAN: enter\n");
+
+   //***************************************************************
+   // If we're asked to enable vlan, but the VlanMode variable is
+   // set to NONE, then just set back to default and return.
+   //***************************************************************
+   if (iANSdata->vlan_mode == IANS_VLAN_MODE_OFF) {
+          DEBUGLOG("bd_ans_hw_EnableVLAN: vlan mode off, enabling priority only\n");
+      return(bd_ans_hw_EnablePriorityRx(bps));
+        }
+
+   //***************************************************************
+   // Read the RX control register.  We'll make changes and write
+   // it back out at the end of the routine.
+   //***************************************************************
+   TempRctlReg = E1000_READ_REG(&adapter->shared, RCTL);
+
+
+   if (iANSdata->tag_mode == IANS_BD_TAGGING_802_3AC)
+   {
+          DEBUGLOG("bd_ans_hw_EnableVLAN: enabling 802.3ac tagging\n");
+      
+      /******************************************************************
+      ** Set the VLAN Ethertype (VET) register, so the hardware knows
+      ** what Ethertype to look for to strip the Q-tag.
+      ******************************************************************/
+      E1000_WRITE_REG(&adapter->shared, VET, QTAG_TYPE);
+   
+      /**************************************************************
+      ** Set VLAN Mode Enable bit in the Control register (CTRL.VME).
+      ** This allows adding/stripping 802.3ac tags.
+      **************************************************************/
+      DeviceControlReg = E1000_READ_REG(&adapter->shared, CTRL);
+      DeviceControlReg |= E1000_CTRL_VME;
+      E1000_WRITE_REG(&adapter->shared, CTRL, DeviceControlReg);
+
+
+      //**********************************************************
+      // Set the VLAN Filter Table Array (VFTA) for the VLANs
+      // that the adapter is a member of.  The VTFA is 128-32 bit
+      // registers that we treat like a 4096 bit array (just like 
+      // the MTA).  A .1q VLAN ID is 12 bits.  The upper 7 bits
+      // will determine the VTFA register and lower 5 bits 
+      // determine what bit in the register should be set.  
+      //**********************************************************
+          if (iANSdata->vlan_filtering_mode == IANS_VLAN_FILTERING_ON) {
+                DEBUGLOG("bd_ans_hw_EnableVLAN: enabling vlan filtering\n");
+        for (i=0; i < iANSdata->num_vlan_filter; i++)
+        {
+                VftaIndex = (iANSdata->VlanID[i] >> 5) & 0x7F;
+                BitInReg = iANSdata->VlanID[i] & 0x1F;  
+
+                // This is Read-Modify-Write operation
+                VftaReg = E1000_READ_REG_ARRAY(&adapter->shared, VFTA, VftaIndex);
+                VftaReg |= (1 << BitInReg);
+                e1000_write_vfta(&adapter->shared, VftaIndex, VftaReg);
+        }
+          }
+
+      //************************************************************
+      // Set the VFE bit in the Receive Control register, and clear
+      // the CFIEN bit.  This enables the VLAN filter, and does not
+      // reject packets with the CFI bit set.  These bits will get
+      // written out when we bring the adapter out of reset.
+#ifndef EXTERAL_RELEASE
+      // Clear the SISLH and ISLE bits to make sure we don't do ISL.
+#endif
+      //************************************************************
+      TempRctlReg |= E1000_RCTL_VFE;
+      TempRctlReg &= ~E1000_RCTL_CFIEN;
+
+   } // end of if (adapter->VlanMode == VLAN_MODE_IEEE)
+   
+
+
+   //***************************************************************
+   // Restore the saved Rctl register, along with our changed bits.
+   //***************************************************************
+
+   E1000_WRITE_REG(&adapter->shared, RCTL, TempRctlReg);
+ 
+   return BD_ANS_SUCCESS;
+}   
+
+//*********************************************************************
+// Name:         bd_ans_hw_DisableTagging
+//
+// Description:  Disables all tagging functions on the adapter.  Turns
+//               off VLAN filtering and tag stripping on receive, and 
+//               disables tagging on send.
+//
+// Author:       Mitch Williams
+//
+// Born on Date: 4/13/1999
+//
+// Arguments:    adapter - Pointer to HSM's adapter Data Space
+//
+// Returns:      ODISTAT
+//
+// Modification log:
+// Date       Who      Description
+// --------   ---      ------------------------------------------------
+// 3/21/00  kcarlson    Modified for generic ans_hw.c file to share amongst
+//                      all OS who support ANS.
+//
+//*********************************************************************
+BD_ANS_STATUS 
+bd_ans_hw_DisableTagging(BOARD_PRIVATE_STRUCT *bps)
+{
+   u32   DeviceControlReg;
+   u32   TempRctlReg;
+   struct e1000_adapter *adapter = GIGABIT_ADAPTER_STRUCT(bps);
+
+    DEBUGLOG("bd_ans_hw_DisableTagging: enter\n");
+    
+   //***************************************************************
+   // Read the RX control register.  We'll make changes and write
+   // it back out at the end of the routine.
+   //***************************************************************
+   TempRctlReg = E1000_READ_REG(&adapter->shared, RCTL);
+
+
+   //***************************************************************
+   // Reset VLAN Mode Enable bit in the Control register (CTRL.VME).
+   // This turns off adding/stripping 802.3ac tags.
+   //***************************************************************
+   DeviceControlReg = E1000_READ_REG(&adapter->shared, CTRL);
+   DeviceControlReg &= ~E1000_CTRL_VME;
+   E1000_WRITE_REG(&adapter->shared, CTRL, DeviceControlReg);
+
+   //**********************************************************
+   // Clear the VLAN Filter Table Array (VFTA).
+   //**********************************************************
+
+	e1000_clear_vfta(&adapter->shared);
+
+   //************************************************************
+   // Clear the VFE and ISLE bits in the Receive Control register.
+   //************************************************************
+
+   TempRctlReg &= ~E1000_RCTL_VFE;
+
+
+   E1000_WRITE_REG(&adapter->shared, RCTL, TempRctlReg);
+  
+   return BD_ANS_SUCCESS;
+}   
+
+//*********************************************************************
+// Name:         bd_ans_hw_EnablePriorityRx
+//
+// Description:  Enables priority tag stripping on the adapter.  Turns on 
+//               VLAN filtering and tag stripping on receive, and enables
+//               tagging on send.
+//               This routine is based on Pat Connor's NDIS code.
+//
+// Author:       Mitch Williams
+//
+// Born on Date: 4/13/1999
+//
+// Arguments:    adapter - Pointer to HSM's adapter Data Space
+//
+// Returns:      ODISTAT    
+//
+// Modification log:
+// Date       Who      Description
+// --------   ---      ------------------------------------------------
+// 3/21/00  kcarlson    Modified for generic ans_hw.c file to share amongst
+//                      all OS who support ANS.
+//
+//*********************************************************************
+BD_ANS_STATUS
+bd_ans_hw_EnablePriorityRx(BOARD_PRIVATE_STRUCT *bps)
+{
+   u32   DeviceControlReg;
+   u32   VftaReg;
+   u32   TempRctlReg;
+   struct e1000_adapter *adapter = GIGABIT_ADAPTER_STRUCT(bps);
+
+   DEBUGLOG("bd_ans_hw_EnablePriorityRx: enter\n");
+   TempRctlReg = E1000_READ_REG(&adapter->shared, RCTL);
+
+
+   /******************************************************************
+   ** Set the VLAN Ethertype (VET) register, so the hardware knows
+   ** what Ethertype to look for to strip the Q-tag.
+   ******************************************************************/
+   E1000_WRITE_REG(&adapter->shared, VET, ETHERNET_IEEE_VLAN_TYPE);
+
+   /**************************************************************
+   ** Set VLAN Mode Enable bit in the Control register (CTRL.VME).
+   ** This allows adding/stripping 802.3ac tags.
+   **************************************************************/
+   DeviceControlReg = E1000_READ_REG(&adapter->shared, CTRL);
+   DeviceControlReg |= E1000_CTRL_VME;
+   E1000_WRITE_REG(&adapter->shared, CTRL, DeviceControlReg);
+
+
+   //**********************************************************
+   // Set the VLAN Filter Table Array (VFTA) to only accept
+   // packets on VLAN 0.  This will cause the hardware to 
+   // reject all packets with valid VLAN tags, and only receive
+   // packets with priority-only information.
+   //**********************************************************
+
+   VftaReg = E1000_READ_REG_ARRAY(&adapter->shared, VFTA, 0);
+   VftaReg |= 1;
+   e1000_write_vfta(&adapter->shared, 0, VftaReg);
+
+   //************************************************************
+   // Set the VFE bit in the Receive Control register, and clear
+   // the CFIEN bit.  This enables the VLAN filter, and does not
+   // reject packets with the CFI bit set.  These bits will get
+   // written out when we bring the adapter out of reset.
+   // Clear the SISLH and ISLE bits to make sure we don't do ISL.
+   //************************************************************
+   TempRctlReg |= E1000_RCTL_VFE;
+   TempRctlReg &= ~E1000_RCTL_CFIEN;
+
+   //***************************************************************
+   // Restore the saved Rctl register, along with our changed bits.
+   //***************************************************************
+
+   E1000_WRITE_REG(&adapter->shared, RCTL, TempRctlReg);
+   return BD_ANS_SUCCESS;
+}   
+#endif 
+
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans_hw.h linux/drivers/net/e1000/ans_hw.h
--- ../ia64/linux/drivers/net/e1000/ans_hw.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans_hw.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,97 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* these are the hardware specific (not OS specific) routines needed by the 
+** bd_ans module
+*/
+#define BD_ANS_HW_IS_SERVER(bps) \
+(bps->device_id == E1000_DEV_ID_82544GC_COPPER ? BD_ANS_FALSE : \
+(bps->device_id == E1000_DEV_ID_82540EM ? BD_ANS_FALSE : BD_ANS_TRUE))
+
+#define BD_ANS_HW_AVAILABLE_SPEEDS(bps) bd_ans_hw_available_speeds(BD_ANS_DRV_PHY_ID(bps))
+
+/* function prototypes */
+extern u32 bd_ans_hw_available_speeds(u32 phyID);
+#ifdef IANS_BASE_VLAN_TAGGING
+extern BD_ANS_BOOLEAN bd_ans_hw_IsQtagPacket(BOARD_PRIVATE_STRUCT *bps, HW_RX_DESCRIPTOR *rxd);
+extern BD_ANS_STATUS bd_ans_hw_InsertQtagHW(BOARD_PRIVATE_STRUCT *bps, HW_TX_DESCRIPTOR *txd, u16 *vlanid);
+extern u16 bd_ans_hw_GetVlanId(BOARD_PRIVATE_STRUCT *bps,
+                                                                  HW_RX_DESCRIPTOR *rxd);
+extern BD_ANS_STATUS bd_ans_hw_EnableVLAN(BOARD_PRIVATE_STRUCT *Adapter);
+extern BD_ANS_STATUS bd_ans_hw_DisableTagging(BOARD_PRIVATE_STRUCT *Adapter);
+extern BD_ANS_STATUS bd_ans_hw_EnablePriorityRx(BOARD_PRIVATE_STRUCT *Adapter);
+#endif
+ 
+
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans_interface.h linux/drivers/net/e1000/ans_interface.h
--- ../ia64/linux/drivers/net/e1000/ans_interface.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans_interface.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,93 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  ans_interface.h                                       *
+*                                                                     *
+* Abstract: this file contains ANS related header files               *    
+*                                                                     *
+* Environment:  This file is intended to be specific to the Linux     *
+*               operating system.                                     *
+*                                                                     *
+**********************************************************************/
+
+#include "base_comm.h"
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans_os.c linux/drivers/net/e1000/ans_os.c
--- ../ia64/linux/drivers/net/e1000/ans_os.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans_os.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,590 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  ans_os.h                                              *
+*                                                                     *
+* Abstract: iANS routines specific to linux                           *
+*                                                                     *
+* Environment:  This file is intended to be specific to the Linux     *
+*               operating system.                                     *
+*                                                                     *
+**********************************************************************/
+
+#include "ans_driver.h"
+#include "ans_os.h"
+#include <asm/unaligned.h>
+
+void (*ans_notify)(device_t *dev, int ind_type) = NULL;
+
+BD_ANS_STATUS bd_ans_os_SetCallback(BOARD_PRIVATE_STRUCT *bps,
+    IANS_BD_PARAM_HEADER *header)
+{
+    IANS_BD_ANS_SET_CB *acb = (IANS_BD_ANS_SET_CB *) header;
+    ans_notify = acb->notify;
+    return BD_ANS_SUCCESS;
+}
+
+/* bd_ans_os_Ioctl()
+**
+**  This function will pull the IANS structures out of the ifr and pass
+**  them to the generic ANS module for processing.
+**
+**  Arguments:  struct device *dev - pointer to the adapters device structure
+**              struct ifreq *ifr - the request structure passed down from
+**                                  upper layers.
+**              int cmd - the number of the IOC to process.  This function
+**                        will only process the IANS_BASE_SIOC command.
+**
+**  Returns:    int - 0 if successful, non-zero otherwise.
+*/
+int
+bd_ans_os_Ioctl(device_t *dev, struct ifreq *ifr, int cmd)
+{
+    /* get the private data structure from the dev struct */
+    BOARD_PRIVATE_STRUCT *bps = dev->priv;    
+    IANS_BD_PARAM_HEADER *header =  (IANS_BD_PARAM_HEADER *)ifr->ifr_data;
+    iANSsupport_t *iANSdata;
+    BD_ANS_STATUS status;
+    
+    /* get a pointer to the ANS data struct from the ifr */
+    iANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+
+    //DEBUGLOG("bd_ans_os_Ioctl: enter\n");
+
+    /* switch on the command */
+    switch(cmd) {
+    case IANS_BASE_SIOC:
+        status = bd_ans_ProcessRequest(bps, iANSdata, header);
+        if (status == BD_ANS_SUCCESS)
+            return 0;
+        /* some problem occured, return error value */
+        return -EAGAIN;
+    default:
+        return -EOPNOTSUPP;
+    }
+    return 0;
+}    
+
+
+/* bd_ans_os_Transmit()
+**
+**  This function will get the required structures from the skb and
+**  pass them to the generic bd_ans_Transmit routine for processing.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - pointer to the boards 
+**                                          private data structure
+**              HW_TX_DESCRIPTOR *txd - pointer to the hardware 
+**                                      specific tx descriptor
+**              struct sk_buff *skb - pointer to the skb which
+**                                    describes this packet.
+**
+**  Returns:    int - 0 if successful, non-zero otherwise.
+*/
+int 
+bd_ans_os_Transmit( BOARD_PRIVATE_STRUCT *bps, 
+    HW_TX_DESCRIPTOR *txd,
+    struct sk_buff **skb )
+{
+    UINT16 vlan_id;     /* don't know if I really need this */
+    IANS_ATTR_HEADER *attr_head = iANSGetTransmitAttributeHeader(*skb);
+    iANSsupport_t *iANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+    
+    /* nothing special to do unless we are in attributed mode */
+    
+    /* call the bd_ans_Transmit routine to setup our frame for transmit */
+    if (iANSdata->attributed_mode) {
+
+        /* Check to identify misrouted frames */
+        /* An explicit check would not have been backward compatible */
+        if ((char *)(attr_head->pFirstTLV) != ( (char *)attr_head + sizeof(IANS_ATTR_HEADER) )) {
+            //printk("%s warning frame does not contain TLV data",(*skb)->dev->name);
+            return 1; // This is not an iANS attributed packet!
+        }
+
+        if (bd_ans_Transmit(bps,
+            iANSdata,
+            attr_head->pFirstTLV,
+            txd,
+            skb,
+            &vlan_id) == BD_ANS_FAILURE)
+            return 1;                                                
+        
+    }        
+    return 0;
+}        
+
+
+
+/* bd_ans_os_Receive()
+**
+**  This function will determine if the adapter is configured
+**  for attributed mode, and call the generic ans routine
+**  to add any needed tlvs if we are configured to do so.
+**  It will also check the routing_mode flag to determine
+**  if we need to check to see if we should route frames
+**  to ANS.
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - pointer to private data struct
+**              HW_RX_DESCRIPTOR *rxd - pointer to hw specific frame descriptr
+**              struct sk_buff *skb - the OS descriptor for this frame
+**
+**  Returns:    int - 0 if successful, non-zero otherwise
+*/
+int
+bd_ans_os_Receive(BOARD_PRIVATE_STRUCT *bps,
+    HW_RX_DESCRIPTOR *rxd,
+    struct sk_buff *skb )
+{
+    UINT32 length;
+    iANSsupport_t *iANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+    IANS_ATTR_HEADER *attr_head = iANSGetReceiveAttributeHeader(skb);
+    struct sk_buff *dummy_tlv_ptr;
+    device_t *dev = DRIVER_DEV_FIELD(bps);
+
+    DEBUGLOG("bd_ans_os_Receive: enter\n");
+
+    /* if we are in attributed mode, we need to fill out tlv structures */
+    if (iANSdata->attributed_mode) {
+        DEBUGLOG("bd_ans_os_Receive: in attributed mode\n");
+        /* setup the TLV pointer first */
+        put_unaligned((Per_Frame_Attribute_Header *)
+                      (((UCHAR *)attr_head) + sizeof(IANS_ATTR_HEADER)),
+                      &(attr_head->pFirstTLV));
+        
+        if (bd_ans_Receive(bps,
+            iANSdata,
+            rxd,
+            skb->data,
+            skb,
+            &dummy_tlv_ptr, /* this isn't used by Linux */
+            &length) == BD_ANS_FAILURE) {
+            DEBUGLOG("bd_ans_os_Receive: Failed bd_ans_Receive\n");
+            return 1;   
+        }
+    } else {
+        put_unaligned(NULL, &(attr_head->pFirstTLV));
+    }
+    
+    /* need to check to see if we are routing rx packets to ANS. If this
+     * has been setup, then we need to replace the existing protocol
+     * with the ANS protocol and store the original at the head of
+     * the skb
+     */
+    if (iANSdata->routing_mode == IANS_ROUTING_ON) {
+        DEBUGLOG("bd_ans_os_Receive: In routing mode\n");
+        /* set the protocol here. the eth_type_trans routine
+         * changes the data pointer and so we want to do that after
+         * we have done any stripping of the packet 
+         */
+        put_unaligned(eth_type_trans(skb, dev),
+                      &(attr_head->OriginalProtocol));
+        skb->protocol = IANS_FRAME_TYPE;
+    } else {
+        skb->protocol = eth_type_trans(skb, dev);
+    }
+    return 0;
+}    
+
+
+
+/* bd_ans_os_Watchdog()
+**
+**  This function will check on the status fields of the ANS
+**  support structure and see if the status has changed since
+**  the last time that it was checked.  If it has changed,
+**  then we need to alert the ANS protocol somehow.(TBD)
+**
+**  Arguments:  struct device *dev - pointer to the device structure
+**              BOARD_PRIVATE_STRUCT *bps - the driver's private data struct
+**
+**  Returns: void
+*/
+void
+bd_ans_os_Watchdog(device_t *dev, BOARD_PRIVATE_STRUCT *bps)
+{
+    IANS_BD_PARAM_STATUS current_status;        
+    iANSsupport_t *piANSdata = ANS_PRIVATE_DATA_FIELD(bps);
+
+
+    /* check ans communication protocol.  If we are not up, there is
+     * nothing to do.
+     */
+    if ((piANSdata->iANS_status == IANS_COMMUNICATION_DOWN)
+        || (piANSdata->reporting_mode == IANS_STATUS_REPORTING_OFF))
+        return;
+    
+    /* update the driver's status */
+    bd_ans_drv_UpdateStatus(bps);
+    
+    /* fill out the current status */
+    bd_ans_FillStatus(bps, ANS_PRIVATE_DATA_FIELD(bps), &current_status);
+    
+    /* compare the status to the last status update.  If they are different,
+     * we need to send an indication.
+     */
+    /* Compare current status against previous one: if equal, just return */
+    if (BD_ANS_BCMP((UCHAR *)&piANSdata->prev_status, (UCHAR *)&current_status,
+                    sizeof(IANS_BD_PARAM_STATUS)) == BD_ANS_TRUE) {
+
+        return;
+    }
+    
+    /* if we are here, we need to send a status change notification */
+    /// TBD - need to get indication definition from ans_base_comm.h 
+    
+    /* as far as I can tell, since it hasn't been defined yet,
+     * the thing to do here is to call netdev_state_change(dev).
+     * this is a synchronous call to a registered chain of who knows
+     * how many protocols, so it seems like this wouldn't be a very good idea...
+     */
+    BD_ANS_BCOPY((UCHAR *)&piANSdata->prev_status, (UCHAR *)&current_status,
+                 sizeof(IANS_BD_PARAM_STATUS));
+
+    DEBUGLOG("bd_ans_os_Watchdog: sending notification\n");
+    if (ans_notify)
+        ans_notify(dev, IANS_IND_EXT_STATUS_CHANGE);
+    DEBUGLOG("bd_ans_os_watchdog: done send\n");
+
+    return;
+}
+                 
+#ifdef IANS_BASE_VLAN_TAGGING 
+/* bd_ans_os_InsertQtagSW()
+**
+**  This function will insert the IEEE vlan id into the data portion of the 
+**  packet.  
+**
+**  Arguments:  BOARD_PRIVATE_STRUCT *bps - pointer to the boards private data
+**                                          structure
+**              struct sk_buff **skb - pointer to a pointer to the sk_buff
+**                                     which describes this packet
+**              UINT16 *vlanid - pointer to the vlan id to insert
+**
+**  Returns:    BD_ANS_STATUS - BD_ANS_FAILURE if a new skb needed to be 
+**                              allocated but could not, BD_ANS_SUCCESS
+**                              otherwise
+*/    
+BD_ANS_STATUS
+bd_ans_os_InsertQtagSW(BOARD_PRIVATE_STRUCT *bps, struct sk_buff **skb, UINT16 *vlan_id)
+{
+    UINT32 count;
+    UCHAR *from;
+    UCHAR *to;
+    peth_vlan_header_t peth_vlan_header;
+    struct sk_buff *new_skb;
+    
+    DEBUGLOG("bd_ans_os_InsertQtagSW: enter\n");
+    /* we can be guarenteed that there is headroom here because we are
+     * blowing away the old TLV list since we don't need it anymore.
+     */
+    if (skb_headroom(*skb) < sizeof(x8021Q_tag_t) ) {
+        DEBUGLOG("bd_ans_os_InsertQtagSW: inserting vlan into headroom\n");
+        /* reallocate the skb */
+        new_skb = skb_realloc_headroom((*skb), sizeof(x8021Q_tag_t));
+        if (new_skb == NULL)
+            return BD_ANS_FAILURE;
+            
+        /* return the old one */
+        dev_kfree_skb(*skb);
+        *skb = new_skb;
+    }
+    
+    
+    /* move the da/sa out of the way */
+    from = (*skb)->data;
+    to = ((UCHAR *)(*skb)->data) - sizeof(x8021Q_tag_t);
+    for (count = 0; count < (ETHERNET_ADDRESS_LENGTH*2); count++)
+        *to++ = *from++;
+    
+    /* adjust the data pointer to new spot */
+    skb_push(*skb,sizeof(x8021Q_tag_t)); 
+    
+    /* insert the vlan id in the proper place */
+    peth_vlan_header = (peth_vlan_header_t)(*skb)->data;
+    peth_vlan_header->Qtag.EtherType = htons(QTAG_TYPE);
+    peth_vlan_header->Qtag.VLAN_ID = htons(*vlan_id);
+    return BD_ANS_SUCCESS;        
+}
+
+
+/* bd_ans_os_StripQtagSW()
+**
+**  This routine will strip a IEEE tag out of the data area of the 
+**  skb.  We assume that the data pointer is still pointing to the
+**  raw ethernet data (i.e. it better be!)
+**
+**  Arguments:  struct sk_buff *skb - pointer to the sk_buff which
+**                                    describes this packet
+**  Returns:    void - you get what you asked for, no checks to see
+**                     if it is a valid vlan packet.
+*/
+void
+bd_ans_os_StripQtagSW(struct sk_buff *skb)
+{
+    unsigned char *to;
+    unsigned char *from;
+    eth_vlan_header_t *header;
+    
+    header = (eth_vlan_header_t *) skb->data;
+    
+    /* start from the last byte of the source address and copy to
+     * the last byte of the qtag.
+     */
+    from = &(header->eth_src[5]);
+    to = from + sizeof(x8021Q_tag_t);
+    while (from >= (unsigned char *)header)
+        *to-- = *from--;
+        
+    /* reset the data to 4 bytes above what it was. */  
+    skb_pull(skb, sizeof(x8021Q_tag_t));      
+}
+
+
+#endif
+
+
+/* bd_ans_os_AllocateTLV()
+**
+**  This function will just set the tlv pointer to the proper place
+**  to begin copying TLV information.  Under Linux, this function
+**  doesn't do much, it is more complex under other OS.
+**
+**  struct sk_buff *frame - pointer to the sk_buff which describes
+**                          the frame to be passed up.
+**  struct sk_buff **tlv  - address of the sk_buff which will contain
+**                          the tlv info.
+**  
+**  Returns:  BD_ANS_SUCCESS - always succeeds for now.
+*/
+BD_ANS_BOOLEAN
+bd_ans_os_AllocateTLV(struct sk_buff *frame, struct sk_buff **tlv)
+{
+    /* since under linux we have our tlv at the head of the
+     * frame data, we use the same sk_buff for the tlv as
+     * the frame data and do not need to do any new allocation 
+     */
+    *tlv = frame;
+    return BD_ANS_SUCCESS;
+}
+
+
+
+/* bd_ans_os_AttributeFill()
+**
+**  This function will serve as a translation layer between the generic
+**  attribute fill routine and the OS specific data structures.  Tell
+**  the generic routines where to fill in the TLV information.
+**
+**  Arguments:  iANS_Attribute_ID attr_id - the id of the attribute
+**              struct sk_buff *skb - the skb which describes the tlv list
+**              UINT32 prev_tlv_length - this will tell the routine how 
+**                                       many bytes to skip to avoid 
+**                                       writing over previous TLV information
+**              void *data             - pointer any associated values that
+**                                       belong to this TLV.
+**  Returns:    UINT32 - the length of the new TLV
+*/ 
+UINT32
+bd_ans_os_AttributeFill(iANS_Attribute_ID attr_id, 
+    struct sk_buff *skb, 
+    UINT32 prev_tlv_length,
+    void *data)
+{
+    int tlv_length = 0;
+    Per_Frame_Attribute_Header *header;
+
+    /* we need to skip any previously filled in attributes so that we 
+     * don't blow them away. 
+     */
+    header = iANSGetReceiveAttributeHeader(skb)->pFirstTLV;
+    header = (Per_Frame_Attribute_Header *)(((UINT8 *)header) + prev_tlv_length);
+    tlv_length = bd_ans_AttributeFill(attr_id, header, data);
+    /* we don't adjust the len field because the len is in relation to the 
+     * frame data only.
+     */
+
+    return tlv_length;
+}    
+ 
+ 
+
+/* bd_ans_os_ReserveSpaceForANS()
+**
+** ANS requires that we have space in the skb for the following:
+** 
+**  pointer to TLV list
+**  old protocol id
+**  TLV list with at most 2 TLVs for now
+** 
+**  This function abstracts the call to skb_reserve so that if the
+**  amount of space that needs to be reserved changes, this is 
+**  only needed to be updated in the shared code and not in each 
+**  individual driver.
+**
+**  Arguments:  struct sk_buff *skb - the sk_buff which is being
+**                                    adjusted.
+**
+**  Returns:    void.
+*/  
+void 
+bd_ans_os_ReserveSpaceForANS(struct sk_buff *skb)
+{
+  /// (??? what is the best way to
+  /// handle this variable number of tlv's? Perhaps ANS can set this 
+  /// number for us in a query or something, or as a define in the 
+  /// base_comm.h file...)
+    skb_reserve(skb, BD_ANS_INFO_SIZE);
+}
+       
+BD_ANS_STATUS bd_ans_os_ProcessRequest(BOARD_PRIVATE_STRUCT *bps, 
+                                       iANSsupport_t *iANSdata,
+                                       IANS_BD_PARAM_HEADER *header)
+{
+    switch (header->Opcode) {
+    case IANS_OP_ANS_SET_CB:
+        DEBUGLOG("bd_ans_ProcessRequest: ans set callbacks\n");
+        return (bd_ans_os_SetCallback(bps, header));
+    default:
+        DEBUGLOG1("bd_ans_os_ProcessRequest: unknown op code = %d\n", header->Opcode);
+        return (BD_ANS_FAILURE);
+    }
+}
+
+BD_ANS_STATUS bd_ans_os_ExtendedGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                              iANSsupport_t *iANSdata,
+                                              IANS_BD_PARAM_HEADER *header)
+{
+    ((IANS_BD_PARAM_EXT_CAP *)header)->BDAllAvailableRouting = 
+        IANS_ROUTING_NOT_SUPPORTED;      
+    /* get routing capabilities */
+    if (BD_ANS_OS_CAN_ROUTE_RX(bps) == BD_ANS_TRUE) {
+        ((IANS_BD_PARAM_EXT_CAP *)header)->BDAllAvailableRouting |=
+            IANS_ROUTING_RX_PROTOCOL;
+    } 
+    ((IANS_BD_PARAM_EXT_CAP *)header)->BDFlags = iANSdata->flags.bd_flags;
+
+    return BD_ANS_SUCCESS;        
+}
+
+BD_ANS_STATUS bd_ans_os_ExtendedSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                        iANSsupport_t *iANSdata,
+                                        IANS_BD_PARAM_HEADER *header)
+{
+    IANS_BD_PARAM_EXT_SET_MODE *request = (IANS_BD_PARAM_EXT_SET_MODE *)header;
+    if (request->BDIansRoutingMode & IANS_ROUTING_RX_PROTOCOL)
+        iANSdata->routing_mode = IANS_ROUTING_ON;
+    else
+        iANSdata->routing_mode = IANS_ROUTING_OFF;
+        
+   return BD_ANS_SUCCESS;
+}
+
+BD_ANS_STATUS bd_ans_os_ActivateFastPolling(BOARD_PRIVATE_STRUCT *bps,
+                                            iANSsupport_t *iANSdata)
+{
+    /* initialize the previous status with the current status so
+     * that we don't send any bogus status change indications
+     */
+    bd_ans_drv_UpdateStatus(bps);
+    bd_ans_FillStatus(bps, iANSdata, &(iANSdata->prev_status));
+
+    /* tell the driver that we need to start checking the
+     * status
+     */    
+    iANSdata->timer_id = bd_ans_drv_StartWatchdog(bps);
+    
+    /* a non-zero timer_id indicates that the driver has
+     * started the Watchdog.
+     */
+    if (iANSdata->timer_id == 0)
+        return BD_ANS_FAILURE;
+        
+    return BD_ANS_SUCCESS; 
+}
+
+
+BD_ANS_STATUS bd_ans_os_GetAllCapabilities(BOARD_PRIVATE_STRUCT *bps,
+                                            iANSsupport_t *iANSdata)
+{
+    iANSdata->flags.bd_flags = BD_ANS_HW_FLAGS(bps);
+    return BD_ANS_SUCCESS;
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/ans_os.h linux/drivers/net/e1000/ans_os.h
--- ../ia64/linux/drivers/net/e1000/ans_os.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/ans_os.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,233 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  ans_os.h                                              *
+*                                                                     *
+* Abstract: this file contains OS specific defines                    *
+*                                                                     *
+* Environment:  This file is intended to be specific to the Linux     *
+*               operating system.                                     *
+*                                                                     *
+**********************************************************************/
+
+
+#ifndef _ANS_OS_H
+#define _ANS_OS_H
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+
+#include <linux/version.h>
+
+/* define the types used for the bd_ans module that are
+ * os specific 
+ */
+#ifndef UINT32
+#define UINT32 uint32_t
+#endif
+
+#ifndef VOID
+#define VOID void
+#endif 
+
+#ifndef UCHAR 
+#define UCHAR  unsigned char
+#endif
+
+#ifndef UINT8
+#define UINT8 uint8_t
+#endif
+
+#ifndef UINT16
+#define UINT16 uint16_t
+#endif
+ 
+
+/* In 2.3.14 the device structure was renamed to net_device */
+#ifndef _DEVICE_T
+#define _DEVICE_T
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,14) )
+typedef struct device device_t;
+#else
+typedef struct net_device device_t;
+#endif
+#endif
+
+/* debug macros for this os */
+#ifdef DEBUG_ANS
+#define DEBUGLOG(s) printk(s);
+#define DEBUGLOG1(s, arg) printk(s, arg);
+#define DEBUGLOG2(s, arg1, arg2) printk(s, arg1, arg2);
+#else
+#define DEBUGLOG(s) 
+#define DEBUGLOG1(s, arg) 
+#define DEBUGLOG2(s, arg1, arg2) 
+#endif
+
+
+/* definition of ethernet frame */
+#define OS_DATA struct sk_buff 
+
+/* how we report line speed for this os */
+#define BD_ANS_10_MBPS  10
+#define BD_ANS_100_MBPS 100
+#define BD_ANS_1000_MBPS 1000
+
+/* how we report duplex for this os */
+#define BD_ANS_DUPLEX_FULL 2
+#define BD_ANS_DUPLEX_HALF 1
+
+/* os specific capabilities */
+#define BD_ANS_OS_STOP_PROM_SUPPORT BD_ANS_FALSE
+#define BD_ANS_OS_MAC_ADDR_SUPPORT BD_ANS_TRUE
+#define BD_ANS_OS_CAN_ROUTE_RX(bps)  BD_ANS_TRUE
+#define BD_ANS_OS_CAN_ROUTE_EVENT(bps)   BD_ANS_FALSE
+
+#include <linux/module.h>
+#define BD_ANS_DRV_LOCK   MOD_INC_USE_COUNT
+#define BD_ANS_DRV_UNLOCK MOD_DEC_USE_COUNT
+
+/* macro to calculate maximum space needed to reserve 
+** at head of skb for ANS extra info.
+*/
+#ifdef IANS_BASE_VLAN_TAGGING
+#define BD_ANS_INFO_SIZE (sizeof(IANS_ATTR_HEADER) + \
+                                                  sizeof(VLAN_ID_Per_Frame_Info) + \
+                                                  sizeof(Last_Attribute))
+#else
+#define BD_ANS_INFO_SIZE (sizeof(IANS_ATTR_HEADER) + \
+                          sizeof(Last_Attribute))
+#endif
+
+/* function prototypes */
+extern void bd_ans_os_ReserveSpaceForANS(struct sk_buff *skb);
+extern UINT32 bd_ans_os_AttributeFill(iANS_Attribute_ID attr_id, 
+                                      struct sk_buff *skb, 
+                                      UINT32 prev_tlv_length,
+                                      void *data);
+extern BD_ANS_BOOLEAN bd_ans_os_AllocateTLV(struct sk_buff *frame, 
+                                            struct sk_buff **tlv);
+
+#ifdef IANS_BASE_VLAN_TAGGING                                            
+extern void bd_ans_os_StripQtagSW(struct sk_buff *skb);
+extern BD_ANS_STATUS bd_ans_os_InsertQtagSW(BOARD_PRIVATE_STRUCT *bps, 
+                                            struct sk_buff **skb, 
+                                            UINT16 *vlan_id);
+#endif
+
+extern void bd_ans_os_Watchdog(device_t *dev, 
+                               BOARD_PRIVATE_STRUCT *bps);
+extern int bd_ans_os_Receive(BOARD_PRIVATE_STRUCT *bps,
+                             HW_RX_DESCRIPTOR *rxd,
+                             struct sk_buff *skb );
+extern int bd_ans_os_Transmit(BOARD_PRIVATE_STRUCT *bps, 
+                              HW_TX_DESCRIPTOR *txd,
+                              struct sk_buff **skb );
+extern int bd_ans_os_Ioctl(device_t *dev, 
+                           struct ifreq *ifr, 
+                           int cmd);                                      
+
+extern void (*ans_notify)(device_t *dev, int ind_type);
+
+extern BD_ANS_STATUS bd_ans_os_SetCallback(BOARD_PRIVATE_STRUCT *bps,
+                                           IANS_BD_PARAM_HEADER *header);
+
+extern BD_ANS_STATUS bd_ans_os_ExtendedSetMode(BOARD_PRIVATE_STRUCT *bps,
+                                               iANSsupport_t *iANSdata,
+                                               IANS_BD_PARAM_HEADER *header);   
+extern BD_ANS_STATUS bd_ans_os_ExtendedGetCapability(BOARD_PRIVATE_STRUCT *bps,
+                                                     iANSsupport_t *iANSdata,
+                                                     IANS_BD_PARAM_HEADER *header);
+extern BD_ANS_STATUS bd_ans_os_ProcessRequest(BOARD_PRIVATE_STRUCT *bps, 
+                                              iANSsupport_t *iANSdata,
+                                              IANS_BD_PARAM_HEADER *header);
+extern BD_ANS_STATUS bd_ans_os_ActivateFastPolling(BOARD_PRIVATE_STRUCT *bps,      
+                                                   iANSsupport_t *iANSdata);
+
+extern BD_ANS_STATUS bd_ans_os_GetAllCapabilities(BOARD_PRIVATE_STRUCT *bps,
+                                                  iANSsupport_t *iANSdata);
+#endif
+
+
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/base_comm.h linux/drivers/net/e1000/base_comm.h
--- ../ia64/linux/drivers/net/e1000/base_comm.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/base_comm.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,730 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+*                                                                     *
+* INTEL CORPORATION                                                   *
+*                                                                     *
+* This software is supplied under the terms of the license included   *
+* above.  All use of this driver must be in accordance with the terms *
+* of that license.                                                    *
+*                                                                     *
+* Module Name:  base_comm.h                                           *
+*                                                                     *
+* Abstract: iANS to base communication defines                        *
+*                                                                     *
+* Environment:                                                        *
+*                                                                     *
+**********************************************************************/
+
+#ifndef _IANS_BASE_COMM_H
+#define _IANS_BASE_COMM_H
+
+
+#include <linux/sockios.h> /* for SIOCDEVPRIVATE */
+
+#define u16 __u16
+#define u32 __u32
+#define u8  __u8
+
+
+/* Make sure all communications parties use the same packing mode
+ * for the shared structures. */
+#ifdef __ia64__
+#pragma pack(8)
+#else
+#pragma pack(4)
+#endif /*  __ia64__ */ 
+
+#ifdef _IANS_MAIN_MODULE_C_
+#define IntOrExt
+#else
+#define IntOrExt extern
+#endif
+
+
+/*--------------------------------------------------------------------*
+ | PRIMITIVES baring iANS communications
+ | =====================================
+ *--------------------------------------------------------------------*/
+
+/* The proprietary iANS IOCTL code */
+#define IANS_BASE_SIOC          (SIOCDEVPRIVATE+1)
+/* The proprietary event notifications code */
+#define IANS_BASE_NOTIFY        (('S'<<24)|('N'<<16)|('A'<<8)|('i')) /* "iANS" */
+
+
+/*------------------------------------------------------------------*
+|   Communication version : 
+|   this is the version of the communication protocol described in 
+|   this header file. 
+|   This information will be passed in the IANS_BD_IDENTIFY ioctl 
+*------------------------------------------------------------------*/
+
+/* iANS's communications version */
+#define IANS_COMM_VERSION_MAJOR (u16)1
+#define IANS_COMM_VERSION_MINOR (u16)0
+
+/* Base driver's version */ 
+#define IANS_BD_COMM_VERSION_MAJOR (u16)1
+#define IANS_BD_COMM_VERSION_MINOR (u16)0
+
+#define IANS_SIGNATURE_LENGTH 80
+
+IntOrExt char IntelCopyrightString[IANS_SIGNATURE_LENGTH]
+#ifdef _IANS_MAIN_MODULE_C_
+= "Intel Copyright 1999, all rights reserved\n";
+#else
+;
+#endif
+
+
+
+
+/* ================================================================== *
+ *                                                                    *
+ *                               IOCTLs                               *
+ *                                                                    *
+ * ================================================================== */
+
+
+
+/*--------------------------------------------------------------------*
+ |                 Proprietary Opcodes
+ *--------------------------------------------------------------------*/
+
+typedef enum _IANS_BASE_OPCODE
+{
+
+    /* ----------  Basic Extension Commands  ---------- */
+    IANS_OP_BD_IDENTIFY,          /* Identify BD to make sure it 
+                                     supports iANS comm.*/
+    /* BD fills Struct:  IANS_BD_PARAM_IDENTIFY */
+    IANS_OP_BD_DISCONNECT,        /* Tell the BD that iANS is about to unload */
+    IANS_OP_EXT_GET_CAPABILITY,   /* Get extended capabilities */
+    /* BD fills struct: _IANS_BD_PARAM_EXT_CAP */
+    IANS_OP_EXT_SET_MODE,         /* Set extended capabilities */
+    /* iANS fills struct: _IANS_BD_PARAM_EXT_SET_MODE */
+    IANS_OP_EXT_GET_STATUS,               /* Get status from base driver */
+    /* BD fills status struct: IANS_BD_IOC_PARAM_STATUS */
+
+
+    IANS_OP_ANS_SET_CB, /* pass ans function's pointers to base */
+
+#ifdef IANS_BASE_ADAPTER_TEAMING
+    /* ----------  Adapter Teaming Commands  ---------- */
+    IANS_OP_IAT_FIRST=0x0100,     /* Skip over reserved area */
+    /* There are no commands specific to adapter teaming */
+    /* Capabilities are included in "Extended capabilities" */
+#endif /* IANS_BASE_ADAPTER_TEAMING */
+
+#ifdef IANS_BASE_VLAN_TAGGING
+    /* ----------  VLan Tagging Commands  ---------- */
+    IANS_OP_ITAG_FIRST=0x0200,          /* Skip over reserved area */
+    IANS_OP_ITAG_GET_CAPABILITY,        /* Get tagging capabilities */
+    /* BD fills struct: IANS_BD_PARAM_ITAG_CAP */
+    IANS_OP_ITAG_SET_MODE,                      /* None/ISL/802.3ac */
+    /* IANS fills struct: IANS_BD_PARAM_ITAG_SET_MODE */
+#endif /* IANS_BASE_VLAN_TAGGING */
+
+#ifdef IANS_BASE_VLAN_ID
+    /* ----------  VLan ID Commands  ---------- */
+    IANS_OP_IVLAN_ID_FIRST=0x0300,       /* Skip over reserved area */
+    IANS_OP_IVLAN_ID_GET_CAPABILITY, /* Get VLan ID capabilities */
+    /* BD fills struct: IANS_BD_PARAM_IVLAN_CAP */
+    IANS_OP_IVLAN_ID_SET_MODE,           /* Set Vlan ID mode */
+    /* iANS fills struct: IANS_BD_PARAM_IVLAN_SET_MODE*/
+    IANS_OP_IVLAN_ID_SET_TABLE,          /* ID list */
+    /* iANS fills struct: IANS_BD_PARAM_IVLAN_TABLE */
+#endif /* IANS_BASE_VLAN_ID */
+
+    /* ---------- */
+    IANS_OP_COMMA       /* Dummy to satisfy last ifdef'ed commma */
+
+} IANS_BASE_OPCODE, *PIANS_BASE_OPCODE;
+
+
+/*--------------------------------------------------------------------*
+ |                Enumerated types for field values
+ *--------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------*
+ |             Enumerated types for Status struct field values
+ *--------------------------------------------------------------------*
+ | In every field, if a base driver doesn't support a valid indication 
+ | on that field it should set it to zero. This value was picked in 
+ | every enumerated type to denote "not supported" value.
+ *--------------------------------------------------------------------*/
+
+
+/* Used in IANS_BD_PARAM_STATUS.LinkStatus */
+typedef enum _IANS_BD_LINK_STATUS 
+{
+    IANS_STATUS_LINK_NOT_SUPPORTED = 0,
+    IANS_STATUS_LINK_OK,
+    IANS_STATUS_LINK_FAIL
+} IANS_BD_LINK_STATUS, *PIANS_BD_LINK_STATUS;
+
+/* Used in IANS_BD_PARAM_STATUS.Duplex */
+typedef enum _IANS_BD_DUPLEX_STATUS 
+{
+    IANS_STATUS_DUPLEX_NOT_SUPPORTED = 0,
+    IANS_STATUS_DUPLEX_HALF,
+    IANS_STATUS_DUPLEX_FULL
+} IANS_BD_DUPLEX_STATUS, *PIANS_BD_DUPLEX_STATUS;
+
+/* Used in IANS_BD_PARAM_STATUS.LinkSpeed */
+
+typedef enum _IANS_BD_LINK_SPEED {
+    IANS_STATUS_LINK_SPEED_NOT_SUPPORTED = 0,
+    IANS_STATUS_LINK_SPEED_1MBPS = 0x1,
+    IANS_STATUS_LINK_SPEED_10MBPS = 0x2,
+    IANS_STATUS_LINK_SPEED_100MBPS = 0x4,
+    IANS_STATUS_LINK_SPEED_1000MBPS = 0x8
+}IANS_BD_LINK_SPEED, *PIANS_BD_LINK_SPEED;
+
+
+/* Used in IANS_BD_PARAM_STATUS.HardwareFailure */
+typedef enum _IANS_BD_HW_STATUS {
+    IANS_STATUS_HARDWARE_NOT_SUPPORTED = 0,
+    IANS_STATUS_HARDWARE_OK,
+    IANS_STATUS_HARDWARE_FAILURE
+} IANS_BD_HW_STATUS, *PIANS_BD_HW_STATUS;
+
+/* Used in IANS_BD_PARAM_STATUS.DuringResetProcess */
+typedef enum _IANS_BD_RESET_STAGE {
+    IANS_STATUS_RESET_NOT_SUPPORTED =0,
+    IANS_STATUS_NOT_DURING_RESET,
+    IANS_STATUS_DURING_RESET
+} IANS_BD_RESET_STAGE, *PIANS_BD_RESET_STAGE;
+
+/* Used in IANS_BD_PARAM_STATUS.Suspended */
+typedef enum _IANS_BD_SUSPENDED_STAGE {
+    IANS_STATUS_SUSPENDED_NOT_SUPPORTED =0,
+    IANS_STATUS_NOT_SUSPENDED,
+    IANS_STATUS_SUSPENDED
+} IANS_BD_SUSPENDED_STAGE, *PIANS_BD_SUSPENDED_STAGE;
+
+/* Rx and event notification routing mechanisms (bitmask ready) */
+typedef enum _IANS_BD_ROUTING {
+    IANS_ROUTING_NOT_SUPPORTED  = 0x00,
+    IANS_ROUTING_RX_PROTOCOL    = 0x01,
+} IANS_BD_ROUTING, *PIANS_BD_ROUTING;
+
+typedef enum _IANS_BD_HOT_PLUG_STATUS {
+    IANS_STATUS_HOT_PLUG_NOT_SUPPORTED = 0,
+    IANS_STATUS_HOT_PLUG_NOT_DONE,
+    IANS_STATUS_HOT_PLUG_WAS_DONE
+} IANS_BD_HOT_PLUG_STATUS, *PIANS_BD_HOT_PLUG_STATUS;
+
+/*--------------------------------------------------------------------*
+ |         Enumerated types for general structs field values
+ *--------------------------------------------------------------------*/
+
+/* general typedef for various features - whether BD supports a feature 
+   or not. To be used on "capabilites" structs */
+
+typedef enum _IANS_BD_SUPPORT {
+    IANS_BD_DOES_NOT_SUPPORT = 0,
+    IANS_BD_SUPPORTS
+} IANS_BD_SUPPORT, *PIANS_BD_SUPPORT;
+
+/* general typedef for various features - whether iANS requests the BD 
+   to support a feature or not. To be used on "set mode" structs. */
+typedef enum _IANS_BD_REQUEST_SUPPORT {
+    IANS_DONT_SUPPORT = 0,
+    IANS_REQUEST_SUPPORT
+} IANS_BD_REQUEST_SUPPORT, *PIANS_BD_REQUEST_SUPPORT;
+
+
+
+/*--------------------------------------------------------------------*
+ |                    Ioctl parameter structs
+ |                    =======================
+ | The following structures are used by the different IOCTLs to pass
+ | parameters between the Base driver and iANS.
+ *--------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------*
+ |                 Common Command/Parameter Header
+ |                 ===============================
+ | The 1st field of every parameter struct.
+ *--------------------------------------------------------------------*/
+
+typedef struct _IANS_BD_PARAM_HEADER
+{
+    // Cast from IANS_BASE_OPCODE to insure forward size compatibility 
+    /* u32 */ int    Opcode; 
+} IANS_BD_PARAM_HEADER, *PIANS_BD_PARAM_HEADER;
+
+
+/*--------------------------------------------------------------------*
+ |                 Status result
+ |                 =============
+ | This struct is sent with as a response to GET_STATUS request.
+ | The status struct contains a version number : in case we will wish to 
+ | extend the status result, we will need a way to indicate which 
+ | version of the status struct we support. 
+ *--------------------------------------------------------------------*/
+#define IANS_STATUS_VERSION        0x00000001
+
+typedef struct _IANS_BD_PARAM_STATUS
+{  
+    u32     StatusVersion;       /* The version of this struct */
+    
+    u32     LinkStatus;          /* Cast from IANS_BD_LINK_STATUS */
+    u32     LinkSpeed;           /* Cast from IANS_BD_LINK_SPEED */
+    u32     Duplex;              /* Cast from IANS_BD_DUPLEX_STATUS  */
+    u32     HardwareFailure;     /* Cast from IANS_BD_HW_FAILURE */
+    u32     DuringResetProcess;  /* Cast from IANS_BD_RESET_STAGE  */
+    u32     Suspended;           /* Cast from IANS_BD_SUSPENDED_STAGE  */
+
+    u32     HotPlug;    /* Cast from IANS_BD_HOT_PLUG_STATUS  */
+} IANS_BD_PARAM_STATUS, *PIANS_BD_PARAM_STATUS;
+
+/*--------------------------------------------------------------------*
+ |                 Status ioctl result
+ |                 ===================
+ | This structure is the struct sent as a response to the GET_STATUS 
+ | request ioctl. It contains the ioctl header, and the status struct.
+ *--------------------------------------------------------------------*/
+
+typedef struct _IANS_BD_IOC_PARAM_STATUS
+{
+    IANS_BD_PARAM_HEADER           Header;                /* Common to all commands */
+    IANS_BD_PARAM_STATUS   Status;
+} IANS_BD_IOC_PARAM_STATUS, *PIANS_BD_IOC_PARAM_STATUS;
+
+
+
+/*--------------------------------------------------------------------*
+ |                    Identify yourself struct
+ |                    ========================
+ | This struct is sent with the IANS_BD_IDENTIFY request. 
+ | iANS fills its signature string and version number, and sends it to
+ | the base driver. The base driver fills its own signature string and
+ | version adn returns it.
+ *--------------------------------------------------------------------*/
+
+typedef struct _IANS_BD_PARAM_IDENTIFY
+{
+    IANS_BD_PARAM_HEADER           Header;                 /* Common to all commands */
+
+    u8      iANSSignature[IANS_SIGNATURE_LENGTH]; 
+    /* iANS fills copyright string*/
+    u8      BDSignature[IANS_SIGNATURE_LENGTH];   
+    /* BD fills copyright string*/
+    u32     iANSCommVersion;  /* iANS supported comm. version */
+    /* Upper word = major version number */
+    /* lower word = minor version number */
+    u32     BDCommVersion;    /* Base driver supported comm. version */
+} IANS_BD_PARAM_IDENTIFY, *PIANS_BD_PARAM_IDENTIFY;
+
+
+
+/*--------------------------------------------------------------------*
+ |                 Get Extended capabilities parameters struct
+ |                 =========================================== 
+ | This struct is sent with IANS_OP_EXT_GET_CAPABILITY - to be filled 
+ | by the base driver and sent to iANS
+ *--------------------------------------------------------------------*/ 
+#define IANS_BD_FLAG1           0x0001
+#define IANS_BD_FLAG2           0x0002
+#define IANS_BD_FLAG3           0x0004
+#define IANS_BD_FLAG4           0x0008
+#define IANS_BD_FLAG5           0x0010
+#define IANS_BD_FLAG6           0x0020
+#define IANS_BD_FLAG7           0x0040
+#define IANS_BD_FLAG8           0x0080
+
+
+typedef struct _IANS_BD_PARAM_EXT_CAP
+{
+    IANS_BD_PARAM_HEADER           Header;                 /* Common to all commands */
+
+    u32 BDCanSetMacAddress;    /* MAC Address setting - cast from 
+                                     IANS_BD_SUPPORT*/
+    u32 BDIansStatusVersion;    /* Status indication with iANS struct 
+                                      - which version is supported  */
+    u32 BDAllAvailableRouting;               /* Bitmask of all available Rx/Event
+                                                 * routings. IANS_BD_ROUTING */
+
+    u32     BDFlags;    /* The adapter's flags */
+
+    u32     BDAllAvailableSpeeds; /* A bit mask of all available speeds */
+
+} IANS_BD_PARAM_EXT_CAP, *PIANS_BD_PARAM_EXT_CAP;
+
+
+/*--------------------------------------------------------------------*
+ |                    Set Extended mode parameters struct
+ |                    ======================================== 
+ | This struct is sent with IANS_OP_EXT_SET_MODE - to be filled 
+ | by iANS and sent to the base driver
+ |
+ | iANS tells the base driver whether to report its status through
+ | the extended struct or not.
+ *--------------------------------------------------------------------*/ 
+
+
+typedef struct _IANS_BD_PARAM_EXT_SET_MODE
+{
+    IANS_BD_PARAM_HEADER           Header; /* Common to all commands */
+
+    u32 BDIansStatusReport;   /* Ask the base driver to report status through 
+                                  * status struct.  
+                                  * Cast from IANS_BD_REQUEST. */
+
+    u32 BDIansAttributedMode; /* Ask the base driver to send and receive
+                                  * packets accompanied by a per-frame data structure
+                                  * Cast from IANS_BD_REQUEST. */
+
+    u32 BDIansRoutingMode;    /* Bitmask of one Rx and one IANS_BD_ROUTING */
+
+
+} IANS_BD_PARAM_EXT_SET_MODE, *PIANS_BD_PARAM_EXT_SET_MODE;
+
+
+
+#ifdef IANS_BASE_VLAN_TAGGING
+
+/*--------------------------------------------------------------------*
+ |                  Get Vlan tagging capabilities
+ |                  =============================
+ | This struct is sent with the IANS_OP_ITAG_GET_CAPABILITY ioctl, to be filled 
+ | by the base driver.
+ *--------------------------------------------------------------------*/
+
+typedef struct _IANS_BD_PARAM_ITAG_CAP
+{
+    IANS_BD_PARAM_HEADER           Header;                 /* Common to all commands */
+
+    u32                 ISLTagMode;         /* cast from IANS_BD_SUPPORT */
+    u32                 IEEE802_3acTagMode; /* cast from IANS_BD_SUPPORT */
+
+} IANS_BD_PARAM_ITAG_CAP, *PIANS_BD_PARAM_ITAG_CAP;
+
+/*--------------------------------------------------------------------*
+ |                  Set Vlan tagging mode
+ |                  =====================
+ | This struct is sent with the IANS_OP_ITAG_SET_MODE ioctl, to be filled 
+ | by iANS.
+ *--------------------------------------------------------------------*/
+
+typedef enum _IANS_BD_TAGGING_MODE 
+{
+    IANS_BD_TAGGING_NONE =0,
+    IANS_BD_TAGGING_802_3AC,
+    IANS_BD_TAGGING_UNDEFINED
+}IANS_BD_TAGGING_MODE , *PIANS_BD_TAGGING_MODE ;
+
+typedef struct _IANS_BD_PARAM_ITAG_SET_MODE
+{
+    IANS_BD_PARAM_HEADER           Header;              /* Common to all commands */
+
+    u32                SetTagMode;  /* cast from IANS_BD_TAGGING_MODE  */
+} IANS_BD_PARAM_ITAG_SET_MODE, *PIANS_BD_PARAM_ITAG_SET_MODE;
+
+#endif /* IANS_BASE_VLAN_TAGGING */
+
+
+#ifdef IANS_BASE_VLAN_ID
+
+/*--------------------------------------------------------------------*
+ |            Get Vlan ID capabilities
+ |            ========================
+ | This struct is sent with the IANS_OP_IVLAN_ID_GET_CAPABILITY ioctl, 
+ | to be filled by the base driver
+ *--------------------------------------------------------------------*/
+
+typedef struct _IANS_BD_PARAM_IVLAN_CAP
+{
+    IANS_BD_PARAM_HEADER           Header;                 /* Common to all commands */
+
+    u32           VlanIDCapable;          /* Cast from IANS_BD_SUPPORT */
+    u32           VlanIDFilteringAble;    /* Cast from IANS_BD_SUPPORT */
+    u16           MaxVlanIDSupported;     /* Max. VLan ID supported by BD */
+    u32           MaxVlanTableSize;       /* Max. number of VLan IDs in a table */
+} IANS_BD_PARAM_IVLAN_CAP, *PIANS_BD_PARAM_IVLAN_CAP;
+
+/*--------------------------------------------------------------------*
+ |           Set Vlan ID mode
+ |           ================ 
+ | This struct is sent with the IANS_OP_IVLAN_ID_SET_MODE ioctl, filled
+ | by the iANS 
+ *--------------------------------------------------------------------*/ 
+
+typedef struct _IANS_BD_PARAM_IVLAN_SET_MODE
+{
+    IANS_BD_PARAM_HEADER           Header;                    /* Common to all commands */
+    u32           VlanIDRequest;           /* Cast from IANS_BD_REQUEST */
+    u32           VlanIDFilteringRequest;  /* Cast from IANS_BD_REQUEST */
+} IANS_BD_PARAM_IVLAN_SET_MODE, *PIANS_BD_PARAM_IVLAN_SET_MODE;
+
+/*--------------------------------------------------------------------*
+ |          Set Vlan ID filtering table
+ |          ===========================
+ | This struct is sent with the IANS_OP_IVLAN_ID_SET_TABLE request
+ *--------------------------------------------------------------------*/
+
+typedef struct _IANS_BD_PARAM_IVLAN_TABLE
+{
+    IANS_BD_PARAM_HEADER           Header;         /* Common to all commands */
+
+    u32        VLanIDNum;       /* Number of VLan IDs defined in 
+                                      this table */
+    u16        *VLanIDTable;  /* Beginning of ID list. 
+                                    * iANS will allocate enough space 
+                                    * for the whole table, and it will 
+                                    * start from this field - we don't 
+                                    * want to force this struct to be 
+                                    * as big as the maximum number of 
+                                    * VLan IDs. */
+
+} IANS_BD_PARAM_IVLAN_TABLE, *PIANS_BD_PARAM_IVLAN_TABLE;
+
+#endif /* IANS_BASE_VLAN_ID */
+
+
+
+/*--------------------------------------------------------------------*
+ |                PER_FRAME_ATTRIBUE_HEADER
+ |                *************************
+ | This header will be included in every TLV 
+ *--------------------------------------------------------------------*/
+
+typedef struct _Per_Frame_Attribute_Header
+{
+    u32               AttributeID;   /* Indicates which kind of data is contained
+                                           in this field */
+    u32               AttributeLength; /* Length of this attribute */
+} Per_Frame_Attribute_Header, *pPer_Frame_Attribute_Header;
+
+
+/* ================================================================= *
+ *                                                                   *
+ *                           Per-Message Attributes                  *
+ *                                                                   *
+ * ================================================================= */
+
+typedef struct _IANS_ATTR_HEADER
+{
+    pPer_Frame_Attribute_Header         pFirstTLV;              /* NULL if not attributed */
+    u32                                      OriginalProtocol;
+} IANS_ATTR_HEADER, *PIANS_ATTR_HEADER;
+
+/* Turn into a legal pointer */
+#if defined(__i386__)
+#define CelingAlignPtr(p)       ( p )
+#else
+#define CelingAlignPtr(p)       ( p )
+#endif
+
+/* The attribute header is kept at the beginning of the allocated buffer */
+#define iANSGetReceiveAttributeHeader(skb) \
+                ( (IANS_ATTR_HEADER*) CelingAlignPtr ( (char*)((skb)->head) ) ) 
+#define iANSGetTransmitAttributeHeader(skb) \
+                ( (IANS_ATTR_HEADER*) CelingAlignPtr ( (char*)((skb)->cb) ) ) 
+
+
+
+
+
+/*--------------------------------------------------------------------*
+ |                Attribute IDs
+ |                *************
+ | These values indicate which type of attribute is contained in a
+ | certain TLV.
+ *--------------------------------------------------------------------*/
+
+typedef enum _iANS_Attribute_ID
+{
+    IANS_ATTR_LAST_ATTR=0, /* Marks the last attribute in a list */
+    IANS_ATTR_DUMMY,       /* Non-initiating side should ignore this attribute */
+
+#ifdef IANS_BASE_VLAN_ID 
+    IANS_ATTR_VLAN_FIRST = 0x100, /* skip over reserved area */
+    IANS_ATTR_VLAN_ID,     /* This attribute contains the VLan ID */
+#endif /* IANS_BASE_VLAN_ID */ 
+
+#ifdef IANS_BASE_VLAN_TAGGING
+    IANS_ATTR_TAGGING_FIRST = 0x200, /* skip over reserved area */
+    IANS_ATTR_TAGGING_UNTAGGED,     /* This determines that frame is untagged */
+#endif /* IANS_BASE_VLAN_TAGGING */ 
+
+    IANS_ATTR_COMMA
+} iANS_Attribute_ID,  *piANS_Attribute_ID; 
+
+
+
+
+#ifdef IANS_BASE_VLAN_ID
+
+/*-------------------------------------------------------------------
+|                       VLAN_ID_PER_FRAME_INFO
+|                       **********************
+| This structure contains only the VLanID per-frame information.
+ -------------------------------------------------------------------*/
+typedef struct _VLAN_ID_Per_Frame_Info 
+{
+    Per_Frame_Attribute_Header  AttrHeader;
+
+    u16 VLanID;
+    u8  Padding[2];
+
+} VLAN_ID_Per_Frame_Info  , *pVLAN_ID_Per_Frame_Info ;
+
+#endif /* IANS_BASE_VLAN_ID */
+
+
+#ifdef IANS_BASE_VLAN_TAGGING
+
+/*-------------------------------------------------------------------
+|                       Untagged_Attribute
+|                       ******************
+| This structure is for the "untagged" attribute (used to indicate
+| that frame is untagged).
+ -------------------------------------------------------------------*/
+
+typedef struct _Untagged_Attribute
+{
+    Per_Frame_Attribute_Header  AttrHeader;
+
+} Untagged_Attribute  , *pUntagged_Attribute ;
+
+#endif /* IANS_BASE_VLAN_TAGGING */
+
+
+/*-------------------------------------------------------------------
+|                       LAST_ATTRIBUTE
+|                       **************
+| This structure is for the last attribute in the TLV list.
+ -------------------------------------------------------------------*/
+
+typedef struct _Last_Attribute
+{
+    Per_Frame_Attribute_Header  LastHeader;
+
+} Last_Attribute, *pLast_Attribute ;
+
+
+/*--------------------------------------------------------------------*
+ |                      Indication 
+ |                     ============                   
+ | This enum value is sent by the notify call back function
+ | called by the base driver for indication purposes.
+ *--------------------------------------------------------------------*/
+
+typedef enum _IANS_INDICATION 
+{
+    /* ----------  Basic Extention Indications  ---------- */
+    IANS_IND_EXT_HWMODIFY,                          
+                                   
+    IANS_IND_EXT_STATUS_CHANGE,     /* Report a new status */
+                                      
+    IANS_IND_XMIT_QUEUE_FULL, // tell ANS to stop transmit through this member
+
+    IANS_IND_XMIT_QUEUE_READY, // tell ANS to start transmit through this member
+                                      
+    IANS_IND_COMMA  /* Dummy to satisfy last ifdef'ed commma */
+        
+} IANS_INDICATION, *PIANS_INDICATION;
+
+
+
+
+typedef struct _IANS_BD_ANS_SET_CB {
+    IANS_BD_PARAM_HEADER           Header;
+    void *notify;
+} IANS_BD_ANS_SET_CB, *PIANS_BD_ANS_SET_CB;
+
+
+
+/* ================================================================= *
+ *                                                                   *
+ *                              Rx Routing                           *
+ *                                                                   *
+ * ================================================================= */
+// temp debug
+#define IANS_FRAME_TYPE         0x6D88  /*  Network order is 0x886D */
+
+
+/* Restore packing mode. */
+#pragma pack()
+
+
+#endif /* _IANS_BASE_COMM_H */
+
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000.h linux/drivers/net/e1000/e1000.h
--- ../ia64/linux/drivers/net/e1000/e1000.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,362 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+/* Linux PRO/1000 Ethernet Driver main header file */
+
+#ifndef _E1000_H_
+#define _E1000_H_
+
+#ifndef __E1000_MAIN__
+#define __NO_VERSION__
+#endif
+
+#include <linux/stddef.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/pagemap.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <linux/capability.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <net/pkt_sched.h>
+
+/* ethtool support */
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#define  E1000_ETHTOOL_COPPER_INTERFACE_SUPPORTS (SUPPORTED_10baseT_Half | \
+                    SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half | \
+                    SUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Full | \
+                    SUPPORTED_Autoneg | SUPPORTED_MII)
+#define  E1000_ETHTOOL_COPPER_INTERFACE_ADVERTISE (ADVERTISED_10baseT_Half | \
+                    ADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half | \
+                    ADVERTISED_100baseT_Full | ADVERTISED_1000baseT_Full | \
+                    ADVERTISED_Autoneg | ADVERTISED_MII)
+#define E1000_ETHTOOL_FIBER_INTERFACE_SUPPORTS (SUPPORTED_Autoneg | \
+                    SUPPORTED_FIBRE)
+#define E1000_ETHTOOL_FIBER_INTERFACE_ADVERTISE (ADVERTISED_Autoneg | \
+                    ADVERTISED_FIBRE)
+#endif /* SIOCETHTOOL */
+
+#include "e1000_kcompat.h"
+
+struct e1000_adapter;
+
+#include "e1000_mac.h"
+#include "e1000_phy.h"
+
+#ifdef IANS
+#include "base_comm.h"
+#include "ans_driver.h"
+#include "ans.h"
+#endif
+
+#ifdef IDIAG
+#include "idiag_pro.h"
+#include "idiag_e1000.h"
+#endif
+
+#define BAR_0 0
+
+/* 8254x can use Dual Address Cycles for 64-bit addressing */
+
+/* Advertise that we can DMA from any address location */
+#define E1000_DMA_MASK (~0x0UL)
+#define E1000_DBG(args...)
+// #define E1000_DBG(args...) printk("e1000: " args)
+#define E1000_ERR(args...) printk(KERN_ERR "e1000: " args)
+#ifdef CONFIG_PPC
+#define E1000_MAX_INTR 1
+#else
+#define E1000_MAX_INTR 10
+#endif
+#define MAX_NUM_MULTICAST_ADDRESSES 128
+
+/* command line options defaults */
+#define DEFAULT_TXD                  256
+#define MAX_TXD                      256
+#define MIN_TXD                       80
+#define MAX_82544_TXD               4096
+#define DEFAULT_RXD                  256
+#define MAX_RXD                      256
+#define MIN_RXD                       80
+#define MAX_82544_RXD               4096
+#define DEFAULT_TIDV                  64
+#define MAX_TIDV                  0xFFFF
+#define MIN_TIDV                       0
+#define DEFAULT_RIDV                  64
+#define MAX_RIDV                  0xFFFF
+#define MIN_RIDV                       0
+#define DEFAULT_MDIX                   0
+#define MAX_MDIX                       3
+#define MIN_MDIX                       0
+
+#define OPTION_UNSET    -1
+#define OPTION_DISABLED 0
+#define OPTION_ENABLED  1
+#define XSUMRX_DEFAULT       OPTION_ENABLED
+#define WAITFORLINK_DEFAULT  OPTION_ENABLED
+#define AUTONEG_ADV_DEFAULT  0x2F
+#define AUTONEG_ADV_MASK     0x2F
+#define FLOW_CONTROL_DEFAULT FLOW_CONTROL_FULL
+
+#define E1000_REPORT_TX_EARLY  2
+
+/* Supported RX Buffer Sizes */
+#define E1000_RXBUFFER_2048  2048
+#define E1000_RXBUFFER_4096  4096
+#define E1000_RXBUFFER_8192  8192
+#define E1000_RXBUFFER_16384 16384
+
+#define E1000_JUMBO_PBA      0x00000028
+#define E1000_DEFAULT_PBA    0x00000030
+
+/* Round size up to the next multiple of unit */
+#define E1000_ROUNDUP(size, unit) ((((size) + (unit) - 1) / (unit)) * (unit))
+
+/* This is better, but only works for unit sizes that are powers of 2 */
+#define E1000_ROUNDUP2(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))
+
+/* wrapper around a pointer to a socket buffer,
+ * so a DMA handle can be stored along with the buffer */
+struct e1000_buffer {
+    struct sk_buff *skb;
+    uint64_t dma;
+    unsigned long length;
+};
+
+/* Adapter->flags definitions */
+#define E1000_BOARD_OPEN 0
+#define E1000_RX_REFILL 1
+#define E1000_DIAG_OPEN 2
+#define E1000_LINK_STATUS_CHANGED 3
+
+typedef enum _XSUM_CONTEXT_T {
+    OFFLOAD_NONE,
+    OFFLOAD_TCP_IP,
+    OFFLOAD_UDP_IP
+} XSUM_CONTEXT_T;
+
+struct e1000_desc_ring {
+    void *desc;                 /* pointer to the descriptor ring memory      */
+    dma_addr_t dma;             /* physical address of the descriptor ring    */
+    unsigned int size;          /* length of descriptor ring in bytes         */
+    unsigned int count;         /* number of descriptors in the ring          */
+    atomic_t unused;            /* number of descriptors with no buffer       */
+    unsigned int next_to_use;   /* next descriptor to associate a buffer with */
+    unsigned int next_to_clean; /* next descriptor to check for DD status bit */
+    struct e1000_buffer *buffer_info; /* array of buffer information structs  */
+};
+
+#define E1000_RX_DESC(ring, i) \
+    (&(((struct e1000_rx_desc *)(ring.desc))[i]))
+
+#define E1000_TX_DESC(ring, i) \
+    (&(((struct e1000_tx_desc *)(ring.desc))[i]))
+
+#define E1000_CONTEXT_DESC(ring, i) \
+    (&(((struct e1000_context_desc *)(ring.desc))[i]))
+
+/* board specific private data structure */
+
+struct e1000_adapter {
+    struct e1000_adapter *next;
+    struct e1000_adapter *prev;
+
+    struct e1000_shared_adapter shared;
+
+#ifdef IANS
+    void *iANSReserved;
+    piANSsupport_t iANSdata;
+    uint32_t ans_link;
+    uint32_t ans_speed;
+    uint32_t ans_duplex;
+    uint32_t ans_suspend;
+    IANS_BD_TAGGING_MODE tag_mode;
+#endif
+
+    spinlock_t stats_lock;
+    spinlock_t rx_fill_lock;
+
+    unsigned long flags;
+    uint32_t bd_number;
+    struct timer_list timer_id;
+
+    /* Ethernet Node Address */
+    uint8_t perm_net_addr[ETH_LENGTH_OF_ADDRESS];
+
+    /* Status Flags */
+    boolean_t link_active;
+    uint16_t link_speed;
+    uint16_t link_duplex;
+    uint32_t rx_buffer_len;
+
+    /* PCI Device Info */
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint8_t rev_id;
+    uint16_t subven_id;
+    uint16_t subsys_id;
+
+    uint32_t part_num;
+
+    uint32_t int_mask;
+
+    /* driver specific */
+    struct tasklet_struct rx_fill_tasklet;
+
+    struct e1000_desc_ring tx_ring;
+    uint32_t tx_int_delay;
+    uint32_t TxdCmd;
+    atomic_t tx_timeout;
+
+    struct e1000_desc_ring rx_ring;
+    uint32_t rx_int_delay;
+
+    uint64_t XsumRXGood;
+    uint64_t XsumRXError;
+
+    /* Linux driver specific */
+    struct net_device *netdev;
+    struct pci_dev *pdev;
+    struct net_device_stats net_stats;
+    char *id_string;
+    boolean_t RxChecksum;
+    XSUM_CONTEXT_T ActiveChecksumContext;
+
+    struct e1000_phy_info phy_info;
+    struct e1000_shared_stats stats;
+
+    /* PHY Statistics */
+    struct e1000_phy_stats phy_stats;
+};
+
+/* Prototypes */
+
+/* e1000_main.c */
+extern int e1000_init_module(void);
+extern int e1000_probe_all(void);
+extern void e1000_exit_module(void);
+extern int e1000_probe(struct pci_dev *pdev,
+                       const struct pci_device_id *ent);
+extern void e1000_remove(struct pci_dev *pdev);
+extern void e1000_delete(struct e1000_adapter *Adapter);
+extern int e1000_open(struct net_device *netdev);
+extern int e1000_close(struct net_device *netdev);
+extern void e1000_set_multi(struct net_device *netdev);
+extern int e1000_xmit_frame(struct sk_buff *skb,
+                            struct net_device *netdev);
+extern struct net_device_stats *e1000_get_stats(struct net_device *netdev);
+extern int e1000_change_mtu(struct net_device *netdev,
+                            int new_mtu);
+extern int e1000_set_mac(struct net_device *netdev,
+                         void *p);
+extern void e1000_intr(int irq,
+                       void *data,
+                       struct pt_regs *regs);
+extern int e1000_ioctl(struct net_device *netdev,
+                       struct ifreq *ifr,
+                       int cmd);
+extern void e1000_watchdog(unsigned long data);
+extern void e1000_diag_ioctl(struct net_device *netdev,
+                             struct ifreq *ifr);
+
+#ifdef CONFIG_PROC_FS
+#include "e1000_proc.h"
+#endif
+#ifdef IDIAG
+#include "e1000_idiag.h"
+#endif
+#endif /* _E1000_H_ */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_idiag.c linux/drivers/net/e1000/e1000_idiag.c
--- ../ia64/linux/drivers/net/e1000/e1000_idiag.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_idiag.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,919 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+ *                                                                     *
+ * INTEL CORPORATION                                                   *
+ *                                                                     *
+ * This software is supplied under the terms of the license included   *
+ * above.  All use of this software must be in accordance with the     *
+ * terms of that license.                                              *
+ *                                                                     *
+ * Module Name:  diag.c                                               *
+ *                                                                     *
+ * Abstract:     Header file for data structure definition for common  *
+ *               diagnostics support                                   *
+ *                                                                     *
+ **********************************************************************/
+
+#include "e1000.h"
+
+static u32 IntrCount;
+
+void SetLoopBackMode(struct e1000_adapter *adapter, short LoopbackType);
+idiag_pro_stat_t Osdep_LoopBackTest(struct e1000_adapter *adapter,
+                idiag_e1000_diag_loopback_test_param_t *Param, int LbType);
+
+extern void e1000_selective_hibernate_adapter(struct net_device *netdev);
+extern void e1000_selective_wakeup_adapter(struct net_device *netdev);
+extern void e1000_hibernate_adapter(struct net_device *netdev);
+extern void e1000_wakeup_adapter(struct net_device *netdev);
+extern int e1000_xmit_lbtest_frame(struct sk_buff *skb, struct e1000_adapter * adapter);
+extern int e1000_rcv_lbtest_frame(struct e1000_adapter * adapter,
+               unsigned int frame_size);
+static void e1000_create_lbtest_frame(struct sk_buff *skb, 
+               unsigned int frame_size);
+
+#define RegPatternTest(Register, Mask, WriteVal)            \
+        for (Pattern = 0; Pattern < Ntests; Pattern++)        \
+        {                                                    \
+            E1000_WRITE_REG(&adapter->shared, Register,                        \
+                (TestPattern[Pattern] & WriteVal));            \
+            ReadValue = E1000_READ_REG(&adapter->shared, Register);            \
+            if (ReadValue != (TestPattern[Pattern] &         \
+                        WriteVal & Mask))                    \
+            {                                                \
+                Param->Reg =                                \
+                (adapter->shared.mac_type < e1000_82543) ?        \
+                E1000_82542_##Register :            \
+                E1000_##Register;        \
+                Param->WriteValue =                         \
+                (TestPattern[Pattern] & WriteVal);            \
+                Param->ReadValue = ReadValue;                \
+                return (IDIAG_PRO_STAT_TEST_FAILED);        \
+            }                                                \
+        }
+
+#define RegSetAndCheck(Register, Mask, WriteVal)            \
+        E1000_WRITE_REG(&adapter->shared, Register, WriteVal);                \
+        ReadValue = E1000_READ_REG(&adapter->shared, Register);                \
+        if ((WriteVal & Mask) != (ReadValue & Mask))        \
+        {                                                    \
+            Param->Reg =                                        \
+            (adapter->shared.mac_type < e1000_82543) ?            \
+            E1000_82542_##Register :                           \
+            E1000_##Register;                              \
+            Param->WriteValue = WriteVal & Mask;            \
+            Param->ReadValue = ReadValue & Mask;            \
+            return (IDIAG_PRO_STAT_TEST_FAILED);             \
+        }
+            
+/****************************************************************************
+* Name:       DiagRegTest 
+*
+* Description: This routine Performs diagnostic tests on the hardware
+*         registers 
+*
+* Author:      IntelCorporation
+*
+* Born on Date:   1/23/2001 
+*
+* Arguments:   
+*      adapter     Board dependent data structure 
+*      Param       Param structure thru which failed diagnostic test
+*                  results are reported.
+*
+* Returns: 
+*     idiag_pro_stat_t    Status of the Diagnostic Test.
+*
+* Modification log:
+* Date      Who  Description
+* --------  ---  -------------------------------------------------------- 
+*
+****************************************************************************/
+
+idiag_pro_stat_t
+DiagRegTest(struct e1000_adapter *adapter,
+    idiag_e1000_diag_reg_test_param_t *Param)
+{
+    u32 ReadValue, Pattern;
+    u32 Ntests = 4;
+    u32 TestPattern[4] = {0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};
+    u32 i;
+
+    /* The status register is Read Only
+     * So a write should fail.
+     * Some bits that get toggled are ignored
+     */
+#ifdef DIAG_DEBUG
+    DEBUGOUT("Register Test\n");
+#endif
+    ReadValue = (E1000_READ_REG(&adapter->shared, STATUS) & (0xFFFFF833));
+    E1000_WRITE_REG(&adapter->shared, STATUS, (0xFFFFFFFF));
+    if(ReadValue != (E1000_READ_REG(&adapter->shared, STATUS) & (0xFFFFF833))) {
+            Param->Reg = E1000_STATUS;
+            Param->WriteValue = 0xFFFFFFFF;
+            Param->ReadValue = ReadValue;
+
+        return(IDIAG_PRO_STAT_TEST_FAILED);
+    }
+
+    /* Register Pattern Test */
+    RegPatternTest(FCAL, 0xFFFFFFFF, 0xFFFFFFFF);
+    RegPatternTest(FCAH, 0x0000FFFF, 0xFFFFFFFF);
+    RegPatternTest(FCT, 0x0000FFFF, 0xFFFFFFFF);
+    RegPatternTest(VET, 0x0000FFFF, 0xFFFFFFFF);
+
+    if (adapter->shared.mac_type >= e1000_82543) {
+        RegSetAndCheck(RCTL, 0x06DFB3FE, 0xFFFFFFFF);
+    }
+    else
+    {
+        RegSetAndCheck(RCTL, 0xFFFFFFFF, 0x01FFFFFF);
+    }
+
+    if(adapter->shared.mac_type >= e1000_82543)
+    {
+        for (i = 0; i < E1000_RAR_ENTRIES; i++)
+        {
+            // RegPatternTest(Rar[i].Low, 0xFFFFFFFF, 0xFFFFFFFF);
+            // RegPatternTest(Rar[i].High, 0x8003FFFF, 0xFFFFFFFF);
+            RegPatternTest(RA + ((i << 1) << 2), 0xFFFFFFFF, 0xFFFFFFFF);
+            RegPatternTest(RA + (((i << 1) + 1) << 2), 0x8003FFFF, 0xFFFFFFFF);
+        }
+    }
+
+    for (i = 0; i < E1000_MC_TBL_SIZE; i++)
+    {
+        // RegPatternTest(Mta[i], 0xFFFFFFFF, 0xFFFFFFFF);
+        RegPatternTest(MTA + (i << 2), 0xFFFFFFFF, 0xFFFFFFFF);
+    }
+
+    RegSetAndCheck(RCTL, 0xFFFFFFFF, 0x00000000);
+
+    RegPatternTest(RDTR, 0x0000FFFF, 0xFFFFFFFF);
+
+    if (adapter->shared.mac_type >= e1000_82543) {
+        RegPatternTest(RDBAL, 0xFFFFFFF0, 0xFFFFFFFF);
+    } else {
+        RegPatternTest(RDBAL, 0xFFFFF000, 0xFFFFFFFF);
+    }
+
+    RegPatternTest(RDBAH, 0xFFFFFFFF, 0xFFFFFFFF);
+    RegPatternTest(RDLEN, 0x000FFF80, 0x000FFFFF);
+    RegPatternTest(RDH, 0x0000FFFF, 0x0000FFFF);
+    RegPatternTest(RDT, 0x0000FFFF, 0x0000FFFF);
+
+    RegPatternTest(FCRTH, 0x0000FFF8, 0x0000FFF8);
+
+    RegPatternTest(FCTTV, 0x0000FFFF, 0x0000FFFF);
+
+    if (adapter->shared.mac_type >= e1000_82543) 
+    {
+        RegPatternTest(TXCW, 0xC000FFFF, 0x0000FFFF);
+    }
+    else
+    {
+        RegPatternTest(TXCW, 0x0000FFFF, 0x0000FFFF);
+    }
+
+        
+    RegSetAndCheck(RCTL, 0x06DFB3FE, 0x003FFFFB);
+    RegSetAndCheck(TCTL, 0xFFFFFFFF, 0x00000000);
+        
+    RegPatternTest(TIPG, 0x3FFFFFFF, 0x3FFFFFFF);    
+    
+    if (adapter->shared.mac_type >= e1000_82543) 
+    {    
+        RegPatternTest(TDBAL, 0xFFFFFFF0, 0xFFFFFFFF);    
+    }
+    else
+    {
+        RegPatternTest(TDBAL, 0xFFFFF000, 0xFFFFFFFF);    
+    }
+
+    RegPatternTest(TDBAH, 0xFFFFFFFF, 0xFFFFFFFF);    
+
+    RegPatternTest(TDLEN, 0x000FFF80, 0x000FFFFF);    
+    
+    if (adapter->shared.mac_type >= e1000_82543)
+        RegPatternTest(TIDV, 0x0000FFFF, 0x0000FFFF);
+
+    return (IDIAG_PRO_STAT_OK);
+}
+
+/****************************************************************************
+* Name:       DiagFifoTest 
+*
+* Description: This routine Performs diagnostic tests on the Packet buffer  
+*         Memory 
+*
+* Author:      IntelCorporation
+*
+* Born on Date:   1/23/2001 
+*
+* Arguments:   
+*      adapter        Board dependent data structure 
+*      Param        Param structure thru which failed diagnostic test
+*                  results are reported.
+*
+* Returns: 
+*     idiag_pro_stat_t    Status of the Diagnostic Test.
+*
+* Modification log:
+* Date      Who  Description
+* --------  ---  -------------------------------------------------------- 
+*
+****************************************************************************/
+            
+idiag_pro_stat_t
+DiagFifoTest(struct e1000_adapter *adapter,
+        idiag_e1000_diag_fifo_test_param_t *Param)
+{
+    return (IDIAG_PRO_STAT_OK);
+}
+
+/****************************************************************************
+* Name:       DiagEepromTest 
+*
+* Description: This routine Performs diagnostic tests on the contents of  
+*         on board EEPROM 
+*
+* Author:      IntelCorporation
+*
+* Born on Date:   1/23/2001 
+*
+* Arguments:   
+*      adapter        Board dependent data structure 
+*      Param        Param structure thru which failed diagnostic test
+*                  results are reported.
+*
+* Returns: 
+*     idiag_pro_stat_t    Status of the Diagnostic Test.
+*
+* Modification log:
+* Date      Who  Description
+* --------  ---  -------------------------------------------------------- 
+*
+****************************************************************************/
+
+idiag_pro_stat_t
+DiagEepromTest(struct e1000_adapter *adapter,
+        idiag_e1000_diag_eeprom_test_param_t *Param)
+{
+    u16 Checksum = 0;
+    u16 Iteration;
+
+#ifdef DIAG_DEBUG
+    DEBUGOUT("EEPROM Test\n");
+#endif
+
+    /* Read and add up the contents of the EEPROM */
+    for (Iteration = 0; Iteration < (EEPROM_CHECKSUM_REG + 1); Iteration++)
+             Checksum += e1000_read_eeprom(&adapter->shared, Iteration);
+    
+    /* If Checksum is not Correct return error else test passed */
+    if(Checksum != (u16) EEPROM_SUM) {
+        Param->ActualChecksum = Checksum;
+        Param->ExpectedChecksum = EEPROM_SUM;
+        return(IDIAG_PRO_STAT_TEST_FAILED);
+    } else {
+        return(IDIAG_PRO_STAT_OK);
+    }
+    
+}
+
+void
+DiagIntrRoutine(int irq, void *data, struct pt_regs *regs)
+{
+    struct net_device *netdev = (struct net_device *)data;
+    struct e1000_adapter * adapter = netdev->priv;
+    uint32_t IcrContents;
+
+    /* Disable interrupts */
+    E1000_WRITE_REG(&adapter->shared, IMC, ~0);
+
+    IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+
+    E1000_DBG("DiagIntr\n");
+
+    IntrCount++;
+
+    return;
+}
+
+/****************************************************************************
+* Name:       DiagIntrTest 
+*
+* Description: This routine Performs diagnostic tests on the Interrupt 
+*         registers  
+*
+* Author:      IntelCorporation
+*
+* Born on Date:   1/23/2001 
+*
+* Arguments:   
+*      adapter        Board dependent data structure 
+*      Param        Param structure thru which failed diagnostic test
+*                  results are reported.
+*
+* Returns: 
+*     idiag_pro_stat_t    Status of the Diagnostic Test.
+*
+* Modification log:
+* Date      Who  Description
+* --------  ---  -------------------------------------------------------- 
+*
+****************************************************************************/
+
+idiag_pro_stat_t
+DiagIntrTest(struct e1000_adapter *adapter,
+        idiag_e1000_diag_intr_test_param_t *Param)
+{
+    u32 IcrContents;    
+    u32 Count;    
+    u32 Mask;    
+
+#ifdef DIAG_DEBUG
+    DEBUGOUT("Intr Test\n");
+#endif
+    
+    IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+
+    *Param = IDIAG_E1000_INTR_TEST_OK;
+    IntrCount = 0;
+
+    /* Disable all the interrupts */
+    E1000_WRITE_REG(&adapter->shared, IMC, 0xFFFFFFFF);
+
+    msec_delay(10);
+
+    /* Intr register is clear on read, 
+     * So read the Icr register once more And verify the
+     * Contents are zero. The contents should be zero
+     * becoz all the interrupts are disbled and Icr 
+     * was read earlier before clearing all its contents
+     */
+    IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+
+    if (IcrContents != 0)
+    {
+        /* Something is wrong, Icr has to be zero. 
+         * Since it is not, we cannot execute
+         * any further interrupt related tests.
+         */ 
+        *Param = IDIAG_E1000_INTR_TEST_NOT_EXEC;
+        return (IDIAG_PRO_STAT_TEST_FAILED);
+    }
+
+    /* Test each interrupt */
+    for(Count = 0; Count < 10; Count++)
+    {
+        /* Disable interrupts */
+        E1000_WRITE_REG(&adapter->shared, IMC, 0xFFFFFFFF);
+        msec_delay(10);
+
+        /* clear the intr cause register */
+        IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+        
+        /* Test Interrupts while disabled */
+        Mask = 0x0001 << Count;
+
+        /* Disable an interrupt by writing 1 to 
+         * corresponding bit of Imc 
+         */
+        E1000_WRITE_REG(&adapter->shared, IMC, (u32) Mask);
+        msec_delay(10);
+
+        /* Cause an interrupt by writing 1 to 
+         * corresponding bit of Imc 
+         */
+        E1000_WRITE_REG(&adapter->shared, ICS, (u32) Mask);
+        msec_delay(10);
+        
+        /* Read the Cause register contents */
+        IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+
+        /* If there is an Intr reported over the Bus then
+         * the test failed, becoz the caused intr was disabled
+         * and should not be reported by the device on the bus
+         */ 
+        if(IntrCount > 0)
+        {
+            *Param = IDIAG_E1000_INTR_TEST_FAILED_WHILE_DISABLED;
+            break;
+        }
+
+        /* Test Interrupts While enabled */
+        E1000_WRITE_REG(&adapter->shared, IMS, (u32) Mask);
+        msec_delay(10);
+        
+        E1000_WRITE_REG(&adapter->shared, ICS, (u32) Mask);
+        msec_delay(10);
+
+        IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+
+        /* The Intr was enabled So the device should have put
+         * an intr on the bus.
+         */                         
+        if(IntrCount == 0) {
+            *Param = IDIAG_E1000_INTR_TEST_FAILED_WHILE_ENABLED;
+            break;
+        }
+        /* Reset the Count for next test */
+        IntrCount = 0;
+        
+        /* Try to cause any other interrupt which is disabled */
+        E1000_WRITE_REG(&adapter->shared, IMC, (u32) ~Mask);
+        msec_delay(10);
+
+        E1000_WRITE_REG(&adapter->shared, ICS, (u32) ~Mask);
+        msec_delay(10);
+
+        IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+
+        /* Intr should not be reported on the bus as the caused
+         * intr's are disabled
+         */
+        if(IntrCount != 0) {
+            *Param = IDIAG_E1000_INTR_TEST_FAILED_MASKED_ENABLED;
+            break;
+        }
+    }
+
+    return ((*Param == IDIAG_E1000_INTR_TEST_OK) ? IDIAG_PRO_STAT_OK:
+            IDIAG_PRO_STAT_TEST_FAILED);
+}
+
+
+/****************************************************************************
+* Name:       DiagLinkTest 
+*
+* Description: This routine reports Link Status  
+*
+* Author:      IntelCorporation
+*
+* Born on Date:   1/23/2001 
+*
+* Arguments:   
+*      adapter        Board dependent data structure 
+*      Param        Param structure thru which failed diagnostic test
+*                  results are reported.
+*
+* Returns: 
+*     idiag_pro_stat_t    Status of the Diagnostic Test.
+*
+* Modification log:
+* Date      Who  Description
+* --------  ---  -------------------------------------------------------- 
+*
+****************************************************************************/
+        
+idiag_pro_stat_t
+DiagLinkTest(struct e1000_adapter *adapter,
+        idiag_e1000_diag_link_test_param_t *Param)
+{
+#ifdef DIAG_DEBUG
+    DEBUGOUT("Link Test\n");
+#endif
+    
+    /* Check link status */
+    adapter->shared.get_link_status = TRUE;
+    e1000_check_for_link(&adapter->shared);
+
+    if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_LU)
+        *Param = IDIAG_E1000_LINK_TEST_UP;
+    else
+        *Param = IDIAG_E1000_LINK_TEST_DOWN;
+
+    return IDIAG_PRO_STAT_OK;
+}
+
+
+/****************************************************************************
+* Name:       DiagLoopbackTest 
+*
+* Description: This routine Performs Loopback diagnostic tests. 
+*
+* Author:      IntelCorporation
+*
+* Born on Date:   1/23/2001 
+*
+* Arguments:   
+*      adapter        Board dependent data structure 
+*      Param        Param structure thru which failed diagnostic test
+*                  results are reported.
+*
+* Returns: 
+*     idiag_pro_stat_t    Status of the Diagnostic Test.
+*
+* Modification log:
+* Date      Who  Description
+* --------  ---  -------------------------------------------------------- 
+*
+****************************************************************************/
+
+idiag_pro_stat_t
+DiagLoopbackTest(struct e1000_adapter *adapter,
+        idiag_e1000_diag_loopback_test_param_t *Param)
+{
+    u32 IcrContents;
+
+#ifdef DIAG_DEBUG
+    DEBUGOUT(" LOOPBACK TEST \n");
+#endif
+
+    /* Disable Interrupts*/    
+    E1000_WRITE_REG(&adapter->shared, IMC, 0xFFFFFFFF);
+
+    /* Clear all interrupts */
+    IcrContents = E1000_READ_REG(&adapter->shared, ICR);
+    
+    if(Param->mode & IDIAG_E1000_DIAG_MAC_LB) {
+        /* Setup MAC loopback mode */
+        SetLoopBackMode(adapter, IDIAG_E1000_DIAG_MAC_LB);
+
+        /* Do the Loopback Test */
+        Osdep_LoopBackTest(adapter, Param, IDIAG_E1000_DIAG_MAC_LB);
+    }
+    if(Param->mode & IDIAG_E1000_DIAG_TCVR_LB) {
+        /* Setup External loopback mode */
+        SetLoopBackMode(adapter, IDIAG_E1000_DIAG_TCVR_LB);
+
+        /* Do the Loopback Test */
+        Osdep_LoopBackTest(adapter, Param, IDIAG_E1000_DIAG_TCVR_LB);
+    }
+    
+    /* Check Params */
+    if(Param->mac != IDIAG_E1000_LOOPBACK_TEST_OK &&
+       Param->tcvr != IDIAG_E1000_LOOPBACK_TEST_OK &&
+         Param->ext != IDIAG_E1000_LOOPBACK_TEST_OK) {
+    
+        return IDIAG_PRO_STAT_TEST_FAILED;
+    } else {
+        return IDIAG_PRO_STAT_OK;
+    }
+}
+
+void SetLoopBackMode(struct e1000_adapter *adapter, short LoopbackType)
+{
+    u32 RctlContents;
+    u16 MiiCtrlReg;
+
+    RctlContents = E1000_READ_REG(&adapter->shared, RCTL);        
+
+    /* Clear LBM bits */
+    RctlContents &= 0xFFFFFF3F;        
+
+    /* Store Bad Packets */
+    RctlContents |= E1000_RCTL_SBP;
+    RctlContents |= E1000_RCTL_BAM;
+
+    switch(LoopbackType)
+    {
+        case IDIAG_E1000_DIAG_MAC_LB:
+            RctlContents |= E1000_RCTL_LBM_MAC;
+            E1000_WRITE_REG(&adapter->shared, RCTL, RctlContents);
+            break;
+
+        case IDIAG_E1000_DIAG_TCVR_LB:
+            RctlContents |= E1000_RCTL_LBM_TCVR;
+            E1000_WRITE_REG(&adapter->shared, RCTL, RctlContents);
+            if(adapter->shared.media_type == e1000_media_type_copper) {
+                    MiiCtrlReg = e1000_read_phy_reg(&adapter->shared, PHY_CTRL);
+                    MiiCtrlReg |= MII_CR_LOOPBACK;
+                    e1000_write_phy_reg(&adapter->shared, PHY_CTRL, MiiCtrlReg);
+                    msec_delay(100);
+            }
+            break;
+    }
+}
+
+idiag_pro_stat_t
+GetPhyInformation(struct e1000_adapter * adapter, 
+                    struct device_diagnostics *Param)
+{
+#ifdef DIAG_DEBUG
+    DEBUGOUT("Get PHY Register Information\n");
+#endif
+     if (Param == NULL)
+        return IDIAG_PRO_STAT_BAD_PARAM;
+
+#ifdef DIAG_DEBUG
+    DEBUGOUT1("line_speed -              <%x>\n", adapter->link_speed);
+    DEBUGOUT1("media_type -              <%x>\n", adapter->shared.media_type);
+    DEBUGOUT1("cable_length -            <%x>\n", adapter->phy_info.cable_length);
+    DEBUGOUT1("extended_10b_t_distance - <%x>\n", adapter->phy_info.extended_10bt_distance);
+    DEBUGOUT1("cable_polarity -          <%x>\n", adapter->phy_info.cable_polarity);
+    DEBUGOUT1("polarity_reversal -       <%x>\n", adapter->phy_info.polarity_correction);
+    DEBUGOUT1("Idle_errors -             <%x>\n", adapter->phy_stats.idle_errors);
+    DEBUGOUT1("receive_errors -          <%x>\n", adapter->phy_stats.receive_errors);
+    DEBUGOUT1("mdi_x_mode -              <%x>\n", adapter->phy_info.mdix_mode);
+    DEBUGOUT1("local_rx -                <%x>\n", adapter->phy_info.local_rx);
+    DEBUGOUT1("remote_rx -               <%x>\n", adapter->phy_info.remote_rx);
+    DEBUGOUT1("pci_mode -                <%x>\n", adapter->bus_type);
+    DEBUGOUT1("bus_speed -               <%x>\n", adapter->bus_speed);
+    DEBUGOUT1("slot_size -               <%x>\n", adapter->bus_width);
+#endif
+
+    Param->line_speed              = adapter->link_speed;
+    Param->media_type              = adapter->shared.media_type;
+    Param->cable_length            = adapter->phy_info.cable_length;
+    Param->extended_10b_t_distance = adapter->phy_info.extended_10bt_distance;
+    Param->cable_polarity          = adapter->phy_info.cable_polarity;
+    Param->polarity_reversal       = adapter->phy_info.polarity_correction;
+    Param->idle_errors             = adapter->phy_stats.idle_errors;
+    Param->link_reset              = adapter->phy_info.link_reset;
+    Param->receive_errors          = adapter->phy_stats.receive_errors;
+    Param->mdi_x_mode              = adapter->phy_info.mdix_mode;
+    Param->local_rx                = adapter->phy_info.local_rx;
+    Param->remote_rx               = adapter->phy_info.remote_rx;
+    Param->pci_mode                = adapter->shared.bus_type;
+    Param->bus_speed               = adapter->shared.bus_speed;
+    Param->slot_size               = adapter->shared.bus_width;
+    
+    return (IDIAG_PRO_STAT_OK);
+}
+
+/* OS dependent diagnostic code */
+
+#include "e1000.h"
+
+void
+e1000_diag_ioctl(struct net_device *netdev, struct ifreq *ifr)
+{
+    uint32_t icr;
+    struct e1000_adapter * adapter = netdev->priv;
+    uint8_t stop_adapter = 0;
+
+    idiag_pro_data_t *DiagData = (idiag_pro_data_t *)ifr->ifr_data;
+
+    if(DiagData->interface_ver != IDIAG_PRO_VERSION) {
+        /* incorrect diagnostics interface version */
+        DiagData->status = IDIAG_PRO_STAT_NOT_SUPPORTED;
+        return;
+    }
+
+    if((DiagData->cmd != IDIAG_PRO_IDENTIFY_DRIVER) &&
+       (DiagData->driver_id != IDIAG_E1000_DRIVER)) {
+        /* incorrect driver identifier */
+        DiagData->status = IDIAG_PRO_STAT_NOT_SUPPORTED;
+        return;
+    }
+
+    if ((DiagData->cmd == IDIAG_E1000_DIAG_REG_TEST) || 
+        (DiagData->cmd == IDIAG_E1000_DIAG_FIFO_TEST) ||
+        (DiagData->cmd == IDIAG_E1000_DIAG_XSUM_TEST) ||
+        (DiagData->cmd == IDIAG_E1000_DIAG_INTR_TEST) ||
+        (DiagData->cmd == IDIAG_E1000_DIAG_LOOPBACK_TEST)){
+        stop_adapter = 1;
+    }
+    
+    if (stop_adapter == 1) {
+        /* Save the adapter state before starting the test */
+        e1000_hibernate_adapter(netdev);
+
+        E1000_WRITE_REG(&adapter->shared, IMC, 0xFFFFFFFF);
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+
+        /* Hook up diagnostic irq */
+        if (request_irq(netdev->irq, &DiagIntrRoutine, SA_SHIRQ,
+                    "e1000", netdev) != 0) {
+            E1000_ERR("Requesting diagnostic interrrupt routine FAILED\n");
+            return;
+        }
+    }
+
+    switch (DiagData->cmd) {
+
+    case IDIAG_PRO_IDENTIFY_DRIVER:
+        DiagData->driver_id = IDIAG_E1000_DRIVER;
+        DiagData->status = IDIAG_PRO_STAT_OK;
+        break;    
+
+    case IDIAG_E1000_DIAG_REG_TEST:
+        DiagData->status = DiagRegTest(adapter, (idiag_e1000_diag_reg_test_param_t *)
+                                       &DiagData->diag_param);
+        break;
+
+    case IDIAG_E1000_DIAG_FIFO_TEST:
+        DiagData->status = DiagFifoTest(adapter, (idiag_e1000_diag_fifo_test_param_t *)
+                                        &DiagData->diag_param);
+        break;
+
+    case IDIAG_E1000_DIAG_XSUM_TEST:
+        DiagData->status = DiagEepromTest(adapter, (idiag_e1000_diag_eeprom_test_param_t *)
+                                          &DiagData->diag_param);
+        break;
+
+    case IDIAG_E1000_DIAG_INTR_TEST:
+        DiagData->status = DiagIntrTest(adapter, (idiag_e1000_diag_intr_test_param_t *)
+                                        &DiagData->diag_param);
+        break;
+
+    case IDIAG_E1000_DIAG_LOOPBACK_TEST:
+
+        /* If interface is not open, we open here because
+        loopback test needs descriptor resources, etc. */ 
+        e1000_selective_wakeup_adapter(netdev);
+
+        /* Stop the interface from calling Tx entry point */
+        netif_stop_queue(netdev);
+
+        msec_delay(50);
+
+        DiagData->status = DiagLoopbackTest(adapter, (idiag_e1000_diag_loopback_test_param_t *)
+                                            &DiagData->diag_param);
+                                        
+        /* 
+        Mask off interrupts. Prevent LSC (Link Status Change) interrupt
+        from going to the bus after Phy Reset.
+        We don't want to see 2 cases:
+        case 1: Spurious interrupts. Linux fires up intr handler when irq is 
+        unhooked.
+        case 2: interrupt test failure. Unexpected fired interrupts will fail
+        interrupt test.
+        */
+        E1000_WRITE_REG(&adapter->shared, IMC, ~0);
+
+        /* Will generate LSC intr. Won't go to bus. */
+        if (adapter->shared.media_type == e1000_media_type_copper)
+            e1000_phy_reset(&adapter->shared);
+
+        e1000_selective_hibernate_adapter(netdev);
+        break;
+
+    case IDIAG_E1000_DIAG_LINK_TEST:
+        DiagData->status = DiagLinkTest(adapter, (idiag_e1000_diag_link_test_param_t *)
+                                         &DiagData->diag_param);
+        break;
+
+    case IDIAG_E1000_DIAG_GET_PHY_INFORMATION:
+        DiagData->status = GetPhyInformation(adapter, 
+                    (struct device_diagnostics *) &DiagData->diag_param);
+        break;
+
+    default:
+        DiagData->status = IDIAG_PRO_STAT_NOT_SUPPORTED;
+        break;
+    }
+
+    if (stop_adapter == 1) {
+        E1000_WRITE_REG(&adapter->shared, IMC, 0xFFFFFFFF);
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+
+        /* Unhook diagnostic irq */
+        free_irq(netdev->irq, netdev);
+
+        e1000_wakeup_adapter(netdev);
+    }
+
+    return;
+}
+
+idiag_pro_stat_t
+Osdep_LoopBackTest(struct e1000_adapter *adapter,
+                idiag_e1000_diag_loopback_test_param_t *Param, int LbType)
+{
+    u16 xmit_stat, rcv_stat;
+    struct sk_buff *skb;
+    unsigned int frame_size = 1024;
+
+    skb = alloc_skb(frame_size, GFP_ATOMIC);
+
+    skb_put(skb, frame_size);
+
+    e1000_create_lbtest_frame(skb, frame_size);
+ 
+    e1000_clear_hw_cntrs(&adapter->shared);
+
+    xmit_stat = e1000_xmit_lbtest_frame(skb, adapter);
+
+    if (xmit_stat != 1) {
+        switch(LbType) {
+        case IDIAG_E1000_DIAG_MAC_LB:
+            Param->mac = IDIAG_E1000_LOOPBACK_TEST_NOT_EXEC;
+            break;
+        case IDIAG_E1000_DIAG_TCVR_LB:
+            Param->tcvr = IDIAG_E1000_LOOPBACK_TEST_NOT_EXEC;
+            break;
+        case IDIAG_E1000_DIAG_EXT_LB:
+            Param->ext = IDIAG_E1000_LOOPBACK_TEST_NOT_EXEC;
+            break;
+        }
+        return (IDIAG_PRO_STAT_TEST_FAILED);
+    }
+
+    msec_delay(100);
+
+    rcv_stat = e1000_rcv_lbtest_frame(adapter, frame_size);
+    
+    if (rcv_stat != 1) {
+        switch(LbType) {
+        case IDIAG_E1000_DIAG_MAC_LB:
+            Param->mac = IDIAG_E1000_LOOPBACK_TEST_FAILED;
+            break;
+        case IDIAG_E1000_DIAG_TCVR_LB:
+            Param->tcvr = IDIAG_E1000_LOOPBACK_TEST_FAILED;
+            break;
+        case IDIAG_E1000_DIAG_EXT_LB:
+            Param->ext = IDIAG_E1000_LOOPBACK_TEST_FAILED;
+            break;
+        }
+        return (IDIAG_PRO_STAT_TEST_FAILED);
+    }
+
+    switch(LbType) {
+    case IDIAG_E1000_DIAG_MAC_LB:
+        Param->mac = IDIAG_E1000_LOOPBACK_TEST_OK;
+        break;
+    case IDIAG_E1000_DIAG_TCVR_LB:
+        Param->tcvr = IDIAG_E1000_LOOPBACK_TEST_OK;
+        break;
+    case IDIAG_E1000_DIAG_EXT_LB:
+        Param->ext = IDIAG_E1000_LOOPBACK_TEST_OK;
+        break;
+    }
+    return (IDIAG_PRO_STAT_OK);
+}
+
+static void
+e1000_create_lbtest_frame(struct sk_buff *skb, unsigned int frame_size)
+{
+    memset(skb->data, 0xFF, frame_size);
+    frame_size = (frame_size % 2) ? (frame_size - 1) : frame_size;
+    memset(&skb->data[frame_size/2], 0xAA, frame_size/2 - 1);
+    memset(&skb->data[frame_size/2 + 10], 0xBE, 1);
+    memset(&skb->data[frame_size/2 + 12], 0xAF, 1);
+} 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_idiag.h linux/drivers/net/e1000/e1000_idiag.h
--- ../ia64/linux/drivers/net/e1000/e1000_idiag.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_idiag.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,135 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+ *                                                                     *
+ * INTEL CORPORATION                                                   *
+ *                                                                     *
+ * This software is supplied under the terms of the license included   *
+ * above.  All use of this software must be in accordance with the     *
+ * terms of that license.                                              *
+ *                                                                     *
+ * Module Name:  e1000_idiag.h                                         *
+ *                                                                     *
+ * Abstract:     Header file for data structure definition for common  *
+ *               diagnostics support                                   *
+ *                                                                     *
+ **********************************************************************/
+
+#ifndef _E1000_IDIAG_H
+#define _E1000_IDIAG_H
+
+#include "idiag_pro.h"
+#include "idiag_e1000.h"
+
+extern idiag_pro_stat_t e1000_DiagRegTest
+(struct e1000_adapter *adapter, idiag_e1000_diag_reg_test_param_t *Param);
+
+extern idiag_pro_stat_t e1000_DiagFifoTest
+(struct e1000_adapter *adapter, idiag_e1000_diag_fifo_test_param_t *Param);
+
+extern idiag_pro_stat_t e1000_DiagEepromTest
+(struct e1000_adapter *adapter, idiag_e1000_diag_eeprom_test_param_t *Param);
+
+extern idiag_pro_stat_t e1000_DiagIntrTest
+(struct e1000_adapter *adapter, idiag_e1000_diag_intr_test_param_t *Param);
+
+extern idiag_pro_stat_t e1000_DiagLoopbackTest
+(struct e1000_adapter *adapter, idiag_e1000_diag_loopback_test_param_t *Param);
+
+extern idiag_pro_stat_t e1000_DiagLinkTest
+(struct e1000_adapter *adapter, idiag_e1000_diag_link_test_param_t *Param);
+
+struct device_diagnostics {
+  unsigned long idle_errors;
+  unsigned long receive_errors;
+  uint16_t line_speed;
+  uint8_t media_type;
+  uint8_t cable_length;
+  uint8_t extended_10b_t_distance;
+  uint8_t cable_polarity;
+  uint8_t polarity_reversal;
+  uint8_t link_reset;
+  uint8_t mdi_x_mode;
+  uint8_t local_rx;
+  uint8_t remote_rx;
+  uint8_t pci_mode;
+  uint8_t bus_speed;
+  uint8_t slot_size;
+};
+
+extern idiag_pro_stat_t e1000_GetPhyInformation
+(struct e1000_adapter *adapter, struct device_diagnostics *Param);
+
+#endif /* _E1000_IDIAG_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_kcompat.h linux/drivers/net/e1000/e1000_kcompat.h
--- ../ia64/linux/drivers/net/e1000/e1000_kcompat.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_kcompat.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,676 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+
+  Recipient has requested a license and Intel Corporation ("Intel") is
+  willing to grant a license for the software entitled Linux Base Driver
+  for the Intel(R) PRO/1000 Familty of Adapters (e1000) (the "Software")
+  being provided by Intel Corporation.
+  
+  The following definitions apply to this License:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation
+  which are necessarily infringed by the use or sale of the Software alone
+  or when combined with the operating system referred to below.
+  "Recipient" means the party to whom Intel delivers this Software.
+  "Licensee" means Recipient and those third parties that receive a license
+  to any operating system available under the GNU Public License version
+  2.0 or later.
+  
+  Copyright (c) 1999-2002 Intel Corporation All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under
+  the following terms.
+  
+  Redistribution and use in source and binary forms of the Software,
+  with or without modification, are permitted provided that the following
+  conditions are met:
+  
+  Redistributions of source code of the Software may retain the above
+  copyright notice, this list of conditions and the following disclaimer.
+  Redistributions in binary form of the Software may reproduce the above
+  copyright notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the distribution.
+  Neither the name of Intel Corporation nor the names of its contributors
+  shall be used to endorse or promote products derived from this Software
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide,
+  royalty-free patent license under Licensed Patents to make, use, sell,
+  offer to sell, import and otherwise transfer the Software, if any, in
+  source code and object code form. This license shall include changes
+  to the Software that are error corrections or other minor changes
+  to the Software that do not add functionality or features when the
+  Software is incorporated in any version of a operating system that has
+  been distributed under the GNU General Public License 2.0 or later.
+  This patent license shall apply to the combination of the Software and
+  any operating system licensed under the GNU Public License version 2.0
+  or later if, at the time Intel provides the Software to Recipient, such
+  addition of the Software to the then publicly available versions of such
+  operating system available under the GNU Public License version 2.0 or
+  later (whether in gold, beta or alpha form) causes such combination to
+  be covered by the Licensed Patents. The patent license shall not apply
+  to any other combinations which include the Software. No hardware per
+  se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS CONTRIBUTORS
+  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* Macros to make drivers compatible with 2.2, 2.4 Linux kernels
+ *
+ * In order to make a single network driver work with all 2.2, 2.4 kernels
+ * these compatibility macros can be used.
+ * They are backwards compatible implementations of the latest APIs.
+ * The idea is that these macros will let you use the newest driver with old
+ * kernels, but can be removed when working with the latest and greatest.
+ */
+
+/* When replacing a kernel function, an inline function is used instead of
+ * a macro to ensure compile time type checking of the arguments.
+ *
+ * All inline functions are prefixed with _kc and a #define is used to map
+ * it to the real name - because otherwise things get broken when a new API
+ * is back-ported in someones modified kernel.
+ */
+
+#ifndef E1000_LINUX_KERNEL_COMPAT_H
+#define E1000_LINUX_KERNEL_COMPAT_H
+
+#include <linux/version.h>
+
+/*****************************************************************************
+ **
+ **  PCI Bus Changes
+ **
+ *****************************************************************************/
+
+/* Accessing the BAR registers from the PCI device structure
+ * Changed from base_address[bar] to resource[bar].start in 2.3.13
+ * The pci_resource_start inline function was introduced in 2.3.43 
+ */
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,13) )
+#ifndef pci_resource_start
+#define pci_resource_start(dev, bar) \
+        (((dev)->base_address[(bar)] & PCI_BASE_ADDRESS_SPACE) ? \
+         ((dev)->base_address[(bar)] & PCI_BASE_ADDRESS_IO_MASK) : \
+         ((dev)->base_address[(bar)] & PCI_BASE_ADDRESS_MEM_MASK))
+#endif
+#elif ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43) )
+#ifndef pci_resource_start
+#define pci_resource_start(dev, bar) \
+        (((dev)->resource[(bar)] & PCI_BASE_ADDRESS_SPACE) ? \
+         ((dev)->resource[(bar)] & PCI_BASE_ADDRESS_IO_MASK) : \
+         ((dev)->resource[(bar)] & PCI_BASE_ADDRESS_MEM_MASK))
+#endif
+#endif
+
+/* Starting with 2.3.23 drivers are supposed to call pci_enable_device
+ * to make sure I/O and memory regions have been mapped and potentially 
+ * bring the device out of a low power state
+ */
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,23) )
+#include <linux/pci.h>
+#ifndef pci_enable_device
+#define pci_enable_device _kc_pci_enable_device
+static inline int
+_kc_pci_enable_device(struct pci_dev *dev)
+{ return 0; }
+#endif
+#endif
+
+/* Dynamic DMA mapping
+ * Instead of using virt_to_bus, bus mastering PCI drivers should use the DMA 
+ * mapping API to get bus addresses.  This lets some platforms use dynamic 
+ * mapping to use PCI devices that do not support DAC in a 64-bit address space
+ */
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+#if   ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,41) )
+#include <linux/pci.h>
+#ifndef pci_set_dma_mask
+#define pci_set_dma_mask _kc_pci_set_dma_mask
+static inline int
+_kc_pci_set_dma_mask(struct pci_dev *dev, u64 mask)
+{
+    if(!pci_dma_supported(dev, mask))
+        return -EIO;
+    dev->dma_mask = mask;
+    return 0;
+}
+#endif
+#endif
+#endif
+
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,41) )
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+
+#if (( LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18) ) || \
+     ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0) ) )
+
+typedef unsigned long dma_addr_t;
+
+#endif
+
+#define PCI_DMA_TODEVICE   1
+#define PCI_DMA_FROMDEVICE 2
+#ifndef pci_alloc_consistent
+#define pci_alloc_consistent _kc_pci_alloc_consistent
+static inline void *
+_kc_pci_alloc_consistent (struct pci_dev *dev, size_t size,
+                          dma_addr_t *dma_handle)
+{
+    void *vaddr = kmalloc(size, GFP_KERNEL);
+
+    if(vaddr != NULL) {
+        *dma_handle = virt_to_bus(vaddr);
+    }
+    return vaddr; 
+}
+#endif
+
+#ifndef pci_dma_supported
+#define pci_dma_supported _kc_pci_dma_supported
+static inline int
+_kc_pci_dma_supported(struct pci_dev *dev, u64 mask)
+{ return 1; }
+#endif
+
+#ifndef pci_set_dma_mask
+#define pci_set_dma_mask _kc_pci_set_dma_mask
+static inline int
+_kc_pci_set_dma_mask(struct pci_dev *dev, u64 mask)
+{ return 0; }
+#endif
+
+#ifndef pci_free_consistent
+#define pci_free_consistent _kc_pci_free_consistent
+static inline void _kc_pci_free_consistent(struct pci_dev *hwdev,
+                                           size_t size, 
+                                           void *cpu_addr,
+                                           dma_addr_t dma_handle)
+{ kfree(cpu_addr); return; }
+#endif
+
+#ifndef pci_map_single
+#define pci_map_single _kc_pci_map_single
+static inline u64 _kc_pci_map_single(struct pci_dev *hwdev, void *ptr,
+                                            size_t size, int direction)
+{ return virt_to_bus(ptr); }
+#endif
+
+#ifndef pci_unmap_single
+#define pci_unmap_single _kc_pci_unmap_single
+static inline void
+_kc_pci_unmap_single(struct pci_dev *hwdev, u64 dma_addr, 
+                     size_t size, int direction)
+{ return; }
+#endif
+
+#ifndef pci_resource_len
+#define pci_resource_len _kc_pci_resource_len
+static inline unsigned long
+_kc_pci_resource_len(struct pci_dev *pdev, int bar)
+{
+    u32 old, len;
+    
+    int bar_reg = PCI_BASE_ADDRESS_0 + (bar << 2);
+    
+    pci_read_config_dword(pdev, bar_reg, &old);
+    pci_write_config_dword(pdev, bar_reg, ~0);
+    pci_read_config_dword(pdev, bar_reg, &len);
+    pci_write_config_dword(pdev, bar_reg, old);
+
+    if((len & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_MEMORY)
+        len = ~(len & PCI_BASE_ADDRESS_MEM_MASK);
+    else
+        len = ~(len & PCI_BASE_ADDRESS_IO_MASK) & 0xffff;
+    
+    return (len + 1);
+}
+#endif
+
+#ifndef request_mem_region
+#define request_mem_region _kc_request_mem_region
+static inline int
+_kc_request_mem_region(unsigned long addr, ...)
+{ return 1; }
+#endif
+
+#ifndef release_mem_region
+#define release_mem_region _kc_release_mem_region
+static inline int
+_kc_release_mem_region(unsigned long addr, ...)
+{ return 0; }
+#endif
+
+#endif
+
+/*****************************************************************************
+ **
+ **  Network Device API Changes
+ **
+ *****************************************************************************/
+
+/* In 2.3.14 the device structure was renamed to net_device 
+ */
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,14) )
+#ifndef net_device
+#define net_device device
+#endif
+#endif
+
+/* 'Softnet' network stack changes merged in 2.3.43 
+ * these are 2.2 compatible defines for the new network interface API
+ * 2.3.47 added some more inline functions for softnet to remove explicit 
+ * bit tests in drivers
+ */
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43) )
+#ifndef netif_start_queue
+#define netif_start_queue(dev)   clear_bit  (0, &(dev)->tbusy)
+#endif
+#ifndef netif_stop_queue
+#define netif_stop_queue(dev)    set_bit    (0, &(dev)->tbusy)
+#endif
+#ifndef netif_wake_queue
+#define netif_wake_queue(dev)    { clear_bit(0, &(dev)->tbusy); \
+                                                mark_bh(NET_BH); }
+#endif
+#ifndef netif_running
+#define netif_running(dev)       test_bit(0, &(dev)->start)
+#endif
+#ifndef netif_queue_stopped
+#define netif_queue_stopped(dev) test_bit(0, &(dev)->tbusy)
+#endif
+#elif ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,47) )
+#ifndef netif_running
+#define netif_running(dev)       test_bit(LINK_STATE_START, &(dev)->state)
+#endif
+#ifndef netif_queue_stopped
+#define netif_queue_stopped(dev) test_bit(LINK_STATE_XOFF,  &(dev)->state)
+#endif
+#endif
+
+/* Softnet changes also affected how SKBs are handled
+ * Special calls need to be made now while in an interrupt handler
+ */
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43) )
+#ifndef dev_kfree_skb_irq
+#define dev_kfree_skb_irq dev_kfree_skb
+#endif
+#endif
+
+/* To avoid possible race conditions,
+ * we allocate a net_device first, and register it later.
+ * This function was copied from the 2.4.17 kernel and
+ * modified to rid of the last two input parameters.
+ */
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+#ifndef alloc_etherdev
+#define alloc_etherdev _kc_alloc_etherdev
+static inline struct net_device *_kc_alloc_etherdev(int sizeof_priv)
+{
+	struct net_device *dev;
+	int alloc_size;
+
+	alloc_size = sizeof (*dev) + sizeof_priv + 31 + IFNAMSIZ;
+
+	dev = (struct net_device *) kmalloc (alloc_size, GFP_KERNEL);
+	if (dev == NULL) {
+		printk(KERN_ERR "alloc_dev: Unable to allocate device memory.\n");
+		return NULL;
+	}
+
+	memset(dev, 0, alloc_size);
+
+	if (sizeof_priv)
+		dev->priv = (void *) (((long)(dev + 1) + 31) & ~31);
+
+	ether_setup(dev);
+#if   ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) )
+	dev->name = (char *) dev->priv + sizeof_priv;
+#endif
+	strcpy(dev->name, "");
+
+	return dev;
+}
+#endif
+#endif
+/*****************************************************************************
+ **
+ **  General Module / Driver / Kernel API Changes
+ **
+ *****************************************************************************/
+
+/* New module_init macro added in 2.3.13 - replaces init_module entry point
+ * If MODULE is defined, it expands to an init_module definition
+ * If the driver is staticly linked to the kernel, it creates the proper 
+ * function pointer for the initialization routine to be called
+ * (no more Space.c)
+ * module_exit does the same thing for cleanup_module
+ */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,13) )
+#ifndef module_init
+#define module_init(fn) int  init_module   (void) { return fn(); }
+#endif
+#ifndef module_exit
+#define module_exit(fn) void cleanup_module(void) { return fn(); }
+#endif
+#endif
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,47) )
+#include <linux/pci.h>
+#include <linux/module.h>
+
+#ifndef PCI_ANY_ID
+#define PCI_ANY_ID (~0U)
+#endif
+
+struct pci_device_id {
+    unsigned int vendor, device;
+    unsigned int subvendor, subdevice;
+    unsigned int class, classmask;
+    unsigned long driver_data;
+};
+
+#ifndef MODULE_DEVICE_TABLE
+#define MODULE_DEVICE_TABLE(bus, dev_table)
+#endif
+
+struct pci_driver {
+    char *name;
+    struct pci_device_id *id_table;
+    int (*probe)(struct pci_dev *dev, const struct pci_device_id *id);
+    void (*remove)(struct pci_dev *dev);
+    void (*suspend)(struct pci_dev *dev);
+    void (*resume)(struct pci_dev *dev);
+    /* track devices on Linux 2.2, used by module_init and unregister_driver */
+    /* not to be used by the driver directly */
+    /* assumes single function device with function #0 to simplify */
+    uint32_t pcimap[256];
+};
+
+#ifndef pci_module_init
+#define pci_module_init _kc_pci_module_init
+static inline int _kc_pci_module_init(struct pci_driver *drv)
+{
+    struct pci_dev *pdev;
+    struct pci_device_id *pciid;
+    uint16_t subvendor, subdevice;
+    int board_count = 0;
+
+    /* walk the global pci device list looking for matches */
+    for(pdev = pci_devices; pdev != NULL; pdev = pdev->next) {
+
+        pciid = &drv->id_table[0];
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &subvendor);
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &subdevice);
+        
+        while(pciid->vendor != 0) {
+            if(((pciid->vendor == pdev->vendor) ||
+                (pciid->vendor == PCI_ANY_ID)) &&
+
+               ((pciid->device == pdev->device) ||
+                (pciid->device == PCI_ANY_ID)) &&
+
+               ((pciid->subvendor == subvendor) ||
+                (pciid->subvendor == PCI_ANY_ID)) &&
+
+               ((pciid->subdevice == subdevice) ||
+                (pciid->subdevice == PCI_ANY_ID))) {
+
+                if(drv->probe(pdev, pciid) == 0) {
+                    board_count++;
+
+                    /* keep track of pci devices found */
+                    set_bit((pdev->devfn >> 3),
+                            &(drv->pcimap[pdev->bus->number]));
+                }
+                break;
+            }
+            pciid++;
+        }
+    }
+
+    return (board_count > 0) ? 0 : -ENODEV;
+}
+#endif
+
+#ifndef pci_unregister_driver
+#define pci_unregister_driver _kc_pci_unregister_driver
+static inline void _kc_pci_unregister_driver(struct pci_driver *drv)
+{
+    int i, bit;
+    struct pci_dev *pdev;
+
+    /* search the pci device bitmap and release them all */
+    for(i = 0; i < 256; i++) {
+        /* ffs = find first set bit */
+        for(bit = ffs(drv->pcimap[i]); bit > 0; bit = ffs(drv->pcimap[i])) {
+            bit--;
+            pdev = pci_find_slot(i, (bit << 3));
+            drv->remove(pdev);
+            clear_bit(bit, &drv->pcimap[i]);
+        }
+    }
+    return;
+}
+#endif
+
+#endif
+
+/* Taslets */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43) )
+
+#include <linux/interrupt.h>
+#ifndef tasklet_struct
+#define tasklet_struct tq_struct
+#endif
+
+#ifndef tasklet_init
+#define tasklet_init _kc_tasklet_init
+static inline void _kc_tasklet_init(struct tasklet_struct *t,
+                void (*func)(unsigned long), unsigned long data)
+{
+    t->next = NULL;
+    t->sync = 0;
+    t->routine = (void *)(void *)func;
+    t->data = (void *)data;
+}
+#endif
+
+#ifndef tasklet_schedule
+#define tasklet_schedule _kc_tasklet_schedule
+static inline void _kc_tasklet_schedule(struct tasklet_struct *t)
+{
+    queue_task(t, &tq_immediate);
+    mark_bh(IMMEDIATE_BH);
+    return;
+}
+#endif
+
+#ifndef tasklet_disable
+#define tasklet_disable _kc_tasklet_disable
+static inline void tasklet_disable(struct tasklet_struct *t)
+{
+    return;
+}
+#endif
+
+#ifndef tasklet_enable
+#define tasklet_enable _kc_tasklet_enable
+static inline void _kc_tasklet_enable(struct tasklet_struct *t)
+{
+    return;
+}
+#endif
+
+#ifndef tasklet_kill
+#define tasklet_kill _kc_tasklet_kill
+static inline void _kc_tasklet_kill(struct tasklet_struct *t)
+{
+    return;
+}
+#endif
+
+#endif
+
+/* Timer */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) )
+
+#ifndef del_timer_sync
+#define del_timer_sync(timer_id) del_timer(timer_id)
+#endif
+
+#endif
+/* End of Timer */
+
+/* pci_map_page / pci_unmap_page */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,13) )
+
+#include <linux/types.h>
+#include <linux/pagemap.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+
+#ifndef virt_to_page 
+#define virt_to_page(v) (mem_map + (virt_to_phys(v) >> PAGE_SHIFT))
+#endif
+
+#ifndef pci_map_page
+#define pci_map_page _kc_pci_map_page
+
+#if defined(CONFIG_HIGHMEM)
+
+#ifndef PCI_DRAM_OFFSET
+#define PCI_DRAM_OFFSET 0
+#endif
+
+static inline u64 _kc_pci_map_page(struct pci_dev *hwdev,
+                                      struct page *page,
+                                      unsigned long offset,
+                                      size_t size,
+                                      int direction) {
+
+    return  (((u64)(page - mem_map) << PAGE_SHIFT) + offset + PCI_DRAM_OFFSET);
+}
+
+#undef DMAADDR_OFFSET
+
+#else
+
+static inline u64 _kc_pci_map_page(struct pci_dev *hwdev,
+                                      struct page *page,
+                                      unsigned long offset,
+                                      size_t size,
+                                      int direction) {
+    return pci_map_single(hwdev,
+                          (void *) page_address(page) + offset,
+                          size,
+                          direction);
+}
+
+#endif
+#endif /* pci_map_page */
+
+#ifndef pci_unmap_page
+#define pci_unmap_page _kc_pci_unmap_page
+static inline void _kc_pci_unmap_page(struct pci_dev *hwdev,
+                                  u64 dma_address,
+                                  size_t size,
+                                  int direction) {
+
+    return pci_unmap_single(hwdev, dma_address, size, direction);
+}
+#endif
+
+#endif /* pci_map_page / pci_unmap_page */
+
+#endif /* E1000_LINUX_KERNEL_COMPAT_H */
+
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_mac.c linux/drivers/net/e1000/e1000_mac.c
--- ../ia64/linux/drivers/net/e1000/e1000_mac.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_mac.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,2093 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_mac.c
+ * Shared functions for accessing and configuring the MAC
+ */
+
+#include "e1000_mac.h"
+#include "e1000_phy.h"
+
+/******************************************************************************
+ * Raises the EEPROM's clock input.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * eecd_reg - EECD's current value
+ *****************************************************************************/
+static void
+e1000_raise_clock(struct e1000_shared_adapter *shared,
+                  uint32_t *eecd_reg)
+{
+    /* Raise the clock input to the EEPROM (by setting the SK bit), and then
+     * wait 50 microseconds.
+     */
+    *eecd_reg = *eecd_reg | E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, *eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Lowers the EEPROM's clock input.
+ *
+ * shared - Struct containing variables accessed by shared code 
+ * eecd_reg - EECD's current value
+ *****************************************************************************/
+static void
+e1000_lower_clock(struct e1000_shared_adapter *shared,
+                  uint32_t *eecd_reg)
+{
+    /* Lower the clock input to the EEPROM (by clearing the SK bit), and then 
+     * wait 50 microseconds. 
+     */
+    *eecd_reg = *eecd_reg & ~E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, *eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Shift data bits out to the EEPROM.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * data - data to send to the EEPROM
+ * count - number of bits to shift out
+ *****************************************************************************/
+static void
+e1000_shift_out_bits(struct e1000_shared_adapter *shared,
+                     uint16_t data,
+                     uint16_t count)
+{
+    uint32_t eecd_reg;
+    uint32_t mask;
+
+    /* We need to shift "count" bits out to the EEPROM. So, value in the
+     * "data" parameter will be shifted out to the EEPROM one bit at a time.
+     * In order to do this, "data" must be broken down into bits. 
+     */
+    mask = 0x01 << (count - 1);
+    eecd_reg = E1000_READ_REG(shared, EECD);
+    eecd_reg &= ~(E1000_EECD_DO | E1000_EECD_DI);
+    do {
+        /* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",
+         * and then raising and then lowering the clock (the SK bit controls
+         * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM
+         * by setting "DI" to "0" and then raising and then lowering the clock.
+         */
+        eecd_reg &= ~E1000_EECD_DI;
+
+        if(data & mask)
+            eecd_reg |= E1000_EECD_DI;
+
+        E1000_WRITE_REG(shared, EECD, eecd_reg);
+
+        usec_delay(50);
+
+        e1000_raise_clock(shared, &eecd_reg);
+        e1000_lower_clock(shared, &eecd_reg);
+
+        mask = mask >> 1;
+
+    } while(mask);
+
+    /* We leave the "DI" bit set to "0" when we leave this routine. */
+    eecd_reg &= ~E1000_EECD_DI;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    return;
+}
+
+/******************************************************************************
+ * Shift data bits in from the EEPROM
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static uint16_t
+e1000_shift_in_bits(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+    uint32_t i;
+    uint16_t data;
+
+    /* In order to read a register from the EEPROM, we need to shift 16 bits 
+     * in from the EEPROM. Bits are "shifted in" by raising the clock input to
+     * the EEPROM (setting the SK bit), and then reading the value of the "DO"
+     * bit.  During this "shifting in" process the "DI" bit should always be 
+     * clear..
+     */
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    eecd_reg &= ~(E1000_EECD_DO | E1000_EECD_DI);
+    data = 0;
+
+    for(i = 0; i < 16; i++) {
+        data = data << 1;
+        e1000_raise_clock(shared, &eecd_reg);
+
+        eecd_reg = E1000_READ_REG(shared, EECD);
+
+        eecd_reg &= ~(E1000_EECD_DI);
+        if(eecd_reg & E1000_EECD_DO)
+            data |= 1;
+
+        e1000_lower_clock(shared, &eecd_reg);
+    }
+
+    return data;
+}
+
+/******************************************************************************
+ * Prepares EEPROM for access
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This 
+ * function should be called before issuing a command to the EEPROM.
+ *****************************************************************************/
+static void
+e1000_setup_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    /* Clear SK and DI */
+    eecd_reg &= ~(E1000_EECD_SK | E1000_EECD_DI);
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+
+    /* Set CS */
+    eecd_reg |= E1000_EECD_CS;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    return;
+}
+
+/******************************************************************************
+ * Returns EEPROM to a "standby" state
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_standby_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    /* Deselct EEPROM */
+    eecd_reg &= ~(E1000_EECD_CS | E1000_EECD_SK);
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Clock high */
+    eecd_reg |= E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Select EEPROM */
+    eecd_reg |= E1000_EECD_CS;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Clock low */
+    eecd_reg &= ~E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Raises then lowers the EEPROM's clock pin
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_clock_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    /* Rising edge of clock */
+    eecd_reg |= E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+
+    /* Falling edge of clock */
+    eecd_reg &= ~E1000_EECD_SK;
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+    usec_delay(50);
+    return;
+}
+
+/******************************************************************************
+ * Terminates a command by lowering the EEPROM's chip select pin
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_cleanup_eeprom(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+
+    eecd_reg = E1000_READ_REG(shared, EECD);
+
+    eecd_reg &= ~(E1000_EECD_CS | E1000_EECD_DI);
+
+    E1000_WRITE_REG(shared, EECD, eecd_reg);
+
+    e1000_clock_eeprom(shared);
+    return;
+}
+
+/******************************************************************************
+ * Waits for the EEPROM to finish the current command.
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * The command is done when the EEPROM's data out pin goes high.
+ *****************************************************************************/
+static uint16_t
+e1000_wait_eeprom_command(struct e1000_shared_adapter *shared)
+{
+    uint32_t eecd_reg;
+    uint32_t i;
+
+
+    /* Toggle the CS line.  This in effect tells to EEPROM to actually execute 
+     * the command in question.
+     */
+    e1000_standby_eeprom(shared);
+
+    /* Now read DO repeatedly until is high (equal to '1').  The EEEPROM will
+     * signal that the command has been completed by raising the DO signal.
+     * If DO does not go high in 10 milliseconds, then error out.
+     */
+    for(i = 0; i < 200; i++) {
+        eecd_reg = E1000_READ_REG(shared, EECD);
+
+        if(eecd_reg & E1000_EECD_DO)
+            return (TRUE);
+
+        usec_delay(50);
+    }
+    ASSERT(0);
+    return (FALSE);
+}
+
+/******************************************************************************
+ * Forces the MAC's flow control settings.
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Sets the TFCE and RFCE bits in the device control register to reflect
+ * the adapter settings. TFCE and RFCE need to be explicitly set by
+ * software when a Copper PHY is used because autonegotiation is managed
+ * by the PHY rather than the MAC. Software must also configure these
+ * bits when link is forced on a fiber connection.
+ *****************************************************************************/
+static void
+e1000_force_mac_fc(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+
+    DEBUGFUNC("e1000_force_mac_fc");
+
+    /* Get the current configuration of the Device Control Register */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Because we didn't get link via the internal auto-negotiation
+     * mechanism (we either forced link or we got link via PHY
+     * auto-neg), we have to manually enable/disable transmit an
+     * receive flow control.
+     *
+     * The "Case" statement below enables/disable flow control
+     * according to the "shared->fc" parameter.
+     *
+     * The possible values of the "fc" parameter are:
+     *      0:  Flow control is completely disabled
+     *      1:  Rx flow control is enabled (we can receive pause
+     *          frames but not send pause frames).
+     *      2:  Tx flow control is enabled (we can send pause frames
+     *          frames but we do not receive pause frames).
+     *      3:  Both Rx and TX flow control (symmetric) is enabled.
+     *  other:  No other values should be possible at this point.
+     */
+
+    switch (shared->fc) {
+    case e1000_fc_none:
+        ctrl_reg &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
+        break;
+    case e1000_fc_rx_pause:
+        ctrl_reg &= (~E1000_CTRL_TFCE);
+        ctrl_reg |= E1000_CTRL_RFCE;
+        break;
+    case e1000_fc_tx_pause:
+        ctrl_reg &= (~E1000_CTRL_RFCE);
+        ctrl_reg |= E1000_CTRL_TFCE;
+        break;
+    case e1000_fc_full:
+        ctrl_reg |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
+        break;
+    default:
+        DEBUGOUT("Flow control param set incorrectly\n");
+        ASSERT(0);
+        break;
+    }
+
+    /* Disable TX Flow Control for 82542 (rev 2.0) */
+    if(shared->mac_type == e1000_82542_rev2_0)
+        ctrl_reg &= (~E1000_CTRL_TFCE);
+
+
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    return;
+}
+
+/******************************************************************************
+ * Reset the transmit and receive units; mask and clear all interrupts.
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_adapter_stop(struct e1000_shared_adapter *shared)
+{
+#if DBG
+    uint32_t ctrl_reg;
+#endif
+    uint32_t ctrl_ext_reg;
+    uint32_t icr_reg;
+    uint16_t pci_cmd_word;
+
+    DEBUGFUNC("e1000_shared_adapter_stop");
+
+    /* If we are stopped or resetting exit gracefully and wait to be
+     * started again before accessing the hardware.
+     */
+    if(shared->adapter_stopped) {
+        DEBUGOUT("Exiting because the adapter is already stopped!!!\n");
+        return;
+    }
+
+    /* Set the Adapter Stopped flag so other driver functions stop
+     * touching the Hardware.
+     */
+    shared->adapter_stopped = TRUE;
+
+    /* For 82542 (rev 2.0), disable MWI before issuing a device reset */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+
+            pci_cmd_word = shared->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE;
+
+            e1000_write_pci_cfg(shared, PCI_COMMAND_REGISTER, &pci_cmd_word);
+        }
+    }
+
+    /* Clear interrupt mask to stop board from generating interrupts */
+    DEBUGOUT("Masking off all interrupts\n");
+    E1000_WRITE_REG(shared, IMC, 0xffffffff);
+
+    /* Disable the Transmit and Receive units.  Then delay to allow
+     * any pending transactions to complete before we hit the MAC with
+     * the global reset.
+     */
+    E1000_WRITE_REG(shared, RCTL, 0);
+    E1000_WRITE_REG(shared, TCTL, E1000_TCTL_PSP);
+
+    /* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
+    shared->tbi_compatibility_on = FALSE;
+
+    msec_delay(10);
+
+    /* Issue a global reset to the MAC.  This will reset the chip's
+     * transmit, receive, DMA, and link units.  It will not effect
+     * the current PCI configuration.  The global reset bit is self-
+     * clearing, and should clear within a microsecond.
+     */
+    DEBUGOUT("Issuing a global reset to MAC\n");
+    E1000_WRITE_REG(shared, CTRL, E1000_CTRL_RST);
+
+    /* Delay a few ms just to allow the reset to complete */
+    msec_delay(10);
+
+#if DBG
+    /* Make sure the self-clearing global reset bit did self clear */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    ASSERT(!(ctrl_reg & E1000_CTRL_RST));
+#endif
+
+    /* Force a reload from the EEPROM */
+    ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+    ctrl_ext_reg |= E1000_CTRL_EXT_EE_RST;
+    E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+    msec_delay(2);
+    
+    /* Clear interrupt mask to stop board from generating interrupts */
+    DEBUGOUT("Masking off all interrupts\n");
+    E1000_WRITE_REG(shared, IMC, 0xffffffff);
+
+    /* Clear any pending interrupt events. */
+    icr_reg = E1000_READ_REG(shared, ICR);
+
+    /* If MWI was previously enabled, reenable it. */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            e1000_write_pci_cfg(shared,
+                                PCI_COMMAND_REGISTER, &shared->pci_cmd_word);
+        }
+    }
+    return;
+}
+
+/******************************************************************************
+ * Performs basic configuration of the adapter.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * 
+ * Assumes that the controller has previously been reset and is in a 
+ * post-reset uninitialized state. Initializes the receive address registers,
+ * multicast table, and VLAN filter table. Calls routines to setup link
+ * configuration and flow control settings. Clears all on-chip counters. Leaves
+ * the transmit and receive units disabled and uninitialized.
+ *****************************************************************************/
+boolean_t
+e1000_init_hw(struct e1000_shared_adapter *shared)
+{
+    uint32_t status_reg;
+    uint32_t i;
+    uint16_t pci_cmd_word;
+    boolean_t status;
+
+    DEBUGFUNC("e1000_init_hw");
+
+    /* Set the Media Type and exit with error if it is not valid. */
+    if(shared->mac_type != e1000_82543) {
+        /* tbi_compatibility is only valid on 82543 */
+        shared->tbi_compatibility_en = FALSE;
+    }
+
+    if(shared->mac_type >= e1000_82543) {
+        status_reg = E1000_READ_REG(shared, STATUS);
+        if(status_reg & E1000_STATUS_TBIMODE) {
+            shared->media_type = e1000_media_type_fiber;
+            /* tbi_compatibility not valid on fiber */
+            shared->tbi_compatibility_en = FALSE;
+        } else {
+            shared->media_type = e1000_media_type_copper;
+        }
+    } else {
+        /* This is an 82542 (fiber only) */
+        shared->media_type = e1000_media_type_fiber;
+    }
+
+    /* Disabling VLAN filtering. */
+    DEBUGOUT("Initializing the IEEE VLAN\n");
+    E1000_WRITE_REG(shared, VET, 0);
+
+    e1000_clear_vfta(shared);
+
+    /* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+            pci_cmd_word = shared->pci_cmd_word & ~CMD_MEM_WRT_INVALIDATE;
+            e1000_write_pci_cfg(shared, PCI_COMMAND_REGISTER, &pci_cmd_word);
+        }
+        E1000_WRITE_REG(shared, RCTL, E1000_RCTL_RST);
+
+        msec_delay(5);
+    }
+
+    /* Setup the receive address. This involves initializing all of the Receive
+     * Address Registers (RARs 0 - 15).
+     */
+    e1000_init_rx_addrs(shared);
+
+    /* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
+    if(shared->mac_type == e1000_82542_rev2_0) {
+        E1000_WRITE_REG(shared, RCTL, 0);
+
+        msec_delay(1);
+
+        if(shared->pci_cmd_word & CMD_MEM_WRT_INVALIDATE) {
+            e1000_write_pci_cfg(shared,
+                                PCI_COMMAND_REGISTER, &shared->pci_cmd_word);
+        }
+    }
+
+    /* Zero out the Multicast HASH table */
+    DEBUGOUT("Zeroing the MTA\n");
+    for(i = 0; i < E1000_MC_TBL_SIZE; i++)
+        E1000_WRITE_REG_ARRAY(shared, MTA, i, 0);
+
+    /* Call a subroutine to configure the link and setup flow control. */
+    status = e1000_setup_fc_and_link(shared);
+
+    /* Clear all of the statistics registers (clear on read).  It is
+     * important that we do this after we have tried to establish link
+     * because the symbol error count will increment wildly if there
+     * is no link.
+     */
+    e1000_clear_hw_cntrs(shared);
+
+    shared->low_profile = FALSE;
+    if(shared->mac_type == e1000_82544) {
+        if(e1000_read_eeprom(shared, E1000_EEPROM_LED_LOGIC) & 
+           E1000_EEPROM_SWDPIN0)
+            shared->low_profile = TRUE;
+    }
+
+    return (status);
+}
+
+/******************************************************************************
+ * Initializes receive address filters.
+ *
+ * shared - Struct containing variables accessed by shared code 
+ *
+ * Places the MAC address in receive address register 0 and clears the rest
+ * of the receive addresss registers. Clears the multicast table. Assumes
+ * the receiver is in reset when the routine is called.
+ *****************************************************************************/
+void
+e1000_init_rx_addrs(struct e1000_shared_adapter *shared)
+{
+    uint32_t i;
+    uint32_t addr_low;
+    uint32_t addr_high;
+
+    DEBUGFUNC("e1000_init_rx_addrs");
+
+    /* Setup the receive address. */
+    DEBUGOUT("Programming MAC Address into RAR[0]\n");
+    addr_low = (shared->mac_addr[0] |
+                (shared->mac_addr[1] << 8) |
+                (shared->mac_addr[2] << 16) | (shared->mac_addr[3] << 24));
+
+    addr_high = (shared->mac_addr[4] |
+                 (shared->mac_addr[5] << 8) | E1000_RAH_AV);
+
+    E1000_WRITE_REG_ARRAY(shared, RA, 0, addr_low);
+    E1000_WRITE_REG_ARRAY(shared, RA, 1, addr_high);
+
+    /* Zero out the other 15 receive addresses. */
+    DEBUGOUT("Clearing RAR[1-15]\n");
+    for(i = 1; i < E1000_RAR_ENTRIES; i++) {
+        E1000_WRITE_REG_ARRAY(shared, RA, (i << 1), 0);
+        E1000_WRITE_REG_ARRAY(shared, RA, ((i << 1) + 1), 0);
+    }
+
+    return;
+}
+
+/******************************************************************************
+ * Updates the MAC's list of multicast addresses.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * mc_addr_list - the list of new multicast addresses
+ * mc_addr_count - number of addresses
+ * pad - number of bytes between addresses in the list
+ *
+ * The given list replaces any existing list. Clears the last 15 receive
+ * address registers and the multicast table. Uses receive address registers
+ * for the first 15 multicast addresses, and hashes the rest into the 
+ * multicast table.
+ *****************************************************************************/
+void
+e1000_mc_addr_list_update(struct e1000_shared_adapter *shared,
+                          uint8_t *mc_addr_list,
+                          uint32_t mc_addr_count,
+                          uint32_t pad)
+{
+    uint32_t hash_value;
+    uint32_t i;
+    uint32_t rar_used_count = 1;        /* RAR[0] is used for our MAC address */
+
+    DEBUGFUNC("e1000_mc_addr_list_update");
+
+    /* Set the new number of MC addresses that we are being requested to use. */
+    shared->num_mc_addrs = mc_addr_count;
+
+    /* Clear RAR[1-15] */
+    DEBUGOUT(" Clearing RAR[1-15]\n");
+    for(i = rar_used_count; i < E1000_RAR_ENTRIES; i++) {
+        E1000_WRITE_REG_ARRAY(shared, RA, (i << 1), 0);
+        E1000_WRITE_REG_ARRAY(shared, RA, ((i << 1) + 1), 0);
+    }
+
+    /* Clear the MTA */
+    DEBUGOUT(" Clearing MTA\n");
+    for(i = 0; i < E1000_NUM_MTA_REGISTERS; i++) {
+        E1000_WRITE_REG_ARRAY(shared, MTA, i, 0);
+    }
+
+    /* Add the new addresses */
+    for(i = 0; i < mc_addr_count; i++) {
+        DEBUGOUT(" Adding the multicast addresses:\n");
+        DEBUGOUT7(" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n", i,
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad)],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 1],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 2],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 3],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 4],
+                  mc_addr_list[i * (ETH_LENGTH_OF_ADDRESS + pad) + 5]);
+
+        hash_value = e1000_hash_mc_addr(shared,
+                                        mc_addr_list +
+                                        (i * (ETH_LENGTH_OF_ADDRESS + pad)));
+
+        DEBUGOUT1(" Hash value = 0x%03X\n", hash_value);
+
+        /* Place this multicast address in the RAR if there is room, *
+         * else put it in the MTA            
+         */
+        if(rar_used_count < E1000_RAR_ENTRIES) {
+            e1000_rar_set(shared,
+                          mc_addr_list + (i * (ETH_LENGTH_OF_ADDRESS + pad)),
+                          rar_used_count);
+            rar_used_count++;
+        } else {
+            e1000_mta_set(shared, hash_value);
+        }
+    }
+
+    DEBUGOUT("MC Update Complete\n");
+    return;
+}
+
+/******************************************************************************
+ * Hashes an address to determine its location in the multicast table
+ *
+ * shared - Struct containing variables accessed by shared code
+ * mc_addr - the multicast address to hash 
+ *****************************************************************************/
+uint32_t
+e1000_hash_mc_addr(struct e1000_shared_adapter *shared,
+                   uint8_t *mc_addr)
+{
+    uint32_t hash_value = 0;
+
+    /* The portion of the address that is used for the hash table is
+     * determined by the mc_filter_type setting.  
+     */
+    switch (shared->mc_filter_type) {
+        /* [0] [1] [2] [3] [4] [5]
+            * 01  AA  00  12  34  56
+            * LSB                 MSB - According to H/W docs */
+    case 0:
+        /* [47:36] i.e. 0x563 for above example address */
+        hash_value = ((mc_addr[4] >> 4) | (((uint16_t) mc_addr[5]) << 4));
+        break;
+    case 1:                   /* [46:35] i.e. 0xAC6 for above example address */
+        hash_value = ((mc_addr[4] >> 3) | (((uint16_t) mc_addr[5]) << 5));
+        break;
+    case 2:                   /* [45:34] i.e. 0x5D8 for above example address */
+        hash_value = ((mc_addr[4] >> 2) | (((uint16_t) mc_addr[5]) << 6));
+        break;
+    case 3:                   /* [43:32] i.e. 0x634 for above example address */
+        hash_value = ((mc_addr[4]) | (((uint16_t) mc_addr[5]) << 8));
+        break;
+    }
+
+    hash_value &= 0xFFF;
+    return (hash_value);
+}
+
+/******************************************************************************
+ * Sets the bit in the multicast table corresponding to the hash value.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * hash_value - Multicast address hash value
+ *****************************************************************************/
+void
+e1000_mta_set(struct e1000_shared_adapter *shared,
+              uint32_t hash_value)
+{
+    uint32_t hash_bit, hash_reg;
+    uint32_t mta_reg;
+    uint32_t temp;
+
+    /* The MTA is a register array of 128 32-bit registers.  
+     * It is treated like an array of 4096 bits.  We want to set 
+     * bit BitArray[hash_value]. So we figure out what register
+     * the bit is in, read it, OR in the new bit, then write
+     * back the new value.  The register is determined by the 
+     * upper 7 bits of the hash value and the bit within that 
+     * register are determined by the lower 5 bits of the value.
+     */
+    hash_reg = (hash_value >> 5) & 0x7F;
+    hash_bit = hash_value & 0x1F;
+
+    mta_reg = E1000_READ_REG_ARRAY(shared, MTA, hash_reg);
+
+    mta_reg |= (1 << hash_bit);
+
+    /* If we are on an 82544 and we are trying to write an odd offset
+     * in the MTA, save off the previous entry before writing and
+     * restore the old value after writing.
+     */
+    if((shared->mac_type == e1000_82544) && ((hash_reg & 0x1) == 1)) {
+        temp = E1000_READ_REG_ARRAY(shared, MTA, (hash_reg - 1));
+        E1000_WRITE_REG_ARRAY(shared, MTA, hash_reg, mta_reg);
+        E1000_WRITE_REG_ARRAY(shared, MTA, (hash_reg - 1), temp);
+    } else {
+        E1000_WRITE_REG_ARRAY(shared, MTA, hash_reg, mta_reg);
+    }
+    return;
+}
+
+/******************************************************************************
+ * Puts an ethernet address into a receive address register.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * addr - Address to put into receive address register
+ * index - Receive address register to write
+ *****************************************************************************/
+void
+e1000_rar_set(struct e1000_shared_adapter *shared,
+              uint8_t *addr,
+              uint32_t index)
+{
+    uint32_t rar_low, rar_high;
+
+    /* HW expects these in little endian so we reverse the byte order
+     * from network order (big endian) to little endian              
+     */
+    rar_low = ((uint32_t) addr[0] |
+               ((uint32_t) addr[1] << 8) |
+               ((uint32_t) addr[2] << 16) | ((uint32_t) addr[3] << 24));
+
+    rar_high = ((uint32_t) addr[4] | ((uint32_t) addr[5] << 8) | E1000_RAH_AV);
+
+    E1000_WRITE_REG_ARRAY(shared, RA, (index << 1), rar_low);
+    E1000_WRITE_REG_ARRAY(shared, RA, ((index << 1) + 1), rar_high);
+    return;
+}
+
+/******************************************************************************
+ * Writes a value to the specified offset in the VLAN filter table.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * offset - Offset in VLAN filer table to write
+ * value - Value to write into VLAN filter table
+ *****************************************************************************/
+void
+e1000_write_vfta(struct e1000_shared_adapter *shared,
+                 uint32_t offset,
+                 uint32_t value)
+{
+    uint32_t temp;
+
+    if((shared->mac_type == e1000_82544) && ((offset & 0x1) == 1)) {
+        temp = E1000_READ_REG_ARRAY(shared, VFTA, (offset - 1));
+        E1000_WRITE_REG_ARRAY(shared, VFTA, offset, value);
+        E1000_WRITE_REG_ARRAY(shared, VFTA, (offset - 1), temp);
+    } else {
+        E1000_WRITE_REG_ARRAY(shared, VFTA, offset, value);
+    }
+    return;
+}
+
+/******************************************************************************
+ * Clears the VLAN filer table
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_clear_vfta(struct e1000_shared_adapter *shared)
+{
+    uint32_t offset;
+
+    for(offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++)
+        E1000_WRITE_REG_ARRAY(shared, VFTA, offset, 0);
+    return;
+}
+
+/******************************************************************************
+ * Configures flow control and link settings.
+ * 
+ * shared - Struct containing variables accessed by shared code
+ * 
+ * Determines which flow control settings to use. Calls the apropriate media-
+ * specific link configuration function. Configures the flow control settings.
+ * Assuming the adapter has a valid link partner, a valid link should be
+ * established. Assumes the hardware has previously been reset and the 
+ * transmitter and receiver are not enabled.
+ *****************************************************************************/
+boolean_t
+e1000_setup_fc_and_link(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+    uint32_t eecd_reg;
+    uint32_t ctrl_ext_reg;
+    boolean_t status = TRUE;
+
+    DEBUGFUNC("e1000_setup_fc_and_link");
+
+    /* Read the SWDPIO bits and the ILOS bit out of word 0x0A in the
+     * EEPROM.  Store these bits in a variable that we will later write
+     * to the Device Control Register (CTRL).
+     */
+    eecd_reg = e1000_read_eeprom(shared, EEPROM_INIT_CONTROL1_REG);
+
+    ctrl_reg =
+        (((eecd_reg & EEPROM_WORD0A_SWDPIO) << SWDPIO_SHIFT) |
+         ((eecd_reg & EEPROM_WORD0A_ILOS) << ILOS_SHIFT));
+
+    /* Set the PCI priority bit correctly in the CTRL register.  This
+     * determines if the adapter gives priority to receives, or if it
+     * gives equal priority to transmits and receives.
+     */
+    if(shared->dma_fairness)
+        ctrl_reg |= E1000_CTRL_PRIOR;
+
+    /* Read and store word 0x0F of the EEPROM. This word contains bits
+     * that determine the hardware's default PAUSE (flow control) mode,
+     * a bit that determines whether the HW defaults to enabling or
+     * disabling auto-negotiation, and the direction of the
+     * SW defined pins. If there is no SW over-ride of the flow
+     * control setting, then the variable shared->fc will
+     * be initialized based on a value in the EEPROM.
+     */
+    eecd_reg = e1000_read_eeprom(shared, EEPROM_INIT_CONTROL2_REG);
+
+    if(shared->fc > e1000_fc_full) {
+        if((eecd_reg & EEPROM_WORD0F_PAUSE_MASK) == 0)
+            shared->fc = e1000_fc_none;
+        else if((eecd_reg & EEPROM_WORD0F_PAUSE_MASK) == EEPROM_WORD0F_ASM_DIR)
+            shared->fc = e1000_fc_tx_pause;
+        else
+            shared->fc = e1000_fc_full;
+    }
+
+    /* We want to save off the original Flow Control configuration just
+     * in case we get disconnected and then reconnected into a different
+     * hub or switch with different Flow Control capabilities.
+     */
+    shared->original_fc = shared->fc;
+
+    if(shared->mac_type == e1000_82542_rev2_0)
+        shared->fc &= (~e1000_fc_tx_pause);
+
+    if((shared->mac_type < e1000_82543) && (shared->report_tx_early == 1))
+        shared->fc &= (~e1000_fc_rx_pause);
+
+    DEBUGOUT1("After fix-ups FlowControl is now = %x\n", shared->fc);
+
+    /* Take the 4 bits from EEPROM word 0x0F that determine the initial
+     * polarity value for the SW controlled pins, and setup the
+     * Extended Device Control reg with that info.
+     * This is needed because one of the SW controlled pins is used for
+     * signal detection.  So this should be done before e1000_setup_pcs_link()
+     * or e1000_phy_setup() is called.
+     */
+    if(shared->mac_type == e1000_82543) {
+        ctrl_ext_reg = ((eecd_reg & EEPROM_WORD0F_SWPDIO_EXT)
+                        << SWDPIO__EXT_SHIFT);
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+    }
+
+    /* Call the necessary subroutine to configure the link. */
+    if(shared->media_type == e1000_media_type_fiber)
+        status = e1000_setup_pcs_link(shared, ctrl_reg);
+    else
+        status = e1000_phy_setup(shared, ctrl_reg);
+
+    /* Initialize the flow control address, type, and PAUSE timer
+     * registers to their default values.  This is done even if flow
+     * control is disabled, because it does not hurt anything to
+     * initialize these registers.
+     */
+    DEBUGOUT("Initializing the Flow Control address, type and timer regs\n");
+
+    E1000_WRITE_REG(shared, FCAL, FLOW_CONTROL_ADDRESS_LOW);
+    E1000_WRITE_REG(shared, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
+    E1000_WRITE_REG(shared, FCT, FLOW_CONTROL_TYPE);
+    E1000_WRITE_REG(shared, FCTTV, shared->fc_pause_time);
+
+    /* Set the flow control receive threshold registers.  Normally,
+     * these registers will be set to a default threshold that may be
+     * adjusted later by the driver's runtime code.  However, if the
+     * ability to transmit pause frames in not enabled, then these
+     * registers will be set to 0. 
+     */
+    if(!(shared->fc & e1000_fc_tx_pause)) {
+        E1000_WRITE_REG(shared, FCRTL, 0);
+        E1000_WRITE_REG(shared, FCRTH, 0);
+    } else {
+        /* We need to set up the Receive Threshold high and low water marks
+         * as well as (optionally) enabling the transmission of XON frames.
+         */
+        if(shared->fc_send_xon) {
+            E1000_WRITE_REG(shared, FCRTL,
+                            (shared->fc_low_water | E1000_FCRTL_XONE));
+            E1000_WRITE_REG(shared, FCRTH, shared->fc_high_water);
+        } else {
+            E1000_WRITE_REG(shared, FCRTL, shared->fc_low_water);
+            E1000_WRITE_REG(shared, FCRTH, shared->fc_high_water);
+        }
+    }
+    return (status);
+}
+
+/******************************************************************************
+ * Sets up link for a fiber based adapter
+ *
+ * shared - Struct containing variables accessed by shared code
+ * ctrl_reg - Current value of the device control register
+ *
+ * Manipulates Physical Coding Sublayer functions in order to configure
+ * link. Assumes the hardware has been previously reset and the transmitter
+ * and receiver are not enabled.
+ *****************************************************************************/
+boolean_t
+e1000_setup_pcs_link(struct e1000_shared_adapter *shared,
+                     uint32_t ctrl_reg)
+{
+    uint32_t status_reg;
+    uint32_t tctl_reg;
+    uint32_t txcw_reg = 0;
+    uint32_t i;
+
+    DEBUGFUNC("e1000_setup_pcs_link");
+
+    /* Setup the collsion distance.  Since this is configuring the
+     * TBI it is assumed that we are in Full Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    i = E1000_FDX_COLLISION_DISTANCE;
+    i <<= E1000_COLD_SHIFT;
+    tctl_reg |= i;
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    /* Check for a software override of the flow control settings, and
+     * setup the device accordingly.  If auto-negotiation is enabled,
+     * then software will have to set the "PAUSE" bits to the correct
+     * value in the Tranmsit Config Word Register (TXCW) and re-start
+     * auto-negotiation.  However, if auto-negotiation is disabled,
+     * then software will have to manually configure the two flow
+     * control enable bits in the CTRL register.
+     *
+     * The possible values of the "fc" parameter are:
+     *      0:  Flow control is completely disabled
+     *      1:  Rx flow control is enabled (we can receive pause frames
+     *          but not send pause frames).
+     *      2:  Tx flow control is enabled (we can send pause frames
+     *          but we do not support receiving pause frames).
+     *      3:  Both Rx and TX flow control (symmetric) are enabled.
+     *  other:  No software override.  The flow control configuration
+     *          in the EEPROM is used.
+     */
+    switch (shared->fc) {
+    case e1000_fc_none:        /* 0 */
+        /* Flow control (RX & TX) is completely disabled by a
+         * software over-ride.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD);
+        break;
+    case e1000_fc_rx_pause:    /* 1 */
+        /* RX Flow control is enabled, and TX Flow control is
+         * disabled, by a software over-ride.
+         */
+        /* Since there really isn't a way to advertise that we are
+         * capable of RX Pause ONLY, we will advertise that we
+         * support both symmetric and asymmetric RX PAUSE.  Later
+         * we will disable the adapter's ability to send PAUSE
+         * frames.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+        break;
+    case e1000_fc_tx_pause:    /* 2 */
+        /* TX Flow control is enabled, and RX Flow control is
+         * disabled, by a software over-ride.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
+        break;
+    case e1000_fc_full:        /* 3 */
+        /* Flow control (both RX and TX) is enabled by a software
+         * over-ride.
+         */
+        txcw_reg = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+        break;
+    default:
+        /* We should never get here.  The value should be 0-3. */
+        DEBUGOUT("Flow control param set incorrectly\n");
+        ASSERT(0);
+        break;
+    }
+
+    /* Since auto-negotiation is enabled, take the link out of reset.
+     * (the link will be in reset, because we previously reset the
+     * chip). This will restart auto-negotiation.  If auto-neogtiation
+     * is successful then the link-up status bit will be set and the
+     * flow control enable bits (RFCE and TFCE) will be set according
+     * to their negotiated value.
+     */
+    DEBUGOUT("Auto-negotiation enabled\n");
+
+    E1000_WRITE_REG(shared, TXCW, txcw_reg);
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    shared->txcw_reg = txcw_reg;
+    msec_delay(1);
+
+    /* If we have a signal then poll for a "Link-Up" indication in the
+     * Device Status Register.   Time-out if a link isn't seen in 500
+     * milliseconds seconds (Auto-negotiation should complete in less
+     * than 500 milliseconds even if the other end is doing it in SW).
+     */
+    if(!(E1000_READ_REG(shared, CTRL) & E1000_CTRL_SWDPIN1)) {
+
+        DEBUGOUT("Looking for Link\n");
+        for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
+            msec_delay(10);
+            status_reg = E1000_READ_REG(shared, STATUS);
+            if(status_reg & E1000_STATUS_LU)
+                break;
+        }
+
+        if(i == (LINK_UP_TIMEOUT / 10)) {
+            /* AutoNeg failed to achieve a link, so we'll call the
+             * "CheckForLink" routine.  This routine will force the link
+             * up if we have "signal-detect".  This will allow us to
+             * communicate with non-autonegotiating link partners.
+             */
+            DEBUGOUT("Never got a valid link from auto-neg!!!\n");
+
+            shared->autoneg_failed = 1;
+            e1000_check_for_link(shared);
+            shared->autoneg_failed = 0;
+        } else {
+            shared->autoneg_failed = 0;
+            DEBUGOUT("Valid Link Found\n");
+        }
+    } else {
+        DEBUGOUT("No Signal Detected\n");
+    }
+
+    return (TRUE);
+}
+
+/******************************************************************************
+ * Configures flow control settings after link is established
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Should be called immediately after a valid link has been established.
+ * Forces MAC flow control settings if link was forced. When in MII/GMII mode
+ * and autonegotiation is enabled, the MAC flow control settings will be set
+ * based on the flow control negotiated by the PHY. In TBI mode, the TFCE
+ * and RFCE bits will be automaticaly set to the negotiated flow control mode.
+ *****************************************************************************/
+void
+e1000_config_fc_after_link_up(struct e1000_shared_adapter *shared)
+{
+    uint16_t mii_status_reg;
+    uint16_t mii_nway_adv_reg;
+    uint16_t mii_nway_lp_ability_reg;
+    uint16_t speed;
+    uint16_t duplex;
+
+    DEBUGFUNC("e1000_config_fc_after_link_up");
+
+    /* Check for the case where we have fiber media and auto-neg failed
+     * so we had to force link.  In this case, we need to force the
+     * configuration of the MAC to match the "fc" parameter.
+     */
+    if(((shared->media_type == e1000_media_type_fiber)
+        && (shared->autoneg_failed))
+       || ((shared->media_type == e1000_media_type_copper)
+           && (!shared->autoneg))) {
+        e1000_force_mac_fc(shared);
+    }
+
+    /* Check for the case where we have copper media and auto-neg is
+     * enabled.  In this case, we need to check and see if Auto-Neg
+     * has completed, and if so, how the PHY and link partner has
+     * flow control configured.
+     */
+    if((shared->media_type == e1000_media_type_copper) && shared->autoneg) {
+        /* Read the MII Status Register and check to see if AutoNeg
+         * has completed.  We read this twice because this reg has
+         * some "sticky" (latched) bits.
+         */
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
+            /* The AutoNeg process has completed, so we now need to
+             * read both the Auto Negotiation Advertisement Register
+             * (Address 4) and the Auto_Negotiation Base Page Ability
+             * Register (Address 5) to determine how flow control was
+             * negotiated.
+             */
+            mii_nway_adv_reg = e1000_read_phy_reg(shared,
+                                                  PHY_AUTONEG_ADV);
+            mii_nway_lp_ability_reg = e1000_read_phy_reg(shared,
+                                                         PHY_LP_ABILITY);
+
+            /* Two bits in the Auto Negotiation Advertisement Register
+             * (Address 4) and two bits in the Auto Negotiation Base
+             * Page Ability Register (Address 5) determine flow control
+             * for both the PHY and the link partner.  The following
+             * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,
+             * 1999, describes these PAUSE resolution bits and how flow
+             * control is determined based upon these settings.
+             * NOTE:  DC = Don't Care
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution
+             *-------|---------|-------|---------|--------------------
+             *   0   |    0    |  DC   |   DC    | e1000_fc_none
+             *   0   |    1    |   0   |   DC    | e1000_fc_none
+             *   0   |    1    |   1   |    0    | e1000_fc_none
+             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+             *   1   |    0    |   0   |   DC    | e1000_fc_none
+             *   1   |   DC    |   1   |   DC    | e1000_fc_full
+             *   1   |    1    |   0   |    0    | e1000_fc_none
+             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+             *
+             */
+            /* Are both PAUSE bits set to 1?  If so, this implies
+             * Symmetric Flow Control is enabled at both ends.  The
+             * ASM_DIR bits are irrelevant per the spec.
+             *
+             * For Symmetric Flow Control:
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+             *-------|---------|-------|---------|--------------------
+             *   1   |   DC    |   1   |   DC    | e1000_fc_full
+             *
+             */
+            if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+               (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
+                /* Now we need to check if the user selected RX ONLY
+                 * of pause frames.  In this case, we had to advertise
+                 * FULL flow control because we could not advertise RX
+                 * ONLY. Hence, we must now check to see if we need to
+                 * turn OFF  the TRANSMISSION of PAUSE frames.
+                 */
+                if(shared->original_fc == e1000_fc_full) {
+                    shared->fc = e1000_fc_full;
+                    DEBUGOUT("Flow Control = FULL.\r\n");
+                } else {
+                    shared->fc = e1000_fc_rx_pause;
+                    DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+                }
+            }
+            /* For receiving PAUSE frames ONLY.
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+             *-------|---------|-------|---------|--------------------
+             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+             *
+             */
+            else if(!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+                    (mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+                shared->fc = e1000_fc_tx_pause;
+                DEBUGOUT("Flow Control = TX PAUSE frames only.\r\n");
+            }
+            /* For transmitting PAUSE frames ONLY.
+             *
+             *   LOCAL DEVICE  |   LINK PARTNER
+             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+             *-------|---------|-------|---------|--------------------
+             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+             *
+             */
+            else if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+                    (mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+                    !(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+                    (mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+                shared->fc = e1000_fc_rx_pause;
+                DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+            }
+            /* Per the IEEE spec, at this point flow control should be
+             * disabled.  However, we want to consider that we could
+             * be connected to a legacy switch that doesn't advertise
+             * desired flow control, but can be forced on the link
+             * partner.  So if we advertised no flow control, that is
+             * what we will resolve to.  If we advertised some kind of
+             * receive capability (Rx Pause Only or Full Flow Control)
+             * and the link partner advertised none, we will configure
+             * ourselves to enable Rx Flow Control only.  We can do
+             * this safely for two reasons:  If the link partner really
+             * didn't want flow control enabled, and we enable Rx, no
+             * harm done since we won't be receiving any PAUSE frames
+             * anyway.  If the intent on the link partner was to have
+             * flow control enabled, then by us enabling RX only, we
+             * can at least receive pause frames and process them.
+             * This is a good idea because in most cases, since we are
+             * predominantly a server NIC, more times than not we will
+             * be asked to delay transmission of packets than asking
+             * our link partner to pause transmission of frames.
+             */
+            else if(shared->original_fc == e1000_fc_none ||
+                    shared->original_fc == e1000_fc_tx_pause) {
+                shared->fc = e1000_fc_none;
+                DEBUGOUT("Flow Control = NONE.\r\n");
+            } else {
+                shared->fc = e1000_fc_rx_pause;
+                DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+            }
+
+            /* Now we need to do one last check...  If we auto-
+             * negotiated to HALF DUPLEX, flow control should not be
+             * enabled per IEEE 802.3 spec.
+             */
+            e1000_get_speed_and_duplex(shared, &speed, &duplex);
+
+            if(duplex == HALF_DUPLEX)
+                shared->fc = e1000_fc_none;
+
+            /* Now we call a subroutine to actually force the MAC
+             * controller to use the correct flow control settings.
+             */
+            e1000_force_mac_fc(shared);
+        } else {
+            DEBUGOUT("Copper PHY and Auto Neg has not completed.\r\n");
+        }
+    }
+    return;  
+}
+
+/******************************************************************************
+ * Checks to see if the link status of the hardware has changed.
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Called by any function that needs to check the link status of the adapter.
+ *****************************************************************************/
+void
+e1000_check_for_link(struct e1000_shared_adapter *shared)
+{
+    uint32_t rxcw_reg;
+    uint32_t ctrl_reg;
+    uint32_t status_reg;
+    uint32_t rctl_reg;
+    uint16_t phy_data;
+    uint16_t lp_capability;
+
+    DEBUGFUNC("e1000_check_for_link");
+
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+    status_reg = E1000_READ_REG(shared, STATUS);
+    rxcw_reg = E1000_READ_REG(shared, RXCW);
+
+    /* If we have a copper PHY then we only want to go out to the PHY
+     * registers to see if Auto-Neg has completed and/or if our link
+     * status has changed.  The get_link_status flag will be set if we
+     * receive a Link Status Change interrupt or we have Rx Sequence
+     * Errors.
+     */
+    if(shared->media_type == e1000_media_type_copper
+       && shared->get_link_status) {
+        /* First we want to see if the MII Status Register reports
+         * link.  If so, then we want to get the current speed/duplex
+         * of the PHY.
+         * Read the register twice since the link bit is sticky.
+         */
+        phy_data = e1000_read_phy_reg(shared, PHY_STATUS);
+        phy_data = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        if(phy_data & MII_SR_LINK_STATUS) {
+            shared->get_link_status = FALSE;
+        } else {
+            DEBUGOUT("**** CFL - No link detected. ****\r\n");
+            return;
+        }
+
+        /* If we are forcing speed/duplex, then we simply return since
+         * we have already determined whether we have link or not.
+         */
+        if(!shared->autoneg) {
+            return;
+        }
+
+        switch (shared->phy_id) {
+        case M88E1000_12_PHY_ID:
+        case M88E1000_14_PHY_ID:
+        case M88E1000_I_PHY_ID:
+        case M88E1011_I_PHY_ID:
+            /* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
+             * have Si on board that is 82544 or newer, Auto
+             * Speed Detection takes care of MAC speed/duplex
+             * configuration.  So we only need to configure Collision
+             * Distance in the MAC.  Otherwise, we need to force
+             * speed/duplex on the MAC to the current PHY speed/duplex
+             * settings.
+             */
+            if(shared->mac_type >= e1000_82544) {
+                DEBUGOUT("CFL - Auto-Neg complete.");
+                DEBUGOUT("Configuring Collision Distance.");
+                e1000_config_collision_dist(shared);
+            } else {
+                /* Read the Phy Specific Status register to get the
+                 * resolved speed/duplex settings.  Then call
+                 * e1000_config_mac_to_phy which will retrieve
+                 * PHY register information and configure the MAC to
+                 * equal the negotiated speed/duplex.
+                 */
+                phy_data = e1000_read_phy_reg(shared, 
+                                              M88E1000_PHY_SPEC_STATUS);
+
+                DEBUGOUT1("CFL - Auto-Neg complete.  phy_data = %x\r\n",
+                          phy_data);
+                e1000_config_mac_to_phy(shared, phy_data);
+            }
+
+            /* Configure Flow Control now that Auto-Neg has completed.
+             * We need to first restore the users desired Flow
+             * Control setting since we may have had to re-autoneg
+             * with a different link partner.
+             */
+            e1000_config_fc_after_link_up(shared);
+            break;
+
+        default:
+            DEBUGOUT("CFL - Invalid PHY detected.\r\n");
+
+        } /* end switch statement */
+
+        /* At this point we know that we are on copper, link is up, 
+         * and we are auto-neg'd.  These are pre-conditions for checking
+         * the link parter capabilities register.  We use the link partner
+         * capabilities to determine if TBI Compatibility needs to be turned on
+         * or turned off.  If the link partner advertises any speed in addition
+         * to Gigabit, then we assume that they are GMII-based and TBI 
+         * compatibility is not needed.
+         * If no other speeds are advertised, then we assume the link partner
+         * is TBI-based and we turn on TBI Compatibility.
+         */
+        if(shared->tbi_compatibility_en) {
+            lp_capability = e1000_read_phy_reg(shared, PHY_LP_ABILITY);
+            if(lp_capability & (NWAY_LPAR_10T_HD_CAPS |
+                                NWAY_LPAR_10T_FD_CAPS |
+                                NWAY_LPAR_100TX_HD_CAPS |
+                                NWAY_LPAR_100TX_FD_CAPS |
+                                NWAY_LPAR_100T4_CAPS)) {
+                /* If our link partner advertises below Gig, then they do not
+                 * need the special Tbi Compatibility mode. 
+                 */
+                if(shared->tbi_compatibility_on) {
+                    /* If we previously were in the mode, turn it off, now. */
+                    rctl_reg = E1000_READ_REG(shared, RCTL);
+                    rctl_reg &= ~E1000_RCTL_SBP;
+                    E1000_WRITE_REG(shared, RCTL, rctl_reg);
+                    shared->tbi_compatibility_on = FALSE;
+                }
+            } else {
+                /* If the mode is was previously off, turn it on. 
+                 * For compatibility with a suspected Tbi link partners, 
+                 * we will store bad packets.
+                 * (Certain frames have an additional byte on the end and will 
+                 * look like CRC errors to to the hardware).
+                 */
+                if(!shared->tbi_compatibility_on) {
+                    shared->tbi_compatibility_on = TRUE;
+                    rctl_reg = E1000_READ_REG(shared, RCTL);
+                    rctl_reg |= E1000_RCTL_SBP;
+                    E1000_WRITE_REG(shared, RCTL, rctl_reg);
+                }
+            }
+        }
+    } /* end if e1000_media_type_copper statement */
+    /* If we don't have link (auto-negotiation failed or link partner
+     * cannot auto-negotiate) and the cable is plugged in since we don't
+     * have Loss-Of-Signal (we HAVE a signal) and our link partner is
+     * not trying to AutoNeg with us (we are receiving idles/data
+     * then we need to force our link to connect to a non
+     * auto-negotiating link partner.  We also need to give
+     * auto-negotiation time to complete in case the cable was just
+     * plugged in.  The autoneg_failed flag does this.
+     */
+    else if((shared->media_type == e1000_media_type_fiber) &&  /* Fiber PHY */
+            (!(status_reg & E1000_STATUS_LU)) &&        /* no link and    */
+            (!(ctrl_reg & E1000_CTRL_SWDPIN1)) &&       /* we have signal */
+            (!(rxcw_reg & E1000_RXCW_C))) {     /* and rxing idle/data */
+        if(shared->autoneg_failed == 0) {      /* given AutoNeg time */
+            shared->autoneg_failed = 1;
+            return;
+        }
+
+        DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\r\n");
+
+        /* Disable auto-negotiation in the TXCW register */
+        E1000_WRITE_REG(shared, TXCW, (shared->txcw_reg & ~E1000_TXCW_ANE));
+
+        /* Force link-up and also force full-duplex. */
+        ctrl_reg = E1000_READ_REG(shared, CTRL);
+        ctrl_reg |= (E1000_CTRL_SLU | E1000_CTRL_FD);
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        /* Configure Flow Control after forcing link up. */
+        e1000_config_fc_after_link_up(shared);
+
+    } else if((shared->media_type == e1000_media_type_fiber) && /* Fiber */
+              (ctrl_reg & E1000_CTRL_SLU) &&    /* we have forced link */
+              (rxcw_reg & E1000_RXCW_C)) {      /* and Rxing /C/ ordered sets */
+        /* If we are forcing link and we are receiving /C/ ordered sets,
+         * then re-enable auto-negotiation in the RXCW register and
+         * disable forced link in the Device Control register in an attempt
+         * to AutoNeg with our link partner.
+         */
+        DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\r\n");
+
+        /* Enable auto-negotiation in the TXCW register and stop
+         * forcing link.
+         */
+        E1000_WRITE_REG(shared, TXCW, shared->txcw_reg);
+
+        E1000_WRITE_REG(shared, CTRL, (ctrl_reg & ~E1000_CTRL_SLU));
+    }
+
+    return;
+}
+
+/******************************************************************************
+ * Clears all hardware statistics counters. 
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_clear_hw_cntrs(struct e1000_shared_adapter *shared)
+{
+    volatile uint32_t temp_reg;
+
+    DEBUGFUNC("e1000_clear_hw_cntrs");
+
+    /* if we are stopped or resetting exit gracefully */
+    if(shared->adapter_stopped) {
+        DEBUGOUT("Exiting because the adapter is stopped!!!\n");
+        return;
+    }
+
+    temp_reg = E1000_READ_REG(shared, CRCERRS);
+    temp_reg = E1000_READ_REG(shared, SYMERRS);
+    temp_reg = E1000_READ_REG(shared, MPC);
+    temp_reg = E1000_READ_REG(shared, SCC);
+    temp_reg = E1000_READ_REG(shared, ECOL);
+    temp_reg = E1000_READ_REG(shared, MCC);
+    temp_reg = E1000_READ_REG(shared, LATECOL);
+    temp_reg = E1000_READ_REG(shared, COLC);
+    temp_reg = E1000_READ_REG(shared, DC);
+    temp_reg = E1000_READ_REG(shared, SEC);
+    temp_reg = E1000_READ_REG(shared, RLEC);
+    temp_reg = E1000_READ_REG(shared, XONRXC);
+    temp_reg = E1000_READ_REG(shared, XONTXC);
+    temp_reg = E1000_READ_REG(shared, XOFFRXC);
+    temp_reg = E1000_READ_REG(shared, XOFFTXC);
+    temp_reg = E1000_READ_REG(shared, FCRUC);
+    temp_reg = E1000_READ_REG(shared, PRC64);
+    temp_reg = E1000_READ_REG(shared, PRC127);
+    temp_reg = E1000_READ_REG(shared, PRC255);
+    temp_reg = E1000_READ_REG(shared, PRC511);
+    temp_reg = E1000_READ_REG(shared, PRC1023);
+    temp_reg = E1000_READ_REG(shared, PRC1522);
+    temp_reg = E1000_READ_REG(shared, GPRC);
+    temp_reg = E1000_READ_REG(shared, BPRC);
+    temp_reg = E1000_READ_REG(shared, MPRC);
+    temp_reg = E1000_READ_REG(shared, GPTC);
+    temp_reg = E1000_READ_REG(shared, GORCL);
+    temp_reg = E1000_READ_REG(shared, GORCH);
+    temp_reg = E1000_READ_REG(shared, GOTCL);
+    temp_reg = E1000_READ_REG(shared, GOTCH);
+    temp_reg = E1000_READ_REG(shared, RNBC);
+    temp_reg = E1000_READ_REG(shared, RUC);
+    temp_reg = E1000_READ_REG(shared, RFC);
+    temp_reg = E1000_READ_REG(shared, ROC);
+    temp_reg = E1000_READ_REG(shared, RJC);
+    temp_reg = E1000_READ_REG(shared, TORL);
+    temp_reg = E1000_READ_REG(shared, TORH);
+    temp_reg = E1000_READ_REG(shared, TOTL);
+    temp_reg = E1000_READ_REG(shared, TOTH);
+    temp_reg = E1000_READ_REG(shared, TPR);
+    temp_reg = E1000_READ_REG(shared, TPT);
+    temp_reg = E1000_READ_REG(shared, PTC64);
+    temp_reg = E1000_READ_REG(shared, PTC127);
+    temp_reg = E1000_READ_REG(shared, PTC255);
+    temp_reg = E1000_READ_REG(shared, PTC511);
+    temp_reg = E1000_READ_REG(shared, PTC1023);
+    temp_reg = E1000_READ_REG(shared, PTC1522);
+    temp_reg = E1000_READ_REG(shared, MPTC);
+    temp_reg = E1000_READ_REG(shared, BPTC);
+
+    if(shared->mac_type < e1000_82543)
+        return;
+
+    temp_reg = E1000_READ_REG(shared, ALGNERRC);
+    temp_reg = E1000_READ_REG(shared, RXERRC);
+    temp_reg = E1000_READ_REG(shared, TNCRS);
+    temp_reg = E1000_READ_REG(shared, CEXTERR);
+    temp_reg = E1000_READ_REG(shared, TSCTC);
+    temp_reg = E1000_READ_REG(shared, TSCTFC);
+    return;
+}
+
+/******************************************************************************
+ * Detects the current speed and duplex settings of the hardware.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * speed - Speed of the connection
+ * duplex - Duplex setting of the connection
+ *****************************************************************************/
+void
+e1000_get_speed_and_duplex(struct e1000_shared_adapter *shared,
+                           uint16_t *speed,
+                           uint16_t *duplex)
+{
+    uint32_t status_reg;
+#if DBG
+    uint16_t phy_data;
+#endif
+
+    DEBUGFUNC("e1000_get_speed_and_duplex");
+
+    /* If the adapter is stopped we don't have a speed or duplex */
+    if(shared->adapter_stopped) {
+        *speed = 0;
+        *duplex = 0;
+        return;
+    }
+
+    if(shared->mac_type >= e1000_82543) {
+        status_reg = E1000_READ_REG(shared, STATUS);
+        if(status_reg & E1000_STATUS_SPEED_1000) {
+            *speed = SPEED_1000;
+            DEBUGOUT("1000 Mbs, ");
+        } else if(status_reg & E1000_STATUS_SPEED_100) {
+            *speed = SPEED_100;
+            DEBUGOUT("100 Mbs, ");
+        } else {
+            *speed = SPEED_10;
+            DEBUGOUT("10 Mbs, ");
+        }
+
+        if(status_reg & E1000_STATUS_FD) {
+            *duplex = FULL_DUPLEX;
+            DEBUGOUT("Full Duplex\r\n");
+        } else {
+            *duplex = HALF_DUPLEX;
+            DEBUGOUT(" Half Duplex\r\n");
+        }
+    } else {
+        DEBUGOUT("1000 Mbs, Full Duplex\r\n");
+        *speed = SPEED_1000;
+        *duplex = FULL_DUPLEX;
+    }
+
+#if DBG
+    if(shared->phy_id == M88E1000_12_PHY_ID ||
+       shared->phy_id == M88E1000_14_PHY_ID ||
+       shared->phy_id == M88E1000_I_PHY_ID  ||
+       shared->phy_id == M88E1011_I_PHY_ID) {
+        /* read the phy specific status register */
+        phy_data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+        DEBUGOUT1("M88E1000 Phy Specific Status Reg contents = %x\n", phy_data);
+        phy_data = e1000_read_phy_reg(shared, PHY_STATUS);
+        DEBUGOUT1("Phy MII Status Reg contents = %x\n", phy_data);
+        DEBUGOUT1("Device Status Reg contents = %x\n", 
+                  E1000_READ_REG(shared, STATUS));
+    }
+#endif
+    return;
+}
+
+/******************************************************************************
+ * Reads a 16 bit word from the EEPROM.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * offset - offset of 16 bit word in the EEPROM to read
+ *****************************************************************************/
+uint16_t
+e1000_read_eeprom(struct e1000_shared_adapter *shared,
+                  uint16_t offset)
+{
+    boolean_t large_eeprom = FALSE;
+    uint16_t data;
+    uint32_t eecd_reg;
+    uint32_t tmp = 0;
+
+    if((shared->mac_type > e1000_82544) &&
+       (E1000_READ_REG(shared, EECD) & E1000_EECD_SIZE)) large_eeprom = TRUE;
+    
+    /* Request EEPROM Access */
+    if(shared->mac_type > e1000_82544) {
+        E1000_WRITE_REG(shared, EECD, (uint32_t) E1000_EECD_REQ);
+        eecd_reg = E1000_READ_REG(shared, EECD);
+        while((!(eecd_reg & E1000_EECD_GNT)) && (tmp < 100)) {
+            tmp++;
+            usec_delay(5);
+            eecd_reg = E1000_READ_REG(shared, EECD);
+        }
+        if(!(eecd_reg & E1000_EECD_GNT)) return(FALSE);
+    }
+
+    /*  Prepare the EEPROM for reading  */
+    e1000_setup_eeprom(shared);
+
+    /*  Send the READ command (opcode + addr)  */
+    e1000_shift_out_bits(shared, EEPROM_READ_OPCODE, 3);
+    /* If we have a 256 word EEPROM, there are 8 address bits
+     * if we have a 64 word EEPROM, there are 6 address bits
+     */
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, offset, 8);
+    else
+        e1000_shift_out_bits(shared, offset, 6);
+
+    /* Read the data */
+    data = e1000_shift_in_bits(shared);
+
+    /* End this read operation */
+    e1000_standby_eeprom(shared);
+
+    /* Stop requestiong EEPROM access */
+    if(shared->mac_type > e1000_82544)
+        E1000_WRITE_REG(shared, EECD, (uint32_t) 0);
+
+    return (data);
+}
+
+/******************************************************************************
+ * Verifies that the EEPROM has a valid checksum
+ * 
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Reads the first 64 16 bit words of the EEPROM and sums the values read.
+ * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
+ * valid.
+ *****************************************************************************/
+boolean_t
+e1000_validate_eeprom_checksum(struct e1000_shared_adapter *shared)
+{
+    uint16_t checksum = 0;
+    uint16_t i;
+
+    for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++)
+        checksum += e1000_read_eeprom(shared, i);
+
+    if(checksum == (uint16_t) EEPROM_SUM)
+        return (TRUE);
+    else
+        return (FALSE);
+}
+
+/******************************************************************************
+ * Calculates the EEPROM checksum and writes it to the EEPROM
+ *
+ * shared - Struct containing variables accessed by shared code
+ *
+ * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.
+ * Writes the difference to word offset 63 of the EEPROM.
+ *****************************************************************************/
+void
+e1000_update_eeprom_checksum(struct e1000_shared_adapter *shared)
+{
+    uint16_t checksum = 0;
+    uint16_t i;
+
+    for(i = 0; i < EEPROM_CHECKSUM_REG; i++)
+        checksum += e1000_read_eeprom(shared, i);
+
+    checksum = (uint16_t) EEPROM_SUM - checksum;
+
+    e1000_write_eeprom(shared, EEPROM_CHECKSUM_REG, checksum);
+    return;
+}
+
+/******************************************************************************
+ * Writes a 16 bit word to a given offset in the EEPROM.
+ *
+ * shared - Struct containing variables accessed by shared code
+ * offset - offset within the EEPROM to be written to
+ * data - 16 bit word to be writen to the EEPROM
+ *
+ * If e1000_update_eeprom_checksum is not called after this function, the 
+ * EEPROM will most likely contain an invalid checksum.
+ *****************************************************************************/
+boolean_t
+e1000_write_eeprom(struct e1000_shared_adapter *shared,
+                   uint16_t offset,
+                   uint16_t data)
+{
+    boolean_t large_eeprom = FALSE;
+    uint32_t eecd_reg;
+    uint32_t tmp = 0;
+
+    if((shared->mac_type > e1000_82544) &&
+       (E1000_READ_REG(shared, EECD) & E1000_EECD_SIZE)) large_eeprom = TRUE;
+    
+    /* Request EEPROM Access */
+    if(shared->mac_type > e1000_82544) {
+        E1000_WRITE_REG(shared, EECD, (uint32_t) E1000_EECD_REQ);
+        eecd_reg = E1000_READ_REG(shared, EECD);
+        while((!(eecd_reg & E1000_EECD_GNT)) && (tmp < 100)) {
+            tmp++;
+            usec_delay(5);
+            eecd_reg = E1000_READ_REG(shared, EECD);
+        }
+        if(!(eecd_reg & E1000_EECD_GNT)) return(FALSE);
+    }
+
+    /* Prepare the EEPROM for writing  */
+    e1000_setup_eeprom(shared);
+
+    /* Send the 9-bit (or 11-bit on large EEPROM) EWEN (write enable) 
+     * command to the EEPROM (5-bit opcode plus 4/6-bit dummy).
+     * This puts the EEPROM into write/erase mode. 
+     */
+    e1000_shift_out_bits(shared, EEPROM_EWEN_OPCODE, 5);
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, 0, 6);
+    else
+        e1000_shift_out_bits(shared, 0, 4);
+
+    /* Prepare the EEPROM */
+    e1000_standby_eeprom(shared);
+
+    /* Send the Write command (3-bit opcode + addr) */
+    e1000_shift_out_bits(shared, EEPROM_WRITE_OPCODE, 3);
+    /* If we have a 256 word EEPROM, there are 8 address bits
+     * if we have a 64 word EEPROM, there are 6 address bits
+     */
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, offset, 8);
+    else
+        e1000_shift_out_bits(shared, offset, 6);
+
+    /* Send the data */
+    e1000_shift_out_bits(shared, data, 16);
+    e1000_wait_eeprom_command(shared);
+
+    /* Recover from write */
+    e1000_standby_eeprom(shared);
+
+    /* Send the 9-bit  (or 11-bit on large EEPROM) EWDS (write disable) 
+     * command to the EEPROM (5-bit opcode plus 4/6-bit dummy).
+     * This takes the EEPROM out of write/erase mode.
+     */
+    e1000_shift_out_bits(shared, EEPROM_EWDS_OPCODE, 5);
+    if(large_eeprom) 
+        e1000_shift_out_bits(shared, 0, 6);
+    else
+        e1000_shift_out_bits(shared, 0, 4);
+
+    /* Done with writing */
+    e1000_cleanup_eeprom(shared);
+
+    /* Stop requestiong EEPROM access */
+    if(shared->mac_type > e1000_82544)
+        E1000_WRITE_REG(shared, EECD, (uint32_t) 0);
+
+    return (TRUE);
+}
+
+/******************************************************************************
+ * Reads the adapter's part number from the EEPROM
+ *
+ * shared - Struct containing variables accessed by shared code
+ * part_num - Adapter's part number
+ *****************************************************************************/
+boolean_t
+e1000_read_part_num(struct e1000_shared_adapter *shared,
+                    uint32_t *part_num)
+{
+    uint16_t eeprom_word;
+
+    DEBUGFUNC("e1000_read_part_num");
+
+    /* Don't read the EEPROM if we are stopped */
+    if(shared->adapter_stopped) {
+        *part_num = 0;
+        return (FALSE);
+    }
+
+    /* Get word 0 from EEPROM */
+    eeprom_word = e1000_read_eeprom(shared, (uint16_t) (EEPROM_PBA_BYTE_1));
+
+    DEBUGOUT("Read first part number word\n");
+
+    /* Save word 0 in upper half is PartNumber */
+    *part_num = (uint32_t) eeprom_word;
+    *part_num = *part_num << 16;
+
+    /* Get word 1 from EEPROM */
+    eeprom_word =
+        e1000_read_eeprom(shared, (uint16_t) (EEPROM_PBA_BYTE_1 + 1));
+
+    DEBUGOUT("Read second part number word\n");
+
+    /* Save word 1 in lower half of PartNumber */
+    *part_num |= eeprom_word;
+
+    /* read a valid part number */
+    return (TRUE);
+}
+
+/******************************************************************************
+ * Turns on the software controllable LED
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_led_on(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+
+    /* if we're stopped don't touch the hardware */
+    if(shared->adapter_stopped)
+        return;
+
+    /* Read the content of the device control reg */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set the LED control pin to an output */
+    ctrl_reg |= E1000_CTRL_SWDPIO0;
+
+    /* Drive it high on normal boards, low on low profile boards */
+    if(shared->low_profile)
+        ctrl_reg &= ~E1000_CTRL_SWDPIN0;
+    else
+        ctrl_reg |= E1000_CTRL_SWDPIN0;
+
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    return;
+}
+
+/******************************************************************************
+ * Turns off the software controllable LED
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_led_off(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+
+    /* if we're stopped don't touch the hardware */
+    if(shared->adapter_stopped)
+        return;
+
+    /* Read the content of the device control reg */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set the LED control pin to an output */
+    ctrl_reg |= E1000_CTRL_SWDPIO0;
+
+    /* Drive it low on normal boards, high on low profile boards */
+    if(shared->low_profile)
+        ctrl_reg |= E1000_CTRL_SWDPIN0;
+    else
+        ctrl_reg &= ~E1000_CTRL_SWDPIN0;
+
+    /* Write the device control reg. back  */
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    return;
+}
+
+/******************************************************************************
+ * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT
+ * 
+ * shared - Struct containing variables accessed by shared code
+ * frame_len - The length of the frame in question
+ * mac_addr - The Ethernet destination address of the frame in question
+ *****************************************************************************/
+uint32_t
+e1000_tbi_adjust_stats(struct e1000_shared_adapter *shared,
+                       struct e1000_shared_stats *stats,
+                       uint32_t frame_len,
+                       uint8_t *mac_addr)
+{
+    uint64_t carry_bit;
+
+    /* First adjust the frame length. */
+    frame_len--;
+    /* We need to adjust the statistics counters, since the hardware
+     * counters overcount this packet as a CRC error and undercount
+     * the packet as a good packet
+     */
+    /* This packet should not be counted as a CRC error.    */
+    stats->crcerrs--;
+    /* This packet does count as a Good Packet Received.    */
+    stats->gprc++;
+
+    /* Adjust the Good Octets received counters             */
+    carry_bit = 0x80000000 & stats->gorcl;
+    stats->gorcl += frame_len;
+    /* If the high bit of Gorcl (the low 32 bits of the Good Octets
+     * Received Count) was one before the addition, 
+     * AND it is zero after, then we lost the carry out, 
+     * need to add one to Gorch (Good Octets Received Count High).
+     * This could be simplified if all environments supported 
+     * 64-bit integers.
+     */
+    if(carry_bit && ((stats->gorcl & 0x80000000) == 0))
+        stats->gorch++;
+    /* Is this a broadcast or multicast?  Check broadcast first,
+     * since the test for a multicast frame will test positive on 
+     * a broadcast frame.
+     */
+    if((mac_addr[0] == (uint8_t) 0xff) && (mac_addr[1] == (uint8_t) 0xff))
+        /* Broadcast packet */
+        stats->bprc++;
+    else if(*mac_addr & 0x01)
+        /* Multicast packet */
+        stats->mprc++;
+
+    if(frame_len == shared->max_frame_size) {
+        /* In this case, the hardware has overcounted the number of
+         * oversize frames.
+         */
+        if(stats->roc > 0)
+            stats->roc--;
+    }
+
+    /* Adjust the bin counters when the extra byte put the frame in the
+     * wrong bin. Remember that the frame_len was adjusted above.
+     */
+    if(frame_len == 64) {
+        stats->prc64++;
+        stats->prc127--;
+    } else if(frame_len == 127) {
+        stats->prc127++;
+        stats->prc255--;
+    } else if(frame_len == 255) {
+        stats->prc255++;
+        stats->prc511--;
+    } else if(frame_len == 511) {
+        stats->prc511++;
+        stats->prc1023--;
+    } else if(frame_len == 1023) {
+        stats->prc1023++;
+        stats->prc1522--;
+    } else if(frame_len == 1522) {
+        stats->prc1522++;
+    }
+    return frame_len;
+}
+
+/******************************************************************************
+ * Gets the current PCI bus type, speed, and width of the hardware
+ *
+ * shared - Struct containing variables accessed by shared code
+ *****************************************************************************/
+void
+e1000_get_bus_info(struct e1000_shared_adapter *shared)
+{
+    uint32_t status_reg;
+
+    if(shared->mac_type < e1000_82543) {
+        shared->bus_type = e1000_bus_type_unknown;
+        shared->bus_speed = e1000_bus_speed_unknown;
+        shared->bus_width = e1000_bus_width_unknown;
+        return;
+    }
+
+    status_reg = E1000_READ_REG(shared, STATUS);
+
+    shared->bus_type = (status_reg & E1000_STATUS_PCIX_MODE) ?
+        e1000_bus_type_pcix : e1000_bus_type_pci;
+
+    if(shared->bus_type == e1000_bus_type_pci) {
+        shared->bus_speed = (status_reg & E1000_STATUS_PCI66) ?
+            e1000_bus_speed_66 : e1000_bus_speed_33;
+    } else {
+        switch (status_reg & E1000_STATUS_PCIX_SPEED) {
+        case E1000_STATUS_PCIX_SPEED_66:
+            shared->bus_speed = e1000_bus_speed_66;
+            break;
+        case E1000_STATUS_PCIX_SPEED_100:
+            shared->bus_speed = e1000_bus_speed_100;
+            break;
+        case E1000_STATUS_PCIX_SPEED_133:
+            shared->bus_speed = e1000_bus_speed_133;
+            break;
+        default:
+            shared->bus_speed = e1000_bus_speed_reserved;
+            break;
+        }
+    }
+
+    shared->bus_width = (status_reg & E1000_STATUS_BUS64) ?
+        e1000_bus_width_64 : e1000_bus_width_32;
+
+    return;
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_mac.h linux/drivers/net/e1000/e1000_mac.h
--- ../ia64/linux/drivers/net/e1000/e1000_mac.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_mac.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,1381 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_mac.h
+ * Structures, enums, and macros for the MAC
+ */
+
+#ifndef _E1000_MAC_H_
+#define _E1000_MAC_H_
+
+#include "e1000_osdep.h"
+
+/* Forward declarations of structures used by the shared code */
+struct e1000_shared_adapter;
+struct e1000_shared_stats;
+
+/* Enumerated types specific to the e1000 hardware */
+/* Media Access Controlers */
+typedef enum {
+    e1000_82542_rev2_0 = 0,
+    e1000_82542_rev2_1,
+    e1000_82543,
+    e1000_82544,
+    e1000_82540,
+    e1000_num_macs
+} e1000_mac_type;
+
+/* Media Types */
+typedef enum {
+    e1000_media_type_copper = 0,
+    e1000_media_type_fiber = 1,
+    e1000_num_media_types
+} e1000_media_type;
+
+typedef enum {
+    e1000_10_half = 0,
+    e1000_10_full = 1,
+    e1000_100_half = 2,
+    e1000_100_full = 3
+} e1000_speed_duplex_type;
+
+/* Flow Control Settings */
+typedef enum {
+    e1000_fc_none = 0,
+    e1000_fc_rx_pause = 1,
+    e1000_fc_tx_pause = 2,
+    e1000_fc_full = 3,
+    e1000_fc_default = 0xFF
+} e1000_fc_type;
+
+/* PCI bus types */
+typedef enum {
+    e1000_bus_type_unknown = 0,
+    e1000_bus_type_pci,
+    e1000_bus_type_pcix
+} e1000_bus_type;
+
+/* PCI bus speeds */
+typedef enum {
+    e1000_bus_speed_unknown = 0,
+    e1000_bus_speed_33,
+    e1000_bus_speed_66,
+    e1000_bus_speed_100,
+    e1000_bus_speed_133,
+    e1000_bus_speed_reserved
+} e1000_bus_speed;
+
+/* PCI bus widths */
+typedef enum {
+    e1000_bus_width_unknown = 0,
+    e1000_bus_width_32,
+    e1000_bus_width_64
+} e1000_bus_width;
+
+
+
+/* Function prototypes */
+/* Setup */
+void e1000_adapter_stop(struct e1000_shared_adapter *shared);
+boolean_t e1000_init_hw(struct e1000_shared_adapter *shared);
+void e1000_init_rx_addrs(struct e1000_shared_adapter *shared);
+
+/* Filters (multicast, vlan, receive) */
+void e1000_mc_addr_list_update(struct e1000_shared_adapter *shared, uint8_t * mc_addr_list, uint32_t mc_addr_count, uint32_t pad);
+uint32_t e1000_hash_mc_addr(struct e1000_shared_adapter *shared, uint8_t * mc_addr);
+void e1000_mta_set(struct e1000_shared_adapter *shared, uint32_t hash_value);
+void e1000_rar_set(struct e1000_shared_adapter *shared, uint8_t * mc_addr, uint32_t rar_index);
+void e1000_write_vfta(struct e1000_shared_adapter *shared, uint32_t offset, uint32_t value);
+void e1000_clear_vfta(struct e1000_shared_adapter *shared);
+
+/* Link layer setup functions */
+boolean_t e1000_setup_fc_and_link(struct e1000_shared_adapter *shared);
+boolean_t e1000_setup_pcs_link(struct e1000_shared_adapter *shared, uint32_t dev_ctrl_reg);
+void e1000_config_fc_after_link_up(struct e1000_shared_adapter *shared);
+void e1000_check_for_link(struct e1000_shared_adapter *shared);
+void e1000_get_speed_and_duplex(struct e1000_shared_adapter *shared, uint16_t * speed, uint16_t * duplex);
+
+/* EEPROM Functions */
+uint16_t e1000_read_eeprom(struct e1000_shared_adapter *shared, uint16_t reg);
+boolean_t e1000_validate_eeprom_checksum(struct e1000_shared_adapter *shared);
+void e1000_update_eeprom_checksum(struct e1000_shared_adapter *shared);
+boolean_t e1000_write_eeprom(struct e1000_shared_adapter *shared, uint16_t reg, uint16_t data);
+
+/* Everything else */
+void e1000_clear_hw_cntrs(struct e1000_shared_adapter *shared);
+boolean_t e1000_read_part_num(struct e1000_shared_adapter *shared, uint32_t * part_num);
+void e1000_led_on(struct e1000_shared_adapter *shared);
+void e1000_led_off(struct e1000_shared_adapter *shared);
+void e1000_get_bus_info(struct e1000_shared_adapter *shared);
+uint32_t e1000_tbi_adjust_stats(struct e1000_shared_adapter *shared, struct e1000_shared_stats *stats, uint32_t frame_len, uint8_t * mac_addr);
+void e1000_write_pci_cfg(struct e1000_shared_adapter *shared, uint32_t reg, uint16_t * value);
+
+/* PCI Device IDs */
+#define E1000_DEV_ID_82542          0x1000
+#define E1000_DEV_ID_82543GC_FIBER  0x1001
+#define E1000_DEV_ID_82543GC_COPPER 0x1004
+#define E1000_DEV_ID_82544EI_COPPER 0x1008
+#define E1000_DEV_ID_82544EI_FIBER  0x1009
+#define E1000_DEV_ID_82544GC_COPPER 0x100C
+#define E1000_DEV_ID_82544GC_LOM    0x100D
+#define E1000_DEV_ID_82540EM        0x100E
+#define NUM_DEV_IDS 8
+
+#define NODE_ADDRESS_SIZE 6
+#define ETH_LENGTH_OF_ADDRESS 6
+
+/* MAC decode size is 128K - This is the size of BAR0 */
+#define MAC_DECODE_SIZE (128 * 1024)
+
+#define E1000_82542_2_0_REV_ID 2
+#define E1000_82542_2_1_REV_ID 3
+
+#define SPEED_10    10
+#define SPEED_100   100
+#define SPEED_1000  1000
+#define HALF_DUPLEX 1
+#define FULL_DUPLEX 2
+
+/* The sizes (in bytes) of a ethernet packet */
+#define ENET_HEADER_SIZE             14
+#define MAXIMUM_ETHERNET_PACKET_SIZE 1514 /* Without FCS */
+#define MINIMUM_ETHERNET_PACKET_SIZE 60   /* Without FCS */
+#define CRC_LENGTH                   4
+#define MAX_JUMBO_FRAME_SIZE         0x3F00
+
+
+/* 802.1q VLAN Packet Sizes */
+#define VLAN_TAG_SIZE                     4     /* 802.3ac tag (not DMAed) */
+
+/* Ethertype field values */
+#define ETHERNET_IEEE_VLAN_TYPE 0x8100  /* 802.3ac packet */
+#define ETHERNET_IP_TYPE        0x0800  /* IP packets */
+#define ETHERNET_ARP_TYPE       0x0806  /* Address Resolution Protocol (ARP) */
+
+/* Packet Header defines */
+#define IP_PROTOCOL_TCP    6
+#define IP_PROTOCOL_UDP    0x11
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error 
+ */
+#define POLL_IMS_ENABLE_MASK ( \
+    E1000_IMS_RXDMT0 |         \
+    E1000_IMS_RXSEQ)
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXT0   = Receiver Timer Interrupt (ring 0)
+ *   o TXDW   = Transmit Descriptor Written Back
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error
+ *   o LSC    = Link Status Change
+ */
+#define IMS_ENABLE_MASK ( \
+    E1000_IMS_RXT0   |    \
+    E1000_IMS_TXDW   |    \
+    E1000_IMS_RXDMT0 |    \
+    E1000_IMS_RXSEQ  |    \
+    E1000_IMS_LSC)
+
+/* The number of high/low register pairs in the RAR. The RAR (Receive Address
+ * Registers) holds the directed and multicast addresses that we monitor. We
+ * reserve one of these spots for our directed address, allowing us room for
+ * E1000_RAR_ENTRIES - 1 multicast addresses. 
+ */
+#define E1000_RAR_ENTRIES 16
+
+#define MIN_NUMBER_OF_DESCRIPTORS 8
+#define MAX_NUMBER_OF_DESCRIPTORS 0xFFF8
+
+/* Receive Descriptor */
+struct e1000_rx_desc {
+    uint64_t buffer_addr; /* Address of the descriptor's data buffer */
+    uint16_t length;     /* Length of data DMAed into data buffer */
+    uint16_t csum;       /* Packet checksum */
+    uint8_t status;      /* Descriptor status */
+    uint8_t errors;      /* Descriptor Errors */
+    uint16_t special;
+};
+
+/* Receive Decriptor bit definitions */
+#define E1000_RXD_STAT_DD       0x01    /* Descriptor Done */
+#define E1000_RXD_STAT_EOP      0x02    /* End of Packet */
+#define E1000_RXD_STAT_IXSM     0x04    /* Ignore checksum */
+#define E1000_RXD_STAT_VP       0x08    /* IEEE VLAN Packet */
+#define E1000_RXD_STAT_TCPCS    0x20    /* TCP xsum calculated */
+#define E1000_RXD_STAT_IPCS     0x40    /* IP xsum calculated */
+#define E1000_RXD_STAT_PIF      0x80    /* passed in-exact filter */
+#define E1000_RXD_ERR_CE        0x01    /* CRC Error */
+#define E1000_RXD_ERR_SE        0x02    /* Symbol Error */
+#define E1000_RXD_ERR_SEQ       0x04    /* Sequence Error */
+#define E1000_RXD_ERR_CXE       0x10    /* Carrier Extension Error */
+#define E1000_RXD_ERR_TCPE      0x20    /* TCP/UDP Checksum Error */
+#define E1000_RXD_ERR_IPE       0x40    /* IP Checksum Error */
+#define E1000_RXD_ERR_RXE       0x80    /* Rx Data Error */
+#define E1000_RXD_SPC_VLAN_MASK 0x0FFF  /* VLAN ID is in lower 12 bits */
+#define E1000_RXD_SPC_PRI_MASK  0xE000  /* Priority is in upper 3 bits */
+#define E1000_RXD_SPC_PRI_SHIFT 0x000D  /* Priority is in upper 3 of 16 */
+#define E1000_RXD_SPC_CFI_MASK  0x1000  /* CFI is bit 12 */
+#define E1000_RXD_SPC_CFI_SHIFT 0x000C  /* CFI is bit 12 */
+
+/* mask to determine if packets should be dropped due to frame errors */
+#define E1000_RXD_ERR_FRAME_ERR_MASK ( \
+    E1000_RXD_ERR_CE  |                \
+    E1000_RXD_ERR_SE  |                \
+    E1000_RXD_ERR_SEQ |                \
+    E1000_RXD_ERR_CXE |                \
+    E1000_RXD_ERR_RXE)
+
+/* Transmit Descriptor */
+struct e1000_tx_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's data buffer */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t cso;        /* Checksum offset */
+            uint8_t cmd;        /* Descriptor control */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t css;        /* Checksum start */
+            uint16_t special;
+        } fields;
+    } upper;
+};
+
+/* Transmit Descriptor bit definitions */
+#define E1000_TXD_DTYP_D     0x00100000 /* Data Descriptor */
+#define E1000_TXD_DTYP_C     0x00000000 /* Context Descriptor */
+#define E1000_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
+#define E1000_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
+#define E1000_TXD_CMD_EOP    0x01000000 /* End of Packet */
+#define E1000_TXD_CMD_IFCS   0x02000000 /* Insert FCS (Ethernet CRC) */
+#define E1000_TXD_CMD_IC     0x04000000 /* Insert Checksum */
+#define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+#define E1000_TXD_CMD_RPS    0x10000000 /* Report Packet Sent */
+#define E1000_TXD_CMD_DEXT   0x20000000 /* Descriptor extension (0 = legacy) */
+#define E1000_TXD_CMD_VLE    0x40000000 /* Add VLAN tag */
+#define E1000_TXD_CMD_IDE    0x80000000 /* Enable Tidv register */
+#define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+#define E1000_TXD_STAT_EC    0x00000002 /* Excess Collisions */
+#define E1000_TXD_STAT_LC    0x00000004 /* Late Collisions */
+#define E1000_TXD_STAT_TU    0x00000008 /* Transmit underrun */
+#define E1000_TXD_CMD_TCP    0x01000000 /* TCP packet */
+#define E1000_TXD_CMD_IP     0x02000000 /* IP packet */
+#define E1000_TXD_CMD_TSE    0x04000000 /* TCP Seg enable */
+#define E1000_TXD_STAT_TC    0x00000004 /* Tx Underrun */
+
+/* Offload Context Descriptor */
+struct e1000_context_desc {
+    union {
+        uint32_t ip_config;
+        struct {
+            uint8_t ipcss;      /* IP checksum start */
+            uint8_t ipcso;      /* IP checksum offset */
+            uint16_t ipcse;     /* IP checksum end */
+        } ip_fields;
+    } lower_setup;
+    union {
+        uint32_t tcp_config;
+        struct {
+            uint8_t tucss;      /* TCP checksum start */
+            uint8_t tucso;      /* TCP checksum offset */
+            uint16_t tucse;     /* TCP checksum end */
+        } tcp_fields;
+    } upper_setup;
+    uint32_t cmd_and_length;    /* */
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t hdr_len;    /* Header length */
+            uint16_t mss;       /* Maximum segment size */
+        } fields;
+    } tcp_seg_setup;
+};
+
+/* Offload data descriptor */
+struct e1000_data_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's buffer address */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t typ_len_ext;        /* */
+            uint8_t cmd;        /* */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t popts;      /* Packet Options */
+            uint16_t special;   /* */
+        } fields;
+    } upper;
+};
+
+/* Filters */
+#define E1000_NUM_UNICAST          16   /* Unicast filter entries */
+#define E1000_MC_TBL_SIZE          128  /* Multicast Filter Table (4096 bits) */
+#define E1000_VLAN_FILTER_TBL_SIZE 128  /* VLAN Filter Table (4096 bits) */
+
+
+/* Receive Address Register */
+struct e1000_rar {
+    volatile uint32_t low;      /* receive address low */
+    volatile uint32_t high;     /* receive address high */
+};
+
+/* The number of entries in the Multicast Table Array (MTA). */
+#define E1000_NUM_MTA_REGISTERS 128
+
+/* IPv4 Address Table Entry */
+struct e1000_ipv4_at_entry {
+    volatile uint32_t ipv4_addr;        /* IP Address (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four wakeup IP addresses are supported */
+#define E1000_WAKEUP_IP_ADDRESS_COUNT_MAX 4
+#define E1000_IP4AT_SIZE                  E1000_WAKEUP_IP_ADDRESS_COUNT_MAX
+#define E1000_IP6AT_SIZE                  1
+
+/* IPv6 Address Table Entry */
+struct e1000_ipv6_at_entry {
+    volatile uint8_t ipv6_addr[16];
+};
+
+/* Flexible Filter Length Table Entry */
+struct e1000_fflt_entry {
+    volatile uint32_t length;   /* Flexible Filter Length (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Mask Table Entry */
+struct e1000_ffmt_entry {
+    volatile uint32_t mask;     /* Flexible Filter Mask (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Value Table Entry */
+struct e1000_ffvt_entry {
+    volatile uint32_t value;    /* Flexible Filter Value (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four Flexible Filters are supported */
+#define E1000_FLEXIBLE_FILTER_COUNT_MAX 4
+
+/* Each Flexible Filter is at most 128 (0x80) bytes in length */
+#define E1000_FLEXIBLE_FILTER_SIZE_MAX  128
+
+#define E1000_FFLT_SIZE E1000_FLEXIBLE_FILTER_COUNT_MAX
+#define E1000_FFMT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+#define E1000_FFVT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+
+/* Register Set. (82543, 82544)
+ *
+ * Registers are defined to be 32 bits and  should be accessed as 32 bit values.
+ * These registers are physically located on the NIC, but are mapped into the 
+ * host memory address space.
+ *
+ * RW - register is both readable and writable
+ * RO - register is read only
+ * WO - register is write only
+ * R/clr - register is read only and is cleared when read
+ * A - register array
+ */
+#define E1000_CTRL     0x00000  /* Device Control - RW */
+#define E1000_STATUS   0x00008  /* Device Status - RO */
+#define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
+#define E1000_EERD     0x00014  /* EEPROM Read - RW */
+#define E1000_CTRL_EXT 0x00018  /* Extended Device Control - RW */
+#define E1000_MDIC     0x00020  /* MDI Control - RW */
+#define E1000_FCAL     0x00028  /* Flow Control Address Low - RW */
+#define E1000_FCAH     0x0002C  /* Flow Control Address High -RW */
+#define E1000_FCT      0x00030  /* Flow Control Type - RW */
+#define E1000_VET      0x00038  /* VLAN Ether Type - RW */
+#define E1000_ICR      0x000C0  /* Interrupt Cause Read - R/clr */
+#define E1000_ITR      0x000C4  /* Interrupt Throttling Rate - RW */
+#define E1000_ICS      0x000C8  /* Interrupt Cause Set - WO */
+#define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
+#define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
+#define E1000_RCTL     0x00100  /* RX Control - RW */
+#define E1000_FCTTV    0x00170  /* Flow Control Transmit Timer Value - RW */
+#define E1000_TXCW     0x00178  /* TX Configuration Word - RW */
+#define E1000_RXCW     0x00180  /* RX Configuration Word - RO */
+#define E1000_TCTL     0x00400  /* TX Control - RW */
+#define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
+#define E1000_TBT      0x00448  /* TX Burst Timer - RW */
+#define E1000_LEDCTL   0x00E00  /* LED Control - RW */
+#define E1000_PBA      0x01000  /* Packet Buffer Allocation - RW */
+#define E1000_FCRTL    0x02160  /* Flow Control Receive Threshold Low - RW */
+#define E1000_FCRTH    0x02168  /* Flow Control Receive Threshold High - RW */
+#define E1000_RDBAL    0x02800  /* RX Descriptor Base Address Low - RW */
+#define E1000_RDBAH    0x02804  /* RX Descriptor Base Address High - RW */
+#define E1000_RDLEN    0x02808  /* RX Descriptor Length - RW */
+#define E1000_RDH      0x02810  /* RX Descriptor Head - RW */
+#define E1000_RDT      0x02818  /* RX Descriptor Tail - RW */
+#define E1000_RDTR     0x02820  /* RX Delay Timer - RW */
+#define E1000_RXDCTL   0x02828  /* RX Descriptor Control - RW */
+#define E1000_RADV     0x0282C  /* RX Interrupt Absolute Delay Timer - RW */
+#define E1000_RSRPD    0x02C00  /* RX Small Packet Detect - RW */
+#define E1000_TXDMAC   0x03000  /* TX DMA Control - RW */
+#define E1000_TDBAL    0x03800  /* TX Descriptor Base Address Low - RW */
+#define E1000_TDBAH    0x03804  /* TX Descriptor Base Address High - RW */
+#define E1000_TDLEN    0x03808  /* TX Descriptor Length - RW */
+#define E1000_TDH      0x03810  /* TX Descriptor Head - RW */
+#define E1000_TDT      0x03818  /* TX Descripotr Tail - RW */
+#define E1000_TIDV     0x03820  /* TX Interrupt Delay Value - RW */
+#define E1000_TXDCTL   0x03828  /* TX Descriptor Control - RW */
+#define E1000_TADV     0x0382C  /* TX Interrupt Absolute Delay Val - RW */
+#define E1000_TSPMT    0x03830  /* TCP Segmentation PAD & Min Threshold - RW */
+#define E1000_CRCERRS  0x04000  /* CRC Error Count - R/clr */
+#define E1000_ALGNERRC 0x04004  /* Alignment Error Count - R/clr */
+#define E1000_SYMERRS  0x04008  /* Symbol Error Count - R/clr */
+#define E1000_RXERRC   0x0400C  /* Receive Error Count - R/clr */
+#define E1000_MPC      0x04010  /* Missed Packet Count - R/clr */
+#define E1000_SCC      0x04014  /* Single Collision Count - R/clr */
+#define E1000_ECOL     0x04018  /* Excessive Collision Count - R/clr */
+#define E1000_MCC      0x0401C  /* Multiple Collision Count - R/clr */
+#define E1000_LATECOL  0x04020  /* Late Collision Count - R/clr */
+#define E1000_COLC     0x04028  /* Collision Count - R/clr */
+#define E1000_DC       0x04030  /* Defer Count - R/clr */
+#define E1000_TNCRS    0x04034  /* TX-No CRS - R/clr */
+#define E1000_SEC      0x04038  /* Sequence Error Count - R/clr */
+#define E1000_CEXTERR  0x0403C  /* Carrier Extension Error Count - R/clr */
+#define E1000_RLEC     0x04040  /* Receive Length Error Count - R/clr */
+#define E1000_XONRXC   0x04048  /* XON RX Count - R/clr */
+#define E1000_XONTXC   0x0404C  /* XON TX Count - R/clr */
+#define E1000_XOFFRXC  0x04050  /* XOFF RX Count - R/clr */
+#define E1000_XOFFTXC  0x04054  /* XOFF TX Count - R/clr */
+#define E1000_FCRUC    0x04058  /* Flow Control RX Unsupported Count- R/clr */
+#define E1000_PRC64    0x0405C  /* Packets RX (64 bytes) - R/clr */
+#define E1000_PRC127   0x04060  /* Packets RX (65-127 bytes) - R/clr */
+#define E1000_PRC255   0x04064  /* Packets RX (128-255 bytes) - R/clr */
+#define E1000_PRC511   0x04068  /* Packets RX (255-511 bytes) - R/clr */
+#define E1000_PRC1023  0x0406C  /* Packets RX (512-1023 bytes) - R/clr */
+#define E1000_PRC1522  0x04070  /* Packets RX (1024-1522 bytes) - R/clr */
+#define E1000_GPRC     0x04074  /* Good Packets RX Count - R/clr */
+#define E1000_BPRC     0x04078  /* Broadcast Packets RX Count - R/clr */
+#define E1000_MPRC     0x0407C  /* Multicast Packets RX Count - R/clr */
+#define E1000_GPTC     0x04080  /* Good Packets TX Count - R/clr */
+#define E1000_GORCL    0x04088  /* Good Octets RX Count Low - R/clr */
+#define E1000_GORCH    0x0408C  /* Good Octets RX Count High - R/clr */
+#define E1000_GOTCL    0x04090  /* Good Octets TX Count Low - R/clr */
+#define E1000_GOTCH    0x04094  /* Good Octets TX Count High - R/clr */
+#define E1000_RNBC     0x040A0  /* RX No Buffers Count - R/clr */
+#define E1000_RUC      0x040A4  /* RX Undersize Count - R/clr */
+#define E1000_RFC      0x040A8  /* RX Fragment Count - R/clr */
+#define E1000_ROC      0x040AC  /* RX Oversize Count - R/clr */
+#define E1000_RJC      0x040B0  /* RX Jabber Count - R/clr */
+#define E1000_MGTPRC   0x040B4  /* Management Packets RX Count - R/clr */
+#define E1000_MGTPDC   0x040B8  /* Management Packets Dropped Count - R/clr */
+#define E1000_MGTPTC   0x040BC  /* Management Packets TX Count - R/clr */
+#define E1000_TORL     0x040C0  /* Total Octets RX Low - R/clr */
+#define E1000_TORH     0x040C4  /* Total Octets RX High - R/clr */
+#define E1000_TOTL     0x040C8  /* Total Octets TX Low - R/clr */
+#define E1000_TOTH     0x040CC  /* Total Octets TX High - R/clr */
+#define E1000_TPR      0x040D0  /* Total Packets RX - R/clr */
+#define E1000_TPT      0x040D4  /* Total Packets TX - R/clr */
+#define E1000_PTC64    0x040D8  /* Packets TX (64 bytes) - R/clr */
+#define E1000_PTC127   0x040DC  /* Packets TX (65-127 bytes) - R/clr */
+#define E1000_PTC255   0x040E0  /* Packets TX (128-255 bytes) - R/clr */
+#define E1000_PTC511   0x040E4  /* Packets TX (256-511 bytes) - R/clr */
+#define E1000_PTC1023  0x040E8  /* Packets TX (512-1023 bytes) - R/clr */
+#define E1000_PTC1522  0x040EC  /* Packets TX (1024-1522 Bytes) - R/clr */
+#define E1000_MPTC     0x040F0  /* Multicast Packets TX Count - R/clr */
+#define E1000_BPTC     0x040F4  /* Broadcast Packets TX Count - R/clr */
+#define E1000_TSCTC    0x040F8  /* TCP Segmentation Context TX - R/clr */
+#define E1000_TSCTFC   0x040FC  /* TCP Segmentation Context TX Fail - R/clr */
+#define E1000_RXCSUM   0x05000  /* RX Checksum Control - RW */
+#define E1000_MTA      0x05200  /* Multicast Table Array - RW Array */
+#define E1000_RA       0x05400  /* Receive Address - RW Array */
+#define E1000_VFTA     0x05600  /* VLAN Filter Table Array - RW Array */
+#define E1000_WUC      0x05800  /* Wakeup Control - RW */
+#define E1000_WUFC     0x05808  /* Wakeup Filter Control - RW */
+#define E1000_WUS      0x05810  /* Wakeup Status - RO */
+#define E1000_MANC     0x05820  /* Management Control - RW */
+#define E1000_IPAV     0x05838  /* IP Address Valid - RW */
+#define E1000_IP4AT    0x05840  /* IPv4 Address Table - RW Array */
+#define E1000_IP6AT    0x05880  /* IPv6 Address Table - RW Array */
+#define E1000_WUPL     0x05900  /* Wakeup Packet Length - RW */
+#define E1000_WUPM     0x05A00  /* Wakeup Packet Memory - RO A */
+#define E1000_FFLT     0x05F00  /* Flexible Filter Length Table - RW Array */
+#define E1000_FFMT     0x09000  /* Flexible Filter Mask Table - RW Array */
+#define E1000_FFVT     0x09800  /* Flexible Filter Value Table - RW Array */
+
+/* Register Set (82542)
+ *
+ * Some of the 82542 registers are located at different offsets than they are
+ * in more current versions of the 8254x. Despite the difference in location,
+ * the registers function in the same manner.
+ */
+#define E1000_82542_CTRL     E1000_CTRL
+#define E1000_82542_STATUS   E1000_STATUS
+#define E1000_82542_EECD     E1000_EECD
+#define E1000_82542_EERD     E1000_EERD
+#define E1000_82542_CTRL_EXT E1000_CTRL_EXT
+#define E1000_82542_MDIC     E1000_MDIC
+#define E1000_82542_FCAL     E1000_FCAL
+#define E1000_82542_FCAH     E1000_FCAH
+#define E1000_82542_FCT      E1000_FCT
+#define E1000_82542_VET      E1000_VET
+#define E1000_82542_RA       0x00040
+#define E1000_82542_ICR      E1000_ICR
+#define E1000_82542_ITR      E1000_ITR
+#define E1000_82542_ICS      E1000_ICS
+#define E1000_82542_IMS      E1000_IMS
+#define E1000_82542_IMC      E1000_IMC
+#define E1000_82542_RCTL     E1000_RCTL
+#define E1000_82542_RDTR     0x00108
+#define E1000_82542_RDBAL    0x00110
+#define E1000_82542_RDBAH    0x00114
+#define E1000_82542_RDLEN    0x00118
+#define E1000_82542_RDH      0x00120
+#define E1000_82542_RDT      0x00128
+#define E1000_82542_FCRTH    0x00160
+#define E1000_82542_FCRTL    0x00168
+#define E1000_82542_FCTTV    E1000_FCTTV
+#define E1000_82542_TXCW     E1000_TXCW
+#define E1000_82542_RXCW     E1000_RXCW
+#define E1000_82542_MTA      0x00200
+#define E1000_82542_TCTL     E1000_TCTL
+#define E1000_82542_TIPG     E1000_TIPG
+#define E1000_82542_TDBAL    0x00420
+#define E1000_82542_TDBAH    0x00424
+#define E1000_82542_TDLEN    0x00428
+#define E1000_82542_TDH      0x00430
+#define E1000_82542_TDT      0x00438
+#define E1000_82542_TIDV     0x00440
+#define E1000_82542_TBT      E1000_TBT
+#define E1000_82542_VFTA     0x00600
+#define E1000_82542_LEDCTL   E1000_LEDCTL
+#define E1000_82542_PBA      E1000_PBA
+#define E1000_82542_RXDCTL   E1000_RXDCTL
+#define E1000_82542_RADV     E1000_RADV
+#define E1000_82542_RSRPD    E1000_RSRPD
+#define E1000_82542_TXDMAC   E1000_TXDMAC
+#define E1000_82542_TXDCTL   E1000_TXDCTL
+#define E1000_82542_TADV     E1000_TADV
+#define E1000_82542_TSPMT    E1000_TSPMT
+#define E1000_82542_CRCERRS  E1000_CRCERRS
+#define E1000_82542_ALGNERRC E1000_ALGNERRC
+#define E1000_82542_SYMERRS  E1000_SYMERRS
+#define E1000_82542_RXERRC   E1000_RXERRC
+#define E1000_82542_MPC      E1000_MPC
+#define E1000_82542_SCC      E1000_SCC
+#define E1000_82542_ECOL     E1000_ECOL
+#define E1000_82542_MCC      E1000_MCC
+#define E1000_82542_LATECOL  E1000_LATECOL
+#define E1000_82542_COLC     E1000_COLC
+#define E1000_82542_DC       E1000_DC
+#define E1000_82542_TNCRS    E1000_TNCRS
+#define E1000_82542_SEC      E1000_SEC
+#define E1000_82542_CEXTERR  E1000_CEXTERR
+#define E1000_82542_RLEC     E1000_RLEC
+#define E1000_82542_XONRXC   E1000_XONRXC
+#define E1000_82542_XONTXC   E1000_XONTXC
+#define E1000_82542_XOFFRXC  E1000_XOFFRXC
+#define E1000_82542_XOFFTXC  E1000_XOFFTXC
+#define E1000_82542_FCRUC    E1000_FCRUC
+#define E1000_82542_PRC64    E1000_PRC64
+#define E1000_82542_PRC127   E1000_PRC127
+#define E1000_82542_PRC255   E1000_PRC255
+#define E1000_82542_PRC511   E1000_PRC511
+#define E1000_82542_PRC1023  E1000_PRC1023
+#define E1000_82542_PRC1522  E1000_PRC1522
+#define E1000_82542_GPRC     E1000_GPRC
+#define E1000_82542_BPRC     E1000_BPRC
+#define E1000_82542_MPRC     E1000_MPRC
+#define E1000_82542_GPTC     E1000_GPTC
+#define E1000_82542_GORCL    E1000_GORCL
+#define E1000_82542_GORCH    E1000_GORCH
+#define E1000_82542_GOTCL    E1000_GOTCL
+#define E1000_82542_GOTCH    E1000_GOTCH
+#define E1000_82542_RNBC     E1000_RNBC
+#define E1000_82542_RUC      E1000_RUC
+#define E1000_82542_RFC      E1000_RFC
+#define E1000_82542_ROC      E1000_ROC
+#define E1000_82542_RJC      E1000_RJC
+#define E1000_82542_MGTPRC   E1000_MGTPRC
+#define E1000_82542_MGTPDC   E1000_MGTPDC
+#define E1000_82542_MGTPTC   E1000_MGTPTC
+#define E1000_82542_TORL     E1000_TORL
+#define E1000_82542_TORH     E1000_TORH
+#define E1000_82542_TOTL     E1000_TOTL
+#define E1000_82542_TOTH     E1000_TOTH
+#define E1000_82542_TPR      E1000_TPR
+#define E1000_82542_TPT      E1000_TPT
+#define E1000_82542_PTC64    E1000_PTC64
+#define E1000_82542_PTC127   E1000_PTC127
+#define E1000_82542_PTC255   E1000_PTC255
+#define E1000_82542_PTC511   E1000_PTC511
+#define E1000_82542_PTC1023  E1000_PTC1023
+#define E1000_82542_PTC1522  E1000_PTC1522
+#define E1000_82542_MPTC     E1000_MPTC
+#define E1000_82542_BPTC     E1000_BPTC
+#define E1000_82542_TSCTC    E1000_TSCTC
+#define E1000_82542_TSCTFC   E1000_TSCTFC
+#define E1000_82542_RXCSUM   E1000_RXCSUM
+#define E1000_82542_WUC      E1000_WUC
+#define E1000_82542_WUFC     E1000_WUFC
+#define E1000_82542_WUS      E1000_WUS
+#define E1000_82542_MANC     E1000_MANC
+#define E1000_82542_IPAV     E1000_IPAV
+#define E1000_82542_IP4AT    E1000_IP4AT
+#define E1000_82542_IP6AT    E1000_IP6AT
+#define E1000_82542_WUPL     E1000_WUPL
+#define E1000_82542_WUPM     E1000_WUPM
+#define E1000_82542_FFLT     E1000_FFLT
+#define E1000_82542_FFMT     E1000_FFMT
+#define E1000_82542_FFVT     E1000_FFVT
+
+/* Statistics counters collected by the MAC */
+struct e1000_shared_stats {
+    uint64_t crcerrs;
+    uint64_t algnerrc;
+    uint64_t symerrs;
+    uint64_t rxerrc;
+    uint64_t mpc;
+    uint64_t scc;
+    uint64_t ecol;
+    uint64_t mcc;
+    uint64_t latecol;
+    uint64_t colc;
+    uint64_t dc;
+    uint64_t tncrs;
+    uint64_t sec;
+    uint64_t cexterr;
+    uint64_t rlec;
+    uint64_t xonrxc;
+    uint64_t xontxc;
+    uint64_t xoffrxc;
+    uint64_t xofftxc;
+    uint64_t fcruc;
+    uint64_t prc64;
+    uint64_t prc127;
+    uint64_t prc255;
+    uint64_t prc511;
+    uint64_t prc1023;
+    uint64_t prc1522;
+    uint64_t gprc;
+    uint64_t bprc;
+    uint64_t mprc;
+    uint64_t gptc;
+    uint64_t gorcl;
+    uint64_t gorch;
+    uint64_t gotcl;
+    uint64_t gotch;
+    uint64_t rnbc;
+    uint64_t ruc;
+    uint64_t rfc;
+    uint64_t roc;
+    uint64_t rjc;
+    uint64_t mgprc;
+    uint64_t mgpdc;
+    uint64_t mgptc;
+    uint64_t torl;
+    uint64_t torh;
+    uint64_t totl;
+    uint64_t toth;
+    uint64_t tpr;
+    uint64_t tpt;
+    uint64_t ptc64;
+    uint64_t ptc127;
+    uint64_t ptc255;
+    uint64_t ptc511;
+    uint64_t ptc1023;
+    uint64_t ptc1522;
+    uint64_t mptc;
+    uint64_t bptc;
+    uint64_t tsctc;
+    uint64_t tsctfc;
+};
+
+/* Structure containing variables used by the shared code (e1000_mac.c and 
+ * e1000_phy.c)
+ */
+struct e1000_shared_adapter {
+    uint8_t *hw_addr;
+    e1000_mac_type mac_type;
+    e1000_media_type media_type;
+    void *back;
+    e1000_fc_type fc;
+    e1000_bus_speed bus_speed;
+    e1000_bus_width bus_width;
+    e1000_bus_type bus_type;
+    uint32_t phy_id;
+    uint32_t phy_addr;
+    uint32_t original_fc;
+    uint32_t txcw_reg;
+    uint32_t autoneg_failed;
+    uint32_t max_frame_size;
+    uint32_t min_frame_size;
+    uint32_t mc_filter_type;
+    uint32_t num_mc_addrs;
+    uint16_t autoneg_advertised;
+    uint16_t pci_cmd_word;
+    uint16_t fc_high_water;
+    uint16_t fc_low_water;
+    uint16_t fc_pause_time;
+    uint16_t device_id;
+    uint16_t vendor_id;
+    uint16_t subsystem_id;
+    uint16_t subsystem_vendor_id;
+    uint8_t revision_id;
+    boolean_t disable_polarity_correction;
+    boolean_t get_link_status;
+    boolean_t tbi_compatibility_en;
+    boolean_t tbi_compatibility_on;
+    boolean_t adapter_stopped;
+    boolean_t fc_send_xon;
+    boolean_t report_tx_early;
+    boolean_t low_profile;
+    uint8_t autoneg;
+    uint8_t mdix;
+    uint8_t forced_speed_duplex;
+    uint8_t wait_autoneg_complete;
+    uint8_t dma_fairness;
+    uint8_t mac_addr[NODE_ADDRESS_SIZE];
+};
+
+
+#define E1000_EEPROM_SWDPIN0   0x0001   /* SWDPIN 0 EEPROM Value */
+#define E1000_EEPROM_LED_LOGIC 0x0020   /* Led Logic Word */
+
+/* Register Bit Masks */
+/* Device Control */
+#define E1000_CTRL_FD       0x00000001  /* Full duplex.0=half; 1=full */
+#define E1000_CTRL_BEM      0x00000002  /* Endian Mode.0=little,1=big */
+#define E1000_CTRL_PRIOR    0x00000004  /* Priority on PCI. 0=rx,1=fair */
+#define E1000_CTRL_LRST     0x00000008  /* Link reset. 0=normal,1=reset */
+#define E1000_CTRL_TME      0x00000010  /* Test mode. 0=normal,1=test */
+#define E1000_CTRL_SLE      0x00000020  /* Serial Link on 0=dis,1=en */
+#define E1000_CTRL_ASDE     0x00000020  /* Auto-speed detect enable */
+#define E1000_CTRL_SLU      0x00000040  /* Set link up (Force Link) */
+#define E1000_CTRL_ILOS     0x00000080  /* Invert Loss-Of Signal */
+#define E1000_CTRL_SPD_SEL  0x00000300  /* Speed Select Mask */
+#define E1000_CTRL_SPD_10   0x00000000  /* Force 10Mb */
+#define E1000_CTRL_SPD_100  0x00000100  /* Force 100Mb */
+#define E1000_CTRL_SPD_1000 0x00000200  /* Force 1Gb */
+#define E1000_CTRL_BEM32    0x00000400  /* Big Endian 32 mode */
+#define E1000_CTRL_FRCSPD   0x00000800  /* Force Speed */
+#define E1000_CTRL_FRCDPX   0x00001000  /* Force Duplex */
+#define E1000_CTRL_SWDPIN0  0x00040000  /* SWDPIN 0 value */
+#define E1000_CTRL_SWDPIN1  0x00080000  /* SWDPIN 1 value */
+#define E1000_CTRL_SWDPIN2  0x00100000  /* SWDPIN 2 value */
+#define E1000_CTRL_SWDPIN3  0x00200000  /* SWDPIN 3 value */
+#define E1000_CTRL_SWDPIO0  0x00400000  /* SWDPIN 0 Input or output */
+#define E1000_CTRL_SWDPIO1  0x00800000  /* SWDPIN 1 input or output */
+#define E1000_CTRL_SWDPIO2  0x01000000  /* SWDPIN 2 input or output */
+#define E1000_CTRL_SWDPIO3  0x02000000  /* SWDPIN 3 input or output */
+#define E1000_CTRL_RST      0x04000000  /* Global reset */
+#define E1000_CTRL_RFCE     0x08000000  /* Receive Flow Control enable */
+#define E1000_CTRL_TFCE     0x10000000  /* Transmit flow control enable */
+#define E1000_CTRL_RTE      0x20000000  /* Routing tag enable */
+#define E1000_CTRL_VME      0x40000000  /* IEEE VLAN mode enable */
+#define E1000_CTRL_PHY_RST  0x80000000  /* PHY Reset */
+
+/* Device Status */
+#define E1000_STATUS_FD         0x00000001      /* Full duplex.0=half,1=full */
+#define E1000_STATUS_LU         0x00000002      /* Link up.0=no,1=link */
+#define E1000_STATUS_FUNC_MASK  0x0000000C      /* PCI Function Mask */
+#define E1000_STATUS_FUNC_0     0x00000000      /* Function 0 */
+#define E1000_STATUS_FUNC_1     0x00000004      /* Function 1 */
+#define E1000_STATUS_TXOFF      0x00000010      /* transmission paused */
+#define E1000_STATUS_TBIMODE    0x00000020      /* TBI mode */
+#define E1000_STATUS_SPEED_MASK 0x000000C0
+#define E1000_STATUS_SPEED_10   0x00000000      /* Speed 10Mb/s */
+#define E1000_STATUS_SPEED_100  0x00000040      /* Speed 100Mb/s */
+#define E1000_STATUS_SPEED_1000 0x00000080      /* Speed 1000Mb/s */
+#define E1000_STATUS_ASDV       0x00000300      /* Auto speed detect value */
+#define E1000_STATUS_MTXCKOK    0x00000400      /* MTX clock running OK */
+#define E1000_STATUS_PCI66      0x00000800      /* In 66Mhz slot */
+#define E1000_STATUS_BUS64      0x00001000      /* In 64 bit slot */
+#define E1000_STATUS_PCIX_MODE  0x00002000      /* PCI-X mode */
+#define E1000_STATUS_PCIX_SPEED 0x0000C000      /* PCI-X bus speed */
+
+/* Constants used to intrepret the masked PCI-X bus speed. */
+#define E1000_STATUS_PCIX_SPEED_66  0x00000000 /* PCI-X bus speed  50-66 MHz */
+#define E1000_STATUS_PCIX_SPEED_100 0x00004000 /* PCI-X bus speed  66-100 MHz */
+#define E1000_STATUS_PCIX_SPEED_133 0x00008000 /* PCI-X bus speed 100-133 MHz */
+
+/* EEPROM/Flash Control */
+#define E1000_EECD_SK        0x00000001 /* EEPROM Clock */
+#define E1000_EECD_CS        0x00000002 /* EEPROM Chip Select */
+#define E1000_EECD_DI        0x00000004 /* EEPROM Data In */
+#define E1000_EECD_DO        0x00000008 /* EEPROM Data Out */
+#define E1000_EECD_FWE_MASK  0x00000030 
+#define E1000_EECD_FWE_DIS   0x00000010 /* Disable FLASH writes */
+#define E1000_EECD_FWE_EN    0x00000020 /* Enable FLASH writes */
+#define E1000_EECD_FWE_SHIFT 4
+#define E1000_EECD_SIZE      0x00000200 /* EEPROM Size (0=64 word 1=256 word) */
+#define E1000_EECD_REQ       0x00000040 /* EEPROM Access Request */
+#define E1000_EECD_GNT       0x00000080 /* EEPROM Access Grant */
+#define E1000_EECD_PRES      0x00000100 /* EEPROM Present */
+
+/* EEPROM Read */
+#define E1000_EERD_START      0x00000001 /* Start Read */
+#define E1000_EERD_DONE       0x00000010 /* Read Done */
+#define E1000_EERD_ADDR_SHIFT 8
+#define E1000_EERD_ADDR_MASK  0x0000FF00 /* Read Address */
+#define E1000_EERD_DATA_SHIFT 16
+#define E1000_EERD_DATA_MASK  0xFFFF0000 /* Read Data */
+
+/* Extended Device Control */
+#define E1000_CTRL_EXT_GPI0_EN   0x00000001 /* Maps SDP4 to GPI0 */ 
+#define E1000_CTRL_EXT_GPI1_EN   0x00000002 /* Maps SDP5 to GPI1 */
+#define E1000_CTRL_EXT_PHYINT_EN E1000_CTRL_EXT_GPI1_EN
+#define E1000_CTRL_EXT_GPI2_EN   0x00000004 /* Maps SDP6 to GPI2 */
+#define E1000_CTRL_EXT_GPI3_EN   0x00000008 /* Maps SDP7 to GPI3 */
+#define E1000_CTRL_EXT_SDP4_DATA 0x00000010 /* Value of SW Defineable Pin 4 */
+#define E1000_CTRL_EXT_SDP5_DATA 0x00000020 /* Value of SW Defineable Pin 5 */
+#define E1000_CTRL_EXT_PHY_INT   E1000_CTRL_EXT_SDP5_DATA
+#define E1000_CTRL_EXT_SDP6_DATA 0x00000040 /* Value of SW Defineable Pin 6 */
+#define E1000_CTRL_EXT_SDP7_DATA 0x00000080 /* Value of SW Defineable Pin 7 */
+#define E1000_CTRL_EXT_SDP4_DIR  0x00000100 /* Direction of SDP4 0=in 1=out */
+#define E1000_CTRL_EXT_SDP5_DIR  0x00000200 /* Direction of SDP5 0=in 1=out */
+#define E1000_CTRL_EXT_SDP6_DIR  0x00000400 /* Direction of SDP6 0=in 1=out */
+#define E1000_CTRL_EXT_SDP7_DIR  0x00000800 /* Direction of SDP7 0=in 1=out */
+#define E1000_CTRL_EXT_ASDCHK    0x00001000 /* Initiate an ASD sequence */
+#define E1000_CTRL_EXT_EE_RST    0x00002000 /* Reinitialize from EEPROM */
+#define E1000_CTRL_EXT_IPS       0x00004000 /* Invert Power State */
+#define E1000_CTRL_EXT_SPD_BYPS  0x00008000 /* Speed Select Bypass */
+#define E1000_CTRL_EXT_LINK_MODE_MASK 0x00C00000
+#define E1000_CTRL_EXT_LINK_MODE_GMII 0x00000000
+#define E1000_CTRL_EXT_LINK_MODE_TBI  0x00C00000
+#define E1000_CTRL_EXT_WR_WMARK_MASK  0x03000000
+#define E1000_CTRL_EXT_WR_WMARK_256   0x00000000
+#define E1000_CTRL_EXT_WR_WMARK_320   0x01000000
+#define E1000_CTRL_EXT_WR_WMARK_384   0x02000000
+#define E1000_CTRL_EXT_WR_WMARK_448   0x03000000
+
+/* MDI Control */
+#define E1000_MDIC_DATA_MASK 0x0000FFFF
+#define E1000_MDIC_REG_MASK  0x001F0000
+#define E1000_MDIC_REG_SHIFT 16
+#define E1000_MDIC_PHY_MASK  0x03E00000
+#define E1000_MDIC_PHY_SHIFT 21
+#define E1000_MDIC_OP_WRITE  0x04000000
+#define E1000_MDIC_OP_READ   0x08000000
+#define E1000_MDIC_READY     0x10000000
+#define E1000_MDIC_INT_EN    0x20000000
+#define E1000_MDIC_ERROR     0x40000000
+
+/* LED Control */
+#define E1000_LEDCTL_LED0_MODE_MASK  0x0000000F
+#define E1000_LEDCTL_LED0_MODE_SHIFT 0
+#define E1000_LEDCTL_LED0_IVRT       0x00000040
+#define E1000_LEDCTL_LED0_BLINK      0x00000080
+#define E1000_LEDCTL_LED1_MODE_MASK  0x00000F00
+#define E1000_LEDCTL_LED1_MODE_SHIFT 8
+#define E1000_LEDCTL_LED1_IVRT       0x00004000
+#define E1000_LEDCTL_LED1_BLINK      0x00008000
+#define E1000_LEDCTL_LED2_MODE_MASK  0x000F0000
+#define E1000_LEDCTL_LED2_MODE_SHIFT 16
+#define E1000_LEDCTL_LED2_IVRT       0x00400000
+#define E1000_LEDCTL_LED2_BLINK      0x00800000
+#define E1000_LEDCTL_LED3_MODE_MASK  0x0F000000
+#define E1000_LEDCTL_LED3_MODE_SHIFT 24
+#define E1000_LEDCTL_LED3_IVRT       0x40000000
+#define E1000_LEDCTL_LED3_BLINK      0x80000000
+
+#define E1000_LEDCTL_MODE_LINK_10_1000  0x0
+#define E1000_LEDCTL_MODE_LINK_100_1000 0x1
+#define E1000_LEDCTL_MODE_LINK_UP       0x2
+#define E1000_LEDCTL_MODE_ACTIVITY      0x3
+#define E1000_LEDCTL_MODE_LINK_ACTIVITY 0x4
+#define E1000_LEDCTL_MODE_LINK_10       0x5
+#define E1000_LEDCTL_MODE_LINK_100      0x6
+#define E1000_LEDCTL_MODE_LINK_1000     0x7
+#define E1000_LEDCTL_MODE_PCIX_MODE     0x8
+#define E1000_LEDCTL_MODE_FULL_DUPLEX   0x9
+#define E1000_LEDCTL_MODE_COLLISION     0xA
+#define E1000_LEDCTL_MODE_BUS_SPEED     0xB
+#define E1000_LEDCTL_MODE_BUS_SIZE      0xC
+#define E1000_LEDCTL_MODE_PAUSED        0xD
+#define E1000_LEDCTL_MODE_LED_ON        0xE
+#define E1000_LEDCTL_MODE_LED_OFF       0xF
+
+/* Receive Address */
+#define E1000_RAH_AV  0x80000000        /* Receive descriptor valid */
+
+/* Interrupt Cause Read */
+#define E1000_ICR_TXDW    0x00000001    /* Transmit desc written back */
+#define E1000_ICR_TXQE    0x00000002    /* Transmit Queue empty */
+#define E1000_ICR_LSC     0x00000004    /* Link Status Change */
+#define E1000_ICR_RXSEQ   0x00000008    /* rx sequence error */
+#define E1000_ICR_RXDMT0  0x00000010    /* rx desc min. threshold (0) */
+#define E1000_ICR_RXO     0x00000040    /* rx overrun */
+#define E1000_ICR_RXT0    0x00000080    /* rx timer intr (ring 0) */
+#define E1000_ICR_MDAC    0x00000200    /* MDIO access complete */
+#define E1000_ICR_RXCFG   0x00000400    /* RX /c/ ordered set */
+#define E1000_ICR_GPI_EN0 0x00000800    /* GP Int 0 */
+#define E1000_ICR_GPI_EN1 0x00001000    /* GP Int 1 */
+#define E1000_ICR_GPI_EN2 0x00002000    /* GP Int 2 */
+#define E1000_ICR_GPI_EN3 0x00004000    /* GP Int 3 */
+#define E1000_ICR_TXD_LOW 0x00008000
+#define E1000_ICR_SRPD    0x00010000
+
+/* Interrupt Cause Set */
+#define E1000_ICS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_ICS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_ICS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_ICS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_ICS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_ICS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_ICS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_ICS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_ICS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_ICS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_ICS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_ICS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_ICS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_ICS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_ICS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Set */
+#define E1000_IMS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Clear */
+#define E1000_IMC_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMC_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMC_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMC_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMC_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMC_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMC_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMC_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMC_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMC_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMC_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMC_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMC_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMC_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMC_SRPD    E1000_ICR_SRPD
+
+/* Receive Control */
+#define E1000_RCTL_RST          0x00000001      /* Software reset */
+#define E1000_RCTL_EN           0x00000002      /* enable */
+#define E1000_RCTL_SBP          0x00000004      /* store bad packet */
+#define E1000_RCTL_UPE          0x00000008      /* unicast promiscuous enable */
+#define E1000_RCTL_MPE          0x00000010      /* multicast promiscuous enab */
+#define E1000_RCTL_LPE          0x00000020      /* long packet enable */
+#define E1000_RCTL_LBM_NO       0x00000000      /* no loopback mode */
+#define E1000_RCTL_LBM_MAC      0x00000040      /* MAC loopback mode */
+#define E1000_RCTL_LBM_SLP      0x00000080      /* serial link loopback mode */
+#define E1000_RCTL_LBM_TCVR     0x000000C0      /* tcvr loopback mode */
+#define E1000_RCTL_RDMTS_HALF   0x00000000      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_QUAT   0x00000100      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_EIGTH  0x00000200      /* rx desc min threshold size */
+#define E1000_RCTL_MO_SHIFT     12              /* multicast offset shift */
+#define E1000_RCTL_MO_0         0x00000000      /* multicast offset 11:0 */
+#define E1000_RCTL_MO_1         0x00001000      /* multicast offset 12:1 */
+#define E1000_RCTL_MO_2         0x00002000      /* multicast offset 13:2 */
+#define E1000_RCTL_MO_3         0x00003000      /* multicast offset 15:4 */
+#define E1000_RCTL_MDR          0x00004000      /* multicast desc ring 0 */
+#define E1000_RCTL_BAM          0x00008000      /* broadcast enable */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
+#define E1000_RCTL_SZ_2048      0x00000000      /* rx buffer size 2048 */
+#define E1000_RCTL_SZ_1024      0x00010000      /* rx buffer size 1024 */
+#define E1000_RCTL_SZ_512       0x00020000      /* rx buffer size 512 */
+#define E1000_RCTL_SZ_256       0x00030000      /* rx buffer size 256 */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 1 */
+#define E1000_RCTL_SZ_16384     0x00010000      /* rx buffer size 16384 */
+#define E1000_RCTL_SZ_8192      0x00020000      /* rx buffer size 8192 */
+#define E1000_RCTL_SZ_4096      0x00030000      /* rx buffer size 4096 */
+#define E1000_RCTL_VFE          0x00040000      /* vlan filter enable */
+#define E1000_RCTL_CFIEN        0x00080000      /* canonical form enable */
+#define E1000_RCTL_CFI          0x00100000      /* canonical form indicator */
+#define E1000_RCTL_DPF          0x00400000      /* discard pause frames */
+#define E1000_RCTL_PMCF         0x00800000      /* pass MAC control frames */
+#define E1000_RCTL_BSEX         0x02000000      /* Buffer size extension */
+
+/* Receive Descriptor */
+#define E1000_RDT_DELAY 0x0000ffff      /* Delay timer (1=1024us) */
+#define E1000_RDT_FPDB  0x80000000      /* Flush descriptor block */
+#define E1000_RDLEN_LEN 0x0007ff80      /* descriptor length */
+#define E1000_RDH_RDH   0x0000ffff      /* receive descriptor head */
+#define E1000_RDT_RDT   0x0000ffff      /* receive descriptor tail */
+
+/* Flow Control */
+#define E1000_FCRTH_RTH  0x0000FFF8     /* Mask Bits[15:3] for RTH */
+#define E1000_FCRTH_XFCE 0x80000000     /* External Flow Control Enable */
+#define E1000_FCRTL_RTL  0x0000FFF8     /* Mask Bits[15:3] for RTL */
+#define E1000_FCRTL_XONE 0x80000000     /* Enable XON frame transmission */
+
+/* Receive Descriptor Control */
+#define E1000_RXDCTL_PTHRESH 0x0000003F /* RXDCTL Prefetch Threshold */
+#define E1000_RXDCTL_HTHRESH 0x00003F00 /* RXDCTL Host Threshold */
+#define E1000_RXDCTL_WTHRESH 0x003F0000 /* RXDCTL Writeback Threshold */
+#define E1000_RXDCTL_GRAN    0x01000000 /* RXDCTL Granularity */
+
+/* Transmit Descriptor Control */
+#define E1000_TXDCTL_PTHRESH 0x000000FF /* TXDCTL Prefetch Threshold */
+#define E1000_TXDCTL_HTHRESH 0x0000FF00 /* TXDCTL Host Threshold */
+#define E1000_TXDCTL_WTHRESH 0x00FF0000 /* TXDCTL Writeback Threshold */
+#define E1000_TXDCTL_GRAN    0x01000000 /* TXDCTL Granularity */
+#define E1000_TXDCTL_LWTHRESH 0xFE000000 /* TXDCTL Low Threshold */
+
+/* Transmit Configuration Word */
+#define E1000_TXCW_FD         0x00000020        /* TXCW full duplex */
+#define E1000_TXCW_HD         0x00000040        /* TXCW half duplex */
+#define E1000_TXCW_PAUSE      0x00000080        /* TXCW sym pause request */
+#define E1000_TXCW_ASM_DIR    0x00000100        /* TXCW astm pause direction */
+#define E1000_TXCW_PAUSE_MASK 0x00000180        /* TXCW pause request mask */
+#define E1000_TXCW_RF         0x00003000        /* TXCW remote fault */
+#define E1000_TXCW_NP         0x00008000        /* TXCW next page */
+#define E1000_TXCW_CW         0x0000ffff        /* TxConfigWord mask */
+#define E1000_TXCW_TXC        0x40000000        /* Transmit Config control */
+#define E1000_TXCW_ANE        0x80000000        /* Auto-neg enable */
+
+/* Receive Configuration Word */
+#define E1000_RXCW_CW    0x0000ffff     /* RxConfigWord mask */
+#define E1000_RXCW_NC    0x04000000     /* Receive config no carrier */
+#define E1000_RXCW_IV    0x08000000     /* Receive config invalid */
+#define E1000_RXCW_CC    0x10000000     /* Receive config change */
+#define E1000_RXCW_C     0x20000000     /* Receive config */
+#define E1000_RXCW_SYNCH 0x40000000     /* Receive config synch */
+#define E1000_RXCW_ANC   0x80000000     /* Auto-neg complete */
+
+/* Transmit Control */
+#define E1000_TCTL_RST    0x00000001    /* software reset */
+#define E1000_TCTL_EN     0x00000002    /* enable tx */
+#define E1000_TCTL_BCE    0x00000004    /* busy check enable */
+#define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+#define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+#define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+#define E1000_TCTL_SWXOFF 0x00400000    /* SW Xoff transmission */
+#define E1000_TCTL_PBE    0x00800000    /* Packet Burst Enable */
+#define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+#define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
+
+/* Receive Checksum Control */
+#define E1000_RXCSUM_PCSS_MASK 0x000000FF   /* Packet Checksum Start */
+#define E1000_RXCSUM_IPOFL     0x00000100   /* IPv4 checksum offload */
+#define E1000_RXCSUM_TUOFL     0x00000200   /* TCP / UDP checksum offload */
+#define E1000_RXCSUM_IPV6OFL   0x00000400   /* IPv6 checksum offload */
+
+/* Definitions for power management and wakeup registers */
+/* Wake Up Control */
+#define E1000_WUC_APME       0x00000001 /* APM Enable */
+#define E1000_WUC_PME_EN     0x00000002 /* PME Enable */
+#define E1000_WUC_PME_STATUS 0x00000004 /* PME Status */
+#define E1000_WUC_APMPME     0x00000008 /* Assert PME on APM Wakeup */
+
+/* Wake Up Filter Control */
+#define E1000_WUFC_LNKC 0x00000001 /* Link Status Change Wakeup Enable */
+#define E1000_WUFC_MAG  0x00000002 /* Magic Packet Wakeup Enable */
+#define E1000_WUFC_EX   0x00000004 /* Directed Exact Wakeup Enable */
+#define E1000_WUFC_MC   0x00000008 /* Directed Multicast Wakeup Enable */
+#define E1000_WUFC_BC   0x00000010 /* Broadcast Wakeup Enable */
+#define E1000_WUFC_ARP  0x00000020 /* ARP Request Packet Wakeup Enable */
+#define E1000_WUFC_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Enable */
+#define E1000_WUFC_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Enable */
+#define E1000_WUFC_FLX0 0x00010000 /* Flexible Filter 0 Enable */
+#define E1000_WUFC_FLX1 0x00020000 /* Flexible Filter 1 Enable */
+#define E1000_WUFC_FLX2 0x00040000 /* Flexible Filter 2 Enable */
+#define E1000_WUFC_FLX3 0x00080000 /* Flexible Filter 3 Enable */
+#define E1000_WUFC_ALL_FILTERS 0x000F00FF /* Mask for all wakeup filters */
+#define E1000_WUFC_FLX_OFFSET 16       /* Offset to the Flexible Filters bits */
+#define E1000_WUFC_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Wake Up Status */
+#define E1000_WUS_LNKC 0x00000001 /* Link Status Changed */
+#define E1000_WUS_MAG  0x00000002 /* Magic Packet Received */
+#define E1000_WUS_EX   0x00000004 /* Directed Exact Received */
+#define E1000_WUS_MC   0x00000008 /* Directed Multicast Received */
+#define E1000_WUS_BC   0x00000010 /* Broadcast Received */
+#define E1000_WUS_ARP  0x00000020 /* ARP Request Packet Received */
+#define E1000_WUS_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Received */
+#define E1000_WUS_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Received */
+#define E1000_WUS_FLX0 0x00010000 /* Flexible Filter 0 Match */
+#define E1000_WUS_FLX1 0x00020000 /* Flexible Filter 1 Match */
+#define E1000_WUS_FLX2 0x00040000 /* Flexible Filter 2 Match */
+#define E1000_WUS_FLX3 0x00080000 /* Flexible Filter 3 Match */
+#define E1000_WUS_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Management Control */
+#define E1000_MANC_SMBUS_EN      0x00000001 /* SMBus Enabled - RO */
+#define E1000_MANC_ASF_EN        0x00000002 /* ASF Enabled - RO */
+#define E1000_MANC_R_ON_FORCE    0x00000004 /* Reset on Force TCO - RO */
+#define E1000_MANC_RMCP_EN       0x00000100 /* Enable RCMP 026Fh Filtering */
+#define E1000_MANC_0298_EN       0x00000200 /* Enable RCMP 0298h Filtering */
+#define E1000_MANC_IPV4_EN       0x00000400 /* Enable IPv4 */
+#define E1000_MANC_IPV6_EN       0x00000800 /* Enable IPv6 */
+#define E1000_MANC_SNAP_EN       0x00001000 /* Accept LLC/SNAP */
+#define E1000_MANC_ARP_EN        0x00002000 /* Enable ARP Request Filtering */
+#define E1000_MANC_NEIGHBOR_EN   0x00004000 /* Enable Neighbor Discovery 
+                                             * Filtering */
+#define E1000_MANC_TCO_RESET     0x00010000 /* TCO Reset Occurred */
+#define E1000_MANC_RCV_TCO_EN    0x00020000 /* Receive TCO Packets Enabled */
+#define E1000_MANC_REPORT_STATUS 0x00040000 /* Status Reporting Enabled */
+#define E1000_MANC_SMB_REQ       0x01000000 /* SMBus Request */
+#define E1000_MANC_SMB_GNT       0x02000000 /* SMBus Grant */
+#define E1000_MANC_SMB_CLK_IN    0x04000000 /* SMBus Clock In */
+#define E1000_MANC_SMB_DATA_IN   0x08000000 /* SMBus Data In */
+#define E1000_MANC_SMB_DATA_OUT  0x10000000 /* SMBus Data Out */
+#define E1000_MANC_SMB_CLK_OUT   0x20000000 /* SMBus Clock Out */
+
+#define E1000_MANC_SMB_DATA_OUT_SHIFT  28 /* SMBus Data Out Shift */
+#define E1000_MANC_SMB_CLK_OUT_SHIFT   29 /* SMBus Clock Out Shift */
+
+/* Wake Up Packet Length */
+#define E1000_WUPL_LENGTH_MASK 0x0FFF   /* Only the lower 12 bits are valid */
+
+#define E1000_MDALIGN          4096
+
+/* EEPROM Commands */
+#define EEPROM_READ_OPCODE  0x6  /* EERPOM read opcode */
+#define EEPROM_WRITE_OPCODE 0x5  /* EERPOM write opcode */
+#define EEPROM_ERASE_OPCODE 0x7  /* EERPOM erase opcode */
+#define EEPROM_EWEN_OPCODE  0x13 /* EERPOM erase/write enable */
+#define EEPROM_EWDS_OPCODE  0x10 /* EERPOM erast/write disable */
+
+/* EEPROM Word Offsets */
+#define EEPROM_INIT_CONTROL1_REG 0x000A
+#define EEPROM_INIT_CONTROL2_REG 0x000F
+#define EEPROM_FLASH_VERSION     0x0032
+#define EEPROM_CHECKSUM_REG      0x003F
+
+/* Mask bits for fields in Word 0x0a of the EEPROM */
+#define EEPROM_WORD0A_ILOS   0x0010
+#define EEPROM_WORD0A_SWDPIO 0x01E0
+#define EEPROM_WORD0A_LRST   0x0200
+#define EEPROM_WORD0A_FD     0x0400
+#define EEPROM_WORD0A_66MHZ  0x0800
+
+/* Mask bits for fields in Word 0x0f of the EEPROM */
+#define EEPROM_WORD0F_PAUSE_MASK 0x3000
+#define EEPROM_WORD0F_PAUSE      0x1000
+#define EEPROM_WORD0F_ASM_DIR    0x2000
+#define EEPROM_WORD0F_ANE        0x0800
+#define EEPROM_WORD0F_SWPDIO_EXT 0x00F0
+
+/* For checksumming, the sum of all words in the EEPROM should equal 0xBABA. */
+#define EEPROM_SUM 0xBABA
+
+/* EEPROM Map defines (WORD OFFSETS)*/
+#define EEPROM_NODE_ADDRESS_BYTE_0 0
+#define EEPROM_PBA_BYTE_1          8
+
+/* EEPROM Map Sizes (Byte Counts) */
+#define PBA_SIZE 4
+
+/* Collision related configuration parameters */
+#define E1000_COLLISION_THRESHOLD       16
+#define E1000_CT_SHIFT                  4
+#define E1000_FDX_COLLISION_DISTANCE    64
+#define E1000_HDX_COLLISION_DISTANCE    64
+#define E1000_GB_HDX_COLLISION_DISTANCE 512
+#define E1000_COLD_SHIFT                12
+
+/* The number of Transmit and Receive Descriptors must be a multiple of 8 */
+#define REQ_TX_DESCRIPTOR_MULTIPLE  8
+#define REQ_RX_DESCRIPTOR_MULTIPLE  8
+
+/* Default values for the transmit IPG register */
+#define DEFAULT_82542_TIPG_IPGT        10
+#define DEFAULT_82543_TIPG_IPGT_FIBER  9
+#define DEFAULT_82543_TIPG_IPGT_COPPER 8
+
+#define E1000_TIPG_IPGT_MASK  0x000003FF
+#define E1000_TIPG_IPGR1_MASK 0x000FFC00
+#define E1000_TIPG_IPGR2_MASK 0x3FF00000
+
+#define DEFAULT_82542_TIPG_IPGR1 2
+#define DEFAULT_82543_TIPG_IPGR1 8
+#define E1000_TIPG_IPGR1_SHIFT  10
+
+#define DEFAULT_82542_TIPG_IPGR2 10
+#define DEFAULT_82543_TIPG_IPGR2 6
+#define E1000_TIPG_IPGR2_SHIFT  20
+
+#define E1000_TXDMAC_DPP 0x00000001
+
+/* PBA constants */
+#define E1000_PBA_16K 0x0010    /* 16KB, default TX allocation */
+#define E1000_PBA_24K 0x0018
+#define E1000_PBA_40K 0x0028
+#define E1000_PBA_48K 0x0030    /* 48KB, default RX allocation */
+
+/* Flow Control Constants */
+#define FLOW_CONTROL_ADDRESS_LOW  0x00C28001
+#define FLOW_CONTROL_ADDRESS_HIGH 0x00000100
+#define FLOW_CONTROL_TYPE         0x8808
+
+/* The historical defaults for the flow control values are given below. */
+#define FC_DEFAULT_HI_THRESH        (0x8000)    /* 32KB */
+#define FC_DEFAULT_LO_THRESH        (0x4000)    /* 16KB */
+#define FC_DEFAULT_TX_TIMER         (0x100)     /* ~130 us */
+
+
+/* The number of bits that we need to shift right to move the "pause"
+ * bits from the EEPROM (bits 13:12) to the "pause" (bits 8:7) field
+ * in the TXCW register 
+ */
+#define PAUSE_SHIFT 5
+
+/* The number of bits that we need to shift left to move the "SWDPIO"
+ * bits from the EEPROM (bits 8:5) to the "SWDPIO" (bits 25:22) field
+ * in the CTRL register 
+ */
+#define SWDPIO_SHIFT 17
+
+/* The number of bits that we need to shift left to move the "SWDPIO_EXT"
+ * bits from the EEPROM word F (bits 7:4) to the bits 11:8 of The
+ * Extended CTRL register.
+ * in the CTRL register 
+ */
+#define SWDPIO__EXT_SHIFT 4
+
+/* The number of bits that we need to shift left to move the "ILOS"
+ * bit from the EEPROM (bit 4) to the "ILOS" (bit 7) field
+ * in the CTRL register 
+ */
+#define ILOS_SHIFT  3
+
+
+#define RECEIVE_BUFFER_ALIGN_SIZE  (256)
+
+/* The number of milliseconds we wait for auto-negotiation to complete */
+#define LINK_UP_TIMEOUT             500
+
+#define E1000_TX_BUFFER_SIZE ((uint32_t)1514)
+
+/* The carrier extension symbol, as received by the NIC. */
+#define CARRIER_EXTENSION   0x0F
+
+/* TBI_ACCEPT macro definition:
+ *
+ * This macro requires:
+ *      adapter = a pointer to struct e1000_shared_adapter 
+ *      status = the 8 bit status field of the RX descriptor with EOP set
+ *      error = the 8 bit error field of the RX descriptor with EOP set
+ *      length = the sum of all the length fields of the RX descriptors that
+ *               make up the current frame
+ *      last_byte = the last byte of the frame DMAed by the hardware
+ *      max_frame_length = the maximum frame length we want to accept.
+ *      min_frame_length = the minimum frame length we want to accept.
+ *
+ * This macro is a conditional that should be used in the interrupt 
+ * handler's Rx processing routine when RxErrors have been detected.
+ *
+ * Typical use:
+ *  ...
+ *  if (TBI_ACCEPT) {
+ *      accept_frame = TRUE;
+ *      e1000_tbi_adjust_stats(adapter, MacAddress);
+ *      frame_length--;
+ *  } else {
+ *      accept_frame = FALSE;
+ *  }
+ *  ...
+ */
+
+#define TBI_ACCEPT(adapter, status, errors, length, last_byte) \
+    ((adapter)->tbi_compatibility_on && \
+     (((errors) & E1000_RXD_ERR_FRAME_ERR_MASK) == E1000_RXD_ERR_CE) && \
+     ((last_byte) == CARRIER_EXTENSION) && \
+     (((status) & E1000_RXD_STAT_VP) ? \
+          (((length) > ((adapter)->min_frame_size - VLAN_TAG_SIZE)) && \
+           ((length) <= ((adapter)->max_frame_size + 1))) : \
+          (((length) > (adapter)->min_frame_size) && \
+           ((length) <= ((adapter)->max_frame_size + VLAN_TAG_SIZE + 1)))))
+
+
+#endif /* _E1000_MAC_H_ */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_main.c linux/drivers/net/e1000/e1000_main.c
--- ../ia64/linux/drivers/net/e1000/e1000_main.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_main.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,3784 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#define __E1000_MAIN__
+#ifdef IANS
+#define _IANS_MAIN_MODULE_C_
+#endif
+#include "e1000.h"
+
+/* Driver name string */
+char e1000_driver_name[] = "e1000";
+
+/* Driver ID string, displayed when loading */
+char e1000_driver_string[] = "Intel(R) PRO/1000 Network Driver";
+
+/* Driver version */
+char e1000_driver_version[] = "4.1.7";
+
+/* Copyright string, displayed when loading */
+char e1000_copyright[] = "Copyright (c) 1999-2002 Intel Corporation.";
+
+/* Linked list of board private structures for all NICs found */
+struct e1000_adapter *e1000_adapter_list = NULL;
+
+/* e1000_strings - PCI Device ID Table
+ *
+ * for selecting devices to load on
+ * private driver_data field (last one) stores an index
+ * into e1000_strings
+ * Wildcard entries (PCI_ANY_ID) should come last
+ * Last entry must be all 0s
+ *
+ * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,
+ *   Class, Class Mask, String Index }
+ */
+static struct pci_device_id e1000_pci_table[] = {
+    /* Intel(R) PRO/1000 Network Connection */
+    {0x8086, 0x1000, 0x8086, 0x1000, 0, 0, 0},
+    {0x8086, 0x1001, 0x8086, 0x1003, 0, 0, 0},
+    {0x8086, 0x1004, 0x8086, 0x1004, 0, 0, 0},
+    {0x8086, 0x1008, 0x8086, 0x1107, 0, 0, 0},
+    {0x8086, 0x1009, 0x8086, 0x1109, 0, 0, 0},
+    {0x8086, 0x100C, 0x8086, 0x1112, 0, 0, 0},
+    {0x8086, 0x100E, 0x8086, 0x001E, 0, 0, 0},
+    /* Compaq Gigabit Ethernet Server Adapter */
+    {0x8086, 0x1000, 0x0E11, PCI_ANY_ID, 0, 0, 1},
+    {0x8086, 0x1001, 0x0E11, PCI_ANY_ID, 0, 0, 1},
+    {0x8086, 0x1004, 0x0E11, PCI_ANY_ID, 0, 0, 1},
+    /* IBM Mobile, Desktop & Server Adapters */
+    {0x8086, 0x1000, 0x1014, PCI_ANY_ID, 0, 0, 2},
+    {0x8086, 0x1001, 0x1014, PCI_ANY_ID, 0, 0, 2},
+    {0x8086, 0x1004, 0x1014, PCI_ANY_ID, 0, 0, 2},
+    /* Generic */
+    {0x8086, 0x1000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x1009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x100C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x100D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    {0x8086, 0x100E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+    /* required last entry */
+    {0,}
+};
+
+MODULE_DEVICE_TABLE(pci, e1000_pci_table);
+
+/* e1000_pci_table - Table of branding strings for all supported NICs. */
+
+static char *e1000_strings[] = {
+    "Intel(R) PRO/1000 Network Connection",
+    "Compaq Gigabit Ethernet Server Adapter",
+    "IBM Mobile, Desktop & Server Adapters"
+};
+
+/* PCI driver information (Linux 2.4 driver API) */
+static struct pci_driver e1000_driver = {
+    name:     e1000_driver_name,
+    id_table: e1000_pci_table,
+    probe:    e1000_probe,
+    remove:   e1000_remove,
+    /* Power Managment Hooks */
+    suspend:  NULL,
+    resume:   NULL
+};
+
+/* Module Parameters are always initialized to -1, so that the driver
+ * can tell the difference between no user specified value or the
+ * user asking for the default value.
+ * The true default values are loaded in when e1000_check_options is called.
+ */
+
+/* This is the only thing that needs to be changed to adjust the
+ * maximum number of ports that the driver can manage.
+ */
+
+#define E1000_MAX_NIC 8
+
+/* This is a GCC extension to ANSI C.
+ * See the item "Labeled Elements in Initializers" in the section
+ * "Extensions to the C Language Family" of the GCC documentation.
+ */
+
+#define E1000_OPTION_INIT { [0 ... E1000_MAX_NIC] = OPTION_UNSET }
+
+/* Transmit Descriptor Count
+ *
+ * Valid Range: 80-256 for 82542 and 82543 gigabit ethernet controllers
+ * Valid Range: 80-4096 for 82544
+ *
+ * Default Value: 256
+ */
+
+static int TxDescriptors[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Receive Descriptor Count
+ *
+ * Valid Range: 80-256 for 82542 and 82543 gigabit ethernet controllers
+ * Valid Range: 80-4096 for 82544
+ *
+ * Default Value: 256
+ */
+
+static int RxDescriptors[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* User Specified Speed Override
+ *
+ * Valid Range: 0, 10, 100, 1000
+ *  - 0    - auto-negotiate at all supported speeds
+ *  - 10   - only link at 10 Mbps
+ *  - 100  - only link at 100 Mbps
+ *  - 1000 - only link at 1000 Mbps
+ *
+ * Default Value: 0
+ */
+
+static int Speed[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* User Specified Duplex Override
+ *
+ * Valid Range: 0-2
+ *  - 0 - auto-negotiate for duplex
+ *  - 1 - only link at half duplex
+ *  - 2 - only link at full duplex
+ *
+ * Default Value: 0
+ */
+
+static int Duplex[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Auto-negotiation Advertisement Override
+ *
+ * Valid Range: 0x00-0x0F, 0x20-0x2F
+ *
+ * The AutoNeg value is a bit mask describing which speed and duplex
+ * combinations should be advertised during auto-negotiation.
+ * The supported speed and duplex modes are listed below
+ *
+ * Bit           7     6     5      4      3     2     1      0
+ * Speed (Mbps)  N/A   N/A   1000   N/A    100   100   10     10
+ * Duplex                    Full          Full  Half  Full   Half
+ *
+ * Default Value: 0x2F
+ */
+
+static int AutoNeg[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* User Specified Flow Control Override
+ *
+ * Valid Range: 0-3
+ *  - 0 - No Flow Control
+ *  - 1 - Rx only, respond to PAUSE frames but do not generate them
+ *  - 2 - Tx only, generate PAUSE frames but ignore them on receive
+ *  - 3 - Full Flow Control Support
+ *
+ * Default Value: Read flow control settings from the EEPROM
+ */
+
+static int FlowControl[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* XsumRX - Receive Checksum Offload Enable/Disable
+ *
+ * Valid Range: 0, 1
+ *  - 0 - disables all checksum offload
+ *  - 1 - enables receive IP/TCP/UDP checksum offload
+ *        on 82543 based NICs
+ *
+ * Default Value: 1
+ */
+
+static int XsumRX[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Transmit Interrupt Delay in units of 1.024 microseconds
+ *
+ * Valid Range: 0-65535
+ *
+ * Default Value: 64
+ */
+
+static int TxIntDelay[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Receive Interrupt Delay in units of 1.024 microseconds
+ *
+ * Valid Range: 0-65535
+ *
+ * Default Value: 64
+ */
+
+static int RxIntDelay[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* MDI-X Support Enable/Disable - Applies only to Copper PHY
+ *
+ * Valid Range: 0, 3
+ *  - 0 - Auto in all modes
+ *  - 1 - MDI
+ *  - 2 - MDI-X
+ *  - 3 - Auto in 1000 Base-T mode (MDI in 10 Base-T and 100 Base-T)
+ *
+ * Default Value: 0 (Auto)
+ */
+
+static int MdiX[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+/* Automatic Correction of Reversed Cable Polarity Enable/Disable
+ * This setting applies only to Copper PHY
+ *
+ * Valid Range: 0, 1
+ *  - 0 - Disabled
+ *  - 1 - Enabled
+ *
+ * Default Value: 1 (Enabled)
+ */
+
+static int DisablePolarityCorrection[E1000_MAX_NIC + 1] = E1000_OPTION_INIT;
+
+#ifdef MODULE
+
+MODULE_AUTHOR("Intel Corporation, <linux.nics@intel.com>");
+MODULE_DESCRIPTION("Intel(R) PRO/1000 Network Driver");
+
+#if defined(MODULE_LICENSE)
+#if 0
+MODULE_LICENSE("BSD with patent grant");
+#else
+MODULE_LICENSE("GPL");	/* LICENSE file says we can choose one of two */
+#endif
+#endif
+
+MODULE_PARM(TxDescriptors, "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(RxDescriptors, "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(Speed,         "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(Duplex,        "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(AutoNeg,       "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(XsumRX,        "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(FlowControl,   "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(TxIntDelay,    "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(RxIntDelay,    "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(MdiX,          "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+MODULE_PARM(DisablePolarityCorrection, "1-" __MODULE_STRING(E1000_MAX_NIC) "i");
+
+MODULE_PARM_DESC(TxDescriptors, "Number of transmit descriptors");
+MODULE_PARM_DESC(RxDescriptors, "Number of receive descriptors");
+MODULE_PARM_DESC(Speed,         "Speed setting");
+MODULE_PARM_DESC(Duplex,        "Duplex setting");
+MODULE_PARM_DESC(AutoNeg,       "Advertised auto-negotiation setting");
+MODULE_PARM_DESC(XsumRX,        "Disable or enable Receive Checksum offload");
+MODULE_PARM_DESC(FlowControl,   "Flow Control setting");
+MODULE_PARM_DESC(TxIntDelay,    "Transmit Interrupt Delay");
+MODULE_PARM_DESC(RxIntDelay,    "Receive Interrupt Delay");
+MODULE_PARM_DESC(MdiX,          "Set MDI/MDI-X Mode");
+MODULE_PARM_DESC(DisablePolarityCorrection,
+                 "Disable or enable Automatic Correction for Reversed Cable Polarity");
+
+#ifdef EXPORT_SYMTAB
+EXPORT_SYMBOL(e1000_init_module);
+EXPORT_SYMBOL(e1000_exit_module);
+EXPORT_SYMBOL(e1000_probe);
+EXPORT_SYMBOL(e1000_remove);
+EXPORT_SYMBOL(e1000_open);
+EXPORT_SYMBOL(e1000_close);
+EXPORT_SYMBOL(e1000_xmit_frame);
+EXPORT_SYMBOL(e1000_intr);
+EXPORT_SYMBOL(e1000_set_multi);
+EXPORT_SYMBOL(e1000_change_mtu);
+EXPORT_SYMBOL(e1000_set_mac);
+EXPORT_SYMBOL(e1000_get_stats);
+EXPORT_SYMBOL(e1000_watchdog);
+EXPORT_SYMBOL(e1000_ioctl);
+EXPORT_SYMBOL(e1000_adapter_list);
+#endif
+
+#endif
+
+/* Local Function Prototypes */
+
+static void e1000_check_options(struct e1000_adapter *adapter);
+static void e1000_check_fiber_options(struct e1000_adapter *adapter);
+static void e1000_check_copper_options(struct e1000_adapter *adapter);
+static int e1000_sw_init(struct e1000_adapter *adapter);
+static int e1000_hw_init(struct e1000_adapter *adapter);
+static void e1000_read_address(struct e1000_adapter *adapter,
+                               uint8_t *addr);
+static int e1000_setup_tx_resources(struct e1000_adapter *adapter);
+static int e1000_setup_rx_resources(struct e1000_adapter *adapter);
+static void e1000_setup_rctl(struct e1000_adapter *adapter);
+static void e1000_configure_rx(struct e1000_adapter *adapter);
+static void e1000_configure_tx(struct e1000_adapter *adapter);
+static void e1000_free_tx_resources(struct e1000_adapter *adapter);
+static void e1000_free_rx_resources(struct e1000_adapter *adapter);
+static void e1000_update_stats(struct e1000_adapter *adapter);
+static inline void e1000_irq_disable(struct e1000_adapter *adapter);
+static inline void e1000_irq_enable(struct e1000_adapter *adapter);
+static void e1000_clean_tx_irq(struct e1000_adapter *adapter);
+static void e1000_clean_rx_irq(struct e1000_adapter *adapter);
+static inline void e1000_rx_checksum(struct e1000_adapter *adapter,
+                                     struct e1000_rx_desc *rx_desc,
+                                     struct sk_buff *skb);
+static void e1000_alloc_rx_buffers(unsigned long data);
+static void e1000_clean_tx_ring(struct e1000_adapter *adapter);
+static void e1000_clean_rx_ring(struct e1000_adapter *adapter);
+void e1000_hibernate_adapter(struct net_device *netdev);
+void e1000_wakeup_adapter(struct net_device *netdev);
+static void e1000_enable_WOL(struct e1000_adapter *adapter);
+
+#ifdef SIOCETHTOOL
+static int e1000_ethtool_ioctl(struct net_device *netdev,
+                               struct ifreq *ifr);
+#endif
+#ifdef IDIAG
+static int e1000_check_lbtest_frame(struct sk_buff *skb,
+                                    unsigned int frame_size);
+#endif
+
+/**
+ * e1000_init_module - Driver Registration Routine
+ *
+ * e1000_init_module is the first routine called when the driver is
+ * loaded. All it does is register with the PCI subsystem.
+ **/
+
+int
+e1000_init_module()
+{
+    E1000_DBG("e1000_init_module\n");
+
+    /* Print the driver ID string and copyright notice */
+
+    printk("%s - version %s\n%s\n", e1000_driver_string, e1000_driver_version,
+           e1000_copyright);
+
+    /* register the driver with the PCI subsystem */
+
+    return pci_module_init(&e1000_driver);
+}
+
+/* this macro creates a special symbol in the object file that
+ * identifies the driver initialization routine
+ */
+module_init(e1000_init_module);
+
+/**
+ * e1000_exit_module - Driver Exit Cleanup Routine
+ *
+ * e1000_exit_module is called just before the driver is removed
+ * from memory.
+ **/
+
+void
+e1000_exit_module()
+{
+#ifdef CONFIG_PROC_FS
+    struct proc_dir_entry *de;
+#endif
+
+    E1000_DBG("e1000_exit_module\n");
+
+    pci_unregister_driver(&e1000_driver);
+
+#ifdef CONFIG_PROC_FS
+    /* if there is no e1000_proc_dir (proc creation failure on load)
+     * then we're done
+     */
+    if(e1000_proc_dir == NULL)
+        return;
+
+    /* If ADAPTERS_PROC_DIR (/proc/net/PRO_LAN_Adapters) is empty
+     * it can be removed now (might still be in use by e100)
+     */
+    for(de = e1000_proc_dir->subdir; de; de = de->next) {
+
+        /* ignore . and .. */
+
+        if(*(de->name) == '.')
+            continue;
+        break;
+    }
+    if(de)
+        return;
+    remove_proc_entry(ADAPTERS_PROC_DIR, proc_net);
+#endif
+
+    return;
+}
+
+/* this macro creates a special symbol in the object file that
+ * identifies the driver cleanup routine
+ */
+module_exit(e1000_exit_module);
+
+/**
+ * e1000_probe - Device Initialization Routine
+ * @pdev: PCI device information struct
+ * @ent: entry in e1000_pci_table
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * e1000_probe initializes an adapter identified by a pci_dev
+ * structure.  The OS initialization is handled here, and
+ * e1000_sw_init and e1000_hw_init are called to handle the driver
+ * specific software structures and hardware initialization
+ * respectively.
+ **/
+
+int
+e1000_probe(struct pci_dev *pdev,
+            const struct pci_device_id *ent)
+{
+    struct net_device *netdev = NULL;
+    struct e1000_adapter *adapter;
+    static int cards_found = 0;
+
+#ifdef CONFIG_PROC_FS
+    int len;
+#endif
+
+    E1000_DBG("e1000_probe\n");
+
+    /* Make sure the PCI device has the proper resources available */
+
+    if(pci_enable_device(pdev) != 0) {
+        E1000_ERR("pci_enable_device failed\n");
+        return -ENODEV;
+    }
+
+    /* Make sure we are enabled as a bus mastering device */
+
+    pci_set_master(pdev);
+
+    /* Check to see if our PCI addressing needs are supported */
+    if(pci_set_dma_mask(pdev, E1000_DMA_MASK) < 0) {
+        E1000_ERR("PCI DMA not supported by the system\n");
+        return -ENODEV;
+    }
+
+    /* Allocate private data structure (struct e1000_adapter)
+     */
+    netdev = alloc_etherdev(sizeof(struct e1000_adapter));
+
+    if(netdev == NULL) {
+        E1000_ERR("Unable to allocate net_device struct\n");
+        return -ENOMEM;
+    }
+
+    /* Calling alloc_etherdev with sizeof(struct e1000_adapter) allocates
+     * a single buffer of size net_device + struct e1000_adapter +
+     * alignment. If this is not done then the struct e1000_adapter needs
+     * to be allocated and freed separately.
+     */
+    adapter = (struct e1000_adapter *) netdev->priv;
+    memset(adapter, 0, sizeof(struct e1000_adapter));
+    adapter->netdev = netdev;
+    adapter->pdev = pdev;
+
+    /* link the struct e1000_adapter into the list */
+
+    if(e1000_adapter_list != NULL)
+        e1000_adapter_list->prev = adapter;
+    adapter->next = e1000_adapter_list;
+    e1000_adapter_list = adapter;
+    adapter->shared.back = (void *) adapter;
+
+    /* reserve the MMIO region as ours */
+
+    if(!request_mem_region
+       (pci_resource_start(pdev, BAR_0), pci_resource_len(pdev, BAR_0),
+        e1000_driver_name)) {
+        E1000_ERR("request_mem_region failed\n");
+        e1000_remove(pdev);
+        return -ENODEV;
+    }
+
+    /* map the MMIO region into the kernel virtual address space */
+
+    adapter->shared.hw_addr =
+        ioremap(pci_resource_start(pdev, BAR_0), pci_resource_len(pdev, BAR_0));
+
+    if(adapter->shared.hw_addr == NULL) {
+        E1000_ERR("ioremap failed\n");
+        release_mem_region(pci_resource_start(pdev, BAR_0),
+                           pci_resource_len(pdev, BAR_0));
+        e1000_remove(pdev);
+        return -ENOMEM;
+    }
+
+    /* don't actually register the interrupt handler until e1000_open */
+
+    netdev->irq = pdev->irq;
+
+    /* Set the MMIO base address for the NIC */
+
+#ifdef IANS
+    netdev->base_addr = pci_resource_start(pdev, BAR_0);
+#endif
+    netdev->mem_start = pci_resource_start(pdev, BAR_0);
+    netdev->mem_end = netdev->mem_start + pci_resource_len(pdev, BAR_0);
+
+    /* set up function pointers to driver entry points */
+
+    netdev->open = &e1000_open;
+    netdev->stop = &e1000_close;
+    netdev->hard_start_xmit = &e1000_xmit_frame;
+    netdev->get_stats = &e1000_get_stats;
+    netdev->set_multicast_list = &e1000_set_multi;
+    netdev->set_mac_address = &e1000_set_mac;
+    netdev->change_mtu = &e1000_change_mtu;
+    netdev->do_ioctl = &e1000_ioctl;
+
+    /* set up the struct e1000_adapter */
+
+    adapter->bd_number = cards_found;
+    adapter->id_string = e1000_strings[ent->driver_data];
+    printk("\n%s\n", adapter->id_string);
+
+    /* Order is important here.  e1000_sw_init also identifies the
+     * hardware, so that e1000_check_options can treat command line parameters
+     * differently depending on the hardware.
+     */
+    e1000_sw_init(adapter);
+    e1000_check_options(adapter);
+
+#ifdef MAX_SKB_FRAGS
+    if(adapter->shared.mac_type >= e1000_82543) {
+        netdev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_HIGHDMA;
+    } else {
+        netdev->features = NETIF_F_SG | NETIF_F_HIGHDMA;
+    }
+#endif
+
+#ifdef IANS
+    adapter->iANSdata = kmalloc(sizeof(iANSsupport_t), GFP_KERNEL);
+    if(adapter->iANSdata == NULL) {
+        e1000_remove(pdev);
+        return -ENOMEM;
+    }
+    memset(adapter->iANSdata, 0, sizeof(iANSsupport_t));
+    bd_ans_drv_InitANS(adapter, adapter->iANSdata);
+#endif
+
+    /* finally, we get around to setting up the hardware */
+
+    if(e1000_hw_init(adapter) < 0) {
+        e1000_remove(pdev);
+        return -ENODEV;
+    }
+    cards_found++;
+
+    /* reset stats */
+
+    e1000_clear_hw_cntrs(&adapter->shared);
+    e1000_phy_get_info(&adapter->shared, &adapter->phy_info);
+
+    /* Then register the net device once everything initializes
+     */
+    register_netdev(netdev);
+
+#ifdef CONFIG_PROC_FS
+    /* set up the proc fs entry */
+
+    len = strlen(ADAPTERS_PROC_DIR);
+
+    for(e1000_proc_dir = proc_net->subdir; e1000_proc_dir;
+        e1000_proc_dir = e1000_proc_dir->next) {
+        if((e1000_proc_dir->namelen == len) &&
+           (memcmp(e1000_proc_dir->name, ADAPTERS_PROC_DIR, len) == 0))
+            break;
+    }
+
+    if(e1000_proc_dir == NULL)
+        e1000_proc_dir =
+            create_proc_entry(ADAPTERS_PROC_DIR, S_IFDIR, proc_net);
+
+    if(e1000_proc_dir != NULL)
+        if(e1000_create_proc_dev(adapter) < 0) {
+            e1000_remove_proc_dev(adapter->netdev);
+        }
+#endif
+
+    /* print the link status */
+
+    if(adapter->link_active == 1)
+        printk("%s:  Mem:0x%p  IRQ:%d  Speed:%d Mbps  Duplex:%s\n",
+               netdev->name, (void *) netdev->mem_start, netdev->irq,
+               adapter->link_speed,
+               adapter->link_duplex == FULL_DUPLEX ? "Full" : "Half");
+    else
+        printk("%s:  Mem:0x%p  IRQ:%d  Speed:N/A  Duplex:N/A\n", netdev->name,
+               (void *) netdev->mem_start, netdev->irq);
+
+    return 0;
+}
+
+/**
+ * e1000_remove - Device Removal Routine
+ * @pdev: PCI device information struct
+ *
+ * e1000_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.  The could be caused by a
+ * Hot-Plug event, or because the driver is going to be removed from
+ * memory.
+ *
+ * This routine is also called to clean up from a failure in
+ * e1000_probe.  The Adapter struct and netdev will always exist,
+ * all other pointers must be checked for NULL before freeing.
+ **/
+
+void
+e1000_remove(struct pci_dev *pdev)
+{
+    struct net_device *netdev;
+    struct e1000_adapter *adapter;
+
+    /* find the Adapter struct that matches this PCI device */
+
+    for(adapter = e1000_adapter_list; adapter != NULL; adapter = adapter->next) {
+        if(adapter->pdev == pdev)
+            break;
+    }
+    if(adapter == NULL)
+        return;
+
+    netdev = adapter->netdev;
+
+    /* this must be called before freeing anything,
+     * otherwise there is a case where the open entry point can be
+     * running at the same time as remove. Calling unregister_netdev on an
+     * open interface results in a call to dev_close, which locks
+     * properly against the other netdev entry points, so this takes
+     * care of the hotplug issue of removing an active interface as well.
+     */
+    unregister_netdev(netdev);
+
+    e1000_phy_hw_reset(&adapter->shared);
+
+#ifdef CONFIG_PROC_FS
+    /* remove the proc nodes */
+
+    if(e1000_proc_dir != NULL)
+        e1000_remove_proc_dev(adapter->netdev);
+#endif
+
+    /* remove from the adapter list */
+
+    if(e1000_adapter_list == adapter)
+        e1000_adapter_list = adapter->next;
+    if(adapter->next != NULL)
+        adapter->next->prev = adapter->prev;
+    if(adapter->prev != NULL)
+        adapter->prev->next = adapter->next;
+
+    /* free system resources */
+
+#ifdef IANS
+    if(adapter->iANSdata != NULL)
+        kfree(adapter->iANSdata);
+#endif
+
+    if(adapter->shared.hw_addr != NULL) {
+        iounmap((void *) adapter->shared.hw_addr);
+        release_mem_region(pci_resource_start(pdev, BAR_0),
+                           pci_resource_len(pdev, BAR_0));
+    }
+
+    /* free the net_device _and_ struct e1000_adapter memory */
+
+    kfree(netdev);
+
+    return;
+}
+
+/**
+ * e1000_check_options - Range Checking for Command Line Parameters
+ * @adapter: board private structure
+ *
+ * This routine checks all command line paramters for valid user
+ * input.  If an invalid value is given, or if no user specified
+ * value exists, a default value is used.  The final value is stored
+ * in a variable in the Adapter structure.
+ **/
+
+static void
+e1000_check_options(struct e1000_adapter *adapter)
+{
+    int board = adapter->bd_number;
+
+    if(board >= E1000_MAX_NIC) {
+        printk("Warning: no configuration for board #%i\n", board);
+        printk("Using defaults for all values\n");
+        board = E1000_MAX_NIC;
+    }
+
+    E1000_DBG("e1000_check_options\n");
+
+    /* Transmit Descriptor Count */
+
+    if(TxDescriptors[board] == OPTION_UNSET) {
+        adapter->tx_ring.count = DEFAULT_TXD;
+        TxDescriptors[board] = DEFAULT_TXD;
+    } else
+        if(((TxDescriptors[board] > MAX_TXD) ||
+            (TxDescriptors[board] < MIN_TXD)) &&
+           (adapter->shared.mac_type <= e1000_82543)) {
+        printk("Invalid TxDescriptors specified (%i), using default %i\n",
+               TxDescriptors[board], DEFAULT_TXD);
+        adapter->tx_ring.count = DEFAULT_TXD;
+    } else
+        if(((TxDescriptors[board] > MAX_82544_TXD) ||
+            (TxDescriptors[board] < MIN_TXD)) &&
+           (adapter->shared.mac_type > e1000_82543)) {
+        printk("Invalid TxDescriptors specified (%i), using default %i\n",
+               TxDescriptors[board], DEFAULT_TXD);
+        adapter->tx_ring.count = DEFAULT_TXD;
+    } else {
+        printk("Using specified value of %i TxDescriptors\n",
+               TxDescriptors[board]);
+        adapter->tx_ring.count = TxDescriptors[board];
+    }
+
+    /* tx_ring.count must be a multiple of 8 */
+
+    adapter->tx_ring.count = E1000_ROUNDUP2(adapter->tx_ring.count,
+                                            REQ_TX_DESCRIPTOR_MULTIPLE);
+
+    /* Receive Descriptor Count */
+
+    if(RxDescriptors[board] == OPTION_UNSET) {
+        adapter->rx_ring.count = DEFAULT_RXD;
+        RxDescriptors[board] = DEFAULT_RXD;
+    } else
+        if(((RxDescriptors[board] > MAX_RXD) ||
+            (RxDescriptors[board] < MIN_RXD)) &&
+           (adapter->shared.mac_type <= e1000_82543)) {
+        printk("Invalid RxDescriptors specified (%i), using default %i\n",
+               RxDescriptors[board], DEFAULT_RXD);
+        adapter->rx_ring.count = DEFAULT_RXD;
+    } else
+        if(((RxDescriptors[board] > MAX_82544_RXD) ||
+            (RxDescriptors[board] < MIN_RXD)) &&
+           (adapter->shared.mac_type > e1000_82543)) {
+        printk("Invalid RxDescriptors specified (%i), using default %i\n",
+               RxDescriptors[board], DEFAULT_RXD);
+        adapter->rx_ring.count = DEFAULT_RXD;
+    } else {
+        printk("Using specified value of %i RxDescriptors\n",
+               RxDescriptors[board]);
+        adapter->rx_ring.count = RxDescriptors[board];
+    }
+
+    /* rx_ring.count must be a multiple of 8 */
+
+    adapter->rx_ring.count =
+        E1000_ROUNDUP2(adapter->rx_ring.count, REQ_RX_DESCRIPTOR_MULTIPLE);
+
+    /* Receive Checksum Offload Enable */
+
+    if(XsumRX[board] == OPTION_UNSET) {
+        adapter->RxChecksum = XSUMRX_DEFAULT;
+        XsumRX[board] = XSUMRX_DEFAULT;
+    } else if((XsumRX[board] != OPTION_ENABLED) &&
+              (XsumRX[board] != OPTION_DISABLED)) {
+        printk("Invalid XsumRX specified (%i), using default of %i\n",
+               XsumRX[board], XSUMRX_DEFAULT);
+        adapter->RxChecksum = XSUMRX_DEFAULT;
+    } else {
+        printk("Receive Checksum Offload %s\n",
+               XsumRX[board] == OPTION_ENABLED ? "Enabled" : "Disabled");
+        adapter->RxChecksum = XsumRX[board];
+    }
+
+    /* Flow Control */
+
+    if(FlowControl[board] == OPTION_UNSET) {
+        adapter->shared.fc = e1000_fc_default;
+        FlowControl[board] = e1000_fc_default;
+    } else if((FlowControl[board] > e1000_fc_full) ||
+              (FlowControl[board] < e1000_fc_none)) {
+        printk("Invalid FlowControl specified (%i), "
+               "reading default settings from the EEPROM\n",
+               FlowControl[board]);
+        adapter->shared.fc = e1000_fc_default;
+    } else {
+        adapter->shared.fc = FlowControl[board];
+        switch (adapter->shared.fc) {
+        case e1000_fc_none:
+            printk("Flow Control Disabled\n");
+            break;
+        case e1000_fc_rx_pause:
+            printk("Flow Control Receive Only\n");
+            break;
+        case e1000_fc_tx_pause:
+            printk("Flow Control Transmit Only\n");
+            break;
+        case e1000_fc_full:
+            printk("Flow Control Enabled\n");
+        case e1000_fc_default:
+            printk("Flow Control Hardware Default\n");
+        }
+    }
+
+    /* Transmit Interrupt Delay */
+
+    if(TxIntDelay[board] == OPTION_UNSET) {
+        adapter->tx_int_delay = DEFAULT_TIDV;
+        TxIntDelay[board] = DEFAULT_TIDV;
+    } else if((TxIntDelay[board] > MAX_TIDV) || (TxIntDelay[board] < MIN_TIDV)) {
+        printk("Invalid TxIntDelay specified (%i), using default %i\n",
+               TxIntDelay[board], DEFAULT_TIDV);
+        adapter->tx_int_delay = DEFAULT_TIDV;
+    } else {
+        printk("Using specified TxIntDelay of %i\n", TxIntDelay[board]);
+        adapter->tx_int_delay = TxIntDelay[board];
+    }
+
+    /* Receive Interrupt Delay */
+
+    if(RxIntDelay[board] == OPTION_UNSET) {
+        adapter->rx_int_delay = DEFAULT_RIDV;
+        RxIntDelay[board] = DEFAULT_RIDV;
+    } else if((RxIntDelay[board] > MAX_RIDV) || (RxIntDelay[board] < MIN_RIDV)) {
+        printk("Invalid RxIntDelay specified (%i), using default %i\n",
+               RxIntDelay[board], DEFAULT_RIDV);
+        adapter->rx_int_delay = DEFAULT_RIDV;
+    } else {
+        printk("Using specified RxIntDelay of %i\n", RxIntDelay[board]);
+        adapter->rx_int_delay = RxIntDelay[board];
+    }
+
+    if(adapter->shared.media_type == e1000_media_type_copper) {
+        /* MDI/MDI-X Support */
+
+        if(MdiX[board] == OPTION_UNSET) {
+            adapter->shared.mdix = DEFAULT_MDIX;
+            MdiX[board] = DEFAULT_MDIX;
+        } else if((MdiX[board] > MAX_MDIX) || (MdiX[board] < MIN_MDIX)) {
+            printk("Invalid MDI/MDI-X specified (%i), using default %i\n",
+                   MdiX[board], DEFAULT_MDIX);
+            adapter->shared.mdix = DEFAULT_MDIX;
+        } else {
+            printk("Using specified MDI/MDI-X of %i\n", MdiX[board]);
+            adapter->shared.mdix = MdiX[board];
+        }
+
+        /* Automatic Correction for Reverse Cable Polarity */
+
+        if(DisablePolarityCorrection[board] == OPTION_UNSET) {
+            adapter->shared.disable_polarity_correction = OPTION_DISABLED;
+            DisablePolarityCorrection[board] = OPTION_DISABLED;
+        } else if((DisablePolarityCorrection[board] != OPTION_ENABLED) &&
+                  (DisablePolarityCorrection[board] != OPTION_DISABLED)) {
+            printk("Invalid polarity correction specified (%i),"
+                   "    using default %i\n", DisablePolarityCorrection[board],
+                   OPTION_DISABLED);
+            adapter->shared.disable_polarity_correction = OPTION_DISABLED;
+        } else {
+            printk("Using specified polarity correction of %i\n",
+                   DisablePolarityCorrection[board]);
+            adapter->shared.disable_polarity_correction =
+                DisablePolarityCorrection[board];
+        }
+    }
+
+    /* Speed, Duplex, and AutoNeg */
+
+    switch (adapter->shared.media_type) {
+
+    case e1000_media_type_fiber:
+        e1000_check_fiber_options(adapter);
+        break;
+
+    case e1000_media_type_copper:
+        e1000_check_copper_options(adapter);
+        break;
+
+    default:
+        printk("Unknown Media Type\n");
+        break;
+    }
+
+    return;
+}
+
+/**
+ * e1000_check_fiber_options - Range Checking for Link Options, Fiber Version
+ * @adapter: board private structure
+ *
+ * Handles speed and duplex options on fiber based adapters
+ **/
+
+static void
+e1000_check_fiber_options(struct e1000_adapter *adapter)
+{
+    int board =
+        adapter->bd_number > E1000_MAX_NIC ? E1000_MAX_NIC : adapter->bd_number;
+
+    E1000_DBG("CheckSpeedDuplexFiber\n");
+
+    /* Speed, Duplex, and AutoNeg are not valid on fiber NICs */
+
+    if((Speed[board] != OPTION_UNSET)) {
+        Speed[board] = 0;
+        printk("Warning: Speed not valid for fiber adapters\n");
+        printk("Speed Parameter Ignored\n");
+    }
+    if((Duplex[board] != OPTION_UNSET)) {
+        Duplex[board] = 0;
+        printk("Warning: Duplex not valid for fiber adapters\n");
+        printk("Duplex Parameter Ignored\n");
+    }
+    if((AutoNeg[board] != OPTION_UNSET)) {
+        AutoNeg[board] = AUTONEG_ADV_DEFAULT;
+        printk("Warning: AutoNeg not valid for fiber adapters\n");
+        printk("AutoNeg Parameter Ignored\n");
+    }
+
+    return;
+}
+
+/**
+ * e1000_check_copper_options - Range Checking for Link Options, Copper Version
+ * @adapter: board private structure
+ *
+ * Handles speed and duplex options on copper based adapters
+ **/
+
+static void
+e1000_check_copper_options(struct e1000_adapter *adapter)
+{
+    int board =
+        adapter->bd_number > E1000_MAX_NIC ? E1000_MAX_NIC : adapter->bd_number;
+    int speed, duplex;
+    boolean_t all_default = TRUE;
+
+    E1000_DBG("CheckSpeedDuplexCopper\n");
+
+    /* User Specified Auto-negotiation Settings */
+
+    if(AutoNeg[board] == OPTION_UNSET) {
+
+        adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+        AutoNeg[board] = AUTONEG_ADV_DEFAULT;
+
+    } else if((Speed[board] != 0 && Speed[board] != OPTION_UNSET) ||
+              (Duplex[board] != 0 && Duplex[board] != OPTION_UNSET)) {
+
+        printk("Warning: AutoNeg specified along with Speed or Duplex\n");
+        printk("AutoNeg Parameter Ignored\n");
+
+        adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+
+    } else {
+
+        if(AutoNeg[board] & ~AUTONEG_ADV_MASK) {
+
+            printk("Invalid AutoNeg Specified (0x%X), Parameter Ignored\n",
+                   AutoNeg[board]);
+
+            adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+
+        } else {
+
+            adapter->shared.autoneg_advertised = AutoNeg[board];
+        }
+
+        printk("AutoNeg Advertising ");
+        if(adapter->shared.autoneg_advertised & ADVERTISE_1000_FULL) {
+            printk("1000/FD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_1000_FULL - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_1000_HALF) {
+            printk("1000/HD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_1000_HALF - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_100_FULL) {
+            printk("100/FD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_100_FULL - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_100_HALF) {
+            printk("100/HD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_100_HALF - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_10_FULL) {
+            printk("10/FD");
+            if(adapter->shared.autoneg_advertised & (ADVERTISE_10_FULL - 1))
+                printk(", ");
+        }
+        if(adapter->shared.autoneg_advertised & ADVERTISE_10_HALF)
+            printk("10/HD");
+        printk("\n");
+    }
+
+    /* Forced Speed and Duplex */
+
+    switch (Speed[board]) {
+    default:
+        printk("Invalid Speed Specified (%i), Parameter Ignored\n",
+               Speed[board]);
+        all_default = FALSE;
+    case OPTION_UNSET:
+        speed = 0;
+        Speed[board] = 0;
+        break;
+    case 0:
+    case 10:
+    case 100:
+    case 1000:
+        speed = Speed[board];
+        all_default = FALSE;
+        break;
+    }
+
+    switch (Duplex[board]) {
+    default:
+        printk("Invalid Duplex Specified (%i), Parameter Ignored\n",
+               Duplex[board]);
+        all_default = FALSE;
+    case OPTION_UNSET:
+        duplex = 0;
+        Duplex[board] = 0;
+        break;
+    case 0:
+    case 1:
+    case 2:
+        duplex = Duplex[board];
+        all_default = FALSE;
+        break;
+    }
+
+    switch (speed + duplex) {
+    case 0:
+        if(all_default == FALSE)
+            printk("Speed and Duplex Auto-negotiation Enabled\n");
+        adapter->shared.autoneg = 1;
+        break;
+    case 1:
+        printk("Warning: Half Duplex specified without Speed\n");
+        printk("Using Auto-negotiation at Half Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_10_HALF | ADVERTISE_100_HALF;
+        break;
+    case 2:
+        printk("Warning: Full Duplex specified without Speed\n");
+        printk("Using Auto-negotiation at Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_10_FULL | ADVERTISE_100_FULL | ADVERTISE_1000_FULL;
+        break;
+    case 10:
+        printk("Warning: 10 Mbps Speed specified without Duplex\n");
+        printk("Using Auto-negotiation at 10 Mbps only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_10_HALF | ADVERTISE_10_FULL;
+        break;
+    case 11:
+        printk("Forcing to 10 Mbps Half Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_10_half;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 12:
+        printk("Forcing to 10 Mbps Full Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_10_full;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 100:
+        printk("Warning: 100 Mbps Speed specified without Duplex\n");
+        printk("Using Auto-negotiation at 100 Mbps only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised =
+            ADVERTISE_100_HALF | ADVERTISE_100_FULL;
+        break;
+    case 101:
+        printk("Forcing to 100 Mbps Half Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_100_half;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 102:
+        printk("Forcing to 100 Mbps Full Duplex\n");
+        adapter->shared.autoneg = 0;
+        adapter->shared.forced_speed_duplex = e1000_100_full;
+        adapter->shared.autoneg_advertised = 0;
+        break;
+    case 1000:
+        printk("Warning: 1000 Mbps Speed specified without Duplex\n");
+        printk("Using Auto-negotiation at 1000 Mbps Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+        break;
+    case 1001:
+        printk("Warning: Half Duplex is not supported at 1000 Mbps\n");
+        printk("Using Auto-negotiation at 1000 Mbps Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+        break;
+    case 1002:
+        printk("Using Auto-negotiation at 1000 Mbps Full Duplex only\n");
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+        break;
+    default:
+        panic("something is wrong in e1000_check_copper_options");
+    }
+
+    /* Speed, AutoNeg and MDI/MDI-X */
+    if (!e1000_validate_mdi_setting(&(adapter->shared))) {
+        printk ("Speed, AutoNeg and MDI-X specifications are incompatible."
+                " Setting MDI-X to a compatible value.\n");
+    }
+
+    return;
+}
+
+/**
+ * e1000_sw_init - Initialize general software structures (struct e1000_adapter)
+ * @adapter: board private structure to initialize
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * e1000_sw_init initializes the Adapter private data structure.
+ * Fields are initialized based on PCI device information and
+ * OS network device settings (MTU size).
+ **/
+
+static int
+e1000_sw_init(struct e1000_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+    uint32_t status;
+
+    E1000_DBG("e1000_sw_init\n");
+
+    /* PCI config space info */
+
+    pci_read_config_word(pdev, PCI_VENDOR_ID, &adapter->vendor_id);
+    pci_read_config_word(pdev, PCI_DEVICE_ID, &adapter->device_id);
+    pci_read_config_byte(pdev, PCI_REVISION_ID, &adapter->rev_id);
+    pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &adapter->subven_id);
+    pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &adapter->subsys_id);
+    pci_read_config_word(pdev, PCI_COMMAND, &adapter->shared.pci_cmd_word);
+    adapter->shared.vendor_id = adapter->vendor_id;
+    adapter->shared.device_id = adapter->device_id;
+    adapter->shared.revision_id = adapter->rev_id;
+    adapter->shared.subsystem_vendor_id = adapter->subven_id;
+    adapter->shared.subsystem_id = adapter->subsys_id;
+
+    /* Initial Receive Buffer Length */
+
+    if((netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH) < E1000_RXBUFFER_2048)
+        adapter->rx_buffer_len = E1000_RXBUFFER_2048;
+    else if((netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH) < E1000_RXBUFFER_4096)
+        adapter->rx_buffer_len = E1000_RXBUFFER_4096;
+    else if((netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH) < E1000_RXBUFFER_8192)
+        adapter->rx_buffer_len = E1000_RXBUFFER_8192;
+    else
+        adapter->rx_buffer_len = E1000_RXBUFFER_16384;
+
+    adapter->shared.max_frame_size =
+        netdev->mtu + ENET_HEADER_SIZE + CRC_LENGTH;
+    adapter->shared.min_frame_size = MINIMUM_ETHERNET_PACKET_SIZE + CRC_LENGTH;
+
+    /* MAC and Phy settings */
+
+    switch (adapter->device_id) {
+    case E1000_DEV_ID_82542:
+        switch (adapter->rev_id) {
+        case E1000_82542_2_0_REV_ID:
+            adapter->shared.mac_type = e1000_82542_rev2_0;
+            break;
+        case E1000_82542_2_1_REV_ID:
+            adapter->shared.mac_type = e1000_82542_rev2_1;
+            break;
+        default:
+            adapter->shared.mac_type = e1000_82542_rev2_0;
+            E1000_ERR("Could not identify 82542 revision\n");
+        }
+        break;
+    case E1000_DEV_ID_82543GC_FIBER:
+    case E1000_DEV_ID_82543GC_COPPER:
+        adapter->shared.mac_type = e1000_82543;
+        break;
+    case E1000_DEV_ID_82544EI_COPPER:
+    case E1000_DEV_ID_82544EI_FIBER:
+    case E1000_DEV_ID_82544GC_COPPER:
+    case E1000_DEV_ID_82544GC_LOM:
+        adapter->shared.mac_type = e1000_82544;
+        break;
+    case E1000_DEV_ID_82540EM:
+        adapter->shared.mac_type = e1000_82540;
+        break;
+    default:
+        E1000_ERR("Could not identify hardware\n");
+        return -ENODEV;
+    }
+
+    adapter->shared.fc_high_water = FC_DEFAULT_HI_THRESH;
+    adapter->shared.fc_low_water = FC_DEFAULT_LO_THRESH;
+    adapter->shared.fc_pause_time = FC_DEFAULT_TX_TIMER;
+    adapter->shared.fc_send_xon = 1;
+
+    /* Identify the Hardware - this is done by the gigabit shared code
+     * in e1000_init_hw, but it would help to identify the NIC
+     * before bringing the hardware online for use in e1000_check_options.
+     */
+    if(adapter->shared.mac_type >= e1000_82543) {
+        status = E1000_READ_REG(&adapter->shared, STATUS);
+        if(status & E1000_STATUS_TBIMODE) {
+            adapter->shared.media_type = e1000_media_type_fiber;
+        } else {
+            adapter->shared.media_type = e1000_media_type_copper;
+        }
+    } else {
+        adapter->shared.media_type = e1000_media_type_fiber;
+    }
+
+    if((E1000_REPORT_TX_EARLY == 0) || (E1000_REPORT_TX_EARLY == 1)) {
+        adapter->shared.report_tx_early = E1000_REPORT_TX_EARLY;
+    } else {
+        if(adapter->shared.mac_type < e1000_82543) {
+
+            adapter->shared.report_tx_early = 0;
+        } else {
+            adapter->shared.report_tx_early = 1;
+        }
+    }
+
+    adapter->shared.wait_autoneg_complete = WAITFORLINK_DEFAULT;
+
+    adapter->shared.tbi_compatibility_en = 1;
+
+    atomic_set(&adapter->tx_timeout, 0);
+
+    spin_lock_init(&adapter->stats_lock);
+    spin_lock_init(&adapter->rx_fill_lock);
+
+    return 0;
+}
+
+/**
+ * e1000_hw_init - prepare the hardware
+ * @adapter: board private struct containing configuration
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * Initialize the hardware to a configuration as specified by the
+ * Adapter structure.  The controler is reset, the EEPROM is
+ * verified, the MAC address is set, then the shared initilization
+ * routines are called.
+ **/
+
+static int
+e1000_hw_init(struct e1000_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+
+    E1000_DBG("e1000_hw_init\n");
+
+    /* Repartition Pba for greater than 9k mtu
+     * To take effect Ctrl_Rst is required.
+     */
+    if(adapter->rx_buffer_len > E1000_RXBUFFER_8192)
+        E1000_WRITE_REG(&adapter->shared, PBA, E1000_JUMBO_PBA);
+    else
+        E1000_WRITE_REG(&adapter->shared, PBA, E1000_DEFAULT_PBA);
+
+    /* Issue a global reset */
+
+    adapter->shared.adapter_stopped = 0;
+    e1000_adapter_stop(&adapter->shared);
+    adapter->shared.adapter_stopped = 0;
+
+    /* make sure the EEPROM is good */
+
+    if(!e1000_validate_eeprom_checksum(&adapter->shared)) {
+        E1000_ERR("The EEPROM Checksum Is Not Valid\n");
+        return -1;
+    }
+
+    /* copy the MAC address out of the EEPROM */
+
+    e1000_read_address(adapter, adapter->perm_net_addr);
+    memcpy(netdev->dev_addr, adapter->perm_net_addr, netdev->addr_len);
+    memcpy(adapter->shared.mac_addr, netdev->dev_addr, netdev->addr_len);
+
+    e1000_read_part_num(&adapter->shared, &(adapter->part_num));
+
+    if(!e1000_init_hw(&adapter->shared)) {
+        E1000_ERR("Hardware Initialization Failed\n");
+        return -1;
+    }
+
+    e1000_enable_WOL(adapter);
+
+    adapter->shared.get_link_status = 1;
+    e1000_check_for_link(&adapter->shared);
+
+    if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_LU)
+        adapter->link_active = TRUE;
+    else
+        adapter->link_active = FALSE;
+
+    if(adapter->link_active == TRUE) {
+        e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                   &adapter->link_duplex);
+    } else {
+        adapter->link_speed = 0;
+        adapter->link_duplex = 0;
+    }
+
+    e1000_get_bus_info(&adapter->shared);
+
+    return 0;
+}
+
+/**
+ * e1000_read_address - Reads the MAC address from the EEPROM
+ * @adapter: board private structure
+ * @addr: pointer to an array of bytes
+ **/
+
+static void
+e1000_read_address(struct e1000_adapter *adapter,
+                   uint8_t *addr)
+{
+    uint16_t eeprom_word;
+    int i;
+
+    E1000_DBG("e1000_read_address\n");
+
+    for(i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
+        eeprom_word =
+            e1000_read_eeprom(&adapter->shared,
+                              EEPROM_NODE_ADDRESS_BYTE_0 + (i / 2));
+        addr[i] = (uint8_t) (eeprom_word & 0x00FF);
+        addr[i + 1] = (uint8_t) (eeprom_word >> 8);
+    }
+
+    return;
+}
+
+/**
+ * e1000_open - Called when a network interface is made active
+ * @netdev: network interface device structure
+ *
+ * Returns 0 on success, negative value on failure
+ *
+ * The open entry point is called when a network interface is made
+ * active by the system (IFF_UP).  At this point all resources needed
+ * for transmit and receive operations are allocated, the interrupt
+ * handler is registered with the OS, the watchdog timer is started,
+ * and the stack is notified that the interface is ready.
+ **/
+
+int
+e1000_open(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+
+    E1000_DBG("e1000_open\n");
+
+    /* prevent multiple opens when dealing with iANS */
+
+    if(test_and_set_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+        return -EBUSY;
+    }
+
+    adapter->shared.fc = adapter->shared.original_fc;
+
+    /* e1000_close issues a global reset (e1000_adapter_stop)
+     * so e1000_hw_init must be called again or the hardware
+     * will resume in it's default state
+     */
+    if(e1000_hw_init(adapter) < 0) {
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -EBUSY;
+    }
+#ifdef IANS
+    /* restore VLAN settings */
+    if((IANS_BD_TAGGING_MODE) (ANS_PRIVATE_DATA_FIELD(adapter)->tag_mode) !=
+       IANS_BD_TAGGING_NONE)
+        bd_ans_hw_EnableVLAN(adapter);
+#endif
+
+    adapter->shared.adapter_stopped = 0;
+
+    /* allocate transmit descriptors */
+
+    if(e1000_setup_tx_resources(adapter) != 0) {
+        e1000_adapter_stop(&adapter->shared);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -ENOMEM;
+    }
+    e1000_configure_tx(adapter);
+
+    /* allocate receive descriptors and buffers */
+
+    if(e1000_setup_rx_resources(adapter) != 0) {
+        e1000_adapter_stop(&adapter->shared);
+        e1000_free_tx_resources(adapter);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -ENOMEM;
+    }
+    e1000_setup_rctl(adapter);
+    e1000_configure_rx(adapter);
+
+    /* hook the interrupt */
+
+    if(request_irq(netdev->irq, &e1000_intr,
+                   SA_SHIRQ, e1000_driver_name, netdev) != 0) {
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        e1000_adapter_stop(&adapter->shared);
+        e1000_free_tx_resources(adapter);
+        e1000_free_rx_resources(adapter);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+        return -EBUSY;
+    }
+
+    /* fill Rx ring with sk_buffs */
+
+    tasklet_init(&adapter->rx_fill_tasklet, e1000_alloc_rx_buffers,
+                 (unsigned long) adapter);
+
+    tasklet_schedule(&adapter->rx_fill_tasklet);
+
+    /* Set the watchdog timer for 2 seconds */
+
+    init_timer(&adapter->timer_id);
+    adapter->timer_id.function = &e1000_watchdog;
+    adapter->timer_id.data = (unsigned long) netdev;
+    mod_timer(&adapter->timer_id, (jiffies + 2 * HZ));
+
+    /* stats accumulated while down are dropped
+     * this does not clear the running total
+     */
+
+    e1000_clear_hw_cntrs(&adapter->shared);
+
+    adapter->int_mask = IMS_ENABLE_MASK;
+    e1000_irq_enable(adapter);
+    netif_start_queue(netdev);
+
+#ifdef MODULE
+
+    /* Incrementing the module use count prevents a driver from being
+     * unloaded while an active network interface is using it.
+     */
+    MOD_INC_USE_COUNT;
+
+#endif
+
+    return 0;
+}
+
+/**
+ * e1000_close - Disables a network interface
+ * @netdev: network interface device structure
+ *
+ * Returns 0, this is not allowed to fail
+ *
+ * The close entry point is called when an interface is de-activated
+ * by the OS.  The hardware is still under the drivers control, but
+ * needs to be disabled.  A global MAC reset is issued to stop the
+ * hardware, and all transmit and receive resources are freed.
+ **/
+
+int
+e1000_close(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+
+    E1000_DBG("e1000_close\n");
+
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags))
+        return 0;
+
+    /* Issue a global reset */
+
+    e1000_adapter_stop((&adapter->shared));
+
+    /* Enable receiver unit after Global reset
+     * for WOL, so that receiver can still recive
+     * wake up packet and will not drop it.
+     */
+    if(adapter->shared.mac_type > e1000_82543)
+        E1000_WRITE_REG(&adapter->shared, RCTL, E1000_RCTL_EN);
+
+    /* free OS resources */
+
+    netif_stop_queue(netdev);
+    free_irq(netdev->irq, netdev);
+    del_timer_sync(&adapter->timer_id);
+
+    /* Make sure the tasklet won't be left after ifconfig down */
+
+    /*
+     * Assumption: tasklet is ALREADY enabled, ie, t->count == 0.
+     * Otherwise, tasklet is still left in the tasklet list, and,
+     * tasklet_kill will not be able to return (hang).
+     */
+    tasklet_kill(&adapter->rx_fill_tasklet);
+
+    /* free software resources */
+
+    e1000_free_tx_resources(adapter);
+    e1000_free_rx_resources(adapter);
+
+#ifdef MODULE
+
+    /* decrement the module usage count
+     * so that the driver can be unloaded
+     */
+    MOD_DEC_USE_COUNT;
+
+#endif
+
+    clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+    return 0;
+}
+
+/**
+ * e1000_setup_tx_resources - allocate Tx resources (Descriptors)
+ * @adapter: board private structure
+ *
+ * Return 0 on success, negative on failure
+ *
+ * e1000_setup_tx_resources allocates all software transmit resources
+ * and enabled the Tx unit of the MAC.
+ **/
+
+static int
+e1000_setup_tx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    int size;
+
+    E1000_DBG("e1000_setup_tx_resources\n");
+
+    size = sizeof(struct e1000_buffer) * adapter->tx_ring.count;
+    adapter->tx_ring.buffer_info = kmalloc(size, GFP_KERNEL);
+    if(adapter->tx_ring.buffer_info == NULL) {
+        return -ENOMEM;
+    }
+    memset(adapter->tx_ring.buffer_info, 0, size);
+
+    /* round up to nearest 4K */
+
+    adapter->tx_ring.size = E1000_ROUNDUP2(adapter->tx_ring.count *
+                                           sizeof(struct e1000_tx_desc),
+                                           4096);
+
+    adapter->tx_ring.desc = pci_alloc_consistent(pdev, adapter->tx_ring.size,
+                                                 &adapter->tx_ring.dma);
+    if(adapter->tx_ring.desc == NULL) {
+        kfree(adapter->tx_ring.buffer_info);
+        return -ENOMEM;
+    }
+    memset(adapter->tx_ring.desc, 0, adapter->tx_ring.size);
+
+    atomic_set(&adapter->tx_ring.unused, adapter->tx_ring.count);
+    adapter->tx_ring.next_to_use = 0;
+    adapter->tx_ring.next_to_clean = 0;
+
+    return 0;
+}
+
+/**
+ * e1000_configure_tx - Configure 8254x Transmit Unit after Reset
+ * @adapter: board private structure
+ *
+ * Configure the Tx unit of the MAC after a reset.
+ **/
+
+static void
+e1000_configure_tx(struct e1000_adapter *adapter)
+{
+    uint32_t tctl, tipg;
+
+    /* Setup the Base and Length of the Rx Descriptor Ring */
+    /* tx_ring.dma can be either a 32 or 64 bit value */
+
+#if (BITS_PER_LONG == 32)
+    E1000_WRITE_REG(&adapter->shared, TDBAL, adapter->tx_ring.dma);
+    E1000_WRITE_REG(&adapter->shared, TDBAH, 0);
+#elif ( BITS_PER_LONG == 64)
+    E1000_WRITE_REG(&adapter->shared, TDBAL,
+                    (uint32_t) (adapter->tx_ring.dma & 0x00000000FFFFFFFF));
+    E1000_WRITE_REG(&adapter->shared, TDBAH,
+                    (uint32_t) (adapter->tx_ring.dma >> 32));
+#else
+#error "Unsupported System - does not use 32 or 64 bit pointers!"
+#endif
+
+    E1000_WRITE_REG(&adapter->shared, TDLEN,
+                    adapter->tx_ring.count * sizeof(struct e1000_tx_desc));
+
+    /* Setup the HW Tx Head and Tail descriptor pointers */
+
+    E1000_WRITE_REG(&adapter->shared, TDH, 0);
+    E1000_WRITE_REG(&adapter->shared, TDT, 0);
+
+    /* Set the default values for the Tx Inter Packet Gap timer */
+
+    switch (adapter->shared.mac_type) {
+    case e1000_82543:
+    case e1000_82544:
+    case e1000_82540:
+        if(adapter->shared.media_type == e1000_media_type_fiber)
+            tipg = DEFAULT_82543_TIPG_IPGT_FIBER;
+        else
+            tipg = DEFAULT_82543_TIPG_IPGT_COPPER;
+        tipg |= DEFAULT_82543_TIPG_IPGR1 << E1000_TIPG_IPGR1_SHIFT;
+        tipg |= DEFAULT_82543_TIPG_IPGR2 << E1000_TIPG_IPGR2_SHIFT;
+        break;
+    case e1000_82542_rev2_0:
+    case e1000_82542_rev2_1:
+    default:
+        tipg = DEFAULT_82542_TIPG_IPGT;
+        tipg |= DEFAULT_82542_TIPG_IPGR1 << E1000_TIPG_IPGR1_SHIFT;
+        tipg |= DEFAULT_82542_TIPG_IPGR2 << E1000_TIPG_IPGR2_SHIFT;
+        break;
+    }
+    E1000_WRITE_REG(&adapter->shared, TIPG, tipg);
+
+    /* Set the Tx Interrupt Delay register */
+
+    E1000_WRITE_REG(&adapter->shared, TIDV, adapter->tx_int_delay);
+
+    /* Program the Transmit Control Register */
+
+    tctl =
+        E1000_TCTL_PSP | E1000_TCTL_EN | (E1000_COLLISION_THRESHOLD <<
+                                          E1000_CT_SHIFT);
+    if(adapter->link_duplex == FULL_DUPLEX) {
+        tctl |= E1000_FDX_COLLISION_DISTANCE << E1000_COLD_SHIFT;
+    } else {
+        tctl |= E1000_HDX_COLLISION_DISTANCE << E1000_COLD_SHIFT;
+    }
+    E1000_WRITE_REG(&adapter->shared, TCTL, tctl);
+
+#ifdef CONFIG_PPC
+    if(adapter->shared.mac_type >= e1000_82543) {
+        E1000_WRITE_REG(&adapter->shared, TXDCTL, 0x00020000);
+    }
+#endif
+
+    /* Setup Transmit Descriptor Settings for this adapter */
+    adapter->TxdCmd = E1000_TXD_CMD_IFCS;
+
+    if(adapter->tx_int_delay > 0)
+        adapter->TxdCmd |= E1000_TXD_CMD_IDE;
+    if(adapter->shared.report_tx_early == 1)
+        adapter->TxdCmd |= E1000_TXD_CMD_RS;
+    else
+        adapter->TxdCmd |= E1000_TXD_CMD_RPS;
+
+    adapter->ActiveChecksumContext = OFFLOAD_NONE;
+
+    return;
+}
+
+/**
+ * e1000_setup_rx_resources - allocate Rx resources (Descriptors, receive SKBs)
+ * @adapter: board private structure
+ * 
+ * Returns 0 on success, negative on failure
+ *
+ * e1000_setup_rx_resources allocates all software receive resources
+ * and network buffers, and enables the Rx unit of the MAC.
+ **/
+
+static int
+e1000_setup_rx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    int size;
+
+    E1000_DBG("e1000_setup_rx_resources\n");
+
+    size = sizeof(struct e1000_buffer) * adapter->rx_ring.count;
+    adapter->rx_ring.buffer_info = kmalloc(size, GFP_KERNEL);
+    if(adapter->rx_ring.buffer_info == NULL) {
+        return -ENOMEM;
+    }
+    memset(adapter->rx_ring.buffer_info, 0, size);
+
+    /* Round up to nearest 4K */
+
+    adapter->rx_ring.size = E1000_ROUNDUP2(adapter->rx_ring.count *
+                                           sizeof(struct e1000_rx_desc),
+                                           4096);
+
+    adapter->rx_ring.desc = pci_alloc_consistent(pdev, adapter->rx_ring.size, 
+                                                 &adapter->rx_ring.dma);
+
+    if(adapter->rx_ring.desc == NULL) {
+        kfree(adapter->rx_ring.buffer_info);
+        return -ENOMEM;
+    }
+    memset(adapter->rx_ring.desc, 0, adapter->rx_ring.size);
+
+    adapter->rx_ring.next_to_clean = 0;
+    atomic_set(&adapter->rx_ring.unused, adapter->rx_ring.count);
+
+    adapter->rx_ring.next_to_use = 0;
+
+    return 0;
+}
+
+/**
+ * e1000_setup_rctl - configure the receive control register
+ * @adapter: Board private structure
+ **/
+
+static void
+e1000_setup_rctl(struct e1000_adapter *adapter)
+{
+    uint32_t rctl;
+
+    /* Setup the Receive Control Register */
+    rctl =
+        E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_LBM_NO |
+        E1000_RCTL_RDMTS_HALF | (adapter->shared.
+                                 mc_filter_type << E1000_RCTL_MO_SHIFT);
+
+    if(adapter->shared.tbi_compatibility_on == 1)
+        rctl |= E1000_RCTL_SBP;
+
+    switch (adapter->rx_buffer_len) {
+    case E1000_RXBUFFER_2048:
+    default:
+        rctl |= E1000_RCTL_SZ_2048;
+        break;
+    case E1000_RXBUFFER_4096:
+        rctl |= E1000_RCTL_SZ_4096 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
+        break;
+    case E1000_RXBUFFER_8192:
+        rctl |= E1000_RCTL_SZ_8192 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
+        break;
+    case E1000_RXBUFFER_16384:
+        rctl |= E1000_RCTL_SZ_16384 | E1000_RCTL_BSEX | E1000_RCTL_LPE;
+        break;
+    }
+
+    E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+}
+
+/**
+ * e1000_configure_rx - Configure 8254x Receive Unit after Reset
+ * @adapter: board private structure
+ *
+ * Configure the Rx unit of the MAC after a reset.
+ **/
+
+static void
+e1000_configure_rx(struct e1000_adapter *adapter)
+{
+    uint32_t rctl;
+    uint32_t rxcsum;
+
+    /* make sure receives are disabled while setting up the descriptor ring */
+    rctl = E1000_READ_REG(&adapter->shared, RCTL);
+    E1000_WRITE_REG(&adapter->shared, RCTL, rctl & ~E1000_RCTL_EN);
+
+    /* set the Receive Delay Timer Register */
+    E1000_WRITE_REG(&adapter->shared, RDTR,
+                    adapter->rx_int_delay | E1000_RDT_FPDB);
+
+    /* Setup the Base and Length of the Rx Descriptor Ring */
+    /* rx_ring.dma can be either a 32 or 64 bit value */
+
+#if (BITS_PER_LONG == 32)
+    E1000_WRITE_REG(&adapter->shared, RDBAL, adapter->rx_ring.dma);
+    E1000_WRITE_REG(&adapter->shared, RDBAH, 0);
+#elif ( BITS_PER_LONG == 64)
+    E1000_WRITE_REG(&adapter->shared, RDBAL,
+                    (uint32_t) (adapter->rx_ring.dma & 0x00000000FFFFFFFF));
+    E1000_WRITE_REG(&adapter->shared, RDBAH,
+                    (uint32_t) (adapter->rx_ring.dma >> 32));
+#else
+#error "Unsupported System - does not use 32 or 64 bit pointers!"
+#endif
+
+    E1000_WRITE_REG(&adapter->shared, RDLEN,
+                    adapter->rx_ring.count * sizeof(struct e1000_rx_desc));
+
+    /* Setup the HW Rx Head and Tail Descriptor Pointers */
+    E1000_WRITE_REG(&adapter->shared, RDH, 0);
+    E1000_WRITE_REG(&adapter->shared, RDT, 0);
+
+    /* Enable 82543 Receive Checksum Offload for TCP and UDP */
+    if((adapter->shared.mac_type >= e1000_82543) &&
+       (adapter->RxChecksum == TRUE)) {
+        rxcsum = E1000_READ_REG(&adapter->shared, RXCSUM);
+        rxcsum |= E1000_RXCSUM_TUOFL;
+        E1000_WRITE_REG(&adapter->shared, RXCSUM, rxcsum);
+    }
+#ifdef CONFIG_PPC
+    if(adapter->shared.mac_type >= e1000_82543) {
+        E1000_WRITE_REG(&adapter->shared, RXDCTL, 0x00020000);
+    }
+#endif
+
+    /* Enable Receives */
+    E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+
+    return;
+}
+
+/**
+ * e1000_free_tx_resources - Free Tx Resources
+ * @adapter: board private structure
+ *
+ * Free all transmit software resources
+ **/
+
+static void
+e1000_free_tx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+
+    E1000_DBG("e1000_free_tx_resources\n");
+
+    e1000_clean_tx_ring(adapter);
+
+    kfree(adapter->tx_ring.buffer_info);
+    adapter->tx_ring.buffer_info = NULL;
+
+    pci_free_consistent(pdev, adapter->tx_ring.size, adapter->tx_ring.desc,
+                        adapter->tx_ring.dma);
+
+    adapter->tx_ring.desc = NULL;
+
+    return;
+}
+
+/**
+ * e1000_clean_tx_ring - Free Tx Buffers
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_tx_ring(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    unsigned long size;
+    int i;
+
+    /* Free all the Tx ring sk_buffs */
+
+    for(i = 0; i < adapter->tx_ring.count; i++) {
+        if(adapter->tx_ring.buffer_info[i].skb != NULL) {
+
+            pci_unmap_page(pdev, adapter->tx_ring.buffer_info[i].dma,
+                           adapter->tx_ring.buffer_info[i].length,
+                           PCI_DMA_TODEVICE);
+
+            dev_kfree_skb(adapter->tx_ring.buffer_info[i].skb);
+
+            adapter->tx_ring.buffer_info[i].skb = NULL;
+        }
+    }
+
+    size = sizeof(struct e1000_buffer) * adapter->tx_ring.count;
+    memset(adapter->tx_ring.buffer_info, 0, size);
+
+    /* Zero out the descriptor ring */
+
+    memset(adapter->tx_ring.desc, 0, adapter->tx_ring.size);
+
+    atomic_set(&adapter->tx_ring.unused, adapter->tx_ring.count);
+    adapter->tx_ring.next_to_use = 0;
+    adapter->tx_ring.next_to_clean = 0;
+
+    return;
+}
+
+/**
+ * e1000_free_rx_resources - Free Rx Resources
+ * @adapter: board private structure
+ *
+ * Free all receive software resources
+ **/
+
+static void
+e1000_free_rx_resources(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+
+    E1000_DBG("e1000_free_rx_resources\n");
+
+    tasklet_disable(&adapter->rx_fill_tasklet);
+
+    e1000_clean_rx_ring(adapter);
+
+    kfree(adapter->rx_ring.buffer_info);
+    adapter->rx_ring.buffer_info = NULL;
+
+    pci_free_consistent(pdev, adapter->rx_ring.size, adapter->rx_ring.desc,
+                        adapter->rx_ring.dma);
+
+    adapter->rx_ring.desc = NULL;
+
+    return;
+}
+
+/**
+ * e1000_clean_rx_ring - Free Rx Buffers
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_rx_ring(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    unsigned long size;
+    int i;
+
+    /* Free all the Rx ring sk_buffs */
+
+    for(i = 0; i < adapter->rx_ring.count; i++) {
+        if(adapter->rx_ring.buffer_info[i].skb != NULL) {
+
+            pci_unmap_single(pdev, adapter->rx_ring.buffer_info[i].dma,
+                             adapter->rx_ring.buffer_info[i].length,
+                             PCI_DMA_FROMDEVICE);
+
+            dev_kfree_skb(adapter->rx_ring.buffer_info[i].skb);
+
+            adapter->rx_ring.buffer_info[i].skb = NULL;
+        }
+    }
+
+    size = sizeof(struct e1000_buffer) * adapter->rx_ring.count;
+    memset(adapter->rx_ring.buffer_info, 0, size);
+
+    /* Zero out the descriptor ring */
+
+    memset(adapter->rx_ring.desc, 0, adapter->rx_ring.size);
+
+    atomic_set(&adapter->rx_ring.unused, adapter->rx_ring.count);
+    adapter->rx_ring.next_to_clean = 0;
+    adapter->rx_ring.next_to_use = 0;
+
+    return;
+}
+
+/**
+ * e1000_set_multi - Multicast and Promiscuous mode set
+ * @netdev: network interface device structure
+ *
+ * The set_multi entry point is called whenever the multicast address
+ * list or the network interface flags are updated.  This routine is
+ * resposible for configuring the hardware for proper multicast,
+ * promiscuous mode, and all-multi behavior.
+ **/
+
+void
+e1000_set_multi(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    struct pci_dev *pdev = adapter->pdev;
+    uint32_t rctl;
+    uint8_t mta[MAX_NUM_MULTICAST_ADDRESSES * ETH_LENGTH_OF_ADDRESS];
+    uint16_t pci_command_word;
+    struct dev_mc_list *mc_ptr;
+    int i;
+
+    E1000_DBG("e1000_set_multi\n");
+
+    rctl = E1000_READ_REG(&adapter->shared, RCTL);
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_command_word =
+                adapter->shared.pci_cmd_word & ~PCI_COMMAND_INVALIDATE;
+            pci_write_config_word(pdev, PCI_COMMAND, pci_command_word);
+        }
+        rctl |= E1000_RCTL_RST;
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        mdelay(5);
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            tasklet_disable(&adapter->rx_fill_tasklet);
+            e1000_clean_rx_ring(adapter);
+        }
+    }
+
+    /* Check for Promiscuous and All Multicast modes */
+
+    if(netdev->flags & IFF_PROMISC) {
+        rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
+    } else if(netdev->flags & IFF_ALLMULTI) {
+        rctl |= E1000_RCTL_MPE;
+        rctl &= ~E1000_RCTL_UPE;
+    } else {
+        rctl &= ~(E1000_RCTL_UPE | E1000_RCTL_MPE);
+    }
+
+    if(netdev->mc_count > MAX_NUM_MULTICAST_ADDRESSES) {
+        rctl |= E1000_RCTL_MPE;
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+    } else {
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        for(i = 0, mc_ptr = netdev->mc_list; mc_ptr; i++, mc_ptr = mc_ptr->next)
+            memcpy(&mta[i * ETH_LENGTH_OF_ADDRESS], mc_ptr->dmi_addr,
+                   ETH_LENGTH_OF_ADDRESS);
+        e1000_mc_addr_list_update(&adapter->shared, mta, netdev->mc_count, 0);
+    }
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        rctl = E1000_READ_REG(&adapter->shared, RCTL);
+        rctl &= ~E1000_RCTL_RST;
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        mdelay(5);
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_write_config_word(pdev, PCI_COMMAND,
+                                  adapter->shared.pci_cmd_word);
+        }
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            e1000_configure_rx(adapter);
+            tasklet_enable(&adapter->rx_fill_tasklet);
+        }
+    }
+
+    return;
+}
+
+#ifdef IANS
+
+/* flush Tx queue without link */
+static void
+e1000_tx_flush(struct e1000_adapter *adapter)
+{
+    uint32_t ctrl, txcw, icr;
+
+    adapter->int_mask = 0;
+    e1000_irq_disable(adapter);
+    synchronize_irq();
+
+    if(adapter->shared.mac_type < e1000_82543) {
+        /* Transmit Unit Reset */
+        E1000_WRITE_REG(&adapter->shared, TCTL, E1000_TCTL_RST);
+        E1000_WRITE_REG(&adapter->shared, TCTL, 0);
+        e1000_clean_tx_ring(adapter);
+        e1000_configure_tx(adapter);
+    } else {
+        /* turn off autoneg, set link up, and invert loss of signal */
+        txcw = E1000_READ_REG(&adapter->shared, TXCW);
+        ctrl = E1000_READ_REG(&adapter->shared, CTRL);
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw & ~E1000_TXCW_ANE);
+        E1000_WRITE_REG(&adapter->shared, CTRL,
+                        (ctrl | E1000_CTRL_SLU | E1000_CTRL_ILOS));
+        /* delay to flush queue, then clean up */
+        mdelay(20);
+        e1000_clean_tx_irq(adapter);
+        E1000_WRITE_REG(&adapter->shared, CTRL, ctrl);
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw);
+        /* clear the link status change interrupts this caused */
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+    }
+
+    adapter->int_mask = IMS_ENABLE_MASK;
+    e1000_irq_enable(adapter);
+    return;
+}
+#endif
+
+/**
+ * e1000_watchdog - Timer Call-back
+ * @data: pointer to netdev cast into an unsigned long
+ **/
+
+void
+e1000_watchdog(unsigned long data)
+{
+    struct net_device *netdev = (struct net_device *) data;
+    struct e1000_adapter *adapter = netdev->priv;
+
+#ifdef IANS
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+    int flags;
+#endif
+#endif
+
+    e1000_check_for_link(&adapter->shared);
+
+    if (test_and_clear_bit(E1000_LINK_STATUS_CHANGED, &adapter->flags))
+        e1000_phy_get_info(&adapter->shared, &adapter->phy_info);
+
+    if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_LU) {
+        if(adapter->link_active != TRUE) {
+
+#ifdef IANS
+            if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+               (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+                if(ans_notify)
+                    ans_notify(netdev, IANS_IND_XMIT_QUEUE_READY);
+#endif
+            netif_wake_queue(netdev);
+
+            e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                       &adapter->link_duplex);
+            printk(KERN_ERR "e1000: %s NIC Link is Up %d Mbps %s\n",
+                   netdev->name, adapter->link_speed,
+                   adapter->link_duplex ==
+                   FULL_DUPLEX ? "Full Duplex" : "Half Duplex");
+
+            adapter->link_active = TRUE;
+            set_bit(E1000_LINK_STATUS_CHANGED, &adapter->flags);
+        }
+    } else {
+        if(adapter->link_active != FALSE) {
+            adapter->link_speed = 0;
+            adapter->link_duplex = 0;
+            printk(KERN_ERR "e1000: %s NIC Link is Down\n", netdev->name);
+            adapter->link_active = FALSE;
+            atomic_set(&adapter->tx_timeout, 0);
+        }
+    }
+
+    e1000_update_stats(adapter);
+
+    if(atomic_read(&adapter->tx_timeout) > 1)
+        atomic_dec(&adapter->tx_timeout);
+
+    if((adapter->link_active == TRUE) && 
+       (atomic_read(&adapter->tx_timeout) == 1)) {
+
+        if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_TXOFF) {
+            atomic_set(&adapter->tx_timeout, 3);
+        } else {
+
+            e1000_hibernate_adapter(netdev);
+
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON)) {
+                adapter->link_active = FALSE;
+                bd_ans_os_Watchdog(netdev, adapter);
+                adapter->link_active = TRUE;
+            }
+#endif
+            atomic_set(&adapter->tx_timeout, 0);
+            e1000_wakeup_adapter(netdev);
+        }
+    }
+#ifdef IANS
+    if(adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
+
+        if(adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON)
+            bd_ans_os_Watchdog(netdev, adapter);
+
+        if(adapter->link_active == FALSE) {
+            /* don't sit on SKBs while link is down */
+
+            if(atomic_read(&adapter->tx_ring.unused) < adapter->tx_ring.count) {
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+                spin_lock_irqsave(&netdev->xmit_lock, flags);
+                e1000_tx_flush(adapter);
+                spin_unlock_irqrestore(&netdev->xmit_lock, flags);
+#else
+                e1000_tx_flush(adapter);
+#endif
+            }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+            spin_lock_irqsave(&netdev->queue_lock, flags);
+            qdisc_reset(netdev->qdisc);
+            spin_unlock_irqrestore(&netdev->queue_lock, flags);
+#else
+            qdisc_reset(netdev->qdisc);
+#endif
+        }
+    }
+#endif
+
+    if(test_bit(E1000_RX_REFILL, &adapter->flags)) {
+        tasklet_schedule(&adapter->rx_fill_tasklet);
+    }
+
+    /* Reset the timer */
+    mod_timer(&adapter->timer_id, jiffies + 2 * HZ);
+
+    return;
+}
+
+/**
+ * e1000_tx_checksum_setup
+ * @adapter:
+ * @skb:
+ * @txd_upper:
+ * @txd_lower:
+ **/
+
+static inline void
+e1000_tx_checksum_setup(struct e1000_adapter *adapter,
+                        struct sk_buff *skb,
+                        uint32_t *txd_upper,
+                        uint32_t *txd_lower)
+{
+
+    struct e1000_context_desc *desc;
+    int i;
+
+    if(skb->protocol != __constant_htons(ETH_P_IP)) {
+        *txd_upper = 0;
+        *txd_lower = adapter->TxdCmd;
+        return;
+    }
+
+    switch (skb->nh.iph->protocol) {
+    case IPPROTO_TCP:
+        /* Offload TCP checksum */
+        *txd_upper = E1000_TXD_POPTS_TXSM << 8;
+        *txd_lower = adapter->TxdCmd | E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
+        if(adapter->ActiveChecksumContext == OFFLOAD_TCP_IP)
+            return;
+        else
+            adapter->ActiveChecksumContext = OFFLOAD_TCP_IP;
+        break;
+    case IPPROTO_UDP:
+        /* Offload UDP checksum */
+        *txd_upper = E1000_TXD_POPTS_TXSM << 8;
+        *txd_lower = adapter->TxdCmd | E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
+        if(adapter->ActiveChecksumContext == OFFLOAD_UDP_IP)
+            return;
+        else
+            adapter->ActiveChecksumContext = OFFLOAD_UDP_IP;
+        break;
+    default:
+        /* no checksum to offload */
+        *txd_upper = 0;
+        *txd_lower = adapter->TxdCmd;
+        return;
+    }
+
+    /* If we reach this point, the checksum offload context
+     * needs to be reset
+     */
+
+    i = adapter->tx_ring.next_to_use;
+    desc = E1000_CONTEXT_DESC(adapter->tx_ring, i);
+
+    desc->lower_setup.ip_fields.ipcss = skb->nh.raw - skb->data;
+    desc->lower_setup.ip_fields.ipcso =
+        ((skb->nh.raw + offsetof(struct iphdr, check)) - skb->data);
+    desc->lower_setup.ip_fields.ipcse = cpu_to_le16(skb->h.raw - skb->data - 1);
+
+    desc->upper_setup.tcp_fields.tucss = (skb->h.raw - skb->data);
+    desc->upper_setup.tcp_fields.tucso = ((skb->h.raw + skb->csum) - skb->data);
+    desc->upper_setup.tcp_fields.tucse = 0;
+
+    desc->tcp_seg_setup.data = 0;
+    desc->cmd_and_length = cpu_to_le32(E1000_TXD_CMD_DEXT) | adapter->TxdCmd;
+
+    i = (i + 1) % adapter->tx_ring.count;
+    atomic_dec(&adapter->tx_ring.unused);
+    adapter->tx_ring.next_to_use = i;
+    E1000_WRITE_REG(&adapter->shared, TDT, adapter->tx_ring.next_to_use);
+    return;
+}
+
+/**
+ * e1000_xmit_frame - Transmit entry point
+ * @skb: buffer with frame data to transmit
+ * @netdev: network interface device structure
+ *
+ * Returns 0 on success, negative on error
+ *
+ * e1000_xmit_frame is called by the stack to initiate a transmit.
+ * The out of resource condition is checked after each successful Tx
+ * so that the stack can be notified, preventing the driver from
+ * ever needing to drop a frame.  The atomic operations on
+ * tx_ring.unused are used to syncronize with the transmit
+ * interrupt processing code without the need for a spinlock.
+ **/
+
+int
+e1000_xmit_frame(struct sk_buff *skb,
+                 struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_tx_desc *tx_desc;
+    int i, len, offset, txd_needed;
+    uint32_t txd_upper, txd_lower;
+
+#define TXD_USE_COUNT(x) (((x) >> 12) + ((x) & 0x0fff ? 1 : 0))
+
+#ifdef MAX_SKB_FRAGS
+    int f;
+    skb_frag_t *frag;
+#endif
+
+    E1000_DBG("e1000_xmit_frame\n");
+
+    if(adapter->link_active == FALSE) {
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+            if(ans_notify)
+                ans_notify(netdev, IANS_IND_XMIT_QUEUE_FULL);
+#endif
+        netif_stop_queue(netdev);
+        return 1;
+    }
+
+#ifdef MAX_SKB_FRAGS
+    txd_needed = TXD_USE_COUNT(skb->len - skb->data_len);
+    for(f = 0; f < skb_shinfo(skb)->nr_frags; f++) {
+        frag = &skb_shinfo(skb)->frags[f];
+        txd_needed += TXD_USE_COUNT(frag->size);
+    }
+#else
+    txd_needed = TXD_USE_COUNT(skb->len);
+#endif
+
+    /* make sure there are enough Tx descriptors available in the ring */
+    if(atomic_read(&adapter->tx_ring.unused) <= (txd_needed + 1)) {
+        adapter->net_stats.tx_dropped++;
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+            if(ans_notify)
+                ans_notify(netdev, IANS_IND_XMIT_QUEUE_FULL);
+#endif
+        netif_stop_queue(netdev);
+
+        return 1;
+    }
+
+    if(skb->ip_summed == CHECKSUM_HW) {
+        e1000_tx_checksum_setup(adapter, skb, &txd_upper, &txd_lower);
+    } else {
+        txd_upper = 0;
+        txd_lower = adapter->TxdCmd;
+    }
+
+    i = adapter->tx_ring.next_to_use;
+    tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+#ifdef IANS
+    if(adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
+        tx_desc->lower.data = cpu_to_le32(txd_lower);
+        tx_desc->upper.data = cpu_to_le32(txd_upper);
+        if(bd_ans_os_Transmit(adapter, tx_desc, &skb) == BD_ANS_FAILURE) {
+            return 1;
+        }
+        txd_lower = le32_to_cpu(tx_desc->lower.data);
+        txd_upper = le32_to_cpu(tx_desc->upper.data);
+    }
+#endif
+
+#ifdef MAX_SKB_FRAGS
+    len = skb->len - skb->data_len;
+#else
+    len = skb->len;
+#endif
+    offset = 0;
+
+    while(len > 4096) {
+        adapter->tx_ring.buffer_info[i].length = 4096;
+        adapter->tx_ring.buffer_info[i].dma =
+            pci_map_page(pdev, virt_to_page(skb->data + offset),
+                         (unsigned long) (skb->data + offset) & ~PAGE_MASK,
+                         4096, PCI_DMA_TODEVICE);
+
+        tx_desc->buffer_addr = cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+        tx_desc->lower.data = cpu_to_le32(txd_lower | 4096);
+        tx_desc->upper.data = cpu_to_le32(txd_upper);
+
+        len -= 4096;
+        offset += 4096;
+        i = (i + 1) % adapter->tx_ring.count;
+        atomic_dec(&adapter->tx_ring.unused);
+        tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+    }
+    adapter->tx_ring.buffer_info[i].length = len;
+    adapter->tx_ring.buffer_info[i].dma =
+        pci_map_page(pdev, virt_to_page(skb->data + offset),
+                     (unsigned long) (skb->data + offset) & ~PAGE_MASK, len,
+                     PCI_DMA_TODEVICE);
+
+    tx_desc->buffer_addr = cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+    tx_desc->lower.data = cpu_to_le32(txd_lower | len);
+    tx_desc->upper.data = cpu_to_le32(txd_upper);
+
+#ifdef MAX_SKB_FRAGS
+    for(f = 0; f < skb_shinfo(skb)->nr_frags; f++) {
+        frag = &skb_shinfo(skb)->frags[f];
+        i = (i + 1) % adapter->tx_ring.count;
+        atomic_dec(&adapter->tx_ring.unused);
+        tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+        len = frag->size;
+        offset = 0;
+
+        while(len > 4096) {
+            adapter->tx_ring.buffer_info[i].length = 4096;
+            adapter->tx_ring.buffer_info[i].dma =
+                pci_map_page(pdev, frag->page, frag->page_offset + offset,
+                             4096, PCI_DMA_TODEVICE);
+
+            tx_desc->buffer_addr =
+                cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+            tx_desc->lower.data = cpu_to_le32(txd_lower | 4096);
+            tx_desc->upper.data = cpu_to_le32(txd_upper);
+
+            len -= 4096;
+            offset += 4096;
+            i = (i + 1) % adapter->tx_ring.count;
+            atomic_dec(&adapter->tx_ring.unused);
+            tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+        }
+        adapter->tx_ring.buffer_info[i].length = len;
+        adapter->tx_ring.buffer_info[i].dma =
+            pci_map_page(pdev, frag->page, frag->page_offset + offset, len,
+                         PCI_DMA_TODEVICE);
+        tx_desc->buffer_addr =
+            cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+
+        tx_desc->lower.data = cpu_to_le32(txd_lower | len);
+        tx_desc->upper.data = cpu_to_le32(txd_upper);
+    }
+#endif
+    
+    /* EOP and SKB pointer go with the last fragment */
+    tx_desc->lower.data |= cpu_to_le32(E1000_TXD_CMD_EOP);
+    adapter->tx_ring.buffer_info[i].skb = skb;
+
+    i = (i + 1) % adapter->tx_ring.count;
+    atomic_dec(&adapter->tx_ring.unused);
+
+    /* Move the HW Tx Tail Pointer */
+    adapter->tx_ring.next_to_use = i;
+
+    E1000_WRITE_REG(&adapter->shared, TDT, adapter->tx_ring.next_to_use);
+
+    if(atomic_read(&adapter->tx_timeout) == 0)
+        atomic_set(&adapter->tx_timeout, 3);
+
+    netdev->trans_start = jiffies;
+
+    return 0;
+}
+
+/**
+ * e1000_get_stats - Get System Network Statistics
+ * @netdev: network interface device structure
+ *
+ * Returns the address of the device statistics structure.
+ * The statistics are actually updated from the timer callback.
+ **/
+
+struct net_device_stats *
+e1000_get_stats(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+
+    E1000_DBG("e1000_get_stats\n");
+
+    return &adapter->net_stats;
+}
+
+/**
+ * e1000_change_mtu - Change the Maximum Transfer Unit
+ * @netdev: network interface device structure
+ * @new_mtu: new value for maximum frame size
+ *
+ * Returns 0 on success, negative on failure
+ **/
+
+int
+e1000_change_mtu(struct net_device *netdev,
+                 int new_mtu)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t old_mtu = adapter->rx_buffer_len;
+
+    E1000_DBG("e1000_change_mtu\n");
+    if((new_mtu < MINIMUM_ETHERNET_PACKET_SIZE - ENET_HEADER_SIZE) ||
+       (new_mtu > MAX_JUMBO_FRAME_SIZE - ENET_HEADER_SIZE)) {
+        E1000_ERR("Invalid MTU setting\n");
+        return -EINVAL;
+    }
+
+    if(new_mtu <= MAXIMUM_ETHERNET_PACKET_SIZE - ENET_HEADER_SIZE) {
+        /* 2k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_2048;
+
+    } else if(adapter->shared.mac_type < e1000_82543) {
+        E1000_ERR("Jumbo Frames not supported on 82542\n");
+        return -EINVAL;
+
+    } else if(new_mtu <= E1000_RXBUFFER_4096 - ENET_HEADER_SIZE - CRC_LENGTH) {
+        /* 4k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_4096;
+
+    } else if(new_mtu <= E1000_RXBUFFER_8192 - ENET_HEADER_SIZE - CRC_LENGTH) {
+        /* 8k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_8192;
+
+    } else {
+        /* 16k buffers */
+        adapter->rx_buffer_len = E1000_RXBUFFER_16384;
+    }
+
+    if(old_mtu != adapter->rx_buffer_len &&
+       test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+
+        /* stop */
+        tasklet_disable(&adapter->rx_fill_tasklet);
+        netif_stop_queue(netdev);
+        adapter->shared.adapter_stopped = 0;
+        e1000_adapter_stop(&adapter->shared);
+
+        /* clean out old buffers */
+        e1000_clean_rx_ring(adapter);
+        e1000_clean_tx_ring(adapter);
+
+        /* reset hardware */
+        adapter->shared.adapter_stopped = 0;
+        e1000_hw_init(adapter);
+
+        /* go */
+        e1000_setup_rctl(adapter);
+        e1000_configure_rx(adapter);
+        e1000_configure_tx(adapter);
+#ifdef IANS
+        /* restore VLAN settings */
+        if((IANS_BD_TAGGING_MODE) (ANS_PRIVATE_DATA_FIELD(adapter)->tag_mode)
+           != IANS_BD_TAGGING_NONE)
+            bd_ans_hw_EnableVLAN(adapter);
+#endif
+        tasklet_enable(&adapter->rx_fill_tasklet);
+        tasklet_schedule(&adapter->rx_fill_tasklet);
+        e1000_irq_enable(adapter);
+        netif_start_queue(netdev);
+    }
+
+    netdev->mtu = new_mtu;
+    adapter->shared.max_frame_size = new_mtu + ENET_HEADER_SIZE + CRC_LENGTH;
+
+    return 0;
+}
+
+/**
+ * e1000_set_mac - Change the Ethernet Address of the NIC
+ * @netdev: network interface device structure
+ * @p: pointer to an address structure
+ * 
+ * Returns 0 on success, negative on failure
+ **/
+
+int
+e1000_set_mac(struct net_device *netdev,
+              void *p)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    struct pci_dev *pdev = adapter->pdev;
+    struct sockaddr *addr = (struct sockaddr *) p;
+    uint32_t pci_command;
+    uint32_t rctl;
+
+    E1000_DBG("e1000_set_mac\n");
+
+    rctl = E1000_READ_REG(&adapter->shared, RCTL);
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_command =
+                adapter->shared.pci_cmd_word & ~PCI_COMMAND_INVALIDATE;
+            pci_write_config_word(pdev, PCI_COMMAND, pci_command);
+        }
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl | E1000_RCTL_RST);
+        mdelay(5);
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            tasklet_disable(&adapter->rx_fill_tasklet);
+            e1000_clean_rx_ring(adapter);
+        }
+    }
+
+    memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
+    memcpy(adapter->shared.mac_addr, addr->sa_data, netdev->addr_len);
+
+    e1000_rar_set(&adapter->shared, adapter->shared.mac_addr, 0);
+
+    if(adapter->shared.mac_type == e1000_82542_rev2_0) {
+        E1000_WRITE_REG(&adapter->shared, RCTL, rctl);
+        mdelay(5);
+        if(adapter->shared.pci_cmd_word & PCI_COMMAND_INVALIDATE) {
+            pci_write_config_word(pdev, PCI_COMMAND,
+                                  adapter->shared.pci_cmd_word);
+        }
+        if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+            e1000_configure_rx(adapter);
+            tasklet_enable(&adapter->rx_fill_tasklet);
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * e1000_update_stats - Update the board statistics counters
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_update_stats(struct e1000_adapter *adapter)
+{
+    unsigned long flags;
+
+#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF
+
+    spin_lock_irqsave(&adapter->stats_lock, flags);
+
+    adapter->stats.crcerrs += E1000_READ_REG(&adapter->shared, CRCERRS);
+    adapter->stats.symerrs += E1000_READ_REG(&adapter->shared, SYMERRS);
+    adapter->stats.mpc += E1000_READ_REG(&adapter->shared, MPC);
+    adapter->stats.scc += E1000_READ_REG(&adapter->shared, SCC);
+    adapter->stats.ecol += E1000_READ_REG(&adapter->shared, ECOL);
+    adapter->stats.mcc += E1000_READ_REG(&adapter->shared, MCC);
+    adapter->stats.latecol += E1000_READ_REG(&adapter->shared, LATECOL);
+    adapter->stats.colc += E1000_READ_REG(&adapter->shared, COLC);
+    adapter->stats.dc += E1000_READ_REG(&adapter->shared, DC);
+    adapter->stats.sec += E1000_READ_REG(&adapter->shared, SEC);
+    adapter->stats.rlec += E1000_READ_REG(&adapter->shared, RLEC);
+    adapter->stats.xonrxc += E1000_READ_REG(&adapter->shared, XONRXC);
+    adapter->stats.xontxc += E1000_READ_REG(&adapter->shared, XONTXC);
+    adapter->stats.xoffrxc += E1000_READ_REG(&adapter->shared, XOFFRXC);
+    adapter->stats.xofftxc += E1000_READ_REG(&adapter->shared, XOFFTXC);
+    adapter->stats.fcruc += E1000_READ_REG(&adapter->shared, FCRUC);
+    adapter->stats.prc64 += E1000_READ_REG(&adapter->shared, PRC64);
+    adapter->stats.prc127 += E1000_READ_REG(&adapter->shared, PRC127);
+    adapter->stats.prc255 += E1000_READ_REG(&adapter->shared, PRC255);
+    adapter->stats.prc511 += E1000_READ_REG(&adapter->shared, PRC511);
+    adapter->stats.prc1023 += E1000_READ_REG(&adapter->shared, PRC1023);
+    adapter->stats.prc1522 += E1000_READ_REG(&adapter->shared, PRC1522);
+    adapter->stats.gprc += E1000_READ_REG(&adapter->shared, GPRC);
+    adapter->stats.bprc += E1000_READ_REG(&adapter->shared, BPRC);
+    adapter->stats.mprc += E1000_READ_REG(&adapter->shared, MPRC);
+    adapter->stats.gptc += E1000_READ_REG(&adapter->shared, GPTC);
+
+    /* for the 64-bit byte counters the low dword must be read first */
+    /* both registers clear on the read of the high dword */
+
+    adapter->stats.gorcl += E1000_READ_REG(&adapter->shared, GORCL);
+    adapter->stats.gorch += E1000_READ_REG(&adapter->shared, GORCH);
+    adapter->stats.gotcl += E1000_READ_REG(&adapter->shared, GOTCL);
+    adapter->stats.gotch += E1000_READ_REG(&adapter->shared, GOTCH);
+
+    adapter->stats.rnbc += E1000_READ_REG(&adapter->shared, RNBC);
+    adapter->stats.ruc += E1000_READ_REG(&adapter->shared, RUC);
+    adapter->stats.rfc += E1000_READ_REG(&adapter->shared, RFC);
+    adapter->stats.roc += E1000_READ_REG(&adapter->shared, ROC);
+    adapter->stats.rjc += E1000_READ_REG(&adapter->shared, RJC);
+
+    adapter->stats.torl += E1000_READ_REG(&adapter->shared, TORL);
+    adapter->stats.torh += E1000_READ_REG(&adapter->shared, TORH);
+    adapter->stats.totl += E1000_READ_REG(&adapter->shared, TOTL);
+    adapter->stats.toth += E1000_READ_REG(&adapter->shared, TOTH);
+
+    adapter->stats.tpr += E1000_READ_REG(&adapter->shared, TPR);
+    adapter->stats.tpt += E1000_READ_REG(&adapter->shared, TPT);
+    adapter->stats.ptc64 += E1000_READ_REG(&adapter->shared, PTC64);
+    adapter->stats.ptc127 += E1000_READ_REG(&adapter->shared, PTC127);
+    adapter->stats.ptc255 += E1000_READ_REG(&adapter->shared, PTC255);
+    adapter->stats.ptc511 += E1000_READ_REG(&adapter->shared, PTC511);
+    adapter->stats.ptc1023 += E1000_READ_REG(&adapter->shared, PTC1023);
+    adapter->stats.ptc1522 += E1000_READ_REG(&adapter->shared, PTC1522);
+    adapter->stats.mptc += E1000_READ_REG(&adapter->shared, MPTC);
+    adapter->stats.bptc += E1000_READ_REG(&adapter->shared, BPTC);
+
+    if(adapter->shared.mac_type >= e1000_82543) {
+        adapter->stats.algnerrc += E1000_READ_REG(&adapter->shared, ALGNERRC);
+        adapter->stats.rxerrc += E1000_READ_REG(&adapter->shared, RXERRC);
+        adapter->stats.tncrs += E1000_READ_REG(&adapter->shared, TNCRS);
+        adapter->stats.cexterr += E1000_READ_REG(&adapter->shared, CEXTERR);
+        adapter->stats.tsctc += E1000_READ_REG(&adapter->shared, TSCTC);
+        adapter->stats.tsctfc += E1000_READ_REG(&adapter->shared, TSCTFC);
+    }
+
+    /* Fill out the OS statistics structure */
+
+    adapter->net_stats.rx_packets = adapter->stats.gprc;
+    adapter->net_stats.tx_packets = adapter->stats.gptc;
+    adapter->net_stats.rx_bytes = adapter->stats.gorcl;
+    adapter->net_stats.tx_bytes = adapter->stats.gotcl;
+    adapter->net_stats.multicast = adapter->stats.mprc;
+    adapter->net_stats.collisions = adapter->stats.colc;
+
+    /* Rx Errors */
+
+    adapter->net_stats.rx_errors =
+        adapter->stats.rxerrc + adapter->stats.crcerrs +
+        adapter->stats.algnerrc + adapter->stats.rlec + adapter->stats.rnbc +
+        adapter->stats.mpc + adapter->stats.cexterr;
+    adapter->net_stats.rx_dropped = adapter->stats.rnbc;
+    adapter->net_stats.rx_length_errors = adapter->stats.rlec;
+    adapter->net_stats.rx_crc_errors = adapter->stats.crcerrs;
+    adapter->net_stats.rx_frame_errors = adapter->stats.algnerrc;
+    adapter->net_stats.rx_fifo_errors = adapter->stats.mpc;
+    adapter->net_stats.rx_missed_errors = adapter->stats.mpc;
+
+    /* Tx Errors */
+
+    adapter->net_stats.tx_errors = adapter->stats.ecol + adapter->stats.latecol;
+    adapter->net_stats.tx_aborted_errors = adapter->stats.ecol;
+    adapter->net_stats.tx_window_errors = adapter->stats.latecol;
+
+    /* Tx Dropped needs to be maintained elsewhere */
+
+    if(adapter->shared.media_type == e1000_media_type_copper) {
+        adapter->phy_stats.idle_errors +=
+            (e1000_read_phy_reg(&adapter->shared, PHY_1000T_STATUS)
+             & PHY_IDLE_ERROR_COUNT_MASK);
+        adapter->phy_stats.receive_errors +=
+            e1000_read_phy_reg(&adapter->shared, M88E1000_RX_ERR_CNTR);
+    }
+
+    spin_unlock_irqrestore(&adapter->stats_lock, flags);
+    return;
+}
+
+/**
+ * e1000_irq_disable - Mask off interrupt generation on the NIC
+ * @adapter: board private structure
+ **/
+
+static inline void
+e1000_irq_disable(struct e1000_adapter *adapter)
+{
+    E1000_DBG("e1000_irq_disable\n");
+
+    /* Mask off all interrupts */
+
+    E1000_WRITE_REG(&adapter->shared, IMC, ~0);
+    return;
+}
+
+/**
+ * e1000_irq_enable - Enable default interrupt generation settings
+ * @adapter: board private structure
+ **/
+
+static inline void
+e1000_irq_enable(struct e1000_adapter *adapter)
+{
+    E1000_DBG("e1000_irq_enable\n");
+
+    E1000_WRITE_REG(&adapter->shared, IMS, adapter->int_mask);
+    return;
+}
+
+/**
+ * e1000_intr - Interrupt Handler
+ * @irq: interrupt number
+ * @data: pointer to a network interface device structure
+ * @pt_regs: CPU registers structure
+ **/
+
+void
+e1000_intr(int irq,
+           void *data,
+           struct pt_regs *regs)
+{
+    struct net_device *netdev = (struct net_device *) data;
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t icr;
+    uint loop_count = E1000_MAX_INTR;
+
+    E1000_DBG("e1000_intr\n");
+
+    e1000_irq_disable(adapter);
+
+    while(loop_count > 0 && (icr = E1000_READ_REG(&adapter->shared, ICR)) != 0) {
+
+        if(icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
+            adapter->shared.get_link_status = 1;
+            set_bit(E1000_LINK_STATUS_CHANGED, &adapter->flags);
+            /* run the watchdog ASAP */
+            mod_timer(&adapter->timer_id, jiffies);
+        }
+
+        e1000_clean_rx_irq(adapter);
+        e1000_clean_tx_irq(adapter);
+        loop_count--;
+    }
+
+    e1000_irq_enable(adapter);
+
+    return;
+}
+
+/**
+ * e1000_clean_tx_irq - Reclaim resources after transmit completes
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_tx_irq(struct e1000_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    int i;
+
+    struct e1000_tx_desc *tx_desc;
+    struct net_device *netdev = adapter->netdev;
+
+    E1000_DBG("e1000_clean_tx_irq\n");
+
+    i = adapter->tx_ring.next_to_clean;
+    tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+    while(tx_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) {
+
+        if(adapter->tx_ring.buffer_info[i].dma != 0) {
+            pci_unmap_page(pdev, adapter->tx_ring.buffer_info[i].dma,
+                           adapter->tx_ring.buffer_info[i].length,
+                           PCI_DMA_TODEVICE);
+            adapter->tx_ring.buffer_info[i].dma = 0;
+        }
+
+        if(adapter->tx_ring.buffer_info[i].skb != NULL) {
+            dev_kfree_skb_irq(adapter->tx_ring.buffer_info[i].skb);
+            adapter->tx_ring.buffer_info[i].skb = NULL;
+        }
+
+        atomic_inc(&adapter->tx_ring.unused);
+        i = (i + 1) % adapter->tx_ring.count;
+
+        tx_desc->upper.data = 0;
+        tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+    }
+
+    adapter->tx_ring.next_to_clean = i;
+
+    if(adapter->tx_ring.next_to_clean == adapter->tx_ring.next_to_use)
+        atomic_set(&adapter->tx_timeout, 0);
+    else
+        atomic_set(&adapter->tx_timeout, 3);
+
+    if(netif_queue_stopped(netdev) &&
+       (atomic_read(&adapter->tx_ring.unused) >
+        (adapter->tx_ring.count * 3 / 4))) {
+
+#ifdef IANS
+        if((adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) &&
+           (adapter->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON))
+            if(ans_notify)
+                ans_notify(netdev, IANS_IND_XMIT_QUEUE_READY);
+#endif
+        netif_wake_queue(netdev);
+    }
+
+    return;
+}
+
+/**
+ * e1000_clean_rx_irq - Send received data up the network stack,
+ * @adapter: board private structure
+ **/
+
+static void
+e1000_clean_rx_irq(struct e1000_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_rx_desc *rx_desc;
+    int i;
+    uint32_t length;
+    struct sk_buff *skb;
+    uint8_t last_byte;
+    unsigned long flags;
+
+    E1000_DBG("e1000_clean_rx_irq\n");
+
+    i = adapter->rx_ring.next_to_clean;
+    rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+    while(rx_desc->status & E1000_RXD_STAT_DD) {
+        pci_unmap_single(pdev, adapter->rx_ring.buffer_info[i].dma,
+                         adapter->rx_ring.buffer_info[i].length,
+                         PCI_DMA_FROMDEVICE);
+
+        skb = adapter->rx_ring.buffer_info[i].skb;
+        length = le16_to_cpu(rx_desc->length);
+
+        if(!(rx_desc->status & E1000_RXD_STAT_EOP)) {
+
+            /* All receives must fit into a single buffer */
+
+            E1000_DBG("Receive packet consumed multiple buffers\n");
+
+            dev_kfree_skb_irq(skb);
+            memset(rx_desc, 0, 16);
+            mb();
+            adapter->rx_ring.buffer_info[i].skb = NULL;
+
+            atomic_inc(&adapter->rx_ring.unused);
+
+            i = (i + 1) % adapter->rx_ring.count;
+
+            rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+            continue;
+        }
+
+        if(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK) {
+
+            last_byte = *(skb->data + length - 1);
+
+            if(TBI_ACCEPT
+               (&adapter->shared, rx_desc->status, rx_desc->errors, length,
+                last_byte)) {
+                spin_lock_irqsave(&adapter->stats_lock, flags);
+                e1000_tbi_adjust_stats(&adapter->shared, &adapter->stats,
+                                       length, skb->data);
+                spin_unlock_irqrestore(&adapter->stats_lock, flags);
+                length--;
+            } else {
+
+                E1000_DBG("Receive Errors Reported by Hardware\n");
+
+                dev_kfree_skb_irq(skb);
+                memset(rx_desc, 0, 16);
+                mb();
+                adapter->rx_ring.buffer_info[i].skb = NULL;
+
+                atomic_inc(&adapter->rx_ring.unused);
+                i = (i + 1) % adapter->rx_ring.count;
+
+                rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+                continue;
+            }
+        }
+
+        /* Good Receive */
+        skb_put(skb, length - CRC_LENGTH);
+
+        /* Adjust socket buffer accounting to only cover the ethernet frame
+         * Not what the stack intends, but there exist TCP problems that
+         * break NFS for network interfaces that need 2k receive buffers
+         */
+        skb->truesize = skb->len;
+
+        /* Receive Checksum Offload */
+        e1000_rx_checksum(adapter, rx_desc, skb);
+
+#ifdef IANS
+        if(adapter->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
+            if(bd_ans_os_Receive(adapter, rx_desc, skb) == BD_ANS_FAILURE)
+                dev_kfree_skb_irq(skb);
+            else
+                netif_rx(skb);
+        } else {
+            skb->protocol = eth_type_trans(skb, netdev);
+            netif_rx(skb);
+        }
+#else
+        skb->protocol = eth_type_trans(skb, netdev);
+        netif_rx(skb);
+#endif
+        memset(rx_desc, 0, 16);
+        mb();
+        adapter->rx_ring.buffer_info[i].skb = NULL;
+
+        atomic_inc(&adapter->rx_ring.unused);
+
+        i = (i + 1) % adapter->rx_ring.count;
+
+        rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+    }
+
+    /* if the Rx ring is less than 3/4 full, allocate more sk_buffs */
+
+    if(atomic_read(&adapter->rx_ring.unused) > (adapter->rx_ring.count / 4)) {
+        tasklet_schedule(&adapter->rx_fill_tasklet);
+    }
+    adapter->rx_ring.next_to_clean = i;
+
+    return;
+}
+
+/**
+ * e1000_alloc_rx_buffers - Replace used receive buffers
+ * @data: address of board private structure
+ **/
+
+static void
+e1000_alloc_rx_buffers(unsigned long data)
+{
+    struct e1000_adapter *adapter = (struct e1000_adapter *) data;
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_rx_desc *rx_desc;
+    struct sk_buff *skb;
+    int i;
+    int reserve_len;
+
+    E1000_DBG("e1000_alloc_rx_buffers\n");
+
+    /* kernel 2.4.7 seems to be broken with respect to tasklet locking */
+    if(!spin_trylock(&adapter->rx_fill_lock))
+        return;
+
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+        spin_unlock(&adapter->rx_fill_lock);
+        return;
+    }
+
+#ifdef IANS
+    reserve_len = E1000_ROUNDUP2(BD_ANS_INFO_SIZE, 16) + 2;
+#else
+    reserve_len = 2;
+#endif
+
+    i = adapter->rx_ring.next_to_use;
+
+    while(adapter->rx_ring.buffer_info[i].skb == NULL) {
+        rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+        skb = alloc_skb(adapter->rx_buffer_len + reserve_len, GFP_ATOMIC);
+
+        if(skb == NULL) {
+            /* Alloc Failed; If we could not allocate a
+             *  skb during this schedule. Wait for a while before
+             *  tasklet to allocate skb is called again.
+             */
+            set_bit(E1000_RX_REFILL, &adapter->flags);
+            break;
+        }
+
+        /* Make buffer alignment 2 beyond a 16 byte boundary
+         * this will result in a 16 byte aligned IP header after
+         * the 14 byte MAC header is removed
+         */
+        skb_reserve(skb, reserve_len);
+
+        skb->dev = netdev;
+
+        adapter->rx_ring.buffer_info[i].skb = skb;
+        adapter->rx_ring.buffer_info[i].length = adapter->rx_buffer_len;
+        adapter->rx_ring.buffer_info[i].dma =
+            pci_map_single(pdev, skb->data, adapter->rx_buffer_len,
+                           PCI_DMA_FROMDEVICE);
+
+        rx_desc->buffer_addr = cpu_to_le64(adapter->rx_ring.buffer_info[i].dma);
+
+        /* move tail */
+        E1000_WRITE_REG(&adapter->shared, RDT, i);
+
+        atomic_dec(&adapter->rx_ring.unused);
+
+        i = (i + 1) % adapter->rx_ring.count;
+
+        if(test_and_clear_bit(E1000_RX_REFILL, &adapter->flags)) {
+            /* Trigger Soft Interrupt */
+            E1000_WRITE_REG(&adapter->shared, ICS, E1000_ICS_RXT0);
+        }
+    }
+
+    adapter->rx_ring.next_to_use = i;
+
+    spin_unlock(&adapter->rx_fill_lock);
+    return;
+}
+
+/**
+ * e1000_ioctl - 
+ * @netdev:
+ * @ifreq:
+ * @cmd:
+ **/
+
+int
+e1000_ioctl(struct net_device *netdev,
+            struct ifreq *ifr,
+            int cmd)
+{
+#ifdef IANS
+    IANS_BD_PARAM_HEADER *header;
+#endif
+
+    E1000_DBG("e1000_do_ioctl\n");
+
+    switch (cmd) {
+
+#ifdef IANS
+    case IANS_BASE_SIOC:
+        header = (IANS_BD_PARAM_HEADER *) ifr->ifr_data;
+        if((header->Opcode != IANS_OP_EXT_GET_STATUS) &&
+           (!capable(CAP_NET_ADMIN)))
+            return -EPERM;
+        return bd_ans_os_Ioctl(netdev, ifr, cmd);
+        break;
+#endif
+
+#ifdef IDIAG
+    case IDIAG_PRO_BASE_SIOC:
+        if(!capable(CAP_NET_ADMIN))
+            return -EPERM;
+
+#ifdef DIAG_DEBUG
+        printk("Entering diagnostics\n");
+#endif
+        e1000_diag_ioctl(netdev, ifr);
+        break;
+#endif /* IDIAG */
+
+#ifdef SIOCETHTOOL
+    case SIOCETHTOOL:
+
+        return e1000_ethtool_ioctl(netdev, ifr);
+
+        break;
+#endif
+
+    default:
+        return -EOPNOTSUPP;
+    }
+
+    return 0;
+}
+
+/**
+ * e1000_rx_checksum - Receive Checksum Offload for 82543
+ * @adapter: board private structure
+ * @rx_desc: receive descriptor
+ * @sk_buff: socket buffer with received data
+ **/
+
+static inline void
+e1000_rx_checksum(struct e1000_adapter *adapter,
+                  struct e1000_rx_desc *rx_desc,
+                  struct sk_buff *skb)
+{
+    /* 82543 or newer only */
+    if((adapter->shared.mac_type < e1000_82543) ||
+       /* Ignore Checksum bit is set */
+       (rx_desc->status & E1000_RXD_STAT_IXSM) ||
+       /* TCP Checksum has not been calculated */
+       (!(rx_desc->status & E1000_RXD_STAT_TCPCS))) {
+
+        skb->ip_summed = CHECKSUM_NONE;
+        return;
+    }
+
+    /* At this point we know the hardware did the TCP checksum */
+    /* now look at the TCP checksum error bit */
+    if(rx_desc->errors & E1000_RXD_ERR_TCPE) {
+        /* let the stack verify checksum errors */
+        skb->ip_summed = CHECKSUM_NONE;
+        adapter->XsumRXError++;
+    } else {
+        /* TCP checksum is good */
+        skb->ip_summed = CHECKSUM_UNNECESSARY;
+        adapter->XsumRXGood++;
+    }
+
+    return;
+}
+
+void
+e1000_hibernate_adapter(struct net_device *netdev)
+{
+    uint32_t icr;
+    struct e1000_adapter *adapter = netdev->priv;
+
+    e1000_irq_disable(adapter);
+    netif_stop_queue(netdev);
+    adapter->shared.adapter_stopped = 0;
+    e1000_adapter_stop(&adapter->shared);
+
+    if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+
+        /* Disable tasklet only when interface is opened. */
+        tasklet_disable(&adapter->rx_fill_tasklet);
+
+        /* clean out old buffers */
+        e1000_clean_rx_ring(adapter);
+        e1000_clean_tx_ring(adapter);
+
+        /* Delete watchdog timer */
+        del_timer(&adapter->timer_id);
+
+        /* Unhook irq */
+        e1000_irq_disable(adapter);
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+        free_irq(netdev->irq, netdev);
+    }
+}
+
+void
+e1000_wakeup_adapter(struct net_device *netdev)
+{
+    uint32_t icr;
+    struct e1000_adapter *adapter = netdev->priv;
+
+    adapter->shared.adapter_stopped = 0;
+    e1000_adapter_stop(&adapter->shared);
+    adapter->shared.adapter_stopped = 0;
+    adapter->shared.fc = adapter->shared.original_fc;
+
+    if(!e1000_init_hw(&adapter->shared))
+        printk("Hardware Init Failed at wakeup\n");
+
+    if(test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+
+        /* Setup Rctl */
+        e1000_setup_rctl(adapter);
+        e1000_configure_rx(adapter);
+        e1000_alloc_rx_buffers((unsigned long) adapter);
+        e1000_set_multi(netdev);
+        e1000_configure_tx(adapter);
+
+#ifdef IANS
+        if((IANS_BD_TAGGING_MODE) (ANS_PRIVATE_DATA_FIELD(adapter)->tag_mode)
+           != IANS_BD_TAGGING_NONE)
+            bd_ans_hw_EnableVLAN(adapter);
+#endif
+
+        /* Set the watchdog timer for 2 seconds */
+        init_timer(&adapter->timer_id);
+        adapter->timer_id.function = &e1000_watchdog;
+        adapter->timer_id.data = (unsigned long) netdev;
+        mod_timer(&adapter->timer_id, (jiffies + 2 * HZ));
+
+        tasklet_enable(&adapter->rx_fill_tasklet);
+
+        /* Hook irq */
+        e1000_irq_disable(adapter);
+        icr = E1000_READ_REG(&adapter->shared, ICR);
+        if(request_irq
+           (netdev->irq, &e1000_intr, SA_SHIRQ, e1000_driver_name, netdev) != 0)
+            printk(KERN_ERR "e1000: Unable to hook irq.\n");
+
+        e1000_irq_enable(adapter);
+        netif_start_queue(netdev);
+    }
+}
+
+#ifdef IDIAG
+int
+e1000_xmit_lbtest_frame(struct sk_buff *skb,
+                        struct e1000_adapter *adapter)
+{
+    /*struct e1000_adapter *adapter = netdev->priv; */
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_tx_desc *tx_desc;
+    int i;
+
+    i = adapter->tx_ring.next_to_use;
+    tx_desc = E1000_TX_DESC(adapter->tx_ring, i);
+
+    adapter->tx_ring.buffer_info[i].skb = skb;
+    adapter->tx_ring.buffer_info[i].length = skb->len;
+    adapter->tx_ring.buffer_info[i].dma =
+        pci_map_page(pdev, virt_to_page(skb->data),
+                     (unsigned long) skb->data & ~PAGE_MASK, skb->len,
+                     PCI_DMA_TODEVICE);
+
+    tx_desc->buffer_addr = cpu_to_le64(adapter->tx_ring.buffer_info[i].dma);
+    tx_desc->lower.data = cpu_to_le32(skb->len);
+
+    /* zero out the status field in the descriptor */
+
+    tx_desc->upper.data = 0;
+
+    tx_desc->lower.data |= E1000_TXD_CMD_EOP;
+    tx_desc->lower.data |= E1000_TXD_CMD_IFCS;
+    tx_desc->lower.data |= E1000_TXD_CMD_IDE;
+
+    if(adapter->shared.report_tx_early == 1)
+        tx_desc->lower.data |= E1000_TXD_CMD_RS;
+    else
+        tx_desc->lower.data |= E1000_TXD_CMD_RPS;
+
+    /* Move the HW Tx Tail Pointer */
+
+    adapter->tx_ring.next_to_use++;
+    adapter->tx_ring.next_to_use %= adapter->tx_ring.count;
+
+    E1000_WRITE_REG(&adapter->shared, TDT, adapter->tx_ring.next_to_use);
+    mdelay(10);
+
+    atomic_dec(&adapter->tx_ring.unused);
+
+    if(atomic_read(&adapter->tx_ring.unused) <= 1) {
+
+        /* this driver never actually drops transmits,
+         * so use tx_dropped count to indicate the number of times
+         * netif_stop_queue is called due to no available descriptors
+         */
+
+        adapter->net_stats.tx_dropped++;
+        return (0);
+    }
+    return (1);
+}
+
+int
+e1000_rcv_lbtest_frame(struct e1000_adapter *adapter,
+                       unsigned int frame_size)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    struct e1000_rx_desc *rx_desc;
+    int i, j = 0, rcved_pkt = 0;
+    uint32_t Length;
+    struct sk_buff *skb;
+
+    mdelay(500);
+    i = adapter->rx_ring.next_to_clean;
+    rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+    while(rx_desc->status & E1000_RXD_STAT_DD) {
+        Length = le16_to_cpu(rx_desc->length) - CRC_LENGTH;
+        skb = adapter->rx_ring.buffer_info[i].skb;
+
+        /* Snoop the packet for pattern */
+        rcved_pkt = e1000_check_lbtest_frame(skb, frame_size);
+
+        pci_unmap_single(pdev, adapter->rx_ring.buffer_info[i].dma,
+                         adapter->rx_ring.buffer_info[i].length,
+                         PCI_DMA_FROMDEVICE);
+
+        dev_kfree_skb_irq(skb);
+        adapter->rx_ring.buffer_info[i].skb = NULL;
+
+        rx_desc->status = 0;
+        atomic_inc(&adapter->rx_ring.unused);
+
+        i++;
+        i %= adapter->rx_ring.count;
+        rx_desc = E1000_RX_DESC(adapter->rx_ring, i);
+
+        if(rcved_pkt)
+            break;
+
+        /* waited enough */
+        if(j++ >= adapter->rx_ring.count)
+            return 0;
+
+        mdelay(5);
+
+    }
+
+    adapter->rx_ring.next_to_clean = i;
+
+    return (rcved_pkt);
+
+}
+
+void
+e1000_selective_wakeup_adapter(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t ctrl, txcw;
+
+    e1000_init_hw(&adapter->shared);
+
+    if((adapter->link_active == FALSE) &&
+       (adapter->shared.mac_type == e1000_82543)) {
+
+        txcw = E1000_READ_REG(&adapter->shared, TXCW);
+        ctrl = E1000_READ_REG(&adapter->shared, CTRL);
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw & ~E1000_TXCW_ANE);
+        E1000_WRITE_REG(&adapter->shared, CTRL,
+                        (ctrl | E1000_CTRL_SLU | E1000_CTRL_ILOS |
+                         E1000_CTRL_FD));
+        mdelay(20);
+    }
+
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) {
+        set_bit(E1000_BOARD_OPEN, &adapter->flags);
+        set_bit(E1000_DIAG_OPEN, &adapter->flags);
+        e1000_setup_tx_resources(adapter);
+        e1000_setup_rx_resources(adapter);
+    }
+    e1000_setup_rctl(adapter);
+    e1000_configure_rx(adapter);
+    e1000_alloc_rx_buffers((unsigned long) adapter);
+    e1000_configure_tx(adapter);
+}
+
+void
+e1000_selective_hibernate_adapter(struct net_device *netdev)
+{
+    struct e1000_adapter *adapter = netdev->priv;
+    uint32_t ctrl, txcw;
+
+    if((adapter->link_active == FALSE) &&
+       (adapter->shared.mac_type == e1000_82543)) {
+
+        txcw = E1000_READ_REG(&adapter->shared, TXCW);
+        ctrl = E1000_READ_REG(&adapter->shared, CTRL);
+        ctrl &= ~E1000_CTRL_SLU & ~E1000_CTRL_ILOS;
+        E1000_WRITE_REG(&adapter->shared, TXCW, txcw | E1000_TXCW_ANE);
+        E1000_WRITE_REG(&adapter->shared, CTRL, ctrl);
+        mdelay(20);
+    }
+    /* clean out old buffers */
+    e1000_clean_rx_ring(adapter);
+    e1000_clean_tx_ring(adapter);
+    if(test_and_clear_bit(E1000_DIAG_OPEN, &adapter->flags)) {
+        e1000_free_tx_resources(adapter);
+        e1000_free_rx_resources(adapter);
+        clear_bit(E1000_BOARD_OPEN, &adapter->flags);
+    }
+}
+
+static int
+e1000_check_lbtest_frame(struct sk_buff *skb,
+                         unsigned int frame_size)
+{
+    frame_size = (frame_size % 2) ? (frame_size - 1) : frame_size;
+    if(*(skb->data + 3) == 0xFF) {
+        if((*(skb->data + frame_size / 2 + 10) == 0xBE) &&
+           (*(skb->data + frame_size / 2 + 12) == 0xAF)) {
+            return 1;
+        }
+    }
+    return 0;
+}
+#endif /* IDIAG */
+
+#ifdef SIOCETHTOOL
+/**
+ * e1000_ethtool_ioctl - Ethtool Ioctl Support 
+ * @netdev: net device structure 
+ * @ifr: interface request structure 
+ **/
+
+static int
+e1000_ethtool_ioctl(struct net_device *netdev,
+                    struct ifreq *ifr)
+{
+    struct ethtool_cmd eth_cmd;
+    struct e1000_adapter *adapter = netdev->priv;
+    boolean_t re_initiate = FALSE;
+
+#ifdef ETHTOOL_GLINK
+    struct ethtool_value eth_e1000_linkinfo;
+#endif
+#ifdef ETHTOOL_GDRVINFO
+    struct ethtool_drvinfo eth_e1000_info;
+#endif
+#ifdef ETHTOOL_GWOL
+    struct ethtool_wolinfo eth_e1000_wolinfo;
+#endif
+
+    /* Get the data structure */
+    if(copy_from_user(&eth_cmd, ifr->ifr_data, sizeof(eth_cmd)))
+        return -EFAULT;
+
+    switch (eth_cmd.cmd) {
+        /* Get the information */
+    case ETHTOOL_GSET:
+        if(adapter->shared.media_type == e1000_media_type_copper) {
+            eth_cmd.supported = E1000_ETHTOOL_COPPER_INTERFACE_SUPPORTS;
+            eth_cmd.advertising = E1000_ETHTOOL_COPPER_INTERFACE_ADVERTISE;
+            eth_cmd.port = PORT_MII;
+            eth_cmd.phy_address = adapter->shared.phy_addr;
+            eth_cmd.transceiver =
+                (adapter->shared.mac_type >
+                 e1000_82543) ? XCVR_INTERNAL : XCVR_EXTERNAL;
+        } else {
+            eth_cmd.supported = E1000_ETHTOOL_FIBER_INTERFACE_SUPPORTS;
+            eth_cmd.advertising = E1000_ETHTOOL_FIBER_INTERFACE_ADVERTISE;
+            eth_cmd.port = PORT_FIBRE;
+        }
+
+        if(adapter->link_active == TRUE) {
+            e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                       &adapter->link_duplex);
+            eth_cmd.speed = adapter->link_speed;
+            eth_cmd.duplex =
+                (adapter->link_duplex ==
+                 FULL_DUPLEX) ? DUPLEX_FULL : DUPLEX_HALF;
+        } else {
+            eth_cmd.speed = 0;
+            eth_cmd.duplex = 0;
+        }
+
+        if(adapter->shared.autoneg)
+            eth_cmd.autoneg = AUTONEG_ENABLE;
+        else
+            eth_cmd.autoneg = AUTONEG_DISABLE;
+
+        if(copy_to_user(ifr->ifr_data, &eth_cmd, sizeof(eth_cmd)))
+            return -EFAULT;
+
+        break;
+
+        /* set information */
+    case ETHTOOL_SSET:
+        /* need proper permission to do set */
+        if(!capable(CAP_NET_ADMIN))
+            return -EPERM;
+
+        /* Cannot Force speed/duplex and at the same time autoneg.
+         * Autoneg will override forcing. 
+         * For example to force speed/duplex pass in 
+         *  'speed 100 duplex half autoneg off'
+         * pass in 'autoneg on' to start autoneg.
+         */
+        printk("e1000: Requested link to be forced to %d Speed, %s Duplex "
+               "%s\n", eth_cmd.speed, (eth_cmd.duplex ? "Full" : "Half"),
+               (eth_cmd.autoneg ? "and Autonegotiate" : "."));
+
+        if(eth_cmd.autoneg && eth_cmd.speed)
+            printk("e1000: Autoneg request will over-ride speed forcing\n");
+
+        /* if not in autoneg mode and have been asked to enable autoneg */
+        if(eth_cmd.autoneg) {
+            if(adapter->shared.autoneg &&
+               adapter->shared.autoneg_advertised == AUTONEG_ADV_DEFAULT)
+                /* If already in Autoneg */
+                return 0;
+            else {
+                adapter->shared.autoneg = 1;
+                adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+                re_initiate = TRUE;
+            }
+        }
+        /* Force link to whatever speed and duplex */
+        /* Also turning off Autoneg in case of non-gig speeds */
+        else if(eth_cmd.speed) {
+            /* Check for invalid request */
+            if(((eth_cmd.speed != SPEED_10) && (eth_cmd.speed != SPEED_100) &&
+                (eth_cmd.speed != SPEED_1000)) ||
+               ((eth_cmd.duplex != DUPLEX_HALF) &&
+                (eth_cmd.duplex != DUPLEX_FULL)) ||
+               (adapter->shared.media_type == e1000_media_type_fiber))
+                return -EINVAL;
+
+            e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed,
+                                       &adapter->link_duplex);
+            /* If we are already forced to requested speed and duplex
+             * Donot do anything, just return
+             */
+            if(!adapter->shared.autoneg &&
+               (adapter->link_speed == eth_cmd.speed) &&
+               (adapter->link_duplex == (eth_cmd.duplex + 1)))
+
+                return 0;
+
+            adapter->shared.autoneg = 0;
+            adapter->shared.autoneg_advertised = 0;
+            re_initiate = TRUE;
+            switch (eth_cmd.speed + eth_cmd.duplex) {
+            case (SPEED_10 + DUPLEX_HALF):
+                adapter->shared.forced_speed_duplex = e1000_10_half;
+                break;
+            case (SPEED_100 + DUPLEX_HALF):
+                adapter->shared.forced_speed_duplex = e1000_100_half;
+                break;
+            case (SPEED_10 + DUPLEX_FULL):
+                adapter->shared.forced_speed_duplex = e1000_10_full;
+                break;
+            case (SPEED_100 + DUPLEX_FULL):
+                adapter->shared.forced_speed_duplex = e1000_100_full;
+                break;
+            case (SPEED_1000 + DUPLEX_HALF):
+                printk("Half Duplex is not supported at 1000 Mbps\n");
+            case (SPEED_1000 + DUPLEX_FULL):
+                printk("Using Auto-neg at 1000 Mbps Full Duplex\n");
+            default:
+                adapter->shared.autoneg = 1;
+                adapter->shared.autoneg_advertised = ADVERTISE_1000_FULL;
+                break;
+            }
+        }
+
+        /* End of force */
+        /* Put the adapter to new settings */
+        if(re_initiate == TRUE) {
+            e1000_hibernate_adapter(netdev);
+            e1000_wakeup_adapter(netdev);
+        } else if(!eth_cmd.autoneg && !eth_cmd.speed) {
+            printk("Cannot turn off autoneg without "
+                   "knowing what speed to force the link\n");
+            printk("Speed specified was %dMbps\n", eth_cmd.speed);
+            return -EINVAL;
+        }
+        /* We donot support setting of 
+         * whatever else that was requested */
+        else
+            return -EOPNOTSUPP;
+
+        break;
+
+#ifdef ETHTOOL_NWAY_RST
+    case ETHTOOL_NWAY_RST:
+        /* need proper permission to restart auto-negotiation */
+        if(!capable(CAP_NET_ADMIN))
+            return -EPERM;
+
+        adapter->shared.autoneg = 1;
+        adapter->shared.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+        e1000_hibernate_adapter(netdev);
+        e1000_wakeup_adapter(netdev);
+
+        break;
+#endif
+
+#ifdef ETHTOOL_GLINK
+    case ETHTOOL_GLINK:
+        eth_e1000_linkinfo.data = adapter->link_active;
+        if(copy_to_user(ifr->ifr_data, &eth_e1000_linkinfo, sizeof(eth_e1000_linkinfo)))
+            return -EFAULT;
+        break;
+#endif
+
+#ifdef ETHTOOL_GDRVINFO
+    case ETHTOOL_GDRVINFO:
+        strcpy(eth_e1000_info.driver, e1000_driver_name);
+        strcpy(eth_e1000_info.version, e1000_driver_version);
+        strcpy(eth_e1000_info.fw_version, "None");
+        strcpy(eth_e1000_info.bus_info, adapter->pdev->slot_name);
+        if(copy_to_user(ifr->ifr_data, &eth_e1000_info, sizeof(eth_e1000_info)))
+            return -EFAULT;
+        break;
+#endif
+
+#ifdef ETHTOOL_GWOL
+    case ETHTOOL_GWOL:
+        eth_e1000_wolinfo.supported = eth_e1000_wolinfo.wolopts = WAKE_MAGIC;
+        if(copy_to_user
+           (ifr->ifr_data, &eth_e1000_wolinfo, sizeof(eth_e1000_wolinfo)))
+            return -EFAULT;
+        break;
+#endif
+
+    default:
+        return -EOPNOTSUPP;
+    }
+
+    return 0;
+
+}
+#endif /* SIOCETHTOOL */
+
+/**
+ * e1000_enable_WOL - Wake On Lan Support (Magic Pkt)
+ * @adapter: Adapter structure 
+ **/
+
+static void
+e1000_enable_WOL(struct e1000_adapter *adapter)
+{
+    uint32_t wuc_val;
+
+    if(adapter->shared.mac_type <= e1000_82543)
+        return;
+
+    /* Set up Wake-Up Ctrl reg */
+    wuc_val = E1000_READ_REG(&adapter->shared, WUC);
+    wuc_val &= ~(E1000_WUC_APME | E1000_WUC_APMPME);
+    wuc_val |= (E1000_WUC_PME_STATUS | E1000_WUC_PME_EN);
+
+    E1000_WRITE_REG(&adapter->shared, WUC, wuc_val);
+
+    /* Set up Wake-up Filter */
+    E1000_WRITE_REG(&adapter->shared, WUFC, E1000_WUFC_MAG);
+
+    return;
+}
+
+/**
+ * e1000_write_pci_cg -
+ * @shared:
+ * @reg:
+ * @value:
+ **/
+
+void
+e1000_write_pci_cfg(struct e1000_shared_adapter *shared,
+                    uint32_t reg,
+                    uint16_t *value)
+{
+    struct e1000_adapter *adapter = (struct e1000_adapter *) shared->back;
+
+    pci_write_config_word(adapter->pdev, reg, *value);
+    return;
+}
+
+/* e1000_main.c */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_osdep.h linux/drivers/net/e1000/e1000_osdep.h
--- ../ia64/linux/drivers/net/e1000/e1000_osdep.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_osdep.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,138 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+/* glue for the OS independant part of e1000 
+ * includes register access macros
+ */
+
+#ifndef _E1000_OSDEP_H_
+#define _E1000_OSDEP_H_
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+#define usec_delay(x) udelay(x)
+#define msec_delay(x) mdelay(x)
+
+#define PCI_COMMAND_REGISTER   PCI_COMMAND
+#define CMD_MEM_WRT_INVALIDATE PCI_COMMAND_INVALIDATE
+
+typedef enum {
+    FALSE = 0,
+    TRUE = 1
+} boolean_t;
+
+#if DBG
+#define ASSERT(x) if(!(x)) panic("E1000: x")
+#define DEBUGOUT(S)         printk(S "\n")
+#define DEBUGOUT1(S,A)      printk(S "\n",A)
+#define DEBUGOUT2(S,A,B)    printk(S "\n",A,B)
+#define DEBUGOUT3(S,A,B,C)  printk(S "\n",A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G)  printk(S "\n",A,B,C,D,E,F,G)
+#else
+#define ASSERT(x)
+#define DEBUGOUT(S)
+#define DEBUGOUT1(S,A)
+#define DEBUGOUT2(S,A,B)
+#define DEBUGOUT3(S,A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G)
+#endif
+
+#define MSGOUT(S, A, B)     printk(S "\n", A, B)
+#define DEBUGFUNC(F)        DEBUGOUT(F)
+
+#define E1000_WRITE_REG(a, reg, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        (writel((value), ((a)->hw_addr + E1000_##reg))) : \
+        (writel((value), ((a)->hw_addr + E1000_82542_##reg))))
+
+#define E1000_READ_REG(a, reg) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg) : \
+        readl((a)->hw_addr + E1000_82542_##reg))
+
+#define E1000_WRITE_REG_ARRAY(a, reg, offset, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        writel((value), ((a)->hw_addr + E1000_##reg + ((offset) << 2))) : \
+        writel((value), ((a)->hw_addr + E1000_82542_##reg + ((offset) << 2))))
+
+#define E1000_READ_REG_ARRAY(a, reg, offset) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg + ((offset) << 2)) : \
+        readl((a)->hw_addr + E1000_82542_##reg + ((offset) << 2)))
+
+#endif /* _E1000_OSDEP_H_ */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_phy.c linux/drivers/net/e1000/e1000_phy.c
--- ../ia64/linux/drivers/net/e1000/e1000_phy.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_phy.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,1576 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_phy.c
+ * Shared functions for accessing and configuring the PHY
+ */
+
+#include "e1000_mac.h"
+#include "e1000_phy.h"
+
+/******************************************************************************
+* Raises the Management Data Clock
+*
+* shared - Struct containing variables accessed by shared code
+* ctrl_reg - Device control register's current value
+******************************************************************************/
+static void
+e1000_raise_mdc(struct e1000_shared_adapter *shared,
+                uint32_t *ctrl_reg)
+{
+    /* Raise the clock input to the Management Data Clock (by setting
+     * the MDC bit), and then delay 2 microseconds.
+     */
+    E1000_WRITE_REG(shared, CTRL, (*ctrl_reg | E1000_CTRL_MDC));
+    usec_delay(2);
+    return;
+}
+
+/******************************************************************************
+* Lowers the Management Data Clock
+*
+* shared - Struct containing variables accessed by shared code
+* ctrl_reg - Device control register's current value
+******************************************************************************/
+static void
+e1000_lower_mdc(struct e1000_shared_adapter *shared,
+                uint32_t *ctrl_reg)
+{
+    /* Lower the clock input to the Management Data Clock (by clearing
+     * the MDC bit), and then delay 2 microseconds.
+     */
+    E1000_WRITE_REG(shared, CTRL, (*ctrl_reg & ~E1000_CTRL_MDC));
+    usec_delay(2);
+    return;
+}
+
+/******************************************************************************
+* Shifts data bits out to the PHY
+*
+* shared - Struct containing variables accessed by shared code
+* data - Data to send out to the PHY
+* count - Number of bits to shift out
+*
+* Bits are shifted out in MSB to LSB order.
+******************************************************************************/
+static void
+e1000_phy_shift_out(struct e1000_shared_adapter *shared,
+                    uint32_t data,
+                    uint16_t count)
+{
+    uint32_t ctrl_reg;
+    uint32_t mask;
+
+    ASSERT(count <= 32);
+
+    /* We need to shift "count" number of bits out to the PHY.  So, the
+     * value in the "Data" parameter will be shifted out to the PHY
+     * one bit at a time.  In order to do this, "Data" must be broken
+     * down into bits, which is what the "while" logic does below.
+     */
+    mask = 0x01;
+    mask <<= (count - 1);
+
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set MDIO_DIR (SWDPIO1) and MDC_DIR (SWDPIO2) direction bits to
+     * be used as output pins.
+     */
+    ctrl_reg |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
+
+    while(mask) {
+        /* A "1" is shifted out to the PHY by setting the MDIO bit to
+         * "1" and then raising and lowering the Management Data Clock
+         * (MDC).  A "0" is shifted out to the PHY by setting the MDIO
+         * bit to "0" and then raising and lowering the clock.
+         */
+        if(data & mask)
+            ctrl_reg |= E1000_CTRL_MDIO;
+        else
+            ctrl_reg &= ~E1000_CTRL_MDIO;
+
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        usec_delay(2);
+
+        e1000_raise_mdc(shared, &ctrl_reg);
+        e1000_lower_mdc(shared, &ctrl_reg);
+
+        mask = mask >> 1;
+    }
+
+    /* Clear the data bit just before leaving this routine. */
+    ctrl_reg &= ~E1000_CTRL_MDIO;
+    return;
+}
+
+/******************************************************************************
+* Shifts data bits in from the PHY
+*
+* shared - Struct containing variables accessed by shared code
+*
+* Bits are shifted in in MSB to LSB order. 
+******************************************************************************/
+static uint16_t
+e1000_phy_shift_in(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+    uint16_t data = 0;
+    uint8_t i;
+
+    /* In order to read a register from the PHY, we need to shift in a
+     * total of 18 bits from the PHY.  The first two bit (TurnAround)
+     * times are used to avoid contention on the MDIO pin when a read
+     * operation is performed.  These two bits are ignored by us and
+     * thrown away.  Bits are "shifted in" by raising the clock input
+     * to the Management Data Clock (setting the MDC bit), and then
+     * reading the value of the MDIO bit.
+     */ 
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as
+     * input.
+     */ 
+    ctrl_reg &= ~E1000_CTRL_MDIO_DIR;
+    ctrl_reg &= ~E1000_CTRL_MDIO;
+
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    /* Raise and Lower the clock before reading in the data.  This
+     * accounts for the TurnAround bits.  The first clock occurred
+     * when we clocked out the last bit of the Register Address.
+     */
+    e1000_raise_mdc(shared, &ctrl_reg);
+    e1000_lower_mdc(shared, &ctrl_reg);
+
+    for(data = 0, i = 0; i < 16; i++) {
+        data = data << 1;
+        e1000_raise_mdc(shared, &ctrl_reg);
+
+        ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+        /* Check to see if we shifted in a "1". */
+        if(ctrl_reg & E1000_CTRL_MDIO)
+            data |= 1;
+
+        e1000_lower_mdc(shared, &ctrl_reg);
+    }
+
+    e1000_raise_mdc(shared, &ctrl_reg);
+    e1000_lower_mdc(shared, &ctrl_reg);
+
+    /* Clear the MDIO bit just before leaving this routine. */
+    ctrl_reg &= ~E1000_CTRL_MDIO;
+
+    return (data);
+}
+
+/******************************************************************************
+* Force PHY speed and duplex settings to shared->forced_speed_duplex
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+static void
+e1000_phy_force_speed_duplex(struct e1000_shared_adapter *shared)
+{
+    uint32_t tctl_reg;
+    uint32_t ctrl_reg;
+    uint32_t shift;
+    uint16_t mii_ctrl_reg;
+    uint16_t mii_status_reg;
+    uint16_t phy_data;
+    uint16_t i;
+
+    DEBUGFUNC("e1000_phy_force_speed_duplex");
+
+    /* Turn off Flow control if we are forcing speed and duplex. */
+    shared->fc = e1000_fc_none;
+
+    DEBUGOUT1("shared->fc = %d\n", shared->fc);
+
+    /* Read the Device Control Register. */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    /* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
+    ctrl_reg |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+    ctrl_reg &= ~(DEVICE_SPEED_MASK);
+
+    /* Clear the Auto Speed Detect Enable bit. */
+    ctrl_reg &= ~E1000_CTRL_ASDE;
+
+    /* Read the MII Control Register. */
+    mii_ctrl_reg = e1000_read_phy_reg(shared, PHY_CTRL);
+
+    /* We need to disable autoneg in order to force link and duplex. */
+
+    mii_ctrl_reg &= ~MII_CR_AUTO_NEG_EN;
+
+    /* Are we forcing Full or Half Duplex? */
+    if(shared->forced_speed_duplex == e1000_100_full ||
+       shared->forced_speed_duplex == e1000_10_full) {
+
+        /* We want to force full duplex so we SET the full duplex bits
+         * in the Device and MII Control Registers.
+         */
+        ctrl_reg |= E1000_CTRL_FD;
+        mii_ctrl_reg |= MII_CR_FULL_DUPLEX;
+
+        DEBUGOUT("Full Duplex\n");
+    } else {
+
+        /* We want to force half duplex so we CLEAR the full duplex
+         * bits in the Device and MII Control Registers.
+         */
+        ctrl_reg &= ~E1000_CTRL_FD;
+        mii_ctrl_reg &= ~MII_CR_FULL_DUPLEX;    /* Do this implies HALF */
+
+        DEBUGOUT("Half Duplex\n");
+    }
+
+    /* Are we forcing 100Mbps??? */
+    if(shared->forced_speed_duplex == e1000_100_full ||
+       shared->forced_speed_duplex == e1000_100_half) {
+
+        /* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
+        ctrl_reg |= E1000_CTRL_SPD_100;
+        mii_ctrl_reg |= MII_CR_SPEED_100;
+        mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_10);
+
+        DEBUGOUT("Forcing 100mb ");
+    } else {                    /* Force 10MB Full or Half */
+
+        /* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
+        ctrl_reg &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
+        mii_ctrl_reg |= MII_CR_SPEED_10;
+        mii_ctrl_reg &= ~(MII_CR_SPEED_1000 | MII_CR_SPEED_100);
+
+        DEBUGOUT("Forcing 10mb ");
+    }
+
+    /* Now we need to configure the Collision Distance.  We need to read
+     * the Transmit Control Register to do this.
+     * Note: This must be done for both Half or Full Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    DEBUGOUT1("tctl_reg = %x\n", tctl_reg);
+
+    if(!(mii_ctrl_reg & MII_CR_FULL_DUPLEX)) {
+
+       /* We are in Half Duplex mode so we need to set up our collision
+        * distance for 10/100.
+        */
+        tctl_reg &= ~E1000_TCTL_COLD;
+        shift = E1000_HDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    } else {
+        /* We are in Full Duplex mode.  We have the same collision
+         * distance regardless of speed.
+         */
+        tctl_reg &= ~E1000_TCTL_COLD;
+        shift = E1000_FDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    }
+
+    /* Write the configured values back to the Transmit Control Reg. */
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    /* Write the configured values back to the Device Control Reg. */
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    /* Write the MII Control Register with the new PHY configuration. */
+    phy_data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    /* Clear Auto-Crossover to force MDI manually.
+     * M88E1000 requires MDI forced whenever speed/duplex is forced
+     */
+    phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_data);
+
+    DEBUGOUT1("M88E1000 PSCR: %x \n", phy_data);
+
+    /* Need to reset the PHY or these bits will get ignored. */
+    mii_ctrl_reg |= MII_CR_RESET;
+
+    e1000_write_phy_reg(shared, PHY_CTRL, mii_ctrl_reg);
+
+    /* The wait_autoneg_complete flag may be a little misleading here.
+     * Since we are forcing speed and duplex, Auto-Neg is not enabled.
+     * But we do want to delay for a period while forcing only so we
+     * don't generate false No Link messages.  So we will wait here
+     * only if the user has set wait_autoneg_complete to 1, which is
+     * the default.
+     */
+    if(shared->wait_autoneg_complete) {
+        /* We will wait for autoneg to complete. */
+        DEBUGOUT("Waiting for forced speed/duplex link.\n");
+        mii_status_reg = 0;
+
+        /* We will wait for autoneg to complete or 4.5 seconds to expire. */
+        for(i = PHY_FORCE_TIME; i > 0; i--) {
+            /* Read the MII Status Register and wait for Auto-Neg
+             * Complete bit to be set.
+             */
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+            if(mii_status_reg & MII_SR_LINK_STATUS)
+                break;
+
+            msec_delay(100);
+        }                       /* end for loop */
+
+        if(i == 0) {            /* We didn't get link   */
+
+            /* Reset the DSP and wait again for link.   */
+            e1000_phy_reset_dsp(shared);
+        }
+
+        /* This loop will early-out if the link condition has been met.  */
+        for(i = PHY_FORCE_TIME; i > 0; i--) {
+            if(mii_status_reg & MII_SR_LINK_STATUS)
+                break;
+
+            msec_delay(100);
+            /* Read the MII Status Register and wait for Auto-Neg
+             * Complete bit to be set.
+             */
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+            mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        }                       /* end for loop */
+    }    /* end if wait_autoneg_complete */
+    /*
+     * Because we reset the PHY above, we need to re-force TX_CLK in the
+     * Extended PHY Specific Control Register to 25MHz clock.  This
+     * value defaults back to a 2.5MHz clock when the PHY is reset.
+     */
+    phy_data = e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+
+    phy_data |= M88E1000_EPSCR_TX_CLK_25;
+
+    e1000_write_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL, phy_data);
+
+    /* In addition, because of the s/w reset above, we need to enable
+     * CRS on TX.  This must be set for both full and half duplex
+     * operation.
+     */
+    phy_data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_data);
+    DEBUGOUT1("M88E1000 Phy Specific Ctrl Reg = %4x\r\n", phy_data);
+
+    return;
+}
+
+/*****************************************************************************
+* Reads the value from a PHY register
+*
+* shared - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to read
+******************************************************************************/
+uint16_t
+e1000_read_phy_reg(struct e1000_shared_adapter *shared,
+                   uint32_t reg_addr)
+{
+    uint32_t i;
+    uint32_t data = 0;
+    uint32_t command = 0;
+
+    ASSERT(reg_addr <= MAX_PHY_REG_ADDRESS);
+
+    if(shared->mac_type > e1000_82543) {
+        /* Set up Op-code, Phy Address, and
+         * register address in the MDI Control register.  The MAC will
+         * take care of interfacing with the PHY to retrieve the
+         * desired data.
+         */
+        command = ((reg_addr << E1000_MDIC_REG_SHIFT) |
+                   (shared->phy_addr << E1000_MDIC_PHY_SHIFT) | 
+                   (E1000_MDIC_OP_READ));
+
+        E1000_WRITE_REG(shared, MDIC, command);
+
+        /* Check every 10 usec to see if the read completed.  The read
+         * may take as long as 64 usecs (we'll wait 100 usecs max)
+         * from the CPU Write to the Ready bit assertion.
+         */
+        for(i = 0; i < 64; i++) {
+            usec_delay(10);
+
+            data = E1000_READ_REG(shared, MDIC);
+
+            if(data & E1000_MDIC_READY)
+                break;
+        }
+    } else {
+        /* We must first send a preamble through the MDIO pin to signal the
+         * beginning of an MII instruction.  This is done by sending 32
+         * consecutive "1" bits.
+         */
+        e1000_phy_shift_out(shared, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+
+        /* Now combine the next few fields that are required for a read
+         * operation.  We use this method instead of calling the
+         * e1000_phy_shift_out routine five different times.  The format of
+         * a MII read instruction consists of a shift out of 14 bits and is
+         * defined as follows:
+         *    <Preamble><SOF><Op Code><Phy Addr><Reg Addr>
+         * followed by a shift in of 18 bits.  This first two bits shifted
+         * in are TurnAround bits used to avoid contention on the MDIO pin
+         * when a READ operation is performed.  These two bits are thrown
+         * away followed by a shift in of 16 bits which contains the
+         * desired data.
+         */
+        command = ((reg_addr) |
+                   (shared->phy_addr << 5) |
+                   (PHY_OP_READ << 10) | (PHY_SOF << 12));
+
+        e1000_phy_shift_out(shared, command, 14);
+
+        /* Now that we've shifted out the read command to the MII, we need
+         * to "shift in" the 16-bit value (18 total bits) of the requested
+         * PHY register address.
+         */
+        data = (uint32_t) e1000_phy_shift_in(shared);
+    }
+
+    ASSERT(!(data & E1000_MDIC_ERROR));
+
+    return ((uint16_t) data);
+}
+
+/******************************************************************************
+* Writes a value to a PHY register
+*
+* shared - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to write
+* data - data to write to the PHY
+******************************************************************************/
+void
+e1000_write_phy_reg(struct e1000_shared_adapter *shared,
+                    uint32_t reg_addr,
+                    uint16_t data)
+{
+    uint32_t i;
+    uint32_t command = 0;
+    uint32_t mdic_reg;
+
+    ASSERT(reg_addr <= MAX_PHY_REG_ADDRESS);
+
+    if(shared->mac_type > e1000_82543) {
+        /* Set up Op-code, Phy Address, register
+         * address, and data intended for the PHY register in the MDI
+         * Control register.  The MAC will take care of interfacing
+         * with the PHY to send the desired data.
+         */
+        command = (((uint32_t) data) |
+                   (reg_addr << E1000_MDIC_REG_SHIFT) |
+                   (shared->phy_addr << E1000_MDIC_PHY_SHIFT) | 
+                   (E1000_MDIC_OP_WRITE));
+
+        E1000_WRITE_REG(shared, MDIC, command);
+
+        /* Check every 10 usec to see if the read completed.  The read
+         * may take as long as 64 usecs (we'll wait 100 usecs max)
+         * from the CPU Write to the Ready bit assertion.
+         */
+        for(i = 0; i < 10; i++) {
+            usec_delay(10);
+
+            mdic_reg = E1000_READ_REG(shared, MDIC);
+
+            if(mdic_reg & E1000_MDIC_READY)
+                break;
+        }
+    } else {
+        /* We'll need to use the SW defined pins to shift the write command
+         *  out to the PHY. We first send a preamble to the PHY to signal the
+         * beginning of the MII instruction.  This is done by sending 32 
+         * consecutive "1" bits.
+         */
+        e1000_phy_shift_out(shared, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+
+        /* Now combine the remaining required fields that will indicate
+         * a write operation.  We use this method instead of calling the
+         * e1000_phy_shift_out routine for each field in the command.  The
+         * format of a MII write instruction is as follows:
+         * <Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.
+         */
+        command = ((PHY_TURNAROUND) |
+                   (reg_addr << 2) |
+                   (shared->phy_addr << 7) |
+                   (PHY_OP_WRITE << 12) | (PHY_SOF << 14));
+        command <<= 16;
+        command |= ((uint32_t) data);
+
+        e1000_phy_shift_out(shared, command, 32);
+    }
+    return;
+}
+
+/******************************************************************************
+* Returns the PHY to the power-on reset state
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+void
+e1000_phy_hw_reset(struct e1000_shared_adapter *shared)
+{
+    uint32_t ctrl_reg;
+    uint32_t ctrl_ext_reg;
+
+    DEBUGFUNC("e1000_phy_hw_reset");
+
+    DEBUGOUT("Resetting Phy...\n");
+
+    if(shared->mac_type > e1000_82543) {
+        /* Read the device control register and assert the
+         * E1000_CTRL_PHY_RST bit.  Hold for 20ms and then take it out
+         * of reset.
+         */
+        ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+        ctrl_reg |= E1000_CTRL_PHY_RST;
+
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        msec_delay(20);
+
+        ctrl_reg &= ~E1000_CTRL_PHY_RST;
+
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        msec_delay(20);
+    } else {
+        /* Read the Extended Device Control Register, assert the
+         * PHY_RESET_DIR bit.  Then clock it out to the PHY.
+         */
+        ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+
+        ctrl_ext_reg |= E1000_CTRL_PHY_RESET_DIR4;
+
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+
+        msec_delay(20);
+
+        /* Set the reset bit in the device control register and clock
+         * it out to the PHY.
+         */
+        ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+
+        ctrl_ext_reg &= ~E1000_CTRL_PHY_RESET4;
+
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+
+        msec_delay(20);
+
+        ctrl_ext_reg = E1000_READ_REG(shared, CTRL_EXT);
+
+        ctrl_ext_reg |= E1000_CTRL_PHY_RESET4;
+
+        E1000_WRITE_REG(shared, CTRL_EXT, ctrl_ext_reg);
+
+        msec_delay(20);
+    }
+    return;
+}
+
+/******************************************************************************
+* Resets the PHY
+*
+* shared - Struct containing variables accessed by shared code
+*
+* Sets bit 15 of the MII Control regiser
+******************************************************************************/
+boolean_t
+e1000_phy_reset(struct e1000_shared_adapter *shared)
+{
+    uint16_t reg_data;
+    uint16_t i;
+
+    DEBUGFUNC("e1000_phy_reset");
+
+    /* Read the MII control register, set the reset bit and write the
+     * value back by clocking it out to the PHY.
+     */
+    reg_data = e1000_read_phy_reg(shared, PHY_CTRL);
+
+    reg_data |= MII_CR_RESET;
+
+    e1000_write_phy_reg(shared, PHY_CTRL, reg_data);
+
+    /* Wait for bit 15 of the MII Control Register to be cleared
+     * indicating the PHY has been reset.
+     */
+    i = 0;
+    while((reg_data & MII_CR_RESET) && i++ < 500) {
+        reg_data = e1000_read_phy_reg(shared, PHY_CTRL);
+        usec_delay(1);
+    }
+
+    if(i >= 500) {
+        DEBUGOUT("Timeout waiting for PHY to reset.\n");
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/******************************************************************************
+* Detects which PHY is present and the speed and duplex
+*
+* shared - Struct containing variables accessed by shared code
+* ctrl_reg - current value of the device control register
+******************************************************************************/
+boolean_t
+e1000_phy_setup(struct e1000_shared_adapter *shared,
+                uint32_t ctrl_reg)
+{
+    uint16_t mii_ctrl_reg;
+    uint16_t mii_status_reg;
+    uint16_t phy_specific_ctrl_reg;
+    uint16_t mii_autoneg_adv_reg;
+    uint16_t mii_1000t_ctrl_reg;
+    uint16_t i;
+    uint16_t data;
+    uint16_t autoneg_hw_setting;
+    uint16_t autoneg_fc_setting;
+    boolean_t restart_autoneg = FALSE;
+    boolean_t force_autoneg_restart = FALSE;
+
+    DEBUGFUNC("e1000_phy_setup");
+
+    /* We want to enable the Auto-Speed Detection bit in the Device
+     * Control Register.  When set to 1, the MAC automatically detects
+     * the resolved speed of the link and self-configures appropriately.
+     * The Set Link Up bit must also be set for this behavior work
+     * properly.
+     */
+    /* Nothing but 82543 and newer */
+    ASSERT(shared->mac_type >= e1000_82543);
+
+    /* With 82543, we need to force speed/duplex
+     * on the MAC equal to what the PHY speed/duplex configuration is.
+     * In addition, on 82543, we need to perform a hardware reset
+     * on the PHY to take it out of reset.
+     */
+    if(shared->mac_type >= e1000_82544) {
+        ctrl_reg |= E1000_CTRL_SLU;
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+    } else {
+        ctrl_reg |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
+        E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+        if(shared->mac_type == e1000_82543)
+            e1000_phy_hw_reset(shared);
+    }
+
+    if(!e1000_detect_gig_phy(shared)) {
+        /* No PHY detected, return FALSE */
+        DEBUGOUT("PhySetup failure, did not detect valid phy.\n");
+        return (FALSE);
+    }
+
+    DEBUGOUT1("Phy ID = %x \n", shared->phy_id);
+
+    /* Read the MII Control Register. */
+    mii_ctrl_reg = e1000_read_phy_reg(shared, PHY_CTRL);
+
+    DEBUGOUT1("MII Ctrl Reg contents = %x\n", mii_ctrl_reg);
+
+    /* Check to see if the Auto Neg Enable bit is set in the MII Control
+     * Register.  If not, we could be in a situation where a driver was
+     * loaded previously and was forcing speed and duplex.  Then the
+     * driver was unloaded but a e1000_phy_hw_reset was not performed, so
+     * link was still being forced and link was still achieved.  Then
+     * the driver was reloaded with the intention to auto-negotiate, but
+     * since link is already established we end up not restarting
+     * auto-neg.  So if the auto-neg bit is not enabled and the driver
+     * is being loaded with the desire to auto-neg, we set this flag to
+     * to ensure the restart of the auto-neg engine later in the logic.
+     */
+    if(!(mii_ctrl_reg & MII_CR_AUTO_NEG_EN))
+        force_autoneg_restart = TRUE;
+
+    /* Clear the isolate bit for normal operation and write it back to
+     * the MII Control Reg.  Although the spec says this doesn't need
+     * to be done when the PHY address is not equal to zero, we do it
+     * anyway just to be safe.
+     */
+    mii_ctrl_reg &= ~(MII_CR_ISOLATE);
+
+    e1000_write_phy_reg(shared, PHY_CTRL, mii_ctrl_reg);
+
+    data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    /* Enable CRS on TX.  This must be set for half-duplex operation. */
+    data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+
+    DEBUGOUT1("M88E1000 PSCR: %x \n", data);
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+
+    /* Force TX_CLK in the Extended PHY Specific Control Register
+     * to 25MHz clock.
+     */
+    data |= M88E1000_EPSCR_TX_CLK_25;
+
+    e1000_write_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL, data);
+
+    /* Certain PHYs will set the default of MII register 4 differently.
+     * We need to check this against our fc value.  If it is
+     * different, we need to setup up register 4 correctly and restart
+     * autonegotiation.
+     */
+    /* Read the MII Auto-Neg Advertisement Register (Address 4). */
+    mii_autoneg_adv_reg = e1000_read_phy_reg(shared, PHY_AUTONEG_ADV);
+
+    /* Shift right to put 10T-Half bit in bit 0
+     * Isolate the four bits for 100/10 Full/Half.
+     */ 
+    autoneg_hw_setting = (mii_autoneg_adv_reg >> 5) & 0xF;
+
+    /* Get the 1000T settings. */
+    mii_1000t_ctrl_reg = e1000_read_phy_reg(shared, PHY_1000T_CTRL);
+
+    /* Isolate and OR in the 1000T settings. */
+    autoneg_hw_setting |= ((mii_1000t_ctrl_reg & 0x0300) >> 4);
+
+    /* mask all bits in the MII Auto-Neg Advertisement Register
+     * except for ASM_DIR and PAUSE and shift.  This value
+     * will be used later to see if we need to restart Auto-Negotiation.
+     */
+    autoneg_fc_setting = ((mii_autoneg_adv_reg & 0x0C00) >> 10);
+
+    /* Perform some bounds checking on the shared->autoneg_advertised
+     * parameter.  If this variable is zero, then set it to the default.
+     */
+    shared->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
+
+    /* If autoneg_advertised is zero, we assume it was not defaulted
+     * by the calling code so we set to advertise full capability.
+     */
+    if(shared->autoneg_advertised == 0)
+        shared->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+
+    /* We could be in the situation where Auto-Neg has already completed
+     * and the user has not indicated any overrides.  In this case we
+     * simply need to call e1000_get_speed_and_duplex to obtain the Auto-
+     * Negotiated speed and duplex, then return.
+     */
+    if(!force_autoneg_restart && shared->autoneg &&
+       (shared->autoneg_advertised == autoneg_hw_setting) &&
+       (shared->fc == autoneg_fc_setting)) {
+
+        DEBUGOUT("No overrides - Reading MII Status Reg..\n");
+
+        /* Read the MII Status Register.  We read this twice because
+         * certain bits are "sticky" and need to be read twice.
+         */
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        DEBUGOUT1("MII Status Reg contents = %x\n", mii_status_reg);
+
+        /* Do we have link now? (if so, auto-neg has completed) */
+        if(mii_status_reg & MII_SR_LINK_STATUS) {
+            data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+            DEBUGOUT1("M88E1000 Phy Specific Status Reg contents = %x\n", data);
+
+            /* We have link, so we need to finish the config process:
+             *   1) Set up the MAC to the current PHY speed/duplex
+             *      if we are on 82543.  If we
+             *      are on newer silicon, we only need to configure
+             *      collision distance in the Transmit Control Register.
+             *   2) Set up flow control on the MAC to that established
+             *      with the link partner.
+             */
+            if(shared->mac_type >= e1000_82544)
+                e1000_config_collision_dist(shared);
+            else
+                e1000_config_mac_to_phy(shared, data);
+
+            e1000_config_fc_after_link_up(shared);
+
+            return (TRUE);
+        }
+    }
+
+    /* Options:
+     *   MDI/MDI-X = 0 (default)
+     *   0 - Auto for all speeds
+     *   1 - MDI mode
+     *   2 - MDI-X mode
+     *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
+     */
+    phy_specific_ctrl_reg = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    phy_specific_ctrl_reg &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+    switch (shared->mdix) {
+    case 1:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_MDI_MANUAL_MODE;
+        break;
+    case 2:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_MDIX_MANUAL_MODE;
+        break;
+    case 3:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_AUTO_X_1000T;
+        break;
+    case 0:
+    default:
+        phy_specific_ctrl_reg |= M88E1000_PSCR_AUTO_X_MODE;
+        break;
+    }
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_specific_ctrl_reg);
+
+    /* Options:
+     *   disable_polarity_correction = 0 (default)
+     *       Automatic Correction for Reversed Cable Polarity
+     *   0 - Disabled
+     *   1 - Enabled
+     */
+    phy_specific_ctrl_reg = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+
+    phy_specific_ctrl_reg &= ~M88E1000_PSCR_POLARITY_REVERSAL;
+
+    if(shared->disable_polarity_correction == 1)
+        phy_specific_ctrl_reg |= M88E1000_PSCR_POLARITY_REVERSAL;
+
+    e1000_write_phy_reg(shared, M88E1000_PHY_SPEC_CTRL, phy_specific_ctrl_reg);
+
+    /* Options:
+     *   autoneg = 1 (default)
+     *      PHY will advertise value(s) parsed from
+     *      autoneg_advertised and fc
+     *   autoneg = 0
+     *      PHY will be set to 10H, 10F, 100H, or 100F
+     *      depending on value parsed from forced_speed_duplex.
+     */
+
+    /* Is autoneg enabled?  This is enabled by default or by software override.
+     * If so, call e1000_phy_setup_autoneg routine to parse the
+     * autoneg_advertised and fc options. If autoneg is NOT enabled, then the
+     * user should have provided a speed/duplex override.  If so, then call
+     * e1000_phy_force_speed_duplex to parse and set this up.  Otherwise,
+     * we are in an error situation and need to bail.
+     */
+    if(shared->autoneg) {
+        DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
+        restart_autoneg = e1000_phy_setup_autoneg(shared);
+    } else {
+        DEBUGOUT("Forcing speed and duplex\n");
+        e1000_phy_force_speed_duplex(shared);
+    }
+
+    /* Based on information parsed above, check the flag to indicate
+     * whether we need to restart Auto-Neg.
+     */
+    if(restart_autoneg) {
+        DEBUGOUT("Restarting Auto-Neg\n");
+
+        /* Read the MII Control Register. */
+        mii_ctrl_reg = e1000_read_phy_reg(shared, PHY_CTRL);
+
+        /* Restart auto-negotiation by setting the Auto Neg Enable bit and
+         * the Auto Neg Restart bit.
+         */
+        mii_ctrl_reg |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
+
+        e1000_write_phy_reg(shared, PHY_CTRL, mii_ctrl_reg);
+
+        /* Does the user want to wait for Auto-Neg to complete here, or
+         * check at a later time (for example, callback routine).
+         */
+        if(shared->wait_autoneg_complete)
+            e1000_wait_autoneg(shared);
+    } /* end if restart_autoneg */
+
+    /* Read the MII Status Register. */
+    mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+    DEBUGOUT1("Checking for link status - MII Status Reg contents = %x\n",
+              mii_status_reg);
+
+    /* Check link status.  Wait up to 100 microseconds for link to
+     * become valid.
+     */
+    for(i = 0; i < 10; i++) {
+        if(mii_status_reg & MII_SR_LINK_STATUS)
+            break;
+        usec_delay(10);
+        DEBUGOUT(". ");
+
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    }
+
+    if(mii_status_reg & MII_SR_LINK_STATUS) {
+        /* Yes, so configure MAC to PHY settings as well as flow control
+         * registers.
+         */
+        data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+
+        DEBUGOUT1("M88E1000 Phy Specific Status Reg contents = %x\n", data);
+
+        /* We have link, so we need to finish the config process:
+         *   1) Set up the MAC to the current PHY speed/duplex
+         *      if we are on 82543.  If we
+         *      are on newer silicon, we only need to configure
+         *      collision distance in the Transmit Control Register.
+         *   2) Set up flow control on the MAC to that established with
+         *      the link partner.
+         */
+        if(shared->mac_type >= e1000_82544)
+            e1000_config_collision_dist(shared);
+        else
+            e1000_config_mac_to_phy(shared, data);
+
+        e1000_config_fc_after_link_up(shared);
+
+        DEBUGOUT("Valid link established!!!\n");
+    } else {
+        DEBUGOUT("Unable to establish link!!!\n");
+    }
+
+    return (TRUE);
+}
+
+/******************************************************************************
+* Configures PHY autoneg and flow control advertisement settings
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+boolean_t
+e1000_phy_setup_autoneg(struct e1000_shared_adapter *shared)
+{
+    uint16_t mii_autoneg_adv_reg;
+    uint16_t mii_1000t_ctrl_reg;
+
+    DEBUGFUNC("e1000_phy_setup_autoneg");
+
+    /* Read the MII Auto-Neg Advertisement Register (Address 4). */
+    mii_autoneg_adv_reg = e1000_read_phy_reg(shared, PHY_AUTONEG_ADV);
+
+    /* Read the MII 1000Base-T Control Register (Address 9). */
+    mii_1000t_ctrl_reg = e1000_read_phy_reg(shared, PHY_1000T_CTRL);
+
+    /* Need to parse both autoneg_advertised and fc and set up
+     * the appropriate PHY registers.  First we will parse for
+     * autoneg_advertised software override.  Since we can advertise
+     * a plethora of combinations, we need to check each bit
+     * individually.
+     */
+
+    /* First we clear all the 10/100 mb speed bits in the Auto-Neg
+     * Advertisement Register (Address 4) and the 1000 mb speed bits in
+     * the  1000Base-T Control Register (Address 9).
+     */
+    mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
+    mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
+
+    DEBUGOUT1("autoneg_advertised %x\n", shared->autoneg_advertised);
+
+    /* Do we want to advertise 10 Mb Half Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_10_HALF) {
+        DEBUGOUT("Advertise 10mb Half duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
+    }
+
+    /* Do we want to advertise 10 Mb Full Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_10_FULL) {
+        DEBUGOUT("Advertise 10mb Full duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
+    }
+
+    /* Do we want to advertise 100 Mb Half Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_100_HALF) {
+        DEBUGOUT("Advertise 100mb Half duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
+    }
+
+    /* Do we want to advertise 100 Mb Full Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_100_FULL) {
+        DEBUGOUT("Advertise 100mb Full duplex\n");
+        mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
+    }
+
+    /* We do not allow the Phy to advertise 1000 Mb Half Duplex */
+    if(shared->autoneg_advertised & ADVERTISE_1000_HALF) {
+        DEBUGOUT("Advertise 1000mb Half duplex requested, request denied!\n");
+    }
+
+    /* Do we want to advertise 1000 Mb Full Duplex? */
+    if(shared->autoneg_advertised & ADVERTISE_1000_FULL) {
+        DEBUGOUT("Advertise 1000mb Full duplex\n");
+        mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
+    }
+
+    /* Check for a software override of the flow control settings, and
+     * setup the PHY advertisement registers accordingly.  If
+     * auto-negotiation is enabled, then software will have to set the
+     * "PAUSE" bits to the correct value in the Auto-Negotiation
+     * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.
+     *
+     * The possible values of the "fc" parameter are:
+     *      0:  Flow control is completely disabled
+     *      1:  Rx flow control is enabled (we can receive pause frames
+     *          but not send pause frames).
+     *      2:  Tx flow control is enabled (we can send pause frames
+     *          but we do not support receiving pause frames).
+     *      3:  Both Rx and TX flow control (symmetric) are enabled.
+     *  other:  No software override.  The flow control configuration
+     *          in the EEPROM is used.
+     */
+    switch (shared->fc) {
+    case e1000_fc_none:        /* 0 */
+            /* Flow control (RX & TX) is completely disabled by a
+             * software over-ride.
+             */
+        mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+        break;
+    case e1000_fc_rx_pause:    /* 1 */
+            /* RX Flow control is enabled, and TX Flow control is
+             * disabled, by a software over-ride.
+             */
+
+            /* Since there really isn't a way to advertise that we are
+             * capable of RX Pause ONLY, we will advertise that we
+             * support both symmetric and asymmetric RX PAUSE.  Later
+             * (in e1000_config_fc_after_link_up) we will disable the
+             *shared's ability to send PAUSE frames.
+             */
+        mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+        break;
+    case e1000_fc_tx_pause:    /* 2 */
+            /* TX Flow control is enabled, and RX Flow control is
+             * disabled, by a software over-ride.
+             */
+        mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
+        mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
+        break;
+    case e1000_fc_full:        /* 3 */
+            /* Flow control (both RX and TX) is enabled by a software
+             * over-ride.
+             */
+        mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+        break;
+    default:
+            /* We should never get here.  The value should be 0-3. */
+        DEBUGOUT("Flow control param set incorrectly\n");
+        ASSERT(0);
+        break;
+    }
+
+    /* Write the MII Auto-Neg Advertisement Register (Address 4). */
+    e1000_write_phy_reg(shared, PHY_AUTONEG_ADV, mii_autoneg_adv_reg);
+
+    DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
+
+    /* Write the MII 1000Base-T Control Register (Address 9). */
+    e1000_write_phy_reg(shared, PHY_1000T_CTRL, mii_1000t_ctrl_reg);
+    return (TRUE);
+}
+
+/******************************************************************************
+* Sets MAC speed and duplex settings to reflect the those in the PHY
+*
+* shared - Struct containing variables accessed by shared code
+* mii_reg - data to write to the MII control register
+*
+* The contents of the PHY register containing the needed information need to
+* be passed in.
+******************************************************************************/
+void
+e1000_config_mac_to_phy(struct e1000_shared_adapter *shared,
+                        uint16_t mii_reg)
+{
+    uint32_t ctrl_reg;
+    uint32_t tctl_reg;
+    uint32_t shift;
+
+    DEBUGFUNC("e1000_config_mac_to_phy");
+
+    /* We need to read the Transmit Control register to configure the
+     * collision distance.
+     * Note: This must be done for both Half or Full Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    DEBUGOUT1("tctl_reg = %x\n", tctl_reg);
+
+    /* Read the Device Control Register and set the bits to Force Speed
+     * and Duplex.
+     */
+    ctrl_reg = E1000_READ_REG(shared, CTRL);
+
+    ctrl_reg |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+    ctrl_reg &= ~(DEVICE_SPEED_MASK);
+
+    DEBUGOUT1("MII Register Data = %x\r\n", mii_reg);
+
+    /* Clear the ILOS bit. */
+    ctrl_reg &= ~E1000_CTRL_ILOS;
+
+    /* Set up duplex in the Device Control and Transmit Control
+     * registers depending on negotiated values.
+     */
+    if(mii_reg & M88E1000_PSSR_DPLX) {
+        ctrl_reg |= E1000_CTRL_FD;
+
+        /* We are in Full Duplex mode.  We have the same collision
+         * distance regardless of speed.
+         */
+        tctl_reg &= ~E1000_TCTL_COLD;
+        shift = E1000_FDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    } else {
+        ctrl_reg &= ~E1000_CTRL_FD;
+
+        /* We are in Half Duplex mode.  Our Half Duplex collision
+         * distance is different for Gigabit than for 10/100 so we will
+         * set accordingly.
+         */
+        if((mii_reg & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS) { 
+            /* 1000Mbs HDX */
+            tctl_reg &= ~E1000_TCTL_COLD;
+            shift = E1000_GB_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+            tctl_reg |= E1000_TCTL_PBE; /* Enable Packet Bursting */
+        } else {
+            /* 10/100Mbs HDX */
+            tctl_reg &= ~E1000_TCTL_COLD;
+            shift = E1000_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+        }
+    }
+
+    /* Set up speed in the Device Control register depending on
+     * negotiated values.
+     */
+    if((mii_reg & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
+        ctrl_reg |= E1000_CTRL_SPD_1000;
+    else if((mii_reg & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
+        ctrl_reg |= E1000_CTRL_SPD_100;
+    else
+        ctrl_reg &= ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);
+
+    /* Write the configured values back to the Transmit Control Reg. */
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    /* Write the configured values back to the Device Control Reg. */
+    E1000_WRITE_REG(shared, CTRL, ctrl_reg);
+
+    return;
+}
+
+/******************************************************************************
+* Sets the collision distance in the Transmit Control register
+*
+* shared - Struct containing variables accessed by shared code
+*
+* Link should have been established previously. Reads the speed and duplex
+* information from the Device Status register.
+******************************************************************************/
+void
+e1000_config_collision_dist(struct e1000_shared_adapter *shared)
+{
+    uint32_t tctl_reg;
+    uint16_t speed;
+    uint16_t duplex;
+    uint32_t shift;
+
+    DEBUGFUNC("e1000_config_collision_dist");
+
+    /* Get our current speed and duplex from the Device Status Register. */
+    e1000_get_speed_and_duplex(shared, &speed, &duplex);
+
+    /* We need to configure the Collision Distance for both Full or
+     * Half Duplex.
+     */
+    tctl_reg = E1000_READ_REG(shared, TCTL);
+    DEBUGOUT1("tctl_reg = %x\n", tctl_reg);
+
+    /* mask the Collision Distance bits in the Transmit Control Reg. */
+    tctl_reg &= ~E1000_TCTL_COLD;
+
+    if(duplex == FULL_DUPLEX) {
+        /* We are in Full Duplex mode.  Therefore, the collision distance
+         * is the same regardless of speed.
+         */
+        shift = E1000_FDX_COLLISION_DISTANCE;
+        shift <<= E1000_COLD_SHIFT;
+        tctl_reg |= shift;
+    } else {
+        /* We are in Half Duplex mode.  Half Duplex collision distance is
+         * different for Gigabit vs. 10/100, so we will set accordingly.
+         */
+        if(speed == SPEED_1000) {       /* 1000Mbs HDX */
+            shift = E1000_GB_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+            tctl_reg |= E1000_TCTL_PBE; /* Enable Packet Bursting */
+        } else {                /* 10/100Mbs HDX */
+            shift = E1000_HDX_COLLISION_DISTANCE;
+            shift <<= E1000_COLD_SHIFT;
+            tctl_reg |= shift;
+        }
+    }
+
+    /* Write the configured values back to the Transmit Control Reg. */
+    E1000_WRITE_REG(shared, TCTL, tctl_reg);
+
+    return;
+}
+
+#if DBG
+/******************************************************************************
+* Displays the contents of all of the MII registers
+*
+* shared - Struct containing variables accessed by shared code
+*
+* For debugging.
+******************************************************************************/
+void
+e1000_display_mii(struct e1000_shared_adapter *shared)
+{
+    uint16_t data;
+    uint16_t phy_id_high;
+    uint16_t phy_id_low;
+    uint32_t phy_id;
+
+    DEBUGFUNC("e1000_display_mii");
+
+    DEBUGOUT1("adapter Base Address = %x\n", shared->hw_addr);
+
+    /* This will read each PHY Reg address and display its contents. */
+
+    data = e1000_read_phy_reg(shared, PHY_CTRL);
+    DEBUGOUT1("MII Ctrl Reg contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_STATUS);
+    data = e1000_read_phy_reg(shared, PHY_STATUS);
+    DEBUGOUT1("MII Status Reg contents = %x\n", data);
+
+    phy_id_high = e1000_read_phy_reg(shared, PHY_ID1);
+    usec_delay(2);
+    phy_id_low = e1000_read_phy_reg(shared, PHY_ID2);
+    phy_id = (phy_id_low | (phy_id_high << 16)) & PHY_REVISION_MASK;
+    DEBUGOUT1("Phy ID = %x \n", phy_id);
+
+    data = e1000_read_phy_reg(shared, PHY_AUTONEG_ADV);
+    DEBUGOUT1("Reg 4 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_LP_ABILITY);
+    DEBUGOUT1("Reg 5 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_AUTONEG_EXP);
+    DEBUGOUT1("Reg 6 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_NEXT_PAGE_TX);
+    DEBUGOUT1("Reg 7 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_LP_NEXT_PAGE);
+    DEBUGOUT1("Reg 8 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_1000T_CTRL);
+    DEBUGOUT1("Reg 9 contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_1000T_STATUS);
+    DEBUGOUT1("Reg A contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, PHY_EXT_STATUS);
+    DEBUGOUT1("Reg F contents = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+    DEBUGOUT1("M88E1000 Specific Control Reg (0x10) = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+    DEBUGOUT1("M88E1000 Specific Status Reg (0x11) = %x\n", data);
+
+    /*
+     * data = e1000_read_phy_reg(shared, M88E1000_INT_ENABLE_REG);
+     * DEBUGOUT1("M88E1000 Interrupt Enable Reg (0x12) = %x\n", data);
+     */
+
+    /*
+     * data = e1000_read_phy_reg(shared, M88E1000_INT_STATUS_REG);
+     * DEBUGOUT1("M88E1000 Interrupt Status Reg (0x13) = %x\n", data);
+     */
+     
+    data = e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+    DEBUGOUT1("M88E1000 Ext. Phy Specific Control (0x14) = %x\n", data);
+
+    data = e1000_read_phy_reg(shared, M88E1000_RX_ERR_CNTR);
+    DEBUGOUT1("M88E1000 Receive Error Counter (0x15) = %x\n", data);
+
+    /*
+     * data = e1000_read_phy_reg(shared, M88E1000_LED_CTRL_REG);
+     * DEBUGOUT1("M88E1000 LED control reg (0x18) = %x\n", data);
+     */
+
+    return;
+}
+#endif // DBG
+
+/******************************************************************************
+* Probes the expected PHY address for known PHY IDs
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+boolean_t
+e1000_detect_gig_phy(struct e1000_shared_adapter *shared)
+{
+    uint32_t phy_id_high;
+    uint16_t phy_id_low;
+
+    DEBUGFUNC("e1000_detect_gig_phy");
+
+    /* Read the PHY ID Registers to identify which PHY is onboard. */
+    shared->phy_addr = 1;
+
+    phy_id_high = e1000_read_phy_reg(shared, PHY_ID1);
+
+    usec_delay(2);
+
+    phy_id_low = e1000_read_phy_reg(shared, PHY_ID2);
+
+    shared->phy_id = (phy_id_low | (phy_id_high << 16)) & PHY_REVISION_MASK;
+
+    if(shared->phy_id == M88E1000_12_PHY_ID ||
+       shared->phy_id == M88E1000_14_PHY_ID ||
+       shared->phy_id == M88E1000_I_PHY_ID  ||
+       shared->phy_id == M88E1011_I_PHY_ID) {
+
+        DEBUGOUT2("phy_id 0x%x detected at address 0x%x\n",
+                  shared->phy_id, shared->phy_addr);
+        return (TRUE);
+    } else {
+        DEBUGOUT("Could not auto-detect Phy!\n");
+        return (FALSE);
+    }
+}
+
+/******************************************************************************
+* Resets the PHY's DSP
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+void
+e1000_phy_reset_dsp(struct e1000_shared_adapter *shared)
+{
+    e1000_write_phy_reg(shared, 29, 0x1d);
+    e1000_write_phy_reg(shared, 30, 0xc1);
+    e1000_write_phy_reg(shared, 30, 0x00);
+    return;
+}
+
+/******************************************************************************
+* Blocks until autoneg completes or times out (~4.5 seconds)
+*
+* shared - Struct containing variables accessed by shared code
+******************************************************************************/
+boolean_t
+e1000_wait_autoneg(struct e1000_shared_adapter *shared)
+{
+    uint16_t i;
+    uint16_t mii_status_reg;
+    boolean_t autoneg_complete = FALSE;
+
+    DEBUGFUNC("e1000_wait_autoneg");
+
+    /* We will wait for autoneg to complete. */
+    DEBUGOUT("Waiting for Auto-Neg to complete.\n");
+    mii_status_reg = 0;
+
+    /* We will wait for autoneg to complete or 4.5 seconds to expire. */
+
+    for(i = PHY_AUTO_NEG_TIME; i > 0; i--) {
+        /* Read the MII Status Register and wait for Auto-Neg
+         * Complete bit to be set.
+         */
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+        mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+
+        if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
+            autoneg_complete = TRUE;
+            break;
+        }
+
+        msec_delay(100);
+    }
+
+    return (autoneg_complete);
+}
+
+/******************************************************************************
+* Get PHY information from various PHY registers
+*
+* shared - Struct containing variables accessed by shared code
+* phy_status_info - PHY information structure
+******************************************************************************/
+boolean_t
+e1000_phy_get_info(struct e1000_shared_adapter *shared,
+                   struct e1000_phy_info *phy_status_info)
+{
+    uint16_t phy_mii_status_reg;
+    uint16_t phy_specific_ctrl_reg;
+    uint16_t phy_specific_status_reg;
+    uint16_t phy_specific_ext_ctrl_reg;
+    uint16_t phy_1000t_stat_reg;
+
+    phy_status_info->cable_length = e1000_cable_length_undefined;
+    phy_status_info->extended_10bt_distance =
+        e1000_10bt_ext_dist_enable_undefined;
+    phy_status_info->cable_polarity = e1000_rev_polarity_undefined;
+    phy_status_info->polarity_correction = e1000_polarity_reversal_undefined;
+    phy_status_info->link_reset = e1000_down_no_idle_undefined;
+    phy_status_info->mdix_mode = e1000_auto_x_mode_undefined;
+    phy_status_info->local_rx = e1000_1000t_rx_status_undefined;
+    phy_status_info->remote_rx = e1000_1000t_rx_status_undefined;
+
+    /* PHY info only valid for copper media. */
+    if(shared == NULL || shared->media_type != e1000_media_type_copper)
+        return FALSE;
+
+    /* PHY info only valid for LINK UP.  Read MII status reg 
+     * back-to-back to get link status.
+     */
+    phy_mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    phy_mii_status_reg = e1000_read_phy_reg(shared, PHY_STATUS);
+    if((phy_mii_status_reg & MII_SR_LINK_STATUS) != MII_SR_LINK_STATUS)
+        return FALSE;
+
+    /* Read various PHY registers to get the PHY info. */
+    phy_specific_ctrl_reg = e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_CTRL);
+    phy_specific_status_reg =
+        e1000_read_phy_reg(shared, M88E1000_PHY_SPEC_STATUS);
+    phy_specific_ext_ctrl_reg =
+        e1000_read_phy_reg(shared, M88E1000_EXT_PHY_SPEC_CTRL);
+    phy_1000t_stat_reg = e1000_read_phy_reg(shared, PHY_1000T_STATUS);
+
+    phy_status_info->cable_length =
+        ((phy_specific_status_reg & M88E1000_PSSR_CABLE_LENGTH) >>
+         M88E1000_PSSR_CABLE_LENGTH_SHIFT);
+
+    phy_status_info->extended_10bt_distance =
+        (phy_specific_ctrl_reg & M88E1000_PSCR_10BT_EXT_DIST_ENABLE) >>
+        M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT;
+
+    phy_status_info->cable_polarity =
+        (phy_specific_status_reg & M88E1000_PSSR_REV_POLARITY) >>
+        M88E1000_PSSR_REV_POLARITY_SHIFT;
+
+    phy_status_info->polarity_correction =
+        (phy_specific_ctrl_reg & M88E1000_PSCR_POLARITY_REVERSAL) >>
+        M88E1000_PSCR_POLARITY_REVERSAL_SHIFT;
+
+    phy_status_info->link_reset =
+        (phy_specific_ext_ctrl_reg & M88E1000_EPSCR_DOWN_NO_IDLE) >>
+        M88E1000_EPSCR_DOWN_NO_IDLE_SHIFT;
+
+    phy_status_info->mdix_mode =
+        (phy_specific_status_reg & M88E1000_PSSR_MDIX) >>
+        M88E1000_PSSR_MDIX_SHIFT;
+
+    phy_status_info->local_rx =
+        (phy_1000t_stat_reg & SR_1000T_LOCAL_RX_STATUS) >>
+        SR_1000T_LOCAL_RX_STATUS_SHIFT;
+
+    phy_status_info->remote_rx =
+        (phy_1000t_stat_reg & SR_1000T_REMOTE_RX_STATUS) >>
+        SR_1000T_REMOTE_RX_STATUS_SHIFT;
+
+    return TRUE;
+}
+
+boolean_t
+e1000_validate_mdi_setting(struct e1000_shared_adapter *shared)
+{
+    if(!shared->autoneg && (shared->mdix == 0 || shared->mdix == 3)) {
+        shared->mdix = 1;
+        return FALSE;
+    }
+    return TRUE;
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_phy.h linux/drivers/net/e1000/e1000_phy.h
--- ../ia64/linux/drivers/net/e1000/e1000_phy.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_phy.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,424 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* e1000_phy.h
+ * Structures, enums, and macros for the PHY
+ */
+
+#ifndef _E1000_PHY_H_
+#define _E1000_PHY_H_
+
+#include "e1000_osdep.h"
+
+/* PHY status info structure and supporting enums */
+typedef enum {
+    e1000_cable_length_50 = 0,
+    e1000_cable_length_50_80,
+    e1000_cable_length_80_110,
+    e1000_cable_length_110_140,
+    e1000_cable_length_140,
+    e1000_cable_length_undefined = 0xFF
+} e1000_cable_length;
+
+typedef enum {
+    e1000_10bt_ext_dist_enable_normal = 0,
+    e1000_10bt_ext_dist_enable_lower,
+    e1000_10bt_ext_dist_enable_undefined = 0xFF
+} e1000_10bt_ext_dist_enable;
+
+typedef enum {
+    e1000_rev_polarity_normal = 0,
+    e1000_rev_polarity_reversed,
+    e1000_rev_polarity_undefined = 0xFF
+} e1000_rev_polarity;
+
+typedef enum {
+    e1000_polarity_reversal_enabled = 0,
+    e1000_polarity_reversal_disabled,
+    e1000_polarity_reversal_undefined = 0xFF
+} e1000_polarity_reversal;
+
+typedef enum {
+    e1000_down_no_idle_no_detect = 0,
+    e1000_down_no_idle_detect,
+    e1000_down_no_idle_undefined = 0xFF
+} e1000_down_no_idle;
+
+typedef enum {
+    e1000_auto_x_mode_manual_mdi = 0,
+    e1000_auto_x_mode_manual_mdix,
+    e1000_auto_x_mode_auto1,
+    e1000_auto_x_mode_auto2,
+    e1000_auto_x_mode_undefined = 0xFF
+} e1000_auto_x_mode;
+
+typedef enum {
+    e1000_1000t_rx_status_not_ok = 0,
+    e1000_1000t_rx_status_ok,
+    e1000_1000t_rx_status_undefined = 0xFF
+} e1000_1000t_rx_status;
+
+struct e1000_phy_info {
+    e1000_cable_length cable_length;
+    e1000_10bt_ext_dist_enable extended_10bt_distance;
+    e1000_rev_polarity cable_polarity;
+    e1000_polarity_reversal polarity_correction;
+    e1000_down_no_idle link_reset;
+    e1000_auto_x_mode mdix_mode;
+    e1000_1000t_rx_status local_rx;
+    e1000_1000t_rx_status remote_rx;
+};
+
+struct e1000_phy_stats {
+    uint32_t idle_errors;
+    uint32_t receive_errors;
+};
+
+/* Function Prototypes */
+uint16_t e1000_read_phy_reg(struct e1000_shared_adapter *shared, uint32_t reg_addr);
+void e1000_write_phy_reg(struct e1000_shared_adapter *shared, uint32_t reg_addr, uint16_t data);
+void e1000_phy_hw_reset(struct e1000_shared_adapter *shared);
+boolean_t e1000_phy_reset(struct e1000_shared_adapter *shared);
+boolean_t e1000_phy_setup(struct e1000_shared_adapter *shared, uint32_t ctrl_reg);
+boolean_t e1000_phy_setup_autoneg(struct e1000_shared_adapter *shared);
+void e1000_config_mac_to_phy(struct e1000_shared_adapter *shared, uint16_t mii_reg);
+void e1000_config_collision_dist(struct e1000_shared_adapter *shared);
+void e1000_display_mii(struct e1000_shared_adapter *shared);
+boolean_t e1000_detect_gig_phy(struct e1000_shared_adapter *shared);
+void e1000_phy_reset_dsp(struct e1000_shared_adapter *shared);
+boolean_t e1000_wait_autoneg(struct e1000_shared_adapter *shared);
+boolean_t e1000_phy_get_info(struct e1000_shared_adapter *shared, struct e1000_phy_info *phy_status_info);
+boolean_t e1000_validate_mdi_setting(struct e1000_shared_adapter *shared);
+
+/* Bit definitions for the Management Data IO (MDIO) and Management Data
+ * Clock (MDC) pins in the Device Control Register.
+ */
+#define E1000_CTRL_PHY_RESET_DIR  E1000_CTRL_SWDPIO0
+#define E1000_CTRL_PHY_RESET      E1000_CTRL_SWDPIN0
+#define E1000_CTRL_MDIO_DIR       E1000_CTRL_SWDPIO2
+#define E1000_CTRL_MDIO           E1000_CTRL_SWDPIN2
+#define E1000_CTRL_MDC_DIR        E1000_CTRL_SWDPIO3
+#define E1000_CTRL_MDC            E1000_CTRL_SWDPIN3
+#define E1000_CTRL_PHY_RESET_DIR4 E1000_CTRL_EXT_SDP4_DIR
+#define E1000_CTRL_PHY_RESET4     E1000_CTRL_EXT_SDP4_DATA
+
+/* PHY 1000 MII Register/Bit Definitions */
+/* PHY Registers defined by IEEE */
+#define PHY_CTRL         0x00 /* Control Register */
+#define PHY_STATUS       0x01 /* Status Regiser */
+#define PHY_ID1          0x02 /* Phy Id Reg (word 1) */
+#define PHY_ID2          0x03 /* Phy Id Reg (word 2) */
+#define PHY_AUTONEG_ADV  0x04 /* Autoneg Advertisement */
+#define PHY_LP_ABILITY   0x05 /* Link Partner Ability (Base Page) */
+#define PHY_AUTONEG_EXP  0x06 /* Autoneg Expansion Reg */
+#define PHY_NEXT_PAGE_TX 0x07 /* Next Page TX */
+#define PHY_LP_NEXT_PAGE 0x08 /* Link Partner Next Page */
+#define PHY_1000T_CTRL   0x09 /* 1000Base-T Control Reg */
+#define PHY_1000T_STATUS 0x0A /* 1000Base-T Status Reg */
+#define PHY_EXT_STATUS   0x0F /* Extended Status Reg */
+
+/* M88E1000 Specific Registers */
+#define M88E1000_PHY_SPEC_CTRL     0x10  /* PHY Specific Control Register */
+#define M88E1000_PHY_SPEC_STATUS   0x11  /* PHY Specific Status Register */
+#define M88E1000_INT_ENABLE        0x12  /* Interrupt Enable Register */
+#define M88E1000_INT_STATUS        0x13  /* Interrupt Status Register */
+#define M88E1000_EXT_PHY_SPEC_CTRL 0x14  /* Extended PHY Specific Control */
+#define M88E1000_RX_ERR_CNTR       0x15  /* Receive Error Counter */
+
+#define MAX_PHY_REG_ADDRESS 0x1F        /* 5 bit address bus (0-0x1F) */
+
+/* PHY Control Register */
+#define MII_CR_SPEED_SELECT_MSB 0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_COLL_TEST_ENABLE 0x0080  /* Collision test enable */
+#define MII_CR_FULL_DUPLEX      0x0100  /* FDX =1, half duplex =0 */
+#define MII_CR_RESTART_AUTO_NEG 0x0200  /* Restart auto negotiation */
+#define MII_CR_ISOLATE          0x0400  /* Isolate PHY from MII */
+#define MII_CR_POWER_DOWN       0x0800  /* Power down */
+#define MII_CR_AUTO_NEG_EN      0x1000  /* Auto Neg Enable */
+#define MII_CR_SPEED_SELECT_LSB 0x2000  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_LOOPBACK         0x4000  /* 0 = normal, 1 = loopback */
+#define MII_CR_RESET            0x8000  /* 0 = normal, 1 = PHY reset */
+
+/* PHY Status Register */
+#define MII_SR_EXTENDED_CAPS     0x0001 /* Extended register capabilities */
+#define MII_SR_JABBER_DETECT     0x0002 /* Jabber Detected */
+#define MII_SR_LINK_STATUS       0x0004 /* Link Status 1 = link */
+#define MII_SR_AUTONEG_CAPS      0x0008 /* Auto Neg Capable */
+#define MII_SR_REMOTE_FAULT      0x0010 /* Remote Fault Detect */
+#define MII_SR_AUTONEG_COMPLETE  0x0020 /* Auto Neg Complete */
+#define MII_SR_PREAMBLE_SUPPRESS 0x0040 /* Preamble may be suppressed */
+#define MII_SR_EXTENDED_STATUS   0x0100 /* Ext. status info in Reg 0x0F */
+#define MII_SR_100T2_HD_CAPS     0x0200 /* 100T2 Half Duplex Capable */
+#define MII_SR_100T2_FD_CAPS     0x0400 /* 100T2 Full Duplex Capable */
+#define MII_SR_10T_HD_CAPS       0x0800 /* 10T   Half Duplex Capable */
+#define MII_SR_10T_FD_CAPS       0x1000 /* 10T   Full Duplex Capable */
+#define MII_SR_100X_HD_CAPS      0x2000 /* 100X  Half Duplex Capable */
+#define MII_SR_100X_FD_CAPS      0x4000 /* 100X  Full Duplex Capable */
+#define MII_SR_100T4_CAPS        0x8000 /* 100T4 Capable */
+
+/* Autoneg Advertisement Register */
+#define NWAY_AR_SELECTOR_FIELD 0x0001   /* indicates IEEE 802.3 CSMA/CD */
+#define NWAY_AR_10T_HD_CAPS    0x0020   /* 10T   Half Duplex Capable */
+#define NWAY_AR_10T_FD_CAPS    0x0040   /* 10T   Full Duplex Capable */
+#define NWAY_AR_100TX_HD_CAPS  0x0080   /* 100TX Half Duplex Capable */
+#define NWAY_AR_100TX_FD_CAPS  0x0100   /* 100TX Full Duplex Capable */
+#define NWAY_AR_100T4_CAPS     0x0200   /* 100T4 Capable */
+#define NWAY_AR_PAUSE          0x0400   /* Pause operation desired */
+#define NWAY_AR_ASM_DIR        0x0800   /* Asymmetric Pause Direction bit */
+#define NWAY_AR_REMOTE_FAULT   0x2000   /* Remote Fault detected */
+#define NWAY_AR_NEXT_PAGE      0x8000   /* Next Page ability supported */
+
+/* Link Partner Ability Register (Base Page) */
+#define NWAY_LPAR_SELECTOR_FIELD 0x0000 /* LP protocol selector field */
+#define NWAY_LPAR_10T_HD_CAPS    0x0020 /* LP is 10T   Half Duplex Capable */
+#define NWAY_LPAR_10T_FD_CAPS    0x0040 /* LP is 10T   Full Duplex Capable */
+#define NWAY_LPAR_100TX_HD_CAPS  0x0080 /* LP is 100TX Half Duplex Capable */
+#define NWAY_LPAR_100TX_FD_CAPS  0x0100 /* LP is 100TX Full Duplex Capable */
+#define NWAY_LPAR_100T4_CAPS     0x0200 /* LP is 100T4 Capable */
+#define NWAY_LPAR_PAUSE          0x0400 /* LP Pause operation desired */
+#define NWAY_LPAR_ASM_DIR        0x0800 /* LP Asymmetric Pause Direction bit */
+#define NWAY_LPAR_REMOTE_FAULT   0x2000 /* LP has detected Remote Fault */
+#define NWAY_LPAR_ACKNOWLEDGE    0x4000 /* LP has rx'd link code word */
+#define NWAY_LPAR_NEXT_PAGE      0x8000 /* Next Page ability supported */
+
+/* Autoneg Expansion Register */
+#define NWAY_ER_LP_NWAY_CAPS      0x0001 /* LP has Auto Neg Capability */
+#define NWAY_ER_PAGE_RXD          0x0002 /* LP is 10T   Half Duplex Capable */
+#define NWAY_ER_NEXT_PAGE_CAPS    0x0004 /* LP is 10T   Full Duplex Capable */
+#define NWAY_ER_LP_NEXT_PAGE_CAPS 0x0008 /* LP is 100TX Half Duplex Capable */
+#define NWAY_ER_PAR_DETECT_FAULT  0x0100 /* LP is 100TX Full Duplex Capable */
+
+/* Next Page TX Register */
+#define NPTX_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define NPTX_TOGGLE         0x0800 /* Toggles between exchanges
+                                    * of different NP
+                                    */
+#define NPTX_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg
+                                    * 0 = cannot comply with msg
+                                    */
+#define NPTX_MSG_PAGE       0x2000 /* formatted(1)/unformatted(0) pg */
+#define NPTX_NEXT_PAGE      0x8000 /* 1 = addition NP will follow 
+                                    * 0 = sending last NP
+                                    */
+
+/* Link Partner Next Page Register */
+#define LP_RNPR_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define LP_RNPR_TOGGLE         0x0800 /* Toggles between exchanges
+                                       * of different NP
+                                       */
+#define LP_RNPR_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg 
+                                       * 0 = cannot comply with msg
+                                       */
+#define LP_RNPR_MSG_PAGE       0x2000  /* formatted(1)/unformatted(0) pg */
+#define LP_RNPR_ACKNOWLDGE     0x4000  /* 1 = ACK / 0 = NO ACK */
+#define LP_RNPR_NEXT_PAGE      0x8000  /* 1 = addition NP will follow
+                                        * 0 = sending last NP 
+                                        */
+
+/* 1000BASE-T Control Register */
+#define CR_1000T_ASYM_PAUSE      0x0080 /* Advertise asymmetric pause bit */
+#define CR_1000T_HD_CAPS         0x0100 /* Advertise 1000T HD capability */
+#define CR_1000T_FD_CAPS         0x0200 /* Advertise 1000T FD capability  */
+#define CR_1000T_REPEATER_DTE    0x0400 /* 1=Repeater/switch device port */
+                                        /* 0=DTE device */
+#define CR_1000T_MS_VALUE        0x0800 /* 1=Configure PHY as Master */
+                                        /* 0=Configure PHY as Slave */
+#define CR_1000T_MS_ENABLE       0x1000 /* 1=Master/Slave manual config value */
+                                        /* 0=Automatic Master/Slave config */
+#define CR_1000T_TEST_MODE_NORMAL 0x0000 /* Normal Operation */
+#define CR_1000T_TEST_MODE_1     0x2000 /* Transmit Waveform test */
+#define CR_1000T_TEST_MODE_2     0x4000 /* Master Transmit Jitter test */
+#define CR_1000T_TEST_MODE_3     0x6000 /* Slave Transmit Jitter test */
+#define CR_1000T_TEST_MODE_4     0x8000 /* Transmitter Distortion test */
+
+/* 1000BASE-T Status Register */
+#define SR_1000T_IDLE_ERROR_CNT   0x00FF /* Num idle errors since last read */
+#define SR_1000T_ASYM_PAUSE_DIR   0x0100 /* LP asymmetric pause direction bit */
+#define SR_1000T_LP_HD_CAPS       0x0400 /* LP is 1000T HD capable */
+#define SR_1000T_LP_FD_CAPS       0x0800 /* LP is 1000T FD capable */
+#define SR_1000T_REMOTE_RX_STATUS 0x1000 /* Remote receiver OK */
+#define SR_1000T_LOCAL_RX_STATUS  0x2000 /* Local receiver OK */
+#define SR_1000T_MS_CONFIG_RES    0x4000 /* 1=Local TX is Master, 0=Slave */
+#define SR_1000T_MS_CONFIG_FAULT  0x8000 /* Master/Slave config fault */
+#define SR_1000T_REMOTE_RX_STATUS_SHIFT 12
+#define SR_1000T_LOCAL_RX_STATUS_SHIFT  13
+
+/* Extended Status Register */
+#define IEEE_ESR_1000T_HD_CAPS 0x1000 /* 1000T HD capable */
+#define IEEE_ESR_1000T_FD_CAPS 0x2000 /* 1000T FD capable */
+#define IEEE_ESR_1000X_HD_CAPS 0x4000 /* 1000X HD capable */
+#define IEEE_ESR_1000X_FD_CAPS 0x8000 /* 1000X FD capable */
+
+#define PHY_TX_POLARITY_MASK   0x0100 /* register 10h bit 8 (polarity bit) */
+#define PHY_TX_NORMAL_POLARITY 0      /* register 10h bit 8 (normal polarity) */
+
+#define AUTO_POLARITY_DISABLE  0x0010 /* register 11h bit 4 */
+                                      /* (0=enable, 1=disable) */
+
+/* M88E1000 PHY Specific Control Register */
+#define M88E1000_PSCR_JABBER_DISABLE    0x0001 /* 1=Jabber Function disabled */
+#define M88E1000_PSCR_POLARITY_REVERSAL 0x0002 /* 1=Polarity Reversal enabled */
+#define M88E1000_PSCR_SQE_TEST          0x0004 /* 1=SQE Test enabled */
+#define M88E1000_PSCR_CLK125_DISABLE    0x0010 /* 1=CLK125 low, 
+                                                * 0=CLK125 toggling
+                                                */
+#define M88E1000_PSCR_MDI_MANUAL_MODE  0x0000  /* MDI Crossover Mode bits 6:5 */
+                                               /* Manual MDI configuration */
+#define M88E1000_PSCR_MDIX_MANUAL_MODE 0x0020  /* Manual MDIX configuration */
+#define M88E1000_PSCR_AUTO_X_1000T     0x0040  /* 1000BASE-T: Auto crossover,
+                                                *  100BASE-TX/10BASE-T: 
+                                                *  MDI Mode
+                                                */
+#define M88E1000_PSCR_AUTO_X_MODE      0x0060  /* Auto crossover enabled 
+                                                * all speeds. 
+                                                */
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE 0x0080 
+                                        /* 1=Enable Extended 10BASE-T distance
+                                         * (Lower 10BASE-T RX Threshold)
+                                         * 0=Normal 10BASE-T RX Threshold */
+#define M88E1000_PSCR_MII_5BIT_ENABLE      0x0100
+                                        /* 1=5-Bit interface in 100BASE-TX
+                                         * 0=MII interface in 100BASE-TX */
+#define M88E1000_PSCR_SCRAMBLER_DISABLE    0x0200 /* 1=Scrambler disable */
+#define M88E1000_PSCR_FORCE_LINK_GOOD      0x0400 /* 1=Force link good */
+#define M88E1000_PSCR_ASSERT_CRS_ON_TX     0x0800 /* 1=Assert CRS on Transmit */
+
+#define M88E1000_PSCR_POLARITY_REVERSAL_SHIFT    1
+#define M88E1000_PSCR_AUTO_X_MODE_SHIFT          5
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT 7
+
+/* M88E1000 PHY Specific Status Register */
+#define M88E1000_PSSR_JABBER             0x0001 /* 1=Jabber */
+#define M88E1000_PSSR_REV_POLARITY       0x0002 /* 1=Polarity reversed */
+#define M88E1000_PSSR_MDIX               0x0040 /* 1=MDIX; 0=MDI */
+#define M88E1000_PSSR_CABLE_LENGTH       0x0380 /* 0=<50M;1=50-80M;2=80-110M;
+                                            * 3=110-140M;4=>140M */
+#define M88E1000_PSSR_LINK               0x0400 /* 1=Link up, 0=Link down */
+#define M88E1000_PSSR_SPD_DPLX_RESOLVED  0x0800 /* 1=Speed & Duplex resolved */
+#define M88E1000_PSSR_PAGE_RCVD          0x1000 /* 1=Page received */
+#define M88E1000_PSSR_DPLX               0x2000 /* 1=Duplex 0=Half Duplex */
+#define M88E1000_PSSR_SPEED              0xC000 /* Speed, bits 14:15 */
+#define M88E1000_PSSR_10MBS              0x0000 /* 00=10Mbs */
+#define M88E1000_PSSR_100MBS             0x4000 /* 01=100Mbs */
+#define M88E1000_PSSR_1000MBS            0x8000 /* 10=1000Mbs */
+
+#define M88E1000_PSSR_REV_POLARITY_SHIFT 1
+#define M88E1000_PSSR_MDIX_SHIFT         6
+#define M88E1000_PSSR_CABLE_LENGTH_SHIFT 7
+
+/* M88E1000 Extended PHY Specific Control Register */
+#define M88E1000_EPSCR_FIBER_LOOPBACK 0x4000 /* 1=Fiber loopback */
+#define M88E1000_EPSCR_DOWN_NO_IDLE   0x8000 /* 1=Lost lock detect enabled.
+                                              * Will assert lost lock and bring
+                                              * link down if idle not seen
+                                              * within 1ms in 1000BASE-T 
+                                              */
+#define M88E1000_EPSCR_TX_CLK_2_5     0x0060 /* 2.5 MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_25      0x0070 /* 25  MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_0       0x0000 /* NO  TX_CLK */
+
+#define M88E1000_EPSCR_DOWN_NO_IDLE_SHIFT 15
+
+/* Bit definitions for valid PHY IDs. */
+#define M88E1000_12_PHY_ID 0x01410C50
+#define M88E1000_14_PHY_ID 0x01410C40
+#define M88E1000_I_PHY_ID  0x01410C30
+#define M88E1011_I_PHY_ID  0x01410C20
+
+/* Miscellaneous PHY bit definitions. */
+#define PHY_PREAMBLE        0xFFFFFFFF
+#define PHY_SOF             0x01
+#define PHY_OP_READ         0x02
+#define PHY_OP_WRITE        0x01
+#define PHY_TURNAROUND      0x02
+#define PHY_PREAMBLE_SIZE   32
+#define MII_CR_SPEED_1000   0x0040
+#define MII_CR_SPEED_100    0x2000
+#define MII_CR_SPEED_10     0x0000
+#define E1000_PHY_ADDRESS   0x01
+#define PHY_AUTO_NEG_TIME   45  /* 4.5 Seconds */
+#define PHY_FORCE_TIME      20  /* 2.0 Seconds */
+#define PHY_REVISION_MASK   0xFFFFFFF0
+#define DEVICE_SPEED_MASK   0x00000300  /* Device Ctrl Reg Speed Mask */
+#define REG4_SPEED_MASK     0x01E0
+#define REG9_SPEED_MASK     0x0300
+#define ADVERTISE_10_HALF   0x0001
+#define ADVERTISE_10_FULL   0x0002
+#define ADVERTISE_100_HALF  0x0004
+#define ADVERTISE_100_FULL  0x0008
+#define ADVERTISE_1000_HALF 0x0010
+#define ADVERTISE_1000_FULL 0x0020
+#define AUTONEG_ADVERTISE_SPEED_DEFAULT 0x002F  /* Everything but 1000-Half */
+
+#endif /* _E1000_PHY_H_ */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_proc.c linux/drivers/net/e1000/e1000_proc.c
--- ../ia64/linux/drivers/net/e1000/e1000_proc.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_proc.c	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,1437 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/***************************************************************************/
+/*       /proc File System Interaface Support Functions                    */
+/***************************************************************************/
+
+#include "e1000.h"
+extern char e1000_driver_name[];
+extern char e1000_driver_version[];
+#include "e1000_proc.h"
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry *e1000_proc_dir;
+
+#define CABLE_LENGTH_TO_STRING() \
+   msg = \
+   (adapter->phy_info.cable_length == e1000_cable_length_50)      ? "0-50 Meters (+/- 20 Meters)"  : \
+   (adapter->phy_info.cable_length == e1000_cable_length_50_80)   ? "50-80 Meters (+/- 20 Meters)"  : \
+   (adapter->phy_info.cable_length == e1000_cable_length_80_110)  ? "80-110 Meters (+/- 20 Meters)" : \
+   (adapter->phy_info.cable_length == e1000_cable_length_110_140) ? "110-140 Meters (+/- 20 Meters)" : \
+   (adapter->phy_info.cable_length == e1000_cable_length_140)     ? "> 140 Meters (+/- 20 Meters)" : \
+   "Unknown";
+
+#define EXTENDED_10BASE_T_DISTANCE_TO_STRING() \
+    msg = \
+    (adapter->phy_info.extended_10bt_distance == \
+            e1000_10bt_ext_dist_enable_normal) ? "Disabled" : \
+    (adapter->phy_info.extended_10bt_distance == \
+                    e1000_10bt_ext_dist_enable_lower) ? "Enabled" : "Unknown"; 
+
+#define CABLE_POLARITY_TO_STRING() \
+    msg = \
+    (adapter->phy_info.cable_polarity == e1000_rev_polarity_normal) ? "Normal" : \
+    (adapter->phy_info.cable_polarity == e1000_rev_polarity_reversed) ? \
+                                        "Reversed" : "Unknown";
+
+#define POLARITY_CORRECTION_TO_STRING() \
+    msg = \
+    (adapter->phy_info.polarity_correction == \
+                    e1000_polarity_reversal_enabled) ? "Disabled" : \
+    (adapter->phy_info.polarity_correction == \
+                    e1000_polarity_reversal_disabled) ? "Enabled" : "Undefined";
+
+#define LINK_RESET_TO_STRING() \
+    msg = \
+    (adapter->phy_info.link_reset == e1000_down_no_idle_no_detect) ? "Disabled" : \
+    (adapter->phy_info.link_reset == e1000_down_no_idle_detect) ? "Enabled" : \
+    "Unknown"; 
+
+#define MDI_X_MODE_TO_STRING() \
+    msg = (adapter->phy_info.mdix_mode == 0) ? "MDI" :  "MDI-X";
+
+#define LOCAL_RECEIVER_STATUS_TO_STRING() \
+    msg = \
+    (adapter->phy_info.local_rx == e1000_1000t_rx_status_not_ok) ? "NOT_OK" : \
+    (adapter->phy_info.local_rx == e1000_1000t_rx_status_ok) ? "OK" : \
+    "Unknown";
+
+#define REMOTE_RECEIVER_STATUS_TO_STRING() \
+    msg = \
+    (adapter->phy_info.remote_rx == e1000_1000t_rx_status_not_ok) ? "NOT_OK" : \
+    (adapter->phy_info.remote_rx == e1000_1000t_rx_status_ok) ? "OK" : \
+    "Unknown";
+
+static void e1000_link_update(struct e1000_adapter * adapter) {
+
+    e1000_check_for_link(&adapter->shared);
+    if(E1000_READ_REG(&adapter->shared, STATUS) & E1000_STATUS_LU)
+        adapter->link_active = 1;
+    else
+        adapter->link_active = 0;
+
+    if (adapter->link_active) {
+        e1000_get_speed_and_duplex(&adapter->shared, &adapter->link_speed, &adapter->link_duplex);
+    } else {
+        adapter->link_speed = 0;
+        adapter->link_duplex = 0;
+    }
+    return;
+}
+
+static int e1000_generic_read(char *page, char **start, off_t off,
+                              int count, int *eof)
+{
+    int len;
+
+    len = strlen(page);
+    page[len++] = '\n';
+
+    if (len <= off + count)
+        *eof = 1;
+    *start = page + off;
+    len -= off;
+    if (len > count)
+        len = count;
+    if (len < 0)
+        len = 0;
+    return len;
+}
+
+static int e1000_read_ulong(char *page, char **start, off_t off,
+               int count, int *eof, unsigned long l)
+{
+    sprintf(page, "%lu", l);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_ulong_hex(char *page, char **start, off_t off,
+                   int count, int *eof, unsigned long l)
+{
+    sprintf(page, "0x%04lx", l);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_ullong(char *page, char **start, off_t off,
+               int count, int *eof, unsigned long long l)
+{
+    sprintf(page, "%Lu", l);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_hwaddr(char *page, char **start, off_t off,
+                int count, int *eof, unsigned char *hwaddr)
+{
+    sprintf(page, "%02X:%02X:%02X:%02X:%02X:%02X",
+            hwaddr[0], hwaddr[1], hwaddr[2],
+            hwaddr[3], hwaddr[4], hwaddr[5]);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+/* need to check page boundaries !!! */
+static int e1000_read_info(char *page, char **start, off_t off,
+              int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    struct net_device_stats *stats = &adapter->net_stats;
+    unsigned char *hwaddr;
+    char *pagep = page;
+    char *msg;
+
+    page += sprintf(page, "%-32s %s\n", DESCRIPTION_TAG, adapter->id_string);
+    page += sprintf(page, "%-32s %06lx-%03x\n",
+                    PART_NUMBER_TAG, 
+                    (unsigned long )adapter->part_num >> 8, 
+                    adapter->part_num & 0x000000FF);
+
+    page += sprintf(page, "%-32s %s\n", DRVR_NAME_TAG, e1000_driver_name);
+
+    page += sprintf(page, "%-32s %s\n", DRVR_VERSION_TAG, e1000_driver_version);
+
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_VENDOR_TAG, (unsigned long) adapter->vendor_id);
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_DEVICE_ID_TAG, (unsigned long) adapter->device_id);
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_SUBSYSTEM_VENDOR_TAG,
+                    (unsigned long) adapter->subven_id);
+    page += sprintf(page, "%-32s 0x%04lx\n",
+                    PCI_SUBSYSTEM_ID_TAG,
+                    (unsigned long) adapter->subsys_id);
+    page += sprintf(page, "%-32s 0x%02lx\n",
+                    PCI_REVISION_ID_TAG,
+                    (unsigned long) adapter->rev_id);
+    
+    page += sprintf(page, "%-32s %lu\n",
+                    PCI_BUS_TAG,
+                    (unsigned long) (adapter->pdev->bus->number));
+    page += sprintf(page, "%-32s %lu\n",
+                    PCI_SLOT_TAG,
+                    (unsigned
+                     long) (PCI_SLOT((adapter->pdev->devfn))));
+       
+    if(adapter->shared.mac_type >= e1000_82543) {
+        page += sprintf(page, "%-32s %s\n",
+                PCI_BUS_TYPE_TAG,
+                (adapter->shared.bus_type == e1000_bus_type_pci)  ? "PCI"   :
+                (adapter->shared.bus_type == e1000_bus_type_pcix) ? "PCI-X" :
+                "UNKNOWN");
+    
+        page += sprintf(page, "%-32s %s\n",
+            PCI_BUS_SPEED_TAG,
+            (adapter->shared.bus_speed == e1000_bus_speed_33)  ? "33MHz"  :
+            (adapter->shared.bus_speed == e1000_bus_speed_66)  ? "66MHz"  :
+            (adapter->shared.bus_speed == e1000_bus_speed_100) ? "100MHz" :
+            (adapter->shared.bus_speed == e1000_bus_speed_133) ? "133MHz" :
+                "UNKNOWN");
+    
+        page += sprintf(page, "%-32s %s\n",
+                PCI_BUS_WIDTH_TAG,
+                (adapter->shared.bus_width == e1000_bus_width_32) ? "32-bit" :
+                (adapter->shared.bus_width == e1000_bus_width_64) ? "64-bit" :
+                "UNKNOWN");
+    }
+    
+    page +=
+        sprintf(page, "%-32s %lu\n", IRQ_TAG,
+                (unsigned long) (adapter->pdev->irq));
+    page +=
+        sprintf(page, "%-32s %s\n", SYSTEM_DEVICE_NAME_TAG,
+                adapter->netdev->name);
+
+    hwaddr = adapter->netdev->dev_addr;
+    page += sprintf(page, "%-32s %02X:%02X:%02X:%02X:%02X:%02X\n",
+                    CURRENT_HWADDR_TAG,
+                    hwaddr[0], hwaddr[1], hwaddr[2],
+                    hwaddr[3], hwaddr[4], hwaddr[5]);
+
+    hwaddr = adapter->perm_net_addr;
+    page += sprintf(page, "%-32s %02X:%02X:%02X:%02X:%02X:%02X\n",
+                    PERMANENT_HWADDR_TAG,
+                    hwaddr[0], hwaddr[1], hwaddr[2],
+                    hwaddr[3], hwaddr[4], hwaddr[5]);
+
+    page += sprintf(page, "\n");
+    
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    if (adapter->link_active == 1)
+        msg = "up";
+    else
+        msg = "down";
+    page += sprintf(page, "%-32s %s\n", LINK_TAG, msg);
+
+    if (adapter->link_speed)
+        page += sprintf(page, "%-32s %lu\n",
+                        SPEED_TAG,
+                        (unsigned long) (adapter->link_speed));
+    else
+        page += sprintf(page, "%-32s %s\n", SPEED_TAG, "N/A");
+
+    msg = adapter->link_duplex == FULL_DUPLEX ? "full" :
+        ((adapter->link_duplex == 0) ? "N/A" : "half");
+    page += sprintf(page, "%-32s %s\n", DUPLEX_TAG, msg);
+
+    if (adapter->netdev->flags & IFF_UP)
+        msg = "up";
+    else
+        msg = "down";
+    page += sprintf(page, "%-32s %s\n", STATE_TAG, msg);
+
+    page += sprintf(page, "\n");
+
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_PACKETS_TAG, (unsigned long) stats->rx_packets);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_PACKETS_TAG, (unsigned long) stats->tx_packets);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_BYTES_TAG, (unsigned long) stats->rx_bytes);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_BYTES_TAG, (unsigned long) stats->tx_bytes);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_ERRORS_TAG, (unsigned long) stats->rx_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_ERRORS_TAG, (unsigned long) stats->tx_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_DROPPED_TAG, (unsigned long) stats->rx_dropped);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_DROPPED_TAG, (unsigned long) stats->tx_dropped);
+    page += sprintf(page, "%-32s %lu\n",
+                    MULTICAST_TAG, (unsigned long) stats->multicast);
+    page += sprintf(page, "%-32s %lu\n",
+                    COLLISIONS_TAG, (unsigned long) stats->collisions);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_LENGTH_ERRORS_TAG,
+                    (unsigned long) stats->rx_length_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_OVER_ERRORS_TAG,
+                    (unsigned long) stats->rx_over_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_CRC_ERRORS_TAG,
+                    (unsigned long) stats->rx_crc_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_FRAME_ERRORS_TAG,
+                    (unsigned long) stats->rx_frame_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_FIFO_ERRORS_TAG,
+                    (unsigned long) stats->rx_fifo_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    RX_MISSED_ERRORS_TAG,
+                    (unsigned long) stats->rx_missed_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_ABORTED_ERRORS_TAG,
+                    (unsigned long) stats->tx_aborted_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_CARRIER_ERRORS_TAG,
+                    (unsigned long) stats->tx_carrier_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_FIFO_ERRORS_TAG,
+                    (unsigned long) stats->tx_fifo_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_HEARTBEAT_ERRORS_TAG,
+                    (unsigned long) stats->tx_heartbeat_errors);
+    page += sprintf(page, "%-32s %lu\n",
+                    TX_WINDOW_ERRORS_TAG,
+                    (unsigned long) stats->tx_window_errors);
+
+    page += sprintf(page, "\n");
+
+    /* 8254x specific stats */
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_LATE_COLL_TAG,
+                    (unsigned long long)adapter->stats.latecol);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_DEFERRED_TAG,
+                    (unsigned long long)adapter->stats.dc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_SINGLE_COLL_TAG,
+                    (unsigned long long)adapter->stats.scc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_MULTI_COLL_TAG,
+                    (unsigned long long)adapter->stats.mcc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_LONG_ERRORS_TAG,
+                    (unsigned long long)adapter->stats.roc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_SHORT_ERRORS_TAG,
+                    (unsigned long long)adapter->stats.ruc);
+    /* The 82542 does not have an alignment error count register */
+    /* ALGNERRC is only valid in MII mode at 10 or 100 Mbps */
+    if(adapter->shared.mac_type >= e1000_82543)
+        page += sprintf(page, "%-32s %Lu\n",
+                        RX_ALIGN_ERRORS_TAG,
+                        (unsigned long long)adapter->stats.algnerrc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_XON_TAG,
+                    (unsigned long long)adapter->stats.xonrxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_XOFF_TAG,
+                    (unsigned long long)adapter->stats.xoffrxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_XON_TAG,
+                    (unsigned long long)adapter->stats.xontxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    TX_XOFF_TAG,
+                    (unsigned long long)adapter->stats.xofftxc);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_CSUM_GOOD_TAG,
+                    (unsigned long long)adapter->XsumRXGood);
+    page += sprintf(page, "%-32s %Lu\n",
+                    RX_CSUM_ERROR_TAG,
+                    (unsigned long long)adapter->XsumRXError);
+
+    if (adapter->shared.media_type == e1000_media_type_copper)
+        msg = "Copper";
+    else
+        msg = "Fiber";
+    page += sprintf(page, "\n%-32s %s\n", MEDIA_TYPE_TAG, msg);
+    
+    if (adapter->shared.media_type == e1000_media_type_copper) {
+       CABLE_LENGTH_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", CABLE_LENGTH_TAG, msg);
+
+       EXTENDED_10BASE_T_DISTANCE_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", EXTENDED_10BASE_T_DISTANCE_TAG, msg);
+ 
+       CABLE_POLARITY_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", CABLE_POLARITY_TAG, msg);
+
+       POLARITY_CORRECTION_TO_STRING();
+       page += sprintf(page, "%-32s %s\n",  CABLE_POLARITY_CORRECTION_TAG, msg);
+
+       page += sprintf(page, "%-32s %lu\n", IDLE_ERRORS_TAG, (unsigned long)adapter->phy_stats.idle_errors );
+
+       LINK_RESET_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", LINK_RESET_ENABLED_TAG, msg);
+
+       page += sprintf(page, "%-32s %lu\n", RECEIVE_ERRORS_TAG, (unsigned long)adapter->phy_stats.receive_errors);
+
+       MDI_X_MODE_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", MDI_X_ENABLED_TAG, msg);
+
+       LOCAL_RECEIVER_STATUS_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", LOCAL_RECEIVER_STATUS_TAG, msg);
+
+       REMOTE_RECEIVER_STATUS_TO_STRING();
+       page += sprintf(page, "%-32s %s\n", REMOTE_RECEIVER_STATUS_TAG, msg);
+    }
+
+    *page = 0;
+    return e1000_generic_read(pagep, start, off, count, eof);
+}
+
+static int e1000_read_descr(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    
+    strncpy(page, adapter->id_string, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_partnum(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    sprintf(page, "%06lx-%03x",
+            (unsigned long)adapter->part_num >> 8,
+            adapter->part_num & 0x000000FF);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_drvr_name(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    strncpy(page, e1000_driver_name, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_drvr_ver(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    strncpy(page, e1000_driver_version, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_vendor(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->vendor_id);
+}
+
+static int e1000_read_pci_device(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->device_id);
+}
+
+static int e1000_read_pci_sub_vendor(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->subven_id);
+}
+
+static int e1000_read_pci_sub_device(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->subsys_id);
+}
+
+static int e1000_read_pci_revision(char *page, char **start, off_t off,
+                      int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong_hex(page, start, off, count, eof,
+                          (unsigned long) adapter->rev_id);
+}
+
+static int e1000_read_dev_name(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page, adapter->netdev->name, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_bus(char *page, char **start, off_t off,
+                 int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) (adapter->pdev->bus->number));
+}
+
+static int e1000_read_pci_slot(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned
+                       long) (PCI_SLOT((adapter->pdev->devfn))));
+}
+
+static int e1000_read_pci_bus_type(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page,
+        (adapter->shared.bus_type == e1000_bus_type_pci)  ? "PCI"   :
+        (adapter->shared.bus_type == e1000_bus_type_pcix) ? "PCI-X" :
+        "UNKNOWN", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_bus_speed(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page, 
+        (adapter->shared.bus_speed == e1000_bus_speed_33)  ? "33MHz"  :
+        (adapter->shared.bus_speed == e1000_bus_speed_66)  ? "66MHz"  :
+        (adapter->shared.bus_speed == e1000_bus_speed_100) ? "100MHz" :
+        (adapter->shared.bus_speed == e1000_bus_speed_133) ? "133MHz" :
+        "UNKNOWN", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_pci_bus_width(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    strncpy(page, 
+        (adapter->shared.bus_width == e1000_bus_width_32) ? "32-bit" :
+        (adapter->shared.bus_width == e1000_bus_width_64) ? "64-bit" :
+        "UNKNOWN", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_irq(char *page, char **start, off_t off,
+             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) (adapter->pdev->irq));
+}
+
+static int e1000_read_current_hwaddr(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    unsigned char *hwaddr = adapter->netdev->dev_addr;
+
+    return e1000_read_hwaddr(page, start, off, count, eof, hwaddr);
+}
+
+static int e1000_read_permanent_hwaddr(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    unsigned char *hwaddr = adapter->perm_net_addr;
+
+    return e1000_read_hwaddr(page, start, off, count, eof, hwaddr);
+}
+
+static int e1000_read_link_status(char *page, char **start, off_t off,
+                     int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    if (adapter->link_active == 1)
+        strncpy(page, "up", PAGE_SIZE);
+    else
+        strncpy(page, "down", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_speed(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    if (adapter->link_speed)
+        return e1000_read_ulong(page, start, off, count, eof,
+                          (unsigned long) (adapter->link_speed));
+    strncpy(page, "N/A", PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_dplx_mode(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    char *dplx_mode;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    dplx_mode = adapter->link_duplex == FULL_DUPLEX ? "full" :
+        ((adapter->link_duplex == 0) ? "N/A" : "half");
+    strncpy(page, dplx_mode, PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_state(char *page, char **start, off_t off,
+               int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    if (adapter->netdev->flags & IFF_UP)
+        strncpy(page, "up", PAGE_SIZE);
+    else
+        strncpy(page, "down", PAGE_SIZE);
+
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_rx_packets(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_packets);
+}
+
+static int e1000_read_tx_packets(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_packets);
+}
+
+static int e1000_read_rx_bytes(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_bytes);
+}
+
+static int e1000_read_tx_bytes(char *page, char **start, off_t off,
+                  int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_bytes);
+}
+
+static int e1000_read_rx_errors(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_errors);
+}
+
+static int e1000_read_tx_errors(char *page, char **start, off_t off,
+                   int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_errors);
+}
+
+static int e1000_read_rx_dropped(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_dropped);
+}
+
+static int e1000_read_tx_dropped(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_dropped);
+}
+
+static int e1000_read_rx_multicast_packets(char *page, char **start, off_t off,
+                              int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.multicast);
+}
+
+static int e1000_read_collisions(char *page, char **start, off_t off,
+                    int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.collisions);
+}
+
+static int e1000_read_rx_length_errors(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_length_errors);
+}
+
+static int e1000_read_rx_over_errors(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_over_errors);
+}
+
+static int e1000_read_rx_crc_errors(char *page, char **start, off_t off,
+                       int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_crc_errors);
+}
+
+static int e1000_read_rx_frame_errors(char *page, char **start, off_t off,
+                         int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_frame_errors);
+}
+
+static int e1000_read_rx_fifo_errors(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_fifo_errors);
+}
+
+static int e1000_read_rx_missed_errors(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.rx_missed_errors);
+}
+
+static int e1000_read_tx_aborted_errors(char *page, char **start, off_t off,
+                           int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_aborted_errors);
+}
+
+static int e1000_read_tx_carrier_errors(char *page, char **start, off_t off,
+                           int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_carrier_errors);
+}
+
+static int e1000_read_tx_fifo_errors(char *page, char **start, off_t off,
+                        int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_fifo_errors);
+}
+
+static int e1000_read_tx_heartbeat_errors(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_heartbeat_errors);
+}
+
+static int e1000_read_tx_window_errors(char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    return e1000_read_ulong(page, start, off, count, eof,
+                      (unsigned long) adapter->net_stats.tx_window_errors);
+}
+
+/* 8254x specific stats */
+static int e1000_read_tx_late_coll(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.latecol);
+}
+
+static int e1000_read_tx_defer_events(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.dc);
+}
+static int e1000_read_tx_single_coll(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.scc);
+}
+static int e1000_read_tx_multi_coll(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.mcc);
+}
+static int e1000_read_rx_oversize(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.roc);
+}
+static int e1000_read_rx_undersize(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.ruc);
+}
+static int e1000_read_rx_align_err(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.algnerrc);
+}
+static int e1000_read_rx_xon(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xonrxc);
+}
+static int e1000_read_rx_xoff(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xoffrxc);
+}
+static int e1000_read_tx_xon(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xontxc);
+}
+static int e1000_read_tx_xoff(char *page, char **start, off_t off,
+                             int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+    return e1000_read_ullong(page, start, off, count, eof, adapter->stats.xofftxc);
+}
+
+static struct proc_dir_entry *e1000_create_proc_read(char *name,
+    struct e1000_adapter * adapter,
+    struct proc_dir_entry *parent,
+    read_proc_t * read_proc)
+{
+    struct proc_dir_entry *pdep;
+
+    if (!(pdep = create_proc_entry(name, S_IFREG, parent)))
+        return NULL;
+    pdep->read_proc = read_proc;
+    pdep->data = adapter;
+    return pdep;
+}
+
+static int e1000_read_cable_length (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    CABLE_LENGTH_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_media_type (char *page, char **start,
+                   off_t off, int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    switch (adapter->shared.media_type) {
+        case e1000_media_type_copper: strncpy(page,"Copper", PAGE_SIZE); break;
+        case e1000_media_type_fiber: strncpy(page, "Fiber", PAGE_SIZE); break;
+        default: strncpy(page, "Unknown", PAGE_SIZE);    
+    }
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_extended_10base_t_distance (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    EXTENDED_10BASE_T_DISTANCE_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_cable_polarity (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    CABLE_POLARITY_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_cable_polarity_correction (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    POLARITY_CORRECTION_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_idle_errors (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    return e1000_read_ulong(page, start, off, count, eof, adapter->phy_stats.idle_errors);
+}
+
+static int e1000_read_link_reset_enabled (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    LINK_RESET_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_receive_errors (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    return e1000_read_ulong(page, start, off, count, eof, adapter->phy_stats.receive_errors);
+}
+
+static int e1000_read_mdi_x_enabled (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    MDI_X_MODE_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_local_receiver_status (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+
+    LOCAL_RECEIVER_STATUS_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+static int e1000_read_remote_receiver_status (char *page, char **start, 
+                off_t off, int count, int *eof, void *data)
+{
+    char *msg;
+    struct e1000_adapter * adapter = (struct e1000_adapter *) data;
+
+    /* If board is not open yet, */
+    if(!test_bit(E1000_BOARD_OPEN, &adapter->flags)) 
+        e1000_link_update(adapter);
+    
+    REMOTE_RECEIVER_STATUS_TO_STRING();
+    strncpy (page, msg, PAGE_SIZE);
+    return e1000_generic_read(page, start, off, count, eof);
+}
+
+int e1000_create_proc_dev(struct e1000_adapter * adapter)
+{
+    struct proc_dir_entry *dev_dir;
+    char info[256];
+    int len;
+
+    dev_dir = create_proc_entry(adapter->netdev->name, S_IFDIR, e1000_proc_dir);
+
+    strncpy(info, adapter->netdev->name, sizeof(info));
+    len = strlen(info);
+    strncat(info + len, ".info", sizeof(info) - len);
+
+    /* info */
+    if (!(e1000_create_proc_read(info, adapter, e1000_proc_dir, e1000_read_info)))
+        return -1;
+
+    /* description */
+    if (!(e1000_create_proc_read(DESCRIPTION_TAG, adapter, dev_dir, e1000_read_descr)))
+        return -1;
+    /* part number */
+    if (!(e1000_create_proc_read(PART_NUMBER_TAG, adapter, dev_dir, e1000_read_partnum)))
+        return -1;
+    /* driver name */
+    if (!(e1000_create_proc_read(DRVR_NAME_TAG, adapter, dev_dir, e1000_read_drvr_name)))
+        return -1;
+    /* driver version */
+    if (!(e1000_create_proc_read(DRVR_VERSION_TAG, adapter, dev_dir, e1000_read_drvr_ver)))
+        return -1;
+    /* pci vendor */
+    if (!(e1000_create_proc_read(PCI_VENDOR_TAG, adapter, dev_dir, e1000_read_pci_vendor)))
+        return -1;
+    /* pci device id */
+    if (!(e1000_create_proc_read(PCI_DEVICE_ID_TAG, adapter, dev_dir,
+                           e1000_read_pci_device))) return -1;
+    /* pci sub vendor */
+    if (!(e1000_create_proc_read(PCI_SUBSYSTEM_VENDOR_TAG, adapter, dev_dir,
+                           e1000_read_pci_sub_vendor))) return -1;
+    /* pci sub device id */
+    if (!(e1000_create_proc_read(PCI_SUBSYSTEM_ID_TAG, adapter, dev_dir,
+                           e1000_read_pci_sub_device))) return -1;
+    /* pci revision id */
+    if (!(e1000_create_proc_read(PCI_REVISION_ID_TAG, adapter, dev_dir,
+                           e1000_read_pci_revision))) return -1;
+    /* device name */
+    if (!(e1000_create_proc_read(SYSTEM_DEVICE_NAME_TAG, adapter, dev_dir,
+                           e1000_read_dev_name))) return -1;
+    /* pci bus */
+    if (!(e1000_create_proc_read(PCI_BUS_TAG, adapter, dev_dir, e1000_read_pci_bus)))
+        return -1;
+    /* pci slot */
+    if (!(e1000_create_proc_read(PCI_SLOT_TAG, adapter, dev_dir, e1000_read_pci_slot)))
+        return -1;
+    /* pci bus type */
+    if (!(e1000_create_proc_read(PCI_BUS_TYPE_TAG, adapter, dev_dir, 
+                               e1000_read_pci_bus_type))) return -1;
+    /* pci bus speed */
+    if (!(e1000_create_proc_read(PCI_BUS_SPEED_TAG, adapter, dev_dir, 
+                               e1000_read_pci_bus_speed))) return -1;
+    /* pci bus width */
+    if (!(e1000_create_proc_read(PCI_BUS_WIDTH_TAG, adapter, dev_dir, 
+                               e1000_read_pci_bus_width))) return -1;
+    /* irq */
+    if (!(e1000_create_proc_read(IRQ_TAG, adapter, dev_dir, e1000_read_irq)))
+        return -1;
+    /* current hwaddr */
+    if (!(e1000_create_proc_read(CURRENT_HWADDR_TAG, adapter, dev_dir,
+                           e1000_read_current_hwaddr))) return -1;
+    /* permanent hwaddr */
+    if (!(e1000_create_proc_read(PERMANENT_HWADDR_TAG, adapter, dev_dir,
+                           e1000_read_permanent_hwaddr))) return -1;
+
+    /* link status */
+    if (!(e1000_create_proc_read(LINK_TAG, adapter, dev_dir, e1000_read_link_status)))
+        return -1;
+    /* speed */
+    if (!(e1000_create_proc_read(SPEED_TAG, adapter, dev_dir, e1000_read_speed)))
+        return -1;
+    /* duplex mode */
+    if (!(e1000_create_proc_read(DUPLEX_TAG, adapter, dev_dir, e1000_read_dplx_mode)))
+        return -1;
+    /* state */
+    if (!(e1000_create_proc_read(STATE_TAG, adapter, dev_dir, e1000_read_state)))
+        return -1;
+    /* rx packets */
+    if (!(e1000_create_proc_read(RX_PACKETS_TAG, adapter, dev_dir, e1000_read_rx_packets)))
+        return -1;
+    /* tx packets */
+    if (!(e1000_create_proc_read(TX_PACKETS_TAG, adapter, dev_dir, e1000_read_tx_packets)))
+        return -1;
+    /* rx bytes */
+    if (!(e1000_create_proc_read(RX_BYTES_TAG, adapter, dev_dir, e1000_read_rx_bytes)))
+        return -1;
+    /* tx bytes */
+    if (!(e1000_create_proc_read(TX_BYTES_TAG, adapter, dev_dir, e1000_read_tx_bytes)))
+        return -1;
+    /* rx errors */
+    if (!(e1000_create_proc_read(RX_ERRORS_TAG, adapter, dev_dir, e1000_read_rx_errors)))
+        return -1;
+    /* tx errors */
+    if (!(e1000_create_proc_read(TX_ERRORS_TAG, adapter, dev_dir, e1000_read_tx_errors)))
+        return -1;
+    /* rx dropped */
+    if (!(e1000_create_proc_read(RX_DROPPED_TAG, adapter, dev_dir, e1000_read_rx_dropped)))
+        return -1;
+    /* tx dropped */
+    if (!(e1000_create_proc_read(TX_DROPPED_TAG, adapter, dev_dir, e1000_read_tx_dropped)))
+        return -1;
+    /* multicast packets */
+    if (!(e1000_create_proc_read(MULTICAST_TAG, adapter, dev_dir, 
+                                    e1000_read_rx_multicast_packets)))
+        return -1;
+
+    /* collisions */
+    if (!(e1000_create_proc_read (COLLISIONS_TAG, adapter, dev_dir, e1000_read_collisions))) 
+        return -1;
+             
+    /* rx length errors */
+    if (!(e1000_create_proc_read(RX_LENGTH_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_length_errors))) return -1;
+    /* rx over errors */
+    if (!(e1000_create_proc_read(RX_OVER_ERRORS_TAG, adapter, dev_dir,
+                               e1000_read_rx_over_errors))) return -1;
+    /* rx crc errors */
+    if (!(e1000_create_proc_read(RX_CRC_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_crc_errors))) return -1;
+    /* rx frame errors */
+    if (!(e1000_create_proc_read(RX_FRAME_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_frame_errors))) return -1;
+    /* rx fifo errors */
+    if (!(e1000_create_proc_read(RX_FIFO_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_fifo_errors))) return -1;
+    /* rx missed errors */
+    if (!(e1000_create_proc_read(RX_MISSED_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_missed_errors))) return -1;
+    /* tx aborted errors */
+    if (!(e1000_create_proc_read(TX_ABORTED_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_aborted_errors))) return -1;
+    /* tx carrier errors */
+    if (!(e1000_create_proc_read(TX_CARRIER_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_carrier_errors))) return -1;
+    /* tx fifo errors */
+    if (!(e1000_create_proc_read(TX_FIFO_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_fifo_errors))) return -1;
+    /* tx heartbeat errors */
+    if (!(e1000_create_proc_read(TX_HEARTBEAT_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_heartbeat_errors))) return -1;
+    /* tx window errors */
+    if (!(e1000_create_proc_read(TX_WINDOW_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_tx_window_errors))) return -1;
+
+    if (!(e1000_create_proc_read(TX_LATE_COLL_TAG, adapter, dev_dir,
+                           e1000_read_tx_late_coll))) return -1;
+    if (!(e1000_create_proc_read(TX_DEFERRED_TAG, adapter, dev_dir,
+                           e1000_read_tx_defer_events))) return -1;
+    if (!(e1000_create_proc_read(TX_SINGLE_COLL_TAG, adapter, dev_dir,
+                           e1000_read_tx_single_coll))) return -1;
+    if (!(e1000_create_proc_read(TX_MULTI_COLL_TAG, adapter, dev_dir,
+                           e1000_read_tx_multi_coll))) return -1;
+    if (!(e1000_create_proc_read(RX_LONG_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_oversize))) return -1;
+    if (!(e1000_create_proc_read(RX_SHORT_ERRORS_TAG, adapter, dev_dir,
+                           e1000_read_rx_undersize))) return -1;
+    if(adapter->shared.mac_type >= e1000_82543)
+        if (!(e1000_create_proc_read(RX_ALIGN_ERRORS_TAG, adapter, dev_dir,
+                               e1000_read_rx_align_err))) return -1;
+    if (!(e1000_create_proc_read(RX_XON_TAG, adapter, dev_dir,
+                           e1000_read_rx_xon))) return -1;
+    if (!(e1000_create_proc_read(RX_XOFF_TAG, adapter, dev_dir,
+                           e1000_read_rx_xoff))) return -1;
+    if (!(e1000_create_proc_read(TX_XON_TAG, adapter, dev_dir,
+                           e1000_read_tx_xon))) return -1;
+    if (!(e1000_create_proc_read(TX_XOFF_TAG, adapter, dev_dir,
+                           e1000_read_tx_xoff))) return -1;
+
+    if (!(e1000_create_proc_read(MEDIA_TYPE_TAG, adapter, dev_dir,
+                    e1000_read_media_type))) return -1;
+    
+    if (adapter->shared.media_type == e1000_media_type_copper) {
+       if (!(e1000_create_proc_read(CABLE_LENGTH_TAG, adapter, dev_dir,
+                    e1000_read_cable_length))) return -1;
+   
+       if (!(e1000_create_proc_read(EXTENDED_10BASE_T_DISTANCE_TAG, 
+                   adapter, dev_dir,
+                   e1000_read_extended_10base_t_distance))) return -1;
+        
+       if (!(e1000_create_proc_read(CABLE_POLARITY_TAG, adapter, dev_dir,
+                    e1000_read_cable_polarity))) return -1;
+   
+       if (!(e1000_create_proc_read(CABLE_POLARITY_CORRECTION_TAG, adapter, dev_dir,
+                   e1000_read_cable_polarity_correction))) return -1;
+   
+       if (!(e1000_create_proc_read(IDLE_ERRORS_TAG, adapter, dev_dir,
+                    e1000_read_idle_errors))) return -1;
+   
+       if (!(e1000_create_proc_read(LINK_RESET_ENABLED_TAG, adapter, dev_dir,
+                   e1000_read_link_reset_enabled))) return -1;
+   
+       if (!(e1000_create_proc_read(RECEIVE_ERRORS_TAG, adapter, dev_dir,
+                    e1000_read_receive_errors))) return -1;
+   
+       if (!(e1000_create_proc_read(MDI_X_ENABLED_TAG, adapter, dev_dir,
+                   e1000_read_mdi_x_enabled))) return -1;
+  
+       if (!(e1000_create_proc_read(LOCAL_RECEIVER_STATUS_TAG, adapter, dev_dir,
+                   e1000_read_local_receiver_status))) return -1;
+   
+       if (!(e1000_create_proc_read(REMOTE_RECEIVER_STATUS_TAG, adapter, dev_dir,
+                   e1000_read_remote_receiver_status))) return -1;
+    }
+    
+    return 0;
+}
+
+void e1000_remove_proc_dev(struct net_device *dev)
+{
+    struct proc_dir_entry *de;
+    struct e1000_adapter * adapter = dev->priv;
+    char info[256];
+    int len;
+
+    len = strlen(dev->name);
+    strncpy(info, dev->name, sizeof(info));
+    strncat(info + len, ".info", sizeof(info) - len);
+
+    for (de = e1000_proc_dir->subdir; de; de = de->next) {
+        if ((de->namelen == len) && (!memcmp(de->name, dev->name, len)))
+            break;
+    }
+    if (de) {
+        remove_proc_entry(DESCRIPTION_TAG, de);
+        remove_proc_entry(PART_NUMBER_TAG, de);
+        remove_proc_entry(DRVR_NAME_TAG, de);
+        remove_proc_entry(DRVR_VERSION_TAG, de);
+        remove_proc_entry(PCI_VENDOR_TAG, de);
+        remove_proc_entry(PCI_DEVICE_ID_TAG, de);
+        remove_proc_entry(PCI_SUBSYSTEM_VENDOR_TAG, de);
+        remove_proc_entry(PCI_SUBSYSTEM_ID_TAG, de);
+        remove_proc_entry(PCI_REVISION_ID_TAG, de);
+        remove_proc_entry(SYSTEM_DEVICE_NAME_TAG, de);
+        remove_proc_entry(PCI_BUS_TAG, de);
+        remove_proc_entry(PCI_SLOT_TAG, de);
+        remove_proc_entry(PCI_BUS_TYPE_TAG, de);
+        remove_proc_entry(PCI_BUS_SPEED_TAG, de);
+        remove_proc_entry(PCI_BUS_WIDTH_TAG, de);
+        remove_proc_entry(IRQ_TAG, de);
+        remove_proc_entry(CURRENT_HWADDR_TAG, de);
+        remove_proc_entry(PERMANENT_HWADDR_TAG, de);
+
+        remove_proc_entry(LINK_TAG, de);
+        remove_proc_entry(SPEED_TAG, de);
+        remove_proc_entry(DUPLEX_TAG, de);
+        remove_proc_entry(STATE_TAG, de);
+
+        remove_proc_entry(RX_PACKETS_TAG, de);
+        remove_proc_entry(TX_PACKETS_TAG, de);
+        remove_proc_entry(RX_BYTES_TAG, de);
+        remove_proc_entry(TX_BYTES_TAG, de);
+        remove_proc_entry(RX_ERRORS_TAG, de);
+        remove_proc_entry(TX_ERRORS_TAG, de);
+        remove_proc_entry(RX_DROPPED_TAG, de);
+        remove_proc_entry(TX_DROPPED_TAG, de);
+        remove_proc_entry(MULTICAST_TAG, de);
+        remove_proc_entry(COLLISIONS_TAG, de);
+        remove_proc_entry(RX_LENGTH_ERRORS_TAG, de);
+        remove_proc_entry(RX_OVER_ERRORS_TAG, de);
+        remove_proc_entry(RX_CRC_ERRORS_TAG, de);
+        remove_proc_entry(RX_FRAME_ERRORS_TAG, de);
+        remove_proc_entry(RX_FIFO_ERRORS_TAG, de);
+        remove_proc_entry(RX_MISSED_ERRORS_TAG, de);
+        remove_proc_entry(TX_ABORTED_ERRORS_TAG, de);
+        remove_proc_entry(TX_CARRIER_ERRORS_TAG, de);
+        remove_proc_entry(TX_FIFO_ERRORS_TAG, de);
+        remove_proc_entry(TX_HEARTBEAT_ERRORS_TAG, de);
+        remove_proc_entry(TX_WINDOW_ERRORS_TAG, de);
+        remove_proc_entry(TX_LATE_COLL_TAG, de);
+        remove_proc_entry(TX_DEFERRED_TAG, de);
+        remove_proc_entry(TX_SINGLE_COLL_TAG, de);
+        remove_proc_entry(TX_MULTI_COLL_TAG, de);
+        remove_proc_entry(RX_LONG_ERRORS_TAG, de);
+        remove_proc_entry(RX_SHORT_ERRORS_TAG, de);
+        remove_proc_entry(RX_XON_TAG, de);
+        remove_proc_entry(RX_XOFF_TAG, de);
+        remove_proc_entry(TX_XON_TAG, de);
+        remove_proc_entry(TX_XOFF_TAG, de);
+
+        remove_proc_entry(MEDIA_TYPE_TAG, de);
+        if (adapter->shared.media_type == e1000_media_type_copper) {
+           remove_proc_entry(CABLE_LENGTH_TAG, de);
+           remove_proc_entry(EXTENDED_10BASE_T_DISTANCE_TAG, de);
+           remove_proc_entry(CABLE_POLARITY_TAG, de);
+           remove_proc_entry(CABLE_POLARITY_CORRECTION_TAG, de);
+           remove_proc_entry(IDLE_ERRORS_TAG, de);
+           remove_proc_entry(LINK_RESET_ENABLED_TAG, de);
+           remove_proc_entry(RECEIVE_ERRORS_TAG, de);
+           remove_proc_entry(MDI_X_ENABLED_TAG, de);
+           remove_proc_entry(LOCAL_RECEIVER_STATUS_TAG, de);
+           remove_proc_entry(REMOTE_RECEIVER_STATUS_TAG, de);
+        }
+    }
+
+    remove_proc_entry(info, e1000_proc_dir);
+    remove_proc_entry(dev->name, e1000_proc_dir);
+}
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/e1000_proc.h linux/drivers/net/e1000/e1000_proc.h
--- ../ia64/linux/drivers/net/e1000/e1000_proc.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/e1000_proc.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,181 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* /proc definitions */
+#include <linux/proc_fs.h>
+
+#define ADAPTERS_PROC_DIR           "PRO_LAN_Adapters"
+
+#define DESCRIPTION_TAG             "Description"
+#define PART_NUMBER_TAG             "Part_Number"
+#define DRVR_NAME_TAG               "Driver_Name"
+#define DRVR_VERSION_TAG            "Driver_Version"
+#define PCI_VENDOR_TAG              "PCI_Vendor"
+#define PCI_DEVICE_ID_TAG           "PCI_Device_ID"
+#define PCI_SUBSYSTEM_VENDOR_TAG    "PCI_Subsystem_Vendor"
+#define PCI_SUBSYSTEM_ID_TAG        "PCI_Subsystem_ID"
+#define PCI_REVISION_ID_TAG         "PCI_Revision_ID"
+#define PCI_BUS_TAG                 "PCI_Bus"
+#define PCI_SLOT_TAG                "PCI_Slot"
+#define PCI_BUS_TYPE_TAG            "PCI_Bus_Type"
+#define PCI_BUS_SPEED_TAG           "PCI_Bus_Speed"
+#define PCI_BUS_WIDTH_TAG           "PCI_Bus_Width"
+#define IRQ_TAG                     "IRQ"
+#define SYSTEM_DEVICE_NAME_TAG      "System_Device_Name"
+#define CURRENT_HWADDR_TAG          "Current_HWaddr"
+#define PERMANENT_HWADDR_TAG        "Permanent_HWaddr"
+
+#define LINK_TAG                    "Link"
+#define SPEED_TAG                   "Speed"
+#define DUPLEX_TAG                  "Duplex"
+#define STATE_TAG                   "State"
+
+#define RX_PACKETS_TAG              "Rx_Packets"
+#define TX_PACKETS_TAG              "Tx_Packets"
+#define RX_BYTES_TAG                "Rx_Bytes"
+#define TX_BYTES_TAG                "Tx_Bytes"
+#define RX_ERRORS_TAG               "Rx_Errors"
+#define TX_ERRORS_TAG               "Tx_Errors"
+#define RX_DROPPED_TAG              "Rx_Dropped"
+#define TX_DROPPED_TAG              "Tx_Dropped"
+#define MULTICAST_TAG               "Multicast"
+#define COLLISIONS_TAG              "Collisions"
+#define RX_LENGTH_ERRORS_TAG        "Rx_Length_Errors"
+#define RX_OVER_ERRORS_TAG          "Rx_Over_Errors"
+#define RX_CRC_ERRORS_TAG           "Rx_CRC_Errors"
+#define RX_FRAME_ERRORS_TAG         "Rx_Frame_Errors"
+#define RX_FIFO_ERRORS_TAG          "Rx_FIFO_Errors"
+#define RX_MISSED_ERRORS_TAG        "Rx_Missed_Errors"
+#define TX_ABORTED_ERRORS_TAG       "Tx_Aborted_Errors"
+#define TX_CARRIER_ERRORS_TAG       "Tx_Carrier_Errors"
+#define TX_FIFO_ERRORS_TAG          "Tx_FIFO_Errors"
+#define TX_HEARTBEAT_ERRORS_TAG     "Tx_Heartbeat_Errors"
+#define TX_WINDOW_ERRORS_TAG        "Tx_Window_Errors"
+
+#define RX_TCP_CHECKSUM_GOOD_TAG    "Rx_TCP_Checksum_Good"
+#define RX_TCP_CHECKSUM_BAD_TAG     "Rx_TCP_Checksum_Bad"
+#define TX_TCP_CHECKSUM_GOOD_TAG    "Tx_TCP_Checksum_Good"
+#define TX_TCP_CHECKSUM_BAD_TAG     "Tx_TCP_Checksum_Bad"
+
+#define TX_LATE_COLL_TAG            "Tx_Abort_Late_Coll"
+#define TX_DEFERRED_TAG             "Tx_Deferred_Ok"
+#define TX_SINGLE_COLL_TAG          "Tx_Single_Coll_Ok"
+#define TX_MULTI_COLL_TAG           "Tx_Multi_Coll_Ok"
+#define RX_LONG_ERRORS_TAG          "Rx_Long_Length_Errors"
+#define RX_SHORT_ERRORS_TAG         "Rx_Short_Length_Errors"
+#define RX_ALIGN_ERRORS_TAG         "Rx_Align_Errors"
+#define RX_XON_TAG                  "Rx_Flow_Control_XON"
+#define RX_XOFF_TAG                 "Rx_Flow_Control_XOFF"
+#define TX_XON_TAG                  "Tx_Flow_Control_XON"
+#define TX_XOFF_TAG                 "Tx_Flow_Control_XOFF"
+#define RX_CSUM_GOOD_TAG            "Rx_Csum_Offload_Good"
+#define RX_CSUM_ERROR_TAG           "Rx_Csum_Offload_Errors"
+
+/* what is the cable length (only for 100/1000 modes)? - 50, 50-80, 80-110, 110-140 and > 140 meters */
+#define CABLE_LENGTH_TAG                 "PHY_Cable_Length"
+
+/* Media Type Copper/Fiber */
+#define MEDIA_TYPE_TAG                   "PHY_Media_Type"
+
+/* Is extended 10 Base-T distance feature enabled? This is done by lowering the receive threshold - enabled/disabled */
+#define EXTENDED_10BASE_T_DISTANCE_TAG   "PHY_Extended_10Base_T_Distance"
+
+/* Cable polarity Normal/Reversed */
+#define CABLE_POLARITY_TAG               "PHY_Cable_Polarity"
+
+/* Is Polarity reversal enabled? Enabled/Disabled */
+#define CABLE_POLARITY_CORRECTION_TAG    "PHY_Disable_Polarity_Correction"
+
+/* Number of IDLE Errors */
+#define IDLE_ERRORS_TAG                  "PHY_Idle_Errors"
+
+/* Should the link be brought down if an IDLE is not seen within 1 msec while in 1000mbps mode? Enabled/Disabled */
+#define LINK_RESET_ENABLED_TAG           "PHY_Link_Reset_Enabled"
+
+/* Number of receive errors */
+#define RECEIVE_ERRORS_TAG               "PHY_Receive_Errors"
+
+/* MDI-X Support Enabled? Auto, Manual(MDI) or Manual(MDI-X) */
+#define MDI_X_ENABLED_TAG                "PHY_MDI_X_Enabled"
+
+/* Local Receiver OK? OK/NOT_OK */
+#define LOCAL_RECEIVER_STATUS_TAG        "PHY_Local_Receiver_Status"
+
+/* Remote Receiver OK? OK/NOT_OK */
+#define REMOTE_RECEIVER_STATUS_TAG       "PHY_Remote_Receiver_Status"
+
+/* symbols exported to e1000_main */
+extern struct proc_dir_entry *e1000_proc_dir;
+extern int e1000_create_proc_dev(struct e1000_adapter * Adapter);
+extern void e1000_remove_proc_dev(struct net_device *dev);
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/idiag_e1000.h linux/drivers/net/e1000/idiag_e1000.h
--- ../ia64/linux/drivers/net/e1000/idiag_e1000.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/idiag_e1000.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,185 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+ *                                                                     *
+ * INTEL CORPORATION                                                   *
+ *                                                                     *
+ * This software is supplied under the terms of the license included   *
+ * above.  All use of this software must be in accordance with the     *
+ * terms of that license.                                              *
+ *                                                                     *
+ * Module Name:  idiag_e1000.h                                         *
+ *                                                                     *
+ * Abstract:     Header file for data structure definition for common  *
+ *               diagnostics support                                   *
+ *                                                                     *
+ **********************************************************************/
+
+#ifndef _IDIAG_E1000_H
+#define _IDIAG_E1000_H
+
+/* Unique base driver identifier */
+
+#define IDIAG_E1000_DRIVER                      0x02
+
+/* e1000 diagnostic commands */
+
+#define IDIAG_E1000_DIAG_REG_TEST               0x01
+#define IDIAG_E1000_DIAG_FIFO_TEST              0x02
+#define IDIAG_E1000_DIAG_XSUM_TEST              0x03
+#define IDIAG_E1000_DIAG_INTR_TEST              0x04
+#define IDIAG_E1000_DIAG_LOOPBACK_TEST          0x05
+#define IDIAG_E1000_DIAG_LINK_TEST              0x06
+#define IDIAG_E1000_DIAG_GET_PHY_INFORMATION    0x0C
+
+typedef struct {
+    unsigned short Reg;
+    unsigned short Pad;
+    unsigned long WriteValue;
+    unsigned long ReadValue;
+} idiag_e1000_diag_reg_test_param_t;
+
+typedef struct {
+    unsigned short Offset;
+    unsigned short Pad;
+    unsigned long WriteValue;
+    unsigned long ReadValue;
+} idiag_e1000_diag_fifo_test_param_t;
+
+typedef struct {
+    unsigned long ExpectedChecksum;
+    unsigned long ActualChecksum;
+} idiag_e1000_diag_eeprom_test_param_t;
+
+typedef struct {
+  unsigned long idle_errors;
+  unsigned long receive_errors;
+  unsigned short line_speed;
+  unsigned char media_type;
+  unsigned char cable_length;
+  unsigned char extended_10b_t_distance;
+  unsigned char cable_polarity;
+  unsigned char polarity_reversal;
+  unsigned char link_reset;
+  unsigned char mdi_x_mode;
+  unsigned char local_rx;
+  unsigned char remote_rx;
+  unsigned char pci_mode;
+  unsigned char bus_speed;
+  unsigned char slot_size;
+} idiag_e1000_diag_phy_information_param_t;
+
+typedef enum {
+    IDIAG_E1000_INTR_TEST_OK,
+    IDIAG_E1000_INTR_TEST_NOT_EXEC,
+    IDIAG_E1000_INTR_TEST_FAILED_WHILE_DISABLED,
+    IDIAG_E1000_INTR_TEST_FAILED_WHILE_ENABLED,
+    IDIAG_E1000_INTR_TEST_FAILED_MASKED_ENABLED
+} idiag_e1000_diag_intr_test_param_t;
+
+#define IDIAG_E1000_DIAG_MAC_LB     0x01
+#define IDIAG_E1000_DIAG_TCVR_LB    0x02
+#define IDIAG_E1000_DIAG_EXT_LB     0x04
+
+#define IDIAG_E1000_ALL_LB        (IDIAG_E1000_DIAG_MAC_LB  | \
+                                 IDIAG_E1000_DIAG_TCVR_LB | \
+                                 IDIAG_E1000_DIAG_EXT_LB)
+
+#define IDIAG_E1000_DEFAULT_LB    (IDIAG_E1000_DIAG_MAC_LB  | \
+                                 IDIAG_E1000_DIAG_TCVR_LB)
+
+typedef enum {
+    IDIAG_E1000_LOOPBACK_TEST_OK,
+    IDIAG_E1000_LOOPBACK_TEST_NOT_EXEC,
+    IDIAG_E1000_LOOPBACK_TEST_FAILED
+} idiag_e1000_diag_loopback_result_t;
+
+typedef struct {
+    /* input - loopback modes to run (MAC, TCVR, EXT) */
+    unsigned int mode;
+
+    /* results */
+    idiag_e1000_diag_loopback_result_t mac;
+    idiag_e1000_diag_loopback_result_t tcvr;
+    idiag_e1000_diag_loopback_result_t ext;
+} idiag_e1000_diag_loopback_test_param_t;
+
+typedef enum {
+    IDIAG_E1000_LINK_TEST_UP,
+    IDIAG_E1000_LINK_TEST_DOWN,
+    IDIAG_E1000_LINK_TEST_NOT_EXEC
+} idiag_e1000_diag_link_test_param_t;
+
+#endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/e1000/idiag_pro.h linux/drivers/net/e1000/idiag_pro.h
--- ../ia64/linux/drivers/net/e1000/idiag_pro.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/e1000/idiag_pro.h	Mon Apr  8 15:34:14 2002
@@ -0,0 +1,129 @@
+/*******************************************************************************
+
+  This software program is available to you under a choice of one of two 
+  licenses. You may choose to be licensed under either the GNU General Public 
+  License (GPL) Version 2, June 1991, available at 
+  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the 
+  text of which follows:
+  
+  Recipient has requested a license and Intel Corporation ("Intel") is willing
+  to grant a license for the software entitled Linux Base Driver for the 
+  Intel(R) PRO/1000 Family of Adapters (e1000) (the "Software") being provided
+  by Intel Corporation. The following definitions apply to this license:
+  
+  "Licensed Patents" means patent claims licensable by Intel Corporation which 
+  are necessarily infringed by the use of sale of the Software alone or when 
+  combined with the operating system referred to below.
+  
+  "Recipient" means the party to whom Intel delivers this Software.
+  
+  "Licensee" means Recipient and those third parties that receive a license to 
+  any operating system available under the GNU Public License version 2.0 or 
+  later.
+  
+  Copyright (c) 1999 - 2002 Intel Corporation.
+  All rights reserved.
+  
+  The license is provided to Recipient and Recipient's Licensees under the 
+  following terms.
+  
+  Redistribution and use in source and binary forms of the Software, with or 
+  without modification, are permitted provided that the following conditions 
+  are met:
+  
+  Redistributions of source code of the Software may retain the above 
+  copyright notice, this list of conditions and the following disclaimer.
+  
+  Redistributions in binary form of the Software may reproduce the above 
+  copyright notice, this list of conditions and the following disclaimer in 
+  the documentation and/or materials provided with the distribution.
+  
+  Neither the name of Intel Corporation nor the names of its contributors 
+  shall be used to endorse or promote products derived from this Software 
+  without specific prior written permission.
+  
+  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, 
+  royalty-free patent license under Licensed Patents to make, use, sell, offer 
+  to sell, import and otherwise transfer the Software, if any, in source code 
+  and object code form. This license shall include changes to the Software 
+  that are error corrections or other minor changes to the Software that do 
+  not add functionality or features when the Software is incorporated in any 
+  version of an operating system that has been distributed under the GNU 
+  General Public License 2.0 or later. This patent license shall apply to the 
+  combination of the Software and any operating system licensed under the GNU 
+  Public License version 2.0 or later if, at the time Intel provides the 
+  Software to Recipient, such addition of the Software to the then publicly 
+  available versions of such operating systems available under the GNU Public 
+  License version 2.0 or later (whether in gold, beta or alpha form) causes 
+  such combination to be covered by the Licensed Patents. The patent license 
+  shall not apply to any other combinations which include the Software. NO 
+  hardware per se is licensed hereunder.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED 
+  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR 
+  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/**********************************************************************
+ *                                                                     *
+ * INTEL CORPORATION                                                   *
+ *                                                                     *
+ * This software is supplied under the terms of the license included   *
+ * above.  All use of this software must be in accordance with the     *
+ * terms of that license.                                              *
+ *                                                                     *
+ * Module Name:  idiag_pro.h                                           *
+ *                                                                     *
+ * Abstract:     Header file for data structure definition for common  *
+ *               diagnostics support                                   *
+ *                                                                     *
+ **********************************************************************/
+
+#ifndef _IDIAG_PRO_H
+#define _IDIAG_PRO_H
+
+#ifndef u16
+#define u16 uint16_t
+#endif
+
+#ifndef u32
+#define u32 uint32_t
+#endif
+
+#define IDIAG_PRO_VERSION           0x100
+#define IDIAG_PRO_PARAM_SIZE        0x80
+
+#define IDIAG_PRO_DRIVER_UNKNOWN    0x0
+#define IDIAG_PRO_IDENTIFY_DRIVER   0x0
+
+#define IDIAG_PRO_BASE_SIOC    (SIOCDEVPRIVATE + 2)
+
+/* Enumeration typedefines */
+typedef enum {
+    IDIAG_PRO_STAT_OK,
+    IDIAG_PRO_STAT_BAD_PARAM,
+    IDIAG_PRO_STAT_TEST_FAILED,
+    IDIAG_PRO_STAT_INVALID_STATE,
+    IDIAG_PRO_STAT_NOT_SUPPORTED,
+    IDIAG_PRO_STAT_TEST_FATAL
+} idiag_pro_stat_t;
+
+typedef struct {
+    unsigned int cmd;
+    unsigned int interface_ver;
+    unsigned int driver_id;
+    unsigned int reserved_in[8];
+    idiag_pro_stat_t status;
+    unsigned int reserved_out[8];
+    unsigned char diag_param[IDIAG_PRO_PARAM_SIZE];
+} idiag_pro_data_t;
+
+#endif
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/eepro100.c linux/drivers/net/eepro100.c
--- ../ia64/linux/drivers/net/eepro100.c	Fri Jan 25 13:11:22 2002
+++ linux/drivers/net/eepro100.c	Wed Feb 27 15:19:22 2002
@@ -70,8 +70,8 @@
 
 /* A few values that may be tweaked. */
 /* The ring sizes should be a power of two for efficiency. */
-#define TX_RING_SIZE	32
-#define RX_RING_SIZE	32
+#define TX_RING_SIZE	64
+#define RX_RING_SIZE	1024
 /* How much slots multicast filter setup may take.
    Do not descrease without changing set_rx_mode() implementaion. */
 #define TX_MULTICAST_SIZE   2
@@ -1078,6 +1078,50 @@
 	outw(CUStart | SCBMaskEarlyRx | SCBMaskFlowCtl, ioaddr + SCBCmd);
 }
 
+/*
+ * Sometimes the receiver stops making progress.  This routine knows how to
+ * get it going again, without losing packets or being otherwise nasty like
+ * a chip reset would be.  Previously the driver had a whole sequence
+ * of if RxSuspended, if it's no buffers do one thing, if it's no resources,
+ * do another, etc.  But those things don't really matter.  Separate logic
+ * in the ISR provides for allocating buffers--the other half of operation
+ * is just making sure the receiver is active.  speedo_rx_soft_reset does that.
+ * This problem with the old, more involved algorithm is shown up under
+ * ping floods on the order of 60K packets/second on a 100Mbps fdx network.
+ */
+static void
+speedo_rx_soft_reset(struct net_device *dev)
+{
+	struct speedo_private *sp = dev->priv;
+	struct RxFD *rfd;
+	long ioaddr;
+
+	ioaddr = dev->base_addr;
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	if (inb(ioaddr + SCBCmd) != 0) {
+		printk("%s: previous command stalled\n", dev->name);
+		return;
+	}
+	/*
+	* Put the hardware into a known state.
+	*/
+	outb(RxAbort, ioaddr + SCBCmd);
+
+	rfd = sp->rx_ringp[sp->cur_rx % RX_RING_SIZE];
+
+	rfd->rx_buf_addr = 0xffffffff;
+
+	wait_for_cmd_done(ioaddr + SCBCmd);
+
+	if (inb(ioaddr + SCBCmd) != 0) {
+		printk("%s: RxAbort command stalled\n", dev->name);
+		return;
+	}
+	outl(sp->rx_ring_dma[sp->cur_rx % RX_RING_SIZE],
+		ioaddr + SCBPointer);
+	outb(RxStart, ioaddr + SCBCmd);
+}
+
 /* Media monitoring and control. */
 static void speedo_timer(unsigned long data)
 {
@@ -1514,82 +1558,37 @@
 		if ((status & 0xfc00) == 0)
 			break;
 
-		/* Always check if all rx buffers are allocated.  --SAW */
-		speedo_refill_rx_buffers(dev, 0);
-
 		if ((status & 0x5000) ||	/* Packet received, or Rx error. */
 			(sp->rx_ring_state&(RrNoMem|RrPostponed)) == RrPostponed)
 									/* Need to gather the postponed packet. */
 			speedo_rx(dev);
 
-		if (status & 0x1000) {
-			spin_lock(&sp->lock);
-			if ((status & 0x003c) == 0x0028) {		/* No more Rx buffers. */
-				struct RxFD *rxf;
-				printk(KERN_WARNING "%s: card reports no RX buffers.\n",
-						dev->name);
-				rxf = sp->rx_ringp[sp->cur_rx % RX_RING_SIZE];
-				if (rxf == NULL) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: NULL cur_rx in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else if (rxf == sp->last_rxf) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: cur_rx is last in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else
-					outb(RxResumeNoResources, ioaddr + SCBCmd);
-			} else if ((status & 0x003c) == 0x0008) { /* No resources. */
-				struct RxFD *rxf;
-				printk(KERN_WARNING "%s: card reports no resources.\n",
-						dev->name);
-				rxf = sp->rx_ringp[sp->cur_rx % RX_RING_SIZE];
-				if (rxf == NULL) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: NULL cur_rx in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else if (rxf == sp->last_rxf) {
-					if (speedo_debug > 2)
-						printk(KERN_DEBUG
-								"%s: cur_rx is last in speedo_interrupt().\n",
-								dev->name);
-					sp->rx_ring_state |= RrNoMem|RrNoResources;
-				} else {
-					/* Restart the receiver. */
-					outl(sp->rx_ring_dma[sp->cur_rx % RX_RING_SIZE],
-						 ioaddr + SCBPointer);
-					outb(RxStart, ioaddr + SCBCmd);
-				}
-			}
-			sp->stats.rx_errors++;
-			spin_unlock(&sp->lock);
-		}
+		/* Always check if all rx buffers are allocated.  --SAW */
+		speedo_refill_rx_buffers(dev, 0);
 
-		if ((sp->rx_ring_state&(RrNoMem|RrNoResources)) == RrNoResources) {
-			printk(KERN_WARNING
-					"%s: restart the receiver after a possible hang.\n",
-					dev->name);
-			spin_lock(&sp->lock);
-			/* Restart the receiver.
-			   I'm not sure if it's always right to restart the receiver
-			   here but I don't know another way to prevent receiver hangs.
-			   1999/12/25 SAW */
-			outl(sp->rx_ring_dma[sp->cur_rx % RX_RING_SIZE],
-				 ioaddr + SCBPointer);
-			outb(RxStart, ioaddr + SCBCmd);
-			sp->rx_ring_state &= ~RrNoResources;
-			spin_unlock(&sp->lock);
+		spin_lock(&sp->lock);
+		/*
+		 * The chip may have suspended reception for various reasons.
+		 * Check for that, and re-prime it should this be the case.
+		 */
+		switch ((status >> 2) & 0xf) {
+		case 0: /* Idle */
+			break;
+		case 1:	/* Suspended */
+		case 2:	/* No resources (RxFDs) */
+		case 9:	/* Suspended with no more RBDs */
+		case 10: /* No resources due to no RBDs */
+		case 12: /* Ready with no RBDs */
+			speedo_rx_soft_reset(dev);
+			break;
+		case 3:  case 5:  case 6:  case 7:  case 8:
+		case 11:  case 13:  case 14:  case 15:
+			/* these are all reserved values */
+			break;
 		}
 
 		/* User interrupt, Command/Tx unit interrupt or CU not active. */
 		if (status & 0xA400) {
-			spin_lock(&sp->lock);
 			speedo_tx_buffer_gc(dev);
 			if (sp->tx_full
 				&& (int)(sp->cur_tx - sp->dirty_tx) < TX_QUEUE_UNFULL) {
@@ -1597,8 +1596,8 @@
 				sp->tx_full = 0;
 				netif_wake_queue(dev); /* Attention: under a spinlock.  --SAW */
 			}
-			spin_unlock(&sp->lock);
 		}
+		spin_unlock(&sp->lock);
 
 		if (--boguscnt < 0) {
 			printk(KERN_ERR "%s: Too much work at interrupt, status=0x%4.4x.\n",
@@ -1719,6 +1718,7 @@
 	int entry = sp->cur_rx % RX_RING_SIZE;
 	int rx_work_limit = sp->dirty_rx + RX_RING_SIZE - sp->cur_rx;
 	int alloc_ok = 1;
+	int npkts = 0;
 
 	if (speedo_debug > 4)
 		printk(KERN_DEBUG " In speedo_rx().\n");
@@ -1785,6 +1785,7 @@
 				memcpy(skb_put(skb, pkt_len), sp->rx_skbuff[entry]->tail,
 					   pkt_len);
 #endif
+				npkts++;
 			} else {
 				/* Pass up the already-filled skbuff. */
 				skb = sp->rx_skbuff[entry];
@@ -1795,6 +1796,7 @@
 				}
 				sp->rx_skbuff[entry] = NULL;
 				skb_put(skb, pkt_len);
+				npkts++;
 				sp->rx_ringp[entry] = NULL;
 				pci_unmap_single(sp->pdev, sp->rx_ring_dma[entry],
 						PKT_BUF_SZ + sizeof(struct RxFD), PCI_DMA_FROMDEVICE);
@@ -1815,7 +1817,8 @@
 	/* Try hard to refill the recently taken buffers. */
 	speedo_refill_rx_buffers(dev, 1);
 
-	sp->last_rx_time = jiffies;
+	if (npkts)
+		sp->last_rx_time = jiffies;
 
 	return 0;
 }
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/tg3.c linux/drivers/net/tg3.c
--- ../ia64/linux/drivers/net/tg3.c	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/tg3.c	Sun Apr 28 22:52:41 2002
@@ -0,0 +1,6448 @@
+/* $Id: tg3.c,v 1.4 2002/04/26 23:04:40 grundler Exp $
+ * tg3.c: Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001, 2002 Jeff Garzik (jgarzik@mandrakesoft.com)
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/compiler.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+
+#ifndef PCI_DMA_BUS_IS_PHYS
+#define PCI_DMA_BUS_IS_PHYS 1
+#endif
+
+/* Either I can't figure out how they secretly implemented it (ie. RXD flags
+ * for mini ring, where it should go in NIC sram, and how many entries the NIC
+ * firmware expects) or it isn't really fully implemented.  Perhaps Broadcom
+ * wants people to pay for a "performance enhanced" version of their firmware +
+ * binary-only driver that has the mini ring actually implemented.
+ * These kids today... -DaveM
+ */
+#define TG3_MINI_RING_WORKS 0
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#define TG3_VLAN_TAG_USED 1
+#else
+#define TG3_VLAN_TAG_USED 0
+#endif
+
+#include "tg3.h"
+
+#define DRV_MODULE_NAME		"tg3"
+#define PFX DRV_MODULE_NAME	": "
+#define DRV_MODULE_VERSION	"0.98"
+#define DRV_MODULE_RELDATE	"Mar 28, 2002"
+
+#define TG3_DEF_MAC_MODE	0
+#define TG3_DEF_RX_MODE		0
+#define TG3_DEF_TX_MODE		0
+#define TG3_DEF_MSG_ENABLE	  \
+	(NETIF_MSG_DRV		| \
+	 NETIF_MSG_PROBE	| \
+	 NETIF_MSG_LINK		| \
+	 NETIF_MSG_TIMER	| \
+	 NETIF_MSG_IFDOWN	| \
+	 NETIF_MSG_IFUP		| \
+	 NETIF_MSG_RX_ERR	| \
+	 NETIF_MSG_TX_ERR)
+
+/* length of time before we decide the hardware is borked,
+ * and dev->tx_timeout() should be called to fix the problem
+ */
+#define TG3_TX_TIMEOUT			(5 * HZ)
+
+/* hardware minimum and maximum for a single frame's data payload */
+#define TG3_MIN_MTU			60
+#define TG3_MAX_MTU			9000
+
+/* These numbers seem to be hard coded in the NIC firmware somehow.
+ * You can't change the ring sizes, but you can change where you place
+ * them in the NIC onboard memory.
+ */
+#define TG3_RX_RING_SIZE		512
+#define TG3_DEF_RX_RING_PENDING		200
+#if TG3_MINI_RING_WORKS
+#define TG3_RX_MINI_RING_SIZE		256 /* ??? */
+#define TG3_DEF_RX_MINI_RING_PENDING	100
+#endif
+#define TG3_RX_JUMBO_RING_SIZE		256
+#define TG3_DEF_RX_JUMBO_RING_PENDING	100
+#define TG3_RX_RCB_RING_SIZE		1024
+#define TG3_TX_RING_SIZE		512
+#define TG3_DEF_TX_RING_PENDING		(TG3_TX_RING_SIZE - 1)
+
+#define TG3_RX_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+				 TG3_RX_RING_SIZE)
+#if TG3_MINI_RING_WORKS
+#define TG3_RX_MINI_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+				 TG3_RX_MINI_RING_SIZE)
+#endif
+#define TG3_RX_JUMBO_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+			         TG3_RX_JUMBO_RING_SIZE)
+#define TG3_RX_RCB_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * \
+			         TG3_RX_RCB_RING_SIZE)
+#define TG3_TX_RING_BYTES	(sizeof(struct tg3_tx_buffer_desc) * \
+				 TG3_TX_RING_SIZE)
+#define TX_RING_GAP(TP)	\
+	(TG3_TX_RING_SIZE - (TP)->tx_pending)
+#define TX_BUFFS_AVAIL(TP)						\
+	(((TP)->tx_cons <= (TP)->tx_prod) ?				\
+	  (TP)->tx_cons + (TP)->tx_pending - (TP)->tx_prod :		\
+	  (TP)->tx_cons - (TP)->tx_prod - TX_RING_GAP(TP))
+#define NEXT_TX(N)		(((N) + 1) & (TG3_TX_RING_SIZE - 1))
+
+#define RX_PKT_BUF_SZ		(1536 + tp->rx_offset + 64)
+#if TG3_MINI_RING_WORKS
+#define RX_MINI_PKT_BUF_SZ	(256 + tp->rx_offset + 64)
+#endif
+#define RX_JUMBO_PKT_BUF_SZ	(9046 + tp->rx_offset + 64)
+
+/* minimum number of free TX descriptors required to wake up TX process */
+#define TG3_TX_WAKEUP_THRESH		(TG3_TX_RING_SIZE / 4)
+
+static char version[] __devinitdata =
+	DRV_MODULE_NAME ".c:v" DRV_MODULE_VERSION " (" DRV_MODULE_RELDATE ")\n";
+
+MODULE_AUTHOR("David S. Miller (davem@redhat.com) and Jeff Garzik (jgarzik@mandrakesoft.com)");
+MODULE_DESCRIPTION("Broadcom Tigon3 ethernet driver");
+MODULE_LICENSE("GPL");
+MODULE_PARM(tg3_debug, "i");
+MODULE_PARM_DESC(tg3_debug, "Tigon3 bitmapped debugging message enable value");
+
+static int tg3_debug = -1;	/* -1 == use TG3_DEF_MSG_ENABLE as value */
+
+static struct pci_device_id tg3_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5700,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5701,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5703,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702FE,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702X,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5703X,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_SYSKONNECT, 0x4400,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_ALTIMA, PCI_DEVICE_ID_ALTIMA_AC1000,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, tg3_pci_tbl);
+
+static void tg3_write_indirect_reg32(struct tg3 *tp, u32 off, u32 val)
+{
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_TARGET_HWBUG) != 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&tp->indirect_lock, flags);
+		pci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off);
+		pci_write_config_dword(tp->pdev, TG3PCI_REG_DATA, val);
+		spin_unlock_irqrestore(&tp->indirect_lock, flags);
+	} else {
+		writel(val, tp->regs + off);
+	}
+}
+
+#define tw32(reg,val)		tg3_write_indirect_reg32(tp,(reg),(val))
+#define tw32_mailbox(reg, val)	writel(((val) & 0xffffffff), tp->regs + (reg))
+#define tw16(reg,val)		writew(((val) & 0xffff), tp->regs + (reg))
+#define tw8(reg,val)		writeb(((val) & 0xff), tp->regs + (reg))
+#define tr32(reg)		readl(tp->regs + (reg))
+#define tr16(reg)		readw(tp->regs + (reg))
+#define tr8(reg)		readb(tp->regs + (reg))
+
+static void tg3_write_mem(struct tg3 *tp, u32 off, u32 val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->indirect_lock, flags);
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+	spin_unlock_irqrestore(&tp->indirect_lock, flags);
+}
+
+static void tg3_read_mem(struct tg3 *tp, u32 off, u32 *val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->indirect_lock, flags);
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_read_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+	spin_unlock_irqrestore(&tp->indirect_lock, flags);
+}
+
+static void tg3_disable_ints(struct tg3 *tp)
+{
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     (tp->misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT));
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);
+}
+
+static void tg3_enable_ints(struct tg3 *tp)
+{
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     (tp->misc_host_ctrl & ~MISC_HOST_CTRL_MASK_PCI_INT));
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000000);
+
+	if (tp->hw_status->status & SD_STATUS_UPDATED)
+		tw32(GRC_LOCAL_CTRL,
+		     tp->grc_local_ctrl | GRC_LCLCTRL_SETINT);
+}
+
+#define PHY_BUSY_LOOPS	5000
+
+static int tg3_readphy(struct tg3 *tp, int reg, u32 *val)
+{
+	u32 frame_val;
+	int loops, ret;
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE,
+		     (tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));
+		udelay(40);
+	}
+
+	*val = 0xffffffff;
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (MI_COM_CMD_READ | MI_COM_START);
+	
+	tw32(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		frame_val = tr32(MAC_MI_COM);
+
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+		udelay(10);
+	}
+
+	ret = -EBUSY;
+	if (loops > 0) {
+		*val = frame_val & MI_COM_DATA_MASK;
+		ret = 0;
+	}
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE, tp->mi_mode);
+		udelay(40);
+	}
+
+	return ret;
+}
+
+static int tg3_writephy(struct tg3 *tp, int reg, u32 val)
+{
+	u32 frame_val;
+	int loops, ret;
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE,
+		     (tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));
+		udelay(40);
+	}
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (val & MI_COM_DATA_MASK);
+	frame_val |= (MI_COM_CMD_WRITE | MI_COM_START);
+	
+	tw32(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		frame_val = tr32(MAC_MI_COM);
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+		udelay(10);
+	}
+
+	ret = -EBUSY;
+	if (loops > 0)
+		ret = 0;
+
+	if ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {
+		tw32(MAC_MI_MODE, tp->mi_mode);
+		udelay(40);
+	}
+
+	return ret;
+}
+
+/* This will reset the tigon3 PHY if there is no valid
+ * link unless the FORCE argument is non-zero.
+ */
+static int tg3_phy_reset(struct tg3 *tp, int force)
+{
+	u32 phy_status, phy_control;
+	int err, limit;
+
+	err  = tg3_readphy(tp, MII_BMSR, &phy_status);
+	err |= tg3_readphy(tp, MII_BMSR, &phy_status);
+	if (err != 0)
+		return -EBUSY;
+
+	/* If we have link, and not forcing a reset, then nothing
+	 * to do.
+	 */
+	if ((phy_status & BMSR_LSTATUS) != 0 && (force == 0))
+		return 0;
+
+	/* OK, reset it, and poll the BMCR_RESET bit until it
+	 * clears or we time out.
+	 */
+	phy_control = BMCR_RESET;
+	err = tg3_writephy(tp, MII_BMCR, phy_control);
+	if (err != 0)
+		return -EBUSY;
+
+	limit = 5000;
+	while (limit--) {
+		err = tg3_readphy(tp, MII_BMCR, &phy_control);
+		if (err != 0)
+			return -EBUSY;
+
+		if ((phy_control & BMCR_RESET) == 0) {
+			udelay(40);
+			return 0;
+		}
+		udelay(10);
+	}
+
+	return -EBUSY;
+}
+
+static int tg3_setup_phy(struct tg3 *);
+static int tg3_halt(struct tg3 *);
+
+static int tg3_set_power_state(struct tg3 *tp, int state)
+{
+	u32 misc_host_ctrl;
+	u16 power_control, power_caps;
+	int pm = tp->pm_cap;
+
+	/* Make sure register accesses (indirect or otherwise)
+	 * will function correctly.
+	 */
+	pci_write_config_dword(tp->pdev,
+			       TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	pci_read_config_word(tp->pdev,
+			     pm + PCI_PM_CTRL,
+			     &power_control);
+	power_control |= PCI_PM_CTRL_PME_STATUS;
+	power_control &= ~(PCI_PM_CTRL_STATE_MASK);
+	switch (state) {
+	case 0:
+		power_control |= 0;
+		pci_write_config_word(tp->pdev,
+				      pm + PCI_PM_CTRL,
+				      power_control);
+		tw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x02);
+		return 0;
+
+	case 1:
+		power_control |= 1;
+		break;
+
+	case 2:
+		power_control |= 2;
+		break;
+
+	case 3:
+		power_control |= 3;
+		break;
+
+	default:
+		printk(KERN_WARNING "%s: Invalid power state (%d) requested.\n",
+		       tp->dev->name, state);
+		return -EINVAL;
+	};
+
+	power_control |= PCI_PM_CTRL_PME_ENABLE;
+
+	misc_host_ctrl = tr32(TG3PCI_MISC_HOST_CTRL);
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT);
+
+	if (tp->link_config.phy_is_low_power == 0) {
+		tp->link_config.phy_is_low_power = 1;
+		tp->link_config.orig_speed = tp->link_config.speed;
+		tp->link_config.orig_duplex = tp->link_config.duplex;
+		tp->link_config.orig_autoneg = tp->link_config.autoneg;
+	}
+
+	tp->link_config.speed = SPEED_10;
+	tp->link_config.autoneg = AUTONEG_ENABLE;
+	tg3_setup_phy(tp);
+
+	tg3_halt(tp);
+
+	pci_read_config_word(tp->pdev, pm + PCI_PM_PMC, &power_caps);
+
+	if (tp->tg3_flags & TG3_FLAG_WOL_ENABLE) {
+		u32 mac_mode;
+
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x5a);
+
+		mac_mode = MAC_MODE_PORT_MODE_MII |
+			MAC_MODE_LINK_POLARITY;
+
+		if (((power_caps & PCI_PM_CAP_PME_D3cold) &&
+		     (tp->tg3_flags & TG3_FLAG_WOL_ENABLE)))
+			mac_mode |= MAC_MODE_MAGIC_PKT_ENABLE;
+
+		tw32(MAC_MODE, mac_mode);
+		tw32(MAC_RX_MODE, RX_MODE_ENABLE);
+	}
+
+	if (tp->tg3_flags & TG3_FLAG_WOL_SPEED_100MB) {
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_ALTCLK));
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_44MHZ_CORE));
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_ALTCLK |
+		      CLOCK_CTRL_44MHZ_CORE));
+	} else {
+		tw32(TG3PCI_CLOCK_CTRL,
+		     (CLOCK_CTRL_RXCLK_DISABLE |
+		      CLOCK_CTRL_TXCLK_DISABLE |
+		      CLOCK_CTRL_ALTCLK |
+		      CLOCK_CTRL_PWRDOWN_PLL133));
+	}
+
+	udelay(40);
+
+	if ((power_caps & PCI_PM_CAP_PME_D3cold) &&
+	    (tp->tg3_flags & TG3_FLAG_WOL_ENABLE)) {
+		/* Move to auxilliary power. */
+		tw32(GRC_LOCAL_CTRL,
+		     (GRC_LCLCTRL_GPIO_OE0 |
+		      GRC_LCLCTRL_GPIO_OE1 |
+		      GRC_LCLCTRL_GPIO_OE2 |
+		      GRC_LCLCTRL_GPIO_OUTPUT0 |
+		      GRC_LCLCTRL_GPIO_OUTPUT1));
+	}
+
+	/* Finally, set the new power state. */
+	pci_write_config_word(tp->pdev, pm + PCI_PM_CTRL, power_control);
+
+	return 0;
+}
+
+static void tg3_link_report(struct tg3 *tp)
+{
+	if (!netif_carrier_ok(tp->dev)) {
+		printk("%s: Link is down.\n", tp->dev->name);
+	} else {
+		printk("%s: Link is up at %d Mbps, %s duplex.\n",
+		       tp->dev->name,
+		       (tp->link_config.active_speed == SPEED_1000 ?
+			1000 :
+			(tp->link_config.active_speed == SPEED_100 ?
+			 100 : 10)),
+		       (tp->link_config.active_duplex == DUPLEX_FULL ?
+			"full" : "half"));
+
+		printk("%s: Flow control is %s for TX and %s for RX.\n",
+		       tp->dev->name,
+		       (tp->tg3_flags & TG3_FLAG_TX_PAUSE) ? "on" : "off",
+		       (tp->tg3_flags & TG3_FLAG_RX_PAUSE) ? "on" : "off");
+	}
+}
+
+static void tg3_setup_flow_control(struct tg3 *tp, u32 local_adv, u32 remote_adv)
+{
+	u32 new_tg3_flags = 0;
+
+	if (local_adv & ADVERTISE_PAUSE_CAP) {
+		if (local_adv & ADVERTISE_PAUSE_ASYM) {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+			else if (remote_adv & LPA_PAUSE_ASYM)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE);
+		} else {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+		}
+	} else if (local_adv & ADVERTISE_PAUSE_ASYM) {
+		if ((remote_adv & LPA_PAUSE_CAP) &&
+		    (remote_adv & LPA_PAUSE_ASYM))
+			new_tg3_flags |= TG3_FLAG_TX_PAUSE;
+	}
+
+	tp->tg3_flags &= ~(TG3_FLAG_RX_PAUSE | TG3_FLAG_TX_PAUSE);
+	tp->tg3_flags |= new_tg3_flags;
+
+	if (new_tg3_flags & TG3_FLAG_RX_PAUSE)
+		tp->rx_mode |= RX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->rx_mode &= ~RX_MODE_FLOW_CTRL_ENABLE;
+
+	if (new_tg3_flags & TG3_FLAG_TX_PAUSE)
+		tp->tx_mode |= TX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->tx_mode &= ~TX_MODE_FLOW_CTRL_ENABLE;
+}
+
+static void tg3_aux_stat_to_speed_duplex(struct tg3 *tp, u32 val, u16 *speed, u8 *duplex)
+{
+	switch (val & MII_TG3_AUX_STAT_SPDMASK) {
+	case MII_TG3_AUX_STAT_10HALF:
+		*speed = SPEED_10;
+		*duplex = DUPLEX_HALF;
+		break;
+
+	case MII_TG3_AUX_STAT_10FULL:
+		*speed = SPEED_10;
+		*duplex = DUPLEX_FULL;
+		break;
+
+	case MII_TG3_AUX_STAT_100HALF:
+		*speed = SPEED_100;
+		*duplex = DUPLEX_HALF;
+		break;
+
+	case MII_TG3_AUX_STAT_100FULL:
+		*speed = SPEED_100;
+		*duplex = DUPLEX_FULL;
+		break;
+
+	case MII_TG3_AUX_STAT_1000HALF:
+		*speed = SPEED_1000;
+		*duplex = DUPLEX_HALF;
+		break;
+
+	case MII_TG3_AUX_STAT_1000FULL:
+		*speed = SPEED_1000;
+		*duplex = DUPLEX_FULL;
+		break;
+
+	default:
+		*speed = SPEED_INVALID;
+		*duplex = DUPLEX_INVALID;
+		break;
+	};
+}
+
+static int tg3_phy_copper_begin(struct tg3 *tp, int wait_for_link)
+{
+	u32 new_adv;
+	int i;
+
+	if (tp->link_config.phy_is_low_power) {
+		/* Entering low power mode.  Disable gigabit and
+		 * 100baseT advertisements.
+		 */
+		tg3_writephy(tp, MII_TG3_CTRL, 0);
+
+		new_adv = (ADVERTISE_10HALF | ADVERTISE_10FULL |
+			   ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+		if (tp->tg3_flags & TG3_FLAG_WOL_SPEED_100MB)
+			new_adv |= (ADVERTISE_100HALF | ADVERTISE_100FULL);
+
+		tg3_writephy(tp, MII_ADVERTISE, new_adv);
+	} else if (tp->link_config.speed == SPEED_INVALID) {
+		tp->link_config.advertising =
+			(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+			 ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+			 ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+			 ADVERTISED_Autoneg | ADVERTISED_MII);
+
+		if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+			tp->link_config.advertising &=
+				~(ADVERTISED_1000baseT_Half |
+				  ADVERTISED_1000baseT_Full);
+
+		new_adv = (ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+		if (tp->link_config.advertising & ADVERTISED_10baseT_Half)
+			new_adv |= ADVERTISE_10HALF;
+		if (tp->link_config.advertising & ADVERTISED_10baseT_Full)
+			new_adv |= ADVERTISE_10FULL;
+		if (tp->link_config.advertising & ADVERTISED_100baseT_Half)
+			new_adv |= ADVERTISE_100HALF;
+		if (tp->link_config.advertising & ADVERTISED_100baseT_Full)
+			new_adv |= ADVERTISE_100FULL;
+		tg3_writephy(tp, MII_ADVERTISE, new_adv);
+
+		if (tp->link_config.advertising &
+		    (ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full)) {
+			new_adv = 0;
+			if (tp->link_config.advertising & ADVERTISED_1000baseT_Half)
+				new_adv |= MII_TG3_CTRL_ADV_1000_HALF;
+			if (tp->link_config.advertising & ADVERTISED_1000baseT_Full)
+				new_adv |= MII_TG3_CTRL_ADV_1000_FULL;
+			if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+			    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)
+				new_adv |= (MII_TG3_CTRL_AS_MASTER |
+					    MII_TG3_CTRL_ENABLE_AS_MASTER);
+			tg3_writephy(tp, MII_TG3_CTRL, new_adv);
+		} else {
+			tg3_writephy(tp, MII_TG3_CTRL, 0);
+		}
+	} else {
+		/* Asking for a specific link mode. */
+		if (tp->link_config.speed == SPEED_1000) {
+			new_adv = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP;
+			tg3_writephy(tp, MII_ADVERTISE, new_adv);
+
+			if (tp->link_config.duplex == DUPLEX_FULL)
+				new_adv = MII_TG3_CTRL_ADV_1000_FULL;
+			else
+				new_adv = MII_TG3_CTRL_ADV_1000_HALF;
+			if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+			    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)
+				new_adv |= (MII_TG3_CTRL_AS_MASTER |
+					    MII_TG3_CTRL_ENABLE_AS_MASTER);
+			tg3_writephy(tp, MII_TG3_CTRL, new_adv);
+		} else {
+			tg3_writephy(tp, MII_TG3_CTRL, 0);
+
+			new_adv = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP;
+			if (tp->link_config.speed == SPEED_100) {
+				if (tp->link_config.duplex == DUPLEX_FULL)
+					new_adv |= ADVERTISE_100FULL;
+				else
+					new_adv |= ADVERTISE_100HALF;
+			} else {
+				if (tp->link_config.duplex == DUPLEX_FULL)
+					new_adv |= ADVERTISE_10FULL;
+				else
+					new_adv |= ADVERTISE_10HALF;
+			}
+			tg3_writephy(tp, MII_ADVERTISE, new_adv);
+		}
+	}
+
+	if (tp->link_config.autoneg == AUTONEG_DISABLE &&
+	    tp->link_config.speed != SPEED_INVALID) {
+		u32 bmcr, orig_bmcr;
+
+		tp->link_config.active_speed = tp->link_config.speed;
+		tp->link_config.active_duplex = tp->link_config.duplex;
+
+		bmcr = 0;
+		switch (tp->link_config.speed) {
+		default:
+		case SPEED_10:
+			break;
+
+		case SPEED_100:
+			bmcr |= BMCR_SPEED100;
+			break;
+
+		case SPEED_1000:
+			bmcr |= TG3_BMCR_SPEED1000;
+			break;
+		};
+
+		if (tp->link_config.duplex == DUPLEX_FULL)
+			bmcr |= BMCR_FULLDPLX;
+
+		tg3_readphy(tp, MII_BMCR, &orig_bmcr);
+		if (bmcr != orig_bmcr) {
+			tg3_writephy(tp, MII_BMCR, BMCR_LOOPBACK);
+			for (i = 0; i < 15000; i++) {
+				u32 tmp;
+
+				udelay(10);
+				tg3_readphy(tp, MII_BMSR, &tmp);
+				tg3_readphy(tp, MII_BMSR, &tmp);
+				if (!(tmp & BMSR_LSTATUS)) {
+					udelay(40);
+					break;
+				}
+			}
+			tg3_writephy(tp, MII_BMCR, bmcr);
+			udelay(40);
+		}
+	} else {
+		tg3_writephy(tp, MII_BMCR,
+			     BMCR_ANENABLE | BMCR_ANRESTART);
+	}
+
+	if (wait_for_link) {
+		tp->link_config.active_speed = SPEED_INVALID;
+		tp->link_config.active_duplex = DUPLEX_INVALID;
+		for (i = 0; i < 300000; i++) {
+			u32 tmp;
+
+			udelay(10);
+			tg3_readphy(tp, MII_BMSR, &tmp);
+			tg3_readphy(tp, MII_BMSR, &tmp);
+			if (!(tmp & BMSR_LSTATUS))
+				continue;
+
+			tg3_readphy(tp, MII_TG3_AUX_STAT, &tmp);
+			tg3_aux_stat_to_speed_duplex(tp, tmp,
+						     &tp->link_config.active_speed,
+						     &tp->link_config.active_duplex);
+		}
+		if (tp->link_config.active_speed == SPEED_INVALID)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int tg3_init_5401phy_dsp(struct tg3 *tp)
+{
+	int err;
+
+	/* Turn off tap power management. */
+	err  = tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c20);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x0012);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x1804);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x0013);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x1204);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8006);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0132);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8006);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0232);
+
+	err |= tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x201f);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0a20);
+
+	udelay(40);
+
+	return err;
+}
+
+static int tg3_setup_copper_phy(struct tg3 *tp)
+{
+	int current_link_up;
+	u32 bmsr, dummy;
+	u16 current_speed;
+	u8 current_duplex;
+	int i, err;
+
+	tw32(MAC_STATUS,
+	     (MAC_STATUS_SYNC_CHANGED |
+	      MAC_STATUS_CFG_CHANGED));
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32(MAC_MI_MODE, tp->mi_mode);
+	udelay(40);
+
+	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401) {
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE))
+			bmsr = 0;
+
+		if (!(bmsr & BMSR_LSTATUS)) {
+			err = tg3_init_5401phy_dsp(tp);
+			if (err)
+				return err;
+
+			tg3_readphy(tp, MII_BMSR, &bmsr);
+			for (i = 0; i < 1000; i++) {
+				udelay(10);
+				tg3_readphy(tp, MII_BMSR, &bmsr);
+				if (bmsr & BMSR_LSTATUS) {
+					udelay(40);
+					break;
+				}
+			}
+
+			if ((tp->phy_id & PHY_ID_REV_MASK) == PHY_REV_BCM5401_B0 &&
+			    !(bmsr & BMSR_LSTATUS) &&
+			    tp->link_config.active_speed == SPEED_1000) {
+				err = tg3_phy_reset(tp, 1);
+				if (!err)
+					err = tg3_init_5401phy_dsp(tp);
+				if (err)
+					return err;
+			}
+		}
+	} else if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+		   tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+		/* 5701 {A0,B0} CRC bug workaround */
+		tg3_writephy(tp, 0x15, 0x0a75);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+		tg3_writephy(tp, 0x1c, 0x8d68);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+	}
+
+	/* Clear pending interrupts... */
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+
+	if (tp->tg3_flags & TG3_FLAG_USE_MI_INTERRUPT)
+		tg3_writephy(tp, MII_TG3_IMASK, ~MII_TG3_INT_LINKCHG);
+	else
+		tg3_writephy(tp, MII_TG3_IMASK, ~0);
+
+	if (tp->led_mode == led_mode_three_link)
+		tg3_writephy(tp, MII_TG3_EXT_CTRL,
+			     MII_TG3_EXT_CTRL_LNK3_LED_MODE);
+	else
+		tg3_writephy(tp, MII_TG3_EXT_CTRL, 0);
+
+	current_link_up = 0;
+	current_speed = SPEED_INVALID;
+	current_duplex = DUPLEX_INVALID;
+
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+
+	if (bmsr & BMSR_LSTATUS) {
+		u32 aux_stat, bmcr;
+
+		tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+		for (i = 0; i < 2000; i++) {
+			udelay(10);
+			tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+			if (aux_stat)
+				break;
+		}
+
+		tg3_aux_stat_to_speed_duplex(tp, aux_stat,
+					     &current_speed,
+					     &current_duplex);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		if (tp->link_config.autoneg == AUTONEG_ENABLE) {
+			if (bmcr & BMCR_ANENABLE) {
+				u32 gig_ctrl;
+
+				current_link_up = 1;
+
+				/* Force autoneg restart if we are exiting
+				 * low power mode.
+				 */
+				tg3_readphy(tp, MII_TG3_CTRL, &gig_ctrl);
+				if (!(gig_ctrl & (MII_TG3_CTRL_ADV_1000_HALF |
+						  MII_TG3_CTRL_ADV_1000_FULL))) {
+					current_link_up = 0;
+				}
+			} else {
+				current_link_up = 0;
+			}
+		} else {
+			if (!(bmcr & BMCR_ANENABLE) &&
+			    tp->link_config.speed == current_speed &&
+			    tp->link_config.duplex == current_duplex) {
+				current_link_up = 1;
+			} else {
+				current_link_up = 0;
+			}
+		}
+
+		tp->link_config.active_speed = current_speed;
+		tp->link_config.active_duplex = current_duplex;
+	}
+
+	if (current_link_up == 1 &&
+	    (tp->link_config.active_duplex == DUPLEX_FULL) &&
+	    (tp->link_config.autoneg == AUTONEG_ENABLE)) {
+		u32 local_adv, remote_adv;
+
+		tg3_readphy(tp, MII_ADVERTISE, &local_adv);
+		local_adv &= (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+		tg3_readphy(tp, MII_LPA, &remote_adv);
+		remote_adv &= (LPA_PAUSE_CAP | LPA_PAUSE_ASYM);
+
+		/* If we are not advertising full pause capability,
+		 * something is wrong.  Bring the link down and reconfigure.
+		 */
+		if (local_adv != ADVERTISE_PAUSE_CAP) {
+			current_link_up = 0;
+		} else {
+			tg3_setup_flow_control(tp, local_adv, remote_adv);
+		}
+	}
+
+	if (current_link_up == 0) {
+		u32 tmp;
+
+		tg3_phy_copper_begin(tp, 0);
+
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		if (tmp & BMSR_LSTATUS)
+			current_link_up = 1;
+	}
+
+	tp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;
+	if (current_link_up == 1) {
+		if (tp->link_config.active_speed == SPEED_100 ||
+		    tp->link_config.active_speed == SPEED_10)
+			tp->mac_mode |= MAC_MODE_PORT_MODE_MII;
+		else
+			tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+	} else
+		tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+
+	tp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;
+	if (tp->link_config.active_duplex == DUPLEX_HALF)
+		tp->mac_mode |= MAC_MODE_HALF_DUPLEX;
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701 ||
+	    GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+		if (current_link_up == 1)
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+		tw32(MAC_LED_CTRL, LED_CTRL_PHY_MODE_1);
+	} else {
+		if ((tp->led_mode == led_mode_link10) ||
+		    (current_link_up == 1 &&
+		     tp->link_config.active_speed == SPEED_10))
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+	}
+	tw32(MAC_MODE, tp->mac_mode);
+
+	if (tp->tg3_flags & TG3_FLAG_USE_LINKCHG_REG) {
+		/* Polled via timer. */
+		tw32(MAC_EVENT, 0);
+	} else {
+		tw32(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 &&
+	    current_link_up == 1 &&
+	    tp->link_config.active_speed == SPEED_1000 &&
+	    ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ||
+	     (tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED))) {
+		udelay(120);
+		tw32(MAC_STATUS,
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED));
+		tg3_write_mem(tp,
+			      NIC_SRAM_FIRMWARE_MBOX,
+			      NIC_SRAM_FIRMWARE_MBOX_MAGIC2);
+	}
+
+	if (current_link_up != netif_carrier_ok(tp->dev)) {
+		if (current_link_up)
+			netif_carrier_on(tp->dev);
+		else
+			netif_carrier_off(tp->dev);
+		tg3_link_report(tp);
+	}
+
+	return 0;
+}
+
+struct tg3_fiber_aneginfo {
+	int state;
+#define ANEG_STATE_UNKNOWN		0
+#define ANEG_STATE_AN_ENABLE		1
+#define ANEG_STATE_RESTART_INIT		2
+#define ANEG_STATE_RESTART		3
+#define ANEG_STATE_DISABLE_LINK_OK	4
+#define ANEG_STATE_ABILITY_DETECT_INIT	5
+#define ANEG_STATE_ABILITY_DETECT	6
+#define ANEG_STATE_ACK_DETECT_INIT	7
+#define ANEG_STATE_ACK_DETECT		8
+#define ANEG_STATE_COMPLETE_ACK_INIT	9
+#define ANEG_STATE_COMPLETE_ACK		10
+#define ANEG_STATE_IDLE_DETECT_INIT	11
+#define ANEG_STATE_IDLE_DETECT		12
+#define ANEG_STATE_LINK_OK		13
+#define ANEG_STATE_NEXT_PAGE_WAIT_INIT	14
+#define ANEG_STATE_NEXT_PAGE_WAIT	15
+
+	u32 flags;
+#define MR_AN_ENABLE		0x00000001
+#define MR_RESTART_AN		0x00000002
+#define MR_AN_COMPLETE		0x00000004
+#define MR_PAGE_RX		0x00000008
+#define MR_NP_LOADED		0x00000010
+#define MR_TOGGLE_TX		0x00000020
+#define MR_LP_ADV_FULL_DUPLEX	0x00000040
+#define MR_LP_ADV_HALF_DUPLEX	0x00000080
+#define MR_LP_ADV_SYM_PAUSE	0x00000100
+#define MR_LP_ADV_ASYM_PAUSE	0x00000200
+#define MR_LP_ADV_REMOTE_FAULT1	0x00000400
+#define MR_LP_ADV_REMOTE_FAULT2	0x00000800
+#define MR_LP_ADV_NEXT_PAGE	0x00001000
+#define MR_TOGGLE_RX		0x00002000
+#define MR_NP_RX		0x00004000
+
+#define MR_LINK_OK		0x80000000
+
+	unsigned long link_time, cur_time;
+
+	u32 ability_match_cfg;
+	int ability_match_count;
+
+	char ability_match, idle_match, ack_match;
+
+	u32 txconfig, rxconfig;
+#define ANEG_CFG_NP		0x00000080
+#define ANEG_CFG_ACK		0x00000040
+#define ANEG_CFG_RF2		0x00000020
+#define ANEG_CFG_RF1		0x00000010
+#define ANEG_CFG_PS2		0x00000001
+#define ANEG_CFG_PS1		0x00008000
+#define ANEG_CFG_HD		0x00004000
+#define ANEG_CFG_FD		0x00002000
+#define ANEG_CFG_INVAL		0x00001f06
+
+};
+#define ANEG_OK		0
+#define ANEG_DONE	1
+#define ANEG_TIMER_ENAB	2
+#define ANEG_FAILED	-1
+
+
+static int tg3_fiber_aneg_smachine(struct tg3 *tp,
+				   struct tg3_fiber_aneginfo *ap)
+{
+	unsigned long delta;
+	u32 rx_cfg_reg;
+	int ret;
+
+	if (ap->state == ANEG_STATE_UNKNOWN) {
+		ap->rxconfig = 0;
+		ap->link_time = 0;
+		ap->cur_time = 0;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->idle_match = 0;
+		ap->ack_match = 0;
+	}
+	ap->cur_time++;
+
+	if (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {
+		rx_cfg_reg = tr32(MAC_RX_AUTO_NEG);
+
+		if (rx_cfg_reg != ap->ability_match_cfg) {
+			ap->ability_match_cfg = rx_cfg_reg;
+			ap->ability_match = 0;
+			ap->ability_match_count = 0;
+		} else {
+			if (++ap->ability_match_count > 1)
+				ap->ability_match = 1;
+		}
+		if (rx_cfg_reg & ANEG_CFG_ACK)
+			ap->ack_match = 1;
+		else
+			ap->ack_match = 0;
+
+		ap->idle_match = 0;
+	} else {
+		ap->idle_match = 1;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->ack_match = 0;
+
+		rx_cfg_reg = 0;
+	}
+
+	ap->rxconfig = rx_cfg_reg;
+	ret = ANEG_OK;
+
+	switch(ap->state) {
+	case ANEG_STATE_UNKNOWN:
+		if (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))
+			ap->state = ANEG_STATE_AN_ENABLE;
+
+		/* fallthru */
+	case ANEG_STATE_AN_ENABLE:
+		ap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);
+		if (ap->flags & MR_AN_ENABLE) {
+			ap->link_time = 0;
+			ap->cur_time = 0;
+			ap->ability_match_cfg = 0;
+			ap->ability_match_count = 0;
+			ap->ability_match = 0;
+			ap->idle_match = 0;
+			ap->ack_match = 0;
+
+			ap->state = ANEG_STATE_RESTART_INIT;
+		} else {
+			ap->state = ANEG_STATE_DISABLE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_RESTART_INIT:
+		ap->link_time = ap->cur_time;
+		ap->flags &= ~(MR_NP_LOADED);
+		ap->txconfig = 0;
+		tw32(MAC_TX_AUTO_NEG, 0);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ret = ANEG_TIMER_ENAB;
+		ap->state = ANEG_STATE_RESTART;
+
+		/* fallthru */
+	case ANEG_STATE_RESTART:
+		delta = ap->cur_time - ap->link_time;
+		if (delta > 100000)
+			ap->state = ANEG_STATE_ABILITY_DETECT_INIT;
+		else
+			ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_DISABLE_LINK_OK:
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT_INIT:
+		ap->flags &= ~(MR_TOGGLE_TX);
+		ap->txconfig = (ANEG_CFG_FD | ANEG_CFG_PS1);
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ap->state = ANEG_STATE_ABILITY_DETECT;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT:
+		if (ap->ability_match != 0 && ap->rxconfig != 0)
+			ap->state = ANEG_STATE_ACK_DETECT_INIT;
+		break;
+
+	case ANEG_STATE_ACK_DETECT_INIT:
+		ap->txconfig |= ANEG_CFG_ACK;
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ap->state = ANEG_STATE_ACK_DETECT;
+
+		/* fallthru */
+	case ANEG_STATE_ACK_DETECT:
+		if (ap->ack_match != 0) {
+			if ((ap->rxconfig & ~ANEG_CFG_ACK) ==
+			    (ap->ability_match_cfg & ~ANEG_CFG_ACK))
+				ap->state = ANEG_STATE_COMPLETE_ACK_INIT;
+			else
+				ap->state = ANEG_STATE_AN_ENABLE;
+		} else if (ap->ability_match != 0 &&
+			   ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+		}
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK_INIT:
+		if (ap->rxconfig & ANEG_CFG_INVAL) {
+			ret = ANEG_FAILED;
+			break;
+		}
+		ap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |
+			       MR_LP_ADV_HALF_DUPLEX |
+			       MR_LP_ADV_SYM_PAUSE |
+			       MR_LP_ADV_ASYM_PAUSE |
+			       MR_LP_ADV_REMOTE_FAULT1 |
+			       MR_LP_ADV_REMOTE_FAULT2 |
+			       MR_LP_ADV_NEXT_PAGE |
+			       MR_TOGGLE_RX |
+			       MR_NP_RX);
+		if (ap->rxconfig & ANEG_CFG_FD)
+			ap->flags |= MR_LP_ADV_FULL_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_HD)
+			ap->flags |= MR_LP_ADV_FULL_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_PS1)
+			ap->flags |= MR_LP_ADV_SYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_PS2)
+			ap->flags |= MR_LP_ADV_ASYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_RF1)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT1;
+		if (ap->rxconfig & ANEG_CFG_RF2)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT2;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_LP_ADV_NEXT_PAGE;
+
+		ap->link_time = ap->cur_time;
+
+		ap->flags ^= (MR_TOGGLE_TX);
+		if (ap->rxconfig & 0x0008)
+			ap->flags |= MR_TOGGLE_RX;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_NP_RX;
+		ap->flags |= MR_PAGE_RX;
+
+		ap->state = ANEG_STATE_COMPLETE_ACK;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > 100000) {
+			if (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {
+				ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+			} else {
+				if ((ap->txconfig & 0x0080) == 0 &&
+				    !(ap->flags & MR_NP_RX))
+					ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+				else
+					ret = ANEG_FAILED;
+			}
+		}
+		break;
+
+	case ANEG_STATE_IDLE_DETECT_INIT:
+		ap->link_time = ap->cur_time;
+		tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+		tw32(MAC_MODE, tp->mac_mode);
+		ap->state = ANEG_STATE_IDLE_DETECT;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_IDLE_DETECT:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > 100000) {
+			/* XXX another gem from the Broadcom driver :( */
+			ap->state = ANEG_STATE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_LINK_OK:
+		ap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT_INIT:
+		/* ??? unimplemented */
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT:
+		/* ??? unimplemented */
+		break;
+
+	default:
+		ret = ANEG_FAILED;
+		break;
+	};
+
+	return ret;
+}
+
+static int tg3_setup_fiber_phy(struct tg3 *tp)
+{
+	int current_link_up;
+	int i;
+
+	tp->mac_mode &= ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);
+	tp->mac_mode |= MAC_MODE_PORT_MODE_TBI;
+	tw32(MAC_MODE, tp->mac_mode);
+	udelay(40);
+
+	/* Reset when initting first time or we have a link. */
+	if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+	    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+		/* Set PLL lock range. */
+		tg3_writephy(tp, 0x16, 0x8007);
+
+		/* SW reset */
+		tg3_writephy(tp, 0x00, 0x8000);
+
+		/* Wait for reset to complete. */
+		/* XXX schedule_timeout() ... */
+		for (i = 0; i < 500; i++)
+			udelay(10);
+
+		/* Config mode; select PMA/Ch 1 regs. */
+		tg3_writephy(tp, 0x10, 0x8411);
+
+		/* Enable auto-lock and comdet, select txclk for tx. */
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		tg3_writephy(tp, 0x18, 0x00a0);
+		tg3_writephy(tp, 0x16, 0x41ff);
+
+		/* Assert and deassert POR. */
+		tg3_writephy(tp, 0x13, 0x0400);
+		udelay(40);
+		tg3_writephy(tp, 0x13, 0x0000);
+
+		tg3_writephy(tp, 0x11, 0x0a50);
+		udelay(40);
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		/* Wait for signal to stabilize */
+		/* XXX schedule_timeout() ... */
+		for (i = 0; i < 15000; i++)
+			udelay(10);
+
+		/* Deselect the channel register so we can read the PHYID
+		 * later.
+		 */
+		tg3_writephy(tp, 0x10, 0x8011);
+	}
+
+	/* Enable link change interrupt. */
+	tw32(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);
+
+	current_link_up = 0;
+	if (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) {
+		if (tp->link_config.autoneg == AUTONEG_ENABLE) {
+			struct tg3_fiber_aneginfo aninfo;
+			int status = ANEG_FAILED;
+
+			memset(&aninfo, 0, sizeof(aninfo));
+			aninfo.flags |= (MR_AN_ENABLE);
+
+			for (i = 0; i < 6; i++) {
+				unsigned int tick;
+				u32 tmp;
+
+				tw32(MAC_TX_AUTO_NEG, 0);
+
+				tmp = tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK;
+				tw32(MAC_MODE, tmp | MAC_MODE_PORT_MODE_GMII);
+				udelay(20);
+
+				tw32(MAC_MODE, tp->mac_mode | MAC_MODE_SEND_CONFIGS);
+
+				aninfo.state = ANEG_STATE_UNKNOWN;
+				aninfo.cur_time = 0;
+				tick = 0;
+				while (++tick < 95000) {
+					status = tg3_fiber_aneg_smachine(tp, &aninfo);
+					if (status == ANEG_DONE ||
+					    status == ANEG_FAILED)
+						break;
+
+					udelay(1);
+				}
+				if (status == ANEG_DONE ||
+				    status == ANEG_FAILED)
+					break;
+			}
+
+			tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+			tw32(MAC_MODE, tp->mac_mode);
+
+			if (status == ANEG_DONE &&
+			    (aninfo.flags & MR_AN_COMPLETE) &&
+			    (aninfo.flags & MR_LINK_OK) &&
+			    (aninfo.flags & MR_LP_ADV_FULL_DUPLEX)) {
+				u32 local_adv, remote_adv;
+
+				local_adv = ADVERTISE_PAUSE_CAP;
+				remote_adv = 0;
+				if (aninfo.flags & MR_LP_ADV_SYM_PAUSE)
+					remote_adv |= LPA_PAUSE_CAP;
+				if (aninfo.flags & MR_LP_ADV_ASYM_PAUSE)
+					remote_adv |= LPA_PAUSE_ASYM;
+
+				tg3_setup_flow_control(tp, local_adv, remote_adv);
+
+				current_link_up = 1;
+			}
+			for (i = 0; i < 60; i++) {
+				udelay(20);
+				tw32(MAC_STATUS,
+				     (MAC_STATUS_SYNC_CHANGED |
+				      MAC_STATUS_CFG_CHANGED));
+
+				udelay(20);
+				if ((tr32(MAC_STATUS) &
+				     (MAC_STATUS_SYNC_CHANGED |
+				      MAC_STATUS_CFG_CHANGED)) == 0)
+					break;
+			}
+		} else {
+			/* Forcing 1000FD link up. */
+			current_link_up = 1;
+		}
+	}
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	tw32(MAC_MODE, tp->mac_mode);
+
+	tp->hw_status->status =
+		(SD_STATUS_UPDATED |
+		 (tp->hw_status->status & ~SD_STATUS_LINK_CHG));
+
+	for (i = 0; i < 100; i++) {
+		tw32(MAC_STATUS,
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED));
+		udelay(5);
+
+		if ((tr32(MAC_STATUS) &
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED)) == 0)
+			break;
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0)
+		current_link_up = 0;
+
+	if (current_link_up == 1) {
+		tp->link_config.active_speed = SPEED_1000;
+		tp->link_config.active_duplex = DUPLEX_FULL;
+	} else {
+		tp->link_config.active_speed = SPEED_INVALID;
+		tp->link_config.active_duplex = DUPLEX_INVALID;
+	}
+
+	if (current_link_up != netif_carrier_ok(tp->dev)) {
+		if (current_link_up)
+			netif_carrier_on(tp->dev);
+		else
+			netif_carrier_off(tp->dev);
+		tg3_link_report(tp);
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0) {
+		tw32(MAC_MODE, tp->mac_mode | MAC_MODE_LINK_POLARITY);
+		if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) {
+			udelay(1);
+			tw32(MAC_MODE, tp->mac_mode);
+		}
+	}
+
+	return 0;
+}
+
+static int tg3_setup_phy(struct tg3 *tp)
+{
+	int err;
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		err = tg3_setup_fiber_phy(tp);
+	} else {
+		err = tg3_setup_copper_phy(tp);
+	}
+
+	if (tp->link_config.active_speed == SPEED_1000 &&
+	    tp->link_config.active_duplex == DUPLEX_HALF)
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (0xff << TX_LENGTHS_SLOT_TIME_SHIFT)));
+	else
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (32 << TX_LENGTHS_SLOT_TIME_SHIFT)));
+
+	return err;
+}
+
+/* Tigon3 never reports partial packet sends.  So we do not
+ * need special logic to handle SKBs that have not had all
+ * of their frags sent yet, like SunGEM does.
+ */
+static void tg3_tx(struct tg3 *tp)
+{
+	u32 hw_idx = tp->hw_status->idx[0].tx_consumer;
+	u32 sw_idx = tp->tx_cons;
+
+	while (sw_idx != hw_idx) {
+		struct ring_info *ri = &tp->tx_buffers[sw_idx];
+		struct sk_buff *skb = ri->skb;
+		int i;
+
+		if (unlikely(skb == NULL))
+			BUG();
+
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(ri, mapping),
+				 (skb->len - skb->data_len),
+				 PCI_DMA_TODEVICE);
+
+		ri->skb = NULL;
+
+		sw_idx = NEXT_TX(sw_idx);
+
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			if (unlikely(sw_idx == hw_idx))
+				BUG();
+
+			ri = &tp->tx_buffers[sw_idx];
+			if (unlikely(ri->skb != NULL))
+				BUG();
+
+			pci_unmap_page(tp->pdev,
+				       pci_unmap_addr(ri, mapping),
+				       skb_shinfo(skb)->frags[i].size,
+				       PCI_DMA_TODEVICE);
+
+			sw_idx = NEXT_TX(sw_idx);
+		}
+
+		dev_kfree_skb_irq(skb);
+	}
+
+	tp->tx_cons = sw_idx;
+
+	if (netif_queue_stopped(tp->dev) &&
+	    (TX_BUFFS_AVAIL(tp) > TG3_TX_WAKEUP_THRESH))
+		netif_wake_queue(tp->dev);
+}
+
+/* Returns size of skb allocated or < 0 on error.
+ *
+ * We only need to fill in the address because the other members
+ * of the RX descriptor are invariant, see tg3_init_rings.
+ *
+ * Note the purposeful assymetry of cpu vs. chip accesses.  For
+ * posting buffers we only dirty the first cache line of the RX
+ * descriptor (containing the address).  Whereas for the RX status
+ * buffers the cpu only reads the last cacheline of the RX descriptor
+ * (to fetch the error flags, vlan tag, checksum, and opaque cookie).
+ */
+static int tg3_alloc_rx_skb(struct tg3 *tp, u32 opaque_key,
+			    int src_idx, u32 dest_idx_unmasked)
+{
+	struct tg3_rx_buffer_desc *desc;
+	struct ring_info *map, *src_map;
+	struct sk_buff *skb;
+	dma_addr_t mapping;
+	int skb_size, dest_idx;
+
+	src_map = NULL;
+	switch (opaque_key) {
+	case RXD_OPAQUE_RING_STD:
+		dest_idx = dest_idx_unmasked % TG3_RX_RING_SIZE;
+		desc = &tp->rx_std[dest_idx];
+		map = &tp->rx_std_buffers[dest_idx];
+		if (src_idx >= 0)
+			src_map = &tp->rx_std_buffers[src_idx];
+		skb_size = RX_PKT_BUF_SZ;
+		break;
+
+	case RXD_OPAQUE_RING_JUMBO:
+		dest_idx = dest_idx_unmasked % TG3_RX_JUMBO_RING_SIZE;
+		desc = &tp->rx_jumbo[dest_idx];
+		map = &tp->rx_jumbo_buffers[dest_idx];
+		if (src_idx >= 0)
+			src_map = &tp->rx_jumbo_buffers[src_idx];
+		skb_size = RX_JUMBO_PKT_BUF_SZ;
+		break;
+#if TG3_MINI_RING_WORKS
+	case RXD_OPAQUE_RING_MINI:
+		dest_idx = dest_idx_unmasked % TG3_RX_MINI_RING_SIZE;
+		desc = &tp->rx_mini[dest_idx];
+		map = &tp->rx_mini_buffers[dest_idx];
+		if (src_idx >= 0)
+			src_map = &tp->rx_mini_buffers[src_idx];
+		skb_size = RX_MINI_PKT_BUF_SZ;
+		break;
+#endif
+	default:
+		return -EINVAL;
+	};
+
+	/* Do not overwrite any of the map or rp information
+	 * until we are sure we can commit to a new buffer.
+	 *
+	 * Callers depend upon this behavior and assume that
+	 * we leave everything unchanged if we fail.
+	 */
+	skb = dev_alloc_skb(skb_size);
+	if (skb == NULL)
+		return -ENOMEM;
+
+	skb->dev = tp->dev;
+	skb_reserve(skb, tp->rx_offset);
+
+	mapping = pci_map_single(tp->pdev, skb->data,
+				 skb_size - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+
+	map->skb = skb;
+	pci_unmap_addr_set(map, mapping, mapping);
+
+	if (src_map != NULL)
+		src_map->skb = NULL;
+
+	desc->addr_hi = ((u64)mapping >> 32);
+	desc->addr_lo = ((u64)mapping & 0xffffffff);
+
+	return skb_size;
+}
+
+/* We only need to move over in the address because the other
+ * members of the RX descriptor are invariant.  See notes above
+ * tg3_alloc_rx_skb for full details.
+ */
+static void tg3_recycle_rx(struct tg3 *tp, u32 opaque_key,
+			   int src_idx, int dest_idx_unmasked)
+{
+	struct tg3_rx_buffer_desc *src_desc, *dest_desc;
+	struct ring_info *src_map, *dest_map;
+	int dest_idx;
+
+	switch (opaque_key) {
+	case RXD_OPAQUE_RING_STD:
+		dest_idx = dest_idx_unmasked % TG3_RX_RING_SIZE;
+		dest_desc = &tp->rx_std[dest_idx];
+		dest_map = &tp->rx_std_buffers[dest_idx];
+		src_desc = &tp->rx_std[src_idx];
+		src_map = &tp->rx_std_buffers[src_idx];
+		break;
+
+	case RXD_OPAQUE_RING_JUMBO:
+		dest_idx = dest_idx_unmasked % TG3_RX_JUMBO_RING_SIZE;
+		dest_desc = &tp->rx_jumbo[dest_idx];
+		dest_map = &tp->rx_jumbo_buffers[dest_idx];
+		src_desc = &tp->rx_jumbo[src_idx];
+		src_map = &tp->rx_jumbo_buffers[src_idx];
+		break;
+#if TG3_MINI_RING_WORKS
+	case RXD_OPAQUE_RING_MINI:
+		dest_idx = dest_idx_unmasked % TG3_RX_MINI_RING_SIZE;
+		dest_desc = &tp->rx_mini[dest_idx];
+		dest_map = &tp->rx_mini_buffers[dest_idx];
+		src_desc = &tp->rx_mini[src_idx];
+		src_map = &tp->rx_mini_buffers[src_idx];
+		break;
+#endif
+	default:
+		return;
+	};
+
+	dest_map->skb = src_map->skb;
+	pci_unmap_addr_set(dest_map, mapping,
+			   pci_unmap_addr(src_map, mapping));
+	dest_desc->addr_hi = src_desc->addr_hi;
+	dest_desc->addr_lo = src_desc->addr_lo;
+
+	src_map->skb = NULL;
+}
+
+#if TG3_VLAN_TAG_USED
+static int tg3_vlan_rx(struct tg3 *tp, struct sk_buff *skb, u16 vlan_tag)
+{
+	return vlan_hwaccel_rx(skb, tp->vlgrp, vlan_tag);
+}
+#endif
+
+/* The RX ring scheme is composed of multiple rings which post fresh
+ * buffers to the chip, and one special ring the chip uses to report
+ * status back to the host.
+ *
+ * The special ring reports the status of received packets to the
+ * host.  The chip does not write into the original descriptor the
+ * RX buffer was obtained from.  The chip simply takes the original
+ * descriptor as provided by the host, updates the status and length
+ * field, then writes this into the next status ring entry.
+ *
+ * Each ring the host uses to post buffers to the chip is described
+ * by a TG3_BDINFO entry in the chips SRAM area.  When a packet arrives,
+ * it is first placed into the on-chip ram.  When the packet's length
+ * is known, it walks down the TG3_BDINFO entries to select the ring.
+ * Each TG3_BDINFO specifies a MAXLEN field and the first TG3_BDINFO
+ * which is within the range of the new packet's length is chosen.
+ *
+ * The "seperate ring for rx status" scheme may sound queer, but it makes
+ * sense from a cache coherency perspective.  If only the host writes
+ * to the buffer post rings, and only the chip writes to the rx status
+ * rings, then cache lines never move beyond shared-modified state.
+ * If both the host and chip were to write into the same ring, cache line
+ * eviction could occur since both entities want it in an exclusive state.
+ */
+static void tg3_rx(struct tg3 *tp)
+{
+	u32 work_mask;
+	u32 rx_rcb_ptr = tp->rx_rcb_ptr;
+	u16 hw_idx, sw_idx;
+
+	hw_idx = tp->hw_status->idx[0].rx_producer;
+	sw_idx = rx_rcb_ptr % TG3_RX_RCB_RING_SIZE;
+	work_mask = 0;
+	while (sw_idx != hw_idx) {
+		struct tg3_rx_buffer_desc *desc = &tp->rx_rcb[sw_idx];
+		unsigned int len;
+		struct sk_buff *skb;
+		dma_addr_t dma_addr;
+		u32 opaque_key, desc_idx, *post_ptr;
+
+		desc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;
+		opaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;
+		if (opaque_key == RXD_OPAQUE_RING_STD) {
+			dma_addr = pci_unmap_addr(&tp->rx_std_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_std_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_std_ptr;
+		} else if (opaque_key == RXD_OPAQUE_RING_JUMBO) {
+			dma_addr = pci_unmap_addr(&tp->rx_jumbo_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_jumbo_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_jumbo_ptr;
+		}
+#if TG3_MINI_RING_WORKS
+		else if (opaque_key == RXD_OPAQUE_RING_MINI) {
+			dma_addr = pci_unmap_addr(&tp->rx_mini_buffers[desc_idx],
+						  mapping);
+			skb = tp->rx_mini_buffers[desc_idx].skb;
+			post_ptr = &tp->rx_mini_ptr;
+		}
+#endif
+		else {
+			goto next_pkt_nopost;
+		}
+
+		work_mask |= opaque_key;
+
+		if ((desc->err_vlan & RXD_ERR_MASK) != 0 &&
+		    (desc->err_vlan != RXD_ERR_ODD_NIBBLE_RCVD_MII)) {
+		drop_it:
+			tg3_recycle_rx(tp, opaque_key,
+				       desc_idx, *post_ptr);
+		drop_it_no_recycle:
+			/* Other statistics kept track of by card. */
+			tp->net_stats.rx_dropped++;
+			goto next_pkt;
+		}
+
+		len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) - 4; /* omit crc */
+
+		/* Kill the copy case if we ever get the mini ring working. */
+		if (len > RX_COPY_THRESHOLD) {
+			int skb_size;
+
+			skb_size = tg3_alloc_rx_skb(tp, opaque_key,
+						    desc_idx, *post_ptr);
+			if (skb_size < 0)
+				goto drop_it;
+
+			pci_unmap_single(tp->pdev, dma_addr,
+					 skb_size - tp->rx_offset,
+					 PCI_DMA_FROMDEVICE);
+
+			skb_put(skb, len);
+		} else {
+			struct sk_buff *copy_skb;
+
+			tg3_recycle_rx(tp, opaque_key,
+				       desc_idx, *post_ptr);
+
+			copy_skb = dev_alloc_skb(len + 2);
+			if (copy_skb == NULL)
+				goto drop_it_no_recycle;
+
+			copy_skb->dev = tp->dev;
+			skb_reserve(copy_skb, 2);
+			skb_put(copy_skb, len);
+			pci_dma_sync_single(tp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);
+			memcpy(copy_skb->data, skb->data, len);
+
+			/* We'll reuse the original ring buffer. */
+			skb = copy_skb;
+		}
+
+		if ((tp->tg3_flags & TG3_FLAG_RX_CHECKSUMS) &&
+		    (desc->type_flags & RXD_FLAG_TCPUDP_CSUM)) {
+			skb->csum = htons((desc->ip_tcp_csum & RXD_TCPCSUM_MASK)
+					  >> RXD_TCPCSUM_SHIFT);
+			skb->ip_summed = CHECKSUM_HW;
+		} else {
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+
+		skb->protocol = eth_type_trans(skb, tp->dev);
+#if TG3_VLAN_TAG_USED
+		if (tp->vlgrp != NULL &&
+		    desc->type_flags & RXD_FLAG_VLAN) {
+			tg3_vlan_rx(tp, skb,
+				    desc->err_vlan & RXD_VLAN_MASK);
+		} else
+#endif
+			netif_rx(skb);
+
+		tp->dev->last_rx = jiffies;
+
+next_pkt:
+		(*post_ptr)++;
+next_pkt_nopost:
+		rx_rcb_ptr++;
+		sw_idx = rx_rcb_ptr % TG3_RX_RCB_RING_SIZE;
+	}
+
+	/* ACK the status ring. */
+	tp->rx_rcb_ptr = rx_rcb_ptr;
+	tw32_mailbox(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW,
+		     (rx_rcb_ptr % TG3_RX_RCB_RING_SIZE));
+
+	/* Refill RX ring(s). */
+	if (work_mask & RXD_OPAQUE_RING_STD) {
+		sw_idx = tp->rx_std_ptr % TG3_RX_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+	}
+	if (work_mask & RXD_OPAQUE_RING_JUMBO) {
+		sw_idx = tp->rx_jumbo_ptr % TG3_RX_JUMBO_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+	}
+#if TG3_MINI_RING_WORKS
+	if (work_mask & RXD_OPAQUE_RING_MINI) {
+		sw_idx = tp->rx_mini_ptr % TG3_RX_MINI_RING_SIZE;
+		tw32_mailbox(MAILBOX_RCV_MINI_PROD_IDX + TG3_64BIT_REG_LOW,
+			     sw_idx);
+	}
+#endif
+}
+
+#define PKT_RATE_LOW		22000
+#define PKT_RATE_HIGH		61000
+
+static void tg3_rate_sample(struct tg3 *tp, unsigned long ticks)
+{
+	u32 delta, rx_now, tx_now;
+	int new_vals, do_tx, do_rx;
+
+	rx_now = tp->hw_stats->rx_ucast_packets.low;
+	tx_now = tp->hw_stats->COS_out_packets[0].low;
+
+	delta  = (rx_now - tp->last_rx_count);
+	delta += (tx_now - tp->last_tx_count);
+	delta /= (ticks / tp->coalesce_config.rate_sample_jiffies);
+
+	tp->last_rx_count = rx_now;
+	tp->last_tx_count = tx_now;
+
+	new_vals = 0;
+	do_tx = (tp->tg3_flags & TG3_FLAG_ADAPTIVE_TX) != 0;
+	do_rx = (tp->tg3_flags & TG3_FLAG_ADAPTIVE_RX) != 0;
+	if (delta < tp->coalesce_config.pkt_rate_low) {
+		if (do_rx &&
+		    tp->coalesce_config.rx_max_coalesced_frames !=
+		    tp->coalesce_config.rx_max_coalesced_frames_low) {
+			tp->coalesce_config.rx_max_coalesced_frames =
+				LOW_RXMAX_FRAMES;
+			tp->coalesce_config.rx_coalesce_ticks =
+				LOW_RXCOL_TICKS;
+			new_vals = 1;
+		}
+		if (do_tx &&
+		    tp->coalesce_config.tx_max_coalesced_frames !=
+		    tp->coalesce_config.tx_max_coalesced_frames_low) {
+			tp->coalesce_config.tx_max_coalesced_frames =
+				tp->coalesce_config.tx_max_coalesced_frames_low;
+			tp->coalesce_config.tx_coalesce_ticks =
+				tp->coalesce_config.tx_coalesce_ticks_low;
+			new_vals = 1;
+		}
+	} else if (delta < tp->coalesce_config.pkt_rate_high) {
+		if (do_rx &&
+		    tp->coalesce_config.rx_max_coalesced_frames !=
+		    tp->coalesce_config.rx_max_coalesced_frames_def) {
+			tp->coalesce_config.rx_max_coalesced_frames =
+				tp->coalesce_config.rx_max_coalesced_frames_def;
+			tp->coalesce_config.rx_coalesce_ticks =
+				tp->coalesce_config.rx_coalesce_ticks_def;
+			new_vals = 1;
+		}
+		if (do_tx &&
+		    tp->coalesce_config.tx_max_coalesced_frames !=
+		    tp->coalesce_config.tx_max_coalesced_frames_def) {
+			tp->coalesce_config.tx_max_coalesced_frames =
+				tp->coalesce_config.tx_max_coalesced_frames_def;
+			tp->coalesce_config.tx_coalesce_ticks =
+				tp->coalesce_config.tx_coalesce_ticks_def;
+			new_vals = 1;
+		}
+	} else {
+		if (do_rx &&
+		    tp->coalesce_config.rx_max_coalesced_frames !=
+		    tp->coalesce_config.rx_max_coalesced_frames_high) {
+			tp->coalesce_config.rx_max_coalesced_frames =
+				tp->coalesce_config.rx_max_coalesced_frames_high;
+			tp->coalesce_config.rx_coalesce_ticks =
+				tp->coalesce_config.rx_coalesce_ticks_high;
+			new_vals = 1;
+		}
+		if (do_tx &&
+		    tp->coalesce_config.tx_max_coalesced_frames !=
+		    tp->coalesce_config.tx_max_coalesced_frames_high) {
+			tp->coalesce_config.tx_max_coalesced_frames =
+				tp->coalesce_config.tx_max_coalesced_frames_high;
+			tp->coalesce_config.tx_coalesce_ticks =
+				tp->coalesce_config.tx_coalesce_ticks_high;
+			new_vals = 1;
+		}
+	}
+
+	if (new_vals) {
+		if (do_rx) {
+			tw32(HOSTCC_RXCOL_TICKS,
+			     tp->coalesce_config.rx_coalesce_ticks);
+			tw32(HOSTCC_RXMAX_FRAMES,
+			     tp->coalesce_config.rx_max_coalesced_frames);
+		}
+		if (do_tx) {
+			tw32(HOSTCC_TXCOL_TICKS,
+			     tp->coalesce_config.tx_coalesce_ticks);
+			tw32(HOSTCC_TXMAX_FRAMES,
+			     tp->coalesce_config.tx_max_coalesced_frames);
+		}
+	}
+
+	tp->last_rate_sample = jiffies;
+}
+
+static void tg3_interrupt_main_work(struct tg3 *tp)
+{
+	struct tg3_hw_status *sblk = tp->hw_status;
+	int did_pkts;
+
+	if (!(tp->tg3_flags & TG3_FLAG_USE_LINKCHG_REG)) {
+		if (sblk->status & SD_STATUS_LINK_CHG) {
+			sblk->status = SD_STATUS_UPDATED |
+				(sblk->status & ~SD_STATUS_LINK_CHG);
+			tg3_setup_phy(tp);
+		}
+	}
+
+	did_pkts = 0;
+	if (sblk->idx[0].rx_producer != tp->rx_rcb_ptr) {
+		tg3_rx(tp);
+		did_pkts = 1;
+	}
+
+	if (sblk->idx[0].tx_consumer != tp->tx_cons) {
+		tg3_tx(tp);
+		did_pkts = 1;
+	}
+
+	if (did_pkts &&
+	    (tp->tg3_flags & (TG3_FLAG_ADAPTIVE_RX | TG3_FLAG_ADAPTIVE_TX))) {
+		unsigned long ticks = jiffies - tp->last_rate_sample;
+
+		if (ticks >= tp->coalesce_config.rate_sample_jiffies)
+			tg3_rate_sample(tp, ticks);
+	}
+}
+
+static void tg3_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	struct tg3 *tp = dev->priv;
+	struct tg3_hw_status *sblk = tp->hw_status;
+
+	spin_lock(&tp->lock);
+
+	while (sblk->status & SD_STATUS_UPDATED) {
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,
+			     0x00000001);
+		sblk->status &= ~SD_STATUS_UPDATED;
+
+		tg3_interrupt_main_work(tp);
+
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,
+			     0x00000000);
+		tr32(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW);
+	}
+
+	spin_unlock(&tp->lock);
+}
+
+static void tg3_interrupt_tagged(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+	struct tg3 *tp = dev->priv;
+	struct tg3_hw_status *sblk = tp->hw_status;
+
+	spin_lock(&tp->lock);
+
+	if (sblk->status & SD_STATUS_UPDATED) {
+		u32 oldtag;
+
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,
+			     0x00000001);
+		oldtag = sblk->status_tag;
+
+		while (1) {
+			u32 newtag;
+
+			sblk->status &= ~SD_STATUS_UPDATED;
+			barrier();
+
+			tg3_interrupt_main_work(tp);
+
+			newtag = sblk->status_tag;
+			if (newtag == oldtag) {
+				tw32_mailbox(MAILBOX_INTERRUPT_0 +
+					     TG3_64BIT_REG_LOW,
+					     newtag << 24);
+				break;
+			}
+			oldtag = newtag;
+		}
+	}
+
+	spin_unlock(&tp->lock);
+}
+
+static void tg3_init_rings(struct tg3 *);
+static int tg3_init_hw(struct tg3 *);
+
+static void tg3_tx_timeout(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+
+	printk(KERN_ERR "%s: transmit timed out, resetting\n",
+	       dev->name);
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_halt(tp);
+	tg3_init_rings(tp);
+	tg3_init_hw(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	netif_wake_queue(dev);
+}
+
+#if !PCI_DMA_BUS_IS_PHYS
+static void tg3_set_txd_addr(struct tg3 *tp, int entry, dma_addr_t mapping)
+{
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		struct tg3_tx_buffer_desc *txd = &tp->tx_ring[entry];
+
+		txd->addr_hi = ((u64) mapping >> 32);
+		txd->addr_lo = ((u64) mapping & 0xffffffff);
+	} else {
+		unsigned long txd;
+
+		txd = (tp->regs +
+		       NIC_SRAM_WIN_BASE +
+		       NIC_SRAM_TX_BUFFER_DESC);
+		txd += (entry * TXD_SIZE);
+
+		if (sizeof(dma_addr_t) != sizeof(u32))
+			writel(((u64) mapping >> 32),
+			       txd + TXD_ADDR + TG3_64BIT_REG_HIGH);
+
+		writel(((u64) mapping & 0xffffffff),
+		       txd + TXD_ADDR + TG3_64BIT_REG_LOW);
+	}
+}
+#endif
+
+static void tg3_set_txd(struct tg3 *, int, dma_addr_t, int, u32, int);
+
+static int tigon3_4gb_hwbug_workaround(struct tg3 *tp, struct sk_buff *skb,
+				       u32 guilty_entry, int guilty_len,
+				       u32 last_plus_one, u32 *start)
+{
+	dma_addr_t new_addr;
+	u32 entry = *start;
+	int i;
+
+#if !PCI_DMA_BUS_IS_PHYS
+	/* IOMMU, just map the guilty area again which is guarenteed to
+	 * use different addresses.
+	 */
+
+	i = 0;
+	while (entry != guilty_entry) {
+		entry = NEXT_TX(entry);
+		i++;
+	}
+	if (i == 0) {
+		new_addr = pci_map_single(tp->pdev, skb->data, guilty_len,
+					  PCI_DMA_TODEVICE);
+	} else {
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i - 1];
+
+		new_addr = pci_map_page(tp->pdev,
+					frag->page, frag->page_offset,
+					guilty_len, PCI_DMA_TODEVICE);
+	}
+	pci_unmap_single(tp->pdev, pci_unmap_addr(&tp->tx_buffers[guilty_entry],
+						  mapping),
+			 guilty_len, PCI_DMA_TODEVICE);
+	tg3_set_txd_addr(tp, guilty_entry, new_addr);
+	pci_unmap_addr_set(&tp->tx_buffers[guilty_entry], mapping,
+			   new_addr);
+	*start = last_plus_one;
+#else
+	/* Oh well, no IOMMU, have to allocate a whole new SKB. */
+	struct sk_buff *new_skb = skb_copy(skb, GFP_ATOMIC);
+
+	if (!new_skb) {
+		dev_kfree_skb(skb);
+		return -1;
+	}
+
+	/* NOTE: Broadcom's driver botches this case up really bad.
+	 *       This is especially true if any of the frag pages
+	 *       are in highmem.  It will instantly oops in that case.
+	 */
+
+	/* New SKB is guarenteed to be linear. */
+	entry = *start;
+	new_addr = pci_map_single(tp->pdev, new_skb->data, new_skb->len,
+				  PCI_DMA_TODEVICE);
+	tg3_set_txd(tp, entry, new_addr, new_skb->len,
+		    (skb->ip_summed == CHECKSUM_HW) ?
+		    TXD_FLAG_TCPUDP_CSUM : 0, 1);
+	*start = NEXT_TX(entry);
+
+	/* Now clean up the sw ring entries. */
+	i = 0;
+	while (entry != last_plus_one) {
+		int len;
+
+		if (i == 0)
+			len = skb->len - skb->data_len;
+		else
+			len = skb_shinfo(skb)->frags[i-1].size;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(&tp->tx_buffers[entry], mapping),
+				 len, PCI_DMA_TODEVICE);
+		if (i == 0) {
+			tp->tx_buffers[entry].skb = new_skb;
+			pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, new_addr);
+		} else {
+			tp->tx_buffers[entry].skb = NULL;
+		}
+		entry = NEXT_TX(entry);
+	}
+
+	dev_kfree_skb(skb);
+#endif
+
+	return 0;
+}
+
+static void tg3_set_txd(struct tg3 *tp, int entry,
+			dma_addr_t mapping, int len, u32 flags,
+			int is_end)
+{
+#if TG3_VLAN_TAG_USED
+	u16 vlan_tag = 0;
+#endif
+
+	if (is_end)
+		flags |= TXD_FLAG_END;
+#if TG3_VLAN_TAG_USED
+	if (flags & TXD_FLAG_VLAN) {
+		vlan_tag = flags >> 16;
+		flags &= 0xffff;
+	}
+#endif
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		struct tg3_tx_buffer_desc *txd = &tp->tx_ring[entry];
+
+		txd->addr_hi = ((u64) mapping >> 32);
+		txd->addr_lo = ((u64) mapping & 0xffffffff);
+		txd->len_flags = (len << TXD_LEN_SHIFT) | flags;
+#if TG3_VLAN_TAG_USED
+		txd->vlan_tag = vlan_tag << TXD_VLAN_TAG_SHIFT;
+#endif
+	} else {
+		unsigned long txd;
+
+		txd = (tp->regs +
+		       NIC_SRAM_WIN_BASE +
+		       NIC_SRAM_TX_BUFFER_DESC);
+		txd += (entry * TXD_SIZE);
+
+		/* Save some PIOs */
+		if (sizeof(dma_addr_t) != sizeof(u32))
+			writel(((u64) mapping >> 32),
+			       txd + TXD_ADDR + TG3_64BIT_REG_HIGH);
+
+		writel(((u64) mapping & 0xffffffff),
+		       txd + TXD_ADDR + TG3_64BIT_REG_LOW);
+		writel(len << TXD_LEN_SHIFT | flags, txd + TXD_LEN_FLAGS);
+#if TG3_VLAN_TAG_USED
+		writel(vlan_tag << TXD_VLAN_TAG_SHIFT, txd + TXD_VLAN_TAG);
+#endif
+	}
+}
+
+static inline int tg3_4g_overflow_test(dma_addr_t mapping, int len)
+{
+	u32 base = (u32) mapping & 0xffffffff;
+
+	return ((base > 0xffffdcc0) &&
+		((u64) mapping >> 32) == 0 &&
+		(base + len + 8 < base));
+}
+
+static int tg3_start_xmit_4gbug(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	dma_addr_t mapping;
+	unsigned int i;
+	u32 len, entry, base_flags;
+	int would_hit_hwbug;
+
+	len = (skb->len - skb->data_len);
+
+	spin_lock_irq(&tp->lock);
+
+	/* This is a hard error, log it. */
+	if (unlikely(TX_BUFFS_AVAIL(tp) <= (skb_shinfo(skb)->nr_frags + 1))) {
+		netif_stop_queue(dev);
+		spin_unlock_irq(&tp->lock);
+		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
+		       dev->name);
+		return 1;
+	}
+
+	entry = tp->tx_prod;
+	base_flags = 0;
+	if (skb->ip_summed == CHECKSUM_HW)
+		base_flags |= TXD_FLAG_TCPUDP_CSUM;
+#if TG3_VLAN_TAG_USED
+	if (tp->vlgrp != NULL && vlan_tx_tag_present(skb))
+		base_flags |= (TXD_FLAG_VLAN |
+			       (vlan_tx_tag_get(skb) << 16));
+#endif
+
+	/* Queue skb data, a.k.a. the main skb fragment. */
+	mapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);
+
+	tp->tx_buffers[entry].skb = skb;
+	pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+	would_hit_hwbug = 0;
+
+	if (tg3_4g_overflow_test(mapping, len))
+		would_hit_hwbug = entry + 1;
+
+	tg3_set_txd(tp, entry, mapping, len, base_flags,
+		    (skb_shinfo(skb)->nr_frags == 0));
+
+	entry = NEXT_TX(entry);
+
+	/* Now loop through additional data fragments, and queue them. */
+	if (skb_shinfo(skb)->nr_frags > 0) {
+		unsigned int i, last;
+
+		last = skb_shinfo(skb)->nr_frags - 1;
+		for (i = 0; i <= last; i++) {
+			skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+
+			len = frag->size;
+			mapping = pci_map_page(tp->pdev,
+					       frag->page,
+					       frag->page_offset,
+					       len, PCI_DMA_TODEVICE);
+
+			tp->tx_buffers[entry].skb = NULL;
+			pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+			if (tg3_4g_overflow_test(mapping, len)) {
+				/* Only one should match. */
+				if (would_hit_hwbug)
+					BUG();
+				would_hit_hwbug = entry + 1;
+			}
+
+			tg3_set_txd(tp, entry, mapping, len,
+				    base_flags, (i == last));
+
+			entry = NEXT_TX(entry);
+		}
+	}
+
+	if (would_hit_hwbug) {
+		u32 last_plus_one = entry;
+		u32 start;
+		unsigned int len = 0;
+
+		would_hit_hwbug -= 1;
+		entry = entry - 1 - skb_shinfo(skb)->nr_frags;
+		entry &= (TG3_TX_RING_SIZE - 1);
+		start = entry;
+		i = 0;
+		while (entry != last_plus_one) {
+			if (i == 0)
+				len = skb->len - skb->data_len;
+			else
+				len = skb_shinfo(skb)->frags[i-1].size;
+
+			if (entry == would_hit_hwbug)
+				break;
+
+			i++;
+			entry = NEXT_TX(entry);
+
+		}
+
+		/* If the workaround fails due to memory/mapping
+		 * failure, silently drop this packet.
+		 */
+		if (tigon3_4gb_hwbug_workaround(tp, skb,
+						entry, len,
+						last_plus_one,
+						&start))
+			goto out_unlock;
+
+		entry = start;
+	}
+
+	/* Packets are ready, update Tx producer idx local and on card. */
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+		if (tp->tg3_flags & TG3_FLAG_TXD_MBOX_HWBUG)
+			tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 +
+				      TG3_64BIT_REG_LOW), entry);
+	} else {
+		tw32_mailbox((MAILBOX_SNDNIC_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+		if (tp->tg3_flags & TG3_FLAG_TXD_MBOX_HWBUG)
+			tw32_mailbox((MAILBOX_SNDNIC_PROD_IDX_0 +
+				      TG3_64BIT_REG_LOW), entry);
+	}
+
+	tp->tx_prod = entry;
+	if (TX_BUFFS_AVAIL(tp) <= (MAX_SKB_FRAGS + 1))
+		netif_stop_queue(dev);
+
+out_unlock:
+	spin_unlock_irq(&tp->lock);
+
+	dev->trans_start = jiffies;
+
+	return 0;
+}
+
+static int tg3_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	dma_addr_t mapping;
+	u32 len, entry, base_flags;
+
+	len = (skb->len - skb->data_len);
+
+	spin_lock_irq(&tp->lock);
+
+	/* This is a hard error, log it. */
+	if (unlikely(TX_BUFFS_AVAIL(tp) <= (skb_shinfo(skb)->nr_frags + 1))) {
+		netif_stop_queue(dev);
+		spin_unlock_irq(&tp->lock);
+		printk(KERN_ERR PFX "%s: BUG! Tx Ring full when queue awake!\n",
+		       dev->name);
+		return 1;
+	}
+
+	entry = tp->tx_prod;
+	base_flags = 0;
+	if (skb->ip_summed == CHECKSUM_HW)
+		base_flags |= TXD_FLAG_TCPUDP_CSUM;
+#if TG3_VLAN_TAG_USED
+	if (tp->vlgrp != NULL && vlan_tx_tag_present(skb))
+		base_flags |= (TXD_FLAG_VLAN |
+			       (vlan_tx_tag_get(skb) << 16));
+#endif
+
+	/* Queue skb data, a.k.a. the main skb fragment. */
+	mapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);
+
+	tp->tx_buffers[entry].skb = skb;
+	pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+	tg3_set_txd(tp, entry, mapping, len, base_flags,
+		    (skb_shinfo(skb)->nr_frags == 0));
+
+	entry = NEXT_TX(entry);
+
+	/* Now loop through additional data fragments, and queue them. */
+	if (skb_shinfo(skb)->nr_frags > 0) {
+		unsigned int i, last;
+
+		last = skb_shinfo(skb)->nr_frags - 1;
+		for (i = 0; i <= last; i++) {
+			skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+
+
+			len = frag->size;
+			mapping = pci_map_page(tp->pdev,
+					       frag->page,
+					       frag->page_offset,
+					       len, PCI_DMA_TODEVICE);
+
+			tp->tx_buffers[entry].skb = NULL;
+			pci_unmap_addr_set(&tp->tx_buffers[entry], mapping, mapping);
+
+			tg3_set_txd(tp, entry, mapping, len,
+				    base_flags, (i == last));
+
+			entry = NEXT_TX(entry);
+		}
+	}
+
+	/* Packets are ready, update Tx producer idx local and on card.
+	 * We know this is not a 5700 (by virtue of not being a chip
+	 * requiring the 4GB overflow workaround) so we can safely omit
+	 * the double-write bug tests.
+	 */
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+	} else {
+		tw32_mailbox((MAILBOX_SNDNIC_PROD_IDX_0 +
+			      TG3_64BIT_REG_LOW), entry);
+	}
+
+	tp->tx_prod = entry;
+	if (TX_BUFFS_AVAIL(tp) <= (MAX_SKB_FRAGS + 1))
+		netif_stop_queue(dev);
+
+	spin_unlock_irq(&tp->lock);
+
+	dev->trans_start = jiffies;
+
+	return 0;
+}
+
+static int tg3_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct tg3 *tp = dev->priv;
+
+	if (new_mtu < TG3_MIN_MTU || new_mtu > TG3_MAX_MTU)
+		return -EINVAL;
+
+	if (!netif_running(dev)) {
+		/* We'll just catch it later when the
+		 * device is up'd.
+		 */
+		dev->mtu = new_mtu;
+		return 0;
+	}
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_halt(tp);
+
+	dev->mtu = new_mtu;
+
+	if (new_mtu > ETH_DATA_LEN)
+		tp->tg3_flags |= TG3_FLAG_JUMBO_ENABLE;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_JUMBO_ENABLE;
+
+	tg3_init_rings(tp);
+	tg3_init_hw(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+/* Free up pending packets in all rx/tx rings.
+ *
+ * The chip has been shut down and the driver detached from
+ * the networking, so no interrupts or new tx packets will
+ * end up in the driver.  tp->lock is not held and we are not
+ * in an interrupt context and thus may sleep.
+ */
+static void tg3_free_rings(struct tg3 *tp)
+{
+	struct ring_info *rxp;
+	int i;
+
+	for (i = 0; i < TG3_RX_RING_SIZE; i++) {
+		rxp = &tp->rx_std_buffers[i];
+
+		if (rxp->skb == NULL)
+			continue;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(rxp, mapping),
+				 RX_PKT_BUF_SZ - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(rxp->skb);
+		rxp->skb = NULL;
+	}
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < TG3_RX_MINI_RING_SIZE; i++) {
+		rxp = &tp->rx_mini_buffers[i];
+
+		if (rxp->skb == NULL)
+			continue;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(rxp, mapping),
+				 RX_MINI_PKT_BUF_SZ - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(rxp->skb);
+		rxp->skb = NULL;
+	}
+#endif
+	for (i = 0; i < TG3_RX_JUMBO_RING_SIZE; i++) {
+		rxp = &tp->rx_jumbo_buffers[i];
+
+		if (rxp->skb == NULL)
+			continue;
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(rxp, mapping),
+				 RX_JUMBO_PKT_BUF_SZ - tp->rx_offset,
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(rxp->skb);
+		rxp->skb = NULL;
+	}
+
+	for (i = 0; i < TG3_TX_RING_SIZE; ) {
+		struct ring_info *txp;
+		struct sk_buff *skb;
+		int j;
+
+		txp = &tp->tx_buffers[i];
+		skb = txp->skb;
+
+		if (skb == NULL) {
+			i++;
+			continue;
+		}
+
+		pci_unmap_single(tp->pdev,
+				 pci_unmap_addr(txp, mapping),
+				 (skb->len - skb->data_len),
+				 PCI_DMA_TODEVICE);
+		txp->skb = NULL;
+
+		i++;
+
+		for (j = 0; j < skb_shinfo(skb)->nr_frags; j++) {
+			txp = &tp->tx_buffers[i & (TG3_TX_RING_SIZE - 1)];
+			pci_unmap_page(tp->pdev,
+				       pci_unmap_addr(txp, mapping),
+				       skb_shinfo(skb)->frags[j].size,
+				       PCI_DMA_TODEVICE);
+			i++;
+		}
+
+		dev_kfree_skb_any(skb);
+	}
+}
+
+/* Initialize tx/rx rings for packet processing.
+ *
+ * The chip has been shut down and the driver detached from
+ * the networking, so no interrupts or new tx packets will
+ * end up in the driver.  tp->lock is not held and we are not
+ * in an interrupt context and thus may sleep.
+ */
+static void tg3_init_rings(struct tg3 *tp)
+{
+	unsigned long start, end;
+	u32 i;
+
+	/* Free up all the SKBs. */
+	tg3_free_rings(tp);
+
+	/* Zero out all descriptors. */
+	memset(tp->rx_std, 0, TG3_RX_RING_BYTES);
+#if TG3_MINI_RING_WORKS
+	memset(tp->rx_mini, 0, TG3_RX_MINI_RING_BYTES);
+#endif
+	memset(tp->rx_jumbo, 0, TG3_RX_JUMBO_RING_BYTES);
+	memset(tp->rx_rcb, 0, TG3_RX_RCB_RING_BYTES);
+
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		memset(tp->tx_ring, 0, TG3_TX_RING_BYTES);
+	} else {
+		start = (tp->regs +
+			 NIC_SRAM_WIN_BASE +
+			 NIC_SRAM_TX_BUFFER_DESC);
+		end = start + TG3_TX_RING_BYTES;
+		while (start < end) {
+			writel(0, start);
+			start += 4;
+		}
+	}
+
+	/* Initialize invariants of the rings, we only set this
+	 * stuff once.  This works because the card does not
+	 * write into the rx buffer posting rings.
+	 */
+	for (i = 0; i < TG3_RX_RING_SIZE; i++) {
+		struct tg3_rx_buffer_desc *rxd;
+
+		rxd = &tp->rx_std[i];
+		rxd->idx_len = (RX_PKT_BUF_SZ - tp->rx_offset - 64)
+			<< RXD_LEN_SHIFT;
+		rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT);
+		rxd->opaque = (RXD_OPAQUE_RING_STD |
+			       (i << RXD_OPAQUE_INDEX_SHIFT));
+	}
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < TG3_RX_MINI_RING_SIZE; i++) {
+		struct tg3_rx_buffer_desc *rxd;
+
+		rxd = &tp->rx_mini[i];
+		rxd->idx_len = (RX_MINI_PKT_BUF_SZ - tp->rx_offset - 64)
+			<< RXD_LEN_SHIFT;
+		rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT) |
+			RXD_FLAG_MINI;
+		rxd->opaque = (RXD_OPAQUE_RING_MINI |
+			       (i << RXD_OPAQUE_INDEX_SHIFT));
+	}
+#endif
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE) {
+		for (i = 0; i < TG3_RX_JUMBO_RING_SIZE; i++) {
+			struct tg3_rx_buffer_desc *rxd;
+
+			rxd = &tp->rx_jumbo[i];
+			rxd->idx_len = (RX_JUMBO_PKT_BUF_SZ - tp->rx_offset - 64)
+				<< RXD_LEN_SHIFT;
+			rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT) |
+				RXD_FLAG_JUMBO;
+			rxd->opaque = (RXD_OPAQUE_RING_JUMBO |
+			       (i << RXD_OPAQUE_INDEX_SHIFT));
+		}
+	}
+
+	/* Now allocate fresh SKBs for each rx ring. */
+	for (i = 0; i < tp->rx_pending; i++) {
+		if (tg3_alloc_rx_skb(tp, RXD_OPAQUE_RING_STD,
+				     -1, i) < 0)
+			break;
+	}
+
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < tp->rx_mini_pending; i++) {
+		if (tg3_alloc_rx_skb(tp, RXD_OPAQUE_RING_MINI,
+				     -1, i) < 0)
+			break;
+	}
+#endif
+
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE) {
+		for (i = 0; i < tp->rx_jumbo_pending; i++) {
+			if (tg3_alloc_rx_skb(tp, RXD_OPAQUE_RING_JUMBO,
+					     -1, i) < 0)
+				break;
+		}
+	}
+}
+
+/*
+ * Must not be invoked with interrupt sources disabled and
+ * the hardware shutdown down.
+ */
+static void tg3_free_consistent(struct tg3 *tp)
+{
+	if (tp->rx_std_buffers) {
+		kfree(tp->rx_std_buffers);
+		tp->rx_std_buffers = NULL;
+	}
+	if (tp->rx_std) {
+		pci_free_consistent(tp->pdev, TG3_RX_RING_BYTES,
+				    tp->rx_std, tp->rx_std_mapping);
+		tp->rx_std = NULL;
+	}
+#if TG3_MINI_RING_WORKS
+	if (tp->rx_mini) {
+		pci_free_consistent(tp->pdev, TG3_RX_MINI_RING_BYTES,
+				    tp->rx_mini, tp->rx_mini_mapping);
+		tp->rx_mini = NULL;
+	}
+#endif
+	if (tp->rx_jumbo) {
+		pci_free_consistent(tp->pdev, TG3_RX_JUMBO_RING_BYTES,
+				    tp->rx_jumbo, tp->rx_jumbo_mapping);
+		tp->rx_jumbo = NULL;
+	}
+	if (tp->rx_rcb) {
+		pci_free_consistent(tp->pdev, TG3_RX_RCB_RING_BYTES,
+				    tp->rx_rcb, tp->rx_rcb_mapping);
+		tp->rx_rcb = NULL;
+	}
+	if (tp->tx_ring) {
+		pci_free_consistent(tp->pdev, TG3_TX_RING_BYTES,
+			tp->tx_ring, tp->tx_desc_mapping);
+		tp->tx_ring = NULL;
+	}
+	if (tp->hw_status) {
+		pci_free_consistent(tp->pdev, TG3_HW_STATUS_SIZE,
+				    tp->hw_status, tp->status_mapping);
+		tp->hw_status = NULL;
+	}
+	if (tp->hw_stats) {
+		pci_free_consistent(tp->pdev, sizeof(struct tg3_hw_stats),
+				    tp->hw_stats, tp->stats_mapping);
+		tp->hw_stats = NULL;
+	}
+}
+
+/*
+ * Must not be invoked with interrupt sources disabled and
+ * the hardware shutdown down.  Can sleep.
+ */
+static int tg3_alloc_consistent(struct tg3 *tp)
+{
+	tp->rx_std_buffers = kmalloc(sizeof(struct ring_info) *
+				     (TG3_RX_RING_SIZE +
+#if TG3_MINI_RING_WORKS
+				      TG3_RX_MINI_RING_SIZE +
+#endif
+				      TG3_RX_JUMBO_RING_SIZE +
+				      TG3_TX_RING_SIZE),
+				     GFP_KERNEL);
+	if (!tp->rx_std_buffers)
+		return -ENOMEM;
+
+#if TG3_MINI_RING_WORKS
+	memset(tp->rx_std_buffers, 0,
+	       (sizeof(struct ring_info) *
+		(TG3_RX_RING_SIZE +
+		 TG3_RX_MINI_RING_SIZE +
+		 TG3_RX_JUMBO_RING_SIZE +
+		 TG3_TX_RING_SIZE)));
+#else
+	memset(tp->rx_std_buffers, 0,
+	       (sizeof(struct ring_info) *
+		(TG3_RX_RING_SIZE +
+		 TG3_RX_JUMBO_RING_SIZE +
+		 TG3_TX_RING_SIZE)));
+#endif
+
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini_buffers = &tp->rx_std_buffers[TG3_RX_RING_SIZE];
+	tp->rx_jumbo_buffers = &tp->rx_mini_buffers[TG3_RX_MINI_RING_SIZE];
+#else
+	tp->rx_jumbo_buffers = &tp->rx_std_buffers[TG3_RX_RING_SIZE];
+#endif
+	tp->tx_buffers = &tp->rx_jumbo_buffers[TG3_RX_JUMBO_RING_SIZE];
+
+	tp->rx_std = pci_alloc_consistent(tp->pdev, TG3_RX_RING_BYTES,
+					  &tp->rx_std_mapping);
+	if (!tp->rx_std)
+		goto err_out;
+
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini = pci_alloc_consistent(tp->pdev, TG3_RX_MINI_RING_BYTES,
+					   &tp->rx_mini_mapping);
+
+	if (!tp->rx_mini)
+		goto err_out;
+#endif
+
+	tp->rx_jumbo = pci_alloc_consistent(tp->pdev, TG3_RX_JUMBO_RING_BYTES,
+					    &tp->rx_jumbo_mapping);
+
+	if (!tp->rx_jumbo)
+		goto err_out;
+
+	tp->rx_rcb = pci_alloc_consistent(tp->pdev, TG3_RX_RCB_RING_BYTES,
+					  &tp->rx_rcb_mapping);
+	if (!tp->rx_rcb)
+		goto err_out;
+
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tp->tx_ring = pci_alloc_consistent(tp->pdev, TG3_TX_RING_BYTES,
+						   &tp->tx_desc_mapping);
+		if (!tp->tx_ring)
+			goto err_out;
+	} else {
+		tp->tx_ring = NULL;
+		tp->tx_desc_mapping = 0;
+	}
+
+	tp->hw_status = pci_alloc_consistent(tp->pdev,
+					     TG3_HW_STATUS_SIZE,
+					     &tp->status_mapping);
+	if (!tp->hw_status)
+		goto err_out;
+
+	tp->hw_stats = pci_alloc_consistent(tp->pdev,
+					    sizeof(struct tg3_hw_stats),
+					    &tp->stats_mapping);
+	if (!tp->hw_stats)
+		goto err_out;
+
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+	memset(tp->hw_stats, 0, sizeof(struct tg3_hw_stats));
+
+	return 0;
+
+err_out:
+	tg3_free_consistent(tp);
+	return -ENOMEM;
+}
+
+#define MAX_WAIT_CNT 10000
+
+/* To stop a block, clear the enable bit and poll till it
+ * clears.  tp->lock is held.
+ */
+static int tg3_stop_block(struct tg3 *tp, unsigned long ofs, u32 enable_bit)
+{
+	unsigned int i;
+	u32 val;
+
+	val = tr32(ofs);
+	val &= ~enable_bit;
+	tw32(ofs, val);
+
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		val = tr32(ofs);
+
+		if ((val & enable_bit) == 0)
+			break;
+		udelay(100);
+	}
+
+	if (i == MAX_WAIT_CNT) {
+		printk(KERN_ERR PFX "tg3_stop_block timed out, "
+		       "ofs=%lx enable_bit=%x\n",
+		       ofs, enable_bit);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static int tg3_abort_hw(struct tg3 *tp)
+{
+	int i, err;
+
+	tg3_disable_ints(tp);
+
+	tp->rx_mode &= ~RX_MODE_ENABLE;
+	tw32(MAC_RX_MODE, tp->rx_mode);
+
+	err  = tg3_stop_block(tp, RCVBDI_MODE, RCVBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLPC_MODE, RCVLPC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLSC_MODE, RCVLSC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDBDI_MODE, RCVDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDCC_MODE, RCVDCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVCC_MODE, RCVCC_MODE_ENABLE);
+
+	err |= tg3_stop_block(tp, SNDBDS_MODE, SNDBDS_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDI_MODE, SNDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RDMAC_MODE, RDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDC_MODE, SNDBDC_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	tp->mac_mode &= ~MAC_MODE_TDE_ENABLE;
+	tw32(MAC_MODE, tp->mac_mode);
+
+	tp->tx_mode &= ~TX_MODE_ENABLE;
+	tw32(MAC_TX_MODE, tp->tx_mode);
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		udelay(100);
+		if (!(tr32(MAC_TX_MODE) & TX_MODE_ENABLE))
+			break;
+	}
+	if (i >= MAX_WAIT_CNT) {
+		printk(KERN_ERR PFX "tg3_abort_hw timed out for %s, "
+		       "TX_MODE_ENABLE will not clear MAC_TX_MODE=%08x\n",
+		       tp->dev->name, tr32(MAC_TX_MODE));
+		return -ENODEV;
+	}
+
+	err  = tg3_stop_block(tp, HOSTCC_MODE, HOSTCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, WDMAC_MODE, WDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MBFREE_MODE, MBFREE_MODE_ENABLE);
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+
+	err |= tg3_stop_block(tp, BUFMGR_MODE, BUFMGR_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MEMARB_MODE, MEMARB_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+
+out:
+	return err;
+}
+
+/* tp->lock is held. */
+static void tg3_chip_reset(struct tg3 *tp)
+{
+	u32 val;
+
+	/* Force NVRAM to settle.
+	 * This deals with a chip bug which can result in EEPROM
+	 * corruption.
+	 */
+	if (tp->tg3_flags & TG3_FLAG_NVRAM) {
+		int i;
+
+		tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+		for (i = 0; i < 100000; i++) {
+			if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+				break;
+			udelay(10);
+		}
+	}
+
+	tw32(GRC_MISC_CFG, GRC_MISC_CFG_CORECLK_RESET);
+	udelay(40);
+	udelay(40);
+	udelay(40);
+
+	/* Re-enable indirect register accesses. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	/* Set MAX PCI retry to zero. */
+	pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE,
+			       (PCISTATE_ROM_ENABLE |
+				PCISTATE_ROM_RETRY_ENABLE));
+
+	pci_restore_state(tp->pdev, tp->pci_cfg_state);
+
+	/* Make sure PCI-X relaxed ordering bit is clear. */
+	pci_read_config_dword(tp->pdev, TG3PCI_X_CAPS, &val);
+	val &= ~PCIX_CAPS_RELAXED_ORDERING;
+	pci_write_config_dword(tp->pdev, TG3PCI_X_CAPS, val);
+
+	tw32(MEMARB_MODE, MEMARB_MODE_ENABLE);
+
+	tw32(TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+}
+
+/* tp->lock is held. */
+static int tg3_halt(struct tg3 *tp)
+{
+	u32 val;
+	int i;
+
+	tg3_abort_hw(tp);
+	tg3_chip_reset(tp);
+	tg3_write_mem(tp,
+		      NIC_SRAM_FIRMWARE_MBOX,
+		      NIC_SRAM_FIRMWARE_MBOX_MAGIC1);
+	for (i = 0; i < 100000; i++) {
+		tg3_read_mem(tp, NIC_SRAM_FIRMWARE_MBOX, &val);
+		if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+			break;
+		udelay(10);
+	}
+
+	if (i >= 100000) {
+		printk(KERN_ERR PFX "tg3_halt timed out for %s, "
+		       "firmware will not restart magic=%08x\n",
+		       tp->dev->name, val);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+#define TG3_FW_RELEASE_MAJOR	0x0
+#define TG3_FW_RELASE_MINOR	0x0
+#define TG3_FW_RELEASE_FIX	0x0
+#define TG3_FW_START_ADDR	0x08000000
+#define TG3_FW_TEXT_ADDR	0x08000000
+#define TG3_FW_TEXT_LEN		0x9c0
+#define TG3_FW_RODATA_ADDR	0x080009c0
+#define TG3_FW_RODATA_LEN	0x60
+#define TG3_FW_DATA_ADDR	0x08000a40
+#define TG3_FW_DATA_LEN		0x20
+#define TG3_FW_SBSS_ADDR	0x08000a60
+#define TG3_FW_SBSS_LEN		0xc
+#define TG3_FW_BSS_ADDR		0x08000a70
+#define TG3_FW_BSS_LEN		0x10
+
+static u32 t3FwText[(TG3_FW_TEXT_LEN / sizeof(u32)) + 1] = {
+	0x00000000, 0x10000003, 0x00000000, 0x0000000d, 0x0000000d, 0x3c1d0800,
+	0x37bd3ffc, 0x03a0f021, 0x3c100800, 0x26100000, 0x0e000018, 0x00000000,
+	0x0000000d, 0x3c1d0800, 0x37bd3ffc, 0x03a0f021, 0x3c100800, 0x26100034,
+	0x0e00021c, 0x00000000, 0x0000000d, 0x00000000, 0x00000000, 0x00000000,
+	0x27bdffe0, 0x3c1cc000, 0xafbf0018, 0xaf80680c, 0x0e00004c, 0x241b2105,
+	0x97850000, 0x97870002, 0x9782002c, 0x9783002e, 0x3c040800, 0x248409c0,
+	0xafa00014, 0x00021400, 0x00621825, 0x00052c00, 0xafa30010, 0x8f860010,
+	0x00e52825, 0x0e000060, 0x24070102, 0x3c02ac00, 0x34420100, 0x3c03ac01,
+	0x34630100, 0xaf820490, 0x3c02ffff, 0xaf820494, 0xaf830498, 0xaf82049c,
+	0x24020001, 0xaf825ce0, 0x0e00003f, 0xaf825d00, 0x0e000140, 0x00000000,
+	0x8fbf0018, 0x03e00008, 0x27bd0020, 0x2402ffff, 0xaf825404, 0x8f835400,
+	0x34630400, 0xaf835400, 0xaf825404, 0x3c020800, 0x24420034, 0xaf82541c,
+	0x03e00008, 0xaf805400, 0x00000000, 0x00000000, 0x3c020800, 0x34423000,
+	0x3c030800, 0x34633000, 0x3c040800, 0x348437ff, 0x3c010800, 0xac220a64,
+	0x24020040, 0x3c010800, 0xac220a68, 0x3c010800, 0xac200a60, 0xac600000,
+	0x24630004, 0x0083102b, 0x5040fffd, 0xac600000, 0x03e00008, 0x00000000,
+	0x00804821, 0x8faa0010, 0x3c020800, 0x8c420a60, 0x3c040800, 0x8c840a68,
+	0x8fab0014, 0x24430001, 0x0044102b, 0x3c010800, 0xac230a60, 0x14400003,
+	0x00004021, 0x3c010800, 0xac200a60, 0x3c020800, 0x8c420a60, 0x3c030800,
+	0x8c630a64, 0x91240000, 0x00021140, 0x00431021, 0x00481021, 0x25080001,
+	0xa0440000, 0x29020008, 0x1440fff4, 0x25290001, 0x3c020800, 0x8c420a60,
+	0x3c030800, 0x8c630a64, 0x8f84680c, 0x00021140, 0x00431021, 0xac440008,
+	0xac45000c, 0xac460010, 0xac470014, 0xac4a0018, 0x03e00008, 0xac4b001c,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0,
+	0x02000008, 0x00000000, 0x0a0001e3, 0x3c0a0001, 0x0a0001e3, 0x3c0a0002,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x3c0a0007, 0x0a0001e3, 0x3c0a0008, 0x0a0001e3, 0x3c0a0009,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x3c0a000b,
+	0x0a0001e3, 0x3c0a000c, 0x0a0001e3, 0x3c0a000d, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x3c0a000e, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000, 0x0a0001e3, 0x00000000,
+	0x0a0001e3, 0x00000000, 0x0a0001e3, 0x3c0a0013, 0x0a0001e3, 0x3c0a0014,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0x27bdffe0, 0x00001821, 0x00001021, 0xafbf0018, 0xafb10014, 0xafb00010,
+	0x3c010800, 0x00220821, 0xac200a70, 0x3c010800, 0x00220821, 0xac200a74,
+	0x3c010800, 0x00220821, 0xac200a78, 0x24630001, 0x1860fff5, 0x2442000c,
+	0x24110001, 0x8f906810, 0x32020004, 0x14400005, 0x24040001, 0x3c020800,
+	0x8c420a78, 0x18400003, 0x00002021, 0x0e000182, 0x00000000, 0x32020001,
+	0x10400003, 0x00000000, 0x0e000169, 0x00000000, 0x0a000153, 0xaf915028,
+	0x8fbf0018, 0x8fb10014, 0x8fb00010, 0x03e00008, 0x27bd0020, 0x3c050800,
+	0x8ca50a70, 0x3c060800, 0x8cc60a80, 0x3c070800, 0x8ce70a78, 0x27bdffe0,
+	0x3c040800, 0x248409d0, 0xafbf0018, 0xafa00010, 0x0e000060, 0xafa00014,
+	0x0e00017b, 0x00002021, 0x8fbf0018, 0x03e00008, 0x27bd0020, 0x24020001,
+	0x8f836810, 0x00821004, 0x00021027, 0x00621824, 0x03e00008, 0xaf836810,
+	0x27bdffd8, 0xafbf0024, 0x1080002e, 0xafb00020, 0x8f825cec, 0xafa20018,
+	0x8f825cec, 0x3c100800, 0x26100a78, 0xafa2001c, 0x34028000, 0xaf825cec,
+	0x8e020000, 0x18400016, 0x00000000, 0x3c020800, 0x94420a74, 0x8fa3001c,
+	0x000221c0, 0xac830004, 0x8fa2001c, 0x3c010800, 0x0e000201, 0xac220a74,
+	0x10400005, 0x00000000, 0x8e020000, 0x24420001, 0x0a0001df, 0xae020000,
+	0x3c020800, 0x8c420a70, 0x00021c02, 0x000321c0, 0x0a0001c5, 0xafa2001c,
+	0x0e000201, 0x00000000, 0x1040001f, 0x00000000, 0x8e020000, 0x8fa3001c,
+	0x24420001, 0x3c010800, 0xac230a70, 0x3c010800, 0xac230a74, 0x0a0001df,
+	0xae020000, 0x3c100800, 0x26100a78, 0x8e020000, 0x18400028, 0x00000000,
+	0x0e000201, 0x00000000, 0x14400024, 0x00000000, 0x8e020000, 0x3c030800,
+	0x8c630a70, 0x2442ffff, 0xafa3001c, 0x18400006, 0xae020000, 0x00031402,
+	0x000221c0, 0x8c820004, 0x3c010800, 0xac220a70, 0x97a2001e, 0x2442ff00,
+	0x2c420300, 0x1440000b, 0x24024000, 0x3c040800, 0x248409dc, 0xafa00010,
+	0xafa00014, 0x8fa6001c, 0x24050008, 0x0e000060, 0x00003821, 0x0a0001df,
+	0x00000000, 0xaf825cf8, 0x3c020800, 0x8c420a40, 0x8fa3001c, 0x24420001,
+	0xaf835cf8, 0x3c010800, 0xac220a40, 0x8fbf0024, 0x8fb00020, 0x03e00008,
+	0x27bd0028, 0x27bdffe0, 0x3c040800, 0x248409e8, 0x00002821, 0x00003021,
+	0x00003821, 0xafbf0018, 0xafa00010, 0x0e000060, 0xafa00014, 0x8fbf0018,
+	0x03e00008, 0x27bd0020, 0x8f82680c, 0x8f85680c, 0x00021827, 0x0003182b,
+	0x00031823, 0x00431024, 0x00441021, 0x00a2282b, 0x10a00006, 0x00000000,
+	0x00401821, 0x8f82680c, 0x0043102b, 0x1440fffd, 0x00000000, 0x03e00008,
+	0x00000000, 0x3c040800, 0x8c840000, 0x3c030800, 0x8c630a40, 0x0064102b,
+	0x54400002, 0x00831023, 0x00641023, 0x2c420008, 0x03e00008, 0x38420001,
+	0x27bdffe0, 0x00802821, 0x3c040800, 0x24840a00, 0x00003021, 0x00003821,
+	0xafbf0018, 0xafa00010, 0x0e000060, 0xafa00014, 0x0a000216, 0x00000000,
+	0x8fbf0018, 0x03e00008, 0x27bd0020, 0x00000000, 0x27bdffe0, 0x3c1cc000,
+	0xafbf0018, 0x0e00004c, 0xaf80680c, 0x3c040800, 0x24840a10, 0x03802821,
+	0x00003021, 0x00003821, 0xafa00010, 0x0e000060, 0xafa00014, 0x2402ffff,
+	0xaf825404, 0x3c0200aa, 0x0e000234, 0xaf825434, 0x8fbf0018, 0x03e00008,
+	0x27bd0020, 0x00000000, 0x00000000, 0x00000000, 0x27bdffe8, 0xafb00010,
+	0x24100001, 0xafbf0014, 0x3c01c003, 0xac200000, 0x8f826810, 0x30422000,
+	0x10400003, 0x00000000, 0x0e000246, 0x00000000, 0x0a00023a, 0xaf905428,
+	0x8fbf0014, 0x8fb00010, 0x03e00008, 0x27bd0018, 0x27bdfff8, 0x8f845d0c,
+	0x3c0200ff, 0x3c030800, 0x8c630a50, 0x3442fff8, 0x00821024, 0x1043001e,
+	0x3c0500ff, 0x34a5fff8, 0x3c06c003, 0x3c074000, 0x00851824, 0x8c620010,
+	0x3c010800, 0xac230a50, 0x30420008, 0x10400005, 0x00871025, 0x8cc20000,
+	0x24420001, 0xacc20000, 0x00871025, 0xaf825d0c, 0x8fa20000, 0x24420001,
+	0xafa20000, 0x8fa20000, 0x8fa20000, 0x24420001, 0xafa20000, 0x8fa20000,
+	0x8f845d0c, 0x3c030800, 0x8c630a50, 0x00851024, 0x1443ffe8, 0x00851824,
+	0x27bd0008, 0x03e00008, 0x00000000, 0x00000000, 0x00000000
+};
+
+static u32 t3FwRodata[(TG3_FW_RODATA_LEN / sizeof(u32)) + 1] = {
+	0x35373031, 0x726c7341, 0x00000000, 0x00000000, 0x53774576, 0x656e7430,
+	0x00000000, 0x726c7045, 0x76656e74, 0x31000000, 0x556e6b6e, 0x45766e74,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x66617461, 0x6c457272,
+	0x00000000, 0x00000000, 0x4d61696e, 0x43707542, 0x00000000, 0x00000000,
+	0x00000000
+};
+
+#if 0 /* All zeros, dont eat up space with it. */
+u32 t3FwData[(TG3_FW_DATA_LEN / sizeof(u32)) + 1] = {
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
+#endif
+
+#define RX_CPU_SCRATCH_BASE	0x30000
+#define RX_CPU_SCRATCH_SIZE	0x04000
+#define TX_CPU_SCRATCH_BASE	0x34000
+#define TX_CPU_SCRATCH_SIZE	0x04000
+
+/* tp->lock is held. */
+static int tg3_reset_cpu(struct tg3 *tp, u32 offset)
+{
+	int i;
+
+	tw32(offset + CPU_STATE, 0xffffffff);
+	tw32(offset + CPU_MODE,  CPU_MODE_RESET);
+	if (offset == RX_CPU_BASE) {
+		for (i = 0; i < 10000; i++)
+			if (!(tr32(offset + CPU_MODE) & CPU_MODE_RESET))
+				break;
+		tw32(offset + CPU_STATE, 0xffffffff);
+		tw32(offset + CPU_MODE,  CPU_MODE_RESET);
+		udelay(10);
+	} else {
+		for (i = 0; i < 10000; i++) {
+			if (!(tr32(offset + CPU_MODE) & CPU_MODE_RESET))
+				break;
+			tw32(offset + CPU_STATE, 0xffffffff);
+			tw32(offset + CPU_MODE,  CPU_MODE_RESET);
+			udelay(10);
+		}
+	}
+
+	if (i >= 10000) {
+		printk(KERN_ERR PFX "tg3_reset_cpu timed out for %s, "
+		       "and %s CPU\n",
+		       tp->dev->name,
+		       (offset == RX_CPU_BASE ? "RX" : "TX"));
+		return -ENODEV;
+	}
+	return 0;
+}
+
+/* tp->lock is held. */
+static int tg3_load_firmware_cpu(struct tg3 *tp, u32 cpu_base, u32 cpu_scratch_base,
+				 int cpu_scratch_size)
+{
+	int err, i;
+
+	err = tg3_reset_cpu(tp, cpu_base);
+	if (err)
+		return err;
+
+	for (i = 0; i < cpu_scratch_size; i += sizeof(u32))
+		tg3_write_indirect_reg32(tp, cpu_scratch_base + i, 0);
+	tw32(cpu_base + CPU_STATE, 0xffffffff);
+	tw32(cpu_base + CPU_MODE, tr32(cpu_base+CPU_MODE)|CPU_MODE_HALT);
+	for (i = 0; i < (TG3_FW_TEXT_LEN / sizeof(u32)); i++)
+		tg3_write_indirect_reg32(tp, (cpu_scratch_base +
+					      (TG3_FW_TEXT_ADDR & 0xffff) +
+					      (i * sizeof(u32))),
+					 t3FwText[i]);
+	for (i = 0; i < (TG3_FW_RODATA_LEN / sizeof(u32)); i++)
+		tg3_write_indirect_reg32(tp, (cpu_scratch_base +
+					      (TG3_FW_RODATA_ADDR & 0xffff) +
+					      (i * sizeof(u32))),
+					 t3FwRodata[i]);
+	for (i = 0; i < (TG3_FW_DATA_LEN / sizeof(u32)); i++)
+		tg3_write_indirect_reg32(tp, (cpu_scratch_base +
+					      (TG3_FW_DATA_ADDR & 0xffff) +
+					      (i * sizeof(u32))),
+					 0);
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static int tg3_load_5701_a0_firmware_fix(struct tg3 *tp)
+{
+	int err, i;
+
+	err = tg3_load_firmware_cpu(tp, RX_CPU_BASE,
+				    RX_CPU_SCRATCH_BASE, RX_CPU_SCRATCH_SIZE);
+	if (err)
+		return err;
+
+	err = tg3_load_firmware_cpu(tp, TX_CPU_BASE,
+				    TX_CPU_SCRATCH_BASE, TX_CPU_SCRATCH_SIZE);
+	if (err)
+		return err;
+
+	/* Now startup only the RX cpu. */
+	for (i = 0; i < 5; i++) {
+		tw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);
+		tw32(RX_CPU_BASE + CPU_MODE,  CPU_MODE_HALT);
+		tw32(RX_CPU_BASE + CPU_PC,    TG3_FW_TEXT_ADDR);
+		tr32(RX_CPU_BASE + CPU_PC);	/* flush writes -ggg */
+		udelay(1000);
+		if (tr32(RX_CPU_BASE + CPU_PC) == TG3_FW_TEXT_ADDR)
+			break;
+	}
+	if (i >= 5) {
+		printk(KERN_ERR PFX "tg3_load_firmware fails for %s "
+		       "to set RX CPU PC, is %08x should be %08x\n",
+		       tp->dev->name, tr32(RX_CPU_BASE + CPU_PC),
+		       TG3_FW_TEXT_ADDR);
+		return -ENODEV;
+	}
+	tw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);
+	tw32(RX_CPU_BASE + CPU_MODE,  0x00000000);
+	tr32(RX_CPU_BASE + CPU_MODE);	/* flush writes -ggg */
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static void __tg3_set_mac_addr(struct tg3 *tp)
+{
+	u32 addr_high, addr_low;
+	int i;
+
+	addr_high = ((tp->dev->dev_addr[0] << 8) |
+		     tp->dev->dev_addr[1]);
+	addr_low = ((tp->dev->dev_addr[2] << 24) |
+		    (tp->dev->dev_addr[3] << 16) |
+		    (tp->dev->dev_addr[4] <<  8) |
+		    (tp->dev->dev_addr[5] <<  0));
+	for (i = 0; i < 4; i++) {
+		tw32(MAC_ADDR_0_HIGH + (i * 8), addr_high);
+		tw32(MAC_ADDR_0_LOW + (i * 8), addr_low);
+	}
+
+	addr_high = (tp->dev->dev_addr[0] +
+		     tp->dev->dev_addr[1] +
+		     tp->dev->dev_addr[2] +
+		     tp->dev->dev_addr[3] +
+		     tp->dev->dev_addr[4] +
+		     tp->dev->dev_addr[5]) &
+		TX_BACKOFF_SEED_MASK;
+	tw32(MAC_TX_BACKOFF_SEED, addr_high);
+}
+
+static int tg3_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct tg3 *tp = dev->priv;
+	struct sockaddr *addr = p;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	spin_lock_irq(&tp->lock);
+	__tg3_set_mac_addr(tp);
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+/* tp->lock is held. */
+static void tg3_set_bdinfo(struct tg3 *tp, u32 bdinfo_addr,
+			   dma_addr_t mapping, u32 maxlen_flags,
+			   u32 nic_addr)
+{
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR +
+		       TG3_64BIT_REG_HIGH),
+		      ((u64) mapping >> 32));
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR +
+		       TG3_64BIT_REG_LOW),
+		      ((u64) mapping & 0xffffffff));
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_MAXLEN_FLAGS),
+		       maxlen_flags);
+	tg3_write_mem(tp,
+		      (bdinfo_addr +
+		       TG3_BDINFO_NIC_ADDR),
+		      nic_addr);
+}
+
+static void __tg3_set_rx_mode(struct net_device *);
+
+/* tp->lock is held. */
+static int tg3_reset_hw(struct tg3 *tp)
+{
+	u32 val;
+	int i, err;
+
+	tg3_disable_ints(tp);
+
+	if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) {
+		err = tg3_abort_hw(tp);
+		if (err)
+			return err;
+	}
+
+	tg3_chip_reset(tp);
+
+	tw32(GRC_MODE, tp->grc_mode);
+	tg3_write_mem(tp,
+		      NIC_SRAM_FIRMWARE_MBOX,
+		      NIC_SRAM_FIRMWARE_MBOX_MAGIC1);
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->mac_mode = MAC_MODE_PORT_MODE_TBI;
+		tw32(MAC_MODE, tp->mac_mode);
+	} else
+		tw32(MAC_MODE, 0);
+
+	/* Wait for firmware initialization to complete. */
+	for (i = 0; i < 100000; i++) {
+		tg3_read_mem(tp, NIC_SRAM_FIRMWARE_MBOX, &val);
+		if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+			break;
+		udelay(10);
+	}
+	if (i >= 100000) {
+		printk(KERN_ERR PFX "tg3_reset_hw timed out for %s, "
+		       "firmware will not restart magic=%08x\n",
+		       tp->dev->name, val);
+		return -ENODEV;
+	}
+
+	/* This works around an issue with Athlon chipsets on
+	 * B3 tigon3 silicon.  This bit has no effect on any
+	 * other revision.
+	 */
+	val = tr32(TG3PCI_CLOCK_CTRL);
+	val |= CLOCK_CTRL_DELAY_PCI_GRANT;
+	tw32(TG3PCI_CLOCK_CTRL, val);
+
+	/* Clear statistics/status block in chip, and status block in ram. */
+	for (i = NIC_SRAM_STATS_BLK;
+	     i < NIC_SRAM_STATUS_BLK + TG3_HW_STATUS_SIZE;
+	     i += sizeof(u32))
+		tg3_write_mem(tp, i, 0);
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+
+	/* This value is determined during the probe time DMA
+	 * engine test, tg3_test_dma.
+	 */
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	tp->grc_mode &= ~(GRC_MODE_HOST_SENDBDS |
+			  GRC_MODE_4X_NIC_SEND_RINGS |
+			  GRC_MODE_NO_TX_PHDR_CSUM |
+			  GRC_MODE_NO_RX_PHDR_CSUM);
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS)
+		tp->grc_mode |= GRC_MODE_HOST_SENDBDS;
+	else
+		tp->grc_mode |= GRC_MODE_4X_NIC_SEND_RINGS;
+	if (tp->tg3_flags & TG3_FLAG_NO_TX_PSEUDO_CSUM)
+		tp->grc_mode |= GRC_MODE_NO_TX_PHDR_CSUM;
+	if (tp->tg3_flags & TG3_FLAG_NO_RX_PSEUDO_CSUM)
+		tp->grc_mode |= GRC_MODE_NO_RX_PHDR_CSUM;
+
+	tw32(GRC_MODE,
+	     tp->grc_mode |
+	     (GRC_MODE_IRQ_ON_MAC_ATTN | GRC_MODE_HOST_STACKUP));
+
+	/* Setup the timer prescalar register.  Clock is always 66Mhz. */
+	tw32(GRC_MISC_CFG,
+	     (65 << GRC_MISC_CFG_PRESCALAR_SHIFT));
+
+	/* Initialize MBUF/DESC pool. */
+	tw32(BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE);
+	tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE);
+	tw32(BUFMGR_DMA_DESC_POOL_ADDR, NIC_SRAM_DMA_DESC_POOL_BASE);
+	tw32(BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE);
+
+	if (!(tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE)) {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water);
+	} else {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water_jumbo);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water_jumbo);
+	}
+	tw32(BUFMGR_DMA_LOW_WATER,
+	     tp->bufmgr_config.dma_low_water);
+	tw32(BUFMGR_DMA_HIGH_WATER,
+	     tp->bufmgr_config.dma_high_water);
+
+	tw32(BUFMGR_MODE, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(BUFMGR_MODE) & BUFMGR_MODE_ENABLE)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printk(KERN_ERR PFX "tg3_reset_hw cannot enable BUFMGR for %s.\n",
+		       tp->dev->name);
+		return -ENODEV;
+	}
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(FTQ_RESET) == 0x00000000)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printk(KERN_ERR PFX "tg3_reset_hw cannot reset FTQ for %s.\n",
+		       tp->dev->name);
+		return -ENODEV;
+	}
+
+	/* Initialize TG3_BDINFO's at:
+	 *  RCVDBDI_STD_BD:	standard eth size rx ring
+	 *  RCVDBDI_JUMBO_BD:	jumbo frame rx ring
+	 *  RCVDBDI_MINI_BD:	small frame rx ring (??? does not work)
+	 *
+	 * like so:
+	 *  TG3_BDINFO_HOST_ADDR:	high/low parts of DMA address of ring
+	 *  TG3_BDINFO_MAXLEN_FLAGS:	(rx max buffer size << 16) |
+	 *                              ring attribute flags
+	 *  TG3_BDINFO_NIC_ADDR:	location of descriptors in nic SRAM
+	 *
+	 * Standard receive ring @ NIC_SRAM_RX_BUFFER_DESC, 512 entries.
+	 * Jumbo receive ring @ NIC_SRAM_RX_JUMBO_BUFFER_DESC, 256 entries.
+	 *
+	 * ??? No space allocated for mini receive ring? :(
+	 *
+	 * The size of each ring is fixed in the firmware, but the location is
+	 * configurable.
+	 */
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->rx_std_mapping >> 32));
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->rx_std_mapping & 0xffffffff));
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS,
+	     RX_STD_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT);
+	tw32(RCVDBDI_STD_BD + TG3_BDINFO_NIC_ADDR,
+	     NIC_SRAM_RX_BUFFER_DESC);
+
+#if TG3_MINI_RING_WORKS
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->rx_mini_mapping >> 32));
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->rx_mini_mapping & 0xffffffff));
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,
+	     RX_MINI_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT);
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_NIC_ADDR,
+	     NIC_SRAM_RX_MINI_BUFFER_DESC);
+#else
+	tw32(RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,
+	     BDINFO_FLAGS_DISABLED);
+#endif
+
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE) {
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,
+		     ((u64) tp->rx_jumbo_mapping >> 32));
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,
+		     ((u64) tp->rx_jumbo_mapping & 0xffffffff));
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,
+		     RX_JUMBO_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT);
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_NIC_ADDR,
+		     NIC_SRAM_RX_JUMBO_BUFFER_DESC);
+	} else {
+		tw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,
+		     BDINFO_FLAGS_DISABLED);
+	}
+
+	/* Setup replenish thresholds. */
+	tw32(RCVBDI_STD_THRESH, tp->rx_pending / 8);
+#if TG3_MINI_RING_WORKS
+	tw32(RCVBDI_MINI_THRESH, tp->rx_mini_pending / 8);
+#endif
+	tw32(RCVBDI_JUMBO_THRESH, tp->rx_jumbo_pending / 8);
+
+	/* Clear out send RCB ring in SRAM. */
+	for (i = NIC_SRAM_SEND_RCB; i < NIC_SRAM_RCV_RET_RCB; i += TG3_BDINFO_SIZE)
+		tg3_write_mem(tp, i + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED);
+
+	tp->tx_prod = 0;
+	tp->tx_cons = 0;
+	tw32_mailbox(MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+	tw32_mailbox(MAILBOX_SNDNIC_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	if (tp->tg3_flags & TG3_FLAG_HOST_TXDS) {
+		tg3_set_bdinfo(tp, NIC_SRAM_SEND_RCB,
+			       tp->tx_desc_mapping,
+			       (TG3_TX_RING_SIZE <<
+				BDINFO_FLAGS_MAXLEN_SHIFT),
+			       NIC_SRAM_TX_BUFFER_DESC);
+	} else {
+		tg3_set_bdinfo(tp, NIC_SRAM_SEND_RCB,
+			       0,
+			       BDINFO_FLAGS_DISABLED,
+			       NIC_SRAM_TX_BUFFER_DESC);
+	}
+
+	for (i = NIC_SRAM_RCV_RET_RCB; i < NIC_SRAM_STATS_BLK; i += TG3_BDINFO_SIZE) {
+		tg3_write_mem(tp, i + TG3_BDINFO_MAXLEN_FLAGS,
+			      BDINFO_FLAGS_DISABLED);
+	}
+
+	tp->rx_rcb_ptr = 0;
+	tw32_mailbox(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	tg3_set_bdinfo(tp, NIC_SRAM_RCV_RET_RCB,
+		       tp->rx_rcb_mapping,
+		       (TG3_RX_RCB_RING_SIZE <<
+			BDINFO_FLAGS_MAXLEN_SHIFT),
+		       0);
+
+	tp->rx_std_ptr = tp->rx_pending;
+	tw32_mailbox(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_std_ptr);
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini_ptr = tp->rx_mini_pending;
+	tw32_mailbox(MAILBOX_RCV_MINI_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_mini_ptr);
+#endif
+
+	if (tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE)
+		tp->rx_jumbo_ptr = tp->rx_jumbo_pending;
+	else
+		tp->rx_jumbo_ptr = 0;
+	tw32_mailbox(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_jumbo_ptr);
+
+	/* Initialize MAC address and backoff seed. */
+	__tg3_set_mac_addr(tp);
+
+	/* MTU + ethernet header + FCS + optional VLAN tag */
+	tw32(MAC_RX_MTU_SIZE, tp->dev->mtu + ETH_HLEN + 8);
+
+	/* The slot time is changed by tg3_setup_phy if we
+	 * run at gigabit with half duplex.
+	 */
+	tw32(MAC_TX_LENGTHS,
+	     (2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+	     (6 << TX_LENGTHS_IPG_SHIFT) |
+	     (32 << TX_LENGTHS_SLOT_TIME_SHIFT));
+
+	/* Receive rules. */
+	tw32(MAC_RCV_RULE_CFG, RCV_RULE_CFG_DEFAULT_CLASS);
+	tw32(RCVLPC_CONFIG, 0x0181);
+
+	/* Receive/send statistics. */
+	tw32(RCVLPC_STATS_ENABLE, 0xffffff);
+	tw32(RCVLPC_STATSCTRL, RCVLPC_STATSCTRL_ENABLE);
+	tw32(SNDDATAI_STATSENAB, 0xffffff);
+	tw32(SNDDATAI_STATSCTRL,
+	     (SNDDATAI_SCTRL_ENABLE |
+	      SNDDATAI_SCTRL_FASTUPD));
+
+	/* Setup host coalescing engine. */
+	tw32(HOSTCC_MODE, 0);
+	for (i = 0; i < 2000; i++) {
+		if (!(tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE))
+			break;
+		udelay(10);
+	}
+
+	tw32(HOSTCC_RXCOL_TICKS,
+	     tp->coalesce_config.rx_coalesce_ticks);
+	tw32(HOSTCC_RXMAX_FRAMES,
+	     tp->coalesce_config.rx_max_coalesced_frames);
+	tw32(HOSTCC_RXCOAL_TICK_INT,
+	     tp->coalesce_config.rx_coalesce_ticks_during_int);
+	tw32(HOSTCC_RXCOAL_MAXF_INT,
+	     tp->coalesce_config.rx_max_coalesced_frames_during_int);
+	tw32(HOSTCC_TXCOL_TICKS,
+	     tp->coalesce_config.tx_coalesce_ticks);
+	tw32(HOSTCC_TXMAX_FRAMES,
+	     tp->coalesce_config.tx_max_coalesced_frames);
+	tw32(HOSTCC_TXCOAL_TICK_INT,
+	     tp->coalesce_config.tx_coalesce_ticks_during_int);
+	tw32(HOSTCC_TXCOAL_MAXF_INT,
+	     tp->coalesce_config.tx_max_coalesced_frames_during_int);
+	tw32(HOSTCC_STAT_COAL_TICKS,
+	     tp->coalesce_config.stats_coalesce_ticks);
+
+	/* Status/statistics block address. */
+	tw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->stats_mapping >> 32));
+	tw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->stats_mapping & 0xffffffff));
+	tw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,
+	     ((u64) tp->status_mapping >> 32));
+	tw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+	     ((u64) tp->status_mapping & 0xffffffff));
+	tw32(HOSTCC_STATS_BLK_NIC_ADDR, NIC_SRAM_STATS_BLK);
+	tw32(HOSTCC_STATUS_BLK_NIC_ADDR, NIC_SRAM_STATUS_BLK);
+
+	tw32(HOSTCC_MODE, HOSTCC_MODE_ENABLE | tp->coalesce_mode);
+
+	tw32(RCVCC_MODE, RCVCC_MODE_ENABLE | RCVCC_MODE_ATTN_ENABLE);
+	tw32(RCVLPC_MODE, RCVLPC_MODE_ENABLE);
+	tw32(RCVLSC_MODE, RCVLSC_MODE_ENABLE | RCVLSC_MODE_ATTN_ENABLE);
+
+	tp->mac_mode = MAC_MODE_TXSTAT_ENABLE | MAC_MODE_RXSTAT_ENABLE |
+		MAC_MODE_TDE_ENABLE | MAC_MODE_RDE_ENABLE | MAC_MODE_FHDE_ENABLE;
+	tw32(MAC_MODE, tp->mac_mode | MAC_MODE_RXSTAT_CLEAR | MAC_MODE_TXSTAT_CLEAR);
+
+	tp->grc_local_ctrl = GRC_LCLCTRL_INT_ON_ATTN | GRC_LCLCTRL_GPIO_OE1 |
+		GRC_LCLCTRL_GPIO_OUTPUT1 | GRC_LCLCTRL_AUTO_SEEPROM;
+	tw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0);
+
+	tw32(DMAC_MODE, DMAC_MODE_ENABLE);
+
+	tw32(WDMAC_MODE, (WDMAC_MODE_ENABLE | WDMAC_MODE_TGTABORT_ENAB |
+			  WDMAC_MODE_MSTABORT_ENAB | WDMAC_MODE_PARITYERR_ENAB |
+			  WDMAC_MODE_ADDROFLOW_ENAB | WDMAC_MODE_FIFOOFLOW_ENAB |
+			  WDMAC_MODE_FIFOURUN_ENAB | WDMAC_MODE_FIFOOREAD_ENAB |
+			  WDMAC_MODE_LNGREAD_ENAB));
+	tw32(RDMAC_MODE, (RDMAC_MODE_ENABLE | RDMAC_MODE_TGTABORT_ENAB |
+			  RDMAC_MODE_MSTABORT_ENAB | RDMAC_MODE_PARITYERR_ENAB |
+			  RDMAC_MODE_ADDROFLOW_ENAB | RDMAC_MODE_FIFOOFLOW_ENAB |
+			  RDMAC_MODE_FIFOURUN_ENAB | RDMAC_MODE_FIFOOREAD_ENAB |
+			  RDMAC_MODE_LNGREAD_ENAB));
+
+	tw32(RCVDCC_MODE, RCVDCC_MODE_ENABLE | RCVDCC_MODE_ATTN_ENABLE);
+	tw32(MBFREE_MODE, MBFREE_MODE_ENABLE);
+	tw32(SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);
+	tw32(SNDBDC_MODE, SNDBDC_MODE_ENABLE | SNDBDC_MODE_ATTN_ENABLE);
+	tw32(RCVBDI_MODE, RCVBDI_MODE_ENABLE | RCVBDI_MODE_RCB_ATTN_ENAB);
+	tw32(RCVDBDI_MODE, RCVDBDI_MODE_ENABLE | RCVDBDI_MODE_INV_RING_SZ);
+	tw32(SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);
+	tw32(SNDBDI_MODE, SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE);
+	tw32(SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0) {
+		err = tg3_load_5701_a0_firmware_fix(tp);
+		if (err)
+			return err;
+	}
+
+	tp->tx_mode = TX_MODE_ENABLE;
+	tw32(MAC_TX_MODE, tp->tx_mode);
+	tp->rx_mode = RX_MODE_ENABLE;
+	tw32(MAC_RX_MODE, tp->rx_mode);
+
+	if (tp->link_config.phy_is_low_power) {
+		tp->link_config.phy_is_low_power = 0;
+		tp->link_config.speed = tp->link_config.orig_speed;
+		tp->link_config.duplex = tp->link_config.orig_duplex;
+		tp->link_config.autoneg = tp->link_config.orig_autoneg;
+	}
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32(MAC_MI_MODE, tp->mi_mode);
+	tw32(MAC_LED_CTRL, 0);
+	tw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);
+	tw32(MAC_RX_MODE, RX_MODE_RESET);
+	udelay(10);
+	tw32(MAC_RX_MODE, tp->rx_mode);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5703_A1)
+		tw32(MAC_SERDES_CFG, 0x616000);
+
+	err = tg3_setup_phy(tp);
+	if (err)
+		return err;
+
+	if (tp->phy_id != PHY_ID_SERDES) {
+		u32 tmp;
+
+		/* Clear CRC stats. */
+		tg3_readphy(tp, 0x1e, &tmp);
+		tg3_writephy(tp, 0x1e, tmp | 0x8000);
+		tg3_readphy(tp, 0x14, &tmp);
+	}
+
+	__tg3_set_rx_mode(tp->dev);
+
+	/* Initialize receive rules. */
+	tw32(MAC_RCV_RULE_0,  0xc2000000 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_0, 0xffffffff & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_RULE_1,  0x86000004 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_1, 0xffffffff & RCV_RULE_DISABLE_MASK);
+#if 0
+	tw32(MAC_RCV_RULE_2,  0); tw32(MAC_RCV_VALUE_2,  0);
+	tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0);
+#endif
+	tw32(MAC_RCV_RULE_4,  0); tw32(MAC_RCV_VALUE_4,  0);
+	tw32(MAC_RCV_RULE_5,  0); tw32(MAC_RCV_VALUE_5,  0);
+	tw32(MAC_RCV_RULE_6,  0); tw32(MAC_RCV_VALUE_6,  0);
+	tw32(MAC_RCV_RULE_7,  0); tw32(MAC_RCV_VALUE_7,  0);
+	tw32(MAC_RCV_RULE_8,  0); tw32(MAC_RCV_VALUE_8,  0);
+	tw32(MAC_RCV_RULE_9,  0); tw32(MAC_RCV_VALUE_9,  0);
+	tw32(MAC_RCV_RULE_10,  0); tw32(MAC_RCV_VALUE_10,  0);
+	tw32(MAC_RCV_RULE_11,  0); tw32(MAC_RCV_VALUE_11,  0);
+	tw32(MAC_RCV_RULE_12,  0); tw32(MAC_RCV_VALUE_12,  0);
+	tw32(MAC_RCV_RULE_13,  0); tw32(MAC_RCV_VALUE_13,  0);
+	tw32(MAC_RCV_RULE_14,  0); tw32(MAC_RCV_VALUE_14,  0);
+	tw32(MAC_RCV_RULE_15,  0); tw32(MAC_RCV_VALUE_15,  0);
+
+	if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE)
+		tg3_enable_ints(tp);
+
+	return 0;
+}
+
+/* Called at device open time to get the chip ready for
+ * packet processing.  Invoked with tp->lock held.
+ */
+static int tg3_init_hw(struct tg3 *tp)
+{
+	int err;
+
+	/* Force the chip into D0. */
+	err = tg3_set_power_state(tp, 0);
+	if (err)
+		goto out;
+
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	err = tg3_reset_hw(tp);
+
+out:
+	return err;
+}
+
+static void tg3_timer(unsigned long __opaque)
+{
+	struct tg3 *tp = (struct tg3 *) __opaque;
+
+	spin_lock_irq(&tp->lock);
+
+	if (!(tp->tg3_flags & TG3_FLAG_TAGGED_IRQ_STATUS)) {
+		/* All of this garbage is because on the 5700 the
+		 * mailbox/status_block protocol the chip uses with
+		 * the cpu is race prone.
+		 */
+		if (tp->hw_status->status & SD_STATUS_UPDATED) {
+			tw32(GRC_LOCAL_CTRL,
+			     tp->grc_local_ctrl | GRC_LCLCTRL_SETINT);
+		} else {
+			tw32(HOSTCC_MODE,
+			     (HOSTCC_MODE_ENABLE | HOSTCC_MODE_NOW));
+		}
+
+		if (!(tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {
+			tg3_halt(tp);
+			tg3_init_rings(tp);
+			tg3_init_hw(tp);
+		}
+	}
+
+	/* This part only runs once per second. */
+	if (!--tp->timer_counter) {
+		if (tp->tg3_flags & TG3_FLAG_USE_LINKCHG_REG) {
+			u32 mac_stat;
+			int phy_event;
+
+			mac_stat = tr32(MAC_STATUS);
+
+			phy_event = 0;
+			if (tp->tg3_flags & TG3_FLAG_USE_MI_INTERRUPT) {
+				if (mac_stat & MAC_STATUS_MI_INTERRUPT)
+					phy_event = 1;
+			} else if (mac_stat & MAC_STATUS_LNKSTATE_CHANGED)
+				phy_event = 1;
+
+			if (phy_event)
+				tg3_setup_phy(tp);
+		}
+
+		tp->timer_counter = tp->timer_multiplier;
+	}
+
+	spin_unlock_irq(&tp->lock);
+
+	tp->timer.expires = jiffies + tp->timer_offset;
+	add_timer(&tp->timer);
+}
+
+static int tg3_open(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_disable_ints(tp);
+	tp->tg3_flags &= ~TG3_FLAG_INIT_COMPLETE;
+
+	spin_unlock_irq(&tp->lock);
+
+	/* If you move this call, make sure TG3_FLAG_HOST_TXDS in
+	 * tp->tg3_flags is accurate at that new place.
+	 */
+	err = tg3_alloc_consistent(tp);
+	if (err)
+		return err;
+
+	if (tp->tg3_flags & TG3_FLAG_TAGGED_IRQ_STATUS)
+		err = request_irq(dev->irq, tg3_interrupt_tagged,
+				  SA_SHIRQ, dev->name, dev);
+	else
+		err = request_irq(dev->irq, tg3_interrupt,
+				  SA_SHIRQ, dev->name, dev);
+
+	if (err) {
+		tg3_free_consistent(tp);
+		return err;
+	}
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_init_rings(tp);
+
+	err = tg3_init_hw(tp);
+	if (err) {
+		tg3_halt(tp);
+		tg3_free_rings(tp);
+	} else {
+		if (tp->tg3_flags & TG3_FLAG_TAGGED_IRQ_STATUS) {
+			tp->timer_offset = HZ;
+			tp->timer_counter = tp->timer_multiplier = 1;
+		} else {
+			tp->timer_offset = HZ / 10;
+			tp->timer_counter = tp->timer_multiplier = 10;
+		}
+
+		init_timer(&tp->timer);
+		tp->timer.expires = jiffies + tp->timer_offset;
+		tp->timer.data = (unsigned long) tp;
+		tp->timer.function = tg3_timer;
+		add_timer(&tp->timer);
+
+		tp->last_rate_sample = jiffies;
+		tp->last_rx_count = 0;
+		tp->last_tx_count = 0;
+
+		tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
+	}
+
+	spin_unlock_irq(&tp->lock);
+
+	if (err) {
+		free_irq(dev->irq, dev);
+		tg3_free_consistent(tp);
+		return err;
+	}
+
+	netif_start_queue(dev);
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_enable_ints(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+#if 0
+/*static*/ void tg3_dump_state(struct tg3 *tp)
+{
+	u32 val32, val32_2, val32_3, val32_4, val32_5;
+	u16 val16;
+	int i;
+
+	pci_read_config_word(tp->pdev, PCI_STATUS, &val16);
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE, &val32);
+	printk("DEBUG: PCI status [%04x] TG3PCI state[%08x]\n",
+	       val16, val32);
+
+	/* MAC block */
+	printk("DEBUG: MAC_MODE[%08x] MAC_STATUS[%08x]\n",
+	       tr32(MAC_MODE), tr32(MAC_STATUS));
+	printk("       MAC_EVENT[%08x] MAC_LED_CTRL[%08x]\n",
+	       tr32(MAC_EVENT), tr32(MAC_LED_CTRL));
+	printk("DEBUG: MAC_TX_MODE[%08x] MAC_TX_STATUS[%08x]\n",
+	       tr32(MAC_TX_MODE), tr32(MAC_TX_STATUS));
+	printk("       MAC_RX_MODE[%08x] MAC_RX_STATUS[%08x]\n",
+	       tr32(MAC_RX_MODE), tr32(MAC_RX_STATUS));
+
+	/* Send data initiator control block */
+	printk("DEBUG: SNDDATAI_MODE[%08x] SNDDATAI_STATUS[%08x]\n",
+	       tr32(SNDDATAI_MODE), tr32(SNDDATAI_STATUS));
+	printk("       SNDDATAI_STATSCTRL[%08x]\n",
+	       tr32(SNDDATAI_STATSCTRL));
+
+	/* Send data completion control block */
+	printk("DEBUG: SNDDATAC_MODE[%08x]\n", tr32(SNDDATAC_MODE));
+
+	/* Send BD ring selector block */
+	printk("DEBUG: SNDBDS_MODE[%08x] SNDBDS_STATUS[%08x]\n",
+	       tr32(SNDBDS_MODE), tr32(SNDBDS_STATUS));
+
+	/* Send BD initiator control block */
+	printk("DEBUG: SNDBDI_MODE[%08x] SNDBDI_STATUS[%08x]\n",
+	       tr32(SNDBDI_MODE), tr32(SNDBDI_STATUS));
+
+	/* Send BD completion control block */
+	printk("DEBUG: SNDBDC_MODE[%08x]\n", tr32(SNDBDC_MODE));
+
+	/* Receive list placement control block */
+	printk("DEBUG: RCVLPC_MODE[%08x] RCVLPC_STATUS[%08x]\n",
+	       tr32(RCVLPC_MODE), tr32(RCVLPC_STATUS));
+	printk("       RCVLPC_STATSCTRL[%08x]\n",
+	       tr32(RCVLPC_STATSCTRL));
+
+	/* Receive data and receive BD initiator control block */
+	printk("DEBUG: RCVDBDI_MODE[%08x] RCVDBDI_STATUS[%08x]\n",
+	       tr32(RCVDBDI_MODE), tr32(RCVDBDI_STATUS));
+
+	/* Receive data completion control block */
+	printk("DEBUG: RCVDCC_MODE[%08x]\n",
+	       tr32(RCVDCC_MODE));
+
+	/* Receive BD initiator control block */
+	printk("DEBUG: RCVBDI_MODE[%08x] RCVBDI_STATUS[%08x]\n",
+	       tr32(RCVBDI_MODE), tr32(RCVBDI_STATUS));
+
+	/* Receive BD completion control block */
+	printk("DEBUG: RCVCC_MODE[%08x] RCVCC_STATUS[%08x]\n",
+	       tr32(RCVCC_MODE), tr32(RCVCC_STATUS));
+
+	/* Receive list selector control block */
+	printk("DEBUG: RCVLSC_MODE[%08x] RCVLSC_STATUS[%08x]\n",
+	       tr32(RCVLSC_MODE), tr32(RCVLSC_STATUS));
+
+	/* Mbuf cluster free block */
+	printk("DEBUG: MBFREE_MODE[%08x] MBFREE_STATUS[%08x]\n",
+	       tr32(MBFREE_MODE), tr32(MBFREE_STATUS));
+
+	/* Host coalescing control block */
+	printk("DEBUG: HOSTCC_MODE[%08x] HOSTCC_STATUS[%08x]\n",
+	       tr32(HOSTCC_MODE), tr32(HOSTCC_STATUS));
+	printk("DEBUG: HOSTCC_STATS_BLK_HOST_ADDR[%08x%08x]\n",
+	       tr32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH),
+	       tr32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW));
+	printk("DEBUG: HOSTCC_STATUS_BLK_HOST_ADDR[%08x%08x]\n",
+	       tr32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH),
+	       tr32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW));
+	printk("DEBUG: HOSTCC_STATS_BLK_NIC_ADDR[%08x]\n",
+	       tr32(HOSTCC_STATS_BLK_NIC_ADDR));
+	printk("DEBUG: HOSTCC_STATUS_BLK_NIC_ADDR[%08x]\n",
+	       tr32(HOSTCC_STATUS_BLK_NIC_ADDR));
+
+	/* Memory arbiter control block */
+	printk("DEBUG: MEMARB_MODE[%08x] MEMARB_STATUS[%08x]\n",
+	       tr32(MEMARB_MODE), tr32(MEMARB_STATUS));
+
+	/* Buffer manager control block */
+	printk("DEBUG: BUFMGR_MODE[%08x] BUFMGR_STATUS[%08x]\n",
+	       tr32(BUFMGR_MODE), tr32(BUFMGR_STATUS));
+	printk("DEBUG: BUFMGR_MB_POOL_ADDR[%08x] BUFMGR_MB_POOL_SIZE[%08x]\n",
+	       tr32(BUFMGR_MB_POOL_ADDR), tr32(BUFMGR_MB_POOL_SIZE));
+	printk("DEBUG: BUFMGR_DMA_DESC_POOL_ADDR[%08x] "
+	       "BUFMGR_DMA_DESC_POOL_SIZE[%08x]\n",
+	       tr32(BUFMGR_DMA_DESC_POOL_ADDR),
+	       tr32(BUFMGR_DMA_DESC_POOL_SIZE));
+
+	/* Read DMA control block */
+	printk("DEBUG: RDMAC_MODE[%08x] RDMAC_STATUS[%08x]\n",
+	       tr32(RDMAC_MODE), tr32(RDMAC_STATUS));
+
+	/* Write DMA control block */
+	printk("DEBUG: WDMAC_MODE[%08x] WDMAC_STATUS[%08x]\n",
+	       tr32(WDMAC_MODE), tr32(WDMAC_STATUS));
+
+	/* DMA completion block */
+	printk("DEBUG: DMAC_MODE[%08x]\n",
+	       tr32(DMAC_MODE));
+
+	/* GRC block */
+	printk("DEBUG: GRC_MODE[%08x] GRC_MISC_CFG[%08x]\n",
+	       tr32(GRC_MODE), tr32(GRC_MISC_CFG));
+	printk("DEBUG: GRC_LOCAL_CTRL[%08x]\n",
+	       tr32(GRC_LOCAL_CTRL));
+
+	/* TG3_BDINFOs */
+	printk("DEBUG: RCVDBDI_JUMBO_BD[%08x%08x:%08x:%08x]\n",
+	       tr32(RCVDBDI_JUMBO_BD + 0x0),
+	       tr32(RCVDBDI_JUMBO_BD + 0x4),
+	       tr32(RCVDBDI_JUMBO_BD + 0x8),
+	       tr32(RCVDBDI_JUMBO_BD + 0xc));
+	printk("DEBUG: RCVDBDI_STD_BD[%08x%08x:%08x:%08x]\n",
+	       tr32(RCVDBDI_STD_BD + 0x0),
+	       tr32(RCVDBDI_STD_BD + 0x4),
+	       tr32(RCVDBDI_STD_BD + 0x8),
+	       tr32(RCVDBDI_STD_BD + 0xc));
+	printk("DEBUG: RCVDBDI_MINI_BD[%08x%08x:%08x:%08x]\n",
+	       tr32(RCVDBDI_MINI_BD + 0x0),
+	       tr32(RCVDBDI_MINI_BD + 0x4),
+	       tr32(RCVDBDI_MINI_BD + 0x8),
+	       tr32(RCVDBDI_MINI_BD + 0xc));
+
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0x0, &val32);
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0x4, &val32_2);
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0x8, &val32_3);
+	tg3_read_mem(tp, NIC_SRAM_SEND_RCB + 0xc, &val32_4);
+	printk("DEBUG: SRAM_SEND_RCB_0[%08x%08x:%08x:%08x]\n",
+	       val32, val32_2, val32_3, val32_4);
+
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0x0, &val32);
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0x4, &val32_2);
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0x8, &val32_3);
+	tg3_read_mem(tp, NIC_SRAM_RCV_RET_RCB + 0xc, &val32_4);
+	printk("DEBUG: SRAM_RCV_RET_RCB_0[%08x%08x:%08x:%08x]\n",
+	       val32, val32_2, val32_3, val32_4);
+
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x0, &val32);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x4, &val32_2);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x8, &val32_3);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0xc, &val32_4);
+	tg3_read_mem(tp, NIC_SRAM_STATUS_BLK + 0x10, &val32_5);
+	printk("DEBUG: SRAM_STATUS_BLK[%08x:%08x:%08x:%08x:%08x]\n",
+	       val32, val32_2, val32_3, val32_4, val32_5);
+
+	/* SW status block */
+	printk("DEBUG: Host status block [%08x:%08x:(%04x:%04x:%04x):(%04x:%04x)]\n",
+	       tp->hw_status->status,
+	       tp->hw_status->status_tag,
+	       tp->hw_status->rx_jumbo_consumer,
+	       tp->hw_status->rx_consumer,
+	       tp->hw_status->rx_mini_consumer,
+	       tp->hw_status->idx[0].rx_producer,
+	       tp->hw_status->idx[0].tx_consumer);
+
+	/* SW statistics block */
+	printk("DEBUG: Host statistics block [%08x:%08x:%08x:%08x]\n",
+	       ((u32 *)tp->hw_stats)[0],
+	       ((u32 *)tp->hw_stats)[1],
+	       ((u32 *)tp->hw_stats)[2],
+	       ((u32 *)tp->hw_stats)[3]);
+
+	/* Mailboxes */
+	printk("DEBUG: SNDHOST_PROD[%08x%08x] SNDNIC_PROD[%08x%08x]\n",
+	       tr32(MAILBOX_SNDHOST_PROD_IDX_0 + 0x0),
+	       tr32(MAILBOX_SNDHOST_PROD_IDX_0 + 0x4),
+	       tr32(MAILBOX_SNDNIC_PROD_IDX_0 + 0x0),
+	       tr32(MAILBOX_SNDNIC_PROD_IDX_0 + 0x4));
+
+	/* NIC side send descriptors. */
+	for (i = 0; i < 6; i++) {
+		unsigned long txd;
+
+		txd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_TX_BUFFER_DESC
+			+ (i * sizeof(struct tg3_tx_buffer_desc));
+		printk("DEBUG: NIC TXD(%d)[%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(txd + 0x0), readl(txd + 0x4),
+		       readl(txd + 0x8), readl(txd + 0xc));
+	}
+
+	/* NIC side RX descriptors. */
+	for (i = 0; i < 6; i++) {
+		unsigned long rxd;
+
+		rxd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_RX_BUFFER_DESC
+			+ (i * sizeof(struct tg3_rx_buffer_desc));
+		printk("DEBUG: NIC RXD_STD(%d)[0][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+		rxd += (4 * sizeof(u32));
+		printk("DEBUG: NIC RXD_STD(%d)[1][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+	}
+#if TG3_MINI_RING_WORKS
+	for (i = 0; i < 6; i++) {
+		unsigned long rxd;
+
+		rxd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_RX_MINI_BUFFER_DESC
+			+ (i * sizeof(struct tg3_rx_buffer_desc));
+		printk("DEBUG: NIC RXD_MINI(%d)[0][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+		rxd += (4 * sizeof(u32));
+		printk("DEBUG: NIC RXD_MINI(%d)[1][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+	}
+#endif
+
+	for (i = 0; i < 6; i++) {
+		unsigned long rxd;
+
+		rxd = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_RX_JUMBO_BUFFER_DESC
+			+ (i * sizeof(struct tg3_rx_buffer_desc));
+		printk("DEBUG: NIC RXD_JUMBO(%d)[0][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+		rxd += (4 * sizeof(u32));
+		printk("DEBUG: NIC RXD_JUMBO(%d)[1][%08x:%08x:%08x:%08x]\n",
+		       i,
+		       readl(rxd + 0x0), readl(rxd + 0x4),
+		       readl(rxd + 0x8), readl(rxd + 0xc));
+	}
+}
+#endif
+
+static struct net_device_stats *tg3_get_stats(struct net_device *);
+
+static int tg3_close(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+
+	netif_stop_queue(dev);
+
+	del_timer_sync(&tp->timer);
+
+	spin_lock_irq(&tp->lock);
+#if 0
+	tg3_dump_state(tp);
+#endif
+
+	tg3_disable_ints(tp);
+
+	tg3_halt(tp);
+	tg3_free_rings(tp);
+	tp->tg3_flags &= ~TG3_FLAG_INIT_COMPLETE;
+
+	spin_unlock_irq(&tp->lock);
+
+	free_irq(dev->irq, dev);
+
+	memcpy(&tp->net_stats_prev, tg3_get_stats(tp->dev),
+	       sizeof(tp->net_stats_prev));
+
+	tg3_free_consistent(tp);
+
+	return 0;
+}
+
+static inline unsigned long get_stat64(tg3_stat64_t *val)
+{
+	unsigned long ret;
+
+#if (BITS_PER_LONG == 32)
+	if (val->high != 0)
+		ret = ~0UL;
+	else
+		ret = val->low;
+#else
+	ret = ((u64)val->high << 32) | ((u64)val->low);
+#endif
+	return ret;
+}
+
+static unsigned long calc_crc_errors(struct tg3 *tp)
+{
+	struct tg3_hw_stats *hw_stats = tp->hw_stats;
+
+	if (tp->phy_id != PHY_ID_SERDES &&
+	    (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 ||
+	     GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701)) {
+		unsigned long flags;
+		u32 val;
+
+		spin_lock_irqsave(&tp->lock, flags);
+		tg3_readphy(tp, 0x1e, &val);
+		tg3_writephy(tp, 0x1e, val | 0x8000);
+		tg3_readphy(tp, 0x14, &val);
+		spin_unlock_irqrestore(&tp->lock, flags);
+
+		tp->phy_crc_errors += val;
+
+		return tp->phy_crc_errors;
+	}
+
+	return get_stat64(&hw_stats->rx_fcs_errors);
+}
+
+static struct net_device_stats *tg3_get_stats(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	struct net_device_stats *stats = &tp->net_stats;
+	struct net_device_stats *old_stats = &tp->net_stats_prev;
+	struct tg3_hw_stats *hw_stats = tp->hw_stats;
+
+	if (!hw_stats)
+		return old_stats;
+
+	stats->rx_packets = old_stats->rx_packets +
+		get_stat64(&hw_stats->rx_ucast_packets) +
+		get_stat64(&hw_stats->rx_mcast_packets) +
+		get_stat64(&hw_stats->rx_bcast_packets);
+		
+	stats->tx_packets = old_stats->tx_packets +
+		get_stat64(&hw_stats->COS_out_packets[0]);
+
+	stats->rx_bytes = old_stats->rx_bytes +
+		get_stat64(&hw_stats->rx_octets);
+	stats->tx_bytes = old_stats->tx_bytes +
+		get_stat64(&hw_stats->tx_octets);
+
+	stats->rx_errors = old_stats->rx_errors +
+		get_stat64(&hw_stats->rx_errors);
+	stats->tx_errors = old_stats->tx_errors +
+		get_stat64(&hw_stats->tx_errors) +
+		get_stat64(&hw_stats->tx_mac_errors) +
+		get_stat64(&hw_stats->tx_carrier_sense_errors) +
+		get_stat64(&hw_stats->tx_discards);
+
+	stats->multicast = old_stats->multicast +
+		get_stat64(&hw_stats->rx_mcast_packets);
+	stats->collisions = old_stats->collisions +
+		get_stat64(&hw_stats->tx_collisions);
+
+	stats->rx_length_errors = old_stats->rx_length_errors +
+		get_stat64(&hw_stats->rx_frame_too_long_errors) +
+		get_stat64(&hw_stats->rx_undersize_packets);
+
+	stats->rx_over_errors = old_stats->rx_over_errors +
+		get_stat64(&hw_stats->rxbds_empty);
+	stats->rx_frame_errors = old_stats->rx_frame_errors +
+		get_stat64(&hw_stats->rx_align_errors);
+	stats->tx_aborted_errors = old_stats->tx_aborted_errors +
+		get_stat64(&hw_stats->tx_discards);
+	stats->tx_carrier_errors = old_stats->tx_carrier_errors +
+		get_stat64(&hw_stats->tx_carrier_sense_errors);
+
+	stats->rx_crc_errors = old_stats->rx_crc_errors +
+		calc_crc_errors(tp);
+
+	return stats;
+}
+
+static inline u32 calc_crc(unsigned char *buf, int len)
+{
+	u32 reg;
+	u32 tmp;
+	int j, k;
+
+	reg = 0xffffffff;
+
+	for (j = 0; j < len; j++) {
+		reg ^= buf[j];
+
+		for (k = 0; k < 8; k++) {
+			tmp = reg & 0x01;
+
+			reg >>= 1;
+
+			if (tmp) {
+				reg ^= 0xedb88320;
+			}
+		}
+	}
+
+	return ~reg;
+}
+
+static void tg3_set_multi(struct tg3 *tp, unsigned int accept_all)
+{
+	/* accept or reject all multicast frames */
+	tw32 (MAC_HASH_REG_0, accept_all ? 0xffffffff : 0);
+	tw32 (MAC_HASH_REG_1, accept_all ? 0xffffffff : 0);
+	tw32 (MAC_HASH_REG_2, accept_all ? 0xffffffff : 0);
+	tw32 (MAC_HASH_REG_3, accept_all ? 0xffffffff : 0);
+}
+
+static void __tg3_set_rx_mode(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+	u32 rx_mode;
+
+	rx_mode = tp->rx_mode & ~RX_MODE_PROMISC;
+
+	if (dev->flags & IFF_PROMISC) {
+		/* Promiscuous mode. */
+		rx_mode |= RX_MODE_PROMISC;
+	} else if (dev->flags & IFF_ALLMULTI) {
+		/* Accept all multicast. */
+		tg3_set_multi (tp, 1);
+	} else if (dev->mc_count < 1) {
+		/* Reject all multicast. */
+		tg3_set_multi (tp, 0);
+	} else {
+		/* Accept one or more multicast(s). */
+		struct dev_mc_list *mclist;
+		unsigned int i;
+		u32 mc_filter[4] = { 0, };
+		u32 regidx;
+		u32 bit;
+		u32 crc;
+
+		for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+		     i++, mclist = mclist->next) {
+
+			crc = calc_crc (mclist->dmi_addr, ETH_ALEN);
+			bit = ~crc & 0x7f;
+			regidx = (bit & 0x60) >> 5;
+			bit &= 0x1f;
+			mc_filter[regidx] |= (1 << bit);
+		}
+
+		tw32 (MAC_HASH_REG_0, mc_filter[0]);
+		tw32 (MAC_HASH_REG_1, mc_filter[1]);
+		tw32 (MAC_HASH_REG_2, mc_filter[2]);
+		tw32 (MAC_HASH_REG_3, mc_filter[3]);
+	}
+
+	if (rx_mode != tp->rx_mode) {
+		tp->rx_mode = rx_mode;
+		tw32 (MAC_RX_MODE, rx_mode);
+	}
+}
+
+static void tg3_set_rx_mode(struct net_device *dev)
+{
+	struct tg3 *tp = dev->priv;
+
+	spin_lock_irq(&tp->lock);
+	__tg3_set_rx_mode(dev);
+	spin_unlock_irq(&tp->lock);
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,17))
+#define TG3_REGDUMP_LEN		(32 * 1024)
+
+static u8 *tg3_get_regs(struct tg3 *tp)
+{
+	u8 *orig_p = kmalloc(TG3_REGDUMP_LEN, GFP_KERNEL);
+	u8 *p;
+	int i;
+
+	if (orig_p == NULL)
+		return NULL;
+
+	memset(orig_p, 0, TG3_REGDUMP_LEN);
+
+	spin_lock_irq(&tp->lock);
+
+#define __GET_REG32(reg)	(*((u32 *)(p))++ = tr32(reg))
+#define GET_REG32_LOOP(base,len)		\
+do {	p = orig_p + (base);			\
+	for (i = 0; i < len; i += 4)		\
+		__GET_REG32((base) + i);	\
+} while (0)
+#define GET_REG32_1(reg)	\
+do {	p = orig_p + (reg);	\
+	__GET_REG32((reg));	\
+} while (0)
+
+	GET_REG32_LOOP(TG3PCI_VENDOR, 0xb0);
+	GET_REG32_LOOP(MAILBOX_INTERRUPT_0, 0x200);
+	GET_REG32_LOOP(MAC_MODE, 0x4f0);
+	GET_REG32_LOOP(SNDDATAI_MODE, 0xe0);
+	GET_REG32_1(SNDDATAC_MODE);
+	GET_REG32_LOOP(SNDBDS_MODE, 0x80);
+	GET_REG32_LOOP(SNDBDI_MODE, 0x48);
+	GET_REG32_1(SNDBDC_MODE);
+	GET_REG32_LOOP(RCVLPC_MODE, 0x20);
+	GET_REG32_LOOP(RCVLPC_SELLST_BASE, 0x15c);
+	GET_REG32_LOOP(RCVDBDI_MODE, 0x0c);
+	GET_REG32_LOOP(RCVDBDI_JUMBO_BD, 0x3c);
+	GET_REG32_LOOP(RCVDBDI_BD_PROD_IDX_0, 0x44);
+	GET_REG32_1(RCVDCC_MODE);
+	GET_REG32_LOOP(RCVBDI_MODE, 0x20);
+	GET_REG32_LOOP(RCVCC_MODE, 0x14);
+	GET_REG32_LOOP(RCVLSC_MODE, 0x08);
+	GET_REG32_1(MBFREE_MODE);
+	GET_REG32_LOOP(HOSTCC_MODE, 0x100);
+	GET_REG32_LOOP(MEMARB_MODE, 0x10);
+	GET_REG32_LOOP(BUFMGR_MODE, 0x58);
+	GET_REG32_LOOP(RDMAC_MODE, 0x08);
+	GET_REG32_LOOP(WDMAC_MODE, 0x08);
+	GET_REG32_LOOP(RX_CPU_BASE, 0x280);
+	GET_REG32_LOOP(TX_CPU_BASE, 0x280);
+	GET_REG32_LOOP(GRCMBOX_INTERRUPT_0, 0x110);
+	GET_REG32_LOOP(FTQ_RESET, 0x120);
+	GET_REG32_LOOP(MSGINT_MODE, 0x0c);
+	GET_REG32_1(DMAC_MODE);
+	GET_REG32_LOOP(GRC_MODE, 0x4c);
+	GET_REG32_LOOP(NVRAM_CMD, 0x24);
+
+#undef __GET_REG32
+#undef GET_REG32_LOOP
+#undef GET_REG32_1
+
+	spin_unlock_irq(&tp->lock);
+
+	return orig_p;
+}
+
+static void tg3_to_ethtool_coal(struct tg3 *tp,
+				struct ethtool_coalesce *ecoal)
+{
+	ecoal->rx_coalesce_usecs =
+		tp->coalesce_config.rx_coalesce_ticks_def;
+	ecoal->rx_max_coalesced_frames =
+		tp->coalesce_config.rx_max_coalesced_frames_def;
+	ecoal->rx_coalesce_usecs_irq =
+		tp->coalesce_config.rx_coalesce_ticks_during_int_def;
+	ecoal->rx_max_coalesced_frames_irq =
+		tp->coalesce_config.rx_max_coalesced_frames_during_int_def;
+
+	ecoal->tx_coalesce_usecs =
+		tp->coalesce_config.tx_coalesce_ticks_def;
+	ecoal->tx_max_coalesced_frames =
+		tp->coalesce_config.tx_max_coalesced_frames_def;
+	ecoal->tx_coalesce_usecs_irq =
+		tp->coalesce_config.tx_coalesce_ticks_during_int_def;
+	ecoal->tx_max_coalesced_frames_irq =
+		tp->coalesce_config.tx_max_coalesced_frames_during_int_def;
+
+	ecoal->stats_block_coalesce_usecs =
+		tp->coalesce_config.stats_coalesce_ticks_def;
+
+	ecoal->use_adaptive_rx_coalesce =
+		(tp->tg3_flags & TG3_FLAG_ADAPTIVE_RX) != 0;
+	ecoal->use_adaptive_tx_coalesce =
+		(tp->tg3_flags & TG3_FLAG_ADAPTIVE_TX) != 0;
+
+	ecoal->pkt_rate_low =
+		tp->coalesce_config.pkt_rate_low;
+	ecoal->rx_coalesce_usecs_low =
+		tp->coalesce_config.rx_coalesce_ticks_low;
+	ecoal->rx_max_coalesced_frames_low =
+		tp->coalesce_config.rx_max_coalesced_frames_low;
+	ecoal->tx_coalesce_usecs_low =
+		tp->coalesce_config.tx_coalesce_ticks_low;
+	ecoal->tx_max_coalesced_frames_low =
+		tp->coalesce_config.tx_max_coalesced_frames_low;
+
+	ecoal->pkt_rate_high =
+		tp->coalesce_config.pkt_rate_high;
+	ecoal->rx_coalesce_usecs_high =
+		tp->coalesce_config.rx_coalesce_ticks_high;
+	ecoal->rx_max_coalesced_frames_high =
+		tp->coalesce_config.rx_max_coalesced_frames_high;
+	ecoal->tx_coalesce_usecs_high =
+		tp->coalesce_config.tx_coalesce_ticks_high;
+	ecoal->tx_max_coalesced_frames_high =
+		tp->coalesce_config.tx_max_coalesced_frames_high;
+
+	ecoal->rate_sample_interval =
+		tp->coalesce_config.rate_sample_jiffies / HZ;
+}
+
+static int tg3_from_ethtool_coal(struct tg3 *tp,
+				 struct ethtool_coalesce *ecoal)
+{
+	/* Make sure we are not getting garbage. */
+	if ((ecoal->rx_coalesce_usecs == 0 &&
+	     ecoal->rx_max_coalesced_frames == 0) ||
+	    (ecoal->tx_coalesce_usecs == 0 &&
+	     ecoal->tx_max_coalesced_frames == 0) ||
+	    ecoal->stats_block_coalesce_usecs == 0)
+		return -EINVAL;
+	if (ecoal->use_adaptive_rx_coalesce ||
+	    ecoal->use_adaptive_tx_coalesce) {
+		if (ecoal->pkt_rate_low > ecoal->pkt_rate_high)
+			return -EINVAL;
+		if (ecoal->rate_sample_interval == 0)
+			return -EINVAL;
+		if (ecoal->use_adaptive_rx_coalesce &&
+		    ((ecoal->rx_coalesce_usecs_low == 0 &&
+		      ecoal->rx_max_coalesced_frames_low == 0) ||
+		     (ecoal->rx_coalesce_usecs_high == 0 &&
+		      ecoal->rx_max_coalesced_frames_high == 0)))
+			return -EINVAL;
+		if (ecoal->use_adaptive_tx_coalesce &&
+		    ((ecoal->tx_coalesce_usecs_low == 0 &&
+		      ecoal->tx_max_coalesced_frames_low == 0) ||
+		     (ecoal->tx_coalesce_usecs_high == 0 &&
+		      ecoal->tx_max_coalesced_frames_high == 0)))
+			return -EINVAL;
+	}
+
+	/* Looks good, let it rip. */
+	spin_lock_irq(&tp->lock);
+	tp->coalesce_config.rx_coalesce_ticks =
+		tp->coalesce_config.rx_coalesce_ticks_def =
+		ecoal->rx_coalesce_usecs;
+	tp->coalesce_config.rx_max_coalesced_frames =
+		tp->coalesce_config.rx_max_coalesced_frames_def =
+		ecoal->rx_max_coalesced_frames;
+	tp->coalesce_config.rx_coalesce_ticks_during_int =
+		tp->coalesce_config.rx_coalesce_ticks_during_int_def =
+		ecoal->rx_coalesce_usecs_irq;
+	tp->coalesce_config.rx_max_coalesced_frames_during_int =
+		tp->coalesce_config.rx_max_coalesced_frames_during_int_def =
+		ecoal->rx_max_coalesced_frames_irq;
+	tp->coalesce_config.tx_coalesce_ticks =
+		tp->coalesce_config.tx_coalesce_ticks_def =
+		ecoal->tx_coalesce_usecs;
+	tp->coalesce_config.tx_max_coalesced_frames =
+		tp->coalesce_config.tx_max_coalesced_frames_def =
+		ecoal->tx_max_coalesced_frames;
+	tp->coalesce_config.tx_coalesce_ticks_during_int =
+		tp->coalesce_config.tx_coalesce_ticks_during_int_def =
+		ecoal->tx_coalesce_usecs_irq;
+	tp->coalesce_config.tx_max_coalesced_frames_during_int =
+		tp->coalesce_config.tx_max_coalesced_frames_during_int_def =
+		ecoal->tx_max_coalesced_frames_irq;
+	tp->coalesce_config.stats_coalesce_ticks =
+		tp->coalesce_config.stats_coalesce_ticks_def =
+		ecoal->stats_block_coalesce_usecs;
+
+	if (ecoal->use_adaptive_rx_coalesce)
+		tp->tg3_flags |= TG3_FLAG_ADAPTIVE_RX;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_ADAPTIVE_RX;
+	if (ecoal->use_adaptive_tx_coalesce)
+		tp->tg3_flags |= TG3_FLAG_ADAPTIVE_TX;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_ADAPTIVE_TX;
+
+	tp->coalesce_config.pkt_rate_low = ecoal->pkt_rate_low;
+	tp->coalesce_config.pkt_rate_high = ecoal->pkt_rate_high;
+	tp->coalesce_config.rate_sample_jiffies =
+		ecoal->rate_sample_interval * HZ;
+
+	tp->coalesce_config.rx_coalesce_ticks_low =
+		ecoal->rx_coalesce_usecs_low;
+	tp->coalesce_config.rx_max_coalesced_frames_low =
+		ecoal->rx_max_coalesced_frames_low;
+	tp->coalesce_config.tx_coalesce_ticks_low =
+		ecoal->tx_coalesce_usecs_low;
+	tp->coalesce_config.tx_max_coalesced_frames_low =
+		ecoal->tx_max_coalesced_frames_low;
+
+	tp->coalesce_config.rx_coalesce_ticks_high =
+		ecoal->rx_coalesce_usecs_high;
+	tp->coalesce_config.rx_max_coalesced_frames_high =
+		ecoal->rx_max_coalesced_frames_high;
+	tp->coalesce_config.tx_coalesce_ticks_high =
+		ecoal->tx_coalesce_usecs_high;
+	tp->coalesce_config.tx_max_coalesced_frames_high =
+		ecoal->tx_max_coalesced_frames_high;
+
+	tw32(HOSTCC_RXCOL_TICKS,
+	     tp->coalesce_config.rx_coalesce_ticks_def);
+	tw32(HOSTCC_RXMAX_FRAMES,
+	     tp->coalesce_config.rx_max_coalesced_frames_def);
+	tw32(HOSTCC_RXCOAL_TICK_INT,
+	     tp->coalesce_config.rx_coalesce_ticks_during_int_def);
+	tw32(HOSTCC_RXCOAL_MAXF_INT,
+	     tp->coalesce_config.rx_max_coalesced_frames_during_int_def);
+	tw32(HOSTCC_TXCOL_TICKS,
+	     tp->coalesce_config.tx_coalesce_ticks_def);
+	tw32(HOSTCC_TXMAX_FRAMES,
+	     tp->coalesce_config.tx_max_coalesced_frames_def);
+	tw32(HOSTCC_TXCOAL_TICK_INT,
+	     tp->coalesce_config.tx_coalesce_ticks_during_int_def);
+	tw32(HOSTCC_TXCOAL_MAXF_INT,
+	     tp->coalesce_config.tx_max_coalesced_frames_during_int_def);
+	tw32(HOSTCC_STAT_COAL_TICKS,
+	     tp->coalesce_config.stats_coalesce_ticks_def);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+static int tg3_ethtool_ioctl (struct net_device *dev, void *useraddr)
+{
+	struct tg3 *tp = dev->priv;
+	struct pci_dev *pci_dev = tp->pdev;
+	u32 ethcmd;
+
+	if (copy_from_user (&ethcmd, useraddr, sizeof (ethcmd)))
+		return -EFAULT;
+
+	switch (ethcmd) {
+	case ETHTOOL_GDRVINFO:{
+		struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+		strcpy (info.driver, DRV_MODULE_NAME);
+		strcpy (info.version, DRV_MODULE_VERSION);
+		memset(&info.fw_version, 0, sizeof(info.fw_version));
+		strcpy (info.bus_info, pci_dev->slot_name);
+		info.eedump_len = 0;
+		info.regdump_len = TG3_REGDUMP_LEN;
+		if (copy_to_user (useraddr, &info, sizeof (info)))
+			return -EFAULT;
+		return 0;
+	}
+
+	case ETHTOOL_GSET: {
+		struct ethtool_cmd cmd = { ETHTOOL_GSET };
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+		    tp->link_config.phy_is_low_power)
+			return -EAGAIN;
+		cmd.supported = (SUPPORTED_Autoneg);
+
+		if (!(tp->tg3_flags & TG3_FLAG_10_100_ONLY))
+			cmd.supported |= (SUPPORTED_1000baseT_Half |
+					  SUPPORTED_1000baseT_Full);
+
+		if (tp->phy_id != PHY_ID_SERDES)
+			cmd.supported |= (SUPPORTED_100baseT_Half |
+					  SUPPORTED_100baseT_Full |
+					  SUPPORTED_10baseT_Half |
+					  SUPPORTED_10baseT_Full |
+					  SUPPORTED_MII);
+		else
+			cmd.supported |= SUPPORTED_FIBRE;
+
+		cmd.advertising = tp->link_config.advertising;
+		cmd.speed = tp->link_config.active_speed;
+		cmd.duplex = tp->link_config.active_duplex;
+		cmd.port = 0;
+		cmd.phy_address = PHY_ADDR;
+		cmd.transceiver = 0;
+		cmd.autoneg = tp->link_config.autoneg;
+		cmd.maxtxpkt = tp->coalesce_config.tx_max_coalesced_frames_def;
+		cmd.maxrxpkt = tp->coalesce_config.rx_max_coalesced_frames_def;
+		if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SSET: {
+		struct ethtool_cmd cmd;
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+		    tp->link_config.phy_is_low_power)
+			return -EAGAIN;
+
+		if (copy_from_user(&cmd, useraddr, sizeof(cmd)))
+			return -EFAULT;
+
+		/* Fiber PHY only supports 1000 full/half */
+		if (cmd.autoneg == AUTONEG_ENABLE) {
+			if (tp->phy_id == PHY_ID_SERDES &&
+			    (cmd.advertising &
+			     (ADVERTISED_10baseT_Half |
+			      ADVERTISED_10baseT_Full |
+			      ADVERTISED_100baseT_Half |
+			      ADVERTISED_100baseT_Full)))
+				return -EINVAL;
+			if ((tp->tg3_flags & TG3_FLAG_10_100_ONLY) &&
+			    (cmd.advertising &
+			     (ADVERTISED_1000baseT_Half |
+			      ADVERTISED_1000baseT_Full)))
+				return -EINVAL;
+		} else {
+			if (tp->phy_id == PHY_ID_SERDES &&
+			    (cmd.speed == SPEED_10 ||
+			     cmd.speed == SPEED_100))
+				return -EINVAL;
+			if ((tp->tg3_flags & TG3_FLAG_10_100_ONLY) &&
+			    (cmd.speed == SPEED_10 ||
+			     cmd.speed == SPEED_100))
+				return -EINVAL;
+		}
+
+		spin_lock_irq(&tp->lock);
+
+		tp->link_config.autoneg = cmd.autoneg;
+		if (cmd.autoneg == AUTONEG_ENABLE) {
+			tp->link_config.advertising = cmd.advertising;
+			tp->link_config.speed = SPEED_INVALID;
+			tp->link_config.duplex = DUPLEX_INVALID;
+		} else {
+			tp->link_config.speed = cmd.speed;
+			tp->link_config.duplex = cmd.duplex;
+		}
+
+		if (cmd.maxtxpkt || cmd.maxrxpkt) {
+			tp->coalesce_config.tx_max_coalesced_frames_def =
+				tp->coalesce_config.tx_max_coalesced_frames =
+				cmd.maxtxpkt;
+			tp->coalesce_config.rx_max_coalesced_frames_def =
+				tp->coalesce_config.rx_max_coalesced_frames =
+				cmd.maxrxpkt;
+
+			/* Coalescing config bits can be updated without
+			 * a full chip reset.
+			 */
+			tw32(HOSTCC_TXMAX_FRAMES,
+			     tp->coalesce_config.tx_max_coalesced_frames);
+			tw32(HOSTCC_RXMAX_FRAMES,
+			     tp->coalesce_config.rx_max_coalesced_frames);
+		}
+		tg3_setup_phy(tp);
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+
+	case ETHTOOL_GREGS: {
+		struct ethtool_regs regs;
+		u8 *regbuf;
+		int ret;
+
+		if (copy_from_user(&regs, useraddr, sizeof(regs)))
+			return -EFAULT;
+		if (regs.len > TG3_REGDUMP_LEN)
+			regs.len = TG3_REGDUMP_LEN;
+		regs.version = 0;
+		if (copy_to_user(useraddr, &regs, sizeof(regs)))
+			return -EFAULT;
+
+		regbuf = tg3_get_regs(tp);
+		if (!regbuf)
+			return -ENOMEM;
+
+		useraddr += offsetof(struct ethtool_regs, data);
+		ret = 0;
+		if (copy_to_user(useraddr, regbuf, regs.len))
+			ret = -EFAULT;
+		kfree(regbuf);
+		return ret;
+	}
+	case ETHTOOL_GWOL: {
+		struct ethtool_wolinfo wol = { ETHTOOL_GWOL };
+
+		wol.supported = WAKE_MAGIC;
+		wol.wolopts = 0;
+		if (tp->tg3_flags & TG3_FLAG_WOL_ENABLE)
+			wol.wolopts = WAKE_MAGIC;
+		memset(&wol.sopass, 0, sizeof(wol.sopass));
+		if (copy_to_user(useraddr, &wol, sizeof(wol)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SWOL: {
+		struct ethtool_wolinfo wol;
+
+		if (copy_from_user(&wol, useraddr, sizeof(wol)))
+			return -EFAULT;
+		if (wol.wolopts & ~WAKE_MAGIC)
+			return -EINVAL;
+		spin_lock_irq(&tp->lock);
+		if (wol.wolopts & WAKE_MAGIC)
+			tp->tg3_flags |= TG3_FLAG_WOL_ENABLE;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_WOL_ENABLE;
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GMSGLVL: {
+		struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+		edata.data = tp->msg_enable;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SMSGLVL: {
+		struct ethtool_value edata;
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+		tp->msg_enable = edata.data;
+		return 0;
+	}
+	case ETHTOOL_NWAY_RST: {
+		u32 bmcr;
+		int r;
+
+		spin_lock_irq(&tp->lock);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		r = -EINVAL;
+		if (bmcr & BMCR_ANENABLE) {
+			tg3_writephy(tp, MII_BMCR,
+				     bmcr | BMCR_ANRESTART);
+			r = 0;
+		}
+		spin_unlock_irq(&tp->lock);
+
+		return r;
+	}
+	case ETHTOOL_GLINK: {
+		struct ethtool_value edata = { ETHTOOL_GLINK };
+		edata.data = netif_carrier_ok(tp->dev) ? 1 : 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	case ETHTOOL_GCOALESCE: {
+		struct ethtool_coalesce ecoal = { ETHTOOL_GCOALESCE };
+
+		tg3_to_ethtool_coal(tp, &ecoal);
+		if (copy_to_user(useraddr, &ecoal, sizeof(ecoal)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SCOALESCE: {
+		struct ethtool_coalesce ecoal;
+
+		if (copy_from_user(&ecoal, useraddr, sizeof(ecoal)))
+			return -EINVAL;
+
+		return tg3_from_ethtool_coal(tp, &ecoal);
+	}
+	case ETHTOOL_GRINGPARAM: {
+		struct ethtool_ringparam ering = { ETHTOOL_GRINGPARAM };
+
+		ering.rx_max_pending = TG3_RX_RING_SIZE - 1;
+#if TG3_MINI_RING_WORKS
+		ering.rx_mini_max_pending = TG3_RX_MINI_RING_SIZE - 1;
+#else
+		ering.rx_mini_max_pending = 0;
+#endif
+		ering.rx_jumbo_max_pending = TG3_RX_JUMBO_RING_SIZE - 1;
+
+		ering.rx_pending = tp->rx_pending;
+#if TG3_MINI_RING_WORKS
+		ering.rx_mini_pending = tp->rx_mini_pending;
+#else
+		ering.rx_mini_pending = 0;
+#endif
+		ering.rx_jumbo_pending = tp->rx_jumbo_pending;
+		ering.tx_pending = tp->tx_pending;
+
+		if (copy_to_user(useraddr, &ering, sizeof(ering)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SRINGPARAM: {
+		struct ethtool_ringparam ering;
+
+		if (copy_from_user(&ering, useraddr, sizeof(ering)))
+			return -EFAULT;
+
+		if ((ering.rx_pending > TG3_RX_RING_SIZE - 1) ||
+#if TG3_MINI_RING_WORKS
+		    (ering.rx_mini_pending > TG3_RX_MINI_RING_SIZE - 1) ||
+#endif
+		    (ering.rx_jumbo_pending > TG3_RX_JUMBO_RING_SIZE - 1) ||
+		    (ering.tx_pending > TG3_TX_RING_SIZE - 1))
+			return -EINVAL;
+
+		spin_lock_irq(&tp->lock);
+
+		tp->rx_pending = ering.rx_pending;
+#if TG3_MINI_RING_WORKS
+		tp->rx_mini_pending = ering.rx_mini_pending;
+#endif
+		tp->rx_jumbo_pending = ering.rx_jumbo_pending;
+		tp->tx_pending = ering.tx_pending;
+
+		tg3_halt(tp);
+		tg3_init_rings(tp);
+		tg3_init_hw(tp);
+		netif_wake_queue(tp->dev);
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GPAUSEPARAM: {
+		struct ethtool_pauseparam epause = { ETHTOOL_GPAUSEPARAM };
+
+		epause.autoneg =
+			(tp->tg3_flags & TG3_FLAG_PAUSE_AUTONEG) != 0;
+		epause.rx_pause =
+			(tp->tg3_flags & TG3_FLAG_PAUSE_RX) != 0;
+		epause.tx_pause =
+			(tp->tg3_flags & TG3_FLAG_PAUSE_TX) != 0;
+		if (copy_to_user(useraddr, &epause, sizeof(epause)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SPAUSEPARAM: {
+		struct ethtool_pauseparam epause;
+
+		if (copy_from_user(&epause, useraddr, sizeof(epause)))
+			return -EFAULT;
+
+		spin_lock_irq(&tp->lock);
+		if (epause.autoneg)
+			tp->tg3_flags |= TG3_FLAG_PAUSE_AUTONEG;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_PAUSE_AUTONEG;
+		if (epause.rx_pause)
+			tp->tg3_flags |= TG3_FLAG_PAUSE_RX;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_PAUSE_RX;
+		if (epause.tx_pause)
+			tp->tg3_flags |= TG3_FLAG_PAUSE_TX;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_PAUSE_TX;
+		tg3_halt(tp);
+		tg3_init_rings(tp);
+		tg3_init_hw(tp);
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GRXCSUM: {
+		struct ethtool_value edata = { ETHTOOL_GRXCSUM };
+
+		edata.data =
+			(tp->tg3_flags & TG3_FLAG_RX_CHECKSUMS) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SRXCSUM: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+
+		if (tp->tg3_flags & TG3_FLAG_BROKEN_CHECKSUMS) {
+			if (edata.data != 0)
+				return -EINVAL;
+			return 0;
+		}
+
+		spin_lock_irq(&tp->lock);
+		if (edata.data)
+			tp->tg3_flags |= TG3_FLAG_RX_CHECKSUMS;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_RX_CHECKSUMS;
+		spin_unlock_irq(&tp->lock);
+
+		return 0;
+	}
+	case ETHTOOL_GTXCSUM: {
+		struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+		edata.data =
+			(tp->dev->features & NETIF_F_IP_CSUM) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_STXCSUM: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+
+		if (tp->tg3_flags & TG3_FLAG_BROKEN_CHECKSUMS) {
+			if (edata.data != 0)
+				return -EINVAL;
+			return 0;
+		}
+
+		if (edata.data)
+			tp->dev->features |= NETIF_F_IP_CSUM;
+		else
+			tp->dev->features &= ~NETIF_F_IP_CSUM;
+
+		return 0;
+	}
+	case ETHTOOL_GSG: {
+		struct ethtool_value edata = { ETHTOOL_GSG };
+
+		edata.data =
+			(tp->dev->features & NETIF_F_SG) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SSG: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+
+		if (edata.data)
+			tp->dev->features |= NETIF_F_SG;
+		else
+			tp->dev->features &= ~NETIF_F_SG;
+
+		return 0;
+	}
+	};
+
+	return -EOPNOTSUPP;
+}
+#endif /* KERNEL_VERSION > 2.4.17 */
+
+
+static int tg3_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	switch(cmd) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,17))
+	case SIOCETHTOOL:
+		return tg3_ethtool_ioctl(dev, (void *) ifr->ifr_data);
+#endif
+	case SIOCGMIIPHY:
+		data->phy_id = PHY_ADDR;
+
+		/* fallthru */
+	case SIOCGMIIREG: {
+		u32 mii_regval;
+
+		spin_lock_irq(&tp->lock);
+		err = tg3_readphy(tp, data->reg_num & 0x1f, &mii_regval);
+		spin_unlock_irq(&tp->lock);
+
+		data->val_out = mii_regval;
+
+		return err;
+	}
+
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		spin_lock_irq(&tp->lock);
+		err = tg3_writephy(tp, data->reg_num & 0x1f, data->val_in);
+		spin_unlock_irq(&tp->lock);
+
+		return err;
+
+	default:
+		/* do nothing */
+		break;
+	}
+	return -EOPNOTSUPP;
+}
+
+#if TG3_VLAN_TAG_USED
+static void tg3_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+	struct tg3 *tp = dev->priv;
+
+	spin_lock_irq(&tp->lock);
+	tp->vlgrp = grp;
+	spin_unlock_irq(&tp->lock);
+}
+
+static void tg3_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	struct tg3 *tp = dev->priv;
+
+	spin_lock_irq(&tp->lock);
+	if (tp->vlgrp)
+		tp->vlgrp->vlan_devices[vid] = NULL;
+	spin_unlock_irq(&tp->lock);
+}
+#endif
+
+/* Chips other than 5700/5701 use the NVRAM for fetching info. */
+static void __devinit tg3_nvram_init(struct tg3 *tp)
+{
+	int j;
+
+	tw32(GRC_EEPROM_ADDR,
+	     (EEPROM_ADDR_FSM_RESET |
+	      (EEPROM_DEFAULT_CLOCK_PERIOD <<
+	       EEPROM_ADDR_CLKPERD_SHIFT)));
+
+	/* XXX schedule_timeout() ... */
+	for (j = 0; j < 100; j++)
+		udelay(10);
+
+	/* Enable seeprom accesses. */
+	tw32(GRC_LOCAL_CTRL,
+	     tr32(GRC_LOCAL_CTRL) | GRC_LCLCTRL_AUTO_SEEPROM);
+	udelay(100);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700 &&
+	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) {
+		u32 nvcfg1 = tr32(NVRAM_CFG1);
+
+		tp->tg3_flags |= TG3_FLAG_NVRAM;
+		if (nvcfg1 & NVRAM_CFG1_FLASHIF_ENAB) {
+			if (nvcfg1 & NVRAM_CFG1_BUFFERED_MODE)
+				tp->tg3_flags |= TG3_FLAG_NVRAM_BUFFERED;
+		} else {
+			nvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;
+			tw32(NVRAM_CFG1, nvcfg1);
+		}
+
+	} else {
+		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
+	}
+}
+
+static int __devinit tg3_nvram_read_using_eeprom(struct tg3 *tp,
+						 u32 offset, u32 *val)
+{
+	u32 tmp;
+	int i;
+
+	if (offset > EEPROM_ADDR_ADDR_MASK ||
+	    (offset % 4) != 0)
+		return -EINVAL;
+
+	tmp = tr32(GRC_EEPROM_ADDR) & ~(EEPROM_ADDR_ADDR_MASK |
+					EEPROM_ADDR_DEVID_MASK |
+					EEPROM_ADDR_READ);
+	tw32(GRC_EEPROM_ADDR,
+	     tmp |
+	     (0 << EEPROM_ADDR_DEVID_SHIFT) |
+	     ((offset << EEPROM_ADDR_ADDR_SHIFT) &
+	      EEPROM_ADDR_ADDR_MASK) |
+	     EEPROM_ADDR_READ | EEPROM_ADDR_START);
+
+	for (i = 0; i < 10000; i++) {
+		tmp = tr32(GRC_EEPROM_ADDR);
+
+		if (tmp & EEPROM_ADDR_COMPLETE)
+			break;
+		udelay(100);
+	}
+	if (!(tmp & EEPROM_ADDR_COMPLETE))
+		return -EBUSY;
+
+	*val = tr32(GRC_EEPROM_DATA);
+	return 0;
+}
+
+static int __devinit tg3_nvram_read(struct tg3 *tp,
+				    u32 offset, u32 *val)
+{
+	int i, saw_done_clear;
+
+	if (!(tp->tg3_flags & TG3_FLAG_NVRAM))
+		return tg3_nvram_read_using_eeprom(tp, offset, val);
+
+	if (tp->tg3_flags & TG3_FLAG_NVRAM_BUFFERED)
+		offset = ((offset / NVRAM_BUFFERED_PAGE_SIZE) <<
+			  NVRAM_BUFFERED_PAGE_POS) +
+			(offset % NVRAM_BUFFERED_PAGE_SIZE);
+
+	if (offset > NVRAM_ADDR_MSK)
+		return -EINVAL;
+
+	tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+	for (i = 0; i < 1000; i++) {
+		if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+			break;
+		udelay(20);
+	}
+
+	tw32(NVRAM_ADDR, offset);
+	tw32(NVRAM_CMD,
+	     NVRAM_CMD_RD | NVRAM_CMD_GO |
+	     NVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);
+
+	/* Wait for done bit to clear then set again. */
+	saw_done_clear = 0;
+	for (i = 0; i < 1000; i++) {
+		udelay(10);
+		if (!saw_done_clear &&
+		    !(tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			saw_done_clear = 1;
+		else if (saw_done_clear &&
+			 (tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			break;
+	}
+	if (i >= 1000) {
+		tw32(NVRAM_SWARB, SWARB_REQ_CLR1);
+		return -EBUSY;
+	}
+
+	*val = swab32(tr32(NVRAM_RDDATA));
+	tw32(NVRAM_SWARB, 0x20);
+
+	return 0;
+}
+
+struct subsys_tbl_ent {
+	u16 subsys_vendor, subsys_devid;
+	u32 phy_id;
+};
+
+static struct subsys_tbl_ent subsys_id_to_phy_id[] = {
+	/* Broadcom boards. */
+	{ 0x14e4, 0x1644, PHY_ID_BCM5401 }, /* BCM95700A6 */
+	{ 0x14e4, 0x0001, PHY_ID_BCM5701 }, /* BCM95701A5 */
+	{ 0x14e4, 0x0002, PHY_ID_BCM8002 }, /* BCM95700T6 */
+	{ 0x14e4, 0x0003, PHY_ID_SERDES  }, /* BCM95700A9 */
+	{ 0x14e4, 0x0005, PHY_ID_BCM5701 }, /* BCM95701T1 */
+	{ 0x14e4, 0x0006, PHY_ID_BCM5701 }, /* BCM95701T8 */
+	{ 0x14e4, 0x0007, PHY_ID_SERDES  }, /* BCM95701A7 */
+	{ 0x14e4, 0x0008, PHY_ID_BCM5701 }, /* BCM95701A10 */
+	{ 0x14e4, 0x8008, PHY_ID_BCM5701 }, /* BCM95701A12 */
+	{ 0x14e4, 0x0009, PHY_ID_BCM5701 }, /* BCM95703Ax1 */
+	{ 0x14e4, 0x8009, PHY_ID_BCM5701 }, /* BCM95703Ax2 */
+
+	/* 3com boards. */
+	{ PCI_VENDOR_ID_3COM, 0x1000, PHY_ID_BCM5401 }, /* 3C996T */
+	{ PCI_VENDOR_ID_3COM, 0x1006, PHY_ID_BCM5701 }, /* 3C996BT */
+	/* { PCI_VENDOR_ID_3COM, 0x1002, PHY_ID_XXX },     3C996CT */
+	/* { PCI_VENDOR_ID_3COM, 0x1003, PHY_ID_XXX },     3C997T */
+	{ PCI_VENDOR_ID_3COM, 0x1004, PHY_ID_SERDES  }, /* 3C996SX */
+	/* { PCI_VENDOR_ID_3COM, 0x1005, PHY_ID_XXX },     3C997SZ */
+	{ PCI_VENDOR_ID_3COM, 0x1007, PHY_ID_BCM5701 }, /* 3C1000T */
+	{ PCI_VENDOR_ID_3COM, 0x1008, PHY_ID_BCM5701 }, /* 3C940BR01 */
+
+	/* DELL boards. */
+	{ PCI_VENDOR_ID_DELL, 0x00d1, PHY_ID_BCM5401 }, /* VIPER */
+	{ PCI_VENDOR_ID_DELL, 0x0106, PHY_ID_BCM5401 }, /* JAGUAR */
+	{ PCI_VENDOR_ID_DELL, 0x0109, PHY_ID_BCM5411 }, /* MERLOT */
+	{ PCI_VENDOR_ID_DELL, 0x010a, PHY_ID_BCM5411 }, /* SLIM_MERLOT */
+
+	/* Compaq boards. */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007c, PHY_ID_BCM5701 }, /* BANSHEE */
+	{ PCI_VENDOR_ID_COMPAQ, 0x009a, PHY_ID_BCM5701 }, /* BANSHEE_2 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007d, PHY_ID_SERDES  }, /* CHANGELING */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0085, PHY_ID_BCM5701 }, /* NC7780 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0099, PHY_ID_BCM5701 }  /* NC7780_2 */
+};
+
+static int __devinit tg3_phy_probe(struct tg3 *tp)
+{
+	u32 eeprom_phy_id, hw_phy_id_1, hw_phy_id_2;
+	u32 hw_phy_id, hw_phy_id_masked;
+	enum phy_led_mode eeprom_led_mode;
+	u32 val;
+	int i, eeprom_signature_found, err;
+
+	tp->phy_id = PHY_ID_INVALID;
+	for (i = 0; i < ARRAY_SIZE(subsys_id_to_phy_id); i++) {
+		if ((subsys_id_to_phy_id[i].subsys_vendor ==
+		     tp->pdev->subsystem_vendor) &&
+		    (subsys_id_to_phy_id[i].subsys_devid ==
+		     tp->pdev->subsystem_device)) {
+			tp->phy_id = subsys_id_to_phy_id[i].phy_id;
+			break;
+		}
+	}
+
+	eeprom_phy_id = PHY_ID_INVALID;
+	eeprom_led_mode = led_mode_auto;
+	eeprom_signature_found = 0;
+	tg3_read_mem(tp, NIC_SRAM_DATA_SIG, &val);
+	if (val == NIC_SRAM_DATA_SIG_MAGIC) {
+		u32 nic_cfg;
+
+		tg3_read_mem(tp, NIC_SRAM_DATA_CFG, &nic_cfg);
+
+		eeprom_signature_found = 1;
+
+		if ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==
+		    NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER) {
+			eeprom_phy_id = PHY_ID_SERDES;
+		} else {
+			u32 nic_phy_id;
+
+			tg3_read_mem(tp, NIC_SRAM_DATA_PHY_ID, &nic_phy_id);
+			if (nic_phy_id != 0) {
+				u32 id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;
+				u32 id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;
+
+				eeprom_phy_id  = (id1 >> 16) << 10;
+				eeprom_phy_id |= (id2 & 0xfc00) << 16;
+				eeprom_phy_id |= (id2 & 0x03ff) <<  0;
+			}
+		}
+
+		switch (nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK) {
+		case NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD:
+			eeprom_led_mode = led_mode_three_link;
+			break;
+
+		case NIC_SRAM_DATA_CFG_LED_LINK_SPD:
+			eeprom_led_mode = led_mode_link10;
+			break;
+
+		default:
+			eeprom_led_mode = led_mode_auto;
+			break;
+		};
+	}
+
+	err = tg3_phy_reset(tp, 0);
+	if (err)
+		return err;
+
+	/* Now read the physical PHY_ID from the chip and verify
+	 * that it is sane.  If it doesn't look good, we fall back
+	 * to either the hard-coded table based PHY_ID and failing
+	 * that the value found in the eeprom area.
+	 */
+	err  = tg3_readphy(tp, MII_PHYSID1, &hw_phy_id_1);
+	err |= tg3_readphy(tp, MII_PHYSID2, &hw_phy_id_2);
+
+	hw_phy_id  = (hw_phy_id_1 & 0xffff) << 10;
+	hw_phy_id |= (hw_phy_id_2 & 0xfc00) << 16;
+	hw_phy_id |= (hw_phy_id_2 & 0x03ff) <<  0;
+
+	hw_phy_id_masked = hw_phy_id & PHY_ID_MASK;
+
+	if (!err && KNOWN_PHY_ID(hw_phy_id_masked)) {
+		tp->phy_id = hw_phy_id;
+	} else {
+		/* phy_id currently holds the value found in the
+		 * subsys_id_to_phy_id[] table or PHY_ID_INVALID
+		 * if a match was not found there.
+		 */
+		if (tp->phy_id == PHY_ID_INVALID) {
+			if (!eeprom_signature_found ||
+			    !KNOWN_PHY_ID(eeprom_phy_id & PHY_ID_MASK))
+				return -ENODEV;
+			tp->phy_id = eeprom_phy_id;
+		}
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x201f);
+		tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x2aaa);
+	}
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)
+		tp->tg3_flags |= TG3_FLAG_PHY_RESET_ON_INIT;
+
+	if (tp->tg3_flags & TG3_FLAG_PHY_RESET_ON_INIT) {
+		u32 mii_tg3_ctrl;
+
+		err = tg3_phy_reset(tp, 1);
+		if (err)
+			return err;
+
+		/* These chips, when reset, only advertise 10Mb capabilities.
+		 * Fix that.
+		 */
+		err  = tg3_writephy(tp, MII_ADVERTISE,
+				    (ADVERTISE_CSMA |
+				     ADVERTISE_10HALF | ADVERTISE_10FULL |
+				     ADVERTISE_100HALF | ADVERTISE_100FULL));
+		mii_tg3_ctrl = (MII_TG3_CTRL_ADV_1000_HALF |
+				MII_TG3_CTRL_ADV_1000_FULL |
+				MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER);
+		if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+			mii_tg3_ctrl = 0;
+
+		err |= tg3_writephy(tp, MII_TG3_CTRL, mii_tg3_ctrl);
+		err |= tg3_writephy(tp, MII_BMCR,
+				    (BMCR_ANRESTART | BMCR_ANENABLE));
+	}
+
+	if (!err && ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401)) {
+		err = tg3_init_5401phy_dsp(tp);
+	}
+
+	/* Determine the PHY led mode. */
+	if (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL) {
+		tp->led_mode = led_mode_link10;
+	} else {
+		tp->led_mode = led_mode_three_link;
+		if (eeprom_signature_found &&
+		    eeprom_led_mode != led_mode_auto)
+			tp->led_mode = eeprom_led_mode;
+	}
+
+	if (tp->phy_id == PHY_ID_SERDES)
+		tp->link_config.advertising =
+			(ADVERTISED_1000baseT_Half |
+			 ADVERTISED_1000baseT_Full |
+			 ADVERTISED_Autoneg |
+			 ADVERTISED_FIBRE);
+	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+		tp->link_config.advertising &=
+			~(ADVERTISED_1000baseT_Half |
+			  ADVERTISED_1000baseT_Full);
+
+	return err;
+}
+
+static void __devinit tg3_read_partno(struct tg3 *tp)
+{
+	unsigned char vpd_data[256];
+	int i;
+
+	for (i = 0; i < 256; i += 4) {
+		u32 tmp;
+
+		if (tg3_nvram_read(tp, 0x100 + i, &tmp))
+			goto out_not_found;
+
+		vpd_data[i + 0] = ((tmp >>  0) & 0xff);
+		vpd_data[i + 1] = ((tmp >>  8) & 0xff);
+		vpd_data[i + 2] = ((tmp >> 16) & 0xff);
+		vpd_data[i + 3] = ((tmp >> 24) & 0xff);
+	}
+
+	/* Now parse and find the part number. */
+	for (i = 0; i < 256; ) {
+		unsigned char val = vpd_data[i];
+		int block_end;
+
+		if (val == 0x82 || val == 0x91) {
+			i = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+			continue;
+		}
+
+		if (val != 0x90)
+			goto out_not_found;
+
+		block_end = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+		i += 3;
+		while (i < block_end) {
+			if (vpd_data[i + 0] == 'P' &&
+			    vpd_data[i + 1] == 'N') {
+				int partno_len = vpd_data[i + 2];
+
+				if (partno_len > 24)
+					goto out_not_found;
+
+				memcpy(tp->board_part_number,
+				       &vpd_data[i + 3],
+				       partno_len);
+
+				/* Success. */
+				return;
+			}
+		}
+
+		/* Part number not found. */
+		goto out_not_found;
+	}
+
+out_not_found:
+	strcpy(tp->board_part_number, "none");
+}
+
+static int __devinit tg3_get_invariants(struct tg3 *tp)
+{
+	u32 misc_ctrl_reg;
+	u32 cacheline_sz_reg;
+	u32 pci_state_reg, grc_misc_cfg;
+	u16 pci_cmd;
+	int err;
+
+	/* Force memory write invalidate off.  If we leave it on,
+	 * then on 5700_BX chips we have to enable a workaround.
+	 * The workaround is to set the TG3PCI_DMA_RW_CTRL boundry
+	 * to match the cacheline size.  The Broadcom driver have this
+	 * workaround but turns MWI off all the times so never uses
+	 * it.  This seems to suggest that the workaround is insufficient.
+	 */
+	pci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);
+	pci_cmd &= ~PCI_COMMAND_INVALIDATE;
+	pci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);
+
+	pci_read_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			      &misc_ctrl_reg);
+
+	tp->pci_chip_rev_id = (misc_ctrl_reg >>
+			       MISC_HOST_CTRL_CHIPREV_SHIFT);
+
+	pci_read_config_dword(tp->pdev, TG3PCI_CACHELINESZ,
+			      &cacheline_sz_reg);
+
+	tp->pci_cacheline_sz = (cacheline_sz_reg >>  0) & 0xff;
+	tp->pci_lat_timer    = (cacheline_sz_reg >>  8) & 0xff;
+	tp->pci_hdr_type     = (cacheline_sz_reg >> 16) & 0xff;
+	tp->pci_bist         = (cacheline_sz_reg >> 24) & 0xff;
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703 &&
+	    tp->pci_lat_timer < 64) {
+		tp->pci_lat_timer = 64;
+
+		cacheline_sz_reg  = ((tp->pci_cacheline_sz & 0xff) <<  0);
+		cacheline_sz_reg |= ((tp->pci_lat_timer    & 0xff) <<  8);
+		cacheline_sz_reg |= ((tp->pci_hdr_type     & 0xff) << 16);
+		cacheline_sz_reg |= ((tp->pci_bist         & 0xff) << 24);
+
+		pci_write_config_dword(tp->pdev, TG3PCI_CACHELINESZ,
+				       cacheline_sz_reg);
+	}
+
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,
+			      &pci_state_reg);
+
+	if ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0) {
+		tp->tg3_flags |= TG3_FLAG_PCIX_MODE;
+
+		/* If this is a 5700 BX chipset, and we are in PCI-X
+		 * mode, enable register write workaround.
+		 *
+		 * The workaround is to use indirect register accesses
+		 * for all chip writes not to mailbox registers.
+		 */
+		if (GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5700_BX) {
+			u32 pm_reg;
+			u16 pci_cmd;
+
+			tp->tg3_flags |= TG3_FLAG_PCIX_TARGET_HWBUG;
+
+			/* The chip can have it's power management PCI config
+			 * space registers clobbered due to this bug.
+			 * So explicitly force the chip into D0 here.
+			 */
+			pci_read_config_dword(tp->pdev, TG3PCI_PM_CTRL_STAT,
+					      &pm_reg);
+			pm_reg &= ~PCI_PM_CTRL_STATE_MASK;
+			pm_reg |= PCI_PM_CTRL_PME_ENABLE | 0 /* D0 */;
+			pci_write_config_dword(tp->pdev, TG3PCI_PM_CTRL_STAT,
+					       pm_reg);
+
+			/* Also, force SERR#/PERR# in PCI command. */
+			pci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);
+			pci_cmd |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+			pci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);
+		}
+	}
+	if ((pci_state_reg & PCISTATE_BUS_SPEED_HIGH) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_HIGH_SPEED;
+	if ((pci_state_reg & PCISTATE_BUS_32BIT) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_32BIT;
+
+	/* Force the chip into D0. */
+	err = tg3_set_power_state(tp, 0);
+	if (err)
+		return err;
+
+	/* 5700 B0 chips do not support checksumming correctly due
+	 * to hardware bugs.
+	 */
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5700_B0)
+		tp->tg3_flags |= TG3_FLAG_BROKEN_CHECKSUMS;
+
+	/* Regardless of whether checksums work or not, we configure
+	 * the StrongARM chips to not compute the pseudo header checksums
+	 * in either direction.  Because of the way Linux checksum support
+	 * works we do not need the chips to do this, and taking the load
+	 * off of the TX/RX onboard StrongARM cpus means that they will not be
+	 * the bottleneck.  Whoever wrote Broadcom's driver did not
+	 * understand the situation at all.  He could have bothered
+	 * to read Jes's Acenic driver because the logic (and this part of
+	 * the Tigon2 hardware/firmware) is pretty much identical.
+	 */
+	tp->tg3_flags |= TG3_FLAG_NO_TX_PSEUDO_CSUM;
+	tp->tg3_flags |= TG3_FLAG_NO_RX_PSEUDO_CSUM;
+
+	/* Derive initial jumbo mode from MTU assigned in
+	 * ether_setup() via the alloc_etherdev() call
+	 */
+	if (tp->dev->mtu > ETH_DATA_LEN)
+		tp->tg3_flags |= TG3_FLAG_JUMBO_ENABLE;
+
+	/* Determine WakeOnLan speed to use. */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B2) {
+		tp->tg3_flags &= ~(TG3_FLAG_WOL_SPEED_100MB);
+	} else {
+		tp->tg3_flags |= TG3_FLAG_WOL_SPEED_100MB;
+	}
+
+	/* Only 5701 and later support tagged irq status mode. */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700) {
+		tp->tg3_flags |= TG3_FLAG_TAGGED_IRQ_STATUS;
+		tp->misc_host_ctrl |= MISC_HOST_CTRL_TAGGED_STATUS;
+
+		/* ??? Due to a glitch Broadcom's driver ALWAYS sets
+		 * ??? these bits in coalesce_mode.  Because MM_GetConfig
+		 * ??? always sets pDevice->UseTaggedStatus correctly
+		 * ??? the following test at tigon3.c:LM_GetAdapterInfo()
+		 * ???
+		 * ???   pDevice->UseTaggedStatus &&
+		 * ???   (pDevice->ChipRevId == T3_CHIP_ID_5700_C0 ||
+		 * ???    T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_AX ||
+		 * ???    T3_CHIP_REV(pDevice->ChipRevId) == T3_CHIP_REV_5700_BX)
+		 * ???
+		 * ??? will never pass and thus pDevice->CoalesceMode will never
+		 * ??? get set to zero.  For now I'll mirror what I believe is
+		 * ??? the intention of their driver.
+		 * ???
+		 * ??? Update: This is fixed in Broadcom's 2.2.3 and later
+		 * ???         drivers.  All the current 2.0.x drivers still
+		 * ???         have the bug.
+		 */
+		tp->coalesce_mode = (HOSTCC_MODE_CLRTICK_RXBD |
+				     HOSTCC_MODE_CLRTICK_TXBD);
+	} else {
+		tp->coalesce_mode = 0;
+
+		/* If not using tagged status, set the *_during_int
+		 * coalesce default config values to zero.
+		 */
+		tp->coalesce_config.rx_coalesce_ticks_during_int_def = 0;
+		tp->coalesce_config.rx_max_coalesced_frames_during_int_def = 0;
+		tp->coalesce_config.tx_coalesce_ticks_during_int_def = 0;
+		tp->coalesce_config.tx_max_coalesced_frames_during_int_def = 0;
+	}
+
+	if (GET_CHIP_REV(tp->pci_chip_rev_id) != CHIPREV_5700_AX &&
+	    GET_CHIP_REV(tp->pci_chip_rev_id) != CHIPREV_5700_BX)
+		tp->coalesce_mode |= HOSTCC_MODE_32BYTE;
+
+	/* Initialize misc host control in PCI block. */
+	tp->misc_host_ctrl |= (misc_ctrl_reg &
+			       MISC_HOST_CTRL_CHIPREV);
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	/* Initialize MAC MI mode, polling disabled. */
+	tw32(MAC_MI_MODE, tp->mi_mode);
+	udelay(40);
+
+	/* Initialize data/descriptor byte/word swapping. */
+	tw32(GRC_MODE, tp->grc_mode);
+
+	/* Clear these out for sanity. */
+	tw32(TG3PCI_CLOCK_CTRL, 0);
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,
+			      &pci_state_reg);
+	if ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_TARGET_HWBUG) == 0) {
+		u32 chiprevid = GET_CHIP_REV_ID(tp->misc_host_ctrl);
+
+		if (chiprevid == CHIPREV_ID_5701_A0 ||
+		    chiprevid == CHIPREV_ID_5701_B0 ||
+		    chiprevid == CHIPREV_ID_5701_B2 ||
+		    chiprevid == CHIPREV_ID_5701_B5) {
+			unsigned long sram_base;
+
+			/* Write some dummy words into the SRAM status block
+			 * area, see if it reads back correctly.  If the return
+			 * value is bad, force enable the PCIX workaround.
+			 */
+			sram_base = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_STATS_BLK;
+
+			writel(0x00000000, sram_base);
+			writel(0x00000000, sram_base + 4);
+			writel(0xffffffff, sram_base + 4);
+			if (readl(sram_base) != 0x00000000)
+				tp->tg3_flags |= TG3_FLAG_PCIX_TARGET_HWBUG;
+		}
+	}
+
+	udelay(50);
+	tg3_nvram_init(tp);
+
+	/* Determine if TX descriptors will reside in
+	 * main memory or in the chip SRAM.
+	 */
+	if (tp->tg3_flags & TG3_FLAG_PCIX_TARGET_HWBUG)
+		tp->tg3_flags |= TG3_FLAG_HOST_TXDS;
+
+	/* Quick sanity check.  Make sure we see an expected
+	 * value here.
+	 */
+	grc_misc_cfg = tr32(GRC_MISC_CFG);
+	grc_misc_cfg &= GRC_MISC_CFG_BOARD_ID_MASK;
+	if (grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5700 &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5701 &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5702FE &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5703 &&
+	    grc_misc_cfg != GRC_MISC_CFG_BOARD_ID_5703S)
+		return -ENODEV;
+
+	/* ROFL, you should see Broadcom's driver code implementing
+	 * this, stuff like "if (a || b)" where a and b are always
+	 * mutually exclusive.  DaveM finds like 6 bugs today, hello!
+	 */
+	if (grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5702FE)
+		tp->tg3_flags |= TG3_FLAG_10_100_ONLY;
+
+	err = tg3_phy_probe(tp);
+
+	tg3_read_partno(tp);
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->tg3_flags &= ~TG3_FLAG_USE_MI_INTERRUPT;
+
+		/* And override led_mode in case Dell ever makes
+		 * a fibre board.
+		 */
+		tp->led_mode = led_mode_three_link;
+	} else {
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700)
+			tp->tg3_flags |= TG3_FLAG_USE_MI_INTERRUPT;
+		else
+			tp->tg3_flags &= ~TG3_FLAG_USE_MI_INTERRUPT;
+	}
+
+	/* 5700 {AX,BX} chips have a broken status block link
+	 * change bit implementation, so we must use the
+	 * status register in those cases.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700)
+		tp->tg3_flags |= TG3_FLAG_USE_LINKCHG_REG;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_USE_LINKCHG_REG;
+
+	/* The led_mode is set during tg3_phy_probe, here we might
+	 * have to force the link status polling mechanism based
+	 * upon subsystem IDs.
+	 */
+	if (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&
+	    tp->phy_id != PHY_ID_SERDES) {
+		tp->tg3_flags |= (TG3_FLAG_USE_MI_INTERRUPT |
+				  TG3_FLAG_USE_LINKCHG_REG);
+	}
+
+	/* 5700 BX chips need to have their TX producer index mailboxes
+	 * written twice to workaround a bug.
+	 */
+	if (GET_CHIP_REV(tp->pci_chip_rev_id) == CHIPREV_5700_BX)
+		tp->tg3_flags |= TG3_FLAG_TXD_MBOX_HWBUG;
+	else
+		tp->tg3_flags &= ~TG3_FLAG_TXD_MBOX_HWBUG;
+
+	/* 5700 chips can get confused if TX buffers straddle the
+	 * 4GB address boundary in some cases.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) {
+		/* ROFL!  Latest Broadcom driver disables NETIF_F_HIGHDMA
+		 * in this case instead of fixing their workaround code.
+		 *
+		 * Like, hey, there is this skb_copy() thing guys,
+		 * use it.  Oh I can't stop laughing...
+		 */
+		tp->dev->hard_start_xmit = tg3_start_xmit_4gbug;
+	} else {
+		tp->dev->hard_start_xmit = tg3_start_xmit;
+	}
+
+	tp->rx_offset = 2;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5701 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE) != 0)
+		tp->rx_offset = 0;
+
+	return err;
+}
+
+static int __devinit tg3_get_device_address(struct tg3 *tp)
+{
+	struct net_device *dev = tp->dev;
+	u32 hi, lo;
+
+	/* First try to get it from MAC address mailbox. */
+	tg3_read_mem(tp, NIC_SRAM_MAC_ADDR_HIGH_MBOX, &hi);
+	if ((hi >> 16) == 0x484b) {
+		dev->dev_addr[0] = (hi >>  8) & 0xff;
+		dev->dev_addr[1] = (hi >>  0) & 0xff;
+
+		tg3_read_mem(tp, NIC_SRAM_MAC_ADDR_LOW_MBOX, &lo);
+		dev->dev_addr[2] = (lo >> 24) & 0xff;
+		dev->dev_addr[3] = (lo >> 16) & 0xff;
+		dev->dev_addr[4] = (lo >>  8) & 0xff;
+		dev->dev_addr[5] = (lo >>  0) & 0xff;
+	}
+	/* Next, try NVRAM. */
+	else if (!tg3_nvram_read(tp, 0x7c, &hi) &&
+		 !tg3_nvram_read(tp, 0x80, &lo)) {
+		dev->dev_addr[0] = ((hi >> 16) & 0xff);
+		dev->dev_addr[1] = ((hi >> 24) & 0xff);
+		dev->dev_addr[2] = ((lo >>  0) & 0xff);
+		dev->dev_addr[3] = ((lo >>  8) & 0xff);
+		dev->dev_addr[4] = ((lo >> 16) & 0xff);
+		dev->dev_addr[5] = ((lo >> 24) & 0xff);
+	}
+	/* Finally just fetch it out of the MAC control regs. */
+	else {
+		hi = tr32(MAC_ADDR_0_HIGH);
+		lo = tr32(MAC_ADDR_0_LOW);
+
+		dev->dev_addr[5] = lo & 0xff;
+		dev->dev_addr[4] = (lo >> 8) & 0xff;
+		dev->dev_addr[3] = (lo >> 16) & 0xff;
+		dev->dev_addr[2] = (lo >> 24) & 0xff;
+		dev->dev_addr[1] = hi & 0xff;
+		dev->dev_addr[0] = (hi >> 8) & 0xff;
+	}
+
+	if (!is_valid_ether_addr(&dev->dev_addr[0]))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int __devinit tg3_do_test_dma(struct tg3 *tp, u32 *buf, dma_addr_t buf_dma, int size, int to_device)
+{
+	struct tg3_internal_buffer_desc test_desc;
+	u32 sram_dma_descs;
+	int i, ret;
+
+	sram_dma_descs = NIC_SRAM_DMA_DESC_POOL_BASE;
+
+	tw32(FTQ_RCVBD_COMP_FIFO_ENQDEQ, 0);
+	tw32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ, 0);
+	tw32(RDMAC_STATUS, 0);
+	tw32(WDMAC_STATUS, 0);
+
+	tw32(BUFMGR_MODE, 0);
+	tw32(FTQ_RESET, 0);
+
+	/* pci_alloc_consistent gives only non-DAC addresses */
+	test_desc.addr_hi = 0;
+	test_desc.addr_lo = buf_dma & 0xffffffff;
+	test_desc.nic_mbuf = 0x00002100;
+	test_desc.len = size;
+	if (to_device) {
+		test_desc.cqid_sqid = (13 << 8) | 2;
+		tw32(RDMAC_MODE, RDMAC_MODE_RESET);
+		tw32(RDMAC_MODE, RDMAC_MODE_ENABLE);
+	} else {
+		test_desc.cqid_sqid = (16 << 8) | 7;
+		tw32(WDMAC_MODE, WDMAC_MODE_RESET);
+		tw32(WDMAC_MODE, WDMAC_MODE_ENABLE);
+	}
+	test_desc.flags = 0x00000004;
+
+	for (i = 0; i < (sizeof(test_desc) / sizeof(u32)); i++) {
+		u32 val;
+
+		val = *(((u32 *)&test_desc) + i);
+		pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR,
+				       sram_dma_descs + (i * sizeof(u32)));
+		pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);
+	}
+	pci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	if (to_device) {
+		tw32(FTQ_DMA_HIGH_READ_FIFO_ENQDEQ, sram_dma_descs);
+	} else {
+		tw32(FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ, sram_dma_descs);
+	}
+
+	ret = -ENODEV;
+	for (i = 0; i < 40; i++) {
+		u32 val;
+
+		if (to_device)
+			val = tr32(FTQ_RCVBD_COMP_FIFO_ENQDEQ);
+		else
+			val = tr32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ);
+		if ((val & 0xffff) == sram_dma_descs) {
+			ret = 0;
+			break;
+		}
+
+		udelay(100);
+	}
+
+	return ret;
+}
+
+#define TEST_BUFFER_SIZE	0x400
+
+static int __devinit tg3_test_dma(struct tg3 *tp)
+{
+	dma_addr_t buf_dma;
+	u32 *buf;
+	int ret;
+
+	buf = pci_alloc_consistent(tp->pdev, TEST_BUFFER_SIZE, &buf_dma);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto out_nofree;
+	}
+
+	tw32(TG3PCI_CLOCK_CTRL, 0);
+
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) == 0) {
+		tp->dma_rwctrl =
+			(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+			(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+			(0x7 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+			(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+			(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+	} else {
+		tp->dma_rwctrl =
+			(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+			(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+			(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+			(0x3 << DMA_RWCTRL_READ_WATER_SHIFT) |
+			(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+
+		/* Wheee, some more chip bugs... */
+		if (tp->pci_chip_rev_id == CHIPREV_ID_5703_A1 ||
+		    tp->pci_chip_rev_id == CHIPREV_ID_5703_A2)
+			tp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;
+	}
+
+	/* We don't do this on x86 because it seems to hurt performace.
+	 * It does help things on other platforms though.
+	 */
+#ifndef CONFIG_X86
+	{
+		u8 byte;
+		int cacheline_size;
+		pci_read_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE, &byte);
+
+		if (byte == 0)
+			cacheline_size = 1024;
+		else
+			cacheline_size = (int) byte * 4;
+
+		tp->dma_rwctrl &= ~(DMA_RWCTRL_READ_BNDRY_MASK |
+				    DMA_RWCTRL_WRITE_BNDRY_MASK);
+
+		switch (cacheline_size) {
+		case 16:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_16 |
+				 DMA_RWCTRL_WRITE_BNDRY_16);
+			break;
+
+		case 32:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_32 |
+				 DMA_RWCTRL_WRITE_BNDRY_32);
+			break;
+
+		case 64:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_64 |
+				 DMA_RWCTRL_WRITE_BNDRY_64);
+			break;
+
+		case 128:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_128 |
+				 DMA_RWCTRL_WRITE_BNDRY_128);
+			break;
+
+		case 256:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_256 |
+				 DMA_RWCTRL_WRITE_BNDRY_256);
+			break;
+
+		case 512:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_512 |
+				 DMA_RWCTRL_WRITE_BNDRY_512);
+			break;
+
+		case 1024:
+			tp->dma_rwctrl |=
+				(DMA_RWCTRL_READ_BNDRY_1024 |
+				 DMA_RWCTRL_WRITE_BNDRY_1024);
+			break;
+		};
+	}
+#endif
+
+	/* Remove this if it causes problems for some boards. */
+	tp->dma_rwctrl |= DMA_RWCTRL_USE_MEM_READ_MULT;
+
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700 &&
+	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701)
+		return 0;
+
+	ret = 0;
+	while (1) {
+		u32 *p, i;
+
+		p = buf;
+		for (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++)
+			p[i] = i;
+
+		/* Send the buffer to the chip. */
+		ret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, 1);
+		if (ret)
+			break;
+
+		p = buf;
+		for (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++)
+			p[i] = 0;
+
+		/* Now read it back. */
+		ret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, 0);
+		if (ret)
+			break;
+
+		/* Verify it. */
+		p = buf;
+		for (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++) {
+			if (p[i] == i)
+				continue;
+
+			if ((tp->dma_rwctrl & DMA_RWCTRL_WRITE_BNDRY_MASK) ==
+			    DMA_RWCTRL_WRITE_BNDRY_DISAB) {
+				tp->dma_rwctrl |= DMA_RWCTRL_WRITE_BNDRY_16;
+				tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+				break;
+			} else {
+				ret = -ENODEV;
+				goto out;
+			}
+		}
+
+		if (i == (TEST_BUFFER_SIZE / sizeof(u32))) {
+			/* Success. */
+			ret = 0;
+			break;
+		}
+	}
+
+out:
+	pci_free_consistent(tp->pdev, TEST_BUFFER_SIZE, buf, buf_dma);
+out_nofree:
+	return ret;
+}
+
+static void __devinit tg3_init_link_config(struct tg3 *tp)
+{
+	tp->link_config.advertising =
+		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+		 ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+		 ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+		 ADVERTISED_Autoneg | ADVERTISED_MII);
+	tp->link_config.speed = SPEED_INVALID;
+	tp->link_config.duplex = DUPLEX_INVALID;
+	tp->link_config.autoneg = AUTONEG_ENABLE;
+	netif_carrier_off(tp->dev);
+	tp->link_config.active_speed = SPEED_INVALID;
+	tp->link_config.active_duplex = DUPLEX_INVALID;
+	tp->link_config.phy_is_low_power = 0;
+	tp->link_config.orig_speed = SPEED_INVALID;
+	tp->link_config.orig_duplex = DUPLEX_INVALID;
+	tp->link_config.orig_autoneg = AUTONEG_INVALID;
+}
+
+static void __devinit tg3_init_coalesce_config(struct tg3 *tp)
+{
+	tp->coalesce_config.rx_coalesce_ticks_def = DEFAULT_RXCOL_TICKS;
+	tp->coalesce_config.rx_max_coalesced_frames_def = DEFAULT_RXMAX_FRAMES;
+	tp->coalesce_config.rx_coalesce_ticks_during_int_def =
+		DEFAULT_RXCOAL_TICK_INT;
+	tp->coalesce_config.rx_max_coalesced_frames_during_int_def =
+		DEFAULT_RXCOAL_MAXF_INT;
+	tp->coalesce_config.tx_coalesce_ticks_def = DEFAULT_TXCOL_TICKS;
+	tp->coalesce_config.tx_max_coalesced_frames_def = DEFAULT_TXMAX_FRAMES;
+	tp->coalesce_config.tx_coalesce_ticks_during_int_def =
+		DEFAULT_TXCOAL_TICK_INT;
+	tp->coalesce_config.tx_max_coalesced_frames_during_int_def =
+		DEFAULT_TXCOAL_MAXF_INT;
+	tp->coalesce_config.stats_coalesce_ticks_def =
+		DEFAULT_STAT_COAL_TICKS;
+
+	tp->coalesce_config.rx_coalesce_ticks_low =
+		LOW_RXCOL_TICKS;
+	tp->coalesce_config.rx_max_coalesced_frames_low =
+		LOW_RXMAX_FRAMES;
+	tp->coalesce_config.tx_coalesce_ticks_low =
+		LOW_TXCOL_TICKS;
+	tp->coalesce_config.tx_max_coalesced_frames_low =
+		LOW_TXMAX_FRAMES;
+
+	tp->coalesce_config.rx_coalesce_ticks_high =
+		HIGH_RXCOL_TICKS;
+	tp->coalesce_config.rx_max_coalesced_frames_high =
+		HIGH_RXMAX_FRAMES;
+	tp->coalesce_config.tx_coalesce_ticks_high =
+		HIGH_TXCOL_TICKS;
+	tp->coalesce_config.tx_max_coalesced_frames_high =
+		HIGH_TXMAX_FRAMES;
+
+	/* Active == default */
+	tp->coalesce_config.rx_coalesce_ticks =
+		tp->coalesce_config.rx_coalesce_ticks_def;
+	tp->coalesce_config.rx_max_coalesced_frames =
+		tp->coalesce_config.rx_max_coalesced_frames_def;
+	tp->coalesce_config.tx_coalesce_ticks =
+		tp->coalesce_config.tx_coalesce_ticks_def;
+	tp->coalesce_config.tx_max_coalesced_frames =
+		tp->coalesce_config.tx_max_coalesced_frames_def;
+	tp->coalesce_config.stats_coalesce_ticks =
+		tp->coalesce_config.stats_coalesce_ticks_def;
+
+	tp->coalesce_config.rate_sample_jiffies = (1 * HZ);
+	tp->coalesce_config.pkt_rate_low = 22000;
+	tp->coalesce_config.pkt_rate_high = 61000;
+
+	tp->tg3_flags |= TG3_FLAG_ADAPTIVE_RX;
+	tp->tg3_flags &= ~(TG3_FLAG_ADAPTIVE_TX);
+}
+
+static void __devinit tg3_init_bufmgr_config(struct tg3 *tp)
+{
+	tp->bufmgr_config.mbuf_read_dma_low_water =
+		DEFAULT_MB_RDMA_LOW_WATER;
+	tp->bufmgr_config.mbuf_mac_rx_low_water =
+		DEFAULT_MB_MACRX_LOW_WATER;
+	tp->bufmgr_config.mbuf_high_water =
+		DEFAULT_MB_HIGH_WATER;
+
+	tp->bufmgr_config.mbuf_read_dma_low_water_jumbo =
+		DEFAULT_MB_RDMA_LOW_WATER_JUMBO;
+	tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =
+		DEFAULT_MB_MACRX_LOW_WATER_JUMBO;
+	tp->bufmgr_config.mbuf_high_water_jumbo =
+		DEFAULT_MB_HIGH_WATER_JUMBO;
+
+	tp->bufmgr_config.dma_low_water = DEFAULT_DMA_LOW_WATER;
+	tp->bufmgr_config.dma_high_water = DEFAULT_DMA_HIGH_WATER;
+}
+
+static char * __devinit tg3_phy_string(struct tg3 *tp)
+{
+	switch (tp->phy_id & PHY_ID_MASK) {
+	case PHY_ID_BCM5400:	return "5400";
+	case PHY_ID_BCM5401:	return "5401";
+	case PHY_ID_BCM5411:	return "5411";
+	case PHY_ID_BCM5701:	return "5701";
+	case PHY_ID_BCM5703:	return "5703";
+	case PHY_ID_BCM8002:	return "8002";
+	case PHY_ID_SERDES:	return "serdes";
+	default:		return "unknown";
+	};
+}
+
+static int __devinit tg3_init_one(struct pci_dev *pdev,
+				  const struct pci_device_id *ent)
+{
+	static int tg3_version_printed = 0;
+	unsigned long tg3reg_base, tg3reg_len;
+	struct net_device *dev;
+	struct tg3 *tp;
+	int i, err, pci_using_dac, pm_cap;
+
+	if (tg3_version_printed++ == 0)
+		printk(KERN_INFO "%s", version);
+
+	err = pci_enable_device(pdev);
+	if (err) {
+		printk(KERN_ERR PFX "Cannot enable PCI device, "
+		       "aborting.\n");
+		return err;
+	}
+
+	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
+		printk(KERN_ERR PFX "Cannot find proper PCI device "
+		       "base address, aborting.\n");
+		err = -ENODEV;
+		goto err_out_disable_pdev;
+	}
+
+	err = pci_request_regions(pdev, DRV_MODULE_NAME);
+	if (err) {
+		printk(KERN_ERR PFX "Cannot obtain PCI resources, "
+		       "aborting.\n");
+		goto err_out_disable_pdev;
+	}
+
+	pci_set_master(pdev);
+
+	/* Find power-management capability. */
+	pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+	if (pm_cap == 0) {
+		printk(KERN_ERR PFX "Cannot find PowerManagement capability, "
+		       "aborting.\n");
+		goto err_out_free_res;
+	}
+
+	/* Configure DMA attributes. */
+	if (!pci_set_dma_mask(pdev, (u64) 0xffffffffffffffff)) {
+		pci_using_dac = 1;
+	} else
+	{
+		err = pci_set_dma_mask(pdev, (u64) 0xffffffff);
+		if (err) {
+			printk(KERN_ERR PFX "No usable DMA configuration, "
+			       "aborting.\n");
+			goto err_out_free_res;
+		}
+		pci_using_dac = 0;
+	}
+
+	tg3reg_base = pci_resource_start(pdev, 0);
+	tg3reg_len = pci_resource_len(pdev, 0);
+
+	dev = alloc_etherdev(sizeof(*tp));
+	if (!dev) {
+		printk(KERN_ERR PFX "Etherdev alloc failed, aborting.\n");
+		err = -ENOMEM;
+		goto err_out_free_res;
+	}
+
+	SET_MODULE_OWNER(dev);
+
+	if (pci_using_dac)
+		dev->features |= NETIF_F_HIGHDMA;
+#if TG3_VLAN_TAG_USED
+	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+	dev->vlan_rx_register = tg3_vlan_rx_register;
+	dev->vlan_rx_kill_vid = tg3_vlan_rx_kill_vid;
+#endif
+
+	tp = dev->priv;
+	tp->pdev = pdev;
+	tp->dev = dev;
+	tp->pm_cap = pm_cap;
+	tp->mac_mode = TG3_DEF_MAC_MODE;
+	tp->rx_mode = TG3_DEF_RX_MODE;
+	tp->tx_mode = TG3_DEF_TX_MODE;
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	if (tg3_debug > 0)
+		tp->msg_enable = tg3_debug;
+	else
+		tp->msg_enable = TG3_DEF_MSG_ENABLE;
+
+	/* The word/byte swap controls here control register access byte
+	 * swapping.  DMA data byte swapping is controlled in the GRC_MODE
+	 * setting below.
+	 */
+	tp->misc_host_ctrl =
+		MISC_HOST_CTRL_MASK_PCI_INT |
+		MISC_HOST_CTRL_WORD_SWAP |
+		MISC_HOST_CTRL_INDIR_ACCESS |
+		MISC_HOST_CTRL_PCISTATE_RW;
+
+	/* The NONFRM (non-frame) byte/word swap controls take effect
+	 * on descriptor entries, anything which isn't packet data.
+	 *
+	 * The StrongARM chips on the board (one for tx, one for rx)
+	 * are running in big-endian mode.
+	 */
+	tp->grc_mode = (GRC_MODE_WSWAP_DATA | GRC_MODE_BSWAP_DATA |
+			GRC_MODE_WSWAP_NONFRM_DATA);
+#ifdef __BIG_ENDIAN
+	tp->grc_mode |= GRC_MODE_BSWAP_NONFRM_DATA;
+#endif
+	spin_lock_init(&tp->lock);
+	spin_lock_init(&tp->indirect_lock);
+
+	tp->regs = (unsigned long) ioremap(tg3reg_base, tg3reg_len);
+	if (tp->regs == 0UL) {
+		printk(KERN_ERR PFX "Cannot map device registers, "
+		       "aborting.\n");
+		err = -ENOMEM;
+		goto err_out_free_dev;
+	}
+
+	tg3_init_link_config(tp);
+
+	tg3_init_coalesce_config(tp);
+
+	tg3_init_bufmgr_config(tp);
+
+	tp->rx_pending = TG3_DEF_RX_RING_PENDING;
+#if TG3_MINI_RING_WORKS
+	tp->rx_mini_pending = TG3_DEF_RX_MINI_RING_PENDING;
+#endif
+	tp->rx_jumbo_pending = TG3_DEF_RX_JUMBO_RING_PENDING;
+	tp->tx_pending = TG3_DEF_TX_RING_PENDING;
+
+	dev->open = tg3_open;
+	dev->stop = tg3_close;
+	dev->get_stats = tg3_get_stats;
+	dev->set_multicast_list = tg3_set_rx_mode;
+	dev->set_mac_address = tg3_set_mac_addr;
+	dev->do_ioctl = tg3_ioctl;
+	dev->tx_timeout = tg3_tx_timeout;
+	dev->watchdog_timeo = TG3_TX_TIMEOUT;
+	dev->change_mtu = tg3_change_mtu;
+	dev->irq = pdev->irq;
+
+	err = tg3_get_invariants(tp);
+	if (err) {
+		printk(KERN_ERR PFX "Problem fetching invariants of chip, "
+		       "aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	err = tg3_get_device_address(tp);
+	if (err) {
+		printk(KERN_ERR PFX "Could not obtain valid ethernet address, "
+		       "aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	err = tg3_test_dma(tp);
+	if (err) {
+		printk(KERN_ERR PFX "DMA engine test failed, aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	/* Tigon3 can do ipv4 only... and some chips have buggy
+	 * checksumming.
+	 */
+	if ((tp->tg3_flags & TG3_FLAG_BROKEN_CHECKSUMS) == 0) {
+		dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+		tp->tg3_flags |= TG3_FLAG_RX_CHECKSUMS;
+	} else
+		tp->tg3_flags &= ~TG3_FLAG_RX_CHECKSUMS;
+
+	err = register_netdev(dev);
+	if (err) {
+		printk(KERN_ERR PFX "Cannot register net device, "
+		       "aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	pci_set_drvdata(pdev, dev);
+
+	/* Now that we have fully setup the chip, save away a snapshot
+	 * of the PCI config space.  We need to restore this after
+	 * GRC_MISC_CFG core clock resets and some resume events.
+	 */
+	pci_save_state(tp->pdev, tp->pci_cfg_state);
+
+	printk(KERN_INFO "%s: Tigon3 [partno(%s) rev %04x PHY(%s)] (PCI%s:%s:%s) %sBaseT Ethernet ",
+	       dev->name,
+	       tp->board_part_number,
+	       tp->pci_chip_rev_id,
+	       tg3_phy_string(tp),
+	       ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "X" : ""),
+	       ((tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED) ?
+		((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "133MHz" : "66MHz") :
+		((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "100MHz" : "33MHz")),
+	       ((tp->tg3_flags & TG3_FLAG_PCI_32BIT) ? "32-bit" : "64-bit"),
+	       (tp->tg3_flags & TG3_FLAG_10_100_ONLY) ? "10/100" : "10/100/1000");
+
+	for (i = 0; i < 6; i++)
+		printk("%2.2x%c", dev->dev_addr[i],
+		       i == 5 ? '\n' : ':');
+
+	return 0;
+
+err_out_iounmap:
+	iounmap((void *) tp->regs);
+
+err_out_free_dev:
+	kfree(dev);
+
+err_out_free_res:
+	pci_release_regions(pdev);
+
+err_out_disable_pdev:
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	return err;
+}
+
+static void __devexit tg3_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+
+	if (dev) {
+		unregister_netdev(dev);
+		iounmap((void *) ((struct tg3 *)(dev->priv))->regs);
+		kfree(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
+}
+
+static int tg3_suspend(struct pci_dev *pdev, u32 state)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	if (!netif_running(dev))
+		return 0;
+
+	spin_lock_irq(&tp->lock);
+	tg3_disable_ints(tp);
+	spin_unlock_irq(&tp->lock);
+
+	netif_device_detach(dev);
+
+	spin_lock_irq(&tp->lock);
+	tg3_halt(tp);
+	spin_unlock_irq(&tp->lock);
+
+	err = tg3_set_power_state(tp, state);
+	if (err) {
+		spin_lock_irq(&tp->lock);
+
+		tg3_init_rings(tp);
+		tg3_init_hw(tp);
+
+		spin_unlock_irq(&tp->lock);
+
+		netif_device_attach(dev);
+	}
+
+	return err;
+}
+
+static int tg3_resume(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct tg3 *tp = dev->priv;
+	int err;
+
+	if (!netif_running(dev))
+		return 0;
+
+	err = tg3_set_power_state(tp, 0);
+	if (err)
+		return err;
+
+	netif_device_attach(dev);
+
+	spin_lock_irq(&tp->lock);
+
+	tg3_init_rings(tp);
+	tg3_init_hw(tp);
+	tg3_enable_ints(tp);
+
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+static struct pci_driver tg3_driver = {
+	name:		DRV_MODULE_NAME,
+	id_table:	tg3_pci_tbl,
+	probe:		tg3_init_one,
+	remove:		__devexit_p(tg3_remove_one),
+	suspend:	tg3_suspend,
+	resume:		tg3_resume
+};
+
+static int __init tg3_init(void)
+{
+	return pci_module_init(&tg3_driver);
+}
+
+static void __exit tg3_cleanup(void)
+{
+	pci_unregister_driver(&tg3_driver);
+}
+
+module_init(tg3_init);
+module_exit(tg3_cleanup);
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/tg3.h linux/drivers/net/tg3.h
--- ../ia64/linux/drivers/net/tg3.h	Wed Dec 31 17:00:00 1969
+++ linux/drivers/net/tg3.h	Thu Apr 11 17:37:03 2002
@@ -0,0 +1,1905 @@
+/* $Id: tg3.h,v 1.2 2002/04/11 23:37:03 grundler Exp $
+ * tg3.h: Definitions for Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001 Jeff Garzik (jgarzik@mandrakesoft.com)
+ */
+
+#ifndef _T3_H
+#define _T3_H
+
+#if (LINUX_VERSION_CODE < 0x020412)
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME) dma_addr_t ADDR_NAME;
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME) __u32 LEN_NAME;
+#define pci_unmap_addr(PTR, ADDR_NAME)  ((PTR)->ADDR_NAME)
+#define pci_unmap_len(PTR, LEN_NAME)    ((PTR)->LEN_NAME)
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL) (((PTR)->ADDR_NAME) = (VAL))
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL) (((PTR)->LEN_NAME) = (VAL))
+#endif
+
+
+#define TG3_64BIT_REG_HIGH		0x00UL
+#define TG3_64BIT_REG_LOW		0x04UL
+
+/* Descriptor block info. */
+#define TG3_BDINFO_HOST_ADDR		0x0UL /* 64-bit */
+#define TG3_BDINFO_MAXLEN_FLAGS		0x8UL /* 32-bit */
+#define  BDINFO_FLAGS_USE_EXT_RECV	 0x00000001 /* ext rx_buffer_desc */
+#define  BDINFO_FLAGS_DISABLED		 0x00000002
+#define  BDINFO_FLAGS_MAXLEN_MASK	 0xffff0000
+#define  BDINFO_FLAGS_MAXLEN_SHIFT	 16
+#define TG3_BDINFO_NIC_ADDR		0xcUL /* 32-bit */
+#define TG3_BDINFO_SIZE			0x10UL
+
+#define RX_COPY_THRESHOLD  		256
+
+#define RX_STD_MAX_SIZE			1536
+#define RX_JUMBO_MAX_SIZE		0xdeadbeef /* XXX */
+#if TG3_MINI_RING_WORKS
+#define RX_MINI_MAX_SIZE		256
+#endif
+
+/* First 256 bytes are a mirror of PCI config space. */
+#define TG3PCI_VENDOR			0x00000000
+#define  TG3PCI_VENDOR_BROADCOM		 0x14e4
+#define TG3PCI_DEVICE			0x00000002
+#define  TG3PCI_DEVICE_TIGON3_1		 0x1644 /* BCM5700 */
+#define  TG3PCI_DEVICE_TIGON3_2		 0x1645 /* BCM5701 */
+#define  TG3PCI_DEVICE_TIGON3_3		 0x1646 /* BCM5702 */
+#define  TG3PCI_DEVICE_TIGON3_4		 0x1647 /* BCM5703 */
+#define TG3PCI_COMMAND			0x00000004
+#define TG3PCI_STATUS			0x00000006
+#define TG3PCI_CCREVID			0x00000008
+#define TG3PCI_CACHELINESZ		0x0000000c
+#define TG3PCI_LATTIMER			0x0000000d
+#define TG3PCI_HEADERTYPE		0x0000000e
+#define TG3PCI_BIST			0x0000000f
+#define TG3PCI_BASE0_LOW		0x00000010
+#define TG3PCI_BASE0_HIGH		0x00000014
+/* 0x18 --> 0x2c unused */
+#define TG3PCI_SUBSYSVENID		0x0000002c
+#define TG3PCI_SUBSYSID			0x0000002e
+#define TG3PCI_ROMADDR			0x00000030
+#define TG3PCI_CAPLIST			0x00000034
+/* 0x35 --> 0x3c unused */
+#define TG3PCI_IRQ_LINE			0x0000003c
+#define TG3PCI_IRQ_PIN			0x0000003d
+#define TG3PCI_MIN_GNT			0x0000003e
+#define TG3PCI_MAX_LAT			0x0000003f
+#define TG3PCI_X_CAPS			0x00000040
+#define  PCIX_CAPS_RELAXED_ORDERING	 0x00020000
+#define TG3PCI_PM_CAP_PTR		0x00000041
+#define TG3PCI_X_COMMAND		0x00000042
+#define TG3PCI_X_STATUS			0x00000044
+#define TG3PCI_PM_CAP_ID		0x00000048
+#define TG3PCI_VPD_CAP_PTR		0x00000049
+#define TG3PCI_PM_CAPS			0x0000004a
+#define TG3PCI_PM_CTRL_STAT		0x0000004c
+#define TG3PCI_BR_SUPP_EXT		0x0000004e
+#define TG3PCI_PM_DATA			0x0000004f
+#define TG3PCI_VPD_CAP_ID		0x00000050
+#define TG3PCI_MSI_CAP_PTR		0x00000051
+#define TG3PCI_VPD_ADDR_FLAG		0x00000052
+#define  VPD_ADDR_FLAG_WRITE		0x00008000
+#define TG3PCI_VPD_DATA			0x00000054
+#define TG3PCI_MSI_CAP_ID		0x00000058
+#define TG3PCI_NXT_CAP_PTR		0x00000059
+#define TG3PCI_MSI_CTRL			0x0000005a
+#define TG3PCI_MSI_ADDR_LOW		0x0000005c
+#define TG3PCI_MSI_ADDR_HIGH		0x00000060
+#define TG3PCI_MSI_DATA			0x00000064
+/* 0x66 --> 0x68 unused */
+#define TG3PCI_MISC_HOST_CTRL		0x00000068
+#define  MISC_HOST_CTRL_CLEAR_INT	 0x00000001
+#define  MISC_HOST_CTRL_MASK_PCI_INT	 0x00000002
+#define  MISC_HOST_CTRL_BYTE_SWAP	 0x00000004
+#define  MISC_HOST_CTRL_WORD_SWAP	 0x00000008
+#define  MISC_HOST_CTRL_PCISTATE_RW	 0x00000010
+#define  MISC_HOST_CTRL_CLKREG_RW	 0x00000020
+#define  MISC_HOST_CTRL_REGWORD_SWAP	 0x00000040
+#define  MISC_HOST_CTRL_INDIR_ACCESS	 0x00000080
+#define  MISC_HOST_CTRL_IRQ_MASK_MODE	 0x00000100
+#define  MISC_HOST_CTRL_TAGGED_STATUS	 0x00000200
+#define  MISC_HOST_CTRL_CHIPREV		 0xffff0000
+#define  MISC_HOST_CTRL_CHIPREV_SHIFT	 16
+#define  GET_CHIP_REV_ID(MISC_HOST_CTRL) \
+	 (((MISC_HOST_CTRL) & MISC_HOST_CTRL_CHIPREV) >> \
+	  MISC_HOST_CTRL_CHIPREV_SHIFT)
+#define  CHIPREV_ID_5700_A0		 0x7000
+#define  CHIPREV_ID_5700_A1		 0x7001
+#define  CHIPREV_ID_5700_B0		 0x7100
+#define  CHIPREV_ID_5700_B1		 0x7101
+#define  CHIPREV_ID_5700_B3		 0x7102
+#define  CHIPREV_ID_5700_C0		 0x7200
+#define  CHIPREV_ID_5701_A0		 0x0000
+#define  CHIPREV_ID_5701_B0		 0x0100
+#define  CHIPREV_ID_5701_B2		 0x0102
+#define  CHIPREV_ID_5701_B5		 0x0105
+#define  CHIPREV_ID_5703_A0		 0x1000
+#define  CHIPREV_ID_5703_A1		 0x1001
+#define  CHIPREV_ID_5703_A2		 0x1002
+#define  GET_ASIC_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 12)
+#define   ASIC_REV_5700			 0x07
+#define   ASIC_REV_5701			 0x00
+#define   ASIC_REV_5703			 0x01
+#define  GET_CHIP_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 8)
+#define   CHIPREV_5700_AX		 0x70
+#define   CHIPREV_5700_BX		 0x71
+#define   CHIPREV_5700_CX		 0x72
+#define   CHIPREV_5701_AX		 0x00
+#define  GET_METAL_REV(CHIP_REV_ID)	((CHIP_REV_ID) & 0xff)
+#define   METAL_REV_A0			 0x00
+#define   METAL_REV_A1			 0x01
+#define   METAL_REV_B0			 0x00
+#define   METAL_REV_B1			 0x01
+#define   METAL_REV_B2			 0x02
+#define TG3PCI_DMA_RW_CTRL		0x0000006c
+#define  DMA_RWCTRL_MIN_DMA		 0x000000ff
+#define  DMA_RWCTRL_MIN_DMA_SHIFT	 0
+#define  DMA_RWCTRL_READ_BNDRY_MASK	 0x00000700
+#define  DMA_RWCTRL_READ_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_READ_BNDRY_16	 0x00000100
+#define  DMA_RWCTRL_READ_BNDRY_32	 0x00000200
+#define  DMA_RWCTRL_READ_BNDRY_64	 0x00000300
+#define  DMA_RWCTRL_READ_BNDRY_128	 0x00000400
+#define  DMA_RWCTRL_READ_BNDRY_256	 0x00000500
+#define  DMA_RWCTRL_READ_BNDRY_512	 0x00000600
+#define  DMA_RWCTRL_READ_BNDRY_1024	 0x00000700
+#define  DMA_RWCTRL_WRITE_BNDRY_MASK	 0x00003800
+#define  DMA_RWCTRL_WRITE_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_WRITE_BNDRY_16	 0x00000800
+#define  DMA_RWCTRL_WRITE_BNDRY_32	 0x00001000
+#define  DMA_RWCTRL_WRITE_BNDRY_64	 0x00001800
+#define  DMA_RWCTRL_WRITE_BNDRY_128	 0x00002000
+#define  DMA_RWCTRL_WRITE_BNDRY_256	 0x00002800
+#define  DMA_RWCTRL_WRITE_BNDRY_512	 0x00003000
+#define  DMA_RWCTRL_WRITE_BNDRY_1024	 0x00003800
+#define  DMA_RWCTRL_ONE_DMA		 0x00004000
+#define  DMA_RWCTRL_READ_WATER		 0x00070000
+#define  DMA_RWCTRL_READ_WATER_SHIFT	 16
+#define  DMA_RWCTRL_WRITE_WATER		 0x00380000
+#define  DMA_RWCTRL_WRITE_WATER_SHIFT	 19
+#define  DMA_RWCTRL_USE_MEM_READ_MULT	 0x00400000
+#define  DMA_RWCTRL_ASSERT_ALL_BE	 0x00800000
+#define  DMA_RWCTRL_PCI_READ_CMD	 0x0f000000
+#define  DMA_RWCTRL_PCI_READ_CMD_SHIFT	 24
+#define  DMA_RWCTRL_PCI_WRITE_CMD	 0xf0000000
+#define  DMA_RWCTRL_PCI_WRITE_CMD_SHIFT	 28
+#define TG3PCI_PCISTATE			0x00000070
+#define  PCISTATE_FORCE_RESET		 0x00000001
+#define  PCISTATE_INT_NOT_ACTIVE	 0x00000002
+#define  PCISTATE_CONV_PCI_MODE		 0x00000004
+#define  PCISTATE_BUS_SPEED_HIGH	 0x00000008
+#define  PCISTATE_BUS_32BIT		 0x00000010
+#define  PCISTATE_ROM_ENABLE		 0x00000020
+#define  PCISTATE_ROM_RETRY_ENABLE	 0x00000040
+#define  PCISTATE_FLAT_VIEW		 0x00000100
+#define TG3PCI_CLOCK_CTRL		0x00000074
+#define  CLOCK_CTRL_CORECLK_DISABLE	 0x00000200
+#define  CLOCK_CTRL_RXCLK_DISABLE	 0x00000400
+#define  CLOCK_CTRL_TXCLK_DISABLE	 0x00000800
+#define  CLOCK_CTRL_ALTCLK		 0x00001000
+#define  CLOCK_CTRL_PWRDOWN_PLL133	 0x00008000
+#define  CLOCK_CTRL_44MHZ_CORE		 0x00040000
+#define  CLOCK_CTRL_DELAY_PCI_GRANT	 0x80000000
+#define TG3PCI_REG_BASE_ADDR		0x00000078
+#define TG3PCI_MEM_WIN_BASE_ADDR	0x0000007c
+#define TG3PCI_REG_DATA			0x00000080
+#define TG3PCI_MEM_WIN_DATA		0x00000084
+#define TG3PCI_MODE_CTRL		0x00000088
+#define TG3PCI_MISC_CFG			0x0000008c
+#define TG3PCI_MISC_LOCAL_CTRL		0x00000090
+/* 0x94 --> 0x98 unused */
+#define TG3PCI_STD_RING_PROD_IDX	0x00000098 /* 64-bit */
+#define TG3PCI_RCV_RET_RING_CON_IDX	0x000000a0 /* 64-bit */
+#define TG3PCI_SND_PROD_IDX		0x000000a8 /* 64-bit */
+/* 0xb0 --> 0x100 unused */
+
+/* 0x100 --> 0x200 unused */
+
+/* Mailbox registers */
+#define MAILBOX_INTERRUPT_0		0x00000200 /* 64-bit */
+#define MAILBOX_INTERRUPT_1		0x00000208 /* 64-bit */
+#define MAILBOX_INTERRUPT_2		0x00000210 /* 64-bit */
+#define MAILBOX_INTERRUPT_3		0x00000218 /* 64-bit */
+#define MAILBOX_GENERAL_0		0x00000220 /* 64-bit */
+#define MAILBOX_GENERAL_1		0x00000228 /* 64-bit */
+#define MAILBOX_GENERAL_2		0x00000230 /* 64-bit */
+#define MAILBOX_GENERAL_3		0x00000238 /* 64-bit */
+#define MAILBOX_GENERAL_4		0x00000240 /* 64-bit */
+#define MAILBOX_GENERAL_5		0x00000248 /* 64-bit */
+#define MAILBOX_GENERAL_6		0x00000250 /* 64-bit */
+#define MAILBOX_GENERAL_7		0x00000258 /* 64-bit */
+#define MAILBOX_RELOAD_STAT		0x00000260 /* 64-bit */
+#define MAILBOX_RCV_STD_PROD_IDX	0x00000268 /* 64-bit */
+#define MAILBOX_RCV_JUMBO_PROD_IDX	0x00000270 /* 64-bit */
+#define MAILBOX_RCV_MINI_PROD_IDX	0x00000278 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_0	0x00000280 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_1	0x00000288 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_2	0x00000290 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_3	0x00000298 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_4	0x000002a0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_5	0x000002a8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_6	0x000002b0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_7	0x000002b8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_8	0x000002c0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_9	0x000002c8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_10	0x000002d0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_11	0x000002d8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_12	0x000002e0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_13	0x000002e8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_14	0x000002f0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_15	0x000002f8 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_0	0x00000300 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_1	0x00000308 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_2	0x00000310 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_3	0x00000318 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_4	0x00000320 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_5	0x00000328 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_6	0x00000330 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_7	0x00000338 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_8	0x00000340 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_9	0x00000348 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_10	0x00000350 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_11	0x00000358 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_12	0x00000360 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_13	0x00000368 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_14	0x00000370 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_15	0x00000378 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_0	0x00000380 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_1	0x00000388 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_2	0x00000390 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_3	0x00000398 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_4	0x000003a0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_5	0x000003a8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_6	0x000003b0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_7	0x000003b8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_8	0x000003c0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_9	0x000003c8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_10	0x000003d0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_11	0x000003d8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_12	0x000003e0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_13	0x000003e8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_14	0x000003f0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_15	0x000003f8 /* 64-bit */
+
+/* MAC control registers */
+#define MAC_MODE			0x00000400
+#define  MAC_MODE_RESET			 0x00000001
+#define  MAC_MODE_HALF_DUPLEX		 0x00000002
+#define  MAC_MODE_PORT_MODE_MASK	 0x0000000c
+#define  MAC_MODE_PORT_MODE_TBI		 0x0000000c
+#define  MAC_MODE_PORT_MODE_GMII	 0x00000008
+#define  MAC_MODE_PORT_MODE_MII		 0x00000004
+#define  MAC_MODE_PORT_MODE_NONE	 0x00000000
+#define  MAC_MODE_PORT_INT_LPBACK	 0x00000010
+#define  MAC_MODE_TAGGED_MAC_CTRL	 0x00000080
+#define  MAC_MODE_TX_BURSTING		 0x00000100
+#define  MAC_MODE_MAX_DEFER		 0x00000200
+#define  MAC_MODE_LINK_POLARITY		 0x00000400
+#define  MAC_MODE_RXSTAT_ENABLE		 0x00000800
+#define  MAC_MODE_RXSTAT_CLEAR		 0x00001000
+#define  MAC_MODE_RXSTAT_FLUSH		 0x00002000
+#define  MAC_MODE_TXSTAT_ENABLE		 0x00004000
+#define  MAC_MODE_TXSTAT_CLEAR		 0x00008000
+#define  MAC_MODE_TXSTAT_FLUSH		 0x00010000
+#define  MAC_MODE_SEND_CONFIGS		 0x00020000
+#define  MAC_MODE_MAGIC_PKT_ENABLE	 0x00040000
+#define  MAC_MODE_ACPI_ENABLE		 0x00080000
+#define  MAC_MODE_MIP_ENABLE		 0x00100000
+#define  MAC_MODE_TDE_ENABLE		 0x00200000
+#define  MAC_MODE_RDE_ENABLE		 0x00400000
+#define  MAC_MODE_FHDE_ENABLE		 0x00800000
+#define MAC_STATUS			0x00000404
+#define  MAC_STATUS_PCS_SYNCED		 0x00000001
+#define  MAC_STATUS_SIGNAL_DET		 0x00000002
+#define  MAC_STATUS_RCVD_CFG		 0x00000004
+#define  MAC_STATUS_CFG_CHANGED		 0x00000008
+#define  MAC_STATUS_SYNC_CHANGED	 0x00000010
+#define  MAC_STATUS_PORT_DEC_ERR	 0x00000400
+#define  MAC_STATUS_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_STATUS_MI_COMPLETION	 0x00400000
+#define  MAC_STATUS_MI_INTERRUPT	 0x00800000
+#define  MAC_STATUS_AP_ERROR		 0x01000000
+#define  MAC_STATUS_ODI_ERROR		 0x02000000
+#define  MAC_STATUS_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_STATUS_TXSTAT_OVERRUN	 0x08000000
+#define MAC_EVENT			0x00000408
+#define  MAC_EVENT_PORT_DECODE_ERR	 0x00000400
+#define  MAC_EVENT_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_EVENT_MI_COMPLETION	 0x00400000
+#define  MAC_EVENT_MI_INTERRUPT		 0x00800000
+#define  MAC_EVENT_AP_ERROR		 0x01000000
+#define  MAC_EVENT_ODI_ERROR		 0x02000000
+#define  MAC_EVENT_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_EVENT_TXSTAT_OVERRUN	 0x08000000
+#define MAC_LED_CTRL			0x0000040c
+#define  LED_CTRL_LNKLED_OVERRIDE	 0x00000001
+#define  LED_CTRL_1000MBPS_ON		 0x00000002
+#define  LED_CTRL_100MBPS_ON		 0x00000004
+#define  LED_CTRL_10MBPS_ON		 0x00000008
+#define  LED_CTRL_TRAFFIC_OVERRIDE	 0x00000010
+#define  LED_CTRL_TRAFFIC_BLINK		 0x00000020
+#define  LED_CTRL_TRAFFIC_LED		 0x00000040
+#define  LED_CTRL_1000MBPS_STATUS	 0x00000080
+#define  LED_CTRL_100MBPS_STATUS	 0x00000100
+#define  LED_CTRL_10MBPS_STATUS		 0x00000200
+#define  LED_CTRL_TRAFFIC_STATUS	 0x00000400
+#define  LED_CTRL_MAC_MODE		 0x00000000
+#define  LED_CTRL_PHY_MODE_1		 0x00000800
+#define  LED_CTRL_PHY_MODE_2		 0x00001000
+#define  LED_CTRL_BLINK_RATE_MASK	 0x7ff80000
+#define  LED_CTRL_BLINK_RATE_SHIFT	 19
+#define  LED_CTRL_BLINK_PER_OVERRIDE	 0x00080000
+#define  LED_CTRL_BLINK_RATE_OVERRIDE	 0x80000000
+#define MAC_ADDR_0_HIGH			0x00000410 /* upper 2 bytes */
+#define MAC_ADDR_0_LOW			0x00000414 /* lower 4 bytes */
+#define MAC_ADDR_1_HIGH			0x00000418 /* upper 2 bytes */
+#define MAC_ADDR_1_LOW			0x0000041c /* lower 4 bytes */
+#define MAC_ADDR_2_HIGH			0x00000420 /* upper 2 bytes */
+#define MAC_ADDR_2_LOW			0x00000424 /* lower 4 bytes */
+#define MAC_ADDR_3_HIGH			0x00000428 /* upper 2 bytes */
+#define MAC_ADDR_3_LOW			0x0000042c /* lower 4 bytes */
+#define MAC_ACPI_MBUF_PTR		0x00000430
+#define MAC_ACPI_LEN_OFFSET		0x00000434
+#define  ACPI_LENOFF_LEN_MASK		 0x0000ffff
+#define  ACPI_LENOFF_LEN_SHIFT		 0
+#define  ACPI_LENOFF_OFF_MASK		 0x0fff0000
+#define  ACPI_LENOFF_OFF_SHIFT		 16
+#define MAC_TX_BACKOFF_SEED		0x00000438
+#define  TX_BACKOFF_SEED_MASK		 0x000003ff
+#define MAC_RX_MTU_SIZE			0x0000043c
+#define  RX_MTU_SIZE_MASK		 0x0000ffff
+#define MAC_PCS_TEST			0x00000440
+#define  PCS_TEST_PATTERN_MASK		 0x000fffff
+#define  PCS_TEST_PATTERN_SHIFT		 0
+#define  PCS_TEST_ENABLE		 0x00100000
+#define MAC_TX_AUTO_NEG			0x00000444
+#define  TX_AUTO_NEG_MASK		 0x0000ffff
+#define  TX_AUTO_NEG_SHIFT		 0
+#define MAC_RX_AUTO_NEG			0x00000448
+#define  RX_AUTO_NEG_MASK		 0x0000ffff
+#define  RX_AUTO_NEG_SHIFT		 0
+#define MAC_MI_COM			0x0000044c
+#define  MI_COM_CMD_MASK		 0x0c000000
+#define  MI_COM_CMD_WRITE		 0x04000000
+#define  MI_COM_CMD_READ		 0x08000000
+#define  MI_COM_READ_FAILED		 0x10000000
+#define  MI_COM_START			 0x20000000
+#define  MI_COM_BUSY			 0x20000000
+#define  MI_COM_PHY_ADDR_MASK		 0x03e00000
+#define  MI_COM_PHY_ADDR_SHIFT		 21
+#define  MI_COM_REG_ADDR_MASK		 0x001f0000
+#define  MI_COM_REG_ADDR_SHIFT		 16
+#define  MI_COM_DATA_MASK		 0x0000ffff
+#define MAC_MI_STAT			0x00000450
+#define  MAC_MI_STAT_LNKSTAT_ATTN_ENAB	 0x00000001
+#define MAC_MI_MODE			0x00000454
+#define  MAC_MI_MODE_CLK_10MHZ		 0x00000001
+#define  MAC_MI_MODE_SHORT_PREAMBLE	 0x00000002
+#define  MAC_MI_MODE_AUTO_POLL		 0x00000010
+#define  MAC_MI_MODE_CORE_CLK_62MHZ	 0x00008000
+#define  MAC_MI_MODE_BASE		 0x000c0000 /* XXX magic values XXX */
+#define MAC_AUTO_POLL_STATUS		0x00000458
+#define  MAC_AUTO_POLL_ERROR		 0x00000001
+#define MAC_TX_MODE			0x0000045c
+#define  TX_MODE_RESET			 0x00000001
+#define  TX_MODE_ENABLE			 0x00000002
+#define  TX_MODE_FLOW_CTRL_ENABLE	 0x00000010
+#define  TX_MODE_BIG_BCKOFF_ENABLE	 0x00000020
+#define  TX_MODE_LONG_PAUSE_ENABLE	 0x00000040
+#define MAC_TX_STATUS			0x00000460
+#define  TX_STATUS_XOFFED		 0x00000001
+#define  TX_STATUS_SENT_XOFF		 0x00000002
+#define  TX_STATUS_SENT_XON		 0x00000004
+#define  TX_STATUS_LINK_UP		 0x00000008
+#define  TX_STATUS_ODI_UNDERRUN		 0x00000010
+#define  TX_STATUS_ODI_OVERRUN		 0x00000020
+#define MAC_TX_LENGTHS			0x00000464
+#define  TX_LENGTHS_SLOT_TIME_MASK	 0x000000ff
+#define  TX_LENGTHS_SLOT_TIME_SHIFT	 0
+#define  TX_LENGTHS_IPG_MASK		 0x00000f00
+#define  TX_LENGTHS_IPG_SHIFT		 8
+#define  TX_LENGTHS_IPG_CRS_MASK	 0x00003000
+#define  TX_LENGTHS_IPG_CRS_SHIFT	 12
+#define MAC_RX_MODE			0x00000468
+#define  RX_MODE_RESET			 0x00000001
+#define  RX_MODE_ENABLE			 0x00000002
+#define  RX_MODE_FLOW_CTRL_ENABLE	 0x00000004
+#define  RX_MODE_KEEP_MAC_CTRL		 0x00000008
+#define  RX_MODE_KEEP_PAUSE		 0x00000010
+#define  RX_MODE_ACCEPT_OVERSIZED	 0x00000020
+#define  RX_MODE_ACCEPT_RUNTS		 0x00000040
+#define  RX_MODE_LEN_CHECK		 0x00000080
+#define  RX_MODE_PROMISC		 0x00000100
+#define  RX_MODE_NO_CRC_CHECK		 0x00000200
+#define  RX_MODE_KEEP_VLAN_TAG		 0x00000400
+#define MAC_RX_STATUS			0x0000046c
+#define  RX_STATUS_REMOTE_TX_XOFFED	 0x00000001
+#define  RX_STATUS_XOFF_RCVD		 0x00000002
+#define  RX_STATUS_XON_RCVD		 0x00000004
+#define MAC_HASH_REG_0			0x00000470
+#define MAC_HASH_REG_1			0x00000474
+#define MAC_HASH_REG_2			0x00000478
+#define MAC_HASH_REG_3			0x0000047c
+#define MAC_RCV_RULE_0			0x00000480
+#define MAC_RCV_VALUE_0			0x00000484
+#define MAC_RCV_RULE_1			0x00000488
+#define MAC_RCV_VALUE_1			0x0000048c
+#define MAC_RCV_RULE_2			0x00000490
+#define MAC_RCV_VALUE_2			0x00000494
+#define MAC_RCV_RULE_3			0x00000498
+#define MAC_RCV_VALUE_3			0x0000049c
+#define MAC_RCV_RULE_4			0x000004a0
+#define MAC_RCV_VALUE_4			0x000004a4
+#define MAC_RCV_RULE_5			0x000004a8
+#define MAC_RCV_VALUE_5			0x000004ac
+#define MAC_RCV_RULE_6			0x000004b0
+#define MAC_RCV_VALUE_6			0x000004b4
+#define MAC_RCV_RULE_7			0x000004b8
+#define MAC_RCV_VALUE_7			0x000004bc
+#define MAC_RCV_RULE_8			0x000004c0
+#define MAC_RCV_VALUE_8			0x000004c4
+#define MAC_RCV_RULE_9			0x000004c8
+#define MAC_RCV_VALUE_9			0x000004cc
+#define MAC_RCV_RULE_10			0x000004d0
+#define MAC_RCV_VALUE_10		0x000004d4
+#define MAC_RCV_RULE_11			0x000004d8
+#define MAC_RCV_VALUE_11		0x000004dc
+#define MAC_RCV_RULE_12			0x000004e0
+#define MAC_RCV_VALUE_12		0x000004e4
+#define MAC_RCV_RULE_13			0x000004e8
+#define MAC_RCV_VALUE_13		0x000004ec
+#define MAC_RCV_RULE_14			0x000004f0
+#define MAC_RCV_VALUE_14		0x000004f4
+#define MAC_RCV_RULE_15			0x000004f8
+#define MAC_RCV_VALUE_15		0x000004fc
+#define  RCV_RULE_DISABLE_MASK		 0x7fffffff
+#define MAC_RCV_RULE_CFG		0x00000500
+#define  RCV_RULE_CFG_DEFAULT_CLASS	0x00000008
+/* 0x504 --> 0x590 unused */
+#define MAC_SERDES_CFG			0x00000590
+#define MAC_SERDES_STAT			0x00000594
+/* 0x598 --> 0x600 unused */
+#define MAC_TX_MAC_STATE_BASE		0x00000600 /* 16 bytes */
+#define MAC_RX_MAC_STATE_BASE		0x00000610 /* 20 bytes */
+/* 0x624 --> 0x800 unused */
+#define MAC_RX_STATS_BASE		0x00000800 /* 26 32-bit words */
+/* 0x868 --> 0x880 unused */
+#define MAC_TX_STATS_BASE		0x00000880 /* 28 32-bit words */
+/* 0x8f0 --> 0xc00 unused */
+
+/* Send data initiator control registers */
+#define SNDDATAI_MODE			0x00000c00
+#define  SNDDATAI_MODE_RESET		 0x00000001
+#define  SNDDATAI_MODE_ENABLE		 0x00000002
+#define  SNDDATAI_MODE_STAT_OFLOW_ENAB	 0x00000004
+#define SNDDATAI_STATUS			0x00000c04
+#define  SNDDATAI_STATUS_STAT_OFLOW	 0x00000004
+#define SNDDATAI_STATSCTRL		0x00000c08
+#define  SNDDATAI_SCTRL_ENABLE		 0x00000001
+#define  SNDDATAI_SCTRL_FASTUPD		 0x00000002
+#define  SNDDATAI_SCTRL_CLEAR		 0x00000004
+#define  SNDDATAI_SCTRL_FLUSH		 0x00000008
+#define  SNDDATAI_SCTRL_FORCE_ZERO	 0x00000010
+#define SNDDATAI_STATSENAB		0x00000c0c
+#define SNDDATAI_STATSINCMASK		0x00000c10
+/* 0xc14 --> 0xc80 unused */
+#define SNDDATAI_COS_CNT_0		0x00000c80
+#define SNDDATAI_COS_CNT_1		0x00000c84
+#define SNDDATAI_COS_CNT_2		0x00000c88
+#define SNDDATAI_COS_CNT_3		0x00000c8c
+#define SNDDATAI_COS_CNT_4		0x00000c90
+#define SNDDATAI_COS_CNT_5		0x00000c94
+#define SNDDATAI_COS_CNT_6		0x00000c98
+#define SNDDATAI_COS_CNT_7		0x00000c9c
+#define SNDDATAI_COS_CNT_8		0x00000ca0
+#define SNDDATAI_COS_CNT_9		0x00000ca4
+#define SNDDATAI_COS_CNT_10		0x00000ca8
+#define SNDDATAI_COS_CNT_11		0x00000cac
+#define SNDDATAI_COS_CNT_12		0x00000cb0
+#define SNDDATAI_COS_CNT_13		0x00000cb4
+#define SNDDATAI_COS_CNT_14		0x00000cb8
+#define SNDDATAI_COS_CNT_15		0x00000cbc
+#define SNDDATAI_DMA_RDQ_FULL_CNT	0x00000cc0
+#define SNDDATAI_DMA_PRIO_RDQ_FULL_CNT	0x00000cc4
+#define SNDDATAI_SDCQ_FULL_CNT		0x00000cc8
+#define SNDDATAI_NICRNG_SSND_PIDX_CNT	0x00000ccc
+#define SNDDATAI_STATS_UPDATED_CNT	0x00000cd0
+#define SNDDATAI_INTERRUPTS_CNT		0x00000cd4
+#define SNDDATAI_AVOID_INTERRUPTS_CNT	0x00000cd8
+#define SNDDATAI_SND_THRESH_HIT_CNT	0x00000cdc
+/* 0xce0 --> 0x1000 unused */
+
+/* Send data completion control registers */
+#define SNDDATAC_MODE			0x00001000
+#define  SNDDATAC_MODE_RESET		 0x00000001
+#define  SNDDATAC_MODE_ENABLE		 0x00000002
+/* 0x1004 --> 0x1400 unused */
+
+/* Send BD ring selector */
+#define SNDBDS_MODE			0x00001400
+#define  SNDBDS_MODE_RESET		 0x00000001
+#define  SNDBDS_MODE_ENABLE		 0x00000002
+#define  SNDBDS_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDS_STATUS			0x00001404
+#define  SNDBDS_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDS_HWDIAG			0x00001408
+/* 0x140c --> 0x1440 */
+#define SNDBDS_SEL_CON_IDX_0		0x00001440
+#define SNDBDS_SEL_CON_IDX_1		0x00001444
+#define SNDBDS_SEL_CON_IDX_2		0x00001448
+#define SNDBDS_SEL_CON_IDX_3		0x0000144c
+#define SNDBDS_SEL_CON_IDX_4		0x00001450
+#define SNDBDS_SEL_CON_IDX_5		0x00001454
+#define SNDBDS_SEL_CON_IDX_6		0x00001458
+#define SNDBDS_SEL_CON_IDX_7		0x0000145c
+#define SNDBDS_SEL_CON_IDX_8		0x00001460
+#define SNDBDS_SEL_CON_IDX_9		0x00001464
+#define SNDBDS_SEL_CON_IDX_10		0x00001468
+#define SNDBDS_SEL_CON_IDX_11		0x0000146c
+#define SNDBDS_SEL_CON_IDX_12		0x00001470
+#define SNDBDS_SEL_CON_IDX_13		0x00001474
+#define SNDBDS_SEL_CON_IDX_14		0x00001478
+#define SNDBDS_SEL_CON_IDX_15		0x0000147c
+/* 0x1480 --> 0x1800 unused */
+
+/* Send BD initiator control registers */
+#define SNDBDI_MODE			0x00001800
+#define  SNDBDI_MODE_RESET		 0x00000001
+#define  SNDBDI_MODE_ENABLE		 0x00000002
+#define  SNDBDI_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDI_STATUS			0x00001804
+#define  SNDBDI_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDI_IN_PROD_IDX_0		0x00001808
+#define SNDBDI_IN_PROD_IDX_1		0x0000180c
+#define SNDBDI_IN_PROD_IDX_2		0x00001810
+#define SNDBDI_IN_PROD_IDX_3		0x00001814
+#define SNDBDI_IN_PROD_IDX_4		0x00001818
+#define SNDBDI_IN_PROD_IDX_5		0x0000181c
+#define SNDBDI_IN_PROD_IDX_6		0x00001820
+#define SNDBDI_IN_PROD_IDX_7		0x00001824
+#define SNDBDI_IN_PROD_IDX_8		0x00001828
+#define SNDBDI_IN_PROD_IDX_9		0x0000182c
+#define SNDBDI_IN_PROD_IDX_10		0x00001830
+#define SNDBDI_IN_PROD_IDX_11		0x00001834
+#define SNDBDI_IN_PROD_IDX_12		0x00001838
+#define SNDBDI_IN_PROD_IDX_13		0x0000183c
+#define SNDBDI_IN_PROD_IDX_14		0x00001840
+#define SNDBDI_IN_PROD_IDX_15		0x00001844
+/* 0x1848 --> 0x1c00 unused */
+
+/* Send BD completion control registers */
+#define SNDBDC_MODE			0x00001c00
+#define SNDBDC_MODE_RESET		 0x00000001
+#define SNDBDC_MODE_ENABLE		 0x00000002
+#define SNDBDC_MODE_ATTN_ENABLE		 0x00000004
+/* 0x1c04 --> 0x2000 unused */
+
+/* Receive list placement control registers */
+#define RCVLPC_MODE			0x00002000
+#define  RCVLPC_MODE_RESET		 0x00000001
+#define  RCVLPC_MODE_ENABLE		 0x00000002
+#define  RCVLPC_MODE_CLASS0_ATTN_ENAB	 0x00000004
+#define  RCVLPC_MODE_MAPOOR_AATTN_ENAB	 0x00000008
+#define  RCVLPC_MODE_STAT_OFLOW_ENAB	 0x00000010
+#define RCVLPC_STATUS			0x00002004
+#define  RCVLPC_STATUS_CLASS0		 0x00000004
+#define  RCVLPC_STATUS_MAPOOR		 0x00000008
+#define  RCVLPC_STATUS_STAT_OFLOW	 0x00000010
+#define RCVLPC_LOCK			0x00002008
+#define  RCVLPC_LOCK_REQ_MASK		 0x0000ffff
+#define  RCVLPC_LOCK_REQ_SHIFT		 0
+#define  RCVLPC_LOCK_GRANT_MASK		 0xffff0000
+#define  RCVLPC_LOCK_GRANT_SHIFT	 16
+#define RCVLPC_NON_EMPTY_BITS		0x0000200c
+#define  RCVLPC_NON_EMPTY_BITS_MASK	 0x0000ffff
+#define RCVLPC_CONFIG			0x00002010
+#define RCVLPC_STATSCTRL		0x00002014
+#define  RCVLPC_STATSCTRL_ENABLE	 0x00000001
+#define  RCVLPC_STATSCTRL_FASTUPD	 0x00000002
+#define RCVLPC_STATS_ENABLE		0x00002018
+#define RCVLPC_STATS_INCMASK		0x0000201c
+/* 0x2020 --> 0x2100 unused */
+#define RCVLPC_SELLST_BASE		0x00002100 /* 16 16-byte entries */
+#define  SELLST_TAIL			0x00000004
+#define  SELLST_CONT			0x00000008
+#define  SELLST_UNUSED			0x0000000c
+#define RCVLPC_COS_CNTL_BASE		0x00002200 /* 16 4-byte entries */
+#define RCVLPC_DROP_FILTER_CNT		0x00002240
+#define RCVLPC_DMA_WQ_FULL_CNT		0x00002244
+#define RCVLPC_DMA_HIPRIO_WQ_FULL_CNT	0x00002248
+#define RCVLPC_NO_RCV_BD_CNT		0x0000224c
+#define RCVLPC_IN_DISCARDS_CNT		0x00002250
+#define RCVLPC_IN_ERRORS_CNT		0x00002254
+#define RCVLPC_RCV_THRESH_HIT_CNT	0x00002258
+/* 0x225c --> 0x2400 unused */
+
+/* Receive Data and Receive BD Initiator Control */
+#define RCVDBDI_MODE			0x00002400
+#define  RCVDBDI_MODE_RESET		 0x00000001
+#define  RCVDBDI_MODE_ENABLE		 0x00000002
+#define  RCVDBDI_MODE_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_MODE_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_MODE_INV_RING_SZ	 0x00000010
+#define RCVDBDI_STATUS			0x00002404
+#define  RCVDBDI_STATUS_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_STATUS_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_STATUS_INV_RING_SZ	 0x00000010
+#define RCVDBDI_SPLIT_FRAME_MINSZ	0x00002408
+/* 0x240c --> 0x2440 unused */
+#define RCVDBDI_JUMBO_BD		0x00002440 /* TG3_BDINFO_... */
+#define RCVDBDI_STD_BD			0x00002450 /* TG3_BDINFO_... */
+#define RCVDBDI_MINI_BD			0x00002460 /* TG3_BDINFO_... */
+#define RCVDBDI_JUMBO_CON_IDX		0x00002470
+#define RCVDBDI_STD_CON_IDX		0x00002474
+#define RCVDBDI_MINI_CON_IDX		0x00002478
+/* 0x247c --> 0x2480 unused */
+#define RCVDBDI_BD_PROD_IDX_0		0x00002480
+#define RCVDBDI_BD_PROD_IDX_1		0x00002484
+#define RCVDBDI_BD_PROD_IDX_2		0x00002488
+#define RCVDBDI_BD_PROD_IDX_3		0x0000248c
+#define RCVDBDI_BD_PROD_IDX_4		0x00002490
+#define RCVDBDI_BD_PROD_IDX_5		0x00002494
+#define RCVDBDI_BD_PROD_IDX_6		0x00002498
+#define RCVDBDI_BD_PROD_IDX_7		0x0000249c
+#define RCVDBDI_BD_PROD_IDX_8		0x000024a0
+#define RCVDBDI_BD_PROD_IDX_9		0x000024a4
+#define RCVDBDI_BD_PROD_IDX_10		0x000024a8
+#define RCVDBDI_BD_PROD_IDX_11		0x000024ac
+#define RCVDBDI_BD_PROD_IDX_12		0x000024b0
+#define RCVDBDI_BD_PROD_IDX_13		0x000024b4
+#define RCVDBDI_BD_PROD_IDX_14		0x000024b8
+#define RCVDBDI_BD_PROD_IDX_15		0x000024bc
+#define RCVDBDI_HWDIAG			0x000024c0
+/* 0x24c4 --> 0x2800 unused */
+
+/* Receive Data Completion Control */
+#define RCVDCC_MODE			0x00002800
+#define  RCVDCC_MODE_RESET		 0x00000001
+#define  RCVDCC_MODE_ENABLE		 0x00000002
+#define  RCVDCC_MODE_ATTN_ENABLE	 0x00000004
+/* 0x2804 --> 0x2c00 unused */
+
+/* Receive BD Initiator Control Registers */
+#define RCVBDI_MODE			0x00002c00
+#define  RCVBDI_MODE_RESET		 0x00000001
+#define  RCVBDI_MODE_ENABLE		 0x00000002
+#define  RCVBDI_MODE_RCB_ATTN_ENAB	 0x00000004
+#define RCVBDI_STATUS			0x00002c04
+#define  RCVBDI_STATUS_RCB_ATTN		 0x00000004
+#define RCVBDI_JUMBO_PROD_IDX		0x00002c08
+#define RCVBDI_STD_PROD_IDX		0x00002c0c
+#define RCVBDI_MINI_PROD_IDX		0x00002c10
+#define RCVBDI_MINI_THRESH		0x00002c14
+#define RCVBDI_STD_THRESH		0x00002c18
+#define RCVBDI_JUMBO_THRESH		0x00002c1c
+/* 0x2c20 --> 0x3000 unused */
+
+/* Receive BD Completion Control Registers */
+#define RCVCC_MODE			0x00003000
+#define  RCVCC_MODE_RESET		 0x00000001
+#define  RCVCC_MODE_ENABLE		 0x00000002
+#define  RCVCC_MODE_ATTN_ENABLE		 0x00000004
+#define RCVCC_STATUS			0x00003004
+#define  RCVCC_STATUS_ERROR_ATTN	 0x00000004
+#define RCVCC_JUMP_PROD_IDX		0x00003008
+#define RCVCC_STD_PROD_IDX		0x0000300c
+#define RCVCC_MINI_PROD_IDX		0x00003010
+/* 0x3014 --> 0x3400 unused */
+
+/* Receive list selector control registers */
+#define RCVLSC_MODE			0x00003400
+#define  RCVLSC_MODE_RESET		 0x00000001
+#define  RCVLSC_MODE_ENABLE		 0x00000002
+#define  RCVLSC_MODE_ATTN_ENABLE	 0x00000004
+#define RCVLSC_STATUS			0x00003404
+#define  RCVLSC_STATUS_ERROR_ATTN	 0x00000004
+/* 0x3408 --> 0x3800 unused */
+
+/* Mbuf cluster free registers */
+#define MBFREE_MODE			0x00003800
+#define  MBFREE_MODE_RESET		 0x00000001
+#define  MBFREE_MODE_ENABLE		 0x00000002
+#define MBFREE_STATUS			0x00003804
+/* 0x3808 --> 0x3c00 unused */
+
+/* Host coalescing control registers */
+#define HOSTCC_MODE			0x00003c00
+#define  HOSTCC_MODE_RESET		 0x00000001
+#define  HOSTCC_MODE_ENABLE		 0x00000002
+#define  HOSTCC_MODE_ATTN		 0x00000004
+#define  HOSTCC_MODE_NOW		 0x00000008
+#define  HOSTCC_MODE_FULL_STATUS	 0x00000000
+#define  HOSTCC_MODE_64BYTE		 0x00000080
+#define  HOSTCC_MODE_32BYTE		 0x00000100
+#define  HOSTCC_MODE_CLRTICK_RXBD	 0x00000200
+#define  HOSTCC_MODE_CLRTICK_TXBD	 0x00000400
+#define  HOSTCC_MODE_NOINT_ON_NOW	 0x00000800
+#define  HOSTCC_MODE_NOINT_ON_FORCE	 0x00001000
+#define HOSTCC_STATUS			0x00003c04
+#define  HOSTCC_STATUS_ERROR_ATTN	 0x00000004
+#define HOSTCC_RXCOL_TICKS		0x00003c08
+#define  LOW_RXCOL_TICKS		 0x00000032
+#define  DEFAULT_RXCOL_TICKS		 0x00000048
+#define  HIGH_RXCOL_TICKS		 0x00000096
+#define HOSTCC_TXCOL_TICKS		0x00003c0c
+#define  LOW_TXCOL_TICKS		 0x00000096
+#define  DEFAULT_TXCOL_TICKS		 0x0000012c
+#define  HIGH_TXCOL_TICKS		 0x00000145
+#define HOSTCC_RXMAX_FRAMES		0x00003c10
+#define  LOW_RXMAX_FRAMES		 0x00000005
+#define  DEFAULT_RXMAX_FRAMES		 0x00000008
+#define  HIGH_RXMAX_FRAMES		 0x00000012
+#define HOSTCC_TXMAX_FRAMES		0x00003c14
+#define  LOW_TXMAX_FRAMES		 0x00000035
+#define  DEFAULT_TXMAX_FRAMES		 0x0000004b
+#define  HIGH_TXMAX_FRAMES		 0x00000052
+#define HOSTCC_RXCOAL_TICK_INT		0x00003c18
+#define  DEFAULT_RXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_TXCOAL_TICK_INT		0x00003c1c
+#define  DEFAULT_TXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_RXCOAL_MAXF_INT		0x00003c20
+#define  DEFAULT_RXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_TXCOAL_MAXF_INT		0x00003c24
+#define  DEFAULT_TXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_STAT_COAL_TICKS		0x00003c28
+#define  DEFAULT_STAT_COAL_TICKS	 0x000f4240
+/* 0x3c2c --> 0x3c30 unused */
+#define HOSTCC_STATS_BLK_HOST_ADDR	0x00003c30 /* 64-bit */
+#define HOSTCC_STATUS_BLK_HOST_ADDR	0x00003c38 /* 64-bit */
+#define HOSTCC_STATS_BLK_NIC_ADDR	0x00003c40
+#define HOSTCC_STATUS_BLK_NIC_ADDR	0x00003c44
+#define HOSTCC_FLOW_ATTN		0x00003c48
+/* 0x3c4c --> 0x3c50 unused */
+#define HOSTCC_JUMBO_CON_IDX		0x00003c50
+#define HOSTCC_STD_CON_IDX		0x00003c54
+#define HOSTCC_MINI_CON_IDX		0x00003c58
+/* 0x3c5c --> 0x3c80 unused */
+#define HOSTCC_RET_PROD_IDX_0		0x00003c80
+#define HOSTCC_RET_PROD_IDX_1		0x00003c84
+#define HOSTCC_RET_PROD_IDX_2		0x00003c88
+#define HOSTCC_RET_PROD_IDX_3		0x00003c8c
+#define HOSTCC_RET_PROD_IDX_4		0x00003c90
+#define HOSTCC_RET_PROD_IDX_5		0x00003c94
+#define HOSTCC_RET_PROD_IDX_6		0x00003c98
+#define HOSTCC_RET_PROD_IDX_7		0x00003c9c
+#define HOSTCC_RET_PROD_IDX_8		0x00003ca0
+#define HOSTCC_RET_PROD_IDX_9		0x00003ca4
+#define HOSTCC_RET_PROD_IDX_10		0x00003ca8
+#define HOSTCC_RET_PROD_IDX_11		0x00003cac
+#define HOSTCC_RET_PROD_IDX_12		0x00003cb0
+#define HOSTCC_RET_PROD_IDX_13		0x00003cb4
+#define HOSTCC_RET_PROD_IDX_14		0x00003cb8
+#define HOSTCC_RET_PROD_IDX_15		0x00003cbc
+#define HOSTCC_SND_CON_IDX_0		0x00003cc0
+#define HOSTCC_SND_CON_IDX_1		0x00003cc4
+#define HOSTCC_SND_CON_IDX_2		0x00003cc8
+#define HOSTCC_SND_CON_IDX_3		0x00003ccc
+#define HOSTCC_SND_CON_IDX_4		0x00003cd0
+#define HOSTCC_SND_CON_IDX_5		0x00003cd4
+#define HOSTCC_SND_CON_IDX_6		0x00003cd8
+#define HOSTCC_SND_CON_IDX_7		0x00003cdc
+#define HOSTCC_SND_CON_IDX_8		0x00003ce0
+#define HOSTCC_SND_CON_IDX_9		0x00003ce4
+#define HOSTCC_SND_CON_IDX_10		0x00003ce8
+#define HOSTCC_SND_CON_IDX_11		0x00003cec
+#define HOSTCC_SND_CON_IDX_12		0x00003cf0
+#define HOSTCC_SND_CON_IDX_13		0x00003cf4
+#define HOSTCC_SND_CON_IDX_14		0x00003cf8
+#define HOSTCC_SND_CON_IDX_15		0x00003cfc
+/* 0x3d00 --> 0x4000 unused */
+
+/* Memory arbiter control registers */
+#define MEMARB_MODE			0x00004000
+#define  MEMARB_MODE_RESET		 0x00000001
+#define  MEMARB_MODE_ENABLE		 0x00000002
+#define MEMARB_STATUS			0x00004004
+#define MEMARB_TRAP_ADDR_LOW		0x00004008
+#define MEMARB_TRAP_ADDR_HIGH		0x0000400c
+/* 0x4010 --> 0x4400 unused */
+
+/* Buffer manager control registers */
+#define BUFMGR_MODE			0x00004400
+#define  BUFMGR_MODE_RESET		 0x00000001
+#define  BUFMGR_MODE_ENABLE		 0x00000002
+#define  BUFMGR_MODE_ATTN_ENABLE	 0x00000004
+#define  BUFMGR_MODE_BM_TEST		 0x00000008
+#define  BUFMGR_MODE_MBLOW_ATTN_ENAB	 0x00000010
+#define BUFMGR_STATUS			0x00004404
+#define  BUFMGR_STATUS_ERROR		 0x00000004
+#define  BUFMGR_STATUS_MBLOW		 0x00000010
+#define BUFMGR_MB_POOL_ADDR		0x00004408
+#define BUFMGR_MB_POOL_SIZE		0x0000440c
+#define BUFMGR_MB_RDMA_LOW_WATER	0x00004410
+#define  DEFAULT_MB_RDMA_LOW_WATER	 0x00000040
+#define  DEFAULT_MB_RDMA_LOW_WATER_JUMBO 0x00000130
+#define BUFMGR_MB_MACRX_LOW_WATER	0x00004414
+#define  DEFAULT_MB_MACRX_LOW_WATER	  0x00000020
+#define  DEFAULT_MB_MACRX_LOW_WATER_JUMBO 0x00000098
+#define BUFMGR_MB_HIGH_WATER		0x00004418
+#define  DEFAULT_MB_HIGH_WATER		 0x00000060
+#define  DEFAULT_MB_HIGH_WATER_JUMBO	 0x0000017c
+#define BUFMGR_RX_MB_ALLOC_REQ		0x0000441c
+#define  BUFMGR_MB_ALLOC_BIT		 0x10000000
+#define BUFMGR_RX_MB_ALLOC_RESP		0x00004420
+#define BUFMGR_TX_MB_ALLOC_REQ		0x00004424
+#define BUFMGR_TX_MB_ALLOC_RESP		0x00004428
+#define BUFMGR_DMA_DESC_POOL_ADDR	0x0000442c
+#define BUFMGR_DMA_DESC_POOL_SIZE	0x00004430
+#define BUFMGR_DMA_LOW_WATER		0x00004434
+#define  DEFAULT_DMA_LOW_WATER		 0x00000005
+#define BUFMGR_DMA_HIGH_WATER		0x00004438
+#define  DEFAULT_DMA_HIGH_WATER		 0x0000000a
+#define BUFMGR_RX_DMA_ALLOC_REQ		0x0000443c
+#define BUFMGR_RX_DMA_ALLOC_RESP	0x00004440
+#define BUFMGR_TX_DMA_ALLOC_REQ		0x00004444
+#define BUFMGR_TX_DMA_ALLOC_RESP	0x00004448
+#define BUFMGR_HWDIAG_0			0x0000444c
+#define BUFMGR_HWDIAG_1			0x00004450
+#define BUFMGR_HWDIAG_2			0x00004454
+/* 0x4458 --> 0x4800 unused */
+
+/* Read DMA control registers */
+#define RDMAC_MODE			0x00004800
+#define  RDMAC_MODE_RESET		 0x00000001
+#define  RDMAC_MODE_ENABLE		 0x00000002
+#define  RDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  RDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  RDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  RDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  RDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  RDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  RDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  RDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define RDMAC_STATUS			0x00004804
+#define  RDMAC_STATUS_TGTABORT		 0x00000004
+#define  RDMAC_STATUS_MSTABORT		 0x00000008
+#define  RDMAC_STATUS_PARITYERR		 0x00000010
+#define  RDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  RDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  RDMAC_STATUS_FIFOURUN		 0x00000080
+#define  RDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  RDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4808 --> 0x4c00 unused */
+
+/* Write DMA control registers */
+#define WDMAC_MODE			0x00004c00
+#define  WDMAC_MODE_RESET		 0x00000001
+#define  WDMAC_MODE_ENABLE		 0x00000002
+#define  WDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  WDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  WDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  WDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  WDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  WDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  WDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  WDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define WDMAC_STATUS			0x00004c04
+#define  WDMAC_STATUS_TGTABORT		 0x00000004
+#define  WDMAC_STATUS_MSTABORT		 0x00000008
+#define  WDMAC_STATUS_PARITYERR		 0x00000010
+#define  WDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  WDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  WDMAC_STATUS_FIFOURUN		 0x00000080
+#define  WDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  WDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4c08 --> 0x5000 unused */
+
+/* Per-cpu register offsets (arm9) */
+#define CPU_MODE			0x00000000
+#define  CPU_MODE_RESET			 0x00000001
+#define  CPU_MODE_HALT			 0x00000400
+#define CPU_STATE			0x00000004
+#define CPU_EVTMASK			0x00000008
+/* 0xc --> 0x1c reserved */
+#define CPU_PC				0x0000001c
+#define CPU_INSN			0x00000020
+#define CPU_SPAD_UFLOW			0x00000024
+#define CPU_WDOG_CLEAR			0x00000028
+#define CPU_WDOG_VECTOR			0x0000002c
+#define CPU_WDOG_PC			0x00000030
+#define CPU_HW_BP			0x00000034
+/* 0x38 --> 0x44 unused */
+#define CPU_WDOG_SAVED_STATE		0x00000044
+#define CPU_LAST_BRANCH_ADDR		0x00000048
+#define CPU_SPAD_UFLOW_SET		0x0000004c
+/* 0x50 --> 0x200 unused */
+#define CPU_R0				0x00000200
+#define CPU_R1				0x00000204
+#define CPU_R2				0x00000208
+#define CPU_R3				0x0000020c
+#define CPU_R4				0x00000210
+#define CPU_R5				0x00000214
+#define CPU_R6				0x00000218
+#define CPU_R7				0x0000021c
+#define CPU_R8				0x00000220
+#define CPU_R9				0x00000224
+#define CPU_R10				0x00000228
+#define CPU_R11				0x0000022c
+#define CPU_R12				0x00000230
+#define CPU_R13				0x00000234
+#define CPU_R14				0x00000238
+#define CPU_R15				0x0000023c
+#define CPU_R16				0x00000240
+#define CPU_R17				0x00000244
+#define CPU_R18				0x00000248
+#define CPU_R19				0x0000024c
+#define CPU_R20				0x00000250
+#define CPU_R21				0x00000254
+#define CPU_R22				0x00000258
+#define CPU_R23				0x0000025c
+#define CPU_R24				0x00000260
+#define CPU_R25				0x00000264
+#define CPU_R26				0x00000268
+#define CPU_R27				0x0000026c
+#define CPU_R28				0x00000270
+#define CPU_R29				0x00000274
+#define CPU_R30				0x00000278
+#define CPU_R31				0x0000027c
+/* 0x280 --> 0x400 unused */
+
+#define RX_CPU_BASE			0x00005000
+#define TX_CPU_BASE			0x00005400
+
+/* Mailboxes */
+#define GRCMBOX_INTERRUPT_0		0x00005800 /* 64-bit */
+#define GRCMBOX_INTERRUPT_1		0x00005808 /* 64-bit */
+#define GRCMBOX_INTERRUPT_2		0x00005810 /* 64-bit */
+#define GRCMBOX_INTERRUPT_3		0x00005818 /* 64-bit */
+#define GRCMBOX_GENERAL_0		0x00005820 /* 64-bit */
+#define GRCMBOX_GENERAL_1		0x00005828 /* 64-bit */
+#define GRCMBOX_GENERAL_2		0x00005830 /* 64-bit */
+#define GRCMBOX_GENERAL_3		0x00005838 /* 64-bit */
+#define GRCMBOX_GENERAL_4		0x00005840 /* 64-bit */
+#define GRCMBOX_GENERAL_5		0x00005848 /* 64-bit */
+#define GRCMBOX_GENERAL_6		0x00005850 /* 64-bit */
+#define GRCMBOX_GENERAL_7		0x00005858 /* 64-bit */
+#define GRCMBOX_RELOAD_STAT		0x00005860 /* 64-bit */
+#define GRCMBOX_RCVSTD_PROD_IDX		0x00005868 /* 64-bit */
+#define GRCMBOX_RCVJUMBO_PROD_IDX	0x00005870 /* 64-bit */
+#define GRCMBOX_RCVMINI_PROD_IDX	0x00005878 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_0	0x00005880 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_1	0x00005888 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_2	0x00005890 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_3	0x00005898 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_4	0x000058a0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_5	0x000058a8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_6	0x000058b0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_7	0x000058b8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_8	0x000058c0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_9	0x000058c8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_10	0x000058d0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_11	0x000058d8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_12	0x000058e0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_13	0x000058e8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_14	0x000058f0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_15	0x000058f8 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_0	0x00005900 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_1	0x00005908 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_2	0x00005910 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_3	0x00005918 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_4	0x00005920 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_5	0x00005928 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_6	0x00005930 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_7	0x00005938 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_8	0x00005940 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_9	0x00005948 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_10	0x00005950 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_11	0x00005958 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_12	0x00005960 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_13	0x00005968 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_14	0x00005970 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_15	0x00005978 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_0	0x00005980 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_1	0x00005988 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_2	0x00005990 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_3	0x00005998 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_4	0x000059a0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_5	0x000059a8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_6	0x000059b0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_7	0x000059b8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_8	0x000059c0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_9	0x000059c8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_10	0x000059d0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_11	0x000059d8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_12	0x000059e0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_13	0x000059e8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_14	0x000059f0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_15	0x000059f8 /* 64-bit */
+#define GRCMBOX_HIGH_PRIO_EV_VECTOR	0x00005a00
+#define GRCMBOX_HIGH_PRIO_EV_MASK	0x00005a04
+#define GRCMBOX_LOW_PRIO_EV_VEC		0x00005a08
+#define GRCMBOX_LOW_PRIO_EV_MASK	0x00005a0c
+/* 0x5a10 --> 0x5c00 */
+
+/* Flow Through queues */
+#define FTQ_RESET			0x00005c00
+/* 0x5c04 --> 0x5c10 unused */
+#define FTQ_DMA_NORM_READ_CTL		0x00005c10
+#define FTQ_DMA_NORM_READ_FULL_CNT	0x00005c14
+#define FTQ_DMA_NORM_READ_FIFO_ENQDEQ	0x00005c18
+#define FTQ_DMA_NORM_READ_WRITE_PEEK	0x00005c1c
+#define FTQ_DMA_HIGH_READ_CTL		0x00005c20
+#define FTQ_DMA_HIGH_READ_FULL_CNT	0x00005c24
+#define FTQ_DMA_HIGH_READ_FIFO_ENQDEQ	0x00005c28
+#define FTQ_DMA_HIGH_READ_WRITE_PEEK	0x00005c2c
+#define FTQ_DMA_COMP_DISC_CTL		0x00005c30
+#define FTQ_DMA_COMP_DISC_FULL_CNT	0x00005c34
+#define FTQ_DMA_COMP_DISC_FIFO_ENQDEQ	0x00005c38
+#define FTQ_DMA_COMP_DISC_WRITE_PEEK	0x00005c3c
+#define FTQ_SEND_BD_COMP_CTL		0x00005c40
+#define FTQ_SEND_BD_COMP_FULL_CNT	0x00005c44
+#define FTQ_SEND_BD_COMP_FIFO_ENQDEQ	0x00005c48
+#define FTQ_SEND_BD_COMP_WRITE_PEEK	0x00005c4c
+#define FTQ_SEND_DATA_INIT_CTL		0x00005c50
+#define FTQ_SEND_DATA_INIT_FULL_CNT	0x00005c54
+#define FTQ_SEND_DATA_INIT_FIFO_ENQDEQ	0x00005c58
+#define FTQ_SEND_DATA_INIT_WRITE_PEEK	0x00005c5c
+#define FTQ_DMA_NORM_WRITE_CTL		0x00005c60
+#define FTQ_DMA_NORM_WRITE_FULL_CNT	0x00005c64
+#define FTQ_DMA_NORM_WRITE_FIFO_ENQDEQ	0x00005c68
+#define FTQ_DMA_NORM_WRITE_WRITE_PEEK	0x00005c6c
+#define FTQ_DMA_HIGH_WRITE_CTL		0x00005c70
+#define FTQ_DMA_HIGH_WRITE_FULL_CNT	0x00005c74
+#define FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ	0x00005c78
+#define FTQ_DMA_HIGH_WRITE_WRITE_PEEK	0x00005c7c
+#define FTQ_SWTYPE1_CTL			0x00005c80
+#define FTQ_SWTYPE1_FULL_CNT		0x00005c84
+#define FTQ_SWTYPE1_FIFO_ENQDEQ		0x00005c88
+#define FTQ_SWTYPE1_WRITE_PEEK		0x00005c8c
+#define FTQ_SEND_DATA_COMP_CTL		0x00005c90
+#define FTQ_SEND_DATA_COMP_FULL_CNT	0x00005c94
+#define FTQ_SEND_DATA_COMP_FIFO_ENQDEQ	0x00005c98
+#define FTQ_SEND_DATA_COMP_WRITE_PEEK	0x00005c9c
+#define FTQ_HOST_COAL_CTL		0x00005ca0
+#define FTQ_HOST_COAL_FULL_CNT		0x00005ca4
+#define FTQ_HOST_COAL_FIFO_ENQDEQ	0x00005ca8
+#define FTQ_HOST_COAL_WRITE_PEEK	0x00005cac
+#define FTQ_MAC_TX_CTL			0x00005cb0
+#define FTQ_MAC_TX_FULL_CNT		0x00005cb4
+#define FTQ_MAC_TX_FIFO_ENQDEQ		0x00005cb8
+#define FTQ_MAC_TX_WRITE_PEEK		0x00005cbc
+#define FTQ_MB_FREE_CTL			0x00005cc0
+#define FTQ_MB_FREE_FULL_CNT		0x00005cc4
+#define FTQ_MB_FREE_FIFO_ENQDEQ		0x00005cc8
+#define FTQ_MB_FREE_WRITE_PEEK		0x00005ccc
+#define FTQ_RCVBD_COMP_CTL		0x00005cd0
+#define FTQ_RCVBD_COMP_FULL_CNT		0x00005cd4
+#define FTQ_RCVBD_COMP_FIFO_ENQDEQ	0x00005cd8
+#define FTQ_RCVBD_COMP_WRITE_PEEK	0x00005cdc
+#define FTQ_RCVLST_PLMT_CTL		0x00005ce0
+#define FTQ_RCVLST_PLMT_FULL_CNT	0x00005ce4
+#define FTQ_RCVLST_PLMT_FIFO_ENQDEQ	0x00005ce8
+#define FTQ_RCVLST_PLMT_WRITE_PEEK	0x00005cec
+#define FTQ_RCVDATA_INI_CTL		0x00005cf0
+#define FTQ_RCVDATA_INI_FULL_CNT	0x00005cf4
+#define FTQ_RCVDATA_INI_FIFO_ENQDEQ	0x00005cf8
+#define FTQ_RCVDATA_INI_WRITE_PEEK	0x00005cfc
+#define FTQ_RCVDATA_COMP_CTL		0x00005d00
+#define FTQ_RCVDATA_COMP_FULL_CNT	0x00005d04
+#define FTQ_RCVDATA_COMP_FIFO_ENQDEQ	0x00005d08
+#define FTQ_RCVDATA_COMP_WRITE_PEEK	0x00005d0c
+#define FTQ_SWTYPE2_CTL			0x00005d10
+#define FTQ_SWTYPE2_FULL_CNT		0x00005d14
+#define FTQ_SWTYPE2_FIFO_ENQDEQ		0x00005d18
+#define FTQ_SWTYPE2_WRITE_PEEK		0x00005d1c
+/* 0x5d20 --> 0x6000 unused */
+
+/* Message signaled interrupt registers */
+#define MSGINT_MODE			0x00006000
+#define  MSGINT_MODE_RESET		 0x00000001
+#define  MSGINT_MODE_ENABLE		 0x00000002
+#define MSGINT_STATUS			0x00006004
+#define MSGINT_FIFO			0x00006008
+/* 0x600c --> 0x6400 unused */
+
+/* DMA completion registers */
+#define DMAC_MODE			0x00006400
+#define  DMAC_MODE_RESET		 0x00000001
+#define  DMAC_MODE_ENABLE		 0x00000002
+/* 0x6404 --> 0x6800 unused */
+
+/* GRC registers */
+#define GRC_MODE			0x00006800
+#define  GRC_MODE_UPD_ON_COAL		0x00000001
+#define  GRC_MODE_BSWAP_NONFRM_DATA	0x00000002
+#define  GRC_MODE_WSWAP_NONFRM_DATA	0x00000004
+#define  GRC_MODE_BSWAP_DATA		0x00000010
+#define  GRC_MODE_WSWAP_DATA		0x00000020
+#define  GRC_MODE_SPLITHDR		0x00000100
+#define  GRC_MODE_NOFRM_CRACKING	0x00000200
+#define  GRC_MODE_INCL_CRC		0x00000400
+#define  GRC_MODE_ALLOW_BAD_FRMS	0x00000800
+#define  GRC_MODE_NOIRQ_ON_SENDS	0x00002000
+#define  GRC_MODE_NOIRQ_ON_RCV		0x00004000
+#define  GRC_MODE_FORCE_PCI32BIT	0x00008000
+#define  GRC_MODE_HOST_STACKUP		0x00010000
+#define  GRC_MODE_HOST_SENDBDS		0x00020000
+#define  GRC_MODE_NO_TX_PHDR_CSUM	0x00100000
+#define  GRC_MODE_NO_RX_PHDR_CSUM	0x00800000
+#define  GRC_MODE_IRQ_ON_TX_CPU_ATTN	0x01000000
+#define  GRC_MODE_IRQ_ON_RX_CPU_ATTN	0x02000000
+#define  GRC_MODE_IRQ_ON_MAC_ATTN	0x04000000
+#define  GRC_MODE_IRQ_ON_DMA_ATTN	0x08000000
+#define  GRC_MODE_IRQ_ON_FLOW_ATTN	0x10000000
+#define  GRC_MODE_4X_NIC_SEND_RINGS	0x20000000
+#define  GRC_MODE_MCAST_FRM_ENABLE	0x40000000
+#define GRC_MISC_CFG			0x00006804
+#define  GRC_MISC_CFG_CORECLK_RESET	0x00000001
+#define  GRC_MISC_CFG_PRESCALAR_MASK	0x000000fe
+#define  GRC_MISC_CFG_PRESCALAR_SHIFT	1
+#define  GRC_MISC_CFG_BOARD_ID_MASK	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5700	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5701	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5702FE	0x00004000
+#define  GRC_MISC_CFG_BOARD_ID_5703	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5703S	0x00002000
+#define GRC_LOCAL_CTRL			0x00006808
+#define  GRC_LCLCTRL_INT_ACTIVE		0x00000001
+#define  GRC_LCLCTRL_CLEARINT		0x00000002
+#define  GRC_LCLCTRL_SETINT		0x00000004
+#define  GRC_LCLCTRL_INT_ON_ATTN	0x00000008
+#define  GRC_LCLCTRL_GPIO_INPUT0	0x00000100
+#define  GRC_LCLCTRL_GPIO_INPUT1	0x00000200
+#define  GRC_LCLCTRL_GPIO_INPUT2	0x00000400
+#define  GRC_LCLCTRL_GPIO_OE0		0x00000800
+#define  GRC_LCLCTRL_GPIO_OE1		0x00001000
+#define  GRC_LCLCTRL_GPIO_OE2		0x00002000
+#define  GRC_LCLCTRL_GPIO_OUTPUT0	0x00004000
+#define  GRC_LCLCTRL_GPIO_OUTPUT1	0x00008000
+#define  GRC_LCLCTRL_GPIO_OUTPUT2	0x00010000
+#define  GRC_LCLCTRL_EXTMEM_ENABLE	0x00020000
+#define  GRC_LCLCTRL_MEMSZ_MASK		0x001c0000
+#define  GRC_LCLCTRL_MEMSZ_256K		0x00000000
+#define  GRC_LCLCTRL_MEMSZ_512K		0x00040000
+#define  GRC_LCLCTRL_MEMSZ_1M		0x00080000
+#define  GRC_LCLCTRL_MEMSZ_2M		0x000c0000
+#define  GRC_LCLCTRL_MEMSZ_4M		0x00100000
+#define  GRC_LCLCTRL_MEMSZ_8M		0x00140000
+#define  GRC_LCLCTRL_MEMSZ_16M		0x00180000
+#define  GRC_LCLCTRL_BANK_SELECT	0x00200000
+#define  GRC_LCLCTRL_SSRAM_TYPE		0x00400000
+#define  GRC_LCLCTRL_AUTO_SEEPROM	0x01000000
+#define GRC_TIMER			0x0000680c
+#define GRC_RX_CPU_EVENT		0x00006810
+#define GRC_RX_TIMER_REF		0x00006814
+#define GRC_RX_CPU_SEM			0x00006818
+#define GRC_REMOTE_RX_CPU_ATTN		0x0000681c
+#define GRC_TX_CPU_EVENT		0x00006820
+#define GRC_TX_TIMER_REF		0x00006824
+#define GRC_TX_CPU_SEM			0x00006828
+#define GRC_REMOTE_TX_CPU_ATTN		0x0000682c
+#define GRC_MEM_POWER_UP		0x00006830 /* 64-bit */
+#define GRC_EEPROM_ADDR			0x00006838
+#define  EEPROM_ADDR_WRITE		0x00000000
+#define  EEPROM_ADDR_READ		0x80000000
+#define  EEPROM_ADDR_COMPLETE		0x40000000
+#define  EEPROM_ADDR_FSM_RESET		0x20000000
+#define  EEPROM_ADDR_DEVID_MASK		0x1c000000
+#define  EEPROM_ADDR_DEVID_SHIFT	26
+#define  EEPROM_ADDR_START		0x02000000
+#define  EEPROM_ADDR_CLKPERD_SHIFT	16
+#define  EEPROM_ADDR_ADDR_MASK		0x0000ffff
+#define  EEPROM_ADDR_ADDR_SHIFT		0
+#define  EEPROM_DEFAULT_CLOCK_PERIOD	0x60
+#define  EEPROM_CHIP_SIZE		(64 * 1024)
+#define GRC_EEPROM_DATA			0x0000683c
+#define GRC_EEPROM_CTRL			0x00006840
+#define GRC_MDI_CTRL			0x00006844
+#define GRC_SEEPROM_DELAY		0x00006848
+/* 0x684c --> 0x6c00 unused */
+
+/* 0x6c00 --> 0x7000 unused */
+
+/* NVRAM Control registers */
+#define NVRAM_CMD			0x00007000
+#define  NVRAM_CMD_RESET		 0x00000001
+#define  NVRAM_CMD_DONE			 0x00000008
+#define  NVRAM_CMD_GO			 0x00000010
+#define  NVRAM_CMD_WR			 0x00000020
+#define  NVRAM_CMD_RD			 0x00000000
+#define  NVRAM_CMD_ERASE		 0x00000040
+#define  NVRAM_CMD_FIRST		 0x00000080
+#define  NVRAM_CMD_LAST			 0x00000100
+#define NVRAM_STAT			0x00007004
+#define NVRAM_WRDATA			0x00007008
+#define NVRAM_ADDR			0x0000700c
+#define  NVRAM_ADDR_MSK			0x00ffffff
+#define NVRAM_RDDATA			0x00007010
+#define NVRAM_CFG1			0x00007014
+#define  NVRAM_CFG1_FLASHIF_ENAB	 0x00000001
+#define  NVRAM_CFG1_BUFFERED_MODE	 0x00000002
+#define  NVRAM_CFG1_PASS_THRU		 0x00000004
+#define  NVRAM_CFG1_BIT_BANG		 0x00000008
+#define  NVRAM_CFG1_COMPAT_BYPASS	 0x80000000
+#define NVRAM_CFG2			0x00007018
+#define NVRAM_CFG3			0x0000701c
+#define NVRAM_SWARB			0x00007020
+#define  SWARB_REQ_SET0			 0x00000001
+#define  SWARB_REQ_SET1			 0x00000002
+#define  SWARB_REQ_SET2			 0x00000004
+#define  SWARB_REQ_SET3			 0x00000008
+#define  SWARB_REQ_CLR0			 0x00000010
+#define  SWARB_REQ_CLR1			 0x00000020
+#define  SWARB_REQ_CLR2			 0x00000040
+#define  SWARB_REQ_CLR3			 0x00000080
+#define  SWARB_GNT0			 0x00000100
+#define  SWARB_GNT1			 0x00000200
+#define  SWARB_GNT2			 0x00000400
+#define  SWARB_GNT3			 0x00000800
+#define  SWARB_REQ0			 0x00001000
+#define  SWARB_REQ1			 0x00002000
+#define  SWARB_REQ2			 0x00004000
+#define  SWARB_REQ3			 0x00008000
+#define    NVRAM_BUFFERED_PAGE_SIZE	   264
+#define    NVRAM_BUFFERED_PAGE_POS	   9
+/* 0x7024 --> 0x7400 unused */
+
+/* 0x7400 --> 0x8000 unused */
+
+/* 32K Window into NIC internal memory */
+#define NIC_SRAM_WIN_BASE		0x00008000
+
+/* Offsets into first 32k of NIC internal memory. */
+#define NIC_SRAM_PAGE_ZERO		0x00000000
+#define NIC_SRAM_SEND_RCB		0x00000100 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_RCV_RET_RCB		0x00000200 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_STATS_BLK		0x00000300
+#define NIC_SRAM_STATUS_BLK		0x00000b00
+
+#define NIC_SRAM_FIRMWARE_MBOX		0x00000b50
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC1	 0x4B657654
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC2	 0x4861764b /* !dma on linkchg */
+
+#define NIC_SRAM_DATA_SIG		0x00000b54
+#define  NIC_SRAM_DATA_SIG_MAGIC	 0x4b657654 /* ascii for 'KevT' */
+
+#define NIC_SRAM_DATA_CFG			0x00000b58
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_MASK	 0x0000000c
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_COPPER	 0x00000004
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER	 0x00000008
+#define  NIC_SRAM_DATA_CFG_LED_MODE_MASK	 0x00000030
+#define  NIC_SRAM_DATA_CFG_LED_MODE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD	 0x00000010
+#define  NIC_SRAM_DATA_CFG_LED_LINK_SPD		 0x00000020
+
+#define NIC_SRAM_DATA_PHY_ID		0x00000b74
+#define  NIC_SRAM_DATA_PHY_ID1_MASK	 0xffff0000
+#define  NIC_SRAM_DATA_PHY_ID2_MASK	 0x0000ffff
+
+#define NIC_SRAM_FW_CMD_MBOX		0x00000b78
+#define  FWCMD_NICDRV_ALIVE		 0x00000001
+#define  FWCMD_NICDRV_PAUSE_FW		 0x00000002
+#define  FWCMD_NICDRV_IPV4ADDR_CHG	 0x00000003
+#define  FWCMD_NICDRV_IPV6ADDR_CHG	 0x00000004
+#define  FWCMD_NICDRV_FIX_DMAR		 0x00000005
+#define  FWCMD_NICDRV_FIX_DMAW		 0x00000006
+#define NIC_SRAM_FW_CMD_LEN_MBOX	0x00000b7c
+#define NIC_SRAM_FW_CMD_DATA_MBOX	0x00000b80
+#define NIC_SRAM_FW_ASF_STATUS_MBOX	0x00000c00
+#define NIC_SRAM_FW_DRV_STATE_MBOX	0x00000c04
+#define  DRV_STATE_START		 0x00000001
+#define  DRV_STATE_UNLOAD		 0x00000002
+#define  DRV_STATE_WOL			 0x00000003
+#define  DRV_STATE_SUSPEND		 0x00000004
+
+#define NIC_SRAM_FW_RESET_TYPE_MBOX	0x00000c08
+
+#define NIC_SRAM_MAC_ADDR_HIGH_MBOX	0x00000c14
+#define NIC_SRAM_MAC_ADDR_LOW_MBOX	0x00000c18
+
+#if TG3_MINI_RING_WORKS
+#define NIC_SRAM_RX_MINI_BUFFER_DESC	0x00001000
+#endif
+
+#define NIC_SRAM_DMA_DESC_POOL_BASE	0x00002000
+#define  NIC_SRAM_DMA_DESC_POOL_SIZE	 0x00002000
+#define NIC_SRAM_TX_BUFFER_DESC		0x00004000 /* 512 entries */
+#define NIC_SRAM_RX_BUFFER_DESC		0x00006000 /* 256 entries */
+#define NIC_SRAM_RX_JUMBO_BUFFER_DESC	0x00007000 /* 256 entries */
+#define NIC_SRAM_MBUF_POOL_BASE		0x00008000
+#define  NIC_SRAM_MBUF_POOL_SIZE	 0x00018000
+
+/* Currently this is fixed. */
+#define PHY_ADDR		0x01
+
+/* Tigon3 specific PHY MII registers. */
+#define  TG3_BMCR_SPEED1000		0x0040
+
+#define MII_TG3_CTRL			0x09 /* 1000-baseT control register */
+#define  MII_TG3_CTRL_ADV_1000_HALF	0x0100
+#define  MII_TG3_CTRL_ADV_1000_FULL	0x0200
+#define  MII_TG3_CTRL_AS_MASTER		0x0800
+#define  MII_TG3_CTRL_ENABLE_AS_MASTER	0x1000
+
+#define MII_TG3_EXT_CTRL		0x10 /* Extended control register */
+#define  MII_TG3_EXT_CTRL_LNK3_LED_MODE	0x0002
+#define  MII_TG3_EXT_CTRL_TBI		0x8000
+
+#define MII_TG3_EXT_STAT		0x11 /* Extended status register */
+#define  MII_TG3_EXT_STAT_LPASS		0x0100
+
+#define MII_TG3_DSP_RW_PORT		0x15 /* DSP coefficient read/write port */
+
+#define MII_TG3_DSP_ADDRESS		0x17 /* DSP address register */
+
+#define MII_TG3_AUX_CTRL		0x18 /* auxilliary control register */
+
+#define MII_TG3_AUX_STAT		0x19 /* auxilliary status register */
+#define MII_TG3_AUX_STAT_LPASS		0x0004
+#define MII_TG3_AUX_STAT_SPDMASK	0x0700
+#define MII_TG3_AUX_STAT_10HALF		0x0100
+#define MII_TG3_AUX_STAT_10FULL		0x0200
+#define MII_TG3_AUX_STAT_100HALF	0x0300
+#define MII_TG3_AUX_STAT_100_4		0x0400
+#define MII_TG3_AUX_STAT_100FULL	0x0500
+#define MII_TG3_AUX_STAT_1000HALF	0x0600
+#define MII_TG3_AUX_STAT_1000FULL	0x0700
+
+#define MII_TG3_ISTAT			0x1a /* IRQ status register */
+#define MII_TG3_IMASK			0x1b /* IRQ mask register */
+
+/* ISTAT/IMASK event bits */
+#define MII_TG3_INT_LINKCHG		0x0002
+#define MII_TG3_INT_SPEEDCHG		0x0004
+#define MII_TG3_INT_DUPLEXCHG		0x0008
+#define MII_TG3_INT_ANEG_PAGE_RX	0x0400
+
+/* XXX Add this to mii.h */
+#ifndef ADVERTISE_PAUSE
+#define ADVERTISE_PAUSE_CAP		0x0400
+#endif
+#ifndef ADVERTISE_PAUSE_ASYM
+#define ADVERTISE_PAUSE_ASYM		0x0800
+#endif
+#ifndef LPA_PAUSE
+#define LPA_PAUSE_CAP			0x0400
+#endif
+#ifndef LPA_PAUSE_ASYM
+#define LPA_PAUSE_ASYM			0x0800
+#endif
+
+/* There are two ways to manage the TX descriptors on the tigon3.
+ * Either the descriptors are in host DMA'able memory, or they
+ * exist only in the cards on-chip SRAM.  All 16 send bds are under
+ * the same mode, they may not be configured individually.
+ *
+ * The mode we use is controlled by TG3_FLAG_HOST_TXDS in tp->tg3_flags.
+ *
+ * To use host memory TX descriptors:
+ *	1) Set GRC_MODE_HOST_SENDBDS in GRC_MODE register.
+ *	   Make sure GRC_MODE_4X_NIC_SEND_RINGS is clear.
+ *	2) Allocate DMA'able memory.
+ *	3) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to DMA address of memory
+ *	      obtained in step 2
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC.
+ *	   c) Set len field of TG3_BDINFO_MAXLEN_FLAGS to number
+ *            of TX descriptors.  Leave flags field clear.
+ *	4) Access TX descriptors via host memory.  The chip
+ *	   will refetch into local SRAM as needed when producer
+ *	   index mailboxes are updated.
+ *
+ * To use on-chip TX descriptors:
+ *	1) Set GRC_MODE_4X_NIC_SEND_RINGS in GRC_MODE register.
+ *	   Make sure GRC_MODE_HOST_SENDBDS is clear.
+ *	2) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to zero.
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC
+ *	   c) TG3_BDINFO_MAXLEN_FLAGS is don't care.
+ *	3) Access TX descriptors directly in on-chip SRAM
+ *	   using normal {read,write}l().  (and not using
+ *         pointer dereferencing of ioremap()'d memory like
+ *	   the broken Broadcom driver does)
+ *
+ * Note that BDINFO_FLAGS_DISABLED should be set in the flags field of
+ * TG3_BDINFO_MAXLEN_FLAGS of all unused SEND_RCB indices.
+ */
+struct tg3_tx_buffer_desc {
+	u32				addr_hi;
+	u32				addr_lo;
+
+	u32				len_flags;
+#define TXD_FLAG_TCPUDP_CSUM		0x0001
+#define TXD_FLAG_IP_CSUM		0x0002
+#define TXD_FLAG_END			0x0004
+#define TXD_FLAG_IP_FRAG		0x0008
+#define TXD_FLAG_IP_FRAG_END		0x0010
+#define TXD_FLAG_VLAN			0x0040
+#define TXD_FLAG_COAL_NOW		0x0080
+#define TXD_FLAG_CPU_PRE_DMA		0x0100
+#define TXD_FLAG_CPU_POST_DMA		0x0200
+#define TXD_FLAG_ADD_SRC_ADDR		0x1000
+#define TXD_FLAG_CHOOSE_SRC_ADDR	0x6000
+#define TXD_FLAG_NO_CRC			0x8000
+#define TXD_LEN_SHIFT			16
+
+	u32				vlan_tag;
+#define TXD_VLAN_TAG_SHIFT		0
+};
+
+#define TXD_ADDR			0x00UL /* 64-bit */
+#define TXD_LEN_FLAGS			0x08UL /* 32-bit (upper 16-bits are len) */
+#define TXD_VLAN_TAG			0x0cUL /* 32-bit (upper 16-bits are tag) */
+#define TXD_SIZE			0x10UL
+
+struct tg3_rx_buffer_desc {
+	u32				addr_hi;
+	u32				addr_lo;
+
+	u32				idx_len;
+#define RXD_IDX_MASK	0xffff0000
+#define RXD_IDX_SHIFT	16
+#define RXD_LEN_MASK	0x0000ffff
+#define RXD_LEN_SHIFT	0
+
+	u32				type_flags;
+#define RXD_TYPE_SHIFT	16
+#define RXD_FLAGS_SHIFT	0
+
+#define RXD_FLAG_END			0x0004
+#if TG3_MINI_RING_WORKS
+#define RXD_FLAG_MINI			0x0800
+#endif
+#define RXD_FLAG_JUMBO			0x0020
+#define RXD_FLAG_VLAN			0x0040
+#define RXD_FLAG_ERROR			0x0400
+#define RXD_FLAG_IP_CSUM		0x1000
+#define RXD_FLAG_TCPUDP_CSUM		0x2000
+#define RXD_FLAG_IS_TCP			0x4000
+
+	u32				ip_tcp_csum;
+#define RXD_IPCSUM_MASK		0xffff0000
+#define RXD_IPCSUM_SHIFT	16
+#define RXD_TCPCSUM_MASK	0x0000ffff
+#define RXD_TCPCSUM_SHIFT	0
+
+	u32				err_vlan;
+
+#define RXD_VLAN_MASK			0x0000ffff
+
+#define RXD_ERR_BAD_CRC			0x00010000
+#define RXD_ERR_COLLISION		0x00020000
+#define RXD_ERR_LINK_LOST		0x00040000
+#define RXD_ERR_PHY_DECODE		0x00080000
+#define RXD_ERR_ODD_NIBBLE_RCVD_MII	0x00100000
+#define RXD_ERR_MAC_ABRT		0x00200000
+#define RXD_ERR_TOO_SMALL		0x00400000
+#define RXD_ERR_NO_RESOURCES		0x00800000
+#define RXD_ERR_HUGE_FRAME		0x01000000
+#define RXD_ERR_MASK			0xffff0000
+
+	u32				reserved;
+	u32				opaque;
+#define RXD_OPAQUE_INDEX_MASK		0x0000ffff
+#define RXD_OPAQUE_INDEX_SHIFT		0
+#define RXD_OPAQUE_RING_STD		0x00010000
+#define RXD_OPAQUE_RING_JUMBO		0x00020000
+#if TG3_MINI_RING_WORKS
+#define RXD_OPAQUE_RING_MINI		0x00040000
+#endif
+#define RXD_OPAQUE_RING_MASK		0x00070000
+};
+
+struct tg3_ext_rx_buffer_desc {
+	struct {
+		u32			addr_hi;
+		u32			addr_lo;
+	}				addrlist[3];
+	u32				len2_len1;
+	u32				resv_len3;
+	struct tg3_rx_buffer_desc	std;
+};
+
+/* We only use this when testing out the DMA engine
+ * at probe time.  This is the internal format of buffer
+ * descriptors used by the chip at NIC_SRAM_DMA_DESCS.
+ */
+struct tg3_internal_buffer_desc {
+	u32				addr_hi;
+	u32				addr_lo;
+	u32				nic_mbuf;
+	/* XXX FIX THIS */
+#ifdef __BIG_ENDIAN
+	u16				cqid_sqid;
+	u16				len;
+#else
+	u16				len;
+	u16				cqid_sqid;
+#endif
+	u32				flags;
+	u32				__cookie1;
+	u32				__cookie2;
+	u32				__cookie3;
+};
+
+#define TG3_HW_STATUS_SIZE		0x80
+struct tg3_hw_status {
+	u32				status;
+#define SD_STATUS_UPDATED		0x00000001
+#define SD_STATUS_LINK_CHG		0x00000002
+#define SD_STATUS_ERROR			0x00000004
+
+	u32				status_tag;
+
+#ifdef __BIG_ENDIAN
+	u16				rx_consumer;
+	u16				rx_jumbo_consumer;
+#else
+	u16				rx_jumbo_consumer;
+	u16				rx_consumer;
+#endif
+
+#ifdef __BIG_ENDIAN
+	u16				reserved;
+	u16				rx_mini_consumer;
+#else
+	u16				rx_mini_consumer;
+	u16				reserved;
+#endif
+	struct {
+#ifdef __BIG_ENDIAN
+		u16			tx_consumer;
+		u16			rx_producer;
+#else
+		u16			rx_producer;
+		u16			tx_consumer;
+#endif
+	}				idx[16];
+};
+
+typedef struct {
+	u32 high, low;
+} tg3_stat64_t;
+
+struct tg3_hw_stats {
+	u8				__reserved0[0x400-0x300];
+
+	/* Statistics maintained by Receive MAC. */
+	tg3_stat64_t			rx_octets;
+	u64				__reserved1;
+	tg3_stat64_t			rx_fragments;
+	tg3_stat64_t			rx_ucast_packets;
+	tg3_stat64_t			rx_mcast_packets;
+	tg3_stat64_t			rx_bcast_packets;
+	tg3_stat64_t			rx_fcs_errors;
+	tg3_stat64_t			rx_align_errors;
+	tg3_stat64_t			rx_xon_pause_rcvd;
+	tg3_stat64_t			rx_xoff_pause_rcvd;
+	tg3_stat64_t			rx_mac_ctrl_rcvd;
+	tg3_stat64_t			rx_xoff_entered;
+	tg3_stat64_t			rx_frame_too_long_errors;
+	tg3_stat64_t			rx_jabbers;
+	tg3_stat64_t			rx_undersize_packets;
+	tg3_stat64_t			rx_in_length_errors;
+	tg3_stat64_t			rx_out_length_errors;
+	tg3_stat64_t			rx_64_or_less_octet_packets;
+	tg3_stat64_t			rx_65_to_127_octet_packets;
+	tg3_stat64_t			rx_128_to_255_octet_packets;
+	tg3_stat64_t			rx_256_to_511_octet_packets;
+	tg3_stat64_t			rx_512_to_1023_octet_packets;
+	tg3_stat64_t			rx_1024_to_1522_octet_packets;
+	tg3_stat64_t			rx_1523_to_2047_octet_packets;
+	tg3_stat64_t			rx_2048_to_4095_octet_packets;
+	tg3_stat64_t			rx_4096_to_8191_octet_packets;
+	tg3_stat64_t			rx_8192_to_9022_octet_packets;
+
+	u64				__unused0[37];
+
+	/* Statistics maintained by Transmit MAC. */
+	tg3_stat64_t			tx_octets;
+	u64				__reserved2;
+	tg3_stat64_t			tx_collisions;
+	tg3_stat64_t			tx_xon_sent;
+	tg3_stat64_t			tx_xoff_sent;
+	tg3_stat64_t			tx_flow_control;
+	tg3_stat64_t			tx_mac_errors;
+	tg3_stat64_t			tx_single_collisions;
+	tg3_stat64_t			tx_mult_collisions;
+	tg3_stat64_t			tx_deferred;
+	u64				__reserved3;
+	tg3_stat64_t			tx_excessive_collisions;
+	tg3_stat64_t			tx_late_collisions;
+	tg3_stat64_t			tx_collide_2times;
+	tg3_stat64_t			tx_collide_3times;
+	tg3_stat64_t			tx_collide_4times;
+	tg3_stat64_t			tx_collide_5times;
+	tg3_stat64_t			tx_collide_6times;
+	tg3_stat64_t			tx_collide_7times;
+	tg3_stat64_t			tx_collide_8times;
+	tg3_stat64_t			tx_collide_9times;
+	tg3_stat64_t			tx_collide_10times;
+	tg3_stat64_t			tx_collide_11times;
+	tg3_stat64_t			tx_collide_12times;
+	tg3_stat64_t			tx_collide_13times;
+	tg3_stat64_t			tx_collide_14times;
+	tg3_stat64_t			tx_collide_15times;
+	tg3_stat64_t			tx_ucast_packets;
+	tg3_stat64_t			tx_mcast_packets;
+	tg3_stat64_t			tx_bcast_packets;
+	tg3_stat64_t			tx_carrier_sense_errors;
+	tg3_stat64_t			tx_discards;
+	tg3_stat64_t			tx_errors;
+
+	u64				__unused1[31];
+
+	/* Statistics maintained by Receive List Placement. */
+	tg3_stat64_t			COS_rx_packets[16];
+	tg3_stat64_t			COS_rx_filter_dropped;
+	tg3_stat64_t			dma_writeq_full;
+	tg3_stat64_t			dma_write_prioq_full;
+	tg3_stat64_t			rxbds_empty;
+	tg3_stat64_t			rx_discards;
+	tg3_stat64_t			rx_errors;
+	tg3_stat64_t			rx_threshold_hit;
+
+	u64				__unused2[9];
+
+	/* Statistics maintained by Send Data Initiator. */
+	tg3_stat64_t			COS_out_packets[16];
+	tg3_stat64_t			dma_readq_full;
+	tg3_stat64_t			dma_read_prioq_full;
+	tg3_stat64_t			tx_comp_queue_full;
+
+	/* Statistics maintained by Host Coalescing. */
+	tg3_stat64_t			ring_set_send_prod_index;
+	tg3_stat64_t			ring_status_update;
+	tg3_stat64_t			nic_irqs;
+	tg3_stat64_t			nic_avoided_irqs;
+	tg3_stat64_t			nic_tx_threshold_hit;
+
+	u8				__reserved4[0xb00-0x9c0];
+};
+
+enum phy_led_mode {
+	led_mode_auto,
+	led_mode_three_link,
+	led_mode_link10
+};
+
+/* 'mapping' is superfluous as the chip does not write into
+ * the tx/rx post rings so we could just fetch it from there.
+ * But the cache behavior is better how we are doing it now.
+ */
+struct ring_info {
+	struct sk_buff			*skb;
+	DECLARE_PCI_UNMAP_ADDR(mapping)
+};
+
+struct tg3_config_info {
+	u32				flags;
+};
+
+struct tg3_link_config {
+	/* Describes what we're trying to get. */
+	u32				advertising;
+	u16				speed;
+	u8				duplex;
+	u8				autoneg;
+
+	/* Describes what we actually have. */
+	u16				active_speed;
+	u8				active_duplex;
+#define SPEED_INVALID		0xffff
+#define DUPLEX_INVALID		0xff
+#define AUTONEG_INVALID		0xff
+
+	/* When we go in and out of low power mode we need
+	 * to swap with this state.
+	 */
+	int				phy_is_low_power;
+	u16				orig_speed;
+	u8				orig_duplex;
+	u8				orig_autoneg;
+};
+
+struct tg3_coalesce_config {
+	/* Current settings. */
+	u32		rx_coalesce_ticks;
+	u32		rx_max_coalesced_frames;
+	u32		rx_coalesce_ticks_during_int;
+	u32		rx_max_coalesced_frames_during_int;
+	u32		tx_coalesce_ticks;
+	u32		tx_max_coalesced_frames;
+	u32		tx_coalesce_ticks_during_int;
+	u32		tx_max_coalesced_frames_during_int;
+	u32		stats_coalesce_ticks;
+
+	/* Default settings. */
+	u32		rx_coalesce_ticks_def;
+	u32		rx_max_coalesced_frames_def;
+	u32		rx_coalesce_ticks_during_int_def;
+	u32		rx_max_coalesced_frames_during_int_def;
+	u32		tx_coalesce_ticks_def;
+	u32		tx_max_coalesced_frames_def;
+	u32		tx_coalesce_ticks_during_int_def;
+	u32		tx_max_coalesced_frames_during_int_def;
+	u32		stats_coalesce_ticks_def;
+
+	/* Adaptive RX/TX coalescing parameters. */
+	u32		rate_sample_jiffies;
+	u32		pkt_rate_low;
+	u32		pkt_rate_high;
+
+	u32		rx_coalesce_ticks_low;
+	u32		rx_max_coalesced_frames_low;
+	u32		tx_coalesce_ticks_low;
+	u32		tx_max_coalesced_frames_low;
+
+	u32		rx_coalesce_ticks_high;
+	u32		rx_max_coalesced_frames_high;
+	u32		tx_coalesce_ticks_high;
+	u32		tx_max_coalesced_frames_high;
+};
+
+struct tg3_bufmgr_config {
+	u32		mbuf_read_dma_low_water;
+	u32		mbuf_mac_rx_low_water;
+	u32		mbuf_high_water;
+
+	u32		mbuf_read_dma_low_water_jumbo;
+	u32		mbuf_mac_rx_low_water_jumbo;
+	u32		mbuf_high_water_jumbo;
+
+	u32		dma_low_water;
+	u32		dma_high_water;
+};
+
+struct tg3 {
+	spinlock_t			lock;
+	u32				tx_prod;
+	u32				tx_cons;
+	u32				rx_rcb_ptr;
+	u32				rx_std_ptr;
+	u32				rx_jumbo_ptr;
+#if TG3_MINI_RING_WORKS
+	u32				rx_mini_ptr;
+#endif
+	spinlock_t			indirect_lock;
+
+	struct net_device_stats		net_stats;
+	struct net_device_stats		net_stats_prev;
+	unsigned long			phy_crc_errors;
+
+	/* Adaptive coalescing engine. */
+	unsigned long			last_rate_sample;
+	u32				last_rx_count;
+	u32				last_tx_count;
+
+	u32				rx_offset;
+	u32				tg3_flags;
+#define TG3_FLAG_HOST_TXDS		0x00000001
+#define TG3_FLAG_TXD_MBOX_HWBUG		0x00000002
+#define TG3_FLAG_RX_CHECKSUMS		0x00000004
+#define TG3_FLAG_USE_LINKCHG_REG	0x00000008
+#define TG3_FLAG_USE_MI_INTERRUPT	0x00000010
+#define TG3_FLAG_ADAPTIVE_RX		0x00000020
+#define TG3_FLAG_ADAPTIVE_TX		0x00000040
+#define TG3_FLAG_PHY_RESET_ON_INIT	0x00000100
+#define TG3_FLAG_PCIX_TARGET_HWBUG	0x00000200
+#define TG3_FLAG_TAGGED_IRQ_STATUS	0x00000400
+#define TG3_FLAG_WOL_SPEED_100MB	0x00000800
+#define TG3_FLAG_WOL_ENABLE		0x00001000
+#define TG3_FLAG_NVRAM			0x00002000
+#define TG3_FLAG_NVRAM_BUFFERED		0x00004000
+#define TG3_FLAG_RX_PAUSE		0x00008000
+#define TG3_FLAG_TX_PAUSE		0x00010000
+#define TG3_FLAG_PCIX_MODE		0x00020000
+#define TG3_FLAG_PCI_HIGH_SPEED		0x00040000
+#define TG3_FLAG_PCI_32BIT		0x00080000
+#define TG3_FLAG_NO_TX_PSEUDO_CSUM	0x00100000
+#define TG3_FLAG_NO_RX_PSEUDO_CSUM	0x00200000
+#define TG3_FLAG_AUTONEG_DISABLE	0x00400000
+#define TG3_FLAG_JUMBO_ENABLE		0x00800000
+#define TG3_FLAG_10_100_ONLY		0x01000000
+#define TG3_FLAG_PAUSE_AUTONEG		0x02000000
+#define TG3_FLAG_PAUSE_RX		0x04000000
+#define TG3_FLAG_PAUSE_TX		0x08000000
+#define TG3_FLAG_BROKEN_CHECKSUMS	0x10000000
+#define TG3_FLAG_INIT_COMPLETE		0x80000000
+
+	u32				msg_enable;
+
+	struct timer_list		timer;
+	u16				timer_counter;
+	u16				timer_multiplier;
+	u32				timer_offset;
+
+	struct tg3_link_config		link_config;
+	struct tg3_coalesce_config	coalesce_config;
+	struct tg3_bufmgr_config	bufmgr_config;
+
+	u32				rx_pending;
+#if TG3_MINI_RING_WORKS
+	u32				rx_mini_pending;
+#endif
+	u32				rx_jumbo_pending;
+	u32				tx_pending;
+
+	/* cache h/w values, often passed straight to h/w */
+	u32				rx_mode;
+	u32				tx_mode;
+	u32				mac_mode;
+	u32				mi_mode;
+	u32				misc_host_ctrl;
+	u32				grc_mode;
+	u32				grc_local_ctrl;
+	u32				dma_rwctrl;
+	u32				coalesce_mode;
+
+	/* PCI block */
+	u16				pci_chip_rev_id;
+	u8				pci_cacheline_sz;
+	u8				pci_lat_timer;
+	u8				pci_hdr_type;
+	u8				pci_bist;
+	u32				pci_cfg_state[64 / sizeof(u32)];
+
+	int				pm_cap;
+
+	/* PHY info */
+	u32				phy_id;
+#define PHY_ID_MASK			0xfffffff0
+#define PHY_ID_BCM5400			0x60008040
+#define PHY_ID_BCM5401			0x60008050
+#define PHY_ID_BCM5411			0x60008070
+#define PHY_ID_BCM5701			0x60008110
+#define PHY_ID_BCM5703			0x60008160
+#define PHY_ID_BCM8002			0x60010140
+#define PHY_ID_SERDES			0xfeedbee0
+#define PHY_ID_INVALID			0xffffffff
+#define PHY_ID_REV_MASK			0x0000000f
+#define PHY_REV_BCM5401_B0		0x1
+#define PHY_REV_BCM5401_B2		0x3
+#define PHY_REV_BCM5401_C0		0x6
+
+	enum phy_led_mode		led_mode;
+
+	char				board_part_number[24];
+
+	/* This macro assumes the passed PHY ID is already masked
+	 * with PHY_ID_MASK.
+	 */
+#define KNOWN_PHY_ID(X)		\
+	((X) == PHY_ID_BCM5400 || (X) == PHY_ID_BCM5401 || \
+	 (X) == PHY_ID_BCM5411 || (X) == PHY_ID_BCM5701 || \
+	 (X) == PHY_ID_BCM5703 ||			   \
+	 (X) == PHY_ID_BCM8002 || (X) == PHY_ID_SERDES)
+
+	unsigned long			regs;
+	struct pci_dev			*pdev;
+	struct net_device		*dev;
+#if TG3_VLAN_TAG_USED
+	struct vlan_group		*vlgrp;
+#endif
+
+	struct tg3_rx_buffer_desc	*rx_std;
+	struct ring_info		*rx_std_buffers;
+	dma_addr_t			rx_std_mapping;
+#if TG3_MINI_RING_WORKS
+	struct tg3_rx_buffer_desc	*rx_mini;
+	struct ring_info		*rx_mini_buffers;
+	dma_addr_t			rx_mini_mapping;
+#endif
+	struct tg3_rx_buffer_desc	*rx_jumbo;
+	struct ring_info		*rx_jumbo_buffers;
+	dma_addr_t			rx_jumbo_mapping;
+
+	struct tg3_rx_buffer_desc	*rx_rcb;
+	dma_addr_t			rx_rcb_mapping;
+
+	/* TX descs are only used if TG3_FLAG_HOST_TXDS is set. */
+	struct tg3_tx_buffer_desc	*tx_ring;
+	struct ring_info		*tx_buffers;
+	dma_addr_t			tx_desc_mapping;
+
+	struct tg3_hw_status		*hw_status;
+	dma_addr_t			status_mapping;
+
+	struct tg3_hw_stats		*hw_stats;
+	dma_addr_t			stats_mapping;
+};
+
+#endif /* !(_T3_H) */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/net/tulip/media.c linux/drivers/net/tulip/media.c
--- ../ia64/linux/drivers/net/tulip/media.c	Fri Jan 25 13:11:24 2002
+++ linux/drivers/net/tulip/media.c	Thu May  9 01:30:51 2002
@@ -284,6 +284,10 @@
 				for (i = 0; i < init_length; i++)
 					outl(init_sequence[i], ioaddr + CSR12);
 			}
+
+			(void) inl(ioaddr + CSR6); /* flush CSR12 writes */
+			udelay(500);		/* Give MII time to recover */
+
 			tmp_info = get_u16(&misc_info[1]);
 			if (tmp_info)
 				tp->advertising[phy_num] = tmp_info | 1;
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/pci/pci.ids linux/drivers/pci/pci.ids
--- ../ia64/linux/drivers/pci/pci.ids	Fri Jan 25 13:11:24 2002
+++ linux/drivers/pci/pci.ids	Mon Mar 25 13:23:53 2002
@@ -917,6 +917,9 @@
 	121a  NetServer SMIC Controller
 	121b  NetServer Legacy COM Port Decoder
 	121c  NetServer PCI COM Port Decoder
+	1229  zx1 SBA
+	122a  zx1 SBA(IOC)
+	122e  zx1 LBA
 	2910  E2910A
 	2925  E2925A
 103e  Solliday Engineering
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/scsi/megaraid.c linux/drivers/scsi/megaraid.c
--- ../ia64/linux/drivers/scsi/megaraid.c	Fri Jan 25 13:11:27 2002
+++ linux/drivers/scsi/megaraid.c	Fri May  3 01:30:43 2002
@@ -2032,9 +2032,6 @@
 
 
 #if DEBUG
-static unsigned int cum_time = 0;
-static unsigned int cum_time_cnt = 0;
-
 static void showMbox (mega_scb * pScb)
 {
 	mega_mailbox *mbox;
@@ -2043,7 +2040,7 @@
 		return;
 
 	mbox = (mega_mailbox *) pScb->mboxData;
-	printk ("%u cmd:%x id:%x #scts:%x lba:%x addr:%x logdrv:%x #sg:%x\n",
+	printk ("%lu cmd:%x id:%x #scts:%x lba:%x addr:%x logdrv:%x #sg:%x\n",
 		pScb->SCpnt->pid,
 		mbox->cmd, mbox->cmdid, mbox->numsectors,
 		mbox->lba, mbox->xferaddr, mbox->logdrv, mbox->numsgelements);
@@ -2288,10 +2285,6 @@
 	phys_mbox = virt_to_bus (megaCfg->mbox);
 #endif
 
-#if DEBUG
-	ShowMbox (pScb);
-#endif
-
 	/* Wait until mailbox is free */
 	if (mega_busyWaitMbox (megaCfg)) {
 		printk ("Blocked mailbox......!!\n");
@@ -3032,9 +3025,7 @@
 					    sizeof (mega_mailbox64),
 					    &(megaCfg->dma_handle64));
 
-		mega_register_mailbox (megaCfg,
-				       virt_to_bus ((void *) megaCfg->
-						    mailbox64ptr));
+		mega_register_mailbox (megaCfg, megaCfg->dma_handle64);
 #else
 		mega_register_mailbox (megaCfg,
 				       virt_to_bus ((void *) &megaCfg->
@@ -3355,9 +3346,13 @@
 	mbox[0] = IS_BIOS_ENABLED;
 	mbox[2] = GET_BIOS;
 
-	mboxpnt->xferaddr = virt_to_bus ((void *) megacfg->mega_buffer);
+	mboxpnt->xferaddr = pci_map_single(megacfg->dev,
+				(void *) megacfg->mega_buffer, (2 * 1024L),
+				PCI_DMA_FROMDEVICE);
 
 	ret = megaIssueCmd (megacfg, mbox, NULL, 0);
+
+	pci_unmap_single(megacfg->dev, mboxpnt->xferaddr, 2 * 1024L, PCI_DMA_FROMDEVICE);
 
 	return (*(char *) megacfg->mega_buffer);
 }
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/drivers/scsi/sym53c8xx.c linux/drivers/scsi/sym53c8xx.c
--- ../ia64/linux/drivers/scsi/sym53c8xx.c	Fri Jan 25 13:11:27 2002
+++ linux/drivers/scsi/sym53c8xx.c	Fri Apr 12 09:09:37 2002
@@ -12951,10 +12951,16 @@
 	j = 0;
 	count = 0;
 	pcidev = PCIDEV_NULL;
-	while (1) {
+#if 0
+	while (1)
+#else
+	pci_for_each_dev(pcidev)
+#endif
+	{
 		char *msg = "";
 		if (count >= hosts)
 			break;
+#if 0
 		if (j >= chips)
 			break;
 		i = driver_setup.reverse_probe ? chips - 1 - j : j;
@@ -12964,6 +12970,19 @@
 			++j;
 			continue;
 		}
+#else
+		if (pcidev->vendor != PCI_VENDOR_ID_NCR)
+			continue;
+
+		for (i=0; i < chips; i++) {
+			if (pcidev->device == ncr_chip_ids[i])
+				break;
+		}
+
+		if (i >= chips)
+			continue;
+#endif
+
 		if (pci_enable_device(pcidev)) /* @!*!$&*!%-*#;! */
 			continue;
 		/* Some HW as the HP LH4 may report twice PCI devices */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/fs/partitions/efi.c linux/fs/partitions/efi.c
--- ../ia64/linux/fs/partitions/efi.c	Fri Jan 25 13:11:34 2002
+++ linux/fs/partitions/efi.c	Thu Feb 14 10:03:20 2002
@@ -549,10 +549,14 @@
 
 		*gpt = pgpt;
 		*ptes = pptes;
-		if (agpt)
+		if (agpt) {
 			kfree(agpt);
-		if (aptes)
+			agpt = NULL;
+		}
+		if (aptes) {
 			kfree(aptes);
+			aptes = NULL;
+		}
 	} /* if primary is valid */
 	else {
 		/* Primary GPT is bad, check the Alternate GPT */
@@ -602,6 +606,8 @@
 	/* Both primary and alternate GPTs are bad, and/or PMBR is invalid.
 	 * This isn't our disk, return 0.
 	 */
+	*gpt = *ptes = NULL;
+
 	if (pgpt) {
 		kfree(pgpt);
 		pgpt = NULL;
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/acpi-ext.h linux/include/asm-ia64/acpi-ext.h
--- ../ia64/linux/include/asm-ia64/acpi-ext.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/acpi-ext.h	Mon Apr  8 19:31:19 2002
@@ -319,5 +319,96 @@
 #define ACPI_SLIT_LOCAL 10
 #endif /* CONFIG_DISCONTIGMEM */
 
+/*
+ * ACPI Specification Rev 2.0 for the Generic Address Structure (GAS)
+ */
+typedef struct
+{
+	u8   address_space_id;       /* Address space where struct or register exists. */
+	u8   register_bit_width;     /* Size in bits of given register */
+	u8   register_bit_offset;    /* Bit offset within the register */
+	u8   reserved;               /* Must be 0 */
+	u64  address;                /* 64-bit address of struct or register */
+} acpi20_gen_addr_t;
+
+
+/*
+ * ACPI Specification Rev 2.0 for the Fixed ACPI Description Table
+ */
+typedef struct
+{
+	acpi_desc_table_hdr_t  header;             /* table header */
+	u32                    V1_firmware_ctrl;   /* 32-bit physical address of FACS */
+	u32                    V1_dsdt;            /* 32-bit physical address of DSDT */
+	u8                     reserved1;          /* System Interrupt Model isn't used in ACPI 2.0*/
+	u8                     prefer_PM_profile;  /* Conveys preferred power management profile to OSPM. */
+	u16                    sci_int;            /* System vector of SCI interrupt */
+	u32                    smi_cmd;            /* Port address of SMI command port */
+	u8                     acpi_enable;        /* value to write to smi_cmd to enable ACPI */
+	u8                     acpi_disable;       /* value to write to smi_cmd to disable ACPI */
+	u8                     S4bios_req;         /* Value to write to SMI CMD to enter S4BIOS state */
+	u8                     pstate_cnt;         /* processor performance state control*/
+	u32                    V1_pm1a_evt_blk;    /* Port address of Power Mgt 1a Acpi_event Reg Blk */
+	u32                    V1_pm1b_evt_blk;    /* Port address of Power Mgt 1b Acpi_event Reg Blk */
+	u32                    V1_pm1a_cnt_blk;    /* Port address of Power Mgt 1a Control Reg Blk */
+	u32                    V1_pm1b_cnt_blk;    /* Port address of Power Mgt 1b Control Reg Blk */
+	u32                    V1_pm2_cnt_blk;     /* Port address of Power Mgt 2 Control Reg Blk */
+	u32                    V1_pm_tmr_blk;      /* Port address of Power Mgt Timer Ctrl Reg Blk */
+	u32                    V1_gpe0blk;         /* Port addr of General Purpose Acpi_event 0 Reg Blk */
+	u32                    V1_gpe1_blk;        /* Port addr of General Purpose Acpi_event 1 Reg Blk */
+	u8                     pm1_evt_len;        /* Byte Length of ports at pm1_x_evt_blk */
+	u8                     pm1_cnt_len;        /* Byte Length of ports at pm1_x_cnt_blk */
+	u8                     pm2_cnt_len;        /* Byte Length of ports at pm2_cnt_blk */
+	u8                     pm_tm_len;          /* Byte Length of ports at pm_tm_blk */
+	u8                     gpe0blk_len;        /* Byte Length of ports at gpe0_blk */
+	u8                     gpe1_blk_len;       /* Byte Length of ports at gpe1_blk */
+	u8                     gpe1_base;          /* offset in gpe model where gpe1 events start */
+	u8                     cst_cnt;            /* Support for the _CST object and C States change notification.*/
+	u16                    plvl2_lat;          /* worst case HW latency to enter/exit C2 state */
+	u16                    plvl3_lat;          /* worst case HW latency to enter/exit C3 state */
+	u16                    flush_size;         /* number of flush strides that need to be read */
+	u16                    flush_stride;       /* Processor's memory cache line width, in bytes */
+	u8                     duty_offset;        /* Processor_~Rs duty cycle index in processor's P_CNT reg*/
+	u8                     duty_width;         /* Processor_~Rs duty cycle value bit width in P_CNT register.*/
+	u8                     day_alrm;           /* index to day-of-month alarm in RTC CMOS RAM */
+	u8                     mon_alrm;           /* index to month-of-year alarm in RTC CMOS RAM */
+	u8                     century;            /* index to century in RTC CMOS RAM */
+	u16                    iapc_boot_arch;     /* IA-PC Boot Architecture Flags. See Table 5-10 for description*/
+	u8                     reserved2;          /* reserved */
+	u32                    wb_invd     : 1;    /* wbinvd instruction works properly */
+	u32                    wb_invd_flush : 1;  /* wbinvd flushes but does not invalidate */
+	u32                    proc_c1     : 1;    /* all processors support C1 state */
+	u32                    plvl2_up    : 1;    /* C2 state works on MP system */
+	u32                    pwr_button  : 1;    /* Power button is handled as a generic feature */
+	u32                    sleep_button : 1;   /* Sleep button is handled as a generic feature, or not present */
+	u32                    fixed_rTC   : 1;    /* RTC wakeup stat not in fixed register space */
+	u32                    rtcs4       : 1;    /* RTC wakeup stat not possible from S4 */
+	u32                    tmr_val_ext : 1;    /* tmr_val is 32 bits */
+	u32                    dock_cap    : 1;    /* Supports Docking */
+	u32                    reset_reg_sup : 1;  /* Indicates system supports system reset via the FADT RESET_REG*/
+	u32                    sealed_case : 1;    /* Indicates system has no internal expansion capabilities and case is sealed. */
+	u32                    headless    : 1;    /* Indicates system does not have local video capabilities or local input devices.*/
+	u32                    cpu_sw_sleep : 1;   /* Indicates to OSPM that a processor native instruction */
+	/* must be executed after writing the SLP_TYPx register. */
+	u32                    reserved6   : 18;   /* reserved - must be zero */
+
+	acpi20_gen_addr_t      reset_register;     /* Reset register address in GAS format */
+	u8                     reset_value;        /* Value to write to the Reset_register port to reset the system. */
+	u8                     reserved7[3];       /* These three bytes must be zero */
+	u64                    Xfirmware_ctrl;     /* 64-bit physical address of FACS */
+	u64                    Xdsdt;              /* 64-bit physical address of DSDT */
+	acpi20_gen_addr_t      Xpm1a_evt_blk;      /* Extended Power Mgt 1a Acpi_event Reg Blk address */
+	acpi20_gen_addr_t      Xpm1b_evt_blk;      /* Extended Power Mgt 1b Acpi_event Reg Blk address */
+	acpi20_gen_addr_t      Xpm1a_cnt_blk;      /* Extended Power Mgt 1a Control Reg Blk address */
+	acpi20_gen_addr_t      Xpm1b_cnt_blk;      /* Extended Power Mgt 1b Control Reg Blk address */
+	acpi20_gen_addr_t      Xpm2_cnt_blk;       /* Extended Power Mgt 2 Control Reg Blk address */
+	acpi20_gen_addr_t      Xpm_tmr_blk;        /* Extended Power Mgt Timer Ctrl Reg Blk address */
+	acpi20_gen_addr_t      Xgpe0blk;           /* Extended General Purpose Acpi_event 0 Reg Blk address */
+	acpi20_gen_addr_t      Xgpe1_blk;          /* Extended General Purpose Acpi_event 1 Reg Blk address */
+}  acpi20_fadt_t;
+
+#define ACPI_FADT_SIG	"FACP"
+#define ACPI_FADT_SIG_LEN  4
+
 #pragma	pack()
 #endif /* _ASM_IA64_ACPI_EXT_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/checksum.h linux/include/asm-ia64/checksum.h
--- ../ia64/linux/include/asm-ia64/checksum.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/checksum.h	Fri Feb  1 17:55:17 2002
@@ -89,11 +89,4 @@
 	return ~sum;
 }
 
-#define _HAVE_ARCH_IPV6_CSUM
-extern unsigned short int csum_ipv6_magic (struct in6_addr *saddr,
-					   struct in6_addr *daddr,
-					   __u16 len,
-					   unsigned short proto,
-					   unsigned int sum);
-
 #endif /* _ASM_IA64_CHECKSUM_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/efi.h linux/include/asm-ia64/efi.h
--- ../ia64/linux/include/asm-ia64/efi.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/efi.h	Fri Mar 22 16:41:23 2002
@@ -181,6 +181,9 @@
 #define SAL_SYSTEM_TABLE_GUID    \
     ((efi_guid_t) { 0xeb9d2d32, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }})
 
+#define HCDP_TABLE_GUID	\
+    ((efi_guid_t) { 0xf951938d, 0x620b, 0x42ef, {0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98}})
+
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
@@ -215,6 +218,7 @@
 	void *acpi20;			/* ACPI table  (ACPI 2.0) */
 	void *smbios;			/* SM BIOS table */
 	void *sal_systab;		/* SAL system table */
+	void *hcdp;			/* HCDP table */
 	void *boot_info;		/* boot info table */
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
@@ -239,6 +243,8 @@
 extern void efi_gettimeofday (struct timeval *tv);
 extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if possible */
 extern u64  efi_get_iobase (void);
+extern u32  efi_mem_type (u64 phys_addr);
+extern u64  efi_mem_attributes (u64 phys_addr);
 
 /*
  * Variable Attributes
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/hcdp_serial.h linux/include/asm-ia64/hcdp_serial.h
--- ../ia64/linux/include/asm-ia64/hcdp_serial.h	Wed Dec 31 17:00:00 1969
+++ linux/include/asm-ia64/hcdp_serial.h	Mon Mar 25 15:05:23 2002
@@ -0,0 +1,84 @@
+/*
+ *  linux/include/asm-ia64/hcdp_serial.h
+ *
+ *  Copyright (C) 2002  Hewlett-Packard Co.
+ *  Copyright (C) 2002  Khalid Aziz <khalid_aziz@hp.com>
+ *
+ *  Definitions for HCDP defined serial ports (Serial console and 
+ *  debug ports)
+ *
+ */
+#ifndef _ASM_IA64_HCDP_SERIAL_H
+#define _ASM_IA64_HCDP_SERIAL_H
+
+/* ACPI table signatures */
+#define HCDP_SIG_LEN		4
+#define HCDP_SIGNATURE		"HCDP"
+
+/* Space ID as defined in ACPI generic address structure */
+#define ACPI_MEM_SPACE		0
+#define ACPI_IO_SPACE		1
+#define ACPI_PCICONF_SPACE	2
+
+/* 
+ * Maximum number of HCDP devices we want to read in
+ */
+#define MAX_HCDP_DEVICES	6
+
+/*
+ * Default base baud rate if clock rate is 0 in HCDP table.
+ */
+#define DEFAULT_BAUD_BASE	115200
+
+/* 
+ * ACPI Generic Address Structure 
+ */
+typedef struct {
+	u8  space_id;
+	u8  bit_width;
+	u8  bit_offset;
+	u8  resv;
+	u32 addrlo;
+	u32 addrhi;
+} acpi_gen_addr;
+
+/* HCDP Device descriptor entry types */
+#define HCDP_DEV_CONSOLE	0
+#define HCDP_DEV_DEBUG		1
+
+/* HCDP Device descriptor type */
+typedef struct {
+	u8	type;
+	u8	bits;
+	u8	parity;
+	u8	stop_bits;
+	u8	pci_seg;
+	u8	pci_bus;
+	u8	pci_dev;
+	u8	pci_func;
+	u64	baud;
+	acpi_gen_addr	base_addr;
+	u16	pci_dev_id;
+	u16	pci_vendor_id;
+	u32	global_int;
+	u32	clock_rate;
+	u8	pci_prog_intfc;
+	u8	resv;
+} hcdp_dev_t;
+
+/* HCDP Table format */
+typedef struct {
+	u8	signature[4];
+	u32	len;
+	u8	rev;
+	u8	chksum;
+	u8	oemid[6];
+	u8	oem_tabid[8];
+	u32	oem_rev;
+	u8	creator_id[4];
+	u32	creator_rev;
+	u32	num_entries;
+	hcdp_dev_t	hcdp_dev[MAX_HCDP_DEVICES];
+} hcdp_t;
+
+#endif	/* _ASM_IA64_HCDP_SERIAL_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/hw_irq.h linux/include/asm-ia64/hw_irq.h
--- ../ia64/linux/include/asm-ia64/hw_irq.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/hw_irq.h	Mon Apr  8 19:09:55 2002
@@ -67,6 +67,8 @@
 
 extern __u8 isa_irq_to_vector_map[16];
 #define isa_irq_to_vector(x)	isa_irq_to_vector_map[(x)]
+extern __u8 gsi_irq_to_vector_map[255];
+#define gsi_irq_to_vector(x)	gsi_irq_to_vector_map[(x)]
 
 extern unsigned long ipi_base_addr;
 
@@ -88,6 +90,7 @@
 
 extern struct irq_desc _irq_desc[NR_IRQS];
 
+#ifndef CONFIG_IA64_GENERIC
 static inline struct irq_desc *
 __ia64_irq_desc (unsigned int irq)
 {
@@ -105,6 +108,7 @@
 {
 	return (unsigned int) vec;
 }
+#endif
 
 /*
  * Next follows the irq descriptor interface.  On IA-64, each CPU supports 256 interrupt
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/io.h linux/include/asm-ia64/io.h
--- ../ia64/linux/include/asm-ia64/io.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/io.h	Fri Feb  1 17:55:17 2002
@@ -408,5 +408,12 @@
 #define memset_io(addr,c,len) \
   __ia64_memset_c_io((unsigned long)(addr),0x0101010101010101UL*(u8)(c),(len))
 
+/* dma_cache* interface deprecated - replaced by PCI DMA mapping
+ * (So far, only CONFIG_IEEE1394 seems to use dma_cache* for IA64)
+ */
+#define dma_cache_inv(_start,_size)		do { } while (0)
+#define dma_cache_wback(_start,_size)		do { } while (0)
+#define dma_cache_wback_inv(_start,_size)	do { } while (0)
+
 # endif /* __KERNEL__ */
 #endif /* _ASM_IA64_IO_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/machvec.h linux/include/asm-ia64/machvec.h
--- ../ia64/linux/include/asm-ia64/machvec.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/machvec.h	Sun Mar 10 19:06:07 2002
@@ -67,6 +67,8 @@
 #  include <asm/machvec_hpsim.h>
 # elif defined (CONFIG_IA64_DIG)
 #  include <asm/machvec_dig.h>
+# elif defined (CONFIG_IA64_HP_ZX1)
+#  include <asm/machvec_hpzx1.h>
 # elif defined (CONFIG_IA64_SGI_SN1)
 #  include <asm/machvec_sn1.h>
 # elif defined (CONFIG_IA64_SGI_SN2)
@@ -121,6 +123,7 @@
 	ia64_mv_cmci_handler_t *cmci_handler;
 	ia64_mv_log_print_t *log_print;
 	ia64_mv_send_ipi_t *send_ipi;
+	ia64_mv_global_tlb_purge_t *global_tlb_purge;
 	ia64_mv_pci_dma_init *dma_init;
 	ia64_mv_pci_alloc_consistent *alloc_consistent;
 	ia64_mv_pci_free_consistent *free_consistent;
@@ -146,6 +149,7 @@
 {						\
 	#name,					\
 	platform_setup,				\
+	platform_cpu_init,			\
 	platform_irq_init,			\
 	platform_pci_fixup,			\
 	platform_map_nr,			\
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/machvec_dig.h linux/include/asm-ia64/machvec_dig.h
--- ../ia64/linux/include/asm-ia64/machvec_dig.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/machvec_dig.h	Sun Mar 10 19:06:07 2002
@@ -13,10 +13,10 @@
  * platform's machvec structure.  When compiling a non-generic kernel,
  * the macros are used directly.
  */
-#define platform_name		"dig"
-#define platform_setup		dig_setup
-#define platform_irq_init	dig_irq_init
-#define platform_pci_fixup	iosapic_pci_fixup
-#define platform_map_nr		map_nr_dense
+#define platform_name                  "dig"
+#define platform_setup                 dig_setup
+#define platform_irq_init              dig_irq_init
+#define platform_pci_fixup             iosapic_pci_fixup
+#define platform_map_nr                map_nr_dense
 
 #endif /* _ASM_IA64_MACHVEC_DIG_h */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/machvec_hpzx1.h linux/include/asm-ia64/machvec_hpzx1.h
--- ../ia64/linux/include/asm-ia64/machvec_hpzx1.h	Wed Dec 31 17:00:00 1969
+++ linux/include/asm-ia64/machvec_hpzx1.h	Sun Mar 10 19:03:48 2002
@@ -0,0 +1,37 @@
+#ifndef _ASM_IA64_MACHVEC_HPZX1_h
+#define _ASM_IA64_MACHVEC_HPZX1_h
+
+extern ia64_mv_setup_t dig_setup;
+extern ia64_mv_pci_fixup_t hpzx1_pci_fixup;
+extern ia64_mv_map_nr_t map_nr_dense;
+extern ia64_mv_pci_alloc_consistent sba_alloc_consistent;
+extern ia64_mv_pci_free_consistent sba_free_consistent;
+extern ia64_mv_pci_map_single sba_map_single;
+extern ia64_mv_pci_unmap_single sba_unmap_single;
+extern ia64_mv_pci_map_sg sba_map_sg;
+extern ia64_mv_pci_unmap_sg sba_unmap_sg;
+extern ia64_mv_pci_dma_address sba_dma_address;
+
+/*
+ * This stuff has dual use!
+ *
+ * For a generic kernel, the macros are used to initialize the
+ * platform's machvec structure.  When compiling a non-generic kernel,
+ * the macros are used directly.
+ */
+#define platform_name			"hpzx1"
+#define platform_setup			dig_setup
+#define platform_pci_fixup		hpzx1_pci_fixup
+#define platform_map_nr			map_nr_dense
+#define platform_pci_dma_init		((ia64_mv_pci_dma_init *) machvec_noop)
+#define platform_pci_alloc_consistent	sba_alloc_consistent
+#define platform_pci_free_consistent	sba_free_consistent
+#define platform_pci_map_single		sba_map_single
+#define platform_pci_unmap_single	sba_unmap_single
+#define platform_pci_map_sg		sba_map_sg
+#define platform_pci_unmap_sg		sba_unmap_sg
+#define platform_pci_dma_sync_single	((ia64_mv_pci_dma_sync_single *) machvec_noop)
+#define platform_pci_dma_sync_sg	((ia64_mv_pci_dma_sync_sg *) machvec_noop)
+#define platform_pci_dma_address	sba_dma_address
+
+#endif /* _ASM_IA64_MACHVEC_HPZX1_h */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/machvec_init.h linux/include/asm-ia64/machvec_init.h
--- ../ia64/linux/include/asm-ia64/machvec_init.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/machvec_init.h	Tue Feb 26 13:21:28 2002
@@ -5,6 +5,11 @@
 #include <asm/machvec.h>
 
 extern ia64_mv_send_ipi_t ia64_send_ipi;
+extern ia64_mv_global_tlb_purge_t ia64_global_tlb_purge;
+extern ia64_mv_irq_desc __ia64_irq_desc;
+extern ia64_mv_irq_to_vector __ia64_irq_to_vector;
+extern ia64_mv_local_vector_to_irq __ia64_local_vector_to_irq;
+
 extern ia64_mv_inb_t __ia64_inb;
 extern ia64_mv_inw_t __ia64_inw;
 extern ia64_mv_inl_t __ia64_inl;
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/offsets.h linux/include/asm-ia64/offsets.h
--- ../ia64/linux/include/asm-ia64/offsets.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/offsets.h	Wed Dec 31 17:00:00 1969
@@ -1,141 +0,0 @@
-#ifndef _ASM_IA64_OFFSETS_H
-#define _ASM_IA64_OFFSETS_H
-/*
- * DO NOT MODIFY
- *
- * This file was generated by arch/ia64/tools/print_offsets.awk.
- *
- */
-#define PT_PTRACED_BIT		0
-#define PT_TRACESYS_BIT		1
-#define IA64_TASK_SIZE			3936	/* 0xf60 */
-#define IA64_PT_REGS_SIZE		400	/* 0x190 */
-#define IA64_SWITCH_STACK_SIZE		560	/* 0x230 */
-#define IA64_SIGINFO_SIZE		128	/* 0x80 */
-#define IA64_CPU_SIZE			16384	/* 0x4000 */
-#define SIGFRAME_SIZE			2816	/* 0xb00 */
-#define UNW_FRAME_INFO_SIZE		448	/* 0x1c0 */
-
-#define IA64_TASK_PTRACE_OFFSET		48	/* 0x30 */
-#define IA64_TASK_SIGPENDING_OFFSET	16	/* 0x10 */
-#define IA64_TASK_NEED_RESCHED_OFFSET	40	/* 0x28 */
-#define IA64_TASK_PROCESSOR_OFFSET	96	/* 0x60 */
-#define IA64_TASK_THREAD_OFFSET		1488	/* 0x5d0 */
-#define IA64_TASK_THREAD_KSP_OFFSET	1488	/* 0x5d0 */
-#define IA64_TASK_PFM_MUST_BLOCK_OFFSET	2112	/* 0x840 */
-#define IA64_TASK_PID_OFFSET		228	/* 0xe4 */
-#define IA64_TASK_MM_OFFSET		88	/* 0x58 */
-#define IA64_PT_REGS_CR_IPSR_OFFSET	0	/* 0x0 */
-#define IA64_PT_REGS_CR_IIP_OFFSET	8	/* 0x8 */
-#define IA64_PT_REGS_CR_IFS_OFFSET	16	/* 0x10 */
-#define IA64_PT_REGS_AR_UNAT_OFFSET	24	/* 0x18 */
-#define IA64_PT_REGS_AR_PFS_OFFSET	32	/* 0x20 */
-#define IA64_PT_REGS_AR_RSC_OFFSET	40	/* 0x28 */
-#define IA64_PT_REGS_AR_RNAT_OFFSET	48	/* 0x30 */
-#define IA64_PT_REGS_AR_BSPSTORE_OFFSET	56	/* 0x38 */
-#define IA64_PT_REGS_PR_OFFSET		64	/* 0x40 */
-#define IA64_PT_REGS_B6_OFFSET		72	/* 0x48 */
-#define IA64_PT_REGS_LOADRS_OFFSET	80	/* 0x50 */
-#define IA64_PT_REGS_R1_OFFSET		88	/* 0x58 */
-#define IA64_PT_REGS_R2_OFFSET		96	/* 0x60 */
-#define IA64_PT_REGS_R3_OFFSET		104	/* 0x68 */
-#define IA64_PT_REGS_R12_OFFSET		112	/* 0x70 */
-#define IA64_PT_REGS_R13_OFFSET		120	/* 0x78 */
-#define IA64_PT_REGS_R14_OFFSET		128	/* 0x80 */
-#define IA64_PT_REGS_R15_OFFSET		136	/* 0x88 */
-#define IA64_PT_REGS_R8_OFFSET		144	/* 0x90 */
-#define IA64_PT_REGS_R9_OFFSET		152	/* 0x98 */
-#define IA64_PT_REGS_R10_OFFSET		160	/* 0xa0 */
-#define IA64_PT_REGS_R11_OFFSET		168	/* 0xa8 */
-#define IA64_PT_REGS_R16_OFFSET		176	/* 0xb0 */
-#define IA64_PT_REGS_R17_OFFSET		184	/* 0xb8 */
-#define IA64_PT_REGS_R18_OFFSET		192	/* 0xc0 */
-#define IA64_PT_REGS_R19_OFFSET		200	/* 0xc8 */
-#define IA64_PT_REGS_R20_OFFSET		208	/* 0xd0 */
-#define IA64_PT_REGS_R21_OFFSET		216	/* 0xd8 */
-#define IA64_PT_REGS_R22_OFFSET		224	/* 0xe0 */
-#define IA64_PT_REGS_R23_OFFSET		232	/* 0xe8 */
-#define IA64_PT_REGS_R24_OFFSET		240	/* 0xf0 */
-#define IA64_PT_REGS_R25_OFFSET		248	/* 0xf8 */
-#define IA64_PT_REGS_R26_OFFSET		256	/* 0x100 */
-#define IA64_PT_REGS_R27_OFFSET		264	/* 0x108 */
-#define IA64_PT_REGS_R28_OFFSET		272	/* 0x110 */
-#define IA64_PT_REGS_R29_OFFSET		280	/* 0x118 */
-#define IA64_PT_REGS_R30_OFFSET		288	/* 0x120 */
-#define IA64_PT_REGS_R31_OFFSET		296	/* 0x128 */
-#define IA64_PT_REGS_AR_CCV_OFFSET	304	/* 0x130 */
-#define IA64_PT_REGS_AR_FPSR_OFFSET	312	/* 0x138 */
-#define IA64_PT_REGS_B0_OFFSET		320	/* 0x140 */
-#define IA64_PT_REGS_B7_OFFSET		328	/* 0x148 */
-#define IA64_PT_REGS_F6_OFFSET		336	/* 0x150 */
-#define IA64_PT_REGS_F7_OFFSET		352	/* 0x160 */
-#define IA64_PT_REGS_F8_OFFSET		368	/* 0x170 */
-#define IA64_PT_REGS_F9_OFFSET		384	/* 0x180 */
-#define IA64_SWITCH_STACK_CALLER_UNAT_OFFSET 0	/* 0x0 */
-#define IA64_SWITCH_STACK_AR_FPSR_OFFSET 8	/* 0x8 */
-#define IA64_SWITCH_STACK_F2_OFFSET	16	/* 0x10 */
-#define IA64_SWITCH_STACK_F3_OFFSET	32	/* 0x20 */
-#define IA64_SWITCH_STACK_F4_OFFSET	48	/* 0x30 */
-#define IA64_SWITCH_STACK_F5_OFFSET	64	/* 0x40 */
-#define IA64_SWITCH_STACK_F10_OFFSET	80	/* 0x50 */
-#define IA64_SWITCH_STACK_F11_OFFSET	96	/* 0x60 */
-#define IA64_SWITCH_STACK_F12_OFFSET	112	/* 0x70 */
-#define IA64_SWITCH_STACK_F13_OFFSET	128	/* 0x80 */
-#define IA64_SWITCH_STACK_F14_OFFSET	144	/* 0x90 */
-#define IA64_SWITCH_STACK_F15_OFFSET	160	/* 0xa0 */
-#define IA64_SWITCH_STACK_F16_OFFSET	176	/* 0xb0 */
-#define IA64_SWITCH_STACK_F17_OFFSET	192	/* 0xc0 */
-#define IA64_SWITCH_STACK_F18_OFFSET	208	/* 0xd0 */
-#define IA64_SWITCH_STACK_F19_OFFSET	224	/* 0xe0 */
-#define IA64_SWITCH_STACK_F20_OFFSET	240	/* 0xf0 */
-#define IA64_SWITCH_STACK_F21_OFFSET	256	/* 0x100 */
-#define IA64_SWITCH_STACK_F22_OFFSET	272	/* 0x110 */
-#define IA64_SWITCH_STACK_F23_OFFSET	288	/* 0x120 */
-#define IA64_SWITCH_STACK_F24_OFFSET	304	/* 0x130 */
-#define IA64_SWITCH_STACK_F25_OFFSET	320	/* 0x140 */
-#define IA64_SWITCH_STACK_F26_OFFSET	336	/* 0x150 */
-#define IA64_SWITCH_STACK_F27_OFFSET	352	/* 0x160 */
-#define IA64_SWITCH_STACK_F28_OFFSET	368	/* 0x170 */
-#define IA64_SWITCH_STACK_F29_OFFSET	384	/* 0x180 */
-#define IA64_SWITCH_STACK_F30_OFFSET	400	/* 0x190 */
-#define IA64_SWITCH_STACK_F31_OFFSET	416	/* 0x1a0 */
-#define IA64_SWITCH_STACK_R4_OFFSET	432	/* 0x1b0 */
-#define IA64_SWITCH_STACK_R5_OFFSET	440	/* 0x1b8 */
-#define IA64_SWITCH_STACK_R6_OFFSET	448	/* 0x1c0 */
-#define IA64_SWITCH_STACK_R7_OFFSET	456	/* 0x1c8 */
-#define IA64_SWITCH_STACK_B0_OFFSET	464	/* 0x1d0 */
-#define IA64_SWITCH_STACK_B1_OFFSET	472	/* 0x1d8 */
-#define IA64_SWITCH_STACK_B2_OFFSET	480	/* 0x1e0 */
-#define IA64_SWITCH_STACK_B3_OFFSET	488	/* 0x1e8 */
-#define IA64_SWITCH_STACK_B4_OFFSET	496	/* 0x1f0 */
-#define IA64_SWITCH_STACK_B5_OFFSET	504	/* 0x1f8 */
-#define IA64_SWITCH_STACK_AR_PFS_OFFSET	512	/* 0x200 */
-#define IA64_SWITCH_STACK_AR_LC_OFFSET	520	/* 0x208 */
-#define IA64_SWITCH_STACK_AR_UNAT_OFFSET 528	/* 0x210 */
-#define IA64_SWITCH_STACK_AR_RNAT_OFFSET 536	/* 0x218 */
-#define IA64_SWITCH_STACK_AR_BSPSTORE_OFFSET 544	/* 0x220 */
-#define IA64_SWITCH_STACK_PR_OFFSET	552	/* 0x228 */
-#define IA64_SIGCONTEXT_AR_BSP_OFFSET	72	/* 0x48 */
-#define IA64_SIGCONTEXT_AR_FPSR_OFFSET	104	/* 0x68 */
-#define IA64_SIGCONTEXT_AR_RNAT_OFFSET	80	/* 0x50 */
-#define IA64_SIGCONTEXT_AR_UNAT_OFFSET	96	/* 0x60 */
-#define IA64_SIGCONTEXT_B0_OFFSET	136	/* 0x88 */
-#define IA64_SIGCONTEXT_CFM_OFFSET	48	/* 0x30 */
-#define IA64_SIGCONTEXT_FLAGS_OFFSET	0	/* 0x0 */
-#define IA64_SIGCONTEXT_FR6_OFFSET	560	/* 0x230 */
-#define IA64_SIGCONTEXT_PR_OFFSET	128	/* 0x80 */
-#define IA64_SIGCONTEXT_R12_OFFSET	296	/* 0x128 */
-#define IA64_SIGCONTEXT_RBS_BASE_OFFSET	2512	/* 0x9d0 */
-#define IA64_SIGCONTEXT_LOADRS_OFFSET	2520	/* 0x9d8 */
-#define IA64_SIGFRAME_ARG0_OFFSET	0	/* 0x0 */
-#define IA64_SIGFRAME_ARG1_OFFSET	8	/* 0x8 */
-#define IA64_SIGFRAME_ARG2_OFFSET	16	/* 0x10 */
-#define IA64_SIGFRAME_HANDLER_OFFSET	24	/* 0x18 */
-#define IA64_SIGFRAME_SIGCONTEXT_OFFSET	160	/* 0xa0 */
-#define IA64_CLONE_VFORK		16384	/* 0x4000 */
-#define IA64_CLONE_VM			256	/* 0x100 */
-#define IA64_CPU_IRQ_COUNT_OFFSET	0	/* 0x0 */
-#define IA64_CPU_BH_COUNT_OFFSET	4	/* 0x4 */
-#define IA64_CPU_PHYS_STACKED_SIZE_P8_OFFSET 12	/* 0xc */
-
-#endif /* _ASM_IA64_OFFSETS_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/page.h linux/include/asm-ia64/page.h
--- ../ia64/linux/include/asm-ia64/page.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/page.h	Tue Apr  9 05:01:45 2002
@@ -55,7 +55,7 @@
 #ifdef CONFIG_IA64_GENERIC
 # include <asm/machvec.h>
 # define virt_to_page(kaddr)	(mem_map + platform_map_nr(kaddr))
-# define page_to_phys(page)	XXX fix me
+# define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
 #elif defined (CONFIG_IA64_SGI_SN1)
 # ifndef CONFIG_DISCONTIGMEM
 #  define virt_to_page(kaddr)	(mem_map + MAP_NR_DENSE(kaddr))
@@ -65,7 +65,9 @@
 # define virt_to_page(kaddr)	(mem_map + MAP_NR_DENSE(kaddr))
 # define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
 #endif
-#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
+
+#define VALID_PAGE(page)	(((page - mem_map) < max_mapnr) \
+				&& ia64_page_valid(page))
 
 typedef union ia64_va {
 	struct {
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/pgtable.h linux/include/asm-ia64/pgtable.h
--- ../ia64/linux/include/asm-ia64/pgtable.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/pgtable.h	Tue Apr  9 05:01:45 2002
@@ -214,7 +214,10 @@
 
 #define VMALLOC_START		(0xa000000000000000 + 3*PAGE_SIZE)
 #define VMALLOC_VMADDR(x)	((unsigned long)(x))
-#define VMALLOC_END		(0xa000000000000000 + (1UL << (4*PAGE_SHIFT - 9)))
+#define VMALLOC_END_INIT        (0xa000000000000000 + (1UL << (4*PAGE_SHIFT - 9))) 
+#define VMALLOC_END             vmalloc_end
+
+extern unsigned long vmalloc_end;
 
 /*
  * Conversion functions: convert a page and protection to a page entry,
@@ -474,6 +477,25 @@
  */
 #define pgtable_cache_init()	do { } while (0)
 
+extern int ia64_page_valid(struct page *page);
+
+#define HAVE_ARCH_MEMMAP_INIT 
+
+#include <linux/mmzone.h>
+
+typedef void memmap_init_callback_t (struct page *start, struct page *end);
+
+extern void arch_memmap_init(memmap_init_callback_t *callback,
+                                struct page *start, struct page *end);
+
+typedef void memmap_zone_callback_t (struct page *start, struct page *end,
+                                zone_t *zone,unsigned long start_paddr,
+                                int highmem_flag);
+
+extern void arch_memmap_zone_init(memmap_zone_callback_t *callback,
+                                struct page *start, struct page *end,
+                                zone_t *zone,unsigned long start_paddr,
+                                int highmem_flag);
 # endif /* !__ASSEMBLY__ */
 
 /*
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/scatterlist.h linux/include/asm-ia64/scatterlist.h
--- ../ia64/linux/include/asm-ia64/scatterlist.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/scatterlist.h	Sun Mar 10 19:06:07 2002
@@ -10,6 +10,8 @@
 	char *address;		/* location data is to be transferred to */
 	void *page;		/* stupid: SCSI code insists on a member of this name... */
 	unsigned int length;	/* buffer length */
+	/* an IOVA can be 64-bits on IA64 platforms. */
+	char *orig_address;        /* I/O Virtual Address */
 };
 
 #define ISA_DMA_THRESHOLD	(~0UL)
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/asm-ia64/serial.h linux/include/asm-ia64/serial.h
--- ../ia64/linux/include/asm-ia64/serial.h	Fri Jan 25 13:11:37 2002
+++ linux/include/asm-ia64/serial.h	Mon Mar 25 15:12:31 2002
@@ -59,6 +59,16 @@
 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
 	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
 
+#ifdef CONFIG_ACPI
+#define ACPI_SERIAL_PORT_DEFNS	\
+	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS },		/* ttyS4 */	\
+	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS },		/* ttyS5 */
+#else
+#define ACPI_SERIAL_PORT_DEFNS
+#endif
+
+#define HCDP_SERIAL_PORT_DEFNS 	\
+	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS },		/* ttyS4 */
 
 #ifdef CONFIG_SERIAL_MANY_PORTS
 #define EXTRA_SERIAL_PORT_DEFNS			\
@@ -129,6 +139,7 @@
 
 #define SERIAL_PORT_DFNS		\
 	STD_SERIAL_PORT_DEFNS		\
+	ACPI_SERIAL_PORT_DEFNS		\
 	EXTRA_SERIAL_PORT_DEFNS		\
 	HUB6_SERIAL_PORT_DFNS		\
 	MCA_SERIAL_PORT_DFNS
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/linux/acpi.h linux/include/linux/acpi.h
--- ../ia64/linux/include/linux/acpi.h	Fri Jan 25 13:11:43 2002
+++ linux/include/linux/acpi.h	Sat Apr  6 08:32:49 2002
@@ -173,6 +173,19 @@
 
 extern unsigned long acpi_wakeup_address;
 
+#include "../../drivers/acpi/include/platform/acgcc.h"
+#include "../../drivers/acpi/include/actypes.h"
+#include "../../drivers/acpi/include/acexcep.h"
+#include "../../drivers/acpi/include/acpixf.h"
+#include "../../drivers/acpi/include/actbl.h"
+#include "../../drivers/acpi/include/acconfig.h"
+#include "../../drivers/acpi/include/acmacros.h"
+#include "../../drivers/acpi/include/aclocal.h"
+#include "../../drivers/acpi/include/acobject.h"
+#include "../../drivers/acpi/include/acstruct.h"
+#include "../../drivers/acpi/include/acnamesp.h"
+#include "../../drivers/acpi/include/acutils.h"
+
 #endif /* __KERNEL__ */
 
 int acpi_init(void);
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/linux/acpi_serial.h linux/include/linux/acpi_serial.h
--- ../ia64/linux/include/linux/acpi_serial.h	Fri Jan 25 13:11:43 2002
+++ linux/include/linux/acpi_serial.h	Fri Feb  8 13:03:39 2002
@@ -8,10 +8,13 @@
  *  debug ports)
  *
  */
+#ifndef _LINUX_ACPI_SERIAL_H
+#define _LINUX_ACPI_SERIAL_H
 
 extern void setup_serial_acpi(void *);
 
 /* ACPI table signatures */
+#define ACPI_SIG_LEN		4
 #define ACPI_SPCRT_SIGNATURE	"SPCR"
 #define ACPI_DBGPT_SIGNATURE	"DBGP"
 
@@ -101,3 +104,32 @@
 	u8  pci_seg;
 	u32 resv2;
 } acpi_ser_t;
+
+/*
+ * EFI Device path
+ */
+typedef struct {
+	__u8	type;
+	__u8	subtype;
+	__u16	len;
+} efi_device_path_t;
+
+#define EFI_DEVICE_TYPE_HW	0x01
+#define EFI_DEVICE_TYPE_ACPI	0x02
+#define EFI_DEVICE_TYPE_MSG	0x03
+#define EFI_DEVICE_TYPE_MEDIA	0x04
+#define EFI_DEVICE_TYPE_BIOS	0x05
+#define EFI_DEVICE_TYPE_END	0xff
+
+typedef struct {
+	__u8	type;
+	__u8	subtype;
+	__u16	len;
+	__u32	resvd;
+	__u64	baud;
+	__u8	bits;
+	__u8	parity;
+	__u8	stop;
+} efi_uart_path_t;
+
+#endif	/* _LINUX_ACPI_SERIAL_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/linux/agp_backend.h linux/include/linux/agp_backend.h
--- ../ia64/linux/include/linux/agp_backend.h	Fri Jan 25 13:11:43 2002
+++ linux/include/linux/agp_backend.h	Thu Mar 14 10:28:39 2002
@@ -77,7 +77,8 @@
 	ALI_GENERIC,
 	SVWRKS_HE,
 	SVWRKS_LE,
-	SVWRKS_GENERIC
+	SVWRKS_GENERIC,
+	HP_ZX1,
 };
 
 typedef struct _agp_version {
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/linux/pci_ids.h linux/include/linux/pci_ids.h
--- ../ia64/linux/include/linux/pci_ids.h	Fri Jan 25 13:11:44 2002
+++ linux/include/linux/pci_ids.h	Mon Apr  8 15:39:55 2002
@@ -504,6 +504,9 @@
 #define PCI_DEVICE_ID_HP_DIVA1		0x1049
 #define PCI_DEVICE_ID_HP_DIVA2		0x104A
 #define PCI_DEVICE_ID_HP_SP2_0		0x104B
+#define PCI_DEVICE_ID_HP_ZX1_SBA	0x1229
+#define PCI_DEVICE_ID_HP_ZX1_IOC	0x122a
+#define PCI_DEVICE_ID_HP_ZX1_LBA	0x122e
 
 #define PCI_VENDOR_ID_PCTECH		0x1042
 #define PCI_DEVICE_ID_PCTECH_RZ1000	0x1000
@@ -1486,7 +1489,11 @@
 #define PCI_VENDOR_ID_BROADCOM		0x14e4
 #define PCI_DEVICE_ID_TIGON3_5700	0x1644
 #define PCI_DEVICE_ID_TIGON3_5701	0x1645
+#define PCI_DEVICE_ID_TIGON3_5702	0x1646
 #define PCI_DEVICE_ID_TIGON3_5703	0x1647
+#define PCI_DEVICE_ID_TIGON3_5702FE	0x164d
+#define PCI_DEVICE_ID_TIGON3_5702X	0x16a6
+#define PCI_DEVICE_ID_TIGON3_5703X	0x16a7
 
 #define PCI_VENDOR_ID_SYBA		0x1592
 #define PCI_DEVICE_ID_SYBA_2P_EPP	0x0782
@@ -1500,6 +1507,9 @@
 
 #define PCI_VENDOR_ID_PDC		0x15e9
 #define PCI_DEVICE_ID_PDC_1841		0x1841
+
+#define PCI_VENDOR_ID_ALTIMA		0x173b
+#define PCI_DEVICE_ID_ALTIMA_AC1000	0x03e8
 
 #define PCI_VENDOR_ID_SYMPHONY		0x1c1c
 #define PCI_DEVICE_ID_SYMPHONY_101	0x0001
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/include/linux/serial.h linux/include/linux/serial.h
--- ../ia64/linux/include/linux/serial.h	Fri Jan 25 13:11:45 2002
+++ linux/include/linux/serial.h	Mon Mar 25 15:08:21 2002
@@ -184,9 +184,11 @@
 
 #ifdef CONFIG_ACPI
 /* tty ports reserved for the ACPI serial console port and debug port */
-#define ACPI_SERIAL_CONSOLE_PORT        4
-#define ACPI_SERIAL_DEBUG_PORT          5
+#define ACPI_SERIAL_CONSOLE_PORT 	4
+#define ACPI_SERIAL_DEBUG_PORT		5
 #endif
+/* tty ports reserved for the HCDP serial console port */
+#define HCDP_SERIAL_CONSOLE_PORT        4
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SERIAL_H */
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/init/main.c linux/init/main.c
--- ../ia64/linux/init/main.c	Fri Jan 25 13:11:46 2002
+++ linux/init/main.c	Mon Jan 28 18:10:51 2002
@@ -609,6 +609,9 @@
 #if defined(CONFIG_ARCH_S390)
 	ccwcache_init();
 #endif
+#ifdef __ia64__
+	acpi_init();
+#endif
 	signals_init();
 #ifdef CONFIG_PROC_FS
 	proc_root_init();
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/kernel/printk.c linux/kernel/printk.c
--- ../ia64/linux/kernel/printk.c	Fri Jan 25 13:11:46 2002
+++ linux/kernel/printk.c	Fri Jan 25 14:35:05 2002
@@ -697,6 +697,9 @@
 #define VGALINES	24
 #define VGACOLS		80
 
+#define UART_BASE       ((char *)0xc0000000FF5E0000)
+#include <linux/serial_reg.h>
+
 static int current_ypos = VGALINES, current_xpos = 0;
 
 void
@@ -707,6 +710,16 @@
 
 	while (len-- > 0) {
 		c = *str++;
+#ifdef CONFIG_IA64_HP_PROTO
+		while (!(UART_LSR_TEMT & readb((char *)(UART_BASE + UART_LSR))))
+			; /* spin */
+
+		writeb(c, (char *)UART_BASE + UART_TX);
+
+		if (c == '\n')
+			writeb('\r', (char *)UART_BASE + UART_TX);
+#else
+
 		if (current_ypos >= VGALINES) {
 			/* scroll 1 line up */
 			for (k = 1, j = 0; k < VGALINES; k++, j++) {
@@ -731,6 +744,7 @@
 				current_ypos++;
 			}
 		}
+#endif
 	}
 }
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/mm/bootmem.c linux/mm/bootmem.c
--- ../ia64/linux/mm/bootmem.c	Fri Jan 25 13:11:46 2002
+++ linux/mm/bootmem.c	Tue Apr 30 16:08:22 2002
@@ -110,7 +110,7 @@
 	unsigned long eidx = (addr + size - bdata->node_boot_start)/PAGE_SIZE;
 	unsigned long end = (addr + size)/PAGE_SIZE;
 
-	if (!size) BUG();
+	if (!size) return;
 	if (end > bdata->node_low_pfn)
 		BUG();
 
diff -urN --exclude-from=/home/rh-ia64/ia64/redhat/dontdiff ../ia64/linux/mm/page_alloc.c linux/mm/page_alloc.c
--- ../ia64/linux/mm/page_alloc.c	Fri Jan 25 13:11:46 2002
+++ linux/mm/page_alloc.c	Wed Jan 30 06:51:32 2002
@@ -626,6 +626,38 @@
 	} 
 }
 
+#ifdef HAVE_ARCH_MEMMAP_INIT
+#define MMI_INLINE 
+#else
+#define MMI_INLINE inline
+#endif
+
+static MMI_INLINE void memmap_init(struct page *start, struct page *end) 
+{
+	struct page *p;
+
+	for (p = start; p < end; p++) {
+		set_page_count(p, 0);
+		SetPageReserved(p);
+		init_waitqueue_head(&p->wait);
+		memlist_init(&p->list);
+	}
+}
+
+static MMI_INLINE void memmap_zone_init(struct page *start, struct page *end,
+					zone_t *zone,unsigned long start_paddr,
+					int highmem_flag)
+{
+	struct page *p;
+	
+	for (p = start; p < end; p++) {
+		p->zone = zone;
+		if (!highmem_flag)
+			p->virtual = __va(start_paddr);
+		start_paddr += PAGE_SIZE;
+	}
+}
+
 #define LONG_ALIGN(x) (((x)+(sizeof(long))-1)&~((sizeof(long))-1))
 
 /*
@@ -638,7 +670,6 @@
 	unsigned long *zones_size, unsigned long zone_start_paddr, 
 	unsigned long *zholes_size, struct page *lmem_map)
 {
-	struct page *p;
 	unsigned long i, j;
 	unsigned long map_size;
 	unsigned long totalpages, offset, realtotalpages;
@@ -686,12 +717,11 @@
 	 * up by free_all_bootmem() once the early boot process is
 	 * done.
 	 */
-	for (p = lmem_map; p < lmem_map + totalpages; p++) {
-		set_page_count(p, 0);
-		SetPageReserved(p);
-		init_waitqueue_head(&p->wait);
-		memlist_init(&p->list);
-	}
+#ifdef HAVE_ARCH_MEMMAP_INIT
+	arch_memmap_init(memmap_init,lmem_map,lmem_map + totalpages);
+#else
+	memmap_init(lmem_map,lmem_map + totalpages);
+#endif
 
 	offset = lmem_map - mem_map;	
 	for (j = 0; j < MAX_NR_ZONES; j++) {
@@ -731,12 +761,19 @@
 		if ((zone_start_paddr >> PAGE_SHIFT) & (zone_required_alignment-1))
 			printk("BUG: wrong zone alignment, it will crash\n");
 
-		for (i = 0; i < size; i++) {
-			struct page *page = mem_map + offset + i;
-			page->zone = zone;
-			if (j != ZONE_HIGHMEM)
-				page->virtual = __va(zone_start_paddr);
-			zone_start_paddr += PAGE_SIZE;
+		{
+			struct page *page = mem_map + offset;
+
+#ifdef HAVE_ARCH_MEMMAP_INIT
+			arch_memmap_zone_init(memmap_zone_init,page,page+size,
+						zone,zone_start_paddr,
+						(j == ZONE_HIGHMEM ? 1 : 0));
+#else	
+			memmap_zone_init(page,page+size,zone,
+				zone_start_paddr,(j == ZONE_HIGHMEM ? 1 : 0));
+#endif
+
+			zone_start_paddr += (size << PAGE_SHIFT);
 		}
 
 		offset += size;
